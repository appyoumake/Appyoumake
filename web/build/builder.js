/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/build/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./assets/js/builder.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./assets/js/builder.js":
/*!******************************!*\
  !*** ./assets/js/builder.js ***!
  \******************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

/* 
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

__webpack_require__(/*! script-loader!./jquery.mobile-1.4.5.js */ "./node_modules/script-loader/index.js!./assets/js/jquery.mobile-1.4.5.js");
__webpack_require__(/*! script-loader!./jquery.qrcode-0.12.0.js */ "./node_modules/script-loader/index.js!./assets/js/jquery.qrcode-0.12.0.js");
__webpack_require__(/*! script-loader!./spin.js */ "./node_modules/script-loader/index.js!./assets/js/spin.js");
__webpack_require__(/*! script-loader!./jquery.spin.js */ "./node_modules/script-loader/index.js!./assets/js/jquery.spin.js");
__webpack_require__(/*! script-loader!./mlab.api.js */ "./node_modules/script-loader/index.js!./assets/js/mlab.api.js");
__webpack_require__(/*! script-loader!./mlab.dt.api.js */ "./node_modules/script-loader/index.js!./assets/js/mlab.dt.api.js");
__webpack_require__(/*! script-loader!./mlab.dt.management.js */ "./node_modules/script-loader/index.js!./assets/js/mlab.dt.management.js");
__webpack_require__(/*! script-loader!./mlab.dt.bestpractice.js */ "./node_modules/script-loader/index.js!./assets/js/mlab.dt.bestpractice.js");
__webpack_require__(/*! script-loader!./mlab.dt.design.js */ "./node_modules/script-loader/index.js!./assets/js/mlab.dt.design.js");
__webpack_require__(/*! script-loader!./mlab.dt.utils.js */ "./node_modules/script-loader/index.js!./assets/js/mlab.dt.utils.js");
__webpack_require__(/*! script-loader!./mlab_editor.init.js */ "./node_modules/script-loader/index.js!./assets/js/mlab_editor.init.js");

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./node_modules/babel-loader/lib/index.js??ref--0-0!./assets/js/jquery.mobile-1.4.5.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/raw-loader!./node_modules/babel-loader/lib??ref--0-0!./assets/js/jquery.mobile-1.4.5.js ***!
  \**************************************************************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports) {

module.exports = "var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/*! jQuery Mobile 1.4.5 | Git HEADhash: 68e55e7 <> 2014-10-31T17:33:30Z | (c) 2010, 2014 jQuery Foundation, Inc. | jquery.org/license */\n\n!function (a, b, c) {\n  \"function\" == typeof define && define.amd ? define([\"jquery\"], function (d) {\n    return c(d, a, b), d.mobile;\n  }) : c(a.jQuery, a, b);\n}(this, document, function (a, b, c) {\n  !function (a) {\n    a.mobile = {};\n  }(a), function (a, b) {\n    function d(b, c) {\n      var d,\n          f,\n          g,\n          h = b.nodeName.toLowerCase();return \"area\" === h ? (d = b.parentNode, f = d.name, b.href && f && \"map\" === d.nodeName.toLowerCase() ? (g = a(\"img[usemap=#\" + f + \"]\")[0], !!g && e(g)) : !1) : (/input|select|textarea|button|object/.test(h) ? !b.disabled : \"a\" === h ? b.href || c : c) && e(b);\n    }function e(b) {\n      return a.expr.filters.visible(b) && !a(b).parents().addBack().filter(function () {\n        return \"hidden\" === a.css(this, \"visibility\");\n      }).length;\n    }var f = 0,\n        g = /^ui-id-\\d+$/;a.ui = a.ui || {}, a.extend(a.ui, { version: \"c0ab71056b936627e8a7821f03c044aec6280a40\", keyCode: { BACKSPACE: 8, COMMA: 188, DELETE: 46, DOWN: 40, END: 35, ENTER: 13, ESCAPE: 27, HOME: 36, LEFT: 37, PAGE_DOWN: 34, PAGE_UP: 33, PERIOD: 190, RIGHT: 39, SPACE: 32, TAB: 9, UP: 38 } }), a.fn.extend({ focus: function (b) {\n        return function (c, d) {\n          return \"number\" == typeof c ? this.each(function () {\n            var b = this;setTimeout(function () {\n              a(b).focus(), d && d.call(b);\n            }, c);\n          }) : b.apply(this, arguments);\n        };\n      }(a.fn.focus), scrollParent: function scrollParent() {\n        var b;return b = a.ui.ie && /(static|relative)/.test(this.css(\"position\")) || /absolute/.test(this.css(\"position\")) ? this.parents().filter(function () {\n          return (/(relative|absolute|fixed)/.test(a.css(this, \"position\")) && /(auto|scroll)/.test(a.css(this, \"overflow\") + a.css(this, \"overflow-y\") + a.css(this, \"overflow-x\"))\n          );\n        }).eq(0) : this.parents().filter(function () {\n          return (/(auto|scroll)/.test(a.css(this, \"overflow\") + a.css(this, \"overflow-y\") + a.css(this, \"overflow-x\"))\n          );\n        }).eq(0), /fixed/.test(this.css(\"position\")) || !b.length ? a(this[0].ownerDocument || c) : b;\n      }, uniqueId: function uniqueId() {\n        return this.each(function () {\n          this.id || (this.id = \"ui-id-\" + ++f);\n        });\n      }, removeUniqueId: function removeUniqueId() {\n        return this.each(function () {\n          g.test(this.id) && a(this).removeAttr(\"id\");\n        });\n      } }), a.extend(a.expr[\":\"], { data: a.expr.createPseudo ? a.expr.createPseudo(function (b) {\n        return function (c) {\n          return !!a.data(c, b);\n        };\n      }) : function (b, c, d) {\n        return !!a.data(b, d[3]);\n      }, focusable: function focusable(b) {\n        return d(b, !isNaN(a.attr(b, \"tabindex\")));\n      }, tabbable: function tabbable(b) {\n        var c = a.attr(b, \"tabindex\"),\n            e = isNaN(c);return (e || c >= 0) && d(b, !e);\n      } }), a(\"<a>\").outerWidth(1).jquery || a.each([\"Width\", \"Height\"], function (c, d) {\n      function e(b, c, d, e) {\n        return a.each(f, function () {\n          c -= parseFloat(a.css(b, \"padding\" + this)) || 0, d && (c -= parseFloat(a.css(b, \"border\" + this + \"Width\")) || 0), e && (c -= parseFloat(a.css(b, \"margin\" + this)) || 0);\n        }), c;\n      }var f = \"Width\" === d ? [\"Left\", \"Right\"] : [\"Top\", \"Bottom\"],\n          g = d.toLowerCase(),\n          h = { innerWidth: a.fn.innerWidth, innerHeight: a.fn.innerHeight, outerWidth: a.fn.outerWidth, outerHeight: a.fn.outerHeight };a.fn[\"inner\" + d] = function (c) {\n        return c === b ? h[\"inner\" + d].call(this) : this.each(function () {\n          a(this).css(g, e(this, c) + \"px\");\n        });\n      }, a.fn[\"outer\" + d] = function (b, c) {\n        return \"number\" != typeof b ? h[\"outer\" + d].call(this, b) : this.each(function () {\n          a(this).css(g, e(this, b, !0, c) + \"px\");\n        });\n      };\n    }), a.fn.addBack || (a.fn.addBack = function (a) {\n      return this.add(null == a ? this.prevObject : this.prevObject.filter(a));\n    }), a(\"<a>\").data(\"a-b\", \"a\").removeData(\"a-b\").data(\"a-b\") && (a.fn.removeData = function (b) {\n      return function (c) {\n        return arguments.length ? b.call(this, a.camelCase(c)) : b.call(this);\n      };\n    }(a.fn.removeData)), a.ui.ie = !!/msie [\\w.]+/.exec(navigator.userAgent.toLowerCase()), a.support.selectstart = \"onselectstart\" in c.createElement(\"div\"), a.fn.extend({ disableSelection: function disableSelection() {\n        return this.bind((a.support.selectstart ? \"selectstart\" : \"mousedown\") + \".ui-disableSelection\", function (a) {\n          a.preventDefault();\n        });\n      }, enableSelection: function enableSelection() {\n        return this.unbind(\".ui-disableSelection\");\n      }, zIndex: function zIndex(d) {\n        if (d !== b) return this.css(\"zIndex\", d);if (this.length) for (var e, f, g = a(this[0]); g.length && g[0] !== c;) {\n          if (e = g.css(\"position\"), (\"absolute\" === e || \"relative\" === e || \"fixed\" === e) && (f = parseInt(g.css(\"zIndex\"), 10), !isNaN(f) && 0 !== f)) return f;g = g.parent();\n        }return 0;\n      } }), a.ui.plugin = { add: function add(b, c, d) {\n        var e,\n            f = a.ui[b].prototype;for (e in d) {\n          f.plugins[e] = f.plugins[e] || [], f.plugins[e].push([c, d[e]]);\n        }\n      }, call: function call(a, b, c, d) {\n        var e,\n            f = a.plugins[b];if (f && (d || a.element[0].parentNode && 11 !== a.element[0].parentNode.nodeType)) for (e = 0; e < f.length; e++) {\n          a.options[f[e][0]] && f[e][1].apply(a.element, c);\n        }\n      } };\n  }(a), function (a, b) {\n    var d = function d(b, c) {\n      var d = b.parent(),\n          e = [],\n          f = function f() {\n        var b = a(this),\n            c = a.mobile.toolbar && b.data(\"mobile-toolbar\") ? b.toolbar(\"option\") : { position: b.attr(\"data-\" + a.mobile.ns + \"position\"), updatePagePadding: b.attr(\"data-\" + a.mobile.ns + \"update-page-padding\") !== !1 };return !(\"fixed\" === c.position && c.updatePagePadding === !0);\n      },\n          g = d.children(\":jqmData(role='header')\").filter(f),\n          h = b.children(\":jqmData(role='header')\"),\n          i = d.children(\":jqmData(role='footer')\").filter(f),\n          j = b.children(\":jqmData(role='footer')\");return 0 === h.length && g.length > 0 && (e = e.concat(g.toArray())), 0 === j.length && i.length > 0 && (e = e.concat(i.toArray())), a.each(e, function (b, d) {\n        c -= a(d).outerHeight();\n      }), Math.max(0, c);\n    };a.extend(a.mobile, { window: a(b), document: a(c), keyCode: a.ui.keyCode, behaviors: {}, silentScroll: function silentScroll(c) {\n        \"number\" !== a.type(c) && (c = a.mobile.defaultHomeScroll), a.event.special.scrollstart.enabled = !1, setTimeout(function () {\n          b.scrollTo(0, c), a.mobile.document.trigger(\"silentscroll\", { x: 0, y: c });\n        }, 20), setTimeout(function () {\n          a.event.special.scrollstart.enabled = !0;\n        }, 150);\n      }, getClosestBaseUrl: function getClosestBaseUrl(b) {\n        var c = a(b).closest(\".ui-page\").jqmData(\"url\"),\n            d = a.mobile.path.documentBase.hrefNoHash;return a.mobile.dynamicBaseEnabled && c && a.mobile.path.isPath(c) || (c = d), a.mobile.path.makeUrlAbsolute(c, d);\n      }, removeActiveLinkClass: function removeActiveLinkClass(b) {\n        !a.mobile.activeClickedLink || a.mobile.activeClickedLink.closest(\".\" + a.mobile.activePageClass).length && !b || a.mobile.activeClickedLink.removeClass(a.mobile.activeBtnClass), a.mobile.activeClickedLink = null;\n      }, getInheritedTheme: function getInheritedTheme(a, b) {\n        for (var c, d, e = a[0], f = \"\", g = /ui-(bar|body|overlay)-([a-z])\\b/; e && (c = e.className || \"\", !(c && (d = g.exec(c)) && (f = d[2])));) {\n          e = e.parentNode;\n        }return f || b || \"a\";\n      }, enhanceable: function enhanceable(a) {\n        return this.haveParents(a, \"enhance\");\n      }, hijackable: function hijackable(a) {\n        return this.haveParents(a, \"ajax\");\n      }, haveParents: function haveParents(b, c) {\n        if (!a.mobile.ignoreContentEnabled) return b;var d,\n            e,\n            f,\n            g,\n            h,\n            i = b.length,\n            j = a();for (g = 0; i > g; g++) {\n          for (e = b.eq(g), f = !1, d = b[g]; d;) {\n            if (h = d.getAttribute ? d.getAttribute(\"data-\" + a.mobile.ns + c) : \"\", \"false\" === h) {\n              f = !0;break;\n            }d = d.parentNode;\n          }f || (j = j.add(e));\n        }return j;\n      }, getScreenHeight: function getScreenHeight() {\n        return b.innerHeight || a.mobile.window.height();\n      }, resetActivePageHeight: function resetActivePageHeight(b) {\n        var c = a(\".\" + a.mobile.activePageClass),\n            e = c.height(),\n            f = c.outerHeight(!0);b = d(c, \"number\" == typeof b ? b : a.mobile.getScreenHeight()), c.css(\"min-height\", \"\"), c.height() < b && c.css(\"min-height\", b - (f - e));\n      }, loading: function loading() {\n        var b = this.loading._widget || a(a.mobile.loader.prototype.defaultHtml).loader(),\n            c = b.loader.apply(b, arguments);return this.loading._widget = b, c;\n      } }), a.addDependents = function (b, c) {\n      var d = a(b),\n          e = d.jqmData(\"dependents\") || a();d.jqmData(\"dependents\", a(e).add(c));\n    }, a.fn.extend({ removeWithDependents: function removeWithDependents() {\n        a.removeWithDependents(this);\n      }, enhanceWithin: function enhanceWithin() {\n        var b,\n            c = {},\n            d = a.mobile.page.prototype.keepNativeSelector(),\n            e = this;a.mobile.nojs && a.mobile.nojs(this), a.mobile.links && a.mobile.links(this), a.mobile.degradeInputsWithin && a.mobile.degradeInputsWithin(this), a.fn.buttonMarkup && this.find(a.fn.buttonMarkup.initSelector).not(d).jqmEnhanceable().buttonMarkup(), a.fn.fieldcontain && this.find(\":jqmData(role='fieldcontain')\").not(d).jqmEnhanceable().fieldcontain(), a.each(a.mobile.widgets, function (b, f) {\n          if (f.initSelector) {\n            var g = a.mobile.enhanceable(e.find(f.initSelector));g.length > 0 && (g = g.not(d)), g.length > 0 && (c[f.prototype.widgetName] = g);\n          }\n        });for (b in c) {\n          c[b][b]();\n        }return this;\n      }, addDependents: function addDependents(b) {\n        a.addDependents(this, b);\n      }, getEncodedText: function getEncodedText() {\n        return a(\"<a>\").text(this.text()).html();\n      }, jqmEnhanceable: function jqmEnhanceable() {\n        return a.mobile.enhanceable(this);\n      }, jqmHijackable: function jqmHijackable() {\n        return a.mobile.hijackable(this);\n      } }), a.removeWithDependents = function (b) {\n      var c = a(b);(c.jqmData(\"dependents\") || a()).remove(), c.remove();\n    }, a.addDependents = function (b, c) {\n      var d = a(b),\n          e = d.jqmData(\"dependents\") || a();d.jqmData(\"dependents\", a(e).add(c));\n    }, a.find.matches = function (b, c) {\n      return a.find(b, null, null, c);\n    }, a.find.matchesSelector = function (b, c) {\n      return a.find(c, null, null, [b]).length > 0;\n    };\n  }(a, this), function (a) {\n    a.extend(a.mobile, { version: \"1.4.5\", subPageUrlKey: \"ui-page\", hideUrlBar: !0, keepNative: \":jqmData(role='none'), :jqmData(role='nojs')\", activePageClass: \"ui-page-active\", activeBtnClass: \"ui-btn-active\", focusClass: \"ui-focus\", ajaxEnabled: !0, hashListeningEnabled: !0, linkBindingEnabled: !0, defaultPageTransition: \"fade\", maxTransitionWidth: !1, minScrollBack: 0, defaultDialogTransition: \"pop\", pageLoadErrorMessage: \"Error Loading Page\", pageLoadErrorMessageTheme: \"a\", phonegapNavigationEnabled: !1, autoInitializePage: !0, pushStateEnabled: !0, ignoreContentEnabled: !1, buttonMarkup: { hoverDelay: 200 }, dynamicBaseEnabled: !0, pageContainer: a(), allowCrossDomainPages: !1, dialogHashKey: \"&ui-state=dialog\" });\n  }(a, this), function (a, b) {\n    var c = 0,\n        d = Array.prototype.slice,\n        e = a.cleanData;a.cleanData = function (b) {\n      for (var c, d = 0; null != (c = b[d]); d++) {\n        try {\n          a(c).triggerHandler(\"remove\");\n        } catch (f) {}\n      }e(b);\n    }, a.widget = function (b, c, d) {\n      var e,\n          f,\n          g,\n          h,\n          i = {},\n          j = b.split(\".\")[0];return b = b.split(\".\")[1], e = j + \"-\" + b, d || (d = c, c = a.Widget), a.expr[\":\"][e.toLowerCase()] = function (b) {\n        return !!a.data(b, e);\n      }, a[j] = a[j] || {}, f = a[j][b], g = a[j][b] = function (a, b) {\n        return this._createWidget ? void (arguments.length && this._createWidget(a, b)) : new g(a, b);\n      }, a.extend(g, f, { version: d.version, _proto: a.extend({}, d), _childConstructors: [] }), h = new c(), h.options = a.widget.extend({}, h.options), a.each(d, function (b, d) {\n        return a.isFunction(d) ? void (i[b] = function () {\n          var a = function a() {\n            return c.prototype[b].apply(this, arguments);\n          },\n              e = function e(a) {\n            return c.prototype[b].apply(this, a);\n          };return function () {\n            var b,\n                c = this._super,\n                f = this._superApply;return this._super = a, this._superApply = e, b = d.apply(this, arguments), this._super = c, this._superApply = f, b;\n          };\n        }()) : void (i[b] = d);\n      }), g.prototype = a.widget.extend(h, { widgetEventPrefix: f ? h.widgetEventPrefix || b : b }, i, { constructor: g, namespace: j, widgetName: b, widgetFullName: e }), f ? (a.each(f._childConstructors, function (b, c) {\n        var d = c.prototype;a.widget(d.namespace + \".\" + d.widgetName, g, c._proto);\n      }), delete f._childConstructors) : c._childConstructors.push(g), a.widget.bridge(b, g), g;\n    }, a.widget.extend = function (c) {\n      for (var e, f, g = d.call(arguments, 1), h = 0, i = g.length; i > h; h++) {\n        for (e in g[h]) {\n          f = g[h][e], g[h].hasOwnProperty(e) && f !== b && (c[e] = a.isPlainObject(f) ? a.isPlainObject(c[e]) ? a.widget.extend({}, c[e], f) : a.widget.extend({}, f) : f);\n        }\n      }return c;\n    }, a.widget.bridge = function (c, e) {\n      var f = e.prototype.widgetFullName || c;a.fn[c] = function (g) {\n        var h = \"string\" == typeof g,\n            i = d.call(arguments, 1),\n            j = this;return g = !h && i.length ? a.widget.extend.apply(null, [g].concat(i)) : g, this.each(h ? function () {\n          var d,\n              e = a.data(this, f);return \"instance\" === g ? (j = e, !1) : e ? a.isFunction(e[g]) && \"_\" !== g.charAt(0) ? (d = e[g].apply(e, i), d !== e && d !== b ? (j = d && d.jquery ? j.pushStack(d.get()) : d, !1) : void 0) : a.error(\"no such method '\" + g + \"' for \" + c + \" widget instance\") : a.error(\"cannot call methods on \" + c + \" prior to initialization; attempted to call method '\" + g + \"'\");\n        } : function () {\n          var b = a.data(this, f);b ? b.option(g || {})._init() : a.data(this, f, new e(g, this));\n        }), j;\n      };\n    }, a.Widget = function () {}, a.Widget._childConstructors = [], a.Widget.prototype = { widgetName: \"widget\", widgetEventPrefix: \"\", defaultElement: \"<div>\", options: { disabled: !1, create: null }, _createWidget: function _createWidget(b, d) {\n        d = a(d || this.defaultElement || this)[0], this.element = a(d), this.uuid = c++, this.eventNamespace = \".\" + this.widgetName + this.uuid, this.options = a.widget.extend({}, this.options, this._getCreateOptions(), b), this.bindings = a(), this.hoverable = a(), this.focusable = a(), d !== this && (a.data(d, this.widgetFullName, this), this._on(!0, this.element, { remove: function remove(a) {\n            a.target === d && this.destroy();\n          } }), this.document = a(d.style ? d.ownerDocument : d.document || d), this.window = a(this.document[0].defaultView || this.document[0].parentWindow)), this._create(), this._trigger(\"create\", null, this._getCreateEventData()), this._init();\n      }, _getCreateOptions: a.noop, _getCreateEventData: a.noop, _create: a.noop, _init: a.noop, destroy: function destroy() {\n        this._destroy(), this.element.unbind(this.eventNamespace).removeData(this.widgetFullName).removeData(a.camelCase(this.widgetFullName)), this.widget().unbind(this.eventNamespace).removeAttr(\"aria-disabled\").removeClass(this.widgetFullName + \"-disabled ui-state-disabled\"), this.bindings.unbind(this.eventNamespace), this.hoverable.removeClass(\"ui-state-hover\"), this.focusable.removeClass(\"ui-state-focus\");\n      }, _destroy: a.noop, widget: function widget() {\n        return this.element;\n      }, option: function option(c, d) {\n        var e,\n            f,\n            g,\n            h = c;if (0 === arguments.length) return a.widget.extend({}, this.options);if (\"string\" == typeof c) if (h = {}, e = c.split(\".\"), c = e.shift(), e.length) {\n          for (f = h[c] = a.widget.extend({}, this.options[c]), g = 0; g < e.length - 1; g++) {\n            f[e[g]] = f[e[g]] || {}, f = f[e[g]];\n          }if (c = e.pop(), d === b) return f[c] === b ? null : f[c];f[c] = d;\n        } else {\n          if (d === b) return this.options[c] === b ? null : this.options[c];h[c] = d;\n        }return this._setOptions(h), this;\n      }, _setOptions: function _setOptions(a) {\n        var b;for (b in a) {\n          this._setOption(b, a[b]);\n        }return this;\n      }, _setOption: function _setOption(a, b) {\n        return this.options[a] = b, \"disabled\" === a && (this.widget().toggleClass(this.widgetFullName + \"-disabled\", !!b), this.hoverable.removeClass(\"ui-state-hover\"), this.focusable.removeClass(\"ui-state-focus\")), this;\n      }, enable: function enable() {\n        return this._setOptions({ disabled: !1 });\n      }, disable: function disable() {\n        return this._setOptions({ disabled: !0 });\n      }, _on: function _on(b, c, d) {\n        var e,\n            f = this;\"boolean\" != typeof b && (d = c, c = b, b = !1), d ? (c = e = a(c), this.bindings = this.bindings.add(c)) : (d = c, c = this.element, e = this.widget()), a.each(d, function (d, g) {\n          function h() {\n            return b || f.options.disabled !== !0 && !a(this).hasClass(\"ui-state-disabled\") ? (\"string\" == typeof g ? f[g] : g).apply(f, arguments) : void 0;\n          }\"string\" != typeof g && (h.guid = g.guid = g.guid || h.guid || a.guid++);var i = d.match(/^(\\w+)\\s*(.*)$/),\n              j = i[1] + f.eventNamespace,\n              k = i[2];k ? e.delegate(k, j, h) : c.bind(j, h);\n        });\n      }, _off: function _off(a, b) {\n        b = (b || \"\").split(\" \").join(this.eventNamespace + \" \") + this.eventNamespace, a.unbind(b).undelegate(b);\n      }, _delay: function _delay(a, b) {\n        function c() {\n          return (\"string\" == typeof a ? d[a] : a).apply(d, arguments);\n        }var d = this;return setTimeout(c, b || 0);\n      }, _hoverable: function _hoverable(b) {\n        this.hoverable = this.hoverable.add(b), this._on(b, { mouseenter: function mouseenter(b) {\n            a(b.currentTarget).addClass(\"ui-state-hover\");\n          }, mouseleave: function mouseleave(b) {\n            a(b.currentTarget).removeClass(\"ui-state-hover\");\n          } });\n      }, _focusable: function _focusable(b) {\n        this.focusable = this.focusable.add(b), this._on(b, { focusin: function focusin(b) {\n            a(b.currentTarget).addClass(\"ui-state-focus\");\n          }, focusout: function focusout(b) {\n            a(b.currentTarget).removeClass(\"ui-state-focus\");\n          } });\n      }, _trigger: function _trigger(b, c, d) {\n        var e,\n            f,\n            g = this.options[b];if (d = d || {}, c = a.Event(c), c.type = (b === this.widgetEventPrefix ? b : this.widgetEventPrefix + b).toLowerCase(), c.target = this.element[0], f = c.originalEvent) for (e in f) {\n          e in c || (c[e] = f[e]);\n        }return this.element.trigger(c, d), !(a.isFunction(g) && g.apply(this.element[0], [c].concat(d)) === !1 || c.isDefaultPrevented());\n      } }, a.each({ show: \"fadeIn\", hide: \"fadeOut\" }, function (b, c) {\n      a.Widget.prototype[\"_\" + b] = function (d, e, f) {\n        \"string\" == typeof e && (e = { effect: e });var g,\n            h = e ? e === !0 || \"number\" == typeof e ? c : e.effect || c : b;e = e || {}, \"number\" == typeof e && (e = { duration: e }), g = !a.isEmptyObject(e), e.complete = f, e.delay && d.delay(e.delay), g && a.effects && a.effects.effect[h] ? d[b](e) : h !== b && d[h] ? d[h](e.duration, e.easing, f) : d.queue(function (c) {\n          a(this)[b](), f && f.call(d[0]), c();\n        });\n      };\n    });\n  }(a), function (a, b, c) {\n    var d = {},\n        e = a.find,\n        f = /(?:\\{[\\s\\S]*\\}|\\[[\\s\\S]*\\])$/,\n        g = /:jqmData\\(([^)]*)\\)/g;a.extend(a.mobile, { ns: \"\", getAttribute: function getAttribute(b, c) {\n        var d;b = b.jquery ? b[0] : b, b && b.getAttribute && (d = b.getAttribute(\"data-\" + a.mobile.ns + c));try {\n          d = \"true\" === d ? !0 : \"false\" === d ? !1 : \"null\" === d ? null : +d + \"\" === d ? +d : f.test(d) ? JSON.parse(d) : d;\n        } catch (e) {}return d;\n      }, nsNormalizeDict: d, nsNormalize: function nsNormalize(b) {\n        return d[b] || (d[b] = a.camelCase(a.mobile.ns + b));\n      }, closestPageData: function closestPageData(a) {\n        return a.closest(\":jqmData(role='page'), :jqmData(role='dialog')\").data(\"mobile-page\");\n      } }), a.fn.jqmData = function (b, d) {\n      var e;return \"undefined\" != typeof b && (b && (b = a.mobile.nsNormalize(b)), e = arguments.length < 2 || d === c ? this.data(b) : this.data(b, d)), e;\n    }, a.jqmData = function (b, c, d) {\n      var e;return \"undefined\" != typeof c && (e = a.data(b, c ? a.mobile.nsNormalize(c) : c, d)), e;\n    }, a.fn.jqmRemoveData = function (b) {\n      return this.removeData(a.mobile.nsNormalize(b));\n    }, a.jqmRemoveData = function (b, c) {\n      return a.removeData(b, a.mobile.nsNormalize(c));\n    }, a.find = function (b, c, d, f) {\n      return b.indexOf(\":jqmData\") > -1 && (b = b.replace(g, \"[data-\" + (a.mobile.ns || \"\") + \"$1]\")), e.call(this, b, c, d, f);\n    }, a.extend(a.find, e);\n  }(a, this), function (a) {\n    var b = /[A-Z]/g,\n        c = function c(a) {\n      return \"-\" + a.toLowerCase();\n    };a.extend(a.Widget.prototype, { _getCreateOptions: function _getCreateOptions() {\n        var d,\n            e,\n            f = this.element[0],\n            g = {};if (!a.mobile.getAttribute(f, \"defaults\")) for (d in this.options) {\n          e = a.mobile.getAttribute(f, d.replace(b, c)), null != e && (g[d] = e);\n        }return g;\n      } }), a.mobile.widget = a.Widget;\n  }(a), function (a) {\n    var b = \"ui-loader\",\n        c = a(\"html\");a.widget(\"mobile.loader\", { options: { theme: \"a\", textVisible: !1, html: \"\", text: \"loading\" }, defaultHtml: \"<div class='\" + b + \"'><span class='ui-icon-loading'></span><h1></h1></div>\", fakeFixLoader: function fakeFixLoader() {\n        var b = a(\".\" + a.mobile.activeBtnClass).first();this.element.css({ top: a.support.scrollTop && this.window.scrollTop() + this.window.height() / 2 || b.length && b.offset().top || 100 });\n      }, checkLoaderPosition: function checkLoaderPosition() {\n        var b = this.element.offset(),\n            c = this.window.scrollTop(),\n            d = a.mobile.getScreenHeight();(b.top < c || b.top - c > d) && (this.element.addClass(\"ui-loader-fakefix\"), this.fakeFixLoader(), this.window.unbind(\"scroll\", this.checkLoaderPosition).bind(\"scroll\", a.proxy(this.fakeFixLoader, this)));\n      }, resetHtml: function resetHtml() {\n        this.element.html(a(this.defaultHtml).html());\n      }, show: function show(d, e, f) {\n        var g, h, i;this.resetHtml(), \"object\" === a.type(d) ? (i = a.extend({}, this.options, d), d = i.theme) : (i = this.options, d = d || i.theme), h = e || (i.text === !1 ? \"\" : i.text), c.addClass(\"ui-loading\"), g = i.textVisible, this.element.attr(\"class\", b + \" ui-corner-all ui-body-\" + d + \" ui-loader-\" + (g || e || d.text ? \"verbose\" : \"default\") + (i.textonly || f ? \" ui-loader-textonly\" : \"\")), i.html ? this.element.html(i.html) : this.element.find(\"h1\").text(h), this.element.appendTo(a(a.mobile.pagecontainer ? \":mobile-pagecontainer\" : \"body\")), this.checkLoaderPosition(), this.window.bind(\"scroll\", a.proxy(this.checkLoaderPosition, this));\n      }, hide: function hide() {\n        c.removeClass(\"ui-loading\"), this.options.text && this.element.removeClass(\"ui-loader-fakefix\"), this.window.unbind(\"scroll\", this.fakeFixLoader), this.window.unbind(\"scroll\", this.checkLoaderPosition);\n      } });\n  }(a, this), function (a, b, d) {\n    \"$:nomunge\";\n    function e(a) {\n      return a = a || location.href, \"#\" + a.replace(/^[^#]*#?(.*)$/, \"$1\");\n    }var f,\n        g = \"hashchange\",\n        h = c,\n        i = a.event.special,\n        j = h.documentMode,\n        k = \"on\" + g in b && (j === d || j > 7);a.fn[g] = function (a) {\n      return a ? this.bind(g, a) : this.trigger(g);\n    }, a.fn[g].delay = 50, i[g] = a.extend(i[g], { setup: function setup() {\n        return k ? !1 : void a(f.start);\n      }, teardown: function teardown() {\n        return k ? !1 : void a(f.stop);\n      } }), f = function () {\n      function c() {\n        var d = e(),\n            h = n(j);d !== j ? (m(j = d, h), a(b).trigger(g)) : h !== j && (location.href = location.href.replace(/#.*/, \"\") + h), f = setTimeout(c, a.fn[g].delay);\n      }var f,\n          i = {},\n          j = e(),\n          l = function l(a) {\n        return a;\n      },\n          m = l,\n          n = l;return i.start = function () {\n        f || c();\n      }, i.stop = function () {\n        f && clearTimeout(f), f = d;\n      }, b.attachEvent && !b.addEventListener && !k && function () {\n        var b, d;i.start = function () {\n          b || (d = a.fn[g].src, d = d && d + e(), b = a('<iframe tabindex=\"-1\" title=\"empty\"/>').hide().one(\"load\", function () {\n            d || m(e()), c();\n          }).attr(\"src\", d || \"javascript:0\").insertAfter(\"body\")[0].contentWindow, h.onpropertychange = function () {\n            try {\n              \"title\" === event.propertyName && (b.document.title = h.title);\n            } catch (a) {}\n          });\n        }, i.stop = l, n = function n() {\n          return e(b.location.href);\n        }, m = function m(c, d) {\n          var e = b.document,\n              f = a.fn[g].domain;c !== d && (e.title = h.title, e.open(), f && e.write('<script>document.domain=\"' + f + '\"</script>'), e.close(), b.location.hash = c);\n        };\n      }(), i;\n    }();\n  }(a, this), function (a) {\n    b.matchMedia = b.matchMedia || function (a) {\n      var b,\n          c = a.documentElement,\n          d = c.firstElementChild || c.firstChild,\n          e = a.createElement(\"body\"),\n          f = a.createElement(\"div\");return f.id = \"mq-test-1\", f.style.cssText = \"position:absolute;top:-100em\", e.style.background = \"none\", e.appendChild(f), function (a) {\n        return f.innerHTML = '&shy;<style media=\"' + a + '\"> #mq-test-1 { width: 42px; }</style>', c.insertBefore(e, d), b = 42 === f.offsetWidth, c.removeChild(e), { matches: b, media: a };\n      };\n    }(c), a.mobile.media = function (a) {\n      return b.matchMedia(a).matches;\n    };\n  }(a), function (a) {\n    var b = { touch: \"ontouchend\" in c };a.mobile.support = a.mobile.support || {}, a.extend(a.support, b), a.extend(a.mobile.support, b);\n  }(a), function (a) {\n    a.extend(a.support, { orientation: \"orientation\" in b && \"onorientationchange\" in b });\n  }(a), function (a, d) {\n    function e(a) {\n      var b,\n          c = a.charAt(0).toUpperCase() + a.substr(1),\n          e = (a + \" \" + o.join(c + \" \") + c).split(\" \");for (b in e) {\n        if (n[e[b]] !== d) return !0;\n      }\n    }function f() {\n      var c = b,\n          d = !(!c.document.createElementNS || !c.document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\").createSVGRect || c.opera && -1 === navigator.userAgent.indexOf(\"Chrome\")),\n          e = function e(b) {\n        b && d || a(\"html\").addClass(\"ui-nosvg\");\n      },\n          f = new c.Image();f.onerror = function () {\n        e(!1);\n      }, f.onload = function () {\n        e(1 === f.width && 1 === f.height);\n      }, f.src = \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==\";\n    }function g() {\n      var e,\n          f,\n          g,\n          h = \"transform-3d\",\n          i = a.mobile.media(\"(-\" + o.join(\"-\" + h + \"),(-\") + \"-\" + h + \"),(\" + h + \")\");if (i) return !!i;e = c.createElement(\"div\"), f = { MozTransform: \"-moz-transform\", transform: \"transform\" }, m.append(e);for (g in f) {\n        e.style[g] !== d && (e.style[g] = \"translate3d( 100px, 1px, 1px )\", i = b.getComputedStyle(e).getPropertyValue(f[g]));\n      }return !!i && \"none\" !== i;\n    }function h() {\n      var b,\n          c,\n          d = location.protocol + \"//\" + location.host + location.pathname + \"ui-dir/\",\n          e = a(\"head base\"),\n          f = null,\n          g = \"\";return e.length ? g = e.attr(\"href\") : e = f = a(\"<base>\", { href: d }).appendTo(\"head\"), b = a(\"<a href='testurl' />\").prependTo(m), c = b[0].href, e[0].href = g || location.pathname, f && f.remove(), 0 === c.indexOf(d);\n    }function i() {\n      var a,\n          d = c.createElement(\"x\"),\n          e = c.documentElement,\n          f = b.getComputedStyle;return \"pointerEvents\" in d.style ? (d.style.pointerEvents = \"auto\", d.style.pointerEvents = \"x\", e.appendChild(d), a = f && \"auto\" === f(d, \"\").pointerEvents, e.removeChild(d), !!a) : !1;\n    }function j() {\n      var a = c.createElement(\"div\");return \"undefined\" != typeof a.getBoundingClientRect;\n    }function k() {\n      var a = b,\n          c = navigator.userAgent,\n          d = navigator.platform,\n          e = c.match(/AppleWebKit\\/([0-9]+)/),\n          f = !!e && e[1],\n          g = c.match(/Fennec\\/([0-9]+)/),\n          h = !!g && g[1],\n          i = c.match(/Opera Mobi\\/([0-9]+)/),\n          j = !!i && i[1];return (d.indexOf(\"iPhone\") > -1 || d.indexOf(\"iPad\") > -1 || d.indexOf(\"iPod\") > -1) && f && 534 > f || a.operamini && \"[object OperaMini]\" === {}.toString.call(a.operamini) || i && 7458 > j || c.indexOf(\"Android\") > -1 && f && 533 > f || h && 6 > h || \"palmGetResource\" in b && f && 534 > f || c.indexOf(\"MeeGo\") > -1 && c.indexOf(\"NokiaBrowser/8.5.0\") > -1 ? !1 : !0;\n    }var l,\n        m = a(\"<body>\").prependTo(\"html\"),\n        n = m[0].style,\n        o = [\"Webkit\", \"Moz\", \"O\"],\n        p = \"palmGetResource\" in b,\n        q = b.operamini && \"[object OperaMini]\" === {}.toString.call(b.operamini),\n        r = b.blackberry && !e(\"-webkit-transform\");a.extend(a.mobile, { browser: {} }), a.mobile.browser.oldIE = function () {\n      var a = 3,\n          b = c.createElement(\"div\"),\n          d = b.all || [];do {\n        b.innerHTML = \"<!--[if gt IE \" + ++a + \"]><br><![endif]-->\";\n      } while (d[0]);return a > 4 ? a : !a;\n    }(), a.extend(a.support, { pushState: \"pushState\" in history && \"replaceState\" in history && !(b.navigator.userAgent.indexOf(\"Firefox\") >= 0 && b.top !== b) && -1 === b.navigator.userAgent.search(/CriOS/), mediaquery: a.mobile.media(\"only all\"), cssPseudoElement: !!e(\"content\"), touchOverflow: !!e(\"overflowScrolling\"), cssTransform3d: g(), boxShadow: !!e(\"boxShadow\") && !r, fixedPosition: k(), scrollTop: (\"pageXOffset\" in b || \"scrollTop\" in c.documentElement || \"scrollTop\" in m[0]) && !p && !q, dynamicBaseTag: h(), cssPointerEvents: i(), boundingRect: j(), inlineSVG: f }), m.remove(), l = function () {\n      var a = b.navigator.userAgent;return a.indexOf(\"Nokia\") > -1 && (a.indexOf(\"Symbian/3\") > -1 || a.indexOf(\"Series60/5\") > -1) && a.indexOf(\"AppleWebKit\") > -1 && a.match(/(BrowserNG|NokiaBrowser)\\/7\\.[0-3]/);\n    }(), a.mobile.gradeA = function () {\n      return (a.support.mediaquery && a.support.cssPseudoElement || a.mobile.browser.oldIE && a.mobile.browser.oldIE >= 8) && (a.support.boundingRect || null !== a.fn.jquery.match(/1\\.[0-7+]\\.[0-9+]?/));\n    }, a.mobile.ajaxBlacklist = b.blackberry && !b.WebKitPoint || q || l, l && a(function () {\n      a(\"head link[rel='stylesheet']\").attr(\"rel\", \"alternate stylesheet\").attr(\"rel\", \"stylesheet\");\n    }), a.support.boxShadow || a(\"html\").addClass(\"ui-noboxshadow\");\n  }(a), function (a, b) {\n    var c,\n        d = a.mobile.window,\n        e = function e() {};a.event.special.beforenavigate = { setup: function setup() {\n        d.on(\"navigate\", e);\n      }, teardown: function teardown() {\n        d.off(\"navigate\", e);\n      } }, a.event.special.navigate = c = { bound: !1, pushStateEnabled: !0, originalEventName: b, isPushStateEnabled: function isPushStateEnabled() {\n        return a.support.pushState && a.mobile.pushStateEnabled === !0 && this.isHashChangeEnabled();\n      }, isHashChangeEnabled: function isHashChangeEnabled() {\n        return a.mobile.hashListeningEnabled === !0;\n      }, popstate: function popstate(b) {\n        var c = new a.Event(\"navigate\"),\n            e = new a.Event(\"beforenavigate\"),\n            f = b.originalEvent.state || {};e.originalEvent = b, d.trigger(e), e.isDefaultPrevented() || (b.historyState && a.extend(f, b.historyState), c.originalEvent = b, setTimeout(function () {\n          d.trigger(c, { state: f });\n        }, 0));\n      }, hashchange: function hashchange(b) {\n        var c = new a.Event(\"navigate\"),\n            e = new a.Event(\"beforenavigate\");e.originalEvent = b, d.trigger(e), e.isDefaultPrevented() || (c.originalEvent = b, d.trigger(c, { state: b.hashchangeState || {} }));\n      }, setup: function setup() {\n        c.bound || (c.bound = !0, c.isPushStateEnabled() ? (c.originalEventName = \"popstate\", d.bind(\"popstate.navigate\", c.popstate)) : c.isHashChangeEnabled() && (c.originalEventName = \"hashchange\", d.bind(\"hashchange.navigate\", c.hashchange)));\n      } };\n  }(a), function (a, c) {\n    var d,\n        e,\n        f = \"&ui-state=dialog\";a.mobile.path = d = { uiStateKey: \"&ui-state\", urlParseRE: /^\\s*(((([^:\\/#\\?]+:)?(?:(\\/\\/)((?:(([^:@\\/#\\?]+)(?:\\:([^:@\\/#\\?]+))?)@)?(([^:\\/#\\?\\]\\[]+|\\[[^\\/\\]@#?]+\\])(?:\\:([0-9]+))?))?)?)?((\\/?(?:[^\\/\\?#]+\\/+)*)([^\\?#]*)))?(\\?[^#]+)?)(#.*)?/, getLocation: function getLocation(a) {\n        var b = this.parseUrl(a || location.href),\n            c = a ? b : location,\n            d = b.hash;return d = \"#\" === d ? \"\" : d, c.protocol + b.doubleSlash + c.host + (\"\" !== c.protocol && \"/\" !== c.pathname.substring(0, 1) ? \"/\" : \"\") + c.pathname + c.search + d;\n      }, getDocumentUrl: function getDocumentUrl(b) {\n        return b ? a.extend({}, d.documentUrl) : d.documentUrl.href;\n      }, parseLocation: function parseLocation() {\n        return this.parseUrl(this.getLocation());\n      }, parseUrl: function parseUrl(b) {\n        if (\"object\" === a.type(b)) return b;var c = d.urlParseRE.exec(b || \"\") || [];return { href: c[0] || \"\", hrefNoHash: c[1] || \"\", hrefNoSearch: c[2] || \"\", domain: c[3] || \"\", protocol: c[4] || \"\", doubleSlash: c[5] || \"\", authority: c[6] || \"\", username: c[8] || \"\", password: c[9] || \"\", host: c[10] || \"\", hostname: c[11] || \"\", port: c[12] || \"\", pathname: c[13] || \"\", directory: c[14] || \"\", filename: c[15] || \"\", search: c[16] || \"\", hash: c[17] || \"\" };\n      }, makePathAbsolute: function makePathAbsolute(a, b) {\n        var c, d, e, f;if (a && \"/\" === a.charAt(0)) return a;for (a = a || \"\", b = b ? b.replace(/^\\/|(\\/[^\\/]*|[^\\/]+)$/g, \"\") : \"\", c = b ? b.split(\"/\") : [], d = a.split(\"/\"), e = 0; e < d.length; e++) {\n          switch (f = d[e]) {case \".\":\n              break;case \"..\":\n              c.length && c.pop();break;default:\n              c.push(f);}\n        }return \"/\" + c.join(\"/\");\n      }, isSameDomain: function isSameDomain(a, b) {\n        return d.parseUrl(a).domain.toLowerCase() === d.parseUrl(b).domain.toLowerCase();\n      }, isRelativeUrl: function isRelativeUrl(a) {\n        return \"\" === d.parseUrl(a).protocol;\n      }, isAbsoluteUrl: function isAbsoluteUrl(a) {\n        return \"\" !== d.parseUrl(a).protocol;\n      }, makeUrlAbsolute: function makeUrlAbsolute(a, b) {\n        if (!d.isRelativeUrl(a)) return a;b === c && (b = this.documentBase);var e = d.parseUrl(a),\n            f = d.parseUrl(b),\n            g = e.protocol || f.protocol,\n            h = e.protocol ? e.doubleSlash : e.doubleSlash || f.doubleSlash,\n            i = e.authority || f.authority,\n            j = \"\" !== e.pathname,\n            k = d.makePathAbsolute(e.pathname || f.filename, f.pathname),\n            l = e.search || !j && f.search || \"\",\n            m = e.hash;return g + h + i + k + l + m;\n      }, addSearchParams: function addSearchParams(b, c) {\n        var e = d.parseUrl(b),\n            f = \"object\" == (typeof c === \"undefined\" ? \"undefined\" : _typeof(c)) ? a.param(c) : c,\n            g = e.search || \"?\";return e.hrefNoSearch + g + (\"?\" !== g.charAt(g.length - 1) ? \"&\" : \"\") + f + (e.hash || \"\");\n      }, convertUrlToDataUrl: function convertUrlToDataUrl(a) {\n        var c = a,\n            e = d.parseUrl(a);return d.isEmbeddedPage(e) ? c = e.hash.split(f)[0].replace(/^#/, \"\").replace(/\\?.*$/, \"\") : d.isSameDomain(e, this.documentBase) && (c = e.hrefNoHash.replace(this.documentBase.domain, \"\").split(f)[0]), b.decodeURIComponent(c);\n      }, get: function get(a) {\n        return a === c && (a = d.parseLocation().hash), d.stripHash(a).replace(/[^\\/]*\\.[^\\/*]+$/, \"\");\n      }, set: function set(a) {\n        location.hash = a;\n      }, isPath: function isPath(a) {\n        return (/\\//.test(a)\n        );\n      }, clean: function clean(a) {\n        return a.replace(this.documentBase.domain, \"\");\n      }, stripHash: function stripHash(a) {\n        return a.replace(/^#/, \"\");\n      }, stripQueryParams: function stripQueryParams(a) {\n        return a.replace(/\\?.*$/, \"\");\n      }, cleanHash: function cleanHash(a) {\n        return d.stripHash(a.replace(/\\?.*$/, \"\").replace(f, \"\"));\n      }, isHashValid: function isHashValid(a) {\n        return (/^#[^#]+$/.test(a)\n        );\n      }, isExternal: function isExternal(a) {\n        var b = d.parseUrl(a);return !(!b.protocol || b.domain.toLowerCase() === this.documentUrl.domain.toLowerCase());\n      }, hasProtocol: function hasProtocol(a) {\n        return (/^(:?\\w+:)/.test(a)\n        );\n      }, isEmbeddedPage: function isEmbeddedPage(a) {\n        var b = d.parseUrl(a);return \"\" !== b.protocol ? !this.isPath(b.hash) && b.hash && (b.hrefNoHash === this.documentUrl.hrefNoHash || this.documentBaseDiffers && b.hrefNoHash === this.documentBase.hrefNoHash) : /^#/.test(b.href);\n      }, squash: function squash(a, b) {\n        var c,\n            e,\n            f,\n            g,\n            h,\n            i = this.isPath(a),\n            j = this.parseUrl(a),\n            k = j.hash,\n            l = \"\";return b || (i ? b = d.getLocation() : (h = d.getDocumentUrl(!0), b = d.isPath(h.hash) ? d.squash(h.href) : h.href)), e = i ? d.stripHash(a) : a, e = d.isPath(j.hash) ? d.stripHash(j.hash) : e, g = e.indexOf(this.uiStateKey), g > -1 && (l = e.slice(g), e = e.slice(0, g)), c = d.makeUrlAbsolute(e, b), f = this.parseUrl(c).search, i ? ((d.isPath(k) || 0 === k.replace(\"#\", \"\").indexOf(this.uiStateKey)) && (k = \"\"), l && -1 === k.indexOf(this.uiStateKey) && (k += l), -1 === k.indexOf(\"#\") && \"\" !== k && (k = \"#\" + k), c = d.parseUrl(c), c = c.protocol + c.doubleSlash + c.host + c.pathname + f + k) : c += c.indexOf(\"#\") > -1 ? l : \"#\" + l, c;\n      }, isPreservableHash: function isPreservableHash(a) {\n        return 0 === a.replace(\"#\", \"\").indexOf(this.uiStateKey);\n      }, hashToSelector: function hashToSelector(a) {\n        var b = \"#\" === a.substring(0, 1);return b && (a = a.substring(1)), (b ? \"#\" : \"\") + a.replace(/([!\"#$%&'()*+,./:;<=>?@[\\]^`{|}~])/g, \"\\\\$1\");\n      }, getFilePath: function getFilePath(a) {\n        return a && a.split(f)[0];\n      }, isFirstPageUrl: function isFirstPageUrl(b) {\n        var e = d.parseUrl(d.makeUrlAbsolute(b, this.documentBase)),\n            f = e.hrefNoHash === this.documentUrl.hrefNoHash || this.documentBaseDiffers && e.hrefNoHash === this.documentBase.hrefNoHash,\n            g = a.mobile.firstPage,\n            h = g && g[0] ? g[0].id : c;return f && (!e.hash || \"#\" === e.hash || h && e.hash.replace(/^#/, \"\") === h);\n      }, isPermittedCrossDomainRequest: function isPermittedCrossDomainRequest(b, c) {\n        return a.mobile.allowCrossDomainPages && (\"file:\" === b.protocol || \"content:\" === b.protocol) && -1 !== c.search(/^https?:/);\n      } }, d.documentUrl = d.parseLocation(), e = a(\"head\").find(\"base\"), d.documentBase = e.length ? d.parseUrl(d.makeUrlAbsolute(e.attr(\"href\"), d.documentUrl.href)) : d.documentUrl, d.documentBaseDiffers = d.documentUrl.hrefNoHash !== d.documentBase.hrefNoHash, d.getDocumentBase = function (b) {\n      return b ? a.extend({}, d.documentBase) : d.documentBase.href;\n    }, a.extend(a.mobile, { getDocumentUrl: d.getDocumentUrl, getDocumentBase: d.getDocumentBase });\n  }(a), function (a, b) {\n    a.mobile.History = function (a, b) {\n      this.stack = a || [], this.activeIndex = b || 0;\n    }, a.extend(a.mobile.History.prototype, { getActive: function getActive() {\n        return this.stack[this.activeIndex];\n      }, getLast: function getLast() {\n        return this.stack[this.previousIndex];\n      }, getNext: function getNext() {\n        return this.stack[this.activeIndex + 1];\n      }, getPrev: function getPrev() {\n        return this.stack[this.activeIndex - 1];\n      }, add: function add(a, b) {\n        b = b || {}, this.getNext() && this.clearForward(), b.hash && -1 === b.hash.indexOf(\"#\") && (b.hash = \"#\" + b.hash), b.url = a, this.stack.push(b), this.activeIndex = this.stack.length - 1;\n      }, clearForward: function clearForward() {\n        this.stack = this.stack.slice(0, this.activeIndex + 1);\n      }, find: function find(a, b, c) {\n        b = b || this.stack;var d,\n            e,\n            f,\n            g = b.length;for (e = 0; g > e; e++) {\n          if (d = b[e], (decodeURIComponent(a) === decodeURIComponent(d.url) || decodeURIComponent(a) === decodeURIComponent(d.hash)) && (f = e, c)) return f;\n        }return f;\n      }, closest: function closest(a) {\n        var c,\n            d = this.activeIndex;return c = this.find(a, this.stack.slice(0, d)), c === b && (c = this.find(a, this.stack.slice(d), !0), c = c === b ? c : c + d), c;\n      }, direct: function direct(c) {\n        var d = this.closest(c.url),\n            e = this.activeIndex;d !== b && (this.activeIndex = d, this.previousIndex = e), e > d ? (c.present || c.back || a.noop)(this.getActive(), \"back\") : d > e ? (c.present || c.forward || a.noop)(this.getActive(), \"forward\") : d === b && c.missing && c.missing(this.getActive());\n      } });\n  }(a), function (a) {\n    var d = a.mobile.path,\n        e = location.href;a.mobile.Navigator = function (b) {\n      this.history = b, this.ignoreInitialHashChange = !0, a.mobile.window.bind({ \"popstate.history\": a.proxy(this.popstate, this), \"hashchange.history\": a.proxy(this.hashchange, this) });\n    }, a.extend(a.mobile.Navigator.prototype, { squash: function squash(e, f) {\n        var g,\n            h,\n            i = d.isPath(e) ? d.stripHash(e) : e;return h = d.squash(e), g = a.extend({ hash: i, url: h }, f), b.history.replaceState(g, g.title || c.title, h), g;\n      }, hash: function hash(a, b) {\n        var c, e, f, g;return c = d.parseUrl(a), e = d.parseLocation(), e.pathname + e.search === c.pathname + c.search ? f = c.hash ? c.hash : c.pathname + c.search : d.isPath(a) ? (g = d.parseUrl(b), f = g.pathname + g.search + (d.isPreservableHash(g.hash) ? g.hash.replace(\"#\", \"\") : \"\")) : f = a, f;\n      }, go: function go(e, f, g) {\n        var h,\n            i,\n            j,\n            k,\n            l = a.event.special.navigate.isPushStateEnabled();\n        i = d.squash(e), j = this.hash(e, i), g && j !== d.stripHash(d.parseLocation().hash) && (this.preventNextHashChange = g), this.preventHashAssignPopState = !0, b.location.hash = j, this.preventHashAssignPopState = !1, h = a.extend({ url: i, hash: j, title: c.title }, f), l && (k = new a.Event(\"popstate\"), k.originalEvent = { type: \"popstate\", state: null }, this.squash(e, h), g || (this.ignorePopState = !0, a.mobile.window.trigger(k))), this.history.add(h.url, h);\n      }, popstate: function popstate(b) {\n        var c, f;if (a.event.special.navigate.isPushStateEnabled()) return this.preventHashAssignPopState ? (this.preventHashAssignPopState = !1, void b.stopImmediatePropagation()) : this.ignorePopState ? void (this.ignorePopState = !1) : !b.originalEvent.state && 1 === this.history.stack.length && this.ignoreInitialHashChange && (this.ignoreInitialHashChange = !1, location.href === e) ? void b.preventDefault() : (c = d.parseLocation().hash, !b.originalEvent.state && c ? (f = this.squash(c), this.history.add(f.url, f), void (b.historyState = f)) : void this.history.direct({ url: (b.originalEvent.state || {}).url || c, present: function present(c, d) {\n            b.historyState = a.extend({}, c), b.historyState.direction = d;\n          } }));\n      }, hashchange: function hashchange(b) {\n        var e, f;if (a.event.special.navigate.isHashChangeEnabled() && !a.event.special.navigate.isPushStateEnabled()) {\n          if (this.preventNextHashChange) return this.preventNextHashChange = !1, void b.stopImmediatePropagation();e = this.history, f = d.parseLocation().hash, this.history.direct({ url: f, present: function present(c, d) {\n              b.hashchangeState = a.extend({}, c), b.hashchangeState.direction = d;\n            }, missing: function missing() {\n              e.add(f, { hash: f, title: c.title });\n            } });\n        }\n      } });\n  }(a), function (a) {\n    a.mobile.navigate = function (b, c, d) {\n      a.mobile.navigate.navigator.go(b, c, d);\n    }, a.mobile.navigate.history = new a.mobile.History(), a.mobile.navigate.navigator = new a.mobile.Navigator(a.mobile.navigate.history);var b = a.mobile.path.parseLocation();a.mobile.navigate.history.add(b.href, { hash: b.hash });\n  }(a), function (a, b) {\n    var d = { animation: {}, transition: {} },\n        e = c.createElement(\"a\"),\n        f = [\"\", \"webkit-\", \"moz-\", \"o-\"];a.each([\"animation\", \"transition\"], function (c, g) {\n      var h = 0 === c ? g + \"-name\" : g;a.each(f, function (c, f) {\n        return e.style[a.camelCase(f + h)] !== b ? (d[g].prefix = f, !1) : void 0;\n      }), d[g].duration = a.camelCase(d[g].prefix + g + \"-duration\"), d[g].event = a.camelCase(d[g].prefix + g + \"-end\"), \"\" === d[g].prefix && (d[g].event = d[g].event.toLowerCase());\n    }), a.support.cssTransitions = d.transition.prefix !== b, a.support.cssAnimations = d.animation.prefix !== b, a(e).remove(), a.fn.animationComplete = function (e, f, g) {\n      var h,\n          i,\n          j = this,\n          k = function k() {\n        clearTimeout(h), e.apply(this, arguments);\n      },\n          l = f && \"animation\" !== f ? \"transition\" : \"animation\";return a.support.cssTransitions && \"transition\" === l || a.support.cssAnimations && \"animation\" === l ? (g === b && (a(this).context !== c && (i = 3e3 * parseFloat(a(this).css(d[l].duration))), (0 === i || i === b || isNaN(i)) && (i = a.fn.animationComplete.defaultDuration)), h = setTimeout(function () {\n        a(j).off(d[l].event, k), e.apply(j);\n      }, i), a(this).one(d[l].event, k)) : (setTimeout(a.proxy(e, this), 0), a(this));\n    }, a.fn.animationComplete.defaultDuration = 1e3;\n  }(a), function (a, b, c, d) {\n    function e(a) {\n      for (; a && \"undefined\" != typeof a.originalEvent;) {\n        a = a.originalEvent;\n      }return a;\n    }function f(b, c) {\n      var f,\n          g,\n          h,\n          i,\n          j,\n          k,\n          l,\n          m,\n          n,\n          o = b.type;if (b = a.Event(b), b.type = c, f = b.originalEvent, g = a.event.props, o.search(/^(mouse|click)/) > -1 && (g = E), f) for (l = g.length, i; l;) {\n        i = g[--l], b[i] = f[i];\n      }if (o.search(/mouse(down|up)|click/) > -1 && !b.which && (b.which = 1), -1 !== o.search(/^touch/) && (h = e(f), o = h.touches, j = h.changedTouches, k = o && o.length ? o[0] : j && j.length ? j[0] : d)) for (m = 0, n = C.length; n > m; m++) {\n        i = C[m], b[i] = k[i];\n      }return b;\n    }function g(b) {\n      for (var c, d, e = {}; b;) {\n        c = a.data(b, z);for (d in c) {\n          c[d] && (e[d] = e.hasVirtualBinding = !0);\n        }b = b.parentNode;\n      }return e;\n    }function h(b, c) {\n      for (var d; b;) {\n        if (d = a.data(b, z), d && (!c || d[c])) return b;b = b.parentNode;\n      }return null;\n    }function i() {\n      M = !1;\n    }function j() {\n      M = !0;\n    }function k() {\n      Q = 0, K.length = 0, L = !1, j();\n    }function l() {\n      i();\n    }function m() {\n      n(), G = setTimeout(function () {\n        G = 0, k();\n      }, a.vmouse.resetTimerDuration);\n    }function n() {\n      G && (clearTimeout(G), G = 0);\n    }function o(b, c, d) {\n      var e;return (d && d[b] || !d && h(c.target, b)) && (e = f(c, b), a(c.target).trigger(e)), e;\n    }function p(b) {\n      var c,\n          d = a.data(b.target, A);L || Q && Q === d || (c = o(\"v\" + b.type, b), c && (c.isDefaultPrevented() && b.preventDefault(), c.isPropagationStopped() && b.stopPropagation(), c.isImmediatePropagationStopped() && b.stopImmediatePropagation()));\n    }function q(b) {\n      var c,\n          d,\n          f,\n          h = e(b).touches;h && 1 === h.length && (c = b.target, d = g(c), d.hasVirtualBinding && (Q = P++, a.data(c, A, Q), n(), l(), J = !1, f = e(b).touches[0], H = f.pageX, I = f.pageY, o(\"vmouseover\", b, d), o(\"vmousedown\", b, d)));\n    }function r(a) {\n      M || (J || o(\"vmousecancel\", a, g(a.target)), J = !0, m());\n    }function s(b) {\n      if (!M) {\n        var c = e(b).touches[0],\n            d = J,\n            f = a.vmouse.moveDistanceThreshold,\n            h = g(b.target);J = J || Math.abs(c.pageX - H) > f || Math.abs(c.pageY - I) > f, J && !d && o(\"vmousecancel\", b, h), o(\"vmousemove\", b, h), m();\n      }\n    }function t(a) {\n      if (!M) {\n        j();var b,\n            c,\n            d = g(a.target);o(\"vmouseup\", a, d), J || (b = o(\"vclick\", a, d), b && b.isDefaultPrevented() && (c = e(a).changedTouches[0], K.push({ touchID: Q, x: c.clientX, y: c.clientY }), L = !0)), o(\"vmouseout\", a, d), J = !1, m();\n      }\n    }function u(b) {\n      var c,\n          d = a.data(b, z);if (d) for (c in d) {\n        if (d[c]) return !0;\n      }return !1;\n    }function v() {}function w(b) {\n      var c = b.substr(1);return { setup: function setup() {\n          u(this) || a.data(this, z, {});var d = a.data(this, z);d[b] = !0, F[b] = (F[b] || 0) + 1, 1 === F[b] && O.bind(c, p), a(this).bind(c, v), N && (F.touchstart = (F.touchstart || 0) + 1, 1 === F.touchstart && O.bind(\"touchstart\", q).bind(\"touchend\", t).bind(\"touchmove\", s).bind(\"scroll\", r));\n        }, teardown: function teardown() {\n          --F[b], F[b] || O.unbind(c, p), N && (--F.touchstart, F.touchstart || O.unbind(\"touchstart\", q).unbind(\"touchmove\", s).unbind(\"touchend\", t).unbind(\"scroll\", r));var d = a(this),\n              e = a.data(this, z);e && (e[b] = !1), d.unbind(c, v), u(this) || d.removeData(z);\n        } };\n    }var x,\n        y,\n        z = \"virtualMouseBindings\",\n        A = \"virtualTouchID\",\n        B = \"vmouseover vmousedown vmousemove vmouseup vclick vmouseout vmousecancel\".split(\" \"),\n        C = \"clientX clientY pageX pageY screenX screenY\".split(\" \"),\n        D = a.event.mouseHooks ? a.event.mouseHooks.props : [],\n        E = a.event.props.concat(D),\n        F = {},\n        G = 0,\n        H = 0,\n        I = 0,\n        J = !1,\n        K = [],\n        L = !1,\n        M = !1,\n        N = \"addEventListener\" in c,\n        O = a(c),\n        P = 1,\n        Q = 0;for (a.vmouse = { moveDistanceThreshold: 10, clickDistanceThreshold: 10, resetTimerDuration: 1500 }, y = 0; y < B.length; y++) {\n      a.event.special[B[y]] = w(B[y]);\n    }N && c.addEventListener(\"click\", function (b) {\n      var c,\n          d,\n          e,\n          f,\n          g,\n          h,\n          i = K.length,\n          j = b.target;if (i) for (c = b.clientX, d = b.clientY, x = a.vmouse.clickDistanceThreshold, e = j; e;) {\n        for (f = 0; i > f; f++) {\n          if (g = K[f], h = 0, e === j && Math.abs(g.x - c) < x && Math.abs(g.y - d) < x || a.data(e, A) === g.touchID) return b.preventDefault(), void b.stopPropagation();\n        }e = e.parentNode;\n      }\n    }, !0);\n  }(a, b, c), function (a, b, d) {\n    function e(b, c, e, f) {\n      var g = e.type;e.type = c, f ? a.event.trigger(e, d, b) : a.event.dispatch.call(b, e), e.type = g;\n    }var f = a(c),\n        g = a.mobile.support.touch,\n        h = \"touchmove scroll\",\n        i = g ? \"touchstart\" : \"mousedown\",\n        j = g ? \"touchend\" : \"mouseup\",\n        k = g ? \"touchmove\" : \"mousemove\";a.each(\"touchstart touchmove touchend tap taphold swipe swipeleft swiperight scrollstart scrollstop\".split(\" \"), function (b, c) {\n      a.fn[c] = function (a) {\n        return a ? this.bind(c, a) : this.trigger(c);\n      }, a.attrFn && (a.attrFn[c] = !0);\n    }), a.event.special.scrollstart = { enabled: !0, setup: function setup() {\n        function b(a, b) {\n          c = b, e(f, c ? \"scrollstart\" : \"scrollstop\", a);\n        }var c,\n            d,\n            f = this,\n            g = a(f);g.bind(h, function (e) {\n          a.event.special.scrollstart.enabled && (c || b(e, !0), clearTimeout(d), d = setTimeout(function () {\n            b(e, !1);\n          }, 50));\n        });\n      }, teardown: function teardown() {\n        a(this).unbind(h);\n      } }, a.event.special.tap = { tapholdThreshold: 750, emitTapOnTaphold: !0, setup: function setup() {\n        var b = this,\n            c = a(b),\n            d = !1;c.bind(\"vmousedown\", function (g) {\n          function h() {\n            clearTimeout(k);\n          }function i() {\n            h(), c.unbind(\"vclick\", j).unbind(\"vmouseup\", h), f.unbind(\"vmousecancel\", i);\n          }function j(a) {\n            i(), d || l !== a.target ? d && a.preventDefault() : e(b, \"tap\", a);\n          }if (d = !1, g.which && 1 !== g.which) return !1;var k,\n              l = g.target;c.bind(\"vmouseup\", h).bind(\"vclick\", j), f.bind(\"vmousecancel\", i), k = setTimeout(function () {\n            a.event.special.tap.emitTapOnTaphold || (d = !0), e(b, \"taphold\", a.Event(\"taphold\", { target: l }));\n          }, a.event.special.tap.tapholdThreshold);\n        });\n      }, teardown: function teardown() {\n        a(this).unbind(\"vmousedown\").unbind(\"vclick\").unbind(\"vmouseup\"), f.unbind(\"vmousecancel\");\n      } }, a.event.special.swipe = { scrollSupressionThreshold: 30, durationThreshold: 1e3, horizontalDistanceThreshold: 30, verticalDistanceThreshold: 30, getLocation: function getLocation(a) {\n        var c = b.pageXOffset,\n            d = b.pageYOffset,\n            e = a.clientX,\n            f = a.clientY;return 0 === a.pageY && Math.floor(f) > Math.floor(a.pageY) || 0 === a.pageX && Math.floor(e) > Math.floor(a.pageX) ? (e -= c, f -= d) : (f < a.pageY - d || e < a.pageX - c) && (e = a.pageX - c, f = a.pageY - d), { x: e, y: f };\n      }, start: function start(b) {\n        var c = b.originalEvent.touches ? b.originalEvent.touches[0] : b,\n            d = a.event.special.swipe.getLocation(c);return { time: new Date().getTime(), coords: [d.x, d.y], origin: a(b.target) };\n      }, stop: function stop(b) {\n        var c = b.originalEvent.touches ? b.originalEvent.touches[0] : b,\n            d = a.event.special.swipe.getLocation(c);return { time: new Date().getTime(), coords: [d.x, d.y] };\n      }, handleSwipe: function handleSwipe(b, c, d, f) {\n        if (c.time - b.time < a.event.special.swipe.durationThreshold && Math.abs(b.coords[0] - c.coords[0]) > a.event.special.swipe.horizontalDistanceThreshold && Math.abs(b.coords[1] - c.coords[1]) < a.event.special.swipe.verticalDistanceThreshold) {\n          var g = b.coords[0] > c.coords[0] ? \"swipeleft\" : \"swiperight\";return e(d, \"swipe\", a.Event(\"swipe\", { target: f, swipestart: b, swipestop: c }), !0), e(d, g, a.Event(g, { target: f, swipestart: b, swipestop: c }), !0), !0;\n        }return !1;\n      }, eventInProgress: !1, setup: function setup() {\n        var b,\n            c = this,\n            d = a(c),\n            e = {};b = a.data(this, \"mobile-events\"), b || (b = { length: 0 }, a.data(this, \"mobile-events\", b)), b.length++, b.swipe = e, e.start = function (b) {\n          if (!a.event.special.swipe.eventInProgress) {\n            a.event.special.swipe.eventInProgress = !0;var d,\n                g = a.event.special.swipe.start(b),\n                h = b.target,\n                i = !1;e.move = function (b) {\n              g && !b.isDefaultPrevented() && (d = a.event.special.swipe.stop(b), i || (i = a.event.special.swipe.handleSwipe(g, d, c, h), i && (a.event.special.swipe.eventInProgress = !1)), Math.abs(g.coords[0] - d.coords[0]) > a.event.special.swipe.scrollSupressionThreshold && b.preventDefault());\n            }, e.stop = function () {\n              i = !0, a.event.special.swipe.eventInProgress = !1, f.off(k, e.move), e.move = null;\n            }, f.on(k, e.move).one(j, e.stop);\n          }\n        }, d.on(i, e.start);\n      }, teardown: function teardown() {\n        var b, c;b = a.data(this, \"mobile-events\"), b && (c = b.swipe, delete b.swipe, b.length--, 0 === b.length && a.removeData(this, \"mobile-events\")), c && (c.start && a(this).off(i, c.start), c.move && f.off(k, c.move), c.stop && f.off(j, c.stop));\n      } }, a.each({ scrollstop: \"scrollstart\", taphold: \"tap\", swipeleft: \"swipe.left\", swiperight: \"swipe.right\" }, function (b, c) {\n      a.event.special[b] = { setup: function setup() {\n          a(this).bind(c, a.noop);\n        }, teardown: function teardown() {\n          a(this).unbind(c);\n        } };\n    });\n  }(a, this), function (a) {\n    a.event.special.throttledresize = { setup: function setup() {\n        a(this).bind(\"resize\", f);\n      }, teardown: function teardown() {\n        a(this).unbind(\"resize\", f);\n      } };var b,\n        c,\n        d,\n        e = 250,\n        f = function f() {\n      c = new Date().getTime(), d = c - g, d >= e ? (g = c, a(this).trigger(\"throttledresize\")) : (b && clearTimeout(b), b = setTimeout(f, e - d));\n    },\n        g = 0;\n  }(a), function (a, b) {\n    function d() {\n      var a = e();a !== f && (f = a, l.trigger(m));\n    }var e,\n        f,\n        g,\n        h,\n        i,\n        j,\n        k,\n        l = a(b),\n        m = \"orientationchange\",\n        n = { 0: !0, 180: !0 };a.support.orientation && (i = b.innerWidth || l.width(), j = b.innerHeight || l.height(), k = 50, g = i > j && i - j > k, h = n[b.orientation], (g && h || !g && !h) && (n = { \"-90\": !0, 90: !0 })), a.event.special.orientationchange = a.extend({}, a.event.special.orientationchange, { setup: function setup() {\n        return a.support.orientation && !a.event.special.orientationchange.disabled ? !1 : (f = e(), void l.bind(\"throttledresize\", d));\n      }, teardown: function teardown() {\n        return a.support.orientation && !a.event.special.orientationchange.disabled ? !1 : void l.unbind(\"throttledresize\", d);\n      }, add: function add(a) {\n        var b = a.handler;a.handler = function (a) {\n          return a.orientation = e(), b.apply(this, arguments);\n        };\n      } }), a.event.special.orientationchange.orientation = e = function e() {\n      var d = !0,\n          e = c.documentElement;return d = a.support.orientation ? n[b.orientation] : e && e.clientWidth / e.clientHeight < 1.1, d ? \"portrait\" : \"landscape\";\n    }, a.fn[m] = function (a) {\n      return a ? this.bind(m, a) : this.trigger(m);\n    }, a.attrFn && (a.attrFn[m] = !0);\n  }(a, this), function (a) {\n    var b = a(\"head\").children(\"base\"),\n        c = { element: b.length ? b : a(\"<base>\", { href: a.mobile.path.documentBase.hrefNoHash }).prependTo(a(\"head\")), linkSelector: \"[src], link[href], a[rel='external'], :jqmData(ajax='false'), a[target]\", set: function set(b) {\n        a.mobile.dynamicBaseEnabled && a.support.dynamicBaseTag && c.element.attr(\"href\", a.mobile.path.makeUrlAbsolute(b, a.mobile.path.documentBase));\n      }, rewrite: function rewrite(b, d) {\n        var e = a.mobile.path.get(b);d.find(c.linkSelector).each(function (b, c) {\n          var d = a(c).is(\"[href]\") ? \"href\" : a(c).is(\"[src]\") ? \"src\" : \"action\",\n              f = a.mobile.path.parseLocation(),\n              g = a(c).attr(d);g = g.replace(f.protocol + f.doubleSlash + f.host + f.pathname, \"\"), /^(\\w+:|#|\\/)/.test(g) || a(c).attr(d, e + g);\n        });\n      }, reset: function reset() {\n        c.element.attr(\"href\", a.mobile.path.documentBase.hrefNoSearch);\n      } };a.mobile.base = c;\n  }(a), function (a, b) {\n    a.mobile.widgets = {};var c = a.widget,\n        d = a.mobile.keepNative;a.widget = function (c) {\n      return function () {\n        var d = c.apply(this, arguments),\n            e = d.prototype.widgetName;return d.initSelector = d.prototype.initSelector !== b ? d.prototype.initSelector : \":jqmData(role='\" + e + \"')\", a.mobile.widgets[e] = d, d;\n      };\n    }(a.widget), a.extend(a.widget, c), a.mobile.document.on(\"create\", function (b) {\n      a(b.target).enhanceWithin();\n    }), a.widget(\"mobile.page\", { options: { theme: \"a\", domCache: !1, keepNativeDefault: a.mobile.keepNative, contentTheme: null, enhanced: !1 }, _createWidget: function _createWidget() {\n        a.Widget.prototype._createWidget.apply(this, arguments), this._trigger(\"init\");\n      }, _create: function _create() {\n        return this._trigger(\"beforecreate\") === !1 ? !1 : (this.options.enhanced || this._enhance(), this._on(this.element, { pagebeforehide: \"removeContainerBackground\", pagebeforeshow: \"_handlePageBeforeShow\" }), this.element.enhanceWithin(), void (\"dialog\" === a.mobile.getAttribute(this.element[0], \"role\") && a.mobile.dialog && this.element.dialog()));\n      }, _enhance: function _enhance() {\n        var c = \"data-\" + a.mobile.ns,\n            d = this;this.options.role && this.element.attr(\"data-\" + a.mobile.ns + \"role\", this.options.role), this.element.attr(\"tabindex\", \"0\").addClass(\"ui-page ui-page-theme-\" + this.options.theme), this.element.find(\"[\" + c + \"role='content']\").each(function () {\n          var e = a(this),\n              f = this.getAttribute(c + \"theme\") || b;d.options.contentTheme = f || d.options.contentTheme || d.options.dialog && d.options.theme || \"dialog\" === d.element.jqmData(\"role\") && d.options.theme, e.addClass(\"ui-content\"), d.options.contentTheme && e.addClass(\"ui-body-\" + d.options.contentTheme), e.attr(\"role\", \"main\").addClass(\"ui-content\");\n        });\n      }, bindRemove: function bindRemove(b) {\n        var c = this.element;!c.data(\"mobile-page\").options.domCache && c.is(\":jqmData(external-page='true')\") && c.bind(\"pagehide.remove\", b || function (b, c) {\n          if (!c.samePage) {\n            var d = a(this),\n                e = new a.Event(\"pageremove\");d.trigger(e), e.isDefaultPrevented() || d.removeWithDependents();\n          }\n        });\n      }, _setOptions: function _setOptions(c) {\n        c.theme !== b && this.element.removeClass(\"ui-page-theme-\" + this.options.theme).addClass(\"ui-page-theme-\" + c.theme), c.contentTheme !== b && this.element.find(\"[data-\" + a.mobile.ns + \"='content']\").removeClass(\"ui-body-\" + this.options.contentTheme).addClass(\"ui-body-\" + c.contentTheme);\n      }, _handlePageBeforeShow: function _handlePageBeforeShow() {\n        this.setContainerBackground();\n      }, removeContainerBackground: function removeContainerBackground() {\n        this.element.closest(\":mobile-pagecontainer\").pagecontainer({ theme: \"none\" });\n      }, setContainerBackground: function setContainerBackground(a) {\n        this.element.parent().pagecontainer({ theme: a || this.options.theme });\n      }, keepNativeSelector: function keepNativeSelector() {\n        var b = this.options,\n            c = a.trim(b.keepNative || \"\"),\n            e = a.trim(a.mobile.keepNative),\n            f = a.trim(b.keepNativeDefault),\n            g = d === e ? \"\" : e,\n            h = \"\" === g ? f : \"\";return (c ? [c] : []).concat(g ? [g] : []).concat(h ? [h] : []).join(\", \");\n      } });\n  }(a), function (a, d) {\n    a.widget(\"mobile.pagecontainer\", { options: { theme: \"a\" }, initSelector: !1, _create: function _create() {\n        this._trigger(\"beforecreate\"), this.setLastScrollEnabled = !0, this._on(this.window, { navigate: \"_disableRecordScroll\", scrollstop: \"_delayedRecordScroll\" }), this._on(this.window, { navigate: \"_filterNavigateEvents\" }), this._on({ pagechange: \"_afterContentChange\" }), this.window.one(\"navigate\", a.proxy(function () {\n          this.setLastScrollEnabled = !0;\n        }, this));\n      }, _setOptions: function _setOptions(a) {\n        a.theme !== d && \"none\" !== a.theme ? this.element.removeClass(\"ui-overlay-\" + this.options.theme).addClass(\"ui-overlay-\" + a.theme) : a.theme !== d && this.element.removeClass(\"ui-overlay-\" + this.options.theme), this._super(a);\n      }, _disableRecordScroll: function _disableRecordScroll() {\n        this.setLastScrollEnabled = !1;\n      }, _enableRecordScroll: function _enableRecordScroll() {\n        this.setLastScrollEnabled = !0;\n      }, _afterContentChange: function _afterContentChange() {\n        this.setLastScrollEnabled = !0, this._off(this.window, \"scrollstop\"), this._on(this.window, { scrollstop: \"_delayedRecordScroll\" });\n      }, _recordScroll: function _recordScroll() {\n        if (this.setLastScrollEnabled) {\n          var a,\n              b,\n              c,\n              d = this._getActiveHistory();d && (a = this._getScroll(), b = this._getMinScroll(), c = this._getDefaultScroll(), d.lastScroll = b > a ? c : a);\n        }\n      }, _delayedRecordScroll: function _delayedRecordScroll() {\n        setTimeout(a.proxy(this, \"_recordScroll\"), 100);\n      }, _getScroll: function _getScroll() {\n        return this.window.scrollTop();\n      }, _getMinScroll: function _getMinScroll() {\n        return a.mobile.minScrollBack;\n      }, _getDefaultScroll: function _getDefaultScroll() {\n        return a.mobile.defaultHomeScroll;\n      }, _filterNavigateEvents: function _filterNavigateEvents(b, c) {\n        var d;b.originalEvent && b.originalEvent.isDefaultPrevented() || (d = b.originalEvent.type.indexOf(\"hashchange\") > -1 ? c.state.hash : c.state.url, d || (d = this._getHash()), d && \"#\" !== d && 0 !== d.indexOf(\"#\" + a.mobile.path.uiStateKey) || (d = location.href), this._handleNavigate(d, c.state));\n      }, _getHash: function _getHash() {\n        return a.mobile.path.parseLocation().hash;\n      }, getActivePage: function getActivePage() {\n        return this.activePage;\n      }, _getInitialContent: function _getInitialContent() {\n        return a.mobile.firstPage;\n      }, _getHistory: function _getHistory() {\n        return a.mobile.navigate.history;\n      }, _getActiveHistory: function _getActiveHistory() {\n        return this._getHistory().getActive();\n      }, _getDocumentBase: function _getDocumentBase() {\n        return a.mobile.path.documentBase;\n      }, back: function back() {\n        this.go(-1);\n      }, forward: function forward() {\n        this.go(1);\n      }, go: function go(c) {\n        if (a.mobile.hashListeningEnabled) b.history.go(c);else {\n          var d = a.mobile.navigate.history.activeIndex,\n              e = d + parseInt(c, 10),\n              f = a.mobile.navigate.history.stack[e].url,\n              g = c >= 1 ? \"forward\" : \"back\";a.mobile.navigate.history.activeIndex = e, a.mobile.navigate.history.previousIndex = d, this.change(f, { direction: g, changeHash: !1, fromHashChange: !0 });\n        }\n      }, _handleDestination: function _handleDestination(b) {\n        var c;return \"string\" === a.type(b) && (b = a.mobile.path.stripHash(b)), b && (c = this._getHistory(), b = a.mobile.path.isPath(b) ? b : a.mobile.path.makeUrlAbsolute(\"#\" + b, this._getDocumentBase())), b || this._getInitialContent();\n      }, _transitionFromHistory: function _transitionFromHistory(a, b) {\n        var c = this._getHistory(),\n            d = \"back\" === a ? c.getLast() : c.getActive();return d && d.transition || b;\n      }, _handleDialog: function _handleDialog(b, c) {\n        var d,\n            e,\n            f = this.getActivePage();return f && !f.data(\"mobile-dialog\") ? (\"back\" === c.direction ? this.back() : this.forward(), !1) : (d = c.pageUrl, e = this._getActiveHistory(), a.extend(b, { role: e.role, transition: this._transitionFromHistory(c.direction, b.transition), reverse: \"back\" === c.direction }), d);\n      }, _handleNavigate: function _handleNavigate(b, c) {\n        var d = a.mobile.path.stripHash(b),\n            e = this._getHistory(),\n            f = 0 === e.stack.length ? \"none\" : this._transitionFromHistory(c.direction),\n            g = { changeHash: !1, fromHashChange: !0, reverse: \"back\" === c.direction };a.extend(g, c, { transition: f }), e.activeIndex > 0 && d.indexOf(a.mobile.dialogHashKey) > -1 && (d = this._handleDialog(g, c), d === !1) || this._changeContent(this._handleDestination(d), g);\n      }, _changeContent: function _changeContent(b, c) {\n        a.mobile.changePage(b, c);\n      }, _getBase: function _getBase() {\n        return a.mobile.base;\n      }, _getNs: function _getNs() {\n        return a.mobile.ns;\n      }, _enhance: function _enhance(a, b) {\n        return a.page({ role: b });\n      }, _include: function _include(a, b) {\n        a.appendTo(this.element), this._enhance(a, b.role), a.page(\"bindRemove\");\n      }, _find: function _find(b) {\n        var c,\n            d = this._createFileUrl(b),\n            e = this._createDataUrl(b),\n            f = this._getInitialContent();return c = this.element.children(\"[data-\" + this._getNs() + \"url='\" + a.mobile.path.hashToSelector(e) + \"']\"), 0 === c.length && e && !a.mobile.path.isPath(e) && (c = this.element.children(a.mobile.path.hashToSelector(\"#\" + e)).attr(\"data-\" + this._getNs() + \"url\", e).jqmData(\"url\", e)), 0 === c.length && a.mobile.path.isFirstPageUrl(d) && f && f.parent().length && (c = a(f)), c;\n      }, _getLoader: function _getLoader() {\n        return a.mobile.loading();\n      }, _showLoading: function _showLoading(b, c, d, e) {\n        this._loadMsg || (this._loadMsg = setTimeout(a.proxy(function () {\n          this._getLoader().loader(\"show\", c, d, e), this._loadMsg = 0;\n        }, this), b));\n      }, _hideLoading: function _hideLoading() {\n        clearTimeout(this._loadMsg), this._loadMsg = 0, this._getLoader().loader(\"hide\");\n      }, _showError: function _showError() {\n        this._hideLoading(), this._showLoading(0, a.mobile.pageLoadErrorMessageTheme, a.mobile.pageLoadErrorMessage, !0), setTimeout(a.proxy(this, \"_hideLoading\"), 1500);\n      }, _parse: function _parse(b, c) {\n        var d,\n            e = a(\"<div></div>\");return e.get(0).innerHTML = b, d = e.find(\":jqmData(role='page'), :jqmData(role='dialog')\").first(), d.length || (d = a(\"<div data-\" + this._getNs() + \"role='page'>\" + (b.split(/<\\/?body[^>]*>/gim)[1] || \"\") + \"</div>\")), d.attr(\"data-\" + this._getNs() + \"url\", this._createDataUrl(c)).attr(\"data-\" + this._getNs() + \"external-page\", !0), d;\n      }, _setLoadedTitle: function _setLoadedTitle(b, c) {\n        var d = c.match(/<title[^>]*>([^<]*)/) && RegExp.$1;d && !b.jqmData(\"title\") && (d = a(\"<div>\" + d + \"</div>\").text(), b.jqmData(\"title\", d));\n      }, _isRewritableBaseTag: function _isRewritableBaseTag() {\n        return a.mobile.dynamicBaseEnabled && !a.support.dynamicBaseTag;\n      }, _createDataUrl: function _createDataUrl(b) {\n        return a.mobile.path.convertUrlToDataUrl(b);\n      }, _createFileUrl: function _createFileUrl(b) {\n        return a.mobile.path.getFilePath(b);\n      }, _triggerWithDeprecated: function _triggerWithDeprecated(b, c, d) {\n        var e = a.Event(\"page\" + b),\n            f = a.Event(this.widgetName + b);return (d || this.element).trigger(e, c), this._trigger(b, f, c), { deprecatedEvent: e, event: f };\n      }, _loadSuccess: function _loadSuccess(b, c, e, f) {\n        var g = this._createFileUrl(b);return a.proxy(function (h, i, j) {\n          var k,\n              l = new RegExp(\"(<[^>]+\\\\bdata-\" + this._getNs() + \"role=[\\\"']?page[\\\"']?[^>]*>)\"),\n              m = new RegExp(\"\\\\bdata-\" + this._getNs() + \"url=[\\\"']?([^\\\"'>]*)[\\\"']?\");l.test(h) && RegExp.$1 && m.test(RegExp.$1) && RegExp.$1 && (g = a.mobile.path.getFilePath(a(\"<div>\" + RegExp.$1 + \"</div>\").text()), g = this.window[0].encodeURIComponent(g)), e.prefetch === d && this._getBase().set(g), k = this._parse(h, g), this._setLoadedTitle(k, h), c.xhr = j, c.textStatus = i, c.page = k, c.content = k, c.toPage = k, this._triggerWithDeprecated(\"load\", c).event.isDefaultPrevented() || (this._isRewritableBaseTag() && k && this._getBase().rewrite(g, k), this._include(k, e), e.showLoadMsg && this._hideLoading(), f.resolve(b, e, k));\n        }, this);\n      }, _loadDefaults: { type: \"get\", data: d, reloadPage: !1, reload: !1, role: d, showLoadMsg: !1, loadMsgDelay: 50 }, load: function load(b, c) {\n        var e,\n            f,\n            g,\n            h,\n            i = c && c.deferred || a.Deferred(),\n            j = c && c.reload === d && c.reloadPage !== d ? { reload: c.reloadPage } : {},\n            k = a.extend({}, this._loadDefaults, c, j),\n            l = null,\n            m = a.mobile.path.makeUrlAbsolute(b, this._findBaseWithDefault());return k.data && \"get\" === k.type && (m = a.mobile.path.addSearchParams(m, k.data), k.data = d), k.data && \"post\" === k.type && (k.reload = !0), e = this._createFileUrl(m), f = this._createDataUrl(m), l = this._find(m), 0 === l.length && a.mobile.path.isEmbeddedPage(e) && !a.mobile.path.isFirstPageUrl(e) ? (i.reject(m, k), i.promise()) : (this._getBase().reset(), l.length && !k.reload ? (this._enhance(l, k.role), i.resolve(m, k, l), k.prefetch || this._getBase().set(b), i.promise()) : (h = { url: b, absUrl: m, toPage: b, prevPage: c ? c.fromPage : d, dataUrl: f, deferred: i, options: k }, g = this._triggerWithDeprecated(\"beforeload\", h), g.deprecatedEvent.isDefaultPrevented() || g.event.isDefaultPrevented() ? i.promise() : (k.showLoadMsg && this._showLoading(k.loadMsgDelay), k.prefetch === d && this._getBase().reset(), a.mobile.allowCrossDomainPages || a.mobile.path.isSameDomain(a.mobile.path.documentUrl, m) ? (a.ajax({ url: e, type: k.type, data: k.data, contentType: k.contentType, dataType: \"html\", success: this._loadSuccess(m, h, k, i), error: this._loadError(m, h, k, i) }), i.promise()) : (i.reject(m, k), i.promise()))));\n      }, _loadError: function _loadError(b, c, d, e) {\n        return a.proxy(function (f, g, h) {\n          this._getBase().set(a.mobile.path.get()), c.xhr = f, c.textStatus = g, c.errorThrown = h;var i = this._triggerWithDeprecated(\"loadfailed\", c);i.deprecatedEvent.isDefaultPrevented() || i.event.isDefaultPrevented() || (d.showLoadMsg && this._showError(), e.reject(b, d));\n        }, this);\n      }, _getTransitionHandler: function _getTransitionHandler(b) {\n        return b = a.mobile._maybeDegradeTransition(b), a.mobile.transitionHandlers[b] || a.mobile.defaultTransitionHandler;\n      }, _triggerCssTransitionEvents: function _triggerCssTransitionEvents(b, c, d) {\n        var e = !1;d = d || \"\", c && (b[0] === c[0] && (e = !0), this._triggerWithDeprecated(d + \"hide\", { nextPage: b, toPage: b, prevPage: c, samePage: e }, c)), this._triggerWithDeprecated(d + \"show\", { prevPage: c || a(\"\"), toPage: b }, b);\n      }, _cssTransition: function _cssTransition(b, c, d) {\n        var e,\n            f,\n            g = d.transition,\n            h = d.reverse,\n            i = d.deferred;this._triggerCssTransitionEvents(b, c, \"before\"), this._hideLoading(), e = this._getTransitionHandler(g), f = new e(g, h, b, c).transition(), f.done(a.proxy(function () {\n          this._triggerCssTransitionEvents(b, c);\n        }, this)), f.done(function () {\n          i.resolve.apply(i, arguments);\n        });\n      }, _releaseTransitionLock: function _releaseTransitionLock() {\n        f = !1, e.length > 0 && a.mobile.changePage.apply(null, e.pop());\n      }, _removeActiveLinkClass: function _removeActiveLinkClass(b) {\n        a.mobile.removeActiveLinkClass(b);\n      }, _loadUrl: function _loadUrl(b, c, d) {\n        d.target = b, d.deferred = a.Deferred(), this.load(b, d), d.deferred.done(a.proxy(function (a, b, d) {\n          f = !1, b.absUrl = c.absUrl, this.transition(d, c, b);\n        }, this)), d.deferred.fail(a.proxy(function () {\n          this._removeActiveLinkClass(!0), this._releaseTransitionLock(), this._triggerWithDeprecated(\"changefailed\", c);\n        }, this));\n      }, _triggerPageBeforeChange: function _triggerPageBeforeChange(b, c, d) {\n        var e;return c.prevPage = this.activePage, a.extend(c, { toPage: b, options: d }), c.absUrl = \"string\" === a.type(b) ? a.mobile.path.makeUrlAbsolute(b, this._findBaseWithDefault()) : d.absUrl, e = this._triggerWithDeprecated(\"beforechange\", c), e.event.isDefaultPrevented() || e.deprecatedEvent.isDefaultPrevented() ? !1 : !0;\n      }, change: function change(b, c) {\n        if (f) return void e.unshift(arguments);var d = a.extend({}, a.mobile.changePage.defaults, c),\n            g = {};d.fromPage = d.fromPage || this.activePage, this._triggerPageBeforeChange(b, g, d) && (b = g.toPage, \"string\" === a.type(b) ? (f = !0, this._loadUrl(b, g, d)) : this.transition(b, g, d));\n      }, transition: function transition(b, g, h) {\n        var i, j, k, l, m, n, o, p, q, r, s, t, u, v;if (f) return void e.unshift([b, h]);if (this._triggerPageBeforeChange(b, g, h) && (g.prevPage = h.fromPage, v = this._triggerWithDeprecated(\"beforetransition\", g), !v.deprecatedEvent.isDefaultPrevented() && !v.event.isDefaultPrevented())) {\n          if (f = !0, b[0] !== a.mobile.firstPage[0] || h.dataUrl || (h.dataUrl = a.mobile.path.documentUrl.hrefNoHash), i = h.fromPage, j = h.dataUrl && a.mobile.path.convertUrlToDataUrl(h.dataUrl) || b.jqmData(\"url\"), k = j, l = a.mobile.path.getFilePath(j), m = a.mobile.navigate.history.getActive(), n = 0 === a.mobile.navigate.history.activeIndex, o = 0, p = c.title, q = (\"dialog\" === h.role || \"dialog\" === b.jqmData(\"role\")) && b.jqmData(\"dialog\") !== !0, i && i[0] === b[0] && !h.allowSamePageTransition) return f = !1, this._triggerWithDeprecated(\"transition\", g), this._triggerWithDeprecated(\"change\", g), void (h.fromHashChange && a.mobile.navigate.history.direct({ url: j }));b.page({ role: h.role }), h.fromHashChange && (o = \"back\" === h.direction ? -1 : 1);try {\n            c.activeElement && \"body\" !== c.activeElement.nodeName.toLowerCase() ? a(c.activeElement).blur() : a(\"input:focus, textarea:focus, select:focus\").blur();\n          } catch (w) {}r = !1, q && m && (m.url && m.url.indexOf(a.mobile.dialogHashKey) > -1 && this.activePage && !this.activePage.hasClass(\"ui-dialog\") && a.mobile.navigate.history.activeIndex > 0 && (h.changeHash = !1, r = !0), j = m.url || \"\", j += !r && j.indexOf(\"#\") > -1 ? a.mobile.dialogHashKey : \"#\" + a.mobile.dialogHashKey), s = m ? b.jqmData(\"title\") || b.children(\":jqmData(role='header')\").find(\".ui-title\").text() : p, s && p === c.title && (p = s), b.jqmData(\"title\") || b.jqmData(\"title\", p), h.transition = h.transition || (o && !n ? m.transition : d) || (q ? a.mobile.defaultDialogTransition : a.mobile.defaultPageTransition), !o && r && (a.mobile.navigate.history.getActive().pageUrl = k), j && !h.fromHashChange && (!a.mobile.path.isPath(j) && j.indexOf(\"#\") < 0 && (j = \"#\" + j), t = { transition: h.transition, title: p, pageUrl: k, role: h.role }, h.changeHash !== !1 && a.mobile.hashListeningEnabled ? a.mobile.navigate(this.window[0].encodeURI(j), t, !0) : b[0] !== a.mobile.firstPage[0] && a.mobile.navigate.history.add(j, t)), c.title = p, a.mobile.activePage = b, this.activePage = b, h.reverse = h.reverse || 0 > o, u = a.Deferred(), this._cssTransition(b, i, { transition: h.transition, reverse: h.reverse, deferred: u }), u.done(a.proxy(function (c, d, e, f, i) {\n            a.mobile.removeActiveLinkClass(), h.duplicateCachedPage && h.duplicateCachedPage.remove(), i || a.mobile.focusPage(b), this._releaseTransitionLock(), this._triggerWithDeprecated(\"transition\", g), this._triggerWithDeprecated(\"change\", g);\n          }, this));\n        }\n      }, _findBaseWithDefault: function _findBaseWithDefault() {\n        var b = this.activePage && a.mobile.getClosestBaseUrl(this.activePage);return b || a.mobile.path.documentBase.hrefNoHash;\n      } }), a.mobile.navreadyDeferred = a.Deferred();var e = [],\n        f = !1;\n  }(a), function (a, d) {\n    function e(a) {\n      for (; a && (\"string\" != typeof a.nodeName || \"a\" !== a.nodeName.toLowerCase());) {\n        a = a.parentNode;\n      }return a;\n    }var f = a.Deferred(),\n        g = a.Deferred(),\n        h = function h() {\n      g.resolve(), g = null;\n    },\n        i = a.mobile.path.documentUrl,\n        j = null;a.mobile.loadPage = function (b, c) {\n      var d;return c = c || {}, d = c.pageContainer || a.mobile.pageContainer, c.deferred = a.Deferred(), d.pagecontainer(\"load\", b, c), c.deferred.promise();\n    }, a.mobile.back = function () {\n      var c = b.navigator;this.phonegapNavigationEnabled && c && c.app && c.app.backHistory ? c.app.backHistory() : a.mobile.pageContainer.pagecontainer(\"back\");\n    }, a.mobile.focusPage = function (a) {\n      var b = a.find(\"[autofocus]\"),\n          c = a.find(\".ui-title:eq(0)\");return b.length ? void b.focus() : void (c.length ? c.focus() : a.focus());\n    }, a.mobile._maybeDegradeTransition = a.mobile._maybeDegradeTransition || function (a) {\n      return a;\n    }, a.mobile.changePage = function (b, c) {\n      a.mobile.pageContainer.pagecontainer(\"change\", b, c);\n    }, a.mobile.changePage.defaults = { transition: d, reverse: !1, changeHash: !0, fromHashChange: !1, role: d, duplicateCachedPage: d, pageContainer: d, showLoadMsg: !0, dataUrl: d, fromPage: d, allowSamePageTransition: !1 }, a.mobile._registerInternalEvents = function () {\n      var c = function c(b, _c) {\n        var d,\n            e,\n            f,\n            g,\n            h = !0;return !a.mobile.ajaxEnabled || b.is(\":jqmData(ajax='false')\") || !b.jqmHijackable().length || b.attr(\"target\") ? !1 : (d = j && j.attr(\"formaction\") || b.attr(\"action\"), g = (b.attr(\"method\") || \"get\").toLowerCase(), d || (d = a.mobile.getClosestBaseUrl(b), \"get\" === g && (d = a.mobile.path.parseUrl(d).hrefNoSearch), d === a.mobile.path.documentBase.hrefNoHash && (d = i.hrefNoSearch)), d = a.mobile.path.makeUrlAbsolute(d, a.mobile.getClosestBaseUrl(b)), a.mobile.path.isExternal(d) && !a.mobile.path.isPermittedCrossDomainRequest(i, d) ? !1 : (_c || (e = b.serializeArray(), j && j[0].form === b[0] && (f = j.attr(\"name\"), f && (a.each(e, function (a, b) {\n          return b.name === f ? (f = \"\", !1) : void 0;\n        }), f && e.push({ name: f, value: j.attr(\"value\") }))), h = { url: d, options: { type: g, data: a.param(e), transition: b.jqmData(\"transition\"), reverse: \"reverse\" === b.jqmData(\"direction\"), reloadPage: !0 } }), h));\n      };a.mobile.document.delegate(\"form\", \"submit\", function (b) {\n        var d;b.isDefaultPrevented() || (d = c(a(this)), d && (a.mobile.changePage(d.url, d.options), b.preventDefault()));\n      }), a.mobile.document.bind(\"vclick\", function (b) {\n        var d,\n            f,\n            g = b.target,\n            h = !1;if (!(b.which > 1) && a.mobile.linkBindingEnabled) {\n          if (j = a(g), a.data(g, \"mobile-button\")) {\n            if (!c(a(g).closest(\"form\"), !0)) return;g.parentNode && (g = g.parentNode);\n          } else {\n            if (g = e(g), !g || \"#\" === a.mobile.path.parseUrl(g.getAttribute(\"href\") || \"#\").hash) return;if (!a(g).jqmHijackable().length) return;\n          }~g.className.indexOf(\"ui-link-inherit\") ? g.parentNode && (f = a.data(g.parentNode, \"buttonElements\")) : f = a.data(g, \"buttonElements\"), f ? g = f.outer : h = !0, d = a(g), h && (d = d.closest(\".ui-btn\")), d.length > 0 && !d.hasClass(\"ui-state-disabled\") && (a.mobile.removeActiveLinkClass(!0), a.mobile.activeClickedLink = d, a.mobile.activeClickedLink.addClass(a.mobile.activeBtnClass));\n        }\n      }), a.mobile.document.bind(\"click\", function (c) {\n        if (a.mobile.linkBindingEnabled && !c.isDefaultPrevented()) {\n          var f,\n              g,\n              h,\n              j,\n              k,\n              l,\n              m,\n              n = e(c.target),\n              o = a(n),\n              p = function p() {\n            b.setTimeout(function () {\n              a.mobile.removeActiveLinkClass(!0);\n            }, 200);\n          };if (a.mobile.activeClickedLink && a.mobile.activeClickedLink[0] === c.target.parentNode && p(), n && !(c.which > 1) && o.jqmHijackable().length) {\n            if (o.is(\":jqmData(rel='back')\")) return a.mobile.back(), !1;if (f = a.mobile.getClosestBaseUrl(o), g = a.mobile.path.makeUrlAbsolute(o.attr(\"href\") || \"#\", f), !a.mobile.ajaxEnabled && !a.mobile.path.isEmbeddedPage(g)) return void p();if (!(-1 === g.search(\"#\") || a.mobile.path.isExternal(g) && a.mobile.path.isAbsoluteUrl(g))) {\n              if (g = g.replace(/[^#]*#/, \"\"), !g) return void c.preventDefault();g = a.mobile.path.isPath(g) ? a.mobile.path.makeUrlAbsolute(g, f) : a.mobile.path.makeUrlAbsolute(\"#\" + g, i.hrefNoHash);\n            }if (h = o.is(\"[rel='external']\") || o.is(\":jqmData(ajax='false')\") || o.is(\"[target]\"), j = h || a.mobile.path.isExternal(g) && !a.mobile.path.isPermittedCrossDomainRequest(i, g)) return void p();k = o.jqmData(\"transition\"), l = \"reverse\" === o.jqmData(\"direction\") || o.jqmData(\"back\"), m = o.attr(\"data-\" + a.mobile.ns + \"rel\") || d, a.mobile.changePage(g, { transition: k, reverse: l, role: m, link: o }), c.preventDefault();\n          }\n        }\n      }), a.mobile.document.delegate(\".ui-page\", \"pageshow.prefetch\", function () {\n        var b = [];a(this).find(\"a:jqmData(prefetch)\").each(function () {\n          var c = a(this),\n              d = c.attr(\"href\");d && -1 === a.inArray(d, b) && (b.push(d), a.mobile.loadPage(d, { role: c.attr(\"data-\" + a.mobile.ns + \"rel\"), prefetch: !0 }));\n        });\n      }), a.mobile.pageContainer.pagecontainer(), a.mobile.document.bind(\"pageshow\", function () {\n        g ? g.done(a.mobile.resetActivePageHeight) : a.mobile.resetActivePageHeight();\n      }), a.mobile.window.bind(\"throttledresize\", a.mobile.resetActivePageHeight);\n    }, a(function () {\n      f.resolve();\n    }), \"complete\" === c.readyState ? h() : a.mobile.window.load(h), a.when(f, a.mobile.navreadyDeferred).done(function () {\n      a.mobile._registerInternalEvents();\n    });\n  }(a), function (a, b) {\n    a.mobile.Transition = function () {\n      this.init.apply(this, arguments);\n    }, a.extend(a.mobile.Transition.prototype, { toPreClass: \" ui-page-pre-in\", init: function init(b, c, d, e) {\n        a.extend(this, { name: b, reverse: c, $to: d, $from: e, deferred: new a.Deferred() });\n      }, cleanFrom: function cleanFrom() {\n        this.$from.removeClass(a.mobile.activePageClass + \" out in reverse \" + this.name).height(\"\");\n      }, beforeDoneIn: function beforeDoneIn() {}, beforeDoneOut: function beforeDoneOut() {}, beforeStartOut: function beforeStartOut() {}, doneIn: function doneIn() {\n        this.beforeDoneIn(), this.$to.removeClass(\"out in reverse \" + this.name).height(\"\"), this.toggleViewportClass(), a.mobile.window.scrollTop() !== this.toScroll && this.scrollPage(), this.sequential || this.$to.addClass(a.mobile.activePageClass), this.deferred.resolve(this.name, this.reverse, this.$to, this.$from, !0);\n      }, doneOut: function doneOut(a, b, c, d) {\n        this.beforeDoneOut(), this.startIn(a, b, c, d);\n      }, hideIn: function hideIn(a) {\n        this.$to.css(\"z-index\", -10), a.call(this), this.$to.css(\"z-index\", \"\");\n      }, scrollPage: function scrollPage() {\n        a.event.special.scrollstart.enabled = !1, (a.mobile.hideUrlBar || this.toScroll !== a.mobile.defaultHomeScroll) && b.scrollTo(0, this.toScroll), setTimeout(function () {\n          a.event.special.scrollstart.enabled = !0;\n        }, 150);\n      }, startIn: function startIn(b, c, d, e) {\n        this.hideIn(function () {\n          this.$to.addClass(a.mobile.activePageClass + this.toPreClass), e || a.mobile.focusPage(this.$to), this.$to.height(b + this.toScroll), d || this.scrollPage();\n        }), this.$to.removeClass(this.toPreClass).addClass(this.name + \" in \" + c), d ? this.doneIn() : this.$to.animationComplete(a.proxy(function () {\n          this.doneIn();\n        }, this));\n      }, startOut: function startOut(b, c, d) {\n        this.beforeStartOut(b, c, d), this.$from.height(b + a.mobile.window.scrollTop()).addClass(this.name + \" out\" + c);\n      }, toggleViewportClass: function toggleViewportClass() {\n        a.mobile.pageContainer.toggleClass(\"ui-mobile-viewport-transitioning viewport-\" + this.name);\n      }, transition: function transition() {\n        var b,\n            c = this.reverse ? \" reverse\" : \"\",\n            d = a.mobile.getScreenHeight(),\n            e = a.mobile.maxTransitionWidth !== !1 && a.mobile.window.width() > a.mobile.maxTransitionWidth;return this.toScroll = a.mobile.navigate.history.getActive().lastScroll || a.mobile.defaultHomeScroll, b = !a.support.cssTransitions || !a.support.cssAnimations || e || !this.name || \"none\" === this.name || Math.max(a.mobile.window.scrollTop(), this.toScroll) > a.mobile.getMaxScrollForTransition(), this.toggleViewportClass(), this.$from && !b ? this.startOut(d, c, b) : this.doneOut(d, c, b, !0), this.deferred.promise();\n      } });\n  }(a, this), function (a) {\n    a.mobile.SerialTransition = function () {\n      this.init.apply(this, arguments);\n    }, a.extend(a.mobile.SerialTransition.prototype, a.mobile.Transition.prototype, { sequential: !0, beforeDoneOut: function beforeDoneOut() {\n        this.$from && this.cleanFrom();\n      }, beforeStartOut: function beforeStartOut(b, c, d) {\n        this.$from.animationComplete(a.proxy(function () {\n          this.doneOut(b, c, d);\n        }, this));\n      } });\n  }(a), function (a) {\n    a.mobile.ConcurrentTransition = function () {\n      this.init.apply(this, arguments);\n    }, a.extend(a.mobile.ConcurrentTransition.prototype, a.mobile.Transition.prototype, { sequential: !1, beforeDoneIn: function beforeDoneIn() {\n        this.$from && this.cleanFrom();\n      }, beforeStartOut: function beforeStartOut(a, b, c) {\n        this.doneOut(a, b, c);\n      } });\n  }(a), function (a) {\n    var b = function b() {\n      return 3 * a.mobile.getScreenHeight();\n    };a.mobile.transitionHandlers = { sequential: a.mobile.SerialTransition, simultaneous: a.mobile.ConcurrentTransition }, a.mobile.defaultTransitionHandler = a.mobile.transitionHandlers.sequential, a.mobile.transitionFallbacks = {}, a.mobile._maybeDegradeTransition = function (b) {\n      return b && !a.support.cssTransform3d && a.mobile.transitionFallbacks[b] && (b = a.mobile.transitionFallbacks[b]), b;\n    }, a.mobile.getMaxScrollForTransition = a.mobile.getMaxScrollForTransition || b;\n  }(a), function (a) {\n    a.mobile.transitionFallbacks.flip = \"fade\";\n  }(a, this), function (a) {\n    a.mobile.transitionFallbacks.flow = \"fade\";\n  }(a, this), function (a) {\n    a.mobile.transitionFallbacks.pop = \"fade\";\n  }(a, this), function (a) {\n    a.mobile.transitionHandlers.slide = a.mobile.transitionHandlers.simultaneous, a.mobile.transitionFallbacks.slide = \"fade\";\n  }(a, this), function (a) {\n    a.mobile.transitionFallbacks.slidedown = \"fade\";\n  }(a, this), function (a) {\n    a.mobile.transitionFallbacks.slidefade = \"fade\";\n  }(a, this), function (a) {\n    a.mobile.transitionFallbacks.slideup = \"fade\";\n  }(a, this), function (a) {\n    a.mobile.transitionFallbacks.turn = \"fade\";\n  }(a, this), function (a) {\n    a.mobile.degradeInputs = { color: !1, date: !1, datetime: !1, \"datetime-local\": !1, email: !1, month: !1, number: !1, range: \"number\", search: \"text\", tel: !1, time: !1, url: !1, week: !1 }, a.mobile.page.prototype.options.degradeInputs = a.mobile.degradeInputs, a.mobile.degradeInputsWithin = function (b) {\n      b = a(b), b.find(\"input\").not(a.mobile.page.prototype.keepNativeSelector()).each(function () {\n        var b,\n            c,\n            d,\n            e,\n            f = a(this),\n            g = this.getAttribute(\"type\"),\n            h = a.mobile.degradeInputs[g] || \"text\";a.mobile.degradeInputs[g] && (b = a(\"<div>\").html(f.clone()).html(), c = b.indexOf(\" type=\") > -1, d = c ? /\\s+type=[\"']?\\w+['\"]?/ : /\\/?>/, e = ' type=\"' + h + '\" data-' + a.mobile.ns + 'type=\"' + g + '\"' + (c ? \"\" : \">\"), f.replaceWith(b.replace(d, e)));\n      });\n    };\n  }(a), function (a, b, c) {\n    a.widget(\"mobile.page\", a.mobile.page, { options: { closeBtn: \"left\", closeBtnText: \"Close\", overlayTheme: \"a\", corners: !0, dialog: !1 }, _create: function _create() {\n        this._super(), this.options.dialog && (a.extend(this, { _inner: this.element.children(), _headerCloseButton: null }), this.options.enhanced || this._setCloseBtn(this.options.closeBtn));\n      }, _enhance: function _enhance() {\n        this._super(), this.options.dialog && this.element.addClass(\"ui-dialog\").wrapInner(a(\"<div/>\", { role: \"dialog\", \"class\": \"ui-dialog-contain ui-overlay-shadow\" + (this.options.corners ? \" ui-corner-all\" : \"\") }));\n      }, _setOptions: function _setOptions(b) {\n        var d,\n            e,\n            f = this.options;b.corners !== c && this._inner.toggleClass(\"ui-corner-all\", !!b.corners), b.overlayTheme !== c && a.mobile.activePage[0] === this.element[0] && (f.overlayTheme = b.overlayTheme, this._handlePageBeforeShow()), b.closeBtnText !== c && (d = f.closeBtn, e = b.closeBtnText), b.closeBtn !== c && (d = b.closeBtn), d && this._setCloseBtn(d, e), this._super(b);\n      }, _handlePageBeforeShow: function _handlePageBeforeShow() {\n        this.options.overlayTheme && this.options.dialog ? (this.removeContainerBackground(), this.setContainerBackground(this.options.overlayTheme)) : this._super();\n      }, _setCloseBtn: function _setCloseBtn(b, c) {\n        var d,\n            e = this._headerCloseButton;b = \"left\" === b ? \"left\" : \"right\" === b ? \"right\" : \"none\", \"none\" === b ? e && (e.remove(), e = null) : e ? (e.removeClass(\"ui-btn-left ui-btn-right\").addClass(\"ui-btn-\" + b), c && e.text(c)) : (d = this._inner.find(\":jqmData(role='header')\").first(), e = a(\"<a></a>\", { href: \"#\", \"class\": \"ui-btn ui-corner-all ui-icon-delete ui-btn-icon-notext ui-btn-\" + b }).attr(\"data-\" + a.mobile.ns + \"rel\", \"back\").text(c || this.options.closeBtnText || \"\").prependTo(d)), this._headerCloseButton = e;\n      } });\n  }(a, this), function (a, b, c) {\n    a.widget(\"mobile.dialog\", { options: { closeBtn: \"left\", closeBtnText: \"Close\", overlayTheme: \"a\", corners: !0 }, _handlePageBeforeShow: function _handlePageBeforeShow() {\n        this._isCloseable = !0, this.options.overlayTheme && this.element.page(\"removeContainerBackground\").page(\"setContainerBackground\", this.options.overlayTheme);\n      }, _handlePageBeforeHide: function _handlePageBeforeHide() {\n        this._isCloseable = !1;\n      }, _handleVClickSubmit: function _handleVClickSubmit(b) {\n        var c,\n            d = a(b.target).closest(\"vclick\" === b.type ? \"a\" : \"form\");d.length && !d.jqmData(\"transition\") && (c = {}, c[\"data-\" + a.mobile.ns + \"transition\"] = (a.mobile.navigate.history.getActive() || {}).transition || a.mobile.defaultDialogTransition, c[\"data-\" + a.mobile.ns + \"direction\"] = \"reverse\", d.attr(c));\n      }, _create: function _create() {\n        var b = this.element,\n            c = this.options;b.addClass(\"ui-dialog\").wrapInner(a(\"<div/>\", { role: \"dialog\", \"class\": \"ui-dialog-contain ui-overlay-shadow\" + (c.corners ? \" ui-corner-all\" : \"\") })), a.extend(this, { _isCloseable: !1, _inner: b.children(), _headerCloseButton: null }), this._on(b, { vclick: \"_handleVClickSubmit\", submit: \"_handleVClickSubmit\", pagebeforeshow: \"_handlePageBeforeShow\", pagebeforehide: \"_handlePageBeforeHide\" }), this._setCloseBtn(c.closeBtn);\n      }, _setOptions: function _setOptions(b) {\n        var d,\n            e,\n            f = this.options;b.corners !== c && this._inner.toggleClass(\"ui-corner-all\", !!b.corners), b.overlayTheme !== c && a.mobile.activePage[0] === this.element[0] && (f.overlayTheme = b.overlayTheme, this._handlePageBeforeShow()), b.closeBtnText !== c && (d = f.closeBtn, e = b.closeBtnText), b.closeBtn !== c && (d = b.closeBtn), d && this._setCloseBtn(d, e), this._super(b);\n      }, _setCloseBtn: function _setCloseBtn(b, c) {\n        var d,\n            e = this._headerCloseButton;b = \"left\" === b ? \"left\" : \"right\" === b ? \"right\" : \"none\", \"none\" === b ? e && (e.remove(), e = null) : e ? (e.removeClass(\"ui-btn-left ui-btn-right\").addClass(\"ui-btn-\" + b), c && e.text(c)) : (d = this._inner.find(\":jqmData(role='header')\").first(), e = a(\"<a></a>\", { role: \"button\", href: \"#\", \"class\": \"ui-btn ui-corner-all ui-icon-delete ui-btn-icon-notext ui-btn-\" + b }).text(c || this.options.closeBtnText || \"\").prependTo(d), this._on(e, { click: \"close\" })), this._headerCloseButton = e;\n      }, close: function close() {\n        var b = a.mobile.navigate.history;this._isCloseable && (this._isCloseable = !1, a.mobile.hashListeningEnabled && b.activeIndex > 0 ? a.mobile.back() : a.mobile.pageContainer.pagecontainer(\"back\"));\n      } });\n  }(a, this), function (a, b) {\n    var c = /([A-Z])/g,\n        d = function d(a) {\n      return \"ui-btn-icon-\" + (null === a ? \"left\" : a);\n    };a.widget(\"mobile.collapsible\", { options: { enhanced: !1, expandCueText: null, collapseCueText: null, collapsed: !0, heading: \"h1,h2,h3,h4,h5,h6,legend\", collapsedIcon: null, expandedIcon: null, iconpos: null, theme: null, contentTheme: null, inset: null, corners: null, mini: null }, _create: function _create() {\n        var b = this.element,\n            c = { accordion: b.closest(\":jqmData(role='collapsible-set'),:jqmData(role='collapsibleset')\" + (a.mobile.collapsibleset ? \", :mobile-collapsibleset\" : \"\")).addClass(\"ui-collapsible-set\") };this._ui = c, this._renderedOptions = this._getOptions(this.options), this.options.enhanced ? (c.heading = this.element.children(\".ui-collapsible-heading\"), c.content = c.heading.next(), c.anchor = c.heading.children(), c.status = c.anchor.children(\".ui-collapsible-heading-status\")) : this._enhance(b, c), this._on(c.heading, { tap: function tap() {\n            c.heading.find(\"a\").first().addClass(a.mobile.activeBtnClass);\n          }, click: function click(a) {\n            this._handleExpandCollapse(!c.heading.hasClass(\"ui-collapsible-heading-collapsed\")), a.preventDefault(), a.stopPropagation();\n          } });\n      }, _getOptions: function _getOptions(b) {\n        var d,\n            e = this._ui.accordion,\n            f = this._ui.accordionWidget;b = a.extend({}, b), e.length && !f && (this._ui.accordionWidget = f = e.data(\"mobile-collapsibleset\"));for (d in b) {\n          b[d] = null != b[d] ? b[d] : f ? f.options[d] : e.length ? a.mobile.getAttribute(e[0], d.replace(c, \"-$1\").toLowerCase()) : null, null == b[d] && (b[d] = a.mobile.collapsible.defaults[d]);\n        }return b;\n      }, _themeClassFromOption: function _themeClassFromOption(a, b) {\n        return b ? \"none\" === b ? \"\" : a + b : \"\";\n      }, _enhance: function _enhance(b, c) {\n        var e,\n            f = this._renderedOptions,\n            g = this._themeClassFromOption(\"ui-body-\", f.contentTheme);return b.addClass(\"ui-collapsible \" + (f.inset ? \"ui-collapsible-inset \" : \"\") + (f.inset && f.corners ? \"ui-corner-all \" : \"\") + (g ? \"ui-collapsible-themed-content \" : \"\")), c.originalHeading = b.children(this.options.heading).first(), c.content = b.wrapInner(\"<div class='ui-collapsible-content \" + g + \"'></div>\").children(\".ui-collapsible-content\"), c.heading = c.originalHeading, c.heading.is(\"legend\") && (c.heading = a(\"<div role='heading'>\" + c.heading.html() + \"</div>\"), c.placeholder = a(\"<div><!-- placeholder for legend --></div>\").insertBefore(c.originalHeading), c.originalHeading.remove()), e = f.collapsed ? f.collapsedIcon ? \"ui-icon-\" + f.collapsedIcon : \"\" : f.expandedIcon ? \"ui-icon-\" + f.expandedIcon : \"\", c.status = a(\"<span class='ui-collapsible-heading-status'></span>\"), c.anchor = c.heading.detach().addClass(\"ui-collapsible-heading\").append(c.status).wrapInner(\"<a href='#' class='ui-collapsible-heading-toggle'></a>\").find(\"a\").first().addClass(\"ui-btn \" + (e ? e + \" \" : \"\") + (e ? d(f.iconpos) + \" \" : \"\") + this._themeClassFromOption(\"ui-btn-\", f.theme) + \" \" + (f.mini ? \"ui-mini \" : \"\")), c.heading.insertBefore(c.content), this._handleExpandCollapse(this.options.collapsed), c;\n      }, refresh: function refresh() {\n        this._applyOptions(this.options), this._renderedOptions = this._getOptions(this.options);\n      }, _applyOptions: function _applyOptions(a) {\n        var c,\n            e,\n            f,\n            g,\n            h,\n            i = this.element,\n            j = this._renderedOptions,\n            k = this._ui,\n            l = k.anchor,\n            m = k.status,\n            n = this._getOptions(a);a.collapsed !== b && this._handleExpandCollapse(a.collapsed), c = i.hasClass(\"ui-collapsible-collapsed\"), c ? n.expandCueText !== b && m.text(n.expandCueText) : n.collapseCueText !== b && m.text(n.collapseCueText), h = n.collapsedIcon !== b ? n.collapsedIcon !== !1 : j.collapsedIcon !== !1, (n.iconpos !== b || n.collapsedIcon !== b || n.expandedIcon !== b) && (l.removeClass([d(j.iconpos)].concat(j.expandedIcon ? [\"ui-icon-\" + j.expandedIcon] : []).concat(j.collapsedIcon ? [\"ui-icon-\" + j.collapsedIcon] : []).join(\" \")), h && l.addClass([d(n.iconpos !== b ? n.iconpos : j.iconpos)].concat(c ? [\"ui-icon-\" + (n.collapsedIcon !== b ? n.collapsedIcon : j.collapsedIcon)] : [\"ui-icon-\" + (n.expandedIcon !== b ? n.expandedIcon : j.expandedIcon)]).join(\" \"))), n.theme !== b && (f = this._themeClassFromOption(\"ui-btn-\", j.theme), e = this._themeClassFromOption(\"ui-btn-\", n.theme), l.removeClass(f).addClass(e)), n.contentTheme !== b && (f = this._themeClassFromOption(\"ui-body-\", j.contentTheme), e = this._themeClassFromOption(\"ui-body-\", n.contentTheme), k.content.removeClass(f).addClass(e)), n.inset !== b && (i.toggleClass(\"ui-collapsible-inset\", n.inset), g = !(!n.inset || !n.corners && !j.corners)), n.corners !== b && (g = !(!n.corners || !n.inset && !j.inset)), g !== b && i.toggleClass(\"ui-corner-all\", g), n.mini !== b && l.toggleClass(\"ui-mini\", n.mini);\n      }, _setOptions: function _setOptions(a) {\n        this._applyOptions(a), this._super(a), this._renderedOptions = this._getOptions(this.options);\n      }, _handleExpandCollapse: function _handleExpandCollapse(b) {\n        var c = this._renderedOptions,\n            d = this._ui;d.status.text(b ? c.expandCueText : c.collapseCueText), d.heading.toggleClass(\"ui-collapsible-heading-collapsed\", b).find(\"a\").first().toggleClass(\"ui-icon-\" + c.expandedIcon, !b).toggleClass(\"ui-icon-\" + c.collapsedIcon, b || c.expandedIcon === c.collapsedIcon).removeClass(a.mobile.activeBtnClass), this.element.toggleClass(\"ui-collapsible-collapsed\", b), d.content.toggleClass(\"ui-collapsible-content-collapsed\", b).attr(\"aria-hidden\", b).trigger(\"updatelayout\"), this.options.collapsed = b, this._trigger(b ? \"collapse\" : \"expand\");\n      }, expand: function expand() {\n        this._handleExpandCollapse(!1);\n      }, collapse: function collapse() {\n        this._handleExpandCollapse(!0);\n      }, _destroy: function _destroy() {\n        var a = this._ui,\n            b = this.options;b.enhanced || (a.placeholder ? (a.originalHeading.insertBefore(a.placeholder), a.placeholder.remove(), a.heading.remove()) : (a.status.remove(), a.heading.removeClass(\"ui-collapsible-heading ui-collapsible-heading-collapsed\").children().contents().unwrap()), a.anchor.contents().unwrap(), a.content.contents().unwrap(), this.element.removeClass(\"ui-collapsible ui-collapsible-collapsed ui-collapsible-themed-content ui-collapsible-inset ui-corner-all\"));\n      } }), a.mobile.collapsible.defaults = { expandCueText: \" click to expand contents\", collapseCueText: \" click to collapse contents\", collapsedIcon: \"plus\", contentTheme: \"inherit\", expandedIcon: \"minus\", iconpos: \"left\", inset: !0, corners: !0, theme: \"inherit\", mini: !1 };\n  }(a), function (a) {\n    function b(b) {\n      var d,\n          e = b.length,\n          f = [];for (d = 0; e > d; d++) {\n        b[d].className.match(c) || f.push(b[d]);\n      }return a(f);\n    }var c = /\\bui-screen-hidden\\b/;a.mobile.behaviors.addFirstLastClasses = { _getVisibles: function _getVisibles(a, c) {\n        var d;return c ? d = b(a) : (d = a.filter(\":visible\"), 0 === d.length && (d = b(a))), d;\n      }, _addFirstLastClasses: function _addFirstLastClasses(a, b, c) {\n        a.removeClass(\"ui-first-child ui-last-child\"), b.eq(0).addClass(\"ui-first-child\").end().last().addClass(\"ui-last-child\"), c || this.element.trigger(\"updatelayout\");\n      }, _removeFirstLastClasses: function _removeFirstLastClasses(a) {\n        a.removeClass(\"ui-first-child ui-last-child\");\n      } };\n  }(a), function (a, b) {\n    var c = \":mobile-collapsible, \" + a.mobile.collapsible.initSelector;a.widget(\"mobile.collapsibleset\", a.extend({ initSelector: \":jqmData(role='collapsible-set'),:jqmData(role='collapsibleset')\", options: a.extend({ enhanced: !1 }, a.mobile.collapsible.defaults), _handleCollapsibleExpand: function _handleCollapsibleExpand(b) {\n        var c = a(b.target).closest(\".ui-collapsible\");c.parent().is(\":mobile-collapsibleset, :jqmData(role='collapsible-set')\") && c.siblings(\".ui-collapsible:not(.ui-collapsible-collapsed)\").collapsible(\"collapse\");\n      }, _create: function _create() {\n        var b = this.element,\n            c = this.options;a.extend(this, { _classes: \"\" }), c.enhanced || (b.addClass(\"ui-collapsible-set \" + this._themeClassFromOption(\"ui-group-theme-\", c.theme) + \" \" + (c.corners && c.inset ? \"ui-corner-all \" : \"\")), this.element.find(a.mobile.collapsible.initSelector).collapsible()), this._on(b, { collapsibleexpand: \"_handleCollapsibleExpand\" });\n      }, _themeClassFromOption: function _themeClassFromOption(a, b) {\n        return b ? \"none\" === b ? \"\" : a + b : \"\";\n      }, _init: function _init() {\n        this._refresh(!0), this.element.children(c).filter(\":jqmData(collapsed='false')\").collapsible(\"expand\");\n      }, _setOptions: function _setOptions(a) {\n        var c,\n            d,\n            e = this.element,\n            f = this._themeClassFromOption(\"ui-group-theme-\", a.theme);return f && e.removeClass(this._themeClassFromOption(\"ui-group-theme-\", this.options.theme)).addClass(f), a.inset !== b && (d = !(!a.inset || !a.corners && !this.options.corners)), a.corners !== b && (d = !(!a.corners || !a.inset && !this.options.inset)), d !== b && e.toggleClass(\"ui-corner-all\", d), c = this._super(a), this.element.children(\":mobile-collapsible\").collapsible(\"refresh\"), c;\n      }, _destroy: function _destroy() {\n        var a = this.element;this._removeFirstLastClasses(a.children(c)), a.removeClass(\"ui-collapsible-set ui-corner-all \" + this._themeClassFromOption(\"ui-group-theme-\", this.options.theme)).children(\":mobile-collapsible\").collapsible(\"destroy\");\n      }, _refresh: function _refresh(b) {\n        var d = this.element.children(c);this.element.find(a.mobile.collapsible.initSelector).not(\".ui-collapsible\").collapsible(), this._addFirstLastClasses(d, this._getVisibles(d, b), b);\n      }, refresh: function refresh() {\n        this._refresh(!1);\n      } }, a.mobile.behaviors.addFirstLastClasses));\n  }(a), function (a) {\n    a.fn.fieldcontain = function () {\n      return this.addClass(\"ui-field-contain\");\n    };\n  }(a), function (a) {\n    a.fn.grid = function (b) {\n      return this.each(function () {\n        var c,\n            d,\n            e = a(this),\n            f = a.extend({ grid: null }, b),\n            g = e.children(),\n            h = { solo: 1, a: 2, b: 3, c: 4, d: 5 },\n            i = f.grid;if (!i) if (g.length <= 5) for (d in h) {\n          h[d] === g.length && (i = d);\n        } else i = \"a\", e.addClass(\"ui-grid-duo\");c = h[i], e.addClass(\"ui-grid-\" + i), g.filter(\":nth-child(\" + c + \"n+1)\").addClass(\"ui-block-a\"), c > 1 && g.filter(\":nth-child(\" + c + \"n+2)\").addClass(\"ui-block-b\"), c > 2 && g.filter(\":nth-child(\" + c + \"n+3)\").addClass(\"ui-block-c\"), c > 3 && g.filter(\":nth-child(\" + c + \"n+4)\").addClass(\"ui-block-d\"), c > 4 && g.filter(\":nth-child(\" + c + \"n+5)\").addClass(\"ui-block-e\");\n      });\n    };\n  }(a), function (a, b) {\n    a.widget(\"mobile.navbar\", { options: { iconpos: \"top\", grid: null }, _create: function _create() {\n        var d = this.element,\n            e = d.find(\"a, button\"),\n            f = e.filter(\":jqmData(icon)\").length ? this.options.iconpos : b;d.addClass(\"ui-navbar\").attr(\"role\", \"navigation\").find(\"ul\").jqmEnhanceable().grid({ grid: this.options.grid }), e.each(function () {\n          var b = a.mobile.getAttribute(this, \"icon\"),\n              c = a.mobile.getAttribute(this, \"theme\"),\n              d = \"ui-btn\";c && (d += \" ui-btn-\" + c), b && (d += \" ui-icon-\" + b + \" ui-btn-icon-\" + f), a(this).addClass(d);\n        }), d.delegate(\"a\", \"vclick\", function () {\n          var b = a(this);b.hasClass(\"ui-state-disabled\") || b.hasClass(\"ui-disabled\") || b.hasClass(a.mobile.activeBtnClass) || (e.removeClass(a.mobile.activeBtnClass), b.addClass(a.mobile.activeBtnClass), a(c).one(\"pagehide\", function () {\n            b.removeClass(a.mobile.activeBtnClass);\n          }));\n        }), d.closest(\".ui-page\").bind(\"pagebeforeshow\", function () {\n          e.filter(\".ui-state-persist\").addClass(a.mobile.activeBtnClass);\n        });\n      } });\n  }(a), function (a) {\n    var b = a.mobile.getAttribute;a.widget(\"mobile.listview\", a.extend({ options: { theme: null, countTheme: null, dividerTheme: null, icon: \"carat-r\", splitIcon: \"carat-r\", splitTheme: null, corners: !0, shadow: !0, inset: !1 }, _create: function _create() {\n        var a = this,\n            b = \"\";b += a.options.inset ? \" ui-listview-inset\" : \"\", a.options.inset && (b += a.options.corners ? \" ui-corner-all\" : \"\", b += a.options.shadow ? \" ui-shadow\" : \"\"), a.element.addClass(\" ui-listview\" + b), a.refresh(!0);\n      }, _findFirstElementByTagName: function _findFirstElementByTagName(a, b, c, d) {\n        var e = {};for (e[c] = e[d] = !0; a;) {\n          if (e[a.nodeName]) return a;a = a[b];\n        }return null;\n      }, _addThumbClasses: function _addThumbClasses(b) {\n        var c,\n            d,\n            e = b.length;for (c = 0; e > c; c++) {\n          d = a(this._findFirstElementByTagName(b[c].firstChild, \"nextSibling\", \"img\", \"IMG\")), d.length && a(this._findFirstElementByTagName(d[0].parentNode, \"parentNode\", \"li\", \"LI\")).addClass(d.hasClass(\"ui-li-icon\") ? \"ui-li-has-icon\" : \"ui-li-has-thumb\");\n        }\n      }, _getChildrenByTagName: function _getChildrenByTagName(b, c, d) {\n        var e = [],\n            f = {};for (f[c] = f[d] = !0, b = b.firstChild; b;) {\n          f[b.nodeName] && e.push(b), b = b.nextSibling;\n        }return a(e);\n      }, _beforeListviewRefresh: a.noop, _afterListviewRefresh: a.noop, refresh: function refresh(c) {\n        var d,\n            e,\n            f,\n            g,\n            h,\n            i,\n            j,\n            k,\n            l,\n            m,\n            n,\n            o,\n            p,\n            q,\n            r,\n            s,\n            t,\n            u,\n            v,\n            w,\n            x = this.options,\n            y = this.element,\n            z = !!a.nodeName(y[0], \"ol\"),\n            A = y.attr(\"start\"),\n            B = {},\n            C = y.find(\".ui-li-count\"),\n            D = b(y[0], \"counttheme\") || this.options.countTheme,\n            E = D ? \"ui-body-\" + D : \"ui-body-inherit\";for (x.theme && y.addClass(\"ui-group-theme-\" + x.theme), z && (A || 0 === A) && (n = parseInt(A, 10) - 1, y.css(\"counter-reset\", \"listnumbering \" + n)), this._beforeListviewRefresh(), w = this._getChildrenByTagName(y[0], \"li\", \"LI\"), e = 0, f = w.length; f > e; e++) {\n          g = w.eq(e), h = \"\", (c || g[0].className.search(/\\bui-li-static\\b|\\bui-li-divider\\b/) < 0) && (l = this._getChildrenByTagName(g[0], \"a\", \"A\"), m = \"list-divider\" === b(g[0], \"role\"), p = g.attr(\"value\"), i = b(g[0], \"theme\"), l.length && l[0].className.search(/\\bui-btn\\b/) < 0 && !m ? (j = b(g[0], \"icon\"), k = j === !1 ? !1 : j || x.icon, l.removeClass(\"ui-link\"), d = \"ui-btn\", i && (d += \" ui-btn-\" + i), l.length > 1 ? (h = \"ui-li-has-alt\", q = l.last(), r = b(q[0], \"theme\") || x.splitTheme || b(g[0], \"theme\", !0), s = r ? \" ui-btn-\" + r : \"\", t = b(q[0], \"icon\") || b(g[0], \"icon\") || x.splitIcon, u = \"ui-btn ui-btn-icon-notext ui-icon-\" + t + s, q.attr(\"title\", a.trim(q.getEncodedText())).addClass(u).empty(), l = l.first()) : k && (d += \" ui-btn-icon-right ui-icon-\" + k), l.addClass(d)) : m ? (v = b(g[0], \"theme\") || x.dividerTheme || x.theme, h = \"ui-li-divider ui-bar-\" + (v ? v : \"inherit\"), g.attr(\"role\", \"heading\")) : l.length <= 0 && (h = \"ui-li-static ui-body-\" + (i ? i : \"inherit\")), z && p && (o = parseInt(p, 10) - 1, g.css(\"counter-reset\", \"listnumbering \" + o))), B[h] || (B[h] = []), B[h].push(g[0]);\n        }for (h in B) {\n          a(B[h]).addClass(h);\n        }C.each(function () {\n          a(this).closest(\"li\").addClass(\"ui-li-has-count\");\n        }), E && C.not(\"[class*='ui-body-']\").addClass(E), this._addThumbClasses(w), this._addThumbClasses(w.find(\".ui-btn\")), this._afterListviewRefresh(), this._addFirstLastClasses(w, this._getVisibles(w, c), c);\n      } }, a.mobile.behaviors.addFirstLastClasses));\n  }(a), function (a) {\n    function b(b) {\n      var c = a.trim(b.text()) || null;return c ? c = c.slice(0, 1).toUpperCase() : null;\n    }a.widget(\"mobile.listview\", a.mobile.listview, { options: { autodividers: !1, autodividersSelector: b }, _beforeListviewRefresh: function _beforeListviewRefresh() {\n        this.options.autodividers && (this._replaceDividers(), this._superApply(arguments));\n      }, _replaceDividers: function _replaceDividers() {\n        var b,\n            d,\n            e,\n            f,\n            g,\n            h = null,\n            i = this.element;for (i.children(\"li:jqmData(role='list-divider')\").remove(), d = i.children(\"li\"), b = 0; b < d.length; b++) {\n          e = d[b], f = this.options.autodividersSelector(a(e)), f && h !== f && (g = c.createElement(\"li\"), g.appendChild(c.createTextNode(f)), g.setAttribute(\"data-\" + a.mobile.ns + \"role\", \"list-divider\"), e.parentNode.insertBefore(g, e)), h = f;\n        }\n      } });\n  }(a), function (a) {\n    var b = /(^|\\s)ui-li-divider($|\\s)/,\n        c = /(^|\\s)ui-screen-hidden($|\\s)/;a.widget(\"mobile.listview\", a.mobile.listview, { options: { hideDividers: !1 }, _afterListviewRefresh: function _afterListviewRefresh() {\n        var a,\n            d,\n            e,\n            f = !0;if (this._superApply(arguments), this.options.hideDividers) for (a = this._getChildrenByTagName(this.element[0], \"li\", \"LI\"), d = a.length - 1; d > -1; d--) {\n          e = a[d], e.className.match(b) ? (f && (e.className = e.className + \" ui-screen-hidden\"), f = !0) : e.className.match(c) || (f = !1);\n        }\n      } });\n  }(a), function (a) {\n    a.mobile.nojs = function (b) {\n      a(\":jqmData(role='nojs')\", b).addClass(\"ui-nojs\");\n    };\n  }(a), function (a) {\n    a.mobile.behaviors.formReset = { _handleFormReset: function _handleFormReset() {\n        this._on(this.element.closest(\"form\"), { reset: function reset() {\n            this._delay(\"_reset\");\n          } });\n      } };\n  }(a), function (a, b) {\n    var c = a.mobile.path.hashToSelector;a.widget(\"mobile.checkboxradio\", a.extend({ initSelector: \"input:not( :jqmData(role='flipswitch' ) )[type='checkbox'],input[type='radio']:not( :jqmData(role='flipswitch' ))\", options: { theme: \"inherit\", mini: !1, wrapperClass: null, enhanced: !1, iconpos: \"left\" }, _create: function _create() {\n        var b = this.element,\n            c = this.options,\n            d = function d(a, b) {\n          return a.jqmData(b) || a.closest(\"form, fieldset\").jqmData(b);\n        },\n            e = this.options.enhanced ? { element: this.element.siblings(\"label\"), isParent: !1 } : this._findLabel(),\n            f = b[0].type,\n            g = \"ui-\" + f + \"-on\",\n            h = \"ui-\" + f + \"-off\";(\"checkbox\" === f || \"radio\" === f) && (this.element[0].disabled && (this.options.disabled = !0), c.iconpos = d(b, \"iconpos\") || e.element.attr(\"data-\" + a.mobile.ns + \"iconpos\") || c.iconpos, c.mini = d(b, \"mini\") || c.mini, a.extend(this, { input: b, label: e.element, labelIsParent: e.isParent, inputtype: f, checkedClass: g, uncheckedClass: h }), this.options.enhanced || this._enhance(), this._on(e.element, { vmouseover: \"_handleLabelVMouseOver\", vclick: \"_handleLabelVClick\" }), this._on(b, { vmousedown: \"_cacheVals\", vclick: \"_handleInputVClick\", focus: \"_handleInputFocus\", blur: \"_handleInputBlur\" }), this._handleFormReset(), this.refresh());\n      }, _findLabel: function _findLabel() {\n        var b,\n            d,\n            e,\n            f = this.element,\n            g = f[0].labels;return g && g.length > 0 ? (d = a(g[0]), e = a.contains(d[0], f[0])) : (b = f.closest(\"label\"), e = b.length > 0, d = e ? b : a(this.document[0].getElementsByTagName(\"label\")).filter(\"[for='\" + c(f[0].id) + \"']\").first()), { element: d, isParent: e };\n      }, _enhance: function _enhance() {\n        this.label.addClass(\"ui-btn ui-corner-all\"), this.labelIsParent ? this.input.add(this.label).wrapAll(this._wrapper()) : (this.element.wrap(this._wrapper()), this.element.parent().prepend(this.label)), this._setOptions({ theme: this.options.theme, iconpos: this.options.iconpos, mini: this.options.mini });\n      }, _wrapper: function _wrapper() {\n        return a(\"<div class='\" + (this.options.wrapperClass ? this.options.wrapperClass : \"\") + \" ui-\" + this.inputtype + (this.options.disabled ? \" ui-state-disabled\" : \"\") + \"' ></div>\");\n      }, _handleInputFocus: function _handleInputFocus() {\n        this.label.addClass(a.mobile.focusClass);\n      }, _handleInputBlur: function _handleInputBlur() {\n        this.label.removeClass(a.mobile.focusClass);\n      }, _handleInputVClick: function _handleInputVClick() {\n        this.element.prop(\"checked\", this.element.is(\":checked\")), this._getInputSet().not(this.element).prop(\"checked\", !1), this._updateAll(!0);\n      }, _handleLabelVMouseOver: function _handleLabelVMouseOver(a) {\n        this.label.parent().hasClass(\"ui-state-disabled\") && a.stopPropagation();\n      }, _handleLabelVClick: function _handleLabelVClick(a) {\n        var b = this.element;return b.is(\":disabled\") ? void a.preventDefault() : (this._cacheVals(), b.prop(\"checked\", \"radio\" === this.inputtype && !0 || !b.prop(\"checked\")), b.triggerHandler(\"click\"), this._getInputSet().not(b).prop(\"checked\", !1), this._updateAll(), !1);\n      }, _cacheVals: function _cacheVals() {\n        this._getInputSet().each(function () {\n          a(this).attr(\"data-\" + a.mobile.ns + \"cacheVal\", this.checked);\n        });\n      }, _getInputSet: function _getInputSet() {\n        var b,\n            d,\n            e = this.element[0],\n            f = e.name,\n            g = e.form,\n            h = this.element.parents().last().get(0),\n            i = this.element;return f && \"radio\" === this.inputtype && h && (b = \"input[type='radio'][name='\" + c(f) + \"']\", g ? (d = g.getAttribute(\"id\"), d && (i = a(b + \"[form='\" + c(d) + \"']\", h)), i = a(g).find(b).filter(function () {\n          return this.form === g;\n        }).add(i)) : i = a(b, h).filter(function () {\n          return !this.form;\n        })), i;\n      }, _updateAll: function _updateAll(b) {\n        var c = this;this._getInputSet().each(function () {\n          var d = a(this);!this.checked && \"checkbox\" !== c.inputtype || b || d.trigger(\"change\");\n        }).checkboxradio(\"refresh\");\n      }, _reset: function _reset() {\n        this.refresh();\n      }, _hasIcon: function _hasIcon() {\n        var b,\n            c,\n            d = a.mobile.controlgroup;return d && (b = this.element.closest(\":mobile-controlgroup,\" + d.prototype.initSelector), b.length > 0) ? (c = a.data(b[0], \"mobile-controlgroup\"), \"horizontal\" !== (c ? c.options.type : b.attr(\"data-\" + a.mobile.ns + \"type\"))) : !0;\n      }, refresh: function refresh() {\n        var b = this.element[0].checked,\n            c = a.mobile.activeBtnClass,\n            d = \"ui-btn-icon-\" + this.options.iconpos,\n            e = [],\n            f = [];this._hasIcon() ? (f.push(c), e.push(d)) : (f.push(d), (b ? e : f).push(c)), b ? (e.push(this.checkedClass), f.push(this.uncheckedClass)) : (e.push(this.uncheckedClass), f.push(this.checkedClass)), this.widget().toggleClass(\"ui-state-disabled\", this.element.prop(\"disabled\")), this.label.addClass(e.join(\" \")).removeClass(f.join(\" \"));\n      }, widget: function widget() {\n        return this.label.parent();\n      }, _setOptions: function _setOptions(a) {\n        var c = this.label,\n            d = this.options,\n            e = this.widget(),\n            f = this._hasIcon();a.disabled !== b && (this.input.prop(\"disabled\", !!a.disabled), e.toggleClass(\"ui-state-disabled\", !!a.disabled)), a.mini !== b && e.toggleClass(\"ui-mini\", !!a.mini), a.theme !== b && c.removeClass(\"ui-btn-\" + d.theme).addClass(\"ui-btn-\" + a.theme), a.wrapperClass !== b && e.removeClass(d.wrapperClass).addClass(a.wrapperClass), a.iconpos !== b && f ? c.removeClass(\"ui-btn-icon-\" + d.iconpos).addClass(\"ui-btn-icon-\" + a.iconpos) : f || c.removeClass(\"ui-btn-icon-\" + d.iconpos), this._super(a);\n      } }, a.mobile.behaviors.formReset));\n  }(a), function (a, b) {\n    a.widget(\"mobile.button\", { initSelector: \"input[type='button'], input[type='submit'], input[type='reset']\", options: { theme: null, icon: null, iconpos: \"left\", iconshadow: !1, corners: !0, shadow: !0, inline: null, mini: null, wrapperClass: null, enhanced: !1 }, _create: function _create() {\n        this.element.is(\":disabled\") && (this.options.disabled = !0), this.options.enhanced || this._enhance(), a.extend(this, { wrapper: this.element.parent() }), this._on({ focus: function focus() {\n            this.widget().addClass(a.mobile.focusClass);\n          }, blur: function blur() {\n            this.widget().removeClass(a.mobile.focusClass);\n          } }), this.refresh(!0);\n      }, _enhance: function _enhance() {\n        this.element.wrap(this._button());\n      }, _button: function _button() {\n        var b = this.options,\n            c = this._getIconClasses(this.options);return a(\"<div class='ui-btn ui-input-btn\" + (b.wrapperClass ? \" \" + b.wrapperClass : \"\") + (b.theme ? \" ui-btn-\" + b.theme : \"\") + (b.corners ? \" ui-corner-all\" : \"\") + (b.shadow ? \" ui-shadow\" : \"\") + (b.inline ? \" ui-btn-inline\" : \"\") + (b.mini ? \" ui-mini\" : \"\") + (b.disabled ? \" ui-state-disabled\" : \"\") + (c ? \" \" + c : \"\") + \"' >\" + this.element.val() + \"</div>\");\n      }, widget: function widget() {\n        return this.wrapper;\n      }, _destroy: function _destroy() {\n        this.element.insertBefore(this.wrapper), this.wrapper.remove();\n      }, _getIconClasses: function _getIconClasses(a) {\n        return a.icon ? \"ui-icon-\" + a.icon + (a.iconshadow ? \" ui-shadow-icon\" : \"\") + \" ui-btn-icon-\" + a.iconpos : \"\";\n      }, _setOptions: function _setOptions(c) {\n        var d = this.widget();c.theme !== b && d.removeClass(this.options.theme).addClass(\"ui-btn-\" + c.theme), c.corners !== b && d.toggleClass(\"ui-corner-all\", c.corners), c.shadow !== b && d.toggleClass(\"ui-shadow\", c.shadow), c.inline !== b && d.toggleClass(\"ui-btn-inline\", c.inline), c.mini !== b && d.toggleClass(\"ui-mini\", c.mini), c.disabled !== b && (this.element.prop(\"disabled\", c.disabled), d.toggleClass(\"ui-state-disabled\", c.disabled)), (c.icon !== b || c.iconshadow !== b || c.iconpos !== b) && d.removeClass(this._getIconClasses(this.options)).addClass(this._getIconClasses(a.extend({}, this.options, c))), this._super(c);\n      }, refresh: function refresh(b) {\n        var c,\n            d = this.element.prop(\"disabled\");this.options.icon && \"notext\" === this.options.iconpos && this.element.attr(\"title\") && this.element.attr(\"title\", this.element.val()), b || (c = this.element.detach(), a(this.wrapper).text(this.element.val()).append(c)), this.options.disabled !== d && this._setOptions({ disabled: d });\n      } });\n  }(a), function (a) {\n    var b = a(\"meta[name=viewport]\"),\n        c = b.attr(\"content\"),\n        d = c + \",maximum-scale=1, user-scalable=no\",\n        e = c + \",maximum-scale=10, user-scalable=yes\",\n        f = /(user-scalable[\\s]*=[\\s]*no)|(maximum-scale[\\s]*=[\\s]*1)[$,\\s]/.test(c);a.mobile.zoom = a.extend({}, { enabled: !f, locked: !1, disable: function disable(c) {\n        f || a.mobile.zoom.locked || (b.attr(\"content\", d), a.mobile.zoom.enabled = !1, a.mobile.zoom.locked = c || !1);\n      }, enable: function enable(c) {\n        f || a.mobile.zoom.locked && c !== !0 || (b.attr(\"content\", e), a.mobile.zoom.enabled = !0, a.mobile.zoom.locked = !1);\n      }, restore: function restore() {\n        f || (b.attr(\"content\", c), a.mobile.zoom.enabled = !0);\n      } });\n  }(a), function (a, b) {\n    a.widget(\"mobile.textinput\", { initSelector: \"input[type='text'],input[type='search'],:jqmData(type='search'),input[type='number'],:jqmData(type='number'),input[type='password'],input[type='email'],input[type='url'],input[type='tel'],textarea,input[type='time'],input[type='date'],input[type='month'],input[type='week'],input[type='datetime'],input[type='datetime-local'],input[type='color'],input:not([type]),input[type='file']\", options: { theme: null, corners: !0, mini: !1, preventFocusZoom: /iPhone|iPad|iPod/.test(navigator.platform) && navigator.userAgent.indexOf(\"AppleWebKit\") > -1, wrapperClass: \"\", enhanced: !1 }, _create: function _create() {\n        var b = this.options,\n            c = this.element.is(\"[type='search'], :jqmData(type='search')\"),\n            d = \"TEXTAREA\" === this.element[0].tagName,\n            e = this.element.is(\"[data-\" + (a.mobile.ns || \"\") + \"type='range']\"),\n            f = (this.element.is(\"input\") || this.element.is(\"[data-\" + (a.mobile.ns || \"\") + \"type='search']\")) && !e;this.element.prop(\"disabled\") && (b.disabled = !0), a.extend(this, { classes: this._classesFromOptions(), isSearch: c, isTextarea: d, isRange: e, inputNeedsWrap: f }), this._autoCorrect(), b.enhanced || this._enhance(), this._on({ focus: \"_handleFocus\", blur: \"_handleBlur\" });\n      }, refresh: function refresh() {\n        this.setOptions({ disabled: this.element.is(\":disabled\") });\n      }, _enhance: function _enhance() {\n        var a = [];this.isTextarea && a.push(\"ui-input-text\"), (this.isTextarea || this.isRange) && a.push(\"ui-shadow-inset\"), this.inputNeedsWrap ? this.element.wrap(this._wrap()) : a = a.concat(this.classes), this.element.addClass(a.join(\" \"));\n      }, widget: function widget() {\n        return this.inputNeedsWrap ? this.element.parent() : this.element;\n      }, _classesFromOptions: function _classesFromOptions() {\n        var a = this.options,\n            b = [];return b.push(\"ui-body-\" + (null === a.theme ? \"inherit\" : a.theme)), a.corners && b.push(\"ui-corner-all\"), a.mini && b.push(\"ui-mini\"), a.disabled && b.push(\"ui-state-disabled\"), a.wrapperClass && b.push(a.wrapperClass), b;\n      }, _wrap: function _wrap() {\n        return a(\"<div class='\" + (this.isSearch ? \"ui-input-search \" : \"ui-input-text \") + this.classes.join(\" \") + \" ui-shadow-inset'></div>\");\n      }, _autoCorrect: function _autoCorrect() {\n        \"undefined\" == typeof this.element[0].autocorrect || a.support.touchOverflow || (this.element[0].setAttribute(\"autocorrect\", \"off\"), this.element[0].setAttribute(\"autocomplete\", \"off\"));\n      }, _handleBlur: function _handleBlur() {\n        this.widget().removeClass(a.mobile.focusClass), this.options.preventFocusZoom && a.mobile.zoom.enable(!0);\n      }, _handleFocus: function _handleFocus() {\n        this.options.preventFocusZoom && a.mobile.zoom.disable(!0), this.widget().addClass(a.mobile.focusClass);\n      }, _setOptions: function _setOptions(a) {\n        var c = this.widget();this._super(a), (a.disabled !== b || a.mini !== b || a.corners !== b || a.theme !== b || a.wrapperClass !== b) && (c.removeClass(this.classes.join(\" \")), this.classes = this._classesFromOptions(), c.addClass(this.classes.join(\" \"))), a.disabled !== b && this.element.prop(\"disabled\", !!a.disabled);\n      }, _destroy: function _destroy() {\n        this.options.enhanced || (this.inputNeedsWrap && this.element.unwrap(), this.element.removeClass(\"ui-input-text \" + this.classes.join(\" \")));\n      } });\n  }(a), function (a, d) {\n    a.widget(\"mobile.slider\", a.extend({ initSelector: \"input[type='range'], :jqmData(type='range'), :jqmData(role='slider')\", widgetEventPrefix: \"slide\", options: { theme: null, trackTheme: null, corners: !0, mini: !1, highlight: !1 }, _create: function _create() {\n        var e,\n            f,\n            g,\n            h,\n            i,\n            j,\n            k,\n            l,\n            m,\n            n,\n            o = this,\n            p = this.element,\n            q = this.options.trackTheme || a.mobile.getAttribute(p[0], \"theme\"),\n            r = q ? \" ui-bar-\" + q : \" ui-bar-inherit\",\n            s = this.options.corners || p.jqmData(\"corners\") ? \" ui-corner-all\" : \"\",\n            t = this.options.mini || p.jqmData(\"mini\") ? \" ui-mini\" : \"\",\n            u = p[0].nodeName.toLowerCase(),\n            v = \"select\" === u,\n            w = p.parent().is(\":jqmData(role='rangeslider')\"),\n            x = v ? \"ui-slider-switch\" : \"\",\n            y = p.attr(\"id\"),\n            z = a(\"[for='\" + y + \"']\"),\n            A = z.attr(\"id\") || y + \"-label\",\n            B = v ? 0 : parseFloat(p.attr(\"min\")),\n            C = v ? p.find(\"option\").length - 1 : parseFloat(p.attr(\"max\")),\n            D = b.parseFloat(p.attr(\"step\") || 1),\n            E = c.createElement(\"a\"),\n            F = a(E),\n            G = c.createElement(\"div\"),\n            H = a(G),\n            I = this.options.highlight && !v ? function () {\n          var b = c.createElement(\"div\");return b.className = \"ui-slider-bg \" + a.mobile.activeBtnClass, a(b).prependTo(H);\n        }() : !1;if (z.attr(\"id\", A), this.isToggleSwitch = v, E.setAttribute(\"href\", \"#\"), G.setAttribute(\"role\", \"application\"), G.className = [this.isToggleSwitch ? \"ui-slider ui-slider-track ui-shadow-inset \" : \"ui-slider-track ui-shadow-inset \", x, r, s, t].join(\"\"), E.className = \"ui-slider-handle\", G.appendChild(E), F.attr({ role: \"slider\", \"aria-valuemin\": B, \"aria-valuemax\": C, \"aria-valuenow\": this._value(), \"aria-valuetext\": this._value(), title: this._value(), \"aria-labelledby\": A }), a.extend(this, { slider: H, handle: F, control: p, type: u, step: D, max: C, min: B, valuebg: I, isRangeslider: w, dragging: !1, beforeStart: null, userModified: !1, mouseMoved: !1 }), v) {\n          for (k = p.attr(\"tabindex\"), k && F.attr(\"tabindex\", k), p.attr(\"tabindex\", \"-1\").focus(function () {\n            a(this).blur(), F.focus();\n          }), f = c.createElement(\"div\"), f.className = \"ui-slider-inneroffset\", g = 0, h = G.childNodes.length; h > g; g++) {\n            f.appendChild(G.childNodes[g]);\n          }for (G.appendChild(f), F.addClass(\"ui-slider-handle-snapping\"), e = p.find(\"option\"), i = 0, j = e.length; j > i; i++) {\n            l = i ? \"a\" : \"b\", m = i ? \" \" + a.mobile.activeBtnClass : \"\", n = c.createElement(\"span\"), n.className = [\"ui-slider-label ui-slider-label-\", l, m].join(\"\"), n.setAttribute(\"role\", \"img\"), n.appendChild(c.createTextNode(e[i].innerHTML)), a(n).prependTo(H);\n          }o._labels = a(\".ui-slider-label\", H);\n        }p.addClass(v ? \"ui-slider-switch\" : \"ui-slider-input\"), this._on(p, { change: \"_controlChange\", keyup: \"_controlKeyup\", blur: \"_controlBlur\", vmouseup: \"_controlVMouseUp\" }), H.bind(\"vmousedown\", a.proxy(this._sliderVMouseDown, this)).bind(\"vclick\", !1), this._on(c, { vmousemove: \"_preventDocumentDrag\" }), this._on(H.add(c), { vmouseup: \"_sliderVMouseUp\" }), H.insertAfter(p), v || w || (f = this.options.mini ? \"<div class='ui-slider ui-mini'>\" : \"<div class='ui-slider'>\", p.add(H).wrapAll(f)), this._on(this.handle, { vmousedown: \"_handleVMouseDown\", keydown: \"_handleKeydown\", keyup: \"_handleKeyup\" }), this.handle.bind(\"vclick\", !1), this._handleFormReset(), this.refresh(d, d, !0);\n      }, _setOptions: function _setOptions(a) {\n        a.theme !== d && this._setTheme(a.theme), a.trackTheme !== d && this._setTrackTheme(a.trackTheme), a.corners !== d && this._setCorners(a.corners), a.mini !== d && this._setMini(a.mini), a.highlight !== d && this._setHighlight(a.highlight), a.disabled !== d && this._setDisabled(a.disabled), this._super(a);\n      }, _controlChange: function _controlChange(a) {\n        return this._trigger(\"controlchange\", a) === !1 ? !1 : void (this.mouseMoved || this.refresh(this._value(), !0));\n      }, _controlKeyup: function _controlKeyup() {\n        this.refresh(this._value(), !0, !0);\n      }, _controlBlur: function _controlBlur() {\n        this.refresh(this._value(), !0);\n      }, _controlVMouseUp: function _controlVMouseUp() {\n        this._checkedRefresh();\n      }, _handleVMouseDown: function _handleVMouseDown() {\n        this.handle.focus();\n      }, _handleKeydown: function _handleKeydown(b) {\n        var c = this._value();if (!this.options.disabled) {\n          switch (b.keyCode) {case a.mobile.keyCode.HOME:case a.mobile.keyCode.END:case a.mobile.keyCode.PAGE_UP:case a.mobile.keyCode.PAGE_DOWN:case a.mobile.keyCode.UP:case a.mobile.keyCode.RIGHT:case a.mobile.keyCode.DOWN:case a.mobile.keyCode.LEFT:\n              b.preventDefault(), this._keySliding || (this._keySliding = !0, this.handle.addClass(\"ui-state-active\"));}switch (b.keyCode) {case a.mobile.keyCode.HOME:\n              this.refresh(this.min);break;case a.mobile.keyCode.END:\n              this.refresh(this.max);break;case a.mobile.keyCode.PAGE_UP:case a.mobile.keyCode.UP:case a.mobile.keyCode.RIGHT:\n              this.refresh(c + this.step);break;case a.mobile.keyCode.PAGE_DOWN:case a.mobile.keyCode.DOWN:case a.mobile.keyCode.LEFT:\n              this.refresh(c - this.step);}\n        }\n      }, _handleKeyup: function _handleKeyup() {\n        this._keySliding && (this._keySliding = !1, this.handle.removeClass(\"ui-state-active\"));\n      }, _sliderVMouseDown: function _sliderVMouseDown(a) {\n        return this.options.disabled || 1 !== a.which && 0 !== a.which && a.which !== d ? !1 : this._trigger(\"beforestart\", a) === !1 ? !1 : (this.dragging = !0, this.userModified = !1, this.mouseMoved = !1, this.isToggleSwitch && (this.beforeStart = this.element[0].selectedIndex), this.refresh(a), this._trigger(\"start\"), !1);\n      }, _sliderVMouseUp: function _sliderVMouseUp() {\n        return this.dragging ? (this.dragging = !1, this.isToggleSwitch && (this.handle.addClass(\"ui-slider-handle-snapping\"), this.refresh(this.mouseMoved ? this.userModified ? 0 === this.beforeStart ? 1 : 0 : this.beforeStart : 0 === this.beforeStart ? 1 : 0)), this.mouseMoved = !1, this._trigger(\"stop\"), !1) : void 0;\n      }, _preventDocumentDrag: function _preventDocumentDrag(a) {\n        return this._trigger(\"drag\", a) === !1 ? !1 : this.dragging && !this.options.disabled ? (this.mouseMoved = !0, this.isToggleSwitch && this.handle.removeClass(\"ui-slider-handle-snapping\"), this.refresh(a), this.userModified = this.beforeStart !== this.element[0].selectedIndex, !1) : void 0;\n      }, _checkedRefresh: function _checkedRefresh() {\n        this.value !== this._value() && this.refresh(this._value());\n      }, _value: function _value() {\n        return this.isToggleSwitch ? this.element[0].selectedIndex : parseFloat(this.element.val());\n      }, _reset: function _reset() {\n        this.refresh(d, !1, !0);\n      }, refresh: function refresh(b, d, e) {\n        var f,\n            g,\n            h,\n            i,\n            j,\n            k,\n            l,\n            m,\n            n,\n            o,\n            p,\n            q,\n            r,\n            s,\n            t,\n            u,\n            v,\n            w,\n            x,\n            y,\n            z = this,\n            A = a.mobile.getAttribute(this.element[0], \"theme\"),\n            B = this.options.theme || A,\n            C = B ? \" ui-btn-\" + B : \"\",\n            D = this.options.trackTheme || A,\n            E = D ? \" ui-bar-\" + D : \" ui-bar-inherit\",\n            F = this.options.corners ? \" ui-corner-all\" : \"\",\n            G = this.options.mini ? \" ui-mini\" : \"\";if (z.slider[0].className = [this.isToggleSwitch ? \"ui-slider ui-slider-switch ui-slider-track ui-shadow-inset\" : \"ui-slider-track ui-shadow-inset\", E, F, G].join(\"\"), (this.options.disabled || this.element.prop(\"disabled\")) && this.disable(), this.value = this._value(), this.options.highlight && !this.isToggleSwitch && 0 === this.slider.find(\".ui-slider-bg\").length && (this.valuebg = function () {\n          var b = c.createElement(\"div\");return b.className = \"ui-slider-bg \" + a.mobile.activeBtnClass, a(b).prependTo(z.slider);\n        }()), this.handle.addClass(\"ui-btn\" + C + \" ui-shadow\"), l = this.element, m = !this.isToggleSwitch, n = m ? [] : l.find(\"option\"), o = m ? parseFloat(l.attr(\"min\")) : 0, p = m ? parseFloat(l.attr(\"max\")) : n.length - 1, q = m && parseFloat(l.attr(\"step\")) > 0 ? parseFloat(l.attr(\"step\")) : 1, \"object\" == (typeof b === \"undefined\" ? \"undefined\" : _typeof(b))) {\n          if (h = b, i = 8, f = this.slider.offset().left, g = this.slider.width(), j = g / ((p - o) / q), !this.dragging || h.pageX < f - i || h.pageX > f + g + i) return;k = j > 1 ? (h.pageX - f) / g * 100 : Math.round((h.pageX - f) / g * 100);\n        } else null == b && (b = m ? parseFloat(l.val() || 0) : l[0].selectedIndex), k = (parseFloat(b) - o) / (p - o) * 100;if (!isNaN(k) && (r = k / 100 * (p - o) + o, s = (r - o) % q, t = r - s, 2 * Math.abs(s) >= q && (t += s > 0 ? q : -q), u = 100 / ((p - o) / q), r = parseFloat(t.toFixed(5)), \"undefined\" == typeof j && (j = g / ((p - o) / q)), j > 1 && m && (k = (r - o) * u * (1 / q)), 0 > k && (k = 0), k > 100 && (k = 100), o > r && (r = o), r > p && (r = p), this.handle.css(\"left\", k + \"%\"), this.handle[0].setAttribute(\"aria-valuenow\", m ? r : n.eq(r).attr(\"value\")), this.handle[0].setAttribute(\"aria-valuetext\", m ? r : n.eq(r).getEncodedText()), this.handle[0].setAttribute(\"title\", m ? r : n.eq(r).getEncodedText()), this.valuebg && this.valuebg.css(\"width\", k + \"%\"), this._labels && (v = this.handle.width() / this.slider.width() * 100, w = k && v + (100 - v) * k / 100, x = 100 === k ? 0 : Math.min(v + 100 - w, 100), this._labels.each(function () {\n          var b = a(this).hasClass(\"ui-slider-label-a\");a(this).width((b ? w : x) + \"%\");\n        })), !e)) {\n          if (y = !1, m ? (y = parseFloat(l.val()) !== r, l.val(r)) : (y = l[0].selectedIndex !== r, l[0].selectedIndex = r), this._trigger(\"beforechange\", b) === !1) return !1;!d && y && l.trigger(\"change\");\n        }\n      }, _setHighlight: function _setHighlight(a) {\n        a = !!a, a ? (this.options.highlight = !!a, this.refresh()) : this.valuebg && (this.valuebg.remove(), this.valuebg = !1);\n      }, _setTheme: function _setTheme(a) {\n        this.handle.removeClass(\"ui-btn-\" + this.options.theme).addClass(\"ui-btn-\" + a);var b = this.options.theme ? this.options.theme : \"inherit\",\n            c = a ? a : \"inherit\";this.control.removeClass(\"ui-body-\" + b).addClass(\"ui-body-\" + c);\n      }, _setTrackTheme: function _setTrackTheme(a) {\n        var b = this.options.trackTheme ? this.options.trackTheme : \"inherit\",\n            c = a ? a : \"inherit\";this.slider.removeClass(\"ui-body-\" + b).addClass(\"ui-body-\" + c);\n      }, _setMini: function _setMini(a) {\n        a = !!a, this.isToggleSwitch || this.isRangeslider || (this.slider.parent().toggleClass(\"ui-mini\", a), this.element.toggleClass(\"ui-mini\", a)), this.slider.toggleClass(\"ui-mini\", a);\n      }, _setCorners: function _setCorners(a) {\n        this.slider.toggleClass(\"ui-corner-all\", a), this.isToggleSwitch || this.control.toggleClass(\"ui-corner-all\", a);\n      }, _setDisabled: function _setDisabled(a) {\n        a = !!a, this.element.prop(\"disabled\", a), this.slider.toggleClass(\"ui-state-disabled\", a).attr(\"aria-disabled\", a), this.element.toggleClass(\"ui-state-disabled\", a);\n      } }, a.mobile.behaviors.formReset));\n  }(a), function (a) {\n    function b() {\n      return c || (c = a(\"<div></div>\", { \"class\": \"ui-slider-popup ui-shadow ui-corner-all\" })), c.clone();\n    }var c;a.widget(\"mobile.slider\", a.mobile.slider, { options: { popupEnabled: !1, showValue: !1 }, _create: function _create() {\n        this._super(), a.extend(this, { _currentValue: null, _popup: null, _popupVisible: !1 }), this._setOption(\"popupEnabled\", this.options.popupEnabled), this._on(this.handle, { vmousedown: \"_showPopup\" }), this._on(this.slider.add(this.document), { vmouseup: \"_hidePopup\" }), this._refresh();\n      }, _positionPopup: function _positionPopup() {\n        var a = this.handle.offset();this._popup.offset({ left: a.left + (this.handle.width() - this._popup.width()) / 2, top: a.top - this._popup.outerHeight() - 5 });\n      }, _setOption: function _setOption(a, c) {\n        this._super(a, c), \"showValue\" === a ? this.handle.html(c && !this.options.mini ? this._value() : \"\") : \"popupEnabled\" === a && c && !this._popup && (this._popup = b().addClass(\"ui-body-\" + (this.options.theme || \"a\")).hide().insertBefore(this.element));\n      }, refresh: function refresh() {\n        this._super.apply(this, arguments), this._refresh();\n      }, _refresh: function _refresh() {\n        var a,\n            b = this.options;b.popupEnabled && this.handle.removeAttr(\"title\"), a = this._value(), a !== this._currentValue && (this._currentValue = a, b.popupEnabled && this._popup && (this._positionPopup(), this._popup.html(a)), b.showValue && !this.options.mini && this.handle.html(a));\n      }, _showPopup: function _showPopup() {\n        this.options.popupEnabled && !this._popupVisible && (this.handle.html(\"\"), this._popup.show(), this._positionPopup(), this._popupVisible = !0);\n      }, _hidePopup: function _hidePopup() {\n        var a = this.options;a.popupEnabled && this._popupVisible && (a.showValue && !a.mini && this.handle.html(this._value()), this._popup.hide(), this._popupVisible = !1);\n      } });\n  }(a), function (a, b) {\n    a.widget(\"mobile.flipswitch\", a.extend({ options: { onText: \"On\", offText: \"Off\", theme: null, enhanced: !1, wrapperClass: null, corners: !0, mini: !1 }, _create: function _create() {\n        this.options.enhanced ? a.extend(this, { flipswitch: this.element.parent(), on: this.element.find(\".ui-flipswitch-on\").eq(0), off: this.element.find(\".ui-flipswitch-off\").eq(0), type: this.element.get(0).tagName }) : this._enhance(), this._handleFormReset(), this._originalTabIndex = this.element.attr(\"tabindex\"), null != this._originalTabIndex && this.on.attr(\"tabindex\", this._originalTabIndex), this.element.attr(\"tabindex\", \"-1\"), this._on({ focus: \"_handleInputFocus\" }), this.element.is(\":disabled\") && this._setOptions({ disabled: !0 }), this._on(this.flipswitch, { click: \"_toggle\", swipeleft: \"_left\", swiperight: \"_right\" }), this._on(this.on, { keydown: \"_keydown\" }), this._on({ change: \"refresh\" });\n      }, _handleInputFocus: function _handleInputFocus() {\n        this.on.focus();\n      }, widget: function widget() {\n        return this.flipswitch;\n      }, _left: function _left() {\n        this.flipswitch.removeClass(\"ui-flipswitch-active\"), \"SELECT\" === this.type ? this.element.get(0).selectedIndex = 0 : this.element.prop(\"checked\", !1), this.element.trigger(\"change\");\n      }, _right: function _right() {\n        this.flipswitch.addClass(\"ui-flipswitch-active\"), \"SELECT\" === this.type ? this.element.get(0).selectedIndex = 1 : this.element.prop(\"checked\", !0), this.element.trigger(\"change\");\n      }, _enhance: function _enhance() {\n        var b = a(\"<div>\"),\n            c = this.options,\n            d = this.element,\n            e = c.theme ? c.theme : \"inherit\",\n            f = a(\"<a></a>\", { href: \"#\" }),\n            g = a(\"<span></span>\"),\n            h = d.get(0).tagName,\n            i = \"INPUT\" === h ? c.onText : d.find(\"option\").eq(1).text(),\n            j = \"INPUT\" === h ? c.offText : d.find(\"option\").eq(0).text();f.addClass(\"ui-flipswitch-on ui-btn ui-shadow ui-btn-inherit\").text(i), g.addClass(\"ui-flipswitch-off\").text(j), b.addClass(\"ui-flipswitch ui-shadow-inset ui-bar-\" + e + \" \" + (c.wrapperClass ? c.wrapperClass : \"\") + \" \" + (d.is(\":checked\") || d.find(\"option\").eq(1).is(\":selected\") ? \"ui-flipswitch-active\" : \"\") + (d.is(\":disabled\") ? \" ui-state-disabled\" : \"\") + (c.corners ? \" ui-corner-all\" : \"\") + (c.mini ? \" ui-mini\" : \"\")).append(f, g), d.addClass(\"ui-flipswitch-input\").after(b).appendTo(b), a.extend(this, { flipswitch: b, on: f, off: g, type: h });\n      }, _reset: function _reset() {\n        this.refresh();\n      }, refresh: function refresh() {\n        var a,\n            b = this.flipswitch.hasClass(\"ui-flipswitch-active\") ? \"_right\" : \"_left\";a = \"SELECT\" === this.type ? this.element.get(0).selectedIndex > 0 ? \"_right\" : \"_left\" : this.element.prop(\"checked\") ? \"_right\" : \"_left\", a !== b && this[a]();\n      }, _toggle: function _toggle() {\n        var a = this.flipswitch.hasClass(\"ui-flipswitch-active\") ? \"_left\" : \"_right\";this[a]();\n      }, _keydown: function _keydown(b) {\n        b.which === a.mobile.keyCode.LEFT ? this._left() : b.which === a.mobile.keyCode.RIGHT ? this._right() : b.which === a.mobile.keyCode.SPACE && (this._toggle(), b.preventDefault());\n      }, _setOptions: function _setOptions(a) {\n        if (a.theme !== b) {\n          var c = a.theme ? a.theme : \"inherit\",\n              d = a.theme ? a.theme : \"inherit\";this.widget().removeClass(\"ui-bar-\" + c).addClass(\"ui-bar-\" + d);\n        }a.onText !== b && this.on.text(a.onText), a.offText !== b && this.off.text(a.offText), a.disabled !== b && this.widget().toggleClass(\"ui-state-disabled\", a.disabled), a.mini !== b && this.widget().toggleClass(\"ui-mini\", a.mini), a.corners !== b && this.widget().toggleClass(\"ui-corner-all\", a.corners), this._super(a);\n      }, _destroy: function _destroy() {\n        this.options.enhanced || (null != this._originalTabIndex ? this.element.attr(\"tabindex\", this._originalTabIndex) : this.element.removeAttr(\"tabindex\"), this.on.remove(), this.off.remove(), this.element.unwrap(), this.flipswitch.remove(), this.removeClass(\"ui-flipswitch-input\"));\n      } }, a.mobile.behaviors.formReset));\n  }(a), function (a, b) {\n    a.widget(\"mobile.rangeslider\", a.extend({ options: { theme: null, trackTheme: null, corners: !0, mini: !1, highlight: !0 }, _create: function _create() {\n        var b = this.element,\n            c = this.options.mini ? \"ui-rangeslider ui-mini\" : \"ui-rangeslider\",\n            d = b.find(\"input\").first(),\n            e = b.find(\"input\").last(),\n            f = b.find(\"label\").first(),\n            g = a.data(d.get(0), \"mobile-slider\") || a.data(d.slider().get(0), \"mobile-slider\"),\n            h = a.data(e.get(0), \"mobile-slider\") || a.data(e.slider().get(0), \"mobile-slider\"),\n            i = g.slider,\n            j = h.slider,\n            k = g.handle,\n            l = a(\"<div class='ui-rangeslider-sliders' />\").appendTo(b);d.addClass(\"ui-rangeslider-first\"), e.addClass(\"ui-rangeslider-last\"), b.addClass(c), i.appendTo(l), j.appendTo(l), f.insertBefore(b), k.prependTo(j), a.extend(this, { _inputFirst: d, _inputLast: e, _sliderFirst: i, _sliderLast: j, _label: f, _targetVal: null, _sliderTarget: !1, _sliders: l, _proxy: !1 }), this.refresh(), this._on(this.element.find(\"input.ui-slider-input\"), { slidebeforestart: \"_slidebeforestart\", slidestop: \"_slidestop\", slidedrag: \"_slidedrag\", slidebeforechange: \"_change\", blur: \"_change\", keyup: \"_change\" }), this._on({ mousedown: \"_change\" }), this._on(this.element.closest(\"form\"), { reset: \"_handleReset\" }), this._on(k, { vmousedown: \"_dragFirstHandle\" });\n      }, _handleReset: function _handleReset() {\n        var a = this;setTimeout(function () {\n          a._updateHighlight();\n        }, 0);\n      }, _dragFirstHandle: function _dragFirstHandle(b) {\n        return a.data(this._inputFirst.get(0), \"mobile-slider\").dragging = !0, a.data(this._inputFirst.get(0), \"mobile-slider\").refresh(b), a.data(this._inputFirst.get(0), \"mobile-slider\")._trigger(\"start\"), !1;\n      }, _slidedrag: function _slidedrag(b) {\n        var c = a(b.target).is(this._inputFirst),\n            d = c ? this._inputLast : this._inputFirst;return this._sliderTarget = !1, \"first\" === this._proxy && c || \"last\" === this._proxy && !c ? (a.data(d.get(0), \"mobile-slider\").dragging = !0, a.data(d.get(0), \"mobile-slider\").refresh(b), !1) : void 0;\n      }, _slidestop: function _slidestop(b) {\n        var c = a(b.target).is(this._inputFirst);this._proxy = !1, this.element.find(\"input\").trigger(\"vmouseup\"), this._sliderFirst.css(\"z-index\", c ? 1 : \"\");\n      }, _slidebeforestart: function _slidebeforestart(b) {\n        this._sliderTarget = !1, a(b.originalEvent.target).hasClass(\"ui-slider-track\") && (this._sliderTarget = !0, this._targetVal = a(b.target).val());\n      }, _setOptions: function _setOptions(a) {\n        a.theme !== b && this._setTheme(a.theme), a.trackTheme !== b && this._setTrackTheme(a.trackTheme), a.mini !== b && this._setMini(a.mini), a.highlight !== b && this._setHighlight(a.highlight), a.disabled !== b && this._setDisabled(a.disabled), this._super(a), this.refresh();\n      }, refresh: function refresh() {\n        var a = this.element,\n            b = this.options;(this._inputFirst.is(\":disabled\") || this._inputLast.is(\":disabled\")) && (this.options.disabled = !0), a.find(\"input\").slider({ theme: b.theme, trackTheme: b.trackTheme, disabled: b.disabled, corners: b.corners, mini: b.mini, highlight: b.highlight }).slider(\"refresh\"), this._updateHighlight();\n      }, _change: function _change(b) {\n        if (\"keyup\" === b.type) return this._updateHighlight(), !1;var c = this,\n            d = parseFloat(this._inputFirst.val(), 10),\n            e = parseFloat(this._inputLast.val(), 10),\n            f = a(b.target).hasClass(\"ui-rangeslider-first\"),\n            g = f ? this._inputFirst : this._inputLast,\n            h = f ? this._inputLast : this._inputFirst;if (this._inputFirst.val() > this._inputLast.val() && \"mousedown\" === b.type && !a(b.target).hasClass(\"ui-slider-handle\")) g.blur();else if (\"mousedown\" === b.type) return;return d > e && !this._sliderTarget ? (g.val(f ? e : d).slider(\"refresh\"), this._trigger(\"normalize\")) : d > e && (g.val(this._targetVal).slider(\"refresh\"), setTimeout(function () {\n          h.val(f ? d : e).slider(\"refresh\"), a.data(h.get(0), \"mobile-slider\").handle.focus(), c._sliderFirst.css(\"z-index\", f ? \"\" : 1), c._trigger(\"normalize\");\n        }, 0), this._proxy = f ? \"first\" : \"last\"), d === e ? (a.data(g.get(0), \"mobile-slider\").handle.css(\"z-index\", 1), a.data(h.get(0), \"mobile-slider\").handle.css(\"z-index\", 0)) : (a.data(h.get(0), \"mobile-slider\").handle.css(\"z-index\", \"\"), a.data(g.get(0), \"mobile-slider\").handle.css(\"z-index\", \"\")), this._updateHighlight(), d >= e ? !1 : void 0;\n      }, _updateHighlight: function _updateHighlight() {\n        var b = parseInt(a.data(this._inputFirst.get(0), \"mobile-slider\").handle.get(0).style.left, 10),\n            c = parseInt(a.data(this._inputLast.get(0), \"mobile-slider\").handle.get(0).style.left, 10),\n            d = c - b;this.element.find(\".ui-slider-bg\").css({ \"margin-left\": b + \"%\", width: d + \"%\" });\n      }, _setTheme: function _setTheme(a) {\n        this._inputFirst.slider(\"option\", \"theme\", a), this._inputLast.slider(\"option\", \"theme\", a);\n      }, _setTrackTheme: function _setTrackTheme(a) {\n        this._inputFirst.slider(\"option\", \"trackTheme\", a), this._inputLast.slider(\"option\", \"trackTheme\", a);\n      }, _setMini: function _setMini(a) {\n        this._inputFirst.slider(\"option\", \"mini\", a), this._inputLast.slider(\"option\", \"mini\", a), this.element.toggleClass(\"ui-mini\", !!a);\n      }, _setHighlight: function _setHighlight(a) {\n        this._inputFirst.slider(\"option\", \"highlight\", a), this._inputLast.slider(\"option\", \"highlight\", a);\n      }, _setDisabled: function _setDisabled(a) {\n        this._inputFirst.prop(\"disabled\", a), this._inputLast.prop(\"disabled\", a);\n      }, _destroy: function _destroy() {\n        this._label.prependTo(this.element), this.element.removeClass(\"ui-rangeslider ui-mini\"), this._inputFirst.after(this._sliderFirst), this._inputLast.after(this._sliderLast), this._sliders.remove(), this.element.find(\"input\").removeClass(\"ui-rangeslider-first ui-rangeslider-last\").slider(\"destroy\");\n      } }, a.mobile.behaviors.formReset));\n  }(a), function (a, b) {\n    a.widget(\"mobile.textinput\", a.mobile.textinput, { options: { clearBtn: !1, clearBtnText: \"Clear text\" }, _create: function _create() {\n        this._super(), this.isSearch && (this.options.clearBtn = !0), this.options.clearBtn && this.inputNeedsWrap && this._addClearBtn();\n      }, clearButton: function clearButton() {\n        return a(\"<a href='#' tabindex='-1' aria-hidden='true' class='ui-input-clear ui-btn ui-icon-delete ui-btn-icon-notext ui-corner-all'></a>\").attr(\"title\", this.options.clearBtnText).text(this.options.clearBtnText);\n      }, _clearBtnClick: function _clearBtnClick(a) {\n        this.element.val(\"\").focus().trigger(\"change\"), this._clearBtn.addClass(\"ui-input-clear-hidden\"), a.preventDefault();\n      }, _addClearBtn: function _addClearBtn() {\n        this.options.enhanced || this._enhanceClear(), a.extend(this, { _clearBtn: this.widget().find(\"a.ui-input-clear\") }), this._bindClearEvents(), this._toggleClear();\n      }, _enhanceClear: function _enhanceClear() {\n        this.clearButton().appendTo(this.widget()), this.widget().addClass(\"ui-input-has-clear\");\n      }, _bindClearEvents: function _bindClearEvents() {\n        this._on(this._clearBtn, { click: \"_clearBtnClick\" }), this._on({ keyup: \"_toggleClear\", change: \"_toggleClear\", input: \"_toggleClear\", focus: \"_toggleClear\", blur: \"_toggleClear\", cut: \"_toggleClear\", paste: \"_toggleClear\" });\n      }, _unbindClear: function _unbindClear() {\n        this._off(this._clearBtn, \"click\"), this._off(this.element, \"keyup change input focus blur cut paste\");\n      }, _setOptions: function _setOptions(a) {\n        this._super(a), a.clearBtn === b || this.element.is(\"textarea, :jqmData(type='range')\") || (a.clearBtn ? this._addClearBtn() : this._destroyClear()), a.clearBtnText !== b && this._clearBtn !== b && this._clearBtn.text(a.clearBtnText).attr(\"title\", a.clearBtnText);\n      }, _toggleClear: function _toggleClear() {\n        this._delay(\"_toggleClearClass\", 0);\n      }, _toggleClearClass: function _toggleClearClass() {\n        this._clearBtn.toggleClass(\"ui-input-clear-hidden\", !this.element.val());\n      }, _destroyClear: function _destroyClear() {\n        this.widget().removeClass(\"ui-input-has-clear\"), this._unbindClear(), this._clearBtn.remove();\n      }, _destroy: function _destroy() {\n        this._super(), this.options.clearBtn && this._destroyClear();\n      } });\n  }(a), function (a, b) {\n    a.widget(\"mobile.textinput\", a.mobile.textinput, { options: { autogrow: !0, keyupTimeoutBuffer: 100 }, _create: function _create() {\n        this._super(), this.options.autogrow && this.isTextarea && this._autogrow();\n      }, _autogrow: function _autogrow() {\n        this.element.addClass(\"ui-textinput-autogrow\"), this._on({ keyup: \"_timeout\", change: \"_timeout\", input: \"_timeout\", paste: \"_timeout\" }), this._on(!0, this.document, { pageshow: \"_handleShow\", popupbeforeposition: \"_handleShow\", updatelayout: \"_handleShow\", panelopen: \"_handleShow\" });\n      }, _handleShow: function _handleShow(b) {\n        a.contains(b.target, this.element[0]) && this.element.is(\":visible\") && (\"popupbeforeposition\" !== b.type && this.element.addClass(\"ui-textinput-autogrow-resize\").animationComplete(a.proxy(function () {\n          this.element.removeClass(\"ui-textinput-autogrow-resize\");\n        }, this), \"transition\"), this._prepareHeightUpdate());\n      }, _unbindAutogrow: function _unbindAutogrow() {\n        this.element.removeClass(\"ui-textinput-autogrow\"), this._off(this.element, \"keyup change input paste\"), this._off(this.document, \"pageshow popupbeforeposition updatelayout panelopen\");\n      }, keyupTimeout: null, _prepareHeightUpdate: function _prepareHeightUpdate(a) {\n        this.keyupTimeout && clearTimeout(this.keyupTimeout), a === b ? this._updateHeight() : this.keyupTimeout = this._delay(\"_updateHeight\", a);\n      }, _timeout: function _timeout() {\n        this._prepareHeightUpdate(this.options.keyupTimeoutBuffer);\n      }, _updateHeight: function _updateHeight() {\n        var a,\n            b,\n            c,\n            d,\n            e,\n            f,\n            g,\n            h,\n            i,\n            j = this.window.scrollTop();this.keyupTimeout = 0, \"onpage\" in this.element[0] || this.element.css({ height: 0, \"min-height\": 0, \"max-height\": 0 }), d = this.element[0].scrollHeight, e = this.element[0].clientHeight, f = parseFloat(this.element.css(\"border-top-width\")), g = parseFloat(this.element.css(\"border-bottom-width\")), h = f + g, i = d + h + 15, 0 === e && (a = parseFloat(this.element.css(\"padding-top\")), b = parseFloat(this.element.css(\"padding-bottom\")), c = a + b, i += c), this.element.css({ height: i, \"min-height\": \"\", \"max-height\": \"\" }), this.window.scrollTop(j);\n      }, refresh: function refresh() {\n        this.options.autogrow && this.isTextarea && this._updateHeight();\n      }, _setOptions: function _setOptions(a) {\n        this._super(a), a.autogrow !== b && this.isTextarea && (a.autogrow ? this._autogrow() : this._unbindAutogrow());\n      } });\n  }(a), function (a) {\n    a.widget(\"mobile.selectmenu\", a.extend({ initSelector: \"select:not( :jqmData(role='slider')):not( :jqmData(role='flipswitch') )\", options: { theme: null, icon: \"carat-d\", iconpos: \"right\", inline: !1, corners: !0, shadow: !0, iconshadow: !1, overlayTheme: null, dividerTheme: null, hidePlaceholderMenuItems: !0, closeText: \"Close\", nativeMenu: !0, preventFocusZoom: /iPhone|iPad|iPod/.test(navigator.platform) && navigator.userAgent.indexOf(\"AppleWebKit\") > -1, mini: !1 }, _button: function _button() {\n        return a(\"<div/>\");\n      }, _setDisabled: function _setDisabled(a) {\n        return this.element.attr(\"disabled\", a), this.button.attr(\"aria-disabled\", a), this._setOption(\"disabled\", a);\n      }, _focusButton: function _focusButton() {\n        var a = this;setTimeout(function () {\n          a.button.focus();\n        }, 40);\n      }, _selectOptions: function _selectOptions() {\n        return this.select.find(\"option\");\n      }, _preExtension: function _preExtension() {\n        var b = this.options.inline || this.element.jqmData(\"inline\"),\n            c = this.options.mini || this.element.jqmData(\"mini\"),\n            d = \"\";~this.element[0].className.indexOf(\"ui-btn-left\") && (d = \" ui-btn-left\"), ~this.element[0].className.indexOf(\"ui-btn-right\") && (d = \" ui-btn-right\"), b && (d += \" ui-btn-inline\"), c && (d += \" ui-mini\"), this.select = this.element.removeClass(\"ui-btn-left ui-btn-right\").wrap(\"<div class='ui-select\" + d + \"'>\"), this.selectId = this.select.attr(\"id\") || \"select-\" + this.uuid, this.buttonId = this.selectId + \"-button\", this.label = a(\"label[for='\" + this.selectId + \"']\"), this.isMultiple = this.select[0].multiple;\n      }, _destroy: function _destroy() {\n        var a = this.element.parents(\".ui-select\");a.length > 0 && (a.is(\".ui-btn-left, .ui-btn-right\") && this.element.addClass(a.hasClass(\"ui-btn-left\") ? \"ui-btn-left\" : \"ui-btn-right\"), this.element.insertAfter(a), a.remove());\n      }, _create: function _create() {\n        this._preExtension(), this.button = this._button();var c = this,\n            d = this.options,\n            e = d.icon ? d.iconpos || this.select.jqmData(\"iconpos\") : !1,\n            f = this.button.insertBefore(this.select).attr(\"id\", this.buttonId).addClass(\"ui-btn\" + (d.icon ? \" ui-icon-\" + d.icon + \" ui-btn-icon-\" + e + (d.iconshadow ? \" ui-shadow-icon\" : \"\") : \"\") + (d.theme ? \" ui-btn-\" + d.theme : \"\") + (d.corners ? \" ui-corner-all\" : \"\") + (d.shadow ? \" ui-shadow\" : \"\"));this.setButtonText(), d.nativeMenu && b.opera && b.opera.version && f.addClass(\"ui-select-nativeonly\"), this.isMultiple && (this.buttonCount = a(\"<span>\").addClass(\"ui-li-count ui-body-inherit\").hide().appendTo(f.addClass(\"ui-li-has-count\"))), (d.disabled || this.element.attr(\"disabled\")) && this.disable(), this.select.change(function () {\n          c.refresh(), d.nativeMenu && c._delay(function () {\n            c.select.blur();\n          });\n        }), this._handleFormReset(), this._on(this.button, { keydown: \"_handleKeydown\" }), this.build();\n      }, build: function build() {\n        var b = this;this.select.appendTo(b.button).bind(\"vmousedown\", function () {\n          b.button.addClass(a.mobile.activeBtnClass);\n        }).bind(\"focus\", function () {\n          b.button.addClass(a.mobile.focusClass);\n        }).bind(\"blur\", function () {\n          b.button.removeClass(a.mobile.focusClass);\n        }).bind(\"focus vmouseover\", function () {\n          b.button.trigger(\"vmouseover\");\n        }).bind(\"vmousemove\", function () {\n          b.button.removeClass(a.mobile.activeBtnClass);\n        }).bind(\"change blur vmouseout\", function () {\n          b.button.trigger(\"vmouseout\").removeClass(a.mobile.activeBtnClass);\n        }), b.button.bind(\"vmousedown\", function () {\n          b.options.preventFocusZoom && a.mobile.zoom.disable(!0);\n        }), b.label.bind(\"click focus\", function () {\n          b.options.preventFocusZoom && a.mobile.zoom.disable(!0);\n        }), b.select.bind(\"focus\", function () {\n          b.options.preventFocusZoom && a.mobile.zoom.disable(!0);\n        }), b.button.bind(\"mouseup\", function () {\n          b.options.preventFocusZoom && setTimeout(function () {\n            a.mobile.zoom.enable(!0);\n          }, 0);\n        }), b.select.bind(\"blur\", function () {\n          b.options.preventFocusZoom && a.mobile.zoom.enable(!0);\n        });\n      }, selected: function selected() {\n        return this._selectOptions().filter(\":selected\");\n      }, selectedIndices: function selectedIndices() {\n        var a = this;return this.selected().map(function () {\n          return a._selectOptions().index(this);\n        }).get();\n      }, setButtonText: function setButtonText() {\n        var b = this,\n            d = this.selected(),\n            e = this.placeholder,\n            f = a(c.createElement(\"span\"));this.button.children(\"span\").not(\".ui-li-count\").remove().end().end().prepend(function () {\n          return e = d.length ? d.map(function () {\n            return a(this).text();\n          }).get().join(\", \") : b.placeholder, e ? f.text(e) : f.html(\"&#160;\"), f.addClass(b.select.attr(\"class\")).addClass(d.attr(\"class\")).removeClass(\"ui-screen-hidden\");\n        }());\n      }, setButtonCount: function setButtonCount() {\n        var a = this.selected();this.isMultiple && this.buttonCount[a.length > 1 ? \"show\" : \"hide\"]().text(a.length);\n      }, _handleKeydown: function _handleKeydown() {\n        this._delay(\"_refreshButton\");\n      }, _reset: function _reset() {\n        this.refresh();\n      }, _refreshButton: function _refreshButton() {\n        this.setButtonText(), this.setButtonCount();\n      }, refresh: function refresh() {\n        this._refreshButton();\n      }, open: a.noop, close: a.noop, disable: function disable() {\n        this._setDisabled(!0), this.button.addClass(\"ui-state-disabled\");\n      }, enable: function enable() {\n        this._setDisabled(!1), this.button.removeClass(\"ui-state-disabled\");\n      } }, a.mobile.behaviors.formReset));\n  }(a), function (a) {\n    a.mobile.links = function (b) {\n      a(b).find(\"a\").jqmEnhanceable().filter(\":jqmData(rel='popup')[href][href!='']\").each(function () {\n        var a = this,\n            b = a.getAttribute(\"href\").substring(1);b && (a.setAttribute(\"aria-haspopup\", !0), a.setAttribute(\"aria-owns\", b), a.setAttribute(\"aria-expanded\", !1));\n      }).end().not(\".ui-btn, :jqmData(role='none'), :jqmData(role='nojs')\").addClass(\"ui-link\");\n    };\n  }(a), function (a, c) {\n    function d(a, b, c, d) {\n      var e = d;return e = b > a ? c + (a - b) / 2 : Math.min(Math.max(c, d - b / 2), c + a - b);\n    }function e(a) {\n      return { x: a.scrollLeft(), y: a.scrollTop(), cx: a[0].innerWidth || a.width(), cy: a[0].innerHeight || a.height() };\n    }a.widget(\"mobile.popup\", { options: { wrapperClass: null, theme: null, overlayTheme: null, shadow: !0, corners: !0, transition: \"none\", positionTo: \"origin\", tolerance: null, closeLinkSelector: \"a:jqmData(rel='back')\", closeLinkEvents: \"click.popup\", navigateEvents: \"navigate.popup\", closeEvents: \"navigate.popup pagebeforechange.popup\", dismissible: !0, enhanced: !1, history: !a.mobile.browser.oldIE }, _handleDocumentVmousedown: function _handleDocumentVmousedown(b) {\n        this._isOpen && a.contains(this._ui.container[0], b.target) && this._ignoreResizeEvents();\n      }, _create: function _create() {\n        var b = this.element,\n            c = b.attr(\"id\"),\n            d = this.options;d.history = d.history && a.mobile.ajaxEnabled && a.mobile.hashListeningEnabled, this._on(this.document, { vmousedown: \"_handleDocumentVmousedown\" }), a.extend(this, { _scrollTop: 0, _page: b.closest(\".ui-page\"), _ui: null, _fallbackTransition: \"\", _currentTransition: !1, _prerequisites: null, _isOpen: !1, _tolerance: null, _resizeData: null, _ignoreResizeTo: 0, _orientationchangeInProgress: !1 }), 0 === this._page.length && (this._page = a(\"body\")), d.enhanced ? this._ui = { container: b.parent(), screen: b.parent().prev(), placeholder: a(this.document[0].getElementById(c + \"-placeholder\")) } : (this._ui = this._enhance(b, c), this._applyTransition(d.transition)), this._setTolerance(d.tolerance)._ui.focusElement = this._ui.container, this._on(this._ui.screen, { vclick: \"_eatEventAndClose\" }), this._on(this.window, { orientationchange: a.proxy(this, \"_handleWindowOrientationchange\"), resize: a.proxy(this, \"_handleWindowResize\"), keyup: a.proxy(this, \"_handleWindowKeyUp\") }), this._on(this.document, { focusin: \"_handleDocumentFocusIn\" });\n      }, _enhance: function _enhance(b, c) {\n        var d = this.options,\n            e = d.wrapperClass,\n            f = { screen: a(\"<div class='ui-screen-hidden ui-popup-screen \" + this._themeClassFromOption(\"ui-overlay-\", d.overlayTheme) + \"'></div>\"), placeholder: a(\"<div style='display: none;'><!-- placeholder --></div>\"), container: a(\"<div class='ui-popup-container ui-popup-hidden ui-popup-truncate\" + (e ? \" \" + e : \"\") + \"'></div>\") },\n            g = this.document[0].createDocumentFragment();return g.appendChild(f.screen[0]), g.appendChild(f.container[0]), c && (f.screen.attr(\"id\", c + \"-screen\"), f.container.attr(\"id\", c + \"-popup\"), f.placeholder.attr(\"id\", c + \"-placeholder\").html(\"<!-- placeholder for \" + c + \" -->\")), this._page[0].appendChild(g), f.placeholder.insertAfter(b), b.detach().addClass(\"ui-popup \" + this._themeClassFromOption(\"ui-body-\", d.theme) + \" \" + (d.shadow ? \"ui-overlay-shadow \" : \"\") + (d.corners ? \"ui-corner-all \" : \"\")).appendTo(f.container), f;\n      }, _eatEventAndClose: function _eatEventAndClose(a) {\n        return a.preventDefault(), a.stopImmediatePropagation(), this.options.dismissible && this.close(), !1;\n      }, _resizeScreen: function _resizeScreen() {\n        var a = this._ui.screen,\n            b = this._ui.container.outerHeight(!0),\n            c = a.removeAttr(\"style\").height(),\n            d = this.document.height() - 1;d > c ? a.height(d) : b > c && a.height(b);\n      }, _handleWindowKeyUp: function _handleWindowKeyUp(b) {\n        return this._isOpen && b.keyCode === a.mobile.keyCode.ESCAPE ? this._eatEventAndClose(b) : void 0;\n      }, _expectResizeEvent: function _expectResizeEvent() {\n        var a = e(this.window);\n        if (this._resizeData) {\n          if (a.x === this._resizeData.windowCoordinates.x && a.y === this._resizeData.windowCoordinates.y && a.cx === this._resizeData.windowCoordinates.cx && a.cy === this._resizeData.windowCoordinates.cy) return !1;clearTimeout(this._resizeData.timeoutId);\n        }return this._resizeData = { timeoutId: this._delay(\"_resizeTimeout\", 200), windowCoordinates: a }, !0;\n      }, _resizeTimeout: function _resizeTimeout() {\n        this._isOpen ? this._expectResizeEvent() || (this._ui.container.hasClass(\"ui-popup-hidden\") && (this._ui.container.removeClass(\"ui-popup-hidden ui-popup-truncate\"), this.reposition({ positionTo: \"window\" }), this._ignoreResizeEvents()), this._resizeScreen(), this._resizeData = null, this._orientationchangeInProgress = !1) : (this._resizeData = null, this._orientationchangeInProgress = !1);\n      }, _stopIgnoringResizeEvents: function _stopIgnoringResizeEvents() {\n        this._ignoreResizeTo = 0;\n      }, _ignoreResizeEvents: function _ignoreResizeEvents() {\n        this._ignoreResizeTo && clearTimeout(this._ignoreResizeTo), this._ignoreResizeTo = this._delay(\"_stopIgnoringResizeEvents\", 1e3);\n      }, _handleWindowResize: function _handleWindowResize() {\n        this._isOpen && 0 === this._ignoreResizeTo && (!this._expectResizeEvent() && !this._orientationchangeInProgress || this._ui.container.hasClass(\"ui-popup-hidden\") || this._ui.container.addClass(\"ui-popup-hidden ui-popup-truncate\").removeAttr(\"style\"));\n      }, _handleWindowOrientationchange: function _handleWindowOrientationchange() {\n        !this._orientationchangeInProgress && this._isOpen && 0 === this._ignoreResizeTo && (this._expectResizeEvent(), this._orientationchangeInProgress = !0);\n      }, _handleDocumentFocusIn: function _handleDocumentFocusIn(b) {\n        var c,\n            d = b.target,\n            e = this._ui;if (this._isOpen) {\n          if (d !== e.container[0]) {\n            if (c = a(d), !a.contains(e.container[0], d)) return a(this.document[0].activeElement).one(\"focus\", a.proxy(function () {\n              this._safelyBlur(d);\n            }, this)), e.focusElement.focus(), b.preventDefault(), b.stopImmediatePropagation(), !1;e.focusElement[0] === e.container[0] && (e.focusElement = c);\n          }this._ignoreResizeEvents();\n        }\n      }, _themeClassFromOption: function _themeClassFromOption(a, b) {\n        return b ? \"none\" === b ? \"\" : a + b : a + \"inherit\";\n      }, _applyTransition: function _applyTransition(b) {\n        return b && (this._ui.container.removeClass(this._fallbackTransition), \"none\" !== b && (this._fallbackTransition = a.mobile._maybeDegradeTransition(b), \"none\" === this._fallbackTransition && (this._fallbackTransition = \"\"), this._ui.container.addClass(this._fallbackTransition))), this;\n      }, _setOptions: function _setOptions(a) {\n        var b = this.options,\n            d = this.element,\n            e = this._ui.screen;return a.wrapperClass !== c && this._ui.container.removeClass(b.wrapperClass).addClass(a.wrapperClass), a.theme !== c && d.removeClass(this._themeClassFromOption(\"ui-body-\", b.theme)).addClass(this._themeClassFromOption(\"ui-body-\", a.theme)), a.overlayTheme !== c && (e.removeClass(this._themeClassFromOption(\"ui-overlay-\", b.overlayTheme)).addClass(this._themeClassFromOption(\"ui-overlay-\", a.overlayTheme)), this._isOpen && e.addClass(\"in\")), a.shadow !== c && d.toggleClass(\"ui-overlay-shadow\", a.shadow), a.corners !== c && d.toggleClass(\"ui-corner-all\", a.corners), a.transition !== c && (this._currentTransition || this._applyTransition(a.transition)), a.tolerance !== c && this._setTolerance(a.tolerance), a.disabled !== c && a.disabled && this.close(), this._super(a);\n      }, _setTolerance: function _setTolerance(b) {\n        var d,\n            e = { t: 30, r: 15, b: 30, l: 15 };if (b !== c) switch (d = String(b).split(\",\"), a.each(d, function (a, b) {\n          d[a] = parseInt(b, 10);\n        }), d.length) {case 1:\n            isNaN(d[0]) || (e.t = e.r = e.b = e.l = d[0]);break;case 2:\n            isNaN(d[0]) || (e.t = e.b = d[0]), isNaN(d[1]) || (e.l = e.r = d[1]);break;case 4:\n            isNaN(d[0]) || (e.t = d[0]), isNaN(d[1]) || (e.r = d[1]), isNaN(d[2]) || (e.b = d[2]), isNaN(d[3]) || (e.l = d[3]);}return this._tolerance = e, this;\n      }, _clampPopupWidth: function _clampPopupWidth(a) {\n        var b,\n            c = e(this.window),\n            d = { x: this._tolerance.l, y: c.y + this._tolerance.t, cx: c.cx - this._tolerance.l - this._tolerance.r, cy: c.cy - this._tolerance.t - this._tolerance.b };return a || this._ui.container.css(\"max-width\", d.cx), b = { cx: this._ui.container.outerWidth(!0), cy: this._ui.container.outerHeight(!0) }, { rc: d, menuSize: b };\n      }, _calculateFinalLocation: function _calculateFinalLocation(a, b) {\n        var c,\n            e = b.rc,\n            f = b.menuSize;return c = { left: d(e.cx, f.cx, e.x, a.x), top: d(e.cy, f.cy, e.y, a.y) }, c.top = Math.max(0, c.top), c.top -= Math.min(c.top, Math.max(0, c.top + f.cy - this.document.height())), c;\n      }, _placementCoords: function _placementCoords(a) {\n        return this._calculateFinalLocation(a, this._clampPopupWidth());\n      }, _createPrerequisites: function _createPrerequisites(b, c, d) {\n        var e,\n            f = this;e = { screen: a.Deferred(), container: a.Deferred() }, e.screen.then(function () {\n          e === f._prerequisites && b();\n        }), e.container.then(function () {\n          e === f._prerequisites && c();\n        }), a.when(e.screen, e.container).done(function () {\n          e === f._prerequisites && (f._prerequisites = null, d());\n        }), f._prerequisites = e;\n      }, _animate: function _animate(b) {\n        return this._ui.screen.removeClass(b.classToRemove).addClass(b.screenClassToAdd), b.prerequisites.screen.resolve(), b.transition && \"none\" !== b.transition && (b.applyTransition && this._applyTransition(b.transition), this._fallbackTransition) ? void this._ui.container.addClass(b.containerClassToAdd).removeClass(b.classToRemove).animationComplete(a.proxy(b.prerequisites.container, \"resolve\")) : (this._ui.container.removeClass(b.classToRemove), void b.prerequisites.container.resolve());\n      }, _desiredCoords: function _desiredCoords(b) {\n        var c,\n            d = null,\n            f = e(this.window),\n            g = b.x,\n            h = b.y,\n            i = b.positionTo;if (i && \"origin\" !== i) if (\"window\" === i) g = f.cx / 2 + f.x, h = f.cy / 2 + f.y;else {\n          try {\n            d = a(i);\n          } catch (j) {\n            d = null;\n          }d && (d.filter(\":visible\"), 0 === d.length && (d = null));\n        }return d && (c = d.offset(), g = c.left + d.outerWidth() / 2, h = c.top + d.outerHeight() / 2), (\"number\" !== a.type(g) || isNaN(g)) && (g = f.cx / 2 + f.x), (\"number\" !== a.type(h) || isNaN(h)) && (h = f.cy / 2 + f.y), { x: g, y: h };\n      }, _reposition: function _reposition(a) {\n        a = { x: a.x, y: a.y, positionTo: a.positionTo }, this._trigger(\"beforeposition\", c, a), this._ui.container.offset(this._placementCoords(this._desiredCoords(a)));\n      }, reposition: function reposition(a) {\n        this._isOpen && this._reposition(a);\n      }, _safelyBlur: function _safelyBlur(b) {\n        b !== this.window[0] && \"body\" !== b.nodeName.toLowerCase() && a(b).blur();\n      }, _openPrerequisitesComplete: function _openPrerequisitesComplete() {\n        var b = this.element.attr(\"id\"),\n            c = this._ui.container.find(\":focusable\").first();this._ui.container.addClass(\"ui-popup-active\"), this._isOpen = !0, this._resizeScreen(), a.contains(this._ui.container[0], this.document[0].activeElement) || this._safelyBlur(this.document[0].activeElement), c.length > 0 && (this._ui.focusElement = c), this._ignoreResizeEvents(), b && this.document.find(\"[aria-haspopup='true'][aria-owns='\" + b + \"']\").attr(\"aria-expanded\", !0), this._trigger(\"afteropen\");\n      }, _open: function _open(b) {\n        var c = a.extend({}, this.options, b),\n            d = function () {\n          var a = navigator.userAgent,\n              b = a.match(/AppleWebKit\\/([0-9\\.]+)/),\n              c = !!b && b[1],\n              d = a.match(/Android (\\d+(?:\\.\\d+))/),\n              e = !!d && d[1],\n              f = a.indexOf(\"Chrome\") > -1;return null !== d && \"4.0\" === e && c && c > 534.13 && !f ? !0 : !1;\n        }();this._createPrerequisites(a.noop, a.noop, a.proxy(this, \"_openPrerequisitesComplete\")), this._currentTransition = c.transition, this._applyTransition(c.transition), this._ui.screen.removeClass(\"ui-screen-hidden\"), this._ui.container.removeClass(\"ui-popup-truncate\"), this._reposition(c), this._ui.container.removeClass(\"ui-popup-hidden\"), this.options.overlayTheme && d && this.element.closest(\".ui-page\").addClass(\"ui-popup-open\"), this._animate({ additionalCondition: !0, transition: c.transition, classToRemove: \"\", screenClassToAdd: \"in\", containerClassToAdd: \"in\", applyTransition: !1, prerequisites: this._prerequisites });\n      }, _closePrerequisiteScreen: function _closePrerequisiteScreen() {\n        this._ui.screen.removeClass(\"out\").addClass(\"ui-screen-hidden\");\n      }, _closePrerequisiteContainer: function _closePrerequisiteContainer() {\n        this._ui.container.removeClass(\"reverse out\").addClass(\"ui-popup-hidden ui-popup-truncate\").removeAttr(\"style\");\n      }, _closePrerequisitesDone: function _closePrerequisitesDone() {\n        var b = this._ui.container,\n            d = this.element.attr(\"id\");a.mobile.popup.active = c, a(\":focus\", b[0]).add(b[0]).blur(), d && this.document.find(\"[aria-haspopup='true'][aria-owns='\" + d + \"']\").attr(\"aria-expanded\", !1), this._trigger(\"afterclose\");\n      }, _close: function _close(b) {\n        this._ui.container.removeClass(\"ui-popup-active\"), this._page.removeClass(\"ui-popup-open\"), this._isOpen = !1, this._createPrerequisites(a.proxy(this, \"_closePrerequisiteScreen\"), a.proxy(this, \"_closePrerequisiteContainer\"), a.proxy(this, \"_closePrerequisitesDone\")), this._animate({ additionalCondition: this._ui.screen.hasClass(\"in\"), transition: b ? \"none\" : this._currentTransition, classToRemove: \"in\", screenClassToAdd: \"out\", containerClassToAdd: \"reverse out\", applyTransition: !0, prerequisites: this._prerequisites });\n      }, _unenhance: function _unenhance() {\n        this.options.enhanced || (this._setOptions({ theme: a.mobile.popup.prototype.options.theme }), this.element.detach().insertAfter(this._ui.placeholder).removeClass(\"ui-popup ui-overlay-shadow ui-corner-all ui-body-inherit\"), this._ui.screen.remove(), this._ui.container.remove(), this._ui.placeholder.remove());\n      }, _destroy: function _destroy() {\n        return a.mobile.popup.active === this ? (this.element.one(\"popupafterclose\", a.proxy(this, \"_unenhance\")), this.close()) : this._unenhance(), this;\n      }, _closePopup: function _closePopup(c, d) {\n        var e,\n            f,\n            g = this.options,\n            h = !1;c && c.isDefaultPrevented() || a.mobile.popup.active !== this || (b.scrollTo(0, this._scrollTop), c && \"pagebeforechange\" === c.type && d && (e = \"string\" == typeof d.toPage ? d.toPage : d.toPage.jqmData(\"url\"), e = a.mobile.path.parseUrl(e), f = e.pathname + e.search + e.hash, this._myUrl !== a.mobile.path.makeUrlAbsolute(f) ? h = !0 : c.preventDefault()), this.window.off(g.closeEvents), this.element.undelegate(g.closeLinkSelector, g.closeLinkEvents), this._close(h));\n      }, _bindContainerClose: function _bindContainerClose() {\n        this.window.on(this.options.closeEvents, a.proxy(this, \"_closePopup\"));\n      }, widget: function widget() {\n        return this._ui.container;\n      }, open: function open(b) {\n        var c,\n            d,\n            e,\n            f,\n            g,\n            h,\n            i = this,\n            j = this.options;return a.mobile.popup.active || j.disabled ? this : (a.mobile.popup.active = this, this._scrollTop = this.window.scrollTop(), j.history ? (h = a.mobile.navigate.history, d = a.mobile.dialogHashKey, e = a.mobile.activePage, f = e ? e.hasClass(\"ui-dialog\") : !1, this._myUrl = c = h.getActive().url, (g = c.indexOf(d) > -1 && !f && h.activeIndex > 0) ? (i._open(b), i._bindContainerClose(), this) : (-1 !== c.indexOf(d) || f ? c = a.mobile.path.parseLocation().hash + d : c += c.indexOf(\"#\") > -1 ? d : \"#\" + d, this.window.one(\"beforenavigate\", function (a) {\n          a.preventDefault(), i._open(b), i._bindContainerClose();\n        }), this.urlAltered = !0, a.mobile.navigate(c, { role: \"dialog\" }), this)) : (i._open(b), i._bindContainerClose(), i.element.delegate(j.closeLinkSelector, j.closeLinkEvents, function (a) {\n          i.close(), a.preventDefault();\n        }), this));\n      }, close: function close() {\n        return a.mobile.popup.active !== this ? this : (this._scrollTop = this.window.scrollTop(), this.options.history && this.urlAltered ? (a.mobile.back(), this.urlAltered = !1) : this._closePopup(), this);\n      } }), a.mobile.popup.handleLink = function (b) {\n      var c,\n          d = a.mobile.path,\n          e = a(d.hashToSelector(d.parseUrl(b.attr(\"href\")).hash)).first();e.length > 0 && e.data(\"mobile-popup\") && (c = b.offset(), e.popup(\"open\", { x: c.left + b.outerWidth() / 2, y: c.top + b.outerHeight() / 2, transition: b.jqmData(\"transition\"), positionTo: b.jqmData(\"position-to\") })), setTimeout(function () {\n        b.removeClass(a.mobile.activeBtnClass);\n      }, 300);\n    }, a.mobile.document.on(\"pagebeforechange\", function (b, c) {\n      \"popup\" === c.options.role && (a.mobile.popup.handleLink(c.options.link), b.preventDefault());\n    });\n  }(a), function (a, b) {\n    var d = \".ui-disabled,.ui-state-disabled,.ui-li-divider,.ui-screen-hidden,:jqmData(role='placeholder')\",\n        e = function e(a, b, c) {\n      var e = a[c + \"All\"]().not(d).first();e.length && (b.blur().attr(\"tabindex\", \"-1\"), e.find(\"a\").first().focus());\n    };a.widget(\"mobile.selectmenu\", a.mobile.selectmenu, { _create: function _create() {\n        var a = this.options;return a.nativeMenu = a.nativeMenu || this.element.parents(\":jqmData(role='popup'),:mobile-popup\").length > 0, this._super();\n      }, _handleSelectFocus: function _handleSelectFocus() {\n        this.element.blur(), this.button.focus();\n      }, _handleKeydown: function _handleKeydown(a) {\n        this._super(a), this._handleButtonVclickKeydown(a);\n      }, _handleButtonVclickKeydown: function _handleButtonVclickKeydown(b) {\n        this.options.disabled || this.isOpen || this.options.nativeMenu || (\"vclick\" === b.type || b.keyCode && (b.keyCode === a.mobile.keyCode.ENTER || b.keyCode === a.mobile.keyCode.SPACE)) && (this._decideFormat(), \"overlay\" === this.menuType ? this.button.attr(\"href\", \"#\" + this.popupId).attr(\"data-\" + (a.mobile.ns || \"\") + \"rel\", \"popup\") : this.button.attr(\"href\", \"#\" + this.dialogId).attr(\"data-\" + (a.mobile.ns || \"\") + \"rel\", \"dialog\"), this.isOpen = !0);\n      }, _handleListFocus: function _handleListFocus(b) {\n        var c = \"focusin\" === b.type ? { tabindex: \"0\", event: \"vmouseover\" } : { tabindex: \"-1\", event: \"vmouseout\" };a(b.target).attr(\"tabindex\", c.tabindex).trigger(c.event);\n      }, _handleListKeydown: function _handleListKeydown(b) {\n        var c = a(b.target),\n            d = c.closest(\"li\");switch (b.keyCode) {case 38:\n            return e(d, c, \"prev\"), !1;case 40:\n            return e(d, c, \"next\"), !1;case 13:case 32:\n            return c.trigger(\"click\"), !1;}\n      }, _handleMenuPageHide: function _handleMenuPageHide() {\n        this._delayedTrigger(), this.thisPage.page(\"bindRemove\");\n      }, _handleHeaderCloseClick: function _handleHeaderCloseClick() {\n        return \"overlay\" === this.menuType ? (this.close(), !1) : void 0;\n      }, _handleListItemClick: function _handleListItemClick(b) {\n        var c = a(b.target).closest(\"li\"),\n            d = this.select[0].selectedIndex,\n            e = a.mobile.getAttribute(c, \"option-index\"),\n            f = this._selectOptions().eq(e)[0];f.selected = this.isMultiple ? !f.selected : !0, this.isMultiple && c.find(\"a\").toggleClass(\"ui-checkbox-on\", f.selected).toggleClass(\"ui-checkbox-off\", !f.selected), this.isMultiple || d === e || (this._triggerChange = !0), this.isMultiple ? (this.select.trigger(\"change\"), this.list.find(\"li:not(.ui-li-divider)\").eq(e).find(\"a\").first().focus()) : this.close(), b.preventDefault();\n      }, build: function build() {\n        var c,\n            d,\n            e,\n            f,\n            g,\n            h,\n            i,\n            j,\n            k,\n            l,\n            m,\n            n,\n            o,\n            p,\n            q,\n            r,\n            s,\n            t,\n            u,\n            v = this.options;return v.nativeMenu ? this._super() : (c = this.selectId, d = c + \"-listbox\", e = c + \"-dialog\", f = this.label, g = this.element.closest(\".ui-page\"), h = this.element[0].multiple, i = c + \"-menu\", j = v.theme ? \" data-\" + a.mobile.ns + \"theme='\" + v.theme + \"'\" : \"\", k = v.overlayTheme || v.theme || null, l = k ? \" data-\" + a.mobile.ns + \"overlay-theme='\" + k + \"'\" : \"\", m = v.dividerTheme && h ? \" data-\" + a.mobile.ns + \"divider-theme='\" + v.dividerTheme + \"'\" : \"\", n = a(\"<div data-\" + a.mobile.ns + \"role='dialog' class='ui-selectmenu' id='\" + e + \"'\" + j + l + \"><div data-\" + a.mobile.ns + \"role='header'><div class='ui-title'></div></div><div data-\" + a.mobile.ns + \"role='content'></div></div>\"), o = a(\"<div\" + j + l + \" id='\" + d + \"' class='ui-selectmenu'></div>\").insertAfter(this.select).popup(), p = a(\"<ul class='ui-selectmenu-list' id='\" + i + \"' role='listbox' aria-labelledby='\" + this.buttonId + \"'\" + j + m + \"></ul>\").appendTo(o), q = a(\"<div class='ui-header ui-bar-\" + (v.theme ? v.theme : \"inherit\") + \"'></div>\").prependTo(o), r = a(\"<h1 class='ui-title'></h1>\").appendTo(q), this.isMultiple && (u = a(\"<a>\", { role: \"button\", text: v.closeText, href: \"#\", \"class\": \"ui-btn ui-corner-all ui-btn-left ui-btn-icon-notext ui-icon-delete\" }).appendTo(q)), a.extend(this, { selectId: c, menuId: i, popupId: d, dialogId: e, thisPage: g, menuPage: n, label: f, isMultiple: h, theme: v.theme, listbox: o, list: p, header: q, headerTitle: r, headerClose: u, menuPageContent: s, menuPageClose: t, placeholder: \"\" }), this.refresh(), this._origTabIndex === b && (this._origTabIndex = null === this.select[0].getAttribute(\"tabindex\") ? !1 : this.select.attr(\"tabindex\")), this.select.attr(\"tabindex\", \"-1\"), this._on(this.select, { focus: \"_handleSelectFocus\" }), this._on(this.button, { vclick: \"_handleButtonVclickKeydown\" }), this.list.attr(\"role\", \"listbox\"), this._on(this.list, { focusin: \"_handleListFocus\", focusout: \"_handleListFocus\", keydown: \"_handleListKeydown\", \"click li:not(.ui-disabled,.ui-state-disabled,.ui-li-divider)\": \"_handleListItemClick\" }), this._on(this.menuPage, { pagehide: \"_handleMenuPageHide\" }), this._on(this.listbox, { popupafterclose: \"_popupClosed\" }), this.isMultiple && this._on(this.headerClose, { click: \"_handleHeaderCloseClick\" }), this);\n      }, _popupClosed: function _popupClosed() {\n        this.close(), this._delayedTrigger();\n      }, _delayedTrigger: function _delayedTrigger() {\n        this._triggerChange && this.element.trigger(\"change\"), this._triggerChange = !1;\n      }, _isRebuildRequired: function _isRebuildRequired() {\n        var a = this.list.find(\"li\"),\n            b = this._selectOptions().not(\".ui-screen-hidden\");return b.text() !== a.text();\n      }, selected: function selected() {\n        return this._selectOptions().filter(\":selected:not( :jqmData(placeholder='true') )\");\n      }, refresh: function refresh(b) {\n        var c, d;return this.options.nativeMenu ? this._super(b) : (c = this, (b || this._isRebuildRequired()) && c._buildList(), d = this.selectedIndices(), c.setButtonText(), c.setButtonCount(), void c.list.find(\"li:not(.ui-li-divider)\").find(\"a\").removeClass(a.mobile.activeBtnClass).end().attr(\"aria-selected\", !1).each(function (b) {\n          var e = a(this);a.inArray(b, d) > -1 ? (e.attr(\"aria-selected\", !0), c.isMultiple ? e.find(\"a\").removeClass(\"ui-checkbox-off\").addClass(\"ui-checkbox-on\") : e.hasClass(\"ui-screen-hidden\") ? e.next().find(\"a\").addClass(a.mobile.activeBtnClass) : e.find(\"a\").addClass(a.mobile.activeBtnClass)) : c.isMultiple && e.find(\"a\").removeClass(\"ui-checkbox-on\").addClass(\"ui-checkbox-off\");\n        }));\n      }, close: function close() {\n        if (!this.options.disabled && this.isOpen) {\n          var a = this;\"page\" === a.menuType ? (a.menuPage.dialog(\"close\"), a.list.appendTo(a.listbox)) : a.listbox.popup(\"close\"), a._focusButton(), a.isOpen = !1;\n        }\n      }, open: function open() {\n        this.button.click();\n      }, _focusMenuItem: function _focusMenuItem() {\n        var b = this.list.find(\"a.\" + a.mobile.activeBtnClass);0 === b.length && (b = this.list.find(\"li:not(\" + d + \") a.ui-btn\")), b.first().focus();\n      }, _decideFormat: function _decideFormat() {\n        var b = this,\n            c = this.window,\n            d = b.list.parent(),\n            e = d.outerHeight(),\n            f = c.scrollTop(),\n            g = b.button.offset().top,\n            h = c.height();e > h - 80 || !a.support.scrollTop ? (b.menuPage.appendTo(a.mobile.pageContainer).page(), b.menuPageContent = b.menuPage.find(\".ui-content\"), b.menuPageClose = b.menuPage.find(\".ui-header a\"), b.thisPage.unbind(\"pagehide.remove\"), 0 === f && g > h && b.thisPage.one(\"pagehide\", function () {\n          a(this).jqmData(\"lastScroll\", g);\n        }), b.menuPage.one({ pageshow: a.proxy(this, \"_focusMenuItem\"), pagehide: a.proxy(this, \"close\") }), b.menuType = \"page\", b.menuPageContent.append(b.list), b.menuPage.find(\"div .ui-title\").text(b.label.getEncodedText() || b.placeholder)) : (b.menuType = \"overlay\", b.listbox.one({ popupafteropen: a.proxy(this, \"_focusMenuItem\") }));\n      }, _buildList: function _buildList() {\n        var b,\n            d,\n            e,\n            f,\n            g,\n            h,\n            i,\n            j,\n            k,\n            l,\n            m,\n            n,\n            o,\n            p,\n            q = this,\n            r = this.options,\n            s = this.placeholder,\n            t = !0,\n            u = \"false\",\n            v = \"data-\" + a.mobile.ns,\n            w = v + \"option-index\",\n            x = v + \"icon\",\n            y = v + \"role\",\n            z = v + \"placeholder\",\n            A = c.createDocumentFragment(),\n            B = !1;for (q.list.empty().filter(\".ui-listview\").listview(\"destroy\"), b = this._selectOptions(), d = b.length, e = this.select[0], g = 0; d > g; g++, B = !1) {\n          h = b[g], i = a(h), i.hasClass(\"ui-screen-hidden\") || (j = h.parentNode, m = [], k = i.text(), l = c.createElement(\"a\"), l.setAttribute(\"href\", \"#\"), l.appendChild(c.createTextNode(k)), j !== e && \"optgroup\" === j.nodeName.toLowerCase() && (n = j.getAttribute(\"label\"), n !== f && (o = c.createElement(\"li\"), o.setAttribute(y, \"list-divider\"), o.setAttribute(\"role\", \"option\"), o.setAttribute(\"tabindex\", \"-1\"), o.appendChild(c.createTextNode(n)), A.appendChild(o), f = n)), !t || h.getAttribute(\"value\") && 0 !== k.length && !i.jqmData(\"placeholder\") || (t = !1, B = !0, null === h.getAttribute(z) && (this._removePlaceholderAttr = !0), h.setAttribute(z, !0), r.hidePlaceholderMenuItems && m.push(\"ui-screen-hidden\"), s !== k && (s = q.placeholder = k)), p = c.createElement(\"li\"), h.disabled && (m.push(\"ui-state-disabled\"), p.setAttribute(\"aria-disabled\", !0)), p.setAttribute(w, g), p.setAttribute(x, u), B && p.setAttribute(z, !0), p.className = m.join(\" \"), p.setAttribute(\"role\", \"option\"), l.setAttribute(\"tabindex\", \"-1\"), this.isMultiple && a(l).addClass(\"ui-btn ui-checkbox-off ui-btn-icon-right\"), p.appendChild(l), A.appendChild(p));\n        }q.list[0].appendChild(A), this.isMultiple || s.length ? this.headerTitle.text(this.placeholder) : this.header.addClass(\"ui-screen-hidden\"), q.list.listview();\n      }, _button: function _button() {\n        return this.options.nativeMenu ? this._super() : a(\"<a>\", { href: \"#\", role: \"button\", id: this.buttonId, \"aria-haspopup\": \"true\", \"aria-owns\": this.menuId });\n      }, _destroy: function _destroy() {\n        this.options.nativeMenu || (this.close(), this._origTabIndex !== b && (this._origTabIndex !== !1 ? this.select.attr(\"tabindex\", this._origTabIndex) : this.select.removeAttr(\"tabindex\")), this._removePlaceholderAttr && this._selectOptions().removeAttr(\"data-\" + a.mobile.ns + \"placeholder\"), this.listbox.remove(), this.menuPage.remove()), this._super();\n      } });\n  }(a), function (a, b) {\n    function c(a, b) {\n      var c = b ? b : [];return c.push(\"ui-btn\"), a.theme && c.push(\"ui-btn-\" + a.theme), a.icon && (c = c.concat([\"ui-icon-\" + a.icon, \"ui-btn-icon-\" + a.iconpos]), a.iconshadow && c.push(\"ui-shadow-icon\")), a.inline && c.push(\"ui-btn-inline\"), a.shadow && c.push(\"ui-shadow\"), a.corners && c.push(\"ui-corner-all\"), a.mini && c.push(\"ui-mini\"), c;\n    }function d(a) {\n      var c,\n          d,\n          e,\n          g = !1,\n          h = !0,\n          i = { icon: \"\", inline: !1, shadow: !1, corners: !1, iconshadow: !1, mini: !1 },\n          j = [];for (a = a.split(\" \"), c = 0; c < a.length; c++) {\n        e = !0, d = f[a[c]], d !== b ? (e = !1, i[d] = !0) : 0 === a[c].indexOf(\"ui-btn-icon-\") ? (e = !1, h = !1, i.iconpos = a[c].substring(12)) : 0 === a[c].indexOf(\"ui-icon-\") ? (e = !1, i.icon = a[c].substring(8)) : 0 === a[c].indexOf(\"ui-btn-\") && 8 === a[c].length ? (e = !1, i.theme = a[c].substring(7)) : \"ui-btn\" === a[c] && (e = !1, g = !0), e && j.push(a[c]);\n      }return h && (i.icon = \"\"), { options: i, unknownClasses: j, alreadyEnhanced: g };\n    }function e(a) {\n      return \"-\" + a.toLowerCase();\n    }var f = { \"ui-shadow\": \"shadow\", \"ui-corner-all\": \"corners\", \"ui-btn-inline\": \"inline\", \"ui-shadow-icon\": \"iconshadow\", \"ui-mini\": \"mini\" },\n        g = function g() {\n      var c = a.mobile.getAttribute.apply(this, arguments);return null == c ? b : c;\n    },\n        h = /[A-Z]/g;a.fn.buttonMarkup = function (f, i) {\n      var j,\n          k,\n          l,\n          m,\n          n,\n          o = a.fn.buttonMarkup.defaults;for (j = 0; j < this.length; j++) {\n        if (l = this[j], k = i ? { alreadyEnhanced: !1, unknownClasses: [] } : d(l.className), m = a.extend({}, k.alreadyEnhanced ? k.options : {}, f), !k.alreadyEnhanced) for (n in o) {\n          m[n] === b && (m[n] = g(l, n.replace(h, e)));\n        }l.className = c(a.extend({}, o, m), k.unknownClasses).join(\" \"), \"button\" !== l.tagName.toLowerCase() && l.setAttribute(\"role\", \"button\");\n      }return this;\n    }, a.fn.buttonMarkup.defaults = { icon: \"\", iconpos: \"left\", theme: null, inline: !1, shadow: !0, corners: !0, iconshadow: !1, mini: !1 }, a.extend(a.fn.buttonMarkup, { initSelector: \"a:jqmData(role='button'), .ui-bar > a, .ui-bar > :jqmData(role='controlgroup') > a, button:not(:jqmData(role='navbar') button)\" });\n  }(a), function (a, b) {\n    a.widget(\"mobile.controlgroup\", a.extend({ options: { enhanced: !1, theme: null, shadow: !1, corners: !0, excludeInvisible: !0, type: \"vertical\", mini: !1 }, _create: function _create() {\n        var b = this.element,\n            c = this.options,\n            d = a.mobile.page.prototype.keepNativeSelector();a.fn.buttonMarkup && this.element.find(a.fn.buttonMarkup.initSelector).not(d).buttonMarkup(), a.each(this._childWidgets, a.proxy(function (b, c) {\n          a.mobile[c] && this.element.find(a.mobile[c].initSelector).not(d)[c]();\n        }, this)), a.extend(this, { _ui: null, _initialRefresh: !0 }), this._ui = c.enhanced ? { groupLegend: b.children(\".ui-controlgroup-label\").children(), childWrapper: b.children(\".ui-controlgroup-controls\") } : this._enhance();\n      }, _childWidgets: [\"checkboxradio\", \"selectmenu\", \"button\"], _themeClassFromOption: function _themeClassFromOption(a) {\n        return a ? \"none\" === a ? \"\" : \"ui-group-theme-\" + a : \"\";\n      }, _enhance: function _enhance() {\n        var b = this.element,\n            c = this.options,\n            d = { groupLegend: b.children(\"legend\"), childWrapper: b.addClass(\"ui-controlgroup ui-controlgroup-\" + (\"horizontal\" === c.type ? \"horizontal\" : \"vertical\") + \" \" + this._themeClassFromOption(c.theme) + \" \" + (c.corners ? \"ui-corner-all \" : \"\") + (c.mini ? \"ui-mini \" : \"\")).wrapInner(\"<div class='ui-controlgroup-controls \" + (c.shadow === !0 ? \"ui-shadow\" : \"\") + \"'></div>\").children() };return d.groupLegend.length > 0 && a(\"<div role='heading' class='ui-controlgroup-label'></div>\").append(d.groupLegend).prependTo(b), d;\n      }, _init: function _init() {\n        this.refresh();\n      }, _setOptions: function _setOptions(a) {\n        var c,\n            d,\n            e = this.element;return a.type !== b && (e.removeClass(\"ui-controlgroup-horizontal ui-controlgroup-vertical\").addClass(\"ui-controlgroup-\" + (\"horizontal\" === a.type ? \"horizontal\" : \"vertical\")), c = !0), a.theme !== b && e.removeClass(this._themeClassFromOption(this.options.theme)).addClass(this._themeClassFromOption(a.theme)), a.corners !== b && e.toggleClass(\"ui-corner-all\", a.corners), a.mini !== b && e.toggleClass(\"ui-mini\", a.mini), a.shadow !== b && this._ui.childWrapper.toggleClass(\"ui-shadow\", a.shadow), a.excludeInvisible !== b && (this.options.excludeInvisible = a.excludeInvisible, c = !0), d = this._super(a), c && this.refresh(), d;\n      }, container: function container() {\n        return this._ui.childWrapper;\n      }, refresh: function refresh() {\n        var b = this.container(),\n            c = b.find(\".ui-btn\").not(\".ui-slider-handle\"),\n            d = this._initialRefresh;a.mobile.checkboxradio && b.find(\":mobile-checkboxradio\").checkboxradio(\"refresh\"), this._addFirstLastClasses(c, this.options.excludeInvisible ? this._getVisibles(c, d) : c, d), this._initialRefresh = !1;\n      }, _destroy: function _destroy() {\n        var a,\n            b,\n            c = this.options;return c.enhanced ? this : (a = this._ui, b = this.element.removeClass(\"ui-controlgroup ui-controlgroup-horizontal ui-controlgroup-vertical ui-corner-all ui-mini \" + this._themeClassFromOption(c.theme)).find(\".ui-btn\").not(\".ui-slider-handle\"), this._removeFirstLastClasses(b), a.groupLegend.unwrap(), void a.childWrapper.children().unwrap());\n      } }, a.mobile.behaviors.addFirstLastClasses));\n  }(a), function (a, b) {\n    a.widget(\"mobile.toolbar\", { initSelector: \":jqmData(role='footer'), :jqmData(role='header')\", options: { theme: null, addBackBtn: !1, backBtnTheme: null, backBtnText: \"Back\" }, _create: function _create() {\n        var b,\n            c,\n            d = this.element.is(\":jqmData(role='header')\") ? \"header\" : \"footer\",\n            e = this.element.closest(\".ui-page\");0 === e.length && (e = !1, this._on(this.document, { pageshow: \"refresh\" })), a.extend(this, { role: d, page: e, leftbtn: b, rightbtn: c }), this.element.attr(\"role\", \"header\" === d ? \"banner\" : \"contentinfo\").addClass(\"ui-\" + d), this.refresh(), this._setOptions(this.options);\n      }, _setOptions: function _setOptions(a) {\n        if (a.addBackBtn !== b && this._updateBackButton(), null != a.backBtnTheme && this.element.find(\".ui-toolbar-back-btn\").addClass(\"ui-btn ui-btn-\" + a.backBtnTheme), a.backBtnText !== b && this.element.find(\".ui-toolbar-back-btn .ui-btn-text\").text(a.backBtnText), a.theme !== b) {\n          var c = this.options.theme ? this.options.theme : \"inherit\",\n              d = a.theme ? a.theme : \"inherit\";this.element.removeClass(\"ui-bar-\" + c).addClass(\"ui-bar-\" + d);\n        }this._super(a);\n      }, refresh: function refresh() {\n        \"header\" === this.role && this._addHeaderButtonClasses(), this.page || (this._setRelative(), \"footer\" === this.role ? this.element.appendTo(\"body\") : \"header\" === this.role && this._updateBackButton()), this._addHeadingClasses(), this._btnMarkup();\n      }, _setRelative: function _setRelative() {\n        a(\"[data-\" + a.mobile.ns + \"role='page']\").css({ position: \"relative\" });\n      }, _btnMarkup: function _btnMarkup() {\n        this.element.children(\"a\").filter(\":not([data-\" + a.mobile.ns + \"role='none'])\").attr(\"data-\" + a.mobile.ns + \"role\", \"button\"), this.element.trigger(\"create\");\n      }, _addHeaderButtonClasses: function _addHeaderButtonClasses() {\n        var a = this.element.children(\"a, button\");this.leftbtn = a.hasClass(\"ui-btn-left\") && !a.hasClass(\"ui-toolbar-back-btn\"), this.rightbtn = a.hasClass(\"ui-btn-right\"), this.leftbtn = this.leftbtn || a.eq(0).not(\".ui-btn-right,.ui-toolbar-back-btn\").addClass(\"ui-btn-left\").length, this.rightbtn = this.rightbtn || a.eq(1).addClass(\"ui-btn-right\").length;\n      }, _updateBackButton: function _updateBackButton() {\n        var b,\n            c = this.options,\n            d = c.backBtnTheme || c.theme;b = this._backButton = this._backButton || {}, this.options.addBackBtn && \"header\" === this.role && a(\".ui-page\").length > 1 && (this.page ? this.page[0].getAttribute(\"data-\" + a.mobile.ns + \"url\") !== a.mobile.path.stripHash(location.hash) : a.mobile.navigate && a.mobile.navigate.history && a.mobile.navigate.history.activeIndex > 0) && !this.leftbtn ? b.attached || (this.backButton = b.element = (b.element || a(\"<a role='button' href='javascript:void(0);' class='ui-btn ui-corner-all ui-shadow ui-btn-left \" + (d ? \"ui-btn-\" + d + \" \" : \"\") + \"ui-toolbar-back-btn ui-icon-carat-l ui-btn-icon-left' data-\" + a.mobile.ns + \"rel='back'>\" + c.backBtnText + \"</a>\")).prependTo(this.element), b.attached = !0) : b.element && (b.element.detach(), b.attached = !1);\n      }, _addHeadingClasses: function _addHeadingClasses() {\n        this.element.children(\"h1, h2, h3, h4, h5, h6\").addClass(\"ui-title\").attr({ role: \"heading\", \"aria-level\": \"1\" });\n      }, _destroy: function _destroy() {\n        var a;this.element.children(\"h1, h2, h3, h4, h5, h6\").removeClass(\"ui-title\").removeAttr(\"role\").removeAttr(\"aria-level\"), \"header\" === this.role && (this.element.children(\"a, button\").removeClass(\"ui-btn-left ui-btn-right ui-btn ui-shadow ui-corner-all\"), this.backButton && this.backButton.remove()), a = this.options.theme ? this.options.theme : \"inherit\", this.element.removeClass(\"ui-bar-\" + a), this.element.removeClass(\"ui-\" + this.role).removeAttr(\"role\");\n      } });\n  }(a), function (a, b) {\n    a.widget(\"mobile.toolbar\", a.mobile.toolbar, { options: { position: null, visibleOnPageShow: !0, disablePageZoom: !0, transition: \"slide\", fullscreen: !1, tapToggle: !0, tapToggleBlacklist: \"a, button, input, select, textarea, .ui-header-fixed, .ui-footer-fixed, .ui-flipswitch, .ui-popup, .ui-panel, .ui-panel-dismiss-open\", hideDuringFocus: \"input, textarea, select\", updatePagePadding: !0, trackPersistentToolbars: !0, supportBlacklist: function supportBlacklist() {\n          return !a.support.fixedPosition;\n        } }, _create: function _create() {\n        this._super(), this.pagecontainer = a(\":mobile-pagecontainer\"), \"fixed\" !== this.options.position || this.options.supportBlacklist() || this._makeFixed();\n      }, _makeFixed: function _makeFixed() {\n        this.element.addClass(\"ui-\" + this.role + \"-fixed\"), this.updatePagePadding(), this._addTransitionClass(), this._bindPageEvents(), this._bindToggleHandlers();\n      }, _setOptions: function _setOptions(c) {\n        if (\"fixed\" === c.position && \"fixed\" !== this.options.position && this._makeFixed(), \"fixed\" === this.options.position && !this.options.supportBlacklist()) {\n          var d = this.page ? this.page : a(\".ui-page-active\").length > 0 ? a(\".ui-page-active\") : a(\".ui-page\").eq(0);c.fullscreen !== b && (c.fullscreen ? (this.element.addClass(\"ui-\" + this.role + \"-fullscreen\"), d.addClass(\"ui-page-\" + this.role + \"-fullscreen\")) : (this.element.removeClass(\"ui-\" + this.role + \"-fullscreen\"), d.removeClass(\"ui-page-\" + this.role + \"-fullscreen\").addClass(\"ui-page-\" + this.role + \"-fixed\")));\n        }this._super(c);\n      }, _addTransitionClass: function _addTransitionClass() {\n        var a = this.options.transition;a && \"none\" !== a && (\"slide\" === a && (a = this.element.hasClass(\"ui-header\") ? \"slidedown\" : \"slideup\"), this.element.addClass(a));\n      }, _bindPageEvents: function _bindPageEvents() {\n        var a = this.page ? this.element.closest(\".ui-page\") : this.document;this._on(a, { pagebeforeshow: \"_handlePageBeforeShow\", webkitAnimationStart: \"_handleAnimationStart\", animationstart: \"_handleAnimationStart\", updatelayout: \"_handleAnimationStart\", pageshow: \"_handlePageShow\", pagebeforehide: \"_handlePageBeforeHide\" });\n      }, _handlePageBeforeShow: function _handlePageBeforeShow() {\n        var b = this.options;b.disablePageZoom && a.mobile.zoom.disable(!0), b.visibleOnPageShow || this.hide(!0);\n      }, _handleAnimationStart: function _handleAnimationStart() {\n        this.options.updatePagePadding && this.updatePagePadding(this.page ? this.page : \".ui-page-active\");\n      }, _handlePageShow: function _handlePageShow() {\n        this.updatePagePadding(this.page ? this.page : \".ui-page-active\"), this.options.updatePagePadding && this._on(this.window, { throttledresize: \"updatePagePadding\" });\n      }, _handlePageBeforeHide: function _handlePageBeforeHide(b, c) {\n        var d,\n            e,\n            f,\n            g,\n            h = this.options;h.disablePageZoom && a.mobile.zoom.enable(!0), h.updatePagePadding && this._off(this.window, \"throttledresize\"), h.trackPersistentToolbars && (d = a(\".ui-footer-fixed:jqmData(id)\", this.page), e = a(\".ui-header-fixed:jqmData(id)\", this.page), f = d.length && c.nextPage && a(\".ui-footer-fixed:jqmData(id='\" + d.jqmData(\"id\") + \"')\", c.nextPage) || a(), g = e.length && c.nextPage && a(\".ui-header-fixed:jqmData(id='\" + e.jqmData(\"id\") + \"')\", c.nextPage) || a(), (f.length || g.length) && (f.add(g).appendTo(a.mobile.pageContainer), c.nextPage.one(\"pageshow\", function () {\n          g.prependTo(this), f.appendTo(this);\n        })));\n      }, _visible: !0, updatePagePadding: function updatePagePadding(c) {\n        var d = this.element,\n            e = \"header\" === this.role,\n            f = parseFloat(d.css(e ? \"top\" : \"bottom\"));this.options.fullscreen || (c = c && c.type === b && c || this.page || d.closest(\".ui-page\"), c = this.page ? this.page : \".ui-page-active\", a(c).css(\"padding-\" + (e ? \"top\" : \"bottom\"), d.outerHeight() + f));\n      }, _useTransition: function _useTransition(b) {\n        var c = this.window,\n            d = this.element,\n            e = c.scrollTop(),\n            f = d.height(),\n            g = this.page ? d.closest(\".ui-page\").height() : a(\".ui-page-active\").height(),\n            h = a.mobile.getScreenHeight();return !b && (this.options.transition && \"none\" !== this.options.transition && (\"header\" === this.role && !this.options.fullscreen && e > f || \"footer\" === this.role && !this.options.fullscreen && g - f > e + h) || this.options.fullscreen);\n      }, show: function show(a) {\n        var b = \"ui-fixed-hidden\",\n            c = this.element;this._useTransition(a) ? c.removeClass(\"out \" + b).addClass(\"in\").animationComplete(function () {\n          c.removeClass(\"in\");\n        }) : c.removeClass(b), this._visible = !0;\n      }, hide: function hide(a) {\n        var b = \"ui-fixed-hidden\",\n            c = this.element,\n            d = \"out\" + (\"slide\" === this.options.transition ? \" reverse\" : \"\");this._useTransition(a) ? c.addClass(d).removeClass(\"in\").animationComplete(function () {\n          c.addClass(b).removeClass(d);\n        }) : c.addClass(b).removeClass(d), this._visible = !1;\n      }, toggle: function toggle() {\n        this[this._visible ? \"hide\" : \"show\"]();\n      }, _bindToggleHandlers: function _bindToggleHandlers() {\n        var b,\n            c,\n            d = this,\n            e = d.options,\n            f = !0,\n            g = this.page ? this.page : a(\".ui-page\");g.bind(\"vclick\", function (b) {\n          e.tapToggle && !a(b.target).closest(e.tapToggleBlacklist).length && d.toggle();\n        }).bind(\"focusin focusout\", function (g) {\n          screen.width < 1025 && a(g.target).is(e.hideDuringFocus) && !a(g.target).closest(\".ui-header-fixed, .ui-footer-fixed\").length && (\"focusout\" !== g.type || f ? \"focusin\" === g.type && f && (clearTimeout(b), f = !1, c = setTimeout(function () {\n            d.hide();\n          }, 0)) : (f = !0, clearTimeout(c), b = setTimeout(function () {\n            d.show();\n          }, 0)));\n        });\n      }, _setRelative: function _setRelative() {\n        \"fixed\" !== this.options.position && a(\"[data-\" + a.mobile.ns + \"role='page']\").css({ position: \"relative\" });\n      }, _destroy: function _destroy() {\n        var b,\n            c,\n            d,\n            e,\n            f,\n            g = this.pagecontainer.pagecontainer(\"getActivePage\");this._super(), \"fixed\" === this.options.position && (d = a(\"body>.ui-\" + this.role + \"-fixed\").add(g.find(\".ui-\" + this.options.role + \"-fixed\")).not(this.element).length > 0, f = a(\"body>.ui-\" + this.role + \"-fixed\").add(g.find(\".ui-\" + this.options.role + \"-fullscreen\")).not(this.element).length > 0, c = \"ui-header-fixed ui-footer-fixed ui-header-fullscreen in out ui-footer-fullscreen fade slidedown slideup ui-fixed-hidden\", this.element.removeClass(c), f || (b = \"ui-page-\" + this.role + \"-fullscreen\"), d || (e = \"header\" === this.role, b += \" ui-page-\" + this.role + \"-fixed\", g.css(\"padding-\" + (e ? \"top\" : \"bottom\"), \"\")), g.removeClass(b));\n      } });\n  }(a), function (a) {\n    a.widget(\"mobile.toolbar\", a.mobile.toolbar, { _makeFixed: function _makeFixed() {\n        this._super(), this._workarounds();\n      }, _workarounds: function _workarounds() {\n        var a = navigator.userAgent,\n            b = navigator.platform,\n            c = a.match(/AppleWebKit\\/([0-9]+)/),\n            d = !!c && c[1],\n            e = null,\n            f = this;if (b.indexOf(\"iPhone\") > -1 || b.indexOf(\"iPad\") > -1 || b.indexOf(\"iPod\") > -1) e = \"ios\";else {\n          if (!(a.indexOf(\"Android\") > -1)) return;e = \"android\";\n        }if (\"ios\" === e) f._bindScrollWorkaround();else {\n          if (!(\"android\" === e && d && 534 > d)) return;f._bindScrollWorkaround(), f._bindListThumbWorkaround();\n        }\n      }, _viewportOffset: function _viewportOffset() {\n        var a = this.element,\n            b = a.hasClass(\"ui-header\"),\n            c = Math.abs(a.offset().top - this.window.scrollTop());return b || (c = Math.round(c - this.window.height() + a.outerHeight()) - 60), c;\n      }, _bindScrollWorkaround: function _bindScrollWorkaround() {\n        var a = this;this._on(this.window, { scrollstop: function scrollstop() {\n            var b = a._viewportOffset();b > 2 && a._visible && a._triggerRedraw();\n          } });\n      }, _bindListThumbWorkaround: function _bindListThumbWorkaround() {\n        this.element.closest(\".ui-page\").addClass(\"ui-android-2x-fixed\");\n      }, _triggerRedraw: function _triggerRedraw() {\n        var b = parseFloat(a(\".ui-page-active\").css(\"padding-bottom\"));a(\".ui-page-active\").css(\"padding-bottom\", b + 1 + \"px\"), setTimeout(function () {\n          a(\".ui-page-active\").css(\"padding-bottom\", b + \"px\");\n        }, 0);\n      }, destroy: function destroy() {\n        this._super(), this.element.closest(\".ui-page-active\").removeClass(\"ui-android-2x-fix\");\n      } });\n  }(a), function (a, b) {\n    function c() {\n      var a = e.clone(),\n          b = a.eq(0),\n          c = a.eq(1),\n          d = c.children();return { arEls: c.add(b), gd: b, ct: c, ar: d };\n    }var d = a.mobile.browser.oldIE && a.mobile.browser.oldIE <= 8,\n        e = a(\"<div class='ui-popup-arrow-guide'></div><div class='ui-popup-arrow-container\" + (d ? \" ie\" : \"\") + \"'><div class='ui-popup-arrow'></div></div>\");a.widget(\"mobile.popup\", a.mobile.popup, { options: { arrow: \"\" }, _create: function _create() {\n        var a,\n            b = this._super();return this.options.arrow && (this._ui.arrow = a = this._addArrow()), b;\n      }, _addArrow: function _addArrow() {\n        var a,\n            b = this.options,\n            d = c();return a = this._themeClassFromOption(\"ui-body-\", b.theme), d.ar.addClass(a + (b.shadow ? \" ui-overlay-shadow\" : \"\")), d.arEls.hide().appendTo(this.element), d;\n      }, _unenhance: function _unenhance() {\n        var a = this._ui.arrow;return a && a.arEls.remove(), this._super();\n      }, _tryAnArrow: function _tryAnArrow(a, b, c, d, e) {\n        var f,\n            g,\n            h,\n            i = {},\n            j = {};return d.arFull[a.dimKey] > d.guideDims[a.dimKey] ? e : (i[a.fst] = c[a.fst] + (d.arHalf[a.oDimKey] + d.menuHalf[a.oDimKey]) * a.offsetFactor - d.contentBox[a.fst] + (d.clampInfo.menuSize[a.oDimKey] - d.contentBox[a.oDimKey]) * a.arrowOffsetFactor, i[a.snd] = c[a.snd], f = d.result || this._calculateFinalLocation(i, d.clampInfo), g = { x: f.left, y: f.top }, j[a.fst] = g[a.fst] + d.contentBox[a.fst] + a.tipOffset, j[a.snd] = Math.max(f[a.prop] + d.guideOffset[a.prop] + d.arHalf[a.dimKey], Math.min(f[a.prop] + d.guideOffset[a.prop] + d.guideDims[a.dimKey] - d.arHalf[a.dimKey], c[a.snd])), h = Math.abs(c.x - j.x) + Math.abs(c.y - j.y), (!e || h < e.diff) && (j[a.snd] -= d.arHalf[a.dimKey] + f[a.prop] + d.contentBox[a.snd], e = { dir: b, diff: h, result: f, posProp: a.prop, posVal: j[a.snd] }), e);\n      }, _getPlacementState: function _getPlacementState(a) {\n        var b,\n            c,\n            d = this._ui.arrow,\n            e = { clampInfo: this._clampPopupWidth(!a), arFull: { cx: d.ct.width(), cy: d.ct.height() }, guideDims: { cx: d.gd.width(), cy: d.gd.height() }, guideOffset: d.gd.offset() };return b = this.element.offset(), d.gd.css({ left: 0, top: 0, right: 0, bottom: 0 }), c = d.gd.offset(), e.contentBox = { x: c.left - b.left, y: c.top - b.top, cx: d.gd.width(), cy: d.gd.height() }, d.gd.removeAttr(\"style\"), e.guideOffset = { left: e.guideOffset.left - b.left, top: e.guideOffset.top - b.top }, e.arHalf = { cx: e.arFull.cx / 2, cy: e.arFull.cy / 2 }, e.menuHalf = { cx: e.clampInfo.menuSize.cx / 2, cy: e.clampInfo.menuSize.cy / 2 }, e;\n      }, _placementCoords: function _placementCoords(b) {\n        var c,\n            e,\n            f,\n            g,\n            h,\n            i = this.options.arrow,\n            j = this._ui.arrow;return j ? (j.arEls.show(), h = {}, c = this._getPlacementState(!0), f = { l: { fst: \"x\", snd: \"y\", prop: \"top\", dimKey: \"cy\", oDimKey: \"cx\", offsetFactor: 1, tipOffset: -c.arHalf.cx, arrowOffsetFactor: 0 }, r: { fst: \"x\", snd: \"y\", prop: \"top\", dimKey: \"cy\", oDimKey: \"cx\", offsetFactor: -1, tipOffset: c.arHalf.cx + c.contentBox.cx, arrowOffsetFactor: 1 }, b: { fst: \"y\", snd: \"x\", prop: \"left\", dimKey: \"cx\", oDimKey: \"cy\", offsetFactor: -1, tipOffset: c.arHalf.cy + c.contentBox.cy, arrowOffsetFactor: 1 }, t: { fst: \"y\", snd: \"x\", prop: \"left\", dimKey: \"cx\", oDimKey: \"cy\", offsetFactor: 1, tipOffset: -c.arHalf.cy, arrowOffsetFactor: 0 } }, a.each((i === !0 ? \"l,t,r,b\" : i).split(\",\"), a.proxy(function (a, d) {\n          e = this._tryAnArrow(f[d], d, b, c, e);\n        }, this)), e ? (j.ct.removeClass(\"ui-popup-arrow-l ui-popup-arrow-t ui-popup-arrow-r ui-popup-arrow-b\").addClass(\"ui-popup-arrow-\" + e.dir).removeAttr(\"style\").css(e.posProp, e.posVal).show(), d || (g = this.element.offset(), h[f[e.dir].fst] = j.ct.offset(), h[f[e.dir].snd] = { left: g.left + c.contentBox.x, top: g.top + c.contentBox.y }), e.result) : (j.arEls.hide(), this._super(b))) : this._super(b);\n      }, _setOptions: function _setOptions(a) {\n        var c,\n            d = this.options.theme,\n            e = this._ui.arrow,\n            f = this._super(a);if (a.arrow !== b) {\n          if (!e && a.arrow) return void (this._ui.arrow = this._addArrow());e && !a.arrow && (e.arEls.remove(), this._ui.arrow = null);\n        }return e = this._ui.arrow, e && (a.theme !== b && (d = this._themeClassFromOption(\"ui-body-\", d), c = this._themeClassFromOption(\"ui-body-\", a.theme), e.ar.removeClass(d).addClass(c)), a.shadow !== b && e.ar.toggleClass(\"ui-overlay-shadow\", a.shadow)), f;\n      }, _destroy: function _destroy() {\n        var a = this._ui.arrow;return a && a.arEls.remove(), this._super();\n      } });\n  }(a), function (a, c) {\n    a.widget(\"mobile.panel\", { options: { classes: { panel: \"ui-panel\", panelOpen: \"ui-panel-open\", panelClosed: \"ui-panel-closed\", panelFixed: \"ui-panel-fixed\", panelInner: \"ui-panel-inner\", modal: \"ui-panel-dismiss\", modalOpen: \"ui-panel-dismiss-open\", pageContainer: \"ui-panel-page-container\", pageWrapper: \"ui-panel-wrapper\", pageFixedToolbar: \"ui-panel-fixed-toolbar\", pageContentPrefix: \"ui-panel-page-content\", animate: \"ui-panel-animate\" }, animate: !0, theme: null, position: \"left\", dismissible: !0, display: \"reveal\", swipeClose: !0, positionFixed: !1 }, _closeLink: null, _parentPage: null, _page: null, _modal: null, _panelInner: null, _wrapper: null, _fixedToolbars: null, _create: function _create() {\n        var b = this.element,\n            c = b.closest(\".ui-page, :jqmData(role='page')\");a.extend(this, { _closeLink: b.find(\":jqmData(rel='close')\"), _parentPage: c.length > 0 ? c : !1, _openedPage: null, _page: this._getPage, _panelInner: this._getPanelInner(), _fixedToolbars: this._getFixedToolbars }), \"overlay\" !== this.options.display && this._getWrapper(), this._addPanelClasses(), a.support.cssTransform3d && this.options.animate && this.element.addClass(this.options.classes.animate), this._bindUpdateLayout(), this._bindCloseEvents(), this._bindLinkListeners(), this._bindPageEvents(), this.options.dismissible && this._createModal(), this._bindSwipeEvents();\n      }, _getPanelInner: function _getPanelInner() {\n        var a = this.element.find(\".\" + this.options.classes.panelInner);return 0 === a.length && (a = this.element.children().wrapAll(\"<div class='\" + this.options.classes.panelInner + \"' />\").parent()), a;\n      }, _createModal: function _createModal() {\n        var b = this,\n            c = b._parentPage ? b._parentPage.parent() : b.element.parent();b._modal = a(\"<div class='\" + b.options.classes.modal + \"'></div>\").on(\"mousedown\", function () {\n          b.close();\n        }).appendTo(c);\n      }, _getPage: function _getPage() {\n        var b = this._openedPage || this._parentPage || a(\".\" + a.mobile.activePageClass);return b;\n      }, _getWrapper: function _getWrapper() {\n        var a = this._page().find(\".\" + this.options.classes.pageWrapper);0 === a.length && (a = this._page().children(\".ui-header:not(.ui-header-fixed), .ui-content:not(.ui-popup), .ui-footer:not(.ui-footer-fixed)\").wrapAll(\"<div class='\" + this.options.classes.pageWrapper + \"'></div>\").parent()), this._wrapper = a;\n      }, _getFixedToolbars: function _getFixedToolbars() {\n        var b = a(\"body\").children(\".ui-header-fixed, .ui-footer-fixed\"),\n            c = this._page().find(\".ui-header-fixed, .ui-footer-fixed\"),\n            d = b.add(c).addClass(this.options.classes.pageFixedToolbar);return d;\n      }, _getPosDisplayClasses: function _getPosDisplayClasses(a) {\n        return a + \"-position-\" + this.options.position + \" \" + a + \"-display-\" + this.options.display;\n      }, _getPanelClasses: function _getPanelClasses() {\n        var a = this.options.classes.panel + \" \" + this._getPosDisplayClasses(this.options.classes.panel) + \" \" + this.options.classes.panelClosed + \" ui-body-\" + (this.options.theme ? this.options.theme : \"inherit\");return this.options.positionFixed && (a += \" \" + this.options.classes.panelFixed), a;\n      }, _addPanelClasses: function _addPanelClasses() {\n        this.element.addClass(this._getPanelClasses());\n      }, _handleCloseClick: function _handleCloseClick(a) {\n        a.isDefaultPrevented() || this.close();\n      }, _bindCloseEvents: function _bindCloseEvents() {\n        this._on(this._closeLink, { click: \"_handleCloseClick\" }), this._on({ \"click a:jqmData(ajax='false')\": \"_handleCloseClick\" });\n      }, _positionPanel: function _positionPanel(b) {\n        var c = this,\n            d = c._panelInner.outerHeight(),\n            e = d > a.mobile.getScreenHeight();e || !c.options.positionFixed ? (e && (c._unfixPanel(), a.mobile.resetActivePageHeight(d)), b && this.window[0].scrollTo(0, a.mobile.defaultHomeScroll)) : c._fixPanel();\n      }, _bindFixListener: function _bindFixListener() {\n        this._on(a(b), { throttledresize: \"_positionPanel\" });\n      }, _unbindFixListener: function _unbindFixListener() {\n        this._off(a(b), \"throttledresize\");\n      }, _unfixPanel: function _unfixPanel() {\n        this.options.positionFixed && a.support.fixedPosition && this.element.removeClass(this.options.classes.panelFixed);\n      }, _fixPanel: function _fixPanel() {\n        this.options.positionFixed && a.support.fixedPosition && this.element.addClass(this.options.classes.panelFixed);\n      }, _bindUpdateLayout: function _bindUpdateLayout() {\n        var a = this;a.element.on(\"updatelayout\", function () {\n          a._open && a._positionPanel();\n        });\n      }, _bindLinkListeners: function _bindLinkListeners() {\n        this._on(\"body\", { \"click a\": \"_handleClick\" });\n      }, _handleClick: function _handleClick(b) {\n        var d,\n            e = this.element.attr(\"id\");b.currentTarget.href.split(\"#\")[1] === e && e !== c && (b.preventDefault(), d = a(b.target), d.hasClass(\"ui-btn\") && (d.addClass(a.mobile.activeBtnClass), this.element.one(\"panelopen panelclose\", function () {\n          d.removeClass(a.mobile.activeBtnClass);\n        })), this.toggle());\n      }, _bindSwipeEvents: function _bindSwipeEvents() {\n        var a = this,\n            b = a._modal ? a.element.add(a._modal) : a.element;a.options.swipeClose && (\"left\" === a.options.position ? b.on(\"swipeleft.panel\", function () {\n          a.close();\n        }) : b.on(\"swiperight.panel\", function () {\n          a.close();\n        }));\n      }, _bindPageEvents: function _bindPageEvents() {\n        var a = this;this.document.on(\"panelbeforeopen\", function (b) {\n          a._open && b.target !== a.element[0] && a.close();\n        }).on(\"keyup.panel\", function (b) {\n          27 === b.keyCode && a._open && a.close();\n        }), this._parentPage || \"overlay\" === this.options.display || this._on(this.document, { pageshow: function pageshow() {\n            this._openedPage = null, this._getWrapper();\n          } }), a._parentPage ? this.document.on(\"pagehide\", \":jqmData(role='page')\", function () {\n          a._open && a.close(!0);\n        }) : this.document.on(\"pagebeforehide\", function () {\n          a._open && a.close(!0);\n        });\n      }, _open: !1, _pageContentOpenClasses: null, _modalOpenClasses: null, open: function open(b) {\n        if (!this._open) {\n          var c = this,\n              d = c.options,\n              e = function e() {\n            c._off(c.document, \"panelclose\"), c._page().jqmData(\"panel\", \"open\"), a.support.cssTransform3d && d.animate && \"overlay\" !== d.display && (c._wrapper.addClass(d.classes.animate), c._fixedToolbars().addClass(d.classes.animate)), !b && a.support.cssTransform3d && d.animate ? (c._wrapper || c.element).animationComplete(f, \"transition\") : setTimeout(f, 0), d.theme && \"overlay\" !== d.display && c._page().parent().addClass(d.classes.pageContainer + \"-themed \" + d.classes.pageContainer + \"-\" + d.theme), c.element.removeClass(d.classes.panelClosed).addClass(d.classes.panelOpen), c._positionPanel(!0), c._pageContentOpenClasses = c._getPosDisplayClasses(d.classes.pageContentPrefix), \"overlay\" !== d.display && (c._page().parent().addClass(d.classes.pageContainer), c._wrapper.addClass(c._pageContentOpenClasses), c._fixedToolbars().addClass(c._pageContentOpenClasses)), c._modalOpenClasses = c._getPosDisplayClasses(d.classes.modal) + \" \" + d.classes.modalOpen, c._modal && c._modal.addClass(c._modalOpenClasses).height(Math.max(c._modal.height(), c.document.height()));\n          },\n              f = function f() {\n            c._open && (\"overlay\" !== d.display && (c._wrapper.addClass(d.classes.pageContentPrefix + \"-open\"), c._fixedToolbars().addClass(d.classes.pageContentPrefix + \"-open\")), c._bindFixListener(), c._trigger(\"open\"), c._openedPage = c._page());\n          };c._trigger(\"beforeopen\"), \"open\" === c._page().jqmData(\"panel\") ? c._on(c.document, { panelclose: e }) : e(), c._open = !0;\n        }\n      }, close: function close(b) {\n        if (this._open) {\n          var c = this,\n              d = this.options,\n              e = function e() {\n            c.element.removeClass(d.classes.panelOpen), \"overlay\" !== d.display && (c._wrapper.removeClass(c._pageContentOpenClasses), c._fixedToolbars().removeClass(c._pageContentOpenClasses)), !b && a.support.cssTransform3d && d.animate ? (c._wrapper || c.element).animationComplete(f, \"transition\") : setTimeout(f, 0), c._modal && c._modal.removeClass(c._modalOpenClasses).height(\"\");\n          },\n              f = function f() {\n            d.theme && \"overlay\" !== d.display && c._page().parent().removeClass(d.classes.pageContainer + \"-themed \" + d.classes.pageContainer + \"-\" + d.theme), c.element.addClass(d.classes.panelClosed), \"overlay\" !== d.display && (c._page().parent().removeClass(d.classes.pageContainer), c._wrapper.removeClass(d.classes.pageContentPrefix + \"-open\"), c._fixedToolbars().removeClass(d.classes.pageContentPrefix + \"-open\")), a.support.cssTransform3d && d.animate && \"overlay\" !== d.display && (c._wrapper.removeClass(d.classes.animate), c._fixedToolbars().removeClass(d.classes.animate)), c._fixPanel(), c._unbindFixListener(), a.mobile.resetActivePageHeight(), c._page().jqmRemoveData(\"panel\"), c._trigger(\"close\"), c._openedPage = null;\n          };c._trigger(\"beforeclose\"), e(), c._open = !1;\n        }\n      }, toggle: function toggle() {\n        this[this._open ? \"close\" : \"open\"]();\n      }, _destroy: function _destroy() {\n        var b,\n            c = this.options,\n            d = a(\"body > :mobile-panel\").length + a.mobile.activePage.find(\":mobile-panel\").length > 1;\"overlay\" !== c.display && (b = a(\"body > :mobile-panel\").add(a.mobile.activePage.find(\":mobile-panel\")), 0 === b.not(\".ui-panel-display-overlay\").not(this.element).length && this._wrapper.children().unwrap(), this._open && (this._fixedToolbars().removeClass(c.classes.pageContentPrefix + \"-open\"), a.support.cssTransform3d && c.animate && this._fixedToolbars().removeClass(c.classes.animate), this._page().parent().removeClass(c.classes.pageContainer), c.theme && this._page().parent().removeClass(c.classes.pageContainer + \"-themed \" + c.classes.pageContainer + \"-\" + c.theme))), d || this.document.off(\"panelopen panelclose\"), this._open && this._page().jqmRemoveData(\"panel\"), this._panelInner.children().unwrap(), this.element.removeClass([this._getPanelClasses(), c.classes.panelOpen, c.classes.animate].join(\" \")).off(\"swipeleft.panel swiperight.panel\").off(\"panelbeforeopen\").off(\"panelhide\").off(\"keyup.panel\").off(\"updatelayout\"), this._modal && this._modal.remove();\n      } });\n  }(a), function (a, b) {\n    a.widget(\"mobile.table\", { options: { classes: { table: \"ui-table\" }, enhanced: !1 }, _create: function _create() {\n        this.options.enhanced || this.element.addClass(this.options.classes.table), a.extend(this, { headers: b, allHeaders: b }), this._refresh(!0);\n      }, _setHeaders: function _setHeaders() {\n        var a = this.element.find(\"thead tr\");this.headers = this.element.find(\"tr:eq(0)\").children(), this.allHeaders = this.headers.add(a.children());\n      }, refresh: function refresh() {\n        this._refresh();\n      }, rebuild: a.noop, _refresh: function _refresh() {\n        var b = this.element,\n            c = b.find(\"thead tr\");this._setHeaders(), c.each(function () {\n          var d = 0;a(this).children().each(function () {\n            var e,\n                f = parseInt(this.getAttribute(\"colspan\"), 10),\n                g = \":nth-child(\" + (d + 1) + \")\";if (this.setAttribute(\"data-\" + a.mobile.ns + \"colstart\", d + 1), f) for (e = 0; f - 1 > e; e++) {\n              d++, g += \", :nth-child(\" + (d + 1) + \")\";\n            }a(this).jqmData(\"cells\", b.find(\"tr\").not(c.eq(0)).not(this).children(g)), d++;\n          });\n        });\n      } });\n  }(a), function (a) {\n    a.widget(\"mobile.table\", a.mobile.table, { options: { mode: \"columntoggle\", columnBtnTheme: null, columnPopupTheme: null, columnBtnText: \"Columns...\", classes: a.extend(a.mobile.table.prototype.options.classes, { popup: \"ui-table-columntoggle-popup\", columnBtn: \"ui-table-columntoggle-btn\", priorityPrefix: \"ui-table-priority-\", columnToggleTable: \"ui-table-columntoggle\" }) }, _create: function _create() {\n        this._super(), \"columntoggle\" === this.options.mode && (a.extend(this, { _menu: null }), this.options.enhanced ? (this._menu = a(this.document[0].getElementById(this._id() + \"-popup\")).children().first(), this._addToggles(this._menu, !0)) : (this._menu = this._enhanceColToggle(), this.element.addClass(this.options.classes.columnToggleTable)), this._setupEvents(), this._setToggleState());\n      }, _id: function _id() {\n        return this.element.attr(\"id\") || this.widgetName + this.uuid;\n      }, _setupEvents: function _setupEvents() {\n        this._on(this.window, { throttledresize: \"_setToggleState\" }), this._on(this._menu, { \"change input\": \"_menuInputChange\" });\n      }, _addToggles: function _addToggles(b, c) {\n        var d,\n            e = 0,\n            f = this.options,\n            g = b.controlgroup(\"container\");c ? d = b.find(\"input\") : g.empty(), this.headers.not(\"td\").each(function () {\n          var b,\n              h,\n              i = a(this),\n              j = a.mobile.getAttribute(this, \"priority\");j && (h = i.add(i.jqmData(\"cells\")), h.addClass(f.classes.priorityPrefix + j), b = (c ? d.eq(e++) : a(\"<label><input type='checkbox' checked />\" + (i.children(\"abbr\").first().attr(\"title\") || i.text()) + \"</label>\").appendTo(g).children(0).checkboxradio({ theme: f.columnPopupTheme })).jqmData(\"header\", i).jqmData(\"cells\", h), i.jqmData(\"input\", b));\n        }), c || b.controlgroup(\"refresh\");\n      }, _menuInputChange: function _menuInputChange(b) {\n        var c = a(b.target),\n            d = c[0].checked;c.jqmData(\"cells\").toggleClass(\"ui-table-cell-hidden\", !d).toggleClass(\"ui-table-cell-visible\", d);\n      }, _unlockCells: function _unlockCells(a) {\n        a.removeClass(\"ui-table-cell-hidden ui-table-cell-visible\");\n      }, _enhanceColToggle: function _enhanceColToggle() {\n        var b,\n            c,\n            d,\n            e,\n            f = this.element,\n            g = this.options,\n            h = a.mobile.ns,\n            i = this.document[0].createDocumentFragment();return b = this._id() + \"-popup\", c = a(\"<a href='#\" + b + \"' class='\" + g.classes.columnBtn + \" ui-btn ui-btn-\" + (g.columnBtnTheme || \"a\") + \" ui-corner-all ui-shadow ui-mini' data-\" + h + \"rel='popup'>\" + g.columnBtnText + \"</a>\"), d = a(\"<div class='\" + g.classes.popup + \"' id='\" + b + \"'></div>\"), e = a(\"<fieldset></fieldset>\").controlgroup(), this._addToggles(e, !1), e.appendTo(d), i.appendChild(d[0]), i.appendChild(c[0]), f.before(i), d.popup(), e;\n      }, rebuild: function rebuild() {\n        this._super(), \"columntoggle\" === this.options.mode && this._refresh(!1);\n      }, _refresh: function _refresh(b) {\n        var c, d, e;if (this._super(b), !b && \"columntoggle\" === this.options.mode) for (c = this.headers, d = [], this._menu.find(\"input\").each(function () {\n          var b = a(this),\n              e = b.jqmData(\"header\"),\n              f = c.index(e[0]);f > -1 && !b.prop(\"checked\") && d.push(f);\n        }), this._unlockCells(this.element.find(\".ui-table-cell-hidden, .ui-table-cell-visible\")), this._addToggles(this._menu, b), e = d.length - 1; e > -1; e--) {\n          c.eq(d[e]).jqmData(\"input\").prop(\"checked\", !1).checkboxradio(\"refresh\").trigger(\"change\");\n        }\n      }, _setToggleState: function _setToggleState() {\n        this._menu.find(\"input\").each(function () {\n          var b = a(this);this.checked = \"table-cell\" === b.jqmData(\"cells\").eq(0).css(\"display\"), b.checkboxradio(\"refresh\");\n        });\n      }, _destroy: function _destroy() {\n        this._super();\n      } });\n  }(a), function (a) {\n    a.widget(\"mobile.table\", a.mobile.table, { options: { mode: \"reflow\", classes: a.extend(a.mobile.table.prototype.options.classes, { reflowTable: \"ui-table-reflow\", cellLabels: \"ui-table-cell-label\" }) }, _create: function _create() {\n        this._super(), \"reflow\" === this.options.mode && (this.options.enhanced || (this.element.addClass(this.options.classes.reflowTable), this._updateReflow()));\n      }, rebuild: function rebuild() {\n        this._super(), \"reflow\" === this.options.mode && this._refresh(!1);\n      }, _refresh: function _refresh(a) {\n        this._super(a), a || \"reflow\" !== this.options.mode || this._updateReflow();\n      }, _updateReflow: function _updateReflow() {\n        var b = this,\n            c = this.options;a(b.allHeaders.get().reverse()).each(function () {\n          var d,\n              e,\n              f = a(this).jqmData(\"cells\"),\n              g = a.mobile.getAttribute(this, \"colstart\"),\n              h = f.not(this).filter(\"thead th\").length && \" ui-table-cell-label-top\",\n              i = a(this).clone().contents();i.length > 0 && (h ? (d = parseInt(this.getAttribute(\"colspan\"), 10), e = \"\", d && (e = \"td:nth-child(\" + d + \"n + \" + g + \")\"), b._addLabels(f.filter(e), c.classes.cellLabels + h, i)) : b._addLabels(f, c.classes.cellLabels, i));\n        });\n      }, _addLabels: function _addLabels(b, c, d) {\n        1 === d.length && \"abbr\" === d[0].nodeName.toLowerCase() && (d = d.eq(0).attr(\"title\")), b.not(\":has(b.\" + c + \")\").prepend(a(\"<b class='\" + c + \"'></b>\").append(d));\n      } });\n  }(a), function (a, c) {\n    var d = function d(b, c) {\n      return -1 === (\"\" + (a.mobile.getAttribute(this, \"filtertext\") || a(this).text())).toLowerCase().indexOf(c);\n    };a.widget(\"mobile.filterable\", { initSelector: \":jqmData(filter='true')\", options: { filterReveal: !1, filterCallback: d, enhanced: !1, input: null, children: \"> li, > option, > optgroup option, > tbody tr, > .ui-controlgroup-controls > .ui-btn, > .ui-controlgroup-controls > .ui-checkbox, > .ui-controlgroup-controls > .ui-radio\" }, _create: function _create() {\n        var b = this.options;a.extend(this, { _search: null, _timer: 0 }), this._setInput(b.input), b.enhanced || this._filterItems((this._search && this._search.val() || \"\").toLowerCase());\n      }, _onKeyUp: function _onKeyUp() {\n        var c,\n            d,\n            e = this._search;if (e) {\n          if (c = e.val().toLowerCase(), d = a.mobile.getAttribute(e[0], \"lastval\") + \"\", d && d === c) return;this._timer && (b.clearTimeout(this._timer), this._timer = 0), this._timer = this._delay(function () {\n            return this._trigger(\"beforefilter\", null, { input: e }) === !1 ? !1 : (e[0].setAttribute(\"data-\" + a.mobile.ns + \"lastval\", c), this._filterItems(c), void (this._timer = 0));\n          }, 250);\n        }\n      }, _getFilterableItems: function _getFilterableItems() {\n        var b = this.element,\n            c = this.options.children,\n            d = c ? a.isFunction(c) ? c() : c.nodeName ? a(c) : c.jquery ? c : this.element.find(c) : { length: 0 };return 0 === d.length && (d = b.children()), d;\n      }, _filterItems: function _filterItems(b) {\n        var c,\n            e,\n            f,\n            g,\n            h = [],\n            i = [],\n            j = this.options,\n            k = this._getFilterableItems();if (null != b) for (e = j.filterCallback || d, f = k.length, c = 0; f > c; c++) {\n          g = e.call(k[c], c, b) ? i : h, g.push(k[c]);\n        }0 === i.length ? k[j.filterReveal && 0 === b.length ? \"addClass\" : \"removeClass\"](\"ui-screen-hidden\") : (a(i).addClass(\"ui-screen-hidden\"), a(h).removeClass(\"ui-screen-hidden\")), this._refreshChildWidget(), this._trigger(\"filter\", null, { items: k });\n      }, _refreshChildWidget: function _refreshChildWidget() {\n        var b,\n            c,\n            d = [\"collapsibleset\", \"selectmenu\", \"controlgroup\", \"listview\"];for (c = d.length - 1; c > -1; c--) {\n          b = d[c], a.mobile[b] && (b = this.element.data(\"mobile-\" + b), b && a.isFunction(b.refresh) && b.refresh());\n        }\n      }, _setInput: function _setInput(c) {\n        var d = this._search;this._timer && (b.clearTimeout(this._timer), this._timer = 0), d && (this._off(d, \"keyup change input\"), d = null), c && (d = c.jquery ? c : c.nodeName ? a(c) : this.document.find(c), this._on(d, { keydown: \"_onKeyDown\", keypress: \"_onKeyPress\", keyup: \"_onKeyUp\", change: \"_onKeyUp\", input: \"_onKeyUp\" })), this._search = d;\n      }, _onKeyDown: function _onKeyDown(b) {\n        b.keyCode === a.ui.keyCode.ENTER && (b.preventDefault(), this._preventKeyPress = !0);\n      }, _onKeyPress: function _onKeyPress(a) {\n        this._preventKeyPress && (a.preventDefault(), this._preventKeyPress = !1);\n      }, _setOptions: function _setOptions(a) {\n        var b = !(a.filterReveal === c && a.filterCallback === c && a.children === c);this._super(a), a.input !== c && (this._setInput(a.input), b = !0), b && this.refresh();\n      }, _destroy: function _destroy() {\n        var a = this.options,\n            b = this._getFilterableItems();a.enhanced ? b.toggleClass(\"ui-screen-hidden\", a.filterReveal) : b.removeClass(\"ui-screen-hidden\");\n      }, refresh: function refresh() {\n        this._timer && (b.clearTimeout(this._timer), this._timer = 0), this._filterItems((this._search && this._search.val() || \"\").toLowerCase());\n      } });\n  }(a), function (a, b) {\n    var c = function c(a, b) {\n      return function (c) {\n        b.call(this, c), a._syncTextInputOptions(c);\n      };\n    },\n        d = /(^|\\s)ui-li-divider(\\s|$)/,\n        e = a.mobile.filterable.prototype.options.filterCallback;a.mobile.filterable.prototype.options.filterCallback = function (a, b) {\n      return !this.className.match(d) && e.call(this, a, b);\n    }, a.widget(\"mobile.filterable\", a.mobile.filterable, { options: { filterPlaceholder: \"Filter items...\", filterTheme: null }, _create: function _create() {\n        var b,\n            c,\n            d = this.element,\n            e = [\"collapsibleset\", \"selectmenu\", \"controlgroup\", \"listview\"],\n            f = {};for (this._super(), a.extend(this, { _widget: null }), b = e.length - 1; b > -1; b--) {\n          if (c = e[b], a.mobile[c]) {\n            if (this._setWidget(d.data(\"mobile-\" + c))) break;f[c + \"create\"] = \"_handleCreate\";\n          }\n        }this._widget || this._on(d, f);\n      }, _handleCreate: function _handleCreate(a) {\n        this._setWidget(this.element.data(\"mobile-\" + a.type.substring(0, a.type.length - 6)));\n      }, _trigger: function _trigger(a, b, c) {\n        return this._widget && \"mobile-listview\" === this._widget.widgetFullName && \"beforefilter\" === a && this._widget._trigger(\"beforefilter\", b, c), this._super(a, b, c);\n      }, _setWidget: function _setWidget(a) {\n        return !this._widget && a && (this._widget = a, this._widget._setOptions = c(this, this._widget._setOptions)), this._widget && (this._syncTextInputOptions(this._widget.options), \"listview\" === this._widget.widgetName && (this._widget.options.hideDividers = !0, this._widget.element.listview(\"refresh\"))), !!this._widget;\n      }, _isSearchInternal: function _isSearchInternal() {\n        return this._search && this._search.jqmData(\"ui-filterable-\" + this.uuid + \"-internal\");\n      }, _setInput: function _setInput(b) {\n        var c = this.options,\n            d = !0,\n            e = {};if (!b) {\n          if (this._isSearchInternal()) return;d = !1, b = a(\"<input data-\" + a.mobile.ns + \"type='search' placeholder='\" + c.filterPlaceholder + \"'></input>\").jqmData(\"ui-filterable-\" + this.uuid + \"-internal\", !0), a(\"<form class='ui-filterable'></form>\").append(b).submit(function (a) {\n            a.preventDefault(), b.blur();\n          }).insertBefore(this.element), a.mobile.textinput && (null != this.options.filterTheme && (e.theme = c.filterTheme), b.textinput(e));\n        }this._super(b), this._isSearchInternal() && d && this._search.attr(\"placeholder\", this.options.filterPlaceholder);\n      }, _setOptions: function _setOptions(c) {\n        var d = this._super(c);return c.filterPlaceholder !== b && this._isSearchInternal() && this._search.attr(\"placeholder\", c.filterPlaceholder), c.filterTheme !== b && this._search && a.mobile.textinput && this._search.textinput(\"option\", \"theme\", c.filterTheme), d;\n      }, _refreshChildWidget: function _refreshChildWidget() {\n        this._refreshingChildWidget = !0, this._superApply(arguments), this._refreshingChildWidget = !1;\n      }, refresh: function refresh() {\n        this._refreshingChildWidget || this._superApply(arguments);\n      }, _destroy: function _destroy() {\n        this._isSearchInternal() && this._search.remove(), this._super();\n      }, _syncTextInputOptions: function _syncTextInputOptions(c) {\n        var d,\n            e = {};if (this._isSearchInternal() && a.mobile.textinput) {\n          for (d in a.mobile.textinput.prototype.options) {\n            c[d] !== b && (e[d] = \"theme\" === d && null != this.options.filterTheme ? this.options.filterTheme : c[d]);\n          }this._search.textinput(\"option\", e);\n        }\n      } }), a.widget(\"mobile.listview\", a.mobile.listview, { options: { filter: !1 }, _create: function _create() {\n        return this.options.filter !== !0 || this.element.data(\"mobile-filterable\") || this.element.filterable(), this._super();\n      }, refresh: function refresh() {\n        var a;this._superApply(arguments), this.options.filter === !0 && (a = this.element.data(\"mobile-filterable\"), a && a.refresh());\n      } });\n  }(a), function (a, b) {\n    function c() {\n      return ++e;\n    }function d(a) {\n      return a.hash.length > 1 && decodeURIComponent(a.href.replace(f, \"\")) === decodeURIComponent(location.href.replace(f, \"\"));\n    }var e = 0,\n        f = /#.*$/;a.widget(\"ui.tabs\", { version: \"fadf2b312a05040436451c64bbfaf4814bc62c56\", delay: 300, options: { active: null, collapsible: !1, event: \"click\", heightStyle: \"content\", hide: null, show: null, activate: null, beforeActivate: null, beforeLoad: null, load: null }, _create: function _create() {\n        var b = this,\n            c = this.options;this.running = !1, this.element.addClass(\"ui-tabs ui-widget ui-widget-content ui-corner-all\").toggleClass(\"ui-tabs-collapsible\", c.collapsible).delegate(\".ui-tabs-nav > li\", \"mousedown\" + this.eventNamespace, function (b) {\n          a(this).is(\".ui-state-disabled\") && b.preventDefault();\n        }).delegate(\".ui-tabs-anchor\", \"focus\" + this.eventNamespace, function () {\n          a(this).closest(\"li\").is(\".ui-state-disabled\") && this.blur();\n        }), this._processTabs(), c.active = this._initialActive(), a.isArray(c.disabled) && (c.disabled = a.unique(c.disabled.concat(a.map(this.tabs.filter(\".ui-state-disabled\"), function (a) {\n          return b.tabs.index(a);\n        }))).sort()), this.active = this.options.active !== !1 && this.anchors.length ? this._findActive(c.active) : a(), this._refresh(), this.active.length && this.load(c.active);\n      }, _initialActive: function _initialActive() {\n        var b = this.options.active,\n            c = this.options.collapsible,\n            d = location.hash.substring(1);return null === b && (d && this.tabs.each(function (c, e) {\n          return a(e).attr(\"aria-controls\") === d ? (b = c, !1) : void 0;\n        }), null === b && (b = this.tabs.index(this.tabs.filter(\".ui-tabs-active\"))), (null === b || -1 === b) && (b = this.tabs.length ? 0 : !1)), b !== !1 && (b = this.tabs.index(this.tabs.eq(b)), -1 === b && (b = c ? !1 : 0)), !c && b === !1 && this.anchors.length && (b = 0), b;\n      }, _getCreateEventData: function _getCreateEventData() {\n        return { tab: this.active, panel: this.active.length ? this._getPanelForTab(this.active) : a() };\n      }, _tabKeydown: function _tabKeydown(b) {\n        var c = a(this.document[0].activeElement).closest(\"li\"),\n            d = this.tabs.index(c),\n            e = !0;if (!this._handlePageNav(b)) {\n          switch (b.keyCode) {case a.ui.keyCode.RIGHT:case a.ui.keyCode.DOWN:\n              d++;break;case a.ui.keyCode.UP:case a.ui.keyCode.LEFT:\n              e = !1, d--;break;case a.ui.keyCode.END:\n              d = this.anchors.length - 1;break;case a.ui.keyCode.HOME:\n              d = 0;break;case a.ui.keyCode.SPACE:\n              return b.preventDefault(), clearTimeout(this.activating), void this._activate(d);case a.ui.keyCode.ENTER:\n              return b.preventDefault(), clearTimeout(this.activating), void this._activate(d === this.options.active ? !1 : d);default:\n              return;}b.preventDefault(), clearTimeout(this.activating), d = this._focusNextTab(d, e), b.ctrlKey || (c.attr(\"aria-selected\", \"false\"), this.tabs.eq(d).attr(\"aria-selected\", \"true\"), this.activating = this._delay(function () {\n            this.option(\"active\", d);\n          }, this.delay));\n        }\n      }, _panelKeydown: function _panelKeydown(b) {\n        this._handlePageNav(b) || b.ctrlKey && b.keyCode === a.ui.keyCode.UP && (b.preventDefault(), this.active.focus());\n      }, _handlePageNav: function _handlePageNav(b) {\n        return b.altKey && b.keyCode === a.ui.keyCode.PAGE_UP ? (this._activate(this._focusNextTab(this.options.active - 1, !1)), !0) : b.altKey && b.keyCode === a.ui.keyCode.PAGE_DOWN ? (this._activate(this._focusNextTab(this.options.active + 1, !0)), !0) : void 0;\n      }, _findNextTab: function _findNextTab(b, c) {\n        function d() {\n          return b > e && (b = 0), 0 > b && (b = e), b;\n        }for (var e = this.tabs.length - 1; -1 !== a.inArray(d(), this.options.disabled);) {\n          b = c ? b + 1 : b - 1;\n        }return b;\n      }, _focusNextTab: function _focusNextTab(a, b) {\n        return a = this._findNextTab(a, b), this.tabs.eq(a).focus(), a;\n      }, _setOption: function _setOption(a, b) {\n        return \"active\" === a ? void this._activate(b) : \"disabled\" === a ? void this._setupDisabled(b) : (this._super(a, b), \"collapsible\" === a && (this.element.toggleClass(\"ui-tabs-collapsible\", b), b || this.options.active !== !1 || this._activate(0)), \"event\" === a && this._setupEvents(b), void (\"heightStyle\" === a && this._setupHeightStyle(b)));\n      }, _tabId: function _tabId(a) {\n        return a.attr(\"aria-controls\") || \"ui-tabs-\" + c();\n      }, _sanitizeSelector: function _sanitizeSelector(a) {\n        return a ? a.replace(/[!\"$%&'()*+,.\\/:;<=>?@\\[\\]\\^`{|}~]/g, \"\\\\$&\") : \"\";\n      }, refresh: function refresh() {\n        var b = this.options,\n            c = this.tablist.children(\":has(a[href])\");b.disabled = a.map(c.filter(\".ui-state-disabled\"), function (a) {\n          return c.index(a);\n        }), this._processTabs(), b.active !== !1 && this.anchors.length ? this.active.length && !a.contains(this.tablist[0], this.active[0]) ? this.tabs.length === b.disabled.length ? (b.active = !1, this.active = a()) : this._activate(this._findNextTab(Math.max(0, b.active - 1), !1)) : b.active = this.tabs.index(this.active) : (b.active = !1, this.active = a()), this._refresh();\n      }, _refresh: function _refresh() {\n        this._setupDisabled(this.options.disabled), this._setupEvents(this.options.event), this._setupHeightStyle(this.options.heightStyle), this.tabs.not(this.active).attr({ \"aria-selected\": \"false\", tabIndex: -1 }), this.panels.not(this._getPanelForTab(this.active)).hide().attr({ \"aria-expanded\": \"false\", \"aria-hidden\": \"true\" }), this.active.length ? (this.active.addClass(\"ui-tabs-active ui-state-active\").attr({ \"aria-selected\": \"true\", tabIndex: 0 }), this._getPanelForTab(this.active).show().attr({ \"aria-expanded\": \"true\", \"aria-hidden\": \"false\" })) : this.tabs.eq(0).attr(\"tabIndex\", 0);\n      }, _processTabs: function _processTabs() {\n        var b = this;this.tablist = this._getList().addClass(\"ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all\").attr(\"role\", \"tablist\"), this.tabs = this.tablist.find(\"> li:has(a[href])\").addClass(\"ui-state-default ui-corner-top\").attr({ role: \"tab\", tabIndex: -1 }), this.anchors = this.tabs.map(function () {\n          return a(\"a\", this)[0];\n        }).addClass(\"ui-tabs-anchor\").attr({ role: \"presentation\", tabIndex: -1 }), this.panels = a(), this.anchors.each(function (c, e) {\n          var f,\n              g,\n              h,\n              i = a(e).uniqueId().attr(\"id\"),\n              j = a(e).closest(\"li\"),\n              k = j.attr(\"aria-controls\");d(e) ? (f = e.hash, g = b.element.find(b._sanitizeSelector(f))) : (h = b._tabId(j), f = \"#\" + h, g = b.element.find(f), g.length || (g = b._createPanel(h), g.insertAfter(b.panels[c - 1] || b.tablist)), g.attr(\"aria-live\", \"polite\")), g.length && (b.panels = b.panels.add(g)), k && j.data(\"ui-tabs-aria-controls\", k), j.attr({ \"aria-controls\": f.substring(1), \"aria-labelledby\": i }), g.attr(\"aria-labelledby\", i);\n        }), this.panels.addClass(\"ui-tabs-panel ui-widget-content ui-corner-bottom\").attr(\"role\", \"tabpanel\");\n      }, _getList: function _getList() {\n        return this.element.find(\"ol,ul\").eq(0);\n      }, _createPanel: function _createPanel(b) {\n        return a(\"<div>\").attr(\"id\", b).addClass(\"ui-tabs-panel ui-widget-content ui-corner-bottom\").data(\"ui-tabs-destroy\", !0);\n      }, _setupDisabled: function _setupDisabled(b) {\n        a.isArray(b) && (b.length ? b.length === this.anchors.length && (b = !0) : b = !1);for (var c, d = 0; c = this.tabs[d]; d++) {\n          b === !0 || -1 !== a.inArray(d, b) ? a(c).addClass(\"ui-state-disabled\").attr(\"aria-disabled\", \"true\") : a(c).removeClass(\"ui-state-disabled\").removeAttr(\"aria-disabled\");\n        }this.options.disabled = b;\n      }, _setupEvents: function _setupEvents(b) {\n        var c = { click: function click(a) {\n            a.preventDefault();\n          } };b && a.each(b.split(\" \"), function (a, b) {\n          c[b] = \"_eventHandler\";\n        }), this._off(this.anchors.add(this.tabs).add(this.panels)), this._on(this.anchors, c), this._on(this.tabs, { keydown: \"_tabKeydown\" }), this._on(this.panels, { keydown: \"_panelKeydown\" }), this._focusable(this.tabs), this._hoverable(this.tabs);\n      }, _setupHeightStyle: function _setupHeightStyle(b) {\n        var c,\n            d = this.element.parent();\"fill\" === b ? (c = d.height(), c -= this.element.outerHeight() - this.element.height(), this.element.siblings(\":visible\").each(function () {\n          var b = a(this),\n              d = b.css(\"position\");\"absolute\" !== d && \"fixed\" !== d && (c -= b.outerHeight(!0));\n        }), this.element.children().not(this.panels).each(function () {\n          c -= a(this).outerHeight(!0);\n        }), this.panels.each(function () {\n          a(this).height(Math.max(0, c - a(this).innerHeight() + a(this).height()));\n        }).css(\"overflow\", \"auto\")) : \"auto\" === b && (c = 0, this.panels.each(function () {\n          c = Math.max(c, a(this).height(\"\").height());\n        }).height(c));\n      }, _eventHandler: function _eventHandler(b) {\n        var c = this.options,\n            d = this.active,\n            e = a(b.currentTarget),\n            f = e.closest(\"li\"),\n            g = f[0] === d[0],\n            h = g && c.collapsible,\n            i = h ? a() : this._getPanelForTab(f),\n            j = d.length ? this._getPanelForTab(d) : a(),\n            k = { oldTab: d, oldPanel: j, newTab: h ? a() : f, newPanel: i };b.preventDefault(), f.hasClass(\"ui-state-disabled\") || f.hasClass(\"ui-tabs-loading\") || this.running || g && !c.collapsible || this._trigger(\"beforeActivate\", b, k) === !1 || (c.active = h ? !1 : this.tabs.index(f), this.active = g ? a() : f, this.xhr && this.xhr.abort(), j.length || i.length || a.error(\"jQuery UI Tabs: Mismatching fragment identifier.\"), i.length && this.load(this.tabs.index(f), b), this._toggle(b, k));\n      }, _toggle: function _toggle(b, c) {\n        function d() {\n          f.running = !1, f._trigger(\"activate\", b, c);\n        }function e() {\n          c.newTab.closest(\"li\").addClass(\"ui-tabs-active ui-state-active\"), g.length && f.options.show ? f._show(g, f.options.show, d) : (g.show(), d());\n        }var f = this,\n            g = c.newPanel,\n            h = c.oldPanel;this.running = !0, h.length && this.options.hide ? this._hide(h, this.options.hide, function () {\n          c.oldTab.closest(\"li\").removeClass(\"ui-tabs-active ui-state-active\"), e();\n        }) : (c.oldTab.closest(\"li\").removeClass(\"ui-tabs-active ui-state-active\"), h.hide(), e()), h.attr({ \"aria-expanded\": \"false\", \"aria-hidden\": \"true\" }), c.oldTab.attr(\"aria-selected\", \"false\"), g.length && h.length ? c.oldTab.attr(\"tabIndex\", -1) : g.length && this.tabs.filter(function () {\n          return 0 === a(this).attr(\"tabIndex\");\n        }).attr(\"tabIndex\", -1), g.attr({ \"aria-expanded\": \"true\", \"aria-hidden\": \"false\" }), c.newTab.attr({ \"aria-selected\": \"true\", tabIndex: 0 });\n      }, _activate: function _activate(b) {\n        var c,\n            d = this._findActive(b);d[0] !== this.active[0] && (d.length || (d = this.active), c = d.find(\".ui-tabs-anchor\")[0], this._eventHandler({ target: c, currentTarget: c, preventDefault: a.noop }));\n      }, _findActive: function _findActive(b) {\n        return b === !1 ? a() : this.tabs.eq(b);\n      }, _getIndex: function _getIndex(a) {\n        return \"string\" == typeof a && (a = this.anchors.index(this.anchors.filter(\"[href$='\" + a + \"']\"))), a;\n      }, _destroy: function _destroy() {\n        this.xhr && this.xhr.abort(), this.element.removeClass(\"ui-tabs ui-widget ui-widget-content ui-corner-all ui-tabs-collapsible\"), this.tablist.removeClass(\"ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all\").removeAttr(\"role\"), this.anchors.removeClass(\"ui-tabs-anchor\").removeAttr(\"role\").removeAttr(\"tabIndex\").removeUniqueId(), this.tabs.add(this.panels).each(function () {\n          a.data(this, \"ui-tabs-destroy\") ? a(this).remove() : a(this).removeClass(\"ui-state-default ui-state-active ui-state-disabled ui-corner-top ui-corner-bottom ui-widget-content ui-tabs-active ui-tabs-panel\").removeAttr(\"tabIndex\").removeAttr(\"aria-live\").removeAttr(\"aria-busy\").removeAttr(\"aria-selected\").removeAttr(\"aria-labelledby\").removeAttr(\"aria-hidden\").removeAttr(\"aria-expanded\").removeAttr(\"role\");\n        }), this.tabs.each(function () {\n          var b = a(this),\n              c = b.data(\"ui-tabs-aria-controls\");c ? b.attr(\"aria-controls\", c).removeData(\"ui-tabs-aria-controls\") : b.removeAttr(\"aria-controls\");\n        }), this.panels.show(), \"content\" !== this.options.heightStyle && this.panels.css(\"height\", \"\");\n      }, enable: function enable(c) {\n        var d = this.options.disabled;d !== !1 && (c === b ? d = !1 : (c = this._getIndex(c), d = a.isArray(d) ? a.map(d, function (a) {\n          return a !== c ? a : null;\n        }) : a.map(this.tabs, function (a, b) {\n          return b !== c ? b : null;\n        })), this._setupDisabled(d));\n      }, disable: function disable(c) {\n        var d = this.options.disabled;if (d !== !0) {\n          if (c === b) d = !0;else {\n            if (c = this._getIndex(c), -1 !== a.inArray(c, d)) return;d = a.isArray(d) ? a.merge([c], d).sort() : [c];\n          }this._setupDisabled(d);\n        }\n      }, load: function load(b, c) {\n        b = this._getIndex(b);var e = this,\n            f = this.tabs.eq(b),\n            g = f.find(\".ui-tabs-anchor\"),\n            h = this._getPanelForTab(f),\n            i = { tab: f, panel: h };d(g[0]) || (this.xhr = a.ajax(this._ajaxSettings(g, c, i)), this.xhr && \"canceled\" !== this.xhr.statusText && (f.addClass(\"ui-tabs-loading\"), h.attr(\"aria-busy\", \"true\"), this.xhr.success(function (a) {\n          setTimeout(function () {\n            h.html(a), e._trigger(\"load\", c, i);\n          }, 1);\n        }).complete(function (a, b) {\n          setTimeout(function () {\n            \"abort\" === b && e.panels.stop(!1, !0), f.removeClass(\"ui-tabs-loading\"), h.removeAttr(\"aria-busy\"), a === e.xhr && delete e.xhr;\n          }, 1);\n        })));\n      }, _ajaxSettings: function _ajaxSettings(b, c, d) {\n        var e = this;return { url: b.attr(\"href\"), beforeSend: function beforeSend(b, f) {\n            return e._trigger(\"beforeLoad\", c, a.extend({ jqXHR: b, ajaxSettings: f }, d));\n          } };\n      }, _getPanelForTab: function _getPanelForTab(b) {\n        var c = a(b).attr(\"aria-controls\");return this.element.find(this._sanitizeSelector(\"#\" + c));\n      } });\n  }(a), function () {}(a), function (a, b) {\n    function c(a) {\n      e = a.originalEvent, i = e.accelerationIncludingGravity, f = Math.abs(i.x), g = Math.abs(i.y), h = Math.abs(i.z), !b.orientation && (f > 7 || (h > 6 && 8 > g || 8 > h && g > 6) && f > 5) ? d.enabled && d.disable() : d.enabled || d.enable();\n    }a.mobile.iosorientationfixEnabled = !0;var d,\n        e,\n        f,\n        g,\n        h,\n        i,\n        j = navigator.userAgent;return (/iPhone|iPad|iPod/.test(navigator.platform) && /OS [1-5]_[0-9_]* like Mac OS X/i.test(j) && j.indexOf(\"AppleWebKit\") > -1 ? (d = a.mobile.zoom, void a.mobile.document.on(\"mobileinit\", function () {\n        a.mobile.iosorientationfixEnabled && a.mobile.window.bind(\"orientationchange.iosorientationfix\", d.enable).bind(\"devicemotion.iosorientationfix\", c);\n      })) : void (a.mobile.iosorientationfixEnabled = !1)\n    );\n  }(a, this), function (a, b, d) {\n    function e() {\n      f.removeClass(\"ui-mobile-rendering\");\n    }var f = a(\"html\"),\n        g = a.mobile.window;a(b.document).trigger(\"mobileinit\"), a.mobile.gradeA() && (a.mobile.ajaxBlacklist && (a.mobile.ajaxEnabled = !1), f.addClass(\"ui-mobile ui-mobile-rendering\"), setTimeout(e, 5e3), a.extend(a.mobile, { initializePage: function initializePage() {\n        var b = a.mobile.path,\n            f = a(\":jqmData(role='page'), :jqmData(role='dialog')\"),\n            h = b.stripHash(b.stripQueryParams(b.parseLocation().hash)),\n            i = a.mobile.path.parseLocation(),\n            j = h ? c.getElementById(h) : d;f.length || (f = a(\"body\").wrapInner(\"<div data-\" + a.mobile.ns + \"role='page'></div>\").children(0)), f.each(function () {\n          var c = a(this);c[0].getAttribute(\"data-\" + a.mobile.ns + \"url\") || c.attr(\"data-\" + a.mobile.ns + \"url\", c.attr(\"id\") || b.convertUrlToDataUrl(i.pathname + i.search));\n        }), a.mobile.firstPage = f.first(), a.mobile.pageContainer = a.mobile.firstPage.parent().addClass(\"ui-mobile-viewport\").pagecontainer(), a.mobile.navreadyDeferred.resolve(), g.trigger(\"pagecontainercreate\"), a.mobile.loading(\"show\"), e(), a.mobile.hashListeningEnabled && a.mobile.path.isHashValid(location.hash) && (a(j).is(\":jqmData(role='page')\") || a.mobile.path.isPath(h) || h === a.mobile.dialogHashKey) ? a.event.special.navigate.isPushStateEnabled() ? (a.mobile.navigate.history.stack = [], a.mobile.navigate(a.mobile.path.isPath(location.hash) ? location.hash : location.href)) : g.trigger(\"hashchange\", [!0]) : (a.event.special.navigate.isPushStateEnabled() && a.mobile.navigate.navigator.squash(b.parseLocation().href), a.mobile.changePage(a.mobile.firstPage, { transition: \"none\", reverse: !0, changeHash: !1, fromHashChange: !0 }));\n      } }), a(function () {\n      a.support.inlineSVG(), a.mobile.hideUrlBar && b.scrollTo(0, 1), a.mobile.defaultHomeScroll = a.support.scrollTop && 1 !== a.mobile.window.scrollTop() ? 1 : 0, a.mobile.autoInitializePage && a.mobile.initializePage(), a.mobile.hideUrlBar && g.load(a.mobile.silentScroll), a.support.cssPointerEvents || a.mobile.document.delegate(\".ui-state-disabled,.ui-disabled\", \"vclick\", function (a) {\n        a.preventDefault(), a.stopImmediatePropagation();\n      });\n    }));\n  }(a, this);\n});\n//# sourceMappingURL=jquery.mobile-1.4.5.min.map"

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./node_modules/babel-loader/lib/index.js??ref--0-0!./assets/js/jquery.qrcode-0.12.0.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/raw-loader!./node_modules/babel-loader/lib??ref--0-0!./assets/js/jquery.qrcode-0.12.0.js ***!
  \***************************************************************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports) {

module.exports = "var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/* jQuery.qrcode 0.12.0 - http://larsjung.de/jquery-qrcode/ - uses //github.com/kazuhikoarase/qrcode-generator (MIT) */\n(function (qrcode) {\n  'use strict';\n\n  var $ = jQuery;\n\n  // Wrapper for the original QR code generator.\n  function QRCode(text, level, version, quiet) {\n\n    var qr = qrcode(version, level);\n    qr.addData(text);\n    qr.make();\n\n    quiet = quiet || 0;\n\n    var qrModuleCount = qr.getModuleCount();\n    var quietModuleCount = qr.getModuleCount() + 2 * quiet;\n\n    function isDark(row, col) {\n\n      row -= quiet;\n      col -= quiet;\n\n      if (row < 0 || row >= qrModuleCount || col < 0 || col >= qrModuleCount) {\n        return false;\n      }\n\n      return qr.isDark(row, col);\n    }\n\n    var addBlank = function addBlank(l, t, r, b) {\n\n      var prevIsDark = this.isDark;\n      var moduleSize = 1 / quietModuleCount;\n\n      this.isDark = function (row, col) {\n\n        var ml = col * moduleSize;\n        var mt = row * moduleSize;\n        var mr = ml + moduleSize;\n        var mb = mt + moduleSize;\n\n        return prevIsDark(row, col) && (l > mr || ml > r || t > mb || mt > b);\n      };\n    };\n\n    this.text = text;\n    this.level = level;\n    this.version = version;\n    this.moduleCount = quietModuleCount;\n    this.isDark = isDark;\n    this.addBlank = addBlank;\n  }\n\n  // Check if canvas is available in the browser (as Modernizr does)\n  var hasCanvas = function () {\n\n    var elem = document.createElement('canvas');\n    return Boolean(elem.getContext && elem.getContext('2d'));\n  }();\n  var hasArcTo = Object.prototype.toString.call(window.opera) !== '[object Opera]';\n\n  // Returns a minimal QR code for the given text starting with version `minVersion`.\n  // Returns `undefined` if `text` is too long to be encoded in `maxVersion`.\n  function createQRCode(text, level, minVersion, maxVersion, quiet) {\n\n    minVersion = Math.max(1, minVersion || 1);\n    maxVersion = Math.min(40, maxVersion || 40);\n    for (var version = minVersion; version <= maxVersion; version += 1) {\n      try {\n        return new QRCode(text, level, version, quiet);\n      } catch (err) {}\n    }\n  }\n\n  function drawBackgroundLabel(qr, context, settings) {\n\n    var size = settings.size;\n    var font = 'bold ' + settings.mSize * size + 'px ' + settings.fontname;\n    var ctx = $('<canvas/>')[0].getContext('2d');\n\n    ctx.font = font;\n\n    var w = ctx.measureText(settings.label).width;\n    var sh = settings.mSize;\n    var sw = w / size;\n    var sl = (1 - sw) * settings.mPosX;\n    var st = (1 - sh) * settings.mPosY;\n    var sr = sl + sw;\n    var sb = st + sh;\n    var pad = 0.01;\n\n    if (settings.mode === 1) {\n      // Strip\n      qr.addBlank(0, st - pad, size, sb + pad);\n    } else {\n      // Box\n      qr.addBlank(sl - pad, st - pad, sr + pad, sb + pad);\n    }\n\n    context.fillStyle = settings.fontcolor;\n    context.font = font;\n    context.fillText(settings.label, sl * size, st * size + 0.75 * settings.mSize * size);\n  }\n\n  function drawBackgroundImage(qr, context, settings) {\n\n    var size = settings.size;\n    var w = settings.image.naturalWidth || 1;\n    var h = settings.image.naturalHeight || 1;\n    var sh = settings.mSize;\n    var sw = sh * w / h;\n    var sl = (1 - sw) * settings.mPosX;\n    var st = (1 - sh) * settings.mPosY;\n    var sr = sl + sw;\n    var sb = st + sh;\n    var pad = 0.01;\n\n    if (settings.mode === 3) {\n      // Strip\n      qr.addBlank(0, st - pad, size, sb + pad);\n    } else {\n      // Box\n      qr.addBlank(sl - pad, st - pad, sr + pad, sb + pad);\n    }\n\n    context.drawImage(settings.image, sl * size, st * size, sw * size, sh * size);\n  }\n\n  function drawBackground(qr, context, settings) {\n\n    if ($(settings.background).is('img')) {\n      context.drawImage(settings.background, 0, 0, settings.size, settings.size);\n    } else if (settings.background) {\n      context.fillStyle = settings.background;\n      context.fillRect(settings.left, settings.top, settings.size, settings.size);\n    }\n\n    var mode = settings.mode;\n    if (mode === 1 || mode === 2) {\n      drawBackgroundLabel(qr, context, settings);\n    } else if (mode === 3 || mode === 4) {\n      drawBackgroundImage(qr, context, settings);\n    }\n  }\n\n  function drawModuleDefault(qr, context, settings, left, top, width, row, col) {\n\n    if (qr.isDark(row, col)) {\n      context.rect(left, top, width, width);\n    }\n  }\n\n  function drawModuleRoundedDark(ctx, l, t, r, b, rad, nw, ne, se, sw) {\n\n    if (nw) {\n      ctx.moveTo(l + rad, t);\n    } else {\n      ctx.moveTo(l, t);\n    }\n\n    if (ne) {\n      ctx.lineTo(r - rad, t);\n      ctx.arcTo(r, t, r, b, rad);\n    } else {\n      ctx.lineTo(r, t);\n    }\n\n    if (se) {\n      ctx.lineTo(r, b - rad);\n      ctx.arcTo(r, b, l, b, rad);\n    } else {\n      ctx.lineTo(r, b);\n    }\n\n    if (sw) {\n      ctx.lineTo(l + rad, b);\n      ctx.arcTo(l, b, l, t, rad);\n    } else {\n      ctx.lineTo(l, b);\n    }\n\n    if (nw) {\n      ctx.lineTo(l, t + rad);\n      ctx.arcTo(l, t, r, t, rad);\n    } else {\n      ctx.lineTo(l, t);\n    }\n  }\n\n  function drawModuleRoundendLight(ctx, l, t, r, b, rad, nw, ne, se, sw) {\n\n    if (nw) {\n      ctx.moveTo(l + rad, t);\n      ctx.lineTo(l, t);\n      ctx.lineTo(l, t + rad);\n      ctx.arcTo(l, t, l + rad, t, rad);\n    }\n\n    if (ne) {\n      ctx.moveTo(r - rad, t);\n      ctx.lineTo(r, t);\n      ctx.lineTo(r, t + rad);\n      ctx.arcTo(r, t, r - rad, t, rad);\n    }\n\n    if (se) {\n      ctx.moveTo(r - rad, b);\n      ctx.lineTo(r, b);\n      ctx.lineTo(r, b - rad);\n      ctx.arcTo(r, b, r - rad, b, rad);\n    }\n\n    if (sw) {\n      ctx.moveTo(l + rad, b);\n      ctx.lineTo(l, b);\n      ctx.lineTo(l, b - rad);\n      ctx.arcTo(l, b, l + rad, b, rad);\n    }\n  }\n\n  function drawModuleRounded(qr, context, settings, left, top, width, row, col) {\n\n    var isDark = qr.isDark;\n    var right = left + width;\n    var bottom = top + width;\n    var radius = settings.radius * width;\n    var rowT = row - 1;\n    var rowB = row + 1;\n    var colL = col - 1;\n    var colR = col + 1;\n    var center = isDark(row, col);\n    var northwest = isDark(rowT, colL);\n    var north = isDark(rowT, col);\n    var northeast = isDark(rowT, colR);\n    var east = isDark(row, colR);\n    var southeast = isDark(rowB, colR);\n    var south = isDark(rowB, col);\n    var southwest = isDark(rowB, colL);\n    var west = isDark(row, colL);\n\n    if (center) {\n      drawModuleRoundedDark(context, left, top, right, bottom, radius, !north && !west, !north && !east, !south && !east, !south && !west);\n    } else {\n      drawModuleRoundendLight(context, left, top, right, bottom, radius, north && west && northwest, north && east && northeast, south && east && southeast, south && west && southwest);\n    }\n  }\n\n  function drawModules(qr, context, settings) {\n\n    var moduleCount = qr.moduleCount;\n    var moduleSize = settings.size / moduleCount;\n    var fn = drawModuleDefault;\n    var row;\n    var col;\n\n    if (hasArcTo && settings.radius > 0 && settings.radius <= 0.5) {\n      fn = drawModuleRounded;\n    }\n\n    context.beginPath();\n    for (row = 0; row < moduleCount; row += 1) {\n      for (col = 0; col < moduleCount; col += 1) {\n\n        var l = settings.left + col * moduleSize;\n        var t = settings.top + row * moduleSize;\n        var w = moduleSize;\n\n        fn(qr, context, settings, l, t, w, row, col);\n      }\n    }\n    if ($(settings.fill).is('img')) {\n      context.strokeStyle = 'rgba(0,0,0,0.5)';\n      context.lineWidth = 2;\n      context.stroke();\n      var prev = context.globalCompositeOperation;\n      context.globalCompositeOperation = 'destination-out';\n      context.fill();\n      context.globalCompositeOperation = prev;\n\n      context.clip();\n      context.drawImage(settings.fill, 0, 0, settings.size, settings.size);\n      context.restore();\n    } else {\n      context.fillStyle = settings.fill;\n      context.fill();\n    }\n  }\n\n  // Draws QR code to the given `canvas` and returns it.\n  function drawOnCanvas(canvas, settings) {\n\n    var qr = createQRCode(settings.text, settings.ecLevel, settings.minVersion, settings.maxVersion, settings.quiet);\n    if (!qr) {\n      return null;\n    }\n\n    var $canvas = $(canvas).data('qrcode', qr);\n    var context = $canvas[0].getContext('2d');\n\n    drawBackground(qr, context, settings);\n    drawModules(qr, context, settings);\n\n    return $canvas;\n  }\n\n  // Returns a `canvas` element representing the QR code for the given settings.\n  function createCanvas(settings) {\n\n    var $canvas = $('<canvas/>').attr('width', settings.size).attr('height', settings.size);\n    return drawOnCanvas($canvas, settings);\n  }\n\n  // Returns an `image` element representing the QR code for the given settings.\n  function createImage(settings) {\n\n    return $('<img/>').attr('src', createCanvas(settings)[0].toDataURL('image/png'));\n  }\n\n  // Returns a `div` element representing the QR code for the given settings.\n  function createDiv(settings) {\n\n    var qr = createQRCode(settings.text, settings.ecLevel, settings.minVersion, settings.maxVersion, settings.quiet);\n    if (!qr) {\n      return null;\n    }\n\n    // some shortcuts to improve compression\n    var settings_size = settings.size;\n    var settings_bgColor = settings.background;\n    var math_floor = Math.floor;\n\n    var moduleCount = qr.moduleCount;\n    var moduleSize = math_floor(settings_size / moduleCount);\n    var offset = math_floor(0.5 * (settings_size - moduleSize * moduleCount));\n\n    var row;\n    var col;\n\n    var containerCSS = {\n      position: 'relative',\n      left: 0,\n      top: 0,\n      padding: 0,\n      margin: 0,\n      width: settings_size,\n      height: settings_size\n    };\n    var darkCSS = {\n      position: 'absolute',\n      padding: 0,\n      margin: 0,\n      width: moduleSize,\n      height: moduleSize,\n      'background-color': settings.fill\n    };\n\n    var $div = $('<div/>').data('qrcode', qr).css(containerCSS);\n\n    if (settings_bgColor) {\n      $div.css('background-color', settings_bgColor);\n    }\n\n    for (row = 0; row < moduleCount; row += 1) {\n      for (col = 0; col < moduleCount; col += 1) {\n        if (qr.isDark(row, col)) {\n          $('<div/>').css(darkCSS).css({\n            left: offset + col * moduleSize,\n            top: offset + row * moduleSize\n          }).appendTo($div);\n        }\n      }\n    }\n\n    return $div;\n  }\n\n  function createHTML(settings) {\n\n    if (hasCanvas && settings.render === 'canvas') {\n      return createCanvas(settings);\n    } else if (hasCanvas && settings.render === 'image') {\n      return createImage(settings);\n    }\n\n    return createDiv(settings);\n  }\n\n  // Plugin\n  // ======\n\n  // Default settings\n  // ----------------\n  var defaults = {\n\n    // render method: `'canvas'`, `'image'` or `'div'`\n    render: 'canvas',\n\n    // version range somewhere in 1 .. 40\n    minVersion: 1,\n    maxVersion: 40,\n\n    // error correction level: `'L'`, `'M'`, `'Q'` or `'H'`\n    ecLevel: 'L',\n\n    // offset in pixel if drawn onto existing canvas\n    left: 0,\n    top: 0,\n\n    // size in pixel\n    size: 200,\n\n    // code color or image element\n    fill: '#000',\n\n    // background color or image element, `null` for transparent background\n    background: null,\n\n    // content\n    text: 'no text',\n\n    // corner radius relative to module width: 0.0 .. 0.5\n    radius: 0,\n\n    // quiet zone in modules\n    quiet: 0,\n\n    // modes\n    // 0: normal\n    // 1: label strip\n    // 2: label box\n    // 3: image strip\n    // 4: image box\n    mode: 0,\n\n    mSize: 0.1,\n    mPosX: 0.5,\n    mPosY: 0.5,\n\n    label: 'no label',\n    fontname: 'sans',\n    fontcolor: '#000',\n\n    image: null\n  };\n\n  // Register the plugin\n  // -------------------\n  $.fn.qrcode = function (options) {\n\n    var settings = $.extend({}, defaults, options);\n\n    return this.each(function () {\n\n      if (this.nodeName.toLowerCase() === 'canvas') {\n        drawOnCanvas(this, settings);\n      } else {\n        $(this).append(createHTML(settings));\n      }\n    });\n  };\n})(function () {\n\n  // `qrcode` is the single public function defined by the `QR Code Generator`\n  //---------------------------------------------------------------------\n  //\n  // QR Code Generator for JavaScript\n  //\n  // Copyright (c) 2009 Kazuhiko Arase\n  //\n  // URL: http://www.d-project.com/\n  //\n  // Licensed under the MIT license:\n  //  http://www.opensource.org/licenses/mit-license.php\n  //\n  // The word 'QR Code' is registered trademark of\n  // DENSO WAVE INCORPORATED\n  //  http://www.denso-wave.com/qrcode/faqpatent-e.html\n  //\n  //---------------------------------------------------------------------\n\n  var qrcode = function () {\n\n    //---------------------------------------------------------------------\n    // qrcode\n    //---------------------------------------------------------------------\n\n    /**\n     * qrcode\n     * @param typeNumber 1 to 40\n     * @param errorCorrectLevel 'L','M','Q','H'\n     */\n    var qrcode = function qrcode(typeNumber, errorCorrectLevel) {\n\n      var PAD0 = 0xEC;\n      var PAD1 = 0x11;\n\n      var _typeNumber = typeNumber;\n      var _errorCorrectLevel = QRErrorCorrectLevel[errorCorrectLevel];\n      var _modules = null;\n      var _moduleCount = 0;\n      var _dataCache = null;\n      var _dataList = new Array();\n\n      var _this = {};\n\n      var makeImpl = function makeImpl(test, maskPattern) {\n\n        _moduleCount = _typeNumber * 4 + 17;\n        _modules = function (moduleCount) {\n          var modules = new Array(moduleCount);\n          for (var row = 0; row < moduleCount; row += 1) {\n            modules[row] = new Array(moduleCount);\n            for (var col = 0; col < moduleCount; col += 1) {\n              modules[row][col] = null;\n            }\n          }\n          return modules;\n        }(_moduleCount);\n\n        setupPositionProbePattern(0, 0);\n        setupPositionProbePattern(_moduleCount - 7, 0);\n        setupPositionProbePattern(0, _moduleCount - 7);\n        setupPositionAdjustPattern();\n        setupTimingPattern();\n        setupTypeInfo(test, maskPattern);\n\n        if (_typeNumber >= 7) {\n          setupTypeNumber(test);\n        }\n\n        if (_dataCache == null) {\n          _dataCache = createData(_typeNumber, _errorCorrectLevel, _dataList);\n        }\n\n        mapData(_dataCache, maskPattern);\n      };\n\n      var setupPositionProbePattern = function setupPositionProbePattern(row, col) {\n\n        for (var r = -1; r <= 7; r += 1) {\n\n          if (row + r <= -1 || _moduleCount <= row + r) continue;\n\n          for (var c = -1; c <= 7; c += 1) {\n\n            if (col + c <= -1 || _moduleCount <= col + c) continue;\n\n            if (0 <= r && r <= 6 && (c == 0 || c == 6) || 0 <= c && c <= 6 && (r == 0 || r == 6) || 2 <= r && r <= 4 && 2 <= c && c <= 4) {\n              _modules[row + r][col + c] = true;\n            } else {\n              _modules[row + r][col + c] = false;\n            }\n          }\n        }\n      };\n\n      var getBestMaskPattern = function getBestMaskPattern() {\n\n        var minLostPoint = 0;\n        var pattern = 0;\n\n        for (var i = 0; i < 8; i += 1) {\n\n          makeImpl(true, i);\n\n          var lostPoint = QRUtil.getLostPoint(_this);\n\n          if (i == 0 || minLostPoint > lostPoint) {\n            minLostPoint = lostPoint;\n            pattern = i;\n          }\n        }\n\n        return pattern;\n      };\n\n      var setupTimingPattern = function setupTimingPattern() {\n\n        for (var r = 8; r < _moduleCount - 8; r += 1) {\n          if (_modules[r][6] != null) {\n            continue;\n          }\n          _modules[r][6] = r % 2 == 0;\n        }\n\n        for (var c = 8; c < _moduleCount - 8; c += 1) {\n          if (_modules[6][c] != null) {\n            continue;\n          }\n          _modules[6][c] = c % 2 == 0;\n        }\n      };\n\n      var setupPositionAdjustPattern = function setupPositionAdjustPattern() {\n\n        var pos = QRUtil.getPatternPosition(_typeNumber);\n\n        for (var i = 0; i < pos.length; i += 1) {\n\n          for (var j = 0; j < pos.length; j += 1) {\n\n            var row = pos[i];\n            var col = pos[j];\n\n            if (_modules[row][col] != null) {\n              continue;\n            }\n\n            for (var r = -2; r <= 2; r += 1) {\n\n              for (var c = -2; c <= 2; c += 1) {\n\n                if (r == -2 || r == 2 || c == -2 || c == 2 || r == 0 && c == 0) {\n                  _modules[row + r][col + c] = true;\n                } else {\n                  _modules[row + r][col + c] = false;\n                }\n              }\n            }\n          }\n        }\n      };\n\n      var setupTypeNumber = function setupTypeNumber(test) {\n\n        var bits = QRUtil.getBCHTypeNumber(_typeNumber);\n\n        for (var i = 0; i < 18; i += 1) {\n          var mod = !test && (bits >> i & 1) == 1;\n          _modules[Math.floor(i / 3)][i % 3 + _moduleCount - 8 - 3] = mod;\n        }\n\n        for (var i = 0; i < 18; i += 1) {\n          var mod = !test && (bits >> i & 1) == 1;\n          _modules[i % 3 + _moduleCount - 8 - 3][Math.floor(i / 3)] = mod;\n        }\n      };\n\n      var setupTypeInfo = function setupTypeInfo(test, maskPattern) {\n\n        var data = _errorCorrectLevel << 3 | maskPattern;\n        var bits = QRUtil.getBCHTypeInfo(data);\n\n        // vertical\n        for (var i = 0; i < 15; i += 1) {\n\n          var mod = !test && (bits >> i & 1) == 1;\n\n          if (i < 6) {\n            _modules[i][8] = mod;\n          } else if (i < 8) {\n            _modules[i + 1][8] = mod;\n          } else {\n            _modules[_moduleCount - 15 + i][8] = mod;\n          }\n        }\n\n        // horizontal\n        for (var i = 0; i < 15; i += 1) {\n\n          var mod = !test && (bits >> i & 1) == 1;\n\n          if (i < 8) {\n            _modules[8][_moduleCount - i - 1] = mod;\n          } else if (i < 9) {\n            _modules[8][15 - i - 1 + 1] = mod;\n          } else {\n            _modules[8][15 - i - 1] = mod;\n          }\n        }\n\n        // fixed module\n        _modules[_moduleCount - 8][8] = !test;\n      };\n\n      var mapData = function mapData(data, maskPattern) {\n\n        var inc = -1;\n        var row = _moduleCount - 1;\n        var bitIndex = 7;\n        var byteIndex = 0;\n        var maskFunc = QRUtil.getMaskFunction(maskPattern);\n\n        for (var col = _moduleCount - 1; col > 0; col -= 2) {\n\n          if (col == 6) col -= 1;\n\n          while (true) {\n\n            for (var c = 0; c < 2; c += 1) {\n\n              if (_modules[row][col - c] == null) {\n\n                var dark = false;\n\n                if (byteIndex < data.length) {\n                  dark = (data[byteIndex] >>> bitIndex & 1) == 1;\n                }\n\n                var mask = maskFunc(row, col - c);\n\n                if (mask) {\n                  dark = !dark;\n                }\n\n                _modules[row][col - c] = dark;\n                bitIndex -= 1;\n\n                if (bitIndex == -1) {\n                  byteIndex += 1;\n                  bitIndex = 7;\n                }\n              }\n            }\n\n            row += inc;\n\n            if (row < 0 || _moduleCount <= row) {\n              row -= inc;\n              inc = -inc;\n              break;\n            }\n          }\n        }\n      };\n\n      var createBytes = function createBytes(buffer, rsBlocks) {\n\n        var offset = 0;\n\n        var maxDcCount = 0;\n        var maxEcCount = 0;\n\n        var dcdata = new Array(rsBlocks.length);\n        var ecdata = new Array(rsBlocks.length);\n\n        for (var r = 0; r < rsBlocks.length; r += 1) {\n\n          var dcCount = rsBlocks[r].dataCount;\n          var ecCount = rsBlocks[r].totalCount - dcCount;\n\n          maxDcCount = Math.max(maxDcCount, dcCount);\n          maxEcCount = Math.max(maxEcCount, ecCount);\n\n          dcdata[r] = new Array(dcCount);\n\n          for (var i = 0; i < dcdata[r].length; i += 1) {\n            dcdata[r][i] = 0xff & buffer.getBuffer()[i + offset];\n          }\n          offset += dcCount;\n\n          var rsPoly = QRUtil.getErrorCorrectPolynomial(ecCount);\n          var rawPoly = qrPolynomial(dcdata[r], rsPoly.getLength() - 1);\n\n          var modPoly = rawPoly.mod(rsPoly);\n          ecdata[r] = new Array(rsPoly.getLength() - 1);\n          for (var i = 0; i < ecdata[r].length; i += 1) {\n            var modIndex = i + modPoly.getLength() - ecdata[r].length;\n            ecdata[r][i] = modIndex >= 0 ? modPoly.getAt(modIndex) : 0;\n          }\n        }\n\n        var totalCodeCount = 0;\n        for (var i = 0; i < rsBlocks.length; i += 1) {\n          totalCodeCount += rsBlocks[i].totalCount;\n        }\n\n        var data = new Array(totalCodeCount);\n        var index = 0;\n\n        for (var i = 0; i < maxDcCount; i += 1) {\n          for (var r = 0; r < rsBlocks.length; r += 1) {\n            if (i < dcdata[r].length) {\n              data[index] = dcdata[r][i];\n              index += 1;\n            }\n          }\n        }\n\n        for (var i = 0; i < maxEcCount; i += 1) {\n          for (var r = 0; r < rsBlocks.length; r += 1) {\n            if (i < ecdata[r].length) {\n              data[index] = ecdata[r][i];\n              index += 1;\n            }\n          }\n        }\n\n        return data;\n      };\n\n      var createData = function createData(typeNumber, errorCorrectLevel, dataList) {\n\n        var rsBlocks = QRRSBlock.getRSBlocks(typeNumber, errorCorrectLevel);\n\n        var buffer = qrBitBuffer();\n\n        for (var i = 0; i < dataList.length; i += 1) {\n          var data = dataList[i];\n          buffer.put(data.getMode(), 4);\n          buffer.put(data.getLength(), QRUtil.getLengthInBits(data.getMode(), typeNumber));\n          data.write(buffer);\n        }\n\n        // calc num max data.\n        var totalDataCount = 0;\n        for (var i = 0; i < rsBlocks.length; i += 1) {\n          totalDataCount += rsBlocks[i].dataCount;\n        }\n\n        if (buffer.getLengthInBits() > totalDataCount * 8) {\n          throw new Error('code length overflow. (' + buffer.getLengthInBits() + '>' + totalDataCount * 8 + ')');\n        }\n\n        // end code\n        if (buffer.getLengthInBits() + 4 <= totalDataCount * 8) {\n          buffer.put(0, 4);\n        }\n\n        // padding\n        while (buffer.getLengthInBits() % 8 != 0) {\n          buffer.putBit(false);\n        }\n\n        // padding\n        while (true) {\n\n          if (buffer.getLengthInBits() >= totalDataCount * 8) {\n            break;\n          }\n          buffer.put(PAD0, 8);\n\n          if (buffer.getLengthInBits() >= totalDataCount * 8) {\n            break;\n          }\n          buffer.put(PAD1, 8);\n        }\n\n        return createBytes(buffer, rsBlocks);\n      };\n\n      _this.addData = function (data) {\n        var newData = qr8BitByte(data);\n        _dataList.push(newData);\n        _dataCache = null;\n      };\n\n      _this.isDark = function (row, col) {\n        if (row < 0 || _moduleCount <= row || col < 0 || _moduleCount <= col) {\n          throw new Error(row + ',' + col);\n        }\n        return _modules[row][col];\n      };\n\n      _this.getModuleCount = function () {\n        return _moduleCount;\n      };\n\n      _this.make = function () {\n        makeImpl(false, getBestMaskPattern());\n      };\n\n      _this.createTableTag = function (cellSize, margin) {\n\n        cellSize = cellSize || 2;\n        margin = typeof margin == 'undefined' ? cellSize * 4 : margin;\n\n        var qrHtml = '';\n\n        qrHtml += '<table style=\"';\n        qrHtml += ' border-width: 0px; border-style: none;';\n        qrHtml += ' border-collapse: collapse;';\n        qrHtml += ' padding: 0px; margin: ' + margin + 'px;';\n        qrHtml += '\">';\n        qrHtml += '<tbody>';\n\n        for (var r = 0; r < _this.getModuleCount(); r += 1) {\n\n          qrHtml += '<tr>';\n\n          for (var c = 0; c < _this.getModuleCount(); c += 1) {\n            qrHtml += '<td style=\"';\n            qrHtml += ' border-width: 0px; border-style: none;';\n            qrHtml += ' border-collapse: collapse;';\n            qrHtml += ' padding: 0px; margin: 0px;';\n            qrHtml += ' width: ' + cellSize + 'px;';\n            qrHtml += ' height: ' + cellSize + 'px;';\n            qrHtml += ' background-color: ';\n            qrHtml += _this.isDark(r, c) ? '#000000' : '#ffffff';\n            qrHtml += ';';\n            qrHtml += '\"/>';\n          }\n\n          qrHtml += '</tr>';\n        }\n\n        qrHtml += '</tbody>';\n        qrHtml += '</table>';\n\n        return qrHtml;\n      };\n\n      _this.createImgTag = function (cellSize, margin) {\n\n        cellSize = cellSize || 2;\n        margin = typeof margin == 'undefined' ? cellSize * 4 : margin;\n\n        var size = _this.getModuleCount() * cellSize + margin * 2;\n        var min = margin;\n        var max = size - margin;\n\n        return createImgTag(size, size, function (x, y) {\n          if (min <= x && x < max && min <= y && y < max) {\n            var c = Math.floor((x - min) / cellSize);\n            var r = Math.floor((y - min) / cellSize);\n            return _this.isDark(r, c) ? 0 : 1;\n          } else {\n            return 1;\n          }\n        });\n      };\n\n      return _this;\n    };\n\n    //---------------------------------------------------------------------\n    // qrcode.stringToBytes\n    //---------------------------------------------------------------------\n\n    qrcode.stringToBytes = function (s) {\n      var bytes = new Array();\n      for (var i = 0; i < s.length; i += 1) {\n        var c = s.charCodeAt(i);\n        bytes.push(c & 0xff);\n      }\n      return bytes;\n    };\n\n    //---------------------------------------------------------------------\n    // qrcode.createStringToBytes\n    //---------------------------------------------------------------------\n\n    /**\n     * @param unicodeData base64 string of byte array.\n     * [16bit Unicode],[16bit Bytes], ...\n     * @param numChars\n     */\n    qrcode.createStringToBytes = function (unicodeData, numChars) {\n\n      // create conversion map.\n\n      var unicodeMap = function () {\n\n        var bin = base64DecodeInputStream(unicodeData);\n        var read = function read() {\n          var b = bin.read();\n          if (b == -1) throw new Error();\n          return b;\n        };\n\n        var count = 0;\n        var unicodeMap = {};\n        while (true) {\n          var b0 = bin.read();\n          if (b0 == -1) break;\n          var b1 = read();\n          var b2 = read();\n          var b3 = read();\n          var k = String.fromCharCode(b0 << 8 | b1);\n          var v = b2 << 8 | b3;\n          unicodeMap[k] = v;\n          count += 1;\n        }\n        if (count != numChars) {\n          throw new Error(count + ' != ' + numChars);\n        }\n\n        return unicodeMap;\n      }();\n\n      var unknownChar = '?'.charCodeAt(0);\n\n      return function (s) {\n        var bytes = new Array();\n        for (var i = 0; i < s.length; i += 1) {\n          var c = s.charCodeAt(i);\n          if (c < 128) {\n            bytes.push(c);\n          } else {\n            var b = unicodeMap[s.charAt(i)];\n            if (typeof b == 'number') {\n              if ((b & 0xff) == b) {\n                // 1byte\n                bytes.push(b);\n              } else {\n                // 2bytes\n                bytes.push(b >>> 8);\n                bytes.push(b & 0xff);\n              }\n            } else {\n              bytes.push(unknownChar);\n            }\n          }\n        }\n        return bytes;\n      };\n    };\n\n    //---------------------------------------------------------------------\n    // QRMode\n    //---------------------------------------------------------------------\n\n    var QRMode = {\n      MODE_NUMBER: 1 << 0,\n      MODE_ALPHA_NUM: 1 << 1,\n      MODE_8BIT_BYTE: 1 << 2,\n      MODE_KANJI: 1 << 3\n    };\n\n    //---------------------------------------------------------------------\n    // QRErrorCorrectLevel\n    //---------------------------------------------------------------------\n\n    var QRErrorCorrectLevel = {\n      L: 1,\n      M: 0,\n      Q: 3,\n      H: 2\n    };\n\n    //---------------------------------------------------------------------\n    // QRMaskPattern\n    //---------------------------------------------------------------------\n\n    var QRMaskPattern = {\n      PATTERN000: 0,\n      PATTERN001: 1,\n      PATTERN010: 2,\n      PATTERN011: 3,\n      PATTERN100: 4,\n      PATTERN101: 5,\n      PATTERN110: 6,\n      PATTERN111: 7\n    };\n\n    //---------------------------------------------------------------------\n    // QRUtil\n    //---------------------------------------------------------------------\n\n    var QRUtil = function () {\n\n      var PATTERN_POSITION_TABLE = [[], [6, 18], [6, 22], [6, 26], [6, 30], [6, 34], [6, 22, 38], [6, 24, 42], [6, 26, 46], [6, 28, 50], [6, 30, 54], [6, 32, 58], [6, 34, 62], [6, 26, 46, 66], [6, 26, 48, 70], [6, 26, 50, 74], [6, 30, 54, 78], [6, 30, 56, 82], [6, 30, 58, 86], [6, 34, 62, 90], [6, 28, 50, 72, 94], [6, 26, 50, 74, 98], [6, 30, 54, 78, 102], [6, 28, 54, 80, 106], [6, 32, 58, 84, 110], [6, 30, 58, 86, 114], [6, 34, 62, 90, 118], [6, 26, 50, 74, 98, 122], [6, 30, 54, 78, 102, 126], [6, 26, 52, 78, 104, 130], [6, 30, 56, 82, 108, 134], [6, 34, 60, 86, 112, 138], [6, 30, 58, 86, 114, 142], [6, 34, 62, 90, 118, 146], [6, 30, 54, 78, 102, 126, 150], [6, 24, 50, 76, 102, 128, 154], [6, 28, 54, 80, 106, 132, 158], [6, 32, 58, 84, 110, 136, 162], [6, 26, 54, 82, 110, 138, 166], [6, 30, 58, 86, 114, 142, 170]];\n      var G15 = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0;\n      var G18 = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0;\n      var G15_MASK = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1;\n\n      var _this = {};\n\n      var getBCHDigit = function getBCHDigit(data) {\n        var digit = 0;\n        while (data != 0) {\n          digit += 1;\n          data >>>= 1;\n        }\n        return digit;\n      };\n\n      _this.getBCHTypeInfo = function (data) {\n        var d = data << 10;\n        while (getBCHDigit(d) - getBCHDigit(G15) >= 0) {\n          d ^= G15 << getBCHDigit(d) - getBCHDigit(G15);\n        }\n        return (data << 10 | d) ^ G15_MASK;\n      };\n\n      _this.getBCHTypeNumber = function (data) {\n        var d = data << 12;\n        while (getBCHDigit(d) - getBCHDigit(G18) >= 0) {\n          d ^= G18 << getBCHDigit(d) - getBCHDigit(G18);\n        }\n        return data << 12 | d;\n      };\n\n      _this.getPatternPosition = function (typeNumber) {\n        return PATTERN_POSITION_TABLE[typeNumber - 1];\n      };\n\n      _this.getMaskFunction = function (maskPattern) {\n\n        switch (maskPattern) {\n\n          case QRMaskPattern.PATTERN000:\n            return function (i, j) {\n              return (i + j) % 2 == 0;\n            };\n          case QRMaskPattern.PATTERN001:\n            return function (i, j) {\n              return i % 2 == 0;\n            };\n          case QRMaskPattern.PATTERN010:\n            return function (i, j) {\n              return j % 3 == 0;\n            };\n          case QRMaskPattern.PATTERN011:\n            return function (i, j) {\n              return (i + j) % 3 == 0;\n            };\n          case QRMaskPattern.PATTERN100:\n            return function (i, j) {\n              return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 == 0;\n            };\n          case QRMaskPattern.PATTERN101:\n            return function (i, j) {\n              return i * j % 2 + i * j % 3 == 0;\n            };\n          case QRMaskPattern.PATTERN110:\n            return function (i, j) {\n              return (i * j % 2 + i * j % 3) % 2 == 0;\n            };\n          case QRMaskPattern.PATTERN111:\n            return function (i, j) {\n              return (i * j % 3 + (i + j) % 2) % 2 == 0;\n            };\n\n          default:\n            throw new Error('bad maskPattern:' + maskPattern);\n        }\n      };\n\n      _this.getErrorCorrectPolynomial = function (errorCorrectLength) {\n        var a = qrPolynomial([1], 0);\n        for (var i = 0; i < errorCorrectLength; i += 1) {\n          a = a.multiply(qrPolynomial([1, QRMath.gexp(i)], 0));\n        }\n        return a;\n      };\n\n      _this.getLengthInBits = function (mode, type) {\n\n        if (1 <= type && type < 10) {\n\n          // 1 - 9\n\n          switch (mode) {\n            case QRMode.MODE_NUMBER:\n              return 10;\n            case QRMode.MODE_ALPHA_NUM:\n              return 9;\n            case QRMode.MODE_8BIT_BYTE:\n              return 8;\n            case QRMode.MODE_KANJI:\n              return 8;\n            default:\n              throw new Error('mode:' + mode);\n          }\n        } else if (type < 27) {\n\n          // 10 - 26\n\n          switch (mode) {\n            case QRMode.MODE_NUMBER:\n              return 12;\n            case QRMode.MODE_ALPHA_NUM:\n              return 11;\n            case QRMode.MODE_8BIT_BYTE:\n              return 16;\n            case QRMode.MODE_KANJI:\n              return 10;\n            default:\n              throw new Error('mode:' + mode);\n          }\n        } else if (type < 41) {\n\n          // 27 - 40\n\n          switch (mode) {\n            case QRMode.MODE_NUMBER:\n              return 14;\n            case QRMode.MODE_ALPHA_NUM:\n              return 13;\n            case QRMode.MODE_8BIT_BYTE:\n              return 16;\n            case QRMode.MODE_KANJI:\n              return 12;\n            default:\n              throw new Error('mode:' + mode);\n          }\n        } else {\n          throw new Error('type:' + type);\n        }\n      };\n\n      _this.getLostPoint = function (qrcode) {\n\n        var moduleCount = qrcode.getModuleCount();\n\n        var lostPoint = 0;\n\n        // LEVEL1\n\n        for (var row = 0; row < moduleCount; row += 1) {\n          for (var col = 0; col < moduleCount; col += 1) {\n\n            var sameCount = 0;\n            var dark = qrcode.isDark(row, col);\n\n            for (var r = -1; r <= 1; r += 1) {\n\n              if (row + r < 0 || moduleCount <= row + r) {\n                continue;\n              }\n\n              for (var c = -1; c <= 1; c += 1) {\n\n                if (col + c < 0 || moduleCount <= col + c) {\n                  continue;\n                }\n\n                if (r == 0 && c == 0) {\n                  continue;\n                }\n\n                if (dark == qrcode.isDark(row + r, col + c)) {\n                  sameCount += 1;\n                }\n              }\n            }\n\n            if (sameCount > 5) {\n              lostPoint += 3 + sameCount - 5;\n            }\n          }\n        };\n\n        // LEVEL2\n\n        for (var row = 0; row < moduleCount - 1; row += 1) {\n          for (var col = 0; col < moduleCount - 1; col += 1) {\n            var count = 0;\n            if (qrcode.isDark(row, col)) count += 1;\n            if (qrcode.isDark(row + 1, col)) count += 1;\n            if (qrcode.isDark(row, col + 1)) count += 1;\n            if (qrcode.isDark(row + 1, col + 1)) count += 1;\n            if (count == 0 || count == 4) {\n              lostPoint += 3;\n            }\n          }\n        }\n\n        // LEVEL3\n\n        for (var row = 0; row < moduleCount; row += 1) {\n          for (var col = 0; col < moduleCount - 6; col += 1) {\n            if (qrcode.isDark(row, col) && !qrcode.isDark(row, col + 1) && qrcode.isDark(row, col + 2) && qrcode.isDark(row, col + 3) && qrcode.isDark(row, col + 4) && !qrcode.isDark(row, col + 5) && qrcode.isDark(row, col + 6)) {\n              lostPoint += 40;\n            }\n          }\n        }\n\n        for (var col = 0; col < moduleCount; col += 1) {\n          for (var row = 0; row < moduleCount - 6; row += 1) {\n            if (qrcode.isDark(row, col) && !qrcode.isDark(row + 1, col) && qrcode.isDark(row + 2, col) && qrcode.isDark(row + 3, col) && qrcode.isDark(row + 4, col) && !qrcode.isDark(row + 5, col) && qrcode.isDark(row + 6, col)) {\n              lostPoint += 40;\n            }\n          }\n        }\n\n        // LEVEL4\n\n        var darkCount = 0;\n\n        for (var col = 0; col < moduleCount; col += 1) {\n          for (var row = 0; row < moduleCount; row += 1) {\n            if (qrcode.isDark(row, col)) {\n              darkCount += 1;\n            }\n          }\n        }\n\n        var ratio = Math.abs(100 * darkCount / moduleCount / moduleCount - 50) / 5;\n        lostPoint += ratio * 10;\n\n        return lostPoint;\n      };\n\n      return _this;\n    }();\n\n    //---------------------------------------------------------------------\n    // QRMath\n    //---------------------------------------------------------------------\n\n    var QRMath = function () {\n\n      var EXP_TABLE = new Array(256);\n      var LOG_TABLE = new Array(256);\n\n      // initialize tables\n      for (var i = 0; i < 8; i += 1) {\n        EXP_TABLE[i] = 1 << i;\n      }\n      for (var i = 8; i < 256; i += 1) {\n        EXP_TABLE[i] = EXP_TABLE[i - 4] ^ EXP_TABLE[i - 5] ^ EXP_TABLE[i - 6] ^ EXP_TABLE[i - 8];\n      }\n      for (var i = 0; i < 255; i += 1) {\n        LOG_TABLE[EXP_TABLE[i]] = i;\n      }\n\n      var _this = {};\n\n      _this.glog = function (n) {\n\n        if (n < 1) {\n          throw new Error('glog(' + n + ')');\n        }\n\n        return LOG_TABLE[n];\n      };\n\n      _this.gexp = function (n) {\n\n        while (n < 0) {\n          n += 255;\n        }\n\n        while (n >= 256) {\n          n -= 255;\n        }\n\n        return EXP_TABLE[n];\n      };\n\n      return _this;\n    }();\n\n    //---------------------------------------------------------------------\n    // qrPolynomial\n    //---------------------------------------------------------------------\n\n    function qrPolynomial(num, shift) {\n\n      if (typeof num.length == 'undefined') {\n        throw new Error(num.length + '/' + shift);\n      }\n\n      var _num = function () {\n        var offset = 0;\n        while (offset < num.length && num[offset] == 0) {\n          offset += 1;\n        }\n        var _num = new Array(num.length - offset + shift);\n        for (var i = 0; i < num.length - offset; i += 1) {\n          _num[i] = num[i + offset];\n        }\n        return _num;\n      }();\n\n      var _this = {};\n\n      _this.getAt = function (index) {\n        return _num[index];\n      };\n\n      _this.getLength = function () {\n        return _num.length;\n      };\n\n      _this.multiply = function (e) {\n\n        var num = new Array(_this.getLength() + e.getLength() - 1);\n\n        for (var i = 0; i < _this.getLength(); i += 1) {\n          for (var j = 0; j < e.getLength(); j += 1) {\n            num[i + j] ^= QRMath.gexp(QRMath.glog(_this.getAt(i)) + QRMath.glog(e.getAt(j)));\n          }\n        }\n\n        return qrPolynomial(num, 0);\n      };\n\n      _this.mod = function (e) {\n\n        if (_this.getLength() - e.getLength() < 0) {\n          return _this;\n        }\n\n        var ratio = QRMath.glog(_this.getAt(0)) - QRMath.glog(e.getAt(0));\n\n        var num = new Array(_this.getLength());\n        for (var i = 0; i < _this.getLength(); i += 1) {\n          num[i] = _this.getAt(i);\n        }\n\n        for (var i = 0; i < e.getLength(); i += 1) {\n          num[i] ^= QRMath.gexp(QRMath.glog(e.getAt(i)) + ratio);\n        }\n\n        // recursive call\n        return qrPolynomial(num, 0).mod(e);\n      };\n\n      return _this;\n    };\n\n    //---------------------------------------------------------------------\n    // QRRSBlock\n    //---------------------------------------------------------------------\n\n    var QRRSBlock = function () {\n\n      var RS_BLOCK_TABLE = [\n\n      // L\n      // M\n      // Q\n      // H\n\n      // 1\n      [1, 26, 19], [1, 26, 16], [1, 26, 13], [1, 26, 9],\n\n      // 2\n      [1, 44, 34], [1, 44, 28], [1, 44, 22], [1, 44, 16],\n\n      // 3\n      [1, 70, 55], [1, 70, 44], [2, 35, 17], [2, 35, 13],\n\n      // 4\n      [1, 100, 80], [2, 50, 32], [2, 50, 24], [4, 25, 9],\n\n      // 5\n      [1, 134, 108], [2, 67, 43], [2, 33, 15, 2, 34, 16], [2, 33, 11, 2, 34, 12],\n\n      // 6\n      [2, 86, 68], [4, 43, 27], [4, 43, 19], [4, 43, 15],\n\n      // 7\n      [2, 98, 78], [4, 49, 31], [2, 32, 14, 4, 33, 15], [4, 39, 13, 1, 40, 14],\n\n      // 8\n      [2, 121, 97], [2, 60, 38, 2, 61, 39], [4, 40, 18, 2, 41, 19], [4, 40, 14, 2, 41, 15],\n\n      // 9\n      [2, 146, 116], [3, 58, 36, 2, 59, 37], [4, 36, 16, 4, 37, 17], [4, 36, 12, 4, 37, 13],\n\n      // 10\n      [2, 86, 68, 2, 87, 69], [4, 69, 43, 1, 70, 44], [6, 43, 19, 2, 44, 20], [6, 43, 15, 2, 44, 16],\n\n      // 11\n      [4, 101, 81], [1, 80, 50, 4, 81, 51], [4, 50, 22, 4, 51, 23], [3, 36, 12, 8, 37, 13],\n\n      // 12\n      [2, 116, 92, 2, 117, 93], [6, 58, 36, 2, 59, 37], [4, 46, 20, 6, 47, 21], [7, 42, 14, 4, 43, 15],\n\n      // 13\n      [4, 133, 107], [8, 59, 37, 1, 60, 38], [8, 44, 20, 4, 45, 21], [12, 33, 11, 4, 34, 12],\n\n      // 14\n      [3, 145, 115, 1, 146, 116], [4, 64, 40, 5, 65, 41], [11, 36, 16, 5, 37, 17], [11, 36, 12, 5, 37, 13],\n\n      // 15\n      [5, 109, 87, 1, 110, 88], [5, 65, 41, 5, 66, 42], [5, 54, 24, 7, 55, 25], [11, 36, 12, 7, 37, 13],\n\n      // 16\n      [5, 122, 98, 1, 123, 99], [7, 73, 45, 3, 74, 46], [15, 43, 19, 2, 44, 20], [3, 45, 15, 13, 46, 16],\n\n      // 17\n      [1, 135, 107, 5, 136, 108], [10, 74, 46, 1, 75, 47], [1, 50, 22, 15, 51, 23], [2, 42, 14, 17, 43, 15],\n\n      // 18\n      [5, 150, 120, 1, 151, 121], [9, 69, 43, 4, 70, 44], [17, 50, 22, 1, 51, 23], [2, 42, 14, 19, 43, 15],\n\n      // 19\n      [3, 141, 113, 4, 142, 114], [3, 70, 44, 11, 71, 45], [17, 47, 21, 4, 48, 22], [9, 39, 13, 16, 40, 14],\n\n      // 20\n      [3, 135, 107, 5, 136, 108], [3, 67, 41, 13, 68, 42], [15, 54, 24, 5, 55, 25], [15, 43, 15, 10, 44, 16],\n\n      // 21\n      [4, 144, 116, 4, 145, 117], [17, 68, 42], [17, 50, 22, 6, 51, 23], [19, 46, 16, 6, 47, 17],\n\n      // 22\n      [2, 139, 111, 7, 140, 112], [17, 74, 46], [7, 54, 24, 16, 55, 25], [34, 37, 13],\n\n      // 23\n      [4, 151, 121, 5, 152, 122], [4, 75, 47, 14, 76, 48], [11, 54, 24, 14, 55, 25], [16, 45, 15, 14, 46, 16],\n\n      // 24\n      [6, 147, 117, 4, 148, 118], [6, 73, 45, 14, 74, 46], [11, 54, 24, 16, 55, 25], [30, 46, 16, 2, 47, 17],\n\n      // 25\n      [8, 132, 106, 4, 133, 107], [8, 75, 47, 13, 76, 48], [7, 54, 24, 22, 55, 25], [22, 45, 15, 13, 46, 16],\n\n      // 26\n      [10, 142, 114, 2, 143, 115], [19, 74, 46, 4, 75, 47], [28, 50, 22, 6, 51, 23], [33, 46, 16, 4, 47, 17],\n\n      // 27\n      [8, 152, 122, 4, 153, 123], [22, 73, 45, 3, 74, 46], [8, 53, 23, 26, 54, 24], [12, 45, 15, 28, 46, 16],\n\n      // 28\n      [3, 147, 117, 10, 148, 118], [3, 73, 45, 23, 74, 46], [4, 54, 24, 31, 55, 25], [11, 45, 15, 31, 46, 16],\n\n      // 29\n      [7, 146, 116, 7, 147, 117], [21, 73, 45, 7, 74, 46], [1, 53, 23, 37, 54, 24], [19, 45, 15, 26, 46, 16],\n\n      // 30\n      [5, 145, 115, 10, 146, 116], [19, 75, 47, 10, 76, 48], [15, 54, 24, 25, 55, 25], [23, 45, 15, 25, 46, 16],\n\n      // 31\n      [13, 145, 115, 3, 146, 116], [2, 74, 46, 29, 75, 47], [42, 54, 24, 1, 55, 25], [23, 45, 15, 28, 46, 16],\n\n      // 32\n      [17, 145, 115], [10, 74, 46, 23, 75, 47], [10, 54, 24, 35, 55, 25], [19, 45, 15, 35, 46, 16],\n\n      // 33\n      [17, 145, 115, 1, 146, 116], [14, 74, 46, 21, 75, 47], [29, 54, 24, 19, 55, 25], [11, 45, 15, 46, 46, 16],\n\n      // 34\n      [13, 145, 115, 6, 146, 116], [14, 74, 46, 23, 75, 47], [44, 54, 24, 7, 55, 25], [59, 46, 16, 1, 47, 17],\n\n      // 35\n      [12, 151, 121, 7, 152, 122], [12, 75, 47, 26, 76, 48], [39, 54, 24, 14, 55, 25], [22, 45, 15, 41, 46, 16],\n\n      // 36\n      [6, 151, 121, 14, 152, 122], [6, 75, 47, 34, 76, 48], [46, 54, 24, 10, 55, 25], [2, 45, 15, 64, 46, 16],\n\n      // 37\n      [17, 152, 122, 4, 153, 123], [29, 74, 46, 14, 75, 47], [49, 54, 24, 10, 55, 25], [24, 45, 15, 46, 46, 16],\n\n      // 38\n      [4, 152, 122, 18, 153, 123], [13, 74, 46, 32, 75, 47], [48, 54, 24, 14, 55, 25], [42, 45, 15, 32, 46, 16],\n\n      // 39\n      [20, 147, 117, 4, 148, 118], [40, 75, 47, 7, 76, 48], [43, 54, 24, 22, 55, 25], [10, 45, 15, 67, 46, 16],\n\n      // 40\n      [19, 148, 118, 6, 149, 119], [18, 75, 47, 31, 76, 48], [34, 54, 24, 34, 55, 25], [20, 45, 15, 61, 46, 16]];\n\n      var qrRSBlock = function qrRSBlock(totalCount, dataCount) {\n        var _this = {};\n        _this.totalCount = totalCount;\n        _this.dataCount = dataCount;\n        return _this;\n      };\n\n      var _this = {};\n\n      var getRsBlockTable = function getRsBlockTable(typeNumber, errorCorrectLevel) {\n\n        switch (errorCorrectLevel) {\n          case QRErrorCorrectLevel.L:\n            return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 0];\n          case QRErrorCorrectLevel.M:\n            return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 1];\n          case QRErrorCorrectLevel.Q:\n            return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 2];\n          case QRErrorCorrectLevel.H:\n            return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 3];\n          default:\n            return undefined;\n        }\n      };\n\n      _this.getRSBlocks = function (typeNumber, errorCorrectLevel) {\n\n        var rsBlock = getRsBlockTable(typeNumber, errorCorrectLevel);\n\n        if (typeof rsBlock == 'undefined') {\n          throw new Error('bad rs block @ typeNumber:' + typeNumber + '/errorCorrectLevel:' + errorCorrectLevel);\n        }\n\n        var length = rsBlock.length / 3;\n\n        var list = new Array();\n\n        for (var i = 0; i < length; i += 1) {\n\n          var count = rsBlock[i * 3 + 0];\n          var totalCount = rsBlock[i * 3 + 1];\n          var dataCount = rsBlock[i * 3 + 2];\n\n          for (var j = 0; j < count; j += 1) {\n            list.push(qrRSBlock(totalCount, dataCount));\n          }\n        }\n\n        return list;\n      };\n\n      return _this;\n    }();\n\n    //---------------------------------------------------------------------\n    // qrBitBuffer\n    //---------------------------------------------------------------------\n\n    var qrBitBuffer = function qrBitBuffer() {\n\n      var _buffer = new Array();\n      var _length = 0;\n\n      var _this = {};\n\n      _this.getBuffer = function () {\n        return _buffer;\n      };\n\n      _this.getAt = function (index) {\n        var bufIndex = Math.floor(index / 8);\n        return (_buffer[bufIndex] >>> 7 - index % 8 & 1) == 1;\n      };\n\n      _this.put = function (num, length) {\n        for (var i = 0; i < length; i += 1) {\n          _this.putBit((num >>> length - i - 1 & 1) == 1);\n        }\n      };\n\n      _this.getLengthInBits = function () {\n        return _length;\n      };\n\n      _this.putBit = function (bit) {\n\n        var bufIndex = Math.floor(_length / 8);\n        if (_buffer.length <= bufIndex) {\n          _buffer.push(0);\n        }\n\n        if (bit) {\n          _buffer[bufIndex] |= 0x80 >>> _length % 8;\n        }\n\n        _length += 1;\n      };\n\n      return _this;\n    };\n\n    //---------------------------------------------------------------------\n    // qr8BitByte\n    //---------------------------------------------------------------------\n\n    var qr8BitByte = function qr8BitByte(data) {\n\n      var _mode = QRMode.MODE_8BIT_BYTE;\n      var _data = data;\n      var _bytes = qrcode.stringToBytes(data);\n\n      var _this = {};\n\n      _this.getMode = function () {\n        return _mode;\n      };\n\n      _this.getLength = function (buffer) {\n        return _bytes.length;\n      };\n\n      _this.write = function (buffer) {\n        for (var i = 0; i < _bytes.length; i += 1) {\n          buffer.put(_bytes[i], 8);\n        }\n      };\n\n      return _this;\n    };\n\n    //=====================================================================\n    // GIF Support etc.\n    //\n\n    //---------------------------------------------------------------------\n    // byteArrayOutputStream\n    //---------------------------------------------------------------------\n\n    var byteArrayOutputStream = function byteArrayOutputStream() {\n\n      var _bytes = new Array();\n\n      var _this = {};\n\n      _this.writeByte = function (b) {\n        _bytes.push(b & 0xff);\n      };\n\n      _this.writeShort = function (i) {\n        _this.writeByte(i);\n        _this.writeByte(i >>> 8);\n      };\n\n      _this.writeBytes = function (b, off, len) {\n        off = off || 0;\n        len = len || b.length;\n        for (var i = 0; i < len; i += 1) {\n          _this.writeByte(b[i + off]);\n        }\n      };\n\n      _this.writeString = function (s) {\n        for (var i = 0; i < s.length; i += 1) {\n          _this.writeByte(s.charCodeAt(i));\n        }\n      };\n\n      _this.toByteArray = function () {\n        return _bytes;\n      };\n\n      _this.toString = function () {\n        var s = '';\n        s += '[';\n        for (var i = 0; i < _bytes.length; i += 1) {\n          if (i > 0) {\n            s += ',';\n          }\n          s += _bytes[i];\n        }\n        s += ']';\n        return s;\n      };\n\n      return _this;\n    };\n\n    //---------------------------------------------------------------------\n    // base64EncodeOutputStream\n    //---------------------------------------------------------------------\n\n    var base64EncodeOutputStream = function base64EncodeOutputStream() {\n\n      var _buffer = 0;\n      var _buflen = 0;\n      var _length = 0;\n      var _base64 = '';\n\n      var _this = {};\n\n      var writeEncoded = function writeEncoded(b) {\n        _base64 += String.fromCharCode(encode(b & 0x3f));\n      };\n\n      var encode = function encode(n) {\n        if (n < 0) {\n          // error.\n        } else if (n < 26) {\n          return 0x41 + n;\n        } else if (n < 52) {\n          return 0x61 + (n - 26);\n        } else if (n < 62) {\n          return 0x30 + (n - 52);\n        } else if (n == 62) {\n          return 0x2b;\n        } else if (n == 63) {\n          return 0x2f;\n        }\n        throw new Error('n:' + n);\n      };\n\n      _this.writeByte = function (n) {\n\n        _buffer = _buffer << 8 | n & 0xff;\n        _buflen += 8;\n        _length += 1;\n\n        while (_buflen >= 6) {\n          writeEncoded(_buffer >>> _buflen - 6);\n          _buflen -= 6;\n        }\n      };\n\n      _this.flush = function () {\n\n        if (_buflen > 0) {\n          writeEncoded(_buffer << 6 - _buflen);\n          _buffer = 0;\n          _buflen = 0;\n        }\n\n        if (_length % 3 != 0) {\n          // padding\n          var padlen = 3 - _length % 3;\n          for (var i = 0; i < padlen; i += 1) {\n            _base64 += '=';\n          }\n        }\n      };\n\n      _this.toString = function () {\n        return _base64;\n      };\n\n      return _this;\n    };\n\n    //---------------------------------------------------------------------\n    // base64DecodeInputStream\n    //---------------------------------------------------------------------\n\n    var base64DecodeInputStream = function base64DecodeInputStream(str) {\n\n      var _str = str;\n      var _pos = 0;\n      var _buffer = 0;\n      var _buflen = 0;\n\n      var _this = {};\n\n      _this.read = function () {\n\n        while (_buflen < 8) {\n\n          if (_pos >= _str.length) {\n            if (_buflen == 0) {\n              return -1;\n            }\n            throw new Error('unexpected end of file./' + _buflen);\n          }\n\n          var c = _str.charAt(_pos);\n          _pos += 1;\n\n          if (c == '=') {\n            _buflen = 0;\n            return -1;\n          } else if (c.match(/^\\s$/)) {\n            // ignore if whitespace.\n            continue;\n          }\n\n          _buffer = _buffer << 6 | decode(c.charCodeAt(0));\n          _buflen += 6;\n        }\n\n        var n = _buffer >>> _buflen - 8 & 0xff;\n        _buflen -= 8;\n        return n;\n      };\n\n      var decode = function decode(c) {\n        if (0x41 <= c && c <= 0x5a) {\n          return c - 0x41;\n        } else if (0x61 <= c && c <= 0x7a) {\n          return c - 0x61 + 26;\n        } else if (0x30 <= c && c <= 0x39) {\n          return c - 0x30 + 52;\n        } else if (c == 0x2b) {\n          return 62;\n        } else if (c == 0x2f) {\n          return 63;\n        } else {\n          throw new Error('c:' + c);\n        }\n      };\n\n      return _this;\n    };\n\n    //---------------------------------------------------------------------\n    // gifImage (B/W)\n    //---------------------------------------------------------------------\n\n    var gifImage = function gifImage(width, height) {\n\n      var _width = width;\n      var _height = height;\n      var _data = new Array(width * height);\n\n      var _this = {};\n\n      _this.setPixel = function (x, y, pixel) {\n        _data[y * _width + x] = pixel;\n      };\n\n      _this.write = function (out) {\n\n        //---------------------------------\n        // GIF Signature\n\n        out.writeString('GIF87a');\n\n        //---------------------------------\n        // Screen Descriptor\n\n        out.writeShort(_width);\n        out.writeShort(_height);\n\n        out.writeByte(0x80); // 2bit\n        out.writeByte(0);\n        out.writeByte(0);\n\n        //---------------------------------\n        // Global Color Map\n\n        // black\n        out.writeByte(0x00);\n        out.writeByte(0x00);\n        out.writeByte(0x00);\n\n        // white\n        out.writeByte(0xff);\n        out.writeByte(0xff);\n        out.writeByte(0xff);\n\n        //---------------------------------\n        // Image Descriptor\n\n        out.writeString(',');\n        out.writeShort(0);\n        out.writeShort(0);\n        out.writeShort(_width);\n        out.writeShort(_height);\n        out.writeByte(0);\n\n        //---------------------------------\n        // Local Color Map\n\n        //---------------------------------\n        // Raster Data\n\n        var lzwMinCodeSize = 2;\n        var raster = getLZWRaster(lzwMinCodeSize);\n\n        out.writeByte(lzwMinCodeSize);\n\n        var offset = 0;\n\n        while (raster.length - offset > 255) {\n          out.writeByte(255);\n          out.writeBytes(raster, offset, 255);\n          offset += 255;\n        }\n\n        out.writeByte(raster.length - offset);\n        out.writeBytes(raster, offset, raster.length - offset);\n        out.writeByte(0x00);\n\n        //---------------------------------\n        // GIF Terminator\n        out.writeString(';');\n      };\n\n      var bitOutputStream = function bitOutputStream(out) {\n\n        var _out = out;\n        var _bitLength = 0;\n        var _bitBuffer = 0;\n\n        var _this = {};\n\n        _this.write = function (data, length) {\n\n          if (data >>> length != 0) {\n            throw new Error('length over');\n          }\n\n          while (_bitLength + length >= 8) {\n            _out.writeByte(0xff & (data << _bitLength | _bitBuffer));\n            length -= 8 - _bitLength;\n            data >>>= 8 - _bitLength;\n            _bitBuffer = 0;\n            _bitLength = 0;\n          }\n\n          _bitBuffer = data << _bitLength | _bitBuffer;\n          _bitLength = _bitLength + length;\n        };\n\n        _this.flush = function () {\n          if (_bitLength > 0) {\n            _out.writeByte(_bitBuffer);\n          }\n        };\n\n        return _this;\n      };\n\n      var getLZWRaster = function getLZWRaster(lzwMinCodeSize) {\n\n        var clearCode = 1 << lzwMinCodeSize;\n        var endCode = (1 << lzwMinCodeSize) + 1;\n        var bitLength = lzwMinCodeSize + 1;\n\n        // Setup LZWTable\n        var table = lzwTable();\n\n        for (var i = 0; i < clearCode; i += 1) {\n          table.add(String.fromCharCode(i));\n        }\n        table.add(String.fromCharCode(clearCode));\n        table.add(String.fromCharCode(endCode));\n\n        var byteOut = byteArrayOutputStream();\n        var bitOut = bitOutputStream(byteOut);\n\n        // clear code\n        bitOut.write(clearCode, bitLength);\n\n        var dataIndex = 0;\n\n        var s = String.fromCharCode(_data[dataIndex]);\n        dataIndex += 1;\n\n        while (dataIndex < _data.length) {\n\n          var c = String.fromCharCode(_data[dataIndex]);\n          dataIndex += 1;\n\n          if (table.contains(s + c)) {\n\n            s = s + c;\n          } else {\n\n            bitOut.write(table.indexOf(s), bitLength);\n\n            if (table.size() < 0xfff) {\n\n              if (table.size() == 1 << bitLength) {\n                bitLength += 1;\n              }\n\n              table.add(s + c);\n            }\n\n            s = c;\n          }\n        }\n\n        bitOut.write(table.indexOf(s), bitLength);\n\n        // end code\n        bitOut.write(endCode, bitLength);\n\n        bitOut.flush();\n\n        return byteOut.toByteArray();\n      };\n\n      var lzwTable = function lzwTable() {\n\n        var _map = {};\n        var _size = 0;\n\n        var _this = {};\n\n        _this.add = function (key) {\n          if (_this.contains(key)) {\n            throw new Error('dup key:' + key);\n          }\n          _map[key] = _size;\n          _size += 1;\n        };\n\n        _this.size = function () {\n          return _size;\n        };\n\n        _this.indexOf = function (key) {\n          return _map[key];\n        };\n\n        _this.contains = function (key) {\n          return typeof _map[key] != 'undefined';\n        };\n\n        return _this;\n      };\n\n      return _this;\n    };\n\n    var createImgTag = function createImgTag(width, height, getPixel, alt) {\n\n      var gif = gifImage(width, height);\n      for (var y = 0; y < height; y += 1) {\n        for (var x = 0; x < width; x += 1) {\n          gif.setPixel(x, y, getPixel(x, y));\n        }\n      }\n\n      var b = byteArrayOutputStream();\n      gif.write(b);\n\n      var base64 = base64EncodeOutputStream();\n      var bytes = b.toByteArray();\n      for (var i = 0; i < bytes.length; i += 1) {\n        base64.writeByte(bytes[i]);\n      }\n      base64.flush();\n\n      var img = '';\n      img += '<img';\n      img += ' src=\"';\n      img += 'data:image/gif;base64,';\n      img += base64;\n      img += '\"';\n      img += ' width=\"';\n      img += width;\n      img += '\"';\n      img += ' height=\"';\n      img += height;\n      img += '\"';\n      if (alt) {\n        img += ' alt=\"';\n        img += alt;\n        img += '\"';\n      }\n      img += '/>';\n\n      return img;\n    };\n\n    //---------------------------------------------------------------------\n    // returns qrcode function.\n\n    return qrcode;\n  }();\n\n  (function (factory) {\n    if (typeof define === 'function' && define.amd) {\n      define([], factory);\n    } else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') {\n      module.exports = factory();\n    }\n  })(function () {\n    return qrcode;\n  });\n  //---------------------------------------------------------------------\n  //\n  // QR Code Generator for JavaScript UTF8 Support (optional)\n  //\n  // Copyright (c) 2011 Kazuhiko Arase\n  //\n  // URL: http://www.d-project.com/\n  //\n  // Licensed under the MIT license:\n  //  http://www.opensource.org/licenses/mit-license.php\n  //\n  // The word 'QR Code' is registered trademark of\n  // DENSO WAVE INCORPORATED\n  //  http://www.denso-wave.com/qrcode/faqpatent-e.html\n  //\n  //---------------------------------------------------------------------\n\n  !function (qrcode) {\n\n    //---------------------------------------------------------------------\n    // overwrite qrcode.stringToBytes\n    //---------------------------------------------------------------------\n\n    qrcode.stringToBytes = function (s) {\n      // http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\n      function toUTF8Array(str) {\n        var utf8 = [];\n        for (var i = 0; i < str.length; i++) {\n          var charcode = str.charCodeAt(i);\n          if (charcode < 0x80) utf8.push(charcode);else if (charcode < 0x800) {\n            utf8.push(0xc0 | charcode >> 6, 0x80 | charcode & 0x3f);\n          } else if (charcode < 0xd800 || charcode >= 0xe000) {\n            utf8.push(0xe0 | charcode >> 12, 0x80 | charcode >> 6 & 0x3f, 0x80 | charcode & 0x3f);\n          }\n          // surrogate pair\n          else {\n              i++;\n              // UTF-16 encodes 0x10000-0x10FFFF by\n              // subtracting 0x10000 and splitting the\n              // 20 bits of 0x0-0xFFFFF into two halves\n              charcode = 0x10000 + ((charcode & 0x3ff) << 10 | str.charCodeAt(i) & 0x3ff);\n              utf8.push(0xf0 | charcode >> 18, 0x80 | charcode >> 12 & 0x3f, 0x80 | charcode >> 6 & 0x3f, 0x80 | charcode & 0x3f);\n            }\n        }\n        return utf8;\n      }\n      return toUTF8Array(s);\n    };\n  }(qrcode);\n\n  return qrcode;\n}());"

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./node_modules/babel-loader/lib/index.js??ref--0-0!./assets/js/jquery.spin.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/raw-loader!./node_modules/babel-loader/lib??ref--0-0!./assets/js/jquery.spin.js ***!
  \******************************************************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports) {

module.exports = "var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n * Copyright (c) 2011-2014 Felix Gnass\n * Licensed under the MIT license\n * http://spin.js.org/\n */\n\n/*\n\nBasic Usage:\n============\n\n$('#el').spin(); // Creates a default Spinner using the text color of #el\n$('#el').spin({ ... }); // Creates a Spinner using the provided options\n\n$('#el').spin(false); // Stops and removes the spinner\n\nUsing Presets:\n==============\n\n$('#el').spin('small'); // Creates a 'small' Spinner using the text color of #el\n$('#el').spin('large', '#fff'); // Creates a 'large' white Spinner\n\nAdding a custom preset:\n=======================\n\n$.fn.spin.presets.flower = {\n  lines:   9,\n  length: 10,\n  width:  20,\n  radius:  0\n};\n\n$('#el').spin('flower', 'red');\n\n*/\n\n;(function (factory) {\n\n  if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) == 'object') {\n    // CommonJS\n    factory(require('jquery'), require('spin.js'));\n  } else if (typeof define == 'function' && define.amd) {\n    // AMD, register as anonymous module\n    define(['jquery', 'spin'], factory);\n  } else {\n    // Browser globals\n    if (!window.Spinner) throw new Error('Spin.js not present');\n    factory(window.jQuery, window.Spinner);\n  }\n})(function ($, Spinner) {\n\n  $.fn.spin = function (opts, color) {\n\n    return this.each(function () {\n      var $this = $(this);\n      var data = $this.data();\n\n      if (data.spinner) {\n        data.spinner.stop();\n        delete data.spinner;\n      }\n      if (opts !== false) {\n        opts = $.extend({ color: color || $this.css('color') }, $.fn.spin.presets[opts] || opts);\n        data.spinner = new Spinner(opts).spin(this);\n      }\n    });\n  };\n\n  $.fn.spin.presets = {\n    tiny: { lines: 8, length: 2, width: 2, radius: 3 },\n    small: { lines: 8, length: 4, width: 3, radius: 5 },\n    large: { lines: 10, length: 8, width: 4, radius: 8 }\n  };\n});"

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./node_modules/babel-loader/lib/index.js??ref--0-0!./assets/js/mlab.api.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/raw-loader!./node_modules/babel-loader/lib??ref--0-0!./assets/js/mlab.api.js ***!
  \***************************************************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports) {

module.exports = "/*******************************************************************************************************************************\n@copyright Copyright (c) 2013-2016, Norwegian Defence Research Establishment (FFI) - All Rights Reserved\n@license Proprietary and confidential\n@author Morten Krane (Snapper) - first version \n@author Arild Bergh/Sinett 3.0 programme (firstname.lastname@ffi.no) rewrite/implementation of all functionality\n@author Cecilie Jackbo Gran/Sinett 3.0 programme (firstname.middlename.lastname@ffi.no) additional functionality\n\nUnauthorized copying of this file, via any medium is strictly prohibited \n\nFor the full copyright and license information, please view the LICENSE_MLAB file that was distributed with this source code.\n*******************************************************************************************************************************/\n\n/**\nCore functionality for the component API, all features here are local\nRemote functionality is provided by any plugins (see end of file for plugin code)\n\nKey issue here is that for data storage we need to use a proper namespace, this is as follows.\n\nLevel 1: Type (state/config/result/etc)\nLevel 2: User name\nLevel 3: Item name\nLevel 4 (optional rarely required) sub item name\n\nStorage is already app-specific, so no need to include that into the namespace.\n*/\n\n/**\n * Standard initialisation of Mlab object which is referred to in several JS files, \n * as these files can come down in different order, we must make sure we can use it here.\n * @returns {Mlab_dt_api}\n * @constructor\n */\nfunction Mlab_api() {\n    var self = this;\n    var documentOb = $(document);\n\n    this.data_divider = \"/\";\n\n    this.db.parent = this;\n    this.db.internal.parent = this.db;\n    this.mode = this.getMode();\n\n    /* \n     * Object to hold components loaded, this includes regular components, features and storage plugins\n    */\n    this.components = {};\n\n    /*--- database ---*/\n\n    /* Object to hold the plugins loaded */\n    this.db.plugins = {};\n\n    //add storage for the app specific variables (generated in the pre-compile processing function)\n    // to the object here\n    this.variables = new Object();\n\n    // added by arild\n    // this will load the text file js/include_comp.txt and load all the component runtime code that are listed there\n    // these are name COMPONENTNAME_code_rt.js, for instance googlemap_code_rt.js\n    // THE REASON FOR THIS IS THAT JQUERY WILL NOT CONFIRM RECEIVED FILE IF A .JS FILE DOES NOT CONTAIN VALID JS FIL\n    // AT THE SAME TIME WE NEED TO CONTROL THE LOADING OF THESE FILES AS THEY ARE USED TO INITIALISE COMPONENTS\n\n    /* MK: Slightly different handling of path. Adding it to empty string, to make sure we get a copy.\n        Also splitting in index_html, because we do not know what parameters there are.\n     */\n    var mlab_ready_triggered = false;\n    var path = '' + window.location.href.split('index.html')[0];\n    /* MK: When jQuery loads a file ending with .js (and no content-type response header is set) it assumes a JS file. When this \n        file proves not to be a JS file, the success handler is never fired. Suggest renaming to .txt.\n    */\n    $.ajaxSetup({ cache: false });\n    $.get(path + \"js/include_comp.txt\").done(function (data) {\n        var components = data.split(\"\\n\");\n        var componentsLength = components.length;\n        var componentsAdded = 0;\n\n        // MK: Converted for() to $.each(), because \"name\" variable was overwritten before XHR was finished. $.each provides closure to the variables.\n        $.each(components, function (i, component) {\n            // MK: js/ was already part of the component name\n            var name = component.replace(\"_code_rt.js\", \"\").replace(\"js/\", \"\");\n            $.get(path + component, function (componentCode) {\n                //we need to attach the code_rt.js content to an object so we can use it as JS code\n                eval(\"mlab.api.components['\" + name + \"'] = new function() {\" + componentCode + \"}();\");\n\n                //here we create the api objects inside the newly created object\n                mlab.api.components[name].api = mlab.api;\n                componentsAdded += 1;\n\n                /* MK: Because ajax is asynchronous, we do not know the order in which the components will be added\n                    Only when these numbers add up do we know that everything is OK \n                */\n                if (componentsAdded == componentsLength) {\n                    // MK: Not sure if this is the way it should be, but \"pagecontainerload\" was never triggered.\n                    $(document).trigger(\"mlabready\");\n                }\n            });\n        });\n    }).fail(function () {\n        $(document).trigger(\"mlabready\");\n    });\n    return this;\n}\n\n/**\n * Initialise the different functions.\n * @type Mlab_api\n */\nMlab_api.prototype = {\n    version: 0.9,\n    /**\n     * Get the mode the app is in: \"runtime\" if in app mode, \"design\" if in editor mode, \n     * with additional device info, app for mobile device, desktop for browser (i.e. no cordova)\n     * @return {object}\n     */\n    getMode: function getMode() {\n        var mode = { mode: \"design\", device: \"desktop\" };\n        if (typeof mlab.dt == \"undefined\") {\n            mode.mode = \"runtime\";\n        }\n        if (typeof window.cordova != \"undefined\") {\n            mode.device = \"mobile\";\n        }\n        return mode;\n    },\n\n    getDeviceId: function getDeviceId() {\n        var mode = this.getMode();\n        if (mode.device == \"mobile\") {\n            return device.uuid;\n        } else {\n            var global_data = window.localStorage.getItem(\"GLOBAL\");\n            if (!global_data) {\n                global_data = { \"device_uuid\": this.getGUID() };\n                window.localStorage.setItem(\"GLOBAL\", JSON.stringify(global_data));\n            } else {\n                global_data = JSON.parse(global_data);\n            }\n            return global_data.device_uuid;\n        }\n    },\n\n    getAppUid: function getAppUid() {\n        return $('head > [name=\"mlab:app_uid\"]').attr(\"content\");\n    },\n\n    /**\n     * Creates a unique ID starting with the prefix mlab_, followed by a rfc4122 version 4 compliant GUID. \n     * This is typically used to create an ID for a component that must not clash with any other IDs.\n     * @returns {String}\n     */\n    getGUID: function getGUID() {\n        return 'mlab_' + 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n            var r = Math.random() * 16 | 0,\n                v = c == 'x' ? r : r & 0x3 | 0x8;\n            return v.toString(16);\n        });\n    },\n\n    /**\n     * Get current locale\n     * @returns string\n     */\n    getLocale: function getLocale() {\n        return this.parent.locale;\n    },\n\n    /**\n     * Reads in the Javascript values stored for the specified element, extracts the value of the key specified.\n     * This only works on top level vars, further processing must be done inside the JS code for the component.\n     * \n     * Variables are stored in a <script> of type application/json as stringified JSON, on the same level as the main component HTML5 code.\n     * These are all contained within a wrapper DIV that is the actual DOM element ppassed to this function.\n     * @param {jQuery DOM element} el\n     * @param {string} key, the key name in the object\n     * @returns {Mlab_dt_api.prototype.getVariable.vars|Array|Object}\n     */\n    getVariable: function getVariable(el, key) {\n        var json = $(el).find(\"script.mlab_storage\").html();\n        if (typeof json == \"undefined\" || json == \"\") {\n            return;\n        }\n        try {\n            var vars = JSON.parse(json);\n        } catch (e) {\n            console.log(e);\n            return;\n        }\n\n        return vars[key];\n    },\n\n    /**\n     * Reads in the Javascript values stored for the specified element, and returns it as a single JS object\n     * Copy of design time code doing the same thing\n     * Variables are stored in a <script> of type application/json as stringified JSON, on the same level as the main component HTML5 code.\n     * These are all contained within a wrapper DIV that is the actual DOM element ppassed to this function.\n     * @param {jQuery DOM element} el\n     * @returns {Mlab_dt_api.prototype.getAllVariables.vars|Array|Object}\n     */\n    getAllVariables: function getAllVariables(el) {\n        var json = $(el).find(\"script.mlab_storage\").html();\n        if (typeof json == \"undefined\" || json == \"\") {\n            return;\n        }\n        try {\n            var vars = JSON.parse(json);\n        } catch (e) {\n            return;\n        }\n\n        return vars;\n    },\n\n    /**\n     * This function stores variables for the current app in a global variable, this matches the function titled setTempVariable in the mlab.dt.api.js file\n     * @param {object} comp, the name of the component\n     * @param {object} key, key to index, the component must itself ensure that this is unique, for instance by using \"xxxx\" + my_unique_id\n     * @param {object} value\n     * @returns {undefined}\n     */\n    setAppVariable: function setAppVariable(comp, key, value) {\n        if (typeof document.mlab_storage == \"undefined\") {\n            document.mlab_storage = {};\n        }\n        if (typeof document.mlab_storage[comp] == \"undefined\") {\n            document.mlab_storage[comp] = {};\n        }\n        if (typeof document.mlab_storage[comp][key] == \"undefined\") {\n            document.mlab_storage[comp][key] = {};\n        }\n\n        document.mlab_storage[comp][key] = value;\n    },\n\n    /**\n        * This function retrieves variables for the current app from a global variable, this matches the function titled getTempVariable in the mlab.dt.api.js file\n        * @param {object} comp, the name of the component\n        * @param {object} key, key to index, the component must itself ensure that this is unique, for instance by using \"xxxx\" + my_unique_id\n        * @returns {Javascript variable}\n     */\n    getAppVariable: function getAppVariable(comp, key) {\n        if (typeof document.mlab_storage == \"undefined\") {\n            return;\n        }\n        if (typeof document.mlab_storage[comp] == \"undefined\") {\n            return;\n        }\n        if (typeof document.mlab_storage[comp][key] == \"undefined\") {\n            return;\n        }\n\n        return document.mlab_storage[comp][key];\n    },\n\n    /**\n     * Object that deals with all database related activity. \n     * Internally it has code for storing data using HTML5 we storage, \n     * all functions check to see if a storage plugin is loaded, if so it will call the matching function in the plugin to store data remotely.\n     * @type object\n     */\n    db: {\n\n        /* Pointer to main mlab object */\n        parent: null,\n        retry_save_queue_counter: 0,\n        process_save_queue_counter: 0,\n        processing_queue: false,\n        process_save_queue_interval: 3000,\n        process_save_queue_num_items: 3,\n        PLUGIN_NOT_USED: -1,\n        PLUGIN_OFFLINE: -2,\n        PLUGIN_NO_FUNCTION: -3,\n        PLUGIN_NO_DATA: -4,\n\n        //we read the storage plugin information directly from the variables stored with the component that initialises the storage plugin\n        //these are stored in a JSON format in a script inside the div, and the variable is always named storage_plugin\n        /**\n         * \n         * @param {type} el: HTML element that = component that wants to open a connection\n         * @param {type} callback: ptional callback to execute from the onPluginLoaded function\n         * @returns {Boolean}\n         */\n        setupStoragePlugin: function setupStoragePlugin(el, callback) {\n            var plugin_component;\n            var owner_id = $(el).attr(\"id\");\n\n            //pick up the settings stored for a storage_plugin this is save autoamtically by the mlab editor environment\n            var plugin_info = this.parent.getVariable(el, \"storage_plugin\");\n\n            if (!plugin_info) {\n                return false;\n            }\n\n            if (\"name\" in plugin_info && plugin_info[\"name\"] in this.parent.components) {\n                plugin_component = this.parent.components[plugin_info[\"name\"]];\n            }\n\n            if (!plugin_component) {\n                return false;\n            }\n\n            //the plugins object holds a list of components (effectively pointers to components), this means all components share a single instance of the code\n            //we therefore need to add a variable that holds unique values for each \"instance\" of this plugin\n            if (!(\"_data\" in plugin_component)) {\n                plugin_component._data = {};\n            }\n            plugin_component._data[owner_id] = {};\n            plugin_component._data[owner_id].settings = plugin_info;\n            plugin_component._data[owner_id].html_element = el;\n            plugin_component._data[owner_id].owner_uuid = owner_id;\n\n            this.plugins[owner_id] = plugin_component;\n\n            // onpluginloaded isn't required for plugins, \n            if (\"onPluginLoaded\" in plugin_component) {\n                plugin_component.onPluginLoaded(el, callback);\n            }\n\n            //last thing we do is to start a global timer which tries to save unsaved data (if this is not already done\n            if (!this.processing_queue) {\n                window.setInterval(mlab.api.db.internal.processFailedQueue(), this.process_save_queue_interval);\n                this.processing_queue = true;\n            }\n            return true;\n        },\n\n        /* ---- functions that are run locally if no plugin is loaded ---- */\n\n        /* Sets state for user, also makes sure it is saved for later use.\n         * @param {String} user User ID for the currently logged in user. Required.\n         * @param {String} key Key name for the state to be stored. Required.\n         * @param {any} value The state value to be stored. Required. Can be anything that is compatible with JSON.stringify. All basic Javascript types should be OK.\n         */\n        setState: function setState(device_uuid, component_uuid, key, value, callback) {\n            return this.internal.setData(\"state\", device_uuid, component_uuid, key, value, callback);\n        },\n\n        /**\n         * Gets state for given user an key.\n         * @param {String} user User ID for the currently logged in user. Required.\n         * @param {String} key Key name for the state to be stored. Required.\n         * @return {Any} Value of state\n         */\n        getState: function getState(device_uuid, component_uuid, key, callback) {\n            return this.internal.getData(\"state\", device_uuid, component_uuid, key, callback);\n        },\n\n        /**\n         * Gets all stored states for user \n         * @param {String} user User ID for the currently logged in user. Optional.\n         * @return {Object} Object containing the states\n         */\n        getAllState: function getAllState(device_uuid, component_uuid, callback) {\n            return this.internal.getAllData(\"state\", device_uuid, component_uuid, callback);\n        },\n\n        /**\n         * Sets config for user, also makes sure it is saved for later use.\n         * @param {String} user User ID for the currently logged in user. Required.\n         * @param {String} key Key name for the config to be stored. Required.\n         * @param {any} value The config value to be stored. Required. Anything that is compatible with JSON.stringify. All basic Javascript types should be OK.\n         */\n        setConfig: function setConfig(device_uuid, component_uuid, key, value, callback) {\n            return this.internal.setData(\"config\", device_uuid, component_uuid, key, value, callback);\n        },\n\n        /**\n         * Gets config for given user an key.\n         * @param {String} user User ID for the currently logged in user. Required.\n         * @param {String} key Key name for the config to be stored. Required.\n         * @return {any} The config value (any type), or null\n         */\n        getConfig: function getConfig(device_uuid, component_uuid, key, callback) {\n            return this.internal.getData(\"config\", device_uuid, component_uuid, key, callback);\n        },\n\n        /**\n         * Gets all stored configs, or all stored configs for user (if given).\n         * @param {String} user: User ID for the currently logged in user. Optional.\n         * @return {Object} Object containing the configs\n         */\n        getAllConfig: function getAllConfig(device_uuid, component_uuid, callback) {\n            return this.internal.getAllData(\"config\", device_uuid, component_uuid, callback);\n        },\n\n        /**\n         * Saves result for a question.\n         * @param {String} user User ID for the currently logged in user. Required.\n         * @param {String} name The name of the quiz. Must be unique within the app. Required.\n         * @param {String} key The name of the question. Must be unique within the quiz. Required.\n         * @param {any} value The value to be stored.\n         */\n        setResult: function setResult(device_uuid, component_uuid, key, value, callback) {\n            return this.internal.setData(\"result\", device_uuid, component_uuid, key, value, callback);\n        },\n\n        /**\n         * Get saved result for specific question\n         * @param {String} user User ID for the currently logged in user. Required.\n         * @param {String} name The name of the quiz. Must be unique within the app. Required.\n         * @param {String} key The name of the question. Must be unique within the quiz. Required.\n         * @return {any} The value that was saved. Normally an object, but any JSON-stringifiable value is allowed.\n         */\n        getResult: function getResult(device_uuid, component_uuid, key, callback) {\n            return this.internal.getData(\"result\", device_uuid, component_uuid, key, callback);\n        },\n\n        /**\n         * Gets all stored results, or all stored reults for user (if given).\n         * @param {String} user User ID for the currently logged in user. Optional.\n         * @return {Object} Object containing the states\n         */\n        getAllResult: function getAllResult(device_uuid, component_uuid, callback) {\n            return this.internal.getAllData(\"result\", device_uuid, component_uuid, callback);\n        },\n\n        /* Network-functions */\n        /**\n         * Login on remote service, through loaded plugin. If we have a loginToken stored, we assume this is valid, \n         * and simply return the token.\n         * @param {String} service The short_name of the service\n         * @param {String} username User name\n         * @param {String} password: Password\n         * @return {boolean} or {String}. True if we have sent a login request, false if we haven't. Login token string\n         * if it exists.\n         */\n        loginRemotely: function loginRemotely(component_uuid, callback) {\n            var token = this.loginToken(component_uuid);\n            if (token) {\n                return token;\n            }\n\n            if (component_uuid in this.parent.plugins && typeof this.parent.plugins[component_uuid][\"loginRemotely\"] == \"function\") {\n                opDone = this.parent.plugins[component_uuid].loginRemotely(this.parent.plugins[component_uuid], callback);\n                if (typeof opDone != \"undefined\") return opDone;\n            }\n            return;\n        },\n\n        /**\n         * Log off the remote service, through plugin.\n         * @param {String} service The short_name of the service\n         * @return {boolean} True if plugin has logged off, false if not.\n         */\n        logoffRemotely: function logoffRemotely(component_uuid) {\n            var token = this.loginToken(component_uuid);\n            if (!token) {\n                return false;\n            }\n\n            if (component_uuid in this.parent.plugins && typeof this.parent.plugins[component_uuid][\"logoffRemotely\"] == \"function\") {\n                opDone = this.parent.plugins[component_uuid].logoffRemotely(this.parent.plugins[component_uuid], token, callback);\n                if (typeof opDone != \"undefined\") return opDone;\n            }\n            return false;\n        },\n\n        /**\n         * Getter/setter for the login token string.\n         * @param {String} service The short_name of the service\n         * @param {String} token. Token to be set. Optional.\n         * @return {String} or {false}. The currently set token, or false if not set.\n         */\n        loginToken: function loginToken(component_uuid, token) {\n            if (typeof component_uuid == \"undefined\") return false;\n\n            // Saves the login tokens in session storage, under the key \"loginTokens\"\n            if (typeof token != \"undefined\") {\n                window.sessionStorage.setItem(\"_LOGIN_TOKENS_\" + component_uuid, token);\n            }\n\n            //always return the saved token, will autoamtically be null if can't find anything\n            return window.sessionStorage.getItem(\"_LOGIN_TOKENS_\" + component_uuid);\n        },\n\n        /**\n         * Object that keeps the functions that are not part of the outward facing API of mlab.\n         */\n        internal: {\n            /* Pointer to main mlab object */\n            parent: null,\n\n            /**\n             * Internal helper function that is a generic way of dispatching a call to plugin. In addition to\n             * the named parameters \"owner_id\" and \"name\", it is possible to pass any number of parameters, which are passed\n             * on to the plugin function.\n             * \n             * @param {type} func\n             * @param {type} data_type\n             * @param {type} app_id\n             * @param {type} device_uuid\n             * @param {type} component_uuid\n             * @param {type} key\n             * @param {type} value (undefined if this is calling a getXXX function)\n             * @param {type} callback\n             * \n             * @return {boolean} Return value from plugin if it supports the function required, otherwise false.\n             * Typically the function in the plugin will run the code asynchronously and always return true\n             */\n            dispatchToPlugin: function dispatchToPlugin(callback, func, data_type, app_uuid, device_uuid, component_uuid, key, value) {\n                var opDone;\n\n                //if no plugin is loaded for this then only save locally\n                if (!component_uuid in this.parent.plugins) {\n                    return this.parent.PLUGIN_NOT_USED;\n                }\n\n                //if we're not online, call the failed callback function and then return false\n                if (typeof navigator.connection == \"undefined\") {\n                    var networkState = true;\n                } else {\n                    var networkState = navigator.connection.type != Connection.NONE;\n                }\n                if (!networkState) {\n                    this.cbPluginFailed(data_type, app_uuid, device_uuid, component_uuid, key);\n                    return this.parent.PLUGIN_OFFLINE;\n                }\n                /*\n                 * In setupStoragePlugin we should perhaps return a uuid, and then the componet can use that later to refer to it (or should it be uid of comp + comp name + plugin name? that way if already logged in, no need to do login again... when reload page would lose uuid)\n                 * Also, this should be a timer event that processes the queue... or perhaps queue just when fail, so first try here, and then\n                 * have two callback, for fail and success, (the original callback is used for success!), in fail we add things to the queue which is processed again only when offline\n                 */\n                var cbFail = this.cbPluginFailed;\n                if (component_uuid in this.parent.plugins && typeof this.parent.plugins[component_uuid][func] == \"function\") {\n                    opDone = this.parent.plugins[component_uuid][func](cbFail, callback, app_uuid, device_uuid, component_uuid, key, value);\n                    if (typeof opDone != \"undefined\") {\n                        return opDone;\n                    } else {\n                        return this.parent.PLUGIN_NO_DATA;\n                    }\n                } else {\n                    return this.parent.PLUGIN_NO_FUNCTION;\n                }\n            },\n\n            /**\n             * If the remote save fails (or we were offline already when try to save) we add a record to the queue we use to retry saves\n             * @param {type} owner_id\n             * @param {type} func\n             * @returns {undefined}\n             */\n            cbPluginFailed: function cbPluginFailed(data_type, app_uuid, device_uuid, component_uuid, key) {\n                var SEP = this.parent.parent.data_divider;\n                var counter = this.parent.retry_save_queue_counter++; //TODO could get a race condition here...\n                window.localStorage.setItem(\"_QUEUE_\" + counter, data_type + SEP + app_uuid + SEP + device_uuid + SEP + component_uuid + SEP + key);\n            },\n\n            /**\n             * Simple first in, first out queue processing, reading entry by entry from the list of items that were not saved correctly\n             * Here we retry the save function by calling setData directly with all the relevant \n             */\n            processFailedQueue: function processFailedQueue() {\n                // If we are still online we simply bail\n                if (typeof navigator.connection == \"undefined\") {\n                    var networkState = true;\n                } else {\n                    var networkState = navigator.connection.type != Connection.NONE;\n                }\n\n                //we store a pointer to the local storage of a value, this pointer = the key of the stored value\n                var dummy_cb, res;\n                var data = { data_type: null, app_uuid: null, device_uuid: null, component_uuid: null, key: null };\n                var counter = this.parent.process_save_queue_counter;\n                for (i = 0; i < this.parent.process_save_queue_num_items; i++) {\n                    console.log(\"processing q\");\n                    //if there's no data in the queue we quit\n                    var key = window.localStorage.getItem(\"_QUEUE_\" + counter);\n                    if (!key) {\n                        console.log(\"nothing in q\");return;\n                    }\n\n                    //if we cannot obtain the value we quit, otherwise we move the pointer forward and process the retrieved data\n                    var value = window.localStorage.getItem(key);\n                    if (!value) {\n                        console.log(\"no value found for key: \" + key);return;\n                    }\n\n                    var temp = key.split(mlab.api.data_divider);\n                    data.data_type = temp[0];\n                    data.app_uuid = temp[1];\n                    data.device_uuid = temp[2];\n                    data.component_uuid = temp[3];\n                    data.key = temp[4];\n                    mlab.api.db.process_save_queue_counter++;\n\n                    res = mlab.api.db.internal.dispatchToPlugin(dummy_cb, \"set\" + data.data_type.charAt(0).toUpperCase() + data.data_type.slice(1), data.data_type, data.app_uuid, data.device_uuid, data.component_uuid, data.key, value);\n                    if (!res) {\n                        mlab.api.db.internal.cbPluginFailed(data_type, app_uuid, device_uuid, component_uuid, key);\n                    }\n                }\n            },\n\n            //-----------------------------GENERIC FUNCTIONS THAT ARE USED BY WRAPPER FUNCTIONS ABOVE\n            setData: function setData(data_type, device_uuid, component_uuid, key, value, callback, app_id) {\n                if (typeof app_id == \"undefined\") {\n                    var app_id = this.parent.parent.getAppUid();\n                }\n                //always update locally\n                var SEP = this.parent.parent.data_divider;\n                window.localStorage.setItem(data_type + SEP + app_id + SEP + device_uuid + SEP + component_uuid + SEP + key, JSON.stringify(value));\n\n                var res = this.dispatchToPlugin(callback, \"set\" + data_type.charAt(0).toUpperCase() + data_type.slice(1), data_type, app_id, device_uuid, component_uuid, key, value);\n\n                //if no plugin or plugin does not support function then this is saving locally only.\n                //we call the callback with local data, and mark it as fresh\n                if (callback && (res == this.parent.PLUGIN_NOT_USED || res == this.parent.PLUGIN_NO_FUNCTION)) {\n                    var state = fresh;\n                    //otherwise data is marked as stale\n                } else if (callback && (res == this.parent.PLUGIN_OFFLINE || res == this.parent.PLUGIN_NO_DATA)) {\n                    var state = stale;\n                }\n                if (callback && res != true) {\n                    var data = { data: {}, state: state };\n                    data.data[key] = value;\n                    callback(data);\n                }\n                return true;\n            },\n\n            /**\n             * Returns the value of a single, type specific, record. Returned as a json object\n             * @param {type} data_type\n             * @param {type} device_uuid\n             * @param {type} comp_id\n             * @param {type} key\n             * @param {type} callback\n             * @returns {Boolean}\n             */\n            getData: function getData(data_type, device_uuid, component_uuid, key, callback) {\n                var app_id = this.parent.parent.getAppUid();\n                var res = this.dispatchToPlugin(callback, \"get\" + data_type.charAt(0).toUpperCase() + data_type.slice(1), data_type, app_id, device_uuid, comp_id, key);\n\n                //If false, getResult is not implemented in plugin, and we should use the local storage.\n                var SEP = this.parent.parent.data_divider;\n\n                //if no plugin or plugin does not support function then this is saving locally only.\n                //we call the callback with local data, and mark it as fresh\n                if (callback && (res == this.parent.PLUGIN_NOT_USED || res == this.parent.PLUGIN_NO_FUNCTION)) {\n                    var state = \"fresh\";\n                    //otherwise data is marked as stale\n                } else if (callback && (res == this.parent.PLUGIN_OFFLINE || res == this.parent.PLUGIN_NO_DATA)) {\n                    var state = \"stale\";\n                }\n\n                if (callback && res != true) {\n                    var data = { state: state, data: {} };\n                    data.data[key] = JSON.parse(window.localStorage.getItem(data_type + SEP + app_id + SEP + device_uuid + SEP + component_uuid + SEP + key));\n                    callback(data);\n                }\n                return true;\n            },\n\n            /**\n             * Returns all value of a single type for a specific app_id/device_uuid/component\n             * @param {type} data_type\n             * @param {type} device_uuid\n             * @param {type} comp_id\n             * @param {type} callback\n             * @returns {Boolean}\n             */\n            getAllData: function getAllData(data_type, device_uuid, comp_id, callback) {\n                var app_id = this.parent.parent.getAppUid();\n                var res = this.dispatchToPlugin(callback, \"getAll\" + data_type.charAt(0).toUpperCase() + data_type.slice(1), data_type, app_id, device_uuid, comp_id);\n                var len = 0;\n\n                if (res === true) {\n                    return true;\n                }\n                //if no plugin or plugin does not support function then this is saving locally only.\n                //we call the callback with local data, and mark it as fresh\n                if (callback && (res == this.parent.PLUGIN_NOT_USED || res == this.parent.PLUGIN_NO_FUNCTION)) {\n                    var state = \"fresh\";\n                    //otherwise data is marked as stale\n                } else if (callback && (res == this.parent.PLUGIN_OFFLINE || res == this.parent.PLUGIN_NO_DATA)) {\n                    var state = \"stale\";\n                }\n\n                if (callback && res != true) {\n                    var i = 0;\n                    var values = {};\n                    var sKey;\n                    var SEP = this.parent.parent.data_divider;\n                    var key = data_type + SEP + app_id + SEP + device_uuid + SEP + comp_id + SEP;\n                    for (; sKey = window.localStorage.key(i); i++) {\n                        len = key.length;\n                        if (sKey.substr(0, len) == key) {\n                            values[sKey] = JSON.parse(window.localStorage.getItem(sKey));\n                        }\n                    }\n                    callback({ data: values, state: state });\n                }\n\n                return true;\n            },\n            /**\n             * Delete everything in localstorage. For testing/debugging purposes.\n             */\n            clearLocalStorage: function clearLocalStorage() {\n                window.localStorage.clear();\n            },\n\n            /**\n             * Delete everything in sessionstorage. For testing/debugging purposes.\n             */\n            clearSessionStorage: function clearSessionStorage() {\n                window.sessionStorage.clear();\n            }\n\n        } //end internal\n\n\n    }, //end db\n\n    //-------- OBJECT THAT CONTAIN SUB FUNCTIONS FOR DIFFERENT APP RELATED TASKS --------//\n\n    /**\n     * Object used for navigation functionality at runtime\n     * (added by arild)\n     */\n    navigation: {\n        current_page_index: 0,\n        page_list: 0,\n        self: this,\n\n        initialise: function initialise(app_start_page, app_page_list) {\n            this.page_list = app_page_list;\n            this.pageDisplay(app_start_page);\n        },\n        /**\n         * current = page that is currently displayed\n         * move_to can be index, first, last, next, previous or a number\n         * @param {type} page\n         * @param {Boolean} swipe\n         * @returns {undefined}\n         */\n        pageDisplay: function pageDisplay(move_to, swipe) {\n            var filename = \"\";\n            switch (move_to) {\n                case \"first\":\n                    //000 is ALWAYS the first page, it is the content of index.html and we do not allow the user to move or delete the index.html page\n                    filename = \"000.html\";\n                    this.current_page_index = 0;\n                    break;\n\n                case \"last\":\n                    filename = (\"000\" + this.page_list[this.page_list.length - 1]).slice(-3) + \".html\";\n                    this.current_page_index = this.page_list.length - 1;\n                    break;\n\n                case \"next\":\n                    if (this.current_page_index >= this.page_list.length - 1) {\n                        this.current_page_index = this.page_list.length - 1;\n                        return this.current_page_index;\n                    }\n                    this.current_page_index++;\n                    filename = (\"000\" + this.page_list[this.current_page_index]).slice(-3) + \".html\";\n                    break;\n\n                case \"previous\":\n                    if (this.current_page_index < 1) {\n                        this.current_page_index = 0;\n                        return this.current_page_index;\n                    }\n                    this.current_page_index--;\n                    if (this.current_page_index < 0) {\n                        this.current_page_index = 0;\n                    }\n                    filename = (\"000\" + this.page_list[this.current_page_index]).slice(-3) + \".html\";\n                    break;\n\n                //pages are always saved as nnn.html, i.e. 001.html, and so on, so need to format the number\n                default:\n                    var pg = parseInt(move_to);\n                    if (isNaN(pg)) {\n                        return this.current_page_index;\n                    }\n                    if (move_to < 0 || move_to > this.max_pages) {\n                        return this.current_page_index;\n                    }\n                    this.current_page_index = this.page_list.indexOf(pg);\n                    filename = (\"000\" + move_to).slice(-3) + \".html\";\n                    break;\n            }\n\n            //have calculated the file name, now we need to try to load it\n            //Adds a differens between swipe and click\n            if (swipe) {\n                $.mobile.pageContainer.pagecontainer(\"change\", filename, { transition: \"slide\" });\n            } else {\n                $.mobile.pageContainer.pagecontainer(\"change\", filename, { transition: \"flip\" });\n            }\n\n            return this.current_page_index;\n        }\n\n    },\n\n    /**\n     * object for display functionality, primarily for resizing components\n     */\n    display: {\n\n        /**\n         * Goes through the components on a page and calls the onPageLoad function (if it exists)\n         * This is for components that does not require the layout of the page to be done\n         * It is called from jquery mobile's pagecreate\n         * @param {type} e\n         * @param {type} ui\n         * @returns {undefined}\n         */\n        prepareRegularComponents: function prepareRegularComponents(e) {\n            /* timestamp & ui object */\n            console.log(e.type + \" \" + Date(e.timeStamp));\n            var components = $('[data-mlab-type]:not([data-mlab-displaydependent=\"true\"])');\n\n            components.each(function () {\n                var comp_id = $(this).data(\"mlab-type\");\n                if (typeof mlab.api.components[comp_id] != \"undefined\" && typeof mlab.api.components[comp_id].onPageLoad != \"undefined\") {\n                    mlab.api.components[comp_id].onPageLoad($(this), mlab.api.getAllVariables($(this)));\n                }\n            });\n        },\n\n        /**\n         * Goes through the components on a page and calls the onPageLoad function (if it exists)\n         * This is for components that does not require the layout of the page to be done\n         * It is called from jquery mobile's pagecreate\n         * @param {type} e\n         * @param {type} ui\n         * @returns {undefined}\n         */\n        prepareDisplayDependentComponents: function prepareDisplayDependentComponents(e, ui) {\n            /* timestamp & ui object */\n            console.log(e.type + \" \" + Date(e.timeStamp));\n            console.log(ui);\n            var components = $('[data-mlab-type][data-mlab-displaydependent=\"true\"]');\n\n            components.each(function () {\n                var comp_id = $(this).data(\"mlab-type\");\n                if (typeof mlab.api.components[comp_id] != \"undefined\" && typeof mlab.api.components[comp_id].onPageLoad != \"undefined\") {\n                    mlab.api.components[comp_id].onPageLoad($(this), mlab.api.getAllVariables($(this)));\n                }\n            });\n        },\n\n        /**\n         * Updates either a single component, or all components on a page, using data attributes to determine the display\n         * @param {type} el: Optional, the element to display. If not specified, then update all components\n         * @returns {undefined}\n         */\n        updateDisplay: function updateDisplay(el) {\n            var components = typeof el == \"undefined\" ? $('[data-mlab-size][data-mlab-aspectratio]') : $(el);\n\n            components.each(function () {\n                var parent_width = $(this).parents('[role=\"main\"]').first().width();\n                var aspect_ratio = $(this).attr(\"data-mlab-aspectratio\").split(\":\");\n                var size = $(this).attr(\"data-mlab-size\");\n                var times = size == \"small\" ? 0.33 : size == \"medium\" ? 0.67 : 1;\n\n                var w = parent_width * times;\n                var h = w / aspect_ratio[0] * aspect_ratio[1];\n                $(this).css({ \"width\": w + \"px\", \"height\": h + \"px\" });\n            });\n        }\n\n    },\n\n    /**\n     * Object used for changing settings at runtime\n     */\n    settings: {\n\n        /**\n         * This function toggles the text size of an html element between 100% and 130%\n         * @param {string} elementId The id of the HTML element where the text size will be toggled\n         */\n        pageTextSizeToggle: function pageTextSizeToggle(elementClass) {\n            //TODO: Bytte til .toggle() og egentlig lage noen generiske toggleClassBasedOnID og toggleClassBasedOnClass\n            if ($(\".\" + elementClass).hasClass('mlab_large_text')) {\n                $(\".\" + elementClass).removeClass('mlab_large_text');\n            } else {\n                $(\".\" + elementClass).addClass('mlab_large_text');\n            }\n        },\n\n        /**\n        * This function toggles the text and background color of an html element\n         * @param {string} elementIdBackgroundColor The id of the HTML element where the color of the background will be toggled\n         * @param {string} elementClassTextColor  The class of the HTML element/s where the color of the text will be toggled\n        */\n        pageColorToggle: function pageColorToggle(elementIdBackgroundColor, elementClassTextColor) {\n\n            //TODO: Bytte til .toggle() og egentlig lage noen generiske toggleClassBasedOnID og toggleClassBasedOnClass\n            if ($(\"#\" + elementIdBackgroundColor).hasClass('mlab_color_toggle')) {\n                $(\"#\" + elementIdBackgroundColor).removeClass('mlab_color_toggle');\n                $(\".\" + elementClassTextColor).removeClass('mlab_color');\n            } else {\n                $(\"#\" + elementIdBackgroundColor).addClass('mlab_color_toggle');\n                $(\".\" + elementClassTextColor).addClass('mlab_color');\n            }\n        }\n\n    }\n}; // end prototype for Mlab.api\n\n/* \n * Mlab object is stored in a global variable \"mlab\", and is initialized automatically when device is ready.\n */\nif (typeof mlab == \"undefined\") {\n    mlab = { \"api\": null };\n}\n\n/**\n * Function called when document is ready, prepares the jQuery mobile callbacks, initialises diaplsy and database functions\n */\n$(document).ready(function () {\n\n    console.log(\"EVENT: ready\");\n\n    if ($(\"body\").attr(\"id\") != \"mlab_editor\") {\n        console.log(\"STATE: mobile mode, init own object\");\n\n        mlab.api = new Mlab_api();\n\n        //page create for main page (that will contain other pages) only for index page\n        $(document).on(\"pagecreate\", \"#index\", function (event) {\n            console.log(\"EVENT: pagecreate-index\");\n        });\n\n        //general pagecreate, run component code for components that do not care about display\n        $(document).on(\"pagecreate\", function (event) {\n            console.log(\"EVENT: pagecreate-general\");\n            mlab.api.display.prepareRegularComponents(event);\n            //Swipe\n            $('div.ui-page').on(\"swiperight\", function () {\n                mlab.api.navigation.pageDisplay(\"previous\", true);console.log(\"right swipe\");\n            }).on(\"swipeleft\", function () {\n                mlab.api.navigation.pageDisplay(\"next\", true);console.log(\"left swipe\");\n            });\n        });\n\n        //general pagecontainerbeforeshow, run component code for components that require size information, ie. display is done\n        $(document).on(\"pagecontainershow\", function (event, ui) {\n            console.log(\"EVENT: pagecontainershow\");\n            mlab.api.display.prepareDisplayDependentComponents(event, ui);\n            mlab.api.display.updateDisplay();\n        });\n\n        //when the orientation changes we must redraw the komponents that require specific resizing\n        $(window).on(\"orientationchange\", function (event) {\n            console.log(\"EVENT: orientationchange\");\n            mlab.api.display.updateDisplay();\n        });\n\n        //used to call app specific initialisation routine\n        $(document).on(\"mlabready\", function () {\n            console.log(\"mlabready\");\n            if (typeof mlabInitialiseApp != \"undefined\") {\n                mlabInitialiseApp();\n            }\n        });\n    }\n});"

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./node_modules/babel-loader/lib/index.js??ref--0-0!./assets/js/mlab.dt.api.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/raw-loader!./node_modules/babel-loader/lib??ref--0-0!./assets/js/mlab.dt.api.js ***!
  \******************************************************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports) {

module.exports = "var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/*******************************************************************************************************************************\r\n@copyright Copyright (c) 2013-2016, Norwegian Defence Research Establishment (FFI) - All Rights Reserved\r\n@license Proprietary and confidential\r\n@author Arild Bergh/Sinett 3.0 programme (firstname.lastname@ffi.no) rewrite/implementation of all functionality\r\n@author Cecilie Jackbo Gran/Sinett 3.0 programme (firstname.middlename.lastname@ffi.no) additional functionality\r\n\r\nUnauthorized copying of this file, via any medium is strictly prohibited \r\n\r\nFor the full copyright and license information, please view the LICENSE_MLAB file that was distributed with this source code.\r\n*******************************************************************************************************************************/\n\n/**\r\n * @abstract API functions for use by components at design time (i.e. in the MLAB editor).\r\n * @abstract Used to obtain info such as paths, to display user input requests or to store data, etc.\r\n * @returns {Mlab_dt_api}\r\n * @constructor\r\n */\nfunction Mlab_dt_api() {\n    this.storage = new Object();\n    this.version = 0.9;\n    this.properties_tooltip = false;\n};\n\n/**\r\n * Initialise the different functions.\r\n * @type type\r\n */\nMlab_dt_api.prototype = {\n\n    /*\r\n     * Symfony allows us to redfine URLs at any time using the route functionality, so we should avoid fixed URLs.\r\n     * They are therefor always stored in variables picked up from the server, using an AJAX call to the load_variable URL.\r\n     * Below are wrapper functions to obtain them from the internal variables.\r\n     */\n\n    /**\r\n     * Requests for the absolute URL to where apps are stored, we work wth the /wwwork directory inside here.\r\n     * Used to load pages in an app, and related CSS/JS/media files.\r\n     * @returns {String.origin|Location.origin|Mlab_dt_api.parent.config.urls.app}\r\n     */\n    getUrlAppAbsolute: function getUrlAppAbsolute() {\n        return window.location.origin + this.parent.config.urls.app;\n    },\n\n    /**\r\n     * Requests for the relative URL to where apps are stored, we work wth the /wwwork directory inside here\r\n     * Used to load pages in an app, and related CSS/JS/media files\r\n     * @returns {Mlab_dt_api.parent.config.urls.app}\r\n     */\n    getUrlAppRelative: function getUrlAppRelative() {\n        return this.parent.config.urls.app;\n    },\n\n    /**\r\n     * Requests for the absolute URL to where components are stored.\r\n     * Used to load components when designing an app (components consist of configuration file and JS code)\r\n     * and related CSS/JS/media files.\r\n     * @returns {Mlab_dt_api.parent.config.urls.component|String.origin|Location.origin}\r\n     */\n    getUrlComponentAbsolute: function getUrlComponentAbsolute() {\n        return window.location.origin + this.parent.config.urls.component;\n    },\n\n    /**\r\n     * Requests for the relative URL to where components are stored.\r\n     * Used to load components when designing an app (components consist of configuration file and JS code).\r\n     * and related CSS/JS/media files.\r\n     * @returns {Mlab_dt_api.parent.config.urls.component}\r\n     */\n    getUrlComponentRelative: function getUrlComponentRelative() {\n        return this.parent.config.urls.component;\n    },\n\n    /**\r\n     * Requests for the absolute URL to where templates are stored.\r\n     * Not really used much by the MLAB editor front end, the files are usually copied on the server.\r\n     * However we have it here for completeness.\r\n     * @returns {String.origin|Location.origin|Mlab_dt_api.parent.config.urls.template}\r\n     */\n    getUrlTemplateAbsolute: function getUrlTemplateAbsolute() {\n        return window.location.origin + this.parent.config.urls.template;\n    },\n\n    /**\r\n     * Requests for the relative URL to where templates are stored.\r\n     * Not really used much by the MLAB editor front end, the files are usually copied on the server.\r\n     * However we have it here for completeness.\r\n     * @returns {Mlab_dt_api.parent.config.urls.template}\r\n     */\n    getUrlTemplateRelative: function getUrlTemplateRelative() {\n        return this.parent.config.urls.template;\n    },\n\n    /**\r\n     * Requests for the absolute URL used to upload files, used by components that let users use own files, \r\n     * such a image component, video player, etc.\r\n     * @param {string} comp_id is the unique ID of the component, for instance img or video\r\n     * @returns {Mlab_dt_api.prototype@pro;parent@pro;urls@pro;component_upload_file@call;replace@call;replace|String.origin|Location.origin}\r\n     */\n    getUrlUploadAbsolute: function getUrlUploadAbsolute(comp_id) {\n        return window.location.origin + this.parent.urls.component_upload_file.replace(\"_APPID_\", this.parent.app.id).replace(\"_COMPID_\", comp_id);\n    },\n\n    /**\r\n     * Requests for the absolute URL used to upload files, used by components that let users use own files, \r\n     * such a image component, video player, etc.\r\n     * @param {string} comp_id is the unique ID of the component, for instance img or video\r\n     * @returns {Mlab_dt_api.prototype@pro;parent@pro;urls@pro;component_upload_file@call;replace@call;replace}\r\n     */\n    getUrlUploadRelative: function getUrlUploadRelative(comp_id) {\n        return this.parent.urls.component_upload_file.replace(\"_APPID_\", this.parent.app.id).replace(\"_FILETYPES_\", comp_id);\n    },\n\n    /**\r\n     * This will return a list in HTML format of all the available storage plugins\r\n     * Each plugin will have an onclick event\r\n     * @param {component} jquery element, the current selected component\r\n     */\n    getStoragePluginList: function getStoragePluginList(component) {\n        var storage_plugin_list = $(\"<ul></ul>\");\n        var sel_class = \"\";\n        var selected_plugin;\n        var that = this;\n\n        //find out if the component has a currently selected storage plugin\n        var existing_storage_plugin = mlab.dt.api.getVariable(component, \"storage_plugin\");\n        if (existing_storage_plugin && existing_storage_plugin.name) {\n            selected_plugin = existing_storage_plugin.name;\n        }\n        //component.conf.storage_plugins \n        //Hvis true så skal alle pluggins lastes - ellers skal de som er listet lastes\n        for (type in this.parent.storage_plugins) {\n            if (type == selected_plugin) {\n                sel_class = \" class='mlab_item_applied' data-mlab-selected-storage='true' \";\n            } else {\n                sel_class = \"\";\n            }\n            storage_plugin_list.append(\"<li data-mlab-storage-plugin-type='\" + type + \"' \" + sel_class + \" title='\" + $('<div/>').text(this.parent.storage_plugins[type]).html() + \"'>\"\n            //bare vise om pluginen trenger credentials...\n            + \"<img data-mlab-comp-tool='credentials' class='mlab_tools mlab_tools_space' src='/img/tools/credentials.png' title='qqq'>\" + \"<span>\" + type.charAt(0).toUpperCase() + type.slice(1) + \"</span>\" + \"</li>\");\n        }\n\n        storage_plugin_list.find(\"img\").on(\"click\", function () {\n            var this_storage_plugin_id = $(this).parent().data(\"mlab-storage-plugin-type\");\n            var el = $(\"[data-mlab-get-info='storage_plugins'] [data-mlab-storage-plugin-type='\" + this_storage_plugin_id + \"']\");\n            that.getCredentials(el, this_storage_plugin_id, that.parent.components[this_storage_plugin_id].conf.credentials, that.parent.design.storage_plugin_store_credentials, true, { storage_plugin_id: this_storage_plugin_id, component: component });\n        });\n\n        storage_plugin_list.find(\"span\").on(\"click\", function () {\n            mlab.dt.design.storage_plugin_setup($(this), $(this).parent().data(\"mlab-storage-plugin-type\"), mlab.dt.api.getSelectedComponent());\n        });\n\n        return storage_plugin_list;\n    },\n    /**\r\n     * Wrapper function which calls the back end to load component help, \r\n     * the backend checks for language selected and sees if there are language specific help file available, if not use generic one\r\n     * @param {type} component: component object\r\n     * @param {type} title: title of dlg box, string\r\n     * @param {type} owner: HTML element that will own this Qtip\r\n     * @returns {undefined}\r\n     */\n\n    displayExternalHelpfile: function displayExternalHelpfile(component_id, title, owner_element, qTipClass) {\n        var qTipClasses = 'qtip-light mlab_dt_box_style mlab_zindex_top_tooltip';\n        var url = this.parent.urls.component_helpfile.replace(\"_COMPID_\", component_id);\n\n        if (typeof qTipClass !== \"undefined\") {\n            qTipClasses = qTipClasses + \" \" + qTipClass;\n        }\n        $.getJSON(url, function (data) {\n            if (data.result === \"SUCCESS\") {\n                $(owner_element).qtip({\n                    solo: false,\n                    content: {\n                        text: data.html,\n                        title: title,\n                        button: true\n                    },\n                    position: { my: 'topRight', at: 'bottomMiddle', viewport: $(window), effect: false },\n                    show: { ready: true, modal: { on: false } },\n                    hide: false,\n                    style: { classes: qTipClasses, tip: true },\n                    events: { hide: function hide(event, api) {\n                            api.destroy();\n                        } }\n                });\n            } else {\n                alert(data.message);\n            }\n        }).fail(function () {\n            alert(_tr[\"mlab.dt.design.js.alert.help.notfound\"]);\n        });\n    },\n\n    /**\r\n     * Returns a list of files already uploaded, non-async so we can return data to the calling function who may do any number of things with it.\r\n     * @param {String} extensions\r\n     * @returns {Array} list of options for select element\r\n     */\n    getMedia: function getMedia(file_type) {\n        var data = $.ajax({\n            type: \"GET\",\n            url: this.parent.urls.uploaded_files.replace(\"_APPID_\", this.parent.app.id).replace(\"_FILETYPE_\", file_type),\n            async: false\n        }).responseText;\n\n        data = eval(\"(\" + data + \")\");\n        if (data.result == \"success\") {\n            return data.files;\n        } else {\n            return \"<option>\" + _tr[\"mlab.dt.api.js.getMedia.fail\"] + \"</option>\";\n        }\n    },\n\n    /**\r\n     * Returns a CSS style class name which utilises standard Mlab styles\r\n     * properties = array of nouns describing what style they want\r\n     */\n    getStyle: function getStyle(properties) {\n        var style = \"\";\n        for (i in properties) {\n            switch (properties[i]) {\n                case \"text\":\n                    style = style + \"mc_text \";\n                    break;\n\n                case \"imgtxt\":\n                    style = style + \"mc_picture_and_text\";\n                    break;\n            }\n        }\n    },\n\n    indicateWait: function indicateWait(state) {\n        if (state) {\n            $(\"#mlab_editor\").addClass(\"mlab_loading_info\");\n        } else {\n            $(\"#mlab_editor\").removeClass(\"mlab_loading_info\");\n        }\n    },\n    /**\r\n     * This is the function used by all components if they want to upload a file.\r\n     * It uses the jquery uploadfile plugin: https://github.com/hayageek/jquery-upload-file\r\n     * @param {type} el: DIV surrounding the component HTML\r\n     * @param {type} cb: Callback function when file is uploaded successfully OR a file is selected\r\n     * @returns {undefined}\r\n     */\n    uploadMedia: function uploadMedia(el, component_config, file_type, cb, event, multi) {\n\n        //store for later when callbacks are executed in different contexts\n        var that = this;\n        var that_qtip = null;\n\n        //first some utility functions\n\n        //generate the form used to upload files on the fly\n        function local_prepare_form_html() {\n            content = $('<form />', { \"id\": \"mlab_dt_form_upload\" });\n            content.append($('<p />', { class: \"mlab_dt_text_info\", text: _tr[\"mlab.dt.api.js.uploadMedia.qtip.content.1\"] }));\n            content.append($('<select />', { id: \"mlab_cp_select_file\", class: \"mlab_dt_select\" }));\n            content.append($('<input />', { id: \"mlab_cp_selected_file\", type: \"hidden\" }));\n            content.append($('<div />', { id: \"mlab_cp_mediaupload_uploadfiles\", class: \"mlab_dt_picture mlab_dt_left\" }));\n            content.append($('<div />', { class: \"mlab_dt_tiny_new_line\", html: \"&nbsp;\" }));\n            content.append($('<div />', { id: \"mlab_cp_mediaupload_button_cancel\", class: \"mlab_dt_button_cancel mlab_dt_left\", text: _tr[\"mlab.dt.api.js.uploadMedia.qtip.content.4\"] }));\n            content.append($('<div />', { id: \"mlab_cp_mediaupload_button_ok\", class: \"mlab_dt_button_ok mlab_dt_left\", text: _tr[\"mlab.dt.api.js.uploadMedia.qtip.content.5\"] }));\n            //            content.append( $('<img />',    { id: \"mlab_cp_mediaupload_spinner\",       class: \"right\",                                                               src:  \"/img/spinner.gif\" }) );\n            return content;\n        }\n\n        function local_set_media_source_existing() {\n            cb(el, $(\"#mlab_cp_select_file\").val());\n            that.setDirty();\n            that.closeAllPropertyDialogs();\n        }\n\n        function local_set_media_source(url) {\n            cb(el, url);\n            that.setDirty();\n            that.closeAllPropertyDialogs();\n        }\n\n        /**\r\n         * This function displays the tooltip DIV that will contain the HTML elements required to select a file for upload.\r\n         * @param {type} event\r\n         * @param {type} api\r\n         * @returns {Mlab_dt_api.prototype.uploadMedia.local_render_tooltip}\r\n         */\n        function local_render_tooltip(event, api) {\n            that.indicateWait(true);\n            that_qtip = this;\n\n            this.dt_component = el;\n            this.dt_component_id = component_config.name;\n            this.dt_config = component_config;\n            this.dt_cb = cb;\n\n            //load existing files into dropdown box and make it ddslick\n            var existing_files = that.getMedia(file_type);\n\n            $(\"#mlab_cp_select_file\").html(existing_files).on(\"change\", local_set_media_source_existing).ddslick({\n                width: 254,\n                height: 64,\n                imagePosition: \"left\",\n                selectText: \"Select existing media file to use\"\n            });\n\n            //prepare upload files jquery plugin\n            var uploadObj = $(\"#mlab_cp_mediaupload_uploadfiles\").uploadFile({\n                url: that.getUrlUploadAbsolute(that_qtip.dt_config.name),\n                formData: { comp_id: that_qtip.dt_component_id, app_path: that.parent.app.path },\n                multiple: multi === true,\n                dragDrop: true,\n                showCancel: true,\n                showAbort: true,\n                showDone: true,\n                autoSubmit: false,\n                fileName: \"mlab_files\",\n                showStatusAfterSuccess: true,\n                showPreview: true,\n                previewHeight: \"100px\",\n                previewWidth: \"100px\",\n                statusBarWidth: 254,\n                dragdropWidth: 254,\n                onSuccess: function (files, data, xhr) {\n                    if (data.result == \"failure\") {\n                        alert(data.msg);\n                    } else {\n                        local_set_media_source(data.urls[0]);\n                        mlab.dt.api.closeAllPropertyDialogs();\n                    }\n                }.bind(that_qtip.dt_component),\n                onError: function onError(files, status, errMsg) {\n                    alert(errMsg);\n                }\n            });\n\n            //assign close events and add mlab styles\n            $('#mlab_cp_mediaupload_button_ok').on(\"click\", function (e) {\n                var sel_existing = $(\"#mlab_cp_select_file\").data('ddslick').selectedData.value;\n                if (sel_existing) {\n                    local_set_media_source(sel_existing);\n                } else {\n                    uploadObj.startUpload();\n                }\n            }.bind(that_qtip.dt_component));\n            $('#mlab_cp_mediaupload_button_cancel').on(\"click\", function (e) {\n                api.hide(e);\n            }.bind(that_qtip.dt_component));\n            $('.new_but_line').addClass('mlab_dt_button_new_line');\n            $('.new_big_line').addClass('mlab_dt_large_new_line');\n            $('.new_small_line').addClass('mlab_dt_small_new_line');\n            $('.info').addClass('mlab_dt_text_info');\n            $('.ajax-file-upload-filename').addClass('mlab_dt_text_filename');\n            $('.ajax-file-upload-statusbar').addClass('mlab_dt_progress_bar');\n\n            that.indicateWait(false);\n        } // end local_render_tooltip\n\n\n        //code that is executed when this function is called\n        //\n        //can be called from element or in response to event click, this decides who should \"own\" this tooltip\n        var owner_element = typeof event != \"undefined\" ? event.currentTarget : el;\n\n        //the meat of this function, displaying the tooltip\n        that_qtip = this.properties_tooltip = $(owner_element).qtip({\n            solo: false,\n            content: { text: local_prepare_form_html(), title: _tr[\"mlab.dt.api.js.uploadMedia.qtip.title\"] },\n            position: { my: 'leftMiddle', at: 'rightMiddle', viewport: $(window) },\n            show: { ready: true, modal: { on: true, blur: false } },\n            hide: false,\n            style: { classes: 'qtip-light mlab_zindex_top_tooltip', tip: true },\n            events: {\n                render: local_render_tooltip,\n                show: function show(event, api) {\n                    api.focus(event);\n                },\n                hide: function hide(event, api) {\n                    api.destroy();that.properties_tooltip = false;\n                }\n            }\n        });\n    },\n\n    /**\r\n     * Creates a unique ID starting with the prefix mlab_, followed by a rfc4122 version 4 compliant GUID. \r\n     * This is typically used to create an ID for a component that must not clash with any other IDs.\r\n     * @returns {String}\r\n     */\n    getGUID: function getGUID() {\n        return 'mlab_' + 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n            var r = Math.random() * 16 | 0,\n                v = c == 'x' ? r : r & 0x3 | 0x8;\n            return v.toString(16);\n        });\n    },\n\n    /**\r\n     * Goes through a newly loaded page and checks if any of the components on the page requires a library (CSS/JS) to be loaded\r\n     * calls getLibraries for the actual hard lifting, this is just a wrapper\r\n     * @returns {Number}\r\n     */\n    getAllLibraries: function getAllLibraries() {\n        var processed_component = [];\n        var comp_id;\n        var that = this;\n        $(\"#\" + this.getEditorElement()).children(\"[data-mlab-type]\").each(function () {\n            comp_id = $(this).data(\"mlab-type\");\n            if (processed_component.indexOf(comp_id) < 0) {\n                that.getLibraries(comp_id);\n                processed_component.push(comp_id);\n            }\n        });\n    },\n\n    //if = true we call component_add_html to complete the adding of the components\n    getScriptFiles: function getScriptFiles(scripts, process_adding_code, comp_id) {\n        var next_script = scripts.shift();\n        var that = this;\n        $.ajaxSetup({ cache: true });\n        $.getScript(next_script).done(function (script, textStatus) {\n            if (scripts.length > 0) {\n                return that.getScriptFiles(scripts, process_adding_code, comp_id);\n            }\n            $.ajaxSetup({ cache: false });\n            if (process_adding_code === true) {\n                mlab.dt.design.component_add_html(comp_id);\n            }\n            return true;\n        }).fail(function (jqxhr, settings, exception) {\n            alert(\"Unable to load script: \" + next_script + \". Component not added, please check network connection\");\n            $.ajaxSetup({ cache: false });\n            return false;\n        });\n    },\n\n    /**\r\n     * Loads all js/css files required by a component at design time.\r\n     * Files loaded are specified in the conf.yml parameter required_libs.\r\n     * @param {string} comp_id, the unique ID for the component that needs to load the files\r\n     * @returns {undefined}\r\n     */\n    getLibraries: function getLibraries(comp_id, process_adding_code) {\n        var js_stack = [];\n        if (\"required_libs\" in this.parent.components[comp_id].conf) {\n            if (\"designtime\" in this.parent.components[comp_id].conf.required_libs) {\n                var comp_url = window.location.origin + this.parent.urls.components_root_url;\n                var comp_path = this.parent.components[comp_id].conf.name;\n\n                for (i in this.parent.components[comp_id].conf.required_libs.designtime) {\n                    var file = this.parent.components[comp_id].conf.required_libs.designtime[i];\n                    var regexp = /(http|https):\\/\\/(\\w+:{0,1}\\w*@)?(\\S+)(:[0-9]+)?(\\/|\\/([\\w#!:.?+=&%@!\\-\\/]))?/;\n\n                    //has full URL including protocol, i.e. it is remote\n                    if (regexp.test(file)) {\n                        if (file.substr(-3) == \".js\") {\n                            if ($(\"script[src*='\" + file + \"']\").length < 1) {\n                                js_stack.push(file);\n                            }\n                        } else {\n                            if ($(\"link[href*='\" + file + \"']\").length < 1) {\n                                $(\"head\").append($(\"<link rel='stylesheet' type='text/css' href='\" + file + \"' >\"));\n                            }\n                        }\n\n                        //\"local\", i.e. file that is part of Mlab a component \n                    } else if (file.substr(-3) == \".js\") {\n                        js_stack.push(file); //the local path is already set on the backend in FileManagement::loadSingleComponent\n                    } else if (file.substr(-4) == \".css\") {\n                        if ($(\"link[href*='\" + file + \"']\").length < 1) {\n                            $(\"head\").append($(\"<link rel='stylesheet' type='text/css' href='\" + file + \"' >\")); //the local path is already set on the backend in FileManagement::loadSingleComponent\n                        }\n                    }\n                }\n\n                if (js_stack.length > 0) {\n                    this.getScriptFiles(js_stack, process_adding_code, comp_id);\n                    return;\n                }\n            }\n        }\n        if (process_adding_code === true) {\n            mlab.dt.design.component_add_html(comp_id);\n        }\n    },\n\n    /**\r\n     * Get api version for designtime API, different from runtime API version (which is anyway a different file/object).\r\n     * @returns {Number}\r\n     */\n    getVersion: function getVersion() {\n        return this.version;\n    },\n\n    /**\r\n     * Get currently selected component (the DIV, not the internal HTML code).\r\n     * @returns {jQuery object that represents the DIV surrounding the component}\r\n     */\n    getSelectedComponent: function getSelectedComponent() {\n        return $('.mlab_current_component');\n    },\n\n    /**\r\n     * Set the global dirty flag, this tells the page_save function that the page needs to be updated on the server.\r\n     * @returns {undefined}\r\n     */\n    setDirty: function setDirty() {\n        this.parent.flag_dirty = true;\n    },\n\n    /**\r\n     * Clear the global dirty flag\r\n     * @returns {undefined}\r\n     */\n    clearDirty: function clearDirty() {\n        this.parent.flag_dirty = false;\n    },\n\n    /**\r\n     * Get the ID of the DIV that is the container for the editable area. \r\n     * The string name is specified in the parameter.yml file and can be changed, but there really is no reason to do this.\r\n     * @returns {String: Mlab_dt_api.parent.config.content_id}\r\n     */\n    getEditorElement: function getEditorElement() {\n        return this.parent.config.app.content_id;\n    },\n\n    /**\r\n     * Simple wrapper function which will ensure that the jQuery plugin qtip2 is closed.\r\n     * @returns {undefined}\r\n     */\n    closeAllPropertyDialogs: function closeAllPropertyDialogs() {\n        if (this.properties_tooltip) {\n            $(this.properties_tooltip).qtip('hide');\n        }\n    },\n\n    executeCallback: function executeCallback(func, el, event, api) {\n        if (typeof func == \"undefined\" || func == null) {\n            return;\n        }\n        func(el, event, api);\n    },\n\n    /**\r\n     * Displays the property input dialog for the specified component. \r\n     * This uses the jQuery plugin qtip2 for the actual dialog, and fills it with the specified content.\r\n     * The component is reponsible for adding buttons such as Cancel and OK with callback to relevant functions in the component.\r\n     * @param {jQuery DOM element} el, the component that the dialdisplayPropertyDialogog should be attached to\r\n     * @param {string} title\r\n     * @param {HTML string} content, valid HTML5\r\n     * @param {function object} func_render, callback function when the property dialog is created, can be used to manipulate dialog, add content, etc.\r\n     * @param {function object} func_visible, callback function when the property dialog is visible\r\n     * @param {function object} func_hide currently unused\r\n     * @returns {undefined}\r\n     */\n    displayPropertyDialog: function displayPropertyDialog(el, title, content, func_render, func_visible, func_hide, focus_selector, wide, event) {\n        this.indicateWait(true);\n        this.closeAllPropertyDialogs();\n        that = this;\n        var c = 'mlab_property_dlg qtip-light mlab_dt_box_style mlab_zindex_top_tooltip';\n        if (wide == true) {\n            c = c + ' mlab_dt_wide_qtip_box ';\n        };\n\n        if (typeof event != \"undefined\") {\n            var owner_element = event.currentTarget;\n        } else {\n            var owner_element = el;\n        }\n\n        var curr_comp = $(\".mlab_current_component\");\n        //set the qTips posistion after where it is placed in the window \n        var myPosQtip = 'leftMiddle';\n        //var eTop = curr_comp.top; //get the offset top of the element\n        var eTop = curr_comp.offset().top; //get the offset top of the element\n        //eTop = eTop - $(window).scrollTop();\n        if (eTop <= 145) {\n            myPosQtip = 'leftTop';\n        }\n\n        that.properties_tooltip = $(owner_element).qtip({\n            solo: false,\n            content: { text: content, title: title, button: true },\n            position: { my: myPosQtip, at: 'rightMiddle', viewport: $(window) },\n            show: { ready: true, modal: { on: true, blur: false, escape: false }, autofocus: focus_selector },\n            hide: false,\n            style: { classes: c, tip: true },\n            events: { render: function render(event, api) {\n                    if (func_render) {\n                        that.executeCallback(func_render, el, event, api);\n                    }\n                },\n                show: function show(event, api) {\n                    $('.qtip-title').append('<img class=\"mlab_dt_button_help\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiZCAAWNk5BICUAxAboEld+P3zxwYGcgHIYCBuAOL3QPwfB74PxAn4zGHE4+r9WFyNCywA+iYRmwQzFQwHAQNmFhaFf3//bESXYMKieD6JhsNAAtBxDsRY4IDDgAegoADiA3gsyScmch2wROx8NDUGuCKflBS0H6ppPw41+8m2AM03AljEDXAk2/cMlACgAQqg4MKTL+YTlQ9wGG4ATb4COJR8AGJDYH54QCgVkWu4I7rhRFsABP14DF8AdfkFoosKLD7AlToSgQYvILksItKCA0DDHQnpJTaIsHl/IsMoQI4DLLiBGL1MtHbcqAUEAQuR6hqxZTRiNAIEGADaemUuXgZoWQAAAABJRU5ErkJggg==\">');\n                },\n                hide: function hide(event, api) {\n                    if (func_hide) {\n                        that.executeCallback(func_hide, el, event, api);\n                    };api.destroy();that.properties_tooltip = false;\n                },\n                visible: function visible(event, api) {\n                    if (func_visible) {\n                        that.executeCallback(func_visible, el, event, api);\n                    }\n                }\n            }\n        });\n        this.indicateWait(false);\n    },\n\n    /**\r\n     * Displays the help text, loaded via AJAX from \r\n     * @param {string} title\r\n     * @param {HTML string} content, valid HTML5\r\n     * @param {function object} func_render, callback function when the property dialog is created, can be used to manipulate dialog, add content, etc.\r\n     * @param {function object} func_visible, callback function when the property dialog is visible\r\n     * @param {function object} func_hide currently unused\r\n     * @returns {undefined}\r\n     */\n    displayHtmlPageInDialog: function displayHtmlPageInDialog(el, title, htmlpage, qTipClass) {\n        var styleClasses = 'qtip-light mlab_dt_box_style mlab_zindex_top_tooltip';\n        if (typeof qTipClass != \"undefined\") {\n            var styleClasses = styleClasses + \" \" + qTipClass;\n        }\n\n        $(el).qtip({\n            solo: false,\n            content: {\n                text: htmlpage,\n                title: title,\n                button: true\n            },\n            position: { my: 'topRight', at: 'bottomMiddle', viewport: $(window), effect: false },\n            show: { ready: true, modal: { on: false } },\n            hide: false,\n            style: { classes: styleClasses, tip: true },\n            events: { hide: function hide(event, api) {\n                    api.destroy();\n                }, render: function render() {\n                    $(\".mlab_help_icon\").qtip().elements.tooltip.draggable();\n                } }\n        });\n    },\n\n    /**\r\n     * Makes currently the socified component editable, using the HTML5 contenteditable attribute.\r\n     * Only works on text elements, such as heading or paragraph\r\n     * @param {jQuery DOM element} el\r\n     * @returns {undefined}\r\n     */\n    editContent: function editContent(el) {\n        $(el).attr('contenteditable', 'true').focus();\n        var range = document.createRange();\n        var sel = window.getSelection();\n        range.selectNodeContents($(el)[0]);\n        sel.removeAllRanges();\n        sel.addRange(range);\n    },\n\n    /**\r\n     * Returns the locale (for instance nb_NO) as specified in the backend Symfony environment.\r\n     * Loaded as a temporary variable on initial MLAB editor page load as it has to be passed from the backend.\r\n     * @returns {Mlab_dt_api.parent.parent.locale}\r\n     */\n    getLocale: function getLocale() {\n        return this.parent.parent.locale;\n    },\n\n    /**\r\n     * Returns the string from a component as specified by the msg_key and msg_subkey \r\n     * This is a string that is entered into the conf.yml, it can be a tooltip or generic messages\r\n     * If the key points to a string we just return the string, if it is an object, and it has an object named the same as the current locale,\r\n     * then it returns this locale string, otherwise looks for one called default. If neither found, return empty\r\n     * @param {type} comp_id\r\n     * @param {string array} keys\r\n     * @returns {string}\r\n     */\n    getLocaleComponentMessage: function getLocaleComponentMessage(comp_id, keys) {\n        var loc = this.getLocale();\n        var obj = this.parent.components[comp_id].conf;\n        var found_at_all = false;\n\n        for (i in keys) {\n            if (keys[i] in obj) {\n                found_at_all = true;\n                obj = obj[keys[i]];\n            } else {\n                found_at_all = false;\n                break;\n            }\n        }\n\n        //does key exist at all?\n        if (!found_at_all) {\n            return \"\";\n\n            //key was found, now ned to see if it is a string or array of strings, and if our locale is present in object\n        } else {\n            if ((typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj)) != \"object\") {\n                return obj;\n            } else if (loc in obj) {\n                return obj[loc];\n            } else if (\"default\" in obj) {\n                return obj[\"default\"];\n            } else {\n                return \"\";\n            }\n        }\n    },\n\n    /**\r\n     * Reads in the Javascript values stored for the specified element, extracts the value of the key specified.\r\n     * This only works on top level vars, further processing must be done inside the JS code for the component.\r\n     * \r\n     * Variables are stored in a <script> of type application/json as stringified JSON, on the same level as the main component HTML5 code.\r\n     * These are all contained within a wrapper DIV that is the actual DOM element ppassed to this function.\r\n     * @param {jQuery DOM element} el\r\n     * @param {string} key, the key name in the object\r\n     * @returns {Mlab_dt_api.prototype.getVariable.vars|Array|Object}\r\n     */\n    getVariable: function getVariable(el, key) {\n        var json = $(el).find(\"script.mlab_storage\").html();\n        if (typeof json == \"undefined\" || json == \"\") {\n            return;\n        }\n        try {\n            var vars = JSON.parse(json);\n        } catch (e) {\n            console.log(e);\n            return;\n        }\n\n        return vars[key];\n    },\n\n    /**\r\n     * Reads in the Javascript values stored for the specified element, and returns it as a single JS object\r\n     * \r\n     * Variables are stored in a <script> of type application/json as stringified JSON, on the same level as the main component HTML5 code.\r\n     * These are all contained within a wrapper DIV that is the actual DOM element ppassed to this function.\r\n     * @param {jQuery DOM element} el\r\n     * @returns {Mlab_dt_api.prototype.getAllVariables.vars|Array|Object}\r\n     */\n    getAllVariables: function getAllVariables(el) {\n        var json = $(el).find(\"script.mlab_storage\").html();\n        if (typeof json == \"undefined\" || json == \"\") {\n            return;\n        }\n        try {\n            var vars = JSON.parse(json);\n        } catch (e) {\n            console.log(e);\n            return;\n        }\n\n        return vars;\n    },\n\n    getTempVariable: function getTempVariable(comp, key) {\n        if (typeof document.mlab_dt_storage == \"undefined\") {\n            return;\n        }\n        if (typeof document.mlab_dt_storage[comp] == \"undefined\") {\n            return;\n        }\n        if (typeof document.mlab_dt_storage[comp][key] == \"undefined\") {\n            return;\n        }\n\n        return document.mlab_dt_storage[comp][key];\n    },\n\n    //writes the javascript value and stores it for the specified element\n    /**\r\n     * Stores a Javascript value for the specified element.\r\n     * This only works on top level vars, but the value can be an object which in effect gives lower level storage posibilities.\r\n     * \r\n     * Variables are stored in a <script> of type application/json as stringified JSON, on the same level as the main component HTML5 code.\r\n     * These are all contained within a wrapper DIV that is the actual DOM element passed to this function.\r\n     * @param {jQuery DOM element} el\r\n     * @param {string} key, the key name in the object\r\n     * @param {anything} value\r\n     * @returns {Boolean}\r\n     */\n    setVariable: function setVariable(el, key, value) {\n        var scrpt = $(el).find(\"script.mlab_storage\");\n        if (scrpt.length < 1) {\n            $(el).append(\"<script type='application/json' class='mlab_storage' />\");\n            var vars = new Object();\n        } else {\n            var json = scrpt.html();\n            if (json != \"\") {\n                try {\n                    var vars = JSON.parse(json);\n                } catch (e) {\n                    console.log(e);\n                    var vars = new Object();\n                }\n            } else {\n                var vars = new Object();\n            }\n        }\n\n        vars[key] = value;\n        $(el).find(\"script.mlab_storage\").html(JSON.stringify(vars));\n        this.setDirty();\n        return true;\n    },\n\n    /**\r\n     * Overwrites all variables for the specified element, complementary to the setVariable function\r\n     * \r\n     * Variables are stored in a <script> of type application/json as stringified JSON, on the same level as the main component HTML5 code.\r\n     * These are all contained within a wrapper DIV that is the actual DOM element passed to this function.\r\n     * @param {jQuery DOM element} el\r\n     * @param {anything} values to be stores\r\n     * @returns {Boolean}\r\n     */\n    setAllVariables: function setAllVariables(el, values) {\n\n        var scrpt = $(el).find(\"script.mlab_storage\");\n        if (scrpt.length < 1) {\n            $(el).append(\"<script type='application/json' class='mlab_storage' />\");\n        }\n\n        $(el).find(\"script.mlab_storage\").html(JSON.stringify(values));\n        this.setDirty();\n        return true;\n    },\n\n    /**\r\n     * This function stores things for the current session (i.e. the lifetime of this webpage) \r\n     * @param {object} comp, the name of the component\r\n     * @param {object} key, key to index, the component must itself ensure that this is unique, for instance by using \"xxxx\" + my_unique_id\r\n     * @param {object} value\r\n     * @returns {undefined}\r\n     */\n    setTempVariable: function setTempVariable(comp, key, value) {\n        if (typeof document.mlab_dt_storage == \"undefined\") {\n            document.mlab_dt_storage = {};\n        }\n        if (typeof document.mlab_dt_storage[comp] == \"undefined\") {\n            document.mlab_dt_storage[comp] = {};\n        }\n        if (typeof document.mlab_dt_storage[comp][key] == \"undefined\") {\n            document.mlab_dt_storage[comp][key] = {};\n        }\n\n        document.mlab_dt_storage[comp][key] = value;\n    },\n\n    /**\r\n     * This updates the script for a control, this is write only as it should always be generated from user input and variables!\r\n     * It therefore also always replaces existing content in the script element\r\n     * @param {jQuery DOM element} el\r\n     * @param {text} code, any Javascript compatible statements\r\n     * @returns {Boolean}\r\n     */\n    setScript: function setScript(el, code) {\n        var scrpt = $(el).find(\"script.mlab_code\");\n        if (scrpt.length > 0) {\n            scrpt.remove();\n        }\n\n        scrpt = document.createElement(\"script\");\n        scrpt.type = \"text/javascript\";\n        scrpt.className = \"mlab_code\";\n        scrpt.text = code;\n        $(el).append(scrpt);\n\n        return true;\n    },\n\n    /***\r\n     * Utility function to get the A element parent of a selection area\r\n     * @returns {String|Boolean}\r\n     */\n    getSelTextParentLinkElement: function getSelTextParentLinkElement() {\n        var el, sel, node;\n        sel = window.getSelection();\n        if (sel.rangeCount) {\n            el = sel.getRangeAt(0).commonAncestorContainer;\n            node = el.nodeName.toLowerCase();\n            while (node != 'a' && node != \"body\") {\n                el = el.parentNode;\n                node = el.nodeName.toLowerCase();\n            }\n        }\n\n        if (node == 'a') {\n            return el;\n        } else {\n            return false;\n        }\n    },\n\n    /***\r\n     * Utility function to check that the current selection is inside the current mlab component\r\n     * @returns {String|Boolean}\r\n     */\n    checkSelTextValid: function checkSelTextValid() {\n        var el, sel, node;\n        sel = window.getSelection();\n        if (sel.toString() != \"\") {\n            el = sel.getRangeAt(0).commonAncestorContainer;\n            if ($(el).hasClass(\"mlab_current_component\") || $(el).parents(\"div.mlab_current_component\").length > 0) {\n                return true;\n            }\n        }\n\n        return false;\n    },\n\n    update_newpage_link: function update_newpage_link(data) {\n        if (data.result == \"success\") {\n            $(\".mlab_current_component\").find(\"a[href=MLAB_DT_LINK_TEMP]\").attr(\"href\", \"#\").attr(\"onclick\", 'mlab.api.navigation.pageDisplay(' + data.new_page_num + '); return false;');\n            mlab.dt.app.page_names = data.page_names;\n            mlab.dt.management.app_update_gui_metadata(true);\n        } else {\n            $(\".mlab_current_component\").find(\"a[href=MLAB_DT_LINK_TEMP]\").contents().unwrap();\n        }\n    },\n\n    /**\r\n     * \r\n     * Links to pages must use the api call navigation.pageDisplay, links to external pages must use _new as the target value.\r\n     * In the option list in the dialog box pages are listed with filename as value and title as displayed text\r\n     * @param {type} link\r\n     * @returns {Boolean}\r\n     */\n    updateLink: function updateLink() {\n        var link_type = $(\"input:radio[name=mlab_dt_getlink_choice]:checked\").val();\n        var link = \"\";\n        var page_name;\n\n        if (link_type == \"page\") {\n            link = $(\"#mlab_dt_link_app_pages\").val();\n            if (link) {\n                page_num = parseInt(link);\n                $(\".mlab_current_component\").find(\"a[href=MLAB_DT_LINK_TEMP]\").attr(\"href\", \"#\").attr(\"onclick\", 'mlab.api.navigation.pageDisplay(' + page_num + '); return false;');\n            } else {\n                alert(_tr[\"mlab.dt.api.js.getLink.alert_no_page\"]);\n                return false;\n            }\n        } else if (link_type == \"url\") {\n            link = $(\"#mlab_dt_link_app_url\").val();\n            if (/^(https?|ftp):\\/\\/(((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:)*@)?(((\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5]))|((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.?)(:\\d*)?)(\\/((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)+(\\/(([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)*)*)?)?(\\?((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)|[\\uE000-\\uF8FF]|\\/|\\?)*)?(\\#((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)|\\/|\\?)*)?$/i.test(link)) {\n                page_name = link.trim();\n                $(\".mlab_current_component\").find(\"a[href=MLAB_DT_LINK_TEMP]\").attr(\"href\", page_name);\n            } else {\n                alert(_tr[\"mlab.dt.api.js.getLink.alert_url_wrong\"]);\n                return false;\n            }\n        } else if (link_type == \"newpage\") {\n            var page_title = $(\"#mlab_dt_link_app_new_page\").val();\n            if (page_title) {\n                mlab.dt.management.page_new_in_background(page_title, this.update_newpage_link);\n            } else {\n                alert(_tr[\"mlab.dt.api.js.getLink.alert_no_title\"]);\n                return false;\n            }\n        } else {\n            alert(_tr[\"mlab.dt.api.js.getLink.alert_choose_type\"]);\n            return false;\n        }\n\n        return true;\n    },\n\n    /**\r\n     * Asks a user for a link either to a external page or to a page in the current app.\r\n     * The actual link is created in updateLink above\r\n     * @returns {Boolean|String}\r\n     */\n    setLink: function setLink(el, event) {\n        //we must first of all check that som text is chosen inside the current component\n        if (!this.checkSelTextValid()) {\n            alert(_tr[\"mlab.dt.api.js.getLink.no_selection\"]);\n            return;\n        }\n\n        //we need to create a temporary link straight away so that we can refer to it later, otherwise the selection will disappear.\n        document.execCommand('createlink', false, \"MLAB_DT_LINK_TEMP\");\n        //we set a data tag, because we'll use an API call if they link to another page, etc\n        $(\".mlab_current_component\").find(\"a[href=MLAB_DT_LINK_TEMP]\").addClass('mc_link mc_text').attr('data-mlab-islink', 1).click(function (e) {\n            e.preventDefault();\n        });\n\n        //we need to request the URL *OR* which page to link to\n        var opt = \"<option value='-1'></option>\";\n        for (pos in mlab.dt.app.page_names) {\n            opt = opt + \"<option value='\" + mlab.dt.app.page_names[pos][\"filename\"] + \"'>\" + mlab.dt.app.page_names[pos][\"title\"] + \"</option>\";\n        }\n        var that = this;\n        var content = $('<div id=\"mlab_dt_link_dialog\">' + '<br><label class=\"mlab_dt_label\"><input type=\"radio\" name=\"mlab_dt_getlink_choice\" value=\"page\" class=\"mlab_dt_input\">' + _tr[\"mlab.dt.api.js.getLink.app_page\"] + '</label><br>' + '<select id=\"mlab_dt_link_app_pages\" class=\"mlab_dt_select\">' + opt + '</select><br>' + '<label class=\"mlab_dt_label\"><input type=\"radio\" name=\"mlab_dt_getlink_choice\" value=\"url\" class=\"mlab_dt_input\">' + _tr[\"mlab.dt.api.js.getLink.url\"] + '</label><br>' + '<input type=\"text\" id=\"mlab_dt_link_app_url\" class=\"mlab_dt_input\">' + '<br>' + '<label class=\"mlab_dt_label\"><input type=\"radio\" name=\"mlab_dt_getlink_choice\" value=\"newpage\" class=\"mlab_dt_input\">' + _tr[\"mlab.dt.api.js.getLink.new_page\"] + '</label><br>' + '<input type=\"text\" id=\"mlab_dt_link_app_new_page\" class=\"mlab_dt_input\">' + '<br>' + '</div>');\n\n        content.append('<button class=\"mlab_dt_button_ok mlab_dt_right\" onclick=\" if (that.updateLink()) {mlab.dt.api.closeAllPropertyDialogs();}\">' + _tr[\"mlab.dt.api.js.getLink.ok\"] + '</button>');\n        content.append('<button class=\"mlab_dt_button_cancel mlab_dt_right\" onclick=\" that.cancelLink();\">' + _tr[\"mlab.dt.api.js.getLink.cancel\"] + '</button>');\n\n        var title = _tr[\"mlab.dt.api.js.getLink.heading\"];\n\n        this.displayPropertyDialog(el, title, content, function () {\n            $(\".qtip-close\").on(\"click\", that.cancelLink);\n        }, null, null, null, false, event);\n    },\n\n    // remove the link from the currently selected text\n    cancelLink: function cancelLink() {\n        $(\".mlab_current_component\").find(\"a[href=MLAB_DT_LINK_TEMP]\").contents().unwrap();\n        mlab.dt.api.closeAllPropertyDialogs();\n    },\n\n    removeLink: function removeLink() {\n        //could use //document.execCommand(\"unlink\", false, false);, but avoiding as does only remove links on selected area\n        var link = this.getSelTextParentLinkElement();\n        if (link) {\n            if ($(link).parents(\"#mlab_editable_area\").length > 0) {\n                $(link).replaceWith($(link).contents());\n            }\n        }\n    },\n\n    /**\r\n      * Requests credentials such as login name and password (for instance, can also be URL to use, database name, etc)\r\n      * These are all just treated as strings and returned as an array of strings. \r\n      * @param {type} el\r\n      * @param {String} component_id\r\n      * @param {type} credentials_required\r\n      * @param {type} cb_function\r\n      * @param {Boolean} edit - if true shows the credential dialogue\r\n      * @param {type} params: this is a js object with key:value pairs, it will ALWAYS contain a paameter called component which is the Mlab component being worked on\r\n      * @returns {Boolean|Array of strings}\r\n     */\n    getCredentials: function getCredentials(el, component_id, credentials_required, cb_function, edit, params) {\n        var default_cred_values = mlab.dt.components[component_id].conf.credential_values;\n        var needinfo = false;\n        var saved_cred_values = this.getVariable(params.component, \"storage_plugin\"); //params.component is always set to the active Mlab component\n        if (saved_cred_values) {\n            saved_cred_values = saved_cred_values[\"credentials\"];\n        }\n\n        //if the values are already saved, either because the default was stored when adding storage plugin, \n        //or because they since been edited or they are missing altogether then we need to request them\n        if (saved_cred_values) {\n            var cred_values = saved_cred_values;\n\n            //nothing saved, and default values exist, so we just save it\n        } else if (default_cred_values) {\n            for (credential in credentials_required) {\n                if (!default_cred_values[credentials_required[credential]]) {\n                    needinfo = true;\n                }\n            }\n            var cred_values = default_cred_values;\n\n            //have no data at all, need to request\n        } else {\n            needinfo = true;\n            var cred_values = new Array();\n        }\n        if (needinfo || edit) {\n            var dlg = $('<div />', { 'id': \"mlab_dt_dialog_credentials\", title: _tr[\"mlab.dt.api.js.getCredentials.dlg.title\"] });\n            dlg.append($('<p />', { text: _tr[\"mlab.dt.api.js.getCredentials.dlg.text\"],\n                'class': 'mlab_dt_text_info' }));\n\n            for (credential in credentials_required) {\n                var credential_id = credentials_required[credential];\n\n                dlg.append($('<label />', { text: credential_id.charAt(0).toUpperCase() + credential_id.slice(1),\n                    'for': 'mlab_dt_dialog_credentials_' + credential_id,\n                    'class': 'mlab_dt_short_label' }));\n                dlg.append($('<input />', { name: 'mlab_dt_dialog_credentials_' + credential_id,\n                    'id': 'mlab_dt_dialog_credentials_' + credential_id,\n                    'class': 'mlab_dt_input',\n                    'value': typeof cred_values[credential_id] === 'undefined' ? \"\" : cred_values[credential_id] }));\n            }\n\n            dlg.append($('<div class=\"mlab_dt_button_small_new_line\">&nbsp;</div>'));\n            dlg.append($('<button class=\"mlab_dt_button mlab_dt_right\">' + _tr[\"mlab.dt.api.js.getCredentials.dlg.save\"] + '</button>'));\n            dlg.find(\"button\").on(\"click\", function () {\n                //TODO verify input here\n                var credentials = {};\n                for (credential in credentials_required) {\n                    credentials[credentials_required[credential]] = $(\"#mlab_dt_dialog_credentials_\" + credentials_required[credential]).val();\n                }\n\n                el.qtip('hide');\n                cb_function(credentials, params);\n            });\n            this.displayPropertyDialog(el, _tr[\"mlab.dt.api.js.getCredentials.dlg.title\"], dlg);\n        } else {\n            cb_function(cred_values, params);\n        }\n    }, // end getCredentials\n\n    /**\r\n     * object with display functionality, primarily used for resizing and highlighting components\r\n     * @type object\r\n     */\n    display: {\n\n        setEditableFocus: function setEditableFocus(el) {\n            var sel = window.getSelection();\n            var range = document.createRange();\n            var html_el = el[0];\n            if (el.text() != \"\") {\n                range.setStart(html_el, 0);\n                range.setEnd(html_el, 0);\n                sel.removeAllRanges();\n                sel.addRange(range);\n            } else {\n                html_el.innerHTML = \"\\xA0\";\n                range.selectNodeContents(html_el);\n                sel.removeAllRanges();\n                sel.addRange(range);\n                document.execCommand('delete', false, null);\n            }\n        },\n\n        /**\r\n         * Updates the aspect ratio setting for a component by updating the data-mlab-ratio setting\r\n         * @param {type} el\r\n         * @param {type} size\r\n         * @returns {undefined}\r\n         */\n        setAspectRatio: function setAspectRatio(el, aspect) {\n            if ([\"4:3\", \"16:9\", \"1:1\"].indexOf(aspect) > -1) {\n                var wrapper = $(el).children(\":first\");\n                if (typeof wrapper.data(\"mlab-sizer\") == \"undefined\") {\n                    $(el).children().wrapAll(\"<div data-mlab-sizer='1' data-mlab-size='medium'></div>\");\n                    wrapper = $(el).children(\":first\");\n                }\n\n                wrapper.attr(\"data-mlab-aspectratio\", aspect);\n                this.parent.closeAllPropertyDialogs();\n                this.parent.setDirty();\n                this.updateDisplay(wrapper);\n            }\n        },\n\n        /**\r\n         * Updates the size setting for a component by updating the data-mlab-size setting\r\n         * Initially this is small, medium, large and fullpage\r\n         * @param {type} el\r\n         * @param {type} size\r\n         * @returns {undefined}\r\n         */\n        setSize: function setSize(el, size) {\n            if ([\"small\", \"medium\", \"large\", \"fullscreen\"].indexOf(size) > -1) {\n                var wrapper = $(el).children(\":first\");\n                if (typeof wrapper.data(\"mlab-sizer\") == \"undefined\") {\n                    $(el).children().wrapAll(\"<div data-mlab-sizer='1' data-mlab-aspectratio='4:3'></div>\");\n                    wrapper = $(el).children(\":first\");\n                }\n\n                $(wrapper).attr(\"data-mlab-size\", size);\n                this.parent.closeAllPropertyDialogs();\n                this.parent.setDirty();\n                this.updateDisplay(wrapper);\n            }\n        },\n\n        /**\r\n         * Updates either a single component, or all components on a page, using data attributes to determine the display\r\n         * The DIV that is updated is an automatically inserted DIV with data-mlab-sizer='1'\r\n         * @param {type} el: Optional, the element to display. If not specified, then update all components\r\n         * @returns {undefined}\r\n         */\n        updateDisplay: function updateDisplay(el) {\n            //was '[data-mlab-size][data-mlab-aspectratio]'\n            var components = typeof el == \"undefined\" ? $('[data-mlab-sizer]') : $(el);\n            var that = this;\n            components.each(function () {\n                var device_width = $('[data-mlab-sizer=\"1\"]').parent().width();\n                var aspect_ratio = $(this).attr(\"data-mlab-aspectratio\").split(\":\");\n                var size = $(this).attr(\"data-mlab-size\");\n                var times = size == \"small\" ? 0.33 : size == \"medium\" ? 0.67 : 1;\n                var comp_id = $(this).parent().data(\"mlab-type\");\n\n                var w = device_width * times;\n                var h = w / aspect_ratio[0] * aspect_ratio[1];\n                $(this).css({ \"width\": w + \"px\", \"height\": h + \"px\" });\n\n                if (typeof that.parent.parent.components[comp_id] != \"undefined\" && typeof that.parent.parent.components[comp_id].code != \"undefined\" && typeof that.parent.parent.components[comp_id].code.onResize != \"undefined\") {\n                    that.parent.parent.components[comp_id].code.onResize(this);\n                };\n            });\n        },\n\n        /**\r\n         * This function takes a rgb color as a prameter and use it to return the inverted color\r\n         *\r\n         * @param String rgb\r\n         * @returns String rgb\r\n        */\n        invertColor: function invertColor(rgbString) {\n            if (typeof rgbString == \"undefined\") {\n                return \"rgb(255, 255, 255);\";\n            }\n            var parts = rgbString.match(/^rgb\\((\\d+),\\s*(\\d+),\\s*(\\d+)\\)$/),\n                i;\n\n            parts.splice(0, 1);\n            for (i = 1; i < 3; ++i) {\n                parts[i] = parseInt(parts[i], 10);\n            }\n            var rgb = 'rgb(';\n            $.each(parts, function (i, item) {\n                rgb += 255 - item + ',';\n            });\n            rgb = rgb.slice(0, -1);\n            rgb += ')';\n            return rgb;\n        },\n\n        /**\r\n         * This function gets the background-color or inherited background-color of an element using jQuery \r\n         *\r\n         * @param jqueryElement\r\n         * @returns String rgb\r\n        */\n        getBackground: function getBackground(jqueryElement) {\n            // Is current element's background color set?\n            var color = jqueryElement.css(\"background-color\");\n\n            if (color !== 'rgba(0, 0, 0, 0)') {\n                // if so then return that color\n                return color;\n            }\n\n            // if not: are you at the body element?\n            if (jqueryElement.is(\"body\")) {\n                // return known 'false' value\n                return false;\n            } else {\n                // call getBackground with parent item\n                return this.getBackground(jqueryElement.parent());\n            }\n        },\n\n        /**\r\n         * Called when we leave a component, either because another one is added/pasted, or they select another component\r\n         */\n        componentBlur: function componentBlur(el) {\n            if (el.length == 0) {\n                return;\n            }\n            el.qtip('hide');\n            var comp_id = el.data(\"mlab-type\");\n            el.removeClass(\"mlab_current_component\");\n            //same for any current sub components, such as a question in a quiz\n            el.find(\"mlab_current_component\").css(\"outline-color\", \"\").removeClass(\"mlab_current_component\");\n            el.find(\".mlab_current_component_editable\").css(\"outline-color\", \"\").removeClass(\"mlab_current_component_editable\").attr(\"contenteditable\", false);\n            window.getSelection().removeAllRanges();\n            el.find(\".mlab_current_component_child\").css(\"outline-color\", \"\").removeClass(\"mlab_current_component_child\");\n\n            if (typeof mlab.dt.components[comp_id].code.onBlur != \"undefined\") {\n                mlab.dt.components[comp_id].code.onBlur(el);\n            }\n        },\n\n        /**\r\n         * Updates either a single component, or all components on a page, using data attributes to determine the display\r\n         * @param {type} el: Optional, the element to display. If not specified, then update all components\r\n         * @returns {true if selected different component, false otherwise}\r\n         */\n        componentHighlightSelected: function componentHighlightSelected(el) {\n            var curComp = $(\"#\" + this.parent.getEditorElement() + \"> div.mlab_current_component\");\n\n            if (el[0] === curComp[0]) {\n                return false;\n            }\n\n            //            if (el[0] !== curComp[0]) {\n            //Delete the outlines and tools for the last current component\n            this.componentBlur(curComp);\n\n            //Set the new current component\n            var pageBgColor = $(\"[data-role=page]\").css(\"background-color\");\n            //inverts the background color\n            var pageBgColorInvert = this.invertColor(pageBgColor);\n            //set the invert color of the background as the border-color for the current selected component\n            $(el).css(\"outline-color\", pageBgColorInvert);\n            $(el).addClass(\"mlab_current_component\");\n            return true;\n            /*            }\r\n            \r\n                        return false;*/\n        },\n\n        /**\r\n         * Highlights controls that have child contols inside them\r\n         * @param {type} sub_el: The element to display. If not specified, then update all components\r\n         * @param {type} editable: Optional, the element to display. If not specified, then update all components\r\n         */\n        componentHighlightSelectedChildren: function componentHighlightSelectedChildren(sub_el, editable, override) {\n            sub_el = $(sub_el);\n\n            if (!$(\".mlab_current_component\").find(\".mlab_current_component_child\").is(sub_el) || override) {\n                $(\".mlab_current_component\").find(\".mlab_current_component_child\").css(\"outline-color\", \"\").removeClass(\"mlab_current_component_child\");\n\n                //gets the childs background color\n                var bgColorC = this.getBackground(sub_el);\n                //inverts the background color\n                var bgColorCInvert = this.invertColor(bgColorC);\n                //set the invert color of the background as the outline-color for the current selected component\n                sub_el.css(\"outline-color\", bgColorCInvert);\n                //set the class to style the selected highlighted child             \n                sub_el.addClass(\"mlab_current_component_child\");\n            }\n\n            if (typeof editable != \"undefined\") {\n                editable = $(editable);\n                //if they have not re-clicked the current ditable element then we deselect old one and select new one\n                if (!$(\".mlab_current_component\").find(\".mlab_current_component_editable\").is(editable)) {\n                    $(\".mlab_current_component\").find(\".mlab_current_component_editable\").css(\"outline-color\", \"\").removeClass(\"mlab_current_component_editable\").attr(\"contenteditable\", false);\n                    if (typeof editable != \"undefined\" && editable.length > 0 && $(editable).prop(\"tagName\").toLowerCase() != \"input\") {\n                        //gets the grandchilds background color\n                        var bgColorGC = this.getBackground(editable);\n                        //inverts the background color\n                        var bgColorGCInvert = this.invertColor(bgColorGC);\n                        //set the invert color of the background as the outline-color for the current selected component\n                        editable.css(\"outline-color\", bgColorGCInvert);\n\n                        editable.addClass(\"mlab_current_component_editable\").attr(\"contenteditable\", true);\n                    }\n                }\n            }\n        }\n    }\n\n};"

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./node_modules/babel-loader/lib/index.js??ref--0-0!./assets/js/mlab.dt.bestpractice.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/raw-loader!./node_modules/babel-loader/lib??ref--0-0!./assets/js/mlab.dt.bestpractice.js ***!
  \***************************************************************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports) {

module.exports = "/*******************************************************************************************************************************\r\n@copyright Copyright (c) 2013-2016, Norwegian Defence Research Establishment (FFI) - All Rights Reserved\r\n@license Proprietary and confidential\r\n@author Arild Bergh/Sinett 3.0 programme (firstname.lastname@ffi.no) rewrite/implementation of all functionality\r\n\r\nUnauthorized copying of this file, via any medium is strictly prohibited \r\n\r\nFor the full copyright and license information, please view the LICENSE_MLAB file that was distributed with this source code.\r\n*******************************************************************************************************************************/\n\n/**\r\n * @abstract Functionality that deals with the template defined best practices\r\n *\r\n */\n\nfunction Mlab_dt_bestpractice() {\n    this.parent = null;\n}\n\nMlab_dt_bestpractice.prototype = {\n\n    //get the object with rules, such as max charavcters, max length, etc\n    //return rules for current template, could be used to track when user has typed in too much text (for instance)\n    //to do preemptive checks (we do post-save check)\n    get_template_rules: function get_template_rules() {\n        return this.parent.app.template_config.components;\n    },\n\n    // final template \"best practices\", we see if there are too many or too few of certain categories of components on a page\n    page_check_content: function page_check_content(component_categories, template_best_practice_msg) {\n\n        var rules = this.parent.app.template_config.components;\n        for (var category in rules) {\n            if (rules[category].hasOwnProperty(\"max\")) {\n                if (component_categories[category] > rules[category].max.count) {\n                    if ($.inArray(rules[category].max.message, template_best_practice_msg) < 0) {\n                        template_best_practice_msg.push(rules[category].max.message);\n                    }\n                }\n            }\n            if (rules[category].hasOwnProperty(\"min\")) {\n                if (component_categories[category] < rules[category].min.count) {\n                    if ($.inArray(rules[category].min.message, template_best_practice_msg) < 0) {\n                        template_best_practice_msg.push(rules[category].min.message);\n                    }\n                }\n            }\n        }\n    },\n\n    /**\r\n     * Runs the \"best practices\" check for a single component, can check if video is too long, if there is too much text, etc, etc\r\n     * @param {type} comp\r\n     * @param {type} comp_id\r\n     * @param {type} component_categories\r\n     * @param {type} template_best_practice_msg\r\n     * @returns {undefined}\r\n     */\n    component_check_content: function component_check_content(comp, comp_id, component_categories, template_best_practice_msg) {\n        var rules = this.parent.app.template_config.components;\n        if (this.parent.components[comp_id].hasOwnProperty(\"conf\") && this.parent.components[comp_id].conf.hasOwnProperty(\"category\")) {\n            var comp_category = this.parent.components[comp_id].conf.category;\n\n            if (!component_categories.hasOwnProperty(comp_category)) {\n                component_categories[comp_category] = 1;\n            } else {\n                component_categories[comp_category]++;\n            }\n\n            //can only do this if component supprts the getContentSize function\n            if (typeof this.parent.components[comp_id].code != \"undefined\") {\n                if (typeof this.parent.components[comp_id].code.getContentSize != \"undefined\") {\n                    var size = this.parent.components[comp_id].code.getContentSize(comp);\n                    if (rules.hasOwnProperty(comp_category)) {\n                        if (rules[comp_category].hasOwnProperty(\"max\")) {\n                            if (size > rules[comp_category].max.size) {\n                                if ($.inArray(rules[comp_category].max.message, template_best_practice_msg) < 0) {\n                                    template_best_practice_msg.push(rules[comp_category].max.message);\n                                }\n                            }\n                        }\n                        if (rules[comp_category].hasOwnProperty(\"min\")) {\n                            if (size < rules[comp_category].min.size) {\n                                if ($.inArray(rules[comp_category].min.message, template_best_practice_msg) < 0) {\n                                    template_best_practice_msg.push(rules[comp_category].min.message);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    } // end prototype\n\n};"

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./node_modules/babel-loader/lib/index.js??ref--0-0!./assets/js/mlab.dt.design.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/raw-loader!./node_modules/babel-loader/lib??ref--0-0!./assets/js/mlab.dt.design.js ***!
  \*********************************************************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports) {

module.exports = "/*******************************************************************************************************************************\r\n@copyright Copyright (c) 2013-2016, Norwegian Defence Research Establishment (FFI) - All Rights Reserved\r\n@license Proprietary and confidential\r\n@author Arild Bergh/Sinett 3.0 programme (firstname.lastname@ffi.no) rewrite/implementation of all functionality\r\n@author Cecilie Jackbo Gran/Sinett 3.0 programme (firstname.middlename.lastname@ffi.no) additional functionality\r\n\r\nUnauthorized copying of this file, via any medium is strictly prohibited \r\n\r\nFor the full copyright and license information, please view the LICENSE_MLAB file that was distributed with this source code.\r\n*******************************************************************************************************************************/\n\n/**\r\n * @abstract Functions to parse HTML for a page and insert it into the editor area \r\n */\n\n/***********************************************************\r\n ******************* Utility functions *********************\r\n************************************************************/\n\n/**\r\n * Standard initialisation of Mlab object which is referred to in several JS files,\r\n * as these files can come down in different order, we must make sure we can use it here.\r\n */\n\nfunction Mlab_dt_design() {\n    this.parent = null;\n}\n\nMlab_dt_design.prototype = {\n    /*\r\n     * DOMParser HTML extension\r\n     * 2012-09-04\r\n     *\r\n     * By Eli Grey, http://eligrey.com\r\n     * Public domain.\r\n     * NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.\r\n     *! @source https://gist.github.com/1129031\r\n     * global document, DOMParser\r\n     */\n\n    domParserWrapper: function domParserWrapper() {\n        \"use strict\";\n\n        var DOMParser_proto = DOMParser.prototype;\n        var real_parseFromString = DOMParser_proto.parseFromString;\n\n        // Firefox/Opera/IE throw errors on unsupported types\n        try {\n            // WebKit returns null on unsupported types\n            if (new DOMParser().parseFromString(\"\", \"text/html\")) {\n                // text/html parsing is natively supported\n                return;\n            }\n        } catch (ex) {}\n\n        DOMParser_proto.parseFromString = function (markup, type) {\n            if (/^\\s*text\\/html\\s*(?:;|$)/i.test(type)) {\n                var doc = document.implementation.createHTMLDocument(\"\");\n                if (markup.toLowerCase().indexOf('<!doctype') > -1) {\n                    doc.documentElement.innerHTML = markup;\n                } else {\n                    doc.body.innerHTML = markup;\n                }\n                return doc;\n            } else {\n                return real_parseFromString.apply(this, arguments);\n            }\n        };\n    },\n\n    /***********************************************************\r\n     *********** Functions to manipulate components ***********\r\n    ************************************************************/\n    component_add: function component_add(id) {\n        if (this.parent.app.locked) {\n            return;\n        }\n\n        //if this control has to be unique we check here to see if one was already added\n        if (this.parent.components[id].conf.unique && $(\"#\" + this.parent.config[\"app\"][\"content_id\"]).find(\"[data-mlab-type='\" + id + \"']\").length > 0) {\n            alert(_tr[\"mlab.dt.design.js.alert.only.one.comp\"]);\n            return;\n        }\n\n        //first we load the relevant CSS/JS files, when that is done we will call component_add_html from the getScriptFiles function.\n        //this is because script files come down at different speeds, and we need them all down before we can add HTML etc to the page\n        this.parent.api.getLibraries(id, true);\n    },\n\n    component_add_html: function component_add_html(id) {\n\n        this.parent.flag_dirty = true;\n        var data_resize = typeof this.parent.components[id].conf.resizeable != \"undefined\" && this.parent.components[id].conf.resizeable == true ? \"data-mlab-aspectratio='4:3' data-mlab-size='medium'\" : \"\";\n        var data_display_dependent = typeof this.parent.components[id].conf.display_dependent != \"undefined\" && this.parent.components[id].conf.display_dependent == true ? \"data-mlab-displaydependent='true'\" : \"\";\n\n        //add a DIV wrapper around all components, makes it easier to move it up/down later\n        //for resizable components we add a second div which is used for settin size of content. Doing this on the outer div messs things up at design time\n        if (data_resize != \"\") {\n            var new_comp = $(\"<div data-mlab-type='\" + id + \"' \" + data_display_dependent + \" style='display: block;'><div data-mlab-sizer='1' \" + data_resize + \" >\" + this.parent.components[id].html + \"</div></div>\");\n        } else {\n            var new_comp = $(\"<div data-mlab-type='\" + id + \"' \" + data_display_dependent + \" style='display: block;'>\" + this.parent.components[id].html + \"</div>\");\n        }\n\n        $(\"#\" + this.parent.config[\"app\"][\"content_id\"]).append(new_comp);\n        new_comp.on(\"click\", function () {\n            var prep_menu = mlab.dt.api.display.componentHighlightSelected($(this));if (prep_menu) {\n                mlab.dt.design.component_menu_prepare();\n            }\n        });\n        new_comp.on(\"input\", function () {\n            mlab.dt.flag_dirty = true;\n        });\n\n        //process all keys if this component wants to manipulate them (i.e. the process_keypress setting exists)\n        if (typeof this.parent.components[id].conf.process_keypress != \"undefined\" && this.parent.components[id].conf.process_keypress) {\n            $(new_comp).keydown(function (e) {\n                mlab.dt.components[$(this).data(\"mlab-type\")].code.onKeyPress(e);\n            });\n        }\n\n        $('.mlab_current_component').qtip('hide');\n\n        if (this.parent.api.display.componentHighlightSelected(new_comp)) {\n            this.component_menu_prepare();\n        }\n\n        //scroll down where the component is added\n        window.scrollTo(0, document.body.scrollHeight);\n\n        //finally we add dependencies, i.e. components that this component depends on\n        if (this.parent.components[id].hasOwnProperty(\"conf\") && this.parent.components[id].conf.hasOwnProperty(\"dependencies\")) {\n            for (component in this.parent.components[id].conf.dependencies) {\n                this.feature_add(this.parent.components[id].conf.dependencies[0], true);\n            }\n        }\n\n        //execute backend code which performs tasks like adding the permissions required to the manifest file, copying include files and so on\n        var url = this.parent.urls.component_added.replace(\"_APPID_\", this.parent.app.id);\n        url = url.replace(\"_COMPID_\", id);\n        var that = this;\n        var comp_id = id;\n\n        var request = $.ajax({\n            type: \"GET\",\n            url: url,\n            dataType: \"json\"\n        });\n\n        //was where XXXX is now:\n        this.parent.drag_origin = 'sortable';\n        //if this is a resizable component we do the initial resizing here\n        if (data_resize != \"\") {\n            this.parent.api.display.updateDisplay($(new_comp).children('[data-mlab-sizer]'));\n        }\n        //if this component requires any credentials we request them here\n        var local_comp = new_comp;\n        var local_comp_id = comp_id;\n        var cred_el = $(\"[data-mlab-comp-tool='credentials']\");\n        if (Object.prototype.toString.call(this.parent.components[comp_id].conf.credentials) === \"[object Array]\") {\n            this.parent.api.getCredentials(cred_el, comp_id, this.parent.components[comp_id].conf.credentials, function (credentials, params) {\n                mlab.dt.design.component_store_credentials(credentials, params);that.component_run_code(local_comp, local_comp_id, true);\n            }, false, { component: new_comp });\n        } else {\n            this.component_run_code(local_comp, local_comp_id, true);\n        }\n        //end XXXX\n\n        request.done(function (result) {\n            if (result.result == \"success\") {\n                //XXXX                \n            } else {\n                alert(result.msg + \"'\\n\\n\" + _tr[\"mlab.dt.design.js.alert.add.comp\"]);\n                $(new_comp).remove();\n            }\n        });\n\n        request.fail(function (jqXHR, textStatus) {\n            alert(_tr[\"mlab.dt.design.js.alert.error.occurred\"] + \": '\" + jqXHR.responseText + \"'\\n\\n\" + _tr[\"mlab.dt.design.js.alert.add.comp\"]);\n            $(new_comp).remove();\n            this.parent.flag_dirty = false;\n        });\n    },\n\n    /**\r\n     * This executes (using eval()) any code for a component that is added to the app\r\n     * @param {type} el = html element we're working on\r\n     * @param {type} comp_id\r\n     * @param {type} created\r\n     * @returns {undefined}\r\n     */\n    component_run_code: function component_run_code(el, comp_id, created) {\n        if (typeof this.parent.components[comp_id] == \"undefined\" || typeof this.parent.components[comp_id].code == \"undefined\") {\n            return;\n        }\n\n        /*        if (!mlab.dt.qtip_tools) {\r\n                    var that = this;\r\n                    window.setTimeout(function() { that.component_run_code(el, comp_id, created) }, 500 );\r\n                    return;\r\n                }\r\n        */\n\n        if (created) {\n            if (this.parent.components[comp_id].conf.experimental) {\n                alert(\"Please be aware that this component is in the testing stage. Do not use it for apps you will share with others.\");\n            }\n            if (typeof this.parent.components[comp_id].code.onCreate != \"undefined\") {\n                this.parent.components[comp_id].code.onCreate(el);\n            }\n            //if the component has an autorun function efined we call it here, with the componet as the parameter\n            if (typeof this.parent.components[comp_id].conf.autorun_on_create == \"string\") {\n                var func = this.parent.components[comp_id].conf.autorun_on_create;\n                eval(\"this.parent.components[comp_id].code.\" + func + \"(el, {currentTarget: mlab.dt.qtip_tools.qtip().tooltip.find('[data-mlab-comp-tool-id=\\\"\" + func + \"\\\"]')[0]});\");\n            }\n        } else if (typeof this.parent.components[comp_id].code.onLoad != \"undefined\") {\n            this.parent.components[comp_id].code.onLoad(el);\n        }\n    },\n\n    /**\r\n     * Runs a random function in the backend code of a component, i.e. in the server_code.php file.\r\n     * @param {type} el\r\n     * @param {type} comp_id\r\n     * @param {type} func_name\r\n     * @param {type} callback\r\n     * @returns {undefined}\r\n     */\n    component_run_backend_code: function component_run_backend_code(el, comp_id, func_name, callback) {\n        //execute specified backend code for this component\n        var url = this.parent.urls.component_run_function.replace(\"_APPID_\", this.parent.app.id);\n        url = url.replace(\"_COMPID_\", comp_id);\n        url = url.replace(\"_FUNCNAME_\", func_name);\n        url = url.replace(\"_PAGENUM_\", this.parent.app.curr_page_num);\n\n        var local_callback = callback,\n            local_el = el;\n\n        $.ajax({\n            type: 'GET',\n            url: url,\n            dataType: 'json',\n            success: function success(data) {\n                if (data.result == \"success\") {\n                    local_callback(local_el, data.html);\n                } else {\n                    local_callback(local_el, \"<h1>failed</h1>\");\n                }\n            },\n            error: function error(_error) {\n                console.log(_error);local_callback(local_el, \"<h1>failed</h1>\");\n            }\n        });\n    },\n\n    component_moveup: function component_moveup(el) {\n        if (typeof el == \"undefined\") {\n            var el = $(\".mlab_current_component\");\n        }\n        if (el.length == 0) {\n            return;\n        }\n        el.fadeOut(500, function () {\n            el.insertBefore(el.prev());\n            var local_el = el;\n            el.fadeIn(500, function () {\n                local_el.qtip(\"api\").reposition(null, false);\n                if (mlab.dt.api.properties_tooltip) {\n                    $(mlab.dt.api.properties_tooltip).qtip(\"api\").reposition(null, false);\n                }\n            });\n        });\n        this.parent.flag_dirty = true;\n    },\n\n    component_movedown: function component_movedown() {\n        if (typeof el == \"undefined\") {\n            var el = $(\".mlab_current_component\");\n        }\n        if (el.length == 0) {\n            return;\n        }\n        el.fadeOut(500, function () {\n            el.insertAfter(el.next());\n            var local_el = el;\n            el.fadeIn(500, function () {\n                local_el.qtip(\"api\").reposition(null, false);\n                if (mlab.dt.api.properties_tooltip) {\n                    $(mlab.dt.api.properties_tooltip).qtip(\"api\").reposition(null, false);\n                }\n            });\n        });\n        this.parent.flag_dirty = true;\n    },\n\n    invert_color: function invert_color(rgb) {\n        rgb = [].slice.call(arguments).join(\",\").replace(/rgb\\(|\\)|rgba\\(|\\)|\\s/gi, '').split(',');\n        for (var i = 0; i < rgb.length; i++) {\n            rgb[i] = (i === 3 ? 1 : 255) - rgb[i];\n        }return rgb.join(\", \");\n    },\n\n    component_delete: function component_delete(cut) {\n        debugger;\n        var that = this;\n        if (cut) {\n            if (el.length == 0) {\n                return;\n            }\n            var comp_id = el.data(\"mlab-type\");\n            if (typeof this.parent.components[comp_id].code.onDelete != \"undefined\") {\n                this.parent.components[comp_id].code.onDelete(el);\n            }\n            mlab.dt.api.closeAllPropertyDialogs();\n            var sel_comp = $(\".mlab_current_component\").prev();\n            if (sel_comp.length == 0) {\n                sel_comp = $(\".mlab_current_component\").next();\n            }\n            $(\".mlab_current_component\").qtip('hide');\n            $(\".mlab_current_component\").remove();\n            if (sel_comp.length > 0) {\n                if (this.parent.api.display.componentHighlightSelected(sel_comp)) {\n                    this.component_menu_prepare();\n                }\n            }\n            this.parent.flag_dirty = true;\n            return true;\n        }\n\n        $(\"#mlab_dialog_delete\").dialog({\n            title: _tr[\"build_app.dialog.delete.title\"],\n            dialogClass: \"no-close\",\n            modal: true,\n            buttons: [{ text: _tr[\"mlab.dt.api.js.getLink.ok\"],\n                click: function click() {\n                    $(this).dialog('destroy');\n                    //Deletes\n                    var el = $(\".mlab_current_component\");\n                    if (el.length == 0) {\n                        return;\n                    }\n                    mlab.dt.api.closeAllPropertyDialogs();\n                    var sel_comp = el.prev();\n                    if (sel_comp.length == 0) {\n                        sel_comp = el.next();\n                    }\n                    el.qtip('hide');\n\n                    //call ondelete in component if it exists\n                    var comp_id = el.data(\"mlab-type\");\n                    if (typeof that.parent.components[comp_id].code.onDelete != \"undefined\") {\n                        that.parent.components[comp_id].code.onDelete(el);\n                    }\n\n                    el.remove();\n                    if (sel_comp.length > 0) {\n                        if (that.parent.api.display.componentHighlightSelected(sel_comp)) {\n                            that.component_menu_prepare();\n                        }\n                    }\n                    that.parent.flag_dirty = true;\n                }\n            }, { text: _tr[\"mlab.dt.api.js.getLink.cancel\"],\n                click: function click() {\n                    $(this).dialog('destroy');\n                    return false;\n                }\n            }]\n        });\n    },\n\n    //gets a html page to show as help for making the component at dt\n    component_help: function component_help() {\n        var comp_id = $(\".mlab_current_component\").data(\"mlab-type\");\n        var extended_name = this.parent.api.getLocaleComponentMessage(comp_id, [\"extended_name\"]);\n        var owner_element = $(\".mlab_help_icon\");\n        var qTipClass = 'mlab_comp_help_qTip';\n        var title = _tr[\"mlab.dt.design.js.qtip.help.title\"] + \" - \" + extended_name;\n        this.parent.api.displayExternalHelpfile(comp_id, title, owner_element, qTipClass);\n    },\n\n    //cut and copy simply takes the complete outerHTML and puts it into a local variable, mlab.dt.clipboard\n    component_cut: function component_cut() {\n        var cut = true;\n        mlab.dt.clipboard = $(\".mlab_current_component\").clone();\n        this.component_delete(cut);\n    },\n\n    component_copy: function component_copy() {\n        mlab.dt.clipboard = $(\".mlab_current_component\").clone();\n    },\n\n    //when they past we need to go through similar checks as we do when adding a component, like is it unique, etc.\n    //also need to attach event handlers, etc, they are lost as \n    component_paste: function component_paste() {\n        var comp_id = mlab.dt.clipboard.data(\"mlab-type\");\n        if (this.parent.components[comp_id].conf.unique && $(\"#\" + this.parent.config[\"app\"][\"content_id\"]).find(\"[data-mlab-type='\" + comp_id + \"']\").length > 0) {\n            alert(_tr[\"mlab.dt.design.js.alert.only.one.comp\"]);\n            return;\n        }\n        //remove selections, highlight, etc for previously selected component\n        this.componentBlur(curComp);\n\n        $(\"#\" + this.parent.config[\"app\"][\"content_id\"]).append(mlab.dt.clipboard);\n        if (this.parent.api.display.componentHighlightSelected(mlab.dt.clipboard)) {\n            this.component_menu_prepare();\n        } else {\n            //TODO - the check does not work.....\n            this.component_menu_prepare();\n        }\n\n        window.scrollTo(0, document.body.scrollHeight);\n        mlab.dt.clipboard.on(\"click\", function () {\n            var prep_menu = mlab.dt.api.display.componentHighlightSelected($(this));if (prep_menu) {\n                mlab.dt.design.component_menu_prepare();\n            }\n        });\n        mlab.dt.clipboard.on(\"input\", function () {\n            mlab.dt.flag_dirty = true;\n        });\n\n        //process all keys if this component wants to manipulate them (i.e. the process_keypress setting exists)\n        if (typeof this.parent.components[comp_id].conf.process_keypress != \"undefined\" && this.parent.components[comp_id].conf.process_keypress) {\n            $(mlab.dt.clipboard).keydown(function (e) {\n                mlab.dt.components[$(this).data(\"mlab-type\")].code.onKeyPress(e);\n            });\n        }\n\n        this.parent.flag_dirty = true;\n    },\n\n    component_edit_credentials: function component_edit_credentials() {\n        var curr_comp = $(\".mlab_current_component\");\n        var cred_el = $(\"[data-mlab-comp-tool='credentials']\");\n        var comp_id = curr_comp.data(\"mlab-type\");\n        if (Object.prototype.toString.call(this.parent.components[comp_id].conf.credentials) === \"[object Array]\") {\n            this.parent.api.getCredentials(cred_el, comp_id, this.parent.components[comp_id].conf.credentials, this.component_store_credentials, true, { component: curr_comp });\n        }\n    },\n\n    /**\r\n     * features are simply components that are not displayed with a GUI\r\n     * they are added to a hidden div on the index page, if we are NOT working on the index page we call a backend function to add this code\r\n     *\r\n     * @returns {undefined}\r\n     */\n\n    feature_add: function feature_add(comp_id, silent) {\n        if ($(this.parent.app.curr_indexpage_html).find(\"#mlab_features_content\").length == 0) {\n            $(this.parent.app.curr_indexpage_html).find(\"body\").append(\"<div id='mlab_features_content' style='display: none;'></div>\");\n        } else {\n            //make sure not duplicate it\n            if ($(this.parent.app.curr_indexpage_html).find(\"#mlab_features_content [data-mlab-type='\" + comp_id + \"']\").length > 0) {\n                if (!silent) {\n                    this.parent.utils.update_status(\"temporary\", _tr[\"mlab.dt.design.js.update_status.feature.already.added\"], false);\n                }\n                return;\n            }\n        }\n        var c = this.parent.components[comp_id].conf;\n        var data_resize = typeof c.resizeable != \"undefined\" && c.resizeable == true ? \"data-mlab-aspectratio='1:1' data-mlab-size='medium'\" : \"\";\n        var data_display_dependent = typeof c.display_dependent != \"undefined\" && c.display_dependent == true || typeof c.resizeable != \"undefined\" && c.resizeable == true ? \"data-mlab-displaydependent='true'\" : \"\";\n\n        $(this.parent.app.curr_indexpage_html).find(\"#mlab_features_content\").append(\"<div data-mlab-type='\" + comp_id + \"' \" + data_resize + \" \" + data_display_dependent + \" >\" + this.parent.components[comp_id].html + \"</div>\");\n\n        var new_feature = $(this.parent.app.curr_indexpage_html).find(\"#mlab_features_content [data-mlab-type='\" + comp_id + \"']\");\n        if (new_feature.length > 0) {\n            this.parent.components[comp_id].code.onCreate(new_feature[0]);\n        }\n\n        //if we are not working on the index page we need to tell the back end to update the index.html file\n        //otherwise this will be lost\n        if (this.parent.app.curr_page_num != 0) {\n            var url = this.parent.urls.feature_add.replace(\"_APPID_\", this.parent.app.id);\n            url = url.replace(\"_COMPID_\", comp_id);\n            if (!silent) {\n                this.parent.utils.update_status(\"callback\", _tr[\"mlab.dt.design.js.update_status.adding.feature\"], true);\n            }\n\n            var that = this;\n            $.get(url, function (data) {\n                if (data.result == \"success\") {\n                    that.parent.utils.update_status(\"temporary\", _tr[\"mlab.dt.design.js.update_status.feature.added\"], false);\n                    $(\"#mlab_features_list [data-mlab-feature-type='\" + data.component_id + \"']\").addClass(\"mlab_item_applied\");\n                } else {\n                    that.parent.utils.update_status(\"temporary\", data.msg, false);\n                }\n            });\n        }\n    },\n\n    /**\r\n     * Function to add or remove storageplugin for a component. \r\n     * Add plugin:\r\n     * storage_plugins are similar to features, except they are linked to individual components and not app as whole\r\n     * They do nothing at design time so here we just call the back end to copy and add the code_rt.js file to the app\r\n     * If credentials = true, we request credentials and store them for the component that this plugin was added to\r\n     * \r\n     * Remove plugin:\r\n     * Just need to set the storage_plugin variable that is stored with the omponent to \"\"\r\n     * \r\n     * @param {type} el: list item showing name of storage plugin = currently clicked HTML element\r\n     * @param {type} storage_plugin_id: unique ID of the storage plugin\r\n     * @param {type} component: the component that wants to use this storage plugin\r\n     */\n    storage_plugin_setup: function storage_plugin_setup(el, storage_plugin_id, component) {\n        if (el.parent().attr(\"data-mlab-selected-storage\")) {\n            mlab.dt.api.setVariable(component, \"storage_plugin\", \"\");\n            el.parent().removeClass(\"mlab_item_applied\").removeAttr(\"data-mlab-selected-storage\");\n        } else {\n            var url = this.parent.urls.storage_plugin_add.replace(\"_APPID_\", this.parent.app.id);\n            url = url.replace(\"_STORAGE_PLUGIN_ID_\", storage_plugin_id);\n            this.parent.utils.update_status(\"callback\", _tr[\"mlab.dt.design.js.update_status.adding.storage.plugin\"], true);\n            var that = this;\n            $.get(url, function (data) {\n                var el = $(\"[data-mlab-get-info='storage_plugins'] [data-mlab-storage-plugin-type='\" + data.storage_plugin_id + \"']\");\n                if (data.result == \"success\") {\n\n                    //first remove data and classes from currently selected plugin, if any\n                    el.parent().siblings().removeClass(\"mlab_item_applied\").removeAttr(\"data-mlab-selected-storage\");\n\n                    that.parent.utils.update_status(\"temporary\", _tr[\"mlab.dt.design.js.update_status.storage.plugin.added\"], false);\n                    el.addClass(\"mlab_item_applied\").attr(\"data-mlab-selected-storage\", \"true\");\n\n                    if (Object.prototype.toString.call(that.parent.components[storage_plugin_id].conf.credentials) === \"[object Array]\") {\n                        that.parent.api.getCredentials(el, storage_plugin_id, that.parent.components[storage_plugin_id].conf.credentials, that.storage_plugin_store_credentials, false, { storage_plugin_id: storage_plugin_id, component: component });\n                    } else {\n                        mlab.dt.api.setVariable(component, \"storage_plugin\", { name: storage_plugin_id });\n                        $(mlab.dt.qtip_tools).qtip().elements.content.find(\"[data-mlab-storage-plugin-type='storage_plugins']\").slideUp();\n                    }\n                } else {\n                    that.parent.utils.update_status(\"temporary\", data.msg, false);\n                }\n            });\n        }\n    },\n\n    /**\r\n     * Callback function which stores the storage_plugin name and the credentials entered\r\n     * @param {type} credentials: \r\n     * @param {type} params\r\n     * \r\n     */\n    component_store_credentials: function component_store_credentials(credentials, params) {\n\n        mlab.dt.api.setVariable(params.component, \"credentials\", credentials);\n    },\n\n    /**\r\n     * Callback function which stores the storage_plugin name and the credentials entered\r\n     * @param {type} credentials: \r\n     * @param {type} params\r\n     * \r\n     */\n    storage_plugin_store_credentials: function storage_plugin_store_credentials(credentials, params) {\n        mlab.dt.api.setVariable(params.component, \"storage_plugin\", { name: params.storage_plugin_id, credentials: credentials });\n    },\n\n    /*\r\n     *\r\n     * @param divs (html/DOM) all divs to edit\r\n     */\n    prepare_editable_area: function prepare_editable_area() {\n        //need to loop through all divs in the editable box after they have been added\n        //and set the styles for dragging/dropping so it works OK\n        var that = this;\n        $(\"#\" + that.parent.config[\"app\"][\"content_id\"] + \"> div\").each(function (index) {\n            $(this).droppable(that.parent.droppable_options).sortable(that.parent.sortable_options).on(\"click\", function () {\n                var prep_menu = mlab.dt.api.display.componentHighlightSelected($(this));if (prep_menu) {\n                    mlab.dt.design.component_menu_prepare();\n                }\n            }).on(\"input\", function () {\n                mlab.dt.flag_dirty = true;\n            });\n\n            comp_id = $(this).data(\"mlab-type\");\n            that.component_run_code($(this), comp_id);\n\n            //process all keys if this component wants to manipulate them (i.e. the process_keypress setting exists)\n            if (typeof that.parent.components[comp_id].conf.process_keypress != \"undefined\" && that.parent.components[comp_id].conf.process_keypress) {\n                $(this).keydown(function (e) {\n                    mlab.dt.components[$(this).data(\"mlab-type\")].code.onKeyPress(e);\n                });\n            }\n        });\n\n        //set draggable/sortable options for the editable area\n        $(\"#\" + that.parent.config[\"app\"][\"content_id\"]).droppable(that.parent.droppable_options).sortable(that.parent.sortable_options);\n    },\n\n    /***********************************************************\r\n    *********** Function to manipulate adaptive menus (those defined by component itself ********\r\n    ************************************************************/\n\n    /* adds component specific menu (images) when a component is added/selected */\n    component_menu_prepare: function component_menu_prepare() {\n        var curr_comp = $(\".mlab_current_component\");\n        if (curr_comp.length < 1) {\n            return;\n        }\n        var conf = this.parent.components[curr_comp.data(\"mlab-type\")].conf;\n        var comp_name = curr_comp.data(\"mlab-type\");\n        var items = new Object();\n        var title = \"\";\n        var menu = $(\"#mlab_toolbar_for_components .mlab_component_context_menu\");\n        var temp_menu = [];\n        var loc = mlab.dt.api.getLocale();\n\n        $(\"#mlab_toolbar_for_components .mlab_component_toolbar_heading\").text(this.parent.api.getLocaleComponentMessage(comp_name, [\"extended_name\"]));\n        menu.html(\"\");\n\n        if (typeof conf.custom != \"undefined\") {\n\n            //preliminary loop to create a lookuptable for the position of tools that handles duplicate order numbers\n            var temp_comp_order = [];\n            for (var index in this.parent.components[comp_name].code) {\n                if (index.substr(0, 7) == \"custom_\") {\n                    title = index.slice(7);\n                    temp_comp_order.push(typeof conf.custom[title][\"order\"] != \"undefined\" ? conf.custom[title][\"order\"] : 0);\n                }\n            }\n            temp_comp_order.sort(function (a, b) {\n                return a - b;\n            });\n\n            for (var index in this.parent.components[comp_name].code) {\n                if (index.substr(0, 7) == \"custom_\") {\n                    title = index.slice(7);\n                    if (typeof conf.custom[title] != \"undefined\") {\n                        var icon = typeof conf.custom[title][\"icon\"] != \"undefined\" ? \"src='\" + conf.custom[title][\"icon\"] + \"'\" : \"class='missing_icon'\";\n                        var tt = this.parent.api.getLocaleComponentMessage(comp_name, [\"custom\", title, \"tooltip\"]);\n\n                        //get unique position\n                        var order = temp_comp_order.indexOf(parseInt(typeof conf.custom[title][\"order\"] != \"undefined\" ? conf.custom[title][\"order\"] : 0));\n                        delete temp_comp_order[order];\n\n                        if (typeof conf.custom[title][\"newline\"] != \"undefined\" && conf.custom[title][\"newline\"] === true) {\n                            var cl = \"mlab_newline\";\n                        } else {\n                            var cl = \"\";\n                        }\n\n                        temp_menu[order] = \"<img onclick='(function(e){ mlab.dt.components.\" + comp_name + \".code.\" + index + \"($(\\\".mlab_current_component\\\"), e);})(event)' \" + \"title='\" + tt + \"' \" + \"class='\" + cl + \"' \" + \"data-mlab-comp-tool-id='\" + index + \"' \" + icon + \" >\";\n                    }\n                }\n            }\n            menu.append(temp_menu.join(\"\"));\n            menu.append(\"<div class='clear'>&nbsp;</div>\");\n        }\n\n        //display credentials selection button, if this supports credentials\n        if (typeof conf.credentials != \"undefined\" && Object.prototype.toString.call(conf.credentials) === \"[object Array]\") {\n            $(\"[data-mlab-comp-tool='credentials']\").removeClass(\"mlab_hidden\");\n        } else {\n            $(\"[data-mlab-comp-tool='credentials']\").addClass(\"mlab_hidden\");\n        }\n\n        //display storage selection list button, if this supports storage\n        if (typeof conf.storage_plugin != \"undefined\" && conf.storage_plugin == true) {\n            $(\"[data-mlab-comp-tool='storage_plugin']\").removeClass(\"mlab_hidden\");\n        } else {\n            $(\"[data-mlab-comp-tool='storage_plugin']\").addClass(\"mlab_hidden\");\n        }\n\n        //display size and aspect ratio selection list buttons, if this supports resizing\n        if (typeof conf.resizeable != \"undefined\" && conf.resizeable == true) {\n            $(\"[data-mlab-comp-tool='comp_size']\").removeClass(\"mlab_hidden\");\n            $(\"[data-mlab-comp-tool='comp_aspect']\").removeClass(\"mlab_hidden\");\n            $(\"#mlab_component_size_list li\").removeClass(\"mlab_item_applied\");\n            $(\"#mlab_component_aspect_list li\").removeClass(\"mlab_item_applied\");\n            //update the menus with the existing selection, if any\n            $(\"#mlab_component_size_list [data-data-mlab-comp-size='\" + curr_comp.data(\"mlab-comp-size\") + \"']\").addClass(\"mlab_item_applied\");\n            $(\"#mlab_component_aspect_list [data-data-mlab-comp-aspect='\" + curr_comp.data(\"mlab-comp-aspect\") + \"']\").addClass(\"mlab_item_applied\");\n        } else {\n            $(\"[data-mlab-comp-tool='comp_size']\").addClass(\"mlab_hidden\");\n            $(\"[data-mlab-comp-tool='comp_aspect']\").addClass(\"mlab_hidden\");\n        }\n\n        //set the qTips posistion after where it is placed in the window \n        var myPosQtip = 'leftTop';\n        var eTop = curr_comp.offset().top; //get the offset top of the element\n        eTop = eTop - $(window).scrollTop();\n\n        if (eTop > 450) {\n            myPosQtip = 'leftBottom';\n        }\n\n        this.parent.qtip_tools = $(curr_comp).qtip({\n            solo: false,\n            content: { text: function text() {\n                    return $('#mlab_toolbar_for_components').clone(true);\n                } },\n            position: { my: myPosQtip, at: 'rightTop', viewport: $(window) },\n            show: { ready: true, modal: { on: false, blur: false } },\n            hide: false,\n            events: {\n                hide: function hide(event, api) {\n                    $(mlab.dt.api.properties_tooltip).qtip('hide');api.destroy();\n                },\n                visible: function visible(event, api) {\n                    $(mlab.dt.qtip_tools).qtip().elements.content.find(\"*\").removeAttr(\"id\");\n                }\n            },\n            style: { classes: 'qtip-light mlab_zindex_regular_tooltip', tip: true }\n\n            /*            show:       { ready: true, modal: { on: false, blur: false } },\r\n                        hide:       false, */\n        });\n\n        $(curr_comp).qtip(\"show\");\n    },\n\n    /*\r\n     * Turn the help in the footer and the footer on and off\r\n     */\n    toggle_footer: function toggle_footer() {\n\n        var footer = $(\".mlab_editor_footer\");\n        var footer_text = $(\".mlab_editor_footer_help\");\n        if (footer.hasClass(\"mlab_transparent\")) {\n            footer.removeClass(\"mlab_transparent\");\n            footer_text.removeClass(\"mlab_hidden\");\n            //TODO toggle title as well\n        } else {\n            footer.addClass(\"mlab_transparent\");\n            footer_text.addClass(\"mlab_hidden\");\n        }\n    } // end design.prototype\n\n};"

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./node_modules/babel-loader/lib/index.js??ref--0-0!./assets/js/mlab.dt.management.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/raw-loader!./node_modules/babel-loader/lib??ref--0-0!./assets/js/mlab.dt.management.js ***!
  \*************************************************************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports) {

module.exports = "/*******************************************************************************************************************************\r\n@copyright Copyright (c) 2013-2016, Norwegian Defence Research Establishment (FFI) - All Rights Reserved\r\n@license Proprietary and confidential\r\n@author Arild Bergh/Sinett 3.0 programme (firstname.lastname@ffi.no) rewrite/implementation of all functionality\r\n@author Cecilie Jackbo Gran/Sinett 3.0 programme (firstname.middlename.lastname@ffi.no) additional functionality\r\n\r\nUnauthorized copying of this file, via any medium is strictly prohibited \r\n\r\nFor the full copyright and license information, please view the LICENSE_MLAB file that was distributed with this source code.\r\n*******************************************************************************************************************************/\n\n/**\r\n * @abstract App level functions \r\n */\n\nfunction Mlab_dt_management() {\n    this.parent = null;\n}\n\nMlab_dt_management.prototype = {\n\n    /*\r\n     * This function will first open the index.html file in an app, this has all the css/js/formatting etc in it.\r\n     * Then it will open the page specified (if it is not == index | 0 )\r\n     * @param {type} app_id\r\n     * @param {type} page_num\r\n     */\n    app_open: function app_open(app_id, page_num) {\n\n        var local_page_num = page_num;\n        var url = this.parent.urls.app_open.replace(\"_ID_\", app_id);\n        url = url.replace(\"_PAGE_NUM_\", 'index');\n        url = url.replace(\"_UID_\", this.parent.uid);\n        url = url.replace(\"_OPEN_MODE_\", \"true\");\n        this.parent.utils.update_status(\"callback\", _tr[\"mlab.dt.management.js.update_status.opening.app\"], true);\n        var that = this;\n        var local_app_id = app_id;\n\n        $.get(url, function (data) {\n            if (data.result == \"success\") {\n                that.index_page_process(data.html, local_page_num == \"0\" || local_page_num == \"index\" || that.parent.app.page_names.length == 1);\n\n                //set the compiler qTip to show QR code and link when hower over compile icon\n                //TODO: Burde endre ikonet til grønt eller noe....\n                //TODO: use api.elements.tooltip\n                //any existing compiled files for this app\n                mlab.dt.app.compiled_files = data.compiled_files;\n\n                $.each(mlab.dt.config.compiler_service.supported_platforms, function (index, platform) {\n                    if (typeof mlab.dt.app.compiled_files[platform] != \"undefined\") {\n                        //TODO: skille ut de 3 neste linjene som egen funksjon - dette skal brukes flere steder....\n                        var text = document.getElementsByTagName(\"base\")[0].href.slice(0, -1) + \"_compiled/\" + mlab.dt.app.compiled_files[platform];\n                        $('#mlab_download_qr_link_' + platform).empty().qrcode({ text: text, size: 150, background: \"#ffffff\", foreground: \"#000000\", render: \"table\" });\n                        $('#mlab_download_link_' + platform).html(\"<b>URL</b>:</br>\" + text);\n\n                        /*                        $('#mlab_download_'+ platform + '_icon').qtip({\r\n                                                    hide:{ delay:500, fixed:true },//give a small delay to allow the user t mouse over it.\r\n                                                    content: {text: function(){ return $(\"[data-mlab-download-link-info='\" + platform + \"']\").html()},\r\n                                                             title: { text: \"Download to \" + platform } },\r\n                                                    style: { classes: \"mlab_qtip_tooltip mlab_qtip_menu_tooltip\", tip: true }\r\n                                                });*/\n                    }\n                });\n\n                $(\"#mlab_statusbar_permanent\").html(mlab.dt.app.name);\n                //update the list of features we have added to this app\n                $(\"#mlab_features_list li\").removeClass(\"mlab_item_applied\");\n                $(that.parent.app.curr_indexpage_html).find(\"#mlab_features_content [data-mlab-type]>\").each(function () {\n                    $(\"#mlab_features_list [data-mlab-feature-type='\" + $(this).parent().data(\"mlab-type\") + \"']\").addClass(\"mlab_item_applied\");\n                });\n\n                //if they are opening the app with a blank page and no components on the index page, let's assume they are opening a new app, and we'll ask for the title of the page\n                if (data.only_index && $(\"#\" + that.parent.config[\"app\"][\"content_id\"]).children().length == 0) {\n                    var title = prompt(_tr[\"mlab.dt.management.js.prompt.title.front.page\"], that.parent.app.curr_pagetitle);\n                    if (title != null) {\n                        that.parent.app.curr_pagetitle = title;\n                        $(\"#mlab_page_control_title\").text(that.parent.app.curr_pagetitle);\n                        that.parent.flag_dirty = true;\n                    }\n                }\n\n                //if they are not opening the index page we need to call backend again to load the page they want to open\n                if (local_page_num != \"0\" && local_page_num != \"index\" && !data.only_index) {\n                    that.page_open_process(data.app_id, local_page_num);\n                } else {\n                    if (data.lock_status == \"locked\") {\n                        that.parent.app.locked = true;\n                        $(\"#\" + that.parent.config[\"app\"][\"content_id\"]).fadeTo('slow', .6);\n                        $(\"div.container\").append('<div id=\"mlab_editor_disabled\" style=\"background-color: gray; position: absolute;top:110px;left:0;width: 100%;height:100%;z-index:2;opacity:0.4;filter: alpha(opacity = 50); background-image: url(/img/page_locked.png); background-repeat: no-repeat; background-position: 95% 2%;\"></div>');\n                    } else {\n                        that.parent.app.locked = false;\n                        $(\"#mlab_editor_disabled\").remove();\n                        $(\"#\" + that.parent.config[\"app\"][\"content_id\"]).fadeTo('slow', 1);\n                    }\n\n                    that.parent.utils.update_status(\"temporary\", _tr[\"mlab.dt.management.js.update_status.ready\"], false);\n                    $(\"#mlab_overlay\").slideUp();\n                    that.parent.app.locked = data.lock_status == \"locked\";\n                    that.parent.utils.timer_start();\n                }\n            } else {\n                that.parent.utils.update_status(\"temporary\", data.msg, false);\n            }\n\n            //set the trap for the paste function so we force plain text\n            $(\"#\" + mlab.dt.config[\"app\"][\"content_id\"]).on(\"paste\", function (e) {\n                // stop original paste from happening\n                e.preventDefault();\n\n                //if they are not allowed to paste into this component we quit\n                var comp_id = $(\".mlab_current_component\").data(\"mlab-type\");\n                if (typeof mlab.dt.components[comp_id].conf.paste_allowed == \"undefined\" || mlab.dt.components[comp_id].conf.paste_allowed === false) {\n                    return;\n                }\n\n                //obtain plain text\n                var text = e.originalEvent.clipboardData.getData(\"text/plain\");\n\n                //insert via built in exec commands\n                document.execCommand(\"insertHTML\", false, text);\n                //add a text in the footer to explain that the formating is lost when you paste text\n                $(\".mlab_editor_footer_help\").text(_tr[\"build_app.footer.help.paste.text\"]);\n                //hide the text after 5 seconds\n                setTimeout(function () {\n                    $(\".mlab_editor_footer_help\").text(\"\");\n                }, 5000);\n\n                mlab.dt.flag_dirty = true;\n            });\n        });\n    },\n\n    /*\r\n     * Calls a function on the backend that returns a URL to the file to download.\r\n     * If it is not compiled we will compile it first.\r\n     * @returns void\r\n     */\n    app_download: function app_download() {\n        that = this;\n        this.page_save(function () {\n            that.app_download_process();\n        });\n    },\n\n    app_download_process: function app_download_process() {\n        this.parent.utils.update_status(\"callback\", _tr[\"mlab.dt.management.js.update_status.retrieving.app\"], true);\n        var url = this.parent.urls.app_download.replace(\"_ID_\", this.parent.app.id);\n        var that = this;\n        $.get(url, function (data) {\n            that.parent.utils.update_status(\"completed\");\n            if (data.result == \"success\") {\n                full_url = window.location.origin + data.url;\n                $(\"#mlab_download_qr2\").empty().qrcode({ text: full_url, render: \"table\" }).show().append(\"<br>\").append(\"<a href='\" + full_url + \"'>\" + _tr[\"mlab.dt.management.js.app_download_process.1\"] + \": \" + full_url + \"</a>\").append(\"<br>\").append(\"<a href='mailto:\" + that.parent.user_email + \"?subject=Link&body=\" + _tr[\"mlab.dt.management.js.app_download_process.2\"] + \": \" + encodeURI(full_url) + \"'>\" + _tr[\"mlab.dt.management.js.app_download_process.3\"] + \"</a>\");\n            } else {\n                $(\"#mlab_download_qr2\").empty().append(\"<p>\" + _tr[\"mlab.dt.management.js.app_download_process.4\"] + \": \" + data.msg + \"</p>\").show();\n            }\n            /*       $(\"#mlab_download_qr_field\").qtip({\r\n                       content: {text: $(\"#mlab_download_qr2\").html() },\r\n                       position: { my: 'top right', at: 'bottom right', target: $(\"#mlab_download_qr_field\") },\r\n                       show: { ready: true, modal: { on: false, blur: false } },\r\n                       hide: 'unfocus',\r\n                       style: { classes: 'qtip-tipped', tip: true }});\r\n               */\n        });\n\n        that.parent.utils.timer_start();\n    },\n\n    app_submit_to_market: function app_submit_to_market() {\n        alert(_tr[\"mlab.dt.management.js.app_submit_to_market\"]);\n    },\n\n    //remove locks, just a backup if something goes wrong\n    app_remove_locks: function app_remove_locks() {\n        this.parent.utils.update_status(\"temporary\", _tr[\"mlab.dt.management.js.update_status.unlocking.pages\"], true);\n        $.get(this.parent.urls.app_unlock);\n        $(\"#\" + this.parent.config[\"app\"][\"content_id\"]).fadeTo('slow', 1);\n        $(\"#mlab_editor_disabled\").remove();\n        this.parent.app.locked = false;\n    },\n\n    /**\r\n     * Function to update content of GUI elements with the current app's metadata\r\n     */\n    app_update_gui_metadata: function app_update_gui_metadata(only_list) {\n\n        //List of all pages\n        //#mlab_existing_pages is a <div> which is populated with a <ol> with a <li> element for each page\n        var list = $('<ol></ol>'),\n            span = \"\";\n        curr_filename = this.page_filenum2filename(this.parent.app.curr_page_num);\n\n        //loop through list of pages in this app and display them\n        for (i in this.parent.app.page_names) {\n            if (i == 0) {\n                //always index.html file \n                page_num = 0;\n                span = \"<span class='mlab_not_copy_file'>&nbsp;</span>\";\n            } else {\n                page_num = parseInt(this.parent.app.page_names[i][\"filename\"]);\n                span = \"<span class='mlab_copy_file' title='\" + _tr[\"mlab.dt.management.js.app_update_gui_metadata.copy.pages\"] + \" \\\"\" + this.parent.app.page_names[i][\"title\"] + \"\\\"' onclick='mlab.dt.management.page_copy(\\\"\" + page_num + \"\\\");' >&nbsp;</span>\";\n            }\n\n            if (this.parent.app.page_names[i][\"filename\"] == curr_filename) {\n                list.append(\"<li data-mlab-page-num='\" + page_num + \"' data-mlab-page-open='\" + page_num + \"'>\" + span + this.parent.app.page_names[i][\"title\"] + \"</li>\");\n            } else {\n                list.append(\"<li data-mlab-page-num='\" + page_num + \"'>\" + span + \"<a data-mlab-page-open='\" + page_num + \"' href='javascript:mlab.dt.management.page_open(\" + this.parent.app.id + \", \\\"\" + page_num + \"\\\");'>\" + this.parent.app.page_names[i][\"title\"] + \"</a></li>\");\n            }\n        }\n\n        $(\"#mlab_existing_pages\").html(list);\n\n        //make page list sortable to reset pages\n        $(\"#mlab_existing_pages ol\").sortable({\n            items: \"> li:gt(0)\",\n            update: function update(event, ui) {\n                mlab.dt.management.page_reorder(event, ui);\n            }\n        }).disableSelection();\n\n        if (only_list) {\n            return;\n        }\n\n        //Various app meta data\n        $(\"#mlab_edit_app_title\").text(this.parent.app.name);\n        $(\"#mlab_edit_app_description\").text(this.parent.app.description);\n        $(\"#mlab_edit_app_keywords\").text(this.parent.app.keywords);\n        $(\"#mlab_edit_app_tags\").text(this.parent.app.tags);\n    },\n\n    /*********************************************************************************************\r\n     *********** Functions to parse HTML for a page and insert it into the editor area ***********\r\n     *********************************************************************************************/\n\n    /* this function processes the index page that was retrieved.\r\n     *\r\n     * It does the following:\r\n        Remove old HTML from the editing div (mlab_editor_chrome)\r\n        Remove old stylesheets from previously edited page from *this page*\r\n        Add new stylesheets from page that is opened for editing to *this page*\r\n        Extract BODY and insert content into mlab_editor_chrome\r\n        Process the top level DIVs inside DIV with ID = this.parent.config[\"app\"][\"content_id\"] (by default mlab_editable_area) so they are moveable/sortable\r\n    */\n\n    index_page_process: function index_page_process(page, is_final_destination) {\n        var comp_id, temp_comp, temp_link;\n        var temp_stylesheets = \"\";\n        var start_dir = this.parent.config.urls.app + this.parent.app.path + \"/\" + this.parent.app.active_version + \"/\";\n\n        //parse doc into a variable\n        var doc = new DOMParser().parseFromString(page, \"text/html\");\n\n        //check if it has editable area, if not we cannot continue\n        if (doc.getElementById(this.parent.config[\"app\"][\"content_id\"]) == null) {\n            alert(_tr[\"mlab.dt.management.js.index_page_process.alert.1\"] + \" \" + this.parent.config[\"app\"][\"content_id\"] + \", \" + _tr[\"mlab.dt.management.js.index_page_process.alert.2\"]);\n            return;\n        }\n\n        //set the base href to the folder of the app\n        document.getElementsByTagName(\"base\")[0].href = start_dir;\n\n        //remove old stuff\n        $(\"#mlab_editor_chrome\").empty();\n        $(\"link[rel=stylesheet][href^='css']\").remove();\n\n        //store different parts of doc for easy access/manipulation\n        var head = doc.getElementsByTagName(\"head\")[0];\n        var divs = doc.getElementById(this.parent.config[\"app\"][\"content_id\"]).cloneNode(true).childNodes;\n\n        //assign vars to current app var, we remove all elements that are editable so we have clean HTML to add our edited content to\n        //this HTML chunk will include HTML header + all body content outside the editable area, plus the empty div for the editable area\n        var content = doc.getElementById(this.parent.config[\"app\"][\"content_id\"]);\n        while (content.firstChild) {\n            content.removeChild(content.firstChild);\n        }\n        var body = doc.getElementsByTagName(\"body\")[0].cloneNode(true);\n\n        var stylesheets = head.getElementsByTagName(\"link\");\n\n        //insert stylesheets, but not when preview it, hence we look for the presence of the RT stylesheet\n        //TODO use variable instead\n        for (var i = 0; i < stylesheets.length; i++) {\n            temp_link = stylesheets[i].getAttribute(\"href\");\n            if (temp_link.indexOf(\"style_rt.css\") < 0) {\n                temp_stylesheets = temp_stylesheets + \"<link rel='stylesheet' href='\" + temp_link + \"' type='text/css'>\" + \"\\n\";\n            }\n        }\n        $(\"head link[rel='stylesheet']\").last().after(temp_stylesheets);\n\n        //here we insert the body MINUS the editable area (which was just removed) which is stored in the divs variable, into the editor_chrome\n        $(\"#mlab_editor_chrome\").append(body.innerHTML);\n\n        //now we need to make the internal code editable, but only if they actually want to edit this page\n        if (is_final_destination) {\n            $(\"#\" + this.parent.config[\"app\"][\"content_id\"]).html(divs);\n            this.parent.api.getAllLibraries();\n            this.parent.design.prepare_editable_area();\n        }\n\n        this.parent.app.curr_indexpage_html = doc;\n\n        //Page name is picked up from title tag in head\n        this.parent.app.curr_pagetitle = head.getElementsByTagName(\"title\")[0].innerText;\n        this.parent.app.curr_page_num = 0;\n        $(\"#mlab_page_control_title\").text(this.parent.app.curr_pagetitle);\n\n        this.app_update_gui_metadata();\n\n        //finally we need to initialise the jQuery mobile stuff on the page we loaded, otherwise it will not display correctly\n        try {\n            $.mobile.initializePage();\n        } catch (err) {\n            console.log(err.message);\n        }\n\n        mlab.dt.api.display.updateDisplay();\n\n        //JS to fix the toolbars in a jQuery mobile page\n        var border_width = parseInt($(\"#mlab_editor_chrome\").css(\"margin-bottom\")) * 2 + parseInt($(\"#mlab_editor_chrome\").css(\"border-bottom-width\"));\n        $(\"[data-role=header]\").css({ \"position\": \"absolute\", \"z-index\": 0 });\n        $(\"[data-role=footer]\").css({ \"position\": \"absolute\", \"bottom\": $(\"[data-role=footer]\").height() + border_width + \"px\" });\n        $(\"[data-role=page]\").css({ \"width\": \"100%\", \"height\": \"100%\", \"min-height\": \"\", \"position\": \"absolute\", \"margin\": \"0\", \"padding\": \"0\", \"padding-top\": $(\"[data-role=header]\").height() + \"px\", \"padding-bottom\": $(\"[data-role=footer]\").height() + \"px\" });\n\n        //TODO: hack de luxe, refreshes images that for some reason can't be seen\n        $(\"#panel_left\").css(\"background-image\", $(\"#panel_left\").css(\"background-image\"));\n        $(\"#panel_right\").css(\"background-image\", $(\"#panel_right\").css(\"background-image\"));\n\n        //stop links from being opened up in design mode, links always have this data attribute\n        $(\"#\" + this.parent.config[\"app\"][\"content_id\"]).find(\"[data-mlab-islink='1']\").click(function (e) {\n            e.preventDefault();\n        });\n    },\n\n    /* this function processes a regular page that was retrieved.\r\n     *\r\n     * It does the following:\r\n        Remove old HTML from the internal editing div (this.parent.config[\"app\"][\"content_id\"])\r\n        Extract title and save it to JS var\r\n        Extract BODY and insert content into this.parent.config[\"app\"][\"content_id\"]\r\n        Process the top level DIVs inside DIV with ID = this.parent.config[\"app\"][\"content_id\"] (by default mlab_editable_area) so they are moveable/sortable\r\n    */\n\n    regular_page_process: function regular_page_process(page, page_num) {\n        var comp_id, temp_comp, temp_link;\n        var start_dir = this.parent.config.urls.app + this.parent.app.path + \"/\" + this.parent.app.active_version + \"/\";\n\n        //remove old stuff\n        $(\"#\" + this.parent.config[\"app\"][\"content_id\"]).html(\"\");\n\n        //a page may have failed to save, in this case we create an empty page here, then everything works\n        if (page == \"\") {\n            page = this.parent.config[\"app\"][\"html_header\"].replace(\"%TITLE%\", \"Title\") + this.parent.config[\"app\"][\"html_footer\"];\n            page = page.replace(/\\\\n/g, \"\\n\");\n        }\n        //\n        //parse doc into variables\n        var doc = new DOMParser().parseFromString(page, \"text/html\");\n        var head = doc.getElementsByTagName(\"head\")[0];\n        var body = doc.getElementsByClassName(\"mlab_main_body_content\")[0].cloneNode(true);\n\n        //Page name is picked up from title tag in head\n        this.parent.app.curr_pagetitle = head.getElementsByTagName(\"title\")[0].innerText;\n        this.parent.app.curr_page_num = page_num;\n        $(\"#mlab_page_control_title\").text(this.parent.app.curr_pagetitle);\n\n        this.app_update_gui_metadata();\n\n        //add body content\n        $(\"#\" + this.parent.config[\"app\"][\"content_id\"]).html(body.innerHTML);\n        this.parent.api.getAllLibraries();\n        this.parent.design.prepare_editable_area();\n\n        try {\n            $.mobile.initializePage();\n        } catch (err) {\n            console.log(err.message);\n        }\n        mlab.dt.api.display.updateDisplay();\n        //stop links from being opened up in design mode, links always have this data attribute\n        $(\"#\" + this.parent.config[\"app\"][\"content_id\"]).find(\"[data-mlab-islink='1']\").click(function (e) {\n            e.preventDefault();\n        });\n    },\n\n    /***********************************************************\r\n     ************** Functions to manipulate pages **************\r\n    ************************************************************/\n\n    /*\r\n     * Utility function to find index in mlab.dt.app.page_names by filename\r\n     * @param string|int filename/number \r\n     * @returns int index\r\n     */\n    page_filenum2index: function page_filenum2index(page_id) {\n        if (typeof page_id != \"number\") {\n            page_id = parseInt(page_id);\n        }\n        if (page_id == 0) {\n            page_id = \"index.html\";\n        } else {\n            page_id = (\"000\" + page_id).slice(-3) + \".html\";\n        }\n        for (var i in this.parent.app.page_names) {\n            if (this.parent.app.page_names[i].filename == page_id) {\n                return i;\n            }\n        }\n    },\n\n    /*\r\n     * Utility function to create a filename from a number\r\n     * @param string|int filename/number \r\n     * @returns int index\r\n     */\n    page_filenum2filename: function page_filenum2filename(page_id) {\n        if (typeof page_id != \"number\") {\n            page_id = parseInt(page_id);\n        }\n        if (page_id == 0) {\n            return \"index.html\";\n        } else {\n            return (\"000\" + page_id).slice(-3) + \".html\";\n        }\n    },\n\n    /*\r\n     * Move the selected page to a new position int he app, this is done on backend by renaming the actual file\r\n     * So if you want to move page 2 to 10, 3 - 9  will be minus one, 2 will be 10\r\n     * @param {type} event jquery event info\r\n     * @param {type} ui jquery ui info\r\n     * @returns {undefined}\r\n     */\n    page_reorder: function page_reorder(event, ui) {\n\n        //bail if it has not been moved\n        if (ui.item.find(\"a\").data(\"mlab-page-open\") == parseInt(mlab.dt.app.page_names[ui.item.index()].filename)) {\n            console.log(\"not moved\");\n            return;\n        }\n        that = this;\n        //turn off automatic saving before moving file\n        this.page_save(function () {\n            mlab.dt.utils.timer_stop();that.page_reorder_process(event, ui);\n        }, undefined, true);\n    },\n\n    page_reorder_process: function page_reorder_process(event, ui) {\n        var app_id = this.parent.app.id;\n        var from_page = ui.item.data(\"mlab-page-num\"); //the filenames are stored in the data tag mlab-page-num\n        var to_page = parseInt(mlab.dt.app.page_names[ui.item.index()].filename); //calculate the page it will push down by using the new index of the moved item and look up filename in internal page_names array \n        var that = this;\n\n        var url = this.parent.urls.page_reorder.replace(\"_ID_\", app_id);\n        url = url.replace(\"_FROM_PAGE_\", from_page);\n        url = url.replace(\"_TO_PAGE_\", to_page);\n        url = url.replace(\"_UID_\", this.parent.uid);\n\n        this.parent.utils.update_status(\"callback\", _tr[\"mlab.dt.management.js.update_status.reordering.page\"], true);\n\n        $.get(url, function (data) {\n            that.parent.utils.update_status(\"completed\");\n            if (data.result == \"success\") {\n                //update the list of pages to the new order, the page numbers have changed so we need to do that\n                that.parent.app.page_names = data.page_names;\n            } else {\n                alert(\"Unable to move page\");\n            }\n            that.app_update_gui_metadata();\n            mlab.dt.utils.timer_start();\n        });\n    },\n\n    /**\r\n     * Retrieve content of a page from server and insert it into the editor area\r\n     * First line is a pattern from Symfony routing so we can get the updated version from symfony when we change it is YML file\r\n     */\n    page_open: function page_open(app_id, page_num) {\n        that = this;\n        this.page_save(function () {\n            that.page_open_process(app_id, page_num);\n        });\n    },\n\n    page_open_process: function page_open_process(app_id, page_num) {\n\n        this.parent.utils.update_status(\"callback\", _tr[\"mlab.dt.management.js.update_status.opening.page\"], true);\n\n        var url = this.parent.urls.page_get.replace(\"_ID_\", app_id);\n        url = url.replace(\"_PAGE_NUM_\", page_num);\n        url = url.replace(\"_UID_\", this.parent.uid);\n\n        //here we hide the tools for components until they select a control\n        if (typeof this.parent.qtip_tools != \"undefined\") {\n            $(this.parent.qtip_tools).qtip('hide');\n            this.parent.qtip_tools = undefined;\n            if (typeof this.parent.api.properties_tooltip != \"undefined\") {\n                $(this.parent.api.properties_tooltip).qtip('hide');\n                this.parent.api.properties_tooltip = undefined;\n            }\n        }\n\n        var that = this;\n\n        $.get(url, function (data) {\n            if (data.result == \"success\") {\n                that.parent.utils.update_status(\"completed\");\n                that.parent.utils.update_status(\"permanent\", that.parent.app.name);\n                $(\"#mlab_page_control_title\").text(that.parent.app.curr_pagetitle);\n                if (data.page_num_sent == 0 || data.page_num_sent == \"index\") {\n                    that.index_page_process(data.html, true);\n                } else if (data.page_num_sent == \"last\" && data.page_num_real == 0) {\n                    that.parent.utils.timer_start();\n                    if ($(\"#mlab_overlay\").is(':visible')) {\n                        $(\"#mlab_overlay\").slideUp();\n                    }\n                    return;\n                } else {\n                    that.regular_page_process(data.html, data.page_num_real);\n                    var path = window.location.pathname.split(\"/\");\n                    path[path.length - 3] = data.app_id;\n                    path[path.length - 2] = data.page_num_real;\n                    history.pushState({ id: data.app_id, page: data.page_num_real }, that.parent.app.curr_pagetitle, path.join(\"/\"));\n                }\n\n                if (data.lock_status == \"locked\") {\n                    that.parent.app.locked = true;\n                    $(\"#\" + that.parent.config[\"app\"][\"content_id\"]).fadeTo('slow', .6);\n                    $(\"div.container\").append('<div id=\"mlab_editor_disabled\" style=\"background-color: gray; position: absolute;top:110px;left:0;width: 100%;height:100%;z-index:2;opacity:0.4;filter: alpha(opacity = 50); background-image: url(/img/page_locked.png); background-repeat: no-repeat; background-position: 95% 2%;\"></div>');\n                } else {\n                    that.parent.app.locked = false;\n                    $(\"#mlab_editor_disabled\").remove();\n                    $(\"#\" + that.parent.config[\"app\"][\"content_id\"]).fadeTo('slow', 1);\n                }\n\n                if ($(\"#mlab_overlay\").is(':visible')) {\n                    $(\"#mlab_overlay\").slideUp();\n                }\n\n                //turn off clikability of links\n                $(\"#mlab_editable_area\").find(\"a\").click(function (e) {\n                    e.preventDefault();\n                });\n\n                that.parent.utils.timer_start();\n            } else {\n                that.parent.utils.update_status(\"temporary\", data.msg, false);\n            }\n        });\n    },\n\n    /**\r\n     * Call a backend python script that uses OpenOffice to convert PPT and DOC to individual pages\r\n     */\n    file_import: function file_import() {\n        that = this;\n        this.page_save(function () {\n            that.file_import_process();\n        });\n    },\n\n    file_import_process: function file_import_process() {\n        this.parent.utils.update_status(\"callback\", _tr[\"mlab.dt.management.js.update_status.importing.file\"], true);\n\n        var form = $('#mlab_form_import_file')[0]; // You need to use standard javascript object here\n        var formData = new FormData(form);\n\n        $.ajax({\n            url: this.parent.urls.file_import,\n            data: formData,\n            type: 'POST',\n            contentType: false,\n            processData: false,\n            success: function success(json) {\n                that.parent.utils.update_status(\"completed\");\n                console.log(\"Status returned: \" + json.app_status);\n                if (json.result == \"success\") {\n                    mlab.dt.utils.update_status(\"temporary\", \"\", false);\n                    that.parent.app.page_names = data.page_names;\n                    that.app_update_gui_metadata();\n                }\n            }\n        });\n    },\n\n    /**\r\n     * This will update the title of the currently open page and also update relevant items other places\r\n     */\n    page_update_title: function page_update_title() {\n        if (this.parent.app.locked) {\n            alert(_tr[\"mlab.dt.management.js.page_update_title.alert.page.locked\"]);\n            return;\n        }\n\n        var page_index = this.page_filenum2index(this.parent.app.curr_page_num);\n\n        this.parent.flag_dirty = true;\n        this.parent.app.curr_pagetitle = $(\"#mlab_page_control_title\").text();\n        this.parent.app.page_names[page_index][\"title\"] = this.parent.app.curr_pagetitle;\n        $(\"#mlab_page_control_title\").text(this.parent.app.curr_pagetitle);\n        this.app_update_gui_metadata(true);\n    },\n\n    /**\r\n     * This is the save function, it is called in three possible ways:\r\n     * 1: When a user clicks the save button\r\n     * 2: When the save timer (this.parent.utils.timer_save) kicks in\r\n     * 3: When a function that has to save the page first is executed.\r\n     *\r\n     * In case 3 th fnc argument is specified and when the save is completed and the AJAX callback function is called this function will be executed.\r\n     * This way we are sure that page related variables are not outdated if the save function takes a long time to complete on the server.\r\n     *\r\n     * to save a page we need to reassemble it,\r\n     * first clone current body from the editor (and give it a new ID!)\r\n     * clean it up using the onSave function for each component\r\n     * then pick up doc variable which has empty body, then insert the cleaned elements\r\n     * finally convert to text to send back\r\n     * @param {type} fnc\r\n     * @returns {undefined}\r\n     */\n    page_save: function page_save(fnc, override, no_display_update) {\n        this.parent.utils.timer_stop();\n        var require_save = true;\n        var res = false;\n        this.parent.counter_saving_page++;\n\n        //cannot save if locked\n        if ($(\"#mlab_editor_disabled\").length > 0) {\n            console.log('Page locked, did not save');\n            require_save = false;\n        }\n\n        //this is called from a timer, so we also need to check if an app has been created, etc\n        //also if any changes have occurred\n        if (typeof this.parent.app.curr_page_num == \"undefined\" || typeof this.parent.app.id == \"undefined\") {\n            require_save = false;\n        }\n\n        if (!this.parent.flag_dirty && typeof override == \"undefined\") {\n            require_save = false;\n        }\n\n        if (!require_save && typeof fnc != 'undefined') {\n            return fnc();\n        } else if (!require_save) {\n            this.parent.utils.timer_start();\n            return false;\n        }\n\n        //prepare various variables\n        this.parent.utils.update_status(\"callback\", _tr[\"mlab.dt.management.js.update_status.storing.page\"], true);\n        var curr_el = $(\"#\" + this.parent.config[\"app\"][\"content_id\"] + \" .mlab_current_component\");\n        curr_el.removeClass(\"mlab_current_component\");\n        var app_id = this.parent.app.id;\n        var page_num = this.parent.app.curr_page_num;\n        var page_content = \"\";\n        var component_categories = new Object();\n        var template_best_practice_msg = new Array();\n        var url = this.parent.urls.page_save.replace(\"_ID_\", app_id);\n        url = url.replace(\"_PAGE_NUM_\", page_num);\n        url = url.replace(\"_CHECKSUM_\", this.parent.app.app_checksum);\n\n        //this loop is a: picking up the cleaned HTML for each component,\n        //(this is done by calling the onSave unction which strips away anything we are not interested in)\n        // and b: checking if the component transgresses any of the rules for the template\n        var that = this;\n        $(\"#\" + that.parent.config[\"app\"][\"content_id\"]).children(\"div\").each(function () {\n            var comp_id = $(this).data(\"mlab-type\");\n            if (typeof that.parent.components[comp_id].code !== \"undefined\" && typeof that.parent.components[comp_id].code.onSave !== \"undefined\") {\n                page_content = page_content + that.parent.components[comp_id].code.onSave(this);\n            } else {\n                page_content = page_content + $(this)[0].outerHTML + \"\\n\";\n            }\n\n            //run the template checks\n            that.parent.bestpractice.component_check_content(this, comp_id, component_categories, template_best_practice_msg);\n        });\n\n        this.parent.bestpractice.page_check_content(component_categories, template_best_practice_msg);\n\n        //if this is the index page we add the full HTML page, if not we only require a very simple header/footer\n        if (page_num == 0) {\n            var final_doc = this.parent.app.curr_indexpage_html;\n            final_doc.getElementById(this.parent.config[\"app\"][\"content_id\"]).innerHTML = page_content;\n            final_doc.title = this.parent.app.curr_pagetitle;\n            var html = new XMLSerializer().serializeToString(final_doc);\n        } else {\n            var html = page_content;\n        }\n\n        curr_el.addClass(\"mlab_current_component\");\n\n        //finally we submit the data to the server, the callback function will further execute the function specified in the fnc argument, if any\n        var that = this;\n        $.post(url, { title: this.parent.app.curr_pagetitle, html: html }, function (data) {\n\n            //if this counter = 0 then noone else have called it in the meantime and it is OK to restart timer\n            that.parent.counter_saving_page--;\n\n            if (data.result == \"success\") {\n                that.parent.utils.update_status(\"temporary\", _tr[\"mlab.dt.management.js.update_status.saved.page\"], false);\n                that.parent.flag_dirty = false;\n\n                //if a function was specified we now execute it, inisde this function the this.parent.utils.timer_save timer will be restarted\n                //if no function was specified AND no-one else has initiated the save function, then OK to restart timer\n                if (typeof fnc != 'undefined') {\n                    res = fnc();\n                }\n\n                //process metadata information that has come back\n                if (typeof data.app_info != \"undefined\") {\n                    //we may have a result saying nochange\n                    if (data.app_info.result === \"file_changes\") {\n                        //load in metadata and (possibly new) checksum of app into variables, then upate display\n                        console.log(\"App files were changed\");\n                        that.parent.app.app_checksum = data.app_info.mlab_app_checksum;\n                        that.parent.app.page_names = data.app_info.mlab_app.page_names;\n                    } else if (data.app_info.result === \"no_file_changes\") {\n                        console.log(\"No changes to app files\");\n                    } else {\n                        if (that.parent.counter_saving_page == 0 && typeof fnc == 'undefined') {\n                            that.parent.utils.timer_start();\n                        }\n                        return;\n                    }\n\n                    that.parent.app.name = data.app_info.mlab_app.name;\n                    that.parent.app.description = data.app_info.mlab_app.description;\n                    that.parent.app.keywords = data.app_info.mlab_app.keywords;\n                    that.parent.app.tags = data.app_info.mlab_app.tags;\n                    if (!no_display_update) {\n                        that.app_update_gui_metadata();\n                    }\n                };\n            } else {\n                //failed\n                that.parent.utils.update_status(\"temporary\", _tr[\"mlab.dt.management.js.update_status.unable.save.page\"] + \": \" + data.msg, false);\n                if (typeof fnc != 'undefined') {\n                    //if this save attempt was a part of another operation we will ask if they want to try again, cancel or continue without saving\n                    //(the change may have been minimal and they want to start a new app let's say)\n                    $(\"#mlab_dialog_confirm\").dialog({\n                        resizable: false,\n                        height: 140,\n                        modal: true,\n                        buttons: {\n                            \"Retry\": function Retry() {\n                                $(this).dialog(\"close\");\n                                that.page_save(fnc);\n                                return;\n                            },\n                            \"Continue\": function Continue() {\n                                $(this).dialog(\"close\");\n                                res = fnc();\n                            },\n                            \"Cancel\": function Cancel() {\n                                $(this).dialog(\"close\");\n                            }\n                        }\n                    });\n                    return res;\n                }\n            }\n\n            //if this was not called from a function AND the save function has not been called by others, then we restart the save timer.\n            if (that.parent.counter_saving_page == 0 && typeof fnc == 'undefined') {\n                that.parent.utils.timer_start();\n            }\n        });\n\n        //above we have counted the number of issues relating to the template \"best practices\" configuration, time to display the error message, if any\n        if (template_best_practice_msg.length > 0) {\n\n            $(\"#mlab_statusbar_permanent\").qtip({\n                content: { text: \"<ul><li>\" + template_best_practice_msg.join(\"</li><li>\") + \"</li></ul>\" },\n                position: { my: 'topMiddle', at: 'bottomMiddle', viewport: $(window) },\n                show: { ready: true },\n                hide: { event: 'unfocus' },\n                style: { \"background-color\": \"white\", color: \"blue\", classes: \"mlab_qtip_info\", tip: true } });\n\n            //hides the qTip after 5 seconds\n            window.setTimeout(function () {\n                $(\".mlab_qtip_info\").remove();\n            }, 5000);\n        } else {\n            $(\".mlab_qtip_info\").remove();\n        }\n\n        return res;\n    },\n\n    /**\r\n    * Creates a new file on the server and opens it\r\n    */\n    page_new: function page_new() {\n        var title = prompt(_tr[\"mlab.dt.management.js.page_new.prompt.title.new.page\"]);\n        if (title != null) {\n            that = this;\n            this.page_save(function () {\n                that.page_new_process(title);\n            });\n        }\n    },\n\n    page_new_process: function page_new_process(title) {\n        $(\"body\").css(\"cursor\", \"wait\");\n        this.parent.utils.update_status(\"callback\", _tr[\"mlab.dt.management.js.update_status.storing.page\"], true);\n        var url = this.parent.urls.page_new.replace(\"_ID_\", this.parent.app.id);\n        url = url.replace(\"_UID_\", this.parent.uid);\n\n        //here we hide the tools for components until they select a control\n        if (typeof this.parent.qtip_tools != \"undefined\") {\n            $(this.parent.qtip_tools).qtip('hide');\n            this.parent.qtip_tools = undefined;\n            if (typeof this.parent.api.properties_tooltip != \"undefined\") {\n                $(this.parent.api.properties_tooltip).qtip('hide');\n                this.parent.api.properties_tooltip = undefined;\n            }\n        }\n\n        var that = this;\n        $.post(url, {}, function (data) {\n            if (data.result == \"success\") {\n                //prepare variables\n                that.parent.app.page_names.push({ title: title, filename: (\"000\" + data.page_num_real).slice(-3) + \".html\" });\n                that.parent.app.curr_pagetitle = title;\n                that.parent.app.curr_page_num = data.page_num_real;\n\n                //update page content area and HTML display of meta data\n                $(\"#\" + that.parent.config[\"app\"][\"content_id\"]).empty();\n                $(\"#mlab_page_control_title\").text(that.parent.app.curr_pagetitle);\n                that.app_update_gui_metadata();\n\n                //update staus\n                that.parent.utils.update_status(\"completed\");\n                that.parent.flag_dirty = true;\n            } else {\n                that.parent.utils.update_status(\"temporary\", data.msg, false);\n            }\n\n            $(\"body\").css(\"cursor\", \"default\");\n            that.parent.utils.timer_start();\n        });\n    },\n\n    /**\r\n    * Creates a new file on the server, does NOT open it but calls a callback function with the id of the page\r\n    * title string, title of page\r\n    * cb: callback function\r\n    */\n    page_new_in_background: function page_new_in_background(title, cb) {\n        $(\"body\").css(\"cursor\", \"wait\");\n        this.parent.utils.update_status(\"callback\", _tr[\"mlab.dt.management.js.update_status.storing.page\"], true);\n        var url = this.parent.urls.page_new.replace(\"_ID_\", this.parent.app.id);\n        url = url.replace(\"_UID_\", this.parent.uid) + \"/0/\" + encodeURI(title);\n\n        var that = this;\n        $.post(url, {}, function (data) {\n            if (data.result == \"success\") {\n                //update staus\n                that.parent.utils.update_status(\"completed\");\n                that.parent.flag_dirty = true;\n            } else {\n                that.parent.utils.update_status(\"temporary\", data.msg, false);\n            }\n            cb(data);\n            $(\"body\").css(\"cursor\", \"default\");\n            that.parent.utils.timer_start();\n        });\n    },\n\n    /**\r\n     * Creates a new file on the server and opens it\r\n     */\n    page_copy: function page_copy(page_num) {\n        if (page_num == \"0\" || page_num == \"index\") {\n            alert(_tr[\"mlab.dt.management.js.page_copy.alert.not.copy.index.page\"]);\n            return;\n        }\n        that = this;\n        this.page_save(function () {\n            that.page_copy_process(page_num);\n        });\n    },\n\n    page_copy_process: function page_copy_process(page_num) {\n        var url = this.parent.urls.page_copy.replace(\"_ID_\", this.parent.app.id);\n        url = url.replace(\"_PAGE_NUM_\", page_num);\n        url = url.replace(\"_UID_\", this.parent.uid);\n        this.parent.utils.update_status(\"callback\", _tr[\"mlab.dt.management.js.update_status.copying.page\"], true);\n        var that = this;\n\n        $.get(url, function (data) {\n            that.parent.utils.update_status(\"completed\");\n            if (data.result == \"success\") {\n                that.parent.app.curr_pagetitle = data.page_title;\n                $(\"#mlab_page_control_title\").text(data.page_title);\n                that.parent.app.page_names.push({ title: data.page_title, filename: (\"000\" + data.page_num_real).slice(-3) + \".html\" });\n                that.regular_page_process(data.html, data.page_num_real);\n            } else {\n                alert(data.msg);\n            }\n            that.parent.utils.timer_start();\n        });\n    },\n\n    page_delete: function page_delete() {\n        if (this.parent.app.curr_page_num == 0) {\n            alert(_tr[\"mlab.dt.management.js.page_copy.alert.not.delete.index.page\"]);\n            return;\n        }\n\n        if (!confirm(_tr[\"mlab.dt.management.js.page_copy.alert.sure.delete\"])) {\n            return;\n        }\n\n        this.parent.utils.timer_stop();\n        this.parent.utils.update_status(\"callback\", _tr[\"mlab.dt.management.js.update_status.deleting.page\"], true);\n\n        var that = this,\n            url = this.parent.urls.page_delete.replace(\"_ID_\", this.parent.app.id);\n        url = url.replace(\"_PAGE_NUM_\", this.parent.app.curr_page_num);\n        url = url.replace(\"_UID_\", this.parent.uid);\n\n        $.get(url, function (data) {\n            that.parent.utils.update_status(\"completed\");\n            if (data.result == \"success\") {\n                $(\"#mlab_existing_pages [data-mlab-page-num='\" + data.page_num_sent).remove();\n\n                that.parent.app.page_names.splice(that.page_filenum2index(that.parent.app.curr_page_num), 1);\n                that.regular_page_process(data.html, data.page_num_real);\n                that.app_update_gui_metadata(true);\n            } else {\n                that.parent.utils.update_status(\"temporary\", data.msg, false);\n            }\n\n            that.parent.utils.timer_start();\n        });\n    },\n\n    /**\r\n     * Simple function to open a new window with current page in it\r\n     * Given that we use an jquery mobile framework with an index file and loading pages into the index file,\r\n     * we need to pass the relevant file name and have matching code in the mlab.js file to deal with this\r\n     * @param {type} index\r\n     * @returns {undefined}\r\n     */\n    page_preview: function page_preview() {\n        that = this;\n        this.page_save(function () {\n            that.page_preview_process();\n        });\n    },\n\n    page_preview_process: function page_preview_process() {\n        var url = this.parent.urls.app_preview.replace(\"_APPID_\", this.parent.app.id);\n        var w = $(window).width() * 0.25;\n        var h = $(window).height() * 0.75;\n        var res = window.open(url, 'targetWindow', 'toolbar=no,location=no,status=no,menubar=no,scrollbars=no,resizable=no,width=' + w + ',height=' + h + ',left=' + w);\n        if (res == undefined) {\n            alert(_tr[\"mlab.dt.management.js.page_preview_process.alert.cannot.open.new.window\"]);\n        }\n    },\n\n    socket: {\n\n        connection: null,\n\n        setup: function setup(callback, param) {\n            //first close any existing connections\n            if (mlab.dt.management.socket.connection) {\n                mlab.dt.management.socket.connection.close();\n            }\n\n            // connect to the websocket server, this returns data from server callback functions used when connectng to market or compiler services\n            mlab.dt.management.socket.connection = new WebSocket(mlab.dt.config.ws_socket.url_client + mlab.dt.config.ws_socket.path_client + '/' + mlab.dt.uid);\n\n            mlab.dt.management.socket.connection.onerror = function (evt) {\n                console.log(\"The following error occurred: \" + evt.data);\n                mlab.dt.management.socket.connection = null;\n                alert(_tr[\"mlab.dt.management.js.websocket.error.connect\"]);\n            };\n\n            mlab.dt.management.socket.connection.onopen = function () {\n                console.log(\"onopen\");\n                callback(param);\n            };\n\n            mlab.dt.management.socket.connection.onmessage = function (event) {\n                data = JSON.parse(event.data);\n                switch (data.status) {\n\n                    //1: When click on menu, then it should indicate that the app is requested ( mlab.dt.management.js  -  compiler: {  get_app :)\n                    //2: When the request has been processed by the PHP backend it should indicate one stage has passed (? -  case \"connected\"?)\n                    //3: Then it should indicate that precompilation has taken place (may not be required, so a numeric is not good) (case \"precompilation\")\n                    //4: createApp is called, this creates the empty app (case \"creating\"....case \"created\"?)\n                    //5: Then files are uploaded (lengthy) (case \"uploading\"? (hoppe vider på case \"verifying\" og  case \"verification_ok\"- tar tid----)\n                    //6: App upload finished, compilation starts (case \"compiling\"...case \"compilation_ok\")\n                    //7: App is being (case \"receiving\":)\n                    //8: App is ready (case \"ready\")\n\n                    //Sette en grå versjon av iconet om siste versjon er kopilert?\n                    // kan Andoid og iOS kopileres på samme tid?\n                    // hva om man lagrer en ny versjon mens kompiler\n\n                    case \"connected\":\n                        $(\"#mlab_progressbar\").val(5);\n                        $(\"#mlab_statusbar_compiler\").text(_tr[\"mlab_editor.init.js.compiling.connected\"]);\n                        break;\n\n                    case \"creating\":\n                        $(\"#mlab_progressbar\").val(10);\n                        $(\"#mlab_statusbar_compiler\").text(_tr[\"mlab_editor.init.js.compiling.creating\"]);\n                        //createApp is called, this creates the empty app\n                        break;\n\n                    case \"created\":\n                        $(\"#mlab_progressbar\").val(15);\n                        $(\"#mlab_statusbar_compiler\").text(_tr[\"mlab_editor.init.js.compiling.created\"]);\n                        break;\n\n                    case \"precompilation\":\n                        $(\"#mlab_progressbar\").val(20);\n                        $(\"#mlab_statusbar_compiler\").text(_tr[\"mlab_editor.init.js.compiling.precompilation\"]);\n                        break;\n\n                    case \"uploading\":\n                        $(\"#mlab_progressbar\").val(25);\n                        $(\"#mlab_statusbar_compiler\").text(_tr[\"mlab_editor.init.js.compiling.uploading\"]);\n                        break;\n\n                    case \"verifying\":\n                        $(\"#mlab_progressbar\").val(30);\n                        $(\"#mlab_statusbar_compiler\").text(_tr[\"mlab_editor.init.js.compiling.verifying\"]);\n                        break;\n\n                    case \"verification_ok\":\n                        $(\"#mlab_progressbar\").val(35);\n                        $(\"#mlab_statusbar_compiler\").text(_tr[\"mlab_editor.init.js.compiling.verification_ok\"]);\n                        break;\n\n                    case \"compiling\":\n                        $(\"#mlab_progressbar\").val(40);\n                        $(\"#mlab_statusbar_compiler\").text(_tr[\"mlab_editor.init.js.compiling.compiling\"]);\n                        break;\n\n                    case \"compilation_ok\":\n                        $(\"#mlab_progressbar\").val(80);\n                        $(\"#mlab_statusbar_compiler\").text(_tr[\"mlab_editor.init.js.compiling.compilation_ok\"]);\n                        break;\n\n                    case \"failed\":\n                    case \"precompilation_failed\":\n                    case \"compilation_failed\":\n                    case \"verification_failed\":\n                    case \"create_failed\":\n                        $(\"#mlab_statusbar_compiler\").text(\"\");\n                        $(\"#mlab_download_\" + data.platform + \"_icon\").removeClass('mlab_download_' + data.platform + '_icon_grey');\n                        $(\"#mlab_download_\" + data.platform + \"_icon\").find(\"img\").hide();\n                        $(\"#mlab_progressbar\").hide();\n                        mlab.dt.utils.update_status(\"temporary\", data.fail_text, false);\n                        mlab.dt.management.socket.connection.close();\n                        mlab.dt.management.socket.connection = null;\n                        break;\n\n                    case \"receiving\":\n                        $(\"#mlab_progressbar\").val(90);\n                        $(\"#mlab_statusbar_compiler\").text(_tr[\"mlab_editor.init.js.compiling.receiving\"]);\n                        break;\n\n                    case \"ready\":\n                        $(\"#mlab_progressbar\").val(100);\n                        $(\"#mlab_statusbar_compiler\").text(\"\");\n                        $(\"#mlab_download_\" + data.platform + \"_icon\").removeClass('mlab_download_' + data.platform + '_icon_grey');\n                        $(\"#mlab_download_\" + data.platform + \"_icon\").find(\"img\").hide();\n                        $(\"#mlab_progressbar\").hide();\n\n                        //inserting the QR code and url to the compiled app in the menu\n                        if (typeof data.filename != \"undefined\" && data.filename != null && data.filename != \"\") {\n                            mlab.dt.app.compiled_files[data.platform] = data.filename;\n                            var text = document.getElementsByTagName(\"base\")[0].href.slice(0, -1) + \"_compiled/\" + data.filename;\n                            $(\"#mlab_download_qr_link_\" + data.platform).empty().qrcode({ text: text, size: 150, background: \"#ffffff\", foreground: \"#000000\", render: \"table\" });\n                            $(\"#mlab_download_link_\" + data.platform).html(\"<b>URL</b>:</br>\" + text);\n                            mlab.dt.utils.update_status(\"temporary\", _tr[\"mlab_editor.init.js.compiling.ready\"], false);\n                        } else {\n                            mlab.dt.utils.update_status(\"temporary\", _tr[\"mlab_editor.init.js.compiling.failed\"], false);\n                        }\n                        mlab.dt.management.socket.connection.close();\n                        mlab.dt.management.socket.connection = null;\n                        break;\n\n                }\n            };\n        } //end function setup\n    }, //end socket object\n\n    market: {\n\n        login: function login() {},\n\n        submit_app_details: function submit_app_details() {},\n\n        upload_app_file: function upload_app_file() {},\n\n        publish_app: function publish_app() {},\n\n        unpublish_app: function unpublish_app() {}\n\n    },\n\n    //these are the compiler functions we call. At the front end we only use two functions, info about current app and get_app\n    //in the background (i.e. on the PHP server) get_app calls lots of different functions to actually prepare app, upload files, compile and retrieve app\n    compiler: {\n\n        get_app_status: function get_app_status() {\n            var url = mlab.dt.urls.cmp_get_app_status.replace(\"_WINDOW_UID_\", mlab.dt.uid);\n            var i = prompt(_tr[\"mlab.dt.management.js.compiler.get_app_status.prompt.db.id\"]);\n            url = url.replace(\"/_ID_\", i != null && i != \"\" ? \"/\" + i : \"\");\n            var v = prompt(_tr[\"mlab.dt.management.js.compiler.get_app_status.prompt.version\"]);\n            url = url.replace(\"/_VERSION_\", v != null && v != \"\" ? \"/\" + v : \"\");\n            var p = prompt(_tr[\"mlab.dt.management.js.compiler.get_app_status.prompt.platform\"]);\n            url = url.replace(\"/_PLATFORM_\", p != null && p != \"\" ? \"/\" + p : \"\");\n\n            $(document).ajaxError(function (event, jqXHR, ajaxSettings) {\n                if (jqXHR.status === 0) {\n                    alert('Not connect.\\n Verify Network.');\n                } else if (jqXHR.status == 404) {\n                    alert('Requested page not found. [404]');\n                } else if (jqXHR.status == 500) {\n                    alert('Internal Server Error [500].');\n                    /*                } else if (exception === 'parsererror') {\r\n                                        alert('Requested JSON parse failed.');\r\n                                    } else if (exception === 'timeout') {\r\n                                        alert('Time out error.');\r\n                                    } else if (exception === 'abort') {\r\n                                        alert('Ajax request aborted.');*/\n                } else {\n                    alert('Uncaught Error.\\n' + jqXHR.responseText);\n                }\n                mlab.dt.utils.update_status(\"temporary\", jqXHR.responseText, false);\n            });\n\n            $.ajax({\n                url: url,\n                dataType: 'json',\n                success: function success(json) {\n                    if (json.result == \"success\") {\n                        console.log(\"Status returned: \");\n                        console.log(json.app_status);\n                    } else {\n                        alert(_tr[\"mlab.dt.management.js.compiler.get_app_status.alert.unable.get.app.status\"]);\n                        mlab.dt.utils.update_status(\"temporary\", \"\", false);\n                    }\n                }\n\n            });\n        },\n\n        /**\r\n         * downloads a complte copy of prepared (i.e. finished precompile process) source code, so Mlab ise just used as an editor\r\n         * @returns {undefined}\r\n         */\n        get_app_source: function get_app_source() {\n            var url = mlab.dt.urls.cmp_get_app_source.replace(\"_WINDOW_UID_\", mlab.dt.uid);\n            url = url.replace(\"_ID_\", mlab.dt.app.id);\n            url = url.replace(\"_VERSION_\", mlab.dt.app.active_version);\n\n            $(document).ajaxError(function (event, jqXHR, ajaxSettings) {\n                if (jqXHR.status === 0) {\n                    alert('Not connect.\\n Verify Network.');\n                } else if (jqXHR.status == 404) {\n                    alert('Requested page not found. [404]');\n                } else if (jqXHR.status == 500) {\n                    alert('Internal Server Error [500].');\n                    /*                } else if (exception === 'parsererror') {\r\n                                        alert('Requested JSON parse failed.');\r\n                                    } else if (exception === 'timeout') {\r\n                                        alert('Time out error.');\r\n                                    } else if (exception === 'abort') {\r\n                                        alert('Ajax request aborted.');*/\n                } else {\n                    alert('Uncaught Error.\\n' + jqXHR.responseText);\n                }\n                mlab.dt.utils.update_status(\"temporary\", jqXHR.responseText, false);\n            });\n\n            $.ajax({\n                url: url,\n                dataType: 'json',\n                success: function success(json) {\n                    if (json.result == \"success\") {\n                        var iframe = $(\"<iframe/>\").attr({\n                            src: json.url,\n                            style: \"visibility:hidden;display:none\"\n                        }).appendTo(\"body\");\n                    } else {\n                        alert(_tr[\"mlab.dt.management.js.compiler.get_app_status.alert.unable.get.app.status\"]);\n                        mlab.dt.utils.update_status(\"temporary\", \"\", false);\n                    }\n                }\n\n            });\n        },\n\n        /**\r\n         * \r\n         * @returns {undefined}\r\n         */\n        upload_website: function upload_website() {\n            var url = mlab.dt.urls.cmp_upload_website.replace(\"_WINDOW_UID_\", mlab.dt.uid);\n            url = url.replace(\"_ID_\", mlab.dt.app.id);\n            url = url.replace(\"_VERSION_\", mlab.dt.app.active_version);\n\n            $(document).ajaxError(function (event, jqXHR, ajaxSettings) {\n                if (jqXHR.status === 0) {\n                    alert('Not connect.\\n Verify Network.');\n                } else if (jqXHR.status == 404) {\n                    alert('Requested page not found. [404]');\n                } else if (jqXHR.status == 500) {\n                    alert('Internal Server Error [500].');\n                    /*                } else if (exception === 'parsererror') {\r\n                                        alert('Requested JSON parse failed.');\r\n                                    } else if (exception === 'timeout') {\r\n                                        alert('Time out error.');\r\n                                    } else if (exception === 'abort') {\r\n                                        alert('Ajax request aborted.');*/\n                } else {\n                    alert('Uncaught Error.\\n' + jqXHR.responseText);\n                }\n                mlab.dt.utils.update_status(\"temporary\", jqXHR.responseText, false);\n            });\n\n            $.ajax({\n                url: url,\n                dataType: 'json',\n                success: function success(json) {\n                    if (json.result == \"success\") {\n                        console.log(\"Status returned: \");\n                        console.log(json.app_status);\n                    } else {\n                        alert(_tr[\"mlab.dt.management.js.compiler.get_app_status.alert.unable.get.app.status\"]);\n                        mlab.dt.utils.update_status(\"temporary\", \"\", false);\n                    }\n                }\n\n            });\n        },\n\n        //sets up a websocket connect to get information back during the compilation process\n        get_app: function get_app(platform) {\n            mlab.dt.management.socket.setup(mlab.dt.management.compiler.get_app_callback, platform);\n        },\n\n        //callback function that is used when the websocket connection (see get_app above) is completed\n        //this is where we start the actual process\n        get_app_callback: function get_app_callback(platform) {\n            var url = mlab.dt.urls.cmp_get_app_process.replace(\"_WINDOW_UID_\", mlab.dt.uid);\n            url = url.replace(\"_ID_\", mlab.dt.app.id);\n            url = url.replace(\"_VERSION_\", mlab.dt.app.active_version);\n            url = url.replace(\"_PLATFORM_\", platform);\n            var caption_finished = _tr[\"mlab.dt.management.js.compiler.get_app.status.creating.app\"];\n            $(\"#mlab_statusbar_compiler\").text(caption_finished);\n            $(\"#mlab_download_\" + platform + \"_icon\").find('img').show();\n            $(\"#mlab_download_\" + platform + \"_icon\").addClass(\"mlab_download_\" + platform + \"_icon_grey\");\n            $(\"#mlab_progressbar\").show();\n            $(\"#mlab_progressbar\").val(2);\n            $.getJSON(url, function (json) {\n                if (json.result != \"success\") {\n                    $(\"#mlab_statusbar_compiler\").text(\"\");\n                    $(\"#mlab_progressbar\").hide();\n                    mlab.dt.utils.update_status(\"temporary\", _tr[\"mlab.dt.management.js.update_status.unable.contact.server\"], false);\n                    $(\"#mlab_download_\" + platform + \"_icon\").find('img').hide();\n                    $(\"#mlab_download_\" + platform + \"_icon\").removeClass(\"mlab_download_\" + platform + \"_icon_grey\");\n                }\n            });\n        }\n    } // end management.prototype\n\n};"

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./node_modules/babel-loader/lib/index.js??ref--0-0!./assets/js/mlab.dt.utils.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/raw-loader!./node_modules/babel-loader/lib??ref--0-0!./assets/js/mlab.dt.utils.js ***!
  \********************************************************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports) {

module.exports = "var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n/*******************************************************************************************************************************\r\n@copyright Copyright (c) 2013-2016, Norwegian Defence Research Establishment (FFI) - All Rights Reserved\r\n@license Proprietary and confidential\r\n@author Arild Bergh/Sinett 3.0 programme (firstname.lastname@ffi.no) rewrite/implementation of all functionality\r\n@author Cecilie Jackbo Gran/Sinett 3.0 programme (firstname.middlename.lastname@ffi.no) additional functionality\r\n\r\nUnauthorized copying of this file, via any medium is strictly prohibited \r\n\r\nFor the full copyright and license information, please view the LICENSE_MLAB file that was distributed with this source code.\r\n*******************************************************************************************************************************/\n\n/**\r\n * @abstract Utility functions for design time\r\n */\n\nfunction Mlab_dt_utils() {\n    this.parent = null;\n    this.timer_save = null;\n    this.concat_not_replace = [\"required_libs\"]; //gah! gory hack to treat the required_libs setting differently when handle inheritance... TODO:Fix!\n};\n\nMlab_dt_utils.prototype = {\n    /**\r\n     * This function is used to display status information, this can be permanent, temporary, or until callback is called, and may have a progress bar\r\n     * If state is completed we get rid of temporary info and any gauges\r\n     *\r\n     * @param {type} state\r\n     * @param {type} content\r\n     * @returns {undefined}\r\n    */\n    update_status: function update_status(state, content, display_progress) {\n\n        if (state == \"permanent\") {\n            $(\"#mlab_statusbar_permanent\").text(content);\n            return;\n        } else if (state == \"temporary\") {\n            $(\"#mlab_statusbar_temporary\").text(content);\n            window.setTimeout(this.clear_status.bind(this), 3000);\n        } else if (state == \"callback\") {\n            $(\"#mlab_statusbar_temporary\").text(content);\n        } else if (state == \"completed\") {\n            $(\"#mlab_statusbar_temporary\").text('');\n            $('#mlab_statusbar_progress_spin').spin(false);\n            $(\"#mlab_statusbar_progress_spin\").hide();\n            return;\n        }\n\n        if (typeof display_progress != \"undefined\" && display_progress == true) {\n            $(\"#mlab_statusbar_progress_spin\").show();\n            $(\"#mlab_statusbar_progress_spin\").spin('small', '#fff');\n        } else if (typeof display_progress != \"undefined\" && display_progress == false) {\n            $('#mlab_statusbar_progress_spin').spin(false);\n            $(\"#mlab_statusbar_progress_spin\").hide();\n        }\n    },\n\n    /**\r\n     * Simple wrapper function to clear a temporary status\r\n     * @returns {undefined} */\n    clear_status: function clear_status() {\n        this.update_status(\"completed\");\n    },\n\n    /**\r\n     * Create a timer to save the current page and stores it in a global variable\r\n     * we call window.clearTimeout(this.timer_save) to stop it should it be required\r\n     *\r\n     * @returns {undefined}\r\n     */\n    timer_start: function timer_start() {\n        var tm = parseInt(this.parent.config[\"save_interval\"]);\n        if (tm < 60) {\n            tm = 60;\n        }\n\n        //Need to provide context for timer event, otherwise the \"this\" inside page_save will point to Window object\n        this.timer_save = window.setTimeout(this.parent.management.page_save.bind(this.parent.management), tm * 1000);\n    },\n\n    timer_stop: function timer_stop() {\n        window.clearTimeout(this.timer_save);\n    },\n\n    //utility to merge two objects, but only ADD non-existing properties to the to_obj\n    //properties that exist are merged, otherwise it is added as a new object property\n    //UPDATE: For the required_libs we concatenate and dedupe, otherwise we end up using numbered index for comparison...\n    merge_objects: function merge_objects(from_obj, to_obj, parent_name) {\n        for (var p in from_obj) {\n            if (Array.isArray(from_obj[p]) && this.concat_not_replace.indexOf(parent_name) > -1) {\n                if (typeof to_obj[p] === \"undefined\") {\n                    //if the receiving object does not have a matching object, then it must be created or it will fail\n                    to_obj[p] = from_obj[p];\n                } else {\n                    //to_obj[p] = from_obj[p].concat(to_obj[p]); //for arrays we always merge\n                    to_obj[p] = [].concat(_toConsumableArray(new Set([].concat(_toConsumableArray(from_obj[p]), _toConsumableArray(to_obj[p])))));\n                }\n            } else if (_typeof(from_obj[p]) === \"object\") {\n                //incoming property is a \"sub\" object, not a value\n                if (typeof to_obj[p] === \"undefined\") {\n                    //if the receiving object does not have a matching object, then it must be created or it will fail\n                    to_obj[p] = new Object();\n                }\n                to_obj[p] = this.merge_objects(from_obj[p], to_obj[p], p); //as this is a object we then merge this sub-object\n            } else if (typeof to_obj[p] === \"undefined\") {\n                //this is a value, not an object and it does NOT exist in receiving object, so we add it.\n                to_obj[p] = from_obj[p];\n            }\n        }\n        return to_obj;\n    },\n\n    process_inheritance_helper: function process_inheritance_helper(components, index) {\n        //does this component inherit from another component?\n        if (typeof components[index].conf[\"inherit\"] != \"undefined\") {\n            var from = components[index].conf.inherit;\n\n            //does the component to inherit from exist?\n            if (typeof components[from] != \"undefined\") {\n\n                //need to check that the object to inherit is either top level, or already inherited, if not we recursively process those inheriances first \n                if (!components[from].inheritance_processed && components[from].conf[\"inherit\"] != \"undefined\") {\n                    this.process_inheritance_helper(components, from);\n                }\n                //we copy top level objects and objects within the code and and code.config objects\n                components[index] = this.merge_objects(components[from], components[index], from);\n                components[index].inheritance_processed = true;\n            } else {\n                console.log(\"Parent object for \" + index + \" does not exist:\" + from);\n            }\n        }\n    },\n\n    //this function takes care of the simple inheritance facility that compoennts offer\n    //Have a property called inheritance_processed, if true we've added properties from parents for that component. Set this to true for components that do not inherit from anyone else\n    //When loop through components and it inherits from a component that had not loaded parents yet, then process that first, then inherit from grandparent to parent first.\n    //If grandparent also inherits, then same for that, and so on.\n    //Need to have a call stack to avoid circular inheritance\n    process_inheritance: function process_inheritance(components) {\n        for (index in components) {\n            this.process_inheritance_helper(components, index);\n        }\n    },\n\n    //gets a cookie by name/key                        \n    getCookie: function getCookie(cname) {\n        var name = cname + \"=\";\n        var ca = document.cookie.split(';');\n        for (var i = 0; i < ca.length; i++) {\n            var c = ca[i];\n            while (c.charAt(0) == ' ') {\n                c = c.substring(1);\n            }if (c.indexOf(name) == 0) return c.substring(name.length, c.length);\n        }\n        return 1;\n    }\n\n};"

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./node_modules/babel-loader/lib/index.js??ref--0-0!./assets/js/mlab_editor.init.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/raw-loader!./node_modules/babel-loader/lib??ref--0-0!./assets/js/mlab_editor.init.js ***!
  \***********************************************************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports) {

module.exports = "/*******************************************************************************************************************************\r\n@copyright Copyright (c) 2013-2016, Norwegian Defence Research Establishment (FFI) - All Rights Reserved\r\n@license Proprietary and confidential\r\n@author Arild Bergh/Sinett 3.0 programme (firstname.lastname@ffi.no) rewrite/implementation of all functionality\r\n@author Cecilie Jackbo Gran/Sinett 3.0 programme (firstname.middlename.lastname@ffi.no) additional functionality\r\n\r\nUnauthorized copying of this file, via any medium is strictly prohibited \r\n\r\nFor the full copyright and license information, please view the LICENSE_MLAB file that was distributed with this source code.\r\n*******************************************************************************************************************************/\n\n/**\r\n * @abstract All functions used in /src/Sinett/MLAB/BuilderBundle/Resources/views/App/build_app.html.twig\r\n * but not the data that has to come from TWIG. Therefore, see top of that page for data structures.\r\n */\n//TODO: NEED TO NOT USE slf (window.slf = JS builtin variable)\n\n\n/* general variables used globally by different functions\r\n   (variables with data from backend are loaded from the backend in the document.ready event and enters this file as JSON structures */\n\n//turn off automatic initialisation of mobile pages\n$.mobile.autoInitializePage = false;\n\n/*********** Startup code ***********/\n$(document).ready(function () {\n\n    //only support chrome and firefox to begin with\n    if (bowser.gecko || bowser.chrome) {} else {\n        alert(_tr[\"mlab_editor.init.js.alert.browser.support\"]);\n        $(\"body\").append('<div id=\"mlab_editor_disabled\" style=\"background-color: gray; position: absolute;top:0;left:0;width: 100%;height:100%;z-index:2;opacity:0.4;filter: alpha(opacity = 50)\"></div>');\n    }\n\n    //initialise the Mlab object, then create an global instance of it\n    //the MLAB object contains several other objects loaded in different files\n    Mlab = function Mlab() {\n        var self = this;\n        this.locale = document.mlab_temp_vars.locale;\n\n        //runtime api is at the top level\n        this.api = new Mlab_api();\n        this.api.parent = self;\n\n        this.dt = {\n            //variables used for: general config, path info, app info, page details\n            uid: 0,\n            config: new Object(),\n            paths: new Object(),\n            app: new Object(),\n            page: new Object(),\n\n            // individual variables used by all .dt sub functions\n            flag_dirty: false,\n            counter_saving_page: 0, // counter which tells us if inside the save function we should restart the timer for\n            drag_origin: 'sortable',\n            mlab_component_cur_tooltip: null,\n\n            // drag'n'drop definitions used by jQuery\n            droppable_options: {\n                drop: function drop(event, ui) {\n                    mlab.dt.flag_dirty = true;\n                }\n            },\n\n            sortable_options: {\n                placeholder: \"mlab_component_placeholder\",\n                revert: false,\n                helper: \"clone\",\n                cancel: \"[contenteditable]\",\n                stop: function stop(event, ui) {\n                    //make editable after dragging to sort\n                    if (mlab.dt.drag_origin == 'sortable' && ui.item.data(\"contenteditable\") == \"true\") {\n                        ui.item.attr(\"contenteditable\", \"true\");\n                    };\n                    mlab.dt.flag_dirty = true;\n                }\n            },\n\n            //other pre-defined objects wrapping up this .dt \"class\"\n            api: new Mlab_dt_api(),\n            bestpractice: new Mlab_dt_bestpractice(),\n            design: new Mlab_dt_design(),\n            management: new Mlab_dt_management(),\n            utils: new Mlab_dt_utils()\n\n        }, this.initialise_dt_parents = function () {\n            self.dt.parent = self;\n            self.dt.api.parent = self.dt;\n            self.dt.api.display.parent = self.dt.api;\n            self.dt.bestpractice.parent = self.dt;\n            self.dt.design.parent = self.dt;\n            self.dt.management.parent = self.dt;\n            self.dt.utils.parent = self.dt;\n        };\n    };\n    mlab = new Mlab();\n    mlab.initialise_dt_parents();\n\n    //here we pick up variables from the backend, if successful we go on, if not we must exit\n    $.get(document.mlab_temp_vars.appbuilder_root_url + document.mlab_temp_vars.app_id + \"/\" + document.mlab_temp_vars.page_num + \"/load_variables\", function (data) {\n\n        if (data.result === \"success\") {\n            //unique ID for this tab/window, used to lock pages\n            mlab.dt.uid = data.mlab_uid;\n\n            //we use the email of the user to send them links to apps\n            mlab.dt.user_email = data.mlab_current_user_email;\n\n            //current app/page information, this will be updated when they create a new app or edit properties\n            mlab.dt.app = data.mlab_app;\n            if (isNaN(data.mlab_app_page_num)) {\n                console.log(\"Error, expecting page number\");\n                alert(\"Error, expecting page number, try to refresh\");\n                return;\n            } else {\n                mlab.dt.app.curr_page_num = data.mlab_app_page_num;\n            }\n            //checksum of current file\n            mlab.dt.app.app_checksum = data.mlab_app_checksum;\n\n            //any existing compiled files for this app\n            mlab.dt.app.compiled_files = data.mlab_compiled_files;\n\n            //configuration stuff from parameter.yml\n            mlab.dt.config = data.mlab_config;\n\n            //URLs can be changed using routes in MLAB, make sure we always use the latest from Symfony and don't have hardwired ones\n            mlab.dt.urls = data.mlab_urls;\n\n            /**** Finished preparing variables, now we set up rest of environment ****/\n\n            //check if the doc is modified before closeing it, if so warn user, also unlock file and save component accordion expand collaps state\n            window.onbeforeunload = function () {\n                var url = mlab.dt.urls.editor_closed.replace(\"_UID_\", mlab.dt.uid);\n                $.ajax({ url: url, async: false });\n\n                if (mlab.dt.flag_dirty) {\n                    return _tr[\"mlab_editor.init.js.alert.unsaved\"];\n                }\n                //Loop trough the Component categories/accordians to se if they are expand or collapsed. \n                var compcat = $(\"#mlab_toolbar_components h3\");\n                if (typeof compcat != \"undefined\") {\n                    compcat.each(function () {\n                        var cat = $(this).data(\"mlab-category\");\n                        if ($(this).hasClass(\"ui-state-active\")) {\n                            //Set coockie to save expand state of the accordians of the componentgroup\n                            document.cookie = \"mlabCompCat\" + cat + \"=0; expires=Thu, 18 Dec 2053 12:00:00 UTC; path=/\";\n                        } else {\n                            //Set coockie to save collapsed state of the accordians of the componentgroup\n                            document.cookie = \"mlabCompCat\" + cat + \"=1; expires=Thu, 18 Dec 2053 12:00:00 UTC; path=/\";\n                        }\n                    });\n                }\n            };\n\n            //now we load components, the go into a mlab object called components,\n            //and for each component we need to turn the text of the\n            $.get(document.mlab_temp_vars.appbuilder_root_url + document.mlab_temp_vars.app_id + \"/load_components\", function (data) {\n                if (data.result === \"success\") {\n\n                    var loc = mlab.dt.api.getLocale();\n                    mlab.dt.components = data.mlab_components;\n                    mlab.dt.storage_plugins = {};\n                    var components_html = {};\n                    var category_translations = {};\n                    var features_html = [];\n                    var additional_html = \"\";\n                    var comp_type;\n\n                    //loop to clean up components so that there are no duplicate order_by entries and also generate JS code from text in code_dt.js file\n                    var temp_comp_order = [];\n                    for (comp_id in mlab.dt.components) {\n                        temp_comp_order.push(parseInt(mlab.dt.components[comp_id].order_by));\n                        //we need to attach the code_dt.js content to an object so we can use it as JS code\n                        if (mlab.dt.components[comp_id].code !== false) {\n                            eval(\"mlab.dt.components['\" + comp_id + \"'].code = new function() { \" + mlab.dt.components[comp_id].code + \"};\");\n                        }\n                    }\n                    temp_comp_order.sort(function (a, b) {\n                        return a - b;\n                    });\n\n                    //now loop through all components and for those that inherit another we transfer properties\n                    mlab.dt.utils.process_inheritance(mlab.dt.components);\n\n                    //second loop which is for displaying the tools loaded & prepared above in the editor page\n                    for (comp_id in mlab.dt.components) {\n                        //here we create the conf object inside the newly created code object, this way we can access the configuration details inside the code\n                        mlab.dt.components[comp_id].code.config = mlab.dt.components[comp_id].conf;\n                        var c = mlab.dt.components[comp_id];\n                        if (c.accessible && !c.is_storage_plugin) {\n\n                            //prepare the tooltips (regular/extended). Can be a string, in which use as is, or an key-value object, if key that equals mlab.dt.api.getLocale() is found use this, if not look for one called \"default\"\n                            var tt = mlab.dt.api.getLocaleComponentMessage(comp_id, [\"tooltip\"]);\n                            var tte = mlab.dt.api.getLocaleComponentMessage(comp_id, [\"footer_tip\"]);\n                            var eName = mlab.dt.api.getLocaleComponentMessage(comp_id, [\"extended_name\"]);\n\n                            //the category setting in the conf.yml files\n                            if (typeof components_html[c.conf.category] == \"undefined\") {\n                                components_html[c.conf.category] = [];\n                                category_translations[c.conf.category] = mlab.dt.api.getLocaleComponentMessage(comp_id, [\"category_name\"]);\n                            }\n\n                            if (c.is_feature) {\n                                comp_type = \"feature\";\n                            } else {\n                                comp_type = \"component\";\n                            }\n\n                            var pos = temp_comp_order.indexOf(parseInt(c.order_by));\n                            delete temp_comp_order[pos];\n                            components_html[c.conf.category][pos] = \"<div data-mlab-type='\" + comp_id + \"' \" + \"onclick='mlab.dt.design.\" + comp_type + \"_add(\\\"\" + comp_id + \"\\\");' \" + \"title='\" + tt + \"' \" + \"class='mlab_button_components' \" + \"style='background-image: url(\\\"\" + mlab.dt.config.urls.component + comp_id + \"/\" + mlab.dt.config.component_files.ICON + \"\\\");'>\" + \"</div>\" + \"<div class='mlab_component_footer_tip'>\" + tte + \"</div>\";\n                        } else if (c.accessible && c.is_storage_plugin) {\n                            mlab.dt.storage_plugins[comp_id] = eName;\n                        }\n                    }\n\n                    //TODO now first category is hardcoded to be text...\n                    //If the first category of components does not have a cookie it moste likely that none of the mlabCompCatxxx cookies are made (first time users or deleted cookies) - so set the first categroy to expand \n                    var cookieExists = mlab.dt.utils.getCookie(\"mlabCompCattext\");\n                    if (cookieExists === 1) {\n                        //Cookie for first category not found - set cookie so it will be expanded\n                        document.cookie = \"mlabCompCattext=0; expires=Thu, 18 Dec 2053 12:00:00 UTC; path=/\";\n                    }\n\n                    //Puts all components under the same category and adds an accordion to the categroy collapsed or expanded depending on the coockie state \n                    for (category in components_html) {\n                        var activeCat = Number(mlab.dt.utils.getCookie(\"mlabCompCat\" + category));\n                        $(\"<div><h3 data-mlab-category='\" + category + \"'><div class='mlab_category_name'>\" + category_translations[category] + \"</div></h3><div>\" + components_html[category].join(\"\") + \"</div></div>\").appendTo(\"#mlab_toolbar_components\").accordion({\n                            heightStyle: \"content\",\n                            active: activeCat,\n                            collapsible: true\n                        });\n                    }\n\n                    //finally we assign the API object to the component, cannot do this earlier as it would create a loop to parents, etc \n                    //when trying to merge properties in the previous code block\n                    for (index in mlab.dt.components) {\n                        if (typeof mlab.dt.components[index].code != \"undefined\" && mlab.dt.components[index].code !== false) {\n                            mlab.dt.components[index].code.api = mlab.dt.api;\n                        }\n\n                        //added to inherit HTML to the additional mlab.dt.components.html which is set in loadSingleComponent in /src/Sinett/MLAB/BuilderBundle/FileManagement/FileManagement.php\n                        if (!mlab.dt.components[index].html && mlab.dt.components[index].conf.inherit) {\n                            mlab.dt.components[index].html = mlab.dt.components[mlab.dt.components[index].conf.inherit].html;\n                        }\n                    }\n\n                    //set the extended help text for the component in the footer\n                    $(\".mlab_button_components\").mouseover(function (e) {\n                        $(\".mlab_editor_footer_help\").text(e.currentTarget.nextSibling.textContent);\n                    });\n\n                    $(\".mlab_button_components\").mouseout(function (e) {\n                        $(\".mlab_editor_footer_help\").text(\"\");\n                    });\n\n                    //we always load pages using AJAX, this takes the parameters passed from the controller\n                    mlab.dt.management.app_open(document.mlab_temp_vars.app_id, document.mlab_temp_vars.page_num);\n\n                    //erase the temporary variable, this is used in inititalisation process only.\n                    delete document.mlab_temp_vars;\n\n                    //prepare the menu popup for the storage plugin selector\n                    /*SPSP                        $(\"[data-mlab-comp-tool='storage_plugin']\").click( function(event) {\r\n                                            mlab.dt.api.closeAllPropertyDialogs();\r\n                                            var owner_element = event.currentTarget;\r\n                                            mlab.dt.api.properties_tooltip = $(owner_element).qtip({\r\n                                                solo: false,\r\n                                                content:    {text: $(\"data-mlab-get-info='storage_plugins'\").clone(), title: _tr[\"mlab_editor.init.js.qtip.comp.storage.plugin.title\"], button: true },\r\n                                                position:   { my: 'leftMiddle', at: 'rightMiddle', adjust: { screen: true } },\r\n                                                show:       { ready: true, modal: { on: true, blur: false } },\r\n                                                hide:       false,\r\n                                                events:     { hide: function(event, api) { api.destroy(); mlab.dt.api.properties_tooltip = false; } },\r\n                                                style:      { classes: \"mlab_zindex_top_tooltip\", tip: true }\r\n                                            });\r\n                                        } );*/\n\n                    //add spinner to the statusbar to show when needed                   \n                    $(\"#mlab_statusbar_progress_spin\").spin('small', '#fff');\n\n                    //assign click functions to tools\n                    $(\"[data-mlab-comp-tool='move_up']\").on(\"click\", function () {\n                        mlab.dt.design.component_moveup();\n                    });\n                    $(\"[data-mlab-comp-tool='move_down']\").on(\"click\", function () {\n                        mlab.dt.design.component_movedown();\n                    });\n                    $(\"[data-mlab-comp-tool='delete']\").on(\"click\", function () {\n                        mlab.dt.design.component_delete();\n                    });\n                    $(\"[data-mlab-comp-tool='help']\").on(\"click\", function () {\n                        mlab.dt.design.component_help();\n                    });\n                    $(\"[data-mlab-comp-tool='cut']\").on(\"click\", function () {\n                        mlab.dt.design.component_cut();\n                    });\n                    $(\"[data-mlab-comp-tool='copy']\").on(\"click\", function () {\n                        mlab.dt.design.component_copy();\n                    });\n                    $(\"[data-mlab-comp-tool='paste']\").on(\"click\", function () {\n                        mlab.dt.design.component_paste();\n                    });\n\n                    $(\"[data-mlab-comp-tool='redo']\").on(\"click\", function () {\n                        document.execCommand(\"redo\");\n                    });\n                    $(\"[data-mlab-comp-tool='undo']\").on(\"click\", function () {\n                        document.execCommand(\"undo\");\n                    });\n\n                    $(\"#mlab_page_control_title\").on(\"click\", function () {\n                        mlab.dt.api.editContent(this);\n                        $('#mlab_page_control_title_actions').show();\n                        $('#mlab_page_control_title').attr('title', _tr[\"app.builder.page.tooltip.page.name.edit\"]);\n                    });\n\n                    $(\"#mlab_page_control_save_title\").on(\"click\", function () {\n                        $('#mlab_page_control_title_actions').hide();\n                        $('#mlab_page_control_title').attr('title', _tr[\"app.builder.page.tooltip.page.name\"]);\n                        mlab.dt.management.page_update_title();\n                    });\n\n                    $(\"#mlab_page_control_cancel_title\").on(\"click\", function () {\n                        $('#mlab_page_control_title_actions').hide();\n                        $('#mlab_page_control_title').attr('title', _tr[\"app.builder.page.tooltip.page.name\"]);\n                        $('#mlab_page_control_title').text(mlab.dt.app.curr_pagetitle);\n                    });\n\n                    $(\"#mlab_page_control_new\").on(\"click\", function () {\n                        mlab.dt.management.page_new();\n                    });\n                    $(\"#mlab_page_control_import\").on(\"click\", function () {\n                        $(\"#mlab_dialog_import\").dialog({ resizable: false, height: 120, modal: true });\n                    });\n\n                    $(\"#mlab_page_control_delete\").on(\"click\", function () {\n                        mlab.dt.management.page_delete();\n                    });\n\n                    $(\"#mlab_page_help\").on(\"click\", function () {\n                        page_help(event);\n                    });\n\n                    //trun on and off footer help\n                    $(\"#mlab_button_help\").on(\"click\", function () {\n                        mlab.dt.design.toggle_footer();\n                    });\n\n                    //Checks if the editor menu icon is cliked\n                    $(\"#mlab_editor_menu_dropdown\").on(\"click\", function (event) {\n                        if ($('#mlab_user_menu_dropdown_content').hasClass('mlab_show_user_dropdown')) {\n                            //User menu is open and needs to be closed \n                            $('#mlab_user_menu_dropdown_content').toggleClass('mlab_show_user_dropdown');\n                            $('#mlab_user_menu_dropdown').toggleClass('mlab_show_user_dropdown_tab_selected');\n                        }\n                        //Toggles the Editor menu on and off\n                        $('#mlab_editor_menu_dropdown_content').toggleClass('mlab_show_editor_dropdown');\n                        $('#mlab_editor_menu_dropdown').toggleClass('mlab_show_editor_dropdown_tab_selected');\n                        event.stopPropagation();\n                    });\n\n                    //Checks if the user menu icon is cliked\n                    $(\"#mlab_user_menu_dropdown\").on(\"click\", function (event) {\n                        if ($('#mlab_editor_menu_dropdown_content').hasClass('mlab_show_editor_dropdown')) {\n                            //Editor menu is open and needs to be closed \n                            $('#mlab_editor_menu_dropdown_content').toggleClass('mlab_show_editor_dropdown');\n                            $('#mlab_editor_menu_dropdown').toggleClass('mlab_show_editor_dropdown_tab_selected');\n                        }\n                        //Toggles the User menu on and off\n                        $('#mlab_user_menu_dropdown_content').toggleClass('mlab_show_user_dropdown');\n                        $('#mlab_user_menu_dropdown').toggleClass('mlab_show_user_dropdown_tab_selected');\n                        event.stopPropagation();\n                    });\n\n                    //Checkes if the page menu icon is cliked\n                    $(\"#mlab_page_control_pagelist\").on(\"click\", function (event) {\n                        //User menu is open and needs to be closed \n                        $('#mlab_page_management').toggleClass('mlab_show');\n                        event.stopPropagation();\n                    });\n\n                    //Listens for any click\n                    $(document).on('click', function (event) {\n                        // Checks if editor menu is open\n                        if ($('#mlab_editor_menu_dropdown_content').hasClass('mlab_show_editor_dropdown')) {\n                            //Editor menu is open - close it\n                            $('#mlab_editor_menu_dropdown_content').toggleClass('mlab_show_editor_dropdown');\n                            $('#mlab_editor_menu_dropdown').toggleClass('mlab_show_editor_dropdown_tab_selected');\n                        }\n\n                        // Checks if user menu is open\n                        if ($('#mlab_user_menu_dropdown_content').hasClass('mlab_show_user_dropdown')) {\n                            //User menu is open - close it\n                            $('#mlab_user_menu_dropdown_content').toggleClass('mlab_show_user_dropdown');\n                            $('#mlab_user_menu_dropdown').toggleClass('mlab_show_user_dropdown_tab_selected');\n                        }\n\n                        // Checks if page menu is open\n                        if ($('#mlab_page_management').hasClass('mlab_show')) {\n                            //User menu is open and needs to be closed \n                            $('#mlab_page_management').toggleClass('mlab_show');\n                        }\n                    });\n\n                    //save page button in the editor menu \n                    $(\"#mlab_page_save_all\").on(\"click\", function () {\n                        var temp;\n                        mlab.dt.management.page_save(temp, true);\n                        //Editor menu is open - close it\n                        $('#mlab_editor_menu_dropdown_content').toggleClass('mlab_show_editor_dropdown');\n                        $('#mlab_editor_menu_dropdown').toggleClass('mlab_show_editor_dropdown_tab_selected');\n                        return false;\n                    });\n\n                    $(\"[data-mlab-comp-tool='storage_plugin']\").on(\"click\", function () {\n                        var el = $(this).siblings(\"[data-mlab-get-info='storage_plugins']\");\n                        if (!el.is(\":visible\")) {\n                            el.html(mlab.dt.api.getStoragePluginList(mlab.dt.api.getSelectedComponent()));\n                        }\n                        el.slideToggle();\n                    });\n\n                    $(\"[data-mlab-comp-tool='credentials']\").on(\"click\", function () {\n                        mlab.dt.design.component_edit_credentials();\n                    });\n\n                    //prepare the menu popup for the component resizer\n                    $(\"[data-mlab-comp-tool='comp_size']\").on(\"click\", function (event) {\n                        mlab.dt.api.closeAllPropertyDialogs();\n                        var owner_element = event.currentTarget;\n                        mlab.dt.api.properties_tooltip = $(owner_element).qtip({\n                            solo: false,\n                            content: { text: $(\"#mlab_component_size_list\").clone(), title: _tr[\"mlab_editor.init.js.qtip.comp.size.title\"], button: true },\n                            position: { my: 'leftMiddle', at: 'rightMiddle', viewport: $(window) },\n                            show: { ready: true, modal: { on: true, blur: false } },\n                            hide: false,\n                            style: { classes: \"mlab_zindex_top_tooltip\", tip: true },\n                            events: { hide: function hide(event, api) {\n                                    api.destroy();mlab.dt.api.properties_tooltip = false;\n                                },\n                                visible: function visible() {\n                                    $(\"[data-mlab-comp-size='small']\").on(\"click\", function () {\n                                        mlab.dt.api.display.setSize($(\".mlab_current_component\"), \"small\");\n                                        $(\"[data-mlab-get-info='comp_sizes']\").hide();\n                                    });\n\n                                    $(\"[data-mlab-comp-size='medium']\").on(\"click\", function () {\n                                        mlab.dt.api.display.setSize($(\".mlab_current_component\"), \"medium\");\n                                        $(\"[data-mlab-get-info='comp_sizes']\").hide();\n                                    });\n\n                                    $(\"[data-mlab-comp-size='large']\").on(\"click\", function () {\n                                        mlab.dt.api.display.setSize($(\".mlab_current_component\"), \"large\");\n                                        $(\"[data-mlab-get-info='comp_sizes']\").hide();\n                                    });\n                                }\n                            }\n                        });\n                    });\n\n                    //prepare the menu popup for the component aspect ratio selector\n                    $(\"[data-mlab-comp-tool='comp_aspect']\").on(\"click\", function (event) {\n                        mlab.dt.api.closeAllPropertyDialogs();\n                        var owner_element = event.currentTarget;\n                        mlab.dt.api.properties_tooltip = $(owner_element).qtip({\n                            solo: false,\n                            content: { text: $(\"#mlab_component_aspect_list\").clone(), title: _tr[\"mlab_editor.init.js.qtip.comp.aspect.title\"], button: true },\n                            position: { my: 'leftMiddle', at: 'rightMiddle', viewport: $(window) },\n                            show: { ready: true, modal: { on: true, blur: false } },\n                            hide: false,\n                            style: { classes: \"mlab_zindex_top_tooltip\", tip: true },\n                            events: { hide: function hide(event, api) {\n                                    api.destroy();mlab.dt.api.properties_tooltip = false;\n                                },\n                                visible: function visible() {\n                                    $(\"[data-mlab-comp-aspect='4:3']\").on(\"click\", function () {\n                                        mlab.dt.api.display.setAspectRatio($(\".mlab_current_component\"), \"4:3\");\n                                        $(\"[data-mlab-get-info='comp_aspects']\").hide();\n                                    });\n\n                                    $(\"[data-mlab-comp-aspect='16:9']\").on(\"click\", function () {\n                                        mlab.dt.api.display.setAspectRatio($(\".mlab_current_component\"), \"16:9\");\n                                        $(\"[data-mlab-get-info='comp_aspects']\").hide();\n                                    });\n\n                                    $(\"[data-mlab-comp-aspect='1:1']\").on(\"click\", function () {\n                                        mlab.dt.api.display.setAspectRatio($(\".mlab_current_component\"), \"1:1\");\n                                        $(\"[data-mlab-get-info='comp_aspects']\").hide();\n                                    });\n                                }\n                            }\n                        });\n                    });\n\n                    //prepare qtip for the credit of the icon use\n                    $('#mlab_credit_icons').qtip({\n                        hide: { delay: 500, fixed: true }, //give a small delay\n                        position: { my: 'left bottom', at: 'right center', adjust: { screen: true } },\n                        content: { text: function text() {\n                                return $(\"<div>The icons on this page are made by <a href='http://www.freepik.com' target='_blank' title='Freepik'>Freepik</a>, <a href='http://www.flaticon.com/authors/simpleicon' target='_blank' title='SimpleIcon'>SimpleIcon</a>, <a href='http://www.flaticon.com/authors/dave-gandy' target='_blank' title='Dave Gandy'>Dave Gandy</a>, <a href='http://www.flaticon.com/authors/anton-saputro' target='_blank' title='Anton Saputro'>Anton Saputro</a> and <a href='http://www.flaticon.com/authors/yannick' target='_blank' title='Yannick'>Yannick</a> from <a href='http://www.flaticon.com' target='_blank' title='Flaticon'>www.flaticon.com</a> and are licensed by <a href='http://creativecommons.org/licenses/by/3.0/' target='_blank' title='Creative Commons BY 3.0'>CC BY 3.0</a> - and many are made by the Sinett project at FFI.no</div>\").html();\n                            },\n                            title: { text: \"Credit for icons\" } },\n                        style: { classes: \"mlab_qtip_tooltip mlab_qtip_menu_tooltip\" }\n                    });\n\n                    //prepare qtip for the credit of the icon use\n                    $('#mlab_credit_icons').qtip({\n                        hide: { delay: 500, fixed: true }, //give a small delay\n                        position: { my: 'left bottom', at: 'right center', viewport: $(window) },\n                        content: { text: function text() {\n                                return $(\"<div>The icons on this page are made by <a href='http://www.freepik.com' target='_blank' title='Freepik'>Freepik</a>, <a href='http://www.flaticon.com/authors/simpleicon' target='_blank' title='SimpleIcon'>SimpleIcon</a>, <a href='http://www.flaticon.com/authors/dave-gandy' target='_blank' title='Dave Gandy'>Dave Gandy</a>, <a href='http://www.flaticon.com/authors/anton-saputro' target='_blank' title='Anton Saputro'>Anton Saputro</a> and <a href='http://www.flaticon.com/authors/yannick' target='_blank' title='Yannick'>Yannick</a> from <a href='http://www.flaticon.com' target='_blank' title='Flaticon'>www.flaticon.com</a> and are licensed by <a href='http://creativecommons.org/licenses/by/3.0/' target='_blank' title='Creative Commons BY 3.0'>CC BY 3.0</a> - and many are made by the Sinett project at FFI.no</div>\").html();\n                            },\n                            title: { text: \"Credit for icons\" } },\n                        style: { classes: \"mlab_qtip_tooltip mlab_qtip_menu_tooltip\", tip: true }\n                    });\n\n                    //prepare qtip for the download of app buttons\n                    $.each(mlab.dt.config.compiler_service.supported_platforms, function (index, platform) {\n                        $('#mlab_download_' + platform + '_icon').qtip({\n                            hide: { delay: 500, fixed: true }, //give a small delay to allow the user t mouse over it.\n                            content: { text: function text() {\n                                    return $(\"[data-mlab-download-link-info='\" + platform + \"']\").html();\n                                },\n                                title: { text: _tr[\"mlab_editor.init.js.qtip.download.app.title\"] + \" \" + platform } },\n                            style: { classes: \"mlab_qtip_tooltip mlab_qtip_menu_tooltip\", tip: true }\n                        });\n                    });\n                } else {\n                    alert(_tr[\"mlab_editor.init.js.compiling.failed.loading.comps\"]);\n                    //document.location.href = document.mlab_temp_vars.appbuilder_root_url;\n                }\n            });\n        } else {\n            alert(_tr[\"mlab_editor.init.js.compiling.failed.loading.var\"]);\n            //document.location.href = document.mlab_temp_vars.appbuilder_root_url;\n        }\n    });\n});"

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./node_modules/babel-loader/lib/index.js??ref--0-0!./assets/js/spin.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/raw-loader!./node_modules/babel-loader/lib??ref--0-0!./assets/js/spin.js ***!
  \***********************************************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports) {

module.exports = "var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n * Copyright (c) 2011-2014 Felix Gnass\n * Licensed under the MIT license\n * http://spin.js.org/\n *\n * Example:\n    var opts = {\n      lines: 12,            // The number of lines to draw\n      length: 7,            // The length of each line\n      width: 5,             // The line thickness\n      radius: 10,           // The radius of the inner circle\n      scale: 1.0,           // Scales overall size of the spinner\n      corners: 1,           // Roundness (0..1)\n      color: '#000',        // #rgb or #rrggbb\n      opacity: 1/4,         // Opacity of the lines\n      rotate: 0,            // Rotation offset\n      direction: 1,         // 1: clockwise, -1: counterclockwise\n      speed: 1,             // Rounds per second\n      trail: 100,           // Afterglow percentage\n      fps: 20,              // Frames per second when using setTimeout()\n      zIndex: 2e9,          // Use a high z-index by default\n      className: 'spinner', // CSS class to assign to the element\n      top: '50%',           // center vertically\n      left: '50%',          // center horizontally\n      shadow: false,        // Whether to render a shadow\n      hwaccel: false,       // Whether to use hardware acceleration (might be buggy)\n      position: 'absolute'  // Element positioning\n    };\n    var target = document.getElementById('foo');\n    var spinner = new Spinner(opts).spin(target);\n */\n;(function (root, factory) {\n  if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) == 'object' && module.exports) module.exports = factory(); // CommonJS\n  else if (typeof define == 'function' && define.amd) define(factory); // AMD module\n    else root.Spinner = factory(); // Browser global\n})(this, function () {\n  'use strict';\n\n  var prefixes = ['webkit', 'Moz', 'ms', 'O']; // Vendor prefixes\n  var animations = {}; // Animation rules keyed by their name\n  var useCssAnimations; // Whether to use CSS animations or setTimeout\n  var sheet; // A stylesheet to hold the @keyframe or VML rules\n\n  /**\n   * Utility function to create elements. If no tag name is given,\n   * a DIV is created. Optionally properties can be passed.\n   */\n  function createEl(tag, prop) {\n    var el = document.createElement(tag || 'div');\n    var n;\n\n    for (n in prop) {\n      el[n] = prop[n];\n    }return el;\n  }\n\n  /**\n   * Appends children and returns the parent.\n   */\n  function ins(parent /* child1, child2, ...*/) {\n    for (var i = 1, n = arguments.length; i < n; i++) {\n      parent.appendChild(arguments[i]);\n    }\n\n    return parent;\n  }\n\n  /**\n   * Creates an opacity keyframe animation rule and returns its name.\n   * Since most mobile Webkits have timing issues with animation-delay,\n   * we create separate rules for each line/segment.\n   */\n  function addAnimation(alpha, trail, i, lines) {\n    var name = ['opacity', trail, ~~(alpha * 100), i, lines].join('-');\n    var start = 0.01 + i / lines * 100;\n    var z = Math.max(1 - (1 - alpha) / trail * (100 - start), alpha);\n    var prefix = useCssAnimations.substring(0, useCssAnimations.indexOf('Animation')).toLowerCase();\n    var pre = prefix && '-' + prefix + '-' || '';\n\n    if (!animations[name]) {\n      sheet.insertRule('@' + pre + 'keyframes ' + name + '{' + '0%{opacity:' + z + '}' + start + '%{opacity:' + alpha + '}' + (start + 0.01) + '%{opacity:1}' + (start + trail) % 100 + '%{opacity:' + alpha + '}' + '100%{opacity:' + z + '}' + '}', sheet.cssRules.length);\n\n      animations[name] = 1;\n    }\n\n    return name;\n  }\n\n  /**\n   * Tries various vendor prefixes and returns the first supported property.\n   */\n  function vendor(el, prop) {\n    var s = el.style;\n    var pp;\n    var i;\n\n    prop = prop.charAt(0).toUpperCase() + prop.slice(1);\n    if (s[prop] !== undefined) return prop;\n    for (i = 0; i < prefixes.length; i++) {\n      pp = prefixes[i] + prop;\n      if (s[pp] !== undefined) return pp;\n    }\n  }\n\n  /**\n   * Sets multiple style properties at once.\n   */\n  function css(el, prop) {\n    for (var n in prop) {\n      el.style[vendor(el, n) || n] = prop[n];\n    }\n\n    return el;\n  }\n\n  /**\n   * Fills in default values.\n   */\n  function merge(obj) {\n    for (var i = 1; i < arguments.length; i++) {\n      var def = arguments[i];\n      for (var n in def) {\n        if (obj[n] === undefined) obj[n] = def[n];\n      }\n    }\n    return obj;\n  }\n\n  /**\n   * Returns the line color from the given string or array.\n   */\n  function getColor(color, idx) {\n    return typeof color == 'string' ? color : color[idx % color.length];\n  }\n\n  // Built-in defaults\n\n  var defaults = {\n    lines: 12, // The number of lines to draw\n    length: 7, // The length of each line\n    width: 5, // The line thickness\n    radius: 10, // The radius of the inner circle\n    scale: 1.0, // Scales overall size of the spinner\n    corners: 1, // Roundness (0..1)\n    color: '#000', // #rgb or #rrggbb\n    opacity: 1 / 4, // Opacity of the lines\n    rotate: 0, // Rotation offset\n    direction: 1, // 1: clockwise, -1: counterclockwise\n    speed: 1, // Rounds per second\n    trail: 100, // Afterglow percentage\n    fps: 20, // Frames per second when using setTimeout()\n    zIndex: 2e9, // Use a high z-index by default\n    className: 'spinner', // CSS class to assign to the element\n    top: '50%', // center vertically\n    left: '50%', // center horizontally\n    shadow: false, // Whether to render a shadow\n    hwaccel: false, // Whether to use hardware acceleration\n    position: 'absolute' // Element positioning\n  };\n\n  /** The constructor */\n  function Spinner(o) {\n    this.opts = merge(o || {}, Spinner.defaults, defaults);\n  }\n\n  // Global defaults that override the built-ins:\n  Spinner.defaults = {};\n\n  merge(Spinner.prototype, {\n    /**\n     * Adds the spinner to the given target element. If this instance is already\n     * spinning, it is automatically removed from its previous target b calling\n     * stop() internally.\n     */\n    spin: function spin(target) {\n      this.stop();\n\n      var self = this;\n      var o = self.opts;\n      var el = self.el = createEl(null, { className: o.className });\n\n      css(el, {\n        position: o.position,\n        width: 0,\n        zIndex: o.zIndex,\n        left: o.left,\n        top: o.top\n      });\n\n      if (target) {\n        target.insertBefore(el, target.firstChild || null);\n      }\n\n      el.setAttribute('role', 'progressbar');\n      self.lines(el, self.opts);\n\n      if (!useCssAnimations) {\n        // No CSS animation support, use setTimeout() instead\n        var i = 0;\n        var start = (o.lines - 1) * (1 - o.direction) / 2;\n        var alpha;\n        var fps = o.fps;\n        var f = fps / o.speed;\n        var ostep = (1 - o.opacity) / (f * o.trail / 100);\n        var astep = f / o.lines;\n\n        (function anim() {\n          i++;\n          for (var j = 0; j < o.lines; j++) {\n            alpha = Math.max(1 - (i + (o.lines - j) * astep) % f * ostep, o.opacity);\n\n            self.opacity(el, j * o.direction + start, alpha, o);\n          }\n          self.timeout = self.el && setTimeout(anim, ~~(1000 / fps));\n        })();\n      }\n      return self;\n    },\n\n    /**\n     * Stops and removes the Spinner.\n     */\n    stop: function stop() {\n      var el = this.el;\n      if (el) {\n        clearTimeout(this.timeout);\n        if (el.parentNode) el.parentNode.removeChild(el);\n        this.el = undefined;\n      }\n      return this;\n    },\n\n    /**\n     * Internal method that draws the individual lines. Will be overwritten\n     * in VML fallback mode below.\n     */\n    lines: function lines(el, o) {\n      var i = 0;\n      var start = (o.lines - 1) * (1 - o.direction) / 2;\n      var seg;\n\n      function fill(color, shadow) {\n        return css(createEl(), {\n          position: 'absolute',\n          width: o.scale * (o.length + o.width) + 'px',\n          height: o.scale * o.width + 'px',\n          background: color,\n          boxShadow: shadow,\n          transformOrigin: 'left',\n          transform: 'rotate(' + ~~(360 / o.lines * i + o.rotate) + 'deg) translate(' + o.scale * o.radius + 'px' + ',0)',\n          borderRadius: (o.corners * o.scale * o.width >> 1) + 'px'\n        });\n      }\n\n      for (; i < o.lines; i++) {\n        seg = css(createEl(), {\n          position: 'absolute',\n          top: 1 + ~(o.scale * o.width / 2) + 'px',\n          transform: o.hwaccel ? 'translate3d(0,0,0)' : '',\n          opacity: o.opacity,\n          animation: useCssAnimations && addAnimation(o.opacity, o.trail, start + i * o.direction, o.lines) + ' ' + 1 / o.speed + 's linear infinite'\n        });\n\n        if (o.shadow) ins(seg, css(fill('#000', '0 0 4px #000'), { top: '2px' }));\n        ins(el, ins(seg, fill(getColor(o.color, i), '0 0 1px rgba(0,0,0,.1)')));\n      }\n      return el;\n    },\n\n    /**\n     * Internal method that adjusts the opacity of a single line.\n     * Will be overwritten in VML fallback mode below.\n     */\n    opacity: function opacity(el, i, val) {\n      if (i < el.childNodes.length) el.childNodes[i].style.opacity = val;\n    }\n\n  });\n\n  function initVML() {\n\n    /* Utility function to create a VML tag */\n    function vml(tag, attr) {\n      return createEl('<' + tag + ' xmlns=\"urn:schemas-microsoft.com:vml\" class=\"spin-vml\">', attr);\n    }\n\n    // No CSS transforms but VML support, add a CSS rule for VML elements:\n    sheet.addRule('.spin-vml', 'behavior:url(#default#VML)');\n\n    Spinner.prototype.lines = function (el, o) {\n      var r = o.scale * (o.length + o.width);\n      var s = o.scale * 2 * r;\n\n      function grp() {\n        return css(vml('group', {\n          coordsize: s + ' ' + s,\n          coordorigin: -r + ' ' + -r\n        }), { width: s, height: s });\n      }\n\n      var margin = -(o.width + o.length) * o.scale * 2 + 'px';\n      var g = css(grp(), { position: 'absolute', top: margin, left: margin });\n      var i;\n\n      function seg(i, dx, filter) {\n        ins(g, ins(css(grp(), { rotation: 360 / o.lines * i + 'deg', left: ~~dx }), ins(css(vml('roundrect', { arcsize: o.corners }), {\n          width: r,\n          height: o.scale * o.width,\n          left: o.scale * o.radius,\n          top: -o.scale * o.width >> 1,\n          filter: filter\n        }), vml('fill', { color: getColor(o.color, i), opacity: o.opacity }), vml('stroke', { opacity: 0 }) // transparent stroke to fix color bleeding upon opacity change\n        )));\n      }\n\n      if (o.shadow) for (i = 1; i <= o.lines; i++) {\n        seg(i, -2, 'progid:DXImageTransform.Microsoft.Blur(pixelradius=2,makeshadow=1,shadowopacity=.3)');\n      }\n\n      for (i = 1; i <= o.lines; i++) {\n        seg(i);\n      }return ins(el, g);\n    };\n\n    Spinner.prototype.opacity = function (el, i, val, o) {\n      var c = el.firstChild;\n      o = o.shadow && o.lines || 0;\n      if (c && i + o < c.childNodes.length) {\n        c = c.childNodes[i + o];c = c && c.firstChild;c = c && c.firstChild;\n        if (c) c.opacity = val;\n      }\n    };\n  }\n\n  if (typeof document !== 'undefined') {\n    sheet = function () {\n      var el = createEl('style', { type: 'text/css' });\n      ins(document.getElementsByTagName('head')[0], el);\n      return el.sheet || el.styleSheet;\n    }();\n\n    var probe = css(createEl('group'), { behavior: 'url(#default#VML)' });\n\n    if (!vendor(probe, 'transform') && probe.adj) initVML();else useCssAnimations = vendor(probe, 'animation');\n  }\n\n  return Spinner;\n});"

/***/ }),

/***/ "./node_modules/script-loader/addScript.js":
/*!*************************************************!*\
  !*** ./node_modules/script-loader/addScript.js ***!
  \*************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
module.exports = function(src) {
	function log(error) {
		(typeof console !== "undefined")
		&& (console.error || console.log)("[Script Loader]", error);
	}

	// Check for IE =< 8
	function isIE() {
		return typeof attachEvent !== "undefined" && typeof addEventListener === "undefined";
	}

	try {
		if (typeof execScript !== "undefined" && isIE()) {
			execScript(src);
		} else if (typeof eval !== "undefined") {
			eval.call(null, src);
		} else {
			log("EvalError: No eval function available");
		}
	} catch (error) {
		log(error);
	}
}


/***/ }),

/***/ "./node_modules/script-loader/index.js!./assets/js/jquery.mobile-1.4.5.js":
/*!***********************************************************************!*\
  !*** ./node_modules/script-loader!./assets/js/jquery.mobile-1.4.5.js ***!
  \***********************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! !./node_modules/script-loader/addScript.js */ "./node_modules/script-loader/addScript.js")(__webpack_require__(/*! !./node_modules/raw-loader!./node_modules/babel-loader/lib??ref--0-0!./assets/js/jquery.mobile-1.4.5.js */ "./node_modules/raw-loader/index.js!./node_modules/babel-loader/lib/index.js??ref--0-0!./assets/js/jquery.mobile-1.4.5.js")+"\n\n// SCRIPT-LOADER FOOTER\n//# sourceURL=script:///home/osboxes/workspace/mlab.local.test/node_modules/babel-loader/lib/index.js%3F?ref--0-0!/home/osboxes/workspace/mlab.local.test/assets/js/jquery.mobile-1.4.5.js")

/***/ }),

/***/ "./node_modules/script-loader/index.js!./assets/js/jquery.qrcode-0.12.0.js":
/*!************************************************************************!*\
  !*** ./node_modules/script-loader!./assets/js/jquery.qrcode-0.12.0.js ***!
  \************************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! !./node_modules/script-loader/addScript.js */ "./node_modules/script-loader/addScript.js")(__webpack_require__(/*! !./node_modules/raw-loader!./node_modules/babel-loader/lib??ref--0-0!./assets/js/jquery.qrcode-0.12.0.js */ "./node_modules/raw-loader/index.js!./node_modules/babel-loader/lib/index.js??ref--0-0!./assets/js/jquery.qrcode-0.12.0.js")+"\n\n// SCRIPT-LOADER FOOTER\n//# sourceURL=script:///home/osboxes/workspace/mlab.local.test/node_modules/babel-loader/lib/index.js%3F?ref--0-0!/home/osboxes/workspace/mlab.local.test/assets/js/jquery.qrcode-0.12.0.js")

/***/ }),

/***/ "./node_modules/script-loader/index.js!./assets/js/jquery.spin.js":
/*!***************************************************************!*\
  !*** ./node_modules/script-loader!./assets/js/jquery.spin.js ***!
  \***************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! !./node_modules/script-loader/addScript.js */ "./node_modules/script-loader/addScript.js")(__webpack_require__(/*! !./node_modules/raw-loader!./node_modules/babel-loader/lib??ref--0-0!./assets/js/jquery.spin.js */ "./node_modules/raw-loader/index.js!./node_modules/babel-loader/lib/index.js??ref--0-0!./assets/js/jquery.spin.js")+"\n\n// SCRIPT-LOADER FOOTER\n//# sourceURL=script:///home/osboxes/workspace/mlab.local.test/node_modules/babel-loader/lib/index.js%3F?ref--0-0!/home/osboxes/workspace/mlab.local.test/assets/js/jquery.spin.js")

/***/ }),

/***/ "./node_modules/script-loader/index.js!./assets/js/mlab.api.js":
/*!************************************************************!*\
  !*** ./node_modules/script-loader!./assets/js/mlab.api.js ***!
  \************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! !./node_modules/script-loader/addScript.js */ "./node_modules/script-loader/addScript.js")(__webpack_require__(/*! !./node_modules/raw-loader!./node_modules/babel-loader/lib??ref--0-0!./assets/js/mlab.api.js */ "./node_modules/raw-loader/index.js!./node_modules/babel-loader/lib/index.js??ref--0-0!./assets/js/mlab.api.js")+"\n\n// SCRIPT-LOADER FOOTER\n//# sourceURL=script:///home/osboxes/workspace/mlab.local.test/node_modules/babel-loader/lib/index.js%3F?ref--0-0!/home/osboxes/workspace/mlab.local.test/assets/js/mlab.api.js")

/***/ }),

/***/ "./node_modules/script-loader/index.js!./assets/js/mlab.dt.api.js":
/*!***************************************************************!*\
  !*** ./node_modules/script-loader!./assets/js/mlab.dt.api.js ***!
  \***************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! !./node_modules/script-loader/addScript.js */ "./node_modules/script-loader/addScript.js")(__webpack_require__(/*! !./node_modules/raw-loader!./node_modules/babel-loader/lib??ref--0-0!./assets/js/mlab.dt.api.js */ "./node_modules/raw-loader/index.js!./node_modules/babel-loader/lib/index.js??ref--0-0!./assets/js/mlab.dt.api.js")+"\n\n// SCRIPT-LOADER FOOTER\n//# sourceURL=script:///home/osboxes/workspace/mlab.local.test/node_modules/babel-loader/lib/index.js%3F?ref--0-0!/home/osboxes/workspace/mlab.local.test/assets/js/mlab.dt.api.js")

/***/ }),

/***/ "./node_modules/script-loader/index.js!./assets/js/mlab.dt.bestpractice.js":
/*!************************************************************************!*\
  !*** ./node_modules/script-loader!./assets/js/mlab.dt.bestpractice.js ***!
  \************************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! !./node_modules/script-loader/addScript.js */ "./node_modules/script-loader/addScript.js")(__webpack_require__(/*! !./node_modules/raw-loader!./node_modules/babel-loader/lib??ref--0-0!./assets/js/mlab.dt.bestpractice.js */ "./node_modules/raw-loader/index.js!./node_modules/babel-loader/lib/index.js??ref--0-0!./assets/js/mlab.dt.bestpractice.js")+"\n\n// SCRIPT-LOADER FOOTER\n//# sourceURL=script:///home/osboxes/workspace/mlab.local.test/node_modules/babel-loader/lib/index.js%3F?ref--0-0!/home/osboxes/workspace/mlab.local.test/assets/js/mlab.dt.bestpractice.js")

/***/ }),

/***/ "./node_modules/script-loader/index.js!./assets/js/mlab.dt.design.js":
/*!******************************************************************!*\
  !*** ./node_modules/script-loader!./assets/js/mlab.dt.design.js ***!
  \******************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! !./node_modules/script-loader/addScript.js */ "./node_modules/script-loader/addScript.js")(__webpack_require__(/*! !./node_modules/raw-loader!./node_modules/babel-loader/lib??ref--0-0!./assets/js/mlab.dt.design.js */ "./node_modules/raw-loader/index.js!./node_modules/babel-loader/lib/index.js??ref--0-0!./assets/js/mlab.dt.design.js")+"\n\n// SCRIPT-LOADER FOOTER\n//# sourceURL=script:///home/osboxes/workspace/mlab.local.test/node_modules/babel-loader/lib/index.js%3F?ref--0-0!/home/osboxes/workspace/mlab.local.test/assets/js/mlab.dt.design.js")

/***/ }),

/***/ "./node_modules/script-loader/index.js!./assets/js/mlab.dt.management.js":
/*!**********************************************************************!*\
  !*** ./node_modules/script-loader!./assets/js/mlab.dt.management.js ***!
  \**********************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! !./node_modules/script-loader/addScript.js */ "./node_modules/script-loader/addScript.js")(__webpack_require__(/*! !./node_modules/raw-loader!./node_modules/babel-loader/lib??ref--0-0!./assets/js/mlab.dt.management.js */ "./node_modules/raw-loader/index.js!./node_modules/babel-loader/lib/index.js??ref--0-0!./assets/js/mlab.dt.management.js")+"\n\n// SCRIPT-LOADER FOOTER\n//# sourceURL=script:///home/osboxes/workspace/mlab.local.test/node_modules/babel-loader/lib/index.js%3F?ref--0-0!/home/osboxes/workspace/mlab.local.test/assets/js/mlab.dt.management.js")

/***/ }),

/***/ "./node_modules/script-loader/index.js!./assets/js/mlab.dt.utils.js":
/*!*****************************************************************!*\
  !*** ./node_modules/script-loader!./assets/js/mlab.dt.utils.js ***!
  \*****************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! !./node_modules/script-loader/addScript.js */ "./node_modules/script-loader/addScript.js")(__webpack_require__(/*! !./node_modules/raw-loader!./node_modules/babel-loader/lib??ref--0-0!./assets/js/mlab.dt.utils.js */ "./node_modules/raw-loader/index.js!./node_modules/babel-loader/lib/index.js??ref--0-0!./assets/js/mlab.dt.utils.js")+"\n\n// SCRIPT-LOADER FOOTER\n//# sourceURL=script:///home/osboxes/workspace/mlab.local.test/node_modules/babel-loader/lib/index.js%3F?ref--0-0!/home/osboxes/workspace/mlab.local.test/assets/js/mlab.dt.utils.js")

/***/ }),

/***/ "./node_modules/script-loader/index.js!./assets/js/mlab_editor.init.js":
/*!********************************************************************!*\
  !*** ./node_modules/script-loader!./assets/js/mlab_editor.init.js ***!
  \********************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! !./node_modules/script-loader/addScript.js */ "./node_modules/script-loader/addScript.js")(__webpack_require__(/*! !./node_modules/raw-loader!./node_modules/babel-loader/lib??ref--0-0!./assets/js/mlab_editor.init.js */ "./node_modules/raw-loader/index.js!./node_modules/babel-loader/lib/index.js??ref--0-0!./assets/js/mlab_editor.init.js")+"\n\n// SCRIPT-LOADER FOOTER\n//# sourceURL=script:///home/osboxes/workspace/mlab.local.test/node_modules/babel-loader/lib/index.js%3F?ref--0-0!/home/osboxes/workspace/mlab.local.test/assets/js/mlab_editor.init.js")

/***/ }),

/***/ "./node_modules/script-loader/index.js!./assets/js/spin.js":
/*!********************************************************!*\
  !*** ./node_modules/script-loader!./assets/js/spin.js ***!
  \********************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! !./node_modules/script-loader/addScript.js */ "./node_modules/script-loader/addScript.js")(__webpack_require__(/*! !./node_modules/raw-loader!./node_modules/babel-loader/lib??ref--0-0!./assets/js/spin.js */ "./node_modules/raw-loader/index.js!./node_modules/babel-loader/lib/index.js??ref--0-0!./assets/js/spin.js")+"\n\n// SCRIPT-LOADER FOOTER\n//# sourceURL=script:///home/osboxes/workspace/mlab.local.test/node_modules/babel-loader/lib/index.js%3F?ref--0-0!/home/osboxes/workspace/mlab.local.test/assets/js/spin.js")

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgMDBkNDJiMjY3OTExM2ZjNzc5M2QiLCJ3ZWJwYWNrOi8vLy4vYXNzZXRzL2pzL2J1aWxkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vYXNzZXRzL2pzL2pxdWVyeS5tb2JpbGUtMS40LjUuanMiLCJ3ZWJwYWNrOi8vLy4vYXNzZXRzL2pzL2pxdWVyeS5xcmNvZGUtMC4xMi4wLmpzIiwid2VicGFjazovLy8uL2Fzc2V0cy9qcy9qcXVlcnkuc3Bpbi5qcyIsIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvbWxhYi5hcGkuanMiLCJ3ZWJwYWNrOi8vLy4vYXNzZXRzL2pzL21sYWIuZHQuYXBpLmpzIiwid2VicGFjazovLy8uL2Fzc2V0cy9qcy9tbGFiLmR0LmJlc3RwcmFjdGljZS5qcyIsIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvbWxhYi5kdC5kZXNpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vYXNzZXRzL2pzL21sYWIuZHQubWFuYWdlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvbWxhYi5kdC51dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvbWxhYl9lZGl0b3IuaW5pdC5qcyIsIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvc3Bpbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanMiLCJ3ZWJwYWNrOi8vLy4vYXNzZXRzL2pzL2pxdWVyeS5tb2JpbGUtMS40LjUuanM/OTc2MyIsIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvanF1ZXJ5LnFyY29kZS0wLjEyLjAuanM/MmMyYyIsIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvanF1ZXJ5LnNwaW4uanM/ODFjMSIsIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvbWxhYi5hcGkuanM/ZWVjZCIsIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvbWxhYi5kdC5hcGkuanM/NjFiNCIsIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvbWxhYi5kdC5iZXN0cHJhY3RpY2UuanM/OTVlYSIsIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvbWxhYi5kdC5kZXNpZ24uanM/NmQzYyIsIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvbWxhYi5kdC5tYW5hZ2VtZW50LmpzPzViODUiLCJ3ZWJwYWNrOi8vLy4vYXNzZXRzL2pzL21sYWIuZHQudXRpbHMuanM/Yjk1ZSIsIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvbWxhYl9lZGl0b3IuaW5pdC5qcz8xZDQ2Iiwid2VicGFjazovLy8uL2Fzc2V0cy9qcy9zcGluLmpzPzhmNWIiXSwibmFtZXMiOlsicmVxdWlyZSJdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBMkIsMEJBQTBCLEVBQUU7QUFDdkQseUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQXNELCtEQUErRDs7QUFFckg7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDN0RBOzs7Ozs7QUFNQUEsbUJBQU9BLENBQUMsd0hBQVI7QUFDQUEsbUJBQU9BLENBQUMsMEhBQVI7QUFDQUEsbUJBQU9BLENBQUMsMEZBQVI7QUFDQUEsbUJBQU9BLENBQUMsd0dBQVI7QUFDQUEsbUJBQU9BLENBQUMsa0dBQVI7QUFDQUEsbUJBQU9BLENBQUMsd0dBQVI7QUFDQUEsbUJBQU9BLENBQUMsc0hBQVI7QUFDQUEsbUJBQU9BLENBQUMsMEhBQVI7QUFDQUEsbUJBQU9BLENBQUMsOEdBQVI7QUFDQUEsbUJBQU9BLENBQUMsNEdBQVI7QUFDQUEsbUJBQU9BLENBQUMsa0hBQVIs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QU8sQ0FBQywyTUFBK04sNk0iLCJmaWxlIjoiYnVpbGRlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIi9idWlsZC9cIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vYXNzZXRzL2pzL2J1aWxkZXIuanNcIik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgMDBkNDJiMjY3OTExM2ZjNzc5M2QiLCIvKiBcbiAqIFRvIGNoYW5nZSB0aGlzIGxpY2Vuc2UgaGVhZGVyLCBjaG9vc2UgTGljZW5zZSBIZWFkZXJzIGluIFByb2plY3QgUHJvcGVydGllcy5cbiAqIFRvIGNoYW5nZSB0aGlzIHRlbXBsYXRlIGZpbGUsIGNob29zZSBUb29scyB8IFRlbXBsYXRlc1xuICogYW5kIG9wZW4gdGhlIHRlbXBsYXRlIGluIHRoZSBlZGl0b3IuXG4gKi9cblxucmVxdWlyZSgnc2NyaXB0LWxvYWRlciEuL2pxdWVyeS5tb2JpbGUtMS40LjUuanMnKTtcbnJlcXVpcmUoJ3NjcmlwdC1sb2FkZXIhLi9qcXVlcnkucXJjb2RlLTAuMTIuMC5qcycpO1xucmVxdWlyZSgnc2NyaXB0LWxvYWRlciEuL3NwaW4uanMnKTtcbnJlcXVpcmUoJ3NjcmlwdC1sb2FkZXIhLi9qcXVlcnkuc3Bpbi5qcycpO1xucmVxdWlyZSgnc2NyaXB0LWxvYWRlciEuL21sYWIuYXBpLmpzJyk7XG5yZXF1aXJlKCdzY3JpcHQtbG9hZGVyIS4vbWxhYi5kdC5hcGkuanMnKTtcbnJlcXVpcmUoJ3NjcmlwdC1sb2FkZXIhLi9tbGFiLmR0Lm1hbmFnZW1lbnQuanMnKTtcbnJlcXVpcmUoJ3NjcmlwdC1sb2FkZXIhLi9tbGFiLmR0LmJlc3RwcmFjdGljZS5qcycpO1xucmVxdWlyZSgnc2NyaXB0LWxvYWRlciEuL21sYWIuZHQuZGVzaWduLmpzJyk7XG5yZXF1aXJlKCdzY3JpcHQtbG9hZGVyIS4vbWxhYi5kdC51dGlscy5qcycpO1xucmVxdWlyZSgnc2NyaXB0LWxvYWRlciEuL21sYWJfZWRpdG9yLmluaXQuanMnKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Fzc2V0cy9qcy9idWlsZGVyLmpzIiwibW9kdWxlLmV4cG9ydHMgPSBcInZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcXFwic3ltYm9sXFxcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcXFwic3ltYm9sXFxcIiA6IHR5cGVvZiBvYmo7IH07XFxuXFxuLyohIGpRdWVyeSBNb2JpbGUgMS40LjUgfCBHaXQgSEVBRGhhc2g6IDY4ZTU1ZTcgPD4gMjAxNC0xMC0zMVQxNzozMzozMFogfCAoYykgMjAxMCwgMjAxNCBqUXVlcnkgRm91bmRhdGlvbiwgSW5jLiB8IGpxdWVyeS5vcmcvbGljZW5zZSAqL1xcblxcbiFmdW5jdGlvbiAoYSwgYiwgYykge1xcbiAgXFxcImZ1bmN0aW9uXFxcIiA9PSB0eXBlb2YgZGVmaW5lICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoW1xcXCJqcXVlcnlcXFwiXSwgZnVuY3Rpb24gKGQpIHtcXG4gICAgcmV0dXJuIGMoZCwgYSwgYiksIGQubW9iaWxlO1xcbiAgfSkgOiBjKGEualF1ZXJ5LCBhLCBiKTtcXG59KHRoaXMsIGRvY3VtZW50LCBmdW5jdGlvbiAoYSwgYiwgYykge1xcbiAgIWZ1bmN0aW9uIChhKSB7XFxuICAgIGEubW9iaWxlID0ge307XFxuICB9KGEpLCBmdW5jdGlvbiAoYSwgYikge1xcbiAgICBmdW5jdGlvbiBkKGIsIGMpIHtcXG4gICAgICB2YXIgZCxcXG4gICAgICAgICAgZixcXG4gICAgICAgICAgZyxcXG4gICAgICAgICAgaCA9IGIubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtyZXR1cm4gXFxcImFyZWFcXFwiID09PSBoID8gKGQgPSBiLnBhcmVudE5vZGUsIGYgPSBkLm5hbWUsIGIuaHJlZiAmJiBmICYmIFxcXCJtYXBcXFwiID09PSBkLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPyAoZyA9IGEoXFxcImltZ1t1c2VtYXA9I1xcXCIgKyBmICsgXFxcIl1cXFwiKVswXSwgISFnICYmIGUoZykpIDogITEpIDogKC9pbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9ufG9iamVjdC8udGVzdChoKSA/ICFiLmRpc2FibGVkIDogXFxcImFcXFwiID09PSBoID8gYi5ocmVmIHx8IGMgOiBjKSAmJiBlKGIpO1xcbiAgICB9ZnVuY3Rpb24gZShiKSB7XFxuICAgICAgcmV0dXJuIGEuZXhwci5maWx0ZXJzLnZpc2libGUoYikgJiYgIWEoYikucGFyZW50cygpLmFkZEJhY2soKS5maWx0ZXIoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgcmV0dXJuIFxcXCJoaWRkZW5cXFwiID09PSBhLmNzcyh0aGlzLCBcXFwidmlzaWJpbGl0eVxcXCIpO1xcbiAgICAgIH0pLmxlbmd0aDtcXG4gICAgfXZhciBmID0gMCxcXG4gICAgICAgIGcgPSAvXnVpLWlkLVxcXFxkKyQvO2EudWkgPSBhLnVpIHx8IHt9LCBhLmV4dGVuZChhLnVpLCB7IHZlcnNpb246IFxcXCJjMGFiNzEwNTZiOTM2NjI3ZThhNzgyMWYwM2MwNDRhZWM2MjgwYTQwXFxcIiwga2V5Q29kZTogeyBCQUNLU1BBQ0U6IDgsIENPTU1BOiAxODgsIERFTEVURTogNDYsIERPV046IDQwLCBFTkQ6IDM1LCBFTlRFUjogMTMsIEVTQ0FQRTogMjcsIEhPTUU6IDM2LCBMRUZUOiAzNywgUEFHRV9ET1dOOiAzNCwgUEFHRV9VUDogMzMsIFBFUklPRDogMTkwLCBSSUdIVDogMzksIFNQQUNFOiAzMiwgVEFCOiA5LCBVUDogMzggfSB9KSwgYS5mbi5leHRlbmQoeyBmb2N1czogZnVuY3Rpb24gKGIpIHtcXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoYywgZCkge1xcbiAgICAgICAgICByZXR1cm4gXFxcIm51bWJlclxcXCIgPT0gdHlwZW9mIGMgPyB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIHZhciBiID0gdGhpcztzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgIGEoYikuZm9jdXMoKSwgZCAmJiBkLmNhbGwoYik7XFxuICAgICAgICAgICAgfSwgYyk7XFxuICAgICAgICAgIH0pIDogYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgICAgICAgfTtcXG4gICAgICB9KGEuZm4uZm9jdXMpLCBzY3JvbGxQYXJlbnQ6IGZ1bmN0aW9uIHNjcm9sbFBhcmVudCgpIHtcXG4gICAgICAgIHZhciBiO3JldHVybiBiID0gYS51aS5pZSAmJiAvKHN0YXRpY3xyZWxhdGl2ZSkvLnRlc3QodGhpcy5jc3MoXFxcInBvc2l0aW9uXFxcIikpIHx8IC9hYnNvbHV0ZS8udGVzdCh0aGlzLmNzcyhcXFwicG9zaXRpb25cXFwiKSkgPyB0aGlzLnBhcmVudHMoKS5maWx0ZXIoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICByZXR1cm4gKC8ocmVsYXRpdmV8YWJzb2x1dGV8Zml4ZWQpLy50ZXN0KGEuY3NzKHRoaXMsIFxcXCJwb3NpdGlvblxcXCIpKSAmJiAvKGF1dG98c2Nyb2xsKS8udGVzdChhLmNzcyh0aGlzLCBcXFwib3ZlcmZsb3dcXFwiKSArIGEuY3NzKHRoaXMsIFxcXCJvdmVyZmxvdy15XFxcIikgKyBhLmNzcyh0aGlzLCBcXFwib3ZlcmZsb3cteFxcXCIpKVxcbiAgICAgICAgICApO1xcbiAgICAgICAgfSkuZXEoMCkgOiB0aGlzLnBhcmVudHMoKS5maWx0ZXIoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICByZXR1cm4gKC8oYXV0b3xzY3JvbGwpLy50ZXN0KGEuY3NzKHRoaXMsIFxcXCJvdmVyZmxvd1xcXCIpICsgYS5jc3ModGhpcywgXFxcIm92ZXJmbG93LXlcXFwiKSArIGEuY3NzKHRoaXMsIFxcXCJvdmVyZmxvdy14XFxcIikpXFxuICAgICAgICAgICk7XFxuICAgICAgICB9KS5lcSgwKSwgL2ZpeGVkLy50ZXN0KHRoaXMuY3NzKFxcXCJwb3NpdGlvblxcXCIpKSB8fCAhYi5sZW5ndGggPyBhKHRoaXNbMF0ub3duZXJEb2N1bWVudCB8fCBjKSA6IGI7XFxuICAgICAgfSwgdW5pcXVlSWQ6IGZ1bmN0aW9uIHVuaXF1ZUlkKCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHRoaXMuaWQgfHwgKHRoaXMuaWQgPSBcXFwidWktaWQtXFxcIiArICsrZik7XFxuICAgICAgICB9KTtcXG4gICAgICB9LCByZW1vdmVVbmlxdWVJZDogZnVuY3Rpb24gcmVtb3ZlVW5pcXVlSWQoKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgZy50ZXN0KHRoaXMuaWQpICYmIGEodGhpcykucmVtb3ZlQXR0cihcXFwiaWRcXFwiKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH0gfSksIGEuZXh0ZW5kKGEuZXhwcltcXFwiOlxcXCJdLCB7IGRhdGE6IGEuZXhwci5jcmVhdGVQc2V1ZG8gPyBhLmV4cHIuY3JlYXRlUHNldWRvKGZ1bmN0aW9uIChiKSB7XFxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGMpIHtcXG4gICAgICAgICAgcmV0dXJuICEhYS5kYXRhKGMsIGIpO1xcbiAgICAgICAgfTtcXG4gICAgICB9KSA6IGZ1bmN0aW9uIChiLCBjLCBkKSB7XFxuICAgICAgICByZXR1cm4gISFhLmRhdGEoYiwgZFszXSk7XFxuICAgICAgfSwgZm9jdXNhYmxlOiBmdW5jdGlvbiBmb2N1c2FibGUoYikge1xcbiAgICAgICAgcmV0dXJuIGQoYiwgIWlzTmFOKGEuYXR0cihiLCBcXFwidGFiaW5kZXhcXFwiKSkpO1xcbiAgICAgIH0sIHRhYmJhYmxlOiBmdW5jdGlvbiB0YWJiYWJsZShiKSB7XFxuICAgICAgICB2YXIgYyA9IGEuYXR0cihiLCBcXFwidGFiaW5kZXhcXFwiKSxcXG4gICAgICAgICAgICBlID0gaXNOYU4oYyk7cmV0dXJuIChlIHx8IGMgPj0gMCkgJiYgZChiLCAhZSk7XFxuICAgICAgfSB9KSwgYShcXFwiPGE+XFxcIikub3V0ZXJXaWR0aCgxKS5qcXVlcnkgfHwgYS5lYWNoKFtcXFwiV2lkdGhcXFwiLCBcXFwiSGVpZ2h0XFxcIl0sIGZ1bmN0aW9uIChjLCBkKSB7XFxuICAgICAgZnVuY3Rpb24gZShiLCBjLCBkLCBlKSB7XFxuICAgICAgICByZXR1cm4gYS5lYWNoKGYsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgYyAtPSBwYXJzZUZsb2F0KGEuY3NzKGIsIFxcXCJwYWRkaW5nXFxcIiArIHRoaXMpKSB8fCAwLCBkICYmIChjIC09IHBhcnNlRmxvYXQoYS5jc3MoYiwgXFxcImJvcmRlclxcXCIgKyB0aGlzICsgXFxcIldpZHRoXFxcIikpIHx8IDApLCBlICYmIChjIC09IHBhcnNlRmxvYXQoYS5jc3MoYiwgXFxcIm1hcmdpblxcXCIgKyB0aGlzKSkgfHwgMCk7XFxuICAgICAgICB9KSwgYztcXG4gICAgICB9dmFyIGYgPSBcXFwiV2lkdGhcXFwiID09PSBkID8gW1xcXCJMZWZ0XFxcIiwgXFxcIlJpZ2h0XFxcIl0gOiBbXFxcIlRvcFxcXCIsIFxcXCJCb3R0b21cXFwiXSxcXG4gICAgICAgICAgZyA9IGQudG9Mb3dlckNhc2UoKSxcXG4gICAgICAgICAgaCA9IHsgaW5uZXJXaWR0aDogYS5mbi5pbm5lcldpZHRoLCBpbm5lckhlaWdodDogYS5mbi5pbm5lckhlaWdodCwgb3V0ZXJXaWR0aDogYS5mbi5vdXRlcldpZHRoLCBvdXRlckhlaWdodDogYS5mbi5vdXRlckhlaWdodCB9O2EuZm5bXFxcImlubmVyXFxcIiArIGRdID0gZnVuY3Rpb24gKGMpIHtcXG4gICAgICAgIHJldHVybiBjID09PSBiID8gaFtcXFwiaW5uZXJcXFwiICsgZF0uY2FsbCh0aGlzKSA6IHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIGEodGhpcykuY3NzKGcsIGUodGhpcywgYykgKyBcXFwicHhcXFwiKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH0sIGEuZm5bXFxcIm91dGVyXFxcIiArIGRdID0gZnVuY3Rpb24gKGIsIGMpIHtcXG4gICAgICAgIHJldHVybiBcXFwibnVtYmVyXFxcIiAhPSB0eXBlb2YgYiA/IGhbXFxcIm91dGVyXFxcIiArIGRdLmNhbGwodGhpcywgYikgOiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBhKHRoaXMpLmNzcyhnLCBlKHRoaXMsIGIsICEwLCBjKSArIFxcXCJweFxcXCIpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfTtcXG4gICAgfSksIGEuZm4uYWRkQmFjayB8fCAoYS5mbi5hZGRCYWNrID0gZnVuY3Rpb24gKGEpIHtcXG4gICAgICByZXR1cm4gdGhpcy5hZGQobnVsbCA9PSBhID8gdGhpcy5wcmV2T2JqZWN0IDogdGhpcy5wcmV2T2JqZWN0LmZpbHRlcihhKSk7XFxuICAgIH0pLCBhKFxcXCI8YT5cXFwiKS5kYXRhKFxcXCJhLWJcXFwiLCBcXFwiYVxcXCIpLnJlbW92ZURhdGEoXFxcImEtYlxcXCIpLmRhdGEoXFxcImEtYlxcXCIpICYmIChhLmZuLnJlbW92ZURhdGEgPSBmdW5jdGlvbiAoYikge1xcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYykge1xcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyBiLmNhbGwodGhpcywgYS5jYW1lbENhc2UoYykpIDogYi5jYWxsKHRoaXMpO1xcbiAgICAgIH07XFxuICAgIH0oYS5mbi5yZW1vdmVEYXRhKSksIGEudWkuaWUgPSAhIS9tc2llIFtcXFxcdy5dKy8uZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkpLCBhLnN1cHBvcnQuc2VsZWN0c3RhcnQgPSBcXFwib25zZWxlY3RzdGFydFxcXCIgaW4gYy5jcmVhdGVFbGVtZW50KFxcXCJkaXZcXFwiKSwgYS5mbi5leHRlbmQoeyBkaXNhYmxlU2VsZWN0aW9uOiBmdW5jdGlvbiBkaXNhYmxlU2VsZWN0aW9uKCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuYmluZCgoYS5zdXBwb3J0LnNlbGVjdHN0YXJ0ID8gXFxcInNlbGVjdHN0YXJ0XFxcIiA6IFxcXCJtb3VzZWRvd25cXFwiKSArIFxcXCIudWktZGlzYWJsZVNlbGVjdGlvblxcXCIsIGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICAgIGEucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH0sIGVuYWJsZVNlbGVjdGlvbjogZnVuY3Rpb24gZW5hYmxlU2VsZWN0aW9uKCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMudW5iaW5kKFxcXCIudWktZGlzYWJsZVNlbGVjdGlvblxcXCIpO1xcbiAgICAgIH0sIHpJbmRleDogZnVuY3Rpb24gekluZGV4KGQpIHtcXG4gICAgICAgIGlmIChkICE9PSBiKSByZXR1cm4gdGhpcy5jc3MoXFxcInpJbmRleFxcXCIsIGQpO2lmICh0aGlzLmxlbmd0aCkgZm9yICh2YXIgZSwgZiwgZyA9IGEodGhpc1swXSk7IGcubGVuZ3RoICYmIGdbMF0gIT09IGM7KSB7XFxuICAgICAgICAgIGlmIChlID0gZy5jc3MoXFxcInBvc2l0aW9uXFxcIiksIChcXFwiYWJzb2x1dGVcXFwiID09PSBlIHx8IFxcXCJyZWxhdGl2ZVxcXCIgPT09IGUgfHwgXFxcImZpeGVkXFxcIiA9PT0gZSkgJiYgKGYgPSBwYXJzZUludChnLmNzcyhcXFwiekluZGV4XFxcIiksIDEwKSwgIWlzTmFOKGYpICYmIDAgIT09IGYpKSByZXR1cm4gZjtnID0gZy5wYXJlbnQoKTtcXG4gICAgICAgIH1yZXR1cm4gMDtcXG4gICAgICB9IH0pLCBhLnVpLnBsdWdpbiA9IHsgYWRkOiBmdW5jdGlvbiBhZGQoYiwgYywgZCkge1xcbiAgICAgICAgdmFyIGUsXFxuICAgICAgICAgICAgZiA9IGEudWlbYl0ucHJvdG90eXBlO2ZvciAoZSBpbiBkKSB7XFxuICAgICAgICAgIGYucGx1Z2luc1tlXSA9IGYucGx1Z2luc1tlXSB8fCBbXSwgZi5wbHVnaW5zW2VdLnB1c2goW2MsIGRbZV1dKTtcXG4gICAgICAgIH1cXG4gICAgICB9LCBjYWxsOiBmdW5jdGlvbiBjYWxsKGEsIGIsIGMsIGQpIHtcXG4gICAgICAgIHZhciBlLFxcbiAgICAgICAgICAgIGYgPSBhLnBsdWdpbnNbYl07aWYgKGYgJiYgKGQgfHwgYS5lbGVtZW50WzBdLnBhcmVudE5vZGUgJiYgMTEgIT09IGEuZWxlbWVudFswXS5wYXJlbnROb2RlLm5vZGVUeXBlKSkgZm9yIChlID0gMDsgZSA8IGYubGVuZ3RoOyBlKyspIHtcXG4gICAgICAgICAgYS5vcHRpb25zW2ZbZV1bMF1dICYmIGZbZV1bMV0uYXBwbHkoYS5lbGVtZW50LCBjKTtcXG4gICAgICAgIH1cXG4gICAgICB9IH07XFxuICB9KGEpLCBmdW5jdGlvbiAoYSwgYikge1xcbiAgICB2YXIgZCA9IGZ1bmN0aW9uIGQoYiwgYykge1xcbiAgICAgIHZhciBkID0gYi5wYXJlbnQoKSxcXG4gICAgICAgICAgZSA9IFtdLFxcbiAgICAgICAgICBmID0gZnVuY3Rpb24gZigpIHtcXG4gICAgICAgIHZhciBiID0gYSh0aGlzKSxcXG4gICAgICAgICAgICBjID0gYS5tb2JpbGUudG9vbGJhciAmJiBiLmRhdGEoXFxcIm1vYmlsZS10b29sYmFyXFxcIikgPyBiLnRvb2xiYXIoXFxcIm9wdGlvblxcXCIpIDogeyBwb3NpdGlvbjogYi5hdHRyKFxcXCJkYXRhLVxcXCIgKyBhLm1vYmlsZS5ucyArIFxcXCJwb3NpdGlvblxcXCIpLCB1cGRhdGVQYWdlUGFkZGluZzogYi5hdHRyKFxcXCJkYXRhLVxcXCIgKyBhLm1vYmlsZS5ucyArIFxcXCJ1cGRhdGUtcGFnZS1wYWRkaW5nXFxcIikgIT09ICExIH07cmV0dXJuICEoXFxcImZpeGVkXFxcIiA9PT0gYy5wb3NpdGlvbiAmJiBjLnVwZGF0ZVBhZ2VQYWRkaW5nID09PSAhMCk7XFxuICAgICAgfSxcXG4gICAgICAgICAgZyA9IGQuY2hpbGRyZW4oXFxcIjpqcW1EYXRhKHJvbGU9J2hlYWRlcicpXFxcIikuZmlsdGVyKGYpLFxcbiAgICAgICAgICBoID0gYi5jaGlsZHJlbihcXFwiOmpxbURhdGEocm9sZT0naGVhZGVyJylcXFwiKSxcXG4gICAgICAgICAgaSA9IGQuY2hpbGRyZW4oXFxcIjpqcW1EYXRhKHJvbGU9J2Zvb3RlcicpXFxcIikuZmlsdGVyKGYpLFxcbiAgICAgICAgICBqID0gYi5jaGlsZHJlbihcXFwiOmpxbURhdGEocm9sZT0nZm9vdGVyJylcXFwiKTtyZXR1cm4gMCA9PT0gaC5sZW5ndGggJiYgZy5sZW5ndGggPiAwICYmIChlID0gZS5jb25jYXQoZy50b0FycmF5KCkpKSwgMCA9PT0gai5sZW5ndGggJiYgaS5sZW5ndGggPiAwICYmIChlID0gZS5jb25jYXQoaS50b0FycmF5KCkpKSwgYS5lYWNoKGUsIGZ1bmN0aW9uIChiLCBkKSB7XFxuICAgICAgICBjIC09IGEoZCkub3V0ZXJIZWlnaHQoKTtcXG4gICAgICB9KSwgTWF0aC5tYXgoMCwgYyk7XFxuICAgIH07YS5leHRlbmQoYS5tb2JpbGUsIHsgd2luZG93OiBhKGIpLCBkb2N1bWVudDogYShjKSwga2V5Q29kZTogYS51aS5rZXlDb2RlLCBiZWhhdmlvcnM6IHt9LCBzaWxlbnRTY3JvbGw6IGZ1bmN0aW9uIHNpbGVudFNjcm9sbChjKSB7XFxuICAgICAgICBcXFwibnVtYmVyXFxcIiAhPT0gYS50eXBlKGMpICYmIChjID0gYS5tb2JpbGUuZGVmYXVsdEhvbWVTY3JvbGwpLCBhLmV2ZW50LnNwZWNpYWwuc2Nyb2xsc3RhcnQuZW5hYmxlZCA9ICExLCBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgYi5zY3JvbGxUbygwLCBjKSwgYS5tb2JpbGUuZG9jdW1lbnQudHJpZ2dlcihcXFwic2lsZW50c2Nyb2xsXFxcIiwgeyB4OiAwLCB5OiBjIH0pO1xcbiAgICAgICAgfSwgMjApLCBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgYS5ldmVudC5zcGVjaWFsLnNjcm9sbHN0YXJ0LmVuYWJsZWQgPSAhMDtcXG4gICAgICAgIH0sIDE1MCk7XFxuICAgICAgfSwgZ2V0Q2xvc2VzdEJhc2VVcmw6IGZ1bmN0aW9uIGdldENsb3Nlc3RCYXNlVXJsKGIpIHtcXG4gICAgICAgIHZhciBjID0gYShiKS5jbG9zZXN0KFxcXCIudWktcGFnZVxcXCIpLmpxbURhdGEoXFxcInVybFxcXCIpLFxcbiAgICAgICAgICAgIGQgPSBhLm1vYmlsZS5wYXRoLmRvY3VtZW50QmFzZS5ocmVmTm9IYXNoO3JldHVybiBhLm1vYmlsZS5keW5hbWljQmFzZUVuYWJsZWQgJiYgYyAmJiBhLm1vYmlsZS5wYXRoLmlzUGF0aChjKSB8fCAoYyA9IGQpLCBhLm1vYmlsZS5wYXRoLm1ha2VVcmxBYnNvbHV0ZShjLCBkKTtcXG4gICAgICB9LCByZW1vdmVBY3RpdmVMaW5rQ2xhc3M6IGZ1bmN0aW9uIHJlbW92ZUFjdGl2ZUxpbmtDbGFzcyhiKSB7XFxuICAgICAgICAhYS5tb2JpbGUuYWN0aXZlQ2xpY2tlZExpbmsgfHwgYS5tb2JpbGUuYWN0aXZlQ2xpY2tlZExpbmsuY2xvc2VzdChcXFwiLlxcXCIgKyBhLm1vYmlsZS5hY3RpdmVQYWdlQ2xhc3MpLmxlbmd0aCAmJiAhYiB8fCBhLm1vYmlsZS5hY3RpdmVDbGlja2VkTGluay5yZW1vdmVDbGFzcyhhLm1vYmlsZS5hY3RpdmVCdG5DbGFzcyksIGEubW9iaWxlLmFjdGl2ZUNsaWNrZWRMaW5rID0gbnVsbDtcXG4gICAgICB9LCBnZXRJbmhlcml0ZWRUaGVtZTogZnVuY3Rpb24gZ2V0SW5oZXJpdGVkVGhlbWUoYSwgYikge1xcbiAgICAgICAgZm9yICh2YXIgYywgZCwgZSA9IGFbMF0sIGYgPSBcXFwiXFxcIiwgZyA9IC91aS0oYmFyfGJvZHl8b3ZlcmxheSktKFthLXpdKVxcXFxiLzsgZSAmJiAoYyA9IGUuY2xhc3NOYW1lIHx8IFxcXCJcXFwiLCAhKGMgJiYgKGQgPSBnLmV4ZWMoYykpICYmIChmID0gZFsyXSkpKTspIHtcXG4gICAgICAgICAgZSA9IGUucGFyZW50Tm9kZTtcXG4gICAgICAgIH1yZXR1cm4gZiB8fCBiIHx8IFxcXCJhXFxcIjtcXG4gICAgICB9LCBlbmhhbmNlYWJsZTogZnVuY3Rpb24gZW5oYW5jZWFibGUoYSkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuaGF2ZVBhcmVudHMoYSwgXFxcImVuaGFuY2VcXFwiKTtcXG4gICAgICB9LCBoaWphY2thYmxlOiBmdW5jdGlvbiBoaWphY2thYmxlKGEpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLmhhdmVQYXJlbnRzKGEsIFxcXCJhamF4XFxcIik7XFxuICAgICAgfSwgaGF2ZVBhcmVudHM6IGZ1bmN0aW9uIGhhdmVQYXJlbnRzKGIsIGMpIHtcXG4gICAgICAgIGlmICghYS5tb2JpbGUuaWdub3JlQ29udGVudEVuYWJsZWQpIHJldHVybiBiO3ZhciBkLFxcbiAgICAgICAgICAgIGUsXFxuICAgICAgICAgICAgZixcXG4gICAgICAgICAgICBnLFxcbiAgICAgICAgICAgIGgsXFxuICAgICAgICAgICAgaSA9IGIubGVuZ3RoLFxcbiAgICAgICAgICAgIGogPSBhKCk7Zm9yIChnID0gMDsgaSA+IGc7IGcrKykge1xcbiAgICAgICAgICBmb3IgKGUgPSBiLmVxKGcpLCBmID0gITEsIGQgPSBiW2ddOyBkOykge1xcbiAgICAgICAgICAgIGlmIChoID0gZC5nZXRBdHRyaWJ1dGUgPyBkLmdldEF0dHJpYnV0ZShcXFwiZGF0YS1cXFwiICsgYS5tb2JpbGUubnMgKyBjKSA6IFxcXCJcXFwiLCBcXFwiZmFsc2VcXFwiID09PSBoKSB7XFxuICAgICAgICAgICAgICBmID0gITA7YnJlYWs7XFxuICAgICAgICAgICAgfWQgPSBkLnBhcmVudE5vZGU7XFxuICAgICAgICAgIH1mIHx8IChqID0gai5hZGQoZSkpO1xcbiAgICAgICAgfXJldHVybiBqO1xcbiAgICAgIH0sIGdldFNjcmVlbkhlaWdodDogZnVuY3Rpb24gZ2V0U2NyZWVuSGVpZ2h0KCkge1xcbiAgICAgICAgcmV0dXJuIGIuaW5uZXJIZWlnaHQgfHwgYS5tb2JpbGUud2luZG93LmhlaWdodCgpO1xcbiAgICAgIH0sIHJlc2V0QWN0aXZlUGFnZUhlaWdodDogZnVuY3Rpb24gcmVzZXRBY3RpdmVQYWdlSGVpZ2h0KGIpIHtcXG4gICAgICAgIHZhciBjID0gYShcXFwiLlxcXCIgKyBhLm1vYmlsZS5hY3RpdmVQYWdlQ2xhc3MpLFxcbiAgICAgICAgICAgIGUgPSBjLmhlaWdodCgpLFxcbiAgICAgICAgICAgIGYgPSBjLm91dGVySGVpZ2h0KCEwKTtiID0gZChjLCBcXFwibnVtYmVyXFxcIiA9PSB0eXBlb2YgYiA/IGIgOiBhLm1vYmlsZS5nZXRTY3JlZW5IZWlnaHQoKSksIGMuY3NzKFxcXCJtaW4taGVpZ2h0XFxcIiwgXFxcIlxcXCIpLCBjLmhlaWdodCgpIDwgYiAmJiBjLmNzcyhcXFwibWluLWhlaWdodFxcXCIsIGIgLSAoZiAtIGUpKTtcXG4gICAgICB9LCBsb2FkaW5nOiBmdW5jdGlvbiBsb2FkaW5nKCkge1xcbiAgICAgICAgdmFyIGIgPSB0aGlzLmxvYWRpbmcuX3dpZGdldCB8fCBhKGEubW9iaWxlLmxvYWRlci5wcm90b3R5cGUuZGVmYXVsdEh0bWwpLmxvYWRlcigpLFxcbiAgICAgICAgICAgIGMgPSBiLmxvYWRlci5hcHBseShiLCBhcmd1bWVudHMpO3JldHVybiB0aGlzLmxvYWRpbmcuX3dpZGdldCA9IGIsIGM7XFxuICAgICAgfSB9KSwgYS5hZGREZXBlbmRlbnRzID0gZnVuY3Rpb24gKGIsIGMpIHtcXG4gICAgICB2YXIgZCA9IGEoYiksXFxuICAgICAgICAgIGUgPSBkLmpxbURhdGEoXFxcImRlcGVuZGVudHNcXFwiKSB8fCBhKCk7ZC5qcW1EYXRhKFxcXCJkZXBlbmRlbnRzXFxcIiwgYShlKS5hZGQoYykpO1xcbiAgICB9LCBhLmZuLmV4dGVuZCh7IHJlbW92ZVdpdGhEZXBlbmRlbnRzOiBmdW5jdGlvbiByZW1vdmVXaXRoRGVwZW5kZW50cygpIHtcXG4gICAgICAgIGEucmVtb3ZlV2l0aERlcGVuZGVudHModGhpcyk7XFxuICAgICAgfSwgZW5oYW5jZVdpdGhpbjogZnVuY3Rpb24gZW5oYW5jZVdpdGhpbigpIHtcXG4gICAgICAgIHZhciBiLFxcbiAgICAgICAgICAgIGMgPSB7fSxcXG4gICAgICAgICAgICBkID0gYS5tb2JpbGUucGFnZS5wcm90b3R5cGUua2VlcE5hdGl2ZVNlbGVjdG9yKCksXFxuICAgICAgICAgICAgZSA9IHRoaXM7YS5tb2JpbGUubm9qcyAmJiBhLm1vYmlsZS5ub2pzKHRoaXMpLCBhLm1vYmlsZS5saW5rcyAmJiBhLm1vYmlsZS5saW5rcyh0aGlzKSwgYS5tb2JpbGUuZGVncmFkZUlucHV0c1dpdGhpbiAmJiBhLm1vYmlsZS5kZWdyYWRlSW5wdXRzV2l0aGluKHRoaXMpLCBhLmZuLmJ1dHRvbk1hcmt1cCAmJiB0aGlzLmZpbmQoYS5mbi5idXR0b25NYXJrdXAuaW5pdFNlbGVjdG9yKS5ub3QoZCkuanFtRW5oYW5jZWFibGUoKS5idXR0b25NYXJrdXAoKSwgYS5mbi5maWVsZGNvbnRhaW4gJiYgdGhpcy5maW5kKFxcXCI6anFtRGF0YShyb2xlPSdmaWVsZGNvbnRhaW4nKVxcXCIpLm5vdChkKS5qcW1FbmhhbmNlYWJsZSgpLmZpZWxkY29udGFpbigpLCBhLmVhY2goYS5tb2JpbGUud2lkZ2V0cywgZnVuY3Rpb24gKGIsIGYpIHtcXG4gICAgICAgICAgaWYgKGYuaW5pdFNlbGVjdG9yKSB7XFxuICAgICAgICAgICAgdmFyIGcgPSBhLm1vYmlsZS5lbmhhbmNlYWJsZShlLmZpbmQoZi5pbml0U2VsZWN0b3IpKTtnLmxlbmd0aCA+IDAgJiYgKGcgPSBnLm5vdChkKSksIGcubGVuZ3RoID4gMCAmJiAoY1tmLnByb3RvdHlwZS53aWRnZXROYW1lXSA9IGcpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9KTtmb3IgKGIgaW4gYykge1xcbiAgICAgICAgICBjW2JdW2JdKCk7XFxuICAgICAgICB9cmV0dXJuIHRoaXM7XFxuICAgICAgfSwgYWRkRGVwZW5kZW50czogZnVuY3Rpb24gYWRkRGVwZW5kZW50cyhiKSB7XFxuICAgICAgICBhLmFkZERlcGVuZGVudHModGhpcywgYik7XFxuICAgICAgfSwgZ2V0RW5jb2RlZFRleHQ6IGZ1bmN0aW9uIGdldEVuY29kZWRUZXh0KCkge1xcbiAgICAgICAgcmV0dXJuIGEoXFxcIjxhPlxcXCIpLnRleHQodGhpcy50ZXh0KCkpLmh0bWwoKTtcXG4gICAgICB9LCBqcW1FbmhhbmNlYWJsZTogZnVuY3Rpb24ganFtRW5oYW5jZWFibGUoKSB7XFxuICAgICAgICByZXR1cm4gYS5tb2JpbGUuZW5oYW5jZWFibGUodGhpcyk7XFxuICAgICAgfSwganFtSGlqYWNrYWJsZTogZnVuY3Rpb24ganFtSGlqYWNrYWJsZSgpIHtcXG4gICAgICAgIHJldHVybiBhLm1vYmlsZS5oaWphY2thYmxlKHRoaXMpO1xcbiAgICAgIH0gfSksIGEucmVtb3ZlV2l0aERlcGVuZGVudHMgPSBmdW5jdGlvbiAoYikge1xcbiAgICAgIHZhciBjID0gYShiKTsoYy5qcW1EYXRhKFxcXCJkZXBlbmRlbnRzXFxcIikgfHwgYSgpKS5yZW1vdmUoKSwgYy5yZW1vdmUoKTtcXG4gICAgfSwgYS5hZGREZXBlbmRlbnRzID0gZnVuY3Rpb24gKGIsIGMpIHtcXG4gICAgICB2YXIgZCA9IGEoYiksXFxuICAgICAgICAgIGUgPSBkLmpxbURhdGEoXFxcImRlcGVuZGVudHNcXFwiKSB8fCBhKCk7ZC5qcW1EYXRhKFxcXCJkZXBlbmRlbnRzXFxcIiwgYShlKS5hZGQoYykpO1xcbiAgICB9LCBhLmZpbmQubWF0Y2hlcyA9IGZ1bmN0aW9uIChiLCBjKSB7XFxuICAgICAgcmV0dXJuIGEuZmluZChiLCBudWxsLCBudWxsLCBjKTtcXG4gICAgfSwgYS5maW5kLm1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uIChiLCBjKSB7XFxuICAgICAgcmV0dXJuIGEuZmluZChjLCBudWxsLCBudWxsLCBbYl0pLmxlbmd0aCA+IDA7XFxuICAgIH07XFxuICB9KGEsIHRoaXMpLCBmdW5jdGlvbiAoYSkge1xcbiAgICBhLmV4dGVuZChhLm1vYmlsZSwgeyB2ZXJzaW9uOiBcXFwiMS40LjVcXFwiLCBzdWJQYWdlVXJsS2V5OiBcXFwidWktcGFnZVxcXCIsIGhpZGVVcmxCYXI6ICEwLCBrZWVwTmF0aXZlOiBcXFwiOmpxbURhdGEocm9sZT0nbm9uZScpLCA6anFtRGF0YShyb2xlPSdub2pzJylcXFwiLCBhY3RpdmVQYWdlQ2xhc3M6IFxcXCJ1aS1wYWdlLWFjdGl2ZVxcXCIsIGFjdGl2ZUJ0bkNsYXNzOiBcXFwidWktYnRuLWFjdGl2ZVxcXCIsIGZvY3VzQ2xhc3M6IFxcXCJ1aS1mb2N1c1xcXCIsIGFqYXhFbmFibGVkOiAhMCwgaGFzaExpc3RlbmluZ0VuYWJsZWQ6ICEwLCBsaW5rQmluZGluZ0VuYWJsZWQ6ICEwLCBkZWZhdWx0UGFnZVRyYW5zaXRpb246IFxcXCJmYWRlXFxcIiwgbWF4VHJhbnNpdGlvbldpZHRoOiAhMSwgbWluU2Nyb2xsQmFjazogMCwgZGVmYXVsdERpYWxvZ1RyYW5zaXRpb246IFxcXCJwb3BcXFwiLCBwYWdlTG9hZEVycm9yTWVzc2FnZTogXFxcIkVycm9yIExvYWRpbmcgUGFnZVxcXCIsIHBhZ2VMb2FkRXJyb3JNZXNzYWdlVGhlbWU6IFxcXCJhXFxcIiwgcGhvbmVnYXBOYXZpZ2F0aW9uRW5hYmxlZDogITEsIGF1dG9Jbml0aWFsaXplUGFnZTogITAsIHB1c2hTdGF0ZUVuYWJsZWQ6ICEwLCBpZ25vcmVDb250ZW50RW5hYmxlZDogITEsIGJ1dHRvbk1hcmt1cDogeyBob3ZlckRlbGF5OiAyMDAgfSwgZHluYW1pY0Jhc2VFbmFibGVkOiAhMCwgcGFnZUNvbnRhaW5lcjogYSgpLCBhbGxvd0Nyb3NzRG9tYWluUGFnZXM6ICExLCBkaWFsb2dIYXNoS2V5OiBcXFwiJnVpLXN0YXRlPWRpYWxvZ1xcXCIgfSk7XFxuICB9KGEsIHRoaXMpLCBmdW5jdGlvbiAoYSwgYikge1xcbiAgICB2YXIgYyA9IDAsXFxuICAgICAgICBkID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLFxcbiAgICAgICAgZSA9IGEuY2xlYW5EYXRhO2EuY2xlYW5EYXRhID0gZnVuY3Rpb24gKGIpIHtcXG4gICAgICBmb3IgKHZhciBjLCBkID0gMDsgbnVsbCAhPSAoYyA9IGJbZF0pOyBkKyspIHtcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgIGEoYykudHJpZ2dlckhhbmRsZXIoXFxcInJlbW92ZVxcXCIpO1xcbiAgICAgICAgfSBjYXRjaCAoZikge31cXG4gICAgICB9ZShiKTtcXG4gICAgfSwgYS53aWRnZXQgPSBmdW5jdGlvbiAoYiwgYywgZCkge1xcbiAgICAgIHZhciBlLFxcbiAgICAgICAgICBmLFxcbiAgICAgICAgICBnLFxcbiAgICAgICAgICBoLFxcbiAgICAgICAgICBpID0ge30sXFxuICAgICAgICAgIGogPSBiLnNwbGl0KFxcXCIuXFxcIilbMF07cmV0dXJuIGIgPSBiLnNwbGl0KFxcXCIuXFxcIilbMV0sIGUgPSBqICsgXFxcIi1cXFwiICsgYiwgZCB8fCAoZCA9IGMsIGMgPSBhLldpZGdldCksIGEuZXhwcltcXFwiOlxcXCJdW2UudG9Mb3dlckNhc2UoKV0gPSBmdW5jdGlvbiAoYikge1xcbiAgICAgICAgcmV0dXJuICEhYS5kYXRhKGIsIGUpO1xcbiAgICAgIH0sIGFbal0gPSBhW2pdIHx8IHt9LCBmID0gYVtqXVtiXSwgZyA9IGFbal1bYl0gPSBmdW5jdGlvbiAoYSwgYikge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZVdpZGdldCA/IHZvaWQgKGFyZ3VtZW50cy5sZW5ndGggJiYgdGhpcy5fY3JlYXRlV2lkZ2V0KGEsIGIpKSA6IG5ldyBnKGEsIGIpO1xcbiAgICAgIH0sIGEuZXh0ZW5kKGcsIGYsIHsgdmVyc2lvbjogZC52ZXJzaW9uLCBfcHJvdG86IGEuZXh0ZW5kKHt9LCBkKSwgX2NoaWxkQ29uc3RydWN0b3JzOiBbXSB9KSwgaCA9IG5ldyBjKCksIGgub3B0aW9ucyA9IGEud2lkZ2V0LmV4dGVuZCh7fSwgaC5vcHRpb25zKSwgYS5lYWNoKGQsIGZ1bmN0aW9uIChiLCBkKSB7XFxuICAgICAgICByZXR1cm4gYS5pc0Z1bmN0aW9uKGQpID8gdm9pZCAoaVtiXSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgdmFyIGEgPSBmdW5jdGlvbiBhKCkge1xcbiAgICAgICAgICAgIHJldHVybiBjLnByb3RvdHlwZVtiXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgZSA9IGZ1bmN0aW9uIGUoYSkge1xcbiAgICAgICAgICAgIHJldHVybiBjLnByb3RvdHlwZVtiXS5hcHBseSh0aGlzLCBhKTtcXG4gICAgICAgICAgfTtyZXR1cm4gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIHZhciBiLFxcbiAgICAgICAgICAgICAgICBjID0gdGhpcy5fc3VwZXIsXFxuICAgICAgICAgICAgICAgIGYgPSB0aGlzLl9zdXBlckFwcGx5O3JldHVybiB0aGlzLl9zdXBlciA9IGEsIHRoaXMuX3N1cGVyQXBwbHkgPSBlLCBiID0gZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCB0aGlzLl9zdXBlciA9IGMsIHRoaXMuX3N1cGVyQXBwbHkgPSBmLCBiO1xcbiAgICAgICAgICB9O1xcbiAgICAgICAgfSgpKSA6IHZvaWQgKGlbYl0gPSBkKTtcXG4gICAgICB9KSwgZy5wcm90b3R5cGUgPSBhLndpZGdldC5leHRlbmQoaCwgeyB3aWRnZXRFdmVudFByZWZpeDogZiA/IGgud2lkZ2V0RXZlbnRQcmVmaXggfHwgYiA6IGIgfSwgaSwgeyBjb25zdHJ1Y3RvcjogZywgbmFtZXNwYWNlOiBqLCB3aWRnZXROYW1lOiBiLCB3aWRnZXRGdWxsTmFtZTogZSB9KSwgZiA/IChhLmVhY2goZi5fY2hpbGRDb25zdHJ1Y3RvcnMsIGZ1bmN0aW9uIChiLCBjKSB7XFxuICAgICAgICB2YXIgZCA9IGMucHJvdG90eXBlO2Eud2lkZ2V0KGQubmFtZXNwYWNlICsgXFxcIi5cXFwiICsgZC53aWRnZXROYW1lLCBnLCBjLl9wcm90byk7XFxuICAgICAgfSksIGRlbGV0ZSBmLl9jaGlsZENvbnN0cnVjdG9ycykgOiBjLl9jaGlsZENvbnN0cnVjdG9ycy5wdXNoKGcpLCBhLndpZGdldC5icmlkZ2UoYiwgZyksIGc7XFxuICAgIH0sIGEud2lkZ2V0LmV4dGVuZCA9IGZ1bmN0aW9uIChjKSB7XFxuICAgICAgZm9yICh2YXIgZSwgZiwgZyA9IGQuY2FsbChhcmd1bWVudHMsIDEpLCBoID0gMCwgaSA9IGcubGVuZ3RoOyBpID4gaDsgaCsrKSB7XFxuICAgICAgICBmb3IgKGUgaW4gZ1toXSkge1xcbiAgICAgICAgICBmID0gZ1toXVtlXSwgZ1toXS5oYXNPd25Qcm9wZXJ0eShlKSAmJiBmICE9PSBiICYmIChjW2VdID0gYS5pc1BsYWluT2JqZWN0KGYpID8gYS5pc1BsYWluT2JqZWN0KGNbZV0pID8gYS53aWRnZXQuZXh0ZW5kKHt9LCBjW2VdLCBmKSA6IGEud2lkZ2V0LmV4dGVuZCh7fSwgZikgOiBmKTtcXG4gICAgICAgIH1cXG4gICAgICB9cmV0dXJuIGM7XFxuICAgIH0sIGEud2lkZ2V0LmJyaWRnZSA9IGZ1bmN0aW9uIChjLCBlKSB7XFxuICAgICAgdmFyIGYgPSBlLnByb3RvdHlwZS53aWRnZXRGdWxsTmFtZSB8fCBjO2EuZm5bY10gPSBmdW5jdGlvbiAoZykge1xcbiAgICAgICAgdmFyIGggPSBcXFwic3RyaW5nXFxcIiA9PSB0eXBlb2YgZyxcXG4gICAgICAgICAgICBpID0gZC5jYWxsKGFyZ3VtZW50cywgMSksXFxuICAgICAgICAgICAgaiA9IHRoaXM7cmV0dXJuIGcgPSAhaCAmJiBpLmxlbmd0aCA/IGEud2lkZ2V0LmV4dGVuZC5hcHBseShudWxsLCBbZ10uY29uY2F0KGkpKSA6IGcsIHRoaXMuZWFjaChoID8gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICB2YXIgZCxcXG4gICAgICAgICAgICAgIGUgPSBhLmRhdGEodGhpcywgZik7cmV0dXJuIFxcXCJpbnN0YW5jZVxcXCIgPT09IGcgPyAoaiA9IGUsICExKSA6IGUgPyBhLmlzRnVuY3Rpb24oZVtnXSkgJiYgXFxcIl9cXFwiICE9PSBnLmNoYXJBdCgwKSA/IChkID0gZVtnXS5hcHBseShlLCBpKSwgZCAhPT0gZSAmJiBkICE9PSBiID8gKGogPSBkICYmIGQuanF1ZXJ5ID8gai5wdXNoU3RhY2soZC5nZXQoKSkgOiBkLCAhMSkgOiB2b2lkIDApIDogYS5lcnJvcihcXFwibm8gc3VjaCBtZXRob2QgJ1xcXCIgKyBnICsgXFxcIicgZm9yIFxcXCIgKyBjICsgXFxcIiB3aWRnZXQgaW5zdGFuY2VcXFwiKSA6IGEuZXJyb3IoXFxcImNhbm5vdCBjYWxsIG1ldGhvZHMgb24gXFxcIiArIGMgKyBcXFwiIHByaW9yIHRvIGluaXRpYWxpemF0aW9uOyBhdHRlbXB0ZWQgdG8gY2FsbCBtZXRob2QgJ1xcXCIgKyBnICsgXFxcIidcXFwiKTtcXG4gICAgICAgIH0gOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHZhciBiID0gYS5kYXRhKHRoaXMsIGYpO2IgPyBiLm9wdGlvbihnIHx8IHt9KS5faW5pdCgpIDogYS5kYXRhKHRoaXMsIGYsIG5ldyBlKGcsIHRoaXMpKTtcXG4gICAgICAgIH0pLCBqO1xcbiAgICAgIH07XFxuICAgIH0sIGEuV2lkZ2V0ID0gZnVuY3Rpb24gKCkge30sIGEuV2lkZ2V0Ll9jaGlsZENvbnN0cnVjdG9ycyA9IFtdLCBhLldpZGdldC5wcm90b3R5cGUgPSB7IHdpZGdldE5hbWU6IFxcXCJ3aWRnZXRcXFwiLCB3aWRnZXRFdmVudFByZWZpeDogXFxcIlxcXCIsIGRlZmF1bHRFbGVtZW50OiBcXFwiPGRpdj5cXFwiLCBvcHRpb25zOiB7IGRpc2FibGVkOiAhMSwgY3JlYXRlOiBudWxsIH0sIF9jcmVhdGVXaWRnZXQ6IGZ1bmN0aW9uIF9jcmVhdGVXaWRnZXQoYiwgZCkge1xcbiAgICAgICAgZCA9IGEoZCB8fCB0aGlzLmRlZmF1bHRFbGVtZW50IHx8IHRoaXMpWzBdLCB0aGlzLmVsZW1lbnQgPSBhKGQpLCB0aGlzLnV1aWQgPSBjKyssIHRoaXMuZXZlbnROYW1lc3BhY2UgPSBcXFwiLlxcXCIgKyB0aGlzLndpZGdldE5hbWUgKyB0aGlzLnV1aWQsIHRoaXMub3B0aW9ucyA9IGEud2lkZ2V0LmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zLCB0aGlzLl9nZXRDcmVhdGVPcHRpb25zKCksIGIpLCB0aGlzLmJpbmRpbmdzID0gYSgpLCB0aGlzLmhvdmVyYWJsZSA9IGEoKSwgdGhpcy5mb2N1c2FibGUgPSBhKCksIGQgIT09IHRoaXMgJiYgKGEuZGF0YShkLCB0aGlzLndpZGdldEZ1bGxOYW1lLCB0aGlzKSwgdGhpcy5fb24oITAsIHRoaXMuZWxlbWVudCwgeyByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShhKSB7XFxuICAgICAgICAgICAgYS50YXJnZXQgPT09IGQgJiYgdGhpcy5kZXN0cm95KCk7XFxuICAgICAgICAgIH0gfSksIHRoaXMuZG9jdW1lbnQgPSBhKGQuc3R5bGUgPyBkLm93bmVyRG9jdW1lbnQgOiBkLmRvY3VtZW50IHx8IGQpLCB0aGlzLndpbmRvdyA9IGEodGhpcy5kb2N1bWVudFswXS5kZWZhdWx0VmlldyB8fCB0aGlzLmRvY3VtZW50WzBdLnBhcmVudFdpbmRvdykpLCB0aGlzLl9jcmVhdGUoKSwgdGhpcy5fdHJpZ2dlcihcXFwiY3JlYXRlXFxcIiwgbnVsbCwgdGhpcy5fZ2V0Q3JlYXRlRXZlbnREYXRhKCkpLCB0aGlzLl9pbml0KCk7XFxuICAgICAgfSwgX2dldENyZWF0ZU9wdGlvbnM6IGEubm9vcCwgX2dldENyZWF0ZUV2ZW50RGF0YTogYS5ub29wLCBfY3JlYXRlOiBhLm5vb3AsIF9pbml0OiBhLm5vb3AsIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XFxuICAgICAgICB0aGlzLl9kZXN0cm95KCksIHRoaXMuZWxlbWVudC51bmJpbmQodGhpcy5ldmVudE5hbWVzcGFjZSkucmVtb3ZlRGF0YSh0aGlzLndpZGdldEZ1bGxOYW1lKS5yZW1vdmVEYXRhKGEuY2FtZWxDYXNlKHRoaXMud2lkZ2V0RnVsbE5hbWUpKSwgdGhpcy53aWRnZXQoKS51bmJpbmQodGhpcy5ldmVudE5hbWVzcGFjZSkucmVtb3ZlQXR0cihcXFwiYXJpYS1kaXNhYmxlZFxcXCIpLnJlbW92ZUNsYXNzKHRoaXMud2lkZ2V0RnVsbE5hbWUgKyBcXFwiLWRpc2FibGVkIHVpLXN0YXRlLWRpc2FibGVkXFxcIiksIHRoaXMuYmluZGluZ3MudW5iaW5kKHRoaXMuZXZlbnROYW1lc3BhY2UpLCB0aGlzLmhvdmVyYWJsZS5yZW1vdmVDbGFzcyhcXFwidWktc3RhdGUtaG92ZXJcXFwiKSwgdGhpcy5mb2N1c2FibGUucmVtb3ZlQ2xhc3MoXFxcInVpLXN0YXRlLWZvY3VzXFxcIik7XFxuICAgICAgfSwgX2Rlc3Ryb3k6IGEubm9vcCwgd2lkZ2V0OiBmdW5jdGlvbiB3aWRnZXQoKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50O1xcbiAgICAgIH0sIG9wdGlvbjogZnVuY3Rpb24gb3B0aW9uKGMsIGQpIHtcXG4gICAgICAgIHZhciBlLFxcbiAgICAgICAgICAgIGYsXFxuICAgICAgICAgICAgZyxcXG4gICAgICAgICAgICBoID0gYztpZiAoMCA9PT0gYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGEud2lkZ2V0LmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zKTtpZiAoXFxcInN0cmluZ1xcXCIgPT0gdHlwZW9mIGMpIGlmIChoID0ge30sIGUgPSBjLnNwbGl0KFxcXCIuXFxcIiksIGMgPSBlLnNoaWZ0KCksIGUubGVuZ3RoKSB7XFxuICAgICAgICAgIGZvciAoZiA9IGhbY10gPSBhLndpZGdldC5leHRlbmQoe30sIHRoaXMub3B0aW9uc1tjXSksIGcgPSAwOyBnIDwgZS5sZW5ndGggLSAxOyBnKyspIHtcXG4gICAgICAgICAgICBmW2VbZ11dID0gZltlW2ddXSB8fCB7fSwgZiA9IGZbZVtnXV07XFxuICAgICAgICAgIH1pZiAoYyA9IGUucG9wKCksIGQgPT09IGIpIHJldHVybiBmW2NdID09PSBiID8gbnVsbCA6IGZbY107ZltjXSA9IGQ7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBpZiAoZCA9PT0gYikgcmV0dXJuIHRoaXMub3B0aW9uc1tjXSA9PT0gYiA/IG51bGwgOiB0aGlzLm9wdGlvbnNbY107aFtjXSA9IGQ7XFxuICAgICAgICB9cmV0dXJuIHRoaXMuX3NldE9wdGlvbnMoaCksIHRoaXM7XFxuICAgICAgfSwgX3NldE9wdGlvbnM6IGZ1bmN0aW9uIF9zZXRPcHRpb25zKGEpIHtcXG4gICAgICAgIHZhciBiO2ZvciAoYiBpbiBhKSB7XFxuICAgICAgICAgIHRoaXMuX3NldE9wdGlvbihiLCBhW2JdKTtcXG4gICAgICAgIH1yZXR1cm4gdGhpcztcXG4gICAgICB9LCBfc2V0T3B0aW9uOiBmdW5jdGlvbiBfc2V0T3B0aW9uKGEsIGIpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNbYV0gPSBiLCBcXFwiZGlzYWJsZWRcXFwiID09PSBhICYmICh0aGlzLndpZGdldCgpLnRvZ2dsZUNsYXNzKHRoaXMud2lkZ2V0RnVsbE5hbWUgKyBcXFwiLWRpc2FibGVkXFxcIiwgISFiKSwgdGhpcy5ob3ZlcmFibGUucmVtb3ZlQ2xhc3MoXFxcInVpLXN0YXRlLWhvdmVyXFxcIiksIHRoaXMuZm9jdXNhYmxlLnJlbW92ZUNsYXNzKFxcXCJ1aS1zdGF0ZS1mb2N1c1xcXCIpKSwgdGhpcztcXG4gICAgICB9LCBlbmFibGU6IGZ1bmN0aW9uIGVuYWJsZSgpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLl9zZXRPcHRpb25zKHsgZGlzYWJsZWQ6ICExIH0pO1xcbiAgICAgIH0sIGRpc2FibGU6IGZ1bmN0aW9uIGRpc2FibGUoKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5fc2V0T3B0aW9ucyh7IGRpc2FibGVkOiAhMCB9KTtcXG4gICAgICB9LCBfb246IGZ1bmN0aW9uIF9vbihiLCBjLCBkKSB7XFxuICAgICAgICB2YXIgZSxcXG4gICAgICAgICAgICBmID0gdGhpcztcXFwiYm9vbGVhblxcXCIgIT0gdHlwZW9mIGIgJiYgKGQgPSBjLCBjID0gYiwgYiA9ICExKSwgZCA/IChjID0gZSA9IGEoYyksIHRoaXMuYmluZGluZ3MgPSB0aGlzLmJpbmRpbmdzLmFkZChjKSkgOiAoZCA9IGMsIGMgPSB0aGlzLmVsZW1lbnQsIGUgPSB0aGlzLndpZGdldCgpKSwgYS5lYWNoKGQsIGZ1bmN0aW9uIChkLCBnKSB7XFxuICAgICAgICAgIGZ1bmN0aW9uIGgoKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGIgfHwgZi5vcHRpb25zLmRpc2FibGVkICE9PSAhMCAmJiAhYSh0aGlzKS5oYXNDbGFzcyhcXFwidWktc3RhdGUtZGlzYWJsZWRcXFwiKSA/IChcXFwic3RyaW5nXFxcIiA9PSB0eXBlb2YgZyA/IGZbZ10gOiBnKS5hcHBseShmLCBhcmd1bWVudHMpIDogdm9pZCAwO1xcbiAgICAgICAgICB9XFxcInN0cmluZ1xcXCIgIT0gdHlwZW9mIGcgJiYgKGguZ3VpZCA9IGcuZ3VpZCA9IGcuZ3VpZCB8fCBoLmd1aWQgfHwgYS5ndWlkKyspO3ZhciBpID0gZC5tYXRjaCgvXihcXFxcdyspXFxcXHMqKC4qKSQvKSxcXG4gICAgICAgICAgICAgIGogPSBpWzFdICsgZi5ldmVudE5hbWVzcGFjZSxcXG4gICAgICAgICAgICAgIGsgPSBpWzJdO2sgPyBlLmRlbGVnYXRlKGssIGosIGgpIDogYy5iaW5kKGosIGgpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfSwgX29mZjogZnVuY3Rpb24gX29mZihhLCBiKSB7XFxuICAgICAgICBiID0gKGIgfHwgXFxcIlxcXCIpLnNwbGl0KFxcXCIgXFxcIikuam9pbih0aGlzLmV2ZW50TmFtZXNwYWNlICsgXFxcIiBcXFwiKSArIHRoaXMuZXZlbnROYW1lc3BhY2UsIGEudW5iaW5kKGIpLnVuZGVsZWdhdGUoYik7XFxuICAgICAgfSwgX2RlbGF5OiBmdW5jdGlvbiBfZGVsYXkoYSwgYikge1xcbiAgICAgICAgZnVuY3Rpb24gYygpIHtcXG4gICAgICAgICAgcmV0dXJuIChcXFwic3RyaW5nXFxcIiA9PSB0eXBlb2YgYSA/IGRbYV0gOiBhKS5hcHBseShkLCBhcmd1bWVudHMpO1xcbiAgICAgICAgfXZhciBkID0gdGhpcztyZXR1cm4gc2V0VGltZW91dChjLCBiIHx8IDApO1xcbiAgICAgIH0sIF9ob3ZlcmFibGU6IGZ1bmN0aW9uIF9ob3ZlcmFibGUoYikge1xcbiAgICAgICAgdGhpcy5ob3ZlcmFibGUgPSB0aGlzLmhvdmVyYWJsZS5hZGQoYiksIHRoaXMuX29uKGIsIHsgbW91c2VlbnRlcjogZnVuY3Rpb24gbW91c2VlbnRlcihiKSB7XFxuICAgICAgICAgICAgYShiLmN1cnJlbnRUYXJnZXQpLmFkZENsYXNzKFxcXCJ1aS1zdGF0ZS1ob3ZlclxcXCIpO1xcbiAgICAgICAgICB9LCBtb3VzZWxlYXZlOiBmdW5jdGlvbiBtb3VzZWxlYXZlKGIpIHtcXG4gICAgICAgICAgICBhKGIuY3VycmVudFRhcmdldCkucmVtb3ZlQ2xhc3MoXFxcInVpLXN0YXRlLWhvdmVyXFxcIik7XFxuICAgICAgICAgIH0gfSk7XFxuICAgICAgfSwgX2ZvY3VzYWJsZTogZnVuY3Rpb24gX2ZvY3VzYWJsZShiKSB7XFxuICAgICAgICB0aGlzLmZvY3VzYWJsZSA9IHRoaXMuZm9jdXNhYmxlLmFkZChiKSwgdGhpcy5fb24oYiwgeyBmb2N1c2luOiBmdW5jdGlvbiBmb2N1c2luKGIpIHtcXG4gICAgICAgICAgICBhKGIuY3VycmVudFRhcmdldCkuYWRkQ2xhc3MoXFxcInVpLXN0YXRlLWZvY3VzXFxcIik7XFxuICAgICAgICAgIH0sIGZvY3Vzb3V0OiBmdW5jdGlvbiBmb2N1c291dChiKSB7XFxuICAgICAgICAgICAgYShiLmN1cnJlbnRUYXJnZXQpLnJlbW92ZUNsYXNzKFxcXCJ1aS1zdGF0ZS1mb2N1c1xcXCIpO1xcbiAgICAgICAgICB9IH0pO1xcbiAgICAgIH0sIF90cmlnZ2VyOiBmdW5jdGlvbiBfdHJpZ2dlcihiLCBjLCBkKSB7XFxuICAgICAgICB2YXIgZSxcXG4gICAgICAgICAgICBmLFxcbiAgICAgICAgICAgIGcgPSB0aGlzLm9wdGlvbnNbYl07aWYgKGQgPSBkIHx8IHt9LCBjID0gYS5FdmVudChjKSwgYy50eXBlID0gKGIgPT09IHRoaXMud2lkZ2V0RXZlbnRQcmVmaXggPyBiIDogdGhpcy53aWRnZXRFdmVudFByZWZpeCArIGIpLnRvTG93ZXJDYXNlKCksIGMudGFyZ2V0ID0gdGhpcy5lbGVtZW50WzBdLCBmID0gYy5vcmlnaW5hbEV2ZW50KSBmb3IgKGUgaW4gZikge1xcbiAgICAgICAgICBlIGluIGMgfHwgKGNbZV0gPSBmW2VdKTtcXG4gICAgICAgIH1yZXR1cm4gdGhpcy5lbGVtZW50LnRyaWdnZXIoYywgZCksICEoYS5pc0Z1bmN0aW9uKGcpICYmIGcuYXBwbHkodGhpcy5lbGVtZW50WzBdLCBbY10uY29uY2F0KGQpKSA9PT0gITEgfHwgYy5pc0RlZmF1bHRQcmV2ZW50ZWQoKSk7XFxuICAgICAgfSB9LCBhLmVhY2goeyBzaG93OiBcXFwiZmFkZUluXFxcIiwgaGlkZTogXFxcImZhZGVPdXRcXFwiIH0sIGZ1bmN0aW9uIChiLCBjKSB7XFxuICAgICAgYS5XaWRnZXQucHJvdG90eXBlW1xcXCJfXFxcIiArIGJdID0gZnVuY3Rpb24gKGQsIGUsIGYpIHtcXG4gICAgICAgIFxcXCJzdHJpbmdcXFwiID09IHR5cGVvZiBlICYmIChlID0geyBlZmZlY3Q6IGUgfSk7dmFyIGcsXFxuICAgICAgICAgICAgaCA9IGUgPyBlID09PSAhMCB8fCBcXFwibnVtYmVyXFxcIiA9PSB0eXBlb2YgZSA/IGMgOiBlLmVmZmVjdCB8fCBjIDogYjtlID0gZSB8fCB7fSwgXFxcIm51bWJlclxcXCIgPT0gdHlwZW9mIGUgJiYgKGUgPSB7IGR1cmF0aW9uOiBlIH0pLCBnID0gIWEuaXNFbXB0eU9iamVjdChlKSwgZS5jb21wbGV0ZSA9IGYsIGUuZGVsYXkgJiYgZC5kZWxheShlLmRlbGF5KSwgZyAmJiBhLmVmZmVjdHMgJiYgYS5lZmZlY3RzLmVmZmVjdFtoXSA/IGRbYl0oZSkgOiBoICE9PSBiICYmIGRbaF0gPyBkW2hdKGUuZHVyYXRpb24sIGUuZWFzaW5nLCBmKSA6IGQucXVldWUoZnVuY3Rpb24gKGMpIHtcXG4gICAgICAgICAgYSh0aGlzKVtiXSgpLCBmICYmIGYuY2FsbChkWzBdKSwgYygpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfTtcXG4gICAgfSk7XFxuICB9KGEpLCBmdW5jdGlvbiAoYSwgYiwgYykge1xcbiAgICB2YXIgZCA9IHt9LFxcbiAgICAgICAgZSA9IGEuZmluZCxcXG4gICAgICAgIGYgPSAvKD86XFxcXHtbXFxcXHNcXFxcU10qXFxcXH18XFxcXFtbXFxcXHNcXFxcU10qXFxcXF0pJC8sXFxuICAgICAgICBnID0gLzpqcW1EYXRhXFxcXCgoW14pXSopXFxcXCkvZzthLmV4dGVuZChhLm1vYmlsZSwgeyBuczogXFxcIlxcXCIsIGdldEF0dHJpYnV0ZTogZnVuY3Rpb24gZ2V0QXR0cmlidXRlKGIsIGMpIHtcXG4gICAgICAgIHZhciBkO2IgPSBiLmpxdWVyeSA/IGJbMF0gOiBiLCBiICYmIGIuZ2V0QXR0cmlidXRlICYmIChkID0gYi5nZXRBdHRyaWJ1dGUoXFxcImRhdGEtXFxcIiArIGEubW9iaWxlLm5zICsgYykpO3RyeSB7XFxuICAgICAgICAgIGQgPSBcXFwidHJ1ZVxcXCIgPT09IGQgPyAhMCA6IFxcXCJmYWxzZVxcXCIgPT09IGQgPyAhMSA6IFxcXCJudWxsXFxcIiA9PT0gZCA/IG51bGwgOiArZCArIFxcXCJcXFwiID09PSBkID8gK2QgOiBmLnRlc3QoZCkgPyBKU09OLnBhcnNlKGQpIDogZDtcXG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9cmV0dXJuIGQ7XFxuICAgICAgfSwgbnNOb3JtYWxpemVEaWN0OiBkLCBuc05vcm1hbGl6ZTogZnVuY3Rpb24gbnNOb3JtYWxpemUoYikge1xcbiAgICAgICAgcmV0dXJuIGRbYl0gfHwgKGRbYl0gPSBhLmNhbWVsQ2FzZShhLm1vYmlsZS5ucyArIGIpKTtcXG4gICAgICB9LCBjbG9zZXN0UGFnZURhdGE6IGZ1bmN0aW9uIGNsb3Nlc3RQYWdlRGF0YShhKSB7XFxuICAgICAgICByZXR1cm4gYS5jbG9zZXN0KFxcXCI6anFtRGF0YShyb2xlPSdwYWdlJyksIDpqcW1EYXRhKHJvbGU9J2RpYWxvZycpXFxcIikuZGF0YShcXFwibW9iaWxlLXBhZ2VcXFwiKTtcXG4gICAgICB9IH0pLCBhLmZuLmpxbURhdGEgPSBmdW5jdGlvbiAoYiwgZCkge1xcbiAgICAgIHZhciBlO3JldHVybiBcXFwidW5kZWZpbmVkXFxcIiAhPSB0eXBlb2YgYiAmJiAoYiAmJiAoYiA9IGEubW9iaWxlLm5zTm9ybWFsaXplKGIpKSwgZSA9IGFyZ3VtZW50cy5sZW5ndGggPCAyIHx8IGQgPT09IGMgPyB0aGlzLmRhdGEoYikgOiB0aGlzLmRhdGEoYiwgZCkpLCBlO1xcbiAgICB9LCBhLmpxbURhdGEgPSBmdW5jdGlvbiAoYiwgYywgZCkge1xcbiAgICAgIHZhciBlO3JldHVybiBcXFwidW5kZWZpbmVkXFxcIiAhPSB0eXBlb2YgYyAmJiAoZSA9IGEuZGF0YShiLCBjID8gYS5tb2JpbGUubnNOb3JtYWxpemUoYykgOiBjLCBkKSksIGU7XFxuICAgIH0sIGEuZm4uanFtUmVtb3ZlRGF0YSA9IGZ1bmN0aW9uIChiKSB7XFxuICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlRGF0YShhLm1vYmlsZS5uc05vcm1hbGl6ZShiKSk7XFxuICAgIH0sIGEuanFtUmVtb3ZlRGF0YSA9IGZ1bmN0aW9uIChiLCBjKSB7XFxuICAgICAgcmV0dXJuIGEucmVtb3ZlRGF0YShiLCBhLm1vYmlsZS5uc05vcm1hbGl6ZShjKSk7XFxuICAgIH0sIGEuZmluZCA9IGZ1bmN0aW9uIChiLCBjLCBkLCBmKSB7XFxuICAgICAgcmV0dXJuIGIuaW5kZXhPZihcXFwiOmpxbURhdGFcXFwiKSA+IC0xICYmIChiID0gYi5yZXBsYWNlKGcsIFxcXCJbZGF0YS1cXFwiICsgKGEubW9iaWxlLm5zIHx8IFxcXCJcXFwiKSArIFxcXCIkMV1cXFwiKSksIGUuY2FsbCh0aGlzLCBiLCBjLCBkLCBmKTtcXG4gICAgfSwgYS5leHRlbmQoYS5maW5kLCBlKTtcXG4gIH0oYSwgdGhpcyksIGZ1bmN0aW9uIChhKSB7XFxuICAgIHZhciBiID0gL1tBLVpdL2csXFxuICAgICAgICBjID0gZnVuY3Rpb24gYyhhKSB7XFxuICAgICAgcmV0dXJuIFxcXCItXFxcIiArIGEudG9Mb3dlckNhc2UoKTtcXG4gICAgfTthLmV4dGVuZChhLldpZGdldC5wcm90b3R5cGUsIHsgX2dldENyZWF0ZU9wdGlvbnM6IGZ1bmN0aW9uIF9nZXRDcmVhdGVPcHRpb25zKCkge1xcbiAgICAgICAgdmFyIGQsXFxuICAgICAgICAgICAgZSxcXG4gICAgICAgICAgICBmID0gdGhpcy5lbGVtZW50WzBdLFxcbiAgICAgICAgICAgIGcgPSB7fTtpZiAoIWEubW9iaWxlLmdldEF0dHJpYnV0ZShmLCBcXFwiZGVmYXVsdHNcXFwiKSkgZm9yIChkIGluIHRoaXMub3B0aW9ucykge1xcbiAgICAgICAgICBlID0gYS5tb2JpbGUuZ2V0QXR0cmlidXRlKGYsIGQucmVwbGFjZShiLCBjKSksIG51bGwgIT0gZSAmJiAoZ1tkXSA9IGUpO1xcbiAgICAgICAgfXJldHVybiBnO1xcbiAgICAgIH0gfSksIGEubW9iaWxlLndpZGdldCA9IGEuV2lkZ2V0O1xcbiAgfShhKSwgZnVuY3Rpb24gKGEpIHtcXG4gICAgdmFyIGIgPSBcXFwidWktbG9hZGVyXFxcIixcXG4gICAgICAgIGMgPSBhKFxcXCJodG1sXFxcIik7YS53aWRnZXQoXFxcIm1vYmlsZS5sb2FkZXJcXFwiLCB7IG9wdGlvbnM6IHsgdGhlbWU6IFxcXCJhXFxcIiwgdGV4dFZpc2libGU6ICExLCBodG1sOiBcXFwiXFxcIiwgdGV4dDogXFxcImxvYWRpbmdcXFwiIH0sIGRlZmF1bHRIdG1sOiBcXFwiPGRpdiBjbGFzcz0nXFxcIiArIGIgKyBcXFwiJz48c3BhbiBjbGFzcz0ndWktaWNvbi1sb2FkaW5nJz48L3NwYW4+PGgxPjwvaDE+PC9kaXY+XFxcIiwgZmFrZUZpeExvYWRlcjogZnVuY3Rpb24gZmFrZUZpeExvYWRlcigpIHtcXG4gICAgICAgIHZhciBiID0gYShcXFwiLlxcXCIgKyBhLm1vYmlsZS5hY3RpdmVCdG5DbGFzcykuZmlyc3QoKTt0aGlzLmVsZW1lbnQuY3NzKHsgdG9wOiBhLnN1cHBvcnQuc2Nyb2xsVG9wICYmIHRoaXMud2luZG93LnNjcm9sbFRvcCgpICsgdGhpcy53aW5kb3cuaGVpZ2h0KCkgLyAyIHx8IGIubGVuZ3RoICYmIGIub2Zmc2V0KCkudG9wIHx8IDEwMCB9KTtcXG4gICAgICB9LCBjaGVja0xvYWRlclBvc2l0aW9uOiBmdW5jdGlvbiBjaGVja0xvYWRlclBvc2l0aW9uKCkge1xcbiAgICAgICAgdmFyIGIgPSB0aGlzLmVsZW1lbnQub2Zmc2V0KCksXFxuICAgICAgICAgICAgYyA9IHRoaXMud2luZG93LnNjcm9sbFRvcCgpLFxcbiAgICAgICAgICAgIGQgPSBhLm1vYmlsZS5nZXRTY3JlZW5IZWlnaHQoKTsoYi50b3AgPCBjIHx8IGIudG9wIC0gYyA+IGQpICYmICh0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoXFxcInVpLWxvYWRlci1mYWtlZml4XFxcIiksIHRoaXMuZmFrZUZpeExvYWRlcigpLCB0aGlzLndpbmRvdy51bmJpbmQoXFxcInNjcm9sbFxcXCIsIHRoaXMuY2hlY2tMb2FkZXJQb3NpdGlvbikuYmluZChcXFwic2Nyb2xsXFxcIiwgYS5wcm94eSh0aGlzLmZha2VGaXhMb2FkZXIsIHRoaXMpKSk7XFxuICAgICAgfSwgcmVzZXRIdG1sOiBmdW5jdGlvbiByZXNldEh0bWwoKSB7XFxuICAgICAgICB0aGlzLmVsZW1lbnQuaHRtbChhKHRoaXMuZGVmYXVsdEh0bWwpLmh0bWwoKSk7XFxuICAgICAgfSwgc2hvdzogZnVuY3Rpb24gc2hvdyhkLCBlLCBmKSB7XFxuICAgICAgICB2YXIgZywgaCwgaTt0aGlzLnJlc2V0SHRtbCgpLCBcXFwib2JqZWN0XFxcIiA9PT0gYS50eXBlKGQpID8gKGkgPSBhLmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zLCBkKSwgZCA9IGkudGhlbWUpIDogKGkgPSB0aGlzLm9wdGlvbnMsIGQgPSBkIHx8IGkudGhlbWUpLCBoID0gZSB8fCAoaS50ZXh0ID09PSAhMSA/IFxcXCJcXFwiIDogaS50ZXh0KSwgYy5hZGRDbGFzcyhcXFwidWktbG9hZGluZ1xcXCIpLCBnID0gaS50ZXh0VmlzaWJsZSwgdGhpcy5lbGVtZW50LmF0dHIoXFxcImNsYXNzXFxcIiwgYiArIFxcXCIgdWktY29ybmVyLWFsbCB1aS1ib2R5LVxcXCIgKyBkICsgXFxcIiB1aS1sb2FkZXItXFxcIiArIChnIHx8IGUgfHwgZC50ZXh0ID8gXFxcInZlcmJvc2VcXFwiIDogXFxcImRlZmF1bHRcXFwiKSArIChpLnRleHRvbmx5IHx8IGYgPyBcXFwiIHVpLWxvYWRlci10ZXh0b25seVxcXCIgOiBcXFwiXFxcIikpLCBpLmh0bWwgPyB0aGlzLmVsZW1lbnQuaHRtbChpLmh0bWwpIDogdGhpcy5lbGVtZW50LmZpbmQoXFxcImgxXFxcIikudGV4dChoKSwgdGhpcy5lbGVtZW50LmFwcGVuZFRvKGEoYS5tb2JpbGUucGFnZWNvbnRhaW5lciA/IFxcXCI6bW9iaWxlLXBhZ2Vjb250YWluZXJcXFwiIDogXFxcImJvZHlcXFwiKSksIHRoaXMuY2hlY2tMb2FkZXJQb3NpdGlvbigpLCB0aGlzLndpbmRvdy5iaW5kKFxcXCJzY3JvbGxcXFwiLCBhLnByb3h5KHRoaXMuY2hlY2tMb2FkZXJQb3NpdGlvbiwgdGhpcykpO1xcbiAgICAgIH0sIGhpZGU6IGZ1bmN0aW9uIGhpZGUoKSB7XFxuICAgICAgICBjLnJlbW92ZUNsYXNzKFxcXCJ1aS1sb2FkaW5nXFxcIiksIHRoaXMub3B0aW9ucy50ZXh0ICYmIHRoaXMuZWxlbWVudC5yZW1vdmVDbGFzcyhcXFwidWktbG9hZGVyLWZha2VmaXhcXFwiKSwgdGhpcy53aW5kb3cudW5iaW5kKFxcXCJzY3JvbGxcXFwiLCB0aGlzLmZha2VGaXhMb2FkZXIpLCB0aGlzLndpbmRvdy51bmJpbmQoXFxcInNjcm9sbFxcXCIsIHRoaXMuY2hlY2tMb2FkZXJQb3NpdGlvbik7XFxuICAgICAgfSB9KTtcXG4gIH0oYSwgdGhpcyksIGZ1bmN0aW9uIChhLCBiLCBkKSB7XFxuICAgIFxcXCIkOm5vbXVuZ2VcXFwiO1xcbiAgICBmdW5jdGlvbiBlKGEpIHtcXG4gICAgICByZXR1cm4gYSA9IGEgfHwgbG9jYXRpb24uaHJlZiwgXFxcIiNcXFwiICsgYS5yZXBsYWNlKC9eW14jXSojPyguKikkLywgXFxcIiQxXFxcIik7XFxuICAgIH12YXIgZixcXG4gICAgICAgIGcgPSBcXFwiaGFzaGNoYW5nZVxcXCIsXFxuICAgICAgICBoID0gYyxcXG4gICAgICAgIGkgPSBhLmV2ZW50LnNwZWNpYWwsXFxuICAgICAgICBqID0gaC5kb2N1bWVudE1vZGUsXFxuICAgICAgICBrID0gXFxcIm9uXFxcIiArIGcgaW4gYiAmJiAoaiA9PT0gZCB8fCBqID4gNyk7YS5mbltnXSA9IGZ1bmN0aW9uIChhKSB7XFxuICAgICAgcmV0dXJuIGEgPyB0aGlzLmJpbmQoZywgYSkgOiB0aGlzLnRyaWdnZXIoZyk7XFxuICAgIH0sIGEuZm5bZ10uZGVsYXkgPSA1MCwgaVtnXSA9IGEuZXh0ZW5kKGlbZ10sIHsgc2V0dXA6IGZ1bmN0aW9uIHNldHVwKCkge1xcbiAgICAgICAgcmV0dXJuIGsgPyAhMSA6IHZvaWQgYShmLnN0YXJ0KTtcXG4gICAgICB9LCB0ZWFyZG93bjogZnVuY3Rpb24gdGVhcmRvd24oKSB7XFxuICAgICAgICByZXR1cm4gayA/ICExIDogdm9pZCBhKGYuc3RvcCk7XFxuICAgICAgfSB9KSwgZiA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICBmdW5jdGlvbiBjKCkge1xcbiAgICAgICAgdmFyIGQgPSBlKCksXFxuICAgICAgICAgICAgaCA9IG4oaik7ZCAhPT0gaiA/IChtKGogPSBkLCBoKSwgYShiKS50cmlnZ2VyKGcpKSA6IGggIT09IGogJiYgKGxvY2F0aW9uLmhyZWYgPSBsb2NhdGlvbi5ocmVmLnJlcGxhY2UoLyMuKi8sIFxcXCJcXFwiKSArIGgpLCBmID0gc2V0VGltZW91dChjLCBhLmZuW2ddLmRlbGF5KTtcXG4gICAgICB9dmFyIGYsXFxuICAgICAgICAgIGkgPSB7fSxcXG4gICAgICAgICAgaiA9IGUoKSxcXG4gICAgICAgICAgbCA9IGZ1bmN0aW9uIGwoYSkge1xcbiAgICAgICAgcmV0dXJuIGE7XFxuICAgICAgfSxcXG4gICAgICAgICAgbSA9IGwsXFxuICAgICAgICAgIG4gPSBsO3JldHVybiBpLnN0YXJ0ID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgZiB8fCBjKCk7XFxuICAgICAgfSwgaS5zdG9wID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgZiAmJiBjbGVhclRpbWVvdXQoZiksIGYgPSBkO1xcbiAgICAgIH0sIGIuYXR0YWNoRXZlbnQgJiYgIWIuYWRkRXZlbnRMaXN0ZW5lciAmJiAhayAmJiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgYiwgZDtpLnN0YXJ0ID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBiIHx8IChkID0gYS5mbltnXS5zcmMsIGQgPSBkICYmIGQgKyBlKCksIGIgPSBhKCc8aWZyYW1lIHRhYmluZGV4PVxcXCItMVxcXCIgdGl0bGU9XFxcImVtcHR5XFxcIi8+JykuaGlkZSgpLm9uZShcXFwibG9hZFxcXCIsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBkIHx8IG0oZSgpKSwgYygpO1xcbiAgICAgICAgICB9KS5hdHRyKFxcXCJzcmNcXFwiLCBkIHx8IFxcXCJqYXZhc2NyaXB0OjBcXFwiKS5pbnNlcnRBZnRlcihcXFwiYm9keVxcXCIpWzBdLmNvbnRlbnRXaW5kb3csIGgub25wcm9wZXJ0eWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgXFxcInRpdGxlXFxcIiA9PT0gZXZlbnQucHJvcGVydHlOYW1lICYmIChiLmRvY3VtZW50LnRpdGxlID0gaC50aXRsZSk7XFxuICAgICAgICAgICAgfSBjYXRjaCAoYSkge31cXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9LCBpLnN0b3AgPSBsLCBuID0gZnVuY3Rpb24gbigpIHtcXG4gICAgICAgICAgcmV0dXJuIGUoYi5sb2NhdGlvbi5ocmVmKTtcXG4gICAgICAgIH0sIG0gPSBmdW5jdGlvbiBtKGMsIGQpIHtcXG4gICAgICAgICAgdmFyIGUgPSBiLmRvY3VtZW50LFxcbiAgICAgICAgICAgICAgZiA9IGEuZm5bZ10uZG9tYWluO2MgIT09IGQgJiYgKGUudGl0bGUgPSBoLnRpdGxlLCBlLm9wZW4oKSwgZiAmJiBlLndyaXRlKCc8c2NyaXB0PmRvY3VtZW50LmRvbWFpbj1cXFwiJyArIGYgKyAnXFxcIjwvc2NyaXB0PicpLCBlLmNsb3NlKCksIGIubG9jYXRpb24uaGFzaCA9IGMpO1xcbiAgICAgICAgfTtcXG4gICAgICB9KCksIGk7XFxuICAgIH0oKTtcXG4gIH0oYSwgdGhpcyksIGZ1bmN0aW9uIChhKSB7XFxuICAgIGIubWF0Y2hNZWRpYSA9IGIubWF0Y2hNZWRpYSB8fCBmdW5jdGlvbiAoYSkge1xcbiAgICAgIHZhciBiLFxcbiAgICAgICAgICBjID0gYS5kb2N1bWVudEVsZW1lbnQsXFxuICAgICAgICAgIGQgPSBjLmZpcnN0RWxlbWVudENoaWxkIHx8IGMuZmlyc3RDaGlsZCxcXG4gICAgICAgICAgZSA9IGEuY3JlYXRlRWxlbWVudChcXFwiYm9keVxcXCIpLFxcbiAgICAgICAgICBmID0gYS5jcmVhdGVFbGVtZW50KFxcXCJkaXZcXFwiKTtyZXR1cm4gZi5pZCA9IFxcXCJtcS10ZXN0LTFcXFwiLCBmLnN0eWxlLmNzc1RleHQgPSBcXFwicG9zaXRpb246YWJzb2x1dGU7dG9wOi0xMDBlbVxcXCIsIGUuc3R5bGUuYmFja2dyb3VuZCA9IFxcXCJub25lXFxcIiwgZS5hcHBlbmRDaGlsZChmKSwgZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgIHJldHVybiBmLmlubmVySFRNTCA9ICcmc2h5OzxzdHlsZSBtZWRpYT1cXFwiJyArIGEgKyAnXFxcIj4gI21xLXRlc3QtMSB7IHdpZHRoOiA0MnB4OyB9PC9zdHlsZT4nLCBjLmluc2VydEJlZm9yZShlLCBkKSwgYiA9IDQyID09PSBmLm9mZnNldFdpZHRoLCBjLnJlbW92ZUNoaWxkKGUpLCB7IG1hdGNoZXM6IGIsIG1lZGlhOiBhIH07XFxuICAgICAgfTtcXG4gICAgfShjKSwgYS5tb2JpbGUubWVkaWEgPSBmdW5jdGlvbiAoYSkge1xcbiAgICAgIHJldHVybiBiLm1hdGNoTWVkaWEoYSkubWF0Y2hlcztcXG4gICAgfTtcXG4gIH0oYSksIGZ1bmN0aW9uIChhKSB7XFxuICAgIHZhciBiID0geyB0b3VjaDogXFxcIm9udG91Y2hlbmRcXFwiIGluIGMgfTthLm1vYmlsZS5zdXBwb3J0ID0gYS5tb2JpbGUuc3VwcG9ydCB8fCB7fSwgYS5leHRlbmQoYS5zdXBwb3J0LCBiKSwgYS5leHRlbmQoYS5tb2JpbGUuc3VwcG9ydCwgYik7XFxuICB9KGEpLCBmdW5jdGlvbiAoYSkge1xcbiAgICBhLmV4dGVuZChhLnN1cHBvcnQsIHsgb3JpZW50YXRpb246IFxcXCJvcmllbnRhdGlvblxcXCIgaW4gYiAmJiBcXFwib25vcmllbnRhdGlvbmNoYW5nZVxcXCIgaW4gYiB9KTtcXG4gIH0oYSksIGZ1bmN0aW9uIChhLCBkKSB7XFxuICAgIGZ1bmN0aW9uIGUoYSkge1xcbiAgICAgIHZhciBiLFxcbiAgICAgICAgICBjID0gYS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGEuc3Vic3RyKDEpLFxcbiAgICAgICAgICBlID0gKGEgKyBcXFwiIFxcXCIgKyBvLmpvaW4oYyArIFxcXCIgXFxcIikgKyBjKS5zcGxpdChcXFwiIFxcXCIpO2ZvciAoYiBpbiBlKSB7XFxuICAgICAgICBpZiAobltlW2JdXSAhPT0gZCkgcmV0dXJuICEwO1xcbiAgICAgIH1cXG4gICAgfWZ1bmN0aW9uIGYoKSB7XFxuICAgICAgdmFyIGMgPSBiLFxcbiAgICAgICAgICBkID0gISghYy5kb2N1bWVudC5jcmVhdGVFbGVtZW50TlMgfHwgIWMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIsIFxcXCJzdmdcXFwiKS5jcmVhdGVTVkdSZWN0IHx8IGMub3BlcmEgJiYgLTEgPT09IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcXFwiQ2hyb21lXFxcIikpLFxcbiAgICAgICAgICBlID0gZnVuY3Rpb24gZShiKSB7XFxuICAgICAgICBiICYmIGQgfHwgYShcXFwiaHRtbFxcXCIpLmFkZENsYXNzKFxcXCJ1aS1ub3N2Z1xcXCIpO1xcbiAgICAgIH0sXFxuICAgICAgICAgIGYgPSBuZXcgYy5JbWFnZSgpO2Yub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGUoITEpO1xcbiAgICAgIH0sIGYub25sb2FkID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgZSgxID09PSBmLndpZHRoICYmIDEgPT09IGYuaGVpZ2h0KTtcXG4gICAgICB9LCBmLnNyYyA9IFxcXCJkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhBUUFCQUlBQUFBQUFBUC8vL3l3QUFBQUFBUUFCQUFBQ0FVd0FPdz09XFxcIjtcXG4gICAgfWZ1bmN0aW9uIGcoKSB7XFxuICAgICAgdmFyIGUsXFxuICAgICAgICAgIGYsXFxuICAgICAgICAgIGcsXFxuICAgICAgICAgIGggPSBcXFwidHJhbnNmb3JtLTNkXFxcIixcXG4gICAgICAgICAgaSA9IGEubW9iaWxlLm1lZGlhKFxcXCIoLVxcXCIgKyBvLmpvaW4oXFxcIi1cXFwiICsgaCArIFxcXCIpLCgtXFxcIikgKyBcXFwiLVxcXCIgKyBoICsgXFxcIiksKFxcXCIgKyBoICsgXFxcIilcXFwiKTtpZiAoaSkgcmV0dXJuICEhaTtlID0gYy5jcmVhdGVFbGVtZW50KFxcXCJkaXZcXFwiKSwgZiA9IHsgTW96VHJhbnNmb3JtOiBcXFwiLW1vei10cmFuc2Zvcm1cXFwiLCB0cmFuc2Zvcm06IFxcXCJ0cmFuc2Zvcm1cXFwiIH0sIG0uYXBwZW5kKGUpO2ZvciAoZyBpbiBmKSB7XFxuICAgICAgICBlLnN0eWxlW2ddICE9PSBkICYmIChlLnN0eWxlW2ddID0gXFxcInRyYW5zbGF0ZTNkKCAxMDBweCwgMXB4LCAxcHggKVxcXCIsIGkgPSBiLmdldENvbXB1dGVkU3R5bGUoZSkuZ2V0UHJvcGVydHlWYWx1ZShmW2ddKSk7XFxuICAgICAgfXJldHVybiAhIWkgJiYgXFxcIm5vbmVcXFwiICE9PSBpO1xcbiAgICB9ZnVuY3Rpb24gaCgpIHtcXG4gICAgICB2YXIgYixcXG4gICAgICAgICAgYyxcXG4gICAgICAgICAgZCA9IGxvY2F0aW9uLnByb3RvY29sICsgXFxcIi8vXFxcIiArIGxvY2F0aW9uLmhvc3QgKyBsb2NhdGlvbi5wYXRobmFtZSArIFxcXCJ1aS1kaXIvXFxcIixcXG4gICAgICAgICAgZSA9IGEoXFxcImhlYWQgYmFzZVxcXCIpLFxcbiAgICAgICAgICBmID0gbnVsbCxcXG4gICAgICAgICAgZyA9IFxcXCJcXFwiO3JldHVybiBlLmxlbmd0aCA/IGcgPSBlLmF0dHIoXFxcImhyZWZcXFwiKSA6IGUgPSBmID0gYShcXFwiPGJhc2U+XFxcIiwgeyBocmVmOiBkIH0pLmFwcGVuZFRvKFxcXCJoZWFkXFxcIiksIGIgPSBhKFxcXCI8YSBocmVmPSd0ZXN0dXJsJyAvPlxcXCIpLnByZXBlbmRUbyhtKSwgYyA9IGJbMF0uaHJlZiwgZVswXS5ocmVmID0gZyB8fCBsb2NhdGlvbi5wYXRobmFtZSwgZiAmJiBmLnJlbW92ZSgpLCAwID09PSBjLmluZGV4T2YoZCk7XFxuICAgIH1mdW5jdGlvbiBpKCkge1xcbiAgICAgIHZhciBhLFxcbiAgICAgICAgICBkID0gYy5jcmVhdGVFbGVtZW50KFxcXCJ4XFxcIiksXFxuICAgICAgICAgIGUgPSBjLmRvY3VtZW50RWxlbWVudCxcXG4gICAgICAgICAgZiA9IGIuZ2V0Q29tcHV0ZWRTdHlsZTtyZXR1cm4gXFxcInBvaW50ZXJFdmVudHNcXFwiIGluIGQuc3R5bGUgPyAoZC5zdHlsZS5wb2ludGVyRXZlbnRzID0gXFxcImF1dG9cXFwiLCBkLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcXFwieFxcXCIsIGUuYXBwZW5kQ2hpbGQoZCksIGEgPSBmICYmIFxcXCJhdXRvXFxcIiA9PT0gZihkLCBcXFwiXFxcIikucG9pbnRlckV2ZW50cywgZS5yZW1vdmVDaGlsZChkKSwgISFhKSA6ICExO1xcbiAgICB9ZnVuY3Rpb24gaigpIHtcXG4gICAgICB2YXIgYSA9IGMuY3JlYXRlRWxlbWVudChcXFwiZGl2XFxcIik7cmV0dXJuIFxcXCJ1bmRlZmluZWRcXFwiICE9IHR5cGVvZiBhLmdldEJvdW5kaW5nQ2xpZW50UmVjdDtcXG4gICAgfWZ1bmN0aW9uIGsoKSB7XFxuICAgICAgdmFyIGEgPSBiLFxcbiAgICAgICAgICBjID0gbmF2aWdhdG9yLnVzZXJBZ2VudCxcXG4gICAgICAgICAgZCA9IG5hdmlnYXRvci5wbGF0Zm9ybSxcXG4gICAgICAgICAgZSA9IGMubWF0Y2goL0FwcGxlV2ViS2l0XFxcXC8oWzAtOV0rKS8pLFxcbiAgICAgICAgICBmID0gISFlICYmIGVbMV0sXFxuICAgICAgICAgIGcgPSBjLm1hdGNoKC9GZW5uZWNcXFxcLyhbMC05XSspLyksXFxuICAgICAgICAgIGggPSAhIWcgJiYgZ1sxXSxcXG4gICAgICAgICAgaSA9IGMubWF0Y2goL09wZXJhIE1vYmlcXFxcLyhbMC05XSspLyksXFxuICAgICAgICAgIGogPSAhIWkgJiYgaVsxXTtyZXR1cm4gKGQuaW5kZXhPZihcXFwiaVBob25lXFxcIikgPiAtMSB8fCBkLmluZGV4T2YoXFxcImlQYWRcXFwiKSA+IC0xIHx8IGQuaW5kZXhPZihcXFwiaVBvZFxcXCIpID4gLTEpICYmIGYgJiYgNTM0ID4gZiB8fCBhLm9wZXJhbWluaSAmJiBcXFwiW29iamVjdCBPcGVyYU1pbmldXFxcIiA9PT0ge30udG9TdHJpbmcuY2FsbChhLm9wZXJhbWluaSkgfHwgaSAmJiA3NDU4ID4gaiB8fCBjLmluZGV4T2YoXFxcIkFuZHJvaWRcXFwiKSA+IC0xICYmIGYgJiYgNTMzID4gZiB8fCBoICYmIDYgPiBoIHx8IFxcXCJwYWxtR2V0UmVzb3VyY2VcXFwiIGluIGIgJiYgZiAmJiA1MzQgPiBmIHx8IGMuaW5kZXhPZihcXFwiTWVlR29cXFwiKSA+IC0xICYmIGMuaW5kZXhPZihcXFwiTm9raWFCcm93c2VyLzguNS4wXFxcIikgPiAtMSA/ICExIDogITA7XFxuICAgIH12YXIgbCxcXG4gICAgICAgIG0gPSBhKFxcXCI8Ym9keT5cXFwiKS5wcmVwZW5kVG8oXFxcImh0bWxcXFwiKSxcXG4gICAgICAgIG4gPSBtWzBdLnN0eWxlLFxcbiAgICAgICAgbyA9IFtcXFwiV2Via2l0XFxcIiwgXFxcIk1velxcXCIsIFxcXCJPXFxcIl0sXFxuICAgICAgICBwID0gXFxcInBhbG1HZXRSZXNvdXJjZVxcXCIgaW4gYixcXG4gICAgICAgIHEgPSBiLm9wZXJhbWluaSAmJiBcXFwiW29iamVjdCBPcGVyYU1pbmldXFxcIiA9PT0ge30udG9TdHJpbmcuY2FsbChiLm9wZXJhbWluaSksXFxuICAgICAgICByID0gYi5ibGFja2JlcnJ5ICYmICFlKFxcXCItd2Via2l0LXRyYW5zZm9ybVxcXCIpO2EuZXh0ZW5kKGEubW9iaWxlLCB7IGJyb3dzZXI6IHt9IH0pLCBhLm1vYmlsZS5icm93c2VyLm9sZElFID0gZnVuY3Rpb24gKCkge1xcbiAgICAgIHZhciBhID0gMyxcXG4gICAgICAgICAgYiA9IGMuY3JlYXRlRWxlbWVudChcXFwiZGl2XFxcIiksXFxuICAgICAgICAgIGQgPSBiLmFsbCB8fCBbXTtkbyB7XFxuICAgICAgICBiLmlubmVySFRNTCA9IFxcXCI8IS0tW2lmIGd0IElFIFxcXCIgKyArK2EgKyBcXFwiXT48YnI+PCFbZW5kaWZdLS0+XFxcIjtcXG4gICAgICB9IHdoaWxlIChkWzBdKTtyZXR1cm4gYSA+IDQgPyBhIDogIWE7XFxuICAgIH0oKSwgYS5leHRlbmQoYS5zdXBwb3J0LCB7IHB1c2hTdGF0ZTogXFxcInB1c2hTdGF0ZVxcXCIgaW4gaGlzdG9yeSAmJiBcXFwicmVwbGFjZVN0YXRlXFxcIiBpbiBoaXN0b3J5ICYmICEoYi5uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXFxcIkZpcmVmb3hcXFwiKSA+PSAwICYmIGIudG9wICE9PSBiKSAmJiAtMSA9PT0gYi5uYXZpZ2F0b3IudXNlckFnZW50LnNlYXJjaCgvQ3JpT1MvKSwgbWVkaWFxdWVyeTogYS5tb2JpbGUubWVkaWEoXFxcIm9ubHkgYWxsXFxcIiksIGNzc1BzZXVkb0VsZW1lbnQ6ICEhZShcXFwiY29udGVudFxcXCIpLCB0b3VjaE92ZXJmbG93OiAhIWUoXFxcIm92ZXJmbG93U2Nyb2xsaW5nXFxcIiksIGNzc1RyYW5zZm9ybTNkOiBnKCksIGJveFNoYWRvdzogISFlKFxcXCJib3hTaGFkb3dcXFwiKSAmJiAhciwgZml4ZWRQb3NpdGlvbjogaygpLCBzY3JvbGxUb3A6IChcXFwicGFnZVhPZmZzZXRcXFwiIGluIGIgfHwgXFxcInNjcm9sbFRvcFxcXCIgaW4gYy5kb2N1bWVudEVsZW1lbnQgfHwgXFxcInNjcm9sbFRvcFxcXCIgaW4gbVswXSkgJiYgIXAgJiYgIXEsIGR5bmFtaWNCYXNlVGFnOiBoKCksIGNzc1BvaW50ZXJFdmVudHM6IGkoKSwgYm91bmRpbmdSZWN0OiBqKCksIGlubGluZVNWRzogZiB9KSwgbS5yZW1vdmUoKSwgbCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICB2YXIgYSA9IGIubmF2aWdhdG9yLnVzZXJBZ2VudDtyZXR1cm4gYS5pbmRleE9mKFxcXCJOb2tpYVxcXCIpID4gLTEgJiYgKGEuaW5kZXhPZihcXFwiU3ltYmlhbi8zXFxcIikgPiAtMSB8fCBhLmluZGV4T2YoXFxcIlNlcmllczYwLzVcXFwiKSA+IC0xKSAmJiBhLmluZGV4T2YoXFxcIkFwcGxlV2ViS2l0XFxcIikgPiAtMSAmJiBhLm1hdGNoKC8oQnJvd3Nlck5HfE5va2lhQnJvd3NlcilcXFxcLzdcXFxcLlswLTNdLyk7XFxuICAgIH0oKSwgYS5tb2JpbGUuZ3JhZGVBID0gZnVuY3Rpb24gKCkge1xcbiAgICAgIHJldHVybiAoYS5zdXBwb3J0Lm1lZGlhcXVlcnkgJiYgYS5zdXBwb3J0LmNzc1BzZXVkb0VsZW1lbnQgfHwgYS5tb2JpbGUuYnJvd3Nlci5vbGRJRSAmJiBhLm1vYmlsZS5icm93c2VyLm9sZElFID49IDgpICYmIChhLnN1cHBvcnQuYm91bmRpbmdSZWN0IHx8IG51bGwgIT09IGEuZm4uanF1ZXJ5Lm1hdGNoKC8xXFxcXC5bMC03K11cXFxcLlswLTkrXT8vKSk7XFxuICAgIH0sIGEubW9iaWxlLmFqYXhCbGFja2xpc3QgPSBiLmJsYWNrYmVycnkgJiYgIWIuV2ViS2l0UG9pbnQgfHwgcSB8fCBsLCBsICYmIGEoZnVuY3Rpb24gKCkge1xcbiAgICAgIGEoXFxcImhlYWQgbGlua1tyZWw9J3N0eWxlc2hlZXQnXVxcXCIpLmF0dHIoXFxcInJlbFxcXCIsIFxcXCJhbHRlcm5hdGUgc3R5bGVzaGVldFxcXCIpLmF0dHIoXFxcInJlbFxcXCIsIFxcXCJzdHlsZXNoZWV0XFxcIik7XFxuICAgIH0pLCBhLnN1cHBvcnQuYm94U2hhZG93IHx8IGEoXFxcImh0bWxcXFwiKS5hZGRDbGFzcyhcXFwidWktbm9ib3hzaGFkb3dcXFwiKTtcXG4gIH0oYSksIGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgIHZhciBjLFxcbiAgICAgICAgZCA9IGEubW9iaWxlLndpbmRvdyxcXG4gICAgICAgIGUgPSBmdW5jdGlvbiBlKCkge307YS5ldmVudC5zcGVjaWFsLmJlZm9yZW5hdmlnYXRlID0geyBzZXR1cDogZnVuY3Rpb24gc2V0dXAoKSB7XFxuICAgICAgICBkLm9uKFxcXCJuYXZpZ2F0ZVxcXCIsIGUpO1xcbiAgICAgIH0sIHRlYXJkb3duOiBmdW5jdGlvbiB0ZWFyZG93bigpIHtcXG4gICAgICAgIGQub2ZmKFxcXCJuYXZpZ2F0ZVxcXCIsIGUpO1xcbiAgICAgIH0gfSwgYS5ldmVudC5zcGVjaWFsLm5hdmlnYXRlID0gYyA9IHsgYm91bmQ6ICExLCBwdXNoU3RhdGVFbmFibGVkOiAhMCwgb3JpZ2luYWxFdmVudE5hbWU6IGIsIGlzUHVzaFN0YXRlRW5hYmxlZDogZnVuY3Rpb24gaXNQdXNoU3RhdGVFbmFibGVkKCkge1xcbiAgICAgICAgcmV0dXJuIGEuc3VwcG9ydC5wdXNoU3RhdGUgJiYgYS5tb2JpbGUucHVzaFN0YXRlRW5hYmxlZCA9PT0gITAgJiYgdGhpcy5pc0hhc2hDaGFuZ2VFbmFibGVkKCk7XFxuICAgICAgfSwgaXNIYXNoQ2hhbmdlRW5hYmxlZDogZnVuY3Rpb24gaXNIYXNoQ2hhbmdlRW5hYmxlZCgpIHtcXG4gICAgICAgIHJldHVybiBhLm1vYmlsZS5oYXNoTGlzdGVuaW5nRW5hYmxlZCA9PT0gITA7XFxuICAgICAgfSwgcG9wc3RhdGU6IGZ1bmN0aW9uIHBvcHN0YXRlKGIpIHtcXG4gICAgICAgIHZhciBjID0gbmV3IGEuRXZlbnQoXFxcIm5hdmlnYXRlXFxcIiksXFxuICAgICAgICAgICAgZSA9IG5ldyBhLkV2ZW50KFxcXCJiZWZvcmVuYXZpZ2F0ZVxcXCIpLFxcbiAgICAgICAgICAgIGYgPSBiLm9yaWdpbmFsRXZlbnQuc3RhdGUgfHwge307ZS5vcmlnaW5hbEV2ZW50ID0gYiwgZC50cmlnZ2VyKGUpLCBlLmlzRGVmYXVsdFByZXZlbnRlZCgpIHx8IChiLmhpc3RvcnlTdGF0ZSAmJiBhLmV4dGVuZChmLCBiLmhpc3RvcnlTdGF0ZSksIGMub3JpZ2luYWxFdmVudCA9IGIsIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBkLnRyaWdnZXIoYywgeyBzdGF0ZTogZiB9KTtcXG4gICAgICAgIH0sIDApKTtcXG4gICAgICB9LCBoYXNoY2hhbmdlOiBmdW5jdGlvbiBoYXNoY2hhbmdlKGIpIHtcXG4gICAgICAgIHZhciBjID0gbmV3IGEuRXZlbnQoXFxcIm5hdmlnYXRlXFxcIiksXFxuICAgICAgICAgICAgZSA9IG5ldyBhLkV2ZW50KFxcXCJiZWZvcmVuYXZpZ2F0ZVxcXCIpO2Uub3JpZ2luYWxFdmVudCA9IGIsIGQudHJpZ2dlcihlKSwgZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSB8fCAoYy5vcmlnaW5hbEV2ZW50ID0gYiwgZC50cmlnZ2VyKGMsIHsgc3RhdGU6IGIuaGFzaGNoYW5nZVN0YXRlIHx8IHt9IH0pKTtcXG4gICAgICB9LCBzZXR1cDogZnVuY3Rpb24gc2V0dXAoKSB7XFxuICAgICAgICBjLmJvdW5kIHx8IChjLmJvdW5kID0gITAsIGMuaXNQdXNoU3RhdGVFbmFibGVkKCkgPyAoYy5vcmlnaW5hbEV2ZW50TmFtZSA9IFxcXCJwb3BzdGF0ZVxcXCIsIGQuYmluZChcXFwicG9wc3RhdGUubmF2aWdhdGVcXFwiLCBjLnBvcHN0YXRlKSkgOiBjLmlzSGFzaENoYW5nZUVuYWJsZWQoKSAmJiAoYy5vcmlnaW5hbEV2ZW50TmFtZSA9IFxcXCJoYXNoY2hhbmdlXFxcIiwgZC5iaW5kKFxcXCJoYXNoY2hhbmdlLm5hdmlnYXRlXFxcIiwgYy5oYXNoY2hhbmdlKSkpO1xcbiAgICAgIH0gfTtcXG4gIH0oYSksIGZ1bmN0aW9uIChhLCBjKSB7XFxuICAgIHZhciBkLFxcbiAgICAgICAgZSxcXG4gICAgICAgIGYgPSBcXFwiJnVpLXN0YXRlPWRpYWxvZ1xcXCI7YS5tb2JpbGUucGF0aCA9IGQgPSB7IHVpU3RhdGVLZXk6IFxcXCImdWktc3RhdGVcXFwiLCB1cmxQYXJzZVJFOiAvXlxcXFxzKigoKChbXjpcXFxcLyNcXFxcP10rOik/KD86KFxcXFwvXFxcXC8pKCg/OigoW146QFxcXFwvI1xcXFw/XSspKD86XFxcXDooW146QFxcXFwvI1xcXFw/XSspKT8pQCk/KChbXjpcXFxcLyNcXFxcP1xcXFxdXFxcXFtdK3xcXFxcW1teXFxcXC9cXFxcXUAjP10rXFxcXF0pKD86XFxcXDooWzAtOV0rKSk/KSk/KT8pPygoXFxcXC8/KD86W15cXFxcL1xcXFw/I10rXFxcXC8rKSopKFteXFxcXD8jXSopKSk/KFxcXFw/W14jXSspPykoIy4qKT8vLCBnZXRMb2NhdGlvbjogZnVuY3Rpb24gZ2V0TG9jYXRpb24oYSkge1xcbiAgICAgICAgdmFyIGIgPSB0aGlzLnBhcnNlVXJsKGEgfHwgbG9jYXRpb24uaHJlZiksXFxuICAgICAgICAgICAgYyA9IGEgPyBiIDogbG9jYXRpb24sXFxuICAgICAgICAgICAgZCA9IGIuaGFzaDtyZXR1cm4gZCA9IFxcXCIjXFxcIiA9PT0gZCA/IFxcXCJcXFwiIDogZCwgYy5wcm90b2NvbCArIGIuZG91YmxlU2xhc2ggKyBjLmhvc3QgKyAoXFxcIlxcXCIgIT09IGMucHJvdG9jb2wgJiYgXFxcIi9cXFwiICE9PSBjLnBhdGhuYW1lLnN1YnN0cmluZygwLCAxKSA/IFxcXCIvXFxcIiA6IFxcXCJcXFwiKSArIGMucGF0aG5hbWUgKyBjLnNlYXJjaCArIGQ7XFxuICAgICAgfSwgZ2V0RG9jdW1lbnRVcmw6IGZ1bmN0aW9uIGdldERvY3VtZW50VXJsKGIpIHtcXG4gICAgICAgIHJldHVybiBiID8gYS5leHRlbmQoe30sIGQuZG9jdW1lbnRVcmwpIDogZC5kb2N1bWVudFVybC5ocmVmO1xcbiAgICAgIH0sIHBhcnNlTG9jYXRpb246IGZ1bmN0aW9uIHBhcnNlTG9jYXRpb24oKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVVybCh0aGlzLmdldExvY2F0aW9uKCkpO1xcbiAgICAgIH0sIHBhcnNlVXJsOiBmdW5jdGlvbiBwYXJzZVVybChiKSB7XFxuICAgICAgICBpZiAoXFxcIm9iamVjdFxcXCIgPT09IGEudHlwZShiKSkgcmV0dXJuIGI7dmFyIGMgPSBkLnVybFBhcnNlUkUuZXhlYyhiIHx8IFxcXCJcXFwiKSB8fCBbXTtyZXR1cm4geyBocmVmOiBjWzBdIHx8IFxcXCJcXFwiLCBocmVmTm9IYXNoOiBjWzFdIHx8IFxcXCJcXFwiLCBocmVmTm9TZWFyY2g6IGNbMl0gfHwgXFxcIlxcXCIsIGRvbWFpbjogY1szXSB8fCBcXFwiXFxcIiwgcHJvdG9jb2w6IGNbNF0gfHwgXFxcIlxcXCIsIGRvdWJsZVNsYXNoOiBjWzVdIHx8IFxcXCJcXFwiLCBhdXRob3JpdHk6IGNbNl0gfHwgXFxcIlxcXCIsIHVzZXJuYW1lOiBjWzhdIHx8IFxcXCJcXFwiLCBwYXNzd29yZDogY1s5XSB8fCBcXFwiXFxcIiwgaG9zdDogY1sxMF0gfHwgXFxcIlxcXCIsIGhvc3RuYW1lOiBjWzExXSB8fCBcXFwiXFxcIiwgcG9ydDogY1sxMl0gfHwgXFxcIlxcXCIsIHBhdGhuYW1lOiBjWzEzXSB8fCBcXFwiXFxcIiwgZGlyZWN0b3J5OiBjWzE0XSB8fCBcXFwiXFxcIiwgZmlsZW5hbWU6IGNbMTVdIHx8IFxcXCJcXFwiLCBzZWFyY2g6IGNbMTZdIHx8IFxcXCJcXFwiLCBoYXNoOiBjWzE3XSB8fCBcXFwiXFxcIiB9O1xcbiAgICAgIH0sIG1ha2VQYXRoQWJzb2x1dGU6IGZ1bmN0aW9uIG1ha2VQYXRoQWJzb2x1dGUoYSwgYikge1xcbiAgICAgICAgdmFyIGMsIGQsIGUsIGY7aWYgKGEgJiYgXFxcIi9cXFwiID09PSBhLmNoYXJBdCgwKSkgcmV0dXJuIGE7Zm9yIChhID0gYSB8fCBcXFwiXFxcIiwgYiA9IGIgPyBiLnJlcGxhY2UoL15cXFxcL3woXFxcXC9bXlxcXFwvXSp8W15cXFxcL10rKSQvZywgXFxcIlxcXCIpIDogXFxcIlxcXCIsIGMgPSBiID8gYi5zcGxpdChcXFwiL1xcXCIpIDogW10sIGQgPSBhLnNwbGl0KFxcXCIvXFxcIiksIGUgPSAwOyBlIDwgZC5sZW5ndGg7IGUrKykge1xcbiAgICAgICAgICBzd2l0Y2ggKGYgPSBkW2VdKSB7Y2FzZSBcXFwiLlxcXCI6XFxuICAgICAgICAgICAgICBicmVhaztjYXNlIFxcXCIuLlxcXCI6XFxuICAgICAgICAgICAgICBjLmxlbmd0aCAmJiBjLnBvcCgpO2JyZWFrO2RlZmF1bHQ6XFxuICAgICAgICAgICAgICBjLnB1c2goZik7fVxcbiAgICAgICAgfXJldHVybiBcXFwiL1xcXCIgKyBjLmpvaW4oXFxcIi9cXFwiKTtcXG4gICAgICB9LCBpc1NhbWVEb21haW46IGZ1bmN0aW9uIGlzU2FtZURvbWFpbihhLCBiKSB7XFxuICAgICAgICByZXR1cm4gZC5wYXJzZVVybChhKS5kb21haW4udG9Mb3dlckNhc2UoKSA9PT0gZC5wYXJzZVVybChiKS5kb21haW4udG9Mb3dlckNhc2UoKTtcXG4gICAgICB9LCBpc1JlbGF0aXZlVXJsOiBmdW5jdGlvbiBpc1JlbGF0aXZlVXJsKGEpIHtcXG4gICAgICAgIHJldHVybiBcXFwiXFxcIiA9PT0gZC5wYXJzZVVybChhKS5wcm90b2NvbDtcXG4gICAgICB9LCBpc0Fic29sdXRlVXJsOiBmdW5jdGlvbiBpc0Fic29sdXRlVXJsKGEpIHtcXG4gICAgICAgIHJldHVybiBcXFwiXFxcIiAhPT0gZC5wYXJzZVVybChhKS5wcm90b2NvbDtcXG4gICAgICB9LCBtYWtlVXJsQWJzb2x1dGU6IGZ1bmN0aW9uIG1ha2VVcmxBYnNvbHV0ZShhLCBiKSB7XFxuICAgICAgICBpZiAoIWQuaXNSZWxhdGl2ZVVybChhKSkgcmV0dXJuIGE7YiA9PT0gYyAmJiAoYiA9IHRoaXMuZG9jdW1lbnRCYXNlKTt2YXIgZSA9IGQucGFyc2VVcmwoYSksXFxuICAgICAgICAgICAgZiA9IGQucGFyc2VVcmwoYiksXFxuICAgICAgICAgICAgZyA9IGUucHJvdG9jb2wgfHwgZi5wcm90b2NvbCxcXG4gICAgICAgICAgICBoID0gZS5wcm90b2NvbCA/IGUuZG91YmxlU2xhc2ggOiBlLmRvdWJsZVNsYXNoIHx8IGYuZG91YmxlU2xhc2gsXFxuICAgICAgICAgICAgaSA9IGUuYXV0aG9yaXR5IHx8IGYuYXV0aG9yaXR5LFxcbiAgICAgICAgICAgIGogPSBcXFwiXFxcIiAhPT0gZS5wYXRobmFtZSxcXG4gICAgICAgICAgICBrID0gZC5tYWtlUGF0aEFic29sdXRlKGUucGF0aG5hbWUgfHwgZi5maWxlbmFtZSwgZi5wYXRobmFtZSksXFxuICAgICAgICAgICAgbCA9IGUuc2VhcmNoIHx8ICFqICYmIGYuc2VhcmNoIHx8IFxcXCJcXFwiLFxcbiAgICAgICAgICAgIG0gPSBlLmhhc2g7cmV0dXJuIGcgKyBoICsgaSArIGsgKyBsICsgbTtcXG4gICAgICB9LCBhZGRTZWFyY2hQYXJhbXM6IGZ1bmN0aW9uIGFkZFNlYXJjaFBhcmFtcyhiLCBjKSB7XFxuICAgICAgICB2YXIgZSA9IGQucGFyc2VVcmwoYiksXFxuICAgICAgICAgICAgZiA9IFxcXCJvYmplY3RcXFwiID09ICh0eXBlb2YgYyA9PT0gXFxcInVuZGVmaW5lZFxcXCIgPyBcXFwidW5kZWZpbmVkXFxcIiA6IF90eXBlb2YoYykpID8gYS5wYXJhbShjKSA6IGMsXFxuICAgICAgICAgICAgZyA9IGUuc2VhcmNoIHx8IFxcXCI/XFxcIjtyZXR1cm4gZS5ocmVmTm9TZWFyY2ggKyBnICsgKFxcXCI/XFxcIiAhPT0gZy5jaGFyQXQoZy5sZW5ndGggLSAxKSA/IFxcXCImXFxcIiA6IFxcXCJcXFwiKSArIGYgKyAoZS5oYXNoIHx8IFxcXCJcXFwiKTtcXG4gICAgICB9LCBjb252ZXJ0VXJsVG9EYXRhVXJsOiBmdW5jdGlvbiBjb252ZXJ0VXJsVG9EYXRhVXJsKGEpIHtcXG4gICAgICAgIHZhciBjID0gYSxcXG4gICAgICAgICAgICBlID0gZC5wYXJzZVVybChhKTtyZXR1cm4gZC5pc0VtYmVkZGVkUGFnZShlKSA/IGMgPSBlLmhhc2guc3BsaXQoZilbMF0ucmVwbGFjZSgvXiMvLCBcXFwiXFxcIikucmVwbGFjZSgvXFxcXD8uKiQvLCBcXFwiXFxcIikgOiBkLmlzU2FtZURvbWFpbihlLCB0aGlzLmRvY3VtZW50QmFzZSkgJiYgKGMgPSBlLmhyZWZOb0hhc2gucmVwbGFjZSh0aGlzLmRvY3VtZW50QmFzZS5kb21haW4sIFxcXCJcXFwiKS5zcGxpdChmKVswXSksIGIuZGVjb2RlVVJJQ29tcG9uZW50KGMpO1xcbiAgICAgIH0sIGdldDogZnVuY3Rpb24gZ2V0KGEpIHtcXG4gICAgICAgIHJldHVybiBhID09PSBjICYmIChhID0gZC5wYXJzZUxvY2F0aW9uKCkuaGFzaCksIGQuc3RyaXBIYXNoKGEpLnJlcGxhY2UoL1teXFxcXC9dKlxcXFwuW15cXFxcLypdKyQvLCBcXFwiXFxcIik7XFxuICAgICAgfSwgc2V0OiBmdW5jdGlvbiBzZXQoYSkge1xcbiAgICAgICAgbG9jYXRpb24uaGFzaCA9IGE7XFxuICAgICAgfSwgaXNQYXRoOiBmdW5jdGlvbiBpc1BhdGgoYSkge1xcbiAgICAgICAgcmV0dXJuICgvXFxcXC8vLnRlc3QoYSlcXG4gICAgICAgICk7XFxuICAgICAgfSwgY2xlYW46IGZ1bmN0aW9uIGNsZWFuKGEpIHtcXG4gICAgICAgIHJldHVybiBhLnJlcGxhY2UodGhpcy5kb2N1bWVudEJhc2UuZG9tYWluLCBcXFwiXFxcIik7XFxuICAgICAgfSwgc3RyaXBIYXNoOiBmdW5jdGlvbiBzdHJpcEhhc2goYSkge1xcbiAgICAgICAgcmV0dXJuIGEucmVwbGFjZSgvXiMvLCBcXFwiXFxcIik7XFxuICAgICAgfSwgc3RyaXBRdWVyeVBhcmFtczogZnVuY3Rpb24gc3RyaXBRdWVyeVBhcmFtcyhhKSB7XFxuICAgICAgICByZXR1cm4gYS5yZXBsYWNlKC9cXFxcPy4qJC8sIFxcXCJcXFwiKTtcXG4gICAgICB9LCBjbGVhbkhhc2g6IGZ1bmN0aW9uIGNsZWFuSGFzaChhKSB7XFxuICAgICAgICByZXR1cm4gZC5zdHJpcEhhc2goYS5yZXBsYWNlKC9cXFxcPy4qJC8sIFxcXCJcXFwiKS5yZXBsYWNlKGYsIFxcXCJcXFwiKSk7XFxuICAgICAgfSwgaXNIYXNoVmFsaWQ6IGZ1bmN0aW9uIGlzSGFzaFZhbGlkKGEpIHtcXG4gICAgICAgIHJldHVybiAoL14jW14jXSskLy50ZXN0KGEpXFxuICAgICAgICApO1xcbiAgICAgIH0sIGlzRXh0ZXJuYWw6IGZ1bmN0aW9uIGlzRXh0ZXJuYWwoYSkge1xcbiAgICAgICAgdmFyIGIgPSBkLnBhcnNlVXJsKGEpO3JldHVybiAhKCFiLnByb3RvY29sIHx8IGIuZG9tYWluLnRvTG93ZXJDYXNlKCkgPT09IHRoaXMuZG9jdW1lbnRVcmwuZG9tYWluLnRvTG93ZXJDYXNlKCkpO1xcbiAgICAgIH0sIGhhc1Byb3RvY29sOiBmdW5jdGlvbiBoYXNQcm90b2NvbChhKSB7XFxuICAgICAgICByZXR1cm4gKC9eKDo/XFxcXHcrOikvLnRlc3QoYSlcXG4gICAgICAgICk7XFxuICAgICAgfSwgaXNFbWJlZGRlZFBhZ2U6IGZ1bmN0aW9uIGlzRW1iZWRkZWRQYWdlKGEpIHtcXG4gICAgICAgIHZhciBiID0gZC5wYXJzZVVybChhKTtyZXR1cm4gXFxcIlxcXCIgIT09IGIucHJvdG9jb2wgPyAhdGhpcy5pc1BhdGgoYi5oYXNoKSAmJiBiLmhhc2ggJiYgKGIuaHJlZk5vSGFzaCA9PT0gdGhpcy5kb2N1bWVudFVybC5ocmVmTm9IYXNoIHx8IHRoaXMuZG9jdW1lbnRCYXNlRGlmZmVycyAmJiBiLmhyZWZOb0hhc2ggPT09IHRoaXMuZG9jdW1lbnRCYXNlLmhyZWZOb0hhc2gpIDogL14jLy50ZXN0KGIuaHJlZik7XFxuICAgICAgfSwgc3F1YXNoOiBmdW5jdGlvbiBzcXVhc2goYSwgYikge1xcbiAgICAgICAgdmFyIGMsXFxuICAgICAgICAgICAgZSxcXG4gICAgICAgICAgICBmLFxcbiAgICAgICAgICAgIGcsXFxuICAgICAgICAgICAgaCxcXG4gICAgICAgICAgICBpID0gdGhpcy5pc1BhdGgoYSksXFxuICAgICAgICAgICAgaiA9IHRoaXMucGFyc2VVcmwoYSksXFxuICAgICAgICAgICAgayA9IGouaGFzaCxcXG4gICAgICAgICAgICBsID0gXFxcIlxcXCI7cmV0dXJuIGIgfHwgKGkgPyBiID0gZC5nZXRMb2NhdGlvbigpIDogKGggPSBkLmdldERvY3VtZW50VXJsKCEwKSwgYiA9IGQuaXNQYXRoKGguaGFzaCkgPyBkLnNxdWFzaChoLmhyZWYpIDogaC5ocmVmKSksIGUgPSBpID8gZC5zdHJpcEhhc2goYSkgOiBhLCBlID0gZC5pc1BhdGgoai5oYXNoKSA/IGQuc3RyaXBIYXNoKGouaGFzaCkgOiBlLCBnID0gZS5pbmRleE9mKHRoaXMudWlTdGF0ZUtleSksIGcgPiAtMSAmJiAobCA9IGUuc2xpY2UoZyksIGUgPSBlLnNsaWNlKDAsIGcpKSwgYyA9IGQubWFrZVVybEFic29sdXRlKGUsIGIpLCBmID0gdGhpcy5wYXJzZVVybChjKS5zZWFyY2gsIGkgPyAoKGQuaXNQYXRoKGspIHx8IDAgPT09IGsucmVwbGFjZShcXFwiI1xcXCIsIFxcXCJcXFwiKS5pbmRleE9mKHRoaXMudWlTdGF0ZUtleSkpICYmIChrID0gXFxcIlxcXCIpLCBsICYmIC0xID09PSBrLmluZGV4T2YodGhpcy51aVN0YXRlS2V5KSAmJiAoayArPSBsKSwgLTEgPT09IGsuaW5kZXhPZihcXFwiI1xcXCIpICYmIFxcXCJcXFwiICE9PSBrICYmIChrID0gXFxcIiNcXFwiICsgayksIGMgPSBkLnBhcnNlVXJsKGMpLCBjID0gYy5wcm90b2NvbCArIGMuZG91YmxlU2xhc2ggKyBjLmhvc3QgKyBjLnBhdGhuYW1lICsgZiArIGspIDogYyArPSBjLmluZGV4T2YoXFxcIiNcXFwiKSA+IC0xID8gbCA6IFxcXCIjXFxcIiArIGwsIGM7XFxuICAgICAgfSwgaXNQcmVzZXJ2YWJsZUhhc2g6IGZ1bmN0aW9uIGlzUHJlc2VydmFibGVIYXNoKGEpIHtcXG4gICAgICAgIHJldHVybiAwID09PSBhLnJlcGxhY2UoXFxcIiNcXFwiLCBcXFwiXFxcIikuaW5kZXhPZih0aGlzLnVpU3RhdGVLZXkpO1xcbiAgICAgIH0sIGhhc2hUb1NlbGVjdG9yOiBmdW5jdGlvbiBoYXNoVG9TZWxlY3RvcihhKSB7XFxuICAgICAgICB2YXIgYiA9IFxcXCIjXFxcIiA9PT0gYS5zdWJzdHJpbmcoMCwgMSk7cmV0dXJuIGIgJiYgKGEgPSBhLnN1YnN0cmluZygxKSksIChiID8gXFxcIiNcXFwiIDogXFxcIlxcXCIpICsgYS5yZXBsYWNlKC8oWyFcXFwiIyQlJicoKSorLC4vOjs8PT4/QFtcXFxcXV5ge3x9fl0pL2csIFxcXCJcXFxcXFxcXCQxXFxcIik7XFxuICAgICAgfSwgZ2V0RmlsZVBhdGg6IGZ1bmN0aW9uIGdldEZpbGVQYXRoKGEpIHtcXG4gICAgICAgIHJldHVybiBhICYmIGEuc3BsaXQoZilbMF07XFxuICAgICAgfSwgaXNGaXJzdFBhZ2VVcmw6IGZ1bmN0aW9uIGlzRmlyc3RQYWdlVXJsKGIpIHtcXG4gICAgICAgIHZhciBlID0gZC5wYXJzZVVybChkLm1ha2VVcmxBYnNvbHV0ZShiLCB0aGlzLmRvY3VtZW50QmFzZSkpLFxcbiAgICAgICAgICAgIGYgPSBlLmhyZWZOb0hhc2ggPT09IHRoaXMuZG9jdW1lbnRVcmwuaHJlZk5vSGFzaCB8fCB0aGlzLmRvY3VtZW50QmFzZURpZmZlcnMgJiYgZS5ocmVmTm9IYXNoID09PSB0aGlzLmRvY3VtZW50QmFzZS5ocmVmTm9IYXNoLFxcbiAgICAgICAgICAgIGcgPSBhLm1vYmlsZS5maXJzdFBhZ2UsXFxuICAgICAgICAgICAgaCA9IGcgJiYgZ1swXSA/IGdbMF0uaWQgOiBjO3JldHVybiBmICYmICghZS5oYXNoIHx8IFxcXCIjXFxcIiA9PT0gZS5oYXNoIHx8IGggJiYgZS5oYXNoLnJlcGxhY2UoL14jLywgXFxcIlxcXCIpID09PSBoKTtcXG4gICAgICB9LCBpc1Blcm1pdHRlZENyb3NzRG9tYWluUmVxdWVzdDogZnVuY3Rpb24gaXNQZXJtaXR0ZWRDcm9zc0RvbWFpblJlcXVlc3QoYiwgYykge1xcbiAgICAgICAgcmV0dXJuIGEubW9iaWxlLmFsbG93Q3Jvc3NEb21haW5QYWdlcyAmJiAoXFxcImZpbGU6XFxcIiA9PT0gYi5wcm90b2NvbCB8fCBcXFwiY29udGVudDpcXFwiID09PSBiLnByb3RvY29sKSAmJiAtMSAhPT0gYy5zZWFyY2goL15odHRwcz86Lyk7XFxuICAgICAgfSB9LCBkLmRvY3VtZW50VXJsID0gZC5wYXJzZUxvY2F0aW9uKCksIGUgPSBhKFxcXCJoZWFkXFxcIikuZmluZChcXFwiYmFzZVxcXCIpLCBkLmRvY3VtZW50QmFzZSA9IGUubGVuZ3RoID8gZC5wYXJzZVVybChkLm1ha2VVcmxBYnNvbHV0ZShlLmF0dHIoXFxcImhyZWZcXFwiKSwgZC5kb2N1bWVudFVybC5ocmVmKSkgOiBkLmRvY3VtZW50VXJsLCBkLmRvY3VtZW50QmFzZURpZmZlcnMgPSBkLmRvY3VtZW50VXJsLmhyZWZOb0hhc2ggIT09IGQuZG9jdW1lbnRCYXNlLmhyZWZOb0hhc2gsIGQuZ2V0RG9jdW1lbnRCYXNlID0gZnVuY3Rpb24gKGIpIHtcXG4gICAgICByZXR1cm4gYiA/IGEuZXh0ZW5kKHt9LCBkLmRvY3VtZW50QmFzZSkgOiBkLmRvY3VtZW50QmFzZS5ocmVmO1xcbiAgICB9LCBhLmV4dGVuZChhLm1vYmlsZSwgeyBnZXREb2N1bWVudFVybDogZC5nZXREb2N1bWVudFVybCwgZ2V0RG9jdW1lbnRCYXNlOiBkLmdldERvY3VtZW50QmFzZSB9KTtcXG4gIH0oYSksIGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgIGEubW9iaWxlLkhpc3RvcnkgPSBmdW5jdGlvbiAoYSwgYikge1xcbiAgICAgIHRoaXMuc3RhY2sgPSBhIHx8IFtdLCB0aGlzLmFjdGl2ZUluZGV4ID0gYiB8fCAwO1xcbiAgICB9LCBhLmV4dGVuZChhLm1vYmlsZS5IaXN0b3J5LnByb3RvdHlwZSwgeyBnZXRBY3RpdmU6IGZ1bmN0aW9uIGdldEFjdGl2ZSgpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLnN0YWNrW3RoaXMuYWN0aXZlSW5kZXhdO1xcbiAgICAgIH0sIGdldExhc3Q6IGZ1bmN0aW9uIGdldExhc3QoKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5zdGFja1t0aGlzLnByZXZpb3VzSW5kZXhdO1xcbiAgICAgIH0sIGdldE5leHQ6IGZ1bmN0aW9uIGdldE5leHQoKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5zdGFja1t0aGlzLmFjdGl2ZUluZGV4ICsgMV07XFxuICAgICAgfSwgZ2V0UHJldjogZnVuY3Rpb24gZ2V0UHJldigpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLnN0YWNrW3RoaXMuYWN0aXZlSW5kZXggLSAxXTtcXG4gICAgICB9LCBhZGQ6IGZ1bmN0aW9uIGFkZChhLCBiKSB7XFxuICAgICAgICBiID0gYiB8fCB7fSwgdGhpcy5nZXROZXh0KCkgJiYgdGhpcy5jbGVhckZvcndhcmQoKSwgYi5oYXNoICYmIC0xID09PSBiLmhhc2guaW5kZXhPZihcXFwiI1xcXCIpICYmIChiLmhhc2ggPSBcXFwiI1xcXCIgKyBiLmhhc2gpLCBiLnVybCA9IGEsIHRoaXMuc3RhY2sucHVzaChiKSwgdGhpcy5hY3RpdmVJbmRleCA9IHRoaXMuc3RhY2subGVuZ3RoIC0gMTtcXG4gICAgICB9LCBjbGVhckZvcndhcmQ6IGZ1bmN0aW9uIGNsZWFyRm9yd2FyZCgpIHtcXG4gICAgICAgIHRoaXMuc3RhY2sgPSB0aGlzLnN0YWNrLnNsaWNlKDAsIHRoaXMuYWN0aXZlSW5kZXggKyAxKTtcXG4gICAgICB9LCBmaW5kOiBmdW5jdGlvbiBmaW5kKGEsIGIsIGMpIHtcXG4gICAgICAgIGIgPSBiIHx8IHRoaXMuc3RhY2s7dmFyIGQsXFxuICAgICAgICAgICAgZSxcXG4gICAgICAgICAgICBmLFxcbiAgICAgICAgICAgIGcgPSBiLmxlbmd0aDtmb3IgKGUgPSAwOyBnID4gZTsgZSsrKSB7XFxuICAgICAgICAgIGlmIChkID0gYltlXSwgKGRlY29kZVVSSUNvbXBvbmVudChhKSA9PT0gZGVjb2RlVVJJQ29tcG9uZW50KGQudXJsKSB8fCBkZWNvZGVVUklDb21wb25lbnQoYSkgPT09IGRlY29kZVVSSUNvbXBvbmVudChkLmhhc2gpKSAmJiAoZiA9IGUsIGMpKSByZXR1cm4gZjtcXG4gICAgICAgIH1yZXR1cm4gZjtcXG4gICAgICB9LCBjbG9zZXN0OiBmdW5jdGlvbiBjbG9zZXN0KGEpIHtcXG4gICAgICAgIHZhciBjLFxcbiAgICAgICAgICAgIGQgPSB0aGlzLmFjdGl2ZUluZGV4O3JldHVybiBjID0gdGhpcy5maW5kKGEsIHRoaXMuc3RhY2suc2xpY2UoMCwgZCkpLCBjID09PSBiICYmIChjID0gdGhpcy5maW5kKGEsIHRoaXMuc3RhY2suc2xpY2UoZCksICEwKSwgYyA9IGMgPT09IGIgPyBjIDogYyArIGQpLCBjO1xcbiAgICAgIH0sIGRpcmVjdDogZnVuY3Rpb24gZGlyZWN0KGMpIHtcXG4gICAgICAgIHZhciBkID0gdGhpcy5jbG9zZXN0KGMudXJsKSxcXG4gICAgICAgICAgICBlID0gdGhpcy5hY3RpdmVJbmRleDtkICE9PSBiICYmICh0aGlzLmFjdGl2ZUluZGV4ID0gZCwgdGhpcy5wcmV2aW91c0luZGV4ID0gZSksIGUgPiBkID8gKGMucHJlc2VudCB8fCBjLmJhY2sgfHwgYS5ub29wKSh0aGlzLmdldEFjdGl2ZSgpLCBcXFwiYmFja1xcXCIpIDogZCA+IGUgPyAoYy5wcmVzZW50IHx8IGMuZm9yd2FyZCB8fCBhLm5vb3ApKHRoaXMuZ2V0QWN0aXZlKCksIFxcXCJmb3J3YXJkXFxcIikgOiBkID09PSBiICYmIGMubWlzc2luZyAmJiBjLm1pc3NpbmcodGhpcy5nZXRBY3RpdmUoKSk7XFxuICAgICAgfSB9KTtcXG4gIH0oYSksIGZ1bmN0aW9uIChhKSB7XFxuICAgIHZhciBkID0gYS5tb2JpbGUucGF0aCxcXG4gICAgICAgIGUgPSBsb2NhdGlvbi5ocmVmO2EubW9iaWxlLk5hdmlnYXRvciA9IGZ1bmN0aW9uIChiKSB7XFxuICAgICAgdGhpcy5oaXN0b3J5ID0gYiwgdGhpcy5pZ25vcmVJbml0aWFsSGFzaENoYW5nZSA9ICEwLCBhLm1vYmlsZS53aW5kb3cuYmluZCh7IFxcXCJwb3BzdGF0ZS5oaXN0b3J5XFxcIjogYS5wcm94eSh0aGlzLnBvcHN0YXRlLCB0aGlzKSwgXFxcImhhc2hjaGFuZ2UuaGlzdG9yeVxcXCI6IGEucHJveHkodGhpcy5oYXNoY2hhbmdlLCB0aGlzKSB9KTtcXG4gICAgfSwgYS5leHRlbmQoYS5tb2JpbGUuTmF2aWdhdG9yLnByb3RvdHlwZSwgeyBzcXVhc2g6IGZ1bmN0aW9uIHNxdWFzaChlLCBmKSB7XFxuICAgICAgICB2YXIgZyxcXG4gICAgICAgICAgICBoLFxcbiAgICAgICAgICAgIGkgPSBkLmlzUGF0aChlKSA/IGQuc3RyaXBIYXNoKGUpIDogZTtyZXR1cm4gaCA9IGQuc3F1YXNoKGUpLCBnID0gYS5leHRlbmQoeyBoYXNoOiBpLCB1cmw6IGggfSwgZiksIGIuaGlzdG9yeS5yZXBsYWNlU3RhdGUoZywgZy50aXRsZSB8fCBjLnRpdGxlLCBoKSwgZztcXG4gICAgICB9LCBoYXNoOiBmdW5jdGlvbiBoYXNoKGEsIGIpIHtcXG4gICAgICAgIHZhciBjLCBlLCBmLCBnO3JldHVybiBjID0gZC5wYXJzZVVybChhKSwgZSA9IGQucGFyc2VMb2NhdGlvbigpLCBlLnBhdGhuYW1lICsgZS5zZWFyY2ggPT09IGMucGF0aG5hbWUgKyBjLnNlYXJjaCA/IGYgPSBjLmhhc2ggPyBjLmhhc2ggOiBjLnBhdGhuYW1lICsgYy5zZWFyY2ggOiBkLmlzUGF0aChhKSA/IChnID0gZC5wYXJzZVVybChiKSwgZiA9IGcucGF0aG5hbWUgKyBnLnNlYXJjaCArIChkLmlzUHJlc2VydmFibGVIYXNoKGcuaGFzaCkgPyBnLmhhc2gucmVwbGFjZShcXFwiI1xcXCIsIFxcXCJcXFwiKSA6IFxcXCJcXFwiKSkgOiBmID0gYSwgZjtcXG4gICAgICB9LCBnbzogZnVuY3Rpb24gZ28oZSwgZiwgZykge1xcbiAgICAgICAgdmFyIGgsXFxuICAgICAgICAgICAgaSxcXG4gICAgICAgICAgICBqLFxcbiAgICAgICAgICAgIGssXFxuICAgICAgICAgICAgbCA9IGEuZXZlbnQuc3BlY2lhbC5uYXZpZ2F0ZS5pc1B1c2hTdGF0ZUVuYWJsZWQoKTtcXG4gICAgICAgIGkgPSBkLnNxdWFzaChlKSwgaiA9IHRoaXMuaGFzaChlLCBpKSwgZyAmJiBqICE9PSBkLnN0cmlwSGFzaChkLnBhcnNlTG9jYXRpb24oKS5oYXNoKSAmJiAodGhpcy5wcmV2ZW50TmV4dEhhc2hDaGFuZ2UgPSBnKSwgdGhpcy5wcmV2ZW50SGFzaEFzc2lnblBvcFN0YXRlID0gITAsIGIubG9jYXRpb24uaGFzaCA9IGosIHRoaXMucHJldmVudEhhc2hBc3NpZ25Qb3BTdGF0ZSA9ICExLCBoID0gYS5leHRlbmQoeyB1cmw6IGksIGhhc2g6IGosIHRpdGxlOiBjLnRpdGxlIH0sIGYpLCBsICYmIChrID0gbmV3IGEuRXZlbnQoXFxcInBvcHN0YXRlXFxcIiksIGsub3JpZ2luYWxFdmVudCA9IHsgdHlwZTogXFxcInBvcHN0YXRlXFxcIiwgc3RhdGU6IG51bGwgfSwgdGhpcy5zcXVhc2goZSwgaCksIGcgfHwgKHRoaXMuaWdub3JlUG9wU3RhdGUgPSAhMCwgYS5tb2JpbGUud2luZG93LnRyaWdnZXIoaykpKSwgdGhpcy5oaXN0b3J5LmFkZChoLnVybCwgaCk7XFxuICAgICAgfSwgcG9wc3RhdGU6IGZ1bmN0aW9uIHBvcHN0YXRlKGIpIHtcXG4gICAgICAgIHZhciBjLCBmO2lmIChhLmV2ZW50LnNwZWNpYWwubmF2aWdhdGUuaXNQdXNoU3RhdGVFbmFibGVkKCkpIHJldHVybiB0aGlzLnByZXZlbnRIYXNoQXNzaWduUG9wU3RhdGUgPyAodGhpcy5wcmV2ZW50SGFzaEFzc2lnblBvcFN0YXRlID0gITEsIHZvaWQgYi5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSkgOiB0aGlzLmlnbm9yZVBvcFN0YXRlID8gdm9pZCAodGhpcy5pZ25vcmVQb3BTdGF0ZSA9ICExKSA6ICFiLm9yaWdpbmFsRXZlbnQuc3RhdGUgJiYgMSA9PT0gdGhpcy5oaXN0b3J5LnN0YWNrLmxlbmd0aCAmJiB0aGlzLmlnbm9yZUluaXRpYWxIYXNoQ2hhbmdlICYmICh0aGlzLmlnbm9yZUluaXRpYWxIYXNoQ2hhbmdlID0gITEsIGxvY2F0aW9uLmhyZWYgPT09IGUpID8gdm9pZCBiLnByZXZlbnREZWZhdWx0KCkgOiAoYyA9IGQucGFyc2VMb2NhdGlvbigpLmhhc2gsICFiLm9yaWdpbmFsRXZlbnQuc3RhdGUgJiYgYyA/IChmID0gdGhpcy5zcXVhc2goYyksIHRoaXMuaGlzdG9yeS5hZGQoZi51cmwsIGYpLCB2b2lkIChiLmhpc3RvcnlTdGF0ZSA9IGYpKSA6IHZvaWQgdGhpcy5oaXN0b3J5LmRpcmVjdCh7IHVybDogKGIub3JpZ2luYWxFdmVudC5zdGF0ZSB8fCB7fSkudXJsIHx8IGMsIHByZXNlbnQ6IGZ1bmN0aW9uIHByZXNlbnQoYywgZCkge1xcbiAgICAgICAgICAgIGIuaGlzdG9yeVN0YXRlID0gYS5leHRlbmQoe30sIGMpLCBiLmhpc3RvcnlTdGF0ZS5kaXJlY3Rpb24gPSBkO1xcbiAgICAgICAgICB9IH0pKTtcXG4gICAgICB9LCBoYXNoY2hhbmdlOiBmdW5jdGlvbiBoYXNoY2hhbmdlKGIpIHtcXG4gICAgICAgIHZhciBlLCBmO2lmIChhLmV2ZW50LnNwZWNpYWwubmF2aWdhdGUuaXNIYXNoQ2hhbmdlRW5hYmxlZCgpICYmICFhLmV2ZW50LnNwZWNpYWwubmF2aWdhdGUuaXNQdXNoU3RhdGVFbmFibGVkKCkpIHtcXG4gICAgICAgICAgaWYgKHRoaXMucHJldmVudE5leHRIYXNoQ2hhbmdlKSByZXR1cm4gdGhpcy5wcmV2ZW50TmV4dEhhc2hDaGFuZ2UgPSAhMSwgdm9pZCBiLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO2UgPSB0aGlzLmhpc3RvcnksIGYgPSBkLnBhcnNlTG9jYXRpb24oKS5oYXNoLCB0aGlzLmhpc3RvcnkuZGlyZWN0KHsgdXJsOiBmLCBwcmVzZW50OiBmdW5jdGlvbiBwcmVzZW50KGMsIGQpIHtcXG4gICAgICAgICAgICAgIGIuaGFzaGNoYW5nZVN0YXRlID0gYS5leHRlbmQoe30sIGMpLCBiLmhhc2hjaGFuZ2VTdGF0ZS5kaXJlY3Rpb24gPSBkO1xcbiAgICAgICAgICAgIH0sIG1pc3Npbmc6IGZ1bmN0aW9uIG1pc3NpbmcoKSB7XFxuICAgICAgICAgICAgICBlLmFkZChmLCB7IGhhc2g6IGYsIHRpdGxlOiBjLnRpdGxlIH0pO1xcbiAgICAgICAgICAgIH0gfSk7XFxuICAgICAgICB9XFxuICAgICAgfSB9KTtcXG4gIH0oYSksIGZ1bmN0aW9uIChhKSB7XFxuICAgIGEubW9iaWxlLm5hdmlnYXRlID0gZnVuY3Rpb24gKGIsIGMsIGQpIHtcXG4gICAgICBhLm1vYmlsZS5uYXZpZ2F0ZS5uYXZpZ2F0b3IuZ28oYiwgYywgZCk7XFxuICAgIH0sIGEubW9iaWxlLm5hdmlnYXRlLmhpc3RvcnkgPSBuZXcgYS5tb2JpbGUuSGlzdG9yeSgpLCBhLm1vYmlsZS5uYXZpZ2F0ZS5uYXZpZ2F0b3IgPSBuZXcgYS5tb2JpbGUuTmF2aWdhdG9yKGEubW9iaWxlLm5hdmlnYXRlLmhpc3RvcnkpO3ZhciBiID0gYS5tb2JpbGUucGF0aC5wYXJzZUxvY2F0aW9uKCk7YS5tb2JpbGUubmF2aWdhdGUuaGlzdG9yeS5hZGQoYi5ocmVmLCB7IGhhc2g6IGIuaGFzaCB9KTtcXG4gIH0oYSksIGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgIHZhciBkID0geyBhbmltYXRpb246IHt9LCB0cmFuc2l0aW9uOiB7fSB9LFxcbiAgICAgICAgZSA9IGMuY3JlYXRlRWxlbWVudChcXFwiYVxcXCIpLFxcbiAgICAgICAgZiA9IFtcXFwiXFxcIiwgXFxcIndlYmtpdC1cXFwiLCBcXFwibW96LVxcXCIsIFxcXCJvLVxcXCJdO2EuZWFjaChbXFxcImFuaW1hdGlvblxcXCIsIFxcXCJ0cmFuc2l0aW9uXFxcIl0sIGZ1bmN0aW9uIChjLCBnKSB7XFxuICAgICAgdmFyIGggPSAwID09PSBjID8gZyArIFxcXCItbmFtZVxcXCIgOiBnO2EuZWFjaChmLCBmdW5jdGlvbiAoYywgZikge1xcbiAgICAgICAgcmV0dXJuIGUuc3R5bGVbYS5jYW1lbENhc2UoZiArIGgpXSAhPT0gYiA/IChkW2ddLnByZWZpeCA9IGYsICExKSA6IHZvaWQgMDtcXG4gICAgICB9KSwgZFtnXS5kdXJhdGlvbiA9IGEuY2FtZWxDYXNlKGRbZ10ucHJlZml4ICsgZyArIFxcXCItZHVyYXRpb25cXFwiKSwgZFtnXS5ldmVudCA9IGEuY2FtZWxDYXNlKGRbZ10ucHJlZml4ICsgZyArIFxcXCItZW5kXFxcIiksIFxcXCJcXFwiID09PSBkW2ddLnByZWZpeCAmJiAoZFtnXS5ldmVudCA9IGRbZ10uZXZlbnQudG9Mb3dlckNhc2UoKSk7XFxuICAgIH0pLCBhLnN1cHBvcnQuY3NzVHJhbnNpdGlvbnMgPSBkLnRyYW5zaXRpb24ucHJlZml4ICE9PSBiLCBhLnN1cHBvcnQuY3NzQW5pbWF0aW9ucyA9IGQuYW5pbWF0aW9uLnByZWZpeCAhPT0gYiwgYShlKS5yZW1vdmUoKSwgYS5mbi5hbmltYXRpb25Db21wbGV0ZSA9IGZ1bmN0aW9uIChlLCBmLCBnKSB7XFxuICAgICAgdmFyIGgsXFxuICAgICAgICAgIGksXFxuICAgICAgICAgIGogPSB0aGlzLFxcbiAgICAgICAgICBrID0gZnVuY3Rpb24gaygpIHtcXG4gICAgICAgIGNsZWFyVGltZW91dChoKSwgZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgICAgIH0sXFxuICAgICAgICAgIGwgPSBmICYmIFxcXCJhbmltYXRpb25cXFwiICE9PSBmID8gXFxcInRyYW5zaXRpb25cXFwiIDogXFxcImFuaW1hdGlvblxcXCI7cmV0dXJuIGEuc3VwcG9ydC5jc3NUcmFuc2l0aW9ucyAmJiBcXFwidHJhbnNpdGlvblxcXCIgPT09IGwgfHwgYS5zdXBwb3J0LmNzc0FuaW1hdGlvbnMgJiYgXFxcImFuaW1hdGlvblxcXCIgPT09IGwgPyAoZyA9PT0gYiAmJiAoYSh0aGlzKS5jb250ZXh0ICE9PSBjICYmIChpID0gM2UzICogcGFyc2VGbG9hdChhKHRoaXMpLmNzcyhkW2xdLmR1cmF0aW9uKSkpLCAoMCA9PT0gaSB8fCBpID09PSBiIHx8IGlzTmFOKGkpKSAmJiAoaSA9IGEuZm4uYW5pbWF0aW9uQ29tcGxldGUuZGVmYXVsdER1cmF0aW9uKSksIGggPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGEoaikub2ZmKGRbbF0uZXZlbnQsIGspLCBlLmFwcGx5KGopO1xcbiAgICAgIH0sIGkpLCBhKHRoaXMpLm9uZShkW2xdLmV2ZW50LCBrKSkgOiAoc2V0VGltZW91dChhLnByb3h5KGUsIHRoaXMpLCAwKSwgYSh0aGlzKSk7XFxuICAgIH0sIGEuZm4uYW5pbWF0aW9uQ29tcGxldGUuZGVmYXVsdER1cmF0aW9uID0gMWUzO1xcbiAgfShhKSwgZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHtcXG4gICAgZnVuY3Rpb24gZShhKSB7XFxuICAgICAgZm9yICg7IGEgJiYgXFxcInVuZGVmaW5lZFxcXCIgIT0gdHlwZW9mIGEub3JpZ2luYWxFdmVudDspIHtcXG4gICAgICAgIGEgPSBhLm9yaWdpbmFsRXZlbnQ7XFxuICAgICAgfXJldHVybiBhO1xcbiAgICB9ZnVuY3Rpb24gZihiLCBjKSB7XFxuICAgICAgdmFyIGYsXFxuICAgICAgICAgIGcsXFxuICAgICAgICAgIGgsXFxuICAgICAgICAgIGksXFxuICAgICAgICAgIGosXFxuICAgICAgICAgIGssXFxuICAgICAgICAgIGwsXFxuICAgICAgICAgIG0sXFxuICAgICAgICAgIG4sXFxuICAgICAgICAgIG8gPSBiLnR5cGU7aWYgKGIgPSBhLkV2ZW50KGIpLCBiLnR5cGUgPSBjLCBmID0gYi5vcmlnaW5hbEV2ZW50LCBnID0gYS5ldmVudC5wcm9wcywgby5zZWFyY2goL14obW91c2V8Y2xpY2spLykgPiAtMSAmJiAoZyA9IEUpLCBmKSBmb3IgKGwgPSBnLmxlbmd0aCwgaTsgbDspIHtcXG4gICAgICAgIGkgPSBnWy0tbF0sIGJbaV0gPSBmW2ldO1xcbiAgICAgIH1pZiAoby5zZWFyY2goL21vdXNlKGRvd258dXApfGNsaWNrLykgPiAtMSAmJiAhYi53aGljaCAmJiAoYi53aGljaCA9IDEpLCAtMSAhPT0gby5zZWFyY2goL150b3VjaC8pICYmIChoID0gZShmKSwgbyA9IGgudG91Y2hlcywgaiA9IGguY2hhbmdlZFRvdWNoZXMsIGsgPSBvICYmIG8ubGVuZ3RoID8gb1swXSA6IGogJiYgai5sZW5ndGggPyBqWzBdIDogZCkpIGZvciAobSA9IDAsIG4gPSBDLmxlbmd0aDsgbiA+IG07IG0rKykge1xcbiAgICAgICAgaSA9IENbbV0sIGJbaV0gPSBrW2ldO1xcbiAgICAgIH1yZXR1cm4gYjtcXG4gICAgfWZ1bmN0aW9uIGcoYikge1xcbiAgICAgIGZvciAodmFyIGMsIGQsIGUgPSB7fTsgYjspIHtcXG4gICAgICAgIGMgPSBhLmRhdGEoYiwgeik7Zm9yIChkIGluIGMpIHtcXG4gICAgICAgICAgY1tkXSAmJiAoZVtkXSA9IGUuaGFzVmlydHVhbEJpbmRpbmcgPSAhMCk7XFxuICAgICAgICB9YiA9IGIucGFyZW50Tm9kZTtcXG4gICAgICB9cmV0dXJuIGU7XFxuICAgIH1mdW5jdGlvbiBoKGIsIGMpIHtcXG4gICAgICBmb3IgKHZhciBkOyBiOykge1xcbiAgICAgICAgaWYgKGQgPSBhLmRhdGEoYiwgeiksIGQgJiYgKCFjIHx8IGRbY10pKSByZXR1cm4gYjtiID0gYi5wYXJlbnROb2RlO1xcbiAgICAgIH1yZXR1cm4gbnVsbDtcXG4gICAgfWZ1bmN0aW9uIGkoKSB7XFxuICAgICAgTSA9ICExO1xcbiAgICB9ZnVuY3Rpb24gaigpIHtcXG4gICAgICBNID0gITA7XFxuICAgIH1mdW5jdGlvbiBrKCkge1xcbiAgICAgIFEgPSAwLCBLLmxlbmd0aCA9IDAsIEwgPSAhMSwgaigpO1xcbiAgICB9ZnVuY3Rpb24gbCgpIHtcXG4gICAgICBpKCk7XFxuICAgIH1mdW5jdGlvbiBtKCkge1xcbiAgICAgIG4oKSwgRyA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgRyA9IDAsIGsoKTtcXG4gICAgICB9LCBhLnZtb3VzZS5yZXNldFRpbWVyRHVyYXRpb24pO1xcbiAgICB9ZnVuY3Rpb24gbigpIHtcXG4gICAgICBHICYmIChjbGVhclRpbWVvdXQoRyksIEcgPSAwKTtcXG4gICAgfWZ1bmN0aW9uIG8oYiwgYywgZCkge1xcbiAgICAgIHZhciBlO3JldHVybiAoZCAmJiBkW2JdIHx8ICFkICYmIGgoYy50YXJnZXQsIGIpKSAmJiAoZSA9IGYoYywgYiksIGEoYy50YXJnZXQpLnRyaWdnZXIoZSkpLCBlO1xcbiAgICB9ZnVuY3Rpb24gcChiKSB7XFxuICAgICAgdmFyIGMsXFxuICAgICAgICAgIGQgPSBhLmRhdGEoYi50YXJnZXQsIEEpO0wgfHwgUSAmJiBRID09PSBkIHx8IChjID0gbyhcXFwidlxcXCIgKyBiLnR5cGUsIGIpLCBjICYmIChjLmlzRGVmYXVsdFByZXZlbnRlZCgpICYmIGIucHJldmVudERlZmF1bHQoKSwgYy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICYmIGIuc3RvcFByb3BhZ2F0aW9uKCksIGMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSAmJiBiLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpKSk7XFxuICAgIH1mdW5jdGlvbiBxKGIpIHtcXG4gICAgICB2YXIgYyxcXG4gICAgICAgICAgZCxcXG4gICAgICAgICAgZixcXG4gICAgICAgICAgaCA9IGUoYikudG91Y2hlcztoICYmIDEgPT09IGgubGVuZ3RoICYmIChjID0gYi50YXJnZXQsIGQgPSBnKGMpLCBkLmhhc1ZpcnR1YWxCaW5kaW5nICYmIChRID0gUCsrLCBhLmRhdGEoYywgQSwgUSksIG4oKSwgbCgpLCBKID0gITEsIGYgPSBlKGIpLnRvdWNoZXNbMF0sIEggPSBmLnBhZ2VYLCBJID0gZi5wYWdlWSwgbyhcXFwidm1vdXNlb3ZlclxcXCIsIGIsIGQpLCBvKFxcXCJ2bW91c2Vkb3duXFxcIiwgYiwgZCkpKTtcXG4gICAgfWZ1bmN0aW9uIHIoYSkge1xcbiAgICAgIE0gfHwgKEogfHwgbyhcXFwidm1vdXNlY2FuY2VsXFxcIiwgYSwgZyhhLnRhcmdldCkpLCBKID0gITAsIG0oKSk7XFxuICAgIH1mdW5jdGlvbiBzKGIpIHtcXG4gICAgICBpZiAoIU0pIHtcXG4gICAgICAgIHZhciBjID0gZShiKS50b3VjaGVzWzBdLFxcbiAgICAgICAgICAgIGQgPSBKLFxcbiAgICAgICAgICAgIGYgPSBhLnZtb3VzZS5tb3ZlRGlzdGFuY2VUaHJlc2hvbGQsXFxuICAgICAgICAgICAgaCA9IGcoYi50YXJnZXQpO0ogPSBKIHx8IE1hdGguYWJzKGMucGFnZVggLSBIKSA+IGYgfHwgTWF0aC5hYnMoYy5wYWdlWSAtIEkpID4gZiwgSiAmJiAhZCAmJiBvKFxcXCJ2bW91c2VjYW5jZWxcXFwiLCBiLCBoKSwgbyhcXFwidm1vdXNlbW92ZVxcXCIsIGIsIGgpLCBtKCk7XFxuICAgICAgfVxcbiAgICB9ZnVuY3Rpb24gdChhKSB7XFxuICAgICAgaWYgKCFNKSB7XFxuICAgICAgICBqKCk7dmFyIGIsXFxuICAgICAgICAgICAgYyxcXG4gICAgICAgICAgICBkID0gZyhhLnRhcmdldCk7byhcXFwidm1vdXNldXBcXFwiLCBhLCBkKSwgSiB8fCAoYiA9IG8oXFxcInZjbGlja1xcXCIsIGEsIGQpLCBiICYmIGIuaXNEZWZhdWx0UHJldmVudGVkKCkgJiYgKGMgPSBlKGEpLmNoYW5nZWRUb3VjaGVzWzBdLCBLLnB1c2goeyB0b3VjaElEOiBRLCB4OiBjLmNsaWVudFgsIHk6IGMuY2xpZW50WSB9KSwgTCA9ICEwKSksIG8oXFxcInZtb3VzZW91dFxcXCIsIGEsIGQpLCBKID0gITEsIG0oKTtcXG4gICAgICB9XFxuICAgIH1mdW5jdGlvbiB1KGIpIHtcXG4gICAgICB2YXIgYyxcXG4gICAgICAgICAgZCA9IGEuZGF0YShiLCB6KTtpZiAoZCkgZm9yIChjIGluIGQpIHtcXG4gICAgICAgIGlmIChkW2NdKSByZXR1cm4gITA7XFxuICAgICAgfXJldHVybiAhMTtcXG4gICAgfWZ1bmN0aW9uIHYoKSB7fWZ1bmN0aW9uIHcoYikge1xcbiAgICAgIHZhciBjID0gYi5zdWJzdHIoMSk7cmV0dXJuIHsgc2V0dXA6IGZ1bmN0aW9uIHNldHVwKCkge1xcbiAgICAgICAgICB1KHRoaXMpIHx8IGEuZGF0YSh0aGlzLCB6LCB7fSk7dmFyIGQgPSBhLmRhdGEodGhpcywgeik7ZFtiXSA9ICEwLCBGW2JdID0gKEZbYl0gfHwgMCkgKyAxLCAxID09PSBGW2JdICYmIE8uYmluZChjLCBwKSwgYSh0aGlzKS5iaW5kKGMsIHYpLCBOICYmIChGLnRvdWNoc3RhcnQgPSAoRi50b3VjaHN0YXJ0IHx8IDApICsgMSwgMSA9PT0gRi50b3VjaHN0YXJ0ICYmIE8uYmluZChcXFwidG91Y2hzdGFydFxcXCIsIHEpLmJpbmQoXFxcInRvdWNoZW5kXFxcIiwgdCkuYmluZChcXFwidG91Y2htb3ZlXFxcIiwgcykuYmluZChcXFwic2Nyb2xsXFxcIiwgcikpO1xcbiAgICAgICAgfSwgdGVhcmRvd246IGZ1bmN0aW9uIHRlYXJkb3duKCkge1xcbiAgICAgICAgICAtLUZbYl0sIEZbYl0gfHwgTy51bmJpbmQoYywgcCksIE4gJiYgKC0tRi50b3VjaHN0YXJ0LCBGLnRvdWNoc3RhcnQgfHwgTy51bmJpbmQoXFxcInRvdWNoc3RhcnRcXFwiLCBxKS51bmJpbmQoXFxcInRvdWNobW92ZVxcXCIsIHMpLnVuYmluZChcXFwidG91Y2hlbmRcXFwiLCB0KS51bmJpbmQoXFxcInNjcm9sbFxcXCIsIHIpKTt2YXIgZCA9IGEodGhpcyksXFxuICAgICAgICAgICAgICBlID0gYS5kYXRhKHRoaXMsIHopO2UgJiYgKGVbYl0gPSAhMSksIGQudW5iaW5kKGMsIHYpLCB1KHRoaXMpIHx8IGQucmVtb3ZlRGF0YSh6KTtcXG4gICAgICAgIH0gfTtcXG4gICAgfXZhciB4LFxcbiAgICAgICAgeSxcXG4gICAgICAgIHogPSBcXFwidmlydHVhbE1vdXNlQmluZGluZ3NcXFwiLFxcbiAgICAgICAgQSA9IFxcXCJ2aXJ0dWFsVG91Y2hJRFxcXCIsXFxuICAgICAgICBCID0gXFxcInZtb3VzZW92ZXIgdm1vdXNlZG93biB2bW91c2Vtb3ZlIHZtb3VzZXVwIHZjbGljayB2bW91c2VvdXQgdm1vdXNlY2FuY2VsXFxcIi5zcGxpdChcXFwiIFxcXCIpLFxcbiAgICAgICAgQyA9IFxcXCJjbGllbnRYIGNsaWVudFkgcGFnZVggcGFnZVkgc2NyZWVuWCBzY3JlZW5ZXFxcIi5zcGxpdChcXFwiIFxcXCIpLFxcbiAgICAgICAgRCA9IGEuZXZlbnQubW91c2VIb29rcyA/IGEuZXZlbnQubW91c2VIb29rcy5wcm9wcyA6IFtdLFxcbiAgICAgICAgRSA9IGEuZXZlbnQucHJvcHMuY29uY2F0KEQpLFxcbiAgICAgICAgRiA9IHt9LFxcbiAgICAgICAgRyA9IDAsXFxuICAgICAgICBIID0gMCxcXG4gICAgICAgIEkgPSAwLFxcbiAgICAgICAgSiA9ICExLFxcbiAgICAgICAgSyA9IFtdLFxcbiAgICAgICAgTCA9ICExLFxcbiAgICAgICAgTSA9ICExLFxcbiAgICAgICAgTiA9IFxcXCJhZGRFdmVudExpc3RlbmVyXFxcIiBpbiBjLFxcbiAgICAgICAgTyA9IGEoYyksXFxuICAgICAgICBQID0gMSxcXG4gICAgICAgIFEgPSAwO2ZvciAoYS52bW91c2UgPSB7IG1vdmVEaXN0YW5jZVRocmVzaG9sZDogMTAsIGNsaWNrRGlzdGFuY2VUaHJlc2hvbGQ6IDEwLCByZXNldFRpbWVyRHVyYXRpb246IDE1MDAgfSwgeSA9IDA7IHkgPCBCLmxlbmd0aDsgeSsrKSB7XFxuICAgICAgYS5ldmVudC5zcGVjaWFsW0JbeV1dID0gdyhCW3ldKTtcXG4gICAgfU4gJiYgYy5hZGRFdmVudExpc3RlbmVyKFxcXCJjbGlja1xcXCIsIGZ1bmN0aW9uIChiKSB7XFxuICAgICAgdmFyIGMsXFxuICAgICAgICAgIGQsXFxuICAgICAgICAgIGUsXFxuICAgICAgICAgIGYsXFxuICAgICAgICAgIGcsXFxuICAgICAgICAgIGgsXFxuICAgICAgICAgIGkgPSBLLmxlbmd0aCxcXG4gICAgICAgICAgaiA9IGIudGFyZ2V0O2lmIChpKSBmb3IgKGMgPSBiLmNsaWVudFgsIGQgPSBiLmNsaWVudFksIHggPSBhLnZtb3VzZS5jbGlja0Rpc3RhbmNlVGhyZXNob2xkLCBlID0gajsgZTspIHtcXG4gICAgICAgIGZvciAoZiA9IDA7IGkgPiBmOyBmKyspIHtcXG4gICAgICAgICAgaWYgKGcgPSBLW2ZdLCBoID0gMCwgZSA9PT0gaiAmJiBNYXRoLmFicyhnLnggLSBjKSA8IHggJiYgTWF0aC5hYnMoZy55IC0gZCkgPCB4IHx8IGEuZGF0YShlLCBBKSA9PT0gZy50b3VjaElEKSByZXR1cm4gYi5wcmV2ZW50RGVmYXVsdCgpLCB2b2lkIGIuc3RvcFByb3BhZ2F0aW9uKCk7XFxuICAgICAgICB9ZSA9IGUucGFyZW50Tm9kZTtcXG4gICAgICB9XFxuICAgIH0sICEwKTtcXG4gIH0oYSwgYiwgYyksIGZ1bmN0aW9uIChhLCBiLCBkKSB7XFxuICAgIGZ1bmN0aW9uIGUoYiwgYywgZSwgZikge1xcbiAgICAgIHZhciBnID0gZS50eXBlO2UudHlwZSA9IGMsIGYgPyBhLmV2ZW50LnRyaWdnZXIoZSwgZCwgYikgOiBhLmV2ZW50LmRpc3BhdGNoLmNhbGwoYiwgZSksIGUudHlwZSA9IGc7XFxuICAgIH12YXIgZiA9IGEoYyksXFxuICAgICAgICBnID0gYS5tb2JpbGUuc3VwcG9ydC50b3VjaCxcXG4gICAgICAgIGggPSBcXFwidG91Y2htb3ZlIHNjcm9sbFxcXCIsXFxuICAgICAgICBpID0gZyA/IFxcXCJ0b3VjaHN0YXJ0XFxcIiA6IFxcXCJtb3VzZWRvd25cXFwiLFxcbiAgICAgICAgaiA9IGcgPyBcXFwidG91Y2hlbmRcXFwiIDogXFxcIm1vdXNldXBcXFwiLFxcbiAgICAgICAgayA9IGcgPyBcXFwidG91Y2htb3ZlXFxcIiA6IFxcXCJtb3VzZW1vdmVcXFwiO2EuZWFjaChcXFwidG91Y2hzdGFydCB0b3VjaG1vdmUgdG91Y2hlbmQgdGFwIHRhcGhvbGQgc3dpcGUgc3dpcGVsZWZ0IHN3aXBlcmlnaHQgc2Nyb2xsc3RhcnQgc2Nyb2xsc3RvcFxcXCIuc3BsaXQoXFxcIiBcXFwiKSwgZnVuY3Rpb24gKGIsIGMpIHtcXG4gICAgICBhLmZuW2NdID0gZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgIHJldHVybiBhID8gdGhpcy5iaW5kKGMsIGEpIDogdGhpcy50cmlnZ2VyKGMpO1xcbiAgICAgIH0sIGEuYXR0ckZuICYmIChhLmF0dHJGbltjXSA9ICEwKTtcXG4gICAgfSksIGEuZXZlbnQuc3BlY2lhbC5zY3JvbGxzdGFydCA9IHsgZW5hYmxlZDogITAsIHNldHVwOiBmdW5jdGlvbiBzZXR1cCgpIHtcXG4gICAgICAgIGZ1bmN0aW9uIGIoYSwgYikge1xcbiAgICAgICAgICBjID0gYiwgZShmLCBjID8gXFxcInNjcm9sbHN0YXJ0XFxcIiA6IFxcXCJzY3JvbGxzdG9wXFxcIiwgYSk7XFxuICAgICAgICB9dmFyIGMsXFxuICAgICAgICAgICAgZCxcXG4gICAgICAgICAgICBmID0gdGhpcyxcXG4gICAgICAgICAgICBnID0gYShmKTtnLmJpbmQoaCwgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgYS5ldmVudC5zcGVjaWFsLnNjcm9sbHN0YXJ0LmVuYWJsZWQgJiYgKGMgfHwgYihlLCAhMCksIGNsZWFyVGltZW91dChkKSwgZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIGIoZSwgITEpO1xcbiAgICAgICAgICB9LCA1MCkpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfSwgdGVhcmRvd246IGZ1bmN0aW9uIHRlYXJkb3duKCkge1xcbiAgICAgICAgYSh0aGlzKS51bmJpbmQoaCk7XFxuICAgICAgfSB9LCBhLmV2ZW50LnNwZWNpYWwudGFwID0geyB0YXBob2xkVGhyZXNob2xkOiA3NTAsIGVtaXRUYXBPblRhcGhvbGQ6ICEwLCBzZXR1cDogZnVuY3Rpb24gc2V0dXAoKSB7XFxuICAgICAgICB2YXIgYiA9IHRoaXMsXFxuICAgICAgICAgICAgYyA9IGEoYiksXFxuICAgICAgICAgICAgZCA9ICExO2MuYmluZChcXFwidm1vdXNlZG93blxcXCIsIGZ1bmN0aW9uIChnKSB7XFxuICAgICAgICAgIGZ1bmN0aW9uIGgoKSB7XFxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGspO1xcbiAgICAgICAgICB9ZnVuY3Rpb24gaSgpIHtcXG4gICAgICAgICAgICBoKCksIGMudW5iaW5kKFxcXCJ2Y2xpY2tcXFwiLCBqKS51bmJpbmQoXFxcInZtb3VzZXVwXFxcIiwgaCksIGYudW5iaW5kKFxcXCJ2bW91c2VjYW5jZWxcXFwiLCBpKTtcXG4gICAgICAgICAgfWZ1bmN0aW9uIGooYSkge1xcbiAgICAgICAgICAgIGkoKSwgZCB8fCBsICE9PSBhLnRhcmdldCA/IGQgJiYgYS5wcmV2ZW50RGVmYXVsdCgpIDogZShiLCBcXFwidGFwXFxcIiwgYSk7XFxuICAgICAgICAgIH1pZiAoZCA9ICExLCBnLndoaWNoICYmIDEgIT09IGcud2hpY2gpIHJldHVybiAhMTt2YXIgayxcXG4gICAgICAgICAgICAgIGwgPSBnLnRhcmdldDtjLmJpbmQoXFxcInZtb3VzZXVwXFxcIiwgaCkuYmluZChcXFwidmNsaWNrXFxcIiwgaiksIGYuYmluZChcXFwidm1vdXNlY2FuY2VsXFxcIiwgaSksIGsgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBhLmV2ZW50LnNwZWNpYWwudGFwLmVtaXRUYXBPblRhcGhvbGQgfHwgKGQgPSAhMCksIGUoYiwgXFxcInRhcGhvbGRcXFwiLCBhLkV2ZW50KFxcXCJ0YXBob2xkXFxcIiwgeyB0YXJnZXQ6IGwgfSkpO1xcbiAgICAgICAgICB9LCBhLmV2ZW50LnNwZWNpYWwudGFwLnRhcGhvbGRUaHJlc2hvbGQpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfSwgdGVhcmRvd246IGZ1bmN0aW9uIHRlYXJkb3duKCkge1xcbiAgICAgICAgYSh0aGlzKS51bmJpbmQoXFxcInZtb3VzZWRvd25cXFwiKS51bmJpbmQoXFxcInZjbGlja1xcXCIpLnVuYmluZChcXFwidm1vdXNldXBcXFwiKSwgZi51bmJpbmQoXFxcInZtb3VzZWNhbmNlbFxcXCIpO1xcbiAgICAgIH0gfSwgYS5ldmVudC5zcGVjaWFsLnN3aXBlID0geyBzY3JvbGxTdXByZXNzaW9uVGhyZXNob2xkOiAzMCwgZHVyYXRpb25UaHJlc2hvbGQ6IDFlMywgaG9yaXpvbnRhbERpc3RhbmNlVGhyZXNob2xkOiAzMCwgdmVydGljYWxEaXN0YW5jZVRocmVzaG9sZDogMzAsIGdldExvY2F0aW9uOiBmdW5jdGlvbiBnZXRMb2NhdGlvbihhKSB7XFxuICAgICAgICB2YXIgYyA9IGIucGFnZVhPZmZzZXQsXFxuICAgICAgICAgICAgZCA9IGIucGFnZVlPZmZzZXQsXFxuICAgICAgICAgICAgZSA9IGEuY2xpZW50WCxcXG4gICAgICAgICAgICBmID0gYS5jbGllbnRZO3JldHVybiAwID09PSBhLnBhZ2VZICYmIE1hdGguZmxvb3IoZikgPiBNYXRoLmZsb29yKGEucGFnZVkpIHx8IDAgPT09IGEucGFnZVggJiYgTWF0aC5mbG9vcihlKSA+IE1hdGguZmxvb3IoYS5wYWdlWCkgPyAoZSAtPSBjLCBmIC09IGQpIDogKGYgPCBhLnBhZ2VZIC0gZCB8fCBlIDwgYS5wYWdlWCAtIGMpICYmIChlID0gYS5wYWdlWCAtIGMsIGYgPSBhLnBhZ2VZIC0gZCksIHsgeDogZSwgeTogZiB9O1xcbiAgICAgIH0sIHN0YXJ0OiBmdW5jdGlvbiBzdGFydChiKSB7XFxuICAgICAgICB2YXIgYyA9IGIub3JpZ2luYWxFdmVudC50b3VjaGVzID8gYi5vcmlnaW5hbEV2ZW50LnRvdWNoZXNbMF0gOiBiLFxcbiAgICAgICAgICAgIGQgPSBhLmV2ZW50LnNwZWNpYWwuc3dpcGUuZ2V0TG9jYXRpb24oYyk7cmV0dXJuIHsgdGltZTogbmV3IERhdGUoKS5nZXRUaW1lKCksIGNvb3JkczogW2QueCwgZC55XSwgb3JpZ2luOiBhKGIudGFyZ2V0KSB9O1xcbiAgICAgIH0sIHN0b3A6IGZ1bmN0aW9uIHN0b3AoYikge1xcbiAgICAgICAgdmFyIGMgPSBiLm9yaWdpbmFsRXZlbnQudG91Y2hlcyA/IGIub3JpZ2luYWxFdmVudC50b3VjaGVzWzBdIDogYixcXG4gICAgICAgICAgICBkID0gYS5ldmVudC5zcGVjaWFsLnN3aXBlLmdldExvY2F0aW9uKGMpO3JldHVybiB7IHRpbWU6IG5ldyBEYXRlKCkuZ2V0VGltZSgpLCBjb29yZHM6IFtkLngsIGQueV0gfTtcXG4gICAgICB9LCBoYW5kbGVTd2lwZTogZnVuY3Rpb24gaGFuZGxlU3dpcGUoYiwgYywgZCwgZikge1xcbiAgICAgICAgaWYgKGMudGltZSAtIGIudGltZSA8IGEuZXZlbnQuc3BlY2lhbC5zd2lwZS5kdXJhdGlvblRocmVzaG9sZCAmJiBNYXRoLmFicyhiLmNvb3Jkc1swXSAtIGMuY29vcmRzWzBdKSA+IGEuZXZlbnQuc3BlY2lhbC5zd2lwZS5ob3Jpem9udGFsRGlzdGFuY2VUaHJlc2hvbGQgJiYgTWF0aC5hYnMoYi5jb29yZHNbMV0gLSBjLmNvb3Jkc1sxXSkgPCBhLmV2ZW50LnNwZWNpYWwuc3dpcGUudmVydGljYWxEaXN0YW5jZVRocmVzaG9sZCkge1xcbiAgICAgICAgICB2YXIgZyA9IGIuY29vcmRzWzBdID4gYy5jb29yZHNbMF0gPyBcXFwic3dpcGVsZWZ0XFxcIiA6IFxcXCJzd2lwZXJpZ2h0XFxcIjtyZXR1cm4gZShkLCBcXFwic3dpcGVcXFwiLCBhLkV2ZW50KFxcXCJzd2lwZVxcXCIsIHsgdGFyZ2V0OiBmLCBzd2lwZXN0YXJ0OiBiLCBzd2lwZXN0b3A6IGMgfSksICEwKSwgZShkLCBnLCBhLkV2ZW50KGcsIHsgdGFyZ2V0OiBmLCBzd2lwZXN0YXJ0OiBiLCBzd2lwZXN0b3A6IGMgfSksICEwKSwgITA7XFxuICAgICAgICB9cmV0dXJuICExO1xcbiAgICAgIH0sIGV2ZW50SW5Qcm9ncmVzczogITEsIHNldHVwOiBmdW5jdGlvbiBzZXR1cCgpIHtcXG4gICAgICAgIHZhciBiLFxcbiAgICAgICAgICAgIGMgPSB0aGlzLFxcbiAgICAgICAgICAgIGQgPSBhKGMpLFxcbiAgICAgICAgICAgIGUgPSB7fTtiID0gYS5kYXRhKHRoaXMsIFxcXCJtb2JpbGUtZXZlbnRzXFxcIiksIGIgfHwgKGIgPSB7IGxlbmd0aDogMCB9LCBhLmRhdGEodGhpcywgXFxcIm1vYmlsZS1ldmVudHNcXFwiLCBiKSksIGIubGVuZ3RoKyssIGIuc3dpcGUgPSBlLCBlLnN0YXJ0ID0gZnVuY3Rpb24gKGIpIHtcXG4gICAgICAgICAgaWYgKCFhLmV2ZW50LnNwZWNpYWwuc3dpcGUuZXZlbnRJblByb2dyZXNzKSB7XFxuICAgICAgICAgICAgYS5ldmVudC5zcGVjaWFsLnN3aXBlLmV2ZW50SW5Qcm9ncmVzcyA9ICEwO3ZhciBkLFxcbiAgICAgICAgICAgICAgICBnID0gYS5ldmVudC5zcGVjaWFsLnN3aXBlLnN0YXJ0KGIpLFxcbiAgICAgICAgICAgICAgICBoID0gYi50YXJnZXQsXFxuICAgICAgICAgICAgICAgIGkgPSAhMTtlLm1vdmUgPSBmdW5jdGlvbiAoYikge1xcbiAgICAgICAgICAgICAgZyAmJiAhYi5pc0RlZmF1bHRQcmV2ZW50ZWQoKSAmJiAoZCA9IGEuZXZlbnQuc3BlY2lhbC5zd2lwZS5zdG9wKGIpLCBpIHx8IChpID0gYS5ldmVudC5zcGVjaWFsLnN3aXBlLmhhbmRsZVN3aXBlKGcsIGQsIGMsIGgpLCBpICYmIChhLmV2ZW50LnNwZWNpYWwuc3dpcGUuZXZlbnRJblByb2dyZXNzID0gITEpKSwgTWF0aC5hYnMoZy5jb29yZHNbMF0gLSBkLmNvb3Jkc1swXSkgPiBhLmV2ZW50LnNwZWNpYWwuc3dpcGUuc2Nyb2xsU3VwcmVzc2lvblRocmVzaG9sZCAmJiBiLnByZXZlbnREZWZhdWx0KCkpO1xcbiAgICAgICAgICAgIH0sIGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgIGkgPSAhMCwgYS5ldmVudC5zcGVjaWFsLnN3aXBlLmV2ZW50SW5Qcm9ncmVzcyA9ICExLCBmLm9mZihrLCBlLm1vdmUpLCBlLm1vdmUgPSBudWxsO1xcbiAgICAgICAgICAgIH0sIGYub24oaywgZS5tb3ZlKS5vbmUoaiwgZS5zdG9wKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSwgZC5vbihpLCBlLnN0YXJ0KTtcXG4gICAgICB9LCB0ZWFyZG93bjogZnVuY3Rpb24gdGVhcmRvd24oKSB7XFxuICAgICAgICB2YXIgYiwgYztiID0gYS5kYXRhKHRoaXMsIFxcXCJtb2JpbGUtZXZlbnRzXFxcIiksIGIgJiYgKGMgPSBiLnN3aXBlLCBkZWxldGUgYi5zd2lwZSwgYi5sZW5ndGgtLSwgMCA9PT0gYi5sZW5ndGggJiYgYS5yZW1vdmVEYXRhKHRoaXMsIFxcXCJtb2JpbGUtZXZlbnRzXFxcIikpLCBjICYmIChjLnN0YXJ0ICYmIGEodGhpcykub2ZmKGksIGMuc3RhcnQpLCBjLm1vdmUgJiYgZi5vZmYoaywgYy5tb3ZlKSwgYy5zdG9wICYmIGYub2ZmKGosIGMuc3RvcCkpO1xcbiAgICAgIH0gfSwgYS5lYWNoKHsgc2Nyb2xsc3RvcDogXFxcInNjcm9sbHN0YXJ0XFxcIiwgdGFwaG9sZDogXFxcInRhcFxcXCIsIHN3aXBlbGVmdDogXFxcInN3aXBlLmxlZnRcXFwiLCBzd2lwZXJpZ2h0OiBcXFwic3dpcGUucmlnaHRcXFwiIH0sIGZ1bmN0aW9uIChiLCBjKSB7XFxuICAgICAgYS5ldmVudC5zcGVjaWFsW2JdID0geyBzZXR1cDogZnVuY3Rpb24gc2V0dXAoKSB7XFxuICAgICAgICAgIGEodGhpcykuYmluZChjLCBhLm5vb3ApO1xcbiAgICAgICAgfSwgdGVhcmRvd246IGZ1bmN0aW9uIHRlYXJkb3duKCkge1xcbiAgICAgICAgICBhKHRoaXMpLnVuYmluZChjKTtcXG4gICAgICAgIH0gfTtcXG4gICAgfSk7XFxuICB9KGEsIHRoaXMpLCBmdW5jdGlvbiAoYSkge1xcbiAgICBhLmV2ZW50LnNwZWNpYWwudGhyb3R0bGVkcmVzaXplID0geyBzZXR1cDogZnVuY3Rpb24gc2V0dXAoKSB7XFxuICAgICAgICBhKHRoaXMpLmJpbmQoXFxcInJlc2l6ZVxcXCIsIGYpO1xcbiAgICAgIH0sIHRlYXJkb3duOiBmdW5jdGlvbiB0ZWFyZG93bigpIHtcXG4gICAgICAgIGEodGhpcykudW5iaW5kKFxcXCJyZXNpemVcXFwiLCBmKTtcXG4gICAgICB9IH07dmFyIGIsXFxuICAgICAgICBjLFxcbiAgICAgICAgZCxcXG4gICAgICAgIGUgPSAyNTAsXFxuICAgICAgICBmID0gZnVuY3Rpb24gZigpIHtcXG4gICAgICBjID0gbmV3IERhdGUoKS5nZXRUaW1lKCksIGQgPSBjIC0gZywgZCA+PSBlID8gKGcgPSBjLCBhKHRoaXMpLnRyaWdnZXIoXFxcInRocm90dGxlZHJlc2l6ZVxcXCIpKSA6IChiICYmIGNsZWFyVGltZW91dChiKSwgYiA9IHNldFRpbWVvdXQoZiwgZSAtIGQpKTtcXG4gICAgfSxcXG4gICAgICAgIGcgPSAwO1xcbiAgfShhKSwgZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgZnVuY3Rpb24gZCgpIHtcXG4gICAgICB2YXIgYSA9IGUoKTthICE9PSBmICYmIChmID0gYSwgbC50cmlnZ2VyKG0pKTtcXG4gICAgfXZhciBlLFxcbiAgICAgICAgZixcXG4gICAgICAgIGcsXFxuICAgICAgICBoLFxcbiAgICAgICAgaSxcXG4gICAgICAgIGosXFxuICAgICAgICBrLFxcbiAgICAgICAgbCA9IGEoYiksXFxuICAgICAgICBtID0gXFxcIm9yaWVudGF0aW9uY2hhbmdlXFxcIixcXG4gICAgICAgIG4gPSB7IDA6ICEwLCAxODA6ICEwIH07YS5zdXBwb3J0Lm9yaWVudGF0aW9uICYmIChpID0gYi5pbm5lcldpZHRoIHx8IGwud2lkdGgoKSwgaiA9IGIuaW5uZXJIZWlnaHQgfHwgbC5oZWlnaHQoKSwgayA9IDUwLCBnID0gaSA+IGogJiYgaSAtIGogPiBrLCBoID0gbltiLm9yaWVudGF0aW9uXSwgKGcgJiYgaCB8fCAhZyAmJiAhaCkgJiYgKG4gPSB7IFxcXCItOTBcXFwiOiAhMCwgOTA6ICEwIH0pKSwgYS5ldmVudC5zcGVjaWFsLm9yaWVudGF0aW9uY2hhbmdlID0gYS5leHRlbmQoe30sIGEuZXZlbnQuc3BlY2lhbC5vcmllbnRhdGlvbmNoYW5nZSwgeyBzZXR1cDogZnVuY3Rpb24gc2V0dXAoKSB7XFxuICAgICAgICByZXR1cm4gYS5zdXBwb3J0Lm9yaWVudGF0aW9uICYmICFhLmV2ZW50LnNwZWNpYWwub3JpZW50YXRpb25jaGFuZ2UuZGlzYWJsZWQgPyAhMSA6IChmID0gZSgpLCB2b2lkIGwuYmluZChcXFwidGhyb3R0bGVkcmVzaXplXFxcIiwgZCkpO1xcbiAgICAgIH0sIHRlYXJkb3duOiBmdW5jdGlvbiB0ZWFyZG93bigpIHtcXG4gICAgICAgIHJldHVybiBhLnN1cHBvcnQub3JpZW50YXRpb24gJiYgIWEuZXZlbnQuc3BlY2lhbC5vcmllbnRhdGlvbmNoYW5nZS5kaXNhYmxlZCA/ICExIDogdm9pZCBsLnVuYmluZChcXFwidGhyb3R0bGVkcmVzaXplXFxcIiwgZCk7XFxuICAgICAgfSwgYWRkOiBmdW5jdGlvbiBhZGQoYSkge1xcbiAgICAgICAgdmFyIGIgPSBhLmhhbmRsZXI7YS5oYW5kbGVyID0gZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgICAgcmV0dXJuIGEub3JpZW50YXRpb24gPSBlKCksIGIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gICAgICAgIH07XFxuICAgICAgfSB9KSwgYS5ldmVudC5zcGVjaWFsLm9yaWVudGF0aW9uY2hhbmdlLm9yaWVudGF0aW9uID0gZSA9IGZ1bmN0aW9uIGUoKSB7XFxuICAgICAgdmFyIGQgPSAhMCxcXG4gICAgICAgICAgZSA9IGMuZG9jdW1lbnRFbGVtZW50O3JldHVybiBkID0gYS5zdXBwb3J0Lm9yaWVudGF0aW9uID8gbltiLm9yaWVudGF0aW9uXSA6IGUgJiYgZS5jbGllbnRXaWR0aCAvIGUuY2xpZW50SGVpZ2h0IDwgMS4xLCBkID8gXFxcInBvcnRyYWl0XFxcIiA6IFxcXCJsYW5kc2NhcGVcXFwiO1xcbiAgICB9LCBhLmZuW21dID0gZnVuY3Rpb24gKGEpIHtcXG4gICAgICByZXR1cm4gYSA/IHRoaXMuYmluZChtLCBhKSA6IHRoaXMudHJpZ2dlcihtKTtcXG4gICAgfSwgYS5hdHRyRm4gJiYgKGEuYXR0ckZuW21dID0gITApO1xcbiAgfShhLCB0aGlzKSwgZnVuY3Rpb24gKGEpIHtcXG4gICAgdmFyIGIgPSBhKFxcXCJoZWFkXFxcIikuY2hpbGRyZW4oXFxcImJhc2VcXFwiKSxcXG4gICAgICAgIGMgPSB7IGVsZW1lbnQ6IGIubGVuZ3RoID8gYiA6IGEoXFxcIjxiYXNlPlxcXCIsIHsgaHJlZjogYS5tb2JpbGUucGF0aC5kb2N1bWVudEJhc2UuaHJlZk5vSGFzaCB9KS5wcmVwZW5kVG8oYShcXFwiaGVhZFxcXCIpKSwgbGlua1NlbGVjdG9yOiBcXFwiW3NyY10sIGxpbmtbaHJlZl0sIGFbcmVsPSdleHRlcm5hbCddLCA6anFtRGF0YShhamF4PSdmYWxzZScpLCBhW3RhcmdldF1cXFwiLCBzZXQ6IGZ1bmN0aW9uIHNldChiKSB7XFxuICAgICAgICBhLm1vYmlsZS5keW5hbWljQmFzZUVuYWJsZWQgJiYgYS5zdXBwb3J0LmR5bmFtaWNCYXNlVGFnICYmIGMuZWxlbWVudC5hdHRyKFxcXCJocmVmXFxcIiwgYS5tb2JpbGUucGF0aC5tYWtlVXJsQWJzb2x1dGUoYiwgYS5tb2JpbGUucGF0aC5kb2N1bWVudEJhc2UpKTtcXG4gICAgICB9LCByZXdyaXRlOiBmdW5jdGlvbiByZXdyaXRlKGIsIGQpIHtcXG4gICAgICAgIHZhciBlID0gYS5tb2JpbGUucGF0aC5nZXQoYik7ZC5maW5kKGMubGlua1NlbGVjdG9yKS5lYWNoKGZ1bmN0aW9uIChiLCBjKSB7XFxuICAgICAgICAgIHZhciBkID0gYShjKS5pcyhcXFwiW2hyZWZdXFxcIikgPyBcXFwiaHJlZlxcXCIgOiBhKGMpLmlzKFxcXCJbc3JjXVxcXCIpID8gXFxcInNyY1xcXCIgOiBcXFwiYWN0aW9uXFxcIixcXG4gICAgICAgICAgICAgIGYgPSBhLm1vYmlsZS5wYXRoLnBhcnNlTG9jYXRpb24oKSxcXG4gICAgICAgICAgICAgIGcgPSBhKGMpLmF0dHIoZCk7ZyA9IGcucmVwbGFjZShmLnByb3RvY29sICsgZi5kb3VibGVTbGFzaCArIGYuaG9zdCArIGYucGF0aG5hbWUsIFxcXCJcXFwiKSwgL14oXFxcXHcrOnwjfFxcXFwvKS8udGVzdChnKSB8fCBhKGMpLmF0dHIoZCwgZSArIGcpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfSwgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0KCkge1xcbiAgICAgICAgYy5lbGVtZW50LmF0dHIoXFxcImhyZWZcXFwiLCBhLm1vYmlsZS5wYXRoLmRvY3VtZW50QmFzZS5ocmVmTm9TZWFyY2gpO1xcbiAgICAgIH0gfTthLm1vYmlsZS5iYXNlID0gYztcXG4gIH0oYSksIGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgIGEubW9iaWxlLndpZGdldHMgPSB7fTt2YXIgYyA9IGEud2lkZ2V0LFxcbiAgICAgICAgZCA9IGEubW9iaWxlLmtlZXBOYXRpdmU7YS53aWRnZXQgPSBmdW5jdGlvbiAoYykge1xcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgZCA9IGMuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcXG4gICAgICAgICAgICBlID0gZC5wcm90b3R5cGUud2lkZ2V0TmFtZTtyZXR1cm4gZC5pbml0U2VsZWN0b3IgPSBkLnByb3RvdHlwZS5pbml0U2VsZWN0b3IgIT09IGIgPyBkLnByb3RvdHlwZS5pbml0U2VsZWN0b3IgOiBcXFwiOmpxbURhdGEocm9sZT0nXFxcIiArIGUgKyBcXFwiJylcXFwiLCBhLm1vYmlsZS53aWRnZXRzW2VdID0gZCwgZDtcXG4gICAgICB9O1xcbiAgICB9KGEud2lkZ2V0KSwgYS5leHRlbmQoYS53aWRnZXQsIGMpLCBhLm1vYmlsZS5kb2N1bWVudC5vbihcXFwiY3JlYXRlXFxcIiwgZnVuY3Rpb24gKGIpIHtcXG4gICAgICBhKGIudGFyZ2V0KS5lbmhhbmNlV2l0aGluKCk7XFxuICAgIH0pLCBhLndpZGdldChcXFwibW9iaWxlLnBhZ2VcXFwiLCB7IG9wdGlvbnM6IHsgdGhlbWU6IFxcXCJhXFxcIiwgZG9tQ2FjaGU6ICExLCBrZWVwTmF0aXZlRGVmYXVsdDogYS5tb2JpbGUua2VlcE5hdGl2ZSwgY29udGVudFRoZW1lOiBudWxsLCBlbmhhbmNlZDogITEgfSwgX2NyZWF0ZVdpZGdldDogZnVuY3Rpb24gX2NyZWF0ZVdpZGdldCgpIHtcXG4gICAgICAgIGEuV2lkZ2V0LnByb3RvdHlwZS5fY3JlYXRlV2lkZ2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHRoaXMuX3RyaWdnZXIoXFxcImluaXRcXFwiKTtcXG4gICAgICB9LCBfY3JlYXRlOiBmdW5jdGlvbiBfY3JlYXRlKCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyaWdnZXIoXFxcImJlZm9yZWNyZWF0ZVxcXCIpID09PSAhMSA/ICExIDogKHRoaXMub3B0aW9ucy5lbmhhbmNlZCB8fCB0aGlzLl9lbmhhbmNlKCksIHRoaXMuX29uKHRoaXMuZWxlbWVudCwgeyBwYWdlYmVmb3JlaGlkZTogXFxcInJlbW92ZUNvbnRhaW5lckJhY2tncm91bmRcXFwiLCBwYWdlYmVmb3Jlc2hvdzogXFxcIl9oYW5kbGVQYWdlQmVmb3JlU2hvd1xcXCIgfSksIHRoaXMuZWxlbWVudC5lbmhhbmNlV2l0aGluKCksIHZvaWQgKFxcXCJkaWFsb2dcXFwiID09PSBhLm1vYmlsZS5nZXRBdHRyaWJ1dGUodGhpcy5lbGVtZW50WzBdLCBcXFwicm9sZVxcXCIpICYmIGEubW9iaWxlLmRpYWxvZyAmJiB0aGlzLmVsZW1lbnQuZGlhbG9nKCkpKTtcXG4gICAgICB9LCBfZW5oYW5jZTogZnVuY3Rpb24gX2VuaGFuY2UoKSB7XFxuICAgICAgICB2YXIgYyA9IFxcXCJkYXRhLVxcXCIgKyBhLm1vYmlsZS5ucyxcXG4gICAgICAgICAgICBkID0gdGhpczt0aGlzLm9wdGlvbnMucm9sZSAmJiB0aGlzLmVsZW1lbnQuYXR0cihcXFwiZGF0YS1cXFwiICsgYS5tb2JpbGUubnMgKyBcXFwicm9sZVxcXCIsIHRoaXMub3B0aW9ucy5yb2xlKSwgdGhpcy5lbGVtZW50LmF0dHIoXFxcInRhYmluZGV4XFxcIiwgXFxcIjBcXFwiKS5hZGRDbGFzcyhcXFwidWktcGFnZSB1aS1wYWdlLXRoZW1lLVxcXCIgKyB0aGlzLm9wdGlvbnMudGhlbWUpLCB0aGlzLmVsZW1lbnQuZmluZChcXFwiW1xcXCIgKyBjICsgXFxcInJvbGU9J2NvbnRlbnQnXVxcXCIpLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICB2YXIgZSA9IGEodGhpcyksXFxuICAgICAgICAgICAgICBmID0gdGhpcy5nZXRBdHRyaWJ1dGUoYyArIFxcXCJ0aGVtZVxcXCIpIHx8IGI7ZC5vcHRpb25zLmNvbnRlbnRUaGVtZSA9IGYgfHwgZC5vcHRpb25zLmNvbnRlbnRUaGVtZSB8fCBkLm9wdGlvbnMuZGlhbG9nICYmIGQub3B0aW9ucy50aGVtZSB8fCBcXFwiZGlhbG9nXFxcIiA9PT0gZC5lbGVtZW50LmpxbURhdGEoXFxcInJvbGVcXFwiKSAmJiBkLm9wdGlvbnMudGhlbWUsIGUuYWRkQ2xhc3MoXFxcInVpLWNvbnRlbnRcXFwiKSwgZC5vcHRpb25zLmNvbnRlbnRUaGVtZSAmJiBlLmFkZENsYXNzKFxcXCJ1aS1ib2R5LVxcXCIgKyBkLm9wdGlvbnMuY29udGVudFRoZW1lKSwgZS5hdHRyKFxcXCJyb2xlXFxcIiwgXFxcIm1haW5cXFwiKS5hZGRDbGFzcyhcXFwidWktY29udGVudFxcXCIpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfSwgYmluZFJlbW92ZTogZnVuY3Rpb24gYmluZFJlbW92ZShiKSB7XFxuICAgICAgICB2YXIgYyA9IHRoaXMuZWxlbWVudDshYy5kYXRhKFxcXCJtb2JpbGUtcGFnZVxcXCIpLm9wdGlvbnMuZG9tQ2FjaGUgJiYgYy5pcyhcXFwiOmpxbURhdGEoZXh0ZXJuYWwtcGFnZT0ndHJ1ZScpXFxcIikgJiYgYy5iaW5kKFxcXCJwYWdlaGlkZS5yZW1vdmVcXFwiLCBiIHx8IGZ1bmN0aW9uIChiLCBjKSB7XFxuICAgICAgICAgIGlmICghYy5zYW1lUGFnZSkge1xcbiAgICAgICAgICAgIHZhciBkID0gYSh0aGlzKSxcXG4gICAgICAgICAgICAgICAgZSA9IG5ldyBhLkV2ZW50KFxcXCJwYWdlcmVtb3ZlXFxcIik7ZC50cmlnZ2VyKGUpLCBlLmlzRGVmYXVsdFByZXZlbnRlZCgpIHx8IGQucmVtb3ZlV2l0aERlcGVuZGVudHMoKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgICAgfSwgX3NldE9wdGlvbnM6IGZ1bmN0aW9uIF9zZXRPcHRpb25zKGMpIHtcXG4gICAgICAgIGMudGhlbWUgIT09IGIgJiYgdGhpcy5lbGVtZW50LnJlbW92ZUNsYXNzKFxcXCJ1aS1wYWdlLXRoZW1lLVxcXCIgKyB0aGlzLm9wdGlvbnMudGhlbWUpLmFkZENsYXNzKFxcXCJ1aS1wYWdlLXRoZW1lLVxcXCIgKyBjLnRoZW1lKSwgYy5jb250ZW50VGhlbWUgIT09IGIgJiYgdGhpcy5lbGVtZW50LmZpbmQoXFxcIltkYXRhLVxcXCIgKyBhLm1vYmlsZS5ucyArIFxcXCI9J2NvbnRlbnQnXVxcXCIpLnJlbW92ZUNsYXNzKFxcXCJ1aS1ib2R5LVxcXCIgKyB0aGlzLm9wdGlvbnMuY29udGVudFRoZW1lKS5hZGRDbGFzcyhcXFwidWktYm9keS1cXFwiICsgYy5jb250ZW50VGhlbWUpO1xcbiAgICAgIH0sIF9oYW5kbGVQYWdlQmVmb3JlU2hvdzogZnVuY3Rpb24gX2hhbmRsZVBhZ2VCZWZvcmVTaG93KCkge1xcbiAgICAgICAgdGhpcy5zZXRDb250YWluZXJCYWNrZ3JvdW5kKCk7XFxuICAgICAgfSwgcmVtb3ZlQ29udGFpbmVyQmFja2dyb3VuZDogZnVuY3Rpb24gcmVtb3ZlQ29udGFpbmVyQmFja2dyb3VuZCgpIHtcXG4gICAgICAgIHRoaXMuZWxlbWVudC5jbG9zZXN0KFxcXCI6bW9iaWxlLXBhZ2Vjb250YWluZXJcXFwiKS5wYWdlY29udGFpbmVyKHsgdGhlbWU6IFxcXCJub25lXFxcIiB9KTtcXG4gICAgICB9LCBzZXRDb250YWluZXJCYWNrZ3JvdW5kOiBmdW5jdGlvbiBzZXRDb250YWluZXJCYWNrZ3JvdW5kKGEpIHtcXG4gICAgICAgIHRoaXMuZWxlbWVudC5wYXJlbnQoKS5wYWdlY29udGFpbmVyKHsgdGhlbWU6IGEgfHwgdGhpcy5vcHRpb25zLnRoZW1lIH0pO1xcbiAgICAgIH0sIGtlZXBOYXRpdmVTZWxlY3RvcjogZnVuY3Rpb24ga2VlcE5hdGl2ZVNlbGVjdG9yKCkge1xcbiAgICAgICAgdmFyIGIgPSB0aGlzLm9wdGlvbnMsXFxuICAgICAgICAgICAgYyA9IGEudHJpbShiLmtlZXBOYXRpdmUgfHwgXFxcIlxcXCIpLFxcbiAgICAgICAgICAgIGUgPSBhLnRyaW0oYS5tb2JpbGUua2VlcE5hdGl2ZSksXFxuICAgICAgICAgICAgZiA9IGEudHJpbShiLmtlZXBOYXRpdmVEZWZhdWx0KSxcXG4gICAgICAgICAgICBnID0gZCA9PT0gZSA/IFxcXCJcXFwiIDogZSxcXG4gICAgICAgICAgICBoID0gXFxcIlxcXCIgPT09IGcgPyBmIDogXFxcIlxcXCI7cmV0dXJuIChjID8gW2NdIDogW10pLmNvbmNhdChnID8gW2ddIDogW10pLmNvbmNhdChoID8gW2hdIDogW10pLmpvaW4oXFxcIiwgXFxcIik7XFxuICAgICAgfSB9KTtcXG4gIH0oYSksIGZ1bmN0aW9uIChhLCBkKSB7XFxuICAgIGEud2lkZ2V0KFxcXCJtb2JpbGUucGFnZWNvbnRhaW5lclxcXCIsIHsgb3B0aW9uczogeyB0aGVtZTogXFxcImFcXFwiIH0sIGluaXRTZWxlY3RvcjogITEsIF9jcmVhdGU6IGZ1bmN0aW9uIF9jcmVhdGUoKSB7XFxuICAgICAgICB0aGlzLl90cmlnZ2VyKFxcXCJiZWZvcmVjcmVhdGVcXFwiKSwgdGhpcy5zZXRMYXN0U2Nyb2xsRW5hYmxlZCA9ICEwLCB0aGlzLl9vbih0aGlzLndpbmRvdywgeyBuYXZpZ2F0ZTogXFxcIl9kaXNhYmxlUmVjb3JkU2Nyb2xsXFxcIiwgc2Nyb2xsc3RvcDogXFxcIl9kZWxheWVkUmVjb3JkU2Nyb2xsXFxcIiB9KSwgdGhpcy5fb24odGhpcy53aW5kb3csIHsgbmF2aWdhdGU6IFxcXCJfZmlsdGVyTmF2aWdhdGVFdmVudHNcXFwiIH0pLCB0aGlzLl9vbih7IHBhZ2VjaGFuZ2U6IFxcXCJfYWZ0ZXJDb250ZW50Q2hhbmdlXFxcIiB9KSwgdGhpcy53aW5kb3cub25lKFxcXCJuYXZpZ2F0ZVxcXCIsIGEucHJveHkoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICB0aGlzLnNldExhc3RTY3JvbGxFbmFibGVkID0gITA7XFxuICAgICAgICB9LCB0aGlzKSk7XFxuICAgICAgfSwgX3NldE9wdGlvbnM6IGZ1bmN0aW9uIF9zZXRPcHRpb25zKGEpIHtcXG4gICAgICAgIGEudGhlbWUgIT09IGQgJiYgXFxcIm5vbmVcXFwiICE9PSBhLnRoZW1lID8gdGhpcy5lbGVtZW50LnJlbW92ZUNsYXNzKFxcXCJ1aS1vdmVybGF5LVxcXCIgKyB0aGlzLm9wdGlvbnMudGhlbWUpLmFkZENsYXNzKFxcXCJ1aS1vdmVybGF5LVxcXCIgKyBhLnRoZW1lKSA6IGEudGhlbWUgIT09IGQgJiYgdGhpcy5lbGVtZW50LnJlbW92ZUNsYXNzKFxcXCJ1aS1vdmVybGF5LVxcXCIgKyB0aGlzLm9wdGlvbnMudGhlbWUpLCB0aGlzLl9zdXBlcihhKTtcXG4gICAgICB9LCBfZGlzYWJsZVJlY29yZFNjcm9sbDogZnVuY3Rpb24gX2Rpc2FibGVSZWNvcmRTY3JvbGwoKSB7XFxuICAgICAgICB0aGlzLnNldExhc3RTY3JvbGxFbmFibGVkID0gITE7XFxuICAgICAgfSwgX2VuYWJsZVJlY29yZFNjcm9sbDogZnVuY3Rpb24gX2VuYWJsZVJlY29yZFNjcm9sbCgpIHtcXG4gICAgICAgIHRoaXMuc2V0TGFzdFNjcm9sbEVuYWJsZWQgPSAhMDtcXG4gICAgICB9LCBfYWZ0ZXJDb250ZW50Q2hhbmdlOiBmdW5jdGlvbiBfYWZ0ZXJDb250ZW50Q2hhbmdlKCkge1xcbiAgICAgICAgdGhpcy5zZXRMYXN0U2Nyb2xsRW5hYmxlZCA9ICEwLCB0aGlzLl9vZmYodGhpcy53aW5kb3csIFxcXCJzY3JvbGxzdG9wXFxcIiksIHRoaXMuX29uKHRoaXMud2luZG93LCB7IHNjcm9sbHN0b3A6IFxcXCJfZGVsYXllZFJlY29yZFNjcm9sbFxcXCIgfSk7XFxuICAgICAgfSwgX3JlY29yZFNjcm9sbDogZnVuY3Rpb24gX3JlY29yZFNjcm9sbCgpIHtcXG4gICAgICAgIGlmICh0aGlzLnNldExhc3RTY3JvbGxFbmFibGVkKSB7XFxuICAgICAgICAgIHZhciBhLFxcbiAgICAgICAgICAgICAgYixcXG4gICAgICAgICAgICAgIGMsXFxuICAgICAgICAgICAgICBkID0gdGhpcy5fZ2V0QWN0aXZlSGlzdG9yeSgpO2QgJiYgKGEgPSB0aGlzLl9nZXRTY3JvbGwoKSwgYiA9IHRoaXMuX2dldE1pblNjcm9sbCgpLCBjID0gdGhpcy5fZ2V0RGVmYXVsdFNjcm9sbCgpLCBkLmxhc3RTY3JvbGwgPSBiID4gYSA/IGMgOiBhKTtcXG4gICAgICAgIH1cXG4gICAgICB9LCBfZGVsYXllZFJlY29yZFNjcm9sbDogZnVuY3Rpb24gX2RlbGF5ZWRSZWNvcmRTY3JvbGwoKSB7XFxuICAgICAgICBzZXRUaW1lb3V0KGEucHJveHkodGhpcywgXFxcIl9yZWNvcmRTY3JvbGxcXFwiKSwgMTAwKTtcXG4gICAgICB9LCBfZ2V0U2Nyb2xsOiBmdW5jdGlvbiBfZ2V0U2Nyb2xsKCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMud2luZG93LnNjcm9sbFRvcCgpO1xcbiAgICAgIH0sIF9nZXRNaW5TY3JvbGw6IGZ1bmN0aW9uIF9nZXRNaW5TY3JvbGwoKSB7XFxuICAgICAgICByZXR1cm4gYS5tb2JpbGUubWluU2Nyb2xsQmFjaztcXG4gICAgICB9LCBfZ2V0RGVmYXVsdFNjcm9sbDogZnVuY3Rpb24gX2dldERlZmF1bHRTY3JvbGwoKSB7XFxuICAgICAgICByZXR1cm4gYS5tb2JpbGUuZGVmYXVsdEhvbWVTY3JvbGw7XFxuICAgICAgfSwgX2ZpbHRlck5hdmlnYXRlRXZlbnRzOiBmdW5jdGlvbiBfZmlsdGVyTmF2aWdhdGVFdmVudHMoYiwgYykge1xcbiAgICAgICAgdmFyIGQ7Yi5vcmlnaW5hbEV2ZW50ICYmIGIub3JpZ2luYWxFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSB8fCAoZCA9IGIub3JpZ2luYWxFdmVudC50eXBlLmluZGV4T2YoXFxcImhhc2hjaGFuZ2VcXFwiKSA+IC0xID8gYy5zdGF0ZS5oYXNoIDogYy5zdGF0ZS51cmwsIGQgfHwgKGQgPSB0aGlzLl9nZXRIYXNoKCkpLCBkICYmIFxcXCIjXFxcIiAhPT0gZCAmJiAwICE9PSBkLmluZGV4T2YoXFxcIiNcXFwiICsgYS5tb2JpbGUucGF0aC51aVN0YXRlS2V5KSB8fCAoZCA9IGxvY2F0aW9uLmhyZWYpLCB0aGlzLl9oYW5kbGVOYXZpZ2F0ZShkLCBjLnN0YXRlKSk7XFxuICAgICAgfSwgX2dldEhhc2g6IGZ1bmN0aW9uIF9nZXRIYXNoKCkge1xcbiAgICAgICAgcmV0dXJuIGEubW9iaWxlLnBhdGgucGFyc2VMb2NhdGlvbigpLmhhc2g7XFxuICAgICAgfSwgZ2V0QWN0aXZlUGFnZTogZnVuY3Rpb24gZ2V0QWN0aXZlUGFnZSgpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZVBhZ2U7XFxuICAgICAgfSwgX2dldEluaXRpYWxDb250ZW50OiBmdW5jdGlvbiBfZ2V0SW5pdGlhbENvbnRlbnQoKSB7XFxuICAgICAgICByZXR1cm4gYS5tb2JpbGUuZmlyc3RQYWdlO1xcbiAgICAgIH0sIF9nZXRIaXN0b3J5OiBmdW5jdGlvbiBfZ2V0SGlzdG9yeSgpIHtcXG4gICAgICAgIHJldHVybiBhLm1vYmlsZS5uYXZpZ2F0ZS5oaXN0b3J5O1xcbiAgICAgIH0sIF9nZXRBY3RpdmVIaXN0b3J5OiBmdW5jdGlvbiBfZ2V0QWN0aXZlSGlzdG9yeSgpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRIaXN0b3J5KCkuZ2V0QWN0aXZlKCk7XFxuICAgICAgfSwgX2dldERvY3VtZW50QmFzZTogZnVuY3Rpb24gX2dldERvY3VtZW50QmFzZSgpIHtcXG4gICAgICAgIHJldHVybiBhLm1vYmlsZS5wYXRoLmRvY3VtZW50QmFzZTtcXG4gICAgICB9LCBiYWNrOiBmdW5jdGlvbiBiYWNrKCkge1xcbiAgICAgICAgdGhpcy5nbygtMSk7XFxuICAgICAgfSwgZm9yd2FyZDogZnVuY3Rpb24gZm9yd2FyZCgpIHtcXG4gICAgICAgIHRoaXMuZ28oMSk7XFxuICAgICAgfSwgZ286IGZ1bmN0aW9uIGdvKGMpIHtcXG4gICAgICAgIGlmIChhLm1vYmlsZS5oYXNoTGlzdGVuaW5nRW5hYmxlZCkgYi5oaXN0b3J5LmdvKGMpO2Vsc2Uge1xcbiAgICAgICAgICB2YXIgZCA9IGEubW9iaWxlLm5hdmlnYXRlLmhpc3RvcnkuYWN0aXZlSW5kZXgsXFxuICAgICAgICAgICAgICBlID0gZCArIHBhcnNlSW50KGMsIDEwKSxcXG4gICAgICAgICAgICAgIGYgPSBhLm1vYmlsZS5uYXZpZ2F0ZS5oaXN0b3J5LnN0YWNrW2VdLnVybCxcXG4gICAgICAgICAgICAgIGcgPSBjID49IDEgPyBcXFwiZm9yd2FyZFxcXCIgOiBcXFwiYmFja1xcXCI7YS5tb2JpbGUubmF2aWdhdGUuaGlzdG9yeS5hY3RpdmVJbmRleCA9IGUsIGEubW9iaWxlLm5hdmlnYXRlLmhpc3RvcnkucHJldmlvdXNJbmRleCA9IGQsIHRoaXMuY2hhbmdlKGYsIHsgZGlyZWN0aW9uOiBnLCBjaGFuZ2VIYXNoOiAhMSwgZnJvbUhhc2hDaGFuZ2U6ICEwIH0pO1xcbiAgICAgICAgfVxcbiAgICAgIH0sIF9oYW5kbGVEZXN0aW5hdGlvbjogZnVuY3Rpb24gX2hhbmRsZURlc3RpbmF0aW9uKGIpIHtcXG4gICAgICAgIHZhciBjO3JldHVybiBcXFwic3RyaW5nXFxcIiA9PT0gYS50eXBlKGIpICYmIChiID0gYS5tb2JpbGUucGF0aC5zdHJpcEhhc2goYikpLCBiICYmIChjID0gdGhpcy5fZ2V0SGlzdG9yeSgpLCBiID0gYS5tb2JpbGUucGF0aC5pc1BhdGgoYikgPyBiIDogYS5tb2JpbGUucGF0aC5tYWtlVXJsQWJzb2x1dGUoXFxcIiNcXFwiICsgYiwgdGhpcy5fZ2V0RG9jdW1lbnRCYXNlKCkpKSwgYiB8fCB0aGlzLl9nZXRJbml0aWFsQ29udGVudCgpO1xcbiAgICAgIH0sIF90cmFuc2l0aW9uRnJvbUhpc3Rvcnk6IGZ1bmN0aW9uIF90cmFuc2l0aW9uRnJvbUhpc3RvcnkoYSwgYikge1xcbiAgICAgICAgdmFyIGMgPSB0aGlzLl9nZXRIaXN0b3J5KCksXFxuICAgICAgICAgICAgZCA9IFxcXCJiYWNrXFxcIiA9PT0gYSA/IGMuZ2V0TGFzdCgpIDogYy5nZXRBY3RpdmUoKTtyZXR1cm4gZCAmJiBkLnRyYW5zaXRpb24gfHwgYjtcXG4gICAgICB9LCBfaGFuZGxlRGlhbG9nOiBmdW5jdGlvbiBfaGFuZGxlRGlhbG9nKGIsIGMpIHtcXG4gICAgICAgIHZhciBkLFxcbiAgICAgICAgICAgIGUsXFxuICAgICAgICAgICAgZiA9IHRoaXMuZ2V0QWN0aXZlUGFnZSgpO3JldHVybiBmICYmICFmLmRhdGEoXFxcIm1vYmlsZS1kaWFsb2dcXFwiKSA/IChcXFwiYmFja1xcXCIgPT09IGMuZGlyZWN0aW9uID8gdGhpcy5iYWNrKCkgOiB0aGlzLmZvcndhcmQoKSwgITEpIDogKGQgPSBjLnBhZ2VVcmwsIGUgPSB0aGlzLl9nZXRBY3RpdmVIaXN0b3J5KCksIGEuZXh0ZW5kKGIsIHsgcm9sZTogZS5yb2xlLCB0cmFuc2l0aW9uOiB0aGlzLl90cmFuc2l0aW9uRnJvbUhpc3RvcnkoYy5kaXJlY3Rpb24sIGIudHJhbnNpdGlvbiksIHJldmVyc2U6IFxcXCJiYWNrXFxcIiA9PT0gYy5kaXJlY3Rpb24gfSksIGQpO1xcbiAgICAgIH0sIF9oYW5kbGVOYXZpZ2F0ZTogZnVuY3Rpb24gX2hhbmRsZU5hdmlnYXRlKGIsIGMpIHtcXG4gICAgICAgIHZhciBkID0gYS5tb2JpbGUucGF0aC5zdHJpcEhhc2goYiksXFxuICAgICAgICAgICAgZSA9IHRoaXMuX2dldEhpc3RvcnkoKSxcXG4gICAgICAgICAgICBmID0gMCA9PT0gZS5zdGFjay5sZW5ndGggPyBcXFwibm9uZVxcXCIgOiB0aGlzLl90cmFuc2l0aW9uRnJvbUhpc3RvcnkoYy5kaXJlY3Rpb24pLFxcbiAgICAgICAgICAgIGcgPSB7IGNoYW5nZUhhc2g6ICExLCBmcm9tSGFzaENoYW5nZTogITAsIHJldmVyc2U6IFxcXCJiYWNrXFxcIiA9PT0gYy5kaXJlY3Rpb24gfTthLmV4dGVuZChnLCBjLCB7IHRyYW5zaXRpb246IGYgfSksIGUuYWN0aXZlSW5kZXggPiAwICYmIGQuaW5kZXhPZihhLm1vYmlsZS5kaWFsb2dIYXNoS2V5KSA+IC0xICYmIChkID0gdGhpcy5faGFuZGxlRGlhbG9nKGcsIGMpLCBkID09PSAhMSkgfHwgdGhpcy5fY2hhbmdlQ29udGVudCh0aGlzLl9oYW5kbGVEZXN0aW5hdGlvbihkKSwgZyk7XFxuICAgICAgfSwgX2NoYW5nZUNvbnRlbnQ6IGZ1bmN0aW9uIF9jaGFuZ2VDb250ZW50KGIsIGMpIHtcXG4gICAgICAgIGEubW9iaWxlLmNoYW5nZVBhZ2UoYiwgYyk7XFxuICAgICAgfSwgX2dldEJhc2U6IGZ1bmN0aW9uIF9nZXRCYXNlKCkge1xcbiAgICAgICAgcmV0dXJuIGEubW9iaWxlLmJhc2U7XFxuICAgICAgfSwgX2dldE5zOiBmdW5jdGlvbiBfZ2V0TnMoKSB7XFxuICAgICAgICByZXR1cm4gYS5tb2JpbGUubnM7XFxuICAgICAgfSwgX2VuaGFuY2U6IGZ1bmN0aW9uIF9lbmhhbmNlKGEsIGIpIHtcXG4gICAgICAgIHJldHVybiBhLnBhZ2UoeyByb2xlOiBiIH0pO1xcbiAgICAgIH0sIF9pbmNsdWRlOiBmdW5jdGlvbiBfaW5jbHVkZShhLCBiKSB7XFxuICAgICAgICBhLmFwcGVuZFRvKHRoaXMuZWxlbWVudCksIHRoaXMuX2VuaGFuY2UoYSwgYi5yb2xlKSwgYS5wYWdlKFxcXCJiaW5kUmVtb3ZlXFxcIik7XFxuICAgICAgfSwgX2ZpbmQ6IGZ1bmN0aW9uIF9maW5kKGIpIHtcXG4gICAgICAgIHZhciBjLFxcbiAgICAgICAgICAgIGQgPSB0aGlzLl9jcmVhdGVGaWxlVXJsKGIpLFxcbiAgICAgICAgICAgIGUgPSB0aGlzLl9jcmVhdGVEYXRhVXJsKGIpLFxcbiAgICAgICAgICAgIGYgPSB0aGlzLl9nZXRJbml0aWFsQ29udGVudCgpO3JldHVybiBjID0gdGhpcy5lbGVtZW50LmNoaWxkcmVuKFxcXCJbZGF0YS1cXFwiICsgdGhpcy5fZ2V0TnMoKSArIFxcXCJ1cmw9J1xcXCIgKyBhLm1vYmlsZS5wYXRoLmhhc2hUb1NlbGVjdG9yKGUpICsgXFxcIiddXFxcIiksIDAgPT09IGMubGVuZ3RoICYmIGUgJiYgIWEubW9iaWxlLnBhdGguaXNQYXRoKGUpICYmIChjID0gdGhpcy5lbGVtZW50LmNoaWxkcmVuKGEubW9iaWxlLnBhdGguaGFzaFRvU2VsZWN0b3IoXFxcIiNcXFwiICsgZSkpLmF0dHIoXFxcImRhdGEtXFxcIiArIHRoaXMuX2dldE5zKCkgKyBcXFwidXJsXFxcIiwgZSkuanFtRGF0YShcXFwidXJsXFxcIiwgZSkpLCAwID09PSBjLmxlbmd0aCAmJiBhLm1vYmlsZS5wYXRoLmlzRmlyc3RQYWdlVXJsKGQpICYmIGYgJiYgZi5wYXJlbnQoKS5sZW5ndGggJiYgKGMgPSBhKGYpKSwgYztcXG4gICAgICB9LCBfZ2V0TG9hZGVyOiBmdW5jdGlvbiBfZ2V0TG9hZGVyKCkge1xcbiAgICAgICAgcmV0dXJuIGEubW9iaWxlLmxvYWRpbmcoKTtcXG4gICAgICB9LCBfc2hvd0xvYWRpbmc6IGZ1bmN0aW9uIF9zaG93TG9hZGluZyhiLCBjLCBkLCBlKSB7XFxuICAgICAgICB0aGlzLl9sb2FkTXNnIHx8ICh0aGlzLl9sb2FkTXNnID0gc2V0VGltZW91dChhLnByb3h5KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgdGhpcy5fZ2V0TG9hZGVyKCkubG9hZGVyKFxcXCJzaG93XFxcIiwgYywgZCwgZSksIHRoaXMuX2xvYWRNc2cgPSAwO1xcbiAgICAgICAgfSwgdGhpcyksIGIpKTtcXG4gICAgICB9LCBfaGlkZUxvYWRpbmc6IGZ1bmN0aW9uIF9oaWRlTG9hZGluZygpIHtcXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9sb2FkTXNnKSwgdGhpcy5fbG9hZE1zZyA9IDAsIHRoaXMuX2dldExvYWRlcigpLmxvYWRlcihcXFwiaGlkZVxcXCIpO1xcbiAgICAgIH0sIF9zaG93RXJyb3I6IGZ1bmN0aW9uIF9zaG93RXJyb3IoKSB7XFxuICAgICAgICB0aGlzLl9oaWRlTG9hZGluZygpLCB0aGlzLl9zaG93TG9hZGluZygwLCBhLm1vYmlsZS5wYWdlTG9hZEVycm9yTWVzc2FnZVRoZW1lLCBhLm1vYmlsZS5wYWdlTG9hZEVycm9yTWVzc2FnZSwgITApLCBzZXRUaW1lb3V0KGEucHJveHkodGhpcywgXFxcIl9oaWRlTG9hZGluZ1xcXCIpLCAxNTAwKTtcXG4gICAgICB9LCBfcGFyc2U6IGZ1bmN0aW9uIF9wYXJzZShiLCBjKSB7XFxuICAgICAgICB2YXIgZCxcXG4gICAgICAgICAgICBlID0gYShcXFwiPGRpdj48L2Rpdj5cXFwiKTtyZXR1cm4gZS5nZXQoMCkuaW5uZXJIVE1MID0gYiwgZCA9IGUuZmluZChcXFwiOmpxbURhdGEocm9sZT0ncGFnZScpLCA6anFtRGF0YShyb2xlPSdkaWFsb2cnKVxcXCIpLmZpcnN0KCksIGQubGVuZ3RoIHx8IChkID0gYShcXFwiPGRpdiBkYXRhLVxcXCIgKyB0aGlzLl9nZXROcygpICsgXFxcInJvbGU9J3BhZ2UnPlxcXCIgKyAoYi5zcGxpdCgvPFxcXFwvP2JvZHlbXj5dKj4vZ2ltKVsxXSB8fCBcXFwiXFxcIikgKyBcXFwiPC9kaXY+XFxcIikpLCBkLmF0dHIoXFxcImRhdGEtXFxcIiArIHRoaXMuX2dldE5zKCkgKyBcXFwidXJsXFxcIiwgdGhpcy5fY3JlYXRlRGF0YVVybChjKSkuYXR0cihcXFwiZGF0YS1cXFwiICsgdGhpcy5fZ2V0TnMoKSArIFxcXCJleHRlcm5hbC1wYWdlXFxcIiwgITApLCBkO1xcbiAgICAgIH0sIF9zZXRMb2FkZWRUaXRsZTogZnVuY3Rpb24gX3NldExvYWRlZFRpdGxlKGIsIGMpIHtcXG4gICAgICAgIHZhciBkID0gYy5tYXRjaCgvPHRpdGxlW14+XSo+KFtePF0qKS8pICYmIFJlZ0V4cC4kMTtkICYmICFiLmpxbURhdGEoXFxcInRpdGxlXFxcIikgJiYgKGQgPSBhKFxcXCI8ZGl2PlxcXCIgKyBkICsgXFxcIjwvZGl2PlxcXCIpLnRleHQoKSwgYi5qcW1EYXRhKFxcXCJ0aXRsZVxcXCIsIGQpKTtcXG4gICAgICB9LCBfaXNSZXdyaXRhYmxlQmFzZVRhZzogZnVuY3Rpb24gX2lzUmV3cml0YWJsZUJhc2VUYWcoKSB7XFxuICAgICAgICByZXR1cm4gYS5tb2JpbGUuZHluYW1pY0Jhc2VFbmFibGVkICYmICFhLnN1cHBvcnQuZHluYW1pY0Jhc2VUYWc7XFxuICAgICAgfSwgX2NyZWF0ZURhdGFVcmw6IGZ1bmN0aW9uIF9jcmVhdGVEYXRhVXJsKGIpIHtcXG4gICAgICAgIHJldHVybiBhLm1vYmlsZS5wYXRoLmNvbnZlcnRVcmxUb0RhdGFVcmwoYik7XFxuICAgICAgfSwgX2NyZWF0ZUZpbGVVcmw6IGZ1bmN0aW9uIF9jcmVhdGVGaWxlVXJsKGIpIHtcXG4gICAgICAgIHJldHVybiBhLm1vYmlsZS5wYXRoLmdldEZpbGVQYXRoKGIpO1xcbiAgICAgIH0sIF90cmlnZ2VyV2l0aERlcHJlY2F0ZWQ6IGZ1bmN0aW9uIF90cmlnZ2VyV2l0aERlcHJlY2F0ZWQoYiwgYywgZCkge1xcbiAgICAgICAgdmFyIGUgPSBhLkV2ZW50KFxcXCJwYWdlXFxcIiArIGIpLFxcbiAgICAgICAgICAgIGYgPSBhLkV2ZW50KHRoaXMud2lkZ2V0TmFtZSArIGIpO3JldHVybiAoZCB8fCB0aGlzLmVsZW1lbnQpLnRyaWdnZXIoZSwgYyksIHRoaXMuX3RyaWdnZXIoYiwgZiwgYyksIHsgZGVwcmVjYXRlZEV2ZW50OiBlLCBldmVudDogZiB9O1xcbiAgICAgIH0sIF9sb2FkU3VjY2VzczogZnVuY3Rpb24gX2xvYWRTdWNjZXNzKGIsIGMsIGUsIGYpIHtcXG4gICAgICAgIHZhciBnID0gdGhpcy5fY3JlYXRlRmlsZVVybChiKTtyZXR1cm4gYS5wcm94eShmdW5jdGlvbiAoaCwgaSwgaikge1xcbiAgICAgICAgICB2YXIgayxcXG4gICAgICAgICAgICAgIGwgPSBuZXcgUmVnRXhwKFxcXCIoPFtePl0rXFxcXFxcXFxiZGF0YS1cXFwiICsgdGhpcy5fZ2V0TnMoKSArIFxcXCJyb2xlPVtcXFxcXFxcIiddP3BhZ2VbXFxcXFxcXCInXT9bXj5dKj4pXFxcIiksXFxuICAgICAgICAgICAgICBtID0gbmV3IFJlZ0V4cChcXFwiXFxcXFxcXFxiZGF0YS1cXFwiICsgdGhpcy5fZ2V0TnMoKSArIFxcXCJ1cmw9W1xcXFxcXFwiJ10/KFteXFxcXFxcXCInPl0qKVtcXFxcXFxcIiddP1xcXCIpO2wudGVzdChoKSAmJiBSZWdFeHAuJDEgJiYgbS50ZXN0KFJlZ0V4cC4kMSkgJiYgUmVnRXhwLiQxICYmIChnID0gYS5tb2JpbGUucGF0aC5nZXRGaWxlUGF0aChhKFxcXCI8ZGl2PlxcXCIgKyBSZWdFeHAuJDEgKyBcXFwiPC9kaXY+XFxcIikudGV4dCgpKSwgZyA9IHRoaXMud2luZG93WzBdLmVuY29kZVVSSUNvbXBvbmVudChnKSksIGUucHJlZmV0Y2ggPT09IGQgJiYgdGhpcy5fZ2V0QmFzZSgpLnNldChnKSwgayA9IHRoaXMuX3BhcnNlKGgsIGcpLCB0aGlzLl9zZXRMb2FkZWRUaXRsZShrLCBoKSwgYy54aHIgPSBqLCBjLnRleHRTdGF0dXMgPSBpLCBjLnBhZ2UgPSBrLCBjLmNvbnRlbnQgPSBrLCBjLnRvUGFnZSA9IGssIHRoaXMuX3RyaWdnZXJXaXRoRGVwcmVjYXRlZChcXFwibG9hZFxcXCIsIGMpLmV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpIHx8ICh0aGlzLl9pc1Jld3JpdGFibGVCYXNlVGFnKCkgJiYgayAmJiB0aGlzLl9nZXRCYXNlKCkucmV3cml0ZShnLCBrKSwgdGhpcy5faW5jbHVkZShrLCBlKSwgZS5zaG93TG9hZE1zZyAmJiB0aGlzLl9oaWRlTG9hZGluZygpLCBmLnJlc29sdmUoYiwgZSwgaykpO1xcbiAgICAgICAgfSwgdGhpcyk7XFxuICAgICAgfSwgX2xvYWREZWZhdWx0czogeyB0eXBlOiBcXFwiZ2V0XFxcIiwgZGF0YTogZCwgcmVsb2FkUGFnZTogITEsIHJlbG9hZDogITEsIHJvbGU6IGQsIHNob3dMb2FkTXNnOiAhMSwgbG9hZE1zZ0RlbGF5OiA1MCB9LCBsb2FkOiBmdW5jdGlvbiBsb2FkKGIsIGMpIHtcXG4gICAgICAgIHZhciBlLFxcbiAgICAgICAgICAgIGYsXFxuICAgICAgICAgICAgZyxcXG4gICAgICAgICAgICBoLFxcbiAgICAgICAgICAgIGkgPSBjICYmIGMuZGVmZXJyZWQgfHwgYS5EZWZlcnJlZCgpLFxcbiAgICAgICAgICAgIGogPSBjICYmIGMucmVsb2FkID09PSBkICYmIGMucmVsb2FkUGFnZSAhPT0gZCA/IHsgcmVsb2FkOiBjLnJlbG9hZFBhZ2UgfSA6IHt9LFxcbiAgICAgICAgICAgIGsgPSBhLmV4dGVuZCh7fSwgdGhpcy5fbG9hZERlZmF1bHRzLCBjLCBqKSxcXG4gICAgICAgICAgICBsID0gbnVsbCxcXG4gICAgICAgICAgICBtID0gYS5tb2JpbGUucGF0aC5tYWtlVXJsQWJzb2x1dGUoYiwgdGhpcy5fZmluZEJhc2VXaXRoRGVmYXVsdCgpKTtyZXR1cm4gay5kYXRhICYmIFxcXCJnZXRcXFwiID09PSBrLnR5cGUgJiYgKG0gPSBhLm1vYmlsZS5wYXRoLmFkZFNlYXJjaFBhcmFtcyhtLCBrLmRhdGEpLCBrLmRhdGEgPSBkKSwgay5kYXRhICYmIFxcXCJwb3N0XFxcIiA9PT0gay50eXBlICYmIChrLnJlbG9hZCA9ICEwKSwgZSA9IHRoaXMuX2NyZWF0ZUZpbGVVcmwobSksIGYgPSB0aGlzLl9jcmVhdGVEYXRhVXJsKG0pLCBsID0gdGhpcy5fZmluZChtKSwgMCA9PT0gbC5sZW5ndGggJiYgYS5tb2JpbGUucGF0aC5pc0VtYmVkZGVkUGFnZShlKSAmJiAhYS5tb2JpbGUucGF0aC5pc0ZpcnN0UGFnZVVybChlKSA/IChpLnJlamVjdChtLCBrKSwgaS5wcm9taXNlKCkpIDogKHRoaXMuX2dldEJhc2UoKS5yZXNldCgpLCBsLmxlbmd0aCAmJiAhay5yZWxvYWQgPyAodGhpcy5fZW5oYW5jZShsLCBrLnJvbGUpLCBpLnJlc29sdmUobSwgaywgbCksIGsucHJlZmV0Y2ggfHwgdGhpcy5fZ2V0QmFzZSgpLnNldChiKSwgaS5wcm9taXNlKCkpIDogKGggPSB7IHVybDogYiwgYWJzVXJsOiBtLCB0b1BhZ2U6IGIsIHByZXZQYWdlOiBjID8gYy5mcm9tUGFnZSA6IGQsIGRhdGFVcmw6IGYsIGRlZmVycmVkOiBpLCBvcHRpb25zOiBrIH0sIGcgPSB0aGlzLl90cmlnZ2VyV2l0aERlcHJlY2F0ZWQoXFxcImJlZm9yZWxvYWRcXFwiLCBoKSwgZy5kZXByZWNhdGVkRXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgfHwgZy5ldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSA/IGkucHJvbWlzZSgpIDogKGsuc2hvd0xvYWRNc2cgJiYgdGhpcy5fc2hvd0xvYWRpbmcoay5sb2FkTXNnRGVsYXkpLCBrLnByZWZldGNoID09PSBkICYmIHRoaXMuX2dldEJhc2UoKS5yZXNldCgpLCBhLm1vYmlsZS5hbGxvd0Nyb3NzRG9tYWluUGFnZXMgfHwgYS5tb2JpbGUucGF0aC5pc1NhbWVEb21haW4oYS5tb2JpbGUucGF0aC5kb2N1bWVudFVybCwgbSkgPyAoYS5hamF4KHsgdXJsOiBlLCB0eXBlOiBrLnR5cGUsIGRhdGE6IGsuZGF0YSwgY29udGVudFR5cGU6IGsuY29udGVudFR5cGUsIGRhdGFUeXBlOiBcXFwiaHRtbFxcXCIsIHN1Y2Nlc3M6IHRoaXMuX2xvYWRTdWNjZXNzKG0sIGgsIGssIGkpLCBlcnJvcjogdGhpcy5fbG9hZEVycm9yKG0sIGgsIGssIGkpIH0pLCBpLnByb21pc2UoKSkgOiAoaS5yZWplY3QobSwgayksIGkucHJvbWlzZSgpKSkpKTtcXG4gICAgICB9LCBfbG9hZEVycm9yOiBmdW5jdGlvbiBfbG9hZEVycm9yKGIsIGMsIGQsIGUpIHtcXG4gICAgICAgIHJldHVybiBhLnByb3h5KGZ1bmN0aW9uIChmLCBnLCBoKSB7XFxuICAgICAgICAgIHRoaXMuX2dldEJhc2UoKS5zZXQoYS5tb2JpbGUucGF0aC5nZXQoKSksIGMueGhyID0gZiwgYy50ZXh0U3RhdHVzID0gZywgYy5lcnJvclRocm93biA9IGg7dmFyIGkgPSB0aGlzLl90cmlnZ2VyV2l0aERlcHJlY2F0ZWQoXFxcImxvYWRmYWlsZWRcXFwiLCBjKTtpLmRlcHJlY2F0ZWRFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSB8fCBpLmV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpIHx8IChkLnNob3dMb2FkTXNnICYmIHRoaXMuX3Nob3dFcnJvcigpLCBlLnJlamVjdChiLCBkKSk7XFxuICAgICAgICB9LCB0aGlzKTtcXG4gICAgICB9LCBfZ2V0VHJhbnNpdGlvbkhhbmRsZXI6IGZ1bmN0aW9uIF9nZXRUcmFuc2l0aW9uSGFuZGxlcihiKSB7XFxuICAgICAgICByZXR1cm4gYiA9IGEubW9iaWxlLl9tYXliZURlZ3JhZGVUcmFuc2l0aW9uKGIpLCBhLm1vYmlsZS50cmFuc2l0aW9uSGFuZGxlcnNbYl0gfHwgYS5tb2JpbGUuZGVmYXVsdFRyYW5zaXRpb25IYW5kbGVyO1xcbiAgICAgIH0sIF90cmlnZ2VyQ3NzVHJhbnNpdGlvbkV2ZW50czogZnVuY3Rpb24gX3RyaWdnZXJDc3NUcmFuc2l0aW9uRXZlbnRzKGIsIGMsIGQpIHtcXG4gICAgICAgIHZhciBlID0gITE7ZCA9IGQgfHwgXFxcIlxcXCIsIGMgJiYgKGJbMF0gPT09IGNbMF0gJiYgKGUgPSAhMCksIHRoaXMuX3RyaWdnZXJXaXRoRGVwcmVjYXRlZChkICsgXFxcImhpZGVcXFwiLCB7IG5leHRQYWdlOiBiLCB0b1BhZ2U6IGIsIHByZXZQYWdlOiBjLCBzYW1lUGFnZTogZSB9LCBjKSksIHRoaXMuX3RyaWdnZXJXaXRoRGVwcmVjYXRlZChkICsgXFxcInNob3dcXFwiLCB7IHByZXZQYWdlOiBjIHx8IGEoXFxcIlxcXCIpLCB0b1BhZ2U6IGIgfSwgYik7XFxuICAgICAgfSwgX2Nzc1RyYW5zaXRpb246IGZ1bmN0aW9uIF9jc3NUcmFuc2l0aW9uKGIsIGMsIGQpIHtcXG4gICAgICAgIHZhciBlLFxcbiAgICAgICAgICAgIGYsXFxuICAgICAgICAgICAgZyA9IGQudHJhbnNpdGlvbixcXG4gICAgICAgICAgICBoID0gZC5yZXZlcnNlLFxcbiAgICAgICAgICAgIGkgPSBkLmRlZmVycmVkO3RoaXMuX3RyaWdnZXJDc3NUcmFuc2l0aW9uRXZlbnRzKGIsIGMsIFxcXCJiZWZvcmVcXFwiKSwgdGhpcy5faGlkZUxvYWRpbmcoKSwgZSA9IHRoaXMuX2dldFRyYW5zaXRpb25IYW5kbGVyKGcpLCBmID0gbmV3IGUoZywgaCwgYiwgYykudHJhbnNpdGlvbigpLCBmLmRvbmUoYS5wcm94eShmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHRoaXMuX3RyaWdnZXJDc3NUcmFuc2l0aW9uRXZlbnRzKGIsIGMpO1xcbiAgICAgICAgfSwgdGhpcykpLCBmLmRvbmUoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBpLnJlc29sdmUuYXBwbHkoaSwgYXJndW1lbnRzKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH0sIF9yZWxlYXNlVHJhbnNpdGlvbkxvY2s6IGZ1bmN0aW9uIF9yZWxlYXNlVHJhbnNpdGlvbkxvY2soKSB7XFxuICAgICAgICBmID0gITEsIGUubGVuZ3RoID4gMCAmJiBhLm1vYmlsZS5jaGFuZ2VQYWdlLmFwcGx5KG51bGwsIGUucG9wKCkpO1xcbiAgICAgIH0sIF9yZW1vdmVBY3RpdmVMaW5rQ2xhc3M6IGZ1bmN0aW9uIF9yZW1vdmVBY3RpdmVMaW5rQ2xhc3MoYikge1xcbiAgICAgICAgYS5tb2JpbGUucmVtb3ZlQWN0aXZlTGlua0NsYXNzKGIpO1xcbiAgICAgIH0sIF9sb2FkVXJsOiBmdW5jdGlvbiBfbG9hZFVybChiLCBjLCBkKSB7XFxuICAgICAgICBkLnRhcmdldCA9IGIsIGQuZGVmZXJyZWQgPSBhLkRlZmVycmVkKCksIHRoaXMubG9hZChiLCBkKSwgZC5kZWZlcnJlZC5kb25lKGEucHJveHkoZnVuY3Rpb24gKGEsIGIsIGQpIHtcXG4gICAgICAgICAgZiA9ICExLCBiLmFic1VybCA9IGMuYWJzVXJsLCB0aGlzLnRyYW5zaXRpb24oZCwgYywgYik7XFxuICAgICAgICB9LCB0aGlzKSksIGQuZGVmZXJyZWQuZmFpbChhLnByb3h5KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgdGhpcy5fcmVtb3ZlQWN0aXZlTGlua0NsYXNzKCEwKSwgdGhpcy5fcmVsZWFzZVRyYW5zaXRpb25Mb2NrKCksIHRoaXMuX3RyaWdnZXJXaXRoRGVwcmVjYXRlZChcXFwiY2hhbmdlZmFpbGVkXFxcIiwgYyk7XFxuICAgICAgICB9LCB0aGlzKSk7XFxuICAgICAgfSwgX3RyaWdnZXJQYWdlQmVmb3JlQ2hhbmdlOiBmdW5jdGlvbiBfdHJpZ2dlclBhZ2VCZWZvcmVDaGFuZ2UoYiwgYywgZCkge1xcbiAgICAgICAgdmFyIGU7cmV0dXJuIGMucHJldlBhZ2UgPSB0aGlzLmFjdGl2ZVBhZ2UsIGEuZXh0ZW5kKGMsIHsgdG9QYWdlOiBiLCBvcHRpb25zOiBkIH0pLCBjLmFic1VybCA9IFxcXCJzdHJpbmdcXFwiID09PSBhLnR5cGUoYikgPyBhLm1vYmlsZS5wYXRoLm1ha2VVcmxBYnNvbHV0ZShiLCB0aGlzLl9maW5kQmFzZVdpdGhEZWZhdWx0KCkpIDogZC5hYnNVcmwsIGUgPSB0aGlzLl90cmlnZ2VyV2l0aERlcHJlY2F0ZWQoXFxcImJlZm9yZWNoYW5nZVxcXCIsIGMpLCBlLmV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpIHx8IGUuZGVwcmVjYXRlZEV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpID8gITEgOiAhMDtcXG4gICAgICB9LCBjaGFuZ2U6IGZ1bmN0aW9uIGNoYW5nZShiLCBjKSB7XFxuICAgICAgICBpZiAoZikgcmV0dXJuIHZvaWQgZS51bnNoaWZ0KGFyZ3VtZW50cyk7dmFyIGQgPSBhLmV4dGVuZCh7fSwgYS5tb2JpbGUuY2hhbmdlUGFnZS5kZWZhdWx0cywgYyksXFxuICAgICAgICAgICAgZyA9IHt9O2QuZnJvbVBhZ2UgPSBkLmZyb21QYWdlIHx8IHRoaXMuYWN0aXZlUGFnZSwgdGhpcy5fdHJpZ2dlclBhZ2VCZWZvcmVDaGFuZ2UoYiwgZywgZCkgJiYgKGIgPSBnLnRvUGFnZSwgXFxcInN0cmluZ1xcXCIgPT09IGEudHlwZShiKSA/IChmID0gITAsIHRoaXMuX2xvYWRVcmwoYiwgZywgZCkpIDogdGhpcy50cmFuc2l0aW9uKGIsIGcsIGQpKTtcXG4gICAgICB9LCB0cmFuc2l0aW9uOiBmdW5jdGlvbiB0cmFuc2l0aW9uKGIsIGcsIGgpIHtcXG4gICAgICAgIHZhciBpLCBqLCBrLCBsLCBtLCBuLCBvLCBwLCBxLCByLCBzLCB0LCB1LCB2O2lmIChmKSByZXR1cm4gdm9pZCBlLnVuc2hpZnQoW2IsIGhdKTtpZiAodGhpcy5fdHJpZ2dlclBhZ2VCZWZvcmVDaGFuZ2UoYiwgZywgaCkgJiYgKGcucHJldlBhZ2UgPSBoLmZyb21QYWdlLCB2ID0gdGhpcy5fdHJpZ2dlcldpdGhEZXByZWNhdGVkKFxcXCJiZWZvcmV0cmFuc2l0aW9uXFxcIiwgZyksICF2LmRlcHJlY2F0ZWRFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSAmJiAhdi5ldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkpIHtcXG4gICAgICAgICAgaWYgKGYgPSAhMCwgYlswXSAhPT0gYS5tb2JpbGUuZmlyc3RQYWdlWzBdIHx8IGguZGF0YVVybCB8fCAoaC5kYXRhVXJsID0gYS5tb2JpbGUucGF0aC5kb2N1bWVudFVybC5ocmVmTm9IYXNoKSwgaSA9IGguZnJvbVBhZ2UsIGogPSBoLmRhdGFVcmwgJiYgYS5tb2JpbGUucGF0aC5jb252ZXJ0VXJsVG9EYXRhVXJsKGguZGF0YVVybCkgfHwgYi5qcW1EYXRhKFxcXCJ1cmxcXFwiKSwgayA9IGosIGwgPSBhLm1vYmlsZS5wYXRoLmdldEZpbGVQYXRoKGopLCBtID0gYS5tb2JpbGUubmF2aWdhdGUuaGlzdG9yeS5nZXRBY3RpdmUoKSwgbiA9IDAgPT09IGEubW9iaWxlLm5hdmlnYXRlLmhpc3RvcnkuYWN0aXZlSW5kZXgsIG8gPSAwLCBwID0gYy50aXRsZSwgcSA9IChcXFwiZGlhbG9nXFxcIiA9PT0gaC5yb2xlIHx8IFxcXCJkaWFsb2dcXFwiID09PSBiLmpxbURhdGEoXFxcInJvbGVcXFwiKSkgJiYgYi5qcW1EYXRhKFxcXCJkaWFsb2dcXFwiKSAhPT0gITAsIGkgJiYgaVswXSA9PT0gYlswXSAmJiAhaC5hbGxvd1NhbWVQYWdlVHJhbnNpdGlvbikgcmV0dXJuIGYgPSAhMSwgdGhpcy5fdHJpZ2dlcldpdGhEZXByZWNhdGVkKFxcXCJ0cmFuc2l0aW9uXFxcIiwgZyksIHRoaXMuX3RyaWdnZXJXaXRoRGVwcmVjYXRlZChcXFwiY2hhbmdlXFxcIiwgZyksIHZvaWQgKGguZnJvbUhhc2hDaGFuZ2UgJiYgYS5tb2JpbGUubmF2aWdhdGUuaGlzdG9yeS5kaXJlY3QoeyB1cmw6IGogfSkpO2IucGFnZSh7IHJvbGU6IGgucm9sZSB9KSwgaC5mcm9tSGFzaENoYW5nZSAmJiAobyA9IFxcXCJiYWNrXFxcIiA9PT0gaC5kaXJlY3Rpb24gPyAtMSA6IDEpO3RyeSB7XFxuICAgICAgICAgICAgYy5hY3RpdmVFbGVtZW50ICYmIFxcXCJib2R5XFxcIiAhPT0gYy5hY3RpdmVFbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPyBhKGMuYWN0aXZlRWxlbWVudCkuYmx1cigpIDogYShcXFwiaW5wdXQ6Zm9jdXMsIHRleHRhcmVhOmZvY3VzLCBzZWxlY3Q6Zm9jdXNcXFwiKS5ibHVyKCk7XFxuICAgICAgICAgIH0gY2F0Y2ggKHcpIHt9ciA9ICExLCBxICYmIG0gJiYgKG0udXJsICYmIG0udXJsLmluZGV4T2YoYS5tb2JpbGUuZGlhbG9nSGFzaEtleSkgPiAtMSAmJiB0aGlzLmFjdGl2ZVBhZ2UgJiYgIXRoaXMuYWN0aXZlUGFnZS5oYXNDbGFzcyhcXFwidWktZGlhbG9nXFxcIikgJiYgYS5tb2JpbGUubmF2aWdhdGUuaGlzdG9yeS5hY3RpdmVJbmRleCA+IDAgJiYgKGguY2hhbmdlSGFzaCA9ICExLCByID0gITApLCBqID0gbS51cmwgfHwgXFxcIlxcXCIsIGogKz0gIXIgJiYgai5pbmRleE9mKFxcXCIjXFxcIikgPiAtMSA/IGEubW9iaWxlLmRpYWxvZ0hhc2hLZXkgOiBcXFwiI1xcXCIgKyBhLm1vYmlsZS5kaWFsb2dIYXNoS2V5KSwgcyA9IG0gPyBiLmpxbURhdGEoXFxcInRpdGxlXFxcIikgfHwgYi5jaGlsZHJlbihcXFwiOmpxbURhdGEocm9sZT0naGVhZGVyJylcXFwiKS5maW5kKFxcXCIudWktdGl0bGVcXFwiKS50ZXh0KCkgOiBwLCBzICYmIHAgPT09IGMudGl0bGUgJiYgKHAgPSBzKSwgYi5qcW1EYXRhKFxcXCJ0aXRsZVxcXCIpIHx8IGIuanFtRGF0YShcXFwidGl0bGVcXFwiLCBwKSwgaC50cmFuc2l0aW9uID0gaC50cmFuc2l0aW9uIHx8IChvICYmICFuID8gbS50cmFuc2l0aW9uIDogZCkgfHwgKHEgPyBhLm1vYmlsZS5kZWZhdWx0RGlhbG9nVHJhbnNpdGlvbiA6IGEubW9iaWxlLmRlZmF1bHRQYWdlVHJhbnNpdGlvbiksICFvICYmIHIgJiYgKGEubW9iaWxlLm5hdmlnYXRlLmhpc3RvcnkuZ2V0QWN0aXZlKCkucGFnZVVybCA9IGspLCBqICYmICFoLmZyb21IYXNoQ2hhbmdlICYmICghYS5tb2JpbGUucGF0aC5pc1BhdGgoaikgJiYgai5pbmRleE9mKFxcXCIjXFxcIikgPCAwICYmIChqID0gXFxcIiNcXFwiICsgaiksIHQgPSB7IHRyYW5zaXRpb246IGgudHJhbnNpdGlvbiwgdGl0bGU6IHAsIHBhZ2VVcmw6IGssIHJvbGU6IGgucm9sZSB9LCBoLmNoYW5nZUhhc2ggIT09ICExICYmIGEubW9iaWxlLmhhc2hMaXN0ZW5pbmdFbmFibGVkID8gYS5tb2JpbGUubmF2aWdhdGUodGhpcy53aW5kb3dbMF0uZW5jb2RlVVJJKGopLCB0LCAhMCkgOiBiWzBdICE9PSBhLm1vYmlsZS5maXJzdFBhZ2VbMF0gJiYgYS5tb2JpbGUubmF2aWdhdGUuaGlzdG9yeS5hZGQoaiwgdCkpLCBjLnRpdGxlID0gcCwgYS5tb2JpbGUuYWN0aXZlUGFnZSA9IGIsIHRoaXMuYWN0aXZlUGFnZSA9IGIsIGgucmV2ZXJzZSA9IGgucmV2ZXJzZSB8fCAwID4gbywgdSA9IGEuRGVmZXJyZWQoKSwgdGhpcy5fY3NzVHJhbnNpdGlvbihiLCBpLCB7IHRyYW5zaXRpb246IGgudHJhbnNpdGlvbiwgcmV2ZXJzZTogaC5yZXZlcnNlLCBkZWZlcnJlZDogdSB9KSwgdS5kb25lKGEucHJveHkoZnVuY3Rpb24gKGMsIGQsIGUsIGYsIGkpIHtcXG4gICAgICAgICAgICBhLm1vYmlsZS5yZW1vdmVBY3RpdmVMaW5rQ2xhc3MoKSwgaC5kdXBsaWNhdGVDYWNoZWRQYWdlICYmIGguZHVwbGljYXRlQ2FjaGVkUGFnZS5yZW1vdmUoKSwgaSB8fCBhLm1vYmlsZS5mb2N1c1BhZ2UoYiksIHRoaXMuX3JlbGVhc2VUcmFuc2l0aW9uTG9jaygpLCB0aGlzLl90cmlnZ2VyV2l0aERlcHJlY2F0ZWQoXFxcInRyYW5zaXRpb25cXFwiLCBnKSwgdGhpcy5fdHJpZ2dlcldpdGhEZXByZWNhdGVkKFxcXCJjaGFuZ2VcXFwiLCBnKTtcXG4gICAgICAgICAgfSwgdGhpcykpO1xcbiAgICAgICAgfVxcbiAgICAgIH0sIF9maW5kQmFzZVdpdGhEZWZhdWx0OiBmdW5jdGlvbiBfZmluZEJhc2VXaXRoRGVmYXVsdCgpIHtcXG4gICAgICAgIHZhciBiID0gdGhpcy5hY3RpdmVQYWdlICYmIGEubW9iaWxlLmdldENsb3Nlc3RCYXNlVXJsKHRoaXMuYWN0aXZlUGFnZSk7cmV0dXJuIGIgfHwgYS5tb2JpbGUucGF0aC5kb2N1bWVudEJhc2UuaHJlZk5vSGFzaDtcXG4gICAgICB9IH0pLCBhLm1vYmlsZS5uYXZyZWFkeURlZmVycmVkID0gYS5EZWZlcnJlZCgpO3ZhciBlID0gW10sXFxuICAgICAgICBmID0gITE7XFxuICB9KGEpLCBmdW5jdGlvbiAoYSwgZCkge1xcbiAgICBmdW5jdGlvbiBlKGEpIHtcXG4gICAgICBmb3IgKDsgYSAmJiAoXFxcInN0cmluZ1xcXCIgIT0gdHlwZW9mIGEubm9kZU5hbWUgfHwgXFxcImFcXFwiICE9PSBhLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpOykge1xcbiAgICAgICAgYSA9IGEucGFyZW50Tm9kZTtcXG4gICAgICB9cmV0dXJuIGE7XFxuICAgIH12YXIgZiA9IGEuRGVmZXJyZWQoKSxcXG4gICAgICAgIGcgPSBhLkRlZmVycmVkKCksXFxuICAgICAgICBoID0gZnVuY3Rpb24gaCgpIHtcXG4gICAgICBnLnJlc29sdmUoKSwgZyA9IG51bGw7XFxuICAgIH0sXFxuICAgICAgICBpID0gYS5tb2JpbGUucGF0aC5kb2N1bWVudFVybCxcXG4gICAgICAgIGogPSBudWxsO2EubW9iaWxlLmxvYWRQYWdlID0gZnVuY3Rpb24gKGIsIGMpIHtcXG4gICAgICB2YXIgZDtyZXR1cm4gYyA9IGMgfHwge30sIGQgPSBjLnBhZ2VDb250YWluZXIgfHwgYS5tb2JpbGUucGFnZUNvbnRhaW5lciwgYy5kZWZlcnJlZCA9IGEuRGVmZXJyZWQoKSwgZC5wYWdlY29udGFpbmVyKFxcXCJsb2FkXFxcIiwgYiwgYyksIGMuZGVmZXJyZWQucHJvbWlzZSgpO1xcbiAgICB9LCBhLm1vYmlsZS5iYWNrID0gZnVuY3Rpb24gKCkge1xcbiAgICAgIHZhciBjID0gYi5uYXZpZ2F0b3I7dGhpcy5waG9uZWdhcE5hdmlnYXRpb25FbmFibGVkICYmIGMgJiYgYy5hcHAgJiYgYy5hcHAuYmFja0hpc3RvcnkgPyBjLmFwcC5iYWNrSGlzdG9yeSgpIDogYS5tb2JpbGUucGFnZUNvbnRhaW5lci5wYWdlY29udGFpbmVyKFxcXCJiYWNrXFxcIik7XFxuICAgIH0sIGEubW9iaWxlLmZvY3VzUGFnZSA9IGZ1bmN0aW9uIChhKSB7XFxuICAgICAgdmFyIGIgPSBhLmZpbmQoXFxcIlthdXRvZm9jdXNdXFxcIiksXFxuICAgICAgICAgIGMgPSBhLmZpbmQoXFxcIi51aS10aXRsZTplcSgwKVxcXCIpO3JldHVybiBiLmxlbmd0aCA/IHZvaWQgYi5mb2N1cygpIDogdm9pZCAoYy5sZW5ndGggPyBjLmZvY3VzKCkgOiBhLmZvY3VzKCkpO1xcbiAgICB9LCBhLm1vYmlsZS5fbWF5YmVEZWdyYWRlVHJhbnNpdGlvbiA9IGEubW9iaWxlLl9tYXliZURlZ3JhZGVUcmFuc2l0aW9uIHx8IGZ1bmN0aW9uIChhKSB7XFxuICAgICAgcmV0dXJuIGE7XFxuICAgIH0sIGEubW9iaWxlLmNoYW5nZVBhZ2UgPSBmdW5jdGlvbiAoYiwgYykge1xcbiAgICAgIGEubW9iaWxlLnBhZ2VDb250YWluZXIucGFnZWNvbnRhaW5lcihcXFwiY2hhbmdlXFxcIiwgYiwgYyk7XFxuICAgIH0sIGEubW9iaWxlLmNoYW5nZVBhZ2UuZGVmYXVsdHMgPSB7IHRyYW5zaXRpb246IGQsIHJldmVyc2U6ICExLCBjaGFuZ2VIYXNoOiAhMCwgZnJvbUhhc2hDaGFuZ2U6ICExLCByb2xlOiBkLCBkdXBsaWNhdGVDYWNoZWRQYWdlOiBkLCBwYWdlQ29udGFpbmVyOiBkLCBzaG93TG9hZE1zZzogITAsIGRhdGFVcmw6IGQsIGZyb21QYWdlOiBkLCBhbGxvd1NhbWVQYWdlVHJhbnNpdGlvbjogITEgfSwgYS5tb2JpbGUuX3JlZ2lzdGVySW50ZXJuYWxFdmVudHMgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgdmFyIGMgPSBmdW5jdGlvbiBjKGIsIF9jKSB7XFxuICAgICAgICB2YXIgZCxcXG4gICAgICAgICAgICBlLFxcbiAgICAgICAgICAgIGYsXFxuICAgICAgICAgICAgZyxcXG4gICAgICAgICAgICBoID0gITA7cmV0dXJuICFhLm1vYmlsZS5hamF4RW5hYmxlZCB8fCBiLmlzKFxcXCI6anFtRGF0YShhamF4PSdmYWxzZScpXFxcIikgfHwgIWIuanFtSGlqYWNrYWJsZSgpLmxlbmd0aCB8fCBiLmF0dHIoXFxcInRhcmdldFxcXCIpID8gITEgOiAoZCA9IGogJiYgai5hdHRyKFxcXCJmb3JtYWN0aW9uXFxcIikgfHwgYi5hdHRyKFxcXCJhY3Rpb25cXFwiKSwgZyA9IChiLmF0dHIoXFxcIm1ldGhvZFxcXCIpIHx8IFxcXCJnZXRcXFwiKS50b0xvd2VyQ2FzZSgpLCBkIHx8IChkID0gYS5tb2JpbGUuZ2V0Q2xvc2VzdEJhc2VVcmwoYiksIFxcXCJnZXRcXFwiID09PSBnICYmIChkID0gYS5tb2JpbGUucGF0aC5wYXJzZVVybChkKS5ocmVmTm9TZWFyY2gpLCBkID09PSBhLm1vYmlsZS5wYXRoLmRvY3VtZW50QmFzZS5ocmVmTm9IYXNoICYmIChkID0gaS5ocmVmTm9TZWFyY2gpKSwgZCA9IGEubW9iaWxlLnBhdGgubWFrZVVybEFic29sdXRlKGQsIGEubW9iaWxlLmdldENsb3Nlc3RCYXNlVXJsKGIpKSwgYS5tb2JpbGUucGF0aC5pc0V4dGVybmFsKGQpICYmICFhLm1vYmlsZS5wYXRoLmlzUGVybWl0dGVkQ3Jvc3NEb21haW5SZXF1ZXN0KGksIGQpID8gITEgOiAoX2MgfHwgKGUgPSBiLnNlcmlhbGl6ZUFycmF5KCksIGogJiYgalswXS5mb3JtID09PSBiWzBdICYmIChmID0gai5hdHRyKFxcXCJuYW1lXFxcIiksIGYgJiYgKGEuZWFjaChlLCBmdW5jdGlvbiAoYSwgYikge1xcbiAgICAgICAgICByZXR1cm4gYi5uYW1lID09PSBmID8gKGYgPSBcXFwiXFxcIiwgITEpIDogdm9pZCAwO1xcbiAgICAgICAgfSksIGYgJiYgZS5wdXNoKHsgbmFtZTogZiwgdmFsdWU6IGouYXR0cihcXFwidmFsdWVcXFwiKSB9KSkpLCBoID0geyB1cmw6IGQsIG9wdGlvbnM6IHsgdHlwZTogZywgZGF0YTogYS5wYXJhbShlKSwgdHJhbnNpdGlvbjogYi5qcW1EYXRhKFxcXCJ0cmFuc2l0aW9uXFxcIiksIHJldmVyc2U6IFxcXCJyZXZlcnNlXFxcIiA9PT0gYi5qcW1EYXRhKFxcXCJkaXJlY3Rpb25cXFwiKSwgcmVsb2FkUGFnZTogITAgfSB9KSwgaCkpO1xcbiAgICAgIH07YS5tb2JpbGUuZG9jdW1lbnQuZGVsZWdhdGUoXFxcImZvcm1cXFwiLCBcXFwic3VibWl0XFxcIiwgZnVuY3Rpb24gKGIpIHtcXG4gICAgICAgIHZhciBkO2IuaXNEZWZhdWx0UHJldmVudGVkKCkgfHwgKGQgPSBjKGEodGhpcykpLCBkICYmIChhLm1vYmlsZS5jaGFuZ2VQYWdlKGQudXJsLCBkLm9wdGlvbnMpLCBiLnByZXZlbnREZWZhdWx0KCkpKTtcXG4gICAgICB9KSwgYS5tb2JpbGUuZG9jdW1lbnQuYmluZChcXFwidmNsaWNrXFxcIiwgZnVuY3Rpb24gKGIpIHtcXG4gICAgICAgIHZhciBkLFxcbiAgICAgICAgICAgIGYsXFxuICAgICAgICAgICAgZyA9IGIudGFyZ2V0LFxcbiAgICAgICAgICAgIGggPSAhMTtpZiAoIShiLndoaWNoID4gMSkgJiYgYS5tb2JpbGUubGlua0JpbmRpbmdFbmFibGVkKSB7XFxuICAgICAgICAgIGlmIChqID0gYShnKSwgYS5kYXRhKGcsIFxcXCJtb2JpbGUtYnV0dG9uXFxcIikpIHtcXG4gICAgICAgICAgICBpZiAoIWMoYShnKS5jbG9zZXN0KFxcXCJmb3JtXFxcIiksICEwKSkgcmV0dXJuO2cucGFyZW50Tm9kZSAmJiAoZyA9IGcucGFyZW50Tm9kZSk7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgaWYgKGcgPSBlKGcpLCAhZyB8fCBcXFwiI1xcXCIgPT09IGEubW9iaWxlLnBhdGgucGFyc2VVcmwoZy5nZXRBdHRyaWJ1dGUoXFxcImhyZWZcXFwiKSB8fCBcXFwiI1xcXCIpLmhhc2gpIHJldHVybjtpZiAoIWEoZykuanFtSGlqYWNrYWJsZSgpLmxlbmd0aCkgcmV0dXJuO1xcbiAgICAgICAgICB9fmcuY2xhc3NOYW1lLmluZGV4T2YoXFxcInVpLWxpbmstaW5oZXJpdFxcXCIpID8gZy5wYXJlbnROb2RlICYmIChmID0gYS5kYXRhKGcucGFyZW50Tm9kZSwgXFxcImJ1dHRvbkVsZW1lbnRzXFxcIikpIDogZiA9IGEuZGF0YShnLCBcXFwiYnV0dG9uRWxlbWVudHNcXFwiKSwgZiA/IGcgPSBmLm91dGVyIDogaCA9ICEwLCBkID0gYShnKSwgaCAmJiAoZCA9IGQuY2xvc2VzdChcXFwiLnVpLWJ0blxcXCIpKSwgZC5sZW5ndGggPiAwICYmICFkLmhhc0NsYXNzKFxcXCJ1aS1zdGF0ZS1kaXNhYmxlZFxcXCIpICYmIChhLm1vYmlsZS5yZW1vdmVBY3RpdmVMaW5rQ2xhc3MoITApLCBhLm1vYmlsZS5hY3RpdmVDbGlja2VkTGluayA9IGQsIGEubW9iaWxlLmFjdGl2ZUNsaWNrZWRMaW5rLmFkZENsYXNzKGEubW9iaWxlLmFjdGl2ZUJ0bkNsYXNzKSk7XFxuICAgICAgICB9XFxuICAgICAgfSksIGEubW9iaWxlLmRvY3VtZW50LmJpbmQoXFxcImNsaWNrXFxcIiwgZnVuY3Rpb24gKGMpIHtcXG4gICAgICAgIGlmIChhLm1vYmlsZS5saW5rQmluZGluZ0VuYWJsZWQgJiYgIWMuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcXG4gICAgICAgICAgdmFyIGYsXFxuICAgICAgICAgICAgICBnLFxcbiAgICAgICAgICAgICAgaCxcXG4gICAgICAgICAgICAgIGosXFxuICAgICAgICAgICAgICBrLFxcbiAgICAgICAgICAgICAgbCxcXG4gICAgICAgICAgICAgIG0sXFxuICAgICAgICAgICAgICBuID0gZShjLnRhcmdldCksXFxuICAgICAgICAgICAgICBvID0gYShuKSxcXG4gICAgICAgICAgICAgIHAgPSBmdW5jdGlvbiBwKCkge1xcbiAgICAgICAgICAgIGIuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICBhLm1vYmlsZS5yZW1vdmVBY3RpdmVMaW5rQ2xhc3MoITApO1xcbiAgICAgICAgICAgIH0sIDIwMCk7XFxuICAgICAgICAgIH07aWYgKGEubW9iaWxlLmFjdGl2ZUNsaWNrZWRMaW5rICYmIGEubW9iaWxlLmFjdGl2ZUNsaWNrZWRMaW5rWzBdID09PSBjLnRhcmdldC5wYXJlbnROb2RlICYmIHAoKSwgbiAmJiAhKGMud2hpY2ggPiAxKSAmJiBvLmpxbUhpamFja2FibGUoKS5sZW5ndGgpIHtcXG4gICAgICAgICAgICBpZiAoby5pcyhcXFwiOmpxbURhdGEocmVsPSdiYWNrJylcXFwiKSkgcmV0dXJuIGEubW9iaWxlLmJhY2soKSwgITE7aWYgKGYgPSBhLm1vYmlsZS5nZXRDbG9zZXN0QmFzZVVybChvKSwgZyA9IGEubW9iaWxlLnBhdGgubWFrZVVybEFic29sdXRlKG8uYXR0cihcXFwiaHJlZlxcXCIpIHx8IFxcXCIjXFxcIiwgZiksICFhLm1vYmlsZS5hamF4RW5hYmxlZCAmJiAhYS5tb2JpbGUucGF0aC5pc0VtYmVkZGVkUGFnZShnKSkgcmV0dXJuIHZvaWQgcCgpO2lmICghKC0xID09PSBnLnNlYXJjaChcXFwiI1xcXCIpIHx8IGEubW9iaWxlLnBhdGguaXNFeHRlcm5hbChnKSAmJiBhLm1vYmlsZS5wYXRoLmlzQWJzb2x1dGVVcmwoZykpKSB7XFxuICAgICAgICAgICAgICBpZiAoZyA9IGcucmVwbGFjZSgvW14jXSojLywgXFxcIlxcXCIpLCAhZykgcmV0dXJuIHZvaWQgYy5wcmV2ZW50RGVmYXVsdCgpO2cgPSBhLm1vYmlsZS5wYXRoLmlzUGF0aChnKSA/IGEubW9iaWxlLnBhdGgubWFrZVVybEFic29sdXRlKGcsIGYpIDogYS5tb2JpbGUucGF0aC5tYWtlVXJsQWJzb2x1dGUoXFxcIiNcXFwiICsgZywgaS5ocmVmTm9IYXNoKTtcXG4gICAgICAgICAgICB9aWYgKGggPSBvLmlzKFxcXCJbcmVsPSdleHRlcm5hbCddXFxcIikgfHwgby5pcyhcXFwiOmpxbURhdGEoYWpheD0nZmFsc2UnKVxcXCIpIHx8IG8uaXMoXFxcIlt0YXJnZXRdXFxcIiksIGogPSBoIHx8IGEubW9iaWxlLnBhdGguaXNFeHRlcm5hbChnKSAmJiAhYS5tb2JpbGUucGF0aC5pc1Blcm1pdHRlZENyb3NzRG9tYWluUmVxdWVzdChpLCBnKSkgcmV0dXJuIHZvaWQgcCgpO2sgPSBvLmpxbURhdGEoXFxcInRyYW5zaXRpb25cXFwiKSwgbCA9IFxcXCJyZXZlcnNlXFxcIiA9PT0gby5qcW1EYXRhKFxcXCJkaXJlY3Rpb25cXFwiKSB8fCBvLmpxbURhdGEoXFxcImJhY2tcXFwiKSwgbSA9IG8uYXR0cihcXFwiZGF0YS1cXFwiICsgYS5tb2JpbGUubnMgKyBcXFwicmVsXFxcIikgfHwgZCwgYS5tb2JpbGUuY2hhbmdlUGFnZShnLCB7IHRyYW5zaXRpb246IGssIHJldmVyc2U6IGwsIHJvbGU6IG0sIGxpbms6IG8gfSksIGMucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH0pLCBhLm1vYmlsZS5kb2N1bWVudC5kZWxlZ2F0ZShcXFwiLnVpLXBhZ2VcXFwiLCBcXFwicGFnZXNob3cucHJlZmV0Y2hcXFwiLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgYiA9IFtdO2EodGhpcykuZmluZChcXFwiYTpqcW1EYXRhKHByZWZldGNoKVxcXCIpLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICB2YXIgYyA9IGEodGhpcyksXFxuICAgICAgICAgICAgICBkID0gYy5hdHRyKFxcXCJocmVmXFxcIik7ZCAmJiAtMSA9PT0gYS5pbkFycmF5KGQsIGIpICYmIChiLnB1c2goZCksIGEubW9iaWxlLmxvYWRQYWdlKGQsIHsgcm9sZTogYy5hdHRyKFxcXCJkYXRhLVxcXCIgKyBhLm1vYmlsZS5ucyArIFxcXCJyZWxcXFwiKSwgcHJlZmV0Y2g6ICEwIH0pKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH0pLCBhLm1vYmlsZS5wYWdlQ29udGFpbmVyLnBhZ2Vjb250YWluZXIoKSwgYS5tb2JpbGUuZG9jdW1lbnQuYmluZChcXFwicGFnZXNob3dcXFwiLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICBnID8gZy5kb25lKGEubW9iaWxlLnJlc2V0QWN0aXZlUGFnZUhlaWdodCkgOiBhLm1vYmlsZS5yZXNldEFjdGl2ZVBhZ2VIZWlnaHQoKTtcXG4gICAgICB9KSwgYS5tb2JpbGUud2luZG93LmJpbmQoXFxcInRocm90dGxlZHJlc2l6ZVxcXCIsIGEubW9iaWxlLnJlc2V0QWN0aXZlUGFnZUhlaWdodCk7XFxuICAgIH0sIGEoZnVuY3Rpb24gKCkge1xcbiAgICAgIGYucmVzb2x2ZSgpO1xcbiAgICB9KSwgXFxcImNvbXBsZXRlXFxcIiA9PT0gYy5yZWFkeVN0YXRlID8gaCgpIDogYS5tb2JpbGUud2luZG93LmxvYWQoaCksIGEud2hlbihmLCBhLm1vYmlsZS5uYXZyZWFkeURlZmVycmVkKS5kb25lKGZ1bmN0aW9uICgpIHtcXG4gICAgICBhLm1vYmlsZS5fcmVnaXN0ZXJJbnRlcm5hbEV2ZW50cygpO1xcbiAgICB9KTtcXG4gIH0oYSksIGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgIGEubW9iaWxlLlRyYW5zaXRpb24gPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgdGhpcy5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICAgIH0sIGEuZXh0ZW5kKGEubW9iaWxlLlRyYW5zaXRpb24ucHJvdG90eXBlLCB7IHRvUHJlQ2xhc3M6IFxcXCIgdWktcGFnZS1wcmUtaW5cXFwiLCBpbml0OiBmdW5jdGlvbiBpbml0KGIsIGMsIGQsIGUpIHtcXG4gICAgICAgIGEuZXh0ZW5kKHRoaXMsIHsgbmFtZTogYiwgcmV2ZXJzZTogYywgJHRvOiBkLCAkZnJvbTogZSwgZGVmZXJyZWQ6IG5ldyBhLkRlZmVycmVkKCkgfSk7XFxuICAgICAgfSwgY2xlYW5Gcm9tOiBmdW5jdGlvbiBjbGVhbkZyb20oKSB7XFxuICAgICAgICB0aGlzLiRmcm9tLnJlbW92ZUNsYXNzKGEubW9iaWxlLmFjdGl2ZVBhZ2VDbGFzcyArIFxcXCIgb3V0IGluIHJldmVyc2UgXFxcIiArIHRoaXMubmFtZSkuaGVpZ2h0KFxcXCJcXFwiKTtcXG4gICAgICB9LCBiZWZvcmVEb25lSW46IGZ1bmN0aW9uIGJlZm9yZURvbmVJbigpIHt9LCBiZWZvcmVEb25lT3V0OiBmdW5jdGlvbiBiZWZvcmVEb25lT3V0KCkge30sIGJlZm9yZVN0YXJ0T3V0OiBmdW5jdGlvbiBiZWZvcmVTdGFydE91dCgpIHt9LCBkb25lSW46IGZ1bmN0aW9uIGRvbmVJbigpIHtcXG4gICAgICAgIHRoaXMuYmVmb3JlRG9uZUluKCksIHRoaXMuJHRvLnJlbW92ZUNsYXNzKFxcXCJvdXQgaW4gcmV2ZXJzZSBcXFwiICsgdGhpcy5uYW1lKS5oZWlnaHQoXFxcIlxcXCIpLCB0aGlzLnRvZ2dsZVZpZXdwb3J0Q2xhc3MoKSwgYS5tb2JpbGUud2luZG93LnNjcm9sbFRvcCgpICE9PSB0aGlzLnRvU2Nyb2xsICYmIHRoaXMuc2Nyb2xsUGFnZSgpLCB0aGlzLnNlcXVlbnRpYWwgfHwgdGhpcy4kdG8uYWRkQ2xhc3MoYS5tb2JpbGUuYWN0aXZlUGFnZUNsYXNzKSwgdGhpcy5kZWZlcnJlZC5yZXNvbHZlKHRoaXMubmFtZSwgdGhpcy5yZXZlcnNlLCB0aGlzLiR0bywgdGhpcy4kZnJvbSwgITApO1xcbiAgICAgIH0sIGRvbmVPdXQ6IGZ1bmN0aW9uIGRvbmVPdXQoYSwgYiwgYywgZCkge1xcbiAgICAgICAgdGhpcy5iZWZvcmVEb25lT3V0KCksIHRoaXMuc3RhcnRJbihhLCBiLCBjLCBkKTtcXG4gICAgICB9LCBoaWRlSW46IGZ1bmN0aW9uIGhpZGVJbihhKSB7XFxuICAgICAgICB0aGlzLiR0by5jc3MoXFxcInotaW5kZXhcXFwiLCAtMTApLCBhLmNhbGwodGhpcyksIHRoaXMuJHRvLmNzcyhcXFwiei1pbmRleFxcXCIsIFxcXCJcXFwiKTtcXG4gICAgICB9LCBzY3JvbGxQYWdlOiBmdW5jdGlvbiBzY3JvbGxQYWdlKCkge1xcbiAgICAgICAgYS5ldmVudC5zcGVjaWFsLnNjcm9sbHN0YXJ0LmVuYWJsZWQgPSAhMSwgKGEubW9iaWxlLmhpZGVVcmxCYXIgfHwgdGhpcy50b1Njcm9sbCAhPT0gYS5tb2JpbGUuZGVmYXVsdEhvbWVTY3JvbGwpICYmIGIuc2Nyb2xsVG8oMCwgdGhpcy50b1Njcm9sbCksIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBhLmV2ZW50LnNwZWNpYWwuc2Nyb2xsc3RhcnQuZW5hYmxlZCA9ICEwO1xcbiAgICAgICAgfSwgMTUwKTtcXG4gICAgICB9LCBzdGFydEluOiBmdW5jdGlvbiBzdGFydEluKGIsIGMsIGQsIGUpIHtcXG4gICAgICAgIHRoaXMuaGlkZUluKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgdGhpcy4kdG8uYWRkQ2xhc3MoYS5tb2JpbGUuYWN0aXZlUGFnZUNsYXNzICsgdGhpcy50b1ByZUNsYXNzKSwgZSB8fCBhLm1vYmlsZS5mb2N1c1BhZ2UodGhpcy4kdG8pLCB0aGlzLiR0by5oZWlnaHQoYiArIHRoaXMudG9TY3JvbGwpLCBkIHx8IHRoaXMuc2Nyb2xsUGFnZSgpO1xcbiAgICAgICAgfSksIHRoaXMuJHRvLnJlbW92ZUNsYXNzKHRoaXMudG9QcmVDbGFzcykuYWRkQ2xhc3ModGhpcy5uYW1lICsgXFxcIiBpbiBcXFwiICsgYyksIGQgPyB0aGlzLmRvbmVJbigpIDogdGhpcy4kdG8uYW5pbWF0aW9uQ29tcGxldGUoYS5wcm94eShmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHRoaXMuZG9uZUluKCk7XFxuICAgICAgICB9LCB0aGlzKSk7XFxuICAgICAgfSwgc3RhcnRPdXQ6IGZ1bmN0aW9uIHN0YXJ0T3V0KGIsIGMsIGQpIHtcXG4gICAgICAgIHRoaXMuYmVmb3JlU3RhcnRPdXQoYiwgYywgZCksIHRoaXMuJGZyb20uaGVpZ2h0KGIgKyBhLm1vYmlsZS53aW5kb3cuc2Nyb2xsVG9wKCkpLmFkZENsYXNzKHRoaXMubmFtZSArIFxcXCIgb3V0XFxcIiArIGMpO1xcbiAgICAgIH0sIHRvZ2dsZVZpZXdwb3J0Q2xhc3M6IGZ1bmN0aW9uIHRvZ2dsZVZpZXdwb3J0Q2xhc3MoKSB7XFxuICAgICAgICBhLm1vYmlsZS5wYWdlQ29udGFpbmVyLnRvZ2dsZUNsYXNzKFxcXCJ1aS1tb2JpbGUtdmlld3BvcnQtdHJhbnNpdGlvbmluZyB2aWV3cG9ydC1cXFwiICsgdGhpcy5uYW1lKTtcXG4gICAgICB9LCB0cmFuc2l0aW9uOiBmdW5jdGlvbiB0cmFuc2l0aW9uKCkge1xcbiAgICAgICAgdmFyIGIsXFxuICAgICAgICAgICAgYyA9IHRoaXMucmV2ZXJzZSA/IFxcXCIgcmV2ZXJzZVxcXCIgOiBcXFwiXFxcIixcXG4gICAgICAgICAgICBkID0gYS5tb2JpbGUuZ2V0U2NyZWVuSGVpZ2h0KCksXFxuICAgICAgICAgICAgZSA9IGEubW9iaWxlLm1heFRyYW5zaXRpb25XaWR0aCAhPT0gITEgJiYgYS5tb2JpbGUud2luZG93LndpZHRoKCkgPiBhLm1vYmlsZS5tYXhUcmFuc2l0aW9uV2lkdGg7cmV0dXJuIHRoaXMudG9TY3JvbGwgPSBhLm1vYmlsZS5uYXZpZ2F0ZS5oaXN0b3J5LmdldEFjdGl2ZSgpLmxhc3RTY3JvbGwgfHwgYS5tb2JpbGUuZGVmYXVsdEhvbWVTY3JvbGwsIGIgPSAhYS5zdXBwb3J0LmNzc1RyYW5zaXRpb25zIHx8ICFhLnN1cHBvcnQuY3NzQW5pbWF0aW9ucyB8fCBlIHx8ICF0aGlzLm5hbWUgfHwgXFxcIm5vbmVcXFwiID09PSB0aGlzLm5hbWUgfHwgTWF0aC5tYXgoYS5tb2JpbGUud2luZG93LnNjcm9sbFRvcCgpLCB0aGlzLnRvU2Nyb2xsKSA+IGEubW9iaWxlLmdldE1heFNjcm9sbEZvclRyYW5zaXRpb24oKSwgdGhpcy50b2dnbGVWaWV3cG9ydENsYXNzKCksIHRoaXMuJGZyb20gJiYgIWIgPyB0aGlzLnN0YXJ0T3V0KGQsIGMsIGIpIDogdGhpcy5kb25lT3V0KGQsIGMsIGIsICEwKSwgdGhpcy5kZWZlcnJlZC5wcm9taXNlKCk7XFxuICAgICAgfSB9KTtcXG4gIH0oYSwgdGhpcyksIGZ1bmN0aW9uIChhKSB7XFxuICAgIGEubW9iaWxlLlNlcmlhbFRyYW5zaXRpb24gPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgdGhpcy5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICAgIH0sIGEuZXh0ZW5kKGEubW9iaWxlLlNlcmlhbFRyYW5zaXRpb24ucHJvdG90eXBlLCBhLm1vYmlsZS5UcmFuc2l0aW9uLnByb3RvdHlwZSwgeyBzZXF1ZW50aWFsOiAhMCwgYmVmb3JlRG9uZU91dDogZnVuY3Rpb24gYmVmb3JlRG9uZU91dCgpIHtcXG4gICAgICAgIHRoaXMuJGZyb20gJiYgdGhpcy5jbGVhbkZyb20oKTtcXG4gICAgICB9LCBiZWZvcmVTdGFydE91dDogZnVuY3Rpb24gYmVmb3JlU3RhcnRPdXQoYiwgYywgZCkge1xcbiAgICAgICAgdGhpcy4kZnJvbS5hbmltYXRpb25Db21wbGV0ZShhLnByb3h5KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgdGhpcy5kb25lT3V0KGIsIGMsIGQpO1xcbiAgICAgICAgfSwgdGhpcykpO1xcbiAgICAgIH0gfSk7XFxuICB9KGEpLCBmdW5jdGlvbiAoYSkge1xcbiAgICBhLm1vYmlsZS5Db25jdXJyZW50VHJhbnNpdGlvbiA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICB0aGlzLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gICAgfSwgYS5leHRlbmQoYS5tb2JpbGUuQ29uY3VycmVudFRyYW5zaXRpb24ucHJvdG90eXBlLCBhLm1vYmlsZS5UcmFuc2l0aW9uLnByb3RvdHlwZSwgeyBzZXF1ZW50aWFsOiAhMSwgYmVmb3JlRG9uZUluOiBmdW5jdGlvbiBiZWZvcmVEb25lSW4oKSB7XFxuICAgICAgICB0aGlzLiRmcm9tICYmIHRoaXMuY2xlYW5Gcm9tKCk7XFxuICAgICAgfSwgYmVmb3JlU3RhcnRPdXQ6IGZ1bmN0aW9uIGJlZm9yZVN0YXJ0T3V0KGEsIGIsIGMpIHtcXG4gICAgICAgIHRoaXMuZG9uZU91dChhLCBiLCBjKTtcXG4gICAgICB9IH0pO1xcbiAgfShhKSwgZnVuY3Rpb24gKGEpIHtcXG4gICAgdmFyIGIgPSBmdW5jdGlvbiBiKCkge1xcbiAgICAgIHJldHVybiAzICogYS5tb2JpbGUuZ2V0U2NyZWVuSGVpZ2h0KCk7XFxuICAgIH07YS5tb2JpbGUudHJhbnNpdGlvbkhhbmRsZXJzID0geyBzZXF1ZW50aWFsOiBhLm1vYmlsZS5TZXJpYWxUcmFuc2l0aW9uLCBzaW11bHRhbmVvdXM6IGEubW9iaWxlLkNvbmN1cnJlbnRUcmFuc2l0aW9uIH0sIGEubW9iaWxlLmRlZmF1bHRUcmFuc2l0aW9uSGFuZGxlciA9IGEubW9iaWxlLnRyYW5zaXRpb25IYW5kbGVycy5zZXF1ZW50aWFsLCBhLm1vYmlsZS50cmFuc2l0aW9uRmFsbGJhY2tzID0ge30sIGEubW9iaWxlLl9tYXliZURlZ3JhZGVUcmFuc2l0aW9uID0gZnVuY3Rpb24gKGIpIHtcXG4gICAgICByZXR1cm4gYiAmJiAhYS5zdXBwb3J0LmNzc1RyYW5zZm9ybTNkICYmIGEubW9iaWxlLnRyYW5zaXRpb25GYWxsYmFja3NbYl0gJiYgKGIgPSBhLm1vYmlsZS50cmFuc2l0aW9uRmFsbGJhY2tzW2JdKSwgYjtcXG4gICAgfSwgYS5tb2JpbGUuZ2V0TWF4U2Nyb2xsRm9yVHJhbnNpdGlvbiA9IGEubW9iaWxlLmdldE1heFNjcm9sbEZvclRyYW5zaXRpb24gfHwgYjtcXG4gIH0oYSksIGZ1bmN0aW9uIChhKSB7XFxuICAgIGEubW9iaWxlLnRyYW5zaXRpb25GYWxsYmFja3MuZmxpcCA9IFxcXCJmYWRlXFxcIjtcXG4gIH0oYSwgdGhpcyksIGZ1bmN0aW9uIChhKSB7XFxuICAgIGEubW9iaWxlLnRyYW5zaXRpb25GYWxsYmFja3MuZmxvdyA9IFxcXCJmYWRlXFxcIjtcXG4gIH0oYSwgdGhpcyksIGZ1bmN0aW9uIChhKSB7XFxuICAgIGEubW9iaWxlLnRyYW5zaXRpb25GYWxsYmFja3MucG9wID0gXFxcImZhZGVcXFwiO1xcbiAgfShhLCB0aGlzKSwgZnVuY3Rpb24gKGEpIHtcXG4gICAgYS5tb2JpbGUudHJhbnNpdGlvbkhhbmRsZXJzLnNsaWRlID0gYS5tb2JpbGUudHJhbnNpdGlvbkhhbmRsZXJzLnNpbXVsdGFuZW91cywgYS5tb2JpbGUudHJhbnNpdGlvbkZhbGxiYWNrcy5zbGlkZSA9IFxcXCJmYWRlXFxcIjtcXG4gIH0oYSwgdGhpcyksIGZ1bmN0aW9uIChhKSB7XFxuICAgIGEubW9iaWxlLnRyYW5zaXRpb25GYWxsYmFja3Muc2xpZGVkb3duID0gXFxcImZhZGVcXFwiO1xcbiAgfShhLCB0aGlzKSwgZnVuY3Rpb24gKGEpIHtcXG4gICAgYS5tb2JpbGUudHJhbnNpdGlvbkZhbGxiYWNrcy5zbGlkZWZhZGUgPSBcXFwiZmFkZVxcXCI7XFxuICB9KGEsIHRoaXMpLCBmdW5jdGlvbiAoYSkge1xcbiAgICBhLm1vYmlsZS50cmFuc2l0aW9uRmFsbGJhY2tzLnNsaWRldXAgPSBcXFwiZmFkZVxcXCI7XFxuICB9KGEsIHRoaXMpLCBmdW5jdGlvbiAoYSkge1xcbiAgICBhLm1vYmlsZS50cmFuc2l0aW9uRmFsbGJhY2tzLnR1cm4gPSBcXFwiZmFkZVxcXCI7XFxuICB9KGEsIHRoaXMpLCBmdW5jdGlvbiAoYSkge1xcbiAgICBhLm1vYmlsZS5kZWdyYWRlSW5wdXRzID0geyBjb2xvcjogITEsIGRhdGU6ICExLCBkYXRldGltZTogITEsIFxcXCJkYXRldGltZS1sb2NhbFxcXCI6ICExLCBlbWFpbDogITEsIG1vbnRoOiAhMSwgbnVtYmVyOiAhMSwgcmFuZ2U6IFxcXCJudW1iZXJcXFwiLCBzZWFyY2g6IFxcXCJ0ZXh0XFxcIiwgdGVsOiAhMSwgdGltZTogITEsIHVybDogITEsIHdlZWs6ICExIH0sIGEubW9iaWxlLnBhZ2UucHJvdG90eXBlLm9wdGlvbnMuZGVncmFkZUlucHV0cyA9IGEubW9iaWxlLmRlZ3JhZGVJbnB1dHMsIGEubW9iaWxlLmRlZ3JhZGVJbnB1dHNXaXRoaW4gPSBmdW5jdGlvbiAoYikge1xcbiAgICAgIGIgPSBhKGIpLCBiLmZpbmQoXFxcImlucHV0XFxcIikubm90KGEubW9iaWxlLnBhZ2UucHJvdG90eXBlLmtlZXBOYXRpdmVTZWxlY3RvcigpKS5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciBiLFxcbiAgICAgICAgICAgIGMsXFxuICAgICAgICAgICAgZCxcXG4gICAgICAgICAgICBlLFxcbiAgICAgICAgICAgIGYgPSBhKHRoaXMpLFxcbiAgICAgICAgICAgIGcgPSB0aGlzLmdldEF0dHJpYnV0ZShcXFwidHlwZVxcXCIpLFxcbiAgICAgICAgICAgIGggPSBhLm1vYmlsZS5kZWdyYWRlSW5wdXRzW2ddIHx8IFxcXCJ0ZXh0XFxcIjthLm1vYmlsZS5kZWdyYWRlSW5wdXRzW2ddICYmIChiID0gYShcXFwiPGRpdj5cXFwiKS5odG1sKGYuY2xvbmUoKSkuaHRtbCgpLCBjID0gYi5pbmRleE9mKFxcXCIgdHlwZT1cXFwiKSA+IC0xLCBkID0gYyA/IC9cXFxccyt0eXBlPVtcXFwiJ10/XFxcXHcrWydcXFwiXT8vIDogL1xcXFwvPz4vLCBlID0gJyB0eXBlPVxcXCInICsgaCArICdcXFwiIGRhdGEtJyArIGEubW9iaWxlLm5zICsgJ3R5cGU9XFxcIicgKyBnICsgJ1xcXCInICsgKGMgPyBcXFwiXFxcIiA6IFxcXCI+XFxcIiksIGYucmVwbGFjZVdpdGgoYi5yZXBsYWNlKGQsIGUpKSk7XFxuICAgICAgfSk7XFxuICAgIH07XFxuICB9KGEpLCBmdW5jdGlvbiAoYSwgYiwgYykge1xcbiAgICBhLndpZGdldChcXFwibW9iaWxlLnBhZ2VcXFwiLCBhLm1vYmlsZS5wYWdlLCB7IG9wdGlvbnM6IHsgY2xvc2VCdG46IFxcXCJsZWZ0XFxcIiwgY2xvc2VCdG5UZXh0OiBcXFwiQ2xvc2VcXFwiLCBvdmVybGF5VGhlbWU6IFxcXCJhXFxcIiwgY29ybmVyczogITAsIGRpYWxvZzogITEgfSwgX2NyZWF0ZTogZnVuY3Rpb24gX2NyZWF0ZSgpIHtcXG4gICAgICAgIHRoaXMuX3N1cGVyKCksIHRoaXMub3B0aW9ucy5kaWFsb2cgJiYgKGEuZXh0ZW5kKHRoaXMsIHsgX2lubmVyOiB0aGlzLmVsZW1lbnQuY2hpbGRyZW4oKSwgX2hlYWRlckNsb3NlQnV0dG9uOiBudWxsIH0pLCB0aGlzLm9wdGlvbnMuZW5oYW5jZWQgfHwgdGhpcy5fc2V0Q2xvc2VCdG4odGhpcy5vcHRpb25zLmNsb3NlQnRuKSk7XFxuICAgICAgfSwgX2VuaGFuY2U6IGZ1bmN0aW9uIF9lbmhhbmNlKCkge1xcbiAgICAgICAgdGhpcy5fc3VwZXIoKSwgdGhpcy5vcHRpb25zLmRpYWxvZyAmJiB0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoXFxcInVpLWRpYWxvZ1xcXCIpLndyYXBJbm5lcihhKFxcXCI8ZGl2Lz5cXFwiLCB7IHJvbGU6IFxcXCJkaWFsb2dcXFwiLCBcXFwiY2xhc3NcXFwiOiBcXFwidWktZGlhbG9nLWNvbnRhaW4gdWktb3ZlcmxheS1zaGFkb3dcXFwiICsgKHRoaXMub3B0aW9ucy5jb3JuZXJzID8gXFxcIiB1aS1jb3JuZXItYWxsXFxcIiA6IFxcXCJcXFwiKSB9KSk7XFxuICAgICAgfSwgX3NldE9wdGlvbnM6IGZ1bmN0aW9uIF9zZXRPcHRpb25zKGIpIHtcXG4gICAgICAgIHZhciBkLFxcbiAgICAgICAgICAgIGUsXFxuICAgICAgICAgICAgZiA9IHRoaXMub3B0aW9ucztiLmNvcm5lcnMgIT09IGMgJiYgdGhpcy5faW5uZXIudG9nZ2xlQ2xhc3MoXFxcInVpLWNvcm5lci1hbGxcXFwiLCAhIWIuY29ybmVycyksIGIub3ZlcmxheVRoZW1lICE9PSBjICYmIGEubW9iaWxlLmFjdGl2ZVBhZ2VbMF0gPT09IHRoaXMuZWxlbWVudFswXSAmJiAoZi5vdmVybGF5VGhlbWUgPSBiLm92ZXJsYXlUaGVtZSwgdGhpcy5faGFuZGxlUGFnZUJlZm9yZVNob3coKSksIGIuY2xvc2VCdG5UZXh0ICE9PSBjICYmIChkID0gZi5jbG9zZUJ0biwgZSA9IGIuY2xvc2VCdG5UZXh0KSwgYi5jbG9zZUJ0biAhPT0gYyAmJiAoZCA9IGIuY2xvc2VCdG4pLCBkICYmIHRoaXMuX3NldENsb3NlQnRuKGQsIGUpLCB0aGlzLl9zdXBlcihiKTtcXG4gICAgICB9LCBfaGFuZGxlUGFnZUJlZm9yZVNob3c6IGZ1bmN0aW9uIF9oYW5kbGVQYWdlQmVmb3JlU2hvdygpIHtcXG4gICAgICAgIHRoaXMub3B0aW9ucy5vdmVybGF5VGhlbWUgJiYgdGhpcy5vcHRpb25zLmRpYWxvZyA/ICh0aGlzLnJlbW92ZUNvbnRhaW5lckJhY2tncm91bmQoKSwgdGhpcy5zZXRDb250YWluZXJCYWNrZ3JvdW5kKHRoaXMub3B0aW9ucy5vdmVybGF5VGhlbWUpKSA6IHRoaXMuX3N1cGVyKCk7XFxuICAgICAgfSwgX3NldENsb3NlQnRuOiBmdW5jdGlvbiBfc2V0Q2xvc2VCdG4oYiwgYykge1xcbiAgICAgICAgdmFyIGQsXFxuICAgICAgICAgICAgZSA9IHRoaXMuX2hlYWRlckNsb3NlQnV0dG9uO2IgPSBcXFwibGVmdFxcXCIgPT09IGIgPyBcXFwibGVmdFxcXCIgOiBcXFwicmlnaHRcXFwiID09PSBiID8gXFxcInJpZ2h0XFxcIiA6IFxcXCJub25lXFxcIiwgXFxcIm5vbmVcXFwiID09PSBiID8gZSAmJiAoZS5yZW1vdmUoKSwgZSA9IG51bGwpIDogZSA/IChlLnJlbW92ZUNsYXNzKFxcXCJ1aS1idG4tbGVmdCB1aS1idG4tcmlnaHRcXFwiKS5hZGRDbGFzcyhcXFwidWktYnRuLVxcXCIgKyBiKSwgYyAmJiBlLnRleHQoYykpIDogKGQgPSB0aGlzLl9pbm5lci5maW5kKFxcXCI6anFtRGF0YShyb2xlPSdoZWFkZXInKVxcXCIpLmZpcnN0KCksIGUgPSBhKFxcXCI8YT48L2E+XFxcIiwgeyBocmVmOiBcXFwiI1xcXCIsIFxcXCJjbGFzc1xcXCI6IFxcXCJ1aS1idG4gdWktY29ybmVyLWFsbCB1aS1pY29uLWRlbGV0ZSB1aS1idG4taWNvbi1ub3RleHQgdWktYnRuLVxcXCIgKyBiIH0pLmF0dHIoXFxcImRhdGEtXFxcIiArIGEubW9iaWxlLm5zICsgXFxcInJlbFxcXCIsIFxcXCJiYWNrXFxcIikudGV4dChjIHx8IHRoaXMub3B0aW9ucy5jbG9zZUJ0blRleHQgfHwgXFxcIlxcXCIpLnByZXBlbmRUbyhkKSksIHRoaXMuX2hlYWRlckNsb3NlQnV0dG9uID0gZTtcXG4gICAgICB9IH0pO1xcbiAgfShhLCB0aGlzKSwgZnVuY3Rpb24gKGEsIGIsIGMpIHtcXG4gICAgYS53aWRnZXQoXFxcIm1vYmlsZS5kaWFsb2dcXFwiLCB7IG9wdGlvbnM6IHsgY2xvc2VCdG46IFxcXCJsZWZ0XFxcIiwgY2xvc2VCdG5UZXh0OiBcXFwiQ2xvc2VcXFwiLCBvdmVybGF5VGhlbWU6IFxcXCJhXFxcIiwgY29ybmVyczogITAgfSwgX2hhbmRsZVBhZ2VCZWZvcmVTaG93OiBmdW5jdGlvbiBfaGFuZGxlUGFnZUJlZm9yZVNob3coKSB7XFxuICAgICAgICB0aGlzLl9pc0Nsb3NlYWJsZSA9ICEwLCB0aGlzLm9wdGlvbnMub3ZlcmxheVRoZW1lICYmIHRoaXMuZWxlbWVudC5wYWdlKFxcXCJyZW1vdmVDb250YWluZXJCYWNrZ3JvdW5kXFxcIikucGFnZShcXFwic2V0Q29udGFpbmVyQmFja2dyb3VuZFxcXCIsIHRoaXMub3B0aW9ucy5vdmVybGF5VGhlbWUpO1xcbiAgICAgIH0sIF9oYW5kbGVQYWdlQmVmb3JlSGlkZTogZnVuY3Rpb24gX2hhbmRsZVBhZ2VCZWZvcmVIaWRlKCkge1xcbiAgICAgICAgdGhpcy5faXNDbG9zZWFibGUgPSAhMTtcXG4gICAgICB9LCBfaGFuZGxlVkNsaWNrU3VibWl0OiBmdW5jdGlvbiBfaGFuZGxlVkNsaWNrU3VibWl0KGIpIHtcXG4gICAgICAgIHZhciBjLFxcbiAgICAgICAgICAgIGQgPSBhKGIudGFyZ2V0KS5jbG9zZXN0KFxcXCJ2Y2xpY2tcXFwiID09PSBiLnR5cGUgPyBcXFwiYVxcXCIgOiBcXFwiZm9ybVxcXCIpO2QubGVuZ3RoICYmICFkLmpxbURhdGEoXFxcInRyYW5zaXRpb25cXFwiKSAmJiAoYyA9IHt9LCBjW1xcXCJkYXRhLVxcXCIgKyBhLm1vYmlsZS5ucyArIFxcXCJ0cmFuc2l0aW9uXFxcIl0gPSAoYS5tb2JpbGUubmF2aWdhdGUuaGlzdG9yeS5nZXRBY3RpdmUoKSB8fCB7fSkudHJhbnNpdGlvbiB8fCBhLm1vYmlsZS5kZWZhdWx0RGlhbG9nVHJhbnNpdGlvbiwgY1tcXFwiZGF0YS1cXFwiICsgYS5tb2JpbGUubnMgKyBcXFwiZGlyZWN0aW9uXFxcIl0gPSBcXFwicmV2ZXJzZVxcXCIsIGQuYXR0cihjKSk7XFxuICAgICAgfSwgX2NyZWF0ZTogZnVuY3Rpb24gX2NyZWF0ZSgpIHtcXG4gICAgICAgIHZhciBiID0gdGhpcy5lbGVtZW50LFxcbiAgICAgICAgICAgIGMgPSB0aGlzLm9wdGlvbnM7Yi5hZGRDbGFzcyhcXFwidWktZGlhbG9nXFxcIikud3JhcElubmVyKGEoXFxcIjxkaXYvPlxcXCIsIHsgcm9sZTogXFxcImRpYWxvZ1xcXCIsIFxcXCJjbGFzc1xcXCI6IFxcXCJ1aS1kaWFsb2ctY29udGFpbiB1aS1vdmVybGF5LXNoYWRvd1xcXCIgKyAoYy5jb3JuZXJzID8gXFxcIiB1aS1jb3JuZXItYWxsXFxcIiA6IFxcXCJcXFwiKSB9KSksIGEuZXh0ZW5kKHRoaXMsIHsgX2lzQ2xvc2VhYmxlOiAhMSwgX2lubmVyOiBiLmNoaWxkcmVuKCksIF9oZWFkZXJDbG9zZUJ1dHRvbjogbnVsbCB9KSwgdGhpcy5fb24oYiwgeyB2Y2xpY2s6IFxcXCJfaGFuZGxlVkNsaWNrU3VibWl0XFxcIiwgc3VibWl0OiBcXFwiX2hhbmRsZVZDbGlja1N1Ym1pdFxcXCIsIHBhZ2ViZWZvcmVzaG93OiBcXFwiX2hhbmRsZVBhZ2VCZWZvcmVTaG93XFxcIiwgcGFnZWJlZm9yZWhpZGU6IFxcXCJfaGFuZGxlUGFnZUJlZm9yZUhpZGVcXFwiIH0pLCB0aGlzLl9zZXRDbG9zZUJ0bihjLmNsb3NlQnRuKTtcXG4gICAgICB9LCBfc2V0T3B0aW9uczogZnVuY3Rpb24gX3NldE9wdGlvbnMoYikge1xcbiAgICAgICAgdmFyIGQsXFxuICAgICAgICAgICAgZSxcXG4gICAgICAgICAgICBmID0gdGhpcy5vcHRpb25zO2IuY29ybmVycyAhPT0gYyAmJiB0aGlzLl9pbm5lci50b2dnbGVDbGFzcyhcXFwidWktY29ybmVyLWFsbFxcXCIsICEhYi5jb3JuZXJzKSwgYi5vdmVybGF5VGhlbWUgIT09IGMgJiYgYS5tb2JpbGUuYWN0aXZlUGFnZVswXSA9PT0gdGhpcy5lbGVtZW50WzBdICYmIChmLm92ZXJsYXlUaGVtZSA9IGIub3ZlcmxheVRoZW1lLCB0aGlzLl9oYW5kbGVQYWdlQmVmb3JlU2hvdygpKSwgYi5jbG9zZUJ0blRleHQgIT09IGMgJiYgKGQgPSBmLmNsb3NlQnRuLCBlID0gYi5jbG9zZUJ0blRleHQpLCBiLmNsb3NlQnRuICE9PSBjICYmIChkID0gYi5jbG9zZUJ0biksIGQgJiYgdGhpcy5fc2V0Q2xvc2VCdG4oZCwgZSksIHRoaXMuX3N1cGVyKGIpO1xcbiAgICAgIH0sIF9zZXRDbG9zZUJ0bjogZnVuY3Rpb24gX3NldENsb3NlQnRuKGIsIGMpIHtcXG4gICAgICAgIHZhciBkLFxcbiAgICAgICAgICAgIGUgPSB0aGlzLl9oZWFkZXJDbG9zZUJ1dHRvbjtiID0gXFxcImxlZnRcXFwiID09PSBiID8gXFxcImxlZnRcXFwiIDogXFxcInJpZ2h0XFxcIiA9PT0gYiA/IFxcXCJyaWdodFxcXCIgOiBcXFwibm9uZVxcXCIsIFxcXCJub25lXFxcIiA9PT0gYiA/IGUgJiYgKGUucmVtb3ZlKCksIGUgPSBudWxsKSA6IGUgPyAoZS5yZW1vdmVDbGFzcyhcXFwidWktYnRuLWxlZnQgdWktYnRuLXJpZ2h0XFxcIikuYWRkQ2xhc3MoXFxcInVpLWJ0bi1cXFwiICsgYiksIGMgJiYgZS50ZXh0KGMpKSA6IChkID0gdGhpcy5faW5uZXIuZmluZChcXFwiOmpxbURhdGEocm9sZT0naGVhZGVyJylcXFwiKS5maXJzdCgpLCBlID0gYShcXFwiPGE+PC9hPlxcXCIsIHsgcm9sZTogXFxcImJ1dHRvblxcXCIsIGhyZWY6IFxcXCIjXFxcIiwgXFxcImNsYXNzXFxcIjogXFxcInVpLWJ0biB1aS1jb3JuZXItYWxsIHVpLWljb24tZGVsZXRlIHVpLWJ0bi1pY29uLW5vdGV4dCB1aS1idG4tXFxcIiArIGIgfSkudGV4dChjIHx8IHRoaXMub3B0aW9ucy5jbG9zZUJ0blRleHQgfHwgXFxcIlxcXCIpLnByZXBlbmRUbyhkKSwgdGhpcy5fb24oZSwgeyBjbGljazogXFxcImNsb3NlXFxcIiB9KSksIHRoaXMuX2hlYWRlckNsb3NlQnV0dG9uID0gZTtcXG4gICAgICB9LCBjbG9zZTogZnVuY3Rpb24gY2xvc2UoKSB7XFxuICAgICAgICB2YXIgYiA9IGEubW9iaWxlLm5hdmlnYXRlLmhpc3Rvcnk7dGhpcy5faXNDbG9zZWFibGUgJiYgKHRoaXMuX2lzQ2xvc2VhYmxlID0gITEsIGEubW9iaWxlLmhhc2hMaXN0ZW5pbmdFbmFibGVkICYmIGIuYWN0aXZlSW5kZXggPiAwID8gYS5tb2JpbGUuYmFjaygpIDogYS5tb2JpbGUucGFnZUNvbnRhaW5lci5wYWdlY29udGFpbmVyKFxcXCJiYWNrXFxcIikpO1xcbiAgICAgIH0gfSk7XFxuICB9KGEsIHRoaXMpLCBmdW5jdGlvbiAoYSwgYikge1xcbiAgICB2YXIgYyA9IC8oW0EtWl0pL2csXFxuICAgICAgICBkID0gZnVuY3Rpb24gZChhKSB7XFxuICAgICAgcmV0dXJuIFxcXCJ1aS1idG4taWNvbi1cXFwiICsgKG51bGwgPT09IGEgPyBcXFwibGVmdFxcXCIgOiBhKTtcXG4gICAgfTthLndpZGdldChcXFwibW9iaWxlLmNvbGxhcHNpYmxlXFxcIiwgeyBvcHRpb25zOiB7IGVuaGFuY2VkOiAhMSwgZXhwYW5kQ3VlVGV4dDogbnVsbCwgY29sbGFwc2VDdWVUZXh0OiBudWxsLCBjb2xsYXBzZWQ6ICEwLCBoZWFkaW5nOiBcXFwiaDEsaDIsaDMsaDQsaDUsaDYsbGVnZW5kXFxcIiwgY29sbGFwc2VkSWNvbjogbnVsbCwgZXhwYW5kZWRJY29uOiBudWxsLCBpY29ucG9zOiBudWxsLCB0aGVtZTogbnVsbCwgY29udGVudFRoZW1lOiBudWxsLCBpbnNldDogbnVsbCwgY29ybmVyczogbnVsbCwgbWluaTogbnVsbCB9LCBfY3JlYXRlOiBmdW5jdGlvbiBfY3JlYXRlKCkge1xcbiAgICAgICAgdmFyIGIgPSB0aGlzLmVsZW1lbnQsXFxuICAgICAgICAgICAgYyA9IHsgYWNjb3JkaW9uOiBiLmNsb3Nlc3QoXFxcIjpqcW1EYXRhKHJvbGU9J2NvbGxhcHNpYmxlLXNldCcpLDpqcW1EYXRhKHJvbGU9J2NvbGxhcHNpYmxlc2V0JylcXFwiICsgKGEubW9iaWxlLmNvbGxhcHNpYmxlc2V0ID8gXFxcIiwgOm1vYmlsZS1jb2xsYXBzaWJsZXNldFxcXCIgOiBcXFwiXFxcIikpLmFkZENsYXNzKFxcXCJ1aS1jb2xsYXBzaWJsZS1zZXRcXFwiKSB9O3RoaXMuX3VpID0gYywgdGhpcy5fcmVuZGVyZWRPcHRpb25zID0gdGhpcy5fZ2V0T3B0aW9ucyh0aGlzLm9wdGlvbnMpLCB0aGlzLm9wdGlvbnMuZW5oYW5jZWQgPyAoYy5oZWFkaW5nID0gdGhpcy5lbGVtZW50LmNoaWxkcmVuKFxcXCIudWktY29sbGFwc2libGUtaGVhZGluZ1xcXCIpLCBjLmNvbnRlbnQgPSBjLmhlYWRpbmcubmV4dCgpLCBjLmFuY2hvciA9IGMuaGVhZGluZy5jaGlsZHJlbigpLCBjLnN0YXR1cyA9IGMuYW5jaG9yLmNoaWxkcmVuKFxcXCIudWktY29sbGFwc2libGUtaGVhZGluZy1zdGF0dXNcXFwiKSkgOiB0aGlzLl9lbmhhbmNlKGIsIGMpLCB0aGlzLl9vbihjLmhlYWRpbmcsIHsgdGFwOiBmdW5jdGlvbiB0YXAoKSB7XFxuICAgICAgICAgICAgYy5oZWFkaW5nLmZpbmQoXFxcImFcXFwiKS5maXJzdCgpLmFkZENsYXNzKGEubW9iaWxlLmFjdGl2ZUJ0bkNsYXNzKTtcXG4gICAgICAgICAgfSwgY2xpY2s6IGZ1bmN0aW9uIGNsaWNrKGEpIHtcXG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVFeHBhbmRDb2xsYXBzZSghYy5oZWFkaW5nLmhhc0NsYXNzKFxcXCJ1aS1jb2xsYXBzaWJsZS1oZWFkaW5nLWNvbGxhcHNlZFxcXCIpKSwgYS5wcmV2ZW50RGVmYXVsdCgpLCBhLnN0b3BQcm9wYWdhdGlvbigpO1xcbiAgICAgICAgICB9IH0pO1xcbiAgICAgIH0sIF9nZXRPcHRpb25zOiBmdW5jdGlvbiBfZ2V0T3B0aW9ucyhiKSB7XFxuICAgICAgICB2YXIgZCxcXG4gICAgICAgICAgICBlID0gdGhpcy5fdWkuYWNjb3JkaW9uLFxcbiAgICAgICAgICAgIGYgPSB0aGlzLl91aS5hY2NvcmRpb25XaWRnZXQ7YiA9IGEuZXh0ZW5kKHt9LCBiKSwgZS5sZW5ndGggJiYgIWYgJiYgKHRoaXMuX3VpLmFjY29yZGlvbldpZGdldCA9IGYgPSBlLmRhdGEoXFxcIm1vYmlsZS1jb2xsYXBzaWJsZXNldFxcXCIpKTtmb3IgKGQgaW4gYikge1xcbiAgICAgICAgICBiW2RdID0gbnVsbCAhPSBiW2RdID8gYltkXSA6IGYgPyBmLm9wdGlvbnNbZF0gOiBlLmxlbmd0aCA/IGEubW9iaWxlLmdldEF0dHJpYnV0ZShlWzBdLCBkLnJlcGxhY2UoYywgXFxcIi0kMVxcXCIpLnRvTG93ZXJDYXNlKCkpIDogbnVsbCwgbnVsbCA9PSBiW2RdICYmIChiW2RdID0gYS5tb2JpbGUuY29sbGFwc2libGUuZGVmYXVsdHNbZF0pO1xcbiAgICAgICAgfXJldHVybiBiO1xcbiAgICAgIH0sIF90aGVtZUNsYXNzRnJvbU9wdGlvbjogZnVuY3Rpb24gX3RoZW1lQ2xhc3NGcm9tT3B0aW9uKGEsIGIpIHtcXG4gICAgICAgIHJldHVybiBiID8gXFxcIm5vbmVcXFwiID09PSBiID8gXFxcIlxcXCIgOiBhICsgYiA6IFxcXCJcXFwiO1xcbiAgICAgIH0sIF9lbmhhbmNlOiBmdW5jdGlvbiBfZW5oYW5jZShiLCBjKSB7XFxuICAgICAgICB2YXIgZSxcXG4gICAgICAgICAgICBmID0gdGhpcy5fcmVuZGVyZWRPcHRpb25zLFxcbiAgICAgICAgICAgIGcgPSB0aGlzLl90aGVtZUNsYXNzRnJvbU9wdGlvbihcXFwidWktYm9keS1cXFwiLCBmLmNvbnRlbnRUaGVtZSk7cmV0dXJuIGIuYWRkQ2xhc3MoXFxcInVpLWNvbGxhcHNpYmxlIFxcXCIgKyAoZi5pbnNldCA/IFxcXCJ1aS1jb2xsYXBzaWJsZS1pbnNldCBcXFwiIDogXFxcIlxcXCIpICsgKGYuaW5zZXQgJiYgZi5jb3JuZXJzID8gXFxcInVpLWNvcm5lci1hbGwgXFxcIiA6IFxcXCJcXFwiKSArIChnID8gXFxcInVpLWNvbGxhcHNpYmxlLXRoZW1lZC1jb250ZW50IFxcXCIgOiBcXFwiXFxcIikpLCBjLm9yaWdpbmFsSGVhZGluZyA9IGIuY2hpbGRyZW4odGhpcy5vcHRpb25zLmhlYWRpbmcpLmZpcnN0KCksIGMuY29udGVudCA9IGIud3JhcElubmVyKFxcXCI8ZGl2IGNsYXNzPSd1aS1jb2xsYXBzaWJsZS1jb250ZW50IFxcXCIgKyBnICsgXFxcIic+PC9kaXY+XFxcIikuY2hpbGRyZW4oXFxcIi51aS1jb2xsYXBzaWJsZS1jb250ZW50XFxcIiksIGMuaGVhZGluZyA9IGMub3JpZ2luYWxIZWFkaW5nLCBjLmhlYWRpbmcuaXMoXFxcImxlZ2VuZFxcXCIpICYmIChjLmhlYWRpbmcgPSBhKFxcXCI8ZGl2IHJvbGU9J2hlYWRpbmcnPlxcXCIgKyBjLmhlYWRpbmcuaHRtbCgpICsgXFxcIjwvZGl2PlxcXCIpLCBjLnBsYWNlaG9sZGVyID0gYShcXFwiPGRpdj48IS0tIHBsYWNlaG9sZGVyIGZvciBsZWdlbmQgLS0+PC9kaXY+XFxcIikuaW5zZXJ0QmVmb3JlKGMub3JpZ2luYWxIZWFkaW5nKSwgYy5vcmlnaW5hbEhlYWRpbmcucmVtb3ZlKCkpLCBlID0gZi5jb2xsYXBzZWQgPyBmLmNvbGxhcHNlZEljb24gPyBcXFwidWktaWNvbi1cXFwiICsgZi5jb2xsYXBzZWRJY29uIDogXFxcIlxcXCIgOiBmLmV4cGFuZGVkSWNvbiA/IFxcXCJ1aS1pY29uLVxcXCIgKyBmLmV4cGFuZGVkSWNvbiA6IFxcXCJcXFwiLCBjLnN0YXR1cyA9IGEoXFxcIjxzcGFuIGNsYXNzPSd1aS1jb2xsYXBzaWJsZS1oZWFkaW5nLXN0YXR1cyc+PC9zcGFuPlxcXCIpLCBjLmFuY2hvciA9IGMuaGVhZGluZy5kZXRhY2goKS5hZGRDbGFzcyhcXFwidWktY29sbGFwc2libGUtaGVhZGluZ1xcXCIpLmFwcGVuZChjLnN0YXR1cykud3JhcElubmVyKFxcXCI8YSBocmVmPScjJyBjbGFzcz0ndWktY29sbGFwc2libGUtaGVhZGluZy10b2dnbGUnPjwvYT5cXFwiKS5maW5kKFxcXCJhXFxcIikuZmlyc3QoKS5hZGRDbGFzcyhcXFwidWktYnRuIFxcXCIgKyAoZSA/IGUgKyBcXFwiIFxcXCIgOiBcXFwiXFxcIikgKyAoZSA/IGQoZi5pY29ucG9zKSArIFxcXCIgXFxcIiA6IFxcXCJcXFwiKSArIHRoaXMuX3RoZW1lQ2xhc3NGcm9tT3B0aW9uKFxcXCJ1aS1idG4tXFxcIiwgZi50aGVtZSkgKyBcXFwiIFxcXCIgKyAoZi5taW5pID8gXFxcInVpLW1pbmkgXFxcIiA6IFxcXCJcXFwiKSksIGMuaGVhZGluZy5pbnNlcnRCZWZvcmUoYy5jb250ZW50KSwgdGhpcy5faGFuZGxlRXhwYW5kQ29sbGFwc2UodGhpcy5vcHRpb25zLmNvbGxhcHNlZCksIGM7XFxuICAgICAgfSwgcmVmcmVzaDogZnVuY3Rpb24gcmVmcmVzaCgpIHtcXG4gICAgICAgIHRoaXMuX2FwcGx5T3B0aW9ucyh0aGlzLm9wdGlvbnMpLCB0aGlzLl9yZW5kZXJlZE9wdGlvbnMgPSB0aGlzLl9nZXRPcHRpb25zKHRoaXMub3B0aW9ucyk7XFxuICAgICAgfSwgX2FwcGx5T3B0aW9uczogZnVuY3Rpb24gX2FwcGx5T3B0aW9ucyhhKSB7XFxuICAgICAgICB2YXIgYyxcXG4gICAgICAgICAgICBlLFxcbiAgICAgICAgICAgIGYsXFxuICAgICAgICAgICAgZyxcXG4gICAgICAgICAgICBoLFxcbiAgICAgICAgICAgIGkgPSB0aGlzLmVsZW1lbnQsXFxuICAgICAgICAgICAgaiA9IHRoaXMuX3JlbmRlcmVkT3B0aW9ucyxcXG4gICAgICAgICAgICBrID0gdGhpcy5fdWksXFxuICAgICAgICAgICAgbCA9IGsuYW5jaG9yLFxcbiAgICAgICAgICAgIG0gPSBrLnN0YXR1cyxcXG4gICAgICAgICAgICBuID0gdGhpcy5fZ2V0T3B0aW9ucyhhKTthLmNvbGxhcHNlZCAhPT0gYiAmJiB0aGlzLl9oYW5kbGVFeHBhbmRDb2xsYXBzZShhLmNvbGxhcHNlZCksIGMgPSBpLmhhc0NsYXNzKFxcXCJ1aS1jb2xsYXBzaWJsZS1jb2xsYXBzZWRcXFwiKSwgYyA/IG4uZXhwYW5kQ3VlVGV4dCAhPT0gYiAmJiBtLnRleHQobi5leHBhbmRDdWVUZXh0KSA6IG4uY29sbGFwc2VDdWVUZXh0ICE9PSBiICYmIG0udGV4dChuLmNvbGxhcHNlQ3VlVGV4dCksIGggPSBuLmNvbGxhcHNlZEljb24gIT09IGIgPyBuLmNvbGxhcHNlZEljb24gIT09ICExIDogai5jb2xsYXBzZWRJY29uICE9PSAhMSwgKG4uaWNvbnBvcyAhPT0gYiB8fCBuLmNvbGxhcHNlZEljb24gIT09IGIgfHwgbi5leHBhbmRlZEljb24gIT09IGIpICYmIChsLnJlbW92ZUNsYXNzKFtkKGouaWNvbnBvcyldLmNvbmNhdChqLmV4cGFuZGVkSWNvbiA/IFtcXFwidWktaWNvbi1cXFwiICsgai5leHBhbmRlZEljb25dIDogW10pLmNvbmNhdChqLmNvbGxhcHNlZEljb24gPyBbXFxcInVpLWljb24tXFxcIiArIGouY29sbGFwc2VkSWNvbl0gOiBbXSkuam9pbihcXFwiIFxcXCIpKSwgaCAmJiBsLmFkZENsYXNzKFtkKG4uaWNvbnBvcyAhPT0gYiA/IG4uaWNvbnBvcyA6IGouaWNvbnBvcyldLmNvbmNhdChjID8gW1xcXCJ1aS1pY29uLVxcXCIgKyAobi5jb2xsYXBzZWRJY29uICE9PSBiID8gbi5jb2xsYXBzZWRJY29uIDogai5jb2xsYXBzZWRJY29uKV0gOiBbXFxcInVpLWljb24tXFxcIiArIChuLmV4cGFuZGVkSWNvbiAhPT0gYiA/IG4uZXhwYW5kZWRJY29uIDogai5leHBhbmRlZEljb24pXSkuam9pbihcXFwiIFxcXCIpKSksIG4udGhlbWUgIT09IGIgJiYgKGYgPSB0aGlzLl90aGVtZUNsYXNzRnJvbU9wdGlvbihcXFwidWktYnRuLVxcXCIsIGoudGhlbWUpLCBlID0gdGhpcy5fdGhlbWVDbGFzc0Zyb21PcHRpb24oXFxcInVpLWJ0bi1cXFwiLCBuLnRoZW1lKSwgbC5yZW1vdmVDbGFzcyhmKS5hZGRDbGFzcyhlKSksIG4uY29udGVudFRoZW1lICE9PSBiICYmIChmID0gdGhpcy5fdGhlbWVDbGFzc0Zyb21PcHRpb24oXFxcInVpLWJvZHktXFxcIiwgai5jb250ZW50VGhlbWUpLCBlID0gdGhpcy5fdGhlbWVDbGFzc0Zyb21PcHRpb24oXFxcInVpLWJvZHktXFxcIiwgbi5jb250ZW50VGhlbWUpLCBrLmNvbnRlbnQucmVtb3ZlQ2xhc3MoZikuYWRkQ2xhc3MoZSkpLCBuLmluc2V0ICE9PSBiICYmIChpLnRvZ2dsZUNsYXNzKFxcXCJ1aS1jb2xsYXBzaWJsZS1pbnNldFxcXCIsIG4uaW5zZXQpLCBnID0gISghbi5pbnNldCB8fCAhbi5jb3JuZXJzICYmICFqLmNvcm5lcnMpKSwgbi5jb3JuZXJzICE9PSBiICYmIChnID0gISghbi5jb3JuZXJzIHx8ICFuLmluc2V0ICYmICFqLmluc2V0KSksIGcgIT09IGIgJiYgaS50b2dnbGVDbGFzcyhcXFwidWktY29ybmVyLWFsbFxcXCIsIGcpLCBuLm1pbmkgIT09IGIgJiYgbC50b2dnbGVDbGFzcyhcXFwidWktbWluaVxcXCIsIG4ubWluaSk7XFxuICAgICAgfSwgX3NldE9wdGlvbnM6IGZ1bmN0aW9uIF9zZXRPcHRpb25zKGEpIHtcXG4gICAgICAgIHRoaXMuX2FwcGx5T3B0aW9ucyhhKSwgdGhpcy5fc3VwZXIoYSksIHRoaXMuX3JlbmRlcmVkT3B0aW9ucyA9IHRoaXMuX2dldE9wdGlvbnModGhpcy5vcHRpb25zKTtcXG4gICAgICB9LCBfaGFuZGxlRXhwYW5kQ29sbGFwc2U6IGZ1bmN0aW9uIF9oYW5kbGVFeHBhbmRDb2xsYXBzZShiKSB7XFxuICAgICAgICB2YXIgYyA9IHRoaXMuX3JlbmRlcmVkT3B0aW9ucyxcXG4gICAgICAgICAgICBkID0gdGhpcy5fdWk7ZC5zdGF0dXMudGV4dChiID8gYy5leHBhbmRDdWVUZXh0IDogYy5jb2xsYXBzZUN1ZVRleHQpLCBkLmhlYWRpbmcudG9nZ2xlQ2xhc3MoXFxcInVpLWNvbGxhcHNpYmxlLWhlYWRpbmctY29sbGFwc2VkXFxcIiwgYikuZmluZChcXFwiYVxcXCIpLmZpcnN0KCkudG9nZ2xlQ2xhc3MoXFxcInVpLWljb24tXFxcIiArIGMuZXhwYW5kZWRJY29uLCAhYikudG9nZ2xlQ2xhc3MoXFxcInVpLWljb24tXFxcIiArIGMuY29sbGFwc2VkSWNvbiwgYiB8fCBjLmV4cGFuZGVkSWNvbiA9PT0gYy5jb2xsYXBzZWRJY29uKS5yZW1vdmVDbGFzcyhhLm1vYmlsZS5hY3RpdmVCdG5DbGFzcyksIHRoaXMuZWxlbWVudC50b2dnbGVDbGFzcyhcXFwidWktY29sbGFwc2libGUtY29sbGFwc2VkXFxcIiwgYiksIGQuY29udGVudC50b2dnbGVDbGFzcyhcXFwidWktY29sbGFwc2libGUtY29udGVudC1jb2xsYXBzZWRcXFwiLCBiKS5hdHRyKFxcXCJhcmlhLWhpZGRlblxcXCIsIGIpLnRyaWdnZXIoXFxcInVwZGF0ZWxheW91dFxcXCIpLCB0aGlzLm9wdGlvbnMuY29sbGFwc2VkID0gYiwgdGhpcy5fdHJpZ2dlcihiID8gXFxcImNvbGxhcHNlXFxcIiA6IFxcXCJleHBhbmRcXFwiKTtcXG4gICAgICB9LCBleHBhbmQ6IGZ1bmN0aW9uIGV4cGFuZCgpIHtcXG4gICAgICAgIHRoaXMuX2hhbmRsZUV4cGFuZENvbGxhcHNlKCExKTtcXG4gICAgICB9LCBjb2xsYXBzZTogZnVuY3Rpb24gY29sbGFwc2UoKSB7XFxuICAgICAgICB0aGlzLl9oYW5kbGVFeHBhbmRDb2xsYXBzZSghMCk7XFxuICAgICAgfSwgX2Rlc3Ryb3k6IGZ1bmN0aW9uIF9kZXN0cm95KCkge1xcbiAgICAgICAgdmFyIGEgPSB0aGlzLl91aSxcXG4gICAgICAgICAgICBiID0gdGhpcy5vcHRpb25zO2IuZW5oYW5jZWQgfHwgKGEucGxhY2Vob2xkZXIgPyAoYS5vcmlnaW5hbEhlYWRpbmcuaW5zZXJ0QmVmb3JlKGEucGxhY2Vob2xkZXIpLCBhLnBsYWNlaG9sZGVyLnJlbW92ZSgpLCBhLmhlYWRpbmcucmVtb3ZlKCkpIDogKGEuc3RhdHVzLnJlbW92ZSgpLCBhLmhlYWRpbmcucmVtb3ZlQ2xhc3MoXFxcInVpLWNvbGxhcHNpYmxlLWhlYWRpbmcgdWktY29sbGFwc2libGUtaGVhZGluZy1jb2xsYXBzZWRcXFwiKS5jaGlsZHJlbigpLmNvbnRlbnRzKCkudW53cmFwKCkpLCBhLmFuY2hvci5jb250ZW50cygpLnVud3JhcCgpLCBhLmNvbnRlbnQuY29udGVudHMoKS51bndyYXAoKSwgdGhpcy5lbGVtZW50LnJlbW92ZUNsYXNzKFxcXCJ1aS1jb2xsYXBzaWJsZSB1aS1jb2xsYXBzaWJsZS1jb2xsYXBzZWQgdWktY29sbGFwc2libGUtdGhlbWVkLWNvbnRlbnQgdWktY29sbGFwc2libGUtaW5zZXQgdWktY29ybmVyLWFsbFxcXCIpKTtcXG4gICAgICB9IH0pLCBhLm1vYmlsZS5jb2xsYXBzaWJsZS5kZWZhdWx0cyA9IHsgZXhwYW5kQ3VlVGV4dDogXFxcIiBjbGljayB0byBleHBhbmQgY29udGVudHNcXFwiLCBjb2xsYXBzZUN1ZVRleHQ6IFxcXCIgY2xpY2sgdG8gY29sbGFwc2UgY29udGVudHNcXFwiLCBjb2xsYXBzZWRJY29uOiBcXFwicGx1c1xcXCIsIGNvbnRlbnRUaGVtZTogXFxcImluaGVyaXRcXFwiLCBleHBhbmRlZEljb246IFxcXCJtaW51c1xcXCIsIGljb25wb3M6IFxcXCJsZWZ0XFxcIiwgaW5zZXQ6ICEwLCBjb3JuZXJzOiAhMCwgdGhlbWU6IFxcXCJpbmhlcml0XFxcIiwgbWluaTogITEgfTtcXG4gIH0oYSksIGZ1bmN0aW9uIChhKSB7XFxuICAgIGZ1bmN0aW9uIGIoYikge1xcbiAgICAgIHZhciBkLFxcbiAgICAgICAgICBlID0gYi5sZW5ndGgsXFxuICAgICAgICAgIGYgPSBbXTtmb3IgKGQgPSAwOyBlID4gZDsgZCsrKSB7XFxuICAgICAgICBiW2RdLmNsYXNzTmFtZS5tYXRjaChjKSB8fCBmLnB1c2goYltkXSk7XFxuICAgICAgfXJldHVybiBhKGYpO1xcbiAgICB9dmFyIGMgPSAvXFxcXGJ1aS1zY3JlZW4taGlkZGVuXFxcXGIvO2EubW9iaWxlLmJlaGF2aW9ycy5hZGRGaXJzdExhc3RDbGFzc2VzID0geyBfZ2V0VmlzaWJsZXM6IGZ1bmN0aW9uIF9nZXRWaXNpYmxlcyhhLCBjKSB7XFxuICAgICAgICB2YXIgZDtyZXR1cm4gYyA/IGQgPSBiKGEpIDogKGQgPSBhLmZpbHRlcihcXFwiOnZpc2libGVcXFwiKSwgMCA9PT0gZC5sZW5ndGggJiYgKGQgPSBiKGEpKSksIGQ7XFxuICAgICAgfSwgX2FkZEZpcnN0TGFzdENsYXNzZXM6IGZ1bmN0aW9uIF9hZGRGaXJzdExhc3RDbGFzc2VzKGEsIGIsIGMpIHtcXG4gICAgICAgIGEucmVtb3ZlQ2xhc3MoXFxcInVpLWZpcnN0LWNoaWxkIHVpLWxhc3QtY2hpbGRcXFwiKSwgYi5lcSgwKS5hZGRDbGFzcyhcXFwidWktZmlyc3QtY2hpbGRcXFwiKS5lbmQoKS5sYXN0KCkuYWRkQ2xhc3MoXFxcInVpLWxhc3QtY2hpbGRcXFwiKSwgYyB8fCB0aGlzLmVsZW1lbnQudHJpZ2dlcihcXFwidXBkYXRlbGF5b3V0XFxcIik7XFxuICAgICAgfSwgX3JlbW92ZUZpcnN0TGFzdENsYXNzZXM6IGZ1bmN0aW9uIF9yZW1vdmVGaXJzdExhc3RDbGFzc2VzKGEpIHtcXG4gICAgICAgIGEucmVtb3ZlQ2xhc3MoXFxcInVpLWZpcnN0LWNoaWxkIHVpLWxhc3QtY2hpbGRcXFwiKTtcXG4gICAgICB9IH07XFxuICB9KGEpLCBmdW5jdGlvbiAoYSwgYikge1xcbiAgICB2YXIgYyA9IFxcXCI6bW9iaWxlLWNvbGxhcHNpYmxlLCBcXFwiICsgYS5tb2JpbGUuY29sbGFwc2libGUuaW5pdFNlbGVjdG9yO2Eud2lkZ2V0KFxcXCJtb2JpbGUuY29sbGFwc2libGVzZXRcXFwiLCBhLmV4dGVuZCh7IGluaXRTZWxlY3RvcjogXFxcIjpqcW1EYXRhKHJvbGU9J2NvbGxhcHNpYmxlLXNldCcpLDpqcW1EYXRhKHJvbGU9J2NvbGxhcHNpYmxlc2V0JylcXFwiLCBvcHRpb25zOiBhLmV4dGVuZCh7IGVuaGFuY2VkOiAhMSB9LCBhLm1vYmlsZS5jb2xsYXBzaWJsZS5kZWZhdWx0cyksIF9oYW5kbGVDb2xsYXBzaWJsZUV4cGFuZDogZnVuY3Rpb24gX2hhbmRsZUNvbGxhcHNpYmxlRXhwYW5kKGIpIHtcXG4gICAgICAgIHZhciBjID0gYShiLnRhcmdldCkuY2xvc2VzdChcXFwiLnVpLWNvbGxhcHNpYmxlXFxcIik7Yy5wYXJlbnQoKS5pcyhcXFwiOm1vYmlsZS1jb2xsYXBzaWJsZXNldCwgOmpxbURhdGEocm9sZT0nY29sbGFwc2libGUtc2V0JylcXFwiKSAmJiBjLnNpYmxpbmdzKFxcXCIudWktY29sbGFwc2libGU6bm90KC51aS1jb2xsYXBzaWJsZS1jb2xsYXBzZWQpXFxcIikuY29sbGFwc2libGUoXFxcImNvbGxhcHNlXFxcIik7XFxuICAgICAgfSwgX2NyZWF0ZTogZnVuY3Rpb24gX2NyZWF0ZSgpIHtcXG4gICAgICAgIHZhciBiID0gdGhpcy5lbGVtZW50LFxcbiAgICAgICAgICAgIGMgPSB0aGlzLm9wdGlvbnM7YS5leHRlbmQodGhpcywgeyBfY2xhc3NlczogXFxcIlxcXCIgfSksIGMuZW5oYW5jZWQgfHwgKGIuYWRkQ2xhc3MoXFxcInVpLWNvbGxhcHNpYmxlLXNldCBcXFwiICsgdGhpcy5fdGhlbWVDbGFzc0Zyb21PcHRpb24oXFxcInVpLWdyb3VwLXRoZW1lLVxcXCIsIGMudGhlbWUpICsgXFxcIiBcXFwiICsgKGMuY29ybmVycyAmJiBjLmluc2V0ID8gXFxcInVpLWNvcm5lci1hbGwgXFxcIiA6IFxcXCJcXFwiKSksIHRoaXMuZWxlbWVudC5maW5kKGEubW9iaWxlLmNvbGxhcHNpYmxlLmluaXRTZWxlY3RvcikuY29sbGFwc2libGUoKSksIHRoaXMuX29uKGIsIHsgY29sbGFwc2libGVleHBhbmQ6IFxcXCJfaGFuZGxlQ29sbGFwc2libGVFeHBhbmRcXFwiIH0pO1xcbiAgICAgIH0sIF90aGVtZUNsYXNzRnJvbU9wdGlvbjogZnVuY3Rpb24gX3RoZW1lQ2xhc3NGcm9tT3B0aW9uKGEsIGIpIHtcXG4gICAgICAgIHJldHVybiBiID8gXFxcIm5vbmVcXFwiID09PSBiID8gXFxcIlxcXCIgOiBhICsgYiA6IFxcXCJcXFwiO1xcbiAgICAgIH0sIF9pbml0OiBmdW5jdGlvbiBfaW5pdCgpIHtcXG4gICAgICAgIHRoaXMuX3JlZnJlc2goITApLCB0aGlzLmVsZW1lbnQuY2hpbGRyZW4oYykuZmlsdGVyKFxcXCI6anFtRGF0YShjb2xsYXBzZWQ9J2ZhbHNlJylcXFwiKS5jb2xsYXBzaWJsZShcXFwiZXhwYW5kXFxcIik7XFxuICAgICAgfSwgX3NldE9wdGlvbnM6IGZ1bmN0aW9uIF9zZXRPcHRpb25zKGEpIHtcXG4gICAgICAgIHZhciBjLFxcbiAgICAgICAgICAgIGQsXFxuICAgICAgICAgICAgZSA9IHRoaXMuZWxlbWVudCxcXG4gICAgICAgICAgICBmID0gdGhpcy5fdGhlbWVDbGFzc0Zyb21PcHRpb24oXFxcInVpLWdyb3VwLXRoZW1lLVxcXCIsIGEudGhlbWUpO3JldHVybiBmICYmIGUucmVtb3ZlQ2xhc3ModGhpcy5fdGhlbWVDbGFzc0Zyb21PcHRpb24oXFxcInVpLWdyb3VwLXRoZW1lLVxcXCIsIHRoaXMub3B0aW9ucy50aGVtZSkpLmFkZENsYXNzKGYpLCBhLmluc2V0ICE9PSBiICYmIChkID0gISghYS5pbnNldCB8fCAhYS5jb3JuZXJzICYmICF0aGlzLm9wdGlvbnMuY29ybmVycykpLCBhLmNvcm5lcnMgIT09IGIgJiYgKGQgPSAhKCFhLmNvcm5lcnMgfHwgIWEuaW5zZXQgJiYgIXRoaXMub3B0aW9ucy5pbnNldCkpLCBkICE9PSBiICYmIGUudG9nZ2xlQ2xhc3MoXFxcInVpLWNvcm5lci1hbGxcXFwiLCBkKSwgYyA9IHRoaXMuX3N1cGVyKGEpLCB0aGlzLmVsZW1lbnQuY2hpbGRyZW4oXFxcIjptb2JpbGUtY29sbGFwc2libGVcXFwiKS5jb2xsYXBzaWJsZShcXFwicmVmcmVzaFxcXCIpLCBjO1xcbiAgICAgIH0sIF9kZXN0cm95OiBmdW5jdGlvbiBfZGVzdHJveSgpIHtcXG4gICAgICAgIHZhciBhID0gdGhpcy5lbGVtZW50O3RoaXMuX3JlbW92ZUZpcnN0TGFzdENsYXNzZXMoYS5jaGlsZHJlbihjKSksIGEucmVtb3ZlQ2xhc3MoXFxcInVpLWNvbGxhcHNpYmxlLXNldCB1aS1jb3JuZXItYWxsIFxcXCIgKyB0aGlzLl90aGVtZUNsYXNzRnJvbU9wdGlvbihcXFwidWktZ3JvdXAtdGhlbWUtXFxcIiwgdGhpcy5vcHRpb25zLnRoZW1lKSkuY2hpbGRyZW4oXFxcIjptb2JpbGUtY29sbGFwc2libGVcXFwiKS5jb2xsYXBzaWJsZShcXFwiZGVzdHJveVxcXCIpO1xcbiAgICAgIH0sIF9yZWZyZXNoOiBmdW5jdGlvbiBfcmVmcmVzaChiKSB7XFxuICAgICAgICB2YXIgZCA9IHRoaXMuZWxlbWVudC5jaGlsZHJlbihjKTt0aGlzLmVsZW1lbnQuZmluZChhLm1vYmlsZS5jb2xsYXBzaWJsZS5pbml0U2VsZWN0b3IpLm5vdChcXFwiLnVpLWNvbGxhcHNpYmxlXFxcIikuY29sbGFwc2libGUoKSwgdGhpcy5fYWRkRmlyc3RMYXN0Q2xhc3NlcyhkLCB0aGlzLl9nZXRWaXNpYmxlcyhkLCBiKSwgYik7XFxuICAgICAgfSwgcmVmcmVzaDogZnVuY3Rpb24gcmVmcmVzaCgpIHtcXG4gICAgICAgIHRoaXMuX3JlZnJlc2goITEpO1xcbiAgICAgIH0gfSwgYS5tb2JpbGUuYmVoYXZpb3JzLmFkZEZpcnN0TGFzdENsYXNzZXMpKTtcXG4gIH0oYSksIGZ1bmN0aW9uIChhKSB7XFxuICAgIGEuZm4uZmllbGRjb250YWluID0gZnVuY3Rpb24gKCkge1xcbiAgICAgIHJldHVybiB0aGlzLmFkZENsYXNzKFxcXCJ1aS1maWVsZC1jb250YWluXFxcIik7XFxuICAgIH07XFxuICB9KGEpLCBmdW5jdGlvbiAoYSkge1xcbiAgICBhLmZuLmdyaWQgPSBmdW5jdGlvbiAoYikge1xcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIGMsXFxuICAgICAgICAgICAgZCxcXG4gICAgICAgICAgICBlID0gYSh0aGlzKSxcXG4gICAgICAgICAgICBmID0gYS5leHRlbmQoeyBncmlkOiBudWxsIH0sIGIpLFxcbiAgICAgICAgICAgIGcgPSBlLmNoaWxkcmVuKCksXFxuICAgICAgICAgICAgaCA9IHsgc29sbzogMSwgYTogMiwgYjogMywgYzogNCwgZDogNSB9LFxcbiAgICAgICAgICAgIGkgPSBmLmdyaWQ7aWYgKCFpKSBpZiAoZy5sZW5ndGggPD0gNSkgZm9yIChkIGluIGgpIHtcXG4gICAgICAgICAgaFtkXSA9PT0gZy5sZW5ndGggJiYgKGkgPSBkKTtcXG4gICAgICAgIH0gZWxzZSBpID0gXFxcImFcXFwiLCBlLmFkZENsYXNzKFxcXCJ1aS1ncmlkLWR1b1xcXCIpO2MgPSBoW2ldLCBlLmFkZENsYXNzKFxcXCJ1aS1ncmlkLVxcXCIgKyBpKSwgZy5maWx0ZXIoXFxcIjpudGgtY2hpbGQoXFxcIiArIGMgKyBcXFwibisxKVxcXCIpLmFkZENsYXNzKFxcXCJ1aS1ibG9jay1hXFxcIiksIGMgPiAxICYmIGcuZmlsdGVyKFxcXCI6bnRoLWNoaWxkKFxcXCIgKyBjICsgXFxcIm4rMilcXFwiKS5hZGRDbGFzcyhcXFwidWktYmxvY2stYlxcXCIpLCBjID4gMiAmJiBnLmZpbHRlcihcXFwiOm50aC1jaGlsZChcXFwiICsgYyArIFxcXCJuKzMpXFxcIikuYWRkQ2xhc3MoXFxcInVpLWJsb2NrLWNcXFwiKSwgYyA+IDMgJiYgZy5maWx0ZXIoXFxcIjpudGgtY2hpbGQoXFxcIiArIGMgKyBcXFwibis0KVxcXCIpLmFkZENsYXNzKFxcXCJ1aS1ibG9jay1kXFxcIiksIGMgPiA0ICYmIGcuZmlsdGVyKFxcXCI6bnRoLWNoaWxkKFxcXCIgKyBjICsgXFxcIm4rNSlcXFwiKS5hZGRDbGFzcyhcXFwidWktYmxvY2stZVxcXCIpO1xcbiAgICAgIH0pO1xcbiAgICB9O1xcbiAgfShhKSwgZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgYS53aWRnZXQoXFxcIm1vYmlsZS5uYXZiYXJcXFwiLCB7IG9wdGlvbnM6IHsgaWNvbnBvczogXFxcInRvcFxcXCIsIGdyaWQ6IG51bGwgfSwgX2NyZWF0ZTogZnVuY3Rpb24gX2NyZWF0ZSgpIHtcXG4gICAgICAgIHZhciBkID0gdGhpcy5lbGVtZW50LFxcbiAgICAgICAgICAgIGUgPSBkLmZpbmQoXFxcImEsIGJ1dHRvblxcXCIpLFxcbiAgICAgICAgICAgIGYgPSBlLmZpbHRlcihcXFwiOmpxbURhdGEoaWNvbilcXFwiKS5sZW5ndGggPyB0aGlzLm9wdGlvbnMuaWNvbnBvcyA6IGI7ZC5hZGRDbGFzcyhcXFwidWktbmF2YmFyXFxcIikuYXR0cihcXFwicm9sZVxcXCIsIFxcXCJuYXZpZ2F0aW9uXFxcIikuZmluZChcXFwidWxcXFwiKS5qcW1FbmhhbmNlYWJsZSgpLmdyaWQoeyBncmlkOiB0aGlzLm9wdGlvbnMuZ3JpZCB9KSwgZS5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgdmFyIGIgPSBhLm1vYmlsZS5nZXRBdHRyaWJ1dGUodGhpcywgXFxcImljb25cXFwiKSxcXG4gICAgICAgICAgICAgIGMgPSBhLm1vYmlsZS5nZXRBdHRyaWJ1dGUodGhpcywgXFxcInRoZW1lXFxcIiksXFxuICAgICAgICAgICAgICBkID0gXFxcInVpLWJ0blxcXCI7YyAmJiAoZCArPSBcXFwiIHVpLWJ0bi1cXFwiICsgYyksIGIgJiYgKGQgKz0gXFxcIiB1aS1pY29uLVxcXCIgKyBiICsgXFxcIiB1aS1idG4taWNvbi1cXFwiICsgZiksIGEodGhpcykuYWRkQ2xhc3MoZCk7XFxuICAgICAgICB9KSwgZC5kZWxlZ2F0ZShcXFwiYVxcXCIsIFxcXCJ2Y2xpY2tcXFwiLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHZhciBiID0gYSh0aGlzKTtiLmhhc0NsYXNzKFxcXCJ1aS1zdGF0ZS1kaXNhYmxlZFxcXCIpIHx8IGIuaGFzQ2xhc3MoXFxcInVpLWRpc2FibGVkXFxcIikgfHwgYi5oYXNDbGFzcyhhLm1vYmlsZS5hY3RpdmVCdG5DbGFzcykgfHwgKGUucmVtb3ZlQ2xhc3MoYS5tb2JpbGUuYWN0aXZlQnRuQ2xhc3MpLCBiLmFkZENsYXNzKGEubW9iaWxlLmFjdGl2ZUJ0bkNsYXNzKSwgYShjKS5vbmUoXFxcInBhZ2VoaWRlXFxcIiwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIGIucmVtb3ZlQ2xhc3MoYS5tb2JpbGUuYWN0aXZlQnRuQ2xhc3MpO1xcbiAgICAgICAgICB9KSk7XFxuICAgICAgICB9KSwgZC5jbG9zZXN0KFxcXCIudWktcGFnZVxcXCIpLmJpbmQoXFxcInBhZ2ViZWZvcmVzaG93XFxcIiwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBlLmZpbHRlcihcXFwiLnVpLXN0YXRlLXBlcnNpc3RcXFwiKS5hZGRDbGFzcyhhLm1vYmlsZS5hY3RpdmVCdG5DbGFzcyk7XFxuICAgICAgICB9KTtcXG4gICAgICB9IH0pO1xcbiAgfShhKSwgZnVuY3Rpb24gKGEpIHtcXG4gICAgdmFyIGIgPSBhLm1vYmlsZS5nZXRBdHRyaWJ1dGU7YS53aWRnZXQoXFxcIm1vYmlsZS5saXN0dmlld1xcXCIsIGEuZXh0ZW5kKHsgb3B0aW9uczogeyB0aGVtZTogbnVsbCwgY291bnRUaGVtZTogbnVsbCwgZGl2aWRlclRoZW1lOiBudWxsLCBpY29uOiBcXFwiY2FyYXQtclxcXCIsIHNwbGl0SWNvbjogXFxcImNhcmF0LXJcXFwiLCBzcGxpdFRoZW1lOiBudWxsLCBjb3JuZXJzOiAhMCwgc2hhZG93OiAhMCwgaW5zZXQ6ICExIH0sIF9jcmVhdGU6IGZ1bmN0aW9uIF9jcmVhdGUoKSB7XFxuICAgICAgICB2YXIgYSA9IHRoaXMsXFxuICAgICAgICAgICAgYiA9IFxcXCJcXFwiO2IgKz0gYS5vcHRpb25zLmluc2V0ID8gXFxcIiB1aS1saXN0dmlldy1pbnNldFxcXCIgOiBcXFwiXFxcIiwgYS5vcHRpb25zLmluc2V0ICYmIChiICs9IGEub3B0aW9ucy5jb3JuZXJzID8gXFxcIiB1aS1jb3JuZXItYWxsXFxcIiA6IFxcXCJcXFwiLCBiICs9IGEub3B0aW9ucy5zaGFkb3cgPyBcXFwiIHVpLXNoYWRvd1xcXCIgOiBcXFwiXFxcIiksIGEuZWxlbWVudC5hZGRDbGFzcyhcXFwiIHVpLWxpc3R2aWV3XFxcIiArIGIpLCBhLnJlZnJlc2goITApO1xcbiAgICAgIH0sIF9maW5kRmlyc3RFbGVtZW50QnlUYWdOYW1lOiBmdW5jdGlvbiBfZmluZEZpcnN0RWxlbWVudEJ5VGFnTmFtZShhLCBiLCBjLCBkKSB7XFxuICAgICAgICB2YXIgZSA9IHt9O2ZvciAoZVtjXSA9IGVbZF0gPSAhMDsgYTspIHtcXG4gICAgICAgICAgaWYgKGVbYS5ub2RlTmFtZV0pIHJldHVybiBhO2EgPSBhW2JdO1xcbiAgICAgICAgfXJldHVybiBudWxsO1xcbiAgICAgIH0sIF9hZGRUaHVtYkNsYXNzZXM6IGZ1bmN0aW9uIF9hZGRUaHVtYkNsYXNzZXMoYikge1xcbiAgICAgICAgdmFyIGMsXFxuICAgICAgICAgICAgZCxcXG4gICAgICAgICAgICBlID0gYi5sZW5ndGg7Zm9yIChjID0gMDsgZSA+IGM7IGMrKykge1xcbiAgICAgICAgICBkID0gYSh0aGlzLl9maW5kRmlyc3RFbGVtZW50QnlUYWdOYW1lKGJbY10uZmlyc3RDaGlsZCwgXFxcIm5leHRTaWJsaW5nXFxcIiwgXFxcImltZ1xcXCIsIFxcXCJJTUdcXFwiKSksIGQubGVuZ3RoICYmIGEodGhpcy5fZmluZEZpcnN0RWxlbWVudEJ5VGFnTmFtZShkWzBdLnBhcmVudE5vZGUsIFxcXCJwYXJlbnROb2RlXFxcIiwgXFxcImxpXFxcIiwgXFxcIkxJXFxcIikpLmFkZENsYXNzKGQuaGFzQ2xhc3MoXFxcInVpLWxpLWljb25cXFwiKSA/IFxcXCJ1aS1saS1oYXMtaWNvblxcXCIgOiBcXFwidWktbGktaGFzLXRodW1iXFxcIik7XFxuICAgICAgICB9XFxuICAgICAgfSwgX2dldENoaWxkcmVuQnlUYWdOYW1lOiBmdW5jdGlvbiBfZ2V0Q2hpbGRyZW5CeVRhZ05hbWUoYiwgYywgZCkge1xcbiAgICAgICAgdmFyIGUgPSBbXSxcXG4gICAgICAgICAgICBmID0ge307Zm9yIChmW2NdID0gZltkXSA9ICEwLCBiID0gYi5maXJzdENoaWxkOyBiOykge1xcbiAgICAgICAgICBmW2Iubm9kZU5hbWVdICYmIGUucHVzaChiKSwgYiA9IGIubmV4dFNpYmxpbmc7XFxuICAgICAgICB9cmV0dXJuIGEoZSk7XFxuICAgICAgfSwgX2JlZm9yZUxpc3R2aWV3UmVmcmVzaDogYS5ub29wLCBfYWZ0ZXJMaXN0dmlld1JlZnJlc2g6IGEubm9vcCwgcmVmcmVzaDogZnVuY3Rpb24gcmVmcmVzaChjKSB7XFxuICAgICAgICB2YXIgZCxcXG4gICAgICAgICAgICBlLFxcbiAgICAgICAgICAgIGYsXFxuICAgICAgICAgICAgZyxcXG4gICAgICAgICAgICBoLFxcbiAgICAgICAgICAgIGksXFxuICAgICAgICAgICAgaixcXG4gICAgICAgICAgICBrLFxcbiAgICAgICAgICAgIGwsXFxuICAgICAgICAgICAgbSxcXG4gICAgICAgICAgICBuLFxcbiAgICAgICAgICAgIG8sXFxuICAgICAgICAgICAgcCxcXG4gICAgICAgICAgICBxLFxcbiAgICAgICAgICAgIHIsXFxuICAgICAgICAgICAgcyxcXG4gICAgICAgICAgICB0LFxcbiAgICAgICAgICAgIHUsXFxuICAgICAgICAgICAgdixcXG4gICAgICAgICAgICB3LFxcbiAgICAgICAgICAgIHggPSB0aGlzLm9wdGlvbnMsXFxuICAgICAgICAgICAgeSA9IHRoaXMuZWxlbWVudCxcXG4gICAgICAgICAgICB6ID0gISFhLm5vZGVOYW1lKHlbMF0sIFxcXCJvbFxcXCIpLFxcbiAgICAgICAgICAgIEEgPSB5LmF0dHIoXFxcInN0YXJ0XFxcIiksXFxuICAgICAgICAgICAgQiA9IHt9LFxcbiAgICAgICAgICAgIEMgPSB5LmZpbmQoXFxcIi51aS1saS1jb3VudFxcXCIpLFxcbiAgICAgICAgICAgIEQgPSBiKHlbMF0sIFxcXCJjb3VudHRoZW1lXFxcIikgfHwgdGhpcy5vcHRpb25zLmNvdW50VGhlbWUsXFxuICAgICAgICAgICAgRSA9IEQgPyBcXFwidWktYm9keS1cXFwiICsgRCA6IFxcXCJ1aS1ib2R5LWluaGVyaXRcXFwiO2ZvciAoeC50aGVtZSAmJiB5LmFkZENsYXNzKFxcXCJ1aS1ncm91cC10aGVtZS1cXFwiICsgeC50aGVtZSksIHogJiYgKEEgfHwgMCA9PT0gQSkgJiYgKG4gPSBwYXJzZUludChBLCAxMCkgLSAxLCB5LmNzcyhcXFwiY291bnRlci1yZXNldFxcXCIsIFxcXCJsaXN0bnVtYmVyaW5nIFxcXCIgKyBuKSksIHRoaXMuX2JlZm9yZUxpc3R2aWV3UmVmcmVzaCgpLCB3ID0gdGhpcy5fZ2V0Q2hpbGRyZW5CeVRhZ05hbWUoeVswXSwgXFxcImxpXFxcIiwgXFxcIkxJXFxcIiksIGUgPSAwLCBmID0gdy5sZW5ndGg7IGYgPiBlOyBlKyspIHtcXG4gICAgICAgICAgZyA9IHcuZXEoZSksIGggPSBcXFwiXFxcIiwgKGMgfHwgZ1swXS5jbGFzc05hbWUuc2VhcmNoKC9cXFxcYnVpLWxpLXN0YXRpY1xcXFxifFxcXFxidWktbGktZGl2aWRlclxcXFxiLykgPCAwKSAmJiAobCA9IHRoaXMuX2dldENoaWxkcmVuQnlUYWdOYW1lKGdbMF0sIFxcXCJhXFxcIiwgXFxcIkFcXFwiKSwgbSA9IFxcXCJsaXN0LWRpdmlkZXJcXFwiID09PSBiKGdbMF0sIFxcXCJyb2xlXFxcIiksIHAgPSBnLmF0dHIoXFxcInZhbHVlXFxcIiksIGkgPSBiKGdbMF0sIFxcXCJ0aGVtZVxcXCIpLCBsLmxlbmd0aCAmJiBsWzBdLmNsYXNzTmFtZS5zZWFyY2goL1xcXFxidWktYnRuXFxcXGIvKSA8IDAgJiYgIW0gPyAoaiA9IGIoZ1swXSwgXFxcImljb25cXFwiKSwgayA9IGogPT09ICExID8gITEgOiBqIHx8IHguaWNvbiwgbC5yZW1vdmVDbGFzcyhcXFwidWktbGlua1xcXCIpLCBkID0gXFxcInVpLWJ0blxcXCIsIGkgJiYgKGQgKz0gXFxcIiB1aS1idG4tXFxcIiArIGkpLCBsLmxlbmd0aCA+IDEgPyAoaCA9IFxcXCJ1aS1saS1oYXMtYWx0XFxcIiwgcSA9IGwubGFzdCgpLCByID0gYihxWzBdLCBcXFwidGhlbWVcXFwiKSB8fCB4LnNwbGl0VGhlbWUgfHwgYihnWzBdLCBcXFwidGhlbWVcXFwiLCAhMCksIHMgPSByID8gXFxcIiB1aS1idG4tXFxcIiArIHIgOiBcXFwiXFxcIiwgdCA9IGIocVswXSwgXFxcImljb25cXFwiKSB8fCBiKGdbMF0sIFxcXCJpY29uXFxcIikgfHwgeC5zcGxpdEljb24sIHUgPSBcXFwidWktYnRuIHVpLWJ0bi1pY29uLW5vdGV4dCB1aS1pY29uLVxcXCIgKyB0ICsgcywgcS5hdHRyKFxcXCJ0aXRsZVxcXCIsIGEudHJpbShxLmdldEVuY29kZWRUZXh0KCkpKS5hZGRDbGFzcyh1KS5lbXB0eSgpLCBsID0gbC5maXJzdCgpKSA6IGsgJiYgKGQgKz0gXFxcIiB1aS1idG4taWNvbi1yaWdodCB1aS1pY29uLVxcXCIgKyBrKSwgbC5hZGRDbGFzcyhkKSkgOiBtID8gKHYgPSBiKGdbMF0sIFxcXCJ0aGVtZVxcXCIpIHx8IHguZGl2aWRlclRoZW1lIHx8IHgudGhlbWUsIGggPSBcXFwidWktbGktZGl2aWRlciB1aS1iYXItXFxcIiArICh2ID8gdiA6IFxcXCJpbmhlcml0XFxcIiksIGcuYXR0cihcXFwicm9sZVxcXCIsIFxcXCJoZWFkaW5nXFxcIikpIDogbC5sZW5ndGggPD0gMCAmJiAoaCA9IFxcXCJ1aS1saS1zdGF0aWMgdWktYm9keS1cXFwiICsgKGkgPyBpIDogXFxcImluaGVyaXRcXFwiKSksIHogJiYgcCAmJiAobyA9IHBhcnNlSW50KHAsIDEwKSAtIDEsIGcuY3NzKFxcXCJjb3VudGVyLXJlc2V0XFxcIiwgXFxcImxpc3RudW1iZXJpbmcgXFxcIiArIG8pKSksIEJbaF0gfHwgKEJbaF0gPSBbXSksIEJbaF0ucHVzaChnWzBdKTtcXG4gICAgICAgIH1mb3IgKGggaW4gQikge1xcbiAgICAgICAgICBhKEJbaF0pLmFkZENsYXNzKGgpO1xcbiAgICAgICAgfUMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIGEodGhpcykuY2xvc2VzdChcXFwibGlcXFwiKS5hZGRDbGFzcyhcXFwidWktbGktaGFzLWNvdW50XFxcIik7XFxuICAgICAgICB9KSwgRSAmJiBDLm5vdChcXFwiW2NsYXNzKj0ndWktYm9keS0nXVxcXCIpLmFkZENsYXNzKEUpLCB0aGlzLl9hZGRUaHVtYkNsYXNzZXModyksIHRoaXMuX2FkZFRodW1iQ2xhc3Nlcyh3LmZpbmQoXFxcIi51aS1idG5cXFwiKSksIHRoaXMuX2FmdGVyTGlzdHZpZXdSZWZyZXNoKCksIHRoaXMuX2FkZEZpcnN0TGFzdENsYXNzZXModywgdGhpcy5fZ2V0VmlzaWJsZXModywgYyksIGMpO1xcbiAgICAgIH0gfSwgYS5tb2JpbGUuYmVoYXZpb3JzLmFkZEZpcnN0TGFzdENsYXNzZXMpKTtcXG4gIH0oYSksIGZ1bmN0aW9uIChhKSB7XFxuICAgIGZ1bmN0aW9uIGIoYikge1xcbiAgICAgIHZhciBjID0gYS50cmltKGIudGV4dCgpKSB8fCBudWxsO3JldHVybiBjID8gYyA9IGMuc2xpY2UoMCwgMSkudG9VcHBlckNhc2UoKSA6IG51bGw7XFxuICAgIH1hLndpZGdldChcXFwibW9iaWxlLmxpc3R2aWV3XFxcIiwgYS5tb2JpbGUubGlzdHZpZXcsIHsgb3B0aW9uczogeyBhdXRvZGl2aWRlcnM6ICExLCBhdXRvZGl2aWRlcnNTZWxlY3RvcjogYiB9LCBfYmVmb3JlTGlzdHZpZXdSZWZyZXNoOiBmdW5jdGlvbiBfYmVmb3JlTGlzdHZpZXdSZWZyZXNoKCkge1xcbiAgICAgICAgdGhpcy5vcHRpb25zLmF1dG9kaXZpZGVycyAmJiAodGhpcy5fcmVwbGFjZURpdmlkZXJzKCksIHRoaXMuX3N1cGVyQXBwbHkoYXJndW1lbnRzKSk7XFxuICAgICAgfSwgX3JlcGxhY2VEaXZpZGVyczogZnVuY3Rpb24gX3JlcGxhY2VEaXZpZGVycygpIHtcXG4gICAgICAgIHZhciBiLFxcbiAgICAgICAgICAgIGQsXFxuICAgICAgICAgICAgZSxcXG4gICAgICAgICAgICBmLFxcbiAgICAgICAgICAgIGcsXFxuICAgICAgICAgICAgaCA9IG51bGwsXFxuICAgICAgICAgICAgaSA9IHRoaXMuZWxlbWVudDtmb3IgKGkuY2hpbGRyZW4oXFxcImxpOmpxbURhdGEocm9sZT0nbGlzdC1kaXZpZGVyJylcXFwiKS5yZW1vdmUoKSwgZCA9IGkuY2hpbGRyZW4oXFxcImxpXFxcIiksIGIgPSAwOyBiIDwgZC5sZW5ndGg7IGIrKykge1xcbiAgICAgICAgICBlID0gZFtiXSwgZiA9IHRoaXMub3B0aW9ucy5hdXRvZGl2aWRlcnNTZWxlY3RvcihhKGUpKSwgZiAmJiBoICE9PSBmICYmIChnID0gYy5jcmVhdGVFbGVtZW50KFxcXCJsaVxcXCIpLCBnLmFwcGVuZENoaWxkKGMuY3JlYXRlVGV4dE5vZGUoZikpLCBnLnNldEF0dHJpYnV0ZShcXFwiZGF0YS1cXFwiICsgYS5tb2JpbGUubnMgKyBcXFwicm9sZVxcXCIsIFxcXCJsaXN0LWRpdmlkZXJcXFwiKSwgZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShnLCBlKSksIGggPSBmO1xcbiAgICAgICAgfVxcbiAgICAgIH0gfSk7XFxuICB9KGEpLCBmdW5jdGlvbiAoYSkge1xcbiAgICB2YXIgYiA9IC8oXnxcXFxccyl1aS1saS1kaXZpZGVyKCR8XFxcXHMpLyxcXG4gICAgICAgIGMgPSAvKF58XFxcXHMpdWktc2NyZWVuLWhpZGRlbigkfFxcXFxzKS87YS53aWRnZXQoXFxcIm1vYmlsZS5saXN0dmlld1xcXCIsIGEubW9iaWxlLmxpc3R2aWV3LCB7IG9wdGlvbnM6IHsgaGlkZURpdmlkZXJzOiAhMSB9LCBfYWZ0ZXJMaXN0dmlld1JlZnJlc2g6IGZ1bmN0aW9uIF9hZnRlckxpc3R2aWV3UmVmcmVzaCgpIHtcXG4gICAgICAgIHZhciBhLFxcbiAgICAgICAgICAgIGQsXFxuICAgICAgICAgICAgZSxcXG4gICAgICAgICAgICBmID0gITA7aWYgKHRoaXMuX3N1cGVyQXBwbHkoYXJndW1lbnRzKSwgdGhpcy5vcHRpb25zLmhpZGVEaXZpZGVycykgZm9yIChhID0gdGhpcy5fZ2V0Q2hpbGRyZW5CeVRhZ05hbWUodGhpcy5lbGVtZW50WzBdLCBcXFwibGlcXFwiLCBcXFwiTElcXFwiKSwgZCA9IGEubGVuZ3RoIC0gMTsgZCA+IC0xOyBkLS0pIHtcXG4gICAgICAgICAgZSA9IGFbZF0sIGUuY2xhc3NOYW1lLm1hdGNoKGIpID8gKGYgJiYgKGUuY2xhc3NOYW1lID0gZS5jbGFzc05hbWUgKyBcXFwiIHVpLXNjcmVlbi1oaWRkZW5cXFwiKSwgZiA9ICEwKSA6IGUuY2xhc3NOYW1lLm1hdGNoKGMpIHx8IChmID0gITEpO1xcbiAgICAgICAgfVxcbiAgICAgIH0gfSk7XFxuICB9KGEpLCBmdW5jdGlvbiAoYSkge1xcbiAgICBhLm1vYmlsZS5ub2pzID0gZnVuY3Rpb24gKGIpIHtcXG4gICAgICBhKFxcXCI6anFtRGF0YShyb2xlPSdub2pzJylcXFwiLCBiKS5hZGRDbGFzcyhcXFwidWktbm9qc1xcXCIpO1xcbiAgICB9O1xcbiAgfShhKSwgZnVuY3Rpb24gKGEpIHtcXG4gICAgYS5tb2JpbGUuYmVoYXZpb3JzLmZvcm1SZXNldCA9IHsgX2hhbmRsZUZvcm1SZXNldDogZnVuY3Rpb24gX2hhbmRsZUZvcm1SZXNldCgpIHtcXG4gICAgICAgIHRoaXMuX29uKHRoaXMuZWxlbWVudC5jbG9zZXN0KFxcXCJmb3JtXFxcIiksIHsgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0KCkge1xcbiAgICAgICAgICAgIHRoaXMuX2RlbGF5KFxcXCJfcmVzZXRcXFwiKTtcXG4gICAgICAgICAgfSB9KTtcXG4gICAgICB9IH07XFxuICB9KGEpLCBmdW5jdGlvbiAoYSwgYikge1xcbiAgICB2YXIgYyA9IGEubW9iaWxlLnBhdGguaGFzaFRvU2VsZWN0b3I7YS53aWRnZXQoXFxcIm1vYmlsZS5jaGVja2JveHJhZGlvXFxcIiwgYS5leHRlbmQoeyBpbml0U2VsZWN0b3I6IFxcXCJpbnB1dDpub3QoIDpqcW1EYXRhKHJvbGU9J2ZsaXBzd2l0Y2gnICkgKVt0eXBlPSdjaGVja2JveCddLGlucHV0W3R5cGU9J3JhZGlvJ106bm90KCA6anFtRGF0YShyb2xlPSdmbGlwc3dpdGNoJyApKVxcXCIsIG9wdGlvbnM6IHsgdGhlbWU6IFxcXCJpbmhlcml0XFxcIiwgbWluaTogITEsIHdyYXBwZXJDbGFzczogbnVsbCwgZW5oYW5jZWQ6ICExLCBpY29ucG9zOiBcXFwibGVmdFxcXCIgfSwgX2NyZWF0ZTogZnVuY3Rpb24gX2NyZWF0ZSgpIHtcXG4gICAgICAgIHZhciBiID0gdGhpcy5lbGVtZW50LFxcbiAgICAgICAgICAgIGMgPSB0aGlzLm9wdGlvbnMsXFxuICAgICAgICAgICAgZCA9IGZ1bmN0aW9uIGQoYSwgYikge1xcbiAgICAgICAgICByZXR1cm4gYS5qcW1EYXRhKGIpIHx8IGEuY2xvc2VzdChcXFwiZm9ybSwgZmllbGRzZXRcXFwiKS5qcW1EYXRhKGIpO1xcbiAgICAgICAgfSxcXG4gICAgICAgICAgICBlID0gdGhpcy5vcHRpb25zLmVuaGFuY2VkID8geyBlbGVtZW50OiB0aGlzLmVsZW1lbnQuc2libGluZ3MoXFxcImxhYmVsXFxcIiksIGlzUGFyZW50OiAhMSB9IDogdGhpcy5fZmluZExhYmVsKCksXFxuICAgICAgICAgICAgZiA9IGJbMF0udHlwZSxcXG4gICAgICAgICAgICBnID0gXFxcInVpLVxcXCIgKyBmICsgXFxcIi1vblxcXCIsXFxuICAgICAgICAgICAgaCA9IFxcXCJ1aS1cXFwiICsgZiArIFxcXCItb2ZmXFxcIjsoXFxcImNoZWNrYm94XFxcIiA9PT0gZiB8fCBcXFwicmFkaW9cXFwiID09PSBmKSAmJiAodGhpcy5lbGVtZW50WzBdLmRpc2FibGVkICYmICh0aGlzLm9wdGlvbnMuZGlzYWJsZWQgPSAhMCksIGMuaWNvbnBvcyA9IGQoYiwgXFxcImljb25wb3NcXFwiKSB8fCBlLmVsZW1lbnQuYXR0cihcXFwiZGF0YS1cXFwiICsgYS5tb2JpbGUubnMgKyBcXFwiaWNvbnBvc1xcXCIpIHx8IGMuaWNvbnBvcywgYy5taW5pID0gZChiLCBcXFwibWluaVxcXCIpIHx8IGMubWluaSwgYS5leHRlbmQodGhpcywgeyBpbnB1dDogYiwgbGFiZWw6IGUuZWxlbWVudCwgbGFiZWxJc1BhcmVudDogZS5pc1BhcmVudCwgaW5wdXR0eXBlOiBmLCBjaGVja2VkQ2xhc3M6IGcsIHVuY2hlY2tlZENsYXNzOiBoIH0pLCB0aGlzLm9wdGlvbnMuZW5oYW5jZWQgfHwgdGhpcy5fZW5oYW5jZSgpLCB0aGlzLl9vbihlLmVsZW1lbnQsIHsgdm1vdXNlb3ZlcjogXFxcIl9oYW5kbGVMYWJlbFZNb3VzZU92ZXJcXFwiLCB2Y2xpY2s6IFxcXCJfaGFuZGxlTGFiZWxWQ2xpY2tcXFwiIH0pLCB0aGlzLl9vbihiLCB7IHZtb3VzZWRvd246IFxcXCJfY2FjaGVWYWxzXFxcIiwgdmNsaWNrOiBcXFwiX2hhbmRsZUlucHV0VkNsaWNrXFxcIiwgZm9jdXM6IFxcXCJfaGFuZGxlSW5wdXRGb2N1c1xcXCIsIGJsdXI6IFxcXCJfaGFuZGxlSW5wdXRCbHVyXFxcIiB9KSwgdGhpcy5faGFuZGxlRm9ybVJlc2V0KCksIHRoaXMucmVmcmVzaCgpKTtcXG4gICAgICB9LCBfZmluZExhYmVsOiBmdW5jdGlvbiBfZmluZExhYmVsKCkge1xcbiAgICAgICAgdmFyIGIsXFxuICAgICAgICAgICAgZCxcXG4gICAgICAgICAgICBlLFxcbiAgICAgICAgICAgIGYgPSB0aGlzLmVsZW1lbnQsXFxuICAgICAgICAgICAgZyA9IGZbMF0ubGFiZWxzO3JldHVybiBnICYmIGcubGVuZ3RoID4gMCA/IChkID0gYShnWzBdKSwgZSA9IGEuY29udGFpbnMoZFswXSwgZlswXSkpIDogKGIgPSBmLmNsb3Nlc3QoXFxcImxhYmVsXFxcIiksIGUgPSBiLmxlbmd0aCA+IDAsIGQgPSBlID8gYiA6IGEodGhpcy5kb2N1bWVudFswXS5nZXRFbGVtZW50c0J5VGFnTmFtZShcXFwibGFiZWxcXFwiKSkuZmlsdGVyKFxcXCJbZm9yPSdcXFwiICsgYyhmWzBdLmlkKSArIFxcXCInXVxcXCIpLmZpcnN0KCkpLCB7IGVsZW1lbnQ6IGQsIGlzUGFyZW50OiBlIH07XFxuICAgICAgfSwgX2VuaGFuY2U6IGZ1bmN0aW9uIF9lbmhhbmNlKCkge1xcbiAgICAgICAgdGhpcy5sYWJlbC5hZGRDbGFzcyhcXFwidWktYnRuIHVpLWNvcm5lci1hbGxcXFwiKSwgdGhpcy5sYWJlbElzUGFyZW50ID8gdGhpcy5pbnB1dC5hZGQodGhpcy5sYWJlbCkud3JhcEFsbCh0aGlzLl93cmFwcGVyKCkpIDogKHRoaXMuZWxlbWVudC53cmFwKHRoaXMuX3dyYXBwZXIoKSksIHRoaXMuZWxlbWVudC5wYXJlbnQoKS5wcmVwZW5kKHRoaXMubGFiZWwpKSwgdGhpcy5fc2V0T3B0aW9ucyh7IHRoZW1lOiB0aGlzLm9wdGlvbnMudGhlbWUsIGljb25wb3M6IHRoaXMub3B0aW9ucy5pY29ucG9zLCBtaW5pOiB0aGlzLm9wdGlvbnMubWluaSB9KTtcXG4gICAgICB9LCBfd3JhcHBlcjogZnVuY3Rpb24gX3dyYXBwZXIoKSB7XFxuICAgICAgICByZXR1cm4gYShcXFwiPGRpdiBjbGFzcz0nXFxcIiArICh0aGlzLm9wdGlvbnMud3JhcHBlckNsYXNzID8gdGhpcy5vcHRpb25zLndyYXBwZXJDbGFzcyA6IFxcXCJcXFwiKSArIFxcXCIgdWktXFxcIiArIHRoaXMuaW5wdXR0eXBlICsgKHRoaXMub3B0aW9ucy5kaXNhYmxlZCA/IFxcXCIgdWktc3RhdGUtZGlzYWJsZWRcXFwiIDogXFxcIlxcXCIpICsgXFxcIicgPjwvZGl2PlxcXCIpO1xcbiAgICAgIH0sIF9oYW5kbGVJbnB1dEZvY3VzOiBmdW5jdGlvbiBfaGFuZGxlSW5wdXRGb2N1cygpIHtcXG4gICAgICAgIHRoaXMubGFiZWwuYWRkQ2xhc3MoYS5tb2JpbGUuZm9jdXNDbGFzcyk7XFxuICAgICAgfSwgX2hhbmRsZUlucHV0Qmx1cjogZnVuY3Rpb24gX2hhbmRsZUlucHV0Qmx1cigpIHtcXG4gICAgICAgIHRoaXMubGFiZWwucmVtb3ZlQ2xhc3MoYS5tb2JpbGUuZm9jdXNDbGFzcyk7XFxuICAgICAgfSwgX2hhbmRsZUlucHV0VkNsaWNrOiBmdW5jdGlvbiBfaGFuZGxlSW5wdXRWQ2xpY2soKSB7XFxuICAgICAgICB0aGlzLmVsZW1lbnQucHJvcChcXFwiY2hlY2tlZFxcXCIsIHRoaXMuZWxlbWVudC5pcyhcXFwiOmNoZWNrZWRcXFwiKSksIHRoaXMuX2dldElucHV0U2V0KCkubm90KHRoaXMuZWxlbWVudCkucHJvcChcXFwiY2hlY2tlZFxcXCIsICExKSwgdGhpcy5fdXBkYXRlQWxsKCEwKTtcXG4gICAgICB9LCBfaGFuZGxlTGFiZWxWTW91c2VPdmVyOiBmdW5jdGlvbiBfaGFuZGxlTGFiZWxWTW91c2VPdmVyKGEpIHtcXG4gICAgICAgIHRoaXMubGFiZWwucGFyZW50KCkuaGFzQ2xhc3MoXFxcInVpLXN0YXRlLWRpc2FibGVkXFxcIikgJiYgYS5zdG9wUHJvcGFnYXRpb24oKTtcXG4gICAgICB9LCBfaGFuZGxlTGFiZWxWQ2xpY2s6IGZ1bmN0aW9uIF9oYW5kbGVMYWJlbFZDbGljayhhKSB7XFxuICAgICAgICB2YXIgYiA9IHRoaXMuZWxlbWVudDtyZXR1cm4gYi5pcyhcXFwiOmRpc2FibGVkXFxcIikgPyB2b2lkIGEucHJldmVudERlZmF1bHQoKSA6ICh0aGlzLl9jYWNoZVZhbHMoKSwgYi5wcm9wKFxcXCJjaGVja2VkXFxcIiwgXFxcInJhZGlvXFxcIiA9PT0gdGhpcy5pbnB1dHR5cGUgJiYgITAgfHwgIWIucHJvcChcXFwiY2hlY2tlZFxcXCIpKSwgYi50cmlnZ2VySGFuZGxlcihcXFwiY2xpY2tcXFwiKSwgdGhpcy5fZ2V0SW5wdXRTZXQoKS5ub3QoYikucHJvcChcXFwiY2hlY2tlZFxcXCIsICExKSwgdGhpcy5fdXBkYXRlQWxsKCksICExKTtcXG4gICAgICB9LCBfY2FjaGVWYWxzOiBmdW5jdGlvbiBfY2FjaGVWYWxzKCkge1xcbiAgICAgICAgdGhpcy5fZ2V0SW5wdXRTZXQoKS5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgYSh0aGlzKS5hdHRyKFxcXCJkYXRhLVxcXCIgKyBhLm1vYmlsZS5ucyArIFxcXCJjYWNoZVZhbFxcXCIsIHRoaXMuY2hlY2tlZCk7XFxuICAgICAgICB9KTtcXG4gICAgICB9LCBfZ2V0SW5wdXRTZXQ6IGZ1bmN0aW9uIF9nZXRJbnB1dFNldCgpIHtcXG4gICAgICAgIHZhciBiLFxcbiAgICAgICAgICAgIGQsXFxuICAgICAgICAgICAgZSA9IHRoaXMuZWxlbWVudFswXSxcXG4gICAgICAgICAgICBmID0gZS5uYW1lLFxcbiAgICAgICAgICAgIGcgPSBlLmZvcm0sXFxuICAgICAgICAgICAgaCA9IHRoaXMuZWxlbWVudC5wYXJlbnRzKCkubGFzdCgpLmdldCgwKSxcXG4gICAgICAgICAgICBpID0gdGhpcy5lbGVtZW50O3JldHVybiBmICYmIFxcXCJyYWRpb1xcXCIgPT09IHRoaXMuaW5wdXR0eXBlICYmIGggJiYgKGIgPSBcXFwiaW5wdXRbdHlwZT0ncmFkaW8nXVtuYW1lPSdcXFwiICsgYyhmKSArIFxcXCInXVxcXCIsIGcgPyAoZCA9IGcuZ2V0QXR0cmlidXRlKFxcXCJpZFxcXCIpLCBkICYmIChpID0gYShiICsgXFxcIltmb3JtPSdcXFwiICsgYyhkKSArIFxcXCInXVxcXCIsIGgpKSwgaSA9IGEoZykuZmluZChiKS5maWx0ZXIoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtID09PSBnO1xcbiAgICAgICAgfSkuYWRkKGkpKSA6IGkgPSBhKGIsIGgpLmZpbHRlcihmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHJldHVybiAhdGhpcy5mb3JtO1xcbiAgICAgICAgfSkpLCBpO1xcbiAgICAgIH0sIF91cGRhdGVBbGw6IGZ1bmN0aW9uIF91cGRhdGVBbGwoYikge1xcbiAgICAgICAgdmFyIGMgPSB0aGlzO3RoaXMuX2dldElucHV0U2V0KCkuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHZhciBkID0gYSh0aGlzKTshdGhpcy5jaGVja2VkICYmIFxcXCJjaGVja2JveFxcXCIgIT09IGMuaW5wdXR0eXBlIHx8IGIgfHwgZC50cmlnZ2VyKFxcXCJjaGFuZ2VcXFwiKTtcXG4gICAgICAgIH0pLmNoZWNrYm94cmFkaW8oXFxcInJlZnJlc2hcXFwiKTtcXG4gICAgICB9LCBfcmVzZXQ6IGZ1bmN0aW9uIF9yZXNldCgpIHtcXG4gICAgICAgIHRoaXMucmVmcmVzaCgpO1xcbiAgICAgIH0sIF9oYXNJY29uOiBmdW5jdGlvbiBfaGFzSWNvbigpIHtcXG4gICAgICAgIHZhciBiLFxcbiAgICAgICAgICAgIGMsXFxuICAgICAgICAgICAgZCA9IGEubW9iaWxlLmNvbnRyb2xncm91cDtyZXR1cm4gZCAmJiAoYiA9IHRoaXMuZWxlbWVudC5jbG9zZXN0KFxcXCI6bW9iaWxlLWNvbnRyb2xncm91cCxcXFwiICsgZC5wcm90b3R5cGUuaW5pdFNlbGVjdG9yKSwgYi5sZW5ndGggPiAwKSA/IChjID0gYS5kYXRhKGJbMF0sIFxcXCJtb2JpbGUtY29udHJvbGdyb3VwXFxcIiksIFxcXCJob3Jpem9udGFsXFxcIiAhPT0gKGMgPyBjLm9wdGlvbnMudHlwZSA6IGIuYXR0cihcXFwiZGF0YS1cXFwiICsgYS5tb2JpbGUubnMgKyBcXFwidHlwZVxcXCIpKSkgOiAhMDtcXG4gICAgICB9LCByZWZyZXNoOiBmdW5jdGlvbiByZWZyZXNoKCkge1xcbiAgICAgICAgdmFyIGIgPSB0aGlzLmVsZW1lbnRbMF0uY2hlY2tlZCxcXG4gICAgICAgICAgICBjID0gYS5tb2JpbGUuYWN0aXZlQnRuQ2xhc3MsXFxuICAgICAgICAgICAgZCA9IFxcXCJ1aS1idG4taWNvbi1cXFwiICsgdGhpcy5vcHRpb25zLmljb25wb3MsXFxuICAgICAgICAgICAgZSA9IFtdLFxcbiAgICAgICAgICAgIGYgPSBbXTt0aGlzLl9oYXNJY29uKCkgPyAoZi5wdXNoKGMpLCBlLnB1c2goZCkpIDogKGYucHVzaChkKSwgKGIgPyBlIDogZikucHVzaChjKSksIGIgPyAoZS5wdXNoKHRoaXMuY2hlY2tlZENsYXNzKSwgZi5wdXNoKHRoaXMudW5jaGVja2VkQ2xhc3MpKSA6IChlLnB1c2godGhpcy51bmNoZWNrZWRDbGFzcyksIGYucHVzaCh0aGlzLmNoZWNrZWRDbGFzcykpLCB0aGlzLndpZGdldCgpLnRvZ2dsZUNsYXNzKFxcXCJ1aS1zdGF0ZS1kaXNhYmxlZFxcXCIsIHRoaXMuZWxlbWVudC5wcm9wKFxcXCJkaXNhYmxlZFxcXCIpKSwgdGhpcy5sYWJlbC5hZGRDbGFzcyhlLmpvaW4oXFxcIiBcXFwiKSkucmVtb3ZlQ2xhc3MoZi5qb2luKFxcXCIgXFxcIikpO1xcbiAgICAgIH0sIHdpZGdldDogZnVuY3Rpb24gd2lkZ2V0KCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMubGFiZWwucGFyZW50KCk7XFxuICAgICAgfSwgX3NldE9wdGlvbnM6IGZ1bmN0aW9uIF9zZXRPcHRpb25zKGEpIHtcXG4gICAgICAgIHZhciBjID0gdGhpcy5sYWJlbCxcXG4gICAgICAgICAgICBkID0gdGhpcy5vcHRpb25zLFxcbiAgICAgICAgICAgIGUgPSB0aGlzLndpZGdldCgpLFxcbiAgICAgICAgICAgIGYgPSB0aGlzLl9oYXNJY29uKCk7YS5kaXNhYmxlZCAhPT0gYiAmJiAodGhpcy5pbnB1dC5wcm9wKFxcXCJkaXNhYmxlZFxcXCIsICEhYS5kaXNhYmxlZCksIGUudG9nZ2xlQ2xhc3MoXFxcInVpLXN0YXRlLWRpc2FibGVkXFxcIiwgISFhLmRpc2FibGVkKSksIGEubWluaSAhPT0gYiAmJiBlLnRvZ2dsZUNsYXNzKFxcXCJ1aS1taW5pXFxcIiwgISFhLm1pbmkpLCBhLnRoZW1lICE9PSBiICYmIGMucmVtb3ZlQ2xhc3MoXFxcInVpLWJ0bi1cXFwiICsgZC50aGVtZSkuYWRkQ2xhc3MoXFxcInVpLWJ0bi1cXFwiICsgYS50aGVtZSksIGEud3JhcHBlckNsYXNzICE9PSBiICYmIGUucmVtb3ZlQ2xhc3MoZC53cmFwcGVyQ2xhc3MpLmFkZENsYXNzKGEud3JhcHBlckNsYXNzKSwgYS5pY29ucG9zICE9PSBiICYmIGYgPyBjLnJlbW92ZUNsYXNzKFxcXCJ1aS1idG4taWNvbi1cXFwiICsgZC5pY29ucG9zKS5hZGRDbGFzcyhcXFwidWktYnRuLWljb24tXFxcIiArIGEuaWNvbnBvcykgOiBmIHx8IGMucmVtb3ZlQ2xhc3MoXFxcInVpLWJ0bi1pY29uLVxcXCIgKyBkLmljb25wb3MpLCB0aGlzLl9zdXBlcihhKTtcXG4gICAgICB9IH0sIGEubW9iaWxlLmJlaGF2aW9ycy5mb3JtUmVzZXQpKTtcXG4gIH0oYSksIGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgIGEud2lkZ2V0KFxcXCJtb2JpbGUuYnV0dG9uXFxcIiwgeyBpbml0U2VsZWN0b3I6IFxcXCJpbnB1dFt0eXBlPSdidXR0b24nXSwgaW5wdXRbdHlwZT0nc3VibWl0J10sIGlucHV0W3R5cGU9J3Jlc2V0J11cXFwiLCBvcHRpb25zOiB7IHRoZW1lOiBudWxsLCBpY29uOiBudWxsLCBpY29ucG9zOiBcXFwibGVmdFxcXCIsIGljb25zaGFkb3c6ICExLCBjb3JuZXJzOiAhMCwgc2hhZG93OiAhMCwgaW5saW5lOiBudWxsLCBtaW5pOiBudWxsLCB3cmFwcGVyQ2xhc3M6IG51bGwsIGVuaGFuY2VkOiAhMSB9LCBfY3JlYXRlOiBmdW5jdGlvbiBfY3JlYXRlKCkge1xcbiAgICAgICAgdGhpcy5lbGVtZW50LmlzKFxcXCI6ZGlzYWJsZWRcXFwiKSAmJiAodGhpcy5vcHRpb25zLmRpc2FibGVkID0gITApLCB0aGlzLm9wdGlvbnMuZW5oYW5jZWQgfHwgdGhpcy5fZW5oYW5jZSgpLCBhLmV4dGVuZCh0aGlzLCB7IHdyYXBwZXI6IHRoaXMuZWxlbWVudC5wYXJlbnQoKSB9KSwgdGhpcy5fb24oeyBmb2N1czogZnVuY3Rpb24gZm9jdXMoKSB7XFxuICAgICAgICAgICAgdGhpcy53aWRnZXQoKS5hZGRDbGFzcyhhLm1vYmlsZS5mb2N1c0NsYXNzKTtcXG4gICAgICAgICAgfSwgYmx1cjogZnVuY3Rpb24gYmx1cigpIHtcXG4gICAgICAgICAgICB0aGlzLndpZGdldCgpLnJlbW92ZUNsYXNzKGEubW9iaWxlLmZvY3VzQ2xhc3MpO1xcbiAgICAgICAgICB9IH0pLCB0aGlzLnJlZnJlc2goITApO1xcbiAgICAgIH0sIF9lbmhhbmNlOiBmdW5jdGlvbiBfZW5oYW5jZSgpIHtcXG4gICAgICAgIHRoaXMuZWxlbWVudC53cmFwKHRoaXMuX2J1dHRvbigpKTtcXG4gICAgICB9LCBfYnV0dG9uOiBmdW5jdGlvbiBfYnV0dG9uKCkge1xcbiAgICAgICAgdmFyIGIgPSB0aGlzLm9wdGlvbnMsXFxuICAgICAgICAgICAgYyA9IHRoaXMuX2dldEljb25DbGFzc2VzKHRoaXMub3B0aW9ucyk7cmV0dXJuIGEoXFxcIjxkaXYgY2xhc3M9J3VpLWJ0biB1aS1pbnB1dC1idG5cXFwiICsgKGIud3JhcHBlckNsYXNzID8gXFxcIiBcXFwiICsgYi53cmFwcGVyQ2xhc3MgOiBcXFwiXFxcIikgKyAoYi50aGVtZSA/IFxcXCIgdWktYnRuLVxcXCIgKyBiLnRoZW1lIDogXFxcIlxcXCIpICsgKGIuY29ybmVycyA/IFxcXCIgdWktY29ybmVyLWFsbFxcXCIgOiBcXFwiXFxcIikgKyAoYi5zaGFkb3cgPyBcXFwiIHVpLXNoYWRvd1xcXCIgOiBcXFwiXFxcIikgKyAoYi5pbmxpbmUgPyBcXFwiIHVpLWJ0bi1pbmxpbmVcXFwiIDogXFxcIlxcXCIpICsgKGIubWluaSA/IFxcXCIgdWktbWluaVxcXCIgOiBcXFwiXFxcIikgKyAoYi5kaXNhYmxlZCA/IFxcXCIgdWktc3RhdGUtZGlzYWJsZWRcXFwiIDogXFxcIlxcXCIpICsgKGMgPyBcXFwiIFxcXCIgKyBjIDogXFxcIlxcXCIpICsgXFxcIicgPlxcXCIgKyB0aGlzLmVsZW1lbnQudmFsKCkgKyBcXFwiPC9kaXY+XFxcIik7XFxuICAgICAgfSwgd2lkZ2V0OiBmdW5jdGlvbiB3aWRnZXQoKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy53cmFwcGVyO1xcbiAgICAgIH0sIF9kZXN0cm95OiBmdW5jdGlvbiBfZGVzdHJveSgpIHtcXG4gICAgICAgIHRoaXMuZWxlbWVudC5pbnNlcnRCZWZvcmUodGhpcy53cmFwcGVyKSwgdGhpcy53cmFwcGVyLnJlbW92ZSgpO1xcbiAgICAgIH0sIF9nZXRJY29uQ2xhc3NlczogZnVuY3Rpb24gX2dldEljb25DbGFzc2VzKGEpIHtcXG4gICAgICAgIHJldHVybiBhLmljb24gPyBcXFwidWktaWNvbi1cXFwiICsgYS5pY29uICsgKGEuaWNvbnNoYWRvdyA/IFxcXCIgdWktc2hhZG93LWljb25cXFwiIDogXFxcIlxcXCIpICsgXFxcIiB1aS1idG4taWNvbi1cXFwiICsgYS5pY29ucG9zIDogXFxcIlxcXCI7XFxuICAgICAgfSwgX3NldE9wdGlvbnM6IGZ1bmN0aW9uIF9zZXRPcHRpb25zKGMpIHtcXG4gICAgICAgIHZhciBkID0gdGhpcy53aWRnZXQoKTtjLnRoZW1lICE9PSBiICYmIGQucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLnRoZW1lKS5hZGRDbGFzcyhcXFwidWktYnRuLVxcXCIgKyBjLnRoZW1lKSwgYy5jb3JuZXJzICE9PSBiICYmIGQudG9nZ2xlQ2xhc3MoXFxcInVpLWNvcm5lci1hbGxcXFwiLCBjLmNvcm5lcnMpLCBjLnNoYWRvdyAhPT0gYiAmJiBkLnRvZ2dsZUNsYXNzKFxcXCJ1aS1zaGFkb3dcXFwiLCBjLnNoYWRvdyksIGMuaW5saW5lICE9PSBiICYmIGQudG9nZ2xlQ2xhc3MoXFxcInVpLWJ0bi1pbmxpbmVcXFwiLCBjLmlubGluZSksIGMubWluaSAhPT0gYiAmJiBkLnRvZ2dsZUNsYXNzKFxcXCJ1aS1taW5pXFxcIiwgYy5taW5pKSwgYy5kaXNhYmxlZCAhPT0gYiAmJiAodGhpcy5lbGVtZW50LnByb3AoXFxcImRpc2FibGVkXFxcIiwgYy5kaXNhYmxlZCksIGQudG9nZ2xlQ2xhc3MoXFxcInVpLXN0YXRlLWRpc2FibGVkXFxcIiwgYy5kaXNhYmxlZCkpLCAoYy5pY29uICE9PSBiIHx8IGMuaWNvbnNoYWRvdyAhPT0gYiB8fCBjLmljb25wb3MgIT09IGIpICYmIGQucmVtb3ZlQ2xhc3ModGhpcy5fZ2V0SWNvbkNsYXNzZXModGhpcy5vcHRpb25zKSkuYWRkQ2xhc3ModGhpcy5fZ2V0SWNvbkNsYXNzZXMoYS5leHRlbmQoe30sIHRoaXMub3B0aW9ucywgYykpKSwgdGhpcy5fc3VwZXIoYyk7XFxuICAgICAgfSwgcmVmcmVzaDogZnVuY3Rpb24gcmVmcmVzaChiKSB7XFxuICAgICAgICB2YXIgYyxcXG4gICAgICAgICAgICBkID0gdGhpcy5lbGVtZW50LnByb3AoXFxcImRpc2FibGVkXFxcIik7dGhpcy5vcHRpb25zLmljb24gJiYgXFxcIm5vdGV4dFxcXCIgPT09IHRoaXMub3B0aW9ucy5pY29ucG9zICYmIHRoaXMuZWxlbWVudC5hdHRyKFxcXCJ0aXRsZVxcXCIpICYmIHRoaXMuZWxlbWVudC5hdHRyKFxcXCJ0aXRsZVxcXCIsIHRoaXMuZWxlbWVudC52YWwoKSksIGIgfHwgKGMgPSB0aGlzLmVsZW1lbnQuZGV0YWNoKCksIGEodGhpcy53cmFwcGVyKS50ZXh0KHRoaXMuZWxlbWVudC52YWwoKSkuYXBwZW5kKGMpKSwgdGhpcy5vcHRpb25zLmRpc2FibGVkICE9PSBkICYmIHRoaXMuX3NldE9wdGlvbnMoeyBkaXNhYmxlZDogZCB9KTtcXG4gICAgICB9IH0pO1xcbiAgfShhKSwgZnVuY3Rpb24gKGEpIHtcXG4gICAgdmFyIGIgPSBhKFxcXCJtZXRhW25hbWU9dmlld3BvcnRdXFxcIiksXFxuICAgICAgICBjID0gYi5hdHRyKFxcXCJjb250ZW50XFxcIiksXFxuICAgICAgICBkID0gYyArIFxcXCIsbWF4aW11bS1zY2FsZT0xLCB1c2VyLXNjYWxhYmxlPW5vXFxcIixcXG4gICAgICAgIGUgPSBjICsgXFxcIixtYXhpbXVtLXNjYWxlPTEwLCB1c2VyLXNjYWxhYmxlPXllc1xcXCIsXFxuICAgICAgICBmID0gLyh1c2VyLXNjYWxhYmxlW1xcXFxzXSo9W1xcXFxzXSpubyl8KG1heGltdW0tc2NhbGVbXFxcXHNdKj1bXFxcXHNdKjEpWyQsXFxcXHNdLy50ZXN0KGMpO2EubW9iaWxlLnpvb20gPSBhLmV4dGVuZCh7fSwgeyBlbmFibGVkOiAhZiwgbG9ja2VkOiAhMSwgZGlzYWJsZTogZnVuY3Rpb24gZGlzYWJsZShjKSB7XFxuICAgICAgICBmIHx8IGEubW9iaWxlLnpvb20ubG9ja2VkIHx8IChiLmF0dHIoXFxcImNvbnRlbnRcXFwiLCBkKSwgYS5tb2JpbGUuem9vbS5lbmFibGVkID0gITEsIGEubW9iaWxlLnpvb20ubG9ja2VkID0gYyB8fCAhMSk7XFxuICAgICAgfSwgZW5hYmxlOiBmdW5jdGlvbiBlbmFibGUoYykge1xcbiAgICAgICAgZiB8fCBhLm1vYmlsZS56b29tLmxvY2tlZCAmJiBjICE9PSAhMCB8fCAoYi5hdHRyKFxcXCJjb250ZW50XFxcIiwgZSksIGEubW9iaWxlLnpvb20uZW5hYmxlZCA9ICEwLCBhLm1vYmlsZS56b29tLmxvY2tlZCA9ICExKTtcXG4gICAgICB9LCByZXN0b3JlOiBmdW5jdGlvbiByZXN0b3JlKCkge1xcbiAgICAgICAgZiB8fCAoYi5hdHRyKFxcXCJjb250ZW50XFxcIiwgYyksIGEubW9iaWxlLnpvb20uZW5hYmxlZCA9ICEwKTtcXG4gICAgICB9IH0pO1xcbiAgfShhKSwgZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgYS53aWRnZXQoXFxcIm1vYmlsZS50ZXh0aW5wdXRcXFwiLCB7IGluaXRTZWxlY3RvcjogXFxcImlucHV0W3R5cGU9J3RleHQnXSxpbnB1dFt0eXBlPSdzZWFyY2gnXSw6anFtRGF0YSh0eXBlPSdzZWFyY2gnKSxpbnB1dFt0eXBlPSdudW1iZXInXSw6anFtRGF0YSh0eXBlPSdudW1iZXInKSxpbnB1dFt0eXBlPSdwYXNzd29yZCddLGlucHV0W3R5cGU9J2VtYWlsJ10saW5wdXRbdHlwZT0ndXJsJ10saW5wdXRbdHlwZT0ndGVsJ10sdGV4dGFyZWEsaW5wdXRbdHlwZT0ndGltZSddLGlucHV0W3R5cGU9J2RhdGUnXSxpbnB1dFt0eXBlPSdtb250aCddLGlucHV0W3R5cGU9J3dlZWsnXSxpbnB1dFt0eXBlPSdkYXRldGltZSddLGlucHV0W3R5cGU9J2RhdGV0aW1lLWxvY2FsJ10saW5wdXRbdHlwZT0nY29sb3InXSxpbnB1dDpub3QoW3R5cGVdKSxpbnB1dFt0eXBlPSdmaWxlJ11cXFwiLCBvcHRpb25zOiB7IHRoZW1lOiBudWxsLCBjb3JuZXJzOiAhMCwgbWluaTogITEsIHByZXZlbnRGb2N1c1pvb206IC9pUGhvbmV8aVBhZHxpUG9kLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSkgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFxcXCJBcHBsZVdlYktpdFxcXCIpID4gLTEsIHdyYXBwZXJDbGFzczogXFxcIlxcXCIsIGVuaGFuY2VkOiAhMSB9LCBfY3JlYXRlOiBmdW5jdGlvbiBfY3JlYXRlKCkge1xcbiAgICAgICAgdmFyIGIgPSB0aGlzLm9wdGlvbnMsXFxuICAgICAgICAgICAgYyA9IHRoaXMuZWxlbWVudC5pcyhcXFwiW3R5cGU9J3NlYXJjaCddLCA6anFtRGF0YSh0eXBlPSdzZWFyY2gnKVxcXCIpLFxcbiAgICAgICAgICAgIGQgPSBcXFwiVEVYVEFSRUFcXFwiID09PSB0aGlzLmVsZW1lbnRbMF0udGFnTmFtZSxcXG4gICAgICAgICAgICBlID0gdGhpcy5lbGVtZW50LmlzKFxcXCJbZGF0YS1cXFwiICsgKGEubW9iaWxlLm5zIHx8IFxcXCJcXFwiKSArIFxcXCJ0eXBlPSdyYW5nZSddXFxcIiksXFxuICAgICAgICAgICAgZiA9ICh0aGlzLmVsZW1lbnQuaXMoXFxcImlucHV0XFxcIikgfHwgdGhpcy5lbGVtZW50LmlzKFxcXCJbZGF0YS1cXFwiICsgKGEubW9iaWxlLm5zIHx8IFxcXCJcXFwiKSArIFxcXCJ0eXBlPSdzZWFyY2gnXVxcXCIpKSAmJiAhZTt0aGlzLmVsZW1lbnQucHJvcChcXFwiZGlzYWJsZWRcXFwiKSAmJiAoYi5kaXNhYmxlZCA9ICEwKSwgYS5leHRlbmQodGhpcywgeyBjbGFzc2VzOiB0aGlzLl9jbGFzc2VzRnJvbU9wdGlvbnMoKSwgaXNTZWFyY2g6IGMsIGlzVGV4dGFyZWE6IGQsIGlzUmFuZ2U6IGUsIGlucHV0TmVlZHNXcmFwOiBmIH0pLCB0aGlzLl9hdXRvQ29ycmVjdCgpLCBiLmVuaGFuY2VkIHx8IHRoaXMuX2VuaGFuY2UoKSwgdGhpcy5fb24oeyBmb2N1czogXFxcIl9oYW5kbGVGb2N1c1xcXCIsIGJsdXI6IFxcXCJfaGFuZGxlQmx1clxcXCIgfSk7XFxuICAgICAgfSwgcmVmcmVzaDogZnVuY3Rpb24gcmVmcmVzaCgpIHtcXG4gICAgICAgIHRoaXMuc2V0T3B0aW9ucyh7IGRpc2FibGVkOiB0aGlzLmVsZW1lbnQuaXMoXFxcIjpkaXNhYmxlZFxcXCIpIH0pO1xcbiAgICAgIH0sIF9lbmhhbmNlOiBmdW5jdGlvbiBfZW5oYW5jZSgpIHtcXG4gICAgICAgIHZhciBhID0gW107dGhpcy5pc1RleHRhcmVhICYmIGEucHVzaChcXFwidWktaW5wdXQtdGV4dFxcXCIpLCAodGhpcy5pc1RleHRhcmVhIHx8IHRoaXMuaXNSYW5nZSkgJiYgYS5wdXNoKFxcXCJ1aS1zaGFkb3ctaW5zZXRcXFwiKSwgdGhpcy5pbnB1dE5lZWRzV3JhcCA/IHRoaXMuZWxlbWVudC53cmFwKHRoaXMuX3dyYXAoKSkgOiBhID0gYS5jb25jYXQodGhpcy5jbGFzc2VzKSwgdGhpcy5lbGVtZW50LmFkZENsYXNzKGEuam9pbihcXFwiIFxcXCIpKTtcXG4gICAgICB9LCB3aWRnZXQ6IGZ1bmN0aW9uIHdpZGdldCgpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLmlucHV0TmVlZHNXcmFwID8gdGhpcy5lbGVtZW50LnBhcmVudCgpIDogdGhpcy5lbGVtZW50O1xcbiAgICAgIH0sIF9jbGFzc2VzRnJvbU9wdGlvbnM6IGZ1bmN0aW9uIF9jbGFzc2VzRnJvbU9wdGlvbnMoKSB7XFxuICAgICAgICB2YXIgYSA9IHRoaXMub3B0aW9ucyxcXG4gICAgICAgICAgICBiID0gW107cmV0dXJuIGIucHVzaChcXFwidWktYm9keS1cXFwiICsgKG51bGwgPT09IGEudGhlbWUgPyBcXFwiaW5oZXJpdFxcXCIgOiBhLnRoZW1lKSksIGEuY29ybmVycyAmJiBiLnB1c2goXFxcInVpLWNvcm5lci1hbGxcXFwiKSwgYS5taW5pICYmIGIucHVzaChcXFwidWktbWluaVxcXCIpLCBhLmRpc2FibGVkICYmIGIucHVzaChcXFwidWktc3RhdGUtZGlzYWJsZWRcXFwiKSwgYS53cmFwcGVyQ2xhc3MgJiYgYi5wdXNoKGEud3JhcHBlckNsYXNzKSwgYjtcXG4gICAgICB9LCBfd3JhcDogZnVuY3Rpb24gX3dyYXAoKSB7XFxuICAgICAgICByZXR1cm4gYShcXFwiPGRpdiBjbGFzcz0nXFxcIiArICh0aGlzLmlzU2VhcmNoID8gXFxcInVpLWlucHV0LXNlYXJjaCBcXFwiIDogXFxcInVpLWlucHV0LXRleHQgXFxcIikgKyB0aGlzLmNsYXNzZXMuam9pbihcXFwiIFxcXCIpICsgXFxcIiB1aS1zaGFkb3ctaW5zZXQnPjwvZGl2PlxcXCIpO1xcbiAgICAgIH0sIF9hdXRvQ29ycmVjdDogZnVuY3Rpb24gX2F1dG9Db3JyZWN0KCkge1xcbiAgICAgICAgXFxcInVuZGVmaW5lZFxcXCIgPT0gdHlwZW9mIHRoaXMuZWxlbWVudFswXS5hdXRvY29ycmVjdCB8fCBhLnN1cHBvcnQudG91Y2hPdmVyZmxvdyB8fCAodGhpcy5lbGVtZW50WzBdLnNldEF0dHJpYnV0ZShcXFwiYXV0b2NvcnJlY3RcXFwiLCBcXFwib2ZmXFxcIiksIHRoaXMuZWxlbWVudFswXS5zZXRBdHRyaWJ1dGUoXFxcImF1dG9jb21wbGV0ZVxcXCIsIFxcXCJvZmZcXFwiKSk7XFxuICAgICAgfSwgX2hhbmRsZUJsdXI6IGZ1bmN0aW9uIF9oYW5kbGVCbHVyKCkge1xcbiAgICAgICAgdGhpcy53aWRnZXQoKS5yZW1vdmVDbGFzcyhhLm1vYmlsZS5mb2N1c0NsYXNzKSwgdGhpcy5vcHRpb25zLnByZXZlbnRGb2N1c1pvb20gJiYgYS5tb2JpbGUuem9vbS5lbmFibGUoITApO1xcbiAgICAgIH0sIF9oYW5kbGVGb2N1czogZnVuY3Rpb24gX2hhbmRsZUZvY3VzKCkge1xcbiAgICAgICAgdGhpcy5vcHRpb25zLnByZXZlbnRGb2N1c1pvb20gJiYgYS5tb2JpbGUuem9vbS5kaXNhYmxlKCEwKSwgdGhpcy53aWRnZXQoKS5hZGRDbGFzcyhhLm1vYmlsZS5mb2N1c0NsYXNzKTtcXG4gICAgICB9LCBfc2V0T3B0aW9uczogZnVuY3Rpb24gX3NldE9wdGlvbnMoYSkge1xcbiAgICAgICAgdmFyIGMgPSB0aGlzLndpZGdldCgpO3RoaXMuX3N1cGVyKGEpLCAoYS5kaXNhYmxlZCAhPT0gYiB8fCBhLm1pbmkgIT09IGIgfHwgYS5jb3JuZXJzICE9PSBiIHx8IGEudGhlbWUgIT09IGIgfHwgYS53cmFwcGVyQ2xhc3MgIT09IGIpICYmIChjLnJlbW92ZUNsYXNzKHRoaXMuY2xhc3Nlcy5qb2luKFxcXCIgXFxcIikpLCB0aGlzLmNsYXNzZXMgPSB0aGlzLl9jbGFzc2VzRnJvbU9wdGlvbnMoKSwgYy5hZGRDbGFzcyh0aGlzLmNsYXNzZXMuam9pbihcXFwiIFxcXCIpKSksIGEuZGlzYWJsZWQgIT09IGIgJiYgdGhpcy5lbGVtZW50LnByb3AoXFxcImRpc2FibGVkXFxcIiwgISFhLmRpc2FibGVkKTtcXG4gICAgICB9LCBfZGVzdHJveTogZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XFxuICAgICAgICB0aGlzLm9wdGlvbnMuZW5oYW5jZWQgfHwgKHRoaXMuaW5wdXROZWVkc1dyYXAgJiYgdGhpcy5lbGVtZW50LnVud3JhcCgpLCB0aGlzLmVsZW1lbnQucmVtb3ZlQ2xhc3MoXFxcInVpLWlucHV0LXRleHQgXFxcIiArIHRoaXMuY2xhc3Nlcy5qb2luKFxcXCIgXFxcIikpKTtcXG4gICAgICB9IH0pO1xcbiAgfShhKSwgZnVuY3Rpb24gKGEsIGQpIHtcXG4gICAgYS53aWRnZXQoXFxcIm1vYmlsZS5zbGlkZXJcXFwiLCBhLmV4dGVuZCh7IGluaXRTZWxlY3RvcjogXFxcImlucHV0W3R5cGU9J3JhbmdlJ10sIDpqcW1EYXRhKHR5cGU9J3JhbmdlJyksIDpqcW1EYXRhKHJvbGU9J3NsaWRlcicpXFxcIiwgd2lkZ2V0RXZlbnRQcmVmaXg6IFxcXCJzbGlkZVxcXCIsIG9wdGlvbnM6IHsgdGhlbWU6IG51bGwsIHRyYWNrVGhlbWU6IG51bGwsIGNvcm5lcnM6ICEwLCBtaW5pOiAhMSwgaGlnaGxpZ2h0OiAhMSB9LCBfY3JlYXRlOiBmdW5jdGlvbiBfY3JlYXRlKCkge1xcbiAgICAgICAgdmFyIGUsXFxuICAgICAgICAgICAgZixcXG4gICAgICAgICAgICBnLFxcbiAgICAgICAgICAgIGgsXFxuICAgICAgICAgICAgaSxcXG4gICAgICAgICAgICBqLFxcbiAgICAgICAgICAgIGssXFxuICAgICAgICAgICAgbCxcXG4gICAgICAgICAgICBtLFxcbiAgICAgICAgICAgIG4sXFxuICAgICAgICAgICAgbyA9IHRoaXMsXFxuICAgICAgICAgICAgcCA9IHRoaXMuZWxlbWVudCxcXG4gICAgICAgICAgICBxID0gdGhpcy5vcHRpb25zLnRyYWNrVGhlbWUgfHwgYS5tb2JpbGUuZ2V0QXR0cmlidXRlKHBbMF0sIFxcXCJ0aGVtZVxcXCIpLFxcbiAgICAgICAgICAgIHIgPSBxID8gXFxcIiB1aS1iYXItXFxcIiArIHEgOiBcXFwiIHVpLWJhci1pbmhlcml0XFxcIixcXG4gICAgICAgICAgICBzID0gdGhpcy5vcHRpb25zLmNvcm5lcnMgfHwgcC5qcW1EYXRhKFxcXCJjb3JuZXJzXFxcIikgPyBcXFwiIHVpLWNvcm5lci1hbGxcXFwiIDogXFxcIlxcXCIsXFxuICAgICAgICAgICAgdCA9IHRoaXMub3B0aW9ucy5taW5pIHx8IHAuanFtRGF0YShcXFwibWluaVxcXCIpID8gXFxcIiB1aS1taW5pXFxcIiA6IFxcXCJcXFwiLFxcbiAgICAgICAgICAgIHUgPSBwWzBdLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksXFxuICAgICAgICAgICAgdiA9IFxcXCJzZWxlY3RcXFwiID09PSB1LFxcbiAgICAgICAgICAgIHcgPSBwLnBhcmVudCgpLmlzKFxcXCI6anFtRGF0YShyb2xlPSdyYW5nZXNsaWRlcicpXFxcIiksXFxuICAgICAgICAgICAgeCA9IHYgPyBcXFwidWktc2xpZGVyLXN3aXRjaFxcXCIgOiBcXFwiXFxcIixcXG4gICAgICAgICAgICB5ID0gcC5hdHRyKFxcXCJpZFxcXCIpLFxcbiAgICAgICAgICAgIHogPSBhKFxcXCJbZm9yPSdcXFwiICsgeSArIFxcXCInXVxcXCIpLFxcbiAgICAgICAgICAgIEEgPSB6LmF0dHIoXFxcImlkXFxcIikgfHwgeSArIFxcXCItbGFiZWxcXFwiLFxcbiAgICAgICAgICAgIEIgPSB2ID8gMCA6IHBhcnNlRmxvYXQocC5hdHRyKFxcXCJtaW5cXFwiKSksXFxuICAgICAgICAgICAgQyA9IHYgPyBwLmZpbmQoXFxcIm9wdGlvblxcXCIpLmxlbmd0aCAtIDEgOiBwYXJzZUZsb2F0KHAuYXR0cihcXFwibWF4XFxcIikpLFxcbiAgICAgICAgICAgIEQgPSBiLnBhcnNlRmxvYXQocC5hdHRyKFxcXCJzdGVwXFxcIikgfHwgMSksXFxuICAgICAgICAgICAgRSA9IGMuY3JlYXRlRWxlbWVudChcXFwiYVxcXCIpLFxcbiAgICAgICAgICAgIEYgPSBhKEUpLFxcbiAgICAgICAgICAgIEcgPSBjLmNyZWF0ZUVsZW1lbnQoXFxcImRpdlxcXCIpLFxcbiAgICAgICAgICAgIEggPSBhKEcpLFxcbiAgICAgICAgICAgIEkgPSB0aGlzLm9wdGlvbnMuaGlnaGxpZ2h0ICYmICF2ID8gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICB2YXIgYiA9IGMuY3JlYXRlRWxlbWVudChcXFwiZGl2XFxcIik7cmV0dXJuIGIuY2xhc3NOYW1lID0gXFxcInVpLXNsaWRlci1iZyBcXFwiICsgYS5tb2JpbGUuYWN0aXZlQnRuQ2xhc3MsIGEoYikucHJlcGVuZFRvKEgpO1xcbiAgICAgICAgfSgpIDogITE7aWYgKHouYXR0cihcXFwiaWRcXFwiLCBBKSwgdGhpcy5pc1RvZ2dsZVN3aXRjaCA9IHYsIEUuc2V0QXR0cmlidXRlKFxcXCJocmVmXFxcIiwgXFxcIiNcXFwiKSwgRy5zZXRBdHRyaWJ1dGUoXFxcInJvbGVcXFwiLCBcXFwiYXBwbGljYXRpb25cXFwiKSwgRy5jbGFzc05hbWUgPSBbdGhpcy5pc1RvZ2dsZVN3aXRjaCA/IFxcXCJ1aS1zbGlkZXIgdWktc2xpZGVyLXRyYWNrIHVpLXNoYWRvdy1pbnNldCBcXFwiIDogXFxcInVpLXNsaWRlci10cmFjayB1aS1zaGFkb3ctaW5zZXQgXFxcIiwgeCwgciwgcywgdF0uam9pbihcXFwiXFxcIiksIEUuY2xhc3NOYW1lID0gXFxcInVpLXNsaWRlci1oYW5kbGVcXFwiLCBHLmFwcGVuZENoaWxkKEUpLCBGLmF0dHIoeyByb2xlOiBcXFwic2xpZGVyXFxcIiwgXFxcImFyaWEtdmFsdWVtaW5cXFwiOiBCLCBcXFwiYXJpYS12YWx1ZW1heFxcXCI6IEMsIFxcXCJhcmlhLXZhbHVlbm93XFxcIjogdGhpcy5fdmFsdWUoKSwgXFxcImFyaWEtdmFsdWV0ZXh0XFxcIjogdGhpcy5fdmFsdWUoKSwgdGl0bGU6IHRoaXMuX3ZhbHVlKCksIFxcXCJhcmlhLWxhYmVsbGVkYnlcXFwiOiBBIH0pLCBhLmV4dGVuZCh0aGlzLCB7IHNsaWRlcjogSCwgaGFuZGxlOiBGLCBjb250cm9sOiBwLCB0eXBlOiB1LCBzdGVwOiBELCBtYXg6IEMsIG1pbjogQiwgdmFsdWViZzogSSwgaXNSYW5nZXNsaWRlcjogdywgZHJhZ2dpbmc6ICExLCBiZWZvcmVTdGFydDogbnVsbCwgdXNlck1vZGlmaWVkOiAhMSwgbW91c2VNb3ZlZDogITEgfSksIHYpIHtcXG4gICAgICAgICAgZm9yIChrID0gcC5hdHRyKFxcXCJ0YWJpbmRleFxcXCIpLCBrICYmIEYuYXR0cihcXFwidGFiaW5kZXhcXFwiLCBrKSwgcC5hdHRyKFxcXCJ0YWJpbmRleFxcXCIsIFxcXCItMVxcXCIpLmZvY3VzKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBhKHRoaXMpLmJsdXIoKSwgRi5mb2N1cygpO1xcbiAgICAgICAgICB9KSwgZiA9IGMuY3JlYXRlRWxlbWVudChcXFwiZGl2XFxcIiksIGYuY2xhc3NOYW1lID0gXFxcInVpLXNsaWRlci1pbm5lcm9mZnNldFxcXCIsIGcgPSAwLCBoID0gRy5jaGlsZE5vZGVzLmxlbmd0aDsgaCA+IGc7IGcrKykge1xcbiAgICAgICAgICAgIGYuYXBwZW5kQ2hpbGQoRy5jaGlsZE5vZGVzW2ddKTtcXG4gICAgICAgICAgfWZvciAoRy5hcHBlbmRDaGlsZChmKSwgRi5hZGRDbGFzcyhcXFwidWktc2xpZGVyLWhhbmRsZS1zbmFwcGluZ1xcXCIpLCBlID0gcC5maW5kKFxcXCJvcHRpb25cXFwiKSwgaSA9IDAsIGogPSBlLmxlbmd0aDsgaiA+IGk7IGkrKykge1xcbiAgICAgICAgICAgIGwgPSBpID8gXFxcImFcXFwiIDogXFxcImJcXFwiLCBtID0gaSA/IFxcXCIgXFxcIiArIGEubW9iaWxlLmFjdGl2ZUJ0bkNsYXNzIDogXFxcIlxcXCIsIG4gPSBjLmNyZWF0ZUVsZW1lbnQoXFxcInNwYW5cXFwiKSwgbi5jbGFzc05hbWUgPSBbXFxcInVpLXNsaWRlci1sYWJlbCB1aS1zbGlkZXItbGFiZWwtXFxcIiwgbCwgbV0uam9pbihcXFwiXFxcIiksIG4uc2V0QXR0cmlidXRlKFxcXCJyb2xlXFxcIiwgXFxcImltZ1xcXCIpLCBuLmFwcGVuZENoaWxkKGMuY3JlYXRlVGV4dE5vZGUoZVtpXS5pbm5lckhUTUwpKSwgYShuKS5wcmVwZW5kVG8oSCk7XFxuICAgICAgICAgIH1vLl9sYWJlbHMgPSBhKFxcXCIudWktc2xpZGVyLWxhYmVsXFxcIiwgSCk7XFxuICAgICAgICB9cC5hZGRDbGFzcyh2ID8gXFxcInVpLXNsaWRlci1zd2l0Y2hcXFwiIDogXFxcInVpLXNsaWRlci1pbnB1dFxcXCIpLCB0aGlzLl9vbihwLCB7IGNoYW5nZTogXFxcIl9jb250cm9sQ2hhbmdlXFxcIiwga2V5dXA6IFxcXCJfY29udHJvbEtleXVwXFxcIiwgYmx1cjogXFxcIl9jb250cm9sQmx1clxcXCIsIHZtb3VzZXVwOiBcXFwiX2NvbnRyb2xWTW91c2VVcFxcXCIgfSksIEguYmluZChcXFwidm1vdXNlZG93blxcXCIsIGEucHJveHkodGhpcy5fc2xpZGVyVk1vdXNlRG93biwgdGhpcykpLmJpbmQoXFxcInZjbGlja1xcXCIsICExKSwgdGhpcy5fb24oYywgeyB2bW91c2Vtb3ZlOiBcXFwiX3ByZXZlbnREb2N1bWVudERyYWdcXFwiIH0pLCB0aGlzLl9vbihILmFkZChjKSwgeyB2bW91c2V1cDogXFxcIl9zbGlkZXJWTW91c2VVcFxcXCIgfSksIEguaW5zZXJ0QWZ0ZXIocCksIHYgfHwgdyB8fCAoZiA9IHRoaXMub3B0aW9ucy5taW5pID8gXFxcIjxkaXYgY2xhc3M9J3VpLXNsaWRlciB1aS1taW5pJz5cXFwiIDogXFxcIjxkaXYgY2xhc3M9J3VpLXNsaWRlcic+XFxcIiwgcC5hZGQoSCkud3JhcEFsbChmKSksIHRoaXMuX29uKHRoaXMuaGFuZGxlLCB7IHZtb3VzZWRvd246IFxcXCJfaGFuZGxlVk1vdXNlRG93blxcXCIsIGtleWRvd246IFxcXCJfaGFuZGxlS2V5ZG93blxcXCIsIGtleXVwOiBcXFwiX2hhbmRsZUtleXVwXFxcIiB9KSwgdGhpcy5oYW5kbGUuYmluZChcXFwidmNsaWNrXFxcIiwgITEpLCB0aGlzLl9oYW5kbGVGb3JtUmVzZXQoKSwgdGhpcy5yZWZyZXNoKGQsIGQsICEwKTtcXG4gICAgICB9LCBfc2V0T3B0aW9uczogZnVuY3Rpb24gX3NldE9wdGlvbnMoYSkge1xcbiAgICAgICAgYS50aGVtZSAhPT0gZCAmJiB0aGlzLl9zZXRUaGVtZShhLnRoZW1lKSwgYS50cmFja1RoZW1lICE9PSBkICYmIHRoaXMuX3NldFRyYWNrVGhlbWUoYS50cmFja1RoZW1lKSwgYS5jb3JuZXJzICE9PSBkICYmIHRoaXMuX3NldENvcm5lcnMoYS5jb3JuZXJzKSwgYS5taW5pICE9PSBkICYmIHRoaXMuX3NldE1pbmkoYS5taW5pKSwgYS5oaWdobGlnaHQgIT09IGQgJiYgdGhpcy5fc2V0SGlnaGxpZ2h0KGEuaGlnaGxpZ2h0KSwgYS5kaXNhYmxlZCAhPT0gZCAmJiB0aGlzLl9zZXREaXNhYmxlZChhLmRpc2FibGVkKSwgdGhpcy5fc3VwZXIoYSk7XFxuICAgICAgfSwgX2NvbnRyb2xDaGFuZ2U6IGZ1bmN0aW9uIF9jb250cm9sQ2hhbmdlKGEpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLl90cmlnZ2VyKFxcXCJjb250cm9sY2hhbmdlXFxcIiwgYSkgPT09ICExID8gITEgOiB2b2lkICh0aGlzLm1vdXNlTW92ZWQgfHwgdGhpcy5yZWZyZXNoKHRoaXMuX3ZhbHVlKCksICEwKSk7XFxuICAgICAgfSwgX2NvbnRyb2xLZXl1cDogZnVuY3Rpb24gX2NvbnRyb2xLZXl1cCgpIHtcXG4gICAgICAgIHRoaXMucmVmcmVzaCh0aGlzLl92YWx1ZSgpLCAhMCwgITApO1xcbiAgICAgIH0sIF9jb250cm9sQmx1cjogZnVuY3Rpb24gX2NvbnRyb2xCbHVyKCkge1xcbiAgICAgICAgdGhpcy5yZWZyZXNoKHRoaXMuX3ZhbHVlKCksICEwKTtcXG4gICAgICB9LCBfY29udHJvbFZNb3VzZVVwOiBmdW5jdGlvbiBfY29udHJvbFZNb3VzZVVwKCkge1xcbiAgICAgICAgdGhpcy5fY2hlY2tlZFJlZnJlc2goKTtcXG4gICAgICB9LCBfaGFuZGxlVk1vdXNlRG93bjogZnVuY3Rpb24gX2hhbmRsZVZNb3VzZURvd24oKSB7XFxuICAgICAgICB0aGlzLmhhbmRsZS5mb2N1cygpO1xcbiAgICAgIH0sIF9oYW5kbGVLZXlkb3duOiBmdW5jdGlvbiBfaGFuZGxlS2V5ZG93bihiKSB7XFxuICAgICAgICB2YXIgYyA9IHRoaXMuX3ZhbHVlKCk7aWYgKCF0aGlzLm9wdGlvbnMuZGlzYWJsZWQpIHtcXG4gICAgICAgICAgc3dpdGNoIChiLmtleUNvZGUpIHtjYXNlIGEubW9iaWxlLmtleUNvZGUuSE9NRTpjYXNlIGEubW9iaWxlLmtleUNvZGUuRU5EOmNhc2UgYS5tb2JpbGUua2V5Q29kZS5QQUdFX1VQOmNhc2UgYS5tb2JpbGUua2V5Q29kZS5QQUdFX0RPV046Y2FzZSBhLm1vYmlsZS5rZXlDb2RlLlVQOmNhc2UgYS5tb2JpbGUua2V5Q29kZS5SSUdIVDpjYXNlIGEubW9iaWxlLmtleUNvZGUuRE9XTjpjYXNlIGEubW9iaWxlLmtleUNvZGUuTEVGVDpcXG4gICAgICAgICAgICAgIGIucHJldmVudERlZmF1bHQoKSwgdGhpcy5fa2V5U2xpZGluZyB8fCAodGhpcy5fa2V5U2xpZGluZyA9ICEwLCB0aGlzLmhhbmRsZS5hZGRDbGFzcyhcXFwidWktc3RhdGUtYWN0aXZlXFxcIikpO31zd2l0Y2ggKGIua2V5Q29kZSkge2Nhc2UgYS5tb2JpbGUua2V5Q29kZS5IT01FOlxcbiAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoKHRoaXMubWluKTticmVhaztjYXNlIGEubW9iaWxlLmtleUNvZGUuRU5EOlxcbiAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoKHRoaXMubWF4KTticmVhaztjYXNlIGEubW9iaWxlLmtleUNvZGUuUEFHRV9VUDpjYXNlIGEubW9iaWxlLmtleUNvZGUuVVA6Y2FzZSBhLm1vYmlsZS5rZXlDb2RlLlJJR0hUOlxcbiAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoKGMgKyB0aGlzLnN0ZXApO2JyZWFrO2Nhc2UgYS5tb2JpbGUua2V5Q29kZS5QQUdFX0RPV046Y2FzZSBhLm1vYmlsZS5rZXlDb2RlLkRPV046Y2FzZSBhLm1vYmlsZS5rZXlDb2RlLkxFRlQ6XFxuICAgICAgICAgICAgICB0aGlzLnJlZnJlc2goYyAtIHRoaXMuc3RlcCk7fVxcbiAgICAgICAgfVxcbiAgICAgIH0sIF9oYW5kbGVLZXl1cDogZnVuY3Rpb24gX2hhbmRsZUtleXVwKCkge1xcbiAgICAgICAgdGhpcy5fa2V5U2xpZGluZyAmJiAodGhpcy5fa2V5U2xpZGluZyA9ICExLCB0aGlzLmhhbmRsZS5yZW1vdmVDbGFzcyhcXFwidWktc3RhdGUtYWN0aXZlXFxcIikpO1xcbiAgICAgIH0sIF9zbGlkZXJWTW91c2VEb3duOiBmdW5jdGlvbiBfc2xpZGVyVk1vdXNlRG93bihhKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmRpc2FibGVkIHx8IDEgIT09IGEud2hpY2ggJiYgMCAhPT0gYS53aGljaCAmJiBhLndoaWNoICE9PSBkID8gITEgOiB0aGlzLl90cmlnZ2VyKFxcXCJiZWZvcmVzdGFydFxcXCIsIGEpID09PSAhMSA/ICExIDogKHRoaXMuZHJhZ2dpbmcgPSAhMCwgdGhpcy51c2VyTW9kaWZpZWQgPSAhMSwgdGhpcy5tb3VzZU1vdmVkID0gITEsIHRoaXMuaXNUb2dnbGVTd2l0Y2ggJiYgKHRoaXMuYmVmb3JlU3RhcnQgPSB0aGlzLmVsZW1lbnRbMF0uc2VsZWN0ZWRJbmRleCksIHRoaXMucmVmcmVzaChhKSwgdGhpcy5fdHJpZ2dlcihcXFwic3RhcnRcXFwiKSwgITEpO1xcbiAgICAgIH0sIF9zbGlkZXJWTW91c2VVcDogZnVuY3Rpb24gX3NsaWRlclZNb3VzZVVwKCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhZ2dpbmcgPyAodGhpcy5kcmFnZ2luZyA9ICExLCB0aGlzLmlzVG9nZ2xlU3dpdGNoICYmICh0aGlzLmhhbmRsZS5hZGRDbGFzcyhcXFwidWktc2xpZGVyLWhhbmRsZS1zbmFwcGluZ1xcXCIpLCB0aGlzLnJlZnJlc2godGhpcy5tb3VzZU1vdmVkID8gdGhpcy51c2VyTW9kaWZpZWQgPyAwID09PSB0aGlzLmJlZm9yZVN0YXJ0ID8gMSA6IDAgOiB0aGlzLmJlZm9yZVN0YXJ0IDogMCA9PT0gdGhpcy5iZWZvcmVTdGFydCA/IDEgOiAwKSksIHRoaXMubW91c2VNb3ZlZCA9ICExLCB0aGlzLl90cmlnZ2VyKFxcXCJzdG9wXFxcIiksICExKSA6IHZvaWQgMDtcXG4gICAgICB9LCBfcHJldmVudERvY3VtZW50RHJhZzogZnVuY3Rpb24gX3ByZXZlbnREb2N1bWVudERyYWcoYSkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyaWdnZXIoXFxcImRyYWdcXFwiLCBhKSA9PT0gITEgPyAhMSA6IHRoaXMuZHJhZ2dpbmcgJiYgIXRoaXMub3B0aW9ucy5kaXNhYmxlZCA/ICh0aGlzLm1vdXNlTW92ZWQgPSAhMCwgdGhpcy5pc1RvZ2dsZVN3aXRjaCAmJiB0aGlzLmhhbmRsZS5yZW1vdmVDbGFzcyhcXFwidWktc2xpZGVyLWhhbmRsZS1zbmFwcGluZ1xcXCIpLCB0aGlzLnJlZnJlc2goYSksIHRoaXMudXNlck1vZGlmaWVkID0gdGhpcy5iZWZvcmVTdGFydCAhPT0gdGhpcy5lbGVtZW50WzBdLnNlbGVjdGVkSW5kZXgsICExKSA6IHZvaWQgMDtcXG4gICAgICB9LCBfY2hlY2tlZFJlZnJlc2g6IGZ1bmN0aW9uIF9jaGVja2VkUmVmcmVzaCgpIHtcXG4gICAgICAgIHRoaXMudmFsdWUgIT09IHRoaXMuX3ZhbHVlKCkgJiYgdGhpcy5yZWZyZXNoKHRoaXMuX3ZhbHVlKCkpO1xcbiAgICAgIH0sIF92YWx1ZTogZnVuY3Rpb24gX3ZhbHVlKCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNUb2dnbGVTd2l0Y2ggPyB0aGlzLmVsZW1lbnRbMF0uc2VsZWN0ZWRJbmRleCA6IHBhcnNlRmxvYXQodGhpcy5lbGVtZW50LnZhbCgpKTtcXG4gICAgICB9LCBfcmVzZXQ6IGZ1bmN0aW9uIF9yZXNldCgpIHtcXG4gICAgICAgIHRoaXMucmVmcmVzaChkLCAhMSwgITApO1xcbiAgICAgIH0sIHJlZnJlc2g6IGZ1bmN0aW9uIHJlZnJlc2goYiwgZCwgZSkge1xcbiAgICAgICAgdmFyIGYsXFxuICAgICAgICAgICAgZyxcXG4gICAgICAgICAgICBoLFxcbiAgICAgICAgICAgIGksXFxuICAgICAgICAgICAgaixcXG4gICAgICAgICAgICBrLFxcbiAgICAgICAgICAgIGwsXFxuICAgICAgICAgICAgbSxcXG4gICAgICAgICAgICBuLFxcbiAgICAgICAgICAgIG8sXFxuICAgICAgICAgICAgcCxcXG4gICAgICAgICAgICBxLFxcbiAgICAgICAgICAgIHIsXFxuICAgICAgICAgICAgcyxcXG4gICAgICAgICAgICB0LFxcbiAgICAgICAgICAgIHUsXFxuICAgICAgICAgICAgdixcXG4gICAgICAgICAgICB3LFxcbiAgICAgICAgICAgIHgsXFxuICAgICAgICAgICAgeSxcXG4gICAgICAgICAgICB6ID0gdGhpcyxcXG4gICAgICAgICAgICBBID0gYS5tb2JpbGUuZ2V0QXR0cmlidXRlKHRoaXMuZWxlbWVudFswXSwgXFxcInRoZW1lXFxcIiksXFxuICAgICAgICAgICAgQiA9IHRoaXMub3B0aW9ucy50aGVtZSB8fCBBLFxcbiAgICAgICAgICAgIEMgPSBCID8gXFxcIiB1aS1idG4tXFxcIiArIEIgOiBcXFwiXFxcIixcXG4gICAgICAgICAgICBEID0gdGhpcy5vcHRpb25zLnRyYWNrVGhlbWUgfHwgQSxcXG4gICAgICAgICAgICBFID0gRCA/IFxcXCIgdWktYmFyLVxcXCIgKyBEIDogXFxcIiB1aS1iYXItaW5oZXJpdFxcXCIsXFxuICAgICAgICAgICAgRiA9IHRoaXMub3B0aW9ucy5jb3JuZXJzID8gXFxcIiB1aS1jb3JuZXItYWxsXFxcIiA6IFxcXCJcXFwiLFxcbiAgICAgICAgICAgIEcgPSB0aGlzLm9wdGlvbnMubWluaSA/IFxcXCIgdWktbWluaVxcXCIgOiBcXFwiXFxcIjtpZiAoei5zbGlkZXJbMF0uY2xhc3NOYW1lID0gW3RoaXMuaXNUb2dnbGVTd2l0Y2ggPyBcXFwidWktc2xpZGVyIHVpLXNsaWRlci1zd2l0Y2ggdWktc2xpZGVyLXRyYWNrIHVpLXNoYWRvdy1pbnNldFxcXCIgOiBcXFwidWktc2xpZGVyLXRyYWNrIHVpLXNoYWRvdy1pbnNldFxcXCIsIEUsIEYsIEddLmpvaW4oXFxcIlxcXCIpLCAodGhpcy5vcHRpb25zLmRpc2FibGVkIHx8IHRoaXMuZWxlbWVudC5wcm9wKFxcXCJkaXNhYmxlZFxcXCIpKSAmJiB0aGlzLmRpc2FibGUoKSwgdGhpcy52YWx1ZSA9IHRoaXMuX3ZhbHVlKCksIHRoaXMub3B0aW9ucy5oaWdobGlnaHQgJiYgIXRoaXMuaXNUb2dnbGVTd2l0Y2ggJiYgMCA9PT0gdGhpcy5zbGlkZXIuZmluZChcXFwiLnVpLXNsaWRlci1iZ1xcXCIpLmxlbmd0aCAmJiAodGhpcy52YWx1ZWJnID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICB2YXIgYiA9IGMuY3JlYXRlRWxlbWVudChcXFwiZGl2XFxcIik7cmV0dXJuIGIuY2xhc3NOYW1lID0gXFxcInVpLXNsaWRlci1iZyBcXFwiICsgYS5tb2JpbGUuYWN0aXZlQnRuQ2xhc3MsIGEoYikucHJlcGVuZFRvKHouc2xpZGVyKTtcXG4gICAgICAgIH0oKSksIHRoaXMuaGFuZGxlLmFkZENsYXNzKFxcXCJ1aS1idG5cXFwiICsgQyArIFxcXCIgdWktc2hhZG93XFxcIiksIGwgPSB0aGlzLmVsZW1lbnQsIG0gPSAhdGhpcy5pc1RvZ2dsZVN3aXRjaCwgbiA9IG0gPyBbXSA6IGwuZmluZChcXFwib3B0aW9uXFxcIiksIG8gPSBtID8gcGFyc2VGbG9hdChsLmF0dHIoXFxcIm1pblxcXCIpKSA6IDAsIHAgPSBtID8gcGFyc2VGbG9hdChsLmF0dHIoXFxcIm1heFxcXCIpKSA6IG4ubGVuZ3RoIC0gMSwgcSA9IG0gJiYgcGFyc2VGbG9hdChsLmF0dHIoXFxcInN0ZXBcXFwiKSkgPiAwID8gcGFyc2VGbG9hdChsLmF0dHIoXFxcInN0ZXBcXFwiKSkgOiAxLCBcXFwib2JqZWN0XFxcIiA9PSAodHlwZW9mIGIgPT09IFxcXCJ1bmRlZmluZWRcXFwiID8gXFxcInVuZGVmaW5lZFxcXCIgOiBfdHlwZW9mKGIpKSkge1xcbiAgICAgICAgICBpZiAoaCA9IGIsIGkgPSA4LCBmID0gdGhpcy5zbGlkZXIub2Zmc2V0KCkubGVmdCwgZyA9IHRoaXMuc2xpZGVyLndpZHRoKCksIGogPSBnIC8gKChwIC0gbykgLyBxKSwgIXRoaXMuZHJhZ2dpbmcgfHwgaC5wYWdlWCA8IGYgLSBpIHx8IGgucGFnZVggPiBmICsgZyArIGkpIHJldHVybjtrID0gaiA+IDEgPyAoaC5wYWdlWCAtIGYpIC8gZyAqIDEwMCA6IE1hdGgucm91bmQoKGgucGFnZVggLSBmKSAvIGcgKiAxMDApO1xcbiAgICAgICAgfSBlbHNlIG51bGwgPT0gYiAmJiAoYiA9IG0gPyBwYXJzZUZsb2F0KGwudmFsKCkgfHwgMCkgOiBsWzBdLnNlbGVjdGVkSW5kZXgpLCBrID0gKHBhcnNlRmxvYXQoYikgLSBvKSAvIChwIC0gbykgKiAxMDA7aWYgKCFpc05hTihrKSAmJiAociA9IGsgLyAxMDAgKiAocCAtIG8pICsgbywgcyA9IChyIC0gbykgJSBxLCB0ID0gciAtIHMsIDIgKiBNYXRoLmFicyhzKSA+PSBxICYmICh0ICs9IHMgPiAwID8gcSA6IC1xKSwgdSA9IDEwMCAvICgocCAtIG8pIC8gcSksIHIgPSBwYXJzZUZsb2F0KHQudG9GaXhlZCg1KSksIFxcXCJ1bmRlZmluZWRcXFwiID09IHR5cGVvZiBqICYmIChqID0gZyAvICgocCAtIG8pIC8gcSkpLCBqID4gMSAmJiBtICYmIChrID0gKHIgLSBvKSAqIHUgKiAoMSAvIHEpKSwgMCA+IGsgJiYgKGsgPSAwKSwgayA+IDEwMCAmJiAoayA9IDEwMCksIG8gPiByICYmIChyID0gbyksIHIgPiBwICYmIChyID0gcCksIHRoaXMuaGFuZGxlLmNzcyhcXFwibGVmdFxcXCIsIGsgKyBcXFwiJVxcXCIpLCB0aGlzLmhhbmRsZVswXS5zZXRBdHRyaWJ1dGUoXFxcImFyaWEtdmFsdWVub3dcXFwiLCBtID8gciA6IG4uZXEocikuYXR0cihcXFwidmFsdWVcXFwiKSksIHRoaXMuaGFuZGxlWzBdLnNldEF0dHJpYnV0ZShcXFwiYXJpYS12YWx1ZXRleHRcXFwiLCBtID8gciA6IG4uZXEocikuZ2V0RW5jb2RlZFRleHQoKSksIHRoaXMuaGFuZGxlWzBdLnNldEF0dHJpYnV0ZShcXFwidGl0bGVcXFwiLCBtID8gciA6IG4uZXEocikuZ2V0RW5jb2RlZFRleHQoKSksIHRoaXMudmFsdWViZyAmJiB0aGlzLnZhbHVlYmcuY3NzKFxcXCJ3aWR0aFxcXCIsIGsgKyBcXFwiJVxcXCIpLCB0aGlzLl9sYWJlbHMgJiYgKHYgPSB0aGlzLmhhbmRsZS53aWR0aCgpIC8gdGhpcy5zbGlkZXIud2lkdGgoKSAqIDEwMCwgdyA9IGsgJiYgdiArICgxMDAgLSB2KSAqIGsgLyAxMDAsIHggPSAxMDAgPT09IGsgPyAwIDogTWF0aC5taW4odiArIDEwMCAtIHcsIDEwMCksIHRoaXMuX2xhYmVscy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgdmFyIGIgPSBhKHRoaXMpLmhhc0NsYXNzKFxcXCJ1aS1zbGlkZXItbGFiZWwtYVxcXCIpO2EodGhpcykud2lkdGgoKGIgPyB3IDogeCkgKyBcXFwiJVxcXCIpO1xcbiAgICAgICAgfSkpLCAhZSkpIHtcXG4gICAgICAgICAgaWYgKHkgPSAhMSwgbSA/ICh5ID0gcGFyc2VGbG9hdChsLnZhbCgpKSAhPT0gciwgbC52YWwocikpIDogKHkgPSBsWzBdLnNlbGVjdGVkSW5kZXggIT09IHIsIGxbMF0uc2VsZWN0ZWRJbmRleCA9IHIpLCB0aGlzLl90cmlnZ2VyKFxcXCJiZWZvcmVjaGFuZ2VcXFwiLCBiKSA9PT0gITEpIHJldHVybiAhMTshZCAmJiB5ICYmIGwudHJpZ2dlcihcXFwiY2hhbmdlXFxcIik7XFxuICAgICAgICB9XFxuICAgICAgfSwgX3NldEhpZ2hsaWdodDogZnVuY3Rpb24gX3NldEhpZ2hsaWdodChhKSB7XFxuICAgICAgICBhID0gISFhLCBhID8gKHRoaXMub3B0aW9ucy5oaWdobGlnaHQgPSAhIWEsIHRoaXMucmVmcmVzaCgpKSA6IHRoaXMudmFsdWViZyAmJiAodGhpcy52YWx1ZWJnLnJlbW92ZSgpLCB0aGlzLnZhbHVlYmcgPSAhMSk7XFxuICAgICAgfSwgX3NldFRoZW1lOiBmdW5jdGlvbiBfc2V0VGhlbWUoYSkge1xcbiAgICAgICAgdGhpcy5oYW5kbGUucmVtb3ZlQ2xhc3MoXFxcInVpLWJ0bi1cXFwiICsgdGhpcy5vcHRpb25zLnRoZW1lKS5hZGRDbGFzcyhcXFwidWktYnRuLVxcXCIgKyBhKTt2YXIgYiA9IHRoaXMub3B0aW9ucy50aGVtZSA/IHRoaXMub3B0aW9ucy50aGVtZSA6IFxcXCJpbmhlcml0XFxcIixcXG4gICAgICAgICAgICBjID0gYSA/IGEgOiBcXFwiaW5oZXJpdFxcXCI7dGhpcy5jb250cm9sLnJlbW92ZUNsYXNzKFxcXCJ1aS1ib2R5LVxcXCIgKyBiKS5hZGRDbGFzcyhcXFwidWktYm9keS1cXFwiICsgYyk7XFxuICAgICAgfSwgX3NldFRyYWNrVGhlbWU6IGZ1bmN0aW9uIF9zZXRUcmFja1RoZW1lKGEpIHtcXG4gICAgICAgIHZhciBiID0gdGhpcy5vcHRpb25zLnRyYWNrVGhlbWUgPyB0aGlzLm9wdGlvbnMudHJhY2tUaGVtZSA6IFxcXCJpbmhlcml0XFxcIixcXG4gICAgICAgICAgICBjID0gYSA/IGEgOiBcXFwiaW5oZXJpdFxcXCI7dGhpcy5zbGlkZXIucmVtb3ZlQ2xhc3MoXFxcInVpLWJvZHktXFxcIiArIGIpLmFkZENsYXNzKFxcXCJ1aS1ib2R5LVxcXCIgKyBjKTtcXG4gICAgICB9LCBfc2V0TWluaTogZnVuY3Rpb24gX3NldE1pbmkoYSkge1xcbiAgICAgICAgYSA9ICEhYSwgdGhpcy5pc1RvZ2dsZVN3aXRjaCB8fCB0aGlzLmlzUmFuZ2VzbGlkZXIgfHwgKHRoaXMuc2xpZGVyLnBhcmVudCgpLnRvZ2dsZUNsYXNzKFxcXCJ1aS1taW5pXFxcIiwgYSksIHRoaXMuZWxlbWVudC50b2dnbGVDbGFzcyhcXFwidWktbWluaVxcXCIsIGEpKSwgdGhpcy5zbGlkZXIudG9nZ2xlQ2xhc3MoXFxcInVpLW1pbmlcXFwiLCBhKTtcXG4gICAgICB9LCBfc2V0Q29ybmVyczogZnVuY3Rpb24gX3NldENvcm5lcnMoYSkge1xcbiAgICAgICAgdGhpcy5zbGlkZXIudG9nZ2xlQ2xhc3MoXFxcInVpLWNvcm5lci1hbGxcXFwiLCBhKSwgdGhpcy5pc1RvZ2dsZVN3aXRjaCB8fCB0aGlzLmNvbnRyb2wudG9nZ2xlQ2xhc3MoXFxcInVpLWNvcm5lci1hbGxcXFwiLCBhKTtcXG4gICAgICB9LCBfc2V0RGlzYWJsZWQ6IGZ1bmN0aW9uIF9zZXREaXNhYmxlZChhKSB7XFxuICAgICAgICBhID0gISFhLCB0aGlzLmVsZW1lbnQucHJvcChcXFwiZGlzYWJsZWRcXFwiLCBhKSwgdGhpcy5zbGlkZXIudG9nZ2xlQ2xhc3MoXFxcInVpLXN0YXRlLWRpc2FibGVkXFxcIiwgYSkuYXR0cihcXFwiYXJpYS1kaXNhYmxlZFxcXCIsIGEpLCB0aGlzLmVsZW1lbnQudG9nZ2xlQ2xhc3MoXFxcInVpLXN0YXRlLWRpc2FibGVkXFxcIiwgYSk7XFxuICAgICAgfSB9LCBhLm1vYmlsZS5iZWhhdmlvcnMuZm9ybVJlc2V0KSk7XFxuICB9KGEpLCBmdW5jdGlvbiAoYSkge1xcbiAgICBmdW5jdGlvbiBiKCkge1xcbiAgICAgIHJldHVybiBjIHx8IChjID0gYShcXFwiPGRpdj48L2Rpdj5cXFwiLCB7IFxcXCJjbGFzc1xcXCI6IFxcXCJ1aS1zbGlkZXItcG9wdXAgdWktc2hhZG93IHVpLWNvcm5lci1hbGxcXFwiIH0pKSwgYy5jbG9uZSgpO1xcbiAgICB9dmFyIGM7YS53aWRnZXQoXFxcIm1vYmlsZS5zbGlkZXJcXFwiLCBhLm1vYmlsZS5zbGlkZXIsIHsgb3B0aW9uczogeyBwb3B1cEVuYWJsZWQ6ICExLCBzaG93VmFsdWU6ICExIH0sIF9jcmVhdGU6IGZ1bmN0aW9uIF9jcmVhdGUoKSB7XFxuICAgICAgICB0aGlzLl9zdXBlcigpLCBhLmV4dGVuZCh0aGlzLCB7IF9jdXJyZW50VmFsdWU6IG51bGwsIF9wb3B1cDogbnVsbCwgX3BvcHVwVmlzaWJsZTogITEgfSksIHRoaXMuX3NldE9wdGlvbihcXFwicG9wdXBFbmFibGVkXFxcIiwgdGhpcy5vcHRpb25zLnBvcHVwRW5hYmxlZCksIHRoaXMuX29uKHRoaXMuaGFuZGxlLCB7IHZtb3VzZWRvd246IFxcXCJfc2hvd1BvcHVwXFxcIiB9KSwgdGhpcy5fb24odGhpcy5zbGlkZXIuYWRkKHRoaXMuZG9jdW1lbnQpLCB7IHZtb3VzZXVwOiBcXFwiX2hpZGVQb3B1cFxcXCIgfSksIHRoaXMuX3JlZnJlc2goKTtcXG4gICAgICB9LCBfcG9zaXRpb25Qb3B1cDogZnVuY3Rpb24gX3Bvc2l0aW9uUG9wdXAoKSB7XFxuICAgICAgICB2YXIgYSA9IHRoaXMuaGFuZGxlLm9mZnNldCgpO3RoaXMuX3BvcHVwLm9mZnNldCh7IGxlZnQ6IGEubGVmdCArICh0aGlzLmhhbmRsZS53aWR0aCgpIC0gdGhpcy5fcG9wdXAud2lkdGgoKSkgLyAyLCB0b3A6IGEudG9wIC0gdGhpcy5fcG9wdXAub3V0ZXJIZWlnaHQoKSAtIDUgfSk7XFxuICAgICAgfSwgX3NldE9wdGlvbjogZnVuY3Rpb24gX3NldE9wdGlvbihhLCBjKSB7XFxuICAgICAgICB0aGlzLl9zdXBlcihhLCBjKSwgXFxcInNob3dWYWx1ZVxcXCIgPT09IGEgPyB0aGlzLmhhbmRsZS5odG1sKGMgJiYgIXRoaXMub3B0aW9ucy5taW5pID8gdGhpcy5fdmFsdWUoKSA6IFxcXCJcXFwiKSA6IFxcXCJwb3B1cEVuYWJsZWRcXFwiID09PSBhICYmIGMgJiYgIXRoaXMuX3BvcHVwICYmICh0aGlzLl9wb3B1cCA9IGIoKS5hZGRDbGFzcyhcXFwidWktYm9keS1cXFwiICsgKHRoaXMub3B0aW9ucy50aGVtZSB8fCBcXFwiYVxcXCIpKS5oaWRlKCkuaW5zZXJ0QmVmb3JlKHRoaXMuZWxlbWVudCkpO1xcbiAgICAgIH0sIHJlZnJlc2g6IGZ1bmN0aW9uIHJlZnJlc2goKSB7XFxuICAgICAgICB0aGlzLl9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCB0aGlzLl9yZWZyZXNoKCk7XFxuICAgICAgfSwgX3JlZnJlc2g6IGZ1bmN0aW9uIF9yZWZyZXNoKCkge1xcbiAgICAgICAgdmFyIGEsXFxuICAgICAgICAgICAgYiA9IHRoaXMub3B0aW9ucztiLnBvcHVwRW5hYmxlZCAmJiB0aGlzLmhhbmRsZS5yZW1vdmVBdHRyKFxcXCJ0aXRsZVxcXCIpLCBhID0gdGhpcy5fdmFsdWUoKSwgYSAhPT0gdGhpcy5fY3VycmVudFZhbHVlICYmICh0aGlzLl9jdXJyZW50VmFsdWUgPSBhLCBiLnBvcHVwRW5hYmxlZCAmJiB0aGlzLl9wb3B1cCAmJiAodGhpcy5fcG9zaXRpb25Qb3B1cCgpLCB0aGlzLl9wb3B1cC5odG1sKGEpKSwgYi5zaG93VmFsdWUgJiYgIXRoaXMub3B0aW9ucy5taW5pICYmIHRoaXMuaGFuZGxlLmh0bWwoYSkpO1xcbiAgICAgIH0sIF9zaG93UG9wdXA6IGZ1bmN0aW9uIF9zaG93UG9wdXAoKSB7XFxuICAgICAgICB0aGlzLm9wdGlvbnMucG9wdXBFbmFibGVkICYmICF0aGlzLl9wb3B1cFZpc2libGUgJiYgKHRoaXMuaGFuZGxlLmh0bWwoXFxcIlxcXCIpLCB0aGlzLl9wb3B1cC5zaG93KCksIHRoaXMuX3Bvc2l0aW9uUG9wdXAoKSwgdGhpcy5fcG9wdXBWaXNpYmxlID0gITApO1xcbiAgICAgIH0sIF9oaWRlUG9wdXA6IGZ1bmN0aW9uIF9oaWRlUG9wdXAoKSB7XFxuICAgICAgICB2YXIgYSA9IHRoaXMub3B0aW9uczthLnBvcHVwRW5hYmxlZCAmJiB0aGlzLl9wb3B1cFZpc2libGUgJiYgKGEuc2hvd1ZhbHVlICYmICFhLm1pbmkgJiYgdGhpcy5oYW5kbGUuaHRtbCh0aGlzLl92YWx1ZSgpKSwgdGhpcy5fcG9wdXAuaGlkZSgpLCB0aGlzLl9wb3B1cFZpc2libGUgPSAhMSk7XFxuICAgICAgfSB9KTtcXG4gIH0oYSksIGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgIGEud2lkZ2V0KFxcXCJtb2JpbGUuZmxpcHN3aXRjaFxcXCIsIGEuZXh0ZW5kKHsgb3B0aW9uczogeyBvblRleHQ6IFxcXCJPblxcXCIsIG9mZlRleHQ6IFxcXCJPZmZcXFwiLCB0aGVtZTogbnVsbCwgZW5oYW5jZWQ6ICExLCB3cmFwcGVyQ2xhc3M6IG51bGwsIGNvcm5lcnM6ICEwLCBtaW5pOiAhMSB9LCBfY3JlYXRlOiBmdW5jdGlvbiBfY3JlYXRlKCkge1xcbiAgICAgICAgdGhpcy5vcHRpb25zLmVuaGFuY2VkID8gYS5leHRlbmQodGhpcywgeyBmbGlwc3dpdGNoOiB0aGlzLmVsZW1lbnQucGFyZW50KCksIG9uOiB0aGlzLmVsZW1lbnQuZmluZChcXFwiLnVpLWZsaXBzd2l0Y2gtb25cXFwiKS5lcSgwKSwgb2ZmOiB0aGlzLmVsZW1lbnQuZmluZChcXFwiLnVpLWZsaXBzd2l0Y2gtb2ZmXFxcIikuZXEoMCksIHR5cGU6IHRoaXMuZWxlbWVudC5nZXQoMCkudGFnTmFtZSB9KSA6IHRoaXMuX2VuaGFuY2UoKSwgdGhpcy5faGFuZGxlRm9ybVJlc2V0KCksIHRoaXMuX29yaWdpbmFsVGFiSW5kZXggPSB0aGlzLmVsZW1lbnQuYXR0cihcXFwidGFiaW5kZXhcXFwiKSwgbnVsbCAhPSB0aGlzLl9vcmlnaW5hbFRhYkluZGV4ICYmIHRoaXMub24uYXR0cihcXFwidGFiaW5kZXhcXFwiLCB0aGlzLl9vcmlnaW5hbFRhYkluZGV4KSwgdGhpcy5lbGVtZW50LmF0dHIoXFxcInRhYmluZGV4XFxcIiwgXFxcIi0xXFxcIiksIHRoaXMuX29uKHsgZm9jdXM6IFxcXCJfaGFuZGxlSW5wdXRGb2N1c1xcXCIgfSksIHRoaXMuZWxlbWVudC5pcyhcXFwiOmRpc2FibGVkXFxcIikgJiYgdGhpcy5fc2V0T3B0aW9ucyh7IGRpc2FibGVkOiAhMCB9KSwgdGhpcy5fb24odGhpcy5mbGlwc3dpdGNoLCB7IGNsaWNrOiBcXFwiX3RvZ2dsZVxcXCIsIHN3aXBlbGVmdDogXFxcIl9sZWZ0XFxcIiwgc3dpcGVyaWdodDogXFxcIl9yaWdodFxcXCIgfSksIHRoaXMuX29uKHRoaXMub24sIHsga2V5ZG93bjogXFxcIl9rZXlkb3duXFxcIiB9KSwgdGhpcy5fb24oeyBjaGFuZ2U6IFxcXCJyZWZyZXNoXFxcIiB9KTtcXG4gICAgICB9LCBfaGFuZGxlSW5wdXRGb2N1czogZnVuY3Rpb24gX2hhbmRsZUlucHV0Rm9jdXMoKSB7XFxuICAgICAgICB0aGlzLm9uLmZvY3VzKCk7XFxuICAgICAgfSwgd2lkZ2V0OiBmdW5jdGlvbiB3aWRnZXQoKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5mbGlwc3dpdGNoO1xcbiAgICAgIH0sIF9sZWZ0OiBmdW5jdGlvbiBfbGVmdCgpIHtcXG4gICAgICAgIHRoaXMuZmxpcHN3aXRjaC5yZW1vdmVDbGFzcyhcXFwidWktZmxpcHN3aXRjaC1hY3RpdmVcXFwiKSwgXFxcIlNFTEVDVFxcXCIgPT09IHRoaXMudHlwZSA/IHRoaXMuZWxlbWVudC5nZXQoMCkuc2VsZWN0ZWRJbmRleCA9IDAgOiB0aGlzLmVsZW1lbnQucHJvcChcXFwiY2hlY2tlZFxcXCIsICExKSwgdGhpcy5lbGVtZW50LnRyaWdnZXIoXFxcImNoYW5nZVxcXCIpO1xcbiAgICAgIH0sIF9yaWdodDogZnVuY3Rpb24gX3JpZ2h0KCkge1xcbiAgICAgICAgdGhpcy5mbGlwc3dpdGNoLmFkZENsYXNzKFxcXCJ1aS1mbGlwc3dpdGNoLWFjdGl2ZVxcXCIpLCBcXFwiU0VMRUNUXFxcIiA9PT0gdGhpcy50eXBlID8gdGhpcy5lbGVtZW50LmdldCgwKS5zZWxlY3RlZEluZGV4ID0gMSA6IHRoaXMuZWxlbWVudC5wcm9wKFxcXCJjaGVja2VkXFxcIiwgITApLCB0aGlzLmVsZW1lbnQudHJpZ2dlcihcXFwiY2hhbmdlXFxcIik7XFxuICAgICAgfSwgX2VuaGFuY2U6IGZ1bmN0aW9uIF9lbmhhbmNlKCkge1xcbiAgICAgICAgdmFyIGIgPSBhKFxcXCI8ZGl2PlxcXCIpLFxcbiAgICAgICAgICAgIGMgPSB0aGlzLm9wdGlvbnMsXFxuICAgICAgICAgICAgZCA9IHRoaXMuZWxlbWVudCxcXG4gICAgICAgICAgICBlID0gYy50aGVtZSA/IGMudGhlbWUgOiBcXFwiaW5oZXJpdFxcXCIsXFxuICAgICAgICAgICAgZiA9IGEoXFxcIjxhPjwvYT5cXFwiLCB7IGhyZWY6IFxcXCIjXFxcIiB9KSxcXG4gICAgICAgICAgICBnID0gYShcXFwiPHNwYW4+PC9zcGFuPlxcXCIpLFxcbiAgICAgICAgICAgIGggPSBkLmdldCgwKS50YWdOYW1lLFxcbiAgICAgICAgICAgIGkgPSBcXFwiSU5QVVRcXFwiID09PSBoID8gYy5vblRleHQgOiBkLmZpbmQoXFxcIm9wdGlvblxcXCIpLmVxKDEpLnRleHQoKSxcXG4gICAgICAgICAgICBqID0gXFxcIklOUFVUXFxcIiA9PT0gaCA/IGMub2ZmVGV4dCA6IGQuZmluZChcXFwib3B0aW9uXFxcIikuZXEoMCkudGV4dCgpO2YuYWRkQ2xhc3MoXFxcInVpLWZsaXBzd2l0Y2gtb24gdWktYnRuIHVpLXNoYWRvdyB1aS1idG4taW5oZXJpdFxcXCIpLnRleHQoaSksIGcuYWRkQ2xhc3MoXFxcInVpLWZsaXBzd2l0Y2gtb2ZmXFxcIikudGV4dChqKSwgYi5hZGRDbGFzcyhcXFwidWktZmxpcHN3aXRjaCB1aS1zaGFkb3ctaW5zZXQgdWktYmFyLVxcXCIgKyBlICsgXFxcIiBcXFwiICsgKGMud3JhcHBlckNsYXNzID8gYy53cmFwcGVyQ2xhc3MgOiBcXFwiXFxcIikgKyBcXFwiIFxcXCIgKyAoZC5pcyhcXFwiOmNoZWNrZWRcXFwiKSB8fCBkLmZpbmQoXFxcIm9wdGlvblxcXCIpLmVxKDEpLmlzKFxcXCI6c2VsZWN0ZWRcXFwiKSA/IFxcXCJ1aS1mbGlwc3dpdGNoLWFjdGl2ZVxcXCIgOiBcXFwiXFxcIikgKyAoZC5pcyhcXFwiOmRpc2FibGVkXFxcIikgPyBcXFwiIHVpLXN0YXRlLWRpc2FibGVkXFxcIiA6IFxcXCJcXFwiKSArIChjLmNvcm5lcnMgPyBcXFwiIHVpLWNvcm5lci1hbGxcXFwiIDogXFxcIlxcXCIpICsgKGMubWluaSA/IFxcXCIgdWktbWluaVxcXCIgOiBcXFwiXFxcIikpLmFwcGVuZChmLCBnKSwgZC5hZGRDbGFzcyhcXFwidWktZmxpcHN3aXRjaC1pbnB1dFxcXCIpLmFmdGVyKGIpLmFwcGVuZFRvKGIpLCBhLmV4dGVuZCh0aGlzLCB7IGZsaXBzd2l0Y2g6IGIsIG9uOiBmLCBvZmY6IGcsIHR5cGU6IGggfSk7XFxuICAgICAgfSwgX3Jlc2V0OiBmdW5jdGlvbiBfcmVzZXQoKSB7XFxuICAgICAgICB0aGlzLnJlZnJlc2goKTtcXG4gICAgICB9LCByZWZyZXNoOiBmdW5jdGlvbiByZWZyZXNoKCkge1xcbiAgICAgICAgdmFyIGEsXFxuICAgICAgICAgICAgYiA9IHRoaXMuZmxpcHN3aXRjaC5oYXNDbGFzcyhcXFwidWktZmxpcHN3aXRjaC1hY3RpdmVcXFwiKSA/IFxcXCJfcmlnaHRcXFwiIDogXFxcIl9sZWZ0XFxcIjthID0gXFxcIlNFTEVDVFxcXCIgPT09IHRoaXMudHlwZSA/IHRoaXMuZWxlbWVudC5nZXQoMCkuc2VsZWN0ZWRJbmRleCA+IDAgPyBcXFwiX3JpZ2h0XFxcIiA6IFxcXCJfbGVmdFxcXCIgOiB0aGlzLmVsZW1lbnQucHJvcChcXFwiY2hlY2tlZFxcXCIpID8gXFxcIl9yaWdodFxcXCIgOiBcXFwiX2xlZnRcXFwiLCBhICE9PSBiICYmIHRoaXNbYV0oKTtcXG4gICAgICB9LCBfdG9nZ2xlOiBmdW5jdGlvbiBfdG9nZ2xlKCkge1xcbiAgICAgICAgdmFyIGEgPSB0aGlzLmZsaXBzd2l0Y2guaGFzQ2xhc3MoXFxcInVpLWZsaXBzd2l0Y2gtYWN0aXZlXFxcIikgPyBcXFwiX2xlZnRcXFwiIDogXFxcIl9yaWdodFxcXCI7dGhpc1thXSgpO1xcbiAgICAgIH0sIF9rZXlkb3duOiBmdW5jdGlvbiBfa2V5ZG93bihiKSB7XFxuICAgICAgICBiLndoaWNoID09PSBhLm1vYmlsZS5rZXlDb2RlLkxFRlQgPyB0aGlzLl9sZWZ0KCkgOiBiLndoaWNoID09PSBhLm1vYmlsZS5rZXlDb2RlLlJJR0hUID8gdGhpcy5fcmlnaHQoKSA6IGIud2hpY2ggPT09IGEubW9iaWxlLmtleUNvZGUuU1BBQ0UgJiYgKHRoaXMuX3RvZ2dsZSgpLCBiLnByZXZlbnREZWZhdWx0KCkpO1xcbiAgICAgIH0sIF9zZXRPcHRpb25zOiBmdW5jdGlvbiBfc2V0T3B0aW9ucyhhKSB7XFxuICAgICAgICBpZiAoYS50aGVtZSAhPT0gYikge1xcbiAgICAgICAgICB2YXIgYyA9IGEudGhlbWUgPyBhLnRoZW1lIDogXFxcImluaGVyaXRcXFwiLFxcbiAgICAgICAgICAgICAgZCA9IGEudGhlbWUgPyBhLnRoZW1lIDogXFxcImluaGVyaXRcXFwiO3RoaXMud2lkZ2V0KCkucmVtb3ZlQ2xhc3MoXFxcInVpLWJhci1cXFwiICsgYykuYWRkQ2xhc3MoXFxcInVpLWJhci1cXFwiICsgZCk7XFxuICAgICAgICB9YS5vblRleHQgIT09IGIgJiYgdGhpcy5vbi50ZXh0KGEub25UZXh0KSwgYS5vZmZUZXh0ICE9PSBiICYmIHRoaXMub2ZmLnRleHQoYS5vZmZUZXh0KSwgYS5kaXNhYmxlZCAhPT0gYiAmJiB0aGlzLndpZGdldCgpLnRvZ2dsZUNsYXNzKFxcXCJ1aS1zdGF0ZS1kaXNhYmxlZFxcXCIsIGEuZGlzYWJsZWQpLCBhLm1pbmkgIT09IGIgJiYgdGhpcy53aWRnZXQoKS50b2dnbGVDbGFzcyhcXFwidWktbWluaVxcXCIsIGEubWluaSksIGEuY29ybmVycyAhPT0gYiAmJiB0aGlzLndpZGdldCgpLnRvZ2dsZUNsYXNzKFxcXCJ1aS1jb3JuZXItYWxsXFxcIiwgYS5jb3JuZXJzKSwgdGhpcy5fc3VwZXIoYSk7XFxuICAgICAgfSwgX2Rlc3Ryb3k6IGZ1bmN0aW9uIF9kZXN0cm95KCkge1xcbiAgICAgICAgdGhpcy5vcHRpb25zLmVuaGFuY2VkIHx8IChudWxsICE9IHRoaXMuX29yaWdpbmFsVGFiSW5kZXggPyB0aGlzLmVsZW1lbnQuYXR0cihcXFwidGFiaW5kZXhcXFwiLCB0aGlzLl9vcmlnaW5hbFRhYkluZGV4KSA6IHRoaXMuZWxlbWVudC5yZW1vdmVBdHRyKFxcXCJ0YWJpbmRleFxcXCIpLCB0aGlzLm9uLnJlbW92ZSgpLCB0aGlzLm9mZi5yZW1vdmUoKSwgdGhpcy5lbGVtZW50LnVud3JhcCgpLCB0aGlzLmZsaXBzd2l0Y2gucmVtb3ZlKCksIHRoaXMucmVtb3ZlQ2xhc3MoXFxcInVpLWZsaXBzd2l0Y2gtaW5wdXRcXFwiKSk7XFxuICAgICAgfSB9LCBhLm1vYmlsZS5iZWhhdmlvcnMuZm9ybVJlc2V0KSk7XFxuICB9KGEpLCBmdW5jdGlvbiAoYSwgYikge1xcbiAgICBhLndpZGdldChcXFwibW9iaWxlLnJhbmdlc2xpZGVyXFxcIiwgYS5leHRlbmQoeyBvcHRpb25zOiB7IHRoZW1lOiBudWxsLCB0cmFja1RoZW1lOiBudWxsLCBjb3JuZXJzOiAhMCwgbWluaTogITEsIGhpZ2hsaWdodDogITAgfSwgX2NyZWF0ZTogZnVuY3Rpb24gX2NyZWF0ZSgpIHtcXG4gICAgICAgIHZhciBiID0gdGhpcy5lbGVtZW50LFxcbiAgICAgICAgICAgIGMgPSB0aGlzLm9wdGlvbnMubWluaSA/IFxcXCJ1aS1yYW5nZXNsaWRlciB1aS1taW5pXFxcIiA6IFxcXCJ1aS1yYW5nZXNsaWRlclxcXCIsXFxuICAgICAgICAgICAgZCA9IGIuZmluZChcXFwiaW5wdXRcXFwiKS5maXJzdCgpLFxcbiAgICAgICAgICAgIGUgPSBiLmZpbmQoXFxcImlucHV0XFxcIikubGFzdCgpLFxcbiAgICAgICAgICAgIGYgPSBiLmZpbmQoXFxcImxhYmVsXFxcIikuZmlyc3QoKSxcXG4gICAgICAgICAgICBnID0gYS5kYXRhKGQuZ2V0KDApLCBcXFwibW9iaWxlLXNsaWRlclxcXCIpIHx8IGEuZGF0YShkLnNsaWRlcigpLmdldCgwKSwgXFxcIm1vYmlsZS1zbGlkZXJcXFwiKSxcXG4gICAgICAgICAgICBoID0gYS5kYXRhKGUuZ2V0KDApLCBcXFwibW9iaWxlLXNsaWRlclxcXCIpIHx8IGEuZGF0YShlLnNsaWRlcigpLmdldCgwKSwgXFxcIm1vYmlsZS1zbGlkZXJcXFwiKSxcXG4gICAgICAgICAgICBpID0gZy5zbGlkZXIsXFxuICAgICAgICAgICAgaiA9IGguc2xpZGVyLFxcbiAgICAgICAgICAgIGsgPSBnLmhhbmRsZSxcXG4gICAgICAgICAgICBsID0gYShcXFwiPGRpdiBjbGFzcz0ndWktcmFuZ2VzbGlkZXItc2xpZGVycycgLz5cXFwiKS5hcHBlbmRUbyhiKTtkLmFkZENsYXNzKFxcXCJ1aS1yYW5nZXNsaWRlci1maXJzdFxcXCIpLCBlLmFkZENsYXNzKFxcXCJ1aS1yYW5nZXNsaWRlci1sYXN0XFxcIiksIGIuYWRkQ2xhc3MoYyksIGkuYXBwZW5kVG8obCksIGouYXBwZW5kVG8obCksIGYuaW5zZXJ0QmVmb3JlKGIpLCBrLnByZXBlbmRUbyhqKSwgYS5leHRlbmQodGhpcywgeyBfaW5wdXRGaXJzdDogZCwgX2lucHV0TGFzdDogZSwgX3NsaWRlckZpcnN0OiBpLCBfc2xpZGVyTGFzdDogaiwgX2xhYmVsOiBmLCBfdGFyZ2V0VmFsOiBudWxsLCBfc2xpZGVyVGFyZ2V0OiAhMSwgX3NsaWRlcnM6IGwsIF9wcm94eTogITEgfSksIHRoaXMucmVmcmVzaCgpLCB0aGlzLl9vbih0aGlzLmVsZW1lbnQuZmluZChcXFwiaW5wdXQudWktc2xpZGVyLWlucHV0XFxcIiksIHsgc2xpZGViZWZvcmVzdGFydDogXFxcIl9zbGlkZWJlZm9yZXN0YXJ0XFxcIiwgc2xpZGVzdG9wOiBcXFwiX3NsaWRlc3RvcFxcXCIsIHNsaWRlZHJhZzogXFxcIl9zbGlkZWRyYWdcXFwiLCBzbGlkZWJlZm9yZWNoYW5nZTogXFxcIl9jaGFuZ2VcXFwiLCBibHVyOiBcXFwiX2NoYW5nZVxcXCIsIGtleXVwOiBcXFwiX2NoYW5nZVxcXCIgfSksIHRoaXMuX29uKHsgbW91c2Vkb3duOiBcXFwiX2NoYW5nZVxcXCIgfSksIHRoaXMuX29uKHRoaXMuZWxlbWVudC5jbG9zZXN0KFxcXCJmb3JtXFxcIiksIHsgcmVzZXQ6IFxcXCJfaGFuZGxlUmVzZXRcXFwiIH0pLCB0aGlzLl9vbihrLCB7IHZtb3VzZWRvd246IFxcXCJfZHJhZ0ZpcnN0SGFuZGxlXFxcIiB9KTtcXG4gICAgICB9LCBfaGFuZGxlUmVzZXQ6IGZ1bmN0aW9uIF9oYW5kbGVSZXNldCgpIHtcXG4gICAgICAgIHZhciBhID0gdGhpcztzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgYS5fdXBkYXRlSGlnaGxpZ2h0KCk7XFxuICAgICAgICB9LCAwKTtcXG4gICAgICB9LCBfZHJhZ0ZpcnN0SGFuZGxlOiBmdW5jdGlvbiBfZHJhZ0ZpcnN0SGFuZGxlKGIpIHtcXG4gICAgICAgIHJldHVybiBhLmRhdGEodGhpcy5faW5wdXRGaXJzdC5nZXQoMCksIFxcXCJtb2JpbGUtc2xpZGVyXFxcIikuZHJhZ2dpbmcgPSAhMCwgYS5kYXRhKHRoaXMuX2lucHV0Rmlyc3QuZ2V0KDApLCBcXFwibW9iaWxlLXNsaWRlclxcXCIpLnJlZnJlc2goYiksIGEuZGF0YSh0aGlzLl9pbnB1dEZpcnN0LmdldCgwKSwgXFxcIm1vYmlsZS1zbGlkZXJcXFwiKS5fdHJpZ2dlcihcXFwic3RhcnRcXFwiKSwgITE7XFxuICAgICAgfSwgX3NsaWRlZHJhZzogZnVuY3Rpb24gX3NsaWRlZHJhZyhiKSB7XFxuICAgICAgICB2YXIgYyA9IGEoYi50YXJnZXQpLmlzKHRoaXMuX2lucHV0Rmlyc3QpLFxcbiAgICAgICAgICAgIGQgPSBjID8gdGhpcy5faW5wdXRMYXN0IDogdGhpcy5faW5wdXRGaXJzdDtyZXR1cm4gdGhpcy5fc2xpZGVyVGFyZ2V0ID0gITEsIFxcXCJmaXJzdFxcXCIgPT09IHRoaXMuX3Byb3h5ICYmIGMgfHwgXFxcImxhc3RcXFwiID09PSB0aGlzLl9wcm94eSAmJiAhYyA/IChhLmRhdGEoZC5nZXQoMCksIFxcXCJtb2JpbGUtc2xpZGVyXFxcIikuZHJhZ2dpbmcgPSAhMCwgYS5kYXRhKGQuZ2V0KDApLCBcXFwibW9iaWxlLXNsaWRlclxcXCIpLnJlZnJlc2goYiksICExKSA6IHZvaWQgMDtcXG4gICAgICB9LCBfc2xpZGVzdG9wOiBmdW5jdGlvbiBfc2xpZGVzdG9wKGIpIHtcXG4gICAgICAgIHZhciBjID0gYShiLnRhcmdldCkuaXModGhpcy5faW5wdXRGaXJzdCk7dGhpcy5fcHJveHkgPSAhMSwgdGhpcy5lbGVtZW50LmZpbmQoXFxcImlucHV0XFxcIikudHJpZ2dlcihcXFwidm1vdXNldXBcXFwiKSwgdGhpcy5fc2xpZGVyRmlyc3QuY3NzKFxcXCJ6LWluZGV4XFxcIiwgYyA/IDEgOiBcXFwiXFxcIik7XFxuICAgICAgfSwgX3NsaWRlYmVmb3Jlc3RhcnQ6IGZ1bmN0aW9uIF9zbGlkZWJlZm9yZXN0YXJ0KGIpIHtcXG4gICAgICAgIHRoaXMuX3NsaWRlclRhcmdldCA9ICExLCBhKGIub3JpZ2luYWxFdmVudC50YXJnZXQpLmhhc0NsYXNzKFxcXCJ1aS1zbGlkZXItdHJhY2tcXFwiKSAmJiAodGhpcy5fc2xpZGVyVGFyZ2V0ID0gITAsIHRoaXMuX3RhcmdldFZhbCA9IGEoYi50YXJnZXQpLnZhbCgpKTtcXG4gICAgICB9LCBfc2V0T3B0aW9uczogZnVuY3Rpb24gX3NldE9wdGlvbnMoYSkge1xcbiAgICAgICAgYS50aGVtZSAhPT0gYiAmJiB0aGlzLl9zZXRUaGVtZShhLnRoZW1lKSwgYS50cmFja1RoZW1lICE9PSBiICYmIHRoaXMuX3NldFRyYWNrVGhlbWUoYS50cmFja1RoZW1lKSwgYS5taW5pICE9PSBiICYmIHRoaXMuX3NldE1pbmkoYS5taW5pKSwgYS5oaWdobGlnaHQgIT09IGIgJiYgdGhpcy5fc2V0SGlnaGxpZ2h0KGEuaGlnaGxpZ2h0KSwgYS5kaXNhYmxlZCAhPT0gYiAmJiB0aGlzLl9zZXREaXNhYmxlZChhLmRpc2FibGVkKSwgdGhpcy5fc3VwZXIoYSksIHRoaXMucmVmcmVzaCgpO1xcbiAgICAgIH0sIHJlZnJlc2g6IGZ1bmN0aW9uIHJlZnJlc2goKSB7XFxuICAgICAgICB2YXIgYSA9IHRoaXMuZWxlbWVudCxcXG4gICAgICAgICAgICBiID0gdGhpcy5vcHRpb25zOyh0aGlzLl9pbnB1dEZpcnN0LmlzKFxcXCI6ZGlzYWJsZWRcXFwiKSB8fCB0aGlzLl9pbnB1dExhc3QuaXMoXFxcIjpkaXNhYmxlZFxcXCIpKSAmJiAodGhpcy5vcHRpb25zLmRpc2FibGVkID0gITApLCBhLmZpbmQoXFxcImlucHV0XFxcIikuc2xpZGVyKHsgdGhlbWU6IGIudGhlbWUsIHRyYWNrVGhlbWU6IGIudHJhY2tUaGVtZSwgZGlzYWJsZWQ6IGIuZGlzYWJsZWQsIGNvcm5lcnM6IGIuY29ybmVycywgbWluaTogYi5taW5pLCBoaWdobGlnaHQ6IGIuaGlnaGxpZ2h0IH0pLnNsaWRlcihcXFwicmVmcmVzaFxcXCIpLCB0aGlzLl91cGRhdGVIaWdobGlnaHQoKTtcXG4gICAgICB9LCBfY2hhbmdlOiBmdW5jdGlvbiBfY2hhbmdlKGIpIHtcXG4gICAgICAgIGlmIChcXFwia2V5dXBcXFwiID09PSBiLnR5cGUpIHJldHVybiB0aGlzLl91cGRhdGVIaWdobGlnaHQoKSwgITE7dmFyIGMgPSB0aGlzLFxcbiAgICAgICAgICAgIGQgPSBwYXJzZUZsb2F0KHRoaXMuX2lucHV0Rmlyc3QudmFsKCksIDEwKSxcXG4gICAgICAgICAgICBlID0gcGFyc2VGbG9hdCh0aGlzLl9pbnB1dExhc3QudmFsKCksIDEwKSxcXG4gICAgICAgICAgICBmID0gYShiLnRhcmdldCkuaGFzQ2xhc3MoXFxcInVpLXJhbmdlc2xpZGVyLWZpcnN0XFxcIiksXFxuICAgICAgICAgICAgZyA9IGYgPyB0aGlzLl9pbnB1dEZpcnN0IDogdGhpcy5faW5wdXRMYXN0LFxcbiAgICAgICAgICAgIGggPSBmID8gdGhpcy5faW5wdXRMYXN0IDogdGhpcy5faW5wdXRGaXJzdDtpZiAodGhpcy5faW5wdXRGaXJzdC52YWwoKSA+IHRoaXMuX2lucHV0TGFzdC52YWwoKSAmJiBcXFwibW91c2Vkb3duXFxcIiA9PT0gYi50eXBlICYmICFhKGIudGFyZ2V0KS5oYXNDbGFzcyhcXFwidWktc2xpZGVyLWhhbmRsZVxcXCIpKSBnLmJsdXIoKTtlbHNlIGlmIChcXFwibW91c2Vkb3duXFxcIiA9PT0gYi50eXBlKSByZXR1cm47cmV0dXJuIGQgPiBlICYmICF0aGlzLl9zbGlkZXJUYXJnZXQgPyAoZy52YWwoZiA/IGUgOiBkKS5zbGlkZXIoXFxcInJlZnJlc2hcXFwiKSwgdGhpcy5fdHJpZ2dlcihcXFwibm9ybWFsaXplXFxcIikpIDogZCA+IGUgJiYgKGcudmFsKHRoaXMuX3RhcmdldFZhbCkuc2xpZGVyKFxcXCJyZWZyZXNoXFxcIiksIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBoLnZhbChmID8gZCA6IGUpLnNsaWRlcihcXFwicmVmcmVzaFxcXCIpLCBhLmRhdGEoaC5nZXQoMCksIFxcXCJtb2JpbGUtc2xpZGVyXFxcIikuaGFuZGxlLmZvY3VzKCksIGMuX3NsaWRlckZpcnN0LmNzcyhcXFwiei1pbmRleFxcXCIsIGYgPyBcXFwiXFxcIiA6IDEpLCBjLl90cmlnZ2VyKFxcXCJub3JtYWxpemVcXFwiKTtcXG4gICAgICAgIH0sIDApLCB0aGlzLl9wcm94eSA9IGYgPyBcXFwiZmlyc3RcXFwiIDogXFxcImxhc3RcXFwiKSwgZCA9PT0gZSA/IChhLmRhdGEoZy5nZXQoMCksIFxcXCJtb2JpbGUtc2xpZGVyXFxcIikuaGFuZGxlLmNzcyhcXFwiei1pbmRleFxcXCIsIDEpLCBhLmRhdGEoaC5nZXQoMCksIFxcXCJtb2JpbGUtc2xpZGVyXFxcIikuaGFuZGxlLmNzcyhcXFwiei1pbmRleFxcXCIsIDApKSA6IChhLmRhdGEoaC5nZXQoMCksIFxcXCJtb2JpbGUtc2xpZGVyXFxcIikuaGFuZGxlLmNzcyhcXFwiei1pbmRleFxcXCIsIFxcXCJcXFwiKSwgYS5kYXRhKGcuZ2V0KDApLCBcXFwibW9iaWxlLXNsaWRlclxcXCIpLmhhbmRsZS5jc3MoXFxcInotaW5kZXhcXFwiLCBcXFwiXFxcIikpLCB0aGlzLl91cGRhdGVIaWdobGlnaHQoKSwgZCA+PSBlID8gITEgOiB2b2lkIDA7XFxuICAgICAgfSwgX3VwZGF0ZUhpZ2hsaWdodDogZnVuY3Rpb24gX3VwZGF0ZUhpZ2hsaWdodCgpIHtcXG4gICAgICAgIHZhciBiID0gcGFyc2VJbnQoYS5kYXRhKHRoaXMuX2lucHV0Rmlyc3QuZ2V0KDApLCBcXFwibW9iaWxlLXNsaWRlclxcXCIpLmhhbmRsZS5nZXQoMCkuc3R5bGUubGVmdCwgMTApLFxcbiAgICAgICAgICAgIGMgPSBwYXJzZUludChhLmRhdGEodGhpcy5faW5wdXRMYXN0LmdldCgwKSwgXFxcIm1vYmlsZS1zbGlkZXJcXFwiKS5oYW5kbGUuZ2V0KDApLnN0eWxlLmxlZnQsIDEwKSxcXG4gICAgICAgICAgICBkID0gYyAtIGI7dGhpcy5lbGVtZW50LmZpbmQoXFxcIi51aS1zbGlkZXItYmdcXFwiKS5jc3MoeyBcXFwibWFyZ2luLWxlZnRcXFwiOiBiICsgXFxcIiVcXFwiLCB3aWR0aDogZCArIFxcXCIlXFxcIiB9KTtcXG4gICAgICB9LCBfc2V0VGhlbWU6IGZ1bmN0aW9uIF9zZXRUaGVtZShhKSB7XFxuICAgICAgICB0aGlzLl9pbnB1dEZpcnN0LnNsaWRlcihcXFwib3B0aW9uXFxcIiwgXFxcInRoZW1lXFxcIiwgYSksIHRoaXMuX2lucHV0TGFzdC5zbGlkZXIoXFxcIm9wdGlvblxcXCIsIFxcXCJ0aGVtZVxcXCIsIGEpO1xcbiAgICAgIH0sIF9zZXRUcmFja1RoZW1lOiBmdW5jdGlvbiBfc2V0VHJhY2tUaGVtZShhKSB7XFxuICAgICAgICB0aGlzLl9pbnB1dEZpcnN0LnNsaWRlcihcXFwib3B0aW9uXFxcIiwgXFxcInRyYWNrVGhlbWVcXFwiLCBhKSwgdGhpcy5faW5wdXRMYXN0LnNsaWRlcihcXFwib3B0aW9uXFxcIiwgXFxcInRyYWNrVGhlbWVcXFwiLCBhKTtcXG4gICAgICB9LCBfc2V0TWluaTogZnVuY3Rpb24gX3NldE1pbmkoYSkge1xcbiAgICAgICAgdGhpcy5faW5wdXRGaXJzdC5zbGlkZXIoXFxcIm9wdGlvblxcXCIsIFxcXCJtaW5pXFxcIiwgYSksIHRoaXMuX2lucHV0TGFzdC5zbGlkZXIoXFxcIm9wdGlvblxcXCIsIFxcXCJtaW5pXFxcIiwgYSksIHRoaXMuZWxlbWVudC50b2dnbGVDbGFzcyhcXFwidWktbWluaVxcXCIsICEhYSk7XFxuICAgICAgfSwgX3NldEhpZ2hsaWdodDogZnVuY3Rpb24gX3NldEhpZ2hsaWdodChhKSB7XFxuICAgICAgICB0aGlzLl9pbnB1dEZpcnN0LnNsaWRlcihcXFwib3B0aW9uXFxcIiwgXFxcImhpZ2hsaWdodFxcXCIsIGEpLCB0aGlzLl9pbnB1dExhc3Quc2xpZGVyKFxcXCJvcHRpb25cXFwiLCBcXFwiaGlnaGxpZ2h0XFxcIiwgYSk7XFxuICAgICAgfSwgX3NldERpc2FibGVkOiBmdW5jdGlvbiBfc2V0RGlzYWJsZWQoYSkge1xcbiAgICAgICAgdGhpcy5faW5wdXRGaXJzdC5wcm9wKFxcXCJkaXNhYmxlZFxcXCIsIGEpLCB0aGlzLl9pbnB1dExhc3QucHJvcChcXFwiZGlzYWJsZWRcXFwiLCBhKTtcXG4gICAgICB9LCBfZGVzdHJveTogZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XFxuICAgICAgICB0aGlzLl9sYWJlbC5wcmVwZW5kVG8odGhpcy5lbGVtZW50KSwgdGhpcy5lbGVtZW50LnJlbW92ZUNsYXNzKFxcXCJ1aS1yYW5nZXNsaWRlciB1aS1taW5pXFxcIiksIHRoaXMuX2lucHV0Rmlyc3QuYWZ0ZXIodGhpcy5fc2xpZGVyRmlyc3QpLCB0aGlzLl9pbnB1dExhc3QuYWZ0ZXIodGhpcy5fc2xpZGVyTGFzdCksIHRoaXMuX3NsaWRlcnMucmVtb3ZlKCksIHRoaXMuZWxlbWVudC5maW5kKFxcXCJpbnB1dFxcXCIpLnJlbW92ZUNsYXNzKFxcXCJ1aS1yYW5nZXNsaWRlci1maXJzdCB1aS1yYW5nZXNsaWRlci1sYXN0XFxcIikuc2xpZGVyKFxcXCJkZXN0cm95XFxcIik7XFxuICAgICAgfSB9LCBhLm1vYmlsZS5iZWhhdmlvcnMuZm9ybVJlc2V0KSk7XFxuICB9KGEpLCBmdW5jdGlvbiAoYSwgYikge1xcbiAgICBhLndpZGdldChcXFwibW9iaWxlLnRleHRpbnB1dFxcXCIsIGEubW9iaWxlLnRleHRpbnB1dCwgeyBvcHRpb25zOiB7IGNsZWFyQnRuOiAhMSwgY2xlYXJCdG5UZXh0OiBcXFwiQ2xlYXIgdGV4dFxcXCIgfSwgX2NyZWF0ZTogZnVuY3Rpb24gX2NyZWF0ZSgpIHtcXG4gICAgICAgIHRoaXMuX3N1cGVyKCksIHRoaXMuaXNTZWFyY2ggJiYgKHRoaXMub3B0aW9ucy5jbGVhckJ0biA9ICEwKSwgdGhpcy5vcHRpb25zLmNsZWFyQnRuICYmIHRoaXMuaW5wdXROZWVkc1dyYXAgJiYgdGhpcy5fYWRkQ2xlYXJCdG4oKTtcXG4gICAgICB9LCBjbGVhckJ1dHRvbjogZnVuY3Rpb24gY2xlYXJCdXR0b24oKSB7XFxuICAgICAgICByZXR1cm4gYShcXFwiPGEgaHJlZj0nIycgdGFiaW5kZXg9Jy0xJyBhcmlhLWhpZGRlbj0ndHJ1ZScgY2xhc3M9J3VpLWlucHV0LWNsZWFyIHVpLWJ0biB1aS1pY29uLWRlbGV0ZSB1aS1idG4taWNvbi1ub3RleHQgdWktY29ybmVyLWFsbCc+PC9hPlxcXCIpLmF0dHIoXFxcInRpdGxlXFxcIiwgdGhpcy5vcHRpb25zLmNsZWFyQnRuVGV4dCkudGV4dCh0aGlzLm9wdGlvbnMuY2xlYXJCdG5UZXh0KTtcXG4gICAgICB9LCBfY2xlYXJCdG5DbGljazogZnVuY3Rpb24gX2NsZWFyQnRuQ2xpY2soYSkge1xcbiAgICAgICAgdGhpcy5lbGVtZW50LnZhbChcXFwiXFxcIikuZm9jdXMoKS50cmlnZ2VyKFxcXCJjaGFuZ2VcXFwiKSwgdGhpcy5fY2xlYXJCdG4uYWRkQ2xhc3MoXFxcInVpLWlucHV0LWNsZWFyLWhpZGRlblxcXCIpLCBhLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgfSwgX2FkZENsZWFyQnRuOiBmdW5jdGlvbiBfYWRkQ2xlYXJCdG4oKSB7XFxuICAgICAgICB0aGlzLm9wdGlvbnMuZW5oYW5jZWQgfHwgdGhpcy5fZW5oYW5jZUNsZWFyKCksIGEuZXh0ZW5kKHRoaXMsIHsgX2NsZWFyQnRuOiB0aGlzLndpZGdldCgpLmZpbmQoXFxcImEudWktaW5wdXQtY2xlYXJcXFwiKSB9KSwgdGhpcy5fYmluZENsZWFyRXZlbnRzKCksIHRoaXMuX3RvZ2dsZUNsZWFyKCk7XFxuICAgICAgfSwgX2VuaGFuY2VDbGVhcjogZnVuY3Rpb24gX2VuaGFuY2VDbGVhcigpIHtcXG4gICAgICAgIHRoaXMuY2xlYXJCdXR0b24oKS5hcHBlbmRUbyh0aGlzLndpZGdldCgpKSwgdGhpcy53aWRnZXQoKS5hZGRDbGFzcyhcXFwidWktaW5wdXQtaGFzLWNsZWFyXFxcIik7XFxuICAgICAgfSwgX2JpbmRDbGVhckV2ZW50czogZnVuY3Rpb24gX2JpbmRDbGVhckV2ZW50cygpIHtcXG4gICAgICAgIHRoaXMuX29uKHRoaXMuX2NsZWFyQnRuLCB7IGNsaWNrOiBcXFwiX2NsZWFyQnRuQ2xpY2tcXFwiIH0pLCB0aGlzLl9vbih7IGtleXVwOiBcXFwiX3RvZ2dsZUNsZWFyXFxcIiwgY2hhbmdlOiBcXFwiX3RvZ2dsZUNsZWFyXFxcIiwgaW5wdXQ6IFxcXCJfdG9nZ2xlQ2xlYXJcXFwiLCBmb2N1czogXFxcIl90b2dnbGVDbGVhclxcXCIsIGJsdXI6IFxcXCJfdG9nZ2xlQ2xlYXJcXFwiLCBjdXQ6IFxcXCJfdG9nZ2xlQ2xlYXJcXFwiLCBwYXN0ZTogXFxcIl90b2dnbGVDbGVhclxcXCIgfSk7XFxuICAgICAgfSwgX3VuYmluZENsZWFyOiBmdW5jdGlvbiBfdW5iaW5kQ2xlYXIoKSB7XFxuICAgICAgICB0aGlzLl9vZmYodGhpcy5fY2xlYXJCdG4sIFxcXCJjbGlja1xcXCIpLCB0aGlzLl9vZmYodGhpcy5lbGVtZW50LCBcXFwia2V5dXAgY2hhbmdlIGlucHV0IGZvY3VzIGJsdXIgY3V0IHBhc3RlXFxcIik7XFxuICAgICAgfSwgX3NldE9wdGlvbnM6IGZ1bmN0aW9uIF9zZXRPcHRpb25zKGEpIHtcXG4gICAgICAgIHRoaXMuX3N1cGVyKGEpLCBhLmNsZWFyQnRuID09PSBiIHx8IHRoaXMuZWxlbWVudC5pcyhcXFwidGV4dGFyZWEsIDpqcW1EYXRhKHR5cGU9J3JhbmdlJylcXFwiKSB8fCAoYS5jbGVhckJ0biA/IHRoaXMuX2FkZENsZWFyQnRuKCkgOiB0aGlzLl9kZXN0cm95Q2xlYXIoKSksIGEuY2xlYXJCdG5UZXh0ICE9PSBiICYmIHRoaXMuX2NsZWFyQnRuICE9PSBiICYmIHRoaXMuX2NsZWFyQnRuLnRleHQoYS5jbGVhckJ0blRleHQpLmF0dHIoXFxcInRpdGxlXFxcIiwgYS5jbGVhckJ0blRleHQpO1xcbiAgICAgIH0sIF90b2dnbGVDbGVhcjogZnVuY3Rpb24gX3RvZ2dsZUNsZWFyKCkge1xcbiAgICAgICAgdGhpcy5fZGVsYXkoXFxcIl90b2dnbGVDbGVhckNsYXNzXFxcIiwgMCk7XFxuICAgICAgfSwgX3RvZ2dsZUNsZWFyQ2xhc3M6IGZ1bmN0aW9uIF90b2dnbGVDbGVhckNsYXNzKCkge1xcbiAgICAgICAgdGhpcy5fY2xlYXJCdG4udG9nZ2xlQ2xhc3MoXFxcInVpLWlucHV0LWNsZWFyLWhpZGRlblxcXCIsICF0aGlzLmVsZW1lbnQudmFsKCkpO1xcbiAgICAgIH0sIF9kZXN0cm95Q2xlYXI6IGZ1bmN0aW9uIF9kZXN0cm95Q2xlYXIoKSB7XFxuICAgICAgICB0aGlzLndpZGdldCgpLnJlbW92ZUNsYXNzKFxcXCJ1aS1pbnB1dC1oYXMtY2xlYXJcXFwiKSwgdGhpcy5fdW5iaW5kQ2xlYXIoKSwgdGhpcy5fY2xlYXJCdG4ucmVtb3ZlKCk7XFxuICAgICAgfSwgX2Rlc3Ryb3k6IGZ1bmN0aW9uIF9kZXN0cm95KCkge1xcbiAgICAgICAgdGhpcy5fc3VwZXIoKSwgdGhpcy5vcHRpb25zLmNsZWFyQnRuICYmIHRoaXMuX2Rlc3Ryb3lDbGVhcigpO1xcbiAgICAgIH0gfSk7XFxuICB9KGEpLCBmdW5jdGlvbiAoYSwgYikge1xcbiAgICBhLndpZGdldChcXFwibW9iaWxlLnRleHRpbnB1dFxcXCIsIGEubW9iaWxlLnRleHRpbnB1dCwgeyBvcHRpb25zOiB7IGF1dG9ncm93OiAhMCwga2V5dXBUaW1lb3V0QnVmZmVyOiAxMDAgfSwgX2NyZWF0ZTogZnVuY3Rpb24gX2NyZWF0ZSgpIHtcXG4gICAgICAgIHRoaXMuX3N1cGVyKCksIHRoaXMub3B0aW9ucy5hdXRvZ3JvdyAmJiB0aGlzLmlzVGV4dGFyZWEgJiYgdGhpcy5fYXV0b2dyb3coKTtcXG4gICAgICB9LCBfYXV0b2dyb3c6IGZ1bmN0aW9uIF9hdXRvZ3JvdygpIHtcXG4gICAgICAgIHRoaXMuZWxlbWVudC5hZGRDbGFzcyhcXFwidWktdGV4dGlucHV0LWF1dG9ncm93XFxcIiksIHRoaXMuX29uKHsga2V5dXA6IFxcXCJfdGltZW91dFxcXCIsIGNoYW5nZTogXFxcIl90aW1lb3V0XFxcIiwgaW5wdXQ6IFxcXCJfdGltZW91dFxcXCIsIHBhc3RlOiBcXFwiX3RpbWVvdXRcXFwiIH0pLCB0aGlzLl9vbighMCwgdGhpcy5kb2N1bWVudCwgeyBwYWdlc2hvdzogXFxcIl9oYW5kbGVTaG93XFxcIiwgcG9wdXBiZWZvcmVwb3NpdGlvbjogXFxcIl9oYW5kbGVTaG93XFxcIiwgdXBkYXRlbGF5b3V0OiBcXFwiX2hhbmRsZVNob3dcXFwiLCBwYW5lbG9wZW46IFxcXCJfaGFuZGxlU2hvd1xcXCIgfSk7XFxuICAgICAgfSwgX2hhbmRsZVNob3c6IGZ1bmN0aW9uIF9oYW5kbGVTaG93KGIpIHtcXG4gICAgICAgIGEuY29udGFpbnMoYi50YXJnZXQsIHRoaXMuZWxlbWVudFswXSkgJiYgdGhpcy5lbGVtZW50LmlzKFxcXCI6dmlzaWJsZVxcXCIpICYmIChcXFwicG9wdXBiZWZvcmVwb3NpdGlvblxcXCIgIT09IGIudHlwZSAmJiB0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoXFxcInVpLXRleHRpbnB1dC1hdXRvZ3Jvdy1yZXNpemVcXFwiKS5hbmltYXRpb25Db21wbGV0ZShhLnByb3h5KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZUNsYXNzKFxcXCJ1aS10ZXh0aW5wdXQtYXV0b2dyb3ctcmVzaXplXFxcIik7XFxuICAgICAgICB9LCB0aGlzKSwgXFxcInRyYW5zaXRpb25cXFwiKSwgdGhpcy5fcHJlcGFyZUhlaWdodFVwZGF0ZSgpKTtcXG4gICAgICB9LCBfdW5iaW5kQXV0b2dyb3c6IGZ1bmN0aW9uIF91bmJpbmRBdXRvZ3JvdygpIHtcXG4gICAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVDbGFzcyhcXFwidWktdGV4dGlucHV0LWF1dG9ncm93XFxcIiksIHRoaXMuX29mZih0aGlzLmVsZW1lbnQsIFxcXCJrZXl1cCBjaGFuZ2UgaW5wdXQgcGFzdGVcXFwiKSwgdGhpcy5fb2ZmKHRoaXMuZG9jdW1lbnQsIFxcXCJwYWdlc2hvdyBwb3B1cGJlZm9yZXBvc2l0aW9uIHVwZGF0ZWxheW91dCBwYW5lbG9wZW5cXFwiKTtcXG4gICAgICB9LCBrZXl1cFRpbWVvdXQ6IG51bGwsIF9wcmVwYXJlSGVpZ2h0VXBkYXRlOiBmdW5jdGlvbiBfcHJlcGFyZUhlaWdodFVwZGF0ZShhKSB7XFxuICAgICAgICB0aGlzLmtleXVwVGltZW91dCAmJiBjbGVhclRpbWVvdXQodGhpcy5rZXl1cFRpbWVvdXQpLCBhID09PSBiID8gdGhpcy5fdXBkYXRlSGVpZ2h0KCkgOiB0aGlzLmtleXVwVGltZW91dCA9IHRoaXMuX2RlbGF5KFxcXCJfdXBkYXRlSGVpZ2h0XFxcIiwgYSk7XFxuICAgICAgfSwgX3RpbWVvdXQ6IGZ1bmN0aW9uIF90aW1lb3V0KCkge1xcbiAgICAgICAgdGhpcy5fcHJlcGFyZUhlaWdodFVwZGF0ZSh0aGlzLm9wdGlvbnMua2V5dXBUaW1lb3V0QnVmZmVyKTtcXG4gICAgICB9LCBfdXBkYXRlSGVpZ2h0OiBmdW5jdGlvbiBfdXBkYXRlSGVpZ2h0KCkge1xcbiAgICAgICAgdmFyIGEsXFxuICAgICAgICAgICAgYixcXG4gICAgICAgICAgICBjLFxcbiAgICAgICAgICAgIGQsXFxuICAgICAgICAgICAgZSxcXG4gICAgICAgICAgICBmLFxcbiAgICAgICAgICAgIGcsXFxuICAgICAgICAgICAgaCxcXG4gICAgICAgICAgICBpLFxcbiAgICAgICAgICAgIGogPSB0aGlzLndpbmRvdy5zY3JvbGxUb3AoKTt0aGlzLmtleXVwVGltZW91dCA9IDAsIFxcXCJvbnBhZ2VcXFwiIGluIHRoaXMuZWxlbWVudFswXSB8fCB0aGlzLmVsZW1lbnQuY3NzKHsgaGVpZ2h0OiAwLCBcXFwibWluLWhlaWdodFxcXCI6IDAsIFxcXCJtYXgtaGVpZ2h0XFxcIjogMCB9KSwgZCA9IHRoaXMuZWxlbWVudFswXS5zY3JvbGxIZWlnaHQsIGUgPSB0aGlzLmVsZW1lbnRbMF0uY2xpZW50SGVpZ2h0LCBmID0gcGFyc2VGbG9hdCh0aGlzLmVsZW1lbnQuY3NzKFxcXCJib3JkZXItdG9wLXdpZHRoXFxcIikpLCBnID0gcGFyc2VGbG9hdCh0aGlzLmVsZW1lbnQuY3NzKFxcXCJib3JkZXItYm90dG9tLXdpZHRoXFxcIikpLCBoID0gZiArIGcsIGkgPSBkICsgaCArIDE1LCAwID09PSBlICYmIChhID0gcGFyc2VGbG9hdCh0aGlzLmVsZW1lbnQuY3NzKFxcXCJwYWRkaW5nLXRvcFxcXCIpKSwgYiA9IHBhcnNlRmxvYXQodGhpcy5lbGVtZW50LmNzcyhcXFwicGFkZGluZy1ib3R0b21cXFwiKSksIGMgPSBhICsgYiwgaSArPSBjKSwgdGhpcy5lbGVtZW50LmNzcyh7IGhlaWdodDogaSwgXFxcIm1pbi1oZWlnaHRcXFwiOiBcXFwiXFxcIiwgXFxcIm1heC1oZWlnaHRcXFwiOiBcXFwiXFxcIiB9KSwgdGhpcy53aW5kb3cuc2Nyb2xsVG9wKGopO1xcbiAgICAgIH0sIHJlZnJlc2g6IGZ1bmN0aW9uIHJlZnJlc2goKSB7XFxuICAgICAgICB0aGlzLm9wdGlvbnMuYXV0b2dyb3cgJiYgdGhpcy5pc1RleHRhcmVhICYmIHRoaXMuX3VwZGF0ZUhlaWdodCgpO1xcbiAgICAgIH0sIF9zZXRPcHRpb25zOiBmdW5jdGlvbiBfc2V0T3B0aW9ucyhhKSB7XFxuICAgICAgICB0aGlzLl9zdXBlcihhKSwgYS5hdXRvZ3JvdyAhPT0gYiAmJiB0aGlzLmlzVGV4dGFyZWEgJiYgKGEuYXV0b2dyb3cgPyB0aGlzLl9hdXRvZ3JvdygpIDogdGhpcy5fdW5iaW5kQXV0b2dyb3coKSk7XFxuICAgICAgfSB9KTtcXG4gIH0oYSksIGZ1bmN0aW9uIChhKSB7XFxuICAgIGEud2lkZ2V0KFxcXCJtb2JpbGUuc2VsZWN0bWVudVxcXCIsIGEuZXh0ZW5kKHsgaW5pdFNlbGVjdG9yOiBcXFwic2VsZWN0Om5vdCggOmpxbURhdGEocm9sZT0nc2xpZGVyJykpOm5vdCggOmpxbURhdGEocm9sZT0nZmxpcHN3aXRjaCcpIClcXFwiLCBvcHRpb25zOiB7IHRoZW1lOiBudWxsLCBpY29uOiBcXFwiY2FyYXQtZFxcXCIsIGljb25wb3M6IFxcXCJyaWdodFxcXCIsIGlubGluZTogITEsIGNvcm5lcnM6ICEwLCBzaGFkb3c6ICEwLCBpY29uc2hhZG93OiAhMSwgb3ZlcmxheVRoZW1lOiBudWxsLCBkaXZpZGVyVGhlbWU6IG51bGwsIGhpZGVQbGFjZWhvbGRlck1lbnVJdGVtczogITAsIGNsb3NlVGV4dDogXFxcIkNsb3NlXFxcIiwgbmF0aXZlTWVudTogITAsIHByZXZlbnRGb2N1c1pvb206IC9pUGhvbmV8aVBhZHxpUG9kLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSkgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFxcXCJBcHBsZVdlYktpdFxcXCIpID4gLTEsIG1pbmk6ICExIH0sIF9idXR0b246IGZ1bmN0aW9uIF9idXR0b24oKSB7XFxuICAgICAgICByZXR1cm4gYShcXFwiPGRpdi8+XFxcIik7XFxuICAgICAgfSwgX3NldERpc2FibGVkOiBmdW5jdGlvbiBfc2V0RGlzYWJsZWQoYSkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC5hdHRyKFxcXCJkaXNhYmxlZFxcXCIsIGEpLCB0aGlzLmJ1dHRvbi5hdHRyKFxcXCJhcmlhLWRpc2FibGVkXFxcIiwgYSksIHRoaXMuX3NldE9wdGlvbihcXFwiZGlzYWJsZWRcXFwiLCBhKTtcXG4gICAgICB9LCBfZm9jdXNCdXR0b246IGZ1bmN0aW9uIF9mb2N1c0J1dHRvbigpIHtcXG4gICAgICAgIHZhciBhID0gdGhpcztzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgYS5idXR0b24uZm9jdXMoKTtcXG4gICAgICAgIH0sIDQwKTtcXG4gICAgICB9LCBfc2VsZWN0T3B0aW9uczogZnVuY3Rpb24gX3NlbGVjdE9wdGlvbnMoKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3QuZmluZChcXFwib3B0aW9uXFxcIik7XFxuICAgICAgfSwgX3ByZUV4dGVuc2lvbjogZnVuY3Rpb24gX3ByZUV4dGVuc2lvbigpIHtcXG4gICAgICAgIHZhciBiID0gdGhpcy5vcHRpb25zLmlubGluZSB8fCB0aGlzLmVsZW1lbnQuanFtRGF0YShcXFwiaW5saW5lXFxcIiksXFxuICAgICAgICAgICAgYyA9IHRoaXMub3B0aW9ucy5taW5pIHx8IHRoaXMuZWxlbWVudC5qcW1EYXRhKFxcXCJtaW5pXFxcIiksXFxuICAgICAgICAgICAgZCA9IFxcXCJcXFwiO350aGlzLmVsZW1lbnRbMF0uY2xhc3NOYW1lLmluZGV4T2YoXFxcInVpLWJ0bi1sZWZ0XFxcIikgJiYgKGQgPSBcXFwiIHVpLWJ0bi1sZWZ0XFxcIiksIH50aGlzLmVsZW1lbnRbMF0uY2xhc3NOYW1lLmluZGV4T2YoXFxcInVpLWJ0bi1yaWdodFxcXCIpICYmIChkID0gXFxcIiB1aS1idG4tcmlnaHRcXFwiKSwgYiAmJiAoZCArPSBcXFwiIHVpLWJ0bi1pbmxpbmVcXFwiKSwgYyAmJiAoZCArPSBcXFwiIHVpLW1pbmlcXFwiKSwgdGhpcy5zZWxlY3QgPSB0aGlzLmVsZW1lbnQucmVtb3ZlQ2xhc3MoXFxcInVpLWJ0bi1sZWZ0IHVpLWJ0bi1yaWdodFxcXCIpLndyYXAoXFxcIjxkaXYgY2xhc3M9J3VpLXNlbGVjdFxcXCIgKyBkICsgXFxcIic+XFxcIiksIHRoaXMuc2VsZWN0SWQgPSB0aGlzLnNlbGVjdC5hdHRyKFxcXCJpZFxcXCIpIHx8IFxcXCJzZWxlY3QtXFxcIiArIHRoaXMudXVpZCwgdGhpcy5idXR0b25JZCA9IHRoaXMuc2VsZWN0SWQgKyBcXFwiLWJ1dHRvblxcXCIsIHRoaXMubGFiZWwgPSBhKFxcXCJsYWJlbFtmb3I9J1xcXCIgKyB0aGlzLnNlbGVjdElkICsgXFxcIiddXFxcIiksIHRoaXMuaXNNdWx0aXBsZSA9IHRoaXMuc2VsZWN0WzBdLm11bHRpcGxlO1xcbiAgICAgIH0sIF9kZXN0cm95OiBmdW5jdGlvbiBfZGVzdHJveSgpIHtcXG4gICAgICAgIHZhciBhID0gdGhpcy5lbGVtZW50LnBhcmVudHMoXFxcIi51aS1zZWxlY3RcXFwiKTthLmxlbmd0aCA+IDAgJiYgKGEuaXMoXFxcIi51aS1idG4tbGVmdCwgLnVpLWJ0bi1yaWdodFxcXCIpICYmIHRoaXMuZWxlbWVudC5hZGRDbGFzcyhhLmhhc0NsYXNzKFxcXCJ1aS1idG4tbGVmdFxcXCIpID8gXFxcInVpLWJ0bi1sZWZ0XFxcIiA6IFxcXCJ1aS1idG4tcmlnaHRcXFwiKSwgdGhpcy5lbGVtZW50Lmluc2VydEFmdGVyKGEpLCBhLnJlbW92ZSgpKTtcXG4gICAgICB9LCBfY3JlYXRlOiBmdW5jdGlvbiBfY3JlYXRlKCkge1xcbiAgICAgICAgdGhpcy5fcHJlRXh0ZW5zaW9uKCksIHRoaXMuYnV0dG9uID0gdGhpcy5fYnV0dG9uKCk7dmFyIGMgPSB0aGlzLFxcbiAgICAgICAgICAgIGQgPSB0aGlzLm9wdGlvbnMsXFxuICAgICAgICAgICAgZSA9IGQuaWNvbiA/IGQuaWNvbnBvcyB8fCB0aGlzLnNlbGVjdC5qcW1EYXRhKFxcXCJpY29ucG9zXFxcIikgOiAhMSxcXG4gICAgICAgICAgICBmID0gdGhpcy5idXR0b24uaW5zZXJ0QmVmb3JlKHRoaXMuc2VsZWN0KS5hdHRyKFxcXCJpZFxcXCIsIHRoaXMuYnV0dG9uSWQpLmFkZENsYXNzKFxcXCJ1aS1idG5cXFwiICsgKGQuaWNvbiA/IFxcXCIgdWktaWNvbi1cXFwiICsgZC5pY29uICsgXFxcIiB1aS1idG4taWNvbi1cXFwiICsgZSArIChkLmljb25zaGFkb3cgPyBcXFwiIHVpLXNoYWRvdy1pY29uXFxcIiA6IFxcXCJcXFwiKSA6IFxcXCJcXFwiKSArIChkLnRoZW1lID8gXFxcIiB1aS1idG4tXFxcIiArIGQudGhlbWUgOiBcXFwiXFxcIikgKyAoZC5jb3JuZXJzID8gXFxcIiB1aS1jb3JuZXItYWxsXFxcIiA6IFxcXCJcXFwiKSArIChkLnNoYWRvdyA/IFxcXCIgdWktc2hhZG93XFxcIiA6IFxcXCJcXFwiKSk7dGhpcy5zZXRCdXR0b25UZXh0KCksIGQubmF0aXZlTWVudSAmJiBiLm9wZXJhICYmIGIub3BlcmEudmVyc2lvbiAmJiBmLmFkZENsYXNzKFxcXCJ1aS1zZWxlY3QtbmF0aXZlb25seVxcXCIpLCB0aGlzLmlzTXVsdGlwbGUgJiYgKHRoaXMuYnV0dG9uQ291bnQgPSBhKFxcXCI8c3Bhbj5cXFwiKS5hZGRDbGFzcyhcXFwidWktbGktY291bnQgdWktYm9keS1pbmhlcml0XFxcIikuaGlkZSgpLmFwcGVuZFRvKGYuYWRkQ2xhc3MoXFxcInVpLWxpLWhhcy1jb3VudFxcXCIpKSksIChkLmRpc2FibGVkIHx8IHRoaXMuZWxlbWVudC5hdHRyKFxcXCJkaXNhYmxlZFxcXCIpKSAmJiB0aGlzLmRpc2FibGUoKSwgdGhpcy5zZWxlY3QuY2hhbmdlKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgYy5yZWZyZXNoKCksIGQubmF0aXZlTWVudSAmJiBjLl9kZWxheShmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgYy5zZWxlY3QuYmx1cigpO1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH0pLCB0aGlzLl9oYW5kbGVGb3JtUmVzZXQoKSwgdGhpcy5fb24odGhpcy5idXR0b24sIHsga2V5ZG93bjogXFxcIl9oYW5kbGVLZXlkb3duXFxcIiB9KSwgdGhpcy5idWlsZCgpO1xcbiAgICAgIH0sIGJ1aWxkOiBmdW5jdGlvbiBidWlsZCgpIHtcXG4gICAgICAgIHZhciBiID0gdGhpczt0aGlzLnNlbGVjdC5hcHBlbmRUbyhiLmJ1dHRvbikuYmluZChcXFwidm1vdXNlZG93blxcXCIsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgYi5idXR0b24uYWRkQ2xhc3MoYS5tb2JpbGUuYWN0aXZlQnRuQ2xhc3MpO1xcbiAgICAgICAgfSkuYmluZChcXFwiZm9jdXNcXFwiLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIGIuYnV0dG9uLmFkZENsYXNzKGEubW9iaWxlLmZvY3VzQ2xhc3MpO1xcbiAgICAgICAgfSkuYmluZChcXFwiYmx1clxcXCIsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgYi5idXR0b24ucmVtb3ZlQ2xhc3MoYS5tb2JpbGUuZm9jdXNDbGFzcyk7XFxuICAgICAgICB9KS5iaW5kKFxcXCJmb2N1cyB2bW91c2VvdmVyXFxcIiwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBiLmJ1dHRvbi50cmlnZ2VyKFxcXCJ2bW91c2VvdmVyXFxcIik7XFxuICAgICAgICB9KS5iaW5kKFxcXCJ2bW91c2Vtb3ZlXFxcIiwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBiLmJ1dHRvbi5yZW1vdmVDbGFzcyhhLm1vYmlsZS5hY3RpdmVCdG5DbGFzcyk7XFxuICAgICAgICB9KS5iaW5kKFxcXCJjaGFuZ2UgYmx1ciB2bW91c2VvdXRcXFwiLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIGIuYnV0dG9uLnRyaWdnZXIoXFxcInZtb3VzZW91dFxcXCIpLnJlbW92ZUNsYXNzKGEubW9iaWxlLmFjdGl2ZUJ0bkNsYXNzKTtcXG4gICAgICAgIH0pLCBiLmJ1dHRvbi5iaW5kKFxcXCJ2bW91c2Vkb3duXFxcIiwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBiLm9wdGlvbnMucHJldmVudEZvY3VzWm9vbSAmJiBhLm1vYmlsZS56b29tLmRpc2FibGUoITApO1xcbiAgICAgICAgfSksIGIubGFiZWwuYmluZChcXFwiY2xpY2sgZm9jdXNcXFwiLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIGIub3B0aW9ucy5wcmV2ZW50Rm9jdXNab29tICYmIGEubW9iaWxlLnpvb20uZGlzYWJsZSghMCk7XFxuICAgICAgICB9KSwgYi5zZWxlY3QuYmluZChcXFwiZm9jdXNcXFwiLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIGIub3B0aW9ucy5wcmV2ZW50Rm9jdXNab29tICYmIGEubW9iaWxlLnpvb20uZGlzYWJsZSghMCk7XFxuICAgICAgICB9KSwgYi5idXR0b24uYmluZChcXFwibW91c2V1cFxcXCIsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgYi5vcHRpb25zLnByZXZlbnRGb2N1c1pvb20gJiYgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgYS5tb2JpbGUuem9vbS5lbmFibGUoITApO1xcbiAgICAgICAgICB9LCAwKTtcXG4gICAgICAgIH0pLCBiLnNlbGVjdC5iaW5kKFxcXCJibHVyXFxcIiwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBiLm9wdGlvbnMucHJldmVudEZvY3VzWm9vbSAmJiBhLm1vYmlsZS56b29tLmVuYWJsZSghMCk7XFxuICAgICAgICB9KTtcXG4gICAgICB9LCBzZWxlY3RlZDogZnVuY3Rpb24gc2VsZWN0ZWQoKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5fc2VsZWN0T3B0aW9ucygpLmZpbHRlcihcXFwiOnNlbGVjdGVkXFxcIik7XFxuICAgICAgfSwgc2VsZWN0ZWRJbmRpY2VzOiBmdW5jdGlvbiBzZWxlY3RlZEluZGljZXMoKSB7XFxuICAgICAgICB2YXIgYSA9IHRoaXM7cmV0dXJuIHRoaXMuc2VsZWN0ZWQoKS5tYXAoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICByZXR1cm4gYS5fc2VsZWN0T3B0aW9ucygpLmluZGV4KHRoaXMpO1xcbiAgICAgICAgfSkuZ2V0KCk7XFxuICAgICAgfSwgc2V0QnV0dG9uVGV4dDogZnVuY3Rpb24gc2V0QnV0dG9uVGV4dCgpIHtcXG4gICAgICAgIHZhciBiID0gdGhpcyxcXG4gICAgICAgICAgICBkID0gdGhpcy5zZWxlY3RlZCgpLFxcbiAgICAgICAgICAgIGUgPSB0aGlzLnBsYWNlaG9sZGVyLFxcbiAgICAgICAgICAgIGYgPSBhKGMuY3JlYXRlRWxlbWVudChcXFwic3BhblxcXCIpKTt0aGlzLmJ1dHRvbi5jaGlsZHJlbihcXFwic3BhblxcXCIpLm5vdChcXFwiLnVpLWxpLWNvdW50XFxcIikucmVtb3ZlKCkuZW5kKCkuZW5kKCkucHJlcGVuZChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHJldHVybiBlID0gZC5sZW5ndGggPyBkLm1hcChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGEodGhpcykudGV4dCgpO1xcbiAgICAgICAgICB9KS5nZXQoKS5qb2luKFxcXCIsIFxcXCIpIDogYi5wbGFjZWhvbGRlciwgZSA/IGYudGV4dChlKSA6IGYuaHRtbChcXFwiJiMxNjA7XFxcIiksIGYuYWRkQ2xhc3MoYi5zZWxlY3QuYXR0cihcXFwiY2xhc3NcXFwiKSkuYWRkQ2xhc3MoZC5hdHRyKFxcXCJjbGFzc1xcXCIpKS5yZW1vdmVDbGFzcyhcXFwidWktc2NyZWVuLWhpZGRlblxcXCIpO1xcbiAgICAgICAgfSgpKTtcXG4gICAgICB9LCBzZXRCdXR0b25Db3VudDogZnVuY3Rpb24gc2V0QnV0dG9uQ291bnQoKSB7XFxuICAgICAgICB2YXIgYSA9IHRoaXMuc2VsZWN0ZWQoKTt0aGlzLmlzTXVsdGlwbGUgJiYgdGhpcy5idXR0b25Db3VudFthLmxlbmd0aCA+IDEgPyBcXFwic2hvd1xcXCIgOiBcXFwiaGlkZVxcXCJdKCkudGV4dChhLmxlbmd0aCk7XFxuICAgICAgfSwgX2hhbmRsZUtleWRvd246IGZ1bmN0aW9uIF9oYW5kbGVLZXlkb3duKCkge1xcbiAgICAgICAgdGhpcy5fZGVsYXkoXFxcIl9yZWZyZXNoQnV0dG9uXFxcIik7XFxuICAgICAgfSwgX3Jlc2V0OiBmdW5jdGlvbiBfcmVzZXQoKSB7XFxuICAgICAgICB0aGlzLnJlZnJlc2goKTtcXG4gICAgICB9LCBfcmVmcmVzaEJ1dHRvbjogZnVuY3Rpb24gX3JlZnJlc2hCdXR0b24oKSB7XFxuICAgICAgICB0aGlzLnNldEJ1dHRvblRleHQoKSwgdGhpcy5zZXRCdXR0b25Db3VudCgpO1xcbiAgICAgIH0sIHJlZnJlc2g6IGZ1bmN0aW9uIHJlZnJlc2goKSB7XFxuICAgICAgICB0aGlzLl9yZWZyZXNoQnV0dG9uKCk7XFxuICAgICAgfSwgb3BlbjogYS5ub29wLCBjbG9zZTogYS5ub29wLCBkaXNhYmxlOiBmdW5jdGlvbiBkaXNhYmxlKCkge1xcbiAgICAgICAgdGhpcy5fc2V0RGlzYWJsZWQoITApLCB0aGlzLmJ1dHRvbi5hZGRDbGFzcyhcXFwidWktc3RhdGUtZGlzYWJsZWRcXFwiKTtcXG4gICAgICB9LCBlbmFibGU6IGZ1bmN0aW9uIGVuYWJsZSgpIHtcXG4gICAgICAgIHRoaXMuX3NldERpc2FibGVkKCExKSwgdGhpcy5idXR0b24ucmVtb3ZlQ2xhc3MoXFxcInVpLXN0YXRlLWRpc2FibGVkXFxcIik7XFxuICAgICAgfSB9LCBhLm1vYmlsZS5iZWhhdmlvcnMuZm9ybVJlc2V0KSk7XFxuICB9KGEpLCBmdW5jdGlvbiAoYSkge1xcbiAgICBhLm1vYmlsZS5saW5rcyA9IGZ1bmN0aW9uIChiKSB7XFxuICAgICAgYShiKS5maW5kKFxcXCJhXFxcIikuanFtRW5oYW5jZWFibGUoKS5maWx0ZXIoXFxcIjpqcW1EYXRhKHJlbD0ncG9wdXAnKVtocmVmXVtocmVmIT0nJ11cXFwiKS5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciBhID0gdGhpcyxcXG4gICAgICAgICAgICBiID0gYS5nZXRBdHRyaWJ1dGUoXFxcImhyZWZcXFwiKS5zdWJzdHJpbmcoMSk7YiAmJiAoYS5zZXRBdHRyaWJ1dGUoXFxcImFyaWEtaGFzcG9wdXBcXFwiLCAhMCksIGEuc2V0QXR0cmlidXRlKFxcXCJhcmlhLW93bnNcXFwiLCBiKSwgYS5zZXRBdHRyaWJ1dGUoXFxcImFyaWEtZXhwYW5kZWRcXFwiLCAhMSkpO1xcbiAgICAgIH0pLmVuZCgpLm5vdChcXFwiLnVpLWJ0biwgOmpxbURhdGEocm9sZT0nbm9uZScpLCA6anFtRGF0YShyb2xlPSdub2pzJylcXFwiKS5hZGRDbGFzcyhcXFwidWktbGlua1xcXCIpO1xcbiAgICB9O1xcbiAgfShhKSwgZnVuY3Rpb24gKGEsIGMpIHtcXG4gICAgZnVuY3Rpb24gZChhLCBiLCBjLCBkKSB7XFxuICAgICAgdmFyIGUgPSBkO3JldHVybiBlID0gYiA+IGEgPyBjICsgKGEgLSBiKSAvIDIgOiBNYXRoLm1pbihNYXRoLm1heChjLCBkIC0gYiAvIDIpLCBjICsgYSAtIGIpO1xcbiAgICB9ZnVuY3Rpb24gZShhKSB7XFxuICAgICAgcmV0dXJuIHsgeDogYS5zY3JvbGxMZWZ0KCksIHk6IGEuc2Nyb2xsVG9wKCksIGN4OiBhWzBdLmlubmVyV2lkdGggfHwgYS53aWR0aCgpLCBjeTogYVswXS5pbm5lckhlaWdodCB8fCBhLmhlaWdodCgpIH07XFxuICAgIH1hLndpZGdldChcXFwibW9iaWxlLnBvcHVwXFxcIiwgeyBvcHRpb25zOiB7IHdyYXBwZXJDbGFzczogbnVsbCwgdGhlbWU6IG51bGwsIG92ZXJsYXlUaGVtZTogbnVsbCwgc2hhZG93OiAhMCwgY29ybmVyczogITAsIHRyYW5zaXRpb246IFxcXCJub25lXFxcIiwgcG9zaXRpb25UbzogXFxcIm9yaWdpblxcXCIsIHRvbGVyYW5jZTogbnVsbCwgY2xvc2VMaW5rU2VsZWN0b3I6IFxcXCJhOmpxbURhdGEocmVsPSdiYWNrJylcXFwiLCBjbG9zZUxpbmtFdmVudHM6IFxcXCJjbGljay5wb3B1cFxcXCIsIG5hdmlnYXRlRXZlbnRzOiBcXFwibmF2aWdhdGUucG9wdXBcXFwiLCBjbG9zZUV2ZW50czogXFxcIm5hdmlnYXRlLnBvcHVwIHBhZ2ViZWZvcmVjaGFuZ2UucG9wdXBcXFwiLCBkaXNtaXNzaWJsZTogITAsIGVuaGFuY2VkOiAhMSwgaGlzdG9yeTogIWEubW9iaWxlLmJyb3dzZXIub2xkSUUgfSwgX2hhbmRsZURvY3VtZW50Vm1vdXNlZG93bjogZnVuY3Rpb24gX2hhbmRsZURvY3VtZW50Vm1vdXNlZG93bihiKSB7XFxuICAgICAgICB0aGlzLl9pc09wZW4gJiYgYS5jb250YWlucyh0aGlzLl91aS5jb250YWluZXJbMF0sIGIudGFyZ2V0KSAmJiB0aGlzLl9pZ25vcmVSZXNpemVFdmVudHMoKTtcXG4gICAgICB9LCBfY3JlYXRlOiBmdW5jdGlvbiBfY3JlYXRlKCkge1xcbiAgICAgICAgdmFyIGIgPSB0aGlzLmVsZW1lbnQsXFxuICAgICAgICAgICAgYyA9IGIuYXR0cihcXFwiaWRcXFwiKSxcXG4gICAgICAgICAgICBkID0gdGhpcy5vcHRpb25zO2QuaGlzdG9yeSA9IGQuaGlzdG9yeSAmJiBhLm1vYmlsZS5hamF4RW5hYmxlZCAmJiBhLm1vYmlsZS5oYXNoTGlzdGVuaW5nRW5hYmxlZCwgdGhpcy5fb24odGhpcy5kb2N1bWVudCwgeyB2bW91c2Vkb3duOiBcXFwiX2hhbmRsZURvY3VtZW50Vm1vdXNlZG93blxcXCIgfSksIGEuZXh0ZW5kKHRoaXMsIHsgX3Njcm9sbFRvcDogMCwgX3BhZ2U6IGIuY2xvc2VzdChcXFwiLnVpLXBhZ2VcXFwiKSwgX3VpOiBudWxsLCBfZmFsbGJhY2tUcmFuc2l0aW9uOiBcXFwiXFxcIiwgX2N1cnJlbnRUcmFuc2l0aW9uOiAhMSwgX3ByZXJlcXVpc2l0ZXM6IG51bGwsIF9pc09wZW46ICExLCBfdG9sZXJhbmNlOiBudWxsLCBfcmVzaXplRGF0YTogbnVsbCwgX2lnbm9yZVJlc2l6ZVRvOiAwLCBfb3JpZW50YXRpb25jaGFuZ2VJblByb2dyZXNzOiAhMSB9KSwgMCA9PT0gdGhpcy5fcGFnZS5sZW5ndGggJiYgKHRoaXMuX3BhZ2UgPSBhKFxcXCJib2R5XFxcIikpLCBkLmVuaGFuY2VkID8gdGhpcy5fdWkgPSB7IGNvbnRhaW5lcjogYi5wYXJlbnQoKSwgc2NyZWVuOiBiLnBhcmVudCgpLnByZXYoKSwgcGxhY2Vob2xkZXI6IGEodGhpcy5kb2N1bWVudFswXS5nZXRFbGVtZW50QnlJZChjICsgXFxcIi1wbGFjZWhvbGRlclxcXCIpKSB9IDogKHRoaXMuX3VpID0gdGhpcy5fZW5oYW5jZShiLCBjKSwgdGhpcy5fYXBwbHlUcmFuc2l0aW9uKGQudHJhbnNpdGlvbikpLCB0aGlzLl9zZXRUb2xlcmFuY2UoZC50b2xlcmFuY2UpLl91aS5mb2N1c0VsZW1lbnQgPSB0aGlzLl91aS5jb250YWluZXIsIHRoaXMuX29uKHRoaXMuX3VpLnNjcmVlbiwgeyB2Y2xpY2s6IFxcXCJfZWF0RXZlbnRBbmRDbG9zZVxcXCIgfSksIHRoaXMuX29uKHRoaXMud2luZG93LCB7IG9yaWVudGF0aW9uY2hhbmdlOiBhLnByb3h5KHRoaXMsIFxcXCJfaGFuZGxlV2luZG93T3JpZW50YXRpb25jaGFuZ2VcXFwiKSwgcmVzaXplOiBhLnByb3h5KHRoaXMsIFxcXCJfaGFuZGxlV2luZG93UmVzaXplXFxcIiksIGtleXVwOiBhLnByb3h5KHRoaXMsIFxcXCJfaGFuZGxlV2luZG93S2V5VXBcXFwiKSB9KSwgdGhpcy5fb24odGhpcy5kb2N1bWVudCwgeyBmb2N1c2luOiBcXFwiX2hhbmRsZURvY3VtZW50Rm9jdXNJblxcXCIgfSk7XFxuICAgICAgfSwgX2VuaGFuY2U6IGZ1bmN0aW9uIF9lbmhhbmNlKGIsIGMpIHtcXG4gICAgICAgIHZhciBkID0gdGhpcy5vcHRpb25zLFxcbiAgICAgICAgICAgIGUgPSBkLndyYXBwZXJDbGFzcyxcXG4gICAgICAgICAgICBmID0geyBzY3JlZW46IGEoXFxcIjxkaXYgY2xhc3M9J3VpLXNjcmVlbi1oaWRkZW4gdWktcG9wdXAtc2NyZWVuIFxcXCIgKyB0aGlzLl90aGVtZUNsYXNzRnJvbU9wdGlvbihcXFwidWktb3ZlcmxheS1cXFwiLCBkLm92ZXJsYXlUaGVtZSkgKyBcXFwiJz48L2Rpdj5cXFwiKSwgcGxhY2Vob2xkZXI6IGEoXFxcIjxkaXYgc3R5bGU9J2Rpc3BsYXk6IG5vbmU7Jz48IS0tIHBsYWNlaG9sZGVyIC0tPjwvZGl2PlxcXCIpLCBjb250YWluZXI6IGEoXFxcIjxkaXYgY2xhc3M9J3VpLXBvcHVwLWNvbnRhaW5lciB1aS1wb3B1cC1oaWRkZW4gdWktcG9wdXAtdHJ1bmNhdGVcXFwiICsgKGUgPyBcXFwiIFxcXCIgKyBlIDogXFxcIlxcXCIpICsgXFxcIic+PC9kaXY+XFxcIikgfSxcXG4gICAgICAgICAgICBnID0gdGhpcy5kb2N1bWVudFswXS5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7cmV0dXJuIGcuYXBwZW5kQ2hpbGQoZi5zY3JlZW5bMF0pLCBnLmFwcGVuZENoaWxkKGYuY29udGFpbmVyWzBdKSwgYyAmJiAoZi5zY3JlZW4uYXR0cihcXFwiaWRcXFwiLCBjICsgXFxcIi1zY3JlZW5cXFwiKSwgZi5jb250YWluZXIuYXR0cihcXFwiaWRcXFwiLCBjICsgXFxcIi1wb3B1cFxcXCIpLCBmLnBsYWNlaG9sZGVyLmF0dHIoXFxcImlkXFxcIiwgYyArIFxcXCItcGxhY2Vob2xkZXJcXFwiKS5odG1sKFxcXCI8IS0tIHBsYWNlaG9sZGVyIGZvciBcXFwiICsgYyArIFxcXCIgLS0+XFxcIikpLCB0aGlzLl9wYWdlWzBdLmFwcGVuZENoaWxkKGcpLCBmLnBsYWNlaG9sZGVyLmluc2VydEFmdGVyKGIpLCBiLmRldGFjaCgpLmFkZENsYXNzKFxcXCJ1aS1wb3B1cCBcXFwiICsgdGhpcy5fdGhlbWVDbGFzc0Zyb21PcHRpb24oXFxcInVpLWJvZHktXFxcIiwgZC50aGVtZSkgKyBcXFwiIFxcXCIgKyAoZC5zaGFkb3cgPyBcXFwidWktb3ZlcmxheS1zaGFkb3cgXFxcIiA6IFxcXCJcXFwiKSArIChkLmNvcm5lcnMgPyBcXFwidWktY29ybmVyLWFsbCBcXFwiIDogXFxcIlxcXCIpKS5hcHBlbmRUbyhmLmNvbnRhaW5lciksIGY7XFxuICAgICAgfSwgX2VhdEV2ZW50QW5kQ2xvc2U6IGZ1bmN0aW9uIF9lYXRFdmVudEFuZENsb3NlKGEpIHtcXG4gICAgICAgIHJldHVybiBhLnByZXZlbnREZWZhdWx0KCksIGEuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCksIHRoaXMub3B0aW9ucy5kaXNtaXNzaWJsZSAmJiB0aGlzLmNsb3NlKCksICExO1xcbiAgICAgIH0sIF9yZXNpemVTY3JlZW46IGZ1bmN0aW9uIF9yZXNpemVTY3JlZW4oKSB7XFxuICAgICAgICB2YXIgYSA9IHRoaXMuX3VpLnNjcmVlbixcXG4gICAgICAgICAgICBiID0gdGhpcy5fdWkuY29udGFpbmVyLm91dGVySGVpZ2h0KCEwKSxcXG4gICAgICAgICAgICBjID0gYS5yZW1vdmVBdHRyKFxcXCJzdHlsZVxcXCIpLmhlaWdodCgpLFxcbiAgICAgICAgICAgIGQgPSB0aGlzLmRvY3VtZW50LmhlaWdodCgpIC0gMTtkID4gYyA/IGEuaGVpZ2h0KGQpIDogYiA+IGMgJiYgYS5oZWlnaHQoYik7XFxuICAgICAgfSwgX2hhbmRsZVdpbmRvd0tleVVwOiBmdW5jdGlvbiBfaGFuZGxlV2luZG93S2V5VXAoYikge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzT3BlbiAmJiBiLmtleUNvZGUgPT09IGEubW9iaWxlLmtleUNvZGUuRVNDQVBFID8gdGhpcy5fZWF0RXZlbnRBbmRDbG9zZShiKSA6IHZvaWQgMDtcXG4gICAgICB9LCBfZXhwZWN0UmVzaXplRXZlbnQ6IGZ1bmN0aW9uIF9leHBlY3RSZXNpemVFdmVudCgpIHtcXG4gICAgICAgIHZhciBhID0gZSh0aGlzLndpbmRvdyk7XFxuICAgICAgICBpZiAodGhpcy5fcmVzaXplRGF0YSkge1xcbiAgICAgICAgICBpZiAoYS54ID09PSB0aGlzLl9yZXNpemVEYXRhLndpbmRvd0Nvb3JkaW5hdGVzLnggJiYgYS55ID09PSB0aGlzLl9yZXNpemVEYXRhLndpbmRvd0Nvb3JkaW5hdGVzLnkgJiYgYS5jeCA9PT0gdGhpcy5fcmVzaXplRGF0YS53aW5kb3dDb29yZGluYXRlcy5jeCAmJiBhLmN5ID09PSB0aGlzLl9yZXNpemVEYXRhLndpbmRvd0Nvb3JkaW5hdGVzLmN5KSByZXR1cm4gITE7Y2xlYXJUaW1lb3V0KHRoaXMuX3Jlc2l6ZURhdGEudGltZW91dElkKTtcXG4gICAgICAgIH1yZXR1cm4gdGhpcy5fcmVzaXplRGF0YSA9IHsgdGltZW91dElkOiB0aGlzLl9kZWxheShcXFwiX3Jlc2l6ZVRpbWVvdXRcXFwiLCAyMDApLCB3aW5kb3dDb29yZGluYXRlczogYSB9LCAhMDtcXG4gICAgICB9LCBfcmVzaXplVGltZW91dDogZnVuY3Rpb24gX3Jlc2l6ZVRpbWVvdXQoKSB7XFxuICAgICAgICB0aGlzLl9pc09wZW4gPyB0aGlzLl9leHBlY3RSZXNpemVFdmVudCgpIHx8ICh0aGlzLl91aS5jb250YWluZXIuaGFzQ2xhc3MoXFxcInVpLXBvcHVwLWhpZGRlblxcXCIpICYmICh0aGlzLl91aS5jb250YWluZXIucmVtb3ZlQ2xhc3MoXFxcInVpLXBvcHVwLWhpZGRlbiB1aS1wb3B1cC10cnVuY2F0ZVxcXCIpLCB0aGlzLnJlcG9zaXRpb24oeyBwb3NpdGlvblRvOiBcXFwid2luZG93XFxcIiB9KSwgdGhpcy5faWdub3JlUmVzaXplRXZlbnRzKCkpLCB0aGlzLl9yZXNpemVTY3JlZW4oKSwgdGhpcy5fcmVzaXplRGF0YSA9IG51bGwsIHRoaXMuX29yaWVudGF0aW9uY2hhbmdlSW5Qcm9ncmVzcyA9ICExKSA6ICh0aGlzLl9yZXNpemVEYXRhID0gbnVsbCwgdGhpcy5fb3JpZW50YXRpb25jaGFuZ2VJblByb2dyZXNzID0gITEpO1xcbiAgICAgIH0sIF9zdG9wSWdub3JpbmdSZXNpemVFdmVudHM6IGZ1bmN0aW9uIF9zdG9wSWdub3JpbmdSZXNpemVFdmVudHMoKSB7XFxuICAgICAgICB0aGlzLl9pZ25vcmVSZXNpemVUbyA9IDA7XFxuICAgICAgfSwgX2lnbm9yZVJlc2l6ZUV2ZW50czogZnVuY3Rpb24gX2lnbm9yZVJlc2l6ZUV2ZW50cygpIHtcXG4gICAgICAgIHRoaXMuX2lnbm9yZVJlc2l6ZVRvICYmIGNsZWFyVGltZW91dCh0aGlzLl9pZ25vcmVSZXNpemVUbyksIHRoaXMuX2lnbm9yZVJlc2l6ZVRvID0gdGhpcy5fZGVsYXkoXFxcIl9zdG9wSWdub3JpbmdSZXNpemVFdmVudHNcXFwiLCAxZTMpO1xcbiAgICAgIH0sIF9oYW5kbGVXaW5kb3dSZXNpemU6IGZ1bmN0aW9uIF9oYW5kbGVXaW5kb3dSZXNpemUoKSB7XFxuICAgICAgICB0aGlzLl9pc09wZW4gJiYgMCA9PT0gdGhpcy5faWdub3JlUmVzaXplVG8gJiYgKCF0aGlzLl9leHBlY3RSZXNpemVFdmVudCgpICYmICF0aGlzLl9vcmllbnRhdGlvbmNoYW5nZUluUHJvZ3Jlc3MgfHwgdGhpcy5fdWkuY29udGFpbmVyLmhhc0NsYXNzKFxcXCJ1aS1wb3B1cC1oaWRkZW5cXFwiKSB8fCB0aGlzLl91aS5jb250YWluZXIuYWRkQ2xhc3MoXFxcInVpLXBvcHVwLWhpZGRlbiB1aS1wb3B1cC10cnVuY2F0ZVxcXCIpLnJlbW92ZUF0dHIoXFxcInN0eWxlXFxcIikpO1xcbiAgICAgIH0sIF9oYW5kbGVXaW5kb3dPcmllbnRhdGlvbmNoYW5nZTogZnVuY3Rpb24gX2hhbmRsZVdpbmRvd09yaWVudGF0aW9uY2hhbmdlKCkge1xcbiAgICAgICAgIXRoaXMuX29yaWVudGF0aW9uY2hhbmdlSW5Qcm9ncmVzcyAmJiB0aGlzLl9pc09wZW4gJiYgMCA9PT0gdGhpcy5faWdub3JlUmVzaXplVG8gJiYgKHRoaXMuX2V4cGVjdFJlc2l6ZUV2ZW50KCksIHRoaXMuX29yaWVudGF0aW9uY2hhbmdlSW5Qcm9ncmVzcyA9ICEwKTtcXG4gICAgICB9LCBfaGFuZGxlRG9jdW1lbnRGb2N1c0luOiBmdW5jdGlvbiBfaGFuZGxlRG9jdW1lbnRGb2N1c0luKGIpIHtcXG4gICAgICAgIHZhciBjLFxcbiAgICAgICAgICAgIGQgPSBiLnRhcmdldCxcXG4gICAgICAgICAgICBlID0gdGhpcy5fdWk7aWYgKHRoaXMuX2lzT3Blbikge1xcbiAgICAgICAgICBpZiAoZCAhPT0gZS5jb250YWluZXJbMF0pIHtcXG4gICAgICAgICAgICBpZiAoYyA9IGEoZCksICFhLmNvbnRhaW5zKGUuY29udGFpbmVyWzBdLCBkKSkgcmV0dXJuIGEodGhpcy5kb2N1bWVudFswXS5hY3RpdmVFbGVtZW50KS5vbmUoXFxcImZvY3VzXFxcIiwgYS5wcm94eShmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICB0aGlzLl9zYWZlbHlCbHVyKGQpO1xcbiAgICAgICAgICAgIH0sIHRoaXMpKSwgZS5mb2N1c0VsZW1lbnQuZm9jdXMoKSwgYi5wcmV2ZW50RGVmYXVsdCgpLCBiLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpLCAhMTtlLmZvY3VzRWxlbWVudFswXSA9PT0gZS5jb250YWluZXJbMF0gJiYgKGUuZm9jdXNFbGVtZW50ID0gYyk7XFxuICAgICAgICAgIH10aGlzLl9pZ25vcmVSZXNpemVFdmVudHMoKTtcXG4gICAgICAgIH1cXG4gICAgICB9LCBfdGhlbWVDbGFzc0Zyb21PcHRpb246IGZ1bmN0aW9uIF90aGVtZUNsYXNzRnJvbU9wdGlvbihhLCBiKSB7XFxuICAgICAgICByZXR1cm4gYiA/IFxcXCJub25lXFxcIiA9PT0gYiA/IFxcXCJcXFwiIDogYSArIGIgOiBhICsgXFxcImluaGVyaXRcXFwiO1xcbiAgICAgIH0sIF9hcHBseVRyYW5zaXRpb246IGZ1bmN0aW9uIF9hcHBseVRyYW5zaXRpb24oYikge1xcbiAgICAgICAgcmV0dXJuIGIgJiYgKHRoaXMuX3VpLmNvbnRhaW5lci5yZW1vdmVDbGFzcyh0aGlzLl9mYWxsYmFja1RyYW5zaXRpb24pLCBcXFwibm9uZVxcXCIgIT09IGIgJiYgKHRoaXMuX2ZhbGxiYWNrVHJhbnNpdGlvbiA9IGEubW9iaWxlLl9tYXliZURlZ3JhZGVUcmFuc2l0aW9uKGIpLCBcXFwibm9uZVxcXCIgPT09IHRoaXMuX2ZhbGxiYWNrVHJhbnNpdGlvbiAmJiAodGhpcy5fZmFsbGJhY2tUcmFuc2l0aW9uID0gXFxcIlxcXCIpLCB0aGlzLl91aS5jb250YWluZXIuYWRkQ2xhc3ModGhpcy5fZmFsbGJhY2tUcmFuc2l0aW9uKSkpLCB0aGlzO1xcbiAgICAgIH0sIF9zZXRPcHRpb25zOiBmdW5jdGlvbiBfc2V0T3B0aW9ucyhhKSB7XFxuICAgICAgICB2YXIgYiA9IHRoaXMub3B0aW9ucyxcXG4gICAgICAgICAgICBkID0gdGhpcy5lbGVtZW50LFxcbiAgICAgICAgICAgIGUgPSB0aGlzLl91aS5zY3JlZW47cmV0dXJuIGEud3JhcHBlckNsYXNzICE9PSBjICYmIHRoaXMuX3VpLmNvbnRhaW5lci5yZW1vdmVDbGFzcyhiLndyYXBwZXJDbGFzcykuYWRkQ2xhc3MoYS53cmFwcGVyQ2xhc3MpLCBhLnRoZW1lICE9PSBjICYmIGQucmVtb3ZlQ2xhc3ModGhpcy5fdGhlbWVDbGFzc0Zyb21PcHRpb24oXFxcInVpLWJvZHktXFxcIiwgYi50aGVtZSkpLmFkZENsYXNzKHRoaXMuX3RoZW1lQ2xhc3NGcm9tT3B0aW9uKFxcXCJ1aS1ib2R5LVxcXCIsIGEudGhlbWUpKSwgYS5vdmVybGF5VGhlbWUgIT09IGMgJiYgKGUucmVtb3ZlQ2xhc3ModGhpcy5fdGhlbWVDbGFzc0Zyb21PcHRpb24oXFxcInVpLW92ZXJsYXktXFxcIiwgYi5vdmVybGF5VGhlbWUpKS5hZGRDbGFzcyh0aGlzLl90aGVtZUNsYXNzRnJvbU9wdGlvbihcXFwidWktb3ZlcmxheS1cXFwiLCBhLm92ZXJsYXlUaGVtZSkpLCB0aGlzLl9pc09wZW4gJiYgZS5hZGRDbGFzcyhcXFwiaW5cXFwiKSksIGEuc2hhZG93ICE9PSBjICYmIGQudG9nZ2xlQ2xhc3MoXFxcInVpLW92ZXJsYXktc2hhZG93XFxcIiwgYS5zaGFkb3cpLCBhLmNvcm5lcnMgIT09IGMgJiYgZC50b2dnbGVDbGFzcyhcXFwidWktY29ybmVyLWFsbFxcXCIsIGEuY29ybmVycyksIGEudHJhbnNpdGlvbiAhPT0gYyAmJiAodGhpcy5fY3VycmVudFRyYW5zaXRpb24gfHwgdGhpcy5fYXBwbHlUcmFuc2l0aW9uKGEudHJhbnNpdGlvbikpLCBhLnRvbGVyYW5jZSAhPT0gYyAmJiB0aGlzLl9zZXRUb2xlcmFuY2UoYS50b2xlcmFuY2UpLCBhLmRpc2FibGVkICE9PSBjICYmIGEuZGlzYWJsZWQgJiYgdGhpcy5jbG9zZSgpLCB0aGlzLl9zdXBlcihhKTtcXG4gICAgICB9LCBfc2V0VG9sZXJhbmNlOiBmdW5jdGlvbiBfc2V0VG9sZXJhbmNlKGIpIHtcXG4gICAgICAgIHZhciBkLFxcbiAgICAgICAgICAgIGUgPSB7IHQ6IDMwLCByOiAxNSwgYjogMzAsIGw6IDE1IH07aWYgKGIgIT09IGMpIHN3aXRjaCAoZCA9IFN0cmluZyhiKS5zcGxpdChcXFwiLFxcXCIpLCBhLmVhY2goZCwgZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgICAgICAgZFthXSA9IHBhcnNlSW50KGIsIDEwKTtcXG4gICAgICAgIH0pLCBkLmxlbmd0aCkge2Nhc2UgMTpcXG4gICAgICAgICAgICBpc05hTihkWzBdKSB8fCAoZS50ID0gZS5yID0gZS5iID0gZS5sID0gZFswXSk7YnJlYWs7Y2FzZSAyOlxcbiAgICAgICAgICAgIGlzTmFOKGRbMF0pIHx8IChlLnQgPSBlLmIgPSBkWzBdKSwgaXNOYU4oZFsxXSkgfHwgKGUubCA9IGUuciA9IGRbMV0pO2JyZWFrO2Nhc2UgNDpcXG4gICAgICAgICAgICBpc05hTihkWzBdKSB8fCAoZS50ID0gZFswXSksIGlzTmFOKGRbMV0pIHx8IChlLnIgPSBkWzFdKSwgaXNOYU4oZFsyXSkgfHwgKGUuYiA9IGRbMl0pLCBpc05hTihkWzNdKSB8fCAoZS5sID0gZFszXSk7fXJldHVybiB0aGlzLl90b2xlcmFuY2UgPSBlLCB0aGlzO1xcbiAgICAgIH0sIF9jbGFtcFBvcHVwV2lkdGg6IGZ1bmN0aW9uIF9jbGFtcFBvcHVwV2lkdGgoYSkge1xcbiAgICAgICAgdmFyIGIsXFxuICAgICAgICAgICAgYyA9IGUodGhpcy53aW5kb3cpLFxcbiAgICAgICAgICAgIGQgPSB7IHg6IHRoaXMuX3RvbGVyYW5jZS5sLCB5OiBjLnkgKyB0aGlzLl90b2xlcmFuY2UudCwgY3g6IGMuY3ggLSB0aGlzLl90b2xlcmFuY2UubCAtIHRoaXMuX3RvbGVyYW5jZS5yLCBjeTogYy5jeSAtIHRoaXMuX3RvbGVyYW5jZS50IC0gdGhpcy5fdG9sZXJhbmNlLmIgfTtyZXR1cm4gYSB8fCB0aGlzLl91aS5jb250YWluZXIuY3NzKFxcXCJtYXgtd2lkdGhcXFwiLCBkLmN4KSwgYiA9IHsgY3g6IHRoaXMuX3VpLmNvbnRhaW5lci5vdXRlcldpZHRoKCEwKSwgY3k6IHRoaXMuX3VpLmNvbnRhaW5lci5vdXRlckhlaWdodCghMCkgfSwgeyByYzogZCwgbWVudVNpemU6IGIgfTtcXG4gICAgICB9LCBfY2FsY3VsYXRlRmluYWxMb2NhdGlvbjogZnVuY3Rpb24gX2NhbGN1bGF0ZUZpbmFsTG9jYXRpb24oYSwgYikge1xcbiAgICAgICAgdmFyIGMsXFxuICAgICAgICAgICAgZSA9IGIucmMsXFxuICAgICAgICAgICAgZiA9IGIubWVudVNpemU7cmV0dXJuIGMgPSB7IGxlZnQ6IGQoZS5jeCwgZi5jeCwgZS54LCBhLngpLCB0b3A6IGQoZS5jeSwgZi5jeSwgZS55LCBhLnkpIH0sIGMudG9wID0gTWF0aC5tYXgoMCwgYy50b3ApLCBjLnRvcCAtPSBNYXRoLm1pbihjLnRvcCwgTWF0aC5tYXgoMCwgYy50b3AgKyBmLmN5IC0gdGhpcy5kb2N1bWVudC5oZWlnaHQoKSkpLCBjO1xcbiAgICAgIH0sIF9wbGFjZW1lbnRDb29yZHM6IGZ1bmN0aW9uIF9wbGFjZW1lbnRDb29yZHMoYSkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGN1bGF0ZUZpbmFsTG9jYXRpb24oYSwgdGhpcy5fY2xhbXBQb3B1cFdpZHRoKCkpO1xcbiAgICAgIH0sIF9jcmVhdGVQcmVyZXF1aXNpdGVzOiBmdW5jdGlvbiBfY3JlYXRlUHJlcmVxdWlzaXRlcyhiLCBjLCBkKSB7XFxuICAgICAgICB2YXIgZSxcXG4gICAgICAgICAgICBmID0gdGhpcztlID0geyBzY3JlZW46IGEuRGVmZXJyZWQoKSwgY29udGFpbmVyOiBhLkRlZmVycmVkKCkgfSwgZS5zY3JlZW4udGhlbihmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIGUgPT09IGYuX3ByZXJlcXVpc2l0ZXMgJiYgYigpO1xcbiAgICAgICAgfSksIGUuY29udGFpbmVyLnRoZW4oZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBlID09PSBmLl9wcmVyZXF1aXNpdGVzICYmIGMoKTtcXG4gICAgICAgIH0pLCBhLndoZW4oZS5zY3JlZW4sIGUuY29udGFpbmVyKS5kb25lKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgZSA9PT0gZi5fcHJlcmVxdWlzaXRlcyAmJiAoZi5fcHJlcmVxdWlzaXRlcyA9IG51bGwsIGQoKSk7XFxuICAgICAgICB9KSwgZi5fcHJlcmVxdWlzaXRlcyA9IGU7XFxuICAgICAgfSwgX2FuaW1hdGU6IGZ1bmN0aW9uIF9hbmltYXRlKGIpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLl91aS5zY3JlZW4ucmVtb3ZlQ2xhc3MoYi5jbGFzc1RvUmVtb3ZlKS5hZGRDbGFzcyhiLnNjcmVlbkNsYXNzVG9BZGQpLCBiLnByZXJlcXVpc2l0ZXMuc2NyZWVuLnJlc29sdmUoKSwgYi50cmFuc2l0aW9uICYmIFxcXCJub25lXFxcIiAhPT0gYi50cmFuc2l0aW9uICYmIChiLmFwcGx5VHJhbnNpdGlvbiAmJiB0aGlzLl9hcHBseVRyYW5zaXRpb24oYi50cmFuc2l0aW9uKSwgdGhpcy5fZmFsbGJhY2tUcmFuc2l0aW9uKSA/IHZvaWQgdGhpcy5fdWkuY29udGFpbmVyLmFkZENsYXNzKGIuY29udGFpbmVyQ2xhc3NUb0FkZCkucmVtb3ZlQ2xhc3MoYi5jbGFzc1RvUmVtb3ZlKS5hbmltYXRpb25Db21wbGV0ZShhLnByb3h5KGIucHJlcmVxdWlzaXRlcy5jb250YWluZXIsIFxcXCJyZXNvbHZlXFxcIikpIDogKHRoaXMuX3VpLmNvbnRhaW5lci5yZW1vdmVDbGFzcyhiLmNsYXNzVG9SZW1vdmUpLCB2b2lkIGIucHJlcmVxdWlzaXRlcy5jb250YWluZXIucmVzb2x2ZSgpKTtcXG4gICAgICB9LCBfZGVzaXJlZENvb3JkczogZnVuY3Rpb24gX2Rlc2lyZWRDb29yZHMoYikge1xcbiAgICAgICAgdmFyIGMsXFxuICAgICAgICAgICAgZCA9IG51bGwsXFxuICAgICAgICAgICAgZiA9IGUodGhpcy53aW5kb3cpLFxcbiAgICAgICAgICAgIGcgPSBiLngsXFxuICAgICAgICAgICAgaCA9IGIueSxcXG4gICAgICAgICAgICBpID0gYi5wb3NpdGlvblRvO2lmIChpICYmIFxcXCJvcmlnaW5cXFwiICE9PSBpKSBpZiAoXFxcIndpbmRvd1xcXCIgPT09IGkpIGcgPSBmLmN4IC8gMiArIGYueCwgaCA9IGYuY3kgLyAyICsgZi55O2Vsc2Uge1xcbiAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgIGQgPSBhKGkpO1xcbiAgICAgICAgICB9IGNhdGNoIChqKSB7XFxuICAgICAgICAgICAgZCA9IG51bGw7XFxuICAgICAgICAgIH1kICYmIChkLmZpbHRlcihcXFwiOnZpc2libGVcXFwiKSwgMCA9PT0gZC5sZW5ndGggJiYgKGQgPSBudWxsKSk7XFxuICAgICAgICB9cmV0dXJuIGQgJiYgKGMgPSBkLm9mZnNldCgpLCBnID0gYy5sZWZ0ICsgZC5vdXRlcldpZHRoKCkgLyAyLCBoID0gYy50b3AgKyBkLm91dGVySGVpZ2h0KCkgLyAyKSwgKFxcXCJudW1iZXJcXFwiICE9PSBhLnR5cGUoZykgfHwgaXNOYU4oZykpICYmIChnID0gZi5jeCAvIDIgKyBmLngpLCAoXFxcIm51bWJlclxcXCIgIT09IGEudHlwZShoKSB8fCBpc05hTihoKSkgJiYgKGggPSBmLmN5IC8gMiArIGYueSksIHsgeDogZywgeTogaCB9O1xcbiAgICAgIH0sIF9yZXBvc2l0aW9uOiBmdW5jdGlvbiBfcmVwb3NpdGlvbihhKSB7XFxuICAgICAgICBhID0geyB4OiBhLngsIHk6IGEueSwgcG9zaXRpb25UbzogYS5wb3NpdGlvblRvIH0sIHRoaXMuX3RyaWdnZXIoXFxcImJlZm9yZXBvc2l0aW9uXFxcIiwgYywgYSksIHRoaXMuX3VpLmNvbnRhaW5lci5vZmZzZXQodGhpcy5fcGxhY2VtZW50Q29vcmRzKHRoaXMuX2Rlc2lyZWRDb29yZHMoYSkpKTtcXG4gICAgICB9LCByZXBvc2l0aW9uOiBmdW5jdGlvbiByZXBvc2l0aW9uKGEpIHtcXG4gICAgICAgIHRoaXMuX2lzT3BlbiAmJiB0aGlzLl9yZXBvc2l0aW9uKGEpO1xcbiAgICAgIH0sIF9zYWZlbHlCbHVyOiBmdW5jdGlvbiBfc2FmZWx5Qmx1cihiKSB7XFxuICAgICAgICBiICE9PSB0aGlzLndpbmRvd1swXSAmJiBcXFwiYm9keVxcXCIgIT09IGIubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAmJiBhKGIpLmJsdXIoKTtcXG4gICAgICB9LCBfb3BlblByZXJlcXVpc2l0ZXNDb21wbGV0ZTogZnVuY3Rpb24gX29wZW5QcmVyZXF1aXNpdGVzQ29tcGxldGUoKSB7XFxuICAgICAgICB2YXIgYiA9IHRoaXMuZWxlbWVudC5hdHRyKFxcXCJpZFxcXCIpLFxcbiAgICAgICAgICAgIGMgPSB0aGlzLl91aS5jb250YWluZXIuZmluZChcXFwiOmZvY3VzYWJsZVxcXCIpLmZpcnN0KCk7dGhpcy5fdWkuY29udGFpbmVyLmFkZENsYXNzKFxcXCJ1aS1wb3B1cC1hY3RpdmVcXFwiKSwgdGhpcy5faXNPcGVuID0gITAsIHRoaXMuX3Jlc2l6ZVNjcmVlbigpLCBhLmNvbnRhaW5zKHRoaXMuX3VpLmNvbnRhaW5lclswXSwgdGhpcy5kb2N1bWVudFswXS5hY3RpdmVFbGVtZW50KSB8fCB0aGlzLl9zYWZlbHlCbHVyKHRoaXMuZG9jdW1lbnRbMF0uYWN0aXZlRWxlbWVudCksIGMubGVuZ3RoID4gMCAmJiAodGhpcy5fdWkuZm9jdXNFbGVtZW50ID0gYyksIHRoaXMuX2lnbm9yZVJlc2l6ZUV2ZW50cygpLCBiICYmIHRoaXMuZG9jdW1lbnQuZmluZChcXFwiW2FyaWEtaGFzcG9wdXA9J3RydWUnXVthcmlhLW93bnM9J1xcXCIgKyBiICsgXFxcIiddXFxcIikuYXR0cihcXFwiYXJpYS1leHBhbmRlZFxcXCIsICEwKSwgdGhpcy5fdHJpZ2dlcihcXFwiYWZ0ZXJvcGVuXFxcIik7XFxuICAgICAgfSwgX29wZW46IGZ1bmN0aW9uIF9vcGVuKGIpIHtcXG4gICAgICAgIHZhciBjID0gYS5leHRlbmQoe30sIHRoaXMub3B0aW9ucywgYiksXFxuICAgICAgICAgICAgZCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgdmFyIGEgPSBuYXZpZ2F0b3IudXNlckFnZW50LFxcbiAgICAgICAgICAgICAgYiA9IGEubWF0Y2goL0FwcGxlV2ViS2l0XFxcXC8oWzAtOVxcXFwuXSspLyksXFxuICAgICAgICAgICAgICBjID0gISFiICYmIGJbMV0sXFxuICAgICAgICAgICAgICBkID0gYS5tYXRjaCgvQW5kcm9pZCAoXFxcXGQrKD86XFxcXC5cXFxcZCspKS8pLFxcbiAgICAgICAgICAgICAgZSA9ICEhZCAmJiBkWzFdLFxcbiAgICAgICAgICAgICAgZiA9IGEuaW5kZXhPZihcXFwiQ2hyb21lXFxcIikgPiAtMTtyZXR1cm4gbnVsbCAhPT0gZCAmJiBcXFwiNC4wXFxcIiA9PT0gZSAmJiBjICYmIGMgPiA1MzQuMTMgJiYgIWYgPyAhMCA6ICExO1xcbiAgICAgICAgfSgpO3RoaXMuX2NyZWF0ZVByZXJlcXVpc2l0ZXMoYS5ub29wLCBhLm5vb3AsIGEucHJveHkodGhpcywgXFxcIl9vcGVuUHJlcmVxdWlzaXRlc0NvbXBsZXRlXFxcIikpLCB0aGlzLl9jdXJyZW50VHJhbnNpdGlvbiA9IGMudHJhbnNpdGlvbiwgdGhpcy5fYXBwbHlUcmFuc2l0aW9uKGMudHJhbnNpdGlvbiksIHRoaXMuX3VpLnNjcmVlbi5yZW1vdmVDbGFzcyhcXFwidWktc2NyZWVuLWhpZGRlblxcXCIpLCB0aGlzLl91aS5jb250YWluZXIucmVtb3ZlQ2xhc3MoXFxcInVpLXBvcHVwLXRydW5jYXRlXFxcIiksIHRoaXMuX3JlcG9zaXRpb24oYyksIHRoaXMuX3VpLmNvbnRhaW5lci5yZW1vdmVDbGFzcyhcXFwidWktcG9wdXAtaGlkZGVuXFxcIiksIHRoaXMub3B0aW9ucy5vdmVybGF5VGhlbWUgJiYgZCAmJiB0aGlzLmVsZW1lbnQuY2xvc2VzdChcXFwiLnVpLXBhZ2VcXFwiKS5hZGRDbGFzcyhcXFwidWktcG9wdXAtb3BlblxcXCIpLCB0aGlzLl9hbmltYXRlKHsgYWRkaXRpb25hbENvbmRpdGlvbjogITAsIHRyYW5zaXRpb246IGMudHJhbnNpdGlvbiwgY2xhc3NUb1JlbW92ZTogXFxcIlxcXCIsIHNjcmVlbkNsYXNzVG9BZGQ6IFxcXCJpblxcXCIsIGNvbnRhaW5lckNsYXNzVG9BZGQ6IFxcXCJpblxcXCIsIGFwcGx5VHJhbnNpdGlvbjogITEsIHByZXJlcXVpc2l0ZXM6IHRoaXMuX3ByZXJlcXVpc2l0ZXMgfSk7XFxuICAgICAgfSwgX2Nsb3NlUHJlcmVxdWlzaXRlU2NyZWVuOiBmdW5jdGlvbiBfY2xvc2VQcmVyZXF1aXNpdGVTY3JlZW4oKSB7XFxuICAgICAgICB0aGlzLl91aS5zY3JlZW4ucmVtb3ZlQ2xhc3MoXFxcIm91dFxcXCIpLmFkZENsYXNzKFxcXCJ1aS1zY3JlZW4taGlkZGVuXFxcIik7XFxuICAgICAgfSwgX2Nsb3NlUHJlcmVxdWlzaXRlQ29udGFpbmVyOiBmdW5jdGlvbiBfY2xvc2VQcmVyZXF1aXNpdGVDb250YWluZXIoKSB7XFxuICAgICAgICB0aGlzLl91aS5jb250YWluZXIucmVtb3ZlQ2xhc3MoXFxcInJldmVyc2Ugb3V0XFxcIikuYWRkQ2xhc3MoXFxcInVpLXBvcHVwLWhpZGRlbiB1aS1wb3B1cC10cnVuY2F0ZVxcXCIpLnJlbW92ZUF0dHIoXFxcInN0eWxlXFxcIik7XFxuICAgICAgfSwgX2Nsb3NlUHJlcmVxdWlzaXRlc0RvbmU6IGZ1bmN0aW9uIF9jbG9zZVByZXJlcXVpc2l0ZXNEb25lKCkge1xcbiAgICAgICAgdmFyIGIgPSB0aGlzLl91aS5jb250YWluZXIsXFxuICAgICAgICAgICAgZCA9IHRoaXMuZWxlbWVudC5hdHRyKFxcXCJpZFxcXCIpO2EubW9iaWxlLnBvcHVwLmFjdGl2ZSA9IGMsIGEoXFxcIjpmb2N1c1xcXCIsIGJbMF0pLmFkZChiWzBdKS5ibHVyKCksIGQgJiYgdGhpcy5kb2N1bWVudC5maW5kKFxcXCJbYXJpYS1oYXNwb3B1cD0ndHJ1ZSddW2FyaWEtb3ducz0nXFxcIiArIGQgKyBcXFwiJ11cXFwiKS5hdHRyKFxcXCJhcmlhLWV4cGFuZGVkXFxcIiwgITEpLCB0aGlzLl90cmlnZ2VyKFxcXCJhZnRlcmNsb3NlXFxcIik7XFxuICAgICAgfSwgX2Nsb3NlOiBmdW5jdGlvbiBfY2xvc2UoYikge1xcbiAgICAgICAgdGhpcy5fdWkuY29udGFpbmVyLnJlbW92ZUNsYXNzKFxcXCJ1aS1wb3B1cC1hY3RpdmVcXFwiKSwgdGhpcy5fcGFnZS5yZW1vdmVDbGFzcyhcXFwidWktcG9wdXAtb3BlblxcXCIpLCB0aGlzLl9pc09wZW4gPSAhMSwgdGhpcy5fY3JlYXRlUHJlcmVxdWlzaXRlcyhhLnByb3h5KHRoaXMsIFxcXCJfY2xvc2VQcmVyZXF1aXNpdGVTY3JlZW5cXFwiKSwgYS5wcm94eSh0aGlzLCBcXFwiX2Nsb3NlUHJlcmVxdWlzaXRlQ29udGFpbmVyXFxcIiksIGEucHJveHkodGhpcywgXFxcIl9jbG9zZVByZXJlcXVpc2l0ZXNEb25lXFxcIikpLCB0aGlzLl9hbmltYXRlKHsgYWRkaXRpb25hbENvbmRpdGlvbjogdGhpcy5fdWkuc2NyZWVuLmhhc0NsYXNzKFxcXCJpblxcXCIpLCB0cmFuc2l0aW9uOiBiID8gXFxcIm5vbmVcXFwiIDogdGhpcy5fY3VycmVudFRyYW5zaXRpb24sIGNsYXNzVG9SZW1vdmU6IFxcXCJpblxcXCIsIHNjcmVlbkNsYXNzVG9BZGQ6IFxcXCJvdXRcXFwiLCBjb250YWluZXJDbGFzc1RvQWRkOiBcXFwicmV2ZXJzZSBvdXRcXFwiLCBhcHBseVRyYW5zaXRpb246ICEwLCBwcmVyZXF1aXNpdGVzOiB0aGlzLl9wcmVyZXF1aXNpdGVzIH0pO1xcbiAgICAgIH0sIF91bmVuaGFuY2U6IGZ1bmN0aW9uIF91bmVuaGFuY2UoKSB7XFxuICAgICAgICB0aGlzLm9wdGlvbnMuZW5oYW5jZWQgfHwgKHRoaXMuX3NldE9wdGlvbnMoeyB0aGVtZTogYS5tb2JpbGUucG9wdXAucHJvdG90eXBlLm9wdGlvbnMudGhlbWUgfSksIHRoaXMuZWxlbWVudC5kZXRhY2goKS5pbnNlcnRBZnRlcih0aGlzLl91aS5wbGFjZWhvbGRlcikucmVtb3ZlQ2xhc3MoXFxcInVpLXBvcHVwIHVpLW92ZXJsYXktc2hhZG93IHVpLWNvcm5lci1hbGwgdWktYm9keS1pbmhlcml0XFxcIiksIHRoaXMuX3VpLnNjcmVlbi5yZW1vdmUoKSwgdGhpcy5fdWkuY29udGFpbmVyLnJlbW92ZSgpLCB0aGlzLl91aS5wbGFjZWhvbGRlci5yZW1vdmUoKSk7XFxuICAgICAgfSwgX2Rlc3Ryb3k6IGZ1bmN0aW9uIF9kZXN0cm95KCkge1xcbiAgICAgICAgcmV0dXJuIGEubW9iaWxlLnBvcHVwLmFjdGl2ZSA9PT0gdGhpcyA/ICh0aGlzLmVsZW1lbnQub25lKFxcXCJwb3B1cGFmdGVyY2xvc2VcXFwiLCBhLnByb3h5KHRoaXMsIFxcXCJfdW5lbmhhbmNlXFxcIikpLCB0aGlzLmNsb3NlKCkpIDogdGhpcy5fdW5lbmhhbmNlKCksIHRoaXM7XFxuICAgICAgfSwgX2Nsb3NlUG9wdXA6IGZ1bmN0aW9uIF9jbG9zZVBvcHVwKGMsIGQpIHtcXG4gICAgICAgIHZhciBlLFxcbiAgICAgICAgICAgIGYsXFxuICAgICAgICAgICAgZyA9IHRoaXMub3B0aW9ucyxcXG4gICAgICAgICAgICBoID0gITE7YyAmJiBjLmlzRGVmYXVsdFByZXZlbnRlZCgpIHx8IGEubW9iaWxlLnBvcHVwLmFjdGl2ZSAhPT0gdGhpcyB8fCAoYi5zY3JvbGxUbygwLCB0aGlzLl9zY3JvbGxUb3ApLCBjICYmIFxcXCJwYWdlYmVmb3JlY2hhbmdlXFxcIiA9PT0gYy50eXBlICYmIGQgJiYgKGUgPSBcXFwic3RyaW5nXFxcIiA9PSB0eXBlb2YgZC50b1BhZ2UgPyBkLnRvUGFnZSA6IGQudG9QYWdlLmpxbURhdGEoXFxcInVybFxcXCIpLCBlID0gYS5tb2JpbGUucGF0aC5wYXJzZVVybChlKSwgZiA9IGUucGF0aG5hbWUgKyBlLnNlYXJjaCArIGUuaGFzaCwgdGhpcy5fbXlVcmwgIT09IGEubW9iaWxlLnBhdGgubWFrZVVybEFic29sdXRlKGYpID8gaCA9ICEwIDogYy5wcmV2ZW50RGVmYXVsdCgpKSwgdGhpcy53aW5kb3cub2ZmKGcuY2xvc2VFdmVudHMpLCB0aGlzLmVsZW1lbnQudW5kZWxlZ2F0ZShnLmNsb3NlTGlua1NlbGVjdG9yLCBnLmNsb3NlTGlua0V2ZW50cyksIHRoaXMuX2Nsb3NlKGgpKTtcXG4gICAgICB9LCBfYmluZENvbnRhaW5lckNsb3NlOiBmdW5jdGlvbiBfYmluZENvbnRhaW5lckNsb3NlKCkge1xcbiAgICAgICAgdGhpcy53aW5kb3cub24odGhpcy5vcHRpb25zLmNsb3NlRXZlbnRzLCBhLnByb3h5KHRoaXMsIFxcXCJfY2xvc2VQb3B1cFxcXCIpKTtcXG4gICAgICB9LCB3aWRnZXQ6IGZ1bmN0aW9uIHdpZGdldCgpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLl91aS5jb250YWluZXI7XFxuICAgICAgfSwgb3BlbjogZnVuY3Rpb24gb3BlbihiKSB7XFxuICAgICAgICB2YXIgYyxcXG4gICAgICAgICAgICBkLFxcbiAgICAgICAgICAgIGUsXFxuICAgICAgICAgICAgZixcXG4gICAgICAgICAgICBnLFxcbiAgICAgICAgICAgIGgsXFxuICAgICAgICAgICAgaSA9IHRoaXMsXFxuICAgICAgICAgICAgaiA9IHRoaXMub3B0aW9ucztyZXR1cm4gYS5tb2JpbGUucG9wdXAuYWN0aXZlIHx8IGouZGlzYWJsZWQgPyB0aGlzIDogKGEubW9iaWxlLnBvcHVwLmFjdGl2ZSA9IHRoaXMsIHRoaXMuX3Njcm9sbFRvcCA9IHRoaXMud2luZG93LnNjcm9sbFRvcCgpLCBqLmhpc3RvcnkgPyAoaCA9IGEubW9iaWxlLm5hdmlnYXRlLmhpc3RvcnksIGQgPSBhLm1vYmlsZS5kaWFsb2dIYXNoS2V5LCBlID0gYS5tb2JpbGUuYWN0aXZlUGFnZSwgZiA9IGUgPyBlLmhhc0NsYXNzKFxcXCJ1aS1kaWFsb2dcXFwiKSA6ICExLCB0aGlzLl9teVVybCA9IGMgPSBoLmdldEFjdGl2ZSgpLnVybCwgKGcgPSBjLmluZGV4T2YoZCkgPiAtMSAmJiAhZiAmJiBoLmFjdGl2ZUluZGV4ID4gMCkgPyAoaS5fb3BlbihiKSwgaS5fYmluZENvbnRhaW5lckNsb3NlKCksIHRoaXMpIDogKC0xICE9PSBjLmluZGV4T2YoZCkgfHwgZiA/IGMgPSBhLm1vYmlsZS5wYXRoLnBhcnNlTG9jYXRpb24oKS5oYXNoICsgZCA6IGMgKz0gYy5pbmRleE9mKFxcXCIjXFxcIikgPiAtMSA/IGQgOiBcXFwiI1xcXCIgKyBkLCB0aGlzLndpbmRvdy5vbmUoXFxcImJlZm9yZW5hdmlnYXRlXFxcIiwgZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgICAgYS5wcmV2ZW50RGVmYXVsdCgpLCBpLl9vcGVuKGIpLCBpLl9iaW5kQ29udGFpbmVyQ2xvc2UoKTtcXG4gICAgICAgIH0pLCB0aGlzLnVybEFsdGVyZWQgPSAhMCwgYS5tb2JpbGUubmF2aWdhdGUoYywgeyByb2xlOiBcXFwiZGlhbG9nXFxcIiB9KSwgdGhpcykpIDogKGkuX29wZW4oYiksIGkuX2JpbmRDb250YWluZXJDbG9zZSgpLCBpLmVsZW1lbnQuZGVsZWdhdGUoai5jbG9zZUxpbmtTZWxlY3Rvciwgai5jbG9zZUxpbmtFdmVudHMsIGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICAgIGkuY2xvc2UoKSwgYS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgfSksIHRoaXMpKTtcXG4gICAgICB9LCBjbG9zZTogZnVuY3Rpb24gY2xvc2UoKSB7XFxuICAgICAgICByZXR1cm4gYS5tb2JpbGUucG9wdXAuYWN0aXZlICE9PSB0aGlzID8gdGhpcyA6ICh0aGlzLl9zY3JvbGxUb3AgPSB0aGlzLndpbmRvdy5zY3JvbGxUb3AoKSwgdGhpcy5vcHRpb25zLmhpc3RvcnkgJiYgdGhpcy51cmxBbHRlcmVkID8gKGEubW9iaWxlLmJhY2soKSwgdGhpcy51cmxBbHRlcmVkID0gITEpIDogdGhpcy5fY2xvc2VQb3B1cCgpLCB0aGlzKTtcXG4gICAgICB9IH0pLCBhLm1vYmlsZS5wb3B1cC5oYW5kbGVMaW5rID0gZnVuY3Rpb24gKGIpIHtcXG4gICAgICB2YXIgYyxcXG4gICAgICAgICAgZCA9IGEubW9iaWxlLnBhdGgsXFxuICAgICAgICAgIGUgPSBhKGQuaGFzaFRvU2VsZWN0b3IoZC5wYXJzZVVybChiLmF0dHIoXFxcImhyZWZcXFwiKSkuaGFzaCkpLmZpcnN0KCk7ZS5sZW5ndGggPiAwICYmIGUuZGF0YShcXFwibW9iaWxlLXBvcHVwXFxcIikgJiYgKGMgPSBiLm9mZnNldCgpLCBlLnBvcHVwKFxcXCJvcGVuXFxcIiwgeyB4OiBjLmxlZnQgKyBiLm91dGVyV2lkdGgoKSAvIDIsIHk6IGMudG9wICsgYi5vdXRlckhlaWdodCgpIC8gMiwgdHJhbnNpdGlvbjogYi5qcW1EYXRhKFxcXCJ0cmFuc2l0aW9uXFxcIiksIHBvc2l0aW9uVG86IGIuanFtRGF0YShcXFwicG9zaXRpb24tdG9cXFwiKSB9KSksIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgYi5yZW1vdmVDbGFzcyhhLm1vYmlsZS5hY3RpdmVCdG5DbGFzcyk7XFxuICAgICAgfSwgMzAwKTtcXG4gICAgfSwgYS5tb2JpbGUuZG9jdW1lbnQub24oXFxcInBhZ2ViZWZvcmVjaGFuZ2VcXFwiLCBmdW5jdGlvbiAoYiwgYykge1xcbiAgICAgIFxcXCJwb3B1cFxcXCIgPT09IGMub3B0aW9ucy5yb2xlICYmIChhLm1vYmlsZS5wb3B1cC5oYW5kbGVMaW5rKGMub3B0aW9ucy5saW5rKSwgYi5wcmV2ZW50RGVmYXVsdCgpKTtcXG4gICAgfSk7XFxuICB9KGEpLCBmdW5jdGlvbiAoYSwgYikge1xcbiAgICB2YXIgZCA9IFxcXCIudWktZGlzYWJsZWQsLnVpLXN0YXRlLWRpc2FibGVkLC51aS1saS1kaXZpZGVyLC51aS1zY3JlZW4taGlkZGVuLDpqcW1EYXRhKHJvbGU9J3BsYWNlaG9sZGVyJylcXFwiLFxcbiAgICAgICAgZSA9IGZ1bmN0aW9uIGUoYSwgYiwgYykge1xcbiAgICAgIHZhciBlID0gYVtjICsgXFxcIkFsbFxcXCJdKCkubm90KGQpLmZpcnN0KCk7ZS5sZW5ndGggJiYgKGIuYmx1cigpLmF0dHIoXFxcInRhYmluZGV4XFxcIiwgXFxcIi0xXFxcIiksIGUuZmluZChcXFwiYVxcXCIpLmZpcnN0KCkuZm9jdXMoKSk7XFxuICAgIH07YS53aWRnZXQoXFxcIm1vYmlsZS5zZWxlY3RtZW51XFxcIiwgYS5tb2JpbGUuc2VsZWN0bWVudSwgeyBfY3JlYXRlOiBmdW5jdGlvbiBfY3JlYXRlKCkge1xcbiAgICAgICAgdmFyIGEgPSB0aGlzLm9wdGlvbnM7cmV0dXJuIGEubmF0aXZlTWVudSA9IGEubmF0aXZlTWVudSB8fCB0aGlzLmVsZW1lbnQucGFyZW50cyhcXFwiOmpxbURhdGEocm9sZT0ncG9wdXAnKSw6bW9iaWxlLXBvcHVwXFxcIikubGVuZ3RoID4gMCwgdGhpcy5fc3VwZXIoKTtcXG4gICAgICB9LCBfaGFuZGxlU2VsZWN0Rm9jdXM6IGZ1bmN0aW9uIF9oYW5kbGVTZWxlY3RGb2N1cygpIHtcXG4gICAgICAgIHRoaXMuZWxlbWVudC5ibHVyKCksIHRoaXMuYnV0dG9uLmZvY3VzKCk7XFxuICAgICAgfSwgX2hhbmRsZUtleWRvd246IGZ1bmN0aW9uIF9oYW5kbGVLZXlkb3duKGEpIHtcXG4gICAgICAgIHRoaXMuX3N1cGVyKGEpLCB0aGlzLl9oYW5kbGVCdXR0b25WY2xpY2tLZXlkb3duKGEpO1xcbiAgICAgIH0sIF9oYW5kbGVCdXR0b25WY2xpY2tLZXlkb3duOiBmdW5jdGlvbiBfaGFuZGxlQnV0dG9uVmNsaWNrS2V5ZG93bihiKSB7XFxuICAgICAgICB0aGlzLm9wdGlvbnMuZGlzYWJsZWQgfHwgdGhpcy5pc09wZW4gfHwgdGhpcy5vcHRpb25zLm5hdGl2ZU1lbnUgfHwgKFxcXCJ2Y2xpY2tcXFwiID09PSBiLnR5cGUgfHwgYi5rZXlDb2RlICYmIChiLmtleUNvZGUgPT09IGEubW9iaWxlLmtleUNvZGUuRU5URVIgfHwgYi5rZXlDb2RlID09PSBhLm1vYmlsZS5rZXlDb2RlLlNQQUNFKSkgJiYgKHRoaXMuX2RlY2lkZUZvcm1hdCgpLCBcXFwib3ZlcmxheVxcXCIgPT09IHRoaXMubWVudVR5cGUgPyB0aGlzLmJ1dHRvbi5hdHRyKFxcXCJocmVmXFxcIiwgXFxcIiNcXFwiICsgdGhpcy5wb3B1cElkKS5hdHRyKFxcXCJkYXRhLVxcXCIgKyAoYS5tb2JpbGUubnMgfHwgXFxcIlxcXCIpICsgXFxcInJlbFxcXCIsIFxcXCJwb3B1cFxcXCIpIDogdGhpcy5idXR0b24uYXR0cihcXFwiaHJlZlxcXCIsIFxcXCIjXFxcIiArIHRoaXMuZGlhbG9nSWQpLmF0dHIoXFxcImRhdGEtXFxcIiArIChhLm1vYmlsZS5ucyB8fCBcXFwiXFxcIikgKyBcXFwicmVsXFxcIiwgXFxcImRpYWxvZ1xcXCIpLCB0aGlzLmlzT3BlbiA9ICEwKTtcXG4gICAgICB9LCBfaGFuZGxlTGlzdEZvY3VzOiBmdW5jdGlvbiBfaGFuZGxlTGlzdEZvY3VzKGIpIHtcXG4gICAgICAgIHZhciBjID0gXFxcImZvY3VzaW5cXFwiID09PSBiLnR5cGUgPyB7IHRhYmluZGV4OiBcXFwiMFxcXCIsIGV2ZW50OiBcXFwidm1vdXNlb3ZlclxcXCIgfSA6IHsgdGFiaW5kZXg6IFxcXCItMVxcXCIsIGV2ZW50OiBcXFwidm1vdXNlb3V0XFxcIiB9O2EoYi50YXJnZXQpLmF0dHIoXFxcInRhYmluZGV4XFxcIiwgYy50YWJpbmRleCkudHJpZ2dlcihjLmV2ZW50KTtcXG4gICAgICB9LCBfaGFuZGxlTGlzdEtleWRvd246IGZ1bmN0aW9uIF9oYW5kbGVMaXN0S2V5ZG93bihiKSB7XFxuICAgICAgICB2YXIgYyA9IGEoYi50YXJnZXQpLFxcbiAgICAgICAgICAgIGQgPSBjLmNsb3Nlc3QoXFxcImxpXFxcIik7c3dpdGNoIChiLmtleUNvZGUpIHtjYXNlIDM4OlxcbiAgICAgICAgICAgIHJldHVybiBlKGQsIGMsIFxcXCJwcmV2XFxcIiksICExO2Nhc2UgNDA6XFxuICAgICAgICAgICAgcmV0dXJuIGUoZCwgYywgXFxcIm5leHRcXFwiKSwgITE7Y2FzZSAxMzpjYXNlIDMyOlxcbiAgICAgICAgICAgIHJldHVybiBjLnRyaWdnZXIoXFxcImNsaWNrXFxcIiksICExO31cXG4gICAgICB9LCBfaGFuZGxlTWVudVBhZ2VIaWRlOiBmdW5jdGlvbiBfaGFuZGxlTWVudVBhZ2VIaWRlKCkge1xcbiAgICAgICAgdGhpcy5fZGVsYXllZFRyaWdnZXIoKSwgdGhpcy50aGlzUGFnZS5wYWdlKFxcXCJiaW5kUmVtb3ZlXFxcIik7XFxuICAgICAgfSwgX2hhbmRsZUhlYWRlckNsb3NlQ2xpY2s6IGZ1bmN0aW9uIF9oYW5kbGVIZWFkZXJDbG9zZUNsaWNrKCkge1xcbiAgICAgICAgcmV0dXJuIFxcXCJvdmVybGF5XFxcIiA9PT0gdGhpcy5tZW51VHlwZSA/ICh0aGlzLmNsb3NlKCksICExKSA6IHZvaWQgMDtcXG4gICAgICB9LCBfaGFuZGxlTGlzdEl0ZW1DbGljazogZnVuY3Rpb24gX2hhbmRsZUxpc3RJdGVtQ2xpY2soYikge1xcbiAgICAgICAgdmFyIGMgPSBhKGIudGFyZ2V0KS5jbG9zZXN0KFxcXCJsaVxcXCIpLFxcbiAgICAgICAgICAgIGQgPSB0aGlzLnNlbGVjdFswXS5zZWxlY3RlZEluZGV4LFxcbiAgICAgICAgICAgIGUgPSBhLm1vYmlsZS5nZXRBdHRyaWJ1dGUoYywgXFxcIm9wdGlvbi1pbmRleFxcXCIpLFxcbiAgICAgICAgICAgIGYgPSB0aGlzLl9zZWxlY3RPcHRpb25zKCkuZXEoZSlbMF07Zi5zZWxlY3RlZCA9IHRoaXMuaXNNdWx0aXBsZSA/ICFmLnNlbGVjdGVkIDogITAsIHRoaXMuaXNNdWx0aXBsZSAmJiBjLmZpbmQoXFxcImFcXFwiKS50b2dnbGVDbGFzcyhcXFwidWktY2hlY2tib3gtb25cXFwiLCBmLnNlbGVjdGVkKS50b2dnbGVDbGFzcyhcXFwidWktY2hlY2tib3gtb2ZmXFxcIiwgIWYuc2VsZWN0ZWQpLCB0aGlzLmlzTXVsdGlwbGUgfHwgZCA9PT0gZSB8fCAodGhpcy5fdHJpZ2dlckNoYW5nZSA9ICEwKSwgdGhpcy5pc011bHRpcGxlID8gKHRoaXMuc2VsZWN0LnRyaWdnZXIoXFxcImNoYW5nZVxcXCIpLCB0aGlzLmxpc3QuZmluZChcXFwibGk6bm90KC51aS1saS1kaXZpZGVyKVxcXCIpLmVxKGUpLmZpbmQoXFxcImFcXFwiKS5maXJzdCgpLmZvY3VzKCkpIDogdGhpcy5jbG9zZSgpLCBiLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgfSwgYnVpbGQ6IGZ1bmN0aW9uIGJ1aWxkKCkge1xcbiAgICAgICAgdmFyIGMsXFxuICAgICAgICAgICAgZCxcXG4gICAgICAgICAgICBlLFxcbiAgICAgICAgICAgIGYsXFxuICAgICAgICAgICAgZyxcXG4gICAgICAgICAgICBoLFxcbiAgICAgICAgICAgIGksXFxuICAgICAgICAgICAgaixcXG4gICAgICAgICAgICBrLFxcbiAgICAgICAgICAgIGwsXFxuICAgICAgICAgICAgbSxcXG4gICAgICAgICAgICBuLFxcbiAgICAgICAgICAgIG8sXFxuICAgICAgICAgICAgcCxcXG4gICAgICAgICAgICBxLFxcbiAgICAgICAgICAgIHIsXFxuICAgICAgICAgICAgcyxcXG4gICAgICAgICAgICB0LFxcbiAgICAgICAgICAgIHUsXFxuICAgICAgICAgICAgdiA9IHRoaXMub3B0aW9ucztyZXR1cm4gdi5uYXRpdmVNZW51ID8gdGhpcy5fc3VwZXIoKSA6IChjID0gdGhpcy5zZWxlY3RJZCwgZCA9IGMgKyBcXFwiLWxpc3Rib3hcXFwiLCBlID0gYyArIFxcXCItZGlhbG9nXFxcIiwgZiA9IHRoaXMubGFiZWwsIGcgPSB0aGlzLmVsZW1lbnQuY2xvc2VzdChcXFwiLnVpLXBhZ2VcXFwiKSwgaCA9IHRoaXMuZWxlbWVudFswXS5tdWx0aXBsZSwgaSA9IGMgKyBcXFwiLW1lbnVcXFwiLCBqID0gdi50aGVtZSA/IFxcXCIgZGF0YS1cXFwiICsgYS5tb2JpbGUubnMgKyBcXFwidGhlbWU9J1xcXCIgKyB2LnRoZW1lICsgXFxcIidcXFwiIDogXFxcIlxcXCIsIGsgPSB2Lm92ZXJsYXlUaGVtZSB8fCB2LnRoZW1lIHx8IG51bGwsIGwgPSBrID8gXFxcIiBkYXRhLVxcXCIgKyBhLm1vYmlsZS5ucyArIFxcXCJvdmVybGF5LXRoZW1lPSdcXFwiICsgayArIFxcXCInXFxcIiA6IFxcXCJcXFwiLCBtID0gdi5kaXZpZGVyVGhlbWUgJiYgaCA/IFxcXCIgZGF0YS1cXFwiICsgYS5tb2JpbGUubnMgKyBcXFwiZGl2aWRlci10aGVtZT0nXFxcIiArIHYuZGl2aWRlclRoZW1lICsgXFxcIidcXFwiIDogXFxcIlxcXCIsIG4gPSBhKFxcXCI8ZGl2IGRhdGEtXFxcIiArIGEubW9iaWxlLm5zICsgXFxcInJvbGU9J2RpYWxvZycgY2xhc3M9J3VpLXNlbGVjdG1lbnUnIGlkPSdcXFwiICsgZSArIFxcXCInXFxcIiArIGogKyBsICsgXFxcIj48ZGl2IGRhdGEtXFxcIiArIGEubW9iaWxlLm5zICsgXFxcInJvbGU9J2hlYWRlcic+PGRpdiBjbGFzcz0ndWktdGl0bGUnPjwvZGl2PjwvZGl2PjxkaXYgZGF0YS1cXFwiICsgYS5tb2JpbGUubnMgKyBcXFwicm9sZT0nY29udGVudCc+PC9kaXY+PC9kaXY+XFxcIiksIG8gPSBhKFxcXCI8ZGl2XFxcIiArIGogKyBsICsgXFxcIiBpZD0nXFxcIiArIGQgKyBcXFwiJyBjbGFzcz0ndWktc2VsZWN0bWVudSc+PC9kaXY+XFxcIikuaW5zZXJ0QWZ0ZXIodGhpcy5zZWxlY3QpLnBvcHVwKCksIHAgPSBhKFxcXCI8dWwgY2xhc3M9J3VpLXNlbGVjdG1lbnUtbGlzdCcgaWQ9J1xcXCIgKyBpICsgXFxcIicgcm9sZT0nbGlzdGJveCcgYXJpYS1sYWJlbGxlZGJ5PSdcXFwiICsgdGhpcy5idXR0b25JZCArIFxcXCInXFxcIiArIGogKyBtICsgXFxcIj48L3VsPlxcXCIpLmFwcGVuZFRvKG8pLCBxID0gYShcXFwiPGRpdiBjbGFzcz0ndWktaGVhZGVyIHVpLWJhci1cXFwiICsgKHYudGhlbWUgPyB2LnRoZW1lIDogXFxcImluaGVyaXRcXFwiKSArIFxcXCInPjwvZGl2PlxcXCIpLnByZXBlbmRUbyhvKSwgciA9IGEoXFxcIjxoMSBjbGFzcz0ndWktdGl0bGUnPjwvaDE+XFxcIikuYXBwZW5kVG8ocSksIHRoaXMuaXNNdWx0aXBsZSAmJiAodSA9IGEoXFxcIjxhPlxcXCIsIHsgcm9sZTogXFxcImJ1dHRvblxcXCIsIHRleHQ6IHYuY2xvc2VUZXh0LCBocmVmOiBcXFwiI1xcXCIsIFxcXCJjbGFzc1xcXCI6IFxcXCJ1aS1idG4gdWktY29ybmVyLWFsbCB1aS1idG4tbGVmdCB1aS1idG4taWNvbi1ub3RleHQgdWktaWNvbi1kZWxldGVcXFwiIH0pLmFwcGVuZFRvKHEpKSwgYS5leHRlbmQodGhpcywgeyBzZWxlY3RJZDogYywgbWVudUlkOiBpLCBwb3B1cElkOiBkLCBkaWFsb2dJZDogZSwgdGhpc1BhZ2U6IGcsIG1lbnVQYWdlOiBuLCBsYWJlbDogZiwgaXNNdWx0aXBsZTogaCwgdGhlbWU6IHYudGhlbWUsIGxpc3Rib3g6IG8sIGxpc3Q6IHAsIGhlYWRlcjogcSwgaGVhZGVyVGl0bGU6IHIsIGhlYWRlckNsb3NlOiB1LCBtZW51UGFnZUNvbnRlbnQ6IHMsIG1lbnVQYWdlQ2xvc2U6IHQsIHBsYWNlaG9sZGVyOiBcXFwiXFxcIiB9KSwgdGhpcy5yZWZyZXNoKCksIHRoaXMuX29yaWdUYWJJbmRleCA9PT0gYiAmJiAodGhpcy5fb3JpZ1RhYkluZGV4ID0gbnVsbCA9PT0gdGhpcy5zZWxlY3RbMF0uZ2V0QXR0cmlidXRlKFxcXCJ0YWJpbmRleFxcXCIpID8gITEgOiB0aGlzLnNlbGVjdC5hdHRyKFxcXCJ0YWJpbmRleFxcXCIpKSwgdGhpcy5zZWxlY3QuYXR0cihcXFwidGFiaW5kZXhcXFwiLCBcXFwiLTFcXFwiKSwgdGhpcy5fb24odGhpcy5zZWxlY3QsIHsgZm9jdXM6IFxcXCJfaGFuZGxlU2VsZWN0Rm9jdXNcXFwiIH0pLCB0aGlzLl9vbih0aGlzLmJ1dHRvbiwgeyB2Y2xpY2s6IFxcXCJfaGFuZGxlQnV0dG9uVmNsaWNrS2V5ZG93blxcXCIgfSksIHRoaXMubGlzdC5hdHRyKFxcXCJyb2xlXFxcIiwgXFxcImxpc3Rib3hcXFwiKSwgdGhpcy5fb24odGhpcy5saXN0LCB7IGZvY3VzaW46IFxcXCJfaGFuZGxlTGlzdEZvY3VzXFxcIiwgZm9jdXNvdXQ6IFxcXCJfaGFuZGxlTGlzdEZvY3VzXFxcIiwga2V5ZG93bjogXFxcIl9oYW5kbGVMaXN0S2V5ZG93blxcXCIsIFxcXCJjbGljayBsaTpub3QoLnVpLWRpc2FibGVkLC51aS1zdGF0ZS1kaXNhYmxlZCwudWktbGktZGl2aWRlcilcXFwiOiBcXFwiX2hhbmRsZUxpc3RJdGVtQ2xpY2tcXFwiIH0pLCB0aGlzLl9vbih0aGlzLm1lbnVQYWdlLCB7IHBhZ2VoaWRlOiBcXFwiX2hhbmRsZU1lbnVQYWdlSGlkZVxcXCIgfSksIHRoaXMuX29uKHRoaXMubGlzdGJveCwgeyBwb3B1cGFmdGVyY2xvc2U6IFxcXCJfcG9wdXBDbG9zZWRcXFwiIH0pLCB0aGlzLmlzTXVsdGlwbGUgJiYgdGhpcy5fb24odGhpcy5oZWFkZXJDbG9zZSwgeyBjbGljazogXFxcIl9oYW5kbGVIZWFkZXJDbG9zZUNsaWNrXFxcIiB9KSwgdGhpcyk7XFxuICAgICAgfSwgX3BvcHVwQ2xvc2VkOiBmdW5jdGlvbiBfcG9wdXBDbG9zZWQoKSB7XFxuICAgICAgICB0aGlzLmNsb3NlKCksIHRoaXMuX2RlbGF5ZWRUcmlnZ2VyKCk7XFxuICAgICAgfSwgX2RlbGF5ZWRUcmlnZ2VyOiBmdW5jdGlvbiBfZGVsYXllZFRyaWdnZXIoKSB7XFxuICAgICAgICB0aGlzLl90cmlnZ2VyQ2hhbmdlICYmIHRoaXMuZWxlbWVudC50cmlnZ2VyKFxcXCJjaGFuZ2VcXFwiKSwgdGhpcy5fdHJpZ2dlckNoYW5nZSA9ICExO1xcbiAgICAgIH0sIF9pc1JlYnVpbGRSZXF1aXJlZDogZnVuY3Rpb24gX2lzUmVidWlsZFJlcXVpcmVkKCkge1xcbiAgICAgICAgdmFyIGEgPSB0aGlzLmxpc3QuZmluZChcXFwibGlcXFwiKSxcXG4gICAgICAgICAgICBiID0gdGhpcy5fc2VsZWN0T3B0aW9ucygpLm5vdChcXFwiLnVpLXNjcmVlbi1oaWRkZW5cXFwiKTtyZXR1cm4gYi50ZXh0KCkgIT09IGEudGV4dCgpO1xcbiAgICAgIH0sIHNlbGVjdGVkOiBmdW5jdGlvbiBzZWxlY3RlZCgpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLl9zZWxlY3RPcHRpb25zKCkuZmlsdGVyKFxcXCI6c2VsZWN0ZWQ6bm90KCA6anFtRGF0YShwbGFjZWhvbGRlcj0ndHJ1ZScpIClcXFwiKTtcXG4gICAgICB9LCByZWZyZXNoOiBmdW5jdGlvbiByZWZyZXNoKGIpIHtcXG4gICAgICAgIHZhciBjLCBkO3JldHVybiB0aGlzLm9wdGlvbnMubmF0aXZlTWVudSA/IHRoaXMuX3N1cGVyKGIpIDogKGMgPSB0aGlzLCAoYiB8fCB0aGlzLl9pc1JlYnVpbGRSZXF1aXJlZCgpKSAmJiBjLl9idWlsZExpc3QoKSwgZCA9IHRoaXMuc2VsZWN0ZWRJbmRpY2VzKCksIGMuc2V0QnV0dG9uVGV4dCgpLCBjLnNldEJ1dHRvbkNvdW50KCksIHZvaWQgYy5saXN0LmZpbmQoXFxcImxpOm5vdCgudWktbGktZGl2aWRlcilcXFwiKS5maW5kKFxcXCJhXFxcIikucmVtb3ZlQ2xhc3MoYS5tb2JpbGUuYWN0aXZlQnRuQ2xhc3MpLmVuZCgpLmF0dHIoXFxcImFyaWEtc2VsZWN0ZWRcXFwiLCAhMSkuZWFjaChmdW5jdGlvbiAoYikge1xcbiAgICAgICAgICB2YXIgZSA9IGEodGhpcyk7YS5pbkFycmF5KGIsIGQpID4gLTEgPyAoZS5hdHRyKFxcXCJhcmlhLXNlbGVjdGVkXFxcIiwgITApLCBjLmlzTXVsdGlwbGUgPyBlLmZpbmQoXFxcImFcXFwiKS5yZW1vdmVDbGFzcyhcXFwidWktY2hlY2tib3gtb2ZmXFxcIikuYWRkQ2xhc3MoXFxcInVpLWNoZWNrYm94LW9uXFxcIikgOiBlLmhhc0NsYXNzKFxcXCJ1aS1zY3JlZW4taGlkZGVuXFxcIikgPyBlLm5leHQoKS5maW5kKFxcXCJhXFxcIikuYWRkQ2xhc3MoYS5tb2JpbGUuYWN0aXZlQnRuQ2xhc3MpIDogZS5maW5kKFxcXCJhXFxcIikuYWRkQ2xhc3MoYS5tb2JpbGUuYWN0aXZlQnRuQ2xhc3MpKSA6IGMuaXNNdWx0aXBsZSAmJiBlLmZpbmQoXFxcImFcXFwiKS5yZW1vdmVDbGFzcyhcXFwidWktY2hlY2tib3gtb25cXFwiKS5hZGRDbGFzcyhcXFwidWktY2hlY2tib3gtb2ZmXFxcIik7XFxuICAgICAgICB9KSk7XFxuICAgICAgfSwgY2xvc2U6IGZ1bmN0aW9uIGNsb3NlKCkge1xcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZGlzYWJsZWQgJiYgdGhpcy5pc09wZW4pIHtcXG4gICAgICAgICAgdmFyIGEgPSB0aGlzO1xcXCJwYWdlXFxcIiA9PT0gYS5tZW51VHlwZSA/IChhLm1lbnVQYWdlLmRpYWxvZyhcXFwiY2xvc2VcXFwiKSwgYS5saXN0LmFwcGVuZFRvKGEubGlzdGJveCkpIDogYS5saXN0Ym94LnBvcHVwKFxcXCJjbG9zZVxcXCIpLCBhLl9mb2N1c0J1dHRvbigpLCBhLmlzT3BlbiA9ICExO1xcbiAgICAgICAgfVxcbiAgICAgIH0sIG9wZW46IGZ1bmN0aW9uIG9wZW4oKSB7XFxuICAgICAgICB0aGlzLmJ1dHRvbi5jbGljaygpO1xcbiAgICAgIH0sIF9mb2N1c01lbnVJdGVtOiBmdW5jdGlvbiBfZm9jdXNNZW51SXRlbSgpIHtcXG4gICAgICAgIHZhciBiID0gdGhpcy5saXN0LmZpbmQoXFxcImEuXFxcIiArIGEubW9iaWxlLmFjdGl2ZUJ0bkNsYXNzKTswID09PSBiLmxlbmd0aCAmJiAoYiA9IHRoaXMubGlzdC5maW5kKFxcXCJsaTpub3QoXFxcIiArIGQgKyBcXFwiKSBhLnVpLWJ0blxcXCIpKSwgYi5maXJzdCgpLmZvY3VzKCk7XFxuICAgICAgfSwgX2RlY2lkZUZvcm1hdDogZnVuY3Rpb24gX2RlY2lkZUZvcm1hdCgpIHtcXG4gICAgICAgIHZhciBiID0gdGhpcyxcXG4gICAgICAgICAgICBjID0gdGhpcy53aW5kb3csXFxuICAgICAgICAgICAgZCA9IGIubGlzdC5wYXJlbnQoKSxcXG4gICAgICAgICAgICBlID0gZC5vdXRlckhlaWdodCgpLFxcbiAgICAgICAgICAgIGYgPSBjLnNjcm9sbFRvcCgpLFxcbiAgICAgICAgICAgIGcgPSBiLmJ1dHRvbi5vZmZzZXQoKS50b3AsXFxuICAgICAgICAgICAgaCA9IGMuaGVpZ2h0KCk7ZSA+IGggLSA4MCB8fCAhYS5zdXBwb3J0LnNjcm9sbFRvcCA/IChiLm1lbnVQYWdlLmFwcGVuZFRvKGEubW9iaWxlLnBhZ2VDb250YWluZXIpLnBhZ2UoKSwgYi5tZW51UGFnZUNvbnRlbnQgPSBiLm1lbnVQYWdlLmZpbmQoXFxcIi51aS1jb250ZW50XFxcIiksIGIubWVudVBhZ2VDbG9zZSA9IGIubWVudVBhZ2UuZmluZChcXFwiLnVpLWhlYWRlciBhXFxcIiksIGIudGhpc1BhZ2UudW5iaW5kKFxcXCJwYWdlaGlkZS5yZW1vdmVcXFwiKSwgMCA9PT0gZiAmJiBnID4gaCAmJiBiLnRoaXNQYWdlLm9uZShcXFwicGFnZWhpZGVcXFwiLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIGEodGhpcykuanFtRGF0YShcXFwibGFzdFNjcm9sbFxcXCIsIGcpO1xcbiAgICAgICAgfSksIGIubWVudVBhZ2Uub25lKHsgcGFnZXNob3c6IGEucHJveHkodGhpcywgXFxcIl9mb2N1c01lbnVJdGVtXFxcIiksIHBhZ2VoaWRlOiBhLnByb3h5KHRoaXMsIFxcXCJjbG9zZVxcXCIpIH0pLCBiLm1lbnVUeXBlID0gXFxcInBhZ2VcXFwiLCBiLm1lbnVQYWdlQ29udGVudC5hcHBlbmQoYi5saXN0KSwgYi5tZW51UGFnZS5maW5kKFxcXCJkaXYgLnVpLXRpdGxlXFxcIikudGV4dChiLmxhYmVsLmdldEVuY29kZWRUZXh0KCkgfHwgYi5wbGFjZWhvbGRlcikpIDogKGIubWVudVR5cGUgPSBcXFwib3ZlcmxheVxcXCIsIGIubGlzdGJveC5vbmUoeyBwb3B1cGFmdGVyb3BlbjogYS5wcm94eSh0aGlzLCBcXFwiX2ZvY3VzTWVudUl0ZW1cXFwiKSB9KSk7XFxuICAgICAgfSwgX2J1aWxkTGlzdDogZnVuY3Rpb24gX2J1aWxkTGlzdCgpIHtcXG4gICAgICAgIHZhciBiLFxcbiAgICAgICAgICAgIGQsXFxuICAgICAgICAgICAgZSxcXG4gICAgICAgICAgICBmLFxcbiAgICAgICAgICAgIGcsXFxuICAgICAgICAgICAgaCxcXG4gICAgICAgICAgICBpLFxcbiAgICAgICAgICAgIGosXFxuICAgICAgICAgICAgayxcXG4gICAgICAgICAgICBsLFxcbiAgICAgICAgICAgIG0sXFxuICAgICAgICAgICAgbixcXG4gICAgICAgICAgICBvLFxcbiAgICAgICAgICAgIHAsXFxuICAgICAgICAgICAgcSA9IHRoaXMsXFxuICAgICAgICAgICAgciA9IHRoaXMub3B0aW9ucyxcXG4gICAgICAgICAgICBzID0gdGhpcy5wbGFjZWhvbGRlcixcXG4gICAgICAgICAgICB0ID0gITAsXFxuICAgICAgICAgICAgdSA9IFxcXCJmYWxzZVxcXCIsXFxuICAgICAgICAgICAgdiA9IFxcXCJkYXRhLVxcXCIgKyBhLm1vYmlsZS5ucyxcXG4gICAgICAgICAgICB3ID0gdiArIFxcXCJvcHRpb24taW5kZXhcXFwiLFxcbiAgICAgICAgICAgIHggPSB2ICsgXFxcImljb25cXFwiLFxcbiAgICAgICAgICAgIHkgPSB2ICsgXFxcInJvbGVcXFwiLFxcbiAgICAgICAgICAgIHogPSB2ICsgXFxcInBsYWNlaG9sZGVyXFxcIixcXG4gICAgICAgICAgICBBID0gYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXFxuICAgICAgICAgICAgQiA9ICExO2ZvciAocS5saXN0LmVtcHR5KCkuZmlsdGVyKFxcXCIudWktbGlzdHZpZXdcXFwiKS5saXN0dmlldyhcXFwiZGVzdHJveVxcXCIpLCBiID0gdGhpcy5fc2VsZWN0T3B0aW9ucygpLCBkID0gYi5sZW5ndGgsIGUgPSB0aGlzLnNlbGVjdFswXSwgZyA9IDA7IGQgPiBnOyBnKyssIEIgPSAhMSkge1xcbiAgICAgICAgICBoID0gYltnXSwgaSA9IGEoaCksIGkuaGFzQ2xhc3MoXFxcInVpLXNjcmVlbi1oaWRkZW5cXFwiKSB8fCAoaiA9IGgucGFyZW50Tm9kZSwgbSA9IFtdLCBrID0gaS50ZXh0KCksIGwgPSBjLmNyZWF0ZUVsZW1lbnQoXFxcImFcXFwiKSwgbC5zZXRBdHRyaWJ1dGUoXFxcImhyZWZcXFwiLCBcXFwiI1xcXCIpLCBsLmFwcGVuZENoaWxkKGMuY3JlYXRlVGV4dE5vZGUoaykpLCBqICE9PSBlICYmIFxcXCJvcHRncm91cFxcXCIgPT09IGoubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAmJiAobiA9IGouZ2V0QXR0cmlidXRlKFxcXCJsYWJlbFxcXCIpLCBuICE9PSBmICYmIChvID0gYy5jcmVhdGVFbGVtZW50KFxcXCJsaVxcXCIpLCBvLnNldEF0dHJpYnV0ZSh5LCBcXFwibGlzdC1kaXZpZGVyXFxcIiksIG8uc2V0QXR0cmlidXRlKFxcXCJyb2xlXFxcIiwgXFxcIm9wdGlvblxcXCIpLCBvLnNldEF0dHJpYnV0ZShcXFwidGFiaW5kZXhcXFwiLCBcXFwiLTFcXFwiKSwgby5hcHBlbmRDaGlsZChjLmNyZWF0ZVRleHROb2RlKG4pKSwgQS5hcHBlbmRDaGlsZChvKSwgZiA9IG4pKSwgIXQgfHwgaC5nZXRBdHRyaWJ1dGUoXFxcInZhbHVlXFxcIikgJiYgMCAhPT0gay5sZW5ndGggJiYgIWkuanFtRGF0YShcXFwicGxhY2Vob2xkZXJcXFwiKSB8fCAodCA9ICExLCBCID0gITAsIG51bGwgPT09IGguZ2V0QXR0cmlidXRlKHopICYmICh0aGlzLl9yZW1vdmVQbGFjZWhvbGRlckF0dHIgPSAhMCksIGguc2V0QXR0cmlidXRlKHosICEwKSwgci5oaWRlUGxhY2Vob2xkZXJNZW51SXRlbXMgJiYgbS5wdXNoKFxcXCJ1aS1zY3JlZW4taGlkZGVuXFxcIiksIHMgIT09IGsgJiYgKHMgPSBxLnBsYWNlaG9sZGVyID0gaykpLCBwID0gYy5jcmVhdGVFbGVtZW50KFxcXCJsaVxcXCIpLCBoLmRpc2FibGVkICYmIChtLnB1c2goXFxcInVpLXN0YXRlLWRpc2FibGVkXFxcIiksIHAuc2V0QXR0cmlidXRlKFxcXCJhcmlhLWRpc2FibGVkXFxcIiwgITApKSwgcC5zZXRBdHRyaWJ1dGUodywgZyksIHAuc2V0QXR0cmlidXRlKHgsIHUpLCBCICYmIHAuc2V0QXR0cmlidXRlKHosICEwKSwgcC5jbGFzc05hbWUgPSBtLmpvaW4oXFxcIiBcXFwiKSwgcC5zZXRBdHRyaWJ1dGUoXFxcInJvbGVcXFwiLCBcXFwib3B0aW9uXFxcIiksIGwuc2V0QXR0cmlidXRlKFxcXCJ0YWJpbmRleFxcXCIsIFxcXCItMVxcXCIpLCB0aGlzLmlzTXVsdGlwbGUgJiYgYShsKS5hZGRDbGFzcyhcXFwidWktYnRuIHVpLWNoZWNrYm94LW9mZiB1aS1idG4taWNvbi1yaWdodFxcXCIpLCBwLmFwcGVuZENoaWxkKGwpLCBBLmFwcGVuZENoaWxkKHApKTtcXG4gICAgICAgIH1xLmxpc3RbMF0uYXBwZW5kQ2hpbGQoQSksIHRoaXMuaXNNdWx0aXBsZSB8fCBzLmxlbmd0aCA/IHRoaXMuaGVhZGVyVGl0bGUudGV4dCh0aGlzLnBsYWNlaG9sZGVyKSA6IHRoaXMuaGVhZGVyLmFkZENsYXNzKFxcXCJ1aS1zY3JlZW4taGlkZGVuXFxcIiksIHEubGlzdC5saXN0dmlldygpO1xcbiAgICAgIH0sIF9idXR0b246IGZ1bmN0aW9uIF9idXR0b24oKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLm5hdGl2ZU1lbnUgPyB0aGlzLl9zdXBlcigpIDogYShcXFwiPGE+XFxcIiwgeyBocmVmOiBcXFwiI1xcXCIsIHJvbGU6IFxcXCJidXR0b25cXFwiLCBpZDogdGhpcy5idXR0b25JZCwgXFxcImFyaWEtaGFzcG9wdXBcXFwiOiBcXFwidHJ1ZVxcXCIsIFxcXCJhcmlhLW93bnNcXFwiOiB0aGlzLm1lbnVJZCB9KTtcXG4gICAgICB9LCBfZGVzdHJveTogZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XFxuICAgICAgICB0aGlzLm9wdGlvbnMubmF0aXZlTWVudSB8fCAodGhpcy5jbG9zZSgpLCB0aGlzLl9vcmlnVGFiSW5kZXggIT09IGIgJiYgKHRoaXMuX29yaWdUYWJJbmRleCAhPT0gITEgPyB0aGlzLnNlbGVjdC5hdHRyKFxcXCJ0YWJpbmRleFxcXCIsIHRoaXMuX29yaWdUYWJJbmRleCkgOiB0aGlzLnNlbGVjdC5yZW1vdmVBdHRyKFxcXCJ0YWJpbmRleFxcXCIpKSwgdGhpcy5fcmVtb3ZlUGxhY2Vob2xkZXJBdHRyICYmIHRoaXMuX3NlbGVjdE9wdGlvbnMoKS5yZW1vdmVBdHRyKFxcXCJkYXRhLVxcXCIgKyBhLm1vYmlsZS5ucyArIFxcXCJwbGFjZWhvbGRlclxcXCIpLCB0aGlzLmxpc3Rib3gucmVtb3ZlKCksIHRoaXMubWVudVBhZ2UucmVtb3ZlKCkpLCB0aGlzLl9zdXBlcigpO1xcbiAgICAgIH0gfSk7XFxuICB9KGEpLCBmdW5jdGlvbiAoYSwgYikge1xcbiAgICBmdW5jdGlvbiBjKGEsIGIpIHtcXG4gICAgICB2YXIgYyA9IGIgPyBiIDogW107cmV0dXJuIGMucHVzaChcXFwidWktYnRuXFxcIiksIGEudGhlbWUgJiYgYy5wdXNoKFxcXCJ1aS1idG4tXFxcIiArIGEudGhlbWUpLCBhLmljb24gJiYgKGMgPSBjLmNvbmNhdChbXFxcInVpLWljb24tXFxcIiArIGEuaWNvbiwgXFxcInVpLWJ0bi1pY29uLVxcXCIgKyBhLmljb25wb3NdKSwgYS5pY29uc2hhZG93ICYmIGMucHVzaChcXFwidWktc2hhZG93LWljb25cXFwiKSksIGEuaW5saW5lICYmIGMucHVzaChcXFwidWktYnRuLWlubGluZVxcXCIpLCBhLnNoYWRvdyAmJiBjLnB1c2goXFxcInVpLXNoYWRvd1xcXCIpLCBhLmNvcm5lcnMgJiYgYy5wdXNoKFxcXCJ1aS1jb3JuZXItYWxsXFxcIiksIGEubWluaSAmJiBjLnB1c2goXFxcInVpLW1pbmlcXFwiKSwgYztcXG4gICAgfWZ1bmN0aW9uIGQoYSkge1xcbiAgICAgIHZhciBjLFxcbiAgICAgICAgICBkLFxcbiAgICAgICAgICBlLFxcbiAgICAgICAgICBnID0gITEsXFxuICAgICAgICAgIGggPSAhMCxcXG4gICAgICAgICAgaSA9IHsgaWNvbjogXFxcIlxcXCIsIGlubGluZTogITEsIHNoYWRvdzogITEsIGNvcm5lcnM6ICExLCBpY29uc2hhZG93OiAhMSwgbWluaTogITEgfSxcXG4gICAgICAgICAgaiA9IFtdO2ZvciAoYSA9IGEuc3BsaXQoXFxcIiBcXFwiKSwgYyA9IDA7IGMgPCBhLmxlbmd0aDsgYysrKSB7XFxuICAgICAgICBlID0gITAsIGQgPSBmW2FbY11dLCBkICE9PSBiID8gKGUgPSAhMSwgaVtkXSA9ICEwKSA6IDAgPT09IGFbY10uaW5kZXhPZihcXFwidWktYnRuLWljb24tXFxcIikgPyAoZSA9ICExLCBoID0gITEsIGkuaWNvbnBvcyA9IGFbY10uc3Vic3RyaW5nKDEyKSkgOiAwID09PSBhW2NdLmluZGV4T2YoXFxcInVpLWljb24tXFxcIikgPyAoZSA9ICExLCBpLmljb24gPSBhW2NdLnN1YnN0cmluZyg4KSkgOiAwID09PSBhW2NdLmluZGV4T2YoXFxcInVpLWJ0bi1cXFwiKSAmJiA4ID09PSBhW2NdLmxlbmd0aCA/IChlID0gITEsIGkudGhlbWUgPSBhW2NdLnN1YnN0cmluZyg3KSkgOiBcXFwidWktYnRuXFxcIiA9PT0gYVtjXSAmJiAoZSA9ICExLCBnID0gITApLCBlICYmIGoucHVzaChhW2NdKTtcXG4gICAgICB9cmV0dXJuIGggJiYgKGkuaWNvbiA9IFxcXCJcXFwiKSwgeyBvcHRpb25zOiBpLCB1bmtub3duQ2xhc3NlczogaiwgYWxyZWFkeUVuaGFuY2VkOiBnIH07XFxuICAgIH1mdW5jdGlvbiBlKGEpIHtcXG4gICAgICByZXR1cm4gXFxcIi1cXFwiICsgYS50b0xvd2VyQ2FzZSgpO1xcbiAgICB9dmFyIGYgPSB7IFxcXCJ1aS1zaGFkb3dcXFwiOiBcXFwic2hhZG93XFxcIiwgXFxcInVpLWNvcm5lci1hbGxcXFwiOiBcXFwiY29ybmVyc1xcXCIsIFxcXCJ1aS1idG4taW5saW5lXFxcIjogXFxcImlubGluZVxcXCIsIFxcXCJ1aS1zaGFkb3ctaWNvblxcXCI6IFxcXCJpY29uc2hhZG93XFxcIiwgXFxcInVpLW1pbmlcXFwiOiBcXFwibWluaVxcXCIgfSxcXG4gICAgICAgIGcgPSBmdW5jdGlvbiBnKCkge1xcbiAgICAgIHZhciBjID0gYS5tb2JpbGUuZ2V0QXR0cmlidXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7cmV0dXJuIG51bGwgPT0gYyA/IGIgOiBjO1xcbiAgICB9LFxcbiAgICAgICAgaCA9IC9bQS1aXS9nO2EuZm4uYnV0dG9uTWFya3VwID0gZnVuY3Rpb24gKGYsIGkpIHtcXG4gICAgICB2YXIgaixcXG4gICAgICAgICAgayxcXG4gICAgICAgICAgbCxcXG4gICAgICAgICAgbSxcXG4gICAgICAgICAgbixcXG4gICAgICAgICAgbyA9IGEuZm4uYnV0dG9uTWFya3VwLmRlZmF1bHRzO2ZvciAoaiA9IDA7IGogPCB0aGlzLmxlbmd0aDsgaisrKSB7XFxuICAgICAgICBpZiAobCA9IHRoaXNbal0sIGsgPSBpID8geyBhbHJlYWR5RW5oYW5jZWQ6ICExLCB1bmtub3duQ2xhc3NlczogW10gfSA6IGQobC5jbGFzc05hbWUpLCBtID0gYS5leHRlbmQoe30sIGsuYWxyZWFkeUVuaGFuY2VkID8gay5vcHRpb25zIDoge30sIGYpLCAhay5hbHJlYWR5RW5oYW5jZWQpIGZvciAobiBpbiBvKSB7XFxuICAgICAgICAgIG1bbl0gPT09IGIgJiYgKG1bbl0gPSBnKGwsIG4ucmVwbGFjZShoLCBlKSkpO1xcbiAgICAgICAgfWwuY2xhc3NOYW1lID0gYyhhLmV4dGVuZCh7fSwgbywgbSksIGsudW5rbm93bkNsYXNzZXMpLmpvaW4oXFxcIiBcXFwiKSwgXFxcImJ1dHRvblxcXCIgIT09IGwudGFnTmFtZS50b0xvd2VyQ2FzZSgpICYmIGwuc2V0QXR0cmlidXRlKFxcXCJyb2xlXFxcIiwgXFxcImJ1dHRvblxcXCIpO1xcbiAgICAgIH1yZXR1cm4gdGhpcztcXG4gICAgfSwgYS5mbi5idXR0b25NYXJrdXAuZGVmYXVsdHMgPSB7IGljb246IFxcXCJcXFwiLCBpY29ucG9zOiBcXFwibGVmdFxcXCIsIHRoZW1lOiBudWxsLCBpbmxpbmU6ICExLCBzaGFkb3c6ICEwLCBjb3JuZXJzOiAhMCwgaWNvbnNoYWRvdzogITEsIG1pbmk6ICExIH0sIGEuZXh0ZW5kKGEuZm4uYnV0dG9uTWFya3VwLCB7IGluaXRTZWxlY3RvcjogXFxcImE6anFtRGF0YShyb2xlPSdidXR0b24nKSwgLnVpLWJhciA+IGEsIC51aS1iYXIgPiA6anFtRGF0YShyb2xlPSdjb250cm9sZ3JvdXAnKSA+IGEsIGJ1dHRvbjpub3QoOmpxbURhdGEocm9sZT0nbmF2YmFyJykgYnV0dG9uKVxcXCIgfSk7XFxuICB9KGEpLCBmdW5jdGlvbiAoYSwgYikge1xcbiAgICBhLndpZGdldChcXFwibW9iaWxlLmNvbnRyb2xncm91cFxcXCIsIGEuZXh0ZW5kKHsgb3B0aW9uczogeyBlbmhhbmNlZDogITEsIHRoZW1lOiBudWxsLCBzaGFkb3c6ICExLCBjb3JuZXJzOiAhMCwgZXhjbHVkZUludmlzaWJsZTogITAsIHR5cGU6IFxcXCJ2ZXJ0aWNhbFxcXCIsIG1pbmk6ICExIH0sIF9jcmVhdGU6IGZ1bmN0aW9uIF9jcmVhdGUoKSB7XFxuICAgICAgICB2YXIgYiA9IHRoaXMuZWxlbWVudCxcXG4gICAgICAgICAgICBjID0gdGhpcy5vcHRpb25zLFxcbiAgICAgICAgICAgIGQgPSBhLm1vYmlsZS5wYWdlLnByb3RvdHlwZS5rZWVwTmF0aXZlU2VsZWN0b3IoKTthLmZuLmJ1dHRvbk1hcmt1cCAmJiB0aGlzLmVsZW1lbnQuZmluZChhLmZuLmJ1dHRvbk1hcmt1cC5pbml0U2VsZWN0b3IpLm5vdChkKS5idXR0b25NYXJrdXAoKSwgYS5lYWNoKHRoaXMuX2NoaWxkV2lkZ2V0cywgYS5wcm94eShmdW5jdGlvbiAoYiwgYykge1xcbiAgICAgICAgICBhLm1vYmlsZVtjXSAmJiB0aGlzLmVsZW1lbnQuZmluZChhLm1vYmlsZVtjXS5pbml0U2VsZWN0b3IpLm5vdChkKVtjXSgpO1xcbiAgICAgICAgfSwgdGhpcykpLCBhLmV4dGVuZCh0aGlzLCB7IF91aTogbnVsbCwgX2luaXRpYWxSZWZyZXNoOiAhMCB9KSwgdGhpcy5fdWkgPSBjLmVuaGFuY2VkID8geyBncm91cExlZ2VuZDogYi5jaGlsZHJlbihcXFwiLnVpLWNvbnRyb2xncm91cC1sYWJlbFxcXCIpLmNoaWxkcmVuKCksIGNoaWxkV3JhcHBlcjogYi5jaGlsZHJlbihcXFwiLnVpLWNvbnRyb2xncm91cC1jb250cm9sc1xcXCIpIH0gOiB0aGlzLl9lbmhhbmNlKCk7XFxuICAgICAgfSwgX2NoaWxkV2lkZ2V0czogW1xcXCJjaGVja2JveHJhZGlvXFxcIiwgXFxcInNlbGVjdG1lbnVcXFwiLCBcXFwiYnV0dG9uXFxcIl0sIF90aGVtZUNsYXNzRnJvbU9wdGlvbjogZnVuY3Rpb24gX3RoZW1lQ2xhc3NGcm9tT3B0aW9uKGEpIHtcXG4gICAgICAgIHJldHVybiBhID8gXFxcIm5vbmVcXFwiID09PSBhID8gXFxcIlxcXCIgOiBcXFwidWktZ3JvdXAtdGhlbWUtXFxcIiArIGEgOiBcXFwiXFxcIjtcXG4gICAgICB9LCBfZW5oYW5jZTogZnVuY3Rpb24gX2VuaGFuY2UoKSB7XFxuICAgICAgICB2YXIgYiA9IHRoaXMuZWxlbWVudCxcXG4gICAgICAgICAgICBjID0gdGhpcy5vcHRpb25zLFxcbiAgICAgICAgICAgIGQgPSB7IGdyb3VwTGVnZW5kOiBiLmNoaWxkcmVuKFxcXCJsZWdlbmRcXFwiKSwgY2hpbGRXcmFwcGVyOiBiLmFkZENsYXNzKFxcXCJ1aS1jb250cm9sZ3JvdXAgdWktY29udHJvbGdyb3VwLVxcXCIgKyAoXFxcImhvcml6b250YWxcXFwiID09PSBjLnR5cGUgPyBcXFwiaG9yaXpvbnRhbFxcXCIgOiBcXFwidmVydGljYWxcXFwiKSArIFxcXCIgXFxcIiArIHRoaXMuX3RoZW1lQ2xhc3NGcm9tT3B0aW9uKGMudGhlbWUpICsgXFxcIiBcXFwiICsgKGMuY29ybmVycyA/IFxcXCJ1aS1jb3JuZXItYWxsIFxcXCIgOiBcXFwiXFxcIikgKyAoYy5taW5pID8gXFxcInVpLW1pbmkgXFxcIiA6IFxcXCJcXFwiKSkud3JhcElubmVyKFxcXCI8ZGl2IGNsYXNzPSd1aS1jb250cm9sZ3JvdXAtY29udHJvbHMgXFxcIiArIChjLnNoYWRvdyA9PT0gITAgPyBcXFwidWktc2hhZG93XFxcIiA6IFxcXCJcXFwiKSArIFxcXCInPjwvZGl2PlxcXCIpLmNoaWxkcmVuKCkgfTtyZXR1cm4gZC5ncm91cExlZ2VuZC5sZW5ndGggPiAwICYmIGEoXFxcIjxkaXYgcm9sZT0naGVhZGluZycgY2xhc3M9J3VpLWNvbnRyb2xncm91cC1sYWJlbCc+PC9kaXY+XFxcIikuYXBwZW5kKGQuZ3JvdXBMZWdlbmQpLnByZXBlbmRUbyhiKSwgZDtcXG4gICAgICB9LCBfaW5pdDogZnVuY3Rpb24gX2luaXQoKSB7XFxuICAgICAgICB0aGlzLnJlZnJlc2goKTtcXG4gICAgICB9LCBfc2V0T3B0aW9uczogZnVuY3Rpb24gX3NldE9wdGlvbnMoYSkge1xcbiAgICAgICAgdmFyIGMsXFxuICAgICAgICAgICAgZCxcXG4gICAgICAgICAgICBlID0gdGhpcy5lbGVtZW50O3JldHVybiBhLnR5cGUgIT09IGIgJiYgKGUucmVtb3ZlQ2xhc3MoXFxcInVpLWNvbnRyb2xncm91cC1ob3Jpem9udGFsIHVpLWNvbnRyb2xncm91cC12ZXJ0aWNhbFxcXCIpLmFkZENsYXNzKFxcXCJ1aS1jb250cm9sZ3JvdXAtXFxcIiArIChcXFwiaG9yaXpvbnRhbFxcXCIgPT09IGEudHlwZSA/IFxcXCJob3Jpem9udGFsXFxcIiA6IFxcXCJ2ZXJ0aWNhbFxcXCIpKSwgYyA9ICEwKSwgYS50aGVtZSAhPT0gYiAmJiBlLnJlbW92ZUNsYXNzKHRoaXMuX3RoZW1lQ2xhc3NGcm9tT3B0aW9uKHRoaXMub3B0aW9ucy50aGVtZSkpLmFkZENsYXNzKHRoaXMuX3RoZW1lQ2xhc3NGcm9tT3B0aW9uKGEudGhlbWUpKSwgYS5jb3JuZXJzICE9PSBiICYmIGUudG9nZ2xlQ2xhc3MoXFxcInVpLWNvcm5lci1hbGxcXFwiLCBhLmNvcm5lcnMpLCBhLm1pbmkgIT09IGIgJiYgZS50b2dnbGVDbGFzcyhcXFwidWktbWluaVxcXCIsIGEubWluaSksIGEuc2hhZG93ICE9PSBiICYmIHRoaXMuX3VpLmNoaWxkV3JhcHBlci50b2dnbGVDbGFzcyhcXFwidWktc2hhZG93XFxcIiwgYS5zaGFkb3cpLCBhLmV4Y2x1ZGVJbnZpc2libGUgIT09IGIgJiYgKHRoaXMub3B0aW9ucy5leGNsdWRlSW52aXNpYmxlID0gYS5leGNsdWRlSW52aXNpYmxlLCBjID0gITApLCBkID0gdGhpcy5fc3VwZXIoYSksIGMgJiYgdGhpcy5yZWZyZXNoKCksIGQ7XFxuICAgICAgfSwgY29udGFpbmVyOiBmdW5jdGlvbiBjb250YWluZXIoKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5fdWkuY2hpbGRXcmFwcGVyO1xcbiAgICAgIH0sIHJlZnJlc2g6IGZ1bmN0aW9uIHJlZnJlc2goKSB7XFxuICAgICAgICB2YXIgYiA9IHRoaXMuY29udGFpbmVyKCksXFxuICAgICAgICAgICAgYyA9IGIuZmluZChcXFwiLnVpLWJ0blxcXCIpLm5vdChcXFwiLnVpLXNsaWRlci1oYW5kbGVcXFwiKSxcXG4gICAgICAgICAgICBkID0gdGhpcy5faW5pdGlhbFJlZnJlc2g7YS5tb2JpbGUuY2hlY2tib3hyYWRpbyAmJiBiLmZpbmQoXFxcIjptb2JpbGUtY2hlY2tib3hyYWRpb1xcXCIpLmNoZWNrYm94cmFkaW8oXFxcInJlZnJlc2hcXFwiKSwgdGhpcy5fYWRkRmlyc3RMYXN0Q2xhc3NlcyhjLCB0aGlzLm9wdGlvbnMuZXhjbHVkZUludmlzaWJsZSA/IHRoaXMuX2dldFZpc2libGVzKGMsIGQpIDogYywgZCksIHRoaXMuX2luaXRpYWxSZWZyZXNoID0gITE7XFxuICAgICAgfSwgX2Rlc3Ryb3k6IGZ1bmN0aW9uIF9kZXN0cm95KCkge1xcbiAgICAgICAgdmFyIGEsXFxuICAgICAgICAgICAgYixcXG4gICAgICAgICAgICBjID0gdGhpcy5vcHRpb25zO3JldHVybiBjLmVuaGFuY2VkID8gdGhpcyA6IChhID0gdGhpcy5fdWksIGIgPSB0aGlzLmVsZW1lbnQucmVtb3ZlQ2xhc3MoXFxcInVpLWNvbnRyb2xncm91cCB1aS1jb250cm9sZ3JvdXAtaG9yaXpvbnRhbCB1aS1jb250cm9sZ3JvdXAtdmVydGljYWwgdWktY29ybmVyLWFsbCB1aS1taW5pIFxcXCIgKyB0aGlzLl90aGVtZUNsYXNzRnJvbU9wdGlvbihjLnRoZW1lKSkuZmluZChcXFwiLnVpLWJ0blxcXCIpLm5vdChcXFwiLnVpLXNsaWRlci1oYW5kbGVcXFwiKSwgdGhpcy5fcmVtb3ZlRmlyc3RMYXN0Q2xhc3NlcyhiKSwgYS5ncm91cExlZ2VuZC51bndyYXAoKSwgdm9pZCBhLmNoaWxkV3JhcHBlci5jaGlsZHJlbigpLnVud3JhcCgpKTtcXG4gICAgICB9IH0sIGEubW9iaWxlLmJlaGF2aW9ycy5hZGRGaXJzdExhc3RDbGFzc2VzKSk7XFxuICB9KGEpLCBmdW5jdGlvbiAoYSwgYikge1xcbiAgICBhLndpZGdldChcXFwibW9iaWxlLnRvb2xiYXJcXFwiLCB7IGluaXRTZWxlY3RvcjogXFxcIjpqcW1EYXRhKHJvbGU9J2Zvb3RlcicpLCA6anFtRGF0YShyb2xlPSdoZWFkZXInKVxcXCIsIG9wdGlvbnM6IHsgdGhlbWU6IG51bGwsIGFkZEJhY2tCdG46ICExLCBiYWNrQnRuVGhlbWU6IG51bGwsIGJhY2tCdG5UZXh0OiBcXFwiQmFja1xcXCIgfSwgX2NyZWF0ZTogZnVuY3Rpb24gX2NyZWF0ZSgpIHtcXG4gICAgICAgIHZhciBiLFxcbiAgICAgICAgICAgIGMsXFxuICAgICAgICAgICAgZCA9IHRoaXMuZWxlbWVudC5pcyhcXFwiOmpxbURhdGEocm9sZT0naGVhZGVyJylcXFwiKSA/IFxcXCJoZWFkZXJcXFwiIDogXFxcImZvb3RlclxcXCIsXFxuICAgICAgICAgICAgZSA9IHRoaXMuZWxlbWVudC5jbG9zZXN0KFxcXCIudWktcGFnZVxcXCIpOzAgPT09IGUubGVuZ3RoICYmIChlID0gITEsIHRoaXMuX29uKHRoaXMuZG9jdW1lbnQsIHsgcGFnZXNob3c6IFxcXCJyZWZyZXNoXFxcIiB9KSksIGEuZXh0ZW5kKHRoaXMsIHsgcm9sZTogZCwgcGFnZTogZSwgbGVmdGJ0bjogYiwgcmlnaHRidG46IGMgfSksIHRoaXMuZWxlbWVudC5hdHRyKFxcXCJyb2xlXFxcIiwgXFxcImhlYWRlclxcXCIgPT09IGQgPyBcXFwiYmFubmVyXFxcIiA6IFxcXCJjb250ZW50aW5mb1xcXCIpLmFkZENsYXNzKFxcXCJ1aS1cXFwiICsgZCksIHRoaXMucmVmcmVzaCgpLCB0aGlzLl9zZXRPcHRpb25zKHRoaXMub3B0aW9ucyk7XFxuICAgICAgfSwgX3NldE9wdGlvbnM6IGZ1bmN0aW9uIF9zZXRPcHRpb25zKGEpIHtcXG4gICAgICAgIGlmIChhLmFkZEJhY2tCdG4gIT09IGIgJiYgdGhpcy5fdXBkYXRlQmFja0J1dHRvbigpLCBudWxsICE9IGEuYmFja0J0blRoZW1lICYmIHRoaXMuZWxlbWVudC5maW5kKFxcXCIudWktdG9vbGJhci1iYWNrLWJ0blxcXCIpLmFkZENsYXNzKFxcXCJ1aS1idG4gdWktYnRuLVxcXCIgKyBhLmJhY2tCdG5UaGVtZSksIGEuYmFja0J0blRleHQgIT09IGIgJiYgdGhpcy5lbGVtZW50LmZpbmQoXFxcIi51aS10b29sYmFyLWJhY2stYnRuIC51aS1idG4tdGV4dFxcXCIpLnRleHQoYS5iYWNrQnRuVGV4dCksIGEudGhlbWUgIT09IGIpIHtcXG4gICAgICAgICAgdmFyIGMgPSB0aGlzLm9wdGlvbnMudGhlbWUgPyB0aGlzLm9wdGlvbnMudGhlbWUgOiBcXFwiaW5oZXJpdFxcXCIsXFxuICAgICAgICAgICAgICBkID0gYS50aGVtZSA/IGEudGhlbWUgOiBcXFwiaW5oZXJpdFxcXCI7dGhpcy5lbGVtZW50LnJlbW92ZUNsYXNzKFxcXCJ1aS1iYXItXFxcIiArIGMpLmFkZENsYXNzKFxcXCJ1aS1iYXItXFxcIiArIGQpO1xcbiAgICAgICAgfXRoaXMuX3N1cGVyKGEpO1xcbiAgICAgIH0sIHJlZnJlc2g6IGZ1bmN0aW9uIHJlZnJlc2goKSB7XFxuICAgICAgICBcXFwiaGVhZGVyXFxcIiA9PT0gdGhpcy5yb2xlICYmIHRoaXMuX2FkZEhlYWRlckJ1dHRvbkNsYXNzZXMoKSwgdGhpcy5wYWdlIHx8ICh0aGlzLl9zZXRSZWxhdGl2ZSgpLCBcXFwiZm9vdGVyXFxcIiA9PT0gdGhpcy5yb2xlID8gdGhpcy5lbGVtZW50LmFwcGVuZFRvKFxcXCJib2R5XFxcIikgOiBcXFwiaGVhZGVyXFxcIiA9PT0gdGhpcy5yb2xlICYmIHRoaXMuX3VwZGF0ZUJhY2tCdXR0b24oKSksIHRoaXMuX2FkZEhlYWRpbmdDbGFzc2VzKCksIHRoaXMuX2J0bk1hcmt1cCgpO1xcbiAgICAgIH0sIF9zZXRSZWxhdGl2ZTogZnVuY3Rpb24gX3NldFJlbGF0aXZlKCkge1xcbiAgICAgICAgYShcXFwiW2RhdGEtXFxcIiArIGEubW9iaWxlLm5zICsgXFxcInJvbGU9J3BhZ2UnXVxcXCIpLmNzcyh7IHBvc2l0aW9uOiBcXFwicmVsYXRpdmVcXFwiIH0pO1xcbiAgICAgIH0sIF9idG5NYXJrdXA6IGZ1bmN0aW9uIF9idG5NYXJrdXAoKSB7XFxuICAgICAgICB0aGlzLmVsZW1lbnQuY2hpbGRyZW4oXFxcImFcXFwiKS5maWx0ZXIoXFxcIjpub3QoW2RhdGEtXFxcIiArIGEubW9iaWxlLm5zICsgXFxcInJvbGU9J25vbmUnXSlcXFwiKS5hdHRyKFxcXCJkYXRhLVxcXCIgKyBhLm1vYmlsZS5ucyArIFxcXCJyb2xlXFxcIiwgXFxcImJ1dHRvblxcXCIpLCB0aGlzLmVsZW1lbnQudHJpZ2dlcihcXFwiY3JlYXRlXFxcIik7XFxuICAgICAgfSwgX2FkZEhlYWRlckJ1dHRvbkNsYXNzZXM6IGZ1bmN0aW9uIF9hZGRIZWFkZXJCdXR0b25DbGFzc2VzKCkge1xcbiAgICAgICAgdmFyIGEgPSB0aGlzLmVsZW1lbnQuY2hpbGRyZW4oXFxcImEsIGJ1dHRvblxcXCIpO3RoaXMubGVmdGJ0biA9IGEuaGFzQ2xhc3MoXFxcInVpLWJ0bi1sZWZ0XFxcIikgJiYgIWEuaGFzQ2xhc3MoXFxcInVpLXRvb2xiYXItYmFjay1idG5cXFwiKSwgdGhpcy5yaWdodGJ0biA9IGEuaGFzQ2xhc3MoXFxcInVpLWJ0bi1yaWdodFxcXCIpLCB0aGlzLmxlZnRidG4gPSB0aGlzLmxlZnRidG4gfHwgYS5lcSgwKS5ub3QoXFxcIi51aS1idG4tcmlnaHQsLnVpLXRvb2xiYXItYmFjay1idG5cXFwiKS5hZGRDbGFzcyhcXFwidWktYnRuLWxlZnRcXFwiKS5sZW5ndGgsIHRoaXMucmlnaHRidG4gPSB0aGlzLnJpZ2h0YnRuIHx8IGEuZXEoMSkuYWRkQ2xhc3MoXFxcInVpLWJ0bi1yaWdodFxcXCIpLmxlbmd0aDtcXG4gICAgICB9LCBfdXBkYXRlQmFja0J1dHRvbjogZnVuY3Rpb24gX3VwZGF0ZUJhY2tCdXR0b24oKSB7XFxuICAgICAgICB2YXIgYixcXG4gICAgICAgICAgICBjID0gdGhpcy5vcHRpb25zLFxcbiAgICAgICAgICAgIGQgPSBjLmJhY2tCdG5UaGVtZSB8fCBjLnRoZW1lO2IgPSB0aGlzLl9iYWNrQnV0dG9uID0gdGhpcy5fYmFja0J1dHRvbiB8fCB7fSwgdGhpcy5vcHRpb25zLmFkZEJhY2tCdG4gJiYgXFxcImhlYWRlclxcXCIgPT09IHRoaXMucm9sZSAmJiBhKFxcXCIudWktcGFnZVxcXCIpLmxlbmd0aCA+IDEgJiYgKHRoaXMucGFnZSA/IHRoaXMucGFnZVswXS5nZXRBdHRyaWJ1dGUoXFxcImRhdGEtXFxcIiArIGEubW9iaWxlLm5zICsgXFxcInVybFxcXCIpICE9PSBhLm1vYmlsZS5wYXRoLnN0cmlwSGFzaChsb2NhdGlvbi5oYXNoKSA6IGEubW9iaWxlLm5hdmlnYXRlICYmIGEubW9iaWxlLm5hdmlnYXRlLmhpc3RvcnkgJiYgYS5tb2JpbGUubmF2aWdhdGUuaGlzdG9yeS5hY3RpdmVJbmRleCA+IDApICYmICF0aGlzLmxlZnRidG4gPyBiLmF0dGFjaGVkIHx8ICh0aGlzLmJhY2tCdXR0b24gPSBiLmVsZW1lbnQgPSAoYi5lbGVtZW50IHx8IGEoXFxcIjxhIHJvbGU9J2J1dHRvbicgaHJlZj0namF2YXNjcmlwdDp2b2lkKDApOycgY2xhc3M9J3VpLWJ0biB1aS1jb3JuZXItYWxsIHVpLXNoYWRvdyB1aS1idG4tbGVmdCBcXFwiICsgKGQgPyBcXFwidWktYnRuLVxcXCIgKyBkICsgXFxcIiBcXFwiIDogXFxcIlxcXCIpICsgXFxcInVpLXRvb2xiYXItYmFjay1idG4gdWktaWNvbi1jYXJhdC1sIHVpLWJ0bi1pY29uLWxlZnQnIGRhdGEtXFxcIiArIGEubW9iaWxlLm5zICsgXFxcInJlbD0nYmFjayc+XFxcIiArIGMuYmFja0J0blRleHQgKyBcXFwiPC9hPlxcXCIpKS5wcmVwZW5kVG8odGhpcy5lbGVtZW50KSwgYi5hdHRhY2hlZCA9ICEwKSA6IGIuZWxlbWVudCAmJiAoYi5lbGVtZW50LmRldGFjaCgpLCBiLmF0dGFjaGVkID0gITEpO1xcbiAgICAgIH0sIF9hZGRIZWFkaW5nQ2xhc3NlczogZnVuY3Rpb24gX2FkZEhlYWRpbmdDbGFzc2VzKCkge1xcbiAgICAgICAgdGhpcy5lbGVtZW50LmNoaWxkcmVuKFxcXCJoMSwgaDIsIGgzLCBoNCwgaDUsIGg2XFxcIikuYWRkQ2xhc3MoXFxcInVpLXRpdGxlXFxcIikuYXR0cih7IHJvbGU6IFxcXCJoZWFkaW5nXFxcIiwgXFxcImFyaWEtbGV2ZWxcXFwiOiBcXFwiMVxcXCIgfSk7XFxuICAgICAgfSwgX2Rlc3Ryb3k6IGZ1bmN0aW9uIF9kZXN0cm95KCkge1xcbiAgICAgICAgdmFyIGE7dGhpcy5lbGVtZW50LmNoaWxkcmVuKFxcXCJoMSwgaDIsIGgzLCBoNCwgaDUsIGg2XFxcIikucmVtb3ZlQ2xhc3MoXFxcInVpLXRpdGxlXFxcIikucmVtb3ZlQXR0cihcXFwicm9sZVxcXCIpLnJlbW92ZUF0dHIoXFxcImFyaWEtbGV2ZWxcXFwiKSwgXFxcImhlYWRlclxcXCIgPT09IHRoaXMucm9sZSAmJiAodGhpcy5lbGVtZW50LmNoaWxkcmVuKFxcXCJhLCBidXR0b25cXFwiKS5yZW1vdmVDbGFzcyhcXFwidWktYnRuLWxlZnQgdWktYnRuLXJpZ2h0IHVpLWJ0biB1aS1zaGFkb3cgdWktY29ybmVyLWFsbFxcXCIpLCB0aGlzLmJhY2tCdXR0b24gJiYgdGhpcy5iYWNrQnV0dG9uLnJlbW92ZSgpKSwgYSA9IHRoaXMub3B0aW9ucy50aGVtZSA/IHRoaXMub3B0aW9ucy50aGVtZSA6IFxcXCJpbmhlcml0XFxcIiwgdGhpcy5lbGVtZW50LnJlbW92ZUNsYXNzKFxcXCJ1aS1iYXItXFxcIiArIGEpLCB0aGlzLmVsZW1lbnQucmVtb3ZlQ2xhc3MoXFxcInVpLVxcXCIgKyB0aGlzLnJvbGUpLnJlbW92ZUF0dHIoXFxcInJvbGVcXFwiKTtcXG4gICAgICB9IH0pO1xcbiAgfShhKSwgZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgYS53aWRnZXQoXFxcIm1vYmlsZS50b29sYmFyXFxcIiwgYS5tb2JpbGUudG9vbGJhciwgeyBvcHRpb25zOiB7IHBvc2l0aW9uOiBudWxsLCB2aXNpYmxlT25QYWdlU2hvdzogITAsIGRpc2FibGVQYWdlWm9vbTogITAsIHRyYW5zaXRpb246IFxcXCJzbGlkZVxcXCIsIGZ1bGxzY3JlZW46ICExLCB0YXBUb2dnbGU6ICEwLCB0YXBUb2dnbGVCbGFja2xpc3Q6IFxcXCJhLCBidXR0b24sIGlucHV0LCBzZWxlY3QsIHRleHRhcmVhLCAudWktaGVhZGVyLWZpeGVkLCAudWktZm9vdGVyLWZpeGVkLCAudWktZmxpcHN3aXRjaCwgLnVpLXBvcHVwLCAudWktcGFuZWwsIC51aS1wYW5lbC1kaXNtaXNzLW9wZW5cXFwiLCBoaWRlRHVyaW5nRm9jdXM6IFxcXCJpbnB1dCwgdGV4dGFyZWEsIHNlbGVjdFxcXCIsIHVwZGF0ZVBhZ2VQYWRkaW5nOiAhMCwgdHJhY2tQZXJzaXN0ZW50VG9vbGJhcnM6ICEwLCBzdXBwb3J0QmxhY2tsaXN0OiBmdW5jdGlvbiBzdXBwb3J0QmxhY2tsaXN0KCkge1xcbiAgICAgICAgICByZXR1cm4gIWEuc3VwcG9ydC5maXhlZFBvc2l0aW9uO1xcbiAgICAgICAgfSB9LCBfY3JlYXRlOiBmdW5jdGlvbiBfY3JlYXRlKCkge1xcbiAgICAgICAgdGhpcy5fc3VwZXIoKSwgdGhpcy5wYWdlY29udGFpbmVyID0gYShcXFwiOm1vYmlsZS1wYWdlY29udGFpbmVyXFxcIiksIFxcXCJmaXhlZFxcXCIgIT09IHRoaXMub3B0aW9ucy5wb3NpdGlvbiB8fCB0aGlzLm9wdGlvbnMuc3VwcG9ydEJsYWNrbGlzdCgpIHx8IHRoaXMuX21ha2VGaXhlZCgpO1xcbiAgICAgIH0sIF9tYWtlRml4ZWQ6IGZ1bmN0aW9uIF9tYWtlRml4ZWQoKSB7XFxuICAgICAgICB0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoXFxcInVpLVxcXCIgKyB0aGlzLnJvbGUgKyBcXFwiLWZpeGVkXFxcIiksIHRoaXMudXBkYXRlUGFnZVBhZGRpbmcoKSwgdGhpcy5fYWRkVHJhbnNpdGlvbkNsYXNzKCksIHRoaXMuX2JpbmRQYWdlRXZlbnRzKCksIHRoaXMuX2JpbmRUb2dnbGVIYW5kbGVycygpO1xcbiAgICAgIH0sIF9zZXRPcHRpb25zOiBmdW5jdGlvbiBfc2V0T3B0aW9ucyhjKSB7XFxuICAgICAgICBpZiAoXFxcImZpeGVkXFxcIiA9PT0gYy5wb3NpdGlvbiAmJiBcXFwiZml4ZWRcXFwiICE9PSB0aGlzLm9wdGlvbnMucG9zaXRpb24gJiYgdGhpcy5fbWFrZUZpeGVkKCksIFxcXCJmaXhlZFxcXCIgPT09IHRoaXMub3B0aW9ucy5wb3NpdGlvbiAmJiAhdGhpcy5vcHRpb25zLnN1cHBvcnRCbGFja2xpc3QoKSkge1xcbiAgICAgICAgICB2YXIgZCA9IHRoaXMucGFnZSA/IHRoaXMucGFnZSA6IGEoXFxcIi51aS1wYWdlLWFjdGl2ZVxcXCIpLmxlbmd0aCA+IDAgPyBhKFxcXCIudWktcGFnZS1hY3RpdmVcXFwiKSA6IGEoXFxcIi51aS1wYWdlXFxcIikuZXEoMCk7Yy5mdWxsc2NyZWVuICE9PSBiICYmIChjLmZ1bGxzY3JlZW4gPyAodGhpcy5lbGVtZW50LmFkZENsYXNzKFxcXCJ1aS1cXFwiICsgdGhpcy5yb2xlICsgXFxcIi1mdWxsc2NyZWVuXFxcIiksIGQuYWRkQ2xhc3MoXFxcInVpLXBhZ2UtXFxcIiArIHRoaXMucm9sZSArIFxcXCItZnVsbHNjcmVlblxcXCIpKSA6ICh0aGlzLmVsZW1lbnQucmVtb3ZlQ2xhc3MoXFxcInVpLVxcXCIgKyB0aGlzLnJvbGUgKyBcXFwiLWZ1bGxzY3JlZW5cXFwiKSwgZC5yZW1vdmVDbGFzcyhcXFwidWktcGFnZS1cXFwiICsgdGhpcy5yb2xlICsgXFxcIi1mdWxsc2NyZWVuXFxcIikuYWRkQ2xhc3MoXFxcInVpLXBhZ2UtXFxcIiArIHRoaXMucm9sZSArIFxcXCItZml4ZWRcXFwiKSkpO1xcbiAgICAgICAgfXRoaXMuX3N1cGVyKGMpO1xcbiAgICAgIH0sIF9hZGRUcmFuc2l0aW9uQ2xhc3M6IGZ1bmN0aW9uIF9hZGRUcmFuc2l0aW9uQ2xhc3MoKSB7XFxuICAgICAgICB2YXIgYSA9IHRoaXMub3B0aW9ucy50cmFuc2l0aW9uO2EgJiYgXFxcIm5vbmVcXFwiICE9PSBhICYmIChcXFwic2xpZGVcXFwiID09PSBhICYmIChhID0gdGhpcy5lbGVtZW50Lmhhc0NsYXNzKFxcXCJ1aS1oZWFkZXJcXFwiKSA/IFxcXCJzbGlkZWRvd25cXFwiIDogXFxcInNsaWRldXBcXFwiKSwgdGhpcy5lbGVtZW50LmFkZENsYXNzKGEpKTtcXG4gICAgICB9LCBfYmluZFBhZ2VFdmVudHM6IGZ1bmN0aW9uIF9iaW5kUGFnZUV2ZW50cygpIHtcXG4gICAgICAgIHZhciBhID0gdGhpcy5wYWdlID8gdGhpcy5lbGVtZW50LmNsb3Nlc3QoXFxcIi51aS1wYWdlXFxcIikgOiB0aGlzLmRvY3VtZW50O3RoaXMuX29uKGEsIHsgcGFnZWJlZm9yZXNob3c6IFxcXCJfaGFuZGxlUGFnZUJlZm9yZVNob3dcXFwiLCB3ZWJraXRBbmltYXRpb25TdGFydDogXFxcIl9oYW5kbGVBbmltYXRpb25TdGFydFxcXCIsIGFuaW1hdGlvbnN0YXJ0OiBcXFwiX2hhbmRsZUFuaW1hdGlvblN0YXJ0XFxcIiwgdXBkYXRlbGF5b3V0OiBcXFwiX2hhbmRsZUFuaW1hdGlvblN0YXJ0XFxcIiwgcGFnZXNob3c6IFxcXCJfaGFuZGxlUGFnZVNob3dcXFwiLCBwYWdlYmVmb3JlaGlkZTogXFxcIl9oYW5kbGVQYWdlQmVmb3JlSGlkZVxcXCIgfSk7XFxuICAgICAgfSwgX2hhbmRsZVBhZ2VCZWZvcmVTaG93OiBmdW5jdGlvbiBfaGFuZGxlUGFnZUJlZm9yZVNob3coKSB7XFxuICAgICAgICB2YXIgYiA9IHRoaXMub3B0aW9ucztiLmRpc2FibGVQYWdlWm9vbSAmJiBhLm1vYmlsZS56b29tLmRpc2FibGUoITApLCBiLnZpc2libGVPblBhZ2VTaG93IHx8IHRoaXMuaGlkZSghMCk7XFxuICAgICAgfSwgX2hhbmRsZUFuaW1hdGlvblN0YXJ0OiBmdW5jdGlvbiBfaGFuZGxlQW5pbWF0aW9uU3RhcnQoKSB7XFxuICAgICAgICB0aGlzLm9wdGlvbnMudXBkYXRlUGFnZVBhZGRpbmcgJiYgdGhpcy51cGRhdGVQYWdlUGFkZGluZyh0aGlzLnBhZ2UgPyB0aGlzLnBhZ2UgOiBcXFwiLnVpLXBhZ2UtYWN0aXZlXFxcIik7XFxuICAgICAgfSwgX2hhbmRsZVBhZ2VTaG93OiBmdW5jdGlvbiBfaGFuZGxlUGFnZVNob3coKSB7XFxuICAgICAgICB0aGlzLnVwZGF0ZVBhZ2VQYWRkaW5nKHRoaXMucGFnZSA/IHRoaXMucGFnZSA6IFxcXCIudWktcGFnZS1hY3RpdmVcXFwiKSwgdGhpcy5vcHRpb25zLnVwZGF0ZVBhZ2VQYWRkaW5nICYmIHRoaXMuX29uKHRoaXMud2luZG93LCB7IHRocm90dGxlZHJlc2l6ZTogXFxcInVwZGF0ZVBhZ2VQYWRkaW5nXFxcIiB9KTtcXG4gICAgICB9LCBfaGFuZGxlUGFnZUJlZm9yZUhpZGU6IGZ1bmN0aW9uIF9oYW5kbGVQYWdlQmVmb3JlSGlkZShiLCBjKSB7XFxuICAgICAgICB2YXIgZCxcXG4gICAgICAgICAgICBlLFxcbiAgICAgICAgICAgIGYsXFxuICAgICAgICAgICAgZyxcXG4gICAgICAgICAgICBoID0gdGhpcy5vcHRpb25zO2guZGlzYWJsZVBhZ2Vab29tICYmIGEubW9iaWxlLnpvb20uZW5hYmxlKCEwKSwgaC51cGRhdGVQYWdlUGFkZGluZyAmJiB0aGlzLl9vZmYodGhpcy53aW5kb3csIFxcXCJ0aHJvdHRsZWRyZXNpemVcXFwiKSwgaC50cmFja1BlcnNpc3RlbnRUb29sYmFycyAmJiAoZCA9IGEoXFxcIi51aS1mb290ZXItZml4ZWQ6anFtRGF0YShpZClcXFwiLCB0aGlzLnBhZ2UpLCBlID0gYShcXFwiLnVpLWhlYWRlci1maXhlZDpqcW1EYXRhKGlkKVxcXCIsIHRoaXMucGFnZSksIGYgPSBkLmxlbmd0aCAmJiBjLm5leHRQYWdlICYmIGEoXFxcIi51aS1mb290ZXItZml4ZWQ6anFtRGF0YShpZD0nXFxcIiArIGQuanFtRGF0YShcXFwiaWRcXFwiKSArIFxcXCInKVxcXCIsIGMubmV4dFBhZ2UpIHx8IGEoKSwgZyA9IGUubGVuZ3RoICYmIGMubmV4dFBhZ2UgJiYgYShcXFwiLnVpLWhlYWRlci1maXhlZDpqcW1EYXRhKGlkPSdcXFwiICsgZS5qcW1EYXRhKFxcXCJpZFxcXCIpICsgXFxcIicpXFxcIiwgYy5uZXh0UGFnZSkgfHwgYSgpLCAoZi5sZW5ndGggfHwgZy5sZW5ndGgpICYmIChmLmFkZChnKS5hcHBlbmRUbyhhLm1vYmlsZS5wYWdlQ29udGFpbmVyKSwgYy5uZXh0UGFnZS5vbmUoXFxcInBhZ2VzaG93XFxcIiwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBnLnByZXBlbmRUbyh0aGlzKSwgZi5hcHBlbmRUbyh0aGlzKTtcXG4gICAgICAgIH0pKSk7XFxuICAgICAgfSwgX3Zpc2libGU6ICEwLCB1cGRhdGVQYWdlUGFkZGluZzogZnVuY3Rpb24gdXBkYXRlUGFnZVBhZGRpbmcoYykge1xcbiAgICAgICAgdmFyIGQgPSB0aGlzLmVsZW1lbnQsXFxuICAgICAgICAgICAgZSA9IFxcXCJoZWFkZXJcXFwiID09PSB0aGlzLnJvbGUsXFxuICAgICAgICAgICAgZiA9IHBhcnNlRmxvYXQoZC5jc3MoZSA/IFxcXCJ0b3BcXFwiIDogXFxcImJvdHRvbVxcXCIpKTt0aGlzLm9wdGlvbnMuZnVsbHNjcmVlbiB8fCAoYyA9IGMgJiYgYy50eXBlID09PSBiICYmIGMgfHwgdGhpcy5wYWdlIHx8IGQuY2xvc2VzdChcXFwiLnVpLXBhZ2VcXFwiKSwgYyA9IHRoaXMucGFnZSA/IHRoaXMucGFnZSA6IFxcXCIudWktcGFnZS1hY3RpdmVcXFwiLCBhKGMpLmNzcyhcXFwicGFkZGluZy1cXFwiICsgKGUgPyBcXFwidG9wXFxcIiA6IFxcXCJib3R0b21cXFwiKSwgZC5vdXRlckhlaWdodCgpICsgZikpO1xcbiAgICAgIH0sIF91c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiBfdXNlVHJhbnNpdGlvbihiKSB7XFxuICAgICAgICB2YXIgYyA9IHRoaXMud2luZG93LFxcbiAgICAgICAgICAgIGQgPSB0aGlzLmVsZW1lbnQsXFxuICAgICAgICAgICAgZSA9IGMuc2Nyb2xsVG9wKCksXFxuICAgICAgICAgICAgZiA9IGQuaGVpZ2h0KCksXFxuICAgICAgICAgICAgZyA9IHRoaXMucGFnZSA/IGQuY2xvc2VzdChcXFwiLnVpLXBhZ2VcXFwiKS5oZWlnaHQoKSA6IGEoXFxcIi51aS1wYWdlLWFjdGl2ZVxcXCIpLmhlaWdodCgpLFxcbiAgICAgICAgICAgIGggPSBhLm1vYmlsZS5nZXRTY3JlZW5IZWlnaHQoKTtyZXR1cm4gIWIgJiYgKHRoaXMub3B0aW9ucy50cmFuc2l0aW9uICYmIFxcXCJub25lXFxcIiAhPT0gdGhpcy5vcHRpb25zLnRyYW5zaXRpb24gJiYgKFxcXCJoZWFkZXJcXFwiID09PSB0aGlzLnJvbGUgJiYgIXRoaXMub3B0aW9ucy5mdWxsc2NyZWVuICYmIGUgPiBmIHx8IFxcXCJmb290ZXJcXFwiID09PSB0aGlzLnJvbGUgJiYgIXRoaXMub3B0aW9ucy5mdWxsc2NyZWVuICYmIGcgLSBmID4gZSArIGgpIHx8IHRoaXMub3B0aW9ucy5mdWxsc2NyZWVuKTtcXG4gICAgICB9LCBzaG93OiBmdW5jdGlvbiBzaG93KGEpIHtcXG4gICAgICAgIHZhciBiID0gXFxcInVpLWZpeGVkLWhpZGRlblxcXCIsXFxuICAgICAgICAgICAgYyA9IHRoaXMuZWxlbWVudDt0aGlzLl91c2VUcmFuc2l0aW9uKGEpID8gYy5yZW1vdmVDbGFzcyhcXFwib3V0IFxcXCIgKyBiKS5hZGRDbGFzcyhcXFwiaW5cXFwiKS5hbmltYXRpb25Db21wbGV0ZShmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIGMucmVtb3ZlQ2xhc3MoXFxcImluXFxcIik7XFxuICAgICAgICB9KSA6IGMucmVtb3ZlQ2xhc3MoYiksIHRoaXMuX3Zpc2libGUgPSAhMDtcXG4gICAgICB9LCBoaWRlOiBmdW5jdGlvbiBoaWRlKGEpIHtcXG4gICAgICAgIHZhciBiID0gXFxcInVpLWZpeGVkLWhpZGRlblxcXCIsXFxuICAgICAgICAgICAgYyA9IHRoaXMuZWxlbWVudCxcXG4gICAgICAgICAgICBkID0gXFxcIm91dFxcXCIgKyAoXFxcInNsaWRlXFxcIiA9PT0gdGhpcy5vcHRpb25zLnRyYW5zaXRpb24gPyBcXFwiIHJldmVyc2VcXFwiIDogXFxcIlxcXCIpO3RoaXMuX3VzZVRyYW5zaXRpb24oYSkgPyBjLmFkZENsYXNzKGQpLnJlbW92ZUNsYXNzKFxcXCJpblxcXCIpLmFuaW1hdGlvbkNvbXBsZXRlKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgYy5hZGRDbGFzcyhiKS5yZW1vdmVDbGFzcyhkKTtcXG4gICAgICAgIH0pIDogYy5hZGRDbGFzcyhiKS5yZW1vdmVDbGFzcyhkKSwgdGhpcy5fdmlzaWJsZSA9ICExO1xcbiAgICAgIH0sIHRvZ2dsZTogZnVuY3Rpb24gdG9nZ2xlKCkge1xcbiAgICAgICAgdGhpc1t0aGlzLl92aXNpYmxlID8gXFxcImhpZGVcXFwiIDogXFxcInNob3dcXFwiXSgpO1xcbiAgICAgIH0sIF9iaW5kVG9nZ2xlSGFuZGxlcnM6IGZ1bmN0aW9uIF9iaW5kVG9nZ2xlSGFuZGxlcnMoKSB7XFxuICAgICAgICB2YXIgYixcXG4gICAgICAgICAgICBjLFxcbiAgICAgICAgICAgIGQgPSB0aGlzLFxcbiAgICAgICAgICAgIGUgPSBkLm9wdGlvbnMsXFxuICAgICAgICAgICAgZiA9ICEwLFxcbiAgICAgICAgICAgIGcgPSB0aGlzLnBhZ2UgPyB0aGlzLnBhZ2UgOiBhKFxcXCIudWktcGFnZVxcXCIpO2cuYmluZChcXFwidmNsaWNrXFxcIiwgZnVuY3Rpb24gKGIpIHtcXG4gICAgICAgICAgZS50YXBUb2dnbGUgJiYgIWEoYi50YXJnZXQpLmNsb3Nlc3QoZS50YXBUb2dnbGVCbGFja2xpc3QpLmxlbmd0aCAmJiBkLnRvZ2dsZSgpO1xcbiAgICAgICAgfSkuYmluZChcXFwiZm9jdXNpbiBmb2N1c291dFxcXCIsIGZ1bmN0aW9uIChnKSB7XFxuICAgICAgICAgIHNjcmVlbi53aWR0aCA8IDEwMjUgJiYgYShnLnRhcmdldCkuaXMoZS5oaWRlRHVyaW5nRm9jdXMpICYmICFhKGcudGFyZ2V0KS5jbG9zZXN0KFxcXCIudWktaGVhZGVyLWZpeGVkLCAudWktZm9vdGVyLWZpeGVkXFxcIikubGVuZ3RoICYmIChcXFwiZm9jdXNvdXRcXFwiICE9PSBnLnR5cGUgfHwgZiA/IFxcXCJmb2N1c2luXFxcIiA9PT0gZy50eXBlICYmIGYgJiYgKGNsZWFyVGltZW91dChiKSwgZiA9ICExLCBjID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgZC5oaWRlKCk7XFxuICAgICAgICAgIH0sIDApKSA6IChmID0gITAsIGNsZWFyVGltZW91dChjKSwgYiA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIGQuc2hvdygpO1xcbiAgICAgICAgICB9LCAwKSkpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfSwgX3NldFJlbGF0aXZlOiBmdW5jdGlvbiBfc2V0UmVsYXRpdmUoKSB7XFxuICAgICAgICBcXFwiZml4ZWRcXFwiICE9PSB0aGlzLm9wdGlvbnMucG9zaXRpb24gJiYgYShcXFwiW2RhdGEtXFxcIiArIGEubW9iaWxlLm5zICsgXFxcInJvbGU9J3BhZ2UnXVxcXCIpLmNzcyh7IHBvc2l0aW9uOiBcXFwicmVsYXRpdmVcXFwiIH0pO1xcbiAgICAgIH0sIF9kZXN0cm95OiBmdW5jdGlvbiBfZGVzdHJveSgpIHtcXG4gICAgICAgIHZhciBiLFxcbiAgICAgICAgICAgIGMsXFxuICAgICAgICAgICAgZCxcXG4gICAgICAgICAgICBlLFxcbiAgICAgICAgICAgIGYsXFxuICAgICAgICAgICAgZyA9IHRoaXMucGFnZWNvbnRhaW5lci5wYWdlY29udGFpbmVyKFxcXCJnZXRBY3RpdmVQYWdlXFxcIik7dGhpcy5fc3VwZXIoKSwgXFxcImZpeGVkXFxcIiA9PT0gdGhpcy5vcHRpb25zLnBvc2l0aW9uICYmIChkID0gYShcXFwiYm9keT4udWktXFxcIiArIHRoaXMucm9sZSArIFxcXCItZml4ZWRcXFwiKS5hZGQoZy5maW5kKFxcXCIudWktXFxcIiArIHRoaXMub3B0aW9ucy5yb2xlICsgXFxcIi1maXhlZFxcXCIpKS5ub3QodGhpcy5lbGVtZW50KS5sZW5ndGggPiAwLCBmID0gYShcXFwiYm9keT4udWktXFxcIiArIHRoaXMucm9sZSArIFxcXCItZml4ZWRcXFwiKS5hZGQoZy5maW5kKFxcXCIudWktXFxcIiArIHRoaXMub3B0aW9ucy5yb2xlICsgXFxcIi1mdWxsc2NyZWVuXFxcIikpLm5vdCh0aGlzLmVsZW1lbnQpLmxlbmd0aCA+IDAsIGMgPSBcXFwidWktaGVhZGVyLWZpeGVkIHVpLWZvb3Rlci1maXhlZCB1aS1oZWFkZXItZnVsbHNjcmVlbiBpbiBvdXQgdWktZm9vdGVyLWZ1bGxzY3JlZW4gZmFkZSBzbGlkZWRvd24gc2xpZGV1cCB1aS1maXhlZC1oaWRkZW5cXFwiLCB0aGlzLmVsZW1lbnQucmVtb3ZlQ2xhc3MoYyksIGYgfHwgKGIgPSBcXFwidWktcGFnZS1cXFwiICsgdGhpcy5yb2xlICsgXFxcIi1mdWxsc2NyZWVuXFxcIiksIGQgfHwgKGUgPSBcXFwiaGVhZGVyXFxcIiA9PT0gdGhpcy5yb2xlLCBiICs9IFxcXCIgdWktcGFnZS1cXFwiICsgdGhpcy5yb2xlICsgXFxcIi1maXhlZFxcXCIsIGcuY3NzKFxcXCJwYWRkaW5nLVxcXCIgKyAoZSA/IFxcXCJ0b3BcXFwiIDogXFxcImJvdHRvbVxcXCIpLCBcXFwiXFxcIikpLCBnLnJlbW92ZUNsYXNzKGIpKTtcXG4gICAgICB9IH0pO1xcbiAgfShhKSwgZnVuY3Rpb24gKGEpIHtcXG4gICAgYS53aWRnZXQoXFxcIm1vYmlsZS50b29sYmFyXFxcIiwgYS5tb2JpbGUudG9vbGJhciwgeyBfbWFrZUZpeGVkOiBmdW5jdGlvbiBfbWFrZUZpeGVkKCkge1xcbiAgICAgICAgdGhpcy5fc3VwZXIoKSwgdGhpcy5fd29ya2Fyb3VuZHMoKTtcXG4gICAgICB9LCBfd29ya2Fyb3VuZHM6IGZ1bmN0aW9uIF93b3JrYXJvdW5kcygpIHtcXG4gICAgICAgIHZhciBhID0gbmF2aWdhdG9yLnVzZXJBZ2VudCxcXG4gICAgICAgICAgICBiID0gbmF2aWdhdG9yLnBsYXRmb3JtLFxcbiAgICAgICAgICAgIGMgPSBhLm1hdGNoKC9BcHBsZVdlYktpdFxcXFwvKFswLTldKykvKSxcXG4gICAgICAgICAgICBkID0gISFjICYmIGNbMV0sXFxuICAgICAgICAgICAgZSA9IG51bGwsXFxuICAgICAgICAgICAgZiA9IHRoaXM7aWYgKGIuaW5kZXhPZihcXFwiaVBob25lXFxcIikgPiAtMSB8fCBiLmluZGV4T2YoXFxcImlQYWRcXFwiKSA+IC0xIHx8IGIuaW5kZXhPZihcXFwiaVBvZFxcXCIpID4gLTEpIGUgPSBcXFwiaW9zXFxcIjtlbHNlIHtcXG4gICAgICAgICAgaWYgKCEoYS5pbmRleE9mKFxcXCJBbmRyb2lkXFxcIikgPiAtMSkpIHJldHVybjtlID0gXFxcImFuZHJvaWRcXFwiO1xcbiAgICAgICAgfWlmIChcXFwiaW9zXFxcIiA9PT0gZSkgZi5fYmluZFNjcm9sbFdvcmthcm91bmQoKTtlbHNlIHtcXG4gICAgICAgICAgaWYgKCEoXFxcImFuZHJvaWRcXFwiID09PSBlICYmIGQgJiYgNTM0ID4gZCkpIHJldHVybjtmLl9iaW5kU2Nyb2xsV29ya2Fyb3VuZCgpLCBmLl9iaW5kTGlzdFRodW1iV29ya2Fyb3VuZCgpO1xcbiAgICAgICAgfVxcbiAgICAgIH0sIF92aWV3cG9ydE9mZnNldDogZnVuY3Rpb24gX3ZpZXdwb3J0T2Zmc2V0KCkge1xcbiAgICAgICAgdmFyIGEgPSB0aGlzLmVsZW1lbnQsXFxuICAgICAgICAgICAgYiA9IGEuaGFzQ2xhc3MoXFxcInVpLWhlYWRlclxcXCIpLFxcbiAgICAgICAgICAgIGMgPSBNYXRoLmFicyhhLm9mZnNldCgpLnRvcCAtIHRoaXMud2luZG93LnNjcm9sbFRvcCgpKTtyZXR1cm4gYiB8fCAoYyA9IE1hdGgucm91bmQoYyAtIHRoaXMud2luZG93LmhlaWdodCgpICsgYS5vdXRlckhlaWdodCgpKSAtIDYwKSwgYztcXG4gICAgICB9LCBfYmluZFNjcm9sbFdvcmthcm91bmQ6IGZ1bmN0aW9uIF9iaW5kU2Nyb2xsV29ya2Fyb3VuZCgpIHtcXG4gICAgICAgIHZhciBhID0gdGhpczt0aGlzLl9vbih0aGlzLndpbmRvdywgeyBzY3JvbGxzdG9wOiBmdW5jdGlvbiBzY3JvbGxzdG9wKCkge1xcbiAgICAgICAgICAgIHZhciBiID0gYS5fdmlld3BvcnRPZmZzZXQoKTtiID4gMiAmJiBhLl92aXNpYmxlICYmIGEuX3RyaWdnZXJSZWRyYXcoKTtcXG4gICAgICAgICAgfSB9KTtcXG4gICAgICB9LCBfYmluZExpc3RUaHVtYldvcmthcm91bmQ6IGZ1bmN0aW9uIF9iaW5kTGlzdFRodW1iV29ya2Fyb3VuZCgpIHtcXG4gICAgICAgIHRoaXMuZWxlbWVudC5jbG9zZXN0KFxcXCIudWktcGFnZVxcXCIpLmFkZENsYXNzKFxcXCJ1aS1hbmRyb2lkLTJ4LWZpeGVkXFxcIik7XFxuICAgICAgfSwgX3RyaWdnZXJSZWRyYXc6IGZ1bmN0aW9uIF90cmlnZ2VyUmVkcmF3KCkge1xcbiAgICAgICAgdmFyIGIgPSBwYXJzZUZsb2F0KGEoXFxcIi51aS1wYWdlLWFjdGl2ZVxcXCIpLmNzcyhcXFwicGFkZGluZy1ib3R0b21cXFwiKSk7YShcXFwiLnVpLXBhZ2UtYWN0aXZlXFxcIikuY3NzKFxcXCJwYWRkaW5nLWJvdHRvbVxcXCIsIGIgKyAxICsgXFxcInB4XFxcIiksIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBhKFxcXCIudWktcGFnZS1hY3RpdmVcXFwiKS5jc3MoXFxcInBhZGRpbmctYm90dG9tXFxcIiwgYiArIFxcXCJweFxcXCIpO1xcbiAgICAgICAgfSwgMCk7XFxuICAgICAgfSwgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcXG4gICAgICAgIHRoaXMuX3N1cGVyKCksIHRoaXMuZWxlbWVudC5jbG9zZXN0KFxcXCIudWktcGFnZS1hY3RpdmVcXFwiKS5yZW1vdmVDbGFzcyhcXFwidWktYW5kcm9pZC0yeC1maXhcXFwiKTtcXG4gICAgICB9IH0pO1xcbiAgfShhKSwgZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgZnVuY3Rpb24gYygpIHtcXG4gICAgICB2YXIgYSA9IGUuY2xvbmUoKSxcXG4gICAgICAgICAgYiA9IGEuZXEoMCksXFxuICAgICAgICAgIGMgPSBhLmVxKDEpLFxcbiAgICAgICAgICBkID0gYy5jaGlsZHJlbigpO3JldHVybiB7IGFyRWxzOiBjLmFkZChiKSwgZ2Q6IGIsIGN0OiBjLCBhcjogZCB9O1xcbiAgICB9dmFyIGQgPSBhLm1vYmlsZS5icm93c2VyLm9sZElFICYmIGEubW9iaWxlLmJyb3dzZXIub2xkSUUgPD0gOCxcXG4gICAgICAgIGUgPSBhKFxcXCI8ZGl2IGNsYXNzPSd1aS1wb3B1cC1hcnJvdy1ndWlkZSc+PC9kaXY+PGRpdiBjbGFzcz0ndWktcG9wdXAtYXJyb3ctY29udGFpbmVyXFxcIiArIChkID8gXFxcIiBpZVxcXCIgOiBcXFwiXFxcIikgKyBcXFwiJz48ZGl2IGNsYXNzPSd1aS1wb3B1cC1hcnJvdyc+PC9kaXY+PC9kaXY+XFxcIik7YS53aWRnZXQoXFxcIm1vYmlsZS5wb3B1cFxcXCIsIGEubW9iaWxlLnBvcHVwLCB7IG9wdGlvbnM6IHsgYXJyb3c6IFxcXCJcXFwiIH0sIF9jcmVhdGU6IGZ1bmN0aW9uIF9jcmVhdGUoKSB7XFxuICAgICAgICB2YXIgYSxcXG4gICAgICAgICAgICBiID0gdGhpcy5fc3VwZXIoKTtyZXR1cm4gdGhpcy5vcHRpb25zLmFycm93ICYmICh0aGlzLl91aS5hcnJvdyA9IGEgPSB0aGlzLl9hZGRBcnJvdygpKSwgYjtcXG4gICAgICB9LCBfYWRkQXJyb3c6IGZ1bmN0aW9uIF9hZGRBcnJvdygpIHtcXG4gICAgICAgIHZhciBhLFxcbiAgICAgICAgICAgIGIgPSB0aGlzLm9wdGlvbnMsXFxuICAgICAgICAgICAgZCA9IGMoKTtyZXR1cm4gYSA9IHRoaXMuX3RoZW1lQ2xhc3NGcm9tT3B0aW9uKFxcXCJ1aS1ib2R5LVxcXCIsIGIudGhlbWUpLCBkLmFyLmFkZENsYXNzKGEgKyAoYi5zaGFkb3cgPyBcXFwiIHVpLW92ZXJsYXktc2hhZG93XFxcIiA6IFxcXCJcXFwiKSksIGQuYXJFbHMuaGlkZSgpLmFwcGVuZFRvKHRoaXMuZWxlbWVudCksIGQ7XFxuICAgICAgfSwgX3VuZW5oYW5jZTogZnVuY3Rpb24gX3VuZW5oYW5jZSgpIHtcXG4gICAgICAgIHZhciBhID0gdGhpcy5fdWkuYXJyb3c7cmV0dXJuIGEgJiYgYS5hckVscy5yZW1vdmUoKSwgdGhpcy5fc3VwZXIoKTtcXG4gICAgICB9LCBfdHJ5QW5BcnJvdzogZnVuY3Rpb24gX3RyeUFuQXJyb3coYSwgYiwgYywgZCwgZSkge1xcbiAgICAgICAgdmFyIGYsXFxuICAgICAgICAgICAgZyxcXG4gICAgICAgICAgICBoLFxcbiAgICAgICAgICAgIGkgPSB7fSxcXG4gICAgICAgICAgICBqID0ge307cmV0dXJuIGQuYXJGdWxsW2EuZGltS2V5XSA+IGQuZ3VpZGVEaW1zW2EuZGltS2V5XSA/IGUgOiAoaVthLmZzdF0gPSBjW2EuZnN0XSArIChkLmFySGFsZlthLm9EaW1LZXldICsgZC5tZW51SGFsZlthLm9EaW1LZXldKSAqIGEub2Zmc2V0RmFjdG9yIC0gZC5jb250ZW50Qm94W2EuZnN0XSArIChkLmNsYW1wSW5mby5tZW51U2l6ZVthLm9EaW1LZXldIC0gZC5jb250ZW50Qm94W2Eub0RpbUtleV0pICogYS5hcnJvd09mZnNldEZhY3RvciwgaVthLnNuZF0gPSBjW2Euc25kXSwgZiA9IGQucmVzdWx0IHx8IHRoaXMuX2NhbGN1bGF0ZUZpbmFsTG9jYXRpb24oaSwgZC5jbGFtcEluZm8pLCBnID0geyB4OiBmLmxlZnQsIHk6IGYudG9wIH0sIGpbYS5mc3RdID0gZ1thLmZzdF0gKyBkLmNvbnRlbnRCb3hbYS5mc3RdICsgYS50aXBPZmZzZXQsIGpbYS5zbmRdID0gTWF0aC5tYXgoZlthLnByb3BdICsgZC5ndWlkZU9mZnNldFthLnByb3BdICsgZC5hckhhbGZbYS5kaW1LZXldLCBNYXRoLm1pbihmW2EucHJvcF0gKyBkLmd1aWRlT2Zmc2V0W2EucHJvcF0gKyBkLmd1aWRlRGltc1thLmRpbUtleV0gLSBkLmFySGFsZlthLmRpbUtleV0sIGNbYS5zbmRdKSksIGggPSBNYXRoLmFicyhjLnggLSBqLngpICsgTWF0aC5hYnMoYy55IC0gai55KSwgKCFlIHx8IGggPCBlLmRpZmYpICYmIChqW2Euc25kXSAtPSBkLmFySGFsZlthLmRpbUtleV0gKyBmW2EucHJvcF0gKyBkLmNvbnRlbnRCb3hbYS5zbmRdLCBlID0geyBkaXI6IGIsIGRpZmY6IGgsIHJlc3VsdDogZiwgcG9zUHJvcDogYS5wcm9wLCBwb3NWYWw6IGpbYS5zbmRdIH0pLCBlKTtcXG4gICAgICB9LCBfZ2V0UGxhY2VtZW50U3RhdGU6IGZ1bmN0aW9uIF9nZXRQbGFjZW1lbnRTdGF0ZShhKSB7XFxuICAgICAgICB2YXIgYixcXG4gICAgICAgICAgICBjLFxcbiAgICAgICAgICAgIGQgPSB0aGlzLl91aS5hcnJvdyxcXG4gICAgICAgICAgICBlID0geyBjbGFtcEluZm86IHRoaXMuX2NsYW1wUG9wdXBXaWR0aCghYSksIGFyRnVsbDogeyBjeDogZC5jdC53aWR0aCgpLCBjeTogZC5jdC5oZWlnaHQoKSB9LCBndWlkZURpbXM6IHsgY3g6IGQuZ2Qud2lkdGgoKSwgY3k6IGQuZ2QuaGVpZ2h0KCkgfSwgZ3VpZGVPZmZzZXQ6IGQuZ2Qub2Zmc2V0KCkgfTtyZXR1cm4gYiA9IHRoaXMuZWxlbWVudC5vZmZzZXQoKSwgZC5nZC5jc3MoeyBsZWZ0OiAwLCB0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDAgfSksIGMgPSBkLmdkLm9mZnNldCgpLCBlLmNvbnRlbnRCb3ggPSB7IHg6IGMubGVmdCAtIGIubGVmdCwgeTogYy50b3AgLSBiLnRvcCwgY3g6IGQuZ2Qud2lkdGgoKSwgY3k6IGQuZ2QuaGVpZ2h0KCkgfSwgZC5nZC5yZW1vdmVBdHRyKFxcXCJzdHlsZVxcXCIpLCBlLmd1aWRlT2Zmc2V0ID0geyBsZWZ0OiBlLmd1aWRlT2Zmc2V0LmxlZnQgLSBiLmxlZnQsIHRvcDogZS5ndWlkZU9mZnNldC50b3AgLSBiLnRvcCB9LCBlLmFySGFsZiA9IHsgY3g6IGUuYXJGdWxsLmN4IC8gMiwgY3k6IGUuYXJGdWxsLmN5IC8gMiB9LCBlLm1lbnVIYWxmID0geyBjeDogZS5jbGFtcEluZm8ubWVudVNpemUuY3ggLyAyLCBjeTogZS5jbGFtcEluZm8ubWVudVNpemUuY3kgLyAyIH0sIGU7XFxuICAgICAgfSwgX3BsYWNlbWVudENvb3JkczogZnVuY3Rpb24gX3BsYWNlbWVudENvb3JkcyhiKSB7XFxuICAgICAgICB2YXIgYyxcXG4gICAgICAgICAgICBlLFxcbiAgICAgICAgICAgIGYsXFxuICAgICAgICAgICAgZyxcXG4gICAgICAgICAgICBoLFxcbiAgICAgICAgICAgIGkgPSB0aGlzLm9wdGlvbnMuYXJyb3csXFxuICAgICAgICAgICAgaiA9IHRoaXMuX3VpLmFycm93O3JldHVybiBqID8gKGouYXJFbHMuc2hvdygpLCBoID0ge30sIGMgPSB0aGlzLl9nZXRQbGFjZW1lbnRTdGF0ZSghMCksIGYgPSB7IGw6IHsgZnN0OiBcXFwieFxcXCIsIHNuZDogXFxcInlcXFwiLCBwcm9wOiBcXFwidG9wXFxcIiwgZGltS2V5OiBcXFwiY3lcXFwiLCBvRGltS2V5OiBcXFwiY3hcXFwiLCBvZmZzZXRGYWN0b3I6IDEsIHRpcE9mZnNldDogLWMuYXJIYWxmLmN4LCBhcnJvd09mZnNldEZhY3RvcjogMCB9LCByOiB7IGZzdDogXFxcInhcXFwiLCBzbmQ6IFxcXCJ5XFxcIiwgcHJvcDogXFxcInRvcFxcXCIsIGRpbUtleTogXFxcImN5XFxcIiwgb0RpbUtleTogXFxcImN4XFxcIiwgb2Zmc2V0RmFjdG9yOiAtMSwgdGlwT2Zmc2V0OiBjLmFySGFsZi5jeCArIGMuY29udGVudEJveC5jeCwgYXJyb3dPZmZzZXRGYWN0b3I6IDEgfSwgYjogeyBmc3Q6IFxcXCJ5XFxcIiwgc25kOiBcXFwieFxcXCIsIHByb3A6IFxcXCJsZWZ0XFxcIiwgZGltS2V5OiBcXFwiY3hcXFwiLCBvRGltS2V5OiBcXFwiY3lcXFwiLCBvZmZzZXRGYWN0b3I6IC0xLCB0aXBPZmZzZXQ6IGMuYXJIYWxmLmN5ICsgYy5jb250ZW50Qm94LmN5LCBhcnJvd09mZnNldEZhY3RvcjogMSB9LCB0OiB7IGZzdDogXFxcInlcXFwiLCBzbmQ6IFxcXCJ4XFxcIiwgcHJvcDogXFxcImxlZnRcXFwiLCBkaW1LZXk6IFxcXCJjeFxcXCIsIG9EaW1LZXk6IFxcXCJjeVxcXCIsIG9mZnNldEZhY3RvcjogMSwgdGlwT2Zmc2V0OiAtYy5hckhhbGYuY3ksIGFycm93T2Zmc2V0RmFjdG9yOiAwIH0gfSwgYS5lYWNoKChpID09PSAhMCA/IFxcXCJsLHQscixiXFxcIiA6IGkpLnNwbGl0KFxcXCIsXFxcIiksIGEucHJveHkoZnVuY3Rpb24gKGEsIGQpIHtcXG4gICAgICAgICAgZSA9IHRoaXMuX3RyeUFuQXJyb3coZltkXSwgZCwgYiwgYywgZSk7XFxuICAgICAgICB9LCB0aGlzKSksIGUgPyAoai5jdC5yZW1vdmVDbGFzcyhcXFwidWktcG9wdXAtYXJyb3ctbCB1aS1wb3B1cC1hcnJvdy10IHVpLXBvcHVwLWFycm93LXIgdWktcG9wdXAtYXJyb3ctYlxcXCIpLmFkZENsYXNzKFxcXCJ1aS1wb3B1cC1hcnJvdy1cXFwiICsgZS5kaXIpLnJlbW92ZUF0dHIoXFxcInN0eWxlXFxcIikuY3NzKGUucG9zUHJvcCwgZS5wb3NWYWwpLnNob3coKSwgZCB8fCAoZyA9IHRoaXMuZWxlbWVudC5vZmZzZXQoKSwgaFtmW2UuZGlyXS5mc3RdID0gai5jdC5vZmZzZXQoKSwgaFtmW2UuZGlyXS5zbmRdID0geyBsZWZ0OiBnLmxlZnQgKyBjLmNvbnRlbnRCb3gueCwgdG9wOiBnLnRvcCArIGMuY29udGVudEJveC55IH0pLCBlLnJlc3VsdCkgOiAoai5hckVscy5oaWRlKCksIHRoaXMuX3N1cGVyKGIpKSkgOiB0aGlzLl9zdXBlcihiKTtcXG4gICAgICB9LCBfc2V0T3B0aW9uczogZnVuY3Rpb24gX3NldE9wdGlvbnMoYSkge1xcbiAgICAgICAgdmFyIGMsXFxuICAgICAgICAgICAgZCA9IHRoaXMub3B0aW9ucy50aGVtZSxcXG4gICAgICAgICAgICBlID0gdGhpcy5fdWkuYXJyb3csXFxuICAgICAgICAgICAgZiA9IHRoaXMuX3N1cGVyKGEpO2lmIChhLmFycm93ICE9PSBiKSB7XFxuICAgICAgICAgIGlmICghZSAmJiBhLmFycm93KSByZXR1cm4gdm9pZCAodGhpcy5fdWkuYXJyb3cgPSB0aGlzLl9hZGRBcnJvdygpKTtlICYmICFhLmFycm93ICYmIChlLmFyRWxzLnJlbW92ZSgpLCB0aGlzLl91aS5hcnJvdyA9IG51bGwpO1xcbiAgICAgICAgfXJldHVybiBlID0gdGhpcy5fdWkuYXJyb3csIGUgJiYgKGEudGhlbWUgIT09IGIgJiYgKGQgPSB0aGlzLl90aGVtZUNsYXNzRnJvbU9wdGlvbihcXFwidWktYm9keS1cXFwiLCBkKSwgYyA9IHRoaXMuX3RoZW1lQ2xhc3NGcm9tT3B0aW9uKFxcXCJ1aS1ib2R5LVxcXCIsIGEudGhlbWUpLCBlLmFyLnJlbW92ZUNsYXNzKGQpLmFkZENsYXNzKGMpKSwgYS5zaGFkb3cgIT09IGIgJiYgZS5hci50b2dnbGVDbGFzcyhcXFwidWktb3ZlcmxheS1zaGFkb3dcXFwiLCBhLnNoYWRvdykpLCBmO1xcbiAgICAgIH0sIF9kZXN0cm95OiBmdW5jdGlvbiBfZGVzdHJveSgpIHtcXG4gICAgICAgIHZhciBhID0gdGhpcy5fdWkuYXJyb3c7cmV0dXJuIGEgJiYgYS5hckVscy5yZW1vdmUoKSwgdGhpcy5fc3VwZXIoKTtcXG4gICAgICB9IH0pO1xcbiAgfShhKSwgZnVuY3Rpb24gKGEsIGMpIHtcXG4gICAgYS53aWRnZXQoXFxcIm1vYmlsZS5wYW5lbFxcXCIsIHsgb3B0aW9uczogeyBjbGFzc2VzOiB7IHBhbmVsOiBcXFwidWktcGFuZWxcXFwiLCBwYW5lbE9wZW46IFxcXCJ1aS1wYW5lbC1vcGVuXFxcIiwgcGFuZWxDbG9zZWQ6IFxcXCJ1aS1wYW5lbC1jbG9zZWRcXFwiLCBwYW5lbEZpeGVkOiBcXFwidWktcGFuZWwtZml4ZWRcXFwiLCBwYW5lbElubmVyOiBcXFwidWktcGFuZWwtaW5uZXJcXFwiLCBtb2RhbDogXFxcInVpLXBhbmVsLWRpc21pc3NcXFwiLCBtb2RhbE9wZW46IFxcXCJ1aS1wYW5lbC1kaXNtaXNzLW9wZW5cXFwiLCBwYWdlQ29udGFpbmVyOiBcXFwidWktcGFuZWwtcGFnZS1jb250YWluZXJcXFwiLCBwYWdlV3JhcHBlcjogXFxcInVpLXBhbmVsLXdyYXBwZXJcXFwiLCBwYWdlRml4ZWRUb29sYmFyOiBcXFwidWktcGFuZWwtZml4ZWQtdG9vbGJhclxcXCIsIHBhZ2VDb250ZW50UHJlZml4OiBcXFwidWktcGFuZWwtcGFnZS1jb250ZW50XFxcIiwgYW5pbWF0ZTogXFxcInVpLXBhbmVsLWFuaW1hdGVcXFwiIH0sIGFuaW1hdGU6ICEwLCB0aGVtZTogbnVsbCwgcG9zaXRpb246IFxcXCJsZWZ0XFxcIiwgZGlzbWlzc2libGU6ICEwLCBkaXNwbGF5OiBcXFwicmV2ZWFsXFxcIiwgc3dpcGVDbG9zZTogITAsIHBvc2l0aW9uRml4ZWQ6ICExIH0sIF9jbG9zZUxpbms6IG51bGwsIF9wYXJlbnRQYWdlOiBudWxsLCBfcGFnZTogbnVsbCwgX21vZGFsOiBudWxsLCBfcGFuZWxJbm5lcjogbnVsbCwgX3dyYXBwZXI6IG51bGwsIF9maXhlZFRvb2xiYXJzOiBudWxsLCBfY3JlYXRlOiBmdW5jdGlvbiBfY3JlYXRlKCkge1xcbiAgICAgICAgdmFyIGIgPSB0aGlzLmVsZW1lbnQsXFxuICAgICAgICAgICAgYyA9IGIuY2xvc2VzdChcXFwiLnVpLXBhZ2UsIDpqcW1EYXRhKHJvbGU9J3BhZ2UnKVxcXCIpO2EuZXh0ZW5kKHRoaXMsIHsgX2Nsb3NlTGluazogYi5maW5kKFxcXCI6anFtRGF0YShyZWw9J2Nsb3NlJylcXFwiKSwgX3BhcmVudFBhZ2U6IGMubGVuZ3RoID4gMCA/IGMgOiAhMSwgX29wZW5lZFBhZ2U6IG51bGwsIF9wYWdlOiB0aGlzLl9nZXRQYWdlLCBfcGFuZWxJbm5lcjogdGhpcy5fZ2V0UGFuZWxJbm5lcigpLCBfZml4ZWRUb29sYmFyczogdGhpcy5fZ2V0Rml4ZWRUb29sYmFycyB9KSwgXFxcIm92ZXJsYXlcXFwiICE9PSB0aGlzLm9wdGlvbnMuZGlzcGxheSAmJiB0aGlzLl9nZXRXcmFwcGVyKCksIHRoaXMuX2FkZFBhbmVsQ2xhc3NlcygpLCBhLnN1cHBvcnQuY3NzVHJhbnNmb3JtM2QgJiYgdGhpcy5vcHRpb25zLmFuaW1hdGUgJiYgdGhpcy5lbGVtZW50LmFkZENsYXNzKHRoaXMub3B0aW9ucy5jbGFzc2VzLmFuaW1hdGUpLCB0aGlzLl9iaW5kVXBkYXRlTGF5b3V0KCksIHRoaXMuX2JpbmRDbG9zZUV2ZW50cygpLCB0aGlzLl9iaW5kTGlua0xpc3RlbmVycygpLCB0aGlzLl9iaW5kUGFnZUV2ZW50cygpLCB0aGlzLm9wdGlvbnMuZGlzbWlzc2libGUgJiYgdGhpcy5fY3JlYXRlTW9kYWwoKSwgdGhpcy5fYmluZFN3aXBlRXZlbnRzKCk7XFxuICAgICAgfSwgX2dldFBhbmVsSW5uZXI6IGZ1bmN0aW9uIF9nZXRQYW5lbElubmVyKCkge1xcbiAgICAgICAgdmFyIGEgPSB0aGlzLmVsZW1lbnQuZmluZChcXFwiLlxcXCIgKyB0aGlzLm9wdGlvbnMuY2xhc3Nlcy5wYW5lbElubmVyKTtyZXR1cm4gMCA9PT0gYS5sZW5ndGggJiYgKGEgPSB0aGlzLmVsZW1lbnQuY2hpbGRyZW4oKS53cmFwQWxsKFxcXCI8ZGl2IGNsYXNzPSdcXFwiICsgdGhpcy5vcHRpb25zLmNsYXNzZXMucGFuZWxJbm5lciArIFxcXCInIC8+XFxcIikucGFyZW50KCkpLCBhO1xcbiAgICAgIH0sIF9jcmVhdGVNb2RhbDogZnVuY3Rpb24gX2NyZWF0ZU1vZGFsKCkge1xcbiAgICAgICAgdmFyIGIgPSB0aGlzLFxcbiAgICAgICAgICAgIGMgPSBiLl9wYXJlbnRQYWdlID8gYi5fcGFyZW50UGFnZS5wYXJlbnQoKSA6IGIuZWxlbWVudC5wYXJlbnQoKTtiLl9tb2RhbCA9IGEoXFxcIjxkaXYgY2xhc3M9J1xcXCIgKyBiLm9wdGlvbnMuY2xhc3Nlcy5tb2RhbCArIFxcXCInPjwvZGl2PlxcXCIpLm9uKFxcXCJtb3VzZWRvd25cXFwiLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIGIuY2xvc2UoKTtcXG4gICAgICAgIH0pLmFwcGVuZFRvKGMpO1xcbiAgICAgIH0sIF9nZXRQYWdlOiBmdW5jdGlvbiBfZ2V0UGFnZSgpIHtcXG4gICAgICAgIHZhciBiID0gdGhpcy5fb3BlbmVkUGFnZSB8fCB0aGlzLl9wYXJlbnRQYWdlIHx8IGEoXFxcIi5cXFwiICsgYS5tb2JpbGUuYWN0aXZlUGFnZUNsYXNzKTtyZXR1cm4gYjtcXG4gICAgICB9LCBfZ2V0V3JhcHBlcjogZnVuY3Rpb24gX2dldFdyYXBwZXIoKSB7XFxuICAgICAgICB2YXIgYSA9IHRoaXMuX3BhZ2UoKS5maW5kKFxcXCIuXFxcIiArIHRoaXMub3B0aW9ucy5jbGFzc2VzLnBhZ2VXcmFwcGVyKTswID09PSBhLmxlbmd0aCAmJiAoYSA9IHRoaXMuX3BhZ2UoKS5jaGlsZHJlbihcXFwiLnVpLWhlYWRlcjpub3QoLnVpLWhlYWRlci1maXhlZCksIC51aS1jb250ZW50Om5vdCgudWktcG9wdXApLCAudWktZm9vdGVyOm5vdCgudWktZm9vdGVyLWZpeGVkKVxcXCIpLndyYXBBbGwoXFxcIjxkaXYgY2xhc3M9J1xcXCIgKyB0aGlzLm9wdGlvbnMuY2xhc3Nlcy5wYWdlV3JhcHBlciArIFxcXCInPjwvZGl2PlxcXCIpLnBhcmVudCgpKSwgdGhpcy5fd3JhcHBlciA9IGE7XFxuICAgICAgfSwgX2dldEZpeGVkVG9vbGJhcnM6IGZ1bmN0aW9uIF9nZXRGaXhlZFRvb2xiYXJzKCkge1xcbiAgICAgICAgdmFyIGIgPSBhKFxcXCJib2R5XFxcIikuY2hpbGRyZW4oXFxcIi51aS1oZWFkZXItZml4ZWQsIC51aS1mb290ZXItZml4ZWRcXFwiKSxcXG4gICAgICAgICAgICBjID0gdGhpcy5fcGFnZSgpLmZpbmQoXFxcIi51aS1oZWFkZXItZml4ZWQsIC51aS1mb290ZXItZml4ZWRcXFwiKSxcXG4gICAgICAgICAgICBkID0gYi5hZGQoYykuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmNsYXNzZXMucGFnZUZpeGVkVG9vbGJhcik7cmV0dXJuIGQ7XFxuICAgICAgfSwgX2dldFBvc0Rpc3BsYXlDbGFzc2VzOiBmdW5jdGlvbiBfZ2V0UG9zRGlzcGxheUNsYXNzZXMoYSkge1xcbiAgICAgICAgcmV0dXJuIGEgKyBcXFwiLXBvc2l0aW9uLVxcXCIgKyB0aGlzLm9wdGlvbnMucG9zaXRpb24gKyBcXFwiIFxcXCIgKyBhICsgXFxcIi1kaXNwbGF5LVxcXCIgKyB0aGlzLm9wdGlvbnMuZGlzcGxheTtcXG4gICAgICB9LCBfZ2V0UGFuZWxDbGFzc2VzOiBmdW5jdGlvbiBfZ2V0UGFuZWxDbGFzc2VzKCkge1xcbiAgICAgICAgdmFyIGEgPSB0aGlzLm9wdGlvbnMuY2xhc3Nlcy5wYW5lbCArIFxcXCIgXFxcIiArIHRoaXMuX2dldFBvc0Rpc3BsYXlDbGFzc2VzKHRoaXMub3B0aW9ucy5jbGFzc2VzLnBhbmVsKSArIFxcXCIgXFxcIiArIHRoaXMub3B0aW9ucy5jbGFzc2VzLnBhbmVsQ2xvc2VkICsgXFxcIiB1aS1ib2R5LVxcXCIgKyAodGhpcy5vcHRpb25zLnRoZW1lID8gdGhpcy5vcHRpb25zLnRoZW1lIDogXFxcImluaGVyaXRcXFwiKTtyZXR1cm4gdGhpcy5vcHRpb25zLnBvc2l0aW9uRml4ZWQgJiYgKGEgKz0gXFxcIiBcXFwiICsgdGhpcy5vcHRpb25zLmNsYXNzZXMucGFuZWxGaXhlZCksIGE7XFxuICAgICAgfSwgX2FkZFBhbmVsQ2xhc3NlczogZnVuY3Rpb24gX2FkZFBhbmVsQ2xhc3NlcygpIHtcXG4gICAgICAgIHRoaXMuZWxlbWVudC5hZGRDbGFzcyh0aGlzLl9nZXRQYW5lbENsYXNzZXMoKSk7XFxuICAgICAgfSwgX2hhbmRsZUNsb3NlQ2xpY2s6IGZ1bmN0aW9uIF9oYW5kbGVDbG9zZUNsaWNrKGEpIHtcXG4gICAgICAgIGEuaXNEZWZhdWx0UHJldmVudGVkKCkgfHwgdGhpcy5jbG9zZSgpO1xcbiAgICAgIH0sIF9iaW5kQ2xvc2VFdmVudHM6IGZ1bmN0aW9uIF9iaW5kQ2xvc2VFdmVudHMoKSB7XFxuICAgICAgICB0aGlzLl9vbih0aGlzLl9jbG9zZUxpbmssIHsgY2xpY2s6IFxcXCJfaGFuZGxlQ2xvc2VDbGlja1xcXCIgfSksIHRoaXMuX29uKHsgXFxcImNsaWNrIGE6anFtRGF0YShhamF4PSdmYWxzZScpXFxcIjogXFxcIl9oYW5kbGVDbG9zZUNsaWNrXFxcIiB9KTtcXG4gICAgICB9LCBfcG9zaXRpb25QYW5lbDogZnVuY3Rpb24gX3Bvc2l0aW9uUGFuZWwoYikge1xcbiAgICAgICAgdmFyIGMgPSB0aGlzLFxcbiAgICAgICAgICAgIGQgPSBjLl9wYW5lbElubmVyLm91dGVySGVpZ2h0KCksXFxuICAgICAgICAgICAgZSA9IGQgPiBhLm1vYmlsZS5nZXRTY3JlZW5IZWlnaHQoKTtlIHx8ICFjLm9wdGlvbnMucG9zaXRpb25GaXhlZCA/IChlICYmIChjLl91bmZpeFBhbmVsKCksIGEubW9iaWxlLnJlc2V0QWN0aXZlUGFnZUhlaWdodChkKSksIGIgJiYgdGhpcy53aW5kb3dbMF0uc2Nyb2xsVG8oMCwgYS5tb2JpbGUuZGVmYXVsdEhvbWVTY3JvbGwpKSA6IGMuX2ZpeFBhbmVsKCk7XFxuICAgICAgfSwgX2JpbmRGaXhMaXN0ZW5lcjogZnVuY3Rpb24gX2JpbmRGaXhMaXN0ZW5lcigpIHtcXG4gICAgICAgIHRoaXMuX29uKGEoYiksIHsgdGhyb3R0bGVkcmVzaXplOiBcXFwiX3Bvc2l0aW9uUGFuZWxcXFwiIH0pO1xcbiAgICAgIH0sIF91bmJpbmRGaXhMaXN0ZW5lcjogZnVuY3Rpb24gX3VuYmluZEZpeExpc3RlbmVyKCkge1xcbiAgICAgICAgdGhpcy5fb2ZmKGEoYiksIFxcXCJ0aHJvdHRsZWRyZXNpemVcXFwiKTtcXG4gICAgICB9LCBfdW5maXhQYW5lbDogZnVuY3Rpb24gX3VuZml4UGFuZWwoKSB7XFxuICAgICAgICB0aGlzLm9wdGlvbnMucG9zaXRpb25GaXhlZCAmJiBhLnN1cHBvcnQuZml4ZWRQb3NpdGlvbiAmJiB0aGlzLmVsZW1lbnQucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmNsYXNzZXMucGFuZWxGaXhlZCk7XFxuICAgICAgfSwgX2ZpeFBhbmVsOiBmdW5jdGlvbiBfZml4UGFuZWwoKSB7XFxuICAgICAgICB0aGlzLm9wdGlvbnMucG9zaXRpb25GaXhlZCAmJiBhLnN1cHBvcnQuZml4ZWRQb3NpdGlvbiAmJiB0aGlzLmVsZW1lbnQuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmNsYXNzZXMucGFuZWxGaXhlZCk7XFxuICAgICAgfSwgX2JpbmRVcGRhdGVMYXlvdXQ6IGZ1bmN0aW9uIF9iaW5kVXBkYXRlTGF5b3V0KCkge1xcbiAgICAgICAgdmFyIGEgPSB0aGlzO2EuZWxlbWVudC5vbihcXFwidXBkYXRlbGF5b3V0XFxcIiwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBhLl9vcGVuICYmIGEuX3Bvc2l0aW9uUGFuZWwoKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH0sIF9iaW5kTGlua0xpc3RlbmVyczogZnVuY3Rpb24gX2JpbmRMaW5rTGlzdGVuZXJzKCkge1xcbiAgICAgICAgdGhpcy5fb24oXFxcImJvZHlcXFwiLCB7IFxcXCJjbGljayBhXFxcIjogXFxcIl9oYW5kbGVDbGlja1xcXCIgfSk7XFxuICAgICAgfSwgX2hhbmRsZUNsaWNrOiBmdW5jdGlvbiBfaGFuZGxlQ2xpY2soYikge1xcbiAgICAgICAgdmFyIGQsXFxuICAgICAgICAgICAgZSA9IHRoaXMuZWxlbWVudC5hdHRyKFxcXCJpZFxcXCIpO2IuY3VycmVudFRhcmdldC5ocmVmLnNwbGl0KFxcXCIjXFxcIilbMV0gPT09IGUgJiYgZSAhPT0gYyAmJiAoYi5wcmV2ZW50RGVmYXVsdCgpLCBkID0gYShiLnRhcmdldCksIGQuaGFzQ2xhc3MoXFxcInVpLWJ0blxcXCIpICYmIChkLmFkZENsYXNzKGEubW9iaWxlLmFjdGl2ZUJ0bkNsYXNzKSwgdGhpcy5lbGVtZW50Lm9uZShcXFwicGFuZWxvcGVuIHBhbmVsY2xvc2VcXFwiLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIGQucmVtb3ZlQ2xhc3MoYS5tb2JpbGUuYWN0aXZlQnRuQ2xhc3MpO1xcbiAgICAgICAgfSkpLCB0aGlzLnRvZ2dsZSgpKTtcXG4gICAgICB9LCBfYmluZFN3aXBlRXZlbnRzOiBmdW5jdGlvbiBfYmluZFN3aXBlRXZlbnRzKCkge1xcbiAgICAgICAgdmFyIGEgPSB0aGlzLFxcbiAgICAgICAgICAgIGIgPSBhLl9tb2RhbCA/IGEuZWxlbWVudC5hZGQoYS5fbW9kYWwpIDogYS5lbGVtZW50O2Eub3B0aW9ucy5zd2lwZUNsb3NlICYmIChcXFwibGVmdFxcXCIgPT09IGEub3B0aW9ucy5wb3NpdGlvbiA/IGIub24oXFxcInN3aXBlbGVmdC5wYW5lbFxcXCIsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgYS5jbG9zZSgpO1xcbiAgICAgICAgfSkgOiBiLm9uKFxcXCJzd2lwZXJpZ2h0LnBhbmVsXFxcIiwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBhLmNsb3NlKCk7XFxuICAgICAgICB9KSk7XFxuICAgICAgfSwgX2JpbmRQYWdlRXZlbnRzOiBmdW5jdGlvbiBfYmluZFBhZ2VFdmVudHMoKSB7XFxuICAgICAgICB2YXIgYSA9IHRoaXM7dGhpcy5kb2N1bWVudC5vbihcXFwicGFuZWxiZWZvcmVvcGVuXFxcIiwgZnVuY3Rpb24gKGIpIHtcXG4gICAgICAgICAgYS5fb3BlbiAmJiBiLnRhcmdldCAhPT0gYS5lbGVtZW50WzBdICYmIGEuY2xvc2UoKTtcXG4gICAgICAgIH0pLm9uKFxcXCJrZXl1cC5wYW5lbFxcXCIsIGZ1bmN0aW9uIChiKSB7XFxuICAgICAgICAgIDI3ID09PSBiLmtleUNvZGUgJiYgYS5fb3BlbiAmJiBhLmNsb3NlKCk7XFxuICAgICAgICB9KSwgdGhpcy5fcGFyZW50UGFnZSB8fCBcXFwib3ZlcmxheVxcXCIgPT09IHRoaXMub3B0aW9ucy5kaXNwbGF5IHx8IHRoaXMuX29uKHRoaXMuZG9jdW1lbnQsIHsgcGFnZXNob3c6IGZ1bmN0aW9uIHBhZ2VzaG93KCkge1xcbiAgICAgICAgICAgIHRoaXMuX29wZW5lZFBhZ2UgPSBudWxsLCB0aGlzLl9nZXRXcmFwcGVyKCk7XFxuICAgICAgICAgIH0gfSksIGEuX3BhcmVudFBhZ2UgPyB0aGlzLmRvY3VtZW50Lm9uKFxcXCJwYWdlaGlkZVxcXCIsIFxcXCI6anFtRGF0YShyb2xlPSdwYWdlJylcXFwiLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIGEuX29wZW4gJiYgYS5jbG9zZSghMCk7XFxuICAgICAgICB9KSA6IHRoaXMuZG9jdW1lbnQub24oXFxcInBhZ2ViZWZvcmVoaWRlXFxcIiwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBhLl9vcGVuICYmIGEuY2xvc2UoITApO1xcbiAgICAgICAgfSk7XFxuICAgICAgfSwgX29wZW46ICExLCBfcGFnZUNvbnRlbnRPcGVuQ2xhc3NlczogbnVsbCwgX21vZGFsT3BlbkNsYXNzZXM6IG51bGwsIG9wZW46IGZ1bmN0aW9uIG9wZW4oYikge1xcbiAgICAgICAgaWYgKCF0aGlzLl9vcGVuKSB7XFxuICAgICAgICAgIHZhciBjID0gdGhpcyxcXG4gICAgICAgICAgICAgIGQgPSBjLm9wdGlvbnMsXFxuICAgICAgICAgICAgICBlID0gZnVuY3Rpb24gZSgpIHtcXG4gICAgICAgICAgICBjLl9vZmYoYy5kb2N1bWVudCwgXFxcInBhbmVsY2xvc2VcXFwiKSwgYy5fcGFnZSgpLmpxbURhdGEoXFxcInBhbmVsXFxcIiwgXFxcIm9wZW5cXFwiKSwgYS5zdXBwb3J0LmNzc1RyYW5zZm9ybTNkICYmIGQuYW5pbWF0ZSAmJiBcXFwib3ZlcmxheVxcXCIgIT09IGQuZGlzcGxheSAmJiAoYy5fd3JhcHBlci5hZGRDbGFzcyhkLmNsYXNzZXMuYW5pbWF0ZSksIGMuX2ZpeGVkVG9vbGJhcnMoKS5hZGRDbGFzcyhkLmNsYXNzZXMuYW5pbWF0ZSkpLCAhYiAmJiBhLnN1cHBvcnQuY3NzVHJhbnNmb3JtM2QgJiYgZC5hbmltYXRlID8gKGMuX3dyYXBwZXIgfHwgYy5lbGVtZW50KS5hbmltYXRpb25Db21wbGV0ZShmLCBcXFwidHJhbnNpdGlvblxcXCIpIDogc2V0VGltZW91dChmLCAwKSwgZC50aGVtZSAmJiBcXFwib3ZlcmxheVxcXCIgIT09IGQuZGlzcGxheSAmJiBjLl9wYWdlKCkucGFyZW50KCkuYWRkQ2xhc3MoZC5jbGFzc2VzLnBhZ2VDb250YWluZXIgKyBcXFwiLXRoZW1lZCBcXFwiICsgZC5jbGFzc2VzLnBhZ2VDb250YWluZXIgKyBcXFwiLVxcXCIgKyBkLnRoZW1lKSwgYy5lbGVtZW50LnJlbW92ZUNsYXNzKGQuY2xhc3Nlcy5wYW5lbENsb3NlZCkuYWRkQ2xhc3MoZC5jbGFzc2VzLnBhbmVsT3BlbiksIGMuX3Bvc2l0aW9uUGFuZWwoITApLCBjLl9wYWdlQ29udGVudE9wZW5DbGFzc2VzID0gYy5fZ2V0UG9zRGlzcGxheUNsYXNzZXMoZC5jbGFzc2VzLnBhZ2VDb250ZW50UHJlZml4KSwgXFxcIm92ZXJsYXlcXFwiICE9PSBkLmRpc3BsYXkgJiYgKGMuX3BhZ2UoKS5wYXJlbnQoKS5hZGRDbGFzcyhkLmNsYXNzZXMucGFnZUNvbnRhaW5lciksIGMuX3dyYXBwZXIuYWRkQ2xhc3MoYy5fcGFnZUNvbnRlbnRPcGVuQ2xhc3NlcyksIGMuX2ZpeGVkVG9vbGJhcnMoKS5hZGRDbGFzcyhjLl9wYWdlQ29udGVudE9wZW5DbGFzc2VzKSksIGMuX21vZGFsT3BlbkNsYXNzZXMgPSBjLl9nZXRQb3NEaXNwbGF5Q2xhc3NlcyhkLmNsYXNzZXMubW9kYWwpICsgXFxcIiBcXFwiICsgZC5jbGFzc2VzLm1vZGFsT3BlbiwgYy5fbW9kYWwgJiYgYy5fbW9kYWwuYWRkQ2xhc3MoYy5fbW9kYWxPcGVuQ2xhc3NlcykuaGVpZ2h0KE1hdGgubWF4KGMuX21vZGFsLmhlaWdodCgpLCBjLmRvY3VtZW50LmhlaWdodCgpKSk7XFxuICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICBmID0gZnVuY3Rpb24gZigpIHtcXG4gICAgICAgICAgICBjLl9vcGVuICYmIChcXFwib3ZlcmxheVxcXCIgIT09IGQuZGlzcGxheSAmJiAoYy5fd3JhcHBlci5hZGRDbGFzcyhkLmNsYXNzZXMucGFnZUNvbnRlbnRQcmVmaXggKyBcXFwiLW9wZW5cXFwiKSwgYy5fZml4ZWRUb29sYmFycygpLmFkZENsYXNzKGQuY2xhc3Nlcy5wYWdlQ29udGVudFByZWZpeCArIFxcXCItb3BlblxcXCIpKSwgYy5fYmluZEZpeExpc3RlbmVyKCksIGMuX3RyaWdnZXIoXFxcIm9wZW5cXFwiKSwgYy5fb3BlbmVkUGFnZSA9IGMuX3BhZ2UoKSk7XFxuICAgICAgICAgIH07Yy5fdHJpZ2dlcihcXFwiYmVmb3Jlb3BlblxcXCIpLCBcXFwib3BlblxcXCIgPT09IGMuX3BhZ2UoKS5qcW1EYXRhKFxcXCJwYW5lbFxcXCIpID8gYy5fb24oYy5kb2N1bWVudCwgeyBwYW5lbGNsb3NlOiBlIH0pIDogZSgpLCBjLl9vcGVuID0gITA7XFxuICAgICAgICB9XFxuICAgICAgfSwgY2xvc2U6IGZ1bmN0aW9uIGNsb3NlKGIpIHtcXG4gICAgICAgIGlmICh0aGlzLl9vcGVuKSB7XFxuICAgICAgICAgIHZhciBjID0gdGhpcyxcXG4gICAgICAgICAgICAgIGQgPSB0aGlzLm9wdGlvbnMsXFxuICAgICAgICAgICAgICBlID0gZnVuY3Rpb24gZSgpIHtcXG4gICAgICAgICAgICBjLmVsZW1lbnQucmVtb3ZlQ2xhc3MoZC5jbGFzc2VzLnBhbmVsT3BlbiksIFxcXCJvdmVybGF5XFxcIiAhPT0gZC5kaXNwbGF5ICYmIChjLl93cmFwcGVyLnJlbW92ZUNsYXNzKGMuX3BhZ2VDb250ZW50T3BlbkNsYXNzZXMpLCBjLl9maXhlZFRvb2xiYXJzKCkucmVtb3ZlQ2xhc3MoYy5fcGFnZUNvbnRlbnRPcGVuQ2xhc3NlcykpLCAhYiAmJiBhLnN1cHBvcnQuY3NzVHJhbnNmb3JtM2QgJiYgZC5hbmltYXRlID8gKGMuX3dyYXBwZXIgfHwgYy5lbGVtZW50KS5hbmltYXRpb25Db21wbGV0ZShmLCBcXFwidHJhbnNpdGlvblxcXCIpIDogc2V0VGltZW91dChmLCAwKSwgYy5fbW9kYWwgJiYgYy5fbW9kYWwucmVtb3ZlQ2xhc3MoYy5fbW9kYWxPcGVuQ2xhc3NlcykuaGVpZ2h0KFxcXCJcXFwiKTtcXG4gICAgICAgICAgfSxcXG4gICAgICAgICAgICAgIGYgPSBmdW5jdGlvbiBmKCkge1xcbiAgICAgICAgICAgIGQudGhlbWUgJiYgXFxcIm92ZXJsYXlcXFwiICE9PSBkLmRpc3BsYXkgJiYgYy5fcGFnZSgpLnBhcmVudCgpLnJlbW92ZUNsYXNzKGQuY2xhc3Nlcy5wYWdlQ29udGFpbmVyICsgXFxcIi10aGVtZWQgXFxcIiArIGQuY2xhc3Nlcy5wYWdlQ29udGFpbmVyICsgXFxcIi1cXFwiICsgZC50aGVtZSksIGMuZWxlbWVudC5hZGRDbGFzcyhkLmNsYXNzZXMucGFuZWxDbG9zZWQpLCBcXFwib3ZlcmxheVxcXCIgIT09IGQuZGlzcGxheSAmJiAoYy5fcGFnZSgpLnBhcmVudCgpLnJlbW92ZUNsYXNzKGQuY2xhc3Nlcy5wYWdlQ29udGFpbmVyKSwgYy5fd3JhcHBlci5yZW1vdmVDbGFzcyhkLmNsYXNzZXMucGFnZUNvbnRlbnRQcmVmaXggKyBcXFwiLW9wZW5cXFwiKSwgYy5fZml4ZWRUb29sYmFycygpLnJlbW92ZUNsYXNzKGQuY2xhc3Nlcy5wYWdlQ29udGVudFByZWZpeCArIFxcXCItb3BlblxcXCIpKSwgYS5zdXBwb3J0LmNzc1RyYW5zZm9ybTNkICYmIGQuYW5pbWF0ZSAmJiBcXFwib3ZlcmxheVxcXCIgIT09IGQuZGlzcGxheSAmJiAoYy5fd3JhcHBlci5yZW1vdmVDbGFzcyhkLmNsYXNzZXMuYW5pbWF0ZSksIGMuX2ZpeGVkVG9vbGJhcnMoKS5yZW1vdmVDbGFzcyhkLmNsYXNzZXMuYW5pbWF0ZSkpLCBjLl9maXhQYW5lbCgpLCBjLl91bmJpbmRGaXhMaXN0ZW5lcigpLCBhLm1vYmlsZS5yZXNldEFjdGl2ZVBhZ2VIZWlnaHQoKSwgYy5fcGFnZSgpLmpxbVJlbW92ZURhdGEoXFxcInBhbmVsXFxcIiksIGMuX3RyaWdnZXIoXFxcImNsb3NlXFxcIiksIGMuX29wZW5lZFBhZ2UgPSBudWxsO1xcbiAgICAgICAgICB9O2MuX3RyaWdnZXIoXFxcImJlZm9yZWNsb3NlXFxcIiksIGUoKSwgYy5fb3BlbiA9ICExO1xcbiAgICAgICAgfVxcbiAgICAgIH0sIHRvZ2dsZTogZnVuY3Rpb24gdG9nZ2xlKCkge1xcbiAgICAgICAgdGhpc1t0aGlzLl9vcGVuID8gXFxcImNsb3NlXFxcIiA6IFxcXCJvcGVuXFxcIl0oKTtcXG4gICAgICB9LCBfZGVzdHJveTogZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XFxuICAgICAgICB2YXIgYixcXG4gICAgICAgICAgICBjID0gdGhpcy5vcHRpb25zLFxcbiAgICAgICAgICAgIGQgPSBhKFxcXCJib2R5ID4gOm1vYmlsZS1wYW5lbFxcXCIpLmxlbmd0aCArIGEubW9iaWxlLmFjdGl2ZVBhZ2UuZmluZChcXFwiOm1vYmlsZS1wYW5lbFxcXCIpLmxlbmd0aCA+IDE7XFxcIm92ZXJsYXlcXFwiICE9PSBjLmRpc3BsYXkgJiYgKGIgPSBhKFxcXCJib2R5ID4gOm1vYmlsZS1wYW5lbFxcXCIpLmFkZChhLm1vYmlsZS5hY3RpdmVQYWdlLmZpbmQoXFxcIjptb2JpbGUtcGFuZWxcXFwiKSksIDAgPT09IGIubm90KFxcXCIudWktcGFuZWwtZGlzcGxheS1vdmVybGF5XFxcIikubm90KHRoaXMuZWxlbWVudCkubGVuZ3RoICYmIHRoaXMuX3dyYXBwZXIuY2hpbGRyZW4oKS51bndyYXAoKSwgdGhpcy5fb3BlbiAmJiAodGhpcy5fZml4ZWRUb29sYmFycygpLnJlbW92ZUNsYXNzKGMuY2xhc3Nlcy5wYWdlQ29udGVudFByZWZpeCArIFxcXCItb3BlblxcXCIpLCBhLnN1cHBvcnQuY3NzVHJhbnNmb3JtM2QgJiYgYy5hbmltYXRlICYmIHRoaXMuX2ZpeGVkVG9vbGJhcnMoKS5yZW1vdmVDbGFzcyhjLmNsYXNzZXMuYW5pbWF0ZSksIHRoaXMuX3BhZ2UoKS5wYXJlbnQoKS5yZW1vdmVDbGFzcyhjLmNsYXNzZXMucGFnZUNvbnRhaW5lciksIGMudGhlbWUgJiYgdGhpcy5fcGFnZSgpLnBhcmVudCgpLnJlbW92ZUNsYXNzKGMuY2xhc3Nlcy5wYWdlQ29udGFpbmVyICsgXFxcIi10aGVtZWQgXFxcIiArIGMuY2xhc3Nlcy5wYWdlQ29udGFpbmVyICsgXFxcIi1cXFwiICsgYy50aGVtZSkpKSwgZCB8fCB0aGlzLmRvY3VtZW50Lm9mZihcXFwicGFuZWxvcGVuIHBhbmVsY2xvc2VcXFwiKSwgdGhpcy5fb3BlbiAmJiB0aGlzLl9wYWdlKCkuanFtUmVtb3ZlRGF0YShcXFwicGFuZWxcXFwiKSwgdGhpcy5fcGFuZWxJbm5lci5jaGlsZHJlbigpLnVud3JhcCgpLCB0aGlzLmVsZW1lbnQucmVtb3ZlQ2xhc3MoW3RoaXMuX2dldFBhbmVsQ2xhc3NlcygpLCBjLmNsYXNzZXMucGFuZWxPcGVuLCBjLmNsYXNzZXMuYW5pbWF0ZV0uam9pbihcXFwiIFxcXCIpKS5vZmYoXFxcInN3aXBlbGVmdC5wYW5lbCBzd2lwZXJpZ2h0LnBhbmVsXFxcIikub2ZmKFxcXCJwYW5lbGJlZm9yZW9wZW5cXFwiKS5vZmYoXFxcInBhbmVsaGlkZVxcXCIpLm9mZihcXFwia2V5dXAucGFuZWxcXFwiKS5vZmYoXFxcInVwZGF0ZWxheW91dFxcXCIpLCB0aGlzLl9tb2RhbCAmJiB0aGlzLl9tb2RhbC5yZW1vdmUoKTtcXG4gICAgICB9IH0pO1xcbiAgfShhKSwgZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgYS53aWRnZXQoXFxcIm1vYmlsZS50YWJsZVxcXCIsIHsgb3B0aW9uczogeyBjbGFzc2VzOiB7IHRhYmxlOiBcXFwidWktdGFibGVcXFwiIH0sIGVuaGFuY2VkOiAhMSB9LCBfY3JlYXRlOiBmdW5jdGlvbiBfY3JlYXRlKCkge1xcbiAgICAgICAgdGhpcy5vcHRpb25zLmVuaGFuY2VkIHx8IHRoaXMuZWxlbWVudC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuY2xhc3Nlcy50YWJsZSksIGEuZXh0ZW5kKHRoaXMsIHsgaGVhZGVyczogYiwgYWxsSGVhZGVyczogYiB9KSwgdGhpcy5fcmVmcmVzaCghMCk7XFxuICAgICAgfSwgX3NldEhlYWRlcnM6IGZ1bmN0aW9uIF9zZXRIZWFkZXJzKCkge1xcbiAgICAgICAgdmFyIGEgPSB0aGlzLmVsZW1lbnQuZmluZChcXFwidGhlYWQgdHJcXFwiKTt0aGlzLmhlYWRlcnMgPSB0aGlzLmVsZW1lbnQuZmluZChcXFwidHI6ZXEoMClcXFwiKS5jaGlsZHJlbigpLCB0aGlzLmFsbEhlYWRlcnMgPSB0aGlzLmhlYWRlcnMuYWRkKGEuY2hpbGRyZW4oKSk7XFxuICAgICAgfSwgcmVmcmVzaDogZnVuY3Rpb24gcmVmcmVzaCgpIHtcXG4gICAgICAgIHRoaXMuX3JlZnJlc2goKTtcXG4gICAgICB9LCByZWJ1aWxkOiBhLm5vb3AsIF9yZWZyZXNoOiBmdW5jdGlvbiBfcmVmcmVzaCgpIHtcXG4gICAgICAgIHZhciBiID0gdGhpcy5lbGVtZW50LFxcbiAgICAgICAgICAgIGMgPSBiLmZpbmQoXFxcInRoZWFkIHRyXFxcIik7dGhpcy5fc2V0SGVhZGVycygpLCBjLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICB2YXIgZCA9IDA7YSh0aGlzKS5jaGlsZHJlbigpLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIHZhciBlLFxcbiAgICAgICAgICAgICAgICBmID0gcGFyc2VJbnQodGhpcy5nZXRBdHRyaWJ1dGUoXFxcImNvbHNwYW5cXFwiKSwgMTApLFxcbiAgICAgICAgICAgICAgICBnID0gXFxcIjpudGgtY2hpbGQoXFxcIiArIChkICsgMSkgKyBcXFwiKVxcXCI7aWYgKHRoaXMuc2V0QXR0cmlidXRlKFxcXCJkYXRhLVxcXCIgKyBhLm1vYmlsZS5ucyArIFxcXCJjb2xzdGFydFxcXCIsIGQgKyAxKSwgZikgZm9yIChlID0gMDsgZiAtIDEgPiBlOyBlKyspIHtcXG4gICAgICAgICAgICAgIGQrKywgZyArPSBcXFwiLCA6bnRoLWNoaWxkKFxcXCIgKyAoZCArIDEpICsgXFxcIilcXFwiO1xcbiAgICAgICAgICAgIH1hKHRoaXMpLmpxbURhdGEoXFxcImNlbGxzXFxcIiwgYi5maW5kKFxcXCJ0clxcXCIpLm5vdChjLmVxKDApKS5ub3QodGhpcykuY2hpbGRyZW4oZykpLCBkKys7XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfSk7XFxuICAgICAgfSB9KTtcXG4gIH0oYSksIGZ1bmN0aW9uIChhKSB7XFxuICAgIGEud2lkZ2V0KFxcXCJtb2JpbGUudGFibGVcXFwiLCBhLm1vYmlsZS50YWJsZSwgeyBvcHRpb25zOiB7IG1vZGU6IFxcXCJjb2x1bW50b2dnbGVcXFwiLCBjb2x1bW5CdG5UaGVtZTogbnVsbCwgY29sdW1uUG9wdXBUaGVtZTogbnVsbCwgY29sdW1uQnRuVGV4dDogXFxcIkNvbHVtbnMuLi5cXFwiLCBjbGFzc2VzOiBhLmV4dGVuZChhLm1vYmlsZS50YWJsZS5wcm90b3R5cGUub3B0aW9ucy5jbGFzc2VzLCB7IHBvcHVwOiBcXFwidWktdGFibGUtY29sdW1udG9nZ2xlLXBvcHVwXFxcIiwgY29sdW1uQnRuOiBcXFwidWktdGFibGUtY29sdW1udG9nZ2xlLWJ0blxcXCIsIHByaW9yaXR5UHJlZml4OiBcXFwidWktdGFibGUtcHJpb3JpdHktXFxcIiwgY29sdW1uVG9nZ2xlVGFibGU6IFxcXCJ1aS10YWJsZS1jb2x1bW50b2dnbGVcXFwiIH0pIH0sIF9jcmVhdGU6IGZ1bmN0aW9uIF9jcmVhdGUoKSB7XFxuICAgICAgICB0aGlzLl9zdXBlcigpLCBcXFwiY29sdW1udG9nZ2xlXFxcIiA9PT0gdGhpcy5vcHRpb25zLm1vZGUgJiYgKGEuZXh0ZW5kKHRoaXMsIHsgX21lbnU6IG51bGwgfSksIHRoaXMub3B0aW9ucy5lbmhhbmNlZCA/ICh0aGlzLl9tZW51ID0gYSh0aGlzLmRvY3VtZW50WzBdLmdldEVsZW1lbnRCeUlkKHRoaXMuX2lkKCkgKyBcXFwiLXBvcHVwXFxcIikpLmNoaWxkcmVuKCkuZmlyc3QoKSwgdGhpcy5fYWRkVG9nZ2xlcyh0aGlzLl9tZW51LCAhMCkpIDogKHRoaXMuX21lbnUgPSB0aGlzLl9lbmhhbmNlQ29sVG9nZ2xlKCksIHRoaXMuZWxlbWVudC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuY2xhc3Nlcy5jb2x1bW5Ub2dnbGVUYWJsZSkpLCB0aGlzLl9zZXR1cEV2ZW50cygpLCB0aGlzLl9zZXRUb2dnbGVTdGF0ZSgpKTtcXG4gICAgICB9LCBfaWQ6IGZ1bmN0aW9uIF9pZCgpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQuYXR0cihcXFwiaWRcXFwiKSB8fCB0aGlzLndpZGdldE5hbWUgKyB0aGlzLnV1aWQ7XFxuICAgICAgfSwgX3NldHVwRXZlbnRzOiBmdW5jdGlvbiBfc2V0dXBFdmVudHMoKSB7XFxuICAgICAgICB0aGlzLl9vbih0aGlzLndpbmRvdywgeyB0aHJvdHRsZWRyZXNpemU6IFxcXCJfc2V0VG9nZ2xlU3RhdGVcXFwiIH0pLCB0aGlzLl9vbih0aGlzLl9tZW51LCB7IFxcXCJjaGFuZ2UgaW5wdXRcXFwiOiBcXFwiX21lbnVJbnB1dENoYW5nZVxcXCIgfSk7XFxuICAgICAgfSwgX2FkZFRvZ2dsZXM6IGZ1bmN0aW9uIF9hZGRUb2dnbGVzKGIsIGMpIHtcXG4gICAgICAgIHZhciBkLFxcbiAgICAgICAgICAgIGUgPSAwLFxcbiAgICAgICAgICAgIGYgPSB0aGlzLm9wdGlvbnMsXFxuICAgICAgICAgICAgZyA9IGIuY29udHJvbGdyb3VwKFxcXCJjb250YWluZXJcXFwiKTtjID8gZCA9IGIuZmluZChcXFwiaW5wdXRcXFwiKSA6IGcuZW1wdHkoKSwgdGhpcy5oZWFkZXJzLm5vdChcXFwidGRcXFwiKS5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgdmFyIGIsXFxuICAgICAgICAgICAgICBoLFxcbiAgICAgICAgICAgICAgaSA9IGEodGhpcyksXFxuICAgICAgICAgICAgICBqID0gYS5tb2JpbGUuZ2V0QXR0cmlidXRlKHRoaXMsIFxcXCJwcmlvcml0eVxcXCIpO2ogJiYgKGggPSBpLmFkZChpLmpxbURhdGEoXFxcImNlbGxzXFxcIikpLCBoLmFkZENsYXNzKGYuY2xhc3Nlcy5wcmlvcml0eVByZWZpeCArIGopLCBiID0gKGMgPyBkLmVxKGUrKykgOiBhKFxcXCI8bGFiZWw+PGlucHV0IHR5cGU9J2NoZWNrYm94JyBjaGVja2VkIC8+XFxcIiArIChpLmNoaWxkcmVuKFxcXCJhYmJyXFxcIikuZmlyc3QoKS5hdHRyKFxcXCJ0aXRsZVxcXCIpIHx8IGkudGV4dCgpKSArIFxcXCI8L2xhYmVsPlxcXCIpLmFwcGVuZFRvKGcpLmNoaWxkcmVuKDApLmNoZWNrYm94cmFkaW8oeyB0aGVtZTogZi5jb2x1bW5Qb3B1cFRoZW1lIH0pKS5qcW1EYXRhKFxcXCJoZWFkZXJcXFwiLCBpKS5qcW1EYXRhKFxcXCJjZWxsc1xcXCIsIGgpLCBpLmpxbURhdGEoXFxcImlucHV0XFxcIiwgYikpO1xcbiAgICAgICAgfSksIGMgfHwgYi5jb250cm9sZ3JvdXAoXFxcInJlZnJlc2hcXFwiKTtcXG4gICAgICB9LCBfbWVudUlucHV0Q2hhbmdlOiBmdW5jdGlvbiBfbWVudUlucHV0Q2hhbmdlKGIpIHtcXG4gICAgICAgIHZhciBjID0gYShiLnRhcmdldCksXFxuICAgICAgICAgICAgZCA9IGNbMF0uY2hlY2tlZDtjLmpxbURhdGEoXFxcImNlbGxzXFxcIikudG9nZ2xlQ2xhc3MoXFxcInVpLXRhYmxlLWNlbGwtaGlkZGVuXFxcIiwgIWQpLnRvZ2dsZUNsYXNzKFxcXCJ1aS10YWJsZS1jZWxsLXZpc2libGVcXFwiLCBkKTtcXG4gICAgICB9LCBfdW5sb2NrQ2VsbHM6IGZ1bmN0aW9uIF91bmxvY2tDZWxscyhhKSB7XFxuICAgICAgICBhLnJlbW92ZUNsYXNzKFxcXCJ1aS10YWJsZS1jZWxsLWhpZGRlbiB1aS10YWJsZS1jZWxsLXZpc2libGVcXFwiKTtcXG4gICAgICB9LCBfZW5oYW5jZUNvbFRvZ2dsZTogZnVuY3Rpb24gX2VuaGFuY2VDb2xUb2dnbGUoKSB7XFxuICAgICAgICB2YXIgYixcXG4gICAgICAgICAgICBjLFxcbiAgICAgICAgICAgIGQsXFxuICAgICAgICAgICAgZSxcXG4gICAgICAgICAgICBmID0gdGhpcy5lbGVtZW50LFxcbiAgICAgICAgICAgIGcgPSB0aGlzLm9wdGlvbnMsXFxuICAgICAgICAgICAgaCA9IGEubW9iaWxlLm5zLFxcbiAgICAgICAgICAgIGkgPSB0aGlzLmRvY3VtZW50WzBdLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtyZXR1cm4gYiA9IHRoaXMuX2lkKCkgKyBcXFwiLXBvcHVwXFxcIiwgYyA9IGEoXFxcIjxhIGhyZWY9JyNcXFwiICsgYiArIFxcXCInIGNsYXNzPSdcXFwiICsgZy5jbGFzc2VzLmNvbHVtbkJ0biArIFxcXCIgdWktYnRuIHVpLWJ0bi1cXFwiICsgKGcuY29sdW1uQnRuVGhlbWUgfHwgXFxcImFcXFwiKSArIFxcXCIgdWktY29ybmVyLWFsbCB1aS1zaGFkb3cgdWktbWluaScgZGF0YS1cXFwiICsgaCArIFxcXCJyZWw9J3BvcHVwJz5cXFwiICsgZy5jb2x1bW5CdG5UZXh0ICsgXFxcIjwvYT5cXFwiKSwgZCA9IGEoXFxcIjxkaXYgY2xhc3M9J1xcXCIgKyBnLmNsYXNzZXMucG9wdXAgKyBcXFwiJyBpZD0nXFxcIiArIGIgKyBcXFwiJz48L2Rpdj5cXFwiKSwgZSA9IGEoXFxcIjxmaWVsZHNldD48L2ZpZWxkc2V0PlxcXCIpLmNvbnRyb2xncm91cCgpLCB0aGlzLl9hZGRUb2dnbGVzKGUsICExKSwgZS5hcHBlbmRUbyhkKSwgaS5hcHBlbmRDaGlsZChkWzBdKSwgaS5hcHBlbmRDaGlsZChjWzBdKSwgZi5iZWZvcmUoaSksIGQucG9wdXAoKSwgZTtcXG4gICAgICB9LCByZWJ1aWxkOiBmdW5jdGlvbiByZWJ1aWxkKCkge1xcbiAgICAgICAgdGhpcy5fc3VwZXIoKSwgXFxcImNvbHVtbnRvZ2dsZVxcXCIgPT09IHRoaXMub3B0aW9ucy5tb2RlICYmIHRoaXMuX3JlZnJlc2goITEpO1xcbiAgICAgIH0sIF9yZWZyZXNoOiBmdW5jdGlvbiBfcmVmcmVzaChiKSB7XFxuICAgICAgICB2YXIgYywgZCwgZTtpZiAodGhpcy5fc3VwZXIoYiksICFiICYmIFxcXCJjb2x1bW50b2dnbGVcXFwiID09PSB0aGlzLm9wdGlvbnMubW9kZSkgZm9yIChjID0gdGhpcy5oZWFkZXJzLCBkID0gW10sIHRoaXMuX21lbnUuZmluZChcXFwiaW5wdXRcXFwiKS5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgdmFyIGIgPSBhKHRoaXMpLFxcbiAgICAgICAgICAgICAgZSA9IGIuanFtRGF0YShcXFwiaGVhZGVyXFxcIiksXFxuICAgICAgICAgICAgICBmID0gYy5pbmRleChlWzBdKTtmID4gLTEgJiYgIWIucHJvcChcXFwiY2hlY2tlZFxcXCIpICYmIGQucHVzaChmKTtcXG4gICAgICAgIH0pLCB0aGlzLl91bmxvY2tDZWxscyh0aGlzLmVsZW1lbnQuZmluZChcXFwiLnVpLXRhYmxlLWNlbGwtaGlkZGVuLCAudWktdGFibGUtY2VsbC12aXNpYmxlXFxcIikpLCB0aGlzLl9hZGRUb2dnbGVzKHRoaXMuX21lbnUsIGIpLCBlID0gZC5sZW5ndGggLSAxOyBlID4gLTE7IGUtLSkge1xcbiAgICAgICAgICBjLmVxKGRbZV0pLmpxbURhdGEoXFxcImlucHV0XFxcIikucHJvcChcXFwiY2hlY2tlZFxcXCIsICExKS5jaGVja2JveHJhZGlvKFxcXCJyZWZyZXNoXFxcIikudHJpZ2dlcihcXFwiY2hhbmdlXFxcIik7XFxuICAgICAgICB9XFxuICAgICAgfSwgX3NldFRvZ2dsZVN0YXRlOiBmdW5jdGlvbiBfc2V0VG9nZ2xlU3RhdGUoKSB7XFxuICAgICAgICB0aGlzLl9tZW51LmZpbmQoXFxcImlucHV0XFxcIikuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHZhciBiID0gYSh0aGlzKTt0aGlzLmNoZWNrZWQgPSBcXFwidGFibGUtY2VsbFxcXCIgPT09IGIuanFtRGF0YShcXFwiY2VsbHNcXFwiKS5lcSgwKS5jc3MoXFxcImRpc3BsYXlcXFwiKSwgYi5jaGVja2JveHJhZGlvKFxcXCJyZWZyZXNoXFxcIik7XFxuICAgICAgICB9KTtcXG4gICAgICB9LCBfZGVzdHJveTogZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XFxuICAgICAgICB0aGlzLl9zdXBlcigpO1xcbiAgICAgIH0gfSk7XFxuICB9KGEpLCBmdW5jdGlvbiAoYSkge1xcbiAgICBhLndpZGdldChcXFwibW9iaWxlLnRhYmxlXFxcIiwgYS5tb2JpbGUudGFibGUsIHsgb3B0aW9uczogeyBtb2RlOiBcXFwicmVmbG93XFxcIiwgY2xhc3NlczogYS5leHRlbmQoYS5tb2JpbGUudGFibGUucHJvdG90eXBlLm9wdGlvbnMuY2xhc3NlcywgeyByZWZsb3dUYWJsZTogXFxcInVpLXRhYmxlLXJlZmxvd1xcXCIsIGNlbGxMYWJlbHM6IFxcXCJ1aS10YWJsZS1jZWxsLWxhYmVsXFxcIiB9KSB9LCBfY3JlYXRlOiBmdW5jdGlvbiBfY3JlYXRlKCkge1xcbiAgICAgICAgdGhpcy5fc3VwZXIoKSwgXFxcInJlZmxvd1xcXCIgPT09IHRoaXMub3B0aW9ucy5tb2RlICYmICh0aGlzLm9wdGlvbnMuZW5oYW5jZWQgfHwgKHRoaXMuZWxlbWVudC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuY2xhc3Nlcy5yZWZsb3dUYWJsZSksIHRoaXMuX3VwZGF0ZVJlZmxvdygpKSk7XFxuICAgICAgfSwgcmVidWlsZDogZnVuY3Rpb24gcmVidWlsZCgpIHtcXG4gICAgICAgIHRoaXMuX3N1cGVyKCksIFxcXCJyZWZsb3dcXFwiID09PSB0aGlzLm9wdGlvbnMubW9kZSAmJiB0aGlzLl9yZWZyZXNoKCExKTtcXG4gICAgICB9LCBfcmVmcmVzaDogZnVuY3Rpb24gX3JlZnJlc2goYSkge1xcbiAgICAgICAgdGhpcy5fc3VwZXIoYSksIGEgfHwgXFxcInJlZmxvd1xcXCIgIT09IHRoaXMub3B0aW9ucy5tb2RlIHx8IHRoaXMuX3VwZGF0ZVJlZmxvdygpO1xcbiAgICAgIH0sIF91cGRhdGVSZWZsb3c6IGZ1bmN0aW9uIF91cGRhdGVSZWZsb3coKSB7XFxuICAgICAgICB2YXIgYiA9IHRoaXMsXFxuICAgICAgICAgICAgYyA9IHRoaXMub3B0aW9uczthKGIuYWxsSGVhZGVycy5nZXQoKS5yZXZlcnNlKCkpLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICB2YXIgZCxcXG4gICAgICAgICAgICAgIGUsXFxuICAgICAgICAgICAgICBmID0gYSh0aGlzKS5qcW1EYXRhKFxcXCJjZWxsc1xcXCIpLFxcbiAgICAgICAgICAgICAgZyA9IGEubW9iaWxlLmdldEF0dHJpYnV0ZSh0aGlzLCBcXFwiY29sc3RhcnRcXFwiKSxcXG4gICAgICAgICAgICAgIGggPSBmLm5vdCh0aGlzKS5maWx0ZXIoXFxcInRoZWFkIHRoXFxcIikubGVuZ3RoICYmIFxcXCIgdWktdGFibGUtY2VsbC1sYWJlbC10b3BcXFwiLFxcbiAgICAgICAgICAgICAgaSA9IGEodGhpcykuY2xvbmUoKS5jb250ZW50cygpO2kubGVuZ3RoID4gMCAmJiAoaCA/IChkID0gcGFyc2VJbnQodGhpcy5nZXRBdHRyaWJ1dGUoXFxcImNvbHNwYW5cXFwiKSwgMTApLCBlID0gXFxcIlxcXCIsIGQgJiYgKGUgPSBcXFwidGQ6bnRoLWNoaWxkKFxcXCIgKyBkICsgXFxcIm4gKyBcXFwiICsgZyArIFxcXCIpXFxcIiksIGIuX2FkZExhYmVscyhmLmZpbHRlcihlKSwgYy5jbGFzc2VzLmNlbGxMYWJlbHMgKyBoLCBpKSkgOiBiLl9hZGRMYWJlbHMoZiwgYy5jbGFzc2VzLmNlbGxMYWJlbHMsIGkpKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH0sIF9hZGRMYWJlbHM6IGZ1bmN0aW9uIF9hZGRMYWJlbHMoYiwgYywgZCkge1xcbiAgICAgICAgMSA9PT0gZC5sZW5ndGggJiYgXFxcImFiYnJcXFwiID09PSBkWzBdLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgJiYgKGQgPSBkLmVxKDApLmF0dHIoXFxcInRpdGxlXFxcIikpLCBiLm5vdChcXFwiOmhhcyhiLlxcXCIgKyBjICsgXFxcIilcXFwiKS5wcmVwZW5kKGEoXFxcIjxiIGNsYXNzPSdcXFwiICsgYyArIFxcXCInPjwvYj5cXFwiKS5hcHBlbmQoZCkpO1xcbiAgICAgIH0gfSk7XFxuICB9KGEpLCBmdW5jdGlvbiAoYSwgYykge1xcbiAgICB2YXIgZCA9IGZ1bmN0aW9uIGQoYiwgYykge1xcbiAgICAgIHJldHVybiAtMSA9PT0gKFxcXCJcXFwiICsgKGEubW9iaWxlLmdldEF0dHJpYnV0ZSh0aGlzLCBcXFwiZmlsdGVydGV4dFxcXCIpIHx8IGEodGhpcykudGV4dCgpKSkudG9Mb3dlckNhc2UoKS5pbmRleE9mKGMpO1xcbiAgICB9O2Eud2lkZ2V0KFxcXCJtb2JpbGUuZmlsdGVyYWJsZVxcXCIsIHsgaW5pdFNlbGVjdG9yOiBcXFwiOmpxbURhdGEoZmlsdGVyPSd0cnVlJylcXFwiLCBvcHRpb25zOiB7IGZpbHRlclJldmVhbDogITEsIGZpbHRlckNhbGxiYWNrOiBkLCBlbmhhbmNlZDogITEsIGlucHV0OiBudWxsLCBjaGlsZHJlbjogXFxcIj4gbGksID4gb3B0aW9uLCA+IG9wdGdyb3VwIG9wdGlvbiwgPiB0Ym9keSB0ciwgPiAudWktY29udHJvbGdyb3VwLWNvbnRyb2xzID4gLnVpLWJ0biwgPiAudWktY29udHJvbGdyb3VwLWNvbnRyb2xzID4gLnVpLWNoZWNrYm94LCA+IC51aS1jb250cm9sZ3JvdXAtY29udHJvbHMgPiAudWktcmFkaW9cXFwiIH0sIF9jcmVhdGU6IGZ1bmN0aW9uIF9jcmVhdGUoKSB7XFxuICAgICAgICB2YXIgYiA9IHRoaXMub3B0aW9uczthLmV4dGVuZCh0aGlzLCB7IF9zZWFyY2g6IG51bGwsIF90aW1lcjogMCB9KSwgdGhpcy5fc2V0SW5wdXQoYi5pbnB1dCksIGIuZW5oYW5jZWQgfHwgdGhpcy5fZmlsdGVySXRlbXMoKHRoaXMuX3NlYXJjaCAmJiB0aGlzLl9zZWFyY2gudmFsKCkgfHwgXFxcIlxcXCIpLnRvTG93ZXJDYXNlKCkpO1xcbiAgICAgIH0sIF9vbktleVVwOiBmdW5jdGlvbiBfb25LZXlVcCgpIHtcXG4gICAgICAgIHZhciBjLFxcbiAgICAgICAgICAgIGQsXFxuICAgICAgICAgICAgZSA9IHRoaXMuX3NlYXJjaDtpZiAoZSkge1xcbiAgICAgICAgICBpZiAoYyA9IGUudmFsKCkudG9Mb3dlckNhc2UoKSwgZCA9IGEubW9iaWxlLmdldEF0dHJpYnV0ZShlWzBdLCBcXFwibGFzdHZhbFxcXCIpICsgXFxcIlxcXCIsIGQgJiYgZCA9PT0gYykgcmV0dXJuO3RoaXMuX3RpbWVyICYmIChiLmNsZWFyVGltZW91dCh0aGlzLl90aW1lciksIHRoaXMuX3RpbWVyID0gMCksIHRoaXMuX3RpbWVyID0gdGhpcy5fZGVsYXkoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90cmlnZ2VyKFxcXCJiZWZvcmVmaWx0ZXJcXFwiLCBudWxsLCB7IGlucHV0OiBlIH0pID09PSAhMSA/ICExIDogKGVbMF0uc2V0QXR0cmlidXRlKFxcXCJkYXRhLVxcXCIgKyBhLm1vYmlsZS5ucyArIFxcXCJsYXN0dmFsXFxcIiwgYyksIHRoaXMuX2ZpbHRlckl0ZW1zKGMpLCB2b2lkICh0aGlzLl90aW1lciA9IDApKTtcXG4gICAgICAgICAgfSwgMjUwKTtcXG4gICAgICAgIH1cXG4gICAgICB9LCBfZ2V0RmlsdGVyYWJsZUl0ZW1zOiBmdW5jdGlvbiBfZ2V0RmlsdGVyYWJsZUl0ZW1zKCkge1xcbiAgICAgICAgdmFyIGIgPSB0aGlzLmVsZW1lbnQsXFxuICAgICAgICAgICAgYyA9IHRoaXMub3B0aW9ucy5jaGlsZHJlbixcXG4gICAgICAgICAgICBkID0gYyA/IGEuaXNGdW5jdGlvbihjKSA/IGMoKSA6IGMubm9kZU5hbWUgPyBhKGMpIDogYy5qcXVlcnkgPyBjIDogdGhpcy5lbGVtZW50LmZpbmQoYykgOiB7IGxlbmd0aDogMCB9O3JldHVybiAwID09PSBkLmxlbmd0aCAmJiAoZCA9IGIuY2hpbGRyZW4oKSksIGQ7XFxuICAgICAgfSwgX2ZpbHRlckl0ZW1zOiBmdW5jdGlvbiBfZmlsdGVySXRlbXMoYikge1xcbiAgICAgICAgdmFyIGMsXFxuICAgICAgICAgICAgZSxcXG4gICAgICAgICAgICBmLFxcbiAgICAgICAgICAgIGcsXFxuICAgICAgICAgICAgaCA9IFtdLFxcbiAgICAgICAgICAgIGkgPSBbXSxcXG4gICAgICAgICAgICBqID0gdGhpcy5vcHRpb25zLFxcbiAgICAgICAgICAgIGsgPSB0aGlzLl9nZXRGaWx0ZXJhYmxlSXRlbXMoKTtpZiAobnVsbCAhPSBiKSBmb3IgKGUgPSBqLmZpbHRlckNhbGxiYWNrIHx8IGQsIGYgPSBrLmxlbmd0aCwgYyA9IDA7IGYgPiBjOyBjKyspIHtcXG4gICAgICAgICAgZyA9IGUuY2FsbChrW2NdLCBjLCBiKSA/IGkgOiBoLCBnLnB1c2goa1tjXSk7XFxuICAgICAgICB9MCA9PT0gaS5sZW5ndGggPyBrW2ouZmlsdGVyUmV2ZWFsICYmIDAgPT09IGIubGVuZ3RoID8gXFxcImFkZENsYXNzXFxcIiA6IFxcXCJyZW1vdmVDbGFzc1xcXCJdKFxcXCJ1aS1zY3JlZW4taGlkZGVuXFxcIikgOiAoYShpKS5hZGRDbGFzcyhcXFwidWktc2NyZWVuLWhpZGRlblxcXCIpLCBhKGgpLnJlbW92ZUNsYXNzKFxcXCJ1aS1zY3JlZW4taGlkZGVuXFxcIikpLCB0aGlzLl9yZWZyZXNoQ2hpbGRXaWRnZXQoKSwgdGhpcy5fdHJpZ2dlcihcXFwiZmlsdGVyXFxcIiwgbnVsbCwgeyBpdGVtczogayB9KTtcXG4gICAgICB9LCBfcmVmcmVzaENoaWxkV2lkZ2V0OiBmdW5jdGlvbiBfcmVmcmVzaENoaWxkV2lkZ2V0KCkge1xcbiAgICAgICAgdmFyIGIsXFxuICAgICAgICAgICAgYyxcXG4gICAgICAgICAgICBkID0gW1xcXCJjb2xsYXBzaWJsZXNldFxcXCIsIFxcXCJzZWxlY3RtZW51XFxcIiwgXFxcImNvbnRyb2xncm91cFxcXCIsIFxcXCJsaXN0dmlld1xcXCJdO2ZvciAoYyA9IGQubGVuZ3RoIC0gMTsgYyA+IC0xOyBjLS0pIHtcXG4gICAgICAgICAgYiA9IGRbY10sIGEubW9iaWxlW2JdICYmIChiID0gdGhpcy5lbGVtZW50LmRhdGEoXFxcIm1vYmlsZS1cXFwiICsgYiksIGIgJiYgYS5pc0Z1bmN0aW9uKGIucmVmcmVzaCkgJiYgYi5yZWZyZXNoKCkpO1xcbiAgICAgICAgfVxcbiAgICAgIH0sIF9zZXRJbnB1dDogZnVuY3Rpb24gX3NldElucHV0KGMpIHtcXG4gICAgICAgIHZhciBkID0gdGhpcy5fc2VhcmNoO3RoaXMuX3RpbWVyICYmIChiLmNsZWFyVGltZW91dCh0aGlzLl90aW1lciksIHRoaXMuX3RpbWVyID0gMCksIGQgJiYgKHRoaXMuX29mZihkLCBcXFwia2V5dXAgY2hhbmdlIGlucHV0XFxcIiksIGQgPSBudWxsKSwgYyAmJiAoZCA9IGMuanF1ZXJ5ID8gYyA6IGMubm9kZU5hbWUgPyBhKGMpIDogdGhpcy5kb2N1bWVudC5maW5kKGMpLCB0aGlzLl9vbihkLCB7IGtleWRvd246IFxcXCJfb25LZXlEb3duXFxcIiwga2V5cHJlc3M6IFxcXCJfb25LZXlQcmVzc1xcXCIsIGtleXVwOiBcXFwiX29uS2V5VXBcXFwiLCBjaGFuZ2U6IFxcXCJfb25LZXlVcFxcXCIsIGlucHV0OiBcXFwiX29uS2V5VXBcXFwiIH0pKSwgdGhpcy5fc2VhcmNoID0gZDtcXG4gICAgICB9LCBfb25LZXlEb3duOiBmdW5jdGlvbiBfb25LZXlEb3duKGIpIHtcXG4gICAgICAgIGIua2V5Q29kZSA9PT0gYS51aS5rZXlDb2RlLkVOVEVSICYmIChiLnByZXZlbnREZWZhdWx0KCksIHRoaXMuX3ByZXZlbnRLZXlQcmVzcyA9ICEwKTtcXG4gICAgICB9LCBfb25LZXlQcmVzczogZnVuY3Rpb24gX29uS2V5UHJlc3MoYSkge1xcbiAgICAgICAgdGhpcy5fcHJldmVudEtleVByZXNzICYmIChhLnByZXZlbnREZWZhdWx0KCksIHRoaXMuX3ByZXZlbnRLZXlQcmVzcyA9ICExKTtcXG4gICAgICB9LCBfc2V0T3B0aW9uczogZnVuY3Rpb24gX3NldE9wdGlvbnMoYSkge1xcbiAgICAgICAgdmFyIGIgPSAhKGEuZmlsdGVyUmV2ZWFsID09PSBjICYmIGEuZmlsdGVyQ2FsbGJhY2sgPT09IGMgJiYgYS5jaGlsZHJlbiA9PT0gYyk7dGhpcy5fc3VwZXIoYSksIGEuaW5wdXQgIT09IGMgJiYgKHRoaXMuX3NldElucHV0KGEuaW5wdXQpLCBiID0gITApLCBiICYmIHRoaXMucmVmcmVzaCgpO1xcbiAgICAgIH0sIF9kZXN0cm95OiBmdW5jdGlvbiBfZGVzdHJveSgpIHtcXG4gICAgICAgIHZhciBhID0gdGhpcy5vcHRpb25zLFxcbiAgICAgICAgICAgIGIgPSB0aGlzLl9nZXRGaWx0ZXJhYmxlSXRlbXMoKTthLmVuaGFuY2VkID8gYi50b2dnbGVDbGFzcyhcXFwidWktc2NyZWVuLWhpZGRlblxcXCIsIGEuZmlsdGVyUmV2ZWFsKSA6IGIucmVtb3ZlQ2xhc3MoXFxcInVpLXNjcmVlbi1oaWRkZW5cXFwiKTtcXG4gICAgICB9LCByZWZyZXNoOiBmdW5jdGlvbiByZWZyZXNoKCkge1xcbiAgICAgICAgdGhpcy5fdGltZXIgJiYgKGIuY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKSwgdGhpcy5fdGltZXIgPSAwKSwgdGhpcy5fZmlsdGVySXRlbXMoKHRoaXMuX3NlYXJjaCAmJiB0aGlzLl9zZWFyY2gudmFsKCkgfHwgXFxcIlxcXCIpLnRvTG93ZXJDYXNlKCkpO1xcbiAgICAgIH0gfSk7XFxuICB9KGEpLCBmdW5jdGlvbiAoYSwgYikge1xcbiAgICB2YXIgYyA9IGZ1bmN0aW9uIGMoYSwgYikge1xcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYykge1xcbiAgICAgICAgYi5jYWxsKHRoaXMsIGMpLCBhLl9zeW5jVGV4dElucHV0T3B0aW9ucyhjKTtcXG4gICAgICB9O1xcbiAgICB9LFxcbiAgICAgICAgZCA9IC8oXnxcXFxccyl1aS1saS1kaXZpZGVyKFxcXFxzfCQpLyxcXG4gICAgICAgIGUgPSBhLm1vYmlsZS5maWx0ZXJhYmxlLnByb3RvdHlwZS5vcHRpb25zLmZpbHRlckNhbGxiYWNrO2EubW9iaWxlLmZpbHRlcmFibGUucHJvdG90eXBlLm9wdGlvbnMuZmlsdGVyQ2FsbGJhY2sgPSBmdW5jdGlvbiAoYSwgYikge1xcbiAgICAgIHJldHVybiAhdGhpcy5jbGFzc05hbWUubWF0Y2goZCkgJiYgZS5jYWxsKHRoaXMsIGEsIGIpO1xcbiAgICB9LCBhLndpZGdldChcXFwibW9iaWxlLmZpbHRlcmFibGVcXFwiLCBhLm1vYmlsZS5maWx0ZXJhYmxlLCB7IG9wdGlvbnM6IHsgZmlsdGVyUGxhY2Vob2xkZXI6IFxcXCJGaWx0ZXIgaXRlbXMuLi5cXFwiLCBmaWx0ZXJUaGVtZTogbnVsbCB9LCBfY3JlYXRlOiBmdW5jdGlvbiBfY3JlYXRlKCkge1xcbiAgICAgICAgdmFyIGIsXFxuICAgICAgICAgICAgYyxcXG4gICAgICAgICAgICBkID0gdGhpcy5lbGVtZW50LFxcbiAgICAgICAgICAgIGUgPSBbXFxcImNvbGxhcHNpYmxlc2V0XFxcIiwgXFxcInNlbGVjdG1lbnVcXFwiLCBcXFwiY29udHJvbGdyb3VwXFxcIiwgXFxcImxpc3R2aWV3XFxcIl0sXFxuICAgICAgICAgICAgZiA9IHt9O2ZvciAodGhpcy5fc3VwZXIoKSwgYS5leHRlbmQodGhpcywgeyBfd2lkZ2V0OiBudWxsIH0pLCBiID0gZS5sZW5ndGggLSAxOyBiID4gLTE7IGItLSkge1xcbiAgICAgICAgICBpZiAoYyA9IGVbYl0sIGEubW9iaWxlW2NdKSB7XFxuICAgICAgICAgICAgaWYgKHRoaXMuX3NldFdpZGdldChkLmRhdGEoXFxcIm1vYmlsZS1cXFwiICsgYykpKSBicmVhaztmW2MgKyBcXFwiY3JlYXRlXFxcIl0gPSBcXFwiX2hhbmRsZUNyZWF0ZVxcXCI7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH10aGlzLl93aWRnZXQgfHwgdGhpcy5fb24oZCwgZik7XFxuICAgICAgfSwgX2hhbmRsZUNyZWF0ZTogZnVuY3Rpb24gX2hhbmRsZUNyZWF0ZShhKSB7XFxuICAgICAgICB0aGlzLl9zZXRXaWRnZXQodGhpcy5lbGVtZW50LmRhdGEoXFxcIm1vYmlsZS1cXFwiICsgYS50eXBlLnN1YnN0cmluZygwLCBhLnR5cGUubGVuZ3RoIC0gNikpKTtcXG4gICAgICB9LCBfdHJpZ2dlcjogZnVuY3Rpb24gX3RyaWdnZXIoYSwgYiwgYykge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dpZGdldCAmJiBcXFwibW9iaWxlLWxpc3R2aWV3XFxcIiA9PT0gdGhpcy5fd2lkZ2V0LndpZGdldEZ1bGxOYW1lICYmIFxcXCJiZWZvcmVmaWx0ZXJcXFwiID09PSBhICYmIHRoaXMuX3dpZGdldC5fdHJpZ2dlcihcXFwiYmVmb3JlZmlsdGVyXFxcIiwgYiwgYyksIHRoaXMuX3N1cGVyKGEsIGIsIGMpO1xcbiAgICAgIH0sIF9zZXRXaWRnZXQ6IGZ1bmN0aW9uIF9zZXRXaWRnZXQoYSkge1xcbiAgICAgICAgcmV0dXJuICF0aGlzLl93aWRnZXQgJiYgYSAmJiAodGhpcy5fd2lkZ2V0ID0gYSwgdGhpcy5fd2lkZ2V0Ll9zZXRPcHRpb25zID0gYyh0aGlzLCB0aGlzLl93aWRnZXQuX3NldE9wdGlvbnMpKSwgdGhpcy5fd2lkZ2V0ICYmICh0aGlzLl9zeW5jVGV4dElucHV0T3B0aW9ucyh0aGlzLl93aWRnZXQub3B0aW9ucyksIFxcXCJsaXN0dmlld1xcXCIgPT09IHRoaXMuX3dpZGdldC53aWRnZXROYW1lICYmICh0aGlzLl93aWRnZXQub3B0aW9ucy5oaWRlRGl2aWRlcnMgPSAhMCwgdGhpcy5fd2lkZ2V0LmVsZW1lbnQubGlzdHZpZXcoXFxcInJlZnJlc2hcXFwiKSkpLCAhIXRoaXMuX3dpZGdldDtcXG4gICAgICB9LCBfaXNTZWFyY2hJbnRlcm5hbDogZnVuY3Rpb24gX2lzU2VhcmNoSW50ZXJuYWwoKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5fc2VhcmNoICYmIHRoaXMuX3NlYXJjaC5qcW1EYXRhKFxcXCJ1aS1maWx0ZXJhYmxlLVxcXCIgKyB0aGlzLnV1aWQgKyBcXFwiLWludGVybmFsXFxcIik7XFxuICAgICAgfSwgX3NldElucHV0OiBmdW5jdGlvbiBfc2V0SW5wdXQoYikge1xcbiAgICAgICAgdmFyIGMgPSB0aGlzLm9wdGlvbnMsXFxuICAgICAgICAgICAgZCA9ICEwLFxcbiAgICAgICAgICAgIGUgPSB7fTtpZiAoIWIpIHtcXG4gICAgICAgICAgaWYgKHRoaXMuX2lzU2VhcmNoSW50ZXJuYWwoKSkgcmV0dXJuO2QgPSAhMSwgYiA9IGEoXFxcIjxpbnB1dCBkYXRhLVxcXCIgKyBhLm1vYmlsZS5ucyArIFxcXCJ0eXBlPSdzZWFyY2gnIHBsYWNlaG9sZGVyPSdcXFwiICsgYy5maWx0ZXJQbGFjZWhvbGRlciArIFxcXCInPjwvaW5wdXQ+XFxcIikuanFtRGF0YShcXFwidWktZmlsdGVyYWJsZS1cXFwiICsgdGhpcy51dWlkICsgXFxcIi1pbnRlcm5hbFxcXCIsICEwKSwgYShcXFwiPGZvcm0gY2xhc3M9J3VpLWZpbHRlcmFibGUnPjwvZm9ybT5cXFwiKS5hcHBlbmQoYikuc3VibWl0KGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICAgICAgYS5wcmV2ZW50RGVmYXVsdCgpLCBiLmJsdXIoKTtcXG4gICAgICAgICAgfSkuaW5zZXJ0QmVmb3JlKHRoaXMuZWxlbWVudCksIGEubW9iaWxlLnRleHRpbnB1dCAmJiAobnVsbCAhPSB0aGlzLm9wdGlvbnMuZmlsdGVyVGhlbWUgJiYgKGUudGhlbWUgPSBjLmZpbHRlclRoZW1lKSwgYi50ZXh0aW5wdXQoZSkpO1xcbiAgICAgICAgfXRoaXMuX3N1cGVyKGIpLCB0aGlzLl9pc1NlYXJjaEludGVybmFsKCkgJiYgZCAmJiB0aGlzLl9zZWFyY2guYXR0cihcXFwicGxhY2Vob2xkZXJcXFwiLCB0aGlzLm9wdGlvbnMuZmlsdGVyUGxhY2Vob2xkZXIpO1xcbiAgICAgIH0sIF9zZXRPcHRpb25zOiBmdW5jdGlvbiBfc2V0T3B0aW9ucyhjKSB7XFxuICAgICAgICB2YXIgZCA9IHRoaXMuX3N1cGVyKGMpO3JldHVybiBjLmZpbHRlclBsYWNlaG9sZGVyICE9PSBiICYmIHRoaXMuX2lzU2VhcmNoSW50ZXJuYWwoKSAmJiB0aGlzLl9zZWFyY2guYXR0cihcXFwicGxhY2Vob2xkZXJcXFwiLCBjLmZpbHRlclBsYWNlaG9sZGVyKSwgYy5maWx0ZXJUaGVtZSAhPT0gYiAmJiB0aGlzLl9zZWFyY2ggJiYgYS5tb2JpbGUudGV4dGlucHV0ICYmIHRoaXMuX3NlYXJjaC50ZXh0aW5wdXQoXFxcIm9wdGlvblxcXCIsIFxcXCJ0aGVtZVxcXCIsIGMuZmlsdGVyVGhlbWUpLCBkO1xcbiAgICAgIH0sIF9yZWZyZXNoQ2hpbGRXaWRnZXQ6IGZ1bmN0aW9uIF9yZWZyZXNoQ2hpbGRXaWRnZXQoKSB7XFxuICAgICAgICB0aGlzLl9yZWZyZXNoaW5nQ2hpbGRXaWRnZXQgPSAhMCwgdGhpcy5fc3VwZXJBcHBseShhcmd1bWVudHMpLCB0aGlzLl9yZWZyZXNoaW5nQ2hpbGRXaWRnZXQgPSAhMTtcXG4gICAgICB9LCByZWZyZXNoOiBmdW5jdGlvbiByZWZyZXNoKCkge1xcbiAgICAgICAgdGhpcy5fcmVmcmVzaGluZ0NoaWxkV2lkZ2V0IHx8IHRoaXMuX3N1cGVyQXBwbHkoYXJndW1lbnRzKTtcXG4gICAgICB9LCBfZGVzdHJveTogZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XFxuICAgICAgICB0aGlzLl9pc1NlYXJjaEludGVybmFsKCkgJiYgdGhpcy5fc2VhcmNoLnJlbW92ZSgpLCB0aGlzLl9zdXBlcigpO1xcbiAgICAgIH0sIF9zeW5jVGV4dElucHV0T3B0aW9uczogZnVuY3Rpb24gX3N5bmNUZXh0SW5wdXRPcHRpb25zKGMpIHtcXG4gICAgICAgIHZhciBkLFxcbiAgICAgICAgICAgIGUgPSB7fTtpZiAodGhpcy5faXNTZWFyY2hJbnRlcm5hbCgpICYmIGEubW9iaWxlLnRleHRpbnB1dCkge1xcbiAgICAgICAgICBmb3IgKGQgaW4gYS5tb2JpbGUudGV4dGlucHV0LnByb3RvdHlwZS5vcHRpb25zKSB7XFxuICAgICAgICAgICAgY1tkXSAhPT0gYiAmJiAoZVtkXSA9IFxcXCJ0aGVtZVxcXCIgPT09IGQgJiYgbnVsbCAhPSB0aGlzLm9wdGlvbnMuZmlsdGVyVGhlbWUgPyB0aGlzLm9wdGlvbnMuZmlsdGVyVGhlbWUgOiBjW2RdKTtcXG4gICAgICAgICAgfXRoaXMuX3NlYXJjaC50ZXh0aW5wdXQoXFxcIm9wdGlvblxcXCIsIGUpO1xcbiAgICAgICAgfVxcbiAgICAgIH0gfSksIGEud2lkZ2V0KFxcXCJtb2JpbGUubGlzdHZpZXdcXFwiLCBhLm1vYmlsZS5saXN0dmlldywgeyBvcHRpb25zOiB7IGZpbHRlcjogITEgfSwgX2NyZWF0ZTogZnVuY3Rpb24gX2NyZWF0ZSgpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZmlsdGVyICE9PSAhMCB8fCB0aGlzLmVsZW1lbnQuZGF0YShcXFwibW9iaWxlLWZpbHRlcmFibGVcXFwiKSB8fCB0aGlzLmVsZW1lbnQuZmlsdGVyYWJsZSgpLCB0aGlzLl9zdXBlcigpO1xcbiAgICAgIH0sIHJlZnJlc2g6IGZ1bmN0aW9uIHJlZnJlc2goKSB7XFxuICAgICAgICB2YXIgYTt0aGlzLl9zdXBlckFwcGx5KGFyZ3VtZW50cyksIHRoaXMub3B0aW9ucy5maWx0ZXIgPT09ICEwICYmIChhID0gdGhpcy5lbGVtZW50LmRhdGEoXFxcIm1vYmlsZS1maWx0ZXJhYmxlXFxcIiksIGEgJiYgYS5yZWZyZXNoKCkpO1xcbiAgICAgIH0gfSk7XFxuICB9KGEpLCBmdW5jdGlvbiAoYSwgYikge1xcbiAgICBmdW5jdGlvbiBjKCkge1xcbiAgICAgIHJldHVybiArK2U7XFxuICAgIH1mdW5jdGlvbiBkKGEpIHtcXG4gICAgICByZXR1cm4gYS5oYXNoLmxlbmd0aCA+IDEgJiYgZGVjb2RlVVJJQ29tcG9uZW50KGEuaHJlZi5yZXBsYWNlKGYsIFxcXCJcXFwiKSkgPT09IGRlY29kZVVSSUNvbXBvbmVudChsb2NhdGlvbi5ocmVmLnJlcGxhY2UoZiwgXFxcIlxcXCIpKTtcXG4gICAgfXZhciBlID0gMCxcXG4gICAgICAgIGYgPSAvIy4qJC87YS53aWRnZXQoXFxcInVpLnRhYnNcXFwiLCB7IHZlcnNpb246IFxcXCJmYWRmMmIzMTJhMDUwNDA0MzY0NTFjNjRiYmZhZjQ4MTRiYzYyYzU2XFxcIiwgZGVsYXk6IDMwMCwgb3B0aW9uczogeyBhY3RpdmU6IG51bGwsIGNvbGxhcHNpYmxlOiAhMSwgZXZlbnQ6IFxcXCJjbGlja1xcXCIsIGhlaWdodFN0eWxlOiBcXFwiY29udGVudFxcXCIsIGhpZGU6IG51bGwsIHNob3c6IG51bGwsIGFjdGl2YXRlOiBudWxsLCBiZWZvcmVBY3RpdmF0ZTogbnVsbCwgYmVmb3JlTG9hZDogbnVsbCwgbG9hZDogbnVsbCB9LCBfY3JlYXRlOiBmdW5jdGlvbiBfY3JlYXRlKCkge1xcbiAgICAgICAgdmFyIGIgPSB0aGlzLFxcbiAgICAgICAgICAgIGMgPSB0aGlzLm9wdGlvbnM7dGhpcy5ydW5uaW5nID0gITEsIHRoaXMuZWxlbWVudC5hZGRDbGFzcyhcXFwidWktdGFicyB1aS13aWRnZXQgdWktd2lkZ2V0LWNvbnRlbnQgdWktY29ybmVyLWFsbFxcXCIpLnRvZ2dsZUNsYXNzKFxcXCJ1aS10YWJzLWNvbGxhcHNpYmxlXFxcIiwgYy5jb2xsYXBzaWJsZSkuZGVsZWdhdGUoXFxcIi51aS10YWJzLW5hdiA+IGxpXFxcIiwgXFxcIm1vdXNlZG93blxcXCIgKyB0aGlzLmV2ZW50TmFtZXNwYWNlLCBmdW5jdGlvbiAoYikge1xcbiAgICAgICAgICBhKHRoaXMpLmlzKFxcXCIudWktc3RhdGUtZGlzYWJsZWRcXFwiKSAmJiBiLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICB9KS5kZWxlZ2F0ZShcXFwiLnVpLXRhYnMtYW5jaG9yXFxcIiwgXFxcImZvY3VzXFxcIiArIHRoaXMuZXZlbnROYW1lc3BhY2UsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgYSh0aGlzKS5jbG9zZXN0KFxcXCJsaVxcXCIpLmlzKFxcXCIudWktc3RhdGUtZGlzYWJsZWRcXFwiKSAmJiB0aGlzLmJsdXIoKTtcXG4gICAgICAgIH0pLCB0aGlzLl9wcm9jZXNzVGFicygpLCBjLmFjdGl2ZSA9IHRoaXMuX2luaXRpYWxBY3RpdmUoKSwgYS5pc0FycmF5KGMuZGlzYWJsZWQpICYmIChjLmRpc2FibGVkID0gYS51bmlxdWUoYy5kaXNhYmxlZC5jb25jYXQoYS5tYXAodGhpcy50YWJzLmZpbHRlcihcXFwiLnVpLXN0YXRlLWRpc2FibGVkXFxcIiksIGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICAgIHJldHVybiBiLnRhYnMuaW5kZXgoYSk7XFxuICAgICAgICB9KSkpLnNvcnQoKSksIHRoaXMuYWN0aXZlID0gdGhpcy5vcHRpb25zLmFjdGl2ZSAhPT0gITEgJiYgdGhpcy5hbmNob3JzLmxlbmd0aCA/IHRoaXMuX2ZpbmRBY3RpdmUoYy5hY3RpdmUpIDogYSgpLCB0aGlzLl9yZWZyZXNoKCksIHRoaXMuYWN0aXZlLmxlbmd0aCAmJiB0aGlzLmxvYWQoYy5hY3RpdmUpO1xcbiAgICAgIH0sIF9pbml0aWFsQWN0aXZlOiBmdW5jdGlvbiBfaW5pdGlhbEFjdGl2ZSgpIHtcXG4gICAgICAgIHZhciBiID0gdGhpcy5vcHRpb25zLmFjdGl2ZSxcXG4gICAgICAgICAgICBjID0gdGhpcy5vcHRpb25zLmNvbGxhcHNpYmxlLFxcbiAgICAgICAgICAgIGQgPSBsb2NhdGlvbi5oYXNoLnN1YnN0cmluZygxKTtyZXR1cm4gbnVsbCA9PT0gYiAmJiAoZCAmJiB0aGlzLnRhYnMuZWFjaChmdW5jdGlvbiAoYywgZSkge1xcbiAgICAgICAgICByZXR1cm4gYShlKS5hdHRyKFxcXCJhcmlhLWNvbnRyb2xzXFxcIikgPT09IGQgPyAoYiA9IGMsICExKSA6IHZvaWQgMDtcXG4gICAgICAgIH0pLCBudWxsID09PSBiICYmIChiID0gdGhpcy50YWJzLmluZGV4KHRoaXMudGFicy5maWx0ZXIoXFxcIi51aS10YWJzLWFjdGl2ZVxcXCIpKSksIChudWxsID09PSBiIHx8IC0xID09PSBiKSAmJiAoYiA9IHRoaXMudGFicy5sZW5ndGggPyAwIDogITEpKSwgYiAhPT0gITEgJiYgKGIgPSB0aGlzLnRhYnMuaW5kZXgodGhpcy50YWJzLmVxKGIpKSwgLTEgPT09IGIgJiYgKGIgPSBjID8gITEgOiAwKSksICFjICYmIGIgPT09ICExICYmIHRoaXMuYW5jaG9ycy5sZW5ndGggJiYgKGIgPSAwKSwgYjtcXG4gICAgICB9LCBfZ2V0Q3JlYXRlRXZlbnREYXRhOiBmdW5jdGlvbiBfZ2V0Q3JlYXRlRXZlbnREYXRhKCkge1xcbiAgICAgICAgcmV0dXJuIHsgdGFiOiB0aGlzLmFjdGl2ZSwgcGFuZWw6IHRoaXMuYWN0aXZlLmxlbmd0aCA/IHRoaXMuX2dldFBhbmVsRm9yVGFiKHRoaXMuYWN0aXZlKSA6IGEoKSB9O1xcbiAgICAgIH0sIF90YWJLZXlkb3duOiBmdW5jdGlvbiBfdGFiS2V5ZG93bihiKSB7XFxuICAgICAgICB2YXIgYyA9IGEodGhpcy5kb2N1bWVudFswXS5hY3RpdmVFbGVtZW50KS5jbG9zZXN0KFxcXCJsaVxcXCIpLFxcbiAgICAgICAgICAgIGQgPSB0aGlzLnRhYnMuaW5kZXgoYyksXFxuICAgICAgICAgICAgZSA9ICEwO2lmICghdGhpcy5faGFuZGxlUGFnZU5hdihiKSkge1xcbiAgICAgICAgICBzd2l0Y2ggKGIua2V5Q29kZSkge2Nhc2UgYS51aS5rZXlDb2RlLlJJR0hUOmNhc2UgYS51aS5rZXlDb2RlLkRPV046XFxuICAgICAgICAgICAgICBkKys7YnJlYWs7Y2FzZSBhLnVpLmtleUNvZGUuVVA6Y2FzZSBhLnVpLmtleUNvZGUuTEVGVDpcXG4gICAgICAgICAgICAgIGUgPSAhMSwgZC0tO2JyZWFrO2Nhc2UgYS51aS5rZXlDb2RlLkVORDpcXG4gICAgICAgICAgICAgIGQgPSB0aGlzLmFuY2hvcnMubGVuZ3RoIC0gMTticmVhaztjYXNlIGEudWkua2V5Q29kZS5IT01FOlxcbiAgICAgICAgICAgICAgZCA9IDA7YnJlYWs7Y2FzZSBhLnVpLmtleUNvZGUuU1BBQ0U6XFxuICAgICAgICAgICAgICByZXR1cm4gYi5wcmV2ZW50RGVmYXVsdCgpLCBjbGVhclRpbWVvdXQodGhpcy5hY3RpdmF0aW5nKSwgdm9pZCB0aGlzLl9hY3RpdmF0ZShkKTtjYXNlIGEudWkua2V5Q29kZS5FTlRFUjpcXG4gICAgICAgICAgICAgIHJldHVybiBiLnByZXZlbnREZWZhdWx0KCksIGNsZWFyVGltZW91dCh0aGlzLmFjdGl2YXRpbmcpLCB2b2lkIHRoaXMuX2FjdGl2YXRlKGQgPT09IHRoaXMub3B0aW9ucy5hY3RpdmUgPyAhMSA6IGQpO2RlZmF1bHQ6XFxuICAgICAgICAgICAgICByZXR1cm47fWIucHJldmVudERlZmF1bHQoKSwgY2xlYXJUaW1lb3V0KHRoaXMuYWN0aXZhdGluZyksIGQgPSB0aGlzLl9mb2N1c05leHRUYWIoZCwgZSksIGIuY3RybEtleSB8fCAoYy5hdHRyKFxcXCJhcmlhLXNlbGVjdGVkXFxcIiwgXFxcImZhbHNlXFxcIiksIHRoaXMudGFicy5lcShkKS5hdHRyKFxcXCJhcmlhLXNlbGVjdGVkXFxcIiwgXFxcInRydWVcXFwiKSwgdGhpcy5hY3RpdmF0aW5nID0gdGhpcy5fZGVsYXkoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIHRoaXMub3B0aW9uKFxcXCJhY3RpdmVcXFwiLCBkKTtcXG4gICAgICAgICAgfSwgdGhpcy5kZWxheSkpO1xcbiAgICAgICAgfVxcbiAgICAgIH0sIF9wYW5lbEtleWRvd246IGZ1bmN0aW9uIF9wYW5lbEtleWRvd24oYikge1xcbiAgICAgICAgdGhpcy5faGFuZGxlUGFnZU5hdihiKSB8fCBiLmN0cmxLZXkgJiYgYi5rZXlDb2RlID09PSBhLnVpLmtleUNvZGUuVVAgJiYgKGIucHJldmVudERlZmF1bHQoKSwgdGhpcy5hY3RpdmUuZm9jdXMoKSk7XFxuICAgICAgfSwgX2hhbmRsZVBhZ2VOYXY6IGZ1bmN0aW9uIF9oYW5kbGVQYWdlTmF2KGIpIHtcXG4gICAgICAgIHJldHVybiBiLmFsdEtleSAmJiBiLmtleUNvZGUgPT09IGEudWkua2V5Q29kZS5QQUdFX1VQID8gKHRoaXMuX2FjdGl2YXRlKHRoaXMuX2ZvY3VzTmV4dFRhYih0aGlzLm9wdGlvbnMuYWN0aXZlIC0gMSwgITEpKSwgITApIDogYi5hbHRLZXkgJiYgYi5rZXlDb2RlID09PSBhLnVpLmtleUNvZGUuUEFHRV9ET1dOID8gKHRoaXMuX2FjdGl2YXRlKHRoaXMuX2ZvY3VzTmV4dFRhYih0aGlzLm9wdGlvbnMuYWN0aXZlICsgMSwgITApKSwgITApIDogdm9pZCAwO1xcbiAgICAgIH0sIF9maW5kTmV4dFRhYjogZnVuY3Rpb24gX2ZpbmROZXh0VGFiKGIsIGMpIHtcXG4gICAgICAgIGZ1bmN0aW9uIGQoKSB7XFxuICAgICAgICAgIHJldHVybiBiID4gZSAmJiAoYiA9IDApLCAwID4gYiAmJiAoYiA9IGUpLCBiO1xcbiAgICAgICAgfWZvciAodmFyIGUgPSB0aGlzLnRhYnMubGVuZ3RoIC0gMTsgLTEgIT09IGEuaW5BcnJheShkKCksIHRoaXMub3B0aW9ucy5kaXNhYmxlZCk7KSB7XFxuICAgICAgICAgIGIgPSBjID8gYiArIDEgOiBiIC0gMTtcXG4gICAgICAgIH1yZXR1cm4gYjtcXG4gICAgICB9LCBfZm9jdXNOZXh0VGFiOiBmdW5jdGlvbiBfZm9jdXNOZXh0VGFiKGEsIGIpIHtcXG4gICAgICAgIHJldHVybiBhID0gdGhpcy5fZmluZE5leHRUYWIoYSwgYiksIHRoaXMudGFicy5lcShhKS5mb2N1cygpLCBhO1xcbiAgICAgIH0sIF9zZXRPcHRpb246IGZ1bmN0aW9uIF9zZXRPcHRpb24oYSwgYikge1xcbiAgICAgICAgcmV0dXJuIFxcXCJhY3RpdmVcXFwiID09PSBhID8gdm9pZCB0aGlzLl9hY3RpdmF0ZShiKSA6IFxcXCJkaXNhYmxlZFxcXCIgPT09IGEgPyB2b2lkIHRoaXMuX3NldHVwRGlzYWJsZWQoYikgOiAodGhpcy5fc3VwZXIoYSwgYiksIFxcXCJjb2xsYXBzaWJsZVxcXCIgPT09IGEgJiYgKHRoaXMuZWxlbWVudC50b2dnbGVDbGFzcyhcXFwidWktdGFicy1jb2xsYXBzaWJsZVxcXCIsIGIpLCBiIHx8IHRoaXMub3B0aW9ucy5hY3RpdmUgIT09ICExIHx8IHRoaXMuX2FjdGl2YXRlKDApKSwgXFxcImV2ZW50XFxcIiA9PT0gYSAmJiB0aGlzLl9zZXR1cEV2ZW50cyhiKSwgdm9pZCAoXFxcImhlaWdodFN0eWxlXFxcIiA9PT0gYSAmJiB0aGlzLl9zZXR1cEhlaWdodFN0eWxlKGIpKSk7XFxuICAgICAgfSwgX3RhYklkOiBmdW5jdGlvbiBfdGFiSWQoYSkge1xcbiAgICAgICAgcmV0dXJuIGEuYXR0cihcXFwiYXJpYS1jb250cm9sc1xcXCIpIHx8IFxcXCJ1aS10YWJzLVxcXCIgKyBjKCk7XFxuICAgICAgfSwgX3Nhbml0aXplU2VsZWN0b3I6IGZ1bmN0aW9uIF9zYW5pdGl6ZVNlbGVjdG9yKGEpIHtcXG4gICAgICAgIHJldHVybiBhID8gYS5yZXBsYWNlKC9bIVxcXCIkJSYnKCkqKywuXFxcXC86Ozw9Pj9AXFxcXFtcXFxcXVxcXFxeYHt8fX5dL2csIFxcXCJcXFxcXFxcXCQmXFxcIikgOiBcXFwiXFxcIjtcXG4gICAgICB9LCByZWZyZXNoOiBmdW5jdGlvbiByZWZyZXNoKCkge1xcbiAgICAgICAgdmFyIGIgPSB0aGlzLm9wdGlvbnMsXFxuICAgICAgICAgICAgYyA9IHRoaXMudGFibGlzdC5jaGlsZHJlbihcXFwiOmhhcyhhW2hyZWZdKVxcXCIpO2IuZGlzYWJsZWQgPSBhLm1hcChjLmZpbHRlcihcXFwiLnVpLXN0YXRlLWRpc2FibGVkXFxcIiksIGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICAgIHJldHVybiBjLmluZGV4KGEpO1xcbiAgICAgICAgfSksIHRoaXMuX3Byb2Nlc3NUYWJzKCksIGIuYWN0aXZlICE9PSAhMSAmJiB0aGlzLmFuY2hvcnMubGVuZ3RoID8gdGhpcy5hY3RpdmUubGVuZ3RoICYmICFhLmNvbnRhaW5zKHRoaXMudGFibGlzdFswXSwgdGhpcy5hY3RpdmVbMF0pID8gdGhpcy50YWJzLmxlbmd0aCA9PT0gYi5kaXNhYmxlZC5sZW5ndGggPyAoYi5hY3RpdmUgPSAhMSwgdGhpcy5hY3RpdmUgPSBhKCkpIDogdGhpcy5fYWN0aXZhdGUodGhpcy5fZmluZE5leHRUYWIoTWF0aC5tYXgoMCwgYi5hY3RpdmUgLSAxKSwgITEpKSA6IGIuYWN0aXZlID0gdGhpcy50YWJzLmluZGV4KHRoaXMuYWN0aXZlKSA6IChiLmFjdGl2ZSA9ICExLCB0aGlzLmFjdGl2ZSA9IGEoKSksIHRoaXMuX3JlZnJlc2goKTtcXG4gICAgICB9LCBfcmVmcmVzaDogZnVuY3Rpb24gX3JlZnJlc2goKSB7XFxuICAgICAgICB0aGlzLl9zZXR1cERpc2FibGVkKHRoaXMub3B0aW9ucy5kaXNhYmxlZCksIHRoaXMuX3NldHVwRXZlbnRzKHRoaXMub3B0aW9ucy5ldmVudCksIHRoaXMuX3NldHVwSGVpZ2h0U3R5bGUodGhpcy5vcHRpb25zLmhlaWdodFN0eWxlKSwgdGhpcy50YWJzLm5vdCh0aGlzLmFjdGl2ZSkuYXR0cih7IFxcXCJhcmlhLXNlbGVjdGVkXFxcIjogXFxcImZhbHNlXFxcIiwgdGFiSW5kZXg6IC0xIH0pLCB0aGlzLnBhbmVscy5ub3QodGhpcy5fZ2V0UGFuZWxGb3JUYWIodGhpcy5hY3RpdmUpKS5oaWRlKCkuYXR0cih7IFxcXCJhcmlhLWV4cGFuZGVkXFxcIjogXFxcImZhbHNlXFxcIiwgXFxcImFyaWEtaGlkZGVuXFxcIjogXFxcInRydWVcXFwiIH0pLCB0aGlzLmFjdGl2ZS5sZW5ndGggPyAodGhpcy5hY3RpdmUuYWRkQ2xhc3MoXFxcInVpLXRhYnMtYWN0aXZlIHVpLXN0YXRlLWFjdGl2ZVxcXCIpLmF0dHIoeyBcXFwiYXJpYS1zZWxlY3RlZFxcXCI6IFxcXCJ0cnVlXFxcIiwgdGFiSW5kZXg6IDAgfSksIHRoaXMuX2dldFBhbmVsRm9yVGFiKHRoaXMuYWN0aXZlKS5zaG93KCkuYXR0cih7IFxcXCJhcmlhLWV4cGFuZGVkXFxcIjogXFxcInRydWVcXFwiLCBcXFwiYXJpYS1oaWRkZW5cXFwiOiBcXFwiZmFsc2VcXFwiIH0pKSA6IHRoaXMudGFicy5lcSgwKS5hdHRyKFxcXCJ0YWJJbmRleFxcXCIsIDApO1xcbiAgICAgIH0sIF9wcm9jZXNzVGFiczogZnVuY3Rpb24gX3Byb2Nlc3NUYWJzKCkge1xcbiAgICAgICAgdmFyIGIgPSB0aGlzO3RoaXMudGFibGlzdCA9IHRoaXMuX2dldExpc3QoKS5hZGRDbGFzcyhcXFwidWktdGFicy1uYXYgdWktaGVscGVyLXJlc2V0IHVpLWhlbHBlci1jbGVhcmZpeCB1aS13aWRnZXQtaGVhZGVyIHVpLWNvcm5lci1hbGxcXFwiKS5hdHRyKFxcXCJyb2xlXFxcIiwgXFxcInRhYmxpc3RcXFwiKSwgdGhpcy50YWJzID0gdGhpcy50YWJsaXN0LmZpbmQoXFxcIj4gbGk6aGFzKGFbaHJlZl0pXFxcIikuYWRkQ2xhc3MoXFxcInVpLXN0YXRlLWRlZmF1bHQgdWktY29ybmVyLXRvcFxcXCIpLmF0dHIoeyByb2xlOiBcXFwidGFiXFxcIiwgdGFiSW5kZXg6IC0xIH0pLCB0aGlzLmFuY2hvcnMgPSB0aGlzLnRhYnMubWFwKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgcmV0dXJuIGEoXFxcImFcXFwiLCB0aGlzKVswXTtcXG4gICAgICAgIH0pLmFkZENsYXNzKFxcXCJ1aS10YWJzLWFuY2hvclxcXCIpLmF0dHIoeyByb2xlOiBcXFwicHJlc2VudGF0aW9uXFxcIiwgdGFiSW5kZXg6IC0xIH0pLCB0aGlzLnBhbmVscyA9IGEoKSwgdGhpcy5hbmNob3JzLmVhY2goZnVuY3Rpb24gKGMsIGUpIHtcXG4gICAgICAgICAgdmFyIGYsXFxuICAgICAgICAgICAgICBnLFxcbiAgICAgICAgICAgICAgaCxcXG4gICAgICAgICAgICAgIGkgPSBhKGUpLnVuaXF1ZUlkKCkuYXR0cihcXFwiaWRcXFwiKSxcXG4gICAgICAgICAgICAgIGogPSBhKGUpLmNsb3Nlc3QoXFxcImxpXFxcIiksXFxuICAgICAgICAgICAgICBrID0gai5hdHRyKFxcXCJhcmlhLWNvbnRyb2xzXFxcIik7ZChlKSA/IChmID0gZS5oYXNoLCBnID0gYi5lbGVtZW50LmZpbmQoYi5fc2FuaXRpemVTZWxlY3RvcihmKSkpIDogKGggPSBiLl90YWJJZChqKSwgZiA9IFxcXCIjXFxcIiArIGgsIGcgPSBiLmVsZW1lbnQuZmluZChmKSwgZy5sZW5ndGggfHwgKGcgPSBiLl9jcmVhdGVQYW5lbChoKSwgZy5pbnNlcnRBZnRlcihiLnBhbmVsc1tjIC0gMV0gfHwgYi50YWJsaXN0KSksIGcuYXR0cihcXFwiYXJpYS1saXZlXFxcIiwgXFxcInBvbGl0ZVxcXCIpKSwgZy5sZW5ndGggJiYgKGIucGFuZWxzID0gYi5wYW5lbHMuYWRkKGcpKSwgayAmJiBqLmRhdGEoXFxcInVpLXRhYnMtYXJpYS1jb250cm9sc1xcXCIsIGspLCBqLmF0dHIoeyBcXFwiYXJpYS1jb250cm9sc1xcXCI6IGYuc3Vic3RyaW5nKDEpLCBcXFwiYXJpYS1sYWJlbGxlZGJ5XFxcIjogaSB9KSwgZy5hdHRyKFxcXCJhcmlhLWxhYmVsbGVkYnlcXFwiLCBpKTtcXG4gICAgICAgIH0pLCB0aGlzLnBhbmVscy5hZGRDbGFzcyhcXFwidWktdGFicy1wYW5lbCB1aS13aWRnZXQtY29udGVudCB1aS1jb3JuZXItYm90dG9tXFxcIikuYXR0cihcXFwicm9sZVxcXCIsIFxcXCJ0YWJwYW5lbFxcXCIpO1xcbiAgICAgIH0sIF9nZXRMaXN0OiBmdW5jdGlvbiBfZ2V0TGlzdCgpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQuZmluZChcXFwib2wsdWxcXFwiKS5lcSgwKTtcXG4gICAgICB9LCBfY3JlYXRlUGFuZWw6IGZ1bmN0aW9uIF9jcmVhdGVQYW5lbChiKSB7XFxuICAgICAgICByZXR1cm4gYShcXFwiPGRpdj5cXFwiKS5hdHRyKFxcXCJpZFxcXCIsIGIpLmFkZENsYXNzKFxcXCJ1aS10YWJzLXBhbmVsIHVpLXdpZGdldC1jb250ZW50IHVpLWNvcm5lci1ib3R0b21cXFwiKS5kYXRhKFxcXCJ1aS10YWJzLWRlc3Ryb3lcXFwiLCAhMCk7XFxuICAgICAgfSwgX3NldHVwRGlzYWJsZWQ6IGZ1bmN0aW9uIF9zZXR1cERpc2FibGVkKGIpIHtcXG4gICAgICAgIGEuaXNBcnJheShiKSAmJiAoYi5sZW5ndGggPyBiLmxlbmd0aCA9PT0gdGhpcy5hbmNob3JzLmxlbmd0aCAmJiAoYiA9ICEwKSA6IGIgPSAhMSk7Zm9yICh2YXIgYywgZCA9IDA7IGMgPSB0aGlzLnRhYnNbZF07IGQrKykge1xcbiAgICAgICAgICBiID09PSAhMCB8fCAtMSAhPT0gYS5pbkFycmF5KGQsIGIpID8gYShjKS5hZGRDbGFzcyhcXFwidWktc3RhdGUtZGlzYWJsZWRcXFwiKS5hdHRyKFxcXCJhcmlhLWRpc2FibGVkXFxcIiwgXFxcInRydWVcXFwiKSA6IGEoYykucmVtb3ZlQ2xhc3MoXFxcInVpLXN0YXRlLWRpc2FibGVkXFxcIikucmVtb3ZlQXR0cihcXFwiYXJpYS1kaXNhYmxlZFxcXCIpO1xcbiAgICAgICAgfXRoaXMub3B0aW9ucy5kaXNhYmxlZCA9IGI7XFxuICAgICAgfSwgX3NldHVwRXZlbnRzOiBmdW5jdGlvbiBfc2V0dXBFdmVudHMoYikge1xcbiAgICAgICAgdmFyIGMgPSB7IGNsaWNrOiBmdW5jdGlvbiBjbGljayhhKSB7XFxuICAgICAgICAgICAgYS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgICB9IH07YiAmJiBhLmVhY2goYi5zcGxpdChcXFwiIFxcXCIpLCBmdW5jdGlvbiAoYSwgYikge1xcbiAgICAgICAgICBjW2JdID0gXFxcIl9ldmVudEhhbmRsZXJcXFwiO1xcbiAgICAgICAgfSksIHRoaXMuX29mZih0aGlzLmFuY2hvcnMuYWRkKHRoaXMudGFicykuYWRkKHRoaXMucGFuZWxzKSksIHRoaXMuX29uKHRoaXMuYW5jaG9ycywgYyksIHRoaXMuX29uKHRoaXMudGFicywgeyBrZXlkb3duOiBcXFwiX3RhYktleWRvd25cXFwiIH0pLCB0aGlzLl9vbih0aGlzLnBhbmVscywgeyBrZXlkb3duOiBcXFwiX3BhbmVsS2V5ZG93blxcXCIgfSksIHRoaXMuX2ZvY3VzYWJsZSh0aGlzLnRhYnMpLCB0aGlzLl9ob3ZlcmFibGUodGhpcy50YWJzKTtcXG4gICAgICB9LCBfc2V0dXBIZWlnaHRTdHlsZTogZnVuY3Rpb24gX3NldHVwSGVpZ2h0U3R5bGUoYikge1xcbiAgICAgICAgdmFyIGMsXFxuICAgICAgICAgICAgZCA9IHRoaXMuZWxlbWVudC5wYXJlbnQoKTtcXFwiZmlsbFxcXCIgPT09IGIgPyAoYyA9IGQuaGVpZ2h0KCksIGMgLT0gdGhpcy5lbGVtZW50Lm91dGVySGVpZ2h0KCkgLSB0aGlzLmVsZW1lbnQuaGVpZ2h0KCksIHRoaXMuZWxlbWVudC5zaWJsaW5ncyhcXFwiOnZpc2libGVcXFwiKS5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgdmFyIGIgPSBhKHRoaXMpLFxcbiAgICAgICAgICAgICAgZCA9IGIuY3NzKFxcXCJwb3NpdGlvblxcXCIpO1xcXCJhYnNvbHV0ZVxcXCIgIT09IGQgJiYgXFxcImZpeGVkXFxcIiAhPT0gZCAmJiAoYyAtPSBiLm91dGVySGVpZ2h0KCEwKSk7XFxuICAgICAgICB9KSwgdGhpcy5lbGVtZW50LmNoaWxkcmVuKCkubm90KHRoaXMucGFuZWxzKS5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgYyAtPSBhKHRoaXMpLm91dGVySGVpZ2h0KCEwKTtcXG4gICAgICAgIH0pLCB0aGlzLnBhbmVscy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgYSh0aGlzKS5oZWlnaHQoTWF0aC5tYXgoMCwgYyAtIGEodGhpcykuaW5uZXJIZWlnaHQoKSArIGEodGhpcykuaGVpZ2h0KCkpKTtcXG4gICAgICAgIH0pLmNzcyhcXFwib3ZlcmZsb3dcXFwiLCBcXFwiYXV0b1xcXCIpKSA6IFxcXCJhdXRvXFxcIiA9PT0gYiAmJiAoYyA9IDAsIHRoaXMucGFuZWxzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBjID0gTWF0aC5tYXgoYywgYSh0aGlzKS5oZWlnaHQoXFxcIlxcXCIpLmhlaWdodCgpKTtcXG4gICAgICAgIH0pLmhlaWdodChjKSk7XFxuICAgICAgfSwgX2V2ZW50SGFuZGxlcjogZnVuY3Rpb24gX2V2ZW50SGFuZGxlcihiKSB7XFxuICAgICAgICB2YXIgYyA9IHRoaXMub3B0aW9ucyxcXG4gICAgICAgICAgICBkID0gdGhpcy5hY3RpdmUsXFxuICAgICAgICAgICAgZSA9IGEoYi5jdXJyZW50VGFyZ2V0KSxcXG4gICAgICAgICAgICBmID0gZS5jbG9zZXN0KFxcXCJsaVxcXCIpLFxcbiAgICAgICAgICAgIGcgPSBmWzBdID09PSBkWzBdLFxcbiAgICAgICAgICAgIGggPSBnICYmIGMuY29sbGFwc2libGUsXFxuICAgICAgICAgICAgaSA9IGggPyBhKCkgOiB0aGlzLl9nZXRQYW5lbEZvclRhYihmKSxcXG4gICAgICAgICAgICBqID0gZC5sZW5ndGggPyB0aGlzLl9nZXRQYW5lbEZvclRhYihkKSA6IGEoKSxcXG4gICAgICAgICAgICBrID0geyBvbGRUYWI6IGQsIG9sZFBhbmVsOiBqLCBuZXdUYWI6IGggPyBhKCkgOiBmLCBuZXdQYW5lbDogaSB9O2IucHJldmVudERlZmF1bHQoKSwgZi5oYXNDbGFzcyhcXFwidWktc3RhdGUtZGlzYWJsZWRcXFwiKSB8fCBmLmhhc0NsYXNzKFxcXCJ1aS10YWJzLWxvYWRpbmdcXFwiKSB8fCB0aGlzLnJ1bm5pbmcgfHwgZyAmJiAhYy5jb2xsYXBzaWJsZSB8fCB0aGlzLl90cmlnZ2VyKFxcXCJiZWZvcmVBY3RpdmF0ZVxcXCIsIGIsIGspID09PSAhMSB8fCAoYy5hY3RpdmUgPSBoID8gITEgOiB0aGlzLnRhYnMuaW5kZXgoZiksIHRoaXMuYWN0aXZlID0gZyA/IGEoKSA6IGYsIHRoaXMueGhyICYmIHRoaXMueGhyLmFib3J0KCksIGoubGVuZ3RoIHx8IGkubGVuZ3RoIHx8IGEuZXJyb3IoXFxcImpRdWVyeSBVSSBUYWJzOiBNaXNtYXRjaGluZyBmcmFnbWVudCBpZGVudGlmaWVyLlxcXCIpLCBpLmxlbmd0aCAmJiB0aGlzLmxvYWQodGhpcy50YWJzLmluZGV4KGYpLCBiKSwgdGhpcy5fdG9nZ2xlKGIsIGspKTtcXG4gICAgICB9LCBfdG9nZ2xlOiBmdW5jdGlvbiBfdG9nZ2xlKGIsIGMpIHtcXG4gICAgICAgIGZ1bmN0aW9uIGQoKSB7XFxuICAgICAgICAgIGYucnVubmluZyA9ICExLCBmLl90cmlnZ2VyKFxcXCJhY3RpdmF0ZVxcXCIsIGIsIGMpO1xcbiAgICAgICAgfWZ1bmN0aW9uIGUoKSB7XFxuICAgICAgICAgIGMubmV3VGFiLmNsb3Nlc3QoXFxcImxpXFxcIikuYWRkQ2xhc3MoXFxcInVpLXRhYnMtYWN0aXZlIHVpLXN0YXRlLWFjdGl2ZVxcXCIpLCBnLmxlbmd0aCAmJiBmLm9wdGlvbnMuc2hvdyA/IGYuX3Nob3coZywgZi5vcHRpb25zLnNob3csIGQpIDogKGcuc2hvdygpLCBkKCkpO1xcbiAgICAgICAgfXZhciBmID0gdGhpcyxcXG4gICAgICAgICAgICBnID0gYy5uZXdQYW5lbCxcXG4gICAgICAgICAgICBoID0gYy5vbGRQYW5lbDt0aGlzLnJ1bm5pbmcgPSAhMCwgaC5sZW5ndGggJiYgdGhpcy5vcHRpb25zLmhpZGUgPyB0aGlzLl9oaWRlKGgsIHRoaXMub3B0aW9ucy5oaWRlLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIGMub2xkVGFiLmNsb3Nlc3QoXFxcImxpXFxcIikucmVtb3ZlQ2xhc3MoXFxcInVpLXRhYnMtYWN0aXZlIHVpLXN0YXRlLWFjdGl2ZVxcXCIpLCBlKCk7XFxuICAgICAgICB9KSA6IChjLm9sZFRhYi5jbG9zZXN0KFxcXCJsaVxcXCIpLnJlbW92ZUNsYXNzKFxcXCJ1aS10YWJzLWFjdGl2ZSB1aS1zdGF0ZS1hY3RpdmVcXFwiKSwgaC5oaWRlKCksIGUoKSksIGguYXR0cih7IFxcXCJhcmlhLWV4cGFuZGVkXFxcIjogXFxcImZhbHNlXFxcIiwgXFxcImFyaWEtaGlkZGVuXFxcIjogXFxcInRydWVcXFwiIH0pLCBjLm9sZFRhYi5hdHRyKFxcXCJhcmlhLXNlbGVjdGVkXFxcIiwgXFxcImZhbHNlXFxcIiksIGcubGVuZ3RoICYmIGgubGVuZ3RoID8gYy5vbGRUYWIuYXR0cihcXFwidGFiSW5kZXhcXFwiLCAtMSkgOiBnLmxlbmd0aCAmJiB0aGlzLnRhYnMuZmlsdGVyKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgcmV0dXJuIDAgPT09IGEodGhpcykuYXR0cihcXFwidGFiSW5kZXhcXFwiKTtcXG4gICAgICAgIH0pLmF0dHIoXFxcInRhYkluZGV4XFxcIiwgLTEpLCBnLmF0dHIoeyBcXFwiYXJpYS1leHBhbmRlZFxcXCI6IFxcXCJ0cnVlXFxcIiwgXFxcImFyaWEtaGlkZGVuXFxcIjogXFxcImZhbHNlXFxcIiB9KSwgYy5uZXdUYWIuYXR0cih7IFxcXCJhcmlhLXNlbGVjdGVkXFxcIjogXFxcInRydWVcXFwiLCB0YWJJbmRleDogMCB9KTtcXG4gICAgICB9LCBfYWN0aXZhdGU6IGZ1bmN0aW9uIF9hY3RpdmF0ZShiKSB7XFxuICAgICAgICB2YXIgYyxcXG4gICAgICAgICAgICBkID0gdGhpcy5fZmluZEFjdGl2ZShiKTtkWzBdICE9PSB0aGlzLmFjdGl2ZVswXSAmJiAoZC5sZW5ndGggfHwgKGQgPSB0aGlzLmFjdGl2ZSksIGMgPSBkLmZpbmQoXFxcIi51aS10YWJzLWFuY2hvclxcXCIpWzBdLCB0aGlzLl9ldmVudEhhbmRsZXIoeyB0YXJnZXQ6IGMsIGN1cnJlbnRUYXJnZXQ6IGMsIHByZXZlbnREZWZhdWx0OiBhLm5vb3AgfSkpO1xcbiAgICAgIH0sIF9maW5kQWN0aXZlOiBmdW5jdGlvbiBfZmluZEFjdGl2ZShiKSB7XFxuICAgICAgICByZXR1cm4gYiA9PT0gITEgPyBhKCkgOiB0aGlzLnRhYnMuZXEoYik7XFxuICAgICAgfSwgX2dldEluZGV4OiBmdW5jdGlvbiBfZ2V0SW5kZXgoYSkge1xcbiAgICAgICAgcmV0dXJuIFxcXCJzdHJpbmdcXFwiID09IHR5cGVvZiBhICYmIChhID0gdGhpcy5hbmNob3JzLmluZGV4KHRoaXMuYW5jaG9ycy5maWx0ZXIoXFxcIltocmVmJD0nXFxcIiArIGEgKyBcXFwiJ11cXFwiKSkpLCBhO1xcbiAgICAgIH0sIF9kZXN0cm95OiBmdW5jdGlvbiBfZGVzdHJveSgpIHtcXG4gICAgICAgIHRoaXMueGhyICYmIHRoaXMueGhyLmFib3J0KCksIHRoaXMuZWxlbWVudC5yZW1vdmVDbGFzcyhcXFwidWktdGFicyB1aS13aWRnZXQgdWktd2lkZ2V0LWNvbnRlbnQgdWktY29ybmVyLWFsbCB1aS10YWJzLWNvbGxhcHNpYmxlXFxcIiksIHRoaXMudGFibGlzdC5yZW1vdmVDbGFzcyhcXFwidWktdGFicy1uYXYgdWktaGVscGVyLXJlc2V0IHVpLWhlbHBlci1jbGVhcmZpeCB1aS13aWRnZXQtaGVhZGVyIHVpLWNvcm5lci1hbGxcXFwiKS5yZW1vdmVBdHRyKFxcXCJyb2xlXFxcIiksIHRoaXMuYW5jaG9ycy5yZW1vdmVDbGFzcyhcXFwidWktdGFicy1hbmNob3JcXFwiKS5yZW1vdmVBdHRyKFxcXCJyb2xlXFxcIikucmVtb3ZlQXR0cihcXFwidGFiSW5kZXhcXFwiKS5yZW1vdmVVbmlxdWVJZCgpLCB0aGlzLnRhYnMuYWRkKHRoaXMucGFuZWxzKS5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgYS5kYXRhKHRoaXMsIFxcXCJ1aS10YWJzLWRlc3Ryb3lcXFwiKSA/IGEodGhpcykucmVtb3ZlKCkgOiBhKHRoaXMpLnJlbW92ZUNsYXNzKFxcXCJ1aS1zdGF0ZS1kZWZhdWx0IHVpLXN0YXRlLWFjdGl2ZSB1aS1zdGF0ZS1kaXNhYmxlZCB1aS1jb3JuZXItdG9wIHVpLWNvcm5lci1ib3R0b20gdWktd2lkZ2V0LWNvbnRlbnQgdWktdGFicy1hY3RpdmUgdWktdGFicy1wYW5lbFxcXCIpLnJlbW92ZUF0dHIoXFxcInRhYkluZGV4XFxcIikucmVtb3ZlQXR0cihcXFwiYXJpYS1saXZlXFxcIikucmVtb3ZlQXR0cihcXFwiYXJpYS1idXN5XFxcIikucmVtb3ZlQXR0cihcXFwiYXJpYS1zZWxlY3RlZFxcXCIpLnJlbW92ZUF0dHIoXFxcImFyaWEtbGFiZWxsZWRieVxcXCIpLnJlbW92ZUF0dHIoXFxcImFyaWEtaGlkZGVuXFxcIikucmVtb3ZlQXR0cihcXFwiYXJpYS1leHBhbmRlZFxcXCIpLnJlbW92ZUF0dHIoXFxcInJvbGVcXFwiKTtcXG4gICAgICAgIH0pLCB0aGlzLnRhYnMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHZhciBiID0gYSh0aGlzKSxcXG4gICAgICAgICAgICAgIGMgPSBiLmRhdGEoXFxcInVpLXRhYnMtYXJpYS1jb250cm9sc1xcXCIpO2MgPyBiLmF0dHIoXFxcImFyaWEtY29udHJvbHNcXFwiLCBjKS5yZW1vdmVEYXRhKFxcXCJ1aS10YWJzLWFyaWEtY29udHJvbHNcXFwiKSA6IGIucmVtb3ZlQXR0cihcXFwiYXJpYS1jb250cm9sc1xcXCIpO1xcbiAgICAgICAgfSksIHRoaXMucGFuZWxzLnNob3coKSwgXFxcImNvbnRlbnRcXFwiICE9PSB0aGlzLm9wdGlvbnMuaGVpZ2h0U3R5bGUgJiYgdGhpcy5wYW5lbHMuY3NzKFxcXCJoZWlnaHRcXFwiLCBcXFwiXFxcIik7XFxuICAgICAgfSwgZW5hYmxlOiBmdW5jdGlvbiBlbmFibGUoYykge1xcbiAgICAgICAgdmFyIGQgPSB0aGlzLm9wdGlvbnMuZGlzYWJsZWQ7ZCAhPT0gITEgJiYgKGMgPT09IGIgPyBkID0gITEgOiAoYyA9IHRoaXMuX2dldEluZGV4KGMpLCBkID0gYS5pc0FycmF5KGQpID8gYS5tYXAoZCwgZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgICAgcmV0dXJuIGEgIT09IGMgPyBhIDogbnVsbDtcXG4gICAgICAgIH0pIDogYS5tYXAodGhpcy50YWJzLCBmdW5jdGlvbiAoYSwgYikge1xcbiAgICAgICAgICByZXR1cm4gYiAhPT0gYyA/IGIgOiBudWxsO1xcbiAgICAgICAgfSkpLCB0aGlzLl9zZXR1cERpc2FibGVkKGQpKTtcXG4gICAgICB9LCBkaXNhYmxlOiBmdW5jdGlvbiBkaXNhYmxlKGMpIHtcXG4gICAgICAgIHZhciBkID0gdGhpcy5vcHRpb25zLmRpc2FibGVkO2lmIChkICE9PSAhMCkge1xcbiAgICAgICAgICBpZiAoYyA9PT0gYikgZCA9ICEwO2Vsc2Uge1xcbiAgICAgICAgICAgIGlmIChjID0gdGhpcy5fZ2V0SW5kZXgoYyksIC0xICE9PSBhLmluQXJyYXkoYywgZCkpIHJldHVybjtkID0gYS5pc0FycmF5KGQpID8gYS5tZXJnZShbY10sIGQpLnNvcnQoKSA6IFtjXTtcXG4gICAgICAgICAgfXRoaXMuX3NldHVwRGlzYWJsZWQoZCk7XFxuICAgICAgICB9XFxuICAgICAgfSwgbG9hZDogZnVuY3Rpb24gbG9hZChiLCBjKSB7XFxuICAgICAgICBiID0gdGhpcy5fZ2V0SW5kZXgoYik7dmFyIGUgPSB0aGlzLFxcbiAgICAgICAgICAgIGYgPSB0aGlzLnRhYnMuZXEoYiksXFxuICAgICAgICAgICAgZyA9IGYuZmluZChcXFwiLnVpLXRhYnMtYW5jaG9yXFxcIiksXFxuICAgICAgICAgICAgaCA9IHRoaXMuX2dldFBhbmVsRm9yVGFiKGYpLFxcbiAgICAgICAgICAgIGkgPSB7IHRhYjogZiwgcGFuZWw6IGggfTtkKGdbMF0pIHx8ICh0aGlzLnhociA9IGEuYWpheCh0aGlzLl9hamF4U2V0dGluZ3MoZywgYywgaSkpLCB0aGlzLnhociAmJiBcXFwiY2FuY2VsZWRcXFwiICE9PSB0aGlzLnhoci5zdGF0dXNUZXh0ICYmIChmLmFkZENsYXNzKFxcXCJ1aS10YWJzLWxvYWRpbmdcXFwiKSwgaC5hdHRyKFxcXCJhcmlhLWJ1c3lcXFwiLCBcXFwidHJ1ZVxcXCIpLCB0aGlzLnhoci5zdWNjZXNzKGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIGguaHRtbChhKSwgZS5fdHJpZ2dlcihcXFwibG9hZFxcXCIsIGMsIGkpO1xcbiAgICAgICAgICB9LCAxKTtcXG4gICAgICAgIH0pLmNvbXBsZXRlKGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIFxcXCJhYm9ydFxcXCIgPT09IGIgJiYgZS5wYW5lbHMuc3RvcCghMSwgITApLCBmLnJlbW92ZUNsYXNzKFxcXCJ1aS10YWJzLWxvYWRpbmdcXFwiKSwgaC5yZW1vdmVBdHRyKFxcXCJhcmlhLWJ1c3lcXFwiKSwgYSA9PT0gZS54aHIgJiYgZGVsZXRlIGUueGhyO1xcbiAgICAgICAgICB9LCAxKTtcXG4gICAgICAgIH0pKSk7XFxuICAgICAgfSwgX2FqYXhTZXR0aW5nczogZnVuY3Rpb24gX2FqYXhTZXR0aW5ncyhiLCBjLCBkKSB7XFxuICAgICAgICB2YXIgZSA9IHRoaXM7cmV0dXJuIHsgdXJsOiBiLmF0dHIoXFxcImhyZWZcXFwiKSwgYmVmb3JlU2VuZDogZnVuY3Rpb24gYmVmb3JlU2VuZChiLCBmKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGUuX3RyaWdnZXIoXFxcImJlZm9yZUxvYWRcXFwiLCBjLCBhLmV4dGVuZCh7IGpxWEhSOiBiLCBhamF4U2V0dGluZ3M6IGYgfSwgZCkpO1xcbiAgICAgICAgICB9IH07XFxuICAgICAgfSwgX2dldFBhbmVsRm9yVGFiOiBmdW5jdGlvbiBfZ2V0UGFuZWxGb3JUYWIoYikge1xcbiAgICAgICAgdmFyIGMgPSBhKGIpLmF0dHIoXFxcImFyaWEtY29udHJvbHNcXFwiKTtyZXR1cm4gdGhpcy5lbGVtZW50LmZpbmQodGhpcy5fc2FuaXRpemVTZWxlY3RvcihcXFwiI1xcXCIgKyBjKSk7XFxuICAgICAgfSB9KTtcXG4gIH0oYSksIGZ1bmN0aW9uICgpIHt9KGEpLCBmdW5jdGlvbiAoYSwgYikge1xcbiAgICBmdW5jdGlvbiBjKGEpIHtcXG4gICAgICBlID0gYS5vcmlnaW5hbEV2ZW50LCBpID0gZS5hY2NlbGVyYXRpb25JbmNsdWRpbmdHcmF2aXR5LCBmID0gTWF0aC5hYnMoaS54KSwgZyA9IE1hdGguYWJzKGkueSksIGggPSBNYXRoLmFicyhpLnopLCAhYi5vcmllbnRhdGlvbiAmJiAoZiA+IDcgfHwgKGggPiA2ICYmIDggPiBnIHx8IDggPiBoICYmIGcgPiA2KSAmJiBmID4gNSkgPyBkLmVuYWJsZWQgJiYgZC5kaXNhYmxlKCkgOiBkLmVuYWJsZWQgfHwgZC5lbmFibGUoKTtcXG4gICAgfWEubW9iaWxlLmlvc29yaWVudGF0aW9uZml4RW5hYmxlZCA9ICEwO3ZhciBkLFxcbiAgICAgICAgZSxcXG4gICAgICAgIGYsXFxuICAgICAgICBnLFxcbiAgICAgICAgaCxcXG4gICAgICAgIGksXFxuICAgICAgICBqID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtyZXR1cm4gKC9pUGhvbmV8aVBhZHxpUG9kLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSkgJiYgL09TIFsxLTVdX1swLTlfXSogbGlrZSBNYWMgT1MgWC9pLnRlc3QoaikgJiYgai5pbmRleE9mKFxcXCJBcHBsZVdlYktpdFxcXCIpID4gLTEgPyAoZCA9IGEubW9iaWxlLnpvb20sIHZvaWQgYS5tb2JpbGUuZG9jdW1lbnQub24oXFxcIm1vYmlsZWluaXRcXFwiLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICBhLm1vYmlsZS5pb3NvcmllbnRhdGlvbmZpeEVuYWJsZWQgJiYgYS5tb2JpbGUud2luZG93LmJpbmQoXFxcIm9yaWVudGF0aW9uY2hhbmdlLmlvc29yaWVudGF0aW9uZml4XFxcIiwgZC5lbmFibGUpLmJpbmQoXFxcImRldmljZW1vdGlvbi5pb3NvcmllbnRhdGlvbmZpeFxcXCIsIGMpO1xcbiAgICAgIH0pKSA6IHZvaWQgKGEubW9iaWxlLmlvc29yaWVudGF0aW9uZml4RW5hYmxlZCA9ICExKVxcbiAgICApO1xcbiAgfShhLCB0aGlzKSwgZnVuY3Rpb24gKGEsIGIsIGQpIHtcXG4gICAgZnVuY3Rpb24gZSgpIHtcXG4gICAgICBmLnJlbW92ZUNsYXNzKFxcXCJ1aS1tb2JpbGUtcmVuZGVyaW5nXFxcIik7XFxuICAgIH12YXIgZiA9IGEoXFxcImh0bWxcXFwiKSxcXG4gICAgICAgIGcgPSBhLm1vYmlsZS53aW5kb3c7YShiLmRvY3VtZW50KS50cmlnZ2VyKFxcXCJtb2JpbGVpbml0XFxcIiksIGEubW9iaWxlLmdyYWRlQSgpICYmIChhLm1vYmlsZS5hamF4QmxhY2tsaXN0ICYmIChhLm1vYmlsZS5hamF4RW5hYmxlZCA9ICExKSwgZi5hZGRDbGFzcyhcXFwidWktbW9iaWxlIHVpLW1vYmlsZS1yZW5kZXJpbmdcXFwiKSwgc2V0VGltZW91dChlLCA1ZTMpLCBhLmV4dGVuZChhLm1vYmlsZSwgeyBpbml0aWFsaXplUGFnZTogZnVuY3Rpb24gaW5pdGlhbGl6ZVBhZ2UoKSB7XFxuICAgICAgICB2YXIgYiA9IGEubW9iaWxlLnBhdGgsXFxuICAgICAgICAgICAgZiA9IGEoXFxcIjpqcW1EYXRhKHJvbGU9J3BhZ2UnKSwgOmpxbURhdGEocm9sZT0nZGlhbG9nJylcXFwiKSxcXG4gICAgICAgICAgICBoID0gYi5zdHJpcEhhc2goYi5zdHJpcFF1ZXJ5UGFyYW1zKGIucGFyc2VMb2NhdGlvbigpLmhhc2gpKSxcXG4gICAgICAgICAgICBpID0gYS5tb2JpbGUucGF0aC5wYXJzZUxvY2F0aW9uKCksXFxuICAgICAgICAgICAgaiA9IGggPyBjLmdldEVsZW1lbnRCeUlkKGgpIDogZDtmLmxlbmd0aCB8fCAoZiA9IGEoXFxcImJvZHlcXFwiKS53cmFwSW5uZXIoXFxcIjxkaXYgZGF0YS1cXFwiICsgYS5tb2JpbGUubnMgKyBcXFwicm9sZT0ncGFnZSc+PC9kaXY+XFxcIikuY2hpbGRyZW4oMCkpLCBmLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICB2YXIgYyA9IGEodGhpcyk7Y1swXS5nZXRBdHRyaWJ1dGUoXFxcImRhdGEtXFxcIiArIGEubW9iaWxlLm5zICsgXFxcInVybFxcXCIpIHx8IGMuYXR0cihcXFwiZGF0YS1cXFwiICsgYS5tb2JpbGUubnMgKyBcXFwidXJsXFxcIiwgYy5hdHRyKFxcXCJpZFxcXCIpIHx8IGIuY29udmVydFVybFRvRGF0YVVybChpLnBhdGhuYW1lICsgaS5zZWFyY2gpKTtcXG4gICAgICAgIH0pLCBhLm1vYmlsZS5maXJzdFBhZ2UgPSBmLmZpcnN0KCksIGEubW9iaWxlLnBhZ2VDb250YWluZXIgPSBhLm1vYmlsZS5maXJzdFBhZ2UucGFyZW50KCkuYWRkQ2xhc3MoXFxcInVpLW1vYmlsZS12aWV3cG9ydFxcXCIpLnBhZ2Vjb250YWluZXIoKSwgYS5tb2JpbGUubmF2cmVhZHlEZWZlcnJlZC5yZXNvbHZlKCksIGcudHJpZ2dlcihcXFwicGFnZWNvbnRhaW5lcmNyZWF0ZVxcXCIpLCBhLm1vYmlsZS5sb2FkaW5nKFxcXCJzaG93XFxcIiksIGUoKSwgYS5tb2JpbGUuaGFzaExpc3RlbmluZ0VuYWJsZWQgJiYgYS5tb2JpbGUucGF0aC5pc0hhc2hWYWxpZChsb2NhdGlvbi5oYXNoKSAmJiAoYShqKS5pcyhcXFwiOmpxbURhdGEocm9sZT0ncGFnZScpXFxcIikgfHwgYS5tb2JpbGUucGF0aC5pc1BhdGgoaCkgfHwgaCA9PT0gYS5tb2JpbGUuZGlhbG9nSGFzaEtleSkgPyBhLmV2ZW50LnNwZWNpYWwubmF2aWdhdGUuaXNQdXNoU3RhdGVFbmFibGVkKCkgPyAoYS5tb2JpbGUubmF2aWdhdGUuaGlzdG9yeS5zdGFjayA9IFtdLCBhLm1vYmlsZS5uYXZpZ2F0ZShhLm1vYmlsZS5wYXRoLmlzUGF0aChsb2NhdGlvbi5oYXNoKSA/IGxvY2F0aW9uLmhhc2ggOiBsb2NhdGlvbi5ocmVmKSkgOiBnLnRyaWdnZXIoXFxcImhhc2hjaGFuZ2VcXFwiLCBbITBdKSA6IChhLmV2ZW50LnNwZWNpYWwubmF2aWdhdGUuaXNQdXNoU3RhdGVFbmFibGVkKCkgJiYgYS5tb2JpbGUubmF2aWdhdGUubmF2aWdhdG9yLnNxdWFzaChiLnBhcnNlTG9jYXRpb24oKS5ocmVmKSwgYS5tb2JpbGUuY2hhbmdlUGFnZShhLm1vYmlsZS5maXJzdFBhZ2UsIHsgdHJhbnNpdGlvbjogXFxcIm5vbmVcXFwiLCByZXZlcnNlOiAhMCwgY2hhbmdlSGFzaDogITEsIGZyb21IYXNoQ2hhbmdlOiAhMCB9KSk7XFxuICAgICAgfSB9KSwgYShmdW5jdGlvbiAoKSB7XFxuICAgICAgYS5zdXBwb3J0LmlubGluZVNWRygpLCBhLm1vYmlsZS5oaWRlVXJsQmFyICYmIGIuc2Nyb2xsVG8oMCwgMSksIGEubW9iaWxlLmRlZmF1bHRIb21lU2Nyb2xsID0gYS5zdXBwb3J0LnNjcm9sbFRvcCAmJiAxICE9PSBhLm1vYmlsZS53aW5kb3cuc2Nyb2xsVG9wKCkgPyAxIDogMCwgYS5tb2JpbGUuYXV0b0luaXRpYWxpemVQYWdlICYmIGEubW9iaWxlLmluaXRpYWxpemVQYWdlKCksIGEubW9iaWxlLmhpZGVVcmxCYXIgJiYgZy5sb2FkKGEubW9iaWxlLnNpbGVudFNjcm9sbCksIGEuc3VwcG9ydC5jc3NQb2ludGVyRXZlbnRzIHx8IGEubW9iaWxlLmRvY3VtZW50LmRlbGVnYXRlKFxcXCIudWktc3RhdGUtZGlzYWJsZWQsLnVpLWRpc2FibGVkXFxcIiwgXFxcInZjbGlja1xcXCIsIGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICBhLnByZXZlbnREZWZhdWx0KCksIGEuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XFxuICAgICAgfSk7XFxuICAgIH0pKTtcXG4gIH0oYSwgdGhpcyk7XFxufSk7XFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9anF1ZXJ5Lm1vYmlsZS0xLjQuNS5taW4ubWFwXCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yYXctbG9hZGVyIS4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWI/P3JlZi0tMC0wIS4vYXNzZXRzL2pzL2pxdWVyeS5tb2JpbGUtMS40LjUuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3Jhdy1sb2FkZXIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0wLTAhLi9hc3NldHMvanMvanF1ZXJ5Lm1vYmlsZS0xLjQuNS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFwidmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFxcXCJzeW1ib2xcXFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFxcXCJzeW1ib2xcXFwiIDogdHlwZW9mIG9iajsgfTtcXG5cXG4vKiBqUXVlcnkucXJjb2RlIDAuMTIuMCAtIGh0dHA6Ly9sYXJzanVuZy5kZS9qcXVlcnktcXJjb2RlLyAtIHVzZXMgLy9naXRodWIuY29tL2thenVoaWtvYXJhc2UvcXJjb2RlLWdlbmVyYXRvciAoTUlUKSAqL1xcbihmdW5jdGlvbiAocXJjb2RlKSB7XFxuICAndXNlIHN0cmljdCc7XFxuXFxuICB2YXIgJCA9IGpRdWVyeTtcXG5cXG4gIC8vIFdyYXBwZXIgZm9yIHRoZSBvcmlnaW5hbCBRUiBjb2RlIGdlbmVyYXRvci5cXG4gIGZ1bmN0aW9uIFFSQ29kZSh0ZXh0LCBsZXZlbCwgdmVyc2lvbiwgcXVpZXQpIHtcXG5cXG4gICAgdmFyIHFyID0gcXJjb2RlKHZlcnNpb24sIGxldmVsKTtcXG4gICAgcXIuYWRkRGF0YSh0ZXh0KTtcXG4gICAgcXIubWFrZSgpO1xcblxcbiAgICBxdWlldCA9IHF1aWV0IHx8IDA7XFxuXFxuICAgIHZhciBxck1vZHVsZUNvdW50ID0gcXIuZ2V0TW9kdWxlQ291bnQoKTtcXG4gICAgdmFyIHF1aWV0TW9kdWxlQ291bnQgPSBxci5nZXRNb2R1bGVDb3VudCgpICsgMiAqIHF1aWV0O1xcblxcbiAgICBmdW5jdGlvbiBpc0Rhcmsocm93LCBjb2wpIHtcXG5cXG4gICAgICByb3cgLT0gcXVpZXQ7XFxuICAgICAgY29sIC09IHF1aWV0O1xcblxcbiAgICAgIGlmIChyb3cgPCAwIHx8IHJvdyA+PSBxck1vZHVsZUNvdW50IHx8IGNvbCA8IDAgfHwgY29sID49IHFyTW9kdWxlQ291bnQpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHFyLmlzRGFyayhyb3csIGNvbCk7XFxuICAgIH1cXG5cXG4gICAgdmFyIGFkZEJsYW5rID0gZnVuY3Rpb24gYWRkQmxhbmsobCwgdCwgciwgYikge1xcblxcbiAgICAgIHZhciBwcmV2SXNEYXJrID0gdGhpcy5pc0Rhcms7XFxuICAgICAgdmFyIG1vZHVsZVNpemUgPSAxIC8gcXVpZXRNb2R1bGVDb3VudDtcXG5cXG4gICAgICB0aGlzLmlzRGFyayA9IGZ1bmN0aW9uIChyb3csIGNvbCkge1xcblxcbiAgICAgICAgdmFyIG1sID0gY29sICogbW9kdWxlU2l6ZTtcXG4gICAgICAgIHZhciBtdCA9IHJvdyAqIG1vZHVsZVNpemU7XFxuICAgICAgICB2YXIgbXIgPSBtbCArIG1vZHVsZVNpemU7XFxuICAgICAgICB2YXIgbWIgPSBtdCArIG1vZHVsZVNpemU7XFxuXFxuICAgICAgICByZXR1cm4gcHJldklzRGFyayhyb3csIGNvbCkgJiYgKGwgPiBtciB8fCBtbCA+IHIgfHwgdCA+IG1iIHx8IG10ID4gYik7XFxuICAgICAgfTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy50ZXh0ID0gdGV4dDtcXG4gICAgdGhpcy5sZXZlbCA9IGxldmVsO1xcbiAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xcbiAgICB0aGlzLm1vZHVsZUNvdW50ID0gcXVpZXRNb2R1bGVDb3VudDtcXG4gICAgdGhpcy5pc0RhcmsgPSBpc0Rhcms7XFxuICAgIHRoaXMuYWRkQmxhbmsgPSBhZGRCbGFuaztcXG4gIH1cXG5cXG4gIC8vIENoZWNrIGlmIGNhbnZhcyBpcyBhdmFpbGFibGUgaW4gdGhlIGJyb3dzZXIgKGFzIE1vZGVybml6ciBkb2VzKVxcbiAgdmFyIGhhc0NhbnZhcyA9IGZ1bmN0aW9uICgpIHtcXG5cXG4gICAgdmFyIGVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcXG4gICAgcmV0dXJuIEJvb2xlYW4oZWxlbS5nZXRDb250ZXh0ICYmIGVsZW0uZ2V0Q29udGV4dCgnMmQnKSk7XFxuICB9KCk7XFxuICB2YXIgaGFzQXJjVG8gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwod2luZG93Lm9wZXJhKSAhPT0gJ1tvYmplY3QgT3BlcmFdJztcXG5cXG4gIC8vIFJldHVybnMgYSBtaW5pbWFsIFFSIGNvZGUgZm9yIHRoZSBnaXZlbiB0ZXh0IHN0YXJ0aW5nIHdpdGggdmVyc2lvbiBgbWluVmVyc2lvbmAuXFxuICAvLyBSZXR1cm5zIGB1bmRlZmluZWRgIGlmIGB0ZXh0YCBpcyB0b28gbG9uZyB0byBiZSBlbmNvZGVkIGluIGBtYXhWZXJzaW9uYC5cXG4gIGZ1bmN0aW9uIGNyZWF0ZVFSQ29kZSh0ZXh0LCBsZXZlbCwgbWluVmVyc2lvbiwgbWF4VmVyc2lvbiwgcXVpZXQpIHtcXG5cXG4gICAgbWluVmVyc2lvbiA9IE1hdGgubWF4KDEsIG1pblZlcnNpb24gfHwgMSk7XFxuICAgIG1heFZlcnNpb24gPSBNYXRoLm1pbig0MCwgbWF4VmVyc2lvbiB8fCA0MCk7XFxuICAgIGZvciAodmFyIHZlcnNpb24gPSBtaW5WZXJzaW9uOyB2ZXJzaW9uIDw9IG1heFZlcnNpb247IHZlcnNpb24gKz0gMSkge1xcbiAgICAgIHRyeSB7XFxuICAgICAgICByZXR1cm4gbmV3IFFSQ29kZSh0ZXh0LCBsZXZlbCwgdmVyc2lvbiwgcXVpZXQpO1xcbiAgICAgIH0gY2F0Y2ggKGVycikge31cXG4gICAgfVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gZHJhd0JhY2tncm91bmRMYWJlbChxciwgY29udGV4dCwgc2V0dGluZ3MpIHtcXG5cXG4gICAgdmFyIHNpemUgPSBzZXR0aW5ncy5zaXplO1xcbiAgICB2YXIgZm9udCA9ICdib2xkICcgKyBzZXR0aW5ncy5tU2l6ZSAqIHNpemUgKyAncHggJyArIHNldHRpbmdzLmZvbnRuYW1lO1xcbiAgICB2YXIgY3R4ID0gJCgnPGNhbnZhcy8+JylbMF0uZ2V0Q29udGV4dCgnMmQnKTtcXG5cXG4gICAgY3R4LmZvbnQgPSBmb250O1xcblxcbiAgICB2YXIgdyA9IGN0eC5tZWFzdXJlVGV4dChzZXR0aW5ncy5sYWJlbCkud2lkdGg7XFxuICAgIHZhciBzaCA9IHNldHRpbmdzLm1TaXplO1xcbiAgICB2YXIgc3cgPSB3IC8gc2l6ZTtcXG4gICAgdmFyIHNsID0gKDEgLSBzdykgKiBzZXR0aW5ncy5tUG9zWDtcXG4gICAgdmFyIHN0ID0gKDEgLSBzaCkgKiBzZXR0aW5ncy5tUG9zWTtcXG4gICAgdmFyIHNyID0gc2wgKyBzdztcXG4gICAgdmFyIHNiID0gc3QgKyBzaDtcXG4gICAgdmFyIHBhZCA9IDAuMDE7XFxuXFxuICAgIGlmIChzZXR0aW5ncy5tb2RlID09PSAxKSB7XFxuICAgICAgLy8gU3RyaXBcXG4gICAgICBxci5hZGRCbGFuaygwLCBzdCAtIHBhZCwgc2l6ZSwgc2IgKyBwYWQpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIC8vIEJveFxcbiAgICAgIHFyLmFkZEJsYW5rKHNsIC0gcGFkLCBzdCAtIHBhZCwgc3IgKyBwYWQsIHNiICsgcGFkKTtcXG4gICAgfVxcblxcbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHNldHRpbmdzLmZvbnRjb2xvcjtcXG4gICAgY29udGV4dC5mb250ID0gZm9udDtcXG4gICAgY29udGV4dC5maWxsVGV4dChzZXR0aW5ncy5sYWJlbCwgc2wgKiBzaXplLCBzdCAqIHNpemUgKyAwLjc1ICogc2V0dGluZ3MubVNpemUgKiBzaXplKTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGRyYXdCYWNrZ3JvdW5kSW1hZ2UocXIsIGNvbnRleHQsIHNldHRpbmdzKSB7XFxuXFxuICAgIHZhciBzaXplID0gc2V0dGluZ3Muc2l6ZTtcXG4gICAgdmFyIHcgPSBzZXR0aW5ncy5pbWFnZS5uYXR1cmFsV2lkdGggfHwgMTtcXG4gICAgdmFyIGggPSBzZXR0aW5ncy5pbWFnZS5uYXR1cmFsSGVpZ2h0IHx8IDE7XFxuICAgIHZhciBzaCA9IHNldHRpbmdzLm1TaXplO1xcbiAgICB2YXIgc3cgPSBzaCAqIHcgLyBoO1xcbiAgICB2YXIgc2wgPSAoMSAtIHN3KSAqIHNldHRpbmdzLm1Qb3NYO1xcbiAgICB2YXIgc3QgPSAoMSAtIHNoKSAqIHNldHRpbmdzLm1Qb3NZO1xcbiAgICB2YXIgc3IgPSBzbCArIHN3O1xcbiAgICB2YXIgc2IgPSBzdCArIHNoO1xcbiAgICB2YXIgcGFkID0gMC4wMTtcXG5cXG4gICAgaWYgKHNldHRpbmdzLm1vZGUgPT09IDMpIHtcXG4gICAgICAvLyBTdHJpcFxcbiAgICAgIHFyLmFkZEJsYW5rKDAsIHN0IC0gcGFkLCBzaXplLCBzYiArIHBhZCk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgLy8gQm94XFxuICAgICAgcXIuYWRkQmxhbmsoc2wgLSBwYWQsIHN0IC0gcGFkLCBzciArIHBhZCwgc2IgKyBwYWQpO1xcbiAgICB9XFxuXFxuICAgIGNvbnRleHQuZHJhd0ltYWdlKHNldHRpbmdzLmltYWdlLCBzbCAqIHNpemUsIHN0ICogc2l6ZSwgc3cgKiBzaXplLCBzaCAqIHNpemUpO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gZHJhd0JhY2tncm91bmQocXIsIGNvbnRleHQsIHNldHRpbmdzKSB7XFxuXFxuICAgIGlmICgkKHNldHRpbmdzLmJhY2tncm91bmQpLmlzKCdpbWcnKSkge1xcbiAgICAgIGNvbnRleHQuZHJhd0ltYWdlKHNldHRpbmdzLmJhY2tncm91bmQsIDAsIDAsIHNldHRpbmdzLnNpemUsIHNldHRpbmdzLnNpemUpO1xcbiAgICB9IGVsc2UgaWYgKHNldHRpbmdzLmJhY2tncm91bmQpIHtcXG4gICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHNldHRpbmdzLmJhY2tncm91bmQ7XFxuICAgICAgY29udGV4dC5maWxsUmVjdChzZXR0aW5ncy5sZWZ0LCBzZXR0aW5ncy50b3AsIHNldHRpbmdzLnNpemUsIHNldHRpbmdzLnNpemUpO1xcbiAgICB9XFxuXFxuICAgIHZhciBtb2RlID0gc2V0dGluZ3MubW9kZTtcXG4gICAgaWYgKG1vZGUgPT09IDEgfHwgbW9kZSA9PT0gMikge1xcbiAgICAgIGRyYXdCYWNrZ3JvdW5kTGFiZWwocXIsIGNvbnRleHQsIHNldHRpbmdzKTtcXG4gICAgfSBlbHNlIGlmIChtb2RlID09PSAzIHx8IG1vZGUgPT09IDQpIHtcXG4gICAgICBkcmF3QmFja2dyb3VuZEltYWdlKHFyLCBjb250ZXh0LCBzZXR0aW5ncyk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGRyYXdNb2R1bGVEZWZhdWx0KHFyLCBjb250ZXh0LCBzZXR0aW5ncywgbGVmdCwgdG9wLCB3aWR0aCwgcm93LCBjb2wpIHtcXG5cXG4gICAgaWYgKHFyLmlzRGFyayhyb3csIGNvbCkpIHtcXG4gICAgICBjb250ZXh0LnJlY3QobGVmdCwgdG9wLCB3aWR0aCwgd2lkdGgpO1xcbiAgICB9XFxuICB9XFxuXFxuICBmdW5jdGlvbiBkcmF3TW9kdWxlUm91bmRlZERhcmsoY3R4LCBsLCB0LCByLCBiLCByYWQsIG53LCBuZSwgc2UsIHN3KSB7XFxuXFxuICAgIGlmIChudykge1xcbiAgICAgIGN0eC5tb3ZlVG8obCArIHJhZCwgdCk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgY3R4Lm1vdmVUbyhsLCB0KTtcXG4gICAgfVxcblxcbiAgICBpZiAobmUpIHtcXG4gICAgICBjdHgubGluZVRvKHIgLSByYWQsIHQpO1xcbiAgICAgIGN0eC5hcmNUbyhyLCB0LCByLCBiLCByYWQpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGN0eC5saW5lVG8ociwgdCk7XFxuICAgIH1cXG5cXG4gICAgaWYgKHNlKSB7XFxuICAgICAgY3R4LmxpbmVUbyhyLCBiIC0gcmFkKTtcXG4gICAgICBjdHguYXJjVG8ociwgYiwgbCwgYiwgcmFkKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBjdHgubGluZVRvKHIsIGIpO1xcbiAgICB9XFxuXFxuICAgIGlmIChzdykge1xcbiAgICAgIGN0eC5saW5lVG8obCArIHJhZCwgYik7XFxuICAgICAgY3R4LmFyY1RvKGwsIGIsIGwsIHQsIHJhZCk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgY3R4LmxpbmVUbyhsLCBiKTtcXG4gICAgfVxcblxcbiAgICBpZiAobncpIHtcXG4gICAgICBjdHgubGluZVRvKGwsIHQgKyByYWQpO1xcbiAgICAgIGN0eC5hcmNUbyhsLCB0LCByLCB0LCByYWQpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGN0eC5saW5lVG8obCwgdCk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGRyYXdNb2R1bGVSb3VuZGVuZExpZ2h0KGN0eCwgbCwgdCwgciwgYiwgcmFkLCBudywgbmUsIHNlLCBzdykge1xcblxcbiAgICBpZiAobncpIHtcXG4gICAgICBjdHgubW92ZVRvKGwgKyByYWQsIHQpO1xcbiAgICAgIGN0eC5saW5lVG8obCwgdCk7XFxuICAgICAgY3R4LmxpbmVUbyhsLCB0ICsgcmFkKTtcXG4gICAgICBjdHguYXJjVG8obCwgdCwgbCArIHJhZCwgdCwgcmFkKTtcXG4gICAgfVxcblxcbiAgICBpZiAobmUpIHtcXG4gICAgICBjdHgubW92ZVRvKHIgLSByYWQsIHQpO1xcbiAgICAgIGN0eC5saW5lVG8ociwgdCk7XFxuICAgICAgY3R4LmxpbmVUbyhyLCB0ICsgcmFkKTtcXG4gICAgICBjdHguYXJjVG8ociwgdCwgciAtIHJhZCwgdCwgcmFkKTtcXG4gICAgfVxcblxcbiAgICBpZiAoc2UpIHtcXG4gICAgICBjdHgubW92ZVRvKHIgLSByYWQsIGIpO1xcbiAgICAgIGN0eC5saW5lVG8ociwgYik7XFxuICAgICAgY3R4LmxpbmVUbyhyLCBiIC0gcmFkKTtcXG4gICAgICBjdHguYXJjVG8ociwgYiwgciAtIHJhZCwgYiwgcmFkKTtcXG4gICAgfVxcblxcbiAgICBpZiAoc3cpIHtcXG4gICAgICBjdHgubW92ZVRvKGwgKyByYWQsIGIpO1xcbiAgICAgIGN0eC5saW5lVG8obCwgYik7XFxuICAgICAgY3R4LmxpbmVUbyhsLCBiIC0gcmFkKTtcXG4gICAgICBjdHguYXJjVG8obCwgYiwgbCArIHJhZCwgYiwgcmFkKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gZHJhd01vZHVsZVJvdW5kZWQocXIsIGNvbnRleHQsIHNldHRpbmdzLCBsZWZ0LCB0b3AsIHdpZHRoLCByb3csIGNvbCkge1xcblxcbiAgICB2YXIgaXNEYXJrID0gcXIuaXNEYXJrO1xcbiAgICB2YXIgcmlnaHQgPSBsZWZ0ICsgd2lkdGg7XFxuICAgIHZhciBib3R0b20gPSB0b3AgKyB3aWR0aDtcXG4gICAgdmFyIHJhZGl1cyA9IHNldHRpbmdzLnJhZGl1cyAqIHdpZHRoO1xcbiAgICB2YXIgcm93VCA9IHJvdyAtIDE7XFxuICAgIHZhciByb3dCID0gcm93ICsgMTtcXG4gICAgdmFyIGNvbEwgPSBjb2wgLSAxO1xcbiAgICB2YXIgY29sUiA9IGNvbCArIDE7XFxuICAgIHZhciBjZW50ZXIgPSBpc0Rhcmsocm93LCBjb2wpO1xcbiAgICB2YXIgbm9ydGh3ZXN0ID0gaXNEYXJrKHJvd1QsIGNvbEwpO1xcbiAgICB2YXIgbm9ydGggPSBpc0Rhcmsocm93VCwgY29sKTtcXG4gICAgdmFyIG5vcnRoZWFzdCA9IGlzRGFyayhyb3dULCBjb2xSKTtcXG4gICAgdmFyIGVhc3QgPSBpc0Rhcmsocm93LCBjb2xSKTtcXG4gICAgdmFyIHNvdXRoZWFzdCA9IGlzRGFyayhyb3dCLCBjb2xSKTtcXG4gICAgdmFyIHNvdXRoID0gaXNEYXJrKHJvd0IsIGNvbCk7XFxuICAgIHZhciBzb3V0aHdlc3QgPSBpc0Rhcmsocm93QiwgY29sTCk7XFxuICAgIHZhciB3ZXN0ID0gaXNEYXJrKHJvdywgY29sTCk7XFxuXFxuICAgIGlmIChjZW50ZXIpIHtcXG4gICAgICBkcmF3TW9kdWxlUm91bmRlZERhcmsoY29udGV4dCwgbGVmdCwgdG9wLCByaWdodCwgYm90dG9tLCByYWRpdXMsICFub3J0aCAmJiAhd2VzdCwgIW5vcnRoICYmICFlYXN0LCAhc291dGggJiYgIWVhc3QsICFzb3V0aCAmJiAhd2VzdCk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgZHJhd01vZHVsZVJvdW5kZW5kTGlnaHQoY29udGV4dCwgbGVmdCwgdG9wLCByaWdodCwgYm90dG9tLCByYWRpdXMsIG5vcnRoICYmIHdlc3QgJiYgbm9ydGh3ZXN0LCBub3J0aCAmJiBlYXN0ICYmIG5vcnRoZWFzdCwgc291dGggJiYgZWFzdCAmJiBzb3V0aGVhc3QsIHNvdXRoICYmIHdlc3QgJiYgc291dGh3ZXN0KTtcXG4gICAgfVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gZHJhd01vZHVsZXMocXIsIGNvbnRleHQsIHNldHRpbmdzKSB7XFxuXFxuICAgIHZhciBtb2R1bGVDb3VudCA9IHFyLm1vZHVsZUNvdW50O1xcbiAgICB2YXIgbW9kdWxlU2l6ZSA9IHNldHRpbmdzLnNpemUgLyBtb2R1bGVDb3VudDtcXG4gICAgdmFyIGZuID0gZHJhd01vZHVsZURlZmF1bHQ7XFxuICAgIHZhciByb3c7XFxuICAgIHZhciBjb2w7XFxuXFxuICAgIGlmIChoYXNBcmNUbyAmJiBzZXR0aW5ncy5yYWRpdXMgPiAwICYmIHNldHRpbmdzLnJhZGl1cyA8PSAwLjUpIHtcXG4gICAgICBmbiA9IGRyYXdNb2R1bGVSb3VuZGVkO1xcbiAgICB9XFxuXFxuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XFxuICAgIGZvciAocm93ID0gMDsgcm93IDwgbW9kdWxlQ291bnQ7IHJvdyArPSAxKSB7XFxuICAgICAgZm9yIChjb2wgPSAwOyBjb2wgPCBtb2R1bGVDb3VudDsgY29sICs9IDEpIHtcXG5cXG4gICAgICAgIHZhciBsID0gc2V0dGluZ3MubGVmdCArIGNvbCAqIG1vZHVsZVNpemU7XFxuICAgICAgICB2YXIgdCA9IHNldHRpbmdzLnRvcCArIHJvdyAqIG1vZHVsZVNpemU7XFxuICAgICAgICB2YXIgdyA9IG1vZHVsZVNpemU7XFxuXFxuICAgICAgICBmbihxciwgY29udGV4dCwgc2V0dGluZ3MsIGwsIHQsIHcsIHJvdywgY29sKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgaWYgKCQoc2V0dGluZ3MuZmlsbCkuaXMoJ2ltZycpKSB7XFxuICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9ICdyZ2JhKDAsMCwwLDAuNSknO1xcbiAgICAgIGNvbnRleHQubGluZVdpZHRoID0gMjtcXG4gICAgICBjb250ZXh0LnN0cm9rZSgpO1xcbiAgICAgIHZhciBwcmV2ID0gY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb247XFxuICAgICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnZGVzdGluYXRpb24tb3V0JztcXG4gICAgICBjb250ZXh0LmZpbGwoKTtcXG4gICAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IHByZXY7XFxuXFxuICAgICAgY29udGV4dC5jbGlwKCk7XFxuICAgICAgY29udGV4dC5kcmF3SW1hZ2Uoc2V0dGluZ3MuZmlsbCwgMCwgMCwgc2V0dGluZ3Muc2l6ZSwgc2V0dGluZ3Muc2l6ZSk7XFxuICAgICAgY29udGV4dC5yZXN0b3JlKCk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBzZXR0aW5ncy5maWxsO1xcbiAgICAgIGNvbnRleHQuZmlsbCgpO1xcbiAgICB9XFxuICB9XFxuXFxuICAvLyBEcmF3cyBRUiBjb2RlIHRvIHRoZSBnaXZlbiBgY2FudmFzYCBhbmQgcmV0dXJucyBpdC5cXG4gIGZ1bmN0aW9uIGRyYXdPbkNhbnZhcyhjYW52YXMsIHNldHRpbmdzKSB7XFxuXFxuICAgIHZhciBxciA9IGNyZWF0ZVFSQ29kZShzZXR0aW5ncy50ZXh0LCBzZXR0aW5ncy5lY0xldmVsLCBzZXR0aW5ncy5taW5WZXJzaW9uLCBzZXR0aW5ncy5tYXhWZXJzaW9uLCBzZXR0aW5ncy5xdWlldCk7XFxuICAgIGlmICghcXIpIHtcXG4gICAgICByZXR1cm4gbnVsbDtcXG4gICAgfVxcblxcbiAgICB2YXIgJGNhbnZhcyA9ICQoY2FudmFzKS5kYXRhKCdxcmNvZGUnLCBxcik7XFxuICAgIHZhciBjb250ZXh0ID0gJGNhbnZhc1swXS5nZXRDb250ZXh0KCcyZCcpO1xcblxcbiAgICBkcmF3QmFja2dyb3VuZChxciwgY29udGV4dCwgc2V0dGluZ3MpO1xcbiAgICBkcmF3TW9kdWxlcyhxciwgY29udGV4dCwgc2V0dGluZ3MpO1xcblxcbiAgICByZXR1cm4gJGNhbnZhcztcXG4gIH1cXG5cXG4gIC8vIFJldHVybnMgYSBgY2FudmFzYCBlbGVtZW50IHJlcHJlc2VudGluZyB0aGUgUVIgY29kZSBmb3IgdGhlIGdpdmVuIHNldHRpbmdzLlxcbiAgZnVuY3Rpb24gY3JlYXRlQ2FudmFzKHNldHRpbmdzKSB7XFxuXFxuICAgIHZhciAkY2FudmFzID0gJCgnPGNhbnZhcy8+JykuYXR0cignd2lkdGgnLCBzZXR0aW5ncy5zaXplKS5hdHRyKCdoZWlnaHQnLCBzZXR0aW5ncy5zaXplKTtcXG4gICAgcmV0dXJuIGRyYXdPbkNhbnZhcygkY2FudmFzLCBzZXR0aW5ncyk7XFxuICB9XFxuXFxuICAvLyBSZXR1cm5zIGFuIGBpbWFnZWAgZWxlbWVudCByZXByZXNlbnRpbmcgdGhlIFFSIGNvZGUgZm9yIHRoZSBnaXZlbiBzZXR0aW5ncy5cXG4gIGZ1bmN0aW9uIGNyZWF0ZUltYWdlKHNldHRpbmdzKSB7XFxuXFxuICAgIHJldHVybiAkKCc8aW1nLz4nKS5hdHRyKCdzcmMnLCBjcmVhdGVDYW52YXMoc2V0dGluZ3MpWzBdLnRvRGF0YVVSTCgnaW1hZ2UvcG5nJykpO1xcbiAgfVxcblxcbiAgLy8gUmV0dXJucyBhIGBkaXZgIGVsZW1lbnQgcmVwcmVzZW50aW5nIHRoZSBRUiBjb2RlIGZvciB0aGUgZ2l2ZW4gc2V0dGluZ3MuXFxuICBmdW5jdGlvbiBjcmVhdGVEaXYoc2V0dGluZ3MpIHtcXG5cXG4gICAgdmFyIHFyID0gY3JlYXRlUVJDb2RlKHNldHRpbmdzLnRleHQsIHNldHRpbmdzLmVjTGV2ZWwsIHNldHRpbmdzLm1pblZlcnNpb24sIHNldHRpbmdzLm1heFZlcnNpb24sIHNldHRpbmdzLnF1aWV0KTtcXG4gICAgaWYgKCFxcikge1xcbiAgICAgIHJldHVybiBudWxsO1xcbiAgICB9XFxuXFxuICAgIC8vIHNvbWUgc2hvcnRjdXRzIHRvIGltcHJvdmUgY29tcHJlc3Npb25cXG4gICAgdmFyIHNldHRpbmdzX3NpemUgPSBzZXR0aW5ncy5zaXplO1xcbiAgICB2YXIgc2V0dGluZ3NfYmdDb2xvciA9IHNldHRpbmdzLmJhY2tncm91bmQ7XFxuICAgIHZhciBtYXRoX2Zsb29yID0gTWF0aC5mbG9vcjtcXG5cXG4gICAgdmFyIG1vZHVsZUNvdW50ID0gcXIubW9kdWxlQ291bnQ7XFxuICAgIHZhciBtb2R1bGVTaXplID0gbWF0aF9mbG9vcihzZXR0aW5nc19zaXplIC8gbW9kdWxlQ291bnQpO1xcbiAgICB2YXIgb2Zmc2V0ID0gbWF0aF9mbG9vcigwLjUgKiAoc2V0dGluZ3Nfc2l6ZSAtIG1vZHVsZVNpemUgKiBtb2R1bGVDb3VudCkpO1xcblxcbiAgICB2YXIgcm93O1xcbiAgICB2YXIgY29sO1xcblxcbiAgICB2YXIgY29udGFpbmVyQ1NTID0ge1xcbiAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxcbiAgICAgIGxlZnQ6IDAsXFxuICAgICAgdG9wOiAwLFxcbiAgICAgIHBhZGRpbmc6IDAsXFxuICAgICAgbWFyZ2luOiAwLFxcbiAgICAgIHdpZHRoOiBzZXR0aW5nc19zaXplLFxcbiAgICAgIGhlaWdodDogc2V0dGluZ3Nfc2l6ZVxcbiAgICB9O1xcbiAgICB2YXIgZGFya0NTUyA9IHtcXG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcXG4gICAgICBwYWRkaW5nOiAwLFxcbiAgICAgIG1hcmdpbjogMCxcXG4gICAgICB3aWR0aDogbW9kdWxlU2l6ZSxcXG4gICAgICBoZWlnaHQ6IG1vZHVsZVNpemUsXFxuICAgICAgJ2JhY2tncm91bmQtY29sb3InOiBzZXR0aW5ncy5maWxsXFxuICAgIH07XFxuXFxuICAgIHZhciAkZGl2ID0gJCgnPGRpdi8+JykuZGF0YSgncXJjb2RlJywgcXIpLmNzcyhjb250YWluZXJDU1MpO1xcblxcbiAgICBpZiAoc2V0dGluZ3NfYmdDb2xvcikge1xcbiAgICAgICRkaXYuY3NzKCdiYWNrZ3JvdW5kLWNvbG9yJywgc2V0dGluZ3NfYmdDb2xvcik7XFxuICAgIH1cXG5cXG4gICAgZm9yIChyb3cgPSAwOyByb3cgPCBtb2R1bGVDb3VudDsgcm93ICs9IDEpIHtcXG4gICAgICBmb3IgKGNvbCA9IDA7IGNvbCA8IG1vZHVsZUNvdW50OyBjb2wgKz0gMSkge1xcbiAgICAgICAgaWYgKHFyLmlzRGFyayhyb3csIGNvbCkpIHtcXG4gICAgICAgICAgJCgnPGRpdi8+JykuY3NzKGRhcmtDU1MpLmNzcyh7XFxuICAgICAgICAgICAgbGVmdDogb2Zmc2V0ICsgY29sICogbW9kdWxlU2l6ZSxcXG4gICAgICAgICAgICB0b3A6IG9mZnNldCArIHJvdyAqIG1vZHVsZVNpemVcXG4gICAgICAgICAgfSkuYXBwZW5kVG8oJGRpdik7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHJldHVybiAkZGl2O1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gY3JlYXRlSFRNTChzZXR0aW5ncykge1xcblxcbiAgICBpZiAoaGFzQ2FudmFzICYmIHNldHRpbmdzLnJlbmRlciA9PT0gJ2NhbnZhcycpIHtcXG4gICAgICByZXR1cm4gY3JlYXRlQ2FudmFzKHNldHRpbmdzKTtcXG4gICAgfSBlbHNlIGlmIChoYXNDYW52YXMgJiYgc2V0dGluZ3MucmVuZGVyID09PSAnaW1hZ2UnKSB7XFxuICAgICAgcmV0dXJuIGNyZWF0ZUltYWdlKHNldHRpbmdzKTtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gY3JlYXRlRGl2KHNldHRpbmdzKTtcXG4gIH1cXG5cXG4gIC8vIFBsdWdpblxcbiAgLy8gPT09PT09XFxuXFxuICAvLyBEZWZhdWx0IHNldHRpbmdzXFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tXFxuICB2YXIgZGVmYXVsdHMgPSB7XFxuXFxuICAgIC8vIHJlbmRlciBtZXRob2Q6IGAnY2FudmFzJ2AsIGAnaW1hZ2UnYCBvciBgJ2RpdidgXFxuICAgIHJlbmRlcjogJ2NhbnZhcycsXFxuXFxuICAgIC8vIHZlcnNpb24gcmFuZ2Ugc29tZXdoZXJlIGluIDEgLi4gNDBcXG4gICAgbWluVmVyc2lvbjogMSxcXG4gICAgbWF4VmVyc2lvbjogNDAsXFxuXFxuICAgIC8vIGVycm9yIGNvcnJlY3Rpb24gbGV2ZWw6IGAnTCdgLCBgJ00nYCwgYCdRJ2Agb3IgYCdIJ2BcXG4gICAgZWNMZXZlbDogJ0wnLFxcblxcbiAgICAvLyBvZmZzZXQgaW4gcGl4ZWwgaWYgZHJhd24gb250byBleGlzdGluZyBjYW52YXNcXG4gICAgbGVmdDogMCxcXG4gICAgdG9wOiAwLFxcblxcbiAgICAvLyBzaXplIGluIHBpeGVsXFxuICAgIHNpemU6IDIwMCxcXG5cXG4gICAgLy8gY29kZSBjb2xvciBvciBpbWFnZSBlbGVtZW50XFxuICAgIGZpbGw6ICcjMDAwJyxcXG5cXG4gICAgLy8gYmFja2dyb3VuZCBjb2xvciBvciBpbWFnZSBlbGVtZW50LCBgbnVsbGAgZm9yIHRyYW5zcGFyZW50IGJhY2tncm91bmRcXG4gICAgYmFja2dyb3VuZDogbnVsbCxcXG5cXG4gICAgLy8gY29udGVudFxcbiAgICB0ZXh0OiAnbm8gdGV4dCcsXFxuXFxuICAgIC8vIGNvcm5lciByYWRpdXMgcmVsYXRpdmUgdG8gbW9kdWxlIHdpZHRoOiAwLjAgLi4gMC41XFxuICAgIHJhZGl1czogMCxcXG5cXG4gICAgLy8gcXVpZXQgem9uZSBpbiBtb2R1bGVzXFxuICAgIHF1aWV0OiAwLFxcblxcbiAgICAvLyBtb2Rlc1xcbiAgICAvLyAwOiBub3JtYWxcXG4gICAgLy8gMTogbGFiZWwgc3RyaXBcXG4gICAgLy8gMjogbGFiZWwgYm94XFxuICAgIC8vIDM6IGltYWdlIHN0cmlwXFxuICAgIC8vIDQ6IGltYWdlIGJveFxcbiAgICBtb2RlOiAwLFxcblxcbiAgICBtU2l6ZTogMC4xLFxcbiAgICBtUG9zWDogMC41LFxcbiAgICBtUG9zWTogMC41LFxcblxcbiAgICBsYWJlbDogJ25vIGxhYmVsJyxcXG4gICAgZm9udG5hbWU6ICdzYW5zJyxcXG4gICAgZm9udGNvbG9yOiAnIzAwMCcsXFxuXFxuICAgIGltYWdlOiBudWxsXFxuICB9O1xcblxcbiAgLy8gUmVnaXN0ZXIgdGhlIHBsdWdpblxcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgJC5mbi5xcmNvZGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xcblxcbiAgICB2YXIgc2V0dGluZ3MgPSAkLmV4dGVuZCh7fSwgZGVmYXVsdHMsIG9wdGlvbnMpO1xcblxcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG5cXG4gICAgICBpZiAodGhpcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnY2FudmFzJykge1xcbiAgICAgICAgZHJhd09uQ2FudmFzKHRoaXMsIHNldHRpbmdzKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgJCh0aGlzKS5hcHBlbmQoY3JlYXRlSFRNTChzZXR0aW5ncykpO1xcbiAgICAgIH1cXG4gICAgfSk7XFxuICB9O1xcbn0pKGZ1bmN0aW9uICgpIHtcXG5cXG4gIC8vIGBxcmNvZGVgIGlzIHRoZSBzaW5nbGUgcHVibGljIGZ1bmN0aW9uIGRlZmluZWQgYnkgdGhlIGBRUiBDb2RlIEdlbmVyYXRvcmBcXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAvL1xcbiAgLy8gUVIgQ29kZSBHZW5lcmF0b3IgZm9yIEphdmFTY3JpcHRcXG4gIC8vXFxuICAvLyBDb3B5cmlnaHQgKGMpIDIwMDkgS2F6dWhpa28gQXJhc2VcXG4gIC8vXFxuICAvLyBVUkw6IGh0dHA6Ly93d3cuZC1wcm9qZWN0LmNvbS9cXG4gIC8vXFxuICAvLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2U6XFxuICAvLyAgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcXG4gIC8vXFxuICAvLyBUaGUgd29yZCAnUVIgQ29kZScgaXMgcmVnaXN0ZXJlZCB0cmFkZW1hcmsgb2ZcXG4gIC8vIERFTlNPIFdBVkUgSU5DT1JQT1JBVEVEXFxuICAvLyAgaHR0cDovL3d3dy5kZW5zby13YXZlLmNvbS9xcmNvZGUvZmFxcGF0ZW50LWUuaHRtbFxcbiAgLy9cXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFxuICB2YXIgcXJjb2RlID0gZnVuY3Rpb24gKCkge1xcblxcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICAvLyBxcmNvZGVcXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cXG4gICAgLyoqXFxuICAgICAqIHFyY29kZVxcbiAgICAgKiBAcGFyYW0gdHlwZU51bWJlciAxIHRvIDQwXFxuICAgICAqIEBwYXJhbSBlcnJvckNvcnJlY3RMZXZlbCAnTCcsJ00nLCdRJywnSCdcXG4gICAgICovXFxuICAgIHZhciBxcmNvZGUgPSBmdW5jdGlvbiBxcmNvZGUodHlwZU51bWJlciwgZXJyb3JDb3JyZWN0TGV2ZWwpIHtcXG5cXG4gICAgICB2YXIgUEFEMCA9IDB4RUM7XFxuICAgICAgdmFyIFBBRDEgPSAweDExO1xcblxcbiAgICAgIHZhciBfdHlwZU51bWJlciA9IHR5cGVOdW1iZXI7XFxuICAgICAgdmFyIF9lcnJvckNvcnJlY3RMZXZlbCA9IFFSRXJyb3JDb3JyZWN0TGV2ZWxbZXJyb3JDb3JyZWN0TGV2ZWxdO1xcbiAgICAgIHZhciBfbW9kdWxlcyA9IG51bGw7XFxuICAgICAgdmFyIF9tb2R1bGVDb3VudCA9IDA7XFxuICAgICAgdmFyIF9kYXRhQ2FjaGUgPSBudWxsO1xcbiAgICAgIHZhciBfZGF0YUxpc3QgPSBuZXcgQXJyYXkoKTtcXG5cXG4gICAgICB2YXIgX3RoaXMgPSB7fTtcXG5cXG4gICAgICB2YXIgbWFrZUltcGwgPSBmdW5jdGlvbiBtYWtlSW1wbCh0ZXN0LCBtYXNrUGF0dGVybikge1xcblxcbiAgICAgICAgX21vZHVsZUNvdW50ID0gX3R5cGVOdW1iZXIgKiA0ICsgMTc7XFxuICAgICAgICBfbW9kdWxlcyA9IGZ1bmN0aW9uIChtb2R1bGVDb3VudCkge1xcbiAgICAgICAgICB2YXIgbW9kdWxlcyA9IG5ldyBBcnJheShtb2R1bGVDb3VudCk7XFxuICAgICAgICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IG1vZHVsZUNvdW50OyByb3cgKz0gMSkge1xcbiAgICAgICAgICAgIG1vZHVsZXNbcm93XSA9IG5ldyBBcnJheShtb2R1bGVDb3VudCk7XFxuICAgICAgICAgICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgbW9kdWxlQ291bnQ7IGNvbCArPSAxKSB7XFxuICAgICAgICAgICAgICBtb2R1bGVzW3Jvd11bY29sXSA9IG51bGw7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICAgIHJldHVybiBtb2R1bGVzO1xcbiAgICAgICAgfShfbW9kdWxlQ291bnQpO1xcblxcbiAgICAgICAgc2V0dXBQb3NpdGlvblByb2JlUGF0dGVybigwLCAwKTtcXG4gICAgICAgIHNldHVwUG9zaXRpb25Qcm9iZVBhdHRlcm4oX21vZHVsZUNvdW50IC0gNywgMCk7XFxuICAgICAgICBzZXR1cFBvc2l0aW9uUHJvYmVQYXR0ZXJuKDAsIF9tb2R1bGVDb3VudCAtIDcpO1xcbiAgICAgICAgc2V0dXBQb3NpdGlvbkFkanVzdFBhdHRlcm4oKTtcXG4gICAgICAgIHNldHVwVGltaW5nUGF0dGVybigpO1xcbiAgICAgICAgc2V0dXBUeXBlSW5mbyh0ZXN0LCBtYXNrUGF0dGVybik7XFxuXFxuICAgICAgICBpZiAoX3R5cGVOdW1iZXIgPj0gNykge1xcbiAgICAgICAgICBzZXR1cFR5cGVOdW1iZXIodGVzdCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoX2RhdGFDYWNoZSA9PSBudWxsKSB7XFxuICAgICAgICAgIF9kYXRhQ2FjaGUgPSBjcmVhdGVEYXRhKF90eXBlTnVtYmVyLCBfZXJyb3JDb3JyZWN0TGV2ZWwsIF9kYXRhTGlzdCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBtYXBEYXRhKF9kYXRhQ2FjaGUsIG1hc2tQYXR0ZXJuKTtcXG4gICAgICB9O1xcblxcbiAgICAgIHZhciBzZXR1cFBvc2l0aW9uUHJvYmVQYXR0ZXJuID0gZnVuY3Rpb24gc2V0dXBQb3NpdGlvblByb2JlUGF0dGVybihyb3csIGNvbCkge1xcblxcbiAgICAgICAgZm9yICh2YXIgciA9IC0xOyByIDw9IDc7IHIgKz0gMSkge1xcblxcbiAgICAgICAgICBpZiAocm93ICsgciA8PSAtMSB8fCBfbW9kdWxlQ291bnQgPD0gcm93ICsgcikgY29udGludWU7XFxuXFxuICAgICAgICAgIGZvciAodmFyIGMgPSAtMTsgYyA8PSA3OyBjICs9IDEpIHtcXG5cXG4gICAgICAgICAgICBpZiAoY29sICsgYyA8PSAtMSB8fCBfbW9kdWxlQ291bnQgPD0gY29sICsgYykgY29udGludWU7XFxuXFxuICAgICAgICAgICAgaWYgKDAgPD0gciAmJiByIDw9IDYgJiYgKGMgPT0gMCB8fCBjID09IDYpIHx8IDAgPD0gYyAmJiBjIDw9IDYgJiYgKHIgPT0gMCB8fCByID09IDYpIHx8IDIgPD0gciAmJiByIDw9IDQgJiYgMiA8PSBjICYmIGMgPD0gNCkge1xcbiAgICAgICAgICAgICAgX21vZHVsZXNbcm93ICsgcl1bY29sICsgY10gPSB0cnVlO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICBfbW9kdWxlc1tyb3cgKyByXVtjb2wgKyBjXSA9IGZhbHNlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH07XFxuXFxuICAgICAgdmFyIGdldEJlc3RNYXNrUGF0dGVybiA9IGZ1bmN0aW9uIGdldEJlc3RNYXNrUGF0dGVybigpIHtcXG5cXG4gICAgICAgIHZhciBtaW5Mb3N0UG9pbnQgPSAwO1xcbiAgICAgICAgdmFyIHBhdHRlcm4gPSAwO1xcblxcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpICs9IDEpIHtcXG5cXG4gICAgICAgICAgbWFrZUltcGwodHJ1ZSwgaSk7XFxuXFxuICAgICAgICAgIHZhciBsb3N0UG9pbnQgPSBRUlV0aWwuZ2V0TG9zdFBvaW50KF90aGlzKTtcXG5cXG4gICAgICAgICAgaWYgKGkgPT0gMCB8fCBtaW5Mb3N0UG9pbnQgPiBsb3N0UG9pbnQpIHtcXG4gICAgICAgICAgICBtaW5Mb3N0UG9pbnQgPSBsb3N0UG9pbnQ7XFxuICAgICAgICAgICAgcGF0dGVybiA9IGk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiBwYXR0ZXJuO1xcbiAgICAgIH07XFxuXFxuICAgICAgdmFyIHNldHVwVGltaW5nUGF0dGVybiA9IGZ1bmN0aW9uIHNldHVwVGltaW5nUGF0dGVybigpIHtcXG5cXG4gICAgICAgIGZvciAodmFyIHIgPSA4OyByIDwgX21vZHVsZUNvdW50IC0gODsgciArPSAxKSB7XFxuICAgICAgICAgIGlmIChfbW9kdWxlc1tyXVs2XSAhPSBudWxsKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgX21vZHVsZXNbcl1bNl0gPSByICUgMiA9PSAwO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZm9yICh2YXIgYyA9IDg7IGMgPCBfbW9kdWxlQ291bnQgLSA4OyBjICs9IDEpIHtcXG4gICAgICAgICAgaWYgKF9tb2R1bGVzWzZdW2NdICE9IG51bGwpIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBfbW9kdWxlc1s2XVtjXSA9IGMgJSAyID09IDA7XFxuICAgICAgICB9XFxuICAgICAgfTtcXG5cXG4gICAgICB2YXIgc2V0dXBQb3NpdGlvbkFkanVzdFBhdHRlcm4gPSBmdW5jdGlvbiBzZXR1cFBvc2l0aW9uQWRqdXN0UGF0dGVybigpIHtcXG5cXG4gICAgICAgIHZhciBwb3MgPSBRUlV0aWwuZ2V0UGF0dGVyblBvc2l0aW9uKF90eXBlTnVtYmVyKTtcXG5cXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9zLmxlbmd0aDsgaSArPSAxKSB7XFxuXFxuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcG9zLmxlbmd0aDsgaiArPSAxKSB7XFxuXFxuICAgICAgICAgICAgdmFyIHJvdyA9IHBvc1tpXTtcXG4gICAgICAgICAgICB2YXIgY29sID0gcG9zW2pdO1xcblxcbiAgICAgICAgICAgIGlmIChfbW9kdWxlc1tyb3ddW2NvbF0gIT0gbnVsbCkge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGZvciAodmFyIHIgPSAtMjsgciA8PSAyOyByICs9IDEpIHtcXG5cXG4gICAgICAgICAgICAgIGZvciAodmFyIGMgPSAtMjsgYyA8PSAyOyBjICs9IDEpIHtcXG5cXG4gICAgICAgICAgICAgICAgaWYgKHIgPT0gLTIgfHwgciA9PSAyIHx8IGMgPT0gLTIgfHwgYyA9PSAyIHx8IHIgPT0gMCAmJiBjID09IDApIHtcXG4gICAgICAgICAgICAgICAgICBfbW9kdWxlc1tyb3cgKyByXVtjb2wgKyBjXSA9IHRydWU7XFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgX21vZHVsZXNbcm93ICsgcl1bY29sICsgY10gPSBmYWxzZTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH07XFxuXFxuICAgICAgdmFyIHNldHVwVHlwZU51bWJlciA9IGZ1bmN0aW9uIHNldHVwVHlwZU51bWJlcih0ZXN0KSB7XFxuXFxuICAgICAgICB2YXIgYml0cyA9IFFSVXRpbC5nZXRCQ0hUeXBlTnVtYmVyKF90eXBlTnVtYmVyKTtcXG5cXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTg7IGkgKz0gMSkge1xcbiAgICAgICAgICB2YXIgbW9kID0gIXRlc3QgJiYgKGJpdHMgPj4gaSAmIDEpID09IDE7XFxuICAgICAgICAgIF9tb2R1bGVzW01hdGguZmxvb3IoaSAvIDMpXVtpICUgMyArIF9tb2R1bGVDb3VudCAtIDggLSAzXSA9IG1vZDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTg7IGkgKz0gMSkge1xcbiAgICAgICAgICB2YXIgbW9kID0gIXRlc3QgJiYgKGJpdHMgPj4gaSAmIDEpID09IDE7XFxuICAgICAgICAgIF9tb2R1bGVzW2kgJSAzICsgX21vZHVsZUNvdW50IC0gOCAtIDNdW01hdGguZmxvb3IoaSAvIDMpXSA9IG1vZDtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcblxcbiAgICAgIHZhciBzZXR1cFR5cGVJbmZvID0gZnVuY3Rpb24gc2V0dXBUeXBlSW5mbyh0ZXN0LCBtYXNrUGF0dGVybikge1xcblxcbiAgICAgICAgdmFyIGRhdGEgPSBfZXJyb3JDb3JyZWN0TGV2ZWwgPDwgMyB8IG1hc2tQYXR0ZXJuO1xcbiAgICAgICAgdmFyIGJpdHMgPSBRUlV0aWwuZ2V0QkNIVHlwZUluZm8oZGF0YSk7XFxuXFxuICAgICAgICAvLyB2ZXJ0aWNhbFxcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNTsgaSArPSAxKSB7XFxuXFxuICAgICAgICAgIHZhciBtb2QgPSAhdGVzdCAmJiAoYml0cyA+PiBpICYgMSkgPT0gMTtcXG5cXG4gICAgICAgICAgaWYgKGkgPCA2KSB7XFxuICAgICAgICAgICAgX21vZHVsZXNbaV1bOF0gPSBtb2Q7XFxuICAgICAgICAgIH0gZWxzZSBpZiAoaSA8IDgpIHtcXG4gICAgICAgICAgICBfbW9kdWxlc1tpICsgMV1bOF0gPSBtb2Q7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgX21vZHVsZXNbX21vZHVsZUNvdW50IC0gMTUgKyBpXVs4XSA9IG1vZDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgLy8gaG9yaXpvbnRhbFxcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNTsgaSArPSAxKSB7XFxuXFxuICAgICAgICAgIHZhciBtb2QgPSAhdGVzdCAmJiAoYml0cyA+PiBpICYgMSkgPT0gMTtcXG5cXG4gICAgICAgICAgaWYgKGkgPCA4KSB7XFxuICAgICAgICAgICAgX21vZHVsZXNbOF1bX21vZHVsZUNvdW50IC0gaSAtIDFdID0gbW9kO1xcbiAgICAgICAgICB9IGVsc2UgaWYgKGkgPCA5KSB7XFxuICAgICAgICAgICAgX21vZHVsZXNbOF1bMTUgLSBpIC0gMSArIDFdID0gbW9kO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIF9tb2R1bGVzWzhdWzE1IC0gaSAtIDFdID0gbW9kO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICAvLyBmaXhlZCBtb2R1bGVcXG4gICAgICAgIF9tb2R1bGVzW19tb2R1bGVDb3VudCAtIDhdWzhdID0gIXRlc3Q7XFxuICAgICAgfTtcXG5cXG4gICAgICB2YXIgbWFwRGF0YSA9IGZ1bmN0aW9uIG1hcERhdGEoZGF0YSwgbWFza1BhdHRlcm4pIHtcXG5cXG4gICAgICAgIHZhciBpbmMgPSAtMTtcXG4gICAgICAgIHZhciByb3cgPSBfbW9kdWxlQ291bnQgLSAxO1xcbiAgICAgICAgdmFyIGJpdEluZGV4ID0gNztcXG4gICAgICAgIHZhciBieXRlSW5kZXggPSAwO1xcbiAgICAgICAgdmFyIG1hc2tGdW5jID0gUVJVdGlsLmdldE1hc2tGdW5jdGlvbihtYXNrUGF0dGVybik7XFxuXFxuICAgICAgICBmb3IgKHZhciBjb2wgPSBfbW9kdWxlQ291bnQgLSAxOyBjb2wgPiAwOyBjb2wgLT0gMikge1xcblxcbiAgICAgICAgICBpZiAoY29sID09IDYpIGNvbCAtPSAxO1xcblxcbiAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xcblxcbiAgICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgMjsgYyArPSAxKSB7XFxuXFxuICAgICAgICAgICAgICBpZiAoX21vZHVsZXNbcm93XVtjb2wgLSBjXSA9PSBudWxsKSB7XFxuXFxuICAgICAgICAgICAgICAgIHZhciBkYXJrID0gZmFsc2U7XFxuXFxuICAgICAgICAgICAgICAgIGlmIChieXRlSW5kZXggPCBkYXRhLmxlbmd0aCkge1xcbiAgICAgICAgICAgICAgICAgIGRhcmsgPSAoZGF0YVtieXRlSW5kZXhdID4+PiBiaXRJbmRleCAmIDEpID09IDE7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgdmFyIG1hc2sgPSBtYXNrRnVuYyhyb3csIGNvbCAtIGMpO1xcblxcbiAgICAgICAgICAgICAgICBpZiAobWFzaykge1xcbiAgICAgICAgICAgICAgICAgIGRhcmsgPSAhZGFyaztcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICBfbW9kdWxlc1tyb3ddW2NvbCAtIGNdID0gZGFyaztcXG4gICAgICAgICAgICAgICAgYml0SW5kZXggLT0gMTtcXG5cXG4gICAgICAgICAgICAgICAgaWYgKGJpdEluZGV4ID09IC0xKSB7XFxuICAgICAgICAgICAgICAgICAgYnl0ZUluZGV4ICs9IDE7XFxuICAgICAgICAgICAgICAgICAgYml0SW5kZXggPSA3O1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIHJvdyArPSBpbmM7XFxuXFxuICAgICAgICAgICAgaWYgKHJvdyA8IDAgfHwgX21vZHVsZUNvdW50IDw9IHJvdykge1xcbiAgICAgICAgICAgICAgcm93IC09IGluYztcXG4gICAgICAgICAgICAgIGluYyA9IC1pbmM7XFxuICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9O1xcblxcbiAgICAgIHZhciBjcmVhdGVCeXRlcyA9IGZ1bmN0aW9uIGNyZWF0ZUJ5dGVzKGJ1ZmZlciwgcnNCbG9ja3MpIHtcXG5cXG4gICAgICAgIHZhciBvZmZzZXQgPSAwO1xcblxcbiAgICAgICAgdmFyIG1heERjQ291bnQgPSAwO1xcbiAgICAgICAgdmFyIG1heEVjQ291bnQgPSAwO1xcblxcbiAgICAgICAgdmFyIGRjZGF0YSA9IG5ldyBBcnJheShyc0Jsb2Nrcy5sZW5ndGgpO1xcbiAgICAgICAgdmFyIGVjZGF0YSA9IG5ldyBBcnJheShyc0Jsb2Nrcy5sZW5ndGgpO1xcblxcbiAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCByc0Jsb2Nrcy5sZW5ndGg7IHIgKz0gMSkge1xcblxcbiAgICAgICAgICB2YXIgZGNDb3VudCA9IHJzQmxvY2tzW3JdLmRhdGFDb3VudDtcXG4gICAgICAgICAgdmFyIGVjQ291bnQgPSByc0Jsb2Nrc1tyXS50b3RhbENvdW50IC0gZGNDb3VudDtcXG5cXG4gICAgICAgICAgbWF4RGNDb3VudCA9IE1hdGgubWF4KG1heERjQ291bnQsIGRjQ291bnQpO1xcbiAgICAgICAgICBtYXhFY0NvdW50ID0gTWF0aC5tYXgobWF4RWNDb3VudCwgZWNDb3VudCk7XFxuXFxuICAgICAgICAgIGRjZGF0YVtyXSA9IG5ldyBBcnJheShkY0NvdW50KTtcXG5cXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkY2RhdGFbcl0ubGVuZ3RoOyBpICs9IDEpIHtcXG4gICAgICAgICAgICBkY2RhdGFbcl1baV0gPSAweGZmICYgYnVmZmVyLmdldEJ1ZmZlcigpW2kgKyBvZmZzZXRdO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIG9mZnNldCArPSBkY0NvdW50O1xcblxcbiAgICAgICAgICB2YXIgcnNQb2x5ID0gUVJVdGlsLmdldEVycm9yQ29ycmVjdFBvbHlub21pYWwoZWNDb3VudCk7XFxuICAgICAgICAgIHZhciByYXdQb2x5ID0gcXJQb2x5bm9taWFsKGRjZGF0YVtyXSwgcnNQb2x5LmdldExlbmd0aCgpIC0gMSk7XFxuXFxuICAgICAgICAgIHZhciBtb2RQb2x5ID0gcmF3UG9seS5tb2QocnNQb2x5KTtcXG4gICAgICAgICAgZWNkYXRhW3JdID0gbmV3IEFycmF5KHJzUG9seS5nZXRMZW5ndGgoKSAtIDEpO1xcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVjZGF0YVtyXS5sZW5ndGg7IGkgKz0gMSkge1xcbiAgICAgICAgICAgIHZhciBtb2RJbmRleCA9IGkgKyBtb2RQb2x5LmdldExlbmd0aCgpIC0gZWNkYXRhW3JdLmxlbmd0aDtcXG4gICAgICAgICAgICBlY2RhdGFbcl1baV0gPSBtb2RJbmRleCA+PSAwID8gbW9kUG9seS5nZXRBdChtb2RJbmRleCkgOiAwO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICB2YXIgdG90YWxDb2RlQ291bnQgPSAwO1xcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByc0Jsb2Nrcy5sZW5ndGg7IGkgKz0gMSkge1xcbiAgICAgICAgICB0b3RhbENvZGVDb3VudCArPSByc0Jsb2Nrc1tpXS50b3RhbENvdW50O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdmFyIGRhdGEgPSBuZXcgQXJyYXkodG90YWxDb2RlQ291bnQpO1xcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcXG5cXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF4RGNDb3VudDsgaSArPSAxKSB7XFxuICAgICAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgcnNCbG9ja3MubGVuZ3RoOyByICs9IDEpIHtcXG4gICAgICAgICAgICBpZiAoaSA8IGRjZGF0YVtyXS5sZW5ndGgpIHtcXG4gICAgICAgICAgICAgIGRhdGFbaW5kZXhdID0gZGNkYXRhW3JdW2ldO1xcbiAgICAgICAgICAgICAgaW5kZXggKz0gMTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF4RWNDb3VudDsgaSArPSAxKSB7XFxuICAgICAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgcnNCbG9ja3MubGVuZ3RoOyByICs9IDEpIHtcXG4gICAgICAgICAgICBpZiAoaSA8IGVjZGF0YVtyXS5sZW5ndGgpIHtcXG4gICAgICAgICAgICAgIGRhdGFbaW5kZXhdID0gZWNkYXRhW3JdW2ldO1xcbiAgICAgICAgICAgICAgaW5kZXggKz0gMTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiBkYXRhO1xcbiAgICAgIH07XFxuXFxuICAgICAgdmFyIGNyZWF0ZURhdGEgPSBmdW5jdGlvbiBjcmVhdGVEYXRhKHR5cGVOdW1iZXIsIGVycm9yQ29ycmVjdExldmVsLCBkYXRhTGlzdCkge1xcblxcbiAgICAgICAgdmFyIHJzQmxvY2tzID0gUVJSU0Jsb2NrLmdldFJTQmxvY2tzKHR5cGVOdW1iZXIsIGVycm9yQ29ycmVjdExldmVsKTtcXG5cXG4gICAgICAgIHZhciBidWZmZXIgPSBxckJpdEJ1ZmZlcigpO1xcblxcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhTGlzdC5sZW5ndGg7IGkgKz0gMSkge1xcbiAgICAgICAgICB2YXIgZGF0YSA9IGRhdGFMaXN0W2ldO1xcbiAgICAgICAgICBidWZmZXIucHV0KGRhdGEuZ2V0TW9kZSgpLCA0KTtcXG4gICAgICAgICAgYnVmZmVyLnB1dChkYXRhLmdldExlbmd0aCgpLCBRUlV0aWwuZ2V0TGVuZ3RoSW5CaXRzKGRhdGEuZ2V0TW9kZSgpLCB0eXBlTnVtYmVyKSk7XFxuICAgICAgICAgIGRhdGEud3JpdGUoYnVmZmVyKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIC8vIGNhbGMgbnVtIG1heCBkYXRhLlxcbiAgICAgICAgdmFyIHRvdGFsRGF0YUNvdW50ID0gMDtcXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcnNCbG9ja3MubGVuZ3RoOyBpICs9IDEpIHtcXG4gICAgICAgICAgdG90YWxEYXRhQ291bnQgKz0gcnNCbG9ja3NbaV0uZGF0YUNvdW50O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKGJ1ZmZlci5nZXRMZW5ndGhJbkJpdHMoKSA+IHRvdGFsRGF0YUNvdW50ICogOCkge1xcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvZGUgbGVuZ3RoIG92ZXJmbG93LiAoJyArIGJ1ZmZlci5nZXRMZW5ndGhJbkJpdHMoKSArICc+JyArIHRvdGFsRGF0YUNvdW50ICogOCArICcpJyk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICAvLyBlbmQgY29kZVxcbiAgICAgICAgaWYgKGJ1ZmZlci5nZXRMZW5ndGhJbkJpdHMoKSArIDQgPD0gdG90YWxEYXRhQ291bnQgKiA4KSB7XFxuICAgICAgICAgIGJ1ZmZlci5wdXQoMCwgNCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICAvLyBwYWRkaW5nXFxuICAgICAgICB3aGlsZSAoYnVmZmVyLmdldExlbmd0aEluQml0cygpICUgOCAhPSAwKSB7XFxuICAgICAgICAgIGJ1ZmZlci5wdXRCaXQoZmFsc2UpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgLy8gcGFkZGluZ1xcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcXG5cXG4gICAgICAgICAgaWYgKGJ1ZmZlci5nZXRMZW5ndGhJbkJpdHMoKSA+PSB0b3RhbERhdGFDb3VudCAqIDgpIHtcXG4gICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBidWZmZXIucHV0KFBBRDAsIDgpO1xcblxcbiAgICAgICAgICBpZiAoYnVmZmVyLmdldExlbmd0aEluQml0cygpID49IHRvdGFsRGF0YUNvdW50ICogOCkge1xcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGJ1ZmZlci5wdXQoUEFEMSwgOCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gY3JlYXRlQnl0ZXMoYnVmZmVyLCByc0Jsb2Nrcyk7XFxuICAgICAgfTtcXG5cXG4gICAgICBfdGhpcy5hZGREYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcXG4gICAgICAgIHZhciBuZXdEYXRhID0gcXI4Qml0Qnl0ZShkYXRhKTtcXG4gICAgICAgIF9kYXRhTGlzdC5wdXNoKG5ld0RhdGEpO1xcbiAgICAgICAgX2RhdGFDYWNoZSA9IG51bGw7XFxuICAgICAgfTtcXG5cXG4gICAgICBfdGhpcy5pc0RhcmsgPSBmdW5jdGlvbiAocm93LCBjb2wpIHtcXG4gICAgICAgIGlmIChyb3cgPCAwIHx8IF9tb2R1bGVDb3VudCA8PSByb3cgfHwgY29sIDwgMCB8fCBfbW9kdWxlQ291bnQgPD0gY29sKSB7XFxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyb3cgKyAnLCcgKyBjb2wpO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIF9tb2R1bGVzW3Jvd11bY29sXTtcXG4gICAgICB9O1xcblxcbiAgICAgIF90aGlzLmdldE1vZHVsZUNvdW50ID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgcmV0dXJuIF9tb2R1bGVDb3VudDtcXG4gICAgICB9O1xcblxcbiAgICAgIF90aGlzLm1ha2UgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICBtYWtlSW1wbChmYWxzZSwgZ2V0QmVzdE1hc2tQYXR0ZXJuKCkpO1xcbiAgICAgIH07XFxuXFxuICAgICAgX3RoaXMuY3JlYXRlVGFibGVUYWcgPSBmdW5jdGlvbiAoY2VsbFNpemUsIG1hcmdpbikge1xcblxcbiAgICAgICAgY2VsbFNpemUgPSBjZWxsU2l6ZSB8fCAyO1xcbiAgICAgICAgbWFyZ2luID0gdHlwZW9mIG1hcmdpbiA9PSAndW5kZWZpbmVkJyA/IGNlbGxTaXplICogNCA6IG1hcmdpbjtcXG5cXG4gICAgICAgIHZhciBxckh0bWwgPSAnJztcXG5cXG4gICAgICAgIHFySHRtbCArPSAnPHRhYmxlIHN0eWxlPVxcXCInO1xcbiAgICAgICAgcXJIdG1sICs9ICcgYm9yZGVyLXdpZHRoOiAwcHg7IGJvcmRlci1zdHlsZTogbm9uZTsnO1xcbiAgICAgICAgcXJIdG1sICs9ICcgYm9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTsnO1xcbiAgICAgICAgcXJIdG1sICs9ICcgcGFkZGluZzogMHB4OyBtYXJnaW46ICcgKyBtYXJnaW4gKyAncHg7JztcXG4gICAgICAgIHFySHRtbCArPSAnXFxcIj4nO1xcbiAgICAgICAgcXJIdG1sICs9ICc8dGJvZHk+JztcXG5cXG4gICAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgX3RoaXMuZ2V0TW9kdWxlQ291bnQoKTsgciArPSAxKSB7XFxuXFxuICAgICAgICAgIHFySHRtbCArPSAnPHRyPic7XFxuXFxuICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgX3RoaXMuZ2V0TW9kdWxlQ291bnQoKTsgYyArPSAxKSB7XFxuICAgICAgICAgICAgcXJIdG1sICs9ICc8dGQgc3R5bGU9XFxcIic7XFxuICAgICAgICAgICAgcXJIdG1sICs9ICcgYm9yZGVyLXdpZHRoOiAwcHg7IGJvcmRlci1zdHlsZTogbm9uZTsnO1xcbiAgICAgICAgICAgIHFySHRtbCArPSAnIGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7JztcXG4gICAgICAgICAgICBxckh0bWwgKz0gJyBwYWRkaW5nOiAwcHg7IG1hcmdpbjogMHB4Oyc7XFxuICAgICAgICAgICAgcXJIdG1sICs9ICcgd2lkdGg6ICcgKyBjZWxsU2l6ZSArICdweDsnO1xcbiAgICAgICAgICAgIHFySHRtbCArPSAnIGhlaWdodDogJyArIGNlbGxTaXplICsgJ3B4Oyc7XFxuICAgICAgICAgICAgcXJIdG1sICs9ICcgYmFja2dyb3VuZC1jb2xvcjogJztcXG4gICAgICAgICAgICBxckh0bWwgKz0gX3RoaXMuaXNEYXJrKHIsIGMpID8gJyMwMDAwMDAnIDogJyNmZmZmZmYnO1xcbiAgICAgICAgICAgIHFySHRtbCArPSAnOyc7XFxuICAgICAgICAgICAgcXJIdG1sICs9ICdcXFwiLz4nO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHFySHRtbCArPSAnPC90cj4nO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcXJIdG1sICs9ICc8L3Rib2R5Pic7XFxuICAgICAgICBxckh0bWwgKz0gJzwvdGFibGU+JztcXG5cXG4gICAgICAgIHJldHVybiBxckh0bWw7XFxuICAgICAgfTtcXG5cXG4gICAgICBfdGhpcy5jcmVhdGVJbWdUYWcgPSBmdW5jdGlvbiAoY2VsbFNpemUsIG1hcmdpbikge1xcblxcbiAgICAgICAgY2VsbFNpemUgPSBjZWxsU2l6ZSB8fCAyO1xcbiAgICAgICAgbWFyZ2luID0gdHlwZW9mIG1hcmdpbiA9PSAndW5kZWZpbmVkJyA/IGNlbGxTaXplICogNCA6IG1hcmdpbjtcXG5cXG4gICAgICAgIHZhciBzaXplID0gX3RoaXMuZ2V0TW9kdWxlQ291bnQoKSAqIGNlbGxTaXplICsgbWFyZ2luICogMjtcXG4gICAgICAgIHZhciBtaW4gPSBtYXJnaW47XFxuICAgICAgICB2YXIgbWF4ID0gc2l6ZSAtIG1hcmdpbjtcXG5cXG4gICAgICAgIHJldHVybiBjcmVhdGVJbWdUYWcoc2l6ZSwgc2l6ZSwgZnVuY3Rpb24gKHgsIHkpIHtcXG4gICAgICAgICAgaWYgKG1pbiA8PSB4ICYmIHggPCBtYXggJiYgbWluIDw9IHkgJiYgeSA8IG1heCkge1xcbiAgICAgICAgICAgIHZhciBjID0gTWF0aC5mbG9vcigoeCAtIG1pbikgLyBjZWxsU2l6ZSk7XFxuICAgICAgICAgICAgdmFyIHIgPSBNYXRoLmZsb29yKCh5IC0gbWluKSAvIGNlbGxTaXplKTtcXG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuaXNEYXJrKHIsIGMpID8gMCA6IDE7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgcmV0dXJuIDE7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICAgIH07XFxuXFxuICAgICAgcmV0dXJuIF90aGlzO1xcbiAgICB9O1xcblxcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICAvLyBxcmNvZGUuc3RyaW5nVG9CeXRlc1xcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblxcbiAgICBxcmNvZGUuc3RyaW5nVG9CeXRlcyA9IGZ1bmN0aW9uIChzKSB7XFxuICAgICAgdmFyIGJ5dGVzID0gbmV3IEFycmF5KCk7XFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzLmxlbmd0aDsgaSArPSAxKSB7XFxuICAgICAgICB2YXIgYyA9IHMuY2hhckNvZGVBdChpKTtcXG4gICAgICAgIGJ5dGVzLnB1c2goYyAmIDB4ZmYpO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gYnl0ZXM7XFxuICAgIH07XFxuXFxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgIC8vIHFyY29kZS5jcmVhdGVTdHJpbmdUb0J5dGVzXFxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFxuICAgIC8qKlxcbiAgICAgKiBAcGFyYW0gdW5pY29kZURhdGEgYmFzZTY0IHN0cmluZyBvZiBieXRlIGFycmF5LlxcbiAgICAgKiBbMTZiaXQgVW5pY29kZV0sWzE2Yml0IEJ5dGVzXSwgLi4uXFxuICAgICAqIEBwYXJhbSBudW1DaGFyc1xcbiAgICAgKi9cXG4gICAgcXJjb2RlLmNyZWF0ZVN0cmluZ1RvQnl0ZXMgPSBmdW5jdGlvbiAodW5pY29kZURhdGEsIG51bUNoYXJzKSB7XFxuXFxuICAgICAgLy8gY3JlYXRlIGNvbnZlcnNpb24gbWFwLlxcblxcbiAgICAgIHZhciB1bmljb2RlTWFwID0gZnVuY3Rpb24gKCkge1xcblxcbiAgICAgICAgdmFyIGJpbiA9IGJhc2U2NERlY29kZUlucHV0U3RyZWFtKHVuaWNvZGVEYXRhKTtcXG4gICAgICAgIHZhciByZWFkID0gZnVuY3Rpb24gcmVhZCgpIHtcXG4gICAgICAgICAgdmFyIGIgPSBiaW4ucmVhZCgpO1xcbiAgICAgICAgICBpZiAoYiA9PSAtMSkgdGhyb3cgbmV3IEVycm9yKCk7XFxuICAgICAgICAgIHJldHVybiBiO1xcbiAgICAgICAgfTtcXG5cXG4gICAgICAgIHZhciBjb3VudCA9IDA7XFxuICAgICAgICB2YXIgdW5pY29kZU1hcCA9IHt9O1xcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcXG4gICAgICAgICAgdmFyIGIwID0gYmluLnJlYWQoKTtcXG4gICAgICAgICAgaWYgKGIwID09IC0xKSBicmVhaztcXG4gICAgICAgICAgdmFyIGIxID0gcmVhZCgpO1xcbiAgICAgICAgICB2YXIgYjIgPSByZWFkKCk7XFxuICAgICAgICAgIHZhciBiMyA9IHJlYWQoKTtcXG4gICAgICAgICAgdmFyIGsgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGIwIDw8IDggfCBiMSk7XFxuICAgICAgICAgIHZhciB2ID0gYjIgPDwgOCB8IGIzO1xcbiAgICAgICAgICB1bmljb2RlTWFwW2tdID0gdjtcXG4gICAgICAgICAgY291bnQgKz0gMTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChjb3VudCAhPSBudW1DaGFycykge1xcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoY291bnQgKyAnICE9ICcgKyBudW1DaGFycyk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gdW5pY29kZU1hcDtcXG4gICAgICB9KCk7XFxuXFxuICAgICAgdmFyIHVua25vd25DaGFyID0gJz8nLmNoYXJDb2RlQXQoMCk7XFxuXFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzKSB7XFxuICAgICAgICB2YXIgYnl0ZXMgPSBuZXcgQXJyYXkoKTtcXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcy5sZW5ndGg7IGkgKz0gMSkge1xcbiAgICAgICAgICB2YXIgYyA9IHMuY2hhckNvZGVBdChpKTtcXG4gICAgICAgICAgaWYgKGMgPCAxMjgpIHtcXG4gICAgICAgICAgICBieXRlcy5wdXNoKGMpO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHZhciBiID0gdW5pY29kZU1hcFtzLmNoYXJBdChpKV07XFxuICAgICAgICAgICAgaWYgKHR5cGVvZiBiID09ICdudW1iZXInKSB7XFxuICAgICAgICAgICAgICBpZiAoKGIgJiAweGZmKSA9PSBiKSB7XFxuICAgICAgICAgICAgICAgIC8vIDFieXRlXFxuICAgICAgICAgICAgICAgIGJ5dGVzLnB1c2goYik7XFxuICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAvLyAyYnl0ZXNcXG4gICAgICAgICAgICAgICAgYnl0ZXMucHVzaChiID4+PiA4KTtcXG4gICAgICAgICAgICAgICAgYnl0ZXMucHVzaChiICYgMHhmZik7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgIGJ5dGVzLnB1c2godW5rbm93bkNoYXIpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIGJ5dGVzO1xcbiAgICAgIH07XFxuICAgIH07XFxuXFxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgIC8vIFFSTW9kZVxcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblxcbiAgICB2YXIgUVJNb2RlID0ge1xcbiAgICAgIE1PREVfTlVNQkVSOiAxIDw8IDAsXFxuICAgICAgTU9ERV9BTFBIQV9OVU06IDEgPDwgMSxcXG4gICAgICBNT0RFXzhCSVRfQllURTogMSA8PCAyLFxcbiAgICAgIE1PREVfS0FOSkk6IDEgPDwgM1xcbiAgICB9O1xcblxcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICAvLyBRUkVycm9yQ29ycmVjdExldmVsXFxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFxuICAgIHZhciBRUkVycm9yQ29ycmVjdExldmVsID0ge1xcbiAgICAgIEw6IDEsXFxuICAgICAgTTogMCxcXG4gICAgICBROiAzLFxcbiAgICAgIEg6IDJcXG4gICAgfTtcXG5cXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAgLy8gUVJNYXNrUGF0dGVyblxcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblxcbiAgICB2YXIgUVJNYXNrUGF0dGVybiA9IHtcXG4gICAgICBQQVRURVJOMDAwOiAwLFxcbiAgICAgIFBBVFRFUk4wMDE6IDEsXFxuICAgICAgUEFUVEVSTjAxMDogMixcXG4gICAgICBQQVRURVJOMDExOiAzLFxcbiAgICAgIFBBVFRFUk4xMDA6IDQsXFxuICAgICAgUEFUVEVSTjEwMTogNSxcXG4gICAgICBQQVRURVJOMTEwOiA2LFxcbiAgICAgIFBBVFRFUk4xMTE6IDdcXG4gICAgfTtcXG5cXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAgLy8gUVJVdGlsXFxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFxuICAgIHZhciBRUlV0aWwgPSBmdW5jdGlvbiAoKSB7XFxuXFxuICAgICAgdmFyIFBBVFRFUk5fUE9TSVRJT05fVEFCTEUgPSBbW10sIFs2LCAxOF0sIFs2LCAyMl0sIFs2LCAyNl0sIFs2LCAzMF0sIFs2LCAzNF0sIFs2LCAyMiwgMzhdLCBbNiwgMjQsIDQyXSwgWzYsIDI2LCA0Nl0sIFs2LCAyOCwgNTBdLCBbNiwgMzAsIDU0XSwgWzYsIDMyLCA1OF0sIFs2LCAzNCwgNjJdLCBbNiwgMjYsIDQ2LCA2Nl0sIFs2LCAyNiwgNDgsIDcwXSwgWzYsIDI2LCA1MCwgNzRdLCBbNiwgMzAsIDU0LCA3OF0sIFs2LCAzMCwgNTYsIDgyXSwgWzYsIDMwLCA1OCwgODZdLCBbNiwgMzQsIDYyLCA5MF0sIFs2LCAyOCwgNTAsIDcyLCA5NF0sIFs2LCAyNiwgNTAsIDc0LCA5OF0sIFs2LCAzMCwgNTQsIDc4LCAxMDJdLCBbNiwgMjgsIDU0LCA4MCwgMTA2XSwgWzYsIDMyLCA1OCwgODQsIDExMF0sIFs2LCAzMCwgNTgsIDg2LCAxMTRdLCBbNiwgMzQsIDYyLCA5MCwgMTE4XSwgWzYsIDI2LCA1MCwgNzQsIDk4LCAxMjJdLCBbNiwgMzAsIDU0LCA3OCwgMTAyLCAxMjZdLCBbNiwgMjYsIDUyLCA3OCwgMTA0LCAxMzBdLCBbNiwgMzAsIDU2LCA4MiwgMTA4LCAxMzRdLCBbNiwgMzQsIDYwLCA4NiwgMTEyLCAxMzhdLCBbNiwgMzAsIDU4LCA4NiwgMTE0LCAxNDJdLCBbNiwgMzQsIDYyLCA5MCwgMTE4LCAxNDZdLCBbNiwgMzAsIDU0LCA3OCwgMTAyLCAxMjYsIDE1MF0sIFs2LCAyNCwgNTAsIDc2LCAxMDIsIDEyOCwgMTU0XSwgWzYsIDI4LCA1NCwgODAsIDEwNiwgMTMyLCAxNThdLCBbNiwgMzIsIDU4LCA4NCwgMTEwLCAxMzYsIDE2Ml0sIFs2LCAyNiwgNTQsIDgyLCAxMTAsIDEzOCwgMTY2XSwgWzYsIDMwLCA1OCwgODYsIDExNCwgMTQyLCAxNzBdXTtcXG4gICAgICB2YXIgRzE1ID0gMSA8PCAxMCB8IDEgPDwgOCB8IDEgPDwgNSB8IDEgPDwgNCB8IDEgPDwgMiB8IDEgPDwgMSB8IDEgPDwgMDtcXG4gICAgICB2YXIgRzE4ID0gMSA8PCAxMiB8IDEgPDwgMTEgfCAxIDw8IDEwIHwgMSA8PCA5IHwgMSA8PCA4IHwgMSA8PCA1IHwgMSA8PCAyIHwgMSA8PCAwO1xcbiAgICAgIHZhciBHMTVfTUFTSyA9IDEgPDwgMTQgfCAxIDw8IDEyIHwgMSA8PCAxMCB8IDEgPDwgNCB8IDEgPDwgMTtcXG5cXG4gICAgICB2YXIgX3RoaXMgPSB7fTtcXG5cXG4gICAgICB2YXIgZ2V0QkNIRGlnaXQgPSBmdW5jdGlvbiBnZXRCQ0hEaWdpdChkYXRhKSB7XFxuICAgICAgICB2YXIgZGlnaXQgPSAwO1xcbiAgICAgICAgd2hpbGUgKGRhdGEgIT0gMCkge1xcbiAgICAgICAgICBkaWdpdCArPSAxO1xcbiAgICAgICAgICBkYXRhID4+Pj0gMTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBkaWdpdDtcXG4gICAgICB9O1xcblxcbiAgICAgIF90aGlzLmdldEJDSFR5cGVJbmZvID0gZnVuY3Rpb24gKGRhdGEpIHtcXG4gICAgICAgIHZhciBkID0gZGF0YSA8PCAxMDtcXG4gICAgICAgIHdoaWxlIChnZXRCQ0hEaWdpdChkKSAtIGdldEJDSERpZ2l0KEcxNSkgPj0gMCkge1xcbiAgICAgICAgICBkIF49IEcxNSA8PCBnZXRCQ0hEaWdpdChkKSAtIGdldEJDSERpZ2l0KEcxNSk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gKGRhdGEgPDwgMTAgfCBkKSBeIEcxNV9NQVNLO1xcbiAgICAgIH07XFxuXFxuICAgICAgX3RoaXMuZ2V0QkNIVHlwZU51bWJlciA9IGZ1bmN0aW9uIChkYXRhKSB7XFxuICAgICAgICB2YXIgZCA9IGRhdGEgPDwgMTI7XFxuICAgICAgICB3aGlsZSAoZ2V0QkNIRGlnaXQoZCkgLSBnZXRCQ0hEaWdpdChHMTgpID49IDApIHtcXG4gICAgICAgICAgZCBePSBHMTggPDwgZ2V0QkNIRGlnaXQoZCkgLSBnZXRCQ0hEaWdpdChHMTgpO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIGRhdGEgPDwgMTIgfCBkO1xcbiAgICAgIH07XFxuXFxuICAgICAgX3RoaXMuZ2V0UGF0dGVyblBvc2l0aW9uID0gZnVuY3Rpb24gKHR5cGVOdW1iZXIpIHtcXG4gICAgICAgIHJldHVybiBQQVRURVJOX1BPU0lUSU9OX1RBQkxFW3R5cGVOdW1iZXIgLSAxXTtcXG4gICAgICB9O1xcblxcbiAgICAgIF90aGlzLmdldE1hc2tGdW5jdGlvbiA9IGZ1bmN0aW9uIChtYXNrUGF0dGVybikge1xcblxcbiAgICAgICAgc3dpdGNoIChtYXNrUGF0dGVybikge1xcblxcbiAgICAgICAgICBjYXNlIFFSTWFza1BhdHRlcm4uUEFUVEVSTjAwMDpcXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGksIGopIHtcXG4gICAgICAgICAgICAgIHJldHVybiAoaSArIGopICUgMiA9PSAwO1xcbiAgICAgICAgICAgIH07XFxuICAgICAgICAgIGNhc2UgUVJNYXNrUGF0dGVybi5QQVRURVJOMDAxOlxcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoaSwgaikge1xcbiAgICAgICAgICAgICAgcmV0dXJuIGkgJSAyID09IDA7XFxuICAgICAgICAgICAgfTtcXG4gICAgICAgICAgY2FzZSBRUk1hc2tQYXR0ZXJuLlBBVFRFUk4wMTA6XFxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChpLCBqKSB7XFxuICAgICAgICAgICAgICByZXR1cm4gaiAlIDMgPT0gMDtcXG4gICAgICAgICAgICB9O1xcbiAgICAgICAgICBjYXNlIFFSTWFza1BhdHRlcm4uUEFUVEVSTjAxMTpcXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGksIGopIHtcXG4gICAgICAgICAgICAgIHJldHVybiAoaSArIGopICUgMyA9PSAwO1xcbiAgICAgICAgICAgIH07XFxuICAgICAgICAgIGNhc2UgUVJNYXNrUGF0dGVybi5QQVRURVJOMTAwOlxcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoaSwgaikge1xcbiAgICAgICAgICAgICAgcmV0dXJuIChNYXRoLmZsb29yKGkgLyAyKSArIE1hdGguZmxvb3IoaiAvIDMpKSAlIDIgPT0gMDtcXG4gICAgICAgICAgICB9O1xcbiAgICAgICAgICBjYXNlIFFSTWFza1BhdHRlcm4uUEFUVEVSTjEwMTpcXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGksIGopIHtcXG4gICAgICAgICAgICAgIHJldHVybiBpICogaiAlIDIgKyBpICogaiAlIDMgPT0gMDtcXG4gICAgICAgICAgICB9O1xcbiAgICAgICAgICBjYXNlIFFSTWFza1BhdHRlcm4uUEFUVEVSTjExMDpcXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGksIGopIHtcXG4gICAgICAgICAgICAgIHJldHVybiAoaSAqIGogJSAyICsgaSAqIGogJSAzKSAlIDIgPT0gMDtcXG4gICAgICAgICAgICB9O1xcbiAgICAgICAgICBjYXNlIFFSTWFza1BhdHRlcm4uUEFUVEVSTjExMTpcXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGksIGopIHtcXG4gICAgICAgICAgICAgIHJldHVybiAoaSAqIGogJSAzICsgKGkgKyBqKSAlIDIpICUgMiA9PSAwO1xcbiAgICAgICAgICAgIH07XFxuXFxuICAgICAgICAgIGRlZmF1bHQ6XFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgbWFza1BhdHRlcm46JyArIG1hc2tQYXR0ZXJuKTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcblxcbiAgICAgIF90aGlzLmdldEVycm9yQ29ycmVjdFBvbHlub21pYWwgPSBmdW5jdGlvbiAoZXJyb3JDb3JyZWN0TGVuZ3RoKSB7XFxuICAgICAgICB2YXIgYSA9IHFyUG9seW5vbWlhbChbMV0sIDApO1xcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlcnJvckNvcnJlY3RMZW5ndGg7IGkgKz0gMSkge1xcbiAgICAgICAgICBhID0gYS5tdWx0aXBseShxclBvbHlub21pYWwoWzEsIFFSTWF0aC5nZXhwKGkpXSwgMCkpO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIGE7XFxuICAgICAgfTtcXG5cXG4gICAgICBfdGhpcy5nZXRMZW5ndGhJbkJpdHMgPSBmdW5jdGlvbiAobW9kZSwgdHlwZSkge1xcblxcbiAgICAgICAgaWYgKDEgPD0gdHlwZSAmJiB0eXBlIDwgMTApIHtcXG5cXG4gICAgICAgICAgLy8gMSAtIDlcXG5cXG4gICAgICAgICAgc3dpdGNoIChtb2RlKSB7XFxuICAgICAgICAgICAgY2FzZSBRUk1vZGUuTU9ERV9OVU1CRVI6XFxuICAgICAgICAgICAgICByZXR1cm4gMTA7XFxuICAgICAgICAgICAgY2FzZSBRUk1vZGUuTU9ERV9BTFBIQV9OVU06XFxuICAgICAgICAgICAgICByZXR1cm4gOTtcXG4gICAgICAgICAgICBjYXNlIFFSTW9kZS5NT0RFXzhCSVRfQllURTpcXG4gICAgICAgICAgICAgIHJldHVybiA4O1xcbiAgICAgICAgICAgIGNhc2UgUVJNb2RlLk1PREVfS0FOSkk6XFxuICAgICAgICAgICAgICByZXR1cm4gODtcXG4gICAgICAgICAgICBkZWZhdWx0OlxcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtb2RlOicgKyBtb2RlKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlIDwgMjcpIHtcXG5cXG4gICAgICAgICAgLy8gMTAgLSAyNlxcblxcbiAgICAgICAgICBzd2l0Y2ggKG1vZGUpIHtcXG4gICAgICAgICAgICBjYXNlIFFSTW9kZS5NT0RFX05VTUJFUjpcXG4gICAgICAgICAgICAgIHJldHVybiAxMjtcXG4gICAgICAgICAgICBjYXNlIFFSTW9kZS5NT0RFX0FMUEhBX05VTTpcXG4gICAgICAgICAgICAgIHJldHVybiAxMTtcXG4gICAgICAgICAgICBjYXNlIFFSTW9kZS5NT0RFXzhCSVRfQllURTpcXG4gICAgICAgICAgICAgIHJldHVybiAxNjtcXG4gICAgICAgICAgICBjYXNlIFFSTW9kZS5NT0RFX0tBTkpJOlxcbiAgICAgICAgICAgICAgcmV0dXJuIDEwO1xcbiAgICAgICAgICAgIGRlZmF1bHQ6XFxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21vZGU6JyArIG1vZGUpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPCA0MSkge1xcblxcbiAgICAgICAgICAvLyAyNyAtIDQwXFxuXFxuICAgICAgICAgIHN3aXRjaCAobW9kZSkge1xcbiAgICAgICAgICAgIGNhc2UgUVJNb2RlLk1PREVfTlVNQkVSOlxcbiAgICAgICAgICAgICAgcmV0dXJuIDE0O1xcbiAgICAgICAgICAgIGNhc2UgUVJNb2RlLk1PREVfQUxQSEFfTlVNOlxcbiAgICAgICAgICAgICAgcmV0dXJuIDEzO1xcbiAgICAgICAgICAgIGNhc2UgUVJNb2RlLk1PREVfOEJJVF9CWVRFOlxcbiAgICAgICAgICAgICAgcmV0dXJuIDE2O1xcbiAgICAgICAgICAgIGNhc2UgUVJNb2RlLk1PREVfS0FOSkk6XFxuICAgICAgICAgICAgICByZXR1cm4gMTI7XFxuICAgICAgICAgICAgZGVmYXVsdDpcXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbW9kZTonICsgbW9kZSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndHlwZTonICsgdHlwZSk7XFxuICAgICAgICB9XFxuICAgICAgfTtcXG5cXG4gICAgICBfdGhpcy5nZXRMb3N0UG9pbnQgPSBmdW5jdGlvbiAocXJjb2RlKSB7XFxuXFxuICAgICAgICB2YXIgbW9kdWxlQ291bnQgPSBxcmNvZGUuZ2V0TW9kdWxlQ291bnQoKTtcXG5cXG4gICAgICAgIHZhciBsb3N0UG9pbnQgPSAwO1xcblxcbiAgICAgICAgLy8gTEVWRUwxXFxuXFxuICAgICAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCBtb2R1bGVDb3VudDsgcm93ICs9IDEpIHtcXG4gICAgICAgICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgbW9kdWxlQ291bnQ7IGNvbCArPSAxKSB7XFxuXFxuICAgICAgICAgICAgdmFyIHNhbWVDb3VudCA9IDA7XFxuICAgICAgICAgICAgdmFyIGRhcmsgPSBxcmNvZGUuaXNEYXJrKHJvdywgY29sKTtcXG5cXG4gICAgICAgICAgICBmb3IgKHZhciByID0gLTE7IHIgPD0gMTsgciArPSAxKSB7XFxuXFxuICAgICAgICAgICAgICBpZiAocm93ICsgciA8IDAgfHwgbW9kdWxlQ291bnQgPD0gcm93ICsgcikge1xcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgIGZvciAodmFyIGMgPSAtMTsgYyA8PSAxOyBjICs9IDEpIHtcXG5cXG4gICAgICAgICAgICAgICAgaWYgKGNvbCArIGMgPCAwIHx8IG1vZHVsZUNvdW50IDw9IGNvbCArIGMpIHtcXG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICBpZiAociA9PSAwICYmIGMgPT0gMCkge1xcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIGlmIChkYXJrID09IHFyY29kZS5pc0Rhcmsocm93ICsgciwgY29sICsgYykpIHtcXG4gICAgICAgICAgICAgICAgICBzYW1lQ291bnQgKz0gMTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpZiAoc2FtZUNvdW50ID4gNSkge1xcbiAgICAgICAgICAgICAgbG9zdFBvaW50ICs9IDMgKyBzYW1lQ291bnQgLSA1O1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfTtcXG5cXG4gICAgICAgIC8vIExFVkVMMlxcblxcbiAgICAgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgbW9kdWxlQ291bnQgLSAxOyByb3cgKz0gMSkge1xcbiAgICAgICAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBtb2R1bGVDb3VudCAtIDE7IGNvbCArPSAxKSB7XFxuICAgICAgICAgICAgdmFyIGNvdW50ID0gMDtcXG4gICAgICAgICAgICBpZiAocXJjb2RlLmlzRGFyayhyb3csIGNvbCkpIGNvdW50ICs9IDE7XFxuICAgICAgICAgICAgaWYgKHFyY29kZS5pc0Rhcmsocm93ICsgMSwgY29sKSkgY291bnQgKz0gMTtcXG4gICAgICAgICAgICBpZiAocXJjb2RlLmlzRGFyayhyb3csIGNvbCArIDEpKSBjb3VudCArPSAxO1xcbiAgICAgICAgICAgIGlmIChxcmNvZGUuaXNEYXJrKHJvdyArIDEsIGNvbCArIDEpKSBjb3VudCArPSAxO1xcbiAgICAgICAgICAgIGlmIChjb3VudCA9PSAwIHx8IGNvdW50ID09IDQpIHtcXG4gICAgICAgICAgICAgIGxvc3RQb2ludCArPSAzO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgLy8gTEVWRUwzXFxuXFxuICAgICAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCBtb2R1bGVDb3VudDsgcm93ICs9IDEpIHtcXG4gICAgICAgICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgbW9kdWxlQ291bnQgLSA2OyBjb2wgKz0gMSkge1xcbiAgICAgICAgICAgIGlmIChxcmNvZGUuaXNEYXJrKHJvdywgY29sKSAmJiAhcXJjb2RlLmlzRGFyayhyb3csIGNvbCArIDEpICYmIHFyY29kZS5pc0Rhcmsocm93LCBjb2wgKyAyKSAmJiBxcmNvZGUuaXNEYXJrKHJvdywgY29sICsgMykgJiYgcXJjb2RlLmlzRGFyayhyb3csIGNvbCArIDQpICYmICFxcmNvZGUuaXNEYXJrKHJvdywgY29sICsgNSkgJiYgcXJjb2RlLmlzRGFyayhyb3csIGNvbCArIDYpKSB7XFxuICAgICAgICAgICAgICBsb3N0UG9pbnQgKz0gNDA7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBtb2R1bGVDb3VudDsgY29sICs9IDEpIHtcXG4gICAgICAgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgbW9kdWxlQ291bnQgLSA2OyByb3cgKz0gMSkge1xcbiAgICAgICAgICAgIGlmIChxcmNvZGUuaXNEYXJrKHJvdywgY29sKSAmJiAhcXJjb2RlLmlzRGFyayhyb3cgKyAxLCBjb2wpICYmIHFyY29kZS5pc0Rhcmsocm93ICsgMiwgY29sKSAmJiBxcmNvZGUuaXNEYXJrKHJvdyArIDMsIGNvbCkgJiYgcXJjb2RlLmlzRGFyayhyb3cgKyA0LCBjb2wpICYmICFxcmNvZGUuaXNEYXJrKHJvdyArIDUsIGNvbCkgJiYgcXJjb2RlLmlzRGFyayhyb3cgKyA2LCBjb2wpKSB7XFxuICAgICAgICAgICAgICBsb3N0UG9pbnQgKz0gNDA7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICAvLyBMRVZFTDRcXG5cXG4gICAgICAgIHZhciBkYXJrQ291bnQgPSAwO1xcblxcbiAgICAgICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgbW9kdWxlQ291bnQ7IGNvbCArPSAxKSB7XFxuICAgICAgICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IG1vZHVsZUNvdW50OyByb3cgKz0gMSkge1xcbiAgICAgICAgICAgIGlmIChxcmNvZGUuaXNEYXJrKHJvdywgY29sKSkge1xcbiAgICAgICAgICAgICAgZGFya0NvdW50ICs9IDE7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICB2YXIgcmF0aW8gPSBNYXRoLmFicygxMDAgKiBkYXJrQ291bnQgLyBtb2R1bGVDb3VudCAvIG1vZHVsZUNvdW50IC0gNTApIC8gNTtcXG4gICAgICAgIGxvc3RQb2ludCArPSByYXRpbyAqIDEwO1xcblxcbiAgICAgICAgcmV0dXJuIGxvc3RQb2ludDtcXG4gICAgICB9O1xcblxcbiAgICAgIHJldHVybiBfdGhpcztcXG4gICAgfSgpO1xcblxcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICAvLyBRUk1hdGhcXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cXG4gICAgdmFyIFFSTWF0aCA9IGZ1bmN0aW9uICgpIHtcXG5cXG4gICAgICB2YXIgRVhQX1RBQkxFID0gbmV3IEFycmF5KDI1Nik7XFxuICAgICAgdmFyIExPR19UQUJMRSA9IG5ldyBBcnJheSgyNTYpO1xcblxcbiAgICAgIC8vIGluaXRpYWxpemUgdGFibGVzXFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpICs9IDEpIHtcXG4gICAgICAgIEVYUF9UQUJMRVtpXSA9IDEgPDwgaTtcXG4gICAgICB9XFxuICAgICAgZm9yICh2YXIgaSA9IDg7IGkgPCAyNTY7IGkgKz0gMSkge1xcbiAgICAgICAgRVhQX1RBQkxFW2ldID0gRVhQX1RBQkxFW2kgLSA0XSBeIEVYUF9UQUJMRVtpIC0gNV0gXiBFWFBfVEFCTEVbaSAtIDZdIF4gRVhQX1RBQkxFW2kgLSA4XTtcXG4gICAgICB9XFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTU7IGkgKz0gMSkge1xcbiAgICAgICAgTE9HX1RBQkxFW0VYUF9UQUJMRVtpXV0gPSBpO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgX3RoaXMgPSB7fTtcXG5cXG4gICAgICBfdGhpcy5nbG9nID0gZnVuY3Rpb24gKG4pIHtcXG5cXG4gICAgICAgIGlmIChuIDwgMSkge1xcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dsb2coJyArIG4gKyAnKScpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIExPR19UQUJMRVtuXTtcXG4gICAgICB9O1xcblxcbiAgICAgIF90aGlzLmdleHAgPSBmdW5jdGlvbiAobikge1xcblxcbiAgICAgICAgd2hpbGUgKG4gPCAwKSB7XFxuICAgICAgICAgIG4gKz0gMjU1O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgd2hpbGUgKG4gPj0gMjU2KSB7XFxuICAgICAgICAgIG4gLT0gMjU1O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIEVYUF9UQUJMRVtuXTtcXG4gICAgICB9O1xcblxcbiAgICAgIHJldHVybiBfdGhpcztcXG4gICAgfSgpO1xcblxcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICAvLyBxclBvbHlub21pYWxcXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cXG4gICAgZnVuY3Rpb24gcXJQb2x5bm9taWFsKG51bSwgc2hpZnQpIHtcXG5cXG4gICAgICBpZiAodHlwZW9mIG51bS5sZW5ndGggPT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihudW0ubGVuZ3RoICsgJy8nICsgc2hpZnQpO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgX251bSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciBvZmZzZXQgPSAwO1xcbiAgICAgICAgd2hpbGUgKG9mZnNldCA8IG51bS5sZW5ndGggJiYgbnVtW29mZnNldF0gPT0gMCkge1xcbiAgICAgICAgICBvZmZzZXQgKz0gMTtcXG4gICAgICAgIH1cXG4gICAgICAgIHZhciBfbnVtID0gbmV3IEFycmF5KG51bS5sZW5ndGggLSBvZmZzZXQgKyBzaGlmdCk7XFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bS5sZW5ndGggLSBvZmZzZXQ7IGkgKz0gMSkge1xcbiAgICAgICAgICBfbnVtW2ldID0gbnVtW2kgKyBvZmZzZXRdO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIF9udW07XFxuICAgICAgfSgpO1xcblxcbiAgICAgIHZhciBfdGhpcyA9IHt9O1xcblxcbiAgICAgIF90aGlzLmdldEF0ID0gZnVuY3Rpb24gKGluZGV4KSB7XFxuICAgICAgICByZXR1cm4gX251bVtpbmRleF07XFxuICAgICAgfTtcXG5cXG4gICAgICBfdGhpcy5nZXRMZW5ndGggPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICByZXR1cm4gX251bS5sZW5ndGg7XFxuICAgICAgfTtcXG5cXG4gICAgICBfdGhpcy5tdWx0aXBseSA9IGZ1bmN0aW9uIChlKSB7XFxuXFxuICAgICAgICB2YXIgbnVtID0gbmV3IEFycmF5KF90aGlzLmdldExlbmd0aCgpICsgZS5nZXRMZW5ndGgoKSAtIDEpO1xcblxcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfdGhpcy5nZXRMZW5ndGgoKTsgaSArPSAxKSB7XFxuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZS5nZXRMZW5ndGgoKTsgaiArPSAxKSB7XFxuICAgICAgICAgICAgbnVtW2kgKyBqXSBePSBRUk1hdGguZ2V4cChRUk1hdGguZ2xvZyhfdGhpcy5nZXRBdChpKSkgKyBRUk1hdGguZ2xvZyhlLmdldEF0KGopKSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiBxclBvbHlub21pYWwobnVtLCAwKTtcXG4gICAgICB9O1xcblxcbiAgICAgIF90aGlzLm1vZCA9IGZ1bmN0aW9uIChlKSB7XFxuXFxuICAgICAgICBpZiAoX3RoaXMuZ2V0TGVuZ3RoKCkgLSBlLmdldExlbmd0aCgpIDwgMCkge1xcbiAgICAgICAgICByZXR1cm4gX3RoaXM7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB2YXIgcmF0aW8gPSBRUk1hdGguZ2xvZyhfdGhpcy5nZXRBdCgwKSkgLSBRUk1hdGguZ2xvZyhlLmdldEF0KDApKTtcXG5cXG4gICAgICAgIHZhciBudW0gPSBuZXcgQXJyYXkoX3RoaXMuZ2V0TGVuZ3RoKCkpO1xcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfdGhpcy5nZXRMZW5ndGgoKTsgaSArPSAxKSB7XFxuICAgICAgICAgIG51bVtpXSA9IF90aGlzLmdldEF0KGkpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlLmdldExlbmd0aCgpOyBpICs9IDEpIHtcXG4gICAgICAgICAgbnVtW2ldIF49IFFSTWF0aC5nZXhwKFFSTWF0aC5nbG9nKGUuZ2V0QXQoaSkpICsgcmF0aW8pO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgLy8gcmVjdXJzaXZlIGNhbGxcXG4gICAgICAgIHJldHVybiBxclBvbHlub21pYWwobnVtLCAwKS5tb2QoZSk7XFxuICAgICAgfTtcXG5cXG4gICAgICByZXR1cm4gX3RoaXM7XFxuICAgIH07XFxuXFxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgIC8vIFFSUlNCbG9ja1xcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblxcbiAgICB2YXIgUVJSU0Jsb2NrID0gZnVuY3Rpb24gKCkge1xcblxcbiAgICAgIHZhciBSU19CTE9DS19UQUJMRSA9IFtcXG5cXG4gICAgICAvLyBMXFxuICAgICAgLy8gTVxcbiAgICAgIC8vIFFcXG4gICAgICAvLyBIXFxuXFxuICAgICAgLy8gMVxcbiAgICAgIFsxLCAyNiwgMTldLCBbMSwgMjYsIDE2XSwgWzEsIDI2LCAxM10sIFsxLCAyNiwgOV0sXFxuXFxuICAgICAgLy8gMlxcbiAgICAgIFsxLCA0NCwgMzRdLCBbMSwgNDQsIDI4XSwgWzEsIDQ0LCAyMl0sIFsxLCA0NCwgMTZdLFxcblxcbiAgICAgIC8vIDNcXG4gICAgICBbMSwgNzAsIDU1XSwgWzEsIDcwLCA0NF0sIFsyLCAzNSwgMTddLCBbMiwgMzUsIDEzXSxcXG5cXG4gICAgICAvLyA0XFxuICAgICAgWzEsIDEwMCwgODBdLCBbMiwgNTAsIDMyXSwgWzIsIDUwLCAyNF0sIFs0LCAyNSwgOV0sXFxuXFxuICAgICAgLy8gNVxcbiAgICAgIFsxLCAxMzQsIDEwOF0sIFsyLCA2NywgNDNdLCBbMiwgMzMsIDE1LCAyLCAzNCwgMTZdLCBbMiwgMzMsIDExLCAyLCAzNCwgMTJdLFxcblxcbiAgICAgIC8vIDZcXG4gICAgICBbMiwgODYsIDY4XSwgWzQsIDQzLCAyN10sIFs0LCA0MywgMTldLCBbNCwgNDMsIDE1XSxcXG5cXG4gICAgICAvLyA3XFxuICAgICAgWzIsIDk4LCA3OF0sIFs0LCA0OSwgMzFdLCBbMiwgMzIsIDE0LCA0LCAzMywgMTVdLCBbNCwgMzksIDEzLCAxLCA0MCwgMTRdLFxcblxcbiAgICAgIC8vIDhcXG4gICAgICBbMiwgMTIxLCA5N10sIFsyLCA2MCwgMzgsIDIsIDYxLCAzOV0sIFs0LCA0MCwgMTgsIDIsIDQxLCAxOV0sIFs0LCA0MCwgMTQsIDIsIDQxLCAxNV0sXFxuXFxuICAgICAgLy8gOVxcbiAgICAgIFsyLCAxNDYsIDExNl0sIFszLCA1OCwgMzYsIDIsIDU5LCAzN10sIFs0LCAzNiwgMTYsIDQsIDM3LCAxN10sIFs0LCAzNiwgMTIsIDQsIDM3LCAxM10sXFxuXFxuICAgICAgLy8gMTBcXG4gICAgICBbMiwgODYsIDY4LCAyLCA4NywgNjldLCBbNCwgNjksIDQzLCAxLCA3MCwgNDRdLCBbNiwgNDMsIDE5LCAyLCA0NCwgMjBdLCBbNiwgNDMsIDE1LCAyLCA0NCwgMTZdLFxcblxcbiAgICAgIC8vIDExXFxuICAgICAgWzQsIDEwMSwgODFdLCBbMSwgODAsIDUwLCA0LCA4MSwgNTFdLCBbNCwgNTAsIDIyLCA0LCA1MSwgMjNdLCBbMywgMzYsIDEyLCA4LCAzNywgMTNdLFxcblxcbiAgICAgIC8vIDEyXFxuICAgICAgWzIsIDExNiwgOTIsIDIsIDExNywgOTNdLCBbNiwgNTgsIDM2LCAyLCA1OSwgMzddLCBbNCwgNDYsIDIwLCA2LCA0NywgMjFdLCBbNywgNDIsIDE0LCA0LCA0MywgMTVdLFxcblxcbiAgICAgIC8vIDEzXFxuICAgICAgWzQsIDEzMywgMTA3XSwgWzgsIDU5LCAzNywgMSwgNjAsIDM4XSwgWzgsIDQ0LCAyMCwgNCwgNDUsIDIxXSwgWzEyLCAzMywgMTEsIDQsIDM0LCAxMl0sXFxuXFxuICAgICAgLy8gMTRcXG4gICAgICBbMywgMTQ1LCAxMTUsIDEsIDE0NiwgMTE2XSwgWzQsIDY0LCA0MCwgNSwgNjUsIDQxXSwgWzExLCAzNiwgMTYsIDUsIDM3LCAxN10sIFsxMSwgMzYsIDEyLCA1LCAzNywgMTNdLFxcblxcbiAgICAgIC8vIDE1XFxuICAgICAgWzUsIDEwOSwgODcsIDEsIDExMCwgODhdLCBbNSwgNjUsIDQxLCA1LCA2NiwgNDJdLCBbNSwgNTQsIDI0LCA3LCA1NSwgMjVdLCBbMTEsIDM2LCAxMiwgNywgMzcsIDEzXSxcXG5cXG4gICAgICAvLyAxNlxcbiAgICAgIFs1LCAxMjIsIDk4LCAxLCAxMjMsIDk5XSwgWzcsIDczLCA0NSwgMywgNzQsIDQ2XSwgWzE1LCA0MywgMTksIDIsIDQ0LCAyMF0sIFszLCA0NSwgMTUsIDEzLCA0NiwgMTZdLFxcblxcbiAgICAgIC8vIDE3XFxuICAgICAgWzEsIDEzNSwgMTA3LCA1LCAxMzYsIDEwOF0sIFsxMCwgNzQsIDQ2LCAxLCA3NSwgNDddLCBbMSwgNTAsIDIyLCAxNSwgNTEsIDIzXSwgWzIsIDQyLCAxNCwgMTcsIDQzLCAxNV0sXFxuXFxuICAgICAgLy8gMThcXG4gICAgICBbNSwgMTUwLCAxMjAsIDEsIDE1MSwgMTIxXSwgWzksIDY5LCA0MywgNCwgNzAsIDQ0XSwgWzE3LCA1MCwgMjIsIDEsIDUxLCAyM10sIFsyLCA0MiwgMTQsIDE5LCA0MywgMTVdLFxcblxcbiAgICAgIC8vIDE5XFxuICAgICAgWzMsIDE0MSwgMTEzLCA0LCAxNDIsIDExNF0sIFszLCA3MCwgNDQsIDExLCA3MSwgNDVdLCBbMTcsIDQ3LCAyMSwgNCwgNDgsIDIyXSwgWzksIDM5LCAxMywgMTYsIDQwLCAxNF0sXFxuXFxuICAgICAgLy8gMjBcXG4gICAgICBbMywgMTM1LCAxMDcsIDUsIDEzNiwgMTA4XSwgWzMsIDY3LCA0MSwgMTMsIDY4LCA0Ml0sIFsxNSwgNTQsIDI0LCA1LCA1NSwgMjVdLCBbMTUsIDQzLCAxNSwgMTAsIDQ0LCAxNl0sXFxuXFxuICAgICAgLy8gMjFcXG4gICAgICBbNCwgMTQ0LCAxMTYsIDQsIDE0NSwgMTE3XSwgWzE3LCA2OCwgNDJdLCBbMTcsIDUwLCAyMiwgNiwgNTEsIDIzXSwgWzE5LCA0NiwgMTYsIDYsIDQ3LCAxN10sXFxuXFxuICAgICAgLy8gMjJcXG4gICAgICBbMiwgMTM5LCAxMTEsIDcsIDE0MCwgMTEyXSwgWzE3LCA3NCwgNDZdLCBbNywgNTQsIDI0LCAxNiwgNTUsIDI1XSwgWzM0LCAzNywgMTNdLFxcblxcbiAgICAgIC8vIDIzXFxuICAgICAgWzQsIDE1MSwgMTIxLCA1LCAxNTIsIDEyMl0sIFs0LCA3NSwgNDcsIDE0LCA3NiwgNDhdLCBbMTEsIDU0LCAyNCwgMTQsIDU1LCAyNV0sIFsxNiwgNDUsIDE1LCAxNCwgNDYsIDE2XSxcXG5cXG4gICAgICAvLyAyNFxcbiAgICAgIFs2LCAxNDcsIDExNywgNCwgMTQ4LCAxMThdLCBbNiwgNzMsIDQ1LCAxNCwgNzQsIDQ2XSwgWzExLCA1NCwgMjQsIDE2LCA1NSwgMjVdLCBbMzAsIDQ2LCAxNiwgMiwgNDcsIDE3XSxcXG5cXG4gICAgICAvLyAyNVxcbiAgICAgIFs4LCAxMzIsIDEwNiwgNCwgMTMzLCAxMDddLCBbOCwgNzUsIDQ3LCAxMywgNzYsIDQ4XSwgWzcsIDU0LCAyNCwgMjIsIDU1LCAyNV0sIFsyMiwgNDUsIDE1LCAxMywgNDYsIDE2XSxcXG5cXG4gICAgICAvLyAyNlxcbiAgICAgIFsxMCwgMTQyLCAxMTQsIDIsIDE0MywgMTE1XSwgWzE5LCA3NCwgNDYsIDQsIDc1LCA0N10sIFsyOCwgNTAsIDIyLCA2LCA1MSwgMjNdLCBbMzMsIDQ2LCAxNiwgNCwgNDcsIDE3XSxcXG5cXG4gICAgICAvLyAyN1xcbiAgICAgIFs4LCAxNTIsIDEyMiwgNCwgMTUzLCAxMjNdLCBbMjIsIDczLCA0NSwgMywgNzQsIDQ2XSwgWzgsIDUzLCAyMywgMjYsIDU0LCAyNF0sIFsxMiwgNDUsIDE1LCAyOCwgNDYsIDE2XSxcXG5cXG4gICAgICAvLyAyOFxcbiAgICAgIFszLCAxNDcsIDExNywgMTAsIDE0OCwgMTE4XSwgWzMsIDczLCA0NSwgMjMsIDc0LCA0Nl0sIFs0LCA1NCwgMjQsIDMxLCA1NSwgMjVdLCBbMTEsIDQ1LCAxNSwgMzEsIDQ2LCAxNl0sXFxuXFxuICAgICAgLy8gMjlcXG4gICAgICBbNywgMTQ2LCAxMTYsIDcsIDE0NywgMTE3XSwgWzIxLCA3MywgNDUsIDcsIDc0LCA0Nl0sIFsxLCA1MywgMjMsIDM3LCA1NCwgMjRdLCBbMTksIDQ1LCAxNSwgMjYsIDQ2LCAxNl0sXFxuXFxuICAgICAgLy8gMzBcXG4gICAgICBbNSwgMTQ1LCAxMTUsIDEwLCAxNDYsIDExNl0sIFsxOSwgNzUsIDQ3LCAxMCwgNzYsIDQ4XSwgWzE1LCA1NCwgMjQsIDI1LCA1NSwgMjVdLCBbMjMsIDQ1LCAxNSwgMjUsIDQ2LCAxNl0sXFxuXFxuICAgICAgLy8gMzFcXG4gICAgICBbMTMsIDE0NSwgMTE1LCAzLCAxNDYsIDExNl0sIFsyLCA3NCwgNDYsIDI5LCA3NSwgNDddLCBbNDIsIDU0LCAyNCwgMSwgNTUsIDI1XSwgWzIzLCA0NSwgMTUsIDI4LCA0NiwgMTZdLFxcblxcbiAgICAgIC8vIDMyXFxuICAgICAgWzE3LCAxNDUsIDExNV0sIFsxMCwgNzQsIDQ2LCAyMywgNzUsIDQ3XSwgWzEwLCA1NCwgMjQsIDM1LCA1NSwgMjVdLCBbMTksIDQ1LCAxNSwgMzUsIDQ2LCAxNl0sXFxuXFxuICAgICAgLy8gMzNcXG4gICAgICBbMTcsIDE0NSwgMTE1LCAxLCAxNDYsIDExNl0sIFsxNCwgNzQsIDQ2LCAyMSwgNzUsIDQ3XSwgWzI5LCA1NCwgMjQsIDE5LCA1NSwgMjVdLCBbMTEsIDQ1LCAxNSwgNDYsIDQ2LCAxNl0sXFxuXFxuICAgICAgLy8gMzRcXG4gICAgICBbMTMsIDE0NSwgMTE1LCA2LCAxNDYsIDExNl0sIFsxNCwgNzQsIDQ2LCAyMywgNzUsIDQ3XSwgWzQ0LCA1NCwgMjQsIDcsIDU1LCAyNV0sIFs1OSwgNDYsIDE2LCAxLCA0NywgMTddLFxcblxcbiAgICAgIC8vIDM1XFxuICAgICAgWzEyLCAxNTEsIDEyMSwgNywgMTUyLCAxMjJdLCBbMTIsIDc1LCA0NywgMjYsIDc2LCA0OF0sIFszOSwgNTQsIDI0LCAxNCwgNTUsIDI1XSwgWzIyLCA0NSwgMTUsIDQxLCA0NiwgMTZdLFxcblxcbiAgICAgIC8vIDM2XFxuICAgICAgWzYsIDE1MSwgMTIxLCAxNCwgMTUyLCAxMjJdLCBbNiwgNzUsIDQ3LCAzNCwgNzYsIDQ4XSwgWzQ2LCA1NCwgMjQsIDEwLCA1NSwgMjVdLCBbMiwgNDUsIDE1LCA2NCwgNDYsIDE2XSxcXG5cXG4gICAgICAvLyAzN1xcbiAgICAgIFsxNywgMTUyLCAxMjIsIDQsIDE1MywgMTIzXSwgWzI5LCA3NCwgNDYsIDE0LCA3NSwgNDddLCBbNDksIDU0LCAyNCwgMTAsIDU1LCAyNV0sIFsyNCwgNDUsIDE1LCA0NiwgNDYsIDE2XSxcXG5cXG4gICAgICAvLyAzOFxcbiAgICAgIFs0LCAxNTIsIDEyMiwgMTgsIDE1MywgMTIzXSwgWzEzLCA3NCwgNDYsIDMyLCA3NSwgNDddLCBbNDgsIDU0LCAyNCwgMTQsIDU1LCAyNV0sIFs0MiwgNDUsIDE1LCAzMiwgNDYsIDE2XSxcXG5cXG4gICAgICAvLyAzOVxcbiAgICAgIFsyMCwgMTQ3LCAxMTcsIDQsIDE0OCwgMTE4XSwgWzQwLCA3NSwgNDcsIDcsIDc2LCA0OF0sIFs0MywgNTQsIDI0LCAyMiwgNTUsIDI1XSwgWzEwLCA0NSwgMTUsIDY3LCA0NiwgMTZdLFxcblxcbiAgICAgIC8vIDQwXFxuICAgICAgWzE5LCAxNDgsIDExOCwgNiwgMTQ5LCAxMTldLCBbMTgsIDc1LCA0NywgMzEsIDc2LCA0OF0sIFszNCwgNTQsIDI0LCAzNCwgNTUsIDI1XSwgWzIwLCA0NSwgMTUsIDYxLCA0NiwgMTZdXTtcXG5cXG4gICAgICB2YXIgcXJSU0Jsb2NrID0gZnVuY3Rpb24gcXJSU0Jsb2NrKHRvdGFsQ291bnQsIGRhdGFDb3VudCkge1xcbiAgICAgICAgdmFyIF90aGlzID0ge307XFxuICAgICAgICBfdGhpcy50b3RhbENvdW50ID0gdG90YWxDb3VudDtcXG4gICAgICAgIF90aGlzLmRhdGFDb3VudCA9IGRhdGFDb3VudDtcXG4gICAgICAgIHJldHVybiBfdGhpcztcXG4gICAgICB9O1xcblxcbiAgICAgIHZhciBfdGhpcyA9IHt9O1xcblxcbiAgICAgIHZhciBnZXRSc0Jsb2NrVGFibGUgPSBmdW5jdGlvbiBnZXRSc0Jsb2NrVGFibGUodHlwZU51bWJlciwgZXJyb3JDb3JyZWN0TGV2ZWwpIHtcXG5cXG4gICAgICAgIHN3aXRjaCAoZXJyb3JDb3JyZWN0TGV2ZWwpIHtcXG4gICAgICAgICAgY2FzZSBRUkVycm9yQ29ycmVjdExldmVsLkw6XFxuICAgICAgICAgICAgcmV0dXJuIFJTX0JMT0NLX1RBQkxFWyh0eXBlTnVtYmVyIC0gMSkgKiA0ICsgMF07XFxuICAgICAgICAgIGNhc2UgUVJFcnJvckNvcnJlY3RMZXZlbC5NOlxcbiAgICAgICAgICAgIHJldHVybiBSU19CTE9DS19UQUJMRVsodHlwZU51bWJlciAtIDEpICogNCArIDFdO1xcbiAgICAgICAgICBjYXNlIFFSRXJyb3JDb3JyZWN0TGV2ZWwuUTpcXG4gICAgICAgICAgICByZXR1cm4gUlNfQkxPQ0tfVEFCTEVbKHR5cGVOdW1iZXIgLSAxKSAqIDQgKyAyXTtcXG4gICAgICAgICAgY2FzZSBRUkVycm9yQ29ycmVjdExldmVsLkg6XFxuICAgICAgICAgICAgcmV0dXJuIFJTX0JMT0NLX1RBQkxFWyh0eXBlTnVtYmVyIC0gMSkgKiA0ICsgM107XFxuICAgICAgICAgIGRlZmF1bHQ6XFxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcblxcbiAgICAgIF90aGlzLmdldFJTQmxvY2tzID0gZnVuY3Rpb24gKHR5cGVOdW1iZXIsIGVycm9yQ29ycmVjdExldmVsKSB7XFxuXFxuICAgICAgICB2YXIgcnNCbG9jayA9IGdldFJzQmxvY2tUYWJsZSh0eXBlTnVtYmVyLCBlcnJvckNvcnJlY3RMZXZlbCk7XFxuXFxuICAgICAgICBpZiAodHlwZW9mIHJzQmxvY2sgPT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcnMgYmxvY2sgQCB0eXBlTnVtYmVyOicgKyB0eXBlTnVtYmVyICsgJy9lcnJvckNvcnJlY3RMZXZlbDonICsgZXJyb3JDb3JyZWN0TGV2ZWwpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdmFyIGxlbmd0aCA9IHJzQmxvY2subGVuZ3RoIC8gMztcXG5cXG4gICAgICAgIHZhciBsaXN0ID0gbmV3IEFycmF5KCk7XFxuXFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XFxuXFxuICAgICAgICAgIHZhciBjb3VudCA9IHJzQmxvY2tbaSAqIDMgKyAwXTtcXG4gICAgICAgICAgdmFyIHRvdGFsQ291bnQgPSByc0Jsb2NrW2kgKiAzICsgMV07XFxuICAgICAgICAgIHZhciBkYXRhQ291bnQgPSByc0Jsb2NrW2kgKiAzICsgMl07XFxuXFxuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY291bnQ7IGogKz0gMSkge1xcbiAgICAgICAgICAgIGxpc3QucHVzaChxclJTQmxvY2sodG90YWxDb3VudCwgZGF0YUNvdW50KSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiBsaXN0O1xcbiAgICAgIH07XFxuXFxuICAgICAgcmV0dXJuIF90aGlzO1xcbiAgICB9KCk7XFxuXFxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgIC8vIHFyQml0QnVmZmVyXFxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFxuICAgIHZhciBxckJpdEJ1ZmZlciA9IGZ1bmN0aW9uIHFyQml0QnVmZmVyKCkge1xcblxcbiAgICAgIHZhciBfYnVmZmVyID0gbmV3IEFycmF5KCk7XFxuICAgICAgdmFyIF9sZW5ndGggPSAwO1xcblxcbiAgICAgIHZhciBfdGhpcyA9IHt9O1xcblxcbiAgICAgIF90aGlzLmdldEJ1ZmZlciA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHJldHVybiBfYnVmZmVyO1xcbiAgICAgIH07XFxuXFxuICAgICAgX3RoaXMuZ2V0QXQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcXG4gICAgICAgIHZhciBidWZJbmRleCA9IE1hdGguZmxvb3IoaW5kZXggLyA4KTtcXG4gICAgICAgIHJldHVybiAoX2J1ZmZlcltidWZJbmRleF0gPj4+IDcgLSBpbmRleCAlIDggJiAxKSA9PSAxO1xcbiAgICAgIH07XFxuXFxuICAgICAgX3RoaXMucHV0ID0gZnVuY3Rpb24gKG51bSwgbGVuZ3RoKSB7XFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XFxuICAgICAgICAgIF90aGlzLnB1dEJpdCgobnVtID4+PiBsZW5ndGggLSBpIC0gMSAmIDEpID09IDEpO1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuXFxuICAgICAgX3RoaXMuZ2V0TGVuZ3RoSW5CaXRzID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgcmV0dXJuIF9sZW5ndGg7XFxuICAgICAgfTtcXG5cXG4gICAgICBfdGhpcy5wdXRCaXQgPSBmdW5jdGlvbiAoYml0KSB7XFxuXFxuICAgICAgICB2YXIgYnVmSW5kZXggPSBNYXRoLmZsb29yKF9sZW5ndGggLyA4KTtcXG4gICAgICAgIGlmIChfYnVmZmVyLmxlbmd0aCA8PSBidWZJbmRleCkge1xcbiAgICAgICAgICBfYnVmZmVyLnB1c2goMCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoYml0KSB7XFxuICAgICAgICAgIF9idWZmZXJbYnVmSW5kZXhdIHw9IDB4ODAgPj4+IF9sZW5ndGggJSA4O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgX2xlbmd0aCArPSAxO1xcbiAgICAgIH07XFxuXFxuICAgICAgcmV0dXJuIF90aGlzO1xcbiAgICB9O1xcblxcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICAvLyBxcjhCaXRCeXRlXFxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFxuICAgIHZhciBxcjhCaXRCeXRlID0gZnVuY3Rpb24gcXI4Qml0Qnl0ZShkYXRhKSB7XFxuXFxuICAgICAgdmFyIF9tb2RlID0gUVJNb2RlLk1PREVfOEJJVF9CWVRFO1xcbiAgICAgIHZhciBfZGF0YSA9IGRhdGE7XFxuICAgICAgdmFyIF9ieXRlcyA9IHFyY29kZS5zdHJpbmdUb0J5dGVzKGRhdGEpO1xcblxcbiAgICAgIHZhciBfdGhpcyA9IHt9O1xcblxcbiAgICAgIF90aGlzLmdldE1vZGUgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICByZXR1cm4gX21vZGU7XFxuICAgICAgfTtcXG5cXG4gICAgICBfdGhpcy5nZXRMZW5ndGggPSBmdW5jdGlvbiAoYnVmZmVyKSB7XFxuICAgICAgICByZXR1cm4gX2J5dGVzLmxlbmd0aDtcXG4gICAgICB9O1xcblxcbiAgICAgIF90aGlzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfYnl0ZXMubGVuZ3RoOyBpICs9IDEpIHtcXG4gICAgICAgICAgYnVmZmVyLnB1dChfYnl0ZXNbaV0sIDgpO1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuXFxuICAgICAgcmV0dXJuIF90aGlzO1xcbiAgICB9O1xcblxcbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbiAgICAvLyBHSUYgU3VwcG9ydCBldGMuXFxuICAgIC8vXFxuXFxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgIC8vIGJ5dGVBcnJheU91dHB1dFN0cmVhbVxcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblxcbiAgICB2YXIgYnl0ZUFycmF5T3V0cHV0U3RyZWFtID0gZnVuY3Rpb24gYnl0ZUFycmF5T3V0cHV0U3RyZWFtKCkge1xcblxcbiAgICAgIHZhciBfYnl0ZXMgPSBuZXcgQXJyYXkoKTtcXG5cXG4gICAgICB2YXIgX3RoaXMgPSB7fTtcXG5cXG4gICAgICBfdGhpcy53cml0ZUJ5dGUgPSBmdW5jdGlvbiAoYikge1xcbiAgICAgICAgX2J5dGVzLnB1c2goYiAmIDB4ZmYpO1xcbiAgICAgIH07XFxuXFxuICAgICAgX3RoaXMud3JpdGVTaG9ydCA9IGZ1bmN0aW9uIChpKSB7XFxuICAgICAgICBfdGhpcy53cml0ZUJ5dGUoaSk7XFxuICAgICAgICBfdGhpcy53cml0ZUJ5dGUoaSA+Pj4gOCk7XFxuICAgICAgfTtcXG5cXG4gICAgICBfdGhpcy53cml0ZUJ5dGVzID0gZnVuY3Rpb24gKGIsIG9mZiwgbGVuKSB7XFxuICAgICAgICBvZmYgPSBvZmYgfHwgMDtcXG4gICAgICAgIGxlbiA9IGxlbiB8fCBiLmxlbmd0aDtcXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcXG4gICAgICAgICAgX3RoaXMud3JpdGVCeXRlKGJbaSArIG9mZl0pO1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuXFxuICAgICAgX3RoaXMud3JpdGVTdHJpbmcgPSBmdW5jdGlvbiAocykge1xcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzLmxlbmd0aDsgaSArPSAxKSB7XFxuICAgICAgICAgIF90aGlzLndyaXRlQnl0ZShzLmNoYXJDb2RlQXQoaSkpO1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuXFxuICAgICAgX3RoaXMudG9CeXRlQXJyYXkgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICByZXR1cm4gX2J5dGVzO1xcbiAgICAgIH07XFxuXFxuICAgICAgX3RoaXMudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgcyA9ICcnO1xcbiAgICAgICAgcyArPSAnWyc7XFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9ieXRlcy5sZW5ndGg7IGkgKz0gMSkge1xcbiAgICAgICAgICBpZiAoaSA+IDApIHtcXG4gICAgICAgICAgICBzICs9ICcsJztcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBzICs9IF9ieXRlc1tpXTtcXG4gICAgICAgIH1cXG4gICAgICAgIHMgKz0gJ10nO1xcbiAgICAgICAgcmV0dXJuIHM7XFxuICAgICAgfTtcXG5cXG4gICAgICByZXR1cm4gX3RoaXM7XFxuICAgIH07XFxuXFxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgIC8vIGJhc2U2NEVuY29kZU91dHB1dFN0cmVhbVxcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblxcbiAgICB2YXIgYmFzZTY0RW5jb2RlT3V0cHV0U3RyZWFtID0gZnVuY3Rpb24gYmFzZTY0RW5jb2RlT3V0cHV0U3RyZWFtKCkge1xcblxcbiAgICAgIHZhciBfYnVmZmVyID0gMDtcXG4gICAgICB2YXIgX2J1ZmxlbiA9IDA7XFxuICAgICAgdmFyIF9sZW5ndGggPSAwO1xcbiAgICAgIHZhciBfYmFzZTY0ID0gJyc7XFxuXFxuICAgICAgdmFyIF90aGlzID0ge307XFxuXFxuICAgICAgdmFyIHdyaXRlRW5jb2RlZCA9IGZ1bmN0aW9uIHdyaXRlRW5jb2RlZChiKSB7XFxuICAgICAgICBfYmFzZTY0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoZW5jb2RlKGIgJiAweDNmKSk7XFxuICAgICAgfTtcXG5cXG4gICAgICB2YXIgZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG4pIHtcXG4gICAgICAgIGlmIChuIDwgMCkge1xcbiAgICAgICAgICAvLyBlcnJvci5cXG4gICAgICAgIH0gZWxzZSBpZiAobiA8IDI2KSB7XFxuICAgICAgICAgIHJldHVybiAweDQxICsgbjtcXG4gICAgICAgIH0gZWxzZSBpZiAobiA8IDUyKSB7XFxuICAgICAgICAgIHJldHVybiAweDYxICsgKG4gLSAyNik7XFxuICAgICAgICB9IGVsc2UgaWYgKG4gPCA2Mikge1xcbiAgICAgICAgICByZXR1cm4gMHgzMCArIChuIC0gNTIpO1xcbiAgICAgICAgfSBlbHNlIGlmIChuID09IDYyKSB7XFxuICAgICAgICAgIHJldHVybiAweDJiO1xcbiAgICAgICAgfSBlbHNlIGlmIChuID09IDYzKSB7XFxuICAgICAgICAgIHJldHVybiAweDJmO1xcbiAgICAgICAgfVxcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCduOicgKyBuKTtcXG4gICAgICB9O1xcblxcbiAgICAgIF90aGlzLndyaXRlQnl0ZSA9IGZ1bmN0aW9uIChuKSB7XFxuXFxuICAgICAgICBfYnVmZmVyID0gX2J1ZmZlciA8PCA4IHwgbiAmIDB4ZmY7XFxuICAgICAgICBfYnVmbGVuICs9IDg7XFxuICAgICAgICBfbGVuZ3RoICs9IDE7XFxuXFxuICAgICAgICB3aGlsZSAoX2J1ZmxlbiA+PSA2KSB7XFxuICAgICAgICAgIHdyaXRlRW5jb2RlZChfYnVmZmVyID4+PiBfYnVmbGVuIC0gNik7XFxuICAgICAgICAgIF9idWZsZW4gLT0gNjtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcblxcbiAgICAgIF90aGlzLmZsdXNoID0gZnVuY3Rpb24gKCkge1xcblxcbiAgICAgICAgaWYgKF9idWZsZW4gPiAwKSB7XFxuICAgICAgICAgIHdyaXRlRW5jb2RlZChfYnVmZmVyIDw8IDYgLSBfYnVmbGVuKTtcXG4gICAgICAgICAgX2J1ZmZlciA9IDA7XFxuICAgICAgICAgIF9idWZsZW4gPSAwO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKF9sZW5ndGggJSAzICE9IDApIHtcXG4gICAgICAgICAgLy8gcGFkZGluZ1xcbiAgICAgICAgICB2YXIgcGFkbGVuID0gMyAtIF9sZW5ndGggJSAzO1xcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhZGxlbjsgaSArPSAxKSB7XFxuICAgICAgICAgICAgX2Jhc2U2NCArPSAnPSc7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9O1xcblxcbiAgICAgIF90aGlzLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgcmV0dXJuIF9iYXNlNjQ7XFxuICAgICAgfTtcXG5cXG4gICAgICByZXR1cm4gX3RoaXM7XFxuICAgIH07XFxuXFxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgIC8vIGJhc2U2NERlY29kZUlucHV0U3RyZWFtXFxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFxuICAgIHZhciBiYXNlNjREZWNvZGVJbnB1dFN0cmVhbSA9IGZ1bmN0aW9uIGJhc2U2NERlY29kZUlucHV0U3RyZWFtKHN0cikge1xcblxcbiAgICAgIHZhciBfc3RyID0gc3RyO1xcbiAgICAgIHZhciBfcG9zID0gMDtcXG4gICAgICB2YXIgX2J1ZmZlciA9IDA7XFxuICAgICAgdmFyIF9idWZsZW4gPSAwO1xcblxcbiAgICAgIHZhciBfdGhpcyA9IHt9O1xcblxcbiAgICAgIF90aGlzLnJlYWQgPSBmdW5jdGlvbiAoKSB7XFxuXFxuICAgICAgICB3aGlsZSAoX2J1ZmxlbiA8IDgpIHtcXG5cXG4gICAgICAgICAgaWYgKF9wb3MgPj0gX3N0ci5sZW5ndGgpIHtcXG4gICAgICAgICAgICBpZiAoX2J1ZmxlbiA9PSAwKSB7XFxuICAgICAgICAgICAgICByZXR1cm4gLTE7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5leHBlY3RlZCBlbmQgb2YgZmlsZS4vJyArIF9idWZsZW4pO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHZhciBjID0gX3N0ci5jaGFyQXQoX3Bvcyk7XFxuICAgICAgICAgIF9wb3MgKz0gMTtcXG5cXG4gICAgICAgICAgaWYgKGMgPT0gJz0nKSB7XFxuICAgICAgICAgICAgX2J1ZmxlbiA9IDA7XFxuICAgICAgICAgICAgcmV0dXJuIC0xO1xcbiAgICAgICAgICB9IGVsc2UgaWYgKGMubWF0Y2goL15cXFxccyQvKSkge1xcbiAgICAgICAgICAgIC8vIGlnbm9yZSBpZiB3aGl0ZXNwYWNlLlxcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIF9idWZmZXIgPSBfYnVmZmVyIDw8IDYgfCBkZWNvZGUoYy5jaGFyQ29kZUF0KDApKTtcXG4gICAgICAgICAgX2J1ZmxlbiArPSA2O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdmFyIG4gPSBfYnVmZmVyID4+PiBfYnVmbGVuIC0gOCAmIDB4ZmY7XFxuICAgICAgICBfYnVmbGVuIC09IDg7XFxuICAgICAgICByZXR1cm4gbjtcXG4gICAgICB9O1xcblxcbiAgICAgIHZhciBkZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUoYykge1xcbiAgICAgICAgaWYgKDB4NDEgPD0gYyAmJiBjIDw9IDB4NWEpIHtcXG4gICAgICAgICAgcmV0dXJuIGMgLSAweDQxO1xcbiAgICAgICAgfSBlbHNlIGlmICgweDYxIDw9IGMgJiYgYyA8PSAweDdhKSB7XFxuICAgICAgICAgIHJldHVybiBjIC0gMHg2MSArIDI2O1xcbiAgICAgICAgfSBlbHNlIGlmICgweDMwIDw9IGMgJiYgYyA8PSAweDM5KSB7XFxuICAgICAgICAgIHJldHVybiBjIC0gMHgzMCArIDUyO1xcbiAgICAgICAgfSBlbHNlIGlmIChjID09IDB4MmIpIHtcXG4gICAgICAgICAgcmV0dXJuIDYyO1xcbiAgICAgICAgfSBlbHNlIGlmIChjID09IDB4MmYpIHtcXG4gICAgICAgICAgcmV0dXJuIDYzO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjOicgKyBjKTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcblxcbiAgICAgIHJldHVybiBfdGhpcztcXG4gICAgfTtcXG5cXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAgLy8gZ2lmSW1hZ2UgKEIvVylcXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cXG4gICAgdmFyIGdpZkltYWdlID0gZnVuY3Rpb24gZ2lmSW1hZ2Uod2lkdGgsIGhlaWdodCkge1xcblxcbiAgICAgIHZhciBfd2lkdGggPSB3aWR0aDtcXG4gICAgICB2YXIgX2hlaWdodCA9IGhlaWdodDtcXG4gICAgICB2YXIgX2RhdGEgPSBuZXcgQXJyYXkod2lkdGggKiBoZWlnaHQpO1xcblxcbiAgICAgIHZhciBfdGhpcyA9IHt9O1xcblxcbiAgICAgIF90aGlzLnNldFBpeGVsID0gZnVuY3Rpb24gKHgsIHksIHBpeGVsKSB7XFxuICAgICAgICBfZGF0YVt5ICogX3dpZHRoICsgeF0gPSBwaXhlbDtcXG4gICAgICB9O1xcblxcbiAgICAgIF90aGlzLndyaXRlID0gZnVuY3Rpb24gKG91dCkge1xcblxcbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAgICAgIC8vIEdJRiBTaWduYXR1cmVcXG5cXG4gICAgICAgIG91dC53cml0ZVN0cmluZygnR0lGODdhJyk7XFxuXFxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICAgICAgLy8gU2NyZWVuIERlc2NyaXB0b3JcXG5cXG4gICAgICAgIG91dC53cml0ZVNob3J0KF93aWR0aCk7XFxuICAgICAgICBvdXQud3JpdGVTaG9ydChfaGVpZ2h0KTtcXG5cXG4gICAgICAgIG91dC53cml0ZUJ5dGUoMHg4MCk7IC8vIDJiaXRcXG4gICAgICAgIG91dC53cml0ZUJ5dGUoMCk7XFxuICAgICAgICBvdXQud3JpdGVCeXRlKDApO1xcblxcbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAgICAgIC8vIEdsb2JhbCBDb2xvciBNYXBcXG5cXG4gICAgICAgIC8vIGJsYWNrXFxuICAgICAgICBvdXQud3JpdGVCeXRlKDB4MDApO1xcbiAgICAgICAgb3V0LndyaXRlQnl0ZSgweDAwKTtcXG4gICAgICAgIG91dC53cml0ZUJ5dGUoMHgwMCk7XFxuXFxuICAgICAgICAvLyB3aGl0ZVxcbiAgICAgICAgb3V0LndyaXRlQnl0ZSgweGZmKTtcXG4gICAgICAgIG91dC53cml0ZUJ5dGUoMHhmZik7XFxuICAgICAgICBvdXQud3JpdGVCeXRlKDB4ZmYpO1xcblxcbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAgICAgIC8vIEltYWdlIERlc2NyaXB0b3JcXG5cXG4gICAgICAgIG91dC53cml0ZVN0cmluZygnLCcpO1xcbiAgICAgICAgb3V0LndyaXRlU2hvcnQoMCk7XFxuICAgICAgICBvdXQud3JpdGVTaG9ydCgwKTtcXG4gICAgICAgIG91dC53cml0ZVNob3J0KF93aWR0aCk7XFxuICAgICAgICBvdXQud3JpdGVTaG9ydChfaGVpZ2h0KTtcXG4gICAgICAgIG91dC53cml0ZUJ5dGUoMCk7XFxuXFxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICAgICAgLy8gTG9jYWwgQ29sb3IgTWFwXFxuXFxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICAgICAgLy8gUmFzdGVyIERhdGFcXG5cXG4gICAgICAgIHZhciBsendNaW5Db2RlU2l6ZSA9IDI7XFxuICAgICAgICB2YXIgcmFzdGVyID0gZ2V0TFpXUmFzdGVyKGx6d01pbkNvZGVTaXplKTtcXG5cXG4gICAgICAgIG91dC53cml0ZUJ5dGUobHp3TWluQ29kZVNpemUpO1xcblxcbiAgICAgICAgdmFyIG9mZnNldCA9IDA7XFxuXFxuICAgICAgICB3aGlsZSAocmFzdGVyLmxlbmd0aCAtIG9mZnNldCA+IDI1NSkge1xcbiAgICAgICAgICBvdXQud3JpdGVCeXRlKDI1NSk7XFxuICAgICAgICAgIG91dC53cml0ZUJ5dGVzKHJhc3Rlciwgb2Zmc2V0LCAyNTUpO1xcbiAgICAgICAgICBvZmZzZXQgKz0gMjU1O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgb3V0LndyaXRlQnl0ZShyYXN0ZXIubGVuZ3RoIC0gb2Zmc2V0KTtcXG4gICAgICAgIG91dC53cml0ZUJ5dGVzKHJhc3Rlciwgb2Zmc2V0LCByYXN0ZXIubGVuZ3RoIC0gb2Zmc2V0KTtcXG4gICAgICAgIG91dC53cml0ZUJ5dGUoMHgwMCk7XFxuXFxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICAgICAgLy8gR0lGIFRlcm1pbmF0b3JcXG4gICAgICAgIG91dC53cml0ZVN0cmluZygnOycpO1xcbiAgICAgIH07XFxuXFxuICAgICAgdmFyIGJpdE91dHB1dFN0cmVhbSA9IGZ1bmN0aW9uIGJpdE91dHB1dFN0cmVhbShvdXQpIHtcXG5cXG4gICAgICAgIHZhciBfb3V0ID0gb3V0O1xcbiAgICAgICAgdmFyIF9iaXRMZW5ndGggPSAwO1xcbiAgICAgICAgdmFyIF9iaXRCdWZmZXIgPSAwO1xcblxcbiAgICAgICAgdmFyIF90aGlzID0ge307XFxuXFxuICAgICAgICBfdGhpcy53cml0ZSA9IGZ1bmN0aW9uIChkYXRhLCBsZW5ndGgpIHtcXG5cXG4gICAgICAgICAgaWYgKGRhdGEgPj4+IGxlbmd0aCAhPSAwKSB7XFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsZW5ndGggb3ZlcicpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHdoaWxlIChfYml0TGVuZ3RoICsgbGVuZ3RoID49IDgpIHtcXG4gICAgICAgICAgICBfb3V0LndyaXRlQnl0ZSgweGZmICYgKGRhdGEgPDwgX2JpdExlbmd0aCB8IF9iaXRCdWZmZXIpKTtcXG4gICAgICAgICAgICBsZW5ndGggLT0gOCAtIF9iaXRMZW5ndGg7XFxuICAgICAgICAgICAgZGF0YSA+Pj49IDggLSBfYml0TGVuZ3RoO1xcbiAgICAgICAgICAgIF9iaXRCdWZmZXIgPSAwO1xcbiAgICAgICAgICAgIF9iaXRMZW5ndGggPSAwO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIF9iaXRCdWZmZXIgPSBkYXRhIDw8IF9iaXRMZW5ndGggfCBfYml0QnVmZmVyO1xcbiAgICAgICAgICBfYml0TGVuZ3RoID0gX2JpdExlbmd0aCArIGxlbmd0aDtcXG4gICAgICAgIH07XFxuXFxuICAgICAgICBfdGhpcy5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgaWYgKF9iaXRMZW5ndGggPiAwKSB7XFxuICAgICAgICAgICAgX291dC53cml0ZUJ5dGUoX2JpdEJ1ZmZlcik7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH07XFxuXFxuICAgICAgICByZXR1cm4gX3RoaXM7XFxuICAgICAgfTtcXG5cXG4gICAgICB2YXIgZ2V0TFpXUmFzdGVyID0gZnVuY3Rpb24gZ2V0TFpXUmFzdGVyKGx6d01pbkNvZGVTaXplKSB7XFxuXFxuICAgICAgICB2YXIgY2xlYXJDb2RlID0gMSA8PCBsendNaW5Db2RlU2l6ZTtcXG4gICAgICAgIHZhciBlbmRDb2RlID0gKDEgPDwgbHp3TWluQ29kZVNpemUpICsgMTtcXG4gICAgICAgIHZhciBiaXRMZW5ndGggPSBsendNaW5Db2RlU2l6ZSArIDE7XFxuXFxuICAgICAgICAvLyBTZXR1cCBMWldUYWJsZVxcbiAgICAgICAgdmFyIHRhYmxlID0gbHp3VGFibGUoKTtcXG5cXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xlYXJDb2RlOyBpICs9IDEpIHtcXG4gICAgICAgICAgdGFibGUuYWRkKFN0cmluZy5mcm9tQ2hhckNvZGUoaSkpO1xcbiAgICAgICAgfVxcbiAgICAgICAgdGFibGUuYWRkKFN0cmluZy5mcm9tQ2hhckNvZGUoY2xlYXJDb2RlKSk7XFxuICAgICAgICB0YWJsZS5hZGQoU3RyaW5nLmZyb21DaGFyQ29kZShlbmRDb2RlKSk7XFxuXFxuICAgICAgICB2YXIgYnl0ZU91dCA9IGJ5dGVBcnJheU91dHB1dFN0cmVhbSgpO1xcbiAgICAgICAgdmFyIGJpdE91dCA9IGJpdE91dHB1dFN0cmVhbShieXRlT3V0KTtcXG5cXG4gICAgICAgIC8vIGNsZWFyIGNvZGVcXG4gICAgICAgIGJpdE91dC53cml0ZShjbGVhckNvZGUsIGJpdExlbmd0aCk7XFxuXFxuICAgICAgICB2YXIgZGF0YUluZGV4ID0gMDtcXG5cXG4gICAgICAgIHZhciBzID0gU3RyaW5nLmZyb21DaGFyQ29kZShfZGF0YVtkYXRhSW5kZXhdKTtcXG4gICAgICAgIGRhdGFJbmRleCArPSAxO1xcblxcbiAgICAgICAgd2hpbGUgKGRhdGFJbmRleCA8IF9kYXRhLmxlbmd0aCkge1xcblxcbiAgICAgICAgICB2YXIgYyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoX2RhdGFbZGF0YUluZGV4XSk7XFxuICAgICAgICAgIGRhdGFJbmRleCArPSAxO1xcblxcbiAgICAgICAgICBpZiAodGFibGUuY29udGFpbnMocyArIGMpKSB7XFxuXFxuICAgICAgICAgICAgcyA9IHMgKyBjO1xcbiAgICAgICAgICB9IGVsc2Uge1xcblxcbiAgICAgICAgICAgIGJpdE91dC53cml0ZSh0YWJsZS5pbmRleE9mKHMpLCBiaXRMZW5ndGgpO1xcblxcbiAgICAgICAgICAgIGlmICh0YWJsZS5zaXplKCkgPCAweGZmZikge1xcblxcbiAgICAgICAgICAgICAgaWYgKHRhYmxlLnNpemUoKSA9PSAxIDw8IGJpdExlbmd0aCkge1xcbiAgICAgICAgICAgICAgICBiaXRMZW5ndGggKz0gMTtcXG4gICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgIHRhYmxlLmFkZChzICsgYyk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIHMgPSBjO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICBiaXRPdXQud3JpdGUodGFibGUuaW5kZXhPZihzKSwgYml0TGVuZ3RoKTtcXG5cXG4gICAgICAgIC8vIGVuZCBjb2RlXFxuICAgICAgICBiaXRPdXQud3JpdGUoZW5kQ29kZSwgYml0TGVuZ3RoKTtcXG5cXG4gICAgICAgIGJpdE91dC5mbHVzaCgpO1xcblxcbiAgICAgICAgcmV0dXJuIGJ5dGVPdXQudG9CeXRlQXJyYXkoKTtcXG4gICAgICB9O1xcblxcbiAgICAgIHZhciBsendUYWJsZSA9IGZ1bmN0aW9uIGx6d1RhYmxlKCkge1xcblxcbiAgICAgICAgdmFyIF9tYXAgPSB7fTtcXG4gICAgICAgIHZhciBfc2l6ZSA9IDA7XFxuXFxuICAgICAgICB2YXIgX3RoaXMgPSB7fTtcXG5cXG4gICAgICAgIF90aGlzLmFkZCA9IGZ1bmN0aW9uIChrZXkpIHtcXG4gICAgICAgICAgaWYgKF90aGlzLmNvbnRhaW5zKGtleSkpIHtcXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2R1cCBrZXk6JyArIGtleSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgX21hcFtrZXldID0gX3NpemU7XFxuICAgICAgICAgIF9zaXplICs9IDE7XFxuICAgICAgICB9O1xcblxcbiAgICAgICAgX3RoaXMuc2l6ZSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgcmV0dXJuIF9zaXplO1xcbiAgICAgICAgfTtcXG5cXG4gICAgICAgIF90aGlzLmluZGV4T2YgPSBmdW5jdGlvbiAoa2V5KSB7XFxuICAgICAgICAgIHJldHVybiBfbWFwW2tleV07XFxuICAgICAgICB9O1xcblxcbiAgICAgICAgX3RoaXMuY29udGFpbnMgPSBmdW5jdGlvbiAoa2V5KSB7XFxuICAgICAgICAgIHJldHVybiB0eXBlb2YgX21hcFtrZXldICE9ICd1bmRlZmluZWQnO1xcbiAgICAgICAgfTtcXG5cXG4gICAgICAgIHJldHVybiBfdGhpcztcXG4gICAgICB9O1xcblxcbiAgICAgIHJldHVybiBfdGhpcztcXG4gICAgfTtcXG5cXG4gICAgdmFyIGNyZWF0ZUltZ1RhZyA9IGZ1bmN0aW9uIGNyZWF0ZUltZ1RhZyh3aWR0aCwgaGVpZ2h0LCBnZXRQaXhlbCwgYWx0KSB7XFxuXFxuICAgICAgdmFyIGdpZiA9IGdpZkltYWdlKHdpZHRoLCBoZWlnaHQpO1xcbiAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgaGVpZ2h0OyB5ICs9IDEpIHtcXG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgd2lkdGg7IHggKz0gMSkge1xcbiAgICAgICAgICBnaWYuc2V0UGl4ZWwoeCwgeSwgZ2V0UGl4ZWwoeCwgeSkpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgYiA9IGJ5dGVBcnJheU91dHB1dFN0cmVhbSgpO1xcbiAgICAgIGdpZi53cml0ZShiKTtcXG5cXG4gICAgICB2YXIgYmFzZTY0ID0gYmFzZTY0RW5jb2RlT3V0cHV0U3RyZWFtKCk7XFxuICAgICAgdmFyIGJ5dGVzID0gYi50b0J5dGVBcnJheSgpO1xcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDEpIHtcXG4gICAgICAgIGJhc2U2NC53cml0ZUJ5dGUoYnl0ZXNbaV0pO1xcbiAgICAgIH1cXG4gICAgICBiYXNlNjQuZmx1c2goKTtcXG5cXG4gICAgICB2YXIgaW1nID0gJyc7XFxuICAgICAgaW1nICs9ICc8aW1nJztcXG4gICAgICBpbWcgKz0gJyBzcmM9XFxcIic7XFxuICAgICAgaW1nICs9ICdkYXRhOmltYWdlL2dpZjtiYXNlNjQsJztcXG4gICAgICBpbWcgKz0gYmFzZTY0O1xcbiAgICAgIGltZyArPSAnXFxcIic7XFxuICAgICAgaW1nICs9ICcgd2lkdGg9XFxcIic7XFxuICAgICAgaW1nICs9IHdpZHRoO1xcbiAgICAgIGltZyArPSAnXFxcIic7XFxuICAgICAgaW1nICs9ICcgaGVpZ2h0PVxcXCInO1xcbiAgICAgIGltZyArPSBoZWlnaHQ7XFxuICAgICAgaW1nICs9ICdcXFwiJztcXG4gICAgICBpZiAoYWx0KSB7XFxuICAgICAgICBpbWcgKz0gJyBhbHQ9XFxcIic7XFxuICAgICAgICBpbWcgKz0gYWx0O1xcbiAgICAgICAgaW1nICs9ICdcXFwiJztcXG4gICAgICB9XFxuICAgICAgaW1nICs9ICcvPic7XFxuXFxuICAgICAgcmV0dXJuIGltZztcXG4gICAgfTtcXG5cXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAgLy8gcmV0dXJucyBxcmNvZGUgZnVuY3Rpb24uXFxuXFxuICAgIHJldHVybiBxcmNvZGU7XFxuICB9KCk7XFxuXFxuICAoZnVuY3Rpb24gKGZhY3RvcnkpIHtcXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xcbiAgICAgIGRlZmluZShbXSwgZmFjdG9yeSk7XFxuICAgIH0gZWxzZSBpZiAoKHR5cGVvZiBleHBvcnRzID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihleHBvcnRzKSkgPT09ICdvYmplY3QnKSB7XFxuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XFxuICAgIH1cXG4gIH0pKGZ1bmN0aW9uICgpIHtcXG4gICAgcmV0dXJuIHFyY29kZTtcXG4gIH0pO1xcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gIC8vXFxuICAvLyBRUiBDb2RlIEdlbmVyYXRvciBmb3IgSmF2YVNjcmlwdCBVVEY4IFN1cHBvcnQgKG9wdGlvbmFsKVxcbiAgLy9cXG4gIC8vIENvcHlyaWdodCAoYykgMjAxMSBLYXp1aGlrbyBBcmFzZVxcbiAgLy9cXG4gIC8vIFVSTDogaHR0cDovL3d3dy5kLXByb2plY3QuY29tL1xcbiAgLy9cXG4gIC8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZTpcXG4gIC8vICBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxcbiAgLy9cXG4gIC8vIFRoZSB3b3JkICdRUiBDb2RlJyBpcyByZWdpc3RlcmVkIHRyYWRlbWFyayBvZlxcbiAgLy8gREVOU08gV0FWRSBJTkNPUlBPUkFURURcXG4gIC8vICBodHRwOi8vd3d3LmRlbnNvLXdhdmUuY29tL3FyY29kZS9mYXFwYXRlbnQtZS5odG1sXFxuICAvL1xcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cXG4gICFmdW5jdGlvbiAocXJjb2RlKSB7XFxuXFxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgIC8vIG92ZXJ3cml0ZSBxcmNvZGUuc3RyaW5nVG9CeXRlc1xcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblxcbiAgICBxcmNvZGUuc3RyaW5nVG9CeXRlcyA9IGZ1bmN0aW9uIChzKSB7XFxuICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xODcyOTQwNS9ob3ctdG8tY29udmVydC11dGY4LXN0cmluZy10by1ieXRlLWFycmF5XFxuICAgICAgZnVuY3Rpb24gdG9VVEY4QXJyYXkoc3RyKSB7XFxuICAgICAgICB2YXIgdXRmOCA9IFtdO1xcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgdmFyIGNoYXJjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XFxuICAgICAgICAgIGlmIChjaGFyY29kZSA8IDB4ODApIHV0ZjgucHVzaChjaGFyY29kZSk7ZWxzZSBpZiAoY2hhcmNvZGUgPCAweDgwMCkge1xcbiAgICAgICAgICAgIHV0ZjgucHVzaCgweGMwIHwgY2hhcmNvZGUgPj4gNiwgMHg4MCB8IGNoYXJjb2RlICYgMHgzZik7XFxuICAgICAgICAgIH0gZWxzZSBpZiAoY2hhcmNvZGUgPCAweGQ4MDAgfHwgY2hhcmNvZGUgPj0gMHhlMDAwKSB7XFxuICAgICAgICAgICAgdXRmOC5wdXNoKDB4ZTAgfCBjaGFyY29kZSA+PiAxMiwgMHg4MCB8IGNoYXJjb2RlID4+IDYgJiAweDNmLCAweDgwIHwgY2hhcmNvZGUgJiAweDNmKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICAvLyBzdXJyb2dhdGUgcGFpclxcbiAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgIGkrKztcXG4gICAgICAgICAgICAgIC8vIFVURi0xNiBlbmNvZGVzIDB4MTAwMDAtMHgxMEZGRkYgYnlcXG4gICAgICAgICAgICAgIC8vIHN1YnRyYWN0aW5nIDB4MTAwMDAgYW5kIHNwbGl0dGluZyB0aGVcXG4gICAgICAgICAgICAgIC8vIDIwIGJpdHMgb2YgMHgwLTB4RkZGRkYgaW50byB0d28gaGFsdmVzXFxuICAgICAgICAgICAgICBjaGFyY29kZSA9IDB4MTAwMDAgKyAoKGNoYXJjb2RlICYgMHgzZmYpIDw8IDEwIHwgc3RyLmNoYXJDb2RlQXQoaSkgJiAweDNmZik7XFxuICAgICAgICAgICAgICB1dGY4LnB1c2goMHhmMCB8IGNoYXJjb2RlID4+IDE4LCAweDgwIHwgY2hhcmNvZGUgPj4gMTIgJiAweDNmLCAweDgwIHwgY2hhcmNvZGUgPj4gNiAmIDB4M2YsIDB4ODAgfCBjaGFyY29kZSAmIDB4M2YpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiB1dGY4O1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gdG9VVEY4QXJyYXkocyk7XFxuICAgIH07XFxuICB9KHFyY29kZSk7XFxuXFxuICByZXR1cm4gcXJjb2RlO1xcbn0oKSk7XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yYXctbG9hZGVyIS4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWI/P3JlZi0tMC0wIS4vYXNzZXRzL2pzL2pxdWVyeS5xcmNvZGUtMC4xMi4wLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9yYXctbG9hZGVyL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMC0wIS4vYXNzZXRzL2pzL2pxdWVyeS5xcmNvZGUtMC4xMi4wLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCJ2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXFxcInN5bWJvbFxcXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXFxcInN5bWJvbFxcXCIgOiB0eXBlb2Ygb2JqOyB9O1xcblxcbi8qKlxcbiAqIENvcHlyaWdodCAoYykgMjAxMS0yMDE0IEZlbGl4IEduYXNzXFxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXFxuICogaHR0cDovL3NwaW4uanMub3JnL1xcbiAqL1xcblxcbi8qXFxuXFxuQmFzaWMgVXNhZ2U6XFxuPT09PT09PT09PT09XFxuXFxuJCgnI2VsJykuc3BpbigpOyAvLyBDcmVhdGVzIGEgZGVmYXVsdCBTcGlubmVyIHVzaW5nIHRoZSB0ZXh0IGNvbG9yIG9mICNlbFxcbiQoJyNlbCcpLnNwaW4oeyAuLi4gfSk7IC8vIENyZWF0ZXMgYSBTcGlubmVyIHVzaW5nIHRoZSBwcm92aWRlZCBvcHRpb25zXFxuXFxuJCgnI2VsJykuc3BpbihmYWxzZSk7IC8vIFN0b3BzIGFuZCByZW1vdmVzIHRoZSBzcGlubmVyXFxuXFxuVXNpbmcgUHJlc2V0czpcXG49PT09PT09PT09PT09PVxcblxcbiQoJyNlbCcpLnNwaW4oJ3NtYWxsJyk7IC8vIENyZWF0ZXMgYSAnc21hbGwnIFNwaW5uZXIgdXNpbmcgdGhlIHRleHQgY29sb3Igb2YgI2VsXFxuJCgnI2VsJykuc3BpbignbGFyZ2UnLCAnI2ZmZicpOyAvLyBDcmVhdGVzIGEgJ2xhcmdlJyB3aGl0ZSBTcGlubmVyXFxuXFxuQWRkaW5nIGEgY3VzdG9tIHByZXNldDpcXG49PT09PT09PT09PT09PT09PT09PT09PVxcblxcbiQuZm4uc3Bpbi5wcmVzZXRzLmZsb3dlciA9IHtcXG4gIGxpbmVzOiAgIDksXFxuICBsZW5ndGg6IDEwLFxcbiAgd2lkdGg6ICAyMCxcXG4gIHJhZGl1czogIDBcXG59O1xcblxcbiQoJyNlbCcpLnNwaW4oJ2Zsb3dlcicsICdyZWQnKTtcXG5cXG4qL1xcblxcbjsoZnVuY3Rpb24gKGZhY3RvcnkpIHtcXG5cXG4gIGlmICgodHlwZW9mIGV4cG9ydHMgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGV4cG9ydHMpKSA9PSAnb2JqZWN0Jykge1xcbiAgICAvLyBDb21tb25KU1xcbiAgICBmYWN0b3J5KHJlcXVpcmUoJ2pxdWVyeScpLCByZXF1aXJlKCdzcGluLmpzJykpO1xcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xcbiAgICAvLyBBTUQsIHJlZ2lzdGVyIGFzIGFub255bW91cyBtb2R1bGVcXG4gICAgZGVmaW5lKFsnanF1ZXJ5JywgJ3NwaW4nXSwgZmFjdG9yeSk7XFxuICB9IGVsc2Uge1xcbiAgICAvLyBCcm93c2VyIGdsb2JhbHNcXG4gICAgaWYgKCF3aW5kb3cuU3Bpbm5lcikgdGhyb3cgbmV3IEVycm9yKCdTcGluLmpzIG5vdCBwcmVzZW50Jyk7XFxuICAgIGZhY3Rvcnkod2luZG93LmpRdWVyeSwgd2luZG93LlNwaW5uZXIpO1xcbiAgfVxcbn0pKGZ1bmN0aW9uICgkLCBTcGlubmVyKSB7XFxuXFxuICAkLmZuLnNwaW4gPSBmdW5jdGlvbiAob3B0cywgY29sb3IpIHtcXG5cXG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgdmFyICR0aGlzID0gJCh0aGlzKTtcXG4gICAgICB2YXIgZGF0YSA9ICR0aGlzLmRhdGEoKTtcXG5cXG4gICAgICBpZiAoZGF0YS5zcGlubmVyKSB7XFxuICAgICAgICBkYXRhLnNwaW5uZXIuc3RvcCgpO1xcbiAgICAgICAgZGVsZXRlIGRhdGEuc3Bpbm5lcjtcXG4gICAgICB9XFxuICAgICAgaWYgKG9wdHMgIT09IGZhbHNlKSB7XFxuICAgICAgICBvcHRzID0gJC5leHRlbmQoeyBjb2xvcjogY29sb3IgfHwgJHRoaXMuY3NzKCdjb2xvcicpIH0sICQuZm4uc3Bpbi5wcmVzZXRzW29wdHNdIHx8IG9wdHMpO1xcbiAgICAgICAgZGF0YS5zcGlubmVyID0gbmV3IFNwaW5uZXIob3B0cykuc3Bpbih0aGlzKTtcXG4gICAgICB9XFxuICAgIH0pO1xcbiAgfTtcXG5cXG4gICQuZm4uc3Bpbi5wcmVzZXRzID0ge1xcbiAgICB0aW55OiB7IGxpbmVzOiA4LCBsZW5ndGg6IDIsIHdpZHRoOiAyLCByYWRpdXM6IDMgfSxcXG4gICAgc21hbGw6IHsgbGluZXM6IDgsIGxlbmd0aDogNCwgd2lkdGg6IDMsIHJhZGl1czogNSB9LFxcbiAgICBsYXJnZTogeyBsaW5lczogMTAsIGxlbmd0aDogOCwgd2lkdGg6IDQsIHJhZGl1czogOCB9XFxuICB9O1xcbn0pO1wiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmF3LWxvYWRlciEuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliPz9yZWYtLTAtMCEuL2Fzc2V0cy9qcy9qcXVlcnkuc3Bpbi5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvcmF3LWxvYWRlci9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTAtMCEuL2Fzc2V0cy9qcy9qcXVlcnkuc3Bpbi5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcXG5AY29weXJpZ2h0IENvcHlyaWdodCAoYykgMjAxMy0yMDE2LCBOb3J3ZWdpYW4gRGVmZW5jZSBSZXNlYXJjaCBFc3RhYmxpc2htZW50IChGRkkpIC0gQWxsIFJpZ2h0cyBSZXNlcnZlZFxcbkBsaWNlbnNlIFByb3ByaWV0YXJ5IGFuZCBjb25maWRlbnRpYWxcXG5AYXV0aG9yIE1vcnRlbiBLcmFuZSAoU25hcHBlcikgLSBmaXJzdCB2ZXJzaW9uIFxcbkBhdXRob3IgQXJpbGQgQmVyZ2gvU2luZXR0IDMuMCBwcm9ncmFtbWUgKGZpcnN0bmFtZS5sYXN0bmFtZUBmZmkubm8pIHJld3JpdGUvaW1wbGVtZW50YXRpb24gb2YgYWxsIGZ1bmN0aW9uYWxpdHlcXG5AYXV0aG9yIENlY2lsaWUgSmFja2JvIEdyYW4vU2luZXR0IDMuMCBwcm9ncmFtbWUgKGZpcnN0bmFtZS5taWRkbGVuYW1lLmxhc3RuYW1lQGZmaS5ubykgYWRkaXRpb25hbCBmdW5jdGlvbmFsaXR5XFxuXFxuVW5hdXRob3JpemVkIGNvcHlpbmcgb2YgdGhpcyBmaWxlLCB2aWEgYW55IG1lZGl1bSBpcyBzdHJpY3RseSBwcm9oaWJpdGVkIFxcblxcbkZvciB0aGUgZnVsbCBjb3B5cmlnaHQgYW5kIGxpY2Vuc2UgaW5mb3JtYXRpb24sIHBsZWFzZSB2aWV3IHRoZSBMSUNFTlNFX01MQUIgZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXFxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG5cXG4vKipcXG5Db3JlIGZ1bmN0aW9uYWxpdHkgZm9yIHRoZSBjb21wb25lbnQgQVBJLCBhbGwgZmVhdHVyZXMgaGVyZSBhcmUgbG9jYWxcXG5SZW1vdGUgZnVuY3Rpb25hbGl0eSBpcyBwcm92aWRlZCBieSBhbnkgcGx1Z2lucyAoc2VlIGVuZCBvZiBmaWxlIGZvciBwbHVnaW4gY29kZSlcXG5cXG5LZXkgaXNzdWUgaGVyZSBpcyB0aGF0IGZvciBkYXRhIHN0b3JhZ2Ugd2UgbmVlZCB0byB1c2UgYSBwcm9wZXIgbmFtZXNwYWNlLCB0aGlzIGlzIGFzIGZvbGxvd3MuXFxuXFxuTGV2ZWwgMTogVHlwZSAoc3RhdGUvY29uZmlnL3Jlc3VsdC9ldGMpXFxuTGV2ZWwgMjogVXNlciBuYW1lXFxuTGV2ZWwgMzogSXRlbSBuYW1lXFxuTGV2ZWwgNCAob3B0aW9uYWwgcmFyZWx5IHJlcXVpcmVkKSBzdWIgaXRlbSBuYW1lXFxuXFxuU3RvcmFnZSBpcyBhbHJlYWR5IGFwcC1zcGVjaWZpYywgc28gbm8gbmVlZCB0byBpbmNsdWRlIHRoYXQgaW50byB0aGUgbmFtZXNwYWNlLlxcbiovXFxuXFxuLyoqXFxuICogU3RhbmRhcmQgaW5pdGlhbGlzYXRpb24gb2YgTWxhYiBvYmplY3Qgd2hpY2ggaXMgcmVmZXJyZWQgdG8gaW4gc2V2ZXJhbCBKUyBmaWxlcywgXFxuICogYXMgdGhlc2UgZmlsZXMgY2FuIGNvbWUgZG93biBpbiBkaWZmZXJlbnQgb3JkZXIsIHdlIG11c3QgbWFrZSBzdXJlIHdlIGNhbiB1c2UgaXQgaGVyZS5cXG4gKiBAcmV0dXJucyB7TWxhYl9kdF9hcGl9XFxuICogQGNvbnN0cnVjdG9yXFxuICovXFxuZnVuY3Rpb24gTWxhYl9hcGkoKSB7XFxuICAgIHZhciBzZWxmID0gdGhpcztcXG4gICAgdmFyIGRvY3VtZW50T2IgPSAkKGRvY3VtZW50KTtcXG5cXG4gICAgdGhpcy5kYXRhX2RpdmlkZXIgPSBcXFwiL1xcXCI7XFxuXFxuICAgIHRoaXMuZGIucGFyZW50ID0gdGhpcztcXG4gICAgdGhpcy5kYi5pbnRlcm5hbC5wYXJlbnQgPSB0aGlzLmRiO1xcbiAgICB0aGlzLm1vZGUgPSB0aGlzLmdldE1vZGUoKTtcXG5cXG4gICAgLyogXFxuICAgICAqIE9iamVjdCB0byBob2xkIGNvbXBvbmVudHMgbG9hZGVkLCB0aGlzIGluY2x1ZGVzIHJlZ3VsYXIgY29tcG9uZW50cywgZmVhdHVyZXMgYW5kIHN0b3JhZ2UgcGx1Z2luc1xcbiAgICAqL1xcbiAgICB0aGlzLmNvbXBvbmVudHMgPSB7fTtcXG5cXG4gICAgLyotLS0gZGF0YWJhc2UgLS0tKi9cXG5cXG4gICAgLyogT2JqZWN0IHRvIGhvbGQgdGhlIHBsdWdpbnMgbG9hZGVkICovXFxuICAgIHRoaXMuZGIucGx1Z2lucyA9IHt9O1xcblxcbiAgICAvL2FkZCBzdG9yYWdlIGZvciB0aGUgYXBwIHNwZWNpZmljIHZhcmlhYmxlcyAoZ2VuZXJhdGVkIGluIHRoZSBwcmUtY29tcGlsZSBwcm9jZXNzaW5nIGZ1bmN0aW9uKVxcbiAgICAvLyB0byB0aGUgb2JqZWN0IGhlcmVcXG4gICAgdGhpcy52YXJpYWJsZXMgPSBuZXcgT2JqZWN0KCk7XFxuXFxuICAgIC8vIGFkZGVkIGJ5IGFyaWxkXFxuICAgIC8vIHRoaXMgd2lsbCBsb2FkIHRoZSB0ZXh0IGZpbGUganMvaW5jbHVkZV9jb21wLnR4dCBhbmQgbG9hZCBhbGwgdGhlIGNvbXBvbmVudCBydW50aW1lIGNvZGUgdGhhdCBhcmUgbGlzdGVkIHRoZXJlXFxuICAgIC8vIHRoZXNlIGFyZSBuYW1lIENPTVBPTkVOVE5BTUVfY29kZV9ydC5qcywgZm9yIGluc3RhbmNlIGdvb2dsZW1hcF9jb2RlX3J0LmpzXFxuICAgIC8vIFRIRSBSRUFTT04gRk9SIFRISVMgSVMgVEhBVCBKUVVFUlkgV0lMTCBOT1QgQ09ORklSTSBSRUNFSVZFRCBGSUxFIElGIEEgLkpTIEZJTEUgRE9FUyBOT1QgQ09OVEFJTiBWQUxJRCBKUyBGSUxcXG4gICAgLy8gQVQgVEhFIFNBTUUgVElNRSBXRSBORUVEIFRPIENPTlRST0wgVEhFIExPQURJTkcgT0YgVEhFU0UgRklMRVMgQVMgVEhFWSBBUkUgVVNFRCBUTyBJTklUSUFMSVNFIENPTVBPTkVOVFNcXG5cXG4gICAgLyogTUs6IFNsaWdodGx5IGRpZmZlcmVudCBoYW5kbGluZyBvZiBwYXRoLiBBZGRpbmcgaXQgdG8gZW1wdHkgc3RyaW5nLCB0byBtYWtlIHN1cmUgd2UgZ2V0IGEgY29weS5cXG4gICAgICAgIEFsc28gc3BsaXR0aW5nIGluIGluZGV4X2h0bWwsIGJlY2F1c2Ugd2UgZG8gbm90IGtub3cgd2hhdCBwYXJhbWV0ZXJzIHRoZXJlIGFyZS5cXG4gICAgICovXFxuICAgIHZhciBtbGFiX3JlYWR5X3RyaWdnZXJlZCA9IGZhbHNlO1xcbiAgICB2YXIgcGF0aCA9ICcnICsgd2luZG93LmxvY2F0aW9uLmhyZWYuc3BsaXQoJ2luZGV4Lmh0bWwnKVswXTtcXG4gICAgLyogTUs6IFdoZW4galF1ZXJ5IGxvYWRzIGEgZmlsZSBlbmRpbmcgd2l0aCAuanMgKGFuZCBubyBjb250ZW50LXR5cGUgcmVzcG9uc2UgaGVhZGVyIGlzIHNldCkgaXQgYXNzdW1lcyBhIEpTIGZpbGUuIFdoZW4gdGhpcyBcXG4gICAgICAgIGZpbGUgcHJvdmVzIG5vdCB0byBiZSBhIEpTIGZpbGUsIHRoZSBzdWNjZXNzIGhhbmRsZXIgaXMgbmV2ZXIgZmlyZWQuIFN1Z2dlc3QgcmVuYW1pbmcgdG8gLnR4dC5cXG4gICAgKi9cXG4gICAgJC5hamF4U2V0dXAoeyBjYWNoZTogZmFsc2UgfSk7XFxuICAgICQuZ2V0KHBhdGggKyBcXFwianMvaW5jbHVkZV9jb21wLnR4dFxcXCIpLmRvbmUoZnVuY3Rpb24gKGRhdGEpIHtcXG4gICAgICAgIHZhciBjb21wb25lbnRzID0gZGF0YS5zcGxpdChcXFwiXFxcXG5cXFwiKTtcXG4gICAgICAgIHZhciBjb21wb25lbnRzTGVuZ3RoID0gY29tcG9uZW50cy5sZW5ndGg7XFxuICAgICAgICB2YXIgY29tcG9uZW50c0FkZGVkID0gMDtcXG5cXG4gICAgICAgIC8vIE1LOiBDb252ZXJ0ZWQgZm9yKCkgdG8gJC5lYWNoKCksIGJlY2F1c2UgXFxcIm5hbWVcXFwiIHZhcmlhYmxlIHdhcyBvdmVyd3JpdHRlbiBiZWZvcmUgWEhSIHdhcyBmaW5pc2hlZC4gJC5lYWNoIHByb3ZpZGVzIGNsb3N1cmUgdG8gdGhlIHZhcmlhYmxlcy5cXG4gICAgICAgICQuZWFjaChjb21wb25lbnRzLCBmdW5jdGlvbiAoaSwgY29tcG9uZW50KSB7XFxuICAgICAgICAgICAgLy8gTUs6IGpzLyB3YXMgYWxyZWFkeSBwYXJ0IG9mIHRoZSBjb21wb25lbnQgbmFtZVxcbiAgICAgICAgICAgIHZhciBuYW1lID0gY29tcG9uZW50LnJlcGxhY2UoXFxcIl9jb2RlX3J0LmpzXFxcIiwgXFxcIlxcXCIpLnJlcGxhY2UoXFxcImpzL1xcXCIsIFxcXCJcXFwiKTtcXG4gICAgICAgICAgICAkLmdldChwYXRoICsgY29tcG9uZW50LCBmdW5jdGlvbiAoY29tcG9uZW50Q29kZSkge1xcbiAgICAgICAgICAgICAgICAvL3dlIG5lZWQgdG8gYXR0YWNoIHRoZSBjb2RlX3J0LmpzIGNvbnRlbnQgdG8gYW4gb2JqZWN0IHNvIHdlIGNhbiB1c2UgaXQgYXMgSlMgY29kZVxcbiAgICAgICAgICAgICAgICBldmFsKFxcXCJtbGFiLmFwaS5jb21wb25lbnRzWydcXFwiICsgbmFtZSArIFxcXCInXSA9IG5ldyBmdW5jdGlvbigpIHtcXFwiICsgY29tcG9uZW50Q29kZSArIFxcXCJ9KCk7XFxcIik7XFxuXFxuICAgICAgICAgICAgICAgIC8vaGVyZSB3ZSBjcmVhdGUgdGhlIGFwaSBvYmplY3RzIGluc2lkZSB0aGUgbmV3bHkgY3JlYXRlZCBvYmplY3RcXG4gICAgICAgICAgICAgICAgbWxhYi5hcGkuY29tcG9uZW50c1tuYW1lXS5hcGkgPSBtbGFiLmFwaTtcXG4gICAgICAgICAgICAgICAgY29tcG9uZW50c0FkZGVkICs9IDE7XFxuXFxuICAgICAgICAgICAgICAgIC8qIE1LOiBCZWNhdXNlIGFqYXggaXMgYXN5bmNocm9ub3VzLCB3ZSBkbyBub3Qga25vdyB0aGUgb3JkZXIgaW4gd2hpY2ggdGhlIGNvbXBvbmVudHMgd2lsbCBiZSBhZGRlZFxcbiAgICAgICAgICAgICAgICAgICAgT25seSB3aGVuIHRoZXNlIG51bWJlcnMgYWRkIHVwIGRvIHdlIGtub3cgdGhhdCBldmVyeXRoaW5nIGlzIE9LIFxcbiAgICAgICAgICAgICAgICAqL1xcbiAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50c0FkZGVkID09IGNvbXBvbmVudHNMZW5ndGgpIHtcXG4gICAgICAgICAgICAgICAgICAgIC8vIE1LOiBOb3Qgc3VyZSBpZiB0aGlzIGlzIHRoZSB3YXkgaXQgc2hvdWxkIGJlLCBidXQgXFxcInBhZ2Vjb250YWluZXJsb2FkXFxcIiB3YXMgbmV2ZXIgdHJpZ2dlcmVkLlxcbiAgICAgICAgICAgICAgICAgICAgJChkb2N1bWVudCkudHJpZ2dlcihcXFwibWxhYnJlYWR5XFxcIik7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH0pO1xcbiAgICB9KS5mYWlsKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICQoZG9jdW1lbnQpLnRyaWdnZXIoXFxcIm1sYWJyZWFkeVxcXCIpO1xcbiAgICB9KTtcXG4gICAgcmV0dXJuIHRoaXM7XFxufVxcblxcbi8qKlxcbiAqIEluaXRpYWxpc2UgdGhlIGRpZmZlcmVudCBmdW5jdGlvbnMuXFxuICogQHR5cGUgTWxhYl9hcGlcXG4gKi9cXG5NbGFiX2FwaS5wcm90b3R5cGUgPSB7XFxuICAgIHZlcnNpb246IDAuOSxcXG4gICAgLyoqXFxuICAgICAqIEdldCB0aGUgbW9kZSB0aGUgYXBwIGlzIGluOiBcXFwicnVudGltZVxcXCIgaWYgaW4gYXBwIG1vZGUsIFxcXCJkZXNpZ25cXFwiIGlmIGluIGVkaXRvciBtb2RlLCBcXG4gICAgICogd2l0aCBhZGRpdGlvbmFsIGRldmljZSBpbmZvLCBhcHAgZm9yIG1vYmlsZSBkZXZpY2UsIGRlc2t0b3AgZm9yIGJyb3dzZXIgKGkuZS4gbm8gY29yZG92YSlcXG4gICAgICogQHJldHVybiB7b2JqZWN0fVxcbiAgICAgKi9cXG4gICAgZ2V0TW9kZTogZnVuY3Rpb24gZ2V0TW9kZSgpIHtcXG4gICAgICAgIHZhciBtb2RlID0geyBtb2RlOiBcXFwiZGVzaWduXFxcIiwgZGV2aWNlOiBcXFwiZGVza3RvcFxcXCIgfTtcXG4gICAgICAgIGlmICh0eXBlb2YgbWxhYi5kdCA9PSBcXFwidW5kZWZpbmVkXFxcIikge1xcbiAgICAgICAgICAgIG1vZGUubW9kZSA9IFxcXCJydW50aW1lXFxcIjtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93LmNvcmRvdmEgIT0gXFxcInVuZGVmaW5lZFxcXCIpIHtcXG4gICAgICAgICAgICBtb2RlLmRldmljZSA9IFxcXCJtb2JpbGVcXFwiO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIG1vZGU7XFxuICAgIH0sXFxuXFxuICAgIGdldERldmljZUlkOiBmdW5jdGlvbiBnZXREZXZpY2VJZCgpIHtcXG4gICAgICAgIHZhciBtb2RlID0gdGhpcy5nZXRNb2RlKCk7XFxuICAgICAgICBpZiAobW9kZS5kZXZpY2UgPT0gXFxcIm1vYmlsZVxcXCIpIHtcXG4gICAgICAgICAgICByZXR1cm4gZGV2aWNlLnV1aWQ7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHZhciBnbG9iYWxfZGF0YSA9IHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShcXFwiR0xPQkFMXFxcIik7XFxuICAgICAgICAgICAgaWYgKCFnbG9iYWxfZGF0YSkge1xcbiAgICAgICAgICAgICAgICBnbG9iYWxfZGF0YSA9IHsgXFxcImRldmljZV91dWlkXFxcIjogdGhpcy5nZXRHVUlEKCkgfTtcXG4gICAgICAgICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKFxcXCJHTE9CQUxcXFwiLCBKU09OLnN0cmluZ2lmeShnbG9iYWxfZGF0YSkpO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIGdsb2JhbF9kYXRhID0gSlNPTi5wYXJzZShnbG9iYWxfZGF0YSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHJldHVybiBnbG9iYWxfZGF0YS5kZXZpY2VfdXVpZDtcXG4gICAgICAgIH1cXG4gICAgfSxcXG5cXG4gICAgZ2V0QXBwVWlkOiBmdW5jdGlvbiBnZXRBcHBVaWQoKSB7XFxuICAgICAgICByZXR1cm4gJCgnaGVhZCA+IFtuYW1lPVxcXCJtbGFiOmFwcF91aWRcXFwiXScpLmF0dHIoXFxcImNvbnRlbnRcXFwiKTtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIENyZWF0ZXMgYSB1bmlxdWUgSUQgc3RhcnRpbmcgd2l0aCB0aGUgcHJlZml4IG1sYWJfLCBmb2xsb3dlZCBieSBhIHJmYzQxMjIgdmVyc2lvbiA0IGNvbXBsaWFudCBHVUlELiBcXG4gICAgICogVGhpcyBpcyB0eXBpY2FsbHkgdXNlZCB0byBjcmVhdGUgYW4gSUQgZm9yIGEgY29tcG9uZW50IHRoYXQgbXVzdCBub3QgY2xhc2ggd2l0aCBhbnkgb3RoZXIgSURzLlxcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxcbiAgICAgKi9cXG4gICAgZ2V0R1VJRDogZnVuY3Rpb24gZ2V0R1VJRCgpIHtcXG4gICAgICAgIHJldHVybiAnbWxhYl8nICsgJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbiAoYykge1xcbiAgICAgICAgICAgIHZhciByID0gTWF0aC5yYW5kb20oKSAqIDE2IHwgMCxcXG4gICAgICAgICAgICAgICAgdiA9IGMgPT0gJ3gnID8gciA6IHIgJiAweDMgfCAweDg7XFxuICAgICAgICAgICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xcbiAgICAgICAgfSk7XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBHZXQgY3VycmVudCBsb2NhbGVcXG4gICAgICogQHJldHVybnMgc3RyaW5nXFxuICAgICAqL1xcbiAgICBnZXRMb2NhbGU6IGZ1bmN0aW9uIGdldExvY2FsZSgpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5sb2NhbGU7XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBSZWFkcyBpbiB0aGUgSmF2YXNjcmlwdCB2YWx1ZXMgc3RvcmVkIGZvciB0aGUgc3BlY2lmaWVkIGVsZW1lbnQsIGV4dHJhY3RzIHRoZSB2YWx1ZSBvZiB0aGUga2V5IHNwZWNpZmllZC5cXG4gICAgICogVGhpcyBvbmx5IHdvcmtzIG9uIHRvcCBsZXZlbCB2YXJzLCBmdXJ0aGVyIHByb2Nlc3NpbmcgbXVzdCBiZSBkb25lIGluc2lkZSB0aGUgSlMgY29kZSBmb3IgdGhlIGNvbXBvbmVudC5cXG4gICAgICogXFxuICAgICAqIFZhcmlhYmxlcyBhcmUgc3RvcmVkIGluIGEgPHNjcmlwdD4gb2YgdHlwZSBhcHBsaWNhdGlvbi9qc29uIGFzIHN0cmluZ2lmaWVkIEpTT04sIG9uIHRoZSBzYW1lIGxldmVsIGFzIHRoZSBtYWluIGNvbXBvbmVudCBIVE1MNSBjb2RlLlxcbiAgICAgKiBUaGVzZSBhcmUgYWxsIGNvbnRhaW5lZCB3aXRoaW4gYSB3cmFwcGVyIERJViB0aGF0IGlzIHRoZSBhY3R1YWwgRE9NIGVsZW1lbnQgcHBhc3NlZCB0byB0aGlzIGZ1bmN0aW9uLlxcbiAgICAgKiBAcGFyYW0ge2pRdWVyeSBET00gZWxlbWVudH0gZWxcXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSwgdGhlIGtleSBuYW1lIGluIHRoZSBvYmplY3RcXG4gICAgICogQHJldHVybnMge01sYWJfZHRfYXBpLnByb3RvdHlwZS5nZXRWYXJpYWJsZS52YXJzfEFycmF5fE9iamVjdH1cXG4gICAgICovXFxuICAgIGdldFZhcmlhYmxlOiBmdW5jdGlvbiBnZXRWYXJpYWJsZShlbCwga2V5KSB7XFxuICAgICAgICB2YXIganNvbiA9ICQoZWwpLmZpbmQoXFxcInNjcmlwdC5tbGFiX3N0b3JhZ2VcXFwiKS5odG1sKCk7XFxuICAgICAgICBpZiAodHlwZW9mIGpzb24gPT0gXFxcInVuZGVmaW5lZFxcXCIgfHwganNvbiA9PSBcXFwiXFxcIikge1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgdmFyIHZhcnMgPSBKU09OLnBhcnNlKGpzb24pO1xcbiAgICAgICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGUpO1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiB2YXJzW2tleV07XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBSZWFkcyBpbiB0aGUgSmF2YXNjcmlwdCB2YWx1ZXMgc3RvcmVkIGZvciB0aGUgc3BlY2lmaWVkIGVsZW1lbnQsIGFuZCByZXR1cm5zIGl0IGFzIGEgc2luZ2xlIEpTIG9iamVjdFxcbiAgICAgKiBDb3B5IG9mIGRlc2lnbiB0aW1lIGNvZGUgZG9pbmcgdGhlIHNhbWUgdGhpbmdcXG4gICAgICogVmFyaWFibGVzIGFyZSBzdG9yZWQgaW4gYSA8c2NyaXB0PiBvZiB0eXBlIGFwcGxpY2F0aW9uL2pzb24gYXMgc3RyaW5naWZpZWQgSlNPTiwgb24gdGhlIHNhbWUgbGV2ZWwgYXMgdGhlIG1haW4gY29tcG9uZW50IEhUTUw1IGNvZGUuXFxuICAgICAqIFRoZXNlIGFyZSBhbGwgY29udGFpbmVkIHdpdGhpbiBhIHdyYXBwZXIgRElWIHRoYXQgaXMgdGhlIGFjdHVhbCBET00gZWxlbWVudCBwcGFzc2VkIHRvIHRoaXMgZnVuY3Rpb24uXFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5IERPTSBlbGVtZW50fSBlbFxcbiAgICAgKiBAcmV0dXJucyB7TWxhYl9kdF9hcGkucHJvdG90eXBlLmdldEFsbFZhcmlhYmxlcy52YXJzfEFycmF5fE9iamVjdH1cXG4gICAgICovXFxuICAgIGdldEFsbFZhcmlhYmxlczogZnVuY3Rpb24gZ2V0QWxsVmFyaWFibGVzKGVsKSB7XFxuICAgICAgICB2YXIganNvbiA9ICQoZWwpLmZpbmQoXFxcInNjcmlwdC5tbGFiX3N0b3JhZ2VcXFwiKS5odG1sKCk7XFxuICAgICAgICBpZiAodHlwZW9mIGpzb24gPT0gXFxcInVuZGVmaW5lZFxcXCIgfHwganNvbiA9PSBcXFwiXFxcIikge1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgdmFyIHZhcnMgPSBKU09OLnBhcnNlKGpzb24pO1xcbiAgICAgICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiB2YXJzO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogVGhpcyBmdW5jdGlvbiBzdG9yZXMgdmFyaWFibGVzIGZvciB0aGUgY3VycmVudCBhcHAgaW4gYSBnbG9iYWwgdmFyaWFibGUsIHRoaXMgbWF0Y2hlcyB0aGUgZnVuY3Rpb24gdGl0bGVkIHNldFRlbXBWYXJpYWJsZSBpbiB0aGUgbWxhYi5kdC5hcGkuanMgZmlsZVxcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29tcCwgdGhlIG5hbWUgb2YgdGhlIGNvbXBvbmVudFxcbiAgICAgKiBAcGFyYW0ge29iamVjdH0ga2V5LCBrZXkgdG8gaW5kZXgsIHRoZSBjb21wb25lbnQgbXVzdCBpdHNlbGYgZW5zdXJlIHRoYXQgdGhpcyBpcyB1bmlxdWUsIGZvciBpbnN0YW5jZSBieSB1c2luZyBcXFwieHh4eFxcXCIgKyBteV91bmlxdWVfaWRcXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHZhbHVlXFxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XFxuICAgICAqL1xcbiAgICBzZXRBcHBWYXJpYWJsZTogZnVuY3Rpb24gc2V0QXBwVmFyaWFibGUoY29tcCwga2V5LCB2YWx1ZSkge1xcbiAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudC5tbGFiX3N0b3JhZ2UgPT0gXFxcInVuZGVmaW5lZFxcXCIpIHtcXG4gICAgICAgICAgICBkb2N1bWVudC5tbGFiX3N0b3JhZ2UgPSB7fTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQubWxhYl9zdG9yYWdlW2NvbXBdID09IFxcXCJ1bmRlZmluZWRcXFwiKSB7XFxuICAgICAgICAgICAgZG9jdW1lbnQubWxhYl9zdG9yYWdlW2NvbXBdID0ge307XFxuICAgICAgICB9XFxuICAgICAgICBpZiAodHlwZW9mIGRvY3VtZW50Lm1sYWJfc3RvcmFnZVtjb21wXVtrZXldID09IFxcXCJ1bmRlZmluZWRcXFwiKSB7XFxuICAgICAgICAgICAgZG9jdW1lbnQubWxhYl9zdG9yYWdlW2NvbXBdW2tleV0gPSB7fTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGRvY3VtZW50Lm1sYWJfc3RvcmFnZVtjb21wXVtrZXldID0gdmFsdWU7XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgICAgKiBUaGlzIGZ1bmN0aW9uIHJldHJpZXZlcyB2YXJpYWJsZXMgZm9yIHRoZSBjdXJyZW50IGFwcCBmcm9tIGEgZ2xvYmFsIHZhcmlhYmxlLCB0aGlzIG1hdGNoZXMgdGhlIGZ1bmN0aW9uIHRpdGxlZCBnZXRUZW1wVmFyaWFibGUgaW4gdGhlIG1sYWIuZHQuYXBpLmpzIGZpbGVcXG4gICAgICAgICogQHBhcmFtIHtvYmplY3R9IGNvbXAsIHRoZSBuYW1lIG9mIHRoZSBjb21wb25lbnRcXG4gICAgICAgICogQHBhcmFtIHtvYmplY3R9IGtleSwga2V5IHRvIGluZGV4LCB0aGUgY29tcG9uZW50IG11c3QgaXRzZWxmIGVuc3VyZSB0aGF0IHRoaXMgaXMgdW5pcXVlLCBmb3IgaW5zdGFuY2UgYnkgdXNpbmcgXFxcInh4eHhcXFwiICsgbXlfdW5pcXVlX2lkXFxuICAgICAgICAqIEByZXR1cm5zIHtKYXZhc2NyaXB0IHZhcmlhYmxlfVxcbiAgICAgKi9cXG4gICAgZ2V0QXBwVmFyaWFibGU6IGZ1bmN0aW9uIGdldEFwcFZhcmlhYmxlKGNvbXAsIGtleSkge1xcbiAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudC5tbGFiX3N0b3JhZ2UgPT0gXFxcInVuZGVmaW5lZFxcXCIpIHtcXG4gICAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuICAgICAgICBpZiAodHlwZW9mIGRvY3VtZW50Lm1sYWJfc3RvcmFnZVtjb21wXSA9PSBcXFwidW5kZWZpbmVkXFxcIikge1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQubWxhYl9zdG9yYWdlW2NvbXBdW2tleV0gPT0gXFxcInVuZGVmaW5lZFxcXCIpIHtcXG4gICAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gZG9jdW1lbnQubWxhYl9zdG9yYWdlW2NvbXBdW2tleV07XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBPYmplY3QgdGhhdCBkZWFscyB3aXRoIGFsbCBkYXRhYmFzZSByZWxhdGVkIGFjdGl2aXR5LiBcXG4gICAgICogSW50ZXJuYWxseSBpdCBoYXMgY29kZSBmb3Igc3RvcmluZyBkYXRhIHVzaW5nIEhUTUw1IHdlIHN0b3JhZ2UsIFxcbiAgICAgKiBhbGwgZnVuY3Rpb25zIGNoZWNrIHRvIHNlZSBpZiBhIHN0b3JhZ2UgcGx1Z2luIGlzIGxvYWRlZCwgaWYgc28gaXQgd2lsbCBjYWxsIHRoZSBtYXRjaGluZyBmdW5jdGlvbiBpbiB0aGUgcGx1Z2luIHRvIHN0b3JlIGRhdGEgcmVtb3RlbHkuXFxuICAgICAqIEB0eXBlIG9iamVjdFxcbiAgICAgKi9cXG4gICAgZGI6IHtcXG5cXG4gICAgICAgIC8qIFBvaW50ZXIgdG8gbWFpbiBtbGFiIG9iamVjdCAqL1xcbiAgICAgICAgcGFyZW50OiBudWxsLFxcbiAgICAgICAgcmV0cnlfc2F2ZV9xdWV1ZV9jb3VudGVyOiAwLFxcbiAgICAgICAgcHJvY2Vzc19zYXZlX3F1ZXVlX2NvdW50ZXI6IDAsXFxuICAgICAgICBwcm9jZXNzaW5nX3F1ZXVlOiBmYWxzZSxcXG4gICAgICAgIHByb2Nlc3Nfc2F2ZV9xdWV1ZV9pbnRlcnZhbDogMzAwMCxcXG4gICAgICAgIHByb2Nlc3Nfc2F2ZV9xdWV1ZV9udW1faXRlbXM6IDMsXFxuICAgICAgICBQTFVHSU5fTk9UX1VTRUQ6IC0xLFxcbiAgICAgICAgUExVR0lOX09GRkxJTkU6IC0yLFxcbiAgICAgICAgUExVR0lOX05PX0ZVTkNUSU9OOiAtMyxcXG4gICAgICAgIFBMVUdJTl9OT19EQVRBOiAtNCxcXG5cXG4gICAgICAgIC8vd2UgcmVhZCB0aGUgc3RvcmFnZSBwbHVnaW4gaW5mb3JtYXRpb24gZGlyZWN0bHkgZnJvbSB0aGUgdmFyaWFibGVzIHN0b3JlZCB3aXRoIHRoZSBjb21wb25lbnQgdGhhdCBpbml0aWFsaXNlcyB0aGUgc3RvcmFnZSBwbHVnaW5cXG4gICAgICAgIC8vdGhlc2UgYXJlIHN0b3JlZCBpbiBhIEpTT04gZm9ybWF0IGluIGEgc2NyaXB0IGluc2lkZSB0aGUgZGl2LCBhbmQgdGhlIHZhcmlhYmxlIGlzIGFsd2F5cyBuYW1lZCBzdG9yYWdlX3BsdWdpblxcbiAgICAgICAgLyoqXFxuICAgICAgICAgKiBcXG4gICAgICAgICAqIEBwYXJhbSB7dHlwZX0gZWw6IEhUTUwgZWxlbWVudCB0aGF0ID0gY29tcG9uZW50IHRoYXQgd2FudHMgdG8gb3BlbiBhIGNvbm5lY3Rpb25cXG4gICAgICAgICAqIEBwYXJhbSB7dHlwZX0gY2FsbGJhY2s6IHB0aW9uYWwgY2FsbGJhY2sgdG8gZXhlY3V0ZSBmcm9tIHRoZSBvblBsdWdpbkxvYWRlZCBmdW5jdGlvblxcbiAgICAgICAgICogQHJldHVybnMge0Jvb2xlYW59XFxuICAgICAgICAgKi9cXG4gICAgICAgIHNldHVwU3RvcmFnZVBsdWdpbjogZnVuY3Rpb24gc2V0dXBTdG9yYWdlUGx1Z2luKGVsLCBjYWxsYmFjaykge1xcbiAgICAgICAgICAgIHZhciBwbHVnaW5fY29tcG9uZW50O1xcbiAgICAgICAgICAgIHZhciBvd25lcl9pZCA9ICQoZWwpLmF0dHIoXFxcImlkXFxcIik7XFxuXFxuICAgICAgICAgICAgLy9waWNrIHVwIHRoZSBzZXR0aW5ncyBzdG9yZWQgZm9yIGEgc3RvcmFnZV9wbHVnaW4gdGhpcyBpcyBzYXZlIGF1dG9hbXRpY2FsbHkgYnkgdGhlIG1sYWIgZWRpdG9yIGVudmlyb25tZW50XFxuICAgICAgICAgICAgdmFyIHBsdWdpbl9pbmZvID0gdGhpcy5wYXJlbnQuZ2V0VmFyaWFibGUoZWwsIFxcXCJzdG9yYWdlX3BsdWdpblxcXCIpO1xcblxcbiAgICAgICAgICAgIGlmICghcGx1Z2luX2luZm8pIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpZiAoXFxcIm5hbWVcXFwiIGluIHBsdWdpbl9pbmZvICYmIHBsdWdpbl9pbmZvW1xcXCJuYW1lXFxcIl0gaW4gdGhpcy5wYXJlbnQuY29tcG9uZW50cykge1xcbiAgICAgICAgICAgICAgICBwbHVnaW5fY29tcG9uZW50ID0gdGhpcy5wYXJlbnQuY29tcG9uZW50c1twbHVnaW5faW5mb1tcXFwibmFtZVxcXCJdXTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaWYgKCFwbHVnaW5fY29tcG9uZW50KSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgLy90aGUgcGx1Z2lucyBvYmplY3QgaG9sZHMgYSBsaXN0IG9mIGNvbXBvbmVudHMgKGVmZmVjdGl2ZWx5IHBvaW50ZXJzIHRvIGNvbXBvbmVudHMpLCB0aGlzIG1lYW5zIGFsbCBjb21wb25lbnRzIHNoYXJlIGEgc2luZ2xlIGluc3RhbmNlIG9mIHRoZSBjb2RlXFxuICAgICAgICAgICAgLy93ZSB0aGVyZWZvcmUgbmVlZCB0byBhZGQgYSB2YXJpYWJsZSB0aGF0IGhvbGRzIHVuaXF1ZSB2YWx1ZXMgZm9yIGVhY2ggXFxcImluc3RhbmNlXFxcIiBvZiB0aGlzIHBsdWdpblxcbiAgICAgICAgICAgIGlmICghKFxcXCJfZGF0YVxcXCIgaW4gcGx1Z2luX2NvbXBvbmVudCkpIHtcXG4gICAgICAgICAgICAgICAgcGx1Z2luX2NvbXBvbmVudC5fZGF0YSA9IHt9O1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBwbHVnaW5fY29tcG9uZW50Ll9kYXRhW293bmVyX2lkXSA9IHt9O1xcbiAgICAgICAgICAgIHBsdWdpbl9jb21wb25lbnQuX2RhdGFbb3duZXJfaWRdLnNldHRpbmdzID0gcGx1Z2luX2luZm87XFxuICAgICAgICAgICAgcGx1Z2luX2NvbXBvbmVudC5fZGF0YVtvd25lcl9pZF0uaHRtbF9lbGVtZW50ID0gZWw7XFxuICAgICAgICAgICAgcGx1Z2luX2NvbXBvbmVudC5fZGF0YVtvd25lcl9pZF0ub3duZXJfdXVpZCA9IG93bmVyX2lkO1xcblxcbiAgICAgICAgICAgIHRoaXMucGx1Z2luc1tvd25lcl9pZF0gPSBwbHVnaW5fY29tcG9uZW50O1xcblxcbiAgICAgICAgICAgIC8vIG9ucGx1Z2lubG9hZGVkIGlzbid0IHJlcXVpcmVkIGZvciBwbHVnaW5zLCBcXG4gICAgICAgICAgICBpZiAoXFxcIm9uUGx1Z2luTG9hZGVkXFxcIiBpbiBwbHVnaW5fY29tcG9uZW50KSB7XFxuICAgICAgICAgICAgICAgIHBsdWdpbl9jb21wb25lbnQub25QbHVnaW5Mb2FkZWQoZWwsIGNhbGxiYWNrKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgLy9sYXN0IHRoaW5nIHdlIGRvIGlzIHRvIHN0YXJ0IGEgZ2xvYmFsIHRpbWVyIHdoaWNoIHRyaWVzIHRvIHNhdmUgdW5zYXZlZCBkYXRhIChpZiB0aGlzIGlzIG5vdCBhbHJlYWR5IGRvbmVcXG4gICAgICAgICAgICBpZiAoIXRoaXMucHJvY2Vzc2luZ19xdWV1ZSkge1xcbiAgICAgICAgICAgICAgICB3aW5kb3cuc2V0SW50ZXJ2YWwobWxhYi5hcGkuZGIuaW50ZXJuYWwucHJvY2Vzc0ZhaWxlZFF1ZXVlKCksIHRoaXMucHJvY2Vzc19zYXZlX3F1ZXVlX2ludGVydmFsKTtcXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzaW5nX3F1ZXVlID0gdHJ1ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgICB9LFxcblxcbiAgICAgICAgLyogLS0tLSBmdW5jdGlvbnMgdGhhdCBhcmUgcnVuIGxvY2FsbHkgaWYgbm8gcGx1Z2luIGlzIGxvYWRlZCAtLS0tICovXFxuXFxuICAgICAgICAvKiBTZXRzIHN0YXRlIGZvciB1c2VyLCBhbHNvIG1ha2VzIHN1cmUgaXQgaXMgc2F2ZWQgZm9yIGxhdGVyIHVzZS5cXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1c2VyIFVzZXIgSUQgZm9yIHRoZSBjdXJyZW50bHkgbG9nZ2VkIGluIHVzZXIuIFJlcXVpcmVkLlxcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBLZXkgbmFtZSBmb3IgdGhlIHN0YXRlIHRvIGJlIHN0b3JlZC4gUmVxdWlyZWQuXFxuICAgICAgICAgKiBAcGFyYW0ge2FueX0gdmFsdWUgVGhlIHN0YXRlIHZhbHVlIHRvIGJlIHN0b3JlZC4gUmVxdWlyZWQuIENhbiBiZSBhbnl0aGluZyB0aGF0IGlzIGNvbXBhdGlibGUgd2l0aCBKU09OLnN0cmluZ2lmeS4gQWxsIGJhc2ljIEphdmFzY3JpcHQgdHlwZXMgc2hvdWxkIGJlIE9LLlxcbiAgICAgICAgICovXFxuICAgICAgICBzZXRTdGF0ZTogZnVuY3Rpb24gc2V0U3RhdGUoZGV2aWNlX3V1aWQsIGNvbXBvbmVudF91dWlkLCBrZXksIHZhbHVlLCBjYWxsYmFjaykge1xcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmludGVybmFsLnNldERhdGEoXFxcInN0YXRlXFxcIiwgZGV2aWNlX3V1aWQsIGNvbXBvbmVudF91dWlkLCBrZXksIHZhbHVlLCBjYWxsYmFjayk7XFxuICAgICAgICB9LFxcblxcbiAgICAgICAgLyoqXFxuICAgICAgICAgKiBHZXRzIHN0YXRlIGZvciBnaXZlbiB1c2VyIGFuIGtleS5cXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1c2VyIFVzZXIgSUQgZm9yIHRoZSBjdXJyZW50bHkgbG9nZ2VkIGluIHVzZXIuIFJlcXVpcmVkLlxcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBLZXkgbmFtZSBmb3IgdGhlIHN0YXRlIHRvIGJlIHN0b3JlZC4gUmVxdWlyZWQuXFxuICAgICAgICAgKiBAcmV0dXJuIHtBbnl9IFZhbHVlIG9mIHN0YXRlXFxuICAgICAgICAgKi9cXG4gICAgICAgIGdldFN0YXRlOiBmdW5jdGlvbiBnZXRTdGF0ZShkZXZpY2VfdXVpZCwgY29tcG9uZW50X3V1aWQsIGtleSwgY2FsbGJhY2spIHtcXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbC5nZXREYXRhKFxcXCJzdGF0ZVxcXCIsIGRldmljZV91dWlkLCBjb21wb25lbnRfdXVpZCwga2V5LCBjYWxsYmFjayk7XFxuICAgICAgICB9LFxcblxcbiAgICAgICAgLyoqXFxuICAgICAgICAgKiBHZXRzIGFsbCBzdG9yZWQgc3RhdGVzIGZvciB1c2VyIFxcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHVzZXIgVXNlciBJRCBmb3IgdGhlIGN1cnJlbnRseSBsb2dnZWQgaW4gdXNlci4gT3B0aW9uYWwuXFxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCBjb250YWluaW5nIHRoZSBzdGF0ZXNcXG4gICAgICAgICAqL1xcbiAgICAgICAgZ2V0QWxsU3RhdGU6IGZ1bmN0aW9uIGdldEFsbFN0YXRlKGRldmljZV91dWlkLCBjb21wb25lbnRfdXVpZCwgY2FsbGJhY2spIHtcXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbC5nZXRBbGxEYXRhKFxcXCJzdGF0ZVxcXCIsIGRldmljZV91dWlkLCBjb21wb25lbnRfdXVpZCwgY2FsbGJhY2spO1xcbiAgICAgICAgfSxcXG5cXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogU2V0cyBjb25maWcgZm9yIHVzZXIsIGFsc28gbWFrZXMgc3VyZSBpdCBpcyBzYXZlZCBmb3IgbGF0ZXIgdXNlLlxcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHVzZXIgVXNlciBJRCBmb3IgdGhlIGN1cnJlbnRseSBsb2dnZWQgaW4gdXNlci4gUmVxdWlyZWQuXFxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IEtleSBuYW1lIGZvciB0aGUgY29uZmlnIHRvIGJlIHN0b3JlZC4gUmVxdWlyZWQuXFxuICAgICAgICAgKiBAcGFyYW0ge2FueX0gdmFsdWUgVGhlIGNvbmZpZyB2YWx1ZSB0byBiZSBzdG9yZWQuIFJlcXVpcmVkLiBBbnl0aGluZyB0aGF0IGlzIGNvbXBhdGlibGUgd2l0aCBKU09OLnN0cmluZ2lmeS4gQWxsIGJhc2ljIEphdmFzY3JpcHQgdHlwZXMgc2hvdWxkIGJlIE9LLlxcbiAgICAgICAgICovXFxuICAgICAgICBzZXRDb25maWc6IGZ1bmN0aW9uIHNldENvbmZpZyhkZXZpY2VfdXVpZCwgY29tcG9uZW50X3V1aWQsIGtleSwgdmFsdWUsIGNhbGxiYWNrKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWwuc2V0RGF0YShcXFwiY29uZmlnXFxcIiwgZGV2aWNlX3V1aWQsIGNvbXBvbmVudF91dWlkLCBrZXksIHZhbHVlLCBjYWxsYmFjayk7XFxuICAgICAgICB9LFxcblxcbiAgICAgICAgLyoqXFxuICAgICAgICAgKiBHZXRzIGNvbmZpZyBmb3IgZ2l2ZW4gdXNlciBhbiBrZXkuXFxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXNlciBVc2VyIElEIGZvciB0aGUgY3VycmVudGx5IGxvZ2dlZCBpbiB1c2VyLiBSZXF1aXJlZC5cXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgS2V5IG5hbWUgZm9yIHRoZSBjb25maWcgdG8gYmUgc3RvcmVkLiBSZXF1aXJlZC5cXG4gICAgICAgICAqIEByZXR1cm4ge2FueX0gVGhlIGNvbmZpZyB2YWx1ZSAoYW55IHR5cGUpLCBvciBudWxsXFxuICAgICAgICAgKi9cXG4gICAgICAgIGdldENvbmZpZzogZnVuY3Rpb24gZ2V0Q29uZmlnKGRldmljZV91dWlkLCBjb21wb25lbnRfdXVpZCwga2V5LCBjYWxsYmFjaykge1xcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmludGVybmFsLmdldERhdGEoXFxcImNvbmZpZ1xcXCIsIGRldmljZV91dWlkLCBjb21wb25lbnRfdXVpZCwga2V5LCBjYWxsYmFjayk7XFxuICAgICAgICB9LFxcblxcbiAgICAgICAgLyoqXFxuICAgICAgICAgKiBHZXRzIGFsbCBzdG9yZWQgY29uZmlncywgb3IgYWxsIHN0b3JlZCBjb25maWdzIGZvciB1c2VyIChpZiBnaXZlbikuXFxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXNlcjogVXNlciBJRCBmb3IgdGhlIGN1cnJlbnRseSBsb2dnZWQgaW4gdXNlci4gT3B0aW9uYWwuXFxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCBjb250YWluaW5nIHRoZSBjb25maWdzXFxuICAgICAgICAgKi9cXG4gICAgICAgIGdldEFsbENvbmZpZzogZnVuY3Rpb24gZ2V0QWxsQ29uZmlnKGRldmljZV91dWlkLCBjb21wb25lbnRfdXVpZCwgY2FsbGJhY2spIHtcXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbC5nZXRBbGxEYXRhKFxcXCJjb25maWdcXFwiLCBkZXZpY2VfdXVpZCwgY29tcG9uZW50X3V1aWQsIGNhbGxiYWNrKTtcXG4gICAgICAgIH0sXFxuXFxuICAgICAgICAvKipcXG4gICAgICAgICAqIFNhdmVzIHJlc3VsdCBmb3IgYSBxdWVzdGlvbi5cXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1c2VyIFVzZXIgSUQgZm9yIHRoZSBjdXJyZW50bHkgbG9nZ2VkIGluIHVzZXIuIFJlcXVpcmVkLlxcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIHF1aXouIE11c3QgYmUgdW5pcXVlIHdpdGhpbiB0aGUgYXBwLiBSZXF1aXJlZC5cXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgVGhlIG5hbWUgb2YgdGhlIHF1ZXN0aW9uLiBNdXN0IGJlIHVuaXF1ZSB3aXRoaW4gdGhlIHF1aXouIFJlcXVpcmVkLlxcbiAgICAgICAgICogQHBhcmFtIHthbnl9IHZhbHVlIFRoZSB2YWx1ZSB0byBiZSBzdG9yZWQuXFxuICAgICAgICAgKi9cXG4gICAgICAgIHNldFJlc3VsdDogZnVuY3Rpb24gc2V0UmVzdWx0KGRldmljZV91dWlkLCBjb21wb25lbnRfdXVpZCwga2V5LCB2YWx1ZSwgY2FsbGJhY2spIHtcXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbC5zZXREYXRhKFxcXCJyZXN1bHRcXFwiLCBkZXZpY2VfdXVpZCwgY29tcG9uZW50X3V1aWQsIGtleSwgdmFsdWUsIGNhbGxiYWNrKTtcXG4gICAgICAgIH0sXFxuXFxuICAgICAgICAvKipcXG4gICAgICAgICAqIEdldCBzYXZlZCByZXN1bHQgZm9yIHNwZWNpZmljIHF1ZXN0aW9uXFxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXNlciBVc2VyIElEIGZvciB0aGUgY3VycmVudGx5IGxvZ2dlZCBpbiB1c2VyLiBSZXF1aXJlZC5cXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBxdWl6LiBNdXN0IGJlIHVuaXF1ZSB3aXRoaW4gdGhlIGFwcC4gUmVxdWlyZWQuXFxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IFRoZSBuYW1lIG9mIHRoZSBxdWVzdGlvbi4gTXVzdCBiZSB1bmlxdWUgd2l0aGluIHRoZSBxdWl6LiBSZXF1aXJlZC5cXG4gICAgICAgICAqIEByZXR1cm4ge2FueX0gVGhlIHZhbHVlIHRoYXQgd2FzIHNhdmVkLiBOb3JtYWxseSBhbiBvYmplY3QsIGJ1dCBhbnkgSlNPTi1zdHJpbmdpZmlhYmxlIHZhbHVlIGlzIGFsbG93ZWQuXFxuICAgICAgICAgKi9cXG4gICAgICAgIGdldFJlc3VsdDogZnVuY3Rpb24gZ2V0UmVzdWx0KGRldmljZV91dWlkLCBjb21wb25lbnRfdXVpZCwga2V5LCBjYWxsYmFjaykge1xcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmludGVybmFsLmdldERhdGEoXFxcInJlc3VsdFxcXCIsIGRldmljZV91dWlkLCBjb21wb25lbnRfdXVpZCwga2V5LCBjYWxsYmFjayk7XFxuICAgICAgICB9LFxcblxcbiAgICAgICAgLyoqXFxuICAgICAgICAgKiBHZXRzIGFsbCBzdG9yZWQgcmVzdWx0cywgb3IgYWxsIHN0b3JlZCByZXVsdHMgZm9yIHVzZXIgKGlmIGdpdmVuKS5cXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1c2VyIFVzZXIgSUQgZm9yIHRoZSBjdXJyZW50bHkgbG9nZ2VkIGluIHVzZXIuIE9wdGlvbmFsLlxcbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgY29udGFpbmluZyB0aGUgc3RhdGVzXFxuICAgICAgICAgKi9cXG4gICAgICAgIGdldEFsbFJlc3VsdDogZnVuY3Rpb24gZ2V0QWxsUmVzdWx0KGRldmljZV91dWlkLCBjb21wb25lbnRfdXVpZCwgY2FsbGJhY2spIHtcXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbC5nZXRBbGxEYXRhKFxcXCJyZXN1bHRcXFwiLCBkZXZpY2VfdXVpZCwgY29tcG9uZW50X3V1aWQsIGNhbGxiYWNrKTtcXG4gICAgICAgIH0sXFxuXFxuICAgICAgICAvKiBOZXR3b3JrLWZ1bmN0aW9ucyAqL1xcbiAgICAgICAgLyoqXFxuICAgICAgICAgKiBMb2dpbiBvbiByZW1vdGUgc2VydmljZSwgdGhyb3VnaCBsb2FkZWQgcGx1Z2luLiBJZiB3ZSBoYXZlIGEgbG9naW5Ub2tlbiBzdG9yZWQsIHdlIGFzc3VtZSB0aGlzIGlzIHZhbGlkLCBcXG4gICAgICAgICAqIGFuZCBzaW1wbHkgcmV0dXJuIHRoZSB0b2tlbi5cXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzZXJ2aWNlIFRoZSBzaG9ydF9uYW1lIG9mIHRoZSBzZXJ2aWNlXFxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXNlcm5hbWUgVXNlciBuYW1lXFxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGFzc3dvcmQ6IFBhc3N3b3JkXFxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBvciB7U3RyaW5nfS4gVHJ1ZSBpZiB3ZSBoYXZlIHNlbnQgYSBsb2dpbiByZXF1ZXN0LCBmYWxzZSBpZiB3ZSBoYXZlbid0LiBMb2dpbiB0b2tlbiBzdHJpbmdcXG4gICAgICAgICAqIGlmIGl0IGV4aXN0cy5cXG4gICAgICAgICAqL1xcbiAgICAgICAgbG9naW5SZW1vdGVseTogZnVuY3Rpb24gbG9naW5SZW1vdGVseShjb21wb25lbnRfdXVpZCwgY2FsbGJhY2spIHtcXG4gICAgICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLmxvZ2luVG9rZW4oY29tcG9uZW50X3V1aWQpO1xcbiAgICAgICAgICAgIGlmICh0b2tlbikge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmIChjb21wb25lbnRfdXVpZCBpbiB0aGlzLnBhcmVudC5wbHVnaW5zICYmIHR5cGVvZiB0aGlzLnBhcmVudC5wbHVnaW5zW2NvbXBvbmVudF91dWlkXVtcXFwibG9naW5SZW1vdGVseVxcXCJdID09IFxcXCJmdW5jdGlvblxcXCIpIHtcXG4gICAgICAgICAgICAgICAgb3BEb25lID0gdGhpcy5wYXJlbnQucGx1Z2luc1tjb21wb25lbnRfdXVpZF0ubG9naW5SZW1vdGVseSh0aGlzLnBhcmVudC5wbHVnaW5zW2NvbXBvbmVudF91dWlkXSwgY2FsbGJhY2spO1xcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9wRG9uZSAhPSBcXFwidW5kZWZpbmVkXFxcIikgcmV0dXJuIG9wRG9uZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfSxcXG5cXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogTG9nIG9mZiB0aGUgcmVtb3RlIHNlcnZpY2UsIHRocm91Z2ggcGx1Z2luLlxcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNlcnZpY2UgVGhlIHNob3J0X25hbWUgb2YgdGhlIHNlcnZpY2VcXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgcGx1Z2luIGhhcyBsb2dnZWQgb2ZmLCBmYWxzZSBpZiBub3QuXFxuICAgICAgICAgKi9cXG4gICAgICAgIGxvZ29mZlJlbW90ZWx5OiBmdW5jdGlvbiBsb2dvZmZSZW1vdGVseShjb21wb25lbnRfdXVpZCkge1xcbiAgICAgICAgICAgIHZhciB0b2tlbiA9IHRoaXMubG9naW5Ub2tlbihjb21wb25lbnRfdXVpZCk7XFxuICAgICAgICAgICAgaWYgKCF0b2tlbikge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmIChjb21wb25lbnRfdXVpZCBpbiB0aGlzLnBhcmVudC5wbHVnaW5zICYmIHR5cGVvZiB0aGlzLnBhcmVudC5wbHVnaW5zW2NvbXBvbmVudF91dWlkXVtcXFwibG9nb2ZmUmVtb3RlbHlcXFwiXSA9PSBcXFwiZnVuY3Rpb25cXFwiKSB7XFxuICAgICAgICAgICAgICAgIG9wRG9uZSA9IHRoaXMucGFyZW50LnBsdWdpbnNbY29tcG9uZW50X3V1aWRdLmxvZ29mZlJlbW90ZWx5KHRoaXMucGFyZW50LnBsdWdpbnNbY29tcG9uZW50X3V1aWRdLCB0b2tlbiwgY2FsbGJhY2spO1xcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9wRG9uZSAhPSBcXFwidW5kZWZpbmVkXFxcIikgcmV0dXJuIG9wRG9uZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgfSxcXG5cXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogR2V0dGVyL3NldHRlciBmb3IgdGhlIGxvZ2luIHRva2VuIHN0cmluZy5cXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzZXJ2aWNlIFRoZSBzaG9ydF9uYW1lIG9mIHRoZSBzZXJ2aWNlXFxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdG9rZW4uIFRva2VuIHRvIGJlIHNldC4gT3B0aW9uYWwuXFxuICAgICAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IG9yIHtmYWxzZX0uIFRoZSBjdXJyZW50bHkgc2V0IHRva2VuLCBvciBmYWxzZSBpZiBub3Qgc2V0LlxcbiAgICAgICAgICovXFxuICAgICAgICBsb2dpblRva2VuOiBmdW5jdGlvbiBsb2dpblRva2VuKGNvbXBvbmVudF91dWlkLCB0b2tlbikge1xcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29tcG9uZW50X3V1aWQgPT0gXFxcInVuZGVmaW5lZFxcXCIpIHJldHVybiBmYWxzZTtcXG5cXG4gICAgICAgICAgICAvLyBTYXZlcyB0aGUgbG9naW4gdG9rZW5zIGluIHNlc3Npb24gc3RvcmFnZSwgdW5kZXIgdGhlIGtleSBcXFwibG9naW5Ub2tlbnNcXFwiXFxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiAhPSBcXFwidW5kZWZpbmVkXFxcIikge1xcbiAgICAgICAgICAgICAgICB3aW5kb3cuc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShcXFwiX0xPR0lOX1RPS0VOU19cXFwiICsgY29tcG9uZW50X3V1aWQsIHRva2VuKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgLy9hbHdheXMgcmV0dXJuIHRoZSBzYXZlZCB0b2tlbiwgd2lsbCBhdXRvYW10aWNhbGx5IGJlIG51bGwgaWYgY2FuJ3QgZmluZCBhbnl0aGluZ1xcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3cuc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShcXFwiX0xPR0lOX1RPS0VOU19cXFwiICsgY29tcG9uZW50X3V1aWQpO1xcbiAgICAgICAgfSxcXG5cXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogT2JqZWN0IHRoYXQga2VlcHMgdGhlIGZ1bmN0aW9ucyB0aGF0IGFyZSBub3QgcGFydCBvZiB0aGUgb3V0d2FyZCBmYWNpbmcgQVBJIG9mIG1sYWIuXFxuICAgICAgICAgKi9cXG4gICAgICAgIGludGVybmFsOiB7XFxuICAgICAgICAgICAgLyogUG9pbnRlciB0byBtYWluIG1sYWIgb2JqZWN0ICovXFxuICAgICAgICAgICAgcGFyZW50OiBudWxsLFxcblxcbiAgICAgICAgICAgIC8qKlxcbiAgICAgICAgICAgICAqIEludGVybmFsIGhlbHBlciBmdW5jdGlvbiB0aGF0IGlzIGEgZ2VuZXJpYyB3YXkgb2YgZGlzcGF0Y2hpbmcgYSBjYWxsIHRvIHBsdWdpbi4gSW4gYWRkaXRpb24gdG9cXG4gICAgICAgICAgICAgKiB0aGUgbmFtZWQgcGFyYW1ldGVycyBcXFwib3duZXJfaWRcXFwiIGFuZCBcXFwibmFtZVxcXCIsIGl0IGlzIHBvc3NpYmxlIHRvIHBhc3MgYW55IG51bWJlciBvZiBwYXJhbWV0ZXJzLCB3aGljaCBhcmUgcGFzc2VkXFxuICAgICAgICAgICAgICogb24gdG8gdGhlIHBsdWdpbiBmdW5jdGlvbi5cXG4gICAgICAgICAgICAgKiBcXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3R5cGV9IGZ1bmNcXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3R5cGV9IGRhdGFfdHlwZVxcbiAgICAgICAgICAgICAqIEBwYXJhbSB7dHlwZX0gYXBwX2lkXFxuICAgICAgICAgICAgICogQHBhcmFtIHt0eXBlfSBkZXZpY2VfdXVpZFxcbiAgICAgICAgICAgICAqIEBwYXJhbSB7dHlwZX0gY29tcG9uZW50X3V1aWRcXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3R5cGV9IGtleVxcbiAgICAgICAgICAgICAqIEBwYXJhbSB7dHlwZX0gdmFsdWUgKHVuZGVmaW5lZCBpZiB0aGlzIGlzIGNhbGxpbmcgYSBnZXRYWFggZnVuY3Rpb24pXFxuICAgICAgICAgICAgICogQHBhcmFtIHt0eXBlfSBjYWxsYmFja1xcbiAgICAgICAgICAgICAqIFxcbiAgICAgICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybiB2YWx1ZSBmcm9tIHBsdWdpbiBpZiBpdCBzdXBwb3J0cyB0aGUgZnVuY3Rpb24gcmVxdWlyZWQsIG90aGVyd2lzZSBmYWxzZS5cXG4gICAgICAgICAgICAgKiBUeXBpY2FsbHkgdGhlIGZ1bmN0aW9uIGluIHRoZSBwbHVnaW4gd2lsbCBydW4gdGhlIGNvZGUgYXN5bmNocm9ub3VzbHkgYW5kIGFsd2F5cyByZXR1cm4gdHJ1ZVxcbiAgICAgICAgICAgICAqL1xcbiAgICAgICAgICAgIGRpc3BhdGNoVG9QbHVnaW46IGZ1bmN0aW9uIGRpc3BhdGNoVG9QbHVnaW4oY2FsbGJhY2ssIGZ1bmMsIGRhdGFfdHlwZSwgYXBwX3V1aWQsIGRldmljZV91dWlkLCBjb21wb25lbnRfdXVpZCwga2V5LCB2YWx1ZSkge1xcbiAgICAgICAgICAgICAgICB2YXIgb3BEb25lO1xcblxcbiAgICAgICAgICAgICAgICAvL2lmIG5vIHBsdWdpbiBpcyBsb2FkZWQgZm9yIHRoaXMgdGhlbiBvbmx5IHNhdmUgbG9jYWxseVxcbiAgICAgICAgICAgICAgICBpZiAoIWNvbXBvbmVudF91dWlkIGluIHRoaXMucGFyZW50LnBsdWdpbnMpIHtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5QTFVHSU5fTk9UX1VTRUQ7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgLy9pZiB3ZSdyZSBub3Qgb25saW5lLCBjYWxsIHRoZSBmYWlsZWQgY2FsbGJhY2sgZnVuY3Rpb24gYW5kIHRoZW4gcmV0dXJuIGZhbHNlXFxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yLmNvbm5lY3Rpb24gPT0gXFxcInVuZGVmaW5lZFxcXCIpIHtcXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXR3b3JrU3RhdGUgPSB0cnVlO1xcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ldHdvcmtTdGF0ZSA9IG5hdmlnYXRvci5jb25uZWN0aW9uLnR5cGUgIT0gQ29ubmVjdGlvbi5OT05FO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGlmICghbmV0d29ya1N0YXRlKSB7XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNiUGx1Z2luRmFpbGVkKGRhdGFfdHlwZSwgYXBwX3V1aWQsIGRldmljZV91dWlkLCBjb21wb25lbnRfdXVpZCwga2V5KTtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5QTFVHSU5fT0ZGTElORTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAvKlxcbiAgICAgICAgICAgICAgICAgKiBJbiBzZXR1cFN0b3JhZ2VQbHVnaW4gd2Ugc2hvdWxkIHBlcmhhcHMgcmV0dXJuIGEgdXVpZCwgYW5kIHRoZW4gdGhlIGNvbXBvbmV0IGNhbiB1c2UgdGhhdCBsYXRlciB0byByZWZlciB0byBpdCAob3Igc2hvdWxkIGl0IGJlIHVpZCBvZiBjb21wICsgY29tcCBuYW1lICsgcGx1Z2luIG5hbWU/IHRoYXQgd2F5IGlmIGFscmVhZHkgbG9nZ2VkIGluLCBubyBuZWVkIHRvIGRvIGxvZ2luIGFnYWluLi4uIHdoZW4gcmVsb2FkIHBhZ2Ugd291bGQgbG9zZSB1dWlkKVxcbiAgICAgICAgICAgICAgICAgKiBBbHNvLCB0aGlzIHNob3VsZCBiZSBhIHRpbWVyIGV2ZW50IHRoYXQgcHJvY2Vzc2VzIHRoZSBxdWV1ZS4uLiBvciBwZXJoYXBzIHF1ZXVlIGp1c3Qgd2hlbiBmYWlsLCBzbyBmaXJzdCB0cnkgaGVyZSwgYW5kIHRoZW5cXG4gICAgICAgICAgICAgICAgICogaGF2ZSB0d28gY2FsbGJhY2ssIGZvciBmYWlsIGFuZCBzdWNjZXNzLCAodGhlIG9yaWdpbmFsIGNhbGxiYWNrIGlzIHVzZWQgZm9yIHN1Y2Nlc3MhKSwgaW4gZmFpbCB3ZSBhZGQgdGhpbmdzIHRvIHRoZSBxdWV1ZSB3aGljaCBpcyBwcm9jZXNzZWQgYWdhaW4gb25seSB3aGVuIG9mZmxpbmVcXG4gICAgICAgICAgICAgICAgICovXFxuICAgICAgICAgICAgICAgIHZhciBjYkZhaWwgPSB0aGlzLmNiUGx1Z2luRmFpbGVkO1xcbiAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50X3V1aWQgaW4gdGhpcy5wYXJlbnQucGx1Z2lucyAmJiB0eXBlb2YgdGhpcy5wYXJlbnQucGx1Z2luc1tjb21wb25lbnRfdXVpZF1bZnVuY10gPT0gXFxcImZ1bmN0aW9uXFxcIikge1xcbiAgICAgICAgICAgICAgICAgICAgb3BEb25lID0gdGhpcy5wYXJlbnQucGx1Z2luc1tjb21wb25lbnRfdXVpZF1bZnVuY10oY2JGYWlsLCBjYWxsYmFjaywgYXBwX3V1aWQsIGRldmljZV91dWlkLCBjb21wb25lbnRfdXVpZCwga2V5LCB2YWx1ZSk7XFxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9wRG9uZSAhPSBcXFwidW5kZWZpbmVkXFxcIikge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcERvbmU7XFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5QTFVHSU5fTk9fREFUQTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5QTFVHSU5fTk9fRlVOQ1RJT047XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9LFxcblxcbiAgICAgICAgICAgIC8qKlxcbiAgICAgICAgICAgICAqIElmIHRoZSByZW1vdGUgc2F2ZSBmYWlscyAob3Igd2Ugd2VyZSBvZmZsaW5lIGFscmVhZHkgd2hlbiB0cnkgdG8gc2F2ZSkgd2UgYWRkIGEgcmVjb3JkIHRvIHRoZSBxdWV1ZSB3ZSB1c2UgdG8gcmV0cnkgc2F2ZXNcXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3R5cGV9IG93bmVyX2lkXFxuICAgICAgICAgICAgICogQHBhcmFtIHt0eXBlfSBmdW5jXFxuICAgICAgICAgICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cXG4gICAgICAgICAgICAgKi9cXG4gICAgICAgICAgICBjYlBsdWdpbkZhaWxlZDogZnVuY3Rpb24gY2JQbHVnaW5GYWlsZWQoZGF0YV90eXBlLCBhcHBfdXVpZCwgZGV2aWNlX3V1aWQsIGNvbXBvbmVudF91dWlkLCBrZXkpIHtcXG4gICAgICAgICAgICAgICAgdmFyIFNFUCA9IHRoaXMucGFyZW50LnBhcmVudC5kYXRhX2RpdmlkZXI7XFxuICAgICAgICAgICAgICAgIHZhciBjb3VudGVyID0gdGhpcy5wYXJlbnQucmV0cnlfc2F2ZV9xdWV1ZV9jb3VudGVyKys7IC8vVE9ETyBjb3VsZCBnZXQgYSByYWNlIGNvbmRpdGlvbiBoZXJlLi4uXFxuICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShcXFwiX1FVRVVFX1xcXCIgKyBjb3VudGVyLCBkYXRhX3R5cGUgKyBTRVAgKyBhcHBfdXVpZCArIFNFUCArIGRldmljZV91dWlkICsgU0VQICsgY29tcG9uZW50X3V1aWQgKyBTRVAgKyBrZXkpO1xcbiAgICAgICAgICAgIH0sXFxuXFxuICAgICAgICAgICAgLyoqXFxuICAgICAgICAgICAgICogU2ltcGxlIGZpcnN0IGluLCBmaXJzdCBvdXQgcXVldWUgcHJvY2Vzc2luZywgcmVhZGluZyBlbnRyeSBieSBlbnRyeSBmcm9tIHRoZSBsaXN0IG9mIGl0ZW1zIHRoYXQgd2VyZSBub3Qgc2F2ZWQgY29ycmVjdGx5XFxuICAgICAgICAgICAgICogSGVyZSB3ZSByZXRyeSB0aGUgc2F2ZSBmdW5jdGlvbiBieSBjYWxsaW5nIHNldERhdGEgZGlyZWN0bHkgd2l0aCBhbGwgdGhlIHJlbGV2YW50IFxcbiAgICAgICAgICAgICAqL1xcbiAgICAgICAgICAgIHByb2Nlc3NGYWlsZWRRdWV1ZTogZnVuY3Rpb24gcHJvY2Vzc0ZhaWxlZFF1ZXVlKCkge1xcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBhcmUgc3RpbGwgb25saW5lIHdlIHNpbXBseSBiYWlsXFxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yLmNvbm5lY3Rpb24gPT0gXFxcInVuZGVmaW5lZFxcXCIpIHtcXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXR3b3JrU3RhdGUgPSB0cnVlO1xcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ldHdvcmtTdGF0ZSA9IG5hdmlnYXRvci5jb25uZWN0aW9uLnR5cGUgIT0gQ29ubmVjdGlvbi5OT05FO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIC8vd2Ugc3RvcmUgYSBwb2ludGVyIHRvIHRoZSBsb2NhbCBzdG9yYWdlIG9mIGEgdmFsdWUsIHRoaXMgcG9pbnRlciA9IHRoZSBrZXkgb2YgdGhlIHN0b3JlZCB2YWx1ZVxcbiAgICAgICAgICAgICAgICB2YXIgZHVtbXlfY2IsIHJlcztcXG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSB7IGRhdGFfdHlwZTogbnVsbCwgYXBwX3V1aWQ6IG51bGwsIGRldmljZV91dWlkOiBudWxsLCBjb21wb25lbnRfdXVpZDogbnVsbCwga2V5OiBudWxsIH07XFxuICAgICAgICAgICAgICAgIHZhciBjb3VudGVyID0gdGhpcy5wYXJlbnQucHJvY2Vzc19zYXZlX3F1ZXVlX2NvdW50ZXI7XFxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnBhcmVudC5wcm9jZXNzX3NhdmVfcXVldWVfbnVtX2l0ZW1zOyBpKyspIHtcXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxcXCJwcm9jZXNzaW5nIHFcXFwiKTtcXG4gICAgICAgICAgICAgICAgICAgIC8vaWYgdGhlcmUncyBubyBkYXRhIGluIHRoZSBxdWV1ZSB3ZSBxdWl0XFxuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKFxcXCJfUVVFVUVfXFxcIiArIGNvdW50ZXIpO1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFrZXkpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcXFwibm90aGluZyBpbiBxXFxcIik7cmV0dXJuO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICAgICAgLy9pZiB3ZSBjYW5ub3Qgb2J0YWluIHRoZSB2YWx1ZSB3ZSBxdWl0LCBvdGhlcndpc2Ugd2UgbW92ZSB0aGUgcG9pbnRlciBmb3J3YXJkIGFuZCBwcm9jZXNzIHRoZSByZXRyaWV2ZWQgZGF0YVxcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSk7XFxuICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbHVlKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXFxcIm5vIHZhbHVlIGZvdW5kIGZvciBrZXk6IFxcXCIgKyBrZXkpO3JldHVybjtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wID0ga2V5LnNwbGl0KG1sYWIuYXBpLmRhdGFfZGl2aWRlcik7XFxuICAgICAgICAgICAgICAgICAgICBkYXRhLmRhdGFfdHlwZSA9IHRlbXBbMF07XFxuICAgICAgICAgICAgICAgICAgICBkYXRhLmFwcF91dWlkID0gdGVtcFsxXTtcXG4gICAgICAgICAgICAgICAgICAgIGRhdGEuZGV2aWNlX3V1aWQgPSB0ZW1wWzJdO1xcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5jb21wb25lbnRfdXVpZCA9IHRlbXBbM107XFxuICAgICAgICAgICAgICAgICAgICBkYXRhLmtleSA9IHRlbXBbNF07XFxuICAgICAgICAgICAgICAgICAgICBtbGFiLmFwaS5kYi5wcm9jZXNzX3NhdmVfcXVldWVfY291bnRlcisrO1xcblxcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gbWxhYi5hcGkuZGIuaW50ZXJuYWwuZGlzcGF0Y2hUb1BsdWdpbihkdW1teV9jYiwgXFxcInNldFxcXCIgKyBkYXRhLmRhdGFfdHlwZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGRhdGEuZGF0YV90eXBlLnNsaWNlKDEpLCBkYXRhLmRhdGFfdHlwZSwgZGF0YS5hcHBfdXVpZCwgZGF0YS5kZXZpY2VfdXVpZCwgZGF0YS5jb21wb25lbnRfdXVpZCwgZGF0YS5rZXksIHZhbHVlKTtcXG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVzKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbWxhYi5hcGkuZGIuaW50ZXJuYWwuY2JQbHVnaW5GYWlsZWQoZGF0YV90eXBlLCBhcHBfdXVpZCwgZGV2aWNlX3V1aWQsIGNvbXBvbmVudF91dWlkLCBrZXkpO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSxcXG5cXG4gICAgICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tR0VORVJJQyBGVU5DVElPTlMgVEhBVCBBUkUgVVNFRCBCWSBXUkFQUEVSIEZVTkNUSU9OUyBBQk9WRVxcbiAgICAgICAgICAgIHNldERhdGE6IGZ1bmN0aW9uIHNldERhdGEoZGF0YV90eXBlLCBkZXZpY2VfdXVpZCwgY29tcG9uZW50X3V1aWQsIGtleSwgdmFsdWUsIGNhbGxiYWNrLCBhcHBfaWQpIHtcXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhcHBfaWQgPT0gXFxcInVuZGVmaW5lZFxcXCIpIHtcXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcHBfaWQgPSB0aGlzLnBhcmVudC5wYXJlbnQuZ2V0QXBwVWlkKCk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgLy9hbHdheXMgdXBkYXRlIGxvY2FsbHlcXG4gICAgICAgICAgICAgICAgdmFyIFNFUCA9IHRoaXMucGFyZW50LnBhcmVudC5kYXRhX2RpdmlkZXI7XFxuICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShkYXRhX3R5cGUgKyBTRVAgKyBhcHBfaWQgKyBTRVAgKyBkZXZpY2VfdXVpZCArIFNFUCArIGNvbXBvbmVudF91dWlkICsgU0VQICsga2V5LCBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xcblxcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gdGhpcy5kaXNwYXRjaFRvUGx1Z2luKGNhbGxiYWNrLCBcXFwic2V0XFxcIiArIGRhdGFfdHlwZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGRhdGFfdHlwZS5zbGljZSgxKSwgZGF0YV90eXBlLCBhcHBfaWQsIGRldmljZV91dWlkLCBjb21wb25lbnRfdXVpZCwga2V5LCB2YWx1ZSk7XFxuXFxuICAgICAgICAgICAgICAgIC8vaWYgbm8gcGx1Z2luIG9yIHBsdWdpbiBkb2VzIG5vdCBzdXBwb3J0IGZ1bmN0aW9uIHRoZW4gdGhpcyBpcyBzYXZpbmcgbG9jYWxseSBvbmx5LlxcbiAgICAgICAgICAgICAgICAvL3dlIGNhbGwgdGhlIGNhbGxiYWNrIHdpdGggbG9jYWwgZGF0YSwgYW5kIG1hcmsgaXQgYXMgZnJlc2hcXG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrICYmIChyZXMgPT0gdGhpcy5wYXJlbnQuUExVR0lOX05PVF9VU0VEIHx8IHJlcyA9PSB0aGlzLnBhcmVudC5QTFVHSU5fTk9fRlVOQ1RJT04pKSB7XFxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhdGUgPSBmcmVzaDtcXG4gICAgICAgICAgICAgICAgICAgIC8vb3RoZXJ3aXNlIGRhdGEgaXMgbWFya2VkIGFzIHN0YWxlXFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2FsbGJhY2sgJiYgKHJlcyA9PSB0aGlzLnBhcmVudC5QTFVHSU5fT0ZGTElORSB8fCByZXMgPT0gdGhpcy5wYXJlbnQuUExVR0lOX05PX0RBVEEpKSB7XFxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhdGUgPSBzdGFsZTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2sgJiYgcmVzICE9IHRydWUpIHtcXG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0geyBkYXRhOiB7fSwgc3RhdGU6IHN0YXRlIH07XFxuICAgICAgICAgICAgICAgICAgICBkYXRhLmRhdGFba2V5XSA9IHZhbHVlO1xcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZGF0YSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgICAgICAgfSxcXG5cXG4gICAgICAgICAgICAvKipcXG4gICAgICAgICAgICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiBhIHNpbmdsZSwgdHlwZSBzcGVjaWZpYywgcmVjb3JkLiBSZXR1cm5lZCBhcyBhIGpzb24gb2JqZWN0XFxuICAgICAgICAgICAgICogQHBhcmFtIHt0eXBlfSBkYXRhX3R5cGVcXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3R5cGV9IGRldmljZV91dWlkXFxuICAgICAgICAgICAgICogQHBhcmFtIHt0eXBlfSBjb21wX2lkXFxuICAgICAgICAgICAgICogQHBhcmFtIHt0eXBlfSBrZXlcXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3R5cGV9IGNhbGxiYWNrXFxuICAgICAgICAgICAgICogQHJldHVybnMge0Jvb2xlYW59XFxuICAgICAgICAgICAgICovXFxuICAgICAgICAgICAgZ2V0RGF0YTogZnVuY3Rpb24gZ2V0RGF0YShkYXRhX3R5cGUsIGRldmljZV91dWlkLCBjb21wb25lbnRfdXVpZCwga2V5LCBjYWxsYmFjaykge1xcbiAgICAgICAgICAgICAgICB2YXIgYXBwX2lkID0gdGhpcy5wYXJlbnQucGFyZW50LmdldEFwcFVpZCgpO1xcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gdGhpcy5kaXNwYXRjaFRvUGx1Z2luKGNhbGxiYWNrLCBcXFwiZ2V0XFxcIiArIGRhdGFfdHlwZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGRhdGFfdHlwZS5zbGljZSgxKSwgZGF0YV90eXBlLCBhcHBfaWQsIGRldmljZV91dWlkLCBjb21wX2lkLCBrZXkpO1xcblxcbiAgICAgICAgICAgICAgICAvL0lmIGZhbHNlLCBnZXRSZXN1bHQgaXMgbm90IGltcGxlbWVudGVkIGluIHBsdWdpbiwgYW5kIHdlIHNob3VsZCB1c2UgdGhlIGxvY2FsIHN0b3JhZ2UuXFxuICAgICAgICAgICAgICAgIHZhciBTRVAgPSB0aGlzLnBhcmVudC5wYXJlbnQuZGF0YV9kaXZpZGVyO1xcblxcbiAgICAgICAgICAgICAgICAvL2lmIG5vIHBsdWdpbiBvciBwbHVnaW4gZG9lcyBub3Qgc3VwcG9ydCBmdW5jdGlvbiB0aGVuIHRoaXMgaXMgc2F2aW5nIGxvY2FsbHkgb25seS5cXG4gICAgICAgICAgICAgICAgLy93ZSBjYWxsIHRoZSBjYWxsYmFjayB3aXRoIGxvY2FsIGRhdGEsIGFuZCBtYXJrIGl0IGFzIGZyZXNoXFxuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjayAmJiAocmVzID09IHRoaXMucGFyZW50LlBMVUdJTl9OT1RfVVNFRCB8fCByZXMgPT0gdGhpcy5wYXJlbnQuUExVR0lOX05PX0ZVTkNUSU9OKSkge1xcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXRlID0gXFxcImZyZXNoXFxcIjtcXG4gICAgICAgICAgICAgICAgICAgIC8vb3RoZXJ3aXNlIGRhdGEgaXMgbWFya2VkIGFzIHN0YWxlXFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2FsbGJhY2sgJiYgKHJlcyA9PSB0aGlzLnBhcmVudC5QTFVHSU5fT0ZGTElORSB8fCByZXMgPT0gdGhpcy5wYXJlbnQuUExVR0lOX05PX0RBVEEpKSB7XFxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhdGUgPSBcXFwic3RhbGVcXFwiO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjayAmJiByZXMgIT0gdHJ1ZSkge1xcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSB7IHN0YXRlOiBzdGF0ZSwgZGF0YToge30gfTtcXG4gICAgICAgICAgICAgICAgICAgIGRhdGEuZGF0YVtrZXldID0gSlNPTi5wYXJzZSh3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0oZGF0YV90eXBlICsgU0VQICsgYXBwX2lkICsgU0VQICsgZGV2aWNlX3V1aWQgKyBTRVAgKyBjb21wb25lbnRfdXVpZCArIFNFUCArIGtleSkpO1xcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZGF0YSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgICAgICAgfSxcXG5cXG4gICAgICAgICAgICAvKipcXG4gICAgICAgICAgICAgKiBSZXR1cm5zIGFsbCB2YWx1ZSBvZiBhIHNpbmdsZSB0eXBlIGZvciBhIHNwZWNpZmljIGFwcF9pZC9kZXZpY2VfdXVpZC9jb21wb25lbnRcXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3R5cGV9IGRhdGFfdHlwZVxcbiAgICAgICAgICAgICAqIEBwYXJhbSB7dHlwZX0gZGV2aWNlX3V1aWRcXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3R5cGV9IGNvbXBfaWRcXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3R5cGV9IGNhbGxiYWNrXFxuICAgICAgICAgICAgICogQHJldHVybnMge0Jvb2xlYW59XFxuICAgICAgICAgICAgICovXFxuICAgICAgICAgICAgZ2V0QWxsRGF0YTogZnVuY3Rpb24gZ2V0QWxsRGF0YShkYXRhX3R5cGUsIGRldmljZV91dWlkLCBjb21wX2lkLCBjYWxsYmFjaykge1xcbiAgICAgICAgICAgICAgICB2YXIgYXBwX2lkID0gdGhpcy5wYXJlbnQucGFyZW50LmdldEFwcFVpZCgpO1xcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gdGhpcy5kaXNwYXRjaFRvUGx1Z2luKGNhbGxiYWNrLCBcXFwiZ2V0QWxsXFxcIiArIGRhdGFfdHlwZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGRhdGFfdHlwZS5zbGljZSgxKSwgZGF0YV90eXBlLCBhcHBfaWQsIGRldmljZV91dWlkLCBjb21wX2lkKTtcXG4gICAgICAgICAgICAgICAgdmFyIGxlbiA9IDA7XFxuXFxuICAgICAgICAgICAgICAgIGlmIChyZXMgPT09IHRydWUpIHtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIC8vaWYgbm8gcGx1Z2luIG9yIHBsdWdpbiBkb2VzIG5vdCBzdXBwb3J0IGZ1bmN0aW9uIHRoZW4gdGhpcyBpcyBzYXZpbmcgbG9jYWxseSBvbmx5LlxcbiAgICAgICAgICAgICAgICAvL3dlIGNhbGwgdGhlIGNhbGxiYWNrIHdpdGggbG9jYWwgZGF0YSwgYW5kIG1hcmsgaXQgYXMgZnJlc2hcXG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrICYmIChyZXMgPT0gdGhpcy5wYXJlbnQuUExVR0lOX05PVF9VU0VEIHx8IHJlcyA9PSB0aGlzLnBhcmVudC5QTFVHSU5fTk9fRlVOQ1RJT04pKSB7XFxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhdGUgPSBcXFwiZnJlc2hcXFwiO1xcbiAgICAgICAgICAgICAgICAgICAgLy9vdGhlcndpc2UgZGF0YSBpcyBtYXJrZWQgYXMgc3RhbGVcXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjYWxsYmFjayAmJiAocmVzID09IHRoaXMucGFyZW50LlBMVUdJTl9PRkZMSU5FIHx8IHJlcyA9PSB0aGlzLnBhcmVudC5QTFVHSU5fTk9fREFUQSkpIHtcXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IFxcXCJzdGFsZVxcXCI7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrICYmIHJlcyAhPSB0cnVlKSB7XFxuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IDA7XFxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWVzID0ge307XFxuICAgICAgICAgICAgICAgICAgICB2YXIgc0tleTtcXG4gICAgICAgICAgICAgICAgICAgIHZhciBTRVAgPSB0aGlzLnBhcmVudC5wYXJlbnQuZGF0YV9kaXZpZGVyO1xcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IGRhdGFfdHlwZSArIFNFUCArIGFwcF9pZCArIFNFUCArIGRldmljZV91dWlkICsgU0VQICsgY29tcF9pZCArIFNFUDtcXG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBzS2V5ID0gd2luZG93LmxvY2FsU3RvcmFnZS5rZXkoaSk7IGkrKykge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbiA9IGtleS5sZW5ndGg7XFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNLZXkuc3Vic3RyKDAsIGxlbikgPT0ga2V5KSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlc1tzS2V5XSA9IEpTT04ucGFyc2Uod2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKHNLZXkpKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh7IGRhdGE6IHZhbHVlcywgc3RhdGU6IHN0YXRlIH0pO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgLyoqXFxuICAgICAgICAgICAgICogRGVsZXRlIGV2ZXJ5dGhpbmcgaW4gbG9jYWxzdG9yYWdlLiBGb3IgdGVzdGluZy9kZWJ1Z2dpbmcgcHVycG9zZXMuXFxuICAgICAgICAgICAgICovXFxuICAgICAgICAgICAgY2xlYXJMb2NhbFN0b3JhZ2U6IGZ1bmN0aW9uIGNsZWFyTG9jYWxTdG9yYWdlKCkge1xcbiAgICAgICAgICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLmNsZWFyKCk7XFxuICAgICAgICAgICAgfSxcXG5cXG4gICAgICAgICAgICAvKipcXG4gICAgICAgICAgICAgKiBEZWxldGUgZXZlcnl0aGluZyBpbiBzZXNzaW9uc3RvcmFnZS4gRm9yIHRlc3RpbmcvZGVidWdnaW5nIHB1cnBvc2VzLlxcbiAgICAgICAgICAgICAqL1xcbiAgICAgICAgICAgIGNsZWFyU2Vzc2lvblN0b3JhZ2U6IGZ1bmN0aW9uIGNsZWFyU2Vzc2lvblN0b3JhZ2UoKSB7XFxuICAgICAgICAgICAgICAgIHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5jbGVhcigpO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgIH0gLy9lbmQgaW50ZXJuYWxcXG5cXG5cXG4gICAgfSwgLy9lbmQgZGJcXG5cXG4gICAgLy8tLS0tLS0tLSBPQkpFQ1QgVEhBVCBDT05UQUlOIFNVQiBGVU5DVElPTlMgRk9SIERJRkZFUkVOVCBBUFAgUkVMQVRFRCBUQVNLUyAtLS0tLS0tLS8vXFxuXFxuICAgIC8qKlxcbiAgICAgKiBPYmplY3QgdXNlZCBmb3IgbmF2aWdhdGlvbiBmdW5jdGlvbmFsaXR5IGF0IHJ1bnRpbWVcXG4gICAgICogKGFkZGVkIGJ5IGFyaWxkKVxcbiAgICAgKi9cXG4gICAgbmF2aWdhdGlvbjoge1xcbiAgICAgICAgY3VycmVudF9wYWdlX2luZGV4OiAwLFxcbiAgICAgICAgcGFnZV9saXN0OiAwLFxcbiAgICAgICAgc2VsZjogdGhpcyxcXG5cXG4gICAgICAgIGluaXRpYWxpc2U6IGZ1bmN0aW9uIGluaXRpYWxpc2UoYXBwX3N0YXJ0X3BhZ2UsIGFwcF9wYWdlX2xpc3QpIHtcXG4gICAgICAgICAgICB0aGlzLnBhZ2VfbGlzdCA9IGFwcF9wYWdlX2xpc3Q7XFxuICAgICAgICAgICAgdGhpcy5wYWdlRGlzcGxheShhcHBfc3RhcnRfcGFnZSk7XFxuICAgICAgICB9LFxcbiAgICAgICAgLyoqXFxuICAgICAgICAgKiBjdXJyZW50ID0gcGFnZSB0aGF0IGlzIGN1cnJlbnRseSBkaXNwbGF5ZWRcXG4gICAgICAgICAqIG1vdmVfdG8gY2FuIGJlIGluZGV4LCBmaXJzdCwgbGFzdCwgbmV4dCwgcHJldmlvdXMgb3IgYSBudW1iZXJcXG4gICAgICAgICAqIEBwYXJhbSB7dHlwZX0gcGFnZVxcbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBzd2lwZVxcbiAgICAgICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cXG4gICAgICAgICAqL1xcbiAgICAgICAgcGFnZURpc3BsYXk6IGZ1bmN0aW9uIHBhZ2VEaXNwbGF5KG1vdmVfdG8sIHN3aXBlKSB7XFxuICAgICAgICAgICAgdmFyIGZpbGVuYW1lID0gXFxcIlxcXCI7XFxuICAgICAgICAgICAgc3dpdGNoIChtb3ZlX3RvKSB7XFxuICAgICAgICAgICAgICAgIGNhc2UgXFxcImZpcnN0XFxcIjpcXG4gICAgICAgICAgICAgICAgICAgIC8vMDAwIGlzIEFMV0FZUyB0aGUgZmlyc3QgcGFnZSwgaXQgaXMgdGhlIGNvbnRlbnQgb2YgaW5kZXguaHRtbCBhbmQgd2UgZG8gbm90IGFsbG93IHRoZSB1c2VyIHRvIG1vdmUgb3IgZGVsZXRlIHRoZSBpbmRleC5odG1sIHBhZ2VcXG4gICAgICAgICAgICAgICAgICAgIGZpbGVuYW1lID0gXFxcIjAwMC5odG1sXFxcIjtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudF9wYWdlX2luZGV4ID0gMDtcXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICAgICAgICBjYXNlIFxcXCJsYXN0XFxcIjpcXG4gICAgICAgICAgICAgICAgICAgIGZpbGVuYW1lID0gKFxcXCIwMDBcXFwiICsgdGhpcy5wYWdlX2xpc3RbdGhpcy5wYWdlX2xpc3QubGVuZ3RoIC0gMV0pLnNsaWNlKC0zKSArIFxcXCIuaHRtbFxcXCI7XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRfcGFnZV9pbmRleCA9IHRoaXMucGFnZV9saXN0Lmxlbmd0aCAtIDE7XFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgICAgICAgICAgY2FzZSBcXFwibmV4dFxcXCI6XFxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50X3BhZ2VfaW5kZXggPj0gdGhpcy5wYWdlX2xpc3QubGVuZ3RoIC0gMSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudF9wYWdlX2luZGV4ID0gdGhpcy5wYWdlX2xpc3QubGVuZ3RoIC0gMTtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50X3BhZ2VfaW5kZXg7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRfcGFnZV9pbmRleCsrO1xcbiAgICAgICAgICAgICAgICAgICAgZmlsZW5hbWUgPSAoXFxcIjAwMFxcXCIgKyB0aGlzLnBhZ2VfbGlzdFt0aGlzLmN1cnJlbnRfcGFnZV9pbmRleF0pLnNsaWNlKC0zKSArIFxcXCIuaHRtbFxcXCI7XFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgICAgICAgICAgY2FzZSBcXFwicHJldmlvdXNcXFwiOlxcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudF9wYWdlX2luZGV4IDwgMSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudF9wYWdlX2luZGV4ID0gMDtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50X3BhZ2VfaW5kZXg7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRfcGFnZV9pbmRleC0tO1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudF9wYWdlX2luZGV4IDwgMCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudF9wYWdlX2luZGV4ID0gMDtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIGZpbGVuYW1lID0gKFxcXCIwMDBcXFwiICsgdGhpcy5wYWdlX2xpc3RbdGhpcy5jdXJyZW50X3BhZ2VfaW5kZXhdKS5zbGljZSgtMykgKyBcXFwiLmh0bWxcXFwiO1xcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICAgICAgICAgIC8vcGFnZXMgYXJlIGFsd2F5cyBzYXZlZCBhcyBubm4uaHRtbCwgaS5lLiAwMDEuaHRtbCwgYW5kIHNvIG9uLCBzbyBuZWVkIHRvIGZvcm1hdCB0aGUgbnVtYmVyXFxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XFxuICAgICAgICAgICAgICAgICAgICB2YXIgcGcgPSBwYXJzZUludChtb3ZlX3RvKTtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc05hTihwZykpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50X3BhZ2VfaW5kZXg7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICBpZiAobW92ZV90byA8IDAgfHwgbW92ZV90byA+IHRoaXMubWF4X3BhZ2VzKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudF9wYWdlX2luZGV4O1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50X3BhZ2VfaW5kZXggPSB0aGlzLnBhZ2VfbGlzdC5pbmRleE9mKHBnKTtcXG4gICAgICAgICAgICAgICAgICAgIGZpbGVuYW1lID0gKFxcXCIwMDBcXFwiICsgbW92ZV90bykuc2xpY2UoLTMpICsgXFxcIi5odG1sXFxcIjtcXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAvL2hhdmUgY2FsY3VsYXRlZCB0aGUgZmlsZSBuYW1lLCBub3cgd2UgbmVlZCB0byB0cnkgdG8gbG9hZCBpdFxcbiAgICAgICAgICAgIC8vQWRkcyBhIGRpZmZlcmVucyBiZXR3ZWVuIHN3aXBlIGFuZCBjbGlja1xcbiAgICAgICAgICAgIGlmIChzd2lwZSkge1xcbiAgICAgICAgICAgICAgICAkLm1vYmlsZS5wYWdlQ29udGFpbmVyLnBhZ2Vjb250YWluZXIoXFxcImNoYW5nZVxcXCIsIGZpbGVuYW1lLCB7IHRyYW5zaXRpb246IFxcXCJzbGlkZVxcXCIgfSk7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgJC5tb2JpbGUucGFnZUNvbnRhaW5lci5wYWdlY29udGFpbmVyKFxcXCJjaGFuZ2VcXFwiLCBmaWxlbmFtZSwgeyB0cmFuc2l0aW9uOiBcXFwiZmxpcFxcXCIgfSk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRfcGFnZV9pbmRleDtcXG4gICAgICAgIH1cXG5cXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIG9iamVjdCBmb3IgZGlzcGxheSBmdW5jdGlvbmFsaXR5LCBwcmltYXJpbHkgZm9yIHJlc2l6aW5nIGNvbXBvbmVudHNcXG4gICAgICovXFxuICAgIGRpc3BsYXk6IHtcXG5cXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogR29lcyB0aHJvdWdoIHRoZSBjb21wb25lbnRzIG9uIGEgcGFnZSBhbmQgY2FsbHMgdGhlIG9uUGFnZUxvYWQgZnVuY3Rpb24gKGlmIGl0IGV4aXN0cylcXG4gICAgICAgICAqIFRoaXMgaXMgZm9yIGNvbXBvbmVudHMgdGhhdCBkb2VzIG5vdCByZXF1aXJlIHRoZSBsYXlvdXQgb2YgdGhlIHBhZ2UgdG8gYmUgZG9uZVxcbiAgICAgICAgICogSXQgaXMgY2FsbGVkIGZyb20ganF1ZXJ5IG1vYmlsZSdzIHBhZ2VjcmVhdGVcXG4gICAgICAgICAqIEBwYXJhbSB7dHlwZX0gZVxcbiAgICAgICAgICogQHBhcmFtIHt0eXBlfSB1aVxcbiAgICAgICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cXG4gICAgICAgICAqL1xcbiAgICAgICAgcHJlcGFyZVJlZ3VsYXJDb21wb25lbnRzOiBmdW5jdGlvbiBwcmVwYXJlUmVndWxhckNvbXBvbmVudHMoZSkge1xcbiAgICAgICAgICAgIC8qIHRpbWVzdGFtcCAmIHVpIG9iamVjdCAqL1xcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGUudHlwZSArIFxcXCIgXFxcIiArIERhdGUoZS50aW1lU3RhbXApKTtcXG4gICAgICAgICAgICB2YXIgY29tcG9uZW50cyA9ICQoJ1tkYXRhLW1sYWItdHlwZV06bm90KFtkYXRhLW1sYWItZGlzcGxheWRlcGVuZGVudD1cXFwidHJ1ZVxcXCJdKScpO1xcblxcbiAgICAgICAgICAgIGNvbXBvbmVudHMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgIHZhciBjb21wX2lkID0gJCh0aGlzKS5kYXRhKFxcXCJtbGFiLXR5cGVcXFwiKTtcXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtbGFiLmFwaS5jb21wb25lbnRzW2NvbXBfaWRdICE9IFxcXCJ1bmRlZmluZWRcXFwiICYmIHR5cGVvZiBtbGFiLmFwaS5jb21wb25lbnRzW2NvbXBfaWRdLm9uUGFnZUxvYWQgIT0gXFxcInVuZGVmaW5lZFxcXCIpIHtcXG4gICAgICAgICAgICAgICAgICAgIG1sYWIuYXBpLmNvbXBvbmVudHNbY29tcF9pZF0ub25QYWdlTG9hZCgkKHRoaXMpLCBtbGFiLmFwaS5nZXRBbGxWYXJpYWJsZXMoJCh0aGlzKSkpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9LFxcblxcbiAgICAgICAgLyoqXFxuICAgICAgICAgKiBHb2VzIHRocm91Z2ggdGhlIGNvbXBvbmVudHMgb24gYSBwYWdlIGFuZCBjYWxscyB0aGUgb25QYWdlTG9hZCBmdW5jdGlvbiAoaWYgaXQgZXhpc3RzKVxcbiAgICAgICAgICogVGhpcyBpcyBmb3IgY29tcG9uZW50cyB0aGF0IGRvZXMgbm90IHJlcXVpcmUgdGhlIGxheW91dCBvZiB0aGUgcGFnZSB0byBiZSBkb25lXFxuICAgICAgICAgKiBJdCBpcyBjYWxsZWQgZnJvbSBqcXVlcnkgbW9iaWxlJ3MgcGFnZWNyZWF0ZVxcbiAgICAgICAgICogQHBhcmFtIHt0eXBlfSBlXFxuICAgICAgICAgKiBAcGFyYW0ge3R5cGV9IHVpXFxuICAgICAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxcbiAgICAgICAgICovXFxuICAgICAgICBwcmVwYXJlRGlzcGxheURlcGVuZGVudENvbXBvbmVudHM6IGZ1bmN0aW9uIHByZXBhcmVEaXNwbGF5RGVwZW5kZW50Q29tcG9uZW50cyhlLCB1aSkge1xcbiAgICAgICAgICAgIC8qIHRpbWVzdGFtcCAmIHVpIG9iamVjdCAqL1xcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGUudHlwZSArIFxcXCIgXFxcIiArIERhdGUoZS50aW1lU3RhbXApKTtcXG4gICAgICAgICAgICBjb25zb2xlLmxvZyh1aSk7XFxuICAgICAgICAgICAgdmFyIGNvbXBvbmVudHMgPSAkKCdbZGF0YS1tbGFiLXR5cGVdW2RhdGEtbWxhYi1kaXNwbGF5ZGVwZW5kZW50PVxcXCJ0cnVlXFxcIl0nKTtcXG5cXG4gICAgICAgICAgICBjb21wb25lbnRzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICB2YXIgY29tcF9pZCA9ICQodGhpcykuZGF0YShcXFwibWxhYi10eXBlXFxcIik7XFxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWxhYi5hcGkuY29tcG9uZW50c1tjb21wX2lkXSAhPSBcXFwidW5kZWZpbmVkXFxcIiAmJiB0eXBlb2YgbWxhYi5hcGkuY29tcG9uZW50c1tjb21wX2lkXS5vblBhZ2VMb2FkICE9IFxcXCJ1bmRlZmluZWRcXFwiKSB7XFxuICAgICAgICAgICAgICAgICAgICBtbGFiLmFwaS5jb21wb25lbnRzW2NvbXBfaWRdLm9uUGFnZUxvYWQoJCh0aGlzKSwgbWxhYi5hcGkuZ2V0QWxsVmFyaWFibGVzKCQodGhpcykpKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgfSxcXG5cXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogVXBkYXRlcyBlaXRoZXIgYSBzaW5nbGUgY29tcG9uZW50LCBvciBhbGwgY29tcG9uZW50cyBvbiBhIHBhZ2UsIHVzaW5nIGRhdGEgYXR0cmlidXRlcyB0byBkZXRlcm1pbmUgdGhlIGRpc3BsYXlcXG4gICAgICAgICAqIEBwYXJhbSB7dHlwZX0gZWw6IE9wdGlvbmFsLCB0aGUgZWxlbWVudCB0byBkaXNwbGF5LiBJZiBub3Qgc3BlY2lmaWVkLCB0aGVuIHVwZGF0ZSBhbGwgY29tcG9uZW50c1xcbiAgICAgICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cXG4gICAgICAgICAqL1xcbiAgICAgICAgdXBkYXRlRGlzcGxheTogZnVuY3Rpb24gdXBkYXRlRGlzcGxheShlbCkge1xcbiAgICAgICAgICAgIHZhciBjb21wb25lbnRzID0gdHlwZW9mIGVsID09IFxcXCJ1bmRlZmluZWRcXFwiID8gJCgnW2RhdGEtbWxhYi1zaXplXVtkYXRhLW1sYWItYXNwZWN0cmF0aW9dJykgOiAkKGVsKTtcXG5cXG4gICAgICAgICAgICBjb21wb25lbnRzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50X3dpZHRoID0gJCh0aGlzKS5wYXJlbnRzKCdbcm9sZT1cXFwibWFpblxcXCJdJykuZmlyc3QoKS53aWR0aCgpO1xcbiAgICAgICAgICAgICAgICB2YXIgYXNwZWN0X3JhdGlvID0gJCh0aGlzKS5hdHRyKFxcXCJkYXRhLW1sYWItYXNwZWN0cmF0aW9cXFwiKS5zcGxpdChcXFwiOlxcXCIpO1xcbiAgICAgICAgICAgICAgICB2YXIgc2l6ZSA9ICQodGhpcykuYXR0cihcXFwiZGF0YS1tbGFiLXNpemVcXFwiKTtcXG4gICAgICAgICAgICAgICAgdmFyIHRpbWVzID0gc2l6ZSA9PSBcXFwic21hbGxcXFwiID8gMC4zMyA6IHNpemUgPT0gXFxcIm1lZGl1bVxcXCIgPyAwLjY3IDogMTtcXG5cXG4gICAgICAgICAgICAgICAgdmFyIHcgPSBwYXJlbnRfd2lkdGggKiB0aW1lcztcXG4gICAgICAgICAgICAgICAgdmFyIGggPSB3IC8gYXNwZWN0X3JhdGlvWzBdICogYXNwZWN0X3JhdGlvWzFdO1xcbiAgICAgICAgICAgICAgICAkKHRoaXMpLmNzcyh7IFxcXCJ3aWR0aFxcXCI6IHcgKyBcXFwicHhcXFwiLCBcXFwiaGVpZ2h0XFxcIjogaCArIFxcXCJweFxcXCIgfSk7XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuXFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBPYmplY3QgdXNlZCBmb3IgY2hhbmdpbmcgc2V0dGluZ3MgYXQgcnVudGltZVxcbiAgICAgKi9cXG4gICAgc2V0dGluZ3M6IHtcXG5cXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogVGhpcyBmdW5jdGlvbiB0b2dnbGVzIHRoZSB0ZXh0IHNpemUgb2YgYW4gaHRtbCBlbGVtZW50IGJldHdlZW4gMTAwJSBhbmQgMTMwJVxcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGVsZW1lbnRJZCBUaGUgaWQgb2YgdGhlIEhUTUwgZWxlbWVudCB3aGVyZSB0aGUgdGV4dCBzaXplIHdpbGwgYmUgdG9nZ2xlZFxcbiAgICAgICAgICovXFxuICAgICAgICBwYWdlVGV4dFNpemVUb2dnbGU6IGZ1bmN0aW9uIHBhZ2VUZXh0U2l6ZVRvZ2dsZShlbGVtZW50Q2xhc3MpIHtcXG4gICAgICAgICAgICAvL1RPRE86IEJ5dHRlIHRpbCAudG9nZ2xlKCkgb2cgZWdlbnRsaWcgbGFnZSBub2VuIGdlbmVyaXNrZSB0b2dnbGVDbGFzc0Jhc2VkT25JRCBvZyB0b2dnbGVDbGFzc0Jhc2VkT25DbGFzc1xcbiAgICAgICAgICAgIGlmICgkKFxcXCIuXFxcIiArIGVsZW1lbnRDbGFzcykuaGFzQ2xhc3MoJ21sYWJfbGFyZ2VfdGV4dCcpKSB7XFxuICAgICAgICAgICAgICAgICQoXFxcIi5cXFwiICsgZWxlbWVudENsYXNzKS5yZW1vdmVDbGFzcygnbWxhYl9sYXJnZV90ZXh0Jyk7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgJChcXFwiLlxcXCIgKyBlbGVtZW50Q2xhc3MpLmFkZENsYXNzKCdtbGFiX2xhcmdlX3RleHQnKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LFxcblxcbiAgICAgICAgLyoqXFxuICAgICAgICAqIFRoaXMgZnVuY3Rpb24gdG9nZ2xlcyB0aGUgdGV4dCBhbmQgYmFja2dyb3VuZCBjb2xvciBvZiBhbiBodG1sIGVsZW1lbnRcXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBlbGVtZW50SWRCYWNrZ3JvdW5kQ29sb3IgVGhlIGlkIG9mIHRoZSBIVE1MIGVsZW1lbnQgd2hlcmUgdGhlIGNvbG9yIG9mIHRoZSBiYWNrZ3JvdW5kIHdpbGwgYmUgdG9nZ2xlZFxcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGVsZW1lbnRDbGFzc1RleHRDb2xvciAgVGhlIGNsYXNzIG9mIHRoZSBIVE1MIGVsZW1lbnQvcyB3aGVyZSB0aGUgY29sb3Igb2YgdGhlIHRleHQgd2lsbCBiZSB0b2dnbGVkXFxuICAgICAgICAqL1xcbiAgICAgICAgcGFnZUNvbG9yVG9nZ2xlOiBmdW5jdGlvbiBwYWdlQ29sb3JUb2dnbGUoZWxlbWVudElkQmFja2dyb3VuZENvbG9yLCBlbGVtZW50Q2xhc3NUZXh0Q29sb3IpIHtcXG5cXG4gICAgICAgICAgICAvL1RPRE86IEJ5dHRlIHRpbCAudG9nZ2xlKCkgb2cgZWdlbnRsaWcgbGFnZSBub2VuIGdlbmVyaXNrZSB0b2dnbGVDbGFzc0Jhc2VkT25JRCBvZyB0b2dnbGVDbGFzc0Jhc2VkT25DbGFzc1xcbiAgICAgICAgICAgIGlmICgkKFxcXCIjXFxcIiArIGVsZW1lbnRJZEJhY2tncm91bmRDb2xvcikuaGFzQ2xhc3MoJ21sYWJfY29sb3JfdG9nZ2xlJykpIHtcXG4gICAgICAgICAgICAgICAgJChcXFwiI1xcXCIgKyBlbGVtZW50SWRCYWNrZ3JvdW5kQ29sb3IpLnJlbW92ZUNsYXNzKCdtbGFiX2NvbG9yX3RvZ2dsZScpO1xcbiAgICAgICAgICAgICAgICAkKFxcXCIuXFxcIiArIGVsZW1lbnRDbGFzc1RleHRDb2xvcikucmVtb3ZlQ2xhc3MoJ21sYWJfY29sb3InKTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAkKFxcXCIjXFxcIiArIGVsZW1lbnRJZEJhY2tncm91bmRDb2xvcikuYWRkQ2xhc3MoJ21sYWJfY29sb3JfdG9nZ2xlJyk7XFxuICAgICAgICAgICAgICAgICQoXFxcIi5cXFwiICsgZWxlbWVudENsYXNzVGV4dENvbG9yKS5hZGRDbGFzcygnbWxhYl9jb2xvcicpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgfVxcbn07IC8vIGVuZCBwcm90b3R5cGUgZm9yIE1sYWIuYXBpXFxuXFxuLyogXFxuICogTWxhYiBvYmplY3QgaXMgc3RvcmVkIGluIGEgZ2xvYmFsIHZhcmlhYmxlIFxcXCJtbGFiXFxcIiwgYW5kIGlzIGluaXRpYWxpemVkIGF1dG9tYXRpY2FsbHkgd2hlbiBkZXZpY2UgaXMgcmVhZHkuXFxuICovXFxuaWYgKHR5cGVvZiBtbGFiID09IFxcXCJ1bmRlZmluZWRcXFwiKSB7XFxuICAgIG1sYWIgPSB7IFxcXCJhcGlcXFwiOiBudWxsIH07XFxufVxcblxcbi8qKlxcbiAqIEZ1bmN0aW9uIGNhbGxlZCB3aGVuIGRvY3VtZW50IGlzIHJlYWR5LCBwcmVwYXJlcyB0aGUgalF1ZXJ5IG1vYmlsZSBjYWxsYmFja3MsIGluaXRpYWxpc2VzIGRpYXBsc3kgYW5kIGRhdGFiYXNlIGZ1bmN0aW9uc1xcbiAqL1xcbiQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uICgpIHtcXG5cXG4gICAgY29uc29sZS5sb2coXFxcIkVWRU5UOiByZWFkeVxcXCIpO1xcblxcbiAgICBpZiAoJChcXFwiYm9keVxcXCIpLmF0dHIoXFxcImlkXFxcIikgIT0gXFxcIm1sYWJfZWRpdG9yXFxcIikge1xcbiAgICAgICAgY29uc29sZS5sb2coXFxcIlNUQVRFOiBtb2JpbGUgbW9kZSwgaW5pdCBvd24gb2JqZWN0XFxcIik7XFxuXFxuICAgICAgICBtbGFiLmFwaSA9IG5ldyBNbGFiX2FwaSgpO1xcblxcbiAgICAgICAgLy9wYWdlIGNyZWF0ZSBmb3IgbWFpbiBwYWdlICh0aGF0IHdpbGwgY29udGFpbiBvdGhlciBwYWdlcykgb25seSBmb3IgaW5kZXggcGFnZVxcbiAgICAgICAgJChkb2N1bWVudCkub24oXFxcInBhZ2VjcmVhdGVcXFwiLCBcXFwiI2luZGV4XFxcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XFxuICAgICAgICAgICAgY29uc29sZS5sb2coXFxcIkVWRU5UOiBwYWdlY3JlYXRlLWluZGV4XFxcIik7XFxuICAgICAgICB9KTtcXG5cXG4gICAgICAgIC8vZ2VuZXJhbCBwYWdlY3JlYXRlLCBydW4gY29tcG9uZW50IGNvZGUgZm9yIGNvbXBvbmVudHMgdGhhdCBkbyBub3QgY2FyZSBhYm91dCBkaXNwbGF5XFxuICAgICAgICAkKGRvY3VtZW50KS5vbihcXFwicGFnZWNyZWF0ZVxcXCIsIGZ1bmN0aW9uIChldmVudCkge1xcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFxcXCJFVkVOVDogcGFnZWNyZWF0ZS1nZW5lcmFsXFxcIik7XFxuICAgICAgICAgICAgbWxhYi5hcGkuZGlzcGxheS5wcmVwYXJlUmVndWxhckNvbXBvbmVudHMoZXZlbnQpO1xcbiAgICAgICAgICAgIC8vU3dpcGVcXG4gICAgICAgICAgICAkKCdkaXYudWktcGFnZScpLm9uKFxcXCJzd2lwZXJpZ2h0XFxcIiwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICBtbGFiLmFwaS5uYXZpZ2F0aW9uLnBhZ2VEaXNwbGF5KFxcXCJwcmV2aW91c1xcXCIsIHRydWUpO2NvbnNvbGUubG9nKFxcXCJyaWdodCBzd2lwZVxcXCIpO1xcbiAgICAgICAgICAgIH0pLm9uKFxcXCJzd2lwZWxlZnRcXFwiLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgIG1sYWIuYXBpLm5hdmlnYXRpb24ucGFnZURpc3BsYXkoXFxcIm5leHRcXFwiLCB0cnVlKTtjb25zb2xlLmxvZyhcXFwibGVmdCBzd2lwZVxcXCIpO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgfSk7XFxuXFxuICAgICAgICAvL2dlbmVyYWwgcGFnZWNvbnRhaW5lcmJlZm9yZXNob3csIHJ1biBjb21wb25lbnQgY29kZSBmb3IgY29tcG9uZW50cyB0aGF0IHJlcXVpcmUgc2l6ZSBpbmZvcm1hdGlvbiwgaWUuIGRpc3BsYXkgaXMgZG9uZVxcbiAgICAgICAgJChkb2N1bWVudCkub24oXFxcInBhZ2Vjb250YWluZXJzaG93XFxcIiwgZnVuY3Rpb24gKGV2ZW50LCB1aSkge1xcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFxcXCJFVkVOVDogcGFnZWNvbnRhaW5lcnNob3dcXFwiKTtcXG4gICAgICAgICAgICBtbGFiLmFwaS5kaXNwbGF5LnByZXBhcmVEaXNwbGF5RGVwZW5kZW50Q29tcG9uZW50cyhldmVudCwgdWkpO1xcbiAgICAgICAgICAgIG1sYWIuYXBpLmRpc3BsYXkudXBkYXRlRGlzcGxheSgpO1xcbiAgICAgICAgfSk7XFxuXFxuICAgICAgICAvL3doZW4gdGhlIG9yaWVudGF0aW9uIGNoYW5nZXMgd2UgbXVzdCByZWRyYXcgdGhlIGtvbXBvbmVudHMgdGhhdCByZXF1aXJlIHNwZWNpZmljIHJlc2l6aW5nXFxuICAgICAgICAkKHdpbmRvdykub24oXFxcIm9yaWVudGF0aW9uY2hhbmdlXFxcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XFxuICAgICAgICAgICAgY29uc29sZS5sb2coXFxcIkVWRU5UOiBvcmllbnRhdGlvbmNoYW5nZVxcXCIpO1xcbiAgICAgICAgICAgIG1sYWIuYXBpLmRpc3BsYXkudXBkYXRlRGlzcGxheSgpO1xcbiAgICAgICAgfSk7XFxuXFxuICAgICAgICAvL3VzZWQgdG8gY2FsbCBhcHAgc3BlY2lmaWMgaW5pdGlhbGlzYXRpb24gcm91dGluZVxcbiAgICAgICAgJChkb2N1bWVudCkub24oXFxcIm1sYWJyZWFkeVxcXCIsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcXFwibWxhYnJlYWR5XFxcIik7XFxuICAgICAgICAgICAgaWYgKHR5cGVvZiBtbGFiSW5pdGlhbGlzZUFwcCAhPSBcXFwidW5kZWZpbmVkXFxcIikge1xcbiAgICAgICAgICAgICAgICBtbGFiSW5pdGlhbGlzZUFwcCgpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICB9XFxufSk7XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yYXctbG9hZGVyIS4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWI/P3JlZi0tMC0wIS4vYXNzZXRzL2pzL21sYWIuYXBpLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9yYXctbG9hZGVyL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMC0wIS4vYXNzZXRzL2pzL21sYWIuYXBpLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCJ2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXFxcInN5bWJvbFxcXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXFxcInN5bWJvbFxcXCIgOiB0eXBlb2Ygb2JqOyB9O1xcblxcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXFxyXFxuQGNvcHlyaWdodCBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNiwgTm9yd2VnaWFuIERlZmVuY2UgUmVzZWFyY2ggRXN0YWJsaXNobWVudCAoRkZJKSAtIEFsbCBSaWdodHMgUmVzZXJ2ZWRcXHJcXG5AbGljZW5zZSBQcm9wcmlldGFyeSBhbmQgY29uZmlkZW50aWFsXFxyXFxuQGF1dGhvciBBcmlsZCBCZXJnaC9TaW5ldHQgMy4wIHByb2dyYW1tZSAoZmlyc3RuYW1lLmxhc3RuYW1lQGZmaS5ubykgcmV3cml0ZS9pbXBsZW1lbnRhdGlvbiBvZiBhbGwgZnVuY3Rpb25hbGl0eVxcclxcbkBhdXRob3IgQ2VjaWxpZSBKYWNrYm8gR3Jhbi9TaW5ldHQgMy4wIHByb2dyYW1tZSAoZmlyc3RuYW1lLm1pZGRsZW5hbWUubGFzdG5hbWVAZmZpLm5vKSBhZGRpdGlvbmFsIGZ1bmN0aW9uYWxpdHlcXHJcXG5cXHJcXG5VbmF1dGhvcml6ZWQgY29weWluZyBvZiB0aGlzIGZpbGUsIHZpYSBhbnkgbWVkaXVtIGlzIHN0cmljdGx5IHByb2hpYml0ZWQgXFxyXFxuXFxyXFxuRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VfTUxBQiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cXHJcXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcblxcbi8qKlxcclxcbiAqIEBhYnN0cmFjdCBBUEkgZnVuY3Rpb25zIGZvciB1c2UgYnkgY29tcG9uZW50cyBhdCBkZXNpZ24gdGltZSAoaS5lLiBpbiB0aGUgTUxBQiBlZGl0b3IpLlxcclxcbiAqIEBhYnN0cmFjdCBVc2VkIHRvIG9idGFpbiBpbmZvIHN1Y2ggYXMgcGF0aHMsIHRvIGRpc3BsYXkgdXNlciBpbnB1dCByZXF1ZXN0cyBvciB0byBzdG9yZSBkYXRhLCBldGMuXFxyXFxuICogQHJldHVybnMge01sYWJfZHRfYXBpfVxcclxcbiAqIEBjb25zdHJ1Y3RvclxcclxcbiAqL1xcbmZ1bmN0aW9uIE1sYWJfZHRfYXBpKCkge1xcbiAgICB0aGlzLnN0b3JhZ2UgPSBuZXcgT2JqZWN0KCk7XFxuICAgIHRoaXMudmVyc2lvbiA9IDAuOTtcXG4gICAgdGhpcy5wcm9wZXJ0aWVzX3Rvb2x0aXAgPSBmYWxzZTtcXG59O1xcblxcbi8qKlxcclxcbiAqIEluaXRpYWxpc2UgdGhlIGRpZmZlcmVudCBmdW5jdGlvbnMuXFxyXFxuICogQHR5cGUgdHlwZVxcclxcbiAqL1xcbk1sYWJfZHRfYXBpLnByb3RvdHlwZSA9IHtcXG5cXG4gICAgLypcXHJcXG4gICAgICogU3ltZm9ueSBhbGxvd3MgdXMgdG8gcmVkZmluZSBVUkxzIGF0IGFueSB0aW1lIHVzaW5nIHRoZSByb3V0ZSBmdW5jdGlvbmFsaXR5LCBzbyB3ZSBzaG91bGQgYXZvaWQgZml4ZWQgVVJMcy5cXHJcXG4gICAgICogVGhleSBhcmUgdGhlcmVmb3IgYWx3YXlzIHN0b3JlZCBpbiB2YXJpYWJsZXMgcGlja2VkIHVwIGZyb20gdGhlIHNlcnZlciwgdXNpbmcgYW4gQUpBWCBjYWxsIHRvIHRoZSBsb2FkX3ZhcmlhYmxlIFVSTC5cXHJcXG4gICAgICogQmVsb3cgYXJlIHdyYXBwZXIgZnVuY3Rpb25zIHRvIG9idGFpbiB0aGVtIGZyb20gdGhlIGludGVybmFsIHZhcmlhYmxlcy5cXHJcXG4gICAgICovXFxuXFxuICAgIC8qKlxcclxcbiAgICAgKiBSZXF1ZXN0cyBmb3IgdGhlIGFic29sdXRlIFVSTCB0byB3aGVyZSBhcHBzIGFyZSBzdG9yZWQsIHdlIHdvcmsgd3RoIHRoZSAvd3d3b3JrIGRpcmVjdG9yeSBpbnNpZGUgaGVyZS5cXHJcXG4gICAgICogVXNlZCB0byBsb2FkIHBhZ2VzIGluIGFuIGFwcCwgYW5kIHJlbGF0ZWQgQ1NTL0pTL21lZGlhIGZpbGVzLlxcclxcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nLm9yaWdpbnxMb2NhdGlvbi5vcmlnaW58TWxhYl9kdF9hcGkucGFyZW50LmNvbmZpZy51cmxzLmFwcH1cXHJcXG4gICAgICovXFxuICAgIGdldFVybEFwcEFic29sdXRlOiBmdW5jdGlvbiBnZXRVcmxBcHBBYnNvbHV0ZSgpIHtcXG4gICAgICAgIHJldHVybiB3aW5kb3cubG9jYXRpb24ub3JpZ2luICsgdGhpcy5wYXJlbnQuY29uZmlnLnVybHMuYXBwO1xcbiAgICB9LFxcblxcbiAgICAvKipcXHJcXG4gICAgICogUmVxdWVzdHMgZm9yIHRoZSByZWxhdGl2ZSBVUkwgdG8gd2hlcmUgYXBwcyBhcmUgc3RvcmVkLCB3ZSB3b3JrIHd0aCB0aGUgL3d3d29yayBkaXJlY3RvcnkgaW5zaWRlIGhlcmVcXHJcXG4gICAgICogVXNlZCB0byBsb2FkIHBhZ2VzIGluIGFuIGFwcCwgYW5kIHJlbGF0ZWQgQ1NTL0pTL21lZGlhIGZpbGVzXFxyXFxuICAgICAqIEByZXR1cm5zIHtNbGFiX2R0X2FwaS5wYXJlbnQuY29uZmlnLnVybHMuYXBwfVxcclxcbiAgICAgKi9cXG4gICAgZ2V0VXJsQXBwUmVsYXRpdmU6IGZ1bmN0aW9uIGdldFVybEFwcFJlbGF0aXZlKCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmNvbmZpZy51cmxzLmFwcDtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxyXFxuICAgICAqIFJlcXVlc3RzIGZvciB0aGUgYWJzb2x1dGUgVVJMIHRvIHdoZXJlIGNvbXBvbmVudHMgYXJlIHN0b3JlZC5cXHJcXG4gICAgICogVXNlZCB0byBsb2FkIGNvbXBvbmVudHMgd2hlbiBkZXNpZ25pbmcgYW4gYXBwIChjb21wb25lbnRzIGNvbnNpc3Qgb2YgY29uZmlndXJhdGlvbiBmaWxlIGFuZCBKUyBjb2RlKVxcclxcbiAgICAgKiBhbmQgcmVsYXRlZCBDU1MvSlMvbWVkaWEgZmlsZXMuXFxyXFxuICAgICAqIEByZXR1cm5zIHtNbGFiX2R0X2FwaS5wYXJlbnQuY29uZmlnLnVybHMuY29tcG9uZW50fFN0cmluZy5vcmlnaW58TG9jYXRpb24ub3JpZ2lufVxcclxcbiAgICAgKi9cXG4gICAgZ2V0VXJsQ29tcG9uZW50QWJzb2x1dGU6IGZ1bmN0aW9uIGdldFVybENvbXBvbmVudEFic29sdXRlKCkge1xcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4gKyB0aGlzLnBhcmVudC5jb25maWcudXJscy5jb21wb25lbnQ7XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcclxcbiAgICAgKiBSZXF1ZXN0cyBmb3IgdGhlIHJlbGF0aXZlIFVSTCB0byB3aGVyZSBjb21wb25lbnRzIGFyZSBzdG9yZWQuXFxyXFxuICAgICAqIFVzZWQgdG8gbG9hZCBjb21wb25lbnRzIHdoZW4gZGVzaWduaW5nIGFuIGFwcCAoY29tcG9uZW50cyBjb25zaXN0IG9mIGNvbmZpZ3VyYXRpb24gZmlsZSBhbmQgSlMgY29kZSkuXFxyXFxuICAgICAqIGFuZCByZWxhdGVkIENTUy9KUy9tZWRpYSBmaWxlcy5cXHJcXG4gICAgICogQHJldHVybnMge01sYWJfZHRfYXBpLnBhcmVudC5jb25maWcudXJscy5jb21wb25lbnR9XFxyXFxuICAgICAqL1xcbiAgICBnZXRVcmxDb21wb25lbnRSZWxhdGl2ZTogZnVuY3Rpb24gZ2V0VXJsQ29tcG9uZW50UmVsYXRpdmUoKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQuY29uZmlnLnVybHMuY29tcG9uZW50O1xcbiAgICB9LFxcblxcbiAgICAvKipcXHJcXG4gICAgICogUmVxdWVzdHMgZm9yIHRoZSBhYnNvbHV0ZSBVUkwgdG8gd2hlcmUgdGVtcGxhdGVzIGFyZSBzdG9yZWQuXFxyXFxuICAgICAqIE5vdCByZWFsbHkgdXNlZCBtdWNoIGJ5IHRoZSBNTEFCIGVkaXRvciBmcm9udCBlbmQsIHRoZSBmaWxlcyBhcmUgdXN1YWxseSBjb3BpZWQgb24gdGhlIHNlcnZlci5cXHJcXG4gICAgICogSG93ZXZlciB3ZSBoYXZlIGl0IGhlcmUgZm9yIGNvbXBsZXRlbmVzcy5cXHJcXG4gICAgICogQHJldHVybnMge1N0cmluZy5vcmlnaW58TG9jYXRpb24ub3JpZ2lufE1sYWJfZHRfYXBpLnBhcmVudC5jb25maWcudXJscy50ZW1wbGF0ZX1cXHJcXG4gICAgICovXFxuICAgIGdldFVybFRlbXBsYXRlQWJzb2x1dGU6IGZ1bmN0aW9uIGdldFVybFRlbXBsYXRlQWJzb2x1dGUoKSB7XFxuICAgICAgICByZXR1cm4gd2luZG93LmxvY2F0aW9uLm9yaWdpbiArIHRoaXMucGFyZW50LmNvbmZpZy51cmxzLnRlbXBsYXRlO1xcbiAgICB9LFxcblxcbiAgICAvKipcXHJcXG4gICAgICogUmVxdWVzdHMgZm9yIHRoZSByZWxhdGl2ZSBVUkwgdG8gd2hlcmUgdGVtcGxhdGVzIGFyZSBzdG9yZWQuXFxyXFxuICAgICAqIE5vdCByZWFsbHkgdXNlZCBtdWNoIGJ5IHRoZSBNTEFCIGVkaXRvciBmcm9udCBlbmQsIHRoZSBmaWxlcyBhcmUgdXN1YWxseSBjb3BpZWQgb24gdGhlIHNlcnZlci5cXHJcXG4gICAgICogSG93ZXZlciB3ZSBoYXZlIGl0IGhlcmUgZm9yIGNvbXBsZXRlbmVzcy5cXHJcXG4gICAgICogQHJldHVybnMge01sYWJfZHRfYXBpLnBhcmVudC5jb25maWcudXJscy50ZW1wbGF0ZX1cXHJcXG4gICAgICovXFxuICAgIGdldFVybFRlbXBsYXRlUmVsYXRpdmU6IGZ1bmN0aW9uIGdldFVybFRlbXBsYXRlUmVsYXRpdmUoKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQuY29uZmlnLnVybHMudGVtcGxhdGU7XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcclxcbiAgICAgKiBSZXF1ZXN0cyBmb3IgdGhlIGFic29sdXRlIFVSTCB1c2VkIHRvIHVwbG9hZCBmaWxlcywgdXNlZCBieSBjb21wb25lbnRzIHRoYXQgbGV0IHVzZXJzIHVzZSBvd24gZmlsZXMsIFxcclxcbiAgICAgKiBzdWNoIGEgaW1hZ2UgY29tcG9uZW50LCB2aWRlbyBwbGF5ZXIsIGV0Yy5cXHJcXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbXBfaWQgaXMgdGhlIHVuaXF1ZSBJRCBvZiB0aGUgY29tcG9uZW50LCBmb3IgaW5zdGFuY2UgaW1nIG9yIHZpZGVvXFxyXFxuICAgICAqIEByZXR1cm5zIHtNbGFiX2R0X2FwaS5wcm90b3R5cGVAcHJvO3BhcmVudEBwcm87dXJsc0Bwcm87Y29tcG9uZW50X3VwbG9hZF9maWxlQGNhbGw7cmVwbGFjZUBjYWxsO3JlcGxhY2V8U3RyaW5nLm9yaWdpbnxMb2NhdGlvbi5vcmlnaW59XFxyXFxuICAgICAqL1xcbiAgICBnZXRVcmxVcGxvYWRBYnNvbHV0ZTogZnVuY3Rpb24gZ2V0VXJsVXBsb2FkQWJzb2x1dGUoY29tcF9pZCkge1xcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4gKyB0aGlzLnBhcmVudC51cmxzLmNvbXBvbmVudF91cGxvYWRfZmlsZS5yZXBsYWNlKFxcXCJfQVBQSURfXFxcIiwgdGhpcy5wYXJlbnQuYXBwLmlkKS5yZXBsYWNlKFxcXCJfQ09NUElEX1xcXCIsIGNvbXBfaWQpO1xcbiAgICB9LFxcblxcbiAgICAvKipcXHJcXG4gICAgICogUmVxdWVzdHMgZm9yIHRoZSBhYnNvbHV0ZSBVUkwgdXNlZCB0byB1cGxvYWQgZmlsZXMsIHVzZWQgYnkgY29tcG9uZW50cyB0aGF0IGxldCB1c2VycyB1c2Ugb3duIGZpbGVzLCBcXHJcXG4gICAgICogc3VjaCBhIGltYWdlIGNvbXBvbmVudCwgdmlkZW8gcGxheWVyLCBldGMuXFxyXFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb21wX2lkIGlzIHRoZSB1bmlxdWUgSUQgb2YgdGhlIGNvbXBvbmVudCwgZm9yIGluc3RhbmNlIGltZyBvciB2aWRlb1xcclxcbiAgICAgKiBAcmV0dXJucyB7TWxhYl9kdF9hcGkucHJvdG90eXBlQHBybztwYXJlbnRAcHJvO3VybHNAcHJvO2NvbXBvbmVudF91cGxvYWRfZmlsZUBjYWxsO3JlcGxhY2VAY2FsbDtyZXBsYWNlfVxcclxcbiAgICAgKi9cXG4gICAgZ2V0VXJsVXBsb2FkUmVsYXRpdmU6IGZ1bmN0aW9uIGdldFVybFVwbG9hZFJlbGF0aXZlKGNvbXBfaWQpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC51cmxzLmNvbXBvbmVudF91cGxvYWRfZmlsZS5yZXBsYWNlKFxcXCJfQVBQSURfXFxcIiwgdGhpcy5wYXJlbnQuYXBwLmlkKS5yZXBsYWNlKFxcXCJfRklMRVRZUEVTX1xcXCIsIGNvbXBfaWQpO1xcbiAgICB9LFxcblxcbiAgICAvKipcXHJcXG4gICAgICogVGhpcyB3aWxsIHJldHVybiBhIGxpc3QgaW4gSFRNTCBmb3JtYXQgb2YgYWxsIHRoZSBhdmFpbGFibGUgc3RvcmFnZSBwbHVnaW5zXFxyXFxuICAgICAqIEVhY2ggcGx1Z2luIHdpbGwgaGF2ZSBhbiBvbmNsaWNrIGV2ZW50XFxyXFxuICAgICAqIEBwYXJhbSB7Y29tcG9uZW50fSBqcXVlcnkgZWxlbWVudCwgdGhlIGN1cnJlbnQgc2VsZWN0ZWQgY29tcG9uZW50XFxyXFxuICAgICAqL1xcbiAgICBnZXRTdG9yYWdlUGx1Z2luTGlzdDogZnVuY3Rpb24gZ2V0U3RvcmFnZVBsdWdpbkxpc3QoY29tcG9uZW50KSB7XFxuICAgICAgICB2YXIgc3RvcmFnZV9wbHVnaW5fbGlzdCA9ICQoXFxcIjx1bD48L3VsPlxcXCIpO1xcbiAgICAgICAgdmFyIHNlbF9jbGFzcyA9IFxcXCJcXFwiO1xcbiAgICAgICAgdmFyIHNlbGVjdGVkX3BsdWdpbjtcXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcXG5cXG4gICAgICAgIC8vZmluZCBvdXQgaWYgdGhlIGNvbXBvbmVudCBoYXMgYSBjdXJyZW50bHkgc2VsZWN0ZWQgc3RvcmFnZSBwbHVnaW5cXG4gICAgICAgIHZhciBleGlzdGluZ19zdG9yYWdlX3BsdWdpbiA9IG1sYWIuZHQuYXBpLmdldFZhcmlhYmxlKGNvbXBvbmVudCwgXFxcInN0b3JhZ2VfcGx1Z2luXFxcIik7XFxuICAgICAgICBpZiAoZXhpc3Rpbmdfc3RvcmFnZV9wbHVnaW4gJiYgZXhpc3Rpbmdfc3RvcmFnZV9wbHVnaW4ubmFtZSkge1xcbiAgICAgICAgICAgIHNlbGVjdGVkX3BsdWdpbiA9IGV4aXN0aW5nX3N0b3JhZ2VfcGx1Z2luLm5hbWU7XFxuICAgICAgICB9XFxuICAgICAgICAvL2NvbXBvbmVudC5jb25mLnN0b3JhZ2VfcGx1Z2lucyBcXG4gICAgICAgIC8vSHZpcyB0cnVlIHPDpSBza2FsIGFsbGUgcGx1Z2dpbnMgbGFzdGVzIC0gZWxsZXJzIHNrYWwgZGUgc29tIGVyIGxpc3RldCBsYXN0ZXNcXG4gICAgICAgIGZvciAodHlwZSBpbiB0aGlzLnBhcmVudC5zdG9yYWdlX3BsdWdpbnMpIHtcXG4gICAgICAgICAgICBpZiAodHlwZSA9PSBzZWxlY3RlZF9wbHVnaW4pIHtcXG4gICAgICAgICAgICAgICAgc2VsX2NsYXNzID0gXFxcIiBjbGFzcz0nbWxhYl9pdGVtX2FwcGxpZWQnIGRhdGEtbWxhYi1zZWxlY3RlZC1zdG9yYWdlPSd0cnVlJyBcXFwiO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHNlbF9jbGFzcyA9IFxcXCJcXFwiO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBzdG9yYWdlX3BsdWdpbl9saXN0LmFwcGVuZChcXFwiPGxpIGRhdGEtbWxhYi1zdG9yYWdlLXBsdWdpbi10eXBlPSdcXFwiICsgdHlwZSArIFxcXCInIFxcXCIgKyBzZWxfY2xhc3MgKyBcXFwiIHRpdGxlPSdcXFwiICsgJCgnPGRpdi8+JykudGV4dCh0aGlzLnBhcmVudC5zdG9yYWdlX3BsdWdpbnNbdHlwZV0pLmh0bWwoKSArIFxcXCInPlxcXCJcXG4gICAgICAgICAgICAvL2JhcmUgdmlzZSBvbSBwbHVnaW5lbiB0cmVuZ2VyIGNyZWRlbnRpYWxzLi4uXFxuICAgICAgICAgICAgKyBcXFwiPGltZyBkYXRhLW1sYWItY29tcC10b29sPSdjcmVkZW50aWFscycgY2xhc3M9J21sYWJfdG9vbHMgbWxhYl90b29sc19zcGFjZScgc3JjPScvaW1nL3Rvb2xzL2NyZWRlbnRpYWxzLnBuZycgdGl0bGU9J3FxcSc+XFxcIiArIFxcXCI8c3Bhbj5cXFwiICsgdHlwZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHR5cGUuc2xpY2UoMSkgKyBcXFwiPC9zcGFuPlxcXCIgKyBcXFwiPC9saT5cXFwiKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHN0b3JhZ2VfcGx1Z2luX2xpc3QuZmluZChcXFwiaW1nXFxcIikub24oXFxcImNsaWNrXFxcIiwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIHZhciB0aGlzX3N0b3JhZ2VfcGx1Z2luX2lkID0gJCh0aGlzKS5wYXJlbnQoKS5kYXRhKFxcXCJtbGFiLXN0b3JhZ2UtcGx1Z2luLXR5cGVcXFwiKTtcXG4gICAgICAgICAgICB2YXIgZWwgPSAkKFxcXCJbZGF0YS1tbGFiLWdldC1pbmZvPSdzdG9yYWdlX3BsdWdpbnMnXSBbZGF0YS1tbGFiLXN0b3JhZ2UtcGx1Z2luLXR5cGU9J1xcXCIgKyB0aGlzX3N0b3JhZ2VfcGx1Z2luX2lkICsgXFxcIiddXFxcIik7XFxuICAgICAgICAgICAgdGhhdC5nZXRDcmVkZW50aWFscyhlbCwgdGhpc19zdG9yYWdlX3BsdWdpbl9pZCwgdGhhdC5wYXJlbnQuY29tcG9uZW50c1t0aGlzX3N0b3JhZ2VfcGx1Z2luX2lkXS5jb25mLmNyZWRlbnRpYWxzLCB0aGF0LnBhcmVudC5kZXNpZ24uc3RvcmFnZV9wbHVnaW5fc3RvcmVfY3JlZGVudGlhbHMsIHRydWUsIHsgc3RvcmFnZV9wbHVnaW5faWQ6IHRoaXNfc3RvcmFnZV9wbHVnaW5faWQsIGNvbXBvbmVudDogY29tcG9uZW50IH0pO1xcbiAgICAgICAgfSk7XFxuXFxuICAgICAgICBzdG9yYWdlX3BsdWdpbl9saXN0LmZpbmQoXFxcInNwYW5cXFwiKS5vbihcXFwiY2xpY2tcXFwiLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgbWxhYi5kdC5kZXNpZ24uc3RvcmFnZV9wbHVnaW5fc2V0dXAoJCh0aGlzKSwgJCh0aGlzKS5wYXJlbnQoKS5kYXRhKFxcXCJtbGFiLXN0b3JhZ2UtcGx1Z2luLXR5cGVcXFwiKSwgbWxhYi5kdC5hcGkuZ2V0U2VsZWN0ZWRDb21wb25lbnQoKSk7XFxuICAgICAgICB9KTtcXG5cXG4gICAgICAgIHJldHVybiBzdG9yYWdlX3BsdWdpbl9saXN0O1xcbiAgICB9LFxcbiAgICAvKipcXHJcXG4gICAgICogV3JhcHBlciBmdW5jdGlvbiB3aGljaCBjYWxscyB0aGUgYmFjayBlbmQgdG8gbG9hZCBjb21wb25lbnQgaGVscCwgXFxyXFxuICAgICAqIHRoZSBiYWNrZW5kIGNoZWNrcyBmb3IgbGFuZ3VhZ2Ugc2VsZWN0ZWQgYW5kIHNlZXMgaWYgdGhlcmUgYXJlIGxhbmd1YWdlIHNwZWNpZmljIGhlbHAgZmlsZSBhdmFpbGFibGUsIGlmIG5vdCB1c2UgZ2VuZXJpYyBvbmVcXHJcXG4gICAgICogQHBhcmFtIHt0eXBlfSBjb21wb25lbnQ6IGNvbXBvbmVudCBvYmplY3RcXHJcXG4gICAgICogQHBhcmFtIHt0eXBlfSB0aXRsZTogdGl0bGUgb2YgZGxnIGJveCwgc3RyaW5nXFxyXFxuICAgICAqIEBwYXJhbSB7dHlwZX0gb3duZXI6IEhUTUwgZWxlbWVudCB0aGF0IHdpbGwgb3duIHRoaXMgUXRpcFxcclxcbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxcclxcbiAgICAgKi9cXG5cXG4gICAgZGlzcGxheUV4dGVybmFsSGVscGZpbGU6IGZ1bmN0aW9uIGRpc3BsYXlFeHRlcm5hbEhlbHBmaWxlKGNvbXBvbmVudF9pZCwgdGl0bGUsIG93bmVyX2VsZW1lbnQsIHFUaXBDbGFzcykge1xcbiAgICAgICAgdmFyIHFUaXBDbGFzc2VzID0gJ3F0aXAtbGlnaHQgbWxhYl9kdF9ib3hfc3R5bGUgbWxhYl96aW5kZXhfdG9wX3Rvb2x0aXAnO1xcbiAgICAgICAgdmFyIHVybCA9IHRoaXMucGFyZW50LnVybHMuY29tcG9uZW50X2hlbHBmaWxlLnJlcGxhY2UoXFxcIl9DT01QSURfXFxcIiwgY29tcG9uZW50X2lkKTtcXG5cXG4gICAgICAgIGlmICh0eXBlb2YgcVRpcENsYXNzICE9PSBcXFwidW5kZWZpbmVkXFxcIikge1xcbiAgICAgICAgICAgIHFUaXBDbGFzc2VzID0gcVRpcENsYXNzZXMgKyBcXFwiIFxcXCIgKyBxVGlwQ2xhc3M7XFxuICAgICAgICB9XFxuICAgICAgICAkLmdldEpTT04odXJsLCBmdW5jdGlvbiAoZGF0YSkge1xcbiAgICAgICAgICAgIGlmIChkYXRhLnJlc3VsdCA9PT0gXFxcIlNVQ0NFU1NcXFwiKSB7XFxuICAgICAgICAgICAgICAgICQob3duZXJfZWxlbWVudCkucXRpcCh7XFxuICAgICAgICAgICAgICAgICAgICBzb2xvOiBmYWxzZSxcXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBkYXRhLmh0bWwsXFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbjogdHJ1ZVxcbiAgICAgICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB7IG15OiAndG9wUmlnaHQnLCBhdDogJ2JvdHRvbU1pZGRsZScsIHZpZXdwb3J0OiAkKHdpbmRvdyksIGVmZmVjdDogZmFsc2UgfSxcXG4gICAgICAgICAgICAgICAgICAgIHNob3c6IHsgcmVhZHk6IHRydWUsIG1vZGFsOiB7IG9uOiBmYWxzZSB9IH0sXFxuICAgICAgICAgICAgICAgICAgICBoaWRlOiBmYWxzZSxcXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7IGNsYXNzZXM6IHFUaXBDbGFzc2VzLCB0aXA6IHRydWUgfSxcXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50czogeyBoaWRlOiBmdW5jdGlvbiBoaWRlKGV2ZW50LCBhcGkpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBpLmRlc3Ryb3koKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB9IH1cXG4gICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgYWxlcnQoZGF0YS5tZXNzYWdlKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9KS5mYWlsKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBhbGVydChfdHJbXFxcIm1sYWIuZHQuZGVzaWduLmpzLmFsZXJ0LmhlbHAubm90Zm91bmRcXFwiXSk7XFxuICAgICAgICB9KTtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxyXFxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIGZpbGVzIGFscmVhZHkgdXBsb2FkZWQsIG5vbi1hc3luYyBzbyB3ZSBjYW4gcmV0dXJuIGRhdGEgdG8gdGhlIGNhbGxpbmcgZnVuY3Rpb24gd2hvIG1heSBkbyBhbnkgbnVtYmVyIG9mIHRoaW5ncyB3aXRoIGl0LlxcclxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXh0ZW5zaW9uc1xcclxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IGxpc3Qgb2Ygb3B0aW9ucyBmb3Igc2VsZWN0IGVsZW1lbnRcXHJcXG4gICAgICovXFxuICAgIGdldE1lZGlhOiBmdW5jdGlvbiBnZXRNZWRpYShmaWxlX3R5cGUpIHtcXG4gICAgICAgIHZhciBkYXRhID0gJC5hamF4KHtcXG4gICAgICAgICAgICB0eXBlOiBcXFwiR0VUXFxcIixcXG4gICAgICAgICAgICB1cmw6IHRoaXMucGFyZW50LnVybHMudXBsb2FkZWRfZmlsZXMucmVwbGFjZShcXFwiX0FQUElEX1xcXCIsIHRoaXMucGFyZW50LmFwcC5pZCkucmVwbGFjZShcXFwiX0ZJTEVUWVBFX1xcXCIsIGZpbGVfdHlwZSksXFxuICAgICAgICAgICAgYXN5bmM6IGZhbHNlXFxuICAgICAgICB9KS5yZXNwb25zZVRleHQ7XFxuXFxuICAgICAgICBkYXRhID0gZXZhbChcXFwiKFxcXCIgKyBkYXRhICsgXFxcIilcXFwiKTtcXG4gICAgICAgIGlmIChkYXRhLnJlc3VsdCA9PSBcXFwic3VjY2Vzc1xcXCIpIHtcXG4gICAgICAgICAgICByZXR1cm4gZGF0YS5maWxlcztcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgcmV0dXJuIFxcXCI8b3B0aW9uPlxcXCIgKyBfdHJbXFxcIm1sYWIuZHQuYXBpLmpzLmdldE1lZGlhLmZhaWxcXFwiXSArIFxcXCI8L29wdGlvbj5cXFwiO1xcbiAgICAgICAgfVxcbiAgICB9LFxcblxcbiAgICAvKipcXHJcXG4gICAgICogUmV0dXJucyBhIENTUyBzdHlsZSBjbGFzcyBuYW1lIHdoaWNoIHV0aWxpc2VzIHN0YW5kYXJkIE1sYWIgc3R5bGVzXFxyXFxuICAgICAqIHByb3BlcnRpZXMgPSBhcnJheSBvZiBub3VucyBkZXNjcmliaW5nIHdoYXQgc3R5bGUgdGhleSB3YW50XFxyXFxuICAgICAqL1xcbiAgICBnZXRTdHlsZTogZnVuY3Rpb24gZ2V0U3R5bGUocHJvcGVydGllcykge1xcbiAgICAgICAgdmFyIHN0eWxlID0gXFxcIlxcXCI7XFxuICAgICAgICBmb3IgKGkgaW4gcHJvcGVydGllcykge1xcbiAgICAgICAgICAgIHN3aXRjaCAocHJvcGVydGllc1tpXSkge1xcbiAgICAgICAgICAgICAgICBjYXNlIFxcXCJ0ZXh0XFxcIjpcXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlID0gc3R5bGUgKyBcXFwibWNfdGV4dCBcXFwiO1xcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICAgICAgICAgIGNhc2UgXFxcImltZ3R4dFxcXCI6XFxuICAgICAgICAgICAgICAgICAgICBzdHlsZSA9IHN0eWxlICsgXFxcIm1jX3BpY3R1cmVfYW5kX3RleHRcXFwiO1xcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICB9LFxcblxcbiAgICBpbmRpY2F0ZVdhaXQ6IGZ1bmN0aW9uIGluZGljYXRlV2FpdChzdGF0ZSkge1xcbiAgICAgICAgaWYgKHN0YXRlKSB7XFxuICAgICAgICAgICAgJChcXFwiI21sYWJfZWRpdG9yXFxcIikuYWRkQ2xhc3MoXFxcIm1sYWJfbG9hZGluZ19pbmZvXFxcIik7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICQoXFxcIiNtbGFiX2VkaXRvclxcXCIpLnJlbW92ZUNsYXNzKFxcXCJtbGFiX2xvYWRpbmdfaW5mb1xcXCIpO1xcbiAgICAgICAgfVxcbiAgICB9LFxcbiAgICAvKipcXHJcXG4gICAgICogVGhpcyBpcyB0aGUgZnVuY3Rpb24gdXNlZCBieSBhbGwgY29tcG9uZW50cyBpZiB0aGV5IHdhbnQgdG8gdXBsb2FkIGEgZmlsZS5cXHJcXG4gICAgICogSXQgdXNlcyB0aGUganF1ZXJ5IHVwbG9hZGZpbGUgcGx1Z2luOiBodHRwczovL2dpdGh1Yi5jb20vaGF5YWdlZWsvanF1ZXJ5LXVwbG9hZC1maWxlXFxyXFxuICAgICAqIEBwYXJhbSB7dHlwZX0gZWw6IERJViBzdXJyb3VuZGluZyB0aGUgY29tcG9uZW50IEhUTUxcXHJcXG4gICAgICogQHBhcmFtIHt0eXBlfSBjYjogQ2FsbGJhY2sgZnVuY3Rpb24gd2hlbiBmaWxlIGlzIHVwbG9hZGVkIHN1Y2Nlc3NmdWxseSBPUiBhIGZpbGUgaXMgc2VsZWN0ZWRcXHJcXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cXHJcXG4gICAgICovXFxuICAgIHVwbG9hZE1lZGlhOiBmdW5jdGlvbiB1cGxvYWRNZWRpYShlbCwgY29tcG9uZW50X2NvbmZpZywgZmlsZV90eXBlLCBjYiwgZXZlbnQsIG11bHRpKSB7XFxuXFxuICAgICAgICAvL3N0b3JlIGZvciBsYXRlciB3aGVuIGNhbGxiYWNrcyBhcmUgZXhlY3V0ZWQgaW4gZGlmZmVyZW50IGNvbnRleHRzXFxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XFxuICAgICAgICB2YXIgdGhhdF9xdGlwID0gbnVsbDtcXG5cXG4gICAgICAgIC8vZmlyc3Qgc29tZSB1dGlsaXR5IGZ1bmN0aW9uc1xcblxcbiAgICAgICAgLy9nZW5lcmF0ZSB0aGUgZm9ybSB1c2VkIHRvIHVwbG9hZCBmaWxlcyBvbiB0aGUgZmx5XFxuICAgICAgICBmdW5jdGlvbiBsb2NhbF9wcmVwYXJlX2Zvcm1faHRtbCgpIHtcXG4gICAgICAgICAgICBjb250ZW50ID0gJCgnPGZvcm0gLz4nLCB7IFxcXCJpZFxcXCI6IFxcXCJtbGFiX2R0X2Zvcm1fdXBsb2FkXFxcIiB9KTtcXG4gICAgICAgICAgICBjb250ZW50LmFwcGVuZCgkKCc8cCAvPicsIHsgY2xhc3M6IFxcXCJtbGFiX2R0X3RleHRfaW5mb1xcXCIsIHRleHQ6IF90cltcXFwibWxhYi5kdC5hcGkuanMudXBsb2FkTWVkaWEucXRpcC5jb250ZW50LjFcXFwiXSB9KSk7XFxuICAgICAgICAgICAgY29udGVudC5hcHBlbmQoJCgnPHNlbGVjdCAvPicsIHsgaWQ6IFxcXCJtbGFiX2NwX3NlbGVjdF9maWxlXFxcIiwgY2xhc3M6IFxcXCJtbGFiX2R0X3NlbGVjdFxcXCIgfSkpO1xcbiAgICAgICAgICAgIGNvbnRlbnQuYXBwZW5kKCQoJzxpbnB1dCAvPicsIHsgaWQ6IFxcXCJtbGFiX2NwX3NlbGVjdGVkX2ZpbGVcXFwiLCB0eXBlOiBcXFwiaGlkZGVuXFxcIiB9KSk7XFxuICAgICAgICAgICAgY29udGVudC5hcHBlbmQoJCgnPGRpdiAvPicsIHsgaWQ6IFxcXCJtbGFiX2NwX21lZGlhdXBsb2FkX3VwbG9hZGZpbGVzXFxcIiwgY2xhc3M6IFxcXCJtbGFiX2R0X3BpY3R1cmUgbWxhYl9kdF9sZWZ0XFxcIiB9KSk7XFxuICAgICAgICAgICAgY29udGVudC5hcHBlbmQoJCgnPGRpdiAvPicsIHsgY2xhc3M6IFxcXCJtbGFiX2R0X3RpbnlfbmV3X2xpbmVcXFwiLCBodG1sOiBcXFwiJm5ic3A7XFxcIiB9KSk7XFxuICAgICAgICAgICAgY29udGVudC5hcHBlbmQoJCgnPGRpdiAvPicsIHsgaWQ6IFxcXCJtbGFiX2NwX21lZGlhdXBsb2FkX2J1dHRvbl9jYW5jZWxcXFwiLCBjbGFzczogXFxcIm1sYWJfZHRfYnV0dG9uX2NhbmNlbCBtbGFiX2R0X2xlZnRcXFwiLCB0ZXh0OiBfdHJbXFxcIm1sYWIuZHQuYXBpLmpzLnVwbG9hZE1lZGlhLnF0aXAuY29udGVudC40XFxcIl0gfSkpO1xcbiAgICAgICAgICAgIGNvbnRlbnQuYXBwZW5kKCQoJzxkaXYgLz4nLCB7IGlkOiBcXFwibWxhYl9jcF9tZWRpYXVwbG9hZF9idXR0b25fb2tcXFwiLCBjbGFzczogXFxcIm1sYWJfZHRfYnV0dG9uX29rIG1sYWJfZHRfbGVmdFxcXCIsIHRleHQ6IF90cltcXFwibWxhYi5kdC5hcGkuanMudXBsb2FkTWVkaWEucXRpcC5jb250ZW50LjVcXFwiXSB9KSk7XFxuICAgICAgICAgICAgLy8gICAgICAgICAgICBjb250ZW50LmFwcGVuZCggJCgnPGltZyAvPicsICAgIHsgaWQ6IFxcXCJtbGFiX2NwX21lZGlhdXBsb2FkX3NwaW5uZXJcXFwiLCAgICAgICBjbGFzczogXFxcInJpZ2h0XFxcIiwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmM6ICBcXFwiL2ltZy9zcGlubmVyLmdpZlxcXCIgfSkgKTtcXG4gICAgICAgICAgICByZXR1cm4gY29udGVudDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGZ1bmN0aW9uIGxvY2FsX3NldF9tZWRpYV9zb3VyY2VfZXhpc3RpbmcoKSB7XFxuICAgICAgICAgICAgY2IoZWwsICQoXFxcIiNtbGFiX2NwX3NlbGVjdF9maWxlXFxcIikudmFsKCkpO1xcbiAgICAgICAgICAgIHRoYXQuc2V0RGlydHkoKTtcXG4gICAgICAgICAgICB0aGF0LmNsb3NlQWxsUHJvcGVydHlEaWFsb2dzKCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBmdW5jdGlvbiBsb2NhbF9zZXRfbWVkaWFfc291cmNlKHVybCkge1xcbiAgICAgICAgICAgIGNiKGVsLCB1cmwpO1xcbiAgICAgICAgICAgIHRoYXQuc2V0RGlydHkoKTtcXG4gICAgICAgICAgICB0aGF0LmNsb3NlQWxsUHJvcGVydHlEaWFsb2dzKCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICAvKipcXHJcXG4gICAgICAgICAqIFRoaXMgZnVuY3Rpb24gZGlzcGxheXMgdGhlIHRvb2x0aXAgRElWIHRoYXQgd2lsbCBjb250YWluIHRoZSBIVE1MIGVsZW1lbnRzIHJlcXVpcmVkIHRvIHNlbGVjdCBhIGZpbGUgZm9yIHVwbG9hZC5cXHJcXG4gICAgICAgICAqIEBwYXJhbSB7dHlwZX0gZXZlbnRcXHJcXG4gICAgICAgICAqIEBwYXJhbSB7dHlwZX0gYXBpXFxyXFxuICAgICAgICAgKiBAcmV0dXJucyB7TWxhYl9kdF9hcGkucHJvdG90eXBlLnVwbG9hZE1lZGlhLmxvY2FsX3JlbmRlcl90b29sdGlwfVxcclxcbiAgICAgICAgICovXFxuICAgICAgICBmdW5jdGlvbiBsb2NhbF9yZW5kZXJfdG9vbHRpcChldmVudCwgYXBpKSB7XFxuICAgICAgICAgICAgdGhhdC5pbmRpY2F0ZVdhaXQodHJ1ZSk7XFxuICAgICAgICAgICAgdGhhdF9xdGlwID0gdGhpcztcXG5cXG4gICAgICAgICAgICB0aGlzLmR0X2NvbXBvbmVudCA9IGVsO1xcbiAgICAgICAgICAgIHRoaXMuZHRfY29tcG9uZW50X2lkID0gY29tcG9uZW50X2NvbmZpZy5uYW1lO1xcbiAgICAgICAgICAgIHRoaXMuZHRfY29uZmlnID0gY29tcG9uZW50X2NvbmZpZztcXG4gICAgICAgICAgICB0aGlzLmR0X2NiID0gY2I7XFxuXFxuICAgICAgICAgICAgLy9sb2FkIGV4aXN0aW5nIGZpbGVzIGludG8gZHJvcGRvd24gYm94IGFuZCBtYWtlIGl0IGRkc2xpY2tcXG4gICAgICAgICAgICB2YXIgZXhpc3RpbmdfZmlsZXMgPSB0aGF0LmdldE1lZGlhKGZpbGVfdHlwZSk7XFxuXFxuICAgICAgICAgICAgJChcXFwiI21sYWJfY3Bfc2VsZWN0X2ZpbGVcXFwiKS5odG1sKGV4aXN0aW5nX2ZpbGVzKS5vbihcXFwiY2hhbmdlXFxcIiwgbG9jYWxfc2V0X21lZGlhX3NvdXJjZV9leGlzdGluZykuZGRzbGljayh7XFxuICAgICAgICAgICAgICAgIHdpZHRoOiAyNTQsXFxuICAgICAgICAgICAgICAgIGhlaWdodDogNjQsXFxuICAgICAgICAgICAgICAgIGltYWdlUG9zaXRpb246IFxcXCJsZWZ0XFxcIixcXG4gICAgICAgICAgICAgICAgc2VsZWN0VGV4dDogXFxcIlNlbGVjdCBleGlzdGluZyBtZWRpYSBmaWxlIHRvIHVzZVxcXCJcXG4gICAgICAgICAgICB9KTtcXG5cXG4gICAgICAgICAgICAvL3ByZXBhcmUgdXBsb2FkIGZpbGVzIGpxdWVyeSBwbHVnaW5cXG4gICAgICAgICAgICB2YXIgdXBsb2FkT2JqID0gJChcXFwiI21sYWJfY3BfbWVkaWF1cGxvYWRfdXBsb2FkZmlsZXNcXFwiKS51cGxvYWRGaWxlKHtcXG4gICAgICAgICAgICAgICAgdXJsOiB0aGF0LmdldFVybFVwbG9hZEFic29sdXRlKHRoYXRfcXRpcC5kdF9jb25maWcubmFtZSksXFxuICAgICAgICAgICAgICAgIGZvcm1EYXRhOiB7IGNvbXBfaWQ6IHRoYXRfcXRpcC5kdF9jb21wb25lbnRfaWQsIGFwcF9wYXRoOiB0aGF0LnBhcmVudC5hcHAucGF0aCB9LFxcbiAgICAgICAgICAgICAgICBtdWx0aXBsZTogbXVsdGkgPT09IHRydWUsXFxuICAgICAgICAgICAgICAgIGRyYWdEcm9wOiB0cnVlLFxcbiAgICAgICAgICAgICAgICBzaG93Q2FuY2VsOiB0cnVlLFxcbiAgICAgICAgICAgICAgICBzaG93QWJvcnQ6IHRydWUsXFxuICAgICAgICAgICAgICAgIHNob3dEb25lOiB0cnVlLFxcbiAgICAgICAgICAgICAgICBhdXRvU3VibWl0OiBmYWxzZSxcXG4gICAgICAgICAgICAgICAgZmlsZU5hbWU6IFxcXCJtbGFiX2ZpbGVzXFxcIixcXG4gICAgICAgICAgICAgICAgc2hvd1N0YXR1c0FmdGVyU3VjY2VzczogdHJ1ZSxcXG4gICAgICAgICAgICAgICAgc2hvd1ByZXZpZXc6IHRydWUsXFxuICAgICAgICAgICAgICAgIHByZXZpZXdIZWlnaHQ6IFxcXCIxMDBweFxcXCIsXFxuICAgICAgICAgICAgICAgIHByZXZpZXdXaWR0aDogXFxcIjEwMHB4XFxcIixcXG4gICAgICAgICAgICAgICAgc3RhdHVzQmFyV2lkdGg6IDI1NCxcXG4gICAgICAgICAgICAgICAgZHJhZ2Ryb3BXaWR0aDogMjU0LFxcbiAgICAgICAgICAgICAgICBvblN1Y2Nlc3M6IGZ1bmN0aW9uIChmaWxlcywgZGF0YSwgeGhyKSB7XFxuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5yZXN1bHQgPT0gXFxcImZhaWx1cmVcXFwiKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxlcnQoZGF0YS5tc2cpO1xcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbF9zZXRfbWVkaWFfc291cmNlKGRhdGEudXJsc1swXSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbWxhYi5kdC5hcGkuY2xvc2VBbGxQcm9wZXJ0eURpYWxvZ3MoKTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoYXRfcXRpcC5kdF9jb21wb25lbnQpLFxcbiAgICAgICAgICAgICAgICBvbkVycm9yOiBmdW5jdGlvbiBvbkVycm9yKGZpbGVzLCBzdGF0dXMsIGVyck1zZykge1xcbiAgICAgICAgICAgICAgICAgICAgYWxlcnQoZXJyTXNnKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0pO1xcblxcbiAgICAgICAgICAgIC8vYXNzaWduIGNsb3NlIGV2ZW50cyBhbmQgYWRkIG1sYWIgc3R5bGVzXFxuICAgICAgICAgICAgJCgnI21sYWJfY3BfbWVkaWF1cGxvYWRfYnV0dG9uX29rJykub24oXFxcImNsaWNrXFxcIiwgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgICAgICAgdmFyIHNlbF9leGlzdGluZyA9ICQoXFxcIiNtbGFiX2NwX3NlbGVjdF9maWxlXFxcIikuZGF0YSgnZGRzbGljaycpLnNlbGVjdGVkRGF0YS52YWx1ZTtcXG4gICAgICAgICAgICAgICAgaWYgKHNlbF9leGlzdGluZykge1xcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxfc2V0X21lZGlhX3NvdXJjZShzZWxfZXhpc3RpbmcpO1xcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgdXBsb2FkT2JqLnN0YXJ0VXBsb2FkKCk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9LmJpbmQodGhhdF9xdGlwLmR0X2NvbXBvbmVudCkpO1xcbiAgICAgICAgICAgICQoJyNtbGFiX2NwX21lZGlhdXBsb2FkX2J1dHRvbl9jYW5jZWwnKS5vbihcXFwiY2xpY2tcXFwiLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICAgICAgICBhcGkuaGlkZShlKTtcXG4gICAgICAgICAgICB9LmJpbmQodGhhdF9xdGlwLmR0X2NvbXBvbmVudCkpO1xcbiAgICAgICAgICAgICQoJy5uZXdfYnV0X2xpbmUnKS5hZGRDbGFzcygnbWxhYl9kdF9idXR0b25fbmV3X2xpbmUnKTtcXG4gICAgICAgICAgICAkKCcubmV3X2JpZ19saW5lJykuYWRkQ2xhc3MoJ21sYWJfZHRfbGFyZ2VfbmV3X2xpbmUnKTtcXG4gICAgICAgICAgICAkKCcubmV3X3NtYWxsX2xpbmUnKS5hZGRDbGFzcygnbWxhYl9kdF9zbWFsbF9uZXdfbGluZScpO1xcbiAgICAgICAgICAgICQoJy5pbmZvJykuYWRkQ2xhc3MoJ21sYWJfZHRfdGV4dF9pbmZvJyk7XFxuICAgICAgICAgICAgJCgnLmFqYXgtZmlsZS11cGxvYWQtZmlsZW5hbWUnKS5hZGRDbGFzcygnbWxhYl9kdF90ZXh0X2ZpbGVuYW1lJyk7XFxuICAgICAgICAgICAgJCgnLmFqYXgtZmlsZS11cGxvYWQtc3RhdHVzYmFyJykuYWRkQ2xhc3MoJ21sYWJfZHRfcHJvZ3Jlc3NfYmFyJyk7XFxuXFxuICAgICAgICAgICAgdGhhdC5pbmRpY2F0ZVdhaXQoZmFsc2UpO1xcbiAgICAgICAgfSAvLyBlbmQgbG9jYWxfcmVuZGVyX3Rvb2x0aXBcXG5cXG5cXG4gICAgICAgIC8vY29kZSB0aGF0IGlzIGV4ZWN1dGVkIHdoZW4gdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWRcXG4gICAgICAgIC8vXFxuICAgICAgICAvL2NhbiBiZSBjYWxsZWQgZnJvbSBlbGVtZW50IG9yIGluIHJlc3BvbnNlIHRvIGV2ZW50IGNsaWNrLCB0aGlzIGRlY2lkZXMgd2hvIHNob3VsZCBcXFwib3duXFxcIiB0aGlzIHRvb2x0aXBcXG4gICAgICAgIHZhciBvd25lcl9lbGVtZW50ID0gdHlwZW9mIGV2ZW50ICE9IFxcXCJ1bmRlZmluZWRcXFwiID8gZXZlbnQuY3VycmVudFRhcmdldCA6IGVsO1xcblxcbiAgICAgICAgLy90aGUgbWVhdCBvZiB0aGlzIGZ1bmN0aW9uLCBkaXNwbGF5aW5nIHRoZSB0b29sdGlwXFxuICAgICAgICB0aGF0X3F0aXAgPSB0aGlzLnByb3BlcnRpZXNfdG9vbHRpcCA9ICQob3duZXJfZWxlbWVudCkucXRpcCh7XFxuICAgICAgICAgICAgc29sbzogZmFsc2UsXFxuICAgICAgICAgICAgY29udGVudDogeyB0ZXh0OiBsb2NhbF9wcmVwYXJlX2Zvcm1faHRtbCgpLCB0aXRsZTogX3RyW1xcXCJtbGFiLmR0LmFwaS5qcy51cGxvYWRNZWRpYS5xdGlwLnRpdGxlXFxcIl0gfSxcXG4gICAgICAgICAgICBwb3NpdGlvbjogeyBteTogJ2xlZnRNaWRkbGUnLCBhdDogJ3JpZ2h0TWlkZGxlJywgdmlld3BvcnQ6ICQod2luZG93KSB9LFxcbiAgICAgICAgICAgIHNob3c6IHsgcmVhZHk6IHRydWUsIG1vZGFsOiB7IG9uOiB0cnVlLCBibHVyOiBmYWxzZSB9IH0sXFxuICAgICAgICAgICAgaGlkZTogZmFsc2UsXFxuICAgICAgICAgICAgc3R5bGU6IHsgY2xhc3NlczogJ3F0aXAtbGlnaHQgbWxhYl96aW5kZXhfdG9wX3Rvb2x0aXAnLCB0aXA6IHRydWUgfSxcXG4gICAgICAgICAgICBldmVudHM6IHtcXG4gICAgICAgICAgICAgICAgcmVuZGVyOiBsb2NhbF9yZW5kZXJfdG9vbHRpcCxcXG4gICAgICAgICAgICAgICAgc2hvdzogZnVuY3Rpb24gc2hvdyhldmVudCwgYXBpKSB7XFxuICAgICAgICAgICAgICAgICAgICBhcGkuZm9jdXMoZXZlbnQpO1xcbiAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICBoaWRlOiBmdW5jdGlvbiBoaWRlKGV2ZW50LCBhcGkpIHtcXG4gICAgICAgICAgICAgICAgICAgIGFwaS5kZXN0cm95KCk7dGhhdC5wcm9wZXJ0aWVzX3Rvb2x0aXAgPSBmYWxzZTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICB9LFxcblxcbiAgICAvKipcXHJcXG4gICAgICogQ3JlYXRlcyBhIHVuaXF1ZSBJRCBzdGFydGluZyB3aXRoIHRoZSBwcmVmaXggbWxhYl8sIGZvbGxvd2VkIGJ5IGEgcmZjNDEyMiB2ZXJzaW9uIDQgY29tcGxpYW50IEdVSUQuIFxcclxcbiAgICAgKiBUaGlzIGlzIHR5cGljYWxseSB1c2VkIHRvIGNyZWF0ZSBhbiBJRCBmb3IgYSBjb21wb25lbnQgdGhhdCBtdXN0IG5vdCBjbGFzaCB3aXRoIGFueSBvdGhlciBJRHMuXFxyXFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XFxyXFxuICAgICAqL1xcbiAgICBnZXRHVUlEOiBmdW5jdGlvbiBnZXRHVUlEKCkge1xcbiAgICAgICAgcmV0dXJuICdtbGFiXycgKyAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIGZ1bmN0aW9uIChjKSB7XFxuICAgICAgICAgICAgdmFyIHIgPSBNYXRoLnJhbmRvbSgpICogMTYgfCAwLFxcbiAgICAgICAgICAgICAgICB2ID0gYyA9PSAneCcgPyByIDogciAmIDB4MyB8IDB4ODtcXG4gICAgICAgICAgICByZXR1cm4gdi50b1N0cmluZygxNik7XFxuICAgICAgICB9KTtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxyXFxuICAgICAqIEdvZXMgdGhyb3VnaCBhIG5ld2x5IGxvYWRlZCBwYWdlIGFuZCBjaGVja3MgaWYgYW55IG9mIHRoZSBjb21wb25lbnRzIG9uIHRoZSBwYWdlIHJlcXVpcmVzIGEgbGlicmFyeSAoQ1NTL0pTKSB0byBiZSBsb2FkZWRcXHJcXG4gICAgICogY2FsbHMgZ2V0TGlicmFyaWVzIGZvciB0aGUgYWN0dWFsIGhhcmQgbGlmdGluZywgdGhpcyBpcyBqdXN0IGEgd3JhcHBlclxcclxcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxcclxcbiAgICAgKi9cXG4gICAgZ2V0QWxsTGlicmFyaWVzOiBmdW5jdGlvbiBnZXRBbGxMaWJyYXJpZXMoKSB7XFxuICAgICAgICB2YXIgcHJvY2Vzc2VkX2NvbXBvbmVudCA9IFtdO1xcbiAgICAgICAgdmFyIGNvbXBfaWQ7XFxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XFxuICAgICAgICAkKFxcXCIjXFxcIiArIHRoaXMuZ2V0RWRpdG9yRWxlbWVudCgpKS5jaGlsZHJlbihcXFwiW2RhdGEtbWxhYi10eXBlXVxcXCIpLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIGNvbXBfaWQgPSAkKHRoaXMpLmRhdGEoXFxcIm1sYWItdHlwZVxcXCIpO1xcbiAgICAgICAgICAgIGlmIChwcm9jZXNzZWRfY29tcG9uZW50LmluZGV4T2YoY29tcF9pZCkgPCAwKSB7XFxuICAgICAgICAgICAgICAgIHRoYXQuZ2V0TGlicmFyaWVzKGNvbXBfaWQpO1xcbiAgICAgICAgICAgICAgICBwcm9jZXNzZWRfY29tcG9uZW50LnB1c2goY29tcF9pZCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgIH0sXFxuXFxuICAgIC8vaWYgPSB0cnVlIHdlIGNhbGwgY29tcG9uZW50X2FkZF9odG1sIHRvIGNvbXBsZXRlIHRoZSBhZGRpbmcgb2YgdGhlIGNvbXBvbmVudHNcXG4gICAgZ2V0U2NyaXB0RmlsZXM6IGZ1bmN0aW9uIGdldFNjcmlwdEZpbGVzKHNjcmlwdHMsIHByb2Nlc3NfYWRkaW5nX2NvZGUsIGNvbXBfaWQpIHtcXG4gICAgICAgIHZhciBuZXh0X3NjcmlwdCA9IHNjcmlwdHMuc2hpZnQoKTtcXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcXG4gICAgICAgICQuYWpheFNldHVwKHsgY2FjaGU6IHRydWUgfSk7XFxuICAgICAgICAkLmdldFNjcmlwdChuZXh0X3NjcmlwdCkuZG9uZShmdW5jdGlvbiAoc2NyaXB0LCB0ZXh0U3RhdHVzKSB7XFxuICAgICAgICAgICAgaWYgKHNjcmlwdHMubGVuZ3RoID4gMCkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhhdC5nZXRTY3JpcHRGaWxlcyhzY3JpcHRzLCBwcm9jZXNzX2FkZGluZ19jb2RlLCBjb21wX2lkKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgJC5hamF4U2V0dXAoeyBjYWNoZTogZmFsc2UgfSk7XFxuICAgICAgICAgICAgaWYgKHByb2Nlc3NfYWRkaW5nX2NvZGUgPT09IHRydWUpIHtcXG4gICAgICAgICAgICAgICAgbWxhYi5kdC5kZXNpZ24uY29tcG9uZW50X2FkZF9odG1sKGNvbXBfaWQpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgIH0pLmZhaWwoZnVuY3Rpb24gKGpxeGhyLCBzZXR0aW5ncywgZXhjZXB0aW9uKSB7XFxuICAgICAgICAgICAgYWxlcnQoXFxcIlVuYWJsZSB0byBsb2FkIHNjcmlwdDogXFxcIiArIG5leHRfc2NyaXB0ICsgXFxcIi4gQ29tcG9uZW50IG5vdCBhZGRlZCwgcGxlYXNlIGNoZWNrIG5ldHdvcmsgY29ubmVjdGlvblxcXCIpO1xcbiAgICAgICAgICAgICQuYWpheFNldHVwKHsgY2FjaGU6IGZhbHNlIH0pO1xcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgIH0pO1xcbiAgICB9LFxcblxcbiAgICAvKipcXHJcXG4gICAgICogTG9hZHMgYWxsIGpzL2NzcyBmaWxlcyByZXF1aXJlZCBieSBhIGNvbXBvbmVudCBhdCBkZXNpZ24gdGltZS5cXHJcXG4gICAgICogRmlsZXMgbG9hZGVkIGFyZSBzcGVjaWZpZWQgaW4gdGhlIGNvbmYueW1sIHBhcmFtZXRlciByZXF1aXJlZF9saWJzLlxcclxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29tcF9pZCwgdGhlIHVuaXF1ZSBJRCBmb3IgdGhlIGNvbXBvbmVudCB0aGF0IG5lZWRzIHRvIGxvYWQgdGhlIGZpbGVzXFxyXFxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XFxyXFxuICAgICAqL1xcbiAgICBnZXRMaWJyYXJpZXM6IGZ1bmN0aW9uIGdldExpYnJhcmllcyhjb21wX2lkLCBwcm9jZXNzX2FkZGluZ19jb2RlKSB7XFxuICAgICAgICB2YXIganNfc3RhY2sgPSBbXTtcXG4gICAgICAgIGlmIChcXFwicmVxdWlyZWRfbGlic1xcXCIgaW4gdGhpcy5wYXJlbnQuY29tcG9uZW50c1tjb21wX2lkXS5jb25mKSB7XFxuICAgICAgICAgICAgaWYgKFxcXCJkZXNpZ250aW1lXFxcIiBpbiB0aGlzLnBhcmVudC5jb21wb25lbnRzW2NvbXBfaWRdLmNvbmYucmVxdWlyZWRfbGlicykge1xcbiAgICAgICAgICAgICAgICB2YXIgY29tcF91cmwgPSB3aW5kb3cubG9jYXRpb24ub3JpZ2luICsgdGhpcy5wYXJlbnQudXJscy5jb21wb25lbnRzX3Jvb3RfdXJsO1xcbiAgICAgICAgICAgICAgICB2YXIgY29tcF9wYXRoID0gdGhpcy5wYXJlbnQuY29tcG9uZW50c1tjb21wX2lkXS5jb25mLm5hbWU7XFxuXFxuICAgICAgICAgICAgICAgIGZvciAoaSBpbiB0aGlzLnBhcmVudC5jb21wb25lbnRzW2NvbXBfaWRdLmNvbmYucmVxdWlyZWRfbGlicy5kZXNpZ250aW1lKSB7XFxuICAgICAgICAgICAgICAgICAgICB2YXIgZmlsZSA9IHRoaXMucGFyZW50LmNvbXBvbmVudHNbY29tcF9pZF0uY29uZi5yZXF1aXJlZF9saWJzLmRlc2lnbnRpbWVbaV07XFxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVnZXhwID0gLyhodHRwfGh0dHBzKTpcXFxcL1xcXFwvKFxcXFx3Kzp7MCwxfVxcXFx3KkApPyhcXFxcUyspKDpbMC05XSspPyhcXFxcL3xcXFxcLyhbXFxcXHcjITouPys9JiVAIVxcXFwtXFxcXC9dKSk/LztcXG5cXG4gICAgICAgICAgICAgICAgICAgIC8vaGFzIGZ1bGwgVVJMIGluY2x1ZGluZyBwcm90b2NvbCwgaS5lLiBpdCBpcyByZW1vdGVcXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWdleHAudGVzdChmaWxlKSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWxlLnN1YnN0cigtMykgPT0gXFxcIi5qc1xcXCIpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCQoXFxcInNjcmlwdFtzcmMqPSdcXFwiICsgZmlsZSArIFxcXCInXVxcXCIpLmxlbmd0aCA8IDEpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzX3N0YWNrLnB1c2goZmlsZSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoJChcXFwibGlua1tocmVmKj0nXFxcIiArIGZpbGUgKyBcXFwiJ11cXFwiKS5sZW5ndGggPCAxKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKFxcXCJoZWFkXFxcIikuYXBwZW5kKCQoXFxcIjxsaW5rIHJlbD0nc3R5bGVzaGVldCcgdHlwZT0ndGV4dC9jc3MnIGhyZWY9J1xcXCIgKyBmaWxlICsgXFxcIicgPlxcXCIpKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1xcXCJsb2NhbFxcXCIsIGkuZS4gZmlsZSB0aGF0IGlzIHBhcnQgb2YgTWxhYiBhIGNvbXBvbmVudCBcXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZmlsZS5zdWJzdHIoLTMpID09IFxcXCIuanNcXFwiKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAganNfc3RhY2sucHVzaChmaWxlKTsgLy90aGUgbG9jYWwgcGF0aCBpcyBhbHJlYWR5IHNldCBvbiB0aGUgYmFja2VuZCBpbiBGaWxlTWFuYWdlbWVudDo6bG9hZFNpbmdsZUNvbXBvbmVudFxcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChmaWxlLnN1YnN0cigtNCkgPT0gXFxcIi5jc3NcXFwiKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCQoXFxcImxpbmtbaHJlZio9J1xcXCIgKyBmaWxlICsgXFxcIiddXFxcIikubGVuZ3RoIDwgMSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKFxcXCJoZWFkXFxcIikuYXBwZW5kKCQoXFxcIjxsaW5rIHJlbD0nc3R5bGVzaGVldCcgdHlwZT0ndGV4dC9jc3MnIGhyZWY9J1xcXCIgKyBmaWxlICsgXFxcIicgPlxcXCIpKTsgLy90aGUgbG9jYWwgcGF0aCBpcyBhbHJlYWR5IHNldCBvbiB0aGUgYmFja2VuZCBpbiBGaWxlTWFuYWdlbWVudDo6bG9hZFNpbmdsZUNvbXBvbmVudFxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICBpZiAoanNfc3RhY2subGVuZ3RoID4gMCkge1xcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRTY3JpcHRGaWxlcyhqc19zdGFjaywgcHJvY2Vzc19hZGRpbmdfY29kZSwgY29tcF9pZCk7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBpZiAocHJvY2Vzc19hZGRpbmdfY29kZSA9PT0gdHJ1ZSkge1xcbiAgICAgICAgICAgIG1sYWIuZHQuZGVzaWduLmNvbXBvbmVudF9hZGRfaHRtbChjb21wX2lkKTtcXG4gICAgICAgIH1cXG4gICAgfSxcXG5cXG4gICAgLyoqXFxyXFxuICAgICAqIEdldCBhcGkgdmVyc2lvbiBmb3IgZGVzaWdudGltZSBBUEksIGRpZmZlcmVudCBmcm9tIHJ1bnRpbWUgQVBJIHZlcnNpb24gKHdoaWNoIGlzIGFueXdheSBhIGRpZmZlcmVudCBmaWxlL29iamVjdCkuXFxyXFxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XFxyXFxuICAgICAqL1xcbiAgICBnZXRWZXJzaW9uOiBmdW5jdGlvbiBnZXRWZXJzaW9uKCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMudmVyc2lvbjtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxyXFxuICAgICAqIEdldCBjdXJyZW50bHkgc2VsZWN0ZWQgY29tcG9uZW50ICh0aGUgRElWLCBub3QgdGhlIGludGVybmFsIEhUTUwgY29kZSkuXFxyXFxuICAgICAqIEByZXR1cm5zIHtqUXVlcnkgb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgRElWIHN1cnJvdW5kaW5nIHRoZSBjb21wb25lbnR9XFxyXFxuICAgICAqL1xcbiAgICBnZXRTZWxlY3RlZENvbXBvbmVudDogZnVuY3Rpb24gZ2V0U2VsZWN0ZWRDb21wb25lbnQoKSB7XFxuICAgICAgICByZXR1cm4gJCgnLm1sYWJfY3VycmVudF9jb21wb25lbnQnKTtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxyXFxuICAgICAqIFNldCB0aGUgZ2xvYmFsIGRpcnR5IGZsYWcsIHRoaXMgdGVsbHMgdGhlIHBhZ2Vfc2F2ZSBmdW5jdGlvbiB0aGF0IHRoZSBwYWdlIG5lZWRzIHRvIGJlIHVwZGF0ZWQgb24gdGhlIHNlcnZlci5cXHJcXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cXHJcXG4gICAgICovXFxuICAgIHNldERpcnR5OiBmdW5jdGlvbiBzZXREaXJ0eSgpIHtcXG4gICAgICAgIHRoaXMucGFyZW50LmZsYWdfZGlydHkgPSB0cnVlO1xcbiAgICB9LFxcblxcbiAgICAvKipcXHJcXG4gICAgICogQ2xlYXIgdGhlIGdsb2JhbCBkaXJ0eSBmbGFnXFxyXFxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XFxyXFxuICAgICAqL1xcbiAgICBjbGVhckRpcnR5OiBmdW5jdGlvbiBjbGVhckRpcnR5KCkge1xcbiAgICAgICAgdGhpcy5wYXJlbnQuZmxhZ19kaXJ0eSA9IGZhbHNlO1xcbiAgICB9LFxcblxcbiAgICAvKipcXHJcXG4gICAgICogR2V0IHRoZSBJRCBvZiB0aGUgRElWIHRoYXQgaXMgdGhlIGNvbnRhaW5lciBmb3IgdGhlIGVkaXRhYmxlIGFyZWEuIFxcclxcbiAgICAgKiBUaGUgc3RyaW5nIG5hbWUgaXMgc3BlY2lmaWVkIGluIHRoZSBwYXJhbWV0ZXIueW1sIGZpbGUgYW5kIGNhbiBiZSBjaGFuZ2VkLCBidXQgdGhlcmUgcmVhbGx5IGlzIG5vIHJlYXNvbiB0byBkbyB0aGlzLlxcclxcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nOiBNbGFiX2R0X2FwaS5wYXJlbnQuY29uZmlnLmNvbnRlbnRfaWR9XFxyXFxuICAgICAqL1xcbiAgICBnZXRFZGl0b3JFbGVtZW50OiBmdW5jdGlvbiBnZXRFZGl0b3JFbGVtZW50KCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmNvbmZpZy5hcHAuY29udGVudF9pZDtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxyXFxuICAgICAqIFNpbXBsZSB3cmFwcGVyIGZ1bmN0aW9uIHdoaWNoIHdpbGwgZW5zdXJlIHRoYXQgdGhlIGpRdWVyeSBwbHVnaW4gcXRpcDIgaXMgY2xvc2VkLlxcclxcbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxcclxcbiAgICAgKi9cXG4gICAgY2xvc2VBbGxQcm9wZXJ0eURpYWxvZ3M6IGZ1bmN0aW9uIGNsb3NlQWxsUHJvcGVydHlEaWFsb2dzKCkge1xcbiAgICAgICAgaWYgKHRoaXMucHJvcGVydGllc190b29sdGlwKSB7XFxuICAgICAgICAgICAgJCh0aGlzLnByb3BlcnRpZXNfdG9vbHRpcCkucXRpcCgnaGlkZScpO1xcbiAgICAgICAgfVxcbiAgICB9LFxcblxcbiAgICBleGVjdXRlQ2FsbGJhY2s6IGZ1bmN0aW9uIGV4ZWN1dGVDYWxsYmFjayhmdW5jLCBlbCwgZXZlbnQsIGFwaSkge1xcbiAgICAgICAgaWYgKHR5cGVvZiBmdW5jID09IFxcXCJ1bmRlZmluZWRcXFwiIHx8IGZ1bmMgPT0gbnVsbCkge1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG4gICAgICAgIGZ1bmMoZWwsIGV2ZW50LCBhcGkpO1xcbiAgICB9LFxcblxcbiAgICAvKipcXHJcXG4gICAgICogRGlzcGxheXMgdGhlIHByb3BlcnR5IGlucHV0IGRpYWxvZyBmb3IgdGhlIHNwZWNpZmllZCBjb21wb25lbnQuIFxcclxcbiAgICAgKiBUaGlzIHVzZXMgdGhlIGpRdWVyeSBwbHVnaW4gcXRpcDIgZm9yIHRoZSBhY3R1YWwgZGlhbG9nLCBhbmQgZmlsbHMgaXQgd2l0aCB0aGUgc3BlY2lmaWVkIGNvbnRlbnQuXFxyXFxuICAgICAqIFRoZSBjb21wb25lbnQgaXMgcmVwb25zaWJsZSBmb3IgYWRkaW5nIGJ1dHRvbnMgc3VjaCBhcyBDYW5jZWwgYW5kIE9LIHdpdGggY2FsbGJhY2sgdG8gcmVsZXZhbnQgZnVuY3Rpb25zIGluIHRoZSBjb21wb25lbnQuXFxyXFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5IERPTSBlbGVtZW50fSBlbCwgdGhlIGNvbXBvbmVudCB0aGF0IHRoZSBkaWFsZGlzcGxheVByb3BlcnR5RGlhbG9nb2cgc2hvdWxkIGJlIGF0dGFjaGVkIHRvXFxyXFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0aXRsZVxcclxcbiAgICAgKiBAcGFyYW0ge0hUTUwgc3RyaW5nfSBjb250ZW50LCB2YWxpZCBIVE1MNVxcclxcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uIG9iamVjdH0gZnVuY19yZW5kZXIsIGNhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gdGhlIHByb3BlcnR5IGRpYWxvZyBpcyBjcmVhdGVkLCBjYW4gYmUgdXNlZCB0byBtYW5pcHVsYXRlIGRpYWxvZywgYWRkIGNvbnRlbnQsIGV0Yy5cXHJcXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbiBvYmplY3R9IGZ1bmNfdmlzaWJsZSwgY2FsbGJhY2sgZnVuY3Rpb24gd2hlbiB0aGUgcHJvcGVydHkgZGlhbG9nIGlzIHZpc2libGVcXHJcXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbiBvYmplY3R9IGZ1bmNfaGlkZSBjdXJyZW50bHkgdW51c2VkXFxyXFxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XFxyXFxuICAgICAqL1xcbiAgICBkaXNwbGF5UHJvcGVydHlEaWFsb2c6IGZ1bmN0aW9uIGRpc3BsYXlQcm9wZXJ0eURpYWxvZyhlbCwgdGl0bGUsIGNvbnRlbnQsIGZ1bmNfcmVuZGVyLCBmdW5jX3Zpc2libGUsIGZ1bmNfaGlkZSwgZm9jdXNfc2VsZWN0b3IsIHdpZGUsIGV2ZW50KSB7XFxuICAgICAgICB0aGlzLmluZGljYXRlV2FpdCh0cnVlKTtcXG4gICAgICAgIHRoaXMuY2xvc2VBbGxQcm9wZXJ0eURpYWxvZ3MoKTtcXG4gICAgICAgIHRoYXQgPSB0aGlzO1xcbiAgICAgICAgdmFyIGMgPSAnbWxhYl9wcm9wZXJ0eV9kbGcgcXRpcC1saWdodCBtbGFiX2R0X2JveF9zdHlsZSBtbGFiX3ppbmRleF90b3BfdG9vbHRpcCc7XFxuICAgICAgICBpZiAod2lkZSA9PSB0cnVlKSB7XFxuICAgICAgICAgICAgYyA9IGMgKyAnIG1sYWJfZHRfd2lkZV9xdGlwX2JveCAnO1xcbiAgICAgICAgfTtcXG5cXG4gICAgICAgIGlmICh0eXBlb2YgZXZlbnQgIT0gXFxcInVuZGVmaW5lZFxcXCIpIHtcXG4gICAgICAgICAgICB2YXIgb3duZXJfZWxlbWVudCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHZhciBvd25lcl9lbGVtZW50ID0gZWw7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB2YXIgY3Vycl9jb21wID0gJChcXFwiLm1sYWJfY3VycmVudF9jb21wb25lbnRcXFwiKTtcXG4gICAgICAgIC8vc2V0IHRoZSBxVGlwcyBwb3Npc3Rpb24gYWZ0ZXIgd2hlcmUgaXQgaXMgcGxhY2VkIGluIHRoZSB3aW5kb3cgXFxuICAgICAgICB2YXIgbXlQb3NRdGlwID0gJ2xlZnRNaWRkbGUnO1xcbiAgICAgICAgLy92YXIgZVRvcCA9IGN1cnJfY29tcC50b3A7IC8vZ2V0IHRoZSBvZmZzZXQgdG9wIG9mIHRoZSBlbGVtZW50XFxuICAgICAgICB2YXIgZVRvcCA9IGN1cnJfY29tcC5vZmZzZXQoKS50b3A7IC8vZ2V0IHRoZSBvZmZzZXQgdG9wIG9mIHRoZSBlbGVtZW50XFxuICAgICAgICAvL2VUb3AgPSBlVG9wIC0gJCh3aW5kb3cpLnNjcm9sbFRvcCgpO1xcbiAgICAgICAgaWYgKGVUb3AgPD0gMTQ1KSB7XFxuICAgICAgICAgICAgbXlQb3NRdGlwID0gJ2xlZnRUb3AnO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdGhhdC5wcm9wZXJ0aWVzX3Rvb2x0aXAgPSAkKG93bmVyX2VsZW1lbnQpLnF0aXAoe1xcbiAgICAgICAgICAgIHNvbG86IGZhbHNlLFxcbiAgICAgICAgICAgIGNvbnRlbnQ6IHsgdGV4dDogY29udGVudCwgdGl0bGU6IHRpdGxlLCBidXR0b246IHRydWUgfSxcXG4gICAgICAgICAgICBwb3NpdGlvbjogeyBteTogbXlQb3NRdGlwLCBhdDogJ3JpZ2h0TWlkZGxlJywgdmlld3BvcnQ6ICQod2luZG93KSB9LFxcbiAgICAgICAgICAgIHNob3c6IHsgcmVhZHk6IHRydWUsIG1vZGFsOiB7IG9uOiB0cnVlLCBibHVyOiBmYWxzZSwgZXNjYXBlOiBmYWxzZSB9LCBhdXRvZm9jdXM6IGZvY3VzX3NlbGVjdG9yIH0sXFxuICAgICAgICAgICAgaGlkZTogZmFsc2UsXFxuICAgICAgICAgICAgc3R5bGU6IHsgY2xhc3NlczogYywgdGlwOiB0cnVlIH0sXFxuICAgICAgICAgICAgZXZlbnRzOiB7IHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGV2ZW50LCBhcGkpIHtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChmdW5jX3JlbmRlcikge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuZXhlY3V0ZUNhbGxiYWNrKGZ1bmNfcmVuZGVyLCBlbCwgZXZlbnQsIGFwaSk7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgIHNob3c6IGZ1bmN0aW9uIHNob3coZXZlbnQsIGFwaSkge1xcbiAgICAgICAgICAgICAgICAgICAgJCgnLnF0aXAtdGl0bGUnKS5hcHBlbmQoJzxpbWcgY2xhc3M9XFxcIm1sYWJfZHRfYnV0dG9uX2hlbHBcXFwiIHNyYz1cXFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFCZ0FBQUFZQ0FZQUFBRGdkejM0QUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUFRSkpSRUZVZU5waVpDQUFXTms1QklDVUF4QWJvRWxkK1Azenh3WUdjZ0hJWUNCdUFPTDNRUHdmQjc0UHhBbjR6R0hFNCtyOVdGeU5DeXdBK2lZUm13UXpGUXdIQVFObUZoYUZmMy8vYkVTWFlNS2llRDZKaHNOQUF0QnhEc1JZNElERGdBZWdvQURpQTNnc3lTY21jaDJ3Uk94OE5EVUd1Q0tmbEJTMEg2cHBQdzQxKzhtMkFNMDNBbGpFRFhBazIvY01sQUNnQVFxZzRNS1RMK1lUbFE5d0dHNEFUYjRDT0pSOEFHSkRZSDU0UUNnVmtXdTRJN3JoUkZzQUJQMTRERjhBZGZrRm9vc0tMRDdBbFRvU2dRWXZJTGtzSXRLQ0EwRERIUW5wSlRhSXNIbC9Jc01vUUk0RExMaUJHTDFNdEhiY3FBVUVBUXVSNmhxeFpUUmlOQUlFR0FEYWVtVXVYZ1pvV1FBQUFBQkpSVTVFcmtKZ2dnPT1cXFwiPicpO1xcbiAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICBoaWRlOiBmdW5jdGlvbiBoaWRlKGV2ZW50LCBhcGkpIHtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChmdW5jX2hpZGUpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmV4ZWN1dGVDYWxsYmFjayhmdW5jX2hpZGUsIGVsLCBldmVudCwgYXBpKTtcXG4gICAgICAgICAgICAgICAgICAgIH07YXBpLmRlc3Ryb3koKTt0aGF0LnByb3BlcnRpZXNfdG9vbHRpcCA9IGZhbHNlO1xcbiAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICB2aXNpYmxlOiBmdW5jdGlvbiB2aXNpYmxlKGV2ZW50LCBhcGkpIHtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChmdW5jX3Zpc2libGUpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmV4ZWN1dGVDYWxsYmFjayhmdW5jX3Zpc2libGUsIGVsLCBldmVudCwgYXBpKTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICAgICAgdGhpcy5pbmRpY2F0ZVdhaXQoZmFsc2UpO1xcbiAgICB9LFxcblxcbiAgICAvKipcXHJcXG4gICAgICogRGlzcGxheXMgdGhlIGhlbHAgdGV4dCwgbG9hZGVkIHZpYSBBSkFYIGZyb20gXFxyXFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0aXRsZVxcclxcbiAgICAgKiBAcGFyYW0ge0hUTUwgc3RyaW5nfSBjb250ZW50LCB2YWxpZCBIVE1MNVxcclxcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uIG9iamVjdH0gZnVuY19yZW5kZXIsIGNhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gdGhlIHByb3BlcnR5IGRpYWxvZyBpcyBjcmVhdGVkLCBjYW4gYmUgdXNlZCB0byBtYW5pcHVsYXRlIGRpYWxvZywgYWRkIGNvbnRlbnQsIGV0Yy5cXHJcXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbiBvYmplY3R9IGZ1bmNfdmlzaWJsZSwgY2FsbGJhY2sgZnVuY3Rpb24gd2hlbiB0aGUgcHJvcGVydHkgZGlhbG9nIGlzIHZpc2libGVcXHJcXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbiBvYmplY3R9IGZ1bmNfaGlkZSBjdXJyZW50bHkgdW51c2VkXFxyXFxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XFxyXFxuICAgICAqL1xcbiAgICBkaXNwbGF5SHRtbFBhZ2VJbkRpYWxvZzogZnVuY3Rpb24gZGlzcGxheUh0bWxQYWdlSW5EaWFsb2coZWwsIHRpdGxlLCBodG1scGFnZSwgcVRpcENsYXNzKSB7XFxuICAgICAgICB2YXIgc3R5bGVDbGFzc2VzID0gJ3F0aXAtbGlnaHQgbWxhYl9kdF9ib3hfc3R5bGUgbWxhYl96aW5kZXhfdG9wX3Rvb2x0aXAnO1xcbiAgICAgICAgaWYgKHR5cGVvZiBxVGlwQ2xhc3MgIT0gXFxcInVuZGVmaW5lZFxcXCIpIHtcXG4gICAgICAgICAgICB2YXIgc3R5bGVDbGFzc2VzID0gc3R5bGVDbGFzc2VzICsgXFxcIiBcXFwiICsgcVRpcENsYXNzO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgJChlbCkucXRpcCh7XFxuICAgICAgICAgICAgc29sbzogZmFsc2UsXFxuICAgICAgICAgICAgY29udGVudDoge1xcbiAgICAgICAgICAgICAgICB0ZXh0OiBodG1scGFnZSxcXG4gICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlLFxcbiAgICAgICAgICAgICAgICBidXR0b246IHRydWVcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIHBvc2l0aW9uOiB7IG15OiAndG9wUmlnaHQnLCBhdDogJ2JvdHRvbU1pZGRsZScsIHZpZXdwb3J0OiAkKHdpbmRvdyksIGVmZmVjdDogZmFsc2UgfSxcXG4gICAgICAgICAgICBzaG93OiB7IHJlYWR5OiB0cnVlLCBtb2RhbDogeyBvbjogZmFsc2UgfSB9LFxcbiAgICAgICAgICAgIGhpZGU6IGZhbHNlLFxcbiAgICAgICAgICAgIHN0eWxlOiB7IGNsYXNzZXM6IHN0eWxlQ2xhc3NlcywgdGlwOiB0cnVlIH0sXFxuICAgICAgICAgICAgZXZlbnRzOiB7IGhpZGU6IGZ1bmN0aW9uIGhpZGUoZXZlbnQsIGFwaSkge1xcbiAgICAgICAgICAgICAgICAgICAgYXBpLmRlc3Ryb3koKTtcXG4gICAgICAgICAgICAgICAgfSwgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XFxuICAgICAgICAgICAgICAgICAgICAkKFxcXCIubWxhYl9oZWxwX2ljb25cXFwiKS5xdGlwKCkuZWxlbWVudHMudG9vbHRpcC5kcmFnZ2FibGUoKTtcXG4gICAgICAgICAgICAgICAgfSB9XFxuICAgICAgICB9KTtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxyXFxuICAgICAqIE1ha2VzIGN1cnJlbnRseSB0aGUgc29jaWZpZWQgY29tcG9uZW50IGVkaXRhYmxlLCB1c2luZyB0aGUgSFRNTDUgY29udGVudGVkaXRhYmxlIGF0dHJpYnV0ZS5cXHJcXG4gICAgICogT25seSB3b3JrcyBvbiB0ZXh0IGVsZW1lbnRzLCBzdWNoIGFzIGhlYWRpbmcgb3IgcGFyYWdyYXBoXFxyXFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5IERPTSBlbGVtZW50fSBlbFxcclxcbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxcclxcbiAgICAgKi9cXG4gICAgZWRpdENvbnRlbnQ6IGZ1bmN0aW9uIGVkaXRDb250ZW50KGVsKSB7XFxuICAgICAgICAkKGVsKS5hdHRyKCdjb250ZW50ZWRpdGFibGUnLCAndHJ1ZScpLmZvY3VzKCk7XFxuICAgICAgICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xcbiAgICAgICAgdmFyIHNlbCA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcXG4gICAgICAgIHJhbmdlLnNlbGVjdE5vZGVDb250ZW50cygkKGVsKVswXSk7XFxuICAgICAgICBzZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XFxuICAgICAgICBzZWwuYWRkUmFuZ2UocmFuZ2UpO1xcbiAgICB9LFxcblxcbiAgICAvKipcXHJcXG4gICAgICogUmV0dXJucyB0aGUgbG9jYWxlIChmb3IgaW5zdGFuY2UgbmJfTk8pIGFzIHNwZWNpZmllZCBpbiB0aGUgYmFja2VuZCBTeW1mb255IGVudmlyb25tZW50LlxcclxcbiAgICAgKiBMb2FkZWQgYXMgYSB0ZW1wb3JhcnkgdmFyaWFibGUgb24gaW5pdGlhbCBNTEFCIGVkaXRvciBwYWdlIGxvYWQgYXMgaXQgaGFzIHRvIGJlIHBhc3NlZCBmcm9tIHRoZSBiYWNrZW5kLlxcclxcbiAgICAgKiBAcmV0dXJucyB7TWxhYl9kdF9hcGkucGFyZW50LnBhcmVudC5sb2NhbGV9XFxyXFxuICAgICAqL1xcbiAgICBnZXRMb2NhbGU6IGZ1bmN0aW9uIGdldExvY2FsZSgpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5wYXJlbnQubG9jYWxlO1xcbiAgICB9LFxcblxcbiAgICAvKipcXHJcXG4gICAgICogUmV0dXJucyB0aGUgc3RyaW5nIGZyb20gYSBjb21wb25lbnQgYXMgc3BlY2lmaWVkIGJ5IHRoZSBtc2dfa2V5IGFuZCBtc2dfc3Via2V5IFxcclxcbiAgICAgKiBUaGlzIGlzIGEgc3RyaW5nIHRoYXQgaXMgZW50ZXJlZCBpbnRvIHRoZSBjb25mLnltbCwgaXQgY2FuIGJlIGEgdG9vbHRpcCBvciBnZW5lcmljIG1lc3NhZ2VzXFxyXFxuICAgICAqIElmIHRoZSBrZXkgcG9pbnRzIHRvIGEgc3RyaW5nIHdlIGp1c3QgcmV0dXJuIHRoZSBzdHJpbmcsIGlmIGl0IGlzIGFuIG9iamVjdCwgYW5kIGl0IGhhcyBhbiBvYmplY3QgbmFtZWQgdGhlIHNhbWUgYXMgdGhlIGN1cnJlbnQgbG9jYWxlLFxcclxcbiAgICAgKiB0aGVuIGl0IHJldHVybnMgdGhpcyBsb2NhbGUgc3RyaW5nLCBvdGhlcndpc2UgbG9va3MgZm9yIG9uZSBjYWxsZWQgZGVmYXVsdC4gSWYgbmVpdGhlciBmb3VuZCwgcmV0dXJuIGVtcHR5XFxyXFxuICAgICAqIEBwYXJhbSB7dHlwZX0gY29tcF9pZFxcclxcbiAgICAgKiBAcGFyYW0ge3N0cmluZyBhcnJheX0ga2V5c1xcclxcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxcclxcbiAgICAgKi9cXG4gICAgZ2V0TG9jYWxlQ29tcG9uZW50TWVzc2FnZTogZnVuY3Rpb24gZ2V0TG9jYWxlQ29tcG9uZW50TWVzc2FnZShjb21wX2lkLCBrZXlzKSB7XFxuICAgICAgICB2YXIgbG9jID0gdGhpcy5nZXRMb2NhbGUoKTtcXG4gICAgICAgIHZhciBvYmogPSB0aGlzLnBhcmVudC5jb21wb25lbnRzW2NvbXBfaWRdLmNvbmY7XFxuICAgICAgICB2YXIgZm91bmRfYXRfYWxsID0gZmFsc2U7XFxuXFxuICAgICAgICBmb3IgKGkgaW4ga2V5cykge1xcbiAgICAgICAgICAgIGlmIChrZXlzW2ldIGluIG9iaikge1xcbiAgICAgICAgICAgICAgICBmb3VuZF9hdF9hbGwgPSB0cnVlO1xcbiAgICAgICAgICAgICAgICBvYmogPSBvYmpba2V5c1tpXV07XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgZm91bmRfYXRfYWxsID0gZmFsc2U7XFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIC8vZG9lcyBrZXkgZXhpc3QgYXQgYWxsP1xcbiAgICAgICAgaWYgKCFmb3VuZF9hdF9hbGwpIHtcXG4gICAgICAgICAgICByZXR1cm4gXFxcIlxcXCI7XFxuXFxuICAgICAgICAgICAgLy9rZXkgd2FzIGZvdW5kLCBub3cgbmVkIHRvIHNlZSBpZiBpdCBpcyBhIHN0cmluZyBvciBhcnJheSBvZiBzdHJpbmdzLCBhbmQgaWYgb3VyIGxvY2FsZSBpcyBwcmVzZW50IGluIG9iamVjdFxcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBpZiAoKHR5cGVvZiBvYmogPT09IFxcXCJ1bmRlZmluZWRcXFwiID8gXFxcInVuZGVmaW5lZFxcXCIgOiBfdHlwZW9mKG9iaikpICE9IFxcXCJvYmplY3RcXFwiKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XFxuICAgICAgICAgICAgfSBlbHNlIGlmIChsb2MgaW4gb2JqKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiBvYmpbbG9jXTtcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxcXCJkZWZhdWx0XFxcIiBpbiBvYmopIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9ialtcXFwiZGVmYXVsdFxcXCJdO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiBcXFwiXFxcIjtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcclxcbiAgICAgKiBSZWFkcyBpbiB0aGUgSmF2YXNjcmlwdCB2YWx1ZXMgc3RvcmVkIGZvciB0aGUgc3BlY2lmaWVkIGVsZW1lbnQsIGV4dHJhY3RzIHRoZSB2YWx1ZSBvZiB0aGUga2V5IHNwZWNpZmllZC5cXHJcXG4gICAgICogVGhpcyBvbmx5IHdvcmtzIG9uIHRvcCBsZXZlbCB2YXJzLCBmdXJ0aGVyIHByb2Nlc3NpbmcgbXVzdCBiZSBkb25lIGluc2lkZSB0aGUgSlMgY29kZSBmb3IgdGhlIGNvbXBvbmVudC5cXHJcXG4gICAgICogXFxyXFxuICAgICAqIFZhcmlhYmxlcyBhcmUgc3RvcmVkIGluIGEgPHNjcmlwdD4gb2YgdHlwZSBhcHBsaWNhdGlvbi9qc29uIGFzIHN0cmluZ2lmaWVkIEpTT04sIG9uIHRoZSBzYW1lIGxldmVsIGFzIHRoZSBtYWluIGNvbXBvbmVudCBIVE1MNSBjb2RlLlxcclxcbiAgICAgKiBUaGVzZSBhcmUgYWxsIGNvbnRhaW5lZCB3aXRoaW4gYSB3cmFwcGVyIERJViB0aGF0IGlzIHRoZSBhY3R1YWwgRE9NIGVsZW1lbnQgcHBhc3NlZCB0byB0aGlzIGZ1bmN0aW9uLlxcclxcbiAgICAgKiBAcGFyYW0ge2pRdWVyeSBET00gZWxlbWVudH0gZWxcXHJcXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSwgdGhlIGtleSBuYW1lIGluIHRoZSBvYmplY3RcXHJcXG4gICAgICogQHJldHVybnMge01sYWJfZHRfYXBpLnByb3RvdHlwZS5nZXRWYXJpYWJsZS52YXJzfEFycmF5fE9iamVjdH1cXHJcXG4gICAgICovXFxuICAgIGdldFZhcmlhYmxlOiBmdW5jdGlvbiBnZXRWYXJpYWJsZShlbCwga2V5KSB7XFxuICAgICAgICB2YXIganNvbiA9ICQoZWwpLmZpbmQoXFxcInNjcmlwdC5tbGFiX3N0b3JhZ2VcXFwiKS5odG1sKCk7XFxuICAgICAgICBpZiAodHlwZW9mIGpzb24gPT0gXFxcInVuZGVmaW5lZFxcXCIgfHwganNvbiA9PSBcXFwiXFxcIikge1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgdmFyIHZhcnMgPSBKU09OLnBhcnNlKGpzb24pO1xcbiAgICAgICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGUpO1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiB2YXJzW2tleV07XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcclxcbiAgICAgKiBSZWFkcyBpbiB0aGUgSmF2YXNjcmlwdCB2YWx1ZXMgc3RvcmVkIGZvciB0aGUgc3BlY2lmaWVkIGVsZW1lbnQsIGFuZCByZXR1cm5zIGl0IGFzIGEgc2luZ2xlIEpTIG9iamVjdFxcclxcbiAgICAgKiBcXHJcXG4gICAgICogVmFyaWFibGVzIGFyZSBzdG9yZWQgaW4gYSA8c2NyaXB0PiBvZiB0eXBlIGFwcGxpY2F0aW9uL2pzb24gYXMgc3RyaW5naWZpZWQgSlNPTiwgb24gdGhlIHNhbWUgbGV2ZWwgYXMgdGhlIG1haW4gY29tcG9uZW50IEhUTUw1IGNvZGUuXFxyXFxuICAgICAqIFRoZXNlIGFyZSBhbGwgY29udGFpbmVkIHdpdGhpbiBhIHdyYXBwZXIgRElWIHRoYXQgaXMgdGhlIGFjdHVhbCBET00gZWxlbWVudCBwcGFzc2VkIHRvIHRoaXMgZnVuY3Rpb24uXFxyXFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5IERPTSBlbGVtZW50fSBlbFxcclxcbiAgICAgKiBAcmV0dXJucyB7TWxhYl9kdF9hcGkucHJvdG90eXBlLmdldEFsbFZhcmlhYmxlcy52YXJzfEFycmF5fE9iamVjdH1cXHJcXG4gICAgICovXFxuICAgIGdldEFsbFZhcmlhYmxlczogZnVuY3Rpb24gZ2V0QWxsVmFyaWFibGVzKGVsKSB7XFxuICAgICAgICB2YXIganNvbiA9ICQoZWwpLmZpbmQoXFxcInNjcmlwdC5tbGFiX3N0b3JhZ2VcXFwiKS5odG1sKCk7XFxuICAgICAgICBpZiAodHlwZW9mIGpzb24gPT0gXFxcInVuZGVmaW5lZFxcXCIgfHwganNvbiA9PSBcXFwiXFxcIikge1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgdmFyIHZhcnMgPSBKU09OLnBhcnNlKGpzb24pO1xcbiAgICAgICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGUpO1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiB2YXJzO1xcbiAgICB9LFxcblxcbiAgICBnZXRUZW1wVmFyaWFibGU6IGZ1bmN0aW9uIGdldFRlbXBWYXJpYWJsZShjb21wLCBrZXkpIHtcXG4gICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQubWxhYl9kdF9zdG9yYWdlID09IFxcXCJ1bmRlZmluZWRcXFwiKSB7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudC5tbGFiX2R0X3N0b3JhZ2VbY29tcF0gPT0gXFxcInVuZGVmaW5lZFxcXCIpIHtcXG4gICAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuICAgICAgICBpZiAodHlwZW9mIGRvY3VtZW50Lm1sYWJfZHRfc3RvcmFnZVtjb21wXVtrZXldID09IFxcXCJ1bmRlZmluZWRcXFwiKSB7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50Lm1sYWJfZHRfc3RvcmFnZVtjb21wXVtrZXldO1xcbiAgICB9LFxcblxcbiAgICAvL3dyaXRlcyB0aGUgamF2YXNjcmlwdCB2YWx1ZSBhbmQgc3RvcmVzIGl0IGZvciB0aGUgc3BlY2lmaWVkIGVsZW1lbnRcXG4gICAgLyoqXFxyXFxuICAgICAqIFN0b3JlcyBhIEphdmFzY3JpcHQgdmFsdWUgZm9yIHRoZSBzcGVjaWZpZWQgZWxlbWVudC5cXHJcXG4gICAgICogVGhpcyBvbmx5IHdvcmtzIG9uIHRvcCBsZXZlbCB2YXJzLCBidXQgdGhlIHZhbHVlIGNhbiBiZSBhbiBvYmplY3Qgd2hpY2ggaW4gZWZmZWN0IGdpdmVzIGxvd2VyIGxldmVsIHN0b3JhZ2UgcG9zaWJpbGl0aWVzLlxcclxcbiAgICAgKiBcXHJcXG4gICAgICogVmFyaWFibGVzIGFyZSBzdG9yZWQgaW4gYSA8c2NyaXB0PiBvZiB0eXBlIGFwcGxpY2F0aW9uL2pzb24gYXMgc3RyaW5naWZpZWQgSlNPTiwgb24gdGhlIHNhbWUgbGV2ZWwgYXMgdGhlIG1haW4gY29tcG9uZW50IEhUTUw1IGNvZGUuXFxyXFxuICAgICAqIFRoZXNlIGFyZSBhbGwgY29udGFpbmVkIHdpdGhpbiBhIHdyYXBwZXIgRElWIHRoYXQgaXMgdGhlIGFjdHVhbCBET00gZWxlbWVudCBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvbi5cXHJcXG4gICAgICogQHBhcmFtIHtqUXVlcnkgRE9NIGVsZW1lbnR9IGVsXFxyXFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXksIHRoZSBrZXkgbmFtZSBpbiB0aGUgb2JqZWN0XFxyXFxuICAgICAqIEBwYXJhbSB7YW55dGhpbmd9IHZhbHVlXFxyXFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxcclxcbiAgICAgKi9cXG4gICAgc2V0VmFyaWFibGU6IGZ1bmN0aW9uIHNldFZhcmlhYmxlKGVsLCBrZXksIHZhbHVlKSB7XFxuICAgICAgICB2YXIgc2NycHQgPSAkKGVsKS5maW5kKFxcXCJzY3JpcHQubWxhYl9zdG9yYWdlXFxcIik7XFxuICAgICAgICBpZiAoc2NycHQubGVuZ3RoIDwgMSkge1xcbiAgICAgICAgICAgICQoZWwpLmFwcGVuZChcXFwiPHNjcmlwdCB0eXBlPSdhcHBsaWNhdGlvbi9qc29uJyBjbGFzcz0nbWxhYl9zdG9yYWdlJyAvPlxcXCIpO1xcbiAgICAgICAgICAgIHZhciB2YXJzID0gbmV3IE9iamVjdCgpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICB2YXIganNvbiA9IHNjcnB0Lmh0bWwoKTtcXG4gICAgICAgICAgICBpZiAoanNvbiAhPSBcXFwiXFxcIikge1xcbiAgICAgICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhcnMgPSBKU09OLnBhcnNlKGpzb24pO1xcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlKTtcXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YXJzID0gbmV3IE9iamVjdCgpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgdmFyIHZhcnMgPSBuZXcgT2JqZWN0KCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgdmFyc1trZXldID0gdmFsdWU7XFxuICAgICAgICAkKGVsKS5maW5kKFxcXCJzY3JpcHQubWxhYl9zdG9yYWdlXFxcIikuaHRtbChKU09OLnN0cmluZ2lmeSh2YXJzKSk7XFxuICAgICAgICB0aGlzLnNldERpcnR5KCk7XFxuICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxyXFxuICAgICAqIE92ZXJ3cml0ZXMgYWxsIHZhcmlhYmxlcyBmb3IgdGhlIHNwZWNpZmllZCBlbGVtZW50LCBjb21wbGVtZW50YXJ5IHRvIHRoZSBzZXRWYXJpYWJsZSBmdW5jdGlvblxcclxcbiAgICAgKiBcXHJcXG4gICAgICogVmFyaWFibGVzIGFyZSBzdG9yZWQgaW4gYSA8c2NyaXB0PiBvZiB0eXBlIGFwcGxpY2F0aW9uL2pzb24gYXMgc3RyaW5naWZpZWQgSlNPTiwgb24gdGhlIHNhbWUgbGV2ZWwgYXMgdGhlIG1haW4gY29tcG9uZW50IEhUTUw1IGNvZGUuXFxyXFxuICAgICAqIFRoZXNlIGFyZSBhbGwgY29udGFpbmVkIHdpdGhpbiBhIHdyYXBwZXIgRElWIHRoYXQgaXMgdGhlIGFjdHVhbCBET00gZWxlbWVudCBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvbi5cXHJcXG4gICAgICogQHBhcmFtIHtqUXVlcnkgRE9NIGVsZW1lbnR9IGVsXFxyXFxuICAgICAqIEBwYXJhbSB7YW55dGhpbmd9IHZhbHVlcyB0byBiZSBzdG9yZXNcXHJcXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XFxyXFxuICAgICAqL1xcbiAgICBzZXRBbGxWYXJpYWJsZXM6IGZ1bmN0aW9uIHNldEFsbFZhcmlhYmxlcyhlbCwgdmFsdWVzKSB7XFxuXFxuICAgICAgICB2YXIgc2NycHQgPSAkKGVsKS5maW5kKFxcXCJzY3JpcHQubWxhYl9zdG9yYWdlXFxcIik7XFxuICAgICAgICBpZiAoc2NycHQubGVuZ3RoIDwgMSkge1xcbiAgICAgICAgICAgICQoZWwpLmFwcGVuZChcXFwiPHNjcmlwdCB0eXBlPSdhcHBsaWNhdGlvbi9qc29uJyBjbGFzcz0nbWxhYl9zdG9yYWdlJyAvPlxcXCIpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgJChlbCkuZmluZChcXFwic2NyaXB0Lm1sYWJfc3RvcmFnZVxcXCIpLmh0bWwoSlNPTi5zdHJpbmdpZnkodmFsdWVzKSk7XFxuICAgICAgICB0aGlzLnNldERpcnR5KCk7XFxuICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxyXFxuICAgICAqIFRoaXMgZnVuY3Rpb24gc3RvcmVzIHRoaW5ncyBmb3IgdGhlIGN1cnJlbnQgc2Vzc2lvbiAoaS5lLiB0aGUgbGlmZXRpbWUgb2YgdGhpcyB3ZWJwYWdlKSBcXHJcXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbXAsIHRoZSBuYW1lIG9mIHRoZSBjb21wb25lbnRcXHJcXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGtleSwga2V5IHRvIGluZGV4LCB0aGUgY29tcG9uZW50IG11c3QgaXRzZWxmIGVuc3VyZSB0aGF0IHRoaXMgaXMgdW5pcXVlLCBmb3IgaW5zdGFuY2UgYnkgdXNpbmcgXFxcInh4eHhcXFwiICsgbXlfdW5pcXVlX2lkXFxyXFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZVxcclxcbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxcclxcbiAgICAgKi9cXG4gICAgc2V0VGVtcFZhcmlhYmxlOiBmdW5jdGlvbiBzZXRUZW1wVmFyaWFibGUoY29tcCwga2V5LCB2YWx1ZSkge1xcbiAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudC5tbGFiX2R0X3N0b3JhZ2UgPT0gXFxcInVuZGVmaW5lZFxcXCIpIHtcXG4gICAgICAgICAgICBkb2N1bWVudC5tbGFiX2R0X3N0b3JhZ2UgPSB7fTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQubWxhYl9kdF9zdG9yYWdlW2NvbXBdID09IFxcXCJ1bmRlZmluZWRcXFwiKSB7XFxuICAgICAgICAgICAgZG9jdW1lbnQubWxhYl9kdF9zdG9yYWdlW2NvbXBdID0ge307XFxuICAgICAgICB9XFxuICAgICAgICBpZiAodHlwZW9mIGRvY3VtZW50Lm1sYWJfZHRfc3RvcmFnZVtjb21wXVtrZXldID09IFxcXCJ1bmRlZmluZWRcXFwiKSB7XFxuICAgICAgICAgICAgZG9jdW1lbnQubWxhYl9kdF9zdG9yYWdlW2NvbXBdW2tleV0gPSB7fTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGRvY3VtZW50Lm1sYWJfZHRfc3RvcmFnZVtjb21wXVtrZXldID0gdmFsdWU7XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcclxcbiAgICAgKiBUaGlzIHVwZGF0ZXMgdGhlIHNjcmlwdCBmb3IgYSBjb250cm9sLCB0aGlzIGlzIHdyaXRlIG9ubHkgYXMgaXQgc2hvdWxkIGFsd2F5cyBiZSBnZW5lcmF0ZWQgZnJvbSB1c2VyIGlucHV0IGFuZCB2YXJpYWJsZXMhXFxyXFxuICAgICAqIEl0IHRoZXJlZm9yZSBhbHNvIGFsd2F5cyByZXBsYWNlcyBleGlzdGluZyBjb250ZW50IGluIHRoZSBzY3JpcHQgZWxlbWVudFxcclxcbiAgICAgKiBAcGFyYW0ge2pRdWVyeSBET00gZWxlbWVudH0gZWxcXHJcXG4gICAgICogQHBhcmFtIHt0ZXh0fSBjb2RlLCBhbnkgSmF2YXNjcmlwdCBjb21wYXRpYmxlIHN0YXRlbWVudHNcXHJcXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XFxyXFxuICAgICAqL1xcbiAgICBzZXRTY3JpcHQ6IGZ1bmN0aW9uIHNldFNjcmlwdChlbCwgY29kZSkge1xcbiAgICAgICAgdmFyIHNjcnB0ID0gJChlbCkuZmluZChcXFwic2NyaXB0Lm1sYWJfY29kZVxcXCIpO1xcbiAgICAgICAgaWYgKHNjcnB0Lmxlbmd0aCA+IDApIHtcXG4gICAgICAgICAgICBzY3JwdC5yZW1vdmUoKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHNjcnB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwic2NyaXB0XFxcIik7XFxuICAgICAgICBzY3JwdC50eXBlID0gXFxcInRleHQvamF2YXNjcmlwdFxcXCI7XFxuICAgICAgICBzY3JwdC5jbGFzc05hbWUgPSBcXFwibWxhYl9jb2RlXFxcIjtcXG4gICAgICAgIHNjcnB0LnRleHQgPSBjb2RlO1xcbiAgICAgICAgJChlbCkuYXBwZW5kKHNjcnB0KTtcXG5cXG4gICAgICAgIHJldHVybiB0cnVlO1xcbiAgICB9LFxcblxcbiAgICAvKioqXFxyXFxuICAgICAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gZ2V0IHRoZSBBIGVsZW1lbnQgcGFyZW50IG9mIGEgc2VsZWN0aW9uIGFyZWFcXHJcXG4gICAgICogQHJldHVybnMge1N0cmluZ3xCb29sZWFufVxcclxcbiAgICAgKi9cXG4gICAgZ2V0U2VsVGV4dFBhcmVudExpbmtFbGVtZW50OiBmdW5jdGlvbiBnZXRTZWxUZXh0UGFyZW50TGlua0VsZW1lbnQoKSB7XFxuICAgICAgICB2YXIgZWwsIHNlbCwgbm9kZTtcXG4gICAgICAgIHNlbCA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcXG4gICAgICAgIGlmIChzZWwucmFuZ2VDb3VudCkge1xcbiAgICAgICAgICAgIGVsID0gc2VsLmdldFJhbmdlQXQoMCkuY29tbW9uQW5jZXN0b3JDb250YWluZXI7XFxuICAgICAgICAgICAgbm9kZSA9IGVsLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XFxuICAgICAgICAgICAgd2hpbGUgKG5vZGUgIT0gJ2EnICYmIG5vZGUgIT0gXFxcImJvZHlcXFwiKSB7XFxuICAgICAgICAgICAgICAgIGVsID0gZWwucGFyZW50Tm9kZTtcXG4gICAgICAgICAgICAgICAgbm9kZSA9IGVsLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKG5vZGUgPT0gJ2EnKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGVsO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICB9XFxuICAgIH0sXFxuXFxuICAgIC8qKipcXHJcXG4gICAgICogVXRpbGl0eSBmdW5jdGlvbiB0byBjaGVjayB0aGF0IHRoZSBjdXJyZW50IHNlbGVjdGlvbiBpcyBpbnNpZGUgdGhlIGN1cnJlbnQgbWxhYiBjb21wb25lbnRcXHJcXG4gICAgICogQHJldHVybnMge1N0cmluZ3xCb29sZWFufVxcclxcbiAgICAgKi9cXG4gICAgY2hlY2tTZWxUZXh0VmFsaWQ6IGZ1bmN0aW9uIGNoZWNrU2VsVGV4dFZhbGlkKCkge1xcbiAgICAgICAgdmFyIGVsLCBzZWwsIG5vZGU7XFxuICAgICAgICBzZWwgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XFxuICAgICAgICBpZiAoc2VsLnRvU3RyaW5nKCkgIT0gXFxcIlxcXCIpIHtcXG4gICAgICAgICAgICBlbCA9IHNlbC5nZXRSYW5nZUF0KDApLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyO1xcbiAgICAgICAgICAgIGlmICgkKGVsKS5oYXNDbGFzcyhcXFwibWxhYl9jdXJyZW50X2NvbXBvbmVudFxcXCIpIHx8ICQoZWwpLnBhcmVudHMoXFxcImRpdi5tbGFiX2N1cnJlbnRfY29tcG9uZW50XFxcIikubGVuZ3RoID4gMCkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH0sXFxuXFxuICAgIHVwZGF0ZV9uZXdwYWdlX2xpbms6IGZ1bmN0aW9uIHVwZGF0ZV9uZXdwYWdlX2xpbmsoZGF0YSkge1xcbiAgICAgICAgaWYgKGRhdGEucmVzdWx0ID09IFxcXCJzdWNjZXNzXFxcIikge1xcbiAgICAgICAgICAgICQoXFxcIi5tbGFiX2N1cnJlbnRfY29tcG9uZW50XFxcIikuZmluZChcXFwiYVtocmVmPU1MQUJfRFRfTElOS19URU1QXVxcXCIpLmF0dHIoXFxcImhyZWZcXFwiLCBcXFwiI1xcXCIpLmF0dHIoXFxcIm9uY2xpY2tcXFwiLCAnbWxhYi5hcGkubmF2aWdhdGlvbi5wYWdlRGlzcGxheSgnICsgZGF0YS5uZXdfcGFnZV9udW0gKyAnKTsgcmV0dXJuIGZhbHNlOycpO1xcbiAgICAgICAgICAgIG1sYWIuZHQuYXBwLnBhZ2VfbmFtZXMgPSBkYXRhLnBhZ2VfbmFtZXM7XFxuICAgICAgICAgICAgbWxhYi5kdC5tYW5hZ2VtZW50LmFwcF91cGRhdGVfZ3VpX21ldGFkYXRhKHRydWUpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAkKFxcXCIubWxhYl9jdXJyZW50X2NvbXBvbmVudFxcXCIpLmZpbmQoXFxcImFbaHJlZj1NTEFCX0RUX0xJTktfVEVNUF1cXFwiKS5jb250ZW50cygpLnVud3JhcCgpO1xcbiAgICAgICAgfVxcbiAgICB9LFxcblxcbiAgICAvKipcXHJcXG4gICAgICogXFxyXFxuICAgICAqIExpbmtzIHRvIHBhZ2VzIG11c3QgdXNlIHRoZSBhcGkgY2FsbCBuYXZpZ2F0aW9uLnBhZ2VEaXNwbGF5LCBsaW5rcyB0byBleHRlcm5hbCBwYWdlcyBtdXN0IHVzZSBfbmV3IGFzIHRoZSB0YXJnZXQgdmFsdWUuXFxyXFxuICAgICAqIEluIHRoZSBvcHRpb24gbGlzdCBpbiB0aGUgZGlhbG9nIGJveCBwYWdlcyBhcmUgbGlzdGVkIHdpdGggZmlsZW5hbWUgYXMgdmFsdWUgYW5kIHRpdGxlIGFzIGRpc3BsYXllZCB0ZXh0XFxyXFxuICAgICAqIEBwYXJhbSB7dHlwZX0gbGlua1xcclxcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cXHJcXG4gICAgICovXFxuICAgIHVwZGF0ZUxpbms6IGZ1bmN0aW9uIHVwZGF0ZUxpbmsoKSB7XFxuICAgICAgICB2YXIgbGlua190eXBlID0gJChcXFwiaW5wdXQ6cmFkaW9bbmFtZT1tbGFiX2R0X2dldGxpbmtfY2hvaWNlXTpjaGVja2VkXFxcIikudmFsKCk7XFxuICAgICAgICB2YXIgbGluayA9IFxcXCJcXFwiO1xcbiAgICAgICAgdmFyIHBhZ2VfbmFtZTtcXG5cXG4gICAgICAgIGlmIChsaW5rX3R5cGUgPT0gXFxcInBhZ2VcXFwiKSB7XFxuICAgICAgICAgICAgbGluayA9ICQoXFxcIiNtbGFiX2R0X2xpbmtfYXBwX3BhZ2VzXFxcIikudmFsKCk7XFxuICAgICAgICAgICAgaWYgKGxpbmspIHtcXG4gICAgICAgICAgICAgICAgcGFnZV9udW0gPSBwYXJzZUludChsaW5rKTtcXG4gICAgICAgICAgICAgICAgJChcXFwiLm1sYWJfY3VycmVudF9jb21wb25lbnRcXFwiKS5maW5kKFxcXCJhW2hyZWY9TUxBQl9EVF9MSU5LX1RFTVBdXFxcIikuYXR0cihcXFwiaHJlZlxcXCIsIFxcXCIjXFxcIikuYXR0cihcXFwib25jbGlja1xcXCIsICdtbGFiLmFwaS5uYXZpZ2F0aW9uLnBhZ2VEaXNwbGF5KCcgKyBwYWdlX251bSArICcpOyByZXR1cm4gZmFsc2U7Jyk7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgYWxlcnQoX3RyW1xcXCJtbGFiLmR0LmFwaS5qcy5nZXRMaW5rLmFsZXJ0X25vX3BhZ2VcXFwiXSk7XFxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2UgaWYgKGxpbmtfdHlwZSA9PSBcXFwidXJsXFxcIikge1xcbiAgICAgICAgICAgIGxpbmsgPSAkKFxcXCIjbWxhYl9kdF9saW5rX2FwcF91cmxcXFwiKS52YWwoKTtcXG4gICAgICAgICAgICBpZiAoL14oaHR0cHM/fGZ0cCk6XFxcXC9cXFxcLygoKChbYS16XXxcXFxcZHwtfFxcXFwufF98fnxbXFxcXHUwMEEwLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkVGXSl8KCVbXFxcXGRhLWZdezJ9KXxbIVxcXFwkJidcXFxcKFxcXFwpXFxcXCpcXFxcKyw7PV18OikqQCk/KCgoXFxcXGR8WzEtOV1cXFxcZHwxXFxcXGRcXFxcZHwyWzAtNF1cXFxcZHwyNVswLTVdKVxcXFwuKFxcXFxkfFsxLTldXFxcXGR8MVxcXFxkXFxcXGR8MlswLTRdXFxcXGR8MjVbMC01XSlcXFxcLihcXFxcZHxbMS05XVxcXFxkfDFcXFxcZFxcXFxkfDJbMC00XVxcXFxkfDI1WzAtNV0pXFxcXC4oXFxcXGR8WzEtOV1cXFxcZHwxXFxcXGRcXFxcZHwyWzAtNF1cXFxcZHwyNVswLTVdKSl8KCgoW2Etel18XFxcXGR8W1xcXFx1MDBBMC1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZFRl0pfCgoW2Etel18XFxcXGR8W1xcXFx1MDBBMC1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZFRl0pKFthLXpdfFxcXFxkfC18XFxcXC58X3x+fFtcXFxcdTAwQTAtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRUZdKSooW2Etel18XFxcXGR8W1xcXFx1MDBBMC1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZFRl0pKSlcXFxcLikrKChbYS16XXxbXFxcXHUwMEEwLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkVGXSl8KChbYS16XXxbXFxcXHUwMEEwLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkVGXSkoW2Etel18XFxcXGR8LXxcXFxcLnxffH58W1xcXFx1MDBBMC1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZFRl0pKihbYS16XXxbXFxcXHUwMEEwLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkVGXSkpKVxcXFwuPykoOlxcXFxkKik/KShcXFxcLygoKFthLXpdfFxcXFxkfC18XFxcXC58X3x+fFtcXFxcdTAwQTAtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRUZdKXwoJVtcXFxcZGEtZl17Mn0pfFshXFxcXCQmJ1xcXFwoXFxcXClcXFxcKlxcXFwrLDs9XXw6fEApKyhcXFxcLygoW2Etel18XFxcXGR8LXxcXFxcLnxffH58W1xcXFx1MDBBMC1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZFRl0pfCglW1xcXFxkYS1mXXsyfSl8WyFcXFxcJCYnXFxcXChcXFxcKVxcXFwqXFxcXCssOz1dfDp8QCkqKSopPyk/KFxcXFw/KCgoW2Etel18XFxcXGR8LXxcXFxcLnxffH58W1xcXFx1MDBBMC1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZFRl0pfCglW1xcXFxkYS1mXXsyfSl8WyFcXFxcJCYnXFxcXChcXFxcKVxcXFwqXFxcXCssOz1dfDp8QCl8W1xcXFx1RTAwMC1cXFxcdUY4RkZdfFxcXFwvfFxcXFw/KSopPyhcXFxcIygoKFthLXpdfFxcXFxkfC18XFxcXC58X3x+fFtcXFxcdTAwQTAtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRUZdKXwoJVtcXFxcZGEtZl17Mn0pfFshXFxcXCQmJ1xcXFwoXFxcXClcXFxcKlxcXFwrLDs9XXw6fEApfFxcXFwvfFxcXFw/KSopPyQvaS50ZXN0KGxpbmspKSB7XFxuICAgICAgICAgICAgICAgIHBhZ2VfbmFtZSA9IGxpbmsudHJpbSgpO1xcbiAgICAgICAgICAgICAgICAkKFxcXCIubWxhYl9jdXJyZW50X2NvbXBvbmVudFxcXCIpLmZpbmQoXFxcImFbaHJlZj1NTEFCX0RUX0xJTktfVEVNUF1cXFwiKS5hdHRyKFxcXCJocmVmXFxcIiwgcGFnZV9uYW1lKTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICBhbGVydChfdHJbXFxcIm1sYWIuZHQuYXBpLmpzLmdldExpbmsuYWxlcnRfdXJsX3dyb25nXFxcIl0pO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIGlmIChsaW5rX3R5cGUgPT0gXFxcIm5ld3BhZ2VcXFwiKSB7XFxuICAgICAgICAgICAgdmFyIHBhZ2VfdGl0bGUgPSAkKFxcXCIjbWxhYl9kdF9saW5rX2FwcF9uZXdfcGFnZVxcXCIpLnZhbCgpO1xcbiAgICAgICAgICAgIGlmIChwYWdlX3RpdGxlKSB7XFxuICAgICAgICAgICAgICAgIG1sYWIuZHQubWFuYWdlbWVudC5wYWdlX25ld19pbl9iYWNrZ3JvdW5kKHBhZ2VfdGl0bGUsIHRoaXMudXBkYXRlX25ld3BhZ2VfbGluayk7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgYWxlcnQoX3RyW1xcXCJtbGFiLmR0LmFwaS5qcy5nZXRMaW5rLmFsZXJ0X25vX3RpdGxlXFxcIl0pO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBhbGVydChfdHJbXFxcIm1sYWIuZHQuYXBpLmpzLmdldExpbmsuYWxlcnRfY2hvb3NlX3R5cGVcXFwiXSk7XFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcclxcbiAgICAgKiBBc2tzIGEgdXNlciBmb3IgYSBsaW5rIGVpdGhlciB0byBhIGV4dGVybmFsIHBhZ2Ugb3IgdG8gYSBwYWdlIGluIHRoZSBjdXJyZW50IGFwcC5cXHJcXG4gICAgICogVGhlIGFjdHVhbCBsaW5rIGlzIGNyZWF0ZWQgaW4gdXBkYXRlTGluayBhYm92ZVxcclxcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbnxTdHJpbmd9XFxyXFxuICAgICAqL1xcbiAgICBzZXRMaW5rOiBmdW5jdGlvbiBzZXRMaW5rKGVsLCBldmVudCkge1xcbiAgICAgICAgLy93ZSBtdXN0IGZpcnN0IG9mIGFsbCBjaGVjayB0aGF0IHNvbSB0ZXh0IGlzIGNob3NlbiBpbnNpZGUgdGhlIGN1cnJlbnQgY29tcG9uZW50XFxuICAgICAgICBpZiAoIXRoaXMuY2hlY2tTZWxUZXh0VmFsaWQoKSkge1xcbiAgICAgICAgICAgIGFsZXJ0KF90cltcXFwibWxhYi5kdC5hcGkuanMuZ2V0TGluay5ub19zZWxlY3Rpb25cXFwiXSk7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgLy93ZSBuZWVkIHRvIGNyZWF0ZSBhIHRlbXBvcmFyeSBsaW5rIHN0cmFpZ2h0IGF3YXkgc28gdGhhdCB3ZSBjYW4gcmVmZXIgdG8gaXQgbGF0ZXIsIG90aGVyd2lzZSB0aGUgc2VsZWN0aW9uIHdpbGwgZGlzYXBwZWFyLlxcbiAgICAgICAgZG9jdW1lbnQuZXhlY0NvbW1hbmQoJ2NyZWF0ZWxpbmsnLCBmYWxzZSwgXFxcIk1MQUJfRFRfTElOS19URU1QXFxcIik7XFxuICAgICAgICAvL3dlIHNldCBhIGRhdGEgdGFnLCBiZWNhdXNlIHdlJ2xsIHVzZSBhbiBBUEkgY2FsbCBpZiB0aGV5IGxpbmsgdG8gYW5vdGhlciBwYWdlLCBldGNcXG4gICAgICAgICQoXFxcIi5tbGFiX2N1cnJlbnRfY29tcG9uZW50XFxcIikuZmluZChcXFwiYVtocmVmPU1MQUJfRFRfTElOS19URU1QXVxcXCIpLmFkZENsYXNzKCdtY19saW5rIG1jX3RleHQnKS5hdHRyKCdkYXRhLW1sYWItaXNsaW5rJywgMSkuY2xpY2soZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICB9KTtcXG5cXG4gICAgICAgIC8vd2UgbmVlZCB0byByZXF1ZXN0IHRoZSBVUkwgKk9SKiB3aGljaCBwYWdlIHRvIGxpbmsgdG9cXG4gICAgICAgIHZhciBvcHQgPSBcXFwiPG9wdGlvbiB2YWx1ZT0nLTEnPjwvb3B0aW9uPlxcXCI7XFxuICAgICAgICBmb3IgKHBvcyBpbiBtbGFiLmR0LmFwcC5wYWdlX25hbWVzKSB7XFxuICAgICAgICAgICAgb3B0ID0gb3B0ICsgXFxcIjxvcHRpb24gdmFsdWU9J1xcXCIgKyBtbGFiLmR0LmFwcC5wYWdlX25hbWVzW3Bvc11bXFxcImZpbGVuYW1lXFxcIl0gKyBcXFwiJz5cXFwiICsgbWxhYi5kdC5hcHAucGFnZV9uYW1lc1twb3NdW1xcXCJ0aXRsZVxcXCJdICsgXFxcIjwvb3B0aW9uPlxcXCI7XFxuICAgICAgICB9XFxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XFxuICAgICAgICB2YXIgY29udGVudCA9ICQoJzxkaXYgaWQ9XFxcIm1sYWJfZHRfbGlua19kaWFsb2dcXFwiPicgKyAnPGJyPjxsYWJlbCBjbGFzcz1cXFwibWxhYl9kdF9sYWJlbFxcXCI+PGlucHV0IHR5cGU9XFxcInJhZGlvXFxcIiBuYW1lPVxcXCJtbGFiX2R0X2dldGxpbmtfY2hvaWNlXFxcIiB2YWx1ZT1cXFwicGFnZVxcXCIgY2xhc3M9XFxcIm1sYWJfZHRfaW5wdXRcXFwiPicgKyBfdHJbXFxcIm1sYWIuZHQuYXBpLmpzLmdldExpbmsuYXBwX3BhZ2VcXFwiXSArICc8L2xhYmVsPjxicj4nICsgJzxzZWxlY3QgaWQ9XFxcIm1sYWJfZHRfbGlua19hcHBfcGFnZXNcXFwiIGNsYXNzPVxcXCJtbGFiX2R0X3NlbGVjdFxcXCI+JyArIG9wdCArICc8L3NlbGVjdD48YnI+JyArICc8bGFiZWwgY2xhc3M9XFxcIm1sYWJfZHRfbGFiZWxcXFwiPjxpbnB1dCB0eXBlPVxcXCJyYWRpb1xcXCIgbmFtZT1cXFwibWxhYl9kdF9nZXRsaW5rX2Nob2ljZVxcXCIgdmFsdWU9XFxcInVybFxcXCIgY2xhc3M9XFxcIm1sYWJfZHRfaW5wdXRcXFwiPicgKyBfdHJbXFxcIm1sYWIuZHQuYXBpLmpzLmdldExpbmsudXJsXFxcIl0gKyAnPC9sYWJlbD48YnI+JyArICc8aW5wdXQgdHlwZT1cXFwidGV4dFxcXCIgaWQ9XFxcIm1sYWJfZHRfbGlua19hcHBfdXJsXFxcIiBjbGFzcz1cXFwibWxhYl9kdF9pbnB1dFxcXCI+JyArICc8YnI+JyArICc8bGFiZWwgY2xhc3M9XFxcIm1sYWJfZHRfbGFiZWxcXFwiPjxpbnB1dCB0eXBlPVxcXCJyYWRpb1xcXCIgbmFtZT1cXFwibWxhYl9kdF9nZXRsaW5rX2Nob2ljZVxcXCIgdmFsdWU9XFxcIm5ld3BhZ2VcXFwiIGNsYXNzPVxcXCJtbGFiX2R0X2lucHV0XFxcIj4nICsgX3RyW1xcXCJtbGFiLmR0LmFwaS5qcy5nZXRMaW5rLm5ld19wYWdlXFxcIl0gKyAnPC9sYWJlbD48YnI+JyArICc8aW5wdXQgdHlwZT1cXFwidGV4dFxcXCIgaWQ9XFxcIm1sYWJfZHRfbGlua19hcHBfbmV3X3BhZ2VcXFwiIGNsYXNzPVxcXCJtbGFiX2R0X2lucHV0XFxcIj4nICsgJzxicj4nICsgJzwvZGl2PicpO1xcblxcbiAgICAgICAgY29udGVudC5hcHBlbmQoJzxidXR0b24gY2xhc3M9XFxcIm1sYWJfZHRfYnV0dG9uX29rIG1sYWJfZHRfcmlnaHRcXFwiIG9uY2xpY2s9XFxcIiBpZiAodGhhdC51cGRhdGVMaW5rKCkpIHttbGFiLmR0LmFwaS5jbG9zZUFsbFByb3BlcnR5RGlhbG9ncygpO31cXFwiPicgKyBfdHJbXFxcIm1sYWIuZHQuYXBpLmpzLmdldExpbmsub2tcXFwiXSArICc8L2J1dHRvbj4nKTtcXG4gICAgICAgIGNvbnRlbnQuYXBwZW5kKCc8YnV0dG9uIGNsYXNzPVxcXCJtbGFiX2R0X2J1dHRvbl9jYW5jZWwgbWxhYl9kdF9yaWdodFxcXCIgb25jbGljaz1cXFwiIHRoYXQuY2FuY2VsTGluaygpO1xcXCI+JyArIF90cltcXFwibWxhYi5kdC5hcGkuanMuZ2V0TGluay5jYW5jZWxcXFwiXSArICc8L2J1dHRvbj4nKTtcXG5cXG4gICAgICAgIHZhciB0aXRsZSA9IF90cltcXFwibWxhYi5kdC5hcGkuanMuZ2V0TGluay5oZWFkaW5nXFxcIl07XFxuXFxuICAgICAgICB0aGlzLmRpc3BsYXlQcm9wZXJ0eURpYWxvZyhlbCwgdGl0bGUsIGNvbnRlbnQsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAkKFxcXCIucXRpcC1jbG9zZVxcXCIpLm9uKFxcXCJjbGlja1xcXCIsIHRoYXQuY2FuY2VsTGluayk7XFxuICAgICAgICB9LCBudWxsLCBudWxsLCBudWxsLCBmYWxzZSwgZXZlbnQpO1xcbiAgICB9LFxcblxcbiAgICAvLyByZW1vdmUgdGhlIGxpbmsgZnJvbSB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHRleHRcXG4gICAgY2FuY2VsTGluazogZnVuY3Rpb24gY2FuY2VsTGluaygpIHtcXG4gICAgICAgICQoXFxcIi5tbGFiX2N1cnJlbnRfY29tcG9uZW50XFxcIikuZmluZChcXFwiYVtocmVmPU1MQUJfRFRfTElOS19URU1QXVxcXCIpLmNvbnRlbnRzKCkudW53cmFwKCk7XFxuICAgICAgICBtbGFiLmR0LmFwaS5jbG9zZUFsbFByb3BlcnR5RGlhbG9ncygpO1xcbiAgICB9LFxcblxcbiAgICByZW1vdmVMaW5rOiBmdW5jdGlvbiByZW1vdmVMaW5rKCkge1xcbiAgICAgICAgLy9jb3VsZCB1c2UgLy9kb2N1bWVudC5leGVjQ29tbWFuZChcXFwidW5saW5rXFxcIiwgZmFsc2UsIGZhbHNlKTssIGJ1dCBhdm9pZGluZyBhcyBkb2VzIG9ubHkgcmVtb3ZlIGxpbmtzIG9uIHNlbGVjdGVkIGFyZWFcXG4gICAgICAgIHZhciBsaW5rID0gdGhpcy5nZXRTZWxUZXh0UGFyZW50TGlua0VsZW1lbnQoKTtcXG4gICAgICAgIGlmIChsaW5rKSB7XFxuICAgICAgICAgICAgaWYgKCQobGluaykucGFyZW50cyhcXFwiI21sYWJfZWRpdGFibGVfYXJlYVxcXCIpLmxlbmd0aCA+IDApIHtcXG4gICAgICAgICAgICAgICAgJChsaW5rKS5yZXBsYWNlV2l0aCgkKGxpbmspLmNvbnRlbnRzKCkpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgfSxcXG5cXG4gICAgLyoqXFxyXFxuICAgICAgKiBSZXF1ZXN0cyBjcmVkZW50aWFscyBzdWNoIGFzIGxvZ2luIG5hbWUgYW5kIHBhc3N3b3JkIChmb3IgaW5zdGFuY2UsIGNhbiBhbHNvIGJlIFVSTCB0byB1c2UsIGRhdGFiYXNlIG5hbWUsIGV0YylcXHJcXG4gICAgICAqIFRoZXNlIGFyZSBhbGwganVzdCB0cmVhdGVkIGFzIHN0cmluZ3MgYW5kIHJldHVybmVkIGFzIGFuIGFycmF5IG9mIHN0cmluZ3MuIFxcclxcbiAgICAgICogQHBhcmFtIHt0eXBlfSBlbFxcclxcbiAgICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbXBvbmVudF9pZFxcclxcbiAgICAgICogQHBhcmFtIHt0eXBlfSBjcmVkZW50aWFsc19yZXF1aXJlZFxcclxcbiAgICAgICogQHBhcmFtIHt0eXBlfSBjYl9mdW5jdGlvblxcclxcbiAgICAgICogQHBhcmFtIHtCb29sZWFufSBlZGl0IC0gaWYgdHJ1ZSBzaG93cyB0aGUgY3JlZGVudGlhbCBkaWFsb2d1ZVxcclxcbiAgICAgICogQHBhcmFtIHt0eXBlfSBwYXJhbXM6IHRoaXMgaXMgYSBqcyBvYmplY3Qgd2l0aCBrZXk6dmFsdWUgcGFpcnMsIGl0IHdpbGwgQUxXQVlTIGNvbnRhaW4gYSBwYWFtZXRlciBjYWxsZWQgY29tcG9uZW50IHdoaWNoIGlzIHRoZSBNbGFiIGNvbXBvbmVudCBiZWluZyB3b3JrZWQgb25cXHJcXG4gICAgICAqIEByZXR1cm5zIHtCb29sZWFufEFycmF5IG9mIHN0cmluZ3N9XFxyXFxuICAgICAqL1xcbiAgICBnZXRDcmVkZW50aWFsczogZnVuY3Rpb24gZ2V0Q3JlZGVudGlhbHMoZWwsIGNvbXBvbmVudF9pZCwgY3JlZGVudGlhbHNfcmVxdWlyZWQsIGNiX2Z1bmN0aW9uLCBlZGl0LCBwYXJhbXMpIHtcXG4gICAgICAgIHZhciBkZWZhdWx0X2NyZWRfdmFsdWVzID0gbWxhYi5kdC5jb21wb25lbnRzW2NvbXBvbmVudF9pZF0uY29uZi5jcmVkZW50aWFsX3ZhbHVlcztcXG4gICAgICAgIHZhciBuZWVkaW5mbyA9IGZhbHNlO1xcbiAgICAgICAgdmFyIHNhdmVkX2NyZWRfdmFsdWVzID0gdGhpcy5nZXRWYXJpYWJsZShwYXJhbXMuY29tcG9uZW50LCBcXFwic3RvcmFnZV9wbHVnaW5cXFwiKTsgLy9wYXJhbXMuY29tcG9uZW50IGlzIGFsd2F5cyBzZXQgdG8gdGhlIGFjdGl2ZSBNbGFiIGNvbXBvbmVudFxcbiAgICAgICAgaWYgKHNhdmVkX2NyZWRfdmFsdWVzKSB7XFxuICAgICAgICAgICAgc2F2ZWRfY3JlZF92YWx1ZXMgPSBzYXZlZF9jcmVkX3ZhbHVlc1tcXFwiY3JlZGVudGlhbHNcXFwiXTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIC8vaWYgdGhlIHZhbHVlcyBhcmUgYWxyZWFkeSBzYXZlZCwgZWl0aGVyIGJlY2F1c2UgdGhlIGRlZmF1bHQgd2FzIHN0b3JlZCB3aGVuIGFkZGluZyBzdG9yYWdlIHBsdWdpbiwgXFxuICAgICAgICAvL29yIGJlY2F1c2UgdGhleSBzaW5jZSBiZWVuIGVkaXRlZCBvciB0aGV5IGFyZSBtaXNzaW5nIGFsdG9nZXRoZXIgdGhlbiB3ZSBuZWVkIHRvIHJlcXVlc3QgdGhlbVxcbiAgICAgICAgaWYgKHNhdmVkX2NyZWRfdmFsdWVzKSB7XFxuICAgICAgICAgICAgdmFyIGNyZWRfdmFsdWVzID0gc2F2ZWRfY3JlZF92YWx1ZXM7XFxuXFxuICAgICAgICAgICAgLy9ub3RoaW5nIHNhdmVkLCBhbmQgZGVmYXVsdCB2YWx1ZXMgZXhpc3QsIHNvIHdlIGp1c3Qgc2F2ZSBpdFxcbiAgICAgICAgfSBlbHNlIGlmIChkZWZhdWx0X2NyZWRfdmFsdWVzKSB7XFxuICAgICAgICAgICAgZm9yIChjcmVkZW50aWFsIGluIGNyZWRlbnRpYWxzX3JlcXVpcmVkKSB7XFxuICAgICAgICAgICAgICAgIGlmICghZGVmYXVsdF9jcmVkX3ZhbHVlc1tjcmVkZW50aWFsc19yZXF1aXJlZFtjcmVkZW50aWFsXV0pIHtcXG4gICAgICAgICAgICAgICAgICAgIG5lZWRpbmZvID0gdHJ1ZTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB2YXIgY3JlZF92YWx1ZXMgPSBkZWZhdWx0X2NyZWRfdmFsdWVzO1xcblxcbiAgICAgICAgICAgIC8vaGF2ZSBubyBkYXRhIGF0IGFsbCwgbmVlZCB0byByZXF1ZXN0XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIG5lZWRpbmZvID0gdHJ1ZTtcXG4gICAgICAgICAgICB2YXIgY3JlZF92YWx1ZXMgPSBuZXcgQXJyYXkoKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChuZWVkaW5mbyB8fCBlZGl0KSB7XFxuICAgICAgICAgICAgdmFyIGRsZyA9ICQoJzxkaXYgLz4nLCB7ICdpZCc6IFxcXCJtbGFiX2R0X2RpYWxvZ19jcmVkZW50aWFsc1xcXCIsIHRpdGxlOiBfdHJbXFxcIm1sYWIuZHQuYXBpLmpzLmdldENyZWRlbnRpYWxzLmRsZy50aXRsZVxcXCJdIH0pO1xcbiAgICAgICAgICAgIGRsZy5hcHBlbmQoJCgnPHAgLz4nLCB7IHRleHQ6IF90cltcXFwibWxhYi5kdC5hcGkuanMuZ2V0Q3JlZGVudGlhbHMuZGxnLnRleHRcXFwiXSxcXG4gICAgICAgICAgICAgICAgJ2NsYXNzJzogJ21sYWJfZHRfdGV4dF9pbmZvJyB9KSk7XFxuXFxuICAgICAgICAgICAgZm9yIChjcmVkZW50aWFsIGluIGNyZWRlbnRpYWxzX3JlcXVpcmVkKSB7XFxuICAgICAgICAgICAgICAgIHZhciBjcmVkZW50aWFsX2lkID0gY3JlZGVudGlhbHNfcmVxdWlyZWRbY3JlZGVudGlhbF07XFxuXFxuICAgICAgICAgICAgICAgIGRsZy5hcHBlbmQoJCgnPGxhYmVsIC8+JywgeyB0ZXh0OiBjcmVkZW50aWFsX2lkLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgY3JlZGVudGlhbF9pZC5zbGljZSgxKSxcXG4gICAgICAgICAgICAgICAgICAgICdmb3InOiAnbWxhYl9kdF9kaWFsb2dfY3JlZGVudGlhbHNfJyArIGNyZWRlbnRpYWxfaWQsXFxuICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiAnbWxhYl9kdF9zaG9ydF9sYWJlbCcgfSkpO1xcbiAgICAgICAgICAgICAgICBkbGcuYXBwZW5kKCQoJzxpbnB1dCAvPicsIHsgbmFtZTogJ21sYWJfZHRfZGlhbG9nX2NyZWRlbnRpYWxzXycgKyBjcmVkZW50aWFsX2lkLFxcbiAgICAgICAgICAgICAgICAgICAgJ2lkJzogJ21sYWJfZHRfZGlhbG9nX2NyZWRlbnRpYWxzXycgKyBjcmVkZW50aWFsX2lkLFxcbiAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogJ21sYWJfZHRfaW5wdXQnLFxcbiAgICAgICAgICAgICAgICAgICAgJ3ZhbHVlJzogdHlwZW9mIGNyZWRfdmFsdWVzW2NyZWRlbnRpYWxfaWRdID09PSAndW5kZWZpbmVkJyA/IFxcXCJcXFwiIDogY3JlZF92YWx1ZXNbY3JlZGVudGlhbF9pZF0gfSkpO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBkbGcuYXBwZW5kKCQoJzxkaXYgY2xhc3M9XFxcIm1sYWJfZHRfYnV0dG9uX3NtYWxsX25ld19saW5lXFxcIj4mbmJzcDs8L2Rpdj4nKSk7XFxuICAgICAgICAgICAgZGxnLmFwcGVuZCgkKCc8YnV0dG9uIGNsYXNzPVxcXCJtbGFiX2R0X2J1dHRvbiBtbGFiX2R0X3JpZ2h0XFxcIj4nICsgX3RyW1xcXCJtbGFiLmR0LmFwaS5qcy5nZXRDcmVkZW50aWFscy5kbGcuc2F2ZVxcXCJdICsgJzwvYnV0dG9uPicpKTtcXG4gICAgICAgICAgICBkbGcuZmluZChcXFwiYnV0dG9uXFxcIikub24oXFxcImNsaWNrXFxcIiwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICAvL1RPRE8gdmVyaWZ5IGlucHV0IGhlcmVcXG4gICAgICAgICAgICAgICAgdmFyIGNyZWRlbnRpYWxzID0ge307XFxuICAgICAgICAgICAgICAgIGZvciAoY3JlZGVudGlhbCBpbiBjcmVkZW50aWFsc19yZXF1aXJlZCkge1xcbiAgICAgICAgICAgICAgICAgICAgY3JlZGVudGlhbHNbY3JlZGVudGlhbHNfcmVxdWlyZWRbY3JlZGVudGlhbF1dID0gJChcXFwiI21sYWJfZHRfZGlhbG9nX2NyZWRlbnRpYWxzX1xcXCIgKyBjcmVkZW50aWFsc19yZXF1aXJlZFtjcmVkZW50aWFsXSkudmFsKCk7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgZWwucXRpcCgnaGlkZScpO1xcbiAgICAgICAgICAgICAgICBjYl9mdW5jdGlvbihjcmVkZW50aWFscywgcGFyYW1zKTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICB0aGlzLmRpc3BsYXlQcm9wZXJ0eURpYWxvZyhlbCwgX3RyW1xcXCJtbGFiLmR0LmFwaS5qcy5nZXRDcmVkZW50aWFscy5kbGcudGl0bGVcXFwiXSwgZGxnKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgY2JfZnVuY3Rpb24oY3JlZF92YWx1ZXMsIHBhcmFtcyk7XFxuICAgICAgICB9XFxuICAgIH0sIC8vIGVuZCBnZXRDcmVkZW50aWFsc1xcblxcbiAgICAvKipcXHJcXG4gICAgICogb2JqZWN0IHdpdGggZGlzcGxheSBmdW5jdGlvbmFsaXR5LCBwcmltYXJpbHkgdXNlZCBmb3IgcmVzaXppbmcgYW5kIGhpZ2hsaWdodGluZyBjb21wb25lbnRzXFxyXFxuICAgICAqIEB0eXBlIG9iamVjdFxcclxcbiAgICAgKi9cXG4gICAgZGlzcGxheToge1xcblxcbiAgICAgICAgc2V0RWRpdGFibGVGb2N1czogZnVuY3Rpb24gc2V0RWRpdGFibGVGb2N1cyhlbCkge1xcbiAgICAgICAgICAgIHZhciBzZWwgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XFxuICAgICAgICAgICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcXG4gICAgICAgICAgICB2YXIgaHRtbF9lbCA9IGVsWzBdO1xcbiAgICAgICAgICAgIGlmIChlbC50ZXh0KCkgIT0gXFxcIlxcXCIpIHtcXG4gICAgICAgICAgICAgICAgcmFuZ2Uuc2V0U3RhcnQoaHRtbF9lbCwgMCk7XFxuICAgICAgICAgICAgICAgIHJhbmdlLnNldEVuZChodG1sX2VsLCAwKTtcXG4gICAgICAgICAgICAgICAgc2VsLnJlbW92ZUFsbFJhbmdlcygpO1xcbiAgICAgICAgICAgICAgICBzZWwuYWRkUmFuZ2UocmFuZ2UpO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIGh0bWxfZWwuaW5uZXJIVE1MID0gXFxcIlxcXFx4QTBcXFwiO1xcbiAgICAgICAgICAgICAgICByYW5nZS5zZWxlY3ROb2RlQ29udGVudHMoaHRtbF9lbCk7XFxuICAgICAgICAgICAgICAgIHNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcXG4gICAgICAgICAgICAgICAgc2VsLmFkZFJhbmdlKHJhbmdlKTtcXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZXhlY0NvbW1hbmQoJ2RlbGV0ZScsIGZhbHNlLCBudWxsKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LFxcblxcbiAgICAgICAgLyoqXFxyXFxuICAgICAgICAgKiBVcGRhdGVzIHRoZSBhc3BlY3QgcmF0aW8gc2V0dGluZyBmb3IgYSBjb21wb25lbnQgYnkgdXBkYXRpbmcgdGhlIGRhdGEtbWxhYi1yYXRpbyBzZXR0aW5nXFxyXFxuICAgICAgICAgKiBAcGFyYW0ge3R5cGV9IGVsXFxyXFxuICAgICAgICAgKiBAcGFyYW0ge3R5cGV9IHNpemVcXHJcXG4gICAgICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XFxyXFxuICAgICAgICAgKi9cXG4gICAgICAgIHNldEFzcGVjdFJhdGlvOiBmdW5jdGlvbiBzZXRBc3BlY3RSYXRpbyhlbCwgYXNwZWN0KSB7XFxuICAgICAgICAgICAgaWYgKFtcXFwiNDozXFxcIiwgXFxcIjE2OjlcXFwiLCBcXFwiMToxXFxcIl0uaW5kZXhPZihhc3BlY3QpID4gLTEpIHtcXG4gICAgICAgICAgICAgICAgdmFyIHdyYXBwZXIgPSAkKGVsKS5jaGlsZHJlbihcXFwiOmZpcnN0XFxcIik7XFxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygd3JhcHBlci5kYXRhKFxcXCJtbGFiLXNpemVyXFxcIikgPT0gXFxcInVuZGVmaW5lZFxcXCIpIHtcXG4gICAgICAgICAgICAgICAgICAgICQoZWwpLmNoaWxkcmVuKCkud3JhcEFsbChcXFwiPGRpdiBkYXRhLW1sYWItc2l6ZXI9JzEnIGRhdGEtbWxhYi1zaXplPSdtZWRpdW0nPjwvZGl2PlxcXCIpO1xcbiAgICAgICAgICAgICAgICAgICAgd3JhcHBlciA9ICQoZWwpLmNoaWxkcmVuKFxcXCI6Zmlyc3RcXFwiKTtcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICB3cmFwcGVyLmF0dHIoXFxcImRhdGEtbWxhYi1hc3BlY3RyYXRpb1xcXCIsIGFzcGVjdCk7XFxuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmNsb3NlQWxsUHJvcGVydHlEaWFsb2dzKCk7XFxuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LnNldERpcnR5KCk7XFxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlRGlzcGxheSh3cmFwcGVyKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LFxcblxcbiAgICAgICAgLyoqXFxyXFxuICAgICAgICAgKiBVcGRhdGVzIHRoZSBzaXplIHNldHRpbmcgZm9yIGEgY29tcG9uZW50IGJ5IHVwZGF0aW5nIHRoZSBkYXRhLW1sYWItc2l6ZSBzZXR0aW5nXFxyXFxuICAgICAgICAgKiBJbml0aWFsbHkgdGhpcyBpcyBzbWFsbCwgbWVkaXVtLCBsYXJnZSBhbmQgZnVsbHBhZ2VcXHJcXG4gICAgICAgICAqIEBwYXJhbSB7dHlwZX0gZWxcXHJcXG4gICAgICAgICAqIEBwYXJhbSB7dHlwZX0gc2l6ZVxcclxcbiAgICAgICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cXHJcXG4gICAgICAgICAqL1xcbiAgICAgICAgc2V0U2l6ZTogZnVuY3Rpb24gc2V0U2l6ZShlbCwgc2l6ZSkge1xcbiAgICAgICAgICAgIGlmIChbXFxcInNtYWxsXFxcIiwgXFxcIm1lZGl1bVxcXCIsIFxcXCJsYXJnZVxcXCIsIFxcXCJmdWxsc2NyZWVuXFxcIl0uaW5kZXhPZihzaXplKSA+IC0xKSB7XFxuICAgICAgICAgICAgICAgIHZhciB3cmFwcGVyID0gJChlbCkuY2hpbGRyZW4oXFxcIjpmaXJzdFxcXCIpO1xcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHdyYXBwZXIuZGF0YShcXFwibWxhYi1zaXplclxcXCIpID09IFxcXCJ1bmRlZmluZWRcXFwiKSB7XFxuICAgICAgICAgICAgICAgICAgICAkKGVsKS5jaGlsZHJlbigpLndyYXBBbGwoXFxcIjxkaXYgZGF0YS1tbGFiLXNpemVyPScxJyBkYXRhLW1sYWItYXNwZWN0cmF0aW89JzQ6Myc+PC9kaXY+XFxcIik7XFxuICAgICAgICAgICAgICAgICAgICB3cmFwcGVyID0gJChlbCkuY2hpbGRyZW4oXFxcIjpmaXJzdFxcXCIpO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgICQod3JhcHBlcikuYXR0cihcXFwiZGF0YS1tbGFiLXNpemVcXFwiLCBzaXplKTtcXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuY2xvc2VBbGxQcm9wZXJ0eURpYWxvZ3MoKTtcXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuc2V0RGlydHkoKTtcXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVEaXNwbGF5KHdyYXBwZXIpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuXFxuICAgICAgICAvKipcXHJcXG4gICAgICAgICAqIFVwZGF0ZXMgZWl0aGVyIGEgc2luZ2xlIGNvbXBvbmVudCwgb3IgYWxsIGNvbXBvbmVudHMgb24gYSBwYWdlLCB1c2luZyBkYXRhIGF0dHJpYnV0ZXMgdG8gZGV0ZXJtaW5lIHRoZSBkaXNwbGF5XFxyXFxuICAgICAgICAgKiBUaGUgRElWIHRoYXQgaXMgdXBkYXRlZCBpcyBhbiBhdXRvbWF0aWNhbGx5IGluc2VydGVkIERJViB3aXRoIGRhdGEtbWxhYi1zaXplcj0nMSdcXHJcXG4gICAgICAgICAqIEBwYXJhbSB7dHlwZX0gZWw6IE9wdGlvbmFsLCB0aGUgZWxlbWVudCB0byBkaXNwbGF5LiBJZiBub3Qgc3BlY2lmaWVkLCB0aGVuIHVwZGF0ZSBhbGwgY29tcG9uZW50c1xcclxcbiAgICAgICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cXHJcXG4gICAgICAgICAqL1xcbiAgICAgICAgdXBkYXRlRGlzcGxheTogZnVuY3Rpb24gdXBkYXRlRGlzcGxheShlbCkge1xcbiAgICAgICAgICAgIC8vd2FzICdbZGF0YS1tbGFiLXNpemVdW2RhdGEtbWxhYi1hc3BlY3RyYXRpb10nXFxuICAgICAgICAgICAgdmFyIGNvbXBvbmVudHMgPSB0eXBlb2YgZWwgPT0gXFxcInVuZGVmaW5lZFxcXCIgPyAkKCdbZGF0YS1tbGFiLXNpemVyXScpIDogJChlbCk7XFxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xcbiAgICAgICAgICAgIGNvbXBvbmVudHMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgIHZhciBkZXZpY2Vfd2lkdGggPSAkKCdbZGF0YS1tbGFiLXNpemVyPVxcXCIxXFxcIl0nKS5wYXJlbnQoKS53aWR0aCgpO1xcbiAgICAgICAgICAgICAgICB2YXIgYXNwZWN0X3JhdGlvID0gJCh0aGlzKS5hdHRyKFxcXCJkYXRhLW1sYWItYXNwZWN0cmF0aW9cXFwiKS5zcGxpdChcXFwiOlxcXCIpO1xcbiAgICAgICAgICAgICAgICB2YXIgc2l6ZSA9ICQodGhpcykuYXR0cihcXFwiZGF0YS1tbGFiLXNpemVcXFwiKTtcXG4gICAgICAgICAgICAgICAgdmFyIHRpbWVzID0gc2l6ZSA9PSBcXFwic21hbGxcXFwiID8gMC4zMyA6IHNpemUgPT0gXFxcIm1lZGl1bVxcXCIgPyAwLjY3IDogMTtcXG4gICAgICAgICAgICAgICAgdmFyIGNvbXBfaWQgPSAkKHRoaXMpLnBhcmVudCgpLmRhdGEoXFxcIm1sYWItdHlwZVxcXCIpO1xcblxcbiAgICAgICAgICAgICAgICB2YXIgdyA9IGRldmljZV93aWR0aCAqIHRpbWVzO1xcbiAgICAgICAgICAgICAgICB2YXIgaCA9IHcgLyBhc3BlY3RfcmF0aW9bMF0gKiBhc3BlY3RfcmF0aW9bMV07XFxuICAgICAgICAgICAgICAgICQodGhpcykuY3NzKHsgXFxcIndpZHRoXFxcIjogdyArIFxcXCJweFxcXCIsIFxcXCJoZWlnaHRcXFwiOiBoICsgXFxcInB4XFxcIiB9KTtcXG5cXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGF0LnBhcmVudC5wYXJlbnQuY29tcG9uZW50c1tjb21wX2lkXSAhPSBcXFwidW5kZWZpbmVkXFxcIiAmJiB0eXBlb2YgdGhhdC5wYXJlbnQucGFyZW50LmNvbXBvbmVudHNbY29tcF9pZF0uY29kZSAhPSBcXFwidW5kZWZpbmVkXFxcIiAmJiB0eXBlb2YgdGhhdC5wYXJlbnQucGFyZW50LmNvbXBvbmVudHNbY29tcF9pZF0uY29kZS5vblJlc2l6ZSAhPSBcXFwidW5kZWZpbmVkXFxcIikge1xcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5wYXJlbnQucGFyZW50LmNvbXBvbmVudHNbY29tcF9pZF0uY29kZS5vblJlc2l6ZSh0aGlzKTtcXG4gICAgICAgICAgICAgICAgfTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH0sXFxuXFxuICAgICAgICAvKipcXHJcXG4gICAgICAgICAqIFRoaXMgZnVuY3Rpb24gdGFrZXMgYSByZ2IgY29sb3IgYXMgYSBwcmFtZXRlciBhbmQgdXNlIGl0IHRvIHJldHVybiB0aGUgaW52ZXJ0ZWQgY29sb3JcXHJcXG4gICAgICAgICAqXFxyXFxuICAgICAgICAgKiBAcGFyYW0gU3RyaW5nIHJnYlxcclxcbiAgICAgICAgICogQHJldHVybnMgU3RyaW5nIHJnYlxcclxcbiAgICAgICAgKi9cXG4gICAgICAgIGludmVydENvbG9yOiBmdW5jdGlvbiBpbnZlcnRDb2xvcihyZ2JTdHJpbmcpIHtcXG4gICAgICAgICAgICBpZiAodHlwZW9mIHJnYlN0cmluZyA9PSBcXFwidW5kZWZpbmVkXFxcIikge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gXFxcInJnYigyNTUsIDI1NSwgMjU1KTtcXFwiO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB2YXIgcGFydHMgPSByZ2JTdHJpbmcubWF0Y2goL15yZ2JcXFxcKChcXFxcZCspLFxcXFxzKihcXFxcZCspLFxcXFxzKihcXFxcZCspXFxcXCkkLyksXFxuICAgICAgICAgICAgICAgIGk7XFxuXFxuICAgICAgICAgICAgcGFydHMuc3BsaWNlKDAsIDEpO1xcbiAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPCAzOyArK2kpIHtcXG4gICAgICAgICAgICAgICAgcGFydHNbaV0gPSBwYXJzZUludChwYXJ0c1tpXSwgMTApO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB2YXIgcmdiID0gJ3JnYignO1xcbiAgICAgICAgICAgICQuZWFjaChwYXJ0cywgZnVuY3Rpb24gKGksIGl0ZW0pIHtcXG4gICAgICAgICAgICAgICAgcmdiICs9IDI1NSAtIGl0ZW0gKyAnLCc7XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgcmdiID0gcmdiLnNsaWNlKDAsIC0xKTtcXG4gICAgICAgICAgICByZ2IgKz0gJyknO1xcbiAgICAgICAgICAgIHJldHVybiByZ2I7XFxuICAgICAgICB9LFxcblxcbiAgICAgICAgLyoqXFxyXFxuICAgICAgICAgKiBUaGlzIGZ1bmN0aW9uIGdldHMgdGhlIGJhY2tncm91bmQtY29sb3Igb3IgaW5oZXJpdGVkIGJhY2tncm91bmQtY29sb3Igb2YgYW4gZWxlbWVudCB1c2luZyBqUXVlcnkgXFxyXFxuICAgICAgICAgKlxcclxcbiAgICAgICAgICogQHBhcmFtIGpxdWVyeUVsZW1lbnRcXHJcXG4gICAgICAgICAqIEByZXR1cm5zIFN0cmluZyByZ2JcXHJcXG4gICAgICAgICovXFxuICAgICAgICBnZXRCYWNrZ3JvdW5kOiBmdW5jdGlvbiBnZXRCYWNrZ3JvdW5kKGpxdWVyeUVsZW1lbnQpIHtcXG4gICAgICAgICAgICAvLyBJcyBjdXJyZW50IGVsZW1lbnQncyBiYWNrZ3JvdW5kIGNvbG9yIHNldD9cXG4gICAgICAgICAgICB2YXIgY29sb3IgPSBqcXVlcnlFbGVtZW50LmNzcyhcXFwiYmFja2dyb3VuZC1jb2xvclxcXCIpO1xcblxcbiAgICAgICAgICAgIGlmIChjb2xvciAhPT0gJ3JnYmEoMCwgMCwgMCwgMCknKSB7XFxuICAgICAgICAgICAgICAgIC8vIGlmIHNvIHRoZW4gcmV0dXJuIHRoYXQgY29sb3JcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbG9yO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAvLyBpZiBub3Q6IGFyZSB5b3UgYXQgdGhlIGJvZHkgZWxlbWVudD9cXG4gICAgICAgICAgICBpZiAoanF1ZXJ5RWxlbWVudC5pcyhcXFwiYm9keVxcXCIpKSB7XFxuICAgICAgICAgICAgICAgIC8vIHJldHVybiBrbm93biAnZmFsc2UnIHZhbHVlXFxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAvLyBjYWxsIGdldEJhY2tncm91bmQgd2l0aCBwYXJlbnQgaXRlbVxcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRCYWNrZ3JvdW5kKGpxdWVyeUVsZW1lbnQucGFyZW50KCkpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuXFxuICAgICAgICAvKipcXHJcXG4gICAgICAgICAqIENhbGxlZCB3aGVuIHdlIGxlYXZlIGEgY29tcG9uZW50LCBlaXRoZXIgYmVjYXVzZSBhbm90aGVyIG9uZSBpcyBhZGRlZC9wYXN0ZWQsIG9yIHRoZXkgc2VsZWN0IGFub3RoZXIgY29tcG9uZW50XFxyXFxuICAgICAgICAgKi9cXG4gICAgICAgIGNvbXBvbmVudEJsdXI6IGZ1bmN0aW9uIGNvbXBvbmVudEJsdXIoZWwpIHtcXG4gICAgICAgICAgICBpZiAoZWwubGVuZ3RoID09IDApIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbC5xdGlwKCdoaWRlJyk7XFxuICAgICAgICAgICAgdmFyIGNvbXBfaWQgPSBlbC5kYXRhKFxcXCJtbGFiLXR5cGVcXFwiKTtcXG4gICAgICAgICAgICBlbC5yZW1vdmVDbGFzcyhcXFwibWxhYl9jdXJyZW50X2NvbXBvbmVudFxcXCIpO1xcbiAgICAgICAgICAgIC8vc2FtZSBmb3IgYW55IGN1cnJlbnQgc3ViIGNvbXBvbmVudHMsIHN1Y2ggYXMgYSBxdWVzdGlvbiBpbiBhIHF1aXpcXG4gICAgICAgICAgICBlbC5maW5kKFxcXCJtbGFiX2N1cnJlbnRfY29tcG9uZW50XFxcIikuY3NzKFxcXCJvdXRsaW5lLWNvbG9yXFxcIiwgXFxcIlxcXCIpLnJlbW92ZUNsYXNzKFxcXCJtbGFiX2N1cnJlbnRfY29tcG9uZW50XFxcIik7XFxuICAgICAgICAgICAgZWwuZmluZChcXFwiLm1sYWJfY3VycmVudF9jb21wb25lbnRfZWRpdGFibGVcXFwiKS5jc3MoXFxcIm91dGxpbmUtY29sb3JcXFwiLCBcXFwiXFxcIikucmVtb3ZlQ2xhc3MoXFxcIm1sYWJfY3VycmVudF9jb21wb25lbnRfZWRpdGFibGVcXFwiKS5hdHRyKFxcXCJjb250ZW50ZWRpdGFibGVcXFwiLCBmYWxzZSk7XFxuICAgICAgICAgICAgd2luZG93LmdldFNlbGVjdGlvbigpLnJlbW92ZUFsbFJhbmdlcygpO1xcbiAgICAgICAgICAgIGVsLmZpbmQoXFxcIi5tbGFiX2N1cnJlbnRfY29tcG9uZW50X2NoaWxkXFxcIikuY3NzKFxcXCJvdXRsaW5lLWNvbG9yXFxcIiwgXFxcIlxcXCIpLnJlbW92ZUNsYXNzKFxcXCJtbGFiX2N1cnJlbnRfY29tcG9uZW50X2NoaWxkXFxcIik7XFxuXFxuICAgICAgICAgICAgaWYgKHR5cGVvZiBtbGFiLmR0LmNvbXBvbmVudHNbY29tcF9pZF0uY29kZS5vbkJsdXIgIT0gXFxcInVuZGVmaW5lZFxcXCIpIHtcXG4gICAgICAgICAgICAgICAgbWxhYi5kdC5jb21wb25lbnRzW2NvbXBfaWRdLmNvZGUub25CbHVyKGVsKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LFxcblxcbiAgICAgICAgLyoqXFxyXFxuICAgICAgICAgKiBVcGRhdGVzIGVpdGhlciBhIHNpbmdsZSBjb21wb25lbnQsIG9yIGFsbCBjb21wb25lbnRzIG9uIGEgcGFnZSwgdXNpbmcgZGF0YSBhdHRyaWJ1dGVzIHRvIGRldGVybWluZSB0aGUgZGlzcGxheVxcclxcbiAgICAgICAgICogQHBhcmFtIHt0eXBlfSBlbDogT3B0aW9uYWwsIHRoZSBlbGVtZW50IHRvIGRpc3BsYXkuIElmIG5vdCBzcGVjaWZpZWQsIHRoZW4gdXBkYXRlIGFsbCBjb21wb25lbnRzXFxyXFxuICAgICAgICAgKiBAcmV0dXJucyB7dHJ1ZSBpZiBzZWxlY3RlZCBkaWZmZXJlbnQgY29tcG9uZW50LCBmYWxzZSBvdGhlcndpc2V9XFxyXFxuICAgICAgICAgKi9cXG4gICAgICAgIGNvbXBvbmVudEhpZ2hsaWdodFNlbGVjdGVkOiBmdW5jdGlvbiBjb21wb25lbnRIaWdobGlnaHRTZWxlY3RlZChlbCkge1xcbiAgICAgICAgICAgIHZhciBjdXJDb21wID0gJChcXFwiI1xcXCIgKyB0aGlzLnBhcmVudC5nZXRFZGl0b3JFbGVtZW50KCkgKyBcXFwiPiBkaXYubWxhYl9jdXJyZW50X2NvbXBvbmVudFxcXCIpO1xcblxcbiAgICAgICAgICAgIGlmIChlbFswXSA9PT0gY3VyQ29tcFswXSkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgaWYgKGVsWzBdICE9PSBjdXJDb21wWzBdKSB7XFxuICAgICAgICAgICAgLy9EZWxldGUgdGhlIG91dGxpbmVzIGFuZCB0b29scyBmb3IgdGhlIGxhc3QgY3VycmVudCBjb21wb25lbnRcXG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudEJsdXIoY3VyQ29tcCk7XFxuXFxuICAgICAgICAgICAgLy9TZXQgdGhlIG5ldyBjdXJyZW50IGNvbXBvbmVudFxcbiAgICAgICAgICAgIHZhciBwYWdlQmdDb2xvciA9ICQoXFxcIltkYXRhLXJvbGU9cGFnZV1cXFwiKS5jc3MoXFxcImJhY2tncm91bmQtY29sb3JcXFwiKTtcXG4gICAgICAgICAgICAvL2ludmVydHMgdGhlIGJhY2tncm91bmQgY29sb3JcXG4gICAgICAgICAgICB2YXIgcGFnZUJnQ29sb3JJbnZlcnQgPSB0aGlzLmludmVydENvbG9yKHBhZ2VCZ0NvbG9yKTtcXG4gICAgICAgICAgICAvL3NldCB0aGUgaW52ZXJ0IGNvbG9yIG9mIHRoZSBiYWNrZ3JvdW5kIGFzIHRoZSBib3JkZXItY29sb3IgZm9yIHRoZSBjdXJyZW50IHNlbGVjdGVkIGNvbXBvbmVudFxcbiAgICAgICAgICAgICQoZWwpLmNzcyhcXFwib3V0bGluZS1jb2xvclxcXCIsIHBhZ2VCZ0NvbG9ySW52ZXJ0KTtcXG4gICAgICAgICAgICAkKGVsKS5hZGRDbGFzcyhcXFwibWxhYl9jdXJyZW50X2NvbXBvbmVudFxcXCIpO1xcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgICAgICAgIC8qICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIFxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsqL1xcbiAgICAgICAgfSxcXG5cXG4gICAgICAgIC8qKlxcclxcbiAgICAgICAgICogSGlnaGxpZ2h0cyBjb250cm9scyB0aGF0IGhhdmUgY2hpbGQgY29udG9scyBpbnNpZGUgdGhlbVxcclxcbiAgICAgICAgICogQHBhcmFtIHt0eXBlfSBzdWJfZWw6IFRoZSBlbGVtZW50IHRvIGRpc3BsYXkuIElmIG5vdCBzcGVjaWZpZWQsIHRoZW4gdXBkYXRlIGFsbCBjb21wb25lbnRzXFxyXFxuICAgICAgICAgKiBAcGFyYW0ge3R5cGV9IGVkaXRhYmxlOiBPcHRpb25hbCwgdGhlIGVsZW1lbnQgdG8gZGlzcGxheS4gSWYgbm90IHNwZWNpZmllZCwgdGhlbiB1cGRhdGUgYWxsIGNvbXBvbmVudHNcXHJcXG4gICAgICAgICAqL1xcbiAgICAgICAgY29tcG9uZW50SGlnaGxpZ2h0U2VsZWN0ZWRDaGlsZHJlbjogZnVuY3Rpb24gY29tcG9uZW50SGlnaGxpZ2h0U2VsZWN0ZWRDaGlsZHJlbihzdWJfZWwsIGVkaXRhYmxlLCBvdmVycmlkZSkge1xcbiAgICAgICAgICAgIHN1Yl9lbCA9ICQoc3ViX2VsKTtcXG5cXG4gICAgICAgICAgICBpZiAoISQoXFxcIi5tbGFiX2N1cnJlbnRfY29tcG9uZW50XFxcIikuZmluZChcXFwiLm1sYWJfY3VycmVudF9jb21wb25lbnRfY2hpbGRcXFwiKS5pcyhzdWJfZWwpIHx8IG92ZXJyaWRlKSB7XFxuICAgICAgICAgICAgICAgICQoXFxcIi5tbGFiX2N1cnJlbnRfY29tcG9uZW50XFxcIikuZmluZChcXFwiLm1sYWJfY3VycmVudF9jb21wb25lbnRfY2hpbGRcXFwiKS5jc3MoXFxcIm91dGxpbmUtY29sb3JcXFwiLCBcXFwiXFxcIikucmVtb3ZlQ2xhc3MoXFxcIm1sYWJfY3VycmVudF9jb21wb25lbnRfY2hpbGRcXFwiKTtcXG5cXG4gICAgICAgICAgICAgICAgLy9nZXRzIHRoZSBjaGlsZHMgYmFja2dyb3VuZCBjb2xvclxcbiAgICAgICAgICAgICAgICB2YXIgYmdDb2xvckMgPSB0aGlzLmdldEJhY2tncm91bmQoc3ViX2VsKTtcXG4gICAgICAgICAgICAgICAgLy9pbnZlcnRzIHRoZSBiYWNrZ3JvdW5kIGNvbG9yXFxuICAgICAgICAgICAgICAgIHZhciBiZ0NvbG9yQ0ludmVydCA9IHRoaXMuaW52ZXJ0Q29sb3IoYmdDb2xvckMpO1xcbiAgICAgICAgICAgICAgICAvL3NldCB0aGUgaW52ZXJ0IGNvbG9yIG9mIHRoZSBiYWNrZ3JvdW5kIGFzIHRoZSBvdXRsaW5lLWNvbG9yIGZvciB0aGUgY3VycmVudCBzZWxlY3RlZCBjb21wb25lbnRcXG4gICAgICAgICAgICAgICAgc3ViX2VsLmNzcyhcXFwib3V0bGluZS1jb2xvclxcXCIsIGJnQ29sb3JDSW52ZXJ0KTtcXG4gICAgICAgICAgICAgICAgLy9zZXQgdGhlIGNsYXNzIHRvIHN0eWxlIHRoZSBzZWxlY3RlZCBoaWdobGlnaHRlZCBjaGlsZCAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgc3ViX2VsLmFkZENsYXNzKFxcXCJtbGFiX2N1cnJlbnRfY29tcG9uZW50X2NoaWxkXFxcIik7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZWRpdGFibGUgIT0gXFxcInVuZGVmaW5lZFxcXCIpIHtcXG4gICAgICAgICAgICAgICAgZWRpdGFibGUgPSAkKGVkaXRhYmxlKTtcXG4gICAgICAgICAgICAgICAgLy9pZiB0aGV5IGhhdmUgbm90IHJlLWNsaWNrZWQgdGhlIGN1cnJlbnQgZGl0YWJsZSBlbGVtZW50IHRoZW4gd2UgZGVzZWxlY3Qgb2xkIG9uZSBhbmQgc2VsZWN0IG5ldyBvbmVcXG4gICAgICAgICAgICAgICAgaWYgKCEkKFxcXCIubWxhYl9jdXJyZW50X2NvbXBvbmVudFxcXCIpLmZpbmQoXFxcIi5tbGFiX2N1cnJlbnRfY29tcG9uZW50X2VkaXRhYmxlXFxcIikuaXMoZWRpdGFibGUpKSB7XFxuICAgICAgICAgICAgICAgICAgICAkKFxcXCIubWxhYl9jdXJyZW50X2NvbXBvbmVudFxcXCIpLmZpbmQoXFxcIi5tbGFiX2N1cnJlbnRfY29tcG9uZW50X2VkaXRhYmxlXFxcIikuY3NzKFxcXCJvdXRsaW5lLWNvbG9yXFxcIiwgXFxcIlxcXCIpLnJlbW92ZUNsYXNzKFxcXCJtbGFiX2N1cnJlbnRfY29tcG9uZW50X2VkaXRhYmxlXFxcIikuYXR0cihcXFwiY29udGVudGVkaXRhYmxlXFxcIiwgZmFsc2UpO1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlZGl0YWJsZSAhPSBcXFwidW5kZWZpbmVkXFxcIiAmJiBlZGl0YWJsZS5sZW5ndGggPiAwICYmICQoZWRpdGFibGUpLnByb3AoXFxcInRhZ05hbWVcXFwiKS50b0xvd2VyQ2FzZSgpICE9IFxcXCJpbnB1dFxcXCIpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2dldHMgdGhlIGdyYW5kY2hpbGRzIGJhY2tncm91bmQgY29sb3JcXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmdDb2xvckdDID0gdGhpcy5nZXRCYWNrZ3JvdW5kKGVkaXRhYmxlKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2ludmVydHMgdGhlIGJhY2tncm91bmQgY29sb3JcXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmdDb2xvckdDSW52ZXJ0ID0gdGhpcy5pbnZlcnRDb2xvcihiZ0NvbG9yR0MpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vc2V0IHRoZSBpbnZlcnQgY29sb3Igb2YgdGhlIGJhY2tncm91bmQgYXMgdGhlIG91dGxpbmUtY29sb3IgZm9yIHRoZSBjdXJyZW50IHNlbGVjdGVkIGNvbXBvbmVudFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRhYmxlLmNzcyhcXFwib3V0bGluZS1jb2xvclxcXCIsIGJnQ29sb3JHQ0ludmVydCk7XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdGFibGUuYWRkQ2xhc3MoXFxcIm1sYWJfY3VycmVudF9jb21wb25lbnRfZWRpdGFibGVcXFwiKS5hdHRyKFxcXCJjb250ZW50ZWRpdGFibGVcXFwiLCB0cnVlKTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgfVxcblxcbn07XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yYXctbG9hZGVyIS4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWI/P3JlZi0tMC0wIS4vYXNzZXRzL2pzL21sYWIuZHQuYXBpLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9yYXctbG9hZGVyL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMC0wIS4vYXNzZXRzL2pzL21sYWIuZHQuYXBpLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxcclxcbkBjb3B5cmlnaHQgQ29weXJpZ2h0IChjKSAyMDEzLTIwMTYsIE5vcndlZ2lhbiBEZWZlbmNlIFJlc2VhcmNoIEVzdGFibGlzaG1lbnQgKEZGSSkgLSBBbGwgUmlnaHRzIFJlc2VydmVkXFxyXFxuQGxpY2Vuc2UgUHJvcHJpZXRhcnkgYW5kIGNvbmZpZGVudGlhbFxcclxcbkBhdXRob3IgQXJpbGQgQmVyZ2gvU2luZXR0IDMuMCBwcm9ncmFtbWUgKGZpcnN0bmFtZS5sYXN0bmFtZUBmZmkubm8pIHJld3JpdGUvaW1wbGVtZW50YXRpb24gb2YgYWxsIGZ1bmN0aW9uYWxpdHlcXHJcXG5cXHJcXG5VbmF1dGhvcml6ZWQgY29weWluZyBvZiB0aGlzIGZpbGUsIHZpYSBhbnkgbWVkaXVtIGlzIHN0cmljdGx5IHByb2hpYml0ZWQgXFxyXFxuXFxyXFxuRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VfTUxBQiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cXHJcXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcblxcbi8qKlxcclxcbiAqIEBhYnN0cmFjdCBGdW5jdGlvbmFsaXR5IHRoYXQgZGVhbHMgd2l0aCB0aGUgdGVtcGxhdGUgZGVmaW5lZCBiZXN0IHByYWN0aWNlc1xcclxcbiAqXFxyXFxuICovXFxuXFxuZnVuY3Rpb24gTWxhYl9kdF9iZXN0cHJhY3RpY2UoKSB7XFxuICAgIHRoaXMucGFyZW50ID0gbnVsbDtcXG59XFxuXFxuTWxhYl9kdF9iZXN0cHJhY3RpY2UucHJvdG90eXBlID0ge1xcblxcbiAgICAvL2dldCB0aGUgb2JqZWN0IHdpdGggcnVsZXMsIHN1Y2ggYXMgbWF4IGNoYXJhdmN0ZXJzLCBtYXggbGVuZ3RoLCBldGNcXG4gICAgLy9yZXR1cm4gcnVsZXMgZm9yIGN1cnJlbnQgdGVtcGxhdGUsIGNvdWxkIGJlIHVzZWQgdG8gdHJhY2sgd2hlbiB1c2VyIGhhcyB0eXBlZCBpbiB0b28gbXVjaCB0ZXh0IChmb3IgaW5zdGFuY2UpXFxuICAgIC8vdG8gZG8gcHJlZW1wdGl2ZSBjaGVja3MgKHdlIGRvIHBvc3Qtc2F2ZSBjaGVjaylcXG4gICAgZ2V0X3RlbXBsYXRlX3J1bGVzOiBmdW5jdGlvbiBnZXRfdGVtcGxhdGVfcnVsZXMoKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQuYXBwLnRlbXBsYXRlX2NvbmZpZy5jb21wb25lbnRzO1xcbiAgICB9LFxcblxcbiAgICAvLyBmaW5hbCB0ZW1wbGF0ZSBcXFwiYmVzdCBwcmFjdGljZXNcXFwiLCB3ZSBzZWUgaWYgdGhlcmUgYXJlIHRvbyBtYW55IG9yIHRvbyBmZXcgb2YgY2VydGFpbiBjYXRlZ29yaWVzIG9mIGNvbXBvbmVudHMgb24gYSBwYWdlXFxuICAgIHBhZ2VfY2hlY2tfY29udGVudDogZnVuY3Rpb24gcGFnZV9jaGVja19jb250ZW50KGNvbXBvbmVudF9jYXRlZ29yaWVzLCB0ZW1wbGF0ZV9iZXN0X3ByYWN0aWNlX21zZykge1xcblxcbiAgICAgICAgdmFyIHJ1bGVzID0gdGhpcy5wYXJlbnQuYXBwLnRlbXBsYXRlX2NvbmZpZy5jb21wb25lbnRzO1xcbiAgICAgICAgZm9yICh2YXIgY2F0ZWdvcnkgaW4gcnVsZXMpIHtcXG4gICAgICAgICAgICBpZiAocnVsZXNbY2F0ZWdvcnldLmhhc093blByb3BlcnR5KFxcXCJtYXhcXFwiKSkge1xcbiAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50X2NhdGVnb3JpZXNbY2F0ZWdvcnldID4gcnVsZXNbY2F0ZWdvcnldLm1heC5jb3VudCkge1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKCQuaW5BcnJheShydWxlc1tjYXRlZ29yeV0ubWF4Lm1lc3NhZ2UsIHRlbXBsYXRlX2Jlc3RfcHJhY3RpY2VfbXNnKSA8IDApIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZV9iZXN0X3ByYWN0aWNlX21zZy5wdXNoKHJ1bGVzW2NhdGVnb3J5XS5tYXgubWVzc2FnZSk7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYgKHJ1bGVzW2NhdGVnb3J5XS5oYXNPd25Qcm9wZXJ0eShcXFwibWluXFxcIikpIHtcXG4gICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudF9jYXRlZ29yaWVzW2NhdGVnb3J5XSA8IHJ1bGVzW2NhdGVnb3J5XS5taW4uY291bnQpIHtcXG4gICAgICAgICAgICAgICAgICAgIGlmICgkLmluQXJyYXkocnVsZXNbY2F0ZWdvcnldLm1pbi5tZXNzYWdlLCB0ZW1wbGF0ZV9iZXN0X3ByYWN0aWNlX21zZykgPCAwKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVfYmVzdF9wcmFjdGljZV9tc2cucHVzaChydWxlc1tjYXRlZ29yeV0ubWluLm1lc3NhZ2UpO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICB9LFxcblxcbiAgICAvKipcXHJcXG4gICAgICogUnVucyB0aGUgXFxcImJlc3QgcHJhY3RpY2VzXFxcIiBjaGVjayBmb3IgYSBzaW5nbGUgY29tcG9uZW50LCBjYW4gY2hlY2sgaWYgdmlkZW8gaXMgdG9vIGxvbmcsIGlmIHRoZXJlIGlzIHRvbyBtdWNoIHRleHQsIGV0YywgZXRjXFxyXFxuICAgICAqIEBwYXJhbSB7dHlwZX0gY29tcFxcclxcbiAgICAgKiBAcGFyYW0ge3R5cGV9IGNvbXBfaWRcXHJcXG4gICAgICogQHBhcmFtIHt0eXBlfSBjb21wb25lbnRfY2F0ZWdvcmllc1xcclxcbiAgICAgKiBAcGFyYW0ge3R5cGV9IHRlbXBsYXRlX2Jlc3RfcHJhY3RpY2VfbXNnXFxyXFxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XFxyXFxuICAgICAqL1xcbiAgICBjb21wb25lbnRfY2hlY2tfY29udGVudDogZnVuY3Rpb24gY29tcG9uZW50X2NoZWNrX2NvbnRlbnQoY29tcCwgY29tcF9pZCwgY29tcG9uZW50X2NhdGVnb3JpZXMsIHRlbXBsYXRlX2Jlc3RfcHJhY3RpY2VfbXNnKSB7XFxuICAgICAgICB2YXIgcnVsZXMgPSB0aGlzLnBhcmVudC5hcHAudGVtcGxhdGVfY29uZmlnLmNvbXBvbmVudHM7XFxuICAgICAgICBpZiAodGhpcy5wYXJlbnQuY29tcG9uZW50c1tjb21wX2lkXS5oYXNPd25Qcm9wZXJ0eShcXFwiY29uZlxcXCIpICYmIHRoaXMucGFyZW50LmNvbXBvbmVudHNbY29tcF9pZF0uY29uZi5oYXNPd25Qcm9wZXJ0eShcXFwiY2F0ZWdvcnlcXFwiKSkge1xcbiAgICAgICAgICAgIHZhciBjb21wX2NhdGVnb3J5ID0gdGhpcy5wYXJlbnQuY29tcG9uZW50c1tjb21wX2lkXS5jb25mLmNhdGVnb3J5O1xcblxcbiAgICAgICAgICAgIGlmICghY29tcG9uZW50X2NhdGVnb3JpZXMuaGFzT3duUHJvcGVydHkoY29tcF9jYXRlZ29yeSkpIHtcXG4gICAgICAgICAgICAgICAgY29tcG9uZW50X2NhdGVnb3JpZXNbY29tcF9jYXRlZ29yeV0gPSAxO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudF9jYXRlZ29yaWVzW2NvbXBfY2F0ZWdvcnldKys7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIC8vY2FuIG9ubHkgZG8gdGhpcyBpZiBjb21wb25lbnQgc3VwcHJ0cyB0aGUgZ2V0Q29udGVudFNpemUgZnVuY3Rpb25cXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMucGFyZW50LmNvbXBvbmVudHNbY29tcF9pZF0uY29kZSAhPSBcXFwidW5kZWZpbmVkXFxcIikge1xcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMucGFyZW50LmNvbXBvbmVudHNbY29tcF9pZF0uY29kZS5nZXRDb250ZW50U2l6ZSAhPSBcXFwidW5kZWZpbmVkXFxcIikge1xcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNpemUgPSB0aGlzLnBhcmVudC5jb21wb25lbnRzW2NvbXBfaWRdLmNvZGUuZ2V0Q29udGVudFNpemUoY29tcCk7XFxuICAgICAgICAgICAgICAgICAgICBpZiAocnVsZXMuaGFzT3duUHJvcGVydHkoY29tcF9jYXRlZ29yeSkpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocnVsZXNbY29tcF9jYXRlZ29yeV0uaGFzT3duUHJvcGVydHkoXFxcIm1heFxcXCIpKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaXplID4gcnVsZXNbY29tcF9jYXRlZ29yeV0ubWF4LnNpemUpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkLmluQXJyYXkocnVsZXNbY29tcF9jYXRlZ29yeV0ubWF4Lm1lc3NhZ2UsIHRlbXBsYXRlX2Jlc3RfcHJhY3RpY2VfbXNnKSA8IDApIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZV9iZXN0X3ByYWN0aWNlX21zZy5wdXNoKHJ1bGVzW2NvbXBfY2F0ZWdvcnldLm1heC5tZXNzYWdlKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocnVsZXNbY29tcF9jYXRlZ29yeV0uaGFzT3duUHJvcGVydHkoXFxcIm1pblxcXCIpKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaXplIDwgcnVsZXNbY29tcF9jYXRlZ29yeV0ubWluLnNpemUpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkLmluQXJyYXkocnVsZXNbY29tcF9jYXRlZ29yeV0ubWluLm1lc3NhZ2UsIHRlbXBsYXRlX2Jlc3RfcHJhY3RpY2VfbXNnKSA8IDApIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZV9iZXN0X3ByYWN0aWNlX21zZy5wdXNoKHJ1bGVzW2NvbXBfY2F0ZWdvcnldLm1pbi5tZXNzYWdlKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgfSAvLyBlbmQgcHJvdG90eXBlXFxuXFxufTtcIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Jhdy1sb2FkZXIhLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYj8/cmVmLS0wLTAhLi9hc3NldHMvanMvbWxhYi5kdC5iZXN0cHJhY3RpY2UuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3Jhdy1sb2FkZXIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0wLTAhLi9hc3NldHMvanMvbWxhYi5kdC5iZXN0cHJhY3RpY2UuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXFxyXFxuQGNvcHlyaWdodCBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNiwgTm9yd2VnaWFuIERlZmVuY2UgUmVzZWFyY2ggRXN0YWJsaXNobWVudCAoRkZJKSAtIEFsbCBSaWdodHMgUmVzZXJ2ZWRcXHJcXG5AbGljZW5zZSBQcm9wcmlldGFyeSBhbmQgY29uZmlkZW50aWFsXFxyXFxuQGF1dGhvciBBcmlsZCBCZXJnaC9TaW5ldHQgMy4wIHByb2dyYW1tZSAoZmlyc3RuYW1lLmxhc3RuYW1lQGZmaS5ubykgcmV3cml0ZS9pbXBsZW1lbnRhdGlvbiBvZiBhbGwgZnVuY3Rpb25hbGl0eVxcclxcbkBhdXRob3IgQ2VjaWxpZSBKYWNrYm8gR3Jhbi9TaW5ldHQgMy4wIHByb2dyYW1tZSAoZmlyc3RuYW1lLm1pZGRsZW5hbWUubGFzdG5hbWVAZmZpLm5vKSBhZGRpdGlvbmFsIGZ1bmN0aW9uYWxpdHlcXHJcXG5cXHJcXG5VbmF1dGhvcml6ZWQgY29weWluZyBvZiB0aGlzIGZpbGUsIHZpYSBhbnkgbWVkaXVtIGlzIHN0cmljdGx5IHByb2hpYml0ZWQgXFxyXFxuXFxyXFxuRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VfTUxBQiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cXHJcXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcblxcbi8qKlxcclxcbiAqIEBhYnN0cmFjdCBGdW5jdGlvbnMgdG8gcGFyc2UgSFRNTCBmb3IgYSBwYWdlIGFuZCBpbnNlcnQgaXQgaW50byB0aGUgZWRpdG9yIGFyZWEgXFxyXFxuICovXFxuXFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXFxyXFxuICoqKioqKioqKioqKioqKioqKiogVXRpbGl0eSBmdW5jdGlvbnMgKioqKioqKioqKioqKioqKioqKioqXFxyXFxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcblxcbi8qKlxcclxcbiAqIFN0YW5kYXJkIGluaXRpYWxpc2F0aW9uIG9mIE1sYWIgb2JqZWN0IHdoaWNoIGlzIHJlZmVycmVkIHRvIGluIHNldmVyYWwgSlMgZmlsZXMsXFxyXFxuICogYXMgdGhlc2UgZmlsZXMgY2FuIGNvbWUgZG93biBpbiBkaWZmZXJlbnQgb3JkZXIsIHdlIG11c3QgbWFrZSBzdXJlIHdlIGNhbiB1c2UgaXQgaGVyZS5cXHJcXG4gKi9cXG5cXG5mdW5jdGlvbiBNbGFiX2R0X2Rlc2lnbigpIHtcXG4gICAgdGhpcy5wYXJlbnQgPSBudWxsO1xcbn1cXG5cXG5NbGFiX2R0X2Rlc2lnbi5wcm90b3R5cGUgPSB7XFxuICAgIC8qXFxyXFxuICAgICAqIERPTVBhcnNlciBIVE1MIGV4dGVuc2lvblxcclxcbiAgICAgKiAyMDEyLTA5LTA0XFxyXFxuICAgICAqXFxyXFxuICAgICAqIEJ5IEVsaSBHcmV5LCBodHRwOi8vZWxpZ3JleS5jb21cXHJcXG4gICAgICogUHVibGljIGRvbWFpbi5cXHJcXG4gICAgICogTk8gV0FSUkFOVFkgRVhQUkVTU0VEIE9SIElNUExJRUQuIFVTRSBBVCBZT1VSIE9XTiBSSVNLLlxcclxcbiAgICAgKiEgQHNvdXJjZSBodHRwczovL2dpc3QuZ2l0aHViLmNvbS8xMTI5MDMxXFxyXFxuICAgICAqIGdsb2JhbCBkb2N1bWVudCwgRE9NUGFyc2VyXFxyXFxuICAgICAqL1xcblxcbiAgICBkb21QYXJzZXJXcmFwcGVyOiBmdW5jdGlvbiBkb21QYXJzZXJXcmFwcGVyKCkge1xcbiAgICAgICAgXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcbiAgICAgICAgdmFyIERPTVBhcnNlcl9wcm90byA9IERPTVBhcnNlci5wcm90b3R5cGU7XFxuICAgICAgICB2YXIgcmVhbF9wYXJzZUZyb21TdHJpbmcgPSBET01QYXJzZXJfcHJvdG8ucGFyc2VGcm9tU3RyaW5nO1xcblxcbiAgICAgICAgLy8gRmlyZWZveC9PcGVyYS9JRSB0aHJvdyBlcnJvcnMgb24gdW5zdXBwb3J0ZWQgdHlwZXNcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgLy8gV2ViS2l0IHJldHVybnMgbnVsbCBvbiB1bnN1cHBvcnRlZCB0eXBlc1xcbiAgICAgICAgICAgIGlmIChuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKFxcXCJcXFwiLCBcXFwidGV4dC9odG1sXFxcIikpIHtcXG4gICAgICAgICAgICAgICAgLy8gdGV4dC9odG1sIHBhcnNpbmcgaXMgbmF0aXZlbHkgc3VwcG9ydGVkXFxuICAgICAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9IGNhdGNoIChleCkge31cXG5cXG4gICAgICAgIERPTVBhcnNlcl9wcm90by5wYXJzZUZyb21TdHJpbmcgPSBmdW5jdGlvbiAobWFya3VwLCB0eXBlKSB7XFxuICAgICAgICAgICAgaWYgKC9eXFxcXHMqdGV4dFxcXFwvaHRtbFxcXFxzKig/Ojt8JCkvaS50ZXN0KHR5cGUpKSB7XFxuICAgICAgICAgICAgICAgIHZhciBkb2MgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoXFxcIlxcXCIpO1xcbiAgICAgICAgICAgICAgICBpZiAobWFya3VwLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignPCFkb2N0eXBlJykgPiAtMSkge1xcbiAgICAgICAgICAgICAgICAgICAgZG9jLmRvY3VtZW50RWxlbWVudC5pbm5lckhUTUwgPSBtYXJrdXA7XFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICBkb2MuYm9keS5pbm5lckhUTUwgPSBtYXJrdXA7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvYztcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVhbF9wYXJzZUZyb21TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9O1xcbiAgICB9LFxcblxcbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcXHJcXG4gICAgICoqKioqKioqKioqIEZ1bmN0aW9ucyB0byBtYW5pcHVsYXRlIGNvbXBvbmVudHMgKioqKioqKioqKipcXHJcXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbiAgICBjb21wb25lbnRfYWRkOiBmdW5jdGlvbiBjb21wb25lbnRfYWRkKGlkKSB7XFxuICAgICAgICBpZiAodGhpcy5wYXJlbnQuYXBwLmxvY2tlZCkge1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIC8vaWYgdGhpcyBjb250cm9sIGhhcyB0byBiZSB1bmlxdWUgd2UgY2hlY2sgaGVyZSB0byBzZWUgaWYgb25lIHdhcyBhbHJlYWR5IGFkZGVkXFxuICAgICAgICBpZiAodGhpcy5wYXJlbnQuY29tcG9uZW50c1tpZF0uY29uZi51bmlxdWUgJiYgJChcXFwiI1xcXCIgKyB0aGlzLnBhcmVudC5jb25maWdbXFxcImFwcFxcXCJdW1xcXCJjb250ZW50X2lkXFxcIl0pLmZpbmQoXFxcIltkYXRhLW1sYWItdHlwZT0nXFxcIiArIGlkICsgXFxcIiddXFxcIikubGVuZ3RoID4gMCkge1xcbiAgICAgICAgICAgIGFsZXJ0KF90cltcXFwibWxhYi5kdC5kZXNpZ24uanMuYWxlcnQub25seS5vbmUuY29tcFxcXCJdKTtcXG4gICAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICAvL2ZpcnN0IHdlIGxvYWQgdGhlIHJlbGV2YW50IENTUy9KUyBmaWxlcywgd2hlbiB0aGF0IGlzIGRvbmUgd2Ugd2lsbCBjYWxsIGNvbXBvbmVudF9hZGRfaHRtbCBmcm9tIHRoZSBnZXRTY3JpcHRGaWxlcyBmdW5jdGlvbi5cXG4gICAgICAgIC8vdGhpcyBpcyBiZWNhdXNlIHNjcmlwdCBmaWxlcyBjb21lIGRvd24gYXQgZGlmZmVyZW50IHNwZWVkcywgYW5kIHdlIG5lZWQgdGhlbSBhbGwgZG93biBiZWZvcmUgd2UgY2FuIGFkZCBIVE1MIGV0YyB0byB0aGUgcGFnZVxcbiAgICAgICAgdGhpcy5wYXJlbnQuYXBpLmdldExpYnJhcmllcyhpZCwgdHJ1ZSk7XFxuICAgIH0sXFxuXFxuICAgIGNvbXBvbmVudF9hZGRfaHRtbDogZnVuY3Rpb24gY29tcG9uZW50X2FkZF9odG1sKGlkKSB7XFxuXFxuICAgICAgICB0aGlzLnBhcmVudC5mbGFnX2RpcnR5ID0gdHJ1ZTtcXG4gICAgICAgIHZhciBkYXRhX3Jlc2l6ZSA9IHR5cGVvZiB0aGlzLnBhcmVudC5jb21wb25lbnRzW2lkXS5jb25mLnJlc2l6ZWFibGUgIT0gXFxcInVuZGVmaW5lZFxcXCIgJiYgdGhpcy5wYXJlbnQuY29tcG9uZW50c1tpZF0uY29uZi5yZXNpemVhYmxlID09IHRydWUgPyBcXFwiZGF0YS1tbGFiLWFzcGVjdHJhdGlvPSc0OjMnIGRhdGEtbWxhYi1zaXplPSdtZWRpdW0nXFxcIiA6IFxcXCJcXFwiO1xcbiAgICAgICAgdmFyIGRhdGFfZGlzcGxheV9kZXBlbmRlbnQgPSB0eXBlb2YgdGhpcy5wYXJlbnQuY29tcG9uZW50c1tpZF0uY29uZi5kaXNwbGF5X2RlcGVuZGVudCAhPSBcXFwidW5kZWZpbmVkXFxcIiAmJiB0aGlzLnBhcmVudC5jb21wb25lbnRzW2lkXS5jb25mLmRpc3BsYXlfZGVwZW5kZW50ID09IHRydWUgPyBcXFwiZGF0YS1tbGFiLWRpc3BsYXlkZXBlbmRlbnQ9J3RydWUnXFxcIiA6IFxcXCJcXFwiO1xcblxcbiAgICAgICAgLy9hZGQgYSBESVYgd3JhcHBlciBhcm91bmQgYWxsIGNvbXBvbmVudHMsIG1ha2VzIGl0IGVhc2llciB0byBtb3ZlIGl0IHVwL2Rvd24gbGF0ZXJcXG4gICAgICAgIC8vZm9yIHJlc2l6YWJsZSBjb21wb25lbnRzIHdlIGFkZCBhIHNlY29uZCBkaXYgd2hpY2ggaXMgdXNlZCBmb3Igc2V0dGluIHNpemUgb2YgY29udGVudC4gRG9pbmcgdGhpcyBvbiB0aGUgb3V0ZXIgZGl2IG1lc3NzIHRoaW5ncyB1cCBhdCBkZXNpZ24gdGltZVxcbiAgICAgICAgaWYgKGRhdGFfcmVzaXplICE9IFxcXCJcXFwiKSB7XFxuICAgICAgICAgICAgdmFyIG5ld19jb21wID0gJChcXFwiPGRpdiBkYXRhLW1sYWItdHlwZT0nXFxcIiArIGlkICsgXFxcIicgXFxcIiArIGRhdGFfZGlzcGxheV9kZXBlbmRlbnQgKyBcXFwiIHN0eWxlPSdkaXNwbGF5OiBibG9jazsnPjxkaXYgZGF0YS1tbGFiLXNpemVyPScxJyBcXFwiICsgZGF0YV9yZXNpemUgKyBcXFwiID5cXFwiICsgdGhpcy5wYXJlbnQuY29tcG9uZW50c1tpZF0uaHRtbCArIFxcXCI8L2Rpdj48L2Rpdj5cXFwiKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgdmFyIG5ld19jb21wID0gJChcXFwiPGRpdiBkYXRhLW1sYWItdHlwZT0nXFxcIiArIGlkICsgXFxcIicgXFxcIiArIGRhdGFfZGlzcGxheV9kZXBlbmRlbnQgKyBcXFwiIHN0eWxlPSdkaXNwbGF5OiBibG9jazsnPlxcXCIgKyB0aGlzLnBhcmVudC5jb21wb25lbnRzW2lkXS5odG1sICsgXFxcIjwvZGl2PlxcXCIpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgJChcXFwiI1xcXCIgKyB0aGlzLnBhcmVudC5jb25maWdbXFxcImFwcFxcXCJdW1xcXCJjb250ZW50X2lkXFxcIl0pLmFwcGVuZChuZXdfY29tcCk7XFxuICAgICAgICBuZXdfY29tcC5vbihcXFwiY2xpY2tcXFwiLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgdmFyIHByZXBfbWVudSA9IG1sYWIuZHQuYXBpLmRpc3BsYXkuY29tcG9uZW50SGlnaGxpZ2h0U2VsZWN0ZWQoJCh0aGlzKSk7aWYgKHByZXBfbWVudSkge1xcbiAgICAgICAgICAgICAgICBtbGFiLmR0LmRlc2lnbi5jb21wb25lbnRfbWVudV9wcmVwYXJlKCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgICAgICBuZXdfY29tcC5vbihcXFwiaW5wdXRcXFwiLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgbWxhYi5kdC5mbGFnX2RpcnR5ID0gdHJ1ZTtcXG4gICAgICAgIH0pO1xcblxcbiAgICAgICAgLy9wcm9jZXNzIGFsbCBrZXlzIGlmIHRoaXMgY29tcG9uZW50IHdhbnRzIHRvIG1hbmlwdWxhdGUgdGhlbSAoaS5lLiB0aGUgcHJvY2Vzc19rZXlwcmVzcyBzZXR0aW5nIGV4aXN0cylcXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5wYXJlbnQuY29tcG9uZW50c1tpZF0uY29uZi5wcm9jZXNzX2tleXByZXNzICE9IFxcXCJ1bmRlZmluZWRcXFwiICYmIHRoaXMucGFyZW50LmNvbXBvbmVudHNbaWRdLmNvbmYucHJvY2Vzc19rZXlwcmVzcykge1xcbiAgICAgICAgICAgICQobmV3X2NvbXApLmtleWRvd24oZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgICAgICAgbWxhYi5kdC5jb21wb25lbnRzWyQodGhpcykuZGF0YShcXFwibWxhYi10eXBlXFxcIildLmNvZGUub25LZXlQcmVzcyhlKTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgICQoJy5tbGFiX2N1cnJlbnRfY29tcG9uZW50JykucXRpcCgnaGlkZScpO1xcblxcbiAgICAgICAgaWYgKHRoaXMucGFyZW50LmFwaS5kaXNwbGF5LmNvbXBvbmVudEhpZ2hsaWdodFNlbGVjdGVkKG5ld19jb21wKSkge1xcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50X21lbnVfcHJlcGFyZSgpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgLy9zY3JvbGwgZG93biB3aGVyZSB0aGUgY29tcG9uZW50IGlzIGFkZGVkXFxuICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgZG9jdW1lbnQuYm9keS5zY3JvbGxIZWlnaHQpO1xcblxcbiAgICAgICAgLy9maW5hbGx5IHdlIGFkZCBkZXBlbmRlbmNpZXMsIGkuZS4gY29tcG9uZW50cyB0aGF0IHRoaXMgY29tcG9uZW50IGRlcGVuZHMgb25cXG4gICAgICAgIGlmICh0aGlzLnBhcmVudC5jb21wb25lbnRzW2lkXS5oYXNPd25Qcm9wZXJ0eShcXFwiY29uZlxcXCIpICYmIHRoaXMucGFyZW50LmNvbXBvbmVudHNbaWRdLmNvbmYuaGFzT3duUHJvcGVydHkoXFxcImRlcGVuZGVuY2llc1xcXCIpKSB7XFxuICAgICAgICAgICAgZm9yIChjb21wb25lbnQgaW4gdGhpcy5wYXJlbnQuY29tcG9uZW50c1tpZF0uY29uZi5kZXBlbmRlbmNpZXMpIHtcXG4gICAgICAgICAgICAgICAgdGhpcy5mZWF0dXJlX2FkZCh0aGlzLnBhcmVudC5jb21wb25lbnRzW2lkXS5jb25mLmRlcGVuZGVuY2llc1swXSwgdHJ1ZSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgLy9leGVjdXRlIGJhY2tlbmQgY29kZSB3aGljaCBwZXJmb3JtcyB0YXNrcyBsaWtlIGFkZGluZyB0aGUgcGVybWlzc2lvbnMgcmVxdWlyZWQgdG8gdGhlIG1hbmlmZXN0IGZpbGUsIGNvcHlpbmcgaW5jbHVkZSBmaWxlcyBhbmQgc28gb25cXG4gICAgICAgIHZhciB1cmwgPSB0aGlzLnBhcmVudC51cmxzLmNvbXBvbmVudF9hZGRlZC5yZXBsYWNlKFxcXCJfQVBQSURfXFxcIiwgdGhpcy5wYXJlbnQuYXBwLmlkKTtcXG4gICAgICAgIHVybCA9IHVybC5yZXBsYWNlKFxcXCJfQ09NUElEX1xcXCIsIGlkKTtcXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcXG4gICAgICAgIHZhciBjb21wX2lkID0gaWQ7XFxuXFxuICAgICAgICB2YXIgcmVxdWVzdCA9ICQuYWpheCh7XFxuICAgICAgICAgICAgdHlwZTogXFxcIkdFVFxcXCIsXFxuICAgICAgICAgICAgdXJsOiB1cmwsXFxuICAgICAgICAgICAgZGF0YVR5cGU6IFxcXCJqc29uXFxcIlxcbiAgICAgICAgfSk7XFxuXFxuICAgICAgICAvL3dhcyB3aGVyZSBYWFhYIGlzIG5vdzpcXG4gICAgICAgIHRoaXMucGFyZW50LmRyYWdfb3JpZ2luID0gJ3NvcnRhYmxlJztcXG4gICAgICAgIC8vaWYgdGhpcyBpcyBhIHJlc2l6YWJsZSBjb21wb25lbnQgd2UgZG8gdGhlIGluaXRpYWwgcmVzaXppbmcgaGVyZVxcbiAgICAgICAgaWYgKGRhdGFfcmVzaXplICE9IFxcXCJcXFwiKSB7XFxuICAgICAgICAgICAgdGhpcy5wYXJlbnQuYXBpLmRpc3BsYXkudXBkYXRlRGlzcGxheSgkKG5ld19jb21wKS5jaGlsZHJlbignW2RhdGEtbWxhYi1zaXplcl0nKSk7XFxuICAgICAgICB9XFxuICAgICAgICAvL2lmIHRoaXMgY29tcG9uZW50IHJlcXVpcmVzIGFueSBjcmVkZW50aWFscyB3ZSByZXF1ZXN0IHRoZW0gaGVyZVxcbiAgICAgICAgdmFyIGxvY2FsX2NvbXAgPSBuZXdfY29tcDtcXG4gICAgICAgIHZhciBsb2NhbF9jb21wX2lkID0gY29tcF9pZDtcXG4gICAgICAgIHZhciBjcmVkX2VsID0gJChcXFwiW2RhdGEtbWxhYi1jb21wLXRvb2w9J2NyZWRlbnRpYWxzJ11cXFwiKTtcXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodGhpcy5wYXJlbnQuY29tcG9uZW50c1tjb21wX2lkXS5jb25mLmNyZWRlbnRpYWxzKSA9PT0gXFxcIltvYmplY3QgQXJyYXldXFxcIikge1xcbiAgICAgICAgICAgIHRoaXMucGFyZW50LmFwaS5nZXRDcmVkZW50aWFscyhjcmVkX2VsLCBjb21wX2lkLCB0aGlzLnBhcmVudC5jb21wb25lbnRzW2NvbXBfaWRdLmNvbmYuY3JlZGVudGlhbHMsIGZ1bmN0aW9uIChjcmVkZW50aWFscywgcGFyYW1zKSB7XFxuICAgICAgICAgICAgICAgIG1sYWIuZHQuZGVzaWduLmNvbXBvbmVudF9zdG9yZV9jcmVkZW50aWFscyhjcmVkZW50aWFscywgcGFyYW1zKTt0aGF0LmNvbXBvbmVudF9ydW5fY29kZShsb2NhbF9jb21wLCBsb2NhbF9jb21wX2lkLCB0cnVlKTtcXG4gICAgICAgICAgICB9LCBmYWxzZSwgeyBjb21wb25lbnQ6IG5ld19jb21wIH0pO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudF9ydW5fY29kZShsb2NhbF9jb21wLCBsb2NhbF9jb21wX2lkLCB0cnVlKTtcXG4gICAgICAgIH1cXG4gICAgICAgIC8vZW5kIFhYWFhcXG5cXG4gICAgICAgIHJlcXVlc3QuZG9uZShmdW5jdGlvbiAocmVzdWx0KSB7XFxuICAgICAgICAgICAgaWYgKHJlc3VsdC5yZXN1bHQgPT0gXFxcInN1Y2Nlc3NcXFwiKSB7XFxuICAgICAgICAgICAgICAgIC8vWFhYWCAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICBhbGVydChyZXN1bHQubXNnICsgXFxcIidcXFxcblxcXFxuXFxcIiArIF90cltcXFwibWxhYi5kdC5kZXNpZ24uanMuYWxlcnQuYWRkLmNvbXBcXFwiXSk7XFxuICAgICAgICAgICAgICAgICQobmV3X2NvbXApLnJlbW92ZSgpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcblxcbiAgICAgICAgcmVxdWVzdC5mYWlsKGZ1bmN0aW9uIChqcVhIUiwgdGV4dFN0YXR1cykge1xcbiAgICAgICAgICAgIGFsZXJ0KF90cltcXFwibWxhYi5kdC5kZXNpZ24uanMuYWxlcnQuZXJyb3Iub2NjdXJyZWRcXFwiXSArIFxcXCI6ICdcXFwiICsganFYSFIucmVzcG9uc2VUZXh0ICsgXFxcIidcXFxcblxcXFxuXFxcIiArIF90cltcXFwibWxhYi5kdC5kZXNpZ24uanMuYWxlcnQuYWRkLmNvbXBcXFwiXSk7XFxuICAgICAgICAgICAgJChuZXdfY29tcCkucmVtb3ZlKCk7XFxuICAgICAgICAgICAgdGhpcy5wYXJlbnQuZmxhZ19kaXJ0eSA9IGZhbHNlO1xcbiAgICAgICAgfSk7XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcclxcbiAgICAgKiBUaGlzIGV4ZWN1dGVzICh1c2luZyBldmFsKCkpIGFueSBjb2RlIGZvciBhIGNvbXBvbmVudCB0aGF0IGlzIGFkZGVkIHRvIHRoZSBhcHBcXHJcXG4gICAgICogQHBhcmFtIHt0eXBlfSBlbCA9IGh0bWwgZWxlbWVudCB3ZSdyZSB3b3JraW5nIG9uXFxyXFxuICAgICAqIEBwYXJhbSB7dHlwZX0gY29tcF9pZFxcclxcbiAgICAgKiBAcGFyYW0ge3R5cGV9IGNyZWF0ZWRcXHJcXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cXHJcXG4gICAgICovXFxuICAgIGNvbXBvbmVudF9ydW5fY29kZTogZnVuY3Rpb24gY29tcG9uZW50X3J1bl9jb2RlKGVsLCBjb21wX2lkLCBjcmVhdGVkKSB7XFxuICAgICAgICBpZiAodHlwZW9mIHRoaXMucGFyZW50LmNvbXBvbmVudHNbY29tcF9pZF0gPT0gXFxcInVuZGVmaW5lZFxcXCIgfHwgdHlwZW9mIHRoaXMucGFyZW50LmNvbXBvbmVudHNbY29tcF9pZF0uY29kZSA9PSBcXFwidW5kZWZpbmVkXFxcIikge1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIC8qICAgICAgICBpZiAoIW1sYWIuZHQucXRpcF90b29scykge1xcclxcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xcclxcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHRoYXQuY29tcG9uZW50X3J1bl9jb2RlKGVsLCBjb21wX2lkLCBjcmVhdGVkKSB9LCA1MDAgKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgKi9cXG5cXG4gICAgICAgIGlmIChjcmVhdGVkKSB7XFxuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50LmNvbXBvbmVudHNbY29tcF9pZF0uY29uZi5leHBlcmltZW50YWwpIHtcXG4gICAgICAgICAgICAgICAgYWxlcnQoXFxcIlBsZWFzZSBiZSBhd2FyZSB0aGF0IHRoaXMgY29tcG9uZW50IGlzIGluIHRoZSB0ZXN0aW5nIHN0YWdlLiBEbyBub3QgdXNlIGl0IGZvciBhcHBzIHlvdSB3aWxsIHNoYXJlIHdpdGggb3RoZXJzLlxcXCIpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMucGFyZW50LmNvbXBvbmVudHNbY29tcF9pZF0uY29kZS5vbkNyZWF0ZSAhPSBcXFwidW5kZWZpbmVkXFxcIikge1xcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5jb21wb25lbnRzW2NvbXBfaWRdLmNvZGUub25DcmVhdGUoZWwpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAvL2lmIHRoZSBjb21wb25lbnQgaGFzIGFuIGF1dG9ydW4gZnVuY3Rpb24gZWZpbmVkIHdlIGNhbGwgaXQgaGVyZSwgd2l0aCB0aGUgY29tcG9uZXQgYXMgdGhlIHBhcmFtZXRlclxcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5wYXJlbnQuY29tcG9uZW50c1tjb21wX2lkXS5jb25mLmF1dG9ydW5fb25fY3JlYXRlID09IFxcXCJzdHJpbmdcXFwiKSB7XFxuICAgICAgICAgICAgICAgIHZhciBmdW5jID0gdGhpcy5wYXJlbnQuY29tcG9uZW50c1tjb21wX2lkXS5jb25mLmF1dG9ydW5fb25fY3JlYXRlO1xcbiAgICAgICAgICAgICAgICBldmFsKFxcXCJ0aGlzLnBhcmVudC5jb21wb25lbnRzW2NvbXBfaWRdLmNvZGUuXFxcIiArIGZ1bmMgKyBcXFwiKGVsLCB7Y3VycmVudFRhcmdldDogbWxhYi5kdC5xdGlwX3Rvb2xzLnF0aXAoKS50b29sdGlwLmZpbmQoJ1tkYXRhLW1sYWItY29tcC10b29sLWlkPVxcXFxcXFwiXFxcIiArIGZ1bmMgKyBcXFwiXFxcXFxcXCJdJylbMF19KTtcXFwiKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLnBhcmVudC5jb21wb25lbnRzW2NvbXBfaWRdLmNvZGUub25Mb2FkICE9IFxcXCJ1bmRlZmluZWRcXFwiKSB7XFxuICAgICAgICAgICAgdGhpcy5wYXJlbnQuY29tcG9uZW50c1tjb21wX2lkXS5jb2RlLm9uTG9hZChlbCk7XFxuICAgICAgICB9XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcclxcbiAgICAgKiBSdW5zIGEgcmFuZG9tIGZ1bmN0aW9uIGluIHRoZSBiYWNrZW5kIGNvZGUgb2YgYSBjb21wb25lbnQsIGkuZS4gaW4gdGhlIHNlcnZlcl9jb2RlLnBocCBmaWxlLlxcclxcbiAgICAgKiBAcGFyYW0ge3R5cGV9IGVsXFxyXFxuICAgICAqIEBwYXJhbSB7dHlwZX0gY29tcF9pZFxcclxcbiAgICAgKiBAcGFyYW0ge3R5cGV9IGZ1bmNfbmFtZVxcclxcbiAgICAgKiBAcGFyYW0ge3R5cGV9IGNhbGxiYWNrXFxyXFxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XFxyXFxuICAgICAqL1xcbiAgICBjb21wb25lbnRfcnVuX2JhY2tlbmRfY29kZTogZnVuY3Rpb24gY29tcG9uZW50X3J1bl9iYWNrZW5kX2NvZGUoZWwsIGNvbXBfaWQsIGZ1bmNfbmFtZSwgY2FsbGJhY2spIHtcXG4gICAgICAgIC8vZXhlY3V0ZSBzcGVjaWZpZWQgYmFja2VuZCBjb2RlIGZvciB0aGlzIGNvbXBvbmVudFxcbiAgICAgICAgdmFyIHVybCA9IHRoaXMucGFyZW50LnVybHMuY29tcG9uZW50X3J1bl9mdW5jdGlvbi5yZXBsYWNlKFxcXCJfQVBQSURfXFxcIiwgdGhpcy5wYXJlbnQuYXBwLmlkKTtcXG4gICAgICAgIHVybCA9IHVybC5yZXBsYWNlKFxcXCJfQ09NUElEX1xcXCIsIGNvbXBfaWQpO1xcbiAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoXFxcIl9GVU5DTkFNRV9cXFwiLCBmdW5jX25hbWUpO1xcbiAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoXFxcIl9QQUdFTlVNX1xcXCIsIHRoaXMucGFyZW50LmFwcC5jdXJyX3BhZ2VfbnVtKTtcXG5cXG4gICAgICAgIHZhciBsb2NhbF9jYWxsYmFjayA9IGNhbGxiYWNrLFxcbiAgICAgICAgICAgIGxvY2FsX2VsID0gZWw7XFxuXFxuICAgICAgICAkLmFqYXgoe1xcbiAgICAgICAgICAgIHR5cGU6ICdHRVQnLFxcbiAgICAgICAgICAgIHVybDogdXJsLFxcbiAgICAgICAgICAgIGRhdGFUeXBlOiAnanNvbicsXFxuICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gc3VjY2VzcyhkYXRhKSB7XFxuICAgICAgICAgICAgICAgIGlmIChkYXRhLnJlc3VsdCA9PSBcXFwic3VjY2Vzc1xcXCIpIHtcXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsX2NhbGxiYWNrKGxvY2FsX2VsLCBkYXRhLmh0bWwpO1xcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxfY2FsbGJhY2sobG9jYWxfZWwsIFxcXCI8aDE+ZmFpbGVkPC9oMT5cXFwiKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uIGVycm9yKF9lcnJvcikge1xcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhfZXJyb3IpO2xvY2FsX2NhbGxiYWNrKGxvY2FsX2VsLCBcXFwiPGgxPmZhaWxlZDwvaDE+XFxcIik7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgIH0sXFxuXFxuICAgIGNvbXBvbmVudF9tb3ZldXA6IGZ1bmN0aW9uIGNvbXBvbmVudF9tb3ZldXAoZWwpIHtcXG4gICAgICAgIGlmICh0eXBlb2YgZWwgPT0gXFxcInVuZGVmaW5lZFxcXCIpIHtcXG4gICAgICAgICAgICB2YXIgZWwgPSAkKFxcXCIubWxhYl9jdXJyZW50X2NvbXBvbmVudFxcXCIpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKGVsLmxlbmd0aCA9PSAwKSB7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcbiAgICAgICAgZWwuZmFkZU91dCg1MDAsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBlbC5pbnNlcnRCZWZvcmUoZWwucHJldigpKTtcXG4gICAgICAgICAgICB2YXIgbG9jYWxfZWwgPSBlbDtcXG4gICAgICAgICAgICBlbC5mYWRlSW4oNTAwLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgIGxvY2FsX2VsLnF0aXAoXFxcImFwaVxcXCIpLnJlcG9zaXRpb24obnVsbCwgZmFsc2UpO1xcbiAgICAgICAgICAgICAgICBpZiAobWxhYi5kdC5hcGkucHJvcGVydGllc190b29sdGlwKSB7XFxuICAgICAgICAgICAgICAgICAgICAkKG1sYWIuZHQuYXBpLnByb3BlcnRpZXNfdG9vbHRpcCkucXRpcChcXFwiYXBpXFxcIikucmVwb3NpdGlvbihudWxsLCBmYWxzZSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH0pO1xcbiAgICAgICAgdGhpcy5wYXJlbnQuZmxhZ19kaXJ0eSA9IHRydWU7XFxuICAgIH0sXFxuXFxuICAgIGNvbXBvbmVudF9tb3ZlZG93bjogZnVuY3Rpb24gY29tcG9uZW50X21vdmVkb3duKCkge1xcbiAgICAgICAgaWYgKHR5cGVvZiBlbCA9PSBcXFwidW5kZWZpbmVkXFxcIikge1xcbiAgICAgICAgICAgIHZhciBlbCA9ICQoXFxcIi5tbGFiX2N1cnJlbnRfY29tcG9uZW50XFxcIik7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoZWwubGVuZ3RoID09IDApIHtcXG4gICAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuICAgICAgICBlbC5mYWRlT3V0KDUwMCwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIGVsLmluc2VydEFmdGVyKGVsLm5leHQoKSk7XFxuICAgICAgICAgICAgdmFyIGxvY2FsX2VsID0gZWw7XFxuICAgICAgICAgICAgZWwuZmFkZUluKDUwMCwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICBsb2NhbF9lbC5xdGlwKFxcXCJhcGlcXFwiKS5yZXBvc2l0aW9uKG51bGwsIGZhbHNlKTtcXG4gICAgICAgICAgICAgICAgaWYgKG1sYWIuZHQuYXBpLnByb3BlcnRpZXNfdG9vbHRpcCkge1xcbiAgICAgICAgICAgICAgICAgICAgJChtbGFiLmR0LmFwaS5wcm9wZXJ0aWVzX3Rvb2x0aXApLnF0aXAoXFxcImFwaVxcXCIpLnJlcG9zaXRpb24obnVsbCwgZmFsc2UpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9KTtcXG4gICAgICAgIHRoaXMucGFyZW50LmZsYWdfZGlydHkgPSB0cnVlO1xcbiAgICB9LFxcblxcbiAgICBpbnZlcnRfY29sb3I6IGZ1bmN0aW9uIGludmVydF9jb2xvcihyZ2IpIHtcXG4gICAgICAgIHJnYiA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5qb2luKFxcXCIsXFxcIikucmVwbGFjZSgvcmdiXFxcXCh8XFxcXCl8cmdiYVxcXFwofFxcXFwpfFxcXFxzL2dpLCAnJykuc3BsaXQoJywnKTtcXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmdiLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgICAgcmdiW2ldID0gKGkgPT09IDMgPyAxIDogMjU1KSAtIHJnYltpXTtcXG4gICAgICAgIH1yZXR1cm4gcmdiLmpvaW4oXFxcIiwgXFxcIik7XFxuICAgIH0sXFxuXFxuICAgIGNvbXBvbmVudF9kZWxldGU6IGZ1bmN0aW9uIGNvbXBvbmVudF9kZWxldGUoY3V0KSB7XFxuICAgICAgICBkZWJ1Z2dlcjtcXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcXG4gICAgICAgIGlmIChjdXQpIHtcXG4gICAgICAgICAgICBpZiAoZWwubGVuZ3RoID09IDApIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB2YXIgY29tcF9pZCA9IGVsLmRhdGEoXFxcIm1sYWItdHlwZVxcXCIpO1xcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5wYXJlbnQuY29tcG9uZW50c1tjb21wX2lkXS5jb2RlLm9uRGVsZXRlICE9IFxcXCJ1bmRlZmluZWRcXFwiKSB7XFxuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmNvbXBvbmVudHNbY29tcF9pZF0uY29kZS5vbkRlbGV0ZShlbCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIG1sYWIuZHQuYXBpLmNsb3NlQWxsUHJvcGVydHlEaWFsb2dzKCk7XFxuICAgICAgICAgICAgdmFyIHNlbF9jb21wID0gJChcXFwiLm1sYWJfY3VycmVudF9jb21wb25lbnRcXFwiKS5wcmV2KCk7XFxuICAgICAgICAgICAgaWYgKHNlbF9jb21wLmxlbmd0aCA9PSAwKSB7XFxuICAgICAgICAgICAgICAgIHNlbF9jb21wID0gJChcXFwiLm1sYWJfY3VycmVudF9jb21wb25lbnRcXFwiKS5uZXh0KCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICQoXFxcIi5tbGFiX2N1cnJlbnRfY29tcG9uZW50XFxcIikucXRpcCgnaGlkZScpO1xcbiAgICAgICAgICAgICQoXFxcIi5tbGFiX2N1cnJlbnRfY29tcG9uZW50XFxcIikucmVtb3ZlKCk7XFxuICAgICAgICAgICAgaWYgKHNlbF9jb21wLmxlbmd0aCA+IDApIHtcXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50LmFwaS5kaXNwbGF5LmNvbXBvbmVudEhpZ2hsaWdodFNlbGVjdGVkKHNlbF9jb21wKSkge1xcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wb25lbnRfbWVudV9wcmVwYXJlKCk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgdGhpcy5wYXJlbnQuZmxhZ19kaXJ0eSA9IHRydWU7XFxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgICB9XFxuXFxuICAgICAgICAkKFxcXCIjbWxhYl9kaWFsb2dfZGVsZXRlXFxcIikuZGlhbG9nKHtcXG4gICAgICAgICAgICB0aXRsZTogX3RyW1xcXCJidWlsZF9hcHAuZGlhbG9nLmRlbGV0ZS50aXRsZVxcXCJdLFxcbiAgICAgICAgICAgIGRpYWxvZ0NsYXNzOiBcXFwibm8tY2xvc2VcXFwiLFxcbiAgICAgICAgICAgIG1vZGFsOiB0cnVlLFxcbiAgICAgICAgICAgIGJ1dHRvbnM6IFt7IHRleHQ6IF90cltcXFwibWxhYi5kdC5hcGkuanMuZ2V0TGluay5va1xcXCJdLFxcbiAgICAgICAgICAgICAgICBjbGljazogZnVuY3Rpb24gY2xpY2soKSB7XFxuICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLmRpYWxvZygnZGVzdHJveScpO1xcbiAgICAgICAgICAgICAgICAgICAgLy9EZWxldGVzXFxuICAgICAgICAgICAgICAgICAgICB2YXIgZWwgPSAkKFxcXCIubWxhYl9jdXJyZW50X2NvbXBvbmVudFxcXCIpO1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsLmxlbmd0aCA9PSAwKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgbWxhYi5kdC5hcGkuY2xvc2VBbGxQcm9wZXJ0eURpYWxvZ3MoKTtcXG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWxfY29tcCA9IGVsLnByZXYoKTtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxfY29tcC5sZW5ndGggPT0gMCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbF9jb21wID0gZWwubmV4dCgpO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgZWwucXRpcCgnaGlkZScpO1xcblxcbiAgICAgICAgICAgICAgICAgICAgLy9jYWxsIG9uZGVsZXRlIGluIGNvbXBvbmVudCBpZiBpdCBleGlzdHNcXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb21wX2lkID0gZWwuZGF0YShcXFwibWxhYi10eXBlXFxcIik7XFxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoYXQucGFyZW50LmNvbXBvbmVudHNbY29tcF9pZF0uY29kZS5vbkRlbGV0ZSAhPSBcXFwidW5kZWZpbmVkXFxcIikge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQucGFyZW50LmNvbXBvbmVudHNbY29tcF9pZF0uY29kZS5vbkRlbGV0ZShlbCk7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgICAgICBlbC5yZW1vdmUoKTtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxfY29tcC5sZW5ndGggPiAwKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoYXQucGFyZW50LmFwaS5kaXNwbGF5LmNvbXBvbmVudEhpZ2hsaWdodFNlbGVjdGVkKHNlbF9jb21wKSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmNvbXBvbmVudF9tZW51X3ByZXBhcmUoKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICB0aGF0LnBhcmVudC5mbGFnX2RpcnR5ID0gdHJ1ZTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0sIHsgdGV4dDogX3RyW1xcXCJtbGFiLmR0LmFwaS5qcy5nZXRMaW5rLmNhbmNlbFxcXCJdLFxcbiAgICAgICAgICAgICAgICBjbGljazogZnVuY3Rpb24gY2xpY2soKSB7XFxuICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLmRpYWxvZygnZGVzdHJveScpO1xcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfV1cXG4gICAgICAgIH0pO1xcbiAgICB9LFxcblxcbiAgICAvL2dldHMgYSBodG1sIHBhZ2UgdG8gc2hvdyBhcyBoZWxwIGZvciBtYWtpbmcgdGhlIGNvbXBvbmVudCBhdCBkdFxcbiAgICBjb21wb25lbnRfaGVscDogZnVuY3Rpb24gY29tcG9uZW50X2hlbHAoKSB7XFxuICAgICAgICB2YXIgY29tcF9pZCA9ICQoXFxcIi5tbGFiX2N1cnJlbnRfY29tcG9uZW50XFxcIikuZGF0YShcXFwibWxhYi10eXBlXFxcIik7XFxuICAgICAgICB2YXIgZXh0ZW5kZWRfbmFtZSA9IHRoaXMucGFyZW50LmFwaS5nZXRMb2NhbGVDb21wb25lbnRNZXNzYWdlKGNvbXBfaWQsIFtcXFwiZXh0ZW5kZWRfbmFtZVxcXCJdKTtcXG4gICAgICAgIHZhciBvd25lcl9lbGVtZW50ID0gJChcXFwiLm1sYWJfaGVscF9pY29uXFxcIik7XFxuICAgICAgICB2YXIgcVRpcENsYXNzID0gJ21sYWJfY29tcF9oZWxwX3FUaXAnO1xcbiAgICAgICAgdmFyIHRpdGxlID0gX3RyW1xcXCJtbGFiLmR0LmRlc2lnbi5qcy5xdGlwLmhlbHAudGl0bGVcXFwiXSArIFxcXCIgLSBcXFwiICsgZXh0ZW5kZWRfbmFtZTtcXG4gICAgICAgIHRoaXMucGFyZW50LmFwaS5kaXNwbGF5RXh0ZXJuYWxIZWxwZmlsZShjb21wX2lkLCB0aXRsZSwgb3duZXJfZWxlbWVudCwgcVRpcENsYXNzKTtcXG4gICAgfSxcXG5cXG4gICAgLy9jdXQgYW5kIGNvcHkgc2ltcGx5IHRha2VzIHRoZSBjb21wbGV0ZSBvdXRlckhUTUwgYW5kIHB1dHMgaXQgaW50byBhIGxvY2FsIHZhcmlhYmxlLCBtbGFiLmR0LmNsaXBib2FyZFxcbiAgICBjb21wb25lbnRfY3V0OiBmdW5jdGlvbiBjb21wb25lbnRfY3V0KCkge1xcbiAgICAgICAgdmFyIGN1dCA9IHRydWU7XFxuICAgICAgICBtbGFiLmR0LmNsaXBib2FyZCA9ICQoXFxcIi5tbGFiX2N1cnJlbnRfY29tcG9uZW50XFxcIikuY2xvbmUoKTtcXG4gICAgICAgIHRoaXMuY29tcG9uZW50X2RlbGV0ZShjdXQpO1xcbiAgICB9LFxcblxcbiAgICBjb21wb25lbnRfY29weTogZnVuY3Rpb24gY29tcG9uZW50X2NvcHkoKSB7XFxuICAgICAgICBtbGFiLmR0LmNsaXBib2FyZCA9ICQoXFxcIi5tbGFiX2N1cnJlbnRfY29tcG9uZW50XFxcIikuY2xvbmUoKTtcXG4gICAgfSxcXG5cXG4gICAgLy93aGVuIHRoZXkgcGFzdCB3ZSBuZWVkIHRvIGdvIHRocm91Z2ggc2ltaWxhciBjaGVja3MgYXMgd2UgZG8gd2hlbiBhZGRpbmcgYSBjb21wb25lbnQsIGxpa2UgaXMgaXQgdW5pcXVlLCBldGMuXFxuICAgIC8vYWxzbyBuZWVkIHRvIGF0dGFjaCBldmVudCBoYW5kbGVycywgZXRjLCB0aGV5IGFyZSBsb3N0IGFzIFxcbiAgICBjb21wb25lbnRfcGFzdGU6IGZ1bmN0aW9uIGNvbXBvbmVudF9wYXN0ZSgpIHtcXG4gICAgICAgIHZhciBjb21wX2lkID0gbWxhYi5kdC5jbGlwYm9hcmQuZGF0YShcXFwibWxhYi10eXBlXFxcIik7XFxuICAgICAgICBpZiAodGhpcy5wYXJlbnQuY29tcG9uZW50c1tjb21wX2lkXS5jb25mLnVuaXF1ZSAmJiAkKFxcXCIjXFxcIiArIHRoaXMucGFyZW50LmNvbmZpZ1tcXFwiYXBwXFxcIl1bXFxcImNvbnRlbnRfaWRcXFwiXSkuZmluZChcXFwiW2RhdGEtbWxhYi10eXBlPSdcXFwiICsgY29tcF9pZCArIFxcXCInXVxcXCIpLmxlbmd0aCA+IDApIHtcXG4gICAgICAgICAgICBhbGVydChfdHJbXFxcIm1sYWIuZHQuZGVzaWduLmpzLmFsZXJ0Lm9ubHkub25lLmNvbXBcXFwiXSk7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcbiAgICAgICAgLy9yZW1vdmUgc2VsZWN0aW9ucywgaGlnaGxpZ2h0LCBldGMgZm9yIHByZXZpb3VzbHkgc2VsZWN0ZWQgY29tcG9uZW50XFxuICAgICAgICB0aGlzLmNvbXBvbmVudEJsdXIoY3VyQ29tcCk7XFxuXFxuICAgICAgICAkKFxcXCIjXFxcIiArIHRoaXMucGFyZW50LmNvbmZpZ1tcXFwiYXBwXFxcIl1bXFxcImNvbnRlbnRfaWRcXFwiXSkuYXBwZW5kKG1sYWIuZHQuY2xpcGJvYXJkKTtcXG4gICAgICAgIGlmICh0aGlzLnBhcmVudC5hcGkuZGlzcGxheS5jb21wb25lbnRIaWdobGlnaHRTZWxlY3RlZChtbGFiLmR0LmNsaXBib2FyZCkpIHtcXG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudF9tZW51X3ByZXBhcmUoKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgLy9UT0RPIC0gdGhlIGNoZWNrIGRvZXMgbm90IHdvcmsuLi4uLlxcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50X21lbnVfcHJlcGFyZSgpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgd2luZG93LnNjcm9sbFRvKDAsIGRvY3VtZW50LmJvZHkuc2Nyb2xsSGVpZ2h0KTtcXG4gICAgICAgIG1sYWIuZHQuY2xpcGJvYXJkLm9uKFxcXCJjbGlja1xcXCIsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICB2YXIgcHJlcF9tZW51ID0gbWxhYi5kdC5hcGkuZGlzcGxheS5jb21wb25lbnRIaWdobGlnaHRTZWxlY3RlZCgkKHRoaXMpKTtpZiAocHJlcF9tZW51KSB7XFxuICAgICAgICAgICAgICAgIG1sYWIuZHQuZGVzaWduLmNvbXBvbmVudF9tZW51X3ByZXBhcmUoKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgICAgIG1sYWIuZHQuY2xpcGJvYXJkLm9uKFxcXCJpbnB1dFxcXCIsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBtbGFiLmR0LmZsYWdfZGlydHkgPSB0cnVlO1xcbiAgICAgICAgfSk7XFxuXFxuICAgICAgICAvL3Byb2Nlc3MgYWxsIGtleXMgaWYgdGhpcyBjb21wb25lbnQgd2FudHMgdG8gbWFuaXB1bGF0ZSB0aGVtIChpLmUuIHRoZSBwcm9jZXNzX2tleXByZXNzIHNldHRpbmcgZXhpc3RzKVxcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnBhcmVudC5jb21wb25lbnRzW2NvbXBfaWRdLmNvbmYucHJvY2Vzc19rZXlwcmVzcyAhPSBcXFwidW5kZWZpbmVkXFxcIiAmJiB0aGlzLnBhcmVudC5jb21wb25lbnRzW2NvbXBfaWRdLmNvbmYucHJvY2Vzc19rZXlwcmVzcykge1xcbiAgICAgICAgICAgICQobWxhYi5kdC5jbGlwYm9hcmQpLmtleWRvd24oZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgICAgICAgbWxhYi5kdC5jb21wb25lbnRzWyQodGhpcykuZGF0YShcXFwibWxhYi10eXBlXFxcIildLmNvZGUub25LZXlQcmVzcyhlKTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHRoaXMucGFyZW50LmZsYWdfZGlydHkgPSB0cnVlO1xcbiAgICB9LFxcblxcbiAgICBjb21wb25lbnRfZWRpdF9jcmVkZW50aWFsczogZnVuY3Rpb24gY29tcG9uZW50X2VkaXRfY3JlZGVudGlhbHMoKSB7XFxuICAgICAgICB2YXIgY3Vycl9jb21wID0gJChcXFwiLm1sYWJfY3VycmVudF9jb21wb25lbnRcXFwiKTtcXG4gICAgICAgIHZhciBjcmVkX2VsID0gJChcXFwiW2RhdGEtbWxhYi1jb21wLXRvb2w9J2NyZWRlbnRpYWxzJ11cXFwiKTtcXG4gICAgICAgIHZhciBjb21wX2lkID0gY3Vycl9jb21wLmRhdGEoXFxcIm1sYWItdHlwZVxcXCIpO1xcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0aGlzLnBhcmVudC5jb21wb25lbnRzW2NvbXBfaWRdLmNvbmYuY3JlZGVudGlhbHMpID09PSBcXFwiW29iamVjdCBBcnJheV1cXFwiKSB7XFxuICAgICAgICAgICAgdGhpcy5wYXJlbnQuYXBpLmdldENyZWRlbnRpYWxzKGNyZWRfZWwsIGNvbXBfaWQsIHRoaXMucGFyZW50LmNvbXBvbmVudHNbY29tcF9pZF0uY29uZi5jcmVkZW50aWFscywgdGhpcy5jb21wb25lbnRfc3RvcmVfY3JlZGVudGlhbHMsIHRydWUsIHsgY29tcG9uZW50OiBjdXJyX2NvbXAgfSk7XFxuICAgICAgICB9XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcclxcbiAgICAgKiBmZWF0dXJlcyBhcmUgc2ltcGx5IGNvbXBvbmVudHMgdGhhdCBhcmUgbm90IGRpc3BsYXllZCB3aXRoIGEgR1VJXFxyXFxuICAgICAqIHRoZXkgYXJlIGFkZGVkIHRvIGEgaGlkZGVuIGRpdiBvbiB0aGUgaW5kZXggcGFnZSwgaWYgd2UgYXJlIE5PVCB3b3JraW5nIG9uIHRoZSBpbmRleCBwYWdlIHdlIGNhbGwgYSBiYWNrZW5kIGZ1bmN0aW9uIHRvIGFkZCB0aGlzIGNvZGVcXHJcXG4gICAgICpcXHJcXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cXHJcXG4gICAgICovXFxuXFxuICAgIGZlYXR1cmVfYWRkOiBmdW5jdGlvbiBmZWF0dXJlX2FkZChjb21wX2lkLCBzaWxlbnQpIHtcXG4gICAgICAgIGlmICgkKHRoaXMucGFyZW50LmFwcC5jdXJyX2luZGV4cGFnZV9odG1sKS5maW5kKFxcXCIjbWxhYl9mZWF0dXJlc19jb250ZW50XFxcIikubGVuZ3RoID09IDApIHtcXG4gICAgICAgICAgICAkKHRoaXMucGFyZW50LmFwcC5jdXJyX2luZGV4cGFnZV9odG1sKS5maW5kKFxcXCJib2R5XFxcIikuYXBwZW5kKFxcXCI8ZGl2IGlkPSdtbGFiX2ZlYXR1cmVzX2NvbnRlbnQnIHN0eWxlPSdkaXNwbGF5OiBub25lOyc+PC9kaXY+XFxcIik7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIC8vbWFrZSBzdXJlIG5vdCBkdXBsaWNhdGUgaXRcXG4gICAgICAgICAgICBpZiAoJCh0aGlzLnBhcmVudC5hcHAuY3Vycl9pbmRleHBhZ2VfaHRtbCkuZmluZChcXFwiI21sYWJfZmVhdHVyZXNfY29udGVudCBbZGF0YS1tbGFiLXR5cGU9J1xcXCIgKyBjb21wX2lkICsgXFxcIiddXFxcIikubGVuZ3RoID4gMCkge1xcbiAgICAgICAgICAgICAgICBpZiAoIXNpbGVudCkge1xcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQudXRpbHMudXBkYXRlX3N0YXR1cyhcXFwidGVtcG9yYXJ5XFxcIiwgX3RyW1xcXCJtbGFiLmR0LmRlc2lnbi5qcy51cGRhdGVfc3RhdHVzLmZlYXR1cmUuYWxyZWFkeS5hZGRlZFxcXCJdLCBmYWxzZSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHZhciBjID0gdGhpcy5wYXJlbnQuY29tcG9uZW50c1tjb21wX2lkXS5jb25mO1xcbiAgICAgICAgdmFyIGRhdGFfcmVzaXplID0gdHlwZW9mIGMucmVzaXplYWJsZSAhPSBcXFwidW5kZWZpbmVkXFxcIiAmJiBjLnJlc2l6ZWFibGUgPT0gdHJ1ZSA/IFxcXCJkYXRhLW1sYWItYXNwZWN0cmF0aW89JzE6MScgZGF0YS1tbGFiLXNpemU9J21lZGl1bSdcXFwiIDogXFxcIlxcXCI7XFxuICAgICAgICB2YXIgZGF0YV9kaXNwbGF5X2RlcGVuZGVudCA9IHR5cGVvZiBjLmRpc3BsYXlfZGVwZW5kZW50ICE9IFxcXCJ1bmRlZmluZWRcXFwiICYmIGMuZGlzcGxheV9kZXBlbmRlbnQgPT0gdHJ1ZSB8fCB0eXBlb2YgYy5yZXNpemVhYmxlICE9IFxcXCJ1bmRlZmluZWRcXFwiICYmIGMucmVzaXplYWJsZSA9PSB0cnVlID8gXFxcImRhdGEtbWxhYi1kaXNwbGF5ZGVwZW5kZW50PSd0cnVlJ1xcXCIgOiBcXFwiXFxcIjtcXG5cXG4gICAgICAgICQodGhpcy5wYXJlbnQuYXBwLmN1cnJfaW5kZXhwYWdlX2h0bWwpLmZpbmQoXFxcIiNtbGFiX2ZlYXR1cmVzX2NvbnRlbnRcXFwiKS5hcHBlbmQoXFxcIjxkaXYgZGF0YS1tbGFiLXR5cGU9J1xcXCIgKyBjb21wX2lkICsgXFxcIicgXFxcIiArIGRhdGFfcmVzaXplICsgXFxcIiBcXFwiICsgZGF0YV9kaXNwbGF5X2RlcGVuZGVudCArIFxcXCIgPlxcXCIgKyB0aGlzLnBhcmVudC5jb21wb25lbnRzW2NvbXBfaWRdLmh0bWwgKyBcXFwiPC9kaXY+XFxcIik7XFxuXFxuICAgICAgICB2YXIgbmV3X2ZlYXR1cmUgPSAkKHRoaXMucGFyZW50LmFwcC5jdXJyX2luZGV4cGFnZV9odG1sKS5maW5kKFxcXCIjbWxhYl9mZWF0dXJlc19jb250ZW50IFtkYXRhLW1sYWItdHlwZT0nXFxcIiArIGNvbXBfaWQgKyBcXFwiJ11cXFwiKTtcXG4gICAgICAgIGlmIChuZXdfZmVhdHVyZS5sZW5ndGggPiAwKSB7XFxuICAgICAgICAgICAgdGhpcy5wYXJlbnQuY29tcG9uZW50c1tjb21wX2lkXS5jb2RlLm9uQ3JlYXRlKG5ld19mZWF0dXJlWzBdKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIC8vaWYgd2UgYXJlIG5vdCB3b3JraW5nIG9uIHRoZSBpbmRleCBwYWdlIHdlIG5lZWQgdG8gdGVsbCB0aGUgYmFjayBlbmQgdG8gdXBkYXRlIHRoZSBpbmRleC5odG1sIGZpbGVcXG4gICAgICAgIC8vb3RoZXJ3aXNlIHRoaXMgd2lsbCBiZSBsb3N0XFxuICAgICAgICBpZiAodGhpcy5wYXJlbnQuYXBwLmN1cnJfcGFnZV9udW0gIT0gMCkge1xcbiAgICAgICAgICAgIHZhciB1cmwgPSB0aGlzLnBhcmVudC51cmxzLmZlYXR1cmVfYWRkLnJlcGxhY2UoXFxcIl9BUFBJRF9cXFwiLCB0aGlzLnBhcmVudC5hcHAuaWQpO1xcbiAgICAgICAgICAgIHVybCA9IHVybC5yZXBsYWNlKFxcXCJfQ09NUElEX1xcXCIsIGNvbXBfaWQpO1xcbiAgICAgICAgICAgIGlmICghc2lsZW50KSB7XFxuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LnV0aWxzLnVwZGF0ZV9zdGF0dXMoXFxcImNhbGxiYWNrXFxcIiwgX3RyW1xcXCJtbGFiLmR0LmRlc2lnbi5qcy51cGRhdGVfc3RhdHVzLmFkZGluZy5mZWF0dXJlXFxcIl0sIHRydWUpO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XFxuICAgICAgICAgICAgJC5nZXQodXJsLCBmdW5jdGlvbiAoZGF0YSkge1xcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5yZXN1bHQgPT0gXFxcInN1Y2Nlc3NcXFwiKSB7XFxuICAgICAgICAgICAgICAgICAgICB0aGF0LnBhcmVudC51dGlscy51cGRhdGVfc3RhdHVzKFxcXCJ0ZW1wb3JhcnlcXFwiLCBfdHJbXFxcIm1sYWIuZHQuZGVzaWduLmpzLnVwZGF0ZV9zdGF0dXMuZmVhdHVyZS5hZGRlZFxcXCJdLCBmYWxzZSk7XFxuICAgICAgICAgICAgICAgICAgICAkKFxcXCIjbWxhYl9mZWF0dXJlc19saXN0IFtkYXRhLW1sYWItZmVhdHVyZS10eXBlPSdcXFwiICsgZGF0YS5jb21wb25lbnRfaWQgKyBcXFwiJ11cXFwiKS5hZGRDbGFzcyhcXFwibWxhYl9pdGVtX2FwcGxpZWRcXFwiKTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIHRoYXQucGFyZW50LnV0aWxzLnVwZGF0ZV9zdGF0dXMoXFxcInRlbXBvcmFyeVxcXCIsIGRhdGEubXNnLCBmYWxzZSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgfSxcXG5cXG4gICAgLyoqXFxyXFxuICAgICAqIEZ1bmN0aW9uIHRvIGFkZCBvciByZW1vdmUgc3RvcmFnZXBsdWdpbiBmb3IgYSBjb21wb25lbnQuIFxcclxcbiAgICAgKiBBZGQgcGx1Z2luOlxcclxcbiAgICAgKiBzdG9yYWdlX3BsdWdpbnMgYXJlIHNpbWlsYXIgdG8gZmVhdHVyZXMsIGV4Y2VwdCB0aGV5IGFyZSBsaW5rZWQgdG8gaW5kaXZpZHVhbCBjb21wb25lbnRzIGFuZCBub3QgYXBwIGFzIHdob2xlXFxyXFxuICAgICAqIFRoZXkgZG8gbm90aGluZyBhdCBkZXNpZ24gdGltZSBzbyBoZXJlIHdlIGp1c3QgY2FsbCB0aGUgYmFjayBlbmQgdG8gY29weSBhbmQgYWRkIHRoZSBjb2RlX3J0LmpzIGZpbGUgdG8gdGhlIGFwcFxcclxcbiAgICAgKiBJZiBjcmVkZW50aWFscyA9IHRydWUsIHdlIHJlcXVlc3QgY3JlZGVudGlhbHMgYW5kIHN0b3JlIHRoZW0gZm9yIHRoZSBjb21wb25lbnQgdGhhdCB0aGlzIHBsdWdpbiB3YXMgYWRkZWQgdG9cXHJcXG4gICAgICogXFxyXFxuICAgICAqIFJlbW92ZSBwbHVnaW46XFxyXFxuICAgICAqIEp1c3QgbmVlZCB0byBzZXQgdGhlIHN0b3JhZ2VfcGx1Z2luIHZhcmlhYmxlIHRoYXQgaXMgc3RvcmVkIHdpdGggdGhlIG9tcG9uZW50IHRvIFxcXCJcXFwiXFxyXFxuICAgICAqIFxcclxcbiAgICAgKiBAcGFyYW0ge3R5cGV9IGVsOiBsaXN0IGl0ZW0gc2hvd2luZyBuYW1lIG9mIHN0b3JhZ2UgcGx1Z2luID0gY3VycmVudGx5IGNsaWNrZWQgSFRNTCBlbGVtZW50XFxyXFxuICAgICAqIEBwYXJhbSB7dHlwZX0gc3RvcmFnZV9wbHVnaW5faWQ6IHVuaXF1ZSBJRCBvZiB0aGUgc3RvcmFnZSBwbHVnaW5cXHJcXG4gICAgICogQHBhcmFtIHt0eXBlfSBjb21wb25lbnQ6IHRoZSBjb21wb25lbnQgdGhhdCB3YW50cyB0byB1c2UgdGhpcyBzdG9yYWdlIHBsdWdpblxcclxcbiAgICAgKi9cXG4gICAgc3RvcmFnZV9wbHVnaW5fc2V0dXA6IGZ1bmN0aW9uIHN0b3JhZ2VfcGx1Z2luX3NldHVwKGVsLCBzdG9yYWdlX3BsdWdpbl9pZCwgY29tcG9uZW50KSB7XFxuICAgICAgICBpZiAoZWwucGFyZW50KCkuYXR0cihcXFwiZGF0YS1tbGFiLXNlbGVjdGVkLXN0b3JhZ2VcXFwiKSkge1xcbiAgICAgICAgICAgIG1sYWIuZHQuYXBpLnNldFZhcmlhYmxlKGNvbXBvbmVudCwgXFxcInN0b3JhZ2VfcGx1Z2luXFxcIiwgXFxcIlxcXCIpO1xcbiAgICAgICAgICAgIGVsLnBhcmVudCgpLnJlbW92ZUNsYXNzKFxcXCJtbGFiX2l0ZW1fYXBwbGllZFxcXCIpLnJlbW92ZUF0dHIoXFxcImRhdGEtbWxhYi1zZWxlY3RlZC1zdG9yYWdlXFxcIik7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHZhciB1cmwgPSB0aGlzLnBhcmVudC51cmxzLnN0b3JhZ2VfcGx1Z2luX2FkZC5yZXBsYWNlKFxcXCJfQVBQSURfXFxcIiwgdGhpcy5wYXJlbnQuYXBwLmlkKTtcXG4gICAgICAgICAgICB1cmwgPSB1cmwucmVwbGFjZShcXFwiX1NUT1JBR0VfUExVR0lOX0lEX1xcXCIsIHN0b3JhZ2VfcGx1Z2luX2lkKTtcXG4gICAgICAgICAgICB0aGlzLnBhcmVudC51dGlscy51cGRhdGVfc3RhdHVzKFxcXCJjYWxsYmFja1xcXCIsIF90cltcXFwibWxhYi5kdC5kZXNpZ24uanMudXBkYXRlX3N0YXR1cy5hZGRpbmcuc3RvcmFnZS5wbHVnaW5cXFwiXSwgdHJ1ZSk7XFxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xcbiAgICAgICAgICAgICQuZ2V0KHVybCwgZnVuY3Rpb24gKGRhdGEpIHtcXG4gICAgICAgICAgICAgICAgdmFyIGVsID0gJChcXFwiW2RhdGEtbWxhYi1nZXQtaW5mbz0nc3RvcmFnZV9wbHVnaW5zJ10gW2RhdGEtbWxhYi1zdG9yYWdlLXBsdWdpbi10eXBlPSdcXFwiICsgZGF0YS5zdG9yYWdlX3BsdWdpbl9pZCArIFxcXCInXVxcXCIpO1xcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5yZXN1bHQgPT0gXFxcInN1Y2Nlc3NcXFwiKSB7XFxuXFxuICAgICAgICAgICAgICAgICAgICAvL2ZpcnN0IHJlbW92ZSBkYXRhIGFuZCBjbGFzc2VzIGZyb20gY3VycmVudGx5IHNlbGVjdGVkIHBsdWdpbiwgaWYgYW55XFxuICAgICAgICAgICAgICAgICAgICBlbC5wYXJlbnQoKS5zaWJsaW5ncygpLnJlbW92ZUNsYXNzKFxcXCJtbGFiX2l0ZW1fYXBwbGllZFxcXCIpLnJlbW92ZUF0dHIoXFxcImRhdGEtbWxhYi1zZWxlY3RlZC1zdG9yYWdlXFxcIik7XFxuXFxuICAgICAgICAgICAgICAgICAgICB0aGF0LnBhcmVudC51dGlscy51cGRhdGVfc3RhdHVzKFxcXCJ0ZW1wb3JhcnlcXFwiLCBfdHJbXFxcIm1sYWIuZHQuZGVzaWduLmpzLnVwZGF0ZV9zdGF0dXMuc3RvcmFnZS5wbHVnaW4uYWRkZWRcXFwiXSwgZmFsc2UpO1xcbiAgICAgICAgICAgICAgICAgICAgZWwuYWRkQ2xhc3MoXFxcIm1sYWJfaXRlbV9hcHBsaWVkXFxcIikuYXR0cihcXFwiZGF0YS1tbGFiLXNlbGVjdGVkLXN0b3JhZ2VcXFwiLCBcXFwidHJ1ZVxcXCIpO1xcblxcbiAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0aGF0LnBhcmVudC5jb21wb25lbnRzW3N0b3JhZ2VfcGx1Z2luX2lkXS5jb25mLmNyZWRlbnRpYWxzKSA9PT0gXFxcIltvYmplY3QgQXJyYXldXFxcIikge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQucGFyZW50LmFwaS5nZXRDcmVkZW50aWFscyhlbCwgc3RvcmFnZV9wbHVnaW5faWQsIHRoYXQucGFyZW50LmNvbXBvbmVudHNbc3RvcmFnZV9wbHVnaW5faWRdLmNvbmYuY3JlZGVudGlhbHMsIHRoYXQuc3RvcmFnZV9wbHVnaW5fc3RvcmVfY3JlZGVudGlhbHMsIGZhbHNlLCB7IHN0b3JhZ2VfcGx1Z2luX2lkOiBzdG9yYWdlX3BsdWdpbl9pZCwgY29tcG9uZW50OiBjb21wb25lbnQgfSk7XFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIG1sYWIuZHQuYXBpLnNldFZhcmlhYmxlKGNvbXBvbmVudCwgXFxcInN0b3JhZ2VfcGx1Z2luXFxcIiwgeyBuYW1lOiBzdG9yYWdlX3BsdWdpbl9pZCB9KTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAkKG1sYWIuZHQucXRpcF90b29scykucXRpcCgpLmVsZW1lbnRzLmNvbnRlbnQuZmluZChcXFwiW2RhdGEtbWxhYi1zdG9yYWdlLXBsdWdpbi10eXBlPSdzdG9yYWdlX3BsdWdpbnMnXVxcXCIpLnNsaWRlVXAoKTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIHRoYXQucGFyZW50LnV0aWxzLnVwZGF0ZV9zdGF0dXMoXFxcInRlbXBvcmFyeVxcXCIsIGRhdGEubXNnLCBmYWxzZSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgfSxcXG5cXG4gICAgLyoqXFxyXFxuICAgICAqIENhbGxiYWNrIGZ1bmN0aW9uIHdoaWNoIHN0b3JlcyB0aGUgc3RvcmFnZV9wbHVnaW4gbmFtZSBhbmQgdGhlIGNyZWRlbnRpYWxzIGVudGVyZWRcXHJcXG4gICAgICogQHBhcmFtIHt0eXBlfSBjcmVkZW50aWFsczogXFxyXFxuICAgICAqIEBwYXJhbSB7dHlwZX0gcGFyYW1zXFxyXFxuICAgICAqIFxcclxcbiAgICAgKi9cXG4gICAgY29tcG9uZW50X3N0b3JlX2NyZWRlbnRpYWxzOiBmdW5jdGlvbiBjb21wb25lbnRfc3RvcmVfY3JlZGVudGlhbHMoY3JlZGVudGlhbHMsIHBhcmFtcykge1xcblxcbiAgICAgICAgbWxhYi5kdC5hcGkuc2V0VmFyaWFibGUocGFyYW1zLmNvbXBvbmVudCwgXFxcImNyZWRlbnRpYWxzXFxcIiwgY3JlZGVudGlhbHMpO1xcbiAgICB9LFxcblxcbiAgICAvKipcXHJcXG4gICAgICogQ2FsbGJhY2sgZnVuY3Rpb24gd2hpY2ggc3RvcmVzIHRoZSBzdG9yYWdlX3BsdWdpbiBuYW1lIGFuZCB0aGUgY3JlZGVudGlhbHMgZW50ZXJlZFxcclxcbiAgICAgKiBAcGFyYW0ge3R5cGV9IGNyZWRlbnRpYWxzOiBcXHJcXG4gICAgICogQHBhcmFtIHt0eXBlfSBwYXJhbXNcXHJcXG4gICAgICogXFxyXFxuICAgICAqL1xcbiAgICBzdG9yYWdlX3BsdWdpbl9zdG9yZV9jcmVkZW50aWFsczogZnVuY3Rpb24gc3RvcmFnZV9wbHVnaW5fc3RvcmVfY3JlZGVudGlhbHMoY3JlZGVudGlhbHMsIHBhcmFtcykge1xcbiAgICAgICAgbWxhYi5kdC5hcGkuc2V0VmFyaWFibGUocGFyYW1zLmNvbXBvbmVudCwgXFxcInN0b3JhZ2VfcGx1Z2luXFxcIiwgeyBuYW1lOiBwYXJhbXMuc3RvcmFnZV9wbHVnaW5faWQsIGNyZWRlbnRpYWxzOiBjcmVkZW50aWFscyB9KTtcXG4gICAgfSxcXG5cXG4gICAgLypcXHJcXG4gICAgICpcXHJcXG4gICAgICogQHBhcmFtIGRpdnMgKGh0bWwvRE9NKSBhbGwgZGl2cyB0byBlZGl0XFxyXFxuICAgICAqL1xcbiAgICBwcmVwYXJlX2VkaXRhYmxlX2FyZWE6IGZ1bmN0aW9uIHByZXBhcmVfZWRpdGFibGVfYXJlYSgpIHtcXG4gICAgICAgIC8vbmVlZCB0byBsb29wIHRocm91Z2ggYWxsIGRpdnMgaW4gdGhlIGVkaXRhYmxlIGJveCBhZnRlciB0aGV5IGhhdmUgYmVlbiBhZGRlZFxcbiAgICAgICAgLy9hbmQgc2V0IHRoZSBzdHlsZXMgZm9yIGRyYWdnaW5nL2Ryb3BwaW5nIHNvIGl0IHdvcmtzIE9LXFxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XFxuICAgICAgICAkKFxcXCIjXFxcIiArIHRoYXQucGFyZW50LmNvbmZpZ1tcXFwiYXBwXFxcIl1bXFxcImNvbnRlbnRfaWRcXFwiXSArIFxcXCI+IGRpdlxcXCIpLmVhY2goZnVuY3Rpb24gKGluZGV4KSB7XFxuICAgICAgICAgICAgJCh0aGlzKS5kcm9wcGFibGUodGhhdC5wYXJlbnQuZHJvcHBhYmxlX29wdGlvbnMpLnNvcnRhYmxlKHRoYXQucGFyZW50LnNvcnRhYmxlX29wdGlvbnMpLm9uKFxcXCJjbGlja1xcXCIsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgdmFyIHByZXBfbWVudSA9IG1sYWIuZHQuYXBpLmRpc3BsYXkuY29tcG9uZW50SGlnaGxpZ2h0U2VsZWN0ZWQoJCh0aGlzKSk7aWYgKHByZXBfbWVudSkge1xcbiAgICAgICAgICAgICAgICAgICAgbWxhYi5kdC5kZXNpZ24uY29tcG9uZW50X21lbnVfcHJlcGFyZSgpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSkub24oXFxcImlucHV0XFxcIiwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICBtbGFiLmR0LmZsYWdfZGlydHkgPSB0cnVlO1xcbiAgICAgICAgICAgIH0pO1xcblxcbiAgICAgICAgICAgIGNvbXBfaWQgPSAkKHRoaXMpLmRhdGEoXFxcIm1sYWItdHlwZVxcXCIpO1xcbiAgICAgICAgICAgIHRoYXQuY29tcG9uZW50X3J1bl9jb2RlKCQodGhpcyksIGNvbXBfaWQpO1xcblxcbiAgICAgICAgICAgIC8vcHJvY2VzcyBhbGwga2V5cyBpZiB0aGlzIGNvbXBvbmVudCB3YW50cyB0byBtYW5pcHVsYXRlIHRoZW0gKGkuZS4gdGhlIHByb2Nlc3Nfa2V5cHJlc3Mgc2V0dGluZyBleGlzdHMpXFxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGF0LnBhcmVudC5jb21wb25lbnRzW2NvbXBfaWRdLmNvbmYucHJvY2Vzc19rZXlwcmVzcyAhPSBcXFwidW5kZWZpbmVkXFxcIiAmJiB0aGF0LnBhcmVudC5jb21wb25lbnRzW2NvbXBfaWRdLmNvbmYucHJvY2Vzc19rZXlwcmVzcykge1xcbiAgICAgICAgICAgICAgICAkKHRoaXMpLmtleWRvd24oZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgICAgICAgICAgIG1sYWIuZHQuY29tcG9uZW50c1skKHRoaXMpLmRhdGEoXFxcIm1sYWItdHlwZVxcXCIpXS5jb2RlLm9uS2V5UHJlc3MoZSk7XFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcblxcbiAgICAgICAgLy9zZXQgZHJhZ2dhYmxlL3NvcnRhYmxlIG9wdGlvbnMgZm9yIHRoZSBlZGl0YWJsZSBhcmVhXFxuICAgICAgICAkKFxcXCIjXFxcIiArIHRoYXQucGFyZW50LmNvbmZpZ1tcXFwiYXBwXFxcIl1bXFxcImNvbnRlbnRfaWRcXFwiXSkuZHJvcHBhYmxlKHRoYXQucGFyZW50LmRyb3BwYWJsZV9vcHRpb25zKS5zb3J0YWJsZSh0aGF0LnBhcmVudC5zb3J0YWJsZV9vcHRpb25zKTtcXG4gICAgfSxcXG5cXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXFxyXFxuICAgICoqKioqKioqKioqIEZ1bmN0aW9uIHRvIG1hbmlwdWxhdGUgYWRhcHRpdmUgbWVudXMgKHRob3NlIGRlZmluZWQgYnkgY29tcG9uZW50IGl0c2VsZiAqKioqKioqKlxcclxcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuXFxuICAgIC8qIGFkZHMgY29tcG9uZW50IHNwZWNpZmljIG1lbnUgKGltYWdlcykgd2hlbiBhIGNvbXBvbmVudCBpcyBhZGRlZC9zZWxlY3RlZCAqL1xcbiAgICBjb21wb25lbnRfbWVudV9wcmVwYXJlOiBmdW5jdGlvbiBjb21wb25lbnRfbWVudV9wcmVwYXJlKCkge1xcbiAgICAgICAgdmFyIGN1cnJfY29tcCA9ICQoXFxcIi5tbGFiX2N1cnJlbnRfY29tcG9uZW50XFxcIik7XFxuICAgICAgICBpZiAoY3Vycl9jb21wLmxlbmd0aCA8IDEpIHtcXG4gICAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuICAgICAgICB2YXIgY29uZiA9IHRoaXMucGFyZW50LmNvbXBvbmVudHNbY3Vycl9jb21wLmRhdGEoXFxcIm1sYWItdHlwZVxcXCIpXS5jb25mO1xcbiAgICAgICAgdmFyIGNvbXBfbmFtZSA9IGN1cnJfY29tcC5kYXRhKFxcXCJtbGFiLXR5cGVcXFwiKTtcXG4gICAgICAgIHZhciBpdGVtcyA9IG5ldyBPYmplY3QoKTtcXG4gICAgICAgIHZhciB0aXRsZSA9IFxcXCJcXFwiO1xcbiAgICAgICAgdmFyIG1lbnUgPSAkKFxcXCIjbWxhYl90b29sYmFyX2Zvcl9jb21wb25lbnRzIC5tbGFiX2NvbXBvbmVudF9jb250ZXh0X21lbnVcXFwiKTtcXG4gICAgICAgIHZhciB0ZW1wX21lbnUgPSBbXTtcXG4gICAgICAgIHZhciBsb2MgPSBtbGFiLmR0LmFwaS5nZXRMb2NhbGUoKTtcXG5cXG4gICAgICAgICQoXFxcIiNtbGFiX3Rvb2xiYXJfZm9yX2NvbXBvbmVudHMgLm1sYWJfY29tcG9uZW50X3Rvb2xiYXJfaGVhZGluZ1xcXCIpLnRleHQodGhpcy5wYXJlbnQuYXBpLmdldExvY2FsZUNvbXBvbmVudE1lc3NhZ2UoY29tcF9uYW1lLCBbXFxcImV4dGVuZGVkX25hbWVcXFwiXSkpO1xcbiAgICAgICAgbWVudS5odG1sKFxcXCJcXFwiKTtcXG5cXG4gICAgICAgIGlmICh0eXBlb2YgY29uZi5jdXN0b20gIT0gXFxcInVuZGVmaW5lZFxcXCIpIHtcXG5cXG4gICAgICAgICAgICAvL3ByZWxpbWluYXJ5IGxvb3AgdG8gY3JlYXRlIGEgbG9va3VwdGFibGUgZm9yIHRoZSBwb3NpdGlvbiBvZiB0b29scyB0aGF0IGhhbmRsZXMgZHVwbGljYXRlIG9yZGVyIG51bWJlcnNcXG4gICAgICAgICAgICB2YXIgdGVtcF9jb21wX29yZGVyID0gW107XFxuICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggaW4gdGhpcy5wYXJlbnQuY29tcG9uZW50c1tjb21wX25hbWVdLmNvZGUpIHtcXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4LnN1YnN0cigwLCA3KSA9PSBcXFwiY3VzdG9tX1xcXCIpIHtcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlID0gaW5kZXguc2xpY2UoNyk7XFxuICAgICAgICAgICAgICAgICAgICB0ZW1wX2NvbXBfb3JkZXIucHVzaCh0eXBlb2YgY29uZi5jdXN0b21bdGl0bGVdW1xcXCJvcmRlclxcXCJdICE9IFxcXCJ1bmRlZmluZWRcXFwiID8gY29uZi5jdXN0b21bdGl0bGVdW1xcXCJvcmRlclxcXCJdIDogMCk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgdGVtcF9jb21wX29yZGVyLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGEgLSBiO1xcbiAgICAgICAgICAgIH0pO1xcblxcbiAgICAgICAgICAgIGZvciAodmFyIGluZGV4IGluIHRoaXMucGFyZW50LmNvbXBvbmVudHNbY29tcF9uYW1lXS5jb2RlKSB7XFxuICAgICAgICAgICAgICAgIGlmIChpbmRleC5zdWJzdHIoMCwgNykgPT0gXFxcImN1c3RvbV9cXFwiKSB7XFxuICAgICAgICAgICAgICAgICAgICB0aXRsZSA9IGluZGV4LnNsaWNlKDcpO1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25mLmN1c3RvbVt0aXRsZV0gIT0gXFxcInVuZGVmaW5lZFxcXCIpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaWNvbiA9IHR5cGVvZiBjb25mLmN1c3RvbVt0aXRsZV1bXFxcImljb25cXFwiXSAhPSBcXFwidW5kZWZpbmVkXFxcIiA/IFxcXCJzcmM9J1xcXCIgKyBjb25mLmN1c3RvbVt0aXRsZV1bXFxcImljb25cXFwiXSArIFxcXCInXFxcIiA6IFxcXCJjbGFzcz0nbWlzc2luZ19pY29uJ1xcXCI7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR0ID0gdGhpcy5wYXJlbnQuYXBpLmdldExvY2FsZUNvbXBvbmVudE1lc3NhZ2UoY29tcF9uYW1lLCBbXFxcImN1c3RvbVxcXCIsIHRpdGxlLCBcXFwidG9vbHRpcFxcXCJdKTtcXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2dldCB1bmlxdWUgcG9zaXRpb25cXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3JkZXIgPSB0ZW1wX2NvbXBfb3JkZXIuaW5kZXhPZihwYXJzZUludCh0eXBlb2YgY29uZi5jdXN0b21bdGl0bGVdW1xcXCJvcmRlclxcXCJdICE9IFxcXCJ1bmRlZmluZWRcXFwiID8gY29uZi5jdXN0b21bdGl0bGVdW1xcXCJvcmRlclxcXCJdIDogMCkpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0ZW1wX2NvbXBfb3JkZXJbb3JkZXJdO1xcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uZi5jdXN0b21bdGl0bGVdW1xcXCJuZXdsaW5lXFxcIl0gIT0gXFxcInVuZGVmaW5lZFxcXCIgJiYgY29uZi5jdXN0b21bdGl0bGVdW1xcXCJuZXdsaW5lXFxcIl0gPT09IHRydWUpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNsID0gXFxcIm1sYWJfbmV3bGluZVxcXCI7XFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNsID0gXFxcIlxcXCI7XFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBfbWVudVtvcmRlcl0gPSBcXFwiPGltZyBvbmNsaWNrPScoZnVuY3Rpb24oZSl7IG1sYWIuZHQuY29tcG9uZW50cy5cXFwiICsgY29tcF9uYW1lICsgXFxcIi5jb2RlLlxcXCIgKyBpbmRleCArIFxcXCIoJChcXFxcXFxcIi5tbGFiX2N1cnJlbnRfY29tcG9uZW50XFxcXFxcXCIpLCBlKTt9KShldmVudCknIFxcXCIgKyBcXFwidGl0bGU9J1xcXCIgKyB0dCArIFxcXCInIFxcXCIgKyBcXFwiY2xhc3M9J1xcXCIgKyBjbCArIFxcXCInIFxcXCIgKyBcXFwiZGF0YS1tbGFiLWNvbXAtdG9vbC1pZD0nXFxcIiArIGluZGV4ICsgXFxcIicgXFxcIiArIGljb24gKyBcXFwiID5cXFwiO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIG1lbnUuYXBwZW5kKHRlbXBfbWVudS5qb2luKFxcXCJcXFwiKSk7XFxuICAgICAgICAgICAgbWVudS5hcHBlbmQoXFxcIjxkaXYgY2xhc3M9J2NsZWFyJz4mbmJzcDs8L2Rpdj5cXFwiKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIC8vZGlzcGxheSBjcmVkZW50aWFscyBzZWxlY3Rpb24gYnV0dG9uLCBpZiB0aGlzIHN1cHBvcnRzIGNyZWRlbnRpYWxzXFxuICAgICAgICBpZiAodHlwZW9mIGNvbmYuY3JlZGVudGlhbHMgIT0gXFxcInVuZGVmaW5lZFxcXCIgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGNvbmYuY3JlZGVudGlhbHMpID09PSBcXFwiW29iamVjdCBBcnJheV1cXFwiKSB7XFxuICAgICAgICAgICAgJChcXFwiW2RhdGEtbWxhYi1jb21wLXRvb2w9J2NyZWRlbnRpYWxzJ11cXFwiKS5yZW1vdmVDbGFzcyhcXFwibWxhYl9oaWRkZW5cXFwiKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgJChcXFwiW2RhdGEtbWxhYi1jb21wLXRvb2w9J2NyZWRlbnRpYWxzJ11cXFwiKS5hZGRDbGFzcyhcXFwibWxhYl9oaWRkZW5cXFwiKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIC8vZGlzcGxheSBzdG9yYWdlIHNlbGVjdGlvbiBsaXN0IGJ1dHRvbiwgaWYgdGhpcyBzdXBwb3J0cyBzdG9yYWdlXFxuICAgICAgICBpZiAodHlwZW9mIGNvbmYuc3RvcmFnZV9wbHVnaW4gIT0gXFxcInVuZGVmaW5lZFxcXCIgJiYgY29uZi5zdG9yYWdlX3BsdWdpbiA9PSB0cnVlKSB7XFxuICAgICAgICAgICAgJChcXFwiW2RhdGEtbWxhYi1jb21wLXRvb2w9J3N0b3JhZ2VfcGx1Z2luJ11cXFwiKS5yZW1vdmVDbGFzcyhcXFwibWxhYl9oaWRkZW5cXFwiKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgJChcXFwiW2RhdGEtbWxhYi1jb21wLXRvb2w9J3N0b3JhZ2VfcGx1Z2luJ11cXFwiKS5hZGRDbGFzcyhcXFwibWxhYl9oaWRkZW5cXFwiKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIC8vZGlzcGxheSBzaXplIGFuZCBhc3BlY3QgcmF0aW8gc2VsZWN0aW9uIGxpc3QgYnV0dG9ucywgaWYgdGhpcyBzdXBwb3J0cyByZXNpemluZ1xcbiAgICAgICAgaWYgKHR5cGVvZiBjb25mLnJlc2l6ZWFibGUgIT0gXFxcInVuZGVmaW5lZFxcXCIgJiYgY29uZi5yZXNpemVhYmxlID09IHRydWUpIHtcXG4gICAgICAgICAgICAkKFxcXCJbZGF0YS1tbGFiLWNvbXAtdG9vbD0nY29tcF9zaXplJ11cXFwiKS5yZW1vdmVDbGFzcyhcXFwibWxhYl9oaWRkZW5cXFwiKTtcXG4gICAgICAgICAgICAkKFxcXCJbZGF0YS1tbGFiLWNvbXAtdG9vbD0nY29tcF9hc3BlY3QnXVxcXCIpLnJlbW92ZUNsYXNzKFxcXCJtbGFiX2hpZGRlblxcXCIpO1xcbiAgICAgICAgICAgICQoXFxcIiNtbGFiX2NvbXBvbmVudF9zaXplX2xpc3QgbGlcXFwiKS5yZW1vdmVDbGFzcyhcXFwibWxhYl9pdGVtX2FwcGxpZWRcXFwiKTtcXG4gICAgICAgICAgICAkKFxcXCIjbWxhYl9jb21wb25lbnRfYXNwZWN0X2xpc3QgbGlcXFwiKS5yZW1vdmVDbGFzcyhcXFwibWxhYl9pdGVtX2FwcGxpZWRcXFwiKTtcXG4gICAgICAgICAgICAvL3VwZGF0ZSB0aGUgbWVudXMgd2l0aCB0aGUgZXhpc3Rpbmcgc2VsZWN0aW9uLCBpZiBhbnlcXG4gICAgICAgICAgICAkKFxcXCIjbWxhYl9jb21wb25lbnRfc2l6ZV9saXN0IFtkYXRhLWRhdGEtbWxhYi1jb21wLXNpemU9J1xcXCIgKyBjdXJyX2NvbXAuZGF0YShcXFwibWxhYi1jb21wLXNpemVcXFwiKSArIFxcXCInXVxcXCIpLmFkZENsYXNzKFxcXCJtbGFiX2l0ZW1fYXBwbGllZFxcXCIpO1xcbiAgICAgICAgICAgICQoXFxcIiNtbGFiX2NvbXBvbmVudF9hc3BlY3RfbGlzdCBbZGF0YS1kYXRhLW1sYWItY29tcC1hc3BlY3Q9J1xcXCIgKyBjdXJyX2NvbXAuZGF0YShcXFwibWxhYi1jb21wLWFzcGVjdFxcXCIpICsgXFxcIiddXFxcIikuYWRkQ2xhc3MoXFxcIm1sYWJfaXRlbV9hcHBsaWVkXFxcIik7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICQoXFxcIltkYXRhLW1sYWItY29tcC10b29sPSdjb21wX3NpemUnXVxcXCIpLmFkZENsYXNzKFxcXCJtbGFiX2hpZGRlblxcXCIpO1xcbiAgICAgICAgICAgICQoXFxcIltkYXRhLW1sYWItY29tcC10b29sPSdjb21wX2FzcGVjdCddXFxcIikuYWRkQ2xhc3MoXFxcIm1sYWJfaGlkZGVuXFxcIik7XFxuICAgICAgICB9XFxuXFxuICAgICAgICAvL3NldCB0aGUgcVRpcHMgcG9zaXN0aW9uIGFmdGVyIHdoZXJlIGl0IGlzIHBsYWNlZCBpbiB0aGUgd2luZG93IFxcbiAgICAgICAgdmFyIG15UG9zUXRpcCA9ICdsZWZ0VG9wJztcXG4gICAgICAgIHZhciBlVG9wID0gY3Vycl9jb21wLm9mZnNldCgpLnRvcDsgLy9nZXQgdGhlIG9mZnNldCB0b3Agb2YgdGhlIGVsZW1lbnRcXG4gICAgICAgIGVUb3AgPSBlVG9wIC0gJCh3aW5kb3cpLnNjcm9sbFRvcCgpO1xcblxcbiAgICAgICAgaWYgKGVUb3AgPiA0NTApIHtcXG4gICAgICAgICAgICBteVBvc1F0aXAgPSAnbGVmdEJvdHRvbSc7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0aGlzLnBhcmVudC5xdGlwX3Rvb2xzID0gJChjdXJyX2NvbXApLnF0aXAoe1xcbiAgICAgICAgICAgIHNvbG86IGZhbHNlLFxcbiAgICAgICAgICAgIGNvbnRlbnQ6IHsgdGV4dDogZnVuY3Rpb24gdGV4dCgpIHtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkKCcjbWxhYl90b29sYmFyX2Zvcl9jb21wb25lbnRzJykuY2xvbmUodHJ1ZSk7XFxuICAgICAgICAgICAgICAgIH0gfSxcXG4gICAgICAgICAgICBwb3NpdGlvbjogeyBteTogbXlQb3NRdGlwLCBhdDogJ3JpZ2h0VG9wJywgdmlld3BvcnQ6ICQod2luZG93KSB9LFxcbiAgICAgICAgICAgIHNob3c6IHsgcmVhZHk6IHRydWUsIG1vZGFsOiB7IG9uOiBmYWxzZSwgYmx1cjogZmFsc2UgfSB9LFxcbiAgICAgICAgICAgIGhpZGU6IGZhbHNlLFxcbiAgICAgICAgICAgIGV2ZW50czoge1xcbiAgICAgICAgICAgICAgICBoaWRlOiBmdW5jdGlvbiBoaWRlKGV2ZW50LCBhcGkpIHtcXG4gICAgICAgICAgICAgICAgICAgICQobWxhYi5kdC5hcGkucHJvcGVydGllc190b29sdGlwKS5xdGlwKCdoaWRlJyk7YXBpLmRlc3Ryb3koKTtcXG4gICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAgdmlzaWJsZTogZnVuY3Rpb24gdmlzaWJsZShldmVudCwgYXBpKSB7XFxuICAgICAgICAgICAgICAgICAgICAkKG1sYWIuZHQucXRpcF90b29scykucXRpcCgpLmVsZW1lbnRzLmNvbnRlbnQuZmluZChcXFwiKlxcXCIpLnJlbW92ZUF0dHIoXFxcImlkXFxcIik7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIHN0eWxlOiB7IGNsYXNzZXM6ICdxdGlwLWxpZ2h0IG1sYWJfemluZGV4X3JlZ3VsYXJfdG9vbHRpcCcsIHRpcDogdHJ1ZSB9XFxuXFxuICAgICAgICAgICAgLyogICAgICAgICAgICBzaG93OiAgICAgICB7IHJlYWR5OiB0cnVlLCBtb2RhbDogeyBvbjogZmFsc2UsIGJsdXI6IGZhbHNlIH0gfSxcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICBoaWRlOiAgICAgICBmYWxzZSwgKi9cXG4gICAgICAgIH0pO1xcblxcbiAgICAgICAgJChjdXJyX2NvbXApLnF0aXAoXFxcInNob3dcXFwiKTtcXG4gICAgfSxcXG5cXG4gICAgLypcXHJcXG4gICAgICogVHVybiB0aGUgaGVscCBpbiB0aGUgZm9vdGVyIGFuZCB0aGUgZm9vdGVyIG9uIGFuZCBvZmZcXHJcXG4gICAgICovXFxuICAgIHRvZ2dsZV9mb290ZXI6IGZ1bmN0aW9uIHRvZ2dsZV9mb290ZXIoKSB7XFxuXFxuICAgICAgICB2YXIgZm9vdGVyID0gJChcXFwiLm1sYWJfZWRpdG9yX2Zvb3RlclxcXCIpO1xcbiAgICAgICAgdmFyIGZvb3Rlcl90ZXh0ID0gJChcXFwiLm1sYWJfZWRpdG9yX2Zvb3Rlcl9oZWxwXFxcIik7XFxuICAgICAgICBpZiAoZm9vdGVyLmhhc0NsYXNzKFxcXCJtbGFiX3RyYW5zcGFyZW50XFxcIikpIHtcXG4gICAgICAgICAgICBmb290ZXIucmVtb3ZlQ2xhc3MoXFxcIm1sYWJfdHJhbnNwYXJlbnRcXFwiKTtcXG4gICAgICAgICAgICBmb290ZXJfdGV4dC5yZW1vdmVDbGFzcyhcXFwibWxhYl9oaWRkZW5cXFwiKTtcXG4gICAgICAgICAgICAvL1RPRE8gdG9nZ2xlIHRpdGxlIGFzIHdlbGxcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgZm9vdGVyLmFkZENsYXNzKFxcXCJtbGFiX3RyYW5zcGFyZW50XFxcIik7XFxuICAgICAgICAgICAgZm9vdGVyX3RleHQuYWRkQ2xhc3MoXFxcIm1sYWJfaGlkZGVuXFxcIik7XFxuICAgICAgICB9XFxuICAgIH0gLy8gZW5kIGRlc2lnbi5wcm90b3R5cGVcXG5cXG59O1wiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmF3LWxvYWRlciEuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliPz9yZWYtLTAtMCEuL2Fzc2V0cy9qcy9tbGFiLmR0LmRlc2lnbi5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvcmF3LWxvYWRlci9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTAtMCEuL2Fzc2V0cy9qcy9tbGFiLmR0LmRlc2lnbi5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcXHJcXG5AY29weXJpZ2h0IENvcHlyaWdodCAoYykgMjAxMy0yMDE2LCBOb3J3ZWdpYW4gRGVmZW5jZSBSZXNlYXJjaCBFc3RhYmxpc2htZW50IChGRkkpIC0gQWxsIFJpZ2h0cyBSZXNlcnZlZFxcclxcbkBsaWNlbnNlIFByb3ByaWV0YXJ5IGFuZCBjb25maWRlbnRpYWxcXHJcXG5AYXV0aG9yIEFyaWxkIEJlcmdoL1NpbmV0dCAzLjAgcHJvZ3JhbW1lIChmaXJzdG5hbWUubGFzdG5hbWVAZmZpLm5vKSByZXdyaXRlL2ltcGxlbWVudGF0aW9uIG9mIGFsbCBmdW5jdGlvbmFsaXR5XFxyXFxuQGF1dGhvciBDZWNpbGllIEphY2tibyBHcmFuL1NpbmV0dCAzLjAgcHJvZ3JhbW1lIChmaXJzdG5hbWUubWlkZGxlbmFtZS5sYXN0bmFtZUBmZmkubm8pIGFkZGl0aW9uYWwgZnVuY3Rpb25hbGl0eVxcclxcblxcclxcblVuYXV0aG9yaXplZCBjb3B5aW5nIG9mIHRoaXMgZmlsZSwgdmlhIGFueSBtZWRpdW0gaXMgc3RyaWN0bHkgcHJvaGliaXRlZCBcXHJcXG5cXHJcXG5Gb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgTElDRU5TRV9NTEFCIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxcclxcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuXFxuLyoqXFxyXFxuICogQGFic3RyYWN0IEFwcCBsZXZlbCBmdW5jdGlvbnMgXFxyXFxuICovXFxuXFxuZnVuY3Rpb24gTWxhYl9kdF9tYW5hZ2VtZW50KCkge1xcbiAgICB0aGlzLnBhcmVudCA9IG51bGw7XFxufVxcblxcbk1sYWJfZHRfbWFuYWdlbWVudC5wcm90b3R5cGUgPSB7XFxuXFxuICAgIC8qXFxyXFxuICAgICAqIFRoaXMgZnVuY3Rpb24gd2lsbCBmaXJzdCBvcGVuIHRoZSBpbmRleC5odG1sIGZpbGUgaW4gYW4gYXBwLCB0aGlzIGhhcyBhbGwgdGhlIGNzcy9qcy9mb3JtYXR0aW5nIGV0YyBpbiBpdC5cXHJcXG4gICAgICogVGhlbiBpdCB3aWxsIG9wZW4gdGhlIHBhZ2Ugc3BlY2lmaWVkIChpZiBpdCBpcyBub3QgPT0gaW5kZXggfCAwIClcXHJcXG4gICAgICogQHBhcmFtIHt0eXBlfSBhcHBfaWRcXHJcXG4gICAgICogQHBhcmFtIHt0eXBlfSBwYWdlX251bVxcclxcbiAgICAgKi9cXG4gICAgYXBwX29wZW46IGZ1bmN0aW9uIGFwcF9vcGVuKGFwcF9pZCwgcGFnZV9udW0pIHtcXG5cXG4gICAgICAgIHZhciBsb2NhbF9wYWdlX251bSA9IHBhZ2VfbnVtO1xcbiAgICAgICAgdmFyIHVybCA9IHRoaXMucGFyZW50LnVybHMuYXBwX29wZW4ucmVwbGFjZShcXFwiX0lEX1xcXCIsIGFwcF9pZCk7XFxuICAgICAgICB1cmwgPSB1cmwucmVwbGFjZShcXFwiX1BBR0VfTlVNX1xcXCIsICdpbmRleCcpO1xcbiAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoXFxcIl9VSURfXFxcIiwgdGhpcy5wYXJlbnQudWlkKTtcXG4gICAgICAgIHVybCA9IHVybC5yZXBsYWNlKFxcXCJfT1BFTl9NT0RFX1xcXCIsIFxcXCJ0cnVlXFxcIik7XFxuICAgICAgICB0aGlzLnBhcmVudC51dGlscy51cGRhdGVfc3RhdHVzKFxcXCJjYWxsYmFja1xcXCIsIF90cltcXFwibWxhYi5kdC5tYW5hZ2VtZW50LmpzLnVwZGF0ZV9zdGF0dXMub3BlbmluZy5hcHBcXFwiXSwgdHJ1ZSk7XFxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XFxuICAgICAgICB2YXIgbG9jYWxfYXBwX2lkID0gYXBwX2lkO1xcblxcbiAgICAgICAgJC5nZXQodXJsLCBmdW5jdGlvbiAoZGF0YSkge1xcbiAgICAgICAgICAgIGlmIChkYXRhLnJlc3VsdCA9PSBcXFwic3VjY2Vzc1xcXCIpIHtcXG4gICAgICAgICAgICAgICAgdGhhdC5pbmRleF9wYWdlX3Byb2Nlc3MoZGF0YS5odG1sLCBsb2NhbF9wYWdlX251bSA9PSBcXFwiMFxcXCIgfHwgbG9jYWxfcGFnZV9udW0gPT0gXFxcImluZGV4XFxcIiB8fCB0aGF0LnBhcmVudC5hcHAucGFnZV9uYW1lcy5sZW5ndGggPT0gMSk7XFxuXFxuICAgICAgICAgICAgICAgIC8vc2V0IHRoZSBjb21waWxlciBxVGlwIHRvIHNob3cgUVIgY29kZSBhbmQgbGluayB3aGVuIGhvd2VyIG92ZXIgY29tcGlsZSBpY29uXFxuICAgICAgICAgICAgICAgIC8vVE9ETzogQnVyZGUgZW5kcmUgaWtvbmV0IHRpbCBncsO4bnQgZWxsZXIgbm9lLi4uLlxcbiAgICAgICAgICAgICAgICAvL1RPRE86IHVzZSBhcGkuZWxlbWVudHMudG9vbHRpcFxcbiAgICAgICAgICAgICAgICAvL2FueSBleGlzdGluZyBjb21waWxlZCBmaWxlcyBmb3IgdGhpcyBhcHBcXG4gICAgICAgICAgICAgICAgbWxhYi5kdC5hcHAuY29tcGlsZWRfZmlsZXMgPSBkYXRhLmNvbXBpbGVkX2ZpbGVzO1xcblxcbiAgICAgICAgICAgICAgICAkLmVhY2gobWxhYi5kdC5jb25maWcuY29tcGlsZXJfc2VydmljZS5zdXBwb3J0ZWRfcGxhdGZvcm1zLCBmdW5jdGlvbiAoaW5kZXgsIHBsYXRmb3JtKSB7XFxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1sYWIuZHQuYXBwLmNvbXBpbGVkX2ZpbGVzW3BsYXRmb3JtXSAhPSBcXFwidW5kZWZpbmVkXFxcIikge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETzogc2tpbGxlIHV0IGRlIDMgbmVzdGUgbGluamVuZSBzb20gZWdlbiBmdW5rc2pvbiAtIGRldHRlIHNrYWwgYnJ1a2VzIGZsZXJlIHN0ZWRlci4uLi5cXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFxcXCJiYXNlXFxcIilbMF0uaHJlZi5zbGljZSgwLCAtMSkgKyBcXFwiX2NvbXBpbGVkL1xcXCIgKyBtbGFiLmR0LmFwcC5jb21waWxlZF9maWxlc1twbGF0Zm9ybV07XFxuICAgICAgICAgICAgICAgICAgICAgICAgJCgnI21sYWJfZG93bmxvYWRfcXJfbGlua18nICsgcGxhdGZvcm0pLmVtcHR5KCkucXJjb2RlKHsgdGV4dDogdGV4dCwgc2l6ZTogMTUwLCBiYWNrZ3JvdW5kOiBcXFwiI2ZmZmZmZlxcXCIsIGZvcmVncm91bmQ6IFxcXCIjMDAwMDAwXFxcIiwgcmVuZGVyOiBcXFwidGFibGVcXFwiIH0pO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICQoJyNtbGFiX2Rvd25sb2FkX2xpbmtfJyArIHBsYXRmb3JtKS5odG1sKFxcXCI8Yj5VUkw8L2I+OjwvYnI+XFxcIiArIHRleHQpO1xcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qICAgICAgICAgICAgICAgICAgICAgICAgJCgnI21sYWJfZG93bmxvYWRfJysgcGxhdGZvcm0gKyAnX2ljb24nKS5xdGlwKHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlkZTp7IGRlbGF5OjUwMCwgZml4ZWQ6dHJ1ZSB9LC8vZ2l2ZSBhIHNtYWxsIGRlbGF5IHRvIGFsbG93IHRoZSB1c2VyIHQgbW91c2Ugb3ZlciBpdC5cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDoge3RleHQ6IGZ1bmN0aW9uKCl7IHJldHVybiAkKFxcXCJbZGF0YS1tbGFiLWRvd25sb2FkLWxpbmstaW5mbz0nXFxcIiArIHBsYXRmb3JtICsgXFxcIiddXFxcIikuaHRtbCgpfSxcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHsgdGV4dDogXFxcIkRvd25sb2FkIHRvIFxcXCIgKyBwbGF0Zm9ybSB9IH0sXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7IGNsYXNzZXM6IFxcXCJtbGFiX3F0aXBfdG9vbHRpcCBtbGFiX3F0aXBfbWVudV90b29sdGlwXFxcIiwgdGlwOiB0cnVlIH1cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTsqL1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9KTtcXG5cXG4gICAgICAgICAgICAgICAgJChcXFwiI21sYWJfc3RhdHVzYmFyX3Blcm1hbmVudFxcXCIpLmh0bWwobWxhYi5kdC5hcHAubmFtZSk7XFxuICAgICAgICAgICAgICAgIC8vdXBkYXRlIHRoZSBsaXN0IG9mIGZlYXR1cmVzIHdlIGhhdmUgYWRkZWQgdG8gdGhpcyBhcHBcXG4gICAgICAgICAgICAgICAgJChcXFwiI21sYWJfZmVhdHVyZXNfbGlzdCBsaVxcXCIpLnJlbW92ZUNsYXNzKFxcXCJtbGFiX2l0ZW1fYXBwbGllZFxcXCIpO1xcbiAgICAgICAgICAgICAgICAkKHRoYXQucGFyZW50LmFwcC5jdXJyX2luZGV4cGFnZV9odG1sKS5maW5kKFxcXCIjbWxhYl9mZWF0dXJlc19jb250ZW50IFtkYXRhLW1sYWItdHlwZV0+XFxcIikuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgICAgICAkKFxcXCIjbWxhYl9mZWF0dXJlc19saXN0IFtkYXRhLW1sYWItZmVhdHVyZS10eXBlPSdcXFwiICsgJCh0aGlzKS5wYXJlbnQoKS5kYXRhKFxcXCJtbGFiLXR5cGVcXFwiKSArIFxcXCInXVxcXCIpLmFkZENsYXNzKFxcXCJtbGFiX2l0ZW1fYXBwbGllZFxcXCIpO1xcbiAgICAgICAgICAgICAgICB9KTtcXG5cXG4gICAgICAgICAgICAgICAgLy9pZiB0aGV5IGFyZSBvcGVuaW5nIHRoZSBhcHAgd2l0aCBhIGJsYW5rIHBhZ2UgYW5kIG5vIGNvbXBvbmVudHMgb24gdGhlIGluZGV4IHBhZ2UsIGxldCdzIGFzc3VtZSB0aGV5IGFyZSBvcGVuaW5nIGEgbmV3IGFwcCwgYW5kIHdlJ2xsIGFzayBmb3IgdGhlIHRpdGxlIG9mIHRoZSBwYWdlXFxuICAgICAgICAgICAgICAgIGlmIChkYXRhLm9ubHlfaW5kZXggJiYgJChcXFwiI1xcXCIgKyB0aGF0LnBhcmVudC5jb25maWdbXFxcImFwcFxcXCJdW1xcXCJjb250ZW50X2lkXFxcIl0pLmNoaWxkcmVuKCkubGVuZ3RoID09IDApIHtcXG4gICAgICAgICAgICAgICAgICAgIHZhciB0aXRsZSA9IHByb21wdChfdHJbXFxcIm1sYWIuZHQubWFuYWdlbWVudC5qcy5wcm9tcHQudGl0bGUuZnJvbnQucGFnZVxcXCJdLCB0aGF0LnBhcmVudC5hcHAuY3Vycl9wYWdldGl0bGUpO1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpdGxlICE9IG51bGwpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnBhcmVudC5hcHAuY3Vycl9wYWdldGl0bGUgPSB0aXRsZTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAkKFxcXCIjbWxhYl9wYWdlX2NvbnRyb2xfdGl0bGVcXFwiKS50ZXh0KHRoYXQucGFyZW50LmFwcC5jdXJyX3BhZ2V0aXRsZSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5wYXJlbnQuZmxhZ19kaXJ0eSA9IHRydWU7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgLy9pZiB0aGV5IGFyZSBub3Qgb3BlbmluZyB0aGUgaW5kZXggcGFnZSB3ZSBuZWVkIHRvIGNhbGwgYmFja2VuZCBhZ2FpbiB0byBsb2FkIHRoZSBwYWdlIHRoZXkgd2FudCB0byBvcGVuXFxuICAgICAgICAgICAgICAgIGlmIChsb2NhbF9wYWdlX251bSAhPSBcXFwiMFxcXCIgJiYgbG9jYWxfcGFnZV9udW0gIT0gXFxcImluZGV4XFxcIiAmJiAhZGF0YS5vbmx5X2luZGV4KSB7XFxuICAgICAgICAgICAgICAgICAgICB0aGF0LnBhZ2Vfb3Blbl9wcm9jZXNzKGRhdGEuYXBwX2lkLCBsb2NhbF9wYWdlX251bSk7XFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5sb2NrX3N0YXR1cyA9PSBcXFwibG9ja2VkXFxcIikge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQucGFyZW50LmFwcC5sb2NrZWQgPSB0cnVlO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICQoXFxcIiNcXFwiICsgdGhhdC5wYXJlbnQuY29uZmlnW1xcXCJhcHBcXFwiXVtcXFwiY29udGVudF9pZFxcXCJdKS5mYWRlVG8oJ3Nsb3cnLCAuNik7XFxuICAgICAgICAgICAgICAgICAgICAgICAgJChcXFwiZGl2LmNvbnRhaW5lclxcXCIpLmFwcGVuZCgnPGRpdiBpZD1cXFwibWxhYl9lZGl0b3JfZGlzYWJsZWRcXFwiIHN0eWxlPVxcXCJiYWNrZ3JvdW5kLWNvbG9yOiBncmF5OyBwb3NpdGlvbjogYWJzb2x1dGU7dG9wOjExMHB4O2xlZnQ6MDt3aWR0aDogMTAwJTtoZWlnaHQ6MTAwJTt6LWluZGV4OjI7b3BhY2l0eTowLjQ7ZmlsdGVyOiBhbHBoYShvcGFjaXR5ID0gNTApOyBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoL2ltZy9wYWdlX2xvY2tlZC5wbmcpOyBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0OyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiA5NSUgMiU7XFxcIj48L2Rpdj4nKTtcXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5wYXJlbnQuYXBwLmxvY2tlZCA9IGZhbHNlO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICQoXFxcIiNtbGFiX2VkaXRvcl9kaXNhYmxlZFxcXCIpLnJlbW92ZSgpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICQoXFxcIiNcXFwiICsgdGhhdC5wYXJlbnQuY29uZmlnW1xcXCJhcHBcXFwiXVtcXFwiY29udGVudF9pZFxcXCJdKS5mYWRlVG8oJ3Nsb3cnLCAxKTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgICAgIHRoYXQucGFyZW50LnV0aWxzLnVwZGF0ZV9zdGF0dXMoXFxcInRlbXBvcmFyeVxcXCIsIF90cltcXFwibWxhYi5kdC5tYW5hZ2VtZW50LmpzLnVwZGF0ZV9zdGF0dXMucmVhZHlcXFwiXSwgZmFsc2UpO1xcbiAgICAgICAgICAgICAgICAgICAgJChcXFwiI21sYWJfb3ZlcmxheVxcXCIpLnNsaWRlVXAoKTtcXG4gICAgICAgICAgICAgICAgICAgIHRoYXQucGFyZW50LmFwcC5sb2NrZWQgPSBkYXRhLmxvY2tfc3RhdHVzID09IFxcXCJsb2NrZWRcXFwiO1xcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5wYXJlbnQudXRpbHMudGltZXJfc3RhcnQoKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHRoYXQucGFyZW50LnV0aWxzLnVwZGF0ZV9zdGF0dXMoXFxcInRlbXBvcmFyeVxcXCIsIGRhdGEubXNnLCBmYWxzZSk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIC8vc2V0IHRoZSB0cmFwIGZvciB0aGUgcGFzdGUgZnVuY3Rpb24gc28gd2UgZm9yY2UgcGxhaW4gdGV4dFxcbiAgICAgICAgICAgICQoXFxcIiNcXFwiICsgbWxhYi5kdC5jb25maWdbXFxcImFwcFxcXCJdW1xcXCJjb250ZW50X2lkXFxcIl0pLm9uKFxcXCJwYXN0ZVxcXCIsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICAgICAgICAgIC8vIHN0b3Agb3JpZ2luYWwgcGFzdGUgZnJvbSBoYXBwZW5pbmdcXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcblxcbiAgICAgICAgICAgICAgICAvL2lmIHRoZXkgYXJlIG5vdCBhbGxvd2VkIHRvIHBhc3RlIGludG8gdGhpcyBjb21wb25lbnQgd2UgcXVpdFxcbiAgICAgICAgICAgICAgICB2YXIgY29tcF9pZCA9ICQoXFxcIi5tbGFiX2N1cnJlbnRfY29tcG9uZW50XFxcIikuZGF0YShcXFwibWxhYi10eXBlXFxcIik7XFxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWxhYi5kdC5jb21wb25lbnRzW2NvbXBfaWRdLmNvbmYucGFzdGVfYWxsb3dlZCA9PSBcXFwidW5kZWZpbmVkXFxcIiB8fCBtbGFiLmR0LmNvbXBvbmVudHNbY29tcF9pZF0uY29uZi5wYXN0ZV9hbGxvd2VkID09PSBmYWxzZSkge1xcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIC8vb2J0YWluIHBsYWluIHRleHRcXG4gICAgICAgICAgICAgICAgdmFyIHRleHQgPSBlLm9yaWdpbmFsRXZlbnQuY2xpcGJvYXJkRGF0YS5nZXREYXRhKFxcXCJ0ZXh0L3BsYWluXFxcIik7XFxuXFxuICAgICAgICAgICAgICAgIC8vaW5zZXJ0IHZpYSBidWlsdCBpbiBleGVjIGNvbW1hbmRzXFxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmV4ZWNDb21tYW5kKFxcXCJpbnNlcnRIVE1MXFxcIiwgZmFsc2UsIHRleHQpO1xcbiAgICAgICAgICAgICAgICAvL2FkZCBhIHRleHQgaW4gdGhlIGZvb3RlciB0byBleHBsYWluIHRoYXQgdGhlIGZvcm1hdGluZyBpcyBsb3N0IHdoZW4geW91IHBhc3RlIHRleHRcXG4gICAgICAgICAgICAgICAgJChcXFwiLm1sYWJfZWRpdG9yX2Zvb3Rlcl9oZWxwXFxcIikudGV4dChfdHJbXFxcImJ1aWxkX2FwcC5mb290ZXIuaGVscC5wYXN0ZS50ZXh0XFxcIl0pO1xcbiAgICAgICAgICAgICAgICAvL2hpZGUgdGhlIHRleHQgYWZ0ZXIgNSBzZWNvbmRzXFxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICAgICAgJChcXFwiLm1sYWJfZWRpdG9yX2Zvb3Rlcl9oZWxwXFxcIikudGV4dChcXFwiXFxcIik7XFxuICAgICAgICAgICAgICAgIH0sIDUwMDApO1xcblxcbiAgICAgICAgICAgICAgICBtbGFiLmR0LmZsYWdfZGlydHkgPSB0cnVlO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgfSk7XFxuICAgIH0sXFxuXFxuICAgIC8qXFxyXFxuICAgICAqIENhbGxzIGEgZnVuY3Rpb24gb24gdGhlIGJhY2tlbmQgdGhhdCByZXR1cm5zIGEgVVJMIHRvIHRoZSBmaWxlIHRvIGRvd25sb2FkLlxcclxcbiAgICAgKiBJZiBpdCBpcyBub3QgY29tcGlsZWQgd2Ugd2lsbCBjb21waWxlIGl0IGZpcnN0LlxcclxcbiAgICAgKiBAcmV0dXJucyB2b2lkXFxyXFxuICAgICAqL1xcbiAgICBhcHBfZG93bmxvYWQ6IGZ1bmN0aW9uIGFwcF9kb3dubG9hZCgpIHtcXG4gICAgICAgIHRoYXQgPSB0aGlzO1xcbiAgICAgICAgdGhpcy5wYWdlX3NhdmUoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIHRoYXQuYXBwX2Rvd25sb2FkX3Byb2Nlc3MoKTtcXG4gICAgICAgIH0pO1xcbiAgICB9LFxcblxcbiAgICBhcHBfZG93bmxvYWRfcHJvY2VzczogZnVuY3Rpb24gYXBwX2Rvd25sb2FkX3Byb2Nlc3MoKSB7XFxuICAgICAgICB0aGlzLnBhcmVudC51dGlscy51cGRhdGVfc3RhdHVzKFxcXCJjYWxsYmFja1xcXCIsIF90cltcXFwibWxhYi5kdC5tYW5hZ2VtZW50LmpzLnVwZGF0ZV9zdGF0dXMucmV0cmlldmluZy5hcHBcXFwiXSwgdHJ1ZSk7XFxuICAgICAgICB2YXIgdXJsID0gdGhpcy5wYXJlbnQudXJscy5hcHBfZG93bmxvYWQucmVwbGFjZShcXFwiX0lEX1xcXCIsIHRoaXMucGFyZW50LmFwcC5pZCk7XFxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XFxuICAgICAgICAkLmdldCh1cmwsIGZ1bmN0aW9uIChkYXRhKSB7XFxuICAgICAgICAgICAgdGhhdC5wYXJlbnQudXRpbHMudXBkYXRlX3N0YXR1cyhcXFwiY29tcGxldGVkXFxcIik7XFxuICAgICAgICAgICAgaWYgKGRhdGEucmVzdWx0ID09IFxcXCJzdWNjZXNzXFxcIikge1xcbiAgICAgICAgICAgICAgICBmdWxsX3VybCA9IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4gKyBkYXRhLnVybDtcXG4gICAgICAgICAgICAgICAgJChcXFwiI21sYWJfZG93bmxvYWRfcXIyXFxcIikuZW1wdHkoKS5xcmNvZGUoeyB0ZXh0OiBmdWxsX3VybCwgcmVuZGVyOiBcXFwidGFibGVcXFwiIH0pLnNob3coKS5hcHBlbmQoXFxcIjxicj5cXFwiKS5hcHBlbmQoXFxcIjxhIGhyZWY9J1xcXCIgKyBmdWxsX3VybCArIFxcXCInPlxcXCIgKyBfdHJbXFxcIm1sYWIuZHQubWFuYWdlbWVudC5qcy5hcHBfZG93bmxvYWRfcHJvY2Vzcy4xXFxcIl0gKyBcXFwiOiBcXFwiICsgZnVsbF91cmwgKyBcXFwiPC9hPlxcXCIpLmFwcGVuZChcXFwiPGJyPlxcXCIpLmFwcGVuZChcXFwiPGEgaHJlZj0nbWFpbHRvOlxcXCIgKyB0aGF0LnBhcmVudC51c2VyX2VtYWlsICsgXFxcIj9zdWJqZWN0PUxpbmsmYm9keT1cXFwiICsgX3RyW1xcXCJtbGFiLmR0Lm1hbmFnZW1lbnQuanMuYXBwX2Rvd25sb2FkX3Byb2Nlc3MuMlxcXCJdICsgXFxcIjogXFxcIiArIGVuY29kZVVSSShmdWxsX3VybCkgKyBcXFwiJz5cXFwiICsgX3RyW1xcXCJtbGFiLmR0Lm1hbmFnZW1lbnQuanMuYXBwX2Rvd25sb2FkX3Byb2Nlc3MuM1xcXCJdICsgXFxcIjwvYT5cXFwiKTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAkKFxcXCIjbWxhYl9kb3dubG9hZF9xcjJcXFwiKS5lbXB0eSgpLmFwcGVuZChcXFwiPHA+XFxcIiArIF90cltcXFwibWxhYi5kdC5tYW5hZ2VtZW50LmpzLmFwcF9kb3dubG9hZF9wcm9jZXNzLjRcXFwiXSArIFxcXCI6IFxcXCIgKyBkYXRhLm1zZyArIFxcXCI8L3A+XFxcIikuc2hvdygpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAvKiAgICAgICAkKFxcXCIjbWxhYl9kb3dubG9hZF9xcl9maWVsZFxcXCIpLnF0aXAoe1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDoge3RleHQ6ICQoXFxcIiNtbGFiX2Rvd25sb2FkX3FyMlxcXCIpLmh0bWwoKSB9LFxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHsgbXk6ICd0b3AgcmlnaHQnLCBhdDogJ2JvdHRvbSByaWdodCcsIHRhcmdldDogJChcXFwiI21sYWJfZG93bmxvYWRfcXJfZmllbGRcXFwiKSB9LFxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgc2hvdzogeyByZWFkeTogdHJ1ZSwgbW9kYWw6IHsgb246IGZhbHNlLCBibHVyOiBmYWxzZSB9IH0sXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICBoaWRlOiAndW5mb2N1cycsXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogeyBjbGFzc2VzOiAncXRpcC10aXBwZWQnLCB0aXA6IHRydWUgfX0pO1xcclxcbiAgICAgICAgICAgICAgICovXFxuICAgICAgICB9KTtcXG5cXG4gICAgICAgIHRoYXQucGFyZW50LnV0aWxzLnRpbWVyX3N0YXJ0KCk7XFxuICAgIH0sXFxuXFxuICAgIGFwcF9zdWJtaXRfdG9fbWFya2V0OiBmdW5jdGlvbiBhcHBfc3VibWl0X3RvX21hcmtldCgpIHtcXG4gICAgICAgIGFsZXJ0KF90cltcXFwibWxhYi5kdC5tYW5hZ2VtZW50LmpzLmFwcF9zdWJtaXRfdG9fbWFya2V0XFxcIl0pO1xcbiAgICB9LFxcblxcbiAgICAvL3JlbW92ZSBsb2NrcywganVzdCBhIGJhY2t1cCBpZiBzb21ldGhpbmcgZ29lcyB3cm9uZ1xcbiAgICBhcHBfcmVtb3ZlX2xvY2tzOiBmdW5jdGlvbiBhcHBfcmVtb3ZlX2xvY2tzKCkge1xcbiAgICAgICAgdGhpcy5wYXJlbnQudXRpbHMudXBkYXRlX3N0YXR1cyhcXFwidGVtcG9yYXJ5XFxcIiwgX3RyW1xcXCJtbGFiLmR0Lm1hbmFnZW1lbnQuanMudXBkYXRlX3N0YXR1cy51bmxvY2tpbmcucGFnZXNcXFwiXSwgdHJ1ZSk7XFxuICAgICAgICAkLmdldCh0aGlzLnBhcmVudC51cmxzLmFwcF91bmxvY2spO1xcbiAgICAgICAgJChcXFwiI1xcXCIgKyB0aGlzLnBhcmVudC5jb25maWdbXFxcImFwcFxcXCJdW1xcXCJjb250ZW50X2lkXFxcIl0pLmZhZGVUbygnc2xvdycsIDEpO1xcbiAgICAgICAgJChcXFwiI21sYWJfZWRpdG9yX2Rpc2FibGVkXFxcIikucmVtb3ZlKCk7XFxuICAgICAgICB0aGlzLnBhcmVudC5hcHAubG9ja2VkID0gZmFsc2U7XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcclxcbiAgICAgKiBGdW5jdGlvbiB0byB1cGRhdGUgY29udGVudCBvZiBHVUkgZWxlbWVudHMgd2l0aCB0aGUgY3VycmVudCBhcHAncyBtZXRhZGF0YVxcclxcbiAgICAgKi9cXG4gICAgYXBwX3VwZGF0ZV9ndWlfbWV0YWRhdGE6IGZ1bmN0aW9uIGFwcF91cGRhdGVfZ3VpX21ldGFkYXRhKG9ubHlfbGlzdCkge1xcblxcbiAgICAgICAgLy9MaXN0IG9mIGFsbCBwYWdlc1xcbiAgICAgICAgLy8jbWxhYl9leGlzdGluZ19wYWdlcyBpcyBhIDxkaXY+IHdoaWNoIGlzIHBvcHVsYXRlZCB3aXRoIGEgPG9sPiB3aXRoIGEgPGxpPiBlbGVtZW50IGZvciBlYWNoIHBhZ2VcXG4gICAgICAgIHZhciBsaXN0ID0gJCgnPG9sPjwvb2w+JyksXFxuICAgICAgICAgICAgc3BhbiA9IFxcXCJcXFwiO1xcbiAgICAgICAgY3Vycl9maWxlbmFtZSA9IHRoaXMucGFnZV9maWxlbnVtMmZpbGVuYW1lKHRoaXMucGFyZW50LmFwcC5jdXJyX3BhZ2VfbnVtKTtcXG5cXG4gICAgICAgIC8vbG9vcCB0aHJvdWdoIGxpc3Qgb2YgcGFnZXMgaW4gdGhpcyBhcHAgYW5kIGRpc3BsYXkgdGhlbVxcbiAgICAgICAgZm9yIChpIGluIHRoaXMucGFyZW50LmFwcC5wYWdlX25hbWVzKSB7XFxuICAgICAgICAgICAgaWYgKGkgPT0gMCkge1xcbiAgICAgICAgICAgICAgICAvL2Fsd2F5cyBpbmRleC5odG1sIGZpbGUgXFxuICAgICAgICAgICAgICAgIHBhZ2VfbnVtID0gMDtcXG4gICAgICAgICAgICAgICAgc3BhbiA9IFxcXCI8c3BhbiBjbGFzcz0nbWxhYl9ub3RfY29weV9maWxlJz4mbmJzcDs8L3NwYW4+XFxcIjtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICBwYWdlX251bSA9IHBhcnNlSW50KHRoaXMucGFyZW50LmFwcC5wYWdlX25hbWVzW2ldW1xcXCJmaWxlbmFtZVxcXCJdKTtcXG4gICAgICAgICAgICAgICAgc3BhbiA9IFxcXCI8c3BhbiBjbGFzcz0nbWxhYl9jb3B5X2ZpbGUnIHRpdGxlPSdcXFwiICsgX3RyW1xcXCJtbGFiLmR0Lm1hbmFnZW1lbnQuanMuYXBwX3VwZGF0ZV9ndWlfbWV0YWRhdGEuY29weS5wYWdlc1xcXCJdICsgXFxcIiBcXFxcXFxcIlxcXCIgKyB0aGlzLnBhcmVudC5hcHAucGFnZV9uYW1lc1tpXVtcXFwidGl0bGVcXFwiXSArIFxcXCJcXFxcXFxcIicgb25jbGljaz0nbWxhYi5kdC5tYW5hZ2VtZW50LnBhZ2VfY29weShcXFxcXFxcIlxcXCIgKyBwYWdlX251bSArIFxcXCJcXFxcXFxcIik7JyA+Jm5ic3A7PC9zcGFuPlxcXCI7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudC5hcHAucGFnZV9uYW1lc1tpXVtcXFwiZmlsZW5hbWVcXFwiXSA9PSBjdXJyX2ZpbGVuYW1lKSB7XFxuICAgICAgICAgICAgICAgIGxpc3QuYXBwZW5kKFxcXCI8bGkgZGF0YS1tbGFiLXBhZ2UtbnVtPSdcXFwiICsgcGFnZV9udW0gKyBcXFwiJyBkYXRhLW1sYWItcGFnZS1vcGVuPSdcXFwiICsgcGFnZV9udW0gKyBcXFwiJz5cXFwiICsgc3BhbiArIHRoaXMucGFyZW50LmFwcC5wYWdlX25hbWVzW2ldW1xcXCJ0aXRsZVxcXCJdICsgXFxcIjwvbGk+XFxcIik7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgbGlzdC5hcHBlbmQoXFxcIjxsaSBkYXRhLW1sYWItcGFnZS1udW09J1xcXCIgKyBwYWdlX251bSArIFxcXCInPlxcXCIgKyBzcGFuICsgXFxcIjxhIGRhdGEtbWxhYi1wYWdlLW9wZW49J1xcXCIgKyBwYWdlX251bSArIFxcXCInIGhyZWY9J2phdmFzY3JpcHQ6bWxhYi5kdC5tYW5hZ2VtZW50LnBhZ2Vfb3BlbihcXFwiICsgdGhpcy5wYXJlbnQuYXBwLmlkICsgXFxcIiwgXFxcXFxcXCJcXFwiICsgcGFnZV9udW0gKyBcXFwiXFxcXFxcXCIpOyc+XFxcIiArIHRoaXMucGFyZW50LmFwcC5wYWdlX25hbWVzW2ldW1xcXCJ0aXRsZVxcXCJdICsgXFxcIjwvYT48L2xpPlxcXCIpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgICQoXFxcIiNtbGFiX2V4aXN0aW5nX3BhZ2VzXFxcIikuaHRtbChsaXN0KTtcXG5cXG4gICAgICAgIC8vbWFrZSBwYWdlIGxpc3Qgc29ydGFibGUgdG8gcmVzZXQgcGFnZXNcXG4gICAgICAgICQoXFxcIiNtbGFiX2V4aXN0aW5nX3BhZ2VzIG9sXFxcIikuc29ydGFibGUoe1xcbiAgICAgICAgICAgIGl0ZW1zOiBcXFwiPiBsaTpndCgwKVxcXCIsXFxuICAgICAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUoZXZlbnQsIHVpKSB7XFxuICAgICAgICAgICAgICAgIG1sYWIuZHQubWFuYWdlbWVudC5wYWdlX3Jlb3JkZXIoZXZlbnQsIHVpKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9KS5kaXNhYmxlU2VsZWN0aW9uKCk7XFxuXFxuICAgICAgICBpZiAob25seV9saXN0KSB7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgLy9WYXJpb3VzIGFwcCBtZXRhIGRhdGFcXG4gICAgICAgICQoXFxcIiNtbGFiX2VkaXRfYXBwX3RpdGxlXFxcIikudGV4dCh0aGlzLnBhcmVudC5hcHAubmFtZSk7XFxuICAgICAgICAkKFxcXCIjbWxhYl9lZGl0X2FwcF9kZXNjcmlwdGlvblxcXCIpLnRleHQodGhpcy5wYXJlbnQuYXBwLmRlc2NyaXB0aW9uKTtcXG4gICAgICAgICQoXFxcIiNtbGFiX2VkaXRfYXBwX2tleXdvcmRzXFxcIikudGV4dCh0aGlzLnBhcmVudC5hcHAua2V5d29yZHMpO1xcbiAgICAgICAgJChcXFwiI21sYWJfZWRpdF9hcHBfdGFnc1xcXCIpLnRleHQodGhpcy5wYXJlbnQuYXBwLnRhZ3MpO1xcbiAgICB9LFxcblxcbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXFxyXFxuICAgICAqKioqKioqKioqKiBGdW5jdGlvbnMgdG8gcGFyc2UgSFRNTCBmb3IgYSBwYWdlIGFuZCBpbnNlcnQgaXQgaW50byB0aGUgZWRpdG9yIGFyZWEgKioqKioqKioqKipcXHJcXG4gICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG5cXG4gICAgLyogdGhpcyBmdW5jdGlvbiBwcm9jZXNzZXMgdGhlIGluZGV4IHBhZ2UgdGhhdCB3YXMgcmV0cmlldmVkLlxcclxcbiAgICAgKlxcclxcbiAgICAgKiBJdCBkb2VzIHRoZSBmb2xsb3dpbmc6XFxyXFxuICAgICAgICBSZW1vdmUgb2xkIEhUTUwgZnJvbSB0aGUgZWRpdGluZyBkaXYgKG1sYWJfZWRpdG9yX2Nocm9tZSlcXHJcXG4gICAgICAgIFJlbW92ZSBvbGQgc3R5bGVzaGVldHMgZnJvbSBwcmV2aW91c2x5IGVkaXRlZCBwYWdlIGZyb20gKnRoaXMgcGFnZSpcXHJcXG4gICAgICAgIEFkZCBuZXcgc3R5bGVzaGVldHMgZnJvbSBwYWdlIHRoYXQgaXMgb3BlbmVkIGZvciBlZGl0aW5nIHRvICp0aGlzIHBhZ2UqXFxyXFxuICAgICAgICBFeHRyYWN0IEJPRFkgYW5kIGluc2VydCBjb250ZW50IGludG8gbWxhYl9lZGl0b3JfY2hyb21lXFxyXFxuICAgICAgICBQcm9jZXNzIHRoZSB0b3AgbGV2ZWwgRElWcyBpbnNpZGUgRElWIHdpdGggSUQgPSB0aGlzLnBhcmVudC5jb25maWdbXFxcImFwcFxcXCJdW1xcXCJjb250ZW50X2lkXFxcIl0gKGJ5IGRlZmF1bHQgbWxhYl9lZGl0YWJsZV9hcmVhKSBzbyB0aGV5IGFyZSBtb3ZlYWJsZS9zb3J0YWJsZVxcclxcbiAgICAqL1xcblxcbiAgICBpbmRleF9wYWdlX3Byb2Nlc3M6IGZ1bmN0aW9uIGluZGV4X3BhZ2VfcHJvY2VzcyhwYWdlLCBpc19maW5hbF9kZXN0aW5hdGlvbikge1xcbiAgICAgICAgdmFyIGNvbXBfaWQsIHRlbXBfY29tcCwgdGVtcF9saW5rO1xcbiAgICAgICAgdmFyIHRlbXBfc3R5bGVzaGVldHMgPSBcXFwiXFxcIjtcXG4gICAgICAgIHZhciBzdGFydF9kaXIgPSB0aGlzLnBhcmVudC5jb25maWcudXJscy5hcHAgKyB0aGlzLnBhcmVudC5hcHAucGF0aCArIFxcXCIvXFxcIiArIHRoaXMucGFyZW50LmFwcC5hY3RpdmVfdmVyc2lvbiArIFxcXCIvXFxcIjtcXG5cXG4gICAgICAgIC8vcGFyc2UgZG9jIGludG8gYSB2YXJpYWJsZVxcbiAgICAgICAgdmFyIGRvYyA9IG5ldyBET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcocGFnZSwgXFxcInRleHQvaHRtbFxcXCIpO1xcblxcbiAgICAgICAgLy9jaGVjayBpZiBpdCBoYXMgZWRpdGFibGUgYXJlYSwgaWYgbm90IHdlIGNhbm5vdCBjb250aW51ZVxcbiAgICAgICAgaWYgKGRvYy5nZXRFbGVtZW50QnlJZCh0aGlzLnBhcmVudC5jb25maWdbXFxcImFwcFxcXCJdW1xcXCJjb250ZW50X2lkXFxcIl0pID09IG51bGwpIHtcXG4gICAgICAgICAgICBhbGVydChfdHJbXFxcIm1sYWIuZHQubWFuYWdlbWVudC5qcy5pbmRleF9wYWdlX3Byb2Nlc3MuYWxlcnQuMVxcXCJdICsgXFxcIiBcXFwiICsgdGhpcy5wYXJlbnQuY29uZmlnW1xcXCJhcHBcXFwiXVtcXFwiY29udGVudF9pZFxcXCJdICsgXFxcIiwgXFxcIiArIF90cltcXFwibWxhYi5kdC5tYW5hZ2VtZW50LmpzLmluZGV4X3BhZ2VfcHJvY2Vzcy5hbGVydC4yXFxcIl0pO1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIC8vc2V0IHRoZSBiYXNlIGhyZWYgdG8gdGhlIGZvbGRlciBvZiB0aGUgYXBwXFxuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcXFwiYmFzZVxcXCIpWzBdLmhyZWYgPSBzdGFydF9kaXI7XFxuXFxuICAgICAgICAvL3JlbW92ZSBvbGQgc3R1ZmZcXG4gICAgICAgICQoXFxcIiNtbGFiX2VkaXRvcl9jaHJvbWVcXFwiKS5lbXB0eSgpO1xcbiAgICAgICAgJChcXFwibGlua1tyZWw9c3R5bGVzaGVldF1baHJlZl49J2NzcyddXFxcIikucmVtb3ZlKCk7XFxuXFxuICAgICAgICAvL3N0b3JlIGRpZmZlcmVudCBwYXJ0cyBvZiBkb2MgZm9yIGVhc3kgYWNjZXNzL21hbmlwdWxhdGlvblxcbiAgICAgICAgdmFyIGhlYWQgPSBkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXFxcImhlYWRcXFwiKVswXTtcXG4gICAgICAgIHZhciBkaXZzID0gZG9jLmdldEVsZW1lbnRCeUlkKHRoaXMucGFyZW50LmNvbmZpZ1tcXFwiYXBwXFxcIl1bXFxcImNvbnRlbnRfaWRcXFwiXSkuY2xvbmVOb2RlKHRydWUpLmNoaWxkTm9kZXM7XFxuXFxuICAgICAgICAvL2Fzc2lnbiB2YXJzIHRvIGN1cnJlbnQgYXBwIHZhciwgd2UgcmVtb3ZlIGFsbCBlbGVtZW50cyB0aGF0IGFyZSBlZGl0YWJsZSBzbyB3ZSBoYXZlIGNsZWFuIEhUTUwgdG8gYWRkIG91ciBlZGl0ZWQgY29udGVudCB0b1xcbiAgICAgICAgLy90aGlzIEhUTUwgY2h1bmsgd2lsbCBpbmNsdWRlIEhUTUwgaGVhZGVyICsgYWxsIGJvZHkgY29udGVudCBvdXRzaWRlIHRoZSBlZGl0YWJsZSBhcmVhLCBwbHVzIHRoZSBlbXB0eSBkaXYgZm9yIHRoZSBlZGl0YWJsZSBhcmVhXFxuICAgICAgICB2YXIgY29udGVudCA9IGRvYy5nZXRFbGVtZW50QnlJZCh0aGlzLnBhcmVudC5jb25maWdbXFxcImFwcFxcXCJdW1xcXCJjb250ZW50X2lkXFxcIl0pO1xcbiAgICAgICAgd2hpbGUgKGNvbnRlbnQuZmlyc3RDaGlsZCkge1xcbiAgICAgICAgICAgIGNvbnRlbnQucmVtb3ZlQ2hpbGQoY29udGVudC5maXJzdENoaWxkKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHZhciBib2R5ID0gZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKFxcXCJib2R5XFxcIilbMF0uY2xvbmVOb2RlKHRydWUpO1xcblxcbiAgICAgICAgdmFyIHN0eWxlc2hlZXRzID0gaGVhZC5nZXRFbGVtZW50c0J5VGFnTmFtZShcXFwibGlua1xcXCIpO1xcblxcbiAgICAgICAgLy9pbnNlcnQgc3R5bGVzaGVldHMsIGJ1dCBub3Qgd2hlbiBwcmV2aWV3IGl0LCBoZW5jZSB3ZSBsb29rIGZvciB0aGUgcHJlc2VuY2Ugb2YgdGhlIFJUIHN0eWxlc2hlZXRcXG4gICAgICAgIC8vVE9ETyB1c2UgdmFyaWFibGUgaW5zdGVhZFxcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXNoZWV0cy5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgICAgIHRlbXBfbGluayA9IHN0eWxlc2hlZXRzW2ldLmdldEF0dHJpYnV0ZShcXFwiaHJlZlxcXCIpO1xcbiAgICAgICAgICAgIGlmICh0ZW1wX2xpbmsuaW5kZXhPZihcXFwic3R5bGVfcnQuY3NzXFxcIikgPCAwKSB7XFxuICAgICAgICAgICAgICAgIHRlbXBfc3R5bGVzaGVldHMgPSB0ZW1wX3N0eWxlc2hlZXRzICsgXFxcIjxsaW5rIHJlbD0nc3R5bGVzaGVldCcgaHJlZj0nXFxcIiArIHRlbXBfbGluayArIFxcXCInIHR5cGU9J3RleHQvY3NzJz5cXFwiICsgXFxcIlxcXFxuXFxcIjtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICAkKFxcXCJoZWFkIGxpbmtbcmVsPSdzdHlsZXNoZWV0J11cXFwiKS5sYXN0KCkuYWZ0ZXIodGVtcF9zdHlsZXNoZWV0cyk7XFxuXFxuICAgICAgICAvL2hlcmUgd2UgaW5zZXJ0IHRoZSBib2R5IE1JTlVTIHRoZSBlZGl0YWJsZSBhcmVhICh3aGljaCB3YXMganVzdCByZW1vdmVkKSB3aGljaCBpcyBzdG9yZWQgaW4gdGhlIGRpdnMgdmFyaWFibGUsIGludG8gdGhlIGVkaXRvcl9jaHJvbWVcXG4gICAgICAgICQoXFxcIiNtbGFiX2VkaXRvcl9jaHJvbWVcXFwiKS5hcHBlbmQoYm9keS5pbm5lckhUTUwpO1xcblxcbiAgICAgICAgLy9ub3cgd2UgbmVlZCB0byBtYWtlIHRoZSBpbnRlcm5hbCBjb2RlIGVkaXRhYmxlLCBidXQgb25seSBpZiB0aGV5IGFjdHVhbGx5IHdhbnQgdG8gZWRpdCB0aGlzIHBhZ2VcXG4gICAgICAgIGlmIChpc19maW5hbF9kZXN0aW5hdGlvbikge1xcbiAgICAgICAgICAgICQoXFxcIiNcXFwiICsgdGhpcy5wYXJlbnQuY29uZmlnW1xcXCJhcHBcXFwiXVtcXFwiY29udGVudF9pZFxcXCJdKS5odG1sKGRpdnMpO1xcbiAgICAgICAgICAgIHRoaXMucGFyZW50LmFwaS5nZXRBbGxMaWJyYXJpZXMoKTtcXG4gICAgICAgICAgICB0aGlzLnBhcmVudC5kZXNpZ24ucHJlcGFyZV9lZGl0YWJsZV9hcmVhKCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0aGlzLnBhcmVudC5hcHAuY3Vycl9pbmRleHBhZ2VfaHRtbCA9IGRvYztcXG5cXG4gICAgICAgIC8vUGFnZSBuYW1lIGlzIHBpY2tlZCB1cCBmcm9tIHRpdGxlIHRhZyBpbiBoZWFkXFxuICAgICAgICB0aGlzLnBhcmVudC5hcHAuY3Vycl9wYWdldGl0bGUgPSBoZWFkLmdldEVsZW1lbnRzQnlUYWdOYW1lKFxcXCJ0aXRsZVxcXCIpWzBdLmlubmVyVGV4dDtcXG4gICAgICAgIHRoaXMucGFyZW50LmFwcC5jdXJyX3BhZ2VfbnVtID0gMDtcXG4gICAgICAgICQoXFxcIiNtbGFiX3BhZ2VfY29udHJvbF90aXRsZVxcXCIpLnRleHQodGhpcy5wYXJlbnQuYXBwLmN1cnJfcGFnZXRpdGxlKTtcXG5cXG4gICAgICAgIHRoaXMuYXBwX3VwZGF0ZV9ndWlfbWV0YWRhdGEoKTtcXG5cXG4gICAgICAgIC8vZmluYWxseSB3ZSBuZWVkIHRvIGluaXRpYWxpc2UgdGhlIGpRdWVyeSBtb2JpbGUgc3R1ZmYgb24gdGhlIHBhZ2Ugd2UgbG9hZGVkLCBvdGhlcndpc2UgaXQgd2lsbCBub3QgZGlzcGxheSBjb3JyZWN0bHlcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgJC5tb2JpbGUuaW5pdGlhbGl6ZVBhZ2UoKTtcXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGVyci5tZXNzYWdlKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIG1sYWIuZHQuYXBpLmRpc3BsYXkudXBkYXRlRGlzcGxheSgpO1xcblxcbiAgICAgICAgLy9KUyB0byBmaXggdGhlIHRvb2xiYXJzIGluIGEgalF1ZXJ5IG1vYmlsZSBwYWdlXFxuICAgICAgICB2YXIgYm9yZGVyX3dpZHRoID0gcGFyc2VJbnQoJChcXFwiI21sYWJfZWRpdG9yX2Nocm9tZVxcXCIpLmNzcyhcXFwibWFyZ2luLWJvdHRvbVxcXCIpKSAqIDIgKyBwYXJzZUludCgkKFxcXCIjbWxhYl9lZGl0b3JfY2hyb21lXFxcIikuY3NzKFxcXCJib3JkZXItYm90dG9tLXdpZHRoXFxcIikpO1xcbiAgICAgICAgJChcXFwiW2RhdGEtcm9sZT1oZWFkZXJdXFxcIikuY3NzKHsgXFxcInBvc2l0aW9uXFxcIjogXFxcImFic29sdXRlXFxcIiwgXFxcInotaW5kZXhcXFwiOiAwIH0pO1xcbiAgICAgICAgJChcXFwiW2RhdGEtcm9sZT1mb290ZXJdXFxcIikuY3NzKHsgXFxcInBvc2l0aW9uXFxcIjogXFxcImFic29sdXRlXFxcIiwgXFxcImJvdHRvbVxcXCI6ICQoXFxcIltkYXRhLXJvbGU9Zm9vdGVyXVxcXCIpLmhlaWdodCgpICsgYm9yZGVyX3dpZHRoICsgXFxcInB4XFxcIiB9KTtcXG4gICAgICAgICQoXFxcIltkYXRhLXJvbGU9cGFnZV1cXFwiKS5jc3MoeyBcXFwid2lkdGhcXFwiOiBcXFwiMTAwJVxcXCIsIFxcXCJoZWlnaHRcXFwiOiBcXFwiMTAwJVxcXCIsIFxcXCJtaW4taGVpZ2h0XFxcIjogXFxcIlxcXCIsIFxcXCJwb3NpdGlvblxcXCI6IFxcXCJhYnNvbHV0ZVxcXCIsIFxcXCJtYXJnaW5cXFwiOiBcXFwiMFxcXCIsIFxcXCJwYWRkaW5nXFxcIjogXFxcIjBcXFwiLCBcXFwicGFkZGluZy10b3BcXFwiOiAkKFxcXCJbZGF0YS1yb2xlPWhlYWRlcl1cXFwiKS5oZWlnaHQoKSArIFxcXCJweFxcXCIsIFxcXCJwYWRkaW5nLWJvdHRvbVxcXCI6ICQoXFxcIltkYXRhLXJvbGU9Zm9vdGVyXVxcXCIpLmhlaWdodCgpICsgXFxcInB4XFxcIiB9KTtcXG5cXG4gICAgICAgIC8vVE9ETzogaGFjayBkZSBsdXhlLCByZWZyZXNoZXMgaW1hZ2VzIHRoYXQgZm9yIHNvbWUgcmVhc29uIGNhbid0IGJlIHNlZW5cXG4gICAgICAgICQoXFxcIiNwYW5lbF9sZWZ0XFxcIikuY3NzKFxcXCJiYWNrZ3JvdW5kLWltYWdlXFxcIiwgJChcXFwiI3BhbmVsX2xlZnRcXFwiKS5jc3MoXFxcImJhY2tncm91bmQtaW1hZ2VcXFwiKSk7XFxuICAgICAgICAkKFxcXCIjcGFuZWxfcmlnaHRcXFwiKS5jc3MoXFxcImJhY2tncm91bmQtaW1hZ2VcXFwiLCAkKFxcXCIjcGFuZWxfcmlnaHRcXFwiKS5jc3MoXFxcImJhY2tncm91bmQtaW1hZ2VcXFwiKSk7XFxuXFxuICAgICAgICAvL3N0b3AgbGlua3MgZnJvbSBiZWluZyBvcGVuZWQgdXAgaW4gZGVzaWduIG1vZGUsIGxpbmtzIGFsd2F5cyBoYXZlIHRoaXMgZGF0YSBhdHRyaWJ1dGVcXG4gICAgICAgICQoXFxcIiNcXFwiICsgdGhpcy5wYXJlbnQuY29uZmlnW1xcXCJhcHBcXFwiXVtcXFwiY29udGVudF9pZFxcXCJdKS5maW5kKFxcXCJbZGF0YS1tbGFiLWlzbGluaz0nMSddXFxcIikuY2xpY2soZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICB9KTtcXG4gICAgfSxcXG5cXG4gICAgLyogdGhpcyBmdW5jdGlvbiBwcm9jZXNzZXMgYSByZWd1bGFyIHBhZ2UgdGhhdCB3YXMgcmV0cmlldmVkLlxcclxcbiAgICAgKlxcclxcbiAgICAgKiBJdCBkb2VzIHRoZSBmb2xsb3dpbmc6XFxyXFxuICAgICAgICBSZW1vdmUgb2xkIEhUTUwgZnJvbSB0aGUgaW50ZXJuYWwgZWRpdGluZyBkaXYgKHRoaXMucGFyZW50LmNvbmZpZ1tcXFwiYXBwXFxcIl1bXFxcImNvbnRlbnRfaWRcXFwiXSlcXHJcXG4gICAgICAgIEV4dHJhY3QgdGl0bGUgYW5kIHNhdmUgaXQgdG8gSlMgdmFyXFxyXFxuICAgICAgICBFeHRyYWN0IEJPRFkgYW5kIGluc2VydCBjb250ZW50IGludG8gdGhpcy5wYXJlbnQuY29uZmlnW1xcXCJhcHBcXFwiXVtcXFwiY29udGVudF9pZFxcXCJdXFxyXFxuICAgICAgICBQcm9jZXNzIHRoZSB0b3AgbGV2ZWwgRElWcyBpbnNpZGUgRElWIHdpdGggSUQgPSB0aGlzLnBhcmVudC5jb25maWdbXFxcImFwcFxcXCJdW1xcXCJjb250ZW50X2lkXFxcIl0gKGJ5IGRlZmF1bHQgbWxhYl9lZGl0YWJsZV9hcmVhKSBzbyB0aGV5IGFyZSBtb3ZlYWJsZS9zb3J0YWJsZVxcclxcbiAgICAqL1xcblxcbiAgICByZWd1bGFyX3BhZ2VfcHJvY2VzczogZnVuY3Rpb24gcmVndWxhcl9wYWdlX3Byb2Nlc3MocGFnZSwgcGFnZV9udW0pIHtcXG4gICAgICAgIHZhciBjb21wX2lkLCB0ZW1wX2NvbXAsIHRlbXBfbGluaztcXG4gICAgICAgIHZhciBzdGFydF9kaXIgPSB0aGlzLnBhcmVudC5jb25maWcudXJscy5hcHAgKyB0aGlzLnBhcmVudC5hcHAucGF0aCArIFxcXCIvXFxcIiArIHRoaXMucGFyZW50LmFwcC5hY3RpdmVfdmVyc2lvbiArIFxcXCIvXFxcIjtcXG5cXG4gICAgICAgIC8vcmVtb3ZlIG9sZCBzdHVmZlxcbiAgICAgICAgJChcXFwiI1xcXCIgKyB0aGlzLnBhcmVudC5jb25maWdbXFxcImFwcFxcXCJdW1xcXCJjb250ZW50X2lkXFxcIl0pLmh0bWwoXFxcIlxcXCIpO1xcblxcbiAgICAgICAgLy9hIHBhZ2UgbWF5IGhhdmUgZmFpbGVkIHRvIHNhdmUsIGluIHRoaXMgY2FzZSB3ZSBjcmVhdGUgYW4gZW1wdHkgcGFnZSBoZXJlLCB0aGVuIGV2ZXJ5dGhpbmcgd29ya3NcXG4gICAgICAgIGlmIChwYWdlID09IFxcXCJcXFwiKSB7XFxuICAgICAgICAgICAgcGFnZSA9IHRoaXMucGFyZW50LmNvbmZpZ1tcXFwiYXBwXFxcIl1bXFxcImh0bWxfaGVhZGVyXFxcIl0ucmVwbGFjZShcXFwiJVRJVExFJVxcXCIsIFxcXCJUaXRsZVxcXCIpICsgdGhpcy5wYXJlbnQuY29uZmlnW1xcXCJhcHBcXFwiXVtcXFwiaHRtbF9mb290ZXJcXFwiXTtcXG4gICAgICAgICAgICBwYWdlID0gcGFnZS5yZXBsYWNlKC9cXFxcXFxcXG4vZywgXFxcIlxcXFxuXFxcIik7XFxuICAgICAgICB9XFxuICAgICAgICAvL1xcbiAgICAgICAgLy9wYXJzZSBkb2MgaW50byB2YXJpYWJsZXNcXG4gICAgICAgIHZhciBkb2MgPSBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKHBhZ2UsIFxcXCJ0ZXh0L2h0bWxcXFwiKTtcXG4gICAgICAgIHZhciBoZWFkID0gZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKFxcXCJoZWFkXFxcIilbMF07XFxuICAgICAgICB2YXIgYm9keSA9IGRvYy5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFxcXCJtbGFiX21haW5fYm9keV9jb250ZW50XFxcIilbMF0uY2xvbmVOb2RlKHRydWUpO1xcblxcbiAgICAgICAgLy9QYWdlIG5hbWUgaXMgcGlja2VkIHVwIGZyb20gdGl0bGUgdGFnIGluIGhlYWRcXG4gICAgICAgIHRoaXMucGFyZW50LmFwcC5jdXJyX3BhZ2V0aXRsZSA9IGhlYWQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXFxcInRpdGxlXFxcIilbMF0uaW5uZXJUZXh0O1xcbiAgICAgICAgdGhpcy5wYXJlbnQuYXBwLmN1cnJfcGFnZV9udW0gPSBwYWdlX251bTtcXG4gICAgICAgICQoXFxcIiNtbGFiX3BhZ2VfY29udHJvbF90aXRsZVxcXCIpLnRleHQodGhpcy5wYXJlbnQuYXBwLmN1cnJfcGFnZXRpdGxlKTtcXG5cXG4gICAgICAgIHRoaXMuYXBwX3VwZGF0ZV9ndWlfbWV0YWRhdGEoKTtcXG5cXG4gICAgICAgIC8vYWRkIGJvZHkgY29udGVudFxcbiAgICAgICAgJChcXFwiI1xcXCIgKyB0aGlzLnBhcmVudC5jb25maWdbXFxcImFwcFxcXCJdW1xcXCJjb250ZW50X2lkXFxcIl0pLmh0bWwoYm9keS5pbm5lckhUTUwpO1xcbiAgICAgICAgdGhpcy5wYXJlbnQuYXBpLmdldEFsbExpYnJhcmllcygpO1xcbiAgICAgICAgdGhpcy5wYXJlbnQuZGVzaWduLnByZXBhcmVfZWRpdGFibGVfYXJlYSgpO1xcblxcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAkLm1vYmlsZS5pbml0aWFsaXplUGFnZSgpO1xcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XFxuICAgICAgICAgICAgY29uc29sZS5sb2coZXJyLm1lc3NhZ2UpO1xcbiAgICAgICAgfVxcbiAgICAgICAgbWxhYi5kdC5hcGkuZGlzcGxheS51cGRhdGVEaXNwbGF5KCk7XFxuICAgICAgICAvL3N0b3AgbGlua3MgZnJvbSBiZWluZyBvcGVuZWQgdXAgaW4gZGVzaWduIG1vZGUsIGxpbmtzIGFsd2F5cyBoYXZlIHRoaXMgZGF0YSBhdHRyaWJ1dGVcXG4gICAgICAgICQoXFxcIiNcXFwiICsgdGhpcy5wYXJlbnQuY29uZmlnW1xcXCJhcHBcXFwiXVtcXFwiY29udGVudF9pZFxcXCJdKS5maW5kKFxcXCJbZGF0YS1tbGFiLWlzbGluaz0nMSddXFxcIikuY2xpY2soZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICB9KTtcXG4gICAgfSxcXG5cXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXFxyXFxuICAgICAqKioqKioqKioqKioqKiBGdW5jdGlvbnMgdG8gbWFuaXB1bGF0ZSBwYWdlcyAqKioqKioqKioqKioqKlxcclxcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuXFxuICAgIC8qXFxyXFxuICAgICAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gZmluZCBpbmRleCBpbiBtbGFiLmR0LmFwcC5wYWdlX25hbWVzIGJ5IGZpbGVuYW1lXFxyXFxuICAgICAqIEBwYXJhbSBzdHJpbmd8aW50IGZpbGVuYW1lL251bWJlciBcXHJcXG4gICAgICogQHJldHVybnMgaW50IGluZGV4XFxyXFxuICAgICAqL1xcbiAgICBwYWdlX2ZpbGVudW0yaW5kZXg6IGZ1bmN0aW9uIHBhZ2VfZmlsZW51bTJpbmRleChwYWdlX2lkKSB7XFxuICAgICAgICBpZiAodHlwZW9mIHBhZ2VfaWQgIT0gXFxcIm51bWJlclxcXCIpIHtcXG4gICAgICAgICAgICBwYWdlX2lkID0gcGFyc2VJbnQocGFnZV9pZCk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAocGFnZV9pZCA9PSAwKSB7XFxuICAgICAgICAgICAgcGFnZV9pZCA9IFxcXCJpbmRleC5odG1sXFxcIjtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgcGFnZV9pZCA9IChcXFwiMDAwXFxcIiArIHBhZ2VfaWQpLnNsaWNlKC0zKSArIFxcXCIuaHRtbFxcXCI7XFxuICAgICAgICB9XFxuICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMucGFyZW50LmFwcC5wYWdlX25hbWVzKSB7XFxuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50LmFwcC5wYWdlX25hbWVzW2ldLmZpbGVuYW1lID09IHBhZ2VfaWQpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICB9LFxcblxcbiAgICAvKlxcclxcbiAgICAgKiBVdGlsaXR5IGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIGZpbGVuYW1lIGZyb20gYSBudW1iZXJcXHJcXG4gICAgICogQHBhcmFtIHN0cmluZ3xpbnQgZmlsZW5hbWUvbnVtYmVyIFxcclxcbiAgICAgKiBAcmV0dXJucyBpbnQgaW5kZXhcXHJcXG4gICAgICovXFxuICAgIHBhZ2VfZmlsZW51bTJmaWxlbmFtZTogZnVuY3Rpb24gcGFnZV9maWxlbnVtMmZpbGVuYW1lKHBhZ2VfaWQpIHtcXG4gICAgICAgIGlmICh0eXBlb2YgcGFnZV9pZCAhPSBcXFwibnVtYmVyXFxcIikge1xcbiAgICAgICAgICAgIHBhZ2VfaWQgPSBwYXJzZUludChwYWdlX2lkKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChwYWdlX2lkID09IDApIHtcXG4gICAgICAgICAgICByZXR1cm4gXFxcImluZGV4Lmh0bWxcXFwiO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICByZXR1cm4gKFxcXCIwMDBcXFwiICsgcGFnZV9pZCkuc2xpY2UoLTMpICsgXFxcIi5odG1sXFxcIjtcXG4gICAgICAgIH1cXG4gICAgfSxcXG5cXG4gICAgLypcXHJcXG4gICAgICogTW92ZSB0aGUgc2VsZWN0ZWQgcGFnZSB0byBhIG5ldyBwb3NpdGlvbiBpbnQgaGUgYXBwLCB0aGlzIGlzIGRvbmUgb24gYmFja2VuZCBieSByZW5hbWluZyB0aGUgYWN0dWFsIGZpbGVcXHJcXG4gICAgICogU28gaWYgeW91IHdhbnQgdG8gbW92ZSBwYWdlIDIgdG8gMTAsIDMgLSA5ICB3aWxsIGJlIG1pbnVzIG9uZSwgMiB3aWxsIGJlIDEwXFxyXFxuICAgICAqIEBwYXJhbSB7dHlwZX0gZXZlbnQganF1ZXJ5IGV2ZW50IGluZm9cXHJcXG4gICAgICogQHBhcmFtIHt0eXBlfSB1aSBqcXVlcnkgdWkgaW5mb1xcclxcbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxcclxcbiAgICAgKi9cXG4gICAgcGFnZV9yZW9yZGVyOiBmdW5jdGlvbiBwYWdlX3Jlb3JkZXIoZXZlbnQsIHVpKSB7XFxuXFxuICAgICAgICAvL2JhaWwgaWYgaXQgaGFzIG5vdCBiZWVuIG1vdmVkXFxuICAgICAgICBpZiAodWkuaXRlbS5maW5kKFxcXCJhXFxcIikuZGF0YShcXFwibWxhYi1wYWdlLW9wZW5cXFwiKSA9PSBwYXJzZUludChtbGFiLmR0LmFwcC5wYWdlX25hbWVzW3VpLml0ZW0uaW5kZXgoKV0uZmlsZW5hbWUpKSB7XFxuICAgICAgICAgICAgY29uc29sZS5sb2coXFxcIm5vdCBtb3ZlZFxcXCIpO1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG4gICAgICAgIHRoYXQgPSB0aGlzO1xcbiAgICAgICAgLy90dXJuIG9mZiBhdXRvbWF0aWMgc2F2aW5nIGJlZm9yZSBtb3ZpbmcgZmlsZVxcbiAgICAgICAgdGhpcy5wYWdlX3NhdmUoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIG1sYWIuZHQudXRpbHMudGltZXJfc3RvcCgpO3RoYXQucGFnZV9yZW9yZGVyX3Byb2Nlc3MoZXZlbnQsIHVpKTtcXG4gICAgICAgIH0sIHVuZGVmaW5lZCwgdHJ1ZSk7XFxuICAgIH0sXFxuXFxuICAgIHBhZ2VfcmVvcmRlcl9wcm9jZXNzOiBmdW5jdGlvbiBwYWdlX3Jlb3JkZXJfcHJvY2VzcyhldmVudCwgdWkpIHtcXG4gICAgICAgIHZhciBhcHBfaWQgPSB0aGlzLnBhcmVudC5hcHAuaWQ7XFxuICAgICAgICB2YXIgZnJvbV9wYWdlID0gdWkuaXRlbS5kYXRhKFxcXCJtbGFiLXBhZ2UtbnVtXFxcIik7IC8vdGhlIGZpbGVuYW1lcyBhcmUgc3RvcmVkIGluIHRoZSBkYXRhIHRhZyBtbGFiLXBhZ2UtbnVtXFxuICAgICAgICB2YXIgdG9fcGFnZSA9IHBhcnNlSW50KG1sYWIuZHQuYXBwLnBhZ2VfbmFtZXNbdWkuaXRlbS5pbmRleCgpXS5maWxlbmFtZSk7IC8vY2FsY3VsYXRlIHRoZSBwYWdlIGl0IHdpbGwgcHVzaCBkb3duIGJ5IHVzaW5nIHRoZSBuZXcgaW5kZXggb2YgdGhlIG1vdmVkIGl0ZW0gYW5kIGxvb2sgdXAgZmlsZW5hbWUgaW4gaW50ZXJuYWwgcGFnZV9uYW1lcyBhcnJheSBcXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcXG5cXG4gICAgICAgIHZhciB1cmwgPSB0aGlzLnBhcmVudC51cmxzLnBhZ2VfcmVvcmRlci5yZXBsYWNlKFxcXCJfSURfXFxcIiwgYXBwX2lkKTtcXG4gICAgICAgIHVybCA9IHVybC5yZXBsYWNlKFxcXCJfRlJPTV9QQUdFX1xcXCIsIGZyb21fcGFnZSk7XFxuICAgICAgICB1cmwgPSB1cmwucmVwbGFjZShcXFwiX1RPX1BBR0VfXFxcIiwgdG9fcGFnZSk7XFxuICAgICAgICB1cmwgPSB1cmwucmVwbGFjZShcXFwiX1VJRF9cXFwiLCB0aGlzLnBhcmVudC51aWQpO1xcblxcbiAgICAgICAgdGhpcy5wYXJlbnQudXRpbHMudXBkYXRlX3N0YXR1cyhcXFwiY2FsbGJhY2tcXFwiLCBfdHJbXFxcIm1sYWIuZHQubWFuYWdlbWVudC5qcy51cGRhdGVfc3RhdHVzLnJlb3JkZXJpbmcucGFnZVxcXCJdLCB0cnVlKTtcXG5cXG4gICAgICAgICQuZ2V0KHVybCwgZnVuY3Rpb24gKGRhdGEpIHtcXG4gICAgICAgICAgICB0aGF0LnBhcmVudC51dGlscy51cGRhdGVfc3RhdHVzKFxcXCJjb21wbGV0ZWRcXFwiKTtcXG4gICAgICAgICAgICBpZiAoZGF0YS5yZXN1bHQgPT0gXFxcInN1Y2Nlc3NcXFwiKSB7XFxuICAgICAgICAgICAgICAgIC8vdXBkYXRlIHRoZSBsaXN0IG9mIHBhZ2VzIHRvIHRoZSBuZXcgb3JkZXIsIHRoZSBwYWdlIG51bWJlcnMgaGF2ZSBjaGFuZ2VkIHNvIHdlIG5lZWQgdG8gZG8gdGhhdFxcbiAgICAgICAgICAgICAgICB0aGF0LnBhcmVudC5hcHAucGFnZV9uYW1lcyA9IGRhdGEucGFnZV9uYW1lcztcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICBhbGVydChcXFwiVW5hYmxlIHRvIG1vdmUgcGFnZVxcXCIpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB0aGF0LmFwcF91cGRhdGVfZ3VpX21ldGFkYXRhKCk7XFxuICAgICAgICAgICAgbWxhYi5kdC51dGlscy50aW1lcl9zdGFydCgpO1xcbiAgICAgICAgfSk7XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcclxcbiAgICAgKiBSZXRyaWV2ZSBjb250ZW50IG9mIGEgcGFnZSBmcm9tIHNlcnZlciBhbmQgaW5zZXJ0IGl0IGludG8gdGhlIGVkaXRvciBhcmVhXFxyXFxuICAgICAqIEZpcnN0IGxpbmUgaXMgYSBwYXR0ZXJuIGZyb20gU3ltZm9ueSByb3V0aW5nIHNvIHdlIGNhbiBnZXQgdGhlIHVwZGF0ZWQgdmVyc2lvbiBmcm9tIHN5bWZvbnkgd2hlbiB3ZSBjaGFuZ2UgaXQgaXMgWU1MIGZpbGVcXHJcXG4gICAgICovXFxuICAgIHBhZ2Vfb3BlbjogZnVuY3Rpb24gcGFnZV9vcGVuKGFwcF9pZCwgcGFnZV9udW0pIHtcXG4gICAgICAgIHRoYXQgPSB0aGlzO1xcbiAgICAgICAgdGhpcy5wYWdlX3NhdmUoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIHRoYXQucGFnZV9vcGVuX3Byb2Nlc3MoYXBwX2lkLCBwYWdlX251bSk7XFxuICAgICAgICB9KTtcXG4gICAgfSxcXG5cXG4gICAgcGFnZV9vcGVuX3Byb2Nlc3M6IGZ1bmN0aW9uIHBhZ2Vfb3Blbl9wcm9jZXNzKGFwcF9pZCwgcGFnZV9udW0pIHtcXG5cXG4gICAgICAgIHRoaXMucGFyZW50LnV0aWxzLnVwZGF0ZV9zdGF0dXMoXFxcImNhbGxiYWNrXFxcIiwgX3RyW1xcXCJtbGFiLmR0Lm1hbmFnZW1lbnQuanMudXBkYXRlX3N0YXR1cy5vcGVuaW5nLnBhZ2VcXFwiXSwgdHJ1ZSk7XFxuXFxuICAgICAgICB2YXIgdXJsID0gdGhpcy5wYXJlbnQudXJscy5wYWdlX2dldC5yZXBsYWNlKFxcXCJfSURfXFxcIiwgYXBwX2lkKTtcXG4gICAgICAgIHVybCA9IHVybC5yZXBsYWNlKFxcXCJfUEFHRV9OVU1fXFxcIiwgcGFnZV9udW0pO1xcbiAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoXFxcIl9VSURfXFxcIiwgdGhpcy5wYXJlbnQudWlkKTtcXG5cXG4gICAgICAgIC8vaGVyZSB3ZSBoaWRlIHRoZSB0b29scyBmb3IgY29tcG9uZW50cyB1bnRpbCB0aGV5IHNlbGVjdCBhIGNvbnRyb2xcXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5wYXJlbnQucXRpcF90b29scyAhPSBcXFwidW5kZWZpbmVkXFxcIikge1xcbiAgICAgICAgICAgICQodGhpcy5wYXJlbnQucXRpcF90b29scykucXRpcCgnaGlkZScpO1xcbiAgICAgICAgICAgIHRoaXMucGFyZW50LnF0aXBfdG9vbHMgPSB1bmRlZmluZWQ7XFxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnBhcmVudC5hcGkucHJvcGVydGllc190b29sdGlwICE9IFxcXCJ1bmRlZmluZWRcXFwiKSB7XFxuICAgICAgICAgICAgICAgICQodGhpcy5wYXJlbnQuYXBpLnByb3BlcnRpZXNfdG9vbHRpcCkucXRpcCgnaGlkZScpO1xcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5hcGkucHJvcGVydGllc190b29sdGlwID0gdW5kZWZpbmVkO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcXG5cXG4gICAgICAgICQuZ2V0KHVybCwgZnVuY3Rpb24gKGRhdGEpIHtcXG4gICAgICAgICAgICBpZiAoZGF0YS5yZXN1bHQgPT0gXFxcInN1Y2Nlc3NcXFwiKSB7XFxuICAgICAgICAgICAgICAgIHRoYXQucGFyZW50LnV0aWxzLnVwZGF0ZV9zdGF0dXMoXFxcImNvbXBsZXRlZFxcXCIpO1xcbiAgICAgICAgICAgICAgICB0aGF0LnBhcmVudC51dGlscy51cGRhdGVfc3RhdHVzKFxcXCJwZXJtYW5lbnRcXFwiLCB0aGF0LnBhcmVudC5hcHAubmFtZSk7XFxuICAgICAgICAgICAgICAgICQoXFxcIiNtbGFiX3BhZ2VfY29udHJvbF90aXRsZVxcXCIpLnRleHQodGhhdC5wYXJlbnQuYXBwLmN1cnJfcGFnZXRpdGxlKTtcXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEucGFnZV9udW1fc2VudCA9PSAwIHx8IGRhdGEucGFnZV9udW1fc2VudCA9PSBcXFwiaW5kZXhcXFwiKSB7XFxuICAgICAgICAgICAgICAgICAgICB0aGF0LmluZGV4X3BhZ2VfcHJvY2VzcyhkYXRhLmh0bWwsIHRydWUpO1xcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRhdGEucGFnZV9udW1fc2VudCA9PSBcXFwibGFzdFxcXCIgJiYgZGF0YS5wYWdlX251bV9yZWFsID09IDApIHtcXG4gICAgICAgICAgICAgICAgICAgIHRoYXQucGFyZW50LnV0aWxzLnRpbWVyX3N0YXJ0KCk7XFxuICAgICAgICAgICAgICAgICAgICBpZiAoJChcXFwiI21sYWJfb3ZlcmxheVxcXCIpLmlzKCc6dmlzaWJsZScpKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgJChcXFwiI21sYWJfb3ZlcmxheVxcXCIpLnNsaWRlVXAoKTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIHRoYXQucmVndWxhcl9wYWdlX3Byb2Nlc3MoZGF0YS5odG1sLCBkYXRhLnBhZ2VfbnVtX3JlYWwpO1xcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhdGggPSB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUuc3BsaXQoXFxcIi9cXFwiKTtcXG4gICAgICAgICAgICAgICAgICAgIHBhdGhbcGF0aC5sZW5ndGggLSAzXSA9IGRhdGEuYXBwX2lkO1xcbiAgICAgICAgICAgICAgICAgICAgcGF0aFtwYXRoLmxlbmd0aCAtIDJdID0gZGF0YS5wYWdlX251bV9yZWFsO1xcbiAgICAgICAgICAgICAgICAgICAgaGlzdG9yeS5wdXNoU3RhdGUoeyBpZDogZGF0YS5hcHBfaWQsIHBhZ2U6IGRhdGEucGFnZV9udW1fcmVhbCB9LCB0aGF0LnBhcmVudC5hcHAuY3Vycl9wYWdldGl0bGUsIHBhdGguam9pbihcXFwiL1xcXCIpKTtcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5sb2NrX3N0YXR1cyA9PSBcXFwibG9ja2VkXFxcIikge1xcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5wYXJlbnQuYXBwLmxvY2tlZCA9IHRydWU7XFxuICAgICAgICAgICAgICAgICAgICAkKFxcXCIjXFxcIiArIHRoYXQucGFyZW50LmNvbmZpZ1tcXFwiYXBwXFxcIl1bXFxcImNvbnRlbnRfaWRcXFwiXSkuZmFkZVRvKCdzbG93JywgLjYpO1xcbiAgICAgICAgICAgICAgICAgICAgJChcXFwiZGl2LmNvbnRhaW5lclxcXCIpLmFwcGVuZCgnPGRpdiBpZD1cXFwibWxhYl9lZGl0b3JfZGlzYWJsZWRcXFwiIHN0eWxlPVxcXCJiYWNrZ3JvdW5kLWNvbG9yOiBncmF5OyBwb3NpdGlvbjogYWJzb2x1dGU7dG9wOjExMHB4O2xlZnQ6MDt3aWR0aDogMTAwJTtoZWlnaHQ6MTAwJTt6LWluZGV4OjI7b3BhY2l0eTowLjQ7ZmlsdGVyOiBhbHBoYShvcGFjaXR5ID0gNTApOyBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoL2ltZy9wYWdlX2xvY2tlZC5wbmcpOyBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0OyBiYWNrZ3JvdW5kLXBvc2l0aW9uOiA5NSUgMiU7XFxcIj48L2Rpdj4nKTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIHRoYXQucGFyZW50LmFwcC5sb2NrZWQgPSBmYWxzZTtcXG4gICAgICAgICAgICAgICAgICAgICQoXFxcIiNtbGFiX2VkaXRvcl9kaXNhYmxlZFxcXCIpLnJlbW92ZSgpO1xcbiAgICAgICAgICAgICAgICAgICAgJChcXFwiI1xcXCIgKyB0aGF0LnBhcmVudC5jb25maWdbXFxcImFwcFxcXCJdW1xcXCJjb250ZW50X2lkXFxcIl0pLmZhZGVUbygnc2xvdycsIDEpO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIGlmICgkKFxcXCIjbWxhYl9vdmVybGF5XFxcIikuaXMoJzp2aXNpYmxlJykpIHtcXG4gICAgICAgICAgICAgICAgICAgICQoXFxcIiNtbGFiX292ZXJsYXlcXFwiKS5zbGlkZVVwKCk7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgLy90dXJuIG9mZiBjbGlrYWJpbGl0eSBvZiBsaW5rc1xcbiAgICAgICAgICAgICAgICAkKFxcXCIjbWxhYl9lZGl0YWJsZV9hcmVhXFxcIikuZmluZChcXFwiYVxcXCIpLmNsaWNrKGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICAgICAgICAgIH0pO1xcblxcbiAgICAgICAgICAgICAgICB0aGF0LnBhcmVudC51dGlscy50aW1lcl9zdGFydCgpO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHRoYXQucGFyZW50LnV0aWxzLnVwZGF0ZV9zdGF0dXMoXFxcInRlbXBvcmFyeVxcXCIsIGRhdGEubXNnLCBmYWxzZSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcclxcbiAgICAgKiBDYWxsIGEgYmFja2VuZCBweXRob24gc2NyaXB0IHRoYXQgdXNlcyBPcGVuT2ZmaWNlIHRvIGNvbnZlcnQgUFBUIGFuZCBET0MgdG8gaW5kaXZpZHVhbCBwYWdlc1xcclxcbiAgICAgKi9cXG4gICAgZmlsZV9pbXBvcnQ6IGZ1bmN0aW9uIGZpbGVfaW1wb3J0KCkge1xcbiAgICAgICAgdGhhdCA9IHRoaXM7XFxuICAgICAgICB0aGlzLnBhZ2Vfc2F2ZShmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgdGhhdC5maWxlX2ltcG9ydF9wcm9jZXNzKCk7XFxuICAgICAgICB9KTtcXG4gICAgfSxcXG5cXG4gICAgZmlsZV9pbXBvcnRfcHJvY2VzczogZnVuY3Rpb24gZmlsZV9pbXBvcnRfcHJvY2VzcygpIHtcXG4gICAgICAgIHRoaXMucGFyZW50LnV0aWxzLnVwZGF0ZV9zdGF0dXMoXFxcImNhbGxiYWNrXFxcIiwgX3RyW1xcXCJtbGFiLmR0Lm1hbmFnZW1lbnQuanMudXBkYXRlX3N0YXR1cy5pbXBvcnRpbmcuZmlsZVxcXCJdLCB0cnVlKTtcXG5cXG4gICAgICAgIHZhciBmb3JtID0gJCgnI21sYWJfZm9ybV9pbXBvcnRfZmlsZScpWzBdOyAvLyBZb3UgbmVlZCB0byB1c2Ugc3RhbmRhcmQgamF2YXNjcmlwdCBvYmplY3QgaGVyZVxcbiAgICAgICAgdmFyIGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKGZvcm0pO1xcblxcbiAgICAgICAgJC5hamF4KHtcXG4gICAgICAgICAgICB1cmw6IHRoaXMucGFyZW50LnVybHMuZmlsZV9pbXBvcnQsXFxuICAgICAgICAgICAgZGF0YTogZm9ybURhdGEsXFxuICAgICAgICAgICAgdHlwZTogJ1BPU1QnLFxcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBmYWxzZSxcXG4gICAgICAgICAgICBwcm9jZXNzRGF0YTogZmFsc2UsXFxuICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gc3VjY2Vzcyhqc29uKSB7XFxuICAgICAgICAgICAgICAgIHRoYXQucGFyZW50LnV0aWxzLnVwZGF0ZV9zdGF0dXMoXFxcImNvbXBsZXRlZFxcXCIpO1xcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcXFwiU3RhdHVzIHJldHVybmVkOiBcXFwiICsganNvbi5hcHBfc3RhdHVzKTtcXG4gICAgICAgICAgICAgICAgaWYgKGpzb24ucmVzdWx0ID09IFxcXCJzdWNjZXNzXFxcIikge1xcbiAgICAgICAgICAgICAgICAgICAgbWxhYi5kdC51dGlscy51cGRhdGVfc3RhdHVzKFxcXCJ0ZW1wb3JhcnlcXFwiLCBcXFwiXFxcIiwgZmFsc2UpO1xcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5wYXJlbnQuYXBwLnBhZ2VfbmFtZXMgPSBkYXRhLnBhZ2VfbmFtZXM7XFxuICAgICAgICAgICAgICAgICAgICB0aGF0LmFwcF91cGRhdGVfZ3VpX21ldGFkYXRhKCk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxyXFxuICAgICAqIFRoaXMgd2lsbCB1cGRhdGUgdGhlIHRpdGxlIG9mIHRoZSBjdXJyZW50bHkgb3BlbiBwYWdlIGFuZCBhbHNvIHVwZGF0ZSByZWxldmFudCBpdGVtcyBvdGhlciBwbGFjZXNcXHJcXG4gICAgICovXFxuICAgIHBhZ2VfdXBkYXRlX3RpdGxlOiBmdW5jdGlvbiBwYWdlX3VwZGF0ZV90aXRsZSgpIHtcXG4gICAgICAgIGlmICh0aGlzLnBhcmVudC5hcHAubG9ja2VkKSB7XFxuICAgICAgICAgICAgYWxlcnQoX3RyW1xcXCJtbGFiLmR0Lm1hbmFnZW1lbnQuanMucGFnZV91cGRhdGVfdGl0bGUuYWxlcnQucGFnZS5sb2NrZWRcXFwiXSk7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdmFyIHBhZ2VfaW5kZXggPSB0aGlzLnBhZ2VfZmlsZW51bTJpbmRleCh0aGlzLnBhcmVudC5hcHAuY3Vycl9wYWdlX251bSk7XFxuXFxuICAgICAgICB0aGlzLnBhcmVudC5mbGFnX2RpcnR5ID0gdHJ1ZTtcXG4gICAgICAgIHRoaXMucGFyZW50LmFwcC5jdXJyX3BhZ2V0aXRsZSA9ICQoXFxcIiNtbGFiX3BhZ2VfY29udHJvbF90aXRsZVxcXCIpLnRleHQoKTtcXG4gICAgICAgIHRoaXMucGFyZW50LmFwcC5wYWdlX25hbWVzW3BhZ2VfaW5kZXhdW1xcXCJ0aXRsZVxcXCJdID0gdGhpcy5wYXJlbnQuYXBwLmN1cnJfcGFnZXRpdGxlO1xcbiAgICAgICAgJChcXFwiI21sYWJfcGFnZV9jb250cm9sX3RpdGxlXFxcIikudGV4dCh0aGlzLnBhcmVudC5hcHAuY3Vycl9wYWdldGl0bGUpO1xcbiAgICAgICAgdGhpcy5hcHBfdXBkYXRlX2d1aV9tZXRhZGF0YSh0cnVlKTtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxyXFxuICAgICAqIFRoaXMgaXMgdGhlIHNhdmUgZnVuY3Rpb24sIGl0IGlzIGNhbGxlZCBpbiB0aHJlZSBwb3NzaWJsZSB3YXlzOlxcclxcbiAgICAgKiAxOiBXaGVuIGEgdXNlciBjbGlja3MgdGhlIHNhdmUgYnV0dG9uXFxyXFxuICAgICAqIDI6IFdoZW4gdGhlIHNhdmUgdGltZXIgKHRoaXMucGFyZW50LnV0aWxzLnRpbWVyX3NhdmUpIGtpY2tzIGluXFxyXFxuICAgICAqIDM6IFdoZW4gYSBmdW5jdGlvbiB0aGF0IGhhcyB0byBzYXZlIHRoZSBwYWdlIGZpcnN0IGlzIGV4ZWN1dGVkLlxcclxcbiAgICAgKlxcclxcbiAgICAgKiBJbiBjYXNlIDMgdGggZm5jIGFyZ3VtZW50IGlzIHNwZWNpZmllZCBhbmQgd2hlbiB0aGUgc2F2ZSBpcyBjb21wbGV0ZWQgYW5kIHRoZSBBSkFYIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIGNhbGxlZCB0aGlzIGZ1bmN0aW9uIHdpbGwgYmUgZXhlY3V0ZWQuXFxyXFxuICAgICAqIFRoaXMgd2F5IHdlIGFyZSBzdXJlIHRoYXQgcGFnZSByZWxhdGVkIHZhcmlhYmxlcyBhcmUgbm90IG91dGRhdGVkIGlmIHRoZSBzYXZlIGZ1bmN0aW9uIHRha2VzIGEgbG9uZyB0aW1lIHRvIGNvbXBsZXRlIG9uIHRoZSBzZXJ2ZXIuXFxyXFxuICAgICAqXFxyXFxuICAgICAqIHRvIHNhdmUgYSBwYWdlIHdlIG5lZWQgdG8gcmVhc3NlbWJsZSBpdCxcXHJcXG4gICAgICogZmlyc3QgY2xvbmUgY3VycmVudCBib2R5IGZyb20gdGhlIGVkaXRvciAoYW5kIGdpdmUgaXQgYSBuZXcgSUQhKVxcclxcbiAgICAgKiBjbGVhbiBpdCB1cCB1c2luZyB0aGUgb25TYXZlIGZ1bmN0aW9uIGZvciBlYWNoIGNvbXBvbmVudFxcclxcbiAgICAgKiB0aGVuIHBpY2sgdXAgZG9jIHZhcmlhYmxlIHdoaWNoIGhhcyBlbXB0eSBib2R5LCB0aGVuIGluc2VydCB0aGUgY2xlYW5lZCBlbGVtZW50c1xcclxcbiAgICAgKiBmaW5hbGx5IGNvbnZlcnQgdG8gdGV4dCB0byBzZW5kIGJhY2tcXHJcXG4gICAgICogQHBhcmFtIHt0eXBlfSBmbmNcXHJcXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cXHJcXG4gICAgICovXFxuICAgIHBhZ2Vfc2F2ZTogZnVuY3Rpb24gcGFnZV9zYXZlKGZuYywgb3ZlcnJpZGUsIG5vX2Rpc3BsYXlfdXBkYXRlKSB7XFxuICAgICAgICB0aGlzLnBhcmVudC51dGlscy50aW1lcl9zdG9wKCk7XFxuICAgICAgICB2YXIgcmVxdWlyZV9zYXZlID0gdHJ1ZTtcXG4gICAgICAgIHZhciByZXMgPSBmYWxzZTtcXG4gICAgICAgIHRoaXMucGFyZW50LmNvdW50ZXJfc2F2aW5nX3BhZ2UrKztcXG5cXG4gICAgICAgIC8vY2Fubm90IHNhdmUgaWYgbG9ja2VkXFxuICAgICAgICBpZiAoJChcXFwiI21sYWJfZWRpdG9yX2Rpc2FibGVkXFxcIikubGVuZ3RoID4gMCkge1xcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQYWdlIGxvY2tlZCwgZGlkIG5vdCBzYXZlJyk7XFxuICAgICAgICAgICAgcmVxdWlyZV9zYXZlID0gZmFsc2U7XFxuICAgICAgICB9XFxuXFxuICAgICAgICAvL3RoaXMgaXMgY2FsbGVkIGZyb20gYSB0aW1lciwgc28gd2UgYWxzbyBuZWVkIHRvIGNoZWNrIGlmIGFuIGFwcCBoYXMgYmVlbiBjcmVhdGVkLCBldGNcXG4gICAgICAgIC8vYWxzbyBpZiBhbnkgY2hhbmdlcyBoYXZlIG9jY3VycmVkXFxuICAgICAgICBpZiAodHlwZW9mIHRoaXMucGFyZW50LmFwcC5jdXJyX3BhZ2VfbnVtID09IFxcXCJ1bmRlZmluZWRcXFwiIHx8IHR5cGVvZiB0aGlzLnBhcmVudC5hcHAuaWQgPT0gXFxcInVuZGVmaW5lZFxcXCIpIHtcXG4gICAgICAgICAgICByZXF1aXJlX3NhdmUgPSBmYWxzZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICghdGhpcy5wYXJlbnQuZmxhZ19kaXJ0eSAmJiB0eXBlb2Ygb3ZlcnJpZGUgPT0gXFxcInVuZGVmaW5lZFxcXCIpIHtcXG4gICAgICAgICAgICByZXF1aXJlX3NhdmUgPSBmYWxzZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICghcmVxdWlyZV9zYXZlICYmIHR5cGVvZiBmbmMgIT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAgICAgICByZXR1cm4gZm5jKCk7XFxuICAgICAgICB9IGVsc2UgaWYgKCFyZXF1aXJlX3NhdmUpIHtcXG4gICAgICAgICAgICB0aGlzLnBhcmVudC51dGlscy50aW1lcl9zdGFydCgpO1xcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIC8vcHJlcGFyZSB2YXJpb3VzIHZhcmlhYmxlc1xcbiAgICAgICAgdGhpcy5wYXJlbnQudXRpbHMudXBkYXRlX3N0YXR1cyhcXFwiY2FsbGJhY2tcXFwiLCBfdHJbXFxcIm1sYWIuZHQubWFuYWdlbWVudC5qcy51cGRhdGVfc3RhdHVzLnN0b3JpbmcucGFnZVxcXCJdLCB0cnVlKTtcXG4gICAgICAgIHZhciBjdXJyX2VsID0gJChcXFwiI1xcXCIgKyB0aGlzLnBhcmVudC5jb25maWdbXFxcImFwcFxcXCJdW1xcXCJjb250ZW50X2lkXFxcIl0gKyBcXFwiIC5tbGFiX2N1cnJlbnRfY29tcG9uZW50XFxcIik7XFxuICAgICAgICBjdXJyX2VsLnJlbW92ZUNsYXNzKFxcXCJtbGFiX2N1cnJlbnRfY29tcG9uZW50XFxcIik7XFxuICAgICAgICB2YXIgYXBwX2lkID0gdGhpcy5wYXJlbnQuYXBwLmlkO1xcbiAgICAgICAgdmFyIHBhZ2VfbnVtID0gdGhpcy5wYXJlbnQuYXBwLmN1cnJfcGFnZV9udW07XFxuICAgICAgICB2YXIgcGFnZV9jb250ZW50ID0gXFxcIlxcXCI7XFxuICAgICAgICB2YXIgY29tcG9uZW50X2NhdGVnb3JpZXMgPSBuZXcgT2JqZWN0KCk7XFxuICAgICAgICB2YXIgdGVtcGxhdGVfYmVzdF9wcmFjdGljZV9tc2cgPSBuZXcgQXJyYXkoKTtcXG4gICAgICAgIHZhciB1cmwgPSB0aGlzLnBhcmVudC51cmxzLnBhZ2Vfc2F2ZS5yZXBsYWNlKFxcXCJfSURfXFxcIiwgYXBwX2lkKTtcXG4gICAgICAgIHVybCA9IHVybC5yZXBsYWNlKFxcXCJfUEFHRV9OVU1fXFxcIiwgcGFnZV9udW0pO1xcbiAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoXFxcIl9DSEVDS1NVTV9cXFwiLCB0aGlzLnBhcmVudC5hcHAuYXBwX2NoZWNrc3VtKTtcXG5cXG4gICAgICAgIC8vdGhpcyBsb29wIGlzIGE6IHBpY2tpbmcgdXAgdGhlIGNsZWFuZWQgSFRNTCBmb3IgZWFjaCBjb21wb25lbnQsXFxuICAgICAgICAvLyh0aGlzIGlzIGRvbmUgYnkgY2FsbGluZyB0aGUgb25TYXZlIHVuY3Rpb24gd2hpY2ggc3RyaXBzIGF3YXkgYW55dGhpbmcgd2UgYXJlIG5vdCBpbnRlcmVzdGVkIGluKVxcbiAgICAgICAgLy8gYW5kIGI6IGNoZWNraW5nIGlmIHRoZSBjb21wb25lbnQgdHJhbnNncmVzc2VzIGFueSBvZiB0aGUgcnVsZXMgZm9yIHRoZSB0ZW1wbGF0ZVxcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xcbiAgICAgICAgJChcXFwiI1xcXCIgKyB0aGF0LnBhcmVudC5jb25maWdbXFxcImFwcFxcXCJdW1xcXCJjb250ZW50X2lkXFxcIl0pLmNoaWxkcmVuKFxcXCJkaXZcXFwiKS5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICB2YXIgY29tcF9pZCA9ICQodGhpcykuZGF0YShcXFwibWxhYi10eXBlXFxcIik7XFxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGF0LnBhcmVudC5jb21wb25lbnRzW2NvbXBfaWRdLmNvZGUgIT09IFxcXCJ1bmRlZmluZWRcXFwiICYmIHR5cGVvZiB0aGF0LnBhcmVudC5jb21wb25lbnRzW2NvbXBfaWRdLmNvZGUub25TYXZlICE9PSBcXFwidW5kZWZpbmVkXFxcIikge1xcbiAgICAgICAgICAgICAgICBwYWdlX2NvbnRlbnQgPSBwYWdlX2NvbnRlbnQgKyB0aGF0LnBhcmVudC5jb21wb25lbnRzW2NvbXBfaWRdLmNvZGUub25TYXZlKHRoaXMpO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHBhZ2VfY29udGVudCA9IHBhZ2VfY29udGVudCArICQodGhpcylbMF0ub3V0ZXJIVE1MICsgXFxcIlxcXFxuXFxcIjtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgLy9ydW4gdGhlIHRlbXBsYXRlIGNoZWNrc1xcbiAgICAgICAgICAgIHRoYXQucGFyZW50LmJlc3RwcmFjdGljZS5jb21wb25lbnRfY2hlY2tfY29udGVudCh0aGlzLCBjb21wX2lkLCBjb21wb25lbnRfY2F0ZWdvcmllcywgdGVtcGxhdGVfYmVzdF9wcmFjdGljZV9tc2cpO1xcbiAgICAgICAgfSk7XFxuXFxuICAgICAgICB0aGlzLnBhcmVudC5iZXN0cHJhY3RpY2UucGFnZV9jaGVja19jb250ZW50KGNvbXBvbmVudF9jYXRlZ29yaWVzLCB0ZW1wbGF0ZV9iZXN0X3ByYWN0aWNlX21zZyk7XFxuXFxuICAgICAgICAvL2lmIHRoaXMgaXMgdGhlIGluZGV4IHBhZ2Ugd2UgYWRkIHRoZSBmdWxsIEhUTUwgcGFnZSwgaWYgbm90IHdlIG9ubHkgcmVxdWlyZSBhIHZlcnkgc2ltcGxlIGhlYWRlci9mb290ZXJcXG4gICAgICAgIGlmIChwYWdlX251bSA9PSAwKSB7XFxuICAgICAgICAgICAgdmFyIGZpbmFsX2RvYyA9IHRoaXMucGFyZW50LmFwcC5jdXJyX2luZGV4cGFnZV9odG1sO1xcbiAgICAgICAgICAgIGZpbmFsX2RvYy5nZXRFbGVtZW50QnlJZCh0aGlzLnBhcmVudC5jb25maWdbXFxcImFwcFxcXCJdW1xcXCJjb250ZW50X2lkXFxcIl0pLmlubmVySFRNTCA9IHBhZ2VfY29udGVudDtcXG4gICAgICAgICAgICBmaW5hbF9kb2MudGl0bGUgPSB0aGlzLnBhcmVudC5hcHAuY3Vycl9wYWdldGl0bGU7XFxuICAgICAgICAgICAgdmFyIGh0bWwgPSBuZXcgWE1MU2VyaWFsaXplcigpLnNlcmlhbGl6ZVRvU3RyaW5nKGZpbmFsX2RvYyk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHZhciBodG1sID0gcGFnZV9jb250ZW50O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgY3Vycl9lbC5hZGRDbGFzcyhcXFwibWxhYl9jdXJyZW50X2NvbXBvbmVudFxcXCIpO1xcblxcbiAgICAgICAgLy9maW5hbGx5IHdlIHN1Ym1pdCB0aGUgZGF0YSB0byB0aGUgc2VydmVyLCB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gd2lsbCBmdXJ0aGVyIGV4ZWN1dGUgdGhlIGZ1bmN0aW9uIHNwZWNpZmllZCBpbiB0aGUgZm5jIGFyZ3VtZW50LCBpZiBhbnlcXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcXG4gICAgICAgICQucG9zdCh1cmwsIHsgdGl0bGU6IHRoaXMucGFyZW50LmFwcC5jdXJyX3BhZ2V0aXRsZSwgaHRtbDogaHRtbCB9LCBmdW5jdGlvbiAoZGF0YSkge1xcblxcbiAgICAgICAgICAgIC8vaWYgdGhpcyBjb3VudGVyID0gMCB0aGVuIG5vb25lIGVsc2UgaGF2ZSBjYWxsZWQgaXQgaW4gdGhlIG1lYW50aW1lIGFuZCBpdCBpcyBPSyB0byByZXN0YXJ0IHRpbWVyXFxuICAgICAgICAgICAgdGhhdC5wYXJlbnQuY291bnRlcl9zYXZpbmdfcGFnZS0tO1xcblxcbiAgICAgICAgICAgIGlmIChkYXRhLnJlc3VsdCA9PSBcXFwic3VjY2Vzc1xcXCIpIHtcXG4gICAgICAgICAgICAgICAgdGhhdC5wYXJlbnQudXRpbHMudXBkYXRlX3N0YXR1cyhcXFwidGVtcG9yYXJ5XFxcIiwgX3RyW1xcXCJtbGFiLmR0Lm1hbmFnZW1lbnQuanMudXBkYXRlX3N0YXR1cy5zYXZlZC5wYWdlXFxcIl0sIGZhbHNlKTtcXG4gICAgICAgICAgICAgICAgdGhhdC5wYXJlbnQuZmxhZ19kaXJ0eSA9IGZhbHNlO1xcblxcbiAgICAgICAgICAgICAgICAvL2lmIGEgZnVuY3Rpb24gd2FzIHNwZWNpZmllZCB3ZSBub3cgZXhlY3V0ZSBpdCwgaW5pc2RlIHRoaXMgZnVuY3Rpb24gdGhlIHRoaXMucGFyZW50LnV0aWxzLnRpbWVyX3NhdmUgdGltZXIgd2lsbCBiZSByZXN0YXJ0ZWRcXG4gICAgICAgICAgICAgICAgLy9pZiBubyBmdW5jdGlvbiB3YXMgc3BlY2lmaWVkIEFORCBuby1vbmUgZWxzZSBoYXMgaW5pdGlhdGVkIHRoZSBzYXZlIGZ1bmN0aW9uLCB0aGVuIE9LIHRvIHJlc3RhcnQgdGltZXJcXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbmMgIT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IGZuYygpO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIC8vcHJvY2VzcyBtZXRhZGF0YSBpbmZvcm1hdGlvbiB0aGF0IGhhcyBjb21lIGJhY2tcXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhLmFwcF9pbmZvICE9IFxcXCJ1bmRlZmluZWRcXFwiKSB7XFxuICAgICAgICAgICAgICAgICAgICAvL3dlIG1heSBoYXZlIGEgcmVzdWx0IHNheWluZyBub2NoYW5nZVxcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuYXBwX2luZm8ucmVzdWx0ID09PSBcXFwiZmlsZV9jaGFuZ2VzXFxcIikge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vbG9hZCBpbiBtZXRhZGF0YSBhbmQgKHBvc3NpYmx5IG5ldykgY2hlY2tzdW0gb2YgYXBwIGludG8gdmFyaWFibGVzLCB0aGVuIHVwYXRlIGRpc3BsYXlcXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcXFwiQXBwIGZpbGVzIHdlcmUgY2hhbmdlZFxcXCIpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQucGFyZW50LmFwcC5hcHBfY2hlY2tzdW0gPSBkYXRhLmFwcF9pbmZvLm1sYWJfYXBwX2NoZWNrc3VtO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQucGFyZW50LmFwcC5wYWdlX25hbWVzID0gZGF0YS5hcHBfaW5mby5tbGFiX2FwcC5wYWdlX25hbWVzO1xcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhLmFwcF9pbmZvLnJlc3VsdCA9PT0gXFxcIm5vX2ZpbGVfY2hhbmdlc1xcXCIpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcXFwiTm8gY2hhbmdlcyB0byBhcHAgZmlsZXNcXFwiKTtcXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoYXQucGFyZW50LmNvdW50ZXJfc2F2aW5nX3BhZ2UgPT0gMCAmJiB0eXBlb2YgZm5jID09ICd1bmRlZmluZWQnKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQucGFyZW50LnV0aWxzLnRpbWVyX3N0YXJ0KCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgICAgIHRoYXQucGFyZW50LmFwcC5uYW1lID0gZGF0YS5hcHBfaW5mby5tbGFiX2FwcC5uYW1lO1xcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5wYXJlbnQuYXBwLmRlc2NyaXB0aW9uID0gZGF0YS5hcHBfaW5mby5tbGFiX2FwcC5kZXNjcmlwdGlvbjtcXG4gICAgICAgICAgICAgICAgICAgIHRoYXQucGFyZW50LmFwcC5rZXl3b3JkcyA9IGRhdGEuYXBwX2luZm8ubWxhYl9hcHAua2V5d29yZHM7XFxuICAgICAgICAgICAgICAgICAgICB0aGF0LnBhcmVudC5hcHAudGFncyA9IGRhdGEuYXBwX2luZm8ubWxhYl9hcHAudGFncztcXG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9fZGlzcGxheV91cGRhdGUpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmFwcF91cGRhdGVfZ3VpX21ldGFkYXRhKCk7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH07XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgLy9mYWlsZWRcXG4gICAgICAgICAgICAgICAgdGhhdC5wYXJlbnQudXRpbHMudXBkYXRlX3N0YXR1cyhcXFwidGVtcG9yYXJ5XFxcIiwgX3RyW1xcXCJtbGFiLmR0Lm1hbmFnZW1lbnQuanMudXBkYXRlX3N0YXR1cy51bmFibGUuc2F2ZS5wYWdlXFxcIl0gKyBcXFwiOiBcXFwiICsgZGF0YS5tc2csIGZhbHNlKTtcXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbmMgIT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAgICAgICAgICAgICAgIC8vaWYgdGhpcyBzYXZlIGF0dGVtcHQgd2FzIGEgcGFydCBvZiBhbm90aGVyIG9wZXJhdGlvbiB3ZSB3aWxsIGFzayBpZiB0aGV5IHdhbnQgdG8gdHJ5IGFnYWluLCBjYW5jZWwgb3IgY29udGludWUgd2l0aG91dCBzYXZpbmdcXG4gICAgICAgICAgICAgICAgICAgIC8vKHRoZSBjaGFuZ2UgbWF5IGhhdmUgYmVlbiBtaW5pbWFsIGFuZCB0aGV5IHdhbnQgdG8gc3RhcnQgYSBuZXcgYXBwIGxldCdzIHNheSlcXG4gICAgICAgICAgICAgICAgICAgICQoXFxcIiNtbGFiX2RpYWxvZ19jb25maXJtXFxcIikuZGlhbG9nKHtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNpemFibGU6IGZhbHNlLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogMTQwLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGFsOiB0cnVlLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbnM6IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcIlJldHJ5XFxcIjogZnVuY3Rpb24gUmV0cnkoKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLmRpYWxvZyhcXFwiY2xvc2VcXFwiKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQucGFnZV9zYXZlKGZuYyk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXCJDb250aW51ZVxcXCI6IGZ1bmN0aW9uIENvbnRpbnVlKCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5kaWFsb2coXFxcImNsb3NlXFxcIik7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMgPSBmbmMoKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcIkNhbmNlbFxcXCI6IGZ1bmN0aW9uIENhbmNlbCgpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQodGhpcykuZGlhbG9nKFxcXCJjbG9zZVxcXCIpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIC8vaWYgdGhpcyB3YXMgbm90IGNhbGxlZCBmcm9tIGEgZnVuY3Rpb24gQU5EIHRoZSBzYXZlIGZ1bmN0aW9uIGhhcyBub3QgYmVlbiBjYWxsZWQgYnkgb3RoZXJzLCB0aGVuIHdlIHJlc3RhcnQgdGhlIHNhdmUgdGltZXIuXFxuICAgICAgICAgICAgaWYgKHRoYXQucGFyZW50LmNvdW50ZXJfc2F2aW5nX3BhZ2UgPT0gMCAmJiB0eXBlb2YgZm5jID09ICd1bmRlZmluZWQnKSB7XFxuICAgICAgICAgICAgICAgIHRoYXQucGFyZW50LnV0aWxzLnRpbWVyX3N0YXJ0KCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuXFxuICAgICAgICAvL2Fib3ZlIHdlIGhhdmUgY291bnRlZCB0aGUgbnVtYmVyIG9mIGlzc3VlcyByZWxhdGluZyB0byB0aGUgdGVtcGxhdGUgXFxcImJlc3QgcHJhY3RpY2VzXFxcIiBjb25maWd1cmF0aW9uLCB0aW1lIHRvIGRpc3BsYXkgdGhlIGVycm9yIG1lc3NhZ2UsIGlmIGFueVxcbiAgICAgICAgaWYgKHRlbXBsYXRlX2Jlc3RfcHJhY3RpY2VfbXNnLmxlbmd0aCA+IDApIHtcXG5cXG4gICAgICAgICAgICAkKFxcXCIjbWxhYl9zdGF0dXNiYXJfcGVybWFuZW50XFxcIikucXRpcCh7XFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHsgdGV4dDogXFxcIjx1bD48bGk+XFxcIiArIHRlbXBsYXRlX2Jlc3RfcHJhY3RpY2VfbXNnLmpvaW4oXFxcIjwvbGk+PGxpPlxcXCIpICsgXFxcIjwvbGk+PC91bD5cXFwiIH0sXFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB7IG15OiAndG9wTWlkZGxlJywgYXQ6ICdib3R0b21NaWRkbGUnLCB2aWV3cG9ydDogJCh3aW5kb3cpIH0sXFxuICAgICAgICAgICAgICAgIHNob3c6IHsgcmVhZHk6IHRydWUgfSxcXG4gICAgICAgICAgICAgICAgaGlkZTogeyBldmVudDogJ3VuZm9jdXMnIH0sXFxuICAgICAgICAgICAgICAgIHN0eWxlOiB7IFxcXCJiYWNrZ3JvdW5kLWNvbG9yXFxcIjogXFxcIndoaXRlXFxcIiwgY29sb3I6IFxcXCJibHVlXFxcIiwgY2xhc3NlczogXFxcIm1sYWJfcXRpcF9pbmZvXFxcIiwgdGlwOiB0cnVlIH0gfSk7XFxuXFxuICAgICAgICAgICAgLy9oaWRlcyB0aGUgcVRpcCBhZnRlciA1IHNlY29uZHNcXG4gICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgICQoXFxcIi5tbGFiX3F0aXBfaW5mb1xcXCIpLnJlbW92ZSgpO1xcbiAgICAgICAgICAgIH0sIDUwMDApO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAkKFxcXCIubWxhYl9xdGlwX2luZm9cXFwiKS5yZW1vdmUoKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiByZXM7XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcclxcbiAgICAqIENyZWF0ZXMgYSBuZXcgZmlsZSBvbiB0aGUgc2VydmVyIGFuZCBvcGVucyBpdFxcclxcbiAgICAqL1xcbiAgICBwYWdlX25ldzogZnVuY3Rpb24gcGFnZV9uZXcoKSB7XFxuICAgICAgICB2YXIgdGl0bGUgPSBwcm9tcHQoX3RyW1xcXCJtbGFiLmR0Lm1hbmFnZW1lbnQuanMucGFnZV9uZXcucHJvbXB0LnRpdGxlLm5ldy5wYWdlXFxcIl0pO1xcbiAgICAgICAgaWYgKHRpdGxlICE9IG51bGwpIHtcXG4gICAgICAgICAgICB0aGF0ID0gdGhpcztcXG4gICAgICAgICAgICB0aGlzLnBhZ2Vfc2F2ZShmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgIHRoYXQucGFnZV9uZXdfcHJvY2Vzcyh0aXRsZSk7XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgIH0sXFxuXFxuICAgIHBhZ2VfbmV3X3Byb2Nlc3M6IGZ1bmN0aW9uIHBhZ2VfbmV3X3Byb2Nlc3ModGl0bGUpIHtcXG4gICAgICAgICQoXFxcImJvZHlcXFwiKS5jc3MoXFxcImN1cnNvclxcXCIsIFxcXCJ3YWl0XFxcIik7XFxuICAgICAgICB0aGlzLnBhcmVudC51dGlscy51cGRhdGVfc3RhdHVzKFxcXCJjYWxsYmFja1xcXCIsIF90cltcXFwibWxhYi5kdC5tYW5hZ2VtZW50LmpzLnVwZGF0ZV9zdGF0dXMuc3RvcmluZy5wYWdlXFxcIl0sIHRydWUpO1xcbiAgICAgICAgdmFyIHVybCA9IHRoaXMucGFyZW50LnVybHMucGFnZV9uZXcucmVwbGFjZShcXFwiX0lEX1xcXCIsIHRoaXMucGFyZW50LmFwcC5pZCk7XFxuICAgICAgICB1cmwgPSB1cmwucmVwbGFjZShcXFwiX1VJRF9cXFwiLCB0aGlzLnBhcmVudC51aWQpO1xcblxcbiAgICAgICAgLy9oZXJlIHdlIGhpZGUgdGhlIHRvb2xzIGZvciBjb21wb25lbnRzIHVudGlsIHRoZXkgc2VsZWN0IGEgY29udHJvbFxcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnBhcmVudC5xdGlwX3Rvb2xzICE9IFxcXCJ1bmRlZmluZWRcXFwiKSB7XFxuICAgICAgICAgICAgJCh0aGlzLnBhcmVudC5xdGlwX3Rvb2xzKS5xdGlwKCdoaWRlJyk7XFxuICAgICAgICAgICAgdGhpcy5wYXJlbnQucXRpcF90b29scyA9IHVuZGVmaW5lZDtcXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMucGFyZW50LmFwaS5wcm9wZXJ0aWVzX3Rvb2x0aXAgIT0gXFxcInVuZGVmaW5lZFxcXCIpIHtcXG4gICAgICAgICAgICAgICAgJCh0aGlzLnBhcmVudC5hcGkucHJvcGVydGllc190b29sdGlwKS5xdGlwKCdoaWRlJyk7XFxuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmFwaS5wcm9wZXJ0aWVzX3Rvb2x0aXAgPSB1bmRlZmluZWQ7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xcbiAgICAgICAgJC5wb3N0KHVybCwge30sIGZ1bmN0aW9uIChkYXRhKSB7XFxuICAgICAgICAgICAgaWYgKGRhdGEucmVzdWx0ID09IFxcXCJzdWNjZXNzXFxcIikge1xcbiAgICAgICAgICAgICAgICAvL3ByZXBhcmUgdmFyaWFibGVzXFxuICAgICAgICAgICAgICAgIHRoYXQucGFyZW50LmFwcC5wYWdlX25hbWVzLnB1c2goeyB0aXRsZTogdGl0bGUsIGZpbGVuYW1lOiAoXFxcIjAwMFxcXCIgKyBkYXRhLnBhZ2VfbnVtX3JlYWwpLnNsaWNlKC0zKSArIFxcXCIuaHRtbFxcXCIgfSk7XFxuICAgICAgICAgICAgICAgIHRoYXQucGFyZW50LmFwcC5jdXJyX3BhZ2V0aXRsZSA9IHRpdGxlO1xcbiAgICAgICAgICAgICAgICB0aGF0LnBhcmVudC5hcHAuY3Vycl9wYWdlX251bSA9IGRhdGEucGFnZV9udW1fcmVhbDtcXG5cXG4gICAgICAgICAgICAgICAgLy91cGRhdGUgcGFnZSBjb250ZW50IGFyZWEgYW5kIEhUTUwgZGlzcGxheSBvZiBtZXRhIGRhdGFcXG4gICAgICAgICAgICAgICAgJChcXFwiI1xcXCIgKyB0aGF0LnBhcmVudC5jb25maWdbXFxcImFwcFxcXCJdW1xcXCJjb250ZW50X2lkXFxcIl0pLmVtcHR5KCk7XFxuICAgICAgICAgICAgICAgICQoXFxcIiNtbGFiX3BhZ2VfY29udHJvbF90aXRsZVxcXCIpLnRleHQodGhhdC5wYXJlbnQuYXBwLmN1cnJfcGFnZXRpdGxlKTtcXG4gICAgICAgICAgICAgICAgdGhhdC5hcHBfdXBkYXRlX2d1aV9tZXRhZGF0YSgpO1xcblxcbiAgICAgICAgICAgICAgICAvL3VwZGF0ZSBzdGF1c1xcbiAgICAgICAgICAgICAgICB0aGF0LnBhcmVudC51dGlscy51cGRhdGVfc3RhdHVzKFxcXCJjb21wbGV0ZWRcXFwiKTtcXG4gICAgICAgICAgICAgICAgdGhhdC5wYXJlbnQuZmxhZ19kaXJ0eSA9IHRydWU7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgdGhhdC5wYXJlbnQudXRpbHMudXBkYXRlX3N0YXR1cyhcXFwidGVtcG9yYXJ5XFxcIiwgZGF0YS5tc2csIGZhbHNlKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgJChcXFwiYm9keVxcXCIpLmNzcyhcXFwiY3Vyc29yXFxcIiwgXFxcImRlZmF1bHRcXFwiKTtcXG4gICAgICAgICAgICB0aGF0LnBhcmVudC51dGlscy50aW1lcl9zdGFydCgpO1xcbiAgICAgICAgfSk7XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcclxcbiAgICAqIENyZWF0ZXMgYSBuZXcgZmlsZSBvbiB0aGUgc2VydmVyLCBkb2VzIE5PVCBvcGVuIGl0IGJ1dCBjYWxscyBhIGNhbGxiYWNrIGZ1bmN0aW9uIHdpdGggdGhlIGlkIG9mIHRoZSBwYWdlXFxyXFxuICAgICogdGl0bGUgc3RyaW5nLCB0aXRsZSBvZiBwYWdlXFxyXFxuICAgICogY2I6IGNhbGxiYWNrIGZ1bmN0aW9uXFxyXFxuICAgICovXFxuICAgIHBhZ2VfbmV3X2luX2JhY2tncm91bmQ6IGZ1bmN0aW9uIHBhZ2VfbmV3X2luX2JhY2tncm91bmQodGl0bGUsIGNiKSB7XFxuICAgICAgICAkKFxcXCJib2R5XFxcIikuY3NzKFxcXCJjdXJzb3JcXFwiLCBcXFwid2FpdFxcXCIpO1xcbiAgICAgICAgdGhpcy5wYXJlbnQudXRpbHMudXBkYXRlX3N0YXR1cyhcXFwiY2FsbGJhY2tcXFwiLCBfdHJbXFxcIm1sYWIuZHQubWFuYWdlbWVudC5qcy51cGRhdGVfc3RhdHVzLnN0b3JpbmcucGFnZVxcXCJdLCB0cnVlKTtcXG4gICAgICAgIHZhciB1cmwgPSB0aGlzLnBhcmVudC51cmxzLnBhZ2VfbmV3LnJlcGxhY2UoXFxcIl9JRF9cXFwiLCB0aGlzLnBhcmVudC5hcHAuaWQpO1xcbiAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoXFxcIl9VSURfXFxcIiwgdGhpcy5wYXJlbnQudWlkKSArIFxcXCIvMC9cXFwiICsgZW5jb2RlVVJJKHRpdGxlKTtcXG5cXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcXG4gICAgICAgICQucG9zdCh1cmwsIHt9LCBmdW5jdGlvbiAoZGF0YSkge1xcbiAgICAgICAgICAgIGlmIChkYXRhLnJlc3VsdCA9PSBcXFwic3VjY2Vzc1xcXCIpIHtcXG4gICAgICAgICAgICAgICAgLy91cGRhdGUgc3RhdXNcXG4gICAgICAgICAgICAgICAgdGhhdC5wYXJlbnQudXRpbHMudXBkYXRlX3N0YXR1cyhcXFwiY29tcGxldGVkXFxcIik7XFxuICAgICAgICAgICAgICAgIHRoYXQucGFyZW50LmZsYWdfZGlydHkgPSB0cnVlO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHRoYXQucGFyZW50LnV0aWxzLnVwZGF0ZV9zdGF0dXMoXFxcInRlbXBvcmFyeVxcXCIsIGRhdGEubXNnLCBmYWxzZSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGNiKGRhdGEpO1xcbiAgICAgICAgICAgICQoXFxcImJvZHlcXFwiKS5jc3MoXFxcImN1cnNvclxcXCIsIFxcXCJkZWZhdWx0XFxcIik7XFxuICAgICAgICAgICAgdGhhdC5wYXJlbnQudXRpbHMudGltZXJfc3RhcnQoKTtcXG4gICAgICAgIH0pO1xcbiAgICB9LFxcblxcbiAgICAvKipcXHJcXG4gICAgICogQ3JlYXRlcyBhIG5ldyBmaWxlIG9uIHRoZSBzZXJ2ZXIgYW5kIG9wZW5zIGl0XFxyXFxuICAgICAqL1xcbiAgICBwYWdlX2NvcHk6IGZ1bmN0aW9uIHBhZ2VfY29weShwYWdlX251bSkge1xcbiAgICAgICAgaWYgKHBhZ2VfbnVtID09IFxcXCIwXFxcIiB8fCBwYWdlX251bSA9PSBcXFwiaW5kZXhcXFwiKSB7XFxuICAgICAgICAgICAgYWxlcnQoX3RyW1xcXCJtbGFiLmR0Lm1hbmFnZW1lbnQuanMucGFnZV9jb3B5LmFsZXJ0Lm5vdC5jb3B5LmluZGV4LnBhZ2VcXFwiXSk7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcbiAgICAgICAgdGhhdCA9IHRoaXM7XFxuICAgICAgICB0aGlzLnBhZ2Vfc2F2ZShmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgdGhhdC5wYWdlX2NvcHlfcHJvY2VzcyhwYWdlX251bSk7XFxuICAgICAgICB9KTtcXG4gICAgfSxcXG5cXG4gICAgcGFnZV9jb3B5X3Byb2Nlc3M6IGZ1bmN0aW9uIHBhZ2VfY29weV9wcm9jZXNzKHBhZ2VfbnVtKSB7XFxuICAgICAgICB2YXIgdXJsID0gdGhpcy5wYXJlbnQudXJscy5wYWdlX2NvcHkucmVwbGFjZShcXFwiX0lEX1xcXCIsIHRoaXMucGFyZW50LmFwcC5pZCk7XFxuICAgICAgICB1cmwgPSB1cmwucmVwbGFjZShcXFwiX1BBR0VfTlVNX1xcXCIsIHBhZ2VfbnVtKTtcXG4gICAgICAgIHVybCA9IHVybC5yZXBsYWNlKFxcXCJfVUlEX1xcXCIsIHRoaXMucGFyZW50LnVpZCk7XFxuICAgICAgICB0aGlzLnBhcmVudC51dGlscy51cGRhdGVfc3RhdHVzKFxcXCJjYWxsYmFja1xcXCIsIF90cltcXFwibWxhYi5kdC5tYW5hZ2VtZW50LmpzLnVwZGF0ZV9zdGF0dXMuY29weWluZy5wYWdlXFxcIl0sIHRydWUpO1xcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xcblxcbiAgICAgICAgJC5nZXQodXJsLCBmdW5jdGlvbiAoZGF0YSkge1xcbiAgICAgICAgICAgIHRoYXQucGFyZW50LnV0aWxzLnVwZGF0ZV9zdGF0dXMoXFxcImNvbXBsZXRlZFxcXCIpO1xcbiAgICAgICAgICAgIGlmIChkYXRhLnJlc3VsdCA9PSBcXFwic3VjY2Vzc1xcXCIpIHtcXG4gICAgICAgICAgICAgICAgdGhhdC5wYXJlbnQuYXBwLmN1cnJfcGFnZXRpdGxlID0gZGF0YS5wYWdlX3RpdGxlO1xcbiAgICAgICAgICAgICAgICAkKFxcXCIjbWxhYl9wYWdlX2NvbnRyb2xfdGl0bGVcXFwiKS50ZXh0KGRhdGEucGFnZV90aXRsZSk7XFxuICAgICAgICAgICAgICAgIHRoYXQucGFyZW50LmFwcC5wYWdlX25hbWVzLnB1c2goeyB0aXRsZTogZGF0YS5wYWdlX3RpdGxlLCBmaWxlbmFtZTogKFxcXCIwMDBcXFwiICsgZGF0YS5wYWdlX251bV9yZWFsKS5zbGljZSgtMykgKyBcXFwiLmh0bWxcXFwiIH0pO1xcbiAgICAgICAgICAgICAgICB0aGF0LnJlZ3VsYXJfcGFnZV9wcm9jZXNzKGRhdGEuaHRtbCwgZGF0YS5wYWdlX251bV9yZWFsKTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICBhbGVydChkYXRhLm1zZyk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHRoYXQucGFyZW50LnV0aWxzLnRpbWVyX3N0YXJ0KCk7XFxuICAgICAgICB9KTtcXG4gICAgfSxcXG5cXG4gICAgcGFnZV9kZWxldGU6IGZ1bmN0aW9uIHBhZ2VfZGVsZXRlKCkge1xcbiAgICAgICAgaWYgKHRoaXMucGFyZW50LmFwcC5jdXJyX3BhZ2VfbnVtID09IDApIHtcXG4gICAgICAgICAgICBhbGVydChfdHJbXFxcIm1sYWIuZHQubWFuYWdlbWVudC5qcy5wYWdlX2NvcHkuYWxlcnQubm90LmRlbGV0ZS5pbmRleC5wYWdlXFxcIl0pO1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICghY29uZmlybShfdHJbXFxcIm1sYWIuZHQubWFuYWdlbWVudC5qcy5wYWdlX2NvcHkuYWxlcnQuc3VyZS5kZWxldGVcXFwiXSkpIHtcXG4gICAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0aGlzLnBhcmVudC51dGlscy50aW1lcl9zdG9wKCk7XFxuICAgICAgICB0aGlzLnBhcmVudC51dGlscy51cGRhdGVfc3RhdHVzKFxcXCJjYWxsYmFja1xcXCIsIF90cltcXFwibWxhYi5kdC5tYW5hZ2VtZW50LmpzLnVwZGF0ZV9zdGF0dXMuZGVsZXRpbmcucGFnZVxcXCJdLCB0cnVlKTtcXG5cXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcyxcXG4gICAgICAgICAgICB1cmwgPSB0aGlzLnBhcmVudC51cmxzLnBhZ2VfZGVsZXRlLnJlcGxhY2UoXFxcIl9JRF9cXFwiLCB0aGlzLnBhcmVudC5hcHAuaWQpO1xcbiAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoXFxcIl9QQUdFX05VTV9cXFwiLCB0aGlzLnBhcmVudC5hcHAuY3Vycl9wYWdlX251bSk7XFxuICAgICAgICB1cmwgPSB1cmwucmVwbGFjZShcXFwiX1VJRF9cXFwiLCB0aGlzLnBhcmVudC51aWQpO1xcblxcbiAgICAgICAgJC5nZXQodXJsLCBmdW5jdGlvbiAoZGF0YSkge1xcbiAgICAgICAgICAgIHRoYXQucGFyZW50LnV0aWxzLnVwZGF0ZV9zdGF0dXMoXFxcImNvbXBsZXRlZFxcXCIpO1xcbiAgICAgICAgICAgIGlmIChkYXRhLnJlc3VsdCA9PSBcXFwic3VjY2Vzc1xcXCIpIHtcXG4gICAgICAgICAgICAgICAgJChcXFwiI21sYWJfZXhpc3RpbmdfcGFnZXMgW2RhdGEtbWxhYi1wYWdlLW51bT0nXFxcIiArIGRhdGEucGFnZV9udW1fc2VudCkucmVtb3ZlKCk7XFxuXFxuICAgICAgICAgICAgICAgIHRoYXQucGFyZW50LmFwcC5wYWdlX25hbWVzLnNwbGljZSh0aGF0LnBhZ2VfZmlsZW51bTJpbmRleCh0aGF0LnBhcmVudC5hcHAuY3Vycl9wYWdlX251bSksIDEpO1xcbiAgICAgICAgICAgICAgICB0aGF0LnJlZ3VsYXJfcGFnZV9wcm9jZXNzKGRhdGEuaHRtbCwgZGF0YS5wYWdlX251bV9yZWFsKTtcXG4gICAgICAgICAgICAgICAgdGhhdC5hcHBfdXBkYXRlX2d1aV9tZXRhZGF0YSh0cnVlKTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICB0aGF0LnBhcmVudC51dGlscy51cGRhdGVfc3RhdHVzKFxcXCJ0ZW1wb3JhcnlcXFwiLCBkYXRhLm1zZywgZmFsc2UpO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICB0aGF0LnBhcmVudC51dGlscy50aW1lcl9zdGFydCgpO1xcbiAgICAgICAgfSk7XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcclxcbiAgICAgKiBTaW1wbGUgZnVuY3Rpb24gdG8gb3BlbiBhIG5ldyB3aW5kb3cgd2l0aCBjdXJyZW50IHBhZ2UgaW4gaXRcXHJcXG4gICAgICogR2l2ZW4gdGhhdCB3ZSB1c2UgYW4ganF1ZXJ5IG1vYmlsZSBmcmFtZXdvcmsgd2l0aCBhbiBpbmRleCBmaWxlIGFuZCBsb2FkaW5nIHBhZ2VzIGludG8gdGhlIGluZGV4IGZpbGUsXFxyXFxuICAgICAqIHdlIG5lZWQgdG8gcGFzcyB0aGUgcmVsZXZhbnQgZmlsZSBuYW1lIGFuZCBoYXZlIG1hdGNoaW5nIGNvZGUgaW4gdGhlIG1sYWIuanMgZmlsZSB0byBkZWFsIHdpdGggdGhpc1xcclxcbiAgICAgKiBAcGFyYW0ge3R5cGV9IGluZGV4XFxyXFxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XFxyXFxuICAgICAqL1xcbiAgICBwYWdlX3ByZXZpZXc6IGZ1bmN0aW9uIHBhZ2VfcHJldmlldygpIHtcXG4gICAgICAgIHRoYXQgPSB0aGlzO1xcbiAgICAgICAgdGhpcy5wYWdlX3NhdmUoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIHRoYXQucGFnZV9wcmV2aWV3X3Byb2Nlc3MoKTtcXG4gICAgICAgIH0pO1xcbiAgICB9LFxcblxcbiAgICBwYWdlX3ByZXZpZXdfcHJvY2VzczogZnVuY3Rpb24gcGFnZV9wcmV2aWV3X3Byb2Nlc3MoKSB7XFxuICAgICAgICB2YXIgdXJsID0gdGhpcy5wYXJlbnQudXJscy5hcHBfcHJldmlldy5yZXBsYWNlKFxcXCJfQVBQSURfXFxcIiwgdGhpcy5wYXJlbnQuYXBwLmlkKTtcXG4gICAgICAgIHZhciB3ID0gJCh3aW5kb3cpLndpZHRoKCkgKiAwLjI1O1xcbiAgICAgICAgdmFyIGggPSAkKHdpbmRvdykuaGVpZ2h0KCkgKiAwLjc1O1xcbiAgICAgICAgdmFyIHJlcyA9IHdpbmRvdy5vcGVuKHVybCwgJ3RhcmdldFdpbmRvdycsICd0b29sYmFyPW5vLGxvY2F0aW9uPW5vLHN0YXR1cz1ubyxtZW51YmFyPW5vLHNjcm9sbGJhcnM9bm8scmVzaXphYmxlPW5vLHdpZHRoPScgKyB3ICsgJyxoZWlnaHQ9JyArIGggKyAnLGxlZnQ9JyArIHcpO1xcbiAgICAgICAgaWYgKHJlcyA9PSB1bmRlZmluZWQpIHtcXG4gICAgICAgICAgICBhbGVydChfdHJbXFxcIm1sYWIuZHQubWFuYWdlbWVudC5qcy5wYWdlX3ByZXZpZXdfcHJvY2Vzcy5hbGVydC5jYW5ub3Qub3Blbi5uZXcud2luZG93XFxcIl0pO1xcbiAgICAgICAgfVxcbiAgICB9LFxcblxcbiAgICBzb2NrZXQ6IHtcXG5cXG4gICAgICAgIGNvbm5lY3Rpb246IG51bGwsXFxuXFxuICAgICAgICBzZXR1cDogZnVuY3Rpb24gc2V0dXAoY2FsbGJhY2ssIHBhcmFtKSB7XFxuICAgICAgICAgICAgLy9maXJzdCBjbG9zZSBhbnkgZXhpc3RpbmcgY29ubmVjdGlvbnNcXG4gICAgICAgICAgICBpZiAobWxhYi5kdC5tYW5hZ2VtZW50LnNvY2tldC5jb25uZWN0aW9uKSB7XFxuICAgICAgICAgICAgICAgIG1sYWIuZHQubWFuYWdlbWVudC5zb2NrZXQuY29ubmVjdGlvbi5jbG9zZSgpO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAvLyBjb25uZWN0IHRvIHRoZSB3ZWJzb2NrZXQgc2VydmVyLCB0aGlzIHJldHVybnMgZGF0YSBmcm9tIHNlcnZlciBjYWxsYmFjayBmdW5jdGlvbnMgdXNlZCB3aGVuIGNvbm5lY3RuZyB0byBtYXJrZXQgb3IgY29tcGlsZXIgc2VydmljZXNcXG4gICAgICAgICAgICBtbGFiLmR0Lm1hbmFnZW1lbnQuc29ja2V0LmNvbm5lY3Rpb24gPSBuZXcgV2ViU29ja2V0KG1sYWIuZHQuY29uZmlnLndzX3NvY2tldC51cmxfY2xpZW50ICsgbWxhYi5kdC5jb25maWcud3Nfc29ja2V0LnBhdGhfY2xpZW50ICsgJy8nICsgbWxhYi5kdC51aWQpO1xcblxcbiAgICAgICAgICAgIG1sYWIuZHQubWFuYWdlbWVudC5zb2NrZXQuY29ubmVjdGlvbi5vbmVycm9yID0gZnVuY3Rpb24gKGV2dCkge1xcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcXFwiVGhlIGZvbGxvd2luZyBlcnJvciBvY2N1cnJlZDogXFxcIiArIGV2dC5kYXRhKTtcXG4gICAgICAgICAgICAgICAgbWxhYi5kdC5tYW5hZ2VtZW50LnNvY2tldC5jb25uZWN0aW9uID0gbnVsbDtcXG4gICAgICAgICAgICAgICAgYWxlcnQoX3RyW1xcXCJtbGFiLmR0Lm1hbmFnZW1lbnQuanMud2Vic29ja2V0LmVycm9yLmNvbm5lY3RcXFwiXSk7XFxuICAgICAgICAgICAgfTtcXG5cXG4gICAgICAgICAgICBtbGFiLmR0Lm1hbmFnZW1lbnQuc29ja2V0LmNvbm5lY3Rpb24ub25vcGVuID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcXFwib25vcGVuXFxcIik7XFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHBhcmFtKTtcXG4gICAgICAgICAgICB9O1xcblxcbiAgICAgICAgICAgIG1sYWIuZHQubWFuYWdlbWVudC5zb2NrZXQuY29ubmVjdGlvbi5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcXG4gICAgICAgICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XFxuICAgICAgICAgICAgICAgIHN3aXRjaCAoZGF0YS5zdGF0dXMpIHtcXG5cXG4gICAgICAgICAgICAgICAgICAgIC8vMTogV2hlbiBjbGljayBvbiBtZW51LCB0aGVuIGl0IHNob3VsZCBpbmRpY2F0ZSB0aGF0IHRoZSBhcHAgaXMgcmVxdWVzdGVkICggbWxhYi5kdC5tYW5hZ2VtZW50LmpzICAtICBjb21waWxlcjogeyAgZ2V0X2FwcCA6KVxcbiAgICAgICAgICAgICAgICAgICAgLy8yOiBXaGVuIHRoZSByZXF1ZXN0IGhhcyBiZWVuIHByb2Nlc3NlZCBieSB0aGUgUEhQIGJhY2tlbmQgaXQgc2hvdWxkIGluZGljYXRlIG9uZSBzdGFnZSBoYXMgcGFzc2VkICg/IC0gIGNhc2UgXFxcImNvbm5lY3RlZFxcXCI/KVxcbiAgICAgICAgICAgICAgICAgICAgLy8zOiBUaGVuIGl0IHNob3VsZCBpbmRpY2F0ZSB0aGF0IHByZWNvbXBpbGF0aW9uIGhhcyB0YWtlbiBwbGFjZSAobWF5IG5vdCBiZSByZXF1aXJlZCwgc28gYSBudW1lcmljIGlzIG5vdCBnb29kKSAoY2FzZSBcXFwicHJlY29tcGlsYXRpb25cXFwiKVxcbiAgICAgICAgICAgICAgICAgICAgLy80OiBjcmVhdGVBcHAgaXMgY2FsbGVkLCB0aGlzIGNyZWF0ZXMgdGhlIGVtcHR5IGFwcCAoY2FzZSBcXFwiY3JlYXRpbmdcXFwiLi4uLmNhc2UgXFxcImNyZWF0ZWRcXFwiPylcXG4gICAgICAgICAgICAgICAgICAgIC8vNTogVGhlbiBmaWxlcyBhcmUgdXBsb2FkZWQgKGxlbmd0aHkpIChjYXNlIFxcXCJ1cGxvYWRpbmdcXFwiPyAoaG9wcGUgdmlkZXIgcMOlIGNhc2UgXFxcInZlcmlmeWluZ1xcXCIgb2cgIGNhc2UgXFxcInZlcmlmaWNhdGlvbl9va1xcXCItIHRhciB0aWQtLS0tKVxcbiAgICAgICAgICAgICAgICAgICAgLy82OiBBcHAgdXBsb2FkIGZpbmlzaGVkLCBjb21waWxhdGlvbiBzdGFydHMgKGNhc2UgXFxcImNvbXBpbGluZ1xcXCIuLi5jYXNlIFxcXCJjb21waWxhdGlvbl9va1xcXCIpXFxuICAgICAgICAgICAgICAgICAgICAvLzc6IEFwcCBpcyBiZWluZyAoY2FzZSBcXFwicmVjZWl2aW5nXFxcIjopXFxuICAgICAgICAgICAgICAgICAgICAvLzg6IEFwcCBpcyByZWFkeSAoY2FzZSBcXFwicmVhZHlcXFwiKVxcblxcbiAgICAgICAgICAgICAgICAgICAgLy9TZXR0ZSBlbiBncsOlIHZlcnNqb24gYXYgaWNvbmV0IG9tIHNpc3RlIHZlcnNqb24gZXIga29waWxlcnQ/XFxuICAgICAgICAgICAgICAgICAgICAvLyBrYW4gQW5kb2lkIG9nIGlPUyBrb3BpbGVyZXMgcMOlIHNhbW1lIHRpZD9cXG4gICAgICAgICAgICAgICAgICAgIC8vIGh2YSBvbSBtYW4gbGFncmVyIGVuIG55IHZlcnNqb24gbWVucyBrb21waWxlclxcblxcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcXFwiY29ubmVjdGVkXFxcIjpcXG4gICAgICAgICAgICAgICAgICAgICAgICAkKFxcXCIjbWxhYl9wcm9ncmVzc2JhclxcXCIpLnZhbCg1KTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAkKFxcXCIjbWxhYl9zdGF0dXNiYXJfY29tcGlsZXJcXFwiKS50ZXh0KF90cltcXFwibWxhYl9lZGl0b3IuaW5pdC5qcy5jb21waWxpbmcuY29ubmVjdGVkXFxcIl0pO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcXFwiY3JlYXRpbmdcXFwiOlxcbiAgICAgICAgICAgICAgICAgICAgICAgICQoXFxcIiNtbGFiX3Byb2dyZXNzYmFyXFxcIikudmFsKDEwKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAkKFxcXCIjbWxhYl9zdGF0dXNiYXJfY29tcGlsZXJcXFwiKS50ZXh0KF90cltcXFwibWxhYl9lZGl0b3IuaW5pdC5qcy5jb21waWxpbmcuY3JlYXRpbmdcXFwiXSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jcmVhdGVBcHAgaXMgY2FsbGVkLCB0aGlzIGNyZWF0ZXMgdGhlIGVtcHR5IGFwcFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcXFwiY3JlYXRlZFxcXCI6XFxuICAgICAgICAgICAgICAgICAgICAgICAgJChcXFwiI21sYWJfcHJvZ3Jlc3NiYXJcXFwiKS52YWwoMTUpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICQoXFxcIiNtbGFiX3N0YXR1c2Jhcl9jb21waWxlclxcXCIpLnRleHQoX3RyW1xcXCJtbGFiX2VkaXRvci5pbml0LmpzLmNvbXBpbGluZy5jcmVhdGVkXFxcIl0pO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcXFwicHJlY29tcGlsYXRpb25cXFwiOlxcbiAgICAgICAgICAgICAgICAgICAgICAgICQoXFxcIiNtbGFiX3Byb2dyZXNzYmFyXFxcIikudmFsKDIwKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAkKFxcXCIjbWxhYl9zdGF0dXNiYXJfY29tcGlsZXJcXFwiKS50ZXh0KF90cltcXFwibWxhYl9lZGl0b3IuaW5pdC5qcy5jb21waWxpbmcucHJlY29tcGlsYXRpb25cXFwiXSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICAgICAgICAgICAgICBjYXNlIFxcXCJ1cGxvYWRpbmdcXFwiOlxcbiAgICAgICAgICAgICAgICAgICAgICAgICQoXFxcIiNtbGFiX3Byb2dyZXNzYmFyXFxcIikudmFsKDI1KTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAkKFxcXCIjbWxhYl9zdGF0dXNiYXJfY29tcGlsZXJcXFwiKS50ZXh0KF90cltcXFwibWxhYl9lZGl0b3IuaW5pdC5qcy5jb21waWxpbmcudXBsb2FkaW5nXFxcIl0pO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcXFwidmVyaWZ5aW5nXFxcIjpcXG4gICAgICAgICAgICAgICAgICAgICAgICAkKFxcXCIjbWxhYl9wcm9ncmVzc2JhclxcXCIpLnZhbCgzMCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgJChcXFwiI21sYWJfc3RhdHVzYmFyX2NvbXBpbGVyXFxcIikudGV4dChfdHJbXFxcIm1sYWJfZWRpdG9yLmluaXQuanMuY29tcGlsaW5nLnZlcmlmeWluZ1xcXCJdKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXFxcInZlcmlmaWNhdGlvbl9va1xcXCI6XFxuICAgICAgICAgICAgICAgICAgICAgICAgJChcXFwiI21sYWJfcHJvZ3Jlc3NiYXJcXFwiKS52YWwoMzUpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICQoXFxcIiNtbGFiX3N0YXR1c2Jhcl9jb21waWxlclxcXCIpLnRleHQoX3RyW1xcXCJtbGFiX2VkaXRvci5pbml0LmpzLmNvbXBpbGluZy52ZXJpZmljYXRpb25fb2tcXFwiXSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICAgICAgICAgICAgICBjYXNlIFxcXCJjb21waWxpbmdcXFwiOlxcbiAgICAgICAgICAgICAgICAgICAgICAgICQoXFxcIiNtbGFiX3Byb2dyZXNzYmFyXFxcIikudmFsKDQwKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAkKFxcXCIjbWxhYl9zdGF0dXNiYXJfY29tcGlsZXJcXFwiKS50ZXh0KF90cltcXFwibWxhYl9lZGl0b3IuaW5pdC5qcy5jb21waWxpbmcuY29tcGlsaW5nXFxcIl0pO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcXFwiY29tcGlsYXRpb25fb2tcXFwiOlxcbiAgICAgICAgICAgICAgICAgICAgICAgICQoXFxcIiNtbGFiX3Byb2dyZXNzYmFyXFxcIikudmFsKDgwKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAkKFxcXCIjbWxhYl9zdGF0dXNiYXJfY29tcGlsZXJcXFwiKS50ZXh0KF90cltcXFwibWxhYl9lZGl0b3IuaW5pdC5qcy5jb21waWxpbmcuY29tcGlsYXRpb25fb2tcXFwiXSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICAgICAgICAgICAgICBjYXNlIFxcXCJmYWlsZWRcXFwiOlxcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcXFwicHJlY29tcGlsYXRpb25fZmFpbGVkXFxcIjpcXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXFxcImNvbXBpbGF0aW9uX2ZhaWxlZFxcXCI6XFxuICAgICAgICAgICAgICAgICAgICBjYXNlIFxcXCJ2ZXJpZmljYXRpb25fZmFpbGVkXFxcIjpcXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXFxcImNyZWF0ZV9mYWlsZWRcXFwiOlxcbiAgICAgICAgICAgICAgICAgICAgICAgICQoXFxcIiNtbGFiX3N0YXR1c2Jhcl9jb21waWxlclxcXCIpLnRleHQoXFxcIlxcXCIpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICQoXFxcIiNtbGFiX2Rvd25sb2FkX1xcXCIgKyBkYXRhLnBsYXRmb3JtICsgXFxcIl9pY29uXFxcIikucmVtb3ZlQ2xhc3MoJ21sYWJfZG93bmxvYWRfJyArIGRhdGEucGxhdGZvcm0gKyAnX2ljb25fZ3JleScpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICQoXFxcIiNtbGFiX2Rvd25sb2FkX1xcXCIgKyBkYXRhLnBsYXRmb3JtICsgXFxcIl9pY29uXFxcIikuZmluZChcXFwiaW1nXFxcIikuaGlkZSgpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICQoXFxcIiNtbGFiX3Byb2dyZXNzYmFyXFxcIikuaGlkZSgpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIG1sYWIuZHQudXRpbHMudXBkYXRlX3N0YXR1cyhcXFwidGVtcG9yYXJ5XFxcIiwgZGF0YS5mYWlsX3RleHQsIGZhbHNlKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBtbGFiLmR0Lm1hbmFnZW1lbnQuc29ja2V0LmNvbm5lY3Rpb24uY2xvc2UoKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBtbGFiLmR0Lm1hbmFnZW1lbnQuc29ja2V0LmNvbm5lY3Rpb24gPSBudWxsO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcXFwicmVjZWl2aW5nXFxcIjpcXG4gICAgICAgICAgICAgICAgICAgICAgICAkKFxcXCIjbWxhYl9wcm9ncmVzc2JhclxcXCIpLnZhbCg5MCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgJChcXFwiI21sYWJfc3RhdHVzYmFyX2NvbXBpbGVyXFxcIikudGV4dChfdHJbXFxcIm1sYWJfZWRpdG9yLmluaXQuanMuY29tcGlsaW5nLnJlY2VpdmluZ1xcXCJdKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXFxcInJlYWR5XFxcIjpcXG4gICAgICAgICAgICAgICAgICAgICAgICAkKFxcXCIjbWxhYl9wcm9ncmVzc2JhclxcXCIpLnZhbCgxMDApO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICQoXFxcIiNtbGFiX3N0YXR1c2Jhcl9jb21waWxlclxcXCIpLnRleHQoXFxcIlxcXCIpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICQoXFxcIiNtbGFiX2Rvd25sb2FkX1xcXCIgKyBkYXRhLnBsYXRmb3JtICsgXFxcIl9pY29uXFxcIikucmVtb3ZlQ2xhc3MoJ21sYWJfZG93bmxvYWRfJyArIGRhdGEucGxhdGZvcm0gKyAnX2ljb25fZ3JleScpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICQoXFxcIiNtbGFiX2Rvd25sb2FkX1xcXCIgKyBkYXRhLnBsYXRmb3JtICsgXFxcIl9pY29uXFxcIikuZmluZChcXFwiaW1nXFxcIikuaGlkZSgpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICQoXFxcIiNtbGFiX3Byb2dyZXNzYmFyXFxcIikuaGlkZSgpO1xcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vaW5zZXJ0aW5nIHRoZSBRUiBjb2RlIGFuZCB1cmwgdG8gdGhlIGNvbXBpbGVkIGFwcCBpbiB0aGUgbWVudVxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YS5maWxlbmFtZSAhPSBcXFwidW5kZWZpbmVkXFxcIiAmJiBkYXRhLmZpbGVuYW1lICE9IG51bGwgJiYgZGF0YS5maWxlbmFtZSAhPSBcXFwiXFxcIikge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtbGFiLmR0LmFwcC5jb21waWxlZF9maWxlc1tkYXRhLnBsYXRmb3JtXSA9IGRhdGEuZmlsZW5hbWU7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXFxcImJhc2VcXFwiKVswXS5ocmVmLnNsaWNlKDAsIC0xKSArIFxcXCJfY29tcGlsZWQvXFxcIiArIGRhdGEuZmlsZW5hbWU7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoXFxcIiNtbGFiX2Rvd25sb2FkX3FyX2xpbmtfXFxcIiArIGRhdGEucGxhdGZvcm0pLmVtcHR5KCkucXJjb2RlKHsgdGV4dDogdGV4dCwgc2l6ZTogMTUwLCBiYWNrZ3JvdW5kOiBcXFwiI2ZmZmZmZlxcXCIsIGZvcmVncm91bmQ6IFxcXCIjMDAwMDAwXFxcIiwgcmVuZGVyOiBcXFwidGFibGVcXFwiIH0pO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKFxcXCIjbWxhYl9kb3dubG9hZF9saW5rX1xcXCIgKyBkYXRhLnBsYXRmb3JtKS5odG1sKFxcXCI8Yj5VUkw8L2I+OjwvYnI+XFxcIiArIHRleHQpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtbGFiLmR0LnV0aWxzLnVwZGF0ZV9zdGF0dXMoXFxcInRlbXBvcmFyeVxcXCIsIF90cltcXFwibWxhYl9lZGl0b3IuaW5pdC5qcy5jb21waWxpbmcucmVhZHlcXFwiXSwgZmFsc2UpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1sYWIuZHQudXRpbHMudXBkYXRlX3N0YXR1cyhcXFwidGVtcG9yYXJ5XFxcIiwgX3RyW1xcXCJtbGFiX2VkaXRvci5pbml0LmpzLmNvbXBpbGluZy5mYWlsZWRcXFwiXSwgZmFsc2UpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICBtbGFiLmR0Lm1hbmFnZW1lbnQuc29ja2V0LmNvbm5lY3Rpb24uY2xvc2UoKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBtbGFiLmR0Lm1hbmFnZW1lbnQuc29ja2V0LmNvbm5lY3Rpb24gPSBudWxsO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfTtcXG4gICAgICAgIH0gLy9lbmQgZnVuY3Rpb24gc2V0dXBcXG4gICAgfSwgLy9lbmQgc29ja2V0IG9iamVjdFxcblxcbiAgICBtYXJrZXQ6IHtcXG5cXG4gICAgICAgIGxvZ2luOiBmdW5jdGlvbiBsb2dpbigpIHt9LFxcblxcbiAgICAgICAgc3VibWl0X2FwcF9kZXRhaWxzOiBmdW5jdGlvbiBzdWJtaXRfYXBwX2RldGFpbHMoKSB7fSxcXG5cXG4gICAgICAgIHVwbG9hZF9hcHBfZmlsZTogZnVuY3Rpb24gdXBsb2FkX2FwcF9maWxlKCkge30sXFxuXFxuICAgICAgICBwdWJsaXNoX2FwcDogZnVuY3Rpb24gcHVibGlzaF9hcHAoKSB7fSxcXG5cXG4gICAgICAgIHVucHVibGlzaF9hcHA6IGZ1bmN0aW9uIHVucHVibGlzaF9hcHAoKSB7fVxcblxcbiAgICB9LFxcblxcbiAgICAvL3RoZXNlIGFyZSB0aGUgY29tcGlsZXIgZnVuY3Rpb25zIHdlIGNhbGwuIEF0IHRoZSBmcm9udCBlbmQgd2Ugb25seSB1c2UgdHdvIGZ1bmN0aW9ucywgaW5mbyBhYm91dCBjdXJyZW50IGFwcCBhbmQgZ2V0X2FwcFxcbiAgICAvL2luIHRoZSBiYWNrZ3JvdW5kIChpLmUuIG9uIHRoZSBQSFAgc2VydmVyKSBnZXRfYXBwIGNhbGxzIGxvdHMgb2YgZGlmZmVyZW50IGZ1bmN0aW9ucyB0byBhY3R1YWxseSBwcmVwYXJlIGFwcCwgdXBsb2FkIGZpbGVzLCBjb21waWxlIGFuZCByZXRyaWV2ZSBhcHBcXG4gICAgY29tcGlsZXI6IHtcXG5cXG4gICAgICAgIGdldF9hcHBfc3RhdHVzOiBmdW5jdGlvbiBnZXRfYXBwX3N0YXR1cygpIHtcXG4gICAgICAgICAgICB2YXIgdXJsID0gbWxhYi5kdC51cmxzLmNtcF9nZXRfYXBwX3N0YXR1cy5yZXBsYWNlKFxcXCJfV0lORE9XX1VJRF9cXFwiLCBtbGFiLmR0LnVpZCk7XFxuICAgICAgICAgICAgdmFyIGkgPSBwcm9tcHQoX3RyW1xcXCJtbGFiLmR0Lm1hbmFnZW1lbnQuanMuY29tcGlsZXIuZ2V0X2FwcF9zdGF0dXMucHJvbXB0LmRiLmlkXFxcIl0pO1xcbiAgICAgICAgICAgIHVybCA9IHVybC5yZXBsYWNlKFxcXCIvX0lEX1xcXCIsIGkgIT0gbnVsbCAmJiBpICE9IFxcXCJcXFwiID8gXFxcIi9cXFwiICsgaSA6IFxcXCJcXFwiKTtcXG4gICAgICAgICAgICB2YXIgdiA9IHByb21wdChfdHJbXFxcIm1sYWIuZHQubWFuYWdlbWVudC5qcy5jb21waWxlci5nZXRfYXBwX3N0YXR1cy5wcm9tcHQudmVyc2lvblxcXCJdKTtcXG4gICAgICAgICAgICB1cmwgPSB1cmwucmVwbGFjZShcXFwiL19WRVJTSU9OX1xcXCIsIHYgIT0gbnVsbCAmJiB2ICE9IFxcXCJcXFwiID8gXFxcIi9cXFwiICsgdiA6IFxcXCJcXFwiKTtcXG4gICAgICAgICAgICB2YXIgcCA9IHByb21wdChfdHJbXFxcIm1sYWIuZHQubWFuYWdlbWVudC5qcy5jb21waWxlci5nZXRfYXBwX3N0YXR1cy5wcm9tcHQucGxhdGZvcm1cXFwiXSk7XFxuICAgICAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoXFxcIi9fUExBVEZPUk1fXFxcIiwgcCAhPSBudWxsICYmIHAgIT0gXFxcIlxcXCIgPyBcXFwiL1xcXCIgKyBwIDogXFxcIlxcXCIpO1xcblxcbiAgICAgICAgICAgICQoZG9jdW1lbnQpLmFqYXhFcnJvcihmdW5jdGlvbiAoZXZlbnQsIGpxWEhSLCBhamF4U2V0dGluZ3MpIHtcXG4gICAgICAgICAgICAgICAgaWYgKGpxWEhSLnN0YXR1cyA9PT0gMCkge1xcbiAgICAgICAgICAgICAgICAgICAgYWxlcnQoJ05vdCBjb25uZWN0LlxcXFxuIFZlcmlmeSBOZXR3b3JrLicpO1xcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGpxWEhSLnN0YXR1cyA9PSA0MDQpIHtcXG4gICAgICAgICAgICAgICAgICAgIGFsZXJ0KCdSZXF1ZXN0ZWQgcGFnZSBub3QgZm91bmQuIFs0MDRdJyk7XFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoanFYSFIuc3RhdHVzID09IDUwMCkge1xcbiAgICAgICAgICAgICAgICAgICAgYWxlcnQoJ0ludGVybmFsIFNlcnZlciBFcnJvciBbNTAwXS4nKTtcXG4gICAgICAgICAgICAgICAgICAgIC8qICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXhjZXB0aW9uID09PSAncGFyc2VyZXJyb3InKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsZXJ0KCdSZXF1ZXN0ZWQgSlNPTiBwYXJzZSBmYWlsZWQuJyk7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChleGNlcHRpb24gPT09ICd0aW1lb3V0Jykge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGVydCgnVGltZSBvdXQgZXJyb3IuJyk7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChleGNlcHRpb24gPT09ICdhYm9ydCcpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxlcnQoJ0FqYXggcmVxdWVzdCBhYm9ydGVkLicpOyovXFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICBhbGVydCgnVW5jYXVnaHQgRXJyb3IuXFxcXG4nICsganFYSFIucmVzcG9uc2VUZXh0KTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBtbGFiLmR0LnV0aWxzLnVwZGF0ZV9zdGF0dXMoXFxcInRlbXBvcmFyeVxcXCIsIGpxWEhSLnJlc3BvbnNlVGV4dCwgZmFsc2UpO1xcbiAgICAgICAgICAgIH0pO1xcblxcbiAgICAgICAgICAgICQuYWpheCh7XFxuICAgICAgICAgICAgICAgIHVybDogdXJsLFxcbiAgICAgICAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiBzdWNjZXNzKGpzb24pIHtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChqc29uLnJlc3VsdCA9PSBcXFwic3VjY2Vzc1xcXCIpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcXFwiU3RhdHVzIHJldHVybmVkOiBcXFwiKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhqc29uLmFwcF9zdGF0dXMpO1xcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGVydChfdHJbXFxcIm1sYWIuZHQubWFuYWdlbWVudC5qcy5jb21waWxlci5nZXRfYXBwX3N0YXR1cy5hbGVydC51bmFibGUuZ2V0LmFwcC5zdGF0dXNcXFwiXSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbWxhYi5kdC51dGlscy51cGRhdGVfc3RhdHVzKFxcXCJ0ZW1wb3JhcnlcXFwiLCBcXFwiXFxcIiwgZmFsc2UpO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9LFxcblxcbiAgICAgICAgLyoqXFxyXFxuICAgICAgICAgKiBkb3dubG9hZHMgYSBjb21wbHRlIGNvcHkgb2YgcHJlcGFyZWQgKGkuZS4gZmluaXNoZWQgcHJlY29tcGlsZSBwcm9jZXNzKSBzb3VyY2UgY29kZSwgc28gTWxhYiBpc2UganVzdCB1c2VkIGFzIGFuIGVkaXRvclxcclxcbiAgICAgICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cXHJcXG4gICAgICAgICAqL1xcbiAgICAgICAgZ2V0X2FwcF9zb3VyY2U6IGZ1bmN0aW9uIGdldF9hcHBfc291cmNlKCkge1xcbiAgICAgICAgICAgIHZhciB1cmwgPSBtbGFiLmR0LnVybHMuY21wX2dldF9hcHBfc291cmNlLnJlcGxhY2UoXFxcIl9XSU5ET1dfVUlEX1xcXCIsIG1sYWIuZHQudWlkKTtcXG4gICAgICAgICAgICB1cmwgPSB1cmwucmVwbGFjZShcXFwiX0lEX1xcXCIsIG1sYWIuZHQuYXBwLmlkKTtcXG4gICAgICAgICAgICB1cmwgPSB1cmwucmVwbGFjZShcXFwiX1ZFUlNJT05fXFxcIiwgbWxhYi5kdC5hcHAuYWN0aXZlX3ZlcnNpb24pO1xcblxcbiAgICAgICAgICAgICQoZG9jdW1lbnQpLmFqYXhFcnJvcihmdW5jdGlvbiAoZXZlbnQsIGpxWEhSLCBhamF4U2V0dGluZ3MpIHtcXG4gICAgICAgICAgICAgICAgaWYgKGpxWEhSLnN0YXR1cyA9PT0gMCkge1xcbiAgICAgICAgICAgICAgICAgICAgYWxlcnQoJ05vdCBjb25uZWN0LlxcXFxuIFZlcmlmeSBOZXR3b3JrLicpO1xcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGpxWEhSLnN0YXR1cyA9PSA0MDQpIHtcXG4gICAgICAgICAgICAgICAgICAgIGFsZXJ0KCdSZXF1ZXN0ZWQgcGFnZSBub3QgZm91bmQuIFs0MDRdJyk7XFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoanFYSFIuc3RhdHVzID09IDUwMCkge1xcbiAgICAgICAgICAgICAgICAgICAgYWxlcnQoJ0ludGVybmFsIFNlcnZlciBFcnJvciBbNTAwXS4nKTtcXG4gICAgICAgICAgICAgICAgICAgIC8qICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXhjZXB0aW9uID09PSAncGFyc2VyZXJyb3InKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsZXJ0KCdSZXF1ZXN0ZWQgSlNPTiBwYXJzZSBmYWlsZWQuJyk7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChleGNlcHRpb24gPT09ICd0aW1lb3V0Jykge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGVydCgnVGltZSBvdXQgZXJyb3IuJyk7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChleGNlcHRpb24gPT09ICdhYm9ydCcpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxlcnQoJ0FqYXggcmVxdWVzdCBhYm9ydGVkLicpOyovXFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICBhbGVydCgnVW5jYXVnaHQgRXJyb3IuXFxcXG4nICsganFYSFIucmVzcG9uc2VUZXh0KTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBtbGFiLmR0LnV0aWxzLnVwZGF0ZV9zdGF0dXMoXFxcInRlbXBvcmFyeVxcXCIsIGpxWEhSLnJlc3BvbnNlVGV4dCwgZmFsc2UpO1xcbiAgICAgICAgICAgIH0pO1xcblxcbiAgICAgICAgICAgICQuYWpheCh7XFxuICAgICAgICAgICAgICAgIHVybDogdXJsLFxcbiAgICAgICAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiBzdWNjZXNzKGpzb24pIHtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChqc29uLnJlc3VsdCA9PSBcXFwic3VjY2Vzc1xcXCIpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaWZyYW1lID0gJChcXFwiPGlmcmFtZS8+XFxcIikuYXR0cih7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyYzoganNvbi51cmwsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBcXFwidmlzaWJpbGl0eTpoaWRkZW47ZGlzcGxheTpub25lXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLmFwcGVuZFRvKFxcXCJib2R5XFxcIik7XFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsZXJ0KF90cltcXFwibWxhYi5kdC5tYW5hZ2VtZW50LmpzLmNvbXBpbGVyLmdldF9hcHBfc3RhdHVzLmFsZXJ0LnVuYWJsZS5nZXQuYXBwLnN0YXR1c1xcXCJdKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBtbGFiLmR0LnV0aWxzLnVwZGF0ZV9zdGF0dXMoXFxcInRlbXBvcmFyeVxcXCIsIFxcXCJcXFwiLCBmYWxzZSk7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH0sXFxuXFxuICAgICAgICAvKipcXHJcXG4gICAgICAgICAqIFxcclxcbiAgICAgICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cXHJcXG4gICAgICAgICAqL1xcbiAgICAgICAgdXBsb2FkX3dlYnNpdGU6IGZ1bmN0aW9uIHVwbG9hZF93ZWJzaXRlKCkge1xcbiAgICAgICAgICAgIHZhciB1cmwgPSBtbGFiLmR0LnVybHMuY21wX3VwbG9hZF93ZWJzaXRlLnJlcGxhY2UoXFxcIl9XSU5ET1dfVUlEX1xcXCIsIG1sYWIuZHQudWlkKTtcXG4gICAgICAgICAgICB1cmwgPSB1cmwucmVwbGFjZShcXFwiX0lEX1xcXCIsIG1sYWIuZHQuYXBwLmlkKTtcXG4gICAgICAgICAgICB1cmwgPSB1cmwucmVwbGFjZShcXFwiX1ZFUlNJT05fXFxcIiwgbWxhYi5kdC5hcHAuYWN0aXZlX3ZlcnNpb24pO1xcblxcbiAgICAgICAgICAgICQoZG9jdW1lbnQpLmFqYXhFcnJvcihmdW5jdGlvbiAoZXZlbnQsIGpxWEhSLCBhamF4U2V0dGluZ3MpIHtcXG4gICAgICAgICAgICAgICAgaWYgKGpxWEhSLnN0YXR1cyA9PT0gMCkge1xcbiAgICAgICAgICAgICAgICAgICAgYWxlcnQoJ05vdCBjb25uZWN0LlxcXFxuIFZlcmlmeSBOZXR3b3JrLicpO1xcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGpxWEhSLnN0YXR1cyA9PSA0MDQpIHtcXG4gICAgICAgICAgICAgICAgICAgIGFsZXJ0KCdSZXF1ZXN0ZWQgcGFnZSBub3QgZm91bmQuIFs0MDRdJyk7XFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoanFYSFIuc3RhdHVzID09IDUwMCkge1xcbiAgICAgICAgICAgICAgICAgICAgYWxlcnQoJ0ludGVybmFsIFNlcnZlciBFcnJvciBbNTAwXS4nKTtcXG4gICAgICAgICAgICAgICAgICAgIC8qICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXhjZXB0aW9uID09PSAncGFyc2VyZXJyb3InKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsZXJ0KCdSZXF1ZXN0ZWQgSlNPTiBwYXJzZSBmYWlsZWQuJyk7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChleGNlcHRpb24gPT09ICd0aW1lb3V0Jykge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGVydCgnVGltZSBvdXQgZXJyb3IuJyk7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChleGNlcHRpb24gPT09ICdhYm9ydCcpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxlcnQoJ0FqYXggcmVxdWVzdCBhYm9ydGVkLicpOyovXFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICBhbGVydCgnVW5jYXVnaHQgRXJyb3IuXFxcXG4nICsganFYSFIucmVzcG9uc2VUZXh0KTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBtbGFiLmR0LnV0aWxzLnVwZGF0ZV9zdGF0dXMoXFxcInRlbXBvcmFyeVxcXCIsIGpxWEhSLnJlc3BvbnNlVGV4dCwgZmFsc2UpO1xcbiAgICAgICAgICAgIH0pO1xcblxcbiAgICAgICAgICAgICQuYWpheCh7XFxuICAgICAgICAgICAgICAgIHVybDogdXJsLFxcbiAgICAgICAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiBzdWNjZXNzKGpzb24pIHtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChqc29uLnJlc3VsdCA9PSBcXFwic3VjY2Vzc1xcXCIpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcXFwiU3RhdHVzIHJldHVybmVkOiBcXFwiKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhqc29uLmFwcF9zdGF0dXMpO1xcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGVydChfdHJbXFxcIm1sYWIuZHQubWFuYWdlbWVudC5qcy5jb21waWxlci5nZXRfYXBwX3N0YXR1cy5hbGVydC51bmFibGUuZ2V0LmFwcC5zdGF0dXNcXFwiXSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbWxhYi5kdC51dGlscy51cGRhdGVfc3RhdHVzKFxcXCJ0ZW1wb3JhcnlcXFwiLCBcXFwiXFxcIiwgZmFsc2UpO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9LFxcblxcbiAgICAgICAgLy9zZXRzIHVwIGEgd2Vic29ja2V0IGNvbm5lY3QgdG8gZ2V0IGluZm9ybWF0aW9uIGJhY2sgZHVyaW5nIHRoZSBjb21waWxhdGlvbiBwcm9jZXNzXFxuICAgICAgICBnZXRfYXBwOiBmdW5jdGlvbiBnZXRfYXBwKHBsYXRmb3JtKSB7XFxuICAgICAgICAgICAgbWxhYi5kdC5tYW5hZ2VtZW50LnNvY2tldC5zZXR1cChtbGFiLmR0Lm1hbmFnZW1lbnQuY29tcGlsZXIuZ2V0X2FwcF9jYWxsYmFjaywgcGxhdGZvcm0pO1xcbiAgICAgICAgfSxcXG5cXG4gICAgICAgIC8vY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyB1c2VkIHdoZW4gdGhlIHdlYnNvY2tldCBjb25uZWN0aW9uIChzZWUgZ2V0X2FwcCBhYm92ZSkgaXMgY29tcGxldGVkXFxuICAgICAgICAvL3RoaXMgaXMgd2hlcmUgd2Ugc3RhcnQgdGhlIGFjdHVhbCBwcm9jZXNzXFxuICAgICAgICBnZXRfYXBwX2NhbGxiYWNrOiBmdW5jdGlvbiBnZXRfYXBwX2NhbGxiYWNrKHBsYXRmb3JtKSB7XFxuICAgICAgICAgICAgdmFyIHVybCA9IG1sYWIuZHQudXJscy5jbXBfZ2V0X2FwcF9wcm9jZXNzLnJlcGxhY2UoXFxcIl9XSU5ET1dfVUlEX1xcXCIsIG1sYWIuZHQudWlkKTtcXG4gICAgICAgICAgICB1cmwgPSB1cmwucmVwbGFjZShcXFwiX0lEX1xcXCIsIG1sYWIuZHQuYXBwLmlkKTtcXG4gICAgICAgICAgICB1cmwgPSB1cmwucmVwbGFjZShcXFwiX1ZFUlNJT05fXFxcIiwgbWxhYi5kdC5hcHAuYWN0aXZlX3ZlcnNpb24pO1xcbiAgICAgICAgICAgIHVybCA9IHVybC5yZXBsYWNlKFxcXCJfUExBVEZPUk1fXFxcIiwgcGxhdGZvcm0pO1xcbiAgICAgICAgICAgIHZhciBjYXB0aW9uX2ZpbmlzaGVkID0gX3RyW1xcXCJtbGFiLmR0Lm1hbmFnZW1lbnQuanMuY29tcGlsZXIuZ2V0X2FwcC5zdGF0dXMuY3JlYXRpbmcuYXBwXFxcIl07XFxuICAgICAgICAgICAgJChcXFwiI21sYWJfc3RhdHVzYmFyX2NvbXBpbGVyXFxcIikudGV4dChjYXB0aW9uX2ZpbmlzaGVkKTtcXG4gICAgICAgICAgICAkKFxcXCIjbWxhYl9kb3dubG9hZF9cXFwiICsgcGxhdGZvcm0gKyBcXFwiX2ljb25cXFwiKS5maW5kKCdpbWcnKS5zaG93KCk7XFxuICAgICAgICAgICAgJChcXFwiI21sYWJfZG93bmxvYWRfXFxcIiArIHBsYXRmb3JtICsgXFxcIl9pY29uXFxcIikuYWRkQ2xhc3MoXFxcIm1sYWJfZG93bmxvYWRfXFxcIiArIHBsYXRmb3JtICsgXFxcIl9pY29uX2dyZXlcXFwiKTtcXG4gICAgICAgICAgICAkKFxcXCIjbWxhYl9wcm9ncmVzc2JhclxcXCIpLnNob3coKTtcXG4gICAgICAgICAgICAkKFxcXCIjbWxhYl9wcm9ncmVzc2JhclxcXCIpLnZhbCgyKTtcXG4gICAgICAgICAgICAkLmdldEpTT04odXJsLCBmdW5jdGlvbiAoanNvbikge1xcbiAgICAgICAgICAgICAgICBpZiAoanNvbi5yZXN1bHQgIT0gXFxcInN1Y2Nlc3NcXFwiKSB7XFxuICAgICAgICAgICAgICAgICAgICAkKFxcXCIjbWxhYl9zdGF0dXNiYXJfY29tcGlsZXJcXFwiKS50ZXh0KFxcXCJcXFwiKTtcXG4gICAgICAgICAgICAgICAgICAgICQoXFxcIiNtbGFiX3Byb2dyZXNzYmFyXFxcIikuaGlkZSgpO1xcbiAgICAgICAgICAgICAgICAgICAgbWxhYi5kdC51dGlscy51cGRhdGVfc3RhdHVzKFxcXCJ0ZW1wb3JhcnlcXFwiLCBfdHJbXFxcIm1sYWIuZHQubWFuYWdlbWVudC5qcy51cGRhdGVfc3RhdHVzLnVuYWJsZS5jb250YWN0LnNlcnZlclxcXCJdLCBmYWxzZSk7XFxuICAgICAgICAgICAgICAgICAgICAkKFxcXCIjbWxhYl9kb3dubG9hZF9cXFwiICsgcGxhdGZvcm0gKyBcXFwiX2ljb25cXFwiKS5maW5kKCdpbWcnKS5oaWRlKCk7XFxuICAgICAgICAgICAgICAgICAgICAkKFxcXCIjbWxhYl9kb3dubG9hZF9cXFwiICsgcGxhdGZvcm0gKyBcXFwiX2ljb25cXFwiKS5yZW1vdmVDbGFzcyhcXFwibWxhYl9kb3dubG9hZF9cXFwiICsgcGxhdGZvcm0gKyBcXFwiX2ljb25fZ3JleVxcXCIpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgIH0gLy8gZW5kIG1hbmFnZW1lbnQucHJvdG90eXBlXFxuXFxufTtcIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Jhdy1sb2FkZXIhLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYj8/cmVmLS0wLTAhLi9hc3NldHMvanMvbWxhYi5kdC5tYW5hZ2VtZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9yYXctbG9hZGVyL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMC0wIS4vYXNzZXRzL2pzL21sYWIuZHQubWFuYWdlbWVudC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFwidmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFxcXCJzeW1ib2xcXFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFxcXCJzeW1ib2xcXFwiIDogdHlwZW9mIG9iajsgfTtcXG5cXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9IGVsc2UgeyByZXR1cm4gQXJyYXkuZnJvbShhcnIpOyB9IH1cXG5cXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxcclxcbkBjb3B5cmlnaHQgQ29weXJpZ2h0IChjKSAyMDEzLTIwMTYsIE5vcndlZ2lhbiBEZWZlbmNlIFJlc2VhcmNoIEVzdGFibGlzaG1lbnQgKEZGSSkgLSBBbGwgUmlnaHRzIFJlc2VydmVkXFxyXFxuQGxpY2Vuc2UgUHJvcHJpZXRhcnkgYW5kIGNvbmZpZGVudGlhbFxcclxcbkBhdXRob3IgQXJpbGQgQmVyZ2gvU2luZXR0IDMuMCBwcm9ncmFtbWUgKGZpcnN0bmFtZS5sYXN0bmFtZUBmZmkubm8pIHJld3JpdGUvaW1wbGVtZW50YXRpb24gb2YgYWxsIGZ1bmN0aW9uYWxpdHlcXHJcXG5AYXV0aG9yIENlY2lsaWUgSmFja2JvIEdyYW4vU2luZXR0IDMuMCBwcm9ncmFtbWUgKGZpcnN0bmFtZS5taWRkbGVuYW1lLmxhc3RuYW1lQGZmaS5ubykgYWRkaXRpb25hbCBmdW5jdGlvbmFsaXR5XFxyXFxuXFxyXFxuVW5hdXRob3JpemVkIGNvcHlpbmcgb2YgdGhpcyBmaWxlLCB2aWEgYW55IG1lZGl1bSBpcyBzdHJpY3RseSBwcm9oaWJpdGVkIFxcclxcblxcclxcbkZvciB0aGUgZnVsbCBjb3B5cmlnaHQgYW5kIGxpY2Vuc2UgaW5mb3JtYXRpb24sIHBsZWFzZSB2aWV3IHRoZSBMSUNFTlNFX01MQUIgZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXFxyXFxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG5cXG4vKipcXHJcXG4gKiBAYWJzdHJhY3QgVXRpbGl0eSBmdW5jdGlvbnMgZm9yIGRlc2lnbiB0aW1lXFxyXFxuICovXFxuXFxuZnVuY3Rpb24gTWxhYl9kdF91dGlscygpIHtcXG4gICAgdGhpcy5wYXJlbnQgPSBudWxsO1xcbiAgICB0aGlzLnRpbWVyX3NhdmUgPSBudWxsO1xcbiAgICB0aGlzLmNvbmNhdF9ub3RfcmVwbGFjZSA9IFtcXFwicmVxdWlyZWRfbGlic1xcXCJdOyAvL2dhaCEgZ29yeSBoYWNrIHRvIHRyZWF0IHRoZSByZXF1aXJlZF9saWJzIHNldHRpbmcgZGlmZmVyZW50bHkgd2hlbiBoYW5kbGUgaW5oZXJpdGFuY2UuLi4gVE9ETzpGaXghXFxufTtcXG5cXG5NbGFiX2R0X3V0aWxzLnByb3RvdHlwZSA9IHtcXG4gICAgLyoqXFxyXFxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBkaXNwbGF5IHN0YXR1cyBpbmZvcm1hdGlvbiwgdGhpcyBjYW4gYmUgcGVybWFuZW50LCB0ZW1wb3JhcnksIG9yIHVudGlsIGNhbGxiYWNrIGlzIGNhbGxlZCwgYW5kIG1heSBoYXZlIGEgcHJvZ3Jlc3MgYmFyXFxyXFxuICAgICAqIElmIHN0YXRlIGlzIGNvbXBsZXRlZCB3ZSBnZXQgcmlkIG9mIHRlbXBvcmFyeSBpbmZvIGFuZCBhbnkgZ2F1Z2VzXFxyXFxuICAgICAqXFxyXFxuICAgICAqIEBwYXJhbSB7dHlwZX0gc3RhdGVcXHJcXG4gICAgICogQHBhcmFtIHt0eXBlfSBjb250ZW50XFxyXFxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XFxyXFxuICAgICovXFxuICAgIHVwZGF0ZV9zdGF0dXM6IGZ1bmN0aW9uIHVwZGF0ZV9zdGF0dXMoc3RhdGUsIGNvbnRlbnQsIGRpc3BsYXlfcHJvZ3Jlc3MpIHtcXG5cXG4gICAgICAgIGlmIChzdGF0ZSA9PSBcXFwicGVybWFuZW50XFxcIikge1xcbiAgICAgICAgICAgICQoXFxcIiNtbGFiX3N0YXR1c2Jhcl9wZXJtYW5lbnRcXFwiKS50ZXh0KGNvbnRlbnQpO1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT0gXFxcInRlbXBvcmFyeVxcXCIpIHtcXG4gICAgICAgICAgICAkKFxcXCIjbWxhYl9zdGF0dXNiYXJfdGVtcG9yYXJ5XFxcIikudGV4dChjb250ZW50KTtcXG4gICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dCh0aGlzLmNsZWFyX3N0YXR1cy5iaW5kKHRoaXMpLCAzMDAwKTtcXG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT0gXFxcImNhbGxiYWNrXFxcIikge1xcbiAgICAgICAgICAgICQoXFxcIiNtbGFiX3N0YXR1c2Jhcl90ZW1wb3JhcnlcXFwiKS50ZXh0KGNvbnRlbnQpO1xcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PSBcXFwiY29tcGxldGVkXFxcIikge1xcbiAgICAgICAgICAgICQoXFxcIiNtbGFiX3N0YXR1c2Jhcl90ZW1wb3JhcnlcXFwiKS50ZXh0KCcnKTtcXG4gICAgICAgICAgICAkKCcjbWxhYl9zdGF0dXNiYXJfcHJvZ3Jlc3Nfc3BpbicpLnNwaW4oZmFsc2UpO1xcbiAgICAgICAgICAgICQoXFxcIiNtbGFiX3N0YXR1c2Jhcl9wcm9ncmVzc19zcGluXFxcIikuaGlkZSgpO1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICh0eXBlb2YgZGlzcGxheV9wcm9ncmVzcyAhPSBcXFwidW5kZWZpbmVkXFxcIiAmJiBkaXNwbGF5X3Byb2dyZXNzID09IHRydWUpIHtcXG4gICAgICAgICAgICAkKFxcXCIjbWxhYl9zdGF0dXNiYXJfcHJvZ3Jlc3Nfc3BpblxcXCIpLnNob3coKTtcXG4gICAgICAgICAgICAkKFxcXCIjbWxhYl9zdGF0dXNiYXJfcHJvZ3Jlc3Nfc3BpblxcXCIpLnNwaW4oJ3NtYWxsJywgJyNmZmYnKTtcXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGRpc3BsYXlfcHJvZ3Jlc3MgIT0gXFxcInVuZGVmaW5lZFxcXCIgJiYgZGlzcGxheV9wcm9ncmVzcyA9PSBmYWxzZSkge1xcbiAgICAgICAgICAgICQoJyNtbGFiX3N0YXR1c2Jhcl9wcm9ncmVzc19zcGluJykuc3BpbihmYWxzZSk7XFxuICAgICAgICAgICAgJChcXFwiI21sYWJfc3RhdHVzYmFyX3Byb2dyZXNzX3NwaW5cXFwiKS5oaWRlKCk7XFxuICAgICAgICB9XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcclxcbiAgICAgKiBTaW1wbGUgd3JhcHBlciBmdW5jdGlvbiB0byBjbGVhciBhIHRlbXBvcmFyeSBzdGF0dXNcXHJcXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH0gKi9cXG4gICAgY2xlYXJfc3RhdHVzOiBmdW5jdGlvbiBjbGVhcl9zdGF0dXMoKSB7XFxuICAgICAgICB0aGlzLnVwZGF0ZV9zdGF0dXMoXFxcImNvbXBsZXRlZFxcXCIpO1xcbiAgICB9LFxcblxcbiAgICAvKipcXHJcXG4gICAgICogQ3JlYXRlIGEgdGltZXIgdG8gc2F2ZSB0aGUgY3VycmVudCBwYWdlIGFuZCBzdG9yZXMgaXQgaW4gYSBnbG9iYWwgdmFyaWFibGVcXHJcXG4gICAgICogd2UgY2FsbCB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMudGltZXJfc2F2ZSkgdG8gc3RvcCBpdCBzaG91bGQgaXQgYmUgcmVxdWlyZWRcXHJcXG4gICAgICpcXHJcXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cXHJcXG4gICAgICovXFxuICAgIHRpbWVyX3N0YXJ0OiBmdW5jdGlvbiB0aW1lcl9zdGFydCgpIHtcXG4gICAgICAgIHZhciB0bSA9IHBhcnNlSW50KHRoaXMucGFyZW50LmNvbmZpZ1tcXFwic2F2ZV9pbnRlcnZhbFxcXCJdKTtcXG4gICAgICAgIGlmICh0bSA8IDYwKSB7XFxuICAgICAgICAgICAgdG0gPSA2MDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIC8vTmVlZCB0byBwcm92aWRlIGNvbnRleHQgZm9yIHRpbWVyIGV2ZW50LCBvdGhlcndpc2UgdGhlIFxcXCJ0aGlzXFxcIiBpbnNpZGUgcGFnZV9zYXZlIHdpbGwgcG9pbnQgdG8gV2luZG93IG9iamVjdFxcbiAgICAgICAgdGhpcy50aW1lcl9zYXZlID0gd2luZG93LnNldFRpbWVvdXQodGhpcy5wYXJlbnQubWFuYWdlbWVudC5wYWdlX3NhdmUuYmluZCh0aGlzLnBhcmVudC5tYW5hZ2VtZW50KSwgdG0gKiAxMDAwKTtcXG4gICAgfSxcXG5cXG4gICAgdGltZXJfc3RvcDogZnVuY3Rpb24gdGltZXJfc3RvcCgpIHtcXG4gICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy50aW1lcl9zYXZlKTtcXG4gICAgfSxcXG5cXG4gICAgLy91dGlsaXR5IHRvIG1lcmdlIHR3byBvYmplY3RzLCBidXQgb25seSBBREQgbm9uLWV4aXN0aW5nIHByb3BlcnRpZXMgdG8gdGhlIHRvX29ialxcbiAgICAvL3Byb3BlcnRpZXMgdGhhdCBleGlzdCBhcmUgbWVyZ2VkLCBvdGhlcndpc2UgaXQgaXMgYWRkZWQgYXMgYSBuZXcgb2JqZWN0IHByb3BlcnR5XFxuICAgIC8vVVBEQVRFOiBGb3IgdGhlIHJlcXVpcmVkX2xpYnMgd2UgY29uY2F0ZW5hdGUgYW5kIGRlZHVwZSwgb3RoZXJ3aXNlIHdlIGVuZCB1cCB1c2luZyBudW1iZXJlZCBpbmRleCBmb3IgY29tcGFyaXNvbi4uLlxcbiAgICBtZXJnZV9vYmplY3RzOiBmdW5jdGlvbiBtZXJnZV9vYmplY3RzKGZyb21fb2JqLCB0b19vYmosIHBhcmVudF9uYW1lKSB7XFxuICAgICAgICBmb3IgKHZhciBwIGluIGZyb21fb2JqKSB7XFxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZnJvbV9vYmpbcF0pICYmIHRoaXMuY29uY2F0X25vdF9yZXBsYWNlLmluZGV4T2YocGFyZW50X25hbWUpID4gLTEpIHtcXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0b19vYmpbcF0gPT09IFxcXCJ1bmRlZmluZWRcXFwiKSB7XFxuICAgICAgICAgICAgICAgICAgICAvL2lmIHRoZSByZWNlaXZpbmcgb2JqZWN0IGRvZXMgbm90IGhhdmUgYSBtYXRjaGluZyBvYmplY3QsIHRoZW4gaXQgbXVzdCBiZSBjcmVhdGVkIG9yIGl0IHdpbGwgZmFpbFxcbiAgICAgICAgICAgICAgICAgICAgdG9fb2JqW3BdID0gZnJvbV9vYmpbcF07XFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICAvL3RvX29ialtwXSA9IGZyb21fb2JqW3BdLmNvbmNhdCh0b19vYmpbcF0pOyAvL2ZvciBhcnJheXMgd2UgYWx3YXlzIG1lcmdlXFxuICAgICAgICAgICAgICAgICAgICB0b19vYmpbcF0gPSBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KG5ldyBTZXQoW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShmcm9tX29ialtwXSksIF90b0NvbnN1bWFibGVBcnJheSh0b19vYmpbcF0pKSkpKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoX3R5cGVvZihmcm9tX29ialtwXSkgPT09IFxcXCJvYmplY3RcXFwiKSB7XFxuICAgICAgICAgICAgICAgIC8vaW5jb21pbmcgcHJvcGVydHkgaXMgYSBcXFwic3ViXFxcIiBvYmplY3QsIG5vdCBhIHZhbHVlXFxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdG9fb2JqW3BdID09PSBcXFwidW5kZWZpbmVkXFxcIikge1xcbiAgICAgICAgICAgICAgICAgICAgLy9pZiB0aGUgcmVjZWl2aW5nIG9iamVjdCBkb2VzIG5vdCBoYXZlIGEgbWF0Y2hpbmcgb2JqZWN0LCB0aGVuIGl0IG11c3QgYmUgY3JlYXRlZCBvciBpdCB3aWxsIGZhaWxcXG4gICAgICAgICAgICAgICAgICAgIHRvX29ialtwXSA9IG5ldyBPYmplY3QoKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB0b19vYmpbcF0gPSB0aGlzLm1lcmdlX29iamVjdHMoZnJvbV9vYmpbcF0sIHRvX29ialtwXSwgcCk7IC8vYXMgdGhpcyBpcyBhIG9iamVjdCB3ZSB0aGVuIG1lcmdlIHRoaXMgc3ViLW9iamVjdFxcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRvX29ialtwXSA9PT0gXFxcInVuZGVmaW5lZFxcXCIpIHtcXG4gICAgICAgICAgICAgICAgLy90aGlzIGlzIGEgdmFsdWUsIG5vdCBhbiBvYmplY3QgYW5kIGl0IGRvZXMgTk9UIGV4aXN0IGluIHJlY2VpdmluZyBvYmplY3QsIHNvIHdlIGFkZCBpdC5cXG4gICAgICAgICAgICAgICAgdG9fb2JqW3BdID0gZnJvbV9vYmpbcF07XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIHRvX29iajtcXG4gICAgfSxcXG5cXG4gICAgcHJvY2Vzc19pbmhlcml0YW5jZV9oZWxwZXI6IGZ1bmN0aW9uIHByb2Nlc3NfaW5oZXJpdGFuY2VfaGVscGVyKGNvbXBvbmVudHMsIGluZGV4KSB7XFxuICAgICAgICAvL2RvZXMgdGhpcyBjb21wb25lbnQgaW5oZXJpdCBmcm9tIGFub3RoZXIgY29tcG9uZW50P1xcbiAgICAgICAgaWYgKHR5cGVvZiBjb21wb25lbnRzW2luZGV4XS5jb25mW1xcXCJpbmhlcml0XFxcIl0gIT0gXFxcInVuZGVmaW5lZFxcXCIpIHtcXG4gICAgICAgICAgICB2YXIgZnJvbSA9IGNvbXBvbmVudHNbaW5kZXhdLmNvbmYuaW5oZXJpdDtcXG5cXG4gICAgICAgICAgICAvL2RvZXMgdGhlIGNvbXBvbmVudCB0byBpbmhlcml0IGZyb20gZXhpc3Q/XFxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb21wb25lbnRzW2Zyb21dICE9IFxcXCJ1bmRlZmluZWRcXFwiKSB7XFxuXFxuICAgICAgICAgICAgICAgIC8vbmVlZCB0byBjaGVjayB0aGF0IHRoZSBvYmplY3QgdG8gaW5oZXJpdCBpcyBlaXRoZXIgdG9wIGxldmVsLCBvciBhbHJlYWR5IGluaGVyaXRlZCwgaWYgbm90IHdlIHJlY3Vyc2l2ZWx5IHByb2Nlc3MgdGhvc2UgaW5oZXJpYW5jZXMgZmlyc3QgXFxuICAgICAgICAgICAgICAgIGlmICghY29tcG9uZW50c1tmcm9tXS5pbmhlcml0YW5jZV9wcm9jZXNzZWQgJiYgY29tcG9uZW50c1tmcm9tXS5jb25mW1xcXCJpbmhlcml0XFxcIl0gIT0gXFxcInVuZGVmaW5lZFxcXCIpIHtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc19pbmhlcml0YW5jZV9oZWxwZXIoY29tcG9uZW50cywgZnJvbSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgLy93ZSBjb3B5IHRvcCBsZXZlbCBvYmplY3RzIGFuZCBvYmplY3RzIHdpdGhpbiB0aGUgY29kZSBhbmQgYW5kIGNvZGUuY29uZmlnIG9iamVjdHNcXG4gICAgICAgICAgICAgICAgY29tcG9uZW50c1tpbmRleF0gPSB0aGlzLm1lcmdlX29iamVjdHMoY29tcG9uZW50c1tmcm9tXSwgY29tcG9uZW50c1tpbmRleF0sIGZyb20pO1xcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzW2luZGV4XS5pbmhlcml0YW5jZV9wcm9jZXNzZWQgPSB0cnVlO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxcXCJQYXJlbnQgb2JqZWN0IGZvciBcXFwiICsgaW5kZXggKyBcXFwiIGRvZXMgbm90IGV4aXN0OlxcXCIgKyBmcm9tKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgIH0sXFxuXFxuICAgIC8vdGhpcyBmdW5jdGlvbiB0YWtlcyBjYXJlIG9mIHRoZSBzaW1wbGUgaW5oZXJpdGFuY2UgZmFjaWxpdHkgdGhhdCBjb21wb2VubnRzIG9mZmVyXFxuICAgIC8vSGF2ZSBhIHByb3BlcnR5IGNhbGxlZCBpbmhlcml0YW5jZV9wcm9jZXNzZWQsIGlmIHRydWUgd2UndmUgYWRkZWQgcHJvcGVydGllcyBmcm9tIHBhcmVudHMgZm9yIHRoYXQgY29tcG9uZW50LiBTZXQgdGhpcyB0byB0cnVlIGZvciBjb21wb25lbnRzIHRoYXQgZG8gbm90IGluaGVyaXQgZnJvbSBhbnlvbmUgZWxzZVxcbiAgICAvL1doZW4gbG9vcCB0aHJvdWdoIGNvbXBvbmVudHMgYW5kIGl0IGluaGVyaXRzIGZyb20gYSBjb21wb25lbnQgdGhhdCBoYWQgbm90IGxvYWRlZCBwYXJlbnRzIHlldCwgdGhlbiBwcm9jZXNzIHRoYXQgZmlyc3QsIHRoZW4gaW5oZXJpdCBmcm9tIGdyYW5kcGFyZW50IHRvIHBhcmVudCBmaXJzdC5cXG4gICAgLy9JZiBncmFuZHBhcmVudCBhbHNvIGluaGVyaXRzLCB0aGVuIHNhbWUgZm9yIHRoYXQsIGFuZCBzbyBvbi5cXG4gICAgLy9OZWVkIHRvIGhhdmUgYSBjYWxsIHN0YWNrIHRvIGF2b2lkIGNpcmN1bGFyIGluaGVyaXRhbmNlXFxuICAgIHByb2Nlc3NfaW5oZXJpdGFuY2U6IGZ1bmN0aW9uIHByb2Nlc3NfaW5oZXJpdGFuY2UoY29tcG9uZW50cykge1xcbiAgICAgICAgZm9yIChpbmRleCBpbiBjb21wb25lbnRzKSB7XFxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzX2luaGVyaXRhbmNlX2hlbHBlcihjb21wb25lbnRzLCBpbmRleCk7XFxuICAgICAgICB9XFxuICAgIH0sXFxuXFxuICAgIC8vZ2V0cyBhIGNvb2tpZSBieSBuYW1lL2tleSAgICAgICAgICAgICAgICAgICAgICAgIFxcbiAgICBnZXRDb29raWU6IGZ1bmN0aW9uIGdldENvb2tpZShjbmFtZSkge1xcbiAgICAgICAgdmFyIG5hbWUgPSBjbmFtZSArIFxcXCI9XFxcIjtcXG4gICAgICAgIHZhciBjYSA9IGRvY3VtZW50LmNvb2tpZS5zcGxpdCgnOycpO1xcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYS5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgICAgIHZhciBjID0gY2FbaV07XFxuICAgICAgICAgICAgd2hpbGUgKGMuY2hhckF0KDApID09ICcgJykge1xcbiAgICAgICAgICAgICAgICBjID0gYy5zdWJzdHJpbmcoMSk7XFxuICAgICAgICAgICAgfWlmIChjLmluZGV4T2YobmFtZSkgPT0gMCkgcmV0dXJuIGMuc3Vic3RyaW5nKG5hbWUubGVuZ3RoLCBjLmxlbmd0aCk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gMTtcXG4gICAgfVxcblxcbn07XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yYXctbG9hZGVyIS4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWI/P3JlZi0tMC0wIS4vYXNzZXRzL2pzL21sYWIuZHQudXRpbHMuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3Jhdy1sb2FkZXIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0wLTAhLi9hc3NldHMvanMvbWxhYi5kdC51dGlscy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcXHJcXG5AY29weXJpZ2h0IENvcHlyaWdodCAoYykgMjAxMy0yMDE2LCBOb3J3ZWdpYW4gRGVmZW5jZSBSZXNlYXJjaCBFc3RhYmxpc2htZW50IChGRkkpIC0gQWxsIFJpZ2h0cyBSZXNlcnZlZFxcclxcbkBsaWNlbnNlIFByb3ByaWV0YXJ5IGFuZCBjb25maWRlbnRpYWxcXHJcXG5AYXV0aG9yIEFyaWxkIEJlcmdoL1NpbmV0dCAzLjAgcHJvZ3JhbW1lIChmaXJzdG5hbWUubGFzdG5hbWVAZmZpLm5vKSByZXdyaXRlL2ltcGxlbWVudGF0aW9uIG9mIGFsbCBmdW5jdGlvbmFsaXR5XFxyXFxuQGF1dGhvciBDZWNpbGllIEphY2tibyBHcmFuL1NpbmV0dCAzLjAgcHJvZ3JhbW1lIChmaXJzdG5hbWUubWlkZGxlbmFtZS5sYXN0bmFtZUBmZmkubm8pIGFkZGl0aW9uYWwgZnVuY3Rpb25hbGl0eVxcclxcblxcclxcblVuYXV0aG9yaXplZCBjb3B5aW5nIG9mIHRoaXMgZmlsZSwgdmlhIGFueSBtZWRpdW0gaXMgc3RyaWN0bHkgcHJvaGliaXRlZCBcXHJcXG5cXHJcXG5Gb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgTElDRU5TRV9NTEFCIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxcclxcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuXFxuLyoqXFxyXFxuICogQGFic3RyYWN0IEFsbCBmdW5jdGlvbnMgdXNlZCBpbiAvc3JjL1NpbmV0dC9NTEFCL0J1aWxkZXJCdW5kbGUvUmVzb3VyY2VzL3ZpZXdzL0FwcC9idWlsZF9hcHAuaHRtbC50d2lnXFxyXFxuICogYnV0IG5vdCB0aGUgZGF0YSB0aGF0IGhhcyB0byBjb21lIGZyb20gVFdJRy4gVGhlcmVmb3JlLCBzZWUgdG9wIG9mIHRoYXQgcGFnZSBmb3IgZGF0YSBzdHJ1Y3R1cmVzLlxcclxcbiAqL1xcbi8vVE9ETzogTkVFRCBUTyBOT1QgVVNFIHNsZiAod2luZG93LnNsZiA9IEpTIGJ1aWx0aW4gdmFyaWFibGUpXFxuXFxuXFxuLyogZ2VuZXJhbCB2YXJpYWJsZXMgdXNlZCBnbG9iYWxseSBieSBkaWZmZXJlbnQgZnVuY3Rpb25zXFxyXFxuICAgKHZhcmlhYmxlcyB3aXRoIGRhdGEgZnJvbSBiYWNrZW5kIGFyZSBsb2FkZWQgZnJvbSB0aGUgYmFja2VuZCBpbiB0aGUgZG9jdW1lbnQucmVhZHkgZXZlbnQgYW5kIGVudGVycyB0aGlzIGZpbGUgYXMgSlNPTiBzdHJ1Y3R1cmVzICovXFxuXFxuLy90dXJuIG9mZiBhdXRvbWF0aWMgaW5pdGlhbGlzYXRpb24gb2YgbW9iaWxlIHBhZ2VzXFxuJC5tb2JpbGUuYXV0b0luaXRpYWxpemVQYWdlID0gZmFsc2U7XFxuXFxuLyoqKioqKioqKioqIFN0YXJ0dXAgY29kZSAqKioqKioqKioqKi9cXG4kKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbiAoKSB7XFxuXFxuICAgIC8vb25seSBzdXBwb3J0IGNocm9tZSBhbmQgZmlyZWZveCB0byBiZWdpbiB3aXRoXFxuICAgIGlmIChib3dzZXIuZ2Vja28gfHwgYm93c2VyLmNocm9tZSkge30gZWxzZSB7XFxuICAgICAgICBhbGVydChfdHJbXFxcIm1sYWJfZWRpdG9yLmluaXQuanMuYWxlcnQuYnJvd3Nlci5zdXBwb3J0XFxcIl0pO1xcbiAgICAgICAgJChcXFwiYm9keVxcXCIpLmFwcGVuZCgnPGRpdiBpZD1cXFwibWxhYl9lZGl0b3JfZGlzYWJsZWRcXFwiIHN0eWxlPVxcXCJiYWNrZ3JvdW5kLWNvbG9yOiBncmF5OyBwb3NpdGlvbjogYWJzb2x1dGU7dG9wOjA7bGVmdDowO3dpZHRoOiAxMDAlO2hlaWdodDoxMDAlO3otaW5kZXg6MjtvcGFjaXR5OjAuNDtmaWx0ZXI6IGFscGhhKG9wYWNpdHkgPSA1MClcXFwiPjwvZGl2PicpO1xcbiAgICB9XFxuXFxuICAgIC8vaW5pdGlhbGlzZSB0aGUgTWxhYiBvYmplY3QsIHRoZW4gY3JlYXRlIGFuIGdsb2JhbCBpbnN0YW5jZSBvZiBpdFxcbiAgICAvL3RoZSBNTEFCIG9iamVjdCBjb250YWlucyBzZXZlcmFsIG90aGVyIG9iamVjdHMgbG9hZGVkIGluIGRpZmZlcmVudCBmaWxlc1xcbiAgICBNbGFiID0gZnVuY3Rpb24gTWxhYigpIHtcXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcXG4gICAgICAgIHRoaXMubG9jYWxlID0gZG9jdW1lbnQubWxhYl90ZW1wX3ZhcnMubG9jYWxlO1xcblxcbiAgICAgICAgLy9ydW50aW1lIGFwaSBpcyBhdCB0aGUgdG9wIGxldmVsXFxuICAgICAgICB0aGlzLmFwaSA9IG5ldyBNbGFiX2FwaSgpO1xcbiAgICAgICAgdGhpcy5hcGkucGFyZW50ID0gc2VsZjtcXG5cXG4gICAgICAgIHRoaXMuZHQgPSB7XFxuICAgICAgICAgICAgLy92YXJpYWJsZXMgdXNlZCBmb3I6IGdlbmVyYWwgY29uZmlnLCBwYXRoIGluZm8sIGFwcCBpbmZvLCBwYWdlIGRldGFpbHNcXG4gICAgICAgICAgICB1aWQ6IDAsXFxuICAgICAgICAgICAgY29uZmlnOiBuZXcgT2JqZWN0KCksXFxuICAgICAgICAgICAgcGF0aHM6IG5ldyBPYmplY3QoKSxcXG4gICAgICAgICAgICBhcHA6IG5ldyBPYmplY3QoKSxcXG4gICAgICAgICAgICBwYWdlOiBuZXcgT2JqZWN0KCksXFxuXFxuICAgICAgICAgICAgLy8gaW5kaXZpZHVhbCB2YXJpYWJsZXMgdXNlZCBieSBhbGwgLmR0IHN1YiBmdW5jdGlvbnNcXG4gICAgICAgICAgICBmbGFnX2RpcnR5OiBmYWxzZSxcXG4gICAgICAgICAgICBjb3VudGVyX3NhdmluZ19wYWdlOiAwLCAvLyBjb3VudGVyIHdoaWNoIHRlbGxzIHVzIGlmIGluc2lkZSB0aGUgc2F2ZSBmdW5jdGlvbiB3ZSBzaG91bGQgcmVzdGFydCB0aGUgdGltZXIgZm9yXFxuICAgICAgICAgICAgZHJhZ19vcmlnaW46ICdzb3J0YWJsZScsXFxuICAgICAgICAgICAgbWxhYl9jb21wb25lbnRfY3VyX3Rvb2x0aXA6IG51bGwsXFxuXFxuICAgICAgICAgICAgLy8gZHJhZyduJ2Ryb3AgZGVmaW5pdGlvbnMgdXNlZCBieSBqUXVlcnlcXG4gICAgICAgICAgICBkcm9wcGFibGVfb3B0aW9uczoge1xcbiAgICAgICAgICAgICAgICBkcm9wOiBmdW5jdGlvbiBkcm9wKGV2ZW50LCB1aSkge1xcbiAgICAgICAgICAgICAgICAgICAgbWxhYi5kdC5mbGFnX2RpcnR5ID0gdHJ1ZTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0sXFxuXFxuICAgICAgICAgICAgc29ydGFibGVfb3B0aW9uczoge1xcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogXFxcIm1sYWJfY29tcG9uZW50X3BsYWNlaG9sZGVyXFxcIixcXG4gICAgICAgICAgICAgICAgcmV2ZXJ0OiBmYWxzZSxcXG4gICAgICAgICAgICAgICAgaGVscGVyOiBcXFwiY2xvbmVcXFwiLFxcbiAgICAgICAgICAgICAgICBjYW5jZWw6IFxcXCJbY29udGVudGVkaXRhYmxlXVxcXCIsXFxuICAgICAgICAgICAgICAgIHN0b3A6IGZ1bmN0aW9uIHN0b3AoZXZlbnQsIHVpKSB7XFxuICAgICAgICAgICAgICAgICAgICAvL21ha2UgZWRpdGFibGUgYWZ0ZXIgZHJhZ2dpbmcgdG8gc29ydFxcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1sYWIuZHQuZHJhZ19vcmlnaW4gPT0gJ3NvcnRhYmxlJyAmJiB1aS5pdGVtLmRhdGEoXFxcImNvbnRlbnRlZGl0YWJsZVxcXCIpID09IFxcXCJ0cnVlXFxcIikge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHVpLml0ZW0uYXR0cihcXFwiY29udGVudGVkaXRhYmxlXFxcIiwgXFxcInRydWVcXFwiKTtcXG4gICAgICAgICAgICAgICAgICAgIH07XFxuICAgICAgICAgICAgICAgICAgICBtbGFiLmR0LmZsYWdfZGlydHkgPSB0cnVlO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSxcXG5cXG4gICAgICAgICAgICAvL290aGVyIHByZS1kZWZpbmVkIG9iamVjdHMgd3JhcHBpbmcgdXAgdGhpcyAuZHQgXFxcImNsYXNzXFxcIlxcbiAgICAgICAgICAgIGFwaTogbmV3IE1sYWJfZHRfYXBpKCksXFxuICAgICAgICAgICAgYmVzdHByYWN0aWNlOiBuZXcgTWxhYl9kdF9iZXN0cHJhY3RpY2UoKSxcXG4gICAgICAgICAgICBkZXNpZ246IG5ldyBNbGFiX2R0X2Rlc2lnbigpLFxcbiAgICAgICAgICAgIG1hbmFnZW1lbnQ6IG5ldyBNbGFiX2R0X21hbmFnZW1lbnQoKSxcXG4gICAgICAgICAgICB1dGlsczogbmV3IE1sYWJfZHRfdXRpbHMoKVxcblxcbiAgICAgICAgfSwgdGhpcy5pbml0aWFsaXNlX2R0X3BhcmVudHMgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgc2VsZi5kdC5wYXJlbnQgPSBzZWxmO1xcbiAgICAgICAgICAgIHNlbGYuZHQuYXBpLnBhcmVudCA9IHNlbGYuZHQ7XFxuICAgICAgICAgICAgc2VsZi5kdC5hcGkuZGlzcGxheS5wYXJlbnQgPSBzZWxmLmR0LmFwaTtcXG4gICAgICAgICAgICBzZWxmLmR0LmJlc3RwcmFjdGljZS5wYXJlbnQgPSBzZWxmLmR0O1xcbiAgICAgICAgICAgIHNlbGYuZHQuZGVzaWduLnBhcmVudCA9IHNlbGYuZHQ7XFxuICAgICAgICAgICAgc2VsZi5kdC5tYW5hZ2VtZW50LnBhcmVudCA9IHNlbGYuZHQ7XFxuICAgICAgICAgICAgc2VsZi5kdC51dGlscy5wYXJlbnQgPSBzZWxmLmR0O1xcbiAgICAgICAgfTtcXG4gICAgfTtcXG4gICAgbWxhYiA9IG5ldyBNbGFiKCk7XFxuICAgIG1sYWIuaW5pdGlhbGlzZV9kdF9wYXJlbnRzKCk7XFxuXFxuICAgIC8vaGVyZSB3ZSBwaWNrIHVwIHZhcmlhYmxlcyBmcm9tIHRoZSBiYWNrZW5kLCBpZiBzdWNjZXNzZnVsIHdlIGdvIG9uLCBpZiBub3Qgd2UgbXVzdCBleGl0XFxuICAgICQuZ2V0KGRvY3VtZW50Lm1sYWJfdGVtcF92YXJzLmFwcGJ1aWxkZXJfcm9vdF91cmwgKyBkb2N1bWVudC5tbGFiX3RlbXBfdmFycy5hcHBfaWQgKyBcXFwiL1xcXCIgKyBkb2N1bWVudC5tbGFiX3RlbXBfdmFycy5wYWdlX251bSArIFxcXCIvbG9hZF92YXJpYWJsZXNcXFwiLCBmdW5jdGlvbiAoZGF0YSkge1xcblxcbiAgICAgICAgaWYgKGRhdGEucmVzdWx0ID09PSBcXFwic3VjY2Vzc1xcXCIpIHtcXG4gICAgICAgICAgICAvL3VuaXF1ZSBJRCBmb3IgdGhpcyB0YWIvd2luZG93LCB1c2VkIHRvIGxvY2sgcGFnZXNcXG4gICAgICAgICAgICBtbGFiLmR0LnVpZCA9IGRhdGEubWxhYl91aWQ7XFxuXFxuICAgICAgICAgICAgLy93ZSB1c2UgdGhlIGVtYWlsIG9mIHRoZSB1c2VyIHRvIHNlbmQgdGhlbSBsaW5rcyB0byBhcHBzXFxuICAgICAgICAgICAgbWxhYi5kdC51c2VyX2VtYWlsID0gZGF0YS5tbGFiX2N1cnJlbnRfdXNlcl9lbWFpbDtcXG5cXG4gICAgICAgICAgICAvL2N1cnJlbnQgYXBwL3BhZ2UgaW5mb3JtYXRpb24sIHRoaXMgd2lsbCBiZSB1cGRhdGVkIHdoZW4gdGhleSBjcmVhdGUgYSBuZXcgYXBwIG9yIGVkaXQgcHJvcGVydGllc1xcbiAgICAgICAgICAgIG1sYWIuZHQuYXBwID0gZGF0YS5tbGFiX2FwcDtcXG4gICAgICAgICAgICBpZiAoaXNOYU4oZGF0YS5tbGFiX2FwcF9wYWdlX251bSkpIHtcXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXFxcIkVycm9yLCBleHBlY3RpbmcgcGFnZSBudW1iZXJcXFwiKTtcXG4gICAgICAgICAgICAgICAgYWxlcnQoXFxcIkVycm9yLCBleHBlY3RpbmcgcGFnZSBudW1iZXIsIHRyeSB0byByZWZyZXNoXFxcIik7XFxuICAgICAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICBtbGFiLmR0LmFwcC5jdXJyX3BhZ2VfbnVtID0gZGF0YS5tbGFiX2FwcF9wYWdlX251bTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgLy9jaGVja3N1bSBvZiBjdXJyZW50IGZpbGVcXG4gICAgICAgICAgICBtbGFiLmR0LmFwcC5hcHBfY2hlY2tzdW0gPSBkYXRhLm1sYWJfYXBwX2NoZWNrc3VtO1xcblxcbiAgICAgICAgICAgIC8vYW55IGV4aXN0aW5nIGNvbXBpbGVkIGZpbGVzIGZvciB0aGlzIGFwcFxcbiAgICAgICAgICAgIG1sYWIuZHQuYXBwLmNvbXBpbGVkX2ZpbGVzID0gZGF0YS5tbGFiX2NvbXBpbGVkX2ZpbGVzO1xcblxcbiAgICAgICAgICAgIC8vY29uZmlndXJhdGlvbiBzdHVmZiBmcm9tIHBhcmFtZXRlci55bWxcXG4gICAgICAgICAgICBtbGFiLmR0LmNvbmZpZyA9IGRhdGEubWxhYl9jb25maWc7XFxuXFxuICAgICAgICAgICAgLy9VUkxzIGNhbiBiZSBjaGFuZ2VkIHVzaW5nIHJvdXRlcyBpbiBNTEFCLCBtYWtlIHN1cmUgd2UgYWx3YXlzIHVzZSB0aGUgbGF0ZXN0IGZyb20gU3ltZm9ueSBhbmQgZG9uJ3QgaGF2ZSBoYXJkd2lyZWQgb25lc1xcbiAgICAgICAgICAgIG1sYWIuZHQudXJscyA9IGRhdGEubWxhYl91cmxzO1xcblxcbiAgICAgICAgICAgIC8qKioqIEZpbmlzaGVkIHByZXBhcmluZyB2YXJpYWJsZXMsIG5vdyB3ZSBzZXQgdXAgcmVzdCBvZiBlbnZpcm9ubWVudCAqKioqL1xcblxcbiAgICAgICAgICAgIC8vY2hlY2sgaWYgdGhlIGRvYyBpcyBtb2RpZmllZCBiZWZvcmUgY2xvc2VpbmcgaXQsIGlmIHNvIHdhcm4gdXNlciwgYWxzbyB1bmxvY2sgZmlsZSBhbmQgc2F2ZSBjb21wb25lbnQgYWNjb3JkaW9uIGV4cGFuZCBjb2xsYXBzIHN0YXRlXFxuICAgICAgICAgICAgd2luZG93Lm9uYmVmb3JldW5sb2FkID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICB2YXIgdXJsID0gbWxhYi5kdC51cmxzLmVkaXRvcl9jbG9zZWQucmVwbGFjZShcXFwiX1VJRF9cXFwiLCBtbGFiLmR0LnVpZCk7XFxuICAgICAgICAgICAgICAgICQuYWpheCh7IHVybDogdXJsLCBhc3luYzogZmFsc2UgfSk7XFxuXFxuICAgICAgICAgICAgICAgIGlmIChtbGFiLmR0LmZsYWdfZGlydHkpIHtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdHJbXFxcIm1sYWJfZWRpdG9yLmluaXQuanMuYWxlcnQudW5zYXZlZFxcXCJdO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIC8vTG9vcCB0cm91Z2ggdGhlIENvbXBvbmVudCBjYXRlZ29yaWVzL2FjY29yZGlhbnMgdG8gc2UgaWYgdGhleSBhcmUgZXhwYW5kIG9yIGNvbGxhcHNlZC4gXFxuICAgICAgICAgICAgICAgIHZhciBjb21wY2F0ID0gJChcXFwiI21sYWJfdG9vbGJhcl9jb21wb25lbnRzIGgzXFxcIik7XFxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29tcGNhdCAhPSBcXFwidW5kZWZpbmVkXFxcIikge1xcbiAgICAgICAgICAgICAgICAgICAgY29tcGNhdC5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2F0ID0gJCh0aGlzKS5kYXRhKFxcXCJtbGFiLWNhdGVnb3J5XFxcIik7XFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCQodGhpcykuaGFzQ2xhc3MoXFxcInVpLXN0YXRlLWFjdGl2ZVxcXCIpKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vU2V0IGNvb2NraWUgdG8gc2F2ZSBleHBhbmQgc3RhdGUgb2YgdGhlIGFjY29yZGlhbnMgb2YgdGhlIGNvbXBvbmVudGdyb3VwXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNvb2tpZSA9IFxcXCJtbGFiQ29tcENhdFxcXCIgKyBjYXQgKyBcXFwiPTA7IGV4cGlyZXM9VGh1LCAxOCBEZWMgMjA1MyAxMjowMDowMCBVVEM7IHBhdGg9L1xcXCI7XFxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9TZXQgY29vY2tpZSB0byBzYXZlIGNvbGxhcHNlZCBzdGF0ZSBvZiB0aGUgYWNjb3JkaWFucyBvZiB0aGUgY29tcG9uZW50Z3JvdXBcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY29va2llID0gXFxcIm1sYWJDb21wQ2F0XFxcIiArIGNhdCArIFxcXCI9MTsgZXhwaXJlcz1UaHUsIDE4IERlYyAyMDUzIDEyOjAwOjAwIFVUQzsgcGF0aD0vXFxcIjtcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH07XFxuXFxuICAgICAgICAgICAgLy9ub3cgd2UgbG9hZCBjb21wb25lbnRzLCB0aGUgZ28gaW50byBhIG1sYWIgb2JqZWN0IGNhbGxlZCBjb21wb25lbnRzLFxcbiAgICAgICAgICAgIC8vYW5kIGZvciBlYWNoIGNvbXBvbmVudCB3ZSBuZWVkIHRvIHR1cm4gdGhlIHRleHQgb2YgdGhlXFxuICAgICAgICAgICAgJC5nZXQoZG9jdW1lbnQubWxhYl90ZW1wX3ZhcnMuYXBwYnVpbGRlcl9yb290X3VybCArIGRvY3VtZW50Lm1sYWJfdGVtcF92YXJzLmFwcF9pZCArIFxcXCIvbG9hZF9jb21wb25lbnRzXFxcIiwgZnVuY3Rpb24gKGRhdGEpIHtcXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEucmVzdWx0ID09PSBcXFwic3VjY2Vzc1xcXCIpIHtcXG5cXG4gICAgICAgICAgICAgICAgICAgIHZhciBsb2MgPSBtbGFiLmR0LmFwaS5nZXRMb2NhbGUoKTtcXG4gICAgICAgICAgICAgICAgICAgIG1sYWIuZHQuY29tcG9uZW50cyA9IGRhdGEubWxhYl9jb21wb25lbnRzO1xcbiAgICAgICAgICAgICAgICAgICAgbWxhYi5kdC5zdG9yYWdlX3BsdWdpbnMgPSB7fTtcXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb21wb25lbnRzX2h0bWwgPSB7fTtcXG4gICAgICAgICAgICAgICAgICAgIHZhciBjYXRlZ29yeV90cmFuc2xhdGlvbnMgPSB7fTtcXG4gICAgICAgICAgICAgICAgICAgIHZhciBmZWF0dXJlc19odG1sID0gW107XFxuICAgICAgICAgICAgICAgICAgICB2YXIgYWRkaXRpb25hbF9odG1sID0gXFxcIlxcXCI7XFxuICAgICAgICAgICAgICAgICAgICB2YXIgY29tcF90eXBlO1xcblxcbiAgICAgICAgICAgICAgICAgICAgLy9sb29wIHRvIGNsZWFuIHVwIGNvbXBvbmVudHMgc28gdGhhdCB0aGVyZSBhcmUgbm8gZHVwbGljYXRlIG9yZGVyX2J5IGVudHJpZXMgYW5kIGFsc28gZ2VuZXJhdGUgSlMgY29kZSBmcm9tIHRleHQgaW4gY29kZV9kdC5qcyBmaWxlXFxuICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcF9jb21wX29yZGVyID0gW107XFxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbXBfaWQgaW4gbWxhYi5kdC5jb21wb25lbnRzKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcF9jb21wX29yZGVyLnB1c2gocGFyc2VJbnQobWxhYi5kdC5jb21wb25lbnRzW2NvbXBfaWRdLm9yZGVyX2J5KSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgLy93ZSBuZWVkIHRvIGF0dGFjaCB0aGUgY29kZV9kdC5qcyBjb250ZW50IHRvIGFuIG9iamVjdCBzbyB3ZSBjYW4gdXNlIGl0IGFzIEpTIGNvZGVcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWxhYi5kdC5jb21wb25lbnRzW2NvbXBfaWRdLmNvZGUgIT09IGZhbHNlKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2YWwoXFxcIm1sYWIuZHQuY29tcG9uZW50c1snXFxcIiArIGNvbXBfaWQgKyBcXFwiJ10uY29kZSA9IG5ldyBmdW5jdGlvbigpIHsgXFxcIiArIG1sYWIuZHQuY29tcG9uZW50c1tjb21wX2lkXS5jb2RlICsgXFxcIn07XFxcIik7XFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgdGVtcF9jb21wX29yZGVyLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYSAtIGI7XFxuICAgICAgICAgICAgICAgICAgICB9KTtcXG5cXG4gICAgICAgICAgICAgICAgICAgIC8vbm93IGxvb3AgdGhyb3VnaCBhbGwgY29tcG9uZW50cyBhbmQgZm9yIHRob3NlIHRoYXQgaW5oZXJpdCBhbm90aGVyIHdlIHRyYW5zZmVyIHByb3BlcnRpZXNcXG4gICAgICAgICAgICAgICAgICAgIG1sYWIuZHQudXRpbHMucHJvY2Vzc19pbmhlcml0YW5jZShtbGFiLmR0LmNvbXBvbmVudHMpO1xcblxcbiAgICAgICAgICAgICAgICAgICAgLy9zZWNvbmQgbG9vcCB3aGljaCBpcyBmb3IgZGlzcGxheWluZyB0aGUgdG9vbHMgbG9hZGVkICYgcHJlcGFyZWQgYWJvdmUgaW4gdGhlIGVkaXRvciBwYWdlXFxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbXBfaWQgaW4gbWxhYi5kdC5jb21wb25lbnRzKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgLy9oZXJlIHdlIGNyZWF0ZSB0aGUgY29uZiBvYmplY3QgaW5zaWRlIHRoZSBuZXdseSBjcmVhdGVkIGNvZGUgb2JqZWN0LCB0aGlzIHdheSB3ZSBjYW4gYWNjZXNzIHRoZSBjb25maWd1cmF0aW9uIGRldGFpbHMgaW5zaWRlIHRoZSBjb2RlXFxuICAgICAgICAgICAgICAgICAgICAgICAgbWxhYi5kdC5jb21wb25lbnRzW2NvbXBfaWRdLmNvZGUuY29uZmlnID0gbWxhYi5kdC5jb21wb25lbnRzW2NvbXBfaWRdLmNvbmY7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBtbGFiLmR0LmNvbXBvbmVudHNbY29tcF9pZF07XFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMuYWNjZXNzaWJsZSAmJiAhYy5pc19zdG9yYWdlX3BsdWdpbikge1xcblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3ByZXBhcmUgdGhlIHRvb2x0aXBzIChyZWd1bGFyL2V4dGVuZGVkKS4gQ2FuIGJlIGEgc3RyaW5nLCBpbiB3aGljaCB1c2UgYXMgaXMsIG9yIGFuIGtleS12YWx1ZSBvYmplY3QsIGlmIGtleSB0aGF0IGVxdWFscyBtbGFiLmR0LmFwaS5nZXRMb2NhbGUoKSBpcyBmb3VuZCB1c2UgdGhpcywgaWYgbm90IGxvb2sgZm9yIG9uZSBjYWxsZWQgXFxcImRlZmF1bHRcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0dCA9IG1sYWIuZHQuYXBpLmdldExvY2FsZUNvbXBvbmVudE1lc3NhZ2UoY29tcF9pZCwgW1xcXCJ0b29sdGlwXFxcIl0pO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHRlID0gbWxhYi5kdC5hcGkuZ2V0TG9jYWxlQ29tcG9uZW50TWVzc2FnZShjb21wX2lkLCBbXFxcImZvb3Rlcl90aXBcXFwiXSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlTmFtZSA9IG1sYWIuZHQuYXBpLmdldExvY2FsZUNvbXBvbmVudE1lc3NhZ2UoY29tcF9pZCwgW1xcXCJleHRlbmRlZF9uYW1lXFxcIl0pO1xcblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RoZSBjYXRlZ29yeSBzZXR0aW5nIGluIHRoZSBjb25mLnltbCBmaWxlc1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbXBvbmVudHNfaHRtbFtjLmNvbmYuY2F0ZWdvcnldID09IFxcXCJ1bmRlZmluZWRcXFwiKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRzX2h0bWxbYy5jb25mLmNhdGVnb3J5XSA9IFtdO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcnlfdHJhbnNsYXRpb25zW2MuY29uZi5jYXRlZ29yeV0gPSBtbGFiLmR0LmFwaS5nZXRMb2NhbGVDb21wb25lbnRNZXNzYWdlKGNvbXBfaWQsIFtcXFwiY2F0ZWdvcnlfbmFtZVxcXCJdKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYy5pc19mZWF0dXJlKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wX3R5cGUgPSBcXFwiZmVhdHVyZVxcXCI7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wX3R5cGUgPSBcXFwiY29tcG9uZW50XFxcIjtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9zID0gdGVtcF9jb21wX29yZGVyLmluZGV4T2YocGFyc2VJbnQoYy5vcmRlcl9ieSkpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGVtcF9jb21wX29yZGVyW3Bvc107XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHNfaHRtbFtjLmNvbmYuY2F0ZWdvcnldW3Bvc10gPSBcXFwiPGRpdiBkYXRhLW1sYWItdHlwZT0nXFxcIiArIGNvbXBfaWQgKyBcXFwiJyBcXFwiICsgXFxcIm9uY2xpY2s9J21sYWIuZHQuZGVzaWduLlxcXCIgKyBjb21wX3R5cGUgKyBcXFwiX2FkZChcXFxcXFxcIlxcXCIgKyBjb21wX2lkICsgXFxcIlxcXFxcXFwiKTsnIFxcXCIgKyBcXFwidGl0bGU9J1xcXCIgKyB0dCArIFxcXCInIFxcXCIgKyBcXFwiY2xhc3M9J21sYWJfYnV0dG9uX2NvbXBvbmVudHMnIFxcXCIgKyBcXFwic3R5bGU9J2JhY2tncm91bmQtaW1hZ2U6IHVybChcXFxcXFxcIlxcXCIgKyBtbGFiLmR0LmNvbmZpZy51cmxzLmNvbXBvbmVudCArIGNvbXBfaWQgKyBcXFwiL1xcXCIgKyBtbGFiLmR0LmNvbmZpZy5jb21wb25lbnRfZmlsZXMuSUNPTiArIFxcXCJcXFxcXFxcIik7Jz5cXFwiICsgXFxcIjwvZGl2PlxcXCIgKyBcXFwiPGRpdiBjbGFzcz0nbWxhYl9jb21wb25lbnRfZm9vdGVyX3RpcCc+XFxcIiArIHR0ZSArIFxcXCI8L2Rpdj5cXFwiO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYy5hY2Nlc3NpYmxlICYmIGMuaXNfc3RvcmFnZV9wbHVnaW4pIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWxhYi5kdC5zdG9yYWdlX3BsdWdpbnNbY29tcF9pZF0gPSBlTmFtZTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgICAgICAvL1RPRE8gbm93IGZpcnN0IGNhdGVnb3J5IGlzIGhhcmRjb2RlZCB0byBiZSB0ZXh0Li4uXFxuICAgICAgICAgICAgICAgICAgICAvL0lmIHRoZSBmaXJzdCBjYXRlZ29yeSBvZiBjb21wb25lbnRzIGRvZXMgbm90IGhhdmUgYSBjb29raWUgaXQgbW9zdGUgbGlrZWx5IHRoYXQgbm9uZSBvZiB0aGUgbWxhYkNvbXBDYXR4eHggY29va2llcyBhcmUgbWFkZSAoZmlyc3QgdGltZSB1c2VycyBvciBkZWxldGVkIGNvb2tpZXMpIC0gc28gc2V0IHRoZSBmaXJzdCBjYXRlZ3JveSB0byBleHBhbmQgXFxuICAgICAgICAgICAgICAgICAgICB2YXIgY29va2llRXhpc3RzID0gbWxhYi5kdC51dGlscy5nZXRDb29raWUoXFxcIm1sYWJDb21wQ2F0dGV4dFxcXCIpO1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvb2tpZUV4aXN0cyA9PT0gMSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vQ29va2llIGZvciBmaXJzdCBjYXRlZ29yeSBub3QgZm91bmQgLSBzZXQgY29va2llIHNvIGl0IHdpbGwgYmUgZXhwYW5kZWRcXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jb29raWUgPSBcXFwibWxhYkNvbXBDYXR0ZXh0PTA7IGV4cGlyZXM9VGh1LCAxOCBEZWMgMjA1MyAxMjowMDowMCBVVEM7IHBhdGg9L1xcXCI7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgICAgICAvL1B1dHMgYWxsIGNvbXBvbmVudHMgdW5kZXIgdGhlIHNhbWUgY2F0ZWdvcnkgYW5kIGFkZHMgYW4gYWNjb3JkaW9uIHRvIHRoZSBjYXRlZ3JveSBjb2xsYXBzZWQgb3IgZXhwYW5kZWQgZGVwZW5kaW5nIG9uIHRoZSBjb29ja2llIHN0YXRlIFxcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjYXRlZ29yeSBpbiBjb21wb25lbnRzX2h0bWwpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWN0aXZlQ2F0ID0gTnVtYmVyKG1sYWIuZHQudXRpbHMuZ2V0Q29va2llKFxcXCJtbGFiQ29tcENhdFxcXCIgKyBjYXRlZ29yeSkpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICQoXFxcIjxkaXY+PGgzIGRhdGEtbWxhYi1jYXRlZ29yeT0nXFxcIiArIGNhdGVnb3J5ICsgXFxcIic+PGRpdiBjbGFzcz0nbWxhYl9jYXRlZ29yeV9uYW1lJz5cXFwiICsgY2F0ZWdvcnlfdHJhbnNsYXRpb25zW2NhdGVnb3J5XSArIFxcXCI8L2Rpdj48L2gzPjxkaXY+XFxcIiArIGNvbXBvbmVudHNfaHRtbFtjYXRlZ29yeV0uam9pbihcXFwiXFxcIikgKyBcXFwiPC9kaXY+PC9kaXY+XFxcIikuYXBwZW5kVG8oXFxcIiNtbGFiX3Rvb2xiYXJfY29tcG9uZW50c1xcXCIpLmFjY29yZGlvbih7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodFN0eWxlOiBcXFwiY29udGVudFxcXCIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZTogYWN0aXZlQ2F0LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsYXBzaWJsZTogdHJ1ZVxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICAgICAgLy9maW5hbGx5IHdlIGFzc2lnbiB0aGUgQVBJIG9iamVjdCB0byB0aGUgY29tcG9uZW50LCBjYW5ub3QgZG8gdGhpcyBlYXJsaWVyIGFzIGl0IHdvdWxkIGNyZWF0ZSBhIGxvb3AgdG8gcGFyZW50cywgZXRjIFxcbiAgICAgICAgICAgICAgICAgICAgLy93aGVuIHRyeWluZyB0byBtZXJnZSBwcm9wZXJ0aWVzIGluIHRoZSBwcmV2aW91cyBjb2RlIGJsb2NrXFxuICAgICAgICAgICAgICAgICAgICBmb3IgKGluZGV4IGluIG1sYWIuZHQuY29tcG9uZW50cykge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWxhYi5kdC5jb21wb25lbnRzW2luZGV4XS5jb2RlICE9IFxcXCJ1bmRlZmluZWRcXFwiICYmIG1sYWIuZHQuY29tcG9uZW50c1tpbmRleF0uY29kZSAhPT0gZmFsc2UpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWxhYi5kdC5jb21wb25lbnRzW2luZGV4XS5jb2RlLmFwaSA9IG1sYWIuZHQuYXBpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2FkZGVkIHRvIGluaGVyaXQgSFRNTCB0byB0aGUgYWRkaXRpb25hbCBtbGFiLmR0LmNvbXBvbmVudHMuaHRtbCB3aGljaCBpcyBzZXQgaW4gbG9hZFNpbmdsZUNvbXBvbmVudCBpbiAvc3JjL1NpbmV0dC9NTEFCL0J1aWxkZXJCdW5kbGUvRmlsZU1hbmFnZW1lbnQvRmlsZU1hbmFnZW1lbnQucGhwXFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtbGFiLmR0LmNvbXBvbmVudHNbaW5kZXhdLmh0bWwgJiYgbWxhYi5kdC5jb21wb25lbnRzW2luZGV4XS5jb25mLmluaGVyaXQpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWxhYi5kdC5jb21wb25lbnRzW2luZGV4XS5odG1sID0gbWxhYi5kdC5jb21wb25lbnRzW21sYWIuZHQuY29tcG9uZW50c1tpbmRleF0uY29uZi5pbmhlcml0XS5odG1sO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgICAgIC8vc2V0IHRoZSBleHRlbmRlZCBoZWxwIHRleHQgZm9yIHRoZSBjb21wb25lbnQgaW4gdGhlIGZvb3RlclxcbiAgICAgICAgICAgICAgICAgICAgJChcXFwiLm1sYWJfYnV0dG9uX2NvbXBvbmVudHNcXFwiKS5tb3VzZW92ZXIoZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAkKFxcXCIubWxhYl9lZGl0b3JfZm9vdGVyX2hlbHBcXFwiKS50ZXh0KGUuY3VycmVudFRhcmdldC5uZXh0U2libGluZy50ZXh0Q29udGVudCk7XFxuICAgICAgICAgICAgICAgICAgICB9KTtcXG5cXG4gICAgICAgICAgICAgICAgICAgICQoXFxcIi5tbGFiX2J1dHRvbl9jb21wb25lbnRzXFxcIikubW91c2VvdXQoZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAkKFxcXCIubWxhYl9lZGl0b3JfZm9vdGVyX2hlbHBcXFwiKS50ZXh0KFxcXCJcXFwiKTtcXG4gICAgICAgICAgICAgICAgICAgIH0pO1xcblxcbiAgICAgICAgICAgICAgICAgICAgLy93ZSBhbHdheXMgbG9hZCBwYWdlcyB1c2luZyBBSkFYLCB0aGlzIHRha2VzIHRoZSBwYXJhbWV0ZXJzIHBhc3NlZCBmcm9tIHRoZSBjb250cm9sbGVyXFxuICAgICAgICAgICAgICAgICAgICBtbGFiLmR0Lm1hbmFnZW1lbnQuYXBwX29wZW4oZG9jdW1lbnQubWxhYl90ZW1wX3ZhcnMuYXBwX2lkLCBkb2N1bWVudC5tbGFiX3RlbXBfdmFycy5wYWdlX251bSk7XFxuXFxuICAgICAgICAgICAgICAgICAgICAvL2VyYXNlIHRoZSB0ZW1wb3JhcnkgdmFyaWFibGUsIHRoaXMgaXMgdXNlZCBpbiBpbml0aXRhbGlzYXRpb24gcHJvY2VzcyBvbmx5LlxcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGRvY3VtZW50Lm1sYWJfdGVtcF92YXJzO1xcblxcbiAgICAgICAgICAgICAgICAgICAgLy9wcmVwYXJlIHRoZSBtZW51IHBvcHVwIGZvciB0aGUgc3RvcmFnZSBwbHVnaW4gc2VsZWN0b3JcXG4gICAgICAgICAgICAgICAgICAgIC8qU1BTUCAgICAgICAgICAgICAgICAgICAgICAgICQoXFxcIltkYXRhLW1sYWItY29tcC10b29sPSdzdG9yYWdlX3BsdWdpbiddXFxcIikuY2xpY2soIGZ1bmN0aW9uKGV2ZW50KSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtbGFiLmR0LmFwaS5jbG9zZUFsbFByb3BlcnR5RGlhbG9ncygpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG93bmVyX2VsZW1lbnQgPSBldmVudC5jdXJyZW50VGFyZ2V0O1xcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWxhYi5kdC5hcGkucHJvcGVydGllc190b29sdGlwID0gJChvd25lcl9lbGVtZW50KS5xdGlwKHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb2xvOiBmYWxzZSxcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAgICB7dGV4dDogJChcXFwiZGF0YS1tbGFiLWdldC1pbmZvPSdzdG9yYWdlX3BsdWdpbnMnXFxcIikuY2xvbmUoKSwgdGl0bGU6IF90cltcXFwibWxhYl9lZGl0b3IuaW5pdC5qcy5xdGlwLmNvbXAuc3RvcmFnZS5wbHVnaW4udGl0bGVcXFwiXSwgYnV0dG9uOiB0cnVlIH0sXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICAgeyBteTogJ2xlZnRNaWRkbGUnLCBhdDogJ3JpZ2h0TWlkZGxlJywgYWRqdXN0OiB7IHNjcmVlbjogdHJ1ZSB9IH0sXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvdzogICAgICAgeyByZWFkeTogdHJ1ZSwgbW9kYWw6IHsgb246IHRydWUsIGJsdXI6IGZhbHNlIH0gfSxcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWRlOiAgICAgICBmYWxzZSxcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudHM6ICAgICB7IGhpZGU6IGZ1bmN0aW9uKGV2ZW50LCBhcGkpIHsgYXBpLmRlc3Ryb3koKTsgbWxhYi5kdC5hcGkucHJvcGVydGllc190b29sdGlwID0gZmFsc2U7IH0gfSxcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogICAgICB7IGNsYXNzZXM6IFxcXCJtbGFiX3ppbmRleF90b3BfdG9vbHRpcFxcXCIsIHRpcDogdHJ1ZSB9XFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSApOyovXFxuXFxuICAgICAgICAgICAgICAgICAgICAvL2FkZCBzcGlubmVyIHRvIHRoZSBzdGF0dXNiYXIgdG8gc2hvdyB3aGVuIG5lZWRlZCAgICAgICAgICAgICAgICAgICBcXG4gICAgICAgICAgICAgICAgICAgICQoXFxcIiNtbGFiX3N0YXR1c2Jhcl9wcm9ncmVzc19zcGluXFxcIikuc3Bpbignc21hbGwnLCAnI2ZmZicpO1xcblxcbiAgICAgICAgICAgICAgICAgICAgLy9hc3NpZ24gY2xpY2sgZnVuY3Rpb25zIHRvIHRvb2xzXFxuICAgICAgICAgICAgICAgICAgICAkKFxcXCJbZGF0YS1tbGFiLWNvbXAtdG9vbD0nbW92ZV91cCddXFxcIikub24oXFxcImNsaWNrXFxcIiwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIG1sYWIuZHQuZGVzaWduLmNvbXBvbmVudF9tb3ZldXAoKTtcXG4gICAgICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICAgICAgJChcXFwiW2RhdGEtbWxhYi1jb21wLXRvb2w9J21vdmVfZG93biddXFxcIikub24oXFxcImNsaWNrXFxcIiwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIG1sYWIuZHQuZGVzaWduLmNvbXBvbmVudF9tb3ZlZG93bigpO1xcbiAgICAgICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgICAgICAkKFxcXCJbZGF0YS1tbGFiLWNvbXAtdG9vbD0nZGVsZXRlJ11cXFwiKS5vbihcXFwiY2xpY2tcXFwiLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbWxhYi5kdC5kZXNpZ24uY29tcG9uZW50X2RlbGV0ZSgpO1xcbiAgICAgICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgICAgICAkKFxcXCJbZGF0YS1tbGFiLWNvbXAtdG9vbD0naGVscCddXFxcIikub24oXFxcImNsaWNrXFxcIiwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIG1sYWIuZHQuZGVzaWduLmNvbXBvbmVudF9oZWxwKCk7XFxuICAgICAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgICAgICQoXFxcIltkYXRhLW1sYWItY29tcC10b29sPSdjdXQnXVxcXCIpLm9uKFxcXCJjbGlja1xcXCIsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBtbGFiLmR0LmRlc2lnbi5jb21wb25lbnRfY3V0KCk7XFxuICAgICAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgICAgICQoXFxcIltkYXRhLW1sYWItY29tcC10b29sPSdjb3B5J11cXFwiKS5vbihcXFwiY2xpY2tcXFwiLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbWxhYi5kdC5kZXNpZ24uY29tcG9uZW50X2NvcHkoKTtcXG4gICAgICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICAgICAgJChcXFwiW2RhdGEtbWxhYi1jb21wLXRvb2w9J3Bhc3RlJ11cXFwiKS5vbihcXFwiY2xpY2tcXFwiLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbWxhYi5kdC5kZXNpZ24uY29tcG9uZW50X3Bhc3RlKCk7XFxuICAgICAgICAgICAgICAgICAgICB9KTtcXG5cXG4gICAgICAgICAgICAgICAgICAgICQoXFxcIltkYXRhLW1sYWItY29tcC10b29sPSdyZWRvJ11cXFwiKS5vbihcXFwiY2xpY2tcXFwiLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZXhlY0NvbW1hbmQoXFxcInJlZG9cXFwiKTtcXG4gICAgICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICAgICAgJChcXFwiW2RhdGEtbWxhYi1jb21wLXRvb2w9J3VuZG8nXVxcXCIpLm9uKFxcXCJjbGlja1xcXCIsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5leGVjQ29tbWFuZChcXFwidW5kb1xcXCIpO1xcbiAgICAgICAgICAgICAgICAgICAgfSk7XFxuXFxuICAgICAgICAgICAgICAgICAgICAkKFxcXCIjbWxhYl9wYWdlX2NvbnRyb2xfdGl0bGVcXFwiKS5vbihcXFwiY2xpY2tcXFwiLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbWxhYi5kdC5hcGkuZWRpdENvbnRlbnQodGhpcyk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgJCgnI21sYWJfcGFnZV9jb250cm9sX3RpdGxlX2FjdGlvbnMnKS5zaG93KCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgJCgnI21sYWJfcGFnZV9jb250cm9sX3RpdGxlJykuYXR0cigndGl0bGUnLCBfdHJbXFxcImFwcC5idWlsZGVyLnBhZ2UudG9vbHRpcC5wYWdlLm5hbWUuZWRpdFxcXCJdKTtcXG4gICAgICAgICAgICAgICAgICAgIH0pO1xcblxcbiAgICAgICAgICAgICAgICAgICAgJChcXFwiI21sYWJfcGFnZV9jb250cm9sX3NhdmVfdGl0bGVcXFwiKS5vbihcXFwiY2xpY2tcXFwiLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgJCgnI21sYWJfcGFnZV9jb250cm9sX3RpdGxlX2FjdGlvbnMnKS5oaWRlKCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgJCgnI21sYWJfcGFnZV9jb250cm9sX3RpdGxlJykuYXR0cigndGl0bGUnLCBfdHJbXFxcImFwcC5idWlsZGVyLnBhZ2UudG9vbHRpcC5wYWdlLm5hbWVcXFwiXSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbWxhYi5kdC5tYW5hZ2VtZW50LnBhZ2VfdXBkYXRlX3RpdGxlKCk7XFxuICAgICAgICAgICAgICAgICAgICB9KTtcXG5cXG4gICAgICAgICAgICAgICAgICAgICQoXFxcIiNtbGFiX3BhZ2VfY29udHJvbF9jYW5jZWxfdGl0bGVcXFwiKS5vbihcXFwiY2xpY2tcXFwiLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgJCgnI21sYWJfcGFnZV9jb250cm9sX3RpdGxlX2FjdGlvbnMnKS5oaWRlKCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgJCgnI21sYWJfcGFnZV9jb250cm9sX3RpdGxlJykuYXR0cigndGl0bGUnLCBfdHJbXFxcImFwcC5idWlsZGVyLnBhZ2UudG9vbHRpcC5wYWdlLm5hbWVcXFwiXSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgJCgnI21sYWJfcGFnZV9jb250cm9sX3RpdGxlJykudGV4dChtbGFiLmR0LmFwcC5jdXJyX3BhZ2V0aXRsZSk7XFxuICAgICAgICAgICAgICAgICAgICB9KTtcXG5cXG4gICAgICAgICAgICAgICAgICAgICQoXFxcIiNtbGFiX3BhZ2VfY29udHJvbF9uZXdcXFwiKS5vbihcXFwiY2xpY2tcXFwiLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbWxhYi5kdC5tYW5hZ2VtZW50LnBhZ2VfbmV3KCk7XFxuICAgICAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgICAgICQoXFxcIiNtbGFiX3BhZ2VfY29udHJvbF9pbXBvcnRcXFwiKS5vbihcXFwiY2xpY2tcXFwiLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgJChcXFwiI21sYWJfZGlhbG9nX2ltcG9ydFxcXCIpLmRpYWxvZyh7IHJlc2l6YWJsZTogZmFsc2UsIGhlaWdodDogMTIwLCBtb2RhbDogdHJ1ZSB9KTtcXG4gICAgICAgICAgICAgICAgICAgIH0pO1xcblxcbiAgICAgICAgICAgICAgICAgICAgJChcXFwiI21sYWJfcGFnZV9jb250cm9sX2RlbGV0ZVxcXCIpLm9uKFxcXCJjbGlja1xcXCIsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBtbGFiLmR0Lm1hbmFnZW1lbnQucGFnZV9kZWxldGUoKTtcXG4gICAgICAgICAgICAgICAgICAgIH0pO1xcblxcbiAgICAgICAgICAgICAgICAgICAgJChcXFwiI21sYWJfcGFnZV9oZWxwXFxcIikub24oXFxcImNsaWNrXFxcIiwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VfaGVscChldmVudCk7XFxuICAgICAgICAgICAgICAgICAgICB9KTtcXG5cXG4gICAgICAgICAgICAgICAgICAgIC8vdHJ1biBvbiBhbmQgb2ZmIGZvb3RlciBoZWxwXFxuICAgICAgICAgICAgICAgICAgICAkKFxcXCIjbWxhYl9idXR0b25faGVscFxcXCIpLm9uKFxcXCJjbGlja1xcXCIsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBtbGFiLmR0LmRlc2lnbi50b2dnbGVfZm9vdGVyKCk7XFxuICAgICAgICAgICAgICAgICAgICB9KTtcXG5cXG4gICAgICAgICAgICAgICAgICAgIC8vQ2hlY2tzIGlmIHRoZSBlZGl0b3IgbWVudSBpY29uIGlzIGNsaWtlZFxcbiAgICAgICAgICAgICAgICAgICAgJChcXFwiI21sYWJfZWRpdG9yX21lbnVfZHJvcGRvd25cXFwiKS5vbihcXFwiY2xpY2tcXFwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJCgnI21sYWJfdXNlcl9tZW51X2Ryb3Bkb3duX2NvbnRlbnQnKS5oYXNDbGFzcygnbWxhYl9zaG93X3VzZXJfZHJvcGRvd24nKSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1VzZXIgbWVudSBpcyBvcGVuIGFuZCBuZWVkcyB0byBiZSBjbG9zZWQgXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoJyNtbGFiX3VzZXJfbWVudV9kcm9wZG93bl9jb250ZW50JykudG9nZ2xlQ2xhc3MoJ21sYWJfc2hvd191c2VyX2Ryb3Bkb3duJyk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoJyNtbGFiX3VzZXJfbWVudV9kcm9wZG93bicpLnRvZ2dsZUNsYXNzKCdtbGFiX3Nob3dfdXNlcl9kcm9wZG93bl90YWJfc2VsZWN0ZWQnKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAgICAgLy9Ub2dnbGVzIHRoZSBFZGl0b3IgbWVudSBvbiBhbmQgb2ZmXFxuICAgICAgICAgICAgICAgICAgICAgICAgJCgnI21sYWJfZWRpdG9yX21lbnVfZHJvcGRvd25fY29udGVudCcpLnRvZ2dsZUNsYXNzKCdtbGFiX3Nob3dfZWRpdG9yX2Ryb3Bkb3duJyk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgJCgnI21sYWJfZWRpdG9yX21lbnVfZHJvcGRvd24nKS50b2dnbGVDbGFzcygnbWxhYl9zaG93X2VkaXRvcl9kcm9wZG93bl90YWJfc2VsZWN0ZWQnKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcXG4gICAgICAgICAgICAgICAgICAgIH0pO1xcblxcbiAgICAgICAgICAgICAgICAgICAgLy9DaGVja3MgaWYgdGhlIHVzZXIgbWVudSBpY29uIGlzIGNsaWtlZFxcbiAgICAgICAgICAgICAgICAgICAgJChcXFwiI21sYWJfdXNlcl9tZW51X2Ryb3Bkb3duXFxcIikub24oXFxcImNsaWNrXFxcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCQoJyNtbGFiX2VkaXRvcl9tZW51X2Ryb3Bkb3duX2NvbnRlbnQnKS5oYXNDbGFzcygnbWxhYl9zaG93X2VkaXRvcl9kcm9wZG93bicpKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vRWRpdG9yIG1lbnUgaXMgb3BlbiBhbmQgbmVlZHMgdG8gYmUgY2xvc2VkIFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKCcjbWxhYl9lZGl0b3JfbWVudV9kcm9wZG93bl9jb250ZW50JykudG9nZ2xlQ2xhc3MoJ21sYWJfc2hvd19lZGl0b3JfZHJvcGRvd24nKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJCgnI21sYWJfZWRpdG9yX21lbnVfZHJvcGRvd24nKS50b2dnbGVDbGFzcygnbWxhYl9zaG93X2VkaXRvcl9kcm9wZG93bl90YWJfc2VsZWN0ZWQnKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAgICAgLy9Ub2dnbGVzIHRoZSBVc2VyIG1lbnUgb24gYW5kIG9mZlxcbiAgICAgICAgICAgICAgICAgICAgICAgICQoJyNtbGFiX3VzZXJfbWVudV9kcm9wZG93bl9jb250ZW50JykudG9nZ2xlQ2xhc3MoJ21sYWJfc2hvd191c2VyX2Ryb3Bkb3duJyk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgJCgnI21sYWJfdXNlcl9tZW51X2Ryb3Bkb3duJykudG9nZ2xlQ2xhc3MoJ21sYWJfc2hvd191c2VyX2Ryb3Bkb3duX3RhYl9zZWxlY3RlZCcpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xcbiAgICAgICAgICAgICAgICAgICAgfSk7XFxuXFxuICAgICAgICAgICAgICAgICAgICAvL0NoZWNrZXMgaWYgdGhlIHBhZ2UgbWVudSBpY29uIGlzIGNsaWtlZFxcbiAgICAgICAgICAgICAgICAgICAgJChcXFwiI21sYWJfcGFnZV9jb250cm9sX3BhZ2VsaXN0XFxcIikub24oXFxcImNsaWNrXFxcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgLy9Vc2VyIG1lbnUgaXMgb3BlbiBhbmQgbmVlZHMgdG8gYmUgY2xvc2VkIFxcbiAgICAgICAgICAgICAgICAgICAgICAgICQoJyNtbGFiX3BhZ2VfbWFuYWdlbWVudCcpLnRvZ2dsZUNsYXNzKCdtbGFiX3Nob3cnKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcXG4gICAgICAgICAgICAgICAgICAgIH0pO1xcblxcbiAgICAgICAgICAgICAgICAgICAgLy9MaXN0ZW5zIGZvciBhbnkgY2xpY2tcXG4gICAgICAgICAgICAgICAgICAgICQoZG9jdW1lbnQpLm9uKCdjbGljaycsIGZ1bmN0aW9uIChldmVudCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrcyBpZiBlZGl0b3IgbWVudSBpcyBvcGVuXFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCQoJyNtbGFiX2VkaXRvcl9tZW51X2Ryb3Bkb3duX2NvbnRlbnQnKS5oYXNDbGFzcygnbWxhYl9zaG93X2VkaXRvcl9kcm9wZG93bicpKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vRWRpdG9yIG1lbnUgaXMgb3BlbiAtIGNsb3NlIGl0XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoJyNtbGFiX2VkaXRvcl9tZW51X2Ryb3Bkb3duX2NvbnRlbnQnKS50b2dnbGVDbGFzcygnbWxhYl9zaG93X2VkaXRvcl9kcm9wZG93bicpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKCcjbWxhYl9lZGl0b3JfbWVudV9kcm9wZG93bicpLnRvZ2dsZUNsYXNzKCdtbGFiX3Nob3dfZWRpdG9yX2Ryb3Bkb3duX3RhYl9zZWxlY3RlZCcpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVja3MgaWYgdXNlciBtZW51IGlzIG9wZW5cXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJCgnI21sYWJfdXNlcl9tZW51X2Ryb3Bkb3duX2NvbnRlbnQnKS5oYXNDbGFzcygnbWxhYl9zaG93X3VzZXJfZHJvcGRvd24nKSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1VzZXIgbWVudSBpcyBvcGVuIC0gY2xvc2UgaXRcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJCgnI21sYWJfdXNlcl9tZW51X2Ryb3Bkb3duX2NvbnRlbnQnKS50b2dnbGVDbGFzcygnbWxhYl9zaG93X3VzZXJfZHJvcGRvd24nKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJCgnI21sYWJfdXNlcl9tZW51X2Ryb3Bkb3duJykudG9nZ2xlQ2xhc3MoJ21sYWJfc2hvd191c2VyX2Ryb3Bkb3duX3RhYl9zZWxlY3RlZCcpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVja3MgaWYgcGFnZSBtZW51IGlzIG9wZW5cXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJCgnI21sYWJfcGFnZV9tYW5hZ2VtZW50JykuaGFzQ2xhc3MoJ21sYWJfc2hvdycpKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vVXNlciBtZW51IGlzIG9wZW4gYW5kIG5lZWRzIHRvIGJlIGNsb3NlZCBcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJCgnI21sYWJfcGFnZV9tYW5hZ2VtZW50JykudG9nZ2xlQ2xhc3MoJ21sYWJfc2hvdycpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIH0pO1xcblxcbiAgICAgICAgICAgICAgICAgICAgLy9zYXZlIHBhZ2UgYnV0dG9uIGluIHRoZSBlZGl0b3IgbWVudSBcXG4gICAgICAgICAgICAgICAgICAgICQoXFxcIiNtbGFiX3BhZ2Vfc2F2ZV9hbGxcXFwiKS5vbihcXFwiY2xpY2tcXFwiLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXA7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbWxhYi5kdC5tYW5hZ2VtZW50LnBhZ2Vfc2F2ZSh0ZW1wLCB0cnVlKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAvL0VkaXRvciBtZW51IGlzIG9wZW4gLSBjbG9zZSBpdFxcbiAgICAgICAgICAgICAgICAgICAgICAgICQoJyNtbGFiX2VkaXRvcl9tZW51X2Ryb3Bkb3duX2NvbnRlbnQnKS50b2dnbGVDbGFzcygnbWxhYl9zaG93X2VkaXRvcl9kcm9wZG93bicpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICQoJyNtbGFiX2VkaXRvcl9tZW51X2Ryb3Bkb3duJykudG9nZ2xlQ2xhc3MoJ21sYWJfc2hvd19lZGl0b3JfZHJvcGRvd25fdGFiX3NlbGVjdGVkJyk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgICAgICAgICAgICAgfSk7XFxuXFxuICAgICAgICAgICAgICAgICAgICAkKFxcXCJbZGF0YS1tbGFiLWNvbXAtdG9vbD0nc3RvcmFnZV9wbHVnaW4nXVxcXCIpLm9uKFxcXCJjbGlja1xcXCIsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWwgPSAkKHRoaXMpLnNpYmxpbmdzKFxcXCJbZGF0YS1tbGFiLWdldC1pbmZvPSdzdG9yYWdlX3BsdWdpbnMnXVxcXCIpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZWwuaXMoXFxcIjp2aXNpYmxlXFxcIikpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwuaHRtbChtbGFiLmR0LmFwaS5nZXRTdG9yYWdlUGx1Z2luTGlzdChtbGFiLmR0LmFwaS5nZXRTZWxlY3RlZENvbXBvbmVudCgpKSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLnNsaWRlVG9nZ2xlKCk7XFxuICAgICAgICAgICAgICAgICAgICB9KTtcXG5cXG4gICAgICAgICAgICAgICAgICAgICQoXFxcIltkYXRhLW1sYWItY29tcC10b29sPSdjcmVkZW50aWFscyddXFxcIikub24oXFxcImNsaWNrXFxcIiwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIG1sYWIuZHQuZGVzaWduLmNvbXBvbmVudF9lZGl0X2NyZWRlbnRpYWxzKCk7XFxuICAgICAgICAgICAgICAgICAgICB9KTtcXG5cXG4gICAgICAgICAgICAgICAgICAgIC8vcHJlcGFyZSB0aGUgbWVudSBwb3B1cCBmb3IgdGhlIGNvbXBvbmVudCByZXNpemVyXFxuICAgICAgICAgICAgICAgICAgICAkKFxcXCJbZGF0YS1tbGFiLWNvbXAtdG9vbD0nY29tcF9zaXplJ11cXFwiKS5vbihcXFwiY2xpY2tcXFwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBtbGFiLmR0LmFwaS5jbG9zZUFsbFByb3BlcnR5RGlhbG9ncygpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvd25lcl9lbGVtZW50ID0gZXZlbnQuY3VycmVudFRhcmdldDtcXG4gICAgICAgICAgICAgICAgICAgICAgICBtbGFiLmR0LmFwaS5wcm9wZXJ0aWVzX3Rvb2x0aXAgPSAkKG93bmVyX2VsZW1lbnQpLnF0aXAoe1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb2xvOiBmYWxzZSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogeyB0ZXh0OiAkKFxcXCIjbWxhYl9jb21wb25lbnRfc2l6ZV9saXN0XFxcIikuY2xvbmUoKSwgdGl0bGU6IF90cltcXFwibWxhYl9lZGl0b3IuaW5pdC5qcy5xdGlwLmNvbXAuc2l6ZS50aXRsZVxcXCJdLCBidXR0b246IHRydWUgfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHsgbXk6ICdsZWZ0TWlkZGxlJywgYXQ6ICdyaWdodE1pZGRsZScsIHZpZXdwb3J0OiAkKHdpbmRvdykgfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvdzogeyByZWFkeTogdHJ1ZSwgbW9kYWw6IHsgb246IHRydWUsIGJsdXI6IGZhbHNlIH0gfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlkZTogZmFsc2UsXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7IGNsYXNzZXM6IFxcXCJtbGFiX3ppbmRleF90b3BfdG9vbHRpcFxcXCIsIHRpcDogdHJ1ZSB9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudHM6IHsgaGlkZTogZnVuY3Rpb24gaGlkZShldmVudCwgYXBpKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBpLmRlc3Ryb3koKTttbGFiLmR0LmFwaS5wcm9wZXJ0aWVzX3Rvb2x0aXAgPSBmYWxzZTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aXNpYmxlOiBmdW5jdGlvbiB2aXNpYmxlKCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoXFxcIltkYXRhLW1sYWItY29tcC1zaXplPSdzbWFsbCddXFxcIikub24oXFxcImNsaWNrXFxcIiwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtbGFiLmR0LmFwaS5kaXNwbGF5LnNldFNpemUoJChcXFwiLm1sYWJfY3VycmVudF9jb21wb25lbnRcXFwiKSwgXFxcInNtYWxsXFxcIik7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoXFxcIltkYXRhLW1sYWItZ2V0LWluZm89J2NvbXBfc2l6ZXMnXVxcXCIpLmhpZGUoKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKFxcXCJbZGF0YS1tbGFiLWNvbXAtc2l6ZT0nbWVkaXVtJ11cXFwiKS5vbihcXFwiY2xpY2tcXFwiLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1sYWIuZHQuYXBpLmRpc3BsYXkuc2V0U2l6ZSgkKFxcXCIubWxhYl9jdXJyZW50X2NvbXBvbmVudFxcXCIpLCBcXFwibWVkaXVtXFxcIik7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoXFxcIltkYXRhLW1sYWItZ2V0LWluZm89J2NvbXBfc2l6ZXMnXVxcXCIpLmhpZGUoKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKFxcXCJbZGF0YS1tbGFiLWNvbXAtc2l6ZT0nbGFyZ2UnXVxcXCIpLm9uKFxcXCJjbGlja1xcXCIsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWxhYi5kdC5hcGkuZGlzcGxheS5zZXRTaXplKCQoXFxcIi5tbGFiX2N1cnJlbnRfY29tcG9uZW50XFxcIiksIFxcXCJsYXJnZVxcXCIpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKFxcXCJbZGF0YS1tbGFiLWdldC1pbmZvPSdjb21wX3NpemVzJ11cXFwiKS5oaWRlKCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgICAgIH0pO1xcblxcbiAgICAgICAgICAgICAgICAgICAgLy9wcmVwYXJlIHRoZSBtZW51IHBvcHVwIGZvciB0aGUgY29tcG9uZW50IGFzcGVjdCByYXRpbyBzZWxlY3RvclxcbiAgICAgICAgICAgICAgICAgICAgJChcXFwiW2RhdGEtbWxhYi1jb21wLXRvb2w9J2NvbXBfYXNwZWN0J11cXFwiKS5vbihcXFwiY2xpY2tcXFwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBtbGFiLmR0LmFwaS5jbG9zZUFsbFByb3BlcnR5RGlhbG9ncygpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvd25lcl9lbGVtZW50ID0gZXZlbnQuY3VycmVudFRhcmdldDtcXG4gICAgICAgICAgICAgICAgICAgICAgICBtbGFiLmR0LmFwaS5wcm9wZXJ0aWVzX3Rvb2x0aXAgPSAkKG93bmVyX2VsZW1lbnQpLnF0aXAoe1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb2xvOiBmYWxzZSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogeyB0ZXh0OiAkKFxcXCIjbWxhYl9jb21wb25lbnRfYXNwZWN0X2xpc3RcXFwiKS5jbG9uZSgpLCB0aXRsZTogX3RyW1xcXCJtbGFiX2VkaXRvci5pbml0LmpzLnF0aXAuY29tcC5hc3BlY3QudGl0bGVcXFwiXSwgYnV0dG9uOiB0cnVlIH0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB7IG15OiAnbGVmdE1pZGRsZScsIGF0OiAncmlnaHRNaWRkbGUnLCB2aWV3cG9ydDogJCh3aW5kb3cpIH0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3c6IHsgcmVhZHk6IHRydWUsIG1vZGFsOiB7IG9uOiB0cnVlLCBibHVyOiBmYWxzZSB9IH0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZGU6IGZhbHNlLFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogeyBjbGFzc2VzOiBcXFwibWxhYl96aW5kZXhfdG9wX3Rvb2x0aXBcXFwiLCB0aXA6IHRydWUgfSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRzOiB7IGhpZGU6IGZ1bmN0aW9uIGhpZGUoZXZlbnQsIGFwaSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwaS5kZXN0cm95KCk7bWxhYi5kdC5hcGkucHJvcGVydGllc190b29sdGlwID0gZmFsc2U7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlzaWJsZTogZnVuY3Rpb24gdmlzaWJsZSgpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKFxcXCJbZGF0YS1tbGFiLWNvbXAtYXNwZWN0PSc0OjMnXVxcXCIpLm9uKFxcXCJjbGlja1xcXCIsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWxhYi5kdC5hcGkuZGlzcGxheS5zZXRBc3BlY3RSYXRpbygkKFxcXCIubWxhYl9jdXJyZW50X2NvbXBvbmVudFxcXCIpLCBcXFwiNDozXFxcIik7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoXFxcIltkYXRhLW1sYWItZ2V0LWluZm89J2NvbXBfYXNwZWN0cyddXFxcIikuaGlkZSgpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xcblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoXFxcIltkYXRhLW1sYWItY29tcC1hc3BlY3Q9JzE2OjknXVxcXCIpLm9uKFxcXCJjbGlja1xcXCIsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWxhYi5kdC5hcGkuZGlzcGxheS5zZXRBc3BlY3RSYXRpbygkKFxcXCIubWxhYl9jdXJyZW50X2NvbXBvbmVudFxcXCIpLCBcXFwiMTY6OVxcXCIpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKFxcXCJbZGF0YS1tbGFiLWdldC1pbmZvPSdjb21wX2FzcGVjdHMnXVxcXCIpLmhpZGUoKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKFxcXCJbZGF0YS1tbGFiLWNvbXAtYXNwZWN0PScxOjEnXVxcXCIpLm9uKFxcXCJjbGlja1xcXCIsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWxhYi5kdC5hcGkuZGlzcGxheS5zZXRBc3BlY3RSYXRpbygkKFxcXCIubWxhYl9jdXJyZW50X2NvbXBvbmVudFxcXCIpLCBcXFwiMToxXFxcIik7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoXFxcIltkYXRhLW1sYWItZ2V0LWluZm89J2NvbXBfYXNwZWN0cyddXFxcIikuaGlkZSgpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgICAgICB9KTtcXG5cXG4gICAgICAgICAgICAgICAgICAgIC8vcHJlcGFyZSBxdGlwIGZvciB0aGUgY3JlZGl0IG9mIHRoZSBpY29uIHVzZVxcbiAgICAgICAgICAgICAgICAgICAgJCgnI21sYWJfY3JlZGl0X2ljb25zJykucXRpcCh7XFxuICAgICAgICAgICAgICAgICAgICAgICAgaGlkZTogeyBkZWxheTogNTAwLCBmaXhlZDogdHJ1ZSB9LCAvL2dpdmUgYSBzbWFsbCBkZWxheVxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB7IG15OiAnbGVmdCBib3R0b20nLCBhdDogJ3JpZ2h0IGNlbnRlcicsIGFkanVzdDogeyBzY3JlZW46IHRydWUgfSB9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHsgdGV4dDogZnVuY3Rpb24gdGV4dCgpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkKFxcXCI8ZGl2PlRoZSBpY29ucyBvbiB0aGlzIHBhZ2UgYXJlIG1hZGUgYnkgPGEgaHJlZj0naHR0cDovL3d3dy5mcmVlcGlrLmNvbScgdGFyZ2V0PSdfYmxhbmsnIHRpdGxlPSdGcmVlcGlrJz5GcmVlcGlrPC9hPiwgPGEgaHJlZj0naHR0cDovL3d3dy5mbGF0aWNvbi5jb20vYXV0aG9ycy9zaW1wbGVpY29uJyB0YXJnZXQ9J19ibGFuaycgdGl0bGU9J1NpbXBsZUljb24nPlNpbXBsZUljb248L2E+LCA8YSBocmVmPSdodHRwOi8vd3d3LmZsYXRpY29uLmNvbS9hdXRob3JzL2RhdmUtZ2FuZHknIHRhcmdldD0nX2JsYW5rJyB0aXRsZT0nRGF2ZSBHYW5keSc+RGF2ZSBHYW5keTwvYT4sIDxhIGhyZWY9J2h0dHA6Ly93d3cuZmxhdGljb24uY29tL2F1dGhvcnMvYW50b24tc2FwdXRybycgdGFyZ2V0PSdfYmxhbmsnIHRpdGxlPSdBbnRvbiBTYXB1dHJvJz5BbnRvbiBTYXB1dHJvPC9hPiBhbmQgPGEgaHJlZj0naHR0cDovL3d3dy5mbGF0aWNvbi5jb20vYXV0aG9ycy95YW5uaWNrJyB0YXJnZXQ9J19ibGFuaycgdGl0bGU9J1lhbm5pY2snPllhbm5pY2s8L2E+IGZyb20gPGEgaHJlZj0naHR0cDovL3d3dy5mbGF0aWNvbi5jb20nIHRhcmdldD0nX2JsYW5rJyB0aXRsZT0nRmxhdGljb24nPnd3dy5mbGF0aWNvbi5jb208L2E+IGFuZCBhcmUgbGljZW5zZWQgYnkgPGEgaHJlZj0naHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnkvMy4wLycgdGFyZ2V0PSdfYmxhbmsnIHRpdGxlPSdDcmVhdGl2ZSBDb21tb25zIEJZIDMuMCc+Q0MgQlkgMy4wPC9hPiAtIGFuZCBtYW55IGFyZSBtYWRlIGJ5IHRoZSBTaW5ldHQgcHJvamVjdCBhdCBGRkkubm88L2Rpdj5cXFwiKS5odG1sKCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiB7IHRleHQ6IFxcXCJDcmVkaXQgZm9yIGljb25zXFxcIiB9IH0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHsgY2xhc3NlczogXFxcIm1sYWJfcXRpcF90b29sdGlwIG1sYWJfcXRpcF9tZW51X3Rvb2x0aXBcXFwiIH1cXG4gICAgICAgICAgICAgICAgICAgIH0pO1xcblxcbiAgICAgICAgICAgICAgICAgICAgLy9wcmVwYXJlIHF0aXAgZm9yIHRoZSBjcmVkaXQgb2YgdGhlIGljb24gdXNlXFxuICAgICAgICAgICAgICAgICAgICAkKCcjbWxhYl9jcmVkaXRfaWNvbnMnKS5xdGlwKHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBoaWRlOiB7IGRlbGF5OiA1MDAsIGZpeGVkOiB0cnVlIH0sIC8vZ2l2ZSBhIHNtYWxsIGRlbGF5XFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHsgbXk6ICdsZWZ0IGJvdHRvbScsIGF0OiAncmlnaHQgY2VudGVyJywgdmlld3BvcnQ6ICQod2luZG93KSB9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHsgdGV4dDogZnVuY3Rpb24gdGV4dCgpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkKFxcXCI8ZGl2PlRoZSBpY29ucyBvbiB0aGlzIHBhZ2UgYXJlIG1hZGUgYnkgPGEgaHJlZj0naHR0cDovL3d3dy5mcmVlcGlrLmNvbScgdGFyZ2V0PSdfYmxhbmsnIHRpdGxlPSdGcmVlcGlrJz5GcmVlcGlrPC9hPiwgPGEgaHJlZj0naHR0cDovL3d3dy5mbGF0aWNvbi5jb20vYXV0aG9ycy9zaW1wbGVpY29uJyB0YXJnZXQ9J19ibGFuaycgdGl0bGU9J1NpbXBsZUljb24nPlNpbXBsZUljb248L2E+LCA8YSBocmVmPSdodHRwOi8vd3d3LmZsYXRpY29uLmNvbS9hdXRob3JzL2RhdmUtZ2FuZHknIHRhcmdldD0nX2JsYW5rJyB0aXRsZT0nRGF2ZSBHYW5keSc+RGF2ZSBHYW5keTwvYT4sIDxhIGhyZWY9J2h0dHA6Ly93d3cuZmxhdGljb24uY29tL2F1dGhvcnMvYW50b24tc2FwdXRybycgdGFyZ2V0PSdfYmxhbmsnIHRpdGxlPSdBbnRvbiBTYXB1dHJvJz5BbnRvbiBTYXB1dHJvPC9hPiBhbmQgPGEgaHJlZj0naHR0cDovL3d3dy5mbGF0aWNvbi5jb20vYXV0aG9ycy95YW5uaWNrJyB0YXJnZXQ9J19ibGFuaycgdGl0bGU9J1lhbm5pY2snPllhbm5pY2s8L2E+IGZyb20gPGEgaHJlZj0naHR0cDovL3d3dy5mbGF0aWNvbi5jb20nIHRhcmdldD0nX2JsYW5rJyB0aXRsZT0nRmxhdGljb24nPnd3dy5mbGF0aWNvbi5jb208L2E+IGFuZCBhcmUgbGljZW5zZWQgYnkgPGEgaHJlZj0naHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnkvMy4wLycgdGFyZ2V0PSdfYmxhbmsnIHRpdGxlPSdDcmVhdGl2ZSBDb21tb25zIEJZIDMuMCc+Q0MgQlkgMy4wPC9hPiAtIGFuZCBtYW55IGFyZSBtYWRlIGJ5IHRoZSBTaW5ldHQgcHJvamVjdCBhdCBGRkkubm88L2Rpdj5cXFwiKS5odG1sKCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiB7IHRleHQ6IFxcXCJDcmVkaXQgZm9yIGljb25zXFxcIiB9IH0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHsgY2xhc3NlczogXFxcIm1sYWJfcXRpcF90b29sdGlwIG1sYWJfcXRpcF9tZW51X3Rvb2x0aXBcXFwiLCB0aXA6IHRydWUgfVxcbiAgICAgICAgICAgICAgICAgICAgfSk7XFxuXFxuICAgICAgICAgICAgICAgICAgICAvL3ByZXBhcmUgcXRpcCBmb3IgdGhlIGRvd25sb2FkIG9mIGFwcCBidXR0b25zXFxuICAgICAgICAgICAgICAgICAgICAkLmVhY2gobWxhYi5kdC5jb25maWcuY29tcGlsZXJfc2VydmljZS5zdXBwb3J0ZWRfcGxhdGZvcm1zLCBmdW5jdGlvbiAoaW5kZXgsIHBsYXRmb3JtKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgJCgnI21sYWJfZG93bmxvYWRfJyArIHBsYXRmb3JtICsgJ19pY29uJykucXRpcCh7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZGU6IHsgZGVsYXk6IDUwMCwgZml4ZWQ6IHRydWUgfSwgLy9naXZlIGEgc21hbGwgZGVsYXkgdG8gYWxsb3cgdGhlIHVzZXIgdCBtb3VzZSBvdmVyIGl0LlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiB7IHRleHQ6IGZ1bmN0aW9uIHRleHQoKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICQoXFxcIltkYXRhLW1sYWItZG93bmxvYWQtbGluay1pbmZvPSdcXFwiICsgcGxhdGZvcm0gKyBcXFwiJ11cXFwiKS5odG1sKCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHsgdGV4dDogX3RyW1xcXCJtbGFiX2VkaXRvci5pbml0LmpzLnF0aXAuZG93bmxvYWQuYXBwLnRpdGxlXFxcIl0gKyBcXFwiIFxcXCIgKyBwbGF0Zm9ybSB9IH0sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiB7IGNsYXNzZXM6IFxcXCJtbGFiX3F0aXBfdG9vbHRpcCBtbGFiX3F0aXBfbWVudV90b29sdGlwXFxcIiwgdGlwOiB0cnVlIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgYWxlcnQoX3RyW1xcXCJtbGFiX2VkaXRvci5pbml0LmpzLmNvbXBpbGluZy5mYWlsZWQubG9hZGluZy5jb21wc1xcXCJdKTtcXG4gICAgICAgICAgICAgICAgICAgIC8vZG9jdW1lbnQubG9jYXRpb24uaHJlZiA9IGRvY3VtZW50Lm1sYWJfdGVtcF92YXJzLmFwcGJ1aWxkZXJfcm9vdF91cmw7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgYWxlcnQoX3RyW1xcXCJtbGFiX2VkaXRvci5pbml0LmpzLmNvbXBpbGluZy5mYWlsZWQubG9hZGluZy52YXJcXFwiXSk7XFxuICAgICAgICAgICAgLy9kb2N1bWVudC5sb2NhdGlvbi5ocmVmID0gZG9jdW1lbnQubWxhYl90ZW1wX3ZhcnMuYXBwYnVpbGRlcl9yb290X3VybDtcXG4gICAgICAgIH1cXG4gICAgfSk7XFxufSk7XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yYXctbG9hZGVyIS4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWI/P3JlZi0tMC0wIS4vYXNzZXRzL2pzL21sYWJfZWRpdG9yLmluaXQuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3Jhdy1sb2FkZXIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0wLTAhLi9hc3NldHMvanMvbWxhYl9lZGl0b3IuaW5pdC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFwidmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFxcXCJzeW1ib2xcXFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFxcXCJzeW1ib2xcXFwiIDogdHlwZW9mIG9iajsgfTtcXG5cXG4vKipcXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEtMjAxNCBGZWxpeCBHbmFzc1xcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxcbiAqIGh0dHA6Ly9zcGluLmpzLm9yZy9cXG4gKlxcbiAqIEV4YW1wbGU6XFxuICAgIHZhciBvcHRzID0ge1xcbiAgICAgIGxpbmVzOiAxMiwgICAgICAgICAgICAvLyBUaGUgbnVtYmVyIG9mIGxpbmVzIHRvIGRyYXdcXG4gICAgICBsZW5ndGg6IDcsICAgICAgICAgICAgLy8gVGhlIGxlbmd0aCBvZiBlYWNoIGxpbmVcXG4gICAgICB3aWR0aDogNSwgICAgICAgICAgICAgLy8gVGhlIGxpbmUgdGhpY2tuZXNzXFxuICAgICAgcmFkaXVzOiAxMCwgICAgICAgICAgIC8vIFRoZSByYWRpdXMgb2YgdGhlIGlubmVyIGNpcmNsZVxcbiAgICAgIHNjYWxlOiAxLjAsICAgICAgICAgICAvLyBTY2FsZXMgb3ZlcmFsbCBzaXplIG9mIHRoZSBzcGlubmVyXFxuICAgICAgY29ybmVyczogMSwgICAgICAgICAgIC8vIFJvdW5kbmVzcyAoMC4uMSlcXG4gICAgICBjb2xvcjogJyMwMDAnLCAgICAgICAgLy8gI3JnYiBvciAjcnJnZ2JiXFxuICAgICAgb3BhY2l0eTogMS80LCAgICAgICAgIC8vIE9wYWNpdHkgb2YgdGhlIGxpbmVzXFxuICAgICAgcm90YXRlOiAwLCAgICAgICAgICAgIC8vIFJvdGF0aW9uIG9mZnNldFxcbiAgICAgIGRpcmVjdGlvbjogMSwgICAgICAgICAvLyAxOiBjbG9ja3dpc2UsIC0xOiBjb3VudGVyY2xvY2t3aXNlXFxuICAgICAgc3BlZWQ6IDEsICAgICAgICAgICAgIC8vIFJvdW5kcyBwZXIgc2Vjb25kXFxuICAgICAgdHJhaWw6IDEwMCwgICAgICAgICAgIC8vIEFmdGVyZ2xvdyBwZXJjZW50YWdlXFxuICAgICAgZnBzOiAyMCwgICAgICAgICAgICAgIC8vIEZyYW1lcyBwZXIgc2Vjb25kIHdoZW4gdXNpbmcgc2V0VGltZW91dCgpXFxuICAgICAgekluZGV4OiAyZTksICAgICAgICAgIC8vIFVzZSBhIGhpZ2ggei1pbmRleCBieSBkZWZhdWx0XFxuICAgICAgY2xhc3NOYW1lOiAnc3Bpbm5lcicsIC8vIENTUyBjbGFzcyB0byBhc3NpZ24gdG8gdGhlIGVsZW1lbnRcXG4gICAgICB0b3A6ICc1MCUnLCAgICAgICAgICAgLy8gY2VudGVyIHZlcnRpY2FsbHlcXG4gICAgICBsZWZ0OiAnNTAlJywgICAgICAgICAgLy8gY2VudGVyIGhvcml6b250YWxseVxcbiAgICAgIHNoYWRvdzogZmFsc2UsICAgICAgICAvLyBXaGV0aGVyIHRvIHJlbmRlciBhIHNoYWRvd1xcbiAgICAgIGh3YWNjZWw6IGZhbHNlLCAgICAgICAvLyBXaGV0aGVyIHRvIHVzZSBoYXJkd2FyZSBhY2NlbGVyYXRpb24gKG1pZ2h0IGJlIGJ1Z2d5KVxcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnICAvLyBFbGVtZW50IHBvc2l0aW9uaW5nXFxuICAgIH07XFxuICAgIHZhciB0YXJnZXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZm9vJyk7XFxuICAgIHZhciBzcGlubmVyID0gbmV3IFNwaW5uZXIob3B0cykuc3Bpbih0YXJnZXQpO1xcbiAqL1xcbjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcXG4gIGlmICgodHlwZW9mIG1vZHVsZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YobW9kdWxlKSkgPT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpOyAvLyBDb21tb25KU1xcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIGRlZmluZShmYWN0b3J5KTsgLy8gQU1EIG1vZHVsZVxcbiAgICBlbHNlIHJvb3QuU3Bpbm5lciA9IGZhY3RvcnkoKTsgLy8gQnJvd3NlciBnbG9iYWxcXG59KSh0aGlzLCBmdW5jdGlvbiAoKSB7XFxuICAndXNlIHN0cmljdCc7XFxuXFxuICB2YXIgcHJlZml4ZXMgPSBbJ3dlYmtpdCcsICdNb3onLCAnbXMnLCAnTyddOyAvLyBWZW5kb3IgcHJlZml4ZXNcXG4gIHZhciBhbmltYXRpb25zID0ge307IC8vIEFuaW1hdGlvbiBydWxlcyBrZXllZCBieSB0aGVpciBuYW1lXFxuICB2YXIgdXNlQ3NzQW5pbWF0aW9uczsgLy8gV2hldGhlciB0byB1c2UgQ1NTIGFuaW1hdGlvbnMgb3Igc2V0VGltZW91dFxcbiAgdmFyIHNoZWV0OyAvLyBBIHN0eWxlc2hlZXQgdG8gaG9sZCB0aGUgQGtleWZyYW1lIG9yIFZNTCBydWxlc1xcblxcbiAgLyoqXFxuICAgKiBVdGlsaXR5IGZ1bmN0aW9uIHRvIGNyZWF0ZSBlbGVtZW50cy4gSWYgbm8gdGFnIG5hbWUgaXMgZ2l2ZW4sXFxuICAgKiBhIERJViBpcyBjcmVhdGVkLiBPcHRpb25hbGx5IHByb3BlcnRpZXMgY2FuIGJlIHBhc3NlZC5cXG4gICAqL1xcbiAgZnVuY3Rpb24gY3JlYXRlRWwodGFnLCBwcm9wKSB7XFxuICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnIHx8ICdkaXYnKTtcXG4gICAgdmFyIG47XFxuXFxuICAgIGZvciAobiBpbiBwcm9wKSB7XFxuICAgICAgZWxbbl0gPSBwcm9wW25dO1xcbiAgICB9cmV0dXJuIGVsO1xcbiAgfVxcblxcbiAgLyoqXFxuICAgKiBBcHBlbmRzIGNoaWxkcmVuIGFuZCByZXR1cm5zIHRoZSBwYXJlbnQuXFxuICAgKi9cXG4gIGZ1bmN0aW9uIGlucyhwYXJlbnQgLyogY2hpbGQxLCBjaGlsZDIsIC4uLiovKSB7XFxuICAgIGZvciAodmFyIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xcbiAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChhcmd1bWVudHNbaV0pO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBwYXJlbnQ7XFxuICB9XFxuXFxuICAvKipcXG4gICAqIENyZWF0ZXMgYW4gb3BhY2l0eSBrZXlmcmFtZSBhbmltYXRpb24gcnVsZSBhbmQgcmV0dXJucyBpdHMgbmFtZS5cXG4gICAqIFNpbmNlIG1vc3QgbW9iaWxlIFdlYmtpdHMgaGF2ZSB0aW1pbmcgaXNzdWVzIHdpdGggYW5pbWF0aW9uLWRlbGF5LFxcbiAgICogd2UgY3JlYXRlIHNlcGFyYXRlIHJ1bGVzIGZvciBlYWNoIGxpbmUvc2VnbWVudC5cXG4gICAqL1xcbiAgZnVuY3Rpb24gYWRkQW5pbWF0aW9uKGFscGhhLCB0cmFpbCwgaSwgbGluZXMpIHtcXG4gICAgdmFyIG5hbWUgPSBbJ29wYWNpdHknLCB0cmFpbCwgfn4oYWxwaGEgKiAxMDApLCBpLCBsaW5lc10uam9pbignLScpO1xcbiAgICB2YXIgc3RhcnQgPSAwLjAxICsgaSAvIGxpbmVzICogMTAwO1xcbiAgICB2YXIgeiA9IE1hdGgubWF4KDEgLSAoMSAtIGFscGhhKSAvIHRyYWlsICogKDEwMCAtIHN0YXJ0KSwgYWxwaGEpO1xcbiAgICB2YXIgcHJlZml4ID0gdXNlQ3NzQW5pbWF0aW9ucy5zdWJzdHJpbmcoMCwgdXNlQ3NzQW5pbWF0aW9ucy5pbmRleE9mKCdBbmltYXRpb24nKSkudG9Mb3dlckNhc2UoKTtcXG4gICAgdmFyIHByZSA9IHByZWZpeCAmJiAnLScgKyBwcmVmaXggKyAnLScgfHwgJyc7XFxuXFxuICAgIGlmICghYW5pbWF0aW9uc1tuYW1lXSkge1xcbiAgICAgIHNoZWV0Lmluc2VydFJ1bGUoJ0AnICsgcHJlICsgJ2tleWZyYW1lcyAnICsgbmFtZSArICd7JyArICcwJXtvcGFjaXR5OicgKyB6ICsgJ30nICsgc3RhcnQgKyAnJXtvcGFjaXR5OicgKyBhbHBoYSArICd9JyArIChzdGFydCArIDAuMDEpICsgJyV7b3BhY2l0eToxfScgKyAoc3RhcnQgKyB0cmFpbCkgJSAxMDAgKyAnJXtvcGFjaXR5OicgKyBhbHBoYSArICd9JyArICcxMDAle29wYWNpdHk6JyArIHogKyAnfScgKyAnfScsIHNoZWV0LmNzc1J1bGVzLmxlbmd0aCk7XFxuXFxuICAgICAgYW5pbWF0aW9uc1tuYW1lXSA9IDE7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIG5hbWU7XFxuICB9XFxuXFxuICAvKipcXG4gICAqIFRyaWVzIHZhcmlvdXMgdmVuZG9yIHByZWZpeGVzIGFuZCByZXR1cm5zIHRoZSBmaXJzdCBzdXBwb3J0ZWQgcHJvcGVydHkuXFxuICAgKi9cXG4gIGZ1bmN0aW9uIHZlbmRvcihlbCwgcHJvcCkge1xcbiAgICB2YXIgcyA9IGVsLnN0eWxlO1xcbiAgICB2YXIgcHA7XFxuICAgIHZhciBpO1xcblxcbiAgICBwcm9wID0gcHJvcC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3Auc2xpY2UoMSk7XFxuICAgIGlmIChzW3Byb3BdICE9PSB1bmRlZmluZWQpIHJldHVybiBwcm9wO1xcbiAgICBmb3IgKGkgPSAwOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcXG4gICAgICBwcCA9IHByZWZpeGVzW2ldICsgcHJvcDtcXG4gICAgICBpZiAoc1twcF0gIT09IHVuZGVmaW5lZCkgcmV0dXJuIHBwO1xcbiAgICB9XFxuICB9XFxuXFxuICAvKipcXG4gICAqIFNldHMgbXVsdGlwbGUgc3R5bGUgcHJvcGVydGllcyBhdCBvbmNlLlxcbiAgICovXFxuICBmdW5jdGlvbiBjc3MoZWwsIHByb3ApIHtcXG4gICAgZm9yICh2YXIgbiBpbiBwcm9wKSB7XFxuICAgICAgZWwuc3R5bGVbdmVuZG9yKGVsLCBuKSB8fCBuXSA9IHByb3Bbbl07XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIGVsO1xcbiAgfVxcblxcbiAgLyoqXFxuICAgKiBGaWxscyBpbiBkZWZhdWx0IHZhbHVlcy5cXG4gICAqL1xcbiAgZnVuY3Rpb24gbWVyZ2Uob2JqKSB7XFxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgdmFyIGRlZiA9IGFyZ3VtZW50c1tpXTtcXG4gICAgICBmb3IgKHZhciBuIGluIGRlZikge1xcbiAgICAgICAgaWYgKG9ialtuXSA9PT0gdW5kZWZpbmVkKSBvYmpbbl0gPSBkZWZbbl07XFxuICAgICAgfVxcbiAgICB9XFxuICAgIHJldHVybiBvYmo7XFxuICB9XFxuXFxuICAvKipcXG4gICAqIFJldHVybnMgdGhlIGxpbmUgY29sb3IgZnJvbSB0aGUgZ2l2ZW4gc3RyaW5nIG9yIGFycmF5LlxcbiAgICovXFxuICBmdW5jdGlvbiBnZXRDb2xvcihjb2xvciwgaWR4KSB7XFxuICAgIHJldHVybiB0eXBlb2YgY29sb3IgPT0gJ3N0cmluZycgPyBjb2xvciA6IGNvbG9yW2lkeCAlIGNvbG9yLmxlbmd0aF07XFxuICB9XFxuXFxuICAvLyBCdWlsdC1pbiBkZWZhdWx0c1xcblxcbiAgdmFyIGRlZmF1bHRzID0ge1xcbiAgICBsaW5lczogMTIsIC8vIFRoZSBudW1iZXIgb2YgbGluZXMgdG8gZHJhd1xcbiAgICBsZW5ndGg6IDcsIC8vIFRoZSBsZW5ndGggb2YgZWFjaCBsaW5lXFxuICAgIHdpZHRoOiA1LCAvLyBUaGUgbGluZSB0aGlja25lc3NcXG4gICAgcmFkaXVzOiAxMCwgLy8gVGhlIHJhZGl1cyBvZiB0aGUgaW5uZXIgY2lyY2xlXFxuICAgIHNjYWxlOiAxLjAsIC8vIFNjYWxlcyBvdmVyYWxsIHNpemUgb2YgdGhlIHNwaW5uZXJcXG4gICAgY29ybmVyczogMSwgLy8gUm91bmRuZXNzICgwLi4xKVxcbiAgICBjb2xvcjogJyMwMDAnLCAvLyAjcmdiIG9yICNycmdnYmJcXG4gICAgb3BhY2l0eTogMSAvIDQsIC8vIE9wYWNpdHkgb2YgdGhlIGxpbmVzXFxuICAgIHJvdGF0ZTogMCwgLy8gUm90YXRpb24gb2Zmc2V0XFxuICAgIGRpcmVjdGlvbjogMSwgLy8gMTogY2xvY2t3aXNlLCAtMTogY291bnRlcmNsb2Nrd2lzZVxcbiAgICBzcGVlZDogMSwgLy8gUm91bmRzIHBlciBzZWNvbmRcXG4gICAgdHJhaWw6IDEwMCwgLy8gQWZ0ZXJnbG93IHBlcmNlbnRhZ2VcXG4gICAgZnBzOiAyMCwgLy8gRnJhbWVzIHBlciBzZWNvbmQgd2hlbiB1c2luZyBzZXRUaW1lb3V0KClcXG4gICAgekluZGV4OiAyZTksIC8vIFVzZSBhIGhpZ2ggei1pbmRleCBieSBkZWZhdWx0XFxuICAgIGNsYXNzTmFtZTogJ3NwaW5uZXInLCAvLyBDU1MgY2xhc3MgdG8gYXNzaWduIHRvIHRoZSBlbGVtZW50XFxuICAgIHRvcDogJzUwJScsIC8vIGNlbnRlciB2ZXJ0aWNhbGx5XFxuICAgIGxlZnQ6ICc1MCUnLCAvLyBjZW50ZXIgaG9yaXpvbnRhbGx5XFxuICAgIHNoYWRvdzogZmFsc2UsIC8vIFdoZXRoZXIgdG8gcmVuZGVyIGEgc2hhZG93XFxuICAgIGh3YWNjZWw6IGZhbHNlLCAvLyBXaGV0aGVyIHRvIHVzZSBoYXJkd2FyZSBhY2NlbGVyYXRpb25cXG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZScgLy8gRWxlbWVudCBwb3NpdGlvbmluZ1xcbiAgfTtcXG5cXG4gIC8qKiBUaGUgY29uc3RydWN0b3IgKi9cXG4gIGZ1bmN0aW9uIFNwaW5uZXIobykge1xcbiAgICB0aGlzLm9wdHMgPSBtZXJnZShvIHx8IHt9LCBTcGlubmVyLmRlZmF1bHRzLCBkZWZhdWx0cyk7XFxuICB9XFxuXFxuICAvLyBHbG9iYWwgZGVmYXVsdHMgdGhhdCBvdmVycmlkZSB0aGUgYnVpbHQtaW5zOlxcbiAgU3Bpbm5lci5kZWZhdWx0cyA9IHt9O1xcblxcbiAgbWVyZ2UoU3Bpbm5lci5wcm90b3R5cGUsIHtcXG4gICAgLyoqXFxuICAgICAqIEFkZHMgdGhlIHNwaW5uZXIgdG8gdGhlIGdpdmVuIHRhcmdldCBlbGVtZW50LiBJZiB0aGlzIGluc3RhbmNlIGlzIGFscmVhZHlcXG4gICAgICogc3Bpbm5pbmcsIGl0IGlzIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZCBmcm9tIGl0cyBwcmV2aW91cyB0YXJnZXQgYiBjYWxsaW5nXFxuICAgICAqIHN0b3AoKSBpbnRlcm5hbGx5LlxcbiAgICAgKi9cXG4gICAgc3BpbjogZnVuY3Rpb24gc3Bpbih0YXJnZXQpIHtcXG4gICAgICB0aGlzLnN0b3AoKTtcXG5cXG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XFxuICAgICAgdmFyIG8gPSBzZWxmLm9wdHM7XFxuICAgICAgdmFyIGVsID0gc2VsZi5lbCA9IGNyZWF0ZUVsKG51bGwsIHsgY2xhc3NOYW1lOiBvLmNsYXNzTmFtZSB9KTtcXG5cXG4gICAgICBjc3MoZWwsIHtcXG4gICAgICAgIHBvc2l0aW9uOiBvLnBvc2l0aW9uLFxcbiAgICAgICAgd2lkdGg6IDAsXFxuICAgICAgICB6SW5kZXg6IG8uekluZGV4LFxcbiAgICAgICAgbGVmdDogby5sZWZ0LFxcbiAgICAgICAgdG9wOiBvLnRvcFxcbiAgICAgIH0pO1xcblxcbiAgICAgIGlmICh0YXJnZXQpIHtcXG4gICAgICAgIHRhcmdldC5pbnNlcnRCZWZvcmUoZWwsIHRhcmdldC5maXJzdENoaWxkIHx8IG51bGwpO1xcbiAgICAgIH1cXG5cXG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAncHJvZ3Jlc3NiYXInKTtcXG4gICAgICBzZWxmLmxpbmVzKGVsLCBzZWxmLm9wdHMpO1xcblxcbiAgICAgIGlmICghdXNlQ3NzQW5pbWF0aW9ucykge1xcbiAgICAgICAgLy8gTm8gQ1NTIGFuaW1hdGlvbiBzdXBwb3J0LCB1c2Ugc2V0VGltZW91dCgpIGluc3RlYWRcXG4gICAgICAgIHZhciBpID0gMDtcXG4gICAgICAgIHZhciBzdGFydCA9IChvLmxpbmVzIC0gMSkgKiAoMSAtIG8uZGlyZWN0aW9uKSAvIDI7XFxuICAgICAgICB2YXIgYWxwaGE7XFxuICAgICAgICB2YXIgZnBzID0gby5mcHM7XFxuICAgICAgICB2YXIgZiA9IGZwcyAvIG8uc3BlZWQ7XFxuICAgICAgICB2YXIgb3N0ZXAgPSAoMSAtIG8ub3BhY2l0eSkgLyAoZiAqIG8udHJhaWwgLyAxMDApO1xcbiAgICAgICAgdmFyIGFzdGVwID0gZiAvIG8ubGluZXM7XFxuXFxuICAgICAgICAoZnVuY3Rpb24gYW5pbSgpIHtcXG4gICAgICAgICAgaSsrO1xcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG8ubGluZXM7IGorKykge1xcbiAgICAgICAgICAgIGFscGhhID0gTWF0aC5tYXgoMSAtIChpICsgKG8ubGluZXMgLSBqKSAqIGFzdGVwKSAlIGYgKiBvc3RlcCwgby5vcGFjaXR5KTtcXG5cXG4gICAgICAgICAgICBzZWxmLm9wYWNpdHkoZWwsIGogKiBvLmRpcmVjdGlvbiArIHN0YXJ0LCBhbHBoYSwgbyk7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgc2VsZi50aW1lb3V0ID0gc2VsZi5lbCAmJiBzZXRUaW1lb3V0KGFuaW0sIH5+KDEwMDAgLyBmcHMpKTtcXG4gICAgICAgIH0pKCk7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBzZWxmO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogU3RvcHMgYW5kIHJlbW92ZXMgdGhlIFNwaW5uZXIuXFxuICAgICAqL1xcbiAgICBzdG9wOiBmdW5jdGlvbiBzdG9wKCkge1xcbiAgICAgIHZhciBlbCA9IHRoaXMuZWw7XFxuICAgICAgaWYgKGVsKSB7XFxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KTtcXG4gICAgICAgIGlmIChlbC5wYXJlbnROb2RlKSBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcXG4gICAgICAgIHRoaXMuZWwgPSB1bmRlZmluZWQ7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiB0aGlzO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogSW50ZXJuYWwgbWV0aG9kIHRoYXQgZHJhd3MgdGhlIGluZGl2aWR1YWwgbGluZXMuIFdpbGwgYmUgb3ZlcndyaXR0ZW5cXG4gICAgICogaW4gVk1MIGZhbGxiYWNrIG1vZGUgYmVsb3cuXFxuICAgICAqL1xcbiAgICBsaW5lczogZnVuY3Rpb24gbGluZXMoZWwsIG8pIHtcXG4gICAgICB2YXIgaSA9IDA7XFxuICAgICAgdmFyIHN0YXJ0ID0gKG8ubGluZXMgLSAxKSAqICgxIC0gby5kaXJlY3Rpb24pIC8gMjtcXG4gICAgICB2YXIgc2VnO1xcblxcbiAgICAgIGZ1bmN0aW9uIGZpbGwoY29sb3IsIHNoYWRvdykge1xcbiAgICAgICAgcmV0dXJuIGNzcyhjcmVhdGVFbCgpLCB7XFxuICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxcbiAgICAgICAgICB3aWR0aDogby5zY2FsZSAqIChvLmxlbmd0aCArIG8ud2lkdGgpICsgJ3B4JyxcXG4gICAgICAgICAgaGVpZ2h0OiBvLnNjYWxlICogby53aWR0aCArICdweCcsXFxuICAgICAgICAgIGJhY2tncm91bmQ6IGNvbG9yLFxcbiAgICAgICAgICBib3hTaGFkb3c6IHNoYWRvdyxcXG4gICAgICAgICAgdHJhbnNmb3JtT3JpZ2luOiAnbGVmdCcsXFxuICAgICAgICAgIHRyYW5zZm9ybTogJ3JvdGF0ZSgnICsgfn4oMzYwIC8gby5saW5lcyAqIGkgKyBvLnJvdGF0ZSkgKyAnZGVnKSB0cmFuc2xhdGUoJyArIG8uc2NhbGUgKiBvLnJhZGl1cyArICdweCcgKyAnLDApJyxcXG4gICAgICAgICAgYm9yZGVyUmFkaXVzOiAoby5jb3JuZXJzICogby5zY2FsZSAqIG8ud2lkdGggPj4gMSkgKyAncHgnXFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuXFxuICAgICAgZm9yICg7IGkgPCBvLmxpbmVzOyBpKyspIHtcXG4gICAgICAgIHNlZyA9IGNzcyhjcmVhdGVFbCgpLCB7XFxuICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxcbiAgICAgICAgICB0b3A6IDEgKyB+KG8uc2NhbGUgKiBvLndpZHRoIC8gMikgKyAncHgnLFxcbiAgICAgICAgICB0cmFuc2Zvcm06IG8uaHdhY2NlbCA/ICd0cmFuc2xhdGUzZCgwLDAsMCknIDogJycsXFxuICAgICAgICAgIG9wYWNpdHk6IG8ub3BhY2l0eSxcXG4gICAgICAgICAgYW5pbWF0aW9uOiB1c2VDc3NBbmltYXRpb25zICYmIGFkZEFuaW1hdGlvbihvLm9wYWNpdHksIG8udHJhaWwsIHN0YXJ0ICsgaSAqIG8uZGlyZWN0aW9uLCBvLmxpbmVzKSArICcgJyArIDEgLyBvLnNwZWVkICsgJ3MgbGluZWFyIGluZmluaXRlJ1xcbiAgICAgICAgfSk7XFxuXFxuICAgICAgICBpZiAoby5zaGFkb3cpIGlucyhzZWcsIGNzcyhmaWxsKCcjMDAwJywgJzAgMCA0cHggIzAwMCcpLCB7IHRvcDogJzJweCcgfSkpO1xcbiAgICAgICAgaW5zKGVsLCBpbnMoc2VnLCBmaWxsKGdldENvbG9yKG8uY29sb3IsIGkpLCAnMCAwIDFweCByZ2JhKDAsMCwwLC4xKScpKSk7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBlbDtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIEludGVybmFsIG1ldGhvZCB0aGF0IGFkanVzdHMgdGhlIG9wYWNpdHkgb2YgYSBzaW5nbGUgbGluZS5cXG4gICAgICogV2lsbCBiZSBvdmVyd3JpdHRlbiBpbiBWTUwgZmFsbGJhY2sgbW9kZSBiZWxvdy5cXG4gICAgICovXFxuICAgIG9wYWNpdHk6IGZ1bmN0aW9uIG9wYWNpdHkoZWwsIGksIHZhbCkge1xcbiAgICAgIGlmIChpIDwgZWwuY2hpbGROb2Rlcy5sZW5ndGgpIGVsLmNoaWxkTm9kZXNbaV0uc3R5bGUub3BhY2l0eSA9IHZhbDtcXG4gICAgfVxcblxcbiAgfSk7XFxuXFxuICBmdW5jdGlvbiBpbml0Vk1MKCkge1xcblxcbiAgICAvKiBVdGlsaXR5IGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIFZNTCB0YWcgKi9cXG4gICAgZnVuY3Rpb24gdm1sKHRhZywgYXR0cikge1xcbiAgICAgIHJldHVybiBjcmVhdGVFbCgnPCcgKyB0YWcgKyAnIHhtbG5zPVxcXCJ1cm46c2NoZW1hcy1taWNyb3NvZnQuY29tOnZtbFxcXCIgY2xhc3M9XFxcInNwaW4tdm1sXFxcIj4nLCBhdHRyKTtcXG4gICAgfVxcblxcbiAgICAvLyBObyBDU1MgdHJhbnNmb3JtcyBidXQgVk1MIHN1cHBvcnQsIGFkZCBhIENTUyBydWxlIGZvciBWTUwgZWxlbWVudHM6XFxuICAgIHNoZWV0LmFkZFJ1bGUoJy5zcGluLXZtbCcsICdiZWhhdmlvcjp1cmwoI2RlZmF1bHQjVk1MKScpO1xcblxcbiAgICBTcGlubmVyLnByb3RvdHlwZS5saW5lcyA9IGZ1bmN0aW9uIChlbCwgbykge1xcbiAgICAgIHZhciByID0gby5zY2FsZSAqIChvLmxlbmd0aCArIG8ud2lkdGgpO1xcbiAgICAgIHZhciBzID0gby5zY2FsZSAqIDIgKiByO1xcblxcbiAgICAgIGZ1bmN0aW9uIGdycCgpIHtcXG4gICAgICAgIHJldHVybiBjc3Modm1sKCdncm91cCcsIHtcXG4gICAgICAgICAgY29vcmRzaXplOiBzICsgJyAnICsgcyxcXG4gICAgICAgICAgY29vcmRvcmlnaW46IC1yICsgJyAnICsgLXJcXG4gICAgICAgIH0pLCB7IHdpZHRoOiBzLCBoZWlnaHQ6IHMgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBtYXJnaW4gPSAtKG8ud2lkdGggKyBvLmxlbmd0aCkgKiBvLnNjYWxlICogMiArICdweCc7XFxuICAgICAgdmFyIGcgPSBjc3MoZ3JwKCksIHsgcG9zaXRpb246ICdhYnNvbHV0ZScsIHRvcDogbWFyZ2luLCBsZWZ0OiBtYXJnaW4gfSk7XFxuICAgICAgdmFyIGk7XFxuXFxuICAgICAgZnVuY3Rpb24gc2VnKGksIGR4LCBmaWx0ZXIpIHtcXG4gICAgICAgIGlucyhnLCBpbnMoY3NzKGdycCgpLCB7IHJvdGF0aW9uOiAzNjAgLyBvLmxpbmVzICogaSArICdkZWcnLCBsZWZ0OiB+fmR4IH0pLCBpbnMoY3NzKHZtbCgncm91bmRyZWN0JywgeyBhcmNzaXplOiBvLmNvcm5lcnMgfSksIHtcXG4gICAgICAgICAgd2lkdGg6IHIsXFxuICAgICAgICAgIGhlaWdodDogby5zY2FsZSAqIG8ud2lkdGgsXFxuICAgICAgICAgIGxlZnQ6IG8uc2NhbGUgKiBvLnJhZGl1cyxcXG4gICAgICAgICAgdG9wOiAtby5zY2FsZSAqIG8ud2lkdGggPj4gMSxcXG4gICAgICAgICAgZmlsdGVyOiBmaWx0ZXJcXG4gICAgICAgIH0pLCB2bWwoJ2ZpbGwnLCB7IGNvbG9yOiBnZXRDb2xvcihvLmNvbG9yLCBpKSwgb3BhY2l0eTogby5vcGFjaXR5IH0pLCB2bWwoJ3N0cm9rZScsIHsgb3BhY2l0eTogMCB9KSAvLyB0cmFuc3BhcmVudCBzdHJva2UgdG8gZml4IGNvbG9yIGJsZWVkaW5nIHVwb24gb3BhY2l0eSBjaGFuZ2VcXG4gICAgICAgICkpKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKG8uc2hhZG93KSBmb3IgKGkgPSAxOyBpIDw9IG8ubGluZXM7IGkrKykge1xcbiAgICAgICAgc2VnKGksIC0yLCAncHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LkJsdXIocGl4ZWxyYWRpdXM9MixtYWtlc2hhZG93PTEsc2hhZG93b3BhY2l0eT0uMyknKTtcXG4gICAgICB9XFxuXFxuICAgICAgZm9yIChpID0gMTsgaSA8PSBvLmxpbmVzOyBpKyspIHtcXG4gICAgICAgIHNlZyhpKTtcXG4gICAgICB9cmV0dXJuIGlucyhlbCwgZyk7XFxuICAgIH07XFxuXFxuICAgIFNwaW5uZXIucHJvdG90eXBlLm9wYWNpdHkgPSBmdW5jdGlvbiAoZWwsIGksIHZhbCwgbykge1xcbiAgICAgIHZhciBjID0gZWwuZmlyc3RDaGlsZDtcXG4gICAgICBvID0gby5zaGFkb3cgJiYgby5saW5lcyB8fCAwO1xcbiAgICAgIGlmIChjICYmIGkgKyBvIDwgYy5jaGlsZE5vZGVzLmxlbmd0aCkge1xcbiAgICAgICAgYyA9IGMuY2hpbGROb2Rlc1tpICsgb107YyA9IGMgJiYgYy5maXJzdENoaWxkO2MgPSBjICYmIGMuZmlyc3RDaGlsZDtcXG4gICAgICAgIGlmIChjKSBjLm9wYWNpdHkgPSB2YWw7XFxuICAgICAgfVxcbiAgICB9O1xcbiAgfVxcblxcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgc2hlZXQgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgdmFyIGVsID0gY3JlYXRlRWwoJ3N0eWxlJywgeyB0eXBlOiAndGV4dC9jc3MnIH0pO1xcbiAgICAgIGlucyhkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLCBlbCk7XFxuICAgICAgcmV0dXJuIGVsLnNoZWV0IHx8IGVsLnN0eWxlU2hlZXQ7XFxuICAgIH0oKTtcXG5cXG4gICAgdmFyIHByb2JlID0gY3NzKGNyZWF0ZUVsKCdncm91cCcpLCB7IGJlaGF2aW9yOiAndXJsKCNkZWZhdWx0I1ZNTCknIH0pO1xcblxcbiAgICBpZiAoIXZlbmRvcihwcm9iZSwgJ3RyYW5zZm9ybScpICYmIHByb2JlLmFkaikgaW5pdFZNTCgpO2Vsc2UgdXNlQ3NzQW5pbWF0aW9ucyA9IHZlbmRvcihwcm9iZSwgJ2FuaW1hdGlvbicpO1xcbiAgfVxcblxcbiAgcmV0dXJuIFNwaW5uZXI7XFxufSk7XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yYXctbG9hZGVyIS4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWI/P3JlZi0tMC0wIS4vYXNzZXRzL2pzL3NwaW4uanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3Jhdy1sb2FkZXIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0wLTAhLi9hc3NldHMvanMvc3Bpbi5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzcmMpIHtcblx0ZnVuY3Rpb24gbG9nKGVycm9yKSB7XG5cdFx0KHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiKVxuXHRcdCYmIChjb25zb2xlLmVycm9yIHx8IGNvbnNvbGUubG9nKShcIltTY3JpcHQgTG9hZGVyXVwiLCBlcnJvcik7XG5cdH1cblxuXHQvLyBDaGVjayBmb3IgSUUgPTwgOFxuXHRmdW5jdGlvbiBpc0lFKCkge1xuXHRcdHJldHVybiB0eXBlb2YgYXR0YWNoRXZlbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGFkZEV2ZW50TGlzdGVuZXIgPT09IFwidW5kZWZpbmVkXCI7XG5cdH1cblxuXHR0cnkge1xuXHRcdGlmICh0eXBlb2YgZXhlY1NjcmlwdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpc0lFKCkpIHtcblx0XHRcdGV4ZWNTY3JpcHQoc3JjKTtcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiBldmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHRldmFsLmNhbGwobnVsbCwgc3JjKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bG9nKFwiRXZhbEVycm9yOiBObyBldmFsIGZ1bmN0aW9uIGF2YWlsYWJsZVwiKTtcblx0XHR9XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0bG9nKGVycm9yKTtcblx0fVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyIsInJlcXVpcmUoXCIhIS9ob21lL29zYm94ZXMvd29ya3NwYWNlL21sYWIubG9jYWwudGVzdC9ub2RlX21vZHVsZXMvc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanNcIikocmVxdWlyZShcIiEhL2hvbWUvb3Nib3hlcy93b3Jrc3BhY2UvbWxhYi5sb2NhbC50ZXN0L25vZGVfbW9kdWxlcy9yYXctbG9hZGVyL2luZGV4LmpzIS9ob21lL29zYm94ZXMvd29ya3NwYWNlL21sYWIubG9jYWwudGVzdC9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0wLTAhL2hvbWUvb3Nib3hlcy93b3Jrc3BhY2UvbWxhYi5sb2NhbC50ZXN0L2Fzc2V0cy9qcy9qcXVlcnkubW9iaWxlLTEuNC41LmpzXCIpK1wiXFxuXFxuLy8gU0NSSVBULUxPQURFUiBGT09URVJcXG4vLyMgc291cmNlVVJMPXNjcmlwdDovLy9ob21lL29zYm94ZXMvd29ya3NwYWNlL21sYWIubG9jYWwudGVzdC9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyUzRj9yZWYtLTAtMCEvaG9tZS9vc2JveGVzL3dvcmtzcGFjZS9tbGFiLmxvY2FsLnRlc3QvYXNzZXRzL2pzL2pxdWVyeS5tb2JpbGUtMS40LjUuanNcIilcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyIS4vYXNzZXRzL2pzL2pxdWVyeS5tb2JpbGUtMS40LjUuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvaW5kZXguanMhLi9hc3NldHMvanMvanF1ZXJ5Lm1vYmlsZS0xLjQuNS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKFwiISEvaG9tZS9vc2JveGVzL3dvcmtzcGFjZS9tbGFiLmxvY2FsLnRlc3Qvbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzXCIpKHJlcXVpcmUoXCIhIS9ob21lL29zYm94ZXMvd29ya3NwYWNlL21sYWIubG9jYWwudGVzdC9ub2RlX21vZHVsZXMvcmF3LWxvYWRlci9pbmRleC5qcyEvaG9tZS9vc2JveGVzL3dvcmtzcGFjZS9tbGFiLmxvY2FsLnRlc3Qvbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMC0wIS9ob21lL29zYm94ZXMvd29ya3NwYWNlL21sYWIubG9jYWwudGVzdC9hc3NldHMvanMvanF1ZXJ5LnFyY29kZS0wLjEyLjAuanNcIikrXCJcXG5cXG4vLyBTQ1JJUFQtTE9BREVSIEZPT1RFUlxcbi8vIyBzb3VyY2VVUkw9c2NyaXB0Oi8vL2hvbWUvb3Nib3hlcy93b3Jrc3BhY2UvbWxhYi5sb2NhbC50ZXN0L25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzJTNGP3JlZi0tMC0wIS9ob21lL29zYm94ZXMvd29ya3NwYWNlL21sYWIubG9jYWwudGVzdC9hc3NldHMvanMvanF1ZXJ5LnFyY29kZS0wLjEyLjAuanNcIilcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyIS4vYXNzZXRzL2pzL2pxdWVyeS5xcmNvZGUtMC4xMi4wLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyL2luZGV4LmpzIS4vYXNzZXRzL2pzL2pxdWVyeS5xcmNvZGUtMC4xMi4wLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoXCIhIS9ob21lL29zYm94ZXMvd29ya3NwYWNlL21sYWIubG9jYWwudGVzdC9ub2RlX21vZHVsZXMvc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanNcIikocmVxdWlyZShcIiEhL2hvbWUvb3Nib3hlcy93b3Jrc3BhY2UvbWxhYi5sb2NhbC50ZXN0L25vZGVfbW9kdWxlcy9yYXctbG9hZGVyL2luZGV4LmpzIS9ob21lL29zYm94ZXMvd29ya3NwYWNlL21sYWIubG9jYWwudGVzdC9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0wLTAhL2hvbWUvb3Nib3hlcy93b3Jrc3BhY2UvbWxhYi5sb2NhbC50ZXN0L2Fzc2V0cy9qcy9qcXVlcnkuc3Bpbi5qc1wiKStcIlxcblxcbi8vIFNDUklQVC1MT0FERVIgRk9PVEVSXFxuLy8jIHNvdXJjZVVSTD1zY3JpcHQ6Ly8vaG9tZS9vc2JveGVzL3dvcmtzcGFjZS9tbGFiLmxvY2FsLnRlc3Qvbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMlM0Y/cmVmLS0wLTAhL2hvbWUvb3Nib3hlcy93b3Jrc3BhY2UvbWxhYi5sb2NhbC50ZXN0L2Fzc2V0cy9qcy9qcXVlcnkuc3Bpbi5qc1wiKVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIhLi9hc3NldHMvanMvanF1ZXJ5LnNwaW4uanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvaW5kZXguanMhLi9hc3NldHMvanMvanF1ZXJ5LnNwaW4uanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwicmVxdWlyZShcIiEhL2hvbWUvb3Nib3hlcy93b3Jrc3BhY2UvbWxhYi5sb2NhbC50ZXN0L25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qc1wiKShyZXF1aXJlKFwiISEvaG9tZS9vc2JveGVzL3dvcmtzcGFjZS9tbGFiLmxvY2FsLnRlc3Qvbm9kZV9tb2R1bGVzL3Jhdy1sb2FkZXIvaW5kZXguanMhL2hvbWUvb3Nib3hlcy93b3Jrc3BhY2UvbWxhYi5sb2NhbC50ZXN0L25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTAtMCEvaG9tZS9vc2JveGVzL3dvcmtzcGFjZS9tbGFiLmxvY2FsLnRlc3QvYXNzZXRzL2pzL21sYWIuYXBpLmpzXCIpK1wiXFxuXFxuLy8gU0NSSVBULUxPQURFUiBGT09URVJcXG4vLyMgc291cmNlVVJMPXNjcmlwdDovLy9ob21lL29zYm94ZXMvd29ya3NwYWNlL21sYWIubG9jYWwudGVzdC9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyUzRj9yZWYtLTAtMCEvaG9tZS9vc2JveGVzL3dvcmtzcGFjZS9tbGFiLmxvY2FsLnRlc3QvYXNzZXRzL2pzL21sYWIuYXBpLmpzXCIpXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvc2NyaXB0LWxvYWRlciEuL2Fzc2V0cy9qcy9tbGFiLmFwaS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvc2NyaXB0LWxvYWRlci9pbmRleC5qcyEuL2Fzc2V0cy9qcy9tbGFiLmFwaS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKFwiISEvaG9tZS9vc2JveGVzL3dvcmtzcGFjZS9tbGFiLmxvY2FsLnRlc3Qvbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzXCIpKHJlcXVpcmUoXCIhIS9ob21lL29zYm94ZXMvd29ya3NwYWNlL21sYWIubG9jYWwudGVzdC9ub2RlX21vZHVsZXMvcmF3LWxvYWRlci9pbmRleC5qcyEvaG9tZS9vc2JveGVzL3dvcmtzcGFjZS9tbGFiLmxvY2FsLnRlc3Qvbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMC0wIS9ob21lL29zYm94ZXMvd29ya3NwYWNlL21sYWIubG9jYWwudGVzdC9hc3NldHMvanMvbWxhYi5kdC5hcGkuanNcIikrXCJcXG5cXG4vLyBTQ1JJUFQtTE9BREVSIEZPT1RFUlxcbi8vIyBzb3VyY2VVUkw9c2NyaXB0Oi8vL2hvbWUvb3Nib3hlcy93b3Jrc3BhY2UvbWxhYi5sb2NhbC50ZXN0L25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzJTNGP3JlZi0tMC0wIS9ob21lL29zYm94ZXMvd29ya3NwYWNlL21sYWIubG9jYWwudGVzdC9hc3NldHMvanMvbWxhYi5kdC5hcGkuanNcIilcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyIS4vYXNzZXRzL2pzL21sYWIuZHQuYXBpLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyL2luZGV4LmpzIS4vYXNzZXRzL2pzL21sYWIuZHQuYXBpLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoXCIhIS9ob21lL29zYm94ZXMvd29ya3NwYWNlL21sYWIubG9jYWwudGVzdC9ub2RlX21vZHVsZXMvc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanNcIikocmVxdWlyZShcIiEhL2hvbWUvb3Nib3hlcy93b3Jrc3BhY2UvbWxhYi5sb2NhbC50ZXN0L25vZGVfbW9kdWxlcy9yYXctbG9hZGVyL2luZGV4LmpzIS9ob21lL29zYm94ZXMvd29ya3NwYWNlL21sYWIubG9jYWwudGVzdC9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0wLTAhL2hvbWUvb3Nib3hlcy93b3Jrc3BhY2UvbWxhYi5sb2NhbC50ZXN0L2Fzc2V0cy9qcy9tbGFiLmR0LmJlc3RwcmFjdGljZS5qc1wiKStcIlxcblxcbi8vIFNDUklQVC1MT0FERVIgRk9PVEVSXFxuLy8jIHNvdXJjZVVSTD1zY3JpcHQ6Ly8vaG9tZS9vc2JveGVzL3dvcmtzcGFjZS9tbGFiLmxvY2FsLnRlc3Qvbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMlM0Y/cmVmLS0wLTAhL2hvbWUvb3Nib3hlcy93b3Jrc3BhY2UvbWxhYi5sb2NhbC50ZXN0L2Fzc2V0cy9qcy9tbGFiLmR0LmJlc3RwcmFjdGljZS5qc1wiKVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIhLi9hc3NldHMvanMvbWxhYi5kdC5iZXN0cHJhY3RpY2UuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvaW5kZXguanMhLi9hc3NldHMvanMvbWxhYi5kdC5iZXN0cHJhY3RpY2UuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwicmVxdWlyZShcIiEhL2hvbWUvb3Nib3hlcy93b3Jrc3BhY2UvbWxhYi5sb2NhbC50ZXN0L25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qc1wiKShyZXF1aXJlKFwiISEvaG9tZS9vc2JveGVzL3dvcmtzcGFjZS9tbGFiLmxvY2FsLnRlc3Qvbm9kZV9tb2R1bGVzL3Jhdy1sb2FkZXIvaW5kZXguanMhL2hvbWUvb3Nib3hlcy93b3Jrc3BhY2UvbWxhYi5sb2NhbC50ZXN0L25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTAtMCEvaG9tZS9vc2JveGVzL3dvcmtzcGFjZS9tbGFiLmxvY2FsLnRlc3QvYXNzZXRzL2pzL21sYWIuZHQuZGVzaWduLmpzXCIpK1wiXFxuXFxuLy8gU0NSSVBULUxPQURFUiBGT09URVJcXG4vLyMgc291cmNlVVJMPXNjcmlwdDovLy9ob21lL29zYm94ZXMvd29ya3NwYWNlL21sYWIubG9jYWwudGVzdC9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyUzRj9yZWYtLTAtMCEvaG9tZS9vc2JveGVzL3dvcmtzcGFjZS9tbGFiLmxvY2FsLnRlc3QvYXNzZXRzL2pzL21sYWIuZHQuZGVzaWduLmpzXCIpXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvc2NyaXB0LWxvYWRlciEuL2Fzc2V0cy9qcy9tbGFiLmR0LmRlc2lnbi5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvc2NyaXB0LWxvYWRlci9pbmRleC5qcyEuL2Fzc2V0cy9qcy9tbGFiLmR0LmRlc2lnbi5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKFwiISEvaG9tZS9vc2JveGVzL3dvcmtzcGFjZS9tbGFiLmxvY2FsLnRlc3Qvbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzXCIpKHJlcXVpcmUoXCIhIS9ob21lL29zYm94ZXMvd29ya3NwYWNlL21sYWIubG9jYWwudGVzdC9ub2RlX21vZHVsZXMvcmF3LWxvYWRlci9pbmRleC5qcyEvaG9tZS9vc2JveGVzL3dvcmtzcGFjZS9tbGFiLmxvY2FsLnRlc3Qvbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMC0wIS9ob21lL29zYm94ZXMvd29ya3NwYWNlL21sYWIubG9jYWwudGVzdC9hc3NldHMvanMvbWxhYi5kdC5tYW5hZ2VtZW50LmpzXCIpK1wiXFxuXFxuLy8gU0NSSVBULUxPQURFUiBGT09URVJcXG4vLyMgc291cmNlVVJMPXNjcmlwdDovLy9ob21lL29zYm94ZXMvd29ya3NwYWNlL21sYWIubG9jYWwudGVzdC9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyUzRj9yZWYtLTAtMCEvaG9tZS9vc2JveGVzL3dvcmtzcGFjZS9tbGFiLmxvY2FsLnRlc3QvYXNzZXRzL2pzL21sYWIuZHQubWFuYWdlbWVudC5qc1wiKVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIhLi9hc3NldHMvanMvbWxhYi5kdC5tYW5hZ2VtZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyL2luZGV4LmpzIS4vYXNzZXRzL2pzL21sYWIuZHQubWFuYWdlbWVudC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJyZXF1aXJlKFwiISEvaG9tZS9vc2JveGVzL3dvcmtzcGFjZS9tbGFiLmxvY2FsLnRlc3Qvbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzXCIpKHJlcXVpcmUoXCIhIS9ob21lL29zYm94ZXMvd29ya3NwYWNlL21sYWIubG9jYWwudGVzdC9ub2RlX21vZHVsZXMvcmF3LWxvYWRlci9pbmRleC5qcyEvaG9tZS9vc2JveGVzL3dvcmtzcGFjZS9tbGFiLmxvY2FsLnRlc3Qvbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMC0wIS9ob21lL29zYm94ZXMvd29ya3NwYWNlL21sYWIubG9jYWwudGVzdC9hc3NldHMvanMvbWxhYi5kdC51dGlscy5qc1wiKStcIlxcblxcbi8vIFNDUklQVC1MT0FERVIgRk9PVEVSXFxuLy8jIHNvdXJjZVVSTD1zY3JpcHQ6Ly8vaG9tZS9vc2JveGVzL3dvcmtzcGFjZS9tbGFiLmxvY2FsLnRlc3Qvbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMlM0Y/cmVmLS0wLTAhL2hvbWUvb3Nib3hlcy93b3Jrc3BhY2UvbWxhYi5sb2NhbC50ZXN0L2Fzc2V0cy9qcy9tbGFiLmR0LnV0aWxzLmpzXCIpXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvc2NyaXB0LWxvYWRlciEuL2Fzc2V0cy9qcy9tbGFiLmR0LnV0aWxzLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyL2luZGV4LmpzIS4vYXNzZXRzL2pzL21sYWIuZHQudXRpbHMuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwicmVxdWlyZShcIiEhL2hvbWUvb3Nib3hlcy93b3Jrc3BhY2UvbWxhYi5sb2NhbC50ZXN0L25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qc1wiKShyZXF1aXJlKFwiISEvaG9tZS9vc2JveGVzL3dvcmtzcGFjZS9tbGFiLmxvY2FsLnRlc3Qvbm9kZV9tb2R1bGVzL3Jhdy1sb2FkZXIvaW5kZXguanMhL2hvbWUvb3Nib3hlcy93b3Jrc3BhY2UvbWxhYi5sb2NhbC50ZXN0L25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTAtMCEvaG9tZS9vc2JveGVzL3dvcmtzcGFjZS9tbGFiLmxvY2FsLnRlc3QvYXNzZXRzL2pzL21sYWJfZWRpdG9yLmluaXQuanNcIikrXCJcXG5cXG4vLyBTQ1JJUFQtTE9BREVSIEZPT1RFUlxcbi8vIyBzb3VyY2VVUkw9c2NyaXB0Oi8vL2hvbWUvb3Nib3hlcy93b3Jrc3BhY2UvbWxhYi5sb2NhbC50ZXN0L25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzJTNGP3JlZi0tMC0wIS9ob21lL29zYm94ZXMvd29ya3NwYWNlL21sYWIubG9jYWwudGVzdC9hc3NldHMvanMvbWxhYl9lZGl0b3IuaW5pdC5qc1wiKVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIhLi9hc3NldHMvanMvbWxhYl9lZGl0b3IuaW5pdC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvc2NyaXB0LWxvYWRlci9pbmRleC5qcyEuL2Fzc2V0cy9qcy9tbGFiX2VkaXRvci5pbml0LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInJlcXVpcmUoXCIhIS9ob21lL29zYm94ZXMvd29ya3NwYWNlL21sYWIubG9jYWwudGVzdC9ub2RlX21vZHVsZXMvc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanNcIikocmVxdWlyZShcIiEhL2hvbWUvb3Nib3hlcy93b3Jrc3BhY2UvbWxhYi5sb2NhbC50ZXN0L25vZGVfbW9kdWxlcy9yYXctbG9hZGVyL2luZGV4LmpzIS9ob21lL29zYm94ZXMvd29ya3NwYWNlL21sYWIubG9jYWwudGVzdC9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0wLTAhL2hvbWUvb3Nib3hlcy93b3Jrc3BhY2UvbWxhYi5sb2NhbC50ZXN0L2Fzc2V0cy9qcy9zcGluLmpzXCIpK1wiXFxuXFxuLy8gU0NSSVBULUxPQURFUiBGT09URVJcXG4vLyMgc291cmNlVVJMPXNjcmlwdDovLy9ob21lL29zYm94ZXMvd29ya3NwYWNlL21sYWIubG9jYWwudGVzdC9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyUzRj9yZWYtLTAtMCEvaG9tZS9vc2JveGVzL3dvcmtzcGFjZS9tbGFiLmxvY2FsLnRlc3QvYXNzZXRzL2pzL3NwaW4uanNcIilcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyIS4vYXNzZXRzL2pzL3NwaW4uanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvaW5kZXguanMhLi9hc3NldHMvanMvc3Bpbi5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9