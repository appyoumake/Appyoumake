/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/build/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./assets/js/admin.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./assets/js/admin.js":
/*!****************************!*\
  !*** ./assets/js/admin.js ***!
  \****************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

/* 
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
__webpack_require__(/*! script-loader!./jstree-3.3.3.js */ "./node_modules/script-loader/index.js!./assets/js/jstree-3.3.3.js");

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./node_modules/babel-loader/lib/index.js??ref--0-0!./assets/js/jstree-3.3.3.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/raw-loader!./node_modules/babel-loader/lib??ref--0-0!./assets/js/jstree-3.3.3.js ***!
  \*******************************************************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports) {

module.exports = "var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/*globals jQuery, define, module, exports, require, window, document, postMessage */\n(function (factory) {\n\t\"use strict\";\n\n\tif (typeof define === 'function' && define.amd) {\n\t\tdefine(['jquery'], factory);\n\t} else if (typeof module !== 'undefined' && module.exports) {\n\t\tmodule.exports = factory(require('jquery'));\n\t} else {\n\t\tfactory(jQuery);\n\t}\n})(function ($, undefined) {\n\t\"use strict\";\n\t/*!\n  * jsTree 3.3.3\n  * http://jstree.com/\n  *\n  * Copyright (c) 2014 Ivan Bozhanov (http://vakata.com)\n  *\n  * Licensed same as jquery - under the terms of the MIT License\n  *   http://www.opensource.org/licenses/mit-license.php\n  */\n\t/*!\n  * if using jslint please allow for the jQuery global and use following options:\n  * jslint: loopfunc: true, browser: true, ass: true, bitwise: true, continue: true, nomen: true, plusplus: true, regexp: true, unparam: true, todo: true, white: true\n  */\n\t/*jshint -W083 */\n\n\t// prevent another load? maybe there is a better way?\n\n\tif ($.jstree) {\n\t\treturn;\n\t}\n\n\t/**\n  * ### jsTree core functionality\n  */\n\n\t// internal variables\n\tvar instance_counter = 0,\n\t    ccp_node = false,\n\t    ccp_mode = false,\n\t    ccp_inst = false,\n\t    themes_loaded = [],\n\t    src = $('script:last').attr('src'),\n\t    document = window.document; // local variable is always faster to access then a global\n\n\t/**\n  * holds all jstree related functions and variables, including the actual class and methods to create, access and manipulate instances.\n  * @name $.jstree\n  */\n\t$.jstree = {\n\t\t/**\n   * specifies the jstree version in use\n   * @name $.jstree.version\n   */\n\t\tversion: '3.3.3',\n\t\t/**\n   * holds all the default options used when creating new instances\n   * @name $.jstree.defaults\n   */\n\t\tdefaults: {\n\t\t\t/**\n    * configure which plugins will be active on an instance. Should be an array of strings, where each element is a plugin name. The default is `[]`\n    * @name $.jstree.defaults.plugins\n    */\n\t\t\tplugins: []\n\t\t},\n\t\t/**\n   * stores all loaded jstree plugins (used internally)\n   * @name $.jstree.plugins\n   */\n\t\tplugins: {},\n\t\tpath: src && src.indexOf('/') !== -1 ? src.replace(/\\/[^\\/]+$/, '') : '',\n\t\tidregex: /[\\\\:&!^|()\\[\\]<>@*'+~#\";.,=\\- \\/${}%?`]/g,\n\t\troot: '#'\n\t};\n\n\t/**\n  * creates a jstree instance\n  * @name $.jstree.create(el [, options])\n  * @param {DOMElement|jQuery|String} el the element to create the instance on, can be jQuery extended or a selector\n  * @param {Object} options options for this instance (extends `$.jstree.defaults`)\n  * @return {jsTree} the new instance\n  */\n\t$.jstree.create = function (el, options) {\n\t\tvar tmp = new $.jstree.core(++instance_counter),\n\t\t    opt = options;\n\t\toptions = $.extend(true, {}, $.jstree.defaults, options);\n\t\tif (opt && opt.plugins) {\n\t\t\toptions.plugins = opt.plugins;\n\t\t}\n\t\t$.each(options.plugins, function (i, k) {\n\t\t\tif (i !== 'core') {\n\t\t\t\ttmp = tmp.plugin(k, options[k]);\n\t\t\t}\n\t\t});\n\t\t$(el).data('jstree', tmp);\n\t\ttmp.init(el, options);\n\t\treturn tmp;\n\t};\n\t/**\n  * remove all traces of jstree from the DOM and destroy all instances\n  * @name $.jstree.destroy()\n  */\n\t$.jstree.destroy = function () {\n\t\t$('.jstree:jstree').jstree('destroy');\n\t\t$(document).off('.jstree');\n\t};\n\t/**\n  * the jstree class constructor, used only internally\n  * @private\n  * @name $.jstree.core(id)\n  * @param {Number} id this instance's index\n  */\n\t$.jstree.core = function (id) {\n\t\tthis._id = id;\n\t\tthis._cnt = 0;\n\t\tthis._wrk = null;\n\t\tthis._data = {\n\t\t\tcore: {\n\t\t\t\tthemes: {\n\t\t\t\t\tname: false,\n\t\t\t\t\tdots: false,\n\t\t\t\t\ticons: false,\n\t\t\t\t\tellipsis: false\n\t\t\t\t},\n\t\t\t\tselected: [],\n\t\t\t\tlast_error: {},\n\t\t\t\tworking: false,\n\t\t\t\tworker_queue: [],\n\t\t\t\tfocused: null\n\t\t\t}\n\t\t};\n\t};\n\t/**\n  * get a reference to an existing instance\n  *\n  * __Examples__\n  *\n  *\t// provided a container with an ID of \"tree\", and a nested node with an ID of \"branch\"\n  *\t// all of there will return the same instance\n  *\t$.jstree.reference('tree');\n  *\t$.jstree.reference('#tree');\n  *\t$.jstree.reference($('#tree'));\n  *\t$.jstree.reference(document.getElementByID('tree'));\n  *\t$.jstree.reference('branch');\n  *\t$.jstree.reference('#branch');\n  *\t$.jstree.reference($('#branch'));\n  *\t$.jstree.reference(document.getElementByID('branch'));\n  *\n  * @name $.jstree.reference(needle)\n  * @param {DOMElement|jQuery|String} needle\n  * @return {jsTree|null} the instance or `null` if not found\n  */\n\t$.jstree.reference = function (needle) {\n\t\tvar tmp = null,\n\t\t    obj = null;\n\t\tif (needle && needle.id && (!needle.tagName || !needle.nodeType)) {\n\t\t\tneedle = needle.id;\n\t\t}\n\n\t\tif (!obj || !obj.length) {\n\t\t\ttry {\n\t\t\t\tobj = $(needle);\n\t\t\t} catch (ignore) {}\n\t\t}\n\t\tif (!obj || !obj.length) {\n\t\t\ttry {\n\t\t\t\tobj = $('#' + needle.replace($.jstree.idregex, '\\\\$&'));\n\t\t\t} catch (ignore) {}\n\t\t}\n\t\tif (obj && obj.length && (obj = obj.closest('.jstree')).length && (obj = obj.data('jstree'))) {\n\t\t\ttmp = obj;\n\t\t} else {\n\t\t\t$('.jstree').each(function () {\n\t\t\t\tvar inst = $(this).data('jstree');\n\t\t\t\tif (inst && inst._model.data[needle]) {\n\t\t\t\t\ttmp = inst;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn tmp;\n\t};\n\t/**\n  * Create an instance, get an instance or invoke a command on a instance.\n  *\n  * If there is no instance associated with the current node a new one is created and `arg` is used to extend `$.jstree.defaults` for this new instance. There would be no return value (chaining is not broken).\n  *\n  * If there is an existing instance and `arg` is a string the command specified by `arg` is executed on the instance, with any additional arguments passed to the function. If the function returns a value it will be returned (chaining could break depending on function).\n  *\n  * If there is an existing instance and `arg` is not a string the instance itself is returned (similar to `$.jstree.reference`).\n  *\n  * In any other case - nothing is returned and chaining is not broken.\n  *\n  * __Examples__\n  *\n  *\t$('#tree1').jstree(); // creates an instance\n  *\t$('#tree2').jstree({ plugins : [] }); // create an instance with some options\n  *\t$('#tree1').jstree('open_node', '#branch_1'); // call a method on an existing instance, passing additional arguments\n  *\t$('#tree2').jstree(); // get an existing instance (or create an instance)\n  *\t$('#tree2').jstree(true); // get an existing instance (will not create new instance)\n  *\t$('#branch_1').jstree().select_node('#branch_1'); // get an instance (using a nested element and call a method)\n  *\n  * @name $().jstree([arg])\n  * @param {String|Object} arg\n  * @return {Mixed}\n  */\n\t$.fn.jstree = function (arg) {\n\t\t// check for string argument\n\t\tvar is_method = typeof arg === 'string',\n\t\t    args = Array.prototype.slice.call(arguments, 1),\n\t\t    result = null;\n\t\tif (arg === true && !this.length) {\n\t\t\treturn false;\n\t\t}\n\t\tthis.each(function () {\n\t\t\t// get the instance (if there is one) and method (if it exists)\n\t\t\tvar instance = $.jstree.reference(this),\n\t\t\t    method = is_method && instance ? instance[arg] : null;\n\t\t\t// if calling a method, and method is available - execute on the instance\n\t\t\tresult = is_method && method ? method.apply(instance, args) : null;\n\t\t\t// if there is no instance and no method is being called - create one\n\t\t\tif (!instance && !is_method && (arg === undefined || $.isPlainObject(arg))) {\n\t\t\t\t$.jstree.create(this, arg);\n\t\t\t}\n\t\t\t// if there is an instance and no method is called - return the instance\n\t\t\tif (instance && !is_method || arg === true) {\n\t\t\t\tresult = instance || false;\n\t\t\t}\n\t\t\t// if there was a method call which returned a result - break and return the value\n\t\t\tif (result !== null && result !== undefined) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\t\t// if there was a method call with a valid return value - return that, otherwise continue the chain\n\t\treturn result !== null && result !== undefined ? result : this;\n\t};\n\t/**\n  * used to find elements containing an instance\n  *\n  * __Examples__\n  *\n  *\t$('div:jstree').each(function () {\n  *\t\t$(this).jstree('destroy');\n  *\t});\n  *\n  * @name $(':jstree')\n  * @return {jQuery}\n  */\n\t$.expr.pseudos.jstree = $.expr.createPseudo(function (search) {\n\t\treturn function (a) {\n\t\t\treturn $(a).hasClass('jstree') && $(a).data('jstree') !== undefined;\n\t\t};\n\t});\n\n\t/**\n  * stores all defaults for the core\n  * @name $.jstree.defaults.core\n  */\n\t$.jstree.defaults.core = {\n\t\t/**\n   * data configuration\n   *\n   * If left as `false` the HTML inside the jstree container element is used to populate the tree (that should be an unordered list with list items).\n   *\n   * You can also pass in a HTML string or a JSON array here.\n   *\n   * It is possible to pass in a standard jQuery-like AJAX config and jstree will automatically determine if the response is JSON or HTML and use that to populate the tree.\n   * In addition to the standard jQuery ajax options here you can suppy functions for `data` and `url`, the functions will be run in the current instance's scope and a param will be passed indicating which node is being loaded, the return value of those functions will be used.\n   *\n   * The last option is to specify a function, that function will receive the node being loaded as argument and a second param which is a function which should be called with the result.\n   *\n   * __Examples__\n   *\n   *\t// AJAX\n   *\t$('#tree').jstree({\n   *\t\t'core' : {\n   *\t\t\t'data' : {\n   *\t\t\t\t'url' : '/get/children/',\n   *\t\t\t\t'data' : function (node) {\n   *\t\t\t\t\treturn { 'id' : node.id };\n   *\t\t\t\t}\n   *\t\t\t}\n   *\t\t});\n   *\n   *\t// direct data\n   *\t$('#tree').jstree({\n   *\t\t'core' : {\n   *\t\t\t'data' : [\n   *\t\t\t\t'Simple root node',\n   *\t\t\t\t{\n   *\t\t\t\t\t'id' : 'node_2',\n   *\t\t\t\t\t'text' : 'Root node with options',\n   *\t\t\t\t\t'state' : { 'opened' : true, 'selected' : true },\n   *\t\t\t\t\t'children' : [ { 'text' : 'Child 1' }, 'Child 2']\n   *\t\t\t\t}\n   *\t\t\t]\n   *\t\t}\n   *\t});\n   *\n   *\t// function\n   *\t$('#tree').jstree({\n   *\t\t'core' : {\n   *\t\t\t'data' : function (obj, callback) {\n   *\t\t\t\tcallback.call(this, ['Root 1', 'Root 2']);\n   *\t\t\t}\n   *\t\t});\n   *\n   * @name $.jstree.defaults.core.data\n   */\n\t\tdata: false,\n\t\t/**\n   * configure the various strings used throughout the tree\n   *\n   * You can use an object where the key is the string you need to replace and the value is your replacement.\n   * Another option is to specify a function which will be called with an argument of the needed string and should return the replacement.\n   * If left as `false` no replacement is made.\n   *\n   * __Examples__\n   *\n   *\t$('#tree').jstree({\n   *\t\t'core' : {\n   *\t\t\t'strings' : {\n   *\t\t\t\t'Loading ...' : 'Please wait ...'\n   *\t\t\t}\n   *\t\t}\n   *\t});\n   *\n   * @name $.jstree.defaults.core.strings\n   */\n\t\tstrings: false,\n\t\t/**\n   * determines what happens when a user tries to modify the structure of the tree\n   * If left as `false` all operations like create, rename, delete, move or copy are prevented.\n   * You can set this to `true` to allow all interactions or use a function to have better control.\n   *\n   * __Examples__\n   *\n   *\t$('#tree').jstree({\n   *\t\t'core' : {\n   *\t\t\t'check_callback' : function (operation, node, node_parent, node_position, more) {\n   *\t\t\t\t// operation can be 'create_node', 'rename_node', 'delete_node', 'move_node' or 'copy_node'\n   *\t\t\t\t// in case of 'rename_node' node_position is filled with the new node name\n   *\t\t\t\treturn operation === 'rename_node' ? true : false;\n   *\t\t\t}\n   *\t\t}\n   *\t});\n   *\n   * @name $.jstree.defaults.core.check_callback\n   */\n\t\tcheck_callback: false,\n\t\t/**\n   * a callback called with a single object parameter in the instance's scope when something goes wrong (operation prevented, ajax failed, etc)\n   * @name $.jstree.defaults.core.error\n   */\n\t\terror: $.noop,\n\t\t/**\n   * the open / close animation duration in milliseconds - set this to `false` to disable the animation (default is `200`)\n   * @name $.jstree.defaults.core.animation\n   */\n\t\tanimation: 200,\n\t\t/**\n   * a boolean indicating if multiple nodes can be selected\n   * @name $.jstree.defaults.core.multiple\n   */\n\t\tmultiple: true,\n\t\t/**\n   * theme configuration object\n   * @name $.jstree.defaults.core.themes\n   */\n\t\tthemes: {\n\t\t\t/**\n    * the name of the theme to use (if left as `false` the default theme is used)\n    * @name $.jstree.defaults.core.themes.name\n    */\n\t\t\tname: false,\n\t\t\t/**\n    * the URL of the theme's CSS file, leave this as `false` if you have manually included the theme CSS (recommended). You can set this to `true` too which will try to autoload the theme.\n    * @name $.jstree.defaults.core.themes.url\n    */\n\t\t\turl: false,\n\t\t\t/**\n    * the location of all jstree themes - only used if `url` is set to `true`\n    * @name $.jstree.defaults.core.themes.dir\n    */\n\t\t\tdir: false,\n\t\t\t/**\n    * a boolean indicating if connecting dots are shown\n    * @name $.jstree.defaults.core.themes.dots\n    */\n\t\t\tdots: true,\n\t\t\t/**\n    * a boolean indicating if node icons are shown\n    * @name $.jstree.defaults.core.themes.icons\n    */\n\t\t\ticons: true,\n\t\t\t/**\n    * a boolean indicating if node ellipsis should be shown - this only works with a fixed with on the container\n    * @name $.jstree.defaults.core.themes.ellipsis\n    */\n\t\t\tellipsis: false,\n\t\t\t/**\n    * a boolean indicating if the tree background is striped\n    * @name $.jstree.defaults.core.themes.stripes\n    */\n\t\t\tstripes: false,\n\t\t\t/**\n    * a string (or boolean `false`) specifying the theme variant to use (if the theme supports variants)\n    * @name $.jstree.defaults.core.themes.variant\n    */\n\t\t\tvariant: false,\n\t\t\t/**\n    * a boolean specifying if a reponsive version of the theme should kick in on smaller screens (if the theme supports it). Defaults to `false`.\n    * @name $.jstree.defaults.core.themes.responsive\n    */\n\t\t\tresponsive: false\n\t\t},\n\t\t/**\n   * if left as `true` all parents of all selected nodes will be opened once the tree loads (so that all selected nodes are visible to the user)\n   * @name $.jstree.defaults.core.expand_selected_onload\n   */\n\t\texpand_selected_onload: true,\n\t\t/**\n   * if left as `true` web workers will be used to parse incoming JSON data where possible, so that the UI will not be blocked by large requests. Workers are however about 30% slower. Defaults to `true`\n   * @name $.jstree.defaults.core.worker\n   */\n\t\tworker: true,\n\t\t/**\n   * Force node text to plain text (and escape HTML). Defaults to `false`\n   * @name $.jstree.defaults.core.force_text\n   */\n\t\tforce_text: false,\n\t\t/**\n   * Should the node should be toggled if the text is double clicked . Defaults to `true`\n   * @name $.jstree.defaults.core.dblclick_toggle\n   */\n\t\tdblclick_toggle: true\n\t};\n\t$.jstree.core.prototype = {\n\t\t/**\n   * used to decorate an instance with a plugin. Used internally.\n   * @private\n   * @name plugin(deco [, opts])\n   * @param  {String} deco the plugin to decorate with\n   * @param  {Object} opts options for the plugin\n   * @return {jsTree}\n   */\n\t\tplugin: function plugin(deco, opts) {\n\t\t\tvar Child = $.jstree.plugins[deco];\n\t\t\tif (Child) {\n\t\t\t\tthis._data[deco] = {};\n\t\t\t\tChild.prototype = this;\n\t\t\t\treturn new Child(opts, this);\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\t\t/**\n   * initialize the instance. Used internally.\n   * @private\n   * @name init(el, optons)\n   * @param {DOMElement|jQuery|String} el the element we are transforming\n   * @param {Object} options options for this instance\n   * @trigger init.jstree, loading.jstree, loaded.jstree, ready.jstree, changed.jstree\n   */\n\t\tinit: function init(el, options) {\n\t\t\tthis._model = {\n\t\t\t\tdata: {},\n\t\t\t\tchanged: [],\n\t\t\t\tforce_full_redraw: false,\n\t\t\t\tredraw_timeout: false,\n\t\t\t\tdefault_state: {\n\t\t\t\t\tloaded: true,\n\t\t\t\t\topened: false,\n\t\t\t\t\tselected: false,\n\t\t\t\t\tdisabled: false\n\t\t\t\t}\n\t\t\t};\n\t\t\tthis._model.data[$.jstree.root] = {\n\t\t\t\tid: $.jstree.root,\n\t\t\t\tparent: null,\n\t\t\t\tparents: [],\n\t\t\t\tchildren: [],\n\t\t\t\tchildren_d: [],\n\t\t\t\tstate: { loaded: false }\n\t\t\t};\n\n\t\t\tthis.element = $(el).addClass('jstree jstree-' + this._id);\n\t\t\tthis.settings = options;\n\n\t\t\tthis._data.core.ready = false;\n\t\t\tthis._data.core.loaded = false;\n\t\t\tthis._data.core.rtl = this.element.css(\"direction\") === \"rtl\";\n\t\t\tthis.element[this._data.core.rtl ? 'addClass' : 'removeClass'](\"jstree-rtl\");\n\t\t\tthis.element.attr('role', 'tree');\n\t\t\tif (this.settings.core.multiple) {\n\t\t\t\tthis.element.attr('aria-multiselectable', true);\n\t\t\t}\n\t\t\tif (!this.element.attr('tabindex')) {\n\t\t\t\tthis.element.attr('tabindex', '0');\n\t\t\t}\n\n\t\t\tthis.bind();\n\t\t\t/**\n    * triggered after all events are bound\n    * @event\n    * @name init.jstree\n    */\n\t\t\tthis.trigger(\"init\");\n\n\t\t\tthis._data.core.original_container_html = this.element.find(\" > ul > li\").clone(true);\n\t\t\tthis._data.core.original_container_html.find(\"li\").addBack().contents().filter(function () {\n\t\t\t\treturn this.nodeType === 3 && (!this.nodeValue || /^\\s+$/.test(this.nodeValue));\n\t\t\t}).remove();\n\t\t\tthis.element.html(\"<\" + \"ul class='jstree-container-ul jstree-children' role='group'><\" + \"li id='j\" + this._id + \"_loading' class='jstree-initial-node jstree-loading jstree-leaf jstree-last' role='tree-item'><i class='jstree-icon jstree-ocl'></i><\" + \"a class='jstree-anchor' href='#'><i class='jstree-icon jstree-themeicon-hidden'></i>\" + this.get_string(\"Loading ...\") + \"</a></li></ul>\");\n\t\t\tthis.element.attr('aria-activedescendant', 'j' + this._id + '_loading');\n\t\t\tthis._data.core.li_height = this.get_container_ul().children(\"li\").first().height() || 24;\n\t\t\tthis._data.core.node = this._create_prototype_node();\n\t\t\t/**\n    * triggered after the loading text is shown and before loading starts\n    * @event\n    * @name loading.jstree\n    */\n\t\t\tthis.trigger(\"loading\");\n\t\t\tthis.load_node($.jstree.root);\n\t\t},\n\t\t/**\n   * destroy an instance\n   * @name destroy()\n   * @param  {Boolean} keep_html if not set to `true` the container will be emptied, otherwise the current DOM elements will be kept intact\n   */\n\t\tdestroy: function destroy(keep_html) {\n\t\t\tif (this._wrk) {\n\t\t\t\ttry {\n\t\t\t\t\twindow.URL.revokeObjectURL(this._wrk);\n\t\t\t\t\tthis._wrk = null;\n\t\t\t\t} catch (ignore) {}\n\t\t\t}\n\t\t\tif (!keep_html) {\n\t\t\t\tthis.element.empty();\n\t\t\t}\n\t\t\tthis.teardown();\n\t\t},\n\t\t/**\n   * Create prototype node\n   */\n\t\t_create_prototype_node: function _create_prototype_node() {\n\t\t\tvar _node = document.createElement('LI'),\n\t\t\t    _temp1,\n\t\t\t    _temp2;\n\t\t\t_node.setAttribute('role', 'treeitem');\n\t\t\t_temp1 = document.createElement('I');\n\t\t\t_temp1.className = 'jstree-icon jstree-ocl';\n\t\t\t_temp1.setAttribute('role', 'presentation');\n\t\t\t_node.appendChild(_temp1);\n\t\t\t_temp1 = document.createElement('A');\n\t\t\t_temp1.className = 'jstree-anchor';\n\t\t\t_temp1.setAttribute('href', '#');\n\t\t\t_temp1.setAttribute('tabindex', '-1');\n\t\t\t_temp2 = document.createElement('I');\n\t\t\t_temp2.className = 'jstree-icon jstree-themeicon';\n\t\t\t_temp2.setAttribute('role', 'presentation');\n\t\t\t_temp1.appendChild(_temp2);\n\t\t\t_node.appendChild(_temp1);\n\t\t\t_temp1 = _temp2 = null;\n\n\t\t\treturn _node;\n\t\t},\n\t\t/**\n   * part of the destroying of an instance. Used internally.\n   * @private\n   * @name teardown()\n   */\n\t\tteardown: function teardown() {\n\t\t\tthis.unbind();\n\t\t\tthis.element.removeClass('jstree').removeData('jstree').find(\"[class^='jstree']\").addBack().attr(\"class\", function () {\n\t\t\t\treturn this.className.replace(/jstree[^ ]*|$/ig, '');\n\t\t\t});\n\t\t\tthis.element = null;\n\t\t},\n\t\t/**\n   * bind all events. Used internally.\n   * @private\n   * @name bind()\n   */\n\t\tbind: function bind() {\n\t\t\tvar word = '',\n\t\t\t    tout = null,\n\t\t\t    was_click = 0;\n\t\t\tthis.element.on(\"dblclick.jstree\", function (e) {\n\t\t\t\tif (e.target.tagName && e.target.tagName.toLowerCase() === \"input\") {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (document.selection && document.selection.empty) {\n\t\t\t\t\tdocument.selection.empty();\n\t\t\t\t} else {\n\t\t\t\t\tif (window.getSelection) {\n\t\t\t\t\t\tvar sel = window.getSelection();\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tsel.removeAllRanges();\n\t\t\t\t\t\t\tsel.collapse();\n\t\t\t\t\t\t} catch (ignore) {}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}).on(\"mousedown.jstree\", $.proxy(function (e) {\n\t\t\t\tif (e.target === this.element[0]) {\n\t\t\t\t\te.preventDefault(); // prevent losing focus when clicking scroll arrows (FF, Chrome)\n\t\t\t\t\twas_click = +new Date(); // ie does not allow to prevent losing focus\n\t\t\t\t}\n\t\t\t}, this)).on(\"mousedown.jstree\", \".jstree-ocl\", function (e) {\n\t\t\t\te.preventDefault(); // prevent any node inside from losing focus when clicking the open/close icon\n\t\t\t}).on(\"click.jstree\", \".jstree-ocl\", $.proxy(function (e) {\n\t\t\t\tthis.toggle_node(e.target);\n\t\t\t}, this)).on(\"dblclick.jstree\", \".jstree-anchor\", $.proxy(function (e) {\n\t\t\t\tif (e.target.tagName && e.target.tagName.toLowerCase() === \"input\") {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (this.settings.core.dblclick_toggle) {\n\t\t\t\t\tthis.toggle_node(e.target);\n\t\t\t\t}\n\t\t\t}, this)).on(\"click.jstree\", \".jstree-anchor\", $.proxy(function (e) {\n\t\t\t\te.preventDefault();\n\t\t\t\tif (e.currentTarget !== document.activeElement) {\n\t\t\t\t\t$(e.currentTarget).focus();\n\t\t\t\t}\n\t\t\t\tthis.activate_node(e.currentTarget, e);\n\t\t\t}, this)).on('keydown.jstree', '.jstree-anchor', $.proxy(function (e) {\n\t\t\t\tif (e.target.tagName && e.target.tagName.toLowerCase() === \"input\") {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (e.which !== 32 && e.which !== 13 && (e.shiftKey || e.ctrlKey || e.altKey || e.metaKey)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tvar o = null;\n\t\t\t\tif (this._data.core.rtl) {\n\t\t\t\t\tif (e.which === 37) {\n\t\t\t\t\t\te.which = 39;\n\t\t\t\t\t} else if (e.which === 39) {\n\t\t\t\t\t\te.which = 37;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tswitch (e.which) {\n\t\t\t\t\tcase 32:\n\t\t\t\t\t\t// aria defines space only with Ctrl\n\t\t\t\t\t\tif (e.ctrlKey) {\n\t\t\t\t\t\t\te.type = \"click\";\n\t\t\t\t\t\t\t$(e.currentTarget).trigger(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 13:\n\t\t\t\t\t\t// enter\n\t\t\t\t\t\te.type = \"click\";\n\t\t\t\t\t\t$(e.currentTarget).trigger(e);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 37:\n\t\t\t\t\t\t// left\n\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\tif (this.is_open(e.currentTarget)) {\n\t\t\t\t\t\t\tthis.close_node(e.currentTarget);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\to = this.get_parent(e.currentTarget);\n\t\t\t\t\t\t\tif (o && o.id !== $.jstree.root) {\n\t\t\t\t\t\t\t\tthis.get_node(o, true).children('.jstree-anchor').focus();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 38:\n\t\t\t\t\t\t// up\n\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\to = this.get_prev_dom(e.currentTarget);\n\t\t\t\t\t\tif (o && o.length) {\n\t\t\t\t\t\t\to.children('.jstree-anchor').focus();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 39:\n\t\t\t\t\t\t// right\n\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\tif (this.is_closed(e.currentTarget)) {\n\t\t\t\t\t\t\tthis.open_node(e.currentTarget, function (o) {\n\t\t\t\t\t\t\t\tthis.get_node(o, true).children('.jstree-anchor').focus();\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else if (this.is_open(e.currentTarget)) {\n\t\t\t\t\t\t\to = this.get_node(e.currentTarget, true).children('.jstree-children')[0];\n\t\t\t\t\t\t\tif (o) {\n\t\t\t\t\t\t\t\t$(this._firstChild(o)).children('.jstree-anchor').focus();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 40:\n\t\t\t\t\t\t// down\n\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\to = this.get_next_dom(e.currentTarget);\n\t\t\t\t\t\tif (o && o.length) {\n\t\t\t\t\t\t\to.children('.jstree-anchor').focus();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 106:\n\t\t\t\t\t\t// aria defines * on numpad as open_all - not very common\n\t\t\t\t\t\tthis.open_all();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 36:\n\t\t\t\t\t\t// home\n\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\to = this._firstChild(this.get_container_ul()[0]);\n\t\t\t\t\t\tif (o) {\n\t\t\t\t\t\t\t$(o).children('.jstree-anchor').filter(':visible').focus();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 35:\n\t\t\t\t\t\t// end\n\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\tthis.element.find('.jstree-anchor').filter(':visible').last().focus();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 113:\n\t\t\t\t\t\t// f2 - safe to include - if check_callback is false it will fail\n\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\tthis.edit(e.currentTarget);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t/*!\n     // delete\n     case 46:\n     \te.preventDefault();\n     \to = this.get_node(e.currentTarget);\n     \tif(o && o.id && o.id !== $.jstree.root) {\n     \t\to = this.is_selected(o) ? this.get_selected() : o;\n     \t\tthis.delete_node(o);\n     \t}\n     \tbreak;\n     \t*/\n\t\t\t\t}\n\t\t\t}, this)).on(\"load_node.jstree\", $.proxy(function (e, data) {\n\t\t\t\tif (data.status) {\n\t\t\t\t\tif (data.node.id === $.jstree.root && !this._data.core.loaded) {\n\t\t\t\t\t\tthis._data.core.loaded = true;\n\t\t\t\t\t\tif (this._firstChild(this.get_container_ul()[0])) {\n\t\t\t\t\t\t\tthis.element.attr('aria-activedescendant', this._firstChild(this.get_container_ul()[0]).id);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/**\n       * triggered after the root node is loaded for the first time\n       * @event\n       * @name loaded.jstree\n       */\n\t\t\t\t\t\tthis.trigger(\"loaded\");\n\t\t\t\t\t}\n\t\t\t\t\tif (!this._data.core.ready) {\n\t\t\t\t\t\tsetTimeout($.proxy(function () {\n\t\t\t\t\t\t\tif (this.element && !this.get_container_ul().find('.jstree-loading').length) {\n\t\t\t\t\t\t\t\tthis._data.core.ready = true;\n\t\t\t\t\t\t\t\tif (this._data.core.selected.length) {\n\t\t\t\t\t\t\t\t\tif (this.settings.core.expand_selected_onload) {\n\t\t\t\t\t\t\t\t\t\tvar tmp = [],\n\t\t\t\t\t\t\t\t\t\t    i,\n\t\t\t\t\t\t\t\t\t\t    j;\n\t\t\t\t\t\t\t\t\t\tfor (i = 0, j = this._data.core.selected.length; i < j; i++) {\n\t\t\t\t\t\t\t\t\t\t\ttmp = tmp.concat(this._model.data[this._data.core.selected[i]].parents);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\ttmp = $.vakata.array_unique(tmp);\n\t\t\t\t\t\t\t\t\t\tfor (i = 0, j = tmp.length; i < j; i++) {\n\t\t\t\t\t\t\t\t\t\t\tthis.open_node(tmp[i], false, 0);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tthis.trigger('changed', { 'action': 'ready', 'selected': this._data.core.selected });\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t/**\n         * triggered after all nodes are finished loading\n         * @event\n         * @name ready.jstree\n         */\n\t\t\t\t\t\t\t\tthis.trigger(\"ready\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, this), 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, this))\n\t\t\t// quick searching when the tree is focused\n\t\t\t.on('keypress.jstree', $.proxy(function (e) {\n\t\t\t\tif (e.target.tagName && e.target.tagName.toLowerCase() === \"input\") {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (tout) {\n\t\t\t\t\tclearTimeout(tout);\n\t\t\t\t}\n\t\t\t\ttout = setTimeout(function () {\n\t\t\t\t\tword = '';\n\t\t\t\t}, 500);\n\n\t\t\t\tvar chr = String.fromCharCode(e.which).toLowerCase(),\n\t\t\t\t    col = this.element.find('.jstree-anchor').filter(':visible'),\n\t\t\t\t    ind = col.index(document.activeElement) || 0,\n\t\t\t\t    end = false;\n\t\t\t\tword += chr;\n\n\t\t\t\t// match for whole word from current node down (including the current node)\n\t\t\t\tif (word.length > 1) {\n\t\t\t\t\tcol.slice(ind).each($.proxy(function (i, v) {\n\t\t\t\t\t\tif ($(v).text().toLowerCase().indexOf(word) === 0) {\n\t\t\t\t\t\t\t$(v).focus();\n\t\t\t\t\t\t\tend = true;\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}, this));\n\t\t\t\t\tif (end) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// match for whole word from the beginning of the tree\n\t\t\t\t\tcol.slice(0, ind).each($.proxy(function (i, v) {\n\t\t\t\t\t\tif ($(v).text().toLowerCase().indexOf(word) === 0) {\n\t\t\t\t\t\t\t$(v).focus();\n\t\t\t\t\t\t\tend = true;\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}, this));\n\t\t\t\t\tif (end) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// list nodes that start with that letter (only if word consists of a single char)\n\t\t\t\tif (new RegExp('^' + chr.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&') + '+$').test(word)) {\n\t\t\t\t\t// search for the next node starting with that letter\n\t\t\t\t\tcol.slice(ind + 1).each($.proxy(function (i, v) {\n\t\t\t\t\t\tif ($(v).text().toLowerCase().charAt(0) === chr) {\n\t\t\t\t\t\t\t$(v).focus();\n\t\t\t\t\t\t\tend = true;\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}, this));\n\t\t\t\t\tif (end) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// search from the beginning\n\t\t\t\t\tcol.slice(0, ind + 1).each($.proxy(function (i, v) {\n\t\t\t\t\t\tif ($(v).text().toLowerCase().charAt(0) === chr) {\n\t\t\t\t\t\t\t$(v).focus();\n\t\t\t\t\t\t\tend = true;\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}, this));\n\t\t\t\t\tif (end) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, this))\n\t\t\t// THEME RELATED\n\t\t\t.on(\"init.jstree\", $.proxy(function () {\n\t\t\t\tvar s = this.settings.core.themes;\n\t\t\t\tthis._data.core.themes.dots = s.dots;\n\t\t\t\tthis._data.core.themes.stripes = s.stripes;\n\t\t\t\tthis._data.core.themes.icons = s.icons;\n\t\t\t\tthis._data.core.themes.ellipsis = s.ellipsis;\n\t\t\t\tthis.set_theme(s.name || \"default\", s.url);\n\t\t\t\tthis.set_theme_variant(s.variant);\n\t\t\t}, this)).on(\"loading.jstree\", $.proxy(function () {\n\t\t\t\tthis[this._data.core.themes.dots ? \"show_dots\" : \"hide_dots\"]();\n\t\t\t\tthis[this._data.core.themes.icons ? \"show_icons\" : \"hide_icons\"]();\n\t\t\t\tthis[this._data.core.themes.stripes ? \"show_stripes\" : \"hide_stripes\"]();\n\t\t\t\tthis[this._data.core.themes.ellipsis ? \"show_ellipsis\" : \"hide_ellipsis\"]();\n\t\t\t}, this)).on('blur.jstree', '.jstree-anchor', $.proxy(function (e) {\n\t\t\t\tthis._data.core.focused = null;\n\t\t\t\t$(e.currentTarget).filter('.jstree-hovered').mouseleave();\n\t\t\t\tthis.element.attr('tabindex', '0');\n\t\t\t}, this)).on('focus.jstree', '.jstree-anchor', $.proxy(function (e) {\n\t\t\t\tvar tmp = this.get_node(e.currentTarget);\n\t\t\t\tif (tmp && tmp.id) {\n\t\t\t\t\tthis._data.core.focused = tmp.id;\n\t\t\t\t}\n\t\t\t\tthis.element.find('.jstree-hovered').not(e.currentTarget).mouseleave();\n\t\t\t\t$(e.currentTarget).mouseenter();\n\t\t\t\tthis.element.attr('tabindex', '-1');\n\t\t\t}, this)).on('focus.jstree', $.proxy(function () {\n\t\t\t\tif (+new Date() - was_click > 500 && !this._data.core.focused) {\n\t\t\t\t\twas_click = 0;\n\t\t\t\t\tvar act = this.get_node(this.element.attr('aria-activedescendant'), true);\n\t\t\t\t\tif (act) {\n\t\t\t\t\t\tact.find('> .jstree-anchor').focus();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, this)).on('mouseenter.jstree', '.jstree-anchor', $.proxy(function (e) {\n\t\t\t\tthis.hover_node(e.currentTarget);\n\t\t\t}, this)).on('mouseleave.jstree', '.jstree-anchor', $.proxy(function (e) {\n\t\t\t\tthis.dehover_node(e.currentTarget);\n\t\t\t}, this));\n\t\t},\n\t\t/**\n   * part of the destroying of an instance. Used internally.\n   * @private\n   * @name unbind()\n   */\n\t\tunbind: function unbind() {\n\t\t\tthis.element.off('.jstree');\n\t\t\t$(document).off('.jstree-' + this._id);\n\t\t},\n\t\t/**\n   * trigger an event. Used internally.\n   * @private\n   * @name trigger(ev [, data])\n   * @param  {String} ev the name of the event to trigger\n   * @param  {Object} data additional data to pass with the event\n   */\n\t\ttrigger: function trigger(ev, data) {\n\t\t\tif (!data) {\n\t\t\t\tdata = {};\n\t\t\t}\n\t\t\tdata.instance = this;\n\t\t\tthis.element.triggerHandler(ev.replace('.jstree', '') + '.jstree', data);\n\t\t},\n\t\t/**\n   * returns the jQuery extended instance container\n   * @name get_container()\n   * @return {jQuery}\n   */\n\t\tget_container: function get_container() {\n\t\t\treturn this.element;\n\t\t},\n\t\t/**\n   * returns the jQuery extended main UL node inside the instance container. Used internally.\n   * @private\n   * @name get_container_ul()\n   * @return {jQuery}\n   */\n\t\tget_container_ul: function get_container_ul() {\n\t\t\treturn this.element.children(\".jstree-children\").first();\n\t\t},\n\t\t/**\n   * gets string replacements (localization). Used internally.\n   * @private\n   * @name get_string(key)\n   * @param  {String} key\n   * @return {String}\n   */\n\t\tget_string: function get_string(key) {\n\t\t\tvar a = this.settings.core.strings;\n\t\t\tif ($.isFunction(a)) {\n\t\t\t\treturn a.call(this, key);\n\t\t\t}\n\t\t\tif (a && a[key]) {\n\t\t\t\treturn a[key];\n\t\t\t}\n\t\t\treturn key;\n\t\t},\n\t\t/**\n   * gets the first child of a DOM node. Used internally.\n   * @private\n   * @name _firstChild(dom)\n   * @param  {DOMElement} dom\n   * @return {DOMElement}\n   */\n\t\t_firstChild: function _firstChild(dom) {\n\t\t\tdom = dom ? dom.firstChild : null;\n\t\t\twhile (dom !== null && dom.nodeType !== 1) {\n\t\t\t\tdom = dom.nextSibling;\n\t\t\t}\n\t\t\treturn dom;\n\t\t},\n\t\t/**\n   * gets the next sibling of a DOM node. Used internally.\n   * @private\n   * @name _nextSibling(dom)\n   * @param  {DOMElement} dom\n   * @return {DOMElement}\n   */\n\t\t_nextSibling: function _nextSibling(dom) {\n\t\t\tdom = dom ? dom.nextSibling : null;\n\t\t\twhile (dom !== null && dom.nodeType !== 1) {\n\t\t\t\tdom = dom.nextSibling;\n\t\t\t}\n\t\t\treturn dom;\n\t\t},\n\t\t/**\n   * gets the previous sibling of a DOM node. Used internally.\n   * @private\n   * @name _previousSibling(dom)\n   * @param  {DOMElement} dom\n   * @return {DOMElement}\n   */\n\t\t_previousSibling: function _previousSibling(dom) {\n\t\t\tdom = dom ? dom.previousSibling : null;\n\t\t\twhile (dom !== null && dom.nodeType !== 1) {\n\t\t\t\tdom = dom.previousSibling;\n\t\t\t}\n\t\t\treturn dom;\n\t\t},\n\t\t/**\n   * get the JSON representation of a node (or the actual jQuery extended DOM node) by using any input (child DOM element, ID string, selector, etc)\n   * @name get_node(obj [, as_dom])\n   * @param  {mixed} obj\n   * @param  {Boolean} as_dom\n   * @return {Object|jQuery}\n   */\n\t\tget_node: function get_node(obj, as_dom) {\n\t\t\tif (obj && obj.id) {\n\t\t\t\tobj = obj.id;\n\t\t\t}\n\t\t\tvar dom;\n\t\t\ttry {\n\t\t\t\tif (this._model.data[obj]) {\n\t\t\t\t\tobj = this._model.data[obj];\n\t\t\t\t} else if (typeof obj === \"string\" && this._model.data[obj.replace(/^#/, '')]) {\n\t\t\t\t\tobj = this._model.data[obj.replace(/^#/, '')];\n\t\t\t\t} else if (typeof obj === \"string\" && (dom = $('#' + obj.replace($.jstree.idregex, '\\\\$&'), this.element)).length && this._model.data[dom.closest('.jstree-node').attr('id')]) {\n\t\t\t\t\tobj = this._model.data[dom.closest('.jstree-node').attr('id')];\n\t\t\t\t} else if ((dom = $(obj, this.element)).length && this._model.data[dom.closest('.jstree-node').attr('id')]) {\n\t\t\t\t\tobj = this._model.data[dom.closest('.jstree-node').attr('id')];\n\t\t\t\t} else if ((dom = $(obj, this.element)).length && dom.hasClass('jstree')) {\n\t\t\t\t\tobj = this._model.data[$.jstree.root];\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif (as_dom) {\n\t\t\t\t\tobj = obj.id === $.jstree.root ? this.element : $('#' + obj.id.replace($.jstree.idregex, '\\\\$&'), this.element);\n\t\t\t\t}\n\t\t\t\treturn obj;\n\t\t\t} catch (ex) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\t/**\n   * get the path to a node, either consisting of node texts, or of node IDs, optionally glued together (otherwise an array)\n   * @name get_path(obj [, glue, ids])\n   * @param  {mixed} obj the node\n   * @param  {String} glue if you want the path as a string - pass the glue here (for example '/'), if a falsy value is supplied here, an array is returned\n   * @param  {Boolean} ids if set to true build the path using ID, otherwise node text is used\n   * @return {mixed}\n   */\n\t\tget_path: function get_path(obj, glue, ids) {\n\t\t\tobj = obj.parents ? obj : this.get_node(obj);\n\t\t\tif (!obj || obj.id === $.jstree.root || !obj.parents) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar i,\n\t\t\t    j,\n\t\t\t    p = [];\n\t\t\tp.push(ids ? obj.id : obj.text);\n\t\t\tfor (i = 0, j = obj.parents.length; i < j; i++) {\n\t\t\t\tp.push(ids ? obj.parents[i] : this.get_text(obj.parents[i]));\n\t\t\t}\n\t\t\tp = p.reverse().slice(1);\n\t\t\treturn glue ? p.join(glue) : p;\n\t\t},\n\t\t/**\n   * get the next visible node that is below the `obj` node. If `strict` is set to `true` only sibling nodes are returned.\n   * @name get_next_dom(obj [, strict])\n   * @param  {mixed} obj\n   * @param  {Boolean} strict\n   * @return {jQuery}\n   */\n\t\tget_next_dom: function get_next_dom(obj, strict) {\n\t\t\tvar tmp;\n\t\t\tobj = this.get_node(obj, true);\n\t\t\tif (obj[0] === this.element[0]) {\n\t\t\t\ttmp = this._firstChild(this.get_container_ul()[0]);\n\t\t\t\twhile (tmp && tmp.offsetHeight === 0) {\n\t\t\t\t\ttmp = this._nextSibling(tmp);\n\t\t\t\t}\n\t\t\t\treturn tmp ? $(tmp) : false;\n\t\t\t}\n\t\t\tif (!obj || !obj.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (strict) {\n\t\t\t\ttmp = obj[0];\n\t\t\t\tdo {\n\t\t\t\t\ttmp = this._nextSibling(tmp);\n\t\t\t\t} while (tmp && tmp.offsetHeight === 0);\n\t\t\t\treturn tmp ? $(tmp) : false;\n\t\t\t}\n\t\t\tif (obj.hasClass(\"jstree-open\")) {\n\t\t\t\ttmp = this._firstChild(obj.children('.jstree-children')[0]);\n\t\t\t\twhile (tmp && tmp.offsetHeight === 0) {\n\t\t\t\t\ttmp = this._nextSibling(tmp);\n\t\t\t\t}\n\t\t\t\tif (tmp !== null) {\n\t\t\t\t\treturn $(tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t\ttmp = obj[0];\n\t\t\tdo {\n\t\t\t\ttmp = this._nextSibling(tmp);\n\t\t\t} while (tmp && tmp.offsetHeight === 0);\n\t\t\tif (tmp !== null) {\n\t\t\t\treturn $(tmp);\n\t\t\t}\n\t\t\treturn obj.parentsUntil(\".jstree\", \".jstree-node\").nextAll(\".jstree-node:visible\").first();\n\t\t},\n\t\t/**\n   * get the previous visible node that is above the `obj` node. If `strict` is set to `true` only sibling nodes are returned.\n   * @name get_prev_dom(obj [, strict])\n   * @param  {mixed} obj\n   * @param  {Boolean} strict\n   * @return {jQuery}\n   */\n\t\tget_prev_dom: function get_prev_dom(obj, strict) {\n\t\t\tvar tmp;\n\t\t\tobj = this.get_node(obj, true);\n\t\t\tif (obj[0] === this.element[0]) {\n\t\t\t\ttmp = this.get_container_ul()[0].lastChild;\n\t\t\t\twhile (tmp && tmp.offsetHeight === 0) {\n\t\t\t\t\ttmp = this._previousSibling(tmp);\n\t\t\t\t}\n\t\t\t\treturn tmp ? $(tmp) : false;\n\t\t\t}\n\t\t\tif (!obj || !obj.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (strict) {\n\t\t\t\ttmp = obj[0];\n\t\t\t\tdo {\n\t\t\t\t\ttmp = this._previousSibling(tmp);\n\t\t\t\t} while (tmp && tmp.offsetHeight === 0);\n\t\t\t\treturn tmp ? $(tmp) : false;\n\t\t\t}\n\t\t\ttmp = obj[0];\n\t\t\tdo {\n\t\t\t\ttmp = this._previousSibling(tmp);\n\t\t\t} while (tmp && tmp.offsetHeight === 0);\n\t\t\tif (tmp !== null) {\n\t\t\t\tobj = $(tmp);\n\t\t\t\twhile (obj.hasClass(\"jstree-open\")) {\n\t\t\t\t\tobj = obj.children(\".jstree-children\").first().children(\".jstree-node:visible:last\");\n\t\t\t\t}\n\t\t\t\treturn obj;\n\t\t\t}\n\t\t\ttmp = obj[0].parentNode.parentNode;\n\t\t\treturn tmp && tmp.className && tmp.className.indexOf('jstree-node') !== -1 ? $(tmp) : false;\n\t\t},\n\t\t/**\n   * get the parent ID of a node\n   * @name get_parent(obj)\n   * @param  {mixed} obj\n   * @return {String}\n   */\n\t\tget_parent: function get_parent(obj) {\n\t\t\tobj = this.get_node(obj);\n\t\t\tif (!obj || obj.id === $.jstree.root) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn obj.parent;\n\t\t},\n\t\t/**\n   * get a jQuery collection of all the children of a node (node must be rendered)\n   * @name get_children_dom(obj)\n   * @param  {mixed} obj\n   * @return {jQuery}\n   */\n\t\tget_children_dom: function get_children_dom(obj) {\n\t\t\tobj = this.get_node(obj, true);\n\t\t\tif (obj[0] === this.element[0]) {\n\t\t\t\treturn this.get_container_ul().children(\".jstree-node\");\n\t\t\t}\n\t\t\tif (!obj || !obj.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn obj.children(\".jstree-children\").children(\".jstree-node\");\n\t\t},\n\t\t/**\n   * checks if a node has children\n   * @name is_parent(obj)\n   * @param  {mixed} obj\n   * @return {Boolean}\n   */\n\t\tis_parent: function is_parent(obj) {\n\t\t\tobj = this.get_node(obj);\n\t\t\treturn obj && (obj.state.loaded === false || obj.children.length > 0);\n\t\t},\n\t\t/**\n   * checks if a node is loaded (its children are available)\n   * @name is_loaded(obj)\n   * @param  {mixed} obj\n   * @return {Boolean}\n   */\n\t\tis_loaded: function is_loaded(obj) {\n\t\t\tobj = this.get_node(obj);\n\t\t\treturn obj && obj.state.loaded;\n\t\t},\n\t\t/**\n   * check if a node is currently loading (fetching children)\n   * @name is_loading(obj)\n   * @param  {mixed} obj\n   * @return {Boolean}\n   */\n\t\tis_loading: function is_loading(obj) {\n\t\t\tobj = this.get_node(obj);\n\t\t\treturn obj && obj.state && obj.state.loading;\n\t\t},\n\t\t/**\n   * check if a node is opened\n   * @name is_open(obj)\n   * @param  {mixed} obj\n   * @return {Boolean}\n   */\n\t\tis_open: function is_open(obj) {\n\t\t\tobj = this.get_node(obj);\n\t\t\treturn obj && obj.state.opened;\n\t\t},\n\t\t/**\n   * check if a node is in a closed state\n   * @name is_closed(obj)\n   * @param  {mixed} obj\n   * @return {Boolean}\n   */\n\t\tis_closed: function is_closed(obj) {\n\t\t\tobj = this.get_node(obj);\n\t\t\treturn obj && this.is_parent(obj) && !obj.state.opened;\n\t\t},\n\t\t/**\n   * check if a node has no children\n   * @name is_leaf(obj)\n   * @param  {mixed} obj\n   * @return {Boolean}\n   */\n\t\tis_leaf: function is_leaf(obj) {\n\t\t\treturn !this.is_parent(obj);\n\t\t},\n\t\t/**\n   * loads a node (fetches its children using the `core.data` setting). Multiple nodes can be passed to by using an array.\n   * @name load_node(obj [, callback])\n   * @param  {mixed} obj\n   * @param  {function} callback a function to be executed once loading is complete, the function is executed in the instance's scope and receives two arguments - the node and a boolean status\n   * @return {Boolean}\n   * @trigger load_node.jstree\n   */\n\t\tload_node: function load_node(obj, callback) {\n\t\t\tvar k, l, i, j, c;\n\t\t\tif ($.isArray(obj)) {\n\t\t\t\tthis._load_nodes(obj.slice(), callback);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tobj = this.get_node(obj);\n\t\t\tif (!obj) {\n\t\t\t\tif (callback) {\n\t\t\t\t\tcallback.call(this, obj, false);\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// if(obj.state.loading) { } // the node is already loading - just wait for it to load and invoke callback? but if called implicitly it should be loaded again?\n\t\t\tif (obj.state.loaded) {\n\t\t\t\tobj.state.loaded = false;\n\t\t\t\tfor (i = 0, j = obj.parents.length; i < j; i++) {\n\t\t\t\t\tthis._model.data[obj.parents[i]].children_d = $.vakata.array_filter(this._model.data[obj.parents[i]].children_d, function (v) {\n\t\t\t\t\t\treturn $.inArray(v, obj.children_d) === -1;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tfor (k = 0, l = obj.children_d.length; k < l; k++) {\n\t\t\t\t\tif (this._model.data[obj.children_d[k]].state.selected) {\n\t\t\t\t\t\tc = true;\n\t\t\t\t\t}\n\t\t\t\t\tdelete this._model.data[obj.children_d[k]];\n\t\t\t\t}\n\t\t\t\tif (c) {\n\t\t\t\t\tthis._data.core.selected = $.vakata.array_filter(this._data.core.selected, function (v) {\n\t\t\t\t\t\treturn $.inArray(v, obj.children_d) === -1;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tobj.children = [];\n\t\t\t\tobj.children_d = [];\n\t\t\t\tif (c) {\n\t\t\t\t\tthis.trigger('changed', { 'action': 'load_node', 'node': obj, 'selected': this._data.core.selected });\n\t\t\t\t}\n\t\t\t}\n\t\t\tobj.state.failed = false;\n\t\t\tobj.state.loading = true;\n\t\t\tthis.get_node(obj, true).addClass(\"jstree-loading\").attr('aria-busy', true);\n\t\t\tthis._load_node(obj, $.proxy(function (status) {\n\t\t\t\tobj = this._model.data[obj.id];\n\t\t\t\tobj.state.loading = false;\n\t\t\t\tobj.state.loaded = status;\n\t\t\t\tobj.state.failed = !obj.state.loaded;\n\t\t\t\tvar dom = this.get_node(obj, true),\n\t\t\t\t    i = 0,\n\t\t\t\t    j = 0,\n\t\t\t\t    m = this._model.data,\n\t\t\t\t    has_children = false;\n\t\t\t\tfor (i = 0, j = obj.children.length; i < j; i++) {\n\t\t\t\t\tif (m[obj.children[i]] && !m[obj.children[i]].state.hidden) {\n\t\t\t\t\t\thas_children = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (obj.state.loaded && dom && dom.length) {\n\t\t\t\t\tdom.removeClass('jstree-closed jstree-open jstree-leaf');\n\t\t\t\t\tif (!has_children) {\n\t\t\t\t\t\tdom.addClass('jstree-leaf');\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (obj.id !== '#') {\n\t\t\t\t\t\t\tdom.addClass(obj.state.opened ? 'jstree-open' : 'jstree-closed');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdom.removeClass(\"jstree-loading\").attr('aria-busy', false);\n\t\t\t\t/**\n     * triggered after a node is loaded\n     * @event\n     * @name load_node.jstree\n     * @param {Object} node the node that was loading\n     * @param {Boolean} status was the node loaded successfully\n     */\n\t\t\t\tthis.trigger('load_node', { \"node\": obj, \"status\": status });\n\t\t\t\tif (callback) {\n\t\t\t\t\tcallback.call(this, obj, status);\n\t\t\t\t}\n\t\t\t}, this));\n\t\t\treturn true;\n\t\t},\n\t\t/**\n   * load an array of nodes (will also load unavailable nodes as soon as the appear in the structure). Used internally.\n   * @private\n   * @name _load_nodes(nodes [, callback])\n   * @param  {array} nodes\n   * @param  {function} callback a function to be executed once loading is complete, the function is executed in the instance's scope and receives one argument - the array passed to _load_nodes\n   */\n\t\t_load_nodes: function _load_nodes(nodes, callback, is_callback, force_reload) {\n\t\t\tvar r = true,\n\t\t\t    c = function c() {\n\t\t\t\tthis._load_nodes(nodes, callback, true);\n\t\t\t},\n\t\t\t    m = this._model.data,\n\t\t\t    i,\n\t\t\t    j,\n\t\t\t    tmp = [];\n\t\t\tfor (i = 0, j = nodes.length; i < j; i++) {\n\t\t\t\tif (m[nodes[i]] && (!m[nodes[i]].state.loaded && !m[nodes[i]].state.failed || !is_callback && force_reload)) {\n\t\t\t\t\tif (!this.is_loading(nodes[i])) {\n\t\t\t\t\t\tthis.load_node(nodes[i], c);\n\t\t\t\t\t}\n\t\t\t\t\tr = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (r) {\n\t\t\t\tfor (i = 0, j = nodes.length; i < j; i++) {\n\t\t\t\t\tif (m[nodes[i]] && m[nodes[i]].state.loaded) {\n\t\t\t\t\t\ttmp.push(nodes[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (callback && !callback.done) {\n\t\t\t\t\tcallback.call(this, tmp);\n\t\t\t\t\tcallback.done = true;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t/**\n   * loads all unloaded nodes\n   * @name load_all([obj, callback])\n   * @param {mixed} obj the node to load recursively, omit to load all nodes in the tree\n   * @param {function} callback a function to be executed once loading all the nodes is complete,\n   * @trigger load_all.jstree\n   */\n\t\tload_all: function load_all(obj, callback) {\n\t\t\tif (!obj) {\n\t\t\t\tobj = $.jstree.root;\n\t\t\t}\n\t\t\tobj = this.get_node(obj);\n\t\t\tif (!obj) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar to_load = [],\n\t\t\t    m = this._model.data,\n\t\t\t    c = m[obj.id].children_d,\n\t\t\t    i,\n\t\t\t    j;\n\t\t\tif (obj.state && !obj.state.loaded) {\n\t\t\t\tto_load.push(obj.id);\n\t\t\t}\n\t\t\tfor (i = 0, j = c.length; i < j; i++) {\n\t\t\t\tif (m[c[i]] && m[c[i]].state && !m[c[i]].state.loaded) {\n\t\t\t\t\tto_load.push(c[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (to_load.length) {\n\t\t\t\tthis._load_nodes(to_load, function () {\n\t\t\t\t\tthis.load_all(obj, callback);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t/**\n     * triggered after a load_all call completes\n     * @event\n     * @name load_all.jstree\n     * @param {Object} node the recursively loaded node\n     */\n\t\t\t\tif (callback) {\n\t\t\t\t\tcallback.call(this, obj);\n\t\t\t\t}\n\t\t\t\tthis.trigger('load_all', { \"node\": obj });\n\t\t\t}\n\t\t},\n\t\t/**\n   * handles the actual loading of a node. Used only internally.\n   * @private\n   * @name _load_node(obj [, callback])\n   * @param  {mixed} obj\n   * @param  {function} callback a function to be executed once loading is complete, the function is executed in the instance's scope and receives one argument - a boolean status\n   * @return {Boolean}\n   */\n\t\t_load_node: function _load_node(obj, callback) {\n\t\t\tvar s = this.settings.core.data,\n\t\t\t    t;\n\t\t\tvar notTextOrCommentNode = function notTextOrCommentNode() {\n\t\t\t\treturn this.nodeType !== 3 && this.nodeType !== 8;\n\t\t\t};\n\t\t\t// use original HTML\n\t\t\tif (!s) {\n\t\t\t\tif (obj.id === $.jstree.root) {\n\t\t\t\t\treturn this._append_html_data(obj, this._data.core.original_container_html.clone(true), function (status) {\n\t\t\t\t\t\tcallback.call(this, status);\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturn callback.call(this, false);\n\t\t\t\t}\n\t\t\t\t// return callback.call(this, obj.id === $.jstree.root ? this._append_html_data(obj, this._data.core.original_container_html.clone(true)) : false);\n\t\t\t}\n\t\t\tif ($.isFunction(s)) {\n\t\t\t\treturn s.call(this, obj, $.proxy(function (d) {\n\t\t\t\t\tif (d === false) {\n\t\t\t\t\t\tcallback.call(this, false);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis[typeof d === 'string' ? '_append_html_data' : '_append_json_data'](obj, typeof d === 'string' ? $($.parseHTML(d)).filter(notTextOrCommentNode) : d, function (status) {\n\t\t\t\t\t\t\tcallback.call(this, status);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\t// return d === false ? callback.call(this, false) : callback.call(this, this[typeof d === 'string' ? '_append_html_data' : '_append_json_data'](obj, typeof d === 'string' ? $(d) : d));\n\t\t\t\t}, this));\n\t\t\t}\n\t\t\tif ((typeof s === 'undefined' ? 'undefined' : _typeof(s)) === 'object') {\n\t\t\t\tif (s.url) {\n\t\t\t\t\ts = $.extend(true, {}, s);\n\t\t\t\t\tif ($.isFunction(s.url)) {\n\t\t\t\t\t\ts.url = s.url.call(this, obj);\n\t\t\t\t\t}\n\t\t\t\t\tif ($.isFunction(s.data)) {\n\t\t\t\t\t\ts.data = s.data.call(this, obj);\n\t\t\t\t\t}\n\t\t\t\t\treturn $.ajax(s).done($.proxy(function (d, t, x) {\n\t\t\t\t\t\tvar type = x.getResponseHeader('Content-Type');\n\t\t\t\t\t\tif (type && type.indexOf('json') !== -1 || (typeof d === 'undefined' ? 'undefined' : _typeof(d)) === \"object\") {\n\t\t\t\t\t\t\treturn this._append_json_data(obj, d, function (status) {\n\t\t\t\t\t\t\t\tcallback.call(this, status);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t//return callback.call(this, this._append_json_data(obj, d));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (type && type.indexOf('html') !== -1 || typeof d === \"string\") {\n\t\t\t\t\t\t\treturn this._append_html_data(obj, $($.parseHTML(d)).filter(notTextOrCommentNode), function (status) {\n\t\t\t\t\t\t\t\tcallback.call(this, status);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t// return callback.call(this, this._append_html_data(obj, $(d)));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis._data.core.last_error = { 'error': 'ajax', 'plugin': 'core', 'id': 'core_04', 'reason': 'Could not load node', 'data': JSON.stringify({ 'id': obj.id, 'xhr': x }) };\n\t\t\t\t\t\tthis.settings.core.error.call(this, this._data.core.last_error);\n\t\t\t\t\t\treturn callback.call(this, false);\n\t\t\t\t\t}, this)).fail($.proxy(function (f) {\n\t\t\t\t\t\tcallback.call(this, false);\n\t\t\t\t\t\tthis._data.core.last_error = { 'error': 'ajax', 'plugin': 'core', 'id': 'core_04', 'reason': 'Could not load node', 'data': JSON.stringify({ 'id': obj.id, 'xhr': f }) };\n\t\t\t\t\t\tthis.settings.core.error.call(this, this._data.core.last_error);\n\t\t\t\t\t}, this));\n\t\t\t\t}\n\t\t\t\tt = $.isArray(s) || $.isPlainObject(s) ? JSON.parse(JSON.stringify(s)) : s;\n\t\t\t\tif (obj.id === $.jstree.root) {\n\t\t\t\t\treturn this._append_json_data(obj, t, function (status) {\n\t\t\t\t\t\tcallback.call(this, status);\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tthis._data.core.last_error = { 'error': 'nodata', 'plugin': 'core', 'id': 'core_05', 'reason': 'Could not load node', 'data': JSON.stringify({ 'id': obj.id }) };\n\t\t\t\t\tthis.settings.core.error.call(this, this._data.core.last_error);\n\t\t\t\t\treturn callback.call(this, false);\n\t\t\t\t}\n\t\t\t\t//return callback.call(this, (obj.id === $.jstree.root ? this._append_json_data(obj, t) : false) );\n\t\t\t}\n\t\t\tif (typeof s === 'string') {\n\t\t\t\tif (obj.id === $.jstree.root) {\n\t\t\t\t\treturn this._append_html_data(obj, $($.parseHTML(s)).filter(notTextOrCommentNode), function (status) {\n\t\t\t\t\t\tcallback.call(this, status);\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tthis._data.core.last_error = { 'error': 'nodata', 'plugin': 'core', 'id': 'core_06', 'reason': 'Could not load node', 'data': JSON.stringify({ 'id': obj.id }) };\n\t\t\t\t\tthis.settings.core.error.call(this, this._data.core.last_error);\n\t\t\t\t\treturn callback.call(this, false);\n\t\t\t\t}\n\t\t\t\t//return callback.call(this, (obj.id === $.jstree.root ? this._append_html_data(obj, $(s)) : false) );\n\t\t\t}\n\t\t\treturn callback.call(this, false);\n\t\t},\n\t\t/**\n   * adds a node to the list of nodes to redraw. Used only internally.\n   * @private\n   * @name _node_changed(obj [, callback])\n   * @param  {mixed} obj\n   */\n\t\t_node_changed: function _node_changed(obj) {\n\t\t\tobj = this.get_node(obj);\n\t\t\tif (obj) {\n\t\t\t\tthis._model.changed.push(obj.id);\n\t\t\t}\n\t\t},\n\t\t/**\n   * appends HTML content to the tree. Used internally.\n   * @private\n   * @name _append_html_data(obj, data)\n   * @param  {mixed} obj the node to append to\n   * @param  {String} data the HTML string to parse and append\n   * @trigger model.jstree, changed.jstree\n   */\n\t\t_append_html_data: function _append_html_data(dom, data, cb) {\n\t\t\tdom = this.get_node(dom);\n\t\t\tdom.children = [];\n\t\t\tdom.children_d = [];\n\t\t\tvar dat = data.is('ul') ? data.children() : data,\n\t\t\t    par = dom.id,\n\t\t\t    chd = [],\n\t\t\t    dpc = [],\n\t\t\t    m = this._model.data,\n\t\t\t    p = m[par],\n\t\t\t    s = this._data.core.selected.length,\n\t\t\t    tmp,\n\t\t\t    i,\n\t\t\t    j;\n\t\t\tdat.each($.proxy(function (i, v) {\n\t\t\t\ttmp = this._parse_model_from_html($(v), par, p.parents.concat());\n\t\t\t\tif (tmp) {\n\t\t\t\t\tchd.push(tmp);\n\t\t\t\t\tdpc.push(tmp);\n\t\t\t\t\tif (m[tmp].children_d.length) {\n\t\t\t\t\t\tdpc = dpc.concat(m[tmp].children_d);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, this));\n\t\t\tp.children = chd;\n\t\t\tp.children_d = dpc;\n\t\t\tfor (i = 0, j = p.parents.length; i < j; i++) {\n\t\t\t\tm[p.parents[i]].children_d = m[p.parents[i]].children_d.concat(dpc);\n\t\t\t}\n\t\t\t/**\n    * triggered when new data is inserted to the tree model\n    * @event\n    * @name model.jstree\n    * @param {Array} nodes an array of node IDs\n    * @param {String} parent the parent ID of the nodes\n    */\n\t\t\tthis.trigger('model', { \"nodes\": dpc, 'parent': par });\n\t\t\tif (par !== $.jstree.root) {\n\t\t\t\tthis._node_changed(par);\n\t\t\t\tthis.redraw();\n\t\t\t} else {\n\t\t\t\tthis.get_container_ul().children('.jstree-initial-node').remove();\n\t\t\t\tthis.redraw(true);\n\t\t\t}\n\t\t\tif (this._data.core.selected.length !== s) {\n\t\t\t\tthis.trigger('changed', { 'action': 'model', 'selected': this._data.core.selected });\n\t\t\t}\n\t\t\tcb.call(this, true);\n\t\t},\n\t\t/**\n   * appends JSON content to the tree. Used internally.\n   * @private\n   * @name _append_json_data(obj, data)\n   * @param  {mixed} obj the node to append to\n   * @param  {String} data the JSON object to parse and append\n   * @param  {Boolean} force_processing internal param - do not set\n   * @trigger model.jstree, changed.jstree\n   */\n\t\t_append_json_data: function _append_json_data(dom, data, cb, force_processing) {\n\t\t\tif (this.element === null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tdom = this.get_node(dom);\n\t\t\tdom.children = [];\n\t\t\tdom.children_d = [];\n\t\t\t// *%$@!!!\n\t\t\tif (data.d) {\n\t\t\t\tdata = data.d;\n\t\t\t\tif (typeof data === \"string\") {\n\t\t\t\t\tdata = JSON.parse(data);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!$.isArray(data)) {\n\t\t\t\tdata = [data];\n\t\t\t}\n\t\t\tvar w = null,\n\t\t\t    args = {\n\t\t\t\t'df': this._model.default_state,\n\t\t\t\t'dat': data,\n\t\t\t\t'par': dom.id,\n\t\t\t\t'm': this._model.data,\n\t\t\t\t't_id': this._id,\n\t\t\t\t't_cnt': this._cnt,\n\t\t\t\t'sel': this._data.core.selected\n\t\t\t},\n\t\t\t    func = function func(data, undefined) {\n\t\t\t\tif (data.data) {\n\t\t\t\t\tdata = data.data;\n\t\t\t\t}\n\t\t\t\tvar dat = data.dat,\n\t\t\t\t    par = data.par,\n\t\t\t\t    chd = [],\n\t\t\t\t    dpc = [],\n\t\t\t\t    add = [],\n\t\t\t\t    df = data.df,\n\t\t\t\t    t_id = data.t_id,\n\t\t\t\t    t_cnt = data.t_cnt,\n\t\t\t\t    m = data.m,\n\t\t\t\t    p = m[par],\n\t\t\t\t    sel = data.sel,\n\t\t\t\t    tmp,\n\t\t\t\t    i,\n\t\t\t\t    j,\n\t\t\t\t    rslt,\n\t\t\t\t    parse_flat = function parse_flat(d, p, ps) {\n\t\t\t\t\tif (!ps) {\n\t\t\t\t\t\tps = [];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tps = ps.concat();\n\t\t\t\t\t}\n\t\t\t\t\tif (p) {\n\t\t\t\t\t\tps.unshift(p);\n\t\t\t\t\t}\n\t\t\t\t\tvar tid = d.id.toString(),\n\t\t\t\t\t    i,\n\t\t\t\t\t    j,\n\t\t\t\t\t    c,\n\t\t\t\t\t    e,\n\t\t\t\t\t    tmp = {\n\t\t\t\t\t\tid: tid,\n\t\t\t\t\t\ttext: d.text || '',\n\t\t\t\t\t\ticon: d.icon !== undefined ? d.icon : true,\n\t\t\t\t\t\tparent: p,\n\t\t\t\t\t\tparents: ps,\n\t\t\t\t\t\tchildren: d.children || [],\n\t\t\t\t\t\tchildren_d: d.children_d || [],\n\t\t\t\t\t\tdata: d.data,\n\t\t\t\t\t\tstate: {},\n\t\t\t\t\t\tli_attr: { id: false },\n\t\t\t\t\t\ta_attr: { href: '#' },\n\t\t\t\t\t\toriginal: false\n\t\t\t\t\t};\n\t\t\t\t\tfor (i in df) {\n\t\t\t\t\t\tif (df.hasOwnProperty(i)) {\n\t\t\t\t\t\t\ttmp.state[i] = df[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (d && d.data && d.data.jstree && d.data.jstree.icon) {\n\t\t\t\t\t\ttmp.icon = d.data.jstree.icon;\n\t\t\t\t\t}\n\t\t\t\t\tif (tmp.icon === undefined || tmp.icon === null || tmp.icon === \"\") {\n\t\t\t\t\t\ttmp.icon = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (d && d.data) {\n\t\t\t\t\t\ttmp.data = d.data;\n\t\t\t\t\t\tif (d.data.jstree) {\n\t\t\t\t\t\t\tfor (i in d.data.jstree) {\n\t\t\t\t\t\t\t\tif (d.data.jstree.hasOwnProperty(i)) {\n\t\t\t\t\t\t\t\t\ttmp.state[i] = d.data.jstree[i];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (d && _typeof(d.state) === 'object') {\n\t\t\t\t\t\tfor (i in d.state) {\n\t\t\t\t\t\t\tif (d.state.hasOwnProperty(i)) {\n\t\t\t\t\t\t\t\ttmp.state[i] = d.state[i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (d && _typeof(d.li_attr) === 'object') {\n\t\t\t\t\t\tfor (i in d.li_attr) {\n\t\t\t\t\t\t\tif (d.li_attr.hasOwnProperty(i)) {\n\t\t\t\t\t\t\t\ttmp.li_attr[i] = d.li_attr[i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!tmp.li_attr.id) {\n\t\t\t\t\t\ttmp.li_attr.id = tid;\n\t\t\t\t\t}\n\t\t\t\t\tif (d && _typeof(d.a_attr) === 'object') {\n\t\t\t\t\t\tfor (i in d.a_attr) {\n\t\t\t\t\t\t\tif (d.a_attr.hasOwnProperty(i)) {\n\t\t\t\t\t\t\t\ttmp.a_attr[i] = d.a_attr[i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (d && d.children && d.children === true) {\n\t\t\t\t\t\ttmp.state.loaded = false;\n\t\t\t\t\t\ttmp.children = [];\n\t\t\t\t\t\ttmp.children_d = [];\n\t\t\t\t\t}\n\t\t\t\t\tm[tmp.id] = tmp;\n\t\t\t\t\tfor (i = 0, j = tmp.children.length; i < j; i++) {\n\t\t\t\t\t\tc = parse_flat(m[tmp.children[i]], tmp.id, ps);\n\t\t\t\t\t\te = m[c];\n\t\t\t\t\t\ttmp.children_d.push(c);\n\t\t\t\t\t\tif (e.children_d.length) {\n\t\t\t\t\t\t\ttmp.children_d = tmp.children_d.concat(e.children_d);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdelete d.data;\n\t\t\t\t\tdelete d.children;\n\t\t\t\t\tm[tmp.id].original = d;\n\t\t\t\t\tif (tmp.state.selected) {\n\t\t\t\t\t\tadd.push(tmp.id);\n\t\t\t\t\t}\n\t\t\t\t\treturn tmp.id;\n\t\t\t\t},\n\t\t\t\t    parse_nest = function parse_nest(d, p, ps) {\n\t\t\t\t\tif (!ps) {\n\t\t\t\t\t\tps = [];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tps = ps.concat();\n\t\t\t\t\t}\n\t\t\t\t\tif (p) {\n\t\t\t\t\t\tps.unshift(p);\n\t\t\t\t\t}\n\t\t\t\t\tvar tid = false,\n\t\t\t\t\t    i,\n\t\t\t\t\t    j,\n\t\t\t\t\t    c,\n\t\t\t\t\t    e,\n\t\t\t\t\t    tmp;\n\t\t\t\t\tdo {\n\t\t\t\t\t\ttid = 'j' + t_id + '_' + ++t_cnt;\n\t\t\t\t\t} while (m[tid]);\n\n\t\t\t\t\ttmp = {\n\t\t\t\t\t\tid: false,\n\t\t\t\t\t\ttext: typeof d === 'string' ? d : '',\n\t\t\t\t\t\ticon: (typeof d === 'undefined' ? 'undefined' : _typeof(d)) === 'object' && d.icon !== undefined ? d.icon : true,\n\t\t\t\t\t\tparent: p,\n\t\t\t\t\t\tparents: ps,\n\t\t\t\t\t\tchildren: [],\n\t\t\t\t\t\tchildren_d: [],\n\t\t\t\t\t\tdata: null,\n\t\t\t\t\t\tstate: {},\n\t\t\t\t\t\tli_attr: { id: false },\n\t\t\t\t\t\ta_attr: { href: '#' },\n\t\t\t\t\t\toriginal: false\n\t\t\t\t\t};\n\t\t\t\t\tfor (i in df) {\n\t\t\t\t\t\tif (df.hasOwnProperty(i)) {\n\t\t\t\t\t\t\ttmp.state[i] = df[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (d && d.id) {\n\t\t\t\t\t\ttmp.id = d.id.toString();\n\t\t\t\t\t}\n\t\t\t\t\tif (d && d.text) {\n\t\t\t\t\t\ttmp.text = d.text;\n\t\t\t\t\t}\n\t\t\t\t\tif (d && d.data && d.data.jstree && d.data.jstree.icon) {\n\t\t\t\t\t\ttmp.icon = d.data.jstree.icon;\n\t\t\t\t\t}\n\t\t\t\t\tif (tmp.icon === undefined || tmp.icon === null || tmp.icon === \"\") {\n\t\t\t\t\t\ttmp.icon = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (d && d.data) {\n\t\t\t\t\t\ttmp.data = d.data;\n\t\t\t\t\t\tif (d.data.jstree) {\n\t\t\t\t\t\t\tfor (i in d.data.jstree) {\n\t\t\t\t\t\t\t\tif (d.data.jstree.hasOwnProperty(i)) {\n\t\t\t\t\t\t\t\t\ttmp.state[i] = d.data.jstree[i];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (d && _typeof(d.state) === 'object') {\n\t\t\t\t\t\tfor (i in d.state) {\n\t\t\t\t\t\t\tif (d.state.hasOwnProperty(i)) {\n\t\t\t\t\t\t\t\ttmp.state[i] = d.state[i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (d && _typeof(d.li_attr) === 'object') {\n\t\t\t\t\t\tfor (i in d.li_attr) {\n\t\t\t\t\t\t\tif (d.li_attr.hasOwnProperty(i)) {\n\t\t\t\t\t\t\t\ttmp.li_attr[i] = d.li_attr[i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (tmp.li_attr.id && !tmp.id) {\n\t\t\t\t\t\ttmp.id = tmp.li_attr.id.toString();\n\t\t\t\t\t}\n\t\t\t\t\tif (!tmp.id) {\n\t\t\t\t\t\ttmp.id = tid;\n\t\t\t\t\t}\n\t\t\t\t\tif (!tmp.li_attr.id) {\n\t\t\t\t\t\ttmp.li_attr.id = tmp.id;\n\t\t\t\t\t}\n\t\t\t\t\tif (d && _typeof(d.a_attr) === 'object') {\n\t\t\t\t\t\tfor (i in d.a_attr) {\n\t\t\t\t\t\t\tif (d.a_attr.hasOwnProperty(i)) {\n\t\t\t\t\t\t\t\ttmp.a_attr[i] = d.a_attr[i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (d && d.children && d.children.length) {\n\t\t\t\t\t\tfor (i = 0, j = d.children.length; i < j; i++) {\n\t\t\t\t\t\t\tc = parse_nest(d.children[i], tmp.id, ps);\n\t\t\t\t\t\t\te = m[c];\n\t\t\t\t\t\t\ttmp.children.push(c);\n\t\t\t\t\t\t\tif (e.children_d.length) {\n\t\t\t\t\t\t\t\ttmp.children_d = tmp.children_d.concat(e.children_d);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmp.children_d = tmp.children_d.concat(tmp.children);\n\t\t\t\t\t}\n\t\t\t\t\tif (d && d.children && d.children === true) {\n\t\t\t\t\t\ttmp.state.loaded = false;\n\t\t\t\t\t\ttmp.children = [];\n\t\t\t\t\t\ttmp.children_d = [];\n\t\t\t\t\t}\n\t\t\t\t\tdelete d.data;\n\t\t\t\t\tdelete d.children;\n\t\t\t\t\ttmp.original = d;\n\t\t\t\t\tm[tmp.id] = tmp;\n\t\t\t\t\tif (tmp.state.selected) {\n\t\t\t\t\t\tadd.push(tmp.id);\n\t\t\t\t\t}\n\t\t\t\t\treturn tmp.id;\n\t\t\t\t};\n\n\t\t\t\tif (dat.length && dat[0].id !== undefined && dat[0].parent !== undefined) {\n\t\t\t\t\t// Flat JSON support (for easy import from DB):\n\t\t\t\t\t// 1) convert to object (foreach)\n\t\t\t\t\tfor (i = 0, j = dat.length; i < j; i++) {\n\t\t\t\t\t\tif (!dat[i].children) {\n\t\t\t\t\t\t\tdat[i].children = [];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tm[dat[i].id.toString()] = dat[i];\n\t\t\t\t\t}\n\t\t\t\t\t// 2) populate children (foreach)\n\t\t\t\t\tfor (i = 0, j = dat.length; i < j; i++) {\n\t\t\t\t\t\tm[dat[i].parent.toString()].children.push(dat[i].id.toString());\n\t\t\t\t\t\t// populate parent.children_d\n\t\t\t\t\t\tp.children_d.push(dat[i].id.toString());\n\t\t\t\t\t}\n\t\t\t\t\t// 3) normalize && populate parents and children_d with recursion\n\t\t\t\t\tfor (i = 0, j = p.children.length; i < j; i++) {\n\t\t\t\t\t\ttmp = parse_flat(m[p.children[i]], par, p.parents.concat());\n\t\t\t\t\t\tdpc.push(tmp);\n\t\t\t\t\t\tif (m[tmp].children_d.length) {\n\t\t\t\t\t\t\tdpc = dpc.concat(m[tmp].children_d);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (i = 0, j = p.parents.length; i < j; i++) {\n\t\t\t\t\t\tm[p.parents[i]].children_d = m[p.parents[i]].children_d.concat(dpc);\n\t\t\t\t\t}\n\t\t\t\t\t// ?) three_state selection - p.state.selected && t - (if three_state foreach(dat => ch) -> foreach(parents) if(parent.selected) child.selected = true;\n\t\t\t\t\trslt = {\n\t\t\t\t\t\t'cnt': t_cnt,\n\t\t\t\t\t\t'mod': m,\n\t\t\t\t\t\t'sel': sel,\n\t\t\t\t\t\t'par': par,\n\t\t\t\t\t\t'dpc': dpc,\n\t\t\t\t\t\t'add': add\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\tfor (i = 0, j = dat.length; i < j; i++) {\n\t\t\t\t\t\ttmp = parse_nest(dat[i], par, p.parents.concat());\n\t\t\t\t\t\tif (tmp) {\n\t\t\t\t\t\t\tchd.push(tmp);\n\t\t\t\t\t\t\tdpc.push(tmp);\n\t\t\t\t\t\t\tif (m[tmp].children_d.length) {\n\t\t\t\t\t\t\t\tdpc = dpc.concat(m[tmp].children_d);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tp.children = chd;\n\t\t\t\t\tp.children_d = dpc;\n\t\t\t\t\tfor (i = 0, j = p.parents.length; i < j; i++) {\n\t\t\t\t\t\tm[p.parents[i]].children_d = m[p.parents[i]].children_d.concat(dpc);\n\t\t\t\t\t}\n\t\t\t\t\trslt = {\n\t\t\t\t\t\t'cnt': t_cnt,\n\t\t\t\t\t\t'mod': m,\n\t\t\t\t\t\t'sel': sel,\n\t\t\t\t\t\t'par': par,\n\t\t\t\t\t\t'dpc': dpc,\n\t\t\t\t\t\t'add': add\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif (typeof window === 'undefined' || typeof window.document === 'undefined') {\n\t\t\t\t\tpostMessage(rslt);\n\t\t\t\t} else {\n\t\t\t\t\treturn rslt;\n\t\t\t\t}\n\t\t\t},\n\t\t\t    rslt = function rslt(_rslt, worker) {\n\t\t\t\tif (this.element === null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis._cnt = _rslt.cnt;\n\t\t\t\tvar i,\n\t\t\t\t    m = this._model.data;\n\t\t\t\tfor (i in m) {\n\t\t\t\t\tif (m.hasOwnProperty(i) && m[i].state && m[i].state.loading && _rslt.mod[i]) {\n\t\t\t\t\t\t_rslt.mod[i].state.loading = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis._model.data = _rslt.mod; // breaks the reference in load_node - careful\n\n\t\t\t\tif (worker) {\n\t\t\t\t\tvar j,\n\t\t\t\t\t    a = _rslt.add,\n\t\t\t\t\t    r = _rslt.sel,\n\t\t\t\t\t    s = this._data.core.selected.slice();\n\t\t\t\t\tm = this._model.data;\n\t\t\t\t\t// if selection was changed while calculating in worker\n\t\t\t\t\tif (r.length !== s.length || $.vakata.array_unique(r.concat(s)).length !== r.length) {\n\t\t\t\t\t\t// deselect nodes that are no longer selected\n\t\t\t\t\t\tfor (i = 0, j = r.length; i < j; i++) {\n\t\t\t\t\t\t\tif ($.inArray(r[i], a) === -1 && $.inArray(r[i], s) === -1) {\n\t\t\t\t\t\t\t\tm[r[i]].state.selected = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// select nodes that were selected in the mean time\n\t\t\t\t\t\tfor (i = 0, j = s.length; i < j; i++) {\n\t\t\t\t\t\t\tif ($.inArray(s[i], r) === -1) {\n\t\t\t\t\t\t\t\tm[s[i]].state.selected = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (_rslt.add.length) {\n\t\t\t\t\tthis._data.core.selected = this._data.core.selected.concat(_rslt.add);\n\t\t\t\t}\n\n\t\t\t\tthis.trigger('model', { \"nodes\": _rslt.dpc, 'parent': _rslt.par });\n\n\t\t\t\tif (_rslt.par !== $.jstree.root) {\n\t\t\t\t\tthis._node_changed(_rslt.par);\n\t\t\t\t\tthis.redraw();\n\t\t\t\t} else {\n\t\t\t\t\t// this.get_container_ul().children('.jstree-initial-node').remove();\n\t\t\t\t\tthis.redraw(true);\n\t\t\t\t}\n\t\t\t\tif (_rslt.add.length) {\n\t\t\t\t\tthis.trigger('changed', { 'action': 'model', 'selected': this._data.core.selected });\n\t\t\t\t}\n\t\t\t\tcb.call(this, true);\n\t\t\t};\n\t\t\tif (this.settings.core.worker && window.Blob && window.URL && window.Worker) {\n\t\t\t\ttry {\n\t\t\t\t\tif (this._wrk === null) {\n\t\t\t\t\t\tthis._wrk = window.URL.createObjectURL(new window.Blob(['self.onmessage = ' + func.toString()], { type: \"text/javascript\" }));\n\t\t\t\t\t}\n\t\t\t\t\tif (!this._data.core.working || force_processing) {\n\t\t\t\t\t\tthis._data.core.working = true;\n\t\t\t\t\t\tw = new window.Worker(this._wrk);\n\t\t\t\t\t\tw.onmessage = $.proxy(function (e) {\n\t\t\t\t\t\t\trslt.call(this, e.data, true);\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tw.terminate();w = null;\n\t\t\t\t\t\t\t} catch (ignore) {}\n\t\t\t\t\t\t\tif (this._data.core.worker_queue.length) {\n\t\t\t\t\t\t\t\tthis._append_json_data.apply(this, this._data.core.worker_queue.shift());\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis._data.core.working = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, this);\n\t\t\t\t\t\tif (!args.par) {\n\t\t\t\t\t\t\tif (this._data.core.worker_queue.length) {\n\t\t\t\t\t\t\t\tthis._append_json_data.apply(this, this._data.core.worker_queue.shift());\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis._data.core.working = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tw.postMessage(args);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._data.core.worker_queue.push([dom, data, cb, true]);\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\trslt.call(this, func(args), false);\n\t\t\t\t\tif (this._data.core.worker_queue.length) {\n\t\t\t\t\t\tthis._append_json_data.apply(this, this._data.core.worker_queue.shift());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._data.core.working = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trslt.call(this, func(args), false);\n\t\t\t}\n\t\t},\n\t\t/**\n   * parses a node from a jQuery object and appends them to the in memory tree model. Used internally.\n   * @private\n   * @name _parse_model_from_html(d [, p, ps])\n   * @param  {jQuery} d the jQuery object to parse\n   * @param  {String} p the parent ID\n   * @param  {Array} ps list of all parents\n   * @return {String} the ID of the object added to the model\n   */\n\t\t_parse_model_from_html: function _parse_model_from_html(d, p, ps) {\n\t\t\tif (!ps) {\n\t\t\t\tps = [];\n\t\t\t} else {\n\t\t\t\tps = [].concat(ps);\n\t\t\t}\n\t\t\tif (p) {\n\t\t\t\tps.unshift(p);\n\t\t\t}\n\t\t\tvar c,\n\t\t\t    e,\n\t\t\t    m = this._model.data,\n\t\t\t    data = {\n\t\t\t\tid: false,\n\t\t\t\ttext: false,\n\t\t\t\ticon: true,\n\t\t\t\tparent: p,\n\t\t\t\tparents: ps,\n\t\t\t\tchildren: [],\n\t\t\t\tchildren_d: [],\n\t\t\t\tdata: null,\n\t\t\t\tstate: {},\n\t\t\t\tli_attr: { id: false },\n\t\t\t\ta_attr: { href: '#' },\n\t\t\t\toriginal: false\n\t\t\t},\n\t\t\t    i,\n\t\t\t    tmp,\n\t\t\t    tid;\n\t\t\tfor (i in this._model.default_state) {\n\t\t\t\tif (this._model.default_state.hasOwnProperty(i)) {\n\t\t\t\t\tdata.state[i] = this._model.default_state[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\ttmp = $.vakata.attributes(d, true);\n\t\t\t$.each(tmp, function (i, v) {\n\t\t\t\tv = $.trim(v);\n\t\t\t\tif (!v.length) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tdata.li_attr[i] = v;\n\t\t\t\tif (i === 'id') {\n\t\t\t\t\tdata.id = v.toString();\n\t\t\t\t}\n\t\t\t});\n\t\t\ttmp = d.children('a').first();\n\t\t\tif (tmp.length) {\n\t\t\t\ttmp = $.vakata.attributes(tmp, true);\n\t\t\t\t$.each(tmp, function (i, v) {\n\t\t\t\t\tv = $.trim(v);\n\t\t\t\t\tif (v.length) {\n\t\t\t\t\t\tdata.a_attr[i] = v;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\ttmp = d.children(\"a\").first().length ? d.children(\"a\").first().clone() : d.clone();\n\t\t\ttmp.children(\"ins, i, ul\").remove();\n\t\t\ttmp = tmp.html();\n\t\t\ttmp = $('<div />').html(tmp);\n\t\t\tdata.text = this.settings.core.force_text ? tmp.text() : tmp.html();\n\t\t\ttmp = d.data();\n\t\t\tdata.data = tmp ? $.extend(true, {}, tmp) : null;\n\t\t\tdata.state.opened = d.hasClass('jstree-open');\n\t\t\tdata.state.selected = d.children('a').hasClass('jstree-clicked');\n\t\t\tdata.state.disabled = d.children('a').hasClass('jstree-disabled');\n\t\t\tif (data.data && data.data.jstree) {\n\t\t\t\tfor (i in data.data.jstree) {\n\t\t\t\t\tif (data.data.jstree.hasOwnProperty(i)) {\n\t\t\t\t\t\tdata.state[i] = data.data.jstree[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ttmp = d.children(\"a\").children(\".jstree-themeicon\");\n\t\t\tif (tmp.length) {\n\t\t\t\tdata.icon = tmp.hasClass('jstree-themeicon-hidden') ? false : tmp.attr('rel');\n\t\t\t}\n\t\t\tif (data.state.icon !== undefined) {\n\t\t\t\tdata.icon = data.state.icon;\n\t\t\t}\n\t\t\tif (data.icon === undefined || data.icon === null || data.icon === \"\") {\n\t\t\t\tdata.icon = true;\n\t\t\t}\n\t\t\ttmp = d.children(\"ul\").children(\"li\");\n\t\t\tdo {\n\t\t\t\ttid = 'j' + this._id + '_' + ++this._cnt;\n\t\t\t} while (m[tid]);\n\t\t\tdata.id = data.li_attr.id ? data.li_attr.id.toString() : tid;\n\t\t\tif (tmp.length) {\n\t\t\t\ttmp.each($.proxy(function (i, v) {\n\t\t\t\t\tc = this._parse_model_from_html($(v), data.id, ps);\n\t\t\t\t\te = this._model.data[c];\n\t\t\t\t\tdata.children.push(c);\n\t\t\t\t\tif (e.children_d.length) {\n\t\t\t\t\t\tdata.children_d = data.children_d.concat(e.children_d);\n\t\t\t\t\t}\n\t\t\t\t}, this));\n\t\t\t\tdata.children_d = data.children_d.concat(data.children);\n\t\t\t} else {\n\t\t\t\tif (d.hasClass('jstree-closed')) {\n\t\t\t\t\tdata.state.loaded = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (data.li_attr['class']) {\n\t\t\t\tdata.li_attr['class'] = data.li_attr['class'].replace('jstree-closed', '').replace('jstree-open', '');\n\t\t\t}\n\t\t\tif (data.a_attr['class']) {\n\t\t\t\tdata.a_attr['class'] = data.a_attr['class'].replace('jstree-clicked', '').replace('jstree-disabled', '');\n\t\t\t}\n\t\t\tm[data.id] = data;\n\t\t\tif (data.state.selected) {\n\t\t\t\tthis._data.core.selected.push(data.id);\n\t\t\t}\n\t\t\treturn data.id;\n\t\t},\n\t\t/**\n   * parses a node from a JSON object (used when dealing with flat data, which has no nesting of children, but has id and parent properties) and appends it to the in memory tree model. Used internally.\n   * @private\n   * @name _parse_model_from_flat_json(d [, p, ps])\n   * @param  {Object} d the JSON object to parse\n   * @param  {String} p the parent ID\n   * @param  {Array} ps list of all parents\n   * @return {String} the ID of the object added to the model\n   */\n\t\t_parse_model_from_flat_json: function _parse_model_from_flat_json(d, p, ps) {\n\t\t\tif (!ps) {\n\t\t\t\tps = [];\n\t\t\t} else {\n\t\t\t\tps = ps.concat();\n\t\t\t}\n\t\t\tif (p) {\n\t\t\t\tps.unshift(p);\n\t\t\t}\n\t\t\tvar tid = d.id.toString(),\n\t\t\t    m = this._model.data,\n\t\t\t    df = this._model.default_state,\n\t\t\t    i,\n\t\t\t    j,\n\t\t\t    c,\n\t\t\t    e,\n\t\t\t    tmp = {\n\t\t\t\tid: tid,\n\t\t\t\ttext: d.text || '',\n\t\t\t\ticon: d.icon !== undefined ? d.icon : true,\n\t\t\t\tparent: p,\n\t\t\t\tparents: ps,\n\t\t\t\tchildren: d.children || [],\n\t\t\t\tchildren_d: d.children_d || [],\n\t\t\t\tdata: d.data,\n\t\t\t\tstate: {},\n\t\t\t\tli_attr: { id: false },\n\t\t\t\ta_attr: { href: '#' },\n\t\t\t\toriginal: false\n\t\t\t};\n\t\t\tfor (i in df) {\n\t\t\t\tif (df.hasOwnProperty(i)) {\n\t\t\t\t\ttmp.state[i] = df[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (d && d.data && d.data.jstree && d.data.jstree.icon) {\n\t\t\t\ttmp.icon = d.data.jstree.icon;\n\t\t\t}\n\t\t\tif (tmp.icon === undefined || tmp.icon === null || tmp.icon === \"\") {\n\t\t\t\ttmp.icon = true;\n\t\t\t}\n\t\t\tif (d && d.data) {\n\t\t\t\ttmp.data = d.data;\n\t\t\t\tif (d.data.jstree) {\n\t\t\t\t\tfor (i in d.data.jstree) {\n\t\t\t\t\t\tif (d.data.jstree.hasOwnProperty(i)) {\n\t\t\t\t\t\t\ttmp.state[i] = d.data.jstree[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (d && _typeof(d.state) === 'object') {\n\t\t\t\tfor (i in d.state) {\n\t\t\t\t\tif (d.state.hasOwnProperty(i)) {\n\t\t\t\t\t\ttmp.state[i] = d.state[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (d && _typeof(d.li_attr) === 'object') {\n\t\t\t\tfor (i in d.li_attr) {\n\t\t\t\t\tif (d.li_attr.hasOwnProperty(i)) {\n\t\t\t\t\t\ttmp.li_attr[i] = d.li_attr[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!tmp.li_attr.id) {\n\t\t\t\ttmp.li_attr.id = tid;\n\t\t\t}\n\t\t\tif (d && _typeof(d.a_attr) === 'object') {\n\t\t\t\tfor (i in d.a_attr) {\n\t\t\t\t\tif (d.a_attr.hasOwnProperty(i)) {\n\t\t\t\t\t\ttmp.a_attr[i] = d.a_attr[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (d && d.children && d.children === true) {\n\t\t\t\ttmp.state.loaded = false;\n\t\t\t\ttmp.children = [];\n\t\t\t\ttmp.children_d = [];\n\t\t\t}\n\t\t\tm[tmp.id] = tmp;\n\t\t\tfor (i = 0, j = tmp.children.length; i < j; i++) {\n\t\t\t\tc = this._parse_model_from_flat_json(m[tmp.children[i]], tmp.id, ps);\n\t\t\t\te = m[c];\n\t\t\t\ttmp.children_d.push(c);\n\t\t\t\tif (e.children_d.length) {\n\t\t\t\t\ttmp.children_d = tmp.children_d.concat(e.children_d);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdelete d.data;\n\t\t\tdelete d.children;\n\t\t\tm[tmp.id].original = d;\n\t\t\tif (tmp.state.selected) {\n\t\t\t\tthis._data.core.selected.push(tmp.id);\n\t\t\t}\n\t\t\treturn tmp.id;\n\t\t},\n\t\t/**\n   * parses a node from a JSON object and appends it to the in memory tree model. Used internally.\n   * @private\n   * @name _parse_model_from_json(d [, p, ps])\n   * @param  {Object} d the JSON object to parse\n   * @param  {String} p the parent ID\n   * @param  {Array} ps list of all parents\n   * @return {String} the ID of the object added to the model\n   */\n\t\t_parse_model_from_json: function _parse_model_from_json(d, p, ps) {\n\t\t\tif (!ps) {\n\t\t\t\tps = [];\n\t\t\t} else {\n\t\t\t\tps = ps.concat();\n\t\t\t}\n\t\t\tif (p) {\n\t\t\t\tps.unshift(p);\n\t\t\t}\n\t\t\tvar tid = false,\n\t\t\t    i,\n\t\t\t    j,\n\t\t\t    c,\n\t\t\t    e,\n\t\t\t    m = this._model.data,\n\t\t\t    df = this._model.default_state,\n\t\t\t    tmp;\n\t\t\tdo {\n\t\t\t\ttid = 'j' + this._id + '_' + ++this._cnt;\n\t\t\t} while (m[tid]);\n\n\t\t\ttmp = {\n\t\t\t\tid: false,\n\t\t\t\ttext: typeof d === 'string' ? d : '',\n\t\t\t\ticon: (typeof d === 'undefined' ? 'undefined' : _typeof(d)) === 'object' && d.icon !== undefined ? d.icon : true,\n\t\t\t\tparent: p,\n\t\t\t\tparents: ps,\n\t\t\t\tchildren: [],\n\t\t\t\tchildren_d: [],\n\t\t\t\tdata: null,\n\t\t\t\tstate: {},\n\t\t\t\tli_attr: { id: false },\n\t\t\t\ta_attr: { href: '#' },\n\t\t\t\toriginal: false\n\t\t\t};\n\t\t\tfor (i in df) {\n\t\t\t\tif (df.hasOwnProperty(i)) {\n\t\t\t\t\ttmp.state[i] = df[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (d && d.id) {\n\t\t\t\ttmp.id = d.id.toString();\n\t\t\t}\n\t\t\tif (d && d.text) {\n\t\t\t\ttmp.text = d.text;\n\t\t\t}\n\t\t\tif (d && d.data && d.data.jstree && d.data.jstree.icon) {\n\t\t\t\ttmp.icon = d.data.jstree.icon;\n\t\t\t}\n\t\t\tif (tmp.icon === undefined || tmp.icon === null || tmp.icon === \"\") {\n\t\t\t\ttmp.icon = true;\n\t\t\t}\n\t\t\tif (d && d.data) {\n\t\t\t\ttmp.data = d.data;\n\t\t\t\tif (d.data.jstree) {\n\t\t\t\t\tfor (i in d.data.jstree) {\n\t\t\t\t\t\tif (d.data.jstree.hasOwnProperty(i)) {\n\t\t\t\t\t\t\ttmp.state[i] = d.data.jstree[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (d && _typeof(d.state) === 'object') {\n\t\t\t\tfor (i in d.state) {\n\t\t\t\t\tif (d.state.hasOwnProperty(i)) {\n\t\t\t\t\t\ttmp.state[i] = d.state[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (d && _typeof(d.li_attr) === 'object') {\n\t\t\t\tfor (i in d.li_attr) {\n\t\t\t\t\tif (d.li_attr.hasOwnProperty(i)) {\n\t\t\t\t\t\ttmp.li_attr[i] = d.li_attr[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tmp.li_attr.id && !tmp.id) {\n\t\t\t\ttmp.id = tmp.li_attr.id.toString();\n\t\t\t}\n\t\t\tif (!tmp.id) {\n\t\t\t\ttmp.id = tid;\n\t\t\t}\n\t\t\tif (!tmp.li_attr.id) {\n\t\t\t\ttmp.li_attr.id = tmp.id;\n\t\t\t}\n\t\t\tif (d && _typeof(d.a_attr) === 'object') {\n\t\t\t\tfor (i in d.a_attr) {\n\t\t\t\t\tif (d.a_attr.hasOwnProperty(i)) {\n\t\t\t\t\t\ttmp.a_attr[i] = d.a_attr[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (d && d.children && d.children.length) {\n\t\t\t\tfor (i = 0, j = d.children.length; i < j; i++) {\n\t\t\t\t\tc = this._parse_model_from_json(d.children[i], tmp.id, ps);\n\t\t\t\t\te = m[c];\n\t\t\t\t\ttmp.children.push(c);\n\t\t\t\t\tif (e.children_d.length) {\n\t\t\t\t\t\ttmp.children_d = tmp.children_d.concat(e.children_d);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp.children_d = tmp.children_d.concat(tmp.children);\n\t\t\t}\n\t\t\tif (d && d.children && d.children === true) {\n\t\t\t\ttmp.state.loaded = false;\n\t\t\t\ttmp.children = [];\n\t\t\t\ttmp.children_d = [];\n\t\t\t}\n\t\t\tdelete d.data;\n\t\t\tdelete d.children;\n\t\t\ttmp.original = d;\n\t\t\tm[tmp.id] = tmp;\n\t\t\tif (tmp.state.selected) {\n\t\t\t\tthis._data.core.selected.push(tmp.id);\n\t\t\t}\n\t\t\treturn tmp.id;\n\t\t},\n\t\t/**\n   * redraws all nodes that need to be redrawn. Used internally.\n   * @private\n   * @name _redraw()\n   * @trigger redraw.jstree\n   */\n\t\t_redraw: function _redraw() {\n\t\t\tvar nodes = this._model.force_full_redraw ? this._model.data[$.jstree.root].children.concat([]) : this._model.changed.concat([]),\n\t\t\t    f = document.createElement('UL'),\n\t\t\t    tmp,\n\t\t\t    i,\n\t\t\t    j,\n\t\t\t    fe = this._data.core.focused;\n\t\t\tfor (i = 0, j = nodes.length; i < j; i++) {\n\t\t\t\ttmp = this.redraw_node(nodes[i], true, this._model.force_full_redraw);\n\t\t\t\tif (tmp && this._model.force_full_redraw) {\n\t\t\t\t\tf.appendChild(tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this._model.force_full_redraw) {\n\t\t\t\tf.className = this.get_container_ul()[0].className;\n\t\t\t\tf.setAttribute('role', 'group');\n\t\t\t\tthis.element.empty().append(f);\n\t\t\t\t//this.get_container_ul()[0].appendChild(f);\n\t\t\t}\n\t\t\tif (fe !== null) {\n\t\t\t\ttmp = this.get_node(fe, true);\n\t\t\t\tif (tmp && tmp.length && tmp.children('.jstree-anchor')[0] !== document.activeElement) {\n\t\t\t\t\ttmp.children('.jstree-anchor').focus();\n\t\t\t\t} else {\n\t\t\t\t\tthis._data.core.focused = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._model.force_full_redraw = false;\n\t\t\tthis._model.changed = [];\n\t\t\t/**\n    * triggered after nodes are redrawn\n    * @event\n    * @name redraw.jstree\n    * @param {array} nodes the redrawn nodes\n    */\n\t\t\tthis.trigger('redraw', { \"nodes\": nodes });\n\t\t},\n\t\t/**\n   * redraws all nodes that need to be redrawn or optionally - the whole tree\n   * @name redraw([full])\n   * @param {Boolean} full if set to `true` all nodes are redrawn.\n   */\n\t\tredraw: function redraw(full) {\n\t\t\tif (full) {\n\t\t\t\tthis._model.force_full_redraw = true;\n\t\t\t}\n\t\t\t//if(this._model.redraw_timeout) {\n\t\t\t//\tclearTimeout(this._model.redraw_timeout);\n\t\t\t//}\n\t\t\t//this._model.redraw_timeout = setTimeout($.proxy(this._redraw, this),0);\n\t\t\tthis._redraw();\n\t\t},\n\t\t/**\n   * redraws a single node's children. Used internally.\n   * @private\n   * @name draw_children(node)\n   * @param {mixed} node the node whose children will be redrawn\n   */\n\t\tdraw_children: function draw_children(node) {\n\t\t\tvar obj = this.get_node(node),\n\t\t\t    i = false,\n\t\t\t    j = false,\n\t\t\t    k = false,\n\t\t\t    d = document;\n\t\t\tif (!obj) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (obj.id === $.jstree.root) {\n\t\t\t\treturn this.redraw(true);\n\t\t\t}\n\t\t\tnode = this.get_node(node, true);\n\t\t\tif (!node || !node.length) {\n\t\t\t\treturn false;\n\t\t\t} // TODO: quick toggle\n\n\t\t\tnode.children('.jstree-children').remove();\n\t\t\tnode = node[0];\n\t\t\tif (obj.children.length && obj.state.loaded) {\n\t\t\t\tk = d.createElement('UL');\n\t\t\t\tk.setAttribute('role', 'group');\n\t\t\t\tk.className = 'jstree-children';\n\t\t\t\tfor (i = 0, j = obj.children.length; i < j; i++) {\n\t\t\t\t\tk.appendChild(this.redraw_node(obj.children[i], true, true));\n\t\t\t\t}\n\t\t\t\tnode.appendChild(k);\n\t\t\t}\n\t\t},\n\t\t/**\n   * redraws a single node. Used internally.\n   * @private\n   * @name redraw_node(node, deep, is_callback, force_render)\n   * @param {mixed} node the node to redraw\n   * @param {Boolean} deep should child nodes be redrawn too\n   * @param {Boolean} is_callback is this a recursion call\n   * @param {Boolean} force_render should children of closed parents be drawn anyway\n   */\n\t\tredraw_node: function redraw_node(node, deep, is_callback, force_render) {\n\t\t\tvar obj = this.get_node(node),\n\t\t\t    par = false,\n\t\t\t    ind = false,\n\t\t\t    old = false,\n\t\t\t    i = false,\n\t\t\t    j = false,\n\t\t\t    k = false,\n\t\t\t    c = '',\n\t\t\t    d = document,\n\t\t\t    m = this._model.data,\n\t\t\t    f = false,\n\t\t\t    s = false,\n\t\t\t    tmp = null,\n\t\t\t    t = 0,\n\t\t\t    l = 0,\n\t\t\t    has_children = false,\n\t\t\t    last_sibling = false;\n\t\t\tif (!obj) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (obj.id === $.jstree.root) {\n\t\t\t\treturn this.redraw(true);\n\t\t\t}\n\t\t\tdeep = deep || obj.children.length === 0;\n\t\t\tnode = !document.querySelector ? document.getElementById(obj.id) : this.element[0].querySelector('#' + (\"0123456789\".indexOf(obj.id[0]) !== -1 ? '\\\\3' + obj.id[0] + ' ' + obj.id.substr(1).replace($.jstree.idregex, '\\\\$&') : obj.id.replace($.jstree.idregex, '\\\\$&'))); //, this.element);\n\t\t\tif (!node) {\n\t\t\t\tdeep = true;\n\t\t\t\t//node = d.createElement('LI');\n\t\t\t\tif (!is_callback) {\n\t\t\t\t\tpar = obj.parent !== $.jstree.root ? $('#' + obj.parent.replace($.jstree.idregex, '\\\\$&'), this.element)[0] : null;\n\t\t\t\t\tif (par !== null && (!par || !m[obj.parent].state.opened)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tind = $.inArray(obj.id, par === null ? m[$.jstree.root].children : m[obj.parent].children);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnode = $(node);\n\t\t\t\tif (!is_callback) {\n\t\t\t\t\tpar = node.parent().parent()[0];\n\t\t\t\t\tif (par === this.element[0]) {\n\t\t\t\t\t\tpar = null;\n\t\t\t\t\t}\n\t\t\t\t\tind = node.index();\n\t\t\t\t}\n\t\t\t\t// m[obj.id].data = node.data(); // use only node's data, no need to touch jquery storage\n\t\t\t\tif (!deep && obj.children.length && !node.children('.jstree-children').length) {\n\t\t\t\t\tdeep = true;\n\t\t\t\t}\n\t\t\t\tif (!deep) {\n\t\t\t\t\told = node.children('.jstree-children')[0];\n\t\t\t\t}\n\t\t\t\tf = node.children('.jstree-anchor')[0] === document.activeElement;\n\t\t\t\tnode.remove();\n\t\t\t\t//node = d.createElement('LI');\n\t\t\t\t//node = node[0];\n\t\t\t}\n\t\t\tnode = this._data.core.node.cloneNode(true);\n\t\t\t// node is DOM, deep is boolean\n\n\t\t\tc = 'jstree-node ';\n\t\t\tfor (i in obj.li_attr) {\n\t\t\t\tif (obj.li_attr.hasOwnProperty(i)) {\n\t\t\t\t\tif (i === 'id') {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (i !== 'class') {\n\t\t\t\t\t\tnode.setAttribute(i, obj.li_attr[i]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tc += obj.li_attr[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!obj.a_attr.id) {\n\t\t\t\tobj.a_attr.id = obj.id + '_anchor';\n\t\t\t}\n\t\t\tnode.setAttribute('aria-selected', !!obj.state.selected);\n\t\t\tnode.setAttribute('aria-level', obj.parents.length);\n\t\t\tnode.setAttribute('aria-labelledby', obj.a_attr.id);\n\t\t\tif (obj.state.disabled) {\n\t\t\t\tnode.setAttribute('aria-disabled', true);\n\t\t\t}\n\n\t\t\tfor (i = 0, j = obj.children.length; i < j; i++) {\n\t\t\t\tif (!m[obj.children[i]].state.hidden) {\n\t\t\t\t\thas_children = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (obj.parent !== null && m[obj.parent] && !obj.state.hidden) {\n\t\t\t\ti = $.inArray(obj.id, m[obj.parent].children);\n\t\t\t\tlast_sibling = obj.id;\n\t\t\t\tif (i !== -1) {\n\t\t\t\t\ti++;\n\t\t\t\t\tfor (j = m[obj.parent].children.length; i < j; i++) {\n\t\t\t\t\t\tif (!m[m[obj.parent].children[i]].state.hidden) {\n\t\t\t\t\t\t\tlast_sibling = m[obj.parent].children[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (last_sibling !== obj.id) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (obj.state.hidden) {\n\t\t\t\tc += ' jstree-hidden';\n\t\t\t}\n\t\t\tif (obj.state.loaded && !has_children) {\n\t\t\t\tc += ' jstree-leaf';\n\t\t\t} else {\n\t\t\t\tc += obj.state.opened && obj.state.loaded ? ' jstree-open' : ' jstree-closed';\n\t\t\t\tnode.setAttribute('aria-expanded', obj.state.opened && obj.state.loaded);\n\t\t\t}\n\t\t\tif (last_sibling === obj.id) {\n\t\t\t\tc += ' jstree-last';\n\t\t\t}\n\t\t\tnode.id = obj.id;\n\t\t\tnode.className = c;\n\t\t\tc = (obj.state.selected ? ' jstree-clicked' : '') + (obj.state.disabled ? ' jstree-disabled' : '');\n\t\t\tfor (j in obj.a_attr) {\n\t\t\t\tif (obj.a_attr.hasOwnProperty(j)) {\n\t\t\t\t\tif (j === 'href' && obj.a_attr[j] === '#') {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (j !== 'class') {\n\t\t\t\t\t\tnode.childNodes[1].setAttribute(j, obj.a_attr[j]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tc += ' ' + obj.a_attr[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (c.length) {\n\t\t\t\tnode.childNodes[1].className = 'jstree-anchor ' + c;\n\t\t\t}\n\t\t\tif (obj.icon && obj.icon !== true || obj.icon === false) {\n\t\t\t\tif (obj.icon === false) {\n\t\t\t\t\tnode.childNodes[1].childNodes[0].className += ' jstree-themeicon-hidden';\n\t\t\t\t} else if (obj.icon.indexOf('/') === -1 && obj.icon.indexOf('.') === -1) {\n\t\t\t\t\tnode.childNodes[1].childNodes[0].className += ' ' + obj.icon + ' jstree-themeicon-custom';\n\t\t\t\t} else {\n\t\t\t\t\tnode.childNodes[1].childNodes[0].style.backgroundImage = 'url(\"' + obj.icon + '\")';\n\t\t\t\t\tnode.childNodes[1].childNodes[0].style.backgroundPosition = 'center center';\n\t\t\t\t\tnode.childNodes[1].childNodes[0].style.backgroundSize = 'auto';\n\t\t\t\t\tnode.childNodes[1].childNodes[0].className += ' jstree-themeicon-custom';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.settings.core.force_text) {\n\t\t\t\tnode.childNodes[1].appendChild(d.createTextNode(obj.text));\n\t\t\t} else {\n\t\t\t\tnode.childNodes[1].innerHTML += obj.text;\n\t\t\t}\n\n\t\t\tif (deep && obj.children.length && (obj.state.opened || force_render) && obj.state.loaded) {\n\t\t\t\tk = d.createElement('UL');\n\t\t\t\tk.setAttribute('role', 'group');\n\t\t\t\tk.className = 'jstree-children';\n\t\t\t\tfor (i = 0, j = obj.children.length; i < j; i++) {\n\t\t\t\t\tk.appendChild(this.redraw_node(obj.children[i], deep, true));\n\t\t\t\t}\n\t\t\t\tnode.appendChild(k);\n\t\t\t}\n\t\t\tif (old) {\n\t\t\t\tnode.appendChild(old);\n\t\t\t}\n\t\t\tif (!is_callback) {\n\t\t\t\t// append back using par / ind\n\t\t\t\tif (!par) {\n\t\t\t\t\tpar = this.element[0];\n\t\t\t\t}\n\t\t\t\tfor (i = 0, j = par.childNodes.length; i < j; i++) {\n\t\t\t\t\tif (par.childNodes[i] && par.childNodes[i].className && par.childNodes[i].className.indexOf('jstree-children') !== -1) {\n\t\t\t\t\t\ttmp = par.childNodes[i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!tmp) {\n\t\t\t\t\ttmp = d.createElement('UL');\n\t\t\t\t\ttmp.setAttribute('role', 'group');\n\t\t\t\t\ttmp.className = 'jstree-children';\n\t\t\t\t\tpar.appendChild(tmp);\n\t\t\t\t}\n\t\t\t\tpar = tmp;\n\n\t\t\t\tif (ind < par.childNodes.length) {\n\t\t\t\t\tpar.insertBefore(node, par.childNodes[ind]);\n\t\t\t\t} else {\n\t\t\t\t\tpar.appendChild(node);\n\t\t\t\t}\n\t\t\t\tif (f) {\n\t\t\t\t\tt = this.element[0].scrollTop;\n\t\t\t\t\tl = this.element[0].scrollLeft;\n\t\t\t\t\tnode.childNodes[1].focus();\n\t\t\t\t\tthis.element[0].scrollTop = t;\n\t\t\t\t\tthis.element[0].scrollLeft = l;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (obj.state.opened && !obj.state.loaded) {\n\t\t\t\tobj.state.opened = false;\n\t\t\t\tsetTimeout($.proxy(function () {\n\t\t\t\t\tthis.open_node(obj.id, false, 0);\n\t\t\t\t}, this), 0);\n\t\t\t}\n\t\t\treturn node;\n\t\t},\n\t\t/**\n   * opens a node, revaling its children. If the node is not loaded it will be loaded and opened once ready.\n   * @name open_node(obj [, callback, animation])\n   * @param {mixed} obj the node to open\n   * @param {Function} callback a function to execute once the node is opened\n   * @param {Number} animation the animation duration in milliseconds when opening the node (overrides the `core.animation` setting). Use `false` for no animation.\n   * @trigger open_node.jstree, after_open.jstree, before_open.jstree\n   */\n\t\topen_node: function open_node(obj, callback, animation) {\n\t\t\tvar t1, t2, d, t;\n\t\t\tif ($.isArray(obj)) {\n\t\t\t\tobj = obj.slice();\n\t\t\t\tfor (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n\t\t\t\t\tthis.open_node(obj[t1], callback, animation);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tobj = this.get_node(obj);\n\t\t\tif (!obj || obj.id === $.jstree.root) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tanimation = animation === undefined ? this.settings.core.animation : animation;\n\t\t\tif (!this.is_closed(obj)) {\n\t\t\t\tif (callback) {\n\t\t\t\t\tcallback.call(this, obj, false);\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!this.is_loaded(obj)) {\n\t\t\t\tif (this.is_loading(obj)) {\n\t\t\t\t\treturn setTimeout($.proxy(function () {\n\t\t\t\t\t\tthis.open_node(obj, callback, animation);\n\t\t\t\t\t}, this), 500);\n\t\t\t\t}\n\t\t\t\tthis.load_node(obj, function (o, ok) {\n\t\t\t\t\treturn ok ? this.open_node(o, callback, animation) : callback ? callback.call(this, o, false) : false;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\td = this.get_node(obj, true);\n\t\t\t\tt = this;\n\t\t\t\tif (d.length) {\n\t\t\t\t\tif (animation && d.children(\".jstree-children\").length) {\n\t\t\t\t\t\td.children(\".jstree-children\").stop(true, true);\n\t\t\t\t\t}\n\t\t\t\t\tif (obj.children.length && !this._firstChild(d.children('.jstree-children')[0])) {\n\t\t\t\t\t\tthis.draw_children(obj);\n\t\t\t\t\t\t//d = this.get_node(obj, true);\n\t\t\t\t\t}\n\t\t\t\t\tif (!animation) {\n\t\t\t\t\t\tthis.trigger('before_open', { \"node\": obj });\n\t\t\t\t\t\td[0].className = d[0].className.replace('jstree-closed', 'jstree-open');\n\t\t\t\t\t\td[0].setAttribute(\"aria-expanded\", true);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.trigger('before_open', { \"node\": obj });\n\t\t\t\t\t\td.children(\".jstree-children\").css(\"display\", \"none\").end().removeClass(\"jstree-closed\").addClass(\"jstree-open\").attr(\"aria-expanded\", true).children(\".jstree-children\").stop(true, true).slideDown(animation, function () {\n\t\t\t\t\t\t\tthis.style.display = \"\";\n\t\t\t\t\t\t\tif (t.element) {\n\t\t\t\t\t\t\t\tt.trigger(\"after_open\", { \"node\": obj });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tobj.state.opened = true;\n\t\t\t\tif (callback) {\n\t\t\t\t\tcallback.call(this, obj, true);\n\t\t\t\t}\n\t\t\t\tif (!d.length) {\n\t\t\t\t\t/**\n      * triggered when a node is about to be opened (if the node is supposed to be in the DOM, it will be, but it won't be visible yet)\n      * @event\n      * @name before_open.jstree\n      * @param {Object} node the opened node\n      */\n\t\t\t\t\tthis.trigger('before_open', { \"node\": obj });\n\t\t\t\t}\n\t\t\t\t/**\n     * triggered when a node is opened (if there is an animation it will not be completed yet)\n     * @event\n     * @name open_node.jstree\n     * @param {Object} node the opened node\n     */\n\t\t\t\tthis.trigger('open_node', { \"node\": obj });\n\t\t\t\tif (!animation || !d.length) {\n\t\t\t\t\t/**\n      * triggered when a node is opened and the animation is complete\n      * @event\n      * @name after_open.jstree\n      * @param {Object} node the opened node\n      */\n\t\t\t\t\tthis.trigger(\"after_open\", { \"node\": obj });\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t},\n\t\t/**\n   * opens every parent of a node (node should be loaded)\n   * @name _open_to(obj)\n   * @param {mixed} obj the node to reveal\n   * @private\n   */\n\t\t_open_to: function _open_to(obj) {\n\t\t\tobj = this.get_node(obj);\n\t\t\tif (!obj || obj.id === $.jstree.root) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar i,\n\t\t\t    j,\n\t\t\t    p = obj.parents;\n\t\t\tfor (i = 0, j = p.length; i < j; i += 1) {\n\t\t\t\tif (i !== $.jstree.root) {\n\t\t\t\t\tthis.open_node(p[i], false, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn $('#' + obj.id.replace($.jstree.idregex, '\\\\$&'), this.element);\n\t\t},\n\t\t/**\n   * closes a node, hiding its children\n   * @name close_node(obj [, animation])\n   * @param {mixed} obj the node to close\n   * @param {Number} animation the animation duration in milliseconds when closing the node (overrides the `core.animation` setting). Use `false` for no animation.\n   * @trigger close_node.jstree, after_close.jstree\n   */\n\t\tclose_node: function close_node(obj, animation) {\n\t\t\tvar t1, t2, t, d;\n\t\t\tif ($.isArray(obj)) {\n\t\t\t\tobj = obj.slice();\n\t\t\t\tfor (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n\t\t\t\t\tthis.close_node(obj[t1], animation);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tobj = this.get_node(obj);\n\t\t\tif (!obj || obj.id === $.jstree.root) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (this.is_closed(obj)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tanimation = animation === undefined ? this.settings.core.animation : animation;\n\t\t\tt = this;\n\t\t\td = this.get_node(obj, true);\n\n\t\t\tobj.state.opened = false;\n\t\t\t/**\n    * triggered when a node is closed (if there is an animation it will not be complete yet)\n    * @event\n    * @name close_node.jstree\n    * @param {Object} node the closed node\n    */\n\t\t\tthis.trigger('close_node', { \"node\": obj });\n\t\t\tif (!d.length) {\n\t\t\t\t/**\n     * triggered when a node is closed and the animation is complete\n     * @event\n     * @name after_close.jstree\n     * @param {Object} node the closed node\n     */\n\t\t\t\tthis.trigger(\"after_close\", { \"node\": obj });\n\t\t\t} else {\n\t\t\t\tif (!animation) {\n\t\t\t\t\td[0].className = d[0].className.replace('jstree-open', 'jstree-closed');\n\t\t\t\t\td.attr(\"aria-expanded\", false).children('.jstree-children').remove();\n\t\t\t\t\tthis.trigger(\"after_close\", { \"node\": obj });\n\t\t\t\t} else {\n\t\t\t\t\td.children(\".jstree-children\").attr(\"style\", \"display:block !important\").end().removeClass(\"jstree-open\").addClass(\"jstree-closed\").attr(\"aria-expanded\", false).children(\".jstree-children\").stop(true, true).slideUp(animation, function () {\n\t\t\t\t\t\tthis.style.display = \"\";\n\t\t\t\t\t\td.children('.jstree-children').remove();\n\t\t\t\t\t\tif (t.element) {\n\t\t\t\t\t\t\tt.trigger(\"after_close\", { \"node\": obj });\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t/**\n   * toggles a node - closing it if it is open, opening it if it is closed\n   * @name toggle_node(obj)\n   * @param {mixed} obj the node to toggle\n   */\n\t\ttoggle_node: function toggle_node(obj) {\n\t\t\tvar t1, t2;\n\t\t\tif ($.isArray(obj)) {\n\t\t\t\tobj = obj.slice();\n\t\t\t\tfor (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n\t\t\t\t\tthis.toggle_node(obj[t1]);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (this.is_closed(obj)) {\n\t\t\t\treturn this.open_node(obj);\n\t\t\t}\n\t\t\tif (this.is_open(obj)) {\n\t\t\t\treturn this.close_node(obj);\n\t\t\t}\n\t\t},\n\t\t/**\n   * opens all nodes within a node (or the tree), revaling their children. If the node is not loaded it will be loaded and opened once ready.\n   * @name open_all([obj, animation, original_obj])\n   * @param {mixed} obj the node to open recursively, omit to open all nodes in the tree\n   * @param {Number} animation the animation duration in milliseconds when opening the nodes, the default is no animation\n   * @param {jQuery} reference to the node that started the process (internal use)\n   * @trigger open_all.jstree\n   */\n\t\topen_all: function open_all(obj, animation, original_obj) {\n\t\t\tif (!obj) {\n\t\t\t\tobj = $.jstree.root;\n\t\t\t}\n\t\t\tobj = this.get_node(obj);\n\t\t\tif (!obj) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar dom = obj.id === $.jstree.root ? this.get_container_ul() : this.get_node(obj, true),\n\t\t\t    i,\n\t\t\t    j,\n\t\t\t    _this;\n\t\t\tif (!dom.length) {\n\t\t\t\tfor (i = 0, j = obj.children_d.length; i < j; i++) {\n\t\t\t\t\tif (this.is_closed(this._model.data[obj.children_d[i]])) {\n\t\t\t\t\t\tthis._model.data[obj.children_d[i]].state.opened = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this.trigger('open_all', { \"node\": obj });\n\t\t\t}\n\t\t\toriginal_obj = original_obj || dom;\n\t\t\t_this = this;\n\t\t\tdom = this.is_closed(obj) ? dom.find('.jstree-closed').addBack() : dom.find('.jstree-closed');\n\t\t\tdom.each(function () {\n\t\t\t\t_this.open_node(this, function (node, status) {\n\t\t\t\t\tif (status && this.is_parent(node)) {\n\t\t\t\t\t\tthis.open_all(node, animation, original_obj);\n\t\t\t\t\t}\n\t\t\t\t}, animation || 0);\n\t\t\t});\n\t\t\tif (original_obj.find('.jstree-closed').length === 0) {\n\t\t\t\t/**\n     * triggered when an `open_all` call completes\n     * @event\n     * @name open_all.jstree\n     * @param {Object} node the opened node\n     */\n\t\t\t\tthis.trigger('open_all', { \"node\": this.get_node(original_obj) });\n\t\t\t}\n\t\t},\n\t\t/**\n   * closes all nodes within a node (or the tree), revaling their children\n   * @name close_all([obj, animation])\n   * @param {mixed} obj the node to close recursively, omit to close all nodes in the tree\n   * @param {Number} animation the animation duration in milliseconds when closing the nodes, the default is no animation\n   * @trigger close_all.jstree\n   */\n\t\tclose_all: function close_all(obj, animation) {\n\t\t\tif (!obj) {\n\t\t\t\tobj = $.jstree.root;\n\t\t\t}\n\t\t\tobj = this.get_node(obj);\n\t\t\tif (!obj) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar dom = obj.id === $.jstree.root ? this.get_container_ul() : this.get_node(obj, true),\n\t\t\t    _this = this,\n\t\t\t    i,\n\t\t\t    j;\n\t\t\tif (dom.length) {\n\t\t\t\tdom = this.is_open(obj) ? dom.find('.jstree-open').addBack() : dom.find('.jstree-open');\n\t\t\t\t$(dom.get().reverse()).each(function () {\n\t\t\t\t\t_this.close_node(this, animation || 0);\n\t\t\t\t});\n\t\t\t}\n\t\t\tfor (i = 0, j = obj.children_d.length; i < j; i++) {\n\t\t\t\tthis._model.data[obj.children_d[i]].state.opened = false;\n\t\t\t}\n\t\t\t/**\n    * triggered when an `close_all` call completes\n    * @event\n    * @name close_all.jstree\n    * @param {Object} node the closed node\n    */\n\t\t\tthis.trigger('close_all', { \"node\": obj });\n\t\t},\n\t\t/**\n   * checks if a node is disabled (not selectable)\n   * @name is_disabled(obj)\n   * @param  {mixed} obj\n   * @return {Boolean}\n   */\n\t\tis_disabled: function is_disabled(obj) {\n\t\t\tobj = this.get_node(obj);\n\t\t\treturn obj && obj.state && obj.state.disabled;\n\t\t},\n\t\t/**\n   * enables a node - so that it can be selected\n   * @name enable_node(obj)\n   * @param {mixed} obj the node to enable\n   * @trigger enable_node.jstree\n   */\n\t\tenable_node: function enable_node(obj) {\n\t\t\tvar t1, t2;\n\t\t\tif ($.isArray(obj)) {\n\t\t\t\tobj = obj.slice();\n\t\t\t\tfor (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n\t\t\t\t\tthis.enable_node(obj[t1]);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tobj = this.get_node(obj);\n\t\t\tif (!obj || obj.id === $.jstree.root) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tobj.state.disabled = false;\n\t\t\tthis.get_node(obj, true).children('.jstree-anchor').removeClass('jstree-disabled').attr('aria-disabled', false);\n\t\t\t/**\n    * triggered when an node is enabled\n    * @event\n    * @name enable_node.jstree\n    * @param {Object} node the enabled node\n    */\n\t\t\tthis.trigger('enable_node', { 'node': obj });\n\t\t},\n\t\t/**\n   * disables a node - so that it can not be selected\n   * @name disable_node(obj)\n   * @param {mixed} obj the node to disable\n   * @trigger disable_node.jstree\n   */\n\t\tdisable_node: function disable_node(obj) {\n\t\t\tvar t1, t2;\n\t\t\tif ($.isArray(obj)) {\n\t\t\t\tobj = obj.slice();\n\t\t\t\tfor (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n\t\t\t\t\tthis.disable_node(obj[t1]);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tobj = this.get_node(obj);\n\t\t\tif (!obj || obj.id === $.jstree.root) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tobj.state.disabled = true;\n\t\t\tthis.get_node(obj, true).children('.jstree-anchor').addClass('jstree-disabled').attr('aria-disabled', true);\n\t\t\t/**\n    * triggered when an node is disabled\n    * @event\n    * @name disable_node.jstree\n    * @param {Object} node the disabled node\n    */\n\t\t\tthis.trigger('disable_node', { 'node': obj });\n\t\t},\n\t\t/**\n   * determines if a node is hidden\n   * @name is_hidden(obj)\n   * @param {mixed} obj the node\n   */\n\t\tis_hidden: function is_hidden(obj) {\n\t\t\tobj = this.get_node(obj);\n\t\t\treturn obj.state.hidden === true;\n\t\t},\n\t\t/**\n   * hides a node - it is still in the structure but will not be visible\n   * @name hide_node(obj)\n   * @param {mixed} obj the node to hide\n   * @param {Boolean} skip_redraw internal parameter controlling if redraw is called\n   * @trigger hide_node.jstree\n   */\n\t\thide_node: function hide_node(obj, skip_redraw) {\n\t\t\tvar t1, t2;\n\t\t\tif ($.isArray(obj)) {\n\t\t\t\tobj = obj.slice();\n\t\t\t\tfor (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n\t\t\t\t\tthis.hide_node(obj[t1], true);\n\t\t\t\t}\n\t\t\t\tif (!skip_redraw) {\n\t\t\t\t\tthis.redraw();\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tobj = this.get_node(obj);\n\t\t\tif (!obj || obj.id === $.jstree.root) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!obj.state.hidden) {\n\t\t\t\tobj.state.hidden = true;\n\t\t\t\tthis._node_changed(obj.parent);\n\t\t\t\tif (!skip_redraw) {\n\t\t\t\t\tthis.redraw();\n\t\t\t\t}\n\t\t\t\t/**\n     * triggered when an node is hidden\n     * @event\n     * @name hide_node.jstree\n     * @param {Object} node the hidden node\n     */\n\t\t\t\tthis.trigger('hide_node', { 'node': obj });\n\t\t\t}\n\t\t},\n\t\t/**\n   * shows a node\n   * @name show_node(obj)\n   * @param {mixed} obj the node to show\n   * @param {Boolean} skip_redraw internal parameter controlling if redraw is called\n   * @trigger show_node.jstree\n   */\n\t\tshow_node: function show_node(obj, skip_redraw) {\n\t\t\tvar t1, t2;\n\t\t\tif ($.isArray(obj)) {\n\t\t\t\tobj = obj.slice();\n\t\t\t\tfor (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n\t\t\t\t\tthis.show_node(obj[t1], true);\n\t\t\t\t}\n\t\t\t\tif (!skip_redraw) {\n\t\t\t\t\tthis.redraw();\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tobj = this.get_node(obj);\n\t\t\tif (!obj || obj.id === $.jstree.root) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (obj.state.hidden) {\n\t\t\t\tobj.state.hidden = false;\n\t\t\t\tthis._node_changed(obj.parent);\n\t\t\t\tif (!skip_redraw) {\n\t\t\t\t\tthis.redraw();\n\t\t\t\t}\n\t\t\t\t/**\n     * triggered when an node is shown\n     * @event\n     * @name show_node.jstree\n     * @param {Object} node the shown node\n     */\n\t\t\t\tthis.trigger('show_node', { 'node': obj });\n\t\t\t}\n\t\t},\n\t\t/**\n   * hides all nodes\n   * @name hide_all()\n   * @trigger hide_all.jstree\n   */\n\t\thide_all: function hide_all(skip_redraw) {\n\t\t\tvar i,\n\t\t\t    m = this._model.data,\n\t\t\t    ids = [];\n\t\t\tfor (i in m) {\n\t\t\t\tif (m.hasOwnProperty(i) && i !== $.jstree.root && !m[i].state.hidden) {\n\t\t\t\t\tm[i].state.hidden = true;\n\t\t\t\t\tids.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._model.force_full_redraw = true;\n\t\t\tif (!skip_redraw) {\n\t\t\t\tthis.redraw();\n\t\t\t}\n\t\t\t/**\n    * triggered when all nodes are hidden\n    * @event\n    * @name hide_all.jstree\n    * @param {Array} nodes the IDs of all hidden nodes\n    */\n\t\t\tthis.trigger('hide_all', { 'nodes': ids });\n\t\t\treturn ids;\n\t\t},\n\t\t/**\n   * shows all nodes\n   * @name show_all()\n   * @trigger show_all.jstree\n   */\n\t\tshow_all: function show_all(skip_redraw) {\n\t\t\tvar i,\n\t\t\t    m = this._model.data,\n\t\t\t    ids = [];\n\t\t\tfor (i in m) {\n\t\t\t\tif (m.hasOwnProperty(i) && i !== $.jstree.root && m[i].state.hidden) {\n\t\t\t\t\tm[i].state.hidden = false;\n\t\t\t\t\tids.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._model.force_full_redraw = true;\n\t\t\tif (!skip_redraw) {\n\t\t\t\tthis.redraw();\n\t\t\t}\n\t\t\t/**\n    * triggered when all nodes are shown\n    * @event\n    * @name show_all.jstree\n    * @param {Array} nodes the IDs of all shown nodes\n    */\n\t\t\tthis.trigger('show_all', { 'nodes': ids });\n\t\t\treturn ids;\n\t\t},\n\t\t/**\n   * called when a node is selected by the user. Used internally.\n   * @private\n   * @name activate_node(obj, e)\n   * @param {mixed} obj the node\n   * @param {Object} e the related event\n   * @trigger activate_node.jstree, changed.jstree\n   */\n\t\tactivate_node: function activate_node(obj, e) {\n\t\t\tif (this.is_disabled(obj)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!e || (typeof e === 'undefined' ? 'undefined' : _typeof(e)) !== 'object') {\n\t\t\t\te = {};\n\t\t\t}\n\n\t\t\t// ensure last_clicked is still in the DOM, make it fresh (maybe it was moved?) and make sure it is still selected, if not - make last_clicked the last selected node\n\t\t\tthis._data.core.last_clicked = this._data.core.last_clicked && this._data.core.last_clicked.id !== undefined ? this.get_node(this._data.core.last_clicked.id) : null;\n\t\t\tif (this._data.core.last_clicked && !this._data.core.last_clicked.state.selected) {\n\t\t\t\tthis._data.core.last_clicked = null;\n\t\t\t}\n\t\t\tif (!this._data.core.last_clicked && this._data.core.selected.length) {\n\t\t\t\tthis._data.core.last_clicked = this.get_node(this._data.core.selected[this._data.core.selected.length - 1]);\n\t\t\t}\n\n\t\t\tif (!this.settings.core.multiple || !e.metaKey && !e.ctrlKey && !e.shiftKey || e.shiftKey && (!this._data.core.last_clicked || !this.get_parent(obj) || this.get_parent(obj) !== this._data.core.last_clicked.parent)) {\n\t\t\t\tif (!this.settings.core.multiple && (e.metaKey || e.ctrlKey || e.shiftKey) && this.is_selected(obj)) {\n\t\t\t\t\tthis.deselect_node(obj, false, e);\n\t\t\t\t} else {\n\t\t\t\t\tthis.deselect_all(true);\n\t\t\t\t\tthis.select_node(obj, false, false, e);\n\t\t\t\t\tthis._data.core.last_clicked = this.get_node(obj);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (e.shiftKey) {\n\t\t\t\t\tvar o = this.get_node(obj).id,\n\t\t\t\t\t    l = this._data.core.last_clicked.id,\n\t\t\t\t\t    p = this.get_node(this._data.core.last_clicked.parent).children,\n\t\t\t\t\t    c = false,\n\t\t\t\t\t    i,\n\t\t\t\t\t    j;\n\t\t\t\t\tfor (i = 0, j = p.length; i < j; i += 1) {\n\t\t\t\t\t\t// separate IFs work whem o and l are the same\n\t\t\t\t\t\tif (p[i] === o) {\n\t\t\t\t\t\t\tc = !c;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (p[i] === l) {\n\t\t\t\t\t\t\tc = !c;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!this.is_disabled(p[i]) && (c || p[i] === o || p[i] === l)) {\n\t\t\t\t\t\t\tif (!this.is_hidden(p[i])) {\n\t\t\t\t\t\t\t\tthis.select_node(p[i], true, false, e);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.deselect_node(p[i], true, e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis.trigger('changed', { 'action': 'select_node', 'node': this.get_node(obj), 'selected': this._data.core.selected, 'event': e });\n\t\t\t\t} else {\n\t\t\t\t\tif (!this.is_selected(obj)) {\n\t\t\t\t\t\tthis.select_node(obj, false, false, e);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.deselect_node(obj, false, e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/**\n    * triggered when an node is clicked or intercated with by the user\n    * @event\n    * @name activate_node.jstree\n    * @param {Object} node\n    * @param {Object} event the ooriginal event (if any) which triggered the call (may be an empty object)\n    */\n\t\t\tthis.trigger('activate_node', { 'node': this.get_node(obj), 'event': e });\n\t\t},\n\t\t/**\n   * applies the hover state on a node, called when a node is hovered by the user. Used internally.\n   * @private\n   * @name hover_node(obj)\n   * @param {mixed} obj\n   * @trigger hover_node.jstree\n   */\n\t\thover_node: function hover_node(obj) {\n\t\t\tobj = this.get_node(obj, true);\n\t\t\tif (!obj || !obj.length || obj.children('.jstree-hovered').length) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar o = this.element.find('.jstree-hovered'),\n\t\t\t    t = this.element;\n\t\t\tif (o && o.length) {\n\t\t\t\tthis.dehover_node(o);\n\t\t\t}\n\n\t\t\tobj.children('.jstree-anchor').addClass('jstree-hovered');\n\t\t\t/**\n    * triggered when an node is hovered\n    * @event\n    * @name hover_node.jstree\n    * @param {Object} node\n    */\n\t\t\tthis.trigger('hover_node', { 'node': this.get_node(obj) });\n\t\t\tsetTimeout(function () {\n\t\t\t\tt.attr('aria-activedescendant', obj[0].id);\n\t\t\t}, 0);\n\t\t},\n\t\t/**\n   * removes the hover state from a nodecalled when a node is no longer hovered by the user. Used internally.\n   * @private\n   * @name dehover_node(obj)\n   * @param {mixed} obj\n   * @trigger dehover_node.jstree\n   */\n\t\tdehover_node: function dehover_node(obj) {\n\t\t\tobj = this.get_node(obj, true);\n\t\t\tif (!obj || !obj.length || !obj.children('.jstree-hovered').length) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tobj.children('.jstree-anchor').removeClass('jstree-hovered');\n\t\t\t/**\n    * triggered when an node is no longer hovered\n    * @event\n    * @name dehover_node.jstree\n    * @param {Object} node\n    */\n\t\t\tthis.trigger('dehover_node', { 'node': this.get_node(obj) });\n\t\t},\n\t\t/**\n   * select a node\n   * @name select_node(obj [, supress_event, prevent_open])\n   * @param {mixed} obj an array can be used to select multiple nodes\n   * @param {Boolean} supress_event if set to `true` the `changed.jstree` event won't be triggered\n   * @param {Boolean} prevent_open if set to `true` parents of the selected node won't be opened\n   * @trigger select_node.jstree, changed.jstree\n   */\n\t\tselect_node: function select_node(obj, supress_event, prevent_open, e) {\n\t\t\tvar dom, t1, t2, th;\n\t\t\tif ($.isArray(obj)) {\n\t\t\t\tobj = obj.slice();\n\t\t\t\tfor (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n\t\t\t\t\tthis.select_node(obj[t1], supress_event, prevent_open, e);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tobj = this.get_node(obj);\n\t\t\tif (!obj || obj.id === $.jstree.root) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tdom = this.get_node(obj, true);\n\t\t\tif (!obj.state.selected) {\n\t\t\t\tobj.state.selected = true;\n\t\t\t\tthis._data.core.selected.push(obj.id);\n\t\t\t\tif (!prevent_open) {\n\t\t\t\t\tdom = this._open_to(obj);\n\t\t\t\t}\n\t\t\t\tif (dom && dom.length) {\n\t\t\t\t\tdom.attr('aria-selected', true).children('.jstree-anchor').addClass('jstree-clicked');\n\t\t\t\t}\n\t\t\t\t/**\n     * triggered when an node is selected\n     * @event\n     * @name select_node.jstree\n     * @param {Object} node\n     * @param {Array} selected the current selection\n     * @param {Object} event the event (if any) that triggered this select_node\n     */\n\t\t\t\tthis.trigger('select_node', { 'node': obj, 'selected': this._data.core.selected, 'event': e });\n\t\t\t\tif (!supress_event) {\n\t\t\t\t\t/**\n      * triggered when selection changes\n      * @event\n      * @name changed.jstree\n      * @param {Object} node\n      * @param {Object} action the action that caused the selection to change\n      * @param {Array} selected the current selection\n      * @param {Object} event the event (if any) that triggered this changed event\n      */\n\t\t\t\t\tthis.trigger('changed', { 'action': 'select_node', 'node': obj, 'selected': this._data.core.selected, 'event': e });\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t/**\n   * deselect a node\n   * @name deselect_node(obj [, supress_event])\n   * @param {mixed} obj an array can be used to deselect multiple nodes\n   * @param {Boolean} supress_event if set to `true` the `changed.jstree` event won't be triggered\n   * @trigger deselect_node.jstree, changed.jstree\n   */\n\t\tdeselect_node: function deselect_node(obj, supress_event, e) {\n\t\t\tvar t1, t2, dom;\n\t\t\tif ($.isArray(obj)) {\n\t\t\t\tobj = obj.slice();\n\t\t\t\tfor (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n\t\t\t\t\tthis.deselect_node(obj[t1], supress_event, e);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tobj = this.get_node(obj);\n\t\t\tif (!obj || obj.id === $.jstree.root) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tdom = this.get_node(obj, true);\n\t\t\tif (obj.state.selected) {\n\t\t\t\tobj.state.selected = false;\n\t\t\t\tthis._data.core.selected = $.vakata.array_remove_item(this._data.core.selected, obj.id);\n\t\t\t\tif (dom.length) {\n\t\t\t\t\tdom.attr('aria-selected', false).children('.jstree-anchor').removeClass('jstree-clicked');\n\t\t\t\t}\n\t\t\t\t/**\n     * triggered when an node is deselected\n     * @event\n     * @name deselect_node.jstree\n     * @param {Object} node\n     * @param {Array} selected the current selection\n     * @param {Object} event the event (if any) that triggered this deselect_node\n     */\n\t\t\t\tthis.trigger('deselect_node', { 'node': obj, 'selected': this._data.core.selected, 'event': e });\n\t\t\t\tif (!supress_event) {\n\t\t\t\t\tthis.trigger('changed', { 'action': 'deselect_node', 'node': obj, 'selected': this._data.core.selected, 'event': e });\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t/**\n   * select all nodes in the tree\n   * @name select_all([supress_event])\n   * @param {Boolean} supress_event if set to `true` the `changed.jstree` event won't be triggered\n   * @trigger select_all.jstree, changed.jstree\n   */\n\t\tselect_all: function select_all(supress_event) {\n\t\t\tvar tmp = this._data.core.selected.concat([]),\n\t\t\t    i,\n\t\t\t    j;\n\t\t\tthis._data.core.selected = this._model.data[$.jstree.root].children_d.concat();\n\t\t\tfor (i = 0, j = this._data.core.selected.length; i < j; i++) {\n\t\t\t\tif (this._model.data[this._data.core.selected[i]]) {\n\t\t\t\t\tthis._model.data[this._data.core.selected[i]].state.selected = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.redraw(true);\n\t\t\t/**\n    * triggered when all nodes are selected\n    * @event\n    * @name select_all.jstree\n    * @param {Array} selected the current selection\n    */\n\t\t\tthis.trigger('select_all', { 'selected': this._data.core.selected });\n\t\t\tif (!supress_event) {\n\t\t\t\tthis.trigger('changed', { 'action': 'select_all', 'selected': this._data.core.selected, 'old_selection': tmp });\n\t\t\t}\n\t\t},\n\t\t/**\n   * deselect all selected nodes\n   * @name deselect_all([supress_event])\n   * @param {Boolean} supress_event if set to `true` the `changed.jstree` event won't be triggered\n   * @trigger deselect_all.jstree, changed.jstree\n   */\n\t\tdeselect_all: function deselect_all(supress_event) {\n\t\t\tvar tmp = this._data.core.selected.concat([]),\n\t\t\t    i,\n\t\t\t    j;\n\t\t\tfor (i = 0, j = this._data.core.selected.length; i < j; i++) {\n\t\t\t\tif (this._model.data[this._data.core.selected[i]]) {\n\t\t\t\t\tthis._model.data[this._data.core.selected[i]].state.selected = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._data.core.selected = [];\n\t\t\tthis.element.find('.jstree-clicked').removeClass('jstree-clicked').parent().attr('aria-selected', false);\n\t\t\t/**\n    * triggered when all nodes are deselected\n    * @event\n    * @name deselect_all.jstree\n    * @param {Object} node the previous selection\n    * @param {Array} selected the current selection\n    */\n\t\t\tthis.trigger('deselect_all', { 'selected': this._data.core.selected, 'node': tmp });\n\t\t\tif (!supress_event) {\n\t\t\t\tthis.trigger('changed', { 'action': 'deselect_all', 'selected': this._data.core.selected, 'old_selection': tmp });\n\t\t\t}\n\t\t},\n\t\t/**\n   * checks if a node is selected\n   * @name is_selected(obj)\n   * @param  {mixed}  obj\n   * @return {Boolean}\n   */\n\t\tis_selected: function is_selected(obj) {\n\t\t\tobj = this.get_node(obj);\n\t\t\tif (!obj || obj.id === $.jstree.root) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn obj.state.selected;\n\t\t},\n\t\t/**\n   * get an array of all selected nodes\n   * @name get_selected([full])\n   * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned\n   * @return {Array}\n   */\n\t\tget_selected: function get_selected(full) {\n\t\t\treturn full ? $.map(this._data.core.selected, $.proxy(function (i) {\n\t\t\t\treturn this.get_node(i);\n\t\t\t}, this)) : this._data.core.selected.slice();\n\t\t},\n\t\t/**\n   * get an array of all top level selected nodes (ignoring children of selected nodes)\n   * @name get_top_selected([full])\n   * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned\n   * @return {Array}\n   */\n\t\tget_top_selected: function get_top_selected(full) {\n\t\t\tvar tmp = this.get_selected(true),\n\t\t\t    obj = {},\n\t\t\t    i,\n\t\t\t    j,\n\t\t\t    k,\n\t\t\t    l;\n\t\t\tfor (i = 0, j = tmp.length; i < j; i++) {\n\t\t\t\tobj[tmp[i].id] = tmp[i];\n\t\t\t}\n\t\t\tfor (i = 0, j = tmp.length; i < j; i++) {\n\t\t\t\tfor (k = 0, l = tmp[i].children_d.length; k < l; k++) {\n\t\t\t\t\tif (obj[tmp[i].children_d[k]]) {\n\t\t\t\t\t\tdelete obj[tmp[i].children_d[k]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ttmp = [];\n\t\t\tfor (i in obj) {\n\t\t\t\tif (obj.hasOwnProperty(i)) {\n\t\t\t\t\ttmp.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn full ? $.map(tmp, $.proxy(function (i) {\n\t\t\t\treturn this.get_node(i);\n\t\t\t}, this)) : tmp;\n\t\t},\n\t\t/**\n   * get an array of all bottom level selected nodes (ignoring selected parents)\n   * @name get_bottom_selected([full])\n   * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned\n   * @return {Array}\n   */\n\t\tget_bottom_selected: function get_bottom_selected(full) {\n\t\t\tvar tmp = this.get_selected(true),\n\t\t\t    obj = [],\n\t\t\t    i,\n\t\t\t    j;\n\t\t\tfor (i = 0, j = tmp.length; i < j; i++) {\n\t\t\t\tif (!tmp[i].children.length) {\n\t\t\t\t\tobj.push(tmp[i].id);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn full ? $.map(obj, $.proxy(function (i) {\n\t\t\t\treturn this.get_node(i);\n\t\t\t}, this)) : obj;\n\t\t},\n\t\t/**\n   * gets the current state of the tree so that it can be restored later with `set_state(state)`. Used internally.\n   * @name get_state()\n   * @private\n   * @return {Object}\n   */\n\t\tget_state: function get_state() {\n\t\t\tvar state = {\n\t\t\t\t'core': {\n\t\t\t\t\t'open': [],\n\t\t\t\t\t'scroll': {\n\t\t\t\t\t\t'left': this.element.scrollLeft(),\n\t\t\t\t\t\t'top': this.element.scrollTop()\n\t\t\t\t\t},\n\t\t\t\t\t/*!\n     'themes' : {\n     \t'name' : this.get_theme(),\n     \t'icons' : this._data.core.themes.icons,\n     \t'dots' : this._data.core.themes.dots\n     },\n     */\n\t\t\t\t\t'selected': []\n\t\t\t\t}\n\t\t\t},\n\t\t\t    i;\n\t\t\tfor (i in this._model.data) {\n\t\t\t\tif (this._model.data.hasOwnProperty(i)) {\n\t\t\t\t\tif (i !== $.jstree.root) {\n\t\t\t\t\t\tif (this._model.data[i].state.opened) {\n\t\t\t\t\t\t\tstate.core.open.push(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (this._model.data[i].state.selected) {\n\t\t\t\t\t\t\tstate.core.selected.push(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn state;\n\t\t},\n\t\t/**\n   * sets the state of the tree. Used internally.\n   * @name set_state(state [, callback])\n   * @private\n   * @param {Object} state the state to restore. Keep in mind this object is passed by reference and jstree will modify it.\n   * @param {Function} callback an optional function to execute once the state is restored.\n   * @trigger set_state.jstree\n   */\n\t\tset_state: function set_state(state, callback) {\n\t\t\tif (state) {\n\t\t\t\tif (state.core) {\n\t\t\t\t\tvar res, n, t, _this, i;\n\t\t\t\t\tif (state.core.open) {\n\t\t\t\t\t\tif (!$.isArray(state.core.open) || !state.core.open.length) {\n\t\t\t\t\t\t\tdelete state.core.open;\n\t\t\t\t\t\t\tthis.set_state(state, callback);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis._load_nodes(state.core.open, function (nodes) {\n\t\t\t\t\t\t\t\tthis.open_node(nodes, false, 0);\n\t\t\t\t\t\t\t\tdelete state.core.open;\n\t\t\t\t\t\t\t\tthis.set_state(state, callback);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tif (state.core.scroll) {\n\t\t\t\t\t\tif (state.core.scroll && state.core.scroll.left !== undefined) {\n\t\t\t\t\t\t\tthis.element.scrollLeft(state.core.scroll.left);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (state.core.scroll && state.core.scroll.top !== undefined) {\n\t\t\t\t\t\t\tthis.element.scrollTop(state.core.scroll.top);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdelete state.core.scroll;\n\t\t\t\t\t\tthis.set_state(state, callback);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tif (state.core.selected) {\n\t\t\t\t\t\t_this = this;\n\t\t\t\t\t\tthis.deselect_all();\n\t\t\t\t\t\t$.each(state.core.selected, function (i, v) {\n\t\t\t\t\t\t\t_this.select_node(v, false, true);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tdelete state.core.selected;\n\t\t\t\t\t\tthis.set_state(state, callback);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tfor (i in state) {\n\t\t\t\t\t\tif (state.hasOwnProperty(i) && i !== \"core\" && $.inArray(i, this.settings.plugins) === -1) {\n\t\t\t\t\t\t\tdelete state[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ($.isEmptyObject(state.core)) {\n\t\t\t\t\t\tdelete state.core;\n\t\t\t\t\t\tthis.set_state(state, callback);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ($.isEmptyObject(state)) {\n\t\t\t\t\tstate = null;\n\t\t\t\t\tif (callback) {\n\t\t\t\t\t\tcallback.call(this);\n\t\t\t\t\t}\n\t\t\t\t\t/**\n      * triggered when a `set_state` call completes\n      * @event\n      * @name set_state.jstree\n      */\n\t\t\t\t\tthis.trigger('set_state');\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t\t/**\n   * refreshes the tree - all nodes are reloaded with calls to `load_node`.\n   * @name refresh()\n   * @param {Boolean} skip_loading an option to skip showing the loading indicator\n   * @param {Mixed} forget_state if set to `true` state will not be reapplied, if set to a function (receiving the current state as argument) the result of that function will be used as state\n   * @trigger refresh.jstree\n   */\n\t\trefresh: function refresh(skip_loading, forget_state) {\n\t\t\tthis._data.core.state = forget_state === true ? {} : this.get_state();\n\t\t\tif (forget_state && $.isFunction(forget_state)) {\n\t\t\t\tthis._data.core.state = forget_state.call(this, this._data.core.state);\n\t\t\t}\n\t\t\tthis._cnt = 0;\n\t\t\tthis._model.data = {};\n\t\t\tthis._model.data[$.jstree.root] = {\n\t\t\t\tid: $.jstree.root,\n\t\t\t\tparent: null,\n\t\t\t\tparents: [],\n\t\t\t\tchildren: [],\n\t\t\t\tchildren_d: [],\n\t\t\t\tstate: { loaded: false }\n\t\t\t};\n\t\t\tthis._data.core.selected = [];\n\t\t\tthis._data.core.last_clicked = null;\n\t\t\tthis._data.core.focused = null;\n\n\t\t\tvar c = this.get_container_ul()[0].className;\n\t\t\tif (!skip_loading) {\n\t\t\t\tthis.element.html(\"<\" + \"ul class='\" + c + \"' role='group'><\" + \"li class='jstree-initial-node jstree-loading jstree-leaf jstree-last' role='treeitem' id='j\" + this._id + \"_loading'><i class='jstree-icon jstree-ocl'></i><\" + \"a class='jstree-anchor' href='#'><i class='jstree-icon jstree-themeicon-hidden'></i>\" + this.get_string(\"Loading ...\") + \"</a></li></ul>\");\n\t\t\t\tthis.element.attr('aria-activedescendant', 'j' + this._id + '_loading');\n\t\t\t}\n\t\t\tthis.load_node($.jstree.root, function (o, s) {\n\t\t\t\tif (s) {\n\t\t\t\t\tthis.get_container_ul()[0].className = c;\n\t\t\t\t\tif (this._firstChild(this.get_container_ul()[0])) {\n\t\t\t\t\t\tthis.element.attr('aria-activedescendant', this._firstChild(this.get_container_ul()[0]).id);\n\t\t\t\t\t}\n\t\t\t\t\tthis.set_state($.extend(true, {}, this._data.core.state), function () {\n\t\t\t\t\t\t/**\n       * triggered when a `refresh` call completes\n       * @event\n       * @name refresh.jstree\n       */\n\t\t\t\t\t\tthis.trigger('refresh');\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tthis._data.core.state = null;\n\t\t\t});\n\t\t},\n\t\t/**\n   * refreshes a node in the tree (reload its children) all opened nodes inside that node are reloaded with calls to `load_node`.\n   * @name refresh_node(obj)\n   * @param  {mixed} obj the node\n   * @trigger refresh_node.jstree\n   */\n\t\trefresh_node: function refresh_node(obj) {\n\t\t\tobj = this.get_node(obj);\n\t\t\tif (!obj || obj.id === $.jstree.root) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar opened = [],\n\t\t\t    to_load = [],\n\t\t\t    s = this._data.core.selected.concat([]);\n\t\t\tto_load.push(obj.id);\n\t\t\tif (obj.state.opened === true) {\n\t\t\t\topened.push(obj.id);\n\t\t\t}\n\t\t\tthis.get_node(obj, true).find('.jstree-open').each(function () {\n\t\t\t\tto_load.push(this.id);opened.push(this.id);\n\t\t\t});\n\t\t\tthis._load_nodes(to_load, $.proxy(function (nodes) {\n\t\t\t\tthis.open_node(opened, false, 0);\n\t\t\t\tthis.select_node(s);\n\t\t\t\t/**\n     * triggered when a node is refreshed\n     * @event\n     * @name refresh_node.jstree\n     * @param {Object} node - the refreshed node\n     * @param {Array} nodes - an array of the IDs of the nodes that were reloaded\n     */\n\t\t\t\tthis.trigger('refresh_node', { 'node': obj, 'nodes': nodes });\n\t\t\t}, this), false, true);\n\t\t},\n\t\t/**\n   * set (change) the ID of a node\n   * @name set_id(obj, id)\n   * @param  {mixed} obj the node\n   * @param  {String} id the new ID\n   * @return {Boolean}\n   * @trigger set_id.jstree\n   */\n\t\tset_id: function set_id(obj, id) {\n\t\t\tobj = this.get_node(obj);\n\t\t\tif (!obj || obj.id === $.jstree.root) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar i,\n\t\t\t    j,\n\t\t\t    m = this._model.data,\n\t\t\t    old = obj.id;\n\t\t\tid = id.toString();\n\t\t\t// update parents (replace current ID with new one in children and children_d)\n\t\t\tm[obj.parent].children[$.inArray(obj.id, m[obj.parent].children)] = id;\n\t\t\tfor (i = 0, j = obj.parents.length; i < j; i++) {\n\t\t\t\tm[obj.parents[i]].children_d[$.inArray(obj.id, m[obj.parents[i]].children_d)] = id;\n\t\t\t}\n\t\t\t// update children (replace current ID with new one in parent and parents)\n\t\t\tfor (i = 0, j = obj.children.length; i < j; i++) {\n\t\t\t\tm[obj.children[i]].parent = id;\n\t\t\t}\n\t\t\tfor (i = 0, j = obj.children_d.length; i < j; i++) {\n\t\t\t\tm[obj.children_d[i]].parents[$.inArray(obj.id, m[obj.children_d[i]].parents)] = id;\n\t\t\t}\n\t\t\ti = $.inArray(obj.id, this._data.core.selected);\n\t\t\tif (i !== -1) {\n\t\t\t\tthis._data.core.selected[i] = id;\n\t\t\t}\n\t\t\t// update model and obj itself (obj.id, this._model.data[KEY])\n\t\t\ti = this.get_node(obj.id, true);\n\t\t\tif (i) {\n\t\t\t\ti.attr('id', id); //.children('.jstree-anchor').attr('id', id + '_anchor').end().attr('aria-labelledby', id + '_anchor');\n\t\t\t\tif (this.element.attr('aria-activedescendant') === obj.id) {\n\t\t\t\t\tthis.element.attr('aria-activedescendant', id);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdelete m[obj.id];\n\t\t\tobj.id = id;\n\t\t\tobj.li_attr.id = id;\n\t\t\tm[id] = obj;\n\t\t\t/**\n    * triggered when a node id value is changed\n    * @event\n    * @name set_id.jstree\n    * @param {Object} node\n    * @param {String} old the old id\n    */\n\t\t\tthis.trigger('set_id', { \"node\": obj, \"new\": obj.id, \"old\": old });\n\t\t\treturn true;\n\t\t},\n\t\t/**\n   * get the text value of a node\n   * @name get_text(obj)\n   * @param  {mixed} obj the node\n   * @return {String}\n   */\n\t\tget_text: function get_text(obj) {\n\t\t\tobj = this.get_node(obj);\n\t\t\treturn !obj || obj.id === $.jstree.root ? false : obj.text;\n\t\t},\n\t\t/**\n   * set the text value of a node. Used internally, please use `rename_node(obj, val)`.\n   * @private\n   * @name set_text(obj, val)\n   * @param  {mixed} obj the node, you can pass an array to set the text on multiple nodes\n   * @param  {String} val the new text value\n   * @return {Boolean}\n   * @trigger set_text.jstree\n   */\n\t\tset_text: function set_text(obj, val) {\n\t\t\tvar t1, t2;\n\t\t\tif ($.isArray(obj)) {\n\t\t\t\tobj = obj.slice();\n\t\t\t\tfor (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n\t\t\t\t\tthis.set_text(obj[t1], val);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tobj = this.get_node(obj);\n\t\t\tif (!obj || obj.id === $.jstree.root) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tobj.text = val;\n\t\t\tif (this.get_node(obj, true).length) {\n\t\t\t\tthis.redraw_node(obj.id);\n\t\t\t}\n\t\t\t/**\n    * triggered when a node text value is changed\n    * @event\n    * @name set_text.jstree\n    * @param {Object} obj\n    * @param {String} text the new value\n    */\n\t\t\tthis.trigger('set_text', { \"obj\": obj, \"text\": val });\n\t\t\treturn true;\n\t\t},\n\t\t/**\n   * gets a JSON representation of a node (or the whole tree)\n   * @name get_json([obj, options])\n   * @param  {mixed} obj\n   * @param  {Object} options\n   * @param  {Boolean} options.no_state do not return state information\n   * @param  {Boolean} options.no_id do not return ID\n   * @param  {Boolean} options.no_children do not include children\n   * @param  {Boolean} options.no_data do not include node data\n   * @param  {Boolean} options.no_li_attr do not include LI attributes\n   * @param  {Boolean} options.no_a_attr do not include A attributes\n   * @param  {Boolean} options.flat return flat JSON instead of nested\n   * @return {Object}\n   */\n\t\tget_json: function get_json(obj, options, flat) {\n\t\t\tobj = this.get_node(obj || $.jstree.root);\n\t\t\tif (!obj) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (options && options.flat && !flat) {\n\t\t\t\tflat = [];\n\t\t\t}\n\t\t\tvar tmp = {\n\t\t\t\t'id': obj.id,\n\t\t\t\t'text': obj.text,\n\t\t\t\t'icon': this.get_icon(obj),\n\t\t\t\t'li_attr': $.extend(true, {}, obj.li_attr),\n\t\t\t\t'a_attr': $.extend(true, {}, obj.a_attr),\n\t\t\t\t'state': {},\n\t\t\t\t'data': options && options.no_data ? false : $.extend(true, {}, obj.data)\n\t\t\t\t//( this.get_node(obj, true).length ? this.get_node(obj, true).data() : obj.data ),\n\t\t\t},\n\t\t\t    i,\n\t\t\t    j;\n\t\t\tif (options && options.flat) {\n\t\t\t\ttmp.parent = obj.parent;\n\t\t\t} else {\n\t\t\t\ttmp.children = [];\n\t\t\t}\n\t\t\tif (!options || !options.no_state) {\n\t\t\t\tfor (i in obj.state) {\n\t\t\t\t\tif (obj.state.hasOwnProperty(i)) {\n\t\t\t\t\t\ttmp.state[i] = obj.state[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdelete tmp.state;\n\t\t\t}\n\t\t\tif (options && options.no_li_attr) {\n\t\t\t\tdelete tmp.li_attr;\n\t\t\t}\n\t\t\tif (options && options.no_a_attr) {\n\t\t\t\tdelete tmp.a_attr;\n\t\t\t}\n\t\t\tif (options && options.no_id) {\n\t\t\t\tdelete tmp.id;\n\t\t\t\tif (tmp.li_attr && tmp.li_attr.id) {\n\t\t\t\t\tdelete tmp.li_attr.id;\n\t\t\t\t}\n\t\t\t\tif (tmp.a_attr && tmp.a_attr.id) {\n\t\t\t\t\tdelete tmp.a_attr.id;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (options && options.flat && obj.id !== $.jstree.root) {\n\t\t\t\tflat.push(tmp);\n\t\t\t}\n\t\t\tif (!options || !options.no_children) {\n\t\t\t\tfor (i = 0, j = obj.children.length; i < j; i++) {\n\t\t\t\t\tif (options && options.flat) {\n\t\t\t\t\t\tthis.get_json(obj.children[i], options, flat);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttmp.children.push(this.get_json(obj.children[i], options));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn options && options.flat ? flat : obj.id === $.jstree.root ? tmp.children : tmp;\n\t\t},\n\t\t/**\n   * create a new node (do not confuse with load_node)\n   * @name create_node([par, node, pos, callback, is_loaded])\n   * @param  {mixed}   par       the parent node (to create a root node use either \"#\" (string) or `null`)\n   * @param  {mixed}   node      the data for the new node (a valid JSON object, or a simple string with the name)\n   * @param  {mixed}   pos       the index at which to insert the node, \"first\" and \"last\" are also supported, default is \"last\"\n   * @param  {Function} callback a function to be called once the node is created\n   * @param  {Boolean} is_loaded internal argument indicating if the parent node was succesfully loaded\n   * @return {String}            the ID of the newly create node\n   * @trigger model.jstree, create_node.jstree\n   */\n\t\tcreate_node: function create_node(par, node, pos, callback, is_loaded) {\n\t\t\tif (par === null) {\n\t\t\t\tpar = $.jstree.root;\n\t\t\t}\n\t\t\tpar = this.get_node(par);\n\t\t\tif (!par) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tpos = pos === undefined ? \"last\" : pos;\n\t\t\tif (!pos.toString().match(/^(before|after)$/) && !is_loaded && !this.is_loaded(par)) {\n\t\t\t\treturn this.load_node(par, function () {\n\t\t\t\t\tthis.create_node(par, node, pos, callback, true);\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (!node) {\n\t\t\t\tnode = { \"text\": this.get_string('New node') };\n\t\t\t}\n\t\t\tif (typeof node === \"string\") {\n\t\t\t\tnode = { \"text\": node };\n\t\t\t}\n\t\t\tif (node.text === undefined) {\n\t\t\t\tnode.text = this.get_string('New node');\n\t\t\t}\n\t\t\tvar tmp, dpc, i, j;\n\n\t\t\tif (par.id === $.jstree.root) {\n\t\t\t\tif (pos === \"before\") {\n\t\t\t\t\tpos = \"first\";\n\t\t\t\t}\n\t\t\t\tif (pos === \"after\") {\n\t\t\t\t\tpos = \"last\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tswitch (pos) {\n\t\t\t\tcase \"before\":\n\t\t\t\t\ttmp = this.get_node(par.parent);\n\t\t\t\t\tpos = $.inArray(par.id, tmp.children);\n\t\t\t\t\tpar = tmp;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"after\":\n\t\t\t\t\ttmp = this.get_node(par.parent);\n\t\t\t\t\tpos = $.inArray(par.id, tmp.children) + 1;\n\t\t\t\t\tpar = tmp;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"inside\":\n\t\t\t\tcase \"first\":\n\t\t\t\t\tpos = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"last\":\n\t\t\t\t\tpos = par.children.length;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (!pos) {\n\t\t\t\t\t\tpos = 0;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (pos > par.children.length) {\n\t\t\t\tpos = par.children.length;\n\t\t\t}\n\t\t\tif (!node.id) {\n\t\t\t\tnode.id = true;\n\t\t\t}\n\t\t\tif (!this.check(\"create_node\", node, par, pos)) {\n\t\t\t\tthis.settings.core.error.call(this, this._data.core.last_error);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (node.id === true) {\n\t\t\t\tdelete node.id;\n\t\t\t}\n\t\t\tnode = this._parse_model_from_json(node, par.id, par.parents.concat());\n\t\t\tif (!node) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ttmp = this.get_node(node);\n\t\t\tdpc = [];\n\t\t\tdpc.push(node);\n\t\t\tdpc = dpc.concat(tmp.children_d);\n\t\t\tthis.trigger('model', { \"nodes\": dpc, \"parent\": par.id });\n\n\t\t\tpar.children_d = par.children_d.concat(dpc);\n\t\t\tfor (i = 0, j = par.parents.length; i < j; i++) {\n\t\t\t\tthis._model.data[par.parents[i]].children_d = this._model.data[par.parents[i]].children_d.concat(dpc);\n\t\t\t}\n\t\t\tnode = tmp;\n\t\t\ttmp = [];\n\t\t\tfor (i = 0, j = par.children.length; i < j; i++) {\n\t\t\t\ttmp[i >= pos ? i + 1 : i] = par.children[i];\n\t\t\t}\n\t\t\ttmp[pos] = node.id;\n\t\t\tpar.children = tmp;\n\n\t\t\tthis.redraw_node(par, true);\n\t\t\tif (callback) {\n\t\t\t\tcallback.call(this, this.get_node(node));\n\t\t\t}\n\t\t\t/**\n    * triggered when a node is created\n    * @event\n    * @name create_node.jstree\n    * @param {Object} node\n    * @param {String} parent the parent's ID\n    * @param {Number} position the position of the new node among the parent's children\n    */\n\t\t\tthis.trigger('create_node', { \"node\": this.get_node(node), \"parent\": par.id, \"position\": pos });\n\t\t\treturn node.id;\n\t\t},\n\t\t/**\n   * set the text value of a node\n   * @name rename_node(obj, val)\n   * @param  {mixed} obj the node, you can pass an array to rename multiple nodes to the same name\n   * @param  {String} val the new text value\n   * @return {Boolean}\n   * @trigger rename_node.jstree\n   */\n\t\trename_node: function rename_node(obj, val) {\n\t\t\tvar t1, t2, old;\n\t\t\tif ($.isArray(obj)) {\n\t\t\t\tobj = obj.slice();\n\t\t\t\tfor (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n\t\t\t\t\tthis.rename_node(obj[t1], val);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tobj = this.get_node(obj);\n\t\t\tif (!obj || obj.id === $.jstree.root) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\told = obj.text;\n\t\t\tif (!this.check(\"rename_node\", obj, this.get_parent(obj), val)) {\n\t\t\t\tthis.settings.core.error.call(this, this._data.core.last_error);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tthis.set_text(obj, val); // .apply(this, Array.prototype.slice.call(arguments))\n\t\t\t/**\n    * triggered when a node is renamed\n    * @event\n    * @name rename_node.jstree\n    * @param {Object} node\n    * @param {String} text the new value\n    * @param {String} old the old value\n    */\n\t\t\tthis.trigger('rename_node', { \"node\": obj, \"text\": val, \"old\": old });\n\t\t\treturn true;\n\t\t},\n\t\t/**\n   * remove a node\n   * @name delete_node(obj)\n   * @param  {mixed} obj the node, you can pass an array to delete multiple nodes\n   * @return {Boolean}\n   * @trigger delete_node.jstree, changed.jstree\n   */\n\t\tdelete_node: function delete_node(obj) {\n\t\t\tvar t1, t2, par, pos, tmp, i, j, k, l, c, top, lft;\n\t\t\tif ($.isArray(obj)) {\n\t\t\t\tobj = obj.slice();\n\t\t\t\tfor (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n\t\t\t\t\tthis.delete_node(obj[t1]);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tobj = this.get_node(obj);\n\t\t\tif (!obj || obj.id === $.jstree.root) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tpar = this.get_node(obj.parent);\n\t\t\tpos = $.inArray(obj.id, par.children);\n\t\t\tc = false;\n\t\t\tif (!this.check(\"delete_node\", obj, par, pos)) {\n\t\t\t\tthis.settings.core.error.call(this, this._data.core.last_error);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (pos !== -1) {\n\t\t\t\tpar.children = $.vakata.array_remove(par.children, pos);\n\t\t\t}\n\t\t\ttmp = obj.children_d.concat([]);\n\t\t\ttmp.push(obj.id);\n\t\t\tfor (i = 0, j = obj.parents.length; i < j; i++) {\n\t\t\t\tthis._model.data[obj.parents[i]].children_d = $.vakata.array_filter(this._model.data[obj.parents[i]].children_d, function (v) {\n\t\t\t\t\treturn $.inArray(v, tmp) === -1;\n\t\t\t\t});\n\t\t\t}\n\t\t\tfor (k = 0, l = tmp.length; k < l; k++) {\n\t\t\t\tif (this._model.data[tmp[k]].state.selected) {\n\t\t\t\t\tc = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (c) {\n\t\t\t\tthis._data.core.selected = $.vakata.array_filter(this._data.core.selected, function (v) {\n\t\t\t\t\treturn $.inArray(v, tmp) === -1;\n\t\t\t\t});\n\t\t\t}\n\t\t\t/**\n    * triggered when a node is deleted\n    * @event\n    * @name delete_node.jstree\n    * @param {Object} node\n    * @param {String} parent the parent's ID\n    */\n\t\t\tthis.trigger('delete_node', { \"node\": obj, \"parent\": par.id });\n\t\t\tif (c) {\n\t\t\t\tthis.trigger('changed', { 'action': 'delete_node', 'node': obj, 'selected': this._data.core.selected, 'parent': par.id });\n\t\t\t}\n\t\t\tfor (k = 0, l = tmp.length; k < l; k++) {\n\t\t\t\tdelete this._model.data[tmp[k]];\n\t\t\t}\n\t\t\tif ($.inArray(this._data.core.focused, tmp) !== -1) {\n\t\t\t\tthis._data.core.focused = null;\n\t\t\t\ttop = this.element[0].scrollTop;\n\t\t\t\tlft = this.element[0].scrollLeft;\n\t\t\t\tif (par.id === $.jstree.root) {\n\t\t\t\t\tif (this._model.data[$.jstree.root].children[0]) {\n\t\t\t\t\t\tthis.get_node(this._model.data[$.jstree.root].children[0], true).children('.jstree-anchor').focus();\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis.get_node(par, true).children('.jstree-anchor').focus();\n\t\t\t\t}\n\t\t\t\tthis.element[0].scrollTop = top;\n\t\t\t\tthis.element[0].scrollLeft = lft;\n\t\t\t}\n\t\t\tthis.redraw_node(par, true);\n\t\t\treturn true;\n\t\t},\n\t\t/**\n   * check if an operation is premitted on the tree. Used internally.\n   * @private\n   * @name check(chk, obj, par, pos)\n   * @param  {String} chk the operation to check, can be \"create_node\", \"rename_node\", \"delete_node\", \"copy_node\" or \"move_node\"\n   * @param  {mixed} obj the node\n   * @param  {mixed} par the parent\n   * @param  {mixed} pos the position to insert at, or if \"rename_node\" - the new name\n   * @param  {mixed} more some various additional information, for example if a \"move_node\" operations is triggered by DND this will be the hovered node\n   * @return {Boolean}\n   */\n\t\tcheck: function check(chk, obj, par, pos, more) {\n\t\t\tobj = obj && obj.id ? obj : this.get_node(obj);\n\t\t\tpar = par && par.id ? par : this.get_node(par);\n\t\t\tvar tmp = chk.match(/^move_node|copy_node|create_node$/i) ? par : obj,\n\t\t\t    chc = this.settings.core.check_callback;\n\t\t\tif (chk === \"move_node\" || chk === \"copy_node\") {\n\t\t\t\tif ((!more || !more.is_multi) && (obj.id === par.id || chk === \"move_node\" && $.inArray(obj.id, par.children) === pos || $.inArray(par.id, obj.children_d) !== -1)) {\n\t\t\t\t\tthis._data.core.last_error = { 'error': 'check', 'plugin': 'core', 'id': 'core_01', 'reason': 'Moving parent inside child', 'data': JSON.stringify({ 'chk': chk, 'pos': pos, 'obj': obj && obj.id ? obj.id : false, 'par': par && par.id ? par.id : false }) };\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tmp && tmp.data) {\n\t\t\t\ttmp = tmp.data;\n\t\t\t}\n\t\t\tif (tmp && tmp.functions && (tmp.functions[chk] === false || tmp.functions[chk] === true)) {\n\t\t\t\tif (tmp.functions[chk] === false) {\n\t\t\t\t\tthis._data.core.last_error = { 'error': 'check', 'plugin': 'core', 'id': 'core_02', 'reason': 'Node data prevents function: ' + chk, 'data': JSON.stringify({ 'chk': chk, 'pos': pos, 'obj': obj && obj.id ? obj.id : false, 'par': par && par.id ? par.id : false }) };\n\t\t\t\t}\n\t\t\t\treturn tmp.functions[chk];\n\t\t\t}\n\t\t\tif (chc === false || $.isFunction(chc) && chc.call(this, chk, obj, par, pos, more) === false || chc && chc[chk] === false) {\n\t\t\t\tthis._data.core.last_error = { 'error': 'check', 'plugin': 'core', 'id': 'core_03', 'reason': 'User config for core.check_callback prevents function: ' + chk, 'data': JSON.stringify({ 'chk': chk, 'pos': pos, 'obj': obj && obj.id ? obj.id : false, 'par': par && par.id ? par.id : false }) };\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\t\t/**\n   * get the last error\n   * @name last_error()\n   * @return {Object}\n   */\n\t\tlast_error: function last_error() {\n\t\t\treturn this._data.core.last_error;\n\t\t},\n\t\t/**\n   * move a node to a new parent\n   * @name move_node(obj, par [, pos, callback, is_loaded])\n   * @param  {mixed} obj the node to move, pass an array to move multiple nodes\n   * @param  {mixed} par the new parent\n   * @param  {mixed} pos the position to insert at (besides integer values, \"first\" and \"last\" are supported, as well as \"before\" and \"after\"), defaults to integer `0`\n   * @param  {function} callback a function to call once the move is completed, receives 3 arguments - the node, the new parent and the position\n   * @param  {Boolean} is_loaded internal parameter indicating if the parent node has been loaded\n   * @param  {Boolean} skip_redraw internal parameter indicating if the tree should be redrawn\n   * @param  {Boolean} instance internal parameter indicating if the node comes from another instance\n   * @trigger move_node.jstree\n   */\n\t\tmove_node: function move_node(obj, par, pos, callback, is_loaded, skip_redraw, origin) {\n\t\t\tvar t1, t2, old_par, old_pos, new_par, old_ins, is_multi, dpc, tmp, i, j, k, l, p;\n\n\t\t\tpar = this.get_node(par);\n\t\t\tpos = pos === undefined ? 0 : pos;\n\t\t\tif (!par) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!pos.toString().match(/^(before|after)$/) && !is_loaded && !this.is_loaded(par)) {\n\t\t\t\treturn this.load_node(par, function () {\n\t\t\t\t\tthis.move_node(obj, par, pos, callback, true, false, origin);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif ($.isArray(obj)) {\n\t\t\t\tif (obj.length === 1) {\n\t\t\t\t\tobj = obj[0];\n\t\t\t\t} else {\n\t\t\t\t\t//obj = obj.slice();\n\t\t\t\t\tfor (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n\t\t\t\t\t\tif (tmp = this.move_node(obj[t1], par, pos, callback, is_loaded, false, origin)) {\n\t\t\t\t\t\t\tpar = tmp;\n\t\t\t\t\t\t\tpos = \"after\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis.redraw();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tobj = obj && obj.id ? obj : this.get_node(obj);\n\n\t\t\tif (!obj || obj.id === $.jstree.root) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\told_par = (obj.parent || $.jstree.root).toString();\n\t\t\tnew_par = !pos.toString().match(/^(before|after)$/) || par.id === $.jstree.root ? par : this.get_node(par.parent);\n\t\t\told_ins = origin ? origin : this._model.data[obj.id] ? this : $.jstree.reference(obj.id);\n\t\t\tis_multi = !old_ins || !old_ins._id || this._id !== old_ins._id;\n\t\t\told_pos = old_ins && old_ins._id && old_par && old_ins._model.data[old_par] && old_ins._model.data[old_par].children ? $.inArray(obj.id, old_ins._model.data[old_par].children) : -1;\n\t\t\tif (old_ins && old_ins._id) {\n\t\t\t\tobj = old_ins._model.data[obj.id];\n\t\t\t}\n\n\t\t\tif (is_multi) {\n\t\t\t\tif (tmp = this.copy_node(obj, par, pos, callback, is_loaded, false, origin)) {\n\t\t\t\t\tif (old_ins) {\n\t\t\t\t\t\told_ins.delete_node(obj);\n\t\t\t\t\t}\n\t\t\t\t\treturn tmp;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t//var m = this._model.data;\n\t\t\tif (par.id === $.jstree.root) {\n\t\t\t\tif (pos === \"before\") {\n\t\t\t\t\tpos = \"first\";\n\t\t\t\t}\n\t\t\t\tif (pos === \"after\") {\n\t\t\t\t\tpos = \"last\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tswitch (pos) {\n\t\t\t\tcase \"before\":\n\t\t\t\t\tpos = $.inArray(par.id, new_par.children);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"after\":\n\t\t\t\t\tpos = $.inArray(par.id, new_par.children) + 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"inside\":\n\t\t\t\tcase \"first\":\n\t\t\t\t\tpos = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"last\":\n\t\t\t\t\tpos = new_par.children.length;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (!pos) {\n\t\t\t\t\t\tpos = 0;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (pos > new_par.children.length) {\n\t\t\t\tpos = new_par.children.length;\n\t\t\t}\n\t\t\tif (!this.check(\"move_node\", obj, new_par, pos, { 'core': true, 'origin': origin, 'is_multi': old_ins && old_ins._id && old_ins._id !== this._id, 'is_foreign': !old_ins || !old_ins._id })) {\n\t\t\t\tthis.settings.core.error.call(this, this._data.core.last_error);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (obj.parent === new_par.id) {\n\t\t\t\tdpc = new_par.children.concat();\n\t\t\t\ttmp = $.inArray(obj.id, dpc);\n\t\t\t\tif (tmp !== -1) {\n\t\t\t\t\tdpc = $.vakata.array_remove(dpc, tmp);\n\t\t\t\t\tif (pos > tmp) {\n\t\t\t\t\t\tpos--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp = [];\n\t\t\t\tfor (i = 0, j = dpc.length; i < j; i++) {\n\t\t\t\t\ttmp[i >= pos ? i + 1 : i] = dpc[i];\n\t\t\t\t}\n\t\t\t\ttmp[pos] = obj.id;\n\t\t\t\tnew_par.children = tmp;\n\t\t\t\tthis._node_changed(new_par.id);\n\t\t\t\tthis.redraw(new_par.id === $.jstree.root);\n\t\t\t} else {\n\t\t\t\t// clean old parent and up\n\t\t\t\ttmp = obj.children_d.concat();\n\t\t\t\ttmp.push(obj.id);\n\t\t\t\tfor (i = 0, j = obj.parents.length; i < j; i++) {\n\t\t\t\t\tdpc = [];\n\t\t\t\t\tp = old_ins._model.data[obj.parents[i]].children_d;\n\t\t\t\t\tfor (k = 0, l = p.length; k < l; k++) {\n\t\t\t\t\t\tif ($.inArray(p[k], tmp) === -1) {\n\t\t\t\t\t\t\tdpc.push(p[k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\told_ins._model.data[obj.parents[i]].children_d = dpc;\n\t\t\t\t}\n\t\t\t\told_ins._model.data[old_par].children = $.vakata.array_remove_item(old_ins._model.data[old_par].children, obj.id);\n\n\t\t\t\t// insert into new parent and up\n\t\t\t\tfor (i = 0, j = new_par.parents.length; i < j; i++) {\n\t\t\t\t\tthis._model.data[new_par.parents[i]].children_d = this._model.data[new_par.parents[i]].children_d.concat(tmp);\n\t\t\t\t}\n\t\t\t\tdpc = [];\n\t\t\t\tfor (i = 0, j = new_par.children.length; i < j; i++) {\n\t\t\t\t\tdpc[i >= pos ? i + 1 : i] = new_par.children[i];\n\t\t\t\t}\n\t\t\t\tdpc[pos] = obj.id;\n\t\t\t\tnew_par.children = dpc;\n\t\t\t\tnew_par.children_d.push(obj.id);\n\t\t\t\tnew_par.children_d = new_par.children_d.concat(obj.children_d);\n\n\t\t\t\t// update object\n\t\t\t\tobj.parent = new_par.id;\n\t\t\t\ttmp = new_par.parents.concat();\n\t\t\t\ttmp.unshift(new_par.id);\n\t\t\t\tp = obj.parents.length;\n\t\t\t\tobj.parents = tmp;\n\n\t\t\t\t// update object children\n\t\t\t\ttmp = tmp.concat();\n\t\t\t\tfor (i = 0, j = obj.children_d.length; i < j; i++) {\n\t\t\t\t\tthis._model.data[obj.children_d[i]].parents = this._model.data[obj.children_d[i]].parents.slice(0, p * -1);\n\t\t\t\t\tArray.prototype.push.apply(this._model.data[obj.children_d[i]].parents, tmp);\n\t\t\t\t}\n\n\t\t\t\tif (old_par === $.jstree.root || new_par.id === $.jstree.root) {\n\t\t\t\t\tthis._model.force_full_redraw = true;\n\t\t\t\t}\n\t\t\t\tif (!this._model.force_full_redraw) {\n\t\t\t\t\tthis._node_changed(old_par);\n\t\t\t\t\tthis._node_changed(new_par.id);\n\t\t\t\t}\n\t\t\t\tif (!skip_redraw) {\n\t\t\t\t\tthis.redraw();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (callback) {\n\t\t\t\tcallback.call(this, obj, new_par, pos);\n\t\t\t}\n\t\t\t/**\n    * triggered when a node is moved\n    * @event\n    * @name move_node.jstree\n    * @param {Object} node\n    * @param {String} parent the parent's ID\n    * @param {Number} position the position of the node among the parent's children\n    * @param {String} old_parent the old parent of the node\n    * @param {Number} old_position the old position of the node\n    * @param {Boolean} is_multi do the node and new parent belong to different instances\n    * @param {jsTree} old_instance the instance the node came from\n    * @param {jsTree} new_instance the instance of the new parent\n    */\n\t\t\tthis.trigger('move_node', { \"node\": obj, \"parent\": new_par.id, \"position\": pos, \"old_parent\": old_par, \"old_position\": old_pos, 'is_multi': old_ins && old_ins._id && old_ins._id !== this._id, 'is_foreign': !old_ins || !old_ins._id, 'old_instance': old_ins, 'new_instance': this });\n\t\t\treturn obj.id;\n\t\t},\n\t\t/**\n   * copy a node to a new parent\n   * @name copy_node(obj, par [, pos, callback, is_loaded])\n   * @param  {mixed} obj the node to copy, pass an array to copy multiple nodes\n   * @param  {mixed} par the new parent\n   * @param  {mixed} pos the position to insert at (besides integer values, \"first\" and \"last\" are supported, as well as \"before\" and \"after\"), defaults to integer `0`\n   * @param  {function} callback a function to call once the move is completed, receives 3 arguments - the node, the new parent and the position\n   * @param  {Boolean} is_loaded internal parameter indicating if the parent node has been loaded\n   * @param  {Boolean} skip_redraw internal parameter indicating if the tree should be redrawn\n   * @param  {Boolean} instance internal parameter indicating if the node comes from another instance\n   * @trigger model.jstree copy_node.jstree\n   */\n\t\tcopy_node: function copy_node(obj, par, pos, callback, is_loaded, skip_redraw, origin) {\n\t\t\tvar t1, t2, dpc, tmp, i, j, node, old_par, new_par, old_ins, is_multi;\n\n\t\t\tpar = this.get_node(par);\n\t\t\tpos = pos === undefined ? 0 : pos;\n\t\t\tif (!par) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!pos.toString().match(/^(before|after)$/) && !is_loaded && !this.is_loaded(par)) {\n\t\t\t\treturn this.load_node(par, function () {\n\t\t\t\t\tthis.copy_node(obj, par, pos, callback, true, false, origin);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif ($.isArray(obj)) {\n\t\t\t\tif (obj.length === 1) {\n\t\t\t\t\tobj = obj[0];\n\t\t\t\t} else {\n\t\t\t\t\t//obj = obj.slice();\n\t\t\t\t\tfor (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n\t\t\t\t\t\tif (tmp = this.copy_node(obj[t1], par, pos, callback, is_loaded, true, origin)) {\n\t\t\t\t\t\t\tpar = tmp;\n\t\t\t\t\t\t\tpos = \"after\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis.redraw();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tobj = obj && obj.id ? obj : this.get_node(obj);\n\t\t\tif (!obj || obj.id === $.jstree.root) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\told_par = (obj.parent || $.jstree.root).toString();\n\t\t\tnew_par = !pos.toString().match(/^(before|after)$/) || par.id === $.jstree.root ? par : this.get_node(par.parent);\n\t\t\told_ins = origin ? origin : this._model.data[obj.id] ? this : $.jstree.reference(obj.id);\n\t\t\tis_multi = !old_ins || !old_ins._id || this._id !== old_ins._id;\n\n\t\t\tif (old_ins && old_ins._id) {\n\t\t\t\tobj = old_ins._model.data[obj.id];\n\t\t\t}\n\n\t\t\tif (par.id === $.jstree.root) {\n\t\t\t\tif (pos === \"before\") {\n\t\t\t\t\tpos = \"first\";\n\t\t\t\t}\n\t\t\t\tif (pos === \"after\") {\n\t\t\t\t\tpos = \"last\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tswitch (pos) {\n\t\t\t\tcase \"before\":\n\t\t\t\t\tpos = $.inArray(par.id, new_par.children);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"after\":\n\t\t\t\t\tpos = $.inArray(par.id, new_par.children) + 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"inside\":\n\t\t\t\tcase \"first\":\n\t\t\t\t\tpos = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"last\":\n\t\t\t\t\tpos = new_par.children.length;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (!pos) {\n\t\t\t\t\t\tpos = 0;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (pos > new_par.children.length) {\n\t\t\t\tpos = new_par.children.length;\n\t\t\t}\n\t\t\tif (!this.check(\"copy_node\", obj, new_par, pos, { 'core': true, 'origin': origin, 'is_multi': old_ins && old_ins._id && old_ins._id !== this._id, 'is_foreign': !old_ins || !old_ins._id })) {\n\t\t\t\tthis.settings.core.error.call(this, this._data.core.last_error);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tnode = old_ins ? old_ins.get_json(obj, { no_id: true, no_data: true, no_state: true }) : obj;\n\t\t\tif (!node) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (node.id === true) {\n\t\t\t\tdelete node.id;\n\t\t\t}\n\t\t\tnode = this._parse_model_from_json(node, new_par.id, new_par.parents.concat());\n\t\t\tif (!node) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ttmp = this.get_node(node);\n\t\t\tif (obj && obj.state && obj.state.loaded === false) {\n\t\t\t\ttmp.state.loaded = false;\n\t\t\t}\n\t\t\tdpc = [];\n\t\t\tdpc.push(node);\n\t\t\tdpc = dpc.concat(tmp.children_d);\n\t\t\tthis.trigger('model', { \"nodes\": dpc, \"parent\": new_par.id });\n\n\t\t\t// insert into new parent and up\n\t\t\tfor (i = 0, j = new_par.parents.length; i < j; i++) {\n\t\t\t\tthis._model.data[new_par.parents[i]].children_d = this._model.data[new_par.parents[i]].children_d.concat(dpc);\n\t\t\t}\n\t\t\tdpc = [];\n\t\t\tfor (i = 0, j = new_par.children.length; i < j; i++) {\n\t\t\t\tdpc[i >= pos ? i + 1 : i] = new_par.children[i];\n\t\t\t}\n\t\t\tdpc[pos] = tmp.id;\n\t\t\tnew_par.children = dpc;\n\t\t\tnew_par.children_d.push(tmp.id);\n\t\t\tnew_par.children_d = new_par.children_d.concat(tmp.children_d);\n\n\t\t\tif (new_par.id === $.jstree.root) {\n\t\t\t\tthis._model.force_full_redraw = true;\n\t\t\t}\n\t\t\tif (!this._model.force_full_redraw) {\n\t\t\t\tthis._node_changed(new_par.id);\n\t\t\t}\n\t\t\tif (!skip_redraw) {\n\t\t\t\tthis.redraw(new_par.id === $.jstree.root);\n\t\t\t}\n\t\t\tif (callback) {\n\t\t\t\tcallback.call(this, tmp, new_par, pos);\n\t\t\t}\n\t\t\t/**\n    * triggered when a node is copied\n    * @event\n    * @name copy_node.jstree\n    * @param {Object} node the copied node\n    * @param {Object} original the original node\n    * @param {String} parent the parent's ID\n    * @param {Number} position the position of the node among the parent's children\n    * @param {String} old_parent the old parent of the node\n    * @param {Number} old_position the position of the original node\n    * @param {Boolean} is_multi do the node and new parent belong to different instances\n    * @param {jsTree} old_instance the instance the node came from\n    * @param {jsTree} new_instance the instance of the new parent\n    */\n\t\t\tthis.trigger('copy_node', { \"node\": tmp, \"original\": obj, \"parent\": new_par.id, \"position\": pos, \"old_parent\": old_par, \"old_position\": old_ins && old_ins._id && old_par && old_ins._model.data[old_par] && old_ins._model.data[old_par].children ? $.inArray(obj.id, old_ins._model.data[old_par].children) : -1, 'is_multi': old_ins && old_ins._id && old_ins._id !== this._id, 'is_foreign': !old_ins || !old_ins._id, 'old_instance': old_ins, 'new_instance': this });\n\t\t\treturn tmp.id;\n\t\t},\n\t\t/**\n   * cut a node (a later call to `paste(obj)` would move the node)\n   * @name cut(obj)\n   * @param  {mixed} obj multiple objects can be passed using an array\n   * @trigger cut.jstree\n   */\n\t\tcut: function cut(obj) {\n\t\t\tif (!obj) {\n\t\t\t\tobj = this._data.core.selected.concat();\n\t\t\t}\n\t\t\tif (!$.isArray(obj)) {\n\t\t\t\tobj = [obj];\n\t\t\t}\n\t\t\tif (!obj.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar tmp = [],\n\t\t\t    o,\n\t\t\t    t1,\n\t\t\t    t2;\n\t\t\tfor (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n\t\t\t\to = this.get_node(obj[t1]);\n\t\t\t\tif (o && o.id && o.id !== $.jstree.root) {\n\t\t\t\t\ttmp.push(o);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!tmp.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tccp_node = tmp;\n\t\t\tccp_inst = this;\n\t\t\tccp_mode = 'move_node';\n\t\t\t/**\n    * triggered when nodes are added to the buffer for moving\n    * @event\n    * @name cut.jstree\n    * @param {Array} node\n    */\n\t\t\tthis.trigger('cut', { \"node\": obj });\n\t\t},\n\t\t/**\n   * copy a node (a later call to `paste(obj)` would copy the node)\n   * @name copy(obj)\n   * @param  {mixed} obj multiple objects can be passed using an array\n   * @trigger copy.jstree\n   */\n\t\tcopy: function copy(obj) {\n\t\t\tif (!obj) {\n\t\t\t\tobj = this._data.core.selected.concat();\n\t\t\t}\n\t\t\tif (!$.isArray(obj)) {\n\t\t\t\tobj = [obj];\n\t\t\t}\n\t\t\tif (!obj.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar tmp = [],\n\t\t\t    o,\n\t\t\t    t1,\n\t\t\t    t2;\n\t\t\tfor (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n\t\t\t\to = this.get_node(obj[t1]);\n\t\t\t\tif (o && o.id && o.id !== $.jstree.root) {\n\t\t\t\t\ttmp.push(o);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!tmp.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tccp_node = tmp;\n\t\t\tccp_inst = this;\n\t\t\tccp_mode = 'copy_node';\n\t\t\t/**\n    * triggered when nodes are added to the buffer for copying\n    * @event\n    * @name copy.jstree\n    * @param {Array} node\n    */\n\t\t\tthis.trigger('copy', { \"node\": obj });\n\t\t},\n\t\t/**\n   * get the current buffer (any nodes that are waiting for a paste operation)\n   * @name get_buffer()\n   * @return {Object} an object consisting of `mode` (\"copy_node\" or \"move_node\"), `node` (an array of objects) and `inst` (the instance)\n   */\n\t\tget_buffer: function get_buffer() {\n\t\t\treturn { 'mode': ccp_mode, 'node': ccp_node, 'inst': ccp_inst };\n\t\t},\n\t\t/**\n   * check if there is something in the buffer to paste\n   * @name can_paste()\n   * @return {Boolean}\n   */\n\t\tcan_paste: function can_paste() {\n\t\t\treturn ccp_mode !== false && ccp_node !== false; // && ccp_inst._model.data[ccp_node];\n\t\t},\n\t\t/**\n   * copy or move the previously cut or copied nodes to a new parent\n   * @name paste(obj [, pos])\n   * @param  {mixed} obj the new parent\n   * @param  {mixed} pos the position to insert at (besides integer, \"first\" and \"last\" are supported), defaults to integer `0`\n   * @trigger paste.jstree\n   */\n\t\tpaste: function paste(obj, pos) {\n\t\t\tobj = this.get_node(obj);\n\t\t\tif (!obj || !ccp_mode || !ccp_mode.match(/^(copy_node|move_node)$/) || !ccp_node) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (this[ccp_mode](ccp_node, obj, pos, false, false, false, ccp_inst)) {\n\t\t\t\t/**\n     * triggered when paste is invoked\n     * @event\n     * @name paste.jstree\n     * @param {String} parent the ID of the receiving node\n     * @param {Array} node the nodes in the buffer\n     * @param {String} mode the performed operation - \"copy_node\" or \"move_node\"\n     */\n\t\t\t\tthis.trigger('paste', { \"parent\": obj.id, \"node\": ccp_node, \"mode\": ccp_mode });\n\t\t\t}\n\t\t\tccp_node = false;\n\t\t\tccp_mode = false;\n\t\t\tccp_inst = false;\n\t\t},\n\t\t/**\n   * clear the buffer of previously copied or cut nodes\n   * @name clear_buffer()\n   * @trigger clear_buffer.jstree\n   */\n\t\tclear_buffer: function clear_buffer() {\n\t\t\tccp_node = false;\n\t\t\tccp_mode = false;\n\t\t\tccp_inst = false;\n\t\t\t/**\n    * triggered when the copy / cut buffer is cleared\n    * @event\n    * @name clear_buffer.jstree\n    */\n\t\t\tthis.trigger('clear_buffer');\n\t\t},\n\t\t/**\n   * put a node in edit mode (input field to rename the node)\n   * @name edit(obj [, default_text, callback])\n   * @param  {mixed} obj\n   * @param  {String} default_text the text to populate the input with (if omitted or set to a non-string value the node's text value is used)\n   * @param  {Function} callback a function to be called once the text box is blurred, it is called in the instance's scope and receives the node, a status parameter (true if the rename is successful, false otherwise) and a boolean indicating if the user cancelled the edit. You can access the node's title using .text\n   */\n\t\tedit: function edit(obj, default_text, callback) {\n\t\t\tvar rtl,\n\t\t\t    w,\n\t\t\t    a,\n\t\t\t    s,\n\t\t\t    t,\n\t\t\t    h1,\n\t\t\t    h2,\n\t\t\t    fn,\n\t\t\t    tmp,\n\t\t\t    cancel = false;\n\t\t\tobj = this.get_node(obj);\n\t\t\tif (!obj) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (this.settings.core.check_callback === false) {\n\t\t\t\tthis._data.core.last_error = { 'error': 'check', 'plugin': 'core', 'id': 'core_07', 'reason': 'Could not edit node because of check_callback' };\n\t\t\t\tthis.settings.core.error.call(this, this._data.core.last_error);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ttmp = obj;\n\t\t\tdefault_text = typeof default_text === 'string' ? default_text : obj.text;\n\t\t\tthis.set_text(obj, \"\");\n\t\t\tobj = this._open_to(obj);\n\t\t\ttmp.text = default_text;\n\n\t\t\trtl = this._data.core.rtl;\n\t\t\tw = this.element.width();\n\t\t\tthis._data.core.focused = tmp.id;\n\t\t\ta = obj.children('.jstree-anchor').focus();\n\t\t\ts = $('<span>');\n\t\t\t/*!\n   oi = obj.children(\"i:visible\"),\n   ai = a.children(\"i:visible\"),\n   w1 = oi.width() * oi.length,\n   w2 = ai.width() * ai.length,\n   */\n\t\t\tt = default_text;\n\t\t\th1 = $(\"<\" + \"div />\", { css: { \"position\": \"absolute\", \"top\": \"-200px\", \"left\": rtl ? \"0px\" : \"-1000px\", \"visibility\": \"hidden\" } }).appendTo(\"body\");\n\t\t\th2 = $(\"<\" + \"input />\", {\n\t\t\t\t\"value\": t,\n\t\t\t\t\"class\": \"jstree-rename-input\",\n\t\t\t\t// \"size\" : t.length,\n\t\t\t\t\"css\": {\n\t\t\t\t\t\"padding\": \"0\",\n\t\t\t\t\t\"border\": \"1px solid silver\",\n\t\t\t\t\t\"box-sizing\": \"border-box\",\n\t\t\t\t\t\"display\": \"inline-block\",\n\t\t\t\t\t\"height\": this._data.core.li_height + \"px\",\n\t\t\t\t\t\"lineHeight\": this._data.core.li_height + \"px\",\n\t\t\t\t\t\"width\": \"150px\" // will be set a bit further down\n\t\t\t\t},\n\t\t\t\t\"blur\": $.proxy(function (e) {\n\t\t\t\t\te.stopImmediatePropagation();\n\t\t\t\t\te.preventDefault();\n\t\t\t\t\tvar i = s.children(\".jstree-rename-input\"),\n\t\t\t\t\t    v = i.val(),\n\t\t\t\t\t    f = this.settings.core.force_text,\n\t\t\t\t\t    nv;\n\t\t\t\t\tif (v === \"\") {\n\t\t\t\t\t\tv = t;\n\t\t\t\t\t}\n\t\t\t\t\th1.remove();\n\t\t\t\t\ts.replaceWith(a);\n\t\t\t\t\ts.remove();\n\t\t\t\t\tt = f ? t : $('<div></div>').append($.parseHTML(t)).html();\n\t\t\t\t\tthis.set_text(obj, t);\n\t\t\t\t\tnv = !!this.rename_node(obj, f ? $('<div></div>').text(v).text() : $('<div></div>').append($.parseHTML(v)).html());\n\t\t\t\t\tif (!nv) {\n\t\t\t\t\t\tthis.set_text(obj, t); // move this up? and fix #483\n\t\t\t\t\t}\n\t\t\t\t\tthis._data.core.focused = tmp.id;\n\t\t\t\t\tsetTimeout($.proxy(function () {\n\t\t\t\t\t\tvar node = this.get_node(tmp.id, true);\n\t\t\t\t\t\tif (node.length) {\n\t\t\t\t\t\t\tthis._data.core.focused = tmp.id;\n\t\t\t\t\t\t\tnode.children('.jstree-anchor').focus();\n\t\t\t\t\t\t}\n\t\t\t\t\t}, this), 0);\n\t\t\t\t\tif (callback) {\n\t\t\t\t\t\tcallback.call(this, tmp, nv, cancel);\n\t\t\t\t\t}\n\t\t\t\t\th2 = null;\n\t\t\t\t}, this),\n\t\t\t\t\"keydown\": function keydown(e) {\n\t\t\t\t\tvar key = e.which;\n\t\t\t\t\tif (key === 27) {\n\t\t\t\t\t\tcancel = true;\n\t\t\t\t\t\tthis.value = t;\n\t\t\t\t\t}\n\t\t\t\t\tif (key === 27 || key === 13 || key === 37 || key === 38 || key === 39 || key === 40 || key === 32) {\n\t\t\t\t\t\te.stopImmediatePropagation();\n\t\t\t\t\t}\n\t\t\t\t\tif (key === 27 || key === 13) {\n\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\tthis.blur();\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"click\": function click(e) {\n\t\t\t\t\te.stopImmediatePropagation();\n\t\t\t\t},\n\t\t\t\t\"mousedown\": function mousedown(e) {\n\t\t\t\t\te.stopImmediatePropagation();\n\t\t\t\t},\n\t\t\t\t\"keyup\": function keyup(e) {\n\t\t\t\t\th2.width(Math.min(h1.text(\"pW\" + this.value).width(), w));\n\t\t\t\t},\n\t\t\t\t\"keypress\": function keypress(e) {\n\t\t\t\t\tif (e.which === 13) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\tfn = {\n\t\t\t\tfontFamily: a.css('fontFamily') || '',\n\t\t\t\tfontSize: a.css('fontSize') || '',\n\t\t\t\tfontWeight: a.css('fontWeight') || '',\n\t\t\t\tfontStyle: a.css('fontStyle') || '',\n\t\t\t\tfontStretch: a.css('fontStretch') || '',\n\t\t\t\tfontVariant: a.css('fontVariant') || '',\n\t\t\t\tletterSpacing: a.css('letterSpacing') || '',\n\t\t\t\twordSpacing: a.css('wordSpacing') || ''\n\t\t\t};\n\t\t\ts.attr('class', a.attr('class')).append(a.contents().clone()).append(h2);\n\t\t\ta.replaceWith(s);\n\t\t\th1.css(fn);\n\t\t\th2.css(fn).width(Math.min(h1.text(\"pW\" + h2[0].value).width(), w))[0].select();\n\t\t\t$(document).one('mousedown.jstree touchstart.jstree dnd_start.vakata', function (e) {\n\t\t\t\tif (h2 && e.target !== h2) {\n\t\t\t\t\t$(h2).blur();\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\t/**\n   * changes the theme\n   * @name set_theme(theme_name [, theme_url])\n   * @param {String} theme_name the name of the new theme to apply\n   * @param {mixed} theme_url  the location of the CSS file for this theme. Omit or set to `false` if you manually included the file. Set to `true` to autoload from the `core.themes.dir` directory.\n   * @trigger set_theme.jstree\n   */\n\t\tset_theme: function set_theme(theme_name, theme_url) {\n\t\t\tif (!theme_name) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (theme_url === true) {\n\t\t\t\tvar dir = this.settings.core.themes.dir;\n\t\t\t\tif (!dir) {\n\t\t\t\t\tdir = $.jstree.path + '/themes';\n\t\t\t\t}\n\t\t\t\ttheme_url = dir + '/' + theme_name + '/style.css';\n\t\t\t}\n\t\t\tif (theme_url && $.inArray(theme_url, themes_loaded) === -1) {\n\t\t\t\t$('head').append('<' + 'link rel=\"stylesheet\" href=\"' + theme_url + '\" type=\"text/css\" />');\n\t\t\t\tthemes_loaded.push(theme_url);\n\t\t\t}\n\t\t\tif (this._data.core.themes.name) {\n\t\t\t\tthis.element.removeClass('jstree-' + this._data.core.themes.name);\n\t\t\t}\n\t\t\tthis._data.core.themes.name = theme_name;\n\t\t\tthis.element.addClass('jstree-' + theme_name);\n\t\t\tthis.element[this.settings.core.themes.responsive ? 'addClass' : 'removeClass']('jstree-' + theme_name + '-responsive');\n\t\t\t/**\n    * triggered when a theme is set\n    * @event\n    * @name set_theme.jstree\n    * @param {String} theme the new theme\n    */\n\t\t\tthis.trigger('set_theme', { 'theme': theme_name });\n\t\t},\n\t\t/**\n   * gets the name of the currently applied theme name\n   * @name get_theme()\n   * @return {String}\n   */\n\t\tget_theme: function get_theme() {\n\t\t\treturn this._data.core.themes.name;\n\t\t},\n\t\t/**\n   * changes the theme variant (if the theme has variants)\n   * @name set_theme_variant(variant_name)\n   * @param {String|Boolean} variant_name the variant to apply (if `false` is used the current variant is removed)\n   */\n\t\tset_theme_variant: function set_theme_variant(variant_name) {\n\t\t\tif (this._data.core.themes.variant) {\n\t\t\t\tthis.element.removeClass('jstree-' + this._data.core.themes.name + '-' + this._data.core.themes.variant);\n\t\t\t}\n\t\t\tthis._data.core.themes.variant = variant_name;\n\t\t\tif (variant_name) {\n\t\t\t\tthis.element.addClass('jstree-' + this._data.core.themes.name + '-' + this._data.core.themes.variant);\n\t\t\t}\n\t\t},\n\t\t/**\n   * gets the name of the currently applied theme variant\n   * @name get_theme()\n   * @return {String}\n   */\n\t\tget_theme_variant: function get_theme_variant() {\n\t\t\treturn this._data.core.themes.variant;\n\t\t},\n\t\t/**\n   * shows a striped background on the container (if the theme supports it)\n   * @name show_stripes()\n   */\n\t\tshow_stripes: function show_stripes() {\n\t\t\tthis._data.core.themes.stripes = true;\n\t\t\tthis.get_container_ul().addClass(\"jstree-striped\");\n\t\t\t/**\n    * triggered when stripes are shown\n    * @event\n    * @name show_stripes.jstree\n    */\n\t\t\tthis.trigger('show_stripes');\n\t\t},\n\t\t/**\n   * hides the striped background on the container\n   * @name hide_stripes()\n   */\n\t\thide_stripes: function hide_stripes() {\n\t\t\tthis._data.core.themes.stripes = false;\n\t\t\tthis.get_container_ul().removeClass(\"jstree-striped\");\n\t\t\t/**\n    * triggered when stripes are hidden\n    * @event\n    * @name hide_stripes.jstree\n    */\n\t\t\tthis.trigger('hide_stripes');\n\t\t},\n\t\t/**\n   * toggles the striped background on the container\n   * @name toggle_stripes()\n   */\n\t\ttoggle_stripes: function toggle_stripes() {\n\t\t\tif (this._data.core.themes.stripes) {\n\t\t\t\tthis.hide_stripes();\n\t\t\t} else {\n\t\t\t\tthis.show_stripes();\n\t\t\t}\n\t\t},\n\t\t/**\n   * shows the connecting dots (if the theme supports it)\n   * @name show_dots()\n   */\n\t\tshow_dots: function show_dots() {\n\t\t\tthis._data.core.themes.dots = true;\n\t\t\tthis.get_container_ul().removeClass(\"jstree-no-dots\");\n\t\t\t/**\n    * triggered when dots are shown\n    * @event\n    * @name show_dots.jstree\n    */\n\t\t\tthis.trigger('show_dots');\n\t\t},\n\t\t/**\n   * hides the connecting dots\n   * @name hide_dots()\n   */\n\t\thide_dots: function hide_dots() {\n\t\t\tthis._data.core.themes.dots = false;\n\t\t\tthis.get_container_ul().addClass(\"jstree-no-dots\");\n\t\t\t/**\n    * triggered when dots are hidden\n    * @event\n    * @name hide_dots.jstree\n    */\n\t\t\tthis.trigger('hide_dots');\n\t\t},\n\t\t/**\n   * toggles the connecting dots\n   * @name toggle_dots()\n   */\n\t\ttoggle_dots: function toggle_dots() {\n\t\t\tif (this._data.core.themes.dots) {\n\t\t\t\tthis.hide_dots();\n\t\t\t} else {\n\t\t\t\tthis.show_dots();\n\t\t\t}\n\t\t},\n\t\t/**\n   * show the node icons\n   * @name show_icons()\n   */\n\t\tshow_icons: function show_icons() {\n\t\t\tthis._data.core.themes.icons = true;\n\t\t\tthis.get_container_ul().removeClass(\"jstree-no-icons\");\n\t\t\t/**\n    * triggered when icons are shown\n    * @event\n    * @name show_icons.jstree\n    */\n\t\t\tthis.trigger('show_icons');\n\t\t},\n\t\t/**\n   * hide the node icons\n   * @name hide_icons()\n   */\n\t\thide_icons: function hide_icons() {\n\t\t\tthis._data.core.themes.icons = false;\n\t\t\tthis.get_container_ul().addClass(\"jstree-no-icons\");\n\t\t\t/**\n    * triggered when icons are hidden\n    * @event\n    * @name hide_icons.jstree\n    */\n\t\t\tthis.trigger('hide_icons');\n\t\t},\n\t\t/**\n   * toggle the node icons\n   * @name toggle_icons()\n   */\n\t\ttoggle_icons: function toggle_icons() {\n\t\t\tif (this._data.core.themes.icons) {\n\t\t\t\tthis.hide_icons();\n\t\t\t} else {\n\t\t\t\tthis.show_icons();\n\t\t\t}\n\t\t},\n\t\t/**\n   * show the node ellipsis\n   * @name show_icons()\n   */\n\t\tshow_ellipsis: function show_ellipsis() {\n\t\t\tthis._data.core.themes.ellipsis = true;\n\t\t\tthis.get_container_ul().addClass(\"jstree-ellipsis\");\n\t\t\t/**\n    * triggered when ellisis is shown\n    * @event\n    * @name show_ellipsis.jstree\n    */\n\t\t\tthis.trigger('show_ellipsis');\n\t\t},\n\t\t/**\n   * hide the node ellipsis\n   * @name hide_ellipsis()\n   */\n\t\thide_ellipsis: function hide_ellipsis() {\n\t\t\tthis._data.core.themes.ellipsis = false;\n\t\t\tthis.get_container_ul().removeClass(\"jstree-ellipsis\");\n\t\t\t/**\n    * triggered when ellisis is hidden\n    * @event\n    * @name hide_ellipsis.jstree\n    */\n\t\t\tthis.trigger('hide_ellipsis');\n\t\t},\n\t\t/**\n   * toggle the node ellipsis\n   * @name toggle_icons()\n   */\n\t\ttoggle_ellipsis: function toggle_ellipsis() {\n\t\t\tif (this._data.core.themes.ellipsis) {\n\t\t\t\tthis.hide_ellipsis();\n\t\t\t} else {\n\t\t\t\tthis.show_ellipsis();\n\t\t\t}\n\t\t},\n\t\t/**\n   * set the node icon for a node\n   * @name set_icon(obj, icon)\n   * @param {mixed} obj\n   * @param {String} icon the new icon - can be a path to an icon or a className, if using an image that is in the current directory use a `./` prefix, otherwise it will be detected as a class\n   */\n\t\tset_icon: function set_icon(obj, icon) {\n\t\t\tvar t1, t2, dom, old;\n\t\t\tif ($.isArray(obj)) {\n\t\t\t\tobj = obj.slice();\n\t\t\t\tfor (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n\t\t\t\t\tthis.set_icon(obj[t1], icon);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tobj = this.get_node(obj);\n\t\t\tif (!obj || obj.id === $.jstree.root) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\told = obj.icon;\n\t\t\tobj.icon = icon === true || icon === null || icon === undefined || icon === '' ? true : icon;\n\t\t\tdom = this.get_node(obj, true).children(\".jstree-anchor\").children(\".jstree-themeicon\");\n\t\t\tif (icon === false) {\n\t\t\t\tthis.hide_icon(obj);\n\t\t\t} else if (icon === true || icon === null || icon === undefined || icon === '') {\n\t\t\t\tdom.removeClass('jstree-themeicon-custom ' + old).css(\"background\", \"\").removeAttr(\"rel\");\n\t\t\t\tif (old === false) {\n\t\t\t\t\tthis.show_icon(obj);\n\t\t\t\t}\n\t\t\t} else if (icon.indexOf(\"/\") === -1 && icon.indexOf(\".\") === -1) {\n\t\t\t\tdom.removeClass(old).css(\"background\", \"\");\n\t\t\t\tdom.addClass(icon + ' jstree-themeicon-custom').attr(\"rel\", icon);\n\t\t\t\tif (old === false) {\n\t\t\t\t\tthis.show_icon(obj);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdom.removeClass(old).css(\"background\", \"\");\n\t\t\t\tdom.addClass('jstree-themeicon-custom').css(\"background\", \"url('\" + icon + \"') center center no-repeat\").attr(\"rel\", icon);\n\t\t\t\tif (old === false) {\n\t\t\t\t\tthis.show_icon(obj);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\t\t/**\n   * get the node icon for a node\n   * @name get_icon(obj)\n   * @param {mixed} obj\n   * @return {String}\n   */\n\t\tget_icon: function get_icon(obj) {\n\t\t\tobj = this.get_node(obj);\n\t\t\treturn !obj || obj.id === $.jstree.root ? false : obj.icon;\n\t\t},\n\t\t/**\n   * hide the icon on an individual node\n   * @name hide_icon(obj)\n   * @param {mixed} obj\n   */\n\t\thide_icon: function hide_icon(obj) {\n\t\t\tvar t1, t2;\n\t\t\tif ($.isArray(obj)) {\n\t\t\t\tobj = obj.slice();\n\t\t\t\tfor (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n\t\t\t\t\tthis.hide_icon(obj[t1]);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tobj = this.get_node(obj);\n\t\t\tif (!obj || obj === $.jstree.root) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tobj.icon = false;\n\t\t\tthis.get_node(obj, true).children(\".jstree-anchor\").children(\".jstree-themeicon\").addClass('jstree-themeicon-hidden');\n\t\t\treturn true;\n\t\t},\n\t\t/**\n   * show the icon on an individual node\n   * @name show_icon(obj)\n   * @param {mixed} obj\n   */\n\t\tshow_icon: function show_icon(obj) {\n\t\t\tvar t1, t2, dom;\n\t\t\tif ($.isArray(obj)) {\n\t\t\t\tobj = obj.slice();\n\t\t\t\tfor (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n\t\t\t\t\tthis.show_icon(obj[t1]);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tobj = this.get_node(obj);\n\t\t\tif (!obj || obj === $.jstree.root) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tdom = this.get_node(obj, true);\n\t\t\tobj.icon = dom.length ? dom.children(\".jstree-anchor\").children(\".jstree-themeicon\").attr('rel') : true;\n\t\t\tif (!obj.icon) {\n\t\t\t\tobj.icon = true;\n\t\t\t}\n\t\t\tdom.children(\".jstree-anchor\").children(\".jstree-themeicon\").removeClass('jstree-themeicon-hidden');\n\t\t\treturn true;\n\t\t}\n\t};\n\n\t// helpers\n\t$.vakata = {};\n\t// collect attributes\n\t$.vakata.attributes = function (node, with_values) {\n\t\tnode = $(node)[0];\n\t\tvar attr = with_values ? {} : [];\n\t\tif (node && node.attributes) {\n\t\t\t$.each(node.attributes, function (i, v) {\n\t\t\t\tif ($.inArray(v.name.toLowerCase(), ['style', 'contenteditable', 'hasfocus', 'tabindex']) !== -1) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (v.value !== null && $.trim(v.value) !== '') {\n\t\t\t\t\tif (with_values) {\n\t\t\t\t\t\tattr[v.name] = v.value;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tattr.push(v.name);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn attr;\n\t};\n\t$.vakata.array_unique = function (array) {\n\t\tvar a = [],\n\t\t    i,\n\t\t    j,\n\t\t    l,\n\t\t    o = {};\n\t\tfor (i = 0, l = array.length; i < l; i++) {\n\t\t\tif (o[array[i]] === undefined) {\n\t\t\t\ta.push(array[i]);\n\t\t\t\to[array[i]] = true;\n\t\t\t}\n\t\t}\n\t\treturn a;\n\t};\n\t// remove item from array\n\t$.vakata.array_remove = function (array, from) {\n\t\tarray.splice(from, 1);\n\t\treturn array;\n\t\t//var rest = array.slice((to || from) + 1 || array.length);\n\t\t//array.length = from < 0 ? array.length + from : from;\n\t\t//array.push.apply(array, rest);\n\t\t//return array;\n\t};\n\t// remove item from array\n\t$.vakata.array_remove_item = function (array, item) {\n\t\tvar tmp = $.inArray(item, array);\n\t\treturn tmp !== -1 ? $.vakata.array_remove(array, tmp) : array;\n\t};\n\t$.vakata.array_filter = function (c, a, b, d, e) {\n\t\tif (c.filter) {\n\t\t\treturn c.filter(a, b);\n\t\t}\n\t\td = [];\n\t\tfor (e in c) {\n\t\t\tif (~~e + '' === e + '' && e >= 0 && a.call(b, c[e], +e, c)) {\n\t\t\t\td.push(c[e]);\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t};\n\n\t/**\n  * ### Changed plugin\n  *\n  * This plugin adds more information to the `changed.jstree` event. The new data is contained in the `changed` event data property, and contains a lists of `selected` and `deselected` nodes.\n  */\n\n\t$.jstree.plugins.changed = function (options, parent) {\n\t\tvar last = [];\n\t\tthis.trigger = function (ev, data) {\n\t\t\tvar i, j;\n\t\t\tif (!data) {\n\t\t\t\tdata = {};\n\t\t\t}\n\t\t\tif (ev.replace('.jstree', '') === 'changed') {\n\t\t\t\tdata.changed = { selected: [], deselected: [] };\n\t\t\t\tvar tmp = {};\n\t\t\t\tfor (i = 0, j = last.length; i < j; i++) {\n\t\t\t\t\ttmp[last[i]] = 1;\n\t\t\t\t}\n\t\t\t\tfor (i = 0, j = data.selected.length; i < j; i++) {\n\t\t\t\t\tif (!tmp[data.selected[i]]) {\n\t\t\t\t\t\tdata.changed.selected.push(data.selected[i]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttmp[data.selected[i]] = 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (i = 0, j = last.length; i < j; i++) {\n\t\t\t\t\tif (tmp[last[i]] === 1) {\n\t\t\t\t\t\tdata.changed.deselected.push(last[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlast = data.selected.slice();\n\t\t\t}\n\t\t\t/**\n    * triggered when selection changes (the \"changed\" plugin enhances the original event with more data)\n    * @event\n    * @name changed.jstree\n    * @param {Object} node\n    * @param {Object} action the action that caused the selection to change\n    * @param {Array} selected the current selection\n    * @param {Object} changed an object containing two properties `selected` and `deselected` - both arrays of node IDs, which were selected or deselected since the last changed event\n    * @param {Object} event the event (if any) that triggered this changed event\n    * @plugin changed\n    */\n\t\t\tparent.trigger.call(this, ev, data);\n\t\t};\n\t\tthis.refresh = function (skip_loading, forget_state) {\n\t\t\tlast = [];\n\t\t\treturn parent.refresh.apply(this, arguments);\n\t\t};\n\t};\n\n\t/**\n  * ### Checkbox plugin\n  *\n  * This plugin renders checkbox icons in front of each node, making multiple selection much easier.\n  * It also supports tri-state behavior, meaning that if a node has a few of its children checked it will be rendered as undetermined, and state will be propagated up.\n  */\n\n\tvar _i = document.createElement('I');\n\t_i.className = 'jstree-icon jstree-checkbox';\n\t_i.setAttribute('role', 'presentation');\n\t/**\n  * stores all defaults for the checkbox plugin\n  * @name $.jstree.defaults.checkbox\n  * @plugin checkbox\n  */\n\t$.jstree.defaults.checkbox = {\n\t\t/**\n   * a boolean indicating if checkboxes should be visible (can be changed at a later time using `show_checkboxes()` and `hide_checkboxes`). Defaults to `true`.\n   * @name $.jstree.defaults.checkbox.visible\n   * @plugin checkbox\n   */\n\t\tvisible: true,\n\t\t/**\n   * a boolean indicating if checkboxes should cascade down and have an undetermined state. Defaults to `true`.\n   * @name $.jstree.defaults.checkbox.three_state\n   * @plugin checkbox\n   */\n\t\tthree_state: true,\n\t\t/**\n   * a boolean indicating if clicking anywhere on the node should act as clicking on the checkbox. Defaults to `true`.\n   * @name $.jstree.defaults.checkbox.whole_node\n   * @plugin checkbox\n   */\n\t\twhole_node: true,\n\t\t/**\n   * a boolean indicating if the selected style of a node should be kept, or removed. Defaults to `true`.\n   * @name $.jstree.defaults.checkbox.keep_selected_style\n   * @plugin checkbox\n   */\n\t\tkeep_selected_style: true,\n\t\t/**\n   * This setting controls how cascading and undetermined nodes are applied.\n   * If 'up' is in the string - cascading up is enabled, if 'down' is in the string - cascading down is enabled, if 'undetermined' is in the string - undetermined nodes will be used.\n   * If `three_state` is set to `true` this setting is automatically set to 'up+down+undetermined'. Defaults to ''.\n   * @name $.jstree.defaults.checkbox.cascade\n   * @plugin checkbox\n   */\n\t\tcascade: '',\n\t\t/**\n   * This setting controls if checkbox are bound to the general tree selection or to an internal array maintained by the checkbox plugin. Defaults to `true`, only set to `false` if you know exactly what you are doing.\n   * @name $.jstree.defaults.checkbox.tie_selection\n   * @plugin checkbox\n   */\n\t\ttie_selection: true\n\t};\n\t$.jstree.plugins.checkbox = function (options, parent) {\n\t\tthis.bind = function () {\n\t\t\tparent.bind.call(this);\n\t\t\tthis._data.checkbox.uto = false;\n\t\t\tthis._data.checkbox.selected = [];\n\t\t\tif (this.settings.checkbox.three_state) {\n\t\t\t\tthis.settings.checkbox.cascade = 'up+down+undetermined';\n\t\t\t}\n\t\t\tthis.element.on(\"init.jstree\", $.proxy(function () {\n\t\t\t\tthis._data.checkbox.visible = this.settings.checkbox.visible;\n\t\t\t\tif (!this.settings.checkbox.keep_selected_style) {\n\t\t\t\t\tthis.element.addClass('jstree-checkbox-no-clicked');\n\t\t\t\t}\n\t\t\t\tif (this.settings.checkbox.tie_selection) {\n\t\t\t\t\tthis.element.addClass('jstree-checkbox-selection');\n\t\t\t\t}\n\t\t\t}, this)).on(\"loading.jstree\", $.proxy(function () {\n\t\t\t\tthis[this._data.checkbox.visible ? 'show_checkboxes' : 'hide_checkboxes']();\n\t\t\t}, this));\n\t\t\tif (this.settings.checkbox.cascade.indexOf('undetermined') !== -1) {\n\t\t\t\tthis.element.on('changed.jstree uncheck_node.jstree check_node.jstree uncheck_all.jstree check_all.jstree move_node.jstree copy_node.jstree redraw.jstree open_node.jstree', $.proxy(function () {\n\t\t\t\t\t// only if undetermined is in setting\n\t\t\t\t\tif (this._data.checkbox.uto) {\n\t\t\t\t\t\tclearTimeout(this._data.checkbox.uto);\n\t\t\t\t\t}\n\t\t\t\t\tthis._data.checkbox.uto = setTimeout($.proxy(this._undetermined, this), 50);\n\t\t\t\t}, this));\n\t\t\t}\n\t\t\tif (!this.settings.checkbox.tie_selection) {\n\t\t\t\tthis.element.on('model.jstree', $.proxy(function (e, data) {\n\t\t\t\t\tvar m = this._model.data,\n\t\t\t\t\t    p = m[data.parent],\n\t\t\t\t\t    dpc = data.nodes,\n\t\t\t\t\t    i,\n\t\t\t\t\t    j;\n\t\t\t\t\tfor (i = 0, j = dpc.length; i < j; i++) {\n\t\t\t\t\t\tm[dpc[i]].state.checked = m[dpc[i]].state.checked || m[dpc[i]].original && m[dpc[i]].original.state && m[dpc[i]].original.state.checked;\n\t\t\t\t\t\tif (m[dpc[i]].state.checked) {\n\t\t\t\t\t\t\tthis._data.checkbox.selected.push(dpc[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}, this));\n\t\t\t}\n\t\t\tif (this.settings.checkbox.cascade.indexOf('up') !== -1 || this.settings.checkbox.cascade.indexOf('down') !== -1) {\n\t\t\t\tthis.element.on('model.jstree', $.proxy(function (e, data) {\n\t\t\t\t\tvar m = this._model.data,\n\t\t\t\t\t    p = m[data.parent],\n\t\t\t\t\t    dpc = data.nodes,\n\t\t\t\t\t    chd = [],\n\t\t\t\t\t    c,\n\t\t\t\t\t    i,\n\t\t\t\t\t    j,\n\t\t\t\t\t    k,\n\t\t\t\t\t    l,\n\t\t\t\t\t    tmp,\n\t\t\t\t\t    s = this.settings.checkbox.cascade,\n\t\t\t\t\t    t = this.settings.checkbox.tie_selection;\n\n\t\t\t\t\tif (s.indexOf('down') !== -1) {\n\t\t\t\t\t\t// apply down\n\t\t\t\t\t\tif (p.state[t ? 'selected' : 'checked']) {\n\t\t\t\t\t\t\tfor (i = 0, j = dpc.length; i < j; i++) {\n\t\t\t\t\t\t\t\tm[dpc[i]].state[t ? 'selected' : 'checked'] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis._data[t ? 'core' : 'checkbox'].selected = this._data[t ? 'core' : 'checkbox'].selected.concat(dpc);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfor (i = 0, j = dpc.length; i < j; i++) {\n\t\t\t\t\t\t\t\tif (m[dpc[i]].state[t ? 'selected' : 'checked']) {\n\t\t\t\t\t\t\t\t\tfor (k = 0, l = m[dpc[i]].children_d.length; k < l; k++) {\n\t\t\t\t\t\t\t\t\t\tm[m[dpc[i]].children_d[k]].state[t ? 'selected' : 'checked'] = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tthis._data[t ? 'core' : 'checkbox'].selected = this._data[t ? 'core' : 'checkbox'].selected.concat(m[dpc[i]].children_d);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (s.indexOf('up') !== -1) {\n\t\t\t\t\t\t// apply up\n\t\t\t\t\t\tfor (i = 0, j = p.children_d.length; i < j; i++) {\n\t\t\t\t\t\t\tif (!m[p.children_d[i]].children.length) {\n\t\t\t\t\t\t\t\tchd.push(m[p.children_d[i]].parent);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tchd = $.vakata.array_unique(chd);\n\t\t\t\t\t\tfor (k = 0, l = chd.length; k < l; k++) {\n\t\t\t\t\t\t\tp = m[chd[k]];\n\t\t\t\t\t\t\twhile (p && p.id !== $.jstree.root) {\n\t\t\t\t\t\t\t\tc = 0;\n\t\t\t\t\t\t\t\tfor (i = 0, j = p.children.length; i < j; i++) {\n\t\t\t\t\t\t\t\t\tc += m[p.children[i]].state[t ? 'selected' : 'checked'];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (c === j) {\n\t\t\t\t\t\t\t\t\tp.state[t ? 'selected' : 'checked'] = true;\n\t\t\t\t\t\t\t\t\tthis._data[t ? 'core' : 'checkbox'].selected.push(p.id);\n\t\t\t\t\t\t\t\t\ttmp = this.get_node(p, true);\n\t\t\t\t\t\t\t\t\tif (tmp && tmp.length) {\n\t\t\t\t\t\t\t\t\t\ttmp.attr('aria-selected', true).children('.jstree-anchor').addClass(t ? 'jstree-clicked' : 'jstree-checked');\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tp = this.get_node(p.parent);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._data[t ? 'core' : 'checkbox'].selected = $.vakata.array_unique(this._data[t ? 'core' : 'checkbox'].selected);\n\t\t\t\t}, this)).on(this.settings.checkbox.tie_selection ? 'select_node.jstree' : 'check_node.jstree', $.proxy(function (e, data) {\n\t\t\t\t\tvar obj = data.node,\n\t\t\t\t\t    m = this._model.data,\n\t\t\t\t\t    par = this.get_node(obj.parent),\n\t\t\t\t\t    dom = this.get_node(obj, true),\n\t\t\t\t\t    i,\n\t\t\t\t\t    j,\n\t\t\t\t\t    c,\n\t\t\t\t\t    tmp,\n\t\t\t\t\t    s = this.settings.checkbox.cascade,\n\t\t\t\t\t    t = this.settings.checkbox.tie_selection,\n\t\t\t\t\t    sel = {},\n\t\t\t\t\t    cur = this._data[t ? 'core' : 'checkbox'].selected;\n\n\t\t\t\t\tfor (i = 0, j = cur.length; i < j; i++) {\n\t\t\t\t\t\tsel[cur[i]] = true;\n\t\t\t\t\t}\n\t\t\t\t\t// apply down\n\t\t\t\t\tif (s.indexOf('down') !== -1) {\n\t\t\t\t\t\t//this._data[ t ? 'core' : 'checkbox' ].selected = $.vakata.array_unique(this._data[ t ? 'core' : 'checkbox' ].selected.concat(obj.children_d));\n\t\t\t\t\t\tfor (i = 0, j = obj.children_d.length; i < j; i++) {\n\t\t\t\t\t\t\tsel[obj.children_d[i]] = true;\n\t\t\t\t\t\t\ttmp = m[obj.children_d[i]];\n\t\t\t\t\t\t\ttmp.state[t ? 'selected' : 'checked'] = true;\n\t\t\t\t\t\t\tif (tmp && tmp.original && tmp.original.state && tmp.original.state.undetermined) {\n\t\t\t\t\t\t\t\ttmp.original.state.undetermined = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// apply up\n\t\t\t\t\tif (s.indexOf('up') !== -1) {\n\t\t\t\t\t\twhile (par && par.id !== $.jstree.root) {\n\t\t\t\t\t\t\tc = 0;\n\t\t\t\t\t\t\tfor (i = 0, j = par.children.length; i < j; i++) {\n\t\t\t\t\t\t\t\tc += m[par.children[i]].state[t ? 'selected' : 'checked'];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (c === j) {\n\t\t\t\t\t\t\t\tpar.state[t ? 'selected' : 'checked'] = true;\n\t\t\t\t\t\t\t\tsel[par.id] = true;\n\t\t\t\t\t\t\t\t//this._data[ t ? 'core' : 'checkbox' ].selected.push(par.id);\n\t\t\t\t\t\t\t\ttmp = this.get_node(par, true);\n\t\t\t\t\t\t\t\tif (tmp && tmp.length) {\n\t\t\t\t\t\t\t\t\ttmp.attr('aria-selected', true).children('.jstree-anchor').addClass(t ? 'jstree-clicked' : 'jstree-checked');\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpar = this.get_node(par.parent);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcur = [];\n\t\t\t\t\tfor (i in sel) {\n\t\t\t\t\t\tif (sel.hasOwnProperty(i)) {\n\t\t\t\t\t\t\tcur.push(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis._data[t ? 'core' : 'checkbox'].selected = cur;\n\n\t\t\t\t\t// apply down (process .children separately?)\n\t\t\t\t\tif (s.indexOf('down') !== -1 && dom.length) {\n\t\t\t\t\t\tdom.find('.jstree-anchor').addClass(t ? 'jstree-clicked' : 'jstree-checked').parent().attr('aria-selected', true);\n\t\t\t\t\t}\n\t\t\t\t}, this)).on(this.settings.checkbox.tie_selection ? 'deselect_all.jstree' : 'uncheck_all.jstree', $.proxy(function (e, data) {\n\t\t\t\t\tvar obj = this.get_node($.jstree.root),\n\t\t\t\t\t    m = this._model.data,\n\t\t\t\t\t    i,\n\t\t\t\t\t    j,\n\t\t\t\t\t    tmp;\n\t\t\t\t\tfor (i = 0, j = obj.children_d.length; i < j; i++) {\n\t\t\t\t\t\ttmp = m[obj.children_d[i]];\n\t\t\t\t\t\tif (tmp && tmp.original && tmp.original.state && tmp.original.state.undetermined) {\n\t\t\t\t\t\t\ttmp.original.state.undetermined = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}, this)).on(this.settings.checkbox.tie_selection ? 'deselect_node.jstree' : 'uncheck_node.jstree', $.proxy(function (e, data) {\n\t\t\t\t\tvar obj = data.node,\n\t\t\t\t\t    dom = this.get_node(obj, true),\n\t\t\t\t\t    i,\n\t\t\t\t\t    j,\n\t\t\t\t\t    tmp,\n\t\t\t\t\t    s = this.settings.checkbox.cascade,\n\t\t\t\t\t    t = this.settings.checkbox.tie_selection,\n\t\t\t\t\t    cur = this._data[t ? 'core' : 'checkbox'].selected,\n\t\t\t\t\t    sel = {};\n\t\t\t\t\tif (obj && obj.original && obj.original.state && obj.original.state.undetermined) {\n\t\t\t\t\t\tobj.original.state.undetermined = false;\n\t\t\t\t\t}\n\n\t\t\t\t\t// apply down\n\t\t\t\t\tif (s.indexOf('down') !== -1) {\n\t\t\t\t\t\tfor (i = 0, j = obj.children_d.length; i < j; i++) {\n\t\t\t\t\t\t\ttmp = this._model.data[obj.children_d[i]];\n\t\t\t\t\t\t\ttmp.state[t ? 'selected' : 'checked'] = false;\n\t\t\t\t\t\t\tif (tmp && tmp.original && tmp.original.state && tmp.original.state.undetermined) {\n\t\t\t\t\t\t\t\ttmp.original.state.undetermined = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// apply up\n\t\t\t\t\tif (s.indexOf('up') !== -1) {\n\t\t\t\t\t\tfor (i = 0, j = obj.parents.length; i < j; i++) {\n\t\t\t\t\t\t\ttmp = this._model.data[obj.parents[i]];\n\t\t\t\t\t\t\ttmp.state[t ? 'selected' : 'checked'] = false;\n\t\t\t\t\t\t\tif (tmp && tmp.original && tmp.original.state && tmp.original.state.undetermined) {\n\t\t\t\t\t\t\t\ttmp.original.state.undetermined = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttmp = this.get_node(obj.parents[i], true);\n\t\t\t\t\t\t\tif (tmp && tmp.length) {\n\t\t\t\t\t\t\t\ttmp.attr('aria-selected', false).children('.jstree-anchor').removeClass(t ? 'jstree-clicked' : 'jstree-checked');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tsel = {};\n\t\t\t\t\tfor (i = 0, j = cur.length; i < j; i++) {\n\t\t\t\t\t\t// apply down + apply up\n\t\t\t\t\t\tif ((s.indexOf('down') === -1 || $.inArray(cur[i], obj.children_d) === -1) && (s.indexOf('up') === -1 || $.inArray(cur[i], obj.parents) === -1)) {\n\t\t\t\t\t\t\tsel[cur[i]] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcur = [];\n\t\t\t\t\tfor (i in sel) {\n\t\t\t\t\t\tif (sel.hasOwnProperty(i)) {\n\t\t\t\t\t\t\tcur.push(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis._data[t ? 'core' : 'checkbox'].selected = cur;\n\n\t\t\t\t\t// apply down (process .children separately?)\n\t\t\t\t\tif (s.indexOf('down') !== -1 && dom.length) {\n\t\t\t\t\t\tdom.find('.jstree-anchor').removeClass(t ? 'jstree-clicked' : 'jstree-checked').parent().attr('aria-selected', false);\n\t\t\t\t\t}\n\t\t\t\t}, this));\n\t\t\t}\n\t\t\tif (this.settings.checkbox.cascade.indexOf('up') !== -1) {\n\t\t\t\tthis.element.on('delete_node.jstree', $.proxy(function (e, data) {\n\t\t\t\t\t// apply up (whole handler)\n\t\t\t\t\tvar p = this.get_node(data.parent),\n\t\t\t\t\t    m = this._model.data,\n\t\t\t\t\t    i,\n\t\t\t\t\t    j,\n\t\t\t\t\t    c,\n\t\t\t\t\t    tmp,\n\t\t\t\t\t    t = this.settings.checkbox.tie_selection;\n\t\t\t\t\twhile (p && p.id !== $.jstree.root && !p.state[t ? 'selected' : 'checked']) {\n\t\t\t\t\t\tc = 0;\n\t\t\t\t\t\tfor (i = 0, j = p.children.length; i < j; i++) {\n\t\t\t\t\t\t\tc += m[p.children[i]].state[t ? 'selected' : 'checked'];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j > 0 && c === j) {\n\t\t\t\t\t\t\tp.state[t ? 'selected' : 'checked'] = true;\n\t\t\t\t\t\t\tthis._data[t ? 'core' : 'checkbox'].selected.push(p.id);\n\t\t\t\t\t\t\ttmp = this.get_node(p, true);\n\t\t\t\t\t\t\tif (tmp && tmp.length) {\n\t\t\t\t\t\t\t\ttmp.attr('aria-selected', true).children('.jstree-anchor').addClass(t ? 'jstree-clicked' : 'jstree-checked');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tp = this.get_node(p.parent);\n\t\t\t\t\t}\n\t\t\t\t}, this)).on('move_node.jstree', $.proxy(function (e, data) {\n\t\t\t\t\t// apply up (whole handler)\n\t\t\t\t\tvar is_multi = data.is_multi,\n\t\t\t\t\t    old_par = data.old_parent,\n\t\t\t\t\t    new_par = this.get_node(data.parent),\n\t\t\t\t\t    m = this._model.data,\n\t\t\t\t\t    p,\n\t\t\t\t\t    c,\n\t\t\t\t\t    i,\n\t\t\t\t\t    j,\n\t\t\t\t\t    tmp,\n\t\t\t\t\t    t = this.settings.checkbox.tie_selection;\n\t\t\t\t\tif (!is_multi) {\n\t\t\t\t\t\tp = this.get_node(old_par);\n\t\t\t\t\t\twhile (p && p.id !== $.jstree.root && !p.state[t ? 'selected' : 'checked']) {\n\t\t\t\t\t\t\tc = 0;\n\t\t\t\t\t\t\tfor (i = 0, j = p.children.length; i < j; i++) {\n\t\t\t\t\t\t\t\tc += m[p.children[i]].state[t ? 'selected' : 'checked'];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (j > 0 && c === j) {\n\t\t\t\t\t\t\t\tp.state[t ? 'selected' : 'checked'] = true;\n\t\t\t\t\t\t\t\tthis._data[t ? 'core' : 'checkbox'].selected.push(p.id);\n\t\t\t\t\t\t\t\ttmp = this.get_node(p, true);\n\t\t\t\t\t\t\t\tif (tmp && tmp.length) {\n\t\t\t\t\t\t\t\t\ttmp.attr('aria-selected', true).children('.jstree-anchor').addClass(t ? 'jstree-clicked' : 'jstree-checked');\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tp = this.get_node(p.parent);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tp = new_par;\n\t\t\t\t\twhile (p && p.id !== $.jstree.root) {\n\t\t\t\t\t\tc = 0;\n\t\t\t\t\t\tfor (i = 0, j = p.children.length; i < j; i++) {\n\t\t\t\t\t\t\tc += m[p.children[i]].state[t ? 'selected' : 'checked'];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (c === j) {\n\t\t\t\t\t\t\tif (!p.state[t ? 'selected' : 'checked']) {\n\t\t\t\t\t\t\t\tp.state[t ? 'selected' : 'checked'] = true;\n\t\t\t\t\t\t\t\tthis._data[t ? 'core' : 'checkbox'].selected.push(p.id);\n\t\t\t\t\t\t\t\ttmp = this.get_node(p, true);\n\t\t\t\t\t\t\t\tif (tmp && tmp.length) {\n\t\t\t\t\t\t\t\t\ttmp.attr('aria-selected', true).children('.jstree-anchor').addClass(t ? 'jstree-clicked' : 'jstree-checked');\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (p.state[t ? 'selected' : 'checked']) {\n\t\t\t\t\t\t\t\tp.state[t ? 'selected' : 'checked'] = false;\n\t\t\t\t\t\t\t\tthis._data[t ? 'core' : 'checkbox'].selected = $.vakata.array_remove_item(this._data[t ? 'core' : 'checkbox'].selected, p.id);\n\t\t\t\t\t\t\t\ttmp = this.get_node(p, true);\n\t\t\t\t\t\t\t\tif (tmp && tmp.length) {\n\t\t\t\t\t\t\t\t\ttmp.attr('aria-selected', false).children('.jstree-anchor').removeClass(t ? 'jstree-clicked' : 'jstree-checked');\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tp = this.get_node(p.parent);\n\t\t\t\t\t}\n\t\t\t\t}, this));\n\t\t\t}\n\t\t};\n\t\t/**\n   * set the undetermined state where and if necessary. Used internally.\n   * @private\n   * @name _undetermined()\n   * @plugin checkbox\n   */\n\t\tthis._undetermined = function () {\n\t\t\tif (this.element === null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar i,\n\t\t\t    j,\n\t\t\t    k,\n\t\t\t    l,\n\t\t\t    o = {},\n\t\t\t    m = this._model.data,\n\t\t\t    t = this.settings.checkbox.tie_selection,\n\t\t\t    s = this._data[t ? 'core' : 'checkbox'].selected,\n\t\t\t    p = [],\n\t\t\t    tt = this;\n\t\t\tfor (i = 0, j = s.length; i < j; i++) {\n\t\t\t\tif (m[s[i]] && m[s[i]].parents) {\n\t\t\t\t\tfor (k = 0, l = m[s[i]].parents.length; k < l; k++) {\n\t\t\t\t\t\tif (o[m[s[i]].parents[k]] !== undefined) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (m[s[i]].parents[k] !== $.jstree.root) {\n\t\t\t\t\t\t\to[m[s[i]].parents[k]] = true;\n\t\t\t\t\t\t\tp.push(m[s[i]].parents[k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// attempt for server side undetermined state\n\t\t\tthis.element.find('.jstree-closed').not(':has(.jstree-children)').each(function () {\n\t\t\t\tvar tmp = tt.get_node(this),\n\t\t\t\t    tmp2;\n\t\t\t\tif (!tmp.state.loaded) {\n\t\t\t\t\tif (tmp.original && tmp.original.state && tmp.original.state.undetermined && tmp.original.state.undetermined === true) {\n\t\t\t\t\t\tif (o[tmp.id] === undefined && tmp.id !== $.jstree.root) {\n\t\t\t\t\t\t\to[tmp.id] = true;\n\t\t\t\t\t\t\tp.push(tmp.id);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (k = 0, l = tmp.parents.length; k < l; k++) {\n\t\t\t\t\t\t\tif (o[tmp.parents[k]] === undefined && tmp.parents[k] !== $.jstree.root) {\n\t\t\t\t\t\t\t\to[tmp.parents[k]] = true;\n\t\t\t\t\t\t\t\tp.push(tmp.parents[k]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (i = 0, j = tmp.children_d.length; i < j; i++) {\n\t\t\t\t\t\ttmp2 = m[tmp.children_d[i]];\n\t\t\t\t\t\tif (!tmp2.state.loaded && tmp2.original && tmp2.original.state && tmp2.original.state.undetermined && tmp2.original.state.undetermined === true) {\n\t\t\t\t\t\t\tif (o[tmp2.id] === undefined && tmp2.id !== $.jstree.root) {\n\t\t\t\t\t\t\t\to[tmp2.id] = true;\n\t\t\t\t\t\t\t\tp.push(tmp2.id);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (k = 0, l = tmp2.parents.length; k < l; k++) {\n\t\t\t\t\t\t\t\tif (o[tmp2.parents[k]] === undefined && tmp2.parents[k] !== $.jstree.root) {\n\t\t\t\t\t\t\t\t\to[tmp2.parents[k]] = true;\n\t\t\t\t\t\t\t\t\tp.push(tmp2.parents[k]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tthis.element.find('.jstree-undetermined').removeClass('jstree-undetermined');\n\t\t\tfor (i = 0, j = p.length; i < j; i++) {\n\t\t\t\tif (!m[p[i]].state[t ? 'selected' : 'checked']) {\n\t\t\t\t\ts = this.get_node(p[i], true);\n\t\t\t\t\tif (s && s.length) {\n\t\t\t\t\t\ts.children('.jstree-anchor').children('.jstree-checkbox').addClass('jstree-undetermined');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tthis.redraw_node = function (obj, deep, is_callback, force_render) {\n\t\t\tobj = parent.redraw_node.apply(this, arguments);\n\t\t\tif (obj) {\n\t\t\t\tvar i,\n\t\t\t\t    j,\n\t\t\t\t    tmp = null,\n\t\t\t\t    icon = null;\n\t\t\t\tfor (i = 0, j = obj.childNodes.length; i < j; i++) {\n\t\t\t\t\tif (obj.childNodes[i] && obj.childNodes[i].className && obj.childNodes[i].className.indexOf(\"jstree-anchor\") !== -1) {\n\t\t\t\t\t\ttmp = obj.childNodes[i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (tmp) {\n\t\t\t\t\tif (!this.settings.checkbox.tie_selection && this._model.data[obj.id].state.checked) {\n\t\t\t\t\t\ttmp.className += ' jstree-checked';\n\t\t\t\t\t}\n\t\t\t\t\ticon = _i.cloneNode(false);\n\t\t\t\t\tif (this._model.data[obj.id].state.checkbox_disabled) {\n\t\t\t\t\t\ticon.className += ' jstree-checkbox-disabled';\n\t\t\t\t\t}\n\t\t\t\t\ttmp.insertBefore(icon, tmp.childNodes[0]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!is_callback && this.settings.checkbox.cascade.indexOf('undetermined') !== -1) {\n\t\t\t\tif (this._data.checkbox.uto) {\n\t\t\t\t\tclearTimeout(this._data.checkbox.uto);\n\t\t\t\t}\n\t\t\t\tthis._data.checkbox.uto = setTimeout($.proxy(this._undetermined, this), 50);\n\t\t\t}\n\t\t\treturn obj;\n\t\t};\n\t\t/**\n   * show the node checkbox icons\n   * @name show_checkboxes()\n   * @plugin checkbox\n   */\n\t\tthis.show_checkboxes = function () {\n\t\t\tthis._data.core.themes.checkboxes = true;this.get_container_ul().removeClass(\"jstree-no-checkboxes\");\n\t\t};\n\t\t/**\n   * hide the node checkbox icons\n   * @name hide_checkboxes()\n   * @plugin checkbox\n   */\n\t\tthis.hide_checkboxes = function () {\n\t\t\tthis._data.core.themes.checkboxes = false;this.get_container_ul().addClass(\"jstree-no-checkboxes\");\n\t\t};\n\t\t/**\n   * toggle the node icons\n   * @name toggle_checkboxes()\n   * @plugin checkbox\n   */\n\t\tthis.toggle_checkboxes = function () {\n\t\t\tif (this._data.core.themes.checkboxes) {\n\t\t\t\tthis.hide_checkboxes();\n\t\t\t} else {\n\t\t\t\tthis.show_checkboxes();\n\t\t\t}\n\t\t};\n\t\t/**\n   * checks if a node is in an undetermined state\n   * @name is_undetermined(obj)\n   * @param  {mixed} obj\n   * @return {Boolean}\n   */\n\t\tthis.is_undetermined = function (obj) {\n\t\t\tobj = this.get_node(obj);\n\t\t\tvar s = this.settings.checkbox.cascade,\n\t\t\t    i,\n\t\t\t    j,\n\t\t\t    t = this.settings.checkbox.tie_selection,\n\t\t\t    d = this._data[t ? 'core' : 'checkbox'].selected,\n\t\t\t    m = this._model.data;\n\t\t\tif (!obj || obj.state[t ? 'selected' : 'checked'] === true || s.indexOf('undetermined') === -1 || s.indexOf('down') === -1 && s.indexOf('up') === -1) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!obj.state.loaded && obj.original.state.undetermined === true) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tfor (i = 0, j = obj.children_d.length; i < j; i++) {\n\t\t\t\tif ($.inArray(obj.children_d[i], d) !== -1 || !m[obj.children_d[i]].state.loaded && m[obj.children_d[i]].original.state.undetermined) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\t/**\n   * disable a node's checkbox\n   * @name disable_checkbox(obj)\n   * @param {mixed} obj an array can be used too\n   * @trigger disable_checkbox.jstree\n   * @plugin checkbox\n   */\n\t\tthis.disable_checkbox = function (obj) {\n\t\t\tvar t1, t2, dom;\n\t\t\tif ($.isArray(obj)) {\n\t\t\t\tobj = obj.slice();\n\t\t\t\tfor (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n\t\t\t\t\tthis.disable_checkbox(obj[t1]);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tobj = this.get_node(obj);\n\t\t\tif (!obj || obj.id === $.jstree.root) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tdom = this.get_node(obj, true);\n\t\t\tif (!obj.state.checkbox_disabled) {\n\t\t\t\tobj.state.checkbox_disabled = true;\n\t\t\t\tif (dom && dom.length) {\n\t\t\t\t\tdom.children('.jstree-anchor').children('.jstree-checkbox').addClass('jstree-checkbox-disabled');\n\t\t\t\t}\n\t\t\t\t/**\n     * triggered when an node's checkbox is disabled\n     * @event\n     * @name disable_checkbox.jstree\n     * @param {Object} node\n     * @plugin checkbox\n     */\n\t\t\t\tthis.trigger('disable_checkbox', { 'node': obj });\n\t\t\t}\n\t\t};\n\t\t/**\n   * enable a node's checkbox\n   * @name disable_checkbox(obj)\n   * @param {mixed} obj an array can be used too\n   * @trigger enable_checkbox.jstree\n   * @plugin checkbox\n   */\n\t\tthis.enable_checkbox = function (obj) {\n\t\t\tvar t1, t2, dom;\n\t\t\tif ($.isArray(obj)) {\n\t\t\t\tobj = obj.slice();\n\t\t\t\tfor (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n\t\t\t\t\tthis.enable_checkbox(obj[t1]);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tobj = this.get_node(obj);\n\t\t\tif (!obj || obj.id === $.jstree.root) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tdom = this.get_node(obj, true);\n\t\t\tif (obj.state.checkbox_disabled) {\n\t\t\t\tobj.state.checkbox_disabled = false;\n\t\t\t\tif (dom && dom.length) {\n\t\t\t\t\tdom.children('.jstree-anchor').children('.jstree-checkbox').removeClass('jstree-checkbox-disabled');\n\t\t\t\t}\n\t\t\t\t/**\n     * triggered when an node's checkbox is enabled\n     * @event\n     * @name enable_checkbox.jstree\n     * @param {Object} node\n     * @plugin checkbox\n     */\n\t\t\t\tthis.trigger('enable_checkbox', { 'node': obj });\n\t\t\t}\n\t\t};\n\n\t\tthis.activate_node = function (obj, e) {\n\t\t\tif ($(e.target).hasClass('jstree-checkbox-disabled')) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (this.settings.checkbox.tie_selection && (this.settings.checkbox.whole_node || $(e.target).hasClass('jstree-checkbox'))) {\n\t\t\t\te.ctrlKey = true;\n\t\t\t}\n\t\t\tif (this.settings.checkbox.tie_selection || !this.settings.checkbox.whole_node && !$(e.target).hasClass('jstree-checkbox')) {\n\t\t\t\treturn parent.activate_node.call(this, obj, e);\n\t\t\t}\n\t\t\tif (this.is_disabled(obj)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (this.is_checked(obj)) {\n\t\t\t\tthis.uncheck_node(obj, e);\n\t\t\t} else {\n\t\t\t\tthis.check_node(obj, e);\n\t\t\t}\n\t\t\tthis.trigger('activate_node', { 'node': this.get_node(obj) });\n\t\t};\n\n\t\t/**\n   * check a node (only if tie_selection in checkbox settings is false, otherwise select_node will be called internally)\n   * @name check_node(obj)\n   * @param {mixed} obj an array can be used to check multiple nodes\n   * @trigger check_node.jstree\n   * @plugin checkbox\n   */\n\t\tthis.check_node = function (obj, e) {\n\t\t\tif (this.settings.checkbox.tie_selection) {\n\t\t\t\treturn this.select_node(obj, false, true, e);\n\t\t\t}\n\t\t\tvar dom, t1, t2, th;\n\t\t\tif ($.isArray(obj)) {\n\t\t\t\tobj = obj.slice();\n\t\t\t\tfor (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n\t\t\t\t\tthis.check_node(obj[t1], e);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tobj = this.get_node(obj);\n\t\t\tif (!obj || obj.id === $.jstree.root) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tdom = this.get_node(obj, true);\n\t\t\tif (!obj.state.checked) {\n\t\t\t\tobj.state.checked = true;\n\t\t\t\tthis._data.checkbox.selected.push(obj.id);\n\t\t\t\tif (dom && dom.length) {\n\t\t\t\t\tdom.children('.jstree-anchor').addClass('jstree-checked');\n\t\t\t\t}\n\t\t\t\t/**\n     * triggered when an node is checked (only if tie_selection in checkbox settings is false)\n     * @event\n     * @name check_node.jstree\n     * @param {Object} node\n     * @param {Array} selected the current selection\n     * @param {Object} event the event (if any) that triggered this check_node\n     * @plugin checkbox\n     */\n\t\t\t\tthis.trigger('check_node', { 'node': obj, 'selected': this._data.checkbox.selected, 'event': e });\n\t\t\t}\n\t\t};\n\t\t/**\n   * uncheck a node (only if tie_selection in checkbox settings is false, otherwise deselect_node will be called internally)\n   * @name uncheck_node(obj)\n   * @param {mixed} obj an array can be used to uncheck multiple nodes\n   * @trigger uncheck_node.jstree\n   * @plugin checkbox\n   */\n\t\tthis.uncheck_node = function (obj, e) {\n\t\t\tif (this.settings.checkbox.tie_selection) {\n\t\t\t\treturn this.deselect_node(obj, false, e);\n\t\t\t}\n\t\t\tvar t1, t2, dom;\n\t\t\tif ($.isArray(obj)) {\n\t\t\t\tobj = obj.slice();\n\t\t\t\tfor (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n\t\t\t\t\tthis.uncheck_node(obj[t1], e);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tobj = this.get_node(obj);\n\t\t\tif (!obj || obj.id === $.jstree.root) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tdom = this.get_node(obj, true);\n\t\t\tif (obj.state.checked) {\n\t\t\t\tobj.state.checked = false;\n\t\t\t\tthis._data.checkbox.selected = $.vakata.array_remove_item(this._data.checkbox.selected, obj.id);\n\t\t\t\tif (dom.length) {\n\t\t\t\t\tdom.children('.jstree-anchor').removeClass('jstree-checked');\n\t\t\t\t}\n\t\t\t\t/**\n     * triggered when an node is unchecked (only if tie_selection in checkbox settings is false)\n     * @event\n     * @name uncheck_node.jstree\n     * @param {Object} node\n     * @param {Array} selected the current selection\n     * @param {Object} event the event (if any) that triggered this uncheck_node\n     * @plugin checkbox\n     */\n\t\t\t\tthis.trigger('uncheck_node', { 'node': obj, 'selected': this._data.checkbox.selected, 'event': e });\n\t\t\t}\n\t\t};\n\t\t/**\n   * checks all nodes in the tree (only if tie_selection in checkbox settings is false, otherwise select_all will be called internally)\n   * @name check_all()\n   * @trigger check_all.jstree, changed.jstree\n   * @plugin checkbox\n   */\n\t\tthis.check_all = function () {\n\t\t\tif (this.settings.checkbox.tie_selection) {\n\t\t\t\treturn this.select_all();\n\t\t\t}\n\t\t\tvar tmp = this._data.checkbox.selected.concat([]),\n\t\t\t    i,\n\t\t\t    j;\n\t\t\tthis._data.checkbox.selected = this._model.data[$.jstree.root].children_d.concat();\n\t\t\tfor (i = 0, j = this._data.checkbox.selected.length; i < j; i++) {\n\t\t\t\tif (this._model.data[this._data.checkbox.selected[i]]) {\n\t\t\t\t\tthis._model.data[this._data.checkbox.selected[i]].state.checked = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.redraw(true);\n\t\t\t/**\n    * triggered when all nodes are checked (only if tie_selection in checkbox settings is false)\n    * @event\n    * @name check_all.jstree\n    * @param {Array} selected the current selection\n    * @plugin checkbox\n    */\n\t\t\tthis.trigger('check_all', { 'selected': this._data.checkbox.selected });\n\t\t};\n\t\t/**\n   * uncheck all checked nodes (only if tie_selection in checkbox settings is false, otherwise deselect_all will be called internally)\n   * @name uncheck_all()\n   * @trigger uncheck_all.jstree\n   * @plugin checkbox\n   */\n\t\tthis.uncheck_all = function () {\n\t\t\tif (this.settings.checkbox.tie_selection) {\n\t\t\t\treturn this.deselect_all();\n\t\t\t}\n\t\t\tvar tmp = this._data.checkbox.selected.concat([]),\n\t\t\t    i,\n\t\t\t    j;\n\t\t\tfor (i = 0, j = this._data.checkbox.selected.length; i < j; i++) {\n\t\t\t\tif (this._model.data[this._data.checkbox.selected[i]]) {\n\t\t\t\t\tthis._model.data[this._data.checkbox.selected[i]].state.checked = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._data.checkbox.selected = [];\n\t\t\tthis.element.find('.jstree-checked').removeClass('jstree-checked');\n\t\t\t/**\n    * triggered when all nodes are unchecked (only if tie_selection in checkbox settings is false)\n    * @event\n    * @name uncheck_all.jstree\n    * @param {Object} node the previous selection\n    * @param {Array} selected the current selection\n    * @plugin checkbox\n    */\n\t\t\tthis.trigger('uncheck_all', { 'selected': this._data.checkbox.selected, 'node': tmp });\n\t\t};\n\t\t/**\n   * checks if a node is checked (if tie_selection is on in the settings this function will return the same as is_selected)\n   * @name is_checked(obj)\n   * @param  {mixed}  obj\n   * @return {Boolean}\n   * @plugin checkbox\n   */\n\t\tthis.is_checked = function (obj) {\n\t\t\tif (this.settings.checkbox.tie_selection) {\n\t\t\t\treturn this.is_selected(obj);\n\t\t\t}\n\t\t\tobj = this.get_node(obj);\n\t\t\tif (!obj || obj.id === $.jstree.root) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn obj.state.checked;\n\t\t};\n\t\t/**\n   * get an array of all checked nodes (if tie_selection is on in the settings this function will return the same as get_selected)\n   * @name get_checked([full])\n   * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned\n   * @return {Array}\n   * @plugin checkbox\n   */\n\t\tthis.get_checked = function (full) {\n\t\t\tif (this.settings.checkbox.tie_selection) {\n\t\t\t\treturn this.get_selected(full);\n\t\t\t}\n\t\t\treturn full ? $.map(this._data.checkbox.selected, $.proxy(function (i) {\n\t\t\t\treturn this.get_node(i);\n\t\t\t}, this)) : this._data.checkbox.selected;\n\t\t};\n\t\t/**\n   * get an array of all top level checked nodes (ignoring children of checked nodes) (if tie_selection is on in the settings this function will return the same as get_top_selected)\n   * @name get_top_checked([full])\n   * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned\n   * @return {Array}\n   * @plugin checkbox\n   */\n\t\tthis.get_top_checked = function (full) {\n\t\t\tif (this.settings.checkbox.tie_selection) {\n\t\t\t\treturn this.get_top_selected(full);\n\t\t\t}\n\t\t\tvar tmp = this.get_checked(true),\n\t\t\t    obj = {},\n\t\t\t    i,\n\t\t\t    j,\n\t\t\t    k,\n\t\t\t    l;\n\t\t\tfor (i = 0, j = tmp.length; i < j; i++) {\n\t\t\t\tobj[tmp[i].id] = tmp[i];\n\t\t\t}\n\t\t\tfor (i = 0, j = tmp.length; i < j; i++) {\n\t\t\t\tfor (k = 0, l = tmp[i].children_d.length; k < l; k++) {\n\t\t\t\t\tif (obj[tmp[i].children_d[k]]) {\n\t\t\t\t\t\tdelete obj[tmp[i].children_d[k]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ttmp = [];\n\t\t\tfor (i in obj) {\n\t\t\t\tif (obj.hasOwnProperty(i)) {\n\t\t\t\t\ttmp.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn full ? $.map(tmp, $.proxy(function (i) {\n\t\t\t\treturn this.get_node(i);\n\t\t\t}, this)) : tmp;\n\t\t};\n\t\t/**\n   * get an array of all bottom level checked nodes (ignoring selected parents) (if tie_selection is on in the settings this function will return the same as get_bottom_selected)\n   * @name get_bottom_checked([full])\n   * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned\n   * @return {Array}\n   * @plugin checkbox\n   */\n\t\tthis.get_bottom_checked = function (full) {\n\t\t\tif (this.settings.checkbox.tie_selection) {\n\t\t\t\treturn this.get_bottom_selected(full);\n\t\t\t}\n\t\t\tvar tmp = this.get_checked(true),\n\t\t\t    obj = [],\n\t\t\t    i,\n\t\t\t    j;\n\t\t\tfor (i = 0, j = tmp.length; i < j; i++) {\n\t\t\t\tif (!tmp[i].children.length) {\n\t\t\t\t\tobj.push(tmp[i].id);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn full ? $.map(obj, $.proxy(function (i) {\n\t\t\t\treturn this.get_node(i);\n\t\t\t}, this)) : obj;\n\t\t};\n\t\tthis.load_node = function (obj, callback) {\n\t\t\tvar k, l, i, j, c, tmp;\n\t\t\tif (!$.isArray(obj) && !this.settings.checkbox.tie_selection) {\n\t\t\t\ttmp = this.get_node(obj);\n\t\t\t\tif (tmp && tmp.state.loaded) {\n\t\t\t\t\tfor (k = 0, l = tmp.children_d.length; k < l; k++) {\n\t\t\t\t\t\tif (this._model.data[tmp.children_d[k]].state.checked) {\n\t\t\t\t\t\t\tc = true;\n\t\t\t\t\t\t\tthis._data.checkbox.selected = $.vakata.array_remove_item(this._data.checkbox.selected, tmp.children_d[k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn parent.load_node.apply(this, arguments);\n\t\t};\n\t\tthis.get_state = function () {\n\t\t\tvar state = parent.get_state.apply(this, arguments);\n\t\t\tif (this.settings.checkbox.tie_selection) {\n\t\t\t\treturn state;\n\t\t\t}\n\t\t\tstate.checkbox = this._data.checkbox.selected.slice();\n\t\t\treturn state;\n\t\t};\n\t\tthis.set_state = function (state, callback) {\n\t\t\tvar res = parent.set_state.apply(this, arguments);\n\t\t\tif (res && state.checkbox) {\n\t\t\t\tif (!this.settings.checkbox.tie_selection) {\n\t\t\t\t\tthis.uncheck_all();\n\t\t\t\t\tvar _this = this;\n\t\t\t\t\t$.each(state.checkbox, function (i, v) {\n\t\t\t\t\t\t_this.check_node(v);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tdelete state.checkbox;\n\t\t\t\tthis.set_state(state, callback);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn res;\n\t\t};\n\t\tthis.refresh = function (skip_loading, forget_state) {\n\t\t\tif (!this.settings.checkbox.tie_selection) {\n\t\t\t\tthis._data.checkbox.selected = [];\n\t\t\t}\n\t\t\treturn parent.refresh.apply(this, arguments);\n\t\t};\n\t};\n\n\t// include the checkbox plugin by default\n\t// $.jstree.defaults.plugins.push(\"checkbox\");\n\n\t/**\n  * ### Conditionalselect plugin\n  *\n  * This plugin allows defining a callback to allow or deny node selection by user input (activate node method).\n  */\n\n\t/**\n  * a callback (function) which is invoked in the instance's scope and receives two arguments - the node and the event that triggered the `activate_node` call. Returning false prevents working with the node, returning true allows invoking activate_node. Defaults to returning `true`.\n  * @name $.jstree.defaults.checkbox.visible\n  * @plugin checkbox\n  */\n\t$.jstree.defaults.conditionalselect = function () {\n\t\treturn true;\n\t};\n\t$.jstree.plugins.conditionalselect = function (options, parent) {\n\t\t// own function\n\t\tthis.activate_node = function (obj, e) {\n\t\t\tif (this.settings.conditionalselect.call(this, this.get_node(obj), e)) {\n\t\t\t\tparent.activate_node.call(this, obj, e);\n\t\t\t}\n\t\t};\n\t};\n\n\t/**\n  * ### Contextmenu plugin\n  *\n  * Shows a context menu when a node is right-clicked.\n  */\n\n\t/**\n  * stores all defaults for the contextmenu plugin\n  * @name $.jstree.defaults.contextmenu\n  * @plugin contextmenu\n  */\n\t$.jstree.defaults.contextmenu = {\n\t\t/**\n   * a boolean indicating if the node should be selected when the context menu is invoked on it. Defaults to `true`.\n   * @name $.jstree.defaults.contextmenu.select_node\n   * @plugin contextmenu\n   */\n\t\tselect_node: true,\n\t\t/**\n   * a boolean indicating if the menu should be shown aligned with the node. Defaults to `true`, otherwise the mouse coordinates are used.\n   * @name $.jstree.defaults.contextmenu.show_at_node\n   * @plugin contextmenu\n   */\n\t\tshow_at_node: true,\n\t\t/**\n   * an object of actions, or a function that accepts a node and a callback function and calls the callback function with an object of actions available for that node (you can also return the items too).\n   *\n   * Each action consists of a key (a unique name) and a value which is an object with the following properties (only label and action are required). Once a menu item is activated the `action` function will be invoked with an object containing the following keys: item - the contextmenu item definition as seen below, reference - the DOM node that was used (the tree node), element - the contextmenu DOM element, position - an object with x/y properties indicating the position of the menu.\n   *\n   * * `separator_before` - a boolean indicating if there should be a separator before this item\n   * * `separator_after` - a boolean indicating if there should be a separator after this item\n   * * `_disabled` - a boolean indicating if this action should be disabled\n   * * `label` - a string - the name of the action (could be a function returning a string)\n   * * `title` - a string - an optional tooltip for the item\n   * * `action` - a function to be executed if this item is chosen, the function will receive \n   * * `icon` - a string, can be a path to an icon or a className, if using an image that is in the current directory use a `./` prefix, otherwise it will be detected as a class\n   * * `shortcut` - keyCode which will trigger the action if the menu is open (for example `113` for rename, which equals F2)\n   * * `shortcut_label` - shortcut label (like for example `F2` for rename)\n   * * `submenu` - an object with the same structure as $.jstree.defaults.contextmenu.items which can be used to create a submenu - each key will be rendered as a separate option in a submenu that will appear once the current item is hovered\n   *\n   * @name $.jstree.defaults.contextmenu.items\n   * @plugin contextmenu\n   */\n\t\titems: function items(o, cb) {\n\t\t\t// Could be an object directly\n\t\t\treturn {\n\t\t\t\t\"create\": {\n\t\t\t\t\t\"separator_before\": false,\n\t\t\t\t\t\"separator_after\": true,\n\t\t\t\t\t\"_disabled\": false, //(this.check(\"create_node\", data.reference, {}, \"last\")),\n\t\t\t\t\t\"label\": \"Create\",\n\t\t\t\t\t\"action\": function action(data) {\n\t\t\t\t\t\tvar inst = $.jstree.reference(data.reference),\n\t\t\t\t\t\t    obj = inst.get_node(data.reference);\n\t\t\t\t\t\tinst.create_node(obj, {}, \"last\", function (new_node) {\n\t\t\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\t\t\tinst.edit(new_node);\n\t\t\t\t\t\t\t}, 0);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"rename\": {\n\t\t\t\t\t\"separator_before\": false,\n\t\t\t\t\t\"separator_after\": false,\n\t\t\t\t\t\"_disabled\": false, //(this.check(\"rename_node\", data.reference, this.get_parent(data.reference), \"\")),\n\t\t\t\t\t\"label\": \"Rename\",\n\t\t\t\t\t/*!\n     \"shortcut\"\t\t\t: 113,\n     \"shortcut_label\"\t: 'F2',\n     \"icon\"\t\t\t\t: \"glyphicon glyphicon-leaf\",\n     */\n\t\t\t\t\t\"action\": function action(data) {\n\t\t\t\t\t\tvar inst = $.jstree.reference(data.reference),\n\t\t\t\t\t\t    obj = inst.get_node(data.reference);\n\t\t\t\t\t\tinst.edit(obj);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"remove\": {\n\t\t\t\t\t\"separator_before\": false,\n\t\t\t\t\t\"icon\": false,\n\t\t\t\t\t\"separator_after\": false,\n\t\t\t\t\t\"_disabled\": false, //(this.check(\"delete_node\", data.reference, this.get_parent(data.reference), \"\")),\n\t\t\t\t\t\"label\": \"Delete\",\n\t\t\t\t\t\"action\": function action(data) {\n\t\t\t\t\t\tvar inst = $.jstree.reference(data.reference),\n\t\t\t\t\t\t    obj = inst.get_node(data.reference);\n\t\t\t\t\t\tif (inst.is_selected(obj)) {\n\t\t\t\t\t\t\tinst.delete_node(inst.get_selected());\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tinst.delete_node(obj);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"ccp\": {\n\t\t\t\t\t\"separator_before\": true,\n\t\t\t\t\t\"icon\": false,\n\t\t\t\t\t\"separator_after\": false,\n\t\t\t\t\t\"label\": \"Edit\",\n\t\t\t\t\t\"action\": false,\n\t\t\t\t\t\"submenu\": {\n\t\t\t\t\t\t\"cut\": {\n\t\t\t\t\t\t\t\"separator_before\": false,\n\t\t\t\t\t\t\t\"separator_after\": false,\n\t\t\t\t\t\t\t\"label\": \"Cut\",\n\t\t\t\t\t\t\t\"action\": function action(data) {\n\t\t\t\t\t\t\t\tvar inst = $.jstree.reference(data.reference),\n\t\t\t\t\t\t\t\t    obj = inst.get_node(data.reference);\n\t\t\t\t\t\t\t\tif (inst.is_selected(obj)) {\n\t\t\t\t\t\t\t\t\tinst.cut(inst.get_top_selected());\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tinst.cut(obj);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"copy\": {\n\t\t\t\t\t\t\t\"separator_before\": false,\n\t\t\t\t\t\t\t\"icon\": false,\n\t\t\t\t\t\t\t\"separator_after\": false,\n\t\t\t\t\t\t\t\"label\": \"Copy\",\n\t\t\t\t\t\t\t\"action\": function action(data) {\n\t\t\t\t\t\t\t\tvar inst = $.jstree.reference(data.reference),\n\t\t\t\t\t\t\t\t    obj = inst.get_node(data.reference);\n\t\t\t\t\t\t\t\tif (inst.is_selected(obj)) {\n\t\t\t\t\t\t\t\t\tinst.copy(inst.get_top_selected());\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tinst.copy(obj);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"paste\": {\n\t\t\t\t\t\t\t\"separator_before\": false,\n\t\t\t\t\t\t\t\"icon\": false,\n\t\t\t\t\t\t\t\"_disabled\": function _disabled(data) {\n\t\t\t\t\t\t\t\treturn !$.jstree.reference(data.reference).can_paste();\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"separator_after\": false,\n\t\t\t\t\t\t\t\"label\": \"Paste\",\n\t\t\t\t\t\t\t\"action\": function action(data) {\n\t\t\t\t\t\t\t\tvar inst = $.jstree.reference(data.reference),\n\t\t\t\t\t\t\t\t    obj = inst.get_node(data.reference);\n\t\t\t\t\t\t\t\tinst.paste(obj);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t};\n\n\t$.jstree.plugins.contextmenu = function (options, parent) {\n\t\tthis.bind = function () {\n\t\t\tparent.bind.call(this);\n\n\t\t\tvar last_ts = 0,\n\t\t\t    cto = null,\n\t\t\t    ex,\n\t\t\t    ey;\n\t\t\tthis.element.on(\"contextmenu.jstree\", \".jstree-anchor\", $.proxy(function (e, data) {\n\t\t\t\tif (e.target.tagName.toLowerCase() === 'input') {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\te.preventDefault();\n\t\t\t\tlast_ts = e.ctrlKey ? +new Date() : 0;\n\t\t\t\tif (data || cto) {\n\t\t\t\t\tlast_ts = +new Date() + 10000;\n\t\t\t\t}\n\t\t\t\tif (cto) {\n\t\t\t\t\tclearTimeout(cto);\n\t\t\t\t}\n\t\t\t\tif (!this.is_loading(e.currentTarget)) {\n\t\t\t\t\tthis.show_contextmenu(e.currentTarget, e.pageX, e.pageY, e);\n\t\t\t\t}\n\t\t\t}, this)).on(\"click.jstree\", \".jstree-anchor\", $.proxy(function (e) {\n\t\t\t\tif (this._data.contextmenu.visible && (!last_ts || +new Date() - last_ts > 250)) {\n\t\t\t\t\t// work around safari & macOS ctrl+click\n\t\t\t\t\t$.vakata.context.hide();\n\t\t\t\t}\n\t\t\t\tlast_ts = 0;\n\t\t\t}, this)).on(\"touchstart.jstree\", \".jstree-anchor\", function (e) {\n\t\t\t\tif (!e.originalEvent || !e.originalEvent.changedTouches || !e.originalEvent.changedTouches[0]) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tex = e.originalEvent.changedTouches[0].clientX;\n\t\t\t\tey = e.originalEvent.changedTouches[0].clientY;\n\t\t\t\tcto = setTimeout(function () {\n\t\t\t\t\t$(e.currentTarget).trigger('contextmenu', true);\n\t\t\t\t}, 750);\n\t\t\t}).on('touchmove.vakata.jstree', function (e) {\n\t\t\t\tif (cto && e.originalEvent && e.originalEvent.changedTouches && e.originalEvent.changedTouches[0] && (Math.abs(ex - e.originalEvent.changedTouches[0].clientX) > 50 || Math.abs(ey - e.originalEvent.changedTouches[0].clientY) > 50)) {\n\t\t\t\t\tclearTimeout(cto);\n\t\t\t\t}\n\t\t\t}).on('touchend.vakata.jstree', function (e) {\n\t\t\t\tif (cto) {\n\t\t\t\t\tclearTimeout(cto);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t/*!\n   if(!('oncontextmenu' in document.body) && ('ontouchstart' in document.body)) {\n   \tvar el = null, tm = null;\n   \tthis.element\n   \t\t.on(\"touchstart\", \".jstree-anchor\", function (e) {\n   \t\t\tel = e.currentTarget;\n   \t\t\ttm = +new Date();\n   \t\t\t$(document).one(\"touchend\", function (e) {\n   \t\t\t\te.target = document.elementFromPoint(e.originalEvent.targetTouches[0].pageX - window.pageXOffset, e.originalEvent.targetTouches[0].pageY - window.pageYOffset);\n   \t\t\t\te.currentTarget = e.target;\n   \t\t\t\ttm = ((+(new Date())) - tm);\n   \t\t\t\tif(e.target === el && tm > 600 && tm < 1000) {\n   \t\t\t\t\te.preventDefault();\n   \t\t\t\t\t$(el).trigger('contextmenu', e);\n   \t\t\t\t}\n   \t\t\t\tel = null;\n   \t\t\t\ttm = null;\n   \t\t\t});\n   \t\t});\n   }\n   */\n\t\t\t$(document).on(\"context_hide.vakata.jstree\", $.proxy(function (e, data) {\n\t\t\t\tthis._data.contextmenu.visible = false;\n\t\t\t\t$(data.reference).removeClass('jstree-context');\n\t\t\t}, this));\n\t\t};\n\t\tthis.teardown = function () {\n\t\t\tif (this._data.contextmenu.visible) {\n\t\t\t\t$.vakata.context.hide();\n\t\t\t}\n\t\t\tparent.teardown.call(this);\n\t\t};\n\n\t\t/**\n   * prepare and show the context menu for a node\n   * @name show_contextmenu(obj [, x, y])\n   * @param {mixed} obj the node\n   * @param {Number} x the x-coordinate relative to the document to show the menu at\n   * @param {Number} y the y-coordinate relative to the document to show the menu at\n   * @param {Object} e the event if available that triggered the contextmenu\n   * @plugin contextmenu\n   * @trigger show_contextmenu.jstree\n   */\n\t\tthis.show_contextmenu = function (obj, x, y, e) {\n\t\t\tobj = this.get_node(obj);\n\t\t\tif (!obj || obj.id === $.jstree.root) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar s = this.settings.contextmenu,\n\t\t\t    d = this.get_node(obj, true),\n\t\t\t    a = d.children(\".jstree-anchor\"),\n\t\t\t    o = false,\n\t\t\t    i = false;\n\t\t\tif (s.show_at_node || x === undefined || y === undefined) {\n\t\t\t\to = a.offset();\n\t\t\t\tx = o.left;\n\t\t\t\ty = o.top + this._data.core.li_height;\n\t\t\t}\n\t\t\tif (this.settings.contextmenu.select_node && !this.is_selected(obj)) {\n\t\t\t\tthis.activate_node(obj, e);\n\t\t\t}\n\n\t\t\ti = s.items;\n\t\t\tif ($.isFunction(i)) {\n\t\t\t\ti = i.call(this, obj, $.proxy(function (i) {\n\t\t\t\t\tthis._show_contextmenu(obj, x, y, i);\n\t\t\t\t}, this));\n\t\t\t}\n\t\t\tif ($.isPlainObject(i)) {\n\t\t\t\tthis._show_contextmenu(obj, x, y, i);\n\t\t\t}\n\t\t};\n\t\t/**\n   * show the prepared context menu for a node\n   * @name _show_contextmenu(obj, x, y, i)\n   * @param {mixed} obj the node\n   * @param {Number} x the x-coordinate relative to the document to show the menu at\n   * @param {Number} y the y-coordinate relative to the document to show the menu at\n   * @param {Number} i the object of items to show\n   * @plugin contextmenu\n   * @trigger show_contextmenu.jstree\n   * @private\n   */\n\t\tthis._show_contextmenu = function (obj, x, y, i) {\n\t\t\tvar d = this.get_node(obj, true),\n\t\t\t    a = d.children(\".jstree-anchor\");\n\t\t\t$(document).one(\"context_show.vakata.jstree\", $.proxy(function (e, data) {\n\t\t\t\tvar cls = 'jstree-contextmenu jstree-' + this.get_theme() + '-contextmenu';\n\t\t\t\t$(data.element).addClass(cls);\n\t\t\t\ta.addClass('jstree-context');\n\t\t\t}, this));\n\t\t\tthis._data.contextmenu.visible = true;\n\t\t\t$.vakata.context.show(a, { 'x': x, 'y': y }, i);\n\t\t\t/**\n    * triggered when the contextmenu is shown for a node\n    * @event\n    * @name show_contextmenu.jstree\n    * @param {Object} node the node\n    * @param {Number} x the x-coordinate of the menu relative to the document\n    * @param {Number} y the y-coordinate of the menu relative to the document\n    * @plugin contextmenu\n    */\n\t\t\tthis.trigger('show_contextmenu', { \"node\": obj, \"x\": x, \"y\": y });\n\t\t};\n\t};\n\n\t// contextmenu helper\n\t(function ($) {\n\t\tvar right_to_left = false,\n\t\t    vakata_context = {\n\t\t\telement: false,\n\t\t\treference: false,\n\t\t\tposition_x: 0,\n\t\t\tposition_y: 0,\n\t\t\titems: [],\n\t\t\thtml: \"\",\n\t\t\tis_visible: false\n\t\t};\n\n\t\t$.vakata.context = {\n\t\t\tsettings: {\n\t\t\t\thide_onmouseleave: 0,\n\t\t\t\ticons: true\n\t\t\t},\n\t\t\t_trigger: function _trigger(event_name) {\n\t\t\t\t$(document).triggerHandler(\"context_\" + event_name + \".vakata\", {\n\t\t\t\t\t\"reference\": vakata_context.reference,\n\t\t\t\t\t\"element\": vakata_context.element,\n\t\t\t\t\t\"position\": {\n\t\t\t\t\t\t\"x\": vakata_context.position_x,\n\t\t\t\t\t\t\"y\": vakata_context.position_y\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\t\t\t_execute: function _execute(i) {\n\t\t\t\ti = vakata_context.items[i];\n\t\t\t\treturn i && (!i._disabled || $.isFunction(i._disabled) && !i._disabled({ \"item\": i, \"reference\": vakata_context.reference, \"element\": vakata_context.element })) && i.action ? i.action.call(null, {\n\t\t\t\t\t\"item\": i,\n\t\t\t\t\t\"reference\": vakata_context.reference,\n\t\t\t\t\t\"element\": vakata_context.element,\n\t\t\t\t\t\"position\": {\n\t\t\t\t\t\t\"x\": vakata_context.position_x,\n\t\t\t\t\t\t\"y\": vakata_context.position_y\n\t\t\t\t\t}\n\t\t\t\t}) : false;\n\t\t\t},\n\t\t\t_parse: function _parse(o, is_callback) {\n\t\t\t\tif (!o) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (!is_callback) {\n\t\t\t\t\tvakata_context.html = \"\";\n\t\t\t\t\tvakata_context.items = [];\n\t\t\t\t}\n\t\t\t\tvar str = \"\",\n\t\t\t\t    sep = false,\n\t\t\t\t    tmp;\n\n\t\t\t\tif (is_callback) {\n\t\t\t\t\tstr += \"<\" + \"ul>\";\n\t\t\t\t}\n\t\t\t\t$.each(o, function (i, val) {\n\t\t\t\t\tif (!val) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tvakata_context.items.push(val);\n\t\t\t\t\tif (!sep && val.separator_before) {\n\t\t\t\t\t\tstr += \"<\" + \"li class='vakata-context-separator'><\" + \"a href='#' \" + ($.vakata.context.settings.icons ? '' : 'style=\"margin-left:0px;\"') + \">&#160;<\" + \"/a><\" + \"/li>\";\n\t\t\t\t\t}\n\t\t\t\t\tsep = false;\n\t\t\t\t\tstr += \"<\" + \"li class='\" + (val._class || \"\") + (val._disabled === true || $.isFunction(val._disabled) && val._disabled({ \"item\": val, \"reference\": vakata_context.reference, \"element\": vakata_context.element }) ? \" vakata-contextmenu-disabled \" : \"\") + \"' \" + (val.shortcut ? \" data-shortcut='\" + val.shortcut + \"' \" : '') + \">\";\n\t\t\t\t\tstr += \"<\" + \"a href='#' rel='\" + (vakata_context.items.length - 1) + \"' \" + (val.title ? \"title='\" + val.title + \"'\" : \"\") + \">\";\n\t\t\t\t\tif ($.vakata.context.settings.icons) {\n\t\t\t\t\t\tstr += \"<\" + \"i \";\n\t\t\t\t\t\tif (val.icon) {\n\t\t\t\t\t\t\tif (val.icon.indexOf(\"/\") !== -1 || val.icon.indexOf(\".\") !== -1) {\n\t\t\t\t\t\t\t\tstr += \" style='background:url(\\\"\" + val.icon + \"\\\") center center no-repeat' \";\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tstr += \" class='\" + val.icon + \"' \";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstr += \"><\" + \"/i><\" + \"span class='vakata-contextmenu-sep'>&#160;<\" + \"/span>\";\n\t\t\t\t\t}\n\t\t\t\t\tstr += ($.isFunction(val.label) ? val.label({ \"item\": i, \"reference\": vakata_context.reference, \"element\": vakata_context.element }) : val.label) + (val.shortcut ? ' <span class=\"vakata-contextmenu-shortcut vakata-contextmenu-shortcut-' + val.shortcut + '\">' + (val.shortcut_label || '') + '</span>' : '') + \"<\" + \"/a>\";\n\t\t\t\t\tif (val.submenu) {\n\t\t\t\t\t\ttmp = $.vakata.context._parse(val.submenu, true);\n\t\t\t\t\t\tif (tmp) {\n\t\t\t\t\t\t\tstr += tmp;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tstr += \"<\" + \"/li>\";\n\t\t\t\t\tif (val.separator_after) {\n\t\t\t\t\t\tstr += \"<\" + \"li class='vakata-context-separator'><\" + \"a href='#' \" + ($.vakata.context.settings.icons ? '' : 'style=\"margin-left:0px;\"') + \">&#160;<\" + \"/a><\" + \"/li>\";\n\t\t\t\t\t\tsep = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tstr = str.replace(/<li class\\='vakata-context-separator'\\><\\/li\\>$/, \"\");\n\t\t\t\tif (is_callback) {\n\t\t\t\t\tstr += \"</ul>\";\n\t\t\t\t}\n\t\t\t\t/**\n     * triggered on the document when the contextmenu is parsed (HTML is built)\n     * @event\n     * @plugin contextmenu\n     * @name context_parse.vakata\n     * @param {jQuery} reference the element that was right clicked\n     * @param {jQuery} element the DOM element of the menu itself\n     * @param {Object} position the x & y coordinates of the menu\n     */\n\t\t\t\tif (!is_callback) {\n\t\t\t\t\tvakata_context.html = str;$.vakata.context._trigger(\"parse\");\n\t\t\t\t}\n\t\t\t\treturn str.length > 10 ? str : false;\n\t\t\t},\n\t\t\t_show_submenu: function _show_submenu(o) {\n\t\t\t\to = $(o);\n\t\t\t\tif (!o.length || !o.children(\"ul\").length) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar e = o.children(\"ul\"),\n\t\t\t\t    xl = o.offset().left,\n\t\t\t\t    x = xl + o.outerWidth(),\n\t\t\t\t    y = o.offset().top,\n\t\t\t\t    w = e.width(),\n\t\t\t\t    h = e.height(),\n\t\t\t\t    dw = $(window).width() + $(window).scrollLeft(),\n\t\t\t\t    dh = $(window).height() + $(window).scrollTop();\n\t\t\t\t//        -       \n\t\t\t\tif (right_to_left) {\n\t\t\t\t\to[x - (w + 10 + o.outerWidth()) < 0 ? \"addClass\" : \"removeClass\"](\"vakata-context-left\");\n\t\t\t\t} else {\n\t\t\t\t\to[x + w > dw && xl > dw - x ? \"addClass\" : \"removeClass\"](\"vakata-context-right\");\n\t\t\t\t}\n\t\t\t\tif (y + h + 10 > dh) {\n\t\t\t\t\te.css(\"bottom\", \"-1px\");\n\t\t\t\t}\n\n\t\t\t\t//if does not fit - stick it to the side\n\t\t\t\tif (o.hasClass('vakata-context-right')) {\n\t\t\t\t\tif (xl < w) {\n\t\t\t\t\t\te.css(\"margin-right\", xl - w);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (dw - x < w) {\n\t\t\t\t\t\te.css(\"margin-left\", dw - x - w);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\te.show();\n\t\t\t},\n\t\t\tshow: function show(reference, position, data) {\n\t\t\t\tvar o,\n\t\t\t\t    e,\n\t\t\t\t    x,\n\t\t\t\t    y,\n\t\t\t\t    w,\n\t\t\t\t    h,\n\t\t\t\t    dw,\n\t\t\t\t    dh,\n\t\t\t\t    cond = true;\n\t\t\t\tif (vakata_context.element && vakata_context.element.length) {\n\t\t\t\t\tvakata_context.element.width('');\n\t\t\t\t}\n\t\t\t\tswitch (cond) {\n\t\t\t\t\tcase !position && !reference:\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tcase !!position && !!reference:\n\t\t\t\t\t\tvakata_context.reference = reference;\n\t\t\t\t\t\tvakata_context.position_x = position.x;\n\t\t\t\t\t\tvakata_context.position_y = position.y;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase !position && !!reference:\n\t\t\t\t\t\tvakata_context.reference = reference;\n\t\t\t\t\t\to = reference.offset();\n\t\t\t\t\t\tvakata_context.position_x = o.left + reference.outerHeight();\n\t\t\t\t\t\tvakata_context.position_y = o.top;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase !!position && !reference:\n\t\t\t\t\t\tvakata_context.position_x = position.x;\n\t\t\t\t\t\tvakata_context.position_y = position.y;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!!reference && !data && $(reference).data('vakata_contextmenu')) {\n\t\t\t\t\tdata = $(reference).data('vakata_contextmenu');\n\t\t\t\t}\n\t\t\t\tif ($.vakata.context._parse(data)) {\n\t\t\t\t\tvakata_context.element.html(vakata_context.html);\n\t\t\t\t}\n\t\t\t\tif (vakata_context.items.length) {\n\t\t\t\t\tvakata_context.element.appendTo(\"body\");\n\t\t\t\t\te = vakata_context.element;\n\t\t\t\t\tx = vakata_context.position_x;\n\t\t\t\t\ty = vakata_context.position_y;\n\t\t\t\t\tw = e.width();\n\t\t\t\t\th = e.height();\n\t\t\t\t\tdw = $(window).width() + $(window).scrollLeft();\n\t\t\t\t\tdh = $(window).height() + $(window).scrollTop();\n\t\t\t\t\tif (right_to_left) {\n\t\t\t\t\t\tx -= e.outerWidth() - $(reference).outerWidth();\n\t\t\t\t\t\tif (x < $(window).scrollLeft() + 20) {\n\t\t\t\t\t\t\tx = $(window).scrollLeft() + 20;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (x + w + 20 > dw) {\n\t\t\t\t\t\tx = dw - (w + 20);\n\t\t\t\t\t}\n\t\t\t\t\tif (y + h + 20 > dh) {\n\t\t\t\t\t\ty = dh - (h + 20);\n\t\t\t\t\t}\n\n\t\t\t\t\tvakata_context.element.css({ \"left\": x, \"top\": y }).show().find('a').first().focus().parent().addClass(\"vakata-context-hover\");\n\t\t\t\t\tvakata_context.is_visible = true;\n\t\t\t\t\t/**\n      * triggered on the document when the contextmenu is shown\n      * @event\n      * @plugin contextmenu\n      * @name context_show.vakata\n      * @param {jQuery} reference the element that was right clicked\n      * @param {jQuery} element the DOM element of the menu itself\n      * @param {Object} position the x & y coordinates of the menu\n      */\n\t\t\t\t\t$.vakata.context._trigger(\"show\");\n\t\t\t\t}\n\t\t\t},\n\t\t\thide: function hide() {\n\t\t\t\tif (vakata_context.is_visible) {\n\t\t\t\t\tvakata_context.element.hide().find(\"ul\").hide().end().find(':focus').blur().end().detach();\n\t\t\t\t\tvakata_context.is_visible = false;\n\t\t\t\t\t/**\n      * triggered on the document when the contextmenu is hidden\n      * @event\n      * @plugin contextmenu\n      * @name context_hide.vakata\n      * @param {jQuery} reference the element that was right clicked\n      * @param {jQuery} element the DOM element of the menu itself\n      * @param {Object} position the x & y coordinates of the menu\n      */\n\t\t\t\t\t$.vakata.context._trigger(\"hide\");\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\t$(function () {\n\t\t\tright_to_left = $(\"body\").css(\"direction\") === \"rtl\";\n\t\t\tvar to = false;\n\n\t\t\tvakata_context.element = $(\"<ul class='vakata-context'></ul>\");\n\t\t\tvakata_context.element.on(\"mouseenter\", \"li\", function (e) {\n\t\t\t\te.stopImmediatePropagation();\n\n\t\t\t\tif ($.contains(this, e.relatedTarget)) {\n\t\t\t\t\t//   delegate mouseleave -\n\t\t\t\t\t// $(this).find(\".vakata-context-hover\").removeClass(\"vakata-context-hover\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (to) {\n\t\t\t\t\tclearTimeout(to);\n\t\t\t\t}\n\t\t\t\tvakata_context.element.find(\".vakata-context-hover\").removeClass(\"vakata-context-hover\").end();\n\n\t\t\t\t$(this).siblings().find(\"ul\").hide().end().end().parentsUntil(\".vakata-context\", \"li\").addBack().addClass(\"vakata-context-hover\");\n\t\t\t\t$.vakata.context._show_submenu(this);\n\t\t\t})\n\t\t\t//  -   ?\n\t\t\t.on(\"mouseleave\", \"li\", function (e) {\n\t\t\t\tif ($.contains(this, e.relatedTarget)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t$(this).find(\".vakata-context-hover\").addBack().removeClass(\"vakata-context-hover\");\n\t\t\t}).on(\"mouseleave\", function (e) {\n\t\t\t\t$(this).find(\".vakata-context-hover\").removeClass(\"vakata-context-hover\");\n\t\t\t\tif ($.vakata.context.settings.hide_onmouseleave) {\n\t\t\t\t\tto = setTimeout(function (t) {\n\t\t\t\t\t\treturn function () {\n\t\t\t\t\t\t\t$.vakata.context.hide();\n\t\t\t\t\t\t};\n\t\t\t\t\t}(this), $.vakata.context.settings.hide_onmouseleave);\n\t\t\t\t}\n\t\t\t}).on(\"click\", \"a\", function (e) {\n\t\t\t\te.preventDefault();\n\t\t\t\t//})\n\t\t\t\t//.on(\"mouseup\", \"a\", function (e) {\n\t\t\t\tif (!$(this).blur().parent().hasClass(\"vakata-context-disabled\") && $.vakata.context._execute($(this).attr(\"rel\")) !== false) {\n\t\t\t\t\t$.vakata.context.hide();\n\t\t\t\t}\n\t\t\t}).on('keydown', 'a', function (e) {\n\t\t\t\tvar o = null;\n\t\t\t\tswitch (e.which) {\n\t\t\t\t\tcase 13:\n\t\t\t\t\tcase 32:\n\t\t\t\t\t\te.type = \"click\";\n\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\t$(e.currentTarget).trigger(e);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 37:\n\t\t\t\t\t\tif (vakata_context.is_visible) {\n\t\t\t\t\t\t\tvakata_context.element.find(\".vakata-context-hover\").last().closest(\"li\").first().find(\"ul\").hide().find(\".vakata-context-hover\").removeClass(\"vakata-context-hover\").end().end().children('a').focus();\n\t\t\t\t\t\t\te.stopImmediatePropagation();\n\t\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 38:\n\t\t\t\t\t\tif (vakata_context.is_visible) {\n\t\t\t\t\t\t\to = vakata_context.element.find(\"ul:visible\").addBack().last().children(\".vakata-context-hover\").removeClass(\"vakata-context-hover\").prevAll(\"li:not(.vakata-context-separator)\").first();\n\t\t\t\t\t\t\tif (!o.length) {\n\t\t\t\t\t\t\t\to = vakata_context.element.find(\"ul:visible\").addBack().last().children(\"li:not(.vakata-context-separator)\").last();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\to.addClass(\"vakata-context-hover\").children('a').focus();\n\t\t\t\t\t\t\te.stopImmediatePropagation();\n\t\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 39:\n\t\t\t\t\t\tif (vakata_context.is_visible) {\n\t\t\t\t\t\t\tvakata_context.element.find(\".vakata-context-hover\").last().children(\"ul\").show().children(\"li:not(.vakata-context-separator)\").removeClass(\"vakata-context-hover\").first().addClass(\"vakata-context-hover\").children('a').focus();\n\t\t\t\t\t\t\te.stopImmediatePropagation();\n\t\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 40:\n\t\t\t\t\t\tif (vakata_context.is_visible) {\n\t\t\t\t\t\t\to = vakata_context.element.find(\"ul:visible\").addBack().last().children(\".vakata-context-hover\").removeClass(\"vakata-context-hover\").nextAll(\"li:not(.vakata-context-separator)\").first();\n\t\t\t\t\t\t\tif (!o.length) {\n\t\t\t\t\t\t\t\to = vakata_context.element.find(\"ul:visible\").addBack().last().children(\"li:not(.vakata-context-separator)\").first();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\to.addClass(\"vakata-context-hover\").children('a').focus();\n\t\t\t\t\t\t\te.stopImmediatePropagation();\n\t\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 27:\n\t\t\t\t\t\t$.vakata.context.hide();\n\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t//console.log(e.which);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}).on('keydown', function (e) {\n\t\t\t\te.preventDefault();\n\t\t\t\tvar a = vakata_context.element.find('.vakata-contextmenu-shortcut-' + e.which).parent();\n\t\t\t\tif (a.parent().not('.vakata-context-disabled')) {\n\t\t\t\t\ta.click();\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t$(document).on(\"mousedown.vakata.jstree\", function (e) {\n\t\t\t\tif (vakata_context.is_visible && !$.contains(vakata_context.element[0], e.target)) {\n\t\t\t\t\t$.vakata.context.hide();\n\t\t\t\t}\n\t\t\t}).on(\"context_show.vakata.jstree\", function (e, data) {\n\t\t\t\tvakata_context.element.find(\"li:has(ul)\").children(\"a\").addClass(\"vakata-context-parent\");\n\t\t\t\tif (right_to_left) {\n\t\t\t\t\tvakata_context.element.addClass(\"vakata-context-rtl\").css(\"direction\", \"rtl\");\n\t\t\t\t}\n\t\t\t\t// also apply a RTL class?\n\t\t\t\tvakata_context.element.find(\"ul\").hide().end();\n\t\t\t});\n\t\t});\n\t})($);\n\t// $.jstree.defaults.plugins.push(\"contextmenu\");\n\n\n\t/**\n  * ### Drag'n'drop plugin\n  *\n  * Enables dragging and dropping of nodes in the tree, resulting in a move or copy operations.\n  */\n\n\t/**\n  * stores all defaults for the drag'n'drop plugin\n  * @name $.jstree.defaults.dnd\n  * @plugin dnd\n  */\n\t$.jstree.defaults.dnd = {\n\t\t/**\n   * a boolean indicating if a copy should be possible while dragging (by pressint the meta key or Ctrl). Defaults to `true`.\n   * @name $.jstree.defaults.dnd.copy\n   * @plugin dnd\n   */\n\t\tcopy: true,\n\t\t/**\n   * a number indicating how long a node should remain hovered while dragging to be opened. Defaults to `500`.\n   * @name $.jstree.defaults.dnd.open_timeout\n   * @plugin dnd\n   */\n\t\topen_timeout: 500,\n\t\t/**\n   * a function invoked each time a node is about to be dragged, invoked in the tree's scope and receives the nodes about to be dragged as an argument (array) and the event that started the drag - return `false` to prevent dragging\n   * @name $.jstree.defaults.dnd.is_draggable\n   * @plugin dnd\n   */\n\t\tis_draggable: true,\n\t\t/**\n   * a boolean indicating if checks should constantly be made while the user is dragging the node (as opposed to checking only on drop), default is `true`\n   * @name $.jstree.defaults.dnd.check_while_dragging\n   * @plugin dnd\n   */\n\t\tcheck_while_dragging: true,\n\t\t/**\n   * a boolean indicating if nodes from this tree should only be copied with dnd (as opposed to moved), default is `false`\n   * @name $.jstree.defaults.dnd.always_copy\n   * @plugin dnd\n   */\n\t\talways_copy: false,\n\t\t/**\n   * when dropping a node \"inside\", this setting indicates the position the node should go to - it can be an integer or a string: \"first\" (same as 0) or \"last\", default is `0`\n   * @name $.jstree.defaults.dnd.inside_pos\n   * @plugin dnd\n   */\n\t\tinside_pos: 0,\n\t\t/**\n   * when starting the drag on a node that is selected this setting controls if all selected nodes are dragged or only the single node, default is `true`, which means all selected nodes are dragged when the drag is started on a selected node\n   * @name $.jstree.defaults.dnd.drag_selection\n   * @plugin dnd\n   */\n\t\tdrag_selection: true,\n\t\t/**\n   * controls whether dnd works on touch devices. If left as boolean true dnd will work the same as in desktop browsers, which in some cases may impair scrolling. If set to boolean false dnd will not work on touch devices. There is a special third option - string \"selected\" which means only selected nodes can be dragged on touch devices.\n   * @name $.jstree.defaults.dnd.touch\n   * @plugin dnd\n   */\n\t\ttouch: true,\n\t\t/**\n   * controls whether items can be dropped anywhere on the node, not just on the anchor, by default only the node anchor is a valid drop target. Works best with the wholerow plugin. If enabled on mobile depending on the interface it might be hard for the user to cancel the drop, since the whole tree container will be a valid drop target.\n   * @name $.jstree.defaults.dnd.large_drop_target\n   * @plugin dnd\n   */\n\t\tlarge_drop_target: false,\n\t\t/**\n   * controls whether a drag can be initiated from any part of the node and not just the text/icon part, works best with the wholerow plugin. Keep in mind it can cause problems with tree scrolling on mobile depending on the interface - in that case set the touch option to \"selected\".\n   * @name $.jstree.defaults.dnd.large_drag_target\n   * @plugin dnd\n   */\n\t\tlarge_drag_target: false,\n\t\t/**\n   * controls whether use HTML5 dnd api instead of classical. That will allow better integration of dnd events with other HTML5 controls.\n   * @reference http://caniuse.com/#feat=dragndrop\n   * @name $.jstree.defaults.dnd.use_html5\n   * @plugin dnd\n   */\n\t\tuse_html5: false\n\t};\n\tvar drg, elm;\n\t// TODO: now check works by checking for each node individually, how about max_children, unique, etc?\n\t$.jstree.plugins.dnd = function (options, parent) {\n\t\tthis.init = function (el, options) {\n\t\t\tparent.init.call(this, el, options);\n\t\t\tthis.settings.dnd.use_html5 = this.settings.dnd.use_html5 && 'draggable' in document.createElement('span');\n\t\t};\n\t\tthis.bind = function () {\n\t\t\tparent.bind.call(this);\n\n\t\t\tthis.element.on(this.settings.dnd.use_html5 ? 'dragstart.jstree' : 'mousedown.jstree touchstart.jstree', this.settings.dnd.large_drag_target ? '.jstree-node' : '.jstree-anchor', $.proxy(function (e) {\n\t\t\t\tif (this.settings.dnd.large_drag_target && $(e.target).closest('.jstree-node')[0] !== e.currentTarget) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (e.type === \"touchstart\" && (!this.settings.dnd.touch || this.settings.dnd.touch === 'selected' && !$(e.currentTarget).closest('.jstree-node').children('.jstree-anchor').hasClass('jstree-clicked'))) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tvar obj = this.get_node(e.target),\n\t\t\t\t    mlt = this.is_selected(obj) && this.settings.dnd.drag_selection ? this.get_top_selected().length : 1,\n\t\t\t\t    txt = mlt > 1 ? mlt + ' ' + this.get_string('nodes') : this.get_text(e.currentTarget);\n\t\t\t\tif (this.settings.core.force_text) {\n\t\t\t\t\ttxt = $.vakata.html.escape(txt);\n\t\t\t\t}\n\t\t\t\tif (obj && obj.id && obj.id !== $.jstree.root && (e.which === 1 || e.type === \"touchstart\" || e.type === \"dragstart\") && (this.settings.dnd.is_draggable === true || $.isFunction(this.settings.dnd.is_draggable) && this.settings.dnd.is_draggable.call(this, mlt > 1 ? this.get_top_selected(true) : [obj], e))) {\n\t\t\t\t\tdrg = { 'jstree': true, 'origin': this, 'obj': this.get_node(obj, true), 'nodes': mlt > 1 ? this.get_top_selected() : [obj.id] };\n\t\t\t\t\telm = e.currentTarget;\n\t\t\t\t\tif (this.settings.dnd.use_html5) {\n\t\t\t\t\t\t$.vakata.dnd._trigger('start', e, { 'helper': $(), 'element': elm, 'data': drg });\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.element.trigger('mousedown.jstree');\n\t\t\t\t\t\treturn $.vakata.dnd.start(e, drg, '<div id=\"jstree-dnd\" class=\"jstree-' + this.get_theme() + ' jstree-' + this.get_theme() + '-' + this.get_theme_variant() + ' ' + (this.settings.core.themes.responsive ? ' jstree-dnd-responsive' : '') + '\"><i class=\"jstree-icon jstree-er\"></i>' + txt + '<ins class=\"jstree-copy\" style=\"display:none;\">+</ins></div>');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, this));\n\t\t\tif (this.settings.dnd.use_html5) {\n\t\t\t\tthis.element.on('dragover.jstree', function (e) {\n\t\t\t\t\te.preventDefault();\n\t\t\t\t\t$.vakata.dnd._trigger('move', e, { 'helper': $(), 'element': elm, 'data': drg });\n\t\t\t\t\treturn false;\n\t\t\t\t})\n\t\t\t\t//.on('dragenter.jstree', this.settings.dnd.large_drop_target ? '.jstree-node' : '.jstree-anchor', $.proxy(function (e) {\n\t\t\t\t//\t\te.preventDefault();\n\t\t\t\t//\t\t$.vakata.dnd._trigger('move', e, { 'helper': $(), 'element': elm, 'data': drg });\n\t\t\t\t//\t\treturn false;\n\t\t\t\t//\t}, this))\n\t\t\t\t.on('drop.jstree', $.proxy(function (e) {\n\t\t\t\t\te.preventDefault();\n\t\t\t\t\t$.vakata.dnd._trigger('stop', e, { 'helper': $(), 'element': elm, 'data': drg });\n\t\t\t\t\treturn false;\n\t\t\t\t}, this));\n\t\t\t}\n\t\t};\n\t\tthis.redraw_node = function (obj, deep, callback, force_render) {\n\t\t\tobj = parent.redraw_node.apply(this, arguments);\n\t\t\tif (obj && this.settings.dnd.use_html5) {\n\t\t\t\tif (this.settings.dnd.large_drag_target) {\n\t\t\t\t\tobj.setAttribute('draggable', true);\n\t\t\t\t} else {\n\t\t\t\t\tvar i,\n\t\t\t\t\t    j,\n\t\t\t\t\t    tmp = null;\n\t\t\t\t\tfor (i = 0, j = obj.childNodes.length; i < j; i++) {\n\t\t\t\t\t\tif (obj.childNodes[i] && obj.childNodes[i].className && obj.childNodes[i].className.indexOf(\"jstree-anchor\") !== -1) {\n\t\t\t\t\t\t\ttmp = obj.childNodes[i];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (tmp) {\n\t\t\t\t\t\ttmp.setAttribute('draggable', true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn obj;\n\t\t};\n\t};\n\n\t$(function () {\n\t\t// bind only once for all instances\n\t\tvar lastmv = false,\n\t\t    laster = false,\n\t\t    lastev = false,\n\t\t    opento = false,\n\t\t    marker = $('<div id=\"jstree-marker\">&#160;</div>').hide(); //.appendTo('body');\n\n\t\t$(document).on('dnd_start.vakata.jstree', function (e, data) {\n\t\t\tlastmv = false;\n\t\t\tlastev = false;\n\t\t\tif (!data || !data.data || !data.data.jstree) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmarker.appendTo('body'); //.show();\n\t\t}).on('dnd_move.vakata.jstree', function (e, data) {\n\t\t\tif (opento) {\n\t\t\t\tif (!data.event || data.event.type !== 'dragover' || data.event.target !== lastev.target) {\n\t\t\t\t\tclearTimeout(opento);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!data || !data.data || !data.data.jstree) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// if we are hovering the marker image do nothing (can happen on \"inside\" drags)\n\t\t\tif (data.event.target.id && data.event.target.id === 'jstree-marker') {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlastev = data.event;\n\n\t\t\tvar ins = $.jstree.reference(data.event.target),\n\t\t\t    ref = false,\n\t\t\t    off = false,\n\t\t\t    rel = false,\n\t\t\t    tmp,\n\t\t\t    l,\n\t\t\t    t,\n\t\t\t    h,\n\t\t\t    p,\n\t\t\t    i,\n\t\t\t    o,\n\t\t\t    ok,\n\t\t\t    t1,\n\t\t\t    t2,\n\t\t\t    op,\n\t\t\t    ps,\n\t\t\t    pr,\n\t\t\t    ip,\n\t\t\t    tm,\n\t\t\t    is_copy,\n\t\t\t    pn;\n\t\t\t// if we are over an instance\n\t\t\tif (ins && ins._data && ins._data.dnd) {\n\t\t\t\tmarker.attr('class', 'jstree-' + ins.get_theme() + (ins.settings.core.themes.responsive ? ' jstree-dnd-responsive' : ''));\n\t\t\t\tis_copy = data.data.origin && (data.data.origin.settings.dnd.always_copy || data.data.origin.settings.dnd.copy && (data.event.metaKey || data.event.ctrlKey));\n\t\t\t\tdata.helper.children().attr('class', 'jstree-' + ins.get_theme() + ' jstree-' + ins.get_theme() + '-' + ins.get_theme_variant() + ' ' + (ins.settings.core.themes.responsive ? ' jstree-dnd-responsive' : '')).find('.jstree-copy').first()[is_copy ? 'show' : 'hide']();\n\n\t\t\t\t// if are hovering the container itself add a new root node\n\t\t\t\t//console.log(data.event);\n\t\t\t\tif ((data.event.target === ins.element[0] || data.event.target === ins.get_container_ul()[0]) && ins.get_container_ul().children().length === 0) {\n\t\t\t\t\tok = true;\n\t\t\t\t\tfor (t1 = 0, t2 = data.data.nodes.length; t1 < t2; t1++) {\n\t\t\t\t\t\tok = ok && ins.check(data.data.origin && (data.data.origin.settings.dnd.always_copy || data.data.origin.settings.dnd.copy && (data.event.metaKey || data.event.ctrlKey)) ? \"copy_node\" : \"move_node\", data.data.origin && data.data.origin !== ins ? data.data.origin.get_node(data.data.nodes[t1]) : data.data.nodes[t1], $.jstree.root, 'last', { 'dnd': true, 'ref': ins.get_node($.jstree.root), 'pos': 'i', 'origin': data.data.origin, 'is_multi': data.data.origin && data.data.origin !== ins, 'is_foreign': !data.data.origin });\n\t\t\t\t\t\tif (!ok) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tlastmv = { 'ins': ins, 'par': $.jstree.root, 'pos': 'last' };\n\t\t\t\t\t\tmarker.hide();\n\t\t\t\t\t\tdata.helper.find('.jstree-icon').first().removeClass('jstree-er').addClass('jstree-ok');\n\t\t\t\t\t\tif (data.event.originalEvent && data.event.originalEvent.dataTransfer) {\n\t\t\t\t\t\t\tdata.event.originalEvent.dataTransfer.dropEffect = is_copy ? 'copy' : 'move';\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// if we are hovering a tree node\n\t\t\t\t\tref = ins.settings.dnd.large_drop_target ? $(data.event.target).closest('.jstree-node').children('.jstree-anchor') : $(data.event.target).closest('.jstree-anchor');\n\t\t\t\t\tif (ref && ref.length && ref.parent().is('.jstree-closed, .jstree-open, .jstree-leaf')) {\n\t\t\t\t\t\toff = ref.offset();\n\t\t\t\t\t\trel = (data.event.pageY !== undefined ? data.event.pageY : data.event.originalEvent.pageY) - off.top;\n\t\t\t\t\t\th = ref.outerHeight();\n\t\t\t\t\t\tif (rel < h / 3) {\n\t\t\t\t\t\t\to = ['b', 'i', 'a'];\n\t\t\t\t\t\t} else if (rel > h - h / 3) {\n\t\t\t\t\t\t\to = ['a', 'i', 'b'];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\to = rel > h / 2 ? ['i', 'a', 'b'] : ['i', 'b', 'a'];\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$.each(o, function (j, v) {\n\t\t\t\t\t\t\tswitch (v) {\n\t\t\t\t\t\t\t\tcase 'b':\n\t\t\t\t\t\t\t\t\tl = off.left - 6;\n\t\t\t\t\t\t\t\t\tt = off.top;\n\t\t\t\t\t\t\t\t\tp = ins.get_parent(ref);\n\t\t\t\t\t\t\t\t\ti = ref.parent().index();\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 'i':\n\t\t\t\t\t\t\t\t\tip = ins.settings.dnd.inside_pos;\n\t\t\t\t\t\t\t\t\ttm = ins.get_node(ref.parent());\n\t\t\t\t\t\t\t\t\tl = off.left - 2;\n\t\t\t\t\t\t\t\t\tt = off.top + h / 2 + 1;\n\t\t\t\t\t\t\t\t\tp = tm.id;\n\t\t\t\t\t\t\t\t\ti = ip === 'first' ? 0 : ip === 'last' ? tm.children.length : Math.min(ip, tm.children.length);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 'a':\n\t\t\t\t\t\t\t\t\tl = off.left - 6;\n\t\t\t\t\t\t\t\t\tt = off.top + h;\n\t\t\t\t\t\t\t\t\tp = ins.get_parent(ref);\n\t\t\t\t\t\t\t\t\ti = ref.parent().index() + 1;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tok = true;\n\t\t\t\t\t\t\tfor (t1 = 0, t2 = data.data.nodes.length; t1 < t2; t1++) {\n\t\t\t\t\t\t\t\top = data.data.origin && (data.data.origin.settings.dnd.always_copy || data.data.origin.settings.dnd.copy && (data.event.metaKey || data.event.ctrlKey)) ? \"copy_node\" : \"move_node\";\n\t\t\t\t\t\t\t\tps = i;\n\t\t\t\t\t\t\t\tif (op === \"move_node\" && v === 'a' && data.data.origin && data.data.origin === ins && p === ins.get_parent(data.data.nodes[t1])) {\n\t\t\t\t\t\t\t\t\tpr = ins.get_node(p);\n\t\t\t\t\t\t\t\t\tif (ps > $.inArray(data.data.nodes[t1], pr.children)) {\n\t\t\t\t\t\t\t\t\t\tps -= 1;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tok = ok && (ins && ins.settings && ins.settings.dnd && ins.settings.dnd.check_while_dragging === false || ins.check(op, data.data.origin && data.data.origin !== ins ? data.data.origin.get_node(data.data.nodes[t1]) : data.data.nodes[t1], p, ps, { 'dnd': true, 'ref': ins.get_node(ref.parent()), 'pos': v, 'origin': data.data.origin, 'is_multi': data.data.origin && data.data.origin !== ins, 'is_foreign': !data.data.origin }));\n\t\t\t\t\t\t\t\tif (!ok) {\n\t\t\t\t\t\t\t\t\tif (ins && ins.last_error) {\n\t\t\t\t\t\t\t\t\t\tlaster = ins.last_error();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (v === 'i' && ref.parent().is('.jstree-closed') && ins.settings.dnd.open_timeout) {\n\t\t\t\t\t\t\t\topento = setTimeout(function (x, z) {\n\t\t\t\t\t\t\t\t\treturn function () {\n\t\t\t\t\t\t\t\t\t\tx.open_node(z);\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t}(ins, ref), ins.settings.dnd.open_timeout);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (ok) {\n\t\t\t\t\t\t\t\tpn = ins.get_node(p, true);\n\t\t\t\t\t\t\t\tif (!pn.hasClass('.jstree-dnd-parent')) {\n\t\t\t\t\t\t\t\t\t$('.jstree-dnd-parent').removeClass('jstree-dnd-parent');\n\t\t\t\t\t\t\t\t\tpn.addClass('jstree-dnd-parent');\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlastmv = { 'ins': ins, 'par': p, 'pos': v === 'i' && ip === 'last' && i === 0 && !ins.is_loaded(tm) ? 'last' : i };\n\t\t\t\t\t\t\t\tmarker.css({ 'left': l + 'px', 'top': t + 'px' }).show();\n\t\t\t\t\t\t\t\tdata.helper.find('.jstree-icon').first().removeClass('jstree-er').addClass('jstree-ok');\n\t\t\t\t\t\t\t\tif (data.event.originalEvent && data.event.originalEvent.dataTransfer) {\n\t\t\t\t\t\t\t\t\tdata.event.originalEvent.dataTransfer.dropEffect = is_copy ? 'copy' : 'move';\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlaster = {};\n\t\t\t\t\t\t\t\to = true;\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (o === true) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t$('.jstree-dnd-parent').removeClass('jstree-dnd-parent');\n\t\t\tlastmv = false;\n\t\t\tdata.helper.find('.jstree-icon').removeClass('jstree-ok').addClass('jstree-er');\n\t\t\tif (data.event.originalEvent && data.event.originalEvent.dataTransfer) {\n\t\t\t\tdata.event.originalEvent.dataTransfer.dropEffect = 'none';\n\t\t\t}\n\t\t\tmarker.hide();\n\t\t}).on('dnd_scroll.vakata.jstree', function (e, data) {\n\t\t\tif (!data || !data.data || !data.data.jstree) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmarker.hide();\n\t\t\tlastmv = false;\n\t\t\tlastev = false;\n\t\t\tdata.helper.find('.jstree-icon').first().removeClass('jstree-ok').addClass('jstree-er');\n\t\t}).on('dnd_stop.vakata.jstree', function (e, data) {\n\t\t\t$('.jstree-dnd-parent').removeClass('jstree-dnd-parent');\n\t\t\tif (opento) {\n\t\t\t\tclearTimeout(opento);\n\t\t\t}\n\t\t\tif (!data || !data.data || !data.data.jstree) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmarker.hide().detach();\n\t\t\tvar i,\n\t\t\t    j,\n\t\t\t    nodes = [];\n\t\t\tif (lastmv) {\n\t\t\t\tfor (i = 0, j = data.data.nodes.length; i < j; i++) {\n\t\t\t\t\tnodes[i] = data.data.origin ? data.data.origin.get_node(data.data.nodes[i]) : data.data.nodes[i];\n\t\t\t\t}\n\t\t\t\tlastmv.ins[data.data.origin && (data.data.origin.settings.dnd.always_copy || data.data.origin.settings.dnd.copy && (data.event.metaKey || data.event.ctrlKey)) ? 'copy_node' : 'move_node'](nodes, lastmv.par, lastmv.pos, false, false, false, data.data.origin);\n\t\t\t} else {\n\t\t\t\ti = $(data.event.target).closest('.jstree');\n\t\t\t\tif (i.length && laster && laster.error && laster.error === 'check') {\n\t\t\t\t\ti = i.jstree(true);\n\t\t\t\t\tif (i) {\n\t\t\t\t\t\ti.settings.core.error.call(this, laster);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlastev = false;\n\t\t\tlastmv = false;\n\t\t}).on('keyup.jstree keydown.jstree', function (e, data) {\n\t\t\tdata = $.vakata.dnd._get();\n\t\t\tif (data && data.data && data.data.jstree) {\n\t\t\t\tif (e.type === \"keyup\" && e.which === 27) {\n\t\t\t\t\tif (opento) {\n\t\t\t\t\t\tclearTimeout(opento);\n\t\t\t\t\t}\n\t\t\t\t\tlastmv = false;\n\t\t\t\t\tlaster = false;\n\t\t\t\t\tlastev = false;\n\t\t\t\t\topento = false;\n\t\t\t\t\tmarker.hide().detach();\n\t\t\t\t\t$.vakata.dnd._clean();\n\t\t\t\t} else {\n\t\t\t\t\tdata.helper.find('.jstree-copy').first()[data.data.origin && (data.data.origin.settings.dnd.always_copy || data.data.origin.settings.dnd.copy && (e.metaKey || e.ctrlKey)) ? 'show' : 'hide']();\n\t\t\t\t\tif (lastev) {\n\t\t\t\t\t\tlastev.metaKey = e.metaKey;\n\t\t\t\t\t\tlastev.ctrlKey = e.ctrlKey;\n\t\t\t\t\t\t$.vakata.dnd._trigger('move', lastev);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n\n\t// helpers\n\t(function ($) {\n\t\t$.vakata.html = {\n\t\t\tdiv: $('<div />'),\n\t\t\tescape: function escape(str) {\n\t\t\t\treturn $.vakata.html.div.text(str).html();\n\t\t\t},\n\t\t\tstrip: function strip(str) {\n\t\t\t\treturn $.vakata.html.div.empty().append($.parseHTML(str)).text();\n\t\t\t}\n\t\t};\n\t\t// private variable\n\t\tvar vakata_dnd = {\n\t\t\telement: false,\n\t\t\ttarget: false,\n\t\t\tis_down: false,\n\t\t\tis_drag: false,\n\t\t\thelper: false,\n\t\t\thelper_w: 0,\n\t\t\tdata: false,\n\t\t\tinit_x: 0,\n\t\t\tinit_y: 0,\n\t\t\tscroll_l: 0,\n\t\t\tscroll_t: 0,\n\t\t\tscroll_e: false,\n\t\t\tscroll_i: false,\n\t\t\tis_touch: false\n\t\t};\n\t\t$.vakata.dnd = {\n\t\t\tsettings: {\n\t\t\t\tscroll_speed: 10,\n\t\t\t\tscroll_proximity: 20,\n\t\t\t\thelper_left: 5,\n\t\t\t\thelper_top: 10,\n\t\t\t\tthreshold: 5,\n\t\t\t\tthreshold_touch: 50\n\t\t\t},\n\t\t\t_trigger: function _trigger(event_name, e, data) {\n\t\t\t\tif (data === undefined) {\n\t\t\t\t\tdata = $.vakata.dnd._get();\n\t\t\t\t}\n\t\t\t\tdata.event = e;\n\t\t\t\t$(document).triggerHandler(\"dnd_\" + event_name + \".vakata\", data);\n\t\t\t},\n\t\t\t_get: function _get() {\n\t\t\t\treturn {\n\t\t\t\t\t\"data\": vakata_dnd.data,\n\t\t\t\t\t\"element\": vakata_dnd.element,\n\t\t\t\t\t\"helper\": vakata_dnd.helper\n\t\t\t\t};\n\t\t\t},\n\t\t\t_clean: function _clean() {\n\t\t\t\tif (vakata_dnd.helper) {\n\t\t\t\t\tvakata_dnd.helper.remove();\n\t\t\t\t}\n\t\t\t\tif (vakata_dnd.scroll_i) {\n\t\t\t\t\tclearInterval(vakata_dnd.scroll_i);vakata_dnd.scroll_i = false;\n\t\t\t\t}\n\t\t\t\tvakata_dnd = {\n\t\t\t\t\telement: false,\n\t\t\t\t\ttarget: false,\n\t\t\t\t\tis_down: false,\n\t\t\t\t\tis_drag: false,\n\t\t\t\t\thelper: false,\n\t\t\t\t\thelper_w: 0,\n\t\t\t\t\tdata: false,\n\t\t\t\t\tinit_x: 0,\n\t\t\t\t\tinit_y: 0,\n\t\t\t\t\tscroll_l: 0,\n\t\t\t\t\tscroll_t: 0,\n\t\t\t\t\tscroll_e: false,\n\t\t\t\t\tscroll_i: false,\n\t\t\t\t\tis_touch: false\n\t\t\t\t};\n\t\t\t\t$(document).off(\"mousemove.vakata.jstree touchmove.vakata.jstree\", $.vakata.dnd.drag);\n\t\t\t\t$(document).off(\"mouseup.vakata.jstree touchend.vakata.jstree\", $.vakata.dnd.stop);\n\t\t\t},\n\t\t\t_scroll: function _scroll(init_only) {\n\t\t\t\tif (!vakata_dnd.scroll_e || !vakata_dnd.scroll_l && !vakata_dnd.scroll_t) {\n\t\t\t\t\tif (vakata_dnd.scroll_i) {\n\t\t\t\t\t\tclearInterval(vakata_dnd.scroll_i);vakata_dnd.scroll_i = false;\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (!vakata_dnd.scroll_i) {\n\t\t\t\t\tvakata_dnd.scroll_i = setInterval($.vakata.dnd._scroll, 100);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (init_only === true) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tvar i = vakata_dnd.scroll_e.scrollTop(),\n\t\t\t\t    j = vakata_dnd.scroll_e.scrollLeft();\n\t\t\t\tvakata_dnd.scroll_e.scrollTop(i + vakata_dnd.scroll_t * $.vakata.dnd.settings.scroll_speed);\n\t\t\t\tvakata_dnd.scroll_e.scrollLeft(j + vakata_dnd.scroll_l * $.vakata.dnd.settings.scroll_speed);\n\t\t\t\tif (i !== vakata_dnd.scroll_e.scrollTop() || j !== vakata_dnd.scroll_e.scrollLeft()) {\n\t\t\t\t\t/**\n      * triggered on the document when a drag causes an element to scroll\n      * @event\n      * @plugin dnd\n      * @name dnd_scroll.vakata\n      * @param {Mixed} data any data supplied with the call to $.vakata.dnd.start\n      * @param {DOM} element the DOM element being dragged\n      * @param {jQuery} helper the helper shown next to the mouse\n      * @param {jQuery} event the element that is scrolling\n      */\n\t\t\t\t\t$.vakata.dnd._trigger(\"scroll\", vakata_dnd.scroll_e);\n\t\t\t\t}\n\t\t\t},\n\t\t\tstart: function start(e, data, html) {\n\t\t\t\tif (e.type === \"touchstart\" && e.originalEvent && e.originalEvent.changedTouches && e.originalEvent.changedTouches[0]) {\n\t\t\t\t\te.pageX = e.originalEvent.changedTouches[0].pageX;\n\t\t\t\t\te.pageY = e.originalEvent.changedTouches[0].pageY;\n\t\t\t\t\te.target = document.elementFromPoint(e.originalEvent.changedTouches[0].pageX - window.pageXOffset, e.originalEvent.changedTouches[0].pageY - window.pageYOffset);\n\t\t\t\t}\n\t\t\t\tif (vakata_dnd.is_drag) {\n\t\t\t\t\t$.vakata.dnd.stop({});\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\te.currentTarget.unselectable = \"on\";\n\t\t\t\t\te.currentTarget.onselectstart = function () {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t};\n\t\t\t\t\tif (e.currentTarget.style) {\n\t\t\t\t\t\te.currentTarget.style.touchAction = \"none\";\n\t\t\t\t\t\te.currentTarget.style.msTouchAction = \"none\";\n\t\t\t\t\t\te.currentTarget.style.MozUserSelect = \"none\";\n\t\t\t\t\t}\n\t\t\t\t} catch (ignore) {}\n\t\t\t\tvakata_dnd.init_x = e.pageX;\n\t\t\t\tvakata_dnd.init_y = e.pageY;\n\t\t\t\tvakata_dnd.data = data;\n\t\t\t\tvakata_dnd.is_down = true;\n\t\t\t\tvakata_dnd.element = e.currentTarget;\n\t\t\t\tvakata_dnd.target = e.target;\n\t\t\t\tvakata_dnd.is_touch = e.type === \"touchstart\";\n\t\t\t\tif (html !== false) {\n\t\t\t\t\tvakata_dnd.helper = $(\"<div id='vakata-dnd'></div>\").html(html).css({\n\t\t\t\t\t\t\"display\": \"block\",\n\t\t\t\t\t\t\"margin\": \"0\",\n\t\t\t\t\t\t\"padding\": \"0\",\n\t\t\t\t\t\t\"position\": \"absolute\",\n\t\t\t\t\t\t\"top\": \"-2000px\",\n\t\t\t\t\t\t\"lineHeight\": \"16px\",\n\t\t\t\t\t\t\"zIndex\": \"10000\"\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t$(document).on(\"mousemove.vakata.jstree touchmove.vakata.jstree\", $.vakata.dnd.drag);\n\t\t\t\t$(document).on(\"mouseup.vakata.jstree touchend.vakata.jstree\", $.vakata.dnd.stop);\n\t\t\t\treturn false;\n\t\t\t},\n\t\t\tdrag: function drag(e) {\n\t\t\t\tif (e.type === \"touchmove\" && e.originalEvent && e.originalEvent.changedTouches && e.originalEvent.changedTouches[0]) {\n\t\t\t\t\te.pageX = e.originalEvent.changedTouches[0].pageX;\n\t\t\t\t\te.pageY = e.originalEvent.changedTouches[0].pageY;\n\t\t\t\t\te.target = document.elementFromPoint(e.originalEvent.changedTouches[0].pageX - window.pageXOffset, e.originalEvent.changedTouches[0].pageY - window.pageYOffset);\n\t\t\t\t}\n\t\t\t\tif (!vakata_dnd.is_down) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (!vakata_dnd.is_drag) {\n\t\t\t\t\tif (Math.abs(e.pageX - vakata_dnd.init_x) > (vakata_dnd.is_touch ? $.vakata.dnd.settings.threshold_touch : $.vakata.dnd.settings.threshold) || Math.abs(e.pageY - vakata_dnd.init_y) > (vakata_dnd.is_touch ? $.vakata.dnd.settings.threshold_touch : $.vakata.dnd.settings.threshold)) {\n\t\t\t\t\t\tif (vakata_dnd.helper) {\n\t\t\t\t\t\t\tvakata_dnd.helper.appendTo(\"body\");\n\t\t\t\t\t\t\tvakata_dnd.helper_w = vakata_dnd.helper.outerWidth();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvakata_dnd.is_drag = true;\n\t\t\t\t\t\t$(vakata_dnd.target).one('click.vakata', false);\n\t\t\t\t\t\t/**\n       * triggered on the document when a drag starts\n       * @event\n       * @plugin dnd\n       * @name dnd_start.vakata\n       * @param {Mixed} data any data supplied with the call to $.vakata.dnd.start\n       * @param {DOM} element the DOM element being dragged\n       * @param {jQuery} helper the helper shown next to the mouse\n       * @param {Object} event the event that caused the start (probably mousemove)\n       */\n\t\t\t\t\t\t$.vakata.dnd._trigger(\"start\", e);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar d = false,\n\t\t\t\t    w = false,\n\t\t\t\t    dh = false,\n\t\t\t\t    wh = false,\n\t\t\t\t    dw = false,\n\t\t\t\t    ww = false,\n\t\t\t\t    dt = false,\n\t\t\t\t    dl = false,\n\t\t\t\t    ht = false,\n\t\t\t\t    hl = false;\n\n\t\t\t\tvakata_dnd.scroll_t = 0;\n\t\t\t\tvakata_dnd.scroll_l = 0;\n\t\t\t\tvakata_dnd.scroll_e = false;\n\t\t\t\t$($(e.target).parentsUntil(\"body\").addBack().get().reverse()).filter(function () {\n\t\t\t\t\treturn (/^auto|scroll$/.test($(this).css(\"overflow\")) && (this.scrollHeight > this.offsetHeight || this.scrollWidth > this.offsetWidth)\n\t\t\t\t\t);\n\t\t\t\t}).each(function () {\n\t\t\t\t\tvar t = $(this),\n\t\t\t\t\t    o = t.offset();\n\t\t\t\t\tif (this.scrollHeight > this.offsetHeight) {\n\t\t\t\t\t\tif (o.top + t.height() - e.pageY < $.vakata.dnd.settings.scroll_proximity) {\n\t\t\t\t\t\t\tvakata_dnd.scroll_t = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (e.pageY - o.top < $.vakata.dnd.settings.scroll_proximity) {\n\t\t\t\t\t\t\tvakata_dnd.scroll_t = -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (this.scrollWidth > this.offsetWidth) {\n\t\t\t\t\t\tif (o.left + t.width() - e.pageX < $.vakata.dnd.settings.scroll_proximity) {\n\t\t\t\t\t\t\tvakata_dnd.scroll_l = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (e.pageX - o.left < $.vakata.dnd.settings.scroll_proximity) {\n\t\t\t\t\t\t\tvakata_dnd.scroll_l = -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (vakata_dnd.scroll_t || vakata_dnd.scroll_l) {\n\t\t\t\t\t\tvakata_dnd.scroll_e = $(this);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tif (!vakata_dnd.scroll_e) {\n\t\t\t\t\td = $(document);w = $(window);\n\t\t\t\t\tdh = d.height();wh = w.height();\n\t\t\t\t\tdw = d.width();ww = w.width();\n\t\t\t\t\tdt = d.scrollTop();dl = d.scrollLeft();\n\t\t\t\t\tif (dh > wh && e.pageY - dt < $.vakata.dnd.settings.scroll_proximity) {\n\t\t\t\t\t\tvakata_dnd.scroll_t = -1;\n\t\t\t\t\t}\n\t\t\t\t\tif (dh > wh && wh - (e.pageY - dt) < $.vakata.dnd.settings.scroll_proximity) {\n\t\t\t\t\t\tvakata_dnd.scroll_t = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (dw > ww && e.pageX - dl < $.vakata.dnd.settings.scroll_proximity) {\n\t\t\t\t\t\tvakata_dnd.scroll_l = -1;\n\t\t\t\t\t}\n\t\t\t\t\tif (dw > ww && ww - (e.pageX - dl) < $.vakata.dnd.settings.scroll_proximity) {\n\t\t\t\t\t\tvakata_dnd.scroll_l = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (vakata_dnd.scroll_t || vakata_dnd.scroll_l) {\n\t\t\t\t\t\tvakata_dnd.scroll_e = d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (vakata_dnd.scroll_e) {\n\t\t\t\t\t$.vakata.dnd._scroll(true);\n\t\t\t\t}\n\n\t\t\t\tif (vakata_dnd.helper) {\n\t\t\t\t\tht = parseInt(e.pageY + $.vakata.dnd.settings.helper_top, 10);\n\t\t\t\t\thl = parseInt(e.pageX + $.vakata.dnd.settings.helper_left, 10);\n\t\t\t\t\tif (dh && ht + 25 > dh) {\n\t\t\t\t\t\tht = dh - 50;\n\t\t\t\t\t}\n\t\t\t\t\tif (dw && hl + vakata_dnd.helper_w > dw) {\n\t\t\t\t\t\thl = dw - (vakata_dnd.helper_w + 2);\n\t\t\t\t\t}\n\t\t\t\t\tvakata_dnd.helper.css({\n\t\t\t\t\t\tleft: hl + \"px\",\n\t\t\t\t\t\ttop: ht + \"px\"\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t/**\n     * triggered on the document when a drag is in progress\n     * @event\n     * @plugin dnd\n     * @name dnd_move.vakata\n     * @param {Mixed} data any data supplied with the call to $.vakata.dnd.start\n     * @param {DOM} element the DOM element being dragged\n     * @param {jQuery} helper the helper shown next to the mouse\n     * @param {Object} event the event that caused this to trigger (most likely mousemove)\n     */\n\t\t\t\t$.vakata.dnd._trigger(\"move\", e);\n\t\t\t\treturn false;\n\t\t\t},\n\t\t\tstop: function stop(e) {\n\t\t\t\tif (e.type === \"touchend\" && e.originalEvent && e.originalEvent.changedTouches && e.originalEvent.changedTouches[0]) {\n\t\t\t\t\te.pageX = e.originalEvent.changedTouches[0].pageX;\n\t\t\t\t\te.pageY = e.originalEvent.changedTouches[0].pageY;\n\t\t\t\t\te.target = document.elementFromPoint(e.originalEvent.changedTouches[0].pageX - window.pageXOffset, e.originalEvent.changedTouches[0].pageY - window.pageYOffset);\n\t\t\t\t}\n\t\t\t\tif (vakata_dnd.is_drag) {\n\t\t\t\t\t/**\n      * triggered on the document when a drag stops (the dragged element is dropped)\n      * @event\n      * @plugin dnd\n      * @name dnd_stop.vakata\n      * @param {Mixed} data any data supplied with the call to $.vakata.dnd.start\n      * @param {DOM} element the DOM element being dragged\n      * @param {jQuery} helper the helper shown next to the mouse\n      * @param {Object} event the event that caused the stop\n      */\n\t\t\t\t\tif (e.target !== vakata_dnd.target) {\n\t\t\t\t\t\t$(vakata_dnd.target).off('click.vakata');\n\t\t\t\t\t}\n\t\t\t\t\t$.vakata.dnd._trigger(\"stop\", e);\n\t\t\t\t} else {\n\t\t\t\t\tif (e.type === \"touchend\" && e.target === vakata_dnd.target) {\n\t\t\t\t\t\tvar to = setTimeout(function () {\n\t\t\t\t\t\t\t$(e.target).click();\n\t\t\t\t\t\t}, 100);\n\t\t\t\t\t\t$(e.target).one('click', function () {\n\t\t\t\t\t\t\tif (to) {\n\t\t\t\t\t\t\t\tclearTimeout(to);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t$.vakata.dnd._clean();\n\t\t\t\treturn false;\n\t\t\t}\n\t\t};\n\t})($);\n\n\t// include the dnd plugin by default\n\t// $.jstree.defaults.plugins.push(\"dnd\");\n\n\n\t/**\n  * ### Massload plugin\n  *\n  * Adds massload functionality to jsTree, so that multiple nodes can be loaded in a single request (only useful with lazy loading).\n  */\n\n\t/**\n  * massload configuration\n  *\n  * It is possible to set this to a standard jQuery-like AJAX config.\n  * In addition to the standard jQuery ajax options here you can supply functions for `data` and `url`, the functions will be run in the current instance's scope and a param will be passed indicating which node IDs need to be loaded, the return value of those functions will be used.\n  *\n  * You can also set this to a function, that function will receive the node IDs being loaded as argument and a second param which is a function (callback) which should be called with the result.\n  *\n  * Both the AJAX and the function approach rely on the same return value - an object where the keys are the node IDs, and the value is the children of that node as an array.\n  *\n  *\t{\n  *\t\t\"id1\" : [{ \"text\" : \"Child of ID1\", \"id\" : \"c1\" }, { \"text\" : \"Another child of ID1\", \"id\" : \"c2\" }],\n  *\t\t\"id2\" : [{ \"text\" : \"Child of ID2\", \"id\" : \"c3\" }]\n  *\t}\n  * \n  * @name $.jstree.defaults.massload\n  * @plugin massload\n  */\n\t$.jstree.defaults.massload = null;\n\t$.jstree.plugins.massload = function (options, parent) {\n\t\tthis.init = function (el, options) {\n\t\t\tthis._data.massload = {};\n\t\t\tparent.init.call(this, el, options);\n\t\t};\n\t\tthis._load_nodes = function (nodes, callback, is_callback, force_reload) {\n\t\t\tvar s = this.settings.massload,\n\t\t\t    nodesString = JSON.stringify(nodes),\n\t\t\t    toLoad = [],\n\t\t\t    m = this._model.data,\n\t\t\t    i,\n\t\t\t    j,\n\t\t\t    dom;\n\t\t\tif (!is_callback) {\n\t\t\t\tfor (i = 0, j = nodes.length; i < j; i++) {\n\t\t\t\t\tif (!m[nodes[i]] || !m[nodes[i]].state.loaded && !m[nodes[i]].state.failed || force_reload) {\n\t\t\t\t\t\ttoLoad.push(nodes[i]);\n\t\t\t\t\t\tdom = this.get_node(nodes[i], true);\n\t\t\t\t\t\tif (dom && dom.length) {\n\t\t\t\t\t\t\tdom.addClass(\"jstree-loading\").attr('aria-busy', true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis._data.massload = {};\n\t\t\t\tif (toLoad.length) {\n\t\t\t\t\tif ($.isFunction(s)) {\n\t\t\t\t\t\treturn s.call(this, toLoad, $.proxy(function (data) {\n\t\t\t\t\t\t\tvar i, j;\n\t\t\t\t\t\t\tif (data) {\n\t\t\t\t\t\t\t\tfor (i in data) {\n\t\t\t\t\t\t\t\t\tif (data.hasOwnProperty(i)) {\n\t\t\t\t\t\t\t\t\t\tthis._data.massload[i] = data[i];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (i = 0, j = nodes.length; i < j; i++) {\n\t\t\t\t\t\t\t\tdom = this.get_node(nodes[i], true);\n\t\t\t\t\t\t\t\tif (dom && dom.length) {\n\t\t\t\t\t\t\t\t\tdom.removeClass(\"jstree-loading\").attr('aria-busy', false);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tparent._load_nodes.call(this, nodes, callback, is_callback, force_reload);\n\t\t\t\t\t\t}, this));\n\t\t\t\t\t}\n\t\t\t\t\tif ((typeof s === 'undefined' ? 'undefined' : _typeof(s)) === 'object' && s && s.url) {\n\t\t\t\t\t\ts = $.extend(true, {}, s);\n\t\t\t\t\t\tif ($.isFunction(s.url)) {\n\t\t\t\t\t\t\ts.url = s.url.call(this, toLoad);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ($.isFunction(s.data)) {\n\t\t\t\t\t\t\ts.data = s.data.call(this, toLoad);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn $.ajax(s).done($.proxy(function (data, t, x) {\n\t\t\t\t\t\t\tvar i, j;\n\t\t\t\t\t\t\tif (data) {\n\t\t\t\t\t\t\t\tfor (i in data) {\n\t\t\t\t\t\t\t\t\tif (data.hasOwnProperty(i)) {\n\t\t\t\t\t\t\t\t\t\tthis._data.massload[i] = data[i];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (i = 0, j = nodes.length; i < j; i++) {\n\t\t\t\t\t\t\t\tdom = this.get_node(nodes[i], true);\n\t\t\t\t\t\t\t\tif (dom && dom.length) {\n\t\t\t\t\t\t\t\t\tdom.removeClass(\"jstree-loading\").attr('aria-busy', false);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tparent._load_nodes.call(this, nodes, callback, is_callback, force_reload);\n\t\t\t\t\t\t}, this)).fail($.proxy(function (f) {\n\t\t\t\t\t\t\tparent._load_nodes.call(this, nodes, callback, is_callback, force_reload);\n\t\t\t\t\t\t}, this));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn parent._load_nodes.call(this, nodes, callback, is_callback, force_reload);\n\t\t};\n\t\tthis._load_node = function (obj, callback) {\n\t\t\tvar data = this._data.massload[obj.id],\n\t\t\t    rslt = null,\n\t\t\t    dom;\n\t\t\tif (data) {\n\t\t\t\trslt = this[typeof data === 'string' ? '_append_html_data' : '_append_json_data'](obj, typeof data === 'string' ? $($.parseHTML(data)).filter(function () {\n\t\t\t\t\treturn this.nodeType !== 3;\n\t\t\t\t}) : data, function (status) {\n\t\t\t\t\tcallback.call(this, status);\n\t\t\t\t});\n\t\t\t\tdom = this.get_node(obj.id, true);\n\t\t\t\tif (dom && dom.length) {\n\t\t\t\t\tdom.removeClass(\"jstree-loading\").attr('aria-busy', false);\n\t\t\t\t}\n\t\t\t\tdelete this._data.massload[obj.id];\n\t\t\t\treturn rslt;\n\t\t\t}\n\t\t\treturn parent._load_node.call(this, obj, callback);\n\t\t};\n\t};\n\n\t/**\n  * ### Search plugin\n  *\n  * Adds search functionality to jsTree.\n  */\n\n\t/**\n  * stores all defaults for the search plugin\n  * @name $.jstree.defaults.search\n  * @plugin search\n  */\n\t$.jstree.defaults.search = {\n\t\t/**\n   * a jQuery-like AJAX config, which jstree uses if a server should be queried for results.\n   *\n   * A `str` (which is the search string) parameter will be added with the request, an optional `inside` parameter will be added if the search is limited to a node id. The expected result is a JSON array with nodes that need to be opened so that matching nodes will be revealed.\n   * Leave this setting as `false` to not query the server. You can also set this to a function, which will be invoked in the instance's scope and receive 3 parameters - the search string, the callback to call with the array of nodes to load, and the optional node ID to limit the search to\n   * @name $.jstree.defaults.search.ajax\n   * @plugin search\n   */\n\t\tajax: false,\n\t\t/**\n   * Indicates if the search should be fuzzy or not (should `chnd3` match `child node 3`). Default is `false`.\n   * @name $.jstree.defaults.search.fuzzy\n   * @plugin search\n   */\n\t\tfuzzy: false,\n\t\t/**\n   * Indicates if the search should be case sensitive. Default is `false`.\n   * @name $.jstree.defaults.search.case_sensitive\n   * @plugin search\n   */\n\t\tcase_sensitive: false,\n\t\t/**\n   * Indicates if the tree should be filtered (by default) to show only matching nodes (keep in mind this can be a heavy on large trees in old browsers).\n   * This setting can be changed at runtime when calling the search method. Default is `false`.\n   * @name $.jstree.defaults.search.show_only_matches\n   * @plugin search\n   */\n\t\tshow_only_matches: false,\n\t\t/**\n   * Indicates if the children of matched element are shown (when show_only_matches is true)\n   * This setting can be changed at runtime when calling the search method. Default is `false`.\n   * @name $.jstree.defaults.search.show_only_matches_children\n   * @plugin search\n   */\n\t\tshow_only_matches_children: false,\n\t\t/**\n   * Indicates if all nodes opened to reveal the search result, should be closed when the search is cleared or a new search is performed. Default is `true`.\n   * @name $.jstree.defaults.search.close_opened_onclear\n   * @plugin search\n   */\n\t\tclose_opened_onclear: true,\n\t\t/**\n   * Indicates if only leaf nodes should be included in search results. Default is `false`.\n   * @name $.jstree.defaults.search.search_leaves_only\n   * @plugin search\n   */\n\t\tsearch_leaves_only: false,\n\t\t/**\n   * If set to a function it wil be called in the instance's scope with two arguments - search string and node (where node will be every node in the structure, so use with caution).\n   * If the function returns a truthy value the node will be considered a match (it might not be displayed if search_only_leaves is set to true and the node is not a leaf). Default is `false`.\n   * @name $.jstree.defaults.search.search_callback\n   * @plugin search\n   */\n\t\tsearch_callback: false\n\t};\n\n\t$.jstree.plugins.search = function (options, parent) {\n\t\tthis.bind = function () {\n\t\t\tparent.bind.call(this);\n\n\t\t\tthis._data.search.str = \"\";\n\t\t\tthis._data.search.dom = $();\n\t\t\tthis._data.search.res = [];\n\t\t\tthis._data.search.opn = [];\n\t\t\tthis._data.search.som = false;\n\t\t\tthis._data.search.smc = false;\n\t\t\tthis._data.search.hdn = [];\n\n\t\t\tthis.element.on(\"search.jstree\", $.proxy(function (e, data) {\n\t\t\t\tif (this._data.search.som && data.res.length) {\n\t\t\t\t\tvar m = this._model.data,\n\t\t\t\t\t    i,\n\t\t\t\t\t    j,\n\t\t\t\t\t    p = [],\n\t\t\t\t\t    k,\n\t\t\t\t\t    l;\n\t\t\t\t\tfor (i = 0, j = data.res.length; i < j; i++) {\n\t\t\t\t\t\tif (m[data.res[i]] && !m[data.res[i]].state.hidden) {\n\t\t\t\t\t\t\tp.push(data.res[i]);\n\t\t\t\t\t\t\tp = p.concat(m[data.res[i]].parents);\n\t\t\t\t\t\t\tif (this._data.search.smc) {\n\t\t\t\t\t\t\t\tfor (k = 0, l = m[data.res[i]].children_d.length; k < l; k++) {\n\t\t\t\t\t\t\t\t\tif (m[m[data.res[i]].children_d[k]] && !m[m[data.res[i]].children_d[k]].state.hidden) {\n\t\t\t\t\t\t\t\t\t\tp.push(m[data.res[i]].children_d[k]);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tp = $.vakata.array_remove_item($.vakata.array_unique(p), $.jstree.root);\n\t\t\t\t\tthis._data.search.hdn = this.hide_all(true);\n\t\t\t\t\tthis.show_node(p, true);\n\t\t\t\t\tthis.redraw(true);\n\t\t\t\t}\n\t\t\t}, this)).on(\"clear_search.jstree\", $.proxy(function (e, data) {\n\t\t\t\tif (this._data.search.som && data.res.length) {\n\t\t\t\t\tthis.show_node(this._data.search.hdn, true);\n\t\t\t\t\tthis.redraw(true);\n\t\t\t\t}\n\t\t\t}, this));\n\t\t};\n\t\t/**\n   * used to search the tree nodes for a given string\n   * @name search(str [, skip_async])\n   * @param {String} str the search string\n   * @param {Boolean} skip_async if set to true server will not be queried even if configured\n   * @param {Boolean} show_only_matches if set to true only matching nodes will be shown (keep in mind this can be very slow on large trees or old browsers)\n   * @param {mixed} inside an optional node to whose children to limit the search\n   * @param {Boolean} append if set to true the results of this search are appended to the previous search\n   * @plugin search\n   * @trigger search.jstree\n   */\n\t\tthis.search = function (str, skip_async, show_only_matches, inside, append, show_only_matches_children) {\n\t\t\tif (str === false || $.trim(str.toString()) === \"\") {\n\t\t\t\treturn this.clear_search();\n\t\t\t}\n\t\t\tinside = this.get_node(inside);\n\t\t\tinside = inside && inside.id ? inside.id : null;\n\t\t\tstr = str.toString();\n\t\t\tvar s = this.settings.search,\n\t\t\t    a = s.ajax ? s.ajax : false,\n\t\t\t    m = this._model.data,\n\t\t\t    f = null,\n\t\t\t    r = [],\n\t\t\t    p = [],\n\t\t\t    i,\n\t\t\t    j;\n\t\t\tif (this._data.search.res.length && !append) {\n\t\t\t\tthis.clear_search();\n\t\t\t}\n\t\t\tif (show_only_matches === undefined) {\n\t\t\t\tshow_only_matches = s.show_only_matches;\n\t\t\t}\n\t\t\tif (show_only_matches_children === undefined) {\n\t\t\t\tshow_only_matches_children = s.show_only_matches_children;\n\t\t\t}\n\t\t\tif (!skip_async && a !== false) {\n\t\t\t\tif ($.isFunction(a)) {\n\t\t\t\t\treturn a.call(this, str, $.proxy(function (d) {\n\t\t\t\t\t\tif (d && d.d) {\n\t\t\t\t\t\t\td = d.d;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis._load_nodes(!$.isArray(d) ? [] : $.vakata.array_unique(d), function () {\n\t\t\t\t\t\t\tthis.search(str, true, show_only_matches, inside, append, show_only_matches_children);\n\t\t\t\t\t\t});\n\t\t\t\t\t}, this), inside);\n\t\t\t\t} else {\n\t\t\t\t\ta = $.extend({}, a);\n\t\t\t\t\tif (!a.data) {\n\t\t\t\t\t\ta.data = {};\n\t\t\t\t\t}\n\t\t\t\t\ta.data.str = str;\n\t\t\t\t\tif (inside) {\n\t\t\t\t\t\ta.data.inside = inside;\n\t\t\t\t\t}\n\t\t\t\t\tif (this._data.search.lastRequest) {\n\t\t\t\t\t\tthis._data.search.lastRequest.abort();\n\t\t\t\t\t}\n\t\t\t\t\tthis._data.search.lastRequest = $.ajax(a).fail($.proxy(function () {\n\t\t\t\t\t\tthis._data.core.last_error = { 'error': 'ajax', 'plugin': 'search', 'id': 'search_01', 'reason': 'Could not load search parents', 'data': JSON.stringify(a) };\n\t\t\t\t\t\tthis.settings.core.error.call(this, this._data.core.last_error);\n\t\t\t\t\t}, this)).done($.proxy(function (d) {\n\t\t\t\t\t\tif (d && d.d) {\n\t\t\t\t\t\t\td = d.d;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis._load_nodes(!$.isArray(d) ? [] : $.vakata.array_unique(d), function () {\n\t\t\t\t\t\t\tthis.search(str, true, show_only_matches, inside, append, show_only_matches_children);\n\t\t\t\t\t\t});\n\t\t\t\t\t}, this));\n\t\t\t\t\treturn this._data.search.lastRequest;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!append) {\n\t\t\t\tthis._data.search.str = str;\n\t\t\t\tthis._data.search.dom = $();\n\t\t\t\tthis._data.search.res = [];\n\t\t\t\tthis._data.search.opn = [];\n\t\t\t\tthis._data.search.som = show_only_matches;\n\t\t\t\tthis._data.search.smc = show_only_matches_children;\n\t\t\t}\n\n\t\t\tf = new $.vakata.search(str, true, { caseSensitive: s.case_sensitive, fuzzy: s.fuzzy });\n\t\t\t$.each(m[inside ? inside : $.jstree.root].children_d, function (ii, i) {\n\t\t\t\tvar v = m[i];\n\t\t\t\tif (v.text && !v.state.hidden && (!s.search_leaves_only || v.state.loaded && v.children.length === 0) && (s.search_callback && s.search_callback.call(this, str, v) || !s.search_callback && f.search(v.text).isMatch)) {\n\t\t\t\t\tr.push(i);\n\t\t\t\t\tp = p.concat(v.parents);\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (r.length) {\n\t\t\t\tp = $.vakata.array_unique(p);\n\t\t\t\tfor (i = 0, j = p.length; i < j; i++) {\n\t\t\t\t\tif (p[i] !== $.jstree.root && m[p[i]] && this.open_node(p[i], null, 0) === true) {\n\t\t\t\t\t\tthis._data.search.opn.push(p[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!append) {\n\t\t\t\t\tthis._data.search.dom = $(this.element[0].querySelectorAll('#' + $.map(r, function (v) {\n\t\t\t\t\t\treturn \"0123456789\".indexOf(v[0]) !== -1 ? '\\\\3' + v[0] + ' ' + v.substr(1).replace($.jstree.idregex, '\\\\$&') : v.replace($.jstree.idregex, '\\\\$&');\n\t\t\t\t\t}).join(', #')));\n\t\t\t\t\tthis._data.search.res = r;\n\t\t\t\t} else {\n\t\t\t\t\tthis._data.search.dom = this._data.search.dom.add($(this.element[0].querySelectorAll('#' + $.map(r, function (v) {\n\t\t\t\t\t\treturn \"0123456789\".indexOf(v[0]) !== -1 ? '\\\\3' + v[0] + ' ' + v.substr(1).replace($.jstree.idregex, '\\\\$&') : v.replace($.jstree.idregex, '\\\\$&');\n\t\t\t\t\t}).join(', #'))));\n\t\t\t\t\tthis._data.search.res = $.vakata.array_unique(this._data.search.res.concat(r));\n\t\t\t\t}\n\t\t\t\tthis._data.search.dom.children(\".jstree-anchor\").addClass('jstree-search');\n\t\t\t}\n\t\t\t/**\n    * triggered after search is complete\n    * @event\n    * @name search.jstree\n    * @param {jQuery} nodes a jQuery collection of matching nodes\n    * @param {String} str the search string\n    * @param {Array} res a collection of objects represeing the matching nodes\n    * @plugin search\n    */\n\t\t\tthis.trigger('search', { nodes: this._data.search.dom, str: str, res: this._data.search.res, show_only_matches: show_only_matches });\n\t\t};\n\t\t/**\n   * used to clear the last search (removes classes and shows all nodes if filtering is on)\n   * @name clear_search()\n   * @plugin search\n   * @trigger clear_search.jstree\n   */\n\t\tthis.clear_search = function () {\n\t\t\tif (this.settings.search.close_opened_onclear) {\n\t\t\t\tthis.close_node(this._data.search.opn, 0);\n\t\t\t}\n\t\t\t/**\n    * triggered after search is complete\n    * @event\n    * @name clear_search.jstree\n    * @param {jQuery} nodes a jQuery collection of matching nodes (the result from the last search)\n    * @param {String} str the search string (the last search string)\n    * @param {Array} res a collection of objects represeing the matching nodes (the result from the last search)\n    * @plugin search\n    */\n\t\t\tthis.trigger('clear_search', { 'nodes': this._data.search.dom, str: this._data.search.str, res: this._data.search.res });\n\t\t\tif (this._data.search.res.length) {\n\t\t\t\tthis._data.search.dom = $(this.element[0].querySelectorAll('#' + $.map(this._data.search.res, function (v) {\n\t\t\t\t\treturn \"0123456789\".indexOf(v[0]) !== -1 ? '\\\\3' + v[0] + ' ' + v.substr(1).replace($.jstree.idregex, '\\\\$&') : v.replace($.jstree.idregex, '\\\\$&');\n\t\t\t\t}).join(', #')));\n\t\t\t\tthis._data.search.dom.children(\".jstree-anchor\").removeClass(\"jstree-search\");\n\t\t\t}\n\t\t\tthis._data.search.str = \"\";\n\t\t\tthis._data.search.res = [];\n\t\t\tthis._data.search.opn = [];\n\t\t\tthis._data.search.dom = $();\n\t\t};\n\n\t\tthis.redraw_node = function (obj, deep, callback, force_render) {\n\t\t\tobj = parent.redraw_node.apply(this, arguments);\n\t\t\tif (obj) {\n\t\t\t\tif ($.inArray(obj.id, this._data.search.res) !== -1) {\n\t\t\t\t\tvar i,\n\t\t\t\t\t    j,\n\t\t\t\t\t    tmp = null;\n\t\t\t\t\tfor (i = 0, j = obj.childNodes.length; i < j; i++) {\n\t\t\t\t\t\tif (obj.childNodes[i] && obj.childNodes[i].className && obj.childNodes[i].className.indexOf(\"jstree-anchor\") !== -1) {\n\t\t\t\t\t\t\ttmp = obj.childNodes[i];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (tmp) {\n\t\t\t\t\t\ttmp.className += ' jstree-search';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn obj;\n\t\t};\n\t};\n\n\t// helpers\n\t(function ($) {\n\t\t// from http://kiro.me/projects/fuse.html\n\t\t$.vakata.search = function (pattern, txt, options) {\n\t\t\toptions = options || {};\n\t\t\toptions = $.extend({}, $.vakata.search.defaults, options);\n\t\t\tif (options.fuzzy !== false) {\n\t\t\t\toptions.fuzzy = true;\n\t\t\t}\n\t\t\tpattern = options.caseSensitive ? pattern : pattern.toLowerCase();\n\t\t\tvar MATCH_LOCATION = options.location,\n\t\t\t    MATCH_DISTANCE = options.distance,\n\t\t\t    MATCH_THRESHOLD = options.threshold,\n\t\t\t    patternLen = pattern.length,\n\t\t\t    matchmask,\n\t\t\t    pattern_alphabet,\n\t\t\t    match_bitapScore,\n\t\t\t    search;\n\t\t\tif (patternLen > 32) {\n\t\t\t\toptions.fuzzy = false;\n\t\t\t}\n\t\t\tif (options.fuzzy) {\n\t\t\t\tmatchmask = 1 << patternLen - 1;\n\t\t\t\tpattern_alphabet = function () {\n\t\t\t\t\tvar mask = {},\n\t\t\t\t\t    i = 0;\n\t\t\t\t\tfor (i = 0; i < patternLen; i++) {\n\t\t\t\t\t\tmask[pattern.charAt(i)] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tfor (i = 0; i < patternLen; i++) {\n\t\t\t\t\t\tmask[pattern.charAt(i)] |= 1 << patternLen - i - 1;\n\t\t\t\t\t}\n\t\t\t\t\treturn mask;\n\t\t\t\t}();\n\t\t\t\tmatch_bitapScore = function match_bitapScore(e, x) {\n\t\t\t\t\tvar accuracy = e / patternLen,\n\t\t\t\t\t    proximity = Math.abs(MATCH_LOCATION - x);\n\t\t\t\t\tif (!MATCH_DISTANCE) {\n\t\t\t\t\t\treturn proximity ? 1.0 : accuracy;\n\t\t\t\t\t}\n\t\t\t\t\treturn accuracy + proximity / MATCH_DISTANCE;\n\t\t\t\t};\n\t\t\t}\n\t\t\tsearch = function search(text) {\n\t\t\t\ttext = options.caseSensitive ? text : text.toLowerCase();\n\t\t\t\tif (pattern === text || text.indexOf(pattern) !== -1) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tisMatch: true,\n\t\t\t\t\t\tscore: 0\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif (!options.fuzzy) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tisMatch: false,\n\t\t\t\t\t\tscore: 1\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tvar i,\n\t\t\t\t    j,\n\t\t\t\t    textLen = text.length,\n\t\t\t\t    scoreThreshold = MATCH_THRESHOLD,\n\t\t\t\t    bestLoc = text.indexOf(pattern, MATCH_LOCATION),\n\t\t\t\t    binMin,\n\t\t\t\t    binMid,\n\t\t\t\t    binMax = patternLen + textLen,\n\t\t\t\t    lastRd,\n\t\t\t\t    start,\n\t\t\t\t    finish,\n\t\t\t\t    rd,\n\t\t\t\t    charMatch,\n\t\t\t\t    score = 1,\n\t\t\t\t    locations = [];\n\t\t\t\tif (bestLoc !== -1) {\n\t\t\t\t\tscoreThreshold = Math.min(match_bitapScore(0, bestLoc), scoreThreshold);\n\t\t\t\t\tbestLoc = text.lastIndexOf(pattern, MATCH_LOCATION + patternLen);\n\t\t\t\t\tif (bestLoc !== -1) {\n\t\t\t\t\t\tscoreThreshold = Math.min(match_bitapScore(0, bestLoc), scoreThreshold);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbestLoc = -1;\n\t\t\t\tfor (i = 0; i < patternLen; i++) {\n\t\t\t\t\tbinMin = 0;\n\t\t\t\t\tbinMid = binMax;\n\t\t\t\t\twhile (binMin < binMid) {\n\t\t\t\t\t\tif (match_bitapScore(i, MATCH_LOCATION + binMid) <= scoreThreshold) {\n\t\t\t\t\t\t\tbinMin = binMid;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbinMax = binMid;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbinMid = Math.floor((binMax - binMin) / 2 + binMin);\n\t\t\t\t\t}\n\t\t\t\t\tbinMax = binMid;\n\t\t\t\t\tstart = Math.max(1, MATCH_LOCATION - binMid + 1);\n\t\t\t\t\tfinish = Math.min(MATCH_LOCATION + binMid, textLen) + patternLen;\n\t\t\t\t\trd = new Array(finish + 2);\n\t\t\t\t\trd[finish + 1] = (1 << i) - 1;\n\t\t\t\t\tfor (j = finish; j >= start; j--) {\n\t\t\t\t\t\tcharMatch = pattern_alphabet[text.charAt(j - 1)];\n\t\t\t\t\t\tif (i === 0) {\n\t\t\t\t\t\t\trd[j] = (rd[j + 1] << 1 | 1) & charMatch;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trd[j] = (rd[j + 1] << 1 | 1) & charMatch | ((lastRd[j + 1] | lastRd[j]) << 1 | 1) | lastRd[j + 1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (rd[j] & matchmask) {\n\t\t\t\t\t\t\tscore = match_bitapScore(i, j - 1);\n\t\t\t\t\t\t\tif (score <= scoreThreshold) {\n\t\t\t\t\t\t\t\tscoreThreshold = score;\n\t\t\t\t\t\t\t\tbestLoc = j - 1;\n\t\t\t\t\t\t\t\tlocations.push(bestLoc);\n\t\t\t\t\t\t\t\tif (bestLoc > MATCH_LOCATION) {\n\t\t\t\t\t\t\t\t\tstart = Math.max(1, 2 * MATCH_LOCATION - bestLoc);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (match_bitapScore(i + 1, MATCH_LOCATION) > scoreThreshold) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tlastRd = rd;\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tisMatch: bestLoc >= 0,\n\t\t\t\t\tscore: score\n\t\t\t\t};\n\t\t\t};\n\t\t\treturn txt === true ? { 'search': search } : search(txt);\n\t\t};\n\t\t$.vakata.search.defaults = {\n\t\t\tlocation: 0,\n\t\t\tdistance: 100,\n\t\t\tthreshold: 0.6,\n\t\t\tfuzzy: false,\n\t\t\tcaseSensitive: false\n\t\t};\n\t})($);\n\n\t// include the search plugin by default\n\t// $.jstree.defaults.plugins.push(\"search\");\n\n\n\t/**\n  * ### Sort plugin\n  *\n  * Automatically sorts all siblings in the tree according to a sorting function.\n  */\n\n\t/**\n  * the settings function used to sort the nodes.\n  * It is executed in the tree's context, accepts two nodes as arguments and should return `1` or `-1`.\n  * @name $.jstree.defaults.sort\n  * @plugin sort\n  */\n\t$.jstree.defaults.sort = function (a, b) {\n\t\t//return this.get_type(a) === this.get_type(b) ? (this.get_text(a) > this.get_text(b) ? 1 : -1) : this.get_type(a) >= this.get_type(b);\n\t\treturn this.get_text(a) > this.get_text(b) ? 1 : -1;\n\t};\n\t$.jstree.plugins.sort = function (options, parent) {\n\t\tthis.bind = function () {\n\t\t\tparent.bind.call(this);\n\t\t\tthis.element.on(\"model.jstree\", $.proxy(function (e, data) {\n\t\t\t\tthis.sort(data.parent, true);\n\t\t\t}, this)).on(\"rename_node.jstree create_node.jstree\", $.proxy(function (e, data) {\n\t\t\t\tthis.sort(data.parent || data.node.parent, false);\n\t\t\t\tthis.redraw_node(data.parent || data.node.parent, true);\n\t\t\t}, this)).on(\"move_node.jstree copy_node.jstree\", $.proxy(function (e, data) {\n\t\t\t\tthis.sort(data.parent, false);\n\t\t\t\tthis.redraw_node(data.parent, true);\n\t\t\t}, this));\n\t\t};\n\t\t/**\n   * used to sort a node's children\n   * @private\n   * @name sort(obj [, deep])\n   * @param  {mixed} obj the node\n   * @param {Boolean} deep if set to `true` nodes are sorted recursively.\n   * @plugin sort\n   * @trigger search.jstree\n   */\n\t\tthis.sort = function (obj, deep) {\n\t\t\tvar i, j;\n\t\t\tobj = this.get_node(obj);\n\t\t\tif (obj && obj.children && obj.children.length) {\n\t\t\t\tobj.children.sort($.proxy(this.settings.sort, this));\n\t\t\t\tif (deep) {\n\t\t\t\t\tfor (i = 0, j = obj.children_d.length; i < j; i++) {\n\t\t\t\t\t\tthis.sort(obj.children_d[i], false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t};\n\n\t// include the sort plugin by default\n\t// $.jstree.defaults.plugins.push(\"sort\");\n\n\t/**\n  * ### State plugin\n  *\n  * Saves the state of the tree (selected nodes, opened nodes) on the user's computer using available options (localStorage, cookies, etc)\n  */\n\n\tvar to = false;\n\t/**\n  * stores all defaults for the state plugin\n  * @name $.jstree.defaults.state\n  * @plugin state\n  */\n\t$.jstree.defaults.state = {\n\t\t/**\n   * A string for the key to use when saving the current tree (change if using multiple trees in your project). Defaults to `jstree`.\n   * @name $.jstree.defaults.state.key\n   * @plugin state\n   */\n\t\tkey: 'jstree',\n\t\t/**\n   * A space separated list of events that trigger a state save. Defaults to `changed.jstree open_node.jstree close_node.jstree`.\n   * @name $.jstree.defaults.state.events\n   * @plugin state\n   */\n\t\tevents: 'changed.jstree open_node.jstree close_node.jstree check_node.jstree uncheck_node.jstree',\n\t\t/**\n   * Time in milliseconds after which the state will expire. Defaults to 'false' meaning - no expire.\n   * @name $.jstree.defaults.state.ttl\n   * @plugin state\n   */\n\t\tttl: false,\n\t\t/**\n   * A function that will be executed prior to restoring state with one argument - the state object. Can be used to clear unwanted parts of the state.\n   * @name $.jstree.defaults.state.filter\n   * @plugin state\n   */\n\t\tfilter: false\n\t};\n\t$.jstree.plugins.state = function (options, parent) {\n\t\tthis.bind = function () {\n\t\t\tparent.bind.call(this);\n\t\t\tvar bind = $.proxy(function () {\n\t\t\t\tthis.element.on(this.settings.state.events, $.proxy(function () {\n\t\t\t\t\tif (to) {\n\t\t\t\t\t\tclearTimeout(to);\n\t\t\t\t\t}\n\t\t\t\t\tto = setTimeout($.proxy(function () {\n\t\t\t\t\t\tthis.save_state();\n\t\t\t\t\t}, this), 100);\n\t\t\t\t}, this));\n\t\t\t\t/**\n     * triggered when the state plugin is finished restoring the state (and immediately after ready if there is no state to restore).\n     * @event\n     * @name state_ready.jstree\n     * @plugin state\n     */\n\t\t\t\tthis.trigger('state_ready');\n\t\t\t}, this);\n\t\t\tthis.element.on(\"ready.jstree\", $.proxy(function (e, data) {\n\t\t\t\tthis.element.one(\"restore_state.jstree\", bind);\n\t\t\t\tif (!this.restore_state()) {\n\t\t\t\t\tbind();\n\t\t\t\t}\n\t\t\t}, this));\n\t\t};\n\t\t/**\n   * save the state\n   * @name save_state()\n   * @plugin state\n   */\n\t\tthis.save_state = function () {\n\t\t\tvar st = { 'state': this.get_state(), 'ttl': this.settings.state.ttl, 'sec': +new Date() };\n\t\t\t$.vakata.storage.set(this.settings.state.key, JSON.stringify(st));\n\t\t};\n\t\t/**\n   * restore the state from the user's computer\n   * @name restore_state()\n   * @plugin state\n   */\n\t\tthis.restore_state = function () {\n\t\t\tvar k = $.vakata.storage.get(this.settings.state.key);\n\t\t\tif (!!k) {\n\t\t\t\ttry {\n\t\t\t\t\tk = JSON.parse(k);\n\t\t\t\t} catch (ex) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!!k && k.ttl && k.sec && +new Date() - k.sec > k.ttl) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!!k && k.state) {\n\t\t\t\tk = k.state;\n\t\t\t}\n\t\t\tif (!!k && $.isFunction(this.settings.state.filter)) {\n\t\t\t\tk = this.settings.state.filter.call(this, k);\n\t\t\t}\n\t\t\tif (!!k) {\n\t\t\t\tthis.element.one(\"set_state.jstree\", function (e, data) {\n\t\t\t\t\tdata.instance.trigger('restore_state', { 'state': $.extend(true, {}, k) });\n\t\t\t\t});\n\t\t\t\tthis.set_state(k);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\t/**\n   * clear the state on the user's computer\n   * @name clear_state()\n   * @plugin state\n   */\n\t\tthis.clear_state = function () {\n\t\t\treturn $.vakata.storage.del(this.settings.state.key);\n\t\t};\n\t};\n\n\t(function ($, undefined) {\n\t\t$.vakata.storage = {\n\t\t\t// simply specifying the functions in FF throws an error\n\t\t\tset: function set(key, val) {\n\t\t\t\treturn window.localStorage.setItem(key, val);\n\t\t\t},\n\t\t\tget: function get(key) {\n\t\t\t\treturn window.localStorage.getItem(key);\n\t\t\t},\n\t\t\tdel: function del(key) {\n\t\t\t\treturn window.localStorage.removeItem(key);\n\t\t\t}\n\t\t};\n\t})($);\n\n\t// include the state plugin by default\n\t// $.jstree.defaults.plugins.push(\"state\");\n\n\t/**\n  * ### Types plugin\n  *\n  * Makes it possible to add predefined types for groups of nodes, which make it possible to easily control nesting rules and icon for each group.\n  */\n\n\t/**\n  * An object storing all types as key value pairs, where the key is the type name and the value is an object that could contain following keys (all optional).\n  *\n  * * `max_children` the maximum number of immediate children this node type can have. Do not specify or set to `-1` for unlimited.\n  * * `max_depth` the maximum number of nesting this node type can have. A value of `1` would mean that the node can have children, but no grandchildren. Do not specify or set to `-1` for unlimited.\n  * * `valid_children` an array of node type strings, that nodes of this type can have as children. Do not specify or set to `-1` for no limits.\n  * * `icon` a string - can be a path to an icon or a className, if using an image that is in the current directory use a `./` prefix, otherwise it will be detected as a class. Omit to use the default icon from your theme.\n  * * `li_attr` an object of values which will be used to add HTML attributes on the resulting LI DOM node (merged with the node's own data)\n  * * `a_attr` an object of values which will be used to add HTML attributes on the resulting A DOM node (merged with the node's own data)\n  *\n  * There are two predefined types:\n  *\n  * * `#` represents the root of the tree, for example `max_children` would control the maximum number of root nodes.\n  * * `default` represents the default node - any settings here will be applied to all nodes that do not have a type specified.\n  *\n  * @name $.jstree.defaults.types\n  * @plugin types\n  */\n\t$.jstree.defaults.types = {\n\t\t'default': {}\n\t};\n\t$.jstree.defaults.types[$.jstree.root] = {};\n\n\t$.jstree.plugins.types = function (options, parent) {\n\t\tthis.init = function (el, options) {\n\t\t\tvar i, j;\n\t\t\tif (options && options.types && options.types['default']) {\n\t\t\t\tfor (i in options.types) {\n\t\t\t\t\tif (i !== \"default\" && i !== $.jstree.root && options.types.hasOwnProperty(i)) {\n\t\t\t\t\t\tfor (j in options.types['default']) {\n\t\t\t\t\t\t\tif (options.types['default'].hasOwnProperty(j) && options.types[i][j] === undefined) {\n\t\t\t\t\t\t\t\toptions.types[i][j] = options.types['default'][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tparent.init.call(this, el, options);\n\t\t\tthis._model.data[$.jstree.root].type = $.jstree.root;\n\t\t};\n\t\tthis.refresh = function (skip_loading, forget_state) {\n\t\t\tparent.refresh.call(this, skip_loading, forget_state);\n\t\t\tthis._model.data[$.jstree.root].type = $.jstree.root;\n\t\t};\n\t\tthis.bind = function () {\n\t\t\tthis.element.on('model.jstree', $.proxy(function (e, data) {\n\t\t\t\tvar m = this._model.data,\n\t\t\t\t    dpc = data.nodes,\n\t\t\t\t    t = this.settings.types,\n\t\t\t\t    i,\n\t\t\t\t    j,\n\t\t\t\t    c = 'default',\n\t\t\t\t    k;\n\t\t\t\tfor (i = 0, j = dpc.length; i < j; i++) {\n\t\t\t\t\tc = 'default';\n\t\t\t\t\tif (m[dpc[i]].original && m[dpc[i]].original.type && t[m[dpc[i]].original.type]) {\n\t\t\t\t\t\tc = m[dpc[i]].original.type;\n\t\t\t\t\t}\n\t\t\t\t\tif (m[dpc[i]].data && m[dpc[i]].data.jstree && m[dpc[i]].data.jstree.type && t[m[dpc[i]].data.jstree.type]) {\n\t\t\t\t\t\tc = m[dpc[i]].data.jstree.type;\n\t\t\t\t\t}\n\t\t\t\t\tm[dpc[i]].type = c;\n\t\t\t\t\tif (m[dpc[i]].icon === true && t[c].icon !== undefined) {\n\t\t\t\t\t\tm[dpc[i]].icon = t[c].icon;\n\t\t\t\t\t}\n\t\t\t\t\tif (t[c].li_attr !== undefined && _typeof(t[c].li_attr) === 'object') {\n\t\t\t\t\t\tfor (k in t[c].li_attr) {\n\t\t\t\t\t\t\tif (t[c].li_attr.hasOwnProperty(k)) {\n\t\t\t\t\t\t\t\tif (k === 'id') {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t} else if (m[dpc[i]].li_attr[k] === undefined) {\n\t\t\t\t\t\t\t\t\tm[dpc[i]].li_attr[k] = t[c].li_attr[k];\n\t\t\t\t\t\t\t\t} else if (k === 'class') {\n\t\t\t\t\t\t\t\t\tm[dpc[i]].li_attr['class'] = t[c].li_attr['class'] + ' ' + m[dpc[i]].li_attr['class'];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (t[c].a_attr !== undefined && _typeof(t[c].a_attr) === 'object') {\n\t\t\t\t\t\tfor (k in t[c].a_attr) {\n\t\t\t\t\t\t\tif (t[c].a_attr.hasOwnProperty(k)) {\n\t\t\t\t\t\t\t\tif (k === 'id') {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t} else if (m[dpc[i]].a_attr[k] === undefined) {\n\t\t\t\t\t\t\t\t\tm[dpc[i]].a_attr[k] = t[c].a_attr[k];\n\t\t\t\t\t\t\t\t} else if (k === 'href' && m[dpc[i]].a_attr[k] === '#') {\n\t\t\t\t\t\t\t\t\tm[dpc[i]].a_attr['href'] = t[c].a_attr['href'];\n\t\t\t\t\t\t\t\t} else if (k === 'class') {\n\t\t\t\t\t\t\t\t\tm[dpc[i]].a_attr['class'] = t[c].a_attr['class'] + ' ' + m[dpc[i]].a_attr['class'];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tm[$.jstree.root].type = $.jstree.root;\n\t\t\t}, this));\n\t\t\tparent.bind.call(this);\n\t\t};\n\t\tthis.get_json = function (obj, options, flat) {\n\t\t\tvar i,\n\t\t\t    j,\n\t\t\t    m = this._model.data,\n\t\t\t    opt = options ? $.extend(true, {}, options, { no_id: false }) : {},\n\t\t\t    tmp = parent.get_json.call(this, obj, opt, flat);\n\t\t\tif (tmp === false) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif ($.isArray(tmp)) {\n\t\t\t\tfor (i = 0, j = tmp.length; i < j; i++) {\n\t\t\t\t\ttmp[i].type = tmp[i].id && m[tmp[i].id] && m[tmp[i].id].type ? m[tmp[i].id].type : \"default\";\n\t\t\t\t\tif (options && options.no_id) {\n\t\t\t\t\t\tdelete tmp[i].id;\n\t\t\t\t\t\tif (tmp[i].li_attr && tmp[i].li_attr.id) {\n\t\t\t\t\t\t\tdelete tmp[i].li_attr.id;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (tmp[i].a_attr && tmp[i].a_attr.id) {\n\t\t\t\t\t\t\tdelete tmp[i].a_attr.id;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttmp.type = tmp.id && m[tmp.id] && m[tmp.id].type ? m[tmp.id].type : \"default\";\n\t\t\t\tif (options && options.no_id) {\n\t\t\t\t\ttmp = this._delete_ids(tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tmp;\n\t\t};\n\t\tthis._delete_ids = function (tmp) {\n\t\t\tif ($.isArray(tmp)) {\n\t\t\t\tfor (var i = 0, j = tmp.length; i < j; i++) {\n\t\t\t\t\ttmp[i] = this._delete_ids(tmp[i]);\n\t\t\t\t}\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t\tdelete tmp.id;\n\t\t\tif (tmp.li_attr && tmp.li_attr.id) {\n\t\t\t\tdelete tmp.li_attr.id;\n\t\t\t}\n\t\t\tif (tmp.a_attr && tmp.a_attr.id) {\n\t\t\t\tdelete tmp.a_attr.id;\n\t\t\t}\n\t\t\tif (tmp.children && $.isArray(tmp.children)) {\n\t\t\t\ttmp.children = this._delete_ids(tmp.children);\n\t\t\t}\n\t\t\treturn tmp;\n\t\t};\n\t\tthis.check = function (chk, obj, par, pos, more) {\n\t\t\tif (parent.check.call(this, chk, obj, par, pos, more) === false) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tobj = obj && obj.id ? obj : this.get_node(obj);\n\t\t\tpar = par && par.id ? par : this.get_node(par);\n\t\t\tvar m = obj && obj.id ? more && more.origin ? more.origin : $.jstree.reference(obj.id) : null,\n\t\t\t    tmp,\n\t\t\t    d,\n\t\t\t    i,\n\t\t\t    j;\n\t\t\tm = m && m._model && m._model.data ? m._model.data : null;\n\t\t\tswitch (chk) {\n\t\t\t\tcase \"create_node\":\n\t\t\t\tcase \"move_node\":\n\t\t\t\tcase \"copy_node\":\n\t\t\t\t\tif (chk !== 'move_node' || $.inArray(obj.id, par.children) === -1) {\n\t\t\t\t\t\ttmp = this.get_rules(par);\n\t\t\t\t\t\tif (tmp.max_children !== undefined && tmp.max_children !== -1 && tmp.max_children === par.children.length) {\n\t\t\t\t\t\t\tthis._data.core.last_error = { 'error': 'check', 'plugin': 'types', 'id': 'types_01', 'reason': 'max_children prevents function: ' + chk, 'data': JSON.stringify({ 'chk': chk, 'pos': pos, 'obj': obj && obj.id ? obj.id : false, 'par': par && par.id ? par.id : false }) };\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (tmp.valid_children !== undefined && tmp.valid_children !== -1 && $.inArray(obj.type || 'default', tmp.valid_children) === -1) {\n\t\t\t\t\t\t\tthis._data.core.last_error = { 'error': 'check', 'plugin': 'types', 'id': 'types_02', 'reason': 'valid_children prevents function: ' + chk, 'data': JSON.stringify({ 'chk': chk, 'pos': pos, 'obj': obj && obj.id ? obj.id : false, 'par': par && par.id ? par.id : false }) };\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (m && obj.children_d && obj.parents) {\n\t\t\t\t\t\t\td = 0;\n\t\t\t\t\t\t\tfor (i = 0, j = obj.children_d.length; i < j; i++) {\n\t\t\t\t\t\t\t\td = Math.max(d, m[obj.children_d[i]].parents.length);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\td = d - obj.parents.length + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (d <= 0 || d === undefined) {\n\t\t\t\t\t\t\td = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tif (tmp.max_depth !== undefined && tmp.max_depth !== -1 && tmp.max_depth < d) {\n\t\t\t\t\t\t\t\tthis._data.core.last_error = { 'error': 'check', 'plugin': 'types', 'id': 'types_03', 'reason': 'max_depth prevents function: ' + chk, 'data': JSON.stringify({ 'chk': chk, 'pos': pos, 'obj': obj && obj.id ? obj.id : false, 'par': par && par.id ? par.id : false }) };\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpar = this.get_node(par.parent);\n\t\t\t\t\t\t\ttmp = this.get_rules(par);\n\t\t\t\t\t\t\td++;\n\t\t\t\t\t\t} while (par);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn true;\n\t\t};\n\t\t/**\n   * used to retrieve the type settings object for a node\n   * @name get_rules(obj)\n   * @param {mixed} obj the node to find the rules for\n   * @return {Object}\n   * @plugin types\n   */\n\t\tthis.get_rules = function (obj) {\n\t\t\tobj = this.get_node(obj);\n\t\t\tif (!obj) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar tmp = this.get_type(obj, true);\n\t\t\tif (tmp.max_depth === undefined) {\n\t\t\t\ttmp.max_depth = -1;\n\t\t\t}\n\t\t\tif (tmp.max_children === undefined) {\n\t\t\t\ttmp.max_children = -1;\n\t\t\t}\n\t\t\tif (tmp.valid_children === undefined) {\n\t\t\t\ttmp.valid_children = -1;\n\t\t\t}\n\t\t\treturn tmp;\n\t\t};\n\t\t/**\n   * used to retrieve the type string or settings object for a node\n   * @name get_type(obj [, rules])\n   * @param {mixed} obj the node to find the rules for\n   * @param {Boolean} rules if set to `true` instead of a string the settings object will be returned\n   * @return {String|Object}\n   * @plugin types\n   */\n\t\tthis.get_type = function (obj, rules) {\n\t\t\tobj = this.get_node(obj);\n\t\t\treturn !obj ? false : rules ? $.extend({ 'type': obj.type }, this.settings.types[obj.type]) : obj.type;\n\t\t};\n\t\t/**\n   * used to change a node's type\n   * @name set_type(obj, type)\n   * @param {mixed} obj the node to change\n   * @param {String} type the new type\n   * @plugin types\n   */\n\t\tthis.set_type = function (obj, type) {\n\t\t\tvar m = this._model.data,\n\t\t\t    t,\n\t\t\t    t1,\n\t\t\t    t2,\n\t\t\t    old_type,\n\t\t\t    old_icon,\n\t\t\t    k,\n\t\t\t    d,\n\t\t\t    a;\n\t\t\tif ($.isArray(obj)) {\n\t\t\t\tobj = obj.slice();\n\t\t\t\tfor (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n\t\t\t\t\tthis.set_type(obj[t1], type);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tt = this.settings.types;\n\t\t\tobj = this.get_node(obj);\n\t\t\tif (!t[type] || !obj) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\td = this.get_node(obj, true);\n\t\t\tif (d && d.length) {\n\t\t\t\ta = d.children('.jstree-anchor');\n\t\t\t}\n\t\t\told_type = obj.type;\n\t\t\told_icon = this.get_icon(obj);\n\t\t\tobj.type = type;\n\t\t\tif (old_icon === true || !t[old_type] || t[old_type].icon !== undefined && old_icon === t[old_type].icon) {\n\t\t\t\tthis.set_icon(obj, t[type].icon !== undefined ? t[type].icon : true);\n\t\t\t}\n\n\t\t\t// remove old type props\n\t\t\tif (t[old_type] && t[old_type].li_attr !== undefined && _typeof(t[old_type].li_attr) === 'object') {\n\t\t\t\tfor (k in t[old_type].li_attr) {\n\t\t\t\t\tif (t[old_type].li_attr.hasOwnProperty(k)) {\n\t\t\t\t\t\tif (k === 'id') {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t} else if (k === 'class') {\n\t\t\t\t\t\t\tm[obj.id].li_attr['class'] = (m[obj.id].li_attr['class'] || '').replace(t[old_type].li_attr[k], '');\n\t\t\t\t\t\t\tif (d) {\n\t\t\t\t\t\t\t\td.removeClass(t[old_type].li_attr[k]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (m[obj.id].li_attr[k] === t[old_type].li_attr[k]) {\n\t\t\t\t\t\t\tm[obj.id].li_attr[k] = null;\n\t\t\t\t\t\t\tif (d) {\n\t\t\t\t\t\t\t\td.removeAttr(k);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (t[old_type] && t[old_type].a_attr !== undefined && _typeof(t[old_type].a_attr) === 'object') {\n\t\t\t\tfor (k in t[old_type].a_attr) {\n\t\t\t\t\tif (t[old_type].a_attr.hasOwnProperty(k)) {\n\t\t\t\t\t\tif (k === 'id') {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t} else if (k === 'class') {\n\t\t\t\t\t\t\tm[obj.id].a_attr['class'] = (m[obj.id].a_attr['class'] || '').replace(t[old_type].a_attr[k], '');\n\t\t\t\t\t\t\tif (a) {\n\t\t\t\t\t\t\t\ta.removeClass(t[old_type].a_attr[k]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (m[obj.id].a_attr[k] === t[old_type].a_attr[k]) {\n\t\t\t\t\t\t\tif (k === 'href') {\n\t\t\t\t\t\t\t\tm[obj.id].a_attr[k] = '#';\n\t\t\t\t\t\t\t\tif (a) {\n\t\t\t\t\t\t\t\t\ta.attr('href', '#');\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdelete m[obj.id].a_attr[k];\n\t\t\t\t\t\t\t\tif (a) {\n\t\t\t\t\t\t\t\t\ta.removeAttr(k);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// add new props\n\t\t\tif (t[type].li_attr !== undefined && _typeof(t[type].li_attr) === 'object') {\n\t\t\t\tfor (k in t[type].li_attr) {\n\t\t\t\t\tif (t[type].li_attr.hasOwnProperty(k)) {\n\t\t\t\t\t\tif (k === 'id') {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t} else if (m[obj.id].li_attr[k] === undefined) {\n\t\t\t\t\t\t\tm[obj.id].li_attr[k] = t[type].li_attr[k];\n\t\t\t\t\t\t\tif (d) {\n\t\t\t\t\t\t\t\tif (k === 'class') {\n\t\t\t\t\t\t\t\t\td.addClass(t[type].li_attr[k]);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\td.attr(k, t[type].li_attr[k]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (k === 'class') {\n\t\t\t\t\t\t\tm[obj.id].li_attr['class'] = t[type].li_attr[k] + ' ' + m[obj.id].li_attr['class'];\n\t\t\t\t\t\t\tif (d) {\n\t\t\t\t\t\t\t\td.addClass(t[type].li_attr[k]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (t[type].a_attr !== undefined && _typeof(t[type].a_attr) === 'object') {\n\t\t\t\tfor (k in t[type].a_attr) {\n\t\t\t\t\tif (t[type].a_attr.hasOwnProperty(k)) {\n\t\t\t\t\t\tif (k === 'id') {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t} else if (m[obj.id].a_attr[k] === undefined) {\n\t\t\t\t\t\t\tm[obj.id].a_attr[k] = t[type].a_attr[k];\n\t\t\t\t\t\t\tif (a) {\n\t\t\t\t\t\t\t\tif (k === 'class') {\n\t\t\t\t\t\t\t\t\ta.addClass(t[type].a_attr[k]);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ta.attr(k, t[type].a_attr[k]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (k === 'href' && m[obj.id].a_attr[k] === '#') {\n\t\t\t\t\t\t\tm[obj.id].a_attr['href'] = t[type].a_attr['href'];\n\t\t\t\t\t\t\tif (a) {\n\t\t\t\t\t\t\t\ta.attr('href', t[type].a_attr['href']);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (k === 'class') {\n\t\t\t\t\t\t\tm[obj.id].a_attr['class'] = t[type].a_attr['class'] + ' ' + m[obj.id].a_attr['class'];\n\t\t\t\t\t\t\tif (a) {\n\t\t\t\t\t\t\t\ta.addClass(t[type].a_attr[k]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t};\n\t};\n\t// include the types plugin by default\n\t// $.jstree.defaults.plugins.push(\"types\");\n\n\n\t/**\n  * ### Unique plugin\n  *\n  * Enforces that no nodes with the same name can coexist as siblings.\n  */\n\n\t/**\n  * stores all defaults for the unique plugin\n  * @name $.jstree.defaults.unique\n  * @plugin unique\n  */\n\t$.jstree.defaults.unique = {\n\t\t/**\n   * Indicates if the comparison should be case sensitive. Default is `false`.\n   * @name $.jstree.defaults.unique.case_sensitive\n   * @plugin unique\n   */\n\t\tcase_sensitive: false,\n\t\t/**\n   * A callback executed in the instance's scope when a new node is created and the name is already taken, the two arguments are the conflicting name and the counter. The default will produce results like `New node (2)`.\n   * @name $.jstree.defaults.unique.duplicate\n   * @plugin unique\n   */\n\t\tduplicate: function duplicate(name, counter) {\n\t\t\treturn name + ' (' + counter + ')';\n\t\t}\n\t};\n\n\t$.jstree.plugins.unique = function (options, parent) {\n\t\tthis.check = function (chk, obj, par, pos, more) {\n\t\t\tif (parent.check.call(this, chk, obj, par, pos, more) === false) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tobj = obj && obj.id ? obj : this.get_node(obj);\n\t\t\tpar = par && par.id ? par : this.get_node(par);\n\t\t\tif (!par || !par.children) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tvar n = chk === \"rename_node\" ? pos : obj.text,\n\t\t\t    c = [],\n\t\t\t    s = this.settings.unique.case_sensitive,\n\t\t\t    m = this._model.data,\n\t\t\t    i,\n\t\t\t    j;\n\t\t\tfor (i = 0, j = par.children.length; i < j; i++) {\n\t\t\t\tc.push(s ? m[par.children[i]].text : m[par.children[i]].text.toLowerCase());\n\t\t\t}\n\t\t\tif (!s) {\n\t\t\t\tn = n.toLowerCase();\n\t\t\t}\n\t\t\tswitch (chk) {\n\t\t\t\tcase \"delete_node\":\n\t\t\t\t\treturn true;\n\t\t\t\tcase \"rename_node\":\n\t\t\t\t\ti = $.inArray(n, c) === -1 || obj.text && obj.text[s ? 'toString' : 'toLowerCase']() === n;\n\t\t\t\t\tif (!i) {\n\t\t\t\t\t\tthis._data.core.last_error = { 'error': 'check', 'plugin': 'unique', 'id': 'unique_01', 'reason': 'Child with name ' + n + ' already exists. Preventing: ' + chk, 'data': JSON.stringify({ 'chk': chk, 'pos': pos, 'obj': obj && obj.id ? obj.id : false, 'par': par && par.id ? par.id : false }) };\n\t\t\t\t\t}\n\t\t\t\t\treturn i;\n\t\t\t\tcase \"create_node\":\n\t\t\t\t\ti = $.inArray(n, c) === -1;\n\t\t\t\t\tif (!i) {\n\t\t\t\t\t\tthis._data.core.last_error = { 'error': 'check', 'plugin': 'unique', 'id': 'unique_04', 'reason': 'Child with name ' + n + ' already exists. Preventing: ' + chk, 'data': JSON.stringify({ 'chk': chk, 'pos': pos, 'obj': obj && obj.id ? obj.id : false, 'par': par && par.id ? par.id : false }) };\n\t\t\t\t\t}\n\t\t\t\t\treturn i;\n\t\t\t\tcase \"copy_node\":\n\t\t\t\t\ti = $.inArray(n, c) === -1;\n\t\t\t\t\tif (!i) {\n\t\t\t\t\t\tthis._data.core.last_error = { 'error': 'check', 'plugin': 'unique', 'id': 'unique_02', 'reason': 'Child with name ' + n + ' already exists. Preventing: ' + chk, 'data': JSON.stringify({ 'chk': chk, 'pos': pos, 'obj': obj && obj.id ? obj.id : false, 'par': par && par.id ? par.id : false }) };\n\t\t\t\t\t}\n\t\t\t\t\treturn i;\n\t\t\t\tcase \"move_node\":\n\t\t\t\t\ti = obj.parent === par.id && (!more || !more.is_multi) || $.inArray(n, c) === -1;\n\t\t\t\t\tif (!i) {\n\t\t\t\t\t\tthis._data.core.last_error = { 'error': 'check', 'plugin': 'unique', 'id': 'unique_03', 'reason': 'Child with name ' + n + ' already exists. Preventing: ' + chk, 'data': JSON.stringify({ 'chk': chk, 'pos': pos, 'obj': obj && obj.id ? obj.id : false, 'par': par && par.id ? par.id : false }) };\n\t\t\t\t\t}\n\t\t\t\t\treturn i;\n\t\t\t}\n\t\t\treturn true;\n\t\t};\n\t\tthis.create_node = function (par, node, pos, callback, is_loaded) {\n\t\t\tif (!node || node.text === undefined) {\n\t\t\t\tif (par === null) {\n\t\t\t\t\tpar = $.jstree.root;\n\t\t\t\t}\n\t\t\t\tpar = this.get_node(par);\n\t\t\t\tif (!par) {\n\t\t\t\t\treturn parent.create_node.call(this, par, node, pos, callback, is_loaded);\n\t\t\t\t}\n\t\t\t\tpos = pos === undefined ? \"last\" : pos;\n\t\t\t\tif (!pos.toString().match(/^(before|after)$/) && !is_loaded && !this.is_loaded(par)) {\n\t\t\t\t\treturn parent.create_node.call(this, par, node, pos, callback, is_loaded);\n\t\t\t\t}\n\t\t\t\tif (!node) {\n\t\t\t\t\tnode = {};\n\t\t\t\t}\n\t\t\t\tvar tmp,\n\t\t\t\t    n,\n\t\t\t\t    dpc,\n\t\t\t\t    i,\n\t\t\t\t    j,\n\t\t\t\t    m = this._model.data,\n\t\t\t\t    s = this.settings.unique.case_sensitive,\n\t\t\t\t    cb = this.settings.unique.duplicate;\n\t\t\t\tn = tmp = this.get_string('New node');\n\t\t\t\tdpc = [];\n\t\t\t\tfor (i = 0, j = par.children.length; i < j; i++) {\n\t\t\t\t\tdpc.push(s ? m[par.children[i]].text : m[par.children[i]].text.toLowerCase());\n\t\t\t\t}\n\t\t\t\ti = 1;\n\t\t\t\twhile ($.inArray(s ? n : n.toLowerCase(), dpc) !== -1) {\n\t\t\t\t\tn = cb.call(this, tmp, ++i).toString();\n\t\t\t\t}\n\t\t\t\tnode.text = n;\n\t\t\t}\n\t\t\treturn parent.create_node.call(this, par, node, pos, callback, is_loaded);\n\t\t};\n\t};\n\n\t// include the unique plugin by default\n\t// $.jstree.defaults.plugins.push(\"unique\");\n\n\n\t/**\n  * ### Wholerow plugin\n  *\n  * Makes each node appear block level. Making selection easier. May cause slow down for large trees in old browsers.\n  */\n\n\tvar div = document.createElement('DIV');\n\tdiv.setAttribute('unselectable', 'on');\n\tdiv.setAttribute('role', 'presentation');\n\tdiv.className = 'jstree-wholerow';\n\tdiv.innerHTML = '&#160;';\n\t$.jstree.plugins.wholerow = function (options, parent) {\n\t\tthis.bind = function () {\n\t\t\tparent.bind.call(this);\n\n\t\t\tthis.element.on('ready.jstree set_state.jstree', $.proxy(function () {\n\t\t\t\tthis.hide_dots();\n\t\t\t}, this)).on(\"init.jstree loading.jstree ready.jstree\", $.proxy(function () {\n\t\t\t\t//div.style.height = this._data.core.li_height + 'px';\n\t\t\t\tthis.get_container_ul().addClass('jstree-wholerow-ul');\n\t\t\t}, this)).on(\"deselect_all.jstree\", $.proxy(function (e, data) {\n\t\t\t\tthis.element.find('.jstree-wholerow-clicked').removeClass('jstree-wholerow-clicked');\n\t\t\t}, this)).on(\"changed.jstree\", $.proxy(function (e, data) {\n\t\t\t\tthis.element.find('.jstree-wholerow-clicked').removeClass('jstree-wholerow-clicked');\n\t\t\t\tvar tmp = false,\n\t\t\t\t    i,\n\t\t\t\t    j;\n\t\t\t\tfor (i = 0, j = data.selected.length; i < j; i++) {\n\t\t\t\t\ttmp = this.get_node(data.selected[i], true);\n\t\t\t\t\tif (tmp && tmp.length) {\n\t\t\t\t\t\ttmp.children('.jstree-wholerow').addClass('jstree-wholerow-clicked');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, this)).on(\"open_node.jstree\", $.proxy(function (e, data) {\n\t\t\t\tthis.get_node(data.node, true).find('.jstree-clicked').parent().children('.jstree-wholerow').addClass('jstree-wholerow-clicked');\n\t\t\t}, this)).on(\"hover_node.jstree dehover_node.jstree\", $.proxy(function (e, data) {\n\t\t\t\tif (e.type === \"hover_node\" && this.is_disabled(data.node)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.get_node(data.node, true).children('.jstree-wholerow')[e.type === \"hover_node\" ? \"addClass\" : \"removeClass\"]('jstree-wholerow-hovered');\n\t\t\t}, this)).on(\"contextmenu.jstree\", \".jstree-wholerow\", $.proxy(function (e) {\n\t\t\t\tif (this._data.contextmenu) {\n\t\t\t\t\te.preventDefault();\n\t\t\t\t\tvar tmp = $.Event('contextmenu', { metaKey: e.metaKey, ctrlKey: e.ctrlKey, altKey: e.altKey, shiftKey: e.shiftKey, pageX: e.pageX, pageY: e.pageY });\n\t\t\t\t\t$(e.currentTarget).closest(\".jstree-node\").children(\".jstree-anchor\").first().trigger(tmp);\n\t\t\t\t}\n\t\t\t}, this))\n\t\t\t/*!\n   .on(\"mousedown.jstree touchstart.jstree\", \".jstree-wholerow\", function (e) {\n   \t\tif(e.target === e.currentTarget) {\n   \t\t\tvar a = $(e.currentTarget).closest(\".jstree-node\").children(\".jstree-anchor\");\n   \t\t\te.target = a[0];\n   \t\t\ta.trigger(e);\n   \t\t}\n   \t})\n   */\n\t\t\t.on(\"click.jstree\", \".jstree-wholerow\", function (e) {\n\t\t\t\te.stopImmediatePropagation();\n\t\t\t\tvar tmp = $.Event('click', { metaKey: e.metaKey, ctrlKey: e.ctrlKey, altKey: e.altKey, shiftKey: e.shiftKey });\n\t\t\t\t$(e.currentTarget).closest(\".jstree-node\").children(\".jstree-anchor\").first().trigger(tmp).focus();\n\t\t\t}).on(\"dblclick.jstree\", \".jstree-wholerow\", function (e) {\n\t\t\t\te.stopImmediatePropagation();\n\t\t\t\tvar tmp = $.Event('dblclick', { metaKey: e.metaKey, ctrlKey: e.ctrlKey, altKey: e.altKey, shiftKey: e.shiftKey });\n\t\t\t\t$(e.currentTarget).closest(\".jstree-node\").children(\".jstree-anchor\").first().trigger(tmp).focus();\n\t\t\t}).on(\"click.jstree\", \".jstree-leaf > .jstree-ocl\", $.proxy(function (e) {\n\t\t\t\te.stopImmediatePropagation();\n\t\t\t\tvar tmp = $.Event('click', { metaKey: e.metaKey, ctrlKey: e.ctrlKey, altKey: e.altKey, shiftKey: e.shiftKey });\n\t\t\t\t$(e.currentTarget).closest(\".jstree-node\").children(\".jstree-anchor\").first().trigger(tmp).focus();\n\t\t\t}, this)).on(\"mouseover.jstree\", \".jstree-wholerow, .jstree-icon\", $.proxy(function (e) {\n\t\t\t\te.stopImmediatePropagation();\n\t\t\t\tif (!this.is_disabled(e.currentTarget)) {\n\t\t\t\t\tthis.hover_node(e.currentTarget);\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}, this)).on(\"mouseleave.jstree\", \".jstree-node\", $.proxy(function (e) {\n\t\t\t\tthis.dehover_node(e.currentTarget);\n\t\t\t}, this));\n\t\t};\n\t\tthis.teardown = function () {\n\t\t\tif (this.settings.wholerow) {\n\t\t\t\tthis.element.find(\".jstree-wholerow\").remove();\n\t\t\t}\n\t\t\tparent.teardown.call(this);\n\t\t};\n\t\tthis.redraw_node = function (obj, deep, callback, force_render) {\n\t\t\tobj = parent.redraw_node.apply(this, arguments);\n\t\t\tif (obj) {\n\t\t\t\tvar tmp = div.cloneNode(true);\n\t\t\t\t//tmp.style.height = this._data.core.li_height + 'px';\n\t\t\t\tif ($.inArray(obj.id, this._data.core.selected) !== -1) {\n\t\t\t\t\ttmp.className += ' jstree-wholerow-clicked';\n\t\t\t\t}\n\t\t\t\tif (this._data.core.focused && this._data.core.focused === obj.id) {\n\t\t\t\t\ttmp.className += ' jstree-wholerow-hovered';\n\t\t\t\t}\n\t\t\t\tobj.insertBefore(tmp, obj.childNodes[0]);\n\t\t\t}\n\t\t\treturn obj;\n\t\t};\n\t};\n\t// include the wholerow plugin by default\n\t// $.jstree.defaults.plugins.push(\"wholerow\");\n\tif (document.registerElement && Object && Object.create) {\n\t\tvar proto = Object.create(HTMLElement.prototype);\n\t\tproto.createdCallback = function () {\n\t\t\tvar c = { core: {}, plugins: [] },\n\t\t\t    i;\n\t\t\tfor (i in $.jstree.plugins) {\n\t\t\t\tif ($.jstree.plugins.hasOwnProperty(i) && this.attributes[i]) {\n\t\t\t\t\tc.plugins.push(i);\n\t\t\t\t\tif (this.getAttribute(i) && JSON.parse(this.getAttribute(i))) {\n\t\t\t\t\t\tc[i] = JSON.parse(this.getAttribute(i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (i in $.jstree.defaults.core) {\n\t\t\t\tif ($.jstree.defaults.core.hasOwnProperty(i) && this.attributes[i]) {\n\t\t\t\t\tc.core[i] = JSON.parse(this.getAttribute(i)) || this.getAttribute(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\t$(this).jstree(c);\n\t\t};\n\t\t// proto.attributeChangedCallback = function (name, previous, value) { };\n\t\ttry {\n\t\t\tdocument.registerElement(\"vakata-jstree\", { prototype: proto });\n\t\t} catch (ignore) {}\n\t}\n});"

/***/ }),

/***/ "./node_modules/script-loader/addScript.js":
/*!*************************************************!*\
  !*** ./node_modules/script-loader/addScript.js ***!
  \*************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
module.exports = function(src) {
	function log(error) {
		(typeof console !== "undefined")
		&& (console.error || console.log)("[Script Loader]", error);
	}

	// Check for IE =< 8
	function isIE() {
		return typeof attachEvent !== "undefined" && typeof addEventListener === "undefined";
	}

	try {
		if (typeof execScript !== "undefined" && isIE()) {
			execScript(src);
		} else if (typeof eval !== "undefined") {
			eval.call(null, src);
		} else {
			log("EvalError: No eval function available");
		}
	} catch (error) {
		log(error);
	}
}


/***/ }),

/***/ "./node_modules/script-loader/index.js!./assets/js/jstree-3.3.3.js":
/*!****************************************************************!*\
  !*** ./node_modules/script-loader!./assets/js/jstree-3.3.3.js ***!
  \****************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! !./node_modules/script-loader/addScript.js */ "./node_modules/script-loader/addScript.js")(__webpack_require__(/*! !./node_modules/raw-loader!./node_modules/babel-loader/lib??ref--0-0!./assets/js/jstree-3.3.3.js */ "./node_modules/raw-loader/index.js!./node_modules/babel-loader/lib/index.js??ref--0-0!./assets/js/jstree-3.3.3.js")+"\n\n// SCRIPT-LOADER FOOTER\n//# sourceURL=script:///home/konstantin/workspace/mlab.local.test/node_modules/babel-loader/lib/index.js%3F?ref--0-0!/home/konstantin/workspace/mlab.local.test/assets/js/jstree-3.3.3.js")

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgN2IwY2EwNWM2NGViOWYyYjUyNjkiLCJ3ZWJwYWNrOi8vLy4vYXNzZXRzL2pzL2FkbWluLmpzIiwid2VicGFjazovLy8uL2Fzc2V0cy9qcy9qc3RyZWUtMy4zLjMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzIiwid2VicGFjazovLy8uL2Fzc2V0cy9qcy9qc3RyZWUtMy4zLjMuanM/NDc1OCJdLCJuYW1lcyI6WyJyZXF1aXJlIl0sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUEyQiwwQkFBMEIsRUFBRTtBQUN2RCx5Q0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBc0QsK0RBQStEOztBQUVySDtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM3REE7Ozs7O0FBS0FBLG1CQUFPQSxDQUFDLDBHQUFSLEU7Ozs7Ozs7Ozs7OztBQ0xBLDBIQUEwSCxtQkFBbUIsRUFBRSxtQkFBbUIsa0lBQWtJLEdBQUcsK0dBQStHLG1CQUFtQix1REFBdUQsa0NBQWtDLEtBQUssNERBQTRELGtEQUFrRCxLQUFLLE9BQU8sc0JBQXNCLEtBQUssR0FBRywyQkFBMkIsbUJBQW1CLG9tQkFBb21CLGFBQWEsS0FBSyw4UkFBOFIsd1BBQXdQLGtQQUFrUCwwT0FBME8sd0hBQXdILCtIQUErSCxhQUFhLDRCQUE0QixpR0FBaUcseUJBQXlCLDZGQUE2RixPQUFPLCtFQUErRSxPQUFPLHFF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QUF1RCwyQ0FBMkMsaUJBQWlCLFNBQVMsZUFBZSxlQUFlLHFDQUFxQyx5RUFBeUUsOEJBQThCLDJFQUEyRSxzREFBc0QsYUFBYSxXQUFXLFNBQVMsMkNBQTJDLCtFQUErRSxpRkFBaUYsV0FBVyxTQUFTLDBCQUEwQixRQUFRLDRFQUE0RSxHQUFHLFdBQVcscURBQXFELG1CQUFtQixFQUFFLE9BQU8sa0JBQWtCLEtBQUssR0FBRyxFQUFFLEM7Ozs7Ozs7Ozs7OztBQ0FqdnhVO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMxQkEsbUJBQU8sQ0FBQyw2RkFBc0YsRUFBRSxtQkFBTyxDQUFDLDJOQUFnUCwyTiIsImZpbGUiOiJhZG1pbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIi9idWlsZC9cIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vYXNzZXRzL2pzL2FkbWluLmpzXCIpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIDdiMGNhMDVjNjRlYjlmMmI1MjY5IiwiLyogXG4gKiBUbyBjaGFuZ2UgdGhpcyBsaWNlbnNlIGhlYWRlciwgY2hvb3NlIExpY2Vuc2UgSGVhZGVycyBpbiBQcm9qZWN0IFByb3BlcnRpZXMuXG4gKiBUbyBjaGFuZ2UgdGhpcyB0ZW1wbGF0ZSBmaWxlLCBjaG9vc2UgVG9vbHMgfCBUZW1wbGF0ZXNcbiAqIGFuZCBvcGVuIHRoZSB0ZW1wbGF0ZSBpbiB0aGUgZWRpdG9yLlxuICovXG5yZXF1aXJlKCdzY3JpcHQtbG9hZGVyIS4vanN0cmVlLTMuMy4zLmpzJyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9hc3NldHMvanMvYWRtaW4uanMiLCJtb2R1bGUuZXhwb3J0cyA9IFwidmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFxcXCJzeW1ib2xcXFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFxcXCJzeW1ib2xcXFwiIDogdHlwZW9mIG9iajsgfTtcXG5cXG4vKmdsb2JhbHMgalF1ZXJ5LCBkZWZpbmUsIG1vZHVsZSwgZXhwb3J0cywgcmVxdWlyZSwgd2luZG93LCBkb2N1bWVudCwgcG9zdE1lc3NhZ2UgKi9cXG4oZnVuY3Rpb24gKGZhY3RvcnkpIHtcXG5cXHRcXFwidXNlIHN0cmljdFxcXCI7XFxuXFxuXFx0aWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xcblxcdFxcdGRlZmluZShbJ2pxdWVyeSddLCBmYWN0b3J5KTtcXG5cXHR9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XFxuXFx0XFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoJ2pxdWVyeScpKTtcXG5cXHR9IGVsc2Uge1xcblxcdFxcdGZhY3RvcnkoalF1ZXJ5KTtcXG5cXHR9XFxufSkoZnVuY3Rpb24gKCQsIHVuZGVmaW5lZCkge1xcblxcdFxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXHQvKiFcXG4gICoganNUcmVlIDMuMy4zXFxuICAqIGh0dHA6Ly9qc3RyZWUuY29tL1xcbiAgKlxcbiAgKiBDb3B5cmlnaHQgKGMpIDIwMTQgSXZhbiBCb3poYW5vdiAoaHR0cDovL3Zha2F0YS5jb20pXFxuICAqXFxuICAqIExpY2Vuc2VkIHNhbWUgYXMganF1ZXJ5IC0gdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNSVQgTGljZW5zZVxcbiAgKiAgIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXFxuICAqL1xcblxcdC8qIVxcbiAgKiBpZiB1c2luZyBqc2xpbnQgcGxlYXNlIGFsbG93IGZvciB0aGUgalF1ZXJ5IGdsb2JhbCBhbmQgdXNlIGZvbGxvd2luZyBvcHRpb25zOlxcbiAgKiBqc2xpbnQ6IGxvb3BmdW5jOiB0cnVlLCBicm93c2VyOiB0cnVlLCBhc3M6IHRydWUsIGJpdHdpc2U6IHRydWUsIGNvbnRpbnVlOiB0cnVlLCBub21lbjogdHJ1ZSwgcGx1c3BsdXM6IHRydWUsIHJlZ2V4cDogdHJ1ZSwgdW5wYXJhbTogdHJ1ZSwgdG9kbzogdHJ1ZSwgd2hpdGU6IHRydWVcXG4gICovXFxuXFx0Lypqc2hpbnQgLVcwODMgKi9cXG5cXG5cXHQvLyBwcmV2ZW50IGFub3RoZXIgbG9hZD8gbWF5YmUgdGhlcmUgaXMgYSBiZXR0ZXIgd2F5P1xcblxcblxcdGlmICgkLmpzdHJlZSkge1xcblxcdFxcdHJldHVybjtcXG5cXHR9XFxuXFxuXFx0LyoqXFxuICAqICMjIyBqc1RyZWUgY29yZSBmdW5jdGlvbmFsaXR5XFxuICAqL1xcblxcblxcdC8vIGludGVybmFsIHZhcmlhYmxlc1xcblxcdHZhciBpbnN0YW5jZV9jb3VudGVyID0gMCxcXG5cXHQgICAgY2NwX25vZGUgPSBmYWxzZSxcXG5cXHQgICAgY2NwX21vZGUgPSBmYWxzZSxcXG5cXHQgICAgY2NwX2luc3QgPSBmYWxzZSxcXG5cXHQgICAgdGhlbWVzX2xvYWRlZCA9IFtdLFxcblxcdCAgICBzcmMgPSAkKCdzY3JpcHQ6bGFzdCcpLmF0dHIoJ3NyYycpLFxcblxcdCAgICBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDsgLy8gbG9jYWwgdmFyaWFibGUgaXMgYWx3YXlzIGZhc3RlciB0byBhY2Nlc3MgdGhlbiBhIGdsb2JhbFxcblxcblxcdC8qKlxcbiAgKiBob2xkcyBhbGwganN0cmVlIHJlbGF0ZWQgZnVuY3Rpb25zIGFuZCB2YXJpYWJsZXMsIGluY2x1ZGluZyB0aGUgYWN0dWFsIGNsYXNzIGFuZCBtZXRob2RzIHRvIGNyZWF0ZSwgYWNjZXNzIGFuZCBtYW5pcHVsYXRlIGluc3RhbmNlcy5cXG4gICogQG5hbWUgJC5qc3RyZWVcXG4gICovXFxuXFx0JC5qc3RyZWUgPSB7XFxuXFx0XFx0LyoqXFxuICAgKiBzcGVjaWZpZXMgdGhlIGpzdHJlZSB2ZXJzaW9uIGluIHVzZVxcbiAgICogQG5hbWUgJC5qc3RyZWUudmVyc2lvblxcbiAgICovXFxuXFx0XFx0dmVyc2lvbjogJzMuMy4zJyxcXG5cXHRcXHQvKipcXG4gICAqIGhvbGRzIGFsbCB0aGUgZGVmYXVsdCBvcHRpb25zIHVzZWQgd2hlbiBjcmVhdGluZyBuZXcgaW5zdGFuY2VzXFxuICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0c1xcbiAgICovXFxuXFx0XFx0ZGVmYXVsdHM6IHtcXG5cXHRcXHRcXHQvKipcXG4gICAgKiBjb25maWd1cmUgd2hpY2ggcGx1Z2lucyB3aWxsIGJlIGFjdGl2ZSBvbiBhbiBpbnN0YW5jZS4gU2hvdWxkIGJlIGFuIGFycmF5IG9mIHN0cmluZ3MsIHdoZXJlIGVhY2ggZWxlbWVudCBpcyBhIHBsdWdpbiBuYW1lLiBUaGUgZGVmYXVsdCBpcyBgW11gXFxuICAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMucGx1Z2luc1xcbiAgICAqL1xcblxcdFxcdFxcdHBsdWdpbnM6IFtdXFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIHN0b3JlcyBhbGwgbG9hZGVkIGpzdHJlZSBwbHVnaW5zICh1c2VkIGludGVybmFsbHkpXFxuICAgKiBAbmFtZSAkLmpzdHJlZS5wbHVnaW5zXFxuICAgKi9cXG5cXHRcXHRwbHVnaW5zOiB7fSxcXG5cXHRcXHRwYXRoOiBzcmMgJiYgc3JjLmluZGV4T2YoJy8nKSAhPT0gLTEgPyBzcmMucmVwbGFjZSgvXFxcXC9bXlxcXFwvXSskLywgJycpIDogJycsXFxuXFx0XFx0aWRyZWdleDogL1tcXFxcXFxcXDomIV58KClcXFxcW1xcXFxdPD5AKicrfiNcXFwiOy4sPVxcXFwtIFxcXFwvJHt9JT9gXS9nLFxcblxcdFxcdHJvb3Q6ICcjJ1xcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqIGNyZWF0ZXMgYSBqc3RyZWUgaW5zdGFuY2VcXG4gICogQG5hbWUgJC5qc3RyZWUuY3JlYXRlKGVsIFssIG9wdGlvbnNdKVxcbiAgKiBAcGFyYW0ge0RPTUVsZW1lbnR8alF1ZXJ5fFN0cmluZ30gZWwgdGhlIGVsZW1lbnQgdG8gY3JlYXRlIHRoZSBpbnN0YW5jZSBvbiwgY2FuIGJlIGpRdWVyeSBleHRlbmRlZCBvciBhIHNlbGVjdG9yXFxuICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIG9wdGlvbnMgZm9yIHRoaXMgaW5zdGFuY2UgKGV4dGVuZHMgYCQuanN0cmVlLmRlZmF1bHRzYClcXG4gICogQHJldHVybiB7anNUcmVlfSB0aGUgbmV3IGluc3RhbmNlXFxuICAqL1xcblxcdCQuanN0cmVlLmNyZWF0ZSA9IGZ1bmN0aW9uIChlbCwgb3B0aW9ucykge1xcblxcdFxcdHZhciB0bXAgPSBuZXcgJC5qc3RyZWUuY29yZSgrK2luc3RhbmNlX2NvdW50ZXIpLFxcblxcdFxcdCAgICBvcHQgPSBvcHRpb25zO1xcblxcdFxcdG9wdGlvbnMgPSAkLmV4dGVuZCh0cnVlLCB7fSwgJC5qc3RyZWUuZGVmYXVsdHMsIG9wdGlvbnMpO1xcblxcdFxcdGlmIChvcHQgJiYgb3B0LnBsdWdpbnMpIHtcXG5cXHRcXHRcXHRvcHRpb25zLnBsdWdpbnMgPSBvcHQucGx1Z2lucztcXG5cXHRcXHR9XFxuXFx0XFx0JC5lYWNoKG9wdGlvbnMucGx1Z2lucywgZnVuY3Rpb24gKGksIGspIHtcXG5cXHRcXHRcXHRpZiAoaSAhPT0gJ2NvcmUnKSB7XFxuXFx0XFx0XFx0XFx0dG1wID0gdG1wLnBsdWdpbihrLCBvcHRpb25zW2tdKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSk7XFxuXFx0XFx0JChlbCkuZGF0YSgnanN0cmVlJywgdG1wKTtcXG5cXHRcXHR0bXAuaW5pdChlbCwgb3B0aW9ucyk7XFxuXFx0XFx0cmV0dXJuIHRtcDtcXG5cXHR9O1xcblxcdC8qKlxcbiAgKiByZW1vdmUgYWxsIHRyYWNlcyBvZiBqc3RyZWUgZnJvbSB0aGUgRE9NIGFuZCBkZXN0cm95IGFsbCBpbnN0YW5jZXNcXG4gICogQG5hbWUgJC5qc3RyZWUuZGVzdHJveSgpXFxuICAqL1xcblxcdCQuanN0cmVlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0JCgnLmpzdHJlZTpqc3RyZWUnKS5qc3RyZWUoJ2Rlc3Ryb3knKTtcXG5cXHRcXHQkKGRvY3VtZW50KS5vZmYoJy5qc3RyZWUnKTtcXG5cXHR9O1xcblxcdC8qKlxcbiAgKiB0aGUganN0cmVlIGNsYXNzIGNvbnN0cnVjdG9yLCB1c2VkIG9ubHkgaW50ZXJuYWxseVxcbiAgKiBAcHJpdmF0ZVxcbiAgKiBAbmFtZSAkLmpzdHJlZS5jb3JlKGlkKVxcbiAgKiBAcGFyYW0ge051bWJlcn0gaWQgdGhpcyBpbnN0YW5jZSdzIGluZGV4XFxuICAqL1xcblxcdCQuanN0cmVlLmNvcmUgPSBmdW5jdGlvbiAoaWQpIHtcXG5cXHRcXHR0aGlzLl9pZCA9IGlkO1xcblxcdFxcdHRoaXMuX2NudCA9IDA7XFxuXFx0XFx0dGhpcy5fd3JrID0gbnVsbDtcXG5cXHRcXHR0aGlzLl9kYXRhID0ge1xcblxcdFxcdFxcdGNvcmU6IHtcXG5cXHRcXHRcXHRcXHR0aGVtZXM6IHtcXG5cXHRcXHRcXHRcXHRcXHRuYW1lOiBmYWxzZSxcXG5cXHRcXHRcXHRcXHRcXHRkb3RzOiBmYWxzZSxcXG5cXHRcXHRcXHRcXHRcXHRpY29uczogZmFsc2UsXFxuXFx0XFx0XFx0XFx0XFx0ZWxsaXBzaXM6IGZhbHNlXFxuXFx0XFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRcXHRzZWxlY3RlZDogW10sXFxuXFx0XFx0XFx0XFx0bGFzdF9lcnJvcjoge30sXFxuXFx0XFx0XFx0XFx0d29ya2luZzogZmFsc2UsXFxuXFx0XFx0XFx0XFx0d29ya2VyX3F1ZXVlOiBbXSxcXG5cXHRcXHRcXHRcXHRmb2N1c2VkOiBudWxsXFxuXFx0XFx0XFx0fVxcblxcdFxcdH07XFxuXFx0fTtcXG5cXHQvKipcXG4gICogZ2V0IGEgcmVmZXJlbmNlIHRvIGFuIGV4aXN0aW5nIGluc3RhbmNlXFxuICAqXFxuICAqIF9fRXhhbXBsZXNfX1xcbiAgKlxcbiAgKlxcdC8vIHByb3ZpZGVkIGEgY29udGFpbmVyIHdpdGggYW4gSUQgb2YgXFxcInRyZWVcXFwiLCBhbmQgYSBuZXN0ZWQgbm9kZSB3aXRoIGFuIElEIG9mIFxcXCJicmFuY2hcXFwiXFxuICAqXFx0Ly8gYWxsIG9mIHRoZXJlIHdpbGwgcmV0dXJuIHRoZSBzYW1lIGluc3RhbmNlXFxuICAqXFx0JC5qc3RyZWUucmVmZXJlbmNlKCd0cmVlJyk7XFxuICAqXFx0JC5qc3RyZWUucmVmZXJlbmNlKCcjdHJlZScpO1xcbiAgKlxcdCQuanN0cmVlLnJlZmVyZW5jZSgkKCcjdHJlZScpKTtcXG4gICpcXHQkLmpzdHJlZS5yZWZlcmVuY2UoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SUQoJ3RyZWUnKSk7XFxuICAqXFx0JC5qc3RyZWUucmVmZXJlbmNlKCdicmFuY2gnKTtcXG4gICpcXHQkLmpzdHJlZS5yZWZlcmVuY2UoJyNicmFuY2gnKTtcXG4gICpcXHQkLmpzdHJlZS5yZWZlcmVuY2UoJCgnI2JyYW5jaCcpKTtcXG4gICpcXHQkLmpzdHJlZS5yZWZlcmVuY2UoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SUQoJ2JyYW5jaCcpKTtcXG4gICpcXG4gICogQG5hbWUgJC5qc3RyZWUucmVmZXJlbmNlKG5lZWRsZSlcXG4gICogQHBhcmFtIHtET01FbGVtZW50fGpRdWVyeXxTdHJpbmd9IG5lZWRsZVxcbiAgKiBAcmV0dXJuIHtqc1RyZWV8bnVsbH0gdGhlIGluc3RhbmNlIG9yIGBudWxsYCBpZiBub3QgZm91bmRcXG4gICovXFxuXFx0JC5qc3RyZWUucmVmZXJlbmNlID0gZnVuY3Rpb24gKG5lZWRsZSkge1xcblxcdFxcdHZhciB0bXAgPSBudWxsLFxcblxcdFxcdCAgICBvYmogPSBudWxsO1xcblxcdFxcdGlmIChuZWVkbGUgJiYgbmVlZGxlLmlkICYmICghbmVlZGxlLnRhZ05hbWUgfHwgIW5lZWRsZS5ub2RlVHlwZSkpIHtcXG5cXHRcXHRcXHRuZWVkbGUgPSBuZWVkbGUuaWQ7XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICghb2JqIHx8ICFvYmoubGVuZ3RoKSB7XFxuXFx0XFx0XFx0dHJ5IHtcXG5cXHRcXHRcXHRcXHRvYmogPSAkKG5lZWRsZSk7XFxuXFx0XFx0XFx0fSBjYXRjaCAoaWdub3JlKSB7fVxcblxcdFxcdH1cXG5cXHRcXHRpZiAoIW9iaiB8fCAhb2JqLmxlbmd0aCkge1xcblxcdFxcdFxcdHRyeSB7XFxuXFx0XFx0XFx0XFx0b2JqID0gJCgnIycgKyBuZWVkbGUucmVwbGFjZSgkLmpzdHJlZS5pZHJlZ2V4LCAnXFxcXFxcXFwkJicpKTtcXG5cXHRcXHRcXHR9IGNhdGNoIChpZ25vcmUpIHt9XFxuXFx0XFx0fVxcblxcdFxcdGlmIChvYmogJiYgb2JqLmxlbmd0aCAmJiAob2JqID0gb2JqLmNsb3Nlc3QoJy5qc3RyZWUnKSkubGVuZ3RoICYmIChvYmogPSBvYmouZGF0YSgnanN0cmVlJykpKSB7XFxuXFx0XFx0XFx0dG1wID0gb2JqO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0JCgnLmpzdHJlZScpLmVhY2goZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdHZhciBpbnN0ID0gJCh0aGlzKS5kYXRhKCdqc3RyZWUnKTtcXG5cXHRcXHRcXHRcXHRpZiAoaW5zdCAmJiBpbnN0Ll9tb2RlbC5kYXRhW25lZWRsZV0pIHtcXG5cXHRcXHRcXHRcXHRcXHR0bXAgPSBpbnN0O1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiB0bXA7XFxuXFx0fTtcXG5cXHQvKipcXG4gICogQ3JlYXRlIGFuIGluc3RhbmNlLCBnZXQgYW4gaW5zdGFuY2Ugb3IgaW52b2tlIGEgY29tbWFuZCBvbiBhIGluc3RhbmNlLlxcbiAgKlxcbiAgKiBJZiB0aGVyZSBpcyBubyBpbnN0YW5jZSBhc3NvY2lhdGVkIHdpdGggdGhlIGN1cnJlbnQgbm9kZSBhIG5ldyBvbmUgaXMgY3JlYXRlZCBhbmQgYGFyZ2AgaXMgdXNlZCB0byBleHRlbmQgYCQuanN0cmVlLmRlZmF1bHRzYCBmb3IgdGhpcyBuZXcgaW5zdGFuY2UuIFRoZXJlIHdvdWxkIGJlIG5vIHJldHVybiB2YWx1ZSAoY2hhaW5pbmcgaXMgbm90IGJyb2tlbikuXFxuICAqXFxuICAqIElmIHRoZXJlIGlzIGFuIGV4aXN0aW5nIGluc3RhbmNlIGFuZCBgYXJnYCBpcyBhIHN0cmluZyB0aGUgY29tbWFuZCBzcGVjaWZpZWQgYnkgYGFyZ2AgaXMgZXhlY3V0ZWQgb24gdGhlIGluc3RhbmNlLCB3aXRoIGFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIGZ1bmN0aW9uLiBJZiB0aGUgZnVuY3Rpb24gcmV0dXJucyBhIHZhbHVlIGl0IHdpbGwgYmUgcmV0dXJuZWQgKGNoYWluaW5nIGNvdWxkIGJyZWFrIGRlcGVuZGluZyBvbiBmdW5jdGlvbikuXFxuICAqXFxuICAqIElmIHRoZXJlIGlzIGFuIGV4aXN0aW5nIGluc3RhbmNlIGFuZCBgYXJnYCBpcyBub3QgYSBzdHJpbmcgdGhlIGluc3RhbmNlIGl0c2VsZiBpcyByZXR1cm5lZCAoc2ltaWxhciB0byBgJC5qc3RyZWUucmVmZXJlbmNlYCkuXFxuICAqXFxuICAqIEluIGFueSBvdGhlciBjYXNlIC0gbm90aGluZyBpcyByZXR1cm5lZCBhbmQgY2hhaW5pbmcgaXMgbm90IGJyb2tlbi5cXG4gICpcXG4gICogX19FeGFtcGxlc19fXFxuICAqXFxuICAqXFx0JCgnI3RyZWUxJykuanN0cmVlKCk7IC8vIGNyZWF0ZXMgYW4gaW5zdGFuY2VcXG4gICpcXHQkKCcjdHJlZTInKS5qc3RyZWUoeyBwbHVnaW5zIDogW10gfSk7IC8vIGNyZWF0ZSBhbiBpbnN0YW5jZSB3aXRoIHNvbWUgb3B0aW9uc1xcbiAgKlxcdCQoJyN0cmVlMScpLmpzdHJlZSgnb3Blbl9ub2RlJywgJyNicmFuY2hfMScpOyAvLyBjYWxsIGEgbWV0aG9kIG9uIGFuIGV4aXN0aW5nIGluc3RhbmNlLCBwYXNzaW5nIGFkZGl0aW9uYWwgYXJndW1lbnRzXFxuICAqXFx0JCgnI3RyZWUyJykuanN0cmVlKCk7IC8vIGdldCBhbiBleGlzdGluZyBpbnN0YW5jZSAob3IgY3JlYXRlIGFuIGluc3RhbmNlKVxcbiAgKlxcdCQoJyN0cmVlMicpLmpzdHJlZSh0cnVlKTsgLy8gZ2V0IGFuIGV4aXN0aW5nIGluc3RhbmNlICh3aWxsIG5vdCBjcmVhdGUgbmV3IGluc3RhbmNlKVxcbiAgKlxcdCQoJyNicmFuY2hfMScpLmpzdHJlZSgpLnNlbGVjdF9ub2RlKCcjYnJhbmNoXzEnKTsgLy8gZ2V0IGFuIGluc3RhbmNlICh1c2luZyBhIG5lc3RlZCBlbGVtZW50IGFuZCBjYWxsIGEgbWV0aG9kKVxcbiAgKlxcbiAgKiBAbmFtZSAkKCkuanN0cmVlKFthcmddKVxcbiAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGFyZ1xcbiAgKiBAcmV0dXJuIHtNaXhlZH1cXG4gICovXFxuXFx0JC5mbi5qc3RyZWUgPSBmdW5jdGlvbiAoYXJnKSB7XFxuXFx0XFx0Ly8gY2hlY2sgZm9yIHN0cmluZyBhcmd1bWVudFxcblxcdFxcdHZhciBpc19tZXRob2QgPSB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyxcXG5cXHRcXHQgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXFxuXFx0XFx0ICAgIHJlc3VsdCA9IG51bGw7XFxuXFx0XFx0aWYgKGFyZyA9PT0gdHJ1ZSAmJiAhdGhpcy5sZW5ndGgpIHtcXG5cXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0fVxcblxcdFxcdHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0Ly8gZ2V0IHRoZSBpbnN0YW5jZSAoaWYgdGhlcmUgaXMgb25lKSBhbmQgbWV0aG9kIChpZiBpdCBleGlzdHMpXFxuXFx0XFx0XFx0dmFyIGluc3RhbmNlID0gJC5qc3RyZWUucmVmZXJlbmNlKHRoaXMpLFxcblxcdFxcdFxcdCAgICBtZXRob2QgPSBpc19tZXRob2QgJiYgaW5zdGFuY2UgPyBpbnN0YW5jZVthcmddIDogbnVsbDtcXG5cXHRcXHRcXHQvLyBpZiBjYWxsaW5nIGEgbWV0aG9kLCBhbmQgbWV0aG9kIGlzIGF2YWlsYWJsZSAtIGV4ZWN1dGUgb24gdGhlIGluc3RhbmNlXFxuXFx0XFx0XFx0cmVzdWx0ID0gaXNfbWV0aG9kICYmIG1ldGhvZCA/IG1ldGhvZC5hcHBseShpbnN0YW5jZSwgYXJncykgOiBudWxsO1xcblxcdFxcdFxcdC8vIGlmIHRoZXJlIGlzIG5vIGluc3RhbmNlIGFuZCBubyBtZXRob2QgaXMgYmVpbmcgY2FsbGVkIC0gY3JlYXRlIG9uZVxcblxcdFxcdFxcdGlmICghaW5zdGFuY2UgJiYgIWlzX21ldGhvZCAmJiAoYXJnID09PSB1bmRlZmluZWQgfHwgJC5pc1BsYWluT2JqZWN0KGFyZykpKSB7XFxuXFx0XFx0XFx0XFx0JC5qc3RyZWUuY3JlYXRlKHRoaXMsIGFyZyk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdC8vIGlmIHRoZXJlIGlzIGFuIGluc3RhbmNlIGFuZCBubyBtZXRob2QgaXMgY2FsbGVkIC0gcmV0dXJuIHRoZSBpbnN0YW5jZVxcblxcdFxcdFxcdGlmIChpbnN0YW5jZSAmJiAhaXNfbWV0aG9kIHx8IGFyZyA9PT0gdHJ1ZSkge1xcblxcdFxcdFxcdFxcdHJlc3VsdCA9IGluc3RhbmNlIHx8IGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHQvLyBpZiB0aGVyZSB3YXMgYSBtZXRob2QgY2FsbCB3aGljaCByZXR1cm5lZCBhIHJlc3VsdCAtIGJyZWFrIGFuZCByZXR1cm4gdGhlIHZhbHVlXFxuXFx0XFx0XFx0aWYgKHJlc3VsdCAhPT0gbnVsbCAmJiByZXN1bHQgIT09IHVuZGVmaW5lZCkge1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSk7XFxuXFx0XFx0Ly8gaWYgdGhlcmUgd2FzIGEgbWV0aG9kIGNhbGwgd2l0aCBhIHZhbGlkIHJldHVybiB2YWx1ZSAtIHJldHVybiB0aGF0LCBvdGhlcndpc2UgY29udGludWUgdGhlIGNoYWluXFxuXFx0XFx0cmV0dXJuIHJlc3VsdCAhPT0gbnVsbCAmJiByZXN1bHQgIT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IHRoaXM7XFxuXFx0fTtcXG5cXHQvKipcXG4gICogdXNlZCB0byBmaW5kIGVsZW1lbnRzIGNvbnRhaW5pbmcgYW4gaW5zdGFuY2VcXG4gICpcXG4gICogX19FeGFtcGxlc19fXFxuICAqXFxuICAqXFx0JCgnZGl2OmpzdHJlZScpLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgKlxcdFxcdCQodGhpcykuanN0cmVlKCdkZXN0cm95Jyk7XFxuICAqXFx0fSk7XFxuICAqXFxuICAqIEBuYW1lICQoJzpqc3RyZWUnKVxcbiAgKiBAcmV0dXJuIHtqUXVlcnl9XFxuICAqL1xcblxcdCQuZXhwci5wc2V1ZG9zLmpzdHJlZSA9ICQuZXhwci5jcmVhdGVQc2V1ZG8oZnVuY3Rpb24gKHNlYXJjaCkge1xcblxcdFxcdHJldHVybiBmdW5jdGlvbiAoYSkge1xcblxcdFxcdFxcdHJldHVybiAkKGEpLmhhc0NsYXNzKCdqc3RyZWUnKSAmJiAkKGEpLmRhdGEoJ2pzdHJlZScpICE9PSB1bmRlZmluZWQ7XFxuXFx0XFx0fTtcXG5cXHR9KTtcXG5cXG5cXHQvKipcXG4gICogc3RvcmVzIGFsbCBkZWZhdWx0cyBmb3IgdGhlIGNvcmVcXG4gICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY29yZVxcbiAgKi9cXG5cXHQkLmpzdHJlZS5kZWZhdWx0cy5jb3JlID0ge1xcblxcdFxcdC8qKlxcbiAgICogZGF0YSBjb25maWd1cmF0aW9uXFxuICAgKlxcbiAgICogSWYgbGVmdCBhcyBgZmFsc2VgIHRoZSBIVE1MIGluc2lkZSB0aGUganN0cmVlIGNvbnRhaW5lciBlbGVtZW50IGlzIHVzZWQgdG8gcG9wdWxhdGUgdGhlIHRyZWUgKHRoYXQgc2hvdWxkIGJlIGFuIHVub3JkZXJlZCBsaXN0IHdpdGggbGlzdCBpdGVtcykuXFxuICAgKlxcbiAgICogWW91IGNhbiBhbHNvIHBhc3MgaW4gYSBIVE1MIHN0cmluZyBvciBhIEpTT04gYXJyYXkgaGVyZS5cXG4gICAqXFxuICAgKiBJdCBpcyBwb3NzaWJsZSB0byBwYXNzIGluIGEgc3RhbmRhcmQgalF1ZXJ5LWxpa2UgQUpBWCBjb25maWcgYW5kIGpzdHJlZSB3aWxsIGF1dG9tYXRpY2FsbHkgZGV0ZXJtaW5lIGlmIHRoZSByZXNwb25zZSBpcyBKU09OIG9yIEhUTUwgYW5kIHVzZSB0aGF0IHRvIHBvcHVsYXRlIHRoZSB0cmVlLlxcbiAgICogSW4gYWRkaXRpb24gdG8gdGhlIHN0YW5kYXJkIGpRdWVyeSBhamF4IG9wdGlvbnMgaGVyZSB5b3UgY2FuIHN1cHB5IGZ1bmN0aW9ucyBmb3IgYGRhdGFgIGFuZCBgdXJsYCwgdGhlIGZ1bmN0aW9ucyB3aWxsIGJlIHJ1biBpbiB0aGUgY3VycmVudCBpbnN0YW5jZSdzIHNjb3BlIGFuZCBhIHBhcmFtIHdpbGwgYmUgcGFzc2VkIGluZGljYXRpbmcgd2hpY2ggbm9kZSBpcyBiZWluZyBsb2FkZWQsIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhvc2UgZnVuY3Rpb25zIHdpbGwgYmUgdXNlZC5cXG4gICAqXFxuICAgKiBUaGUgbGFzdCBvcHRpb24gaXMgdG8gc3BlY2lmeSBhIGZ1bmN0aW9uLCB0aGF0IGZ1bmN0aW9uIHdpbGwgcmVjZWl2ZSB0aGUgbm9kZSBiZWluZyBsb2FkZWQgYXMgYXJndW1lbnQgYW5kIGEgc2Vjb25kIHBhcmFtIHdoaWNoIGlzIGEgZnVuY3Rpb24gd2hpY2ggc2hvdWxkIGJlIGNhbGxlZCB3aXRoIHRoZSByZXN1bHQuXFxuICAgKlxcbiAgICogX19FeGFtcGxlc19fXFxuICAgKlxcbiAgICpcXHQvLyBBSkFYXFxuICAgKlxcdCQoJyN0cmVlJykuanN0cmVlKHtcXG4gICAqXFx0XFx0J2NvcmUnIDoge1xcbiAgICpcXHRcXHRcXHQnZGF0YScgOiB7XFxuICAgKlxcdFxcdFxcdFxcdCd1cmwnIDogJy9nZXQvY2hpbGRyZW4vJyxcXG4gICAqXFx0XFx0XFx0XFx0J2RhdGEnIDogZnVuY3Rpb24gKG5vZGUpIHtcXG4gICAqXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHsgJ2lkJyA6IG5vZGUuaWQgfTtcXG4gICAqXFx0XFx0XFx0XFx0fVxcbiAgICpcXHRcXHRcXHR9XFxuICAgKlxcdFxcdH0pO1xcbiAgICpcXG4gICAqXFx0Ly8gZGlyZWN0IGRhdGFcXG4gICAqXFx0JCgnI3RyZWUnKS5qc3RyZWUoe1xcbiAgICpcXHRcXHQnY29yZScgOiB7XFxuICAgKlxcdFxcdFxcdCdkYXRhJyA6IFtcXG4gICAqXFx0XFx0XFx0XFx0J1NpbXBsZSByb290IG5vZGUnLFxcbiAgICpcXHRcXHRcXHRcXHR7XFxuICAgKlxcdFxcdFxcdFxcdFxcdCdpZCcgOiAnbm9kZV8yJyxcXG4gICAqXFx0XFx0XFx0XFx0XFx0J3RleHQnIDogJ1Jvb3Qgbm9kZSB3aXRoIG9wdGlvbnMnLFxcbiAgICpcXHRcXHRcXHRcXHRcXHQnc3RhdGUnIDogeyAnb3BlbmVkJyA6IHRydWUsICdzZWxlY3RlZCcgOiB0cnVlIH0sXFxuICAgKlxcdFxcdFxcdFxcdFxcdCdjaGlsZHJlbicgOiBbIHsgJ3RleHQnIDogJ0NoaWxkIDEnIH0sICdDaGlsZCAyJ11cXG4gICAqXFx0XFx0XFx0XFx0fVxcbiAgICpcXHRcXHRcXHRdXFxuICAgKlxcdFxcdH1cXG4gICAqXFx0fSk7XFxuICAgKlxcbiAgICpcXHQvLyBmdW5jdGlvblxcbiAgICpcXHQkKCcjdHJlZScpLmpzdHJlZSh7XFxuICAgKlxcdFxcdCdjb3JlJyA6IHtcXG4gICAqXFx0XFx0XFx0J2RhdGEnIDogZnVuY3Rpb24gKG9iaiwgY2FsbGJhY2spIHtcXG4gICAqXFx0XFx0XFx0XFx0Y2FsbGJhY2suY2FsbCh0aGlzLCBbJ1Jvb3QgMScsICdSb290IDInXSk7XFxuICAgKlxcdFxcdFxcdH1cXG4gICAqXFx0XFx0fSk7XFxuICAgKlxcbiAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY29yZS5kYXRhXFxuICAgKi9cXG5cXHRcXHRkYXRhOiBmYWxzZSxcXG5cXHRcXHQvKipcXG4gICAqIGNvbmZpZ3VyZSB0aGUgdmFyaW91cyBzdHJpbmdzIHVzZWQgdGhyb3VnaG91dCB0aGUgdHJlZVxcbiAgICpcXG4gICAqIFlvdSBjYW4gdXNlIGFuIG9iamVjdCB3aGVyZSB0aGUga2V5IGlzIHRoZSBzdHJpbmcgeW91IG5lZWQgdG8gcmVwbGFjZSBhbmQgdGhlIHZhbHVlIGlzIHlvdXIgcmVwbGFjZW1lbnQuXFxuICAgKiBBbm90aGVyIG9wdGlvbiBpcyB0byBzcGVjaWZ5IGEgZnVuY3Rpb24gd2hpY2ggd2lsbCBiZSBjYWxsZWQgd2l0aCBhbiBhcmd1bWVudCBvZiB0aGUgbmVlZGVkIHN0cmluZyBhbmQgc2hvdWxkIHJldHVybiB0aGUgcmVwbGFjZW1lbnQuXFxuICAgKiBJZiBsZWZ0IGFzIGBmYWxzZWAgbm8gcmVwbGFjZW1lbnQgaXMgbWFkZS5cXG4gICAqXFxuICAgKiBfX0V4YW1wbGVzX19cXG4gICAqXFxuICAgKlxcdCQoJyN0cmVlJykuanN0cmVlKHtcXG4gICAqXFx0XFx0J2NvcmUnIDoge1xcbiAgICpcXHRcXHRcXHQnc3RyaW5ncycgOiB7XFxuICAgKlxcdFxcdFxcdFxcdCdMb2FkaW5nIC4uLicgOiAnUGxlYXNlIHdhaXQgLi4uJ1xcbiAgICpcXHRcXHRcXHR9XFxuICAgKlxcdFxcdH1cXG4gICAqXFx0fSk7XFxuICAgKlxcbiAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY29yZS5zdHJpbmdzXFxuICAgKi9cXG5cXHRcXHRzdHJpbmdzOiBmYWxzZSxcXG5cXHRcXHQvKipcXG4gICAqIGRldGVybWluZXMgd2hhdCBoYXBwZW5zIHdoZW4gYSB1c2VyIHRyaWVzIHRvIG1vZGlmeSB0aGUgc3RydWN0dXJlIG9mIHRoZSB0cmVlXFxuICAgKiBJZiBsZWZ0IGFzIGBmYWxzZWAgYWxsIG9wZXJhdGlvbnMgbGlrZSBjcmVhdGUsIHJlbmFtZSwgZGVsZXRlLCBtb3ZlIG9yIGNvcHkgYXJlIHByZXZlbnRlZC5cXG4gICAqIFlvdSBjYW4gc2V0IHRoaXMgdG8gYHRydWVgIHRvIGFsbG93IGFsbCBpbnRlcmFjdGlvbnMgb3IgdXNlIGEgZnVuY3Rpb24gdG8gaGF2ZSBiZXR0ZXIgY29udHJvbC5cXG4gICAqXFxuICAgKiBfX0V4YW1wbGVzX19cXG4gICAqXFxuICAgKlxcdCQoJyN0cmVlJykuanN0cmVlKHtcXG4gICAqXFx0XFx0J2NvcmUnIDoge1xcbiAgICpcXHRcXHRcXHQnY2hlY2tfY2FsbGJhY2snIDogZnVuY3Rpb24gKG9wZXJhdGlvbiwgbm9kZSwgbm9kZV9wYXJlbnQsIG5vZGVfcG9zaXRpb24sIG1vcmUpIHtcXG4gICAqXFx0XFx0XFx0XFx0Ly8gb3BlcmF0aW9uIGNhbiBiZSAnY3JlYXRlX25vZGUnLCAncmVuYW1lX25vZGUnLCAnZGVsZXRlX25vZGUnLCAnbW92ZV9ub2RlJyBvciAnY29weV9ub2RlJ1xcbiAgICpcXHRcXHRcXHRcXHQvLyBpbiBjYXNlIG9mICdyZW5hbWVfbm9kZScgbm9kZV9wb3NpdGlvbiBpcyBmaWxsZWQgd2l0aCB0aGUgbmV3IG5vZGUgbmFtZVxcbiAgICpcXHRcXHRcXHRcXHRyZXR1cm4gb3BlcmF0aW9uID09PSAncmVuYW1lX25vZGUnID8gdHJ1ZSA6IGZhbHNlO1xcbiAgICpcXHRcXHRcXHR9XFxuICAgKlxcdFxcdH1cXG4gICAqXFx0fSk7XFxuICAgKlxcbiAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY29yZS5jaGVja19jYWxsYmFja1xcbiAgICovXFxuXFx0XFx0Y2hlY2tfY2FsbGJhY2s6IGZhbHNlLFxcblxcdFxcdC8qKlxcbiAgICogYSBjYWxsYmFjayBjYWxsZWQgd2l0aCBhIHNpbmdsZSBvYmplY3QgcGFyYW1ldGVyIGluIHRoZSBpbnN0YW5jZSdzIHNjb3BlIHdoZW4gc29tZXRoaW5nIGdvZXMgd3JvbmcgKG9wZXJhdGlvbiBwcmV2ZW50ZWQsIGFqYXggZmFpbGVkLCBldGMpXFxuICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb3JlLmVycm9yXFxuICAgKi9cXG5cXHRcXHRlcnJvcjogJC5ub29wLFxcblxcdFxcdC8qKlxcbiAgICogdGhlIG9wZW4gLyBjbG9zZSBhbmltYXRpb24gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzIC0gc2V0IHRoaXMgdG8gYGZhbHNlYCB0byBkaXNhYmxlIHRoZSBhbmltYXRpb24gKGRlZmF1bHQgaXMgYDIwMGApXFxuICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb3JlLmFuaW1hdGlvblxcbiAgICovXFxuXFx0XFx0YW5pbWF0aW9uOiAyMDAsXFxuXFx0XFx0LyoqXFxuICAgKiBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiBtdWx0aXBsZSBub2RlcyBjYW4gYmUgc2VsZWN0ZWRcXG4gICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvcmUubXVsdGlwbGVcXG4gICAqL1xcblxcdFxcdG11bHRpcGxlOiB0cnVlLFxcblxcdFxcdC8qKlxcbiAgICogdGhlbWUgY29uZmlndXJhdGlvbiBvYmplY3RcXG4gICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvcmUudGhlbWVzXFxuICAgKi9cXG5cXHRcXHR0aGVtZXM6IHtcXG5cXHRcXHRcXHQvKipcXG4gICAgKiB0aGUgbmFtZSBvZiB0aGUgdGhlbWUgdG8gdXNlIChpZiBsZWZ0IGFzIGBmYWxzZWAgdGhlIGRlZmF1bHQgdGhlbWUgaXMgdXNlZClcXG4gICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb3JlLnRoZW1lcy5uYW1lXFxuICAgICovXFxuXFx0XFx0XFx0bmFtZTogZmFsc2UsXFxuXFx0XFx0XFx0LyoqXFxuICAgICogdGhlIFVSTCBvZiB0aGUgdGhlbWUncyBDU1MgZmlsZSwgbGVhdmUgdGhpcyBhcyBgZmFsc2VgIGlmIHlvdSBoYXZlIG1hbnVhbGx5IGluY2x1ZGVkIHRoZSB0aGVtZSBDU1MgKHJlY29tbWVuZGVkKS4gWW91IGNhbiBzZXQgdGhpcyB0byBgdHJ1ZWAgdG9vIHdoaWNoIHdpbGwgdHJ5IHRvIGF1dG9sb2FkIHRoZSB0aGVtZS5cXG4gICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb3JlLnRoZW1lcy51cmxcXG4gICAgKi9cXG5cXHRcXHRcXHR1cmw6IGZhbHNlLFxcblxcdFxcdFxcdC8qKlxcbiAgICAqIHRoZSBsb2NhdGlvbiBvZiBhbGwganN0cmVlIHRoZW1lcyAtIG9ubHkgdXNlZCBpZiBgdXJsYCBpcyBzZXQgdG8gYHRydWVgXFxuICAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY29yZS50aGVtZXMuZGlyXFxuICAgICovXFxuXFx0XFx0XFx0ZGlyOiBmYWxzZSxcXG5cXHRcXHRcXHQvKipcXG4gICAgKiBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiBjb25uZWN0aW5nIGRvdHMgYXJlIHNob3duXFxuICAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY29yZS50aGVtZXMuZG90c1xcbiAgICAqL1xcblxcdFxcdFxcdGRvdHM6IHRydWUsXFxuXFx0XFx0XFx0LyoqXFxuICAgICogYSBib29sZWFuIGluZGljYXRpbmcgaWYgbm9kZSBpY29ucyBhcmUgc2hvd25cXG4gICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb3JlLnRoZW1lcy5pY29uc1xcbiAgICAqL1xcblxcdFxcdFxcdGljb25zOiB0cnVlLFxcblxcdFxcdFxcdC8qKlxcbiAgICAqIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIG5vZGUgZWxsaXBzaXMgc2hvdWxkIGJlIHNob3duIC0gdGhpcyBvbmx5IHdvcmtzIHdpdGggYSBmaXhlZCB3aXRoIG9uIHRoZSBjb250YWluZXJcXG4gICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb3JlLnRoZW1lcy5lbGxpcHNpc1xcbiAgICAqL1xcblxcdFxcdFxcdGVsbGlwc2lzOiBmYWxzZSxcXG5cXHRcXHRcXHQvKipcXG4gICAgKiBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiB0aGUgdHJlZSBiYWNrZ3JvdW5kIGlzIHN0cmlwZWRcXG4gICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb3JlLnRoZW1lcy5zdHJpcGVzXFxuICAgICovXFxuXFx0XFx0XFx0c3RyaXBlczogZmFsc2UsXFxuXFx0XFx0XFx0LyoqXFxuICAgICogYSBzdHJpbmcgKG9yIGJvb2xlYW4gYGZhbHNlYCkgc3BlY2lmeWluZyB0aGUgdGhlbWUgdmFyaWFudCB0byB1c2UgKGlmIHRoZSB0aGVtZSBzdXBwb3J0cyB2YXJpYW50cylcXG4gICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb3JlLnRoZW1lcy52YXJpYW50XFxuICAgICovXFxuXFx0XFx0XFx0dmFyaWFudDogZmFsc2UsXFxuXFx0XFx0XFx0LyoqXFxuICAgICogYSBib29sZWFuIHNwZWNpZnlpbmcgaWYgYSByZXBvbnNpdmUgdmVyc2lvbiBvZiB0aGUgdGhlbWUgc2hvdWxkIGtpY2sgaW4gb24gc21hbGxlciBzY3JlZW5zIChpZiB0aGUgdGhlbWUgc3VwcG9ydHMgaXQpLiBEZWZhdWx0cyB0byBgZmFsc2VgLlxcbiAgICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvcmUudGhlbWVzLnJlc3BvbnNpdmVcXG4gICAgKi9cXG5cXHRcXHRcXHRyZXNwb25zaXZlOiBmYWxzZVxcblxcdFxcdH0sXFxuXFx0XFx0LyoqXFxuICAgKiBpZiBsZWZ0IGFzIGB0cnVlYCBhbGwgcGFyZW50cyBvZiBhbGwgc2VsZWN0ZWQgbm9kZXMgd2lsbCBiZSBvcGVuZWQgb25jZSB0aGUgdHJlZSBsb2FkcyAoc28gdGhhdCBhbGwgc2VsZWN0ZWQgbm9kZXMgYXJlIHZpc2libGUgdG8gdGhlIHVzZXIpXFxuICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb3JlLmV4cGFuZF9zZWxlY3RlZF9vbmxvYWRcXG4gICAqL1xcblxcdFxcdGV4cGFuZF9zZWxlY3RlZF9vbmxvYWQ6IHRydWUsXFxuXFx0XFx0LyoqXFxuICAgKiBpZiBsZWZ0IGFzIGB0cnVlYCB3ZWIgd29ya2VycyB3aWxsIGJlIHVzZWQgdG8gcGFyc2UgaW5jb21pbmcgSlNPTiBkYXRhIHdoZXJlIHBvc3NpYmxlLCBzbyB0aGF0IHRoZSBVSSB3aWxsIG5vdCBiZSBibG9ja2VkIGJ5IGxhcmdlIHJlcXVlc3RzLiBXb3JrZXJzIGFyZSBob3dldmVyIGFib3V0IDMwJSBzbG93ZXIuIERlZmF1bHRzIHRvIGB0cnVlYFxcbiAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY29yZS53b3JrZXJcXG4gICAqL1xcblxcdFxcdHdvcmtlcjogdHJ1ZSxcXG5cXHRcXHQvKipcXG4gICAqIEZvcmNlIG5vZGUgdGV4dCB0byBwbGFpbiB0ZXh0IChhbmQgZXNjYXBlIEhUTUwpLiBEZWZhdWx0cyB0byBgZmFsc2VgXFxuICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb3JlLmZvcmNlX3RleHRcXG4gICAqL1xcblxcdFxcdGZvcmNlX3RleHQ6IGZhbHNlLFxcblxcdFxcdC8qKlxcbiAgICogU2hvdWxkIHRoZSBub2RlIHNob3VsZCBiZSB0b2dnbGVkIGlmIHRoZSB0ZXh0IGlzIGRvdWJsZSBjbGlja2VkIC4gRGVmYXVsdHMgdG8gYHRydWVgXFxuICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb3JlLmRibGNsaWNrX3RvZ2dsZVxcbiAgICovXFxuXFx0XFx0ZGJsY2xpY2tfdG9nZ2xlOiB0cnVlXFxuXFx0fTtcXG5cXHQkLmpzdHJlZS5jb3JlLnByb3RvdHlwZSA9IHtcXG5cXHRcXHQvKipcXG4gICAqIHVzZWQgdG8gZGVjb3JhdGUgYW4gaW5zdGFuY2Ugd2l0aCBhIHBsdWdpbi4gVXNlZCBpbnRlcm5hbGx5LlxcbiAgICogQHByaXZhdGVcXG4gICAqIEBuYW1lIHBsdWdpbihkZWNvIFssIG9wdHNdKVxcbiAgICogQHBhcmFtICB7U3RyaW5nfSBkZWNvIHRoZSBwbHVnaW4gdG8gZGVjb3JhdGUgd2l0aFxcbiAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRzIG9wdGlvbnMgZm9yIHRoZSBwbHVnaW5cXG4gICAqIEByZXR1cm4ge2pzVHJlZX1cXG4gICAqL1xcblxcdFxcdHBsdWdpbjogZnVuY3Rpb24gcGx1Z2luKGRlY28sIG9wdHMpIHtcXG5cXHRcXHRcXHR2YXIgQ2hpbGQgPSAkLmpzdHJlZS5wbHVnaW5zW2RlY29dO1xcblxcdFxcdFxcdGlmIChDaGlsZCkge1xcblxcdFxcdFxcdFxcdHRoaXMuX2RhdGFbZGVjb10gPSB7fTtcXG5cXHRcXHRcXHRcXHRDaGlsZC5wcm90b3R5cGUgPSB0aGlzO1xcblxcdFxcdFxcdFxcdHJldHVybiBuZXcgQ2hpbGQob3B0cywgdGhpcyk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcdFxcdH0sXFxuXFx0XFx0LyoqXFxuICAgKiBpbml0aWFsaXplIHRoZSBpbnN0YW5jZS4gVXNlZCBpbnRlcm5hbGx5LlxcbiAgICogQHByaXZhdGVcXG4gICAqIEBuYW1lIGluaXQoZWwsIG9wdG9ucylcXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudHxqUXVlcnl8U3RyaW5nfSBlbCB0aGUgZWxlbWVudCB3ZSBhcmUgdHJhbnNmb3JtaW5nXFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBvcHRpb25zIGZvciB0aGlzIGluc3RhbmNlXFxuICAgKiBAdHJpZ2dlciBpbml0LmpzdHJlZSwgbG9hZGluZy5qc3RyZWUsIGxvYWRlZC5qc3RyZWUsIHJlYWR5LmpzdHJlZSwgY2hhbmdlZC5qc3RyZWVcXG4gICAqL1xcblxcdFxcdGluaXQ6IGZ1bmN0aW9uIGluaXQoZWwsIG9wdGlvbnMpIHtcXG5cXHRcXHRcXHR0aGlzLl9tb2RlbCA9IHtcXG5cXHRcXHRcXHRcXHRkYXRhOiB7fSxcXG5cXHRcXHRcXHRcXHRjaGFuZ2VkOiBbXSxcXG5cXHRcXHRcXHRcXHRmb3JjZV9mdWxsX3JlZHJhdzogZmFsc2UsXFxuXFx0XFx0XFx0XFx0cmVkcmF3X3RpbWVvdXQ6IGZhbHNlLFxcblxcdFxcdFxcdFxcdGRlZmF1bHRfc3RhdGU6IHtcXG5cXHRcXHRcXHRcXHRcXHRsb2FkZWQ6IHRydWUsXFxuXFx0XFx0XFx0XFx0XFx0b3BlbmVkOiBmYWxzZSxcXG5cXHRcXHRcXHRcXHRcXHRzZWxlY3RlZDogZmFsc2UsXFxuXFx0XFx0XFx0XFx0XFx0ZGlzYWJsZWQ6IGZhbHNlXFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH07XFxuXFx0XFx0XFx0dGhpcy5fbW9kZWwuZGF0YVskLmpzdHJlZS5yb290XSA9IHtcXG5cXHRcXHRcXHRcXHRpZDogJC5qc3RyZWUucm9vdCxcXG5cXHRcXHRcXHRcXHRwYXJlbnQ6IG51bGwsXFxuXFx0XFx0XFx0XFx0cGFyZW50czogW10sXFxuXFx0XFx0XFx0XFx0Y2hpbGRyZW46IFtdLFxcblxcdFxcdFxcdFxcdGNoaWxkcmVuX2Q6IFtdLFxcblxcdFxcdFxcdFxcdHN0YXRlOiB7IGxvYWRlZDogZmFsc2UgfVxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0XFx0dGhpcy5lbGVtZW50ID0gJChlbCkuYWRkQ2xhc3MoJ2pzdHJlZSBqc3RyZWUtJyArIHRoaXMuX2lkKTtcXG5cXHRcXHRcXHR0aGlzLnNldHRpbmdzID0gb3B0aW9ucztcXG5cXG5cXHRcXHRcXHR0aGlzLl9kYXRhLmNvcmUucmVhZHkgPSBmYWxzZTtcXG5cXHRcXHRcXHR0aGlzLl9kYXRhLmNvcmUubG9hZGVkID0gZmFsc2U7XFxuXFx0XFx0XFx0dGhpcy5fZGF0YS5jb3JlLnJ0bCA9IHRoaXMuZWxlbWVudC5jc3MoXFxcImRpcmVjdGlvblxcXCIpID09PSBcXFwicnRsXFxcIjtcXG5cXHRcXHRcXHR0aGlzLmVsZW1lbnRbdGhpcy5fZGF0YS5jb3JlLnJ0bCA/ICdhZGRDbGFzcycgOiAncmVtb3ZlQ2xhc3MnXShcXFwianN0cmVlLXJ0bFxcXCIpO1xcblxcdFxcdFxcdHRoaXMuZWxlbWVudC5hdHRyKCdyb2xlJywgJ3RyZWUnKTtcXG5cXHRcXHRcXHRpZiAodGhpcy5zZXR0aW5ncy5jb3JlLm11bHRpcGxlKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5lbGVtZW50LmF0dHIoJ2FyaWEtbXVsdGlzZWxlY3RhYmxlJywgdHJ1ZSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICghdGhpcy5lbGVtZW50LmF0dHIoJ3RhYmluZGV4JykpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLmVsZW1lbnQuYXR0cigndGFiaW5kZXgnLCAnMCcpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLmJpbmQoKTtcXG5cXHRcXHRcXHQvKipcXG4gICAgKiB0cmlnZ2VyZWQgYWZ0ZXIgYWxsIGV2ZW50cyBhcmUgYm91bmRcXG4gICAgKiBAZXZlbnRcXG4gICAgKiBAbmFtZSBpbml0LmpzdHJlZVxcbiAgICAqL1xcblxcdFxcdFxcdHRoaXMudHJpZ2dlcihcXFwiaW5pdFxcXCIpO1xcblxcblxcdFxcdFxcdHRoaXMuX2RhdGEuY29yZS5vcmlnaW5hbF9jb250YWluZXJfaHRtbCA9IHRoaXMuZWxlbWVudC5maW5kKFxcXCIgPiB1bCA+IGxpXFxcIikuY2xvbmUodHJ1ZSk7XFxuXFx0XFx0XFx0dGhpcy5fZGF0YS5jb3JlLm9yaWdpbmFsX2NvbnRhaW5lcl9odG1sLmZpbmQoXFxcImxpXFxcIikuYWRkQmFjaygpLmNvbnRlbnRzKCkuZmlsdGVyKGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5ub2RlVHlwZSA9PT0gMyAmJiAoIXRoaXMubm9kZVZhbHVlIHx8IC9eXFxcXHMrJC8udGVzdCh0aGlzLm5vZGVWYWx1ZSkpO1xcblxcdFxcdFxcdH0pLnJlbW92ZSgpO1xcblxcdFxcdFxcdHRoaXMuZWxlbWVudC5odG1sKFxcXCI8XFxcIiArIFxcXCJ1bCBjbGFzcz0nanN0cmVlLWNvbnRhaW5lci11bCBqc3RyZWUtY2hpbGRyZW4nIHJvbGU9J2dyb3VwJz48XFxcIiArIFxcXCJsaSBpZD0nalxcXCIgKyB0aGlzLl9pZCArIFxcXCJfbG9hZGluZycgY2xhc3M9J2pzdHJlZS1pbml0aWFsLW5vZGUganN0cmVlLWxvYWRpbmcganN0cmVlLWxlYWYganN0cmVlLWxhc3QnIHJvbGU9J3RyZWUtaXRlbSc+PGkgY2xhc3M9J2pzdHJlZS1pY29uIGpzdHJlZS1vY2wnPjwvaT48XFxcIiArIFxcXCJhIGNsYXNzPSdqc3RyZWUtYW5jaG9yJyBocmVmPScjJz48aSBjbGFzcz0nanN0cmVlLWljb24ganN0cmVlLXRoZW1laWNvbi1oaWRkZW4nPjwvaT5cXFwiICsgdGhpcy5nZXRfc3RyaW5nKFxcXCJMb2FkaW5nIC4uLlxcXCIpICsgXFxcIjwvYT48L2xpPjwvdWw+XFxcIik7XFxuXFx0XFx0XFx0dGhpcy5lbGVtZW50LmF0dHIoJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCcsICdqJyArIHRoaXMuX2lkICsgJ19sb2FkaW5nJyk7XFxuXFx0XFx0XFx0dGhpcy5fZGF0YS5jb3JlLmxpX2hlaWdodCA9IHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpLmNoaWxkcmVuKFxcXCJsaVxcXCIpLmZpcnN0KCkuaGVpZ2h0KCkgfHwgMjQ7XFxuXFx0XFx0XFx0dGhpcy5fZGF0YS5jb3JlLm5vZGUgPSB0aGlzLl9jcmVhdGVfcHJvdG90eXBlX25vZGUoKTtcXG5cXHRcXHRcXHQvKipcXG4gICAgKiB0cmlnZ2VyZWQgYWZ0ZXIgdGhlIGxvYWRpbmcgdGV4dCBpcyBzaG93biBhbmQgYmVmb3JlIGxvYWRpbmcgc3RhcnRzXFxuICAgICogQGV2ZW50XFxuICAgICogQG5hbWUgbG9hZGluZy5qc3RyZWVcXG4gICAgKi9cXG5cXHRcXHRcXHR0aGlzLnRyaWdnZXIoXFxcImxvYWRpbmdcXFwiKTtcXG5cXHRcXHRcXHR0aGlzLmxvYWRfbm9kZSgkLmpzdHJlZS5yb290KTtcXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogZGVzdHJveSBhbiBpbnN0YW5jZVxcbiAgICogQG5hbWUgZGVzdHJveSgpXFxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBrZWVwX2h0bWwgaWYgbm90IHNldCB0byBgdHJ1ZWAgdGhlIGNvbnRhaW5lciB3aWxsIGJlIGVtcHRpZWQsIG90aGVyd2lzZSB0aGUgY3VycmVudCBET00gZWxlbWVudHMgd2lsbCBiZSBrZXB0IGludGFjdFxcbiAgICovXFxuXFx0XFx0ZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveShrZWVwX2h0bWwpIHtcXG5cXHRcXHRcXHRpZiAodGhpcy5fd3JrKSB7XFxuXFx0XFx0XFx0XFx0dHJ5IHtcXG5cXHRcXHRcXHRcXHRcXHR3aW5kb3cuVVJMLnJldm9rZU9iamVjdFVSTCh0aGlzLl93cmspO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX3dyayA9IG51bGw7XFxuXFx0XFx0XFx0XFx0fSBjYXRjaCAoaWdub3JlKSB7fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoIWtlZXBfaHRtbCkge1xcblxcdFxcdFxcdFxcdHRoaXMuZWxlbWVudC5lbXB0eSgpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR0aGlzLnRlYXJkb3duKCk7XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIENyZWF0ZSBwcm90b3R5cGUgbm9kZVxcbiAgICovXFxuXFx0XFx0X2NyZWF0ZV9wcm90b3R5cGVfbm9kZTogZnVuY3Rpb24gX2NyZWF0ZV9wcm90b3R5cGVfbm9kZSgpIHtcXG5cXHRcXHRcXHR2YXIgX25vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdMSScpLFxcblxcdFxcdFxcdCAgICBfdGVtcDEsXFxuXFx0XFx0XFx0ICAgIF90ZW1wMjtcXG5cXHRcXHRcXHRfbm9kZS5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAndHJlZWl0ZW0nKTtcXG5cXHRcXHRcXHRfdGVtcDEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdJJyk7XFxuXFx0XFx0XFx0X3RlbXAxLmNsYXNzTmFtZSA9ICdqc3RyZWUtaWNvbiBqc3RyZWUtb2NsJztcXG5cXHRcXHRcXHRfdGVtcDEuc2V0QXR0cmlidXRlKCdyb2xlJywgJ3ByZXNlbnRhdGlvbicpO1xcblxcdFxcdFxcdF9ub2RlLmFwcGVuZENoaWxkKF90ZW1wMSk7XFxuXFx0XFx0XFx0X3RlbXAxID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnQScpO1xcblxcdFxcdFxcdF90ZW1wMS5jbGFzc05hbWUgPSAnanN0cmVlLWFuY2hvcic7XFxuXFx0XFx0XFx0X3RlbXAxLnNldEF0dHJpYnV0ZSgnaHJlZicsICcjJyk7XFxuXFx0XFx0XFx0X3RlbXAxLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKTtcXG5cXHRcXHRcXHRfdGVtcDIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdJJyk7XFxuXFx0XFx0XFx0X3RlbXAyLmNsYXNzTmFtZSA9ICdqc3RyZWUtaWNvbiBqc3RyZWUtdGhlbWVpY29uJztcXG5cXHRcXHRcXHRfdGVtcDIuc2V0QXR0cmlidXRlKCdyb2xlJywgJ3ByZXNlbnRhdGlvbicpO1xcblxcdFxcdFxcdF90ZW1wMS5hcHBlbmRDaGlsZChfdGVtcDIpO1xcblxcdFxcdFxcdF9ub2RlLmFwcGVuZENoaWxkKF90ZW1wMSk7XFxuXFx0XFx0XFx0X3RlbXAxID0gX3RlbXAyID0gbnVsbDtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gX25vZGU7XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIHBhcnQgb2YgdGhlIGRlc3Ryb3lpbmcgb2YgYW4gaW5zdGFuY2UuIFVzZWQgaW50ZXJuYWxseS5cXG4gICAqIEBwcml2YXRlXFxuICAgKiBAbmFtZSB0ZWFyZG93bigpXFxuICAgKi9cXG5cXHRcXHR0ZWFyZG93bjogZnVuY3Rpb24gdGVhcmRvd24oKSB7XFxuXFx0XFx0XFx0dGhpcy51bmJpbmQoKTtcXG5cXHRcXHRcXHR0aGlzLmVsZW1lbnQucmVtb3ZlQ2xhc3MoJ2pzdHJlZScpLnJlbW92ZURhdGEoJ2pzdHJlZScpLmZpbmQoXFxcIltjbGFzc149J2pzdHJlZSddXFxcIikuYWRkQmFjaygpLmF0dHIoXFxcImNsYXNzXFxcIiwgZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLmNsYXNzTmFtZS5yZXBsYWNlKC9qc3RyZWVbXiBdKnwkL2lnLCAnJyk7XFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0dGhpcy5lbGVtZW50ID0gbnVsbDtcXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogYmluZCBhbGwgZXZlbnRzLiBVc2VkIGludGVybmFsbHkuXFxuICAgKiBAcHJpdmF0ZVxcbiAgICogQG5hbWUgYmluZCgpXFxuICAgKi9cXG5cXHRcXHRiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xcblxcdFxcdFxcdHZhciB3b3JkID0gJycsXFxuXFx0XFx0XFx0ICAgIHRvdXQgPSBudWxsLFxcblxcdFxcdFxcdCAgICB3YXNfY2xpY2sgPSAwO1xcblxcdFxcdFxcdHRoaXMuZWxlbWVudC5vbihcXFwiZGJsY2xpY2suanN0cmVlXFxcIiwgZnVuY3Rpb24gKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZS50YXJnZXQudGFnTmFtZSAmJiBlLnRhcmdldC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFxcXCJpbnB1dFxcXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aWYgKGRvY3VtZW50LnNlbGVjdGlvbiAmJiBkb2N1bWVudC5zZWxlY3Rpb24uZW1wdHkpIHtcXG5cXHRcXHRcXHRcXHRcXHRkb2N1bWVudC5zZWxlY3Rpb24uZW1wdHkoKTtcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdGlmICh3aW5kb3cuZ2V0U2VsZWN0aW9uKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIHNlbCA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0cnkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzZWwuY29sbGFwc2UoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9IGNhdGNoIChpZ25vcmUpIHt9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9KS5vbihcXFwibW91c2Vkb3duLmpzdHJlZVxcXCIsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZS50YXJnZXQgPT09IHRoaXMuZWxlbWVudFswXSkge1xcblxcdFxcdFxcdFxcdFxcdGUucHJldmVudERlZmF1bHQoKTsgLy8gcHJldmVudCBsb3NpbmcgZm9jdXMgd2hlbiBjbGlja2luZyBzY3JvbGwgYXJyb3dzIChGRiwgQ2hyb21lKVxcblxcdFxcdFxcdFxcdFxcdHdhc19jbGljayA9ICtuZXcgRGF0ZSgpOyAvLyBpZSBkb2VzIG5vdCBhbGxvdyB0byBwcmV2ZW50IGxvc2luZyBmb2N1c1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LCB0aGlzKSkub24oXFxcIm1vdXNlZG93bi5qc3RyZWVcXFwiLCBcXFwiLmpzdHJlZS1vY2xcXFwiLCBmdW5jdGlvbiAoZSkge1xcblxcdFxcdFxcdFxcdGUucHJldmVudERlZmF1bHQoKTsgLy8gcHJldmVudCBhbnkgbm9kZSBpbnNpZGUgZnJvbSBsb3NpbmcgZm9jdXMgd2hlbiBjbGlja2luZyB0aGUgb3Blbi9jbG9zZSBpY29uXFxuXFx0XFx0XFx0fSkub24oXFxcImNsaWNrLmpzdHJlZVxcXCIsIFxcXCIuanN0cmVlLW9jbFxcXCIsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLnRvZ2dsZV9ub2RlKGUudGFyZ2V0KTtcXG5cXHRcXHRcXHR9LCB0aGlzKSkub24oXFxcImRibGNsaWNrLmpzdHJlZVxcXCIsIFxcXCIuanN0cmVlLWFuY2hvclxcXCIsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZS50YXJnZXQudGFnTmFtZSAmJiBlLnRhcmdldC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFxcXCJpbnB1dFxcXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aWYgKHRoaXMuc2V0dGluZ3MuY29yZS5kYmxjbGlja190b2dnbGUpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnRvZ2dsZV9ub2RlKGUudGFyZ2V0KTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSwgdGhpcykpLm9uKFxcXCJjbGljay5qc3RyZWVcXFwiLCBcXFwiLmpzdHJlZS1hbmNob3JcXFwiLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XFxuXFx0XFx0XFx0XFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdFxcdFxcdFxcdGlmIChlLmN1cnJlbnRUYXJnZXQgIT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIHtcXG5cXHRcXHRcXHRcXHRcXHQkKGUuY3VycmVudFRhcmdldCkuZm9jdXMoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0dGhpcy5hY3RpdmF0ZV9ub2RlKGUuY3VycmVudFRhcmdldCwgZSk7XFxuXFx0XFx0XFx0fSwgdGhpcykpLm9uKCdrZXlkb3duLmpzdHJlZScsICcuanN0cmVlLWFuY2hvcicsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZS50YXJnZXQudGFnTmFtZSAmJiBlLnRhcmdldC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFxcXCJpbnB1dFxcXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aWYgKGUud2hpY2ggIT09IDMyICYmIGUud2hpY2ggIT09IDEzICYmIChlLnNoaWZ0S2V5IHx8IGUuY3RybEtleSB8fCBlLmFsdEtleSB8fCBlLm1ldGFLZXkpKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHZhciBvID0gbnVsbDtcXG5cXHRcXHRcXHRcXHRpZiAodGhpcy5fZGF0YS5jb3JlLnJ0bCkge1xcblxcdFxcdFxcdFxcdFxcdGlmIChlLndoaWNoID09PSAzNykge1xcblxcdFxcdFxcdFxcdFxcdFxcdGUud2hpY2ggPSAzOTtcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2UgaWYgKGUud2hpY2ggPT09IDM5KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZS53aGljaCA9IDM3O1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0c3dpdGNoIChlLndoaWNoKSB7XFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAzMjpcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBhcmlhIGRlZmluZXMgc3BhY2Ugb25seSB3aXRoIEN0cmxcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoZS5jdHJsS2V5KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZS50eXBlID0gXFxcImNsaWNrXFxcIjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQkKGUuY3VycmVudFRhcmdldCkudHJpZ2dlcihlKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAxMzpcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBlbnRlclxcblxcdFxcdFxcdFxcdFxcdFxcdGUudHlwZSA9IFxcXCJjbGlja1xcXCI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0JChlLmN1cnJlbnRUYXJnZXQpLnRyaWdnZXIoZSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAzNzpcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBsZWZ0XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICh0aGlzLmlzX29wZW4oZS5jdXJyZW50VGFyZ2V0KSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuY2xvc2Vfbm9kZShlLmN1cnJlbnRUYXJnZXQpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0byA9IHRoaXMuZ2V0X3BhcmVudChlLmN1cnJlbnRUYXJnZXQpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChvICYmIG8uaWQgIT09ICQuanN0cmVlLnJvb3QpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLmdldF9ub2RlKG8sIHRydWUpLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLmZvY3VzKCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRjYXNlIDM4OlxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIHVwXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdFxcdFxcdFxcdFxcdFxcdG8gPSB0aGlzLmdldF9wcmV2X2RvbShlLmN1cnJlbnRUYXJnZXQpO1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChvICYmIG8ubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0by5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5mb2N1cygpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRjYXNlIDM5OlxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIHJpZ2h0XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICh0aGlzLmlzX2Nsb3NlZChlLmN1cnJlbnRUYXJnZXQpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5vcGVuX25vZGUoZS5jdXJyZW50VGFyZ2V0LCBmdW5jdGlvbiAobykge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuZ2V0X25vZGUobywgdHJ1ZSkuY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuZm9jdXMoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2UgaWYgKHRoaXMuaXNfb3BlbihlLmN1cnJlbnRUYXJnZXQpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0byA9IHRoaXMuZ2V0X25vZGUoZS5jdXJyZW50VGFyZ2V0LCB0cnVlKS5jaGlsZHJlbignLmpzdHJlZS1jaGlsZHJlbicpWzBdO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChvKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0JCh0aGlzLl9maXJzdENoaWxkKG8pKS5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5mb2N1cygpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSA0MDpcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBkb3duXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdFxcdFxcdFxcdFxcdFxcdG8gPSB0aGlzLmdldF9uZXh0X2RvbShlLmN1cnJlbnRUYXJnZXQpO1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChvICYmIG8ubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0by5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5mb2N1cygpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRjYXNlIDEwNjpcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBhcmlhIGRlZmluZXMgKiBvbiBudW1wYWQgYXMgb3Blbl9hbGwgLSBub3QgdmVyeSBjb21tb25cXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLm9wZW5fYWxsKCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAzNjpcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBob21lXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdFxcdFxcdFxcdFxcdFxcdG8gPSB0aGlzLl9maXJzdENoaWxkKHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpWzBdKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAobykge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdCQobykuY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuZmlsdGVyKCc6dmlzaWJsZScpLmZvY3VzKCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdGNhc2UgMzU6XFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gZW5kXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuZWxlbWVudC5maW5kKCcuanN0cmVlLWFuY2hvcicpLmZpbHRlcignOnZpc2libGUnKS5sYXN0KCkuZm9jdXMoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRjYXNlIDExMzpcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBmMiAtIHNhZmUgdG8gaW5jbHVkZSAtIGlmIGNoZWNrX2NhbGxiYWNrIGlzIGZhbHNlIGl0IHdpbGwgZmFpbFxcblxcdFxcdFxcdFxcdFxcdFxcdGUucHJldmVudERlZmF1bHQoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLmVkaXQoZS5jdXJyZW50VGFyZ2V0KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRkZWZhdWx0OlxcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdC8qIVxcbiAgICAgLy8gZGVsZXRlXFxuICAgICBjYXNlIDQ2OlxcbiAgICAgXFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgXFx0byA9IHRoaXMuZ2V0X25vZGUoZS5jdXJyZW50VGFyZ2V0KTtcXG4gICAgIFxcdGlmKG8gJiYgby5pZCAmJiBvLmlkICE9PSAkLmpzdHJlZS5yb290KSB7XFxuICAgICBcXHRcXHRvID0gdGhpcy5pc19zZWxlY3RlZChvKSA/IHRoaXMuZ2V0X3NlbGVjdGVkKCkgOiBvO1xcbiAgICAgXFx0XFx0dGhpcy5kZWxldGVfbm9kZShvKTtcXG4gICAgIFxcdH1cXG4gICAgIFxcdGJyZWFrO1xcbiAgICAgXFx0Ki9cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSwgdGhpcykpLm9uKFxcXCJsb2FkX25vZGUuanN0cmVlXFxcIiwgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xcblxcdFxcdFxcdFxcdGlmIChkYXRhLnN0YXR1cykge1xcblxcdFxcdFxcdFxcdFxcdGlmIChkYXRhLm5vZGUuaWQgPT09ICQuanN0cmVlLnJvb3QgJiYgIXRoaXMuX2RhdGEuY29yZS5sb2FkZWQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl9kYXRhLmNvcmUubG9hZGVkID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAodGhpcy5fZmlyc3RDaGlsZCh0aGlzLmdldF9jb250YWluZXJfdWwoKVswXSkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLmVsZW1lbnQuYXR0cignYXJpYS1hY3RpdmVkZXNjZW5kYW50JywgdGhpcy5fZmlyc3RDaGlsZCh0aGlzLmdldF9jb250YWluZXJfdWwoKVswXSkuaWQpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHQvKipcXG4gICAgICAgKiB0cmlnZ2VyZWQgYWZ0ZXIgdGhlIHJvb3Qgbm9kZSBpcyBsb2FkZWQgZm9yIHRoZSBmaXJzdCB0aW1lXFxuICAgICAgICogQGV2ZW50XFxuICAgICAgICogQG5hbWUgbG9hZGVkLmpzdHJlZVxcbiAgICAgICAqL1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMudHJpZ2dlcihcXFwibG9hZGVkXFxcIik7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmICghdGhpcy5fZGF0YS5jb3JlLnJlYWR5KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0c2V0VGltZW91dCgkLnByb3h5KGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAodGhpcy5lbGVtZW50ICYmICF0aGlzLmdldF9jb250YWluZXJfdWwoKS5maW5kKCcuanN0cmVlLWxvYWRpbmcnKS5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl9kYXRhLmNvcmUucmVhZHkgPSB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICh0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKHRoaXMuc2V0dGluZ3MuY29yZS5leHBhbmRfc2VsZWN0ZWRfb25sb2FkKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIHRtcCA9IFtdLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdCAgICBpLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdCAgICBqO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGZvciAoaSA9IDAsIGogPSB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dG1wID0gdG1wLmNvbmNhdCh0aGlzLl9tb2RlbC5kYXRhW3RoaXMuX2RhdGEuY29yZS5zZWxlY3RlZFtpXV0ucGFyZW50cyk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRtcCA9ICQudmFrYXRhLmFycmF5X3VuaXF1ZSh0bXApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGZvciAoaSA9IDAsIGogPSB0bXAubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5vcGVuX25vZGUodG1wW2ldLCBmYWxzZSwgMCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLnRyaWdnZXIoJ2NoYW5nZWQnLCB7ICdhY3Rpb24nOiAncmVhZHknLCAnc2VsZWN0ZWQnOiB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQgfSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8qKlxcbiAgICAgICAgICogdHJpZ2dlcmVkIGFmdGVyIGFsbCBub2RlcyBhcmUgZmluaXNoZWQgbG9hZGluZ1xcbiAgICAgICAgICogQGV2ZW50XFxuICAgICAgICAgKiBAbmFtZSByZWFkeS5qc3RyZWVcXG4gICAgICAgICAqL1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoaXMudHJpZ2dlcihcXFwicmVhZHlcXFwiKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSwgdGhpcyksIDApO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSwgdGhpcykpXFxuXFx0XFx0XFx0Ly8gcXVpY2sgc2VhcmNoaW5nIHdoZW4gdGhlIHRyZWUgaXMgZm9jdXNlZFxcblxcdFxcdFxcdC5vbigna2V5cHJlc3MuanN0cmVlJywgJC5wcm94eShmdW5jdGlvbiAoZSkge1xcblxcdFxcdFxcdFxcdGlmIChlLnRhcmdldC50YWdOYW1lICYmIGUudGFyZ2V0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXFxcImlucHV0XFxcIikge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRpZiAodG91dCkge1xcblxcdFxcdFxcdFxcdFxcdGNsZWFyVGltZW91dCh0b3V0KTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0dG91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdHdvcmQgPSAnJztcXG5cXHRcXHRcXHRcXHR9LCA1MDApO1xcblxcblxcdFxcdFxcdFxcdHZhciBjaHIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGUud2hpY2gpLnRvTG93ZXJDYXNlKCksXFxuXFx0XFx0XFx0XFx0ICAgIGNvbCA9IHRoaXMuZWxlbWVudC5maW5kKCcuanN0cmVlLWFuY2hvcicpLmZpbHRlcignOnZpc2libGUnKSxcXG5cXHRcXHRcXHRcXHQgICAgaW5kID0gY29sLmluZGV4KGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIHx8IDAsXFxuXFx0XFx0XFx0XFx0ICAgIGVuZCA9IGZhbHNlO1xcblxcdFxcdFxcdFxcdHdvcmQgKz0gY2hyO1xcblxcblxcdFxcdFxcdFxcdC8vIG1hdGNoIGZvciB3aG9sZSB3b3JkIGZyb20gY3VycmVudCBub2RlIGRvd24gKGluY2x1ZGluZyB0aGUgY3VycmVudCBub2RlKVxcblxcdFxcdFxcdFxcdGlmICh3b3JkLmxlbmd0aCA+IDEpIHtcXG5cXHRcXHRcXHRcXHRcXHRjb2wuc2xpY2UoaW5kKS5lYWNoKCQucHJveHkoZnVuY3Rpb24gKGksIHYpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoJCh2KS50ZXh0KCkudG9Mb3dlckNhc2UoKS5pbmRleE9mKHdvcmQpID09PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0JCh2KS5mb2N1cygpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGVuZCA9IHRydWU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9LCB0aGlzKSk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGVuZCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gbWF0Y2ggZm9yIHdob2xlIHdvcmQgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0cmVlXFxuXFx0XFx0XFx0XFx0XFx0Y29sLnNsaWNlKDAsIGluZCkuZWFjaCgkLnByb3h5KGZ1bmN0aW9uIChpLCB2KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCQodikudGV4dCgpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZih3b3JkKSA9PT0gMCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdCQodikuZm9jdXMoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRlbmQgPSB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fSwgdGhpcykpO1xcblxcdFxcdFxcdFxcdFxcdGlmIChlbmQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHQvLyBsaXN0IG5vZGVzIHRoYXQgc3RhcnQgd2l0aCB0aGF0IGxldHRlciAob25seSBpZiB3b3JkIGNvbnNpc3RzIG9mIGEgc2luZ2xlIGNoYXIpXFxuXFx0XFx0XFx0XFx0aWYgKG5ldyBSZWdFeHAoJ14nICsgY2hyLnJlcGxhY2UoL1stXFxcXC9cXFxcXFxcXF4kKis/LigpfFtcXFxcXXt9XS9nLCAnXFxcXFxcXFwkJicpICsgJyskJykudGVzdCh3b3JkKSkge1xcblxcdFxcdFxcdFxcdFxcdC8vIHNlYXJjaCBmb3IgdGhlIG5leHQgbm9kZSBzdGFydGluZyB3aXRoIHRoYXQgbGV0dGVyXFxuXFx0XFx0XFx0XFx0XFx0Y29sLnNsaWNlKGluZCArIDEpLmVhY2goJC5wcm94eShmdW5jdGlvbiAoaSwgdikge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICgkKHYpLnRleHQoKS50b0xvd2VyQ2FzZSgpLmNoYXJBdCgwKSA9PT0gY2hyKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0JCh2KS5mb2N1cygpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGVuZCA9IHRydWU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9LCB0aGlzKSk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGVuZCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gc2VhcmNoIGZyb20gdGhlIGJlZ2lubmluZ1xcblxcdFxcdFxcdFxcdFxcdGNvbC5zbGljZSgwLCBpbmQgKyAxKS5lYWNoKCQucHJveHkoZnVuY3Rpb24gKGksIHYpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoJCh2KS50ZXh0KCkudG9Mb3dlckNhc2UoKS5jaGFyQXQoMCkgPT09IGNocikge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdCQodikuZm9jdXMoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRlbmQgPSB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fSwgdGhpcykpO1xcblxcdFxcdFxcdFxcdFxcdGlmIChlbmQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LCB0aGlzKSlcXG5cXHRcXHRcXHQvLyBUSEVNRSBSRUxBVEVEXFxuXFx0XFx0XFx0Lm9uKFxcXCJpbml0LmpzdHJlZVxcXCIsICQucHJveHkoZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdHZhciBzID0gdGhpcy5zZXR0aW5ncy5jb3JlLnRoZW1lcztcXG5cXHRcXHRcXHRcXHR0aGlzLl9kYXRhLmNvcmUudGhlbWVzLmRvdHMgPSBzLmRvdHM7XFxuXFx0XFx0XFx0XFx0dGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5zdHJpcGVzID0gcy5zdHJpcGVzO1xcblxcdFxcdFxcdFxcdHRoaXMuX2RhdGEuY29yZS50aGVtZXMuaWNvbnMgPSBzLmljb25zO1xcblxcdFxcdFxcdFxcdHRoaXMuX2RhdGEuY29yZS50aGVtZXMuZWxsaXBzaXMgPSBzLmVsbGlwc2lzO1xcblxcdFxcdFxcdFxcdHRoaXMuc2V0X3RoZW1lKHMubmFtZSB8fCBcXFwiZGVmYXVsdFxcXCIsIHMudXJsKTtcXG5cXHRcXHRcXHRcXHR0aGlzLnNldF90aGVtZV92YXJpYW50KHMudmFyaWFudCk7XFxuXFx0XFx0XFx0fSwgdGhpcykpLm9uKFxcXCJsb2FkaW5nLmpzdHJlZVxcXCIsICQucHJveHkoZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdHRoaXNbdGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5kb3RzID8gXFxcInNob3dfZG90c1xcXCIgOiBcXFwiaGlkZV9kb3RzXFxcIl0oKTtcXG5cXHRcXHRcXHRcXHR0aGlzW3RoaXMuX2RhdGEuY29yZS50aGVtZXMuaWNvbnMgPyBcXFwic2hvd19pY29uc1xcXCIgOiBcXFwiaGlkZV9pY29uc1xcXCJdKCk7XFxuXFx0XFx0XFx0XFx0dGhpc1t0aGlzLl9kYXRhLmNvcmUudGhlbWVzLnN0cmlwZXMgPyBcXFwic2hvd19zdHJpcGVzXFxcIiA6IFxcXCJoaWRlX3N0cmlwZXNcXFwiXSgpO1xcblxcdFxcdFxcdFxcdHRoaXNbdGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5lbGxpcHNpcyA/IFxcXCJzaG93X2VsbGlwc2lzXFxcIiA6IFxcXCJoaWRlX2VsbGlwc2lzXFxcIl0oKTtcXG5cXHRcXHRcXHR9LCB0aGlzKSkub24oJ2JsdXIuanN0cmVlJywgJy5qc3RyZWUtYW5jaG9yJywgJC5wcm94eShmdW5jdGlvbiAoZSkge1xcblxcdFxcdFxcdFxcdHRoaXMuX2RhdGEuY29yZS5mb2N1c2VkID0gbnVsbDtcXG5cXHRcXHRcXHRcXHQkKGUuY3VycmVudFRhcmdldCkuZmlsdGVyKCcuanN0cmVlLWhvdmVyZWQnKS5tb3VzZWxlYXZlKCk7XFxuXFx0XFx0XFx0XFx0dGhpcy5lbGVtZW50LmF0dHIoJ3RhYmluZGV4JywgJzAnKTtcXG5cXHRcXHRcXHR9LCB0aGlzKSkub24oJ2ZvY3VzLmpzdHJlZScsICcuanN0cmVlLWFuY2hvcicsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcXG5cXHRcXHRcXHRcXHR2YXIgdG1wID0gdGhpcy5nZXRfbm9kZShlLmN1cnJlbnRUYXJnZXQpO1xcblxcdFxcdFxcdFxcdGlmICh0bXAgJiYgdG1wLmlkKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fZGF0YS5jb3JlLmZvY3VzZWQgPSB0bXAuaWQ7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHRoaXMuZWxlbWVudC5maW5kKCcuanN0cmVlLWhvdmVyZWQnKS5ub3QoZS5jdXJyZW50VGFyZ2V0KS5tb3VzZWxlYXZlKCk7XFxuXFx0XFx0XFx0XFx0JChlLmN1cnJlbnRUYXJnZXQpLm1vdXNlZW50ZXIoKTtcXG5cXHRcXHRcXHRcXHR0aGlzLmVsZW1lbnQuYXR0cigndGFiaW5kZXgnLCAnLTEnKTtcXG5cXHRcXHRcXHR9LCB0aGlzKSkub24oJ2ZvY3VzLmpzdHJlZScsICQucHJveHkoZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdGlmICgrbmV3IERhdGUoKSAtIHdhc19jbGljayA+IDUwMCAmJiAhdGhpcy5fZGF0YS5jb3JlLmZvY3VzZWQpIHtcXG5cXHRcXHRcXHRcXHRcXHR3YXNfY2xpY2sgPSAwO1xcblxcdFxcdFxcdFxcdFxcdHZhciBhY3QgPSB0aGlzLmdldF9ub2RlKHRoaXMuZWxlbWVudC5hdHRyKCdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnKSwgdHJ1ZSk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGFjdCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGFjdC5maW5kKCc+IC5qc3RyZWUtYW5jaG9yJykuZm9jdXMoKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sIHRoaXMpKS5vbignbW91c2VlbnRlci5qc3RyZWUnLCAnLmpzdHJlZS1hbmNob3InLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5ob3Zlcl9ub2RlKGUuY3VycmVudFRhcmdldCk7XFxuXFx0XFx0XFx0fSwgdGhpcykpLm9uKCdtb3VzZWxlYXZlLmpzdHJlZScsICcuanN0cmVlLWFuY2hvcicsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLmRlaG92ZXJfbm9kZShlLmN1cnJlbnRUYXJnZXQpO1xcblxcdFxcdFxcdH0sIHRoaXMpKTtcXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogcGFydCBvZiB0aGUgZGVzdHJveWluZyBvZiBhbiBpbnN0YW5jZS4gVXNlZCBpbnRlcm5hbGx5LlxcbiAgICogQHByaXZhdGVcXG4gICAqIEBuYW1lIHVuYmluZCgpXFxuICAgKi9cXG5cXHRcXHR1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCgpIHtcXG5cXHRcXHRcXHR0aGlzLmVsZW1lbnQub2ZmKCcuanN0cmVlJyk7XFxuXFx0XFx0XFx0JChkb2N1bWVudCkub2ZmKCcuanN0cmVlLScgKyB0aGlzLl9pZCk7XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIHRyaWdnZXIgYW4gZXZlbnQuIFVzZWQgaW50ZXJuYWxseS5cXG4gICAqIEBwcml2YXRlXFxuICAgKiBAbmFtZSB0cmlnZ2VyKGV2IFssIGRhdGFdKVxcbiAgICogQHBhcmFtICB7U3RyaW5nfSBldiB0aGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gdHJpZ2dlclxcbiAgICogQHBhcmFtICB7T2JqZWN0fSBkYXRhIGFkZGl0aW9uYWwgZGF0YSB0byBwYXNzIHdpdGggdGhlIGV2ZW50XFxuICAgKi9cXG5cXHRcXHR0cmlnZ2VyOiBmdW5jdGlvbiB0cmlnZ2VyKGV2LCBkYXRhKSB7XFxuXFx0XFx0XFx0aWYgKCFkYXRhKSB7XFxuXFx0XFx0XFx0XFx0ZGF0YSA9IHt9O1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRkYXRhLmluc3RhbmNlID0gdGhpcztcXG5cXHRcXHRcXHR0aGlzLmVsZW1lbnQudHJpZ2dlckhhbmRsZXIoZXYucmVwbGFjZSgnLmpzdHJlZScsICcnKSArICcuanN0cmVlJywgZGF0YSk7XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIHJldHVybnMgdGhlIGpRdWVyeSBleHRlbmRlZCBpbnN0YW5jZSBjb250YWluZXJcXG4gICAqIEBuYW1lIGdldF9jb250YWluZXIoKVxcbiAgICogQHJldHVybiB7alF1ZXJ5fVxcbiAgICovXFxuXFx0XFx0Z2V0X2NvbnRhaW5lcjogZnVuY3Rpb24gZ2V0X2NvbnRhaW5lcigpIHtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5lbGVtZW50O1xcblxcdFxcdH0sXFxuXFx0XFx0LyoqXFxuICAgKiByZXR1cm5zIHRoZSBqUXVlcnkgZXh0ZW5kZWQgbWFpbiBVTCBub2RlIGluc2lkZSB0aGUgaW5zdGFuY2UgY29udGFpbmVyLiBVc2VkIGludGVybmFsbHkuXFxuICAgKiBAcHJpdmF0ZVxcbiAgICogQG5hbWUgZ2V0X2NvbnRhaW5lcl91bCgpXFxuICAgKiBAcmV0dXJuIHtqUXVlcnl9XFxuICAgKi9cXG5cXHRcXHRnZXRfY29udGFpbmVyX3VsOiBmdW5jdGlvbiBnZXRfY29udGFpbmVyX3VsKCkge1xcblxcdFxcdFxcdHJldHVybiB0aGlzLmVsZW1lbnQuY2hpbGRyZW4oXFxcIi5qc3RyZWUtY2hpbGRyZW5cXFwiKS5maXJzdCgpO1xcblxcdFxcdH0sXFxuXFx0XFx0LyoqXFxuICAgKiBnZXRzIHN0cmluZyByZXBsYWNlbWVudHMgKGxvY2FsaXphdGlvbikuIFVzZWQgaW50ZXJuYWxseS5cXG4gICAqIEBwcml2YXRlXFxuICAgKiBAbmFtZSBnZXRfc3RyaW5nKGtleSlcXG4gICAqIEBwYXJhbSAge1N0cmluZ30ga2V5XFxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XFxuICAgKi9cXG5cXHRcXHRnZXRfc3RyaW5nOiBmdW5jdGlvbiBnZXRfc3RyaW5nKGtleSkge1xcblxcdFxcdFxcdHZhciBhID0gdGhpcy5zZXR0aW5ncy5jb3JlLnN0cmluZ3M7XFxuXFx0XFx0XFx0aWYgKCQuaXNGdW5jdGlvbihhKSkge1xcblxcdFxcdFxcdFxcdHJldHVybiBhLmNhbGwodGhpcywga2V5KTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKGEgJiYgYVtrZXldKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGFba2V5XTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIGtleTtcXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogZ2V0cyB0aGUgZmlyc3QgY2hpbGQgb2YgYSBET00gbm9kZS4gVXNlZCBpbnRlcm5hbGx5LlxcbiAgICogQHByaXZhdGVcXG4gICAqIEBuYW1lIF9maXJzdENoaWxkKGRvbSlcXG4gICAqIEBwYXJhbSAge0RPTUVsZW1lbnR9IGRvbVxcbiAgICogQHJldHVybiB7RE9NRWxlbWVudH1cXG4gICAqL1xcblxcdFxcdF9maXJzdENoaWxkOiBmdW5jdGlvbiBfZmlyc3RDaGlsZChkb20pIHtcXG5cXHRcXHRcXHRkb20gPSBkb20gPyBkb20uZmlyc3RDaGlsZCA6IG51bGw7XFxuXFx0XFx0XFx0d2hpbGUgKGRvbSAhPT0gbnVsbCAmJiBkb20ubm9kZVR5cGUgIT09IDEpIHtcXG5cXHRcXHRcXHRcXHRkb20gPSBkb20ubmV4dFNpYmxpbmc7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiBkb207XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIGdldHMgdGhlIG5leHQgc2libGluZyBvZiBhIERPTSBub2RlLiBVc2VkIGludGVybmFsbHkuXFxuICAgKiBAcHJpdmF0ZVxcbiAgICogQG5hbWUgX25leHRTaWJsaW5nKGRvbSlcXG4gICAqIEBwYXJhbSAge0RPTUVsZW1lbnR9IGRvbVxcbiAgICogQHJldHVybiB7RE9NRWxlbWVudH1cXG4gICAqL1xcblxcdFxcdF9uZXh0U2libGluZzogZnVuY3Rpb24gX25leHRTaWJsaW5nKGRvbSkge1xcblxcdFxcdFxcdGRvbSA9IGRvbSA/IGRvbS5uZXh0U2libGluZyA6IG51bGw7XFxuXFx0XFx0XFx0d2hpbGUgKGRvbSAhPT0gbnVsbCAmJiBkb20ubm9kZVR5cGUgIT09IDEpIHtcXG5cXHRcXHRcXHRcXHRkb20gPSBkb20ubmV4dFNpYmxpbmc7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiBkb207XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIGdldHMgdGhlIHByZXZpb3VzIHNpYmxpbmcgb2YgYSBET00gbm9kZS4gVXNlZCBpbnRlcm5hbGx5LlxcbiAgICogQHByaXZhdGVcXG4gICAqIEBuYW1lIF9wcmV2aW91c1NpYmxpbmcoZG9tKVxcbiAgICogQHBhcmFtICB7RE9NRWxlbWVudH0gZG9tXFxuICAgKiBAcmV0dXJuIHtET01FbGVtZW50fVxcbiAgICovXFxuXFx0XFx0X3ByZXZpb3VzU2libGluZzogZnVuY3Rpb24gX3ByZXZpb3VzU2libGluZyhkb20pIHtcXG5cXHRcXHRcXHRkb20gPSBkb20gPyBkb20ucHJldmlvdXNTaWJsaW5nIDogbnVsbDtcXG5cXHRcXHRcXHR3aGlsZSAoZG9tICE9PSBudWxsICYmIGRvbS5ub2RlVHlwZSAhPT0gMSkge1xcblxcdFxcdFxcdFxcdGRvbSA9IGRvbS5wcmV2aW91c1NpYmxpbmc7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiBkb207XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIGdldCB0aGUgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBhIG5vZGUgKG9yIHRoZSBhY3R1YWwgalF1ZXJ5IGV4dGVuZGVkIERPTSBub2RlKSBieSB1c2luZyBhbnkgaW5wdXQgKGNoaWxkIERPTSBlbGVtZW50LCBJRCBzdHJpbmcsIHNlbGVjdG9yLCBldGMpXFxuICAgKiBAbmFtZSBnZXRfbm9kZShvYmogWywgYXNfZG9tXSlcXG4gICAqIEBwYXJhbSAge21peGVkfSBvYmpcXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IGFzX2RvbVxcbiAgICogQHJldHVybiB7T2JqZWN0fGpRdWVyeX1cXG4gICAqL1xcblxcdFxcdGdldF9ub2RlOiBmdW5jdGlvbiBnZXRfbm9kZShvYmosIGFzX2RvbSkge1xcblxcdFxcdFxcdGlmIChvYmogJiYgb2JqLmlkKSB7XFxuXFx0XFx0XFx0XFx0b2JqID0gb2JqLmlkO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR2YXIgZG9tO1xcblxcdFxcdFxcdHRyeSB7XFxuXFx0XFx0XFx0XFx0aWYgKHRoaXMuX21vZGVsLmRhdGFbb2JqXSkge1xcblxcdFxcdFxcdFxcdFxcdG9iaiA9IHRoaXMuX21vZGVsLmRhdGFbb2JqXTtcXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09IFxcXCJzdHJpbmdcXFwiICYmIHRoaXMuX21vZGVsLmRhdGFbb2JqLnJlcGxhY2UoL14jLywgJycpXSkge1xcblxcdFxcdFxcdFxcdFxcdG9iaiA9IHRoaXMuX21vZGVsLmRhdGFbb2JqLnJlcGxhY2UoL14jLywgJycpXTtcXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09IFxcXCJzdHJpbmdcXFwiICYmIChkb20gPSAkKCcjJyArIG9iai5yZXBsYWNlKCQuanN0cmVlLmlkcmVnZXgsICdcXFxcXFxcXCQmJyksIHRoaXMuZWxlbWVudCkpLmxlbmd0aCAmJiB0aGlzLl9tb2RlbC5kYXRhW2RvbS5jbG9zZXN0KCcuanN0cmVlLW5vZGUnKS5hdHRyKCdpZCcpXSkge1xcblxcdFxcdFxcdFxcdFxcdG9iaiA9IHRoaXMuX21vZGVsLmRhdGFbZG9tLmNsb3Nlc3QoJy5qc3RyZWUtbm9kZScpLmF0dHIoJ2lkJyldO1xcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoKGRvbSA9ICQob2JqLCB0aGlzLmVsZW1lbnQpKS5sZW5ndGggJiYgdGhpcy5fbW9kZWwuZGF0YVtkb20uY2xvc2VzdCgnLmpzdHJlZS1ub2RlJykuYXR0cignaWQnKV0pIHtcXG5cXHRcXHRcXHRcXHRcXHRvYmogPSB0aGlzLl9tb2RlbC5kYXRhW2RvbS5jbG9zZXN0KCcuanN0cmVlLW5vZGUnKS5hdHRyKCdpZCcpXTtcXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKChkb20gPSAkKG9iaiwgdGhpcy5lbGVtZW50KSkubGVuZ3RoICYmIGRvbS5oYXNDbGFzcygnanN0cmVlJykpIHtcXG5cXHRcXHRcXHRcXHRcXHRvYmogPSB0aGlzLl9tb2RlbC5kYXRhWyQuanN0cmVlLnJvb3RdO1xcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAoYXNfZG9tKSB7XFxuXFx0XFx0XFx0XFx0XFx0b2JqID0gb2JqLmlkID09PSAkLmpzdHJlZS5yb290ID8gdGhpcy5lbGVtZW50IDogJCgnIycgKyBvYmouaWQucmVwbGFjZSgkLmpzdHJlZS5pZHJlZ2V4LCAnXFxcXFxcXFwkJicpLCB0aGlzLmVsZW1lbnQpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRyZXR1cm4gb2JqO1xcblxcdFxcdFxcdH0gY2F0Y2ggKGV4KSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogZ2V0IHRoZSBwYXRoIHRvIGEgbm9kZSwgZWl0aGVyIGNvbnNpc3Rpbmcgb2Ygbm9kZSB0ZXh0cywgb3Igb2Ygbm9kZSBJRHMsIG9wdGlvbmFsbHkgZ2x1ZWQgdG9nZXRoZXIgKG90aGVyd2lzZSBhbiBhcnJheSlcXG4gICAqIEBuYW1lIGdldF9wYXRoKG9iaiBbLCBnbHVlLCBpZHNdKVxcbiAgICogQHBhcmFtICB7bWl4ZWR9IG9iaiB0aGUgbm9kZVxcbiAgICogQHBhcmFtICB7U3RyaW5nfSBnbHVlIGlmIHlvdSB3YW50IHRoZSBwYXRoIGFzIGEgc3RyaW5nIC0gcGFzcyB0aGUgZ2x1ZSBoZXJlIChmb3IgZXhhbXBsZSAnLycpLCBpZiBhIGZhbHN5IHZhbHVlIGlzIHN1cHBsaWVkIGhlcmUsIGFuIGFycmF5IGlzIHJldHVybmVkXFxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBpZHMgaWYgc2V0IHRvIHRydWUgYnVpbGQgdGhlIHBhdGggdXNpbmcgSUQsIG90aGVyd2lzZSBub2RlIHRleHQgaXMgdXNlZFxcbiAgICogQHJldHVybiB7bWl4ZWR9XFxuICAgKi9cXG5cXHRcXHRnZXRfcGF0aDogZnVuY3Rpb24gZ2V0X3BhdGgob2JqLCBnbHVlLCBpZHMpIHtcXG5cXHRcXHRcXHRvYmogPSBvYmoucGFyZW50cyA/IG9iaiA6IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXHRcXHRcXHRpZiAoIW9iaiB8fCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QgfHwgIW9iai5wYXJlbnRzKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR2YXIgaSxcXG5cXHRcXHRcXHQgICAgaixcXG5cXHRcXHRcXHQgICAgcCA9IFtdO1xcblxcdFxcdFxcdHAucHVzaChpZHMgPyBvYmouaWQgOiBvYmoudGV4dCk7XFxuXFx0XFx0XFx0Zm9yIChpID0gMCwgaiA9IG9iai5wYXJlbnRzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcblxcdFxcdFxcdFxcdHAucHVzaChpZHMgPyBvYmoucGFyZW50c1tpXSA6IHRoaXMuZ2V0X3RleHQob2JqLnBhcmVudHNbaV0pKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cCA9IHAucmV2ZXJzZSgpLnNsaWNlKDEpO1xcblxcdFxcdFxcdHJldHVybiBnbHVlID8gcC5qb2luKGdsdWUpIDogcDtcXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogZ2V0IHRoZSBuZXh0IHZpc2libGUgbm9kZSB0aGF0IGlzIGJlbG93IHRoZSBgb2JqYCBub2RlLiBJZiBgc3RyaWN0YCBpcyBzZXQgdG8gYHRydWVgIG9ubHkgc2libGluZyBub2RlcyBhcmUgcmV0dXJuZWQuXFxuICAgKiBAbmFtZSBnZXRfbmV4dF9kb20ob2JqIFssIHN0cmljdF0pXFxuICAgKiBAcGFyYW0gIHttaXhlZH0gb2JqXFxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBzdHJpY3RcXG4gICAqIEByZXR1cm4ge2pRdWVyeX1cXG4gICAqL1xcblxcdFxcdGdldF9uZXh0X2RvbTogZnVuY3Rpb24gZ2V0X25leHRfZG9tKG9iaiwgc3RyaWN0KSB7XFxuXFx0XFx0XFx0dmFyIHRtcDtcXG5cXHRcXHRcXHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSk7XFxuXFx0XFx0XFx0aWYgKG9ialswXSA9PT0gdGhpcy5lbGVtZW50WzBdKSB7XFxuXFx0XFx0XFx0XFx0dG1wID0gdGhpcy5fZmlyc3RDaGlsZCh0aGlzLmdldF9jb250YWluZXJfdWwoKVswXSk7XFxuXFx0XFx0XFx0XFx0d2hpbGUgKHRtcCAmJiB0bXAub2Zmc2V0SGVpZ2h0ID09PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0dG1wID0gdGhpcy5fbmV4dFNpYmxpbmcodG1wKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRtcCA/ICQodG1wKSA6IGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoIW9iaiB8fCAhb2JqLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKHN0cmljdCkge1xcblxcdFxcdFxcdFxcdHRtcCA9IG9ialswXTtcXG5cXHRcXHRcXHRcXHRkbyB7XFxuXFx0XFx0XFx0XFx0XFx0dG1wID0gdGhpcy5fbmV4dFNpYmxpbmcodG1wKTtcXG5cXHRcXHRcXHRcXHR9IHdoaWxlICh0bXAgJiYgdG1wLm9mZnNldEhlaWdodCA9PT0gMCk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRtcCA/ICQodG1wKSA6IGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAob2JqLmhhc0NsYXNzKFxcXCJqc3RyZWUtb3BlblxcXCIpKSB7XFxuXFx0XFx0XFx0XFx0dG1wID0gdGhpcy5fZmlyc3RDaGlsZChvYmouY2hpbGRyZW4oJy5qc3RyZWUtY2hpbGRyZW4nKVswXSk7XFxuXFx0XFx0XFx0XFx0d2hpbGUgKHRtcCAmJiB0bXAub2Zmc2V0SGVpZ2h0ID09PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0dG1wID0gdGhpcy5fbmV4dFNpYmxpbmcodG1wKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aWYgKHRtcCAhPT0gbnVsbCkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiAkKHRtcCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR0bXAgPSBvYmpbMF07XFxuXFx0XFx0XFx0ZG8ge1xcblxcdFxcdFxcdFxcdHRtcCA9IHRoaXMuX25leHRTaWJsaW5nKHRtcCk7XFxuXFx0XFx0XFx0fSB3aGlsZSAodG1wICYmIHRtcC5vZmZzZXRIZWlnaHQgPT09IDApO1xcblxcdFxcdFxcdGlmICh0bXAgIT09IG51bGwpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gJCh0bXApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gb2JqLnBhcmVudHNVbnRpbChcXFwiLmpzdHJlZVxcXCIsIFxcXCIuanN0cmVlLW5vZGVcXFwiKS5uZXh0QWxsKFxcXCIuanN0cmVlLW5vZGU6dmlzaWJsZVxcXCIpLmZpcnN0KCk7XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIGdldCB0aGUgcHJldmlvdXMgdmlzaWJsZSBub2RlIHRoYXQgaXMgYWJvdmUgdGhlIGBvYmpgIG5vZGUuIElmIGBzdHJpY3RgIGlzIHNldCB0byBgdHJ1ZWAgb25seSBzaWJsaW5nIG5vZGVzIGFyZSByZXR1cm5lZC5cXG4gICAqIEBuYW1lIGdldF9wcmV2X2RvbShvYmogWywgc3RyaWN0XSlcXG4gICAqIEBwYXJhbSAge21peGVkfSBvYmpcXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IHN0cmljdFxcbiAgICogQHJldHVybiB7alF1ZXJ5fVxcbiAgICovXFxuXFx0XFx0Z2V0X3ByZXZfZG9tOiBmdW5jdGlvbiBnZXRfcHJldl9kb20ob2JqLCBzdHJpY3QpIHtcXG5cXHRcXHRcXHR2YXIgdG1wO1xcblxcdFxcdFxcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKTtcXG5cXHRcXHRcXHRpZiAob2JqWzBdID09PSB0aGlzLmVsZW1lbnRbMF0pIHtcXG5cXHRcXHRcXHRcXHR0bXAgPSB0aGlzLmdldF9jb250YWluZXJfdWwoKVswXS5sYXN0Q2hpbGQ7XFxuXFx0XFx0XFx0XFx0d2hpbGUgKHRtcCAmJiB0bXAub2Zmc2V0SGVpZ2h0ID09PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0dG1wID0gdGhpcy5fcHJldmlvdXNTaWJsaW5nKHRtcCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHJldHVybiB0bXAgPyAkKHRtcCkgOiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKCFvYmogfHwgIW9iai5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmIChzdHJpY3QpIHtcXG5cXHRcXHRcXHRcXHR0bXAgPSBvYmpbMF07XFxuXFx0XFx0XFx0XFx0ZG8ge1xcblxcdFxcdFxcdFxcdFxcdHRtcCA9IHRoaXMuX3ByZXZpb3VzU2libGluZyh0bXApO1xcblxcdFxcdFxcdFxcdH0gd2hpbGUgKHRtcCAmJiB0bXAub2Zmc2V0SGVpZ2h0ID09PSAwKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdG1wID8gJCh0bXApIDogZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHRtcCA9IG9ialswXTtcXG5cXHRcXHRcXHRkbyB7XFxuXFx0XFx0XFx0XFx0dG1wID0gdGhpcy5fcHJldmlvdXNTaWJsaW5nKHRtcCk7XFxuXFx0XFx0XFx0fSB3aGlsZSAodG1wICYmIHRtcC5vZmZzZXRIZWlnaHQgPT09IDApO1xcblxcdFxcdFxcdGlmICh0bXAgIT09IG51bGwpIHtcXG5cXHRcXHRcXHRcXHRvYmogPSAkKHRtcCk7XFxuXFx0XFx0XFx0XFx0d2hpbGUgKG9iai5oYXNDbGFzcyhcXFwianN0cmVlLW9wZW5cXFwiKSkge1xcblxcdFxcdFxcdFxcdFxcdG9iaiA9IG9iai5jaGlsZHJlbihcXFwiLmpzdHJlZS1jaGlsZHJlblxcXCIpLmZpcnN0KCkuY2hpbGRyZW4oXFxcIi5qc3RyZWUtbm9kZTp2aXNpYmxlOmxhc3RcXFwiKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0cmV0dXJuIG9iajtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0dG1wID0gb2JqWzBdLnBhcmVudE5vZGUucGFyZW50Tm9kZTtcXG5cXHRcXHRcXHRyZXR1cm4gdG1wICYmIHRtcC5jbGFzc05hbWUgJiYgdG1wLmNsYXNzTmFtZS5pbmRleE9mKCdqc3RyZWUtbm9kZScpICE9PSAtMSA/ICQodG1wKSA6IGZhbHNlO1xcblxcdFxcdH0sXFxuXFx0XFx0LyoqXFxuICAgKiBnZXQgdGhlIHBhcmVudCBJRCBvZiBhIG5vZGVcXG4gICAqIEBuYW1lIGdldF9wYXJlbnQob2JqKVxcbiAgICogQHBhcmFtICB7bWl4ZWR9IG9ialxcbiAgICogQHJldHVybiB7U3RyaW5nfVxcbiAgICovXFxuXFx0XFx0Z2V0X3BhcmVudDogZnVuY3Rpb24gZ2V0X3BhcmVudChvYmopIHtcXG5cXHRcXHRcXHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XFxuXFx0XFx0XFx0aWYgKCFvYmogfHwgb2JqLmlkID09PSAkLmpzdHJlZS5yb290KSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gb2JqLnBhcmVudDtcXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogZ2V0IGEgalF1ZXJ5IGNvbGxlY3Rpb24gb2YgYWxsIHRoZSBjaGlsZHJlbiBvZiBhIG5vZGUgKG5vZGUgbXVzdCBiZSByZW5kZXJlZClcXG4gICAqIEBuYW1lIGdldF9jaGlsZHJlbl9kb20ob2JqKVxcbiAgICogQHBhcmFtICB7bWl4ZWR9IG9ialxcbiAgICogQHJldHVybiB7alF1ZXJ5fVxcbiAgICovXFxuXFx0XFx0Z2V0X2NoaWxkcmVuX2RvbTogZnVuY3Rpb24gZ2V0X2NoaWxkcmVuX2RvbShvYmopIHtcXG5cXHRcXHRcXHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSk7XFxuXFx0XFx0XFx0aWYgKG9ialswXSA9PT0gdGhpcy5lbGVtZW50WzBdKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpLmNoaWxkcmVuKFxcXCIuanN0cmVlLW5vZGVcXFwiKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKCFvYmogfHwgIW9iai5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiBvYmouY2hpbGRyZW4oXFxcIi5qc3RyZWUtY2hpbGRyZW5cXFwiKS5jaGlsZHJlbihcXFwiLmpzdHJlZS1ub2RlXFxcIik7XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIGNoZWNrcyBpZiBhIG5vZGUgaGFzIGNoaWxkcmVuXFxuICAgKiBAbmFtZSBpc19wYXJlbnQob2JqKVxcbiAgICogQHBhcmFtICB7bWl4ZWR9IG9ialxcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cXG4gICAqL1xcblxcdFxcdGlzX3BhcmVudDogZnVuY3Rpb24gaXNfcGFyZW50KG9iaikge1xcblxcdFxcdFxcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXHRcXHRcXHRyZXR1cm4gb2JqICYmIChvYmouc3RhdGUubG9hZGVkID09PSBmYWxzZSB8fCBvYmouY2hpbGRyZW4ubGVuZ3RoID4gMCk7XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIGNoZWNrcyBpZiBhIG5vZGUgaXMgbG9hZGVkIChpdHMgY2hpbGRyZW4gYXJlIGF2YWlsYWJsZSlcXG4gICAqIEBuYW1lIGlzX2xvYWRlZChvYmopXFxuICAgKiBAcGFyYW0gIHttaXhlZH0gb2JqXFxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxcbiAgICovXFxuXFx0XFx0aXNfbG9hZGVkOiBmdW5jdGlvbiBpc19sb2FkZWQob2JqKSB7XFxuXFx0XFx0XFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xcblxcdFxcdFxcdHJldHVybiBvYmogJiYgb2JqLnN0YXRlLmxvYWRlZDtcXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogY2hlY2sgaWYgYSBub2RlIGlzIGN1cnJlbnRseSBsb2FkaW5nIChmZXRjaGluZyBjaGlsZHJlbilcXG4gICAqIEBuYW1lIGlzX2xvYWRpbmcob2JqKVxcbiAgICogQHBhcmFtICB7bWl4ZWR9IG9ialxcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cXG4gICAqL1xcblxcdFxcdGlzX2xvYWRpbmc6IGZ1bmN0aW9uIGlzX2xvYWRpbmcob2JqKSB7XFxuXFx0XFx0XFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xcblxcdFxcdFxcdHJldHVybiBvYmogJiYgb2JqLnN0YXRlICYmIG9iai5zdGF0ZS5sb2FkaW5nO1xcblxcdFxcdH0sXFxuXFx0XFx0LyoqXFxuICAgKiBjaGVjayBpZiBhIG5vZGUgaXMgb3BlbmVkXFxuICAgKiBAbmFtZSBpc19vcGVuKG9iailcXG4gICAqIEBwYXJhbSAge21peGVkfSBvYmpcXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XFxuICAgKi9cXG5cXHRcXHRpc19vcGVuOiBmdW5jdGlvbiBpc19vcGVuKG9iaikge1xcblxcdFxcdFxcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXHRcXHRcXHRyZXR1cm4gb2JqICYmIG9iai5zdGF0ZS5vcGVuZWQ7XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIGNoZWNrIGlmIGEgbm9kZSBpcyBpbiBhIGNsb3NlZCBzdGF0ZVxcbiAgICogQG5hbWUgaXNfY2xvc2VkKG9iailcXG4gICAqIEBwYXJhbSAge21peGVkfSBvYmpcXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XFxuICAgKi9cXG5cXHRcXHRpc19jbG9zZWQ6IGZ1bmN0aW9uIGlzX2Nsb3NlZChvYmopIHtcXG5cXHRcXHRcXHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XFxuXFx0XFx0XFx0cmV0dXJuIG9iaiAmJiB0aGlzLmlzX3BhcmVudChvYmopICYmICFvYmouc3RhdGUub3BlbmVkO1xcblxcdFxcdH0sXFxuXFx0XFx0LyoqXFxuICAgKiBjaGVjayBpZiBhIG5vZGUgaGFzIG5vIGNoaWxkcmVuXFxuICAgKiBAbmFtZSBpc19sZWFmKG9iailcXG4gICAqIEBwYXJhbSAge21peGVkfSBvYmpcXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XFxuICAgKi9cXG5cXHRcXHRpc19sZWFmOiBmdW5jdGlvbiBpc19sZWFmKG9iaikge1xcblxcdFxcdFxcdHJldHVybiAhdGhpcy5pc19wYXJlbnQob2JqKTtcXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogbG9hZHMgYSBub2RlIChmZXRjaGVzIGl0cyBjaGlsZHJlbiB1c2luZyB0aGUgYGNvcmUuZGF0YWAgc2V0dGluZykuIE11bHRpcGxlIG5vZGVzIGNhbiBiZSBwYXNzZWQgdG8gYnkgdXNpbmcgYW4gYXJyYXkuXFxuICAgKiBAbmFtZSBsb2FkX25vZGUob2JqIFssIGNhbGxiYWNrXSlcXG4gICAqIEBwYXJhbSAge21peGVkfSBvYmpcXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSBjYWxsYmFjayBhIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIG9uY2UgbG9hZGluZyBpcyBjb21wbGV0ZSwgdGhlIGZ1bmN0aW9uIGlzIGV4ZWN1dGVkIGluIHRoZSBpbnN0YW5jZSdzIHNjb3BlIGFuZCByZWNlaXZlcyB0d28gYXJndW1lbnRzIC0gdGhlIG5vZGUgYW5kIGEgYm9vbGVhbiBzdGF0dXNcXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XFxuICAgKiBAdHJpZ2dlciBsb2FkX25vZGUuanN0cmVlXFxuICAgKi9cXG5cXHRcXHRsb2FkX25vZGU6IGZ1bmN0aW9uIGxvYWRfbm9kZShvYmosIGNhbGxiYWNrKSB7XFxuXFx0XFx0XFx0dmFyIGssIGwsIGksIGosIGM7XFxuXFx0XFx0XFx0aWYgKCQuaXNBcnJheShvYmopKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5fbG9hZF9ub2RlcyhvYmouc2xpY2UoKSwgY2FsbGJhY2spO1xcblxcdFxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XFxuXFx0XFx0XFx0aWYgKCFvYmopIHtcXG5cXHRcXHRcXHRcXHRpZiAoY2FsbGJhY2spIHtcXG5cXHRcXHRcXHRcXHRcXHRjYWxsYmFjay5jYWxsKHRoaXMsIG9iaiwgZmFsc2UpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdC8vIGlmKG9iai5zdGF0ZS5sb2FkaW5nKSB7IH0gLy8gdGhlIG5vZGUgaXMgYWxyZWFkeSBsb2FkaW5nIC0ganVzdCB3YWl0IGZvciBpdCB0byBsb2FkIGFuZCBpbnZva2UgY2FsbGJhY2s/IGJ1dCBpZiBjYWxsZWQgaW1wbGljaXRseSBpdCBzaG91bGQgYmUgbG9hZGVkIGFnYWluP1xcblxcdFxcdFxcdGlmIChvYmouc3RhdGUubG9hZGVkKSB7XFxuXFx0XFx0XFx0XFx0b2JqLnN0YXRlLmxvYWRlZCA9IGZhbHNlO1xcblxcdFxcdFxcdFxcdGZvciAoaSA9IDAsIGogPSBvYmoucGFyZW50cy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9tb2RlbC5kYXRhW29iai5wYXJlbnRzW2ldXS5jaGlsZHJlbl9kID0gJC52YWthdGEuYXJyYXlfZmlsdGVyKHRoaXMuX21vZGVsLmRhdGFbb2JqLnBhcmVudHNbaV1dLmNoaWxkcmVuX2QsIGZ1bmN0aW9uICh2KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuICQuaW5BcnJheSh2LCBvYmouY2hpbGRyZW5fZCkgPT09IC0xO1xcblxcdFxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRmb3IgKGsgPSAwLCBsID0gb2JqLmNoaWxkcmVuX2QubGVuZ3RoOyBrIDwgbDsgaysrKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHRoaXMuX21vZGVsLmRhdGFbb2JqLmNoaWxkcmVuX2Rba11dLnN0YXRlLnNlbGVjdGVkKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YyA9IHRydWU7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGRlbGV0ZSB0aGlzLl9tb2RlbC5kYXRhW29iai5jaGlsZHJlbl9kW2tdXTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aWYgKGMpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQgPSAkLnZha2F0YS5hcnJheV9maWx0ZXIodGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLCBmdW5jdGlvbiAodikge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiAkLmluQXJyYXkodiwgb2JqLmNoaWxkcmVuX2QpID09PSAtMTtcXG5cXHRcXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0b2JqLmNoaWxkcmVuID0gW107XFxuXFx0XFx0XFx0XFx0b2JqLmNoaWxkcmVuX2QgPSBbXTtcXG5cXHRcXHRcXHRcXHRpZiAoYykge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMudHJpZ2dlcignY2hhbmdlZCcsIHsgJ2FjdGlvbic6ICdsb2FkX25vZGUnLCAnbm9kZSc6IG9iaiwgJ3NlbGVjdGVkJzogdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkIH0pO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0b2JqLnN0YXRlLmZhaWxlZCA9IGZhbHNlO1xcblxcdFxcdFxcdG9iai5zdGF0ZS5sb2FkaW5nID0gdHJ1ZTtcXG5cXHRcXHRcXHR0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSkuYWRkQ2xhc3MoXFxcImpzdHJlZS1sb2FkaW5nXFxcIikuYXR0cignYXJpYS1idXN5JywgdHJ1ZSk7XFxuXFx0XFx0XFx0dGhpcy5fbG9hZF9ub2RlKG9iaiwgJC5wcm94eShmdW5jdGlvbiAoc3RhdHVzKSB7XFxuXFx0XFx0XFx0XFx0b2JqID0gdGhpcy5fbW9kZWwuZGF0YVtvYmouaWRdO1xcblxcdFxcdFxcdFxcdG9iai5zdGF0ZS5sb2FkaW5nID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0b2JqLnN0YXRlLmxvYWRlZCA9IHN0YXR1cztcXG5cXHRcXHRcXHRcXHRvYmouc3RhdGUuZmFpbGVkID0gIW9iai5zdGF0ZS5sb2FkZWQ7XFxuXFx0XFx0XFx0XFx0dmFyIGRvbSA9IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKSxcXG5cXHRcXHRcXHRcXHQgICAgaSA9IDAsXFxuXFx0XFx0XFx0XFx0ICAgIGogPSAwLFxcblxcdFxcdFxcdFxcdCAgICBtID0gdGhpcy5fbW9kZWwuZGF0YSxcXG5cXHRcXHRcXHRcXHQgICAgaGFzX2NoaWxkcmVuID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0Zm9yIChpID0gMCwgaiA9IG9iai5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAobVtvYmouY2hpbGRyZW5baV1dICYmICFtW29iai5jaGlsZHJlbltpXV0uc3RhdGUuaGlkZGVuKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aGFzX2NoaWxkcmVuID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGlmIChvYmouc3RhdGUubG9hZGVkICYmIGRvbSAmJiBkb20ubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZG9tLnJlbW92ZUNsYXNzKCdqc3RyZWUtY2xvc2VkIGpzdHJlZS1vcGVuIGpzdHJlZS1sZWFmJyk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCFoYXNfY2hpbGRyZW4pIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRkb20uYWRkQ2xhc3MoJ2pzdHJlZS1sZWFmJyk7XFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAob2JqLmlkICE9PSAnIycpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRkb20uYWRkQ2xhc3Mob2JqLnN0YXRlLm9wZW5lZCA/ICdqc3RyZWUtb3BlbicgOiAnanN0cmVlLWNsb3NlZCcpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGRvbS5yZW1vdmVDbGFzcyhcXFwianN0cmVlLWxvYWRpbmdcXFwiKS5hdHRyKCdhcmlhLWJ1c3knLCBmYWxzZSk7XFxuXFx0XFx0XFx0XFx0LyoqXFxuICAgICAqIHRyaWdnZXJlZCBhZnRlciBhIG5vZGUgaXMgbG9hZGVkXFxuICAgICAqIEBldmVudFxcbiAgICAgKiBAbmFtZSBsb2FkX25vZGUuanN0cmVlXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIHRoZSBub2RlIHRoYXQgd2FzIGxvYWRpbmdcXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzdGF0dXMgd2FzIHRoZSBub2RlIGxvYWRlZCBzdWNjZXNzZnVsbHlcXG4gICAgICovXFxuXFx0XFx0XFx0XFx0dGhpcy50cmlnZ2VyKCdsb2FkX25vZGUnLCB7IFxcXCJub2RlXFxcIjogb2JqLCBcXFwic3RhdHVzXFxcIjogc3RhdHVzIH0pO1xcblxcdFxcdFxcdFxcdGlmIChjYWxsYmFjaykge1xcblxcdFxcdFxcdFxcdFxcdGNhbGxiYWNrLmNhbGwodGhpcywgb2JqLCBzdGF0dXMpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LCB0aGlzKSk7XFxuXFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIGxvYWQgYW4gYXJyYXkgb2Ygbm9kZXMgKHdpbGwgYWxzbyBsb2FkIHVuYXZhaWxhYmxlIG5vZGVzIGFzIHNvb24gYXMgdGhlIGFwcGVhciBpbiB0aGUgc3RydWN0dXJlKS4gVXNlZCBpbnRlcm5hbGx5LlxcbiAgICogQHByaXZhdGVcXG4gICAqIEBuYW1lIF9sb2FkX25vZGVzKG5vZGVzIFssIGNhbGxiYWNrXSlcXG4gICAqIEBwYXJhbSAge2FycmF5fSBub2Rlc1xcbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IGNhbGxiYWNrIGEgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgb25jZSBsb2FkaW5nIGlzIGNvbXBsZXRlLCB0aGUgZnVuY3Rpb24gaXMgZXhlY3V0ZWQgaW4gdGhlIGluc3RhbmNlJ3Mgc2NvcGUgYW5kIHJlY2VpdmVzIG9uZSBhcmd1bWVudCAtIHRoZSBhcnJheSBwYXNzZWQgdG8gX2xvYWRfbm9kZXNcXG4gICAqL1xcblxcdFxcdF9sb2FkX25vZGVzOiBmdW5jdGlvbiBfbG9hZF9ub2Rlcyhub2RlcywgY2FsbGJhY2ssIGlzX2NhbGxiYWNrLCBmb3JjZV9yZWxvYWQpIHtcXG5cXHRcXHRcXHR2YXIgciA9IHRydWUsXFxuXFx0XFx0XFx0ICAgIGMgPSBmdW5jdGlvbiBjKCkge1xcblxcdFxcdFxcdFxcdHRoaXMuX2xvYWRfbm9kZXMobm9kZXMsIGNhbGxiYWNrLCB0cnVlKTtcXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdCAgICBtID0gdGhpcy5fbW9kZWwuZGF0YSxcXG5cXHRcXHRcXHQgICAgaSxcXG5cXHRcXHRcXHQgICAgaixcXG5cXHRcXHRcXHQgICAgdG1wID0gW107XFxuXFx0XFx0XFx0Zm9yIChpID0gMCwgaiA9IG5vZGVzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcblxcdFxcdFxcdFxcdGlmIChtW25vZGVzW2ldXSAmJiAoIW1bbm9kZXNbaV1dLnN0YXRlLmxvYWRlZCAmJiAhbVtub2Rlc1tpXV0uc3RhdGUuZmFpbGVkIHx8ICFpc19jYWxsYmFjayAmJiBmb3JjZV9yZWxvYWQpKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCF0aGlzLmlzX2xvYWRpbmcobm9kZXNbaV0pKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5sb2FkX25vZGUobm9kZXNbaV0sIGMpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRyID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAocikge1xcblxcdFxcdFxcdFxcdGZvciAoaSA9IDAsIGogPSBub2Rlcy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAobVtub2Rlc1tpXV0gJiYgbVtub2Rlc1tpXV0uc3RhdGUubG9hZGVkKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dG1wLnB1c2gobm9kZXNbaV0pO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aWYgKGNhbGxiYWNrICYmICFjYWxsYmFjay5kb25lKSB7XFxuXFx0XFx0XFx0XFx0XFx0Y2FsbGJhY2suY2FsbCh0aGlzLCB0bXApO1xcblxcdFxcdFxcdFxcdFxcdGNhbGxiYWNrLmRvbmUgPSB0cnVlO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIGxvYWRzIGFsbCB1bmxvYWRlZCBub2Rlc1xcbiAgICogQG5hbWUgbG9hZF9hbGwoW29iaiwgY2FsbGJhY2tdKVxcbiAgICogQHBhcmFtIHttaXhlZH0gb2JqIHRoZSBub2RlIHRvIGxvYWQgcmVjdXJzaXZlbHksIG9taXQgdG8gbG9hZCBhbGwgbm9kZXMgaW4gdGhlIHRyZWVcXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIGEgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgb25jZSBsb2FkaW5nIGFsbCB0aGUgbm9kZXMgaXMgY29tcGxldGUsXFxuICAgKiBAdHJpZ2dlciBsb2FkX2FsbC5qc3RyZWVcXG4gICAqL1xcblxcdFxcdGxvYWRfYWxsOiBmdW5jdGlvbiBsb2FkX2FsbChvYmosIGNhbGxiYWNrKSB7XFxuXFx0XFx0XFx0aWYgKCFvYmopIHtcXG5cXHRcXHRcXHRcXHRvYmogPSAkLmpzdHJlZS5yb290O1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XFxuXFx0XFx0XFx0aWYgKCFvYmopIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHZhciB0b19sb2FkID0gW10sXFxuXFx0XFx0XFx0ICAgIG0gPSB0aGlzLl9tb2RlbC5kYXRhLFxcblxcdFxcdFxcdCAgICBjID0gbVtvYmouaWRdLmNoaWxkcmVuX2QsXFxuXFx0XFx0XFx0ICAgIGksXFxuXFx0XFx0XFx0ICAgIGo7XFxuXFx0XFx0XFx0aWYgKG9iai5zdGF0ZSAmJiAhb2JqLnN0YXRlLmxvYWRlZCkge1xcblxcdFxcdFxcdFxcdHRvX2xvYWQucHVzaChvYmouaWQpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRmb3IgKGkgPSAwLCBqID0gYy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRpZiAobVtjW2ldXSAmJiBtW2NbaV1dLnN0YXRlICYmICFtW2NbaV1dLnN0YXRlLmxvYWRlZCkge1xcblxcdFxcdFxcdFxcdFxcdHRvX2xvYWQucHVzaChjW2ldKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICh0b19sb2FkLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdHRoaXMuX2xvYWRfbm9kZXModG9fbG9hZCwgZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMubG9hZF9hbGwob2JqLCBjYWxsYmFjayk7XFxuXFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHQvKipcXG4gICAgICogdHJpZ2dlcmVkIGFmdGVyIGEgbG9hZF9hbGwgY2FsbCBjb21wbGV0ZXNcXG4gICAgICogQGV2ZW50XFxuICAgICAqIEBuYW1lIGxvYWRfYWxsLmpzdHJlZVxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZSB0aGUgcmVjdXJzaXZlbHkgbG9hZGVkIG5vZGVcXG4gICAgICovXFxuXFx0XFx0XFx0XFx0aWYgKGNhbGxiYWNrKSB7XFxuXFx0XFx0XFx0XFx0XFx0Y2FsbGJhY2suY2FsbCh0aGlzLCBvYmopO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR0aGlzLnRyaWdnZXIoJ2xvYWRfYWxsJywgeyBcXFwibm9kZVxcXCI6IG9iaiB9KTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIGhhbmRsZXMgdGhlIGFjdHVhbCBsb2FkaW5nIG9mIGEgbm9kZS4gVXNlZCBvbmx5IGludGVybmFsbHkuXFxuICAgKiBAcHJpdmF0ZVxcbiAgICogQG5hbWUgX2xvYWRfbm9kZShvYmogWywgY2FsbGJhY2tdKVxcbiAgICogQHBhcmFtICB7bWl4ZWR9IG9ialxcbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IGNhbGxiYWNrIGEgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgb25jZSBsb2FkaW5nIGlzIGNvbXBsZXRlLCB0aGUgZnVuY3Rpb24gaXMgZXhlY3V0ZWQgaW4gdGhlIGluc3RhbmNlJ3Mgc2NvcGUgYW5kIHJlY2VpdmVzIG9uZSBhcmd1bWVudCAtIGEgYm9vbGVhbiBzdGF0dXNcXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XFxuICAgKi9cXG5cXHRcXHRfbG9hZF9ub2RlOiBmdW5jdGlvbiBfbG9hZF9ub2RlKG9iaiwgY2FsbGJhY2spIHtcXG5cXHRcXHRcXHR2YXIgcyA9IHRoaXMuc2V0dGluZ3MuY29yZS5kYXRhLFxcblxcdFxcdFxcdCAgICB0O1xcblxcdFxcdFxcdHZhciBub3RUZXh0T3JDb21tZW50Tm9kZSA9IGZ1bmN0aW9uIG5vdFRleHRPckNvbW1lbnROb2RlKCkge1xcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLm5vZGVUeXBlICE9PSAzICYmIHRoaXMubm9kZVR5cGUgIT09IDg7XFxuXFx0XFx0XFx0fTtcXG5cXHRcXHRcXHQvLyB1c2Ugb3JpZ2luYWwgSFRNTFxcblxcdFxcdFxcdGlmICghcykge1xcblxcdFxcdFxcdFxcdGlmIChvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5fYXBwZW5kX2h0bWxfZGF0YShvYmosIHRoaXMuX2RhdGEuY29yZS5vcmlnaW5hbF9jb250YWluZXJfaHRtbC5jbG9uZSh0cnVlKSwgZnVuY3Rpb24gKHN0YXR1cykge1xcblxcdFxcdFxcdFxcdFxcdFxcdGNhbGxiYWNrLmNhbGwodGhpcywgc3RhdHVzKTtcXG5cXHRcXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBjYWxsYmFjay5jYWxsKHRoaXMsIGZhbHNlKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0Ly8gcmV0dXJuIGNhbGxiYWNrLmNhbGwodGhpcywgb2JqLmlkID09PSAkLmpzdHJlZS5yb290ID8gdGhpcy5fYXBwZW5kX2h0bWxfZGF0YShvYmosIHRoaXMuX2RhdGEuY29yZS5vcmlnaW5hbF9jb250YWluZXJfaHRtbC5jbG9uZSh0cnVlKSkgOiBmYWxzZSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICgkLmlzRnVuY3Rpb24ocykpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gcy5jYWxsKHRoaXMsIG9iaiwgJC5wcm94eShmdW5jdGlvbiAoZCkge1xcblxcdFxcdFxcdFxcdFxcdGlmIChkID09PSBmYWxzZSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGNhbGxiYWNrLmNhbGwodGhpcywgZmFsc2UpO1xcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpc1t0eXBlb2YgZCA9PT0gJ3N0cmluZycgPyAnX2FwcGVuZF9odG1sX2RhdGEnIDogJ19hcHBlbmRfanNvbl9kYXRhJ10ob2JqLCB0eXBlb2YgZCA9PT0gJ3N0cmluZycgPyAkKCQucGFyc2VIVE1MKGQpKS5maWx0ZXIobm90VGV4dE9yQ29tbWVudE5vZGUpIDogZCwgZnVuY3Rpb24gKHN0YXR1cykge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGNhbGxiYWNrLmNhbGwodGhpcywgc3RhdHVzKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0Ly8gcmV0dXJuIGQgPT09IGZhbHNlID8gY2FsbGJhY2suY2FsbCh0aGlzLCBmYWxzZSkgOiBjYWxsYmFjay5jYWxsKHRoaXMsIHRoaXNbdHlwZW9mIGQgPT09ICdzdHJpbmcnID8gJ19hcHBlbmRfaHRtbF9kYXRhJyA6ICdfYXBwZW5kX2pzb25fZGF0YSddKG9iaiwgdHlwZW9mIGQgPT09ICdzdHJpbmcnID8gJChkKSA6IGQpKTtcXG5cXHRcXHRcXHRcXHR9LCB0aGlzKSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICgodHlwZW9mIHMgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHMpKSA9PT0gJ29iamVjdCcpIHtcXG5cXHRcXHRcXHRcXHRpZiAocy51cmwpIHtcXG5cXHRcXHRcXHRcXHRcXHRzID0gJC5leHRlbmQodHJ1ZSwge30sIHMpO1xcblxcdFxcdFxcdFxcdFxcdGlmICgkLmlzRnVuY3Rpb24ocy51cmwpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cy51cmwgPSBzLnVybC5jYWxsKHRoaXMsIG9iaik7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmICgkLmlzRnVuY3Rpb24ocy5kYXRhKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHMuZGF0YSA9IHMuZGF0YS5jYWxsKHRoaXMsIG9iaik7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdHJldHVybiAkLmFqYXgocykuZG9uZSgkLnByb3h5KGZ1bmN0aW9uIChkLCB0LCB4KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIHR5cGUgPSB4LmdldFJlc3BvbnNlSGVhZGVyKCdDb250ZW50LVR5cGUnKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAodHlwZSAmJiB0eXBlLmluZGV4T2YoJ2pzb24nKSAhPT0gLTEgfHwgKHR5cGVvZiBkID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihkKSkgPT09IFxcXCJvYmplY3RcXFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuX2FwcGVuZF9qc29uX2RhdGEob2JqLCBkLCBmdW5jdGlvbiAoc3RhdHVzKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Y2FsbGJhY2suY2FsbCh0aGlzLCBzdGF0dXMpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vcmV0dXJuIGNhbGxiYWNrLmNhbGwodGhpcywgdGhpcy5fYXBwZW5kX2pzb25fZGF0YShvYmosIGQpKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKHR5cGUgJiYgdHlwZS5pbmRleE9mKCdodG1sJykgIT09IC0xIHx8IHR5cGVvZiBkID09PSBcXFwic3RyaW5nXFxcIikge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiB0aGlzLl9hcHBlbmRfaHRtbF9kYXRhKG9iaiwgJCgkLnBhcnNlSFRNTChkKSkuZmlsdGVyKG5vdFRleHRPckNvbW1lbnROb2RlKSwgZnVuY3Rpb24gKHN0YXR1cykge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGNhbGxiYWNrLmNhbGwodGhpcywgc3RhdHVzKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyByZXR1cm4gY2FsbGJhY2suY2FsbCh0aGlzLCB0aGlzLl9hcHBlbmRfaHRtbF9kYXRhKG9iaiwgJChkKSkpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvciA9IHsgJ2Vycm9yJzogJ2FqYXgnLCAncGx1Z2luJzogJ2NvcmUnLCAnaWQnOiAnY29yZV8wNCcsICdyZWFzb24nOiAnQ291bGQgbm90IGxvYWQgbm9kZScsICdkYXRhJzogSlNPTi5zdHJpbmdpZnkoeyAnaWQnOiBvYmouaWQsICd4aHInOiB4IH0pIH07XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5zZXR0aW5ncy5jb3JlLmVycm9yLmNhbGwodGhpcywgdGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IpO1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBjYWxsYmFjay5jYWxsKHRoaXMsIGZhbHNlKTtcXG5cXHRcXHRcXHRcXHRcXHR9LCB0aGlzKSkuZmFpbCgkLnByb3h5KGZ1bmN0aW9uIChmKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FsbGJhY2suY2FsbCh0aGlzLCBmYWxzZSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IgPSB7ICdlcnJvcic6ICdhamF4JywgJ3BsdWdpbic6ICdjb3JlJywgJ2lkJzogJ2NvcmVfMDQnLCAncmVhc29uJzogJ0NvdWxkIG5vdCBsb2FkIG5vZGUnLCAnZGF0YSc6IEpTT04uc3RyaW5naWZ5KHsgJ2lkJzogb2JqLmlkLCAneGhyJzogZiB9KSB9O1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuc2V0dGluZ3MuY29yZS5lcnJvci5jYWxsKHRoaXMsIHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yKTtcXG5cXHRcXHRcXHRcXHRcXHR9LCB0aGlzKSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHQgPSAkLmlzQXJyYXkocykgfHwgJC5pc1BsYWluT2JqZWN0KHMpID8gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShzKSkgOiBzO1xcblxcdFxcdFxcdFxcdGlmIChvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5fYXBwZW5kX2pzb25fZGF0YShvYmosIHQsIGZ1bmN0aW9uIChzdGF0dXMpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYWxsYmFjay5jYWxsKHRoaXMsIHN0YXR1cyk7XFxuXFx0XFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvciA9IHsgJ2Vycm9yJzogJ25vZGF0YScsICdwbHVnaW4nOiAnY29yZScsICdpZCc6ICdjb3JlXzA1JywgJ3JlYXNvbic6ICdDb3VsZCBub3QgbG9hZCBub2RlJywgJ2RhdGEnOiBKU09OLnN0cmluZ2lmeSh7ICdpZCc6IG9iai5pZCB9KSB9O1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuc2V0dGluZ3MuY29yZS5lcnJvci5jYWxsKHRoaXMsIHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yKTtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gY2FsbGJhY2suY2FsbCh0aGlzLCBmYWxzZSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdC8vcmV0dXJuIGNhbGxiYWNrLmNhbGwodGhpcywgKG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCA/IHRoaXMuX2FwcGVuZF9qc29uX2RhdGEob2JqLCB0KSA6IGZhbHNlKSApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAodHlwZW9mIHMgPT09ICdzdHJpbmcnKSB7XFxuXFx0XFx0XFx0XFx0aWYgKG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiB0aGlzLl9hcHBlbmRfaHRtbF9kYXRhKG9iaiwgJCgkLnBhcnNlSFRNTChzKSkuZmlsdGVyKG5vdFRleHRPckNvbW1lbnROb2RlKSwgZnVuY3Rpb24gKHN0YXR1cykge1xcblxcdFxcdFxcdFxcdFxcdFxcdGNhbGxiYWNrLmNhbGwodGhpcywgc3RhdHVzKTtcXG5cXHRcXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yID0geyAnZXJyb3InOiAnbm9kYXRhJywgJ3BsdWdpbic6ICdjb3JlJywgJ2lkJzogJ2NvcmVfMDYnLCAncmVhc29uJzogJ0NvdWxkIG5vdCBsb2FkIG5vZGUnLCAnZGF0YSc6IEpTT04uc3RyaW5naWZ5KHsgJ2lkJzogb2JqLmlkIH0pIH07XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5zZXR0aW5ncy5jb3JlLmVycm9yLmNhbGwodGhpcywgdGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IpO1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBjYWxsYmFjay5jYWxsKHRoaXMsIGZhbHNlKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0Ly9yZXR1cm4gY2FsbGJhY2suY2FsbCh0aGlzLCAob2JqLmlkID09PSAkLmpzdHJlZS5yb290ID8gdGhpcy5fYXBwZW5kX2h0bWxfZGF0YShvYmosICQocykpIDogZmFsc2UpICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiBjYWxsYmFjay5jYWxsKHRoaXMsIGZhbHNlKTtcXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogYWRkcyBhIG5vZGUgdG8gdGhlIGxpc3Qgb2Ygbm9kZXMgdG8gcmVkcmF3LiBVc2VkIG9ubHkgaW50ZXJuYWxseS5cXG4gICAqIEBwcml2YXRlXFxuICAgKiBAbmFtZSBfbm9kZV9jaGFuZ2VkKG9iaiBbLCBjYWxsYmFja10pXFxuICAgKiBAcGFyYW0gIHttaXhlZH0gb2JqXFxuICAgKi9cXG5cXHRcXHRfbm9kZV9jaGFuZ2VkOiBmdW5jdGlvbiBfbm9kZV9jaGFuZ2VkKG9iaikge1xcblxcdFxcdFxcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXHRcXHRcXHRpZiAob2JqKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5fbW9kZWwuY2hhbmdlZC5wdXNoKG9iai5pZCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFx0XFx0LyoqXFxuICAgKiBhcHBlbmRzIEhUTUwgY29udGVudCB0byB0aGUgdHJlZS4gVXNlZCBpbnRlcm5hbGx5LlxcbiAgICogQHByaXZhdGVcXG4gICAqIEBuYW1lIF9hcHBlbmRfaHRtbF9kYXRhKG9iaiwgZGF0YSlcXG4gICAqIEBwYXJhbSAge21peGVkfSBvYmogdGhlIG5vZGUgdG8gYXBwZW5kIHRvXFxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGRhdGEgdGhlIEhUTUwgc3RyaW5nIHRvIHBhcnNlIGFuZCBhcHBlbmRcXG4gICAqIEB0cmlnZ2VyIG1vZGVsLmpzdHJlZSwgY2hhbmdlZC5qc3RyZWVcXG4gICAqL1xcblxcdFxcdF9hcHBlbmRfaHRtbF9kYXRhOiBmdW5jdGlvbiBfYXBwZW5kX2h0bWxfZGF0YShkb20sIGRhdGEsIGNiKSB7XFxuXFx0XFx0XFx0ZG9tID0gdGhpcy5nZXRfbm9kZShkb20pO1xcblxcdFxcdFxcdGRvbS5jaGlsZHJlbiA9IFtdO1xcblxcdFxcdFxcdGRvbS5jaGlsZHJlbl9kID0gW107XFxuXFx0XFx0XFx0dmFyIGRhdCA9IGRhdGEuaXMoJ3VsJykgPyBkYXRhLmNoaWxkcmVuKCkgOiBkYXRhLFxcblxcdFxcdFxcdCAgICBwYXIgPSBkb20uaWQsXFxuXFx0XFx0XFx0ICAgIGNoZCA9IFtdLFxcblxcdFxcdFxcdCAgICBkcGMgPSBbXSxcXG5cXHRcXHRcXHQgICAgbSA9IHRoaXMuX21vZGVsLmRhdGEsXFxuXFx0XFx0XFx0ICAgIHAgPSBtW3Bhcl0sXFxuXFx0XFx0XFx0ICAgIHMgPSB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQubGVuZ3RoLFxcblxcdFxcdFxcdCAgICB0bXAsXFxuXFx0XFx0XFx0ICAgIGksXFxuXFx0XFx0XFx0ICAgIGo7XFxuXFx0XFx0XFx0ZGF0LmVhY2goJC5wcm94eShmdW5jdGlvbiAoaSwgdikge1xcblxcdFxcdFxcdFxcdHRtcCA9IHRoaXMuX3BhcnNlX21vZGVsX2Zyb21faHRtbCgkKHYpLCBwYXIsIHAucGFyZW50cy5jb25jYXQoKSk7XFxuXFx0XFx0XFx0XFx0aWYgKHRtcCkge1xcblxcdFxcdFxcdFxcdFxcdGNoZC5wdXNoKHRtcCk7XFxuXFx0XFx0XFx0XFx0XFx0ZHBjLnB1c2godG1wKTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAobVt0bXBdLmNoaWxkcmVuX2QubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZHBjID0gZHBjLmNvbmNhdChtW3RtcF0uY2hpbGRyZW5fZCk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LCB0aGlzKSk7XFxuXFx0XFx0XFx0cC5jaGlsZHJlbiA9IGNoZDtcXG5cXHRcXHRcXHRwLmNoaWxkcmVuX2QgPSBkcGM7XFxuXFx0XFx0XFx0Zm9yIChpID0gMCwgaiA9IHAucGFyZW50cy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRtW3AucGFyZW50c1tpXV0uY2hpbGRyZW5fZCA9IG1bcC5wYXJlbnRzW2ldXS5jaGlsZHJlbl9kLmNvbmNhdChkcGMpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHQvKipcXG4gICAgKiB0cmlnZ2VyZWQgd2hlbiBuZXcgZGF0YSBpcyBpbnNlcnRlZCB0byB0aGUgdHJlZSBtb2RlbFxcbiAgICAqIEBldmVudFxcbiAgICAqIEBuYW1lIG1vZGVsLmpzdHJlZVxcbiAgICAqIEBwYXJhbSB7QXJyYXl9IG5vZGVzIGFuIGFycmF5IG9mIG5vZGUgSURzXFxuICAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmVudCB0aGUgcGFyZW50IElEIG9mIHRoZSBub2Rlc1xcbiAgICAqL1xcblxcdFxcdFxcdHRoaXMudHJpZ2dlcignbW9kZWwnLCB7IFxcXCJub2Rlc1xcXCI6IGRwYywgJ3BhcmVudCc6IHBhciB9KTtcXG5cXHRcXHRcXHRpZiAocGFyICE9PSAkLmpzdHJlZS5yb290KSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5fbm9kZV9jaGFuZ2VkKHBhcik7XFxuXFx0XFx0XFx0XFx0dGhpcy5yZWRyYXcoKTtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpLmNoaWxkcmVuKCcuanN0cmVlLWluaXRpYWwtbm9kZScpLnJlbW92ZSgpO1xcblxcdFxcdFxcdFxcdHRoaXMucmVkcmF3KHRydWUpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAodGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLmxlbmd0aCAhPT0gcykge1xcblxcdFxcdFxcdFxcdHRoaXMudHJpZ2dlcignY2hhbmdlZCcsIHsgJ2FjdGlvbic6ICdtb2RlbCcsICdzZWxlY3RlZCc6IHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZCB9KTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0Y2IuY2FsbCh0aGlzLCB0cnVlKTtcXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogYXBwZW5kcyBKU09OIGNvbnRlbnQgdG8gdGhlIHRyZWUuIFVzZWQgaW50ZXJuYWxseS5cXG4gICAqIEBwcml2YXRlXFxuICAgKiBAbmFtZSBfYXBwZW5kX2pzb25fZGF0YShvYmosIGRhdGEpXFxuICAgKiBAcGFyYW0gIHttaXhlZH0gb2JqIHRoZSBub2RlIHRvIGFwcGVuZCB0b1xcbiAgICogQHBhcmFtICB7U3RyaW5nfSBkYXRhIHRoZSBKU09OIG9iamVjdCB0byBwYXJzZSBhbmQgYXBwZW5kXFxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBmb3JjZV9wcm9jZXNzaW5nIGludGVybmFsIHBhcmFtIC0gZG8gbm90IHNldFxcbiAgICogQHRyaWdnZXIgbW9kZWwuanN0cmVlLCBjaGFuZ2VkLmpzdHJlZVxcbiAgICovXFxuXFx0XFx0X2FwcGVuZF9qc29uX2RhdGE6IGZ1bmN0aW9uIF9hcHBlbmRfanNvbl9kYXRhKGRvbSwgZGF0YSwgY2IsIGZvcmNlX3Byb2Nlc3NpbmcpIHtcXG5cXHRcXHRcXHRpZiAodGhpcy5lbGVtZW50ID09PSBudWxsKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRkb20gPSB0aGlzLmdldF9ub2RlKGRvbSk7XFxuXFx0XFx0XFx0ZG9tLmNoaWxkcmVuID0gW107XFxuXFx0XFx0XFx0ZG9tLmNoaWxkcmVuX2QgPSBbXTtcXG5cXHRcXHRcXHQvLyAqJSRAISEhXFxuXFx0XFx0XFx0aWYgKGRhdGEuZCkge1xcblxcdFxcdFxcdFxcdGRhdGEgPSBkYXRhLmQ7XFxuXFx0XFx0XFx0XFx0aWYgKHR5cGVvZiBkYXRhID09PSBcXFwic3RyaW5nXFxcIikge1xcblxcdFxcdFxcdFxcdFxcdGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKCEkLmlzQXJyYXkoZGF0YSkpIHtcXG5cXHRcXHRcXHRcXHRkYXRhID0gW2RhdGFdO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR2YXIgdyA9IG51bGwsXFxuXFx0XFx0XFx0ICAgIGFyZ3MgPSB7XFxuXFx0XFx0XFx0XFx0J2RmJzogdGhpcy5fbW9kZWwuZGVmYXVsdF9zdGF0ZSxcXG5cXHRcXHRcXHRcXHQnZGF0JzogZGF0YSxcXG5cXHRcXHRcXHRcXHQncGFyJzogZG9tLmlkLFxcblxcdFxcdFxcdFxcdCdtJzogdGhpcy5fbW9kZWwuZGF0YSxcXG5cXHRcXHRcXHRcXHQndF9pZCc6IHRoaXMuX2lkLFxcblxcdFxcdFxcdFxcdCd0X2NudCc6IHRoaXMuX2NudCxcXG5cXHRcXHRcXHRcXHQnc2VsJzogdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkXFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHQgICAgZnVuYyA9IGZ1bmN0aW9uIGZ1bmMoZGF0YSwgdW5kZWZpbmVkKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGRhdGEuZGF0YSkge1xcblxcdFxcdFxcdFxcdFxcdGRhdGEgPSBkYXRhLmRhdGE7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHZhciBkYXQgPSBkYXRhLmRhdCxcXG5cXHRcXHRcXHRcXHQgICAgcGFyID0gZGF0YS5wYXIsXFxuXFx0XFx0XFx0XFx0ICAgIGNoZCA9IFtdLFxcblxcdFxcdFxcdFxcdCAgICBkcGMgPSBbXSxcXG5cXHRcXHRcXHRcXHQgICAgYWRkID0gW10sXFxuXFx0XFx0XFx0XFx0ICAgIGRmID0gZGF0YS5kZixcXG5cXHRcXHRcXHRcXHQgICAgdF9pZCA9IGRhdGEudF9pZCxcXG5cXHRcXHRcXHRcXHQgICAgdF9jbnQgPSBkYXRhLnRfY250LFxcblxcdFxcdFxcdFxcdCAgICBtID0gZGF0YS5tLFxcblxcdFxcdFxcdFxcdCAgICBwID0gbVtwYXJdLFxcblxcdFxcdFxcdFxcdCAgICBzZWwgPSBkYXRhLnNlbCxcXG5cXHRcXHRcXHRcXHQgICAgdG1wLFxcblxcdFxcdFxcdFxcdCAgICBpLFxcblxcdFxcdFxcdFxcdCAgICBqLFxcblxcdFxcdFxcdFxcdCAgICByc2x0LFxcblxcdFxcdFxcdFxcdCAgICBwYXJzZV9mbGF0ID0gZnVuY3Rpb24gcGFyc2VfZmxhdChkLCBwLCBwcykge1xcblxcdFxcdFxcdFxcdFxcdGlmICghcHMpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRwcyA9IFtdO1xcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cHMgPSBwcy5jb25jYXQoKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRwcy51bnNoaWZ0KHApO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR2YXIgdGlkID0gZC5pZC50b1N0cmluZygpLFxcblxcdFxcdFxcdFxcdFxcdCAgICBpLFxcblxcdFxcdFxcdFxcdFxcdCAgICBqLFxcblxcdFxcdFxcdFxcdFxcdCAgICBjLFxcblxcdFxcdFxcdFxcdFxcdCAgICBlLFxcblxcdFxcdFxcdFxcdFxcdCAgICB0bXAgPSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWQ6IHRpZCxcXG5cXHRcXHRcXHRcXHRcXHRcXHR0ZXh0OiBkLnRleHQgfHwgJycsXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWNvbjogZC5pY29uICE9PSB1bmRlZmluZWQgPyBkLmljb24gOiB0cnVlLFxcblxcdFxcdFxcdFxcdFxcdFxcdHBhcmVudDogcCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRwYXJlbnRzOiBwcyxcXG5cXHRcXHRcXHRcXHRcXHRcXHRjaGlsZHJlbjogZC5jaGlsZHJlbiB8fCBbXSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRjaGlsZHJlbl9kOiBkLmNoaWxkcmVuX2QgfHwgW10sXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZGF0YTogZC5kYXRhLFxcblxcdFxcdFxcdFxcdFxcdFxcdHN0YXRlOiB7fSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRsaV9hdHRyOiB7IGlkOiBmYWxzZSB9LFxcblxcdFxcdFxcdFxcdFxcdFxcdGFfYXR0cjogeyBocmVmOiAnIycgfSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRvcmlnaW5hbDogZmFsc2VcXG5cXHRcXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdFxcdFxcdGZvciAoaSBpbiBkZikge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChkZi5oYXNPd25Qcm9wZXJ0eShpKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRtcC5zdGF0ZVtpXSA9IGRmW2ldO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGQgJiYgZC5kYXRhICYmIGQuZGF0YS5qc3RyZWUgJiYgZC5kYXRhLmpzdHJlZS5pY29uKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dG1wLmljb24gPSBkLmRhdGEuanN0cmVlLmljb247XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmICh0bXAuaWNvbiA9PT0gdW5kZWZpbmVkIHx8IHRtcC5pY29uID09PSBudWxsIHx8IHRtcC5pY29uID09PSBcXFwiXFxcIikge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRtcC5pY29uID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGQgJiYgZC5kYXRhKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dG1wLmRhdGEgPSBkLmRhdGE7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKGQuZGF0YS5qc3RyZWUpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRmb3IgKGkgaW4gZC5kYXRhLmpzdHJlZSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChkLmRhdGEuanN0cmVlLmhhc093blByb3BlcnR5KGkpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dG1wLnN0YXRlW2ldID0gZC5kYXRhLmpzdHJlZVtpXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGQgJiYgX3R5cGVvZihkLnN0YXRlKSA9PT0gJ29iamVjdCcpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRmb3IgKGkgaW4gZC5zdGF0ZSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChkLnN0YXRlLmhhc093blByb3BlcnR5KGkpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dG1wLnN0YXRlW2ldID0gZC5zdGF0ZVtpXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRpZiAoZCAmJiBfdHlwZW9mKGQubGlfYXR0cikgPT09ICdvYmplY3QnKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Zm9yIChpIGluIGQubGlfYXR0cikge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChkLmxpX2F0dHIuaGFzT3duUHJvcGVydHkoaSkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0bXAubGlfYXR0cltpXSA9IGQubGlfYXR0cltpXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIXRtcC5saV9hdHRyLmlkKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dG1wLmxpX2F0dHIuaWQgPSB0aWQ7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmIChkICYmIF90eXBlb2YoZC5hX2F0dHIpID09PSAnb2JqZWN0Jykge1xcblxcdFxcdFxcdFxcdFxcdFxcdGZvciAoaSBpbiBkLmFfYXR0cikge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChkLmFfYXR0ci5oYXNPd25Qcm9wZXJ0eShpKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRtcC5hX2F0dHJbaV0gPSBkLmFfYXR0cltpXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRpZiAoZCAmJiBkLmNoaWxkcmVuICYmIGQuY2hpbGRyZW4gPT09IHRydWUpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0bXAuc3RhdGUubG9hZGVkID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dG1wLmNoaWxkcmVuID0gW107XFxuXFx0XFx0XFx0XFx0XFx0XFx0dG1wLmNoaWxkcmVuX2QgPSBbXTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0bVt0bXAuaWRdID0gdG1wO1xcblxcdFxcdFxcdFxcdFxcdGZvciAoaSA9IDAsIGogPSB0bXAuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YyA9IHBhcnNlX2ZsYXQobVt0bXAuY2hpbGRyZW5baV1dLCB0bXAuaWQsIHBzKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRlID0gbVtjXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0bXAuY2hpbGRyZW5fZC5wdXNoKGMpO1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChlLmNoaWxkcmVuX2QubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dG1wLmNoaWxkcmVuX2QgPSB0bXAuY2hpbGRyZW5fZC5jb25jYXQoZS5jaGlsZHJlbl9kKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGRlbGV0ZSBkLmRhdGE7XFxuXFx0XFx0XFx0XFx0XFx0ZGVsZXRlIGQuY2hpbGRyZW47XFxuXFx0XFx0XFx0XFx0XFx0bVt0bXAuaWRdLm9yaWdpbmFsID0gZDtcXG5cXHRcXHRcXHRcXHRcXHRpZiAodG1wLnN0YXRlLnNlbGVjdGVkKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YWRkLnB1c2godG1wLmlkKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRtcC5pZDtcXG5cXHRcXHRcXHRcXHR9LFxcblxcdFxcdFxcdFxcdCAgICBwYXJzZV9uZXN0ID0gZnVuY3Rpb24gcGFyc2VfbmVzdChkLCBwLCBwcykge1xcblxcdFxcdFxcdFxcdFxcdGlmICghcHMpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRwcyA9IFtdO1xcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cHMgPSBwcy5jb25jYXQoKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRwcy51bnNoaWZ0KHApO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR2YXIgdGlkID0gZmFsc2UsXFxuXFx0XFx0XFx0XFx0XFx0ICAgIGksXFxuXFx0XFx0XFx0XFx0XFx0ICAgIGosXFxuXFx0XFx0XFx0XFx0XFx0ICAgIGMsXFxuXFx0XFx0XFx0XFx0XFx0ICAgIGUsXFxuXFx0XFx0XFx0XFx0XFx0ICAgIHRtcDtcXG5cXHRcXHRcXHRcXHRcXHRkbyB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGlkID0gJ2onICsgdF9pZCArICdfJyArICsrdF9jbnQ7XFxuXFx0XFx0XFx0XFx0XFx0fSB3aGlsZSAobVt0aWRdKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0bXAgPSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWQ6IGZhbHNlLFxcblxcdFxcdFxcdFxcdFxcdFxcdHRleHQ6IHR5cGVvZiBkID09PSAnc3RyaW5nJyA/IGQgOiAnJyxcXG5cXHRcXHRcXHRcXHRcXHRcXHRpY29uOiAodHlwZW9mIGQgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGQpKSA9PT0gJ29iamVjdCcgJiYgZC5pY29uICE9PSB1bmRlZmluZWQgPyBkLmljb24gOiB0cnVlLFxcblxcdFxcdFxcdFxcdFxcdFxcdHBhcmVudDogcCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRwYXJlbnRzOiBwcyxcXG5cXHRcXHRcXHRcXHRcXHRcXHRjaGlsZHJlbjogW10sXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2hpbGRyZW5fZDogW10sXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZGF0YTogbnVsbCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRzdGF0ZToge30sXFxuXFx0XFx0XFx0XFx0XFx0XFx0bGlfYXR0cjogeyBpZDogZmFsc2UgfSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRhX2F0dHI6IHsgaHJlZjogJyMnIH0sXFxuXFx0XFx0XFx0XFx0XFx0XFx0b3JpZ2luYWw6IGZhbHNlXFxuXFx0XFx0XFx0XFx0XFx0fTtcXG5cXHRcXHRcXHRcXHRcXHRmb3IgKGkgaW4gZGYpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoZGYuaGFzT3duUHJvcGVydHkoaSkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0bXAuc3RhdGVbaV0gPSBkZltpXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmIChkICYmIGQuaWQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0bXAuaWQgPSBkLmlkLnRvU3RyaW5nKCk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmIChkICYmIGQudGV4dCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRtcC50ZXh0ID0gZC50ZXh0O1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRpZiAoZCAmJiBkLmRhdGEgJiYgZC5kYXRhLmpzdHJlZSAmJiBkLmRhdGEuanN0cmVlLmljb24pIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0bXAuaWNvbiA9IGQuZGF0YS5qc3RyZWUuaWNvbjtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHRtcC5pY29uID09PSB1bmRlZmluZWQgfHwgdG1wLmljb24gPT09IG51bGwgfHwgdG1wLmljb24gPT09IFxcXCJcXFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dG1wLmljb24gPSB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRpZiAoZCAmJiBkLmRhdGEpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0bXAuZGF0YSA9IGQuZGF0YTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoZC5kYXRhLmpzdHJlZSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGZvciAoaSBpbiBkLmRhdGEuanN0cmVlKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKGQuZGF0YS5qc3RyZWUuaGFzT3duUHJvcGVydHkoaSkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0bXAuc3RhdGVbaV0gPSBkLmRhdGEuanN0cmVlW2ldO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRpZiAoZCAmJiBfdHlwZW9mKGQuc3RhdGUpID09PSAnb2JqZWN0Jykge1xcblxcdFxcdFxcdFxcdFxcdFxcdGZvciAoaSBpbiBkLnN0YXRlKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKGQuc3RhdGUuaGFzT3duUHJvcGVydHkoaSkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0bXAuc3RhdGVbaV0gPSBkLnN0YXRlW2ldO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmIChkICYmIF90eXBlb2YoZC5saV9hdHRyKSA9PT0gJ29iamVjdCcpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRmb3IgKGkgaW4gZC5saV9hdHRyKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKGQubGlfYXR0ci5oYXNPd25Qcm9wZXJ0eShpKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRtcC5saV9hdHRyW2ldID0gZC5saV9hdHRyW2ldO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmICh0bXAubGlfYXR0ci5pZCAmJiAhdG1wLmlkKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dG1wLmlkID0gdG1wLmxpX2F0dHIuaWQudG9TdHJpbmcoKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCF0bXAuaWQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0bXAuaWQgPSB0aWQ7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmICghdG1wLmxpX2F0dHIuaWQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0bXAubGlfYXR0ci5pZCA9IHRtcC5pZDtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGQgJiYgX3R5cGVvZihkLmFfYXR0cikgPT09ICdvYmplY3QnKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Zm9yIChpIGluIGQuYV9hdHRyKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKGQuYV9hdHRyLmhhc093blByb3BlcnR5KGkpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dG1wLmFfYXR0cltpXSA9IGQuYV9hdHRyW2ldO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmIChkICYmIGQuY2hpbGRyZW4gJiYgZC5jaGlsZHJlbi5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRmb3IgKGkgPSAwLCBqID0gZC5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjID0gcGFyc2VfbmVzdChkLmNoaWxkcmVuW2ldLCB0bXAuaWQsIHBzKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRlID0gbVtjXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0bXAuY2hpbGRyZW4ucHVzaChjKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoZS5jaGlsZHJlbl9kLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRtcC5jaGlsZHJlbl9kID0gdG1wLmNoaWxkcmVuX2QuY29uY2F0KGUuY2hpbGRyZW5fZCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR0bXAuY2hpbGRyZW5fZCA9IHRtcC5jaGlsZHJlbl9kLmNvbmNhdCh0bXAuY2hpbGRyZW4pO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRpZiAoZCAmJiBkLmNoaWxkcmVuICYmIGQuY2hpbGRyZW4gPT09IHRydWUpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0bXAuc3RhdGUubG9hZGVkID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dG1wLmNoaWxkcmVuID0gW107XFxuXFx0XFx0XFx0XFx0XFx0XFx0dG1wLmNoaWxkcmVuX2QgPSBbXTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0ZGVsZXRlIGQuZGF0YTtcXG5cXHRcXHRcXHRcXHRcXHRkZWxldGUgZC5jaGlsZHJlbjtcXG5cXHRcXHRcXHRcXHRcXHR0bXAub3JpZ2luYWwgPSBkO1xcblxcdFxcdFxcdFxcdFxcdG1bdG1wLmlkXSA9IHRtcDtcXG5cXHRcXHRcXHRcXHRcXHRpZiAodG1wLnN0YXRlLnNlbGVjdGVkKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YWRkLnB1c2godG1wLmlkKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRtcC5pZDtcXG5cXHRcXHRcXHRcXHR9O1xcblxcblxcdFxcdFxcdFxcdGlmIChkYXQubGVuZ3RoICYmIGRhdFswXS5pZCAhPT0gdW5kZWZpbmVkICYmIGRhdFswXS5wYXJlbnQgIT09IHVuZGVmaW5lZCkge1xcblxcdFxcdFxcdFxcdFxcdC8vIEZsYXQgSlNPTiBzdXBwb3J0IChmb3IgZWFzeSBpbXBvcnQgZnJvbSBEQik6XFxuXFx0XFx0XFx0XFx0XFx0Ly8gMSkgY29udmVydCB0byBvYmplY3QgKGZvcmVhY2gpXFxuXFx0XFx0XFx0XFx0XFx0Zm9yIChpID0gMCwgaiA9IGRhdC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIWRhdFtpXS5jaGlsZHJlbikge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdFtpXS5jaGlsZHJlbiA9IFtdO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRtW2RhdFtpXS5pZC50b1N0cmluZygpXSA9IGRhdFtpXTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0Ly8gMikgcG9wdWxhdGUgY2hpbGRyZW4gKGZvcmVhY2gpXFxuXFx0XFx0XFx0XFx0XFx0Zm9yIChpID0gMCwgaiA9IGRhdC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRtW2RhdFtpXS5wYXJlbnQudG9TdHJpbmcoKV0uY2hpbGRyZW4ucHVzaChkYXRbaV0uaWQudG9TdHJpbmcoKSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gcG9wdWxhdGUgcGFyZW50LmNoaWxkcmVuX2RcXG5cXHRcXHRcXHRcXHRcXHRcXHRwLmNoaWxkcmVuX2QucHVzaChkYXRbaV0uaWQudG9TdHJpbmcoKSk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdC8vIDMpIG5vcm1hbGl6ZSAmJiBwb3B1bGF0ZSBwYXJlbnRzIGFuZCBjaGlsZHJlbl9kIHdpdGggcmVjdXJzaW9uXFxuXFx0XFx0XFx0XFx0XFx0Zm9yIChpID0gMCwgaiA9IHAuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dG1wID0gcGFyc2VfZmxhdChtW3AuY2hpbGRyZW5baV1dLCBwYXIsIHAucGFyZW50cy5jb25jYXQoKSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZHBjLnB1c2godG1wKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAobVt0bXBdLmNoaWxkcmVuX2QubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZHBjID0gZHBjLmNvbmNhdChtW3RtcF0uY2hpbGRyZW5fZCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRmb3IgKGkgPSAwLCBqID0gcC5wYXJlbnRzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdFxcdG1bcC5wYXJlbnRzW2ldXS5jaGlsZHJlbl9kID0gbVtwLnBhcmVudHNbaV1dLmNoaWxkcmVuX2QuY29uY2F0KGRwYyk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdC8vID8pIHRocmVlX3N0YXRlIHNlbGVjdGlvbiAtIHAuc3RhdGUuc2VsZWN0ZWQgJiYgdCAtIChpZiB0aHJlZV9zdGF0ZSBmb3JlYWNoKGRhdCA9PiBjaCkgLT4gZm9yZWFjaChwYXJlbnRzKSBpZihwYXJlbnQuc2VsZWN0ZWQpIGNoaWxkLnNlbGVjdGVkID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHRyc2x0ID0ge1xcblxcdFxcdFxcdFxcdFxcdFxcdCdjbnQnOiB0X2NudCxcXG5cXHRcXHRcXHRcXHRcXHRcXHQnbW9kJzogbSxcXG5cXHRcXHRcXHRcXHRcXHRcXHQnc2VsJzogc2VsLFxcblxcdFxcdFxcdFxcdFxcdFxcdCdwYXInOiBwYXIsXFxuXFx0XFx0XFx0XFx0XFx0XFx0J2RwYyc6IGRwYyxcXG5cXHRcXHRcXHRcXHRcXHRcXHQnYWRkJzogYWRkXFxuXFx0XFx0XFx0XFx0XFx0fTtcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdGZvciAoaSA9IDAsIGogPSBkYXQubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dG1wID0gcGFyc2VfbmVzdChkYXRbaV0sIHBhciwgcC5wYXJlbnRzLmNvbmNhdCgpKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAodG1wKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y2hkLnB1c2godG1wKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRkcGMucHVzaCh0bXApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChtW3RtcF0uY2hpbGRyZW5fZC5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkcGMgPSBkcGMuY29uY2F0KG1bdG1wXS5jaGlsZHJlbl9kKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRwLmNoaWxkcmVuID0gY2hkO1xcblxcdFxcdFxcdFxcdFxcdHAuY2hpbGRyZW5fZCA9IGRwYztcXG5cXHRcXHRcXHRcXHRcXHRmb3IgKGkgPSAwLCBqID0gcC5wYXJlbnRzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdFxcdG1bcC5wYXJlbnRzW2ldXS5jaGlsZHJlbl9kID0gbVtwLnBhcmVudHNbaV1dLmNoaWxkcmVuX2QuY29uY2F0KGRwYyk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdHJzbHQgPSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0J2NudCc6IHRfY250LFxcblxcdFxcdFxcdFxcdFxcdFxcdCdtb2QnOiBtLFxcblxcdFxcdFxcdFxcdFxcdFxcdCdzZWwnOiBzZWwsXFxuXFx0XFx0XFx0XFx0XFx0XFx0J3Bhcic6IHBhcixcXG5cXHRcXHRcXHRcXHRcXHRcXHQnZHBjJzogZHBjLFxcblxcdFxcdFxcdFxcdFxcdFxcdCdhZGQnOiBhZGRcXG5cXHRcXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcXG5cXHRcXHRcXHRcXHRcXHRwb3N0TWVzc2FnZShyc2x0KTtcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiByc2x0O1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdCAgICByc2x0ID0gZnVuY3Rpb24gcnNsdChfcnNsdCwgd29ya2VyKSB7XFxuXFx0XFx0XFx0XFx0aWYgKHRoaXMuZWxlbWVudCA9PT0gbnVsbCkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0dGhpcy5fY250ID0gX3JzbHQuY250O1xcblxcdFxcdFxcdFxcdHZhciBpLFxcblxcdFxcdFxcdFxcdCAgICBtID0gdGhpcy5fbW9kZWwuZGF0YTtcXG5cXHRcXHRcXHRcXHRmb3IgKGkgaW4gbSkge1xcblxcdFxcdFxcdFxcdFxcdGlmIChtLmhhc093blByb3BlcnR5KGkpICYmIG1baV0uc3RhdGUgJiYgbVtpXS5zdGF0ZS5sb2FkaW5nICYmIF9yc2x0Lm1vZFtpXSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdF9yc2x0Lm1vZFtpXS5zdGF0ZS5sb2FkaW5nID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHRoaXMuX21vZGVsLmRhdGEgPSBfcnNsdC5tb2Q7IC8vIGJyZWFrcyB0aGUgcmVmZXJlbmNlIGluIGxvYWRfbm9kZSAtIGNhcmVmdWxcXG5cXG5cXHRcXHRcXHRcXHRpZiAod29ya2VyKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGosXFxuXFx0XFx0XFx0XFx0XFx0ICAgIGEgPSBfcnNsdC5hZGQsXFxuXFx0XFx0XFx0XFx0XFx0ICAgIHIgPSBfcnNsdC5zZWwsXFxuXFx0XFx0XFx0XFx0XFx0ICAgIHMgPSB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQuc2xpY2UoKTtcXG5cXHRcXHRcXHRcXHRcXHRtID0gdGhpcy5fbW9kZWwuZGF0YTtcXG5cXHRcXHRcXHRcXHRcXHQvLyBpZiBzZWxlY3Rpb24gd2FzIGNoYW5nZWQgd2hpbGUgY2FsY3VsYXRpbmcgaW4gd29ya2VyXFxuXFx0XFx0XFx0XFx0XFx0aWYgKHIubGVuZ3RoICE9PSBzLmxlbmd0aCB8fCAkLnZha2F0YS5hcnJheV91bmlxdWUoci5jb25jYXQocykpLmxlbmd0aCAhPT0gci5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBkZXNlbGVjdCBub2RlcyB0aGF0IGFyZSBubyBsb25nZXIgc2VsZWN0ZWRcXG5cXHRcXHRcXHRcXHRcXHRcXHRmb3IgKGkgPSAwLCBqID0gci5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoJC5pbkFycmF5KHJbaV0sIGEpID09PSAtMSAmJiAkLmluQXJyYXkocltpXSwgcykgPT09IC0xKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bVtyW2ldXS5zdGF0ZS5zZWxlY3RlZCA9IGZhbHNlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gc2VsZWN0IG5vZGVzIHRoYXQgd2VyZSBzZWxlY3RlZCBpbiB0aGUgbWVhbiB0aW1lXFxuXFx0XFx0XFx0XFx0XFx0XFx0Zm9yIChpID0gMCwgaiA9IHMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCQuaW5BcnJheShzW2ldLCByKSA9PT0gLTEpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRtW3NbaV1dLnN0YXRlLnNlbGVjdGVkID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aWYgKF9yc2x0LmFkZC5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQgPSB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQuY29uY2F0KF9yc2x0LmFkZCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHRoaXMudHJpZ2dlcignbW9kZWwnLCB7IFxcXCJub2Rlc1xcXCI6IF9yc2x0LmRwYywgJ3BhcmVudCc6IF9yc2x0LnBhciB9KTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoX3JzbHQucGFyICE9PSAkLmpzdHJlZS5yb290KSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fbm9kZV9jaGFuZ2VkKF9yc2x0LnBhcik7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5yZWRyYXcoKTtcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdC8vIHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpLmNoaWxkcmVuKCcuanN0cmVlLWluaXRpYWwtbm9kZScpLnJlbW92ZSgpO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMucmVkcmF3KHRydWUpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRpZiAoX3JzbHQuYWRkLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMudHJpZ2dlcignY2hhbmdlZCcsIHsgJ2FjdGlvbic6ICdtb2RlbCcsICdzZWxlY3RlZCc6IHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZCB9KTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0Y2IuY2FsbCh0aGlzLCB0cnVlKTtcXG5cXHRcXHRcXHR9O1xcblxcdFxcdFxcdGlmICh0aGlzLnNldHRpbmdzLmNvcmUud29ya2VyICYmIHdpbmRvdy5CbG9iICYmIHdpbmRvdy5VUkwgJiYgd2luZG93Lldvcmtlcikge1xcblxcdFxcdFxcdFxcdHRyeSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHRoaXMuX3dyayA9PT0gbnVsbCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuX3dyayA9IHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyB3aW5kb3cuQmxvYihbJ3NlbGYub25tZXNzYWdlID0gJyArIGZ1bmMudG9TdHJpbmcoKV0sIHsgdHlwZTogXFxcInRleHQvamF2YXNjcmlwdFxcXCIgfSkpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIXRoaXMuX2RhdGEuY29yZS53b3JraW5nIHx8IGZvcmNlX3Byb2Nlc3NpbmcpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl9kYXRhLmNvcmUud29ya2luZyA9IHRydWU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dyA9IG5ldyB3aW5kb3cuV29ya2VyKHRoaXMuX3dyayk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dy5vbm1lc3NhZ2UgPSAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cnNsdC5jYWxsKHRoaXMsIGUuZGF0YSwgdHJ1ZSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dHJ5IHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR3LnRlcm1pbmF0ZSgpO3cgPSBudWxsO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gY2F0Y2ggKGlnbm9yZSkge31cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAodGhpcy5fZGF0YS5jb3JlLndvcmtlcl9xdWV1ZS5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl9hcHBlbmRfanNvbl9kYXRhLmFwcGx5KHRoaXMsIHRoaXMuX2RhdGEuY29yZS53b3JrZXJfcXVldWUuc2hpZnQoKSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl9kYXRhLmNvcmUud29ya2luZyA9IGZhbHNlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9LCB0aGlzKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIWFyZ3MucGFyKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKHRoaXMuX2RhdGEuY29yZS53b3JrZXJfcXVldWUubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5fYXBwZW5kX2pzb25fZGF0YS5hcHBseSh0aGlzLCB0aGlzLl9kYXRhLmNvcmUud29ya2VyX3F1ZXVlLnNoaWZ0KCkpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5fZGF0YS5jb3JlLndvcmtpbmcgPSBmYWxzZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR3LnBvc3RNZXNzYWdlKGFyZ3MpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuX2RhdGEuY29yZS53b3JrZXJfcXVldWUucHVzaChbZG9tLCBkYXRhLCBjYiwgdHJ1ZV0pO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9IGNhdGNoIChlKSB7XFxuXFx0XFx0XFx0XFx0XFx0cnNsdC5jYWxsKHRoaXMsIGZ1bmMoYXJncyksIGZhbHNlKTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAodGhpcy5fZGF0YS5jb3JlLndvcmtlcl9xdWV1ZS5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl9hcHBlbmRfanNvbl9kYXRhLmFwcGx5KHRoaXMsIHRoaXMuX2RhdGEuY29yZS53b3JrZXJfcXVldWUuc2hpZnQoKSk7XFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl9kYXRhLmNvcmUud29ya2luZyA9IGZhbHNlO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRyc2x0LmNhbGwodGhpcywgZnVuYyhhcmdzKSwgZmFsc2UpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogcGFyc2VzIGEgbm9kZSBmcm9tIGEgalF1ZXJ5IG9iamVjdCBhbmQgYXBwZW5kcyB0aGVtIHRvIHRoZSBpbiBtZW1vcnkgdHJlZSBtb2RlbC4gVXNlZCBpbnRlcm5hbGx5LlxcbiAgICogQHByaXZhdGVcXG4gICAqIEBuYW1lIF9wYXJzZV9tb2RlbF9mcm9tX2h0bWwoZCBbLCBwLCBwc10pXFxuICAgKiBAcGFyYW0gIHtqUXVlcnl9IGQgdGhlIGpRdWVyeSBvYmplY3QgdG8gcGFyc2VcXG4gICAqIEBwYXJhbSAge1N0cmluZ30gcCB0aGUgcGFyZW50IElEXFxuICAgKiBAcGFyYW0gIHtBcnJheX0gcHMgbGlzdCBvZiBhbGwgcGFyZW50c1xcbiAgICogQHJldHVybiB7U3RyaW5nfSB0aGUgSUQgb2YgdGhlIG9iamVjdCBhZGRlZCB0byB0aGUgbW9kZWxcXG4gICAqL1xcblxcdFxcdF9wYXJzZV9tb2RlbF9mcm9tX2h0bWw6IGZ1bmN0aW9uIF9wYXJzZV9tb2RlbF9mcm9tX2h0bWwoZCwgcCwgcHMpIHtcXG5cXHRcXHRcXHRpZiAoIXBzKSB7XFxuXFx0XFx0XFx0XFx0cHMgPSBbXTtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdHBzID0gW10uY29uY2F0KHBzKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKHApIHtcXG5cXHRcXHRcXHRcXHRwcy51bnNoaWZ0KHApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR2YXIgYyxcXG5cXHRcXHRcXHQgICAgZSxcXG5cXHRcXHRcXHQgICAgbSA9IHRoaXMuX21vZGVsLmRhdGEsXFxuXFx0XFx0XFx0ICAgIGRhdGEgPSB7XFxuXFx0XFx0XFx0XFx0aWQ6IGZhbHNlLFxcblxcdFxcdFxcdFxcdHRleHQ6IGZhbHNlLFxcblxcdFxcdFxcdFxcdGljb246IHRydWUsXFxuXFx0XFx0XFx0XFx0cGFyZW50OiBwLFxcblxcdFxcdFxcdFxcdHBhcmVudHM6IHBzLFxcblxcdFxcdFxcdFxcdGNoaWxkcmVuOiBbXSxcXG5cXHRcXHRcXHRcXHRjaGlsZHJlbl9kOiBbXSxcXG5cXHRcXHRcXHRcXHRkYXRhOiBudWxsLFxcblxcdFxcdFxcdFxcdHN0YXRlOiB7fSxcXG5cXHRcXHRcXHRcXHRsaV9hdHRyOiB7IGlkOiBmYWxzZSB9LFxcblxcdFxcdFxcdFxcdGFfYXR0cjogeyBocmVmOiAnIycgfSxcXG5cXHRcXHRcXHRcXHRvcmlnaW5hbDogZmFsc2VcXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdCAgICBpLFxcblxcdFxcdFxcdCAgICB0bXAsXFxuXFx0XFx0XFx0ICAgIHRpZDtcXG5cXHRcXHRcXHRmb3IgKGkgaW4gdGhpcy5fbW9kZWwuZGVmYXVsdF9zdGF0ZSkge1xcblxcdFxcdFxcdFxcdGlmICh0aGlzLl9tb2RlbC5kZWZhdWx0X3N0YXRlLmhhc093blByb3BlcnR5KGkpKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZGF0YS5zdGF0ZVtpXSA9IHRoaXMuX21vZGVsLmRlZmF1bHRfc3RhdGVbaV07XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR0bXAgPSAkLnZha2F0YS5hdHRyaWJ1dGVzKGQsIHRydWUpO1xcblxcdFxcdFxcdCQuZWFjaCh0bXAsIGZ1bmN0aW9uIChpLCB2KSB7XFxuXFx0XFx0XFx0XFx0diA9ICQudHJpbSh2KTtcXG5cXHRcXHRcXHRcXHRpZiAoIXYubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGRhdGEubGlfYXR0cltpXSA9IHY7XFxuXFx0XFx0XFx0XFx0aWYgKGkgPT09ICdpZCcpIHtcXG5cXHRcXHRcXHRcXHRcXHRkYXRhLmlkID0gdi50b1N0cmluZygpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHR0bXAgPSBkLmNoaWxkcmVuKCdhJykuZmlyc3QoKTtcXG5cXHRcXHRcXHRpZiAodG1wLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdHRtcCA9ICQudmFrYXRhLmF0dHJpYnV0ZXModG1wLCB0cnVlKTtcXG5cXHRcXHRcXHRcXHQkLmVhY2godG1wLCBmdW5jdGlvbiAoaSwgdikge1xcblxcdFxcdFxcdFxcdFxcdHYgPSAkLnRyaW0odik7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHYubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS5hX2F0dHJbaV0gPSB2O1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0dG1wID0gZC5jaGlsZHJlbihcXFwiYVxcXCIpLmZpcnN0KCkubGVuZ3RoID8gZC5jaGlsZHJlbihcXFwiYVxcXCIpLmZpcnN0KCkuY2xvbmUoKSA6IGQuY2xvbmUoKTtcXG5cXHRcXHRcXHR0bXAuY2hpbGRyZW4oXFxcImlucywgaSwgdWxcXFwiKS5yZW1vdmUoKTtcXG5cXHRcXHRcXHR0bXAgPSB0bXAuaHRtbCgpO1xcblxcdFxcdFxcdHRtcCA9ICQoJzxkaXYgLz4nKS5odG1sKHRtcCk7XFxuXFx0XFx0XFx0ZGF0YS50ZXh0ID0gdGhpcy5zZXR0aW5ncy5jb3JlLmZvcmNlX3RleHQgPyB0bXAudGV4dCgpIDogdG1wLmh0bWwoKTtcXG5cXHRcXHRcXHR0bXAgPSBkLmRhdGEoKTtcXG5cXHRcXHRcXHRkYXRhLmRhdGEgPSB0bXAgPyAkLmV4dGVuZCh0cnVlLCB7fSwgdG1wKSA6IG51bGw7XFxuXFx0XFx0XFx0ZGF0YS5zdGF0ZS5vcGVuZWQgPSBkLmhhc0NsYXNzKCdqc3RyZWUtb3BlbicpO1xcblxcdFxcdFxcdGRhdGEuc3RhdGUuc2VsZWN0ZWQgPSBkLmNoaWxkcmVuKCdhJykuaGFzQ2xhc3MoJ2pzdHJlZS1jbGlja2VkJyk7XFxuXFx0XFx0XFx0ZGF0YS5zdGF0ZS5kaXNhYmxlZCA9IGQuY2hpbGRyZW4oJ2EnKS5oYXNDbGFzcygnanN0cmVlLWRpc2FibGVkJyk7XFxuXFx0XFx0XFx0aWYgKGRhdGEuZGF0YSAmJiBkYXRhLmRhdGEuanN0cmVlKSB7XFxuXFx0XFx0XFx0XFx0Zm9yIChpIGluIGRhdGEuZGF0YS5qc3RyZWUpIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoZGF0YS5kYXRhLmpzdHJlZS5oYXNPd25Qcm9wZXJ0eShpKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGRhdGEuc3RhdGVbaV0gPSBkYXRhLmRhdGEuanN0cmVlW2ldO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHRtcCA9IGQuY2hpbGRyZW4oXFxcImFcXFwiKS5jaGlsZHJlbihcXFwiLmpzdHJlZS10aGVtZWljb25cXFwiKTtcXG5cXHRcXHRcXHRpZiAodG1wLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdGRhdGEuaWNvbiA9IHRtcC5oYXNDbGFzcygnanN0cmVlLXRoZW1laWNvbi1oaWRkZW4nKSA/IGZhbHNlIDogdG1wLmF0dHIoJ3JlbCcpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoZGF0YS5zdGF0ZS5pY29uICE9PSB1bmRlZmluZWQpIHtcXG5cXHRcXHRcXHRcXHRkYXRhLmljb24gPSBkYXRhLnN0YXRlLmljb247XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmIChkYXRhLmljb24gPT09IHVuZGVmaW5lZCB8fCBkYXRhLmljb24gPT09IG51bGwgfHwgZGF0YS5pY29uID09PSBcXFwiXFxcIikge1xcblxcdFxcdFxcdFxcdGRhdGEuaWNvbiA9IHRydWU7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHRtcCA9IGQuY2hpbGRyZW4oXFxcInVsXFxcIikuY2hpbGRyZW4oXFxcImxpXFxcIik7XFxuXFx0XFx0XFx0ZG8ge1xcblxcdFxcdFxcdFxcdHRpZCA9ICdqJyArIHRoaXMuX2lkICsgJ18nICsgKyt0aGlzLl9jbnQ7XFxuXFx0XFx0XFx0fSB3aGlsZSAobVt0aWRdKTtcXG5cXHRcXHRcXHRkYXRhLmlkID0gZGF0YS5saV9hdHRyLmlkID8gZGF0YS5saV9hdHRyLmlkLnRvU3RyaW5nKCkgOiB0aWQ7XFxuXFx0XFx0XFx0aWYgKHRtcC5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHR0bXAuZWFjaCgkLnByb3h5KGZ1bmN0aW9uIChpLCB2KSB7XFxuXFx0XFx0XFx0XFx0XFx0YyA9IHRoaXMuX3BhcnNlX21vZGVsX2Zyb21faHRtbCgkKHYpLCBkYXRhLmlkLCBwcyk7XFxuXFx0XFx0XFx0XFx0XFx0ZSA9IHRoaXMuX21vZGVsLmRhdGFbY107XFxuXFx0XFx0XFx0XFx0XFx0ZGF0YS5jaGlsZHJlbi5wdXNoKGMpO1xcblxcdFxcdFxcdFxcdFxcdGlmIChlLmNoaWxkcmVuX2QubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS5jaGlsZHJlbl9kID0gZGF0YS5jaGlsZHJlbl9kLmNvbmNhdChlLmNoaWxkcmVuX2QpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9LCB0aGlzKSk7XFxuXFx0XFx0XFx0XFx0ZGF0YS5jaGlsZHJlbl9kID0gZGF0YS5jaGlsZHJlbl9kLmNvbmNhdChkYXRhLmNoaWxkcmVuKTtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdGlmIChkLmhhc0NsYXNzKCdqc3RyZWUtY2xvc2VkJykpIHtcXG5cXHRcXHRcXHRcXHRcXHRkYXRhLnN0YXRlLmxvYWRlZCA9IGZhbHNlO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKGRhdGEubGlfYXR0clsnY2xhc3MnXSkge1xcblxcdFxcdFxcdFxcdGRhdGEubGlfYXR0clsnY2xhc3MnXSA9IGRhdGEubGlfYXR0clsnY2xhc3MnXS5yZXBsYWNlKCdqc3RyZWUtY2xvc2VkJywgJycpLnJlcGxhY2UoJ2pzdHJlZS1vcGVuJywgJycpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoZGF0YS5hX2F0dHJbJ2NsYXNzJ10pIHtcXG5cXHRcXHRcXHRcXHRkYXRhLmFfYXR0clsnY2xhc3MnXSA9IGRhdGEuYV9hdHRyWydjbGFzcyddLnJlcGxhY2UoJ2pzdHJlZS1jbGlja2VkJywgJycpLnJlcGxhY2UoJ2pzdHJlZS1kaXNhYmxlZCcsICcnKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0bVtkYXRhLmlkXSA9IGRhdGE7XFxuXFx0XFx0XFx0aWYgKGRhdGEuc3RhdGUuc2VsZWN0ZWQpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQucHVzaChkYXRhLmlkKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIGRhdGEuaWQ7XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIHBhcnNlcyBhIG5vZGUgZnJvbSBhIEpTT04gb2JqZWN0ICh1c2VkIHdoZW4gZGVhbGluZyB3aXRoIGZsYXQgZGF0YSwgd2hpY2ggaGFzIG5vIG5lc3Rpbmcgb2YgY2hpbGRyZW4sIGJ1dCBoYXMgaWQgYW5kIHBhcmVudCBwcm9wZXJ0aWVzKSBhbmQgYXBwZW5kcyBpdCB0byB0aGUgaW4gbWVtb3J5IHRyZWUgbW9kZWwuIFVzZWQgaW50ZXJuYWxseS5cXG4gICAqIEBwcml2YXRlXFxuICAgKiBAbmFtZSBfcGFyc2VfbW9kZWxfZnJvbV9mbGF0X2pzb24oZCBbLCBwLCBwc10pXFxuICAgKiBAcGFyYW0gIHtPYmplY3R9IGQgdGhlIEpTT04gb2JqZWN0IHRvIHBhcnNlXFxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHAgdGhlIHBhcmVudCBJRFxcbiAgICogQHBhcmFtICB7QXJyYXl9IHBzIGxpc3Qgb2YgYWxsIHBhcmVudHNcXG4gICAqIEByZXR1cm4ge1N0cmluZ30gdGhlIElEIG9mIHRoZSBvYmplY3QgYWRkZWQgdG8gdGhlIG1vZGVsXFxuICAgKi9cXG5cXHRcXHRfcGFyc2VfbW9kZWxfZnJvbV9mbGF0X2pzb246IGZ1bmN0aW9uIF9wYXJzZV9tb2RlbF9mcm9tX2ZsYXRfanNvbihkLCBwLCBwcykge1xcblxcdFxcdFxcdGlmICghcHMpIHtcXG5cXHRcXHRcXHRcXHRwcyA9IFtdO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0cHMgPSBwcy5jb25jYXQoKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKHApIHtcXG5cXHRcXHRcXHRcXHRwcy51bnNoaWZ0KHApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR2YXIgdGlkID0gZC5pZC50b1N0cmluZygpLFxcblxcdFxcdFxcdCAgICBtID0gdGhpcy5fbW9kZWwuZGF0YSxcXG5cXHRcXHRcXHQgICAgZGYgPSB0aGlzLl9tb2RlbC5kZWZhdWx0X3N0YXRlLFxcblxcdFxcdFxcdCAgICBpLFxcblxcdFxcdFxcdCAgICBqLFxcblxcdFxcdFxcdCAgICBjLFxcblxcdFxcdFxcdCAgICBlLFxcblxcdFxcdFxcdCAgICB0bXAgPSB7XFxuXFx0XFx0XFx0XFx0aWQ6IHRpZCxcXG5cXHRcXHRcXHRcXHR0ZXh0OiBkLnRleHQgfHwgJycsXFxuXFx0XFx0XFx0XFx0aWNvbjogZC5pY29uICE9PSB1bmRlZmluZWQgPyBkLmljb24gOiB0cnVlLFxcblxcdFxcdFxcdFxcdHBhcmVudDogcCxcXG5cXHRcXHRcXHRcXHRwYXJlbnRzOiBwcyxcXG5cXHRcXHRcXHRcXHRjaGlsZHJlbjogZC5jaGlsZHJlbiB8fCBbXSxcXG5cXHRcXHRcXHRcXHRjaGlsZHJlbl9kOiBkLmNoaWxkcmVuX2QgfHwgW10sXFxuXFx0XFx0XFx0XFx0ZGF0YTogZC5kYXRhLFxcblxcdFxcdFxcdFxcdHN0YXRlOiB7fSxcXG5cXHRcXHRcXHRcXHRsaV9hdHRyOiB7IGlkOiBmYWxzZSB9LFxcblxcdFxcdFxcdFxcdGFfYXR0cjogeyBocmVmOiAnIycgfSxcXG5cXHRcXHRcXHRcXHRvcmlnaW5hbDogZmFsc2VcXG5cXHRcXHRcXHR9O1xcblxcdFxcdFxcdGZvciAoaSBpbiBkZikge1xcblxcdFxcdFxcdFxcdGlmIChkZi5oYXNPd25Qcm9wZXJ0eShpKSkge1xcblxcdFxcdFxcdFxcdFxcdHRtcC5zdGF0ZVtpXSA9IGRmW2ldO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKGQgJiYgZC5kYXRhICYmIGQuZGF0YS5qc3RyZWUgJiYgZC5kYXRhLmpzdHJlZS5pY29uKSB7XFxuXFx0XFx0XFx0XFx0dG1wLmljb24gPSBkLmRhdGEuanN0cmVlLmljb247XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICh0bXAuaWNvbiA9PT0gdW5kZWZpbmVkIHx8IHRtcC5pY29uID09PSBudWxsIHx8IHRtcC5pY29uID09PSBcXFwiXFxcIikge1xcblxcdFxcdFxcdFxcdHRtcC5pY29uID0gdHJ1ZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKGQgJiYgZC5kYXRhKSB7XFxuXFx0XFx0XFx0XFx0dG1wLmRhdGEgPSBkLmRhdGE7XFxuXFx0XFx0XFx0XFx0aWYgKGQuZGF0YS5qc3RyZWUpIHtcXG5cXHRcXHRcXHRcXHRcXHRmb3IgKGkgaW4gZC5kYXRhLmpzdHJlZSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChkLmRhdGEuanN0cmVlLmhhc093blByb3BlcnR5KGkpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dG1wLnN0YXRlW2ldID0gZC5kYXRhLmpzdHJlZVtpXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKGQgJiYgX3R5cGVvZihkLnN0YXRlKSA9PT0gJ29iamVjdCcpIHtcXG5cXHRcXHRcXHRcXHRmb3IgKGkgaW4gZC5zdGF0ZSkge1xcblxcdFxcdFxcdFxcdFxcdGlmIChkLnN0YXRlLmhhc093blByb3BlcnR5KGkpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dG1wLnN0YXRlW2ldID0gZC5zdGF0ZVtpXTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoZCAmJiBfdHlwZW9mKGQubGlfYXR0cikgPT09ICdvYmplY3QnKSB7XFxuXFx0XFx0XFx0XFx0Zm9yIChpIGluIGQubGlfYXR0cikge1xcblxcdFxcdFxcdFxcdFxcdGlmIChkLmxpX2F0dHIuaGFzT3duUHJvcGVydHkoaSkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0bXAubGlfYXR0cltpXSA9IGQubGlfYXR0cltpXTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoIXRtcC5saV9hdHRyLmlkKSB7XFxuXFx0XFx0XFx0XFx0dG1wLmxpX2F0dHIuaWQgPSB0aWQ7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmIChkICYmIF90eXBlb2YoZC5hX2F0dHIpID09PSAnb2JqZWN0Jykge1xcblxcdFxcdFxcdFxcdGZvciAoaSBpbiBkLmFfYXR0cikge1xcblxcdFxcdFxcdFxcdFxcdGlmIChkLmFfYXR0ci5oYXNPd25Qcm9wZXJ0eShpKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRtcC5hX2F0dHJbaV0gPSBkLmFfYXR0cltpXTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoZCAmJiBkLmNoaWxkcmVuICYmIGQuY2hpbGRyZW4gPT09IHRydWUpIHtcXG5cXHRcXHRcXHRcXHR0bXAuc3RhdGUubG9hZGVkID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0dG1wLmNoaWxkcmVuID0gW107XFxuXFx0XFx0XFx0XFx0dG1wLmNoaWxkcmVuX2QgPSBbXTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0bVt0bXAuaWRdID0gdG1wO1xcblxcdFxcdFxcdGZvciAoaSA9IDAsIGogPSB0bXAuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0YyA9IHRoaXMuX3BhcnNlX21vZGVsX2Zyb21fZmxhdF9qc29uKG1bdG1wLmNoaWxkcmVuW2ldXSwgdG1wLmlkLCBwcyk7XFxuXFx0XFx0XFx0XFx0ZSA9IG1bY107XFxuXFx0XFx0XFx0XFx0dG1wLmNoaWxkcmVuX2QucHVzaChjKTtcXG5cXHRcXHRcXHRcXHRpZiAoZS5jaGlsZHJlbl9kLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdFxcdHRtcC5jaGlsZHJlbl9kID0gdG1wLmNoaWxkcmVuX2QuY29uY2F0KGUuY2hpbGRyZW5fZCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRkZWxldGUgZC5kYXRhO1xcblxcdFxcdFxcdGRlbGV0ZSBkLmNoaWxkcmVuO1xcblxcdFxcdFxcdG1bdG1wLmlkXS5vcmlnaW5hbCA9IGQ7XFxuXFx0XFx0XFx0aWYgKHRtcC5zdGF0ZS5zZWxlY3RlZCkge1xcblxcdFxcdFxcdFxcdHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZC5wdXNoKHRtcC5pZCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiB0bXAuaWQ7XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIHBhcnNlcyBhIG5vZGUgZnJvbSBhIEpTT04gb2JqZWN0IGFuZCBhcHBlbmRzIGl0IHRvIHRoZSBpbiBtZW1vcnkgdHJlZSBtb2RlbC4gVXNlZCBpbnRlcm5hbGx5LlxcbiAgICogQHByaXZhdGVcXG4gICAqIEBuYW1lIF9wYXJzZV9tb2RlbF9mcm9tX2pzb24oZCBbLCBwLCBwc10pXFxuICAgKiBAcGFyYW0gIHtPYmplY3R9IGQgdGhlIEpTT04gb2JqZWN0IHRvIHBhcnNlXFxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHAgdGhlIHBhcmVudCBJRFxcbiAgICogQHBhcmFtICB7QXJyYXl9IHBzIGxpc3Qgb2YgYWxsIHBhcmVudHNcXG4gICAqIEByZXR1cm4ge1N0cmluZ30gdGhlIElEIG9mIHRoZSBvYmplY3QgYWRkZWQgdG8gdGhlIG1vZGVsXFxuICAgKi9cXG5cXHRcXHRfcGFyc2VfbW9kZWxfZnJvbV9qc29uOiBmdW5jdGlvbiBfcGFyc2VfbW9kZWxfZnJvbV9qc29uKGQsIHAsIHBzKSB7XFxuXFx0XFx0XFx0aWYgKCFwcykge1xcblxcdFxcdFxcdFxcdHBzID0gW107XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRwcyA9IHBzLmNvbmNhdCgpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAocCkge1xcblxcdFxcdFxcdFxcdHBzLnVuc2hpZnQocCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHZhciB0aWQgPSBmYWxzZSxcXG5cXHRcXHRcXHQgICAgaSxcXG5cXHRcXHRcXHQgICAgaixcXG5cXHRcXHRcXHQgICAgYyxcXG5cXHRcXHRcXHQgICAgZSxcXG5cXHRcXHRcXHQgICAgbSA9IHRoaXMuX21vZGVsLmRhdGEsXFxuXFx0XFx0XFx0ICAgIGRmID0gdGhpcy5fbW9kZWwuZGVmYXVsdF9zdGF0ZSxcXG5cXHRcXHRcXHQgICAgdG1wO1xcblxcdFxcdFxcdGRvIHtcXG5cXHRcXHRcXHRcXHR0aWQgPSAnaicgKyB0aGlzLl9pZCArICdfJyArICsrdGhpcy5fY250O1xcblxcdFxcdFxcdH0gd2hpbGUgKG1bdGlkXSk7XFxuXFxuXFx0XFx0XFx0dG1wID0ge1xcblxcdFxcdFxcdFxcdGlkOiBmYWxzZSxcXG5cXHRcXHRcXHRcXHR0ZXh0OiB0eXBlb2YgZCA9PT0gJ3N0cmluZycgPyBkIDogJycsXFxuXFx0XFx0XFx0XFx0aWNvbjogKHR5cGVvZiBkID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihkKSkgPT09ICdvYmplY3QnICYmIGQuaWNvbiAhPT0gdW5kZWZpbmVkID8gZC5pY29uIDogdHJ1ZSxcXG5cXHRcXHRcXHRcXHRwYXJlbnQ6IHAsXFxuXFx0XFx0XFx0XFx0cGFyZW50czogcHMsXFxuXFx0XFx0XFx0XFx0Y2hpbGRyZW46IFtdLFxcblxcdFxcdFxcdFxcdGNoaWxkcmVuX2Q6IFtdLFxcblxcdFxcdFxcdFxcdGRhdGE6IG51bGwsXFxuXFx0XFx0XFx0XFx0c3RhdGU6IHt9LFxcblxcdFxcdFxcdFxcdGxpX2F0dHI6IHsgaWQ6IGZhbHNlIH0sXFxuXFx0XFx0XFx0XFx0YV9hdHRyOiB7IGhyZWY6ICcjJyB9LFxcblxcdFxcdFxcdFxcdG9yaWdpbmFsOiBmYWxzZVxcblxcdFxcdFxcdH07XFxuXFx0XFx0XFx0Zm9yIChpIGluIGRmKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGRmLmhhc093blByb3BlcnR5KGkpKSB7XFxuXFx0XFx0XFx0XFx0XFx0dG1wLnN0YXRlW2ldID0gZGZbaV07XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoZCAmJiBkLmlkKSB7XFxuXFx0XFx0XFx0XFx0dG1wLmlkID0gZC5pZC50b1N0cmluZygpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoZCAmJiBkLnRleHQpIHtcXG5cXHRcXHRcXHRcXHR0bXAudGV4dCA9IGQudGV4dDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKGQgJiYgZC5kYXRhICYmIGQuZGF0YS5qc3RyZWUgJiYgZC5kYXRhLmpzdHJlZS5pY29uKSB7XFxuXFx0XFx0XFx0XFx0dG1wLmljb24gPSBkLmRhdGEuanN0cmVlLmljb247XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICh0bXAuaWNvbiA9PT0gdW5kZWZpbmVkIHx8IHRtcC5pY29uID09PSBudWxsIHx8IHRtcC5pY29uID09PSBcXFwiXFxcIikge1xcblxcdFxcdFxcdFxcdHRtcC5pY29uID0gdHJ1ZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKGQgJiYgZC5kYXRhKSB7XFxuXFx0XFx0XFx0XFx0dG1wLmRhdGEgPSBkLmRhdGE7XFxuXFx0XFx0XFx0XFx0aWYgKGQuZGF0YS5qc3RyZWUpIHtcXG5cXHRcXHRcXHRcXHRcXHRmb3IgKGkgaW4gZC5kYXRhLmpzdHJlZSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChkLmRhdGEuanN0cmVlLmhhc093blByb3BlcnR5KGkpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dG1wLnN0YXRlW2ldID0gZC5kYXRhLmpzdHJlZVtpXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKGQgJiYgX3R5cGVvZihkLnN0YXRlKSA9PT0gJ29iamVjdCcpIHtcXG5cXHRcXHRcXHRcXHRmb3IgKGkgaW4gZC5zdGF0ZSkge1xcblxcdFxcdFxcdFxcdFxcdGlmIChkLnN0YXRlLmhhc093blByb3BlcnR5KGkpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dG1wLnN0YXRlW2ldID0gZC5zdGF0ZVtpXTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoZCAmJiBfdHlwZW9mKGQubGlfYXR0cikgPT09ICdvYmplY3QnKSB7XFxuXFx0XFx0XFx0XFx0Zm9yIChpIGluIGQubGlfYXR0cikge1xcblxcdFxcdFxcdFxcdFxcdGlmIChkLmxpX2F0dHIuaGFzT3duUHJvcGVydHkoaSkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0bXAubGlfYXR0cltpXSA9IGQubGlfYXR0cltpXTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAodG1wLmxpX2F0dHIuaWQgJiYgIXRtcC5pZCkge1xcblxcdFxcdFxcdFxcdHRtcC5pZCA9IHRtcC5saV9hdHRyLmlkLnRvU3RyaW5nKCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICghdG1wLmlkKSB7XFxuXFx0XFx0XFx0XFx0dG1wLmlkID0gdGlkO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoIXRtcC5saV9hdHRyLmlkKSB7XFxuXFx0XFx0XFx0XFx0dG1wLmxpX2F0dHIuaWQgPSB0bXAuaWQ7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmIChkICYmIF90eXBlb2YoZC5hX2F0dHIpID09PSAnb2JqZWN0Jykge1xcblxcdFxcdFxcdFxcdGZvciAoaSBpbiBkLmFfYXR0cikge1xcblxcdFxcdFxcdFxcdFxcdGlmIChkLmFfYXR0ci5oYXNPd25Qcm9wZXJ0eShpKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRtcC5hX2F0dHJbaV0gPSBkLmFfYXR0cltpXTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoZCAmJiBkLmNoaWxkcmVuICYmIGQuY2hpbGRyZW4ubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0Zm9yIChpID0gMCwgaiA9IGQuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0YyA9IHRoaXMuX3BhcnNlX21vZGVsX2Zyb21fanNvbihkLmNoaWxkcmVuW2ldLCB0bXAuaWQsIHBzKTtcXG5cXHRcXHRcXHRcXHRcXHRlID0gbVtjXTtcXG5cXHRcXHRcXHRcXHRcXHR0bXAuY2hpbGRyZW4ucHVzaChjKTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoZS5jaGlsZHJlbl9kLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRtcC5jaGlsZHJlbl9kID0gdG1wLmNoaWxkcmVuX2QuY29uY2F0KGUuY2hpbGRyZW5fZCk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR0bXAuY2hpbGRyZW5fZCA9IHRtcC5jaGlsZHJlbl9kLmNvbmNhdCh0bXAuY2hpbGRyZW4pO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoZCAmJiBkLmNoaWxkcmVuICYmIGQuY2hpbGRyZW4gPT09IHRydWUpIHtcXG5cXHRcXHRcXHRcXHR0bXAuc3RhdGUubG9hZGVkID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0dG1wLmNoaWxkcmVuID0gW107XFxuXFx0XFx0XFx0XFx0dG1wLmNoaWxkcmVuX2QgPSBbXTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0ZGVsZXRlIGQuZGF0YTtcXG5cXHRcXHRcXHRkZWxldGUgZC5jaGlsZHJlbjtcXG5cXHRcXHRcXHR0bXAub3JpZ2luYWwgPSBkO1xcblxcdFxcdFxcdG1bdG1wLmlkXSA9IHRtcDtcXG5cXHRcXHRcXHRpZiAodG1wLnN0YXRlLnNlbGVjdGVkKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLnB1c2godG1wLmlkKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIHRtcC5pZDtcXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogcmVkcmF3cyBhbGwgbm9kZXMgdGhhdCBuZWVkIHRvIGJlIHJlZHJhd24uIFVzZWQgaW50ZXJuYWxseS5cXG4gICAqIEBwcml2YXRlXFxuICAgKiBAbmFtZSBfcmVkcmF3KClcXG4gICAqIEB0cmlnZ2VyIHJlZHJhdy5qc3RyZWVcXG4gICAqL1xcblxcdFxcdF9yZWRyYXc6IGZ1bmN0aW9uIF9yZWRyYXcoKSB7XFxuXFx0XFx0XFx0dmFyIG5vZGVzID0gdGhpcy5fbW9kZWwuZm9yY2VfZnVsbF9yZWRyYXcgPyB0aGlzLl9tb2RlbC5kYXRhWyQuanN0cmVlLnJvb3RdLmNoaWxkcmVuLmNvbmNhdChbXSkgOiB0aGlzLl9tb2RlbC5jaGFuZ2VkLmNvbmNhdChbXSksXFxuXFx0XFx0XFx0ICAgIGYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdVTCcpLFxcblxcdFxcdFxcdCAgICB0bXAsXFxuXFx0XFx0XFx0ICAgIGksXFxuXFx0XFx0XFx0ICAgIGosXFxuXFx0XFx0XFx0ICAgIGZlID0gdGhpcy5fZGF0YS5jb3JlLmZvY3VzZWQ7XFxuXFx0XFx0XFx0Zm9yIChpID0gMCwgaiA9IG5vZGVzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcblxcdFxcdFxcdFxcdHRtcCA9IHRoaXMucmVkcmF3X25vZGUobm9kZXNbaV0sIHRydWUsIHRoaXMuX21vZGVsLmZvcmNlX2Z1bGxfcmVkcmF3KTtcXG5cXHRcXHRcXHRcXHRpZiAodG1wICYmIHRoaXMuX21vZGVsLmZvcmNlX2Z1bGxfcmVkcmF3KSB7XFxuXFx0XFx0XFx0XFx0XFx0Zi5hcHBlbmRDaGlsZCh0bXApO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKHRoaXMuX21vZGVsLmZvcmNlX2Z1bGxfcmVkcmF3KSB7XFxuXFx0XFx0XFx0XFx0Zi5jbGFzc05hbWUgPSB0aGlzLmdldF9jb250YWluZXJfdWwoKVswXS5jbGFzc05hbWU7XFxuXFx0XFx0XFx0XFx0Zi5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnZ3JvdXAnKTtcXG5cXHRcXHRcXHRcXHR0aGlzLmVsZW1lbnQuZW1wdHkoKS5hcHBlbmQoZik7XFxuXFx0XFx0XFx0XFx0Ly90aGlzLmdldF9jb250YWluZXJfdWwoKVswXS5hcHBlbmRDaGlsZChmKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKGZlICE9PSBudWxsKSB7XFxuXFx0XFx0XFx0XFx0dG1wID0gdGhpcy5nZXRfbm9kZShmZSwgdHJ1ZSk7XFxuXFx0XFx0XFx0XFx0aWYgKHRtcCAmJiB0bXAubGVuZ3RoICYmIHRtcC5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKVswXSAhPT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkge1xcblxcdFxcdFxcdFxcdFxcdHRtcC5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5mb2N1cygpO1xcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fZGF0YS5jb3JlLmZvY3VzZWQgPSBudWxsO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0dGhpcy5fbW9kZWwuZm9yY2VfZnVsbF9yZWRyYXcgPSBmYWxzZTtcXG5cXHRcXHRcXHR0aGlzLl9tb2RlbC5jaGFuZ2VkID0gW107XFxuXFx0XFx0XFx0LyoqXFxuICAgICogdHJpZ2dlcmVkIGFmdGVyIG5vZGVzIGFyZSByZWRyYXduXFxuICAgICogQGV2ZW50XFxuICAgICogQG5hbWUgcmVkcmF3LmpzdHJlZVxcbiAgICAqIEBwYXJhbSB7YXJyYXl9IG5vZGVzIHRoZSByZWRyYXduIG5vZGVzXFxuICAgICovXFxuXFx0XFx0XFx0dGhpcy50cmlnZ2VyKCdyZWRyYXcnLCB7IFxcXCJub2Rlc1xcXCI6IG5vZGVzIH0pO1xcblxcdFxcdH0sXFxuXFx0XFx0LyoqXFxuICAgKiByZWRyYXdzIGFsbCBub2RlcyB0aGF0IG5lZWQgdG8gYmUgcmVkcmF3biBvciBvcHRpb25hbGx5IC0gdGhlIHdob2xlIHRyZWVcXG4gICAqIEBuYW1lIHJlZHJhdyhbZnVsbF0pXFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZ1bGwgaWYgc2V0IHRvIGB0cnVlYCBhbGwgbm9kZXMgYXJlIHJlZHJhd24uXFxuICAgKi9cXG5cXHRcXHRyZWRyYXc6IGZ1bmN0aW9uIHJlZHJhdyhmdWxsKSB7XFxuXFx0XFx0XFx0aWYgKGZ1bGwpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9tb2RlbC5mb3JjZV9mdWxsX3JlZHJhdyA9IHRydWU7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdC8vaWYodGhpcy5fbW9kZWwucmVkcmF3X3RpbWVvdXQpIHtcXG5cXHRcXHRcXHQvL1xcdGNsZWFyVGltZW91dCh0aGlzLl9tb2RlbC5yZWRyYXdfdGltZW91dCk7XFxuXFx0XFx0XFx0Ly99XFxuXFx0XFx0XFx0Ly90aGlzLl9tb2RlbC5yZWRyYXdfdGltZW91dCA9IHNldFRpbWVvdXQoJC5wcm94eSh0aGlzLl9yZWRyYXcsIHRoaXMpLDApO1xcblxcdFxcdFxcdHRoaXMuX3JlZHJhdygpO1xcblxcdFxcdH0sXFxuXFx0XFx0LyoqXFxuICAgKiByZWRyYXdzIGEgc2luZ2xlIG5vZGUncyBjaGlsZHJlbi4gVXNlZCBpbnRlcm5hbGx5LlxcbiAgICogQHByaXZhdGVcXG4gICAqIEBuYW1lIGRyYXdfY2hpbGRyZW4obm9kZSlcXG4gICAqIEBwYXJhbSB7bWl4ZWR9IG5vZGUgdGhlIG5vZGUgd2hvc2UgY2hpbGRyZW4gd2lsbCBiZSByZWRyYXduXFxuICAgKi9cXG5cXHRcXHRkcmF3X2NoaWxkcmVuOiBmdW5jdGlvbiBkcmF3X2NoaWxkcmVuKG5vZGUpIHtcXG5cXHRcXHRcXHR2YXIgb2JqID0gdGhpcy5nZXRfbm9kZShub2RlKSxcXG5cXHRcXHRcXHQgICAgaSA9IGZhbHNlLFxcblxcdFxcdFxcdCAgICBqID0gZmFsc2UsXFxuXFx0XFx0XFx0ICAgIGsgPSBmYWxzZSxcXG5cXHRcXHRcXHQgICAgZCA9IGRvY3VtZW50O1xcblxcdFxcdFxcdGlmICghb2JqKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAob2JqLmlkID09PSAkLmpzdHJlZS5yb290KSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMucmVkcmF3KHRydWUpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRub2RlID0gdGhpcy5nZXRfbm9kZShub2RlLCB0cnVlKTtcXG5cXHRcXHRcXHRpZiAoIW5vZGUgfHwgIW5vZGUubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH0gLy8gVE9ETzogcXVpY2sgdG9nZ2xlXFxuXFxuXFx0XFx0XFx0bm9kZS5jaGlsZHJlbignLmpzdHJlZS1jaGlsZHJlbicpLnJlbW92ZSgpO1xcblxcdFxcdFxcdG5vZGUgPSBub2RlWzBdO1xcblxcdFxcdFxcdGlmIChvYmouY2hpbGRyZW4ubGVuZ3RoICYmIG9iai5zdGF0ZS5sb2FkZWQpIHtcXG5cXHRcXHRcXHRcXHRrID0gZC5jcmVhdGVFbGVtZW50KCdVTCcpO1xcblxcdFxcdFxcdFxcdGsuc2V0QXR0cmlidXRlKCdyb2xlJywgJ2dyb3VwJyk7XFxuXFx0XFx0XFx0XFx0ay5jbGFzc05hbWUgPSAnanN0cmVlLWNoaWxkcmVuJztcXG5cXHRcXHRcXHRcXHRmb3IgKGkgPSAwLCBqID0gb2JqLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdGsuYXBwZW5kQ2hpbGQodGhpcy5yZWRyYXdfbm9kZShvYmouY2hpbGRyZW5baV0sIHRydWUsIHRydWUpKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0bm9kZS5hcHBlbmRDaGlsZChrKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIHJlZHJhd3MgYSBzaW5nbGUgbm9kZS4gVXNlZCBpbnRlcm5hbGx5LlxcbiAgICogQHByaXZhdGVcXG4gICAqIEBuYW1lIHJlZHJhd19ub2RlKG5vZGUsIGRlZXAsIGlzX2NhbGxiYWNrLCBmb3JjZV9yZW5kZXIpXFxuICAgKiBAcGFyYW0ge21peGVkfSBub2RlIHRoZSBub2RlIHRvIHJlZHJhd1xcbiAgICogQHBhcmFtIHtCb29sZWFufSBkZWVwIHNob3VsZCBjaGlsZCBub2RlcyBiZSByZWRyYXduIHRvb1xcbiAgICogQHBhcmFtIHtCb29sZWFufSBpc19jYWxsYmFjayBpcyB0aGlzIGEgcmVjdXJzaW9uIGNhbGxcXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZm9yY2VfcmVuZGVyIHNob3VsZCBjaGlsZHJlbiBvZiBjbG9zZWQgcGFyZW50cyBiZSBkcmF3biBhbnl3YXlcXG4gICAqL1xcblxcdFxcdHJlZHJhd19ub2RlOiBmdW5jdGlvbiByZWRyYXdfbm9kZShub2RlLCBkZWVwLCBpc19jYWxsYmFjaywgZm9yY2VfcmVuZGVyKSB7XFxuXFx0XFx0XFx0dmFyIG9iaiA9IHRoaXMuZ2V0X25vZGUobm9kZSksXFxuXFx0XFx0XFx0ICAgIHBhciA9IGZhbHNlLFxcblxcdFxcdFxcdCAgICBpbmQgPSBmYWxzZSxcXG5cXHRcXHRcXHQgICAgb2xkID0gZmFsc2UsXFxuXFx0XFx0XFx0ICAgIGkgPSBmYWxzZSxcXG5cXHRcXHRcXHQgICAgaiA9IGZhbHNlLFxcblxcdFxcdFxcdCAgICBrID0gZmFsc2UsXFxuXFx0XFx0XFx0ICAgIGMgPSAnJyxcXG5cXHRcXHRcXHQgICAgZCA9IGRvY3VtZW50LFxcblxcdFxcdFxcdCAgICBtID0gdGhpcy5fbW9kZWwuZGF0YSxcXG5cXHRcXHRcXHQgICAgZiA9IGZhbHNlLFxcblxcdFxcdFxcdCAgICBzID0gZmFsc2UsXFxuXFx0XFx0XFx0ICAgIHRtcCA9IG51bGwsXFxuXFx0XFx0XFx0ICAgIHQgPSAwLFxcblxcdFxcdFxcdCAgICBsID0gMCxcXG5cXHRcXHRcXHQgICAgaGFzX2NoaWxkcmVuID0gZmFsc2UsXFxuXFx0XFx0XFx0ICAgIGxhc3Rfc2libGluZyA9IGZhbHNlO1xcblxcdFxcdFxcdGlmICghb2JqKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAob2JqLmlkID09PSAkLmpzdHJlZS5yb290KSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMucmVkcmF3KHRydWUpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRkZWVwID0gZGVlcCB8fCBvYmouY2hpbGRyZW4ubGVuZ3RoID09PSAwO1xcblxcdFxcdFxcdG5vZGUgPSAhZG9jdW1lbnQucXVlcnlTZWxlY3RvciA/IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG9iai5pZCkgOiB0aGlzLmVsZW1lbnRbMF0ucXVlcnlTZWxlY3RvcignIycgKyAoXFxcIjAxMjM0NTY3ODlcXFwiLmluZGV4T2Yob2JqLmlkWzBdKSAhPT0gLTEgPyAnXFxcXFxcXFwzJyArIG9iai5pZFswXSArICcgJyArIG9iai5pZC5zdWJzdHIoMSkucmVwbGFjZSgkLmpzdHJlZS5pZHJlZ2V4LCAnXFxcXFxcXFwkJicpIDogb2JqLmlkLnJlcGxhY2UoJC5qc3RyZWUuaWRyZWdleCwgJ1xcXFxcXFxcJCYnKSkpOyAvLywgdGhpcy5lbGVtZW50KTtcXG5cXHRcXHRcXHRpZiAoIW5vZGUpIHtcXG5cXHRcXHRcXHRcXHRkZWVwID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHQvL25vZGUgPSBkLmNyZWF0ZUVsZW1lbnQoJ0xJJyk7XFxuXFx0XFx0XFx0XFx0aWYgKCFpc19jYWxsYmFjaykge1xcblxcdFxcdFxcdFxcdFxcdHBhciA9IG9iai5wYXJlbnQgIT09ICQuanN0cmVlLnJvb3QgPyAkKCcjJyArIG9iai5wYXJlbnQucmVwbGFjZSgkLmpzdHJlZS5pZHJlZ2V4LCAnXFxcXFxcXFwkJicpLCB0aGlzLmVsZW1lbnQpWzBdIDogbnVsbDtcXG5cXHRcXHRcXHRcXHRcXHRpZiAocGFyICE9PSBudWxsICYmICghcGFyIHx8ICFtW29iai5wYXJlbnRdLnN0YXRlLm9wZW5lZCkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGluZCA9ICQuaW5BcnJheShvYmouaWQsIHBhciA9PT0gbnVsbCA/IG1bJC5qc3RyZWUucm9vdF0uY2hpbGRyZW4gOiBtW29iai5wYXJlbnRdLmNoaWxkcmVuKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRub2RlID0gJChub2RlKTtcXG5cXHRcXHRcXHRcXHRpZiAoIWlzX2NhbGxiYWNrKSB7XFxuXFx0XFx0XFx0XFx0XFx0cGFyID0gbm9kZS5wYXJlbnQoKS5wYXJlbnQoKVswXTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAocGFyID09PSB0aGlzLmVsZW1lbnRbMF0pIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRwYXIgPSBudWxsO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRpbmQgPSBub2RlLmluZGV4KCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdC8vIG1bb2JqLmlkXS5kYXRhID0gbm9kZS5kYXRhKCk7IC8vIHVzZSBvbmx5IG5vZGUncyBkYXRhLCBubyBuZWVkIHRvIHRvdWNoIGpxdWVyeSBzdG9yYWdlXFxuXFx0XFx0XFx0XFx0aWYgKCFkZWVwICYmIG9iai5jaGlsZHJlbi5sZW5ndGggJiYgIW5vZGUuY2hpbGRyZW4oJy5qc3RyZWUtY2hpbGRyZW4nKS5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRcXHRkZWVwID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aWYgKCFkZWVwKSB7XFxuXFx0XFx0XFx0XFx0XFx0b2xkID0gbm9kZS5jaGlsZHJlbignLmpzdHJlZS1jaGlsZHJlbicpWzBdO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRmID0gbm9kZS5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKVswXSA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcXG5cXHRcXHRcXHRcXHRub2RlLnJlbW92ZSgpO1xcblxcdFxcdFxcdFxcdC8vbm9kZSA9IGQuY3JlYXRlRWxlbWVudCgnTEknKTtcXG5cXHRcXHRcXHRcXHQvL25vZGUgPSBub2RlWzBdO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRub2RlID0gdGhpcy5fZGF0YS5jb3JlLm5vZGUuY2xvbmVOb2RlKHRydWUpO1xcblxcdFxcdFxcdC8vIG5vZGUgaXMgRE9NLCBkZWVwIGlzIGJvb2xlYW5cXG5cXG5cXHRcXHRcXHRjID0gJ2pzdHJlZS1ub2RlICc7XFxuXFx0XFx0XFx0Zm9yIChpIGluIG9iai5saV9hdHRyKSB7XFxuXFx0XFx0XFx0XFx0aWYgKG9iai5saV9hdHRyLmhhc093blByb3BlcnR5KGkpKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGkgPT09ICdpZCcpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRjb250aW51ZTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGkgIT09ICdjbGFzcycpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRub2RlLnNldEF0dHJpYnV0ZShpLCBvYmoubGlfYXR0cltpXSk7XFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRjICs9IG9iai5saV9hdHRyW2ldO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICghb2JqLmFfYXR0ci5pZCkge1xcblxcdFxcdFxcdFxcdG9iai5hX2F0dHIuaWQgPSBvYmouaWQgKyAnX2FuY2hvcic7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdG5vZGUuc2V0QXR0cmlidXRlKCdhcmlhLXNlbGVjdGVkJywgISFvYmouc3RhdGUuc2VsZWN0ZWQpO1xcblxcdFxcdFxcdG5vZGUuc2V0QXR0cmlidXRlKCdhcmlhLWxldmVsJywgb2JqLnBhcmVudHMubGVuZ3RoKTtcXG5cXHRcXHRcXHRub2RlLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbGxlZGJ5Jywgb2JqLmFfYXR0ci5pZCk7XFxuXFx0XFx0XFx0aWYgKG9iai5zdGF0ZS5kaXNhYmxlZCkge1xcblxcdFxcdFxcdFxcdG5vZGUuc2V0QXR0cmlidXRlKCdhcmlhLWRpc2FibGVkJywgdHJ1ZSk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGZvciAoaSA9IDAsIGogPSBvYmouY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCFtW29iai5jaGlsZHJlbltpXV0uc3RhdGUuaGlkZGVuKSB7XFxuXFx0XFx0XFx0XFx0XFx0aGFzX2NoaWxkcmVuID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmIChvYmoucGFyZW50ICE9PSBudWxsICYmIG1bb2JqLnBhcmVudF0gJiYgIW9iai5zdGF0ZS5oaWRkZW4pIHtcXG5cXHRcXHRcXHRcXHRpID0gJC5pbkFycmF5KG9iai5pZCwgbVtvYmoucGFyZW50XS5jaGlsZHJlbik7XFxuXFx0XFx0XFx0XFx0bGFzdF9zaWJsaW5nID0gb2JqLmlkO1xcblxcdFxcdFxcdFxcdGlmIChpICE9PSAtMSkge1xcblxcdFxcdFxcdFxcdFxcdGkrKztcXG5cXHRcXHRcXHRcXHRcXHRmb3IgKGogPSBtW29iai5wYXJlbnRdLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICghbVttW29iai5wYXJlbnRdLmNoaWxkcmVuW2ldXS5zdGF0ZS5oaWRkZW4pIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRsYXN0X3NpYmxpbmcgPSBtW29iai5wYXJlbnRdLmNoaWxkcmVuW2ldO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAobGFzdF9zaWJsaW5nICE9PSBvYmouaWQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKG9iai5zdGF0ZS5oaWRkZW4pIHtcXG5cXHRcXHRcXHRcXHRjICs9ICcganN0cmVlLWhpZGRlbic7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmIChvYmouc3RhdGUubG9hZGVkICYmICFoYXNfY2hpbGRyZW4pIHtcXG5cXHRcXHRcXHRcXHRjICs9ICcganN0cmVlLWxlYWYnO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0YyArPSBvYmouc3RhdGUub3BlbmVkICYmIG9iai5zdGF0ZS5sb2FkZWQgPyAnIGpzdHJlZS1vcGVuJyA6ICcganN0cmVlLWNsb3NlZCc7XFxuXFx0XFx0XFx0XFx0bm9kZS5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCBvYmouc3RhdGUub3BlbmVkICYmIG9iai5zdGF0ZS5sb2FkZWQpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAobGFzdF9zaWJsaW5nID09PSBvYmouaWQpIHtcXG5cXHRcXHRcXHRcXHRjICs9ICcganN0cmVlLWxhc3QnO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRub2RlLmlkID0gb2JqLmlkO1xcblxcdFxcdFxcdG5vZGUuY2xhc3NOYW1lID0gYztcXG5cXHRcXHRcXHRjID0gKG9iai5zdGF0ZS5zZWxlY3RlZCA/ICcganN0cmVlLWNsaWNrZWQnIDogJycpICsgKG9iai5zdGF0ZS5kaXNhYmxlZCA/ICcganN0cmVlLWRpc2FibGVkJyA6ICcnKTtcXG5cXHRcXHRcXHRmb3IgKGogaW4gb2JqLmFfYXR0cikge1xcblxcdFxcdFxcdFxcdGlmIChvYmouYV9hdHRyLmhhc093blByb3BlcnR5KGopKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGogPT09ICdocmVmJyAmJiBvYmouYV9hdHRyW2pdID09PSAnIycpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRjb250aW51ZTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGogIT09ICdjbGFzcycpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRub2RlLmNoaWxkTm9kZXNbMV0uc2V0QXR0cmlidXRlKGosIG9iai5hX2F0dHJbal0pO1xcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YyArPSAnICcgKyBvYmouYV9hdHRyW2pdO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmIChjLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdG5vZGUuY2hpbGROb2Rlc1sxXS5jbGFzc05hbWUgPSAnanN0cmVlLWFuY2hvciAnICsgYztcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKG9iai5pY29uICYmIG9iai5pY29uICE9PSB0cnVlIHx8IG9iai5pY29uID09PSBmYWxzZSkge1xcblxcdFxcdFxcdFxcdGlmIChvYmouaWNvbiA9PT0gZmFsc2UpIHtcXG5cXHRcXHRcXHRcXHRcXHRub2RlLmNoaWxkTm9kZXNbMV0uY2hpbGROb2Rlc1swXS5jbGFzc05hbWUgKz0gJyBqc3RyZWUtdGhlbWVpY29uLWhpZGRlbic7XFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmIChvYmouaWNvbi5pbmRleE9mKCcvJykgPT09IC0xICYmIG9iai5pY29uLmluZGV4T2YoJy4nKSA9PT0gLTEpIHtcXG5cXHRcXHRcXHRcXHRcXHRub2RlLmNoaWxkTm9kZXNbMV0uY2hpbGROb2Rlc1swXS5jbGFzc05hbWUgKz0gJyAnICsgb2JqLmljb24gKyAnIGpzdHJlZS10aGVtZWljb24tY3VzdG9tJztcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdG5vZGUuY2hpbGROb2Rlc1sxXS5jaGlsZE5vZGVzWzBdLnN0eWxlLmJhY2tncm91bmRJbWFnZSA9ICd1cmwoXFxcIicgKyBvYmouaWNvbiArICdcXFwiKSc7XFxuXFx0XFx0XFx0XFx0XFx0bm9kZS5jaGlsZE5vZGVzWzFdLmNoaWxkTm9kZXNbMF0uc3R5bGUuYmFja2dyb3VuZFBvc2l0aW9uID0gJ2NlbnRlciBjZW50ZXInO1xcblxcdFxcdFxcdFxcdFxcdG5vZGUuY2hpbGROb2Rlc1sxXS5jaGlsZE5vZGVzWzBdLnN0eWxlLmJhY2tncm91bmRTaXplID0gJ2F1dG8nO1xcblxcdFxcdFxcdFxcdFxcdG5vZGUuY2hpbGROb2Rlc1sxXS5jaGlsZE5vZGVzWzBdLmNsYXNzTmFtZSArPSAnIGpzdHJlZS10aGVtZWljb24tY3VzdG9tJztcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICh0aGlzLnNldHRpbmdzLmNvcmUuZm9yY2VfdGV4dCkge1xcblxcdFxcdFxcdFxcdG5vZGUuY2hpbGROb2Rlc1sxXS5hcHBlbmRDaGlsZChkLmNyZWF0ZVRleHROb2RlKG9iai50ZXh0KSk7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRub2RlLmNoaWxkTm9kZXNbMV0uaW5uZXJIVE1MICs9IG9iai50ZXh0O1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoZGVlcCAmJiBvYmouY2hpbGRyZW4ubGVuZ3RoICYmIChvYmouc3RhdGUub3BlbmVkIHx8IGZvcmNlX3JlbmRlcikgJiYgb2JqLnN0YXRlLmxvYWRlZCkge1xcblxcdFxcdFxcdFxcdGsgPSBkLmNyZWF0ZUVsZW1lbnQoJ1VMJyk7XFxuXFx0XFx0XFx0XFx0ay5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnZ3JvdXAnKTtcXG5cXHRcXHRcXHRcXHRrLmNsYXNzTmFtZSA9ICdqc3RyZWUtY2hpbGRyZW4nO1xcblxcdFxcdFxcdFxcdGZvciAoaSA9IDAsIGogPSBvYmouY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0ay5hcHBlbmRDaGlsZCh0aGlzLnJlZHJhd19ub2RlKG9iai5jaGlsZHJlbltpXSwgZGVlcCwgdHJ1ZSkpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRub2RlLmFwcGVuZENoaWxkKGspO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAob2xkKSB7XFxuXFx0XFx0XFx0XFx0bm9kZS5hcHBlbmRDaGlsZChvbGQpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoIWlzX2NhbGxiYWNrKSB7XFxuXFx0XFx0XFx0XFx0Ly8gYXBwZW5kIGJhY2sgdXNpbmcgcGFyIC8gaW5kXFxuXFx0XFx0XFx0XFx0aWYgKCFwYXIpIHtcXG5cXHRcXHRcXHRcXHRcXHRwYXIgPSB0aGlzLmVsZW1lbnRbMF07XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGZvciAoaSA9IDAsIGogPSBwYXIuY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAocGFyLmNoaWxkTm9kZXNbaV0gJiYgcGFyLmNoaWxkTm9kZXNbaV0uY2xhc3NOYW1lICYmIHBhci5jaGlsZE5vZGVzW2ldLmNsYXNzTmFtZS5pbmRleE9mKCdqc3RyZWUtY2hpbGRyZW4nKSAhPT0gLTEpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0bXAgPSBwYXIuY2hpbGROb2Rlc1tpXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGlmICghdG1wKSB7XFxuXFx0XFx0XFx0XFx0XFx0dG1wID0gZC5jcmVhdGVFbGVtZW50KCdVTCcpO1xcblxcdFxcdFxcdFxcdFxcdHRtcC5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnZ3JvdXAnKTtcXG5cXHRcXHRcXHRcXHRcXHR0bXAuY2xhc3NOYW1lID0gJ2pzdHJlZS1jaGlsZHJlbic7XFxuXFx0XFx0XFx0XFx0XFx0cGFyLmFwcGVuZENoaWxkKHRtcCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHBhciA9IHRtcDtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoaW5kIDwgcGFyLmNoaWxkTm9kZXMubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0cGFyLmluc2VydEJlZm9yZShub2RlLCBwYXIuY2hpbGROb2Rlc1tpbmRdKTtcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdHBhci5hcHBlbmRDaGlsZChub2RlKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aWYgKGYpIHtcXG5cXHRcXHRcXHRcXHRcXHR0ID0gdGhpcy5lbGVtZW50WzBdLnNjcm9sbFRvcDtcXG5cXHRcXHRcXHRcXHRcXHRsID0gdGhpcy5lbGVtZW50WzBdLnNjcm9sbExlZnQ7XFxuXFx0XFx0XFx0XFx0XFx0bm9kZS5jaGlsZE5vZGVzWzFdLmZvY3VzKCk7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5lbGVtZW50WzBdLnNjcm9sbFRvcCA9IHQ7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5lbGVtZW50WzBdLnNjcm9sbExlZnQgPSBsO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKG9iai5zdGF0ZS5vcGVuZWQgJiYgIW9iai5zdGF0ZS5sb2FkZWQpIHtcXG5cXHRcXHRcXHRcXHRvYmouc3RhdGUub3BlbmVkID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0c2V0VGltZW91dCgkLnByb3h5KGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLm9wZW5fbm9kZShvYmouaWQsIGZhbHNlLCAwKTtcXG5cXHRcXHRcXHRcXHR9LCB0aGlzKSwgMCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiBub2RlO1xcblxcdFxcdH0sXFxuXFx0XFx0LyoqXFxuICAgKiBvcGVucyBhIG5vZGUsIHJldmFsaW5nIGl0cyBjaGlsZHJlbi4gSWYgdGhlIG5vZGUgaXMgbm90IGxvYWRlZCBpdCB3aWxsIGJlIGxvYWRlZCBhbmQgb3BlbmVkIG9uY2UgcmVhZHkuXFxuICAgKiBAbmFtZSBvcGVuX25vZGUob2JqIFssIGNhbGxiYWNrLCBhbmltYXRpb25dKVxcbiAgICogQHBhcmFtIHttaXhlZH0gb2JqIHRoZSBub2RlIHRvIG9wZW5cXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGEgZnVuY3Rpb24gdG8gZXhlY3V0ZSBvbmNlIHRoZSBub2RlIGlzIG9wZW5lZFxcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFuaW1hdGlvbiB0aGUgYW5pbWF0aW9uIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcyB3aGVuIG9wZW5pbmcgdGhlIG5vZGUgKG92ZXJyaWRlcyB0aGUgYGNvcmUuYW5pbWF0aW9uYCBzZXR0aW5nKS4gVXNlIGBmYWxzZWAgZm9yIG5vIGFuaW1hdGlvbi5cXG4gICAqIEB0cmlnZ2VyIG9wZW5fbm9kZS5qc3RyZWUsIGFmdGVyX29wZW4uanN0cmVlLCBiZWZvcmVfb3Blbi5qc3RyZWVcXG4gICAqL1xcblxcdFxcdG9wZW5fbm9kZTogZnVuY3Rpb24gb3Blbl9ub2RlKG9iaiwgY2FsbGJhY2ssIGFuaW1hdGlvbikge1xcblxcdFxcdFxcdHZhciB0MSwgdDIsIGQsIHQ7XFxuXFx0XFx0XFx0aWYgKCQuaXNBcnJheShvYmopKSB7XFxuXFx0XFx0XFx0XFx0b2JqID0gb2JqLnNsaWNlKCk7XFxuXFx0XFx0XFx0XFx0Zm9yICh0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMub3Blbl9ub2RlKG9ialt0MV0sIGNhbGxiYWNrLCBhbmltYXRpb24pO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xcblxcdFxcdFxcdGlmICghb2JqIHx8IG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCkge1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0YW5pbWF0aW9uID0gYW5pbWF0aW9uID09PSB1bmRlZmluZWQgPyB0aGlzLnNldHRpbmdzLmNvcmUuYW5pbWF0aW9uIDogYW5pbWF0aW9uO1xcblxcdFxcdFxcdGlmICghdGhpcy5pc19jbG9zZWQob2JqKSkge1xcblxcdFxcdFxcdFxcdGlmIChjYWxsYmFjaykge1xcblxcdFxcdFxcdFxcdFxcdGNhbGxiYWNrLmNhbGwodGhpcywgb2JqLCBmYWxzZSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKCF0aGlzLmlzX2xvYWRlZChvYmopKSB7XFxuXFx0XFx0XFx0XFx0aWYgKHRoaXMuaXNfbG9hZGluZyhvYmopKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHNldFRpbWVvdXQoJC5wcm94eShmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5vcGVuX25vZGUob2JqLCBjYWxsYmFjaywgYW5pbWF0aW9uKTtcXG5cXHRcXHRcXHRcXHRcXHR9LCB0aGlzKSwgNTAwKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0dGhpcy5sb2FkX25vZGUob2JqLCBmdW5jdGlvbiAobywgb2spIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gb2sgPyB0aGlzLm9wZW5fbm9kZShvLCBjYWxsYmFjaywgYW5pbWF0aW9uKSA6IGNhbGxiYWNrID8gY2FsbGJhY2suY2FsbCh0aGlzLCBvLCBmYWxzZSkgOiBmYWxzZTtcXG5cXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdGQgPSB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSk7XFxuXFx0XFx0XFx0XFx0dCA9IHRoaXM7XFxuXFx0XFx0XFx0XFx0aWYgKGQubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGFuaW1hdGlvbiAmJiBkLmNoaWxkcmVuKFxcXCIuanN0cmVlLWNoaWxkcmVuXFxcIikubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZC5jaGlsZHJlbihcXFwiLmpzdHJlZS1jaGlsZHJlblxcXCIpLnN0b3AodHJ1ZSwgdHJ1ZSk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmIChvYmouY2hpbGRyZW4ubGVuZ3RoICYmICF0aGlzLl9maXJzdENoaWxkKGQuY2hpbGRyZW4oJy5qc3RyZWUtY2hpbGRyZW4nKVswXSkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLmRyYXdfY2hpbGRyZW4ob2JqKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHQvL2QgPSB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmICghYW5pbWF0aW9uKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy50cmlnZ2VyKCdiZWZvcmVfb3BlbicsIHsgXFxcIm5vZGVcXFwiOiBvYmogfSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZFswXS5jbGFzc05hbWUgPSBkWzBdLmNsYXNzTmFtZS5yZXBsYWNlKCdqc3RyZWUtY2xvc2VkJywgJ2pzdHJlZS1vcGVuJyk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZFswXS5zZXRBdHRyaWJ1dGUoXFxcImFyaWEtZXhwYW5kZWRcXFwiLCB0cnVlKTtcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMudHJpZ2dlcignYmVmb3JlX29wZW4nLCB7IFxcXCJub2RlXFxcIjogb2JqIH0pO1xcblxcdFxcdFxcdFxcdFxcdFxcdGQuY2hpbGRyZW4oXFxcIi5qc3RyZWUtY2hpbGRyZW5cXFwiKS5jc3MoXFxcImRpc3BsYXlcXFwiLCBcXFwibm9uZVxcXCIpLmVuZCgpLnJlbW92ZUNsYXNzKFxcXCJqc3RyZWUtY2xvc2VkXFxcIikuYWRkQ2xhc3MoXFxcImpzdHJlZS1vcGVuXFxcIikuYXR0cihcXFwiYXJpYS1leHBhbmRlZFxcXCIsIHRydWUpLmNoaWxkcmVuKFxcXCIuanN0cmVlLWNoaWxkcmVuXFxcIikuc3RvcCh0cnVlLCB0cnVlKS5zbGlkZURvd24oYW5pbWF0aW9uLCBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5zdHlsZS5kaXNwbGF5ID0gXFxcIlxcXCI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKHQuZWxlbWVudCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHQudHJpZ2dlcihcXFwiYWZ0ZXJfb3BlblxcXCIsIHsgXFxcIm5vZGVcXFwiOiBvYmogfSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0b2JqLnN0YXRlLm9wZW5lZCA9IHRydWU7XFxuXFx0XFx0XFx0XFx0aWYgKGNhbGxiYWNrKSB7XFxuXFx0XFx0XFx0XFx0XFx0Y2FsbGJhY2suY2FsbCh0aGlzLCBvYmosIHRydWUpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRpZiAoIWQubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0LyoqXFxuICAgICAgKiB0cmlnZ2VyZWQgd2hlbiBhIG5vZGUgaXMgYWJvdXQgdG8gYmUgb3BlbmVkIChpZiB0aGUgbm9kZSBpcyBzdXBwb3NlZCB0byBiZSBpbiB0aGUgRE9NLCBpdCB3aWxsIGJlLCBidXQgaXQgd29uJ3QgYmUgdmlzaWJsZSB5ZXQpXFxuICAgICAgKiBAZXZlbnRcXG4gICAgICAqIEBuYW1lIGJlZm9yZV9vcGVuLmpzdHJlZVxcbiAgICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGUgdGhlIG9wZW5lZCBub2RlXFxuICAgICAgKi9cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnRyaWdnZXIoJ2JlZm9yZV9vcGVuJywgeyBcXFwibm9kZVxcXCI6IG9iaiB9KTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0LyoqXFxuICAgICAqIHRyaWdnZXJlZCB3aGVuIGEgbm9kZSBpcyBvcGVuZWQgKGlmIHRoZXJlIGlzIGFuIGFuaW1hdGlvbiBpdCB3aWxsIG5vdCBiZSBjb21wbGV0ZWQgeWV0KVxcbiAgICAgKiBAZXZlbnRcXG4gICAgICogQG5hbWUgb3Blbl9ub2RlLmpzdHJlZVxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZSB0aGUgb3BlbmVkIG5vZGVcXG4gICAgICovXFxuXFx0XFx0XFx0XFx0dGhpcy50cmlnZ2VyKCdvcGVuX25vZGUnLCB7IFxcXCJub2RlXFxcIjogb2JqIH0pO1xcblxcdFxcdFxcdFxcdGlmICghYW5pbWF0aW9uIHx8ICFkLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdFxcdC8qKlxcbiAgICAgICogdHJpZ2dlcmVkIHdoZW4gYSBub2RlIGlzIG9wZW5lZCBhbmQgdGhlIGFuaW1hdGlvbiBpcyBjb21wbGV0ZVxcbiAgICAgICogQGV2ZW50XFxuICAgICAgKiBAbmFtZSBhZnRlcl9vcGVuLmpzdHJlZVxcbiAgICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGUgdGhlIG9wZW5lZCBub2RlXFxuICAgICAgKi9cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnRyaWdnZXIoXFxcImFmdGVyX29wZW5cXFwiLCB7IFxcXCJub2RlXFxcIjogb2JqIH0pO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIG9wZW5zIGV2ZXJ5IHBhcmVudCBvZiBhIG5vZGUgKG5vZGUgc2hvdWxkIGJlIGxvYWRlZClcXG4gICAqIEBuYW1lIF9vcGVuX3RvKG9iailcXG4gICAqIEBwYXJhbSB7bWl4ZWR9IG9iaiB0aGUgbm9kZSB0byByZXZlYWxcXG4gICAqIEBwcml2YXRlXFxuICAgKi9cXG5cXHRcXHRfb3Blbl90bzogZnVuY3Rpb24gX29wZW5fdG8ob2JqKSB7XFxuXFx0XFx0XFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xcblxcdFxcdFxcdGlmICghb2JqIHx8IG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCkge1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0dmFyIGksXFxuXFx0XFx0XFx0ICAgIGosXFxuXFx0XFx0XFx0ICAgIHAgPSBvYmoucGFyZW50cztcXG5cXHRcXHRcXHRmb3IgKGkgPSAwLCBqID0gcC5sZW5ndGg7IGkgPCBqOyBpICs9IDEpIHtcXG5cXHRcXHRcXHRcXHRpZiAoaSAhPT0gJC5qc3RyZWUucm9vdCkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMub3Blbl9ub2RlKHBbaV0sIGZhbHNlLCAwKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiAkKCcjJyArIG9iai5pZC5yZXBsYWNlKCQuanN0cmVlLmlkcmVnZXgsICdcXFxcXFxcXCQmJyksIHRoaXMuZWxlbWVudCk7XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIGNsb3NlcyBhIG5vZGUsIGhpZGluZyBpdHMgY2hpbGRyZW5cXG4gICAqIEBuYW1lIGNsb3NlX25vZGUob2JqIFssIGFuaW1hdGlvbl0pXFxuICAgKiBAcGFyYW0ge21peGVkfSBvYmogdGhlIG5vZGUgdG8gY2xvc2VcXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhbmltYXRpb24gdGhlIGFuaW1hdGlvbiBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMgd2hlbiBjbG9zaW5nIHRoZSBub2RlIChvdmVycmlkZXMgdGhlIGBjb3JlLmFuaW1hdGlvbmAgc2V0dGluZykuIFVzZSBgZmFsc2VgIGZvciBubyBhbmltYXRpb24uXFxuICAgKiBAdHJpZ2dlciBjbG9zZV9ub2RlLmpzdHJlZSwgYWZ0ZXJfY2xvc2UuanN0cmVlXFxuICAgKi9cXG5cXHRcXHRjbG9zZV9ub2RlOiBmdW5jdGlvbiBjbG9zZV9ub2RlKG9iaiwgYW5pbWF0aW9uKSB7XFxuXFx0XFx0XFx0dmFyIHQxLCB0MiwgdCwgZDtcXG5cXHRcXHRcXHRpZiAoJC5pc0FycmF5KG9iaikpIHtcXG5cXHRcXHRcXHRcXHRvYmogPSBvYmouc2xpY2UoKTtcXG5cXHRcXHRcXHRcXHRmb3IgKHQxID0gMCwgdDIgPSBvYmoubGVuZ3RoOyB0MSA8IHQyOyB0MSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5jbG9zZV9ub2RlKG9ialt0MV0sIGFuaW1hdGlvbik7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XFxuXFx0XFx0XFx0aWYgKCFvYmogfHwgb2JqLmlkID09PSAkLmpzdHJlZS5yb290KSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAodGhpcy5pc19jbG9zZWQob2JqKSkge1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0YW5pbWF0aW9uID0gYW5pbWF0aW9uID09PSB1bmRlZmluZWQgPyB0aGlzLnNldHRpbmdzLmNvcmUuYW5pbWF0aW9uIDogYW5pbWF0aW9uO1xcblxcdFxcdFxcdHQgPSB0aGlzO1xcblxcdFxcdFxcdGQgPSB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSk7XFxuXFxuXFx0XFx0XFx0b2JqLnN0YXRlLm9wZW5lZCA9IGZhbHNlO1xcblxcdFxcdFxcdC8qKlxcbiAgICAqIHRyaWdnZXJlZCB3aGVuIGEgbm9kZSBpcyBjbG9zZWQgKGlmIHRoZXJlIGlzIGFuIGFuaW1hdGlvbiBpdCB3aWxsIG5vdCBiZSBjb21wbGV0ZSB5ZXQpXFxuICAgICogQGV2ZW50XFxuICAgICogQG5hbWUgY2xvc2Vfbm9kZS5qc3RyZWVcXG4gICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZSB0aGUgY2xvc2VkIG5vZGVcXG4gICAgKi9cXG5cXHRcXHRcXHR0aGlzLnRyaWdnZXIoJ2Nsb3NlX25vZGUnLCB7IFxcXCJub2RlXFxcIjogb2JqIH0pO1xcblxcdFxcdFxcdGlmICghZC5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHQvKipcXG4gICAgICogdHJpZ2dlcmVkIHdoZW4gYSBub2RlIGlzIGNsb3NlZCBhbmQgdGhlIGFuaW1hdGlvbiBpcyBjb21wbGV0ZVxcbiAgICAgKiBAZXZlbnRcXG4gICAgICogQG5hbWUgYWZ0ZXJfY2xvc2UuanN0cmVlXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIHRoZSBjbG9zZWQgbm9kZVxcbiAgICAgKi9cXG5cXHRcXHRcXHRcXHR0aGlzLnRyaWdnZXIoXFxcImFmdGVyX2Nsb3NlXFxcIiwgeyBcXFwibm9kZVxcXCI6IG9iaiB9KTtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdGlmICghYW5pbWF0aW9uKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZFswXS5jbGFzc05hbWUgPSBkWzBdLmNsYXNzTmFtZS5yZXBsYWNlKCdqc3RyZWUtb3BlbicsICdqc3RyZWUtY2xvc2VkJyk7XFxuXFx0XFx0XFx0XFx0XFx0ZC5hdHRyKFxcXCJhcmlhLWV4cGFuZGVkXFxcIiwgZmFsc2UpLmNoaWxkcmVuKCcuanN0cmVlLWNoaWxkcmVuJykucmVtb3ZlKCk7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy50cmlnZ2VyKFxcXCJhZnRlcl9jbG9zZVxcXCIsIHsgXFxcIm5vZGVcXFwiOiBvYmogfSk7XFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRkLmNoaWxkcmVuKFxcXCIuanN0cmVlLWNoaWxkcmVuXFxcIikuYXR0cihcXFwic3R5bGVcXFwiLCBcXFwiZGlzcGxheTpibG9jayAhaW1wb3J0YW50XFxcIikuZW5kKCkucmVtb3ZlQ2xhc3MoXFxcImpzdHJlZS1vcGVuXFxcIikuYWRkQ2xhc3MoXFxcImpzdHJlZS1jbG9zZWRcXFwiKS5hdHRyKFxcXCJhcmlhLWV4cGFuZGVkXFxcIiwgZmFsc2UpLmNoaWxkcmVuKFxcXCIuanN0cmVlLWNoaWxkcmVuXFxcIikuc3RvcCh0cnVlLCB0cnVlKS5zbGlkZVVwKGFuaW1hdGlvbiwgZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuc3R5bGUuZGlzcGxheSA9IFxcXCJcXFwiO1xcblxcdFxcdFxcdFxcdFxcdFxcdGQuY2hpbGRyZW4oJy5qc3RyZWUtY2hpbGRyZW4nKS5yZW1vdmUoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAodC5lbGVtZW50KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dC50cmlnZ2VyKFxcXCJhZnRlcl9jbG9zZVxcXCIsIHsgXFxcIm5vZGVcXFwiOiBvYmogfSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIHRvZ2dsZXMgYSBub2RlIC0gY2xvc2luZyBpdCBpZiBpdCBpcyBvcGVuLCBvcGVuaW5nIGl0IGlmIGl0IGlzIGNsb3NlZFxcbiAgICogQG5hbWUgdG9nZ2xlX25vZGUob2JqKVxcbiAgICogQHBhcmFtIHttaXhlZH0gb2JqIHRoZSBub2RlIHRvIHRvZ2dsZVxcbiAgICovXFxuXFx0XFx0dG9nZ2xlX25vZGU6IGZ1bmN0aW9uIHRvZ2dsZV9ub2RlKG9iaikge1xcblxcdFxcdFxcdHZhciB0MSwgdDI7XFxuXFx0XFx0XFx0aWYgKCQuaXNBcnJheShvYmopKSB7XFxuXFx0XFx0XFx0XFx0b2JqID0gb2JqLnNsaWNlKCk7XFxuXFx0XFx0XFx0XFx0Zm9yICh0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMudG9nZ2xlX25vZGUob2JqW3QxXSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAodGhpcy5pc19jbG9zZWQob2JqKSkge1xcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLm9wZW5fbm9kZShvYmopO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAodGhpcy5pc19vcGVuKG9iaikpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5jbG9zZV9ub2RlKG9iaik7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFx0XFx0LyoqXFxuICAgKiBvcGVucyBhbGwgbm9kZXMgd2l0aGluIGEgbm9kZSAob3IgdGhlIHRyZWUpLCByZXZhbGluZyB0aGVpciBjaGlsZHJlbi4gSWYgdGhlIG5vZGUgaXMgbm90IGxvYWRlZCBpdCB3aWxsIGJlIGxvYWRlZCBhbmQgb3BlbmVkIG9uY2UgcmVhZHkuXFxuICAgKiBAbmFtZSBvcGVuX2FsbChbb2JqLCBhbmltYXRpb24sIG9yaWdpbmFsX29ial0pXFxuICAgKiBAcGFyYW0ge21peGVkfSBvYmogdGhlIG5vZGUgdG8gb3BlbiByZWN1cnNpdmVseSwgb21pdCB0byBvcGVuIGFsbCBub2RlcyBpbiB0aGUgdHJlZVxcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFuaW1hdGlvbiB0aGUgYW5pbWF0aW9uIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcyB3aGVuIG9wZW5pbmcgdGhlIG5vZGVzLCB0aGUgZGVmYXVsdCBpcyBubyBhbmltYXRpb25cXG4gICAqIEBwYXJhbSB7alF1ZXJ5fSByZWZlcmVuY2UgdG8gdGhlIG5vZGUgdGhhdCBzdGFydGVkIHRoZSBwcm9jZXNzIChpbnRlcm5hbCB1c2UpXFxuICAgKiBAdHJpZ2dlciBvcGVuX2FsbC5qc3RyZWVcXG4gICAqL1xcblxcdFxcdG9wZW5fYWxsOiBmdW5jdGlvbiBvcGVuX2FsbChvYmosIGFuaW1hdGlvbiwgb3JpZ2luYWxfb2JqKSB7XFxuXFx0XFx0XFx0aWYgKCFvYmopIHtcXG5cXHRcXHRcXHRcXHRvYmogPSAkLmpzdHJlZS5yb290O1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XFxuXFx0XFx0XFx0aWYgKCFvYmopIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHZhciBkb20gPSBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QgPyB0aGlzLmdldF9jb250YWluZXJfdWwoKSA6IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKSxcXG5cXHRcXHRcXHQgICAgaSxcXG5cXHRcXHRcXHQgICAgaixcXG5cXHRcXHRcXHQgICAgX3RoaXM7XFxuXFx0XFx0XFx0aWYgKCFkb20ubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0Zm9yIChpID0gMCwgaiA9IG9iai5jaGlsZHJlbl9kLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdGlmICh0aGlzLmlzX2Nsb3NlZCh0aGlzLl9tb2RlbC5kYXRhW29iai5jaGlsZHJlbl9kW2ldXSkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl9tb2RlbC5kYXRhW29iai5jaGlsZHJlbl9kW2ldXS5zdGF0ZS5vcGVuZWQgPSB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMudHJpZ2dlcignb3Blbl9hbGwnLCB7IFxcXCJub2RlXFxcIjogb2JqIH0pO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRvcmlnaW5hbF9vYmogPSBvcmlnaW5hbF9vYmogfHwgZG9tO1xcblxcdFxcdFxcdF90aGlzID0gdGhpcztcXG5cXHRcXHRcXHRkb20gPSB0aGlzLmlzX2Nsb3NlZChvYmopID8gZG9tLmZpbmQoJy5qc3RyZWUtY2xvc2VkJykuYWRkQmFjaygpIDogZG9tLmZpbmQoJy5qc3RyZWUtY2xvc2VkJyk7XFxuXFx0XFx0XFx0ZG9tLmVhY2goZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdF90aGlzLm9wZW5fbm9kZSh0aGlzLCBmdW5jdGlvbiAobm9kZSwgc3RhdHVzKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHN0YXR1cyAmJiB0aGlzLmlzX3BhcmVudChub2RlKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMub3Blbl9hbGwobm9kZSwgYW5pbWF0aW9uLCBvcmlnaW5hbF9vYmopO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9LCBhbmltYXRpb24gfHwgMCk7XFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0aWYgKG9yaWdpbmFsX29iai5maW5kKCcuanN0cmVlLWNsb3NlZCcpLmxlbmd0aCA9PT0gMCkge1xcblxcdFxcdFxcdFxcdC8qKlxcbiAgICAgKiB0cmlnZ2VyZWQgd2hlbiBhbiBgb3Blbl9hbGxgIGNhbGwgY29tcGxldGVzXFxuICAgICAqIEBldmVudFxcbiAgICAgKiBAbmFtZSBvcGVuX2FsbC5qc3RyZWVcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGUgdGhlIG9wZW5lZCBub2RlXFxuICAgICAqL1xcblxcdFxcdFxcdFxcdHRoaXMudHJpZ2dlcignb3Blbl9hbGwnLCB7IFxcXCJub2RlXFxcIjogdGhpcy5nZXRfbm9kZShvcmlnaW5hbF9vYmopIH0pO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogY2xvc2VzIGFsbCBub2RlcyB3aXRoaW4gYSBub2RlIChvciB0aGUgdHJlZSksIHJldmFsaW5nIHRoZWlyIGNoaWxkcmVuXFxuICAgKiBAbmFtZSBjbG9zZV9hbGwoW29iaiwgYW5pbWF0aW9uXSlcXG4gICAqIEBwYXJhbSB7bWl4ZWR9IG9iaiB0aGUgbm9kZSB0byBjbG9zZSByZWN1cnNpdmVseSwgb21pdCB0byBjbG9zZSBhbGwgbm9kZXMgaW4gdGhlIHRyZWVcXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhbmltYXRpb24gdGhlIGFuaW1hdGlvbiBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMgd2hlbiBjbG9zaW5nIHRoZSBub2RlcywgdGhlIGRlZmF1bHQgaXMgbm8gYW5pbWF0aW9uXFxuICAgKiBAdHJpZ2dlciBjbG9zZV9hbGwuanN0cmVlXFxuICAgKi9cXG5cXHRcXHRjbG9zZV9hbGw6IGZ1bmN0aW9uIGNsb3NlX2FsbChvYmosIGFuaW1hdGlvbikge1xcblxcdFxcdFxcdGlmICghb2JqKSB7XFxuXFx0XFx0XFx0XFx0b2JqID0gJC5qc3RyZWUucm9vdDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xcblxcdFxcdFxcdGlmICghb2JqKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR2YXIgZG9tID0gb2JqLmlkID09PSAkLmpzdHJlZS5yb290ID8gdGhpcy5nZXRfY29udGFpbmVyX3VsKCkgOiB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSksXFxuXFx0XFx0XFx0ICAgIF90aGlzID0gdGhpcyxcXG5cXHRcXHRcXHQgICAgaSxcXG5cXHRcXHRcXHQgICAgajtcXG5cXHRcXHRcXHRpZiAoZG9tLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdGRvbSA9IHRoaXMuaXNfb3BlbihvYmopID8gZG9tLmZpbmQoJy5qc3RyZWUtb3BlbicpLmFkZEJhY2soKSA6IGRvbS5maW5kKCcuanN0cmVlLW9wZW4nKTtcXG5cXHRcXHRcXHRcXHQkKGRvbS5nZXQoKS5yZXZlcnNlKCkpLmVhY2goZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdF90aGlzLmNsb3NlX25vZGUodGhpcywgYW5pbWF0aW9uIHx8IDApO1xcblxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRmb3IgKGkgPSAwLCBqID0gb2JqLmNoaWxkcmVuX2QubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5fbW9kZWwuZGF0YVtvYmouY2hpbGRyZW5fZFtpXV0uc3RhdGUub3BlbmVkID0gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdC8qKlxcbiAgICAqIHRyaWdnZXJlZCB3aGVuIGFuIGBjbG9zZV9hbGxgIGNhbGwgY29tcGxldGVzXFxuICAgICogQGV2ZW50XFxuICAgICogQG5hbWUgY2xvc2VfYWxsLmpzdHJlZVxcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIHRoZSBjbG9zZWQgbm9kZVxcbiAgICAqL1xcblxcdFxcdFxcdHRoaXMudHJpZ2dlcignY2xvc2VfYWxsJywgeyBcXFwibm9kZVxcXCI6IG9iaiB9KTtcXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogY2hlY2tzIGlmIGEgbm9kZSBpcyBkaXNhYmxlZCAobm90IHNlbGVjdGFibGUpXFxuICAgKiBAbmFtZSBpc19kaXNhYmxlZChvYmopXFxuICAgKiBAcGFyYW0gIHttaXhlZH0gb2JqXFxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxcbiAgICovXFxuXFx0XFx0aXNfZGlzYWJsZWQ6IGZ1bmN0aW9uIGlzX2Rpc2FibGVkKG9iaikge1xcblxcdFxcdFxcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXHRcXHRcXHRyZXR1cm4gb2JqICYmIG9iai5zdGF0ZSAmJiBvYmouc3RhdGUuZGlzYWJsZWQ7XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIGVuYWJsZXMgYSBub2RlIC0gc28gdGhhdCBpdCBjYW4gYmUgc2VsZWN0ZWRcXG4gICAqIEBuYW1lIGVuYWJsZV9ub2RlKG9iailcXG4gICAqIEBwYXJhbSB7bWl4ZWR9IG9iaiB0aGUgbm9kZSB0byBlbmFibGVcXG4gICAqIEB0cmlnZ2VyIGVuYWJsZV9ub2RlLmpzdHJlZVxcbiAgICovXFxuXFx0XFx0ZW5hYmxlX25vZGU6IGZ1bmN0aW9uIGVuYWJsZV9ub2RlKG9iaikge1xcblxcdFxcdFxcdHZhciB0MSwgdDI7XFxuXFx0XFx0XFx0aWYgKCQuaXNBcnJheShvYmopKSB7XFxuXFx0XFx0XFx0XFx0b2JqID0gb2JqLnNsaWNlKCk7XFxuXFx0XFx0XFx0XFx0Zm9yICh0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuZW5hYmxlX25vZGUob2JqW3QxXSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XFxuXFx0XFx0XFx0aWYgKCFvYmogfHwgb2JqLmlkID09PSAkLmpzdHJlZS5yb290KSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRvYmouc3RhdGUuZGlzYWJsZWQgPSBmYWxzZTtcXG5cXHRcXHRcXHR0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSkuY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykucmVtb3ZlQ2xhc3MoJ2pzdHJlZS1kaXNhYmxlZCcpLmF0dHIoJ2FyaWEtZGlzYWJsZWQnLCBmYWxzZSk7XFxuXFx0XFx0XFx0LyoqXFxuICAgICogdHJpZ2dlcmVkIHdoZW4gYW4gbm9kZSBpcyBlbmFibGVkXFxuICAgICogQGV2ZW50XFxuICAgICogQG5hbWUgZW5hYmxlX25vZGUuanN0cmVlXFxuICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGUgdGhlIGVuYWJsZWQgbm9kZVxcbiAgICAqL1xcblxcdFxcdFxcdHRoaXMudHJpZ2dlcignZW5hYmxlX25vZGUnLCB7ICdub2RlJzogb2JqIH0pO1xcblxcdFxcdH0sXFxuXFx0XFx0LyoqXFxuICAgKiBkaXNhYmxlcyBhIG5vZGUgLSBzbyB0aGF0IGl0IGNhbiBub3QgYmUgc2VsZWN0ZWRcXG4gICAqIEBuYW1lIGRpc2FibGVfbm9kZShvYmopXFxuICAgKiBAcGFyYW0ge21peGVkfSBvYmogdGhlIG5vZGUgdG8gZGlzYWJsZVxcbiAgICogQHRyaWdnZXIgZGlzYWJsZV9ub2RlLmpzdHJlZVxcbiAgICovXFxuXFx0XFx0ZGlzYWJsZV9ub2RlOiBmdW5jdGlvbiBkaXNhYmxlX25vZGUob2JqKSB7XFxuXFx0XFx0XFx0dmFyIHQxLCB0MjtcXG5cXHRcXHRcXHRpZiAoJC5pc0FycmF5KG9iaikpIHtcXG5cXHRcXHRcXHRcXHRvYmogPSBvYmouc2xpY2UoKTtcXG5cXHRcXHRcXHRcXHRmb3IgKHQxID0gMCwgdDIgPSBvYmoubGVuZ3RoOyB0MSA8IHQyOyB0MSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5kaXNhYmxlX25vZGUob2JqW3QxXSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XFxuXFx0XFx0XFx0aWYgKCFvYmogfHwgb2JqLmlkID09PSAkLmpzdHJlZS5yb290KSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRvYmouc3RhdGUuZGlzYWJsZWQgPSB0cnVlO1xcblxcdFxcdFxcdHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKS5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5hZGRDbGFzcygnanN0cmVlLWRpc2FibGVkJykuYXR0cignYXJpYS1kaXNhYmxlZCcsIHRydWUpO1xcblxcdFxcdFxcdC8qKlxcbiAgICAqIHRyaWdnZXJlZCB3aGVuIGFuIG5vZGUgaXMgZGlzYWJsZWRcXG4gICAgKiBAZXZlbnRcXG4gICAgKiBAbmFtZSBkaXNhYmxlX25vZGUuanN0cmVlXFxuICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGUgdGhlIGRpc2FibGVkIG5vZGVcXG4gICAgKi9cXG5cXHRcXHRcXHR0aGlzLnRyaWdnZXIoJ2Rpc2FibGVfbm9kZScsIHsgJ25vZGUnOiBvYmogfSk7XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIGRldGVybWluZXMgaWYgYSBub2RlIGlzIGhpZGRlblxcbiAgICogQG5hbWUgaXNfaGlkZGVuKG9iailcXG4gICAqIEBwYXJhbSB7bWl4ZWR9IG9iaiB0aGUgbm9kZVxcbiAgICovXFxuXFx0XFx0aXNfaGlkZGVuOiBmdW5jdGlvbiBpc19oaWRkZW4ob2JqKSB7XFxuXFx0XFx0XFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xcblxcdFxcdFxcdHJldHVybiBvYmouc3RhdGUuaGlkZGVuID09PSB0cnVlO1xcblxcdFxcdH0sXFxuXFx0XFx0LyoqXFxuICAgKiBoaWRlcyBhIG5vZGUgLSBpdCBpcyBzdGlsbCBpbiB0aGUgc3RydWN0dXJlIGJ1dCB3aWxsIG5vdCBiZSB2aXNpYmxlXFxuICAgKiBAbmFtZSBoaWRlX25vZGUob2JqKVxcbiAgICogQHBhcmFtIHttaXhlZH0gb2JqIHRoZSBub2RlIHRvIGhpZGVcXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2tpcF9yZWRyYXcgaW50ZXJuYWwgcGFyYW1ldGVyIGNvbnRyb2xsaW5nIGlmIHJlZHJhdyBpcyBjYWxsZWRcXG4gICAqIEB0cmlnZ2VyIGhpZGVfbm9kZS5qc3RyZWVcXG4gICAqL1xcblxcdFxcdGhpZGVfbm9kZTogZnVuY3Rpb24gaGlkZV9ub2RlKG9iaiwgc2tpcF9yZWRyYXcpIHtcXG5cXHRcXHRcXHR2YXIgdDEsIHQyO1xcblxcdFxcdFxcdGlmICgkLmlzQXJyYXkob2JqKSkge1xcblxcdFxcdFxcdFxcdG9iaiA9IG9iai5zbGljZSgpO1xcblxcdFxcdFxcdFxcdGZvciAodDEgPSAwLCB0MiA9IG9iai5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmhpZGVfbm9kZShvYmpbdDFdLCB0cnVlKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aWYgKCFza2lwX3JlZHJhdykge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMucmVkcmF3KCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XFxuXFx0XFx0XFx0aWYgKCFvYmogfHwgb2JqLmlkID09PSAkLmpzdHJlZS5yb290KSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoIW9iai5zdGF0ZS5oaWRkZW4pIHtcXG5cXHRcXHRcXHRcXHRvYmouc3RhdGUuaGlkZGVuID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHR0aGlzLl9ub2RlX2NoYW5nZWQob2JqLnBhcmVudCk7XFxuXFx0XFx0XFx0XFx0aWYgKCFza2lwX3JlZHJhdykge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMucmVkcmF3KCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdC8qKlxcbiAgICAgKiB0cmlnZ2VyZWQgd2hlbiBhbiBub2RlIGlzIGhpZGRlblxcbiAgICAgKiBAZXZlbnRcXG4gICAgICogQG5hbWUgaGlkZV9ub2RlLmpzdHJlZVxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZSB0aGUgaGlkZGVuIG5vZGVcXG4gICAgICovXFxuXFx0XFx0XFx0XFx0dGhpcy50cmlnZ2VyKCdoaWRlX25vZGUnLCB7ICdub2RlJzogb2JqIH0pO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogc2hvd3MgYSBub2RlXFxuICAgKiBAbmFtZSBzaG93X25vZGUob2JqKVxcbiAgICogQHBhcmFtIHttaXhlZH0gb2JqIHRoZSBub2RlIHRvIHNob3dcXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2tpcF9yZWRyYXcgaW50ZXJuYWwgcGFyYW1ldGVyIGNvbnRyb2xsaW5nIGlmIHJlZHJhdyBpcyBjYWxsZWRcXG4gICAqIEB0cmlnZ2VyIHNob3dfbm9kZS5qc3RyZWVcXG4gICAqL1xcblxcdFxcdHNob3dfbm9kZTogZnVuY3Rpb24gc2hvd19ub2RlKG9iaiwgc2tpcF9yZWRyYXcpIHtcXG5cXHRcXHRcXHR2YXIgdDEsIHQyO1xcblxcdFxcdFxcdGlmICgkLmlzQXJyYXkob2JqKSkge1xcblxcdFxcdFxcdFxcdG9iaiA9IG9iai5zbGljZSgpO1xcblxcdFxcdFxcdFxcdGZvciAodDEgPSAwLCB0MiA9IG9iai5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnNob3dfbm9kZShvYmpbdDFdLCB0cnVlKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aWYgKCFza2lwX3JlZHJhdykge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMucmVkcmF3KCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XFxuXFx0XFx0XFx0aWYgKCFvYmogfHwgb2JqLmlkID09PSAkLmpzdHJlZS5yb290KSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAob2JqLnN0YXRlLmhpZGRlbikge1xcblxcdFxcdFxcdFxcdG9iai5zdGF0ZS5oaWRkZW4gPSBmYWxzZTtcXG5cXHRcXHRcXHRcXHR0aGlzLl9ub2RlX2NoYW5nZWQob2JqLnBhcmVudCk7XFxuXFx0XFx0XFx0XFx0aWYgKCFza2lwX3JlZHJhdykge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMucmVkcmF3KCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdC8qKlxcbiAgICAgKiB0cmlnZ2VyZWQgd2hlbiBhbiBub2RlIGlzIHNob3duXFxuICAgICAqIEBldmVudFxcbiAgICAgKiBAbmFtZSBzaG93X25vZGUuanN0cmVlXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIHRoZSBzaG93biBub2RlXFxuICAgICAqL1xcblxcdFxcdFxcdFxcdHRoaXMudHJpZ2dlcignc2hvd19ub2RlJywgeyAnbm9kZSc6IG9iaiB9KTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIGhpZGVzIGFsbCBub2Rlc1xcbiAgICogQG5hbWUgaGlkZV9hbGwoKVxcbiAgICogQHRyaWdnZXIgaGlkZV9hbGwuanN0cmVlXFxuICAgKi9cXG5cXHRcXHRoaWRlX2FsbDogZnVuY3Rpb24gaGlkZV9hbGwoc2tpcF9yZWRyYXcpIHtcXG5cXHRcXHRcXHR2YXIgaSxcXG5cXHRcXHRcXHQgICAgbSA9IHRoaXMuX21vZGVsLmRhdGEsXFxuXFx0XFx0XFx0ICAgIGlkcyA9IFtdO1xcblxcdFxcdFxcdGZvciAoaSBpbiBtKSB7XFxuXFx0XFx0XFx0XFx0aWYgKG0uaGFzT3duUHJvcGVydHkoaSkgJiYgaSAhPT0gJC5qc3RyZWUucm9vdCAmJiAhbVtpXS5zdGF0ZS5oaWRkZW4pIHtcXG5cXHRcXHRcXHRcXHRcXHRtW2ldLnN0YXRlLmhpZGRlbiA9IHRydWU7XFxuXFx0XFx0XFx0XFx0XFx0aWRzLnB1c2goaSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR0aGlzLl9tb2RlbC5mb3JjZV9mdWxsX3JlZHJhdyA9IHRydWU7XFxuXFx0XFx0XFx0aWYgKCFza2lwX3JlZHJhdykge1xcblxcdFxcdFxcdFxcdHRoaXMucmVkcmF3KCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdC8qKlxcbiAgICAqIHRyaWdnZXJlZCB3aGVuIGFsbCBub2RlcyBhcmUgaGlkZGVuXFxuICAgICogQGV2ZW50XFxuICAgICogQG5hbWUgaGlkZV9hbGwuanN0cmVlXFxuICAgICogQHBhcmFtIHtBcnJheX0gbm9kZXMgdGhlIElEcyBvZiBhbGwgaGlkZGVuIG5vZGVzXFxuICAgICovXFxuXFx0XFx0XFx0dGhpcy50cmlnZ2VyKCdoaWRlX2FsbCcsIHsgJ25vZGVzJzogaWRzIH0pO1xcblxcdFxcdFxcdHJldHVybiBpZHM7XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIHNob3dzIGFsbCBub2Rlc1xcbiAgICogQG5hbWUgc2hvd19hbGwoKVxcbiAgICogQHRyaWdnZXIgc2hvd19hbGwuanN0cmVlXFxuICAgKi9cXG5cXHRcXHRzaG93X2FsbDogZnVuY3Rpb24gc2hvd19hbGwoc2tpcF9yZWRyYXcpIHtcXG5cXHRcXHRcXHR2YXIgaSxcXG5cXHRcXHRcXHQgICAgbSA9IHRoaXMuX21vZGVsLmRhdGEsXFxuXFx0XFx0XFx0ICAgIGlkcyA9IFtdO1xcblxcdFxcdFxcdGZvciAoaSBpbiBtKSB7XFxuXFx0XFx0XFx0XFx0aWYgKG0uaGFzT3duUHJvcGVydHkoaSkgJiYgaSAhPT0gJC5qc3RyZWUucm9vdCAmJiBtW2ldLnN0YXRlLmhpZGRlbikge1xcblxcdFxcdFxcdFxcdFxcdG1baV0uc3RhdGUuaGlkZGVuID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0XFx0aWRzLnB1c2goaSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR0aGlzLl9tb2RlbC5mb3JjZV9mdWxsX3JlZHJhdyA9IHRydWU7XFxuXFx0XFx0XFx0aWYgKCFza2lwX3JlZHJhdykge1xcblxcdFxcdFxcdFxcdHRoaXMucmVkcmF3KCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdC8qKlxcbiAgICAqIHRyaWdnZXJlZCB3aGVuIGFsbCBub2RlcyBhcmUgc2hvd25cXG4gICAgKiBAZXZlbnRcXG4gICAgKiBAbmFtZSBzaG93X2FsbC5qc3RyZWVcXG4gICAgKiBAcGFyYW0ge0FycmF5fSBub2RlcyB0aGUgSURzIG9mIGFsbCBzaG93biBub2Rlc1xcbiAgICAqL1xcblxcdFxcdFxcdHRoaXMudHJpZ2dlcignc2hvd19hbGwnLCB7ICdub2Rlcyc6IGlkcyB9KTtcXG5cXHRcXHRcXHRyZXR1cm4gaWRzO1xcblxcdFxcdH0sXFxuXFx0XFx0LyoqXFxuICAgKiBjYWxsZWQgd2hlbiBhIG5vZGUgaXMgc2VsZWN0ZWQgYnkgdGhlIHVzZXIuIFVzZWQgaW50ZXJuYWxseS5cXG4gICAqIEBwcml2YXRlXFxuICAgKiBAbmFtZSBhY3RpdmF0ZV9ub2RlKG9iaiwgZSlcXG4gICAqIEBwYXJhbSB7bWl4ZWR9IG9iaiB0aGUgbm9kZVxcbiAgICogQHBhcmFtIHtPYmplY3R9IGUgdGhlIHJlbGF0ZWQgZXZlbnRcXG4gICAqIEB0cmlnZ2VyIGFjdGl2YXRlX25vZGUuanN0cmVlLCBjaGFuZ2VkLmpzdHJlZVxcbiAgICovXFxuXFx0XFx0YWN0aXZhdGVfbm9kZTogZnVuY3Rpb24gYWN0aXZhdGVfbm9kZShvYmosIGUpIHtcXG5cXHRcXHRcXHRpZiAodGhpcy5pc19kaXNhYmxlZChvYmopKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoIWUgfHwgKHR5cGVvZiBlID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihlKSkgIT09ICdvYmplY3QnKSB7XFxuXFx0XFx0XFx0XFx0ZSA9IHt9O1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBlbnN1cmUgbGFzdF9jbGlja2VkIGlzIHN0aWxsIGluIHRoZSBET00sIG1ha2UgaXQgZnJlc2ggKG1heWJlIGl0IHdhcyBtb3ZlZD8pIGFuZCBtYWtlIHN1cmUgaXQgaXMgc3RpbGwgc2VsZWN0ZWQsIGlmIG5vdCAtIG1ha2UgbGFzdF9jbGlja2VkIHRoZSBsYXN0IHNlbGVjdGVkIG5vZGVcXG5cXHRcXHRcXHR0aGlzLl9kYXRhLmNvcmUubGFzdF9jbGlja2VkID0gdGhpcy5fZGF0YS5jb3JlLmxhc3RfY2xpY2tlZCAmJiB0aGlzLl9kYXRhLmNvcmUubGFzdF9jbGlja2VkLmlkICE9PSB1bmRlZmluZWQgPyB0aGlzLmdldF9ub2RlKHRoaXMuX2RhdGEuY29yZS5sYXN0X2NsaWNrZWQuaWQpIDogbnVsbDtcXG5cXHRcXHRcXHRpZiAodGhpcy5fZGF0YS5jb3JlLmxhc3RfY2xpY2tlZCAmJiAhdGhpcy5fZGF0YS5jb3JlLmxhc3RfY2xpY2tlZC5zdGF0ZS5zZWxlY3RlZCkge1xcblxcdFxcdFxcdFxcdHRoaXMuX2RhdGEuY29yZS5sYXN0X2NsaWNrZWQgPSBudWxsO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoIXRoaXMuX2RhdGEuY29yZS5sYXN0X2NsaWNrZWQgJiYgdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdHRoaXMuX2RhdGEuY29yZS5sYXN0X2NsaWNrZWQgPSB0aGlzLmdldF9ub2RlKHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZFt0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQubGVuZ3RoIC0gMV0pO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIXRoaXMuc2V0dGluZ3MuY29yZS5tdWx0aXBsZSB8fCAhZS5tZXRhS2V5ICYmICFlLmN0cmxLZXkgJiYgIWUuc2hpZnRLZXkgfHwgZS5zaGlmdEtleSAmJiAoIXRoaXMuX2RhdGEuY29yZS5sYXN0X2NsaWNrZWQgfHwgIXRoaXMuZ2V0X3BhcmVudChvYmopIHx8IHRoaXMuZ2V0X3BhcmVudChvYmopICE9PSB0aGlzLl9kYXRhLmNvcmUubGFzdF9jbGlja2VkLnBhcmVudCkpIHtcXG5cXHRcXHRcXHRcXHRpZiAoIXRoaXMuc2V0dGluZ3MuY29yZS5tdWx0aXBsZSAmJiAoZS5tZXRhS2V5IHx8IGUuY3RybEtleSB8fCBlLnNoaWZ0S2V5KSAmJiB0aGlzLmlzX3NlbGVjdGVkKG9iaikpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmRlc2VsZWN0X25vZGUob2JqLCBmYWxzZSwgZSk7XFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmRlc2VsZWN0X2FsbCh0cnVlKTtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnNlbGVjdF9ub2RlKG9iaiwgZmFsc2UsIGZhbHNlLCBlKTtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9kYXRhLmNvcmUubGFzdF9jbGlja2VkID0gdGhpcy5nZXRfbm9kZShvYmopO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdGlmIChlLnNoaWZ0S2V5KSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIG8gPSB0aGlzLmdldF9ub2RlKG9iaikuaWQsXFxuXFx0XFx0XFx0XFx0XFx0ICAgIGwgPSB0aGlzLl9kYXRhLmNvcmUubGFzdF9jbGlja2VkLmlkLFxcblxcdFxcdFxcdFxcdFxcdCAgICBwID0gdGhpcy5nZXRfbm9kZSh0aGlzLl9kYXRhLmNvcmUubGFzdF9jbGlja2VkLnBhcmVudCkuY2hpbGRyZW4sXFxuXFx0XFx0XFx0XFx0XFx0ICAgIGMgPSBmYWxzZSxcXG5cXHRcXHRcXHRcXHRcXHQgICAgaSxcXG5cXHRcXHRcXHRcXHRcXHQgICAgajtcXG5cXHRcXHRcXHRcXHRcXHRmb3IgKGkgPSAwLCBqID0gcC5sZW5ndGg7IGkgPCBqOyBpICs9IDEpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBzZXBhcmF0ZSBJRnMgd29yayB3aGVtIG8gYW5kIGwgYXJlIHRoZSBzYW1lXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKHBbaV0gPT09IG8pIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjID0gIWM7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChwW2ldID09PSBsKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YyA9ICFjO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIXRoaXMuaXNfZGlzYWJsZWQocFtpXSkgJiYgKGMgfHwgcFtpXSA9PT0gbyB8fCBwW2ldID09PSBsKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICghdGhpcy5pc19oaWRkZW4ocFtpXSkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLnNlbGVjdF9ub2RlKHBbaV0sIHRydWUsIGZhbHNlLCBlKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLmRlc2VsZWN0X25vZGUocFtpXSwgdHJ1ZSwgZSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnRyaWdnZXIoJ2NoYW5nZWQnLCB7ICdhY3Rpb24nOiAnc2VsZWN0X25vZGUnLCAnbm9kZSc6IHRoaXMuZ2V0X25vZGUob2JqKSwgJ3NlbGVjdGVkJzogdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLCAnZXZlbnQnOiBlIH0pO1xcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCF0aGlzLmlzX3NlbGVjdGVkKG9iaikpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLnNlbGVjdF9ub2RlKG9iaiwgZmFsc2UsIGZhbHNlLCBlKTtcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuZGVzZWxlY3Rfbm9kZShvYmosIGZhbHNlLCBlKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHQvKipcXG4gICAgKiB0cmlnZ2VyZWQgd2hlbiBhbiBub2RlIGlzIGNsaWNrZWQgb3IgaW50ZXJjYXRlZCB3aXRoIGJ5IHRoZSB1c2VyXFxuICAgICogQGV2ZW50XFxuICAgICogQG5hbWUgYWN0aXZhdGVfbm9kZS5qc3RyZWVcXG4gICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZVxcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCB0aGUgb29yaWdpbmFsIGV2ZW50IChpZiBhbnkpIHdoaWNoIHRyaWdnZXJlZCB0aGUgY2FsbCAobWF5IGJlIGFuIGVtcHR5IG9iamVjdClcXG4gICAgKi9cXG5cXHRcXHRcXHR0aGlzLnRyaWdnZXIoJ2FjdGl2YXRlX25vZGUnLCB7ICdub2RlJzogdGhpcy5nZXRfbm9kZShvYmopLCAnZXZlbnQnOiBlIH0pO1xcblxcdFxcdH0sXFxuXFx0XFx0LyoqXFxuICAgKiBhcHBsaWVzIHRoZSBob3ZlciBzdGF0ZSBvbiBhIG5vZGUsIGNhbGxlZCB3aGVuIGEgbm9kZSBpcyBob3ZlcmVkIGJ5IHRoZSB1c2VyLiBVc2VkIGludGVybmFsbHkuXFxuICAgKiBAcHJpdmF0ZVxcbiAgICogQG5hbWUgaG92ZXJfbm9kZShvYmopXFxuICAgKiBAcGFyYW0ge21peGVkfSBvYmpcXG4gICAqIEB0cmlnZ2VyIGhvdmVyX25vZGUuanN0cmVlXFxuICAgKi9cXG5cXHRcXHRob3Zlcl9ub2RlOiBmdW5jdGlvbiBob3Zlcl9ub2RlKG9iaikge1xcblxcdFxcdFxcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKTtcXG5cXHRcXHRcXHRpZiAoIW9iaiB8fCAhb2JqLmxlbmd0aCB8fCBvYmouY2hpbGRyZW4oJy5qc3RyZWUtaG92ZXJlZCcpLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0dmFyIG8gPSB0aGlzLmVsZW1lbnQuZmluZCgnLmpzdHJlZS1ob3ZlcmVkJyksXFxuXFx0XFx0XFx0ICAgIHQgPSB0aGlzLmVsZW1lbnQ7XFxuXFx0XFx0XFx0aWYgKG8gJiYgby5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLmRlaG92ZXJfbm9kZShvKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0b2JqLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLmFkZENsYXNzKCdqc3RyZWUtaG92ZXJlZCcpO1xcblxcdFxcdFxcdC8qKlxcbiAgICAqIHRyaWdnZXJlZCB3aGVuIGFuIG5vZGUgaXMgaG92ZXJlZFxcbiAgICAqIEBldmVudFxcbiAgICAqIEBuYW1lIGhvdmVyX25vZGUuanN0cmVlXFxuICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGVcXG4gICAgKi9cXG5cXHRcXHRcXHR0aGlzLnRyaWdnZXIoJ2hvdmVyX25vZGUnLCB7ICdub2RlJzogdGhpcy5nZXRfbm9kZShvYmopIH0pO1xcblxcdFxcdFxcdHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdHQuYXR0cignYXJpYS1hY3RpdmVkZXNjZW5kYW50Jywgb2JqWzBdLmlkKTtcXG5cXHRcXHRcXHR9LCAwKTtcXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogcmVtb3ZlcyB0aGUgaG92ZXIgc3RhdGUgZnJvbSBhIG5vZGVjYWxsZWQgd2hlbiBhIG5vZGUgaXMgbm8gbG9uZ2VyIGhvdmVyZWQgYnkgdGhlIHVzZXIuIFVzZWQgaW50ZXJuYWxseS5cXG4gICAqIEBwcml2YXRlXFxuICAgKiBAbmFtZSBkZWhvdmVyX25vZGUob2JqKVxcbiAgICogQHBhcmFtIHttaXhlZH0gb2JqXFxuICAgKiBAdHJpZ2dlciBkZWhvdmVyX25vZGUuanN0cmVlXFxuICAgKi9cXG5cXHRcXHRkZWhvdmVyX25vZGU6IGZ1bmN0aW9uIGRlaG92ZXJfbm9kZShvYmopIHtcXG5cXHRcXHRcXHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSk7XFxuXFx0XFx0XFx0aWYgKCFvYmogfHwgIW9iai5sZW5ndGggfHwgIW9iai5jaGlsZHJlbignLmpzdHJlZS1ob3ZlcmVkJykubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRvYmouY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykucmVtb3ZlQ2xhc3MoJ2pzdHJlZS1ob3ZlcmVkJyk7XFxuXFx0XFx0XFx0LyoqXFxuICAgICogdHJpZ2dlcmVkIHdoZW4gYW4gbm9kZSBpcyBubyBsb25nZXIgaG92ZXJlZFxcbiAgICAqIEBldmVudFxcbiAgICAqIEBuYW1lIGRlaG92ZXJfbm9kZS5qc3RyZWVcXG4gICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZVxcbiAgICAqL1xcblxcdFxcdFxcdHRoaXMudHJpZ2dlcignZGVob3Zlcl9ub2RlJywgeyAnbm9kZSc6IHRoaXMuZ2V0X25vZGUob2JqKSB9KTtcXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogc2VsZWN0IGEgbm9kZVxcbiAgICogQG5hbWUgc2VsZWN0X25vZGUob2JqIFssIHN1cHJlc3NfZXZlbnQsIHByZXZlbnRfb3Blbl0pXFxuICAgKiBAcGFyYW0ge21peGVkfSBvYmogYW4gYXJyYXkgY2FuIGJlIHVzZWQgdG8gc2VsZWN0IG11bHRpcGxlIG5vZGVzXFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHN1cHJlc3NfZXZlbnQgaWYgc2V0IHRvIGB0cnVlYCB0aGUgYGNoYW5nZWQuanN0cmVlYCBldmVudCB3b24ndCBiZSB0cmlnZ2VyZWRcXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gcHJldmVudF9vcGVuIGlmIHNldCB0byBgdHJ1ZWAgcGFyZW50cyBvZiB0aGUgc2VsZWN0ZWQgbm9kZSB3b24ndCBiZSBvcGVuZWRcXG4gICAqIEB0cmlnZ2VyIHNlbGVjdF9ub2RlLmpzdHJlZSwgY2hhbmdlZC5qc3RyZWVcXG4gICAqL1xcblxcdFxcdHNlbGVjdF9ub2RlOiBmdW5jdGlvbiBzZWxlY3Rfbm9kZShvYmosIHN1cHJlc3NfZXZlbnQsIHByZXZlbnRfb3BlbiwgZSkge1xcblxcdFxcdFxcdHZhciBkb20sIHQxLCB0MiwgdGg7XFxuXFx0XFx0XFx0aWYgKCQuaXNBcnJheShvYmopKSB7XFxuXFx0XFx0XFx0XFx0b2JqID0gb2JqLnNsaWNlKCk7XFxuXFx0XFx0XFx0XFx0Zm9yICh0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuc2VsZWN0X25vZGUob2JqW3QxXSwgc3VwcmVzc19ldmVudCwgcHJldmVudF9vcGVuLCBlKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXHRcXHRcXHRpZiAoIW9iaiB8fCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGRvbSA9IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKTtcXG5cXHRcXHRcXHRpZiAoIW9iai5zdGF0ZS5zZWxlY3RlZCkge1xcblxcdFxcdFxcdFxcdG9iai5zdGF0ZS5zZWxlY3RlZCA9IHRydWU7XFxuXFx0XFx0XFx0XFx0dGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLnB1c2gob2JqLmlkKTtcXG5cXHRcXHRcXHRcXHRpZiAoIXByZXZlbnRfb3Blbikge1xcblxcdFxcdFxcdFxcdFxcdGRvbSA9IHRoaXMuX29wZW5fdG8ob2JqKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aWYgKGRvbSAmJiBkb20ubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZG9tLmF0dHIoJ2FyaWEtc2VsZWN0ZWQnLCB0cnVlKS5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5hZGRDbGFzcygnanN0cmVlLWNsaWNrZWQnKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0LyoqXFxuICAgICAqIHRyaWdnZXJlZCB3aGVuIGFuIG5vZGUgaXMgc2VsZWN0ZWRcXG4gICAgICogQGV2ZW50XFxuICAgICAqIEBuYW1lIHNlbGVjdF9ub2RlLmpzdHJlZVxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZVxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBzZWxlY3RlZCB0aGUgY3VycmVudCBzZWxlY3Rpb25cXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IHRoZSBldmVudCAoaWYgYW55KSB0aGF0IHRyaWdnZXJlZCB0aGlzIHNlbGVjdF9ub2RlXFxuICAgICAqL1xcblxcdFxcdFxcdFxcdHRoaXMudHJpZ2dlcignc2VsZWN0X25vZGUnLCB7ICdub2RlJzogb2JqLCAnc2VsZWN0ZWQnOiB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQsICdldmVudCc6IGUgfSk7XFxuXFx0XFx0XFx0XFx0aWYgKCFzdXByZXNzX2V2ZW50KSB7XFxuXFx0XFx0XFx0XFx0XFx0LyoqXFxuICAgICAgKiB0cmlnZ2VyZWQgd2hlbiBzZWxlY3Rpb24gY2hhbmdlc1xcbiAgICAgICogQGV2ZW50XFxuICAgICAgKiBAbmFtZSBjaGFuZ2VkLmpzdHJlZVxcbiAgICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGVcXG4gICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24gdGhlIGFjdGlvbiB0aGF0IGNhdXNlZCB0aGUgc2VsZWN0aW9uIHRvIGNoYW5nZVxcbiAgICAgICogQHBhcmFtIHtBcnJheX0gc2VsZWN0ZWQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uXFxuICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgdGhlIGV2ZW50IChpZiBhbnkpIHRoYXQgdHJpZ2dlcmVkIHRoaXMgY2hhbmdlZCBldmVudFxcbiAgICAgICovXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy50cmlnZ2VyKCdjaGFuZ2VkJywgeyAnYWN0aW9uJzogJ3NlbGVjdF9ub2RlJywgJ25vZGUnOiBvYmosICdzZWxlY3RlZCc6IHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZCwgJ2V2ZW50JzogZSB9KTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFx0XFx0LyoqXFxuICAgKiBkZXNlbGVjdCBhIG5vZGVcXG4gICAqIEBuYW1lIGRlc2VsZWN0X25vZGUob2JqIFssIHN1cHJlc3NfZXZlbnRdKVxcbiAgICogQHBhcmFtIHttaXhlZH0gb2JqIGFuIGFycmF5IGNhbiBiZSB1c2VkIHRvIGRlc2VsZWN0IG11bHRpcGxlIG5vZGVzXFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHN1cHJlc3NfZXZlbnQgaWYgc2V0IHRvIGB0cnVlYCB0aGUgYGNoYW5nZWQuanN0cmVlYCBldmVudCB3b24ndCBiZSB0cmlnZ2VyZWRcXG4gICAqIEB0cmlnZ2VyIGRlc2VsZWN0X25vZGUuanN0cmVlLCBjaGFuZ2VkLmpzdHJlZVxcbiAgICovXFxuXFx0XFx0ZGVzZWxlY3Rfbm9kZTogZnVuY3Rpb24gZGVzZWxlY3Rfbm9kZShvYmosIHN1cHJlc3NfZXZlbnQsIGUpIHtcXG5cXHRcXHRcXHR2YXIgdDEsIHQyLCBkb207XFxuXFx0XFx0XFx0aWYgKCQuaXNBcnJheShvYmopKSB7XFxuXFx0XFx0XFx0XFx0b2JqID0gb2JqLnNsaWNlKCk7XFxuXFx0XFx0XFx0XFx0Zm9yICh0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuZGVzZWxlY3Rfbm9kZShvYmpbdDFdLCBzdXByZXNzX2V2ZW50LCBlKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXHRcXHRcXHRpZiAoIW9iaiB8fCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGRvbSA9IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKTtcXG5cXHRcXHRcXHRpZiAob2JqLnN0YXRlLnNlbGVjdGVkKSB7XFxuXFx0XFx0XFx0XFx0b2JqLnN0YXRlLnNlbGVjdGVkID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0dGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkID0gJC52YWthdGEuYXJyYXlfcmVtb3ZlX2l0ZW0odGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLCBvYmouaWQpO1xcblxcdFxcdFxcdFxcdGlmIChkb20ubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZG9tLmF0dHIoJ2FyaWEtc2VsZWN0ZWQnLCBmYWxzZSkuY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykucmVtb3ZlQ2xhc3MoJ2pzdHJlZS1jbGlja2VkJyk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdC8qKlxcbiAgICAgKiB0cmlnZ2VyZWQgd2hlbiBhbiBub2RlIGlzIGRlc2VsZWN0ZWRcXG4gICAgICogQGV2ZW50XFxuICAgICAqIEBuYW1lIGRlc2VsZWN0X25vZGUuanN0cmVlXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlXFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHNlbGVjdGVkIHRoZSBjdXJyZW50IHNlbGVjdGlvblxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgdGhlIGV2ZW50IChpZiBhbnkpIHRoYXQgdHJpZ2dlcmVkIHRoaXMgZGVzZWxlY3Rfbm9kZVxcbiAgICAgKi9cXG5cXHRcXHRcXHRcXHR0aGlzLnRyaWdnZXIoJ2Rlc2VsZWN0X25vZGUnLCB7ICdub2RlJzogb2JqLCAnc2VsZWN0ZWQnOiB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQsICdldmVudCc6IGUgfSk7XFxuXFx0XFx0XFx0XFx0aWYgKCFzdXByZXNzX2V2ZW50KSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy50cmlnZ2VyKCdjaGFuZ2VkJywgeyAnYWN0aW9uJzogJ2Rlc2VsZWN0X25vZGUnLCAnbm9kZSc6IG9iaiwgJ3NlbGVjdGVkJzogdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLCAnZXZlbnQnOiBlIH0pO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIHNlbGVjdCBhbGwgbm9kZXMgaW4gdGhlIHRyZWVcXG4gICAqIEBuYW1lIHNlbGVjdF9hbGwoW3N1cHJlc3NfZXZlbnRdKVxcbiAgICogQHBhcmFtIHtCb29sZWFufSBzdXByZXNzX2V2ZW50IGlmIHNldCB0byBgdHJ1ZWAgdGhlIGBjaGFuZ2VkLmpzdHJlZWAgZXZlbnQgd29uJ3QgYmUgdHJpZ2dlcmVkXFxuICAgKiBAdHJpZ2dlciBzZWxlY3RfYWxsLmpzdHJlZSwgY2hhbmdlZC5qc3RyZWVcXG4gICAqL1xcblxcdFxcdHNlbGVjdF9hbGw6IGZ1bmN0aW9uIHNlbGVjdF9hbGwoc3VwcmVzc19ldmVudCkge1xcblxcdFxcdFxcdHZhciB0bXAgPSB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQuY29uY2F0KFtdKSxcXG5cXHRcXHRcXHQgICAgaSxcXG5cXHRcXHRcXHQgICAgajtcXG5cXHRcXHRcXHR0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQgPSB0aGlzLl9tb2RlbC5kYXRhWyQuanN0cmVlLnJvb3RdLmNoaWxkcmVuX2QuY29uY2F0KCk7XFxuXFx0XFx0XFx0Zm9yIChpID0gMCwgaiA9IHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRpZiAodGhpcy5fbW9kZWwuZGF0YVt0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWRbaV1dKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fbW9kZWwuZGF0YVt0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWRbaV1dLnN0YXRlLnNlbGVjdGVkID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHRoaXMucmVkcmF3KHRydWUpO1xcblxcdFxcdFxcdC8qKlxcbiAgICAqIHRyaWdnZXJlZCB3aGVuIGFsbCBub2RlcyBhcmUgc2VsZWN0ZWRcXG4gICAgKiBAZXZlbnRcXG4gICAgKiBAbmFtZSBzZWxlY3RfYWxsLmpzdHJlZVxcbiAgICAqIEBwYXJhbSB7QXJyYXl9IHNlbGVjdGVkIHRoZSBjdXJyZW50IHNlbGVjdGlvblxcbiAgICAqL1xcblxcdFxcdFxcdHRoaXMudHJpZ2dlcignc2VsZWN0X2FsbCcsIHsgJ3NlbGVjdGVkJzogdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkIH0pO1xcblxcdFxcdFxcdGlmICghc3VwcmVzc19ldmVudCkge1xcblxcdFxcdFxcdFxcdHRoaXMudHJpZ2dlcignY2hhbmdlZCcsIHsgJ2FjdGlvbic6ICdzZWxlY3RfYWxsJywgJ3NlbGVjdGVkJzogdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLCAnb2xkX3NlbGVjdGlvbic6IHRtcCB9KTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIGRlc2VsZWN0IGFsbCBzZWxlY3RlZCBub2Rlc1xcbiAgICogQG5hbWUgZGVzZWxlY3RfYWxsKFtzdXByZXNzX2V2ZW50XSlcXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gc3VwcmVzc19ldmVudCBpZiBzZXQgdG8gYHRydWVgIHRoZSBgY2hhbmdlZC5qc3RyZWVgIGV2ZW50IHdvbid0IGJlIHRyaWdnZXJlZFxcbiAgICogQHRyaWdnZXIgZGVzZWxlY3RfYWxsLmpzdHJlZSwgY2hhbmdlZC5qc3RyZWVcXG4gICAqL1xcblxcdFxcdGRlc2VsZWN0X2FsbDogZnVuY3Rpb24gZGVzZWxlY3RfYWxsKHN1cHJlc3NfZXZlbnQpIHtcXG5cXHRcXHRcXHR2YXIgdG1wID0gdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLmNvbmNhdChbXSksXFxuXFx0XFx0XFx0ICAgIGksXFxuXFx0XFx0XFx0ICAgIGo7XFxuXFx0XFx0XFx0Zm9yIChpID0gMCwgaiA9IHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRpZiAodGhpcy5fbW9kZWwuZGF0YVt0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWRbaV1dKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fbW9kZWwuZGF0YVt0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWRbaV1dLnN0YXRlLnNlbGVjdGVkID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQgPSBbXTtcXG5cXHRcXHRcXHR0aGlzLmVsZW1lbnQuZmluZCgnLmpzdHJlZS1jbGlja2VkJykucmVtb3ZlQ2xhc3MoJ2pzdHJlZS1jbGlja2VkJykucGFyZW50KCkuYXR0cignYXJpYS1zZWxlY3RlZCcsIGZhbHNlKTtcXG5cXHRcXHRcXHQvKipcXG4gICAgKiB0cmlnZ2VyZWQgd2hlbiBhbGwgbm9kZXMgYXJlIGRlc2VsZWN0ZWRcXG4gICAgKiBAZXZlbnRcXG4gICAgKiBAbmFtZSBkZXNlbGVjdF9hbGwuanN0cmVlXFxuICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGUgdGhlIHByZXZpb3VzIHNlbGVjdGlvblxcbiAgICAqIEBwYXJhbSB7QXJyYXl9IHNlbGVjdGVkIHRoZSBjdXJyZW50IHNlbGVjdGlvblxcbiAgICAqL1xcblxcdFxcdFxcdHRoaXMudHJpZ2dlcignZGVzZWxlY3RfYWxsJywgeyAnc2VsZWN0ZWQnOiB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQsICdub2RlJzogdG1wIH0pO1xcblxcdFxcdFxcdGlmICghc3VwcmVzc19ldmVudCkge1xcblxcdFxcdFxcdFxcdHRoaXMudHJpZ2dlcignY2hhbmdlZCcsIHsgJ2FjdGlvbic6ICdkZXNlbGVjdF9hbGwnLCAnc2VsZWN0ZWQnOiB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQsICdvbGRfc2VsZWN0aW9uJzogdG1wIH0pO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogY2hlY2tzIGlmIGEgbm9kZSBpcyBzZWxlY3RlZFxcbiAgICogQG5hbWUgaXNfc2VsZWN0ZWQob2JqKVxcbiAgICogQHBhcmFtICB7bWl4ZWR9ICBvYmpcXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XFxuICAgKi9cXG5cXHRcXHRpc19zZWxlY3RlZDogZnVuY3Rpb24gaXNfc2VsZWN0ZWQob2JqKSB7XFxuXFx0XFx0XFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xcblxcdFxcdFxcdGlmICghb2JqIHx8IG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCkge1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIG9iai5zdGF0ZS5zZWxlY3RlZDtcXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogZ2V0IGFuIGFycmF5IG9mIGFsbCBzZWxlY3RlZCBub2Rlc1xcbiAgICogQG5hbWUgZ2V0X3NlbGVjdGVkKFtmdWxsXSlcXG4gICAqIEBwYXJhbSAge21peGVkfSAgZnVsbCBpZiBzZXQgdG8gYHRydWVgIHRoZSByZXR1cm5lZCBhcnJheSB3aWxsIGNvbnNpc3Qgb2YgdGhlIGZ1bGwgbm9kZSBvYmplY3RzLCBvdGhlcndpc2UgLSBvbmx5IElEcyB3aWxsIGJlIHJldHVybmVkXFxuICAgKiBAcmV0dXJuIHtBcnJheX1cXG4gICAqL1xcblxcdFxcdGdldF9zZWxlY3RlZDogZnVuY3Rpb24gZ2V0X3NlbGVjdGVkKGZ1bGwpIHtcXG5cXHRcXHRcXHRyZXR1cm4gZnVsbCA/ICQubWFwKHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZCwgJC5wcm94eShmdW5jdGlvbiAoaSkge1xcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLmdldF9ub2RlKGkpO1xcblxcdFxcdFxcdH0sIHRoaXMpKSA6IHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZC5zbGljZSgpO1xcblxcdFxcdH0sXFxuXFx0XFx0LyoqXFxuICAgKiBnZXQgYW4gYXJyYXkgb2YgYWxsIHRvcCBsZXZlbCBzZWxlY3RlZCBub2RlcyAoaWdub3JpbmcgY2hpbGRyZW4gb2Ygc2VsZWN0ZWQgbm9kZXMpXFxuICAgKiBAbmFtZSBnZXRfdG9wX3NlbGVjdGVkKFtmdWxsXSlcXG4gICAqIEBwYXJhbSAge21peGVkfSAgZnVsbCBpZiBzZXQgdG8gYHRydWVgIHRoZSByZXR1cm5lZCBhcnJheSB3aWxsIGNvbnNpc3Qgb2YgdGhlIGZ1bGwgbm9kZSBvYmplY3RzLCBvdGhlcndpc2UgLSBvbmx5IElEcyB3aWxsIGJlIHJldHVybmVkXFxuICAgKiBAcmV0dXJuIHtBcnJheX1cXG4gICAqL1xcblxcdFxcdGdldF90b3Bfc2VsZWN0ZWQ6IGZ1bmN0aW9uIGdldF90b3Bfc2VsZWN0ZWQoZnVsbCkge1xcblxcdFxcdFxcdHZhciB0bXAgPSB0aGlzLmdldF9zZWxlY3RlZCh0cnVlKSxcXG5cXHRcXHRcXHQgICAgb2JqID0ge30sXFxuXFx0XFx0XFx0ICAgIGksXFxuXFx0XFx0XFx0ICAgIGosXFxuXFx0XFx0XFx0ICAgIGssXFxuXFx0XFx0XFx0ICAgIGw7XFxuXFx0XFx0XFx0Zm9yIChpID0gMCwgaiA9IHRtcC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRvYmpbdG1wW2ldLmlkXSA9IHRtcFtpXTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0Zm9yIChpID0gMCwgaiA9IHRtcC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRmb3IgKGsgPSAwLCBsID0gdG1wW2ldLmNoaWxkcmVuX2QubGVuZ3RoOyBrIDwgbDsgaysrKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKG9ialt0bXBbaV0uY2hpbGRyZW5fZFtrXV0pIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRkZWxldGUgb2JqW3RtcFtpXS5jaGlsZHJlbl9kW2tdXTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR0bXAgPSBbXTtcXG5cXHRcXHRcXHRmb3IgKGkgaW4gb2JqKSB7XFxuXFx0XFx0XFx0XFx0aWYgKG9iai5oYXNPd25Qcm9wZXJ0eShpKSkge1xcblxcdFxcdFxcdFxcdFxcdHRtcC5wdXNoKGkpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIGZ1bGwgPyAkLm1hcCh0bXAsICQucHJveHkoZnVuY3Rpb24gKGkpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5nZXRfbm9kZShpKTtcXG5cXHRcXHRcXHR9LCB0aGlzKSkgOiB0bXA7XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIGdldCBhbiBhcnJheSBvZiBhbGwgYm90dG9tIGxldmVsIHNlbGVjdGVkIG5vZGVzIChpZ25vcmluZyBzZWxlY3RlZCBwYXJlbnRzKVxcbiAgICogQG5hbWUgZ2V0X2JvdHRvbV9zZWxlY3RlZChbZnVsbF0pXFxuICAgKiBAcGFyYW0gIHttaXhlZH0gIGZ1bGwgaWYgc2V0IHRvIGB0cnVlYCB0aGUgcmV0dXJuZWQgYXJyYXkgd2lsbCBjb25zaXN0IG9mIHRoZSBmdWxsIG5vZGUgb2JqZWN0cywgb3RoZXJ3aXNlIC0gb25seSBJRHMgd2lsbCBiZSByZXR1cm5lZFxcbiAgICogQHJldHVybiB7QXJyYXl9XFxuICAgKi9cXG5cXHRcXHRnZXRfYm90dG9tX3NlbGVjdGVkOiBmdW5jdGlvbiBnZXRfYm90dG9tX3NlbGVjdGVkKGZ1bGwpIHtcXG5cXHRcXHRcXHR2YXIgdG1wID0gdGhpcy5nZXRfc2VsZWN0ZWQodHJ1ZSksXFxuXFx0XFx0XFx0ICAgIG9iaiA9IFtdLFxcblxcdFxcdFxcdCAgICBpLFxcblxcdFxcdFxcdCAgICBqO1xcblxcdFxcdFxcdGZvciAoaSA9IDAsIGogPSB0bXAubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCF0bXBbaV0uY2hpbGRyZW4ubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0b2JqLnB1c2godG1wW2ldLmlkKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiBmdWxsID8gJC5tYXAob2JqLCAkLnByb3h5KGZ1bmN0aW9uIChpKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuZ2V0X25vZGUoaSk7XFxuXFx0XFx0XFx0fSwgdGhpcykpIDogb2JqO1xcblxcdFxcdH0sXFxuXFx0XFx0LyoqXFxuICAgKiBnZXRzIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSB0cmVlIHNvIHRoYXQgaXQgY2FuIGJlIHJlc3RvcmVkIGxhdGVyIHdpdGggYHNldF9zdGF0ZShzdGF0ZSlgLiBVc2VkIGludGVybmFsbHkuXFxuICAgKiBAbmFtZSBnZXRfc3RhdGUoKVxcbiAgICogQHByaXZhdGVcXG4gICAqIEByZXR1cm4ge09iamVjdH1cXG4gICAqL1xcblxcdFxcdGdldF9zdGF0ZTogZnVuY3Rpb24gZ2V0X3N0YXRlKCkge1xcblxcdFxcdFxcdHZhciBzdGF0ZSA9IHtcXG5cXHRcXHRcXHRcXHQnY29yZSc6IHtcXG5cXHRcXHRcXHRcXHRcXHQnb3Blbic6IFtdLFxcblxcdFxcdFxcdFxcdFxcdCdzY3JvbGwnOiB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0J2xlZnQnOiB0aGlzLmVsZW1lbnQuc2Nyb2xsTGVmdCgpLFxcblxcdFxcdFxcdFxcdFxcdFxcdCd0b3AnOiB0aGlzLmVsZW1lbnQuc2Nyb2xsVG9wKClcXG5cXHRcXHRcXHRcXHRcXHR9LFxcblxcdFxcdFxcdFxcdFxcdC8qIVxcbiAgICAgJ3RoZW1lcycgOiB7XFxuICAgICBcXHQnbmFtZScgOiB0aGlzLmdldF90aGVtZSgpLFxcbiAgICAgXFx0J2ljb25zJyA6IHRoaXMuX2RhdGEuY29yZS50aGVtZXMuaWNvbnMsXFxuICAgICBcXHQnZG90cycgOiB0aGlzLl9kYXRhLmNvcmUudGhlbWVzLmRvdHNcXG4gICAgIH0sXFxuICAgICAqL1xcblxcdFxcdFxcdFxcdFxcdCdzZWxlY3RlZCc6IFtdXFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0ICAgIGk7XFxuXFx0XFx0XFx0Zm9yIChpIGluIHRoaXMuX21vZGVsLmRhdGEpIHtcXG5cXHRcXHRcXHRcXHRpZiAodGhpcy5fbW9kZWwuZGF0YS5oYXNPd25Qcm9wZXJ0eShpKSkge1xcblxcdFxcdFxcdFxcdFxcdGlmIChpICE9PSAkLmpzdHJlZS5yb290KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKHRoaXMuX21vZGVsLmRhdGFbaV0uc3RhdGUub3BlbmVkKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c3RhdGUuY29yZS5vcGVuLnB1c2goaSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICh0aGlzLl9tb2RlbC5kYXRhW2ldLnN0YXRlLnNlbGVjdGVkKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c3RhdGUuY29yZS5zZWxlY3RlZC5wdXNoKGkpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gc3RhdGU7XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIHNldHMgdGhlIHN0YXRlIG9mIHRoZSB0cmVlLiBVc2VkIGludGVybmFsbHkuXFxuICAgKiBAbmFtZSBzZXRfc3RhdGUoc3RhdGUgWywgY2FsbGJhY2tdKVxcbiAgICogQHByaXZhdGVcXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZSB0aGUgc3RhdGUgdG8gcmVzdG9yZS4gS2VlcCBpbiBtaW5kIHRoaXMgb2JqZWN0IGlzIHBhc3NlZCBieSByZWZlcmVuY2UgYW5kIGpzdHJlZSB3aWxsIG1vZGlmeSBpdC5cXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGFuIG9wdGlvbmFsIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgb25jZSB0aGUgc3RhdGUgaXMgcmVzdG9yZWQuXFxuICAgKiBAdHJpZ2dlciBzZXRfc3RhdGUuanN0cmVlXFxuICAgKi9cXG5cXHRcXHRzZXRfc3RhdGU6IGZ1bmN0aW9uIHNldF9zdGF0ZShzdGF0ZSwgY2FsbGJhY2spIHtcXG5cXHRcXHRcXHRpZiAoc3RhdGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoc3RhdGUuY29yZSkge1xcblxcdFxcdFxcdFxcdFxcdHZhciByZXMsIG4sIHQsIF90aGlzLCBpO1xcblxcdFxcdFxcdFxcdFxcdGlmIChzdGF0ZS5jb3JlLm9wZW4pIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoISQuaXNBcnJheShzdGF0ZS5jb3JlLm9wZW4pIHx8ICFzdGF0ZS5jb3JlLm9wZW4ubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGVsZXRlIHN0YXRlLmNvcmUub3BlbjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLnNldF9zdGF0ZShzdGF0ZSwgY2FsbGJhY2spO1xcblxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5fbG9hZF9ub2RlcyhzdGF0ZS5jb3JlLm9wZW4sIGZ1bmN0aW9uIChub2Rlcykge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoaXMub3Blbl9ub2RlKG5vZGVzLCBmYWxzZSwgMCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGVsZXRlIHN0YXRlLmNvcmUub3BlbjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLnNldF9zdGF0ZShzdGF0ZSwgY2FsbGJhY2spO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmIChzdGF0ZS5jb3JlLnNjcm9sbCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChzdGF0ZS5jb3JlLnNjcm9sbCAmJiBzdGF0ZS5jb3JlLnNjcm9sbC5sZWZ0ICE9PSB1bmRlZmluZWQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLmVsZW1lbnQuc2Nyb2xsTGVmdChzdGF0ZS5jb3JlLnNjcm9sbC5sZWZ0KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKHN0YXRlLmNvcmUuc2Nyb2xsICYmIHN0YXRlLmNvcmUuc2Nyb2xsLnRvcCAhPT0gdW5kZWZpbmVkKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5lbGVtZW50LnNjcm9sbFRvcChzdGF0ZS5jb3JlLnNjcm9sbC50b3ApO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRkZWxldGUgc3RhdGUuY29yZS5zY3JvbGw7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5zZXRfc3RhdGUoc3RhdGUsIGNhbGxiYWNrKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmIChzdGF0ZS5jb3JlLnNlbGVjdGVkKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0X3RoaXMgPSB0aGlzO1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuZGVzZWxlY3RfYWxsKCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0JC5lYWNoKHN0YXRlLmNvcmUuc2VsZWN0ZWQsIGZ1bmN0aW9uIChpLCB2KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0X3RoaXMuc2VsZWN0X25vZGUodiwgZmFsc2UsIHRydWUpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdFxcdFxcdFxcdGRlbGV0ZSBzdGF0ZS5jb3JlLnNlbGVjdGVkO1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuc2V0X3N0YXRlKHN0YXRlLCBjYWxsYmFjayk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRmb3IgKGkgaW4gc3RhdGUpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoc3RhdGUuaGFzT3duUHJvcGVydHkoaSkgJiYgaSAhPT0gXFxcImNvcmVcXFwiICYmICQuaW5BcnJheShpLCB0aGlzLnNldHRpbmdzLnBsdWdpbnMpID09PSAtMSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGRlbGV0ZSBzdGF0ZVtpXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmICgkLmlzRW1wdHlPYmplY3Qoc3RhdGUuY29yZSkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRkZWxldGUgc3RhdGUuY29yZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLnNldF9zdGF0ZShzdGF0ZSwgY2FsbGJhY2spO1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGlmICgkLmlzRW1wdHlPYmplY3Qoc3RhdGUpKSB7XFxuXFx0XFx0XFx0XFx0XFx0c3RhdGUgPSBudWxsO1xcblxcdFxcdFxcdFxcdFxcdGlmIChjYWxsYmFjaykge1xcblxcdFxcdFxcdFxcdFxcdFxcdGNhbGxiYWNrLmNhbGwodGhpcyk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdC8qKlxcbiAgICAgICogdHJpZ2dlcmVkIHdoZW4gYSBgc2V0X3N0YXRlYCBjYWxsIGNvbXBsZXRlc1xcbiAgICAgICogQGV2ZW50XFxuICAgICAgKiBAbmFtZSBzZXRfc3RhdGUuanN0cmVlXFxuICAgICAgKi9cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnRyaWdnZXIoJ3NldF9zdGF0ZScpO1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogcmVmcmVzaGVzIHRoZSB0cmVlIC0gYWxsIG5vZGVzIGFyZSByZWxvYWRlZCB3aXRoIGNhbGxzIHRvIGBsb2FkX25vZGVgLlxcbiAgICogQG5hbWUgcmVmcmVzaCgpXFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNraXBfbG9hZGluZyBhbiBvcHRpb24gdG8gc2tpcCBzaG93aW5nIHRoZSBsb2FkaW5nIGluZGljYXRvclxcbiAgICogQHBhcmFtIHtNaXhlZH0gZm9yZ2V0X3N0YXRlIGlmIHNldCB0byBgdHJ1ZWAgc3RhdGUgd2lsbCBub3QgYmUgcmVhcHBsaWVkLCBpZiBzZXQgdG8gYSBmdW5jdGlvbiAocmVjZWl2aW5nIHRoZSBjdXJyZW50IHN0YXRlIGFzIGFyZ3VtZW50KSB0aGUgcmVzdWx0IG9mIHRoYXQgZnVuY3Rpb24gd2lsbCBiZSB1c2VkIGFzIHN0YXRlXFxuICAgKiBAdHJpZ2dlciByZWZyZXNoLmpzdHJlZVxcbiAgICovXFxuXFx0XFx0cmVmcmVzaDogZnVuY3Rpb24gcmVmcmVzaChza2lwX2xvYWRpbmcsIGZvcmdldF9zdGF0ZSkge1xcblxcdFxcdFxcdHRoaXMuX2RhdGEuY29yZS5zdGF0ZSA9IGZvcmdldF9zdGF0ZSA9PT0gdHJ1ZSA/IHt9IDogdGhpcy5nZXRfc3RhdGUoKTtcXG5cXHRcXHRcXHRpZiAoZm9yZ2V0X3N0YXRlICYmICQuaXNGdW5jdGlvbihmb3JnZXRfc3RhdGUpKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5fZGF0YS5jb3JlLnN0YXRlID0gZm9yZ2V0X3N0YXRlLmNhbGwodGhpcywgdGhpcy5fZGF0YS5jb3JlLnN0YXRlKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0dGhpcy5fY250ID0gMDtcXG5cXHRcXHRcXHR0aGlzLl9tb2RlbC5kYXRhID0ge307XFxuXFx0XFx0XFx0dGhpcy5fbW9kZWwuZGF0YVskLmpzdHJlZS5yb290XSA9IHtcXG5cXHRcXHRcXHRcXHRpZDogJC5qc3RyZWUucm9vdCxcXG5cXHRcXHRcXHRcXHRwYXJlbnQ6IG51bGwsXFxuXFx0XFx0XFx0XFx0cGFyZW50czogW10sXFxuXFx0XFx0XFx0XFx0Y2hpbGRyZW46IFtdLFxcblxcdFxcdFxcdFxcdGNoaWxkcmVuX2Q6IFtdLFxcblxcdFxcdFxcdFxcdHN0YXRlOiB7IGxvYWRlZDogZmFsc2UgfVxcblxcdFxcdFxcdH07XFxuXFx0XFx0XFx0dGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkID0gW107XFxuXFx0XFx0XFx0dGhpcy5fZGF0YS5jb3JlLmxhc3RfY2xpY2tlZCA9IG51bGw7XFxuXFx0XFx0XFx0dGhpcy5fZGF0YS5jb3JlLmZvY3VzZWQgPSBudWxsO1xcblxcblxcdFxcdFxcdHZhciBjID0gdGhpcy5nZXRfY29udGFpbmVyX3VsKClbMF0uY2xhc3NOYW1lO1xcblxcdFxcdFxcdGlmICghc2tpcF9sb2FkaW5nKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5lbGVtZW50Lmh0bWwoXFxcIjxcXFwiICsgXFxcInVsIGNsYXNzPSdcXFwiICsgYyArIFxcXCInIHJvbGU9J2dyb3VwJz48XFxcIiArIFxcXCJsaSBjbGFzcz0nanN0cmVlLWluaXRpYWwtbm9kZSBqc3RyZWUtbG9hZGluZyBqc3RyZWUtbGVhZiBqc3RyZWUtbGFzdCcgcm9sZT0ndHJlZWl0ZW0nIGlkPSdqXFxcIiArIHRoaXMuX2lkICsgXFxcIl9sb2FkaW5nJz48aSBjbGFzcz0nanN0cmVlLWljb24ganN0cmVlLW9jbCc+PC9pPjxcXFwiICsgXFxcImEgY2xhc3M9J2pzdHJlZS1hbmNob3InIGhyZWY9JyMnPjxpIGNsYXNzPSdqc3RyZWUtaWNvbiBqc3RyZWUtdGhlbWVpY29uLWhpZGRlbic+PC9pPlxcXCIgKyB0aGlzLmdldF9zdHJpbmcoXFxcIkxvYWRpbmcgLi4uXFxcIikgKyBcXFwiPC9hPjwvbGk+PC91bD5cXFwiKTtcXG5cXHRcXHRcXHRcXHR0aGlzLmVsZW1lbnQuYXR0cignYXJpYS1hY3RpdmVkZXNjZW5kYW50JywgJ2onICsgdGhpcy5faWQgKyAnX2xvYWRpbmcnKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0dGhpcy5sb2FkX25vZGUoJC5qc3RyZWUucm9vdCwgZnVuY3Rpb24gKG8sIHMpIHtcXG5cXHRcXHRcXHRcXHRpZiAocykge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpWzBdLmNsYXNzTmFtZSA9IGM7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHRoaXMuX2ZpcnN0Q2hpbGQodGhpcy5nZXRfY29udGFpbmVyX3VsKClbMF0pKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5lbGVtZW50LmF0dHIoJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCcsIHRoaXMuX2ZpcnN0Q2hpbGQodGhpcy5nZXRfY29udGFpbmVyX3VsKClbMF0pLmlkKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5zZXRfc3RhdGUoJC5leHRlbmQodHJ1ZSwge30sIHRoaXMuX2RhdGEuY29yZS5zdGF0ZSksIGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHQvKipcXG4gICAgICAgKiB0cmlnZ2VyZWQgd2hlbiBhIGByZWZyZXNoYCBjYWxsIGNvbXBsZXRlc1xcbiAgICAgICAqIEBldmVudFxcbiAgICAgICAqIEBuYW1lIHJlZnJlc2guanN0cmVlXFxuICAgICAgICovXFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy50cmlnZ2VyKCdyZWZyZXNoJyk7XFxuXFx0XFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHRoaXMuX2RhdGEuY29yZS5zdGF0ZSA9IG51bGw7XFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIHJlZnJlc2hlcyBhIG5vZGUgaW4gdGhlIHRyZWUgKHJlbG9hZCBpdHMgY2hpbGRyZW4pIGFsbCBvcGVuZWQgbm9kZXMgaW5zaWRlIHRoYXQgbm9kZSBhcmUgcmVsb2FkZWQgd2l0aCBjYWxscyB0byBgbG9hZF9ub2RlYC5cXG4gICAqIEBuYW1lIHJlZnJlc2hfbm9kZShvYmopXFxuICAgKiBAcGFyYW0gIHttaXhlZH0gb2JqIHRoZSBub2RlXFxuICAgKiBAdHJpZ2dlciByZWZyZXNoX25vZGUuanN0cmVlXFxuICAgKi9cXG5cXHRcXHRyZWZyZXNoX25vZGU6IGZ1bmN0aW9uIHJlZnJlc2hfbm9kZShvYmopIHtcXG5cXHRcXHRcXHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XFxuXFx0XFx0XFx0aWYgKCFvYmogfHwgb2JqLmlkID09PSAkLmpzdHJlZS5yb290KSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR2YXIgb3BlbmVkID0gW10sXFxuXFx0XFx0XFx0ICAgIHRvX2xvYWQgPSBbXSxcXG5cXHRcXHRcXHQgICAgcyA9IHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZC5jb25jYXQoW10pO1xcblxcdFxcdFxcdHRvX2xvYWQucHVzaChvYmouaWQpO1xcblxcdFxcdFxcdGlmIChvYmouc3RhdGUub3BlbmVkID09PSB0cnVlKSB7XFxuXFx0XFx0XFx0XFx0b3BlbmVkLnB1c2gob2JqLmlkKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0dGhpcy5nZXRfbm9kZShvYmosIHRydWUpLmZpbmQoJy5qc3RyZWUtb3BlbicpLmVhY2goZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdHRvX2xvYWQucHVzaCh0aGlzLmlkKTtvcGVuZWQucHVzaCh0aGlzLmlkKTtcXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHR0aGlzLl9sb2FkX25vZGVzKHRvX2xvYWQsICQucHJveHkoZnVuY3Rpb24gKG5vZGVzKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5vcGVuX25vZGUob3BlbmVkLCBmYWxzZSwgMCk7XFxuXFx0XFx0XFx0XFx0dGhpcy5zZWxlY3Rfbm9kZShzKTtcXG5cXHRcXHRcXHRcXHQvKipcXG4gICAgICogdHJpZ2dlcmVkIHdoZW4gYSBub2RlIGlzIHJlZnJlc2hlZFxcbiAgICAgKiBAZXZlbnRcXG4gICAgICogQG5hbWUgcmVmcmVzaF9ub2RlLmpzdHJlZVxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZSAtIHRoZSByZWZyZXNoZWQgbm9kZVxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBub2RlcyAtIGFuIGFycmF5IG9mIHRoZSBJRHMgb2YgdGhlIG5vZGVzIHRoYXQgd2VyZSByZWxvYWRlZFxcbiAgICAgKi9cXG5cXHRcXHRcXHRcXHR0aGlzLnRyaWdnZXIoJ3JlZnJlc2hfbm9kZScsIHsgJ25vZGUnOiBvYmosICdub2Rlcyc6IG5vZGVzIH0pO1xcblxcdFxcdFxcdH0sIHRoaXMpLCBmYWxzZSwgdHJ1ZSk7XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIHNldCAoY2hhbmdlKSB0aGUgSUQgb2YgYSBub2RlXFxuICAgKiBAbmFtZSBzZXRfaWQob2JqLCBpZClcXG4gICAqIEBwYXJhbSAge21peGVkfSBvYmogdGhlIG5vZGVcXG4gICAqIEBwYXJhbSAge1N0cmluZ30gaWQgdGhlIG5ldyBJRFxcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cXG4gICAqIEB0cmlnZ2VyIHNldF9pZC5qc3RyZWVcXG4gICAqL1xcblxcdFxcdHNldF9pZDogZnVuY3Rpb24gc2V0X2lkKG9iaiwgaWQpIHtcXG5cXHRcXHRcXHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XFxuXFx0XFx0XFx0aWYgKCFvYmogfHwgb2JqLmlkID09PSAkLmpzdHJlZS5yb290KSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR2YXIgaSxcXG5cXHRcXHRcXHQgICAgaixcXG5cXHRcXHRcXHQgICAgbSA9IHRoaXMuX21vZGVsLmRhdGEsXFxuXFx0XFx0XFx0ICAgIG9sZCA9IG9iai5pZDtcXG5cXHRcXHRcXHRpZCA9IGlkLnRvU3RyaW5nKCk7XFxuXFx0XFx0XFx0Ly8gdXBkYXRlIHBhcmVudHMgKHJlcGxhY2UgY3VycmVudCBJRCB3aXRoIG5ldyBvbmUgaW4gY2hpbGRyZW4gYW5kIGNoaWxkcmVuX2QpXFxuXFx0XFx0XFx0bVtvYmoucGFyZW50XS5jaGlsZHJlblskLmluQXJyYXkob2JqLmlkLCBtW29iai5wYXJlbnRdLmNoaWxkcmVuKV0gPSBpZDtcXG5cXHRcXHRcXHRmb3IgKGkgPSAwLCBqID0gb2JqLnBhcmVudHMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0bVtvYmoucGFyZW50c1tpXV0uY2hpbGRyZW5fZFskLmluQXJyYXkob2JqLmlkLCBtW29iai5wYXJlbnRzW2ldXS5jaGlsZHJlbl9kKV0gPSBpZDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0Ly8gdXBkYXRlIGNoaWxkcmVuIChyZXBsYWNlIGN1cnJlbnQgSUQgd2l0aCBuZXcgb25lIGluIHBhcmVudCBhbmQgcGFyZW50cylcXG5cXHRcXHRcXHRmb3IgKGkgPSAwLCBqID0gb2JqLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcblxcdFxcdFxcdFxcdG1bb2JqLmNoaWxkcmVuW2ldXS5wYXJlbnQgPSBpZDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0Zm9yIChpID0gMCwgaiA9IG9iai5jaGlsZHJlbl9kLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcblxcdFxcdFxcdFxcdG1bb2JqLmNoaWxkcmVuX2RbaV1dLnBhcmVudHNbJC5pbkFycmF5KG9iai5pZCwgbVtvYmouY2hpbGRyZW5fZFtpXV0ucGFyZW50cyldID0gaWQ7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGkgPSAkLmluQXJyYXkob2JqLmlkLCB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQpO1xcblxcdFxcdFxcdGlmIChpICE9PSAtMSkge1xcblxcdFxcdFxcdFxcdHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZFtpXSA9IGlkO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHQvLyB1cGRhdGUgbW9kZWwgYW5kIG9iaiBpdHNlbGYgKG9iai5pZCwgdGhpcy5fbW9kZWwuZGF0YVtLRVldKVxcblxcdFxcdFxcdGkgPSB0aGlzLmdldF9ub2RlKG9iai5pZCwgdHJ1ZSk7XFxuXFx0XFx0XFx0aWYgKGkpIHtcXG5cXHRcXHRcXHRcXHRpLmF0dHIoJ2lkJywgaWQpOyAvLy5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5hdHRyKCdpZCcsIGlkICsgJ19hbmNob3InKS5lbmQoKS5hdHRyKCdhcmlhLWxhYmVsbGVkYnknLCBpZCArICdfYW5jaG9yJyk7XFxuXFx0XFx0XFx0XFx0aWYgKHRoaXMuZWxlbWVudC5hdHRyKCdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnKSA9PT0gb2JqLmlkKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5lbGVtZW50LmF0dHIoJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCcsIGlkKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGRlbGV0ZSBtW29iai5pZF07XFxuXFx0XFx0XFx0b2JqLmlkID0gaWQ7XFxuXFx0XFx0XFx0b2JqLmxpX2F0dHIuaWQgPSBpZDtcXG5cXHRcXHRcXHRtW2lkXSA9IG9iajtcXG5cXHRcXHRcXHQvKipcXG4gICAgKiB0cmlnZ2VyZWQgd2hlbiBhIG5vZGUgaWQgdmFsdWUgaXMgY2hhbmdlZFxcbiAgICAqIEBldmVudFxcbiAgICAqIEBuYW1lIHNldF9pZC5qc3RyZWVcXG4gICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZVxcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGQgdGhlIG9sZCBpZFxcbiAgICAqL1xcblxcdFxcdFxcdHRoaXMudHJpZ2dlcignc2V0X2lkJywgeyBcXFwibm9kZVxcXCI6IG9iaiwgXFxcIm5ld1xcXCI6IG9iai5pZCwgXFxcIm9sZFxcXCI6IG9sZCB9KTtcXG5cXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogZ2V0IHRoZSB0ZXh0IHZhbHVlIG9mIGEgbm9kZVxcbiAgICogQG5hbWUgZ2V0X3RleHQob2JqKVxcbiAgICogQHBhcmFtICB7bWl4ZWR9IG9iaiB0aGUgbm9kZVxcbiAgICogQHJldHVybiB7U3RyaW5nfVxcbiAgICovXFxuXFx0XFx0Z2V0X3RleHQ6IGZ1bmN0aW9uIGdldF90ZXh0KG9iaikge1xcblxcdFxcdFxcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXHRcXHRcXHRyZXR1cm4gIW9iaiB8fCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QgPyBmYWxzZSA6IG9iai50ZXh0O1xcblxcdFxcdH0sXFxuXFx0XFx0LyoqXFxuICAgKiBzZXQgdGhlIHRleHQgdmFsdWUgb2YgYSBub2RlLiBVc2VkIGludGVybmFsbHksIHBsZWFzZSB1c2UgYHJlbmFtZV9ub2RlKG9iaiwgdmFsKWAuXFxuICAgKiBAcHJpdmF0ZVxcbiAgICogQG5hbWUgc2V0X3RleHQob2JqLCB2YWwpXFxuICAgKiBAcGFyYW0gIHttaXhlZH0gb2JqIHRoZSBub2RlLCB5b3UgY2FuIHBhc3MgYW4gYXJyYXkgdG8gc2V0IHRoZSB0ZXh0IG9uIG11bHRpcGxlIG5vZGVzXFxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHZhbCB0aGUgbmV3IHRleHQgdmFsdWVcXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XFxuICAgKiBAdHJpZ2dlciBzZXRfdGV4dC5qc3RyZWVcXG4gICAqL1xcblxcdFxcdHNldF90ZXh0OiBmdW5jdGlvbiBzZXRfdGV4dChvYmosIHZhbCkge1xcblxcdFxcdFxcdHZhciB0MSwgdDI7XFxuXFx0XFx0XFx0aWYgKCQuaXNBcnJheShvYmopKSB7XFxuXFx0XFx0XFx0XFx0b2JqID0gb2JqLnNsaWNlKCk7XFxuXFx0XFx0XFx0XFx0Zm9yICh0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuc2V0X3RleHQob2JqW3QxXSwgdmFsKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXHRcXHRcXHRpZiAoIW9iaiB8fCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdG9iai50ZXh0ID0gdmFsO1xcblxcdFxcdFxcdGlmICh0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSkubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5yZWRyYXdfbm9kZShvYmouaWQpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHQvKipcXG4gICAgKiB0cmlnZ2VyZWQgd2hlbiBhIG5vZGUgdGV4dCB2YWx1ZSBpcyBjaGFuZ2VkXFxuICAgICogQGV2ZW50XFxuICAgICogQG5hbWUgc2V0X3RleHQuanN0cmVlXFxuICAgICogQHBhcmFtIHtPYmplY3R9IG9ialxcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IHRoZSBuZXcgdmFsdWVcXG4gICAgKi9cXG5cXHRcXHRcXHR0aGlzLnRyaWdnZXIoJ3NldF90ZXh0JywgeyBcXFwib2JqXFxcIjogb2JqLCBcXFwidGV4dFxcXCI6IHZhbCB9KTtcXG5cXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogZ2V0cyBhIEpTT04gcmVwcmVzZW50YXRpb24gb2YgYSBub2RlIChvciB0aGUgd2hvbGUgdHJlZSlcXG4gICAqIEBuYW1lIGdldF9qc29uKFtvYmosIG9wdGlvbnNdKVxcbiAgICogQHBhcmFtICB7bWl4ZWR9IG9ialxcbiAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXFxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBvcHRpb25zLm5vX3N0YXRlIGRvIG5vdCByZXR1cm4gc3RhdGUgaW5mb3JtYXRpb25cXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IG9wdGlvbnMubm9faWQgZG8gbm90IHJldHVybiBJRFxcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gb3B0aW9ucy5ub19jaGlsZHJlbiBkbyBub3QgaW5jbHVkZSBjaGlsZHJlblxcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gb3B0aW9ucy5ub19kYXRhIGRvIG5vdCBpbmNsdWRlIG5vZGUgZGF0YVxcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gb3B0aW9ucy5ub19saV9hdHRyIGRvIG5vdCBpbmNsdWRlIExJIGF0dHJpYnV0ZXNcXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IG9wdGlvbnMubm9fYV9hdHRyIGRvIG5vdCBpbmNsdWRlIEEgYXR0cmlidXRlc1xcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gb3B0aW9ucy5mbGF0IHJldHVybiBmbGF0IEpTT04gaW5zdGVhZCBvZiBuZXN0ZWRcXG4gICAqIEByZXR1cm4ge09iamVjdH1cXG4gICAqL1xcblxcdFxcdGdldF9qc29uOiBmdW5jdGlvbiBnZXRfanNvbihvYmosIG9wdGlvbnMsIGZsYXQpIHtcXG5cXHRcXHRcXHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaiB8fCAkLmpzdHJlZS5yb290KTtcXG5cXHRcXHRcXHRpZiAoIW9iaikge1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5mbGF0ICYmICFmbGF0KSB7XFxuXFx0XFx0XFx0XFx0ZmxhdCA9IFtdO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR2YXIgdG1wID0ge1xcblxcdFxcdFxcdFxcdCdpZCc6IG9iai5pZCxcXG5cXHRcXHRcXHRcXHQndGV4dCc6IG9iai50ZXh0LFxcblxcdFxcdFxcdFxcdCdpY29uJzogdGhpcy5nZXRfaWNvbihvYmopLFxcblxcdFxcdFxcdFxcdCdsaV9hdHRyJzogJC5leHRlbmQodHJ1ZSwge30sIG9iai5saV9hdHRyKSxcXG5cXHRcXHRcXHRcXHQnYV9hdHRyJzogJC5leHRlbmQodHJ1ZSwge30sIG9iai5hX2F0dHIpLFxcblxcdFxcdFxcdFxcdCdzdGF0ZSc6IHt9LFxcblxcdFxcdFxcdFxcdCdkYXRhJzogb3B0aW9ucyAmJiBvcHRpb25zLm5vX2RhdGEgPyBmYWxzZSA6ICQuZXh0ZW5kKHRydWUsIHt9LCBvYmouZGF0YSlcXG5cXHRcXHRcXHRcXHQvLyggdGhpcy5nZXRfbm9kZShvYmosIHRydWUpLmxlbmd0aCA/IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKS5kYXRhKCkgOiBvYmouZGF0YSApLFxcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0ICAgIGksXFxuXFx0XFx0XFx0ICAgIGo7XFxuXFx0XFx0XFx0aWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5mbGF0KSB7XFxuXFx0XFx0XFx0XFx0dG1wLnBhcmVudCA9IG9iai5wYXJlbnQ7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHR0bXAuY2hpbGRyZW4gPSBbXTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKCFvcHRpb25zIHx8ICFvcHRpb25zLm5vX3N0YXRlKSB7XFxuXFx0XFx0XFx0XFx0Zm9yIChpIGluIG9iai5zdGF0ZSkge1xcblxcdFxcdFxcdFxcdFxcdGlmIChvYmouc3RhdGUuaGFzT3duUHJvcGVydHkoaSkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0bXAuc3RhdGVbaV0gPSBvYmouc3RhdGVbaV07XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdGRlbGV0ZSB0bXAuc3RhdGU7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmIChvcHRpb25zICYmIG9wdGlvbnMubm9fbGlfYXR0cikge1xcblxcdFxcdFxcdFxcdGRlbGV0ZSB0bXAubGlfYXR0cjtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5ub19hX2F0dHIpIHtcXG5cXHRcXHRcXHRcXHRkZWxldGUgdG1wLmFfYXR0cjtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5ub19pZCkge1xcblxcdFxcdFxcdFxcdGRlbGV0ZSB0bXAuaWQ7XFxuXFx0XFx0XFx0XFx0aWYgKHRtcC5saV9hdHRyICYmIHRtcC5saV9hdHRyLmlkKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZGVsZXRlIHRtcC5saV9hdHRyLmlkO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRpZiAodG1wLmFfYXR0ciAmJiB0bXAuYV9hdHRyLmlkKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZGVsZXRlIHRtcC5hX2F0dHIuaWQ7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAob3B0aW9ucyAmJiBvcHRpb25zLmZsYXQgJiYgb2JqLmlkICE9PSAkLmpzdHJlZS5yb290KSB7XFxuXFx0XFx0XFx0XFx0ZmxhdC5wdXNoKHRtcCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICghb3B0aW9ucyB8fCAhb3B0aW9ucy5ub19jaGlsZHJlbikge1xcblxcdFxcdFxcdFxcdGZvciAoaSA9IDAsIGogPSBvYmouY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5mbGF0KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5nZXRfanNvbihvYmouY2hpbGRyZW5baV0sIG9wdGlvbnMsIGZsYXQpO1xcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dG1wLmNoaWxkcmVuLnB1c2godGhpcy5nZXRfanNvbihvYmouY2hpbGRyZW5baV0sIG9wdGlvbnMpKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gb3B0aW9ucyAmJiBvcHRpb25zLmZsYXQgPyBmbGF0IDogb2JqLmlkID09PSAkLmpzdHJlZS5yb290ID8gdG1wLmNoaWxkcmVuIDogdG1wO1xcblxcdFxcdH0sXFxuXFx0XFx0LyoqXFxuICAgKiBjcmVhdGUgYSBuZXcgbm9kZSAoZG8gbm90IGNvbmZ1c2Ugd2l0aCBsb2FkX25vZGUpXFxuICAgKiBAbmFtZSBjcmVhdGVfbm9kZShbcGFyLCBub2RlLCBwb3MsIGNhbGxiYWNrLCBpc19sb2FkZWRdKVxcbiAgICogQHBhcmFtICB7bWl4ZWR9ICAgcGFyICAgICAgIHRoZSBwYXJlbnQgbm9kZSAodG8gY3JlYXRlIGEgcm9vdCBub2RlIHVzZSBlaXRoZXIgXFxcIiNcXFwiIChzdHJpbmcpIG9yIGBudWxsYClcXG4gICAqIEBwYXJhbSAge21peGVkfSAgIG5vZGUgICAgICB0aGUgZGF0YSBmb3IgdGhlIG5ldyBub2RlIChhIHZhbGlkIEpTT04gb2JqZWN0LCBvciBhIHNpbXBsZSBzdHJpbmcgd2l0aCB0aGUgbmFtZSlcXG4gICAqIEBwYXJhbSAge21peGVkfSAgIHBvcyAgICAgICB0aGUgaW5kZXggYXQgd2hpY2ggdG8gaW5zZXJ0IHRoZSBub2RlLCBcXFwiZmlyc3RcXFwiIGFuZCBcXFwibGFzdFxcXCIgYXJlIGFsc28gc3VwcG9ydGVkLCBkZWZhdWx0IGlzIFxcXCJsYXN0XFxcIlxcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrIGEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uY2UgdGhlIG5vZGUgaXMgY3JlYXRlZFxcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gaXNfbG9hZGVkIGludGVybmFsIGFyZ3VtZW50IGluZGljYXRpbmcgaWYgdGhlIHBhcmVudCBub2RlIHdhcyBzdWNjZXNmdWxseSBsb2FkZWRcXG4gICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICAgICB0aGUgSUQgb2YgdGhlIG5ld2x5IGNyZWF0ZSBub2RlXFxuICAgKiBAdHJpZ2dlciBtb2RlbC5qc3RyZWUsIGNyZWF0ZV9ub2RlLmpzdHJlZVxcbiAgICovXFxuXFx0XFx0Y3JlYXRlX25vZGU6IGZ1bmN0aW9uIGNyZWF0ZV9ub2RlKHBhciwgbm9kZSwgcG9zLCBjYWxsYmFjaywgaXNfbG9hZGVkKSB7XFxuXFx0XFx0XFx0aWYgKHBhciA9PT0gbnVsbCkge1xcblxcdFxcdFxcdFxcdHBhciA9ICQuanN0cmVlLnJvb3Q7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHBhciA9IHRoaXMuZ2V0X25vZGUocGFyKTtcXG5cXHRcXHRcXHRpZiAoIXBhcikge1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cG9zID0gcG9zID09PSB1bmRlZmluZWQgPyBcXFwibGFzdFxcXCIgOiBwb3M7XFxuXFx0XFx0XFx0aWYgKCFwb3MudG9TdHJpbmcoKS5tYXRjaCgvXihiZWZvcmV8YWZ0ZXIpJC8pICYmICFpc19sb2FkZWQgJiYgIXRoaXMuaXNfbG9hZGVkKHBhcikpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5sb2FkX25vZGUocGFyLCBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5jcmVhdGVfbm9kZShwYXIsIG5vZGUsIHBvcywgY2FsbGJhY2ssIHRydWUpO1xcblxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoIW5vZGUpIHtcXG5cXHRcXHRcXHRcXHRub2RlID0geyBcXFwidGV4dFxcXCI6IHRoaXMuZ2V0X3N0cmluZygnTmV3IG5vZGUnKSB9O1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAodHlwZW9mIG5vZGUgPT09IFxcXCJzdHJpbmdcXFwiKSB7XFxuXFx0XFx0XFx0XFx0bm9kZSA9IHsgXFxcInRleHRcXFwiOiBub2RlIH07XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmIChub2RlLnRleHQgPT09IHVuZGVmaW5lZCkge1xcblxcdFxcdFxcdFxcdG5vZGUudGV4dCA9IHRoaXMuZ2V0X3N0cmluZygnTmV3IG5vZGUnKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0dmFyIHRtcCwgZHBjLCBpLCBqO1xcblxcblxcdFxcdFxcdGlmIChwYXIuaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcXG5cXHRcXHRcXHRcXHRpZiAocG9zID09PSBcXFwiYmVmb3JlXFxcIikge1xcblxcdFxcdFxcdFxcdFxcdHBvcyA9IFxcXCJmaXJzdFxcXCI7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGlmIChwb3MgPT09IFxcXCJhZnRlclxcXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRwb3MgPSBcXFwibGFzdFxcXCI7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRzd2l0Y2ggKHBvcykge1xcblxcdFxcdFxcdFxcdGNhc2UgXFxcImJlZm9yZVxcXCI6XFxuXFx0XFx0XFx0XFx0XFx0dG1wID0gdGhpcy5nZXRfbm9kZShwYXIucGFyZW50KTtcXG5cXHRcXHRcXHRcXHRcXHRwb3MgPSAkLmluQXJyYXkocGFyLmlkLCB0bXAuY2hpbGRyZW4pO1xcblxcdFxcdFxcdFxcdFxcdHBhciA9IHRtcDtcXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRjYXNlIFxcXCJhZnRlclxcXCI6XFxuXFx0XFx0XFx0XFx0XFx0dG1wID0gdGhpcy5nZXRfbm9kZShwYXIucGFyZW50KTtcXG5cXHRcXHRcXHRcXHRcXHRwb3MgPSAkLmluQXJyYXkocGFyLmlkLCB0bXAuY2hpbGRyZW4pICsgMTtcXG5cXHRcXHRcXHRcXHRcXHRwYXIgPSB0bXA7XFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0Y2FzZSBcXFwiaW5zaWRlXFxcIjpcXG5cXHRcXHRcXHRcXHRjYXNlIFxcXCJmaXJzdFxcXCI6XFxuXFx0XFx0XFx0XFx0XFx0cG9zID0gMDtcXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRjYXNlIFxcXCJsYXN0XFxcIjpcXG5cXHRcXHRcXHRcXHRcXHRwb3MgPSBwYXIuY2hpbGRyZW4ubGVuZ3RoO1xcblxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdGRlZmF1bHQ6XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCFwb3MpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRwb3MgPSAwO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKHBvcyA+IHBhci5jaGlsZHJlbi5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRwb3MgPSBwYXIuY2hpbGRyZW4ubGVuZ3RoO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoIW5vZGUuaWQpIHtcXG5cXHRcXHRcXHRcXHRub2RlLmlkID0gdHJ1ZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKCF0aGlzLmNoZWNrKFxcXCJjcmVhdGVfbm9kZVxcXCIsIG5vZGUsIHBhciwgcG9zKSkge1xcblxcdFxcdFxcdFxcdHRoaXMuc2V0dGluZ3MuY29yZS5lcnJvci5jYWxsKHRoaXMsIHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmIChub2RlLmlkID09PSB0cnVlKSB7XFxuXFx0XFx0XFx0XFx0ZGVsZXRlIG5vZGUuaWQ7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdG5vZGUgPSB0aGlzLl9wYXJzZV9tb2RlbF9mcm9tX2pzb24obm9kZSwgcGFyLmlkLCBwYXIucGFyZW50cy5jb25jYXQoKSk7XFxuXFx0XFx0XFx0aWYgKCFub2RlKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR0bXAgPSB0aGlzLmdldF9ub2RlKG5vZGUpO1xcblxcdFxcdFxcdGRwYyA9IFtdO1xcblxcdFxcdFxcdGRwYy5wdXNoKG5vZGUpO1xcblxcdFxcdFxcdGRwYyA9IGRwYy5jb25jYXQodG1wLmNoaWxkcmVuX2QpO1xcblxcdFxcdFxcdHRoaXMudHJpZ2dlcignbW9kZWwnLCB7IFxcXCJub2Rlc1xcXCI6IGRwYywgXFxcInBhcmVudFxcXCI6IHBhci5pZCB9KTtcXG5cXG5cXHRcXHRcXHRwYXIuY2hpbGRyZW5fZCA9IHBhci5jaGlsZHJlbl9kLmNvbmNhdChkcGMpO1xcblxcdFxcdFxcdGZvciAoaSA9IDAsIGogPSBwYXIucGFyZW50cy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9tb2RlbC5kYXRhW3Bhci5wYXJlbnRzW2ldXS5jaGlsZHJlbl9kID0gdGhpcy5fbW9kZWwuZGF0YVtwYXIucGFyZW50c1tpXV0uY2hpbGRyZW5fZC5jb25jYXQoZHBjKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0bm9kZSA9IHRtcDtcXG5cXHRcXHRcXHR0bXAgPSBbXTtcXG5cXHRcXHRcXHRmb3IgKGkgPSAwLCBqID0gcGFyLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcblxcdFxcdFxcdFxcdHRtcFtpID49IHBvcyA/IGkgKyAxIDogaV0gPSBwYXIuY2hpbGRyZW5baV07XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHRtcFtwb3NdID0gbm9kZS5pZDtcXG5cXHRcXHRcXHRwYXIuY2hpbGRyZW4gPSB0bXA7XFxuXFxuXFx0XFx0XFx0dGhpcy5yZWRyYXdfbm9kZShwYXIsIHRydWUpO1xcblxcdFxcdFxcdGlmIChjYWxsYmFjaykge1xcblxcdFxcdFxcdFxcdGNhbGxiYWNrLmNhbGwodGhpcywgdGhpcy5nZXRfbm9kZShub2RlKSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdC8qKlxcbiAgICAqIHRyaWdnZXJlZCB3aGVuIGEgbm9kZSBpcyBjcmVhdGVkXFxuICAgICogQGV2ZW50XFxuICAgICogQG5hbWUgY3JlYXRlX25vZGUuanN0cmVlXFxuICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGVcXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyZW50IHRoZSBwYXJlbnQncyBJRFxcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSBwb3NpdGlvbiB0aGUgcG9zaXRpb24gb2YgdGhlIG5ldyBub2RlIGFtb25nIHRoZSBwYXJlbnQncyBjaGlsZHJlblxcbiAgICAqL1xcblxcdFxcdFxcdHRoaXMudHJpZ2dlcignY3JlYXRlX25vZGUnLCB7IFxcXCJub2RlXFxcIjogdGhpcy5nZXRfbm9kZShub2RlKSwgXFxcInBhcmVudFxcXCI6IHBhci5pZCwgXFxcInBvc2l0aW9uXFxcIjogcG9zIH0pO1xcblxcdFxcdFxcdHJldHVybiBub2RlLmlkO1xcblxcdFxcdH0sXFxuXFx0XFx0LyoqXFxuICAgKiBzZXQgdGhlIHRleHQgdmFsdWUgb2YgYSBub2RlXFxuICAgKiBAbmFtZSByZW5hbWVfbm9kZShvYmosIHZhbClcXG4gICAqIEBwYXJhbSAge21peGVkfSBvYmogdGhlIG5vZGUsIHlvdSBjYW4gcGFzcyBhbiBhcnJheSB0byByZW5hbWUgbXVsdGlwbGUgbm9kZXMgdG8gdGhlIHNhbWUgbmFtZVxcbiAgICogQHBhcmFtICB7U3RyaW5nfSB2YWwgdGhlIG5ldyB0ZXh0IHZhbHVlXFxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxcbiAgICogQHRyaWdnZXIgcmVuYW1lX25vZGUuanN0cmVlXFxuICAgKi9cXG5cXHRcXHRyZW5hbWVfbm9kZTogZnVuY3Rpb24gcmVuYW1lX25vZGUob2JqLCB2YWwpIHtcXG5cXHRcXHRcXHR2YXIgdDEsIHQyLCBvbGQ7XFxuXFx0XFx0XFx0aWYgKCQuaXNBcnJheShvYmopKSB7XFxuXFx0XFx0XFx0XFx0b2JqID0gb2JqLnNsaWNlKCk7XFxuXFx0XFx0XFx0XFx0Zm9yICh0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMucmVuYW1lX25vZGUob2JqW3QxXSwgdmFsKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXHRcXHRcXHRpZiAoIW9iaiB8fCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdG9sZCA9IG9iai50ZXh0O1xcblxcdFxcdFxcdGlmICghdGhpcy5jaGVjayhcXFwicmVuYW1lX25vZGVcXFwiLCBvYmosIHRoaXMuZ2V0X3BhcmVudChvYmopLCB2YWwpKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5zZXR0aW5ncy5jb3JlLmVycm9yLmNhbGwodGhpcywgdGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IpO1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0dGhpcy5zZXRfdGV4dChvYmosIHZhbCk7IC8vIC5hcHBseSh0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKVxcblxcdFxcdFxcdC8qKlxcbiAgICAqIHRyaWdnZXJlZCB3aGVuIGEgbm9kZSBpcyByZW5hbWVkXFxuICAgICogQGV2ZW50XFxuICAgICogQG5hbWUgcmVuYW1lX25vZGUuanN0cmVlXFxuICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGVcXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCB0aGUgbmV3IHZhbHVlXFxuICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZCB0aGUgb2xkIHZhbHVlXFxuICAgICovXFxuXFx0XFx0XFx0dGhpcy50cmlnZ2VyKCdyZW5hbWVfbm9kZScsIHsgXFxcIm5vZGVcXFwiOiBvYmosIFxcXCJ0ZXh0XFxcIjogdmFsLCBcXFwib2xkXFxcIjogb2xkIH0pO1xcblxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdH0sXFxuXFx0XFx0LyoqXFxuICAgKiByZW1vdmUgYSBub2RlXFxuICAgKiBAbmFtZSBkZWxldGVfbm9kZShvYmopXFxuICAgKiBAcGFyYW0gIHttaXhlZH0gb2JqIHRoZSBub2RlLCB5b3UgY2FuIHBhc3MgYW4gYXJyYXkgdG8gZGVsZXRlIG11bHRpcGxlIG5vZGVzXFxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxcbiAgICogQHRyaWdnZXIgZGVsZXRlX25vZGUuanN0cmVlLCBjaGFuZ2VkLmpzdHJlZVxcbiAgICovXFxuXFx0XFx0ZGVsZXRlX25vZGU6IGZ1bmN0aW9uIGRlbGV0ZV9ub2RlKG9iaikge1xcblxcdFxcdFxcdHZhciB0MSwgdDIsIHBhciwgcG9zLCB0bXAsIGksIGosIGssIGwsIGMsIHRvcCwgbGZ0O1xcblxcdFxcdFxcdGlmICgkLmlzQXJyYXkob2JqKSkge1xcblxcdFxcdFxcdFxcdG9iaiA9IG9iai5zbGljZSgpO1xcblxcdFxcdFxcdFxcdGZvciAodDEgPSAwLCB0MiA9IG9iai5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmRlbGV0ZV9ub2RlKG9ialt0MV0pO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xcblxcdFxcdFxcdGlmICghb2JqIHx8IG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCkge1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cGFyID0gdGhpcy5nZXRfbm9kZShvYmoucGFyZW50KTtcXG5cXHRcXHRcXHRwb3MgPSAkLmluQXJyYXkob2JqLmlkLCBwYXIuY2hpbGRyZW4pO1xcblxcdFxcdFxcdGMgPSBmYWxzZTtcXG5cXHRcXHRcXHRpZiAoIXRoaXMuY2hlY2soXFxcImRlbGV0ZV9ub2RlXFxcIiwgb2JqLCBwYXIsIHBvcykpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLnNldHRpbmdzLmNvcmUuZXJyb3IuY2FsbCh0aGlzLCB0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvcik7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAocG9zICE9PSAtMSkge1xcblxcdFxcdFxcdFxcdHBhci5jaGlsZHJlbiA9ICQudmFrYXRhLmFycmF5X3JlbW92ZShwYXIuY2hpbGRyZW4sIHBvcyk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHRtcCA9IG9iai5jaGlsZHJlbl9kLmNvbmNhdChbXSk7XFxuXFx0XFx0XFx0dG1wLnB1c2gob2JqLmlkKTtcXG5cXHRcXHRcXHRmb3IgKGkgPSAwLCBqID0gb2JqLnBhcmVudHMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5fbW9kZWwuZGF0YVtvYmoucGFyZW50c1tpXV0uY2hpbGRyZW5fZCA9ICQudmFrYXRhLmFycmF5X2ZpbHRlcih0aGlzLl9tb2RlbC5kYXRhW29iai5wYXJlbnRzW2ldXS5jaGlsZHJlbl9kLCBmdW5jdGlvbiAodikge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiAkLmluQXJyYXkodiwgdG1wKSA9PT0gLTE7XFxuXFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGZvciAoayA9IDAsIGwgPSB0bXAubGVuZ3RoOyBrIDwgbDsgaysrKSB7XFxuXFx0XFx0XFx0XFx0aWYgKHRoaXMuX21vZGVsLmRhdGFbdG1wW2tdXS5zdGF0ZS5zZWxlY3RlZCkge1xcblxcdFxcdFxcdFxcdFxcdGMgPSB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKGMpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQgPSAkLnZha2F0YS5hcnJheV9maWx0ZXIodGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLCBmdW5jdGlvbiAodikge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiAkLmluQXJyYXkodiwgdG1wKSA9PT0gLTE7XFxuXFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdC8qKlxcbiAgICAqIHRyaWdnZXJlZCB3aGVuIGEgbm9kZSBpcyBkZWxldGVkXFxuICAgICogQGV2ZW50XFxuICAgICogQG5hbWUgZGVsZXRlX25vZGUuanN0cmVlXFxuICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGVcXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyZW50IHRoZSBwYXJlbnQncyBJRFxcbiAgICAqL1xcblxcdFxcdFxcdHRoaXMudHJpZ2dlcignZGVsZXRlX25vZGUnLCB7IFxcXCJub2RlXFxcIjogb2JqLCBcXFwicGFyZW50XFxcIjogcGFyLmlkIH0pO1xcblxcdFxcdFxcdGlmIChjKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy50cmlnZ2VyKCdjaGFuZ2VkJywgeyAnYWN0aW9uJzogJ2RlbGV0ZV9ub2RlJywgJ25vZGUnOiBvYmosICdzZWxlY3RlZCc6IHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZCwgJ3BhcmVudCc6IHBhci5pZCB9KTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0Zm9yIChrID0gMCwgbCA9IHRtcC5sZW5ndGg7IGsgPCBsOyBrKyspIHtcXG5cXHRcXHRcXHRcXHRkZWxldGUgdGhpcy5fbW9kZWwuZGF0YVt0bXBba11dO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoJC5pbkFycmF5KHRoaXMuX2RhdGEuY29yZS5mb2N1c2VkLCB0bXApICE9PSAtMSkge1xcblxcdFxcdFxcdFxcdHRoaXMuX2RhdGEuY29yZS5mb2N1c2VkID0gbnVsbDtcXG5cXHRcXHRcXHRcXHR0b3AgPSB0aGlzLmVsZW1lbnRbMF0uc2Nyb2xsVG9wO1xcblxcdFxcdFxcdFxcdGxmdCA9IHRoaXMuZWxlbWVudFswXS5zY3JvbGxMZWZ0O1xcblxcdFxcdFxcdFxcdGlmIChwYXIuaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAodGhpcy5fbW9kZWwuZGF0YVskLmpzdHJlZS5yb290XS5jaGlsZHJlblswXSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuZ2V0X25vZGUodGhpcy5fbW9kZWwuZGF0YVskLmpzdHJlZS5yb290XS5jaGlsZHJlblswXSwgdHJ1ZSkuY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuZm9jdXMoKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmdldF9ub2RlKHBhciwgdHJ1ZSkuY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuZm9jdXMoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0dGhpcy5lbGVtZW50WzBdLnNjcm9sbFRvcCA9IHRvcDtcXG5cXHRcXHRcXHRcXHR0aGlzLmVsZW1lbnRbMF0uc2Nyb2xsTGVmdCA9IGxmdDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0dGhpcy5yZWRyYXdfbm9kZShwYXIsIHRydWUpO1xcblxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdH0sXFxuXFx0XFx0LyoqXFxuICAgKiBjaGVjayBpZiBhbiBvcGVyYXRpb24gaXMgcHJlbWl0dGVkIG9uIHRoZSB0cmVlLiBVc2VkIGludGVybmFsbHkuXFxuICAgKiBAcHJpdmF0ZVxcbiAgICogQG5hbWUgY2hlY2soY2hrLCBvYmosIHBhciwgcG9zKVxcbiAgICogQHBhcmFtICB7U3RyaW5nfSBjaGsgdGhlIG9wZXJhdGlvbiB0byBjaGVjaywgY2FuIGJlIFxcXCJjcmVhdGVfbm9kZVxcXCIsIFxcXCJyZW5hbWVfbm9kZVxcXCIsIFxcXCJkZWxldGVfbm9kZVxcXCIsIFxcXCJjb3B5X25vZGVcXFwiIG9yIFxcXCJtb3ZlX25vZGVcXFwiXFxuICAgKiBAcGFyYW0gIHttaXhlZH0gb2JqIHRoZSBub2RlXFxuICAgKiBAcGFyYW0gIHttaXhlZH0gcGFyIHRoZSBwYXJlbnRcXG4gICAqIEBwYXJhbSAge21peGVkfSBwb3MgdGhlIHBvc2l0aW9uIHRvIGluc2VydCBhdCwgb3IgaWYgXFxcInJlbmFtZV9ub2RlXFxcIiAtIHRoZSBuZXcgbmFtZVxcbiAgICogQHBhcmFtICB7bWl4ZWR9IG1vcmUgc29tZSB2YXJpb3VzIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24sIGZvciBleGFtcGxlIGlmIGEgXFxcIm1vdmVfbm9kZVxcXCIgb3BlcmF0aW9ucyBpcyB0cmlnZ2VyZWQgYnkgRE5EIHRoaXMgd2lsbCBiZSB0aGUgaG92ZXJlZCBub2RlXFxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxcbiAgICovXFxuXFx0XFx0Y2hlY2s6IGZ1bmN0aW9uIGNoZWNrKGNoaywgb2JqLCBwYXIsIHBvcywgbW9yZSkge1xcblxcdFxcdFxcdG9iaiA9IG9iaiAmJiBvYmouaWQgPyBvYmogOiB0aGlzLmdldF9ub2RlKG9iaik7XFxuXFx0XFx0XFx0cGFyID0gcGFyICYmIHBhci5pZCA/IHBhciA6IHRoaXMuZ2V0X25vZGUocGFyKTtcXG5cXHRcXHRcXHR2YXIgdG1wID0gY2hrLm1hdGNoKC9ebW92ZV9ub2RlfGNvcHlfbm9kZXxjcmVhdGVfbm9kZSQvaSkgPyBwYXIgOiBvYmosXFxuXFx0XFx0XFx0ICAgIGNoYyA9IHRoaXMuc2V0dGluZ3MuY29yZS5jaGVja19jYWxsYmFjaztcXG5cXHRcXHRcXHRpZiAoY2hrID09PSBcXFwibW92ZV9ub2RlXFxcIiB8fCBjaGsgPT09IFxcXCJjb3B5X25vZGVcXFwiKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCghbW9yZSB8fCAhbW9yZS5pc19tdWx0aSkgJiYgKG9iai5pZCA9PT0gcGFyLmlkIHx8IGNoayA9PT0gXFxcIm1vdmVfbm9kZVxcXCIgJiYgJC5pbkFycmF5KG9iai5pZCwgcGFyLmNoaWxkcmVuKSA9PT0gcG9zIHx8ICQuaW5BcnJheShwYXIuaWQsIG9iai5jaGlsZHJlbl9kKSAhPT0gLTEpKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IgPSB7ICdlcnJvcic6ICdjaGVjaycsICdwbHVnaW4nOiAnY29yZScsICdpZCc6ICdjb3JlXzAxJywgJ3JlYXNvbic6ICdNb3ZpbmcgcGFyZW50IGluc2lkZSBjaGlsZCcsICdkYXRhJzogSlNPTi5zdHJpbmdpZnkoeyAnY2hrJzogY2hrLCAncG9zJzogcG9zLCAnb2JqJzogb2JqICYmIG9iai5pZCA/IG9iai5pZCA6IGZhbHNlLCAncGFyJzogcGFyICYmIHBhci5pZCA/IHBhci5pZCA6IGZhbHNlIH0pIH07XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKHRtcCAmJiB0bXAuZGF0YSkge1xcblxcdFxcdFxcdFxcdHRtcCA9IHRtcC5kYXRhO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAodG1wICYmIHRtcC5mdW5jdGlvbnMgJiYgKHRtcC5mdW5jdGlvbnNbY2hrXSA9PT0gZmFsc2UgfHwgdG1wLmZ1bmN0aW9uc1tjaGtdID09PSB0cnVlKSkge1xcblxcdFxcdFxcdFxcdGlmICh0bXAuZnVuY3Rpb25zW2Noa10gPT09IGZhbHNlKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IgPSB7ICdlcnJvcic6ICdjaGVjaycsICdwbHVnaW4nOiAnY29yZScsICdpZCc6ICdjb3JlXzAyJywgJ3JlYXNvbic6ICdOb2RlIGRhdGEgcHJldmVudHMgZnVuY3Rpb246ICcgKyBjaGssICdkYXRhJzogSlNPTi5zdHJpbmdpZnkoeyAnY2hrJzogY2hrLCAncG9zJzogcG9zLCAnb2JqJzogb2JqICYmIG9iai5pZCA/IG9iai5pZCA6IGZhbHNlLCAncGFyJzogcGFyICYmIHBhci5pZCA/IHBhci5pZCA6IGZhbHNlIH0pIH07XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHJldHVybiB0bXAuZnVuY3Rpb25zW2Noa107XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmIChjaGMgPT09IGZhbHNlIHx8ICQuaXNGdW5jdGlvbihjaGMpICYmIGNoYy5jYWxsKHRoaXMsIGNoaywgb2JqLCBwYXIsIHBvcywgbW9yZSkgPT09IGZhbHNlIHx8IGNoYyAmJiBjaGNbY2hrXSA9PT0gZmFsc2UpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvciA9IHsgJ2Vycm9yJzogJ2NoZWNrJywgJ3BsdWdpbic6ICdjb3JlJywgJ2lkJzogJ2NvcmVfMDMnLCAncmVhc29uJzogJ1VzZXIgY29uZmlnIGZvciBjb3JlLmNoZWNrX2NhbGxiYWNrIHByZXZlbnRzIGZ1bmN0aW9uOiAnICsgY2hrLCAnZGF0YSc6IEpTT04uc3RyaW5naWZ5KHsgJ2Noayc6IGNoaywgJ3Bvcyc6IHBvcywgJ29iaic6IG9iaiAmJiBvYmouaWQgPyBvYmouaWQgOiBmYWxzZSwgJ3Bhcic6IHBhciAmJiBwYXIuaWQgPyBwYXIuaWQgOiBmYWxzZSB9KSB9O1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIGdldCB0aGUgbGFzdCBlcnJvclxcbiAgICogQG5hbWUgbGFzdF9lcnJvcigpXFxuICAgKiBAcmV0dXJuIHtPYmplY3R9XFxuICAgKi9cXG5cXHRcXHRsYXN0X2Vycm9yOiBmdW5jdGlvbiBsYXN0X2Vycm9yKCkge1xcblxcdFxcdFxcdHJldHVybiB0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvcjtcXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogbW92ZSBhIG5vZGUgdG8gYSBuZXcgcGFyZW50XFxuICAgKiBAbmFtZSBtb3ZlX25vZGUob2JqLCBwYXIgWywgcG9zLCBjYWxsYmFjaywgaXNfbG9hZGVkXSlcXG4gICAqIEBwYXJhbSAge21peGVkfSBvYmogdGhlIG5vZGUgdG8gbW92ZSwgcGFzcyBhbiBhcnJheSB0byBtb3ZlIG11bHRpcGxlIG5vZGVzXFxuICAgKiBAcGFyYW0gIHttaXhlZH0gcGFyIHRoZSBuZXcgcGFyZW50XFxuICAgKiBAcGFyYW0gIHttaXhlZH0gcG9zIHRoZSBwb3NpdGlvbiB0byBpbnNlcnQgYXQgKGJlc2lkZXMgaW50ZWdlciB2YWx1ZXMsIFxcXCJmaXJzdFxcXCIgYW5kIFxcXCJsYXN0XFxcIiBhcmUgc3VwcG9ydGVkLCBhcyB3ZWxsIGFzIFxcXCJiZWZvcmVcXFwiIGFuZCBcXFwiYWZ0ZXJcXFwiKSwgZGVmYXVsdHMgdG8gaW50ZWdlciBgMGBcXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSBjYWxsYmFjayBhIGZ1bmN0aW9uIHRvIGNhbGwgb25jZSB0aGUgbW92ZSBpcyBjb21wbGV0ZWQsIHJlY2VpdmVzIDMgYXJndW1lbnRzIC0gdGhlIG5vZGUsIHRoZSBuZXcgcGFyZW50IGFuZCB0aGUgcG9zaXRpb25cXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IGlzX2xvYWRlZCBpbnRlcm5hbCBwYXJhbWV0ZXIgaW5kaWNhdGluZyBpZiB0aGUgcGFyZW50IG5vZGUgaGFzIGJlZW4gbG9hZGVkXFxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBza2lwX3JlZHJhdyBpbnRlcm5hbCBwYXJhbWV0ZXIgaW5kaWNhdGluZyBpZiB0aGUgdHJlZSBzaG91bGQgYmUgcmVkcmF3blxcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gaW5zdGFuY2UgaW50ZXJuYWwgcGFyYW1ldGVyIGluZGljYXRpbmcgaWYgdGhlIG5vZGUgY29tZXMgZnJvbSBhbm90aGVyIGluc3RhbmNlXFxuICAgKiBAdHJpZ2dlciBtb3ZlX25vZGUuanN0cmVlXFxuICAgKi9cXG5cXHRcXHRtb3ZlX25vZGU6IGZ1bmN0aW9uIG1vdmVfbm9kZShvYmosIHBhciwgcG9zLCBjYWxsYmFjaywgaXNfbG9hZGVkLCBza2lwX3JlZHJhdywgb3JpZ2luKSB7XFxuXFx0XFx0XFx0dmFyIHQxLCB0Miwgb2xkX3Bhciwgb2xkX3BvcywgbmV3X3Bhciwgb2xkX2lucywgaXNfbXVsdGksIGRwYywgdG1wLCBpLCBqLCBrLCBsLCBwO1xcblxcblxcdFxcdFxcdHBhciA9IHRoaXMuZ2V0X25vZGUocGFyKTtcXG5cXHRcXHRcXHRwb3MgPSBwb3MgPT09IHVuZGVmaW5lZCA/IDAgOiBwb3M7XFxuXFx0XFx0XFx0aWYgKCFwYXIpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICghcG9zLnRvU3RyaW5nKCkubWF0Y2goL14oYmVmb3JlfGFmdGVyKSQvKSAmJiAhaXNfbG9hZGVkICYmICF0aGlzLmlzX2xvYWRlZChwYXIpKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMubG9hZF9ub2RlKHBhciwgZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMubW92ZV9ub2RlKG9iaiwgcGFyLCBwb3MsIGNhbGxiYWNrLCB0cnVlLCBmYWxzZSwgb3JpZ2luKTtcXG5cXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCQuaXNBcnJheShvYmopKSB7XFxuXFx0XFx0XFx0XFx0aWYgKG9iai5sZW5ndGggPT09IDEpIHtcXG5cXHRcXHRcXHRcXHRcXHRvYmogPSBvYmpbMF07XFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHQvL29iaiA9IG9iai5zbGljZSgpO1xcblxcdFxcdFxcdFxcdFxcdGZvciAodDEgPSAwLCB0MiA9IG9iai5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAodG1wID0gdGhpcy5tb3ZlX25vZGUob2JqW3QxXSwgcGFyLCBwb3MsIGNhbGxiYWNrLCBpc19sb2FkZWQsIGZhbHNlLCBvcmlnaW4pKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cGFyID0gdG1wO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHBvcyA9IFxcXCJhZnRlclxcXCI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnJlZHJhdygpO1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0b2JqID0gb2JqICYmIG9iai5pZCA/IG9iaiA6IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXG5cXHRcXHRcXHRpZiAoIW9iaiB8fCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdG9sZF9wYXIgPSAob2JqLnBhcmVudCB8fCAkLmpzdHJlZS5yb290KS50b1N0cmluZygpO1xcblxcdFxcdFxcdG5ld19wYXIgPSAhcG9zLnRvU3RyaW5nKCkubWF0Y2goL14oYmVmb3JlfGFmdGVyKSQvKSB8fCBwYXIuaWQgPT09ICQuanN0cmVlLnJvb3QgPyBwYXIgOiB0aGlzLmdldF9ub2RlKHBhci5wYXJlbnQpO1xcblxcdFxcdFxcdG9sZF9pbnMgPSBvcmlnaW4gPyBvcmlnaW4gOiB0aGlzLl9tb2RlbC5kYXRhW29iai5pZF0gPyB0aGlzIDogJC5qc3RyZWUucmVmZXJlbmNlKG9iai5pZCk7XFxuXFx0XFx0XFx0aXNfbXVsdGkgPSAhb2xkX2lucyB8fCAhb2xkX2lucy5faWQgfHwgdGhpcy5faWQgIT09IG9sZF9pbnMuX2lkO1xcblxcdFxcdFxcdG9sZF9wb3MgPSBvbGRfaW5zICYmIG9sZF9pbnMuX2lkICYmIG9sZF9wYXIgJiYgb2xkX2lucy5fbW9kZWwuZGF0YVtvbGRfcGFyXSAmJiBvbGRfaW5zLl9tb2RlbC5kYXRhW29sZF9wYXJdLmNoaWxkcmVuID8gJC5pbkFycmF5KG9iai5pZCwgb2xkX2lucy5fbW9kZWwuZGF0YVtvbGRfcGFyXS5jaGlsZHJlbikgOiAtMTtcXG5cXHRcXHRcXHRpZiAob2xkX2lucyAmJiBvbGRfaW5zLl9pZCkge1xcblxcdFxcdFxcdFxcdG9iaiA9IG9sZF9pbnMuX21vZGVsLmRhdGFbb2JqLmlkXTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKGlzX211bHRpKSB7XFxuXFx0XFx0XFx0XFx0aWYgKHRtcCA9IHRoaXMuY29weV9ub2RlKG9iaiwgcGFyLCBwb3MsIGNhbGxiYWNrLCBpc19sb2FkZWQsIGZhbHNlLCBvcmlnaW4pKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKG9sZF9pbnMpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRvbGRfaW5zLmRlbGV0ZV9ub2RlKG9iaik7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdHJldHVybiB0bXA7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0Ly92YXIgbSA9IHRoaXMuX21vZGVsLmRhdGE7XFxuXFx0XFx0XFx0aWYgKHBhci5pZCA9PT0gJC5qc3RyZWUucm9vdCkge1xcblxcdFxcdFxcdFxcdGlmIChwb3MgPT09IFxcXCJiZWZvcmVcXFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0cG9zID0gXFxcImZpcnN0XFxcIjtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aWYgKHBvcyA9PT0gXFxcImFmdGVyXFxcIikge1xcblxcdFxcdFxcdFxcdFxcdHBvcyA9IFxcXCJsYXN0XFxcIjtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHN3aXRjaCAocG9zKSB7XFxuXFx0XFx0XFx0XFx0Y2FzZSBcXFwiYmVmb3JlXFxcIjpcXG5cXHRcXHRcXHRcXHRcXHRwb3MgPSAkLmluQXJyYXkocGFyLmlkLCBuZXdfcGFyLmNoaWxkcmVuKTtcXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRjYXNlIFxcXCJhZnRlclxcXCI6XFxuXFx0XFx0XFx0XFx0XFx0cG9zID0gJC5pbkFycmF5KHBhci5pZCwgbmV3X3Bhci5jaGlsZHJlbikgKyAxO1xcblxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdGNhc2UgXFxcImluc2lkZVxcXCI6XFxuXFx0XFx0XFx0XFx0Y2FzZSBcXFwiZmlyc3RcXFwiOlxcblxcdFxcdFxcdFxcdFxcdHBvcyA9IDA7XFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0Y2FzZSBcXFwibGFzdFxcXCI6XFxuXFx0XFx0XFx0XFx0XFx0cG9zID0gbmV3X3Bhci5jaGlsZHJlbi5sZW5ndGg7XFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0ZGVmYXVsdDpcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIXBvcykge1xcblxcdFxcdFxcdFxcdFxcdFxcdHBvcyA9IDA7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAocG9zID4gbmV3X3Bhci5jaGlsZHJlbi5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRwb3MgPSBuZXdfcGFyLmNoaWxkcmVuLmxlbmd0aDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKCF0aGlzLmNoZWNrKFxcXCJtb3ZlX25vZGVcXFwiLCBvYmosIG5ld19wYXIsIHBvcywgeyAnY29yZSc6IHRydWUsICdvcmlnaW4nOiBvcmlnaW4sICdpc19tdWx0aSc6IG9sZF9pbnMgJiYgb2xkX2lucy5faWQgJiYgb2xkX2lucy5faWQgIT09IHRoaXMuX2lkLCAnaXNfZm9yZWlnbic6ICFvbGRfaW5zIHx8ICFvbGRfaW5zLl9pZCB9KSkge1xcblxcdFxcdFxcdFxcdHRoaXMuc2V0dGluZ3MuY29yZS5lcnJvci5jYWxsKHRoaXMsIHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmIChvYmoucGFyZW50ID09PSBuZXdfcGFyLmlkKSB7XFxuXFx0XFx0XFx0XFx0ZHBjID0gbmV3X3Bhci5jaGlsZHJlbi5jb25jYXQoKTtcXG5cXHRcXHRcXHRcXHR0bXAgPSAkLmluQXJyYXkob2JqLmlkLCBkcGMpO1xcblxcdFxcdFxcdFxcdGlmICh0bXAgIT09IC0xKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZHBjID0gJC52YWthdGEuYXJyYXlfcmVtb3ZlKGRwYywgdG1wKTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAocG9zID4gdG1wKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cG9zLS07XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR0bXAgPSBbXTtcXG5cXHRcXHRcXHRcXHRmb3IgKGkgPSAwLCBqID0gZHBjLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdHRtcFtpID49IHBvcyA/IGkgKyAxIDogaV0gPSBkcGNbaV07XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHRtcFtwb3NdID0gb2JqLmlkO1xcblxcdFxcdFxcdFxcdG5ld19wYXIuY2hpbGRyZW4gPSB0bXA7XFxuXFx0XFx0XFx0XFx0dGhpcy5fbm9kZV9jaGFuZ2VkKG5ld19wYXIuaWQpO1xcblxcdFxcdFxcdFxcdHRoaXMucmVkcmF3KG5ld19wYXIuaWQgPT09ICQuanN0cmVlLnJvb3QpO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0Ly8gY2xlYW4gb2xkIHBhcmVudCBhbmQgdXBcXG5cXHRcXHRcXHRcXHR0bXAgPSBvYmouY2hpbGRyZW5fZC5jb25jYXQoKTtcXG5cXHRcXHRcXHRcXHR0bXAucHVzaChvYmouaWQpO1xcblxcdFxcdFxcdFxcdGZvciAoaSA9IDAsIGogPSBvYmoucGFyZW50cy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRkcGMgPSBbXTtcXG5cXHRcXHRcXHRcXHRcXHRwID0gb2xkX2lucy5fbW9kZWwuZGF0YVtvYmoucGFyZW50c1tpXV0uY2hpbGRyZW5fZDtcXG5cXHRcXHRcXHRcXHRcXHRmb3IgKGsgPSAwLCBsID0gcC5sZW5ndGg7IGsgPCBsOyBrKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoJC5pbkFycmF5KHBba10sIHRtcCkgPT09IC0xKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZHBjLnB1c2gocFtrXSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRvbGRfaW5zLl9tb2RlbC5kYXRhW29iai5wYXJlbnRzW2ldXS5jaGlsZHJlbl9kID0gZHBjO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRvbGRfaW5zLl9tb2RlbC5kYXRhW29sZF9wYXJdLmNoaWxkcmVuID0gJC52YWthdGEuYXJyYXlfcmVtb3ZlX2l0ZW0ob2xkX2lucy5fbW9kZWwuZGF0YVtvbGRfcGFyXS5jaGlsZHJlbiwgb2JqLmlkKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBpbnNlcnQgaW50byBuZXcgcGFyZW50IGFuZCB1cFxcblxcdFxcdFxcdFxcdGZvciAoaSA9IDAsIGogPSBuZXdfcGFyLnBhcmVudHMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fbW9kZWwuZGF0YVtuZXdfcGFyLnBhcmVudHNbaV1dLmNoaWxkcmVuX2QgPSB0aGlzLl9tb2RlbC5kYXRhW25ld19wYXIucGFyZW50c1tpXV0uY2hpbGRyZW5fZC5jb25jYXQodG1wKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0ZHBjID0gW107XFxuXFx0XFx0XFx0XFx0Zm9yIChpID0gMCwgaiA9IG5ld19wYXIuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZHBjW2kgPj0gcG9zID8gaSArIDEgOiBpXSA9IG5ld19wYXIuY2hpbGRyZW5baV07XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGRwY1twb3NdID0gb2JqLmlkO1xcblxcdFxcdFxcdFxcdG5ld19wYXIuY2hpbGRyZW4gPSBkcGM7XFxuXFx0XFx0XFx0XFx0bmV3X3Bhci5jaGlsZHJlbl9kLnB1c2gob2JqLmlkKTtcXG5cXHRcXHRcXHRcXHRuZXdfcGFyLmNoaWxkcmVuX2QgPSBuZXdfcGFyLmNoaWxkcmVuX2QuY29uY2F0KG9iai5jaGlsZHJlbl9kKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyB1cGRhdGUgb2JqZWN0XFxuXFx0XFx0XFx0XFx0b2JqLnBhcmVudCA9IG5ld19wYXIuaWQ7XFxuXFx0XFx0XFx0XFx0dG1wID0gbmV3X3Bhci5wYXJlbnRzLmNvbmNhdCgpO1xcblxcdFxcdFxcdFxcdHRtcC51bnNoaWZ0KG5ld19wYXIuaWQpO1xcblxcdFxcdFxcdFxcdHAgPSBvYmoucGFyZW50cy5sZW5ndGg7XFxuXFx0XFx0XFx0XFx0b2JqLnBhcmVudHMgPSB0bXA7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gdXBkYXRlIG9iamVjdCBjaGlsZHJlblxcblxcdFxcdFxcdFxcdHRtcCA9IHRtcC5jb25jYXQoKTtcXG5cXHRcXHRcXHRcXHRmb3IgKGkgPSAwLCBqID0gb2JqLmNoaWxkcmVuX2QubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fbW9kZWwuZGF0YVtvYmouY2hpbGRyZW5fZFtpXV0ucGFyZW50cyA9IHRoaXMuX21vZGVsLmRhdGFbb2JqLmNoaWxkcmVuX2RbaV1dLnBhcmVudHMuc2xpY2UoMCwgcCAqIC0xKTtcXG5cXHRcXHRcXHRcXHRcXHRBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSh0aGlzLl9tb2RlbC5kYXRhW29iai5jaGlsZHJlbl9kW2ldXS5wYXJlbnRzLCB0bXApO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAob2xkX3BhciA9PT0gJC5qc3RyZWUucm9vdCB8fCBuZXdfcGFyLmlkID09PSAkLmpzdHJlZS5yb290KSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fbW9kZWwuZm9yY2VfZnVsbF9yZWRyYXcgPSB0cnVlO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRpZiAoIXRoaXMuX21vZGVsLmZvcmNlX2Z1bGxfcmVkcmF3KSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fbm9kZV9jaGFuZ2VkKG9sZF9wYXIpO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX25vZGVfY2hhbmdlZChuZXdfcGFyLmlkKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aWYgKCFza2lwX3JlZHJhdykge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMucmVkcmF3KCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoY2FsbGJhY2spIHtcXG5cXHRcXHRcXHRcXHRjYWxsYmFjay5jYWxsKHRoaXMsIG9iaiwgbmV3X3BhciwgcG9zKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0LyoqXFxuICAgICogdHJpZ2dlcmVkIHdoZW4gYSBub2RlIGlzIG1vdmVkXFxuICAgICogQGV2ZW50XFxuICAgICogQG5hbWUgbW92ZV9ub2RlLmpzdHJlZVxcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlXFxuICAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmVudCB0aGUgcGFyZW50J3MgSURcXG4gICAgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb24gdGhlIHBvc2l0aW9uIG9mIHRoZSBub2RlIGFtb25nIHRoZSBwYXJlbnQncyBjaGlsZHJlblxcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRfcGFyZW50IHRoZSBvbGQgcGFyZW50IG9mIHRoZSBub2RlXFxuICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZF9wb3NpdGlvbiB0aGUgb2xkIHBvc2l0aW9uIG9mIHRoZSBub2RlXFxuICAgICogQHBhcmFtIHtCb29sZWFufSBpc19tdWx0aSBkbyB0aGUgbm9kZSBhbmQgbmV3IHBhcmVudCBiZWxvbmcgdG8gZGlmZmVyZW50IGluc3RhbmNlc1xcbiAgICAqIEBwYXJhbSB7anNUcmVlfSBvbGRfaW5zdGFuY2UgdGhlIGluc3RhbmNlIHRoZSBub2RlIGNhbWUgZnJvbVxcbiAgICAqIEBwYXJhbSB7anNUcmVlfSBuZXdfaW5zdGFuY2UgdGhlIGluc3RhbmNlIG9mIHRoZSBuZXcgcGFyZW50XFxuICAgICovXFxuXFx0XFx0XFx0dGhpcy50cmlnZ2VyKCdtb3ZlX25vZGUnLCB7IFxcXCJub2RlXFxcIjogb2JqLCBcXFwicGFyZW50XFxcIjogbmV3X3Bhci5pZCwgXFxcInBvc2l0aW9uXFxcIjogcG9zLCBcXFwib2xkX3BhcmVudFxcXCI6IG9sZF9wYXIsIFxcXCJvbGRfcG9zaXRpb25cXFwiOiBvbGRfcG9zLCAnaXNfbXVsdGknOiBvbGRfaW5zICYmIG9sZF9pbnMuX2lkICYmIG9sZF9pbnMuX2lkICE9PSB0aGlzLl9pZCwgJ2lzX2ZvcmVpZ24nOiAhb2xkX2lucyB8fCAhb2xkX2lucy5faWQsICdvbGRfaW5zdGFuY2UnOiBvbGRfaW5zLCAnbmV3X2luc3RhbmNlJzogdGhpcyB9KTtcXG5cXHRcXHRcXHRyZXR1cm4gb2JqLmlkO1xcblxcdFxcdH0sXFxuXFx0XFx0LyoqXFxuICAgKiBjb3B5IGEgbm9kZSB0byBhIG5ldyBwYXJlbnRcXG4gICAqIEBuYW1lIGNvcHlfbm9kZShvYmosIHBhciBbLCBwb3MsIGNhbGxiYWNrLCBpc19sb2FkZWRdKVxcbiAgICogQHBhcmFtICB7bWl4ZWR9IG9iaiB0aGUgbm9kZSB0byBjb3B5LCBwYXNzIGFuIGFycmF5IHRvIGNvcHkgbXVsdGlwbGUgbm9kZXNcXG4gICAqIEBwYXJhbSAge21peGVkfSBwYXIgdGhlIG5ldyBwYXJlbnRcXG4gICAqIEBwYXJhbSAge21peGVkfSBwb3MgdGhlIHBvc2l0aW9uIHRvIGluc2VydCBhdCAoYmVzaWRlcyBpbnRlZ2VyIHZhbHVlcywgXFxcImZpcnN0XFxcIiBhbmQgXFxcImxhc3RcXFwiIGFyZSBzdXBwb3J0ZWQsIGFzIHdlbGwgYXMgXFxcImJlZm9yZVxcXCIgYW5kIFxcXCJhZnRlclxcXCIpLCBkZWZhdWx0cyB0byBpbnRlZ2VyIGAwYFxcbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IGNhbGxiYWNrIGEgZnVuY3Rpb24gdG8gY2FsbCBvbmNlIHRoZSBtb3ZlIGlzIGNvbXBsZXRlZCwgcmVjZWl2ZXMgMyBhcmd1bWVudHMgLSB0aGUgbm9kZSwgdGhlIG5ldyBwYXJlbnQgYW5kIHRoZSBwb3NpdGlvblxcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gaXNfbG9hZGVkIGludGVybmFsIHBhcmFtZXRlciBpbmRpY2F0aW5nIGlmIHRoZSBwYXJlbnQgbm9kZSBoYXMgYmVlbiBsb2FkZWRcXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IHNraXBfcmVkcmF3IGludGVybmFsIHBhcmFtZXRlciBpbmRpY2F0aW5nIGlmIHRoZSB0cmVlIHNob3VsZCBiZSByZWRyYXduXFxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBpbnN0YW5jZSBpbnRlcm5hbCBwYXJhbWV0ZXIgaW5kaWNhdGluZyBpZiB0aGUgbm9kZSBjb21lcyBmcm9tIGFub3RoZXIgaW5zdGFuY2VcXG4gICAqIEB0cmlnZ2VyIG1vZGVsLmpzdHJlZSBjb3B5X25vZGUuanN0cmVlXFxuICAgKi9cXG5cXHRcXHRjb3B5X25vZGU6IGZ1bmN0aW9uIGNvcHlfbm9kZShvYmosIHBhciwgcG9zLCBjYWxsYmFjaywgaXNfbG9hZGVkLCBza2lwX3JlZHJhdywgb3JpZ2luKSB7XFxuXFx0XFx0XFx0dmFyIHQxLCB0MiwgZHBjLCB0bXAsIGksIGosIG5vZGUsIG9sZF9wYXIsIG5ld19wYXIsIG9sZF9pbnMsIGlzX211bHRpO1xcblxcblxcdFxcdFxcdHBhciA9IHRoaXMuZ2V0X25vZGUocGFyKTtcXG5cXHRcXHRcXHRwb3MgPSBwb3MgPT09IHVuZGVmaW5lZCA/IDAgOiBwb3M7XFxuXFx0XFx0XFx0aWYgKCFwYXIpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICghcG9zLnRvU3RyaW5nKCkubWF0Y2goL14oYmVmb3JlfGFmdGVyKSQvKSAmJiAhaXNfbG9hZGVkICYmICF0aGlzLmlzX2xvYWRlZChwYXIpKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMubG9hZF9ub2RlKHBhciwgZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuY29weV9ub2RlKG9iaiwgcGFyLCBwb3MsIGNhbGxiYWNrLCB0cnVlLCBmYWxzZSwgb3JpZ2luKTtcXG5cXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCQuaXNBcnJheShvYmopKSB7XFxuXFx0XFx0XFx0XFx0aWYgKG9iai5sZW5ndGggPT09IDEpIHtcXG5cXHRcXHRcXHRcXHRcXHRvYmogPSBvYmpbMF07XFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHQvL29iaiA9IG9iai5zbGljZSgpO1xcblxcdFxcdFxcdFxcdFxcdGZvciAodDEgPSAwLCB0MiA9IG9iai5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAodG1wID0gdGhpcy5jb3B5X25vZGUob2JqW3QxXSwgcGFyLCBwb3MsIGNhbGxiYWNrLCBpc19sb2FkZWQsIHRydWUsIG9yaWdpbikpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRwYXIgPSB0bXA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cG9zID0gXFxcImFmdGVyXFxcIjtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdHRoaXMucmVkcmF3KCk7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRvYmogPSBvYmogJiYgb2JqLmlkID8gb2JqIDogdGhpcy5nZXRfbm9kZShvYmopO1xcblxcdFxcdFxcdGlmICghb2JqIHx8IG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCkge1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0b2xkX3BhciA9IChvYmoucGFyZW50IHx8ICQuanN0cmVlLnJvb3QpLnRvU3RyaW5nKCk7XFxuXFx0XFx0XFx0bmV3X3BhciA9ICFwb3MudG9TdHJpbmcoKS5tYXRjaCgvXihiZWZvcmV8YWZ0ZXIpJC8pIHx8IHBhci5pZCA9PT0gJC5qc3RyZWUucm9vdCA/IHBhciA6IHRoaXMuZ2V0X25vZGUocGFyLnBhcmVudCk7XFxuXFx0XFx0XFx0b2xkX2lucyA9IG9yaWdpbiA/IG9yaWdpbiA6IHRoaXMuX21vZGVsLmRhdGFbb2JqLmlkXSA/IHRoaXMgOiAkLmpzdHJlZS5yZWZlcmVuY2Uob2JqLmlkKTtcXG5cXHRcXHRcXHRpc19tdWx0aSA9ICFvbGRfaW5zIHx8ICFvbGRfaW5zLl9pZCB8fCB0aGlzLl9pZCAhPT0gb2xkX2lucy5faWQ7XFxuXFxuXFx0XFx0XFx0aWYgKG9sZF9pbnMgJiYgb2xkX2lucy5faWQpIHtcXG5cXHRcXHRcXHRcXHRvYmogPSBvbGRfaW5zLl9tb2RlbC5kYXRhW29iai5pZF07XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmIChwYXIuaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcXG5cXHRcXHRcXHRcXHRpZiAocG9zID09PSBcXFwiYmVmb3JlXFxcIikge1xcblxcdFxcdFxcdFxcdFxcdHBvcyA9IFxcXCJmaXJzdFxcXCI7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGlmIChwb3MgPT09IFxcXCJhZnRlclxcXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRwb3MgPSBcXFwibGFzdFxcXCI7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRzd2l0Y2ggKHBvcykge1xcblxcdFxcdFxcdFxcdGNhc2UgXFxcImJlZm9yZVxcXCI6XFxuXFx0XFx0XFx0XFx0XFx0cG9zID0gJC5pbkFycmF5KHBhci5pZCwgbmV3X3Bhci5jaGlsZHJlbik7XFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0Y2FzZSBcXFwiYWZ0ZXJcXFwiOlxcblxcdFxcdFxcdFxcdFxcdHBvcyA9ICQuaW5BcnJheShwYXIuaWQsIG5ld19wYXIuY2hpbGRyZW4pICsgMTtcXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRjYXNlIFxcXCJpbnNpZGVcXFwiOlxcblxcdFxcdFxcdFxcdGNhc2UgXFxcImZpcnN0XFxcIjpcXG5cXHRcXHRcXHRcXHRcXHRwb3MgPSAwO1xcblxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdGNhc2UgXFxcImxhc3RcXFwiOlxcblxcdFxcdFxcdFxcdFxcdHBvcyA9IG5ld19wYXIuY2hpbGRyZW4ubGVuZ3RoO1xcblxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdGRlZmF1bHQ6XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCFwb3MpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRwb3MgPSAwO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKHBvcyA+IG5ld19wYXIuY2hpbGRyZW4ubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0cG9zID0gbmV3X3Bhci5jaGlsZHJlbi5sZW5ndGg7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICghdGhpcy5jaGVjayhcXFwiY29weV9ub2RlXFxcIiwgb2JqLCBuZXdfcGFyLCBwb3MsIHsgJ2NvcmUnOiB0cnVlLCAnb3JpZ2luJzogb3JpZ2luLCAnaXNfbXVsdGknOiBvbGRfaW5zICYmIG9sZF9pbnMuX2lkICYmIG9sZF9pbnMuX2lkICE9PSB0aGlzLl9pZCwgJ2lzX2ZvcmVpZ24nOiAhb2xkX2lucyB8fCAhb2xkX2lucy5faWQgfSkpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLnNldHRpbmdzLmNvcmUuZXJyb3IuY2FsbCh0aGlzLCB0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvcik7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRub2RlID0gb2xkX2lucyA/IG9sZF9pbnMuZ2V0X2pzb24ob2JqLCB7IG5vX2lkOiB0cnVlLCBub19kYXRhOiB0cnVlLCBub19zdGF0ZTogdHJ1ZSB9KSA6IG9iajtcXG5cXHRcXHRcXHRpZiAoIW5vZGUpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmIChub2RlLmlkID09PSB0cnVlKSB7XFxuXFx0XFx0XFx0XFx0ZGVsZXRlIG5vZGUuaWQ7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdG5vZGUgPSB0aGlzLl9wYXJzZV9tb2RlbF9mcm9tX2pzb24obm9kZSwgbmV3X3Bhci5pZCwgbmV3X3Bhci5wYXJlbnRzLmNvbmNhdCgpKTtcXG5cXHRcXHRcXHRpZiAoIW5vZGUpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHRtcCA9IHRoaXMuZ2V0X25vZGUobm9kZSk7XFxuXFx0XFx0XFx0aWYgKG9iaiAmJiBvYmouc3RhdGUgJiYgb2JqLnN0YXRlLmxvYWRlZCA9PT0gZmFsc2UpIHtcXG5cXHRcXHRcXHRcXHR0bXAuc3RhdGUubG9hZGVkID0gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGRwYyA9IFtdO1xcblxcdFxcdFxcdGRwYy5wdXNoKG5vZGUpO1xcblxcdFxcdFxcdGRwYyA9IGRwYy5jb25jYXQodG1wLmNoaWxkcmVuX2QpO1xcblxcdFxcdFxcdHRoaXMudHJpZ2dlcignbW9kZWwnLCB7IFxcXCJub2Rlc1xcXCI6IGRwYywgXFxcInBhcmVudFxcXCI6IG5ld19wYXIuaWQgfSk7XFxuXFxuXFx0XFx0XFx0Ly8gaW5zZXJ0IGludG8gbmV3IHBhcmVudCBhbmQgdXBcXG5cXHRcXHRcXHRmb3IgKGkgPSAwLCBqID0gbmV3X3Bhci5wYXJlbnRzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcblxcdFxcdFxcdFxcdHRoaXMuX21vZGVsLmRhdGFbbmV3X3Bhci5wYXJlbnRzW2ldXS5jaGlsZHJlbl9kID0gdGhpcy5fbW9kZWwuZGF0YVtuZXdfcGFyLnBhcmVudHNbaV1dLmNoaWxkcmVuX2QuY29uY2F0KGRwYyk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGRwYyA9IFtdO1xcblxcdFxcdFxcdGZvciAoaSA9IDAsIGogPSBuZXdfcGFyLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcblxcdFxcdFxcdFxcdGRwY1tpID49IHBvcyA/IGkgKyAxIDogaV0gPSBuZXdfcGFyLmNoaWxkcmVuW2ldO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRkcGNbcG9zXSA9IHRtcC5pZDtcXG5cXHRcXHRcXHRuZXdfcGFyLmNoaWxkcmVuID0gZHBjO1xcblxcdFxcdFxcdG5ld19wYXIuY2hpbGRyZW5fZC5wdXNoKHRtcC5pZCk7XFxuXFx0XFx0XFx0bmV3X3Bhci5jaGlsZHJlbl9kID0gbmV3X3Bhci5jaGlsZHJlbl9kLmNvbmNhdCh0bXAuY2hpbGRyZW5fZCk7XFxuXFxuXFx0XFx0XFx0aWYgKG5ld19wYXIuaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9tb2RlbC5mb3JjZV9mdWxsX3JlZHJhdyA9IHRydWU7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICghdGhpcy5fbW9kZWwuZm9yY2VfZnVsbF9yZWRyYXcpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9ub2RlX2NoYW5nZWQobmV3X3Bhci5pZCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICghc2tpcF9yZWRyYXcpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLnJlZHJhdyhuZXdfcGFyLmlkID09PSAkLmpzdHJlZS5yb290KTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKGNhbGxiYWNrKSB7XFxuXFx0XFx0XFx0XFx0Y2FsbGJhY2suY2FsbCh0aGlzLCB0bXAsIG5ld19wYXIsIHBvcyk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdC8qKlxcbiAgICAqIHRyaWdnZXJlZCB3aGVuIGEgbm9kZSBpcyBjb3BpZWRcXG4gICAgKiBAZXZlbnRcXG4gICAgKiBAbmFtZSBjb3B5X25vZGUuanN0cmVlXFxuICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGUgdGhlIGNvcGllZCBub2RlXFxuICAgICogQHBhcmFtIHtPYmplY3R9IG9yaWdpbmFsIHRoZSBvcmlnaW5hbCBub2RlXFxuICAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmVudCB0aGUgcGFyZW50J3MgSURcXG4gICAgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb24gdGhlIHBvc2l0aW9uIG9mIHRoZSBub2RlIGFtb25nIHRoZSBwYXJlbnQncyBjaGlsZHJlblxcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRfcGFyZW50IHRoZSBvbGQgcGFyZW50IG9mIHRoZSBub2RlXFxuICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZF9wb3NpdGlvbiB0aGUgcG9zaXRpb24gb2YgdGhlIG9yaWdpbmFsIG5vZGVcXG4gICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzX211bHRpIGRvIHRoZSBub2RlIGFuZCBuZXcgcGFyZW50IGJlbG9uZyB0byBkaWZmZXJlbnQgaW5zdGFuY2VzXFxuICAgICogQHBhcmFtIHtqc1RyZWV9IG9sZF9pbnN0YW5jZSB0aGUgaW5zdGFuY2UgdGhlIG5vZGUgY2FtZSBmcm9tXFxuICAgICogQHBhcmFtIHtqc1RyZWV9IG5ld19pbnN0YW5jZSB0aGUgaW5zdGFuY2Ugb2YgdGhlIG5ldyBwYXJlbnRcXG4gICAgKi9cXG5cXHRcXHRcXHR0aGlzLnRyaWdnZXIoJ2NvcHlfbm9kZScsIHsgXFxcIm5vZGVcXFwiOiB0bXAsIFxcXCJvcmlnaW5hbFxcXCI6IG9iaiwgXFxcInBhcmVudFxcXCI6IG5ld19wYXIuaWQsIFxcXCJwb3NpdGlvblxcXCI6IHBvcywgXFxcIm9sZF9wYXJlbnRcXFwiOiBvbGRfcGFyLCBcXFwib2xkX3Bvc2l0aW9uXFxcIjogb2xkX2lucyAmJiBvbGRfaW5zLl9pZCAmJiBvbGRfcGFyICYmIG9sZF9pbnMuX21vZGVsLmRhdGFbb2xkX3Bhcl0gJiYgb2xkX2lucy5fbW9kZWwuZGF0YVtvbGRfcGFyXS5jaGlsZHJlbiA/ICQuaW5BcnJheShvYmouaWQsIG9sZF9pbnMuX21vZGVsLmRhdGFbb2xkX3Bhcl0uY2hpbGRyZW4pIDogLTEsICdpc19tdWx0aSc6IG9sZF9pbnMgJiYgb2xkX2lucy5faWQgJiYgb2xkX2lucy5faWQgIT09IHRoaXMuX2lkLCAnaXNfZm9yZWlnbic6ICFvbGRfaW5zIHx8ICFvbGRfaW5zLl9pZCwgJ29sZF9pbnN0YW5jZSc6IG9sZF9pbnMsICduZXdfaW5zdGFuY2UnOiB0aGlzIH0pO1xcblxcdFxcdFxcdHJldHVybiB0bXAuaWQ7XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIGN1dCBhIG5vZGUgKGEgbGF0ZXIgY2FsbCB0byBgcGFzdGUob2JqKWAgd291bGQgbW92ZSB0aGUgbm9kZSlcXG4gICAqIEBuYW1lIGN1dChvYmopXFxuICAgKiBAcGFyYW0gIHttaXhlZH0gb2JqIG11bHRpcGxlIG9iamVjdHMgY2FuIGJlIHBhc3NlZCB1c2luZyBhbiBhcnJheVxcbiAgICogQHRyaWdnZXIgY3V0LmpzdHJlZVxcbiAgICovXFxuXFx0XFx0Y3V0OiBmdW5jdGlvbiBjdXQob2JqKSB7XFxuXFx0XFx0XFx0aWYgKCFvYmopIHtcXG5cXHRcXHRcXHRcXHRvYmogPSB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQuY29uY2F0KCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICghJC5pc0FycmF5KG9iaikpIHtcXG5cXHRcXHRcXHRcXHRvYmogPSBbb2JqXTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKCFvYmoubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR2YXIgdG1wID0gW10sXFxuXFx0XFx0XFx0ICAgIG8sXFxuXFx0XFx0XFx0ICAgIHQxLFxcblxcdFxcdFxcdCAgICB0MjtcXG5cXHRcXHRcXHRmb3IgKHQxID0gMCwgdDIgPSBvYmoubGVuZ3RoOyB0MSA8IHQyOyB0MSsrKSB7XFxuXFx0XFx0XFx0XFx0byA9IHRoaXMuZ2V0X25vZGUob2JqW3QxXSk7XFxuXFx0XFx0XFx0XFx0aWYgKG8gJiYgby5pZCAmJiBvLmlkICE9PSAkLmpzdHJlZS5yb290KSB7XFxuXFx0XFx0XFx0XFx0XFx0dG1wLnB1c2gobyk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoIXRtcC5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGNjcF9ub2RlID0gdG1wO1xcblxcdFxcdFxcdGNjcF9pbnN0ID0gdGhpcztcXG5cXHRcXHRcXHRjY3BfbW9kZSA9ICdtb3ZlX25vZGUnO1xcblxcdFxcdFxcdC8qKlxcbiAgICAqIHRyaWdnZXJlZCB3aGVuIG5vZGVzIGFyZSBhZGRlZCB0byB0aGUgYnVmZmVyIGZvciBtb3ZpbmdcXG4gICAgKiBAZXZlbnRcXG4gICAgKiBAbmFtZSBjdXQuanN0cmVlXFxuICAgICogQHBhcmFtIHtBcnJheX0gbm9kZVxcbiAgICAqL1xcblxcdFxcdFxcdHRoaXMudHJpZ2dlcignY3V0JywgeyBcXFwibm9kZVxcXCI6IG9iaiB9KTtcXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogY29weSBhIG5vZGUgKGEgbGF0ZXIgY2FsbCB0byBgcGFzdGUob2JqKWAgd291bGQgY29weSB0aGUgbm9kZSlcXG4gICAqIEBuYW1lIGNvcHkob2JqKVxcbiAgICogQHBhcmFtICB7bWl4ZWR9IG9iaiBtdWx0aXBsZSBvYmplY3RzIGNhbiBiZSBwYXNzZWQgdXNpbmcgYW4gYXJyYXlcXG4gICAqIEB0cmlnZ2VyIGNvcHkuanN0cmVlXFxuICAgKi9cXG5cXHRcXHRjb3B5OiBmdW5jdGlvbiBjb3B5KG9iaikge1xcblxcdFxcdFxcdGlmICghb2JqKSB7XFxuXFx0XFx0XFx0XFx0b2JqID0gdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLmNvbmNhdCgpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoISQuaXNBcnJheShvYmopKSB7XFxuXFx0XFx0XFx0XFx0b2JqID0gW29ial07XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICghb2JqLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0dmFyIHRtcCA9IFtdLFxcblxcdFxcdFxcdCAgICBvLFxcblxcdFxcdFxcdCAgICB0MSxcXG5cXHRcXHRcXHQgICAgdDI7XFxuXFx0XFx0XFx0Zm9yICh0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xcblxcdFxcdFxcdFxcdG8gPSB0aGlzLmdldF9ub2RlKG9ialt0MV0pO1xcblxcdFxcdFxcdFxcdGlmIChvICYmIG8uaWQgJiYgby5pZCAhPT0gJC5qc3RyZWUucm9vdCkge1xcblxcdFxcdFxcdFxcdFxcdHRtcC5wdXNoKG8pO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKCF0bXAubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRjY3Bfbm9kZSA9IHRtcDtcXG5cXHRcXHRcXHRjY3BfaW5zdCA9IHRoaXM7XFxuXFx0XFx0XFx0Y2NwX21vZGUgPSAnY29weV9ub2RlJztcXG5cXHRcXHRcXHQvKipcXG4gICAgKiB0cmlnZ2VyZWQgd2hlbiBub2RlcyBhcmUgYWRkZWQgdG8gdGhlIGJ1ZmZlciBmb3IgY29weWluZ1xcbiAgICAqIEBldmVudFxcbiAgICAqIEBuYW1lIGNvcHkuanN0cmVlXFxuICAgICogQHBhcmFtIHtBcnJheX0gbm9kZVxcbiAgICAqL1xcblxcdFxcdFxcdHRoaXMudHJpZ2dlcignY29weScsIHsgXFxcIm5vZGVcXFwiOiBvYmogfSk7XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIGdldCB0aGUgY3VycmVudCBidWZmZXIgKGFueSBub2RlcyB0aGF0IGFyZSB3YWl0aW5nIGZvciBhIHBhc3RlIG9wZXJhdGlvbilcXG4gICAqIEBuYW1lIGdldF9idWZmZXIoKVxcbiAgICogQHJldHVybiB7T2JqZWN0fSBhbiBvYmplY3QgY29uc2lzdGluZyBvZiBgbW9kZWAgKFxcXCJjb3B5X25vZGVcXFwiIG9yIFxcXCJtb3ZlX25vZGVcXFwiKSwgYG5vZGVgIChhbiBhcnJheSBvZiBvYmplY3RzKSBhbmQgYGluc3RgICh0aGUgaW5zdGFuY2UpXFxuICAgKi9cXG5cXHRcXHRnZXRfYnVmZmVyOiBmdW5jdGlvbiBnZXRfYnVmZmVyKCkge1xcblxcdFxcdFxcdHJldHVybiB7ICdtb2RlJzogY2NwX21vZGUsICdub2RlJzogY2NwX25vZGUsICdpbnN0JzogY2NwX2luc3QgfTtcXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogY2hlY2sgaWYgdGhlcmUgaXMgc29tZXRoaW5nIGluIHRoZSBidWZmZXIgdG8gcGFzdGVcXG4gICAqIEBuYW1lIGNhbl9wYXN0ZSgpXFxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxcbiAgICovXFxuXFx0XFx0Y2FuX3Bhc3RlOiBmdW5jdGlvbiBjYW5fcGFzdGUoKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGNjcF9tb2RlICE9PSBmYWxzZSAmJiBjY3Bfbm9kZSAhPT0gZmFsc2U7IC8vICYmIGNjcF9pbnN0Ll9tb2RlbC5kYXRhW2NjcF9ub2RlXTtcXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogY29weSBvciBtb3ZlIHRoZSBwcmV2aW91c2x5IGN1dCBvciBjb3BpZWQgbm9kZXMgdG8gYSBuZXcgcGFyZW50XFxuICAgKiBAbmFtZSBwYXN0ZShvYmogWywgcG9zXSlcXG4gICAqIEBwYXJhbSAge21peGVkfSBvYmogdGhlIG5ldyBwYXJlbnRcXG4gICAqIEBwYXJhbSAge21peGVkfSBwb3MgdGhlIHBvc2l0aW9uIHRvIGluc2VydCBhdCAoYmVzaWRlcyBpbnRlZ2VyLCBcXFwiZmlyc3RcXFwiIGFuZCBcXFwibGFzdFxcXCIgYXJlIHN1cHBvcnRlZCksIGRlZmF1bHRzIHRvIGludGVnZXIgYDBgXFxuICAgKiBAdHJpZ2dlciBwYXN0ZS5qc3RyZWVcXG4gICAqL1xcblxcdFxcdHBhc3RlOiBmdW5jdGlvbiBwYXN0ZShvYmosIHBvcykge1xcblxcdFxcdFxcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXHRcXHRcXHRpZiAoIW9iaiB8fCAhY2NwX21vZGUgfHwgIWNjcF9tb2RlLm1hdGNoKC9eKGNvcHlfbm9kZXxtb3ZlX25vZGUpJC8pIHx8ICFjY3Bfbm9kZSkge1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKHRoaXNbY2NwX21vZGVdKGNjcF9ub2RlLCBvYmosIHBvcywgZmFsc2UsIGZhbHNlLCBmYWxzZSwgY2NwX2luc3QpKSB7XFxuXFx0XFx0XFx0XFx0LyoqXFxuICAgICAqIHRyaWdnZXJlZCB3aGVuIHBhc3RlIGlzIGludm9rZWRcXG4gICAgICogQGV2ZW50XFxuICAgICAqIEBuYW1lIHBhc3RlLmpzdHJlZVxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyZW50IHRoZSBJRCBvZiB0aGUgcmVjZWl2aW5nIG5vZGVcXG4gICAgICogQHBhcmFtIHtBcnJheX0gbm9kZSB0aGUgbm9kZXMgaW4gdGhlIGJ1ZmZlclxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbW9kZSB0aGUgcGVyZm9ybWVkIG9wZXJhdGlvbiAtIFxcXCJjb3B5X25vZGVcXFwiIG9yIFxcXCJtb3ZlX25vZGVcXFwiXFxuICAgICAqL1xcblxcdFxcdFxcdFxcdHRoaXMudHJpZ2dlcigncGFzdGUnLCB7IFxcXCJwYXJlbnRcXFwiOiBvYmouaWQsIFxcXCJub2RlXFxcIjogY2NwX25vZGUsIFxcXCJtb2RlXFxcIjogY2NwX21vZGUgfSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGNjcF9ub2RlID0gZmFsc2U7XFxuXFx0XFx0XFx0Y2NwX21vZGUgPSBmYWxzZTtcXG5cXHRcXHRcXHRjY3BfaW5zdCA9IGZhbHNlO1xcblxcdFxcdH0sXFxuXFx0XFx0LyoqXFxuICAgKiBjbGVhciB0aGUgYnVmZmVyIG9mIHByZXZpb3VzbHkgY29waWVkIG9yIGN1dCBub2Rlc1xcbiAgICogQG5hbWUgY2xlYXJfYnVmZmVyKClcXG4gICAqIEB0cmlnZ2VyIGNsZWFyX2J1ZmZlci5qc3RyZWVcXG4gICAqL1xcblxcdFxcdGNsZWFyX2J1ZmZlcjogZnVuY3Rpb24gY2xlYXJfYnVmZmVyKCkge1xcblxcdFxcdFxcdGNjcF9ub2RlID0gZmFsc2U7XFxuXFx0XFx0XFx0Y2NwX21vZGUgPSBmYWxzZTtcXG5cXHRcXHRcXHRjY3BfaW5zdCA9IGZhbHNlO1xcblxcdFxcdFxcdC8qKlxcbiAgICAqIHRyaWdnZXJlZCB3aGVuIHRoZSBjb3B5IC8gY3V0IGJ1ZmZlciBpcyBjbGVhcmVkXFxuICAgICogQGV2ZW50XFxuICAgICogQG5hbWUgY2xlYXJfYnVmZmVyLmpzdHJlZVxcbiAgICAqL1xcblxcdFxcdFxcdHRoaXMudHJpZ2dlcignY2xlYXJfYnVmZmVyJyk7XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIHB1dCBhIG5vZGUgaW4gZWRpdCBtb2RlIChpbnB1dCBmaWVsZCB0byByZW5hbWUgdGhlIG5vZGUpXFxuICAgKiBAbmFtZSBlZGl0KG9iaiBbLCBkZWZhdWx0X3RleHQsIGNhbGxiYWNrXSlcXG4gICAqIEBwYXJhbSAge21peGVkfSBvYmpcXG4gICAqIEBwYXJhbSAge1N0cmluZ30gZGVmYXVsdF90ZXh0IHRoZSB0ZXh0IHRvIHBvcHVsYXRlIHRoZSBpbnB1dCB3aXRoIChpZiBvbWl0dGVkIG9yIHNldCB0byBhIG5vbi1zdHJpbmcgdmFsdWUgdGhlIG5vZGUncyB0ZXh0IHZhbHVlIGlzIHVzZWQpXFxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2sgYSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb25jZSB0aGUgdGV4dCBib3ggaXMgYmx1cnJlZCwgaXQgaXMgY2FsbGVkIGluIHRoZSBpbnN0YW5jZSdzIHNjb3BlIGFuZCByZWNlaXZlcyB0aGUgbm9kZSwgYSBzdGF0dXMgcGFyYW1ldGVyICh0cnVlIGlmIHRoZSByZW5hbWUgaXMgc3VjY2Vzc2Z1bCwgZmFsc2Ugb3RoZXJ3aXNlKSBhbmQgYSBib29sZWFuIGluZGljYXRpbmcgaWYgdGhlIHVzZXIgY2FuY2VsbGVkIHRoZSBlZGl0LiBZb3UgY2FuIGFjY2VzcyB0aGUgbm9kZSdzIHRpdGxlIHVzaW5nIC50ZXh0XFxuICAgKi9cXG5cXHRcXHRlZGl0OiBmdW5jdGlvbiBlZGl0KG9iaiwgZGVmYXVsdF90ZXh0LCBjYWxsYmFjaykge1xcblxcdFxcdFxcdHZhciBydGwsXFxuXFx0XFx0XFx0ICAgIHcsXFxuXFx0XFx0XFx0ICAgIGEsXFxuXFx0XFx0XFx0ICAgIHMsXFxuXFx0XFx0XFx0ICAgIHQsXFxuXFx0XFx0XFx0ICAgIGgxLFxcblxcdFxcdFxcdCAgICBoMixcXG5cXHRcXHRcXHQgICAgZm4sXFxuXFx0XFx0XFx0ICAgIHRtcCxcXG5cXHRcXHRcXHQgICAgY2FuY2VsID0gZmFsc2U7XFxuXFx0XFx0XFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xcblxcdFxcdFxcdGlmICghb2JqKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAodGhpcy5zZXR0aW5ncy5jb3JlLmNoZWNrX2NhbGxiYWNrID09PSBmYWxzZSkge1xcblxcdFxcdFxcdFxcdHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yID0geyAnZXJyb3InOiAnY2hlY2snLCAncGx1Z2luJzogJ2NvcmUnLCAnaWQnOiAnY29yZV8wNycsICdyZWFzb24nOiAnQ291bGQgbm90IGVkaXQgbm9kZSBiZWNhdXNlIG9mIGNoZWNrX2NhbGxiYWNrJyB9O1xcblxcdFxcdFxcdFxcdHRoaXMuc2V0dGluZ3MuY29yZS5lcnJvci5jYWxsKHRoaXMsIHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHRtcCA9IG9iajtcXG5cXHRcXHRcXHRkZWZhdWx0X3RleHQgPSB0eXBlb2YgZGVmYXVsdF90ZXh0ID09PSAnc3RyaW5nJyA/IGRlZmF1bHRfdGV4dCA6IG9iai50ZXh0O1xcblxcdFxcdFxcdHRoaXMuc2V0X3RleHQob2JqLCBcXFwiXFxcIik7XFxuXFx0XFx0XFx0b2JqID0gdGhpcy5fb3Blbl90byhvYmopO1xcblxcdFxcdFxcdHRtcC50ZXh0ID0gZGVmYXVsdF90ZXh0O1xcblxcblxcdFxcdFxcdHJ0bCA9IHRoaXMuX2RhdGEuY29yZS5ydGw7XFxuXFx0XFx0XFx0dyA9IHRoaXMuZWxlbWVudC53aWR0aCgpO1xcblxcdFxcdFxcdHRoaXMuX2RhdGEuY29yZS5mb2N1c2VkID0gdG1wLmlkO1xcblxcdFxcdFxcdGEgPSBvYmouY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuZm9jdXMoKTtcXG5cXHRcXHRcXHRzID0gJCgnPHNwYW4+Jyk7XFxuXFx0XFx0XFx0LyohXFxuICAgb2kgPSBvYmouY2hpbGRyZW4oXFxcImk6dmlzaWJsZVxcXCIpLFxcbiAgIGFpID0gYS5jaGlsZHJlbihcXFwiaTp2aXNpYmxlXFxcIiksXFxuICAgdzEgPSBvaS53aWR0aCgpICogb2kubGVuZ3RoLFxcbiAgIHcyID0gYWkud2lkdGgoKSAqIGFpLmxlbmd0aCxcXG4gICAqL1xcblxcdFxcdFxcdHQgPSBkZWZhdWx0X3RleHQ7XFxuXFx0XFx0XFx0aDEgPSAkKFxcXCI8XFxcIiArIFxcXCJkaXYgLz5cXFwiLCB7IGNzczogeyBcXFwicG9zaXRpb25cXFwiOiBcXFwiYWJzb2x1dGVcXFwiLCBcXFwidG9wXFxcIjogXFxcIi0yMDBweFxcXCIsIFxcXCJsZWZ0XFxcIjogcnRsID8gXFxcIjBweFxcXCIgOiBcXFwiLTEwMDBweFxcXCIsIFxcXCJ2aXNpYmlsaXR5XFxcIjogXFxcImhpZGRlblxcXCIgfSB9KS5hcHBlbmRUbyhcXFwiYm9keVxcXCIpO1xcblxcdFxcdFxcdGgyID0gJChcXFwiPFxcXCIgKyBcXFwiaW5wdXQgLz5cXFwiLCB7XFxuXFx0XFx0XFx0XFx0XFxcInZhbHVlXFxcIjogdCxcXG5cXHRcXHRcXHRcXHRcXFwiY2xhc3NcXFwiOiBcXFwianN0cmVlLXJlbmFtZS1pbnB1dFxcXCIsXFxuXFx0XFx0XFx0XFx0Ly8gXFxcInNpemVcXFwiIDogdC5sZW5ndGgsXFxuXFx0XFx0XFx0XFx0XFxcImNzc1xcXCI6IHtcXG5cXHRcXHRcXHRcXHRcXHRcXFwicGFkZGluZ1xcXCI6IFxcXCIwXFxcIixcXG5cXHRcXHRcXHRcXHRcXHRcXFwiYm9yZGVyXFxcIjogXFxcIjFweCBzb2xpZCBzaWx2ZXJcXFwiLFxcblxcdFxcdFxcdFxcdFxcdFxcXCJib3gtc2l6aW5nXFxcIjogXFxcImJvcmRlci1ib3hcXFwiLFxcblxcdFxcdFxcdFxcdFxcdFxcXCJkaXNwbGF5XFxcIjogXFxcImlubGluZS1ibG9ja1xcXCIsXFxuXFx0XFx0XFx0XFx0XFx0XFxcImhlaWdodFxcXCI6IHRoaXMuX2RhdGEuY29yZS5saV9oZWlnaHQgKyBcXFwicHhcXFwiLFxcblxcdFxcdFxcdFxcdFxcdFxcXCJsaW5lSGVpZ2h0XFxcIjogdGhpcy5fZGF0YS5jb3JlLmxpX2hlaWdodCArIFxcXCJweFxcXCIsXFxuXFx0XFx0XFx0XFx0XFx0XFxcIndpZHRoXFxcIjogXFxcIjE1MHB4XFxcIiAvLyB3aWxsIGJlIHNldCBhIGJpdCBmdXJ0aGVyIGRvd25cXG5cXHRcXHRcXHRcXHR9LFxcblxcdFxcdFxcdFxcdFxcXCJibHVyXFxcIjogJC5wcm94eShmdW5jdGlvbiAoZSkge1xcblxcdFxcdFxcdFxcdFxcdGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XFxuXFx0XFx0XFx0XFx0XFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdFxcdFxcdFxcdFxcdHZhciBpID0gcy5jaGlsZHJlbihcXFwiLmpzdHJlZS1yZW5hbWUtaW5wdXRcXFwiKSxcXG5cXHRcXHRcXHRcXHRcXHQgICAgdiA9IGkudmFsKCksXFxuXFx0XFx0XFx0XFx0XFx0ICAgIGYgPSB0aGlzLnNldHRpbmdzLmNvcmUuZm9yY2VfdGV4dCxcXG5cXHRcXHRcXHRcXHRcXHQgICAgbnY7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHYgPT09IFxcXCJcXFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0diA9IHQ7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGgxLnJlbW92ZSgpO1xcblxcdFxcdFxcdFxcdFxcdHMucmVwbGFjZVdpdGgoYSk7XFxuXFx0XFx0XFx0XFx0XFx0cy5yZW1vdmUoKTtcXG5cXHRcXHRcXHRcXHRcXHR0ID0gZiA/IHQgOiAkKCc8ZGl2PjwvZGl2PicpLmFwcGVuZCgkLnBhcnNlSFRNTCh0KSkuaHRtbCgpO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuc2V0X3RleHQob2JqLCB0KTtcXG5cXHRcXHRcXHRcXHRcXHRudiA9ICEhdGhpcy5yZW5hbWVfbm9kZShvYmosIGYgPyAkKCc8ZGl2PjwvZGl2PicpLnRleHQodikudGV4dCgpIDogJCgnPGRpdj48L2Rpdj4nKS5hcHBlbmQoJC5wYXJzZUhUTUwodikpLmh0bWwoKSk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCFudikge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuc2V0X3RleHQob2JqLCB0KTsgLy8gbW92ZSB0aGlzIHVwPyBhbmQgZml4ICM0ODNcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fZGF0YS5jb3JlLmZvY3VzZWQgPSB0bXAuaWQ7XFxuXFx0XFx0XFx0XFx0XFx0c2V0VGltZW91dCgkLnByb3h5KGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgbm9kZSA9IHRoaXMuZ2V0X25vZGUodG1wLmlkLCB0cnVlKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAobm9kZS5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl9kYXRhLmNvcmUuZm9jdXNlZCA9IHRtcC5pZDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRub2RlLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLmZvY3VzKCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH0sIHRoaXMpLCAwKTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoY2FsbGJhY2spIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYWxsYmFjay5jYWxsKHRoaXMsIHRtcCwgbnYsIGNhbmNlbCk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGgyID0gbnVsbDtcXG5cXHRcXHRcXHRcXHR9LCB0aGlzKSxcXG5cXHRcXHRcXHRcXHRcXFwia2V5ZG93blxcXCI6IGZ1bmN0aW9uIGtleWRvd24oZSkge1xcblxcdFxcdFxcdFxcdFxcdHZhciBrZXkgPSBlLndoaWNoO1xcblxcdFxcdFxcdFxcdFxcdGlmIChrZXkgPT09IDI3KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FuY2VsID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLnZhbHVlID0gdDtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGtleSA9PT0gMjcgfHwga2V5ID09PSAxMyB8fCBrZXkgPT09IDM3IHx8IGtleSA9PT0gMzggfHwga2V5ID09PSAzOSB8fCBrZXkgPT09IDQwIHx8IGtleSA9PT0gMzIpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRpZiAoa2V5ID09PSAyNyB8fCBrZXkgPT09IDEzKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuYmx1cigpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9LFxcblxcdFxcdFxcdFxcdFxcXCJjbGlja1xcXCI6IGZ1bmN0aW9uIGNsaWNrKGUpIHtcXG5cXHRcXHRcXHRcXHRcXHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xcblxcdFxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0XFx0XFxcIm1vdXNlZG93blxcXCI6IGZ1bmN0aW9uIG1vdXNlZG93bihlKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcXG5cXHRcXHRcXHRcXHR9LFxcblxcdFxcdFxcdFxcdFxcXCJrZXl1cFxcXCI6IGZ1bmN0aW9uIGtleXVwKGUpIHtcXG5cXHRcXHRcXHRcXHRcXHRoMi53aWR0aChNYXRoLm1pbihoMS50ZXh0KFxcXCJwV1xcXCIgKyB0aGlzLnZhbHVlKS53aWR0aCgpLCB3KSk7XFxuXFx0XFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRcXHRcXFwia2V5cHJlc3NcXFwiOiBmdW5jdGlvbiBrZXlwcmVzcyhlKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGUud2hpY2ggPT09IDEzKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0Zm4gPSB7XFxuXFx0XFx0XFx0XFx0Zm9udEZhbWlseTogYS5jc3MoJ2ZvbnRGYW1pbHknKSB8fCAnJyxcXG5cXHRcXHRcXHRcXHRmb250U2l6ZTogYS5jc3MoJ2ZvbnRTaXplJykgfHwgJycsXFxuXFx0XFx0XFx0XFx0Zm9udFdlaWdodDogYS5jc3MoJ2ZvbnRXZWlnaHQnKSB8fCAnJyxcXG5cXHRcXHRcXHRcXHRmb250U3R5bGU6IGEuY3NzKCdmb250U3R5bGUnKSB8fCAnJyxcXG5cXHRcXHRcXHRcXHRmb250U3RyZXRjaDogYS5jc3MoJ2ZvbnRTdHJldGNoJykgfHwgJycsXFxuXFx0XFx0XFx0XFx0Zm9udFZhcmlhbnQ6IGEuY3NzKCdmb250VmFyaWFudCcpIHx8ICcnLFxcblxcdFxcdFxcdFxcdGxldHRlclNwYWNpbmc6IGEuY3NzKCdsZXR0ZXJTcGFjaW5nJykgfHwgJycsXFxuXFx0XFx0XFx0XFx0d29yZFNwYWNpbmc6IGEuY3NzKCd3b3JkU3BhY2luZycpIHx8ICcnXFxuXFx0XFx0XFx0fTtcXG5cXHRcXHRcXHRzLmF0dHIoJ2NsYXNzJywgYS5hdHRyKCdjbGFzcycpKS5hcHBlbmQoYS5jb250ZW50cygpLmNsb25lKCkpLmFwcGVuZChoMik7XFxuXFx0XFx0XFx0YS5yZXBsYWNlV2l0aChzKTtcXG5cXHRcXHRcXHRoMS5jc3MoZm4pO1xcblxcdFxcdFxcdGgyLmNzcyhmbikud2lkdGgoTWF0aC5taW4oaDEudGV4dChcXFwicFdcXFwiICsgaDJbMF0udmFsdWUpLndpZHRoKCksIHcpKVswXS5zZWxlY3QoKTtcXG5cXHRcXHRcXHQkKGRvY3VtZW50KS5vbmUoJ21vdXNlZG93bi5qc3RyZWUgdG91Y2hzdGFydC5qc3RyZWUgZG5kX3N0YXJ0LnZha2F0YScsIGZ1bmN0aW9uIChlKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGgyICYmIGUudGFyZ2V0ICE9PSBoMikge1xcblxcdFxcdFxcdFxcdFxcdCQoaDIpLmJsdXIoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvKipcXG4gICAqIGNoYW5nZXMgdGhlIHRoZW1lXFxuICAgKiBAbmFtZSBzZXRfdGhlbWUodGhlbWVfbmFtZSBbLCB0aGVtZV91cmxdKVxcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRoZW1lX25hbWUgdGhlIG5hbWUgb2YgdGhlIG5ldyB0aGVtZSB0byBhcHBseVxcbiAgICogQHBhcmFtIHttaXhlZH0gdGhlbWVfdXJsICB0aGUgbG9jYXRpb24gb2YgdGhlIENTUyBmaWxlIGZvciB0aGlzIHRoZW1lLiBPbWl0IG9yIHNldCB0byBgZmFsc2VgIGlmIHlvdSBtYW51YWxseSBpbmNsdWRlZCB0aGUgZmlsZS4gU2V0IHRvIGB0cnVlYCB0byBhdXRvbG9hZCBmcm9tIHRoZSBgY29yZS50aGVtZXMuZGlyYCBkaXJlY3RvcnkuXFxuICAgKiBAdHJpZ2dlciBzZXRfdGhlbWUuanN0cmVlXFxuICAgKi9cXG5cXHRcXHRzZXRfdGhlbWU6IGZ1bmN0aW9uIHNldF90aGVtZSh0aGVtZV9uYW1lLCB0aGVtZV91cmwpIHtcXG5cXHRcXHRcXHRpZiAoIXRoZW1lX25hbWUpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICh0aGVtZV91cmwgPT09IHRydWUpIHtcXG5cXHRcXHRcXHRcXHR2YXIgZGlyID0gdGhpcy5zZXR0aW5ncy5jb3JlLnRoZW1lcy5kaXI7XFxuXFx0XFx0XFx0XFx0aWYgKCFkaXIpIHtcXG5cXHRcXHRcXHRcXHRcXHRkaXIgPSAkLmpzdHJlZS5wYXRoICsgJy90aGVtZXMnO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR0aGVtZV91cmwgPSBkaXIgKyAnLycgKyB0aGVtZV9uYW1lICsgJy9zdHlsZS5jc3MnO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAodGhlbWVfdXJsICYmICQuaW5BcnJheSh0aGVtZV91cmwsIHRoZW1lc19sb2FkZWQpID09PSAtMSkge1xcblxcdFxcdFxcdFxcdCQoJ2hlYWQnKS5hcHBlbmQoJzwnICsgJ2xpbmsgcmVsPVxcXCJzdHlsZXNoZWV0XFxcIiBocmVmPVxcXCInICsgdGhlbWVfdXJsICsgJ1xcXCIgdHlwZT1cXFwidGV4dC9jc3NcXFwiIC8+Jyk7XFxuXFx0XFx0XFx0XFx0dGhlbWVzX2xvYWRlZC5wdXNoKHRoZW1lX3VybCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICh0aGlzLl9kYXRhLmNvcmUudGhlbWVzLm5hbWUpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLmVsZW1lbnQucmVtb3ZlQ2xhc3MoJ2pzdHJlZS0nICsgdGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5uYW1lKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0dGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5uYW1lID0gdGhlbWVfbmFtZTtcXG5cXHRcXHRcXHR0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoJ2pzdHJlZS0nICsgdGhlbWVfbmFtZSk7XFxuXFx0XFx0XFx0dGhpcy5lbGVtZW50W3RoaXMuc2V0dGluZ3MuY29yZS50aGVtZXMucmVzcG9uc2l2ZSA/ICdhZGRDbGFzcycgOiAncmVtb3ZlQ2xhc3MnXSgnanN0cmVlLScgKyB0aGVtZV9uYW1lICsgJy1yZXNwb25zaXZlJyk7XFxuXFx0XFx0XFx0LyoqXFxuICAgICogdHJpZ2dlcmVkIHdoZW4gYSB0aGVtZSBpcyBzZXRcXG4gICAgKiBAZXZlbnRcXG4gICAgKiBAbmFtZSBzZXRfdGhlbWUuanN0cmVlXFxuICAgICogQHBhcmFtIHtTdHJpbmd9IHRoZW1lIHRoZSBuZXcgdGhlbWVcXG4gICAgKi9cXG5cXHRcXHRcXHR0aGlzLnRyaWdnZXIoJ3NldF90aGVtZScsIHsgJ3RoZW1lJzogdGhlbWVfbmFtZSB9KTtcXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogZ2V0cyB0aGUgbmFtZSBvZiB0aGUgY3VycmVudGx5IGFwcGxpZWQgdGhlbWUgbmFtZVxcbiAgICogQG5hbWUgZ2V0X3RoZW1lKClcXG4gICAqIEByZXR1cm4ge1N0cmluZ31cXG4gICAqL1xcblxcdFxcdGdldF90aGVtZTogZnVuY3Rpb24gZ2V0X3RoZW1lKCkge1xcblxcdFxcdFxcdHJldHVybiB0aGlzLl9kYXRhLmNvcmUudGhlbWVzLm5hbWU7XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIGNoYW5nZXMgdGhlIHRoZW1lIHZhcmlhbnQgKGlmIHRoZSB0aGVtZSBoYXMgdmFyaWFudHMpXFxuICAgKiBAbmFtZSBzZXRfdGhlbWVfdmFyaWFudCh2YXJpYW50X25hbWUpXFxuICAgKiBAcGFyYW0ge1N0cmluZ3xCb29sZWFufSB2YXJpYW50X25hbWUgdGhlIHZhcmlhbnQgdG8gYXBwbHkgKGlmIGBmYWxzZWAgaXMgdXNlZCB0aGUgY3VycmVudCB2YXJpYW50IGlzIHJlbW92ZWQpXFxuICAgKi9cXG5cXHRcXHRzZXRfdGhlbWVfdmFyaWFudDogZnVuY3Rpb24gc2V0X3RoZW1lX3ZhcmlhbnQodmFyaWFudF9uYW1lKSB7XFxuXFx0XFx0XFx0aWYgKHRoaXMuX2RhdGEuY29yZS50aGVtZXMudmFyaWFudCkge1xcblxcdFxcdFxcdFxcdHRoaXMuZWxlbWVudC5yZW1vdmVDbGFzcygnanN0cmVlLScgKyB0aGlzLl9kYXRhLmNvcmUudGhlbWVzLm5hbWUgKyAnLScgKyB0aGlzLl9kYXRhLmNvcmUudGhlbWVzLnZhcmlhbnQpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR0aGlzLl9kYXRhLmNvcmUudGhlbWVzLnZhcmlhbnQgPSB2YXJpYW50X25hbWU7XFxuXFx0XFx0XFx0aWYgKHZhcmlhbnRfbmFtZSkge1xcblxcdFxcdFxcdFxcdHRoaXMuZWxlbWVudC5hZGRDbGFzcygnanN0cmVlLScgKyB0aGlzLl9kYXRhLmNvcmUudGhlbWVzLm5hbWUgKyAnLScgKyB0aGlzLl9kYXRhLmNvcmUudGhlbWVzLnZhcmlhbnQpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogZ2V0cyB0aGUgbmFtZSBvZiB0aGUgY3VycmVudGx5IGFwcGxpZWQgdGhlbWUgdmFyaWFudFxcbiAgICogQG5hbWUgZ2V0X3RoZW1lKClcXG4gICAqIEByZXR1cm4ge1N0cmluZ31cXG4gICAqL1xcblxcdFxcdGdldF90aGVtZV92YXJpYW50OiBmdW5jdGlvbiBnZXRfdGhlbWVfdmFyaWFudCgpIHtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5fZGF0YS5jb3JlLnRoZW1lcy52YXJpYW50O1xcblxcdFxcdH0sXFxuXFx0XFx0LyoqXFxuICAgKiBzaG93cyBhIHN0cmlwZWQgYmFja2dyb3VuZCBvbiB0aGUgY29udGFpbmVyIChpZiB0aGUgdGhlbWUgc3VwcG9ydHMgaXQpXFxuICAgKiBAbmFtZSBzaG93X3N0cmlwZXMoKVxcbiAgICovXFxuXFx0XFx0c2hvd19zdHJpcGVzOiBmdW5jdGlvbiBzaG93X3N0cmlwZXMoKSB7XFxuXFx0XFx0XFx0dGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5zdHJpcGVzID0gdHJ1ZTtcXG5cXHRcXHRcXHR0aGlzLmdldF9jb250YWluZXJfdWwoKS5hZGRDbGFzcyhcXFwianN0cmVlLXN0cmlwZWRcXFwiKTtcXG5cXHRcXHRcXHQvKipcXG4gICAgKiB0cmlnZ2VyZWQgd2hlbiBzdHJpcGVzIGFyZSBzaG93blxcbiAgICAqIEBldmVudFxcbiAgICAqIEBuYW1lIHNob3dfc3RyaXBlcy5qc3RyZWVcXG4gICAgKi9cXG5cXHRcXHRcXHR0aGlzLnRyaWdnZXIoJ3Nob3dfc3RyaXBlcycpO1xcblxcdFxcdH0sXFxuXFx0XFx0LyoqXFxuICAgKiBoaWRlcyB0aGUgc3RyaXBlZCBiYWNrZ3JvdW5kIG9uIHRoZSBjb250YWluZXJcXG4gICAqIEBuYW1lIGhpZGVfc3RyaXBlcygpXFxuICAgKi9cXG5cXHRcXHRoaWRlX3N0cmlwZXM6IGZ1bmN0aW9uIGhpZGVfc3RyaXBlcygpIHtcXG5cXHRcXHRcXHR0aGlzLl9kYXRhLmNvcmUudGhlbWVzLnN0cmlwZXMgPSBmYWxzZTtcXG5cXHRcXHRcXHR0aGlzLmdldF9jb250YWluZXJfdWwoKS5yZW1vdmVDbGFzcyhcXFwianN0cmVlLXN0cmlwZWRcXFwiKTtcXG5cXHRcXHRcXHQvKipcXG4gICAgKiB0cmlnZ2VyZWQgd2hlbiBzdHJpcGVzIGFyZSBoaWRkZW5cXG4gICAgKiBAZXZlbnRcXG4gICAgKiBAbmFtZSBoaWRlX3N0cmlwZXMuanN0cmVlXFxuICAgICovXFxuXFx0XFx0XFx0dGhpcy50cmlnZ2VyKCdoaWRlX3N0cmlwZXMnKTtcXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogdG9nZ2xlcyB0aGUgc3RyaXBlZCBiYWNrZ3JvdW5kIG9uIHRoZSBjb250YWluZXJcXG4gICAqIEBuYW1lIHRvZ2dsZV9zdHJpcGVzKClcXG4gICAqL1xcblxcdFxcdHRvZ2dsZV9zdHJpcGVzOiBmdW5jdGlvbiB0b2dnbGVfc3RyaXBlcygpIHtcXG5cXHRcXHRcXHRpZiAodGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5zdHJpcGVzKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5oaWRlX3N0cmlwZXMoKTtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdHRoaXMuc2hvd19zdHJpcGVzKCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFx0XFx0LyoqXFxuICAgKiBzaG93cyB0aGUgY29ubmVjdGluZyBkb3RzIChpZiB0aGUgdGhlbWUgc3VwcG9ydHMgaXQpXFxuICAgKiBAbmFtZSBzaG93X2RvdHMoKVxcbiAgICovXFxuXFx0XFx0c2hvd19kb3RzOiBmdW5jdGlvbiBzaG93X2RvdHMoKSB7XFxuXFx0XFx0XFx0dGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5kb3RzID0gdHJ1ZTtcXG5cXHRcXHRcXHR0aGlzLmdldF9jb250YWluZXJfdWwoKS5yZW1vdmVDbGFzcyhcXFwianN0cmVlLW5vLWRvdHNcXFwiKTtcXG5cXHRcXHRcXHQvKipcXG4gICAgKiB0cmlnZ2VyZWQgd2hlbiBkb3RzIGFyZSBzaG93blxcbiAgICAqIEBldmVudFxcbiAgICAqIEBuYW1lIHNob3dfZG90cy5qc3RyZWVcXG4gICAgKi9cXG5cXHRcXHRcXHR0aGlzLnRyaWdnZXIoJ3Nob3dfZG90cycpO1xcblxcdFxcdH0sXFxuXFx0XFx0LyoqXFxuICAgKiBoaWRlcyB0aGUgY29ubmVjdGluZyBkb3RzXFxuICAgKiBAbmFtZSBoaWRlX2RvdHMoKVxcbiAgICovXFxuXFx0XFx0aGlkZV9kb3RzOiBmdW5jdGlvbiBoaWRlX2RvdHMoKSB7XFxuXFx0XFx0XFx0dGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5kb3RzID0gZmFsc2U7XFxuXFx0XFx0XFx0dGhpcy5nZXRfY29udGFpbmVyX3VsKCkuYWRkQ2xhc3MoXFxcImpzdHJlZS1uby1kb3RzXFxcIik7XFxuXFx0XFx0XFx0LyoqXFxuICAgICogdHJpZ2dlcmVkIHdoZW4gZG90cyBhcmUgaGlkZGVuXFxuICAgICogQGV2ZW50XFxuICAgICogQG5hbWUgaGlkZV9kb3RzLmpzdHJlZVxcbiAgICAqL1xcblxcdFxcdFxcdHRoaXMudHJpZ2dlcignaGlkZV9kb3RzJyk7XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIHRvZ2dsZXMgdGhlIGNvbm5lY3RpbmcgZG90c1xcbiAgICogQG5hbWUgdG9nZ2xlX2RvdHMoKVxcbiAgICovXFxuXFx0XFx0dG9nZ2xlX2RvdHM6IGZ1bmN0aW9uIHRvZ2dsZV9kb3RzKCkge1xcblxcdFxcdFxcdGlmICh0aGlzLl9kYXRhLmNvcmUudGhlbWVzLmRvdHMpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLmhpZGVfZG90cygpO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5zaG93X2RvdHMoKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIHNob3cgdGhlIG5vZGUgaWNvbnNcXG4gICAqIEBuYW1lIHNob3dfaWNvbnMoKVxcbiAgICovXFxuXFx0XFx0c2hvd19pY29uczogZnVuY3Rpb24gc2hvd19pY29ucygpIHtcXG5cXHRcXHRcXHR0aGlzLl9kYXRhLmNvcmUudGhlbWVzLmljb25zID0gdHJ1ZTtcXG5cXHRcXHRcXHR0aGlzLmdldF9jb250YWluZXJfdWwoKS5yZW1vdmVDbGFzcyhcXFwianN0cmVlLW5vLWljb25zXFxcIik7XFxuXFx0XFx0XFx0LyoqXFxuICAgICogdHJpZ2dlcmVkIHdoZW4gaWNvbnMgYXJlIHNob3duXFxuICAgICogQGV2ZW50XFxuICAgICogQG5hbWUgc2hvd19pY29ucy5qc3RyZWVcXG4gICAgKi9cXG5cXHRcXHRcXHR0aGlzLnRyaWdnZXIoJ3Nob3dfaWNvbnMnKTtcXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogaGlkZSB0aGUgbm9kZSBpY29uc1xcbiAgICogQG5hbWUgaGlkZV9pY29ucygpXFxuICAgKi9cXG5cXHRcXHRoaWRlX2ljb25zOiBmdW5jdGlvbiBoaWRlX2ljb25zKCkge1xcblxcdFxcdFxcdHRoaXMuX2RhdGEuY29yZS50aGVtZXMuaWNvbnMgPSBmYWxzZTtcXG5cXHRcXHRcXHR0aGlzLmdldF9jb250YWluZXJfdWwoKS5hZGRDbGFzcyhcXFwianN0cmVlLW5vLWljb25zXFxcIik7XFxuXFx0XFx0XFx0LyoqXFxuICAgICogdHJpZ2dlcmVkIHdoZW4gaWNvbnMgYXJlIGhpZGRlblxcbiAgICAqIEBldmVudFxcbiAgICAqIEBuYW1lIGhpZGVfaWNvbnMuanN0cmVlXFxuICAgICovXFxuXFx0XFx0XFx0dGhpcy50cmlnZ2VyKCdoaWRlX2ljb25zJyk7XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIHRvZ2dsZSB0aGUgbm9kZSBpY29uc1xcbiAgICogQG5hbWUgdG9nZ2xlX2ljb25zKClcXG4gICAqL1xcblxcdFxcdHRvZ2dsZV9pY29uczogZnVuY3Rpb24gdG9nZ2xlX2ljb25zKCkge1xcblxcdFxcdFxcdGlmICh0aGlzLl9kYXRhLmNvcmUudGhlbWVzLmljb25zKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5oaWRlX2ljb25zKCk7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHR0aGlzLnNob3dfaWNvbnMoKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIHNob3cgdGhlIG5vZGUgZWxsaXBzaXNcXG4gICAqIEBuYW1lIHNob3dfaWNvbnMoKVxcbiAgICovXFxuXFx0XFx0c2hvd19lbGxpcHNpczogZnVuY3Rpb24gc2hvd19lbGxpcHNpcygpIHtcXG5cXHRcXHRcXHR0aGlzLl9kYXRhLmNvcmUudGhlbWVzLmVsbGlwc2lzID0gdHJ1ZTtcXG5cXHRcXHRcXHR0aGlzLmdldF9jb250YWluZXJfdWwoKS5hZGRDbGFzcyhcXFwianN0cmVlLWVsbGlwc2lzXFxcIik7XFxuXFx0XFx0XFx0LyoqXFxuICAgICogdHJpZ2dlcmVkIHdoZW4gZWxsaXNpcyBpcyBzaG93blxcbiAgICAqIEBldmVudFxcbiAgICAqIEBuYW1lIHNob3dfZWxsaXBzaXMuanN0cmVlXFxuICAgICovXFxuXFx0XFx0XFx0dGhpcy50cmlnZ2VyKCdzaG93X2VsbGlwc2lzJyk7XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIGhpZGUgdGhlIG5vZGUgZWxsaXBzaXNcXG4gICAqIEBuYW1lIGhpZGVfZWxsaXBzaXMoKVxcbiAgICovXFxuXFx0XFx0aGlkZV9lbGxpcHNpczogZnVuY3Rpb24gaGlkZV9lbGxpcHNpcygpIHtcXG5cXHRcXHRcXHR0aGlzLl9kYXRhLmNvcmUudGhlbWVzLmVsbGlwc2lzID0gZmFsc2U7XFxuXFx0XFx0XFx0dGhpcy5nZXRfY29udGFpbmVyX3VsKCkucmVtb3ZlQ2xhc3MoXFxcImpzdHJlZS1lbGxpcHNpc1xcXCIpO1xcblxcdFxcdFxcdC8qKlxcbiAgICAqIHRyaWdnZXJlZCB3aGVuIGVsbGlzaXMgaXMgaGlkZGVuXFxuICAgICogQGV2ZW50XFxuICAgICogQG5hbWUgaGlkZV9lbGxpcHNpcy5qc3RyZWVcXG4gICAgKi9cXG5cXHRcXHRcXHR0aGlzLnRyaWdnZXIoJ2hpZGVfZWxsaXBzaXMnKTtcXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogdG9nZ2xlIHRoZSBub2RlIGVsbGlwc2lzXFxuICAgKiBAbmFtZSB0b2dnbGVfaWNvbnMoKVxcbiAgICovXFxuXFx0XFx0dG9nZ2xlX2VsbGlwc2lzOiBmdW5jdGlvbiB0b2dnbGVfZWxsaXBzaXMoKSB7XFxuXFx0XFx0XFx0aWYgKHRoaXMuX2RhdGEuY29yZS50aGVtZXMuZWxsaXBzaXMpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLmhpZGVfZWxsaXBzaXMoKTtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdHRoaXMuc2hvd19lbGxpcHNpcygpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogc2V0IHRoZSBub2RlIGljb24gZm9yIGEgbm9kZVxcbiAgICogQG5hbWUgc2V0X2ljb24ob2JqLCBpY29uKVxcbiAgICogQHBhcmFtIHttaXhlZH0gb2JqXFxuICAgKiBAcGFyYW0ge1N0cmluZ30gaWNvbiB0aGUgbmV3IGljb24gLSBjYW4gYmUgYSBwYXRoIHRvIGFuIGljb24gb3IgYSBjbGFzc05hbWUsIGlmIHVzaW5nIGFuIGltYWdlIHRoYXQgaXMgaW4gdGhlIGN1cnJlbnQgZGlyZWN0b3J5IHVzZSBhIGAuL2AgcHJlZml4LCBvdGhlcndpc2UgaXQgd2lsbCBiZSBkZXRlY3RlZCBhcyBhIGNsYXNzXFxuICAgKi9cXG5cXHRcXHRzZXRfaWNvbjogZnVuY3Rpb24gc2V0X2ljb24ob2JqLCBpY29uKSB7XFxuXFx0XFx0XFx0dmFyIHQxLCB0MiwgZG9tLCBvbGQ7XFxuXFx0XFx0XFx0aWYgKCQuaXNBcnJheShvYmopKSB7XFxuXFx0XFx0XFx0XFx0b2JqID0gb2JqLnNsaWNlKCk7XFxuXFx0XFx0XFx0XFx0Zm9yICh0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuc2V0X2ljb24ob2JqW3QxXSwgaWNvbik7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XFxuXFx0XFx0XFx0aWYgKCFvYmogfHwgb2JqLmlkID09PSAkLmpzdHJlZS5yb290KSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRvbGQgPSBvYmouaWNvbjtcXG5cXHRcXHRcXHRvYmouaWNvbiA9IGljb24gPT09IHRydWUgfHwgaWNvbiA9PT0gbnVsbCB8fCBpY29uID09PSB1bmRlZmluZWQgfHwgaWNvbiA9PT0gJycgPyB0cnVlIDogaWNvbjtcXG5cXHRcXHRcXHRkb20gPSB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSkuY2hpbGRyZW4oXFxcIi5qc3RyZWUtYW5jaG9yXFxcIikuY2hpbGRyZW4oXFxcIi5qc3RyZWUtdGhlbWVpY29uXFxcIik7XFxuXFx0XFx0XFx0aWYgKGljb24gPT09IGZhbHNlKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5oaWRlX2ljb24ob2JqKTtcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKGljb24gPT09IHRydWUgfHwgaWNvbiA9PT0gbnVsbCB8fCBpY29uID09PSB1bmRlZmluZWQgfHwgaWNvbiA9PT0gJycpIHtcXG5cXHRcXHRcXHRcXHRkb20ucmVtb3ZlQ2xhc3MoJ2pzdHJlZS10aGVtZWljb24tY3VzdG9tICcgKyBvbGQpLmNzcyhcXFwiYmFja2dyb3VuZFxcXCIsIFxcXCJcXFwiKS5yZW1vdmVBdHRyKFxcXCJyZWxcXFwiKTtcXG5cXHRcXHRcXHRcXHRpZiAob2xkID09PSBmYWxzZSkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuc2hvd19pY29uKG9iaik7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0gZWxzZSBpZiAoaWNvbi5pbmRleE9mKFxcXCIvXFxcIikgPT09IC0xICYmIGljb24uaW5kZXhPZihcXFwiLlxcXCIpID09PSAtMSkge1xcblxcdFxcdFxcdFxcdGRvbS5yZW1vdmVDbGFzcyhvbGQpLmNzcyhcXFwiYmFja2dyb3VuZFxcXCIsIFxcXCJcXFwiKTtcXG5cXHRcXHRcXHRcXHRkb20uYWRkQ2xhc3MoaWNvbiArICcganN0cmVlLXRoZW1laWNvbi1jdXN0b20nKS5hdHRyKFxcXCJyZWxcXFwiLCBpY29uKTtcXG5cXHRcXHRcXHRcXHRpZiAob2xkID09PSBmYWxzZSkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuc2hvd19pY29uKG9iaik7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0ZG9tLnJlbW92ZUNsYXNzKG9sZCkuY3NzKFxcXCJiYWNrZ3JvdW5kXFxcIiwgXFxcIlxcXCIpO1xcblxcdFxcdFxcdFxcdGRvbS5hZGRDbGFzcygnanN0cmVlLXRoZW1laWNvbi1jdXN0b20nKS5jc3MoXFxcImJhY2tncm91bmRcXFwiLCBcXFwidXJsKCdcXFwiICsgaWNvbiArIFxcXCInKSBjZW50ZXIgY2VudGVyIG5vLXJlcGVhdFxcXCIpLmF0dHIoXFxcInJlbFxcXCIsIGljb24pO1xcblxcdFxcdFxcdFxcdGlmIChvbGQgPT09IGZhbHNlKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5zaG93X2ljb24ob2JqKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdH0sXFxuXFx0XFx0LyoqXFxuICAgKiBnZXQgdGhlIG5vZGUgaWNvbiBmb3IgYSBub2RlXFxuICAgKiBAbmFtZSBnZXRfaWNvbihvYmopXFxuICAgKiBAcGFyYW0ge21peGVkfSBvYmpcXG4gICAqIEByZXR1cm4ge1N0cmluZ31cXG4gICAqL1xcblxcdFxcdGdldF9pY29uOiBmdW5jdGlvbiBnZXRfaWNvbihvYmopIHtcXG5cXHRcXHRcXHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XFxuXFx0XFx0XFx0cmV0dXJuICFvYmogfHwgb2JqLmlkID09PSAkLmpzdHJlZS5yb290ID8gZmFsc2UgOiBvYmouaWNvbjtcXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogaGlkZSB0aGUgaWNvbiBvbiBhbiBpbmRpdmlkdWFsIG5vZGVcXG4gICAqIEBuYW1lIGhpZGVfaWNvbihvYmopXFxuICAgKiBAcGFyYW0ge21peGVkfSBvYmpcXG4gICAqL1xcblxcdFxcdGhpZGVfaWNvbjogZnVuY3Rpb24gaGlkZV9pY29uKG9iaikge1xcblxcdFxcdFxcdHZhciB0MSwgdDI7XFxuXFx0XFx0XFx0aWYgKCQuaXNBcnJheShvYmopKSB7XFxuXFx0XFx0XFx0XFx0b2JqID0gb2JqLnNsaWNlKCk7XFxuXFx0XFx0XFx0XFx0Zm9yICh0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuaGlkZV9pY29uKG9ialt0MV0pO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xcblxcdFxcdFxcdGlmICghb2JqIHx8IG9iaiA9PT0gJC5qc3RyZWUucm9vdCkge1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0b2JqLmljb24gPSBmYWxzZTtcXG5cXHRcXHRcXHR0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSkuY2hpbGRyZW4oXFxcIi5qc3RyZWUtYW5jaG9yXFxcIikuY2hpbGRyZW4oXFxcIi5qc3RyZWUtdGhlbWVpY29uXFxcIikuYWRkQ2xhc3MoJ2pzdHJlZS10aGVtZWljb24taGlkZGVuJyk7XFxuXFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIHNob3cgdGhlIGljb24gb24gYW4gaW5kaXZpZHVhbCBub2RlXFxuICAgKiBAbmFtZSBzaG93X2ljb24ob2JqKVxcbiAgICogQHBhcmFtIHttaXhlZH0gb2JqXFxuICAgKi9cXG5cXHRcXHRzaG93X2ljb246IGZ1bmN0aW9uIHNob3dfaWNvbihvYmopIHtcXG5cXHRcXHRcXHR2YXIgdDEsIHQyLCBkb207XFxuXFx0XFx0XFx0aWYgKCQuaXNBcnJheShvYmopKSB7XFxuXFx0XFx0XFx0XFx0b2JqID0gb2JqLnNsaWNlKCk7XFxuXFx0XFx0XFx0XFx0Zm9yICh0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuc2hvd19pY29uKG9ialt0MV0pO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xcblxcdFxcdFxcdGlmICghb2JqIHx8IG9iaiA9PT0gJC5qc3RyZWUucm9vdCkge1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0ZG9tID0gdGhpcy5nZXRfbm9kZShvYmosIHRydWUpO1xcblxcdFxcdFxcdG9iai5pY29uID0gZG9tLmxlbmd0aCA/IGRvbS5jaGlsZHJlbihcXFwiLmpzdHJlZS1hbmNob3JcXFwiKS5jaGlsZHJlbihcXFwiLmpzdHJlZS10aGVtZWljb25cXFwiKS5hdHRyKCdyZWwnKSA6IHRydWU7XFxuXFx0XFx0XFx0aWYgKCFvYmouaWNvbikge1xcblxcdFxcdFxcdFxcdG9iai5pY29uID0gdHJ1ZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0ZG9tLmNoaWxkcmVuKFxcXCIuanN0cmVlLWFuY2hvclxcXCIpLmNoaWxkcmVuKFxcXCIuanN0cmVlLXRoZW1laWNvblxcXCIpLnJlbW92ZUNsYXNzKCdqc3RyZWUtdGhlbWVpY29uLWhpZGRlbicpO1xcblxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdH1cXG5cXHR9O1xcblxcblxcdC8vIGhlbHBlcnNcXG5cXHQkLnZha2F0YSA9IHt9O1xcblxcdC8vIGNvbGxlY3QgYXR0cmlidXRlc1xcblxcdCQudmFrYXRhLmF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAobm9kZSwgd2l0aF92YWx1ZXMpIHtcXG5cXHRcXHRub2RlID0gJChub2RlKVswXTtcXG5cXHRcXHR2YXIgYXR0ciA9IHdpdGhfdmFsdWVzID8ge30gOiBbXTtcXG5cXHRcXHRpZiAobm9kZSAmJiBub2RlLmF0dHJpYnV0ZXMpIHtcXG5cXHRcXHRcXHQkLmVhY2gobm9kZS5hdHRyaWJ1dGVzLCBmdW5jdGlvbiAoaSwgdikge1xcblxcdFxcdFxcdFxcdGlmICgkLmluQXJyYXkodi5uYW1lLnRvTG93ZXJDYXNlKCksIFsnc3R5bGUnLCAnY29udGVudGVkaXRhYmxlJywgJ2hhc2ZvY3VzJywgJ3RhYmluZGV4J10pICE9PSAtMSkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aWYgKHYudmFsdWUgIT09IG51bGwgJiYgJC50cmltKHYudmFsdWUpICE9PSAnJykge1xcblxcdFxcdFxcdFxcdFxcdGlmICh3aXRoX3ZhbHVlcykge1xcblxcdFxcdFxcdFxcdFxcdFxcdGF0dHJbdi5uYW1lXSA9IHYudmFsdWU7XFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRhdHRyLnB1c2godi5uYW1lKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0pO1xcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gYXR0cjtcXG5cXHR9O1xcblxcdCQudmFrYXRhLmFycmF5X3VuaXF1ZSA9IGZ1bmN0aW9uIChhcnJheSkge1xcblxcdFxcdHZhciBhID0gW10sXFxuXFx0XFx0ICAgIGksXFxuXFx0XFx0ICAgIGosXFxuXFx0XFx0ICAgIGwsXFxuXFx0XFx0ICAgIG8gPSB7fTtcXG5cXHRcXHRmb3IgKGkgPSAwLCBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XFxuXFx0XFx0XFx0aWYgKG9bYXJyYXlbaV1dID09PSB1bmRlZmluZWQpIHtcXG5cXHRcXHRcXHRcXHRhLnB1c2goYXJyYXlbaV0pO1xcblxcdFxcdFxcdFxcdG9bYXJyYXlbaV1dID0gdHJ1ZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiBhO1xcblxcdH07XFxuXFx0Ly8gcmVtb3ZlIGl0ZW0gZnJvbSBhcnJheVxcblxcdCQudmFrYXRhLmFycmF5X3JlbW92ZSA9IGZ1bmN0aW9uIChhcnJheSwgZnJvbSkge1xcblxcdFxcdGFycmF5LnNwbGljZShmcm9tLCAxKTtcXG5cXHRcXHRyZXR1cm4gYXJyYXk7XFxuXFx0XFx0Ly92YXIgcmVzdCA9IGFycmF5LnNsaWNlKCh0byB8fCBmcm9tKSArIDEgfHwgYXJyYXkubGVuZ3RoKTtcXG5cXHRcXHQvL2FycmF5Lmxlbmd0aCA9IGZyb20gPCAwID8gYXJyYXkubGVuZ3RoICsgZnJvbSA6IGZyb207XFxuXFx0XFx0Ly9hcnJheS5wdXNoLmFwcGx5KGFycmF5LCByZXN0KTtcXG5cXHRcXHQvL3JldHVybiBhcnJheTtcXG5cXHR9O1xcblxcdC8vIHJlbW92ZSBpdGVtIGZyb20gYXJyYXlcXG5cXHQkLnZha2F0YS5hcnJheV9yZW1vdmVfaXRlbSA9IGZ1bmN0aW9uIChhcnJheSwgaXRlbSkge1xcblxcdFxcdHZhciB0bXAgPSAkLmluQXJyYXkoaXRlbSwgYXJyYXkpO1xcblxcdFxcdHJldHVybiB0bXAgIT09IC0xID8gJC52YWthdGEuYXJyYXlfcmVtb3ZlKGFycmF5LCB0bXApIDogYXJyYXk7XFxuXFx0fTtcXG5cXHQkLnZha2F0YS5hcnJheV9maWx0ZXIgPSBmdW5jdGlvbiAoYywgYSwgYiwgZCwgZSkge1xcblxcdFxcdGlmIChjLmZpbHRlcikge1xcblxcdFxcdFxcdHJldHVybiBjLmZpbHRlcihhLCBiKTtcXG5cXHRcXHR9XFxuXFx0XFx0ZCA9IFtdO1xcblxcdFxcdGZvciAoZSBpbiBjKSB7XFxuXFx0XFx0XFx0aWYgKH5+ZSArICcnID09PSBlICsgJycgJiYgZSA+PSAwICYmIGEuY2FsbChiLCBjW2VdLCArZSwgYykpIHtcXG5cXHRcXHRcXHRcXHRkLnB1c2goY1tlXSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gZDtcXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiAjIyMgQ2hhbmdlZCBwbHVnaW5cXG4gICpcXG4gICogVGhpcyBwbHVnaW4gYWRkcyBtb3JlIGluZm9ybWF0aW9uIHRvIHRoZSBgY2hhbmdlZC5qc3RyZWVgIGV2ZW50LiBUaGUgbmV3IGRhdGEgaXMgY29udGFpbmVkIGluIHRoZSBgY2hhbmdlZGAgZXZlbnQgZGF0YSBwcm9wZXJ0eSwgYW5kIGNvbnRhaW5zIGEgbGlzdHMgb2YgYHNlbGVjdGVkYCBhbmQgYGRlc2VsZWN0ZWRgIG5vZGVzLlxcbiAgKi9cXG5cXG5cXHQkLmpzdHJlZS5wbHVnaW5zLmNoYW5nZWQgPSBmdW5jdGlvbiAob3B0aW9ucywgcGFyZW50KSB7XFxuXFx0XFx0dmFyIGxhc3QgPSBbXTtcXG5cXHRcXHR0aGlzLnRyaWdnZXIgPSBmdW5jdGlvbiAoZXYsIGRhdGEpIHtcXG5cXHRcXHRcXHR2YXIgaSwgajtcXG5cXHRcXHRcXHRpZiAoIWRhdGEpIHtcXG5cXHRcXHRcXHRcXHRkYXRhID0ge307XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmIChldi5yZXBsYWNlKCcuanN0cmVlJywgJycpID09PSAnY2hhbmdlZCcpIHtcXG5cXHRcXHRcXHRcXHRkYXRhLmNoYW5nZWQgPSB7IHNlbGVjdGVkOiBbXSwgZGVzZWxlY3RlZDogW10gfTtcXG5cXHRcXHRcXHRcXHR2YXIgdG1wID0ge307XFxuXFx0XFx0XFx0XFx0Zm9yIChpID0gMCwgaiA9IGxhc3QubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0dG1wW2xhc3RbaV1dID0gMTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0Zm9yIChpID0gMCwgaiA9IGRhdGEuc2VsZWN0ZWQubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCF0bXBbZGF0YS5zZWxlY3RlZFtpXV0pIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRkYXRhLmNoYW5nZWQuc2VsZWN0ZWQucHVzaChkYXRhLnNlbGVjdGVkW2ldKTtcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRtcFtkYXRhLnNlbGVjdGVkW2ldXSA9IDI7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRmb3IgKGkgPSAwLCBqID0gbGFzdC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAodG1wW2xhc3RbaV1dID09PSAxKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS5jaGFuZ2VkLmRlc2VsZWN0ZWQucHVzaChsYXN0W2ldKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGxhc3QgPSBkYXRhLnNlbGVjdGVkLnNsaWNlKCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdC8qKlxcbiAgICAqIHRyaWdnZXJlZCB3aGVuIHNlbGVjdGlvbiBjaGFuZ2VzICh0aGUgXFxcImNoYW5nZWRcXFwiIHBsdWdpbiBlbmhhbmNlcyB0aGUgb3JpZ2luYWwgZXZlbnQgd2l0aCBtb3JlIGRhdGEpXFxuICAgICogQGV2ZW50XFxuICAgICogQG5hbWUgY2hhbmdlZC5qc3RyZWVcXG4gICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZVxcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24gdGhlIGFjdGlvbiB0aGF0IGNhdXNlZCB0aGUgc2VsZWN0aW9uIHRvIGNoYW5nZVxcbiAgICAqIEBwYXJhbSB7QXJyYXl9IHNlbGVjdGVkIHRoZSBjdXJyZW50IHNlbGVjdGlvblxcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBjaGFuZ2VkIGFuIG9iamVjdCBjb250YWluaW5nIHR3byBwcm9wZXJ0aWVzIGBzZWxlY3RlZGAgYW5kIGBkZXNlbGVjdGVkYCAtIGJvdGggYXJyYXlzIG9mIG5vZGUgSURzLCB3aGljaCB3ZXJlIHNlbGVjdGVkIG9yIGRlc2VsZWN0ZWQgc2luY2UgdGhlIGxhc3QgY2hhbmdlZCBldmVudFxcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCB0aGUgZXZlbnQgKGlmIGFueSkgdGhhdCB0cmlnZ2VyZWQgdGhpcyBjaGFuZ2VkIGV2ZW50XFxuICAgICogQHBsdWdpbiBjaGFuZ2VkXFxuICAgICovXFxuXFx0XFx0XFx0cGFyZW50LnRyaWdnZXIuY2FsbCh0aGlzLCBldiwgZGF0YSk7XFxuXFx0XFx0fTtcXG5cXHRcXHR0aGlzLnJlZnJlc2ggPSBmdW5jdGlvbiAoc2tpcF9sb2FkaW5nLCBmb3JnZXRfc3RhdGUpIHtcXG5cXHRcXHRcXHRsYXN0ID0gW107XFxuXFx0XFx0XFx0cmV0dXJuIHBhcmVudC5yZWZyZXNoLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuXFx0XFx0fTtcXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiAjIyMgQ2hlY2tib3ggcGx1Z2luXFxuICAqXFxuICAqIFRoaXMgcGx1Z2luIHJlbmRlcnMgY2hlY2tib3ggaWNvbnMgaW4gZnJvbnQgb2YgZWFjaCBub2RlLCBtYWtpbmcgbXVsdGlwbGUgc2VsZWN0aW9uIG11Y2ggZWFzaWVyLlxcbiAgKiBJdCBhbHNvIHN1cHBvcnRzIHRyaS1zdGF0ZSBiZWhhdmlvciwgbWVhbmluZyB0aGF0IGlmIGEgbm9kZSBoYXMgYSBmZXcgb2YgaXRzIGNoaWxkcmVuIGNoZWNrZWQgaXQgd2lsbCBiZSByZW5kZXJlZCBhcyB1bmRldGVybWluZWQsIGFuZCBzdGF0ZSB3aWxsIGJlIHByb3BhZ2F0ZWQgdXAuXFxuICAqL1xcblxcblxcdHZhciBfaSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0knKTtcXG5cXHRfaS5jbGFzc05hbWUgPSAnanN0cmVlLWljb24ganN0cmVlLWNoZWNrYm94JztcXG5cXHRfaS5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAncHJlc2VudGF0aW9uJyk7XFxuXFx0LyoqXFxuICAqIHN0b3JlcyBhbGwgZGVmYXVsdHMgZm9yIHRoZSBjaGVja2JveCBwbHVnaW5cXG4gICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY2hlY2tib3hcXG4gICogQHBsdWdpbiBjaGVja2JveFxcbiAgKi9cXG5cXHQkLmpzdHJlZS5kZWZhdWx0cy5jaGVja2JveCA9IHtcXG5cXHRcXHQvKipcXG4gICAqIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIGNoZWNrYm94ZXMgc2hvdWxkIGJlIHZpc2libGUgKGNhbiBiZSBjaGFuZ2VkIGF0IGEgbGF0ZXIgdGltZSB1c2luZyBgc2hvd19jaGVja2JveGVzKClgIGFuZCBgaGlkZV9jaGVja2JveGVzYCkuIERlZmF1bHRzIHRvIGB0cnVlYC5cXG4gICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNoZWNrYm94LnZpc2libGVcXG4gICAqIEBwbHVnaW4gY2hlY2tib3hcXG4gICAqL1xcblxcdFxcdHZpc2libGU6IHRydWUsXFxuXFx0XFx0LyoqXFxuICAgKiBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiBjaGVja2JveGVzIHNob3VsZCBjYXNjYWRlIGRvd24gYW5kIGhhdmUgYW4gdW5kZXRlcm1pbmVkIHN0YXRlLiBEZWZhdWx0cyB0byBgdHJ1ZWAuXFxuICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jaGVja2JveC50aHJlZV9zdGF0ZVxcbiAgICogQHBsdWdpbiBjaGVja2JveFxcbiAgICovXFxuXFx0XFx0dGhyZWVfc3RhdGU6IHRydWUsXFxuXFx0XFx0LyoqXFxuICAgKiBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiBjbGlja2luZyBhbnl3aGVyZSBvbiB0aGUgbm9kZSBzaG91bGQgYWN0IGFzIGNsaWNraW5nIG9uIHRoZSBjaGVja2JveC4gRGVmYXVsdHMgdG8gYHRydWVgLlxcbiAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY2hlY2tib3gud2hvbGVfbm9kZVxcbiAgICogQHBsdWdpbiBjaGVja2JveFxcbiAgICovXFxuXFx0XFx0d2hvbGVfbm9kZTogdHJ1ZSxcXG5cXHRcXHQvKipcXG4gICAqIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoZSBzZWxlY3RlZCBzdHlsZSBvZiBhIG5vZGUgc2hvdWxkIGJlIGtlcHQsIG9yIHJlbW92ZWQuIERlZmF1bHRzIHRvIGB0cnVlYC5cXG4gICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNoZWNrYm94LmtlZXBfc2VsZWN0ZWRfc3R5bGVcXG4gICAqIEBwbHVnaW4gY2hlY2tib3hcXG4gICAqL1xcblxcdFxcdGtlZXBfc2VsZWN0ZWRfc3R5bGU6IHRydWUsXFxuXFx0XFx0LyoqXFxuICAgKiBUaGlzIHNldHRpbmcgY29udHJvbHMgaG93IGNhc2NhZGluZyBhbmQgdW5kZXRlcm1pbmVkIG5vZGVzIGFyZSBhcHBsaWVkLlxcbiAgICogSWYgJ3VwJyBpcyBpbiB0aGUgc3RyaW5nIC0gY2FzY2FkaW5nIHVwIGlzIGVuYWJsZWQsIGlmICdkb3duJyBpcyBpbiB0aGUgc3RyaW5nIC0gY2FzY2FkaW5nIGRvd24gaXMgZW5hYmxlZCwgaWYgJ3VuZGV0ZXJtaW5lZCcgaXMgaW4gdGhlIHN0cmluZyAtIHVuZGV0ZXJtaW5lZCBub2RlcyB3aWxsIGJlIHVzZWQuXFxuICAgKiBJZiBgdGhyZWVfc3RhdGVgIGlzIHNldCB0byBgdHJ1ZWAgdGhpcyBzZXR0aW5nIGlzIGF1dG9tYXRpY2FsbHkgc2V0IHRvICd1cCtkb3duK3VuZGV0ZXJtaW5lZCcuIERlZmF1bHRzIHRvICcnLlxcbiAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY2hlY2tib3guY2FzY2FkZVxcbiAgICogQHBsdWdpbiBjaGVja2JveFxcbiAgICovXFxuXFx0XFx0Y2FzY2FkZTogJycsXFxuXFx0XFx0LyoqXFxuICAgKiBUaGlzIHNldHRpbmcgY29udHJvbHMgaWYgY2hlY2tib3ggYXJlIGJvdW5kIHRvIHRoZSBnZW5lcmFsIHRyZWUgc2VsZWN0aW9uIG9yIHRvIGFuIGludGVybmFsIGFycmF5IG1haW50YWluZWQgYnkgdGhlIGNoZWNrYm94IHBsdWdpbi4gRGVmYXVsdHMgdG8gYHRydWVgLCBvbmx5IHNldCB0byBgZmFsc2VgIGlmIHlvdSBrbm93IGV4YWN0bHkgd2hhdCB5b3UgYXJlIGRvaW5nLlxcbiAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY2hlY2tib3gudGllX3NlbGVjdGlvblxcbiAgICogQHBsdWdpbiBjaGVja2JveFxcbiAgICovXFxuXFx0XFx0dGllX3NlbGVjdGlvbjogdHJ1ZVxcblxcdH07XFxuXFx0JC5qc3RyZWUucGx1Z2lucy5jaGVja2JveCA9IGZ1bmN0aW9uIChvcHRpb25zLCBwYXJlbnQpIHtcXG5cXHRcXHR0aGlzLmJpbmQgPSBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0cGFyZW50LmJpbmQuY2FsbCh0aGlzKTtcXG5cXHRcXHRcXHR0aGlzLl9kYXRhLmNoZWNrYm94LnV0byA9IGZhbHNlO1xcblxcdFxcdFxcdHRoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWQgPSBbXTtcXG5cXHRcXHRcXHRpZiAodGhpcy5zZXR0aW5ncy5jaGVja2JveC50aHJlZV9zdGF0ZSkge1xcblxcdFxcdFxcdFxcdHRoaXMuc2V0dGluZ3MuY2hlY2tib3guY2FzY2FkZSA9ICd1cCtkb3duK3VuZGV0ZXJtaW5lZCc7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHRoaXMuZWxlbWVudC5vbihcXFwiaW5pdC5qc3RyZWVcXFwiLCAkLnByb3h5KGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9kYXRhLmNoZWNrYm94LnZpc2libGUgPSB0aGlzLnNldHRpbmdzLmNoZWNrYm94LnZpc2libGU7XFxuXFx0XFx0XFx0XFx0aWYgKCF0aGlzLnNldHRpbmdzLmNoZWNrYm94LmtlZXBfc2VsZWN0ZWRfc3R5bGUpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoJ2pzdHJlZS1jaGVja2JveC1uby1jbGlja2VkJyk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGlmICh0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb24pIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoJ2pzdHJlZS1jaGVja2JveC1zZWxlY3Rpb24nKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSwgdGhpcykpLm9uKFxcXCJsb2FkaW5nLmpzdHJlZVxcXCIsICQucHJveHkoZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdHRoaXNbdGhpcy5fZGF0YS5jaGVja2JveC52aXNpYmxlID8gJ3Nob3dfY2hlY2tib3hlcycgOiAnaGlkZV9jaGVja2JveGVzJ10oKTtcXG5cXHRcXHRcXHR9LCB0aGlzKSk7XFxuXFx0XFx0XFx0aWYgKHRoaXMuc2V0dGluZ3MuY2hlY2tib3guY2FzY2FkZS5pbmRleE9mKCd1bmRldGVybWluZWQnKSAhPT0gLTEpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLmVsZW1lbnQub24oJ2NoYW5nZWQuanN0cmVlIHVuY2hlY2tfbm9kZS5qc3RyZWUgY2hlY2tfbm9kZS5qc3RyZWUgdW5jaGVja19hbGwuanN0cmVlIGNoZWNrX2FsbC5qc3RyZWUgbW92ZV9ub2RlLmpzdHJlZSBjb3B5X25vZGUuanN0cmVlIHJlZHJhdy5qc3RyZWUgb3Blbl9ub2RlLmpzdHJlZScsICQucHJveHkoZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdC8vIG9ubHkgaWYgdW5kZXRlcm1pbmVkIGlzIGluIHNldHRpbmdcXG5cXHRcXHRcXHRcXHRcXHRpZiAodGhpcy5fZGF0YS5jaGVja2JveC51dG8pIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRjbGVhclRpbWVvdXQodGhpcy5fZGF0YS5jaGVja2JveC51dG8pO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9kYXRhLmNoZWNrYm94LnV0byA9IHNldFRpbWVvdXQoJC5wcm94eSh0aGlzLl91bmRldGVybWluZWQsIHRoaXMpLCA1MCk7XFxuXFx0XFx0XFx0XFx0fSwgdGhpcykpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoIXRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbikge1xcblxcdFxcdFxcdFxcdHRoaXMuZWxlbWVudC5vbignbW9kZWwuanN0cmVlJywgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xcblxcdFxcdFxcdFxcdFxcdHZhciBtID0gdGhpcy5fbW9kZWwuZGF0YSxcXG5cXHRcXHRcXHRcXHRcXHQgICAgcCA9IG1bZGF0YS5wYXJlbnRdLFxcblxcdFxcdFxcdFxcdFxcdCAgICBkcGMgPSBkYXRhLm5vZGVzLFxcblxcdFxcdFxcdFxcdFxcdCAgICBpLFxcblxcdFxcdFxcdFxcdFxcdCAgICBqO1xcblxcdFxcdFxcdFxcdFxcdGZvciAoaSA9IDAsIGogPSBkcGMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0bVtkcGNbaV1dLnN0YXRlLmNoZWNrZWQgPSBtW2RwY1tpXV0uc3RhdGUuY2hlY2tlZCB8fCBtW2RwY1tpXV0ub3JpZ2luYWwgJiYgbVtkcGNbaV1dLm9yaWdpbmFsLnN0YXRlICYmIG1bZHBjW2ldXS5vcmlnaW5hbC5zdGF0ZS5jaGVja2VkO1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChtW2RwY1tpXV0uc3RhdGUuY2hlY2tlZCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWQucHVzaChkcGNbaV0pO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fSwgdGhpcykpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAodGhpcy5zZXR0aW5ncy5jaGVja2JveC5jYXNjYWRlLmluZGV4T2YoJ3VwJykgIT09IC0xIHx8IHRoaXMuc2V0dGluZ3MuY2hlY2tib3guY2FzY2FkZS5pbmRleE9mKCdkb3duJykgIT09IC0xKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5lbGVtZW50Lm9uKCdtb2RlbC5qc3RyZWUnLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIG0gPSB0aGlzLl9tb2RlbC5kYXRhLFxcblxcdFxcdFxcdFxcdFxcdCAgICBwID0gbVtkYXRhLnBhcmVudF0sXFxuXFx0XFx0XFx0XFx0XFx0ICAgIGRwYyA9IGRhdGEubm9kZXMsXFxuXFx0XFx0XFx0XFx0XFx0ICAgIGNoZCA9IFtdLFxcblxcdFxcdFxcdFxcdFxcdCAgICBjLFxcblxcdFxcdFxcdFxcdFxcdCAgICBpLFxcblxcdFxcdFxcdFxcdFxcdCAgICBqLFxcblxcdFxcdFxcdFxcdFxcdCAgICBrLFxcblxcdFxcdFxcdFxcdFxcdCAgICBsLFxcblxcdFxcdFxcdFxcdFxcdCAgICB0bXAsXFxuXFx0XFx0XFx0XFx0XFx0ICAgIHMgPSB0aGlzLnNldHRpbmdzLmNoZWNrYm94LmNhc2NhZGUsXFxuXFx0XFx0XFx0XFx0XFx0ICAgIHQgPSB0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb247XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKHMuaW5kZXhPZignZG93bicpICE9PSAtMSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdC8vIGFwcGx5IGRvd25cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAocC5zdGF0ZVt0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJ10pIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRmb3IgKGkgPSAwLCBqID0gZHBjLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG1bZHBjW2ldXS5zdGF0ZVt0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJ10gPSB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl9kYXRhW3QgPyAnY29yZScgOiAnY2hlY2tib3gnXS5zZWxlY3RlZCA9IHRoaXMuX2RhdGFbdCA/ICdjb3JlJyA6ICdjaGVja2JveCddLnNlbGVjdGVkLmNvbmNhdChkcGMpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Zm9yIChpID0gMCwgaiA9IGRwYy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAobVtkcGNbaV1dLnN0YXRlW3QgPyAnc2VsZWN0ZWQnIDogJ2NoZWNrZWQnXSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGZvciAoayA9IDAsIGwgPSBtW2RwY1tpXV0uY2hpbGRyZW5fZC5sZW5ndGg7IGsgPCBsOyBrKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRtW21bZHBjW2ldXS5jaGlsZHJlbl9kW2tdXS5zdGF0ZVt0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJ10gPSB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl9kYXRhW3QgPyAnY29yZScgOiAnY2hlY2tib3gnXS5zZWxlY3RlZCA9IHRoaXMuX2RhdGFbdCA/ICdjb3JlJyA6ICdjaGVja2JveCddLnNlbGVjdGVkLmNvbmNhdChtW2RwY1tpXV0uY2hpbGRyZW5fZCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdGlmIChzLmluZGV4T2YoJ3VwJykgIT09IC0xKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gYXBwbHkgdXBcXG5cXHRcXHRcXHRcXHRcXHRcXHRmb3IgKGkgPSAwLCBqID0gcC5jaGlsZHJlbl9kLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICghbVtwLmNoaWxkcmVuX2RbaV1dLmNoaWxkcmVuLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGNoZC5wdXNoKG1bcC5jaGlsZHJlbl9kW2ldXS5wYXJlbnQpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2hkID0gJC52YWthdGEuYXJyYXlfdW5pcXVlKGNoZCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Zm9yIChrID0gMCwgbCA9IGNoZC5sZW5ndGg7IGsgPCBsOyBrKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRwID0gbVtjaGRba11dO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHdoaWxlIChwICYmIHAuaWQgIT09ICQuanN0cmVlLnJvb3QpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjID0gMDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRmb3IgKGkgPSAwLCBqID0gcC5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjICs9IG1bcC5jaGlsZHJlbltpXV0uc3RhdGVbdCA/ICdzZWxlY3RlZCcgOiAnY2hlY2tlZCddO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoYyA9PT0gaikge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHAuc3RhdGVbdCA/ICdzZWxlY3RlZCcgOiAnY2hlY2tlZCddID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl9kYXRhW3QgPyAnY29yZScgOiAnY2hlY2tib3gnXS5zZWxlY3RlZC5wdXNoKHAuaWQpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRtcCA9IHRoaXMuZ2V0X25vZGUocCwgdHJ1ZSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKHRtcCAmJiB0bXAubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dG1wLmF0dHIoJ2FyaWEtc2VsZWN0ZWQnLCB0cnVlKS5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5hZGRDbGFzcyh0ID8gJ2pzdHJlZS1jbGlja2VkJyA6ICdqc3RyZWUtY2hlY2tlZCcpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRwID0gdGhpcy5nZXRfbm9kZShwLnBhcmVudCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fZGF0YVt0ID8gJ2NvcmUnIDogJ2NoZWNrYm94J10uc2VsZWN0ZWQgPSAkLnZha2F0YS5hcnJheV91bmlxdWUodGhpcy5fZGF0YVt0ID8gJ2NvcmUnIDogJ2NoZWNrYm94J10uc2VsZWN0ZWQpO1xcblxcdFxcdFxcdFxcdH0sIHRoaXMpKS5vbih0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb24gPyAnc2VsZWN0X25vZGUuanN0cmVlJyA6ICdjaGVja19ub2RlLmpzdHJlZScsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgb2JqID0gZGF0YS5ub2RlLFxcblxcdFxcdFxcdFxcdFxcdCAgICBtID0gdGhpcy5fbW9kZWwuZGF0YSxcXG5cXHRcXHRcXHRcXHRcXHQgICAgcGFyID0gdGhpcy5nZXRfbm9kZShvYmoucGFyZW50KSxcXG5cXHRcXHRcXHRcXHRcXHQgICAgZG9tID0gdGhpcy5nZXRfbm9kZShvYmosIHRydWUpLFxcblxcdFxcdFxcdFxcdFxcdCAgICBpLFxcblxcdFxcdFxcdFxcdFxcdCAgICBqLFxcblxcdFxcdFxcdFxcdFxcdCAgICBjLFxcblxcdFxcdFxcdFxcdFxcdCAgICB0bXAsXFxuXFx0XFx0XFx0XFx0XFx0ICAgIHMgPSB0aGlzLnNldHRpbmdzLmNoZWNrYm94LmNhc2NhZGUsXFxuXFx0XFx0XFx0XFx0XFx0ICAgIHQgPSB0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb24sXFxuXFx0XFx0XFx0XFx0XFx0ICAgIHNlbCA9IHt9LFxcblxcdFxcdFxcdFxcdFxcdCAgICBjdXIgPSB0aGlzLl9kYXRhW3QgPyAnY29yZScgOiAnY2hlY2tib3gnXS5zZWxlY3RlZDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRmb3IgKGkgPSAwLCBqID0gY3VyLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdFxcdHNlbFtjdXJbaV1dID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0Ly8gYXBwbHkgZG93blxcblxcdFxcdFxcdFxcdFxcdGlmIChzLmluZGV4T2YoJ2Rvd24nKSAhPT0gLTEpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHQvL3RoaXMuX2RhdGFbIHQgPyAnY29yZScgOiAnY2hlY2tib3gnIF0uc2VsZWN0ZWQgPSAkLnZha2F0YS5hcnJheV91bmlxdWUodGhpcy5fZGF0YVsgdCA/ICdjb3JlJyA6ICdjaGVja2JveCcgXS5zZWxlY3RlZC5jb25jYXQob2JqLmNoaWxkcmVuX2QpKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRmb3IgKGkgPSAwLCBqID0gb2JqLmNoaWxkcmVuX2QubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c2VsW29iai5jaGlsZHJlbl9kW2ldXSA9IHRydWU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dG1wID0gbVtvYmouY2hpbGRyZW5fZFtpXV07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dG1wLnN0YXRlW3QgPyAnc2VsZWN0ZWQnIDogJ2NoZWNrZWQnXSA9IHRydWU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKHRtcCAmJiB0bXAub3JpZ2luYWwgJiYgdG1wLm9yaWdpbmFsLnN0YXRlICYmIHRtcC5vcmlnaW5hbC5zdGF0ZS51bmRldGVybWluZWQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0bXAub3JpZ2luYWwuc3RhdGUudW5kZXRlcm1pbmVkID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gYXBwbHkgdXBcXG5cXHRcXHRcXHRcXHRcXHRpZiAocy5pbmRleE9mKCd1cCcpICE9PSAtMSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHdoaWxlIChwYXIgJiYgcGFyLmlkICE9PSAkLmpzdHJlZS5yb290KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YyA9IDA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Zm9yIChpID0gMCwgaiA9IHBhci5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjICs9IG1bcGFyLmNoaWxkcmVuW2ldXS5zdGF0ZVt0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJ107XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChjID09PSBqKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cGFyLnN0YXRlW3QgPyAnc2VsZWN0ZWQnIDogJ2NoZWNrZWQnXSA9IHRydWU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0c2VsW3Bhci5pZF0gPSB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vdGhpcy5fZGF0YVsgdCA/ICdjb3JlJyA6ICdjaGVja2JveCcgXS5zZWxlY3RlZC5wdXNoKHBhci5pZCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dG1wID0gdGhpcy5nZXRfbm9kZShwYXIsIHRydWUpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICh0bXAgJiYgdG1wLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRtcC5hdHRyKCdhcmlhLXNlbGVjdGVkJywgdHJ1ZSkuY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuYWRkQ2xhc3ModCA/ICdqc3RyZWUtY2xpY2tlZCcgOiAnanN0cmVlLWNoZWNrZWQnKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cGFyID0gdGhpcy5nZXRfbm9kZShwYXIucGFyZW50KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdGN1ciA9IFtdO1xcblxcdFxcdFxcdFxcdFxcdGZvciAoaSBpbiBzZWwpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoc2VsLmhhc093blByb3BlcnR5KGkpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y3VyLnB1c2goaSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9kYXRhW3QgPyAnY29yZScgOiAnY2hlY2tib3gnXS5zZWxlY3RlZCA9IGN1cjtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBhcHBseSBkb3duIChwcm9jZXNzIC5jaGlsZHJlbiBzZXBhcmF0ZWx5PylcXG5cXHRcXHRcXHRcXHRcXHRpZiAocy5pbmRleE9mKCdkb3duJykgIT09IC0xICYmIGRvbS5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRkb20uZmluZCgnLmpzdHJlZS1hbmNob3InKS5hZGRDbGFzcyh0ID8gJ2pzdHJlZS1jbGlja2VkJyA6ICdqc3RyZWUtY2hlY2tlZCcpLnBhcmVudCgpLmF0dHIoJ2FyaWEtc2VsZWN0ZWQnLCB0cnVlKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fSwgdGhpcykpLm9uKHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbiA/ICdkZXNlbGVjdF9hbGwuanN0cmVlJyA6ICd1bmNoZWNrX2FsbC5qc3RyZWUnLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIG9iaiA9IHRoaXMuZ2V0X25vZGUoJC5qc3RyZWUucm9vdCksXFxuXFx0XFx0XFx0XFx0XFx0ICAgIG0gPSB0aGlzLl9tb2RlbC5kYXRhLFxcblxcdFxcdFxcdFxcdFxcdCAgICBpLFxcblxcdFxcdFxcdFxcdFxcdCAgICBqLFxcblxcdFxcdFxcdFxcdFxcdCAgICB0bXA7XFxuXFx0XFx0XFx0XFx0XFx0Zm9yIChpID0gMCwgaiA9IG9iai5jaGlsZHJlbl9kLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRtcCA9IG1bb2JqLmNoaWxkcmVuX2RbaV1dO1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICh0bXAgJiYgdG1wLm9yaWdpbmFsICYmIHRtcC5vcmlnaW5hbC5zdGF0ZSAmJiB0bXAub3JpZ2luYWwuc3RhdGUudW5kZXRlcm1pbmVkKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dG1wLm9yaWdpbmFsLnN0YXRlLnVuZGV0ZXJtaW5lZCA9IGZhbHNlO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fSwgdGhpcykpLm9uKHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbiA/ICdkZXNlbGVjdF9ub2RlLmpzdHJlZScgOiAndW5jaGVja19ub2RlLmpzdHJlZScsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgb2JqID0gZGF0YS5ub2RlLFxcblxcdFxcdFxcdFxcdFxcdCAgICBkb20gPSB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSksXFxuXFx0XFx0XFx0XFx0XFx0ICAgIGksXFxuXFx0XFx0XFx0XFx0XFx0ICAgIGosXFxuXFx0XFx0XFx0XFx0XFx0ICAgIHRtcCxcXG5cXHRcXHRcXHRcXHRcXHQgICAgcyA9IHRoaXMuc2V0dGluZ3MuY2hlY2tib3guY2FzY2FkZSxcXG5cXHRcXHRcXHRcXHRcXHQgICAgdCA9IHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbixcXG5cXHRcXHRcXHRcXHRcXHQgICAgY3VyID0gdGhpcy5fZGF0YVt0ID8gJ2NvcmUnIDogJ2NoZWNrYm94J10uc2VsZWN0ZWQsXFxuXFx0XFx0XFx0XFx0XFx0ICAgIHNlbCA9IHt9O1xcblxcdFxcdFxcdFxcdFxcdGlmIChvYmogJiYgb2JqLm9yaWdpbmFsICYmIG9iai5vcmlnaW5hbC5zdGF0ZSAmJiBvYmoub3JpZ2luYWwuc3RhdGUudW5kZXRlcm1pbmVkKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0b2JqLm9yaWdpbmFsLnN0YXRlLnVuZGV0ZXJtaW5lZCA9IGZhbHNlO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBhcHBseSBkb3duXFxuXFx0XFx0XFx0XFx0XFx0aWYgKHMuaW5kZXhPZignZG93bicpICE9PSAtMSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGZvciAoaSA9IDAsIGogPSBvYmouY2hpbGRyZW5fZC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0bXAgPSB0aGlzLl9tb2RlbC5kYXRhW29iai5jaGlsZHJlbl9kW2ldXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0bXAuc3RhdGVbdCA/ICdzZWxlY3RlZCcgOiAnY2hlY2tlZCddID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKHRtcCAmJiB0bXAub3JpZ2luYWwgJiYgdG1wLm9yaWdpbmFsLnN0YXRlICYmIHRtcC5vcmlnaW5hbC5zdGF0ZS51bmRldGVybWluZWQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0bXAub3JpZ2luYWwuc3RhdGUudW5kZXRlcm1pbmVkID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gYXBwbHkgdXBcXG5cXHRcXHRcXHRcXHRcXHRpZiAocy5pbmRleE9mKCd1cCcpICE9PSAtMSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGZvciAoaSA9IDAsIGogPSBvYmoucGFyZW50cy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0bXAgPSB0aGlzLl9tb2RlbC5kYXRhW29iai5wYXJlbnRzW2ldXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0bXAuc3RhdGVbdCA/ICdzZWxlY3RlZCcgOiAnY2hlY2tlZCddID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKHRtcCAmJiB0bXAub3JpZ2luYWwgJiYgdG1wLm9yaWdpbmFsLnN0YXRlICYmIHRtcC5vcmlnaW5hbC5zdGF0ZS51bmRldGVybWluZWQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0bXAub3JpZ2luYWwuc3RhdGUudW5kZXRlcm1pbmVkID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRtcCA9IHRoaXMuZ2V0X25vZGUob2JqLnBhcmVudHNbaV0sIHRydWUpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICh0bXAgJiYgdG1wLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRtcC5hdHRyKCdhcmlhLXNlbGVjdGVkJywgZmFsc2UpLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLnJlbW92ZUNsYXNzKHQgPyAnanN0cmVlLWNsaWNrZWQnIDogJ2pzdHJlZS1jaGVja2VkJyk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0c2VsID0ge307XFxuXFx0XFx0XFx0XFx0XFx0Zm9yIChpID0gMCwgaiA9IGN1ci5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBhcHBseSBkb3duICsgYXBwbHkgdXBcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoKHMuaW5kZXhPZignZG93bicpID09PSAtMSB8fCAkLmluQXJyYXkoY3VyW2ldLCBvYmouY2hpbGRyZW5fZCkgPT09IC0xKSAmJiAocy5pbmRleE9mKCd1cCcpID09PSAtMSB8fCAkLmluQXJyYXkoY3VyW2ldLCBvYmoucGFyZW50cykgPT09IC0xKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHNlbFtjdXJbaV1dID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGN1ciA9IFtdO1xcblxcdFxcdFxcdFxcdFxcdGZvciAoaSBpbiBzZWwpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoc2VsLmhhc093blByb3BlcnR5KGkpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y3VyLnB1c2goaSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9kYXRhW3QgPyAnY29yZScgOiAnY2hlY2tib3gnXS5zZWxlY3RlZCA9IGN1cjtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBhcHBseSBkb3duIChwcm9jZXNzIC5jaGlsZHJlbiBzZXBhcmF0ZWx5PylcXG5cXHRcXHRcXHRcXHRcXHRpZiAocy5pbmRleE9mKCdkb3duJykgIT09IC0xICYmIGRvbS5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRkb20uZmluZCgnLmpzdHJlZS1hbmNob3InKS5yZW1vdmVDbGFzcyh0ID8gJ2pzdHJlZS1jbGlja2VkJyA6ICdqc3RyZWUtY2hlY2tlZCcpLnBhcmVudCgpLmF0dHIoJ2FyaWEtc2VsZWN0ZWQnLCBmYWxzZSk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH0sIHRoaXMpKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKHRoaXMuc2V0dGluZ3MuY2hlY2tib3guY2FzY2FkZS5pbmRleE9mKCd1cCcpICE9PSAtMSkge1xcblxcdFxcdFxcdFxcdHRoaXMuZWxlbWVudC5vbignZGVsZXRlX25vZGUuanN0cmVlJywgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xcblxcdFxcdFxcdFxcdFxcdC8vIGFwcGx5IHVwICh3aG9sZSBoYW5kbGVyKVxcblxcdFxcdFxcdFxcdFxcdHZhciBwID0gdGhpcy5nZXRfbm9kZShkYXRhLnBhcmVudCksXFxuXFx0XFx0XFx0XFx0XFx0ICAgIG0gPSB0aGlzLl9tb2RlbC5kYXRhLFxcblxcdFxcdFxcdFxcdFxcdCAgICBpLFxcblxcdFxcdFxcdFxcdFxcdCAgICBqLFxcblxcdFxcdFxcdFxcdFxcdCAgICBjLFxcblxcdFxcdFxcdFxcdFxcdCAgICB0bXAsXFxuXFx0XFx0XFx0XFx0XFx0ICAgIHQgPSB0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb247XFxuXFx0XFx0XFx0XFx0XFx0d2hpbGUgKHAgJiYgcC5pZCAhPT0gJC5qc3RyZWUucm9vdCAmJiAhcC5zdGF0ZVt0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJ10pIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRjID0gMDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRmb3IgKGkgPSAwLCBqID0gcC5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjICs9IG1bcC5jaGlsZHJlbltpXV0uc3RhdGVbdCA/ICdzZWxlY3RlZCcgOiAnY2hlY2tlZCddO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoaiA+IDAgJiYgYyA9PT0gaikge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHAuc3RhdGVbdCA/ICdzZWxlY3RlZCcgOiAnY2hlY2tlZCddID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl9kYXRhW3QgPyAnY29yZScgOiAnY2hlY2tib3gnXS5zZWxlY3RlZC5wdXNoKHAuaWQpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRtcCA9IHRoaXMuZ2V0X25vZGUocCwgdHJ1ZSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKHRtcCAmJiB0bXAubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dG1wLmF0dHIoJ2FyaWEtc2VsZWN0ZWQnLCB0cnVlKS5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5hZGRDbGFzcyh0ID8gJ2pzdHJlZS1jbGlja2VkJyA6ICdqc3RyZWUtY2hlY2tlZCcpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRwID0gdGhpcy5nZXRfbm9kZShwLnBhcmVudCk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH0sIHRoaXMpKS5vbignbW92ZV9ub2RlLmpzdHJlZScsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcXG5cXHRcXHRcXHRcXHRcXHQvLyBhcHBseSB1cCAod2hvbGUgaGFuZGxlcilcXG5cXHRcXHRcXHRcXHRcXHR2YXIgaXNfbXVsdGkgPSBkYXRhLmlzX211bHRpLFxcblxcdFxcdFxcdFxcdFxcdCAgICBvbGRfcGFyID0gZGF0YS5vbGRfcGFyZW50LFxcblxcdFxcdFxcdFxcdFxcdCAgICBuZXdfcGFyID0gdGhpcy5nZXRfbm9kZShkYXRhLnBhcmVudCksXFxuXFx0XFx0XFx0XFx0XFx0ICAgIG0gPSB0aGlzLl9tb2RlbC5kYXRhLFxcblxcdFxcdFxcdFxcdFxcdCAgICBwLFxcblxcdFxcdFxcdFxcdFxcdCAgICBjLFxcblxcdFxcdFxcdFxcdFxcdCAgICBpLFxcblxcdFxcdFxcdFxcdFxcdCAgICBqLFxcblxcdFxcdFxcdFxcdFxcdCAgICB0bXAsXFxuXFx0XFx0XFx0XFx0XFx0ICAgIHQgPSB0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb247XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCFpc19tdWx0aSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHAgPSB0aGlzLmdldF9ub2RlKG9sZF9wYXIpO1xcblxcdFxcdFxcdFxcdFxcdFxcdHdoaWxlIChwICYmIHAuaWQgIT09ICQuanN0cmVlLnJvb3QgJiYgIXAuc3RhdGVbdCA/ICdzZWxlY3RlZCcgOiAnY2hlY2tlZCddKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YyA9IDA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Zm9yIChpID0gMCwgaiA9IHAuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YyArPSBtW3AuY2hpbGRyZW5baV1dLnN0YXRlW3QgPyAnc2VsZWN0ZWQnIDogJ2NoZWNrZWQnXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKGogPiAwICYmIGMgPT09IGopIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRwLnN0YXRlW3QgPyAnc2VsZWN0ZWQnIDogJ2NoZWNrZWQnXSA9IHRydWU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5fZGF0YVt0ID8gJ2NvcmUnIDogJ2NoZWNrYm94J10uc2VsZWN0ZWQucHVzaChwLmlkKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0bXAgPSB0aGlzLmdldF9ub2RlKHAsIHRydWUpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICh0bXAgJiYgdG1wLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRtcC5hdHRyKCdhcmlhLXNlbGVjdGVkJywgdHJ1ZSkuY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuYWRkQ2xhc3ModCA/ICdqc3RyZWUtY2xpY2tlZCcgOiAnanN0cmVlLWNoZWNrZWQnKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cCA9IHRoaXMuZ2V0X25vZGUocC5wYXJlbnQpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0cCA9IG5ld19wYXI7XFxuXFx0XFx0XFx0XFx0XFx0d2hpbGUgKHAgJiYgcC5pZCAhPT0gJC5qc3RyZWUucm9vdCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGMgPSAwO1xcblxcdFxcdFxcdFxcdFxcdFxcdGZvciAoaSA9IDAsIGogPSBwLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGMgKz0gbVtwLmNoaWxkcmVuW2ldXS5zdGF0ZVt0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJ107XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChjID09PSBqKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCFwLnN0YXRlW3QgPyAnc2VsZWN0ZWQnIDogJ2NoZWNrZWQnXSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHAuc3RhdGVbdCA/ICdzZWxlY3RlZCcgOiAnY2hlY2tlZCddID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl9kYXRhW3QgPyAnY29yZScgOiAnY2hlY2tib3gnXS5zZWxlY3RlZC5wdXNoKHAuaWQpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRtcCA9IHRoaXMuZ2V0X25vZGUocCwgdHJ1ZSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKHRtcCAmJiB0bXAubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dG1wLmF0dHIoJ2FyaWEtc2VsZWN0ZWQnLCB0cnVlKS5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5hZGRDbGFzcyh0ID8gJ2pzdHJlZS1jbGlja2VkJyA6ICdqc3RyZWUtY2hlY2tlZCcpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAocC5zdGF0ZVt0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJ10pIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRwLnN0YXRlW3QgPyAnc2VsZWN0ZWQnIDogJ2NoZWNrZWQnXSA9IGZhbHNlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuX2RhdGFbdCA/ICdjb3JlJyA6ICdjaGVja2JveCddLnNlbGVjdGVkID0gJC52YWthdGEuYXJyYXlfcmVtb3ZlX2l0ZW0odGhpcy5fZGF0YVt0ID8gJ2NvcmUnIDogJ2NoZWNrYm94J10uc2VsZWN0ZWQsIHAuaWQpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRtcCA9IHRoaXMuZ2V0X25vZGUocCwgdHJ1ZSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKHRtcCAmJiB0bXAubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dG1wLmF0dHIoJ2FyaWEtc2VsZWN0ZWQnLCBmYWxzZSkuY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykucmVtb3ZlQ2xhc3ModCA/ICdqc3RyZWUtY2xpY2tlZCcgOiAnanN0cmVlLWNoZWNrZWQnKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdHAgPSB0aGlzLmdldF9ub2RlKHAucGFyZW50KTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fSwgdGhpcykpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9O1xcblxcdFxcdC8qKlxcbiAgICogc2V0IHRoZSB1bmRldGVybWluZWQgc3RhdGUgd2hlcmUgYW5kIGlmIG5lY2Vzc2FyeS4gVXNlZCBpbnRlcm5hbGx5LlxcbiAgICogQHByaXZhdGVcXG4gICAqIEBuYW1lIF91bmRldGVybWluZWQoKVxcbiAgICogQHBsdWdpbiBjaGVja2JveFxcbiAgICovXFxuXFx0XFx0dGhpcy5fdW5kZXRlcm1pbmVkID0gZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdGlmICh0aGlzLmVsZW1lbnQgPT09IG51bGwpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHZhciBpLFxcblxcdFxcdFxcdCAgICBqLFxcblxcdFxcdFxcdCAgICBrLFxcblxcdFxcdFxcdCAgICBsLFxcblxcdFxcdFxcdCAgICBvID0ge30sXFxuXFx0XFx0XFx0ICAgIG0gPSB0aGlzLl9tb2RlbC5kYXRhLFxcblxcdFxcdFxcdCAgICB0ID0gdGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uLFxcblxcdFxcdFxcdCAgICBzID0gdGhpcy5fZGF0YVt0ID8gJ2NvcmUnIDogJ2NoZWNrYm94J10uc2VsZWN0ZWQsXFxuXFx0XFx0XFx0ICAgIHAgPSBbXSxcXG5cXHRcXHRcXHQgICAgdHQgPSB0aGlzO1xcblxcdFxcdFxcdGZvciAoaSA9IDAsIGogPSBzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcblxcdFxcdFxcdFxcdGlmIChtW3NbaV1dICYmIG1bc1tpXV0ucGFyZW50cykge1xcblxcdFxcdFxcdFxcdFxcdGZvciAoayA9IDAsIGwgPSBtW3NbaV1dLnBhcmVudHMubGVuZ3RoOyBrIDwgbDsgaysrKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKG9bbVtzW2ldXS5wYXJlbnRzW2tdXSAhPT0gdW5kZWZpbmVkKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChtW3NbaV1dLnBhcmVudHNba10gIT09ICQuanN0cmVlLnJvb3QpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRvW21bc1tpXV0ucGFyZW50c1trXV0gPSB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHAucHVzaChtW3NbaV1dLnBhcmVudHNba10pO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHQvLyBhdHRlbXB0IGZvciBzZXJ2ZXIgc2lkZSB1bmRldGVybWluZWQgc3RhdGVcXG5cXHRcXHRcXHR0aGlzLmVsZW1lbnQuZmluZCgnLmpzdHJlZS1jbG9zZWQnKS5ub3QoJzpoYXMoLmpzdHJlZS1jaGlsZHJlbiknKS5lYWNoKGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHR2YXIgdG1wID0gdHQuZ2V0X25vZGUodGhpcyksXFxuXFx0XFx0XFx0XFx0ICAgIHRtcDI7XFxuXFx0XFx0XFx0XFx0aWYgKCF0bXAuc3RhdGUubG9hZGVkKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHRtcC5vcmlnaW5hbCAmJiB0bXAub3JpZ2luYWwuc3RhdGUgJiYgdG1wLm9yaWdpbmFsLnN0YXRlLnVuZGV0ZXJtaW5lZCAmJiB0bXAub3JpZ2luYWwuc3RhdGUudW5kZXRlcm1pbmVkID09PSB0cnVlKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKG9bdG1wLmlkXSA9PT0gdW5kZWZpbmVkICYmIHRtcC5pZCAhPT0gJC5qc3RyZWUucm9vdCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG9bdG1wLmlkXSA9IHRydWU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cC5wdXNoKHRtcC5pZCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdGZvciAoayA9IDAsIGwgPSB0bXAucGFyZW50cy5sZW5ndGg7IGsgPCBsOyBrKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAob1t0bXAucGFyZW50c1trXV0gPT09IHVuZGVmaW5lZCAmJiB0bXAucGFyZW50c1trXSAhPT0gJC5qc3RyZWUucm9vdCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG9bdG1wLnBhcmVudHNba11dID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRwLnB1c2godG1wLnBhcmVudHNba10pO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0Zm9yIChpID0gMCwgaiA9IHRtcC5jaGlsZHJlbl9kLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRtcDIgPSBtW3RtcC5jaGlsZHJlbl9kW2ldXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIXRtcDIuc3RhdGUubG9hZGVkICYmIHRtcDIub3JpZ2luYWwgJiYgdG1wMi5vcmlnaW5hbC5zdGF0ZSAmJiB0bXAyLm9yaWdpbmFsLnN0YXRlLnVuZGV0ZXJtaW5lZCAmJiB0bXAyLm9yaWdpbmFsLnN0YXRlLnVuZGV0ZXJtaW5lZCA9PT0gdHJ1ZSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChvW3RtcDIuaWRdID09PSB1bmRlZmluZWQgJiYgdG1wMi5pZCAhPT0gJC5qc3RyZWUucm9vdCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG9bdG1wMi5pZF0gPSB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHAucHVzaCh0bXAyLmlkKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Zm9yIChrID0gMCwgbCA9IHRtcDIucGFyZW50cy5sZW5ndGg7IGsgPCBsOyBrKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAob1t0bXAyLnBhcmVudHNba11dID09PSB1bmRlZmluZWQgJiYgdG1wMi5wYXJlbnRzW2tdICE9PSAkLmpzdHJlZS5yb290KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0b1t0bXAyLnBhcmVudHNba11dID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRwLnB1c2godG1wMi5wYXJlbnRzW2tdKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0pO1xcblxcblxcdFxcdFxcdHRoaXMuZWxlbWVudC5maW5kKCcuanN0cmVlLXVuZGV0ZXJtaW5lZCcpLnJlbW92ZUNsYXNzKCdqc3RyZWUtdW5kZXRlcm1pbmVkJyk7XFxuXFx0XFx0XFx0Zm9yIChpID0gMCwgaiA9IHAubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCFtW3BbaV1dLnN0YXRlW3QgPyAnc2VsZWN0ZWQnIDogJ2NoZWNrZWQnXSkge1xcblxcdFxcdFxcdFxcdFxcdHMgPSB0aGlzLmdldF9ub2RlKHBbaV0sIHRydWUpO1xcblxcdFxcdFxcdFxcdFxcdGlmIChzICYmIHMubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cy5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5jaGlsZHJlbignLmpzdHJlZS1jaGVja2JveCcpLmFkZENsYXNzKCdqc3RyZWUtdW5kZXRlcm1pbmVkJyk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fTtcXG5cXHRcXHR0aGlzLnJlZHJhd19ub2RlID0gZnVuY3Rpb24gKG9iaiwgZGVlcCwgaXNfY2FsbGJhY2ssIGZvcmNlX3JlbmRlcikge1xcblxcdFxcdFxcdG9iaiA9IHBhcmVudC5yZWRyYXdfbm9kZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcblxcdFxcdFxcdGlmIChvYmopIHtcXG5cXHRcXHRcXHRcXHR2YXIgaSxcXG5cXHRcXHRcXHRcXHQgICAgaixcXG5cXHRcXHRcXHRcXHQgICAgdG1wID0gbnVsbCxcXG5cXHRcXHRcXHRcXHQgICAgaWNvbiA9IG51bGw7XFxuXFx0XFx0XFx0XFx0Zm9yIChpID0gMCwgaiA9IG9iai5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdGlmIChvYmouY2hpbGROb2Rlc1tpXSAmJiBvYmouY2hpbGROb2Rlc1tpXS5jbGFzc05hbWUgJiYgb2JqLmNoaWxkTm9kZXNbaV0uY2xhc3NOYW1lLmluZGV4T2YoXFxcImpzdHJlZS1hbmNob3JcXFwiKSAhPT0gLTEpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0bXAgPSBvYmouY2hpbGROb2Rlc1tpXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGlmICh0bXApIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIXRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbiAmJiB0aGlzLl9tb2RlbC5kYXRhW29iai5pZF0uc3RhdGUuY2hlY2tlZCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRtcC5jbGFzc05hbWUgKz0gJyBqc3RyZWUtY2hlY2tlZCc7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGljb24gPSBfaS5jbG9uZU5vZGUoZmFsc2UpO1xcblxcdFxcdFxcdFxcdFxcdGlmICh0aGlzLl9tb2RlbC5kYXRhW29iai5pZF0uc3RhdGUuY2hlY2tib3hfZGlzYWJsZWQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpY29uLmNsYXNzTmFtZSArPSAnIGpzdHJlZS1jaGVja2JveC1kaXNhYmxlZCc7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdHRtcC5pbnNlcnRCZWZvcmUoaWNvbiwgdG1wLmNoaWxkTm9kZXNbMF0pO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKCFpc19jYWxsYmFjayAmJiB0aGlzLnNldHRpbmdzLmNoZWNrYm94LmNhc2NhZGUuaW5kZXhPZigndW5kZXRlcm1pbmVkJykgIT09IC0xKSB7XFxuXFx0XFx0XFx0XFx0aWYgKHRoaXMuX2RhdGEuY2hlY2tib3gudXRvKSB7XFxuXFx0XFx0XFx0XFx0XFx0Y2xlYXJUaW1lb3V0KHRoaXMuX2RhdGEuY2hlY2tib3gudXRvKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0dGhpcy5fZGF0YS5jaGVja2JveC51dG8gPSBzZXRUaW1lb3V0KCQucHJveHkodGhpcy5fdW5kZXRlcm1pbmVkLCB0aGlzKSwgNTApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gb2JqO1xcblxcdFxcdH07XFxuXFx0XFx0LyoqXFxuICAgKiBzaG93IHRoZSBub2RlIGNoZWNrYm94IGljb25zXFxuICAgKiBAbmFtZSBzaG93X2NoZWNrYm94ZXMoKVxcbiAgICogQHBsdWdpbiBjaGVja2JveFxcbiAgICovXFxuXFx0XFx0dGhpcy5zaG93X2NoZWNrYm94ZXMgPSBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0dGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5jaGVja2JveGVzID0gdHJ1ZTt0aGlzLmdldF9jb250YWluZXJfdWwoKS5yZW1vdmVDbGFzcyhcXFwianN0cmVlLW5vLWNoZWNrYm94ZXNcXFwiKTtcXG5cXHRcXHR9O1xcblxcdFxcdC8qKlxcbiAgICogaGlkZSB0aGUgbm9kZSBjaGVja2JveCBpY29uc1xcbiAgICogQG5hbWUgaGlkZV9jaGVja2JveGVzKClcXG4gICAqIEBwbHVnaW4gY2hlY2tib3hcXG4gICAqL1xcblxcdFxcdHRoaXMuaGlkZV9jaGVja2JveGVzID0gZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdHRoaXMuX2RhdGEuY29yZS50aGVtZXMuY2hlY2tib3hlcyA9IGZhbHNlO3RoaXMuZ2V0X2NvbnRhaW5lcl91bCgpLmFkZENsYXNzKFxcXCJqc3RyZWUtbm8tY2hlY2tib3hlc1xcXCIpO1xcblxcdFxcdH07XFxuXFx0XFx0LyoqXFxuICAgKiB0b2dnbGUgdGhlIG5vZGUgaWNvbnNcXG4gICAqIEBuYW1lIHRvZ2dsZV9jaGVja2JveGVzKClcXG4gICAqIEBwbHVnaW4gY2hlY2tib3hcXG4gICAqL1xcblxcdFxcdHRoaXMudG9nZ2xlX2NoZWNrYm94ZXMgPSBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0aWYgKHRoaXMuX2RhdGEuY29yZS50aGVtZXMuY2hlY2tib3hlcykge1xcblxcdFxcdFxcdFxcdHRoaXMuaGlkZV9jaGVja2JveGVzKCk7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHR0aGlzLnNob3dfY2hlY2tib3hlcygpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9O1xcblxcdFxcdC8qKlxcbiAgICogY2hlY2tzIGlmIGEgbm9kZSBpcyBpbiBhbiB1bmRldGVybWluZWQgc3RhdGVcXG4gICAqIEBuYW1lIGlzX3VuZGV0ZXJtaW5lZChvYmopXFxuICAgKiBAcGFyYW0gIHttaXhlZH0gb2JqXFxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxcbiAgICovXFxuXFx0XFx0dGhpcy5pc191bmRldGVybWluZWQgPSBmdW5jdGlvbiAob2JqKSB7XFxuXFx0XFx0XFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xcblxcdFxcdFxcdHZhciBzID0gdGhpcy5zZXR0aW5ncy5jaGVja2JveC5jYXNjYWRlLFxcblxcdFxcdFxcdCAgICBpLFxcblxcdFxcdFxcdCAgICBqLFxcblxcdFxcdFxcdCAgICB0ID0gdGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uLFxcblxcdFxcdFxcdCAgICBkID0gdGhpcy5fZGF0YVt0ID8gJ2NvcmUnIDogJ2NoZWNrYm94J10uc2VsZWN0ZWQsXFxuXFx0XFx0XFx0ICAgIG0gPSB0aGlzLl9tb2RlbC5kYXRhO1xcblxcdFxcdFxcdGlmICghb2JqIHx8IG9iai5zdGF0ZVt0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJ10gPT09IHRydWUgfHwgcy5pbmRleE9mKCd1bmRldGVybWluZWQnKSA9PT0gLTEgfHwgcy5pbmRleE9mKCdkb3duJykgPT09IC0xICYmIHMuaW5kZXhPZigndXAnKSA9PT0gLTEpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICghb2JqLnN0YXRlLmxvYWRlZCAmJiBvYmoub3JpZ2luYWwuc3RhdGUudW5kZXRlcm1pbmVkID09PSB0cnVlKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGZvciAoaSA9IDAsIGogPSBvYmouY2hpbGRyZW5fZC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRpZiAoJC5pbkFycmF5KG9iai5jaGlsZHJlbl9kW2ldLCBkKSAhPT0gLTEgfHwgIW1bb2JqLmNoaWxkcmVuX2RbaV1dLnN0YXRlLmxvYWRlZCAmJiBtW29iai5jaGlsZHJlbl9kW2ldXS5vcmlnaW5hbC5zdGF0ZS51bmRldGVybWluZWQpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHR9O1xcblxcdFxcdC8qKlxcbiAgICogZGlzYWJsZSBhIG5vZGUncyBjaGVja2JveFxcbiAgICogQG5hbWUgZGlzYWJsZV9jaGVja2JveChvYmopXFxuICAgKiBAcGFyYW0ge21peGVkfSBvYmogYW4gYXJyYXkgY2FuIGJlIHVzZWQgdG9vXFxuICAgKiBAdHJpZ2dlciBkaXNhYmxlX2NoZWNrYm94LmpzdHJlZVxcbiAgICogQHBsdWdpbiBjaGVja2JveFxcbiAgICovXFxuXFx0XFx0dGhpcy5kaXNhYmxlX2NoZWNrYm94ID0gZnVuY3Rpb24gKG9iaikge1xcblxcdFxcdFxcdHZhciB0MSwgdDIsIGRvbTtcXG5cXHRcXHRcXHRpZiAoJC5pc0FycmF5KG9iaikpIHtcXG5cXHRcXHRcXHRcXHRvYmogPSBvYmouc2xpY2UoKTtcXG5cXHRcXHRcXHRcXHRmb3IgKHQxID0gMCwgdDIgPSBvYmoubGVuZ3RoOyB0MSA8IHQyOyB0MSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5kaXNhYmxlX2NoZWNrYm94KG9ialt0MV0pO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xcblxcdFxcdFxcdGlmICghb2JqIHx8IG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCkge1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0ZG9tID0gdGhpcy5nZXRfbm9kZShvYmosIHRydWUpO1xcblxcdFxcdFxcdGlmICghb2JqLnN0YXRlLmNoZWNrYm94X2Rpc2FibGVkKSB7XFxuXFx0XFx0XFx0XFx0b2JqLnN0YXRlLmNoZWNrYm94X2Rpc2FibGVkID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRpZiAoZG9tICYmIGRvbS5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRcXHRkb20uY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuY2hpbGRyZW4oJy5qc3RyZWUtY2hlY2tib3gnKS5hZGRDbGFzcygnanN0cmVlLWNoZWNrYm94LWRpc2FibGVkJyk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdC8qKlxcbiAgICAgKiB0cmlnZ2VyZWQgd2hlbiBhbiBub2RlJ3MgY2hlY2tib3ggaXMgZGlzYWJsZWRcXG4gICAgICogQGV2ZW50XFxuICAgICAqIEBuYW1lIGRpc2FibGVfY2hlY2tib3guanN0cmVlXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlXFxuICAgICAqIEBwbHVnaW4gY2hlY2tib3hcXG4gICAgICovXFxuXFx0XFx0XFx0XFx0dGhpcy50cmlnZ2VyKCdkaXNhYmxlX2NoZWNrYm94JywgeyAnbm9kZSc6IG9iaiB9KTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fTtcXG5cXHRcXHQvKipcXG4gICAqIGVuYWJsZSBhIG5vZGUncyBjaGVja2JveFxcbiAgICogQG5hbWUgZGlzYWJsZV9jaGVja2JveChvYmopXFxuICAgKiBAcGFyYW0ge21peGVkfSBvYmogYW4gYXJyYXkgY2FuIGJlIHVzZWQgdG9vXFxuICAgKiBAdHJpZ2dlciBlbmFibGVfY2hlY2tib3guanN0cmVlXFxuICAgKiBAcGx1Z2luIGNoZWNrYm94XFxuICAgKi9cXG5cXHRcXHR0aGlzLmVuYWJsZV9jaGVja2JveCA9IGZ1bmN0aW9uIChvYmopIHtcXG5cXHRcXHRcXHR2YXIgdDEsIHQyLCBkb207XFxuXFx0XFx0XFx0aWYgKCQuaXNBcnJheShvYmopKSB7XFxuXFx0XFx0XFx0XFx0b2JqID0gb2JqLnNsaWNlKCk7XFxuXFx0XFx0XFx0XFx0Zm9yICh0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuZW5hYmxlX2NoZWNrYm94KG9ialt0MV0pO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xcblxcdFxcdFxcdGlmICghb2JqIHx8IG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCkge1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0ZG9tID0gdGhpcy5nZXRfbm9kZShvYmosIHRydWUpO1xcblxcdFxcdFxcdGlmIChvYmouc3RhdGUuY2hlY2tib3hfZGlzYWJsZWQpIHtcXG5cXHRcXHRcXHRcXHRvYmouc3RhdGUuY2hlY2tib3hfZGlzYWJsZWQgPSBmYWxzZTtcXG5cXHRcXHRcXHRcXHRpZiAoZG9tICYmIGRvbS5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRcXHRkb20uY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuY2hpbGRyZW4oJy5qc3RyZWUtY2hlY2tib3gnKS5yZW1vdmVDbGFzcygnanN0cmVlLWNoZWNrYm94LWRpc2FibGVkJyk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdC8qKlxcbiAgICAgKiB0cmlnZ2VyZWQgd2hlbiBhbiBub2RlJ3MgY2hlY2tib3ggaXMgZW5hYmxlZFxcbiAgICAgKiBAZXZlbnRcXG4gICAgICogQG5hbWUgZW5hYmxlX2NoZWNrYm94LmpzdHJlZVxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZVxcbiAgICAgKiBAcGx1Z2luIGNoZWNrYm94XFxuICAgICAqL1xcblxcdFxcdFxcdFxcdHRoaXMudHJpZ2dlcignZW5hYmxlX2NoZWNrYm94JywgeyAnbm9kZSc6IG9iaiB9KTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fTtcXG5cXG5cXHRcXHR0aGlzLmFjdGl2YXRlX25vZGUgPSBmdW5jdGlvbiAob2JqLCBlKSB7XFxuXFx0XFx0XFx0aWYgKCQoZS50YXJnZXQpLmhhc0NsYXNzKCdqc3RyZWUtY2hlY2tib3gtZGlzYWJsZWQnKSkge1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbiAmJiAodGhpcy5zZXR0aW5ncy5jaGVja2JveC53aG9sZV9ub2RlIHx8ICQoZS50YXJnZXQpLmhhc0NsYXNzKCdqc3RyZWUtY2hlY2tib3gnKSkpIHtcXG5cXHRcXHRcXHRcXHRlLmN0cmxLZXkgPSB0cnVlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAodGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uIHx8ICF0aGlzLnNldHRpbmdzLmNoZWNrYm94Lndob2xlX25vZGUgJiYgISQoZS50YXJnZXQpLmhhc0NsYXNzKCdqc3RyZWUtY2hlY2tib3gnKSkge1xcblxcdFxcdFxcdFxcdHJldHVybiBwYXJlbnQuYWN0aXZhdGVfbm9kZS5jYWxsKHRoaXMsIG9iaiwgZSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICh0aGlzLmlzX2Rpc2FibGVkKG9iaikpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICh0aGlzLmlzX2NoZWNrZWQob2JqKSkge1xcblxcdFxcdFxcdFxcdHRoaXMudW5jaGVja19ub2RlKG9iaiwgZSk7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHR0aGlzLmNoZWNrX25vZGUob2JqLCBlKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0dGhpcy50cmlnZ2VyKCdhY3RpdmF0ZV9ub2RlJywgeyAnbm9kZSc6IHRoaXMuZ2V0X25vZGUob2JqKSB9KTtcXG5cXHRcXHR9O1xcblxcblxcdFxcdC8qKlxcbiAgICogY2hlY2sgYSBub2RlIChvbmx5IGlmIHRpZV9zZWxlY3Rpb24gaW4gY2hlY2tib3ggc2V0dGluZ3MgaXMgZmFsc2UsIG90aGVyd2lzZSBzZWxlY3Rfbm9kZSB3aWxsIGJlIGNhbGxlZCBpbnRlcm5hbGx5KVxcbiAgICogQG5hbWUgY2hlY2tfbm9kZShvYmopXFxuICAgKiBAcGFyYW0ge21peGVkfSBvYmogYW4gYXJyYXkgY2FuIGJlIHVzZWQgdG8gY2hlY2sgbXVsdGlwbGUgbm9kZXNcXG4gICAqIEB0cmlnZ2VyIGNoZWNrX25vZGUuanN0cmVlXFxuICAgKiBAcGx1Z2luIGNoZWNrYm94XFxuICAgKi9cXG5cXHRcXHR0aGlzLmNoZWNrX25vZGUgPSBmdW5jdGlvbiAob2JqLCBlKSB7XFxuXFx0XFx0XFx0aWYgKHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbikge1xcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLnNlbGVjdF9ub2RlKG9iaiwgZmFsc2UsIHRydWUsIGUpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR2YXIgZG9tLCB0MSwgdDIsIHRoO1xcblxcdFxcdFxcdGlmICgkLmlzQXJyYXkob2JqKSkge1xcblxcdFxcdFxcdFxcdG9iaiA9IG9iai5zbGljZSgpO1xcblxcdFxcdFxcdFxcdGZvciAodDEgPSAwLCB0MiA9IG9iai5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmNoZWNrX25vZGUob2JqW3QxXSwgZSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XFxuXFx0XFx0XFx0aWYgKCFvYmogfHwgb2JqLmlkID09PSAkLmpzdHJlZS5yb290KSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRkb20gPSB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSk7XFxuXFx0XFx0XFx0aWYgKCFvYmouc3RhdGUuY2hlY2tlZCkge1xcblxcdFxcdFxcdFxcdG9iai5zdGF0ZS5jaGVja2VkID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHR0aGlzLl9kYXRhLmNoZWNrYm94LnNlbGVjdGVkLnB1c2gob2JqLmlkKTtcXG5cXHRcXHRcXHRcXHRpZiAoZG9tICYmIGRvbS5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRcXHRkb20uY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuYWRkQ2xhc3MoJ2pzdHJlZS1jaGVja2VkJyk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdC8qKlxcbiAgICAgKiB0cmlnZ2VyZWQgd2hlbiBhbiBub2RlIGlzIGNoZWNrZWQgKG9ubHkgaWYgdGllX3NlbGVjdGlvbiBpbiBjaGVja2JveCBzZXR0aW5ncyBpcyBmYWxzZSlcXG4gICAgICogQGV2ZW50XFxuICAgICAqIEBuYW1lIGNoZWNrX25vZGUuanN0cmVlXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlXFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHNlbGVjdGVkIHRoZSBjdXJyZW50IHNlbGVjdGlvblxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgdGhlIGV2ZW50IChpZiBhbnkpIHRoYXQgdHJpZ2dlcmVkIHRoaXMgY2hlY2tfbm9kZVxcbiAgICAgKiBAcGx1Z2luIGNoZWNrYm94XFxuICAgICAqL1xcblxcdFxcdFxcdFxcdHRoaXMudHJpZ2dlcignY2hlY2tfbm9kZScsIHsgJ25vZGUnOiBvYmosICdzZWxlY3RlZCc6IHRoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWQsICdldmVudCc6IGUgfSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH07XFxuXFx0XFx0LyoqXFxuICAgKiB1bmNoZWNrIGEgbm9kZSAob25seSBpZiB0aWVfc2VsZWN0aW9uIGluIGNoZWNrYm94IHNldHRpbmdzIGlzIGZhbHNlLCBvdGhlcndpc2UgZGVzZWxlY3Rfbm9kZSB3aWxsIGJlIGNhbGxlZCBpbnRlcm5hbGx5KVxcbiAgICogQG5hbWUgdW5jaGVja19ub2RlKG9iailcXG4gICAqIEBwYXJhbSB7bWl4ZWR9IG9iaiBhbiBhcnJheSBjYW4gYmUgdXNlZCB0byB1bmNoZWNrIG11bHRpcGxlIG5vZGVzXFxuICAgKiBAdHJpZ2dlciB1bmNoZWNrX25vZGUuanN0cmVlXFxuICAgKiBAcGx1Z2luIGNoZWNrYm94XFxuICAgKi9cXG5cXHRcXHR0aGlzLnVuY2hlY2tfbm9kZSA9IGZ1bmN0aW9uIChvYmosIGUpIHtcXG5cXHRcXHRcXHRpZiAodGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuZGVzZWxlY3Rfbm9kZShvYmosIGZhbHNlLCBlKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0dmFyIHQxLCB0MiwgZG9tO1xcblxcdFxcdFxcdGlmICgkLmlzQXJyYXkob2JqKSkge1xcblxcdFxcdFxcdFxcdG9iaiA9IG9iai5zbGljZSgpO1xcblxcdFxcdFxcdFxcdGZvciAodDEgPSAwLCB0MiA9IG9iai5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnVuY2hlY2tfbm9kZShvYmpbdDFdLCBlKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXHRcXHRcXHRpZiAoIW9iaiB8fCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGRvbSA9IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKTtcXG5cXHRcXHRcXHRpZiAob2JqLnN0YXRlLmNoZWNrZWQpIHtcXG5cXHRcXHRcXHRcXHRvYmouc3RhdGUuY2hlY2tlZCA9IGZhbHNlO1xcblxcdFxcdFxcdFxcdHRoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWQgPSAkLnZha2F0YS5hcnJheV9yZW1vdmVfaXRlbSh0aGlzLl9kYXRhLmNoZWNrYm94LnNlbGVjdGVkLCBvYmouaWQpO1xcblxcdFxcdFxcdFxcdGlmIChkb20ubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZG9tLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLnJlbW92ZUNsYXNzKCdqc3RyZWUtY2hlY2tlZCcpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHQvKipcXG4gICAgICogdHJpZ2dlcmVkIHdoZW4gYW4gbm9kZSBpcyB1bmNoZWNrZWQgKG9ubHkgaWYgdGllX3NlbGVjdGlvbiBpbiBjaGVja2JveCBzZXR0aW5ncyBpcyBmYWxzZSlcXG4gICAgICogQGV2ZW50XFxuICAgICAqIEBuYW1lIHVuY2hlY2tfbm9kZS5qc3RyZWVcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGVcXG4gICAgICogQHBhcmFtIHtBcnJheX0gc2VsZWN0ZWQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCB0aGUgZXZlbnQgKGlmIGFueSkgdGhhdCB0cmlnZ2VyZWQgdGhpcyB1bmNoZWNrX25vZGVcXG4gICAgICogQHBsdWdpbiBjaGVja2JveFxcbiAgICAgKi9cXG5cXHRcXHRcXHRcXHR0aGlzLnRyaWdnZXIoJ3VuY2hlY2tfbm9kZScsIHsgJ25vZGUnOiBvYmosICdzZWxlY3RlZCc6IHRoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWQsICdldmVudCc6IGUgfSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH07XFxuXFx0XFx0LyoqXFxuICAgKiBjaGVja3MgYWxsIG5vZGVzIGluIHRoZSB0cmVlIChvbmx5IGlmIHRpZV9zZWxlY3Rpb24gaW4gY2hlY2tib3ggc2V0dGluZ3MgaXMgZmFsc2UsIG90aGVyd2lzZSBzZWxlY3RfYWxsIHdpbGwgYmUgY2FsbGVkIGludGVybmFsbHkpXFxuICAgKiBAbmFtZSBjaGVja19hbGwoKVxcbiAgICogQHRyaWdnZXIgY2hlY2tfYWxsLmpzdHJlZSwgY2hhbmdlZC5qc3RyZWVcXG4gICAqIEBwbHVnaW4gY2hlY2tib3hcXG4gICAqL1xcblxcdFxcdHRoaXMuY2hlY2tfYWxsID0gZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdGlmICh0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb24pIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5zZWxlY3RfYWxsKCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHZhciB0bXAgPSB0aGlzLl9kYXRhLmNoZWNrYm94LnNlbGVjdGVkLmNvbmNhdChbXSksXFxuXFx0XFx0XFx0ICAgIGksXFxuXFx0XFx0XFx0ICAgIGo7XFxuXFx0XFx0XFx0dGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZCA9IHRoaXMuX21vZGVsLmRhdGFbJC5qc3RyZWUucm9vdF0uY2hpbGRyZW5fZC5jb25jYXQoKTtcXG5cXHRcXHRcXHRmb3IgKGkgPSAwLCBqID0gdGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRpZiAodGhpcy5fbW9kZWwuZGF0YVt0aGlzLl9kYXRhLmNoZWNrYm94LnNlbGVjdGVkW2ldXSkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX21vZGVsLmRhdGFbdGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZFtpXV0uc3RhdGUuY2hlY2tlZCA9IHRydWU7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR0aGlzLnJlZHJhdyh0cnVlKTtcXG5cXHRcXHRcXHQvKipcXG4gICAgKiB0cmlnZ2VyZWQgd2hlbiBhbGwgbm9kZXMgYXJlIGNoZWNrZWQgKG9ubHkgaWYgdGllX3NlbGVjdGlvbiBpbiBjaGVja2JveCBzZXR0aW5ncyBpcyBmYWxzZSlcXG4gICAgKiBAZXZlbnRcXG4gICAgKiBAbmFtZSBjaGVja19hbGwuanN0cmVlXFxuICAgICogQHBhcmFtIHtBcnJheX0gc2VsZWN0ZWQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uXFxuICAgICogQHBsdWdpbiBjaGVja2JveFxcbiAgICAqL1xcblxcdFxcdFxcdHRoaXMudHJpZ2dlcignY2hlY2tfYWxsJywgeyAnc2VsZWN0ZWQnOiB0aGlzLl9kYXRhLmNoZWNrYm94LnNlbGVjdGVkIH0pO1xcblxcdFxcdH07XFxuXFx0XFx0LyoqXFxuICAgKiB1bmNoZWNrIGFsbCBjaGVja2VkIG5vZGVzIChvbmx5IGlmIHRpZV9zZWxlY3Rpb24gaW4gY2hlY2tib3ggc2V0dGluZ3MgaXMgZmFsc2UsIG90aGVyd2lzZSBkZXNlbGVjdF9hbGwgd2lsbCBiZSBjYWxsZWQgaW50ZXJuYWxseSlcXG4gICAqIEBuYW1lIHVuY2hlY2tfYWxsKClcXG4gICAqIEB0cmlnZ2VyIHVuY2hlY2tfYWxsLmpzdHJlZVxcbiAgICogQHBsdWdpbiBjaGVja2JveFxcbiAgICovXFxuXFx0XFx0dGhpcy51bmNoZWNrX2FsbCA9IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRpZiAodGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuZGVzZWxlY3RfYWxsKCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHZhciB0bXAgPSB0aGlzLl9kYXRhLmNoZWNrYm94LnNlbGVjdGVkLmNvbmNhdChbXSksXFxuXFx0XFx0XFx0ICAgIGksXFxuXFx0XFx0XFx0ICAgIGo7XFxuXFx0XFx0XFx0Zm9yIChpID0gMCwgaiA9IHRoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWQubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0aWYgKHRoaXMuX21vZGVsLmRhdGFbdGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZFtpXV0pIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9tb2RlbC5kYXRhW3RoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWRbaV1dLnN0YXRlLmNoZWNrZWQgPSBmYWxzZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHRoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWQgPSBbXTtcXG5cXHRcXHRcXHR0aGlzLmVsZW1lbnQuZmluZCgnLmpzdHJlZS1jaGVja2VkJykucmVtb3ZlQ2xhc3MoJ2pzdHJlZS1jaGVja2VkJyk7XFxuXFx0XFx0XFx0LyoqXFxuICAgICogdHJpZ2dlcmVkIHdoZW4gYWxsIG5vZGVzIGFyZSB1bmNoZWNrZWQgKG9ubHkgaWYgdGllX3NlbGVjdGlvbiBpbiBjaGVja2JveCBzZXR0aW5ncyBpcyBmYWxzZSlcXG4gICAgKiBAZXZlbnRcXG4gICAgKiBAbmFtZSB1bmNoZWNrX2FsbC5qc3RyZWVcXG4gICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZSB0aGUgcHJldmlvdXMgc2VsZWN0aW9uXFxuICAgICogQHBhcmFtIHtBcnJheX0gc2VsZWN0ZWQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uXFxuICAgICogQHBsdWdpbiBjaGVja2JveFxcbiAgICAqL1xcblxcdFxcdFxcdHRoaXMudHJpZ2dlcigndW5jaGVja19hbGwnLCB7ICdzZWxlY3RlZCc6IHRoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWQsICdub2RlJzogdG1wIH0pO1xcblxcdFxcdH07XFxuXFx0XFx0LyoqXFxuICAgKiBjaGVja3MgaWYgYSBub2RlIGlzIGNoZWNrZWQgKGlmIHRpZV9zZWxlY3Rpb24gaXMgb24gaW4gdGhlIHNldHRpbmdzIHRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gdGhlIHNhbWUgYXMgaXNfc2VsZWN0ZWQpXFxuICAgKiBAbmFtZSBpc19jaGVja2VkKG9iailcXG4gICAqIEBwYXJhbSAge21peGVkfSAgb2JqXFxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxcbiAgICogQHBsdWdpbiBjaGVja2JveFxcbiAgICovXFxuXFx0XFx0dGhpcy5pc19jaGVja2VkID0gZnVuY3Rpb24gKG9iaikge1xcblxcdFxcdFxcdGlmICh0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb24pIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5pc19zZWxlY3RlZChvYmopO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XFxuXFx0XFx0XFx0aWYgKCFvYmogfHwgb2JqLmlkID09PSAkLmpzdHJlZS5yb290KSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gb2JqLnN0YXRlLmNoZWNrZWQ7XFxuXFx0XFx0fTtcXG5cXHRcXHQvKipcXG4gICAqIGdldCBhbiBhcnJheSBvZiBhbGwgY2hlY2tlZCBub2RlcyAoaWYgdGllX3NlbGVjdGlvbiBpcyBvbiBpbiB0aGUgc2V0dGluZ3MgdGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgc2FtZSBhcyBnZXRfc2VsZWN0ZWQpXFxuICAgKiBAbmFtZSBnZXRfY2hlY2tlZChbZnVsbF0pXFxuICAgKiBAcGFyYW0gIHttaXhlZH0gIGZ1bGwgaWYgc2V0IHRvIGB0cnVlYCB0aGUgcmV0dXJuZWQgYXJyYXkgd2lsbCBjb25zaXN0IG9mIHRoZSBmdWxsIG5vZGUgb2JqZWN0cywgb3RoZXJ3aXNlIC0gb25seSBJRHMgd2lsbCBiZSByZXR1cm5lZFxcbiAgICogQHJldHVybiB7QXJyYXl9XFxuICAgKiBAcGx1Z2luIGNoZWNrYm94XFxuICAgKi9cXG5cXHRcXHR0aGlzLmdldF9jaGVja2VkID0gZnVuY3Rpb24gKGZ1bGwpIHtcXG5cXHRcXHRcXHRpZiAodGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuZ2V0X3NlbGVjdGVkKGZ1bGwpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gZnVsbCA/ICQubWFwKHRoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWQsICQucHJveHkoZnVuY3Rpb24gKGkpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5nZXRfbm9kZShpKTtcXG5cXHRcXHRcXHR9LCB0aGlzKSkgOiB0aGlzLl9kYXRhLmNoZWNrYm94LnNlbGVjdGVkO1xcblxcdFxcdH07XFxuXFx0XFx0LyoqXFxuICAgKiBnZXQgYW4gYXJyYXkgb2YgYWxsIHRvcCBsZXZlbCBjaGVja2VkIG5vZGVzIChpZ25vcmluZyBjaGlsZHJlbiBvZiBjaGVja2VkIG5vZGVzKSAoaWYgdGllX3NlbGVjdGlvbiBpcyBvbiBpbiB0aGUgc2V0dGluZ3MgdGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgc2FtZSBhcyBnZXRfdG9wX3NlbGVjdGVkKVxcbiAgICogQG5hbWUgZ2V0X3RvcF9jaGVja2VkKFtmdWxsXSlcXG4gICAqIEBwYXJhbSAge21peGVkfSAgZnVsbCBpZiBzZXQgdG8gYHRydWVgIHRoZSByZXR1cm5lZCBhcnJheSB3aWxsIGNvbnNpc3Qgb2YgdGhlIGZ1bGwgbm9kZSBvYmplY3RzLCBvdGhlcndpc2UgLSBvbmx5IElEcyB3aWxsIGJlIHJldHVybmVkXFxuICAgKiBAcmV0dXJuIHtBcnJheX1cXG4gICAqIEBwbHVnaW4gY2hlY2tib3hcXG4gICAqL1xcblxcdFxcdHRoaXMuZ2V0X3RvcF9jaGVja2VkID0gZnVuY3Rpb24gKGZ1bGwpIHtcXG5cXHRcXHRcXHRpZiAodGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuZ2V0X3RvcF9zZWxlY3RlZChmdWxsKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0dmFyIHRtcCA9IHRoaXMuZ2V0X2NoZWNrZWQodHJ1ZSksXFxuXFx0XFx0XFx0ICAgIG9iaiA9IHt9LFxcblxcdFxcdFxcdCAgICBpLFxcblxcdFxcdFxcdCAgICBqLFxcblxcdFxcdFxcdCAgICBrLFxcblxcdFxcdFxcdCAgICBsO1xcblxcdFxcdFxcdGZvciAoaSA9IDAsIGogPSB0bXAubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0b2JqW3RtcFtpXS5pZF0gPSB0bXBbaV07XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGZvciAoaSA9IDAsIGogPSB0bXAubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0Zm9yIChrID0gMCwgbCA9IHRtcFtpXS5jaGlsZHJlbl9kLmxlbmd0aDsgayA8IGw7IGsrKykge1xcblxcdFxcdFxcdFxcdFxcdGlmIChvYmpbdG1wW2ldLmNoaWxkcmVuX2Rba11dKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZGVsZXRlIG9ialt0bXBbaV0uY2hpbGRyZW5fZFtrXV07XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0dG1wID0gW107XFxuXFx0XFx0XFx0Zm9yIChpIGluIG9iaikge1xcblxcdFxcdFxcdFxcdGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcXG5cXHRcXHRcXHRcXHRcXHR0bXAucHVzaChpKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiBmdWxsID8gJC5tYXAodG1wLCAkLnByb3h5KGZ1bmN0aW9uIChpKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuZ2V0X25vZGUoaSk7XFxuXFx0XFx0XFx0fSwgdGhpcykpIDogdG1wO1xcblxcdFxcdH07XFxuXFx0XFx0LyoqXFxuICAgKiBnZXQgYW4gYXJyYXkgb2YgYWxsIGJvdHRvbSBsZXZlbCBjaGVja2VkIG5vZGVzIChpZ25vcmluZyBzZWxlY3RlZCBwYXJlbnRzKSAoaWYgdGllX3NlbGVjdGlvbiBpcyBvbiBpbiB0aGUgc2V0dGluZ3MgdGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgc2FtZSBhcyBnZXRfYm90dG9tX3NlbGVjdGVkKVxcbiAgICogQG5hbWUgZ2V0X2JvdHRvbV9jaGVja2VkKFtmdWxsXSlcXG4gICAqIEBwYXJhbSAge21peGVkfSAgZnVsbCBpZiBzZXQgdG8gYHRydWVgIHRoZSByZXR1cm5lZCBhcnJheSB3aWxsIGNvbnNpc3Qgb2YgdGhlIGZ1bGwgbm9kZSBvYmplY3RzLCBvdGhlcndpc2UgLSBvbmx5IElEcyB3aWxsIGJlIHJldHVybmVkXFxuICAgKiBAcmV0dXJuIHtBcnJheX1cXG4gICAqIEBwbHVnaW4gY2hlY2tib3hcXG4gICAqL1xcblxcdFxcdHRoaXMuZ2V0X2JvdHRvbV9jaGVja2VkID0gZnVuY3Rpb24gKGZ1bGwpIHtcXG5cXHRcXHRcXHRpZiAodGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuZ2V0X2JvdHRvbV9zZWxlY3RlZChmdWxsKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0dmFyIHRtcCA9IHRoaXMuZ2V0X2NoZWNrZWQodHJ1ZSksXFxuXFx0XFx0XFx0ICAgIG9iaiA9IFtdLFxcblxcdFxcdFxcdCAgICBpLFxcblxcdFxcdFxcdCAgICBqO1xcblxcdFxcdFxcdGZvciAoaSA9IDAsIGogPSB0bXAubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCF0bXBbaV0uY2hpbGRyZW4ubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0b2JqLnB1c2godG1wW2ldLmlkKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiBmdWxsID8gJC5tYXAob2JqLCAkLnByb3h5KGZ1bmN0aW9uIChpKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuZ2V0X25vZGUoaSk7XFxuXFx0XFx0XFx0fSwgdGhpcykpIDogb2JqO1xcblxcdFxcdH07XFxuXFx0XFx0dGhpcy5sb2FkX25vZGUgPSBmdW5jdGlvbiAob2JqLCBjYWxsYmFjaykge1xcblxcdFxcdFxcdHZhciBrLCBsLCBpLCBqLCBjLCB0bXA7XFxuXFx0XFx0XFx0aWYgKCEkLmlzQXJyYXkob2JqKSAmJiAhdGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uKSB7XFxuXFx0XFx0XFx0XFx0dG1wID0gdGhpcy5nZXRfbm9kZShvYmopO1xcblxcdFxcdFxcdFxcdGlmICh0bXAgJiYgdG1wLnN0YXRlLmxvYWRlZCkge1xcblxcdFxcdFxcdFxcdFxcdGZvciAoayA9IDAsIGwgPSB0bXAuY2hpbGRyZW5fZC5sZW5ndGg7IGsgPCBsOyBrKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAodGhpcy5fbW9kZWwuZGF0YVt0bXAuY2hpbGRyZW5fZFtrXV0uc3RhdGUuY2hlY2tlZCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGMgPSB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWQgPSAkLnZha2F0YS5hcnJheV9yZW1vdmVfaXRlbSh0aGlzLl9kYXRhLmNoZWNrYm94LnNlbGVjdGVkLCB0bXAuY2hpbGRyZW5fZFtrXSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiBwYXJlbnQubG9hZF9ub2RlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuXFx0XFx0fTtcXG5cXHRcXHR0aGlzLmdldF9zdGF0ZSA9IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHR2YXIgc3RhdGUgPSBwYXJlbnQuZ2V0X3N0YXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuXFx0XFx0XFx0aWYgKHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbikge1xcblxcdFxcdFxcdFxcdHJldHVybiBzdGF0ZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0c3RhdGUuY2hlY2tib3ggPSB0aGlzLl9kYXRhLmNoZWNrYm94LnNlbGVjdGVkLnNsaWNlKCk7XFxuXFx0XFx0XFx0cmV0dXJuIHN0YXRlO1xcblxcdFxcdH07XFxuXFx0XFx0dGhpcy5zZXRfc3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUsIGNhbGxiYWNrKSB7XFxuXFx0XFx0XFx0dmFyIHJlcyA9IHBhcmVudC5zZXRfc3RhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG5cXHRcXHRcXHRpZiAocmVzICYmIHN0YXRlLmNoZWNrYm94KSB7XFxuXFx0XFx0XFx0XFx0aWYgKCF0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb24pIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnVuY2hlY2tfYWxsKCk7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIF90aGlzID0gdGhpcztcXG5cXHRcXHRcXHRcXHRcXHQkLmVhY2goc3RhdGUuY2hlY2tib3gsIGZ1bmN0aW9uIChpLCB2KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0X3RoaXMuY2hlY2tfbm9kZSh2KTtcXG5cXHRcXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0ZGVsZXRlIHN0YXRlLmNoZWNrYm94O1xcblxcdFxcdFxcdFxcdHRoaXMuc2V0X3N0YXRlKHN0YXRlLCBjYWxsYmFjayk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gcmVzO1xcblxcdFxcdH07XFxuXFx0XFx0dGhpcy5yZWZyZXNoID0gZnVuY3Rpb24gKHNraXBfbG9hZGluZywgZm9yZ2V0X3N0YXRlKSB7XFxuXFx0XFx0XFx0aWYgKCF0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb24pIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9kYXRhLmNoZWNrYm94LnNlbGVjdGVkID0gW107XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiBwYXJlbnQucmVmcmVzaC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcblxcdFxcdH07XFxuXFx0fTtcXG5cXG5cXHQvLyBpbmNsdWRlIHRoZSBjaGVja2JveCBwbHVnaW4gYnkgZGVmYXVsdFxcblxcdC8vICQuanN0cmVlLmRlZmF1bHRzLnBsdWdpbnMucHVzaChcXFwiY2hlY2tib3hcXFwiKTtcXG5cXG5cXHQvKipcXG4gICogIyMjIENvbmRpdGlvbmFsc2VsZWN0IHBsdWdpblxcbiAgKlxcbiAgKiBUaGlzIHBsdWdpbiBhbGxvd3MgZGVmaW5pbmcgYSBjYWxsYmFjayB0byBhbGxvdyBvciBkZW55IG5vZGUgc2VsZWN0aW9uIGJ5IHVzZXIgaW5wdXQgKGFjdGl2YXRlIG5vZGUgbWV0aG9kKS5cXG4gICovXFxuXFxuXFx0LyoqXFxuICAqIGEgY2FsbGJhY2sgKGZ1bmN0aW9uKSB3aGljaCBpcyBpbnZva2VkIGluIHRoZSBpbnN0YW5jZSdzIHNjb3BlIGFuZCByZWNlaXZlcyB0d28gYXJndW1lbnRzIC0gdGhlIG5vZGUgYW5kIHRoZSBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGUgYGFjdGl2YXRlX25vZGVgIGNhbGwuIFJldHVybmluZyBmYWxzZSBwcmV2ZW50cyB3b3JraW5nIHdpdGggdGhlIG5vZGUsIHJldHVybmluZyB0cnVlIGFsbG93cyBpbnZva2luZyBhY3RpdmF0ZV9ub2RlLiBEZWZhdWx0cyB0byByZXR1cm5pbmcgYHRydWVgLlxcbiAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jaGVja2JveC52aXNpYmxlXFxuICAqIEBwbHVnaW4gY2hlY2tib3hcXG4gICovXFxuXFx0JC5qc3RyZWUuZGVmYXVsdHMuY29uZGl0aW9uYWxzZWxlY3QgPSBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0fTtcXG5cXHQkLmpzdHJlZS5wbHVnaW5zLmNvbmRpdGlvbmFsc2VsZWN0ID0gZnVuY3Rpb24gKG9wdGlvbnMsIHBhcmVudCkge1xcblxcdFxcdC8vIG93biBmdW5jdGlvblxcblxcdFxcdHRoaXMuYWN0aXZhdGVfbm9kZSA9IGZ1bmN0aW9uIChvYmosIGUpIHtcXG5cXHRcXHRcXHRpZiAodGhpcy5zZXR0aW5ncy5jb25kaXRpb25hbHNlbGVjdC5jYWxsKHRoaXMsIHRoaXMuZ2V0X25vZGUob2JqKSwgZSkpIHtcXG5cXHRcXHRcXHRcXHRwYXJlbnQuYWN0aXZhdGVfbm9kZS5jYWxsKHRoaXMsIG9iaiwgZSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH07XFxuXFx0fTtcXG5cXG5cXHQvKipcXG4gICogIyMjIENvbnRleHRtZW51IHBsdWdpblxcbiAgKlxcbiAgKiBTaG93cyBhIGNvbnRleHQgbWVudSB3aGVuIGEgbm9kZSBpcyByaWdodC1jbGlja2VkLlxcbiAgKi9cXG5cXG5cXHQvKipcXG4gICogc3RvcmVzIGFsbCBkZWZhdWx0cyBmb3IgdGhlIGNvbnRleHRtZW51IHBsdWdpblxcbiAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb250ZXh0bWVudVxcbiAgKiBAcGx1Z2luIGNvbnRleHRtZW51XFxuICAqL1xcblxcdCQuanN0cmVlLmRlZmF1bHRzLmNvbnRleHRtZW51ID0ge1xcblxcdFxcdC8qKlxcbiAgICogYSBib29sZWFuIGluZGljYXRpbmcgaWYgdGhlIG5vZGUgc2hvdWxkIGJlIHNlbGVjdGVkIHdoZW4gdGhlIGNvbnRleHQgbWVudSBpcyBpbnZva2VkIG9uIGl0LiBEZWZhdWx0cyB0byBgdHJ1ZWAuXFxuICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb250ZXh0bWVudS5zZWxlY3Rfbm9kZVxcbiAgICogQHBsdWdpbiBjb250ZXh0bWVudVxcbiAgICovXFxuXFx0XFx0c2VsZWN0X25vZGU6IHRydWUsXFxuXFx0XFx0LyoqXFxuICAgKiBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiB0aGUgbWVudSBzaG91bGQgYmUgc2hvd24gYWxpZ25lZCB3aXRoIHRoZSBub2RlLiBEZWZhdWx0cyB0byBgdHJ1ZWAsIG90aGVyd2lzZSB0aGUgbW91c2UgY29vcmRpbmF0ZXMgYXJlIHVzZWQuXFxuICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb250ZXh0bWVudS5zaG93X2F0X25vZGVcXG4gICAqIEBwbHVnaW4gY29udGV4dG1lbnVcXG4gICAqL1xcblxcdFxcdHNob3dfYXRfbm9kZTogdHJ1ZSxcXG5cXHRcXHQvKipcXG4gICAqIGFuIG9iamVjdCBvZiBhY3Rpb25zLCBvciBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBhIG5vZGUgYW5kIGEgY2FsbGJhY2sgZnVuY3Rpb24gYW5kIGNhbGxzIHRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aXRoIGFuIG9iamVjdCBvZiBhY3Rpb25zIGF2YWlsYWJsZSBmb3IgdGhhdCBub2RlICh5b3UgY2FuIGFsc28gcmV0dXJuIHRoZSBpdGVtcyB0b28pLlxcbiAgICpcXG4gICAqIEVhY2ggYWN0aW9uIGNvbnNpc3RzIG9mIGEga2V5IChhIHVuaXF1ZSBuYW1lKSBhbmQgYSB2YWx1ZSB3aGljaCBpcyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXMgKG9ubHkgbGFiZWwgYW5kIGFjdGlvbiBhcmUgcmVxdWlyZWQpLiBPbmNlIGEgbWVudSBpdGVtIGlzIGFjdGl2YXRlZCB0aGUgYGFjdGlvbmAgZnVuY3Rpb24gd2lsbCBiZSBpbnZva2VkIHdpdGggYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGZvbGxvd2luZyBrZXlzOiBpdGVtIC0gdGhlIGNvbnRleHRtZW51IGl0ZW0gZGVmaW5pdGlvbiBhcyBzZWVuIGJlbG93LCByZWZlcmVuY2UgLSB0aGUgRE9NIG5vZGUgdGhhdCB3YXMgdXNlZCAodGhlIHRyZWUgbm9kZSksIGVsZW1lbnQgLSB0aGUgY29udGV4dG1lbnUgRE9NIGVsZW1lbnQsIHBvc2l0aW9uIC0gYW4gb2JqZWN0IHdpdGggeC95IHByb3BlcnRpZXMgaW5kaWNhdGluZyB0aGUgcG9zaXRpb24gb2YgdGhlIG1lbnUuXFxuICAgKlxcbiAgICogKiBgc2VwYXJhdG9yX2JlZm9yZWAgLSBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiB0aGVyZSBzaG91bGQgYmUgYSBzZXBhcmF0b3IgYmVmb3JlIHRoaXMgaXRlbVxcbiAgICogKiBgc2VwYXJhdG9yX2FmdGVyYCAtIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoZXJlIHNob3VsZCBiZSBhIHNlcGFyYXRvciBhZnRlciB0aGlzIGl0ZW1cXG4gICAqICogYF9kaXNhYmxlZGAgLSBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiB0aGlzIGFjdGlvbiBzaG91bGQgYmUgZGlzYWJsZWRcXG4gICAqICogYGxhYmVsYCAtIGEgc3RyaW5nIC0gdGhlIG5hbWUgb2YgdGhlIGFjdGlvbiAoY291bGQgYmUgYSBmdW5jdGlvbiByZXR1cm5pbmcgYSBzdHJpbmcpXFxuICAgKiAqIGB0aXRsZWAgLSBhIHN0cmluZyAtIGFuIG9wdGlvbmFsIHRvb2x0aXAgZm9yIHRoZSBpdGVtXFxuICAgKiAqIGBhY3Rpb25gIC0gYSBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCBpZiB0aGlzIGl0ZW0gaXMgY2hvc2VuLCB0aGUgZnVuY3Rpb24gd2lsbCByZWNlaXZlIFxcbiAgICogKiBgaWNvbmAgLSBhIHN0cmluZywgY2FuIGJlIGEgcGF0aCB0byBhbiBpY29uIG9yIGEgY2xhc3NOYW1lLCBpZiB1c2luZyBhbiBpbWFnZSB0aGF0IGlzIGluIHRoZSBjdXJyZW50IGRpcmVjdG9yeSB1c2UgYSBgLi9gIHByZWZpeCwgb3RoZXJ3aXNlIGl0IHdpbGwgYmUgZGV0ZWN0ZWQgYXMgYSBjbGFzc1xcbiAgICogKiBgc2hvcnRjdXRgIC0ga2V5Q29kZSB3aGljaCB3aWxsIHRyaWdnZXIgdGhlIGFjdGlvbiBpZiB0aGUgbWVudSBpcyBvcGVuIChmb3IgZXhhbXBsZSBgMTEzYCBmb3IgcmVuYW1lLCB3aGljaCBlcXVhbHMgRjIpXFxuICAgKiAqIGBzaG9ydGN1dF9sYWJlbGAgLSBzaG9ydGN1dCBsYWJlbCAobGlrZSBmb3IgZXhhbXBsZSBgRjJgIGZvciByZW5hbWUpXFxuICAgKiAqIGBzdWJtZW51YCAtIGFuIG9iamVjdCB3aXRoIHRoZSBzYW1lIHN0cnVjdHVyZSBhcyAkLmpzdHJlZS5kZWZhdWx0cy5jb250ZXh0bWVudS5pdGVtcyB3aGljaCBjYW4gYmUgdXNlZCB0byBjcmVhdGUgYSBzdWJtZW51IC0gZWFjaCBrZXkgd2lsbCBiZSByZW5kZXJlZCBhcyBhIHNlcGFyYXRlIG9wdGlvbiBpbiBhIHN1Ym1lbnUgdGhhdCB3aWxsIGFwcGVhciBvbmNlIHRoZSBjdXJyZW50IGl0ZW0gaXMgaG92ZXJlZFxcbiAgICpcXG4gICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvbnRleHRtZW51Lml0ZW1zXFxuICAgKiBAcGx1Z2luIGNvbnRleHRtZW51XFxuICAgKi9cXG5cXHRcXHRpdGVtczogZnVuY3Rpb24gaXRlbXMobywgY2IpIHtcXG5cXHRcXHRcXHQvLyBDb3VsZCBiZSBhbiBvYmplY3QgZGlyZWN0bHlcXG5cXHRcXHRcXHRyZXR1cm4ge1xcblxcdFxcdFxcdFxcdFxcXCJjcmVhdGVcXFwiOiB7XFxuXFx0XFx0XFx0XFx0XFx0XFxcInNlcGFyYXRvcl9iZWZvcmVcXFwiOiBmYWxzZSxcXG5cXHRcXHRcXHRcXHRcXHRcXFwic2VwYXJhdG9yX2FmdGVyXFxcIjogdHJ1ZSxcXG5cXHRcXHRcXHRcXHRcXHRcXFwiX2Rpc2FibGVkXFxcIjogZmFsc2UsIC8vKHRoaXMuY2hlY2soXFxcImNyZWF0ZV9ub2RlXFxcIiwgZGF0YS5yZWZlcmVuY2UsIHt9LCBcXFwibGFzdFxcXCIpKSxcXG5cXHRcXHRcXHRcXHRcXHRcXFwibGFiZWxcXFwiOiBcXFwiQ3JlYXRlXFxcIixcXG5cXHRcXHRcXHRcXHRcXHRcXFwiYWN0aW9uXFxcIjogZnVuY3Rpb24gYWN0aW9uKGRhdGEpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgaW5zdCA9ICQuanN0cmVlLnJlZmVyZW5jZShkYXRhLnJlZmVyZW5jZSksXFxuXFx0XFx0XFx0XFx0XFx0XFx0ICAgIG9iaiA9IGluc3QuZ2V0X25vZGUoZGF0YS5yZWZlcmVuY2UpO1xcblxcdFxcdFxcdFxcdFxcdFxcdGluc3QuY3JlYXRlX25vZGUob2JqLCB7fSwgXFxcImxhc3RcXFwiLCBmdW5jdGlvbiAobmV3X25vZGUpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpbnN0LmVkaXQobmV3X25vZGUpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH0sIDApO1xcblxcdFxcdFxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9LFxcblxcdFxcdFxcdFxcdFxcXCJyZW5hbWVcXFwiOiB7XFxuXFx0XFx0XFx0XFx0XFx0XFxcInNlcGFyYXRvcl9iZWZvcmVcXFwiOiBmYWxzZSxcXG5cXHRcXHRcXHRcXHRcXHRcXFwic2VwYXJhdG9yX2FmdGVyXFxcIjogZmFsc2UsXFxuXFx0XFx0XFx0XFx0XFx0XFxcIl9kaXNhYmxlZFxcXCI6IGZhbHNlLCAvLyh0aGlzLmNoZWNrKFxcXCJyZW5hbWVfbm9kZVxcXCIsIGRhdGEucmVmZXJlbmNlLCB0aGlzLmdldF9wYXJlbnQoZGF0YS5yZWZlcmVuY2UpLCBcXFwiXFxcIikpLFxcblxcdFxcdFxcdFxcdFxcdFxcXCJsYWJlbFxcXCI6IFxcXCJSZW5hbWVcXFwiLFxcblxcdFxcdFxcdFxcdFxcdC8qIVxcbiAgICAgXFxcInNob3J0Y3V0XFxcIlxcdFxcdFxcdDogMTEzLFxcbiAgICAgXFxcInNob3J0Y3V0X2xhYmVsXFxcIlxcdDogJ0YyJyxcXG4gICAgIFxcXCJpY29uXFxcIlxcdFxcdFxcdFxcdDogXFxcImdseXBoaWNvbiBnbHlwaGljb24tbGVhZlxcXCIsXFxuICAgICAqL1xcblxcdFxcdFxcdFxcdFxcdFxcXCJhY3Rpb25cXFwiOiBmdW5jdGlvbiBhY3Rpb24oZGF0YSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBpbnN0ID0gJC5qc3RyZWUucmVmZXJlbmNlKGRhdGEucmVmZXJlbmNlKSxcXG5cXHRcXHRcXHRcXHRcXHRcXHQgICAgb2JqID0gaW5zdC5nZXRfbm9kZShkYXRhLnJlZmVyZW5jZSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aW5zdC5lZGl0KG9iaik7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0XFx0XFxcInJlbW92ZVxcXCI6IHtcXG5cXHRcXHRcXHRcXHRcXHRcXFwic2VwYXJhdG9yX2JlZm9yZVxcXCI6IGZhbHNlLFxcblxcdFxcdFxcdFxcdFxcdFxcXCJpY29uXFxcIjogZmFsc2UsXFxuXFx0XFx0XFx0XFx0XFx0XFxcInNlcGFyYXRvcl9hZnRlclxcXCI6IGZhbHNlLFxcblxcdFxcdFxcdFxcdFxcdFxcXCJfZGlzYWJsZWRcXFwiOiBmYWxzZSwgLy8odGhpcy5jaGVjayhcXFwiZGVsZXRlX25vZGVcXFwiLCBkYXRhLnJlZmVyZW5jZSwgdGhpcy5nZXRfcGFyZW50KGRhdGEucmVmZXJlbmNlKSwgXFxcIlxcXCIpKSxcXG5cXHRcXHRcXHRcXHRcXHRcXFwibGFiZWxcXFwiOiBcXFwiRGVsZXRlXFxcIixcXG5cXHRcXHRcXHRcXHRcXHRcXFwiYWN0aW9uXFxcIjogZnVuY3Rpb24gYWN0aW9uKGRhdGEpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgaW5zdCA9ICQuanN0cmVlLnJlZmVyZW5jZShkYXRhLnJlZmVyZW5jZSksXFxuXFx0XFx0XFx0XFx0XFx0XFx0ICAgIG9iaiA9IGluc3QuZ2V0X25vZGUoZGF0YS5yZWZlcmVuY2UpO1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChpbnN0LmlzX3NlbGVjdGVkKG9iaikpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpbnN0LmRlbGV0ZV9ub2RlKGluc3QuZ2V0X3NlbGVjdGVkKCkpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aW5zdC5kZWxldGVfbm9kZShvYmopO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRcXHRcXFwiY2NwXFxcIjoge1xcblxcdFxcdFxcdFxcdFxcdFxcXCJzZXBhcmF0b3JfYmVmb3JlXFxcIjogdHJ1ZSxcXG5cXHRcXHRcXHRcXHRcXHRcXFwiaWNvblxcXCI6IGZhbHNlLFxcblxcdFxcdFxcdFxcdFxcdFxcXCJzZXBhcmF0b3JfYWZ0ZXJcXFwiOiBmYWxzZSxcXG5cXHRcXHRcXHRcXHRcXHRcXFwibGFiZWxcXFwiOiBcXFwiRWRpdFxcXCIsXFxuXFx0XFx0XFx0XFx0XFx0XFxcImFjdGlvblxcXCI6IGZhbHNlLFxcblxcdFxcdFxcdFxcdFxcdFxcXCJzdWJtZW51XFxcIjoge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcXCJjdXRcXFwiOiB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFxcInNlcGFyYXRvcl9iZWZvcmVcXFwiOiBmYWxzZSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXFwic2VwYXJhdG9yX2FmdGVyXFxcIjogZmFsc2UsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFxcImxhYmVsXFxcIjogXFxcIkN1dFxcXCIsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFxcImFjdGlvblxcXCI6IGZ1bmN0aW9uIGFjdGlvbihkYXRhKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIGluc3QgPSAkLmpzdHJlZS5yZWZlcmVuY2UoZGF0YS5yZWZlcmVuY2UpLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdCAgICBvYmogPSBpbnN0LmdldF9ub2RlKGRhdGEucmVmZXJlbmNlKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoaW5zdC5pc19zZWxlY3RlZChvYmopKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aW5zdC5jdXQoaW5zdC5nZXRfdG9wX3NlbGVjdGVkKCkpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aW5zdC5jdXQob2JqKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFxcImNvcHlcXFwiOiB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFxcInNlcGFyYXRvcl9iZWZvcmVcXFwiOiBmYWxzZSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXFwiaWNvblxcXCI6IGZhbHNlLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcXCJzZXBhcmF0b3JfYWZ0ZXJcXFwiOiBmYWxzZSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXFwibGFiZWxcXFwiOiBcXFwiQ29weVxcXCIsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFxcImFjdGlvblxcXCI6IGZ1bmN0aW9uIGFjdGlvbihkYXRhKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIGluc3QgPSAkLmpzdHJlZS5yZWZlcmVuY2UoZGF0YS5yZWZlcmVuY2UpLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdCAgICBvYmogPSBpbnN0LmdldF9ub2RlKGRhdGEucmVmZXJlbmNlKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoaW5zdC5pc19zZWxlY3RlZChvYmopKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aW5zdC5jb3B5KGluc3QuZ2V0X3RvcF9zZWxlY3RlZCgpKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGluc3QuY29weShvYmopO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXFwicGFzdGVcXFwiOiB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFxcInNlcGFyYXRvcl9iZWZvcmVcXFwiOiBmYWxzZSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXFwiaWNvblxcXCI6IGZhbHNlLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcXCJfZGlzYWJsZWRcXFwiOiBmdW5jdGlvbiBfZGlzYWJsZWQoZGF0YSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiAhJC5qc3RyZWUucmVmZXJlbmNlKGRhdGEucmVmZXJlbmNlKS5jYW5fcGFzdGUoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9LFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcXCJzZXBhcmF0b3JfYWZ0ZXJcXFwiOiBmYWxzZSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXFwibGFiZWxcXFwiOiBcXFwiUGFzdGVcXFwiLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcXCJhY3Rpb25cXFwiOiBmdW5jdGlvbiBhY3Rpb24oZGF0YSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciBpbnN0ID0gJC5qc3RyZWUucmVmZXJlbmNlKGRhdGEucmVmZXJlbmNlKSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQgICAgb2JqID0gaW5zdC5nZXRfbm9kZShkYXRhLnJlZmVyZW5jZSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aW5zdC5wYXN0ZShvYmopO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9O1xcblxcdFxcdH1cXG5cXHR9O1xcblxcblxcdCQuanN0cmVlLnBsdWdpbnMuY29udGV4dG1lbnUgPSBmdW5jdGlvbiAob3B0aW9ucywgcGFyZW50KSB7XFxuXFx0XFx0dGhpcy5iaW5kID0gZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdHBhcmVudC5iaW5kLmNhbGwodGhpcyk7XFxuXFxuXFx0XFx0XFx0dmFyIGxhc3RfdHMgPSAwLFxcblxcdFxcdFxcdCAgICBjdG8gPSBudWxsLFxcblxcdFxcdFxcdCAgICBleCxcXG5cXHRcXHRcXHQgICAgZXk7XFxuXFx0XFx0XFx0dGhpcy5lbGVtZW50Lm9uKFxcXCJjb250ZXh0bWVudS5qc3RyZWVcXFwiLCBcXFwiLmpzdHJlZS1hbmNob3JcXFwiLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGUudGFyZ2V0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0Jykge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdFxcdFxcdFxcdGxhc3RfdHMgPSBlLmN0cmxLZXkgPyArbmV3IERhdGUoKSA6IDA7XFxuXFx0XFx0XFx0XFx0aWYgKGRhdGEgfHwgY3RvKSB7XFxuXFx0XFx0XFx0XFx0XFx0bGFzdF90cyA9ICtuZXcgRGF0ZSgpICsgMTAwMDA7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGlmIChjdG8pIHtcXG5cXHRcXHRcXHRcXHRcXHRjbGVhclRpbWVvdXQoY3RvKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aWYgKCF0aGlzLmlzX2xvYWRpbmcoZS5jdXJyZW50VGFyZ2V0KSkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuc2hvd19jb250ZXh0bWVudShlLmN1cnJlbnRUYXJnZXQsIGUucGFnZVgsIGUucGFnZVksIGUpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LCB0aGlzKSkub24oXFxcImNsaWNrLmpzdHJlZVxcXCIsIFxcXCIuanN0cmVlLWFuY2hvclxcXCIsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAodGhpcy5fZGF0YS5jb250ZXh0bWVudS52aXNpYmxlICYmICghbGFzdF90cyB8fCArbmV3IERhdGUoKSAtIGxhc3RfdHMgPiAyNTApKSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gd29yayBhcm91bmQgc2FmYXJpICYgbWFjT1MgY3RybCtjbGlja1xcblxcdFxcdFxcdFxcdFxcdCQudmFrYXRhLmNvbnRleHQuaGlkZSgpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRsYXN0X3RzID0gMDtcXG5cXHRcXHRcXHR9LCB0aGlzKSkub24oXFxcInRvdWNoc3RhcnQuanN0cmVlXFxcIiwgXFxcIi5qc3RyZWUtYW5jaG9yXFxcIiwgZnVuY3Rpb24gKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoIWUub3JpZ2luYWxFdmVudCB8fCAhZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzIHx8ICFlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0pIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGV4ID0gZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFg7XFxuXFx0XFx0XFx0XFx0ZXkgPSBlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WTtcXG5cXHRcXHRcXHRcXHRjdG8gPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHQkKGUuY3VycmVudFRhcmdldCkudHJpZ2dlcignY29udGV4dG1lbnUnLCB0cnVlKTtcXG5cXHRcXHRcXHRcXHR9LCA3NTApO1xcblxcdFxcdFxcdH0pLm9uKCd0b3VjaG1vdmUudmFrYXRhLmpzdHJlZScsIGZ1bmN0aW9uIChlKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGN0byAmJiBlLm9yaWdpbmFsRXZlbnQgJiYgZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzICYmIGUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXSAmJiAoTWF0aC5hYnMoZXggLSBlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WCkgPiA1MCB8fCBNYXRoLmFicyhleSAtIGUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRZKSA+IDUwKSkge1xcblxcdFxcdFxcdFxcdFxcdGNsZWFyVGltZW91dChjdG8pO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9KS5vbigndG91Y2hlbmQudmFrYXRhLmpzdHJlZScsIGZ1bmN0aW9uIChlKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGN0bykge1xcblxcdFxcdFxcdFxcdFxcdGNsZWFyVGltZW91dChjdG8pO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9KTtcXG5cXG5cXHRcXHRcXHQvKiFcXG4gICBpZighKCdvbmNvbnRleHRtZW51JyBpbiBkb2N1bWVudC5ib2R5KSAmJiAoJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuYm9keSkpIHtcXG4gICBcXHR2YXIgZWwgPSBudWxsLCB0bSA9IG51bGw7XFxuICAgXFx0dGhpcy5lbGVtZW50XFxuICAgXFx0XFx0Lm9uKFxcXCJ0b3VjaHN0YXJ0XFxcIiwgXFxcIi5qc3RyZWUtYW5jaG9yXFxcIiwgZnVuY3Rpb24gKGUpIHtcXG4gICBcXHRcXHRcXHRlbCA9IGUuY3VycmVudFRhcmdldDtcXG4gICBcXHRcXHRcXHR0bSA9ICtuZXcgRGF0ZSgpO1xcbiAgIFxcdFxcdFxcdCQoZG9jdW1lbnQpLm9uZShcXFwidG91Y2hlbmRcXFwiLCBmdW5jdGlvbiAoZSkge1xcbiAgIFxcdFxcdFxcdFxcdGUudGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChlLm9yaWdpbmFsRXZlbnQudGFyZ2V0VG91Y2hlc1swXS5wYWdlWCAtIHdpbmRvdy5wYWdlWE9mZnNldCwgZS5vcmlnaW5hbEV2ZW50LnRhcmdldFRvdWNoZXNbMF0ucGFnZVkgLSB3aW5kb3cucGFnZVlPZmZzZXQpO1xcbiAgIFxcdFxcdFxcdFxcdGUuY3VycmVudFRhcmdldCA9IGUudGFyZ2V0O1xcbiAgIFxcdFxcdFxcdFxcdHRtID0gKCgrKG5ldyBEYXRlKCkpKSAtIHRtKTtcXG4gICBcXHRcXHRcXHRcXHRpZihlLnRhcmdldCA9PT0gZWwgJiYgdG0gPiA2MDAgJiYgdG0gPCAxMDAwKSB7XFxuICAgXFx0XFx0XFx0XFx0XFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgIFxcdFxcdFxcdFxcdFxcdCQoZWwpLnRyaWdnZXIoJ2NvbnRleHRtZW51JywgZSk7XFxuICAgXFx0XFx0XFx0XFx0fVxcbiAgIFxcdFxcdFxcdFxcdGVsID0gbnVsbDtcXG4gICBcXHRcXHRcXHRcXHR0bSA9IG51bGw7XFxuICAgXFx0XFx0XFx0fSk7XFxuICAgXFx0XFx0fSk7XFxuICAgfVxcbiAgICovXFxuXFx0XFx0XFx0JChkb2N1bWVudCkub24oXFxcImNvbnRleHRfaGlkZS52YWthdGEuanN0cmVlXFxcIiwgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xcblxcdFxcdFxcdFxcdHRoaXMuX2RhdGEuY29udGV4dG1lbnUudmlzaWJsZSA9IGZhbHNlO1xcblxcdFxcdFxcdFxcdCQoZGF0YS5yZWZlcmVuY2UpLnJlbW92ZUNsYXNzKCdqc3RyZWUtY29udGV4dCcpO1xcblxcdFxcdFxcdH0sIHRoaXMpKTtcXG5cXHRcXHR9O1xcblxcdFxcdHRoaXMudGVhcmRvd24gPSBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0aWYgKHRoaXMuX2RhdGEuY29udGV4dG1lbnUudmlzaWJsZSkge1xcblxcdFxcdFxcdFxcdCQudmFrYXRhLmNvbnRleHQuaGlkZSgpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRwYXJlbnQudGVhcmRvd24uY2FsbCh0aGlzKTtcXG5cXHRcXHR9O1xcblxcblxcdFxcdC8qKlxcbiAgICogcHJlcGFyZSBhbmQgc2hvdyB0aGUgY29udGV4dCBtZW51IGZvciBhIG5vZGVcXG4gICAqIEBuYW1lIHNob3dfY29udGV4dG1lbnUob2JqIFssIHgsIHldKVxcbiAgICogQHBhcmFtIHttaXhlZH0gb2JqIHRoZSBub2RlXFxuICAgKiBAcGFyYW0ge051bWJlcn0geCB0aGUgeC1jb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBkb2N1bWVudCB0byBzaG93IHRoZSBtZW51IGF0XFxuICAgKiBAcGFyYW0ge051bWJlcn0geSB0aGUgeS1jb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBkb2N1bWVudCB0byBzaG93IHRoZSBtZW51IGF0XFxuICAgKiBAcGFyYW0ge09iamVjdH0gZSB0aGUgZXZlbnQgaWYgYXZhaWxhYmxlIHRoYXQgdHJpZ2dlcmVkIHRoZSBjb250ZXh0bWVudVxcbiAgICogQHBsdWdpbiBjb250ZXh0bWVudVxcbiAgICogQHRyaWdnZXIgc2hvd19jb250ZXh0bWVudS5qc3RyZWVcXG4gICAqL1xcblxcdFxcdHRoaXMuc2hvd19jb250ZXh0bWVudSA9IGZ1bmN0aW9uIChvYmosIHgsIHksIGUpIHtcXG5cXHRcXHRcXHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XFxuXFx0XFx0XFx0aWYgKCFvYmogfHwgb2JqLmlkID09PSAkLmpzdHJlZS5yb290KSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR2YXIgcyA9IHRoaXMuc2V0dGluZ3MuY29udGV4dG1lbnUsXFxuXFx0XFx0XFx0ICAgIGQgPSB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSksXFxuXFx0XFx0XFx0ICAgIGEgPSBkLmNoaWxkcmVuKFxcXCIuanN0cmVlLWFuY2hvclxcXCIpLFxcblxcdFxcdFxcdCAgICBvID0gZmFsc2UsXFxuXFx0XFx0XFx0ICAgIGkgPSBmYWxzZTtcXG5cXHRcXHRcXHRpZiAocy5zaG93X2F0X25vZGUgfHwgeCA9PT0gdW5kZWZpbmVkIHx8IHkgPT09IHVuZGVmaW5lZCkge1xcblxcdFxcdFxcdFxcdG8gPSBhLm9mZnNldCgpO1xcblxcdFxcdFxcdFxcdHggPSBvLmxlZnQ7XFxuXFx0XFx0XFx0XFx0eSA9IG8udG9wICsgdGhpcy5fZGF0YS5jb3JlLmxpX2hlaWdodDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKHRoaXMuc2V0dGluZ3MuY29udGV4dG1lbnUuc2VsZWN0X25vZGUgJiYgIXRoaXMuaXNfc2VsZWN0ZWQob2JqKSkge1xcblxcdFxcdFxcdFxcdHRoaXMuYWN0aXZhdGVfbm9kZShvYmosIGUpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpID0gcy5pdGVtcztcXG5cXHRcXHRcXHRpZiAoJC5pc0Z1bmN0aW9uKGkpKSB7XFxuXFx0XFx0XFx0XFx0aSA9IGkuY2FsbCh0aGlzLCBvYmosICQucHJveHkoZnVuY3Rpb24gKGkpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9zaG93X2NvbnRleHRtZW51KG9iaiwgeCwgeSwgaSk7XFxuXFx0XFx0XFx0XFx0fSwgdGhpcykpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoJC5pc1BsYWluT2JqZWN0KGkpKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5fc2hvd19jb250ZXh0bWVudShvYmosIHgsIHksIGkpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9O1xcblxcdFxcdC8qKlxcbiAgICogc2hvdyB0aGUgcHJlcGFyZWQgY29udGV4dCBtZW51IGZvciBhIG5vZGVcXG4gICAqIEBuYW1lIF9zaG93X2NvbnRleHRtZW51KG9iaiwgeCwgeSwgaSlcXG4gICAqIEBwYXJhbSB7bWl4ZWR9IG9iaiB0aGUgbm9kZVxcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHggdGhlIHgtY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgZG9jdW1lbnQgdG8gc2hvdyB0aGUgbWVudSBhdFxcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHkgdGhlIHktY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgZG9jdW1lbnQgdG8gc2hvdyB0aGUgbWVudSBhdFxcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGkgdGhlIG9iamVjdCBvZiBpdGVtcyB0byBzaG93XFxuICAgKiBAcGx1Z2luIGNvbnRleHRtZW51XFxuICAgKiBAdHJpZ2dlciBzaG93X2NvbnRleHRtZW51LmpzdHJlZVxcbiAgICogQHByaXZhdGVcXG4gICAqL1xcblxcdFxcdHRoaXMuX3Nob3dfY29udGV4dG1lbnUgPSBmdW5jdGlvbiAob2JqLCB4LCB5LCBpKSB7XFxuXFx0XFx0XFx0dmFyIGQgPSB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSksXFxuXFx0XFx0XFx0ICAgIGEgPSBkLmNoaWxkcmVuKFxcXCIuanN0cmVlLWFuY2hvclxcXCIpO1xcblxcdFxcdFxcdCQoZG9jdW1lbnQpLm9uZShcXFwiY29udGV4dF9zaG93LnZha2F0YS5qc3RyZWVcXFwiLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XFxuXFx0XFx0XFx0XFx0dmFyIGNscyA9ICdqc3RyZWUtY29udGV4dG1lbnUganN0cmVlLScgKyB0aGlzLmdldF90aGVtZSgpICsgJy1jb250ZXh0bWVudSc7XFxuXFx0XFx0XFx0XFx0JChkYXRhLmVsZW1lbnQpLmFkZENsYXNzKGNscyk7XFxuXFx0XFx0XFx0XFx0YS5hZGRDbGFzcygnanN0cmVlLWNvbnRleHQnKTtcXG5cXHRcXHRcXHR9LCB0aGlzKSk7XFxuXFx0XFx0XFx0dGhpcy5fZGF0YS5jb250ZXh0bWVudS52aXNpYmxlID0gdHJ1ZTtcXG5cXHRcXHRcXHQkLnZha2F0YS5jb250ZXh0LnNob3coYSwgeyAneCc6IHgsICd5JzogeSB9LCBpKTtcXG5cXHRcXHRcXHQvKipcXG4gICAgKiB0cmlnZ2VyZWQgd2hlbiB0aGUgY29udGV4dG1lbnUgaXMgc2hvd24gZm9yIGEgbm9kZVxcbiAgICAqIEBldmVudFxcbiAgICAqIEBuYW1lIHNob3dfY29udGV4dG1lbnUuanN0cmVlXFxuICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGUgdGhlIG5vZGVcXG4gICAgKiBAcGFyYW0ge051bWJlcn0geCB0aGUgeC1jb29yZGluYXRlIG9mIHRoZSBtZW51IHJlbGF0aXZlIHRvIHRoZSBkb2N1bWVudFxcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IHRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIG1lbnUgcmVsYXRpdmUgdG8gdGhlIGRvY3VtZW50XFxuICAgICogQHBsdWdpbiBjb250ZXh0bWVudVxcbiAgICAqL1xcblxcdFxcdFxcdHRoaXMudHJpZ2dlcignc2hvd19jb250ZXh0bWVudScsIHsgXFxcIm5vZGVcXFwiOiBvYmosIFxcXCJ4XFxcIjogeCwgXFxcInlcXFwiOiB5IH0pO1xcblxcdFxcdH07XFxuXFx0fTtcXG5cXG5cXHQvLyBjb250ZXh0bWVudSBoZWxwZXJcXG5cXHQoZnVuY3Rpb24gKCQpIHtcXG5cXHRcXHR2YXIgcmlnaHRfdG9fbGVmdCA9IGZhbHNlLFxcblxcdFxcdCAgICB2YWthdGFfY29udGV4dCA9IHtcXG5cXHRcXHRcXHRlbGVtZW50OiBmYWxzZSxcXG5cXHRcXHRcXHRyZWZlcmVuY2U6IGZhbHNlLFxcblxcdFxcdFxcdHBvc2l0aW9uX3g6IDAsXFxuXFx0XFx0XFx0cG9zaXRpb25feTogMCxcXG5cXHRcXHRcXHRpdGVtczogW10sXFxuXFx0XFx0XFx0aHRtbDogXFxcIlxcXCIsXFxuXFx0XFx0XFx0aXNfdmlzaWJsZTogZmFsc2VcXG5cXHRcXHR9O1xcblxcblxcdFxcdCQudmFrYXRhLmNvbnRleHQgPSB7XFxuXFx0XFx0XFx0c2V0dGluZ3M6IHtcXG5cXHRcXHRcXHRcXHRoaWRlX29ubW91c2VsZWF2ZTogMCxcXG5cXHRcXHRcXHRcXHRpY29uczogdHJ1ZVxcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0X3RyaWdnZXI6IGZ1bmN0aW9uIF90cmlnZ2VyKGV2ZW50X25hbWUpIHtcXG5cXHRcXHRcXHRcXHQkKGRvY3VtZW50KS50cmlnZ2VySGFuZGxlcihcXFwiY29udGV4dF9cXFwiICsgZXZlbnRfbmFtZSArIFxcXCIudmFrYXRhXFxcIiwge1xcblxcdFxcdFxcdFxcdFxcdFxcXCJyZWZlcmVuY2VcXFwiOiB2YWthdGFfY29udGV4dC5yZWZlcmVuY2UsXFxuXFx0XFx0XFx0XFx0XFx0XFxcImVsZW1lbnRcXFwiOiB2YWthdGFfY29udGV4dC5lbGVtZW50LFxcblxcdFxcdFxcdFxcdFxcdFxcXCJwb3NpdGlvblxcXCI6IHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXFwieFxcXCI6IHZha2F0YV9jb250ZXh0LnBvc2l0aW9uX3gsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFxcInlcXFwiOiB2YWthdGFfY29udGV4dC5wb3NpdGlvbl95XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0X2V4ZWN1dGU6IGZ1bmN0aW9uIF9leGVjdXRlKGkpIHtcXG5cXHRcXHRcXHRcXHRpID0gdmFrYXRhX2NvbnRleHQuaXRlbXNbaV07XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGkgJiYgKCFpLl9kaXNhYmxlZCB8fCAkLmlzRnVuY3Rpb24oaS5fZGlzYWJsZWQpICYmICFpLl9kaXNhYmxlZCh7IFxcXCJpdGVtXFxcIjogaSwgXFxcInJlZmVyZW5jZVxcXCI6IHZha2F0YV9jb250ZXh0LnJlZmVyZW5jZSwgXFxcImVsZW1lbnRcXFwiOiB2YWthdGFfY29udGV4dC5lbGVtZW50IH0pKSAmJiBpLmFjdGlvbiA/IGkuYWN0aW9uLmNhbGwobnVsbCwge1xcblxcdFxcdFxcdFxcdFxcdFxcXCJpdGVtXFxcIjogaSxcXG5cXHRcXHRcXHRcXHRcXHRcXFwicmVmZXJlbmNlXFxcIjogdmFrYXRhX2NvbnRleHQucmVmZXJlbmNlLFxcblxcdFxcdFxcdFxcdFxcdFxcXCJlbGVtZW50XFxcIjogdmFrYXRhX2NvbnRleHQuZWxlbWVudCxcXG5cXHRcXHRcXHRcXHRcXHRcXFwicG9zaXRpb25cXFwiOiB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFxcInhcXFwiOiB2YWthdGFfY29udGV4dC5wb3NpdGlvbl94LFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcXCJ5XFxcIjogdmFrYXRhX2NvbnRleHQucG9zaXRpb25feVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9KSA6IGZhbHNlO1xcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0X3BhcnNlOiBmdW5jdGlvbiBfcGFyc2UobywgaXNfY2FsbGJhY2spIHtcXG5cXHRcXHRcXHRcXHRpZiAoIW8pIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGlmICghaXNfY2FsbGJhY2spIHtcXG5cXHRcXHRcXHRcXHRcXHR2YWthdGFfY29udGV4dC5odG1sID0gXFxcIlxcXCI7XFxuXFx0XFx0XFx0XFx0XFx0dmFrYXRhX2NvbnRleHQuaXRlbXMgPSBbXTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0dmFyIHN0ciA9IFxcXCJcXFwiLFxcblxcdFxcdFxcdFxcdCAgICBzZXAgPSBmYWxzZSxcXG5cXHRcXHRcXHRcXHQgICAgdG1wO1xcblxcblxcdFxcdFxcdFxcdGlmIChpc19jYWxsYmFjaykge1xcblxcdFxcdFxcdFxcdFxcdHN0ciArPSBcXFwiPFxcXCIgKyBcXFwidWw+XFxcIjtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0JC5lYWNoKG8sIGZ1bmN0aW9uIChpLCB2YWwpIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIXZhbCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR2YWthdGFfY29udGV4dC5pdGVtcy5wdXNoKHZhbCk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCFzZXAgJiYgdmFsLnNlcGFyYXRvcl9iZWZvcmUpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzdHIgKz0gXFxcIjxcXFwiICsgXFxcImxpIGNsYXNzPSd2YWthdGEtY29udGV4dC1zZXBhcmF0b3InPjxcXFwiICsgXFxcImEgaHJlZj0nIycgXFxcIiArICgkLnZha2F0YS5jb250ZXh0LnNldHRpbmdzLmljb25zID8gJycgOiAnc3R5bGU9XFxcIm1hcmdpbi1sZWZ0OjBweDtcXFwiJykgKyBcXFwiPiYjMTYwOzxcXFwiICsgXFxcIi9hPjxcXFwiICsgXFxcIi9saT5cXFwiO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRzZXAgPSBmYWxzZTtcXG5cXHRcXHRcXHRcXHRcXHRzdHIgKz0gXFxcIjxcXFwiICsgXFxcImxpIGNsYXNzPSdcXFwiICsgKHZhbC5fY2xhc3MgfHwgXFxcIlxcXCIpICsgKHZhbC5fZGlzYWJsZWQgPT09IHRydWUgfHwgJC5pc0Z1bmN0aW9uKHZhbC5fZGlzYWJsZWQpICYmIHZhbC5fZGlzYWJsZWQoeyBcXFwiaXRlbVxcXCI6IHZhbCwgXFxcInJlZmVyZW5jZVxcXCI6IHZha2F0YV9jb250ZXh0LnJlZmVyZW5jZSwgXFxcImVsZW1lbnRcXFwiOiB2YWthdGFfY29udGV4dC5lbGVtZW50IH0pID8gXFxcIiB2YWthdGEtY29udGV4dG1lbnUtZGlzYWJsZWQgXFxcIiA6IFxcXCJcXFwiKSArIFxcXCInIFxcXCIgKyAodmFsLnNob3J0Y3V0ID8gXFxcIiBkYXRhLXNob3J0Y3V0PSdcXFwiICsgdmFsLnNob3J0Y3V0ICsgXFxcIicgXFxcIiA6ICcnKSArIFxcXCI+XFxcIjtcXG5cXHRcXHRcXHRcXHRcXHRzdHIgKz0gXFxcIjxcXFwiICsgXFxcImEgaHJlZj0nIycgcmVsPSdcXFwiICsgKHZha2F0YV9jb250ZXh0Lml0ZW1zLmxlbmd0aCAtIDEpICsgXFxcIicgXFxcIiArICh2YWwudGl0bGUgPyBcXFwidGl0bGU9J1xcXCIgKyB2YWwudGl0bGUgKyBcXFwiJ1xcXCIgOiBcXFwiXFxcIikgKyBcXFwiPlxcXCI7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCQudmFrYXRhLmNvbnRleHQuc2V0dGluZ3MuaWNvbnMpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzdHIgKz0gXFxcIjxcXFwiICsgXFxcImkgXFxcIjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAodmFsLmljb24pIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAodmFsLmljb24uaW5kZXhPZihcXFwiL1xcXCIpICE9PSAtMSB8fCB2YWwuaWNvbi5pbmRleE9mKFxcXCIuXFxcIikgIT09IC0xKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0c3RyICs9IFxcXCIgc3R5bGU9J2JhY2tncm91bmQ6dXJsKFxcXFxcXFwiXFxcIiArIHZhbC5pY29uICsgXFxcIlxcXFxcXFwiKSBjZW50ZXIgY2VudGVyIG5vLXJlcGVhdCcgXFxcIjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHN0ciArPSBcXFwiIGNsYXNzPSdcXFwiICsgdmFsLmljb24gKyBcXFwiJyBcXFwiO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0c3RyICs9IFxcXCI+PFxcXCIgKyBcXFwiL2k+PFxcXCIgKyBcXFwic3BhbiBjbGFzcz0ndmFrYXRhLWNvbnRleHRtZW51LXNlcCc+JiMxNjA7PFxcXCIgKyBcXFwiL3NwYW4+XFxcIjtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0c3RyICs9ICgkLmlzRnVuY3Rpb24odmFsLmxhYmVsKSA/IHZhbC5sYWJlbCh7IFxcXCJpdGVtXFxcIjogaSwgXFxcInJlZmVyZW5jZVxcXCI6IHZha2F0YV9jb250ZXh0LnJlZmVyZW5jZSwgXFxcImVsZW1lbnRcXFwiOiB2YWthdGFfY29udGV4dC5lbGVtZW50IH0pIDogdmFsLmxhYmVsKSArICh2YWwuc2hvcnRjdXQgPyAnIDxzcGFuIGNsYXNzPVxcXCJ2YWthdGEtY29udGV4dG1lbnUtc2hvcnRjdXQgdmFrYXRhLWNvbnRleHRtZW51LXNob3J0Y3V0LScgKyB2YWwuc2hvcnRjdXQgKyAnXFxcIj4nICsgKHZhbC5zaG9ydGN1dF9sYWJlbCB8fCAnJykgKyAnPC9zcGFuPicgOiAnJykgKyBcXFwiPFxcXCIgKyBcXFwiL2E+XFxcIjtcXG5cXHRcXHRcXHRcXHRcXHRpZiAodmFsLnN1Ym1lbnUpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0bXAgPSAkLnZha2F0YS5jb250ZXh0Ll9wYXJzZSh2YWwuc3VibWVudSwgdHJ1ZSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKHRtcCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHN0ciArPSB0bXA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRzdHIgKz0gXFxcIjxcXFwiICsgXFxcIi9saT5cXFwiO1xcblxcdFxcdFxcdFxcdFxcdGlmICh2YWwuc2VwYXJhdG9yX2FmdGVyKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0c3RyICs9IFxcXCI8XFxcIiArIFxcXCJsaSBjbGFzcz0ndmFrYXRhLWNvbnRleHQtc2VwYXJhdG9yJz48XFxcIiArIFxcXCJhIGhyZWY9JyMnIFxcXCIgKyAoJC52YWthdGEuY29udGV4dC5zZXR0aW5ncy5pY29ucyA/ICcnIDogJ3N0eWxlPVxcXCJtYXJnaW4tbGVmdDowcHg7XFxcIicpICsgXFxcIj4mIzE2MDs8XFxcIiArIFxcXCIvYT48XFxcIiArIFxcXCIvbGk+XFxcIjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzZXAgPSB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcXHRzdHIgPSBzdHIucmVwbGFjZSgvPGxpIGNsYXNzXFxcXD0ndmFrYXRhLWNvbnRleHQtc2VwYXJhdG9yJ1xcXFw+PFxcXFwvbGlcXFxcPiQvLCBcXFwiXFxcIik7XFxuXFx0XFx0XFx0XFx0aWYgKGlzX2NhbGxiYWNrKSB7XFxuXFx0XFx0XFx0XFx0XFx0c3RyICs9IFxcXCI8L3VsPlxcXCI7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdC8qKlxcbiAgICAgKiB0cmlnZ2VyZWQgb24gdGhlIGRvY3VtZW50IHdoZW4gdGhlIGNvbnRleHRtZW51IGlzIHBhcnNlZCAoSFRNTCBpcyBidWlsdClcXG4gICAgICogQGV2ZW50XFxuICAgICAqIEBwbHVnaW4gY29udGV4dG1lbnVcXG4gICAgICogQG5hbWUgY29udGV4dF9wYXJzZS52YWthdGFcXG4gICAgICogQHBhcmFtIHtqUXVlcnl9IHJlZmVyZW5jZSB0aGUgZWxlbWVudCB0aGF0IHdhcyByaWdodCBjbGlja2VkXFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IHRoZSBET00gZWxlbWVudCBvZiB0aGUgbWVudSBpdHNlbGZcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvc2l0aW9uIHRoZSB4ICYgeSBjb29yZGluYXRlcyBvZiB0aGUgbWVudVxcbiAgICAgKi9cXG5cXHRcXHRcXHRcXHRpZiAoIWlzX2NhbGxiYWNrKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFrYXRhX2NvbnRleHQuaHRtbCA9IHN0cjskLnZha2F0YS5jb250ZXh0Ll90cmlnZ2VyKFxcXCJwYXJzZVxcXCIpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRyZXR1cm4gc3RyLmxlbmd0aCA+IDEwID8gc3RyIDogZmFsc2U7XFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRfc2hvd19zdWJtZW51OiBmdW5jdGlvbiBfc2hvd19zdWJtZW51KG8pIHtcXG5cXHRcXHRcXHRcXHRvID0gJChvKTtcXG5cXHRcXHRcXHRcXHRpZiAoIW8ubGVuZ3RoIHx8ICFvLmNoaWxkcmVuKFxcXCJ1bFxcXCIpLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0dmFyIGUgPSBvLmNoaWxkcmVuKFxcXCJ1bFxcXCIpLFxcblxcdFxcdFxcdFxcdCAgICB4bCA9IG8ub2Zmc2V0KCkubGVmdCxcXG5cXHRcXHRcXHRcXHQgICAgeCA9IHhsICsgby5vdXRlcldpZHRoKCksXFxuXFx0XFx0XFx0XFx0ICAgIHkgPSBvLm9mZnNldCgpLnRvcCxcXG5cXHRcXHRcXHRcXHQgICAgdyA9IGUud2lkdGgoKSxcXG5cXHRcXHRcXHRcXHQgICAgaCA9IGUuaGVpZ2h0KCksXFxuXFx0XFx0XFx0XFx0ICAgIGR3ID0gJCh3aW5kb3cpLndpZHRoKCkgKyAkKHdpbmRvdykuc2Nyb2xsTGVmdCgpLFxcblxcdFxcdFxcdFxcdCAgICBkaCA9ICQod2luZG93KS5oZWlnaHQoKSArICQod2luZG93KS5zY3JvbGxUb3AoKTtcXG5cXHRcXHRcXHRcXHQvLyDQvNC+0LbQtSDQtNCwINGB0LUg0YHQv9C10YHRgtC4INC1INC10LTQvdCwINC/0YDQvtCy0LXRgNC60LAgLSDQtNCw0LvQuCDQvdGP0LzQsCDQvdGP0LrQvtC5INC+0YIg0LrQu9Cw0YHQvtCy0LXRgtC1INCy0LXRh9C1INC90LDQs9C+0YDQtVxcblxcdFxcdFxcdFxcdGlmIChyaWdodF90b19sZWZ0KSB7XFxuXFx0XFx0XFx0XFx0XFx0b1t4IC0gKHcgKyAxMCArIG8ub3V0ZXJXaWR0aCgpKSA8IDAgPyBcXFwiYWRkQ2xhc3NcXFwiIDogXFxcInJlbW92ZUNsYXNzXFxcIl0oXFxcInZha2F0YS1jb250ZXh0LWxlZnRcXFwiKTtcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdG9beCArIHcgPiBkdyAmJiB4bCA+IGR3IC0geCA/IFxcXCJhZGRDbGFzc1xcXCIgOiBcXFwicmVtb3ZlQ2xhc3NcXFwiXShcXFwidmFrYXRhLWNvbnRleHQtcmlnaHRcXFwiKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aWYgKHkgKyBoICsgMTAgPiBkaCkge1xcblxcdFxcdFxcdFxcdFxcdGUuY3NzKFxcXCJib3R0b21cXFwiLCBcXFwiLTFweFxcXCIpO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvL2lmIGRvZXMgbm90IGZpdCAtIHN0aWNrIGl0IHRvIHRoZSBzaWRlXFxuXFx0XFx0XFx0XFx0aWYgKG8uaGFzQ2xhc3MoJ3Zha2F0YS1jb250ZXh0LXJpZ2h0JykpIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoeGwgPCB3KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZS5jc3MoXFxcIm1hcmdpbi1yaWdodFxcXCIsIHhsIC0gdyk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGR3IC0geCA8IHcpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRlLmNzcyhcXFwibWFyZ2luLWxlZnRcXFwiLCBkdyAtIHggLSB3KTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGUuc2hvdygpO1xcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0c2hvdzogZnVuY3Rpb24gc2hvdyhyZWZlcmVuY2UsIHBvc2l0aW9uLCBkYXRhKSB7XFxuXFx0XFx0XFx0XFx0dmFyIG8sXFxuXFx0XFx0XFx0XFx0ICAgIGUsXFxuXFx0XFx0XFx0XFx0ICAgIHgsXFxuXFx0XFx0XFx0XFx0ICAgIHksXFxuXFx0XFx0XFx0XFx0ICAgIHcsXFxuXFx0XFx0XFx0XFx0ICAgIGgsXFxuXFx0XFx0XFx0XFx0ICAgIGR3LFxcblxcdFxcdFxcdFxcdCAgICBkaCxcXG5cXHRcXHRcXHRcXHQgICAgY29uZCA9IHRydWU7XFxuXFx0XFx0XFx0XFx0aWYgKHZha2F0YV9jb250ZXh0LmVsZW1lbnQgJiYgdmFrYXRhX2NvbnRleHQuZWxlbWVudC5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRcXHR2YWthdGFfY29udGV4dC5lbGVtZW50LndpZHRoKCcnKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0c3dpdGNoIChjb25kKSB7XFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAhcG9zaXRpb24gJiYgIXJlZmVyZW5jZTpcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAhIXBvc2l0aW9uICYmICEhcmVmZXJlbmNlOlxcblxcdFxcdFxcdFxcdFxcdFxcdHZha2F0YV9jb250ZXh0LnJlZmVyZW5jZSA9IHJlZmVyZW5jZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YWthdGFfY29udGV4dC5wb3NpdGlvbl94ID0gcG9zaXRpb24ueDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YWthdGFfY29udGV4dC5wb3NpdGlvbl95ID0gcG9zaXRpb24ueTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRjYXNlICFwb3NpdGlvbiAmJiAhIXJlZmVyZW5jZTpcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YWthdGFfY29udGV4dC5yZWZlcmVuY2UgPSByZWZlcmVuY2U7XFxuXFx0XFx0XFx0XFx0XFx0XFx0byA9IHJlZmVyZW5jZS5vZmZzZXQoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YWthdGFfY29udGV4dC5wb3NpdGlvbl94ID0gby5sZWZ0ICsgcmVmZXJlbmNlLm91dGVySGVpZ2h0KCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFrYXRhX2NvbnRleHQucG9zaXRpb25feSA9IG8udG9wO1xcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdGNhc2UgISFwb3NpdGlvbiAmJiAhcmVmZXJlbmNlOlxcblxcdFxcdFxcdFxcdFxcdFxcdHZha2F0YV9jb250ZXh0LnBvc2l0aW9uX3ggPSBwb3NpdGlvbi54O1xcblxcdFxcdFxcdFxcdFxcdFxcdHZha2F0YV9jb250ZXh0LnBvc2l0aW9uX3kgPSBwb3NpdGlvbi55O1xcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRpZiAoISFyZWZlcmVuY2UgJiYgIWRhdGEgJiYgJChyZWZlcmVuY2UpLmRhdGEoJ3Zha2F0YV9jb250ZXh0bWVudScpKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZGF0YSA9ICQocmVmZXJlbmNlKS5kYXRhKCd2YWthdGFfY29udGV4dG1lbnUnKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aWYgKCQudmFrYXRhLmNvbnRleHQuX3BhcnNlKGRhdGEpKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFrYXRhX2NvbnRleHQuZWxlbWVudC5odG1sKHZha2F0YV9jb250ZXh0Lmh0bWwpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRpZiAodmFrYXRhX2NvbnRleHQuaXRlbXMubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFrYXRhX2NvbnRleHQuZWxlbWVudC5hcHBlbmRUbyhcXFwiYm9keVxcXCIpO1xcblxcdFxcdFxcdFxcdFxcdGUgPSB2YWthdGFfY29udGV4dC5lbGVtZW50O1xcblxcdFxcdFxcdFxcdFxcdHggPSB2YWthdGFfY29udGV4dC5wb3NpdGlvbl94O1xcblxcdFxcdFxcdFxcdFxcdHkgPSB2YWthdGFfY29udGV4dC5wb3NpdGlvbl95O1xcblxcdFxcdFxcdFxcdFxcdHcgPSBlLndpZHRoKCk7XFxuXFx0XFx0XFx0XFx0XFx0aCA9IGUuaGVpZ2h0KCk7XFxuXFx0XFx0XFx0XFx0XFx0ZHcgPSAkKHdpbmRvdykud2lkdGgoKSArICQod2luZG93KS5zY3JvbGxMZWZ0KCk7XFxuXFx0XFx0XFx0XFx0XFx0ZGggPSAkKHdpbmRvdykuaGVpZ2h0KCkgKyAkKHdpbmRvdykuc2Nyb2xsVG9wKCk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHJpZ2h0X3RvX2xlZnQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR4IC09IGUub3V0ZXJXaWR0aCgpIC0gJChyZWZlcmVuY2UpLm91dGVyV2lkdGgoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoeCA8ICQod2luZG93KS5zY3JvbGxMZWZ0KCkgKyAyMCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHggPSAkKHdpbmRvdykuc2Nyb2xsTGVmdCgpICsgMjA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRpZiAoeCArIHcgKyAyMCA+IGR3KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0eCA9IGR3IC0gKHcgKyAyMCk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmICh5ICsgaCArIDIwID4gZGgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR5ID0gZGggLSAoaCArIDIwKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFrYXRhX2NvbnRleHQuZWxlbWVudC5jc3MoeyBcXFwibGVmdFxcXCI6IHgsIFxcXCJ0b3BcXFwiOiB5IH0pLnNob3coKS5maW5kKCdhJykuZmlyc3QoKS5mb2N1cygpLnBhcmVudCgpLmFkZENsYXNzKFxcXCJ2YWthdGEtY29udGV4dC1ob3ZlclxcXCIpO1xcblxcdFxcdFxcdFxcdFxcdHZha2F0YV9jb250ZXh0LmlzX3Zpc2libGUgPSB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdC8qKlxcbiAgICAgICogdHJpZ2dlcmVkIG9uIHRoZSBkb2N1bWVudCB3aGVuIHRoZSBjb250ZXh0bWVudSBpcyBzaG93blxcbiAgICAgICogQGV2ZW50XFxuICAgICAgKiBAcGx1Z2luIGNvbnRleHRtZW51XFxuICAgICAgKiBAbmFtZSBjb250ZXh0X3Nob3cudmFrYXRhXFxuICAgICAgKiBAcGFyYW0ge2pRdWVyeX0gcmVmZXJlbmNlIHRoZSBlbGVtZW50IHRoYXQgd2FzIHJpZ2h0IGNsaWNrZWRcXG4gICAgICAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IHRoZSBET00gZWxlbWVudCBvZiB0aGUgbWVudSBpdHNlbGZcXG4gICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb3NpdGlvbiB0aGUgeCAmIHkgY29vcmRpbmF0ZXMgb2YgdGhlIG1lbnVcXG4gICAgICAqL1xcblxcdFxcdFxcdFxcdFxcdCQudmFrYXRhLmNvbnRleHQuX3RyaWdnZXIoXFxcInNob3dcXFwiKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRoaWRlOiBmdW5jdGlvbiBoaWRlKCkge1xcblxcdFxcdFxcdFxcdGlmICh2YWthdGFfY29udGV4dC5pc192aXNpYmxlKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFrYXRhX2NvbnRleHQuZWxlbWVudC5oaWRlKCkuZmluZChcXFwidWxcXFwiKS5oaWRlKCkuZW5kKCkuZmluZCgnOmZvY3VzJykuYmx1cigpLmVuZCgpLmRldGFjaCgpO1xcblxcdFxcdFxcdFxcdFxcdHZha2F0YV9jb250ZXh0LmlzX3Zpc2libGUgPSBmYWxzZTtcXG5cXHRcXHRcXHRcXHRcXHQvKipcXG4gICAgICAqIHRyaWdnZXJlZCBvbiB0aGUgZG9jdW1lbnQgd2hlbiB0aGUgY29udGV4dG1lbnUgaXMgaGlkZGVuXFxuICAgICAgKiBAZXZlbnRcXG4gICAgICAqIEBwbHVnaW4gY29udGV4dG1lbnVcXG4gICAgICAqIEBuYW1lIGNvbnRleHRfaGlkZS52YWthdGFcXG4gICAgICAqIEBwYXJhbSB7alF1ZXJ5fSByZWZlcmVuY2UgdGhlIGVsZW1lbnQgdGhhdCB3YXMgcmlnaHQgY2xpY2tlZFxcbiAgICAgICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgdGhlIERPTSBlbGVtZW50IG9mIHRoZSBtZW51IGl0c2VsZlxcbiAgICAgICogQHBhcmFtIHtPYmplY3R9IHBvc2l0aW9uIHRoZSB4ICYgeSBjb29yZGluYXRlcyBvZiB0aGUgbWVudVxcbiAgICAgICovXFxuXFx0XFx0XFx0XFx0XFx0JC52YWthdGEuY29udGV4dC5fdHJpZ2dlcihcXFwiaGlkZVxcXCIpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fTtcXG5cXHRcXHQkKGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRyaWdodF90b19sZWZ0ID0gJChcXFwiYm9keVxcXCIpLmNzcyhcXFwiZGlyZWN0aW9uXFxcIikgPT09IFxcXCJydGxcXFwiO1xcblxcdFxcdFxcdHZhciB0byA9IGZhbHNlO1xcblxcblxcdFxcdFxcdHZha2F0YV9jb250ZXh0LmVsZW1lbnQgPSAkKFxcXCI8dWwgY2xhc3M9J3Zha2F0YS1jb250ZXh0Jz48L3VsPlxcXCIpO1xcblxcdFxcdFxcdHZha2F0YV9jb250ZXh0LmVsZW1lbnQub24oXFxcIm1vdXNlZW50ZXJcXFwiLCBcXFwibGlcXFwiLCBmdW5jdGlvbiAoZSkge1xcblxcdFxcdFxcdFxcdGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCQuY29udGFpbnModGhpcywgZS5yZWxhdGVkVGFyZ2V0KSkge1xcblxcdFxcdFxcdFxcdFxcdC8vINC/0YDQtdC80LDRhdC90LDRgtC+INC30LDRgNCw0LTQuCBkZWxlZ2F0ZSBtb3VzZWxlYXZlINC/0L4t0LTQvtC70YNcXG5cXHRcXHRcXHRcXHRcXHQvLyAkKHRoaXMpLmZpbmQoXFxcIi52YWthdGEtY29udGV4dC1ob3ZlclxcXCIpLnJlbW92ZUNsYXNzKFxcXCJ2YWthdGEtY29udGV4dC1ob3ZlclxcXCIpO1xcblxcdFxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKHRvKSB7XFxuXFx0XFx0XFx0XFx0XFx0Y2xlYXJUaW1lb3V0KHRvKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0dmFrYXRhX2NvbnRleHQuZWxlbWVudC5maW5kKFxcXCIudmFrYXRhLWNvbnRleHQtaG92ZXJcXFwiKS5yZW1vdmVDbGFzcyhcXFwidmFrYXRhLWNvbnRleHQtaG92ZXJcXFwiKS5lbmQoKTtcXG5cXG5cXHRcXHRcXHRcXHQkKHRoaXMpLnNpYmxpbmdzKCkuZmluZChcXFwidWxcXFwiKS5oaWRlKCkuZW5kKCkuZW5kKCkucGFyZW50c1VudGlsKFxcXCIudmFrYXRhLWNvbnRleHRcXFwiLCBcXFwibGlcXFwiKS5hZGRCYWNrKCkuYWRkQ2xhc3MoXFxcInZha2F0YS1jb250ZXh0LWhvdmVyXFxcIik7XFxuXFx0XFx0XFx0XFx0JC52YWthdGEuY29udGV4dC5fc2hvd19zdWJtZW51KHRoaXMpO1xcblxcdFxcdFxcdH0pXFxuXFx0XFx0XFx0Ly8g0YLQtdGB0YLQvtCy0L4gLSDQtNCw0LvQuCDQvdC1INC90LDRgtC+0LLQsNGA0LLQsD9cXG5cXHRcXHRcXHQub24oXFxcIm1vdXNlbGVhdmVcXFwiLCBcXFwibGlcXFwiLCBmdW5jdGlvbiAoZSkge1xcblxcdFxcdFxcdFxcdGlmICgkLmNvbnRhaW5zKHRoaXMsIGUucmVsYXRlZFRhcmdldCkpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdCQodGhpcykuZmluZChcXFwiLnZha2F0YS1jb250ZXh0LWhvdmVyXFxcIikuYWRkQmFjaygpLnJlbW92ZUNsYXNzKFxcXCJ2YWthdGEtY29udGV4dC1ob3ZlclxcXCIpO1xcblxcdFxcdFxcdH0pLm9uKFxcXCJtb3VzZWxlYXZlXFxcIiwgZnVuY3Rpb24gKGUpIHtcXG5cXHRcXHRcXHRcXHQkKHRoaXMpLmZpbmQoXFxcIi52YWthdGEtY29udGV4dC1ob3ZlclxcXCIpLnJlbW92ZUNsYXNzKFxcXCJ2YWthdGEtY29udGV4dC1ob3ZlclxcXCIpO1xcblxcdFxcdFxcdFxcdGlmICgkLnZha2F0YS5jb250ZXh0LnNldHRpbmdzLmhpZGVfb25tb3VzZWxlYXZlKSB7XFxuXFx0XFx0XFx0XFx0XFx0dG8gPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICh0KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQkLnZha2F0YS5jb250ZXh0LmhpZGUoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdFxcdFxcdH0odGhpcyksICQudmFrYXRhLmNvbnRleHQuc2V0dGluZ3MuaGlkZV9vbm1vdXNlbGVhdmUpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9KS5vbihcXFwiY2xpY2tcXFwiLCBcXFwiYVxcXCIsIGZ1bmN0aW9uIChlKSB7XFxuXFx0XFx0XFx0XFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdFxcdFxcdFxcdC8vfSlcXG5cXHRcXHRcXHRcXHQvLy5vbihcXFwibW91c2V1cFxcXCIsIFxcXCJhXFxcIiwgZnVuY3Rpb24gKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoISQodGhpcykuYmx1cigpLnBhcmVudCgpLmhhc0NsYXNzKFxcXCJ2YWthdGEtY29udGV4dC1kaXNhYmxlZFxcXCIpICYmICQudmFrYXRhLmNvbnRleHQuX2V4ZWN1dGUoJCh0aGlzKS5hdHRyKFxcXCJyZWxcXFwiKSkgIT09IGZhbHNlKSB7XFxuXFx0XFx0XFx0XFx0XFx0JC52YWthdGEuY29udGV4dC5oaWRlKCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0pLm9uKCdrZXlkb3duJywgJ2EnLCBmdW5jdGlvbiAoZSkge1xcblxcdFxcdFxcdFxcdHZhciBvID0gbnVsbDtcXG5cXHRcXHRcXHRcXHRzd2l0Y2ggKGUud2hpY2gpIHtcXG5cXHRcXHRcXHRcXHRcXHRjYXNlIDEzOlxcblxcdFxcdFxcdFxcdFxcdGNhc2UgMzI6XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZS50eXBlID0gXFxcImNsaWNrXFxcIjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRlLnByZXZlbnREZWZhdWx0KCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0JChlLmN1cnJlbnRUYXJnZXQpLnRyaWdnZXIoZSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAzNzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAodmFrYXRhX2NvbnRleHQuaXNfdmlzaWJsZSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZha2F0YV9jb250ZXh0LmVsZW1lbnQuZmluZChcXFwiLnZha2F0YS1jb250ZXh0LWhvdmVyXFxcIikubGFzdCgpLmNsb3Nlc3QoXFxcImxpXFxcIikuZmlyc3QoKS5maW5kKFxcXCJ1bFxcXCIpLmhpZGUoKS5maW5kKFxcXCIudmFrYXRhLWNvbnRleHQtaG92ZXJcXFwiKS5yZW1vdmVDbGFzcyhcXFwidmFrYXRhLWNvbnRleHQtaG92ZXJcXFwiKS5lbmQoKS5lbmQoKS5jaGlsZHJlbignYScpLmZvY3VzKCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRlLnByZXZlbnREZWZhdWx0KCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdGNhc2UgMzg6XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKHZha2F0YV9jb250ZXh0LmlzX3Zpc2libGUpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRvID0gdmFrYXRhX2NvbnRleHQuZWxlbWVudC5maW5kKFxcXCJ1bDp2aXNpYmxlXFxcIikuYWRkQmFjaygpLmxhc3QoKS5jaGlsZHJlbihcXFwiLnZha2F0YS1jb250ZXh0LWhvdmVyXFxcIikucmVtb3ZlQ2xhc3MoXFxcInZha2F0YS1jb250ZXh0LWhvdmVyXFxcIikucHJldkFsbChcXFwibGk6bm90KC52YWthdGEtY29udGV4dC1zZXBhcmF0b3IpXFxcIikuZmlyc3QoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIW8ubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0byA9IHZha2F0YV9jb250ZXh0LmVsZW1lbnQuZmluZChcXFwidWw6dmlzaWJsZVxcXCIpLmFkZEJhY2soKS5sYXN0KCkuY2hpbGRyZW4oXFxcImxpOm5vdCgudmFrYXRhLWNvbnRleHQtc2VwYXJhdG9yKVxcXCIpLmxhc3QoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0by5hZGRDbGFzcyhcXFwidmFrYXRhLWNvbnRleHQtaG92ZXJcXFwiKS5jaGlsZHJlbignYScpLmZvY3VzKCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRlLnByZXZlbnREZWZhdWx0KCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdGNhc2UgMzk6XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKHZha2F0YV9jb250ZXh0LmlzX3Zpc2libGUpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YWthdGFfY29udGV4dC5lbGVtZW50LmZpbmQoXFxcIi52YWthdGEtY29udGV4dC1ob3ZlclxcXCIpLmxhc3QoKS5jaGlsZHJlbihcXFwidWxcXFwiKS5zaG93KCkuY2hpbGRyZW4oXFxcImxpOm5vdCgudmFrYXRhLWNvbnRleHQtc2VwYXJhdG9yKVxcXCIpLnJlbW92ZUNsYXNzKFxcXCJ2YWthdGEtY29udGV4dC1ob3ZlclxcXCIpLmZpcnN0KCkuYWRkQ2xhc3MoXFxcInZha2F0YS1jb250ZXh0LWhvdmVyXFxcIikuY2hpbGRyZW4oJ2EnKS5mb2N1cygpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRjYXNlIDQwOlxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICh2YWthdGFfY29udGV4dC5pc192aXNpYmxlKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0byA9IHZha2F0YV9jb250ZXh0LmVsZW1lbnQuZmluZChcXFwidWw6dmlzaWJsZVxcXCIpLmFkZEJhY2soKS5sYXN0KCkuY2hpbGRyZW4oXFxcIi52YWthdGEtY29udGV4dC1ob3ZlclxcXCIpLnJlbW92ZUNsYXNzKFxcXCJ2YWthdGEtY29udGV4dC1ob3ZlclxcXCIpLm5leHRBbGwoXFxcImxpOm5vdCgudmFrYXRhLWNvbnRleHQtc2VwYXJhdG9yKVxcXCIpLmZpcnN0KCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCFvLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG8gPSB2YWthdGFfY29udGV4dC5lbGVtZW50LmZpbmQoXFxcInVsOnZpc2libGVcXFwiKS5hZGRCYWNrKCkubGFzdCgpLmNoaWxkcmVuKFxcXCJsaTpub3QoLnZha2F0YS1jb250ZXh0LXNlcGFyYXRvcilcXFwiKS5maXJzdCgpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRvLmFkZENsYXNzKFxcXCJ2YWthdGEtY29udGV4dC1ob3ZlclxcXCIpLmNoaWxkcmVuKCdhJykuZm9jdXMoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGUucHJldmVudERlZmF1bHQoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAyNzpcXG5cXHRcXHRcXHRcXHRcXHRcXHQkLnZha2F0YS5jb250ZXh0LmhpZGUoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRlLnByZXZlbnREZWZhdWx0KCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0ZGVmYXVsdDpcXG5cXHRcXHRcXHRcXHRcXHRcXHQvL2NvbnNvbGUubG9nKGUud2hpY2gpO1xcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9KS5vbigna2V5ZG93bicsIGZ1bmN0aW9uIChlKSB7XFxuXFx0XFx0XFx0XFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdFxcdFxcdFxcdHZhciBhID0gdmFrYXRhX2NvbnRleHQuZWxlbWVudC5maW5kKCcudmFrYXRhLWNvbnRleHRtZW51LXNob3J0Y3V0LScgKyBlLndoaWNoKS5wYXJlbnQoKTtcXG5cXHRcXHRcXHRcXHRpZiAoYS5wYXJlbnQoKS5ub3QoJy52YWthdGEtY29udGV4dC1kaXNhYmxlZCcpKSB7XFxuXFx0XFx0XFx0XFx0XFx0YS5jbGljaygpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9KTtcXG5cXG5cXHRcXHRcXHQkKGRvY3VtZW50KS5vbihcXFwibW91c2Vkb3duLnZha2F0YS5qc3RyZWVcXFwiLCBmdW5jdGlvbiAoZSkge1xcblxcdFxcdFxcdFxcdGlmICh2YWthdGFfY29udGV4dC5pc192aXNpYmxlICYmICEkLmNvbnRhaW5zKHZha2F0YV9jb250ZXh0LmVsZW1lbnRbMF0sIGUudGFyZ2V0KSkge1xcblxcdFxcdFxcdFxcdFxcdCQudmFrYXRhLmNvbnRleHQuaGlkZSgpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9KS5vbihcXFwiY29udGV4dF9zaG93LnZha2F0YS5qc3RyZWVcXFwiLCBmdW5jdGlvbiAoZSwgZGF0YSkge1xcblxcdFxcdFxcdFxcdHZha2F0YV9jb250ZXh0LmVsZW1lbnQuZmluZChcXFwibGk6aGFzKHVsKVxcXCIpLmNoaWxkcmVuKFxcXCJhXFxcIikuYWRkQ2xhc3MoXFxcInZha2F0YS1jb250ZXh0LXBhcmVudFxcXCIpO1xcblxcdFxcdFxcdFxcdGlmIChyaWdodF90b19sZWZ0KSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFrYXRhX2NvbnRleHQuZWxlbWVudC5hZGRDbGFzcyhcXFwidmFrYXRhLWNvbnRleHQtcnRsXFxcIikuY3NzKFxcXCJkaXJlY3Rpb25cXFwiLCBcXFwicnRsXFxcIik7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdC8vIGFsc28gYXBwbHkgYSBSVEwgY2xhc3M/XFxuXFx0XFx0XFx0XFx0dmFrYXRhX2NvbnRleHQuZWxlbWVudC5maW5kKFxcXCJ1bFxcXCIpLmhpZGUoKS5lbmQoKTtcXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHR9KTtcXG5cXHR9KSgkKTtcXG5cXHQvLyAkLmpzdHJlZS5kZWZhdWx0cy5wbHVnaW5zLnB1c2goXFxcImNvbnRleHRtZW51XFxcIik7XFxuXFxuXFxuXFx0LyoqXFxuICAqICMjIyBEcmFnJ24nZHJvcCBwbHVnaW5cXG4gICpcXG4gICogRW5hYmxlcyBkcmFnZ2luZyBhbmQgZHJvcHBpbmcgb2Ygbm9kZXMgaW4gdGhlIHRyZWUsIHJlc3VsdGluZyBpbiBhIG1vdmUgb3IgY29weSBvcGVyYXRpb25zLlxcbiAgKi9cXG5cXG5cXHQvKipcXG4gICogc3RvcmVzIGFsbCBkZWZhdWx0cyBmb3IgdGhlIGRyYWcnbidkcm9wIHBsdWdpblxcbiAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5kbmRcXG4gICogQHBsdWdpbiBkbmRcXG4gICovXFxuXFx0JC5qc3RyZWUuZGVmYXVsdHMuZG5kID0ge1xcblxcdFxcdC8qKlxcbiAgICogYSBib29sZWFuIGluZGljYXRpbmcgaWYgYSBjb3B5IHNob3VsZCBiZSBwb3NzaWJsZSB3aGlsZSBkcmFnZ2luZyAoYnkgcHJlc3NpbnQgdGhlIG1ldGEga2V5IG9yIEN0cmwpLiBEZWZhdWx0cyB0byBgdHJ1ZWAuXFxuICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5kbmQuY29weVxcbiAgICogQHBsdWdpbiBkbmRcXG4gICAqL1xcblxcdFxcdGNvcHk6IHRydWUsXFxuXFx0XFx0LyoqXFxuICAgKiBhIG51bWJlciBpbmRpY2F0aW5nIGhvdyBsb25nIGEgbm9kZSBzaG91bGQgcmVtYWluIGhvdmVyZWQgd2hpbGUgZHJhZ2dpbmcgdG8gYmUgb3BlbmVkLiBEZWZhdWx0cyB0byBgNTAwYC5cXG4gICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmRuZC5vcGVuX3RpbWVvdXRcXG4gICAqIEBwbHVnaW4gZG5kXFxuICAgKi9cXG5cXHRcXHRvcGVuX3RpbWVvdXQ6IDUwMCxcXG5cXHRcXHQvKipcXG4gICAqIGEgZnVuY3Rpb24gaW52b2tlZCBlYWNoIHRpbWUgYSBub2RlIGlzIGFib3V0IHRvIGJlIGRyYWdnZWQsIGludm9rZWQgaW4gdGhlIHRyZWUncyBzY29wZSBhbmQgcmVjZWl2ZXMgdGhlIG5vZGVzIGFib3V0IHRvIGJlIGRyYWdnZWQgYXMgYW4gYXJndW1lbnQgKGFycmF5KSBhbmQgdGhlIGV2ZW50IHRoYXQgc3RhcnRlZCB0aGUgZHJhZyAtIHJldHVybiBgZmFsc2VgIHRvIHByZXZlbnQgZHJhZ2dpbmdcXG4gICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmRuZC5pc19kcmFnZ2FibGVcXG4gICAqIEBwbHVnaW4gZG5kXFxuICAgKi9cXG5cXHRcXHRpc19kcmFnZ2FibGU6IHRydWUsXFxuXFx0XFx0LyoqXFxuICAgKiBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiBjaGVja3Mgc2hvdWxkIGNvbnN0YW50bHkgYmUgbWFkZSB3aGlsZSB0aGUgdXNlciBpcyBkcmFnZ2luZyB0aGUgbm9kZSAoYXMgb3Bwb3NlZCB0byBjaGVja2luZyBvbmx5IG9uIGRyb3ApLCBkZWZhdWx0IGlzIGB0cnVlYFxcbiAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuZG5kLmNoZWNrX3doaWxlX2RyYWdnaW5nXFxuICAgKiBAcGx1Z2luIGRuZFxcbiAgICovXFxuXFx0XFx0Y2hlY2tfd2hpbGVfZHJhZ2dpbmc6IHRydWUsXFxuXFx0XFx0LyoqXFxuICAgKiBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiBub2RlcyBmcm9tIHRoaXMgdHJlZSBzaG91bGQgb25seSBiZSBjb3BpZWQgd2l0aCBkbmQgKGFzIG9wcG9zZWQgdG8gbW92ZWQpLCBkZWZhdWx0IGlzIGBmYWxzZWBcXG4gICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmRuZC5hbHdheXNfY29weVxcbiAgICogQHBsdWdpbiBkbmRcXG4gICAqL1xcblxcdFxcdGFsd2F5c19jb3B5OiBmYWxzZSxcXG5cXHRcXHQvKipcXG4gICAqIHdoZW4gZHJvcHBpbmcgYSBub2RlIFxcXCJpbnNpZGVcXFwiLCB0aGlzIHNldHRpbmcgaW5kaWNhdGVzIHRoZSBwb3NpdGlvbiB0aGUgbm9kZSBzaG91bGQgZ28gdG8gLSBpdCBjYW4gYmUgYW4gaW50ZWdlciBvciBhIHN0cmluZzogXFxcImZpcnN0XFxcIiAoc2FtZSBhcyAwKSBvciBcXFwibGFzdFxcXCIsIGRlZmF1bHQgaXMgYDBgXFxuICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5kbmQuaW5zaWRlX3Bvc1xcbiAgICogQHBsdWdpbiBkbmRcXG4gICAqL1xcblxcdFxcdGluc2lkZV9wb3M6IDAsXFxuXFx0XFx0LyoqXFxuICAgKiB3aGVuIHN0YXJ0aW5nIHRoZSBkcmFnIG9uIGEgbm9kZSB0aGF0IGlzIHNlbGVjdGVkIHRoaXMgc2V0dGluZyBjb250cm9scyBpZiBhbGwgc2VsZWN0ZWQgbm9kZXMgYXJlIGRyYWdnZWQgb3Igb25seSB0aGUgc2luZ2xlIG5vZGUsIGRlZmF1bHQgaXMgYHRydWVgLCB3aGljaCBtZWFucyBhbGwgc2VsZWN0ZWQgbm9kZXMgYXJlIGRyYWdnZWQgd2hlbiB0aGUgZHJhZyBpcyBzdGFydGVkIG9uIGEgc2VsZWN0ZWQgbm9kZVxcbiAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuZG5kLmRyYWdfc2VsZWN0aW9uXFxuICAgKiBAcGx1Z2luIGRuZFxcbiAgICovXFxuXFx0XFx0ZHJhZ19zZWxlY3Rpb246IHRydWUsXFxuXFx0XFx0LyoqXFxuICAgKiBjb250cm9scyB3aGV0aGVyIGRuZCB3b3JrcyBvbiB0b3VjaCBkZXZpY2VzLiBJZiBsZWZ0IGFzIGJvb2xlYW4gdHJ1ZSBkbmQgd2lsbCB3b3JrIHRoZSBzYW1lIGFzIGluIGRlc2t0b3AgYnJvd3NlcnMsIHdoaWNoIGluIHNvbWUgY2FzZXMgbWF5IGltcGFpciBzY3JvbGxpbmcuIElmIHNldCB0byBib29sZWFuIGZhbHNlIGRuZCB3aWxsIG5vdCB3b3JrIG9uIHRvdWNoIGRldmljZXMuIFRoZXJlIGlzIGEgc3BlY2lhbCB0aGlyZCBvcHRpb24gLSBzdHJpbmcgXFxcInNlbGVjdGVkXFxcIiB3aGljaCBtZWFucyBvbmx5IHNlbGVjdGVkIG5vZGVzIGNhbiBiZSBkcmFnZ2VkIG9uIHRvdWNoIGRldmljZXMuXFxuICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5kbmQudG91Y2hcXG4gICAqIEBwbHVnaW4gZG5kXFxuICAgKi9cXG5cXHRcXHR0b3VjaDogdHJ1ZSxcXG5cXHRcXHQvKipcXG4gICAqIGNvbnRyb2xzIHdoZXRoZXIgaXRlbXMgY2FuIGJlIGRyb3BwZWQgYW55d2hlcmUgb24gdGhlIG5vZGUsIG5vdCBqdXN0IG9uIHRoZSBhbmNob3IsIGJ5IGRlZmF1bHQgb25seSB0aGUgbm9kZSBhbmNob3IgaXMgYSB2YWxpZCBkcm9wIHRhcmdldC4gV29ya3MgYmVzdCB3aXRoIHRoZSB3aG9sZXJvdyBwbHVnaW4uIElmIGVuYWJsZWQgb24gbW9iaWxlIGRlcGVuZGluZyBvbiB0aGUgaW50ZXJmYWNlIGl0IG1pZ2h0IGJlIGhhcmQgZm9yIHRoZSB1c2VyIHRvIGNhbmNlbCB0aGUgZHJvcCwgc2luY2UgdGhlIHdob2xlIHRyZWUgY29udGFpbmVyIHdpbGwgYmUgYSB2YWxpZCBkcm9wIHRhcmdldC5cXG4gICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmRuZC5sYXJnZV9kcm9wX3RhcmdldFxcbiAgICogQHBsdWdpbiBkbmRcXG4gICAqL1xcblxcdFxcdGxhcmdlX2Ryb3BfdGFyZ2V0OiBmYWxzZSxcXG5cXHRcXHQvKipcXG4gICAqIGNvbnRyb2xzIHdoZXRoZXIgYSBkcmFnIGNhbiBiZSBpbml0aWF0ZWQgZnJvbSBhbnkgcGFydCBvZiB0aGUgbm9kZSBhbmQgbm90IGp1c3QgdGhlIHRleHQvaWNvbiBwYXJ0LCB3b3JrcyBiZXN0IHdpdGggdGhlIHdob2xlcm93IHBsdWdpbi4gS2VlcCBpbiBtaW5kIGl0IGNhbiBjYXVzZSBwcm9ibGVtcyB3aXRoIHRyZWUgc2Nyb2xsaW5nIG9uIG1vYmlsZSBkZXBlbmRpbmcgb24gdGhlIGludGVyZmFjZSAtIGluIHRoYXQgY2FzZSBzZXQgdGhlIHRvdWNoIG9wdGlvbiB0byBcXFwic2VsZWN0ZWRcXFwiLlxcbiAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuZG5kLmxhcmdlX2RyYWdfdGFyZ2V0XFxuICAgKiBAcGx1Z2luIGRuZFxcbiAgICovXFxuXFx0XFx0bGFyZ2VfZHJhZ190YXJnZXQ6IGZhbHNlLFxcblxcdFxcdC8qKlxcbiAgICogY29udHJvbHMgd2hldGhlciB1c2UgSFRNTDUgZG5kIGFwaSBpbnN0ZWFkIG9mIGNsYXNzaWNhbC4gVGhhdCB3aWxsIGFsbG93IGJldHRlciBpbnRlZ3JhdGlvbiBvZiBkbmQgZXZlbnRzIHdpdGggb3RoZXIgSFRNTDUgY29udHJvbHMuXFxuICAgKiBAcmVmZXJlbmNlIGh0dHA6Ly9jYW5pdXNlLmNvbS8jZmVhdD1kcmFnbmRyb3BcXG4gICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmRuZC51c2VfaHRtbDVcXG4gICAqIEBwbHVnaW4gZG5kXFxuICAgKi9cXG5cXHRcXHR1c2VfaHRtbDU6IGZhbHNlXFxuXFx0fTtcXG5cXHR2YXIgZHJnLCBlbG07XFxuXFx0Ly8gVE9ETzogbm93IGNoZWNrIHdvcmtzIGJ5IGNoZWNraW5nIGZvciBlYWNoIG5vZGUgaW5kaXZpZHVhbGx5LCBob3cgYWJvdXQgbWF4X2NoaWxkcmVuLCB1bmlxdWUsIGV0Yz9cXG5cXHQkLmpzdHJlZS5wbHVnaW5zLmRuZCA9IGZ1bmN0aW9uIChvcHRpb25zLCBwYXJlbnQpIHtcXG5cXHRcXHR0aGlzLmluaXQgPSBmdW5jdGlvbiAoZWwsIG9wdGlvbnMpIHtcXG5cXHRcXHRcXHRwYXJlbnQuaW5pdC5jYWxsKHRoaXMsIGVsLCBvcHRpb25zKTtcXG5cXHRcXHRcXHR0aGlzLnNldHRpbmdzLmRuZC51c2VfaHRtbDUgPSB0aGlzLnNldHRpbmdzLmRuZC51c2VfaHRtbDUgJiYgJ2RyYWdnYWJsZScgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xcblxcdFxcdH07XFxuXFx0XFx0dGhpcy5iaW5kID0gZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdHBhcmVudC5iaW5kLmNhbGwodGhpcyk7XFxuXFxuXFx0XFx0XFx0dGhpcy5lbGVtZW50Lm9uKHRoaXMuc2V0dGluZ3MuZG5kLnVzZV9odG1sNSA/ICdkcmFnc3RhcnQuanN0cmVlJyA6ICdtb3VzZWRvd24uanN0cmVlIHRvdWNoc3RhcnQuanN0cmVlJywgdGhpcy5zZXR0aW5ncy5kbmQubGFyZ2VfZHJhZ190YXJnZXQgPyAnLmpzdHJlZS1ub2RlJyA6ICcuanN0cmVlLWFuY2hvcicsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAodGhpcy5zZXR0aW5ncy5kbmQubGFyZ2VfZHJhZ190YXJnZXQgJiYgJChlLnRhcmdldCkuY2xvc2VzdCgnLmpzdHJlZS1ub2RlJylbMF0gIT09IGUuY3VycmVudFRhcmdldCkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRpZiAoZS50eXBlID09PSBcXFwidG91Y2hzdGFydFxcXCIgJiYgKCF0aGlzLnNldHRpbmdzLmRuZC50b3VjaCB8fCB0aGlzLnNldHRpbmdzLmRuZC50b3VjaCA9PT0gJ3NlbGVjdGVkJyAmJiAhJChlLmN1cnJlbnRUYXJnZXQpLmNsb3Nlc3QoJy5qc3RyZWUtbm9kZScpLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLmhhc0NsYXNzKCdqc3RyZWUtY2xpY2tlZCcpKSkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR2YXIgb2JqID0gdGhpcy5nZXRfbm9kZShlLnRhcmdldCksXFxuXFx0XFx0XFx0XFx0ICAgIG1sdCA9IHRoaXMuaXNfc2VsZWN0ZWQob2JqKSAmJiB0aGlzLnNldHRpbmdzLmRuZC5kcmFnX3NlbGVjdGlvbiA/IHRoaXMuZ2V0X3RvcF9zZWxlY3RlZCgpLmxlbmd0aCA6IDEsXFxuXFx0XFx0XFx0XFx0ICAgIHR4dCA9IG1sdCA+IDEgPyBtbHQgKyAnICcgKyB0aGlzLmdldF9zdHJpbmcoJ25vZGVzJykgOiB0aGlzLmdldF90ZXh0KGUuY3VycmVudFRhcmdldCk7XFxuXFx0XFx0XFx0XFx0aWYgKHRoaXMuc2V0dGluZ3MuY29yZS5mb3JjZV90ZXh0KSB7XFxuXFx0XFx0XFx0XFx0XFx0dHh0ID0gJC52YWthdGEuaHRtbC5lc2NhcGUodHh0KTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aWYgKG9iaiAmJiBvYmouaWQgJiYgb2JqLmlkICE9PSAkLmpzdHJlZS5yb290ICYmIChlLndoaWNoID09PSAxIHx8IGUudHlwZSA9PT0gXFxcInRvdWNoc3RhcnRcXFwiIHx8IGUudHlwZSA9PT0gXFxcImRyYWdzdGFydFxcXCIpICYmICh0aGlzLnNldHRpbmdzLmRuZC5pc19kcmFnZ2FibGUgPT09IHRydWUgfHwgJC5pc0Z1bmN0aW9uKHRoaXMuc2V0dGluZ3MuZG5kLmlzX2RyYWdnYWJsZSkgJiYgdGhpcy5zZXR0aW5ncy5kbmQuaXNfZHJhZ2dhYmxlLmNhbGwodGhpcywgbWx0ID4gMSA/IHRoaXMuZ2V0X3RvcF9zZWxlY3RlZCh0cnVlKSA6IFtvYmpdLCBlKSkpIHtcXG5cXHRcXHRcXHRcXHRcXHRkcmcgPSB7ICdqc3RyZWUnOiB0cnVlLCAnb3JpZ2luJzogdGhpcywgJ29iaic6IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKSwgJ25vZGVzJzogbWx0ID4gMSA/IHRoaXMuZ2V0X3RvcF9zZWxlY3RlZCgpIDogW29iai5pZF0gfTtcXG5cXHRcXHRcXHRcXHRcXHRlbG0gPSBlLmN1cnJlbnRUYXJnZXQ7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHRoaXMuc2V0dGluZ3MuZG5kLnVzZV9odG1sNSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdCQudmFrYXRhLmRuZC5fdHJpZ2dlcignc3RhcnQnLCBlLCB7ICdoZWxwZXInOiAkKCksICdlbGVtZW50JzogZWxtLCAnZGF0YSc6IGRyZyB9KTtcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuZWxlbWVudC50cmlnZ2VyKCdtb3VzZWRvd24uanN0cmVlJyk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuICQudmFrYXRhLmRuZC5zdGFydChlLCBkcmcsICc8ZGl2IGlkPVxcXCJqc3RyZWUtZG5kXFxcIiBjbGFzcz1cXFwianN0cmVlLScgKyB0aGlzLmdldF90aGVtZSgpICsgJyBqc3RyZWUtJyArIHRoaXMuZ2V0X3RoZW1lKCkgKyAnLScgKyB0aGlzLmdldF90aGVtZV92YXJpYW50KCkgKyAnICcgKyAodGhpcy5zZXR0aW5ncy5jb3JlLnRoZW1lcy5yZXNwb25zaXZlID8gJyBqc3RyZWUtZG5kLXJlc3BvbnNpdmUnIDogJycpICsgJ1xcXCI+PGkgY2xhc3M9XFxcImpzdHJlZS1pY29uIGpzdHJlZS1lclxcXCI+PC9pPicgKyB0eHQgKyAnPGlucyBjbGFzcz1cXFwianN0cmVlLWNvcHlcXFwiIHN0eWxlPVxcXCJkaXNwbGF5Om5vbmU7XFxcIj4rPC9pbnM+PC9kaXY+Jyk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LCB0aGlzKSk7XFxuXFx0XFx0XFx0aWYgKHRoaXMuc2V0dGluZ3MuZG5kLnVzZV9odG1sNSkge1xcblxcdFxcdFxcdFxcdHRoaXMuZWxlbWVudC5vbignZHJhZ292ZXIuanN0cmVlJywgZnVuY3Rpb24gKGUpIHtcXG5cXHRcXHRcXHRcXHRcXHRlLnByZXZlbnREZWZhdWx0KCk7XFxuXFx0XFx0XFx0XFx0XFx0JC52YWthdGEuZG5kLl90cmlnZ2VyKCdtb3ZlJywgZSwgeyAnaGVscGVyJzogJCgpLCAnZWxlbWVudCc6IGVsbSwgJ2RhdGEnOiBkcmcgfSk7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdFxcdH0pXFxuXFx0XFx0XFx0XFx0Ly8ub24oJ2RyYWdlbnRlci5qc3RyZWUnLCB0aGlzLnNldHRpbmdzLmRuZC5sYXJnZV9kcm9wX3RhcmdldCA/ICcuanN0cmVlLW5vZGUnIDogJy5qc3RyZWUtYW5jaG9yJywgJC5wcm94eShmdW5jdGlvbiAoZSkge1xcblxcdFxcdFxcdFxcdC8vXFx0XFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdFxcdFxcdFxcdC8vXFx0XFx0JC52YWthdGEuZG5kLl90cmlnZ2VyKCdtb3ZlJywgZSwgeyAnaGVscGVyJzogJCgpLCAnZWxlbWVudCc6IGVsbSwgJ2RhdGEnOiBkcmcgfSk7XFxuXFx0XFx0XFx0XFx0Ly9cXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0XFx0Ly9cXHR9LCB0aGlzKSlcXG5cXHRcXHRcXHRcXHQub24oJ2Ryb3AuanN0cmVlJywgJC5wcm94eShmdW5jdGlvbiAoZSkge1xcblxcdFxcdFxcdFxcdFxcdGUucHJldmVudERlZmF1bHQoKTtcXG5cXHRcXHRcXHRcXHRcXHQkLnZha2F0YS5kbmQuX3RyaWdnZXIoJ3N0b3AnLCBlLCB7ICdoZWxwZXInOiAkKCksICdlbGVtZW50JzogZWxtLCAnZGF0YSc6IGRyZyB9KTtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0XFx0fSwgdGhpcykpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9O1xcblxcdFxcdHRoaXMucmVkcmF3X25vZGUgPSBmdW5jdGlvbiAob2JqLCBkZWVwLCBjYWxsYmFjaywgZm9yY2VfcmVuZGVyKSB7XFxuXFx0XFx0XFx0b2JqID0gcGFyZW50LnJlZHJhd19ub2RlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuXFx0XFx0XFx0aWYgKG9iaiAmJiB0aGlzLnNldHRpbmdzLmRuZC51c2VfaHRtbDUpIHtcXG5cXHRcXHRcXHRcXHRpZiAodGhpcy5zZXR0aW5ncy5kbmQubGFyZ2VfZHJhZ190YXJnZXQpIHtcXG5cXHRcXHRcXHRcXHRcXHRvYmouc2V0QXR0cmlidXRlKCdkcmFnZ2FibGUnLCB0cnVlKTtcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdHZhciBpLFxcblxcdFxcdFxcdFxcdFxcdCAgICBqLFxcblxcdFxcdFxcdFxcdFxcdCAgICB0bXAgPSBudWxsO1xcblxcdFxcdFxcdFxcdFxcdGZvciAoaSA9IDAsIGogPSBvYmouY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAob2JqLmNoaWxkTm9kZXNbaV0gJiYgb2JqLmNoaWxkTm9kZXNbaV0uY2xhc3NOYW1lICYmIG9iai5jaGlsZE5vZGVzW2ldLmNsYXNzTmFtZS5pbmRleE9mKFxcXCJqc3RyZWUtYW5jaG9yXFxcIikgIT09IC0xKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dG1wID0gb2JqLmNoaWxkTm9kZXNbaV07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRpZiAodG1wKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dG1wLnNldEF0dHJpYnV0ZSgnZHJhZ2dhYmxlJywgdHJ1ZSk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIG9iajtcXG5cXHRcXHR9O1xcblxcdH07XFxuXFxuXFx0JChmdW5jdGlvbiAoKSB7XFxuXFx0XFx0Ly8gYmluZCBvbmx5IG9uY2UgZm9yIGFsbCBpbnN0YW5jZXNcXG5cXHRcXHR2YXIgbGFzdG12ID0gZmFsc2UsXFxuXFx0XFx0ICAgIGxhc3RlciA9IGZhbHNlLFxcblxcdFxcdCAgICBsYXN0ZXYgPSBmYWxzZSxcXG5cXHRcXHQgICAgb3BlbnRvID0gZmFsc2UsXFxuXFx0XFx0ICAgIG1hcmtlciA9ICQoJzxkaXYgaWQ9XFxcImpzdHJlZS1tYXJrZXJcXFwiPiYjMTYwOzwvZGl2PicpLmhpZGUoKTsgLy8uYXBwZW5kVG8oJ2JvZHknKTtcXG5cXG5cXHRcXHQkKGRvY3VtZW50KS5vbignZG5kX3N0YXJ0LnZha2F0YS5qc3RyZWUnLCBmdW5jdGlvbiAoZSwgZGF0YSkge1xcblxcdFxcdFxcdGxhc3RtdiA9IGZhbHNlO1xcblxcdFxcdFxcdGxhc3RldiA9IGZhbHNlO1xcblxcdFxcdFxcdGlmICghZGF0YSB8fCAhZGF0YS5kYXRhIHx8ICFkYXRhLmRhdGEuanN0cmVlKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRtYXJrZXIuYXBwZW5kVG8oJ2JvZHknKTsgLy8uc2hvdygpO1xcblxcdFxcdH0pLm9uKCdkbmRfbW92ZS52YWthdGEuanN0cmVlJywgZnVuY3Rpb24gKGUsIGRhdGEpIHtcXG5cXHRcXHRcXHRpZiAob3BlbnRvKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCFkYXRhLmV2ZW50IHx8IGRhdGEuZXZlbnQudHlwZSAhPT0gJ2RyYWdvdmVyJyB8fCBkYXRhLmV2ZW50LnRhcmdldCAhPT0gbGFzdGV2LnRhcmdldCkge1xcblxcdFxcdFxcdFxcdFxcdGNsZWFyVGltZW91dChvcGVudG8pO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKCFkYXRhIHx8ICFkYXRhLmRhdGEgfHwgIWRhdGEuZGF0YS5qc3RyZWUpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIGlmIHdlIGFyZSBob3ZlcmluZyB0aGUgbWFya2VyIGltYWdlIGRvIG5vdGhpbmcgKGNhbiBoYXBwZW4gb24gXFxcImluc2lkZVxcXCIgZHJhZ3MpXFxuXFx0XFx0XFx0aWYgKGRhdGEuZXZlbnQudGFyZ2V0LmlkICYmIGRhdGEuZXZlbnQudGFyZ2V0LmlkID09PSAnanN0cmVlLW1hcmtlcicpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGxhc3RldiA9IGRhdGEuZXZlbnQ7XFxuXFxuXFx0XFx0XFx0dmFyIGlucyA9ICQuanN0cmVlLnJlZmVyZW5jZShkYXRhLmV2ZW50LnRhcmdldCksXFxuXFx0XFx0XFx0ICAgIHJlZiA9IGZhbHNlLFxcblxcdFxcdFxcdCAgICBvZmYgPSBmYWxzZSxcXG5cXHRcXHRcXHQgICAgcmVsID0gZmFsc2UsXFxuXFx0XFx0XFx0ICAgIHRtcCxcXG5cXHRcXHRcXHQgICAgbCxcXG5cXHRcXHRcXHQgICAgdCxcXG5cXHRcXHRcXHQgICAgaCxcXG5cXHRcXHRcXHQgICAgcCxcXG5cXHRcXHRcXHQgICAgaSxcXG5cXHRcXHRcXHQgICAgbyxcXG5cXHRcXHRcXHQgICAgb2ssXFxuXFx0XFx0XFx0ICAgIHQxLFxcblxcdFxcdFxcdCAgICB0MixcXG5cXHRcXHRcXHQgICAgb3AsXFxuXFx0XFx0XFx0ICAgIHBzLFxcblxcdFxcdFxcdCAgICBwcixcXG5cXHRcXHRcXHQgICAgaXAsXFxuXFx0XFx0XFx0ICAgIHRtLFxcblxcdFxcdFxcdCAgICBpc19jb3B5LFxcblxcdFxcdFxcdCAgICBwbjtcXG5cXHRcXHRcXHQvLyBpZiB3ZSBhcmUgb3ZlciBhbiBpbnN0YW5jZVxcblxcdFxcdFxcdGlmIChpbnMgJiYgaW5zLl9kYXRhICYmIGlucy5fZGF0YS5kbmQpIHtcXG5cXHRcXHRcXHRcXHRtYXJrZXIuYXR0cignY2xhc3MnLCAnanN0cmVlLScgKyBpbnMuZ2V0X3RoZW1lKCkgKyAoaW5zLnNldHRpbmdzLmNvcmUudGhlbWVzLnJlc3BvbnNpdmUgPyAnIGpzdHJlZS1kbmQtcmVzcG9uc2l2ZScgOiAnJykpO1xcblxcdFxcdFxcdFxcdGlzX2NvcHkgPSBkYXRhLmRhdGEub3JpZ2luICYmIChkYXRhLmRhdGEub3JpZ2luLnNldHRpbmdzLmRuZC5hbHdheXNfY29weSB8fCBkYXRhLmRhdGEub3JpZ2luLnNldHRpbmdzLmRuZC5jb3B5ICYmIChkYXRhLmV2ZW50Lm1ldGFLZXkgfHwgZGF0YS5ldmVudC5jdHJsS2V5KSk7XFxuXFx0XFx0XFx0XFx0ZGF0YS5oZWxwZXIuY2hpbGRyZW4oKS5hdHRyKCdjbGFzcycsICdqc3RyZWUtJyArIGlucy5nZXRfdGhlbWUoKSArICcganN0cmVlLScgKyBpbnMuZ2V0X3RoZW1lKCkgKyAnLScgKyBpbnMuZ2V0X3RoZW1lX3ZhcmlhbnQoKSArICcgJyArIChpbnMuc2V0dGluZ3MuY29yZS50aGVtZXMucmVzcG9uc2l2ZSA/ICcganN0cmVlLWRuZC1yZXNwb25zaXZlJyA6ICcnKSkuZmluZCgnLmpzdHJlZS1jb3B5JykuZmlyc3QoKVtpc19jb3B5ID8gJ3Nob3cnIDogJ2hpZGUnXSgpO1xcblxcblxcdFxcdFxcdFxcdC8vIGlmIGFyZSBob3ZlcmluZyB0aGUgY29udGFpbmVyIGl0c2VsZiBhZGQgYSBuZXcgcm9vdCBub2RlXFxuXFx0XFx0XFx0XFx0Ly9jb25zb2xlLmxvZyhkYXRhLmV2ZW50KTtcXG5cXHRcXHRcXHRcXHRpZiAoKGRhdGEuZXZlbnQudGFyZ2V0ID09PSBpbnMuZWxlbWVudFswXSB8fCBkYXRhLmV2ZW50LnRhcmdldCA9PT0gaW5zLmdldF9jb250YWluZXJfdWwoKVswXSkgJiYgaW5zLmdldF9jb250YWluZXJfdWwoKS5jaGlsZHJlbigpLmxlbmd0aCA9PT0gMCkge1xcblxcdFxcdFxcdFxcdFxcdG9rID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHRmb3IgKHQxID0gMCwgdDIgPSBkYXRhLmRhdGEubm9kZXMubGVuZ3RoOyB0MSA8IHQyOyB0MSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0b2sgPSBvayAmJiBpbnMuY2hlY2soZGF0YS5kYXRhLm9yaWdpbiAmJiAoZGF0YS5kYXRhLm9yaWdpbi5zZXR0aW5ncy5kbmQuYWx3YXlzX2NvcHkgfHwgZGF0YS5kYXRhLm9yaWdpbi5zZXR0aW5ncy5kbmQuY29weSAmJiAoZGF0YS5ldmVudC5tZXRhS2V5IHx8IGRhdGEuZXZlbnQuY3RybEtleSkpID8gXFxcImNvcHlfbm9kZVxcXCIgOiBcXFwibW92ZV9ub2RlXFxcIiwgZGF0YS5kYXRhLm9yaWdpbiAmJiBkYXRhLmRhdGEub3JpZ2luICE9PSBpbnMgPyBkYXRhLmRhdGEub3JpZ2luLmdldF9ub2RlKGRhdGEuZGF0YS5ub2Rlc1t0MV0pIDogZGF0YS5kYXRhLm5vZGVzW3QxXSwgJC5qc3RyZWUucm9vdCwgJ2xhc3QnLCB7ICdkbmQnOiB0cnVlLCAncmVmJzogaW5zLmdldF9ub2RlKCQuanN0cmVlLnJvb3QpLCAncG9zJzogJ2knLCAnb3JpZ2luJzogZGF0YS5kYXRhLm9yaWdpbiwgJ2lzX211bHRpJzogZGF0YS5kYXRhLm9yaWdpbiAmJiBkYXRhLmRhdGEub3JpZ2luICE9PSBpbnMsICdpc19mb3JlaWduJzogIWRhdGEuZGF0YS5vcmlnaW4gfSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCFvaykge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aWYgKG9rKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0bGFzdG12ID0geyAnaW5zJzogaW5zLCAncGFyJzogJC5qc3RyZWUucm9vdCwgJ3Bvcyc6ICdsYXN0JyB9O1xcblxcdFxcdFxcdFxcdFxcdFxcdG1hcmtlci5oaWRlKCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS5oZWxwZXIuZmluZCgnLmpzdHJlZS1pY29uJykuZmlyc3QoKS5yZW1vdmVDbGFzcygnanN0cmVlLWVyJykuYWRkQ2xhc3MoJ2pzdHJlZS1vaycpO1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChkYXRhLmV2ZW50Lm9yaWdpbmFsRXZlbnQgJiYgZGF0YS5ldmVudC5vcmlnaW5hbEV2ZW50LmRhdGFUcmFuc2Zlcikge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEuZXZlbnQub3JpZ2luYWxFdmVudC5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9IGlzX2NvcHkgPyAnY29weScgOiAnbW92ZSc7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHQvLyBpZiB3ZSBhcmUgaG92ZXJpbmcgYSB0cmVlIG5vZGVcXG5cXHRcXHRcXHRcXHRcXHRyZWYgPSBpbnMuc2V0dGluZ3MuZG5kLmxhcmdlX2Ryb3BfdGFyZ2V0ID8gJChkYXRhLmV2ZW50LnRhcmdldCkuY2xvc2VzdCgnLmpzdHJlZS1ub2RlJykuY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykgOiAkKGRhdGEuZXZlbnQudGFyZ2V0KS5jbG9zZXN0KCcuanN0cmVlLWFuY2hvcicpO1xcblxcdFxcdFxcdFxcdFxcdGlmIChyZWYgJiYgcmVmLmxlbmd0aCAmJiByZWYucGFyZW50KCkuaXMoJy5qc3RyZWUtY2xvc2VkLCAuanN0cmVlLW9wZW4sIC5qc3RyZWUtbGVhZicpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0b2ZmID0gcmVmLm9mZnNldCgpO1xcblxcdFxcdFxcdFxcdFxcdFxcdHJlbCA9IChkYXRhLmV2ZW50LnBhZ2VZICE9PSB1bmRlZmluZWQgPyBkYXRhLmV2ZW50LnBhZ2VZIDogZGF0YS5ldmVudC5vcmlnaW5hbEV2ZW50LnBhZ2VZKSAtIG9mZi50b3A7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aCA9IHJlZi5vdXRlckhlaWdodCgpO1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChyZWwgPCBoIC8gMykge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG8gPSBbJ2InLCAnaScsICdhJ107XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIGlmIChyZWwgPiBoIC0gaCAvIDMpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRvID0gWydhJywgJ2knLCAnYiddO1xcblxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0byA9IHJlbCA+IGggLyAyID8gWydpJywgJ2EnLCAnYiddIDogWydpJywgJ2InLCAnYSddO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHQkLmVhY2gobywgZnVuY3Rpb24gKGosIHYpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzd2l0Y2ggKHYpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdiJzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRsID0gb2ZmLmxlZnQgLSA2O1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHQgPSBvZmYudG9wO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHAgPSBpbnMuZ2V0X3BhcmVudChyZWYpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGkgPSByZWYucGFyZW50KCkuaW5kZXgoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdpJzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpcCA9IGlucy5zZXR0aW5ncy5kbmQuaW5zaWRlX3BvcztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0bSA9IGlucy5nZXRfbm9kZShyZWYucGFyZW50KCkpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGwgPSBvZmYubGVmdCAtIDI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dCA9IG9mZi50b3AgKyBoIC8gMiArIDE7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cCA9IHRtLmlkO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGkgPSBpcCA9PT0gJ2ZpcnN0JyA/IDAgOiBpcCA9PT0gJ2xhc3QnID8gdG0uY2hpbGRyZW4ubGVuZ3RoIDogTWF0aC5taW4oaXAsIHRtLmNoaWxkcmVuLmxlbmd0aCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnYSc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bCA9IG9mZi5sZWZ0IC0gNjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0ID0gb2ZmLnRvcCArIGg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cCA9IGlucy5nZXRfcGFyZW50KHJlZik7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aSA9IHJlZi5wYXJlbnQoKS5pbmRleCgpICsgMTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0b2sgPSB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGZvciAodDEgPSAwLCB0MiA9IGRhdGEuZGF0YS5ub2Rlcy5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRvcCA9IGRhdGEuZGF0YS5vcmlnaW4gJiYgKGRhdGEuZGF0YS5vcmlnaW4uc2V0dGluZ3MuZG5kLmFsd2F5c19jb3B5IHx8IGRhdGEuZGF0YS5vcmlnaW4uc2V0dGluZ3MuZG5kLmNvcHkgJiYgKGRhdGEuZXZlbnQubWV0YUtleSB8fCBkYXRhLmV2ZW50LmN0cmxLZXkpKSA/IFxcXCJjb3B5X25vZGVcXFwiIDogXFxcIm1vdmVfbm9kZVxcXCI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cHMgPSBpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChvcCA9PT0gXFxcIm1vdmVfbm9kZVxcXCIgJiYgdiA9PT0gJ2EnICYmIGRhdGEuZGF0YS5vcmlnaW4gJiYgZGF0YS5kYXRhLm9yaWdpbiA9PT0gaW5zICYmIHAgPT09IGlucy5nZXRfcGFyZW50KGRhdGEuZGF0YS5ub2Rlc1t0MV0pKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cHIgPSBpbnMuZ2V0X25vZGUocCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKHBzID4gJC5pbkFycmF5KGRhdGEuZGF0YS5ub2Rlc1t0MV0sIHByLmNoaWxkcmVuKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHBzIC09IDE7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRvayA9IG9rICYmIChpbnMgJiYgaW5zLnNldHRpbmdzICYmIGlucy5zZXR0aW5ncy5kbmQgJiYgaW5zLnNldHRpbmdzLmRuZC5jaGVja193aGlsZV9kcmFnZ2luZyA9PT0gZmFsc2UgfHwgaW5zLmNoZWNrKG9wLCBkYXRhLmRhdGEub3JpZ2luICYmIGRhdGEuZGF0YS5vcmlnaW4gIT09IGlucyA/IGRhdGEuZGF0YS5vcmlnaW4uZ2V0X25vZGUoZGF0YS5kYXRhLm5vZGVzW3QxXSkgOiBkYXRhLmRhdGEubm9kZXNbdDFdLCBwLCBwcywgeyAnZG5kJzogdHJ1ZSwgJ3JlZic6IGlucy5nZXRfbm9kZShyZWYucGFyZW50KCkpLCAncG9zJzogdiwgJ29yaWdpbic6IGRhdGEuZGF0YS5vcmlnaW4sICdpc19tdWx0aSc6IGRhdGEuZGF0YS5vcmlnaW4gJiYgZGF0YS5kYXRhLm9yaWdpbiAhPT0gaW5zLCAnaXNfZm9yZWlnbic6ICFkYXRhLmRhdGEub3JpZ2luIH0pKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIW9rKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKGlucyAmJiBpbnMubGFzdF9lcnJvcikge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGxhc3RlciA9IGlucy5sYXN0X2Vycm9yKCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKHYgPT09ICdpJyAmJiByZWYucGFyZW50KCkuaXMoJy5qc3RyZWUtY2xvc2VkJykgJiYgaW5zLnNldHRpbmdzLmRuZC5vcGVuX3RpbWVvdXQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRvcGVudG8gPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICh4LCB6KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR4Lm9wZW5fbm9kZSh6KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH0oaW5zLCByZWYpLCBpbnMuc2V0dGluZ3MuZG5kLm9wZW5fdGltZW91dCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChvaykge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHBuID0gaW5zLmdldF9ub2RlKHAsIHRydWUpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICghcG4uaGFzQ2xhc3MoJy5qc3RyZWUtZG5kLXBhcmVudCcpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0JCgnLmpzdHJlZS1kbmQtcGFyZW50JykucmVtb3ZlQ2xhc3MoJ2pzdHJlZS1kbmQtcGFyZW50Jyk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cG4uYWRkQ2xhc3MoJ2pzdHJlZS1kbmQtcGFyZW50Jyk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGxhc3RtdiA9IHsgJ2lucyc6IGlucywgJ3Bhcic6IHAsICdwb3MnOiB2ID09PSAnaScgJiYgaXAgPT09ICdsYXN0JyAmJiBpID09PSAwICYmICFpbnMuaXNfbG9hZGVkKHRtKSA/ICdsYXN0JyA6IGkgfTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRtYXJrZXIuY3NzKHsgJ2xlZnQnOiBsICsgJ3B4JywgJ3RvcCc6IHQgKyAncHgnIH0pLnNob3coKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLmhlbHBlci5maW5kKCcuanN0cmVlLWljb24nKS5maXJzdCgpLnJlbW92ZUNsYXNzKCdqc3RyZWUtZXInKS5hZGRDbGFzcygnanN0cmVlLW9rJyk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKGRhdGEuZXZlbnQub3JpZ2luYWxFdmVudCAmJiBkYXRhLmV2ZW50Lm9yaWdpbmFsRXZlbnQuZGF0YVRyYW5zZmVyKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS5ldmVudC5vcmlnaW5hbEV2ZW50LmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gaXNfY29weSA/ICdjb3B5JyA6ICdtb3ZlJztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bGFzdGVyID0ge307XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0byA9IHRydWU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAobyA9PT0gdHJ1ZSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0JCgnLmpzdHJlZS1kbmQtcGFyZW50JykucmVtb3ZlQ2xhc3MoJ2pzdHJlZS1kbmQtcGFyZW50Jyk7XFxuXFx0XFx0XFx0bGFzdG12ID0gZmFsc2U7XFxuXFx0XFx0XFx0ZGF0YS5oZWxwZXIuZmluZCgnLmpzdHJlZS1pY29uJykucmVtb3ZlQ2xhc3MoJ2pzdHJlZS1vaycpLmFkZENsYXNzKCdqc3RyZWUtZXInKTtcXG5cXHRcXHRcXHRpZiAoZGF0YS5ldmVudC5vcmlnaW5hbEV2ZW50ICYmIGRhdGEuZXZlbnQub3JpZ2luYWxFdmVudC5kYXRhVHJhbnNmZXIpIHtcXG5cXHRcXHRcXHRcXHRkYXRhLmV2ZW50Lm9yaWdpbmFsRXZlbnQuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSAnbm9uZSc7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdG1hcmtlci5oaWRlKCk7XFxuXFx0XFx0fSkub24oJ2RuZF9zY3JvbGwudmFrYXRhLmpzdHJlZScsIGZ1bmN0aW9uIChlLCBkYXRhKSB7XFxuXFx0XFx0XFx0aWYgKCFkYXRhIHx8ICFkYXRhLmRhdGEgfHwgIWRhdGEuZGF0YS5qc3RyZWUpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdG1hcmtlci5oaWRlKCk7XFxuXFx0XFx0XFx0bGFzdG12ID0gZmFsc2U7XFxuXFx0XFx0XFx0bGFzdGV2ID0gZmFsc2U7XFxuXFx0XFx0XFx0ZGF0YS5oZWxwZXIuZmluZCgnLmpzdHJlZS1pY29uJykuZmlyc3QoKS5yZW1vdmVDbGFzcygnanN0cmVlLW9rJykuYWRkQ2xhc3MoJ2pzdHJlZS1lcicpO1xcblxcdFxcdH0pLm9uKCdkbmRfc3RvcC52YWthdGEuanN0cmVlJywgZnVuY3Rpb24gKGUsIGRhdGEpIHtcXG5cXHRcXHRcXHQkKCcuanN0cmVlLWRuZC1wYXJlbnQnKS5yZW1vdmVDbGFzcygnanN0cmVlLWRuZC1wYXJlbnQnKTtcXG5cXHRcXHRcXHRpZiAob3BlbnRvKSB7XFxuXFx0XFx0XFx0XFx0Y2xlYXJUaW1lb3V0KG9wZW50byk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICghZGF0YSB8fCAhZGF0YS5kYXRhIHx8ICFkYXRhLmRhdGEuanN0cmVlKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRtYXJrZXIuaGlkZSgpLmRldGFjaCgpO1xcblxcdFxcdFxcdHZhciBpLFxcblxcdFxcdFxcdCAgICBqLFxcblxcdFxcdFxcdCAgICBub2RlcyA9IFtdO1xcblxcdFxcdFxcdGlmIChsYXN0bXYpIHtcXG5cXHRcXHRcXHRcXHRmb3IgKGkgPSAwLCBqID0gZGF0YS5kYXRhLm5vZGVzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdG5vZGVzW2ldID0gZGF0YS5kYXRhLm9yaWdpbiA/IGRhdGEuZGF0YS5vcmlnaW4uZ2V0X25vZGUoZGF0YS5kYXRhLm5vZGVzW2ldKSA6IGRhdGEuZGF0YS5ub2Rlc1tpXTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0bGFzdG12Lmluc1tkYXRhLmRhdGEub3JpZ2luICYmIChkYXRhLmRhdGEub3JpZ2luLnNldHRpbmdzLmRuZC5hbHdheXNfY29weSB8fCBkYXRhLmRhdGEub3JpZ2luLnNldHRpbmdzLmRuZC5jb3B5ICYmIChkYXRhLmV2ZW50Lm1ldGFLZXkgfHwgZGF0YS5ldmVudC5jdHJsS2V5KSkgPyAnY29weV9ub2RlJyA6ICdtb3ZlX25vZGUnXShub2RlcywgbGFzdG12LnBhciwgbGFzdG12LnBvcywgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZGF0YS5kYXRhLm9yaWdpbik7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRpID0gJChkYXRhLmV2ZW50LnRhcmdldCkuY2xvc2VzdCgnLmpzdHJlZScpO1xcblxcdFxcdFxcdFxcdGlmIChpLmxlbmd0aCAmJiBsYXN0ZXIgJiYgbGFzdGVyLmVycm9yICYmIGxhc3Rlci5lcnJvciA9PT0gJ2NoZWNrJykge1xcblxcdFxcdFxcdFxcdFxcdGkgPSBpLmpzdHJlZSh0cnVlKTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoaSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGkuc2V0dGluZ3MuY29yZS5lcnJvci5jYWxsKHRoaXMsIGxhc3Rlcik7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0bGFzdGV2ID0gZmFsc2U7XFxuXFx0XFx0XFx0bGFzdG12ID0gZmFsc2U7XFxuXFx0XFx0fSkub24oJ2tleXVwLmpzdHJlZSBrZXlkb3duLmpzdHJlZScsIGZ1bmN0aW9uIChlLCBkYXRhKSB7XFxuXFx0XFx0XFx0ZGF0YSA9ICQudmFrYXRhLmRuZC5fZ2V0KCk7XFxuXFx0XFx0XFx0aWYgKGRhdGEgJiYgZGF0YS5kYXRhICYmIGRhdGEuZGF0YS5qc3RyZWUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZS50eXBlID09PSBcXFwia2V5dXBcXFwiICYmIGUud2hpY2ggPT09IDI3KSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKG9wZW50bykge1xcblxcdFxcdFxcdFxcdFxcdFxcdGNsZWFyVGltZW91dChvcGVudG8pO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRsYXN0bXYgPSBmYWxzZTtcXG5cXHRcXHRcXHRcXHRcXHRsYXN0ZXIgPSBmYWxzZTtcXG5cXHRcXHRcXHRcXHRcXHRsYXN0ZXYgPSBmYWxzZTtcXG5cXHRcXHRcXHRcXHRcXHRvcGVudG8gPSBmYWxzZTtcXG5cXHRcXHRcXHRcXHRcXHRtYXJrZXIuaGlkZSgpLmRldGFjaCgpO1xcblxcdFxcdFxcdFxcdFxcdCQudmFrYXRhLmRuZC5fY2xlYW4oKTtcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdGRhdGEuaGVscGVyLmZpbmQoJy5qc3RyZWUtY29weScpLmZpcnN0KClbZGF0YS5kYXRhLm9yaWdpbiAmJiAoZGF0YS5kYXRhLm9yaWdpbi5zZXR0aW5ncy5kbmQuYWx3YXlzX2NvcHkgfHwgZGF0YS5kYXRhLm9yaWdpbi5zZXR0aW5ncy5kbmQuY29weSAmJiAoZS5tZXRhS2V5IHx8IGUuY3RybEtleSkpID8gJ3Nob3cnIDogJ2hpZGUnXSgpO1xcblxcdFxcdFxcdFxcdFxcdGlmIChsYXN0ZXYpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRsYXN0ZXYubWV0YUtleSA9IGUubWV0YUtleTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRsYXN0ZXYuY3RybEtleSA9IGUuY3RybEtleTtcXG5cXHRcXHRcXHRcXHRcXHRcXHQkLnZha2F0YS5kbmQuX3RyaWdnZXIoJ21vdmUnLCBsYXN0ZXYpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0pO1xcblxcdH0pO1xcblxcblxcdC8vIGhlbHBlcnNcXG5cXHQoZnVuY3Rpb24gKCQpIHtcXG5cXHRcXHQkLnZha2F0YS5odG1sID0ge1xcblxcdFxcdFxcdGRpdjogJCgnPGRpdiAvPicpLFxcblxcdFxcdFxcdGVzY2FwZTogZnVuY3Rpb24gZXNjYXBlKHN0cikge1xcblxcdFxcdFxcdFxcdHJldHVybiAkLnZha2F0YS5odG1sLmRpdi50ZXh0KHN0cikuaHRtbCgpO1xcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0c3RyaXA6IGZ1bmN0aW9uIHN0cmlwKHN0cikge1xcblxcdFxcdFxcdFxcdHJldHVybiAkLnZha2F0YS5odG1sLmRpdi5lbXB0eSgpLmFwcGVuZCgkLnBhcnNlSFRNTChzdHIpKS50ZXh0KCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH07XFxuXFx0XFx0Ly8gcHJpdmF0ZSB2YXJpYWJsZVxcblxcdFxcdHZhciB2YWthdGFfZG5kID0ge1xcblxcdFxcdFxcdGVsZW1lbnQ6IGZhbHNlLFxcblxcdFxcdFxcdHRhcmdldDogZmFsc2UsXFxuXFx0XFx0XFx0aXNfZG93bjogZmFsc2UsXFxuXFx0XFx0XFx0aXNfZHJhZzogZmFsc2UsXFxuXFx0XFx0XFx0aGVscGVyOiBmYWxzZSxcXG5cXHRcXHRcXHRoZWxwZXJfdzogMCxcXG5cXHRcXHRcXHRkYXRhOiBmYWxzZSxcXG5cXHRcXHRcXHRpbml0X3g6IDAsXFxuXFx0XFx0XFx0aW5pdF95OiAwLFxcblxcdFxcdFxcdHNjcm9sbF9sOiAwLFxcblxcdFxcdFxcdHNjcm9sbF90OiAwLFxcblxcdFxcdFxcdHNjcm9sbF9lOiBmYWxzZSxcXG5cXHRcXHRcXHRzY3JvbGxfaTogZmFsc2UsXFxuXFx0XFx0XFx0aXNfdG91Y2g6IGZhbHNlXFxuXFx0XFx0fTtcXG5cXHRcXHQkLnZha2F0YS5kbmQgPSB7XFxuXFx0XFx0XFx0c2V0dGluZ3M6IHtcXG5cXHRcXHRcXHRcXHRzY3JvbGxfc3BlZWQ6IDEwLFxcblxcdFxcdFxcdFxcdHNjcm9sbF9wcm94aW1pdHk6IDIwLFxcblxcdFxcdFxcdFxcdGhlbHBlcl9sZWZ0OiA1LFxcblxcdFxcdFxcdFxcdGhlbHBlcl90b3A6IDEwLFxcblxcdFxcdFxcdFxcdHRocmVzaG9sZDogNSxcXG5cXHRcXHRcXHRcXHR0aHJlc2hvbGRfdG91Y2g6IDUwXFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRfdHJpZ2dlcjogZnVuY3Rpb24gX3RyaWdnZXIoZXZlbnRfbmFtZSwgZSwgZGF0YSkge1xcblxcdFxcdFxcdFxcdGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcXG5cXHRcXHRcXHRcXHRcXHRkYXRhID0gJC52YWthdGEuZG5kLl9nZXQoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0ZGF0YS5ldmVudCA9IGU7XFxuXFx0XFx0XFx0XFx0JChkb2N1bWVudCkudHJpZ2dlckhhbmRsZXIoXFxcImRuZF9cXFwiICsgZXZlbnRfbmFtZSArIFxcXCIudmFrYXRhXFxcIiwgZGF0YSk7XFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRfZ2V0OiBmdW5jdGlvbiBfZ2V0KCkge1xcblxcdFxcdFxcdFxcdHJldHVybiB7XFxuXFx0XFx0XFx0XFx0XFx0XFxcImRhdGFcXFwiOiB2YWthdGFfZG5kLmRhdGEsXFxuXFx0XFx0XFx0XFx0XFx0XFxcImVsZW1lbnRcXFwiOiB2YWthdGFfZG5kLmVsZW1lbnQsXFxuXFx0XFx0XFx0XFx0XFx0XFxcImhlbHBlclxcXCI6IHZha2F0YV9kbmQuaGVscGVyXFxuXFx0XFx0XFx0XFx0fTtcXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdF9jbGVhbjogZnVuY3Rpb24gX2NsZWFuKCkge1xcblxcdFxcdFxcdFxcdGlmICh2YWthdGFfZG5kLmhlbHBlcikge1xcblxcdFxcdFxcdFxcdFxcdHZha2F0YV9kbmQuaGVscGVyLnJlbW92ZSgpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRpZiAodmFrYXRhX2RuZC5zY3JvbGxfaSkge1xcblxcdFxcdFxcdFxcdFxcdGNsZWFySW50ZXJ2YWwodmFrYXRhX2RuZC5zY3JvbGxfaSk7dmFrYXRhX2RuZC5zY3JvbGxfaSA9IGZhbHNlO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR2YWthdGFfZG5kID0ge1xcblxcdFxcdFxcdFxcdFxcdGVsZW1lbnQ6IGZhbHNlLFxcblxcdFxcdFxcdFxcdFxcdHRhcmdldDogZmFsc2UsXFxuXFx0XFx0XFx0XFx0XFx0aXNfZG93bjogZmFsc2UsXFxuXFx0XFx0XFx0XFx0XFx0aXNfZHJhZzogZmFsc2UsXFxuXFx0XFx0XFx0XFx0XFx0aGVscGVyOiBmYWxzZSxcXG5cXHRcXHRcXHRcXHRcXHRoZWxwZXJfdzogMCxcXG5cXHRcXHRcXHRcXHRcXHRkYXRhOiBmYWxzZSxcXG5cXHRcXHRcXHRcXHRcXHRpbml0X3g6IDAsXFxuXFx0XFx0XFx0XFx0XFx0aW5pdF95OiAwLFxcblxcdFxcdFxcdFxcdFxcdHNjcm9sbF9sOiAwLFxcblxcdFxcdFxcdFxcdFxcdHNjcm9sbF90OiAwLFxcblxcdFxcdFxcdFxcdFxcdHNjcm9sbF9lOiBmYWxzZSxcXG5cXHRcXHRcXHRcXHRcXHRzY3JvbGxfaTogZmFsc2UsXFxuXFx0XFx0XFx0XFx0XFx0aXNfdG91Y2g6IGZhbHNlXFxuXFx0XFx0XFx0XFx0fTtcXG5cXHRcXHRcXHRcXHQkKGRvY3VtZW50KS5vZmYoXFxcIm1vdXNlbW92ZS52YWthdGEuanN0cmVlIHRvdWNobW92ZS52YWthdGEuanN0cmVlXFxcIiwgJC52YWthdGEuZG5kLmRyYWcpO1xcblxcdFxcdFxcdFxcdCQoZG9jdW1lbnQpLm9mZihcXFwibW91c2V1cC52YWthdGEuanN0cmVlIHRvdWNoZW5kLnZha2F0YS5qc3RyZWVcXFwiLCAkLnZha2F0YS5kbmQuc3RvcCk7XFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRfc2Nyb2xsOiBmdW5jdGlvbiBfc2Nyb2xsKGluaXRfb25seSkge1xcblxcdFxcdFxcdFxcdGlmICghdmFrYXRhX2RuZC5zY3JvbGxfZSB8fCAhdmFrYXRhX2RuZC5zY3JvbGxfbCAmJiAhdmFrYXRhX2RuZC5zY3JvbGxfdCkge1xcblxcdFxcdFxcdFxcdFxcdGlmICh2YWthdGFfZG5kLnNjcm9sbF9pKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2xlYXJJbnRlcnZhbCh2YWthdGFfZG5kLnNjcm9sbF9pKTt2YWthdGFfZG5kLnNjcm9sbF9pID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aWYgKCF2YWthdGFfZG5kLnNjcm9sbF9pKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFrYXRhX2RuZC5zY3JvbGxfaSA9IHNldEludGVydmFsKCQudmFrYXRhLmRuZC5fc2Nyb2xsLCAxMDApO1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aWYgKGluaXRfb25seSA9PT0gdHJ1ZSkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGkgPSB2YWthdGFfZG5kLnNjcm9sbF9lLnNjcm9sbFRvcCgpLFxcblxcdFxcdFxcdFxcdCAgICBqID0gdmFrYXRhX2RuZC5zY3JvbGxfZS5zY3JvbGxMZWZ0KCk7XFxuXFx0XFx0XFx0XFx0dmFrYXRhX2RuZC5zY3JvbGxfZS5zY3JvbGxUb3AoaSArIHZha2F0YV9kbmQuc2Nyb2xsX3QgKiAkLnZha2F0YS5kbmQuc2V0dGluZ3Muc2Nyb2xsX3NwZWVkKTtcXG5cXHRcXHRcXHRcXHR2YWthdGFfZG5kLnNjcm9sbF9lLnNjcm9sbExlZnQoaiArIHZha2F0YV9kbmQuc2Nyb2xsX2wgKiAkLnZha2F0YS5kbmQuc2V0dGluZ3Muc2Nyb2xsX3NwZWVkKTtcXG5cXHRcXHRcXHRcXHRpZiAoaSAhPT0gdmFrYXRhX2RuZC5zY3JvbGxfZS5zY3JvbGxUb3AoKSB8fCBqICE9PSB2YWthdGFfZG5kLnNjcm9sbF9lLnNjcm9sbExlZnQoKSkge1xcblxcdFxcdFxcdFxcdFxcdC8qKlxcbiAgICAgICogdHJpZ2dlcmVkIG9uIHRoZSBkb2N1bWVudCB3aGVuIGEgZHJhZyBjYXVzZXMgYW4gZWxlbWVudCB0byBzY3JvbGxcXG4gICAgICAqIEBldmVudFxcbiAgICAgICogQHBsdWdpbiBkbmRcXG4gICAgICAqIEBuYW1lIGRuZF9zY3JvbGwudmFrYXRhXFxuICAgICAgKiBAcGFyYW0ge01peGVkfSBkYXRhIGFueSBkYXRhIHN1cHBsaWVkIHdpdGggdGhlIGNhbGwgdG8gJC52YWthdGEuZG5kLnN0YXJ0XFxuICAgICAgKiBAcGFyYW0ge0RPTX0gZWxlbWVudCB0aGUgRE9NIGVsZW1lbnQgYmVpbmcgZHJhZ2dlZFxcbiAgICAgICogQHBhcmFtIHtqUXVlcnl9IGhlbHBlciB0aGUgaGVscGVyIHNob3duIG5leHQgdG8gdGhlIG1vdXNlXFxuICAgICAgKiBAcGFyYW0ge2pRdWVyeX0gZXZlbnQgdGhlIGVsZW1lbnQgdGhhdCBpcyBzY3JvbGxpbmdcXG4gICAgICAqL1xcblxcdFxcdFxcdFxcdFxcdCQudmFrYXRhLmRuZC5fdHJpZ2dlcihcXFwic2Nyb2xsXFxcIiwgdmFrYXRhX2RuZC5zY3JvbGxfZSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0c3RhcnQ6IGZ1bmN0aW9uIHN0YXJ0KGUsIGRhdGEsIGh0bWwpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZS50eXBlID09PSBcXFwidG91Y2hzdGFydFxcXCIgJiYgZS5vcmlnaW5hbEV2ZW50ICYmIGUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlcyAmJiBlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0pIHtcXG5cXHRcXHRcXHRcXHRcXHRlLnBhZ2VYID0gZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VYO1xcblxcdFxcdFxcdFxcdFxcdGUucGFnZVkgPSBlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVk7XFxuXFx0XFx0XFx0XFx0XFx0ZS50YXJnZXQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KGUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWCAtIHdpbmRvdy5wYWdlWE9mZnNldCwgZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VZIC0gd2luZG93LnBhZ2VZT2Zmc2V0KTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aWYgKHZha2F0YV9kbmQuaXNfZHJhZykge1xcblxcdFxcdFxcdFxcdFxcdCQudmFrYXRhLmRuZC5zdG9wKHt9KTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0dHJ5IHtcXG5cXHRcXHRcXHRcXHRcXHRlLmN1cnJlbnRUYXJnZXQudW5zZWxlY3RhYmxlID0gXFxcIm9uXFxcIjtcXG5cXHRcXHRcXHRcXHRcXHRlLmN1cnJlbnRUYXJnZXQub25zZWxlY3RzdGFydCA9IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0XFx0XFx0fTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoZS5jdXJyZW50VGFyZ2V0LnN0eWxlKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZS5jdXJyZW50VGFyZ2V0LnN0eWxlLnRvdWNoQWN0aW9uID0gXFxcIm5vbmVcXFwiO1xcblxcdFxcdFxcdFxcdFxcdFxcdGUuY3VycmVudFRhcmdldC5zdHlsZS5tc1RvdWNoQWN0aW9uID0gXFxcIm5vbmVcXFwiO1xcblxcdFxcdFxcdFxcdFxcdFxcdGUuY3VycmVudFRhcmdldC5zdHlsZS5Nb3pVc2VyU2VsZWN0ID0gXFxcIm5vbmVcXFwiO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9IGNhdGNoIChpZ25vcmUpIHt9XFxuXFx0XFx0XFx0XFx0dmFrYXRhX2RuZC5pbml0X3ggPSBlLnBhZ2VYO1xcblxcdFxcdFxcdFxcdHZha2F0YV9kbmQuaW5pdF95ID0gZS5wYWdlWTtcXG5cXHRcXHRcXHRcXHR2YWthdGFfZG5kLmRhdGEgPSBkYXRhO1xcblxcdFxcdFxcdFxcdHZha2F0YV9kbmQuaXNfZG93biA9IHRydWU7XFxuXFx0XFx0XFx0XFx0dmFrYXRhX2RuZC5lbGVtZW50ID0gZS5jdXJyZW50VGFyZ2V0O1xcblxcdFxcdFxcdFxcdHZha2F0YV9kbmQudGFyZ2V0ID0gZS50YXJnZXQ7XFxuXFx0XFx0XFx0XFx0dmFrYXRhX2RuZC5pc190b3VjaCA9IGUudHlwZSA9PT0gXFxcInRvdWNoc3RhcnRcXFwiO1xcblxcdFxcdFxcdFxcdGlmIChodG1sICE9PSBmYWxzZSkge1xcblxcdFxcdFxcdFxcdFxcdHZha2F0YV9kbmQuaGVscGVyID0gJChcXFwiPGRpdiBpZD0ndmFrYXRhLWRuZCc+PC9kaXY+XFxcIikuaHRtbChodG1sKS5jc3Moe1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcXCJkaXNwbGF5XFxcIjogXFxcImJsb2NrXFxcIixcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXFwibWFyZ2luXFxcIjogXFxcIjBcXFwiLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcXCJwYWRkaW5nXFxcIjogXFxcIjBcXFwiLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcXCJwb3NpdGlvblxcXCI6IFxcXCJhYnNvbHV0ZVxcXCIsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFxcInRvcFxcXCI6IFxcXCItMjAwMHB4XFxcIixcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXFwibGluZUhlaWdodFxcXCI6IFxcXCIxNnB4XFxcIixcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXFwiekluZGV4XFxcIjogXFxcIjEwMDAwXFxcIlxcblxcdFxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHQkKGRvY3VtZW50KS5vbihcXFwibW91c2Vtb3ZlLnZha2F0YS5qc3RyZWUgdG91Y2htb3ZlLnZha2F0YS5qc3RyZWVcXFwiLCAkLnZha2F0YS5kbmQuZHJhZyk7XFxuXFx0XFx0XFx0XFx0JChkb2N1bWVudCkub24oXFxcIm1vdXNldXAudmFrYXRhLmpzdHJlZSB0b3VjaGVuZC52YWthdGEuanN0cmVlXFxcIiwgJC52YWthdGEuZG5kLnN0b3ApO1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdGRyYWc6IGZ1bmN0aW9uIGRyYWcoZSkge1xcblxcdFxcdFxcdFxcdGlmIChlLnR5cGUgPT09IFxcXCJ0b3VjaG1vdmVcXFwiICYmIGUub3JpZ2luYWxFdmVudCAmJiBlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXMgJiYgZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZS5wYWdlWCA9IGUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWDtcXG5cXHRcXHRcXHRcXHRcXHRlLnBhZ2VZID0gZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VZO1xcblxcdFxcdFxcdFxcdFxcdGUudGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVggLSB3aW5kb3cucGFnZVhPZmZzZXQsIGUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWSAtIHdpbmRvdy5wYWdlWU9mZnNldCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGlmICghdmFrYXRhX2RuZC5pc19kb3duKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRpZiAoIXZha2F0YV9kbmQuaXNfZHJhZykge1xcblxcdFxcdFxcdFxcdFxcdGlmIChNYXRoLmFicyhlLnBhZ2VYIC0gdmFrYXRhX2RuZC5pbml0X3gpID4gKHZha2F0YV9kbmQuaXNfdG91Y2ggPyAkLnZha2F0YS5kbmQuc2V0dGluZ3MudGhyZXNob2xkX3RvdWNoIDogJC52YWthdGEuZG5kLnNldHRpbmdzLnRocmVzaG9sZCkgfHwgTWF0aC5hYnMoZS5wYWdlWSAtIHZha2F0YV9kbmQuaW5pdF95KSA+ICh2YWthdGFfZG5kLmlzX3RvdWNoID8gJC52YWthdGEuZG5kLnNldHRpbmdzLnRocmVzaG9sZF90b3VjaCA6ICQudmFrYXRhLmRuZC5zZXR0aW5ncy50aHJlc2hvbGQpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKHZha2F0YV9kbmQuaGVscGVyKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFrYXRhX2RuZC5oZWxwZXIuYXBwZW5kVG8oXFxcImJvZHlcXFwiKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YWthdGFfZG5kLmhlbHBlcl93ID0gdmFrYXRhX2RuZC5oZWxwZXIub3V0ZXJXaWR0aCgpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR2YWthdGFfZG5kLmlzX2RyYWcgPSB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdFxcdCQodmFrYXRhX2RuZC50YXJnZXQpLm9uZSgnY2xpY2sudmFrYXRhJywgZmFsc2UpO1xcblxcdFxcdFxcdFxcdFxcdFxcdC8qKlxcbiAgICAgICAqIHRyaWdnZXJlZCBvbiB0aGUgZG9jdW1lbnQgd2hlbiBhIGRyYWcgc3RhcnRzXFxuICAgICAgICogQGV2ZW50XFxuICAgICAgICogQHBsdWdpbiBkbmRcXG4gICAgICAgKiBAbmFtZSBkbmRfc3RhcnQudmFrYXRhXFxuICAgICAgICogQHBhcmFtIHtNaXhlZH0gZGF0YSBhbnkgZGF0YSBzdXBwbGllZCB3aXRoIHRoZSBjYWxsIHRvICQudmFrYXRhLmRuZC5zdGFydFxcbiAgICAgICAqIEBwYXJhbSB7RE9NfSBlbGVtZW50IHRoZSBET00gZWxlbWVudCBiZWluZyBkcmFnZ2VkXFxuICAgICAgICogQHBhcmFtIHtqUXVlcnl9IGhlbHBlciB0aGUgaGVscGVyIHNob3duIG5leHQgdG8gdGhlIG1vdXNlXFxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IHRoZSBldmVudCB0aGF0IGNhdXNlZCB0aGUgc3RhcnQgKHByb2JhYmx5IG1vdXNlbW92ZSlcXG4gICAgICAgKi9cXG5cXHRcXHRcXHRcXHRcXHRcXHQkLnZha2F0YS5kbmQuX3RyaWdnZXIoXFxcInN0YXJ0XFxcIiwgZSk7XFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR2YXIgZCA9IGZhbHNlLFxcblxcdFxcdFxcdFxcdCAgICB3ID0gZmFsc2UsXFxuXFx0XFx0XFx0XFx0ICAgIGRoID0gZmFsc2UsXFxuXFx0XFx0XFx0XFx0ICAgIHdoID0gZmFsc2UsXFxuXFx0XFx0XFx0XFx0ICAgIGR3ID0gZmFsc2UsXFxuXFx0XFx0XFx0XFx0ICAgIHd3ID0gZmFsc2UsXFxuXFx0XFx0XFx0XFx0ICAgIGR0ID0gZmFsc2UsXFxuXFx0XFx0XFx0XFx0ICAgIGRsID0gZmFsc2UsXFxuXFx0XFx0XFx0XFx0ICAgIGh0ID0gZmFsc2UsXFxuXFx0XFx0XFx0XFx0ICAgIGhsID0gZmFsc2U7XFxuXFxuXFx0XFx0XFx0XFx0dmFrYXRhX2RuZC5zY3JvbGxfdCA9IDA7XFxuXFx0XFx0XFx0XFx0dmFrYXRhX2RuZC5zY3JvbGxfbCA9IDA7XFxuXFx0XFx0XFx0XFx0dmFrYXRhX2RuZC5zY3JvbGxfZSA9IGZhbHNlO1xcblxcdFxcdFxcdFxcdCQoJChlLnRhcmdldCkucGFyZW50c1VudGlsKFxcXCJib2R5XFxcIikuYWRkQmFjaygpLmdldCgpLnJldmVyc2UoKSkuZmlsdGVyKGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gKC9eYXV0b3xzY3JvbGwkLy50ZXN0KCQodGhpcykuY3NzKFxcXCJvdmVyZmxvd1xcXCIpKSAmJiAodGhpcy5zY3JvbGxIZWlnaHQgPiB0aGlzLm9mZnNldEhlaWdodCB8fCB0aGlzLnNjcm9sbFdpZHRoID4gdGhpcy5vZmZzZXRXaWR0aClcXG5cXHRcXHRcXHRcXHRcXHQpO1xcblxcdFxcdFxcdFxcdH0pLmVhY2goZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdHZhciB0ID0gJCh0aGlzKSxcXG5cXHRcXHRcXHRcXHRcXHQgICAgbyA9IHQub2Zmc2V0KCk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHRoaXMuc2Nyb2xsSGVpZ2h0ID4gdGhpcy5vZmZzZXRIZWlnaHQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoby50b3AgKyB0LmhlaWdodCgpIC0gZS5wYWdlWSA8ICQudmFrYXRhLmRuZC5zZXR0aW5ncy5zY3JvbGxfcHJveGltaXR5KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFrYXRhX2RuZC5zY3JvbGxfdCA9IDE7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChlLnBhZ2VZIC0gby50b3AgPCAkLnZha2F0YS5kbmQuc2V0dGluZ3Muc2Nyb2xsX3Byb3hpbWl0eSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZha2F0YV9kbmQuc2Nyb2xsX3QgPSAtMTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmICh0aGlzLnNjcm9sbFdpZHRoID4gdGhpcy5vZmZzZXRXaWR0aCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChvLmxlZnQgKyB0LndpZHRoKCkgLSBlLnBhZ2VYIDwgJC52YWthdGEuZG5kLnNldHRpbmdzLnNjcm9sbF9wcm94aW1pdHkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YWthdGFfZG5kLnNjcm9sbF9sID0gMTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKGUucGFnZVggLSBvLmxlZnQgPCAkLnZha2F0YS5kbmQuc2V0dGluZ3Muc2Nyb2xsX3Byb3hpbWl0eSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZha2F0YV9kbmQuc2Nyb2xsX2wgPSAtMTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmICh2YWthdGFfZG5kLnNjcm9sbF90IHx8IHZha2F0YV9kbmQuc2Nyb2xsX2wpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YWthdGFfZG5kLnNjcm9sbF9lID0gJCh0aGlzKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH0pO1xcblxcblxcdFxcdFxcdFxcdGlmICghdmFrYXRhX2RuZC5zY3JvbGxfZSkge1xcblxcdFxcdFxcdFxcdFxcdGQgPSAkKGRvY3VtZW50KTt3ID0gJCh3aW5kb3cpO1xcblxcdFxcdFxcdFxcdFxcdGRoID0gZC5oZWlnaHQoKTt3aCA9IHcuaGVpZ2h0KCk7XFxuXFx0XFx0XFx0XFx0XFx0ZHcgPSBkLndpZHRoKCk7d3cgPSB3LndpZHRoKCk7XFxuXFx0XFx0XFx0XFx0XFx0ZHQgPSBkLnNjcm9sbFRvcCgpO2RsID0gZC5zY3JvbGxMZWZ0KCk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGRoID4gd2ggJiYgZS5wYWdlWSAtIGR0IDwgJC52YWthdGEuZG5kLnNldHRpbmdzLnNjcm9sbF9wcm94aW1pdHkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YWthdGFfZG5kLnNjcm9sbF90ID0gLTE7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmIChkaCA+IHdoICYmIHdoIC0gKGUucGFnZVkgLSBkdCkgPCAkLnZha2F0YS5kbmQuc2V0dGluZ3Muc2Nyb2xsX3Byb3hpbWl0eSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHZha2F0YV9kbmQuc2Nyb2xsX3QgPSAxO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRpZiAoZHcgPiB3dyAmJiBlLnBhZ2VYIC0gZGwgPCAkLnZha2F0YS5kbmQuc2V0dGluZ3Muc2Nyb2xsX3Byb3hpbWl0eSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHZha2F0YV9kbmQuc2Nyb2xsX2wgPSAtMTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGR3ID4gd3cgJiYgd3cgLSAoZS5wYWdlWCAtIGRsKSA8ICQudmFrYXRhLmRuZC5zZXR0aW5ncy5zY3JvbGxfcHJveGltaXR5KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFrYXRhX2RuZC5zY3JvbGxfbCA9IDE7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmICh2YWthdGFfZG5kLnNjcm9sbF90IHx8IHZha2F0YV9kbmQuc2Nyb2xsX2wpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YWthdGFfZG5kLnNjcm9sbF9lID0gZDtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGlmICh2YWthdGFfZG5kLnNjcm9sbF9lKSB7XFxuXFx0XFx0XFx0XFx0XFx0JC52YWthdGEuZG5kLl9zY3JvbGwodHJ1ZSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmICh2YWthdGFfZG5kLmhlbHBlcikge1xcblxcdFxcdFxcdFxcdFxcdGh0ID0gcGFyc2VJbnQoZS5wYWdlWSArICQudmFrYXRhLmRuZC5zZXR0aW5ncy5oZWxwZXJfdG9wLCAxMCk7XFxuXFx0XFx0XFx0XFx0XFx0aGwgPSBwYXJzZUludChlLnBhZ2VYICsgJC52YWthdGEuZG5kLnNldHRpbmdzLmhlbHBlcl9sZWZ0LCAxMCk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGRoICYmIGh0ICsgMjUgPiBkaCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGh0ID0gZGggLSA1MDtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGR3ICYmIGhsICsgdmFrYXRhX2RuZC5oZWxwZXJfdyA+IGR3KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aGwgPSBkdyAtICh2YWthdGFfZG5kLmhlbHBlcl93ICsgMik7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdHZha2F0YV9kbmQuaGVscGVyLmNzcyh7XFxuXFx0XFx0XFx0XFx0XFx0XFx0bGVmdDogaGwgKyBcXFwicHhcXFwiLFxcblxcdFxcdFxcdFxcdFxcdFxcdHRvcDogaHQgKyBcXFwicHhcXFwiXFxuXFx0XFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdC8qKlxcbiAgICAgKiB0cmlnZ2VyZWQgb24gdGhlIGRvY3VtZW50IHdoZW4gYSBkcmFnIGlzIGluIHByb2dyZXNzXFxuICAgICAqIEBldmVudFxcbiAgICAgKiBAcGx1Z2luIGRuZFxcbiAgICAgKiBAbmFtZSBkbmRfbW92ZS52YWthdGFcXG4gICAgICogQHBhcmFtIHtNaXhlZH0gZGF0YSBhbnkgZGF0YSBzdXBwbGllZCB3aXRoIHRoZSBjYWxsIHRvICQudmFrYXRhLmRuZC5zdGFydFxcbiAgICAgKiBAcGFyYW0ge0RPTX0gZWxlbWVudCB0aGUgRE9NIGVsZW1lbnQgYmVpbmcgZHJhZ2dlZFxcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gaGVscGVyIHRoZSBoZWxwZXIgc2hvd24gbmV4dCB0byB0aGUgbW91c2VcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IHRoZSBldmVudCB0aGF0IGNhdXNlZCB0aGlzIHRvIHRyaWdnZXIgKG1vc3QgbGlrZWx5IG1vdXNlbW92ZSlcXG4gICAgICovXFxuXFx0XFx0XFx0XFx0JC52YWthdGEuZG5kLl90cmlnZ2VyKFxcXCJtb3ZlXFxcIiwgZSk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0c3RvcDogZnVuY3Rpb24gc3RvcChlKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGUudHlwZSA9PT0gXFxcInRvdWNoZW5kXFxcIiAmJiBlLm9yaWdpbmFsRXZlbnQgJiYgZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzICYmIGUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXSkge1xcblxcdFxcdFxcdFxcdFxcdGUucGFnZVggPSBlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVg7XFxuXFx0XFx0XFx0XFx0XFx0ZS5wYWdlWSA9IGUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWTtcXG5cXHRcXHRcXHRcXHRcXHRlLnRhcmdldCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VYIC0gd2luZG93LnBhZ2VYT2Zmc2V0LCBlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVkgLSB3aW5kb3cucGFnZVlPZmZzZXQpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRpZiAodmFrYXRhX2RuZC5pc19kcmFnKSB7XFxuXFx0XFx0XFx0XFx0XFx0LyoqXFxuICAgICAgKiB0cmlnZ2VyZWQgb24gdGhlIGRvY3VtZW50IHdoZW4gYSBkcmFnIHN0b3BzICh0aGUgZHJhZ2dlZCBlbGVtZW50IGlzIGRyb3BwZWQpXFxuICAgICAgKiBAZXZlbnRcXG4gICAgICAqIEBwbHVnaW4gZG5kXFxuICAgICAgKiBAbmFtZSBkbmRfc3RvcC52YWthdGFcXG4gICAgICAqIEBwYXJhbSB7TWl4ZWR9IGRhdGEgYW55IGRhdGEgc3VwcGxpZWQgd2l0aCB0aGUgY2FsbCB0byAkLnZha2F0YS5kbmQuc3RhcnRcXG4gICAgICAqIEBwYXJhbSB7RE9NfSBlbGVtZW50IHRoZSBET00gZWxlbWVudCBiZWluZyBkcmFnZ2VkXFxuICAgICAgKiBAcGFyYW0ge2pRdWVyeX0gaGVscGVyIHRoZSBoZWxwZXIgc2hvd24gbmV4dCB0byB0aGUgbW91c2VcXG4gICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCB0aGUgZXZlbnQgdGhhdCBjYXVzZWQgdGhlIHN0b3BcXG4gICAgICAqL1xcblxcdFxcdFxcdFxcdFxcdGlmIChlLnRhcmdldCAhPT0gdmFrYXRhX2RuZC50YXJnZXQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHQkKHZha2F0YV9kbmQudGFyZ2V0KS5vZmYoJ2NsaWNrLnZha2F0YScpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHQkLnZha2F0YS5kbmQuX3RyaWdnZXIoXFxcInN0b3BcXFwiLCBlKTtcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdGlmIChlLnR5cGUgPT09IFxcXCJ0b3VjaGVuZFxcXCIgJiYgZS50YXJnZXQgPT09IHZha2F0YV9kbmQudGFyZ2V0KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIHRvID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0JChlLnRhcmdldCkuY2xpY2soKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9LCAxMDApO1xcblxcdFxcdFxcdFxcdFxcdFxcdCQoZS50YXJnZXQpLm9uZSgnY2xpY2snLCBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKHRvKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Y2xlYXJUaW1lb3V0KHRvKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHQkLnZha2F0YS5kbmQuX2NsZWFuKCk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9O1xcblxcdH0pKCQpO1xcblxcblxcdC8vIGluY2x1ZGUgdGhlIGRuZCBwbHVnaW4gYnkgZGVmYXVsdFxcblxcdC8vICQuanN0cmVlLmRlZmF1bHRzLnBsdWdpbnMucHVzaChcXFwiZG5kXFxcIik7XFxuXFxuXFxuXFx0LyoqXFxuICAqICMjIyBNYXNzbG9hZCBwbHVnaW5cXG4gICpcXG4gICogQWRkcyBtYXNzbG9hZCBmdW5jdGlvbmFsaXR5IHRvIGpzVHJlZSwgc28gdGhhdCBtdWx0aXBsZSBub2RlcyBjYW4gYmUgbG9hZGVkIGluIGEgc2luZ2xlIHJlcXVlc3QgKG9ubHkgdXNlZnVsIHdpdGggbGF6eSBsb2FkaW5nKS5cXG4gICovXFxuXFxuXFx0LyoqXFxuICAqIG1hc3Nsb2FkIGNvbmZpZ3VyYXRpb25cXG4gICpcXG4gICogSXQgaXMgcG9zc2libGUgdG8gc2V0IHRoaXMgdG8gYSBzdGFuZGFyZCBqUXVlcnktbGlrZSBBSkFYIGNvbmZpZy5cXG4gICogSW4gYWRkaXRpb24gdG8gdGhlIHN0YW5kYXJkIGpRdWVyeSBhamF4IG9wdGlvbnMgaGVyZSB5b3UgY2FuIHN1cHBseSBmdW5jdGlvbnMgZm9yIGBkYXRhYCBhbmQgYHVybGAsIHRoZSBmdW5jdGlvbnMgd2lsbCBiZSBydW4gaW4gdGhlIGN1cnJlbnQgaW5zdGFuY2UncyBzY29wZSBhbmQgYSBwYXJhbSB3aWxsIGJlIHBhc3NlZCBpbmRpY2F0aW5nIHdoaWNoIG5vZGUgSURzIG5lZWQgdG8gYmUgbG9hZGVkLCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRob3NlIGZ1bmN0aW9ucyB3aWxsIGJlIHVzZWQuXFxuICAqXFxuICAqIFlvdSBjYW4gYWxzbyBzZXQgdGhpcyB0byBhIGZ1bmN0aW9uLCB0aGF0IGZ1bmN0aW9uIHdpbGwgcmVjZWl2ZSB0aGUgbm9kZSBJRHMgYmVpbmcgbG9hZGVkIGFzIGFyZ3VtZW50IGFuZCBhIHNlY29uZCBwYXJhbSB3aGljaCBpcyBhIGZ1bmN0aW9uIChjYWxsYmFjaykgd2hpY2ggc2hvdWxkIGJlIGNhbGxlZCB3aXRoIHRoZSByZXN1bHQuXFxuICAqXFxuICAqIEJvdGggdGhlIEFKQVggYW5kIHRoZSBmdW5jdGlvbiBhcHByb2FjaCByZWx5IG9uIHRoZSBzYW1lIHJldHVybiB2YWx1ZSAtIGFuIG9iamVjdCB3aGVyZSB0aGUga2V5cyBhcmUgdGhlIG5vZGUgSURzLCBhbmQgdGhlIHZhbHVlIGlzIHRoZSBjaGlsZHJlbiBvZiB0aGF0IG5vZGUgYXMgYW4gYXJyYXkuXFxuICAqXFxuICAqXFx0e1xcbiAgKlxcdFxcdFxcXCJpZDFcXFwiIDogW3sgXFxcInRleHRcXFwiIDogXFxcIkNoaWxkIG9mIElEMVxcXCIsIFxcXCJpZFxcXCIgOiBcXFwiYzFcXFwiIH0sIHsgXFxcInRleHRcXFwiIDogXFxcIkFub3RoZXIgY2hpbGQgb2YgSUQxXFxcIiwgXFxcImlkXFxcIiA6IFxcXCJjMlxcXCIgfV0sXFxuICAqXFx0XFx0XFxcImlkMlxcXCIgOiBbeyBcXFwidGV4dFxcXCIgOiBcXFwiQ2hpbGQgb2YgSUQyXFxcIiwgXFxcImlkXFxcIiA6IFxcXCJjM1xcXCIgfV1cXG4gICpcXHR9XFxuICAqIFxcbiAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5tYXNzbG9hZFxcbiAgKiBAcGx1Z2luIG1hc3Nsb2FkXFxuICAqL1xcblxcdCQuanN0cmVlLmRlZmF1bHRzLm1hc3Nsb2FkID0gbnVsbDtcXG5cXHQkLmpzdHJlZS5wbHVnaW5zLm1hc3Nsb2FkID0gZnVuY3Rpb24gKG9wdGlvbnMsIHBhcmVudCkge1xcblxcdFxcdHRoaXMuaW5pdCA9IGZ1bmN0aW9uIChlbCwgb3B0aW9ucykge1xcblxcdFxcdFxcdHRoaXMuX2RhdGEubWFzc2xvYWQgPSB7fTtcXG5cXHRcXHRcXHRwYXJlbnQuaW5pdC5jYWxsKHRoaXMsIGVsLCBvcHRpb25zKTtcXG5cXHRcXHR9O1xcblxcdFxcdHRoaXMuX2xvYWRfbm9kZXMgPSBmdW5jdGlvbiAobm9kZXMsIGNhbGxiYWNrLCBpc19jYWxsYmFjaywgZm9yY2VfcmVsb2FkKSB7XFxuXFx0XFx0XFx0dmFyIHMgPSB0aGlzLnNldHRpbmdzLm1hc3Nsb2FkLFxcblxcdFxcdFxcdCAgICBub2Rlc1N0cmluZyA9IEpTT04uc3RyaW5naWZ5KG5vZGVzKSxcXG5cXHRcXHRcXHQgICAgdG9Mb2FkID0gW10sXFxuXFx0XFx0XFx0ICAgIG0gPSB0aGlzLl9tb2RlbC5kYXRhLFxcblxcdFxcdFxcdCAgICBpLFxcblxcdFxcdFxcdCAgICBqLFxcblxcdFxcdFxcdCAgICBkb207XFxuXFx0XFx0XFx0aWYgKCFpc19jYWxsYmFjaykge1xcblxcdFxcdFxcdFxcdGZvciAoaSA9IDAsIGogPSBub2Rlcy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIW1bbm9kZXNbaV1dIHx8ICFtW25vZGVzW2ldXS5zdGF0ZS5sb2FkZWQgJiYgIW1bbm9kZXNbaV1dLnN0YXRlLmZhaWxlZCB8fCBmb3JjZV9yZWxvYWQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0b0xvYWQucHVzaChub2Rlc1tpXSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZG9tID0gdGhpcy5nZXRfbm9kZShub2Rlc1tpXSwgdHJ1ZSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKGRvbSAmJiBkb20ubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZG9tLmFkZENsYXNzKFxcXCJqc3RyZWUtbG9hZGluZ1xcXCIpLmF0dHIoJ2FyaWEtYnVzeScsIHRydWUpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHRoaXMuX2RhdGEubWFzc2xvYWQgPSB7fTtcXG5cXHRcXHRcXHRcXHRpZiAodG9Mb2FkLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdFxcdGlmICgkLmlzRnVuY3Rpb24ocykpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gcy5jYWxsKHRoaXMsIHRvTG9hZCwgJC5wcm94eShmdW5jdGlvbiAoZGF0YSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciBpLCBqO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChkYXRhKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Zm9yIChpIGluIGRhdGEpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoZGF0YS5oYXNPd25Qcm9wZXJ0eShpKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuX2RhdGEubWFzc2xvYWRbaV0gPSBkYXRhW2ldO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGZvciAoaSA9IDAsIGogPSBub2Rlcy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkb20gPSB0aGlzLmdldF9ub2RlKG5vZGVzW2ldLCB0cnVlKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoZG9tICYmIGRvbS5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkb20ucmVtb3ZlQ2xhc3MoXFxcImpzdHJlZS1sb2FkaW5nXFxcIikuYXR0cignYXJpYS1idXN5JywgZmFsc2UpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cGFyZW50Ll9sb2FkX25vZGVzLmNhbGwodGhpcywgbm9kZXMsIGNhbGxiYWNrLCBpc19jYWxsYmFjaywgZm9yY2VfcmVsb2FkKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9LCB0aGlzKSk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmICgodHlwZW9mIHMgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHMpKSA9PT0gJ29iamVjdCcgJiYgcyAmJiBzLnVybCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHMgPSAkLmV4dGVuZCh0cnVlLCB7fSwgcyk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCQuaXNGdW5jdGlvbihzLnVybCkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzLnVybCA9IHMudXJsLmNhbGwodGhpcywgdG9Mb2FkKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCQuaXNGdW5jdGlvbihzLmRhdGEpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cy5kYXRhID0gcy5kYXRhLmNhbGwodGhpcywgdG9Mb2FkKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuICQuYWpheChzKS5kb25lKCQucHJveHkoZnVuY3Rpb24gKGRhdGEsIHQsIHgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgaSwgajtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoZGF0YSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGZvciAoaSBpbiBkYXRhKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKGRhdGEuaGFzT3duUHJvcGVydHkoaSkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl9kYXRhLm1hc3Nsb2FkW2ldID0gZGF0YVtpXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRmb3IgKGkgPSAwLCBqID0gbm9kZXMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZG9tID0gdGhpcy5nZXRfbm9kZShub2Rlc1tpXSwgdHJ1ZSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKGRvbSAmJiBkb20ubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZG9tLnJlbW92ZUNsYXNzKFxcXCJqc3RyZWUtbG9hZGluZ1xcXCIpLmF0dHIoJ2FyaWEtYnVzeScsIGZhbHNlKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHBhcmVudC5fbG9hZF9ub2Rlcy5jYWxsKHRoaXMsIG5vZGVzLCBjYWxsYmFjaywgaXNfY2FsbGJhY2ssIGZvcmNlX3JlbG9hZCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSwgdGhpcykpLmZhaWwoJC5wcm94eShmdW5jdGlvbiAoZikge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHBhcmVudC5fbG9hZF9ub2Rlcy5jYWxsKHRoaXMsIG5vZGVzLCBjYWxsYmFjaywgaXNfY2FsbGJhY2ssIGZvcmNlX3JlbG9hZCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSwgdGhpcykpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiBwYXJlbnQuX2xvYWRfbm9kZXMuY2FsbCh0aGlzLCBub2RlcywgY2FsbGJhY2ssIGlzX2NhbGxiYWNrLCBmb3JjZV9yZWxvYWQpO1xcblxcdFxcdH07XFxuXFx0XFx0dGhpcy5fbG9hZF9ub2RlID0gZnVuY3Rpb24gKG9iaiwgY2FsbGJhY2spIHtcXG5cXHRcXHRcXHR2YXIgZGF0YSA9IHRoaXMuX2RhdGEubWFzc2xvYWRbb2JqLmlkXSxcXG5cXHRcXHRcXHQgICAgcnNsdCA9IG51bGwsXFxuXFx0XFx0XFx0ICAgIGRvbTtcXG5cXHRcXHRcXHRpZiAoZGF0YSkge1xcblxcdFxcdFxcdFxcdHJzbHQgPSB0aGlzW3R5cGVvZiBkYXRhID09PSAnc3RyaW5nJyA/ICdfYXBwZW5kX2h0bWxfZGF0YScgOiAnX2FwcGVuZF9qc29uX2RhdGEnXShvYmosIHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyA/ICQoJC5wYXJzZUhUTUwoZGF0YSkpLmZpbHRlcihmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMubm9kZVR5cGUgIT09IDM7XFxuXFx0XFx0XFx0XFx0fSkgOiBkYXRhLCBmdW5jdGlvbiAoc3RhdHVzKSB7XFxuXFx0XFx0XFx0XFx0XFx0Y2FsbGJhY2suY2FsbCh0aGlzLCBzdGF0dXMpO1xcblxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdFxcdGRvbSA9IHRoaXMuZ2V0X25vZGUob2JqLmlkLCB0cnVlKTtcXG5cXHRcXHRcXHRcXHRpZiAoZG9tICYmIGRvbS5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRcXHRkb20ucmVtb3ZlQ2xhc3MoXFxcImpzdHJlZS1sb2FkaW5nXFxcIikuYXR0cignYXJpYS1idXN5JywgZmFsc2UpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRkZWxldGUgdGhpcy5fZGF0YS5tYXNzbG9hZFtvYmouaWRdO1xcblxcdFxcdFxcdFxcdHJldHVybiByc2x0O1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gcGFyZW50Ll9sb2FkX25vZGUuY2FsbCh0aGlzLCBvYmosIGNhbGxiYWNrKTtcXG5cXHRcXHR9O1xcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqICMjIyBTZWFyY2ggcGx1Z2luXFxuICAqXFxuICAqIEFkZHMgc2VhcmNoIGZ1bmN0aW9uYWxpdHkgdG8ganNUcmVlLlxcbiAgKi9cXG5cXG5cXHQvKipcXG4gICogc3RvcmVzIGFsbCBkZWZhdWx0cyBmb3IgdGhlIHNlYXJjaCBwbHVnaW5cXG4gICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuc2VhcmNoXFxuICAqIEBwbHVnaW4gc2VhcmNoXFxuICAqL1xcblxcdCQuanN0cmVlLmRlZmF1bHRzLnNlYXJjaCA9IHtcXG5cXHRcXHQvKipcXG4gICAqIGEgalF1ZXJ5LWxpa2UgQUpBWCBjb25maWcsIHdoaWNoIGpzdHJlZSB1c2VzIGlmIGEgc2VydmVyIHNob3VsZCBiZSBxdWVyaWVkIGZvciByZXN1bHRzLlxcbiAgICpcXG4gICAqIEEgYHN0cmAgKHdoaWNoIGlzIHRoZSBzZWFyY2ggc3RyaW5nKSBwYXJhbWV0ZXIgd2lsbCBiZSBhZGRlZCB3aXRoIHRoZSByZXF1ZXN0LCBhbiBvcHRpb25hbCBgaW5zaWRlYCBwYXJhbWV0ZXIgd2lsbCBiZSBhZGRlZCBpZiB0aGUgc2VhcmNoIGlzIGxpbWl0ZWQgdG8gYSBub2RlIGlkLiBUaGUgZXhwZWN0ZWQgcmVzdWx0IGlzIGEgSlNPTiBhcnJheSB3aXRoIG5vZGVzIHRoYXQgbmVlZCB0byBiZSBvcGVuZWQgc28gdGhhdCBtYXRjaGluZyBub2RlcyB3aWxsIGJlIHJldmVhbGVkLlxcbiAgICogTGVhdmUgdGhpcyBzZXR0aW5nIGFzIGBmYWxzZWAgdG8gbm90IHF1ZXJ5IHRoZSBzZXJ2ZXIuIFlvdSBjYW4gYWxzbyBzZXQgdGhpcyB0byBhIGZ1bmN0aW9uLCB3aGljaCB3aWxsIGJlIGludm9rZWQgaW4gdGhlIGluc3RhbmNlJ3Mgc2NvcGUgYW5kIHJlY2VpdmUgMyBwYXJhbWV0ZXJzIC0gdGhlIHNlYXJjaCBzdHJpbmcsIHRoZSBjYWxsYmFjayB0byBjYWxsIHdpdGggdGhlIGFycmF5IG9mIG5vZGVzIHRvIGxvYWQsIGFuZCB0aGUgb3B0aW9uYWwgbm9kZSBJRCB0byBsaW1pdCB0aGUgc2VhcmNoIHRvXFxuICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5zZWFyY2guYWpheFxcbiAgICogQHBsdWdpbiBzZWFyY2hcXG4gICAqL1xcblxcdFxcdGFqYXg6IGZhbHNlLFxcblxcdFxcdC8qKlxcbiAgICogSW5kaWNhdGVzIGlmIHRoZSBzZWFyY2ggc2hvdWxkIGJlIGZ1enp5IG9yIG5vdCAoc2hvdWxkIGBjaG5kM2AgbWF0Y2ggYGNoaWxkIG5vZGUgM2ApLiBEZWZhdWx0IGlzIGBmYWxzZWAuXFxuICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5zZWFyY2guZnV6enlcXG4gICAqIEBwbHVnaW4gc2VhcmNoXFxuICAgKi9cXG5cXHRcXHRmdXp6eTogZmFsc2UsXFxuXFx0XFx0LyoqXFxuICAgKiBJbmRpY2F0ZXMgaWYgdGhlIHNlYXJjaCBzaG91bGQgYmUgY2FzZSBzZW5zaXRpdmUuIERlZmF1bHQgaXMgYGZhbHNlYC5cXG4gICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLnNlYXJjaC5jYXNlX3NlbnNpdGl2ZVxcbiAgICogQHBsdWdpbiBzZWFyY2hcXG4gICAqL1xcblxcdFxcdGNhc2Vfc2Vuc2l0aXZlOiBmYWxzZSxcXG5cXHRcXHQvKipcXG4gICAqIEluZGljYXRlcyBpZiB0aGUgdHJlZSBzaG91bGQgYmUgZmlsdGVyZWQgKGJ5IGRlZmF1bHQpIHRvIHNob3cgb25seSBtYXRjaGluZyBub2RlcyAoa2VlcCBpbiBtaW5kIHRoaXMgY2FuIGJlIGEgaGVhdnkgb24gbGFyZ2UgdHJlZXMgaW4gb2xkIGJyb3dzZXJzKS5cXG4gICAqIFRoaXMgc2V0dGluZyBjYW4gYmUgY2hhbmdlZCBhdCBydW50aW1lIHdoZW4gY2FsbGluZyB0aGUgc2VhcmNoIG1ldGhvZC4gRGVmYXVsdCBpcyBgZmFsc2VgLlxcbiAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuc2VhcmNoLnNob3dfb25seV9tYXRjaGVzXFxuICAgKiBAcGx1Z2luIHNlYXJjaFxcbiAgICovXFxuXFx0XFx0c2hvd19vbmx5X21hdGNoZXM6IGZhbHNlLFxcblxcdFxcdC8qKlxcbiAgICogSW5kaWNhdGVzIGlmIHRoZSBjaGlsZHJlbiBvZiBtYXRjaGVkIGVsZW1lbnQgYXJlIHNob3duICh3aGVuIHNob3dfb25seV9tYXRjaGVzIGlzIHRydWUpXFxuICAgKiBUaGlzIHNldHRpbmcgY2FuIGJlIGNoYW5nZWQgYXQgcnVudGltZSB3aGVuIGNhbGxpbmcgdGhlIHNlYXJjaCBtZXRob2QuIERlZmF1bHQgaXMgYGZhbHNlYC5cXG4gICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLnNlYXJjaC5zaG93X29ubHlfbWF0Y2hlc19jaGlsZHJlblxcbiAgICogQHBsdWdpbiBzZWFyY2hcXG4gICAqL1xcblxcdFxcdHNob3dfb25seV9tYXRjaGVzX2NoaWxkcmVuOiBmYWxzZSxcXG5cXHRcXHQvKipcXG4gICAqIEluZGljYXRlcyBpZiBhbGwgbm9kZXMgb3BlbmVkIHRvIHJldmVhbCB0aGUgc2VhcmNoIHJlc3VsdCwgc2hvdWxkIGJlIGNsb3NlZCB3aGVuIHRoZSBzZWFyY2ggaXMgY2xlYXJlZCBvciBhIG5ldyBzZWFyY2ggaXMgcGVyZm9ybWVkLiBEZWZhdWx0IGlzIGB0cnVlYC5cXG4gICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLnNlYXJjaC5jbG9zZV9vcGVuZWRfb25jbGVhclxcbiAgICogQHBsdWdpbiBzZWFyY2hcXG4gICAqL1xcblxcdFxcdGNsb3NlX29wZW5lZF9vbmNsZWFyOiB0cnVlLFxcblxcdFxcdC8qKlxcbiAgICogSW5kaWNhdGVzIGlmIG9ubHkgbGVhZiBub2RlcyBzaG91bGQgYmUgaW5jbHVkZWQgaW4gc2VhcmNoIHJlc3VsdHMuIERlZmF1bHQgaXMgYGZhbHNlYC5cXG4gICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLnNlYXJjaC5zZWFyY2hfbGVhdmVzX29ubHlcXG4gICAqIEBwbHVnaW4gc2VhcmNoXFxuICAgKi9cXG5cXHRcXHRzZWFyY2hfbGVhdmVzX29ubHk6IGZhbHNlLFxcblxcdFxcdC8qKlxcbiAgICogSWYgc2V0IHRvIGEgZnVuY3Rpb24gaXQgd2lsIGJlIGNhbGxlZCBpbiB0aGUgaW5zdGFuY2UncyBzY29wZSB3aXRoIHR3byBhcmd1bWVudHMgLSBzZWFyY2ggc3RyaW5nIGFuZCBub2RlICh3aGVyZSBub2RlIHdpbGwgYmUgZXZlcnkgbm9kZSBpbiB0aGUgc3RydWN0dXJlLCBzbyB1c2Ugd2l0aCBjYXV0aW9uKS5cXG4gICAqIElmIHRoZSBmdW5jdGlvbiByZXR1cm5zIGEgdHJ1dGh5IHZhbHVlIHRoZSBub2RlIHdpbGwgYmUgY29uc2lkZXJlZCBhIG1hdGNoIChpdCBtaWdodCBub3QgYmUgZGlzcGxheWVkIGlmIHNlYXJjaF9vbmx5X2xlYXZlcyBpcyBzZXQgdG8gdHJ1ZSBhbmQgdGhlIG5vZGUgaXMgbm90IGEgbGVhZikuIERlZmF1bHQgaXMgYGZhbHNlYC5cXG4gICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLnNlYXJjaC5zZWFyY2hfY2FsbGJhY2tcXG4gICAqIEBwbHVnaW4gc2VhcmNoXFxuICAgKi9cXG5cXHRcXHRzZWFyY2hfY2FsbGJhY2s6IGZhbHNlXFxuXFx0fTtcXG5cXG5cXHQkLmpzdHJlZS5wbHVnaW5zLnNlYXJjaCA9IGZ1bmN0aW9uIChvcHRpb25zLCBwYXJlbnQpIHtcXG5cXHRcXHR0aGlzLmJpbmQgPSBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0cGFyZW50LmJpbmQuY2FsbCh0aGlzKTtcXG5cXG5cXHRcXHRcXHR0aGlzLl9kYXRhLnNlYXJjaC5zdHIgPSBcXFwiXFxcIjtcXG5cXHRcXHRcXHR0aGlzLl9kYXRhLnNlYXJjaC5kb20gPSAkKCk7XFxuXFx0XFx0XFx0dGhpcy5fZGF0YS5zZWFyY2gucmVzID0gW107XFxuXFx0XFx0XFx0dGhpcy5fZGF0YS5zZWFyY2gub3BuID0gW107XFxuXFx0XFx0XFx0dGhpcy5fZGF0YS5zZWFyY2guc29tID0gZmFsc2U7XFxuXFx0XFx0XFx0dGhpcy5fZGF0YS5zZWFyY2guc21jID0gZmFsc2U7XFxuXFx0XFx0XFx0dGhpcy5fZGF0YS5zZWFyY2guaGRuID0gW107XFxuXFxuXFx0XFx0XFx0dGhpcy5lbGVtZW50Lm9uKFxcXCJzZWFyY2guanN0cmVlXFxcIiwgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xcblxcdFxcdFxcdFxcdGlmICh0aGlzLl9kYXRhLnNlYXJjaC5zb20gJiYgZGF0YS5yZXMubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIG0gPSB0aGlzLl9tb2RlbC5kYXRhLFxcblxcdFxcdFxcdFxcdFxcdCAgICBpLFxcblxcdFxcdFxcdFxcdFxcdCAgICBqLFxcblxcdFxcdFxcdFxcdFxcdCAgICBwID0gW10sXFxuXFx0XFx0XFx0XFx0XFx0ICAgIGssXFxuXFx0XFx0XFx0XFx0XFx0ICAgIGw7XFxuXFx0XFx0XFx0XFx0XFx0Zm9yIChpID0gMCwgaiA9IGRhdGEucmVzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChtW2RhdGEucmVzW2ldXSAmJiAhbVtkYXRhLnJlc1tpXV0uc3RhdGUuaGlkZGVuKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cC5wdXNoKGRhdGEucmVzW2ldKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRwID0gcC5jb25jYXQobVtkYXRhLnJlc1tpXV0ucGFyZW50cyk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKHRoaXMuX2RhdGEuc2VhcmNoLnNtYykge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGZvciAoayA9IDAsIGwgPSBtW2RhdGEucmVzW2ldXS5jaGlsZHJlbl9kLmxlbmd0aDsgayA8IGw7IGsrKykge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChtW21bZGF0YS5yZXNbaV1dLmNoaWxkcmVuX2Rba11dICYmICFtW21bZGF0YS5yZXNbaV1dLmNoaWxkcmVuX2Rba11dLnN0YXRlLmhpZGRlbikge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHAucHVzaChtW2RhdGEucmVzW2ldXS5jaGlsZHJlbl9kW2tdKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdHAgPSAkLnZha2F0YS5hcnJheV9yZW1vdmVfaXRlbSgkLnZha2F0YS5hcnJheV91bmlxdWUocCksICQuanN0cmVlLnJvb3QpO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX2RhdGEuc2VhcmNoLmhkbiA9IHRoaXMuaGlkZV9hbGwodHJ1ZSk7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5zaG93X25vZGUocCwgdHJ1ZSk7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5yZWRyYXcodHJ1ZSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sIHRoaXMpKS5vbihcXFwiY2xlYXJfc2VhcmNoLmpzdHJlZVxcXCIsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcXG5cXHRcXHRcXHRcXHRpZiAodGhpcy5fZGF0YS5zZWFyY2guc29tICYmIGRhdGEucmVzLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuc2hvd19ub2RlKHRoaXMuX2RhdGEuc2VhcmNoLmhkbiwgdHJ1ZSk7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5yZWRyYXcodHJ1ZSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sIHRoaXMpKTtcXG5cXHRcXHR9O1xcblxcdFxcdC8qKlxcbiAgICogdXNlZCB0byBzZWFyY2ggdGhlIHRyZWUgbm9kZXMgZm9yIGEgZ2l2ZW4gc3RyaW5nXFxuICAgKiBAbmFtZSBzZWFyY2goc3RyIFssIHNraXBfYXN5bmNdKVxcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciB0aGUgc2VhcmNoIHN0cmluZ1xcbiAgICogQHBhcmFtIHtCb29sZWFufSBza2lwX2FzeW5jIGlmIHNldCB0byB0cnVlIHNlcnZlciB3aWxsIG5vdCBiZSBxdWVyaWVkIGV2ZW4gaWYgY29uZmlndXJlZFxcbiAgICogQHBhcmFtIHtCb29sZWFufSBzaG93X29ubHlfbWF0Y2hlcyBpZiBzZXQgdG8gdHJ1ZSBvbmx5IG1hdGNoaW5nIG5vZGVzIHdpbGwgYmUgc2hvd24gKGtlZXAgaW4gbWluZCB0aGlzIGNhbiBiZSB2ZXJ5IHNsb3cgb24gbGFyZ2UgdHJlZXMgb3Igb2xkIGJyb3dzZXJzKVxcbiAgICogQHBhcmFtIHttaXhlZH0gaW5zaWRlIGFuIG9wdGlvbmFsIG5vZGUgdG8gd2hvc2UgY2hpbGRyZW4gdG8gbGltaXQgdGhlIHNlYXJjaFxcbiAgICogQHBhcmFtIHtCb29sZWFufSBhcHBlbmQgaWYgc2V0IHRvIHRydWUgdGhlIHJlc3VsdHMgb2YgdGhpcyBzZWFyY2ggYXJlIGFwcGVuZGVkIHRvIHRoZSBwcmV2aW91cyBzZWFyY2hcXG4gICAqIEBwbHVnaW4gc2VhcmNoXFxuICAgKiBAdHJpZ2dlciBzZWFyY2guanN0cmVlXFxuICAgKi9cXG5cXHRcXHR0aGlzLnNlYXJjaCA9IGZ1bmN0aW9uIChzdHIsIHNraXBfYXN5bmMsIHNob3dfb25seV9tYXRjaGVzLCBpbnNpZGUsIGFwcGVuZCwgc2hvd19vbmx5X21hdGNoZXNfY2hpbGRyZW4pIHtcXG5cXHRcXHRcXHRpZiAoc3RyID09PSBmYWxzZSB8fCAkLnRyaW0oc3RyLnRvU3RyaW5nKCkpID09PSBcXFwiXFxcIikge1xcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLmNsZWFyX3NlYXJjaCgpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpbnNpZGUgPSB0aGlzLmdldF9ub2RlKGluc2lkZSk7XFxuXFx0XFx0XFx0aW5zaWRlID0gaW5zaWRlICYmIGluc2lkZS5pZCA/IGluc2lkZS5pZCA6IG51bGw7XFxuXFx0XFx0XFx0c3RyID0gc3RyLnRvU3RyaW5nKCk7XFxuXFx0XFx0XFx0dmFyIHMgPSB0aGlzLnNldHRpbmdzLnNlYXJjaCxcXG5cXHRcXHRcXHQgICAgYSA9IHMuYWpheCA/IHMuYWpheCA6IGZhbHNlLFxcblxcdFxcdFxcdCAgICBtID0gdGhpcy5fbW9kZWwuZGF0YSxcXG5cXHRcXHRcXHQgICAgZiA9IG51bGwsXFxuXFx0XFx0XFx0ICAgIHIgPSBbXSxcXG5cXHRcXHRcXHQgICAgcCA9IFtdLFxcblxcdFxcdFxcdCAgICBpLFxcblxcdFxcdFxcdCAgICBqO1xcblxcdFxcdFxcdGlmICh0aGlzLl9kYXRhLnNlYXJjaC5yZXMubGVuZ3RoICYmICFhcHBlbmQpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLmNsZWFyX3NlYXJjaCgpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoc2hvd19vbmx5X21hdGNoZXMgPT09IHVuZGVmaW5lZCkge1xcblxcdFxcdFxcdFxcdHNob3dfb25seV9tYXRjaGVzID0gcy5zaG93X29ubHlfbWF0Y2hlcztcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKHNob3dfb25seV9tYXRjaGVzX2NoaWxkcmVuID09PSB1bmRlZmluZWQpIHtcXG5cXHRcXHRcXHRcXHRzaG93X29ubHlfbWF0Y2hlc19jaGlsZHJlbiA9IHMuc2hvd19vbmx5X21hdGNoZXNfY2hpbGRyZW47XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICghc2tpcF9hc3luYyAmJiBhICE9PSBmYWxzZSkge1xcblxcdFxcdFxcdFxcdGlmICgkLmlzRnVuY3Rpb24oYSkpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gYS5jYWxsKHRoaXMsIHN0ciwgJC5wcm94eShmdW5jdGlvbiAoZCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChkICYmIGQuZCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGQgPSBkLmQ7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuX2xvYWRfbm9kZXMoISQuaXNBcnJheShkKSA/IFtdIDogJC52YWthdGEuYXJyYXlfdW5pcXVlKGQpLCBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5zZWFyY2goc3RyLCB0cnVlLCBzaG93X29ubHlfbWF0Y2hlcywgaW5zaWRlLCBhcHBlbmQsIHNob3dfb25seV9tYXRjaGVzX2NoaWxkcmVuKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcXHRcXHR9LCB0aGlzKSwgaW5zaWRlKTtcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdGEgPSAkLmV4dGVuZCh7fSwgYSk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCFhLmRhdGEpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRhLmRhdGEgPSB7fTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0YS5kYXRhLnN0ciA9IHN0cjtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoaW5zaWRlKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YS5kYXRhLmluc2lkZSA9IGluc2lkZTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHRoaXMuX2RhdGEuc2VhcmNoLmxhc3RSZXF1ZXN0KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5fZGF0YS5zZWFyY2gubGFzdFJlcXVlc3QuYWJvcnQoKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fZGF0YS5zZWFyY2gubGFzdFJlcXVlc3QgPSAkLmFqYXgoYSkuZmFpbCgkLnByb3h5KGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvciA9IHsgJ2Vycm9yJzogJ2FqYXgnLCAncGx1Z2luJzogJ3NlYXJjaCcsICdpZCc6ICdzZWFyY2hfMDEnLCAncmVhc29uJzogJ0NvdWxkIG5vdCBsb2FkIHNlYXJjaCBwYXJlbnRzJywgJ2RhdGEnOiBKU09OLnN0cmluZ2lmeShhKSB9O1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuc2V0dGluZ3MuY29yZS5lcnJvci5jYWxsKHRoaXMsIHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yKTtcXG5cXHRcXHRcXHRcXHRcXHR9LCB0aGlzKSkuZG9uZSgkLnByb3h5KGZ1bmN0aW9uIChkKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKGQgJiYgZC5kKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZCA9IGQuZDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5fbG9hZF9ub2RlcyghJC5pc0FycmF5KGQpID8gW10gOiAkLnZha2F0YS5hcnJheV91bmlxdWUoZCksIGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLnNlYXJjaChzdHIsIHRydWUsIHNob3dfb25seV9tYXRjaGVzLCBpbnNpZGUsIGFwcGVuZCwgc2hvd19vbmx5X21hdGNoZXNfY2hpbGRyZW4pO1xcblxcdFxcdFxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdFxcdFxcdH0sIHRoaXMpKTtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5fZGF0YS5zZWFyY2gubGFzdFJlcXVlc3Q7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoIWFwcGVuZCkge1xcblxcdFxcdFxcdFxcdHRoaXMuX2RhdGEuc2VhcmNoLnN0ciA9IHN0cjtcXG5cXHRcXHRcXHRcXHR0aGlzLl9kYXRhLnNlYXJjaC5kb20gPSAkKCk7XFxuXFx0XFx0XFx0XFx0dGhpcy5fZGF0YS5zZWFyY2gucmVzID0gW107XFxuXFx0XFx0XFx0XFx0dGhpcy5fZGF0YS5zZWFyY2gub3BuID0gW107XFxuXFx0XFx0XFx0XFx0dGhpcy5fZGF0YS5zZWFyY2guc29tID0gc2hvd19vbmx5X21hdGNoZXM7XFxuXFx0XFx0XFx0XFx0dGhpcy5fZGF0YS5zZWFyY2guc21jID0gc2hvd19vbmx5X21hdGNoZXNfY2hpbGRyZW47XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGYgPSBuZXcgJC52YWthdGEuc2VhcmNoKHN0ciwgdHJ1ZSwgeyBjYXNlU2Vuc2l0aXZlOiBzLmNhc2Vfc2Vuc2l0aXZlLCBmdXp6eTogcy5mdXp6eSB9KTtcXG5cXHRcXHRcXHQkLmVhY2gobVtpbnNpZGUgPyBpbnNpZGUgOiAkLmpzdHJlZS5yb290XS5jaGlsZHJlbl9kLCBmdW5jdGlvbiAoaWksIGkpIHtcXG5cXHRcXHRcXHRcXHR2YXIgdiA9IG1baV07XFxuXFx0XFx0XFx0XFx0aWYgKHYudGV4dCAmJiAhdi5zdGF0ZS5oaWRkZW4gJiYgKCFzLnNlYXJjaF9sZWF2ZXNfb25seSB8fCB2LnN0YXRlLmxvYWRlZCAmJiB2LmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkgJiYgKHMuc2VhcmNoX2NhbGxiYWNrICYmIHMuc2VhcmNoX2NhbGxiYWNrLmNhbGwodGhpcywgc3RyLCB2KSB8fCAhcy5zZWFyY2hfY2FsbGJhY2sgJiYgZi5zZWFyY2godi50ZXh0KS5pc01hdGNoKSkge1xcblxcdFxcdFxcdFxcdFxcdHIucHVzaChpKTtcXG5cXHRcXHRcXHRcXHRcXHRwID0gcC5jb25jYXQodi5wYXJlbnRzKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0aWYgKHIubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0cCA9ICQudmFrYXRhLmFycmF5X3VuaXF1ZShwKTtcXG5cXHRcXHRcXHRcXHRmb3IgKGkgPSAwLCBqID0gcC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAocFtpXSAhPT0gJC5qc3RyZWUucm9vdCAmJiBtW3BbaV1dICYmIHRoaXMub3Blbl9ub2RlKHBbaV0sIG51bGwsIDApID09PSB0cnVlKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5fZGF0YS5zZWFyY2gub3BuLnB1c2gocFtpXSk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRpZiAoIWFwcGVuZCkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX2RhdGEuc2VhcmNoLmRvbSA9ICQodGhpcy5lbGVtZW50WzBdLnF1ZXJ5U2VsZWN0b3JBbGwoJyMnICsgJC5tYXAociwgZnVuY3Rpb24gKHYpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gXFxcIjAxMjM0NTY3ODlcXFwiLmluZGV4T2YodlswXSkgIT09IC0xID8gJ1xcXFxcXFxcMycgKyB2WzBdICsgJyAnICsgdi5zdWJzdHIoMSkucmVwbGFjZSgkLmpzdHJlZS5pZHJlZ2V4LCAnXFxcXFxcXFwkJicpIDogdi5yZXBsYWNlKCQuanN0cmVlLmlkcmVnZXgsICdcXFxcXFxcXCQmJyk7XFxuXFx0XFx0XFx0XFx0XFx0fSkuam9pbignLCAjJykpKTtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9kYXRhLnNlYXJjaC5yZXMgPSByO1xcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fZGF0YS5zZWFyY2guZG9tID0gdGhpcy5fZGF0YS5zZWFyY2guZG9tLmFkZCgkKHRoaXMuZWxlbWVudFswXS5xdWVyeVNlbGVjdG9yQWxsKCcjJyArICQubWFwKHIsIGZ1bmN0aW9uICh2KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIFxcXCIwMTIzNDU2Nzg5XFxcIi5pbmRleE9mKHZbMF0pICE9PSAtMSA/ICdcXFxcXFxcXDMnICsgdlswXSArICcgJyArIHYuc3Vic3RyKDEpLnJlcGxhY2UoJC5qc3RyZWUuaWRyZWdleCwgJ1xcXFxcXFxcJCYnKSA6IHYucmVwbGFjZSgkLmpzdHJlZS5pZHJlZ2V4LCAnXFxcXFxcXFwkJicpO1xcblxcdFxcdFxcdFxcdFxcdH0pLmpvaW4oJywgIycpKSkpO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX2RhdGEuc2VhcmNoLnJlcyA9ICQudmFrYXRhLmFycmF5X3VuaXF1ZSh0aGlzLl9kYXRhLnNlYXJjaC5yZXMuY29uY2F0KHIpKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0dGhpcy5fZGF0YS5zZWFyY2guZG9tLmNoaWxkcmVuKFxcXCIuanN0cmVlLWFuY2hvclxcXCIpLmFkZENsYXNzKCdqc3RyZWUtc2VhcmNoJyk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdC8qKlxcbiAgICAqIHRyaWdnZXJlZCBhZnRlciBzZWFyY2ggaXMgY29tcGxldGVcXG4gICAgKiBAZXZlbnRcXG4gICAgKiBAbmFtZSBzZWFyY2guanN0cmVlXFxuICAgICogQHBhcmFtIHtqUXVlcnl9IG5vZGVzIGEgalF1ZXJ5IGNvbGxlY3Rpb24gb2YgbWF0Y2hpbmcgbm9kZXNcXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIHRoZSBzZWFyY2ggc3RyaW5nXFxuICAgICogQHBhcmFtIHtBcnJheX0gcmVzIGEgY29sbGVjdGlvbiBvZiBvYmplY3RzIHJlcHJlc2VpbmcgdGhlIG1hdGNoaW5nIG5vZGVzXFxuICAgICogQHBsdWdpbiBzZWFyY2hcXG4gICAgKi9cXG5cXHRcXHRcXHR0aGlzLnRyaWdnZXIoJ3NlYXJjaCcsIHsgbm9kZXM6IHRoaXMuX2RhdGEuc2VhcmNoLmRvbSwgc3RyOiBzdHIsIHJlczogdGhpcy5fZGF0YS5zZWFyY2gucmVzLCBzaG93X29ubHlfbWF0Y2hlczogc2hvd19vbmx5X21hdGNoZXMgfSk7XFxuXFx0XFx0fTtcXG5cXHRcXHQvKipcXG4gICAqIHVzZWQgdG8gY2xlYXIgdGhlIGxhc3Qgc2VhcmNoIChyZW1vdmVzIGNsYXNzZXMgYW5kIHNob3dzIGFsbCBub2RlcyBpZiBmaWx0ZXJpbmcgaXMgb24pXFxuICAgKiBAbmFtZSBjbGVhcl9zZWFyY2goKVxcbiAgICogQHBsdWdpbiBzZWFyY2hcXG4gICAqIEB0cmlnZ2VyIGNsZWFyX3NlYXJjaC5qc3RyZWVcXG4gICAqL1xcblxcdFxcdHRoaXMuY2xlYXJfc2VhcmNoID0gZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdGlmICh0aGlzLnNldHRpbmdzLnNlYXJjaC5jbG9zZV9vcGVuZWRfb25jbGVhcikge1xcblxcdFxcdFxcdFxcdHRoaXMuY2xvc2Vfbm9kZSh0aGlzLl9kYXRhLnNlYXJjaC5vcG4sIDApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHQvKipcXG4gICAgKiB0cmlnZ2VyZWQgYWZ0ZXIgc2VhcmNoIGlzIGNvbXBsZXRlXFxuICAgICogQGV2ZW50XFxuICAgICogQG5hbWUgY2xlYXJfc2VhcmNoLmpzdHJlZVxcbiAgICAqIEBwYXJhbSB7alF1ZXJ5fSBub2RlcyBhIGpRdWVyeSBjb2xsZWN0aW9uIG9mIG1hdGNoaW5nIG5vZGVzICh0aGUgcmVzdWx0IGZyb20gdGhlIGxhc3Qgc2VhcmNoKVxcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgdGhlIHNlYXJjaCBzdHJpbmcgKHRoZSBsYXN0IHNlYXJjaCBzdHJpbmcpXFxuICAgICogQHBhcmFtIHtBcnJheX0gcmVzIGEgY29sbGVjdGlvbiBvZiBvYmplY3RzIHJlcHJlc2VpbmcgdGhlIG1hdGNoaW5nIG5vZGVzICh0aGUgcmVzdWx0IGZyb20gdGhlIGxhc3Qgc2VhcmNoKVxcbiAgICAqIEBwbHVnaW4gc2VhcmNoXFxuICAgICovXFxuXFx0XFx0XFx0dGhpcy50cmlnZ2VyKCdjbGVhcl9zZWFyY2gnLCB7ICdub2Rlcyc6IHRoaXMuX2RhdGEuc2VhcmNoLmRvbSwgc3RyOiB0aGlzLl9kYXRhLnNlYXJjaC5zdHIsIHJlczogdGhpcy5fZGF0YS5zZWFyY2gucmVzIH0pO1xcblxcdFxcdFxcdGlmICh0aGlzLl9kYXRhLnNlYXJjaC5yZXMubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5fZGF0YS5zZWFyY2guZG9tID0gJCh0aGlzLmVsZW1lbnRbMF0ucXVlcnlTZWxlY3RvckFsbCgnIycgKyAkLm1hcCh0aGlzLl9kYXRhLnNlYXJjaC5yZXMsIGZ1bmN0aW9uICh2KSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIFxcXCIwMTIzNDU2Nzg5XFxcIi5pbmRleE9mKHZbMF0pICE9PSAtMSA/ICdcXFxcXFxcXDMnICsgdlswXSArICcgJyArIHYuc3Vic3RyKDEpLnJlcGxhY2UoJC5qc3RyZWUuaWRyZWdleCwgJ1xcXFxcXFxcJCYnKSA6IHYucmVwbGFjZSgkLmpzdHJlZS5pZHJlZ2V4LCAnXFxcXFxcXFwkJicpO1xcblxcdFxcdFxcdFxcdH0pLmpvaW4oJywgIycpKSk7XFxuXFx0XFx0XFx0XFx0dGhpcy5fZGF0YS5zZWFyY2guZG9tLmNoaWxkcmVuKFxcXCIuanN0cmVlLWFuY2hvclxcXCIpLnJlbW92ZUNsYXNzKFxcXCJqc3RyZWUtc2VhcmNoXFxcIik7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHRoaXMuX2RhdGEuc2VhcmNoLnN0ciA9IFxcXCJcXFwiO1xcblxcdFxcdFxcdHRoaXMuX2RhdGEuc2VhcmNoLnJlcyA9IFtdO1xcblxcdFxcdFxcdHRoaXMuX2RhdGEuc2VhcmNoLm9wbiA9IFtdO1xcblxcdFxcdFxcdHRoaXMuX2RhdGEuc2VhcmNoLmRvbSA9ICQoKTtcXG5cXHRcXHR9O1xcblxcblxcdFxcdHRoaXMucmVkcmF3X25vZGUgPSBmdW5jdGlvbiAob2JqLCBkZWVwLCBjYWxsYmFjaywgZm9yY2VfcmVuZGVyKSB7XFxuXFx0XFx0XFx0b2JqID0gcGFyZW50LnJlZHJhd19ub2RlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuXFx0XFx0XFx0aWYgKG9iaikge1xcblxcdFxcdFxcdFxcdGlmICgkLmluQXJyYXkob2JqLmlkLCB0aGlzLl9kYXRhLnNlYXJjaC5yZXMpICE9PSAtMSkge1xcblxcdFxcdFxcdFxcdFxcdHZhciBpLFxcblxcdFxcdFxcdFxcdFxcdCAgICBqLFxcblxcdFxcdFxcdFxcdFxcdCAgICB0bXAgPSBudWxsO1xcblxcdFxcdFxcdFxcdFxcdGZvciAoaSA9IDAsIGogPSBvYmouY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAob2JqLmNoaWxkTm9kZXNbaV0gJiYgb2JqLmNoaWxkTm9kZXNbaV0uY2xhc3NOYW1lICYmIG9iai5jaGlsZE5vZGVzW2ldLmNsYXNzTmFtZS5pbmRleE9mKFxcXCJqc3RyZWUtYW5jaG9yXFxcIikgIT09IC0xKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dG1wID0gb2JqLmNoaWxkTm9kZXNbaV07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRpZiAodG1wKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dG1wLmNsYXNzTmFtZSArPSAnIGpzdHJlZS1zZWFyY2gnO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiBvYmo7XFxuXFx0XFx0fTtcXG5cXHR9O1xcblxcblxcdC8vIGhlbHBlcnNcXG5cXHQoZnVuY3Rpb24gKCQpIHtcXG5cXHRcXHQvLyBmcm9tIGh0dHA6Ly9raXJvLm1lL3Byb2plY3RzL2Z1c2UuaHRtbFxcblxcdFxcdCQudmFrYXRhLnNlYXJjaCA9IGZ1bmN0aW9uIChwYXR0ZXJuLCB0eHQsIG9wdGlvbnMpIHtcXG5cXHRcXHRcXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcXG5cXHRcXHRcXHRvcHRpb25zID0gJC5leHRlbmQoe30sICQudmFrYXRhLnNlYXJjaC5kZWZhdWx0cywgb3B0aW9ucyk7XFxuXFx0XFx0XFx0aWYgKG9wdGlvbnMuZnV6enkgIT09IGZhbHNlKSB7XFxuXFx0XFx0XFx0XFx0b3B0aW9ucy5mdXp6eSA9IHRydWU7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHBhdHRlcm4gPSBvcHRpb25zLmNhc2VTZW5zaXRpdmUgPyBwYXR0ZXJuIDogcGF0dGVybi50b0xvd2VyQ2FzZSgpO1xcblxcdFxcdFxcdHZhciBNQVRDSF9MT0NBVElPTiA9IG9wdGlvbnMubG9jYXRpb24sXFxuXFx0XFx0XFx0ICAgIE1BVENIX0RJU1RBTkNFID0gb3B0aW9ucy5kaXN0YW5jZSxcXG5cXHRcXHRcXHQgICAgTUFUQ0hfVEhSRVNIT0xEID0gb3B0aW9ucy50aHJlc2hvbGQsXFxuXFx0XFx0XFx0ICAgIHBhdHRlcm5MZW4gPSBwYXR0ZXJuLmxlbmd0aCxcXG5cXHRcXHRcXHQgICAgbWF0Y2htYXNrLFxcblxcdFxcdFxcdCAgICBwYXR0ZXJuX2FscGhhYmV0LFxcblxcdFxcdFxcdCAgICBtYXRjaF9iaXRhcFNjb3JlLFxcblxcdFxcdFxcdCAgICBzZWFyY2g7XFxuXFx0XFx0XFx0aWYgKHBhdHRlcm5MZW4gPiAzMikge1xcblxcdFxcdFxcdFxcdG9wdGlvbnMuZnV6enkgPSBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKG9wdGlvbnMuZnV6enkpIHtcXG5cXHRcXHRcXHRcXHRtYXRjaG1hc2sgPSAxIDw8IHBhdHRlcm5MZW4gLSAxO1xcblxcdFxcdFxcdFxcdHBhdHRlcm5fYWxwaGFiZXQgPSBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIG1hc2sgPSB7fSxcXG5cXHRcXHRcXHRcXHRcXHQgICAgaSA9IDA7XFxuXFx0XFx0XFx0XFx0XFx0Zm9yIChpID0gMDsgaSA8IHBhdHRlcm5MZW47IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdFxcdG1hc2tbcGF0dGVybi5jaGFyQXQoaSldID0gMDtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0Zm9yIChpID0gMDsgaSA8IHBhdHRlcm5MZW47IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdFxcdG1hc2tbcGF0dGVybi5jaGFyQXQoaSldIHw9IDEgPDwgcGF0dGVybkxlbiAtIGkgLSAxO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gbWFzaztcXG5cXHRcXHRcXHRcXHR9KCk7XFxuXFx0XFx0XFx0XFx0bWF0Y2hfYml0YXBTY29yZSA9IGZ1bmN0aW9uIG1hdGNoX2JpdGFwU2NvcmUoZSwgeCkge1xcblxcdFxcdFxcdFxcdFxcdHZhciBhY2N1cmFjeSA9IGUgLyBwYXR0ZXJuTGVuLFxcblxcdFxcdFxcdFxcdFxcdCAgICBwcm94aW1pdHkgPSBNYXRoLmFicyhNQVRDSF9MT0NBVElPTiAtIHgpO1xcblxcdFxcdFxcdFxcdFxcdGlmICghTUFUQ0hfRElTVEFOQ0UpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gcHJveGltaXR5ID8gMS4wIDogYWNjdXJhY3k7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBhY2N1cmFjeSArIHByb3hpbWl0eSAvIE1BVENIX0RJU1RBTkNFO1xcblxcdFxcdFxcdFxcdH07XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHNlYXJjaCA9IGZ1bmN0aW9uIHNlYXJjaCh0ZXh0KSB7XFxuXFx0XFx0XFx0XFx0dGV4dCA9IG9wdGlvbnMuY2FzZVNlbnNpdGl2ZSA/IHRleHQgOiB0ZXh0LnRvTG93ZXJDYXNlKCk7XFxuXFx0XFx0XFx0XFx0aWYgKHBhdHRlcm4gPT09IHRleHQgfHwgdGV4dC5pbmRleE9mKHBhdHRlcm4pICE9PSAtMSkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aXNNYXRjaDogdHJ1ZSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRzY29yZTogMFxcblxcdFxcdFxcdFxcdFxcdH07XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGlmICghb3B0aW9ucy5mdXp6eSkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aXNNYXRjaDogZmFsc2UsXFxuXFx0XFx0XFx0XFx0XFx0XFx0c2NvcmU6IDFcXG5cXHRcXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR2YXIgaSxcXG5cXHRcXHRcXHRcXHQgICAgaixcXG5cXHRcXHRcXHRcXHQgICAgdGV4dExlbiA9IHRleHQubGVuZ3RoLFxcblxcdFxcdFxcdFxcdCAgICBzY29yZVRocmVzaG9sZCA9IE1BVENIX1RIUkVTSE9MRCxcXG5cXHRcXHRcXHRcXHQgICAgYmVzdExvYyA9IHRleHQuaW5kZXhPZihwYXR0ZXJuLCBNQVRDSF9MT0NBVElPTiksXFxuXFx0XFx0XFx0XFx0ICAgIGJpbk1pbixcXG5cXHRcXHRcXHRcXHQgICAgYmluTWlkLFxcblxcdFxcdFxcdFxcdCAgICBiaW5NYXggPSBwYXR0ZXJuTGVuICsgdGV4dExlbixcXG5cXHRcXHRcXHRcXHQgICAgbGFzdFJkLFxcblxcdFxcdFxcdFxcdCAgICBzdGFydCxcXG5cXHRcXHRcXHRcXHQgICAgZmluaXNoLFxcblxcdFxcdFxcdFxcdCAgICByZCxcXG5cXHRcXHRcXHRcXHQgICAgY2hhck1hdGNoLFxcblxcdFxcdFxcdFxcdCAgICBzY29yZSA9IDEsXFxuXFx0XFx0XFx0XFx0ICAgIGxvY2F0aW9ucyA9IFtdO1xcblxcdFxcdFxcdFxcdGlmIChiZXN0TG9jICE9PSAtMSkge1xcblxcdFxcdFxcdFxcdFxcdHNjb3JlVGhyZXNob2xkID0gTWF0aC5taW4obWF0Y2hfYml0YXBTY29yZSgwLCBiZXN0TG9jKSwgc2NvcmVUaHJlc2hvbGQpO1xcblxcdFxcdFxcdFxcdFxcdGJlc3RMb2MgPSB0ZXh0Lmxhc3RJbmRleE9mKHBhdHRlcm4sIE1BVENIX0xPQ0FUSU9OICsgcGF0dGVybkxlbik7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGJlc3RMb2MgIT09IC0xKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0c2NvcmVUaHJlc2hvbGQgPSBNYXRoLm1pbihtYXRjaF9iaXRhcFNjb3JlKDAsIGJlc3RMb2MpLCBzY29yZVRocmVzaG9sZCk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRiZXN0TG9jID0gLTE7XFxuXFx0XFx0XFx0XFx0Zm9yIChpID0gMDsgaSA8IHBhdHRlcm5MZW47IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdGJpbk1pbiA9IDA7XFxuXFx0XFx0XFx0XFx0XFx0YmluTWlkID0gYmluTWF4O1xcblxcdFxcdFxcdFxcdFxcdHdoaWxlIChiaW5NaW4gPCBiaW5NaWQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAobWF0Y2hfYml0YXBTY29yZShpLCBNQVRDSF9MT0NBVElPTiArIGJpbk1pZCkgPD0gc2NvcmVUaHJlc2hvbGQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRiaW5NaW4gPSBiaW5NaWQ7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRiaW5NYXggPSBiaW5NaWQ7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdGJpbk1pZCA9IE1hdGguZmxvb3IoKGJpbk1heCAtIGJpbk1pbikgLyAyICsgYmluTWluKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0YmluTWF4ID0gYmluTWlkO1xcblxcdFxcdFxcdFxcdFxcdHN0YXJ0ID0gTWF0aC5tYXgoMSwgTUFUQ0hfTE9DQVRJT04gLSBiaW5NaWQgKyAxKTtcXG5cXHRcXHRcXHRcXHRcXHRmaW5pc2ggPSBNYXRoLm1pbihNQVRDSF9MT0NBVElPTiArIGJpbk1pZCwgdGV4dExlbikgKyBwYXR0ZXJuTGVuO1xcblxcdFxcdFxcdFxcdFxcdHJkID0gbmV3IEFycmF5KGZpbmlzaCArIDIpO1xcblxcdFxcdFxcdFxcdFxcdHJkW2ZpbmlzaCArIDFdID0gKDEgPDwgaSkgLSAxO1xcblxcdFxcdFxcdFxcdFxcdGZvciAoaiA9IGZpbmlzaDsgaiA+PSBzdGFydDsgai0tKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2hhck1hdGNoID0gcGF0dGVybl9hbHBoYWJldFt0ZXh0LmNoYXJBdChqIC0gMSldO1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChpID09PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmRbal0gPSAocmRbaiArIDFdIDw8IDEgfCAxKSAmIGNoYXJNYXRjaDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJkW2pdID0gKHJkW2ogKyAxXSA8PCAxIHwgMSkgJiBjaGFyTWF0Y2ggfCAoKGxhc3RSZFtqICsgMV0gfCBsYXN0UmRbal0pIDw8IDEgfCAxKSB8IGxhc3RSZFtqICsgMV07XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChyZFtqXSAmIG1hdGNobWFzaykge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHNjb3JlID0gbWF0Y2hfYml0YXBTY29yZShpLCBqIC0gMSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKHNjb3JlIDw9IHNjb3JlVGhyZXNob2xkKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0c2NvcmVUaHJlc2hvbGQgPSBzY29yZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRiZXN0TG9jID0gaiAtIDE7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bG9jYXRpb25zLnB1c2goYmVzdExvYyk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKGJlc3RMb2MgPiBNQVRDSF9MT0NBVElPTikge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHN0YXJ0ID0gTWF0aC5tYXgoMSwgMiAqIE1BVENIX0xPQ0FUSU9OIC0gYmVzdExvYyk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aWYgKG1hdGNoX2JpdGFwU2NvcmUoaSArIDEsIE1BVENIX0xPQ0FUSU9OKSA+IHNjb3JlVGhyZXNob2xkKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGxhc3RSZCA9IHJkO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRyZXR1cm4ge1xcblxcdFxcdFxcdFxcdFxcdGlzTWF0Y2g6IGJlc3RMb2MgPj0gMCxcXG5cXHRcXHRcXHRcXHRcXHRzY29yZTogc2NvcmVcXG5cXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdH07XFxuXFx0XFx0XFx0cmV0dXJuIHR4dCA9PT0gdHJ1ZSA/IHsgJ3NlYXJjaCc6IHNlYXJjaCB9IDogc2VhcmNoKHR4dCk7XFxuXFx0XFx0fTtcXG5cXHRcXHQkLnZha2F0YS5zZWFyY2guZGVmYXVsdHMgPSB7XFxuXFx0XFx0XFx0bG9jYXRpb246IDAsXFxuXFx0XFx0XFx0ZGlzdGFuY2U6IDEwMCxcXG5cXHRcXHRcXHR0aHJlc2hvbGQ6IDAuNixcXG5cXHRcXHRcXHRmdXp6eTogZmFsc2UsXFxuXFx0XFx0XFx0Y2FzZVNlbnNpdGl2ZTogZmFsc2VcXG5cXHRcXHR9O1xcblxcdH0pKCQpO1xcblxcblxcdC8vIGluY2x1ZGUgdGhlIHNlYXJjaCBwbHVnaW4gYnkgZGVmYXVsdFxcblxcdC8vICQuanN0cmVlLmRlZmF1bHRzLnBsdWdpbnMucHVzaChcXFwic2VhcmNoXFxcIik7XFxuXFxuXFxuXFx0LyoqXFxuICAqICMjIyBTb3J0IHBsdWdpblxcbiAgKlxcbiAgKiBBdXRvbWF0aWNhbGx5IHNvcnRzIGFsbCBzaWJsaW5ncyBpbiB0aGUgdHJlZSBhY2NvcmRpbmcgdG8gYSBzb3J0aW5nIGZ1bmN0aW9uLlxcbiAgKi9cXG5cXG5cXHQvKipcXG4gICogdGhlIHNldHRpbmdzIGZ1bmN0aW9uIHVzZWQgdG8gc29ydCB0aGUgbm9kZXMuXFxuICAqIEl0IGlzIGV4ZWN1dGVkIGluIHRoZSB0cmVlJ3MgY29udGV4dCwgYWNjZXB0cyB0d28gbm9kZXMgYXMgYXJndW1lbnRzIGFuZCBzaG91bGQgcmV0dXJuIGAxYCBvciBgLTFgLlxcbiAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5zb3J0XFxuICAqIEBwbHVnaW4gc29ydFxcbiAgKi9cXG5cXHQkLmpzdHJlZS5kZWZhdWx0cy5zb3J0ID0gZnVuY3Rpb24gKGEsIGIpIHtcXG5cXHRcXHQvL3JldHVybiB0aGlzLmdldF90eXBlKGEpID09PSB0aGlzLmdldF90eXBlKGIpID8gKHRoaXMuZ2V0X3RleHQoYSkgPiB0aGlzLmdldF90ZXh0KGIpID8gMSA6IC0xKSA6IHRoaXMuZ2V0X3R5cGUoYSkgPj0gdGhpcy5nZXRfdHlwZShiKTtcXG5cXHRcXHRyZXR1cm4gdGhpcy5nZXRfdGV4dChhKSA+IHRoaXMuZ2V0X3RleHQoYikgPyAxIDogLTE7XFxuXFx0fTtcXG5cXHQkLmpzdHJlZS5wbHVnaW5zLnNvcnQgPSBmdW5jdGlvbiAob3B0aW9ucywgcGFyZW50KSB7XFxuXFx0XFx0dGhpcy5iaW5kID0gZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdHBhcmVudC5iaW5kLmNhbGwodGhpcyk7XFxuXFx0XFx0XFx0dGhpcy5lbGVtZW50Lm9uKFxcXCJtb2RlbC5qc3RyZWVcXFwiLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5zb3J0KGRhdGEucGFyZW50LCB0cnVlKTtcXG5cXHRcXHRcXHR9LCB0aGlzKSkub24oXFxcInJlbmFtZV9ub2RlLmpzdHJlZSBjcmVhdGVfbm9kZS5qc3RyZWVcXFwiLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5zb3J0KGRhdGEucGFyZW50IHx8IGRhdGEubm9kZS5wYXJlbnQsIGZhbHNlKTtcXG5cXHRcXHRcXHRcXHR0aGlzLnJlZHJhd19ub2RlKGRhdGEucGFyZW50IHx8IGRhdGEubm9kZS5wYXJlbnQsIHRydWUpO1xcblxcdFxcdFxcdH0sIHRoaXMpKS5vbihcXFwibW92ZV9ub2RlLmpzdHJlZSBjb3B5X25vZGUuanN0cmVlXFxcIiwgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xcblxcdFxcdFxcdFxcdHRoaXMuc29ydChkYXRhLnBhcmVudCwgZmFsc2UpO1xcblxcdFxcdFxcdFxcdHRoaXMucmVkcmF3X25vZGUoZGF0YS5wYXJlbnQsIHRydWUpO1xcblxcdFxcdFxcdH0sIHRoaXMpKTtcXG5cXHRcXHR9O1xcblxcdFxcdC8qKlxcbiAgICogdXNlZCB0byBzb3J0IGEgbm9kZSdzIGNoaWxkcmVuXFxuICAgKiBAcHJpdmF0ZVxcbiAgICogQG5hbWUgc29ydChvYmogWywgZGVlcF0pXFxuICAgKiBAcGFyYW0gIHttaXhlZH0gb2JqIHRoZSBub2RlXFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRlZXAgaWYgc2V0IHRvIGB0cnVlYCBub2RlcyBhcmUgc29ydGVkIHJlY3Vyc2l2ZWx5LlxcbiAgICogQHBsdWdpbiBzb3J0XFxuICAgKiBAdHJpZ2dlciBzZWFyY2guanN0cmVlXFxuICAgKi9cXG5cXHRcXHR0aGlzLnNvcnQgPSBmdW5jdGlvbiAob2JqLCBkZWVwKSB7XFxuXFx0XFx0XFx0dmFyIGksIGo7XFxuXFx0XFx0XFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xcblxcdFxcdFxcdGlmIChvYmogJiYgb2JqLmNoaWxkcmVuICYmIG9iai5jaGlsZHJlbi5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRvYmouY2hpbGRyZW4uc29ydCgkLnByb3h5KHRoaXMuc2V0dGluZ3Muc29ydCwgdGhpcykpO1xcblxcdFxcdFxcdFxcdGlmIChkZWVwKSB7XFxuXFx0XFx0XFx0XFx0XFx0Zm9yIChpID0gMCwgaiA9IG9iai5jaGlsZHJlbl9kLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuc29ydChvYmouY2hpbGRyZW5fZFtpXSwgZmFsc2UpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH07XFxuXFx0fTtcXG5cXG5cXHQvLyBpbmNsdWRlIHRoZSBzb3J0IHBsdWdpbiBieSBkZWZhdWx0XFxuXFx0Ly8gJC5qc3RyZWUuZGVmYXVsdHMucGx1Z2lucy5wdXNoKFxcXCJzb3J0XFxcIik7XFxuXFxuXFx0LyoqXFxuICAqICMjIyBTdGF0ZSBwbHVnaW5cXG4gICpcXG4gICogU2F2ZXMgdGhlIHN0YXRlIG9mIHRoZSB0cmVlIChzZWxlY3RlZCBub2Rlcywgb3BlbmVkIG5vZGVzKSBvbiB0aGUgdXNlcidzIGNvbXB1dGVyIHVzaW5nIGF2YWlsYWJsZSBvcHRpb25zIChsb2NhbFN0b3JhZ2UsIGNvb2tpZXMsIGV0YylcXG4gICovXFxuXFxuXFx0dmFyIHRvID0gZmFsc2U7XFxuXFx0LyoqXFxuICAqIHN0b3JlcyBhbGwgZGVmYXVsdHMgZm9yIHRoZSBzdGF0ZSBwbHVnaW5cXG4gICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuc3RhdGVcXG4gICogQHBsdWdpbiBzdGF0ZVxcbiAgKi9cXG5cXHQkLmpzdHJlZS5kZWZhdWx0cy5zdGF0ZSA9IHtcXG5cXHRcXHQvKipcXG4gICAqIEEgc3RyaW5nIGZvciB0aGUga2V5IHRvIHVzZSB3aGVuIHNhdmluZyB0aGUgY3VycmVudCB0cmVlIChjaGFuZ2UgaWYgdXNpbmcgbXVsdGlwbGUgdHJlZXMgaW4geW91ciBwcm9qZWN0KS4gRGVmYXVsdHMgdG8gYGpzdHJlZWAuXFxuICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5zdGF0ZS5rZXlcXG4gICAqIEBwbHVnaW4gc3RhdGVcXG4gICAqL1xcblxcdFxcdGtleTogJ2pzdHJlZScsXFxuXFx0XFx0LyoqXFxuICAgKiBBIHNwYWNlIHNlcGFyYXRlZCBsaXN0IG9mIGV2ZW50cyB0aGF0IHRyaWdnZXIgYSBzdGF0ZSBzYXZlLiBEZWZhdWx0cyB0byBgY2hhbmdlZC5qc3RyZWUgb3Blbl9ub2RlLmpzdHJlZSBjbG9zZV9ub2RlLmpzdHJlZWAuXFxuICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5zdGF0ZS5ldmVudHNcXG4gICAqIEBwbHVnaW4gc3RhdGVcXG4gICAqL1xcblxcdFxcdGV2ZW50czogJ2NoYW5nZWQuanN0cmVlIG9wZW5fbm9kZS5qc3RyZWUgY2xvc2Vfbm9kZS5qc3RyZWUgY2hlY2tfbm9kZS5qc3RyZWUgdW5jaGVja19ub2RlLmpzdHJlZScsXFxuXFx0XFx0LyoqXFxuICAgKiBUaW1lIGluIG1pbGxpc2Vjb25kcyBhZnRlciB3aGljaCB0aGUgc3RhdGUgd2lsbCBleHBpcmUuIERlZmF1bHRzIHRvICdmYWxzZScgbWVhbmluZyAtIG5vIGV4cGlyZS5cXG4gICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLnN0YXRlLnR0bFxcbiAgICogQHBsdWdpbiBzdGF0ZVxcbiAgICovXFxuXFx0XFx0dHRsOiBmYWxzZSxcXG5cXHRcXHQvKipcXG4gICAqIEEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHByaW9yIHRvIHJlc3RvcmluZyBzdGF0ZSB3aXRoIG9uZSBhcmd1bWVudCAtIHRoZSBzdGF0ZSBvYmplY3QuIENhbiBiZSB1c2VkIHRvIGNsZWFyIHVud2FudGVkIHBhcnRzIG9mIHRoZSBzdGF0ZS5cXG4gICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLnN0YXRlLmZpbHRlclxcbiAgICogQHBsdWdpbiBzdGF0ZVxcbiAgICovXFxuXFx0XFx0ZmlsdGVyOiBmYWxzZVxcblxcdH07XFxuXFx0JC5qc3RyZWUucGx1Z2lucy5zdGF0ZSA9IGZ1bmN0aW9uIChvcHRpb25zLCBwYXJlbnQpIHtcXG5cXHRcXHR0aGlzLmJpbmQgPSBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0cGFyZW50LmJpbmQuY2FsbCh0aGlzKTtcXG5cXHRcXHRcXHR2YXIgYmluZCA9ICQucHJveHkoZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdHRoaXMuZWxlbWVudC5vbih0aGlzLnNldHRpbmdzLnN0YXRlLmV2ZW50cywgJC5wcm94eShmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHRvKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2xlYXJUaW1lb3V0KHRvKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0dG8gPSBzZXRUaW1lb3V0KCQucHJveHkoZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuc2F2ZV9zdGF0ZSgpO1xcblxcdFxcdFxcdFxcdFxcdH0sIHRoaXMpLCAxMDApO1xcblxcdFxcdFxcdFxcdH0sIHRoaXMpKTtcXG5cXHRcXHRcXHRcXHQvKipcXG4gICAgICogdHJpZ2dlcmVkIHdoZW4gdGhlIHN0YXRlIHBsdWdpbiBpcyBmaW5pc2hlZCByZXN0b3JpbmcgdGhlIHN0YXRlIChhbmQgaW1tZWRpYXRlbHkgYWZ0ZXIgcmVhZHkgaWYgdGhlcmUgaXMgbm8gc3RhdGUgdG8gcmVzdG9yZSkuXFxuICAgICAqIEBldmVudFxcbiAgICAgKiBAbmFtZSBzdGF0ZV9yZWFkeS5qc3RyZWVcXG4gICAgICogQHBsdWdpbiBzdGF0ZVxcbiAgICAgKi9cXG5cXHRcXHRcXHRcXHR0aGlzLnRyaWdnZXIoJ3N0YXRlX3JlYWR5Jyk7XFxuXFx0XFx0XFx0fSwgdGhpcyk7XFxuXFx0XFx0XFx0dGhpcy5lbGVtZW50Lm9uKFxcXCJyZWFkeS5qc3RyZWVcXFwiLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5lbGVtZW50Lm9uZShcXFwicmVzdG9yZV9zdGF0ZS5qc3RyZWVcXFwiLCBiaW5kKTtcXG5cXHRcXHRcXHRcXHRpZiAoIXRoaXMucmVzdG9yZV9zdGF0ZSgpKSB7XFxuXFx0XFx0XFx0XFx0XFx0YmluZCgpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LCB0aGlzKSk7XFxuXFx0XFx0fTtcXG5cXHRcXHQvKipcXG4gICAqIHNhdmUgdGhlIHN0YXRlXFxuICAgKiBAbmFtZSBzYXZlX3N0YXRlKClcXG4gICAqIEBwbHVnaW4gc3RhdGVcXG4gICAqL1xcblxcdFxcdHRoaXMuc2F2ZV9zdGF0ZSA9IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHR2YXIgc3QgPSB7ICdzdGF0ZSc6IHRoaXMuZ2V0X3N0YXRlKCksICd0dGwnOiB0aGlzLnNldHRpbmdzLnN0YXRlLnR0bCwgJ3NlYyc6ICtuZXcgRGF0ZSgpIH07XFxuXFx0XFx0XFx0JC52YWthdGEuc3RvcmFnZS5zZXQodGhpcy5zZXR0aW5ncy5zdGF0ZS5rZXksIEpTT04uc3RyaW5naWZ5KHN0KSk7XFxuXFx0XFx0fTtcXG5cXHRcXHQvKipcXG4gICAqIHJlc3RvcmUgdGhlIHN0YXRlIGZyb20gdGhlIHVzZXIncyBjb21wdXRlclxcbiAgICogQG5hbWUgcmVzdG9yZV9zdGF0ZSgpXFxuICAgKiBAcGx1Z2luIHN0YXRlXFxuICAgKi9cXG5cXHRcXHR0aGlzLnJlc3RvcmVfc3RhdGUgPSBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0dmFyIGsgPSAkLnZha2F0YS5zdG9yYWdlLmdldCh0aGlzLnNldHRpbmdzLnN0YXRlLmtleSk7XFxuXFx0XFx0XFx0aWYgKCEhaykge1xcblxcdFxcdFxcdFxcdHRyeSB7XFxuXFx0XFx0XFx0XFx0XFx0ayA9IEpTT04ucGFyc2Uoayk7XFxuXFx0XFx0XFx0XFx0fSBjYXRjaCAoZXgpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoISFrICYmIGsudHRsICYmIGsuc2VjICYmICtuZXcgRGF0ZSgpIC0gay5zZWMgPiBrLnR0bCkge1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKCEhayAmJiBrLnN0YXRlKSB7XFxuXFx0XFx0XFx0XFx0ayA9IGsuc3RhdGU7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICghIWsgJiYgJC5pc0Z1bmN0aW9uKHRoaXMuc2V0dGluZ3Muc3RhdGUuZmlsdGVyKSkge1xcblxcdFxcdFxcdFxcdGsgPSB0aGlzLnNldHRpbmdzLnN0YXRlLmZpbHRlci5jYWxsKHRoaXMsIGspO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoISFrKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5lbGVtZW50Lm9uZShcXFwic2V0X3N0YXRlLmpzdHJlZVxcXCIsIGZ1bmN0aW9uIChlLCBkYXRhKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZGF0YS5pbnN0YW5jZS50cmlnZ2VyKCdyZXN0b3JlX3N0YXRlJywgeyAnc3RhdGUnOiAkLmV4dGVuZCh0cnVlLCB7fSwgaykgfSk7XFxuXFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0XFx0dGhpcy5zZXRfc3RhdGUoayk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHR9O1xcblxcdFxcdC8qKlxcbiAgICogY2xlYXIgdGhlIHN0YXRlIG9uIHRoZSB1c2VyJ3MgY29tcHV0ZXJcXG4gICAqIEBuYW1lIGNsZWFyX3N0YXRlKClcXG4gICAqIEBwbHVnaW4gc3RhdGVcXG4gICAqL1xcblxcdFxcdHRoaXMuY2xlYXJfc3RhdGUgPSBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0cmV0dXJuICQudmFrYXRhLnN0b3JhZ2UuZGVsKHRoaXMuc2V0dGluZ3Muc3RhdGUua2V5KTtcXG5cXHRcXHR9O1xcblxcdH07XFxuXFxuXFx0KGZ1bmN0aW9uICgkLCB1bmRlZmluZWQpIHtcXG5cXHRcXHQkLnZha2F0YS5zdG9yYWdlID0ge1xcblxcdFxcdFxcdC8vIHNpbXBseSBzcGVjaWZ5aW5nIHRoZSBmdW5jdGlvbnMgaW4gRkYgdGhyb3dzIGFuIGVycm9yXFxuXFx0XFx0XFx0c2V0OiBmdW5jdGlvbiBzZXQoa2V5LCB2YWwpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gd2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKGtleSwgdmFsKTtcXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdGdldDogZnVuY3Rpb24gZ2V0KGtleSkge1xcblxcdFxcdFxcdFxcdHJldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KTtcXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdGRlbDogZnVuY3Rpb24gZGVsKGtleSkge1xcblxcdFxcdFxcdFxcdHJldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fTtcXG5cXHR9KSgkKTtcXG5cXG5cXHQvLyBpbmNsdWRlIHRoZSBzdGF0ZSBwbHVnaW4gYnkgZGVmYXVsdFxcblxcdC8vICQuanN0cmVlLmRlZmF1bHRzLnBsdWdpbnMucHVzaChcXFwic3RhdGVcXFwiKTtcXG5cXG5cXHQvKipcXG4gICogIyMjIFR5cGVzIHBsdWdpblxcbiAgKlxcbiAgKiBNYWtlcyBpdCBwb3NzaWJsZSB0byBhZGQgcHJlZGVmaW5lZCB0eXBlcyBmb3IgZ3JvdXBzIG9mIG5vZGVzLCB3aGljaCBtYWtlIGl0IHBvc3NpYmxlIHRvIGVhc2lseSBjb250cm9sIG5lc3RpbmcgcnVsZXMgYW5kIGljb24gZm9yIGVhY2ggZ3JvdXAuXFxuICAqL1xcblxcblxcdC8qKlxcbiAgKiBBbiBvYmplY3Qgc3RvcmluZyBhbGwgdHlwZXMgYXMga2V5IHZhbHVlIHBhaXJzLCB3aGVyZSB0aGUga2V5IGlzIHRoZSB0eXBlIG5hbWUgYW5kIHRoZSB2YWx1ZSBpcyBhbiBvYmplY3QgdGhhdCBjb3VsZCBjb250YWluIGZvbGxvd2luZyBrZXlzIChhbGwgb3B0aW9uYWwpLlxcbiAgKlxcbiAgKiAqIGBtYXhfY2hpbGRyZW5gIHRoZSBtYXhpbXVtIG51bWJlciBvZiBpbW1lZGlhdGUgY2hpbGRyZW4gdGhpcyBub2RlIHR5cGUgY2FuIGhhdmUuIERvIG5vdCBzcGVjaWZ5IG9yIHNldCB0byBgLTFgIGZvciB1bmxpbWl0ZWQuXFxuICAqICogYG1heF9kZXB0aGAgdGhlIG1heGltdW0gbnVtYmVyIG9mIG5lc3RpbmcgdGhpcyBub2RlIHR5cGUgY2FuIGhhdmUuIEEgdmFsdWUgb2YgYDFgIHdvdWxkIG1lYW4gdGhhdCB0aGUgbm9kZSBjYW4gaGF2ZSBjaGlsZHJlbiwgYnV0IG5vIGdyYW5kY2hpbGRyZW4uIERvIG5vdCBzcGVjaWZ5IG9yIHNldCB0byBgLTFgIGZvciB1bmxpbWl0ZWQuXFxuICAqICogYHZhbGlkX2NoaWxkcmVuYCBhbiBhcnJheSBvZiBub2RlIHR5cGUgc3RyaW5ncywgdGhhdCBub2RlcyBvZiB0aGlzIHR5cGUgY2FuIGhhdmUgYXMgY2hpbGRyZW4uIERvIG5vdCBzcGVjaWZ5IG9yIHNldCB0byBgLTFgIGZvciBubyBsaW1pdHMuXFxuICAqICogYGljb25gIGEgc3RyaW5nIC0gY2FuIGJlIGEgcGF0aCB0byBhbiBpY29uIG9yIGEgY2xhc3NOYW1lLCBpZiB1c2luZyBhbiBpbWFnZSB0aGF0IGlzIGluIHRoZSBjdXJyZW50IGRpcmVjdG9yeSB1c2UgYSBgLi9gIHByZWZpeCwgb3RoZXJ3aXNlIGl0IHdpbGwgYmUgZGV0ZWN0ZWQgYXMgYSBjbGFzcy4gT21pdCB0byB1c2UgdGhlIGRlZmF1bHQgaWNvbiBmcm9tIHlvdXIgdGhlbWUuXFxuICAqICogYGxpX2F0dHJgIGFuIG9iamVjdCBvZiB2YWx1ZXMgd2hpY2ggd2lsbCBiZSB1c2VkIHRvIGFkZCBIVE1MIGF0dHJpYnV0ZXMgb24gdGhlIHJlc3VsdGluZyBMSSBET00gbm9kZSAobWVyZ2VkIHdpdGggdGhlIG5vZGUncyBvd24gZGF0YSlcXG4gICogKiBgYV9hdHRyYCBhbiBvYmplY3Qgb2YgdmFsdWVzIHdoaWNoIHdpbGwgYmUgdXNlZCB0byBhZGQgSFRNTCBhdHRyaWJ1dGVzIG9uIHRoZSByZXN1bHRpbmcgQSBET00gbm9kZSAobWVyZ2VkIHdpdGggdGhlIG5vZGUncyBvd24gZGF0YSlcXG4gICpcXG4gICogVGhlcmUgYXJlIHR3byBwcmVkZWZpbmVkIHR5cGVzOlxcbiAgKlxcbiAgKiAqIGAjYCByZXByZXNlbnRzIHRoZSByb290IG9mIHRoZSB0cmVlLCBmb3IgZXhhbXBsZSBgbWF4X2NoaWxkcmVuYCB3b3VsZCBjb250cm9sIHRoZSBtYXhpbXVtIG51bWJlciBvZiByb290IG5vZGVzLlxcbiAgKiAqIGBkZWZhdWx0YCByZXByZXNlbnRzIHRoZSBkZWZhdWx0IG5vZGUgLSBhbnkgc2V0dGluZ3MgaGVyZSB3aWxsIGJlIGFwcGxpZWQgdG8gYWxsIG5vZGVzIHRoYXQgZG8gbm90IGhhdmUgYSB0eXBlIHNwZWNpZmllZC5cXG4gICpcXG4gICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMudHlwZXNcXG4gICogQHBsdWdpbiB0eXBlc1xcbiAgKi9cXG5cXHQkLmpzdHJlZS5kZWZhdWx0cy50eXBlcyA9IHtcXG5cXHRcXHQnZGVmYXVsdCc6IHt9XFxuXFx0fTtcXG5cXHQkLmpzdHJlZS5kZWZhdWx0cy50eXBlc1skLmpzdHJlZS5yb290XSA9IHt9O1xcblxcblxcdCQuanN0cmVlLnBsdWdpbnMudHlwZXMgPSBmdW5jdGlvbiAob3B0aW9ucywgcGFyZW50KSB7XFxuXFx0XFx0dGhpcy5pbml0ID0gZnVuY3Rpb24gKGVsLCBvcHRpb25zKSB7XFxuXFx0XFx0XFx0dmFyIGksIGo7XFxuXFx0XFx0XFx0aWYgKG9wdGlvbnMgJiYgb3B0aW9ucy50eXBlcyAmJiBvcHRpb25zLnR5cGVzWydkZWZhdWx0J10pIHtcXG5cXHRcXHRcXHRcXHRmb3IgKGkgaW4gb3B0aW9ucy50eXBlcykge1xcblxcdFxcdFxcdFxcdFxcdGlmIChpICE9PSBcXFwiZGVmYXVsdFxcXCIgJiYgaSAhPT0gJC5qc3RyZWUucm9vdCAmJiBvcHRpb25zLnR5cGVzLmhhc093blByb3BlcnR5KGkpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Zm9yIChqIGluIG9wdGlvbnMudHlwZXNbJ2RlZmF1bHQnXSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChvcHRpb25zLnR5cGVzWydkZWZhdWx0J10uaGFzT3duUHJvcGVydHkoaikgJiYgb3B0aW9ucy50eXBlc1tpXVtqXSA9PT0gdW5kZWZpbmVkKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0b3B0aW9ucy50eXBlc1tpXVtqXSA9IG9wdGlvbnMudHlwZXNbJ2RlZmF1bHQnXVtqXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHBhcmVudC5pbml0LmNhbGwodGhpcywgZWwsIG9wdGlvbnMpO1xcblxcdFxcdFxcdHRoaXMuX21vZGVsLmRhdGFbJC5qc3RyZWUucm9vdF0udHlwZSA9ICQuanN0cmVlLnJvb3Q7XFxuXFx0XFx0fTtcXG5cXHRcXHR0aGlzLnJlZnJlc2ggPSBmdW5jdGlvbiAoc2tpcF9sb2FkaW5nLCBmb3JnZXRfc3RhdGUpIHtcXG5cXHRcXHRcXHRwYXJlbnQucmVmcmVzaC5jYWxsKHRoaXMsIHNraXBfbG9hZGluZywgZm9yZ2V0X3N0YXRlKTtcXG5cXHRcXHRcXHR0aGlzLl9tb2RlbC5kYXRhWyQuanN0cmVlLnJvb3RdLnR5cGUgPSAkLmpzdHJlZS5yb290O1xcblxcdFxcdH07XFxuXFx0XFx0dGhpcy5iaW5kID0gZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdHRoaXMuZWxlbWVudC5vbignbW9kZWwuanN0cmVlJywgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xcblxcdFxcdFxcdFxcdHZhciBtID0gdGhpcy5fbW9kZWwuZGF0YSxcXG5cXHRcXHRcXHRcXHQgICAgZHBjID0gZGF0YS5ub2RlcyxcXG5cXHRcXHRcXHRcXHQgICAgdCA9IHRoaXMuc2V0dGluZ3MudHlwZXMsXFxuXFx0XFx0XFx0XFx0ICAgIGksXFxuXFx0XFx0XFx0XFx0ICAgIGosXFxuXFx0XFx0XFx0XFx0ICAgIGMgPSAnZGVmYXVsdCcsXFxuXFx0XFx0XFx0XFx0ICAgIGs7XFxuXFx0XFx0XFx0XFx0Zm9yIChpID0gMCwgaiA9IGRwYy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRjID0gJ2RlZmF1bHQnO1xcblxcdFxcdFxcdFxcdFxcdGlmIChtW2RwY1tpXV0ub3JpZ2luYWwgJiYgbVtkcGNbaV1dLm9yaWdpbmFsLnR5cGUgJiYgdFttW2RwY1tpXV0ub3JpZ2luYWwudHlwZV0pIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRjID0gbVtkcGNbaV1dLm9yaWdpbmFsLnR5cGU7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmIChtW2RwY1tpXV0uZGF0YSAmJiBtW2RwY1tpXV0uZGF0YS5qc3RyZWUgJiYgbVtkcGNbaV1dLmRhdGEuanN0cmVlLnR5cGUgJiYgdFttW2RwY1tpXV0uZGF0YS5qc3RyZWUudHlwZV0pIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRjID0gbVtkcGNbaV1dLmRhdGEuanN0cmVlLnR5cGU7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdG1bZHBjW2ldXS50eXBlID0gYztcXG5cXHRcXHRcXHRcXHRcXHRpZiAobVtkcGNbaV1dLmljb24gPT09IHRydWUgJiYgdFtjXS5pY29uICE9PSB1bmRlZmluZWQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRtW2RwY1tpXV0uaWNvbiA9IHRbY10uaWNvbjtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHRbY10ubGlfYXR0ciAhPT0gdW5kZWZpbmVkICYmIF90eXBlb2YodFtjXS5saV9hdHRyKSA9PT0gJ29iamVjdCcpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRmb3IgKGsgaW4gdFtjXS5saV9hdHRyKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKHRbY10ubGlfYXR0ci5oYXNPd25Qcm9wZXJ0eShrKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChrID09PSAnaWQnKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Y29udGludWU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIGlmIChtW2RwY1tpXV0ubGlfYXR0cltrXSA9PT0gdW5kZWZpbmVkKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bVtkcGNbaV1dLmxpX2F0dHJba10gPSB0W2NdLmxpX2F0dHJba107XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIGlmIChrID09PSAnY2xhc3MnKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bVtkcGNbaV1dLmxpX2F0dHJbJ2NsYXNzJ10gPSB0W2NdLmxpX2F0dHJbJ2NsYXNzJ10gKyAnICcgKyBtW2RwY1tpXV0ubGlfYXR0clsnY2xhc3MnXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHRbY10uYV9hdHRyICE9PSB1bmRlZmluZWQgJiYgX3R5cGVvZih0W2NdLmFfYXR0cikgPT09ICdvYmplY3QnKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Zm9yIChrIGluIHRbY10uYV9hdHRyKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKHRbY10uYV9hdHRyLmhhc093blByb3BlcnR5KGspKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKGsgPT09ICdpZCcpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjb250aW51ZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2UgaWYgKG1bZHBjW2ldXS5hX2F0dHJba10gPT09IHVuZGVmaW5lZCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG1bZHBjW2ldXS5hX2F0dHJba10gPSB0W2NdLmFfYXR0cltrXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2UgaWYgKGsgPT09ICdocmVmJyAmJiBtW2RwY1tpXV0uYV9hdHRyW2tdID09PSAnIycpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRtW2RwY1tpXV0uYV9hdHRyWydocmVmJ10gPSB0W2NdLmFfYXR0clsnaHJlZiddO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoayA9PT0gJ2NsYXNzJykge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG1bZHBjW2ldXS5hX2F0dHJbJ2NsYXNzJ10gPSB0W2NdLmFfYXR0clsnY2xhc3MnXSArICcgJyArIG1bZHBjW2ldXS5hX2F0dHJbJ2NsYXNzJ107XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRtWyQuanN0cmVlLnJvb3RdLnR5cGUgPSAkLmpzdHJlZS5yb290O1xcblxcdFxcdFxcdH0sIHRoaXMpKTtcXG5cXHRcXHRcXHRwYXJlbnQuYmluZC5jYWxsKHRoaXMpO1xcblxcdFxcdH07XFxuXFx0XFx0dGhpcy5nZXRfanNvbiA9IGZ1bmN0aW9uIChvYmosIG9wdGlvbnMsIGZsYXQpIHtcXG5cXHRcXHRcXHR2YXIgaSxcXG5cXHRcXHRcXHQgICAgaixcXG5cXHRcXHRcXHQgICAgbSA9IHRoaXMuX21vZGVsLmRhdGEsXFxuXFx0XFx0XFx0ICAgIG9wdCA9IG9wdGlvbnMgPyAkLmV4dGVuZCh0cnVlLCB7fSwgb3B0aW9ucywgeyBub19pZDogZmFsc2UgfSkgOiB7fSxcXG5cXHRcXHRcXHQgICAgdG1wID0gcGFyZW50LmdldF9qc29uLmNhbGwodGhpcywgb2JqLCBvcHQsIGZsYXQpO1xcblxcdFxcdFxcdGlmICh0bXAgPT09IGZhbHNlKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoJC5pc0FycmF5KHRtcCkpIHtcXG5cXHRcXHRcXHRcXHRmb3IgKGkgPSAwLCBqID0gdG1wLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdHRtcFtpXS50eXBlID0gdG1wW2ldLmlkICYmIG1bdG1wW2ldLmlkXSAmJiBtW3RtcFtpXS5pZF0udHlwZSA/IG1bdG1wW2ldLmlkXS50eXBlIDogXFxcImRlZmF1bHRcXFwiO1xcblxcdFxcdFxcdFxcdFxcdGlmIChvcHRpb25zICYmIG9wdGlvbnMubm9faWQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRkZWxldGUgdG1wW2ldLmlkO1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICh0bXBbaV0ubGlfYXR0ciAmJiB0bXBbaV0ubGlfYXR0ci5pZCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGRlbGV0ZSB0bXBbaV0ubGlfYXR0ci5pZDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKHRtcFtpXS5hX2F0dHIgJiYgdG1wW2ldLmFfYXR0ci5pZCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGRlbGV0ZSB0bXBbaV0uYV9hdHRyLmlkO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0dG1wLnR5cGUgPSB0bXAuaWQgJiYgbVt0bXAuaWRdICYmIG1bdG1wLmlkXS50eXBlID8gbVt0bXAuaWRdLnR5cGUgOiBcXFwiZGVmYXVsdFxcXCI7XFxuXFx0XFx0XFx0XFx0aWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5ub19pZCkge1xcblxcdFxcdFxcdFxcdFxcdHRtcCA9IHRoaXMuX2RlbGV0ZV9pZHModG1wKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiB0bXA7XFxuXFx0XFx0fTtcXG5cXHRcXHR0aGlzLl9kZWxldGVfaWRzID0gZnVuY3Rpb24gKHRtcCkge1xcblxcdFxcdFxcdGlmICgkLmlzQXJyYXkodG1wKSkge1xcblxcdFxcdFxcdFxcdGZvciAodmFyIGkgPSAwLCBqID0gdG1wLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdHRtcFtpXSA9IHRoaXMuX2RlbGV0ZV9pZHModG1wW2ldKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRtcDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0ZGVsZXRlIHRtcC5pZDtcXG5cXHRcXHRcXHRpZiAodG1wLmxpX2F0dHIgJiYgdG1wLmxpX2F0dHIuaWQpIHtcXG5cXHRcXHRcXHRcXHRkZWxldGUgdG1wLmxpX2F0dHIuaWQ7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICh0bXAuYV9hdHRyICYmIHRtcC5hX2F0dHIuaWQpIHtcXG5cXHRcXHRcXHRcXHRkZWxldGUgdG1wLmFfYXR0ci5pZDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKHRtcC5jaGlsZHJlbiAmJiAkLmlzQXJyYXkodG1wLmNoaWxkcmVuKSkge1xcblxcdFxcdFxcdFxcdHRtcC5jaGlsZHJlbiA9IHRoaXMuX2RlbGV0ZV9pZHModG1wLmNoaWxkcmVuKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIHRtcDtcXG5cXHRcXHR9O1xcblxcdFxcdHRoaXMuY2hlY2sgPSBmdW5jdGlvbiAoY2hrLCBvYmosIHBhciwgcG9zLCBtb3JlKSB7XFxuXFx0XFx0XFx0aWYgKHBhcmVudC5jaGVjay5jYWxsKHRoaXMsIGNoaywgb2JqLCBwYXIsIHBvcywgbW9yZSkgPT09IGZhbHNlKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRvYmogPSBvYmogJiYgb2JqLmlkID8gb2JqIDogdGhpcy5nZXRfbm9kZShvYmopO1xcblxcdFxcdFxcdHBhciA9IHBhciAmJiBwYXIuaWQgPyBwYXIgOiB0aGlzLmdldF9ub2RlKHBhcik7XFxuXFx0XFx0XFx0dmFyIG0gPSBvYmogJiYgb2JqLmlkID8gbW9yZSAmJiBtb3JlLm9yaWdpbiA/IG1vcmUub3JpZ2luIDogJC5qc3RyZWUucmVmZXJlbmNlKG9iai5pZCkgOiBudWxsLFxcblxcdFxcdFxcdCAgICB0bXAsXFxuXFx0XFx0XFx0ICAgIGQsXFxuXFx0XFx0XFx0ICAgIGksXFxuXFx0XFx0XFx0ICAgIGo7XFxuXFx0XFx0XFx0bSA9IG0gJiYgbS5fbW9kZWwgJiYgbS5fbW9kZWwuZGF0YSA/IG0uX21vZGVsLmRhdGEgOiBudWxsO1xcblxcdFxcdFxcdHN3aXRjaCAoY2hrKSB7XFxuXFx0XFx0XFx0XFx0Y2FzZSBcXFwiY3JlYXRlX25vZGVcXFwiOlxcblxcdFxcdFxcdFxcdGNhc2UgXFxcIm1vdmVfbm9kZVxcXCI6XFxuXFx0XFx0XFx0XFx0Y2FzZSBcXFwiY29weV9ub2RlXFxcIjpcXG5cXHRcXHRcXHRcXHRcXHRpZiAoY2hrICE9PSAnbW92ZV9ub2RlJyB8fCAkLmluQXJyYXkob2JqLmlkLCBwYXIuY2hpbGRyZW4pID09PSAtMSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRtcCA9IHRoaXMuZ2V0X3J1bGVzKHBhcik7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKHRtcC5tYXhfY2hpbGRyZW4gIT09IHVuZGVmaW5lZCAmJiB0bXAubWF4X2NoaWxkcmVuICE9PSAtMSAmJiB0bXAubWF4X2NoaWxkcmVuID09PSBwYXIuY2hpbGRyZW4ubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IgPSB7ICdlcnJvcic6ICdjaGVjaycsICdwbHVnaW4nOiAndHlwZXMnLCAnaWQnOiAndHlwZXNfMDEnLCAncmVhc29uJzogJ21heF9jaGlsZHJlbiBwcmV2ZW50cyBmdW5jdGlvbjogJyArIGNoaywgJ2RhdGEnOiBKU09OLnN0cmluZ2lmeSh7ICdjaGsnOiBjaGssICdwb3MnOiBwb3MsICdvYmonOiBvYmogJiYgb2JqLmlkID8gb2JqLmlkIDogZmFsc2UsICdwYXInOiBwYXIgJiYgcGFyLmlkID8gcGFyLmlkIDogZmFsc2UgfSkgfTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICh0bXAudmFsaWRfY2hpbGRyZW4gIT09IHVuZGVmaW5lZCAmJiB0bXAudmFsaWRfY2hpbGRyZW4gIT09IC0xICYmICQuaW5BcnJheShvYmoudHlwZSB8fCAnZGVmYXVsdCcsIHRtcC52YWxpZF9jaGlsZHJlbikgPT09IC0xKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IgPSB7ICdlcnJvcic6ICdjaGVjaycsICdwbHVnaW4nOiAndHlwZXMnLCAnaWQnOiAndHlwZXNfMDInLCAncmVhc29uJzogJ3ZhbGlkX2NoaWxkcmVuIHByZXZlbnRzIGZ1bmN0aW9uOiAnICsgY2hrLCAnZGF0YSc6IEpTT04uc3RyaW5naWZ5KHsgJ2Noayc6IGNoaywgJ3Bvcyc6IHBvcywgJ29iaic6IG9iaiAmJiBvYmouaWQgPyBvYmouaWQgOiBmYWxzZSwgJ3Bhcic6IHBhciAmJiBwYXIuaWQgPyBwYXIuaWQgOiBmYWxzZSB9KSB9O1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKG0gJiYgb2JqLmNoaWxkcmVuX2QgJiYgb2JqLnBhcmVudHMpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRkID0gMDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRmb3IgKGkgPSAwLCBqID0gb2JqLmNoaWxkcmVuX2QubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZCA9IE1hdGgubWF4KGQsIG1bb2JqLmNoaWxkcmVuX2RbaV1dLnBhcmVudHMubGVuZ3RoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZCA9IGQgLSBvYmoucGFyZW50cy5sZW5ndGggKyAxO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoZCA8PSAwIHx8IGQgPT09IHVuZGVmaW5lZCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGQgPSAxO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRkbyB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKHRtcC5tYXhfZGVwdGggIT09IHVuZGVmaW5lZCAmJiB0bXAubWF4X2RlcHRoICE9PSAtMSAmJiB0bXAubWF4X2RlcHRoIDwgZCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yID0geyAnZXJyb3InOiAnY2hlY2snLCAncGx1Z2luJzogJ3R5cGVzJywgJ2lkJzogJ3R5cGVzXzAzJywgJ3JlYXNvbic6ICdtYXhfZGVwdGggcHJldmVudHMgZnVuY3Rpb246ICcgKyBjaGssICdkYXRhJzogSlNPTi5zdHJpbmdpZnkoeyAnY2hrJzogY2hrLCAncG9zJzogcG9zLCAnb2JqJzogb2JqICYmIG9iai5pZCA/IG9iai5pZCA6IGZhbHNlLCAncGFyJzogcGFyICYmIHBhci5pZCA/IHBhci5pZCA6IGZhbHNlIH0pIH07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRwYXIgPSB0aGlzLmdldF9ub2RlKHBhci5wYXJlbnQpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRtcCA9IHRoaXMuZ2V0X3J1bGVzKHBhcik7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZCsrO1xcblxcdFxcdFxcdFxcdFxcdFxcdH0gd2hpbGUgKHBhcik7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHR9O1xcblxcdFxcdC8qKlxcbiAgICogdXNlZCB0byByZXRyaWV2ZSB0aGUgdHlwZSBzZXR0aW5ncyBvYmplY3QgZm9yIGEgbm9kZVxcbiAgICogQG5hbWUgZ2V0X3J1bGVzKG9iailcXG4gICAqIEBwYXJhbSB7bWl4ZWR9IG9iaiB0aGUgbm9kZSB0byBmaW5kIHRoZSBydWxlcyBmb3JcXG4gICAqIEByZXR1cm4ge09iamVjdH1cXG4gICAqIEBwbHVnaW4gdHlwZXNcXG4gICAqL1xcblxcdFxcdHRoaXMuZ2V0X3J1bGVzID0gZnVuY3Rpb24gKG9iaikge1xcblxcdFxcdFxcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXHRcXHRcXHRpZiAoIW9iaikge1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0dmFyIHRtcCA9IHRoaXMuZ2V0X3R5cGUob2JqLCB0cnVlKTtcXG5cXHRcXHRcXHRpZiAodG1wLm1heF9kZXB0aCA9PT0gdW5kZWZpbmVkKSB7XFxuXFx0XFx0XFx0XFx0dG1wLm1heF9kZXB0aCA9IC0xO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAodG1wLm1heF9jaGlsZHJlbiA9PT0gdW5kZWZpbmVkKSB7XFxuXFx0XFx0XFx0XFx0dG1wLm1heF9jaGlsZHJlbiA9IC0xO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAodG1wLnZhbGlkX2NoaWxkcmVuID09PSB1bmRlZmluZWQpIHtcXG5cXHRcXHRcXHRcXHR0bXAudmFsaWRfY2hpbGRyZW4gPSAtMTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIHRtcDtcXG5cXHRcXHR9O1xcblxcdFxcdC8qKlxcbiAgICogdXNlZCB0byByZXRyaWV2ZSB0aGUgdHlwZSBzdHJpbmcgb3Igc2V0dGluZ3Mgb2JqZWN0IGZvciBhIG5vZGVcXG4gICAqIEBuYW1lIGdldF90eXBlKG9iaiBbLCBydWxlc10pXFxuICAgKiBAcGFyYW0ge21peGVkfSBvYmogdGhlIG5vZGUgdG8gZmluZCB0aGUgcnVsZXMgZm9yXFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJ1bGVzIGlmIHNldCB0byBgdHJ1ZWAgaW5zdGVhZCBvZiBhIHN0cmluZyB0aGUgc2V0dGluZ3Mgb2JqZWN0IHdpbGwgYmUgcmV0dXJuZWRcXG4gICAqIEByZXR1cm4ge1N0cmluZ3xPYmplY3R9XFxuICAgKiBAcGx1Z2luIHR5cGVzXFxuICAgKi9cXG5cXHRcXHR0aGlzLmdldF90eXBlID0gZnVuY3Rpb24gKG9iaiwgcnVsZXMpIHtcXG5cXHRcXHRcXHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XFxuXFx0XFx0XFx0cmV0dXJuICFvYmogPyBmYWxzZSA6IHJ1bGVzID8gJC5leHRlbmQoeyAndHlwZSc6IG9iai50eXBlIH0sIHRoaXMuc2V0dGluZ3MudHlwZXNbb2JqLnR5cGVdKSA6IG9iai50eXBlO1xcblxcdFxcdH07XFxuXFx0XFx0LyoqXFxuICAgKiB1c2VkIHRvIGNoYW5nZSBhIG5vZGUncyB0eXBlXFxuICAgKiBAbmFtZSBzZXRfdHlwZShvYmosIHR5cGUpXFxuICAgKiBAcGFyYW0ge21peGVkfSBvYmogdGhlIG5vZGUgdG8gY2hhbmdlXFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSB0aGUgbmV3IHR5cGVcXG4gICAqIEBwbHVnaW4gdHlwZXNcXG4gICAqL1xcblxcdFxcdHRoaXMuc2V0X3R5cGUgPSBmdW5jdGlvbiAob2JqLCB0eXBlKSB7XFxuXFx0XFx0XFx0dmFyIG0gPSB0aGlzLl9tb2RlbC5kYXRhLFxcblxcdFxcdFxcdCAgICB0LFxcblxcdFxcdFxcdCAgICB0MSxcXG5cXHRcXHRcXHQgICAgdDIsXFxuXFx0XFx0XFx0ICAgIG9sZF90eXBlLFxcblxcdFxcdFxcdCAgICBvbGRfaWNvbixcXG5cXHRcXHRcXHQgICAgayxcXG5cXHRcXHRcXHQgICAgZCxcXG5cXHRcXHRcXHQgICAgYTtcXG5cXHRcXHRcXHRpZiAoJC5pc0FycmF5KG9iaikpIHtcXG5cXHRcXHRcXHRcXHRvYmogPSBvYmouc2xpY2UoKTtcXG5cXHRcXHRcXHRcXHRmb3IgKHQxID0gMCwgdDIgPSBvYmoubGVuZ3RoOyB0MSA8IHQyOyB0MSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5zZXRfdHlwZShvYmpbdDFdLCB0eXBlKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHQgPSB0aGlzLnNldHRpbmdzLnR5cGVzO1xcblxcdFxcdFxcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXHRcXHRcXHRpZiAoIXRbdHlwZV0gfHwgIW9iaikge1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0ZCA9IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKTtcXG5cXHRcXHRcXHRpZiAoZCAmJiBkLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdGEgPSBkLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRvbGRfdHlwZSA9IG9iai50eXBlO1xcblxcdFxcdFxcdG9sZF9pY29uID0gdGhpcy5nZXRfaWNvbihvYmopO1xcblxcdFxcdFxcdG9iai50eXBlID0gdHlwZTtcXG5cXHRcXHRcXHRpZiAob2xkX2ljb24gPT09IHRydWUgfHwgIXRbb2xkX3R5cGVdIHx8IHRbb2xkX3R5cGVdLmljb24gIT09IHVuZGVmaW5lZCAmJiBvbGRfaWNvbiA9PT0gdFtvbGRfdHlwZV0uaWNvbikge1xcblxcdFxcdFxcdFxcdHRoaXMuc2V0X2ljb24ob2JqLCB0W3R5cGVdLmljb24gIT09IHVuZGVmaW5lZCA/IHRbdHlwZV0uaWNvbiA6IHRydWUpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyByZW1vdmUgb2xkIHR5cGUgcHJvcHNcXG5cXHRcXHRcXHRpZiAodFtvbGRfdHlwZV0gJiYgdFtvbGRfdHlwZV0ubGlfYXR0ciAhPT0gdW5kZWZpbmVkICYmIF90eXBlb2YodFtvbGRfdHlwZV0ubGlfYXR0cikgPT09ICdvYmplY3QnKSB7XFxuXFx0XFx0XFx0XFx0Zm9yIChrIGluIHRbb2xkX3R5cGVdLmxpX2F0dHIpIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAodFtvbGRfdHlwZV0ubGlfYXR0ci5oYXNPd25Qcm9wZXJ0eShrKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChrID09PSAnaWQnKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y29udGludWU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIGlmIChrID09PSAnY2xhc3MnKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bVtvYmouaWRdLmxpX2F0dHJbJ2NsYXNzJ10gPSAobVtvYmouaWRdLmxpX2F0dHJbJ2NsYXNzJ10gfHwgJycpLnJlcGxhY2UodFtvbGRfdHlwZV0ubGlfYXR0cltrXSwgJycpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChkKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZC5yZW1vdmVDbGFzcyh0W29sZF90eXBlXS5saV9hdHRyW2tdKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIGlmIChtW29iai5pZF0ubGlfYXR0cltrXSA9PT0gdFtvbGRfdHlwZV0ubGlfYXR0cltrXSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG1bb2JqLmlkXS5saV9hdHRyW2tdID0gbnVsbDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoZCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGQucmVtb3ZlQXR0cihrKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICh0W29sZF90eXBlXSAmJiB0W29sZF90eXBlXS5hX2F0dHIgIT09IHVuZGVmaW5lZCAmJiBfdHlwZW9mKHRbb2xkX3R5cGVdLmFfYXR0cikgPT09ICdvYmplY3QnKSB7XFxuXFx0XFx0XFx0XFx0Zm9yIChrIGluIHRbb2xkX3R5cGVdLmFfYXR0cikge1xcblxcdFxcdFxcdFxcdFxcdGlmICh0W29sZF90eXBlXS5hX2F0dHIuaGFzT3duUHJvcGVydHkoaykpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoayA9PT0gJ2lkJykge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGNvbnRpbnVlO1xcblxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoayA9PT0gJ2NsYXNzJykge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG1bb2JqLmlkXS5hX2F0dHJbJ2NsYXNzJ10gPSAobVtvYmouaWRdLmFfYXR0clsnY2xhc3MnXSB8fCAnJykucmVwbGFjZSh0W29sZF90eXBlXS5hX2F0dHJba10sICcnKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoYSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGEucmVtb3ZlQ2xhc3ModFtvbGRfdHlwZV0uYV9hdHRyW2tdKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIGlmIChtW29iai5pZF0uYV9hdHRyW2tdID09PSB0W29sZF90eXBlXS5hX2F0dHJba10pIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoayA9PT0gJ2hyZWYnKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bVtvYmouaWRdLmFfYXR0cltrXSA9ICcjJztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoYSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGEuYXR0cignaHJlZicsICcjJyk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGVsZXRlIG1bb2JqLmlkXS5hX2F0dHJba107XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKGEpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRhLnJlbW92ZUF0dHIoayk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gYWRkIG5ldyBwcm9wc1xcblxcdFxcdFxcdGlmICh0W3R5cGVdLmxpX2F0dHIgIT09IHVuZGVmaW5lZCAmJiBfdHlwZW9mKHRbdHlwZV0ubGlfYXR0cikgPT09ICdvYmplY3QnKSB7XFxuXFx0XFx0XFx0XFx0Zm9yIChrIGluIHRbdHlwZV0ubGlfYXR0cikge1xcblxcdFxcdFxcdFxcdFxcdGlmICh0W3R5cGVdLmxpX2F0dHIuaGFzT3duUHJvcGVydHkoaykpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoayA9PT0gJ2lkJykge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGNvbnRpbnVlO1xcblxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSBpZiAobVtvYmouaWRdLmxpX2F0dHJba10gPT09IHVuZGVmaW5lZCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG1bb2JqLmlkXS5saV9hdHRyW2tdID0gdFt0eXBlXS5saV9hdHRyW2tdO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChkKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKGsgPT09ICdjbGFzcycpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkLmFkZENsYXNzKHRbdHlwZV0ubGlfYXR0cltrXSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkLmF0dHIoaywgdFt0eXBlXS5saV9hdHRyW2tdKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoayA9PT0gJ2NsYXNzJykge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG1bb2JqLmlkXS5saV9hdHRyWydjbGFzcyddID0gdFt0eXBlXS5saV9hdHRyW2tdICsgJyAnICsgbVtvYmouaWRdLmxpX2F0dHJbJ2NsYXNzJ107XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKGQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkLmFkZENsYXNzKHRbdHlwZV0ubGlfYXR0cltrXSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAodFt0eXBlXS5hX2F0dHIgIT09IHVuZGVmaW5lZCAmJiBfdHlwZW9mKHRbdHlwZV0uYV9hdHRyKSA9PT0gJ29iamVjdCcpIHtcXG5cXHRcXHRcXHRcXHRmb3IgKGsgaW4gdFt0eXBlXS5hX2F0dHIpIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAodFt0eXBlXS5hX2F0dHIuaGFzT3duUHJvcGVydHkoaykpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoayA9PT0gJ2lkJykge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGNvbnRpbnVlO1xcblxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSBpZiAobVtvYmouaWRdLmFfYXR0cltrXSA9PT0gdW5kZWZpbmVkKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bVtvYmouaWRdLmFfYXR0cltrXSA9IHRbdHlwZV0uYV9hdHRyW2tdO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChhKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKGsgPT09ICdjbGFzcycpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRhLmFkZENsYXNzKHRbdHlwZV0uYV9hdHRyW2tdKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGEuYXR0cihrLCB0W3R5cGVdLmFfYXR0cltrXSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2UgaWYgKGsgPT09ICdocmVmJyAmJiBtW29iai5pZF0uYV9hdHRyW2tdID09PSAnIycpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRtW29iai5pZF0uYV9hdHRyWydocmVmJ10gPSB0W3R5cGVdLmFfYXR0clsnaHJlZiddO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChhKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YS5hdHRyKCdocmVmJywgdFt0eXBlXS5hX2F0dHJbJ2hyZWYnXSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoayA9PT0gJ2NsYXNzJykge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG1bb2JqLmlkXS5hX2F0dHJbJ2NsYXNzJ10gPSB0W3R5cGVdLmFfYXR0clsnY2xhc3MnXSArICcgJyArIG1bb2JqLmlkXS5hX2F0dHJbJ2NsYXNzJ107XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKGEpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRhLmFkZENsYXNzKHRbdHlwZV0uYV9hdHRyW2tdKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdH07XFxuXFx0fTtcXG5cXHQvLyBpbmNsdWRlIHRoZSB0eXBlcyBwbHVnaW4gYnkgZGVmYXVsdFxcblxcdC8vICQuanN0cmVlLmRlZmF1bHRzLnBsdWdpbnMucHVzaChcXFwidHlwZXNcXFwiKTtcXG5cXG5cXG5cXHQvKipcXG4gICogIyMjIFVuaXF1ZSBwbHVnaW5cXG4gICpcXG4gICogRW5mb3JjZXMgdGhhdCBubyBub2RlcyB3aXRoIHRoZSBzYW1lIG5hbWUgY2FuIGNvZXhpc3QgYXMgc2libGluZ3MuXFxuICAqL1xcblxcblxcdC8qKlxcbiAgKiBzdG9yZXMgYWxsIGRlZmF1bHRzIGZvciB0aGUgdW5pcXVlIHBsdWdpblxcbiAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy51bmlxdWVcXG4gICogQHBsdWdpbiB1bmlxdWVcXG4gICovXFxuXFx0JC5qc3RyZWUuZGVmYXVsdHMudW5pcXVlID0ge1xcblxcdFxcdC8qKlxcbiAgICogSW5kaWNhdGVzIGlmIHRoZSBjb21wYXJpc29uIHNob3VsZCBiZSBjYXNlIHNlbnNpdGl2ZS4gRGVmYXVsdCBpcyBgZmFsc2VgLlxcbiAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMudW5pcXVlLmNhc2Vfc2Vuc2l0aXZlXFxuICAgKiBAcGx1Z2luIHVuaXF1ZVxcbiAgICovXFxuXFx0XFx0Y2FzZV9zZW5zaXRpdmU6IGZhbHNlLFxcblxcdFxcdC8qKlxcbiAgICogQSBjYWxsYmFjayBleGVjdXRlZCBpbiB0aGUgaW5zdGFuY2UncyBzY29wZSB3aGVuIGEgbmV3IG5vZGUgaXMgY3JlYXRlZCBhbmQgdGhlIG5hbWUgaXMgYWxyZWFkeSB0YWtlbiwgdGhlIHR3byBhcmd1bWVudHMgYXJlIHRoZSBjb25mbGljdGluZyBuYW1lIGFuZCB0aGUgY291bnRlci4gVGhlIGRlZmF1bHQgd2lsbCBwcm9kdWNlIHJlc3VsdHMgbGlrZSBgTmV3IG5vZGUgKDIpYC5cXG4gICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLnVuaXF1ZS5kdXBsaWNhdGVcXG4gICAqIEBwbHVnaW4gdW5pcXVlXFxuICAgKi9cXG5cXHRcXHRkdXBsaWNhdGU6IGZ1bmN0aW9uIGR1cGxpY2F0ZShuYW1lLCBjb3VudGVyKSB7XFxuXFx0XFx0XFx0cmV0dXJuIG5hbWUgKyAnICgnICsgY291bnRlciArICcpJztcXG5cXHRcXHR9XFxuXFx0fTtcXG5cXG5cXHQkLmpzdHJlZS5wbHVnaW5zLnVuaXF1ZSA9IGZ1bmN0aW9uIChvcHRpb25zLCBwYXJlbnQpIHtcXG5cXHRcXHR0aGlzLmNoZWNrID0gZnVuY3Rpb24gKGNoaywgb2JqLCBwYXIsIHBvcywgbW9yZSkge1xcblxcdFxcdFxcdGlmIChwYXJlbnQuY2hlY2suY2FsbCh0aGlzLCBjaGssIG9iaiwgcGFyLCBwb3MsIG1vcmUpID09PSBmYWxzZSkge1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0b2JqID0gb2JqICYmIG9iai5pZCA/IG9iaiA6IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXHRcXHRcXHRwYXIgPSBwYXIgJiYgcGFyLmlkID8gcGFyIDogdGhpcy5nZXRfbm9kZShwYXIpO1xcblxcdFxcdFxcdGlmICghcGFyIHx8ICFwYXIuY2hpbGRyZW4pIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0dmFyIG4gPSBjaGsgPT09IFxcXCJyZW5hbWVfbm9kZVxcXCIgPyBwb3MgOiBvYmoudGV4dCxcXG5cXHRcXHRcXHQgICAgYyA9IFtdLFxcblxcdFxcdFxcdCAgICBzID0gdGhpcy5zZXR0aW5ncy51bmlxdWUuY2FzZV9zZW5zaXRpdmUsXFxuXFx0XFx0XFx0ICAgIG0gPSB0aGlzLl9tb2RlbC5kYXRhLFxcblxcdFxcdFxcdCAgICBpLFxcblxcdFxcdFxcdCAgICBqO1xcblxcdFxcdFxcdGZvciAoaSA9IDAsIGogPSBwYXIuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0Yy5wdXNoKHMgPyBtW3Bhci5jaGlsZHJlbltpXV0udGV4dCA6IG1bcGFyLmNoaWxkcmVuW2ldXS50ZXh0LnRvTG93ZXJDYXNlKCkpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoIXMpIHtcXG5cXHRcXHRcXHRcXHRuID0gbi50b0xvd2VyQ2FzZSgpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRzd2l0Y2ggKGNoaykge1xcblxcdFxcdFxcdFxcdGNhc2UgXFxcImRlbGV0ZV9ub2RlXFxcIjpcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRjYXNlIFxcXCJyZW5hbWVfbm9kZVxcXCI6XFxuXFx0XFx0XFx0XFx0XFx0aSA9ICQuaW5BcnJheShuLCBjKSA9PT0gLTEgfHwgb2JqLnRleHQgJiYgb2JqLnRleHRbcyA/ICd0b1N0cmluZycgOiAndG9Mb3dlckNhc2UnXSgpID09PSBuO1xcblxcdFxcdFxcdFxcdFxcdGlmICghaSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yID0geyAnZXJyb3InOiAnY2hlY2snLCAncGx1Z2luJzogJ3VuaXF1ZScsICdpZCc6ICd1bmlxdWVfMDEnLCAncmVhc29uJzogJ0NoaWxkIHdpdGggbmFtZSAnICsgbiArICcgYWxyZWFkeSBleGlzdHMuIFByZXZlbnRpbmc6ICcgKyBjaGssICdkYXRhJzogSlNPTi5zdHJpbmdpZnkoeyAnY2hrJzogY2hrLCAncG9zJzogcG9zLCAnb2JqJzogb2JqICYmIG9iai5pZCA/IG9iai5pZCA6IGZhbHNlLCAncGFyJzogcGFyICYmIHBhci5pZCA/IHBhci5pZCA6IGZhbHNlIH0pIH07XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBpO1xcblxcdFxcdFxcdFxcdGNhc2UgXFxcImNyZWF0ZV9ub2RlXFxcIjpcXG5cXHRcXHRcXHRcXHRcXHRpID0gJC5pbkFycmF5KG4sIGMpID09PSAtMTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIWkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvciA9IHsgJ2Vycm9yJzogJ2NoZWNrJywgJ3BsdWdpbic6ICd1bmlxdWUnLCAnaWQnOiAndW5pcXVlXzA0JywgJ3JlYXNvbic6ICdDaGlsZCB3aXRoIG5hbWUgJyArIG4gKyAnIGFscmVhZHkgZXhpc3RzLiBQcmV2ZW50aW5nOiAnICsgY2hrLCAnZGF0YSc6IEpTT04uc3RyaW5naWZ5KHsgJ2Noayc6IGNoaywgJ3Bvcyc6IHBvcywgJ29iaic6IG9iaiAmJiBvYmouaWQgPyBvYmouaWQgOiBmYWxzZSwgJ3Bhcic6IHBhciAmJiBwYXIuaWQgPyBwYXIuaWQgOiBmYWxzZSB9KSB9O1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gaTtcXG5cXHRcXHRcXHRcXHRjYXNlIFxcXCJjb3B5X25vZGVcXFwiOlxcblxcdFxcdFxcdFxcdFxcdGkgPSAkLmluQXJyYXkobiwgYykgPT09IC0xO1xcblxcdFxcdFxcdFxcdFxcdGlmICghaSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yID0geyAnZXJyb3InOiAnY2hlY2snLCAncGx1Z2luJzogJ3VuaXF1ZScsICdpZCc6ICd1bmlxdWVfMDInLCAncmVhc29uJzogJ0NoaWxkIHdpdGggbmFtZSAnICsgbiArICcgYWxyZWFkeSBleGlzdHMuIFByZXZlbnRpbmc6ICcgKyBjaGssICdkYXRhJzogSlNPTi5zdHJpbmdpZnkoeyAnY2hrJzogY2hrLCAncG9zJzogcG9zLCAnb2JqJzogb2JqICYmIG9iai5pZCA/IG9iai5pZCA6IGZhbHNlLCAncGFyJzogcGFyICYmIHBhci5pZCA/IHBhci5pZCA6IGZhbHNlIH0pIH07XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBpO1xcblxcdFxcdFxcdFxcdGNhc2UgXFxcIm1vdmVfbm9kZVxcXCI6XFxuXFx0XFx0XFx0XFx0XFx0aSA9IG9iai5wYXJlbnQgPT09IHBhci5pZCAmJiAoIW1vcmUgfHwgIW1vcmUuaXNfbXVsdGkpIHx8ICQuaW5BcnJheShuLCBjKSA9PT0gLTE7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCFpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IgPSB7ICdlcnJvcic6ICdjaGVjaycsICdwbHVnaW4nOiAndW5pcXVlJywgJ2lkJzogJ3VuaXF1ZV8wMycsICdyZWFzb24nOiAnQ2hpbGQgd2l0aCBuYW1lICcgKyBuICsgJyBhbHJlYWR5IGV4aXN0cy4gUHJldmVudGluZzogJyArIGNoaywgJ2RhdGEnOiBKU09OLnN0cmluZ2lmeSh7ICdjaGsnOiBjaGssICdwb3MnOiBwb3MsICdvYmonOiBvYmogJiYgb2JqLmlkID8gb2JqLmlkIDogZmFsc2UsICdwYXInOiBwYXIgJiYgcGFyLmlkID8gcGFyLmlkIDogZmFsc2UgfSkgfTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdH07XFxuXFx0XFx0dGhpcy5jcmVhdGVfbm9kZSA9IGZ1bmN0aW9uIChwYXIsIG5vZGUsIHBvcywgY2FsbGJhY2ssIGlzX2xvYWRlZCkge1xcblxcdFxcdFxcdGlmICghbm9kZSB8fCBub2RlLnRleHQgPT09IHVuZGVmaW5lZCkge1xcblxcdFxcdFxcdFxcdGlmIChwYXIgPT09IG51bGwpIHtcXG5cXHRcXHRcXHRcXHRcXHRwYXIgPSAkLmpzdHJlZS5yb290O1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRwYXIgPSB0aGlzLmdldF9ub2RlKHBhcik7XFxuXFx0XFx0XFx0XFx0aWYgKCFwYXIpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gcGFyZW50LmNyZWF0ZV9ub2RlLmNhbGwodGhpcywgcGFyLCBub2RlLCBwb3MsIGNhbGxiYWNrLCBpc19sb2FkZWQpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRwb3MgPSBwb3MgPT09IHVuZGVmaW5lZCA/IFxcXCJsYXN0XFxcIiA6IHBvcztcXG5cXHRcXHRcXHRcXHRpZiAoIXBvcy50b1N0cmluZygpLm1hdGNoKC9eKGJlZm9yZXxhZnRlcikkLykgJiYgIWlzX2xvYWRlZCAmJiAhdGhpcy5pc19sb2FkZWQocGFyKSkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBwYXJlbnQuY3JlYXRlX25vZGUuY2FsbCh0aGlzLCBwYXIsIG5vZGUsIHBvcywgY2FsbGJhY2ssIGlzX2xvYWRlZCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGlmICghbm9kZSkge1xcblxcdFxcdFxcdFxcdFxcdG5vZGUgPSB7fTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0dmFyIHRtcCxcXG5cXHRcXHRcXHRcXHQgICAgbixcXG5cXHRcXHRcXHRcXHQgICAgZHBjLFxcblxcdFxcdFxcdFxcdCAgICBpLFxcblxcdFxcdFxcdFxcdCAgICBqLFxcblxcdFxcdFxcdFxcdCAgICBtID0gdGhpcy5fbW9kZWwuZGF0YSxcXG5cXHRcXHRcXHRcXHQgICAgcyA9IHRoaXMuc2V0dGluZ3MudW5pcXVlLmNhc2Vfc2Vuc2l0aXZlLFxcblxcdFxcdFxcdFxcdCAgICBjYiA9IHRoaXMuc2V0dGluZ3MudW5pcXVlLmR1cGxpY2F0ZTtcXG5cXHRcXHRcXHRcXHRuID0gdG1wID0gdGhpcy5nZXRfc3RyaW5nKCdOZXcgbm9kZScpO1xcblxcdFxcdFxcdFxcdGRwYyA9IFtdO1xcblxcdFxcdFxcdFxcdGZvciAoaSA9IDAsIGogPSBwYXIuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZHBjLnB1c2gocyA/IG1bcGFyLmNoaWxkcmVuW2ldXS50ZXh0IDogbVtwYXIuY2hpbGRyZW5baV1dLnRleHQudG9Mb3dlckNhc2UoKSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGkgPSAxO1xcblxcdFxcdFxcdFxcdHdoaWxlICgkLmluQXJyYXkocyA/IG4gOiBuLnRvTG93ZXJDYXNlKCksIGRwYykgIT09IC0xKSB7XFxuXFx0XFx0XFx0XFx0XFx0biA9IGNiLmNhbGwodGhpcywgdG1wLCArK2kpLnRvU3RyaW5nKCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdG5vZGUudGV4dCA9IG47XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiBwYXJlbnQuY3JlYXRlX25vZGUuY2FsbCh0aGlzLCBwYXIsIG5vZGUsIHBvcywgY2FsbGJhY2ssIGlzX2xvYWRlZCk7XFxuXFx0XFx0fTtcXG5cXHR9O1xcblxcblxcdC8vIGluY2x1ZGUgdGhlIHVuaXF1ZSBwbHVnaW4gYnkgZGVmYXVsdFxcblxcdC8vICQuanN0cmVlLmRlZmF1bHRzLnBsdWdpbnMucHVzaChcXFwidW5pcXVlXFxcIik7XFxuXFxuXFxuXFx0LyoqXFxuICAqICMjIyBXaG9sZXJvdyBwbHVnaW5cXG4gICpcXG4gICogTWFrZXMgZWFjaCBub2RlIGFwcGVhciBibG9jayBsZXZlbC4gTWFraW5nIHNlbGVjdGlvbiBlYXNpZXIuIE1heSBjYXVzZSBzbG93IGRvd24gZm9yIGxhcmdlIHRyZWVzIGluIG9sZCBicm93c2Vycy5cXG4gICovXFxuXFxuXFx0dmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xcblxcdGRpdi5zZXRBdHRyaWJ1dGUoJ3Vuc2VsZWN0YWJsZScsICdvbicpO1xcblxcdGRpdi5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAncHJlc2VudGF0aW9uJyk7XFxuXFx0ZGl2LmNsYXNzTmFtZSA9ICdqc3RyZWUtd2hvbGVyb3cnO1xcblxcdGRpdi5pbm5lckhUTUwgPSAnJiMxNjA7JztcXG5cXHQkLmpzdHJlZS5wbHVnaW5zLndob2xlcm93ID0gZnVuY3Rpb24gKG9wdGlvbnMsIHBhcmVudCkge1xcblxcdFxcdHRoaXMuYmluZCA9IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRwYXJlbnQuYmluZC5jYWxsKHRoaXMpO1xcblxcblxcdFxcdFxcdHRoaXMuZWxlbWVudC5vbigncmVhZHkuanN0cmVlIHNldF9zdGF0ZS5qc3RyZWUnLCAkLnByb3h5KGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLmhpZGVfZG90cygpO1xcblxcdFxcdFxcdH0sIHRoaXMpKS5vbihcXFwiaW5pdC5qc3RyZWUgbG9hZGluZy5qc3RyZWUgcmVhZHkuanN0cmVlXFxcIiwgJC5wcm94eShmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0Ly9kaXYuc3R5bGUuaGVpZ2h0ID0gdGhpcy5fZGF0YS5jb3JlLmxpX2hlaWdodCArICdweCc7XFxuXFx0XFx0XFx0XFx0dGhpcy5nZXRfY29udGFpbmVyX3VsKCkuYWRkQ2xhc3MoJ2pzdHJlZS13aG9sZXJvdy11bCcpO1xcblxcdFxcdFxcdH0sIHRoaXMpKS5vbihcXFwiZGVzZWxlY3RfYWxsLmpzdHJlZVxcXCIsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLmVsZW1lbnQuZmluZCgnLmpzdHJlZS13aG9sZXJvdy1jbGlja2VkJykucmVtb3ZlQ2xhc3MoJ2pzdHJlZS13aG9sZXJvdy1jbGlja2VkJyk7XFxuXFx0XFx0XFx0fSwgdGhpcykpLm9uKFxcXCJjaGFuZ2VkLmpzdHJlZVxcXCIsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLmVsZW1lbnQuZmluZCgnLmpzdHJlZS13aG9sZXJvdy1jbGlja2VkJykucmVtb3ZlQ2xhc3MoJ2pzdHJlZS13aG9sZXJvdy1jbGlja2VkJyk7XFxuXFx0XFx0XFx0XFx0dmFyIHRtcCA9IGZhbHNlLFxcblxcdFxcdFxcdFxcdCAgICBpLFxcblxcdFxcdFxcdFxcdCAgICBqO1xcblxcdFxcdFxcdFxcdGZvciAoaSA9IDAsIGogPSBkYXRhLnNlbGVjdGVkLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdHRtcCA9IHRoaXMuZ2V0X25vZGUoZGF0YS5zZWxlY3RlZFtpXSwgdHJ1ZSk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHRtcCAmJiB0bXAubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dG1wLmNoaWxkcmVuKCcuanN0cmVlLXdob2xlcm93JykuYWRkQ2xhc3MoJ2pzdHJlZS13aG9sZXJvdy1jbGlja2VkJyk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LCB0aGlzKSkub24oXFxcIm9wZW5fbm9kZS5qc3RyZWVcXFwiLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5nZXRfbm9kZShkYXRhLm5vZGUsIHRydWUpLmZpbmQoJy5qc3RyZWUtY2xpY2tlZCcpLnBhcmVudCgpLmNoaWxkcmVuKCcuanN0cmVlLXdob2xlcm93JykuYWRkQ2xhc3MoJ2pzdHJlZS13aG9sZXJvdy1jbGlja2VkJyk7XFxuXFx0XFx0XFx0fSwgdGhpcykpLm9uKFxcXCJob3Zlcl9ub2RlLmpzdHJlZSBkZWhvdmVyX25vZGUuanN0cmVlXFxcIiwgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xcblxcdFxcdFxcdFxcdGlmIChlLnR5cGUgPT09IFxcXCJob3Zlcl9ub2RlXFxcIiAmJiB0aGlzLmlzX2Rpc2FibGVkKGRhdGEubm9kZSkpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHRoaXMuZ2V0X25vZGUoZGF0YS5ub2RlLCB0cnVlKS5jaGlsZHJlbignLmpzdHJlZS13aG9sZXJvdycpW2UudHlwZSA9PT0gXFxcImhvdmVyX25vZGVcXFwiID8gXFxcImFkZENsYXNzXFxcIiA6IFxcXCJyZW1vdmVDbGFzc1xcXCJdKCdqc3RyZWUtd2hvbGVyb3ctaG92ZXJlZCcpO1xcblxcdFxcdFxcdH0sIHRoaXMpKS5vbihcXFwiY29udGV4dG1lbnUuanN0cmVlXFxcIiwgXFxcIi5qc3RyZWUtd2hvbGVyb3dcXFwiLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XFxuXFx0XFx0XFx0XFx0aWYgKHRoaXMuX2RhdGEuY29udGV4dG1lbnUpIHtcXG5cXHRcXHRcXHRcXHRcXHRlLnByZXZlbnREZWZhdWx0KCk7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIHRtcCA9ICQuRXZlbnQoJ2NvbnRleHRtZW51JywgeyBtZXRhS2V5OiBlLm1ldGFLZXksIGN0cmxLZXk6IGUuY3RybEtleSwgYWx0S2V5OiBlLmFsdEtleSwgc2hpZnRLZXk6IGUuc2hpZnRLZXksIHBhZ2VYOiBlLnBhZ2VYLCBwYWdlWTogZS5wYWdlWSB9KTtcXG5cXHRcXHRcXHRcXHRcXHQkKGUuY3VycmVudFRhcmdldCkuY2xvc2VzdChcXFwiLmpzdHJlZS1ub2RlXFxcIikuY2hpbGRyZW4oXFxcIi5qc3RyZWUtYW5jaG9yXFxcIikuZmlyc3QoKS50cmlnZ2VyKHRtcCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sIHRoaXMpKVxcblxcdFxcdFxcdC8qIVxcbiAgIC5vbihcXFwibW91c2Vkb3duLmpzdHJlZSB0b3VjaHN0YXJ0LmpzdHJlZVxcXCIsIFxcXCIuanN0cmVlLXdob2xlcm93XFxcIiwgZnVuY3Rpb24gKGUpIHtcXG4gICBcXHRcXHRpZihlLnRhcmdldCA9PT0gZS5jdXJyZW50VGFyZ2V0KSB7XFxuICAgXFx0XFx0XFx0dmFyIGEgPSAkKGUuY3VycmVudFRhcmdldCkuY2xvc2VzdChcXFwiLmpzdHJlZS1ub2RlXFxcIikuY2hpbGRyZW4oXFxcIi5qc3RyZWUtYW5jaG9yXFxcIik7XFxuICAgXFx0XFx0XFx0ZS50YXJnZXQgPSBhWzBdO1xcbiAgIFxcdFxcdFxcdGEudHJpZ2dlcihlKTtcXG4gICBcXHRcXHR9XFxuICAgXFx0fSlcXG4gICAqL1xcblxcdFxcdFxcdC5vbihcXFwiY2xpY2suanN0cmVlXFxcIiwgXFxcIi5qc3RyZWUtd2hvbGVyb3dcXFwiLCBmdW5jdGlvbiAoZSkge1xcblxcdFxcdFxcdFxcdGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XFxuXFx0XFx0XFx0XFx0dmFyIHRtcCA9ICQuRXZlbnQoJ2NsaWNrJywgeyBtZXRhS2V5OiBlLm1ldGFLZXksIGN0cmxLZXk6IGUuY3RybEtleSwgYWx0S2V5OiBlLmFsdEtleSwgc2hpZnRLZXk6IGUuc2hpZnRLZXkgfSk7XFxuXFx0XFx0XFx0XFx0JChlLmN1cnJlbnRUYXJnZXQpLmNsb3Nlc3QoXFxcIi5qc3RyZWUtbm9kZVxcXCIpLmNoaWxkcmVuKFxcXCIuanN0cmVlLWFuY2hvclxcXCIpLmZpcnN0KCkudHJpZ2dlcih0bXApLmZvY3VzKCk7XFxuXFx0XFx0XFx0fSkub24oXFxcImRibGNsaWNrLmpzdHJlZVxcXCIsIFxcXCIuanN0cmVlLXdob2xlcm93XFxcIiwgZnVuY3Rpb24gKGUpIHtcXG5cXHRcXHRcXHRcXHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xcblxcdFxcdFxcdFxcdHZhciB0bXAgPSAkLkV2ZW50KCdkYmxjbGljaycsIHsgbWV0YUtleTogZS5tZXRhS2V5LCBjdHJsS2V5OiBlLmN0cmxLZXksIGFsdEtleTogZS5hbHRLZXksIHNoaWZ0S2V5OiBlLnNoaWZ0S2V5IH0pO1xcblxcdFxcdFxcdFxcdCQoZS5jdXJyZW50VGFyZ2V0KS5jbG9zZXN0KFxcXCIuanN0cmVlLW5vZGVcXFwiKS5jaGlsZHJlbihcXFwiLmpzdHJlZS1hbmNob3JcXFwiKS5maXJzdCgpLnRyaWdnZXIodG1wKS5mb2N1cygpO1xcblxcdFxcdFxcdH0pLm9uKFxcXCJjbGljay5qc3RyZWVcXFwiLCBcXFwiLmpzdHJlZS1sZWFmID4gLmpzdHJlZS1vY2xcXFwiLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XFxuXFx0XFx0XFx0XFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcXG5cXHRcXHRcXHRcXHR2YXIgdG1wID0gJC5FdmVudCgnY2xpY2snLCB7IG1ldGFLZXk6IGUubWV0YUtleSwgY3RybEtleTogZS5jdHJsS2V5LCBhbHRLZXk6IGUuYWx0S2V5LCBzaGlmdEtleTogZS5zaGlmdEtleSB9KTtcXG5cXHRcXHRcXHRcXHQkKGUuY3VycmVudFRhcmdldCkuY2xvc2VzdChcXFwiLmpzdHJlZS1ub2RlXFxcIikuY2hpbGRyZW4oXFxcIi5qc3RyZWUtYW5jaG9yXFxcIikuZmlyc3QoKS50cmlnZ2VyKHRtcCkuZm9jdXMoKTtcXG5cXHRcXHRcXHR9LCB0aGlzKSkub24oXFxcIm1vdXNlb3Zlci5qc3RyZWVcXFwiLCBcXFwiLmpzdHJlZS13aG9sZXJvdywgLmpzdHJlZS1pY29uXFxcIiwgJC5wcm94eShmdW5jdGlvbiAoZSkge1xcblxcdFxcdFxcdFxcdGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XFxuXFx0XFx0XFx0XFx0aWYgKCF0aGlzLmlzX2Rpc2FibGVkKGUuY3VycmVudFRhcmdldCkpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmhvdmVyX25vZGUoZS5jdXJyZW50VGFyZ2V0KTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH0sIHRoaXMpKS5vbihcXFwibW91c2VsZWF2ZS5qc3RyZWVcXFwiLCBcXFwiLmpzdHJlZS1ub2RlXFxcIiwgJC5wcm94eShmdW5jdGlvbiAoZSkge1xcblxcdFxcdFxcdFxcdHRoaXMuZGVob3Zlcl9ub2RlKGUuY3VycmVudFRhcmdldCk7XFxuXFx0XFx0XFx0fSwgdGhpcykpO1xcblxcdFxcdH07XFxuXFx0XFx0dGhpcy50ZWFyZG93biA9IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRpZiAodGhpcy5zZXR0aW5ncy53aG9sZXJvdykge1xcblxcdFxcdFxcdFxcdHRoaXMuZWxlbWVudC5maW5kKFxcXCIuanN0cmVlLXdob2xlcm93XFxcIikucmVtb3ZlKCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHBhcmVudC50ZWFyZG93bi5jYWxsKHRoaXMpO1xcblxcdFxcdH07XFxuXFx0XFx0dGhpcy5yZWRyYXdfbm9kZSA9IGZ1bmN0aW9uIChvYmosIGRlZXAsIGNhbGxiYWNrLCBmb3JjZV9yZW5kZXIpIHtcXG5cXHRcXHRcXHRvYmogPSBwYXJlbnQucmVkcmF3X25vZGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG5cXHRcXHRcXHRpZiAob2JqKSB7XFxuXFx0XFx0XFx0XFx0dmFyIHRtcCA9IGRpdi5jbG9uZU5vZGUodHJ1ZSk7XFxuXFx0XFx0XFx0XFx0Ly90bXAuc3R5bGUuaGVpZ2h0ID0gdGhpcy5fZGF0YS5jb3JlLmxpX2hlaWdodCArICdweCc7XFxuXFx0XFx0XFx0XFx0aWYgKCQuaW5BcnJheShvYmouaWQsIHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZCkgIT09IC0xKSB7XFxuXFx0XFx0XFx0XFx0XFx0dG1wLmNsYXNzTmFtZSArPSAnIGpzdHJlZS13aG9sZXJvdy1jbGlja2VkJztcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aWYgKHRoaXMuX2RhdGEuY29yZS5mb2N1c2VkICYmIHRoaXMuX2RhdGEuY29yZS5mb2N1c2VkID09PSBvYmouaWQpIHtcXG5cXHRcXHRcXHRcXHRcXHR0bXAuY2xhc3NOYW1lICs9ICcganN0cmVlLXdob2xlcm93LWhvdmVyZWQnO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRvYmouaW5zZXJ0QmVmb3JlKHRtcCwgb2JqLmNoaWxkTm9kZXNbMF0pO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gb2JqO1xcblxcdFxcdH07XFxuXFx0fTtcXG5cXHQvLyBpbmNsdWRlIHRoZSB3aG9sZXJvdyBwbHVnaW4gYnkgZGVmYXVsdFxcblxcdC8vICQuanN0cmVlLmRlZmF1bHRzLnBsdWdpbnMucHVzaChcXFwid2hvbGVyb3dcXFwiKTtcXG5cXHRpZiAoZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50ICYmIE9iamVjdCAmJiBPYmplY3QuY3JlYXRlKSB7XFxuXFx0XFx0dmFyIHByb3RvID0gT2JqZWN0LmNyZWF0ZShIVE1MRWxlbWVudC5wcm90b3R5cGUpO1xcblxcdFxcdHByb3RvLmNyZWF0ZWRDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHR2YXIgYyA9IHsgY29yZToge30sIHBsdWdpbnM6IFtdIH0sXFxuXFx0XFx0XFx0ICAgIGk7XFxuXFx0XFx0XFx0Zm9yIChpIGluICQuanN0cmVlLnBsdWdpbnMpIHtcXG5cXHRcXHRcXHRcXHRpZiAoJC5qc3RyZWUucGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShpKSAmJiB0aGlzLmF0dHJpYnV0ZXNbaV0pIHtcXG5cXHRcXHRcXHRcXHRcXHRjLnBsdWdpbnMucHVzaChpKTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAodGhpcy5nZXRBdHRyaWJ1dGUoaSkgJiYgSlNPTi5wYXJzZSh0aGlzLmdldEF0dHJpYnV0ZShpKSkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRjW2ldID0gSlNPTi5wYXJzZSh0aGlzLmdldEF0dHJpYnV0ZShpKSk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0Zm9yIChpIGluICQuanN0cmVlLmRlZmF1bHRzLmNvcmUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoJC5qc3RyZWUuZGVmYXVsdHMuY29yZS5oYXNPd25Qcm9wZXJ0eShpKSAmJiB0aGlzLmF0dHJpYnV0ZXNbaV0pIHtcXG5cXHRcXHRcXHRcXHRcXHRjLmNvcmVbaV0gPSBKU09OLnBhcnNlKHRoaXMuZ2V0QXR0cmlidXRlKGkpKSB8fCB0aGlzLmdldEF0dHJpYnV0ZShpKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdCQodGhpcykuanN0cmVlKGMpO1xcblxcdFxcdH07XFxuXFx0XFx0Ly8gcHJvdG8uYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrID0gZnVuY3Rpb24gKG5hbWUsIHByZXZpb3VzLCB2YWx1ZSkgeyB9O1xcblxcdFxcdHRyeSB7XFxuXFx0XFx0XFx0ZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KFxcXCJ2YWthdGEtanN0cmVlXFxcIiwgeyBwcm90b3R5cGU6IHByb3RvIH0pO1xcblxcdFxcdH0gY2F0Y2ggKGlnbm9yZSkge31cXG5cXHR9XFxufSk7XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yYXctbG9hZGVyIS4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWI/P3JlZi0tMC0wIS4vYXNzZXRzL2pzL2pzdHJlZS0zLjMuMy5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvcmF3LWxvYWRlci9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTAtMCEuL2Fzc2V0cy9qcy9qc3RyZWUtMy4zLjMuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAzIiwiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc3JjKSB7XG5cdGZ1bmN0aW9uIGxvZyhlcnJvcikge1xuXHRcdCh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIilcblx0XHQmJiAoY29uc29sZS5lcnJvciB8fCBjb25zb2xlLmxvZykoXCJbU2NyaXB0IExvYWRlcl1cIiwgZXJyb3IpO1xuXHR9XG5cblx0Ly8gQ2hlY2sgZm9yIElFID08IDhcblx0ZnVuY3Rpb24gaXNJRSgpIHtcblx0XHRyZXR1cm4gdHlwZW9mIGF0dGFjaEV2ZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBhZGRFdmVudExpc3RlbmVyID09PSBcInVuZGVmaW5lZFwiO1xuXHR9XG5cblx0dHJ5IHtcblx0XHRpZiAodHlwZW9mIGV4ZWNTY3JpcHQgIT09IFwidW5kZWZpbmVkXCIgJiYgaXNJRSgpKSB7XG5cdFx0XHRleGVjU2NyaXB0KHNyYyk7XG5cdFx0fSBlbHNlIGlmICh0eXBlb2YgZXZhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0ZXZhbC5jYWxsKG51bGwsIHNyYyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxvZyhcIkV2YWxFcnJvcjogTm8gZXZhbCBmdW5jdGlvbiBhdmFpbGFibGVcIik7XG5cdFx0fVxuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdGxvZyhlcnJvcik7XG5cdH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMiLCJyZXF1aXJlKFwiISEvaG9tZS9rb25zdGFudGluL3dvcmtzcGFjZS9tbGFiLmxvY2FsLnRlc3Qvbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzXCIpKHJlcXVpcmUoXCIhIS9ob21lL2tvbnN0YW50aW4vd29ya3NwYWNlL21sYWIubG9jYWwudGVzdC9ub2RlX21vZHVsZXMvcmF3LWxvYWRlci9pbmRleC5qcyEvaG9tZS9rb25zdGFudGluL3dvcmtzcGFjZS9tbGFiLmxvY2FsLnRlc3Qvbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMC0wIS9ob21lL2tvbnN0YW50aW4vd29ya3NwYWNlL21sYWIubG9jYWwudGVzdC9hc3NldHMvanMvanN0cmVlLTMuMy4zLmpzXCIpK1wiXFxuXFxuLy8gU0NSSVBULUxPQURFUiBGT09URVJcXG4vLyMgc291cmNlVVJMPXNjcmlwdDovLy9ob21lL2tvbnN0YW50aW4vd29ya3NwYWNlL21sYWIubG9jYWwudGVzdC9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyUzRj9yZWYtLTAtMCEvaG9tZS9rb25zdGFudGluL3dvcmtzcGFjZS9tbGFiLmxvY2FsLnRlc3QvYXNzZXRzL2pzL2pzdHJlZS0zLjMuMy5qc1wiKVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIhLi9hc3NldHMvanMvanN0cmVlLTMuMy4zLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyL2luZGV4LmpzIS4vYXNzZXRzL2pzL2pzdHJlZS0zLjMuMy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDMiXSwic291cmNlUm9vdCI6IiJ9