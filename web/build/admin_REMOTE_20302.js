/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/build/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./assets/js/admin.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./assets/js/admin.js":
/*!****************************!*\
  !*** ./assets/js/admin.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* 
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
__webpack_require__(/*! script-loader!./jstree-3.3.3.js */ "./node_modules/script-loader/index.js!./assets/js/jstree-3.3.3.js");

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./node_modules/babel-loader/lib/index.js?!./assets/js/jstree-3.3.3.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/raw-loader!./node_modules/babel-loader/lib??ref--4-0!./assets/js/jstree-3.3.3.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*globals jQuery, define, module, exports, require, window, document, postMessage */\n(function (factory) {\n  \"use strict\";\n\n  if (typeof define === 'function' && define.amd) {\n    define(['jquery'], factory);\n  } else if (typeof module !== 'undefined' && module.exports) {\n    module.exports = factory(require('jquery'));\n  } else {\n    factory(jQuery);\n  }\n})(function ($, undefined) {\n  \"use strict\";\n  /*!\n   * jsTree 3.3.3\n   * http://jstree.com/\n   *\n   * Copyright (c) 2014 Ivan Bozhanov (http://vakata.com)\n   *\n   * Licensed same as jquery - under the terms of the MIT License\n   *   http://www.opensource.org/licenses/mit-license.php\n   */\n\n  /*!\n   * if using jslint please allow for the jQuery global and use following options:\n   * jslint: loopfunc: true, browser: true, ass: true, bitwise: true, continue: true, nomen: true, plusplus: true, regexp: true, unparam: true, todo: true, white: true\n   */\n\n  /*jshint -W083 */\n  // prevent another load? maybe there is a better way?\n\n  if ($.jstree) {\n    return;\n  }\n  /**\n   * ### jsTree core functionality\n   */\n  // internal variables\n\n\n  var instance_counter = 0,\n      ccp_node = false,\n      ccp_mode = false,\n      ccp_inst = false,\n      themes_loaded = [],\n      src = $('script:last').attr('src'),\n      document = window.document; // local variable is always faster to access then a global\n\n  /**\n   * holds all jstree related functions and variables, including the actual class and methods to create, access and manipulate instances.\n   * @name $.jstree\n   */\n\n  $.jstree = {\n    /**\n     * specifies the jstree version in use\n     * @name $.jstree.version\n     */\n    version: '3.3.3',\n\n    /**\n     * holds all the default options used when creating new instances\n     * @name $.jstree.defaults\n     */\n    defaults: {\n      /**\n       * configure which plugins will be active on an instance. Should be an array of strings, where each element is a plugin name. The default is `[]`\n       * @name $.jstree.defaults.plugins\n       */\n      plugins: []\n    },\n\n    /**\n     * stores all loaded jstree plugins (used internally)\n     * @name $.jstree.plugins\n     */\n    plugins: {},\n    path: src && src.indexOf('/') !== -1 ? src.replace(/\\/[^\\/]+$/, '') : '',\n    idregex: /[\\\\:&!^|()\\[\\]<>@*'+~#\";.,=\\- \\/${}%?`]/g,\n    root: '#'\n  };\n  /**\n   * creates a jstree instance\n   * @name $.jstree.create(el [, options])\n   * @param {DOMElement|jQuery|String} el the element to create the instance on, can be jQuery extended or a selector\n   * @param {Object} options options for this instance (extends `$.jstree.defaults`)\n   * @return {jsTree} the new instance\n   */\n\n  $.jstree.create = function (el, options) {\n    var tmp = new $.jstree.core(++instance_counter),\n        opt = options;\n    options = $.extend(true, {}, $.jstree.defaults, options);\n\n    if (opt && opt.plugins) {\n      options.plugins = opt.plugins;\n    }\n\n    $.each(options.plugins, function (i, k) {\n      if (i !== 'core') {\n        tmp = tmp.plugin(k, options[k]);\n      }\n    });\n    $(el).data('jstree', tmp);\n    tmp.init(el, options);\n    return tmp;\n  };\n  /**\n   * remove all traces of jstree from the DOM and destroy all instances\n   * @name $.jstree.destroy()\n   */\n\n\n  $.jstree.destroy = function () {\n    $('.jstree:jstree').jstree('destroy');\n    $(document).off('.jstree');\n  };\n  /**\n   * the jstree class constructor, used only internally\n   * @private\n   * @name $.jstree.core(id)\n   * @param {Number} id this instance's index\n   */\n\n\n  $.jstree.core = function (id) {\n    this._id = id;\n    this._cnt = 0;\n    this._wrk = null;\n    this._data = {\n      core: {\n        themes: {\n          name: false,\n          dots: false,\n          icons: false,\n          ellipsis: false\n        },\n        selected: [],\n        last_error: {},\n        working: false,\n        worker_queue: [],\n        focused: null\n      }\n    };\n  };\n  /**\n   * get a reference to an existing instance\n   *\n   * __Examples__\n   *\n   *\t// provided a container with an ID of \"tree\", and a nested node with an ID of \"branch\"\n   *\t// all of there will return the same instance\n   *\t$.jstree.reference('tree');\n   *\t$.jstree.reference('#tree');\n   *\t$.jstree.reference($('#tree'));\n   *\t$.jstree.reference(document.getElementByID('tree'));\n   *\t$.jstree.reference('branch');\n   *\t$.jstree.reference('#branch');\n   *\t$.jstree.reference($('#branch'));\n   *\t$.jstree.reference(document.getElementByID('branch'));\n   *\n   * @name $.jstree.reference(needle)\n   * @param {DOMElement|jQuery|String} needle\n   * @return {jsTree|null} the instance or `null` if not found\n   */\n\n\n  $.jstree.reference = function (needle) {\n    var tmp = null,\n        obj = null;\n\n    if (needle && needle.id && (!needle.tagName || !needle.nodeType)) {\n      needle = needle.id;\n    }\n\n    if (!obj || !obj.length) {\n      try {\n        obj = $(needle);\n      } catch (ignore) {}\n    }\n\n    if (!obj || !obj.length) {\n      try {\n        obj = $('#' + needle.replace($.jstree.idregex, '\\\\$&'));\n      } catch (ignore) {}\n    }\n\n    if (obj && obj.length && (obj = obj.closest('.jstree')).length && (obj = obj.data('jstree'))) {\n      tmp = obj;\n    } else {\n      $('.jstree').each(function () {\n        var inst = $(this).data('jstree');\n\n        if (inst && inst._model.data[needle]) {\n          tmp = inst;\n          return false;\n        }\n      });\n    }\n\n    return tmp;\n  };\n  /**\n   * Create an instance, get an instance or invoke a command on a instance.\n   *\n   * If there is no instance associated with the current node a new one is created and `arg` is used to extend `$.jstree.defaults` for this new instance. There would be no return value (chaining is not broken).\n   *\n   * If there is an existing instance and `arg` is a string the command specified by `arg` is executed on the instance, with any additional arguments passed to the function. If the function returns a value it will be returned (chaining could break depending on function).\n   *\n   * If there is an existing instance and `arg` is not a string the instance itself is returned (similar to `$.jstree.reference`).\n   *\n   * In any other case - nothing is returned and chaining is not broken.\n   *\n   * __Examples__\n   *\n   *\t$('#tree1').jstree(); // creates an instance\n   *\t$('#tree2').jstree({ plugins : [] }); // create an instance with some options\n   *\t$('#tree1').jstree('open_node', '#branch_1'); // call a method on an existing instance, passing additional arguments\n   *\t$('#tree2').jstree(); // get an existing instance (or create an instance)\n   *\t$('#tree2').jstree(true); // get an existing instance (will not create new instance)\n   *\t$('#branch_1').jstree().select_node('#branch_1'); // get an instance (using a nested element and call a method)\n   *\n   * @name $().jstree([arg])\n   * @param {String|Object} arg\n   * @return {Mixed}\n   */\n\n\n  $.fn.jstree = function (arg) {\n    // check for string argument\n    var is_method = typeof arg === 'string',\n        args = Array.prototype.slice.call(arguments, 1),\n        result = null;\n\n    if (arg === true && !this.length) {\n      return false;\n    }\n\n    this.each(function () {\n      // get the instance (if there is one) and method (if it exists)\n      var instance = $.jstree.reference(this),\n          method = is_method && instance ? instance[arg] : null; // if calling a method, and method is available - execute on the instance\n\n      result = is_method && method ? method.apply(instance, args) : null; // if there is no instance and no method is being called - create one\n\n      if (!instance && !is_method && (arg === undefined || $.isPlainObject(arg))) {\n        $.jstree.create(this, arg);\n      } // if there is an instance and no method is called - return the instance\n\n\n      if (instance && !is_method || arg === true) {\n        result = instance || false;\n      } // if there was a method call which returned a result - break and return the value\n\n\n      if (result !== null && result !== undefined) {\n        return false;\n      }\n    }); // if there was a method call with a valid return value - return that, otherwise continue the chain\n\n    return result !== null && result !== undefined ? result : this;\n  };\n  /**\n   * used to find elements containing an instance\n   *\n   * __Examples__\n   *\n   *\t$('div:jstree').each(function () {\n   *\t\t$(this).jstree('destroy');\n   *\t});\n   *\n   * @name $(':jstree')\n   * @return {jQuery}\n   */\n\n\n  $.expr.pseudos.jstree = $.expr.createPseudo(function (search) {\n    return function (a) {\n      return $(a).hasClass('jstree') && $(a).data('jstree') !== undefined;\n    };\n  });\n  /**\n   * stores all defaults for the core\n   * @name $.jstree.defaults.core\n   */\n\n  $.jstree.defaults.core = {\n    /**\n     * data configuration\n     *\n     * If left as `false` the HTML inside the jstree container element is used to populate the tree (that should be an unordered list with list items).\n     *\n     * You can also pass in a HTML string or a JSON array here.\n     *\n     * It is possible to pass in a standard jQuery-like AJAX config and jstree will automatically determine if the response is JSON or HTML and use that to populate the tree.\n     * In addition to the standard jQuery ajax options here you can suppy functions for `data` and `url`, the functions will be run in the current instance's scope and a param will be passed indicating which node is being loaded, the return value of those functions will be used.\n     *\n     * The last option is to specify a function, that function will receive the node being loaded as argument and a second param which is a function which should be called with the result.\n     *\n     * __Examples__\n     *\n     *\t// AJAX\n     *\t$('#tree').jstree({\n     *\t\t'core' : {\n     *\t\t\t'data' : {\n     *\t\t\t\t'url' : '/get/children/',\n     *\t\t\t\t'data' : function (node) {\n     *\t\t\t\t\treturn { 'id' : node.id };\n     *\t\t\t\t}\n     *\t\t\t}\n     *\t\t});\n     *\n     *\t// direct data\n     *\t$('#tree').jstree({\n     *\t\t'core' : {\n     *\t\t\t'data' : [\n     *\t\t\t\t'Simple root node',\n     *\t\t\t\t{\n     *\t\t\t\t\t'id' : 'node_2',\n     *\t\t\t\t\t'text' : 'Root node with options',\n     *\t\t\t\t\t'state' : { 'opened' : true, 'selected' : true },\n     *\t\t\t\t\t'children' : [ { 'text' : 'Child 1' }, 'Child 2']\n     *\t\t\t\t}\n     *\t\t\t]\n     *\t\t}\n     *\t});\n     *\n     *\t// function\n     *\t$('#tree').jstree({\n     *\t\t'core' : {\n     *\t\t\t'data' : function (obj, callback) {\n     *\t\t\t\tcallback.call(this, ['Root 1', 'Root 2']);\n     *\t\t\t}\n     *\t\t});\n     *\n     * @name $.jstree.defaults.core.data\n     */\n    data: false,\n\n    /**\n     * configure the various strings used throughout the tree\n     *\n     * You can use an object where the key is the string you need to replace and the value is your replacement.\n     * Another option is to specify a function which will be called with an argument of the needed string and should return the replacement.\n     * If left as `false` no replacement is made.\n     *\n     * __Examples__\n     *\n     *\t$('#tree').jstree({\n     *\t\t'core' : {\n     *\t\t\t'strings' : {\n     *\t\t\t\t'Loading ...' : 'Please wait ...'\n     *\t\t\t}\n     *\t\t}\n     *\t});\n     *\n     * @name $.jstree.defaults.core.strings\n     */\n    strings: false,\n\n    /**\n     * determines what happens when a user tries to modify the structure of the tree\n     * If left as `false` all operations like create, rename, delete, move or copy are prevented.\n     * You can set this to `true` to allow all interactions or use a function to have better control.\n     *\n     * __Examples__\n     *\n     *\t$('#tree').jstree({\n     *\t\t'core' : {\n     *\t\t\t'check_callback' : function (operation, node, node_parent, node_position, more) {\n     *\t\t\t\t// operation can be 'create_node', 'rename_node', 'delete_node', 'move_node' or 'copy_node'\n     *\t\t\t\t// in case of 'rename_node' node_position is filled with the new node name\n     *\t\t\t\treturn operation === 'rename_node' ? true : false;\n     *\t\t\t}\n     *\t\t}\n     *\t});\n     *\n     * @name $.jstree.defaults.core.check_callback\n     */\n    check_callback: false,\n\n    /**\n     * a callback called with a single object parameter in the instance's scope when something goes wrong (operation prevented, ajax failed, etc)\n     * @name $.jstree.defaults.core.error\n     */\n    error: $.noop,\n\n    /**\n     * the open / close animation duration in milliseconds - set this to `false` to disable the animation (default is `200`)\n     * @name $.jstree.defaults.core.animation\n     */\n    animation: 200,\n\n    /**\n     * a boolean indicating if multiple nodes can be selected\n     * @name $.jstree.defaults.core.multiple\n     */\n    multiple: true,\n\n    /**\n     * theme configuration object\n     * @name $.jstree.defaults.core.themes\n     */\n    themes: {\n      /**\n       * the name of the theme to use (if left as `false` the default theme is used)\n       * @name $.jstree.defaults.core.themes.name\n       */\n      name: false,\n\n      /**\n       * the URL of the theme's CSS file, leave this as `false` if you have manually included the theme CSS (recommended). You can set this to `true` too which will try to autoload the theme.\n       * @name $.jstree.defaults.core.themes.url\n       */\n      url: false,\n\n      /**\n       * the location of all jstree themes - only used if `url` is set to `true`\n       * @name $.jstree.defaults.core.themes.dir\n       */\n      dir: false,\n\n      /**\n       * a boolean indicating if connecting dots are shown\n       * @name $.jstree.defaults.core.themes.dots\n       */\n      dots: true,\n\n      /**\n       * a boolean indicating if node icons are shown\n       * @name $.jstree.defaults.core.themes.icons\n       */\n      icons: true,\n\n      /**\n       * a boolean indicating if node ellipsis should be shown - this only works with a fixed with on the container\n       * @name $.jstree.defaults.core.themes.ellipsis\n       */\n      ellipsis: false,\n\n      /**\n       * a boolean indicating if the tree background is striped\n       * @name $.jstree.defaults.core.themes.stripes\n       */\n      stripes: false,\n\n      /**\n       * a string (or boolean `false`) specifying the theme variant to use (if the theme supports variants)\n       * @name $.jstree.defaults.core.themes.variant\n       */\n      variant: false,\n\n      /**\n       * a boolean specifying if a reponsive version of the theme should kick in on smaller screens (if the theme supports it). Defaults to `false`.\n       * @name $.jstree.defaults.core.themes.responsive\n       */\n      responsive: false\n    },\n\n    /**\n     * if left as `true` all parents of all selected nodes will be opened once the tree loads (so that all selected nodes are visible to the user)\n     * @name $.jstree.defaults.core.expand_selected_onload\n     */\n    expand_selected_onload: true,\n\n    /**\n     * if left as `true` web workers will be used to parse incoming JSON data where possible, so that the UI will not be blocked by large requests. Workers are however about 30% slower. Defaults to `true`\n     * @name $.jstree.defaults.core.worker\n     */\n    worker: true,\n\n    /**\n     * Force node text to plain text (and escape HTML). Defaults to `false`\n     * @name $.jstree.defaults.core.force_text\n     */\n    force_text: false,\n\n    /**\n     * Should the node should be toggled if the text is double clicked . Defaults to `true`\n     * @name $.jstree.defaults.core.dblclick_toggle\n     */\n    dblclick_toggle: true\n  };\n  $.jstree.core.prototype = {\n    /**\n     * used to decorate an instance with a plugin. Used internally.\n     * @private\n     * @name plugin(deco [, opts])\n     * @param  {String} deco the plugin to decorate with\n     * @param  {Object} opts options for the plugin\n     * @return {jsTree}\n     */\n    plugin: function plugin(deco, opts) {\n      var Child = $.jstree.plugins[deco];\n\n      if (Child) {\n        this._data[deco] = {};\n        Child.prototype = this;\n        return new Child(opts, this);\n      }\n\n      return this;\n    },\n\n    /**\n     * initialize the instance. Used internally.\n     * @private\n     * @name init(el, optons)\n     * @param {DOMElement|jQuery|String} el the element we are transforming\n     * @param {Object} options options for this instance\n     * @trigger init.jstree, loading.jstree, loaded.jstree, ready.jstree, changed.jstree\n     */\n    init: function init(el, options) {\n      this._model = {\n        data: {},\n        changed: [],\n        force_full_redraw: false,\n        redraw_timeout: false,\n        default_state: {\n          loaded: true,\n          opened: false,\n          selected: false,\n          disabled: false\n        }\n      };\n      this._model.data[$.jstree.root] = {\n        id: $.jstree.root,\n        parent: null,\n        parents: [],\n        children: [],\n        children_d: [],\n        state: {\n          loaded: false\n        }\n      };\n      this.element = $(el).addClass('jstree jstree-' + this._id);\n      this.settings = options;\n      this._data.core.ready = false;\n      this._data.core.loaded = false;\n      this._data.core.rtl = this.element.css(\"direction\") === \"rtl\";\n      this.element[this._data.core.rtl ? 'addClass' : 'removeClass'](\"jstree-rtl\");\n      this.element.attr('role', 'tree');\n\n      if (this.settings.core.multiple) {\n        this.element.attr('aria-multiselectable', true);\n      }\n\n      if (!this.element.attr('tabindex')) {\n        this.element.attr('tabindex', '0');\n      }\n\n      this.bind();\n      /**\n       * triggered after all events are bound\n       * @event\n       * @name init.jstree\n       */\n\n      this.trigger(\"init\");\n      this._data.core.original_container_html = this.element.find(\" > ul > li\").clone(true);\n\n      this._data.core.original_container_html.find(\"li\").addBack().contents().filter(function () {\n        return this.nodeType === 3 && (!this.nodeValue || /^\\s+$/.test(this.nodeValue));\n      }).remove();\n\n      this.element.html(\"<\" + \"ul class='jstree-container-ul jstree-children' role='group'><\" + \"li id='j\" + this._id + \"_loading' class='jstree-initial-node jstree-loading jstree-leaf jstree-last' role='tree-item'><i class='jstree-icon jstree-ocl'></i><\" + \"a class='jstree-anchor' href='#'><i class='jstree-icon jstree-themeicon-hidden'></i>\" + this.get_string(\"Loading ...\") + \"</a></li></ul>\");\n      this.element.attr('aria-activedescendant', 'j' + this._id + '_loading');\n      this._data.core.li_height = this.get_container_ul().children(\"li\").first().height() || 24;\n      this._data.core.node = this._create_prototype_node();\n      /**\n       * triggered after the loading text is shown and before loading starts\n       * @event\n       * @name loading.jstree\n       */\n\n      this.trigger(\"loading\");\n      this.load_node($.jstree.root);\n    },\n\n    /**\n     * destroy an instance\n     * @name destroy()\n     * @param  {Boolean} keep_html if not set to `true` the container will be emptied, otherwise the current DOM elements will be kept intact\n     */\n    destroy: function destroy(keep_html) {\n      if (this._wrk) {\n        try {\n          window.URL.revokeObjectURL(this._wrk);\n          this._wrk = null;\n        } catch (ignore) {}\n      }\n\n      if (!keep_html) {\n        this.element.empty();\n      }\n\n      this.teardown();\n    },\n\n    /**\n     * Create prototype node\n     */\n    _create_prototype_node: function _create_prototype_node() {\n      var _node = document.createElement('LI'),\n          _temp1,\n          _temp2;\n\n      _node.setAttribute('role', 'treeitem');\n\n      _temp1 = document.createElement('I');\n      _temp1.className = 'jstree-icon jstree-ocl';\n\n      _temp1.setAttribute('role', 'presentation');\n\n      _node.appendChild(_temp1);\n\n      _temp1 = document.createElement('A');\n      _temp1.className = 'jstree-anchor';\n\n      _temp1.setAttribute('href', '#');\n\n      _temp1.setAttribute('tabindex', '-1');\n\n      _temp2 = document.createElement('I');\n      _temp2.className = 'jstree-icon jstree-themeicon';\n\n      _temp2.setAttribute('role', 'presentation');\n\n      _temp1.appendChild(_temp2);\n\n      _node.appendChild(_temp1);\n\n      _temp1 = _temp2 = null;\n      return _node;\n    },\n\n    /**\n     * part of the destroying of an instance. Used internally.\n     * @private\n     * @name teardown()\n     */\n    teardown: function teardown() {\n      this.unbind();\n      this.element.removeClass('jstree').removeData('jstree').find(\"[class^='jstree']\").addBack().attr(\"class\", function () {\n        return this.className.replace(/jstree[^ ]*|$/ig, '');\n      });\n      this.element = null;\n    },\n\n    /**\n     * bind all events. Used internally.\n     * @private\n     * @name bind()\n     */\n    bind: function bind() {\n      var word = '',\n          tout = null,\n          was_click = 0;\n      this.element.on(\"dblclick.jstree\", function (e) {\n        if (e.target.tagName && e.target.tagName.toLowerCase() === \"input\") {\n          return true;\n        }\n\n        if (document.selection && document.selection.empty) {\n          document.selection.empty();\n        } else {\n          if (window.getSelection) {\n            var sel = window.getSelection();\n\n            try {\n              sel.removeAllRanges();\n              sel.collapse();\n            } catch (ignore) {}\n          }\n        }\n      }).on(\"mousedown.jstree\", $.proxy(function (e) {\n        if (e.target === this.element[0]) {\n          e.preventDefault(); // prevent losing focus when clicking scroll arrows (FF, Chrome)\n\n          was_click = +new Date(); // ie does not allow to prevent losing focus\n        }\n      }, this)).on(\"mousedown.jstree\", \".jstree-ocl\", function (e) {\n        e.preventDefault(); // prevent any node inside from losing focus when clicking the open/close icon\n      }).on(\"click.jstree\", \".jstree-ocl\", $.proxy(function (e) {\n        this.toggle_node(e.target);\n      }, this)).on(\"dblclick.jstree\", \".jstree-anchor\", $.proxy(function (e) {\n        if (e.target.tagName && e.target.tagName.toLowerCase() === \"input\") {\n          return true;\n        }\n\n        if (this.settings.core.dblclick_toggle) {\n          this.toggle_node(e.target);\n        }\n      }, this)).on(\"click.jstree\", \".jstree-anchor\", $.proxy(function (e) {\n        e.preventDefault();\n\n        if (e.currentTarget !== document.activeElement) {\n          $(e.currentTarget).focus();\n        }\n\n        this.activate_node(e.currentTarget, e);\n      }, this)).on('keydown.jstree', '.jstree-anchor', $.proxy(function (e) {\n        if (e.target.tagName && e.target.tagName.toLowerCase() === \"input\") {\n          return true;\n        }\n\n        if (e.which !== 32 && e.which !== 13 && (e.shiftKey || e.ctrlKey || e.altKey || e.metaKey)) {\n          return true;\n        }\n\n        var o = null;\n\n        if (this._data.core.rtl) {\n          if (e.which === 37) {\n            e.which = 39;\n          } else if (e.which === 39) {\n            e.which = 37;\n          }\n        }\n\n        switch (e.which) {\n          case 32:\n            // aria defines space only with Ctrl\n            if (e.ctrlKey) {\n              e.type = \"click\";\n              $(e.currentTarget).trigger(e);\n            }\n\n            break;\n\n          case 13:\n            // enter\n            e.type = \"click\";\n            $(e.currentTarget).trigger(e);\n            break;\n\n          case 37:\n            // left\n            e.preventDefault();\n\n            if (this.is_open(e.currentTarget)) {\n              this.close_node(e.currentTarget);\n            } else {\n              o = this.get_parent(e.currentTarget);\n\n              if (o && o.id !== $.jstree.root) {\n                this.get_node(o, true).children('.jstree-anchor').focus();\n              }\n            }\n\n            break;\n\n          case 38:\n            // up\n            e.preventDefault();\n            o = this.get_prev_dom(e.currentTarget);\n\n            if (o && o.length) {\n              o.children('.jstree-anchor').focus();\n            }\n\n            break;\n\n          case 39:\n            // right\n            e.preventDefault();\n\n            if (this.is_closed(e.currentTarget)) {\n              this.open_node(e.currentTarget, function (o) {\n                this.get_node(o, true).children('.jstree-anchor').focus();\n              });\n            } else if (this.is_open(e.currentTarget)) {\n              o = this.get_node(e.currentTarget, true).children('.jstree-children')[0];\n\n              if (o) {\n                $(this._firstChild(o)).children('.jstree-anchor').focus();\n              }\n            }\n\n            break;\n\n          case 40:\n            // down\n            e.preventDefault();\n            o = this.get_next_dom(e.currentTarget);\n\n            if (o && o.length) {\n              o.children('.jstree-anchor').focus();\n            }\n\n            break;\n\n          case 106:\n            // aria defines * on numpad as open_all - not very common\n            this.open_all();\n            break;\n\n          case 36:\n            // home\n            e.preventDefault();\n            o = this._firstChild(this.get_container_ul()[0]);\n\n            if (o) {\n              $(o).children('.jstree-anchor').filter(':visible').focus();\n            }\n\n            break;\n\n          case 35:\n            // end\n            e.preventDefault();\n            this.element.find('.jstree-anchor').filter(':visible').last().focus();\n            break;\n\n          case 113:\n            // f2 - safe to include - if check_callback is false it will fail\n            e.preventDefault();\n            this.edit(e.currentTarget);\n            break;\n\n          default:\n            break;\n\n          /*!\n          // delete\n          case 46:\n          \te.preventDefault();\n          \to = this.get_node(e.currentTarget);\n          \tif(o && o.id && o.id !== $.jstree.root) {\n          \t\to = this.is_selected(o) ? this.get_selected() : o;\n          \t\tthis.delete_node(o);\n          \t}\n          \tbreak;\n          \t*/\n        }\n      }, this)).on(\"load_node.jstree\", $.proxy(function (e, data) {\n        if (data.status) {\n          if (data.node.id === $.jstree.root && !this._data.core.loaded) {\n            this._data.core.loaded = true;\n\n            if (this._firstChild(this.get_container_ul()[0])) {\n              this.element.attr('aria-activedescendant', this._firstChild(this.get_container_ul()[0]).id);\n            }\n            /**\n             * triggered after the root node is loaded for the first time\n             * @event\n             * @name loaded.jstree\n             */\n\n\n            this.trigger(\"loaded\");\n          }\n\n          if (!this._data.core.ready) {\n            setTimeout($.proxy(function () {\n              if (this.element && !this.get_container_ul().find('.jstree-loading').length) {\n                this._data.core.ready = true;\n\n                if (this._data.core.selected.length) {\n                  if (this.settings.core.expand_selected_onload) {\n                    var tmp = [],\n                        i,\n                        j;\n\n                    for (i = 0, j = this._data.core.selected.length; i < j; i++) {\n                      tmp = tmp.concat(this._model.data[this._data.core.selected[i]].parents);\n                    }\n\n                    tmp = $.vakata.array_unique(tmp);\n\n                    for (i = 0, j = tmp.length; i < j; i++) {\n                      this.open_node(tmp[i], false, 0);\n                    }\n                  }\n\n                  this.trigger('changed', {\n                    'action': 'ready',\n                    'selected': this._data.core.selected\n                  });\n                }\n                /**\n                 * triggered after all nodes are finished loading\n                 * @event\n                 * @name ready.jstree\n                 */\n\n\n                this.trigger(\"ready\");\n              }\n            }, this), 0);\n          }\n        }\n      }, this)) // quick searching when the tree is focused\n      .on('keypress.jstree', $.proxy(function (e) {\n        if (e.target.tagName && e.target.tagName.toLowerCase() === \"input\") {\n          return true;\n        }\n\n        if (tout) {\n          clearTimeout(tout);\n        }\n\n        tout = setTimeout(function () {\n          word = '';\n        }, 500);\n        var chr = String.fromCharCode(e.which).toLowerCase(),\n            col = this.element.find('.jstree-anchor').filter(':visible'),\n            ind = col.index(document.activeElement) || 0,\n            end = false;\n        word += chr; // match for whole word from current node down (including the current node)\n\n        if (word.length > 1) {\n          col.slice(ind).each($.proxy(function (i, v) {\n            if ($(v).text().toLowerCase().indexOf(word) === 0) {\n              $(v).focus();\n              end = true;\n              return false;\n            }\n          }, this));\n\n          if (end) {\n            return;\n          } // match for whole word from the beginning of the tree\n\n\n          col.slice(0, ind).each($.proxy(function (i, v) {\n            if ($(v).text().toLowerCase().indexOf(word) === 0) {\n              $(v).focus();\n              end = true;\n              return false;\n            }\n          }, this));\n\n          if (end) {\n            return;\n          }\n        } // list nodes that start with that letter (only if word consists of a single char)\n\n\n        if (new RegExp('^' + chr.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&') + '+$').test(word)) {\n          // search for the next node starting with that letter\n          col.slice(ind + 1).each($.proxy(function (i, v) {\n            if ($(v).text().toLowerCase().charAt(0) === chr) {\n              $(v).focus();\n              end = true;\n              return false;\n            }\n          }, this));\n\n          if (end) {\n            return;\n          } // search from the beginning\n\n\n          col.slice(0, ind + 1).each($.proxy(function (i, v) {\n            if ($(v).text().toLowerCase().charAt(0) === chr) {\n              $(v).focus();\n              end = true;\n              return false;\n            }\n          }, this));\n\n          if (end) {\n            return;\n          }\n        }\n      }, this)) // THEME RELATED\n      .on(\"init.jstree\", $.proxy(function () {\n        var s = this.settings.core.themes;\n        this._data.core.themes.dots = s.dots;\n        this._data.core.themes.stripes = s.stripes;\n        this._data.core.themes.icons = s.icons;\n        this._data.core.themes.ellipsis = s.ellipsis;\n        this.set_theme(s.name || \"default\", s.url);\n        this.set_theme_variant(s.variant);\n      }, this)).on(\"loading.jstree\", $.proxy(function () {\n        this[this._data.core.themes.dots ? \"show_dots\" : \"hide_dots\"]();\n        this[this._data.core.themes.icons ? \"show_icons\" : \"hide_icons\"]();\n        this[this._data.core.themes.stripes ? \"show_stripes\" : \"hide_stripes\"]();\n        this[this._data.core.themes.ellipsis ? \"show_ellipsis\" : \"hide_ellipsis\"]();\n      }, this)).on('blur.jstree', '.jstree-anchor', $.proxy(function (e) {\n        this._data.core.focused = null;\n        $(e.currentTarget).filter('.jstree-hovered').mouseleave();\n        this.element.attr('tabindex', '0');\n      }, this)).on('focus.jstree', '.jstree-anchor', $.proxy(function (e) {\n        var tmp = this.get_node(e.currentTarget);\n\n        if (tmp && tmp.id) {\n          this._data.core.focused = tmp.id;\n        }\n\n        this.element.find('.jstree-hovered').not(e.currentTarget).mouseleave();\n        $(e.currentTarget).mouseenter();\n        this.element.attr('tabindex', '-1');\n      }, this)).on('focus.jstree', $.proxy(function () {\n        if (+new Date() - was_click > 500 && !this._data.core.focused) {\n          was_click = 0;\n          var act = this.get_node(this.element.attr('aria-activedescendant'), true);\n\n          if (act) {\n            act.find('> .jstree-anchor').focus();\n          }\n        }\n      }, this)).on('mouseenter.jstree', '.jstree-anchor', $.proxy(function (e) {\n        this.hover_node(e.currentTarget);\n      }, this)).on('mouseleave.jstree', '.jstree-anchor', $.proxy(function (e) {\n        this.dehover_node(e.currentTarget);\n      }, this));\n    },\n\n    /**\n     * part of the destroying of an instance. Used internally.\n     * @private\n     * @name unbind()\n     */\n    unbind: function unbind() {\n      this.element.off('.jstree');\n      $(document).off('.jstree-' + this._id);\n    },\n\n    /**\n     * trigger an event. Used internally.\n     * @private\n     * @name trigger(ev [, data])\n     * @param  {String} ev the name of the event to trigger\n     * @param  {Object} data additional data to pass with the event\n     */\n    trigger: function trigger(ev, data) {\n      if (!data) {\n        data = {};\n      }\n\n      data.instance = this;\n      this.element.triggerHandler(ev.replace('.jstree', '') + '.jstree', data);\n    },\n\n    /**\n     * returns the jQuery extended instance container\n     * @name get_container()\n     * @return {jQuery}\n     */\n    get_container: function get_container() {\n      return this.element;\n    },\n\n    /**\n     * returns the jQuery extended main UL node inside the instance container. Used internally.\n     * @private\n     * @name get_container_ul()\n     * @return {jQuery}\n     */\n    get_container_ul: function get_container_ul() {\n      return this.element.children(\".jstree-children\").first();\n    },\n\n    /**\n     * gets string replacements (localization). Used internally.\n     * @private\n     * @name get_string(key)\n     * @param  {String} key\n     * @return {String}\n     */\n    get_string: function get_string(key) {\n      var a = this.settings.core.strings;\n\n      if ($.isFunction(a)) {\n        return a.call(this, key);\n      }\n\n      if (a && a[key]) {\n        return a[key];\n      }\n\n      return key;\n    },\n\n    /**\n     * gets the first child of a DOM node. Used internally.\n     * @private\n     * @name _firstChild(dom)\n     * @param  {DOMElement} dom\n     * @return {DOMElement}\n     */\n    _firstChild: function _firstChild(dom) {\n      dom = dom ? dom.firstChild : null;\n\n      while (dom !== null && dom.nodeType !== 1) {\n        dom = dom.nextSibling;\n      }\n\n      return dom;\n    },\n\n    /**\n     * gets the next sibling of a DOM node. Used internally.\n     * @private\n     * @name _nextSibling(dom)\n     * @param  {DOMElement} dom\n     * @return {DOMElement}\n     */\n    _nextSibling: function _nextSibling(dom) {\n      dom = dom ? dom.nextSibling : null;\n\n      while (dom !== null && dom.nodeType !== 1) {\n        dom = dom.nextSibling;\n      }\n\n      return dom;\n    },\n\n    /**\n     * gets the previous sibling of a DOM node. Used internally.\n     * @private\n     * @name _previousSibling(dom)\n     * @param  {DOMElement} dom\n     * @return {DOMElement}\n     */\n    _previousSibling: function _previousSibling(dom) {\n      dom = dom ? dom.previousSibling : null;\n\n      while (dom !== null && dom.nodeType !== 1) {\n        dom = dom.previousSibling;\n      }\n\n      return dom;\n    },\n\n    /**\n     * get the JSON representation of a node (or the actual jQuery extended DOM node) by using any input (child DOM element, ID string, selector, etc)\n     * @name get_node(obj [, as_dom])\n     * @param  {mixed} obj\n     * @param  {Boolean} as_dom\n     * @return {Object|jQuery}\n     */\n    get_node: function get_node(obj, as_dom) {\n      if (obj && obj.id) {\n        obj = obj.id;\n      }\n\n      var dom;\n\n      try {\n        if (this._model.data[obj]) {\n          obj = this._model.data[obj];\n        } else if (typeof obj === \"string\" && this._model.data[obj.replace(/^#/, '')]) {\n          obj = this._model.data[obj.replace(/^#/, '')];\n        } else if (typeof obj === \"string\" && (dom = $('#' + obj.replace($.jstree.idregex, '\\\\$&'), this.element)).length && this._model.data[dom.closest('.jstree-node').attr('id')]) {\n          obj = this._model.data[dom.closest('.jstree-node').attr('id')];\n        } else if ((dom = $(obj, this.element)).length && this._model.data[dom.closest('.jstree-node').attr('id')]) {\n          obj = this._model.data[dom.closest('.jstree-node').attr('id')];\n        } else if ((dom = $(obj, this.element)).length && dom.hasClass('jstree')) {\n          obj = this._model.data[$.jstree.root];\n        } else {\n          return false;\n        }\n\n        if (as_dom) {\n          obj = obj.id === $.jstree.root ? this.element : $('#' + obj.id.replace($.jstree.idregex, '\\\\$&'), this.element);\n        }\n\n        return obj;\n      } catch (ex) {\n        return false;\n      }\n    },\n\n    /**\n     * get the path to a node, either consisting of node texts, or of node IDs, optionally glued together (otherwise an array)\n     * @name get_path(obj [, glue, ids])\n     * @param  {mixed} obj the node\n     * @param  {String} glue if you want the path as a string - pass the glue here (for example '/'), if a falsy value is supplied here, an array is returned\n     * @param  {Boolean} ids if set to true build the path using ID, otherwise node text is used\n     * @return {mixed}\n     */\n    get_path: function get_path(obj, glue, ids) {\n      obj = obj.parents ? obj : this.get_node(obj);\n\n      if (!obj || obj.id === $.jstree.root || !obj.parents) {\n        return false;\n      }\n\n      var i,\n          j,\n          p = [];\n      p.push(ids ? obj.id : obj.text);\n\n      for (i = 0, j = obj.parents.length; i < j; i++) {\n        p.push(ids ? obj.parents[i] : this.get_text(obj.parents[i]));\n      }\n\n      p = p.reverse().slice(1);\n      return glue ? p.join(glue) : p;\n    },\n\n    /**\n     * get the next visible node that is below the `obj` node. If `strict` is set to `true` only sibling nodes are returned.\n     * @name get_next_dom(obj [, strict])\n     * @param  {mixed} obj\n     * @param  {Boolean} strict\n     * @return {jQuery}\n     */\n    get_next_dom: function get_next_dom(obj, strict) {\n      var tmp;\n      obj = this.get_node(obj, true);\n\n      if (obj[0] === this.element[0]) {\n        tmp = this._firstChild(this.get_container_ul()[0]);\n\n        while (tmp && tmp.offsetHeight === 0) {\n          tmp = this._nextSibling(tmp);\n        }\n\n        return tmp ? $(tmp) : false;\n      }\n\n      if (!obj || !obj.length) {\n        return false;\n      }\n\n      if (strict) {\n        tmp = obj[0];\n\n        do {\n          tmp = this._nextSibling(tmp);\n        } while (tmp && tmp.offsetHeight === 0);\n\n        return tmp ? $(tmp) : false;\n      }\n\n      if (obj.hasClass(\"jstree-open\")) {\n        tmp = this._firstChild(obj.children('.jstree-children')[0]);\n\n        while (tmp && tmp.offsetHeight === 0) {\n          tmp = this._nextSibling(tmp);\n        }\n\n        if (tmp !== null) {\n          return $(tmp);\n        }\n      }\n\n      tmp = obj[0];\n\n      do {\n        tmp = this._nextSibling(tmp);\n      } while (tmp && tmp.offsetHeight === 0);\n\n      if (tmp !== null) {\n        return $(tmp);\n      }\n\n      return obj.parentsUntil(\".jstree\", \".jstree-node\").nextAll(\".jstree-node:visible\").first();\n    },\n\n    /**\n     * get the previous visible node that is above the `obj` node. If `strict` is set to `true` only sibling nodes are returned.\n     * @name get_prev_dom(obj [, strict])\n     * @param  {mixed} obj\n     * @param  {Boolean} strict\n     * @return {jQuery}\n     */\n    get_prev_dom: function get_prev_dom(obj, strict) {\n      var tmp;\n      obj = this.get_node(obj, true);\n\n      if (obj[0] === this.element[0]) {\n        tmp = this.get_container_ul()[0].lastChild;\n\n        while (tmp && tmp.offsetHeight === 0) {\n          tmp = this._previousSibling(tmp);\n        }\n\n        return tmp ? $(tmp) : false;\n      }\n\n      if (!obj || !obj.length) {\n        return false;\n      }\n\n      if (strict) {\n        tmp = obj[0];\n\n        do {\n          tmp = this._previousSibling(tmp);\n        } while (tmp && tmp.offsetHeight === 0);\n\n        return tmp ? $(tmp) : false;\n      }\n\n      tmp = obj[0];\n\n      do {\n        tmp = this._previousSibling(tmp);\n      } while (tmp && tmp.offsetHeight === 0);\n\n      if (tmp !== null) {\n        obj = $(tmp);\n\n        while (obj.hasClass(\"jstree-open\")) {\n          obj = obj.children(\".jstree-children\").first().children(\".jstree-node:visible:last\");\n        }\n\n        return obj;\n      }\n\n      tmp = obj[0].parentNode.parentNode;\n      return tmp && tmp.className && tmp.className.indexOf('jstree-node') !== -1 ? $(tmp) : false;\n    },\n\n    /**\n     * get the parent ID of a node\n     * @name get_parent(obj)\n     * @param  {mixed} obj\n     * @return {String}\n     */\n    get_parent: function get_parent(obj) {\n      obj = this.get_node(obj);\n\n      if (!obj || obj.id === $.jstree.root) {\n        return false;\n      }\n\n      return obj.parent;\n    },\n\n    /**\n     * get a jQuery collection of all the children of a node (node must be rendered)\n     * @name get_children_dom(obj)\n     * @param  {mixed} obj\n     * @return {jQuery}\n     */\n    get_children_dom: function get_children_dom(obj) {\n      obj = this.get_node(obj, true);\n\n      if (obj[0] === this.element[0]) {\n        return this.get_container_ul().children(\".jstree-node\");\n      }\n\n      if (!obj || !obj.length) {\n        return false;\n      }\n\n      return obj.children(\".jstree-children\").children(\".jstree-node\");\n    },\n\n    /**\n     * checks if a node has children\n     * @name is_parent(obj)\n     * @param  {mixed} obj\n     * @return {Boolean}\n     */\n    is_parent: function is_parent(obj) {\n      obj = this.get_node(obj);\n      return obj && (obj.state.loaded === false || obj.children.length > 0);\n    },\n\n    /**\n     * checks if a node is loaded (its children are available)\n     * @name is_loaded(obj)\n     * @param  {mixed} obj\n     * @return {Boolean}\n     */\n    is_loaded: function is_loaded(obj) {\n      obj = this.get_node(obj);\n      return obj && obj.state.loaded;\n    },\n\n    /**\n     * check if a node is currently loading (fetching children)\n     * @name is_loading(obj)\n     * @param  {mixed} obj\n     * @return {Boolean}\n     */\n    is_loading: function is_loading(obj) {\n      obj = this.get_node(obj);\n      return obj && obj.state && obj.state.loading;\n    },\n\n    /**\n     * check if a node is opened\n     * @name is_open(obj)\n     * @param  {mixed} obj\n     * @return {Boolean}\n     */\n    is_open: function is_open(obj) {\n      obj = this.get_node(obj);\n      return obj && obj.state.opened;\n    },\n\n    /**\n     * check if a node is in a closed state\n     * @name is_closed(obj)\n     * @param  {mixed} obj\n     * @return {Boolean}\n     */\n    is_closed: function is_closed(obj) {\n      obj = this.get_node(obj);\n      return obj && this.is_parent(obj) && !obj.state.opened;\n    },\n\n    /**\n     * check if a node has no children\n     * @name is_leaf(obj)\n     * @param  {mixed} obj\n     * @return {Boolean}\n     */\n    is_leaf: function is_leaf(obj) {\n      return !this.is_parent(obj);\n    },\n\n    /**\n     * loads a node (fetches its children using the `core.data` setting). Multiple nodes can be passed to by using an array.\n     * @name load_node(obj [, callback])\n     * @param  {mixed} obj\n     * @param  {function} callback a function to be executed once loading is complete, the function is executed in the instance's scope and receives two arguments - the node and a boolean status\n     * @return {Boolean}\n     * @trigger load_node.jstree\n     */\n    load_node: function load_node(obj, callback) {\n      var k, l, i, j, c;\n\n      if ($.isArray(obj)) {\n        this._load_nodes(obj.slice(), callback);\n\n        return true;\n      }\n\n      obj = this.get_node(obj);\n\n      if (!obj) {\n        if (callback) {\n          callback.call(this, obj, false);\n        }\n\n        return false;\n      } // if(obj.state.loading) { } // the node is already loading - just wait for it to load and invoke callback? but if called implicitly it should be loaded again?\n\n\n      if (obj.state.loaded) {\n        obj.state.loaded = false;\n\n        for (i = 0, j = obj.parents.length; i < j; i++) {\n          this._model.data[obj.parents[i]].children_d = $.vakata.array_filter(this._model.data[obj.parents[i]].children_d, function (v) {\n            return $.inArray(v, obj.children_d) === -1;\n          });\n        }\n\n        for (k = 0, l = obj.children_d.length; k < l; k++) {\n          if (this._model.data[obj.children_d[k]].state.selected) {\n            c = true;\n          }\n\n          delete this._model.data[obj.children_d[k]];\n        }\n\n        if (c) {\n          this._data.core.selected = $.vakata.array_filter(this._data.core.selected, function (v) {\n            return $.inArray(v, obj.children_d) === -1;\n          });\n        }\n\n        obj.children = [];\n        obj.children_d = [];\n\n        if (c) {\n          this.trigger('changed', {\n            'action': 'load_node',\n            'node': obj,\n            'selected': this._data.core.selected\n          });\n        }\n      }\n\n      obj.state.failed = false;\n      obj.state.loading = true;\n      this.get_node(obj, true).addClass(\"jstree-loading\").attr('aria-busy', true);\n\n      this._load_node(obj, $.proxy(function (status) {\n        obj = this._model.data[obj.id];\n        obj.state.loading = false;\n        obj.state.loaded = status;\n        obj.state.failed = !obj.state.loaded;\n        var dom = this.get_node(obj, true),\n            i = 0,\n            j = 0,\n            m = this._model.data,\n            has_children = false;\n\n        for (i = 0, j = obj.children.length; i < j; i++) {\n          if (m[obj.children[i]] && !m[obj.children[i]].state.hidden) {\n            has_children = true;\n            break;\n          }\n        }\n\n        if (obj.state.loaded && dom && dom.length) {\n          dom.removeClass('jstree-closed jstree-open jstree-leaf');\n\n          if (!has_children) {\n            dom.addClass('jstree-leaf');\n          } else {\n            if (obj.id !== '#') {\n              dom.addClass(obj.state.opened ? 'jstree-open' : 'jstree-closed');\n            }\n          }\n        }\n\n        dom.removeClass(\"jstree-loading\").attr('aria-busy', false);\n        /**\n         * triggered after a node is loaded\n         * @event\n         * @name load_node.jstree\n         * @param {Object} node the node that was loading\n         * @param {Boolean} status was the node loaded successfully\n         */\n\n        this.trigger('load_node', {\n          \"node\": obj,\n          \"status\": status\n        });\n\n        if (callback) {\n          callback.call(this, obj, status);\n        }\n      }, this));\n\n      return true;\n    },\n\n    /**\n     * load an array of nodes (will also load unavailable nodes as soon as the appear in the structure). Used internally.\n     * @private\n     * @name _load_nodes(nodes [, callback])\n     * @param  {array} nodes\n     * @param  {function} callback a function to be executed once loading is complete, the function is executed in the instance's scope and receives one argument - the array passed to _load_nodes\n     */\n    _load_nodes: function _load_nodes(nodes, callback, is_callback, force_reload) {\n      var r = true,\n          c = function c() {\n        this._load_nodes(nodes, callback, true);\n      },\n          m = this._model.data,\n          i,\n          j,\n          tmp = [];\n\n      for (i = 0, j = nodes.length; i < j; i++) {\n        if (m[nodes[i]] && (!m[nodes[i]].state.loaded && !m[nodes[i]].state.failed || !is_callback && force_reload)) {\n          if (!this.is_loading(nodes[i])) {\n            this.load_node(nodes[i], c);\n          }\n\n          r = false;\n        }\n      }\n\n      if (r) {\n        for (i = 0, j = nodes.length; i < j; i++) {\n          if (m[nodes[i]] && m[nodes[i]].state.loaded) {\n            tmp.push(nodes[i]);\n          }\n        }\n\n        if (callback && !callback.done) {\n          callback.call(this, tmp);\n          callback.done = true;\n        }\n      }\n    },\n\n    /**\n     * loads all unloaded nodes\n     * @name load_all([obj, callback])\n     * @param {mixed} obj the node to load recursively, omit to load all nodes in the tree\n     * @param {function} callback a function to be executed once loading all the nodes is complete,\n     * @trigger load_all.jstree\n     */\n    load_all: function load_all(obj, callback) {\n      if (!obj) {\n        obj = $.jstree.root;\n      }\n\n      obj = this.get_node(obj);\n\n      if (!obj) {\n        return false;\n      }\n\n      var to_load = [],\n          m = this._model.data,\n          c = m[obj.id].children_d,\n          i,\n          j;\n\n      if (obj.state && !obj.state.loaded) {\n        to_load.push(obj.id);\n      }\n\n      for (i = 0, j = c.length; i < j; i++) {\n        if (m[c[i]] && m[c[i]].state && !m[c[i]].state.loaded) {\n          to_load.push(c[i]);\n        }\n      }\n\n      if (to_load.length) {\n        this._load_nodes(to_load, function () {\n          this.load_all(obj, callback);\n        });\n      } else {\n        /**\n         * triggered after a load_all call completes\n         * @event\n         * @name load_all.jstree\n         * @param {Object} node the recursively loaded node\n         */\n        if (callback) {\n          callback.call(this, obj);\n        }\n\n        this.trigger('load_all', {\n          \"node\": obj\n        });\n      }\n    },\n\n    /**\n     * handles the actual loading of a node. Used only internally.\n     * @private\n     * @name _load_node(obj [, callback])\n     * @param  {mixed} obj\n     * @param  {function} callback a function to be executed once loading is complete, the function is executed in the instance's scope and receives one argument - a boolean status\n     * @return {Boolean}\n     */\n    _load_node: function _load_node(obj, callback) {\n      var s = this.settings.core.data,\n          t;\n\n      var notTextOrCommentNode = function notTextOrCommentNode() {\n        return this.nodeType !== 3 && this.nodeType !== 8;\n      }; // use original HTML\n\n\n      if (!s) {\n        if (obj.id === $.jstree.root) {\n          return this._append_html_data(obj, this._data.core.original_container_html.clone(true), function (status) {\n            callback.call(this, status);\n          });\n        } else {\n          return callback.call(this, false);\n        } // return callback.call(this, obj.id === $.jstree.root ? this._append_html_data(obj, this._data.core.original_container_html.clone(true)) : false);\n\n      }\n\n      if ($.isFunction(s)) {\n        return s.call(this, obj, $.proxy(function (d) {\n          if (d === false) {\n            callback.call(this, false);\n          } else {\n            this[typeof d === 'string' ? '_append_html_data' : '_append_json_data'](obj, typeof d === 'string' ? $($.parseHTML(d)).filter(notTextOrCommentNode) : d, function (status) {\n              callback.call(this, status);\n            });\n          } // return d === false ? callback.call(this, false) : callback.call(this, this[typeof d === 'string' ? '_append_html_data' : '_append_json_data'](obj, typeof d === 'string' ? $(d) : d));\n\n        }, this));\n      }\n\n      if (_typeof(s) === 'object') {\n        if (s.url) {\n          s = $.extend(true, {}, s);\n\n          if ($.isFunction(s.url)) {\n            s.url = s.url.call(this, obj);\n          }\n\n          if ($.isFunction(s.data)) {\n            s.data = s.data.call(this, obj);\n          }\n\n          return $.ajax(s).done($.proxy(function (d, t, x) {\n            var type = x.getResponseHeader('Content-Type');\n\n            if (type && type.indexOf('json') !== -1 || _typeof(d) === \"object\") {\n              return this._append_json_data(obj, d, function (status) {\n                callback.call(this, status);\n              }); //return callback.call(this, this._append_json_data(obj, d));\n            }\n\n            if (type && type.indexOf('html') !== -1 || typeof d === \"string\") {\n              return this._append_html_data(obj, $($.parseHTML(d)).filter(notTextOrCommentNode), function (status) {\n                callback.call(this, status);\n              }); // return callback.call(this, this._append_html_data(obj, $(d)));\n            }\n\n            this._data.core.last_error = {\n              'error': 'ajax',\n              'plugin': 'core',\n              'id': 'core_04',\n              'reason': 'Could not load node',\n              'data': JSON.stringify({\n                'id': obj.id,\n                'xhr': x\n              })\n            };\n            this.settings.core.error.call(this, this._data.core.last_error);\n            return callback.call(this, false);\n          }, this)).fail($.proxy(function (f) {\n            callback.call(this, false);\n            this._data.core.last_error = {\n              'error': 'ajax',\n              'plugin': 'core',\n              'id': 'core_04',\n              'reason': 'Could not load node',\n              'data': JSON.stringify({\n                'id': obj.id,\n                'xhr': f\n              })\n            };\n            this.settings.core.error.call(this, this._data.core.last_error);\n          }, this));\n        }\n\n        t = $.isArray(s) || $.isPlainObject(s) ? JSON.parse(JSON.stringify(s)) : s;\n\n        if (obj.id === $.jstree.root) {\n          return this._append_json_data(obj, t, function (status) {\n            callback.call(this, status);\n          });\n        } else {\n          this._data.core.last_error = {\n            'error': 'nodata',\n            'plugin': 'core',\n            'id': 'core_05',\n            'reason': 'Could not load node',\n            'data': JSON.stringify({\n              'id': obj.id\n            })\n          };\n          this.settings.core.error.call(this, this._data.core.last_error);\n          return callback.call(this, false);\n        } //return callback.call(this, (obj.id === $.jstree.root ? this._append_json_data(obj, t) : false) );\n\n      }\n\n      if (typeof s === 'string') {\n        if (obj.id === $.jstree.root) {\n          return this._append_html_data(obj, $($.parseHTML(s)).filter(notTextOrCommentNode), function (status) {\n            callback.call(this, status);\n          });\n        } else {\n          this._data.core.last_error = {\n            'error': 'nodata',\n            'plugin': 'core',\n            'id': 'core_06',\n            'reason': 'Could not load node',\n            'data': JSON.stringify({\n              'id': obj.id\n            })\n          };\n          this.settings.core.error.call(this, this._data.core.last_error);\n          return callback.call(this, false);\n        } //return callback.call(this, (obj.id === $.jstree.root ? this._append_html_data(obj, $(s)) : false) );\n\n      }\n\n      return callback.call(this, false);\n    },\n\n    /**\n     * adds a node to the list of nodes to redraw. Used only internally.\n     * @private\n     * @name _node_changed(obj [, callback])\n     * @param  {mixed} obj\n     */\n    _node_changed: function _node_changed(obj) {\n      obj = this.get_node(obj);\n\n      if (obj) {\n        this._model.changed.push(obj.id);\n      }\n    },\n\n    /**\n     * appends HTML content to the tree. Used internally.\n     * @private\n     * @name _append_html_data(obj, data)\n     * @param  {mixed} obj the node to append to\n     * @param  {String} data the HTML string to parse and append\n     * @trigger model.jstree, changed.jstree\n     */\n    _append_html_data: function _append_html_data(dom, data, cb) {\n      dom = this.get_node(dom);\n      dom.children = [];\n      dom.children_d = [];\n      var dat = data.is('ul') ? data.children() : data,\n          par = dom.id,\n          chd = [],\n          dpc = [],\n          m = this._model.data,\n          p = m[par],\n          s = this._data.core.selected.length,\n          tmp,\n          i,\n          j;\n      dat.each($.proxy(function (i, v) {\n        tmp = this._parse_model_from_html($(v), par, p.parents.concat());\n\n        if (tmp) {\n          chd.push(tmp);\n          dpc.push(tmp);\n\n          if (m[tmp].children_d.length) {\n            dpc = dpc.concat(m[tmp].children_d);\n          }\n        }\n      }, this));\n      p.children = chd;\n      p.children_d = dpc;\n\n      for (i = 0, j = p.parents.length; i < j; i++) {\n        m[p.parents[i]].children_d = m[p.parents[i]].children_d.concat(dpc);\n      }\n      /**\n       * triggered when new data is inserted to the tree model\n       * @event\n       * @name model.jstree\n       * @param {Array} nodes an array of node IDs\n       * @param {String} parent the parent ID of the nodes\n       */\n\n\n      this.trigger('model', {\n        \"nodes\": dpc,\n        'parent': par\n      });\n\n      if (par !== $.jstree.root) {\n        this._node_changed(par);\n\n        this.redraw();\n      } else {\n        this.get_container_ul().children('.jstree-initial-node').remove();\n        this.redraw(true);\n      }\n\n      if (this._data.core.selected.length !== s) {\n        this.trigger('changed', {\n          'action': 'model',\n          'selected': this._data.core.selected\n        });\n      }\n\n      cb.call(this, true);\n    },\n\n    /**\n     * appends JSON content to the tree. Used internally.\n     * @private\n     * @name _append_json_data(obj, data)\n     * @param  {mixed} obj the node to append to\n     * @param  {String} data the JSON object to parse and append\n     * @param  {Boolean} force_processing internal param - do not set\n     * @trigger model.jstree, changed.jstree\n     */\n    _append_json_data: function _append_json_data(dom, data, cb, force_processing) {\n      if (this.element === null) {\n        return;\n      }\n\n      dom = this.get_node(dom);\n      dom.children = [];\n      dom.children_d = []; // *%$@!!!\n\n      if (data.d) {\n        data = data.d;\n\n        if (typeof data === \"string\") {\n          data = JSON.parse(data);\n        }\n      }\n\n      if (!$.isArray(data)) {\n        data = [data];\n      }\n\n      var w = null,\n          args = {\n        'df': this._model.default_state,\n        'dat': data,\n        'par': dom.id,\n        'm': this._model.data,\n        't_id': this._id,\n        't_cnt': this._cnt,\n        'sel': this._data.core.selected\n      },\n          func = function func(data, undefined) {\n        if (data.data) {\n          data = data.data;\n        }\n\n        var dat = data.dat,\n            par = data.par,\n            chd = [],\n            dpc = [],\n            add = [],\n            df = data.df,\n            t_id = data.t_id,\n            t_cnt = data.t_cnt,\n            m = data.m,\n            p = m[par],\n            sel = data.sel,\n            tmp,\n            i,\n            j,\n            rslt,\n            parse_flat = function parse_flat(d, p, ps) {\n          if (!ps) {\n            ps = [];\n          } else {\n            ps = ps.concat();\n          }\n\n          if (p) {\n            ps.unshift(p);\n          }\n\n          var tid = d.id.toString(),\n              i,\n              j,\n              c,\n              e,\n              tmp = {\n            id: tid,\n            text: d.text || '',\n            icon: d.icon !== undefined ? d.icon : true,\n            parent: p,\n            parents: ps,\n            children: d.children || [],\n            children_d: d.children_d || [],\n            data: d.data,\n            state: {},\n            li_attr: {\n              id: false\n            },\n            a_attr: {\n              href: '#'\n            },\n            original: false\n          };\n\n          for (i in df) {\n            if (df.hasOwnProperty(i)) {\n              tmp.state[i] = df[i];\n            }\n          }\n\n          if (d && d.data && d.data.jstree && d.data.jstree.icon) {\n            tmp.icon = d.data.jstree.icon;\n          }\n\n          if (tmp.icon === undefined || tmp.icon === null || tmp.icon === \"\") {\n            tmp.icon = true;\n          }\n\n          if (d && d.data) {\n            tmp.data = d.data;\n\n            if (d.data.jstree) {\n              for (i in d.data.jstree) {\n                if (d.data.jstree.hasOwnProperty(i)) {\n                  tmp.state[i] = d.data.jstree[i];\n                }\n              }\n            }\n          }\n\n          if (d && _typeof(d.state) === 'object') {\n            for (i in d.state) {\n              if (d.state.hasOwnProperty(i)) {\n                tmp.state[i] = d.state[i];\n              }\n            }\n          }\n\n          if (d && _typeof(d.li_attr) === 'object') {\n            for (i in d.li_attr) {\n              if (d.li_attr.hasOwnProperty(i)) {\n                tmp.li_attr[i] = d.li_attr[i];\n              }\n            }\n          }\n\n          if (!tmp.li_attr.id) {\n            tmp.li_attr.id = tid;\n          }\n\n          if (d && _typeof(d.a_attr) === 'object') {\n            for (i in d.a_attr) {\n              if (d.a_attr.hasOwnProperty(i)) {\n                tmp.a_attr[i] = d.a_attr[i];\n              }\n            }\n          }\n\n          if (d && d.children && d.children === true) {\n            tmp.state.loaded = false;\n            tmp.children = [];\n            tmp.children_d = [];\n          }\n\n          m[tmp.id] = tmp;\n\n          for (i = 0, j = tmp.children.length; i < j; i++) {\n            c = parse_flat(m[tmp.children[i]], tmp.id, ps);\n            e = m[c];\n            tmp.children_d.push(c);\n\n            if (e.children_d.length) {\n              tmp.children_d = tmp.children_d.concat(e.children_d);\n            }\n          }\n\n          delete d.data;\n          delete d.children;\n          m[tmp.id].original = d;\n\n          if (tmp.state.selected) {\n            add.push(tmp.id);\n          }\n\n          return tmp.id;\n        },\n            parse_nest = function parse_nest(d, p, ps) {\n          if (!ps) {\n            ps = [];\n          } else {\n            ps = ps.concat();\n          }\n\n          if (p) {\n            ps.unshift(p);\n          }\n\n          var tid = false,\n              i,\n              j,\n              c,\n              e,\n              tmp;\n\n          do {\n            tid = 'j' + t_id + '_' + ++t_cnt;\n          } while (m[tid]);\n\n          tmp = {\n            id: false,\n            text: typeof d === 'string' ? d : '',\n            icon: _typeof(d) === 'object' && d.icon !== undefined ? d.icon : true,\n            parent: p,\n            parents: ps,\n            children: [],\n            children_d: [],\n            data: null,\n            state: {},\n            li_attr: {\n              id: false\n            },\n            a_attr: {\n              href: '#'\n            },\n            original: false\n          };\n\n          for (i in df) {\n            if (df.hasOwnProperty(i)) {\n              tmp.state[i] = df[i];\n            }\n          }\n\n          if (d && d.id) {\n            tmp.id = d.id.toString();\n          }\n\n          if (d && d.text) {\n            tmp.text = d.text;\n          }\n\n          if (d && d.data && d.data.jstree && d.data.jstree.icon) {\n            tmp.icon = d.data.jstree.icon;\n          }\n\n          if (tmp.icon === undefined || tmp.icon === null || tmp.icon === \"\") {\n            tmp.icon = true;\n          }\n\n          if (d && d.data) {\n            tmp.data = d.data;\n\n            if (d.data.jstree) {\n              for (i in d.data.jstree) {\n                if (d.data.jstree.hasOwnProperty(i)) {\n                  tmp.state[i] = d.data.jstree[i];\n                }\n              }\n            }\n          }\n\n          if (d && _typeof(d.state) === 'object') {\n            for (i in d.state) {\n              if (d.state.hasOwnProperty(i)) {\n                tmp.state[i] = d.state[i];\n              }\n            }\n          }\n\n          if (d && _typeof(d.li_attr) === 'object') {\n            for (i in d.li_attr) {\n              if (d.li_attr.hasOwnProperty(i)) {\n                tmp.li_attr[i] = d.li_attr[i];\n              }\n            }\n          }\n\n          if (tmp.li_attr.id && !tmp.id) {\n            tmp.id = tmp.li_attr.id.toString();\n          }\n\n          if (!tmp.id) {\n            tmp.id = tid;\n          }\n\n          if (!tmp.li_attr.id) {\n            tmp.li_attr.id = tmp.id;\n          }\n\n          if (d && _typeof(d.a_attr) === 'object') {\n            for (i in d.a_attr) {\n              if (d.a_attr.hasOwnProperty(i)) {\n                tmp.a_attr[i] = d.a_attr[i];\n              }\n            }\n          }\n\n          if (d && d.children && d.children.length) {\n            for (i = 0, j = d.children.length; i < j; i++) {\n              c = parse_nest(d.children[i], tmp.id, ps);\n              e = m[c];\n              tmp.children.push(c);\n\n              if (e.children_d.length) {\n                tmp.children_d = tmp.children_d.concat(e.children_d);\n              }\n            }\n\n            tmp.children_d = tmp.children_d.concat(tmp.children);\n          }\n\n          if (d && d.children && d.children === true) {\n            tmp.state.loaded = false;\n            tmp.children = [];\n            tmp.children_d = [];\n          }\n\n          delete d.data;\n          delete d.children;\n          tmp.original = d;\n          m[tmp.id] = tmp;\n\n          if (tmp.state.selected) {\n            add.push(tmp.id);\n          }\n\n          return tmp.id;\n        };\n\n        if (dat.length && dat[0].id !== undefined && dat[0].parent !== undefined) {\n          // Flat JSON support (for easy import from DB):\n          // 1) convert to object (foreach)\n          for (i = 0, j = dat.length; i < j; i++) {\n            if (!dat[i].children) {\n              dat[i].children = [];\n            }\n\n            m[dat[i].id.toString()] = dat[i];\n          } // 2) populate children (foreach)\n\n\n          for (i = 0, j = dat.length; i < j; i++) {\n            m[dat[i].parent.toString()].children.push(dat[i].id.toString()); // populate parent.children_d\n\n            p.children_d.push(dat[i].id.toString());\n          } // 3) normalize && populate parents and children_d with recursion\n\n\n          for (i = 0, j = p.children.length; i < j; i++) {\n            tmp = parse_flat(m[p.children[i]], par, p.parents.concat());\n            dpc.push(tmp);\n\n            if (m[tmp].children_d.length) {\n              dpc = dpc.concat(m[tmp].children_d);\n            }\n          }\n\n          for (i = 0, j = p.parents.length; i < j; i++) {\n            m[p.parents[i]].children_d = m[p.parents[i]].children_d.concat(dpc);\n          } // ?) three_state selection - p.state.selected && t - (if three_state foreach(dat => ch) -> foreach(parents) if(parent.selected) child.selected = true;\n\n\n          rslt = {\n            'cnt': t_cnt,\n            'mod': m,\n            'sel': sel,\n            'par': par,\n            'dpc': dpc,\n            'add': add\n          };\n        } else {\n          for (i = 0, j = dat.length; i < j; i++) {\n            tmp = parse_nest(dat[i], par, p.parents.concat());\n\n            if (tmp) {\n              chd.push(tmp);\n              dpc.push(tmp);\n\n              if (m[tmp].children_d.length) {\n                dpc = dpc.concat(m[tmp].children_d);\n              }\n            }\n          }\n\n          p.children = chd;\n          p.children_d = dpc;\n\n          for (i = 0, j = p.parents.length; i < j; i++) {\n            m[p.parents[i]].children_d = m[p.parents[i]].children_d.concat(dpc);\n          }\n\n          rslt = {\n            'cnt': t_cnt,\n            'mod': m,\n            'sel': sel,\n            'par': par,\n            'dpc': dpc,\n            'add': add\n          };\n        }\n\n        if (typeof window === 'undefined' || typeof window.document === 'undefined') {\n          postMessage(rslt);\n        } else {\n          return rslt;\n        }\n      },\n          rslt = function rslt(_rslt, worker) {\n        if (this.element === null) {\n          return;\n        }\n\n        this._cnt = _rslt.cnt;\n        var i,\n            m = this._model.data;\n\n        for (i in m) {\n          if (m.hasOwnProperty(i) && m[i].state && m[i].state.loading && _rslt.mod[i]) {\n            _rslt.mod[i].state.loading = true;\n          }\n        }\n\n        this._model.data = _rslt.mod; // breaks the reference in load_node - careful\n\n        if (worker) {\n          var j,\n              a = _rslt.add,\n              r = _rslt.sel,\n              s = this._data.core.selected.slice();\n\n          m = this._model.data; // if selection was changed while calculating in worker\n\n          if (r.length !== s.length || $.vakata.array_unique(r.concat(s)).length !== r.length) {\n            // deselect nodes that are no longer selected\n            for (i = 0, j = r.length; i < j; i++) {\n              if ($.inArray(r[i], a) === -1 && $.inArray(r[i], s) === -1) {\n                m[r[i]].state.selected = false;\n              }\n            } // select nodes that were selected in the mean time\n\n\n            for (i = 0, j = s.length; i < j; i++) {\n              if ($.inArray(s[i], r) === -1) {\n                m[s[i]].state.selected = true;\n              }\n            }\n          }\n        }\n\n        if (_rslt.add.length) {\n          this._data.core.selected = this._data.core.selected.concat(_rslt.add);\n        }\n\n        this.trigger('model', {\n          \"nodes\": _rslt.dpc,\n          'parent': _rslt.par\n        });\n\n        if (_rslt.par !== $.jstree.root) {\n          this._node_changed(_rslt.par);\n\n          this.redraw();\n        } else {\n          // this.get_container_ul().children('.jstree-initial-node').remove();\n          this.redraw(true);\n        }\n\n        if (_rslt.add.length) {\n          this.trigger('changed', {\n            'action': 'model',\n            'selected': this._data.core.selected\n          });\n        }\n\n        cb.call(this, true);\n      };\n\n      if (this.settings.core.worker && window.Blob && window.URL && window.Worker) {\n        try {\n          if (this._wrk === null) {\n            this._wrk = window.URL.createObjectURL(new window.Blob(['self.onmessage = ' + func.toString()], {\n              type: \"text/javascript\"\n            }));\n          }\n\n          if (!this._data.core.working || force_processing) {\n            this._data.core.working = true;\n            w = new window.Worker(this._wrk);\n            w.onmessage = $.proxy(function (e) {\n              rslt.call(this, e.data, true);\n\n              try {\n                w.terminate();\n                w = null;\n              } catch (ignore) {}\n\n              if (this._data.core.worker_queue.length) {\n                this._append_json_data.apply(this, this._data.core.worker_queue.shift());\n              } else {\n                this._data.core.working = false;\n              }\n            }, this);\n\n            if (!args.par) {\n              if (this._data.core.worker_queue.length) {\n                this._append_json_data.apply(this, this._data.core.worker_queue.shift());\n              } else {\n                this._data.core.working = false;\n              }\n            } else {\n              w.postMessage(args);\n            }\n          } else {\n            this._data.core.worker_queue.push([dom, data, cb, true]);\n          }\n        } catch (e) {\n          rslt.call(this, func(args), false);\n\n          if (this._data.core.worker_queue.length) {\n            this._append_json_data.apply(this, this._data.core.worker_queue.shift());\n          } else {\n            this._data.core.working = false;\n          }\n        }\n      } else {\n        rslt.call(this, func(args), false);\n      }\n    },\n\n    /**\n     * parses a node from a jQuery object and appends them to the in memory tree model. Used internally.\n     * @private\n     * @name _parse_model_from_html(d [, p, ps])\n     * @param  {jQuery} d the jQuery object to parse\n     * @param  {String} p the parent ID\n     * @param  {Array} ps list of all parents\n     * @return {String} the ID of the object added to the model\n     */\n    _parse_model_from_html: function _parse_model_from_html(d, p, ps) {\n      if (!ps) {\n        ps = [];\n      } else {\n        ps = [].concat(ps);\n      }\n\n      if (p) {\n        ps.unshift(p);\n      }\n\n      var c,\n          e,\n          m = this._model.data,\n          data = {\n        id: false,\n        text: false,\n        icon: true,\n        parent: p,\n        parents: ps,\n        children: [],\n        children_d: [],\n        data: null,\n        state: {},\n        li_attr: {\n          id: false\n        },\n        a_attr: {\n          href: '#'\n        },\n        original: false\n      },\n          i,\n          tmp,\n          tid;\n\n      for (i in this._model.default_state) {\n        if (this._model.default_state.hasOwnProperty(i)) {\n          data.state[i] = this._model.default_state[i];\n        }\n      }\n\n      tmp = $.vakata.attributes(d, true);\n      $.each(tmp, function (i, v) {\n        v = $.trim(v);\n\n        if (!v.length) {\n          return true;\n        }\n\n        data.li_attr[i] = v;\n\n        if (i === 'id') {\n          data.id = v.toString();\n        }\n      });\n      tmp = d.children('a').first();\n\n      if (tmp.length) {\n        tmp = $.vakata.attributes(tmp, true);\n        $.each(tmp, function (i, v) {\n          v = $.trim(v);\n\n          if (v.length) {\n            data.a_attr[i] = v;\n          }\n        });\n      }\n\n      tmp = d.children(\"a\").first().length ? d.children(\"a\").first().clone() : d.clone();\n      tmp.children(\"ins, i, ul\").remove();\n      tmp = tmp.html();\n      tmp = $('<div />').html(tmp);\n      data.text = this.settings.core.force_text ? tmp.text() : tmp.html();\n      tmp = d.data();\n      data.data = tmp ? $.extend(true, {}, tmp) : null;\n      data.state.opened = d.hasClass('jstree-open');\n      data.state.selected = d.children('a').hasClass('jstree-clicked');\n      data.state.disabled = d.children('a').hasClass('jstree-disabled');\n\n      if (data.data && data.data.jstree) {\n        for (i in data.data.jstree) {\n          if (data.data.jstree.hasOwnProperty(i)) {\n            data.state[i] = data.data.jstree[i];\n          }\n        }\n      }\n\n      tmp = d.children(\"a\").children(\".jstree-themeicon\");\n\n      if (tmp.length) {\n        data.icon = tmp.hasClass('jstree-themeicon-hidden') ? false : tmp.attr('rel');\n      }\n\n      if (data.state.icon !== undefined) {\n        data.icon = data.state.icon;\n      }\n\n      if (data.icon === undefined || data.icon === null || data.icon === \"\") {\n        data.icon = true;\n      }\n\n      tmp = d.children(\"ul\").children(\"li\");\n\n      do {\n        tid = 'j' + this._id + '_' + ++this._cnt;\n      } while (m[tid]);\n\n      data.id = data.li_attr.id ? data.li_attr.id.toString() : tid;\n\n      if (tmp.length) {\n        tmp.each($.proxy(function (i, v) {\n          c = this._parse_model_from_html($(v), data.id, ps);\n          e = this._model.data[c];\n          data.children.push(c);\n\n          if (e.children_d.length) {\n            data.children_d = data.children_d.concat(e.children_d);\n          }\n        }, this));\n        data.children_d = data.children_d.concat(data.children);\n      } else {\n        if (d.hasClass('jstree-closed')) {\n          data.state.loaded = false;\n        }\n      }\n\n      if (data.li_attr['class']) {\n        data.li_attr['class'] = data.li_attr['class'].replace('jstree-closed', '').replace('jstree-open', '');\n      }\n\n      if (data.a_attr['class']) {\n        data.a_attr['class'] = data.a_attr['class'].replace('jstree-clicked', '').replace('jstree-disabled', '');\n      }\n\n      m[data.id] = data;\n\n      if (data.state.selected) {\n        this._data.core.selected.push(data.id);\n      }\n\n      return data.id;\n    },\n\n    /**\n     * parses a node from a JSON object (used when dealing with flat data, which has no nesting of children, but has id and parent properties) and appends it to the in memory tree model. Used internally.\n     * @private\n     * @name _parse_model_from_flat_json(d [, p, ps])\n     * @param  {Object} d the JSON object to parse\n     * @param  {String} p the parent ID\n     * @param  {Array} ps list of all parents\n     * @return {String} the ID of the object added to the model\n     */\n    _parse_model_from_flat_json: function _parse_model_from_flat_json(d, p, ps) {\n      if (!ps) {\n        ps = [];\n      } else {\n        ps = ps.concat();\n      }\n\n      if (p) {\n        ps.unshift(p);\n      }\n\n      var tid = d.id.toString(),\n          m = this._model.data,\n          df = this._model.default_state,\n          i,\n          j,\n          c,\n          e,\n          tmp = {\n        id: tid,\n        text: d.text || '',\n        icon: d.icon !== undefined ? d.icon : true,\n        parent: p,\n        parents: ps,\n        children: d.children || [],\n        children_d: d.children_d || [],\n        data: d.data,\n        state: {},\n        li_attr: {\n          id: false\n        },\n        a_attr: {\n          href: '#'\n        },\n        original: false\n      };\n\n      for (i in df) {\n        if (df.hasOwnProperty(i)) {\n          tmp.state[i] = df[i];\n        }\n      }\n\n      if (d && d.data && d.data.jstree && d.data.jstree.icon) {\n        tmp.icon = d.data.jstree.icon;\n      }\n\n      if (tmp.icon === undefined || tmp.icon === null || tmp.icon === \"\") {\n        tmp.icon = true;\n      }\n\n      if (d && d.data) {\n        tmp.data = d.data;\n\n        if (d.data.jstree) {\n          for (i in d.data.jstree) {\n            if (d.data.jstree.hasOwnProperty(i)) {\n              tmp.state[i] = d.data.jstree[i];\n            }\n          }\n        }\n      }\n\n      if (d && _typeof(d.state) === 'object') {\n        for (i in d.state) {\n          if (d.state.hasOwnProperty(i)) {\n            tmp.state[i] = d.state[i];\n          }\n        }\n      }\n\n      if (d && _typeof(d.li_attr) === 'object') {\n        for (i in d.li_attr) {\n          if (d.li_attr.hasOwnProperty(i)) {\n            tmp.li_attr[i] = d.li_attr[i];\n          }\n        }\n      }\n\n      if (!tmp.li_attr.id) {\n        tmp.li_attr.id = tid;\n      }\n\n      if (d && _typeof(d.a_attr) === 'object') {\n        for (i in d.a_attr) {\n          if (d.a_attr.hasOwnProperty(i)) {\n            tmp.a_attr[i] = d.a_attr[i];\n          }\n        }\n      }\n\n      if (d && d.children && d.children === true) {\n        tmp.state.loaded = false;\n        tmp.children = [];\n        tmp.children_d = [];\n      }\n\n      m[tmp.id] = tmp;\n\n      for (i = 0, j = tmp.children.length; i < j; i++) {\n        c = this._parse_model_from_flat_json(m[tmp.children[i]], tmp.id, ps);\n        e = m[c];\n        tmp.children_d.push(c);\n\n        if (e.children_d.length) {\n          tmp.children_d = tmp.children_d.concat(e.children_d);\n        }\n      }\n\n      delete d.data;\n      delete d.children;\n      m[tmp.id].original = d;\n\n      if (tmp.state.selected) {\n        this._data.core.selected.push(tmp.id);\n      }\n\n      return tmp.id;\n    },\n\n    /**\n     * parses a node from a JSON object and appends it to the in memory tree model. Used internally.\n     * @private\n     * @name _parse_model_from_json(d [, p, ps])\n     * @param  {Object} d the JSON object to parse\n     * @param  {String} p the parent ID\n     * @param  {Array} ps list of all parents\n     * @return {String} the ID of the object added to the model\n     */\n    _parse_model_from_json: function _parse_model_from_json(d, p, ps) {\n      if (!ps) {\n        ps = [];\n      } else {\n        ps = ps.concat();\n      }\n\n      if (p) {\n        ps.unshift(p);\n      }\n\n      var tid = false,\n          i,\n          j,\n          c,\n          e,\n          m = this._model.data,\n          df = this._model.default_state,\n          tmp;\n\n      do {\n        tid = 'j' + this._id + '_' + ++this._cnt;\n      } while (m[tid]);\n\n      tmp = {\n        id: false,\n        text: typeof d === 'string' ? d : '',\n        icon: _typeof(d) === 'object' && d.icon !== undefined ? d.icon : true,\n        parent: p,\n        parents: ps,\n        children: [],\n        children_d: [],\n        data: null,\n        state: {},\n        li_attr: {\n          id: false\n        },\n        a_attr: {\n          href: '#'\n        },\n        original: false\n      };\n\n      for (i in df) {\n        if (df.hasOwnProperty(i)) {\n          tmp.state[i] = df[i];\n        }\n      }\n\n      if (d && d.id) {\n        tmp.id = d.id.toString();\n      }\n\n      if (d && d.text) {\n        tmp.text = d.text;\n      }\n\n      if (d && d.data && d.data.jstree && d.data.jstree.icon) {\n        tmp.icon = d.data.jstree.icon;\n      }\n\n      if (tmp.icon === undefined || tmp.icon === null || tmp.icon === \"\") {\n        tmp.icon = true;\n      }\n\n      if (d && d.data) {\n        tmp.data = d.data;\n\n        if (d.data.jstree) {\n          for (i in d.data.jstree) {\n            if (d.data.jstree.hasOwnProperty(i)) {\n              tmp.state[i] = d.data.jstree[i];\n            }\n          }\n        }\n      }\n\n      if (d && _typeof(d.state) === 'object') {\n        for (i in d.state) {\n          if (d.state.hasOwnProperty(i)) {\n            tmp.state[i] = d.state[i];\n          }\n        }\n      }\n\n      if (d && _typeof(d.li_attr) === 'object') {\n        for (i in d.li_attr) {\n          if (d.li_attr.hasOwnProperty(i)) {\n            tmp.li_attr[i] = d.li_attr[i];\n          }\n        }\n      }\n\n      if (tmp.li_attr.id && !tmp.id) {\n        tmp.id = tmp.li_attr.id.toString();\n      }\n\n      if (!tmp.id) {\n        tmp.id = tid;\n      }\n\n      if (!tmp.li_attr.id) {\n        tmp.li_attr.id = tmp.id;\n      }\n\n      if (d && _typeof(d.a_attr) === 'object') {\n        for (i in d.a_attr) {\n          if (d.a_attr.hasOwnProperty(i)) {\n            tmp.a_attr[i] = d.a_attr[i];\n          }\n        }\n      }\n\n      if (d && d.children && d.children.length) {\n        for (i = 0, j = d.children.length; i < j; i++) {\n          c = this._parse_model_from_json(d.children[i], tmp.id, ps);\n          e = m[c];\n          tmp.children.push(c);\n\n          if (e.children_d.length) {\n            tmp.children_d = tmp.children_d.concat(e.children_d);\n          }\n        }\n\n        tmp.children_d = tmp.children_d.concat(tmp.children);\n      }\n\n      if (d && d.children && d.children === true) {\n        tmp.state.loaded = false;\n        tmp.children = [];\n        tmp.children_d = [];\n      }\n\n      delete d.data;\n      delete d.children;\n      tmp.original = d;\n      m[tmp.id] = tmp;\n\n      if (tmp.state.selected) {\n        this._data.core.selected.push(tmp.id);\n      }\n\n      return tmp.id;\n    },\n\n    /**\n     * redraws all nodes that need to be redrawn. Used internally.\n     * @private\n     * @name _redraw()\n     * @trigger redraw.jstree\n     */\n    _redraw: function _redraw() {\n      var nodes = this._model.force_full_redraw ? this._model.data[$.jstree.root].children.concat([]) : this._model.changed.concat([]),\n          f = document.createElement('UL'),\n          tmp,\n          i,\n          j,\n          fe = this._data.core.focused;\n\n      for (i = 0, j = nodes.length; i < j; i++) {\n        tmp = this.redraw_node(nodes[i], true, this._model.force_full_redraw);\n\n        if (tmp && this._model.force_full_redraw) {\n          f.appendChild(tmp);\n        }\n      }\n\n      if (this._model.force_full_redraw) {\n        f.className = this.get_container_ul()[0].className;\n        f.setAttribute('role', 'group');\n        this.element.empty().append(f); //this.get_container_ul()[0].appendChild(f);\n      }\n\n      if (fe !== null) {\n        tmp = this.get_node(fe, true);\n\n        if (tmp && tmp.length && tmp.children('.jstree-anchor')[0] !== document.activeElement) {\n          tmp.children('.jstree-anchor').focus();\n        } else {\n          this._data.core.focused = null;\n        }\n      }\n\n      this._model.force_full_redraw = false;\n      this._model.changed = [];\n      /**\n       * triggered after nodes are redrawn\n       * @event\n       * @name redraw.jstree\n       * @param {array} nodes the redrawn nodes\n       */\n\n      this.trigger('redraw', {\n        \"nodes\": nodes\n      });\n    },\n\n    /**\n     * redraws all nodes that need to be redrawn or optionally - the whole tree\n     * @name redraw([full])\n     * @param {Boolean} full if set to `true` all nodes are redrawn.\n     */\n    redraw: function redraw(full) {\n      if (full) {\n        this._model.force_full_redraw = true;\n      } //if(this._model.redraw_timeout) {\n      //\tclearTimeout(this._model.redraw_timeout);\n      //}\n      //this._model.redraw_timeout = setTimeout($.proxy(this._redraw, this),0);\n\n\n      this._redraw();\n    },\n\n    /**\n     * redraws a single node's children. Used internally.\n     * @private\n     * @name draw_children(node)\n     * @param {mixed} node the node whose children will be redrawn\n     */\n    draw_children: function draw_children(node) {\n      var obj = this.get_node(node),\n          i = false,\n          j = false,\n          k = false,\n          d = document;\n\n      if (!obj) {\n        return false;\n      }\n\n      if (obj.id === $.jstree.root) {\n        return this.redraw(true);\n      }\n\n      node = this.get_node(node, true);\n\n      if (!node || !node.length) {\n        return false;\n      } // TODO: quick toggle\n\n\n      node.children('.jstree-children').remove();\n      node = node[0];\n\n      if (obj.children.length && obj.state.loaded) {\n        k = d.createElement('UL');\n        k.setAttribute('role', 'group');\n        k.className = 'jstree-children';\n\n        for (i = 0, j = obj.children.length; i < j; i++) {\n          k.appendChild(this.redraw_node(obj.children[i], true, true));\n        }\n\n        node.appendChild(k);\n      }\n    },\n\n    /**\n     * redraws a single node. Used internally.\n     * @private\n     * @name redraw_node(node, deep, is_callback, force_render)\n     * @param {mixed} node the node to redraw\n     * @param {Boolean} deep should child nodes be redrawn too\n     * @param {Boolean} is_callback is this a recursion call\n     * @param {Boolean} force_render should children of closed parents be drawn anyway\n     */\n    redraw_node: function redraw_node(node, deep, is_callback, force_render) {\n      var obj = this.get_node(node),\n          par = false,\n          ind = false,\n          old = false,\n          i = false,\n          j = false,\n          k = false,\n          c = '',\n          d = document,\n          m = this._model.data,\n          f = false,\n          s = false,\n          tmp = null,\n          t = 0,\n          l = 0,\n          has_children = false,\n          last_sibling = false;\n\n      if (!obj) {\n        return false;\n      }\n\n      if (obj.id === $.jstree.root) {\n        return this.redraw(true);\n      }\n\n      deep = deep || obj.children.length === 0;\n      node = !document.querySelector ? document.getElementById(obj.id) : this.element[0].querySelector('#' + (\"0123456789\".indexOf(obj.id[0]) !== -1 ? '\\\\3' + obj.id[0] + ' ' + obj.id.substr(1).replace($.jstree.idregex, '\\\\$&') : obj.id.replace($.jstree.idregex, '\\\\$&'))); //, this.element);\n\n      if (!node) {\n        deep = true; //node = d.createElement('LI');\n\n        if (!is_callback) {\n          par = obj.parent !== $.jstree.root ? $('#' + obj.parent.replace($.jstree.idregex, '\\\\$&'), this.element)[0] : null;\n\n          if (par !== null && (!par || !m[obj.parent].state.opened)) {\n            return false;\n          }\n\n          ind = $.inArray(obj.id, par === null ? m[$.jstree.root].children : m[obj.parent].children);\n        }\n      } else {\n        node = $(node);\n\n        if (!is_callback) {\n          par = node.parent().parent()[0];\n\n          if (par === this.element[0]) {\n            par = null;\n          }\n\n          ind = node.index();\n        } // m[obj.id].data = node.data(); // use only node's data, no need to touch jquery storage\n\n\n        if (!deep && obj.children.length && !node.children('.jstree-children').length) {\n          deep = true;\n        }\n\n        if (!deep) {\n          old = node.children('.jstree-children')[0];\n        }\n\n        f = node.children('.jstree-anchor')[0] === document.activeElement;\n        node.remove(); //node = d.createElement('LI');\n        //node = node[0];\n      }\n\n      node = this._data.core.node.cloneNode(true); // node is DOM, deep is boolean\n\n      c = 'jstree-node ';\n\n      for (i in obj.li_attr) {\n        if (obj.li_attr.hasOwnProperty(i)) {\n          if (i === 'id') {\n            continue;\n          }\n\n          if (i !== 'class') {\n            node.setAttribute(i, obj.li_attr[i]);\n          } else {\n            c += obj.li_attr[i];\n          }\n        }\n      }\n\n      if (!obj.a_attr.id) {\n        obj.a_attr.id = obj.id + '_anchor';\n      }\n\n      node.setAttribute('aria-selected', !!obj.state.selected);\n      node.setAttribute('aria-level', obj.parents.length);\n      node.setAttribute('aria-labelledby', obj.a_attr.id);\n\n      if (obj.state.disabled) {\n        node.setAttribute('aria-disabled', true);\n      }\n\n      for (i = 0, j = obj.children.length; i < j; i++) {\n        if (!m[obj.children[i]].state.hidden) {\n          has_children = true;\n          break;\n        }\n      }\n\n      if (obj.parent !== null && m[obj.parent] && !obj.state.hidden) {\n        i = $.inArray(obj.id, m[obj.parent].children);\n        last_sibling = obj.id;\n\n        if (i !== -1) {\n          i++;\n\n          for (j = m[obj.parent].children.length; i < j; i++) {\n            if (!m[m[obj.parent].children[i]].state.hidden) {\n              last_sibling = m[obj.parent].children[i];\n            }\n\n            if (last_sibling !== obj.id) {\n              break;\n            }\n          }\n        }\n      }\n\n      if (obj.state.hidden) {\n        c += ' jstree-hidden';\n      }\n\n      if (obj.state.loaded && !has_children) {\n        c += ' jstree-leaf';\n      } else {\n        c += obj.state.opened && obj.state.loaded ? ' jstree-open' : ' jstree-closed';\n        node.setAttribute('aria-expanded', obj.state.opened && obj.state.loaded);\n      }\n\n      if (last_sibling === obj.id) {\n        c += ' jstree-last';\n      }\n\n      node.id = obj.id;\n      node.className = c;\n      c = (obj.state.selected ? ' jstree-clicked' : '') + (obj.state.disabled ? ' jstree-disabled' : '');\n\n      for (j in obj.a_attr) {\n        if (obj.a_attr.hasOwnProperty(j)) {\n          if (j === 'href' && obj.a_attr[j] === '#') {\n            continue;\n          }\n\n          if (j !== 'class') {\n            node.childNodes[1].setAttribute(j, obj.a_attr[j]);\n          } else {\n            c += ' ' + obj.a_attr[j];\n          }\n        }\n      }\n\n      if (c.length) {\n        node.childNodes[1].className = 'jstree-anchor ' + c;\n      }\n\n      if (obj.icon && obj.icon !== true || obj.icon === false) {\n        if (obj.icon === false) {\n          node.childNodes[1].childNodes[0].className += ' jstree-themeicon-hidden';\n        } else if (obj.icon.indexOf('/') === -1 && obj.icon.indexOf('.') === -1) {\n          node.childNodes[1].childNodes[0].className += ' ' + obj.icon + ' jstree-themeicon-custom';\n        } else {\n          node.childNodes[1].childNodes[0].style.backgroundImage = 'url(\"' + obj.icon + '\")';\n          node.childNodes[1].childNodes[0].style.backgroundPosition = 'center center';\n          node.childNodes[1].childNodes[0].style.backgroundSize = 'auto';\n          node.childNodes[1].childNodes[0].className += ' jstree-themeicon-custom';\n        }\n      }\n\n      if (this.settings.core.force_text) {\n        node.childNodes[1].appendChild(d.createTextNode(obj.text));\n      } else {\n        node.childNodes[1].innerHTML += obj.text;\n      }\n\n      if (deep && obj.children.length && (obj.state.opened || force_render) && obj.state.loaded) {\n        k = d.createElement('UL');\n        k.setAttribute('role', 'group');\n        k.className = 'jstree-children';\n\n        for (i = 0, j = obj.children.length; i < j; i++) {\n          k.appendChild(this.redraw_node(obj.children[i], deep, true));\n        }\n\n        node.appendChild(k);\n      }\n\n      if (old) {\n        node.appendChild(old);\n      }\n\n      if (!is_callback) {\n        // append back using par / ind\n        if (!par) {\n          par = this.element[0];\n        }\n\n        for (i = 0, j = par.childNodes.length; i < j; i++) {\n          if (par.childNodes[i] && par.childNodes[i].className && par.childNodes[i].className.indexOf('jstree-children') !== -1) {\n            tmp = par.childNodes[i];\n            break;\n          }\n        }\n\n        if (!tmp) {\n          tmp = d.createElement('UL');\n          tmp.setAttribute('role', 'group');\n          tmp.className = 'jstree-children';\n          par.appendChild(tmp);\n        }\n\n        par = tmp;\n\n        if (ind < par.childNodes.length) {\n          par.insertBefore(node, par.childNodes[ind]);\n        } else {\n          par.appendChild(node);\n        }\n\n        if (f) {\n          t = this.element[0].scrollTop;\n          l = this.element[0].scrollLeft;\n          node.childNodes[1].focus();\n          this.element[0].scrollTop = t;\n          this.element[0].scrollLeft = l;\n        }\n      }\n\n      if (obj.state.opened && !obj.state.loaded) {\n        obj.state.opened = false;\n        setTimeout($.proxy(function () {\n          this.open_node(obj.id, false, 0);\n        }, this), 0);\n      }\n\n      return node;\n    },\n\n    /**\n     * opens a node, revaling its children. If the node is not loaded it will be loaded and opened once ready.\n     * @name open_node(obj [, callback, animation])\n     * @param {mixed} obj the node to open\n     * @param {Function} callback a function to execute once the node is opened\n     * @param {Number} animation the animation duration in milliseconds when opening the node (overrides the `core.animation` setting). Use `false` for no animation.\n     * @trigger open_node.jstree, after_open.jstree, before_open.jstree\n     */\n    open_node: function open_node(obj, callback, animation) {\n      var t1, t2, d, t;\n\n      if ($.isArray(obj)) {\n        obj = obj.slice();\n\n        for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n          this.open_node(obj[t1], callback, animation);\n        }\n\n        return true;\n      }\n\n      obj = this.get_node(obj);\n\n      if (!obj || obj.id === $.jstree.root) {\n        return false;\n      }\n\n      animation = animation === undefined ? this.settings.core.animation : animation;\n\n      if (!this.is_closed(obj)) {\n        if (callback) {\n          callback.call(this, obj, false);\n        }\n\n        return false;\n      }\n\n      if (!this.is_loaded(obj)) {\n        if (this.is_loading(obj)) {\n          return setTimeout($.proxy(function () {\n            this.open_node(obj, callback, animation);\n          }, this), 500);\n        }\n\n        this.load_node(obj, function (o, ok) {\n          return ok ? this.open_node(o, callback, animation) : callback ? callback.call(this, o, false) : false;\n        });\n      } else {\n        d = this.get_node(obj, true);\n        t = this;\n\n        if (d.length) {\n          if (animation && d.children(\".jstree-children\").length) {\n            d.children(\".jstree-children\").stop(true, true);\n          }\n\n          if (obj.children.length && !this._firstChild(d.children('.jstree-children')[0])) {\n            this.draw_children(obj); //d = this.get_node(obj, true);\n          }\n\n          if (!animation) {\n            this.trigger('before_open', {\n              \"node\": obj\n            });\n            d[0].className = d[0].className.replace('jstree-closed', 'jstree-open');\n            d[0].setAttribute(\"aria-expanded\", true);\n          } else {\n            this.trigger('before_open', {\n              \"node\": obj\n            });\n            d.children(\".jstree-children\").css(\"display\", \"none\").end().removeClass(\"jstree-closed\").addClass(\"jstree-open\").attr(\"aria-expanded\", true).children(\".jstree-children\").stop(true, true).slideDown(animation, function () {\n              this.style.display = \"\";\n\n              if (t.element) {\n                t.trigger(\"after_open\", {\n                  \"node\": obj\n                });\n              }\n            });\n          }\n        }\n\n        obj.state.opened = true;\n\n        if (callback) {\n          callback.call(this, obj, true);\n        }\n\n        if (!d.length) {\n          /**\n           * triggered when a node is about to be opened (if the node is supposed to be in the DOM, it will be, but it won't be visible yet)\n           * @event\n           * @name before_open.jstree\n           * @param {Object} node the opened node\n           */\n          this.trigger('before_open', {\n            \"node\": obj\n          });\n        }\n        /**\n         * triggered when a node is opened (if there is an animation it will not be completed yet)\n         * @event\n         * @name open_node.jstree\n         * @param {Object} node the opened node\n         */\n\n\n        this.trigger('open_node', {\n          \"node\": obj\n        });\n\n        if (!animation || !d.length) {\n          /**\n           * triggered when a node is opened and the animation is complete\n           * @event\n           * @name after_open.jstree\n           * @param {Object} node the opened node\n           */\n          this.trigger(\"after_open\", {\n            \"node\": obj\n          });\n        }\n\n        return true;\n      }\n    },\n\n    /**\n     * opens every parent of a node (node should be loaded)\n     * @name _open_to(obj)\n     * @param {mixed} obj the node to reveal\n     * @private\n     */\n    _open_to: function _open_to(obj) {\n      obj = this.get_node(obj);\n\n      if (!obj || obj.id === $.jstree.root) {\n        return false;\n      }\n\n      var i,\n          j,\n          p = obj.parents;\n\n      for (i = 0, j = p.length; i < j; i += 1) {\n        if (i !== $.jstree.root) {\n          this.open_node(p[i], false, 0);\n        }\n      }\n\n      return $('#' + obj.id.replace($.jstree.idregex, '\\\\$&'), this.element);\n    },\n\n    /**\n     * closes a node, hiding its children\n     * @name close_node(obj [, animation])\n     * @param {mixed} obj the node to close\n     * @param {Number} animation the animation duration in milliseconds when closing the node (overrides the `core.animation` setting). Use `false` for no animation.\n     * @trigger close_node.jstree, after_close.jstree\n     */\n    close_node: function close_node(obj, animation) {\n      var t1, t2, t, d;\n\n      if ($.isArray(obj)) {\n        obj = obj.slice();\n\n        for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n          this.close_node(obj[t1], animation);\n        }\n\n        return true;\n      }\n\n      obj = this.get_node(obj);\n\n      if (!obj || obj.id === $.jstree.root) {\n        return false;\n      }\n\n      if (this.is_closed(obj)) {\n        return false;\n      }\n\n      animation = animation === undefined ? this.settings.core.animation : animation;\n      t = this;\n      d = this.get_node(obj, true);\n      obj.state.opened = false;\n      /**\n       * triggered when a node is closed (if there is an animation it will not be complete yet)\n       * @event\n       * @name close_node.jstree\n       * @param {Object} node the closed node\n       */\n\n      this.trigger('close_node', {\n        \"node\": obj\n      });\n\n      if (!d.length) {\n        /**\n         * triggered when a node is closed and the animation is complete\n         * @event\n         * @name after_close.jstree\n         * @param {Object} node the closed node\n         */\n        this.trigger(\"after_close\", {\n          \"node\": obj\n        });\n      } else {\n        if (!animation) {\n          d[0].className = d[0].className.replace('jstree-open', 'jstree-closed');\n          d.attr(\"aria-expanded\", false).children('.jstree-children').remove();\n          this.trigger(\"after_close\", {\n            \"node\": obj\n          });\n        } else {\n          d.children(\".jstree-children\").attr(\"style\", \"display:block !important\").end().removeClass(\"jstree-open\").addClass(\"jstree-closed\").attr(\"aria-expanded\", false).children(\".jstree-children\").stop(true, true).slideUp(animation, function () {\n            this.style.display = \"\";\n            d.children('.jstree-children').remove();\n\n            if (t.element) {\n              t.trigger(\"after_close\", {\n                \"node\": obj\n              });\n            }\n          });\n        }\n      }\n    },\n\n    /**\n     * toggles a node - closing it if it is open, opening it if it is closed\n     * @name toggle_node(obj)\n     * @param {mixed} obj the node to toggle\n     */\n    toggle_node: function toggle_node(obj) {\n      var t1, t2;\n\n      if ($.isArray(obj)) {\n        obj = obj.slice();\n\n        for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n          this.toggle_node(obj[t1]);\n        }\n\n        return true;\n      }\n\n      if (this.is_closed(obj)) {\n        return this.open_node(obj);\n      }\n\n      if (this.is_open(obj)) {\n        return this.close_node(obj);\n      }\n    },\n\n    /**\n     * opens all nodes within a node (or the tree), revaling their children. If the node is not loaded it will be loaded and opened once ready.\n     * @name open_all([obj, animation, original_obj])\n     * @param {mixed} obj the node to open recursively, omit to open all nodes in the tree\n     * @param {Number} animation the animation duration in milliseconds when opening the nodes, the default is no animation\n     * @param {jQuery} reference to the node that started the process (internal use)\n     * @trigger open_all.jstree\n     */\n    open_all: function open_all(obj, animation, original_obj) {\n      if (!obj) {\n        obj = $.jstree.root;\n      }\n\n      obj = this.get_node(obj);\n\n      if (!obj) {\n        return false;\n      }\n\n      var dom = obj.id === $.jstree.root ? this.get_container_ul() : this.get_node(obj, true),\n          i,\n          j,\n          _this;\n\n      if (!dom.length) {\n        for (i = 0, j = obj.children_d.length; i < j; i++) {\n          if (this.is_closed(this._model.data[obj.children_d[i]])) {\n            this._model.data[obj.children_d[i]].state.opened = true;\n          }\n        }\n\n        return this.trigger('open_all', {\n          \"node\": obj\n        });\n      }\n\n      original_obj = original_obj || dom;\n      _this = this;\n      dom = this.is_closed(obj) ? dom.find('.jstree-closed').addBack() : dom.find('.jstree-closed');\n      dom.each(function () {\n        _this.open_node(this, function (node, status) {\n          if (status && this.is_parent(node)) {\n            this.open_all(node, animation, original_obj);\n          }\n        }, animation || 0);\n      });\n\n      if (original_obj.find('.jstree-closed').length === 0) {\n        /**\n         * triggered when an `open_all` call completes\n         * @event\n         * @name open_all.jstree\n         * @param {Object} node the opened node\n         */\n        this.trigger('open_all', {\n          \"node\": this.get_node(original_obj)\n        });\n      }\n    },\n\n    /**\n     * closes all nodes within a node (or the tree), revaling their children\n     * @name close_all([obj, animation])\n     * @param {mixed} obj the node to close recursively, omit to close all nodes in the tree\n     * @param {Number} animation the animation duration in milliseconds when closing the nodes, the default is no animation\n     * @trigger close_all.jstree\n     */\n    close_all: function close_all(obj, animation) {\n      if (!obj) {\n        obj = $.jstree.root;\n      }\n\n      obj = this.get_node(obj);\n\n      if (!obj) {\n        return false;\n      }\n\n      var dom = obj.id === $.jstree.root ? this.get_container_ul() : this.get_node(obj, true),\n          _this = this,\n          i,\n          j;\n\n      if (dom.length) {\n        dom = this.is_open(obj) ? dom.find('.jstree-open').addBack() : dom.find('.jstree-open');\n        $(dom.get().reverse()).each(function () {\n          _this.close_node(this, animation || 0);\n        });\n      }\n\n      for (i = 0, j = obj.children_d.length; i < j; i++) {\n        this._model.data[obj.children_d[i]].state.opened = false;\n      }\n      /**\n       * triggered when an `close_all` call completes\n       * @event\n       * @name close_all.jstree\n       * @param {Object} node the closed node\n       */\n\n\n      this.trigger('close_all', {\n        \"node\": obj\n      });\n    },\n\n    /**\n     * checks if a node is disabled (not selectable)\n     * @name is_disabled(obj)\n     * @param  {mixed} obj\n     * @return {Boolean}\n     */\n    is_disabled: function is_disabled(obj) {\n      obj = this.get_node(obj);\n      return obj && obj.state && obj.state.disabled;\n    },\n\n    /**\n     * enables a node - so that it can be selected\n     * @name enable_node(obj)\n     * @param {mixed} obj the node to enable\n     * @trigger enable_node.jstree\n     */\n    enable_node: function enable_node(obj) {\n      var t1, t2;\n\n      if ($.isArray(obj)) {\n        obj = obj.slice();\n\n        for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n          this.enable_node(obj[t1]);\n        }\n\n        return true;\n      }\n\n      obj = this.get_node(obj);\n\n      if (!obj || obj.id === $.jstree.root) {\n        return false;\n      }\n\n      obj.state.disabled = false;\n      this.get_node(obj, true).children('.jstree-anchor').removeClass('jstree-disabled').attr('aria-disabled', false);\n      /**\n       * triggered when an node is enabled\n       * @event\n       * @name enable_node.jstree\n       * @param {Object} node the enabled node\n       */\n\n      this.trigger('enable_node', {\n        'node': obj\n      });\n    },\n\n    /**\n     * disables a node - so that it can not be selected\n     * @name disable_node(obj)\n     * @param {mixed} obj the node to disable\n     * @trigger disable_node.jstree\n     */\n    disable_node: function disable_node(obj) {\n      var t1, t2;\n\n      if ($.isArray(obj)) {\n        obj = obj.slice();\n\n        for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n          this.disable_node(obj[t1]);\n        }\n\n        return true;\n      }\n\n      obj = this.get_node(obj);\n\n      if (!obj || obj.id === $.jstree.root) {\n        return false;\n      }\n\n      obj.state.disabled = true;\n      this.get_node(obj, true).children('.jstree-anchor').addClass('jstree-disabled').attr('aria-disabled', true);\n      /**\n       * triggered when an node is disabled\n       * @event\n       * @name disable_node.jstree\n       * @param {Object} node the disabled node\n       */\n\n      this.trigger('disable_node', {\n        'node': obj\n      });\n    },\n\n    /**\n     * determines if a node is hidden\n     * @name is_hidden(obj)\n     * @param {mixed} obj the node\n     */\n    is_hidden: function is_hidden(obj) {\n      obj = this.get_node(obj);\n      return obj.state.hidden === true;\n    },\n\n    /**\n     * hides a node - it is still in the structure but will not be visible\n     * @name hide_node(obj)\n     * @param {mixed} obj the node to hide\n     * @param {Boolean} skip_redraw internal parameter controlling if redraw is called\n     * @trigger hide_node.jstree\n     */\n    hide_node: function hide_node(obj, skip_redraw) {\n      var t1, t2;\n\n      if ($.isArray(obj)) {\n        obj = obj.slice();\n\n        for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n          this.hide_node(obj[t1], true);\n        }\n\n        if (!skip_redraw) {\n          this.redraw();\n        }\n\n        return true;\n      }\n\n      obj = this.get_node(obj);\n\n      if (!obj || obj.id === $.jstree.root) {\n        return false;\n      }\n\n      if (!obj.state.hidden) {\n        obj.state.hidden = true;\n\n        this._node_changed(obj.parent);\n\n        if (!skip_redraw) {\n          this.redraw();\n        }\n        /**\n         * triggered when an node is hidden\n         * @event\n         * @name hide_node.jstree\n         * @param {Object} node the hidden node\n         */\n\n\n        this.trigger('hide_node', {\n          'node': obj\n        });\n      }\n    },\n\n    /**\n     * shows a node\n     * @name show_node(obj)\n     * @param {mixed} obj the node to show\n     * @param {Boolean} skip_redraw internal parameter controlling if redraw is called\n     * @trigger show_node.jstree\n     */\n    show_node: function show_node(obj, skip_redraw) {\n      var t1, t2;\n\n      if ($.isArray(obj)) {\n        obj = obj.slice();\n\n        for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n          this.show_node(obj[t1], true);\n        }\n\n        if (!skip_redraw) {\n          this.redraw();\n        }\n\n        return true;\n      }\n\n      obj = this.get_node(obj);\n\n      if (!obj || obj.id === $.jstree.root) {\n        return false;\n      }\n\n      if (obj.state.hidden) {\n        obj.state.hidden = false;\n\n        this._node_changed(obj.parent);\n\n        if (!skip_redraw) {\n          this.redraw();\n        }\n        /**\n         * triggered when an node is shown\n         * @event\n         * @name show_node.jstree\n         * @param {Object} node the shown node\n         */\n\n\n        this.trigger('show_node', {\n          'node': obj\n        });\n      }\n    },\n\n    /**\n     * hides all nodes\n     * @name hide_all()\n     * @trigger hide_all.jstree\n     */\n    hide_all: function hide_all(skip_redraw) {\n      var i,\n          m = this._model.data,\n          ids = [];\n\n      for (i in m) {\n        if (m.hasOwnProperty(i) && i !== $.jstree.root && !m[i].state.hidden) {\n          m[i].state.hidden = true;\n          ids.push(i);\n        }\n      }\n\n      this._model.force_full_redraw = true;\n\n      if (!skip_redraw) {\n        this.redraw();\n      }\n      /**\n       * triggered when all nodes are hidden\n       * @event\n       * @name hide_all.jstree\n       * @param {Array} nodes the IDs of all hidden nodes\n       */\n\n\n      this.trigger('hide_all', {\n        'nodes': ids\n      });\n      return ids;\n    },\n\n    /**\n     * shows all nodes\n     * @name show_all()\n     * @trigger show_all.jstree\n     */\n    show_all: function show_all(skip_redraw) {\n      var i,\n          m = this._model.data,\n          ids = [];\n\n      for (i in m) {\n        if (m.hasOwnProperty(i) && i !== $.jstree.root && m[i].state.hidden) {\n          m[i].state.hidden = false;\n          ids.push(i);\n        }\n      }\n\n      this._model.force_full_redraw = true;\n\n      if (!skip_redraw) {\n        this.redraw();\n      }\n      /**\n       * triggered when all nodes are shown\n       * @event\n       * @name show_all.jstree\n       * @param {Array} nodes the IDs of all shown nodes\n       */\n\n\n      this.trigger('show_all', {\n        'nodes': ids\n      });\n      return ids;\n    },\n\n    /**\n     * called when a node is selected by the user. Used internally.\n     * @private\n     * @name activate_node(obj, e)\n     * @param {mixed} obj the node\n     * @param {Object} e the related event\n     * @trigger activate_node.jstree, changed.jstree\n     */\n    activate_node: function activate_node(obj, e) {\n      if (this.is_disabled(obj)) {\n        return false;\n      }\n\n      if (!e || _typeof(e) !== 'object') {\n        e = {};\n      } // ensure last_clicked is still in the DOM, make it fresh (maybe it was moved?) and make sure it is still selected, if not - make last_clicked the last selected node\n\n\n      this._data.core.last_clicked = this._data.core.last_clicked && this._data.core.last_clicked.id !== undefined ? this.get_node(this._data.core.last_clicked.id) : null;\n\n      if (this._data.core.last_clicked && !this._data.core.last_clicked.state.selected) {\n        this._data.core.last_clicked = null;\n      }\n\n      if (!this._data.core.last_clicked && this._data.core.selected.length) {\n        this._data.core.last_clicked = this.get_node(this._data.core.selected[this._data.core.selected.length - 1]);\n      }\n\n      if (!this.settings.core.multiple || !e.metaKey && !e.ctrlKey && !e.shiftKey || e.shiftKey && (!this._data.core.last_clicked || !this.get_parent(obj) || this.get_parent(obj) !== this._data.core.last_clicked.parent)) {\n        if (!this.settings.core.multiple && (e.metaKey || e.ctrlKey || e.shiftKey) && this.is_selected(obj)) {\n          this.deselect_node(obj, false, e);\n        } else {\n          this.deselect_all(true);\n          this.select_node(obj, false, false, e);\n          this._data.core.last_clicked = this.get_node(obj);\n        }\n      } else {\n        if (e.shiftKey) {\n          var o = this.get_node(obj).id,\n              l = this._data.core.last_clicked.id,\n              p = this.get_node(this._data.core.last_clicked.parent).children,\n              c = false,\n              i,\n              j;\n\n          for (i = 0, j = p.length; i < j; i += 1) {\n            // separate IFs work whem o and l are the same\n            if (p[i] === o) {\n              c = !c;\n            }\n\n            if (p[i] === l) {\n              c = !c;\n            }\n\n            if (!this.is_disabled(p[i]) && (c || p[i] === o || p[i] === l)) {\n              if (!this.is_hidden(p[i])) {\n                this.select_node(p[i], true, false, e);\n              }\n            } else {\n              this.deselect_node(p[i], true, e);\n            }\n          }\n\n          this.trigger('changed', {\n            'action': 'select_node',\n            'node': this.get_node(obj),\n            'selected': this._data.core.selected,\n            'event': e\n          });\n        } else {\n          if (!this.is_selected(obj)) {\n            this.select_node(obj, false, false, e);\n          } else {\n            this.deselect_node(obj, false, e);\n          }\n        }\n      }\n      /**\n       * triggered when an node is clicked or intercated with by the user\n       * @event\n       * @name activate_node.jstree\n       * @param {Object} node\n       * @param {Object} event the ooriginal event (if any) which triggered the call (may be an empty object)\n       */\n\n\n      this.trigger('activate_node', {\n        'node': this.get_node(obj),\n        'event': e\n      });\n    },\n\n    /**\n     * applies the hover state on a node, called when a node is hovered by the user. Used internally.\n     * @private\n     * @name hover_node(obj)\n     * @param {mixed} obj\n     * @trigger hover_node.jstree\n     */\n    hover_node: function hover_node(obj) {\n      obj = this.get_node(obj, true);\n\n      if (!obj || !obj.length || obj.children('.jstree-hovered').length) {\n        return false;\n      }\n\n      var o = this.element.find('.jstree-hovered'),\n          t = this.element;\n\n      if (o && o.length) {\n        this.dehover_node(o);\n      }\n\n      obj.children('.jstree-anchor').addClass('jstree-hovered');\n      /**\n       * triggered when an node is hovered\n       * @event\n       * @name hover_node.jstree\n       * @param {Object} node\n       */\n\n      this.trigger('hover_node', {\n        'node': this.get_node(obj)\n      });\n      setTimeout(function () {\n        t.attr('aria-activedescendant', obj[0].id);\n      }, 0);\n    },\n\n    /**\n     * removes the hover state from a nodecalled when a node is no longer hovered by the user. Used internally.\n     * @private\n     * @name dehover_node(obj)\n     * @param {mixed} obj\n     * @trigger dehover_node.jstree\n     */\n    dehover_node: function dehover_node(obj) {\n      obj = this.get_node(obj, true);\n\n      if (!obj || !obj.length || !obj.children('.jstree-hovered').length) {\n        return false;\n      }\n\n      obj.children('.jstree-anchor').removeClass('jstree-hovered');\n      /**\n       * triggered when an node is no longer hovered\n       * @event\n       * @name dehover_node.jstree\n       * @param {Object} node\n       */\n\n      this.trigger('dehover_node', {\n        'node': this.get_node(obj)\n      });\n    },\n\n    /**\n     * select a node\n     * @name select_node(obj [, supress_event, prevent_open])\n     * @param {mixed} obj an array can be used to select multiple nodes\n     * @param {Boolean} supress_event if set to `true` the `changed.jstree` event won't be triggered\n     * @param {Boolean} prevent_open if set to `true` parents of the selected node won't be opened\n     * @trigger select_node.jstree, changed.jstree\n     */\n    select_node: function select_node(obj, supress_event, prevent_open, e) {\n      var dom, t1, t2, th;\n\n      if ($.isArray(obj)) {\n        obj = obj.slice();\n\n        for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n          this.select_node(obj[t1], supress_event, prevent_open, e);\n        }\n\n        return true;\n      }\n\n      obj = this.get_node(obj);\n\n      if (!obj || obj.id === $.jstree.root) {\n        return false;\n      }\n\n      dom = this.get_node(obj, true);\n\n      if (!obj.state.selected) {\n        obj.state.selected = true;\n\n        this._data.core.selected.push(obj.id);\n\n        if (!prevent_open) {\n          dom = this._open_to(obj);\n        }\n\n        if (dom && dom.length) {\n          dom.attr('aria-selected', true).children('.jstree-anchor').addClass('jstree-clicked');\n        }\n        /**\n         * triggered when an node is selected\n         * @event\n         * @name select_node.jstree\n         * @param {Object} node\n         * @param {Array} selected the current selection\n         * @param {Object} event the event (if any) that triggered this select_node\n         */\n\n\n        this.trigger('select_node', {\n          'node': obj,\n          'selected': this._data.core.selected,\n          'event': e\n        });\n\n        if (!supress_event) {\n          /**\n           * triggered when selection changes\n           * @event\n           * @name changed.jstree\n           * @param {Object} node\n           * @param {Object} action the action that caused the selection to change\n           * @param {Array} selected the current selection\n           * @param {Object} event the event (if any) that triggered this changed event\n           */\n          this.trigger('changed', {\n            'action': 'select_node',\n            'node': obj,\n            'selected': this._data.core.selected,\n            'event': e\n          });\n        }\n      }\n    },\n\n    /**\n     * deselect a node\n     * @name deselect_node(obj [, supress_event])\n     * @param {mixed} obj an array can be used to deselect multiple nodes\n     * @param {Boolean} supress_event if set to `true` the `changed.jstree` event won't be triggered\n     * @trigger deselect_node.jstree, changed.jstree\n     */\n    deselect_node: function deselect_node(obj, supress_event, e) {\n      var t1, t2, dom;\n\n      if ($.isArray(obj)) {\n        obj = obj.slice();\n\n        for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n          this.deselect_node(obj[t1], supress_event, e);\n        }\n\n        return true;\n      }\n\n      obj = this.get_node(obj);\n\n      if (!obj || obj.id === $.jstree.root) {\n        return false;\n      }\n\n      dom = this.get_node(obj, true);\n\n      if (obj.state.selected) {\n        obj.state.selected = false;\n        this._data.core.selected = $.vakata.array_remove_item(this._data.core.selected, obj.id);\n\n        if (dom.length) {\n          dom.attr('aria-selected', false).children('.jstree-anchor').removeClass('jstree-clicked');\n        }\n        /**\n         * triggered when an node is deselected\n         * @event\n         * @name deselect_node.jstree\n         * @param {Object} node\n         * @param {Array} selected the current selection\n         * @param {Object} event the event (if any) that triggered this deselect_node\n         */\n\n\n        this.trigger('deselect_node', {\n          'node': obj,\n          'selected': this._data.core.selected,\n          'event': e\n        });\n\n        if (!supress_event) {\n          this.trigger('changed', {\n            'action': 'deselect_node',\n            'node': obj,\n            'selected': this._data.core.selected,\n            'event': e\n          });\n        }\n      }\n    },\n\n    /**\n     * select all nodes in the tree\n     * @name select_all([supress_event])\n     * @param {Boolean} supress_event if set to `true` the `changed.jstree` event won't be triggered\n     * @trigger select_all.jstree, changed.jstree\n     */\n    select_all: function select_all(supress_event) {\n      var tmp = this._data.core.selected.concat([]),\n          i,\n          j;\n\n      this._data.core.selected = this._model.data[$.jstree.root].children_d.concat();\n\n      for (i = 0, j = this._data.core.selected.length; i < j; i++) {\n        if (this._model.data[this._data.core.selected[i]]) {\n          this._model.data[this._data.core.selected[i]].state.selected = true;\n        }\n      }\n\n      this.redraw(true);\n      /**\n       * triggered when all nodes are selected\n       * @event\n       * @name select_all.jstree\n       * @param {Array} selected the current selection\n       */\n\n      this.trigger('select_all', {\n        'selected': this._data.core.selected\n      });\n\n      if (!supress_event) {\n        this.trigger('changed', {\n          'action': 'select_all',\n          'selected': this._data.core.selected,\n          'old_selection': tmp\n        });\n      }\n    },\n\n    /**\n     * deselect all selected nodes\n     * @name deselect_all([supress_event])\n     * @param {Boolean} supress_event if set to `true` the `changed.jstree` event won't be triggered\n     * @trigger deselect_all.jstree, changed.jstree\n     */\n    deselect_all: function deselect_all(supress_event) {\n      var tmp = this._data.core.selected.concat([]),\n          i,\n          j;\n\n      for (i = 0, j = this._data.core.selected.length; i < j; i++) {\n        if (this._model.data[this._data.core.selected[i]]) {\n          this._model.data[this._data.core.selected[i]].state.selected = false;\n        }\n      }\n\n      this._data.core.selected = [];\n      this.element.find('.jstree-clicked').removeClass('jstree-clicked').parent().attr('aria-selected', false);\n      /**\n       * triggered when all nodes are deselected\n       * @event\n       * @name deselect_all.jstree\n       * @param {Object} node the previous selection\n       * @param {Array} selected the current selection\n       */\n\n      this.trigger('deselect_all', {\n        'selected': this._data.core.selected,\n        'node': tmp\n      });\n\n      if (!supress_event) {\n        this.trigger('changed', {\n          'action': 'deselect_all',\n          'selected': this._data.core.selected,\n          'old_selection': tmp\n        });\n      }\n    },\n\n    /**\n     * checks if a node is selected\n     * @name is_selected(obj)\n     * @param  {mixed}  obj\n     * @return {Boolean}\n     */\n    is_selected: function is_selected(obj) {\n      obj = this.get_node(obj);\n\n      if (!obj || obj.id === $.jstree.root) {\n        return false;\n      }\n\n      return obj.state.selected;\n    },\n\n    /**\n     * get an array of all selected nodes\n     * @name get_selected([full])\n     * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned\n     * @return {Array}\n     */\n    get_selected: function get_selected(full) {\n      return full ? $.map(this._data.core.selected, $.proxy(function (i) {\n        return this.get_node(i);\n      }, this)) : this._data.core.selected.slice();\n    },\n\n    /**\n     * get an array of all top level selected nodes (ignoring children of selected nodes)\n     * @name get_top_selected([full])\n     * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned\n     * @return {Array}\n     */\n    get_top_selected: function get_top_selected(full) {\n      var tmp = this.get_selected(true),\n          obj = {},\n          i,\n          j,\n          k,\n          l;\n\n      for (i = 0, j = tmp.length; i < j; i++) {\n        obj[tmp[i].id] = tmp[i];\n      }\n\n      for (i = 0, j = tmp.length; i < j; i++) {\n        for (k = 0, l = tmp[i].children_d.length; k < l; k++) {\n          if (obj[tmp[i].children_d[k]]) {\n            delete obj[tmp[i].children_d[k]];\n          }\n        }\n      }\n\n      tmp = [];\n\n      for (i in obj) {\n        if (obj.hasOwnProperty(i)) {\n          tmp.push(i);\n        }\n      }\n\n      return full ? $.map(tmp, $.proxy(function (i) {\n        return this.get_node(i);\n      }, this)) : tmp;\n    },\n\n    /**\n     * get an array of all bottom level selected nodes (ignoring selected parents)\n     * @name get_bottom_selected([full])\n     * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned\n     * @return {Array}\n     */\n    get_bottom_selected: function get_bottom_selected(full) {\n      var tmp = this.get_selected(true),\n          obj = [],\n          i,\n          j;\n\n      for (i = 0, j = tmp.length; i < j; i++) {\n        if (!tmp[i].children.length) {\n          obj.push(tmp[i].id);\n        }\n      }\n\n      return full ? $.map(obj, $.proxy(function (i) {\n        return this.get_node(i);\n      }, this)) : obj;\n    },\n\n    /**\n     * gets the current state of the tree so that it can be restored later with `set_state(state)`. Used internally.\n     * @name get_state()\n     * @private\n     * @return {Object}\n     */\n    get_state: function get_state() {\n      var state = {\n        'core': {\n          'open': [],\n          'scroll': {\n            'left': this.element.scrollLeft(),\n            'top': this.element.scrollTop()\n          },\n\n          /*!\n          'themes' : {\n          \t'name' : this.get_theme(),\n          \t'icons' : this._data.core.themes.icons,\n          \t'dots' : this._data.core.themes.dots\n          },\n          */\n          'selected': []\n        }\n      },\n          i;\n\n      for (i in this._model.data) {\n        if (this._model.data.hasOwnProperty(i)) {\n          if (i !== $.jstree.root) {\n            if (this._model.data[i].state.opened) {\n              state.core.open.push(i);\n            }\n\n            if (this._model.data[i].state.selected) {\n              state.core.selected.push(i);\n            }\n          }\n        }\n      }\n\n      return state;\n    },\n\n    /**\n     * sets the state of the tree. Used internally.\n     * @name set_state(state [, callback])\n     * @private\n     * @param {Object} state the state to restore. Keep in mind this object is passed by reference and jstree will modify it.\n     * @param {Function} callback an optional function to execute once the state is restored.\n     * @trigger set_state.jstree\n     */\n    set_state: function set_state(state, callback) {\n      if (state) {\n        if (state.core) {\n          var res, n, t, _this, i;\n\n          if (state.core.open) {\n            if (!$.isArray(state.core.open) || !state.core.open.length) {\n              delete state.core.open;\n              this.set_state(state, callback);\n            } else {\n              this._load_nodes(state.core.open, function (nodes) {\n                this.open_node(nodes, false, 0);\n                delete state.core.open;\n                this.set_state(state, callback);\n              });\n            }\n\n            return false;\n          }\n\n          if (state.core.scroll) {\n            if (state.core.scroll && state.core.scroll.left !== undefined) {\n              this.element.scrollLeft(state.core.scroll.left);\n            }\n\n            if (state.core.scroll && state.core.scroll.top !== undefined) {\n              this.element.scrollTop(state.core.scroll.top);\n            }\n\n            delete state.core.scroll;\n            this.set_state(state, callback);\n            return false;\n          }\n\n          if (state.core.selected) {\n            _this = this;\n            this.deselect_all();\n            $.each(state.core.selected, function (i, v) {\n              _this.select_node(v, false, true);\n            });\n            delete state.core.selected;\n            this.set_state(state, callback);\n            return false;\n          }\n\n          for (i in state) {\n            if (state.hasOwnProperty(i) && i !== \"core\" && $.inArray(i, this.settings.plugins) === -1) {\n              delete state[i];\n            }\n          }\n\n          if ($.isEmptyObject(state.core)) {\n            delete state.core;\n            this.set_state(state, callback);\n            return false;\n          }\n        }\n\n        if ($.isEmptyObject(state)) {\n          state = null;\n\n          if (callback) {\n            callback.call(this);\n          }\n          /**\n           * triggered when a `set_state` call completes\n           * @event\n           * @name set_state.jstree\n           */\n\n\n          this.trigger('set_state');\n          return false;\n        }\n\n        return true;\n      }\n\n      return false;\n    },\n\n    /**\n     * refreshes the tree - all nodes are reloaded with calls to `load_node`.\n     * @name refresh()\n     * @param {Boolean} skip_loading an option to skip showing the loading indicator\n     * @param {Mixed} forget_state if set to `true` state will not be reapplied, if set to a function (receiving the current state as argument) the result of that function will be used as state\n     * @trigger refresh.jstree\n     */\n    refresh: function refresh(skip_loading, forget_state) {\n      this._data.core.state = forget_state === true ? {} : this.get_state();\n\n      if (forget_state && $.isFunction(forget_state)) {\n        this._data.core.state = forget_state.call(this, this._data.core.state);\n      }\n\n      this._cnt = 0;\n      this._model.data = {};\n      this._model.data[$.jstree.root] = {\n        id: $.jstree.root,\n        parent: null,\n        parents: [],\n        children: [],\n        children_d: [],\n        state: {\n          loaded: false\n        }\n      };\n      this._data.core.selected = [];\n      this._data.core.last_clicked = null;\n      this._data.core.focused = null;\n      var c = this.get_container_ul()[0].className;\n\n      if (!skip_loading) {\n        this.element.html(\"<\" + \"ul class='\" + c + \"' role='group'><\" + \"li class='jstree-initial-node jstree-loading jstree-leaf jstree-last' role='treeitem' id='j\" + this._id + \"_loading'><i class='jstree-icon jstree-ocl'></i><\" + \"a class='jstree-anchor' href='#'><i class='jstree-icon jstree-themeicon-hidden'></i>\" + this.get_string(\"Loading ...\") + \"</a></li></ul>\");\n        this.element.attr('aria-activedescendant', 'j' + this._id + '_loading');\n      }\n\n      this.load_node($.jstree.root, function (o, s) {\n        if (s) {\n          this.get_container_ul()[0].className = c;\n\n          if (this._firstChild(this.get_container_ul()[0])) {\n            this.element.attr('aria-activedescendant', this._firstChild(this.get_container_ul()[0]).id);\n          }\n\n          this.set_state($.extend(true, {}, this._data.core.state), function () {\n            /**\n             * triggered when a `refresh` call completes\n             * @event\n             * @name refresh.jstree\n             */\n            this.trigger('refresh');\n          });\n        }\n\n        this._data.core.state = null;\n      });\n    },\n\n    /**\n     * refreshes a node in the tree (reload its children) all opened nodes inside that node are reloaded with calls to `load_node`.\n     * @name refresh_node(obj)\n     * @param  {mixed} obj the node\n     * @trigger refresh_node.jstree\n     */\n    refresh_node: function refresh_node(obj) {\n      obj = this.get_node(obj);\n\n      if (!obj || obj.id === $.jstree.root) {\n        return false;\n      }\n\n      var opened = [],\n          to_load = [],\n          s = this._data.core.selected.concat([]);\n\n      to_load.push(obj.id);\n\n      if (obj.state.opened === true) {\n        opened.push(obj.id);\n      }\n\n      this.get_node(obj, true).find('.jstree-open').each(function () {\n        to_load.push(this.id);\n        opened.push(this.id);\n      });\n\n      this._load_nodes(to_load, $.proxy(function (nodes) {\n        this.open_node(opened, false, 0);\n        this.select_node(s);\n        /**\n         * triggered when a node is refreshed\n         * @event\n         * @name refresh_node.jstree\n         * @param {Object} node - the refreshed node\n         * @param {Array} nodes - an array of the IDs of the nodes that were reloaded\n         */\n\n        this.trigger('refresh_node', {\n          'node': obj,\n          'nodes': nodes\n        });\n      }, this), false, true);\n    },\n\n    /**\n     * set (change) the ID of a node\n     * @name set_id(obj, id)\n     * @param  {mixed} obj the node\n     * @param  {String} id the new ID\n     * @return {Boolean}\n     * @trigger set_id.jstree\n     */\n    set_id: function set_id(obj, id) {\n      obj = this.get_node(obj);\n\n      if (!obj || obj.id === $.jstree.root) {\n        return false;\n      }\n\n      var i,\n          j,\n          m = this._model.data,\n          old = obj.id;\n      id = id.toString(); // update parents (replace current ID with new one in children and children_d)\n\n      m[obj.parent].children[$.inArray(obj.id, m[obj.parent].children)] = id;\n\n      for (i = 0, j = obj.parents.length; i < j; i++) {\n        m[obj.parents[i]].children_d[$.inArray(obj.id, m[obj.parents[i]].children_d)] = id;\n      } // update children (replace current ID with new one in parent and parents)\n\n\n      for (i = 0, j = obj.children.length; i < j; i++) {\n        m[obj.children[i]].parent = id;\n      }\n\n      for (i = 0, j = obj.children_d.length; i < j; i++) {\n        m[obj.children_d[i]].parents[$.inArray(obj.id, m[obj.children_d[i]].parents)] = id;\n      }\n\n      i = $.inArray(obj.id, this._data.core.selected);\n\n      if (i !== -1) {\n        this._data.core.selected[i] = id;\n      } // update model and obj itself (obj.id, this._model.data[KEY])\n\n\n      i = this.get_node(obj.id, true);\n\n      if (i) {\n        i.attr('id', id); //.children('.jstree-anchor').attr('id', id + '_anchor').end().attr('aria-labelledby', id + '_anchor');\n\n        if (this.element.attr('aria-activedescendant') === obj.id) {\n          this.element.attr('aria-activedescendant', id);\n        }\n      }\n\n      delete m[obj.id];\n      obj.id = id;\n      obj.li_attr.id = id;\n      m[id] = obj;\n      /**\n       * triggered when a node id value is changed\n       * @event\n       * @name set_id.jstree\n       * @param {Object} node\n       * @param {String} old the old id\n       */\n\n      this.trigger('set_id', {\n        \"node\": obj,\n        \"new\": obj.id,\n        \"old\": old\n      });\n      return true;\n    },\n\n    /**\n     * get the text value of a node\n     * @name get_text(obj)\n     * @param  {mixed} obj the node\n     * @return {String}\n     */\n    get_text: function get_text(obj) {\n      obj = this.get_node(obj);\n      return !obj || obj.id === $.jstree.root ? false : obj.text;\n    },\n\n    /**\n     * set the text value of a node. Used internally, please use `rename_node(obj, val)`.\n     * @private\n     * @name set_text(obj, val)\n     * @param  {mixed} obj the node, you can pass an array to set the text on multiple nodes\n     * @param  {String} val the new text value\n     * @return {Boolean}\n     * @trigger set_text.jstree\n     */\n    set_text: function set_text(obj, val) {\n      var t1, t2;\n\n      if ($.isArray(obj)) {\n        obj = obj.slice();\n\n        for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n          this.set_text(obj[t1], val);\n        }\n\n        return true;\n      }\n\n      obj = this.get_node(obj);\n\n      if (!obj || obj.id === $.jstree.root) {\n        return false;\n      }\n\n      obj.text = val;\n\n      if (this.get_node(obj, true).length) {\n        this.redraw_node(obj.id);\n      }\n      /**\n       * triggered when a node text value is changed\n       * @event\n       * @name set_text.jstree\n       * @param {Object} obj\n       * @param {String} text the new value\n       */\n\n\n      this.trigger('set_text', {\n        \"obj\": obj,\n        \"text\": val\n      });\n      return true;\n    },\n\n    /**\n     * gets a JSON representation of a node (or the whole tree)\n     * @name get_json([obj, options])\n     * @param  {mixed} obj\n     * @param  {Object} options\n     * @param  {Boolean} options.no_state do not return state information\n     * @param  {Boolean} options.no_id do not return ID\n     * @param  {Boolean} options.no_children do not include children\n     * @param  {Boolean} options.no_data do not include node data\n     * @param  {Boolean} options.no_li_attr do not include LI attributes\n     * @param  {Boolean} options.no_a_attr do not include A attributes\n     * @param  {Boolean} options.flat return flat JSON instead of nested\n     * @return {Object}\n     */\n    get_json: function get_json(obj, options, flat) {\n      obj = this.get_node(obj || $.jstree.root);\n\n      if (!obj) {\n        return false;\n      }\n\n      if (options && options.flat && !flat) {\n        flat = [];\n      }\n\n      var tmp = {\n        'id': obj.id,\n        'text': obj.text,\n        'icon': this.get_icon(obj),\n        'li_attr': $.extend(true, {}, obj.li_attr),\n        'a_attr': $.extend(true, {}, obj.a_attr),\n        'state': {},\n        'data': options && options.no_data ? false : $.extend(true, {}, obj.data) //( this.get_node(obj, true).length ? this.get_node(obj, true).data() : obj.data ),\n\n      },\n          i,\n          j;\n\n      if (options && options.flat) {\n        tmp.parent = obj.parent;\n      } else {\n        tmp.children = [];\n      }\n\n      if (!options || !options.no_state) {\n        for (i in obj.state) {\n          if (obj.state.hasOwnProperty(i)) {\n            tmp.state[i] = obj.state[i];\n          }\n        }\n      } else {\n        delete tmp.state;\n      }\n\n      if (options && options.no_li_attr) {\n        delete tmp.li_attr;\n      }\n\n      if (options && options.no_a_attr) {\n        delete tmp.a_attr;\n      }\n\n      if (options && options.no_id) {\n        delete tmp.id;\n\n        if (tmp.li_attr && tmp.li_attr.id) {\n          delete tmp.li_attr.id;\n        }\n\n        if (tmp.a_attr && tmp.a_attr.id) {\n          delete tmp.a_attr.id;\n        }\n      }\n\n      if (options && options.flat && obj.id !== $.jstree.root) {\n        flat.push(tmp);\n      }\n\n      if (!options || !options.no_children) {\n        for (i = 0, j = obj.children.length; i < j; i++) {\n          if (options && options.flat) {\n            this.get_json(obj.children[i], options, flat);\n          } else {\n            tmp.children.push(this.get_json(obj.children[i], options));\n          }\n        }\n      }\n\n      return options && options.flat ? flat : obj.id === $.jstree.root ? tmp.children : tmp;\n    },\n\n    /**\n     * create a new node (do not confuse with load_node)\n     * @name create_node([par, node, pos, callback, is_loaded])\n     * @param  {mixed}   par       the parent node (to create a root node use either \"#\" (string) or `null`)\n     * @param  {mixed}   node      the data for the new node (a valid JSON object, or a simple string with the name)\n     * @param  {mixed}   pos       the index at which to insert the node, \"first\" and \"last\" are also supported, default is \"last\"\n     * @param  {Function} callback a function to be called once the node is created\n     * @param  {Boolean} is_loaded internal argument indicating if the parent node was succesfully loaded\n     * @return {String}            the ID of the newly create node\n     * @trigger model.jstree, create_node.jstree\n     */\n    create_node: function create_node(par, node, pos, callback, is_loaded) {\n      if (par === null) {\n        par = $.jstree.root;\n      }\n\n      par = this.get_node(par);\n\n      if (!par) {\n        return false;\n      }\n\n      pos = pos === undefined ? \"last\" : pos;\n\n      if (!pos.toString().match(/^(before|after)$/) && !is_loaded && !this.is_loaded(par)) {\n        return this.load_node(par, function () {\n          this.create_node(par, node, pos, callback, true);\n        });\n      }\n\n      if (!node) {\n        node = {\n          \"text\": this.get_string('New node')\n        };\n      }\n\n      if (typeof node === \"string\") {\n        node = {\n          \"text\": node\n        };\n      }\n\n      if (node.text === undefined) {\n        node.text = this.get_string('New node');\n      }\n\n      var tmp, dpc, i, j;\n\n      if (par.id === $.jstree.root) {\n        if (pos === \"before\") {\n          pos = \"first\";\n        }\n\n        if (pos === \"after\") {\n          pos = \"last\";\n        }\n      }\n\n      switch (pos) {\n        case \"before\":\n          tmp = this.get_node(par.parent);\n          pos = $.inArray(par.id, tmp.children);\n          par = tmp;\n          break;\n\n        case \"after\":\n          tmp = this.get_node(par.parent);\n          pos = $.inArray(par.id, tmp.children) + 1;\n          par = tmp;\n          break;\n\n        case \"inside\":\n        case \"first\":\n          pos = 0;\n          break;\n\n        case \"last\":\n          pos = par.children.length;\n          break;\n\n        default:\n          if (!pos) {\n            pos = 0;\n          }\n\n          break;\n      }\n\n      if (pos > par.children.length) {\n        pos = par.children.length;\n      }\n\n      if (!node.id) {\n        node.id = true;\n      }\n\n      if (!this.check(\"create_node\", node, par, pos)) {\n        this.settings.core.error.call(this, this._data.core.last_error);\n        return false;\n      }\n\n      if (node.id === true) {\n        delete node.id;\n      }\n\n      node = this._parse_model_from_json(node, par.id, par.parents.concat());\n\n      if (!node) {\n        return false;\n      }\n\n      tmp = this.get_node(node);\n      dpc = [];\n      dpc.push(node);\n      dpc = dpc.concat(tmp.children_d);\n      this.trigger('model', {\n        \"nodes\": dpc,\n        \"parent\": par.id\n      });\n      par.children_d = par.children_d.concat(dpc);\n\n      for (i = 0, j = par.parents.length; i < j; i++) {\n        this._model.data[par.parents[i]].children_d = this._model.data[par.parents[i]].children_d.concat(dpc);\n      }\n\n      node = tmp;\n      tmp = [];\n\n      for (i = 0, j = par.children.length; i < j; i++) {\n        tmp[i >= pos ? i + 1 : i] = par.children[i];\n      }\n\n      tmp[pos] = node.id;\n      par.children = tmp;\n      this.redraw_node(par, true);\n\n      if (callback) {\n        callback.call(this, this.get_node(node));\n      }\n      /**\n       * triggered when a node is created\n       * @event\n       * @name create_node.jstree\n       * @param {Object} node\n       * @param {String} parent the parent's ID\n       * @param {Number} position the position of the new node among the parent's children\n       */\n\n\n      this.trigger('create_node', {\n        \"node\": this.get_node(node),\n        \"parent\": par.id,\n        \"position\": pos\n      });\n      return node.id;\n    },\n\n    /**\n     * set the text value of a node\n     * @name rename_node(obj, val)\n     * @param  {mixed} obj the node, you can pass an array to rename multiple nodes to the same name\n     * @param  {String} val the new text value\n     * @return {Boolean}\n     * @trigger rename_node.jstree\n     */\n    rename_node: function rename_node(obj, val) {\n      var t1, t2, old;\n\n      if ($.isArray(obj)) {\n        obj = obj.slice();\n\n        for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n          this.rename_node(obj[t1], val);\n        }\n\n        return true;\n      }\n\n      obj = this.get_node(obj);\n\n      if (!obj || obj.id === $.jstree.root) {\n        return false;\n      }\n\n      old = obj.text;\n\n      if (!this.check(\"rename_node\", obj, this.get_parent(obj), val)) {\n        this.settings.core.error.call(this, this._data.core.last_error);\n        return false;\n      }\n\n      this.set_text(obj, val); // .apply(this, Array.prototype.slice.call(arguments))\n\n      /**\n       * triggered when a node is renamed\n       * @event\n       * @name rename_node.jstree\n       * @param {Object} node\n       * @param {String} text the new value\n       * @param {String} old the old value\n       */\n\n      this.trigger('rename_node', {\n        \"node\": obj,\n        \"text\": val,\n        \"old\": old\n      });\n      return true;\n    },\n\n    /**\n     * remove a node\n     * @name delete_node(obj)\n     * @param  {mixed} obj the node, you can pass an array to delete multiple nodes\n     * @return {Boolean}\n     * @trigger delete_node.jstree, changed.jstree\n     */\n    delete_node: function delete_node(obj) {\n      var t1, t2, par, pos, tmp, i, j, k, l, c, top, lft;\n\n      if ($.isArray(obj)) {\n        obj = obj.slice();\n\n        for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n          this.delete_node(obj[t1]);\n        }\n\n        return true;\n      }\n\n      obj = this.get_node(obj);\n\n      if (!obj || obj.id === $.jstree.root) {\n        return false;\n      }\n\n      par = this.get_node(obj.parent);\n      pos = $.inArray(obj.id, par.children);\n      c = false;\n\n      if (!this.check(\"delete_node\", obj, par, pos)) {\n        this.settings.core.error.call(this, this._data.core.last_error);\n        return false;\n      }\n\n      if (pos !== -1) {\n        par.children = $.vakata.array_remove(par.children, pos);\n      }\n\n      tmp = obj.children_d.concat([]);\n      tmp.push(obj.id);\n\n      for (i = 0, j = obj.parents.length; i < j; i++) {\n        this._model.data[obj.parents[i]].children_d = $.vakata.array_filter(this._model.data[obj.parents[i]].children_d, function (v) {\n          return $.inArray(v, tmp) === -1;\n        });\n      }\n\n      for (k = 0, l = tmp.length; k < l; k++) {\n        if (this._model.data[tmp[k]].state.selected) {\n          c = true;\n          break;\n        }\n      }\n\n      if (c) {\n        this._data.core.selected = $.vakata.array_filter(this._data.core.selected, function (v) {\n          return $.inArray(v, tmp) === -1;\n        });\n      }\n      /**\n       * triggered when a node is deleted\n       * @event\n       * @name delete_node.jstree\n       * @param {Object} node\n       * @param {String} parent the parent's ID\n       */\n\n\n      this.trigger('delete_node', {\n        \"node\": obj,\n        \"parent\": par.id\n      });\n\n      if (c) {\n        this.trigger('changed', {\n          'action': 'delete_node',\n          'node': obj,\n          'selected': this._data.core.selected,\n          'parent': par.id\n        });\n      }\n\n      for (k = 0, l = tmp.length; k < l; k++) {\n        delete this._model.data[tmp[k]];\n      }\n\n      if ($.inArray(this._data.core.focused, tmp) !== -1) {\n        this._data.core.focused = null;\n        top = this.element[0].scrollTop;\n        lft = this.element[0].scrollLeft;\n\n        if (par.id === $.jstree.root) {\n          if (this._model.data[$.jstree.root].children[0]) {\n            this.get_node(this._model.data[$.jstree.root].children[0], true).children('.jstree-anchor').focus();\n          }\n        } else {\n          this.get_node(par, true).children('.jstree-anchor').focus();\n        }\n\n        this.element[0].scrollTop = top;\n        this.element[0].scrollLeft = lft;\n      }\n\n      this.redraw_node(par, true);\n      return true;\n    },\n\n    /**\n     * check if an operation is premitted on the tree. Used internally.\n     * @private\n     * @name check(chk, obj, par, pos)\n     * @param  {String} chk the operation to check, can be \"create_node\", \"rename_node\", \"delete_node\", \"copy_node\" or \"move_node\"\n     * @param  {mixed} obj the node\n     * @param  {mixed} par the parent\n     * @param  {mixed} pos the position to insert at, or if \"rename_node\" - the new name\n     * @param  {mixed} more some various additional information, for example if a \"move_node\" operations is triggered by DND this will be the hovered node\n     * @return {Boolean}\n     */\n    check: function check(chk, obj, par, pos, more) {\n      obj = obj && obj.id ? obj : this.get_node(obj);\n      par = par && par.id ? par : this.get_node(par);\n      var tmp = chk.match(/^move_node|copy_node|create_node$/i) ? par : obj,\n          chc = this.settings.core.check_callback;\n\n      if (chk === \"move_node\" || chk === \"copy_node\") {\n        if ((!more || !more.is_multi) && (obj.id === par.id || chk === \"move_node\" && $.inArray(obj.id, par.children) === pos || $.inArray(par.id, obj.children_d) !== -1)) {\n          this._data.core.last_error = {\n            'error': 'check',\n            'plugin': 'core',\n            'id': 'core_01',\n            'reason': 'Moving parent inside child',\n            'data': JSON.stringify({\n              'chk': chk,\n              'pos': pos,\n              'obj': obj && obj.id ? obj.id : false,\n              'par': par && par.id ? par.id : false\n            })\n          };\n          return false;\n        }\n      }\n\n      if (tmp && tmp.data) {\n        tmp = tmp.data;\n      }\n\n      if (tmp && tmp.functions && (tmp.functions[chk] === false || tmp.functions[chk] === true)) {\n        if (tmp.functions[chk] === false) {\n          this._data.core.last_error = {\n            'error': 'check',\n            'plugin': 'core',\n            'id': 'core_02',\n            'reason': 'Node data prevents function: ' + chk,\n            'data': JSON.stringify({\n              'chk': chk,\n              'pos': pos,\n              'obj': obj && obj.id ? obj.id : false,\n              'par': par && par.id ? par.id : false\n            })\n          };\n        }\n\n        return tmp.functions[chk];\n      }\n\n      if (chc === false || $.isFunction(chc) && chc.call(this, chk, obj, par, pos, more) === false || chc && chc[chk] === false) {\n        this._data.core.last_error = {\n          'error': 'check',\n          'plugin': 'core',\n          'id': 'core_03',\n          'reason': 'User config for core.check_callback prevents function: ' + chk,\n          'data': JSON.stringify({\n            'chk': chk,\n            'pos': pos,\n            'obj': obj && obj.id ? obj.id : false,\n            'par': par && par.id ? par.id : false\n          })\n        };\n        return false;\n      }\n\n      return true;\n    },\n\n    /**\n     * get the last error\n     * @name last_error()\n     * @return {Object}\n     */\n    last_error: function last_error() {\n      return this._data.core.last_error;\n    },\n\n    /**\n     * move a node to a new parent\n     * @name move_node(obj, par [, pos, callback, is_loaded])\n     * @param  {mixed} obj the node to move, pass an array to move multiple nodes\n     * @param  {mixed} par the new parent\n     * @param  {mixed} pos the position to insert at (besides integer values, \"first\" and \"last\" are supported, as well as \"before\" and \"after\"), defaults to integer `0`\n     * @param  {function} callback a function to call once the move is completed, receives 3 arguments - the node, the new parent and the position\n     * @param  {Boolean} is_loaded internal parameter indicating if the parent node has been loaded\n     * @param  {Boolean} skip_redraw internal parameter indicating if the tree should be redrawn\n     * @param  {Boolean} instance internal parameter indicating if the node comes from another instance\n     * @trigger move_node.jstree\n     */\n    move_node: function move_node(obj, par, pos, callback, is_loaded, skip_redraw, origin) {\n      var t1, t2, old_par, old_pos, new_par, old_ins, is_multi, dpc, tmp, i, j, k, l, p;\n      par = this.get_node(par);\n      pos = pos === undefined ? 0 : pos;\n\n      if (!par) {\n        return false;\n      }\n\n      if (!pos.toString().match(/^(before|after)$/) && !is_loaded && !this.is_loaded(par)) {\n        return this.load_node(par, function () {\n          this.move_node(obj, par, pos, callback, true, false, origin);\n        });\n      }\n\n      if ($.isArray(obj)) {\n        if (obj.length === 1) {\n          obj = obj[0];\n        } else {\n          //obj = obj.slice();\n          for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n            if (tmp = this.move_node(obj[t1], par, pos, callback, is_loaded, false, origin)) {\n              par = tmp;\n              pos = \"after\";\n            }\n          }\n\n          this.redraw();\n          return true;\n        }\n      }\n\n      obj = obj && obj.id ? obj : this.get_node(obj);\n\n      if (!obj || obj.id === $.jstree.root) {\n        return false;\n      }\n\n      old_par = (obj.parent || $.jstree.root).toString();\n      new_par = !pos.toString().match(/^(before|after)$/) || par.id === $.jstree.root ? par : this.get_node(par.parent);\n      old_ins = origin ? origin : this._model.data[obj.id] ? this : $.jstree.reference(obj.id);\n      is_multi = !old_ins || !old_ins._id || this._id !== old_ins._id;\n      old_pos = old_ins && old_ins._id && old_par && old_ins._model.data[old_par] && old_ins._model.data[old_par].children ? $.inArray(obj.id, old_ins._model.data[old_par].children) : -1;\n\n      if (old_ins && old_ins._id) {\n        obj = old_ins._model.data[obj.id];\n      }\n\n      if (is_multi) {\n        if (tmp = this.copy_node(obj, par, pos, callback, is_loaded, false, origin)) {\n          if (old_ins) {\n            old_ins.delete_node(obj);\n          }\n\n          return tmp;\n        }\n\n        return false;\n      } //var m = this._model.data;\n\n\n      if (par.id === $.jstree.root) {\n        if (pos === \"before\") {\n          pos = \"first\";\n        }\n\n        if (pos === \"after\") {\n          pos = \"last\";\n        }\n      }\n\n      switch (pos) {\n        case \"before\":\n          pos = $.inArray(par.id, new_par.children);\n          break;\n\n        case \"after\":\n          pos = $.inArray(par.id, new_par.children) + 1;\n          break;\n\n        case \"inside\":\n        case \"first\":\n          pos = 0;\n          break;\n\n        case \"last\":\n          pos = new_par.children.length;\n          break;\n\n        default:\n          if (!pos) {\n            pos = 0;\n          }\n\n          break;\n      }\n\n      if (pos > new_par.children.length) {\n        pos = new_par.children.length;\n      }\n\n      if (!this.check(\"move_node\", obj, new_par, pos, {\n        'core': true,\n        'origin': origin,\n        'is_multi': old_ins && old_ins._id && old_ins._id !== this._id,\n        'is_foreign': !old_ins || !old_ins._id\n      })) {\n        this.settings.core.error.call(this, this._data.core.last_error);\n        return false;\n      }\n\n      if (obj.parent === new_par.id) {\n        dpc = new_par.children.concat();\n        tmp = $.inArray(obj.id, dpc);\n\n        if (tmp !== -1) {\n          dpc = $.vakata.array_remove(dpc, tmp);\n\n          if (pos > tmp) {\n            pos--;\n          }\n        }\n\n        tmp = [];\n\n        for (i = 0, j = dpc.length; i < j; i++) {\n          tmp[i >= pos ? i + 1 : i] = dpc[i];\n        }\n\n        tmp[pos] = obj.id;\n        new_par.children = tmp;\n\n        this._node_changed(new_par.id);\n\n        this.redraw(new_par.id === $.jstree.root);\n      } else {\n        // clean old parent and up\n        tmp = obj.children_d.concat();\n        tmp.push(obj.id);\n\n        for (i = 0, j = obj.parents.length; i < j; i++) {\n          dpc = [];\n          p = old_ins._model.data[obj.parents[i]].children_d;\n\n          for (k = 0, l = p.length; k < l; k++) {\n            if ($.inArray(p[k], tmp) === -1) {\n              dpc.push(p[k]);\n            }\n          }\n\n          old_ins._model.data[obj.parents[i]].children_d = dpc;\n        }\n\n        old_ins._model.data[old_par].children = $.vakata.array_remove_item(old_ins._model.data[old_par].children, obj.id); // insert into new parent and up\n\n        for (i = 0, j = new_par.parents.length; i < j; i++) {\n          this._model.data[new_par.parents[i]].children_d = this._model.data[new_par.parents[i]].children_d.concat(tmp);\n        }\n\n        dpc = [];\n\n        for (i = 0, j = new_par.children.length; i < j; i++) {\n          dpc[i >= pos ? i + 1 : i] = new_par.children[i];\n        }\n\n        dpc[pos] = obj.id;\n        new_par.children = dpc;\n        new_par.children_d.push(obj.id);\n        new_par.children_d = new_par.children_d.concat(obj.children_d); // update object\n\n        obj.parent = new_par.id;\n        tmp = new_par.parents.concat();\n        tmp.unshift(new_par.id);\n        p = obj.parents.length;\n        obj.parents = tmp; // update object children\n\n        tmp = tmp.concat();\n\n        for (i = 0, j = obj.children_d.length; i < j; i++) {\n          this._model.data[obj.children_d[i]].parents = this._model.data[obj.children_d[i]].parents.slice(0, p * -1);\n          Array.prototype.push.apply(this._model.data[obj.children_d[i]].parents, tmp);\n        }\n\n        if (old_par === $.jstree.root || new_par.id === $.jstree.root) {\n          this._model.force_full_redraw = true;\n        }\n\n        if (!this._model.force_full_redraw) {\n          this._node_changed(old_par);\n\n          this._node_changed(new_par.id);\n        }\n\n        if (!skip_redraw) {\n          this.redraw();\n        }\n      }\n\n      if (callback) {\n        callback.call(this, obj, new_par, pos);\n      }\n      /**\n       * triggered when a node is moved\n       * @event\n       * @name move_node.jstree\n       * @param {Object} node\n       * @param {String} parent the parent's ID\n       * @param {Number} position the position of the node among the parent's children\n       * @param {String} old_parent the old parent of the node\n       * @param {Number} old_position the old position of the node\n       * @param {Boolean} is_multi do the node and new parent belong to different instances\n       * @param {jsTree} old_instance the instance the node came from\n       * @param {jsTree} new_instance the instance of the new parent\n       */\n\n\n      this.trigger('move_node', {\n        \"node\": obj,\n        \"parent\": new_par.id,\n        \"position\": pos,\n        \"old_parent\": old_par,\n        \"old_position\": old_pos,\n        'is_multi': old_ins && old_ins._id && old_ins._id !== this._id,\n        'is_foreign': !old_ins || !old_ins._id,\n        'old_instance': old_ins,\n        'new_instance': this\n      });\n      return obj.id;\n    },\n\n    /**\n     * copy a node to a new parent\n     * @name copy_node(obj, par [, pos, callback, is_loaded])\n     * @param  {mixed} obj the node to copy, pass an array to copy multiple nodes\n     * @param  {mixed} par the new parent\n     * @param  {mixed} pos the position to insert at (besides integer values, \"first\" and \"last\" are supported, as well as \"before\" and \"after\"), defaults to integer `0`\n     * @param  {function} callback a function to call once the move is completed, receives 3 arguments - the node, the new parent and the position\n     * @param  {Boolean} is_loaded internal parameter indicating if the parent node has been loaded\n     * @param  {Boolean} skip_redraw internal parameter indicating if the tree should be redrawn\n     * @param  {Boolean} instance internal parameter indicating if the node comes from another instance\n     * @trigger model.jstree copy_node.jstree\n     */\n    copy_node: function copy_node(obj, par, pos, callback, is_loaded, skip_redraw, origin) {\n      var t1, t2, dpc, tmp, i, j, node, old_par, new_par, old_ins, is_multi;\n      par = this.get_node(par);\n      pos = pos === undefined ? 0 : pos;\n\n      if (!par) {\n        return false;\n      }\n\n      if (!pos.toString().match(/^(before|after)$/) && !is_loaded && !this.is_loaded(par)) {\n        return this.load_node(par, function () {\n          this.copy_node(obj, par, pos, callback, true, false, origin);\n        });\n      }\n\n      if ($.isArray(obj)) {\n        if (obj.length === 1) {\n          obj = obj[0];\n        } else {\n          //obj = obj.slice();\n          for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n            if (tmp = this.copy_node(obj[t1], par, pos, callback, is_loaded, true, origin)) {\n              par = tmp;\n              pos = \"after\";\n            }\n          }\n\n          this.redraw();\n          return true;\n        }\n      }\n\n      obj = obj && obj.id ? obj : this.get_node(obj);\n\n      if (!obj || obj.id === $.jstree.root) {\n        return false;\n      }\n\n      old_par = (obj.parent || $.jstree.root).toString();\n      new_par = !pos.toString().match(/^(before|after)$/) || par.id === $.jstree.root ? par : this.get_node(par.parent);\n      old_ins = origin ? origin : this._model.data[obj.id] ? this : $.jstree.reference(obj.id);\n      is_multi = !old_ins || !old_ins._id || this._id !== old_ins._id;\n\n      if (old_ins && old_ins._id) {\n        obj = old_ins._model.data[obj.id];\n      }\n\n      if (par.id === $.jstree.root) {\n        if (pos === \"before\") {\n          pos = \"first\";\n        }\n\n        if (pos === \"after\") {\n          pos = \"last\";\n        }\n      }\n\n      switch (pos) {\n        case \"before\":\n          pos = $.inArray(par.id, new_par.children);\n          break;\n\n        case \"after\":\n          pos = $.inArray(par.id, new_par.children) + 1;\n          break;\n\n        case \"inside\":\n        case \"first\":\n          pos = 0;\n          break;\n\n        case \"last\":\n          pos = new_par.children.length;\n          break;\n\n        default:\n          if (!pos) {\n            pos = 0;\n          }\n\n          break;\n      }\n\n      if (pos > new_par.children.length) {\n        pos = new_par.children.length;\n      }\n\n      if (!this.check(\"copy_node\", obj, new_par, pos, {\n        'core': true,\n        'origin': origin,\n        'is_multi': old_ins && old_ins._id && old_ins._id !== this._id,\n        'is_foreign': !old_ins || !old_ins._id\n      })) {\n        this.settings.core.error.call(this, this._data.core.last_error);\n        return false;\n      }\n\n      node = old_ins ? old_ins.get_json(obj, {\n        no_id: true,\n        no_data: true,\n        no_state: true\n      }) : obj;\n\n      if (!node) {\n        return false;\n      }\n\n      if (node.id === true) {\n        delete node.id;\n      }\n\n      node = this._parse_model_from_json(node, new_par.id, new_par.parents.concat());\n\n      if (!node) {\n        return false;\n      }\n\n      tmp = this.get_node(node);\n\n      if (obj && obj.state && obj.state.loaded === false) {\n        tmp.state.loaded = false;\n      }\n\n      dpc = [];\n      dpc.push(node);\n      dpc = dpc.concat(tmp.children_d);\n      this.trigger('model', {\n        \"nodes\": dpc,\n        \"parent\": new_par.id\n      }); // insert into new parent and up\n\n      for (i = 0, j = new_par.parents.length; i < j; i++) {\n        this._model.data[new_par.parents[i]].children_d = this._model.data[new_par.parents[i]].children_d.concat(dpc);\n      }\n\n      dpc = [];\n\n      for (i = 0, j = new_par.children.length; i < j; i++) {\n        dpc[i >= pos ? i + 1 : i] = new_par.children[i];\n      }\n\n      dpc[pos] = tmp.id;\n      new_par.children = dpc;\n      new_par.children_d.push(tmp.id);\n      new_par.children_d = new_par.children_d.concat(tmp.children_d);\n\n      if (new_par.id === $.jstree.root) {\n        this._model.force_full_redraw = true;\n      }\n\n      if (!this._model.force_full_redraw) {\n        this._node_changed(new_par.id);\n      }\n\n      if (!skip_redraw) {\n        this.redraw(new_par.id === $.jstree.root);\n      }\n\n      if (callback) {\n        callback.call(this, tmp, new_par, pos);\n      }\n      /**\n       * triggered when a node is copied\n       * @event\n       * @name copy_node.jstree\n       * @param {Object} node the copied node\n       * @param {Object} original the original node\n       * @param {String} parent the parent's ID\n       * @param {Number} position the position of the node among the parent's children\n       * @param {String} old_parent the old parent of the node\n       * @param {Number} old_position the position of the original node\n       * @param {Boolean} is_multi do the node and new parent belong to different instances\n       * @param {jsTree} old_instance the instance the node came from\n       * @param {jsTree} new_instance the instance of the new parent\n       */\n\n\n      this.trigger('copy_node', {\n        \"node\": tmp,\n        \"original\": obj,\n        \"parent\": new_par.id,\n        \"position\": pos,\n        \"old_parent\": old_par,\n        \"old_position\": old_ins && old_ins._id && old_par && old_ins._model.data[old_par] && old_ins._model.data[old_par].children ? $.inArray(obj.id, old_ins._model.data[old_par].children) : -1,\n        'is_multi': old_ins && old_ins._id && old_ins._id !== this._id,\n        'is_foreign': !old_ins || !old_ins._id,\n        'old_instance': old_ins,\n        'new_instance': this\n      });\n      return tmp.id;\n    },\n\n    /**\n     * cut a node (a later call to `paste(obj)` would move the node)\n     * @name cut(obj)\n     * @param  {mixed} obj multiple objects can be passed using an array\n     * @trigger cut.jstree\n     */\n    cut: function cut(obj) {\n      if (!obj) {\n        obj = this._data.core.selected.concat();\n      }\n\n      if (!$.isArray(obj)) {\n        obj = [obj];\n      }\n\n      if (!obj.length) {\n        return false;\n      }\n\n      var tmp = [],\n          o,\n          t1,\n          t2;\n\n      for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n        o = this.get_node(obj[t1]);\n\n        if (o && o.id && o.id !== $.jstree.root) {\n          tmp.push(o);\n        }\n      }\n\n      if (!tmp.length) {\n        return false;\n      }\n\n      ccp_node = tmp;\n      ccp_inst = this;\n      ccp_mode = 'move_node';\n      /**\n       * triggered when nodes are added to the buffer for moving\n       * @event\n       * @name cut.jstree\n       * @param {Array} node\n       */\n\n      this.trigger('cut', {\n        \"node\": obj\n      });\n    },\n\n    /**\n     * copy a node (a later call to `paste(obj)` would copy the node)\n     * @name copy(obj)\n     * @param  {mixed} obj multiple objects can be passed using an array\n     * @trigger copy.jstree\n     */\n    copy: function copy(obj) {\n      if (!obj) {\n        obj = this._data.core.selected.concat();\n      }\n\n      if (!$.isArray(obj)) {\n        obj = [obj];\n      }\n\n      if (!obj.length) {\n        return false;\n      }\n\n      var tmp = [],\n          o,\n          t1,\n          t2;\n\n      for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n        o = this.get_node(obj[t1]);\n\n        if (o && o.id && o.id !== $.jstree.root) {\n          tmp.push(o);\n        }\n      }\n\n      if (!tmp.length) {\n        return false;\n      }\n\n      ccp_node = tmp;\n      ccp_inst = this;\n      ccp_mode = 'copy_node';\n      /**\n       * triggered when nodes are added to the buffer for copying\n       * @event\n       * @name copy.jstree\n       * @param {Array} node\n       */\n\n      this.trigger('copy', {\n        \"node\": obj\n      });\n    },\n\n    /**\n     * get the current buffer (any nodes that are waiting for a paste operation)\n     * @name get_buffer()\n     * @return {Object} an object consisting of `mode` (\"copy_node\" or \"move_node\"), `node` (an array of objects) and `inst` (the instance)\n     */\n    get_buffer: function get_buffer() {\n      return {\n        'mode': ccp_mode,\n        'node': ccp_node,\n        'inst': ccp_inst\n      };\n    },\n\n    /**\n     * check if there is something in the buffer to paste\n     * @name can_paste()\n     * @return {Boolean}\n     */\n    can_paste: function can_paste() {\n      return ccp_mode !== false && ccp_node !== false; // && ccp_inst._model.data[ccp_node];\n    },\n\n    /**\n     * copy or move the previously cut or copied nodes to a new parent\n     * @name paste(obj [, pos])\n     * @param  {mixed} obj the new parent\n     * @param  {mixed} pos the position to insert at (besides integer, \"first\" and \"last\" are supported), defaults to integer `0`\n     * @trigger paste.jstree\n     */\n    paste: function paste(obj, pos) {\n      obj = this.get_node(obj);\n\n      if (!obj || !ccp_mode || !ccp_mode.match(/^(copy_node|move_node)$/) || !ccp_node) {\n        return false;\n      }\n\n      if (this[ccp_mode](ccp_node, obj, pos, false, false, false, ccp_inst)) {\n        /**\n         * triggered when paste is invoked\n         * @event\n         * @name paste.jstree\n         * @param {String} parent the ID of the receiving node\n         * @param {Array} node the nodes in the buffer\n         * @param {String} mode the performed operation - \"copy_node\" or \"move_node\"\n         */\n        this.trigger('paste', {\n          \"parent\": obj.id,\n          \"node\": ccp_node,\n          \"mode\": ccp_mode\n        });\n      }\n\n      ccp_node = false;\n      ccp_mode = false;\n      ccp_inst = false;\n    },\n\n    /**\n     * clear the buffer of previously copied or cut nodes\n     * @name clear_buffer()\n     * @trigger clear_buffer.jstree\n     */\n    clear_buffer: function clear_buffer() {\n      ccp_node = false;\n      ccp_mode = false;\n      ccp_inst = false;\n      /**\n       * triggered when the copy / cut buffer is cleared\n       * @event\n       * @name clear_buffer.jstree\n       */\n\n      this.trigger('clear_buffer');\n    },\n\n    /**\n     * put a node in edit mode (input field to rename the node)\n     * @name edit(obj [, default_text, callback])\n     * @param  {mixed} obj\n     * @param  {String} default_text the text to populate the input with (if omitted or set to a non-string value the node's text value is used)\n     * @param  {Function} callback a function to be called once the text box is blurred, it is called in the instance's scope and receives the node, a status parameter (true if the rename is successful, false otherwise) and a boolean indicating if the user cancelled the edit. You can access the node's title using .text\n     */\n    edit: function edit(obj, default_text, callback) {\n      var rtl,\n          w,\n          a,\n          s,\n          t,\n          h1,\n          h2,\n          fn,\n          tmp,\n          cancel = false;\n      obj = this.get_node(obj);\n\n      if (!obj) {\n        return false;\n      }\n\n      if (this.settings.core.check_callback === false) {\n        this._data.core.last_error = {\n          'error': 'check',\n          'plugin': 'core',\n          'id': 'core_07',\n          'reason': 'Could not edit node because of check_callback'\n        };\n        this.settings.core.error.call(this, this._data.core.last_error);\n        return false;\n      }\n\n      tmp = obj;\n      default_text = typeof default_text === 'string' ? default_text : obj.text;\n      this.set_text(obj, \"\");\n      obj = this._open_to(obj);\n      tmp.text = default_text;\n      rtl = this._data.core.rtl;\n      w = this.element.width();\n      this._data.core.focused = tmp.id;\n      a = obj.children('.jstree-anchor').focus();\n      s = $('<span>');\n      /*!\n      oi = obj.children(\"i:visible\"),\n      ai = a.children(\"i:visible\"),\n      w1 = oi.width() * oi.length,\n      w2 = ai.width() * ai.length,\n      */\n\n      t = default_text;\n      h1 = $(\"<\" + \"div />\", {\n        css: {\n          \"position\": \"absolute\",\n          \"top\": \"-200px\",\n          \"left\": rtl ? \"0px\" : \"-1000px\",\n          \"visibility\": \"hidden\"\n        }\n      }).appendTo(\"body\");\n      h2 = $(\"<\" + \"input />\", {\n        \"value\": t,\n        \"class\": \"jstree-rename-input\",\n        // \"size\" : t.length,\n        \"css\": {\n          \"padding\": \"0\",\n          \"border\": \"1px solid silver\",\n          \"box-sizing\": \"border-box\",\n          \"display\": \"inline-block\",\n          \"height\": this._data.core.li_height + \"px\",\n          \"lineHeight\": this._data.core.li_height + \"px\",\n          \"width\": \"150px\" // will be set a bit further down\n\n        },\n        \"blur\": $.proxy(function (e) {\n          e.stopImmediatePropagation();\n          e.preventDefault();\n          var i = s.children(\".jstree-rename-input\"),\n              v = i.val(),\n              f = this.settings.core.force_text,\n              nv;\n\n          if (v === \"\") {\n            v = t;\n          }\n\n          h1.remove();\n          s.replaceWith(a);\n          s.remove();\n          t = f ? t : $('<div></div>').append($.parseHTML(t)).html();\n          this.set_text(obj, t);\n          nv = !!this.rename_node(obj, f ? $('<div></div>').text(v).text() : $('<div></div>').append($.parseHTML(v)).html());\n\n          if (!nv) {\n            this.set_text(obj, t); // move this up? and fix #483\n          }\n\n          this._data.core.focused = tmp.id;\n          setTimeout($.proxy(function () {\n            var node = this.get_node(tmp.id, true);\n\n            if (node.length) {\n              this._data.core.focused = tmp.id;\n              node.children('.jstree-anchor').focus();\n            }\n          }, this), 0);\n\n          if (callback) {\n            callback.call(this, tmp, nv, cancel);\n          }\n\n          h2 = null;\n        }, this),\n        \"keydown\": function keydown(e) {\n          var key = e.which;\n\n          if (key === 27) {\n            cancel = true;\n            this.value = t;\n          }\n\n          if (key === 27 || key === 13 || key === 37 || key === 38 || key === 39 || key === 40 || key === 32) {\n            e.stopImmediatePropagation();\n          }\n\n          if (key === 27 || key === 13) {\n            e.preventDefault();\n            this.blur();\n          }\n        },\n        \"click\": function click(e) {\n          e.stopImmediatePropagation();\n        },\n        \"mousedown\": function mousedown(e) {\n          e.stopImmediatePropagation();\n        },\n        \"keyup\": function keyup(e) {\n          h2.width(Math.min(h1.text(\"pW\" + this.value).width(), w));\n        },\n        \"keypress\": function keypress(e) {\n          if (e.which === 13) {\n            return false;\n          }\n        }\n      });\n      fn = {\n        fontFamily: a.css('fontFamily') || '',\n        fontSize: a.css('fontSize') || '',\n        fontWeight: a.css('fontWeight') || '',\n        fontStyle: a.css('fontStyle') || '',\n        fontStretch: a.css('fontStretch') || '',\n        fontVariant: a.css('fontVariant') || '',\n        letterSpacing: a.css('letterSpacing') || '',\n        wordSpacing: a.css('wordSpacing') || ''\n      };\n      s.attr('class', a.attr('class')).append(a.contents().clone()).append(h2);\n      a.replaceWith(s);\n      h1.css(fn);\n      h2.css(fn).width(Math.min(h1.text(\"pW\" + h2[0].value).width(), w))[0].select();\n      $(document).one('mousedown.jstree touchstart.jstree dnd_start.vakata', function (e) {\n        if (h2 && e.target !== h2) {\n          $(h2).blur();\n        }\n      });\n    },\n\n    /**\n     * changes the theme\n     * @name set_theme(theme_name [, theme_url])\n     * @param {String} theme_name the name of the new theme to apply\n     * @param {mixed} theme_url  the location of the CSS file for this theme. Omit or set to `false` if you manually included the file. Set to `true` to autoload from the `core.themes.dir` directory.\n     * @trigger set_theme.jstree\n     */\n    set_theme: function set_theme(theme_name, theme_url) {\n      if (!theme_name) {\n        return false;\n      }\n\n      if (theme_url === true) {\n        var dir = this.settings.core.themes.dir;\n\n        if (!dir) {\n          dir = $.jstree.path + '/themes';\n        }\n\n        theme_url = dir + '/' + theme_name + '/style.css';\n      }\n\n      if (theme_url && $.inArray(theme_url, themes_loaded) === -1) {\n        $('head').append('<' + 'link rel=\"stylesheet\" href=\"' + theme_url + '\" type=\"text/css\" />');\n        themes_loaded.push(theme_url);\n      }\n\n      if (this._data.core.themes.name) {\n        this.element.removeClass('jstree-' + this._data.core.themes.name);\n      }\n\n      this._data.core.themes.name = theme_name;\n      this.element.addClass('jstree-' + theme_name);\n      this.element[this.settings.core.themes.responsive ? 'addClass' : 'removeClass']('jstree-' + theme_name + '-responsive');\n      /**\n       * triggered when a theme is set\n       * @event\n       * @name set_theme.jstree\n       * @param {String} theme the new theme\n       */\n\n      this.trigger('set_theme', {\n        'theme': theme_name\n      });\n    },\n\n    /**\n     * gets the name of the currently applied theme name\n     * @name get_theme()\n     * @return {String}\n     */\n    get_theme: function get_theme() {\n      return this._data.core.themes.name;\n    },\n\n    /**\n     * changes the theme variant (if the theme has variants)\n     * @name set_theme_variant(variant_name)\n     * @param {String|Boolean} variant_name the variant to apply (if `false` is used the current variant is removed)\n     */\n    set_theme_variant: function set_theme_variant(variant_name) {\n      if (this._data.core.themes.variant) {\n        this.element.removeClass('jstree-' + this._data.core.themes.name + '-' + this._data.core.themes.variant);\n      }\n\n      this._data.core.themes.variant = variant_name;\n\n      if (variant_name) {\n        this.element.addClass('jstree-' + this._data.core.themes.name + '-' + this._data.core.themes.variant);\n      }\n    },\n\n    /**\n     * gets the name of the currently applied theme variant\n     * @name get_theme()\n     * @return {String}\n     */\n    get_theme_variant: function get_theme_variant() {\n      return this._data.core.themes.variant;\n    },\n\n    /**\n     * shows a striped background on the container (if the theme supports it)\n     * @name show_stripes()\n     */\n    show_stripes: function show_stripes() {\n      this._data.core.themes.stripes = true;\n      this.get_container_ul().addClass(\"jstree-striped\");\n      /**\n       * triggered when stripes are shown\n       * @event\n       * @name show_stripes.jstree\n       */\n\n      this.trigger('show_stripes');\n    },\n\n    /**\n     * hides the striped background on the container\n     * @name hide_stripes()\n     */\n    hide_stripes: function hide_stripes() {\n      this._data.core.themes.stripes = false;\n      this.get_container_ul().removeClass(\"jstree-striped\");\n      /**\n       * triggered when stripes are hidden\n       * @event\n       * @name hide_stripes.jstree\n       */\n\n      this.trigger('hide_stripes');\n    },\n\n    /**\n     * toggles the striped background on the container\n     * @name toggle_stripes()\n     */\n    toggle_stripes: function toggle_stripes() {\n      if (this._data.core.themes.stripes) {\n        this.hide_stripes();\n      } else {\n        this.show_stripes();\n      }\n    },\n\n    /**\n     * shows the connecting dots (if the theme supports it)\n     * @name show_dots()\n     */\n    show_dots: function show_dots() {\n      this._data.core.themes.dots = true;\n      this.get_container_ul().removeClass(\"jstree-no-dots\");\n      /**\n       * triggered when dots are shown\n       * @event\n       * @name show_dots.jstree\n       */\n\n      this.trigger('show_dots');\n    },\n\n    /**\n     * hides the connecting dots\n     * @name hide_dots()\n     */\n    hide_dots: function hide_dots() {\n      this._data.core.themes.dots = false;\n      this.get_container_ul().addClass(\"jstree-no-dots\");\n      /**\n       * triggered when dots are hidden\n       * @event\n       * @name hide_dots.jstree\n       */\n\n      this.trigger('hide_dots');\n    },\n\n    /**\n     * toggles the connecting dots\n     * @name toggle_dots()\n     */\n    toggle_dots: function toggle_dots() {\n      if (this._data.core.themes.dots) {\n        this.hide_dots();\n      } else {\n        this.show_dots();\n      }\n    },\n\n    /**\n     * show the node icons\n     * @name show_icons()\n     */\n    show_icons: function show_icons() {\n      this._data.core.themes.icons = true;\n      this.get_container_ul().removeClass(\"jstree-no-icons\");\n      /**\n       * triggered when icons are shown\n       * @event\n       * @name show_icons.jstree\n       */\n\n      this.trigger('show_icons');\n    },\n\n    /**\n     * hide the node icons\n     * @name hide_icons()\n     */\n    hide_icons: function hide_icons() {\n      this._data.core.themes.icons = false;\n      this.get_container_ul().addClass(\"jstree-no-icons\");\n      /**\n       * triggered when icons are hidden\n       * @event\n       * @name hide_icons.jstree\n       */\n\n      this.trigger('hide_icons');\n    },\n\n    /**\n     * toggle the node icons\n     * @name toggle_icons()\n     */\n    toggle_icons: function toggle_icons() {\n      if (this._data.core.themes.icons) {\n        this.hide_icons();\n      } else {\n        this.show_icons();\n      }\n    },\n\n    /**\n     * show the node ellipsis\n     * @name show_icons()\n     */\n    show_ellipsis: function show_ellipsis() {\n      this._data.core.themes.ellipsis = true;\n      this.get_container_ul().addClass(\"jstree-ellipsis\");\n      /**\n       * triggered when ellisis is shown\n       * @event\n       * @name show_ellipsis.jstree\n       */\n\n      this.trigger('show_ellipsis');\n    },\n\n    /**\n     * hide the node ellipsis\n     * @name hide_ellipsis()\n     */\n    hide_ellipsis: function hide_ellipsis() {\n      this._data.core.themes.ellipsis = false;\n      this.get_container_ul().removeClass(\"jstree-ellipsis\");\n      /**\n       * triggered when ellisis is hidden\n       * @event\n       * @name hide_ellipsis.jstree\n       */\n\n      this.trigger('hide_ellipsis');\n    },\n\n    /**\n     * toggle the node ellipsis\n     * @name toggle_icons()\n     */\n    toggle_ellipsis: function toggle_ellipsis() {\n      if (this._data.core.themes.ellipsis) {\n        this.hide_ellipsis();\n      } else {\n        this.show_ellipsis();\n      }\n    },\n\n    /**\n     * set the node icon for a node\n     * @name set_icon(obj, icon)\n     * @param {mixed} obj\n     * @param {String} icon the new icon - can be a path to an icon or a className, if using an image that is in the current directory use a `./` prefix, otherwise it will be detected as a class\n     */\n    set_icon: function set_icon(obj, icon) {\n      var t1, t2, dom, old;\n\n      if ($.isArray(obj)) {\n        obj = obj.slice();\n\n        for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n          this.set_icon(obj[t1], icon);\n        }\n\n        return true;\n      }\n\n      obj = this.get_node(obj);\n\n      if (!obj || obj.id === $.jstree.root) {\n        return false;\n      }\n\n      old = obj.icon;\n      obj.icon = icon === true || icon === null || icon === undefined || icon === '' ? true : icon;\n      dom = this.get_node(obj, true).children(\".jstree-anchor\").children(\".jstree-themeicon\");\n\n      if (icon === false) {\n        this.hide_icon(obj);\n      } else if (icon === true || icon === null || icon === undefined || icon === '') {\n        dom.removeClass('jstree-themeicon-custom ' + old).css(\"background\", \"\").removeAttr(\"rel\");\n\n        if (old === false) {\n          this.show_icon(obj);\n        }\n      } else if (icon.indexOf(\"/\") === -1 && icon.indexOf(\".\") === -1) {\n        dom.removeClass(old).css(\"background\", \"\");\n        dom.addClass(icon + ' jstree-themeicon-custom').attr(\"rel\", icon);\n\n        if (old === false) {\n          this.show_icon(obj);\n        }\n      } else {\n        dom.removeClass(old).css(\"background\", \"\");\n        dom.addClass('jstree-themeicon-custom').css(\"background\", \"url('\" + icon + \"') center center no-repeat\").attr(\"rel\", icon);\n\n        if (old === false) {\n          this.show_icon(obj);\n        }\n      }\n\n      return true;\n    },\n\n    /**\n     * get the node icon for a node\n     * @name get_icon(obj)\n     * @param {mixed} obj\n     * @return {String}\n     */\n    get_icon: function get_icon(obj) {\n      obj = this.get_node(obj);\n      return !obj || obj.id === $.jstree.root ? false : obj.icon;\n    },\n\n    /**\n     * hide the icon on an individual node\n     * @name hide_icon(obj)\n     * @param {mixed} obj\n     */\n    hide_icon: function hide_icon(obj) {\n      var t1, t2;\n\n      if ($.isArray(obj)) {\n        obj = obj.slice();\n\n        for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n          this.hide_icon(obj[t1]);\n        }\n\n        return true;\n      }\n\n      obj = this.get_node(obj);\n\n      if (!obj || obj === $.jstree.root) {\n        return false;\n      }\n\n      obj.icon = false;\n      this.get_node(obj, true).children(\".jstree-anchor\").children(\".jstree-themeicon\").addClass('jstree-themeicon-hidden');\n      return true;\n    },\n\n    /**\n     * show the icon on an individual node\n     * @name show_icon(obj)\n     * @param {mixed} obj\n     */\n    show_icon: function show_icon(obj) {\n      var t1, t2, dom;\n\n      if ($.isArray(obj)) {\n        obj = obj.slice();\n\n        for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n          this.show_icon(obj[t1]);\n        }\n\n        return true;\n      }\n\n      obj = this.get_node(obj);\n\n      if (!obj || obj === $.jstree.root) {\n        return false;\n      }\n\n      dom = this.get_node(obj, true);\n      obj.icon = dom.length ? dom.children(\".jstree-anchor\").children(\".jstree-themeicon\").attr('rel') : true;\n\n      if (!obj.icon) {\n        obj.icon = true;\n      }\n\n      dom.children(\".jstree-anchor\").children(\".jstree-themeicon\").removeClass('jstree-themeicon-hidden');\n      return true;\n    }\n  }; // helpers\n\n  $.vakata = {}; // collect attributes\n\n  $.vakata.attributes = function (node, with_values) {\n    node = $(node)[0];\n    var attr = with_values ? {} : [];\n\n    if (node && node.attributes) {\n      $.each(node.attributes, function (i, v) {\n        if ($.inArray(v.name.toLowerCase(), ['style', 'contenteditable', 'hasfocus', 'tabindex']) !== -1) {\n          return;\n        }\n\n        if (v.value !== null && $.trim(v.value) !== '') {\n          if (with_values) {\n            attr[v.name] = v.value;\n          } else {\n            attr.push(v.name);\n          }\n        }\n      });\n    }\n\n    return attr;\n  };\n\n  $.vakata.array_unique = function (array) {\n    var a = [],\n        i,\n        j,\n        l,\n        o = {};\n\n    for (i = 0, l = array.length; i < l; i++) {\n      if (o[array[i]] === undefined) {\n        a.push(array[i]);\n        o[array[i]] = true;\n      }\n    }\n\n    return a;\n  }; // remove item from array\n\n\n  $.vakata.array_remove = function (array, from) {\n    array.splice(from, 1);\n    return array; //var rest = array.slice((to || from) + 1 || array.length);\n    //array.length = from < 0 ? array.length + from : from;\n    //array.push.apply(array, rest);\n    //return array;\n  }; // remove item from array\n\n\n  $.vakata.array_remove_item = function (array, item) {\n    var tmp = $.inArray(item, array);\n    return tmp !== -1 ? $.vakata.array_remove(array, tmp) : array;\n  };\n\n  $.vakata.array_filter = function (c, a, b, d, e) {\n    if (c.filter) {\n      return c.filter(a, b);\n    }\n\n    d = [];\n\n    for (e in c) {\n      if (~~e + '' === e + '' && e >= 0 && a.call(b, c[e], +e, c)) {\n        d.push(c[e]);\n      }\n    }\n\n    return d;\n  };\n  /**\n   * ### Changed plugin\n   *\n   * This plugin adds more information to the `changed.jstree` event. The new data is contained in the `changed` event data property, and contains a lists of `selected` and `deselected` nodes.\n   */\n\n\n  $.jstree.plugins.changed = function (options, parent) {\n    var last = [];\n\n    this.trigger = function (ev, data) {\n      var i, j;\n\n      if (!data) {\n        data = {};\n      }\n\n      if (ev.replace('.jstree', '') === 'changed') {\n        data.changed = {\n          selected: [],\n          deselected: []\n        };\n        var tmp = {};\n\n        for (i = 0, j = last.length; i < j; i++) {\n          tmp[last[i]] = 1;\n        }\n\n        for (i = 0, j = data.selected.length; i < j; i++) {\n          if (!tmp[data.selected[i]]) {\n            data.changed.selected.push(data.selected[i]);\n          } else {\n            tmp[data.selected[i]] = 2;\n          }\n        }\n\n        for (i = 0, j = last.length; i < j; i++) {\n          if (tmp[last[i]] === 1) {\n            data.changed.deselected.push(last[i]);\n          }\n        }\n\n        last = data.selected.slice();\n      }\n      /**\n       * triggered when selection changes (the \"changed\" plugin enhances the original event with more data)\n       * @event\n       * @name changed.jstree\n       * @param {Object} node\n       * @param {Object} action the action that caused the selection to change\n       * @param {Array} selected the current selection\n       * @param {Object} changed an object containing two properties `selected` and `deselected` - both arrays of node IDs, which were selected or deselected since the last changed event\n       * @param {Object} event the event (if any) that triggered this changed event\n       * @plugin changed\n       */\n\n\n      parent.trigger.call(this, ev, data);\n    };\n\n    this.refresh = function (skip_loading, forget_state) {\n      last = [];\n      return parent.refresh.apply(this, arguments);\n    };\n  };\n  /**\n   * ### Checkbox plugin\n   *\n   * This plugin renders checkbox icons in front of each node, making multiple selection much easier.\n   * It also supports tri-state behavior, meaning that if a node has a few of its children checked it will be rendered as undetermined, and state will be propagated up.\n   */\n\n\n  var _i = document.createElement('I');\n\n  _i.className = 'jstree-icon jstree-checkbox';\n\n  _i.setAttribute('role', 'presentation');\n  /**\n   * stores all defaults for the checkbox plugin\n   * @name $.jstree.defaults.checkbox\n   * @plugin checkbox\n   */\n\n\n  $.jstree.defaults.checkbox = {\n    /**\n     * a boolean indicating if checkboxes should be visible (can be changed at a later time using `show_checkboxes()` and `hide_checkboxes`). Defaults to `true`.\n     * @name $.jstree.defaults.checkbox.visible\n     * @plugin checkbox\n     */\n    visible: true,\n\n    /**\n     * a boolean indicating if checkboxes should cascade down and have an undetermined state. Defaults to `true`.\n     * @name $.jstree.defaults.checkbox.three_state\n     * @plugin checkbox\n     */\n    three_state: true,\n\n    /**\n     * a boolean indicating if clicking anywhere on the node should act as clicking on the checkbox. Defaults to `true`.\n     * @name $.jstree.defaults.checkbox.whole_node\n     * @plugin checkbox\n     */\n    whole_node: true,\n\n    /**\n     * a boolean indicating if the selected style of a node should be kept, or removed. Defaults to `true`.\n     * @name $.jstree.defaults.checkbox.keep_selected_style\n     * @plugin checkbox\n     */\n    keep_selected_style: true,\n\n    /**\n     * This setting controls how cascading and undetermined nodes are applied.\n     * If 'up' is in the string - cascading up is enabled, if 'down' is in the string - cascading down is enabled, if 'undetermined' is in the string - undetermined nodes will be used.\n     * If `three_state` is set to `true` this setting is automatically set to 'up+down+undetermined'. Defaults to ''.\n     * @name $.jstree.defaults.checkbox.cascade\n     * @plugin checkbox\n     */\n    cascade: '',\n\n    /**\n     * This setting controls if checkbox are bound to the general tree selection or to an internal array maintained by the checkbox plugin. Defaults to `true`, only set to `false` if you know exactly what you are doing.\n     * @name $.jstree.defaults.checkbox.tie_selection\n     * @plugin checkbox\n     */\n    tie_selection: true\n  };\n\n  $.jstree.plugins.checkbox = function (options, parent) {\n    this.bind = function () {\n      parent.bind.call(this);\n      this._data.checkbox.uto = false;\n      this._data.checkbox.selected = [];\n\n      if (this.settings.checkbox.three_state) {\n        this.settings.checkbox.cascade = 'up+down+undetermined';\n      }\n\n      this.element.on(\"init.jstree\", $.proxy(function () {\n        this._data.checkbox.visible = this.settings.checkbox.visible;\n\n        if (!this.settings.checkbox.keep_selected_style) {\n          this.element.addClass('jstree-checkbox-no-clicked');\n        }\n\n        if (this.settings.checkbox.tie_selection) {\n          this.element.addClass('jstree-checkbox-selection');\n        }\n      }, this)).on(\"loading.jstree\", $.proxy(function () {\n        this[this._data.checkbox.visible ? 'show_checkboxes' : 'hide_checkboxes']();\n      }, this));\n\n      if (this.settings.checkbox.cascade.indexOf('undetermined') !== -1) {\n        this.element.on('changed.jstree uncheck_node.jstree check_node.jstree uncheck_all.jstree check_all.jstree move_node.jstree copy_node.jstree redraw.jstree open_node.jstree', $.proxy(function () {\n          // only if undetermined is in setting\n          if (this._data.checkbox.uto) {\n            clearTimeout(this._data.checkbox.uto);\n          }\n\n          this._data.checkbox.uto = setTimeout($.proxy(this._undetermined, this), 50);\n        }, this));\n      }\n\n      if (!this.settings.checkbox.tie_selection) {\n        this.element.on('model.jstree', $.proxy(function (e, data) {\n          var m = this._model.data,\n              p = m[data.parent],\n              dpc = data.nodes,\n              i,\n              j;\n\n          for (i = 0, j = dpc.length; i < j; i++) {\n            m[dpc[i]].state.checked = m[dpc[i]].state.checked || m[dpc[i]].original && m[dpc[i]].original.state && m[dpc[i]].original.state.checked;\n\n            if (m[dpc[i]].state.checked) {\n              this._data.checkbox.selected.push(dpc[i]);\n            }\n          }\n        }, this));\n      }\n\n      if (this.settings.checkbox.cascade.indexOf('up') !== -1 || this.settings.checkbox.cascade.indexOf('down') !== -1) {\n        this.element.on('model.jstree', $.proxy(function (e, data) {\n          var m = this._model.data,\n              p = m[data.parent],\n              dpc = data.nodes,\n              chd = [],\n              c,\n              i,\n              j,\n              k,\n              l,\n              tmp,\n              s = this.settings.checkbox.cascade,\n              t = this.settings.checkbox.tie_selection;\n\n          if (s.indexOf('down') !== -1) {\n            // apply down\n            if (p.state[t ? 'selected' : 'checked']) {\n              for (i = 0, j = dpc.length; i < j; i++) {\n                m[dpc[i]].state[t ? 'selected' : 'checked'] = true;\n              }\n\n              this._data[t ? 'core' : 'checkbox'].selected = this._data[t ? 'core' : 'checkbox'].selected.concat(dpc);\n            } else {\n              for (i = 0, j = dpc.length; i < j; i++) {\n                if (m[dpc[i]].state[t ? 'selected' : 'checked']) {\n                  for (k = 0, l = m[dpc[i]].children_d.length; k < l; k++) {\n                    m[m[dpc[i]].children_d[k]].state[t ? 'selected' : 'checked'] = true;\n                  }\n\n                  this._data[t ? 'core' : 'checkbox'].selected = this._data[t ? 'core' : 'checkbox'].selected.concat(m[dpc[i]].children_d);\n                }\n              }\n            }\n          }\n\n          if (s.indexOf('up') !== -1) {\n            // apply up\n            for (i = 0, j = p.children_d.length; i < j; i++) {\n              if (!m[p.children_d[i]].children.length) {\n                chd.push(m[p.children_d[i]].parent);\n              }\n            }\n\n            chd = $.vakata.array_unique(chd);\n\n            for (k = 0, l = chd.length; k < l; k++) {\n              p = m[chd[k]];\n\n              while (p && p.id !== $.jstree.root) {\n                c = 0;\n\n                for (i = 0, j = p.children.length; i < j; i++) {\n                  c += m[p.children[i]].state[t ? 'selected' : 'checked'];\n                }\n\n                if (c === j) {\n                  p.state[t ? 'selected' : 'checked'] = true;\n\n                  this._data[t ? 'core' : 'checkbox'].selected.push(p.id);\n\n                  tmp = this.get_node(p, true);\n\n                  if (tmp && tmp.length) {\n                    tmp.attr('aria-selected', true).children('.jstree-anchor').addClass(t ? 'jstree-clicked' : 'jstree-checked');\n                  }\n                } else {\n                  break;\n                }\n\n                p = this.get_node(p.parent);\n              }\n            }\n          }\n\n          this._data[t ? 'core' : 'checkbox'].selected = $.vakata.array_unique(this._data[t ? 'core' : 'checkbox'].selected);\n        }, this)).on(this.settings.checkbox.tie_selection ? 'select_node.jstree' : 'check_node.jstree', $.proxy(function (e, data) {\n          var obj = data.node,\n              m = this._model.data,\n              par = this.get_node(obj.parent),\n              dom = this.get_node(obj, true),\n              i,\n              j,\n              c,\n              tmp,\n              s = this.settings.checkbox.cascade,\n              t = this.settings.checkbox.tie_selection,\n              sel = {},\n              cur = this._data[t ? 'core' : 'checkbox'].selected;\n\n          for (i = 0, j = cur.length; i < j; i++) {\n            sel[cur[i]] = true;\n          } // apply down\n\n\n          if (s.indexOf('down') !== -1) {\n            //this._data[ t ? 'core' : 'checkbox' ].selected = $.vakata.array_unique(this._data[ t ? 'core' : 'checkbox' ].selected.concat(obj.children_d));\n            for (i = 0, j = obj.children_d.length; i < j; i++) {\n              sel[obj.children_d[i]] = true;\n              tmp = m[obj.children_d[i]];\n              tmp.state[t ? 'selected' : 'checked'] = true;\n\n              if (tmp && tmp.original && tmp.original.state && tmp.original.state.undetermined) {\n                tmp.original.state.undetermined = false;\n              }\n            }\n          } // apply up\n\n\n          if (s.indexOf('up') !== -1) {\n            while (par && par.id !== $.jstree.root) {\n              c = 0;\n\n              for (i = 0, j = par.children.length; i < j; i++) {\n                c += m[par.children[i]].state[t ? 'selected' : 'checked'];\n              }\n\n              if (c === j) {\n                par.state[t ? 'selected' : 'checked'] = true;\n                sel[par.id] = true; //this._data[ t ? 'core' : 'checkbox' ].selected.push(par.id);\n\n                tmp = this.get_node(par, true);\n\n                if (tmp && tmp.length) {\n                  tmp.attr('aria-selected', true).children('.jstree-anchor').addClass(t ? 'jstree-clicked' : 'jstree-checked');\n                }\n              } else {\n                break;\n              }\n\n              par = this.get_node(par.parent);\n            }\n          }\n\n          cur = [];\n\n          for (i in sel) {\n            if (sel.hasOwnProperty(i)) {\n              cur.push(i);\n            }\n          }\n\n          this._data[t ? 'core' : 'checkbox'].selected = cur; // apply down (process .children separately?)\n\n          if (s.indexOf('down') !== -1 && dom.length) {\n            dom.find('.jstree-anchor').addClass(t ? 'jstree-clicked' : 'jstree-checked').parent().attr('aria-selected', true);\n          }\n        }, this)).on(this.settings.checkbox.tie_selection ? 'deselect_all.jstree' : 'uncheck_all.jstree', $.proxy(function (e, data) {\n          var obj = this.get_node($.jstree.root),\n              m = this._model.data,\n              i,\n              j,\n              tmp;\n\n          for (i = 0, j = obj.children_d.length; i < j; i++) {\n            tmp = m[obj.children_d[i]];\n\n            if (tmp && tmp.original && tmp.original.state && tmp.original.state.undetermined) {\n              tmp.original.state.undetermined = false;\n            }\n          }\n        }, this)).on(this.settings.checkbox.tie_selection ? 'deselect_node.jstree' : 'uncheck_node.jstree', $.proxy(function (e, data) {\n          var obj = data.node,\n              dom = this.get_node(obj, true),\n              i,\n              j,\n              tmp,\n              s = this.settings.checkbox.cascade,\n              t = this.settings.checkbox.tie_selection,\n              cur = this._data[t ? 'core' : 'checkbox'].selected,\n              sel = {};\n\n          if (obj && obj.original && obj.original.state && obj.original.state.undetermined) {\n            obj.original.state.undetermined = false;\n          } // apply down\n\n\n          if (s.indexOf('down') !== -1) {\n            for (i = 0, j = obj.children_d.length; i < j; i++) {\n              tmp = this._model.data[obj.children_d[i]];\n              tmp.state[t ? 'selected' : 'checked'] = false;\n\n              if (tmp && tmp.original && tmp.original.state && tmp.original.state.undetermined) {\n                tmp.original.state.undetermined = false;\n              }\n            }\n          } // apply up\n\n\n          if (s.indexOf('up') !== -1) {\n            for (i = 0, j = obj.parents.length; i < j; i++) {\n              tmp = this._model.data[obj.parents[i]];\n              tmp.state[t ? 'selected' : 'checked'] = false;\n\n              if (tmp && tmp.original && tmp.original.state && tmp.original.state.undetermined) {\n                tmp.original.state.undetermined = false;\n              }\n\n              tmp = this.get_node(obj.parents[i], true);\n\n              if (tmp && tmp.length) {\n                tmp.attr('aria-selected', false).children('.jstree-anchor').removeClass(t ? 'jstree-clicked' : 'jstree-checked');\n              }\n            }\n          }\n\n          sel = {};\n\n          for (i = 0, j = cur.length; i < j; i++) {\n            // apply down + apply up\n            if ((s.indexOf('down') === -1 || $.inArray(cur[i], obj.children_d) === -1) && (s.indexOf('up') === -1 || $.inArray(cur[i], obj.parents) === -1)) {\n              sel[cur[i]] = true;\n            }\n          }\n\n          cur = [];\n\n          for (i in sel) {\n            if (sel.hasOwnProperty(i)) {\n              cur.push(i);\n            }\n          }\n\n          this._data[t ? 'core' : 'checkbox'].selected = cur; // apply down (process .children separately?)\n\n          if (s.indexOf('down') !== -1 && dom.length) {\n            dom.find('.jstree-anchor').removeClass(t ? 'jstree-clicked' : 'jstree-checked').parent().attr('aria-selected', false);\n          }\n        }, this));\n      }\n\n      if (this.settings.checkbox.cascade.indexOf('up') !== -1) {\n        this.element.on('delete_node.jstree', $.proxy(function (e, data) {\n          // apply up (whole handler)\n          var p = this.get_node(data.parent),\n              m = this._model.data,\n              i,\n              j,\n              c,\n              tmp,\n              t = this.settings.checkbox.tie_selection;\n\n          while (p && p.id !== $.jstree.root && !p.state[t ? 'selected' : 'checked']) {\n            c = 0;\n\n            for (i = 0, j = p.children.length; i < j; i++) {\n              c += m[p.children[i]].state[t ? 'selected' : 'checked'];\n            }\n\n            if (j > 0 && c === j) {\n              p.state[t ? 'selected' : 'checked'] = true;\n\n              this._data[t ? 'core' : 'checkbox'].selected.push(p.id);\n\n              tmp = this.get_node(p, true);\n\n              if (tmp && tmp.length) {\n                tmp.attr('aria-selected', true).children('.jstree-anchor').addClass(t ? 'jstree-clicked' : 'jstree-checked');\n              }\n            } else {\n              break;\n            }\n\n            p = this.get_node(p.parent);\n          }\n        }, this)).on('move_node.jstree', $.proxy(function (e, data) {\n          // apply up (whole handler)\n          var is_multi = data.is_multi,\n              old_par = data.old_parent,\n              new_par = this.get_node(data.parent),\n              m = this._model.data,\n              p,\n              c,\n              i,\n              j,\n              tmp,\n              t = this.settings.checkbox.tie_selection;\n\n          if (!is_multi) {\n            p = this.get_node(old_par);\n\n            while (p && p.id !== $.jstree.root && !p.state[t ? 'selected' : 'checked']) {\n              c = 0;\n\n              for (i = 0, j = p.children.length; i < j; i++) {\n                c += m[p.children[i]].state[t ? 'selected' : 'checked'];\n              }\n\n              if (j > 0 && c === j) {\n                p.state[t ? 'selected' : 'checked'] = true;\n\n                this._data[t ? 'core' : 'checkbox'].selected.push(p.id);\n\n                tmp = this.get_node(p, true);\n\n                if (tmp && tmp.length) {\n                  tmp.attr('aria-selected', true).children('.jstree-anchor').addClass(t ? 'jstree-clicked' : 'jstree-checked');\n                }\n              } else {\n                break;\n              }\n\n              p = this.get_node(p.parent);\n            }\n          }\n\n          p = new_par;\n\n          while (p && p.id !== $.jstree.root) {\n            c = 0;\n\n            for (i = 0, j = p.children.length; i < j; i++) {\n              c += m[p.children[i]].state[t ? 'selected' : 'checked'];\n            }\n\n            if (c === j) {\n              if (!p.state[t ? 'selected' : 'checked']) {\n                p.state[t ? 'selected' : 'checked'] = true;\n\n                this._data[t ? 'core' : 'checkbox'].selected.push(p.id);\n\n                tmp = this.get_node(p, true);\n\n                if (tmp && tmp.length) {\n                  tmp.attr('aria-selected', true).children('.jstree-anchor').addClass(t ? 'jstree-clicked' : 'jstree-checked');\n                }\n              }\n            } else {\n              if (p.state[t ? 'selected' : 'checked']) {\n                p.state[t ? 'selected' : 'checked'] = false;\n                this._data[t ? 'core' : 'checkbox'].selected = $.vakata.array_remove_item(this._data[t ? 'core' : 'checkbox'].selected, p.id);\n                tmp = this.get_node(p, true);\n\n                if (tmp && tmp.length) {\n                  tmp.attr('aria-selected', false).children('.jstree-anchor').removeClass(t ? 'jstree-clicked' : 'jstree-checked');\n                }\n              } else {\n                break;\n              }\n            }\n\n            p = this.get_node(p.parent);\n          }\n        }, this));\n      }\n    };\n    /**\n     * set the undetermined state where and if necessary. Used internally.\n     * @private\n     * @name _undetermined()\n     * @plugin checkbox\n     */\n\n\n    this._undetermined = function () {\n      if (this.element === null) {\n        return;\n      }\n\n      var i,\n          j,\n          k,\n          l,\n          o = {},\n          m = this._model.data,\n          t = this.settings.checkbox.tie_selection,\n          s = this._data[t ? 'core' : 'checkbox'].selected,\n          p = [],\n          tt = this;\n\n      for (i = 0, j = s.length; i < j; i++) {\n        if (m[s[i]] && m[s[i]].parents) {\n          for (k = 0, l = m[s[i]].parents.length; k < l; k++) {\n            if (o[m[s[i]].parents[k]] !== undefined) {\n              break;\n            }\n\n            if (m[s[i]].parents[k] !== $.jstree.root) {\n              o[m[s[i]].parents[k]] = true;\n              p.push(m[s[i]].parents[k]);\n            }\n          }\n        }\n      } // attempt for server side undetermined state\n\n\n      this.element.find('.jstree-closed').not(':has(.jstree-children)').each(function () {\n        var tmp = tt.get_node(this),\n            tmp2;\n\n        if (!tmp.state.loaded) {\n          if (tmp.original && tmp.original.state && tmp.original.state.undetermined && tmp.original.state.undetermined === true) {\n            if (o[tmp.id] === undefined && tmp.id !== $.jstree.root) {\n              o[tmp.id] = true;\n              p.push(tmp.id);\n            }\n\n            for (k = 0, l = tmp.parents.length; k < l; k++) {\n              if (o[tmp.parents[k]] === undefined && tmp.parents[k] !== $.jstree.root) {\n                o[tmp.parents[k]] = true;\n                p.push(tmp.parents[k]);\n              }\n            }\n          }\n        } else {\n          for (i = 0, j = tmp.children_d.length; i < j; i++) {\n            tmp2 = m[tmp.children_d[i]];\n\n            if (!tmp2.state.loaded && tmp2.original && tmp2.original.state && tmp2.original.state.undetermined && tmp2.original.state.undetermined === true) {\n              if (o[tmp2.id] === undefined && tmp2.id !== $.jstree.root) {\n                o[tmp2.id] = true;\n                p.push(tmp2.id);\n              }\n\n              for (k = 0, l = tmp2.parents.length; k < l; k++) {\n                if (o[tmp2.parents[k]] === undefined && tmp2.parents[k] !== $.jstree.root) {\n                  o[tmp2.parents[k]] = true;\n                  p.push(tmp2.parents[k]);\n                }\n              }\n            }\n          }\n        }\n      });\n      this.element.find('.jstree-undetermined').removeClass('jstree-undetermined');\n\n      for (i = 0, j = p.length; i < j; i++) {\n        if (!m[p[i]].state[t ? 'selected' : 'checked']) {\n          s = this.get_node(p[i], true);\n\n          if (s && s.length) {\n            s.children('.jstree-anchor').children('.jstree-checkbox').addClass('jstree-undetermined');\n          }\n        }\n      }\n    };\n\n    this.redraw_node = function (obj, deep, is_callback, force_render) {\n      obj = parent.redraw_node.apply(this, arguments);\n\n      if (obj) {\n        var i,\n            j,\n            tmp = null,\n            icon = null;\n\n        for (i = 0, j = obj.childNodes.length; i < j; i++) {\n          if (obj.childNodes[i] && obj.childNodes[i].className && obj.childNodes[i].className.indexOf(\"jstree-anchor\") !== -1) {\n            tmp = obj.childNodes[i];\n            break;\n          }\n        }\n\n        if (tmp) {\n          if (!this.settings.checkbox.tie_selection && this._model.data[obj.id].state.checked) {\n            tmp.className += ' jstree-checked';\n          }\n\n          icon = _i.cloneNode(false);\n\n          if (this._model.data[obj.id].state.checkbox_disabled) {\n            icon.className += ' jstree-checkbox-disabled';\n          }\n\n          tmp.insertBefore(icon, tmp.childNodes[0]);\n        }\n      }\n\n      if (!is_callback && this.settings.checkbox.cascade.indexOf('undetermined') !== -1) {\n        if (this._data.checkbox.uto) {\n          clearTimeout(this._data.checkbox.uto);\n        }\n\n        this._data.checkbox.uto = setTimeout($.proxy(this._undetermined, this), 50);\n      }\n\n      return obj;\n    };\n    /**\n     * show the node checkbox icons\n     * @name show_checkboxes()\n     * @plugin checkbox\n     */\n\n\n    this.show_checkboxes = function () {\n      this._data.core.themes.checkboxes = true;\n      this.get_container_ul().removeClass(\"jstree-no-checkboxes\");\n    };\n    /**\n     * hide the node checkbox icons\n     * @name hide_checkboxes()\n     * @plugin checkbox\n     */\n\n\n    this.hide_checkboxes = function () {\n      this._data.core.themes.checkboxes = false;\n      this.get_container_ul().addClass(\"jstree-no-checkboxes\");\n    };\n    /**\n     * toggle the node icons\n     * @name toggle_checkboxes()\n     * @plugin checkbox\n     */\n\n\n    this.toggle_checkboxes = function () {\n      if (this._data.core.themes.checkboxes) {\n        this.hide_checkboxes();\n      } else {\n        this.show_checkboxes();\n      }\n    };\n    /**\n     * checks if a node is in an undetermined state\n     * @name is_undetermined(obj)\n     * @param  {mixed} obj\n     * @return {Boolean}\n     */\n\n\n    this.is_undetermined = function (obj) {\n      obj = this.get_node(obj);\n      var s = this.settings.checkbox.cascade,\n          i,\n          j,\n          t = this.settings.checkbox.tie_selection,\n          d = this._data[t ? 'core' : 'checkbox'].selected,\n          m = this._model.data;\n\n      if (!obj || obj.state[t ? 'selected' : 'checked'] === true || s.indexOf('undetermined') === -1 || s.indexOf('down') === -1 && s.indexOf('up') === -1) {\n        return false;\n      }\n\n      if (!obj.state.loaded && obj.original.state.undetermined === true) {\n        return true;\n      }\n\n      for (i = 0, j = obj.children_d.length; i < j; i++) {\n        if ($.inArray(obj.children_d[i], d) !== -1 || !m[obj.children_d[i]].state.loaded && m[obj.children_d[i]].original.state.undetermined) {\n          return true;\n        }\n      }\n\n      return false;\n    };\n    /**\n     * disable a node's checkbox\n     * @name disable_checkbox(obj)\n     * @param {mixed} obj an array can be used too\n     * @trigger disable_checkbox.jstree\n     * @plugin checkbox\n     */\n\n\n    this.disable_checkbox = function (obj) {\n      var t1, t2, dom;\n\n      if ($.isArray(obj)) {\n        obj = obj.slice();\n\n        for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n          this.disable_checkbox(obj[t1]);\n        }\n\n        return true;\n      }\n\n      obj = this.get_node(obj);\n\n      if (!obj || obj.id === $.jstree.root) {\n        return false;\n      }\n\n      dom = this.get_node(obj, true);\n\n      if (!obj.state.checkbox_disabled) {\n        obj.state.checkbox_disabled = true;\n\n        if (dom && dom.length) {\n          dom.children('.jstree-anchor').children('.jstree-checkbox').addClass('jstree-checkbox-disabled');\n        }\n        /**\n         * triggered when an node's checkbox is disabled\n         * @event\n         * @name disable_checkbox.jstree\n         * @param {Object} node\n         * @plugin checkbox\n         */\n\n\n        this.trigger('disable_checkbox', {\n          'node': obj\n        });\n      }\n    };\n    /**\n     * enable a node's checkbox\n     * @name disable_checkbox(obj)\n     * @param {mixed} obj an array can be used too\n     * @trigger enable_checkbox.jstree\n     * @plugin checkbox\n     */\n\n\n    this.enable_checkbox = function (obj) {\n      var t1, t2, dom;\n\n      if ($.isArray(obj)) {\n        obj = obj.slice();\n\n        for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n          this.enable_checkbox(obj[t1]);\n        }\n\n        return true;\n      }\n\n      obj = this.get_node(obj);\n\n      if (!obj || obj.id === $.jstree.root) {\n        return false;\n      }\n\n      dom = this.get_node(obj, true);\n\n      if (obj.state.checkbox_disabled) {\n        obj.state.checkbox_disabled = false;\n\n        if (dom && dom.length) {\n          dom.children('.jstree-anchor').children('.jstree-checkbox').removeClass('jstree-checkbox-disabled');\n        }\n        /**\n         * triggered when an node's checkbox is enabled\n         * @event\n         * @name enable_checkbox.jstree\n         * @param {Object} node\n         * @plugin checkbox\n         */\n\n\n        this.trigger('enable_checkbox', {\n          'node': obj\n        });\n      }\n    };\n\n    this.activate_node = function (obj, e) {\n      if ($(e.target).hasClass('jstree-checkbox-disabled')) {\n        return false;\n      }\n\n      if (this.settings.checkbox.tie_selection && (this.settings.checkbox.whole_node || $(e.target).hasClass('jstree-checkbox'))) {\n        e.ctrlKey = true;\n      }\n\n      if (this.settings.checkbox.tie_selection || !this.settings.checkbox.whole_node && !$(e.target).hasClass('jstree-checkbox')) {\n        return parent.activate_node.call(this, obj, e);\n      }\n\n      if (this.is_disabled(obj)) {\n        return false;\n      }\n\n      if (this.is_checked(obj)) {\n        this.uncheck_node(obj, e);\n      } else {\n        this.check_node(obj, e);\n      }\n\n      this.trigger('activate_node', {\n        'node': this.get_node(obj)\n      });\n    };\n    /**\n     * check a node (only if tie_selection in checkbox settings is false, otherwise select_node will be called internally)\n     * @name check_node(obj)\n     * @param {mixed} obj an array can be used to check multiple nodes\n     * @trigger check_node.jstree\n     * @plugin checkbox\n     */\n\n\n    this.check_node = function (obj, e) {\n      if (this.settings.checkbox.tie_selection) {\n        return this.select_node(obj, false, true, e);\n      }\n\n      var dom, t1, t2, th;\n\n      if ($.isArray(obj)) {\n        obj = obj.slice();\n\n        for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n          this.check_node(obj[t1], e);\n        }\n\n        return true;\n      }\n\n      obj = this.get_node(obj);\n\n      if (!obj || obj.id === $.jstree.root) {\n        return false;\n      }\n\n      dom = this.get_node(obj, true);\n\n      if (!obj.state.checked) {\n        obj.state.checked = true;\n\n        this._data.checkbox.selected.push(obj.id);\n\n        if (dom && dom.length) {\n          dom.children('.jstree-anchor').addClass('jstree-checked');\n        }\n        /**\n         * triggered when an node is checked (only if tie_selection in checkbox settings is false)\n         * @event\n         * @name check_node.jstree\n         * @param {Object} node\n         * @param {Array} selected the current selection\n         * @param {Object} event the event (if any) that triggered this check_node\n         * @plugin checkbox\n         */\n\n\n        this.trigger('check_node', {\n          'node': obj,\n          'selected': this._data.checkbox.selected,\n          'event': e\n        });\n      }\n    };\n    /**\n     * uncheck a node (only if tie_selection in checkbox settings is false, otherwise deselect_node will be called internally)\n     * @name uncheck_node(obj)\n     * @param {mixed} obj an array can be used to uncheck multiple nodes\n     * @trigger uncheck_node.jstree\n     * @plugin checkbox\n     */\n\n\n    this.uncheck_node = function (obj, e) {\n      if (this.settings.checkbox.tie_selection) {\n        return this.deselect_node(obj, false, e);\n      }\n\n      var t1, t2, dom;\n\n      if ($.isArray(obj)) {\n        obj = obj.slice();\n\n        for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n          this.uncheck_node(obj[t1], e);\n        }\n\n        return true;\n      }\n\n      obj = this.get_node(obj);\n\n      if (!obj || obj.id === $.jstree.root) {\n        return false;\n      }\n\n      dom = this.get_node(obj, true);\n\n      if (obj.state.checked) {\n        obj.state.checked = false;\n        this._data.checkbox.selected = $.vakata.array_remove_item(this._data.checkbox.selected, obj.id);\n\n        if (dom.length) {\n          dom.children('.jstree-anchor').removeClass('jstree-checked');\n        }\n        /**\n         * triggered when an node is unchecked (only if tie_selection in checkbox settings is false)\n         * @event\n         * @name uncheck_node.jstree\n         * @param {Object} node\n         * @param {Array} selected the current selection\n         * @param {Object} event the event (if any) that triggered this uncheck_node\n         * @plugin checkbox\n         */\n\n\n        this.trigger('uncheck_node', {\n          'node': obj,\n          'selected': this._data.checkbox.selected,\n          'event': e\n        });\n      }\n    };\n    /**\n     * checks all nodes in the tree (only if tie_selection in checkbox settings is false, otherwise select_all will be called internally)\n     * @name check_all()\n     * @trigger check_all.jstree, changed.jstree\n     * @plugin checkbox\n     */\n\n\n    this.check_all = function () {\n      if (this.settings.checkbox.tie_selection) {\n        return this.select_all();\n      }\n\n      var tmp = this._data.checkbox.selected.concat([]),\n          i,\n          j;\n\n      this._data.checkbox.selected = this._model.data[$.jstree.root].children_d.concat();\n\n      for (i = 0, j = this._data.checkbox.selected.length; i < j; i++) {\n        if (this._model.data[this._data.checkbox.selected[i]]) {\n          this._model.data[this._data.checkbox.selected[i]].state.checked = true;\n        }\n      }\n\n      this.redraw(true);\n      /**\n       * triggered when all nodes are checked (only if tie_selection in checkbox settings is false)\n       * @event\n       * @name check_all.jstree\n       * @param {Array} selected the current selection\n       * @plugin checkbox\n       */\n\n      this.trigger('check_all', {\n        'selected': this._data.checkbox.selected\n      });\n    };\n    /**\n     * uncheck all checked nodes (only if tie_selection in checkbox settings is false, otherwise deselect_all will be called internally)\n     * @name uncheck_all()\n     * @trigger uncheck_all.jstree\n     * @plugin checkbox\n     */\n\n\n    this.uncheck_all = function () {\n      if (this.settings.checkbox.tie_selection) {\n        return this.deselect_all();\n      }\n\n      var tmp = this._data.checkbox.selected.concat([]),\n          i,\n          j;\n\n      for (i = 0, j = this._data.checkbox.selected.length; i < j; i++) {\n        if (this._model.data[this._data.checkbox.selected[i]]) {\n          this._model.data[this._data.checkbox.selected[i]].state.checked = false;\n        }\n      }\n\n      this._data.checkbox.selected = [];\n      this.element.find('.jstree-checked').removeClass('jstree-checked');\n      /**\n       * triggered when all nodes are unchecked (only if tie_selection in checkbox settings is false)\n       * @event\n       * @name uncheck_all.jstree\n       * @param {Object} node the previous selection\n       * @param {Array} selected the current selection\n       * @plugin checkbox\n       */\n\n      this.trigger('uncheck_all', {\n        'selected': this._data.checkbox.selected,\n        'node': tmp\n      });\n    };\n    /**\n     * checks if a node is checked (if tie_selection is on in the settings this function will return the same as is_selected)\n     * @name is_checked(obj)\n     * @param  {mixed}  obj\n     * @return {Boolean}\n     * @plugin checkbox\n     */\n\n\n    this.is_checked = function (obj) {\n      if (this.settings.checkbox.tie_selection) {\n        return this.is_selected(obj);\n      }\n\n      obj = this.get_node(obj);\n\n      if (!obj || obj.id === $.jstree.root) {\n        return false;\n      }\n\n      return obj.state.checked;\n    };\n    /**\n     * get an array of all checked nodes (if tie_selection is on in the settings this function will return the same as get_selected)\n     * @name get_checked([full])\n     * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned\n     * @return {Array}\n     * @plugin checkbox\n     */\n\n\n    this.get_checked = function (full) {\n      if (this.settings.checkbox.tie_selection) {\n        return this.get_selected(full);\n      }\n\n      return full ? $.map(this._data.checkbox.selected, $.proxy(function (i) {\n        return this.get_node(i);\n      }, this)) : this._data.checkbox.selected;\n    };\n    /**\n     * get an array of all top level checked nodes (ignoring children of checked nodes) (if tie_selection is on in the settings this function will return the same as get_top_selected)\n     * @name get_top_checked([full])\n     * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned\n     * @return {Array}\n     * @plugin checkbox\n     */\n\n\n    this.get_top_checked = function (full) {\n      if (this.settings.checkbox.tie_selection) {\n        return this.get_top_selected(full);\n      }\n\n      var tmp = this.get_checked(true),\n          obj = {},\n          i,\n          j,\n          k,\n          l;\n\n      for (i = 0, j = tmp.length; i < j; i++) {\n        obj[tmp[i].id] = tmp[i];\n      }\n\n      for (i = 0, j = tmp.length; i < j; i++) {\n        for (k = 0, l = tmp[i].children_d.length; k < l; k++) {\n          if (obj[tmp[i].children_d[k]]) {\n            delete obj[tmp[i].children_d[k]];\n          }\n        }\n      }\n\n      tmp = [];\n\n      for (i in obj) {\n        if (obj.hasOwnProperty(i)) {\n          tmp.push(i);\n        }\n      }\n\n      return full ? $.map(tmp, $.proxy(function (i) {\n        return this.get_node(i);\n      }, this)) : tmp;\n    };\n    /**\n     * get an array of all bottom level checked nodes (ignoring selected parents) (if tie_selection is on in the settings this function will return the same as get_bottom_selected)\n     * @name get_bottom_checked([full])\n     * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned\n     * @return {Array}\n     * @plugin checkbox\n     */\n\n\n    this.get_bottom_checked = function (full) {\n      if (this.settings.checkbox.tie_selection) {\n        return this.get_bottom_selected(full);\n      }\n\n      var tmp = this.get_checked(true),\n          obj = [],\n          i,\n          j;\n\n      for (i = 0, j = tmp.length; i < j; i++) {\n        if (!tmp[i].children.length) {\n          obj.push(tmp[i].id);\n        }\n      }\n\n      return full ? $.map(obj, $.proxy(function (i) {\n        return this.get_node(i);\n      }, this)) : obj;\n    };\n\n    this.load_node = function (obj, callback) {\n      var k, l, i, j, c, tmp;\n\n      if (!$.isArray(obj) && !this.settings.checkbox.tie_selection) {\n        tmp = this.get_node(obj);\n\n        if (tmp && tmp.state.loaded) {\n          for (k = 0, l = tmp.children_d.length; k < l; k++) {\n            if (this._model.data[tmp.children_d[k]].state.checked) {\n              c = true;\n              this._data.checkbox.selected = $.vakata.array_remove_item(this._data.checkbox.selected, tmp.children_d[k]);\n            }\n          }\n        }\n      }\n\n      return parent.load_node.apply(this, arguments);\n    };\n\n    this.get_state = function () {\n      var state = parent.get_state.apply(this, arguments);\n\n      if (this.settings.checkbox.tie_selection) {\n        return state;\n      }\n\n      state.checkbox = this._data.checkbox.selected.slice();\n      return state;\n    };\n\n    this.set_state = function (state, callback) {\n      var res = parent.set_state.apply(this, arguments);\n\n      if (res && state.checkbox) {\n        if (!this.settings.checkbox.tie_selection) {\n          this.uncheck_all();\n\n          var _this = this;\n\n          $.each(state.checkbox, function (i, v) {\n            _this.check_node(v);\n          });\n        }\n\n        delete state.checkbox;\n        this.set_state(state, callback);\n        return false;\n      }\n\n      return res;\n    };\n\n    this.refresh = function (skip_loading, forget_state) {\n      if (!this.settings.checkbox.tie_selection) {\n        this._data.checkbox.selected = [];\n      }\n\n      return parent.refresh.apply(this, arguments);\n    };\n  }; // include the checkbox plugin by default\n  // $.jstree.defaults.plugins.push(\"checkbox\");\n\n  /**\n   * ### Conditionalselect plugin\n   *\n   * This plugin allows defining a callback to allow or deny node selection by user input (activate node method).\n   */\n\n  /**\n   * a callback (function) which is invoked in the instance's scope and receives two arguments - the node and the event that triggered the `activate_node` call. Returning false prevents working with the node, returning true allows invoking activate_node. Defaults to returning `true`.\n   * @name $.jstree.defaults.checkbox.visible\n   * @plugin checkbox\n   */\n\n\n  $.jstree.defaults.conditionalselect = function () {\n    return true;\n  };\n\n  $.jstree.plugins.conditionalselect = function (options, parent) {\n    // own function\n    this.activate_node = function (obj, e) {\n      if (this.settings.conditionalselect.call(this, this.get_node(obj), e)) {\n        parent.activate_node.call(this, obj, e);\n      }\n    };\n  };\n  /**\n   * ### Contextmenu plugin\n   *\n   * Shows a context menu when a node is right-clicked.\n   */\n\n  /**\n   * stores all defaults for the contextmenu plugin\n   * @name $.jstree.defaults.contextmenu\n   * @plugin contextmenu\n   */\n\n\n  $.jstree.defaults.contextmenu = {\n    /**\n     * a boolean indicating if the node should be selected when the context menu is invoked on it. Defaults to `true`.\n     * @name $.jstree.defaults.contextmenu.select_node\n     * @plugin contextmenu\n     */\n    select_node: true,\n\n    /**\n     * a boolean indicating if the menu should be shown aligned with the node. Defaults to `true`, otherwise the mouse coordinates are used.\n     * @name $.jstree.defaults.contextmenu.show_at_node\n     * @plugin contextmenu\n     */\n    show_at_node: true,\n\n    /**\n     * an object of actions, or a function that accepts a node and a callback function and calls the callback function with an object of actions available for that node (you can also return the items too).\n     *\n     * Each action consists of a key (a unique name) and a value which is an object with the following properties (only label and action are required). Once a menu item is activated the `action` function will be invoked with an object containing the following keys: item - the contextmenu item definition as seen below, reference - the DOM node that was used (the tree node), element - the contextmenu DOM element, position - an object with x/y properties indicating the position of the menu.\n     *\n     * * `separator_before` - a boolean indicating if there should be a separator before this item\n     * * `separator_after` - a boolean indicating if there should be a separator after this item\n     * * `_disabled` - a boolean indicating if this action should be disabled\n     * * `label` - a string - the name of the action (could be a function returning a string)\n     * * `title` - a string - an optional tooltip for the item\n     * * `action` - a function to be executed if this item is chosen, the function will receive \n     * * `icon` - a string, can be a path to an icon or a className, if using an image that is in the current directory use a `./` prefix, otherwise it will be detected as a class\n     * * `shortcut` - keyCode which will trigger the action if the menu is open (for example `113` for rename, which equals F2)\n     * * `shortcut_label` - shortcut label (like for example `F2` for rename)\n     * * `submenu` - an object with the same structure as $.jstree.defaults.contextmenu.items which can be used to create a submenu - each key will be rendered as a separate option in a submenu that will appear once the current item is hovered\n     *\n     * @name $.jstree.defaults.contextmenu.items\n     * @plugin contextmenu\n     */\n    items: function items(o, cb) {\n      // Could be an object directly\n      return {\n        \"create\": {\n          \"separator_before\": false,\n          \"separator_after\": true,\n          \"_disabled\": false,\n          //(this.check(\"create_node\", data.reference, {}, \"last\")),\n          \"label\": \"Create\",\n          \"action\": function action(data) {\n            var inst = $.jstree.reference(data.reference),\n                obj = inst.get_node(data.reference);\n            inst.create_node(obj, {}, \"last\", function (new_node) {\n              setTimeout(function () {\n                inst.edit(new_node);\n              }, 0);\n            });\n          }\n        },\n        \"rename\": {\n          \"separator_before\": false,\n          \"separator_after\": false,\n          \"_disabled\": false,\n          //(this.check(\"rename_node\", data.reference, this.get_parent(data.reference), \"\")),\n          \"label\": \"Rename\",\n\n          /*!\n          \"shortcut\"\t\t\t: 113,\n          \"shortcut_label\"\t: 'F2',\n          \"icon\"\t\t\t\t: \"glyphicon glyphicon-leaf\",\n          */\n          \"action\": function action(data) {\n            var inst = $.jstree.reference(data.reference),\n                obj = inst.get_node(data.reference);\n            inst.edit(obj);\n          }\n        },\n        \"remove\": {\n          \"separator_before\": false,\n          \"icon\": false,\n          \"separator_after\": false,\n          \"_disabled\": false,\n          //(this.check(\"delete_node\", data.reference, this.get_parent(data.reference), \"\")),\n          \"label\": \"Delete\",\n          \"action\": function action(data) {\n            var inst = $.jstree.reference(data.reference),\n                obj = inst.get_node(data.reference);\n\n            if (inst.is_selected(obj)) {\n              inst.delete_node(inst.get_selected());\n            } else {\n              inst.delete_node(obj);\n            }\n          }\n        },\n        \"ccp\": {\n          \"separator_before\": true,\n          \"icon\": false,\n          \"separator_after\": false,\n          \"label\": \"Edit\",\n          \"action\": false,\n          \"submenu\": {\n            \"cut\": {\n              \"separator_before\": false,\n              \"separator_after\": false,\n              \"label\": \"Cut\",\n              \"action\": function action(data) {\n                var inst = $.jstree.reference(data.reference),\n                    obj = inst.get_node(data.reference);\n\n                if (inst.is_selected(obj)) {\n                  inst.cut(inst.get_top_selected());\n                } else {\n                  inst.cut(obj);\n                }\n              }\n            },\n            \"copy\": {\n              \"separator_before\": false,\n              \"icon\": false,\n              \"separator_after\": false,\n              \"label\": \"Copy\",\n              \"action\": function action(data) {\n                var inst = $.jstree.reference(data.reference),\n                    obj = inst.get_node(data.reference);\n\n                if (inst.is_selected(obj)) {\n                  inst.copy(inst.get_top_selected());\n                } else {\n                  inst.copy(obj);\n                }\n              }\n            },\n            \"paste\": {\n              \"separator_before\": false,\n              \"icon\": false,\n              \"_disabled\": function _disabled(data) {\n                return !$.jstree.reference(data.reference).can_paste();\n              },\n              \"separator_after\": false,\n              \"label\": \"Paste\",\n              \"action\": function action(data) {\n                var inst = $.jstree.reference(data.reference),\n                    obj = inst.get_node(data.reference);\n                inst.paste(obj);\n              }\n            }\n          }\n        }\n      };\n    }\n  };\n\n  $.jstree.plugins.contextmenu = function (options, parent) {\n    this.bind = function () {\n      parent.bind.call(this);\n      var last_ts = 0,\n          cto = null,\n          ex,\n          ey;\n      this.element.on(\"contextmenu.jstree\", \".jstree-anchor\", $.proxy(function (e, data) {\n        if (e.target.tagName.toLowerCase() === 'input') {\n          return;\n        }\n\n        e.preventDefault();\n        last_ts = e.ctrlKey ? +new Date() : 0;\n\n        if (data || cto) {\n          last_ts = +new Date() + 10000;\n        }\n\n        if (cto) {\n          clearTimeout(cto);\n        }\n\n        if (!this.is_loading(e.currentTarget)) {\n          this.show_contextmenu(e.currentTarget, e.pageX, e.pageY, e);\n        }\n      }, this)).on(\"click.jstree\", \".jstree-anchor\", $.proxy(function (e) {\n        if (this._data.contextmenu.visible && (!last_ts || +new Date() - last_ts > 250)) {\n          // work around safari & macOS ctrl+click\n          $.vakata.context.hide();\n        }\n\n        last_ts = 0;\n      }, this)).on(\"touchstart.jstree\", \".jstree-anchor\", function (e) {\n        if (!e.originalEvent || !e.originalEvent.changedTouches || !e.originalEvent.changedTouches[0]) {\n          return;\n        }\n\n        ex = e.originalEvent.changedTouches[0].clientX;\n        ey = e.originalEvent.changedTouches[0].clientY;\n        cto = setTimeout(function () {\n          $(e.currentTarget).trigger('contextmenu', true);\n        }, 750);\n      }).on('touchmove.vakata.jstree', function (e) {\n        if (cto && e.originalEvent && e.originalEvent.changedTouches && e.originalEvent.changedTouches[0] && (Math.abs(ex - e.originalEvent.changedTouches[0].clientX) > 50 || Math.abs(ey - e.originalEvent.changedTouches[0].clientY) > 50)) {\n          clearTimeout(cto);\n        }\n      }).on('touchend.vakata.jstree', function (e) {\n        if (cto) {\n          clearTimeout(cto);\n        }\n      });\n      /*!\n      if(!('oncontextmenu' in document.body) && ('ontouchstart' in document.body)) {\n      \tvar el = null, tm = null;\n      \tthis.element\n      \t\t.on(\"touchstart\", \".jstree-anchor\", function (e) {\n      \t\t\tel = e.currentTarget;\n      \t\t\ttm = +new Date();\n      \t\t\t$(document).one(\"touchend\", function (e) {\n      \t\t\t\te.target = document.elementFromPoint(e.originalEvent.targetTouches[0].pageX - window.pageXOffset, e.originalEvent.targetTouches[0].pageY - window.pageYOffset);\n      \t\t\t\te.currentTarget = e.target;\n      \t\t\t\ttm = ((+(new Date())) - tm);\n      \t\t\t\tif(e.target === el && tm > 600 && tm < 1000) {\n      \t\t\t\t\te.preventDefault();\n      \t\t\t\t\t$(el).trigger('contextmenu', e);\n      \t\t\t\t}\n      \t\t\t\tel = null;\n      \t\t\t\ttm = null;\n      \t\t\t});\n      \t\t});\n      }\n      */\n\n      $(document).on(\"context_hide.vakata.jstree\", $.proxy(function (e, data) {\n        this._data.contextmenu.visible = false;\n        $(data.reference).removeClass('jstree-context');\n      }, this));\n    };\n\n    this.teardown = function () {\n      if (this._data.contextmenu.visible) {\n        $.vakata.context.hide();\n      }\n\n      parent.teardown.call(this);\n    };\n    /**\n     * prepare and show the context menu for a node\n     * @name show_contextmenu(obj [, x, y])\n     * @param {mixed} obj the node\n     * @param {Number} x the x-coordinate relative to the document to show the menu at\n     * @param {Number} y the y-coordinate relative to the document to show the menu at\n     * @param {Object} e the event if available that triggered the contextmenu\n     * @plugin contextmenu\n     * @trigger show_contextmenu.jstree\n     */\n\n\n    this.show_contextmenu = function (obj, x, y, e) {\n      obj = this.get_node(obj);\n\n      if (!obj || obj.id === $.jstree.root) {\n        return false;\n      }\n\n      var s = this.settings.contextmenu,\n          d = this.get_node(obj, true),\n          a = d.children(\".jstree-anchor\"),\n          o = false,\n          i = false;\n\n      if (s.show_at_node || x === undefined || y === undefined) {\n        o = a.offset();\n        x = o.left;\n        y = o.top + this._data.core.li_height;\n      }\n\n      if (this.settings.contextmenu.select_node && !this.is_selected(obj)) {\n        this.activate_node(obj, e);\n      }\n\n      i = s.items;\n\n      if ($.isFunction(i)) {\n        i = i.call(this, obj, $.proxy(function (i) {\n          this._show_contextmenu(obj, x, y, i);\n        }, this));\n      }\n\n      if ($.isPlainObject(i)) {\n        this._show_contextmenu(obj, x, y, i);\n      }\n    };\n    /**\n     * show the prepared context menu for a node\n     * @name _show_contextmenu(obj, x, y, i)\n     * @param {mixed} obj the node\n     * @param {Number} x the x-coordinate relative to the document to show the menu at\n     * @param {Number} y the y-coordinate relative to the document to show the menu at\n     * @param {Number} i the object of items to show\n     * @plugin contextmenu\n     * @trigger show_contextmenu.jstree\n     * @private\n     */\n\n\n    this._show_contextmenu = function (obj, x, y, i) {\n      var d = this.get_node(obj, true),\n          a = d.children(\".jstree-anchor\");\n      $(document).one(\"context_show.vakata.jstree\", $.proxy(function (e, data) {\n        var cls = 'jstree-contextmenu jstree-' + this.get_theme() + '-contextmenu';\n        $(data.element).addClass(cls);\n        a.addClass('jstree-context');\n      }, this));\n      this._data.contextmenu.visible = true;\n      $.vakata.context.show(a, {\n        'x': x,\n        'y': y\n      }, i);\n      /**\n       * triggered when the contextmenu is shown for a node\n       * @event\n       * @name show_contextmenu.jstree\n       * @param {Object} node the node\n       * @param {Number} x the x-coordinate of the menu relative to the document\n       * @param {Number} y the y-coordinate of the menu relative to the document\n       * @plugin contextmenu\n       */\n\n      this.trigger('show_contextmenu', {\n        \"node\": obj,\n        \"x\": x,\n        \"y\": y\n      });\n    };\n  }; // contextmenu helper\n\n\n  (function ($) {\n    var right_to_left = false,\n        vakata_context = {\n      element: false,\n      reference: false,\n      position_x: 0,\n      position_y: 0,\n      items: [],\n      html: \"\",\n      is_visible: false\n    };\n    $.vakata.context = {\n      settings: {\n        hide_onmouseleave: 0,\n        icons: true\n      },\n      _trigger: function _trigger(event_name) {\n        $(document).triggerHandler(\"context_\" + event_name + \".vakata\", {\n          \"reference\": vakata_context.reference,\n          \"element\": vakata_context.element,\n          \"position\": {\n            \"x\": vakata_context.position_x,\n            \"y\": vakata_context.position_y\n          }\n        });\n      },\n      _execute: function _execute(i) {\n        i = vakata_context.items[i];\n        return i && (!i._disabled || $.isFunction(i._disabled) && !i._disabled({\n          \"item\": i,\n          \"reference\": vakata_context.reference,\n          \"element\": vakata_context.element\n        })) && i.action ? i.action.call(null, {\n          \"item\": i,\n          \"reference\": vakata_context.reference,\n          \"element\": vakata_context.element,\n          \"position\": {\n            \"x\": vakata_context.position_x,\n            \"y\": vakata_context.position_y\n          }\n        }) : false;\n      },\n      _parse: function _parse(o, is_callback) {\n        if (!o) {\n          return false;\n        }\n\n        if (!is_callback) {\n          vakata_context.html = \"\";\n          vakata_context.items = [];\n        }\n\n        var str = \"\",\n            sep = false,\n            tmp;\n\n        if (is_callback) {\n          str += \"<\" + \"ul>\";\n        }\n\n        $.each(o, function (i, val) {\n          if (!val) {\n            return true;\n          }\n\n          vakata_context.items.push(val);\n\n          if (!sep && val.separator_before) {\n            str += \"<\" + \"li class='vakata-context-separator'><\" + \"a href='#' \" + ($.vakata.context.settings.icons ? '' : 'style=\"margin-left:0px;\"') + \">&#160;<\" + \"/a><\" + \"/li>\";\n          }\n\n          sep = false;\n          str += \"<\" + \"li class='\" + (val._class || \"\") + (val._disabled === true || $.isFunction(val._disabled) && val._disabled({\n            \"item\": val,\n            \"reference\": vakata_context.reference,\n            \"element\": vakata_context.element\n          }) ? \" vakata-contextmenu-disabled \" : \"\") + \"' \" + (val.shortcut ? \" data-shortcut='\" + val.shortcut + \"' \" : '') + \">\";\n          str += \"<\" + \"a href='#' rel='\" + (vakata_context.items.length - 1) + \"' \" + (val.title ? \"title='\" + val.title + \"'\" : \"\") + \">\";\n\n          if ($.vakata.context.settings.icons) {\n            str += \"<\" + \"i \";\n\n            if (val.icon) {\n              if (val.icon.indexOf(\"/\") !== -1 || val.icon.indexOf(\".\") !== -1) {\n                str += \" style='background:url(\\\"\" + val.icon + \"\\\") center center no-repeat' \";\n              } else {\n                str += \" class='\" + val.icon + \"' \";\n              }\n            }\n\n            str += \"><\" + \"/i><\" + \"span class='vakata-contextmenu-sep'>&#160;<\" + \"/span>\";\n          }\n\n          str += ($.isFunction(val.label) ? val.label({\n            \"item\": i,\n            \"reference\": vakata_context.reference,\n            \"element\": vakata_context.element\n          }) : val.label) + (val.shortcut ? ' <span class=\"vakata-contextmenu-shortcut vakata-contextmenu-shortcut-' + val.shortcut + '\">' + (val.shortcut_label || '') + '</span>' : '') + \"<\" + \"/a>\";\n\n          if (val.submenu) {\n            tmp = $.vakata.context._parse(val.submenu, true);\n\n            if (tmp) {\n              str += tmp;\n            }\n          }\n\n          str += \"<\" + \"/li>\";\n\n          if (val.separator_after) {\n            str += \"<\" + \"li class='vakata-context-separator'><\" + \"a href='#' \" + ($.vakata.context.settings.icons ? '' : 'style=\"margin-left:0px;\"') + \">&#160;<\" + \"/a><\" + \"/li>\";\n            sep = true;\n          }\n        });\n        str = str.replace(/<li class\\='vakata-context-separator'\\><\\/li\\>$/, \"\");\n\n        if (is_callback) {\n          str += \"</ul>\";\n        }\n        /**\n         * triggered on the document when the contextmenu is parsed (HTML is built)\n         * @event\n         * @plugin contextmenu\n         * @name context_parse.vakata\n         * @param {jQuery} reference the element that was right clicked\n         * @param {jQuery} element the DOM element of the menu itself\n         * @param {Object} position the x & y coordinates of the menu\n         */\n\n\n        if (!is_callback) {\n          vakata_context.html = str;\n\n          $.vakata.context._trigger(\"parse\");\n        }\n\n        return str.length > 10 ? str : false;\n      },\n      _show_submenu: function _show_submenu(o) {\n        o = $(o);\n\n        if (!o.length || !o.children(\"ul\").length) {\n          return;\n        }\n\n        var e = o.children(\"ul\"),\n            xl = o.offset().left,\n            x = xl + o.outerWidth(),\n            y = o.offset().top,\n            w = e.width(),\n            h = e.height(),\n            dw = $(window).width() + $(window).scrollLeft(),\n            dh = $(window).height() + $(window).scrollTop(); //        -       \n\n        if (right_to_left) {\n          o[x - (w + 10 + o.outerWidth()) < 0 ? \"addClass\" : \"removeClass\"](\"vakata-context-left\");\n        } else {\n          o[x + w > dw && xl > dw - x ? \"addClass\" : \"removeClass\"](\"vakata-context-right\");\n        }\n\n        if (y + h + 10 > dh) {\n          e.css(\"bottom\", \"-1px\");\n        } //if does not fit - stick it to the side\n\n\n        if (o.hasClass('vakata-context-right')) {\n          if (xl < w) {\n            e.css(\"margin-right\", xl - w);\n          }\n        } else {\n          if (dw - x < w) {\n            e.css(\"margin-left\", dw - x - w);\n          }\n        }\n\n        e.show();\n      },\n      show: function show(reference, position, data) {\n        var o,\n            e,\n            x,\n            y,\n            w,\n            h,\n            dw,\n            dh,\n            cond = true;\n\n        if (vakata_context.element && vakata_context.element.length) {\n          vakata_context.element.width('');\n        }\n\n        switch (cond) {\n          case !position && !reference:\n            return false;\n\n          case !!position && !!reference:\n            vakata_context.reference = reference;\n            vakata_context.position_x = position.x;\n            vakata_context.position_y = position.y;\n            break;\n\n          case !position && !!reference:\n            vakata_context.reference = reference;\n            o = reference.offset();\n            vakata_context.position_x = o.left + reference.outerHeight();\n            vakata_context.position_y = o.top;\n            break;\n\n          case !!position && !reference:\n            vakata_context.position_x = position.x;\n            vakata_context.position_y = position.y;\n            break;\n        }\n\n        if (!!reference && !data && $(reference).data('vakata_contextmenu')) {\n          data = $(reference).data('vakata_contextmenu');\n        }\n\n        if ($.vakata.context._parse(data)) {\n          vakata_context.element.html(vakata_context.html);\n        }\n\n        if (vakata_context.items.length) {\n          vakata_context.element.appendTo(\"body\");\n          e = vakata_context.element;\n          x = vakata_context.position_x;\n          y = vakata_context.position_y;\n          w = e.width();\n          h = e.height();\n          dw = $(window).width() + $(window).scrollLeft();\n          dh = $(window).height() + $(window).scrollTop();\n\n          if (right_to_left) {\n            x -= e.outerWidth() - $(reference).outerWidth();\n\n            if (x < $(window).scrollLeft() + 20) {\n              x = $(window).scrollLeft() + 20;\n            }\n          }\n\n          if (x + w + 20 > dw) {\n            x = dw - (w + 20);\n          }\n\n          if (y + h + 20 > dh) {\n            y = dh - (h + 20);\n          }\n\n          vakata_context.element.css({\n            \"left\": x,\n            \"top\": y\n          }).show().find('a').first().focus().parent().addClass(\"vakata-context-hover\");\n          vakata_context.is_visible = true;\n          /**\n           * triggered on the document when the contextmenu is shown\n           * @event\n           * @plugin contextmenu\n           * @name context_show.vakata\n           * @param {jQuery} reference the element that was right clicked\n           * @param {jQuery} element the DOM element of the menu itself\n           * @param {Object} position the x & y coordinates of the menu\n           */\n\n          $.vakata.context._trigger(\"show\");\n        }\n      },\n      hide: function hide() {\n        if (vakata_context.is_visible) {\n          vakata_context.element.hide().find(\"ul\").hide().end().find(':focus').blur().end().detach();\n          vakata_context.is_visible = false;\n          /**\n           * triggered on the document when the contextmenu is hidden\n           * @event\n           * @plugin contextmenu\n           * @name context_hide.vakata\n           * @param {jQuery} reference the element that was right clicked\n           * @param {jQuery} element the DOM element of the menu itself\n           * @param {Object} position the x & y coordinates of the menu\n           */\n\n          $.vakata.context._trigger(\"hide\");\n        }\n      }\n    };\n    $(function () {\n      right_to_left = $(\"body\").css(\"direction\") === \"rtl\";\n      var to = false;\n      vakata_context.element = $(\"<ul class='vakata-context'></ul>\");\n      vakata_context.element.on(\"mouseenter\", \"li\", function (e) {\n        e.stopImmediatePropagation();\n\n        if ($.contains(this, e.relatedTarget)) {\n          //   delegate mouseleave -\n          // $(this).find(\".vakata-context-hover\").removeClass(\"vakata-context-hover\");\n          return;\n        }\n\n        if (to) {\n          clearTimeout(to);\n        }\n\n        vakata_context.element.find(\".vakata-context-hover\").removeClass(\"vakata-context-hover\").end();\n        $(this).siblings().find(\"ul\").hide().end().end().parentsUntil(\".vakata-context\", \"li\").addBack().addClass(\"vakata-context-hover\");\n\n        $.vakata.context._show_submenu(this);\n      }) //  -   ?\n      .on(\"mouseleave\", \"li\", function (e) {\n        if ($.contains(this, e.relatedTarget)) {\n          return;\n        }\n\n        $(this).find(\".vakata-context-hover\").addBack().removeClass(\"vakata-context-hover\");\n      }).on(\"mouseleave\", function (e) {\n        $(this).find(\".vakata-context-hover\").removeClass(\"vakata-context-hover\");\n\n        if ($.vakata.context.settings.hide_onmouseleave) {\n          to = setTimeout(function (t) {\n            return function () {\n              $.vakata.context.hide();\n            };\n          }(this), $.vakata.context.settings.hide_onmouseleave);\n        }\n      }).on(\"click\", \"a\", function (e) {\n        e.preventDefault(); //})\n        //.on(\"mouseup\", \"a\", function (e) {\n\n        if (!$(this).blur().parent().hasClass(\"vakata-context-disabled\") && $.vakata.context._execute($(this).attr(\"rel\")) !== false) {\n          $.vakata.context.hide();\n        }\n      }).on('keydown', 'a', function (e) {\n        var o = null;\n\n        switch (e.which) {\n          case 13:\n          case 32:\n            e.type = \"click\";\n            e.preventDefault();\n            $(e.currentTarget).trigger(e);\n            break;\n\n          case 37:\n            if (vakata_context.is_visible) {\n              vakata_context.element.find(\".vakata-context-hover\").last().closest(\"li\").first().find(\"ul\").hide().find(\".vakata-context-hover\").removeClass(\"vakata-context-hover\").end().end().children('a').focus();\n              e.stopImmediatePropagation();\n              e.preventDefault();\n            }\n\n            break;\n\n          case 38:\n            if (vakata_context.is_visible) {\n              o = vakata_context.element.find(\"ul:visible\").addBack().last().children(\".vakata-context-hover\").removeClass(\"vakata-context-hover\").prevAll(\"li:not(.vakata-context-separator)\").first();\n\n              if (!o.length) {\n                o = vakata_context.element.find(\"ul:visible\").addBack().last().children(\"li:not(.vakata-context-separator)\").last();\n              }\n\n              o.addClass(\"vakata-context-hover\").children('a').focus();\n              e.stopImmediatePropagation();\n              e.preventDefault();\n            }\n\n            break;\n\n          case 39:\n            if (vakata_context.is_visible) {\n              vakata_context.element.find(\".vakata-context-hover\").last().children(\"ul\").show().children(\"li:not(.vakata-context-separator)\").removeClass(\"vakata-context-hover\").first().addClass(\"vakata-context-hover\").children('a').focus();\n              e.stopImmediatePropagation();\n              e.preventDefault();\n            }\n\n            break;\n\n          case 40:\n            if (vakata_context.is_visible) {\n              o = vakata_context.element.find(\"ul:visible\").addBack().last().children(\".vakata-context-hover\").removeClass(\"vakata-context-hover\").nextAll(\"li:not(.vakata-context-separator)\").first();\n\n              if (!o.length) {\n                o = vakata_context.element.find(\"ul:visible\").addBack().last().children(\"li:not(.vakata-context-separator)\").first();\n              }\n\n              o.addClass(\"vakata-context-hover\").children('a').focus();\n              e.stopImmediatePropagation();\n              e.preventDefault();\n            }\n\n            break;\n\n          case 27:\n            $.vakata.context.hide();\n            e.preventDefault();\n            break;\n\n          default:\n            //console.log(e.which);\n            break;\n        }\n      }).on('keydown', function (e) {\n        e.preventDefault();\n        var a = vakata_context.element.find('.vakata-contextmenu-shortcut-' + e.which).parent();\n\n        if (a.parent().not('.vakata-context-disabled')) {\n          a.click();\n        }\n      });\n      $(document).on(\"mousedown.vakata.jstree\", function (e) {\n        if (vakata_context.is_visible && !$.contains(vakata_context.element[0], e.target)) {\n          $.vakata.context.hide();\n        }\n      }).on(\"context_show.vakata.jstree\", function (e, data) {\n        vakata_context.element.find(\"li:has(ul)\").children(\"a\").addClass(\"vakata-context-parent\");\n\n        if (right_to_left) {\n          vakata_context.element.addClass(\"vakata-context-rtl\").css(\"direction\", \"rtl\");\n        } // also apply a RTL class?\n\n\n        vakata_context.element.find(\"ul\").hide().end();\n      });\n    });\n  })($); // $.jstree.defaults.plugins.push(\"contextmenu\");\n\n  /**\n   * ### Drag'n'drop plugin\n   *\n   * Enables dragging and dropping of nodes in the tree, resulting in a move or copy operations.\n   */\n\n  /**\n   * stores all defaults for the drag'n'drop plugin\n   * @name $.jstree.defaults.dnd\n   * @plugin dnd\n   */\n\n\n  $.jstree.defaults.dnd = {\n    /**\n     * a boolean indicating if a copy should be possible while dragging (by pressint the meta key or Ctrl). Defaults to `true`.\n     * @name $.jstree.defaults.dnd.copy\n     * @plugin dnd\n     */\n    copy: true,\n\n    /**\n     * a number indicating how long a node should remain hovered while dragging to be opened. Defaults to `500`.\n     * @name $.jstree.defaults.dnd.open_timeout\n     * @plugin dnd\n     */\n    open_timeout: 500,\n\n    /**\n     * a function invoked each time a node is about to be dragged, invoked in the tree's scope and receives the nodes about to be dragged as an argument (array) and the event that started the drag - return `false` to prevent dragging\n     * @name $.jstree.defaults.dnd.is_draggable\n     * @plugin dnd\n     */\n    is_draggable: true,\n\n    /**\n     * a boolean indicating if checks should constantly be made while the user is dragging the node (as opposed to checking only on drop), default is `true`\n     * @name $.jstree.defaults.dnd.check_while_dragging\n     * @plugin dnd\n     */\n    check_while_dragging: true,\n\n    /**\n     * a boolean indicating if nodes from this tree should only be copied with dnd (as opposed to moved), default is `false`\n     * @name $.jstree.defaults.dnd.always_copy\n     * @plugin dnd\n     */\n    always_copy: false,\n\n    /**\n     * when dropping a node \"inside\", this setting indicates the position the node should go to - it can be an integer or a string: \"first\" (same as 0) or \"last\", default is `0`\n     * @name $.jstree.defaults.dnd.inside_pos\n     * @plugin dnd\n     */\n    inside_pos: 0,\n\n    /**\n     * when starting the drag on a node that is selected this setting controls if all selected nodes are dragged or only the single node, default is `true`, which means all selected nodes are dragged when the drag is started on a selected node\n     * @name $.jstree.defaults.dnd.drag_selection\n     * @plugin dnd\n     */\n    drag_selection: true,\n\n    /**\n     * controls whether dnd works on touch devices. If left as boolean true dnd will work the same as in desktop browsers, which in some cases may impair scrolling. If set to boolean false dnd will not work on touch devices. There is a special third option - string \"selected\" which means only selected nodes can be dragged on touch devices.\n     * @name $.jstree.defaults.dnd.touch\n     * @plugin dnd\n     */\n    touch: true,\n\n    /**\n     * controls whether items can be dropped anywhere on the node, not just on the anchor, by default only the node anchor is a valid drop target. Works best with the wholerow plugin. If enabled on mobile depending on the interface it might be hard for the user to cancel the drop, since the whole tree container will be a valid drop target.\n     * @name $.jstree.defaults.dnd.large_drop_target\n     * @plugin dnd\n     */\n    large_drop_target: false,\n\n    /**\n     * controls whether a drag can be initiated from any part of the node and not just the text/icon part, works best with the wholerow plugin. Keep in mind it can cause problems with tree scrolling on mobile depending on the interface - in that case set the touch option to \"selected\".\n     * @name $.jstree.defaults.dnd.large_drag_target\n     * @plugin dnd\n     */\n    large_drag_target: false,\n\n    /**\n     * controls whether use HTML5 dnd api instead of classical. That will allow better integration of dnd events with other HTML5 controls.\n     * @reference http://caniuse.com/#feat=dragndrop\n     * @name $.jstree.defaults.dnd.use_html5\n     * @plugin dnd\n     */\n    use_html5: false\n  };\n  var drg, elm; // TODO: now check works by checking for each node individually, how about max_children, unique, etc?\n\n  $.jstree.plugins.dnd = function (options, parent) {\n    this.init = function (el, options) {\n      parent.init.call(this, el, options);\n      this.settings.dnd.use_html5 = this.settings.dnd.use_html5 && 'draggable' in document.createElement('span');\n    };\n\n    this.bind = function () {\n      parent.bind.call(this);\n      this.element.on(this.settings.dnd.use_html5 ? 'dragstart.jstree' : 'mousedown.jstree touchstart.jstree', this.settings.dnd.large_drag_target ? '.jstree-node' : '.jstree-anchor', $.proxy(function (e) {\n        if (this.settings.dnd.large_drag_target && $(e.target).closest('.jstree-node')[0] !== e.currentTarget) {\n          return true;\n        }\n\n        if (e.type === \"touchstart\" && (!this.settings.dnd.touch || this.settings.dnd.touch === 'selected' && !$(e.currentTarget).closest('.jstree-node').children('.jstree-anchor').hasClass('jstree-clicked'))) {\n          return true;\n        }\n\n        var obj = this.get_node(e.target),\n            mlt = this.is_selected(obj) && this.settings.dnd.drag_selection ? this.get_top_selected().length : 1,\n            txt = mlt > 1 ? mlt + ' ' + this.get_string('nodes') : this.get_text(e.currentTarget);\n\n        if (this.settings.core.force_text) {\n          txt = $.vakata.html.escape(txt);\n        }\n\n        if (obj && obj.id && obj.id !== $.jstree.root && (e.which === 1 || e.type === \"touchstart\" || e.type === \"dragstart\") && (this.settings.dnd.is_draggable === true || $.isFunction(this.settings.dnd.is_draggable) && this.settings.dnd.is_draggable.call(this, mlt > 1 ? this.get_top_selected(true) : [obj], e))) {\n          drg = {\n            'jstree': true,\n            'origin': this,\n            'obj': this.get_node(obj, true),\n            'nodes': mlt > 1 ? this.get_top_selected() : [obj.id]\n          };\n          elm = e.currentTarget;\n\n          if (this.settings.dnd.use_html5) {\n            $.vakata.dnd._trigger('start', e, {\n              'helper': $(),\n              'element': elm,\n              'data': drg\n            });\n          } else {\n            this.element.trigger('mousedown.jstree');\n            return $.vakata.dnd.start(e, drg, '<div id=\"jstree-dnd\" class=\"jstree-' + this.get_theme() + ' jstree-' + this.get_theme() + '-' + this.get_theme_variant() + ' ' + (this.settings.core.themes.responsive ? ' jstree-dnd-responsive' : '') + '\"><i class=\"jstree-icon jstree-er\"></i>' + txt + '<ins class=\"jstree-copy\" style=\"display:none;\">+</ins></div>');\n          }\n        }\n      }, this));\n\n      if (this.settings.dnd.use_html5) {\n        this.element.on('dragover.jstree', function (e) {\n          e.preventDefault();\n\n          $.vakata.dnd._trigger('move', e, {\n            'helper': $(),\n            'element': elm,\n            'data': drg\n          });\n\n          return false;\n        }) //.on('dragenter.jstree', this.settings.dnd.large_drop_target ? '.jstree-node' : '.jstree-anchor', $.proxy(function (e) {\n        //\t\te.preventDefault();\n        //\t\t$.vakata.dnd._trigger('move', e, { 'helper': $(), 'element': elm, 'data': drg });\n        //\t\treturn false;\n        //\t}, this))\n        .on('drop.jstree', $.proxy(function (e) {\n          e.preventDefault();\n\n          $.vakata.dnd._trigger('stop', e, {\n            'helper': $(),\n            'element': elm,\n            'data': drg\n          });\n\n          return false;\n        }, this));\n      }\n    };\n\n    this.redraw_node = function (obj, deep, callback, force_render) {\n      obj = parent.redraw_node.apply(this, arguments);\n\n      if (obj && this.settings.dnd.use_html5) {\n        if (this.settings.dnd.large_drag_target) {\n          obj.setAttribute('draggable', true);\n        } else {\n          var i,\n              j,\n              tmp = null;\n\n          for (i = 0, j = obj.childNodes.length; i < j; i++) {\n            if (obj.childNodes[i] && obj.childNodes[i].className && obj.childNodes[i].className.indexOf(\"jstree-anchor\") !== -1) {\n              tmp = obj.childNodes[i];\n              break;\n            }\n          }\n\n          if (tmp) {\n            tmp.setAttribute('draggable', true);\n          }\n        }\n      }\n\n      return obj;\n    };\n  };\n\n  $(function () {\n    // bind only once for all instances\n    var lastmv = false,\n        laster = false,\n        lastev = false,\n        opento = false,\n        marker = $('<div id=\"jstree-marker\">&#160;</div>').hide(); //.appendTo('body');\n\n    $(document).on('dnd_start.vakata.jstree', function (e, data) {\n      lastmv = false;\n      lastev = false;\n\n      if (!data || !data.data || !data.data.jstree) {\n        return;\n      }\n\n      marker.appendTo('body'); //.show();\n    }).on('dnd_move.vakata.jstree', function (e, data) {\n      if (opento) {\n        if (!data.event || data.event.type !== 'dragover' || data.event.target !== lastev.target) {\n          clearTimeout(opento);\n        }\n      }\n\n      if (!data || !data.data || !data.data.jstree) {\n        return;\n      } // if we are hovering the marker image do nothing (can happen on \"inside\" drags)\n\n\n      if (data.event.target.id && data.event.target.id === 'jstree-marker') {\n        return;\n      }\n\n      lastev = data.event;\n      var ins = $.jstree.reference(data.event.target),\n          ref = false,\n          off = false,\n          rel = false,\n          tmp,\n          l,\n          t,\n          h,\n          p,\n          i,\n          o,\n          ok,\n          t1,\n          t2,\n          op,\n          ps,\n          pr,\n          ip,\n          tm,\n          is_copy,\n          pn; // if we are over an instance\n\n      if (ins && ins._data && ins._data.dnd) {\n        marker.attr('class', 'jstree-' + ins.get_theme() + (ins.settings.core.themes.responsive ? ' jstree-dnd-responsive' : ''));\n        is_copy = data.data.origin && (data.data.origin.settings.dnd.always_copy || data.data.origin.settings.dnd.copy && (data.event.metaKey || data.event.ctrlKey));\n        data.helper.children().attr('class', 'jstree-' + ins.get_theme() + ' jstree-' + ins.get_theme() + '-' + ins.get_theme_variant() + ' ' + (ins.settings.core.themes.responsive ? ' jstree-dnd-responsive' : '')).find('.jstree-copy').first()[is_copy ? 'show' : 'hide'](); // if are hovering the container itself add a new root node\n        //console.log(data.event);\n\n        if ((data.event.target === ins.element[0] || data.event.target === ins.get_container_ul()[0]) && ins.get_container_ul().children().length === 0) {\n          ok = true;\n\n          for (t1 = 0, t2 = data.data.nodes.length; t1 < t2; t1++) {\n            ok = ok && ins.check(data.data.origin && (data.data.origin.settings.dnd.always_copy || data.data.origin.settings.dnd.copy && (data.event.metaKey || data.event.ctrlKey)) ? \"copy_node\" : \"move_node\", data.data.origin && data.data.origin !== ins ? data.data.origin.get_node(data.data.nodes[t1]) : data.data.nodes[t1], $.jstree.root, 'last', {\n              'dnd': true,\n              'ref': ins.get_node($.jstree.root),\n              'pos': 'i',\n              'origin': data.data.origin,\n              'is_multi': data.data.origin && data.data.origin !== ins,\n              'is_foreign': !data.data.origin\n            });\n\n            if (!ok) {\n              break;\n            }\n          }\n\n          if (ok) {\n            lastmv = {\n              'ins': ins,\n              'par': $.jstree.root,\n              'pos': 'last'\n            };\n            marker.hide();\n            data.helper.find('.jstree-icon').first().removeClass('jstree-er').addClass('jstree-ok');\n\n            if (data.event.originalEvent && data.event.originalEvent.dataTransfer) {\n              data.event.originalEvent.dataTransfer.dropEffect = is_copy ? 'copy' : 'move';\n            }\n\n            return;\n          }\n        } else {\n          // if we are hovering a tree node\n          ref = ins.settings.dnd.large_drop_target ? $(data.event.target).closest('.jstree-node').children('.jstree-anchor') : $(data.event.target).closest('.jstree-anchor');\n\n          if (ref && ref.length && ref.parent().is('.jstree-closed, .jstree-open, .jstree-leaf')) {\n            off = ref.offset();\n            rel = (data.event.pageY !== undefined ? data.event.pageY : data.event.originalEvent.pageY) - off.top;\n            h = ref.outerHeight();\n\n            if (rel < h / 3) {\n              o = ['b', 'i', 'a'];\n            } else if (rel > h - h / 3) {\n              o = ['a', 'i', 'b'];\n            } else {\n              o = rel > h / 2 ? ['i', 'a', 'b'] : ['i', 'b', 'a'];\n            }\n\n            $.each(o, function (j, v) {\n              switch (v) {\n                case 'b':\n                  l = off.left - 6;\n                  t = off.top;\n                  p = ins.get_parent(ref);\n                  i = ref.parent().index();\n                  break;\n\n                case 'i':\n                  ip = ins.settings.dnd.inside_pos;\n                  tm = ins.get_node(ref.parent());\n                  l = off.left - 2;\n                  t = off.top + h / 2 + 1;\n                  p = tm.id;\n                  i = ip === 'first' ? 0 : ip === 'last' ? tm.children.length : Math.min(ip, tm.children.length);\n                  break;\n\n                case 'a':\n                  l = off.left - 6;\n                  t = off.top + h;\n                  p = ins.get_parent(ref);\n                  i = ref.parent().index() + 1;\n                  break;\n              }\n\n              ok = true;\n\n              for (t1 = 0, t2 = data.data.nodes.length; t1 < t2; t1++) {\n                op = data.data.origin && (data.data.origin.settings.dnd.always_copy || data.data.origin.settings.dnd.copy && (data.event.metaKey || data.event.ctrlKey)) ? \"copy_node\" : \"move_node\";\n                ps = i;\n\n                if (op === \"move_node\" && v === 'a' && data.data.origin && data.data.origin === ins && p === ins.get_parent(data.data.nodes[t1])) {\n                  pr = ins.get_node(p);\n\n                  if (ps > $.inArray(data.data.nodes[t1], pr.children)) {\n                    ps -= 1;\n                  }\n                }\n\n                ok = ok && (ins && ins.settings && ins.settings.dnd && ins.settings.dnd.check_while_dragging === false || ins.check(op, data.data.origin && data.data.origin !== ins ? data.data.origin.get_node(data.data.nodes[t1]) : data.data.nodes[t1], p, ps, {\n                  'dnd': true,\n                  'ref': ins.get_node(ref.parent()),\n                  'pos': v,\n                  'origin': data.data.origin,\n                  'is_multi': data.data.origin && data.data.origin !== ins,\n                  'is_foreign': !data.data.origin\n                }));\n\n                if (!ok) {\n                  if (ins && ins.last_error) {\n                    laster = ins.last_error();\n                  }\n\n                  break;\n                }\n              }\n\n              if (v === 'i' && ref.parent().is('.jstree-closed') && ins.settings.dnd.open_timeout) {\n                opento = setTimeout(function (x, z) {\n                  return function () {\n                    x.open_node(z);\n                  };\n                }(ins, ref), ins.settings.dnd.open_timeout);\n              }\n\n              if (ok) {\n                pn = ins.get_node(p, true);\n\n                if (!pn.hasClass('.jstree-dnd-parent')) {\n                  $('.jstree-dnd-parent').removeClass('jstree-dnd-parent');\n                  pn.addClass('jstree-dnd-parent');\n                }\n\n                lastmv = {\n                  'ins': ins,\n                  'par': p,\n                  'pos': v === 'i' && ip === 'last' && i === 0 && !ins.is_loaded(tm) ? 'last' : i\n                };\n                marker.css({\n                  'left': l + 'px',\n                  'top': t + 'px'\n                }).show();\n                data.helper.find('.jstree-icon').first().removeClass('jstree-er').addClass('jstree-ok');\n\n                if (data.event.originalEvent && data.event.originalEvent.dataTransfer) {\n                  data.event.originalEvent.dataTransfer.dropEffect = is_copy ? 'copy' : 'move';\n                }\n\n                laster = {};\n                o = true;\n                return false;\n              }\n            });\n\n            if (o === true) {\n              return;\n            }\n          }\n        }\n      }\n\n      $('.jstree-dnd-parent').removeClass('jstree-dnd-parent');\n      lastmv = false;\n      data.helper.find('.jstree-icon').removeClass('jstree-ok').addClass('jstree-er');\n\n      if (data.event.originalEvent && data.event.originalEvent.dataTransfer) {\n        data.event.originalEvent.dataTransfer.dropEffect = 'none';\n      }\n\n      marker.hide();\n    }).on('dnd_scroll.vakata.jstree', function (e, data) {\n      if (!data || !data.data || !data.data.jstree) {\n        return;\n      }\n\n      marker.hide();\n      lastmv = false;\n      lastev = false;\n      data.helper.find('.jstree-icon').first().removeClass('jstree-ok').addClass('jstree-er');\n    }).on('dnd_stop.vakata.jstree', function (e, data) {\n      $('.jstree-dnd-parent').removeClass('jstree-dnd-parent');\n\n      if (opento) {\n        clearTimeout(opento);\n      }\n\n      if (!data || !data.data || !data.data.jstree) {\n        return;\n      }\n\n      marker.hide().detach();\n      var i,\n          j,\n          nodes = [];\n\n      if (lastmv) {\n        for (i = 0, j = data.data.nodes.length; i < j; i++) {\n          nodes[i] = data.data.origin ? data.data.origin.get_node(data.data.nodes[i]) : data.data.nodes[i];\n        }\n\n        lastmv.ins[data.data.origin && (data.data.origin.settings.dnd.always_copy || data.data.origin.settings.dnd.copy && (data.event.metaKey || data.event.ctrlKey)) ? 'copy_node' : 'move_node'](nodes, lastmv.par, lastmv.pos, false, false, false, data.data.origin);\n      } else {\n        i = $(data.event.target).closest('.jstree');\n\n        if (i.length && laster && laster.error && laster.error === 'check') {\n          i = i.jstree(true);\n\n          if (i) {\n            i.settings.core.error.call(this, laster);\n          }\n        }\n      }\n\n      lastev = false;\n      lastmv = false;\n    }).on('keyup.jstree keydown.jstree', function (e, data) {\n      data = $.vakata.dnd._get();\n\n      if (data && data.data && data.data.jstree) {\n        if (e.type === \"keyup\" && e.which === 27) {\n          if (opento) {\n            clearTimeout(opento);\n          }\n\n          lastmv = false;\n          laster = false;\n          lastev = false;\n          opento = false;\n          marker.hide().detach();\n\n          $.vakata.dnd._clean();\n        } else {\n          data.helper.find('.jstree-copy').first()[data.data.origin && (data.data.origin.settings.dnd.always_copy || data.data.origin.settings.dnd.copy && (e.metaKey || e.ctrlKey)) ? 'show' : 'hide']();\n\n          if (lastev) {\n            lastev.metaKey = e.metaKey;\n            lastev.ctrlKey = e.ctrlKey;\n\n            $.vakata.dnd._trigger('move', lastev);\n          }\n        }\n      }\n    });\n  }); // helpers\n\n  (function ($) {\n    $.vakata.html = {\n      div: $('<div />'),\n      escape: function escape(str) {\n        return $.vakata.html.div.text(str).html();\n      },\n      strip: function strip(str) {\n        return $.vakata.html.div.empty().append($.parseHTML(str)).text();\n      }\n    }; // private variable\n\n    var vakata_dnd = {\n      element: false,\n      target: false,\n      is_down: false,\n      is_drag: false,\n      helper: false,\n      helper_w: 0,\n      data: false,\n      init_x: 0,\n      init_y: 0,\n      scroll_l: 0,\n      scroll_t: 0,\n      scroll_e: false,\n      scroll_i: false,\n      is_touch: false\n    };\n    $.vakata.dnd = {\n      settings: {\n        scroll_speed: 10,\n        scroll_proximity: 20,\n        helper_left: 5,\n        helper_top: 10,\n        threshold: 5,\n        threshold_touch: 50\n      },\n      _trigger: function _trigger(event_name, e, data) {\n        if (data === undefined) {\n          data = $.vakata.dnd._get();\n        }\n\n        data.event = e;\n        $(document).triggerHandler(\"dnd_\" + event_name + \".vakata\", data);\n      },\n      _get: function _get() {\n        return {\n          \"data\": vakata_dnd.data,\n          \"element\": vakata_dnd.element,\n          \"helper\": vakata_dnd.helper\n        };\n      },\n      _clean: function _clean() {\n        if (vakata_dnd.helper) {\n          vakata_dnd.helper.remove();\n        }\n\n        if (vakata_dnd.scroll_i) {\n          clearInterval(vakata_dnd.scroll_i);\n          vakata_dnd.scroll_i = false;\n        }\n\n        vakata_dnd = {\n          element: false,\n          target: false,\n          is_down: false,\n          is_drag: false,\n          helper: false,\n          helper_w: 0,\n          data: false,\n          init_x: 0,\n          init_y: 0,\n          scroll_l: 0,\n          scroll_t: 0,\n          scroll_e: false,\n          scroll_i: false,\n          is_touch: false\n        };\n        $(document).off(\"mousemove.vakata.jstree touchmove.vakata.jstree\", $.vakata.dnd.drag);\n        $(document).off(\"mouseup.vakata.jstree touchend.vakata.jstree\", $.vakata.dnd.stop);\n      },\n      _scroll: function _scroll(init_only) {\n        if (!vakata_dnd.scroll_e || !vakata_dnd.scroll_l && !vakata_dnd.scroll_t) {\n          if (vakata_dnd.scroll_i) {\n            clearInterval(vakata_dnd.scroll_i);\n            vakata_dnd.scroll_i = false;\n          }\n\n          return false;\n        }\n\n        if (!vakata_dnd.scroll_i) {\n          vakata_dnd.scroll_i = setInterval($.vakata.dnd._scroll, 100);\n          return false;\n        }\n\n        if (init_only === true) {\n          return false;\n        }\n\n        var i = vakata_dnd.scroll_e.scrollTop(),\n            j = vakata_dnd.scroll_e.scrollLeft();\n        vakata_dnd.scroll_e.scrollTop(i + vakata_dnd.scroll_t * $.vakata.dnd.settings.scroll_speed);\n        vakata_dnd.scroll_e.scrollLeft(j + vakata_dnd.scroll_l * $.vakata.dnd.settings.scroll_speed);\n\n        if (i !== vakata_dnd.scroll_e.scrollTop() || j !== vakata_dnd.scroll_e.scrollLeft()) {\n          /**\n           * triggered on the document when a drag causes an element to scroll\n           * @event\n           * @plugin dnd\n           * @name dnd_scroll.vakata\n           * @param {Mixed} data any data supplied with the call to $.vakata.dnd.start\n           * @param {DOM} element the DOM element being dragged\n           * @param {jQuery} helper the helper shown next to the mouse\n           * @param {jQuery} event the element that is scrolling\n           */\n          $.vakata.dnd._trigger(\"scroll\", vakata_dnd.scroll_e);\n        }\n      },\n      start: function start(e, data, html) {\n        if (e.type === \"touchstart\" && e.originalEvent && e.originalEvent.changedTouches && e.originalEvent.changedTouches[0]) {\n          e.pageX = e.originalEvent.changedTouches[0].pageX;\n          e.pageY = e.originalEvent.changedTouches[0].pageY;\n          e.target = document.elementFromPoint(e.originalEvent.changedTouches[0].pageX - window.pageXOffset, e.originalEvent.changedTouches[0].pageY - window.pageYOffset);\n        }\n\n        if (vakata_dnd.is_drag) {\n          $.vakata.dnd.stop({});\n        }\n\n        try {\n          e.currentTarget.unselectable = \"on\";\n\n          e.currentTarget.onselectstart = function () {\n            return false;\n          };\n\n          if (e.currentTarget.style) {\n            e.currentTarget.style.touchAction = \"none\";\n            e.currentTarget.style.msTouchAction = \"none\";\n            e.currentTarget.style.MozUserSelect = \"none\";\n          }\n        } catch (ignore) {}\n\n        vakata_dnd.init_x = e.pageX;\n        vakata_dnd.init_y = e.pageY;\n        vakata_dnd.data = data;\n        vakata_dnd.is_down = true;\n        vakata_dnd.element = e.currentTarget;\n        vakata_dnd.target = e.target;\n        vakata_dnd.is_touch = e.type === \"touchstart\";\n\n        if (html !== false) {\n          vakata_dnd.helper = $(\"<div id='vakata-dnd'></div>\").html(html).css({\n            \"display\": \"block\",\n            \"margin\": \"0\",\n            \"padding\": \"0\",\n            \"position\": \"absolute\",\n            \"top\": \"-2000px\",\n            \"lineHeight\": \"16px\",\n            \"zIndex\": \"10000\"\n          });\n        }\n\n        $(document).on(\"mousemove.vakata.jstree touchmove.vakata.jstree\", $.vakata.dnd.drag);\n        $(document).on(\"mouseup.vakata.jstree touchend.vakata.jstree\", $.vakata.dnd.stop);\n        return false;\n      },\n      drag: function drag(e) {\n        if (e.type === \"touchmove\" && e.originalEvent && e.originalEvent.changedTouches && e.originalEvent.changedTouches[0]) {\n          e.pageX = e.originalEvent.changedTouches[0].pageX;\n          e.pageY = e.originalEvent.changedTouches[0].pageY;\n          e.target = document.elementFromPoint(e.originalEvent.changedTouches[0].pageX - window.pageXOffset, e.originalEvent.changedTouches[0].pageY - window.pageYOffset);\n        }\n\n        if (!vakata_dnd.is_down) {\n          return;\n        }\n\n        if (!vakata_dnd.is_drag) {\n          if (Math.abs(e.pageX - vakata_dnd.init_x) > (vakata_dnd.is_touch ? $.vakata.dnd.settings.threshold_touch : $.vakata.dnd.settings.threshold) || Math.abs(e.pageY - vakata_dnd.init_y) > (vakata_dnd.is_touch ? $.vakata.dnd.settings.threshold_touch : $.vakata.dnd.settings.threshold)) {\n            if (vakata_dnd.helper) {\n              vakata_dnd.helper.appendTo(\"body\");\n              vakata_dnd.helper_w = vakata_dnd.helper.outerWidth();\n            }\n\n            vakata_dnd.is_drag = true;\n            $(vakata_dnd.target).one('click.vakata', false);\n            /**\n             * triggered on the document when a drag starts\n             * @event\n             * @plugin dnd\n             * @name dnd_start.vakata\n             * @param {Mixed} data any data supplied with the call to $.vakata.dnd.start\n             * @param {DOM} element the DOM element being dragged\n             * @param {jQuery} helper the helper shown next to the mouse\n             * @param {Object} event the event that caused the start (probably mousemove)\n             */\n\n            $.vakata.dnd._trigger(\"start\", e);\n          } else {\n            return;\n          }\n        }\n\n        var d = false,\n            w = false,\n            dh = false,\n            wh = false,\n            dw = false,\n            ww = false,\n            dt = false,\n            dl = false,\n            ht = false,\n            hl = false;\n        vakata_dnd.scroll_t = 0;\n        vakata_dnd.scroll_l = 0;\n        vakata_dnd.scroll_e = false;\n        $($(e.target).parentsUntil(\"body\").addBack().get().reverse()).filter(function () {\n          return /^auto|scroll$/.test($(this).css(\"overflow\")) && (this.scrollHeight > this.offsetHeight || this.scrollWidth > this.offsetWidth);\n        }).each(function () {\n          var t = $(this),\n              o = t.offset();\n\n          if (this.scrollHeight > this.offsetHeight) {\n            if (o.top + t.height() - e.pageY < $.vakata.dnd.settings.scroll_proximity) {\n              vakata_dnd.scroll_t = 1;\n            }\n\n            if (e.pageY - o.top < $.vakata.dnd.settings.scroll_proximity) {\n              vakata_dnd.scroll_t = -1;\n            }\n          }\n\n          if (this.scrollWidth > this.offsetWidth) {\n            if (o.left + t.width() - e.pageX < $.vakata.dnd.settings.scroll_proximity) {\n              vakata_dnd.scroll_l = 1;\n            }\n\n            if (e.pageX - o.left < $.vakata.dnd.settings.scroll_proximity) {\n              vakata_dnd.scroll_l = -1;\n            }\n          }\n\n          if (vakata_dnd.scroll_t || vakata_dnd.scroll_l) {\n            vakata_dnd.scroll_e = $(this);\n            return false;\n          }\n        });\n\n        if (!vakata_dnd.scroll_e) {\n          d = $(document);\n          w = $(window);\n          dh = d.height();\n          wh = w.height();\n          dw = d.width();\n          ww = w.width();\n          dt = d.scrollTop();\n          dl = d.scrollLeft();\n\n          if (dh > wh && e.pageY - dt < $.vakata.dnd.settings.scroll_proximity) {\n            vakata_dnd.scroll_t = -1;\n          }\n\n          if (dh > wh && wh - (e.pageY - dt) < $.vakata.dnd.settings.scroll_proximity) {\n            vakata_dnd.scroll_t = 1;\n          }\n\n          if (dw > ww && e.pageX - dl < $.vakata.dnd.settings.scroll_proximity) {\n            vakata_dnd.scroll_l = -1;\n          }\n\n          if (dw > ww && ww - (e.pageX - dl) < $.vakata.dnd.settings.scroll_proximity) {\n            vakata_dnd.scroll_l = 1;\n          }\n\n          if (vakata_dnd.scroll_t || vakata_dnd.scroll_l) {\n            vakata_dnd.scroll_e = d;\n          }\n        }\n\n        if (vakata_dnd.scroll_e) {\n          $.vakata.dnd._scroll(true);\n        }\n\n        if (vakata_dnd.helper) {\n          ht = parseInt(e.pageY + $.vakata.dnd.settings.helper_top, 10);\n          hl = parseInt(e.pageX + $.vakata.dnd.settings.helper_left, 10);\n\n          if (dh && ht + 25 > dh) {\n            ht = dh - 50;\n          }\n\n          if (dw && hl + vakata_dnd.helper_w > dw) {\n            hl = dw - (vakata_dnd.helper_w + 2);\n          }\n\n          vakata_dnd.helper.css({\n            left: hl + \"px\",\n            top: ht + \"px\"\n          });\n        }\n        /**\n         * triggered on the document when a drag is in progress\n         * @event\n         * @plugin dnd\n         * @name dnd_move.vakata\n         * @param {Mixed} data any data supplied with the call to $.vakata.dnd.start\n         * @param {DOM} element the DOM element being dragged\n         * @param {jQuery} helper the helper shown next to the mouse\n         * @param {Object} event the event that caused this to trigger (most likely mousemove)\n         */\n\n\n        $.vakata.dnd._trigger(\"move\", e);\n\n        return false;\n      },\n      stop: function stop(e) {\n        if (e.type === \"touchend\" && e.originalEvent && e.originalEvent.changedTouches && e.originalEvent.changedTouches[0]) {\n          e.pageX = e.originalEvent.changedTouches[0].pageX;\n          e.pageY = e.originalEvent.changedTouches[0].pageY;\n          e.target = document.elementFromPoint(e.originalEvent.changedTouches[0].pageX - window.pageXOffset, e.originalEvent.changedTouches[0].pageY - window.pageYOffset);\n        }\n\n        if (vakata_dnd.is_drag) {\n          /**\n           * triggered on the document when a drag stops (the dragged element is dropped)\n           * @event\n           * @plugin dnd\n           * @name dnd_stop.vakata\n           * @param {Mixed} data any data supplied with the call to $.vakata.dnd.start\n           * @param {DOM} element the DOM element being dragged\n           * @param {jQuery} helper the helper shown next to the mouse\n           * @param {Object} event the event that caused the stop\n           */\n          if (e.target !== vakata_dnd.target) {\n            $(vakata_dnd.target).off('click.vakata');\n          }\n\n          $.vakata.dnd._trigger(\"stop\", e);\n        } else {\n          if (e.type === \"touchend\" && e.target === vakata_dnd.target) {\n            var to = setTimeout(function () {\n              $(e.target).click();\n            }, 100);\n            $(e.target).one('click', function () {\n              if (to) {\n                clearTimeout(to);\n              }\n            });\n          }\n        }\n\n        $.vakata.dnd._clean();\n\n        return false;\n      }\n    };\n  })($); // include the dnd plugin by default\n  // $.jstree.defaults.plugins.push(\"dnd\");\n\n  /**\n   * ### Massload plugin\n   *\n   * Adds massload functionality to jsTree, so that multiple nodes can be loaded in a single request (only useful with lazy loading).\n   */\n\n  /**\n   * massload configuration\n   *\n   * It is possible to set this to a standard jQuery-like AJAX config.\n   * In addition to the standard jQuery ajax options here you can supply functions for `data` and `url`, the functions will be run in the current instance's scope and a param will be passed indicating which node IDs need to be loaded, the return value of those functions will be used.\n   *\n   * You can also set this to a function, that function will receive the node IDs being loaded as argument and a second param which is a function (callback) which should be called with the result.\n   *\n   * Both the AJAX and the function approach rely on the same return value - an object where the keys are the node IDs, and the value is the children of that node as an array.\n   *\n   *\t{\n   *\t\t\"id1\" : [{ \"text\" : \"Child of ID1\", \"id\" : \"c1\" }, { \"text\" : \"Another child of ID1\", \"id\" : \"c2\" }],\n   *\t\t\"id2\" : [{ \"text\" : \"Child of ID2\", \"id\" : \"c3\" }]\n   *\t}\n   * \n   * @name $.jstree.defaults.massload\n   * @plugin massload\n   */\n\n\n  $.jstree.defaults.massload = null;\n\n  $.jstree.plugins.massload = function (options, parent) {\n    this.init = function (el, options) {\n      this._data.massload = {};\n      parent.init.call(this, el, options);\n    };\n\n    this._load_nodes = function (nodes, callback, is_callback, force_reload) {\n      var s = this.settings.massload,\n          nodesString = JSON.stringify(nodes),\n          toLoad = [],\n          m = this._model.data,\n          i,\n          j,\n          dom;\n\n      if (!is_callback) {\n        for (i = 0, j = nodes.length; i < j; i++) {\n          if (!m[nodes[i]] || !m[nodes[i]].state.loaded && !m[nodes[i]].state.failed || force_reload) {\n            toLoad.push(nodes[i]);\n            dom = this.get_node(nodes[i], true);\n\n            if (dom && dom.length) {\n              dom.addClass(\"jstree-loading\").attr('aria-busy', true);\n            }\n          }\n        }\n\n        this._data.massload = {};\n\n        if (toLoad.length) {\n          if ($.isFunction(s)) {\n            return s.call(this, toLoad, $.proxy(function (data) {\n              var i, j;\n\n              if (data) {\n                for (i in data) {\n                  if (data.hasOwnProperty(i)) {\n                    this._data.massload[i] = data[i];\n                  }\n                }\n              }\n\n              for (i = 0, j = nodes.length; i < j; i++) {\n                dom = this.get_node(nodes[i], true);\n\n                if (dom && dom.length) {\n                  dom.removeClass(\"jstree-loading\").attr('aria-busy', false);\n                }\n              }\n\n              parent._load_nodes.call(this, nodes, callback, is_callback, force_reload);\n            }, this));\n          }\n\n          if (_typeof(s) === 'object' && s && s.url) {\n            s = $.extend(true, {}, s);\n\n            if ($.isFunction(s.url)) {\n              s.url = s.url.call(this, toLoad);\n            }\n\n            if ($.isFunction(s.data)) {\n              s.data = s.data.call(this, toLoad);\n            }\n\n            return $.ajax(s).done($.proxy(function (data, t, x) {\n              var i, j;\n\n              if (data) {\n                for (i in data) {\n                  if (data.hasOwnProperty(i)) {\n                    this._data.massload[i] = data[i];\n                  }\n                }\n              }\n\n              for (i = 0, j = nodes.length; i < j; i++) {\n                dom = this.get_node(nodes[i], true);\n\n                if (dom && dom.length) {\n                  dom.removeClass(\"jstree-loading\").attr('aria-busy', false);\n                }\n              }\n\n              parent._load_nodes.call(this, nodes, callback, is_callback, force_reload);\n            }, this)).fail($.proxy(function (f) {\n              parent._load_nodes.call(this, nodes, callback, is_callback, force_reload);\n            }, this));\n          }\n        }\n      }\n\n      return parent._load_nodes.call(this, nodes, callback, is_callback, force_reload);\n    };\n\n    this._load_node = function (obj, callback) {\n      var data = this._data.massload[obj.id],\n          rslt = null,\n          dom;\n\n      if (data) {\n        rslt = this[typeof data === 'string' ? '_append_html_data' : '_append_json_data'](obj, typeof data === 'string' ? $($.parseHTML(data)).filter(function () {\n          return this.nodeType !== 3;\n        }) : data, function (status) {\n          callback.call(this, status);\n        });\n        dom = this.get_node(obj.id, true);\n\n        if (dom && dom.length) {\n          dom.removeClass(\"jstree-loading\").attr('aria-busy', false);\n        }\n\n        delete this._data.massload[obj.id];\n        return rslt;\n      }\n\n      return parent._load_node.call(this, obj, callback);\n    };\n  };\n  /**\n   * ### Search plugin\n   *\n   * Adds search functionality to jsTree.\n   */\n\n  /**\n   * stores all defaults for the search plugin\n   * @name $.jstree.defaults.search\n   * @plugin search\n   */\n\n\n  $.jstree.defaults.search = {\n    /**\n     * a jQuery-like AJAX config, which jstree uses if a server should be queried for results.\n     *\n     * A `str` (which is the search string) parameter will be added with the request, an optional `inside` parameter will be added if the search is limited to a node id. The expected result is a JSON array with nodes that need to be opened so that matching nodes will be revealed.\n     * Leave this setting as `false` to not query the server. You can also set this to a function, which will be invoked in the instance's scope and receive 3 parameters - the search string, the callback to call with the array of nodes to load, and the optional node ID to limit the search to\n     * @name $.jstree.defaults.search.ajax\n     * @plugin search\n     */\n    ajax: false,\n\n    /**\n     * Indicates if the search should be fuzzy or not (should `chnd3` match `child node 3`). Default is `false`.\n     * @name $.jstree.defaults.search.fuzzy\n     * @plugin search\n     */\n    fuzzy: false,\n\n    /**\n     * Indicates if the search should be case sensitive. Default is `false`.\n     * @name $.jstree.defaults.search.case_sensitive\n     * @plugin search\n     */\n    case_sensitive: false,\n\n    /**\n     * Indicates if the tree should be filtered (by default) to show only matching nodes (keep in mind this can be a heavy on large trees in old browsers).\n     * This setting can be changed at runtime when calling the search method. Default is `false`.\n     * @name $.jstree.defaults.search.show_only_matches\n     * @plugin search\n     */\n    show_only_matches: false,\n\n    /**\n     * Indicates if the children of matched element are shown (when show_only_matches is true)\n     * This setting can be changed at runtime when calling the search method. Default is `false`.\n     * @name $.jstree.defaults.search.show_only_matches_children\n     * @plugin search\n     */\n    show_only_matches_children: false,\n\n    /**\n     * Indicates if all nodes opened to reveal the search result, should be closed when the search is cleared or a new search is performed. Default is `true`.\n     * @name $.jstree.defaults.search.close_opened_onclear\n     * @plugin search\n     */\n    close_opened_onclear: true,\n\n    /**\n     * Indicates if only leaf nodes should be included in search results. Default is `false`.\n     * @name $.jstree.defaults.search.search_leaves_only\n     * @plugin search\n     */\n    search_leaves_only: false,\n\n    /**\n     * If set to a function it wil be called in the instance's scope with two arguments - search string and node (where node will be every node in the structure, so use with caution).\n     * If the function returns a truthy value the node will be considered a match (it might not be displayed if search_only_leaves is set to true and the node is not a leaf). Default is `false`.\n     * @name $.jstree.defaults.search.search_callback\n     * @plugin search\n     */\n    search_callback: false\n  };\n\n  $.jstree.plugins.search = function (options, parent) {\n    this.bind = function () {\n      parent.bind.call(this);\n      this._data.search.str = \"\";\n      this._data.search.dom = $();\n      this._data.search.res = [];\n      this._data.search.opn = [];\n      this._data.search.som = false;\n      this._data.search.smc = false;\n      this._data.search.hdn = [];\n      this.element.on(\"search.jstree\", $.proxy(function (e, data) {\n        if (this._data.search.som && data.res.length) {\n          var m = this._model.data,\n              i,\n              j,\n              p = [],\n              k,\n              l;\n\n          for (i = 0, j = data.res.length; i < j; i++) {\n            if (m[data.res[i]] && !m[data.res[i]].state.hidden) {\n              p.push(data.res[i]);\n              p = p.concat(m[data.res[i]].parents);\n\n              if (this._data.search.smc) {\n                for (k = 0, l = m[data.res[i]].children_d.length; k < l; k++) {\n                  if (m[m[data.res[i]].children_d[k]] && !m[m[data.res[i]].children_d[k]].state.hidden) {\n                    p.push(m[data.res[i]].children_d[k]);\n                  }\n                }\n              }\n            }\n          }\n\n          p = $.vakata.array_remove_item($.vakata.array_unique(p), $.jstree.root);\n          this._data.search.hdn = this.hide_all(true);\n          this.show_node(p, true);\n          this.redraw(true);\n        }\n      }, this)).on(\"clear_search.jstree\", $.proxy(function (e, data) {\n        if (this._data.search.som && data.res.length) {\n          this.show_node(this._data.search.hdn, true);\n          this.redraw(true);\n        }\n      }, this));\n    };\n    /**\n     * used to search the tree nodes for a given string\n     * @name search(str [, skip_async])\n     * @param {String} str the search string\n     * @param {Boolean} skip_async if set to true server will not be queried even if configured\n     * @param {Boolean} show_only_matches if set to true only matching nodes will be shown (keep in mind this can be very slow on large trees or old browsers)\n     * @param {mixed} inside an optional node to whose children to limit the search\n     * @param {Boolean} append if set to true the results of this search are appended to the previous search\n     * @plugin search\n     * @trigger search.jstree\n     */\n\n\n    this.search = function (str, skip_async, show_only_matches, inside, append, show_only_matches_children) {\n      if (str === false || $.trim(str.toString()) === \"\") {\n        return this.clear_search();\n      }\n\n      inside = this.get_node(inside);\n      inside = inside && inside.id ? inside.id : null;\n      str = str.toString();\n      var s = this.settings.search,\n          a = s.ajax ? s.ajax : false,\n          m = this._model.data,\n          f = null,\n          r = [],\n          p = [],\n          i,\n          j;\n\n      if (this._data.search.res.length && !append) {\n        this.clear_search();\n      }\n\n      if (show_only_matches === undefined) {\n        show_only_matches = s.show_only_matches;\n      }\n\n      if (show_only_matches_children === undefined) {\n        show_only_matches_children = s.show_only_matches_children;\n      }\n\n      if (!skip_async && a !== false) {\n        if ($.isFunction(a)) {\n          return a.call(this, str, $.proxy(function (d) {\n            if (d && d.d) {\n              d = d.d;\n            }\n\n            this._load_nodes(!$.isArray(d) ? [] : $.vakata.array_unique(d), function () {\n              this.search(str, true, show_only_matches, inside, append, show_only_matches_children);\n            });\n          }, this), inside);\n        } else {\n          a = $.extend({}, a);\n\n          if (!a.data) {\n            a.data = {};\n          }\n\n          a.data.str = str;\n\n          if (inside) {\n            a.data.inside = inside;\n          }\n\n          if (this._data.search.lastRequest) {\n            this._data.search.lastRequest.abort();\n          }\n\n          this._data.search.lastRequest = $.ajax(a).fail($.proxy(function () {\n            this._data.core.last_error = {\n              'error': 'ajax',\n              'plugin': 'search',\n              'id': 'search_01',\n              'reason': 'Could not load search parents',\n              'data': JSON.stringify(a)\n            };\n            this.settings.core.error.call(this, this._data.core.last_error);\n          }, this)).done($.proxy(function (d) {\n            if (d && d.d) {\n              d = d.d;\n            }\n\n            this._load_nodes(!$.isArray(d) ? [] : $.vakata.array_unique(d), function () {\n              this.search(str, true, show_only_matches, inside, append, show_only_matches_children);\n            });\n          }, this));\n          return this._data.search.lastRequest;\n        }\n      }\n\n      if (!append) {\n        this._data.search.str = str;\n        this._data.search.dom = $();\n        this._data.search.res = [];\n        this._data.search.opn = [];\n        this._data.search.som = show_only_matches;\n        this._data.search.smc = show_only_matches_children;\n      }\n\n      f = new $.vakata.search(str, true, {\n        caseSensitive: s.case_sensitive,\n        fuzzy: s.fuzzy\n      });\n      $.each(m[inside ? inside : $.jstree.root].children_d, function (ii, i) {\n        var v = m[i];\n\n        if (v.text && !v.state.hidden && (!s.search_leaves_only || v.state.loaded && v.children.length === 0) && (s.search_callback && s.search_callback.call(this, str, v) || !s.search_callback && f.search(v.text).isMatch)) {\n          r.push(i);\n          p = p.concat(v.parents);\n        }\n      });\n\n      if (r.length) {\n        p = $.vakata.array_unique(p);\n\n        for (i = 0, j = p.length; i < j; i++) {\n          if (p[i] !== $.jstree.root && m[p[i]] && this.open_node(p[i], null, 0) === true) {\n            this._data.search.opn.push(p[i]);\n          }\n        }\n\n        if (!append) {\n          this._data.search.dom = $(this.element[0].querySelectorAll('#' + $.map(r, function (v) {\n            return \"0123456789\".indexOf(v[0]) !== -1 ? '\\\\3' + v[0] + ' ' + v.substr(1).replace($.jstree.idregex, '\\\\$&') : v.replace($.jstree.idregex, '\\\\$&');\n          }).join(', #')));\n          this._data.search.res = r;\n        } else {\n          this._data.search.dom = this._data.search.dom.add($(this.element[0].querySelectorAll('#' + $.map(r, function (v) {\n            return \"0123456789\".indexOf(v[0]) !== -1 ? '\\\\3' + v[0] + ' ' + v.substr(1).replace($.jstree.idregex, '\\\\$&') : v.replace($.jstree.idregex, '\\\\$&');\n          }).join(', #'))));\n          this._data.search.res = $.vakata.array_unique(this._data.search.res.concat(r));\n        }\n\n        this._data.search.dom.children(\".jstree-anchor\").addClass('jstree-search');\n      }\n      /**\n       * triggered after search is complete\n       * @event\n       * @name search.jstree\n       * @param {jQuery} nodes a jQuery collection of matching nodes\n       * @param {String} str the search string\n       * @param {Array} res a collection of objects represeing the matching nodes\n       * @plugin search\n       */\n\n\n      this.trigger('search', {\n        nodes: this._data.search.dom,\n        str: str,\n        res: this._data.search.res,\n        show_only_matches: show_only_matches\n      });\n    };\n    /**\n     * used to clear the last search (removes classes and shows all nodes if filtering is on)\n     * @name clear_search()\n     * @plugin search\n     * @trigger clear_search.jstree\n     */\n\n\n    this.clear_search = function () {\n      if (this.settings.search.close_opened_onclear) {\n        this.close_node(this._data.search.opn, 0);\n      }\n      /**\n       * triggered after search is complete\n       * @event\n       * @name clear_search.jstree\n       * @param {jQuery} nodes a jQuery collection of matching nodes (the result from the last search)\n       * @param {String} str the search string (the last search string)\n       * @param {Array} res a collection of objects represeing the matching nodes (the result from the last search)\n       * @plugin search\n       */\n\n\n      this.trigger('clear_search', {\n        'nodes': this._data.search.dom,\n        str: this._data.search.str,\n        res: this._data.search.res\n      });\n\n      if (this._data.search.res.length) {\n        this._data.search.dom = $(this.element[0].querySelectorAll('#' + $.map(this._data.search.res, function (v) {\n          return \"0123456789\".indexOf(v[0]) !== -1 ? '\\\\3' + v[0] + ' ' + v.substr(1).replace($.jstree.idregex, '\\\\$&') : v.replace($.jstree.idregex, '\\\\$&');\n        }).join(', #')));\n\n        this._data.search.dom.children(\".jstree-anchor\").removeClass(\"jstree-search\");\n      }\n\n      this._data.search.str = \"\";\n      this._data.search.res = [];\n      this._data.search.opn = [];\n      this._data.search.dom = $();\n    };\n\n    this.redraw_node = function (obj, deep, callback, force_render) {\n      obj = parent.redraw_node.apply(this, arguments);\n\n      if (obj) {\n        if ($.inArray(obj.id, this._data.search.res) !== -1) {\n          var i,\n              j,\n              tmp = null;\n\n          for (i = 0, j = obj.childNodes.length; i < j; i++) {\n            if (obj.childNodes[i] && obj.childNodes[i].className && obj.childNodes[i].className.indexOf(\"jstree-anchor\") !== -1) {\n              tmp = obj.childNodes[i];\n              break;\n            }\n          }\n\n          if (tmp) {\n            tmp.className += ' jstree-search';\n          }\n        }\n      }\n\n      return obj;\n    };\n  }; // helpers\n\n\n  (function ($) {\n    // from http://kiro.me/projects/fuse.html\n    $.vakata.search = function (pattern, txt, options) {\n      options = options || {};\n      options = $.extend({}, $.vakata.search.defaults, options);\n\n      if (options.fuzzy !== false) {\n        options.fuzzy = true;\n      }\n\n      pattern = options.caseSensitive ? pattern : pattern.toLowerCase();\n      var MATCH_LOCATION = options.location,\n          MATCH_DISTANCE = options.distance,\n          MATCH_THRESHOLD = options.threshold,\n          patternLen = pattern.length,\n          matchmask,\n          pattern_alphabet,\n          match_bitapScore,\n          search;\n\n      if (patternLen > 32) {\n        options.fuzzy = false;\n      }\n\n      if (options.fuzzy) {\n        matchmask = 1 << patternLen - 1;\n\n        pattern_alphabet = function () {\n          var mask = {},\n              i = 0;\n\n          for (i = 0; i < patternLen; i++) {\n            mask[pattern.charAt(i)] = 0;\n          }\n\n          for (i = 0; i < patternLen; i++) {\n            mask[pattern.charAt(i)] |= 1 << patternLen - i - 1;\n          }\n\n          return mask;\n        }();\n\n        match_bitapScore = function match_bitapScore(e, x) {\n          var accuracy = e / patternLen,\n              proximity = Math.abs(MATCH_LOCATION - x);\n\n          if (!MATCH_DISTANCE) {\n            return proximity ? 1.0 : accuracy;\n          }\n\n          return accuracy + proximity / MATCH_DISTANCE;\n        };\n      }\n\n      search = function search(text) {\n        text = options.caseSensitive ? text : text.toLowerCase();\n\n        if (pattern === text || text.indexOf(pattern) !== -1) {\n          return {\n            isMatch: true,\n            score: 0\n          };\n        }\n\n        if (!options.fuzzy) {\n          return {\n            isMatch: false,\n            score: 1\n          };\n        }\n\n        var i,\n            j,\n            textLen = text.length,\n            scoreThreshold = MATCH_THRESHOLD,\n            bestLoc = text.indexOf(pattern, MATCH_LOCATION),\n            binMin,\n            binMid,\n            binMax = patternLen + textLen,\n            lastRd,\n            start,\n            finish,\n            rd,\n            charMatch,\n            score = 1,\n            locations = [];\n\n        if (bestLoc !== -1) {\n          scoreThreshold = Math.min(match_bitapScore(0, bestLoc), scoreThreshold);\n          bestLoc = text.lastIndexOf(pattern, MATCH_LOCATION + patternLen);\n\n          if (bestLoc !== -1) {\n            scoreThreshold = Math.min(match_bitapScore(0, bestLoc), scoreThreshold);\n          }\n        }\n\n        bestLoc = -1;\n\n        for (i = 0; i < patternLen; i++) {\n          binMin = 0;\n          binMid = binMax;\n\n          while (binMin < binMid) {\n            if (match_bitapScore(i, MATCH_LOCATION + binMid) <= scoreThreshold) {\n              binMin = binMid;\n            } else {\n              binMax = binMid;\n            }\n\n            binMid = Math.floor((binMax - binMin) / 2 + binMin);\n          }\n\n          binMax = binMid;\n          start = Math.max(1, MATCH_LOCATION - binMid + 1);\n          finish = Math.min(MATCH_LOCATION + binMid, textLen) + patternLen;\n          rd = new Array(finish + 2);\n          rd[finish + 1] = (1 << i) - 1;\n\n          for (j = finish; j >= start; j--) {\n            charMatch = pattern_alphabet[text.charAt(j - 1)];\n\n            if (i === 0) {\n              rd[j] = (rd[j + 1] << 1 | 1) & charMatch;\n            } else {\n              rd[j] = (rd[j + 1] << 1 | 1) & charMatch | ((lastRd[j + 1] | lastRd[j]) << 1 | 1) | lastRd[j + 1];\n            }\n\n            if (rd[j] & matchmask) {\n              score = match_bitapScore(i, j - 1);\n\n              if (score <= scoreThreshold) {\n                scoreThreshold = score;\n                bestLoc = j - 1;\n                locations.push(bestLoc);\n\n                if (bestLoc > MATCH_LOCATION) {\n                  start = Math.max(1, 2 * MATCH_LOCATION - bestLoc);\n                } else {\n                  break;\n                }\n              }\n            }\n          }\n\n          if (match_bitapScore(i + 1, MATCH_LOCATION) > scoreThreshold) {\n            break;\n          }\n\n          lastRd = rd;\n        }\n\n        return {\n          isMatch: bestLoc >= 0,\n          score: score\n        };\n      };\n\n      return txt === true ? {\n        'search': search\n      } : search(txt);\n    };\n\n    $.vakata.search.defaults = {\n      location: 0,\n      distance: 100,\n      threshold: 0.6,\n      fuzzy: false,\n      caseSensitive: false\n    };\n  })($); // include the search plugin by default\n  // $.jstree.defaults.plugins.push(\"search\");\n\n  /**\n   * ### Sort plugin\n   *\n   * Automatically sorts all siblings in the tree according to a sorting function.\n   */\n\n  /**\n   * the settings function used to sort the nodes.\n   * It is executed in the tree's context, accepts two nodes as arguments and should return `1` or `-1`.\n   * @name $.jstree.defaults.sort\n   * @plugin sort\n   */\n\n\n  $.jstree.defaults.sort = function (a, b) {\n    //return this.get_type(a) === this.get_type(b) ? (this.get_text(a) > this.get_text(b) ? 1 : -1) : this.get_type(a) >= this.get_type(b);\n    return this.get_text(a) > this.get_text(b) ? 1 : -1;\n  };\n\n  $.jstree.plugins.sort = function (options, parent) {\n    this.bind = function () {\n      parent.bind.call(this);\n      this.element.on(\"model.jstree\", $.proxy(function (e, data) {\n        this.sort(data.parent, true);\n      }, this)).on(\"rename_node.jstree create_node.jstree\", $.proxy(function (e, data) {\n        this.sort(data.parent || data.node.parent, false);\n        this.redraw_node(data.parent || data.node.parent, true);\n      }, this)).on(\"move_node.jstree copy_node.jstree\", $.proxy(function (e, data) {\n        this.sort(data.parent, false);\n        this.redraw_node(data.parent, true);\n      }, this));\n    };\n    /**\n     * used to sort a node's children\n     * @private\n     * @name sort(obj [, deep])\n     * @param  {mixed} obj the node\n     * @param {Boolean} deep if set to `true` nodes are sorted recursively.\n     * @plugin sort\n     * @trigger search.jstree\n     */\n\n\n    this.sort = function (obj, deep) {\n      var i, j;\n      obj = this.get_node(obj);\n\n      if (obj && obj.children && obj.children.length) {\n        obj.children.sort($.proxy(this.settings.sort, this));\n\n        if (deep) {\n          for (i = 0, j = obj.children_d.length; i < j; i++) {\n            this.sort(obj.children_d[i], false);\n          }\n        }\n      }\n    };\n  }; // include the sort plugin by default\n  // $.jstree.defaults.plugins.push(\"sort\");\n\n  /**\n   * ### State plugin\n   *\n   * Saves the state of the tree (selected nodes, opened nodes) on the user's computer using available options (localStorage, cookies, etc)\n   */\n\n\n  var to = false;\n  /**\n   * stores all defaults for the state plugin\n   * @name $.jstree.defaults.state\n   * @plugin state\n   */\n\n  $.jstree.defaults.state = {\n    /**\n     * A string for the key to use when saving the current tree (change if using multiple trees in your project). Defaults to `jstree`.\n     * @name $.jstree.defaults.state.key\n     * @plugin state\n     */\n    key: 'jstree',\n\n    /**\n     * A space separated list of events that trigger a state save. Defaults to `changed.jstree open_node.jstree close_node.jstree`.\n     * @name $.jstree.defaults.state.events\n     * @plugin state\n     */\n    events: 'changed.jstree open_node.jstree close_node.jstree check_node.jstree uncheck_node.jstree',\n\n    /**\n     * Time in milliseconds after which the state will expire. Defaults to 'false' meaning - no expire.\n     * @name $.jstree.defaults.state.ttl\n     * @plugin state\n     */\n    ttl: false,\n\n    /**\n     * A function that will be executed prior to restoring state with one argument - the state object. Can be used to clear unwanted parts of the state.\n     * @name $.jstree.defaults.state.filter\n     * @plugin state\n     */\n    filter: false\n  };\n\n  $.jstree.plugins.state = function (options, parent) {\n    this.bind = function () {\n      parent.bind.call(this);\n      var bind = $.proxy(function () {\n        this.element.on(this.settings.state.events, $.proxy(function () {\n          if (to) {\n            clearTimeout(to);\n          }\n\n          to = setTimeout($.proxy(function () {\n            this.save_state();\n          }, this), 100);\n        }, this));\n        /**\n         * triggered when the state plugin is finished restoring the state (and immediately after ready if there is no state to restore).\n         * @event\n         * @name state_ready.jstree\n         * @plugin state\n         */\n\n        this.trigger('state_ready');\n      }, this);\n      this.element.on(\"ready.jstree\", $.proxy(function (e, data) {\n        this.element.one(\"restore_state.jstree\", bind);\n\n        if (!this.restore_state()) {\n          bind();\n        }\n      }, this));\n    };\n    /**\n     * save the state\n     * @name save_state()\n     * @plugin state\n     */\n\n\n    this.save_state = function () {\n      var st = {\n        'state': this.get_state(),\n        'ttl': this.settings.state.ttl,\n        'sec': +new Date()\n      };\n      $.vakata.storage.set(this.settings.state.key, JSON.stringify(st));\n    };\n    /**\n     * restore the state from the user's computer\n     * @name restore_state()\n     * @plugin state\n     */\n\n\n    this.restore_state = function () {\n      var k = $.vakata.storage.get(this.settings.state.key);\n\n      if (!!k) {\n        try {\n          k = JSON.parse(k);\n        } catch (ex) {\n          return false;\n        }\n      }\n\n      if (!!k && k.ttl && k.sec && +new Date() - k.sec > k.ttl) {\n        return false;\n      }\n\n      if (!!k && k.state) {\n        k = k.state;\n      }\n\n      if (!!k && $.isFunction(this.settings.state.filter)) {\n        k = this.settings.state.filter.call(this, k);\n      }\n\n      if (!!k) {\n        this.element.one(\"set_state.jstree\", function (e, data) {\n          data.instance.trigger('restore_state', {\n            'state': $.extend(true, {}, k)\n          });\n        });\n        this.set_state(k);\n        return true;\n      }\n\n      return false;\n    };\n    /**\n     * clear the state on the user's computer\n     * @name clear_state()\n     * @plugin state\n     */\n\n\n    this.clear_state = function () {\n      return $.vakata.storage.del(this.settings.state.key);\n    };\n  };\n\n  (function ($, undefined) {\n    $.vakata.storage = {\n      // simply specifying the functions in FF throws an error\n      set: function set(key, val) {\n        return window.localStorage.setItem(key, val);\n      },\n      get: function get(key) {\n        return window.localStorage.getItem(key);\n      },\n      del: function del(key) {\n        return window.localStorage.removeItem(key);\n      }\n    };\n  })($); // include the state plugin by default\n  // $.jstree.defaults.plugins.push(\"state\");\n\n  /**\n   * ### Types plugin\n   *\n   * Makes it possible to add predefined types for groups of nodes, which make it possible to easily control nesting rules and icon for each group.\n   */\n\n  /**\n   * An object storing all types as key value pairs, where the key is the type name and the value is an object that could contain following keys (all optional).\n   *\n   * * `max_children` the maximum number of immediate children this node type can have. Do not specify or set to `-1` for unlimited.\n   * * `max_depth` the maximum number of nesting this node type can have. A value of `1` would mean that the node can have children, but no grandchildren. Do not specify or set to `-1` for unlimited.\n   * * `valid_children` an array of node type strings, that nodes of this type can have as children. Do not specify or set to `-1` for no limits.\n   * * `icon` a string - can be a path to an icon or a className, if using an image that is in the current directory use a `./` prefix, otherwise it will be detected as a class. Omit to use the default icon from your theme.\n   * * `li_attr` an object of values which will be used to add HTML attributes on the resulting LI DOM node (merged with the node's own data)\n   * * `a_attr` an object of values which will be used to add HTML attributes on the resulting A DOM node (merged with the node's own data)\n   *\n   * There are two predefined types:\n   *\n   * * `#` represents the root of the tree, for example `max_children` would control the maximum number of root nodes.\n   * * `default` represents the default node - any settings here will be applied to all nodes that do not have a type specified.\n   *\n   * @name $.jstree.defaults.types\n   * @plugin types\n   */\n\n\n  $.jstree.defaults.types = {\n    'default': {}\n  };\n  $.jstree.defaults.types[$.jstree.root] = {};\n\n  $.jstree.plugins.types = function (options, parent) {\n    this.init = function (el, options) {\n      var i, j;\n\n      if (options && options.types && options.types['default']) {\n        for (i in options.types) {\n          if (i !== \"default\" && i !== $.jstree.root && options.types.hasOwnProperty(i)) {\n            for (j in options.types['default']) {\n              if (options.types['default'].hasOwnProperty(j) && options.types[i][j] === undefined) {\n                options.types[i][j] = options.types['default'][j];\n              }\n            }\n          }\n        }\n      }\n\n      parent.init.call(this, el, options);\n      this._model.data[$.jstree.root].type = $.jstree.root;\n    };\n\n    this.refresh = function (skip_loading, forget_state) {\n      parent.refresh.call(this, skip_loading, forget_state);\n      this._model.data[$.jstree.root].type = $.jstree.root;\n    };\n\n    this.bind = function () {\n      this.element.on('model.jstree', $.proxy(function (e, data) {\n        var m = this._model.data,\n            dpc = data.nodes,\n            t = this.settings.types,\n            i,\n            j,\n            c = 'default',\n            k;\n\n        for (i = 0, j = dpc.length; i < j; i++) {\n          c = 'default';\n\n          if (m[dpc[i]].original && m[dpc[i]].original.type && t[m[dpc[i]].original.type]) {\n            c = m[dpc[i]].original.type;\n          }\n\n          if (m[dpc[i]].data && m[dpc[i]].data.jstree && m[dpc[i]].data.jstree.type && t[m[dpc[i]].data.jstree.type]) {\n            c = m[dpc[i]].data.jstree.type;\n          }\n\n          m[dpc[i]].type = c;\n\n          if (m[dpc[i]].icon === true && t[c].icon !== undefined) {\n            m[dpc[i]].icon = t[c].icon;\n          }\n\n          if (t[c].li_attr !== undefined && _typeof(t[c].li_attr) === 'object') {\n            for (k in t[c].li_attr) {\n              if (t[c].li_attr.hasOwnProperty(k)) {\n                if (k === 'id') {\n                  continue;\n                } else if (m[dpc[i]].li_attr[k] === undefined) {\n                  m[dpc[i]].li_attr[k] = t[c].li_attr[k];\n                } else if (k === 'class') {\n                  m[dpc[i]].li_attr['class'] = t[c].li_attr['class'] + ' ' + m[dpc[i]].li_attr['class'];\n                }\n              }\n            }\n          }\n\n          if (t[c].a_attr !== undefined && _typeof(t[c].a_attr) === 'object') {\n            for (k in t[c].a_attr) {\n              if (t[c].a_attr.hasOwnProperty(k)) {\n                if (k === 'id') {\n                  continue;\n                } else if (m[dpc[i]].a_attr[k] === undefined) {\n                  m[dpc[i]].a_attr[k] = t[c].a_attr[k];\n                } else if (k === 'href' && m[dpc[i]].a_attr[k] === '#') {\n                  m[dpc[i]].a_attr['href'] = t[c].a_attr['href'];\n                } else if (k === 'class') {\n                  m[dpc[i]].a_attr['class'] = t[c].a_attr['class'] + ' ' + m[dpc[i]].a_attr['class'];\n                }\n              }\n            }\n          }\n        }\n\n        m[$.jstree.root].type = $.jstree.root;\n      }, this));\n      parent.bind.call(this);\n    };\n\n    this.get_json = function (obj, options, flat) {\n      var i,\n          j,\n          m = this._model.data,\n          opt = options ? $.extend(true, {}, options, {\n        no_id: false\n      }) : {},\n          tmp = parent.get_json.call(this, obj, opt, flat);\n\n      if (tmp === false) {\n        return false;\n      }\n\n      if ($.isArray(tmp)) {\n        for (i = 0, j = tmp.length; i < j; i++) {\n          tmp[i].type = tmp[i].id && m[tmp[i].id] && m[tmp[i].id].type ? m[tmp[i].id].type : \"default\";\n\n          if (options && options.no_id) {\n            delete tmp[i].id;\n\n            if (tmp[i].li_attr && tmp[i].li_attr.id) {\n              delete tmp[i].li_attr.id;\n            }\n\n            if (tmp[i].a_attr && tmp[i].a_attr.id) {\n              delete tmp[i].a_attr.id;\n            }\n          }\n        }\n      } else {\n        tmp.type = tmp.id && m[tmp.id] && m[tmp.id].type ? m[tmp.id].type : \"default\";\n\n        if (options && options.no_id) {\n          tmp = this._delete_ids(tmp);\n        }\n      }\n\n      return tmp;\n    };\n\n    this._delete_ids = function (tmp) {\n      if ($.isArray(tmp)) {\n        for (var i = 0, j = tmp.length; i < j; i++) {\n          tmp[i] = this._delete_ids(tmp[i]);\n        }\n\n        return tmp;\n      }\n\n      delete tmp.id;\n\n      if (tmp.li_attr && tmp.li_attr.id) {\n        delete tmp.li_attr.id;\n      }\n\n      if (tmp.a_attr && tmp.a_attr.id) {\n        delete tmp.a_attr.id;\n      }\n\n      if (tmp.children && $.isArray(tmp.children)) {\n        tmp.children = this._delete_ids(tmp.children);\n      }\n\n      return tmp;\n    };\n\n    this.check = function (chk, obj, par, pos, more) {\n      if (parent.check.call(this, chk, obj, par, pos, more) === false) {\n        return false;\n      }\n\n      obj = obj && obj.id ? obj : this.get_node(obj);\n      par = par && par.id ? par : this.get_node(par);\n      var m = obj && obj.id ? more && more.origin ? more.origin : $.jstree.reference(obj.id) : null,\n          tmp,\n          d,\n          i,\n          j;\n      m = m && m._model && m._model.data ? m._model.data : null;\n\n      switch (chk) {\n        case \"create_node\":\n        case \"move_node\":\n        case \"copy_node\":\n          if (chk !== 'move_node' || $.inArray(obj.id, par.children) === -1) {\n            tmp = this.get_rules(par);\n\n            if (tmp.max_children !== undefined && tmp.max_children !== -1 && tmp.max_children === par.children.length) {\n              this._data.core.last_error = {\n                'error': 'check',\n                'plugin': 'types',\n                'id': 'types_01',\n                'reason': 'max_children prevents function: ' + chk,\n                'data': JSON.stringify({\n                  'chk': chk,\n                  'pos': pos,\n                  'obj': obj && obj.id ? obj.id : false,\n                  'par': par && par.id ? par.id : false\n                })\n              };\n              return false;\n            }\n\n            if (tmp.valid_children !== undefined && tmp.valid_children !== -1 && $.inArray(obj.type || 'default', tmp.valid_children) === -1) {\n              this._data.core.last_error = {\n                'error': 'check',\n                'plugin': 'types',\n                'id': 'types_02',\n                'reason': 'valid_children prevents function: ' + chk,\n                'data': JSON.stringify({\n                  'chk': chk,\n                  'pos': pos,\n                  'obj': obj && obj.id ? obj.id : false,\n                  'par': par && par.id ? par.id : false\n                })\n              };\n              return false;\n            }\n\n            if (m && obj.children_d && obj.parents) {\n              d = 0;\n\n              for (i = 0, j = obj.children_d.length; i < j; i++) {\n                d = Math.max(d, m[obj.children_d[i]].parents.length);\n              }\n\n              d = d - obj.parents.length + 1;\n            }\n\n            if (d <= 0 || d === undefined) {\n              d = 1;\n            }\n\n            do {\n              if (tmp.max_depth !== undefined && tmp.max_depth !== -1 && tmp.max_depth < d) {\n                this._data.core.last_error = {\n                  'error': 'check',\n                  'plugin': 'types',\n                  'id': 'types_03',\n                  'reason': 'max_depth prevents function: ' + chk,\n                  'data': JSON.stringify({\n                    'chk': chk,\n                    'pos': pos,\n                    'obj': obj && obj.id ? obj.id : false,\n                    'par': par && par.id ? par.id : false\n                  })\n                };\n                return false;\n              }\n\n              par = this.get_node(par.parent);\n              tmp = this.get_rules(par);\n              d++;\n            } while (par);\n          }\n\n          break;\n      }\n\n      return true;\n    };\n    /**\n     * used to retrieve the type settings object for a node\n     * @name get_rules(obj)\n     * @param {mixed} obj the node to find the rules for\n     * @return {Object}\n     * @plugin types\n     */\n\n\n    this.get_rules = function (obj) {\n      obj = this.get_node(obj);\n\n      if (!obj) {\n        return false;\n      }\n\n      var tmp = this.get_type(obj, true);\n\n      if (tmp.max_depth === undefined) {\n        tmp.max_depth = -1;\n      }\n\n      if (tmp.max_children === undefined) {\n        tmp.max_children = -1;\n      }\n\n      if (tmp.valid_children === undefined) {\n        tmp.valid_children = -1;\n      }\n\n      return tmp;\n    };\n    /**\n     * used to retrieve the type string or settings object for a node\n     * @name get_type(obj [, rules])\n     * @param {mixed} obj the node to find the rules for\n     * @param {Boolean} rules if set to `true` instead of a string the settings object will be returned\n     * @return {String|Object}\n     * @plugin types\n     */\n\n\n    this.get_type = function (obj, rules) {\n      obj = this.get_node(obj);\n      return !obj ? false : rules ? $.extend({\n        'type': obj.type\n      }, this.settings.types[obj.type]) : obj.type;\n    };\n    /**\n     * used to change a node's type\n     * @name set_type(obj, type)\n     * @param {mixed} obj the node to change\n     * @param {String} type the new type\n     * @plugin types\n     */\n\n\n    this.set_type = function (obj, type) {\n      var m = this._model.data,\n          t,\n          t1,\n          t2,\n          old_type,\n          old_icon,\n          k,\n          d,\n          a;\n\n      if ($.isArray(obj)) {\n        obj = obj.slice();\n\n        for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n          this.set_type(obj[t1], type);\n        }\n\n        return true;\n      }\n\n      t = this.settings.types;\n      obj = this.get_node(obj);\n\n      if (!t[type] || !obj) {\n        return false;\n      }\n\n      d = this.get_node(obj, true);\n\n      if (d && d.length) {\n        a = d.children('.jstree-anchor');\n      }\n\n      old_type = obj.type;\n      old_icon = this.get_icon(obj);\n      obj.type = type;\n\n      if (old_icon === true || !t[old_type] || t[old_type].icon !== undefined && old_icon === t[old_type].icon) {\n        this.set_icon(obj, t[type].icon !== undefined ? t[type].icon : true);\n      } // remove old type props\n\n\n      if (t[old_type] && t[old_type].li_attr !== undefined && _typeof(t[old_type].li_attr) === 'object') {\n        for (k in t[old_type].li_attr) {\n          if (t[old_type].li_attr.hasOwnProperty(k)) {\n            if (k === 'id') {\n              continue;\n            } else if (k === 'class') {\n              m[obj.id].li_attr['class'] = (m[obj.id].li_attr['class'] || '').replace(t[old_type].li_attr[k], '');\n\n              if (d) {\n                d.removeClass(t[old_type].li_attr[k]);\n              }\n            } else if (m[obj.id].li_attr[k] === t[old_type].li_attr[k]) {\n              m[obj.id].li_attr[k] = null;\n\n              if (d) {\n                d.removeAttr(k);\n              }\n            }\n          }\n        }\n      }\n\n      if (t[old_type] && t[old_type].a_attr !== undefined && _typeof(t[old_type].a_attr) === 'object') {\n        for (k in t[old_type].a_attr) {\n          if (t[old_type].a_attr.hasOwnProperty(k)) {\n            if (k === 'id') {\n              continue;\n            } else if (k === 'class') {\n              m[obj.id].a_attr['class'] = (m[obj.id].a_attr['class'] || '').replace(t[old_type].a_attr[k], '');\n\n              if (a) {\n                a.removeClass(t[old_type].a_attr[k]);\n              }\n            } else if (m[obj.id].a_attr[k] === t[old_type].a_attr[k]) {\n              if (k === 'href') {\n                m[obj.id].a_attr[k] = '#';\n\n                if (a) {\n                  a.attr('href', '#');\n                }\n              } else {\n                delete m[obj.id].a_attr[k];\n\n                if (a) {\n                  a.removeAttr(k);\n                }\n              }\n            }\n          }\n        }\n      } // add new props\n\n\n      if (t[type].li_attr !== undefined && _typeof(t[type].li_attr) === 'object') {\n        for (k in t[type].li_attr) {\n          if (t[type].li_attr.hasOwnProperty(k)) {\n            if (k === 'id') {\n              continue;\n            } else if (m[obj.id].li_attr[k] === undefined) {\n              m[obj.id].li_attr[k] = t[type].li_attr[k];\n\n              if (d) {\n                if (k === 'class') {\n                  d.addClass(t[type].li_attr[k]);\n                } else {\n                  d.attr(k, t[type].li_attr[k]);\n                }\n              }\n            } else if (k === 'class') {\n              m[obj.id].li_attr['class'] = t[type].li_attr[k] + ' ' + m[obj.id].li_attr['class'];\n\n              if (d) {\n                d.addClass(t[type].li_attr[k]);\n              }\n            }\n          }\n        }\n      }\n\n      if (t[type].a_attr !== undefined && _typeof(t[type].a_attr) === 'object') {\n        for (k in t[type].a_attr) {\n          if (t[type].a_attr.hasOwnProperty(k)) {\n            if (k === 'id') {\n              continue;\n            } else if (m[obj.id].a_attr[k] === undefined) {\n              m[obj.id].a_attr[k] = t[type].a_attr[k];\n\n              if (a) {\n                if (k === 'class') {\n                  a.addClass(t[type].a_attr[k]);\n                } else {\n                  a.attr(k, t[type].a_attr[k]);\n                }\n              }\n            } else if (k === 'href' && m[obj.id].a_attr[k] === '#') {\n              m[obj.id].a_attr['href'] = t[type].a_attr['href'];\n\n              if (a) {\n                a.attr('href', t[type].a_attr['href']);\n              }\n            } else if (k === 'class') {\n              m[obj.id].a_attr['class'] = t[type].a_attr['class'] + ' ' + m[obj.id].a_attr['class'];\n\n              if (a) {\n                a.addClass(t[type].a_attr[k]);\n              }\n            }\n          }\n        }\n      }\n\n      return true;\n    };\n  }; // include the types plugin by default\n  // $.jstree.defaults.plugins.push(\"types\");\n\n  /**\n   * ### Unique plugin\n   *\n   * Enforces that no nodes with the same name can coexist as siblings.\n   */\n\n  /**\n   * stores all defaults for the unique plugin\n   * @name $.jstree.defaults.unique\n   * @plugin unique\n   */\n\n\n  $.jstree.defaults.unique = {\n    /**\n     * Indicates if the comparison should be case sensitive. Default is `false`.\n     * @name $.jstree.defaults.unique.case_sensitive\n     * @plugin unique\n     */\n    case_sensitive: false,\n\n    /**\n     * A callback executed in the instance's scope when a new node is created and the name is already taken, the two arguments are the conflicting name and the counter. The default will produce results like `New node (2)`.\n     * @name $.jstree.defaults.unique.duplicate\n     * @plugin unique\n     */\n    duplicate: function duplicate(name, counter) {\n      return name + ' (' + counter + ')';\n    }\n  };\n\n  $.jstree.plugins.unique = function (options, parent) {\n    this.check = function (chk, obj, par, pos, more) {\n      if (parent.check.call(this, chk, obj, par, pos, more) === false) {\n        return false;\n      }\n\n      obj = obj && obj.id ? obj : this.get_node(obj);\n      par = par && par.id ? par : this.get_node(par);\n\n      if (!par || !par.children) {\n        return true;\n      }\n\n      var n = chk === \"rename_node\" ? pos : obj.text,\n          c = [],\n          s = this.settings.unique.case_sensitive,\n          m = this._model.data,\n          i,\n          j;\n\n      for (i = 0, j = par.children.length; i < j; i++) {\n        c.push(s ? m[par.children[i]].text : m[par.children[i]].text.toLowerCase());\n      }\n\n      if (!s) {\n        n = n.toLowerCase();\n      }\n\n      switch (chk) {\n        case \"delete_node\":\n          return true;\n\n        case \"rename_node\":\n          i = $.inArray(n, c) === -1 || obj.text && obj.text[s ? 'toString' : 'toLowerCase']() === n;\n\n          if (!i) {\n            this._data.core.last_error = {\n              'error': 'check',\n              'plugin': 'unique',\n              'id': 'unique_01',\n              'reason': 'Child with name ' + n + ' already exists. Preventing: ' + chk,\n              'data': JSON.stringify({\n                'chk': chk,\n                'pos': pos,\n                'obj': obj && obj.id ? obj.id : false,\n                'par': par && par.id ? par.id : false\n              })\n            };\n          }\n\n          return i;\n\n        case \"create_node\":\n          i = $.inArray(n, c) === -1;\n\n          if (!i) {\n            this._data.core.last_error = {\n              'error': 'check',\n              'plugin': 'unique',\n              'id': 'unique_04',\n              'reason': 'Child with name ' + n + ' already exists. Preventing: ' + chk,\n              'data': JSON.stringify({\n                'chk': chk,\n                'pos': pos,\n                'obj': obj && obj.id ? obj.id : false,\n                'par': par && par.id ? par.id : false\n              })\n            };\n          }\n\n          return i;\n\n        case \"copy_node\":\n          i = $.inArray(n, c) === -1;\n\n          if (!i) {\n            this._data.core.last_error = {\n              'error': 'check',\n              'plugin': 'unique',\n              'id': 'unique_02',\n              'reason': 'Child with name ' + n + ' already exists. Preventing: ' + chk,\n              'data': JSON.stringify({\n                'chk': chk,\n                'pos': pos,\n                'obj': obj && obj.id ? obj.id : false,\n                'par': par && par.id ? par.id : false\n              })\n            };\n          }\n\n          return i;\n\n        case \"move_node\":\n          i = obj.parent === par.id && (!more || !more.is_multi) || $.inArray(n, c) === -1;\n\n          if (!i) {\n            this._data.core.last_error = {\n              'error': 'check',\n              'plugin': 'unique',\n              'id': 'unique_03',\n              'reason': 'Child with name ' + n + ' already exists. Preventing: ' + chk,\n              'data': JSON.stringify({\n                'chk': chk,\n                'pos': pos,\n                'obj': obj && obj.id ? obj.id : false,\n                'par': par && par.id ? par.id : false\n              })\n            };\n          }\n\n          return i;\n      }\n\n      return true;\n    };\n\n    this.create_node = function (par, node, pos, callback, is_loaded) {\n      if (!node || node.text === undefined) {\n        if (par === null) {\n          par = $.jstree.root;\n        }\n\n        par = this.get_node(par);\n\n        if (!par) {\n          return parent.create_node.call(this, par, node, pos, callback, is_loaded);\n        }\n\n        pos = pos === undefined ? \"last\" : pos;\n\n        if (!pos.toString().match(/^(before|after)$/) && !is_loaded && !this.is_loaded(par)) {\n          return parent.create_node.call(this, par, node, pos, callback, is_loaded);\n        }\n\n        if (!node) {\n          node = {};\n        }\n\n        var tmp,\n            n,\n            dpc,\n            i,\n            j,\n            m = this._model.data,\n            s = this.settings.unique.case_sensitive,\n            cb = this.settings.unique.duplicate;\n        n = tmp = this.get_string('New node');\n        dpc = [];\n\n        for (i = 0, j = par.children.length; i < j; i++) {\n          dpc.push(s ? m[par.children[i]].text : m[par.children[i]].text.toLowerCase());\n        }\n\n        i = 1;\n\n        while ($.inArray(s ? n : n.toLowerCase(), dpc) !== -1) {\n          n = cb.call(this, tmp, ++i).toString();\n        }\n\n        node.text = n;\n      }\n\n      return parent.create_node.call(this, par, node, pos, callback, is_loaded);\n    };\n  }; // include the unique plugin by default\n  // $.jstree.defaults.plugins.push(\"unique\");\n\n  /**\n   * ### Wholerow plugin\n   *\n   * Makes each node appear block level. Making selection easier. May cause slow down for large trees in old browsers.\n   */\n\n\n  var div = document.createElement('DIV');\n  div.setAttribute('unselectable', 'on');\n  div.setAttribute('role', 'presentation');\n  div.className = 'jstree-wholerow';\n  div.innerHTML = '&#160;';\n\n  $.jstree.plugins.wholerow = function (options, parent) {\n    this.bind = function () {\n      parent.bind.call(this);\n      this.element.on('ready.jstree set_state.jstree', $.proxy(function () {\n        this.hide_dots();\n      }, this)).on(\"init.jstree loading.jstree ready.jstree\", $.proxy(function () {\n        //div.style.height = this._data.core.li_height + 'px';\n        this.get_container_ul().addClass('jstree-wholerow-ul');\n      }, this)).on(\"deselect_all.jstree\", $.proxy(function (e, data) {\n        this.element.find('.jstree-wholerow-clicked').removeClass('jstree-wholerow-clicked');\n      }, this)).on(\"changed.jstree\", $.proxy(function (e, data) {\n        this.element.find('.jstree-wholerow-clicked').removeClass('jstree-wholerow-clicked');\n        var tmp = false,\n            i,\n            j;\n\n        for (i = 0, j = data.selected.length; i < j; i++) {\n          tmp = this.get_node(data.selected[i], true);\n\n          if (tmp && tmp.length) {\n            tmp.children('.jstree-wholerow').addClass('jstree-wholerow-clicked');\n          }\n        }\n      }, this)).on(\"open_node.jstree\", $.proxy(function (e, data) {\n        this.get_node(data.node, true).find('.jstree-clicked').parent().children('.jstree-wholerow').addClass('jstree-wholerow-clicked');\n      }, this)).on(\"hover_node.jstree dehover_node.jstree\", $.proxy(function (e, data) {\n        if (e.type === \"hover_node\" && this.is_disabled(data.node)) {\n          return;\n        }\n\n        this.get_node(data.node, true).children('.jstree-wholerow')[e.type === \"hover_node\" ? \"addClass\" : \"removeClass\"]('jstree-wholerow-hovered');\n      }, this)).on(\"contextmenu.jstree\", \".jstree-wholerow\", $.proxy(function (e) {\n        if (this._data.contextmenu) {\n          e.preventDefault();\n          var tmp = $.Event('contextmenu', {\n            metaKey: e.metaKey,\n            ctrlKey: e.ctrlKey,\n            altKey: e.altKey,\n            shiftKey: e.shiftKey,\n            pageX: e.pageX,\n            pageY: e.pageY\n          });\n          $(e.currentTarget).closest(\".jstree-node\").children(\".jstree-anchor\").first().trigger(tmp);\n        }\n      }, this))\n      /*!\n      .on(\"mousedown.jstree touchstart.jstree\", \".jstree-wholerow\", function (e) {\n      \t\tif(e.target === e.currentTarget) {\n      \t\t\tvar a = $(e.currentTarget).closest(\".jstree-node\").children(\".jstree-anchor\");\n      \t\t\te.target = a[0];\n      \t\t\ta.trigger(e);\n      \t\t}\n      \t})\n      */\n      .on(\"click.jstree\", \".jstree-wholerow\", function (e) {\n        e.stopImmediatePropagation();\n        var tmp = $.Event('click', {\n          metaKey: e.metaKey,\n          ctrlKey: e.ctrlKey,\n          altKey: e.altKey,\n          shiftKey: e.shiftKey\n        });\n        $(e.currentTarget).closest(\".jstree-node\").children(\".jstree-anchor\").first().trigger(tmp).focus();\n      }).on(\"dblclick.jstree\", \".jstree-wholerow\", function (e) {\n        e.stopImmediatePropagation();\n        var tmp = $.Event('dblclick', {\n          metaKey: e.metaKey,\n          ctrlKey: e.ctrlKey,\n          altKey: e.altKey,\n          shiftKey: e.shiftKey\n        });\n        $(e.currentTarget).closest(\".jstree-node\").children(\".jstree-anchor\").first().trigger(tmp).focus();\n      }).on(\"click.jstree\", \".jstree-leaf > .jstree-ocl\", $.proxy(function (e) {\n        e.stopImmediatePropagation();\n        var tmp = $.Event('click', {\n          metaKey: e.metaKey,\n          ctrlKey: e.ctrlKey,\n          altKey: e.altKey,\n          shiftKey: e.shiftKey\n        });\n        $(e.currentTarget).closest(\".jstree-node\").children(\".jstree-anchor\").first().trigger(tmp).focus();\n      }, this)).on(\"mouseover.jstree\", \".jstree-wholerow, .jstree-icon\", $.proxy(function (e) {\n        e.stopImmediatePropagation();\n\n        if (!this.is_disabled(e.currentTarget)) {\n          this.hover_node(e.currentTarget);\n        }\n\n        return false;\n      }, this)).on(\"mouseleave.jstree\", \".jstree-node\", $.proxy(function (e) {\n        this.dehover_node(e.currentTarget);\n      }, this));\n    };\n\n    this.teardown = function () {\n      if (this.settings.wholerow) {\n        this.element.find(\".jstree-wholerow\").remove();\n      }\n\n      parent.teardown.call(this);\n    };\n\n    this.redraw_node = function (obj, deep, callback, force_render) {\n      obj = parent.redraw_node.apply(this, arguments);\n\n      if (obj) {\n        var tmp = div.cloneNode(true); //tmp.style.height = this._data.core.li_height + 'px';\n\n        if ($.inArray(obj.id, this._data.core.selected) !== -1) {\n          tmp.className += ' jstree-wholerow-clicked';\n        }\n\n        if (this._data.core.focused && this._data.core.focused === obj.id) {\n          tmp.className += ' jstree-wholerow-hovered';\n        }\n\n        obj.insertBefore(tmp, obj.childNodes[0]);\n      }\n\n      return obj;\n    };\n  }; // include the wholerow plugin by default\n  // $.jstree.defaults.plugins.push(\"wholerow\");\n\n\n  if (document.registerElement && Object && Object.create) {\n    var proto = Object.create(HTMLElement.prototype);\n\n    proto.createdCallback = function () {\n      var c = {\n        core: {},\n        plugins: []\n      },\n          i;\n\n      for (i in $.jstree.plugins) {\n        if ($.jstree.plugins.hasOwnProperty(i) && this.attributes[i]) {\n          c.plugins.push(i);\n\n          if (this.getAttribute(i) && JSON.parse(this.getAttribute(i))) {\n            c[i] = JSON.parse(this.getAttribute(i));\n          }\n        }\n      }\n\n      for (i in $.jstree.defaults.core) {\n        if ($.jstree.defaults.core.hasOwnProperty(i) && this.attributes[i]) {\n          c.core[i] = JSON.parse(this.getAttribute(i)) || this.getAttribute(i);\n        }\n      }\n\n      $(this).jstree(c);\n    }; // proto.attributeChangedCallback = function (name, previous, value) { };\n\n\n    try {\n      document.registerElement(\"vakata-jstree\", {\n        prototype: proto\n      });\n    } catch (ignore) {}\n  }\n});"

/***/ }),

/***/ "./node_modules/script-loader/addScript.js":
/*!*************************************************!*\
  !*** ./node_modules/script-loader/addScript.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
module.exports = function(src) {
	function log(error) {
		(typeof console !== "undefined")
		&& (console.error || console.log)("[Script Loader]", error);
	}

	// Check for IE =< 8
	function isIE() {
		return typeof attachEvent !== "undefined" && typeof addEventListener === "undefined";
	}

	try {
		if (typeof execScript !== "undefined" && isIE()) {
			execScript(src);
		} else if (typeof eval !== "undefined") {
			eval.call(null, src);
		} else {
			log("EvalError: No eval function available");
		}
	} catch (error) {
		log(error);
	}
}


/***/ }),

/***/ "./node_modules/script-loader/index.js!./assets/js/jstree-3.3.3.js":
/*!****************************************************************!*\
  !*** ./node_modules/script-loader!./assets/js/jstree-3.3.3.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! !./node_modules/script-loader/addScript.js */ "./node_modules/script-loader/addScript.js")(__webpack_require__(/*! !./node_modules/raw-loader!./node_modules/babel-loader/lib??ref--4-0!./assets/js/jstree-3.3.3.js */ "./node_modules/raw-loader/index.js!./node_modules/babel-loader/lib/index.js?!./assets/js/jstree-3.3.3.js")+"\n\n// SCRIPT-LOADER FOOTER\n//# sourceURL=script:///home/osboxes/workspace/mlab.local.test/node_modules/babel-loader/lib/index.js%3F?ref--4-0!/home/osboxes/workspace/mlab.local.test/assets/js/jstree-3.3.3.js")

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vYXNzZXRzL2pzL2FkbWluLmpzIiwid2VicGFjazovLy8uL2Fzc2V0cy9qcy9qc3RyZWUtMy4zLjMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzIiwid2VicGFjazovLy8uL2Fzc2V0cy9qcy9qc3RyZWUtMy4zLjMuanM/OTI2MyJdLCJuYW1lcyI6WyJyZXF1aXJlIl0sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrREFBMEMsZ0NBQWdDO0FBQzFFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0VBQXdELGtCQUFrQjtBQUMxRTtBQUNBLHlEQUFpRCxjQUFjO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBeUMsaUNBQWlDO0FBQzFFLHdIQUFnSCxtQkFBbUIsRUFBRTtBQUNySTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUEyQiwwQkFBMEIsRUFBRTtBQUN2RCx5Q0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBc0QsK0RBQStEOztBQUVySDtBQUNBOzs7QUFHQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNsRkE7Ozs7O0FBS0FBLG1CQUFPLENBQUMsMEdBQUQsQ0FBUCxDOzs7Ozs7Ozs7OztBQ0xBLHlDQUF5QywrRUFBK0Usa0NBQWtDLG1CQUFtQixHQUFHLEVBQUUsT0FBTyxrQ0FBa0Msa0lBQWtJLEdBQUcsRUFBRSxxQkFBcUIsRUFBRSwrR0FBK0csbUJBQW1C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QVMsNkVBQTZFLHVDQUF1QyxzQ0FBc0Msc0lBQXNJLEVBQUUsaUhBQWlILFNBQVMsNEZBQTRGLHVDQUF1QyxxREFBcUQsNkNBQTZDLFdBQVcseUJBQXlCLFNBQVMsMkVBQTJFLDZDQUE2QyxTQUFTLFNBQVMsUUFBUSxxQ0FBcUMscUNBQXFDLDJEQUEyRCxTQUFTLHFDQUFxQyxRQUFRLHlFQUF5RSx3REFBd0Qsb0JBQW9CLHdDQUF3Qyx1REFBdUQscUVBQXFFLHdEQUF3RCxXQUFXLGdGQUFnRix3REFBd0QsV0FBVyxxREFBcUQsU0FBUyxxQkFBcUIsUUFBUSxNQUFNLDhGQUE4RixrRUFBa0UsdURBQXVELDZDQUE2QyxpQkFBaUIsa0JBQWtCLCtCQUErQixlQUFlLHVDQUF1Qyx5RUFBeUUsOEJBQThCLDZFQUE2RSxzREFBc0QsYUFBYSxXQUFXLFNBQVMsNkNBQTZDLCtFQUErRSxpRkFBaUYsV0FBVyxTQUFTLDRCQUE0QixRQUFRLHVFQUF1RSxHQUFHLGVBQWUscURBQXFELG1DQUFtQyxFQUFFLE9BQU8sa0JBQWtCLEtBQUssR0FBRyxFQUFFLEM7Ozs7Ozs7Ozs7O0FDQTU1cVY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDMUJBLG1CQUFPLENBQUMsNkZBQW1GLEVBQUUsbUJBQU8sQ0FBQyxrTkFBdU8scU4iLCJmaWxlIjoiYWRtaW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIi9idWlsZC9cIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9hc3NldHMvanMvYWRtaW4uanNcIik7XG4iLCIvKiBcbiAqIFRvIGNoYW5nZSB0aGlzIGxpY2Vuc2UgaGVhZGVyLCBjaG9vc2UgTGljZW5zZSBIZWFkZXJzIGluIFByb2plY3QgUHJvcGVydGllcy5cbiAqIFRvIGNoYW5nZSB0aGlzIHRlbXBsYXRlIGZpbGUsIGNob29zZSBUb29scyB8IFRlbXBsYXRlc1xuICogYW5kIG9wZW4gdGhlIHRlbXBsYXRlIGluIHRoZSBlZGl0b3IuXG4gKi9cbnJlcXVpcmUoJ3NjcmlwdC1sb2FkZXIhLi9qc3RyZWUtMy4zLjMuanMnKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gXCJmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcXFwic3ltYm9sXFxcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXFxcInN5bWJvbFxcXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cXG5cXG4vKmdsb2JhbHMgalF1ZXJ5LCBkZWZpbmUsIG1vZHVsZSwgZXhwb3J0cywgcmVxdWlyZSwgd2luZG93LCBkb2N1bWVudCwgcG9zdE1lc3NhZ2UgKi9cXG4oZnVuY3Rpb24gKGZhY3RvcnkpIHtcXG4gIFxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcXG4gICAgZGVmaW5lKFsnanF1ZXJ5J10sIGZhY3RvcnkpO1xcbiAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSgnanF1ZXJ5JykpO1xcbiAgfSBlbHNlIHtcXG4gICAgZmFjdG9yeShqUXVlcnkpO1xcbiAgfVxcbn0pKGZ1bmN0aW9uICgkLCB1bmRlZmluZWQpIHtcXG4gIFxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG4gIC8qIVxcbiAgICoganNUcmVlIDMuMy4zXFxuICAgKiBodHRwOi8vanN0cmVlLmNvbS9cXG4gICAqXFxuICAgKiBDb3B5cmlnaHQgKGMpIDIwMTQgSXZhbiBCb3poYW5vdiAoaHR0cDovL3Zha2F0YS5jb20pXFxuICAgKlxcbiAgICogTGljZW5zZWQgc2FtZSBhcyBqcXVlcnkgLSB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlXFxuICAgKiAgIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXFxuICAgKi9cXG5cXG4gIC8qIVxcbiAgICogaWYgdXNpbmcganNsaW50IHBsZWFzZSBhbGxvdyBmb3IgdGhlIGpRdWVyeSBnbG9iYWwgYW5kIHVzZSBmb2xsb3dpbmcgb3B0aW9uczpcXG4gICAqIGpzbGludDogbG9vcGZ1bmM6IHRydWUsIGJyb3dzZXI6IHRydWUsIGFzczogdHJ1ZSwgYml0d2lzZTogdHJ1ZSwgY29udGludWU6IHRydWUsIG5vbWVuOiB0cnVlLCBwbHVzcGx1czogdHJ1ZSwgcmVnZXhwOiB0cnVlLCB1bnBhcmFtOiB0cnVlLCB0b2RvOiB0cnVlLCB3aGl0ZTogdHJ1ZVxcbiAgICovXFxuXFxuICAvKmpzaGludCAtVzA4MyAqL1xcbiAgLy8gcHJldmVudCBhbm90aGVyIGxvYWQ/IG1heWJlIHRoZXJlIGlzIGEgYmV0dGVyIHdheT9cXG5cXG4gIGlmICgkLmpzdHJlZSkge1xcbiAgICByZXR1cm47XFxuICB9XFxuICAvKipcXG4gICAqICMjIyBqc1RyZWUgY29yZSBmdW5jdGlvbmFsaXR5XFxuICAgKi9cXG4gIC8vIGludGVybmFsIHZhcmlhYmxlc1xcblxcblxcbiAgdmFyIGluc3RhbmNlX2NvdW50ZXIgPSAwLFxcbiAgICAgIGNjcF9ub2RlID0gZmFsc2UsXFxuICAgICAgY2NwX21vZGUgPSBmYWxzZSxcXG4gICAgICBjY3BfaW5zdCA9IGZhbHNlLFxcbiAgICAgIHRoZW1lc19sb2FkZWQgPSBbXSxcXG4gICAgICBzcmMgPSAkKCdzY3JpcHQ6bGFzdCcpLmF0dHIoJ3NyYycpLFxcbiAgICAgIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50OyAvLyBsb2NhbCB2YXJpYWJsZSBpcyBhbHdheXMgZmFzdGVyIHRvIGFjY2VzcyB0aGVuIGEgZ2xvYmFsXFxuXFxuICAvKipcXG4gICAqIGhvbGRzIGFsbCBqc3RyZWUgcmVsYXRlZCBmdW5jdGlvbnMgYW5kIHZhcmlhYmxlcywgaW5jbHVkaW5nIHRoZSBhY3R1YWwgY2xhc3MgYW5kIG1ldGhvZHMgdG8gY3JlYXRlLCBhY2Nlc3MgYW5kIG1hbmlwdWxhdGUgaW5zdGFuY2VzLlxcbiAgICogQG5hbWUgJC5qc3RyZWVcXG4gICAqL1xcblxcbiAgJC5qc3RyZWUgPSB7XFxuICAgIC8qKlxcbiAgICAgKiBzcGVjaWZpZXMgdGhlIGpzdHJlZSB2ZXJzaW9uIGluIHVzZVxcbiAgICAgKiBAbmFtZSAkLmpzdHJlZS52ZXJzaW9uXFxuICAgICAqL1xcbiAgICB2ZXJzaW9uOiAnMy4zLjMnLFxcblxcbiAgICAvKipcXG4gICAgICogaG9sZHMgYWxsIHRoZSBkZWZhdWx0IG9wdGlvbnMgdXNlZCB3aGVuIGNyZWF0aW5nIG5ldyBpbnN0YW5jZXNcXG4gICAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHNcXG4gICAgICovXFxuICAgIGRlZmF1bHRzOiB7XFxuICAgICAgLyoqXFxuICAgICAgICogY29uZmlndXJlIHdoaWNoIHBsdWdpbnMgd2lsbCBiZSBhY3RpdmUgb24gYW4gaW5zdGFuY2UuIFNob3VsZCBiZSBhbiBhcnJheSBvZiBzdHJpbmdzLCB3aGVyZSBlYWNoIGVsZW1lbnQgaXMgYSBwbHVnaW4gbmFtZS4gVGhlIGRlZmF1bHQgaXMgYFtdYFxcbiAgICAgICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLnBsdWdpbnNcXG4gICAgICAgKi9cXG4gICAgICBwbHVnaW5zOiBbXVxcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogc3RvcmVzIGFsbCBsb2FkZWQganN0cmVlIHBsdWdpbnMgKHVzZWQgaW50ZXJuYWxseSlcXG4gICAgICogQG5hbWUgJC5qc3RyZWUucGx1Z2luc1xcbiAgICAgKi9cXG4gICAgcGx1Z2luczoge30sXFxuICAgIHBhdGg6IHNyYyAmJiBzcmMuaW5kZXhPZignLycpICE9PSAtMSA/IHNyYy5yZXBsYWNlKC9cXFxcL1teXFxcXC9dKyQvLCAnJykgOiAnJyxcXG4gICAgaWRyZWdleDogL1tcXFxcXFxcXDomIV58KClcXFxcW1xcXFxdPD5AKicrfiNcXFwiOy4sPVxcXFwtIFxcXFwvJHt9JT9gXS9nLFxcbiAgICByb290OiAnIydcXG4gIH07XFxuICAvKipcXG4gICAqIGNyZWF0ZXMgYSBqc3RyZWUgaW5zdGFuY2VcXG4gICAqIEBuYW1lICQuanN0cmVlLmNyZWF0ZShlbCBbLCBvcHRpb25zXSlcXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudHxqUXVlcnl8U3RyaW5nfSBlbCB0aGUgZWxlbWVudCB0byBjcmVhdGUgdGhlIGluc3RhbmNlIG9uLCBjYW4gYmUgalF1ZXJ5IGV4dGVuZGVkIG9yIGEgc2VsZWN0b3JcXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIG9wdGlvbnMgZm9yIHRoaXMgaW5zdGFuY2UgKGV4dGVuZHMgYCQuanN0cmVlLmRlZmF1bHRzYClcXG4gICAqIEByZXR1cm4ge2pzVHJlZX0gdGhlIG5ldyBpbnN0YW5jZVxcbiAgICovXFxuXFxuICAkLmpzdHJlZS5jcmVhdGUgPSBmdW5jdGlvbiAoZWwsIG9wdGlvbnMpIHtcXG4gICAgdmFyIHRtcCA9IG5ldyAkLmpzdHJlZS5jb3JlKCsraW5zdGFuY2VfY291bnRlciksXFxuICAgICAgICBvcHQgPSBvcHRpb25zO1xcbiAgICBvcHRpb25zID0gJC5leHRlbmQodHJ1ZSwge30sICQuanN0cmVlLmRlZmF1bHRzLCBvcHRpb25zKTtcXG5cXG4gICAgaWYgKG9wdCAmJiBvcHQucGx1Z2lucykge1xcbiAgICAgIG9wdGlvbnMucGx1Z2lucyA9IG9wdC5wbHVnaW5zO1xcbiAgICB9XFxuXFxuICAgICQuZWFjaChvcHRpb25zLnBsdWdpbnMsIGZ1bmN0aW9uIChpLCBrKSB7XFxuICAgICAgaWYgKGkgIT09ICdjb3JlJykge1xcbiAgICAgICAgdG1wID0gdG1wLnBsdWdpbihrLCBvcHRpb25zW2tdKTtcXG4gICAgICB9XFxuICAgIH0pO1xcbiAgICAkKGVsKS5kYXRhKCdqc3RyZWUnLCB0bXApO1xcbiAgICB0bXAuaW5pdChlbCwgb3B0aW9ucyk7XFxuICAgIHJldHVybiB0bXA7XFxuICB9O1xcbiAgLyoqXFxuICAgKiByZW1vdmUgYWxsIHRyYWNlcyBvZiBqc3RyZWUgZnJvbSB0aGUgRE9NIGFuZCBkZXN0cm95IGFsbCBpbnN0YW5jZXNcXG4gICAqIEBuYW1lICQuanN0cmVlLmRlc3Ryb3koKVxcbiAgICovXFxuXFxuXFxuICAkLmpzdHJlZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xcbiAgICAkKCcuanN0cmVlOmpzdHJlZScpLmpzdHJlZSgnZGVzdHJveScpO1xcbiAgICAkKGRvY3VtZW50KS5vZmYoJy5qc3RyZWUnKTtcXG4gIH07XFxuICAvKipcXG4gICAqIHRoZSBqc3RyZWUgY2xhc3MgY29uc3RydWN0b3IsIHVzZWQgb25seSBpbnRlcm5hbGx5XFxuICAgKiBAcHJpdmF0ZVxcbiAgICogQG5hbWUgJC5qc3RyZWUuY29yZShpZClcXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpZCB0aGlzIGluc3RhbmNlJ3MgaW5kZXhcXG4gICAqL1xcblxcblxcbiAgJC5qc3RyZWUuY29yZSA9IGZ1bmN0aW9uIChpZCkge1xcbiAgICB0aGlzLl9pZCA9IGlkO1xcbiAgICB0aGlzLl9jbnQgPSAwO1xcbiAgICB0aGlzLl93cmsgPSBudWxsO1xcbiAgICB0aGlzLl9kYXRhID0ge1xcbiAgICAgIGNvcmU6IHtcXG4gICAgICAgIHRoZW1lczoge1xcbiAgICAgICAgICBuYW1lOiBmYWxzZSxcXG4gICAgICAgICAgZG90czogZmFsc2UsXFxuICAgICAgICAgIGljb25zOiBmYWxzZSxcXG4gICAgICAgICAgZWxsaXBzaXM6IGZhbHNlXFxuICAgICAgICB9LFxcbiAgICAgICAgc2VsZWN0ZWQ6IFtdLFxcbiAgICAgICAgbGFzdF9lcnJvcjoge30sXFxuICAgICAgICB3b3JraW5nOiBmYWxzZSxcXG4gICAgICAgIHdvcmtlcl9xdWV1ZTogW10sXFxuICAgICAgICBmb2N1c2VkOiBudWxsXFxuICAgICAgfVxcbiAgICB9O1xcbiAgfTtcXG4gIC8qKlxcbiAgICogZ2V0IGEgcmVmZXJlbmNlIHRvIGFuIGV4aXN0aW5nIGluc3RhbmNlXFxuICAgKlxcbiAgICogX19FeGFtcGxlc19fXFxuICAgKlxcbiAgICpcXHQvLyBwcm92aWRlZCBhIGNvbnRhaW5lciB3aXRoIGFuIElEIG9mIFxcXCJ0cmVlXFxcIiwgYW5kIGEgbmVzdGVkIG5vZGUgd2l0aCBhbiBJRCBvZiBcXFwiYnJhbmNoXFxcIlxcbiAgICpcXHQvLyBhbGwgb2YgdGhlcmUgd2lsbCByZXR1cm4gdGhlIHNhbWUgaW5zdGFuY2VcXG4gICAqXFx0JC5qc3RyZWUucmVmZXJlbmNlKCd0cmVlJyk7XFxuICAgKlxcdCQuanN0cmVlLnJlZmVyZW5jZSgnI3RyZWUnKTtcXG4gICAqXFx0JC5qc3RyZWUucmVmZXJlbmNlKCQoJyN0cmVlJykpO1xcbiAgICpcXHQkLmpzdHJlZS5yZWZlcmVuY2UoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SUQoJ3RyZWUnKSk7XFxuICAgKlxcdCQuanN0cmVlLnJlZmVyZW5jZSgnYnJhbmNoJyk7XFxuICAgKlxcdCQuanN0cmVlLnJlZmVyZW5jZSgnI2JyYW5jaCcpO1xcbiAgICpcXHQkLmpzdHJlZS5yZWZlcmVuY2UoJCgnI2JyYW5jaCcpKTtcXG4gICAqXFx0JC5qc3RyZWUucmVmZXJlbmNlKGRvY3VtZW50LmdldEVsZW1lbnRCeUlEKCdicmFuY2gnKSk7XFxuICAgKlxcbiAgICogQG5hbWUgJC5qc3RyZWUucmVmZXJlbmNlKG5lZWRsZSlcXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudHxqUXVlcnl8U3RyaW5nfSBuZWVkbGVcXG4gICAqIEByZXR1cm4ge2pzVHJlZXxudWxsfSB0aGUgaW5zdGFuY2Ugb3IgYG51bGxgIGlmIG5vdCBmb3VuZFxcbiAgICovXFxuXFxuXFxuICAkLmpzdHJlZS5yZWZlcmVuY2UgPSBmdW5jdGlvbiAobmVlZGxlKSB7XFxuICAgIHZhciB0bXAgPSBudWxsLFxcbiAgICAgICAgb2JqID0gbnVsbDtcXG5cXG4gICAgaWYgKG5lZWRsZSAmJiBuZWVkbGUuaWQgJiYgKCFuZWVkbGUudGFnTmFtZSB8fCAhbmVlZGxlLm5vZGVUeXBlKSkge1xcbiAgICAgIG5lZWRsZSA9IG5lZWRsZS5pZDtcXG4gICAgfVxcblxcbiAgICBpZiAoIW9iaiB8fCAhb2JqLmxlbmd0aCkge1xcbiAgICAgIHRyeSB7XFxuICAgICAgICBvYmogPSAkKG5lZWRsZSk7XFxuICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxcbiAgICB9XFxuXFxuICAgIGlmICghb2JqIHx8ICFvYmoubGVuZ3RoKSB7XFxuICAgICAgdHJ5IHtcXG4gICAgICAgIG9iaiA9ICQoJyMnICsgbmVlZGxlLnJlcGxhY2UoJC5qc3RyZWUuaWRyZWdleCwgJ1xcXFxcXFxcJCYnKSk7XFxuICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxcbiAgICB9XFxuXFxuICAgIGlmIChvYmogJiYgb2JqLmxlbmd0aCAmJiAob2JqID0gb2JqLmNsb3Nlc3QoJy5qc3RyZWUnKSkubGVuZ3RoICYmIChvYmogPSBvYmouZGF0YSgnanN0cmVlJykpKSB7XFxuICAgICAgdG1wID0gb2JqO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICQoJy5qc3RyZWUnKS5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciBpbnN0ID0gJCh0aGlzKS5kYXRhKCdqc3RyZWUnKTtcXG5cXG4gICAgICAgIGlmIChpbnN0ICYmIGluc3QuX21vZGVsLmRhdGFbbmVlZGxlXSkge1xcbiAgICAgICAgICB0bXAgPSBpbnN0O1xcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHRtcDtcXG4gIH07XFxuICAvKipcXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZSwgZ2V0IGFuIGluc3RhbmNlIG9yIGludm9rZSBhIGNvbW1hbmQgb24gYSBpbnN0YW5jZS5cXG4gICAqXFxuICAgKiBJZiB0aGVyZSBpcyBubyBpbnN0YW5jZSBhc3NvY2lhdGVkIHdpdGggdGhlIGN1cnJlbnQgbm9kZSBhIG5ldyBvbmUgaXMgY3JlYXRlZCBhbmQgYGFyZ2AgaXMgdXNlZCB0byBleHRlbmQgYCQuanN0cmVlLmRlZmF1bHRzYCBmb3IgdGhpcyBuZXcgaW5zdGFuY2UuIFRoZXJlIHdvdWxkIGJlIG5vIHJldHVybiB2YWx1ZSAoY2hhaW5pbmcgaXMgbm90IGJyb2tlbikuXFxuICAgKlxcbiAgICogSWYgdGhlcmUgaXMgYW4gZXhpc3RpbmcgaW5zdGFuY2UgYW5kIGBhcmdgIGlzIGEgc3RyaW5nIHRoZSBjb21tYW5kIHNwZWNpZmllZCBieSBgYXJnYCBpcyBleGVjdXRlZCBvbiB0aGUgaW5zdGFuY2UsIHdpdGggYW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgZnVuY3Rpb24uIElmIHRoZSBmdW5jdGlvbiByZXR1cm5zIGEgdmFsdWUgaXQgd2lsbCBiZSByZXR1cm5lZCAoY2hhaW5pbmcgY291bGQgYnJlYWsgZGVwZW5kaW5nIG9uIGZ1bmN0aW9uKS5cXG4gICAqXFxuICAgKiBJZiB0aGVyZSBpcyBhbiBleGlzdGluZyBpbnN0YW5jZSBhbmQgYGFyZ2AgaXMgbm90IGEgc3RyaW5nIHRoZSBpbnN0YW5jZSBpdHNlbGYgaXMgcmV0dXJuZWQgKHNpbWlsYXIgdG8gYCQuanN0cmVlLnJlZmVyZW5jZWApLlxcbiAgICpcXG4gICAqIEluIGFueSBvdGhlciBjYXNlIC0gbm90aGluZyBpcyByZXR1cm5lZCBhbmQgY2hhaW5pbmcgaXMgbm90IGJyb2tlbi5cXG4gICAqXFxuICAgKiBfX0V4YW1wbGVzX19cXG4gICAqXFxuICAgKlxcdCQoJyN0cmVlMScpLmpzdHJlZSgpOyAvLyBjcmVhdGVzIGFuIGluc3RhbmNlXFxuICAgKlxcdCQoJyN0cmVlMicpLmpzdHJlZSh7IHBsdWdpbnMgOiBbXSB9KTsgLy8gY3JlYXRlIGFuIGluc3RhbmNlIHdpdGggc29tZSBvcHRpb25zXFxuICAgKlxcdCQoJyN0cmVlMScpLmpzdHJlZSgnb3Blbl9ub2RlJywgJyNicmFuY2hfMScpOyAvLyBjYWxsIGEgbWV0aG9kIG9uIGFuIGV4aXN0aW5nIGluc3RhbmNlLCBwYXNzaW5nIGFkZGl0aW9uYWwgYXJndW1lbnRzXFxuICAgKlxcdCQoJyN0cmVlMicpLmpzdHJlZSgpOyAvLyBnZXQgYW4gZXhpc3RpbmcgaW5zdGFuY2UgKG9yIGNyZWF0ZSBhbiBpbnN0YW5jZSlcXG4gICAqXFx0JCgnI3RyZWUyJykuanN0cmVlKHRydWUpOyAvLyBnZXQgYW4gZXhpc3RpbmcgaW5zdGFuY2UgKHdpbGwgbm90IGNyZWF0ZSBuZXcgaW5zdGFuY2UpXFxuICAgKlxcdCQoJyNicmFuY2hfMScpLmpzdHJlZSgpLnNlbGVjdF9ub2RlKCcjYnJhbmNoXzEnKTsgLy8gZ2V0IGFuIGluc3RhbmNlICh1c2luZyBhIG5lc3RlZCBlbGVtZW50IGFuZCBjYWxsIGEgbWV0aG9kKVxcbiAgICpcXG4gICAqIEBuYW1lICQoKS5qc3RyZWUoW2FyZ10pXFxuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGFyZ1xcbiAgICogQHJldHVybiB7TWl4ZWR9XFxuICAgKi9cXG5cXG5cXG4gICQuZm4uanN0cmVlID0gZnVuY3Rpb24gKGFyZykge1xcbiAgICAvLyBjaGVjayBmb3Igc3RyaW5nIGFyZ3VtZW50XFxuICAgIHZhciBpc19tZXRob2QgPSB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyxcXG4gICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLFxcbiAgICAgICAgcmVzdWx0ID0gbnVsbDtcXG5cXG4gICAgaWYgKGFyZyA9PT0gdHJ1ZSAmJiAhdGhpcy5sZW5ndGgpIHtcXG4gICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG5cXG4gICAgdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAvLyBnZXQgdGhlIGluc3RhbmNlIChpZiB0aGVyZSBpcyBvbmUpIGFuZCBtZXRob2QgKGlmIGl0IGV4aXN0cylcXG4gICAgICB2YXIgaW5zdGFuY2UgPSAkLmpzdHJlZS5yZWZlcmVuY2UodGhpcyksXFxuICAgICAgICAgIG1ldGhvZCA9IGlzX21ldGhvZCAmJiBpbnN0YW5jZSA/IGluc3RhbmNlW2FyZ10gOiBudWxsOyAvLyBpZiBjYWxsaW5nIGEgbWV0aG9kLCBhbmQgbWV0aG9kIGlzIGF2YWlsYWJsZSAtIGV4ZWN1dGUgb24gdGhlIGluc3RhbmNlXFxuXFxuICAgICAgcmVzdWx0ID0gaXNfbWV0aG9kICYmIG1ldGhvZCA/IG1ldGhvZC5hcHBseShpbnN0YW5jZSwgYXJncykgOiBudWxsOyAvLyBpZiB0aGVyZSBpcyBubyBpbnN0YW5jZSBhbmQgbm8gbWV0aG9kIGlzIGJlaW5nIGNhbGxlZCAtIGNyZWF0ZSBvbmVcXG5cXG4gICAgICBpZiAoIWluc3RhbmNlICYmICFpc19tZXRob2QgJiYgKGFyZyA9PT0gdW5kZWZpbmVkIHx8ICQuaXNQbGFpbk9iamVjdChhcmcpKSkge1xcbiAgICAgICAgJC5qc3RyZWUuY3JlYXRlKHRoaXMsIGFyZyk7XFxuICAgICAgfSAvLyBpZiB0aGVyZSBpcyBhbiBpbnN0YW5jZSBhbmQgbm8gbWV0aG9kIGlzIGNhbGxlZCAtIHJldHVybiB0aGUgaW5zdGFuY2VcXG5cXG5cXG4gICAgICBpZiAoaW5zdGFuY2UgJiYgIWlzX21ldGhvZCB8fCBhcmcgPT09IHRydWUpIHtcXG4gICAgICAgIHJlc3VsdCA9IGluc3RhbmNlIHx8IGZhbHNlO1xcbiAgICAgIH0gLy8gaWYgdGhlcmUgd2FzIGEgbWV0aG9kIGNhbGwgd2hpY2ggcmV0dXJuZWQgYSByZXN1bHQgLSBicmVhayBhbmQgcmV0dXJuIHRoZSB2YWx1ZVxcblxcblxcbiAgICAgIGlmIChyZXN1bHQgIT09IG51bGwgJiYgcmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuICAgIH0pOyAvLyBpZiB0aGVyZSB3YXMgYSBtZXRob2QgY2FsbCB3aXRoIGEgdmFsaWQgcmV0dXJuIHZhbHVlIC0gcmV0dXJuIHRoYXQsIG90aGVyd2lzZSBjb250aW51ZSB0aGUgY2hhaW5cXG5cXG4gICAgcmV0dXJuIHJlc3VsdCAhPT0gbnVsbCAmJiByZXN1bHQgIT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IHRoaXM7XFxuICB9O1xcbiAgLyoqXFxuICAgKiB1c2VkIHRvIGZpbmQgZWxlbWVudHMgY29udGFpbmluZyBhbiBpbnN0YW5jZVxcbiAgICpcXG4gICAqIF9fRXhhbXBsZXNfX1xcbiAgICpcXG4gICAqXFx0JCgnZGl2OmpzdHJlZScpLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICpcXHRcXHQkKHRoaXMpLmpzdHJlZSgnZGVzdHJveScpO1xcbiAgICpcXHR9KTtcXG4gICAqXFxuICAgKiBAbmFtZSAkKCc6anN0cmVlJylcXG4gICAqIEByZXR1cm4ge2pRdWVyeX1cXG4gICAqL1xcblxcblxcbiAgJC5leHByLnBzZXVkb3MuanN0cmVlID0gJC5leHByLmNyZWF0ZVBzZXVkbyhmdW5jdGlvbiAoc2VhcmNoKSB7XFxuICAgIHJldHVybiBmdW5jdGlvbiAoYSkge1xcbiAgICAgIHJldHVybiAkKGEpLmhhc0NsYXNzKCdqc3RyZWUnKSAmJiAkKGEpLmRhdGEoJ2pzdHJlZScpICE9PSB1bmRlZmluZWQ7XFxuICAgIH07XFxuICB9KTtcXG4gIC8qKlxcbiAgICogc3RvcmVzIGFsbCBkZWZhdWx0cyBmb3IgdGhlIGNvcmVcXG4gICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvcmVcXG4gICAqL1xcblxcbiAgJC5qc3RyZWUuZGVmYXVsdHMuY29yZSA9IHtcXG4gICAgLyoqXFxuICAgICAqIGRhdGEgY29uZmlndXJhdGlvblxcbiAgICAgKlxcbiAgICAgKiBJZiBsZWZ0IGFzIGBmYWxzZWAgdGhlIEhUTUwgaW5zaWRlIHRoZSBqc3RyZWUgY29udGFpbmVyIGVsZW1lbnQgaXMgdXNlZCB0byBwb3B1bGF0ZSB0aGUgdHJlZSAodGhhdCBzaG91bGQgYmUgYW4gdW5vcmRlcmVkIGxpc3Qgd2l0aCBsaXN0IGl0ZW1zKS5cXG4gICAgICpcXG4gICAgICogWW91IGNhbiBhbHNvIHBhc3MgaW4gYSBIVE1MIHN0cmluZyBvciBhIEpTT04gYXJyYXkgaGVyZS5cXG4gICAgICpcXG4gICAgICogSXQgaXMgcG9zc2libGUgdG8gcGFzcyBpbiBhIHN0YW5kYXJkIGpRdWVyeS1saWtlIEFKQVggY29uZmlnIGFuZCBqc3RyZWUgd2lsbCBhdXRvbWF0aWNhbGx5IGRldGVybWluZSBpZiB0aGUgcmVzcG9uc2UgaXMgSlNPTiBvciBIVE1MIGFuZCB1c2UgdGhhdCB0byBwb3B1bGF0ZSB0aGUgdHJlZS5cXG4gICAgICogSW4gYWRkaXRpb24gdG8gdGhlIHN0YW5kYXJkIGpRdWVyeSBhamF4IG9wdGlvbnMgaGVyZSB5b3UgY2FuIHN1cHB5IGZ1bmN0aW9ucyBmb3IgYGRhdGFgIGFuZCBgdXJsYCwgdGhlIGZ1bmN0aW9ucyB3aWxsIGJlIHJ1biBpbiB0aGUgY3VycmVudCBpbnN0YW5jZSdzIHNjb3BlIGFuZCBhIHBhcmFtIHdpbGwgYmUgcGFzc2VkIGluZGljYXRpbmcgd2hpY2ggbm9kZSBpcyBiZWluZyBsb2FkZWQsIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhvc2UgZnVuY3Rpb25zIHdpbGwgYmUgdXNlZC5cXG4gICAgICpcXG4gICAgICogVGhlIGxhc3Qgb3B0aW9uIGlzIHRvIHNwZWNpZnkgYSBmdW5jdGlvbiwgdGhhdCBmdW5jdGlvbiB3aWxsIHJlY2VpdmUgdGhlIG5vZGUgYmVpbmcgbG9hZGVkIGFzIGFyZ3VtZW50IGFuZCBhIHNlY29uZCBwYXJhbSB3aGljaCBpcyBhIGZ1bmN0aW9uIHdoaWNoIHNob3VsZCBiZSBjYWxsZWQgd2l0aCB0aGUgcmVzdWx0LlxcbiAgICAgKlxcbiAgICAgKiBfX0V4YW1wbGVzX19cXG4gICAgICpcXG4gICAgICpcXHQvLyBBSkFYXFxuICAgICAqXFx0JCgnI3RyZWUnKS5qc3RyZWUoe1xcbiAgICAgKlxcdFxcdCdjb3JlJyA6IHtcXG4gICAgICpcXHRcXHRcXHQnZGF0YScgOiB7XFxuICAgICAqXFx0XFx0XFx0XFx0J3VybCcgOiAnL2dldC9jaGlsZHJlbi8nLFxcbiAgICAgKlxcdFxcdFxcdFxcdCdkYXRhJyA6IGZ1bmN0aW9uIChub2RlKSB7XFxuICAgICAqXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHsgJ2lkJyA6IG5vZGUuaWQgfTtcXG4gICAgICpcXHRcXHRcXHRcXHR9XFxuICAgICAqXFx0XFx0XFx0fVxcbiAgICAgKlxcdFxcdH0pO1xcbiAgICAgKlxcbiAgICAgKlxcdC8vIGRpcmVjdCBkYXRhXFxuICAgICAqXFx0JCgnI3RyZWUnKS5qc3RyZWUoe1xcbiAgICAgKlxcdFxcdCdjb3JlJyA6IHtcXG4gICAgICpcXHRcXHRcXHQnZGF0YScgOiBbXFxuICAgICAqXFx0XFx0XFx0XFx0J1NpbXBsZSByb290IG5vZGUnLFxcbiAgICAgKlxcdFxcdFxcdFxcdHtcXG4gICAgICpcXHRcXHRcXHRcXHRcXHQnaWQnIDogJ25vZGVfMicsXFxuICAgICAqXFx0XFx0XFx0XFx0XFx0J3RleHQnIDogJ1Jvb3Qgbm9kZSB3aXRoIG9wdGlvbnMnLFxcbiAgICAgKlxcdFxcdFxcdFxcdFxcdCdzdGF0ZScgOiB7ICdvcGVuZWQnIDogdHJ1ZSwgJ3NlbGVjdGVkJyA6IHRydWUgfSxcXG4gICAgICpcXHRcXHRcXHRcXHRcXHQnY2hpbGRyZW4nIDogWyB7ICd0ZXh0JyA6ICdDaGlsZCAxJyB9LCAnQ2hpbGQgMiddXFxuICAgICAqXFx0XFx0XFx0XFx0fVxcbiAgICAgKlxcdFxcdFxcdF1cXG4gICAgICpcXHRcXHR9XFxuICAgICAqXFx0fSk7XFxuICAgICAqXFxuICAgICAqXFx0Ly8gZnVuY3Rpb25cXG4gICAgICpcXHQkKCcjdHJlZScpLmpzdHJlZSh7XFxuICAgICAqXFx0XFx0J2NvcmUnIDoge1xcbiAgICAgKlxcdFxcdFxcdCdkYXRhJyA6IGZ1bmN0aW9uIChvYmosIGNhbGxiYWNrKSB7XFxuICAgICAqXFx0XFx0XFx0XFx0Y2FsbGJhY2suY2FsbCh0aGlzLCBbJ1Jvb3QgMScsICdSb290IDInXSk7XFxuICAgICAqXFx0XFx0XFx0fVxcbiAgICAgKlxcdFxcdH0pO1xcbiAgICAgKlxcbiAgICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb3JlLmRhdGFcXG4gICAgICovXFxuICAgIGRhdGE6IGZhbHNlLFxcblxcbiAgICAvKipcXG4gICAgICogY29uZmlndXJlIHRoZSB2YXJpb3VzIHN0cmluZ3MgdXNlZCB0aHJvdWdob3V0IHRoZSB0cmVlXFxuICAgICAqXFxuICAgICAqIFlvdSBjYW4gdXNlIGFuIG9iamVjdCB3aGVyZSB0aGUga2V5IGlzIHRoZSBzdHJpbmcgeW91IG5lZWQgdG8gcmVwbGFjZSBhbmQgdGhlIHZhbHVlIGlzIHlvdXIgcmVwbGFjZW1lbnQuXFxuICAgICAqIEFub3RoZXIgb3B0aW9uIGlzIHRvIHNwZWNpZnkgYSBmdW5jdGlvbiB3aGljaCB3aWxsIGJlIGNhbGxlZCB3aXRoIGFuIGFyZ3VtZW50IG9mIHRoZSBuZWVkZWQgc3RyaW5nIGFuZCBzaG91bGQgcmV0dXJuIHRoZSByZXBsYWNlbWVudC5cXG4gICAgICogSWYgbGVmdCBhcyBgZmFsc2VgIG5vIHJlcGxhY2VtZW50IGlzIG1hZGUuXFxuICAgICAqXFxuICAgICAqIF9fRXhhbXBsZXNfX1xcbiAgICAgKlxcbiAgICAgKlxcdCQoJyN0cmVlJykuanN0cmVlKHtcXG4gICAgICpcXHRcXHQnY29yZScgOiB7XFxuICAgICAqXFx0XFx0XFx0J3N0cmluZ3MnIDoge1xcbiAgICAgKlxcdFxcdFxcdFxcdCdMb2FkaW5nIC4uLicgOiAnUGxlYXNlIHdhaXQgLi4uJ1xcbiAgICAgKlxcdFxcdFxcdH1cXG4gICAgICpcXHRcXHR9XFxuICAgICAqXFx0fSk7XFxuICAgICAqXFxuICAgICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvcmUuc3RyaW5nc1xcbiAgICAgKi9cXG4gICAgc3RyaW5nczogZmFsc2UsXFxuXFxuICAgIC8qKlxcbiAgICAgKiBkZXRlcm1pbmVzIHdoYXQgaGFwcGVucyB3aGVuIGEgdXNlciB0cmllcyB0byBtb2RpZnkgdGhlIHN0cnVjdHVyZSBvZiB0aGUgdHJlZVxcbiAgICAgKiBJZiBsZWZ0IGFzIGBmYWxzZWAgYWxsIG9wZXJhdGlvbnMgbGlrZSBjcmVhdGUsIHJlbmFtZSwgZGVsZXRlLCBtb3ZlIG9yIGNvcHkgYXJlIHByZXZlbnRlZC5cXG4gICAgICogWW91IGNhbiBzZXQgdGhpcyB0byBgdHJ1ZWAgdG8gYWxsb3cgYWxsIGludGVyYWN0aW9ucyBvciB1c2UgYSBmdW5jdGlvbiB0byBoYXZlIGJldHRlciBjb250cm9sLlxcbiAgICAgKlxcbiAgICAgKiBfX0V4YW1wbGVzX19cXG4gICAgICpcXG4gICAgICpcXHQkKCcjdHJlZScpLmpzdHJlZSh7XFxuICAgICAqXFx0XFx0J2NvcmUnIDoge1xcbiAgICAgKlxcdFxcdFxcdCdjaGVja19jYWxsYmFjaycgOiBmdW5jdGlvbiAob3BlcmF0aW9uLCBub2RlLCBub2RlX3BhcmVudCwgbm9kZV9wb3NpdGlvbiwgbW9yZSkge1xcbiAgICAgKlxcdFxcdFxcdFxcdC8vIG9wZXJhdGlvbiBjYW4gYmUgJ2NyZWF0ZV9ub2RlJywgJ3JlbmFtZV9ub2RlJywgJ2RlbGV0ZV9ub2RlJywgJ21vdmVfbm9kZScgb3IgJ2NvcHlfbm9kZSdcXG4gICAgICpcXHRcXHRcXHRcXHQvLyBpbiBjYXNlIG9mICdyZW5hbWVfbm9kZScgbm9kZV9wb3NpdGlvbiBpcyBmaWxsZWQgd2l0aCB0aGUgbmV3IG5vZGUgbmFtZVxcbiAgICAgKlxcdFxcdFxcdFxcdHJldHVybiBvcGVyYXRpb24gPT09ICdyZW5hbWVfbm9kZScgPyB0cnVlIDogZmFsc2U7XFxuICAgICAqXFx0XFx0XFx0fVxcbiAgICAgKlxcdFxcdH1cXG4gICAgICpcXHR9KTtcXG4gICAgICpcXG4gICAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY29yZS5jaGVja19jYWxsYmFja1xcbiAgICAgKi9cXG4gICAgY2hlY2tfY2FsbGJhY2s6IGZhbHNlLFxcblxcbiAgICAvKipcXG4gICAgICogYSBjYWxsYmFjayBjYWxsZWQgd2l0aCBhIHNpbmdsZSBvYmplY3QgcGFyYW1ldGVyIGluIHRoZSBpbnN0YW5jZSdzIHNjb3BlIHdoZW4gc29tZXRoaW5nIGdvZXMgd3JvbmcgKG9wZXJhdGlvbiBwcmV2ZW50ZWQsIGFqYXggZmFpbGVkLCBldGMpXFxuICAgICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvcmUuZXJyb3JcXG4gICAgICovXFxuICAgIGVycm9yOiAkLm5vb3AsXFxuXFxuICAgIC8qKlxcbiAgICAgKiB0aGUgb3BlbiAvIGNsb3NlIGFuaW1hdGlvbiBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMgLSBzZXQgdGhpcyB0byBgZmFsc2VgIHRvIGRpc2FibGUgdGhlIGFuaW1hdGlvbiAoZGVmYXVsdCBpcyBgMjAwYClcXG4gICAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY29yZS5hbmltYXRpb25cXG4gICAgICovXFxuICAgIGFuaW1hdGlvbjogMjAwLFxcblxcbiAgICAvKipcXG4gICAgICogYSBib29sZWFuIGluZGljYXRpbmcgaWYgbXVsdGlwbGUgbm9kZXMgY2FuIGJlIHNlbGVjdGVkXFxuICAgICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvcmUubXVsdGlwbGVcXG4gICAgICovXFxuICAgIG11bHRpcGxlOiB0cnVlLFxcblxcbiAgICAvKipcXG4gICAgICogdGhlbWUgY29uZmlndXJhdGlvbiBvYmplY3RcXG4gICAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY29yZS50aGVtZXNcXG4gICAgICovXFxuICAgIHRoZW1lczoge1xcbiAgICAgIC8qKlxcbiAgICAgICAqIHRoZSBuYW1lIG9mIHRoZSB0aGVtZSB0byB1c2UgKGlmIGxlZnQgYXMgYGZhbHNlYCB0aGUgZGVmYXVsdCB0aGVtZSBpcyB1c2VkKVxcbiAgICAgICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvcmUudGhlbWVzLm5hbWVcXG4gICAgICAgKi9cXG4gICAgICBuYW1lOiBmYWxzZSxcXG5cXG4gICAgICAvKipcXG4gICAgICAgKiB0aGUgVVJMIG9mIHRoZSB0aGVtZSdzIENTUyBmaWxlLCBsZWF2ZSB0aGlzIGFzIGBmYWxzZWAgaWYgeW91IGhhdmUgbWFudWFsbHkgaW5jbHVkZWQgdGhlIHRoZW1lIENTUyAocmVjb21tZW5kZWQpLiBZb3UgY2FuIHNldCB0aGlzIHRvIGB0cnVlYCB0b28gd2hpY2ggd2lsbCB0cnkgdG8gYXV0b2xvYWQgdGhlIHRoZW1lLlxcbiAgICAgICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvcmUudGhlbWVzLnVybFxcbiAgICAgICAqL1xcbiAgICAgIHVybDogZmFsc2UsXFxuXFxuICAgICAgLyoqXFxuICAgICAgICogdGhlIGxvY2F0aW9uIG9mIGFsbCBqc3RyZWUgdGhlbWVzIC0gb25seSB1c2VkIGlmIGB1cmxgIGlzIHNldCB0byBgdHJ1ZWBcXG4gICAgICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb3JlLnRoZW1lcy5kaXJcXG4gICAgICAgKi9cXG4gICAgICBkaXI6IGZhbHNlLFxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIGNvbm5lY3RpbmcgZG90cyBhcmUgc2hvd25cXG4gICAgICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb3JlLnRoZW1lcy5kb3RzXFxuICAgICAgICovXFxuICAgICAgZG90czogdHJ1ZSxcXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiBub2RlIGljb25zIGFyZSBzaG93blxcbiAgICAgICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvcmUudGhlbWVzLmljb25zXFxuICAgICAgICovXFxuICAgICAgaWNvbnM6IHRydWUsXFxuXFxuICAgICAgLyoqXFxuICAgICAgICogYSBib29sZWFuIGluZGljYXRpbmcgaWYgbm9kZSBlbGxpcHNpcyBzaG91bGQgYmUgc2hvd24gLSB0aGlzIG9ubHkgd29ya3Mgd2l0aCBhIGZpeGVkIHdpdGggb24gdGhlIGNvbnRhaW5lclxcbiAgICAgICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvcmUudGhlbWVzLmVsbGlwc2lzXFxuICAgICAgICovXFxuICAgICAgZWxsaXBzaXM6IGZhbHNlLFxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoZSB0cmVlIGJhY2tncm91bmQgaXMgc3RyaXBlZFxcbiAgICAgICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvcmUudGhlbWVzLnN0cmlwZXNcXG4gICAgICAgKi9cXG4gICAgICBzdHJpcGVzOiBmYWxzZSxcXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBhIHN0cmluZyAob3IgYm9vbGVhbiBgZmFsc2VgKSBzcGVjaWZ5aW5nIHRoZSB0aGVtZSB2YXJpYW50IHRvIHVzZSAoaWYgdGhlIHRoZW1lIHN1cHBvcnRzIHZhcmlhbnRzKVxcbiAgICAgICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvcmUudGhlbWVzLnZhcmlhbnRcXG4gICAgICAgKi9cXG4gICAgICB2YXJpYW50OiBmYWxzZSxcXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBhIGJvb2xlYW4gc3BlY2lmeWluZyBpZiBhIHJlcG9uc2l2ZSB2ZXJzaW9uIG9mIHRoZSB0aGVtZSBzaG91bGQga2ljayBpbiBvbiBzbWFsbGVyIHNjcmVlbnMgKGlmIHRoZSB0aGVtZSBzdXBwb3J0cyBpdCkuIERlZmF1bHRzIHRvIGBmYWxzZWAuXFxuICAgICAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY29yZS50aGVtZXMucmVzcG9uc2l2ZVxcbiAgICAgICAqL1xcbiAgICAgIHJlc3BvbnNpdmU6IGZhbHNlXFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBpZiBsZWZ0IGFzIGB0cnVlYCBhbGwgcGFyZW50cyBvZiBhbGwgc2VsZWN0ZWQgbm9kZXMgd2lsbCBiZSBvcGVuZWQgb25jZSB0aGUgdHJlZSBsb2FkcyAoc28gdGhhdCBhbGwgc2VsZWN0ZWQgbm9kZXMgYXJlIHZpc2libGUgdG8gdGhlIHVzZXIpXFxuICAgICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvcmUuZXhwYW5kX3NlbGVjdGVkX29ubG9hZFxcbiAgICAgKi9cXG4gICAgZXhwYW5kX3NlbGVjdGVkX29ubG9hZDogdHJ1ZSxcXG5cXG4gICAgLyoqXFxuICAgICAqIGlmIGxlZnQgYXMgYHRydWVgIHdlYiB3b3JrZXJzIHdpbGwgYmUgdXNlZCB0byBwYXJzZSBpbmNvbWluZyBKU09OIGRhdGEgd2hlcmUgcG9zc2libGUsIHNvIHRoYXQgdGhlIFVJIHdpbGwgbm90IGJlIGJsb2NrZWQgYnkgbGFyZ2UgcmVxdWVzdHMuIFdvcmtlcnMgYXJlIGhvd2V2ZXIgYWJvdXQgMzAlIHNsb3dlci4gRGVmYXVsdHMgdG8gYHRydWVgXFxuICAgICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvcmUud29ya2VyXFxuICAgICAqL1xcbiAgICB3b3JrZXI6IHRydWUsXFxuXFxuICAgIC8qKlxcbiAgICAgKiBGb3JjZSBub2RlIHRleHQgdG8gcGxhaW4gdGV4dCAoYW5kIGVzY2FwZSBIVE1MKS4gRGVmYXVsdHMgdG8gYGZhbHNlYFxcbiAgICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb3JlLmZvcmNlX3RleHRcXG4gICAgICovXFxuICAgIGZvcmNlX3RleHQ6IGZhbHNlLFxcblxcbiAgICAvKipcXG4gICAgICogU2hvdWxkIHRoZSBub2RlIHNob3VsZCBiZSB0b2dnbGVkIGlmIHRoZSB0ZXh0IGlzIGRvdWJsZSBjbGlja2VkIC4gRGVmYXVsdHMgdG8gYHRydWVgXFxuICAgICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvcmUuZGJsY2xpY2tfdG9nZ2xlXFxuICAgICAqL1xcbiAgICBkYmxjbGlja190b2dnbGU6IHRydWVcXG4gIH07XFxuICAkLmpzdHJlZS5jb3JlLnByb3RvdHlwZSA9IHtcXG4gICAgLyoqXFxuICAgICAqIHVzZWQgdG8gZGVjb3JhdGUgYW4gaW5zdGFuY2Ugd2l0aCBhIHBsdWdpbi4gVXNlZCBpbnRlcm5hbGx5LlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAbmFtZSBwbHVnaW4oZGVjbyBbLCBvcHRzXSlcXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBkZWNvIHRoZSBwbHVnaW4gdG8gZGVjb3JhdGUgd2l0aFxcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdHMgb3B0aW9ucyBmb3IgdGhlIHBsdWdpblxcbiAgICAgKiBAcmV0dXJuIHtqc1RyZWV9XFxuICAgICAqL1xcbiAgICBwbHVnaW46IGZ1bmN0aW9uIHBsdWdpbihkZWNvLCBvcHRzKSB7XFxuICAgICAgdmFyIENoaWxkID0gJC5qc3RyZWUucGx1Z2luc1tkZWNvXTtcXG5cXG4gICAgICBpZiAoQ2hpbGQpIHtcXG4gICAgICAgIHRoaXMuX2RhdGFbZGVjb10gPSB7fTtcXG4gICAgICAgIENoaWxkLnByb3RvdHlwZSA9IHRoaXM7XFxuICAgICAgICByZXR1cm4gbmV3IENoaWxkKG9wdHMsIHRoaXMpO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gdGhpcztcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIGluaXRpYWxpemUgdGhlIGluc3RhbmNlLiBVc2VkIGludGVybmFsbHkuXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBuYW1lIGluaXQoZWwsIG9wdG9ucylcXG4gICAgICogQHBhcmFtIHtET01FbGVtZW50fGpRdWVyeXxTdHJpbmd9IGVsIHRoZSBlbGVtZW50IHdlIGFyZSB0cmFuc2Zvcm1pbmdcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgb3B0aW9ucyBmb3IgdGhpcyBpbnN0YW5jZVxcbiAgICAgKiBAdHJpZ2dlciBpbml0LmpzdHJlZSwgbG9hZGluZy5qc3RyZWUsIGxvYWRlZC5qc3RyZWUsIHJlYWR5LmpzdHJlZSwgY2hhbmdlZC5qc3RyZWVcXG4gICAgICovXFxuICAgIGluaXQ6IGZ1bmN0aW9uIGluaXQoZWwsIG9wdGlvbnMpIHtcXG4gICAgICB0aGlzLl9tb2RlbCA9IHtcXG4gICAgICAgIGRhdGE6IHt9LFxcbiAgICAgICAgY2hhbmdlZDogW10sXFxuICAgICAgICBmb3JjZV9mdWxsX3JlZHJhdzogZmFsc2UsXFxuICAgICAgICByZWRyYXdfdGltZW91dDogZmFsc2UsXFxuICAgICAgICBkZWZhdWx0X3N0YXRlOiB7XFxuICAgICAgICAgIGxvYWRlZDogdHJ1ZSxcXG4gICAgICAgICAgb3BlbmVkOiBmYWxzZSxcXG4gICAgICAgICAgc2VsZWN0ZWQ6IGZhbHNlLFxcbiAgICAgICAgICBkaXNhYmxlZDogZmFsc2VcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIHRoaXMuX21vZGVsLmRhdGFbJC5qc3RyZWUucm9vdF0gPSB7XFxuICAgICAgICBpZDogJC5qc3RyZWUucm9vdCxcXG4gICAgICAgIHBhcmVudDogbnVsbCxcXG4gICAgICAgIHBhcmVudHM6IFtdLFxcbiAgICAgICAgY2hpbGRyZW46IFtdLFxcbiAgICAgICAgY2hpbGRyZW5fZDogW10sXFxuICAgICAgICBzdGF0ZToge1xcbiAgICAgICAgICBsb2FkZWQ6IGZhbHNlXFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICB0aGlzLmVsZW1lbnQgPSAkKGVsKS5hZGRDbGFzcygnanN0cmVlIGpzdHJlZS0nICsgdGhpcy5faWQpO1xcbiAgICAgIHRoaXMuc2V0dGluZ3MgPSBvcHRpb25zO1xcbiAgICAgIHRoaXMuX2RhdGEuY29yZS5yZWFkeSA9IGZhbHNlO1xcbiAgICAgIHRoaXMuX2RhdGEuY29yZS5sb2FkZWQgPSBmYWxzZTtcXG4gICAgICB0aGlzLl9kYXRhLmNvcmUucnRsID0gdGhpcy5lbGVtZW50LmNzcyhcXFwiZGlyZWN0aW9uXFxcIikgPT09IFxcXCJydGxcXFwiO1xcbiAgICAgIHRoaXMuZWxlbWVudFt0aGlzLl9kYXRhLmNvcmUucnRsID8gJ2FkZENsYXNzJyA6ICdyZW1vdmVDbGFzcyddKFxcXCJqc3RyZWUtcnRsXFxcIik7XFxuICAgICAgdGhpcy5lbGVtZW50LmF0dHIoJ3JvbGUnLCAndHJlZScpO1xcblxcbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLmNvcmUubXVsdGlwbGUpIHtcXG4gICAgICAgIHRoaXMuZWxlbWVudC5hdHRyKCdhcmlhLW11bHRpc2VsZWN0YWJsZScsIHRydWUpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIXRoaXMuZWxlbWVudC5hdHRyKCd0YWJpbmRleCcpKSB7XFxuICAgICAgICB0aGlzLmVsZW1lbnQuYXR0cigndGFiaW5kZXgnLCAnMCcpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLmJpbmQoKTtcXG4gICAgICAvKipcXG4gICAgICAgKiB0cmlnZ2VyZWQgYWZ0ZXIgYWxsIGV2ZW50cyBhcmUgYm91bmRcXG4gICAgICAgKiBAZXZlbnRcXG4gICAgICAgKiBAbmFtZSBpbml0LmpzdHJlZVxcbiAgICAgICAqL1xcblxcbiAgICAgIHRoaXMudHJpZ2dlcihcXFwiaW5pdFxcXCIpO1xcbiAgICAgIHRoaXMuX2RhdGEuY29yZS5vcmlnaW5hbF9jb250YWluZXJfaHRtbCA9IHRoaXMuZWxlbWVudC5maW5kKFxcXCIgPiB1bCA+IGxpXFxcIikuY2xvbmUodHJ1ZSk7XFxuXFxuICAgICAgdGhpcy5fZGF0YS5jb3JlLm9yaWdpbmFsX2NvbnRhaW5lcl9odG1sLmZpbmQoXFxcImxpXFxcIikuYWRkQmFjaygpLmNvbnRlbnRzKCkuZmlsdGVyKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVUeXBlID09PSAzICYmICghdGhpcy5ub2RlVmFsdWUgfHwgL15cXFxccyskLy50ZXN0KHRoaXMubm9kZVZhbHVlKSk7XFxuICAgICAgfSkucmVtb3ZlKCk7XFxuXFxuICAgICAgdGhpcy5lbGVtZW50Lmh0bWwoXFxcIjxcXFwiICsgXFxcInVsIGNsYXNzPSdqc3RyZWUtY29udGFpbmVyLXVsIGpzdHJlZS1jaGlsZHJlbicgcm9sZT0nZ3JvdXAnPjxcXFwiICsgXFxcImxpIGlkPSdqXFxcIiArIHRoaXMuX2lkICsgXFxcIl9sb2FkaW5nJyBjbGFzcz0nanN0cmVlLWluaXRpYWwtbm9kZSBqc3RyZWUtbG9hZGluZyBqc3RyZWUtbGVhZiBqc3RyZWUtbGFzdCcgcm9sZT0ndHJlZS1pdGVtJz48aSBjbGFzcz0nanN0cmVlLWljb24ganN0cmVlLW9jbCc+PC9pPjxcXFwiICsgXFxcImEgY2xhc3M9J2pzdHJlZS1hbmNob3InIGhyZWY9JyMnPjxpIGNsYXNzPSdqc3RyZWUtaWNvbiBqc3RyZWUtdGhlbWVpY29uLWhpZGRlbic+PC9pPlxcXCIgKyB0aGlzLmdldF9zdHJpbmcoXFxcIkxvYWRpbmcgLi4uXFxcIikgKyBcXFwiPC9hPjwvbGk+PC91bD5cXFwiKTtcXG4gICAgICB0aGlzLmVsZW1lbnQuYXR0cignYXJpYS1hY3RpdmVkZXNjZW5kYW50JywgJ2onICsgdGhpcy5faWQgKyAnX2xvYWRpbmcnKTtcXG4gICAgICB0aGlzLl9kYXRhLmNvcmUubGlfaGVpZ2h0ID0gdGhpcy5nZXRfY29udGFpbmVyX3VsKCkuY2hpbGRyZW4oXFxcImxpXFxcIikuZmlyc3QoKS5oZWlnaHQoKSB8fCAyNDtcXG4gICAgICB0aGlzLl9kYXRhLmNvcmUubm9kZSA9IHRoaXMuX2NyZWF0ZV9wcm90b3R5cGVfbm9kZSgpO1xcbiAgICAgIC8qKlxcbiAgICAgICAqIHRyaWdnZXJlZCBhZnRlciB0aGUgbG9hZGluZyB0ZXh0IGlzIHNob3duIGFuZCBiZWZvcmUgbG9hZGluZyBzdGFydHNcXG4gICAgICAgKiBAZXZlbnRcXG4gICAgICAgKiBAbmFtZSBsb2FkaW5nLmpzdHJlZVxcbiAgICAgICAqL1xcblxcbiAgICAgIHRoaXMudHJpZ2dlcihcXFwibG9hZGluZ1xcXCIpO1xcbiAgICAgIHRoaXMubG9hZF9ub2RlKCQuanN0cmVlLnJvb3QpO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogZGVzdHJveSBhbiBpbnN0YW5jZVxcbiAgICAgKiBAbmFtZSBkZXN0cm95KClcXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0ga2VlcF9odG1sIGlmIG5vdCBzZXQgdG8gYHRydWVgIHRoZSBjb250YWluZXIgd2lsbCBiZSBlbXB0aWVkLCBvdGhlcndpc2UgdGhlIGN1cnJlbnQgRE9NIGVsZW1lbnRzIHdpbGwgYmUga2VwdCBpbnRhY3RcXG4gICAgICovXFxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koa2VlcF9odG1sKSB7XFxuICAgICAgaWYgKHRoaXMuX3dyaykge1xcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgd2luZG93LlVSTC5yZXZva2VPYmplY3RVUkwodGhpcy5fd3JrKTtcXG4gICAgICAgICAgdGhpcy5fd3JrID0gbnVsbDtcXG4gICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCFrZWVwX2h0bWwpIHtcXG4gICAgICAgIHRoaXMuZWxlbWVudC5lbXB0eSgpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLnRlYXJkb3duKCk7XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGUgcHJvdG90eXBlIG5vZGVcXG4gICAgICovXFxuICAgIF9jcmVhdGVfcHJvdG90eXBlX25vZGU6IGZ1bmN0aW9uIF9jcmVhdGVfcHJvdG90eXBlX25vZGUoKSB7XFxuICAgICAgdmFyIF9ub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnTEknKSxcXG4gICAgICAgICAgX3RlbXAxLFxcbiAgICAgICAgICBfdGVtcDI7XFxuXFxuICAgICAgX25vZGUuc2V0QXR0cmlidXRlKCdyb2xlJywgJ3RyZWVpdGVtJyk7XFxuXFxuICAgICAgX3RlbXAxID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnSScpO1xcbiAgICAgIF90ZW1wMS5jbGFzc05hbWUgPSAnanN0cmVlLWljb24ganN0cmVlLW9jbCc7XFxuXFxuICAgICAgX3RlbXAxLnNldEF0dHJpYnV0ZSgncm9sZScsICdwcmVzZW50YXRpb24nKTtcXG5cXG4gICAgICBfbm9kZS5hcHBlbmRDaGlsZChfdGVtcDEpO1xcblxcbiAgICAgIF90ZW1wMSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0EnKTtcXG4gICAgICBfdGVtcDEuY2xhc3NOYW1lID0gJ2pzdHJlZS1hbmNob3InO1xcblxcbiAgICAgIF90ZW1wMS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCAnIycpO1xcblxcbiAgICAgIF90ZW1wMS5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJy0xJyk7XFxuXFxuICAgICAgX3RlbXAyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnSScpO1xcbiAgICAgIF90ZW1wMi5jbGFzc05hbWUgPSAnanN0cmVlLWljb24ganN0cmVlLXRoZW1laWNvbic7XFxuXFxuICAgICAgX3RlbXAyLnNldEF0dHJpYnV0ZSgncm9sZScsICdwcmVzZW50YXRpb24nKTtcXG5cXG4gICAgICBfdGVtcDEuYXBwZW5kQ2hpbGQoX3RlbXAyKTtcXG5cXG4gICAgICBfbm9kZS5hcHBlbmRDaGlsZChfdGVtcDEpO1xcblxcbiAgICAgIF90ZW1wMSA9IF90ZW1wMiA9IG51bGw7XFxuICAgICAgcmV0dXJuIF9ub2RlO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogcGFydCBvZiB0aGUgZGVzdHJveWluZyBvZiBhbiBpbnN0YW5jZS4gVXNlZCBpbnRlcm5hbGx5LlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAbmFtZSB0ZWFyZG93bigpXFxuICAgICAqL1xcbiAgICB0ZWFyZG93bjogZnVuY3Rpb24gdGVhcmRvd24oKSB7XFxuICAgICAgdGhpcy51bmJpbmQoKTtcXG4gICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlQ2xhc3MoJ2pzdHJlZScpLnJlbW92ZURhdGEoJ2pzdHJlZScpLmZpbmQoXFxcIltjbGFzc149J2pzdHJlZSddXFxcIikuYWRkQmFjaygpLmF0dHIoXFxcImNsYXNzXFxcIiwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xhc3NOYW1lLnJlcGxhY2UoL2pzdHJlZVteIF0qfCQvaWcsICcnKTtcXG4gICAgICB9KTtcXG4gICAgICB0aGlzLmVsZW1lbnQgPSBudWxsO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogYmluZCBhbGwgZXZlbnRzLiBVc2VkIGludGVybmFsbHkuXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBuYW1lIGJpbmQoKVxcbiAgICAgKi9cXG4gICAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcXG4gICAgICB2YXIgd29yZCA9ICcnLFxcbiAgICAgICAgICB0b3V0ID0gbnVsbCxcXG4gICAgICAgICAgd2FzX2NsaWNrID0gMDtcXG4gICAgICB0aGlzLmVsZW1lbnQub24oXFxcImRibGNsaWNrLmpzdHJlZVxcXCIsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICBpZiAoZS50YXJnZXQudGFnTmFtZSAmJiBlLnRhcmdldC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFxcXCJpbnB1dFxcXCIpIHtcXG4gICAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoZG9jdW1lbnQuc2VsZWN0aW9uICYmIGRvY3VtZW50LnNlbGVjdGlvbi5lbXB0eSkge1xcbiAgICAgICAgICBkb2N1bWVudC5zZWxlY3Rpb24uZW1wdHkoKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGlmICh3aW5kb3cuZ2V0U2VsZWN0aW9uKSB7XFxuICAgICAgICAgICAgdmFyIHNlbCA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcXG5cXG4gICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgc2VsLnJlbW92ZUFsbFJhbmdlcygpO1xcbiAgICAgICAgICAgICAgc2VsLmNvbGxhcHNlKCk7XFxuICAgICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfSkub24oXFxcIm1vdXNlZG93bi5qc3RyZWVcXFwiLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICBpZiAoZS50YXJnZXQgPT09IHRoaXMuZWxlbWVudFswXSkge1xcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7IC8vIHByZXZlbnQgbG9zaW5nIGZvY3VzIHdoZW4gY2xpY2tpbmcgc2Nyb2xsIGFycm93cyAoRkYsIENocm9tZSlcXG5cXG4gICAgICAgICAgd2FzX2NsaWNrID0gK25ldyBEYXRlKCk7IC8vIGllIGRvZXMgbm90IGFsbG93IHRvIHByZXZlbnQgbG9zaW5nIGZvY3VzXFxuICAgICAgICB9XFxuICAgICAgfSwgdGhpcykpLm9uKFxcXCJtb3VzZWRvd24uanN0cmVlXFxcIiwgXFxcIi5qc3RyZWUtb2NsXFxcIiwgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTsgLy8gcHJldmVudCBhbnkgbm9kZSBpbnNpZGUgZnJvbSBsb3NpbmcgZm9jdXMgd2hlbiBjbGlja2luZyB0aGUgb3Blbi9jbG9zZSBpY29uXFxuICAgICAgfSkub24oXFxcImNsaWNrLmpzdHJlZVxcXCIsIFxcXCIuanN0cmVlLW9jbFxcXCIsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgIHRoaXMudG9nZ2xlX25vZGUoZS50YXJnZXQpO1xcbiAgICAgIH0sIHRoaXMpKS5vbihcXFwiZGJsY2xpY2suanN0cmVlXFxcIiwgXFxcIi5qc3RyZWUtYW5jaG9yXFxcIiwgJC5wcm94eShmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgaWYgKGUudGFyZ2V0LnRhZ05hbWUgJiYgZS50YXJnZXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcXFwiaW5wdXRcXFwiKSB7XFxuICAgICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuY29yZS5kYmxjbGlja190b2dnbGUpIHtcXG4gICAgICAgICAgdGhpcy50b2dnbGVfbm9kZShlLnRhcmdldCk7XFxuICAgICAgICB9XFxuICAgICAgfSwgdGhpcykpLm9uKFxcXCJjbGljay5qc3RyZWVcXFwiLCBcXFwiLmpzdHJlZS1hbmNob3JcXFwiLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuXFxuICAgICAgICBpZiAoZS5jdXJyZW50VGFyZ2V0ICE9PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50KSB7XFxuICAgICAgICAgICQoZS5jdXJyZW50VGFyZ2V0KS5mb2N1cygpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdGhpcy5hY3RpdmF0ZV9ub2RlKGUuY3VycmVudFRhcmdldCwgZSk7XFxuICAgICAgfSwgdGhpcykpLm9uKCdrZXlkb3duLmpzdHJlZScsICcuanN0cmVlLWFuY2hvcicsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgIGlmIChlLnRhcmdldC50YWdOYW1lICYmIGUudGFyZ2V0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXFxcImlucHV0XFxcIikge1xcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChlLndoaWNoICE9PSAzMiAmJiBlLndoaWNoICE9PSAxMyAmJiAoZS5zaGlmdEtleSB8fCBlLmN0cmxLZXkgfHwgZS5hbHRLZXkgfHwgZS5tZXRhS2V5KSkge1xcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHZhciBvID0gbnVsbDtcXG5cXG4gICAgICAgIGlmICh0aGlzLl9kYXRhLmNvcmUucnRsKSB7XFxuICAgICAgICAgIGlmIChlLndoaWNoID09PSAzNykge1xcbiAgICAgICAgICAgIGUud2hpY2ggPSAzOTtcXG4gICAgICAgICAgfSBlbHNlIGlmIChlLndoaWNoID09PSAzOSkge1xcbiAgICAgICAgICAgIGUud2hpY2ggPSAzNztcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgc3dpdGNoIChlLndoaWNoKSB7XFxuICAgICAgICAgIGNhc2UgMzI6XFxuICAgICAgICAgICAgLy8gYXJpYSBkZWZpbmVzIHNwYWNlIG9ubHkgd2l0aCBDdHJsXFxuICAgICAgICAgICAgaWYgKGUuY3RybEtleSkge1xcbiAgICAgICAgICAgICAgZS50eXBlID0gXFxcImNsaWNrXFxcIjtcXG4gICAgICAgICAgICAgICQoZS5jdXJyZW50VGFyZ2V0KS50cmlnZ2VyKGUpO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgICAgY2FzZSAxMzpcXG4gICAgICAgICAgICAvLyBlbnRlclxcbiAgICAgICAgICAgIGUudHlwZSA9IFxcXCJjbGlja1xcXCI7XFxuICAgICAgICAgICAgJChlLmN1cnJlbnRUYXJnZXQpLnRyaWdnZXIoZSk7XFxuICAgICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICAgIGNhc2UgMzc6XFxuICAgICAgICAgICAgLy8gbGVmdFxcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXG5cXG4gICAgICAgICAgICBpZiAodGhpcy5pc19vcGVuKGUuY3VycmVudFRhcmdldCkpIHtcXG4gICAgICAgICAgICAgIHRoaXMuY2xvc2Vfbm9kZShlLmN1cnJlbnRUYXJnZXQpO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICBvID0gdGhpcy5nZXRfcGFyZW50KGUuY3VycmVudFRhcmdldCk7XFxuXFxuICAgICAgICAgICAgICBpZiAobyAmJiBvLmlkICE9PSAkLmpzdHJlZS5yb290KSB7XFxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0X25vZGUobywgdHJ1ZSkuY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuZm9jdXMoKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICAgIGNhc2UgMzg6XFxuICAgICAgICAgICAgLy8gdXBcXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICAgICAgbyA9IHRoaXMuZ2V0X3ByZXZfZG9tKGUuY3VycmVudFRhcmdldCk7XFxuXFxuICAgICAgICAgICAgaWYgKG8gJiYgby5sZW5ndGgpIHtcXG4gICAgICAgICAgICAgIG8uY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuZm9jdXMoKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICAgIGNhc2UgMzk6XFxuICAgICAgICAgICAgLy8gcmlnaHRcXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuXFxuICAgICAgICAgICAgaWYgKHRoaXMuaXNfY2xvc2VkKGUuY3VycmVudFRhcmdldCkpIHtcXG4gICAgICAgICAgICAgIHRoaXMub3Blbl9ub2RlKGUuY3VycmVudFRhcmdldCwgZnVuY3Rpb24gKG8pIHtcXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRfbm9kZShvLCB0cnVlKS5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5mb2N1cygpO1xcbiAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzX29wZW4oZS5jdXJyZW50VGFyZ2V0KSkge1xcbiAgICAgICAgICAgICAgbyA9IHRoaXMuZ2V0X25vZGUoZS5jdXJyZW50VGFyZ2V0LCB0cnVlKS5jaGlsZHJlbignLmpzdHJlZS1jaGlsZHJlbicpWzBdO1xcblxcbiAgICAgICAgICAgICAgaWYgKG8pIHtcXG4gICAgICAgICAgICAgICAgJCh0aGlzLl9maXJzdENoaWxkKG8pKS5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5mb2N1cygpO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgICAgY2FzZSA0MDpcXG4gICAgICAgICAgICAvLyBkb3duXFxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgICAgIG8gPSB0aGlzLmdldF9uZXh0X2RvbShlLmN1cnJlbnRUYXJnZXQpO1xcblxcbiAgICAgICAgICAgIGlmIChvICYmIG8ubGVuZ3RoKSB7XFxuICAgICAgICAgICAgICBvLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLmZvY3VzKCk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICBjYXNlIDEwNjpcXG4gICAgICAgICAgICAvLyBhcmlhIGRlZmluZXMgKiBvbiBudW1wYWQgYXMgb3Blbl9hbGwgLSBub3QgdmVyeSBjb21tb25cXG4gICAgICAgICAgICB0aGlzLm9wZW5fYWxsKCk7XFxuICAgICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICAgIGNhc2UgMzY6XFxuICAgICAgICAgICAgLy8gaG9tZVxcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgICAgICBvID0gdGhpcy5fZmlyc3RDaGlsZCh0aGlzLmdldF9jb250YWluZXJfdWwoKVswXSk7XFxuXFxuICAgICAgICAgICAgaWYgKG8pIHtcXG4gICAgICAgICAgICAgICQobykuY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuZmlsdGVyKCc6dmlzaWJsZScpLmZvY3VzKCk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICBjYXNlIDM1OlxcbiAgICAgICAgICAgIC8vIGVuZFxcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuZmluZCgnLmpzdHJlZS1hbmNob3InKS5maWx0ZXIoJzp2aXNpYmxlJykubGFzdCgpLmZvY3VzKCk7XFxuICAgICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICAgIGNhc2UgMTEzOlxcbiAgICAgICAgICAgIC8vIGYyIC0gc2FmZSB0byBpbmNsdWRlIC0gaWYgY2hlY2tfY2FsbGJhY2sgaXMgZmFsc2UgaXQgd2lsbCBmYWlsXFxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgICAgIHRoaXMuZWRpdChlLmN1cnJlbnRUYXJnZXQpO1xcbiAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICBkZWZhdWx0OlxcbiAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICAvKiFcXG4gICAgICAgICAgLy8gZGVsZXRlXFxuICAgICAgICAgIGNhc2UgNDY6XFxuICAgICAgICAgIFxcdGUucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgICAgXFx0byA9IHRoaXMuZ2V0X25vZGUoZS5jdXJyZW50VGFyZ2V0KTtcXG4gICAgICAgICAgXFx0aWYobyAmJiBvLmlkICYmIG8uaWQgIT09ICQuanN0cmVlLnJvb3QpIHtcXG4gICAgICAgICAgXFx0XFx0byA9IHRoaXMuaXNfc2VsZWN0ZWQobykgPyB0aGlzLmdldF9zZWxlY3RlZCgpIDogbztcXG4gICAgICAgICAgXFx0XFx0dGhpcy5kZWxldGVfbm9kZShvKTtcXG4gICAgICAgICAgXFx0fVxcbiAgICAgICAgICBcXHRicmVhaztcXG4gICAgICAgICAgXFx0Ki9cXG4gICAgICAgIH1cXG4gICAgICB9LCB0aGlzKSkub24oXFxcImxvYWRfbm9kZS5qc3RyZWVcXFwiLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XFxuICAgICAgICBpZiAoZGF0YS5zdGF0dXMpIHtcXG4gICAgICAgICAgaWYgKGRhdGEubm9kZS5pZCA9PT0gJC5qc3RyZWUucm9vdCAmJiAhdGhpcy5fZGF0YS5jb3JlLmxvYWRlZCkge1xcbiAgICAgICAgICAgIHRoaXMuX2RhdGEuY29yZS5sb2FkZWQgPSB0cnVlO1xcblxcbiAgICAgICAgICAgIGlmICh0aGlzLl9maXJzdENoaWxkKHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpWzBdKSkge1xcbiAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LmF0dHIoJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCcsIHRoaXMuX2ZpcnN0Q2hpbGQodGhpcy5nZXRfY29udGFpbmVyX3VsKClbMF0pLmlkKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgLyoqXFxuICAgICAgICAgICAgICogdHJpZ2dlcmVkIGFmdGVyIHRoZSByb290IG5vZGUgaXMgbG9hZGVkIGZvciB0aGUgZmlyc3QgdGltZVxcbiAgICAgICAgICAgICAqIEBldmVudFxcbiAgICAgICAgICAgICAqIEBuYW1lIGxvYWRlZC5qc3RyZWVcXG4gICAgICAgICAgICAgKi9cXG5cXG5cXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoXFxcImxvYWRlZFxcXCIpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmICghdGhpcy5fZGF0YS5jb3JlLnJlYWR5KSB7XFxuICAgICAgICAgICAgc2V0VGltZW91dCgkLnByb3h5KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgIGlmICh0aGlzLmVsZW1lbnQgJiYgIXRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpLmZpbmQoJy5qc3RyZWUtbG9hZGluZycpLmxlbmd0aCkge1xcbiAgICAgICAgICAgICAgICB0aGlzLl9kYXRhLmNvcmUucmVhZHkgPSB0cnVlO1xcblxcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLmxlbmd0aCkge1xcbiAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmNvcmUuZXhwYW5kX3NlbGVjdGVkX29ubG9hZCkge1xcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRtcCA9IFtdLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGksXFxuICAgICAgICAgICAgICAgICAgICAgICAgajtcXG5cXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGogPSB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICAgICAgICAgICAgICAgIHRtcCA9IHRtcC5jb25jYXQodGhpcy5fbW9kZWwuZGF0YVt0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWRbaV1dLnBhcmVudHMpO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICAgICAgdG1wID0gJC52YWthdGEuYXJyYXlfdW5pcXVlKHRtcCk7XFxuXFxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBqID0gdG1wLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wZW5fbm9kZSh0bXBbaV0sIGZhbHNlLCAwKTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdjaGFuZ2VkJywge1xcbiAgICAgICAgICAgICAgICAgICAgJ2FjdGlvbic6ICdyZWFkeScsXFxuICAgICAgICAgICAgICAgICAgICAnc2VsZWN0ZWQnOiB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWRcXG4gICAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAvKipcXG4gICAgICAgICAgICAgICAgICogdHJpZ2dlcmVkIGFmdGVyIGFsbCBub2RlcyBhcmUgZmluaXNoZWQgbG9hZGluZ1xcbiAgICAgICAgICAgICAgICAgKiBAZXZlbnRcXG4gICAgICAgICAgICAgICAgICogQG5hbWUgcmVhZHkuanN0cmVlXFxuICAgICAgICAgICAgICAgICAqL1xcblxcblxcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoXFxcInJlYWR5XFxcIik7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSwgdGhpcyksIDApO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfSwgdGhpcykpIC8vIHF1aWNrIHNlYXJjaGluZyB3aGVuIHRoZSB0cmVlIGlzIGZvY3VzZWRcXG4gICAgICAub24oJ2tleXByZXNzLmpzdHJlZScsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgIGlmIChlLnRhcmdldC50YWdOYW1lICYmIGUudGFyZ2V0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXFxcImlucHV0XFxcIikge1xcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICh0b3V0KSB7XFxuICAgICAgICAgIGNsZWFyVGltZW91dCh0b3V0KTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHRvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgd29yZCA9ICcnO1xcbiAgICAgICAgfSwgNTAwKTtcXG4gICAgICAgIHZhciBjaHIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGUud2hpY2gpLnRvTG93ZXJDYXNlKCksXFxuICAgICAgICAgICAgY29sID0gdGhpcy5lbGVtZW50LmZpbmQoJy5qc3RyZWUtYW5jaG9yJykuZmlsdGVyKCc6dmlzaWJsZScpLFxcbiAgICAgICAgICAgIGluZCA9IGNvbC5pbmRleChkb2N1bWVudC5hY3RpdmVFbGVtZW50KSB8fCAwLFxcbiAgICAgICAgICAgIGVuZCA9IGZhbHNlO1xcbiAgICAgICAgd29yZCArPSBjaHI7IC8vIG1hdGNoIGZvciB3aG9sZSB3b3JkIGZyb20gY3VycmVudCBub2RlIGRvd24gKGluY2x1ZGluZyB0aGUgY3VycmVudCBub2RlKVxcblxcbiAgICAgICAgaWYgKHdvcmQubGVuZ3RoID4gMSkge1xcbiAgICAgICAgICBjb2wuc2xpY2UoaW5kKS5lYWNoKCQucHJveHkoZnVuY3Rpb24gKGksIHYpIHtcXG4gICAgICAgICAgICBpZiAoJCh2KS50ZXh0KCkudG9Mb3dlckNhc2UoKS5pbmRleE9mKHdvcmQpID09PSAwKSB7XFxuICAgICAgICAgICAgICAkKHYpLmZvY3VzKCk7XFxuICAgICAgICAgICAgICBlbmQgPSB0cnVlO1xcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSwgdGhpcykpO1xcblxcbiAgICAgICAgICBpZiAoZW5kKSB7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICB9IC8vIG1hdGNoIGZvciB3aG9sZSB3b3JkIGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgdHJlZVxcblxcblxcbiAgICAgICAgICBjb2wuc2xpY2UoMCwgaW5kKS5lYWNoKCQucHJveHkoZnVuY3Rpb24gKGksIHYpIHtcXG4gICAgICAgICAgICBpZiAoJCh2KS50ZXh0KCkudG9Mb3dlckNhc2UoKS5pbmRleE9mKHdvcmQpID09PSAwKSB7XFxuICAgICAgICAgICAgICAkKHYpLmZvY3VzKCk7XFxuICAgICAgICAgICAgICBlbmQgPSB0cnVlO1xcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSwgdGhpcykpO1xcblxcbiAgICAgICAgICBpZiAoZW5kKSB7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IC8vIGxpc3Qgbm9kZXMgdGhhdCBzdGFydCB3aXRoIHRoYXQgbGV0dGVyIChvbmx5IGlmIHdvcmQgY29uc2lzdHMgb2YgYSBzaW5nbGUgY2hhcilcXG5cXG5cXG4gICAgICAgIGlmIChuZXcgUmVnRXhwKCdeJyArIGNoci5yZXBsYWNlKC9bLVxcXFwvXFxcXFxcXFxeJCorPy4oKXxbXFxcXF17fV0vZywgJ1xcXFxcXFxcJCYnKSArICcrJCcpLnRlc3Qod29yZCkpIHtcXG4gICAgICAgICAgLy8gc2VhcmNoIGZvciB0aGUgbmV4dCBub2RlIHN0YXJ0aW5nIHdpdGggdGhhdCBsZXR0ZXJcXG4gICAgICAgICAgY29sLnNsaWNlKGluZCArIDEpLmVhY2goJC5wcm94eShmdW5jdGlvbiAoaSwgdikge1xcbiAgICAgICAgICAgIGlmICgkKHYpLnRleHQoKS50b0xvd2VyQ2FzZSgpLmNoYXJBdCgwKSA9PT0gY2hyKSB7XFxuICAgICAgICAgICAgICAkKHYpLmZvY3VzKCk7XFxuICAgICAgICAgICAgICBlbmQgPSB0cnVlO1xcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSwgdGhpcykpO1xcblxcbiAgICAgICAgICBpZiAoZW5kKSB7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICB9IC8vIHNlYXJjaCBmcm9tIHRoZSBiZWdpbm5pbmdcXG5cXG5cXG4gICAgICAgICAgY29sLnNsaWNlKDAsIGluZCArIDEpLmVhY2goJC5wcm94eShmdW5jdGlvbiAoaSwgdikge1xcbiAgICAgICAgICAgIGlmICgkKHYpLnRleHQoKS50b0xvd2VyQ2FzZSgpLmNoYXJBdCgwKSA9PT0gY2hyKSB7XFxuICAgICAgICAgICAgICAkKHYpLmZvY3VzKCk7XFxuICAgICAgICAgICAgICBlbmQgPSB0cnVlO1xcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSwgdGhpcykpO1xcblxcbiAgICAgICAgICBpZiAoZW5kKSB7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfSwgdGhpcykpIC8vIFRIRU1FIFJFTEFURURcXG4gICAgICAub24oXFxcImluaXQuanN0cmVlXFxcIiwgJC5wcm94eShmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgcyA9IHRoaXMuc2V0dGluZ3MuY29yZS50aGVtZXM7XFxuICAgICAgICB0aGlzLl9kYXRhLmNvcmUudGhlbWVzLmRvdHMgPSBzLmRvdHM7XFxuICAgICAgICB0aGlzLl9kYXRhLmNvcmUudGhlbWVzLnN0cmlwZXMgPSBzLnN0cmlwZXM7XFxuICAgICAgICB0aGlzLl9kYXRhLmNvcmUudGhlbWVzLmljb25zID0gcy5pY29ucztcXG4gICAgICAgIHRoaXMuX2RhdGEuY29yZS50aGVtZXMuZWxsaXBzaXMgPSBzLmVsbGlwc2lzO1xcbiAgICAgICAgdGhpcy5zZXRfdGhlbWUocy5uYW1lIHx8IFxcXCJkZWZhdWx0XFxcIiwgcy51cmwpO1xcbiAgICAgICAgdGhpcy5zZXRfdGhlbWVfdmFyaWFudChzLnZhcmlhbnQpO1xcbiAgICAgIH0sIHRoaXMpKS5vbihcXFwibG9hZGluZy5qc3RyZWVcXFwiLCAkLnByb3h5KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHRoaXNbdGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5kb3RzID8gXFxcInNob3dfZG90c1xcXCIgOiBcXFwiaGlkZV9kb3RzXFxcIl0oKTtcXG4gICAgICAgIHRoaXNbdGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5pY29ucyA/IFxcXCJzaG93X2ljb25zXFxcIiA6IFxcXCJoaWRlX2ljb25zXFxcIl0oKTtcXG4gICAgICAgIHRoaXNbdGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5zdHJpcGVzID8gXFxcInNob3dfc3RyaXBlc1xcXCIgOiBcXFwiaGlkZV9zdHJpcGVzXFxcIl0oKTtcXG4gICAgICAgIHRoaXNbdGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5lbGxpcHNpcyA/IFxcXCJzaG93X2VsbGlwc2lzXFxcIiA6IFxcXCJoaWRlX2VsbGlwc2lzXFxcIl0oKTtcXG4gICAgICB9LCB0aGlzKSkub24oJ2JsdXIuanN0cmVlJywgJy5qc3RyZWUtYW5jaG9yJywgJC5wcm94eShmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgdGhpcy5fZGF0YS5jb3JlLmZvY3VzZWQgPSBudWxsO1xcbiAgICAgICAgJChlLmN1cnJlbnRUYXJnZXQpLmZpbHRlcignLmpzdHJlZS1ob3ZlcmVkJykubW91c2VsZWF2ZSgpO1xcbiAgICAgICAgdGhpcy5lbGVtZW50LmF0dHIoJ3RhYmluZGV4JywgJzAnKTtcXG4gICAgICB9LCB0aGlzKSkub24oJ2ZvY3VzLmpzdHJlZScsICcuanN0cmVlLWFuY2hvcicsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgIHZhciB0bXAgPSB0aGlzLmdldF9ub2RlKGUuY3VycmVudFRhcmdldCk7XFxuXFxuICAgICAgICBpZiAodG1wICYmIHRtcC5pZCkge1xcbiAgICAgICAgICB0aGlzLl9kYXRhLmNvcmUuZm9jdXNlZCA9IHRtcC5pZDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHRoaXMuZWxlbWVudC5maW5kKCcuanN0cmVlLWhvdmVyZWQnKS5ub3QoZS5jdXJyZW50VGFyZ2V0KS5tb3VzZWxlYXZlKCk7XFxuICAgICAgICAkKGUuY3VycmVudFRhcmdldCkubW91c2VlbnRlcigpO1xcbiAgICAgICAgdGhpcy5lbGVtZW50LmF0dHIoJ3RhYmluZGV4JywgJy0xJyk7XFxuICAgICAgfSwgdGhpcykpLm9uKCdmb2N1cy5qc3RyZWUnLCAkLnByb3h5KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGlmICgrbmV3IERhdGUoKSAtIHdhc19jbGljayA+IDUwMCAmJiAhdGhpcy5fZGF0YS5jb3JlLmZvY3VzZWQpIHtcXG4gICAgICAgICAgd2FzX2NsaWNrID0gMDtcXG4gICAgICAgICAgdmFyIGFjdCA9IHRoaXMuZ2V0X25vZGUodGhpcy5lbGVtZW50LmF0dHIoJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCcpLCB0cnVlKTtcXG5cXG4gICAgICAgICAgaWYgKGFjdCkge1xcbiAgICAgICAgICAgIGFjdC5maW5kKCc+IC5qc3RyZWUtYW5jaG9yJykuZm9jdXMoKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH0sIHRoaXMpKS5vbignbW91c2VlbnRlci5qc3RyZWUnLCAnLmpzdHJlZS1hbmNob3InLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICB0aGlzLmhvdmVyX25vZGUoZS5jdXJyZW50VGFyZ2V0KTtcXG4gICAgICB9LCB0aGlzKSkub24oJ21vdXNlbGVhdmUuanN0cmVlJywgJy5qc3RyZWUtYW5jaG9yJywgJC5wcm94eShmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgdGhpcy5kZWhvdmVyX25vZGUoZS5jdXJyZW50VGFyZ2V0KTtcXG4gICAgICB9LCB0aGlzKSk7XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBwYXJ0IG9mIHRoZSBkZXN0cm95aW5nIG9mIGFuIGluc3RhbmNlLiBVc2VkIGludGVybmFsbHkuXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBuYW1lIHVuYmluZCgpXFxuICAgICAqL1xcbiAgICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCgpIHtcXG4gICAgICB0aGlzLmVsZW1lbnQub2ZmKCcuanN0cmVlJyk7XFxuICAgICAgJChkb2N1bWVudCkub2ZmKCcuanN0cmVlLScgKyB0aGlzLl9pZCk7XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiB0cmlnZ2VyIGFuIGV2ZW50LiBVc2VkIGludGVybmFsbHkuXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBuYW1lIHRyaWdnZXIoZXYgWywgZGF0YV0pXFxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gZXYgdGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHRyaWdnZXJcXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBkYXRhIGFkZGl0aW9uYWwgZGF0YSB0byBwYXNzIHdpdGggdGhlIGV2ZW50XFxuICAgICAqL1xcbiAgICB0cmlnZ2VyOiBmdW5jdGlvbiB0cmlnZ2VyKGV2LCBkYXRhKSB7XFxuICAgICAgaWYgKCFkYXRhKSB7XFxuICAgICAgICBkYXRhID0ge307XFxuICAgICAgfVxcblxcbiAgICAgIGRhdGEuaW5zdGFuY2UgPSB0aGlzO1xcbiAgICAgIHRoaXMuZWxlbWVudC50cmlnZ2VySGFuZGxlcihldi5yZXBsYWNlKCcuanN0cmVlJywgJycpICsgJy5qc3RyZWUnLCBkYXRhKTtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIHJldHVybnMgdGhlIGpRdWVyeSBleHRlbmRlZCBpbnN0YW5jZSBjb250YWluZXJcXG4gICAgICogQG5hbWUgZ2V0X2NvbnRhaW5lcigpXFxuICAgICAqIEByZXR1cm4ge2pRdWVyeX1cXG4gICAgICovXFxuICAgIGdldF9jb250YWluZXI6IGZ1bmN0aW9uIGdldF9jb250YWluZXIoKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudDtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIHJldHVybnMgdGhlIGpRdWVyeSBleHRlbmRlZCBtYWluIFVMIG5vZGUgaW5zaWRlIHRoZSBpbnN0YW5jZSBjb250YWluZXIuIFVzZWQgaW50ZXJuYWxseS5cXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQG5hbWUgZ2V0X2NvbnRhaW5lcl91bCgpXFxuICAgICAqIEByZXR1cm4ge2pRdWVyeX1cXG4gICAgICovXFxuICAgIGdldF9jb250YWluZXJfdWw6IGZ1bmN0aW9uIGdldF9jb250YWluZXJfdWwoKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC5jaGlsZHJlbihcXFwiLmpzdHJlZS1jaGlsZHJlblxcXCIpLmZpcnN0KCk7XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBnZXRzIHN0cmluZyByZXBsYWNlbWVudHMgKGxvY2FsaXphdGlvbikuIFVzZWQgaW50ZXJuYWxseS5cXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQG5hbWUgZ2V0X3N0cmluZyhrZXkpXFxuICAgICAqIEBwYXJhbSAge1N0cmluZ30ga2V5XFxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cXG4gICAgICovXFxuICAgIGdldF9zdHJpbmc6IGZ1bmN0aW9uIGdldF9zdHJpbmcoa2V5KSB7XFxuICAgICAgdmFyIGEgPSB0aGlzLnNldHRpbmdzLmNvcmUuc3RyaW5ncztcXG5cXG4gICAgICBpZiAoJC5pc0Z1bmN0aW9uKGEpKSB7XFxuICAgICAgICByZXR1cm4gYS5jYWxsKHRoaXMsIGtleSk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChhICYmIGFba2V5XSkge1xcbiAgICAgICAgcmV0dXJuIGFba2V5XTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIGtleTtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIGdldHMgdGhlIGZpcnN0IGNoaWxkIG9mIGEgRE9NIG5vZGUuIFVzZWQgaW50ZXJuYWxseS5cXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQG5hbWUgX2ZpcnN0Q2hpbGQoZG9tKVxcbiAgICAgKiBAcGFyYW0gIHtET01FbGVtZW50fSBkb21cXG4gICAgICogQHJldHVybiB7RE9NRWxlbWVudH1cXG4gICAgICovXFxuICAgIF9maXJzdENoaWxkOiBmdW5jdGlvbiBfZmlyc3RDaGlsZChkb20pIHtcXG4gICAgICBkb20gPSBkb20gPyBkb20uZmlyc3RDaGlsZCA6IG51bGw7XFxuXFxuICAgICAgd2hpbGUgKGRvbSAhPT0gbnVsbCAmJiBkb20ubm9kZVR5cGUgIT09IDEpIHtcXG4gICAgICAgIGRvbSA9IGRvbS5uZXh0U2libGluZztcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIGRvbTtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIGdldHMgdGhlIG5leHQgc2libGluZyBvZiBhIERPTSBub2RlLiBVc2VkIGludGVybmFsbHkuXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBuYW1lIF9uZXh0U2libGluZyhkb20pXFxuICAgICAqIEBwYXJhbSAge0RPTUVsZW1lbnR9IGRvbVxcbiAgICAgKiBAcmV0dXJuIHtET01FbGVtZW50fVxcbiAgICAgKi9cXG4gICAgX25leHRTaWJsaW5nOiBmdW5jdGlvbiBfbmV4dFNpYmxpbmcoZG9tKSB7XFxuICAgICAgZG9tID0gZG9tID8gZG9tLm5leHRTaWJsaW5nIDogbnVsbDtcXG5cXG4gICAgICB3aGlsZSAoZG9tICE9PSBudWxsICYmIGRvbS5ub2RlVHlwZSAhPT0gMSkge1xcbiAgICAgICAgZG9tID0gZG9tLm5leHRTaWJsaW5nO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gZG9tO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogZ2V0cyB0aGUgcHJldmlvdXMgc2libGluZyBvZiBhIERPTSBub2RlLiBVc2VkIGludGVybmFsbHkuXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBuYW1lIF9wcmV2aW91c1NpYmxpbmcoZG9tKVxcbiAgICAgKiBAcGFyYW0gIHtET01FbGVtZW50fSBkb21cXG4gICAgICogQHJldHVybiB7RE9NRWxlbWVudH1cXG4gICAgICovXFxuICAgIF9wcmV2aW91c1NpYmxpbmc6IGZ1bmN0aW9uIF9wcmV2aW91c1NpYmxpbmcoZG9tKSB7XFxuICAgICAgZG9tID0gZG9tID8gZG9tLnByZXZpb3VzU2libGluZyA6IG51bGw7XFxuXFxuICAgICAgd2hpbGUgKGRvbSAhPT0gbnVsbCAmJiBkb20ubm9kZVR5cGUgIT09IDEpIHtcXG4gICAgICAgIGRvbSA9IGRvbS5wcmV2aW91c1NpYmxpbmc7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBkb207XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBnZXQgdGhlIEpTT04gcmVwcmVzZW50YXRpb24gb2YgYSBub2RlIChvciB0aGUgYWN0dWFsIGpRdWVyeSBleHRlbmRlZCBET00gbm9kZSkgYnkgdXNpbmcgYW55IGlucHV0IChjaGlsZCBET00gZWxlbWVudCwgSUQgc3RyaW5nLCBzZWxlY3RvciwgZXRjKVxcbiAgICAgKiBAbmFtZSBnZXRfbm9kZShvYmogWywgYXNfZG9tXSlcXG4gICAgICogQHBhcmFtICB7bWl4ZWR9IG9ialxcbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBhc19kb21cXG4gICAgICogQHJldHVybiB7T2JqZWN0fGpRdWVyeX1cXG4gICAgICovXFxuICAgIGdldF9ub2RlOiBmdW5jdGlvbiBnZXRfbm9kZShvYmosIGFzX2RvbSkge1xcbiAgICAgIGlmIChvYmogJiYgb2JqLmlkKSB7XFxuICAgICAgICBvYmogPSBvYmouaWQ7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBkb207XFxuXFxuICAgICAgdHJ5IHtcXG4gICAgICAgIGlmICh0aGlzLl9tb2RlbC5kYXRhW29ial0pIHtcXG4gICAgICAgICAgb2JqID0gdGhpcy5fbW9kZWwuZGF0YVtvYmpdO1xcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSBcXFwic3RyaW5nXFxcIiAmJiB0aGlzLl9tb2RlbC5kYXRhW29iai5yZXBsYWNlKC9eIy8sICcnKV0pIHtcXG4gICAgICAgICAgb2JqID0gdGhpcy5fbW9kZWwuZGF0YVtvYmoucmVwbGFjZSgvXiMvLCAnJyldO1xcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSBcXFwic3RyaW5nXFxcIiAmJiAoZG9tID0gJCgnIycgKyBvYmoucmVwbGFjZSgkLmpzdHJlZS5pZHJlZ2V4LCAnXFxcXFxcXFwkJicpLCB0aGlzLmVsZW1lbnQpKS5sZW5ndGggJiYgdGhpcy5fbW9kZWwuZGF0YVtkb20uY2xvc2VzdCgnLmpzdHJlZS1ub2RlJykuYXR0cignaWQnKV0pIHtcXG4gICAgICAgICAgb2JqID0gdGhpcy5fbW9kZWwuZGF0YVtkb20uY2xvc2VzdCgnLmpzdHJlZS1ub2RlJykuYXR0cignaWQnKV07XFxuICAgICAgICB9IGVsc2UgaWYgKChkb20gPSAkKG9iaiwgdGhpcy5lbGVtZW50KSkubGVuZ3RoICYmIHRoaXMuX21vZGVsLmRhdGFbZG9tLmNsb3Nlc3QoJy5qc3RyZWUtbm9kZScpLmF0dHIoJ2lkJyldKSB7XFxuICAgICAgICAgIG9iaiA9IHRoaXMuX21vZGVsLmRhdGFbZG9tLmNsb3Nlc3QoJy5qc3RyZWUtbm9kZScpLmF0dHIoJ2lkJyldO1xcbiAgICAgICAgfSBlbHNlIGlmICgoZG9tID0gJChvYmosIHRoaXMuZWxlbWVudCkpLmxlbmd0aCAmJiBkb20uaGFzQ2xhc3MoJ2pzdHJlZScpKSB7XFxuICAgICAgICAgIG9iaiA9IHRoaXMuX21vZGVsLmRhdGFbJC5qc3RyZWUucm9vdF07XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoYXNfZG9tKSB7XFxuICAgICAgICAgIG9iaiA9IG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCA/IHRoaXMuZWxlbWVudCA6ICQoJyMnICsgb2JqLmlkLnJlcGxhY2UoJC5qc3RyZWUuaWRyZWdleCwgJ1xcXFxcXFxcJCYnKSwgdGhpcy5lbGVtZW50KTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiBvYmo7XFxuICAgICAgfSBjYXRjaCAoZXgpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBnZXQgdGhlIHBhdGggdG8gYSBub2RlLCBlaXRoZXIgY29uc2lzdGluZyBvZiBub2RlIHRleHRzLCBvciBvZiBub2RlIElEcywgb3B0aW9uYWxseSBnbHVlZCB0b2dldGhlciAob3RoZXJ3aXNlIGFuIGFycmF5KVxcbiAgICAgKiBAbmFtZSBnZXRfcGF0aChvYmogWywgZ2x1ZSwgaWRzXSlcXG4gICAgICogQHBhcmFtICB7bWl4ZWR9IG9iaiB0aGUgbm9kZVxcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGdsdWUgaWYgeW91IHdhbnQgdGhlIHBhdGggYXMgYSBzdHJpbmcgLSBwYXNzIHRoZSBnbHVlIGhlcmUgKGZvciBleGFtcGxlICcvJyksIGlmIGEgZmFsc3kgdmFsdWUgaXMgc3VwcGxpZWQgaGVyZSwgYW4gYXJyYXkgaXMgcmV0dXJuZWRcXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gaWRzIGlmIHNldCB0byB0cnVlIGJ1aWxkIHRoZSBwYXRoIHVzaW5nIElELCBvdGhlcndpc2Ugbm9kZSB0ZXh0IGlzIHVzZWRcXG4gICAgICogQHJldHVybiB7bWl4ZWR9XFxuICAgICAqL1xcbiAgICBnZXRfcGF0aDogZnVuY3Rpb24gZ2V0X3BhdGgob2JqLCBnbHVlLCBpZHMpIHtcXG4gICAgICBvYmogPSBvYmoucGFyZW50cyA/IG9iaiA6IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXG4gICAgICBpZiAoIW9iaiB8fCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QgfHwgIW9iai5wYXJlbnRzKSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBpLFxcbiAgICAgICAgICBqLFxcbiAgICAgICAgICBwID0gW107XFxuICAgICAgcC5wdXNoKGlkcyA/IG9iai5pZCA6IG9iai50ZXh0KTtcXG5cXG4gICAgICBmb3IgKGkgPSAwLCBqID0gb2JqLnBhcmVudHMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICBwLnB1c2goaWRzID8gb2JqLnBhcmVudHNbaV0gOiB0aGlzLmdldF90ZXh0KG9iai5wYXJlbnRzW2ldKSk7XFxuICAgICAgfVxcblxcbiAgICAgIHAgPSBwLnJldmVyc2UoKS5zbGljZSgxKTtcXG4gICAgICByZXR1cm4gZ2x1ZSA/IHAuam9pbihnbHVlKSA6IHA7XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBnZXQgdGhlIG5leHQgdmlzaWJsZSBub2RlIHRoYXQgaXMgYmVsb3cgdGhlIGBvYmpgIG5vZGUuIElmIGBzdHJpY3RgIGlzIHNldCB0byBgdHJ1ZWAgb25seSBzaWJsaW5nIG5vZGVzIGFyZSByZXR1cm5lZC5cXG4gICAgICogQG5hbWUgZ2V0X25leHRfZG9tKG9iaiBbLCBzdHJpY3RdKVxcbiAgICAgKiBAcGFyYW0gIHttaXhlZH0gb2JqXFxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IHN0cmljdFxcbiAgICAgKiBAcmV0dXJuIHtqUXVlcnl9XFxuICAgICAqL1xcbiAgICBnZXRfbmV4dF9kb206IGZ1bmN0aW9uIGdldF9uZXh0X2RvbShvYmosIHN0cmljdCkge1xcbiAgICAgIHZhciB0bXA7XFxuICAgICAgb2JqID0gdGhpcy5nZXRfbm9kZShvYmosIHRydWUpO1xcblxcbiAgICAgIGlmIChvYmpbMF0gPT09IHRoaXMuZWxlbWVudFswXSkge1xcbiAgICAgICAgdG1wID0gdGhpcy5fZmlyc3RDaGlsZCh0aGlzLmdldF9jb250YWluZXJfdWwoKVswXSk7XFxuXFxuICAgICAgICB3aGlsZSAodG1wICYmIHRtcC5vZmZzZXRIZWlnaHQgPT09IDApIHtcXG4gICAgICAgICAgdG1wID0gdGhpcy5fbmV4dFNpYmxpbmcodG1wKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiB0bXAgPyAkKHRtcCkgOiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCFvYmogfHwgIW9iai5sZW5ndGgpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHN0cmljdCkge1xcbiAgICAgICAgdG1wID0gb2JqWzBdO1xcblxcbiAgICAgICAgZG8ge1xcbiAgICAgICAgICB0bXAgPSB0aGlzLl9uZXh0U2libGluZyh0bXApO1xcbiAgICAgICAgfSB3aGlsZSAodG1wICYmIHRtcC5vZmZzZXRIZWlnaHQgPT09IDApO1xcblxcbiAgICAgICAgcmV0dXJuIHRtcCA/ICQodG1wKSA6IGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAob2JqLmhhc0NsYXNzKFxcXCJqc3RyZWUtb3BlblxcXCIpKSB7XFxuICAgICAgICB0bXAgPSB0aGlzLl9maXJzdENoaWxkKG9iai5jaGlsZHJlbignLmpzdHJlZS1jaGlsZHJlbicpWzBdKTtcXG5cXG4gICAgICAgIHdoaWxlICh0bXAgJiYgdG1wLm9mZnNldEhlaWdodCA9PT0gMCkge1xcbiAgICAgICAgICB0bXAgPSB0aGlzLl9uZXh0U2libGluZyh0bXApO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKHRtcCAhPT0gbnVsbCkge1xcbiAgICAgICAgICByZXR1cm4gJCh0bXApO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICB0bXAgPSBvYmpbMF07XFxuXFxuICAgICAgZG8ge1xcbiAgICAgICAgdG1wID0gdGhpcy5fbmV4dFNpYmxpbmcodG1wKTtcXG4gICAgICB9IHdoaWxlICh0bXAgJiYgdG1wLm9mZnNldEhlaWdodCA9PT0gMCk7XFxuXFxuICAgICAgaWYgKHRtcCAhPT0gbnVsbCkge1xcbiAgICAgICAgcmV0dXJuICQodG1wKTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIG9iai5wYXJlbnRzVW50aWwoXFxcIi5qc3RyZWVcXFwiLCBcXFwiLmpzdHJlZS1ub2RlXFxcIikubmV4dEFsbChcXFwiLmpzdHJlZS1ub2RlOnZpc2libGVcXFwiKS5maXJzdCgpO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogZ2V0IHRoZSBwcmV2aW91cyB2aXNpYmxlIG5vZGUgdGhhdCBpcyBhYm92ZSB0aGUgYG9iamAgbm9kZS4gSWYgYHN0cmljdGAgaXMgc2V0IHRvIGB0cnVlYCBvbmx5IHNpYmxpbmcgbm9kZXMgYXJlIHJldHVybmVkLlxcbiAgICAgKiBAbmFtZSBnZXRfcHJldl9kb20ob2JqIFssIHN0cmljdF0pXFxuICAgICAqIEBwYXJhbSAge21peGVkfSBvYmpcXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gc3RyaWN0XFxuICAgICAqIEByZXR1cm4ge2pRdWVyeX1cXG4gICAgICovXFxuICAgIGdldF9wcmV2X2RvbTogZnVuY3Rpb24gZ2V0X3ByZXZfZG9tKG9iaiwgc3RyaWN0KSB7XFxuICAgICAgdmFyIHRtcDtcXG4gICAgICBvYmogPSB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSk7XFxuXFxuICAgICAgaWYgKG9ialswXSA9PT0gdGhpcy5lbGVtZW50WzBdKSB7XFxuICAgICAgICB0bXAgPSB0aGlzLmdldF9jb250YWluZXJfdWwoKVswXS5sYXN0Q2hpbGQ7XFxuXFxuICAgICAgICB3aGlsZSAodG1wICYmIHRtcC5vZmZzZXRIZWlnaHQgPT09IDApIHtcXG4gICAgICAgICAgdG1wID0gdGhpcy5fcHJldmlvdXNTaWJsaW5nKHRtcCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gdG1wID8gJCh0bXApIDogZmFsc2U7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghb2JqIHx8ICFvYmoubGVuZ3RoKSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChzdHJpY3QpIHtcXG4gICAgICAgIHRtcCA9IG9ialswXTtcXG5cXG4gICAgICAgIGRvIHtcXG4gICAgICAgICAgdG1wID0gdGhpcy5fcHJldmlvdXNTaWJsaW5nKHRtcCk7XFxuICAgICAgICB9IHdoaWxlICh0bXAgJiYgdG1wLm9mZnNldEhlaWdodCA9PT0gMCk7XFxuXFxuICAgICAgICByZXR1cm4gdG1wID8gJCh0bXApIDogZmFsc2U7XFxuICAgICAgfVxcblxcbiAgICAgIHRtcCA9IG9ialswXTtcXG5cXG4gICAgICBkbyB7XFxuICAgICAgICB0bXAgPSB0aGlzLl9wcmV2aW91c1NpYmxpbmcodG1wKTtcXG4gICAgICB9IHdoaWxlICh0bXAgJiYgdG1wLm9mZnNldEhlaWdodCA9PT0gMCk7XFxuXFxuICAgICAgaWYgKHRtcCAhPT0gbnVsbCkge1xcbiAgICAgICAgb2JqID0gJCh0bXApO1xcblxcbiAgICAgICAgd2hpbGUgKG9iai5oYXNDbGFzcyhcXFwianN0cmVlLW9wZW5cXFwiKSkge1xcbiAgICAgICAgICBvYmogPSBvYmouY2hpbGRyZW4oXFxcIi5qc3RyZWUtY2hpbGRyZW5cXFwiKS5maXJzdCgpLmNoaWxkcmVuKFxcXCIuanN0cmVlLW5vZGU6dmlzaWJsZTpsYXN0XFxcIik7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gb2JqO1xcbiAgICAgIH1cXG5cXG4gICAgICB0bXAgPSBvYmpbMF0ucGFyZW50Tm9kZS5wYXJlbnROb2RlO1xcbiAgICAgIHJldHVybiB0bXAgJiYgdG1wLmNsYXNzTmFtZSAmJiB0bXAuY2xhc3NOYW1lLmluZGV4T2YoJ2pzdHJlZS1ub2RlJykgIT09IC0xID8gJCh0bXApIDogZmFsc2U7XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBnZXQgdGhlIHBhcmVudCBJRCBvZiBhIG5vZGVcXG4gICAgICogQG5hbWUgZ2V0X3BhcmVudChvYmopXFxuICAgICAqIEBwYXJhbSAge21peGVkfSBvYmpcXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxcbiAgICAgKi9cXG4gICAgZ2V0X3BhcmVudDogZnVuY3Rpb24gZ2V0X3BhcmVudChvYmopIHtcXG4gICAgICBvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XFxuXFxuICAgICAgaWYgKCFvYmogfHwgb2JqLmlkID09PSAkLmpzdHJlZS5yb290KSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBvYmoucGFyZW50O1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogZ2V0IGEgalF1ZXJ5IGNvbGxlY3Rpb24gb2YgYWxsIHRoZSBjaGlsZHJlbiBvZiBhIG5vZGUgKG5vZGUgbXVzdCBiZSByZW5kZXJlZClcXG4gICAgICogQG5hbWUgZ2V0X2NoaWxkcmVuX2RvbShvYmopXFxuICAgICAqIEBwYXJhbSAge21peGVkfSBvYmpcXG4gICAgICogQHJldHVybiB7alF1ZXJ5fVxcbiAgICAgKi9cXG4gICAgZ2V0X2NoaWxkcmVuX2RvbTogZnVuY3Rpb24gZ2V0X2NoaWxkcmVuX2RvbShvYmopIHtcXG4gICAgICBvYmogPSB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSk7XFxuXFxuICAgICAgaWYgKG9ialswXSA9PT0gdGhpcy5lbGVtZW50WzBdKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5nZXRfY29udGFpbmVyX3VsKCkuY2hpbGRyZW4oXFxcIi5qc3RyZWUtbm9kZVxcXCIpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIW9iaiB8fCAhb2JqLmxlbmd0aCkge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gb2JqLmNoaWxkcmVuKFxcXCIuanN0cmVlLWNoaWxkcmVuXFxcIikuY2hpbGRyZW4oXFxcIi5qc3RyZWUtbm9kZVxcXCIpO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogY2hlY2tzIGlmIGEgbm9kZSBoYXMgY2hpbGRyZW5cXG4gICAgICogQG5hbWUgaXNfcGFyZW50KG9iailcXG4gICAgICogQHBhcmFtICB7bWl4ZWR9IG9ialxcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxcbiAgICAgKi9cXG4gICAgaXNfcGFyZW50OiBmdW5jdGlvbiBpc19wYXJlbnQob2JqKSB7XFxuICAgICAgb2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xcbiAgICAgIHJldHVybiBvYmogJiYgKG9iai5zdGF0ZS5sb2FkZWQgPT09IGZhbHNlIHx8IG9iai5jaGlsZHJlbi5sZW5ndGggPiAwKTtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIGNoZWNrcyBpZiBhIG5vZGUgaXMgbG9hZGVkIChpdHMgY2hpbGRyZW4gYXJlIGF2YWlsYWJsZSlcXG4gICAgICogQG5hbWUgaXNfbG9hZGVkKG9iailcXG4gICAgICogQHBhcmFtICB7bWl4ZWR9IG9ialxcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxcbiAgICAgKi9cXG4gICAgaXNfbG9hZGVkOiBmdW5jdGlvbiBpc19sb2FkZWQob2JqKSB7XFxuICAgICAgb2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xcbiAgICAgIHJldHVybiBvYmogJiYgb2JqLnN0YXRlLmxvYWRlZDtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIGNoZWNrIGlmIGEgbm9kZSBpcyBjdXJyZW50bHkgbG9hZGluZyAoZmV0Y2hpbmcgY2hpbGRyZW4pXFxuICAgICAqIEBuYW1lIGlzX2xvYWRpbmcob2JqKVxcbiAgICAgKiBAcGFyYW0gIHttaXhlZH0gb2JqXFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XFxuICAgICAqL1xcbiAgICBpc19sb2FkaW5nOiBmdW5jdGlvbiBpc19sb2FkaW5nKG9iaikge1xcbiAgICAgIG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcXG4gICAgICByZXR1cm4gb2JqICYmIG9iai5zdGF0ZSAmJiBvYmouc3RhdGUubG9hZGluZztcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIGNoZWNrIGlmIGEgbm9kZSBpcyBvcGVuZWRcXG4gICAgICogQG5hbWUgaXNfb3BlbihvYmopXFxuICAgICAqIEBwYXJhbSAge21peGVkfSBvYmpcXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cXG4gICAgICovXFxuICAgIGlzX29wZW46IGZ1bmN0aW9uIGlzX29wZW4ob2JqKSB7XFxuICAgICAgb2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xcbiAgICAgIHJldHVybiBvYmogJiYgb2JqLnN0YXRlLm9wZW5lZDtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIGNoZWNrIGlmIGEgbm9kZSBpcyBpbiBhIGNsb3NlZCBzdGF0ZVxcbiAgICAgKiBAbmFtZSBpc19jbG9zZWQob2JqKVxcbiAgICAgKiBAcGFyYW0gIHttaXhlZH0gb2JqXFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XFxuICAgICAqL1xcbiAgICBpc19jbG9zZWQ6IGZ1bmN0aW9uIGlzX2Nsb3NlZChvYmopIHtcXG4gICAgICBvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XFxuICAgICAgcmV0dXJuIG9iaiAmJiB0aGlzLmlzX3BhcmVudChvYmopICYmICFvYmouc3RhdGUub3BlbmVkO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogY2hlY2sgaWYgYSBub2RlIGhhcyBubyBjaGlsZHJlblxcbiAgICAgKiBAbmFtZSBpc19sZWFmKG9iailcXG4gICAgICogQHBhcmFtICB7bWl4ZWR9IG9ialxcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxcbiAgICAgKi9cXG4gICAgaXNfbGVhZjogZnVuY3Rpb24gaXNfbGVhZihvYmopIHtcXG4gICAgICByZXR1cm4gIXRoaXMuaXNfcGFyZW50KG9iaik7XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBsb2FkcyBhIG5vZGUgKGZldGNoZXMgaXRzIGNoaWxkcmVuIHVzaW5nIHRoZSBgY29yZS5kYXRhYCBzZXR0aW5nKS4gTXVsdGlwbGUgbm9kZXMgY2FuIGJlIHBhc3NlZCB0byBieSB1c2luZyBhbiBhcnJheS5cXG4gICAgICogQG5hbWUgbG9hZF9ub2RlKG9iaiBbLCBjYWxsYmFja10pXFxuICAgICAqIEBwYXJhbSAge21peGVkfSBvYmpcXG4gICAgICogQHBhcmFtICB7ZnVuY3Rpb259IGNhbGxiYWNrIGEgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgb25jZSBsb2FkaW5nIGlzIGNvbXBsZXRlLCB0aGUgZnVuY3Rpb24gaXMgZXhlY3V0ZWQgaW4gdGhlIGluc3RhbmNlJ3Mgc2NvcGUgYW5kIHJlY2VpdmVzIHR3byBhcmd1bWVudHMgLSB0aGUgbm9kZSBhbmQgYSBib29sZWFuIHN0YXR1c1xcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxcbiAgICAgKiBAdHJpZ2dlciBsb2FkX25vZGUuanN0cmVlXFxuICAgICAqL1xcbiAgICBsb2FkX25vZGU6IGZ1bmN0aW9uIGxvYWRfbm9kZShvYmosIGNhbGxiYWNrKSB7XFxuICAgICAgdmFyIGssIGwsIGksIGosIGM7XFxuXFxuICAgICAgaWYgKCQuaXNBcnJheShvYmopKSB7XFxuICAgICAgICB0aGlzLl9sb2FkX25vZGVzKG9iai5zbGljZSgpLCBjYWxsYmFjayk7XFxuXFxuICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICB9XFxuXFxuICAgICAgb2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xcblxcbiAgICAgIGlmICghb2JqKSB7XFxuICAgICAgICBpZiAoY2FsbGJhY2spIHtcXG4gICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCBvYmosIGZhbHNlKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9IC8vIGlmKG9iai5zdGF0ZS5sb2FkaW5nKSB7IH0gLy8gdGhlIG5vZGUgaXMgYWxyZWFkeSBsb2FkaW5nIC0ganVzdCB3YWl0IGZvciBpdCB0byBsb2FkIGFuZCBpbnZva2UgY2FsbGJhY2s/IGJ1dCBpZiBjYWxsZWQgaW1wbGljaXRseSBpdCBzaG91bGQgYmUgbG9hZGVkIGFnYWluP1xcblxcblxcbiAgICAgIGlmIChvYmouc3RhdGUubG9hZGVkKSB7XFxuICAgICAgICBvYmouc3RhdGUubG9hZGVkID0gZmFsc2U7XFxuXFxuICAgICAgICBmb3IgKGkgPSAwLCBqID0gb2JqLnBhcmVudHMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICAgIHRoaXMuX21vZGVsLmRhdGFbb2JqLnBhcmVudHNbaV1dLmNoaWxkcmVuX2QgPSAkLnZha2F0YS5hcnJheV9maWx0ZXIodGhpcy5fbW9kZWwuZGF0YVtvYmoucGFyZW50c1tpXV0uY2hpbGRyZW5fZCwgZnVuY3Rpb24gKHYpIHtcXG4gICAgICAgICAgICByZXR1cm4gJC5pbkFycmF5KHYsIG9iai5jaGlsZHJlbl9kKSA9PT0gLTE7XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZm9yIChrID0gMCwgbCA9IG9iai5jaGlsZHJlbl9kLmxlbmd0aDsgayA8IGw7IGsrKykge1xcbiAgICAgICAgICBpZiAodGhpcy5fbW9kZWwuZGF0YVtvYmouY2hpbGRyZW5fZFtrXV0uc3RhdGUuc2VsZWN0ZWQpIHtcXG4gICAgICAgICAgICBjID0gdHJ1ZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBkZWxldGUgdGhpcy5fbW9kZWwuZGF0YVtvYmouY2hpbGRyZW5fZFtrXV07XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoYykge1xcbiAgICAgICAgICB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQgPSAkLnZha2F0YS5hcnJheV9maWx0ZXIodGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLCBmdW5jdGlvbiAodikge1xcbiAgICAgICAgICAgIHJldHVybiAkLmluQXJyYXkodiwgb2JqLmNoaWxkcmVuX2QpID09PSAtMTtcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBvYmouY2hpbGRyZW4gPSBbXTtcXG4gICAgICAgIG9iai5jaGlsZHJlbl9kID0gW107XFxuXFxuICAgICAgICBpZiAoYykge1xcbiAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZWQnLCB7XFxuICAgICAgICAgICAgJ2FjdGlvbic6ICdsb2FkX25vZGUnLFxcbiAgICAgICAgICAgICdub2RlJzogb2JqLFxcbiAgICAgICAgICAgICdzZWxlY3RlZCc6IHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZFxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgb2JqLnN0YXRlLmZhaWxlZCA9IGZhbHNlO1xcbiAgICAgIG9iai5zdGF0ZS5sb2FkaW5nID0gdHJ1ZTtcXG4gICAgICB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSkuYWRkQ2xhc3MoXFxcImpzdHJlZS1sb2FkaW5nXFxcIikuYXR0cignYXJpYS1idXN5JywgdHJ1ZSk7XFxuXFxuICAgICAgdGhpcy5fbG9hZF9ub2RlKG9iaiwgJC5wcm94eShmdW5jdGlvbiAoc3RhdHVzKSB7XFxuICAgICAgICBvYmogPSB0aGlzLl9tb2RlbC5kYXRhW29iai5pZF07XFxuICAgICAgICBvYmouc3RhdGUubG9hZGluZyA9IGZhbHNlO1xcbiAgICAgICAgb2JqLnN0YXRlLmxvYWRlZCA9IHN0YXR1cztcXG4gICAgICAgIG9iai5zdGF0ZS5mYWlsZWQgPSAhb2JqLnN0YXRlLmxvYWRlZDtcXG4gICAgICAgIHZhciBkb20gPSB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSksXFxuICAgICAgICAgICAgaSA9IDAsXFxuICAgICAgICAgICAgaiA9IDAsXFxuICAgICAgICAgICAgbSA9IHRoaXMuX21vZGVsLmRhdGEsXFxuICAgICAgICAgICAgaGFzX2NoaWxkcmVuID0gZmFsc2U7XFxuXFxuICAgICAgICBmb3IgKGkgPSAwLCBqID0gb2JqLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcbiAgICAgICAgICBpZiAobVtvYmouY2hpbGRyZW5baV1dICYmICFtW29iai5jaGlsZHJlbltpXV0uc3RhdGUuaGlkZGVuKSB7XFxuICAgICAgICAgICAgaGFzX2NoaWxkcmVuID0gdHJ1ZTtcXG4gICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKG9iai5zdGF0ZS5sb2FkZWQgJiYgZG9tICYmIGRvbS5sZW5ndGgpIHtcXG4gICAgICAgICAgZG9tLnJlbW92ZUNsYXNzKCdqc3RyZWUtY2xvc2VkIGpzdHJlZS1vcGVuIGpzdHJlZS1sZWFmJyk7XFxuXFxuICAgICAgICAgIGlmICghaGFzX2NoaWxkcmVuKSB7XFxuICAgICAgICAgICAgZG9tLmFkZENsYXNzKCdqc3RyZWUtbGVhZicpO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGlmIChvYmouaWQgIT09ICcjJykge1xcbiAgICAgICAgICAgICAgZG9tLmFkZENsYXNzKG9iai5zdGF0ZS5vcGVuZWQgPyAnanN0cmVlLW9wZW4nIDogJ2pzdHJlZS1jbG9zZWQnKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGRvbS5yZW1vdmVDbGFzcyhcXFwianN0cmVlLWxvYWRpbmdcXFwiKS5hdHRyKCdhcmlhLWJ1c3knLCBmYWxzZSk7XFxuICAgICAgICAvKipcXG4gICAgICAgICAqIHRyaWdnZXJlZCBhZnRlciBhIG5vZGUgaXMgbG9hZGVkXFxuICAgICAgICAgKiBAZXZlbnRcXG4gICAgICAgICAqIEBuYW1lIGxvYWRfbm9kZS5qc3RyZWVcXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIHRoZSBub2RlIHRoYXQgd2FzIGxvYWRpbmdcXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc3RhdHVzIHdhcyB0aGUgbm9kZSBsb2FkZWQgc3VjY2Vzc2Z1bGx5XFxuICAgICAgICAgKi9cXG5cXG4gICAgICAgIHRoaXMudHJpZ2dlcignbG9hZF9ub2RlJywge1xcbiAgICAgICAgICBcXFwibm9kZVxcXCI6IG9iaixcXG4gICAgICAgICAgXFxcInN0YXR1c1xcXCI6IHN0YXR1c1xcbiAgICAgICAgfSk7XFxuXFxuICAgICAgICBpZiAoY2FsbGJhY2spIHtcXG4gICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCBvYmosIHN0YXR1cyk7XFxuICAgICAgICB9XFxuICAgICAgfSwgdGhpcykpO1xcblxcbiAgICAgIHJldHVybiB0cnVlO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogbG9hZCBhbiBhcnJheSBvZiBub2RlcyAod2lsbCBhbHNvIGxvYWQgdW5hdmFpbGFibGUgbm9kZXMgYXMgc29vbiBhcyB0aGUgYXBwZWFyIGluIHRoZSBzdHJ1Y3R1cmUpLiBVc2VkIGludGVybmFsbHkuXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBuYW1lIF9sb2FkX25vZGVzKG5vZGVzIFssIGNhbGxiYWNrXSlcXG4gICAgICogQHBhcmFtICB7YXJyYXl9IG5vZGVzXFxuICAgICAqIEBwYXJhbSAge2Z1bmN0aW9ufSBjYWxsYmFjayBhIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIG9uY2UgbG9hZGluZyBpcyBjb21wbGV0ZSwgdGhlIGZ1bmN0aW9uIGlzIGV4ZWN1dGVkIGluIHRoZSBpbnN0YW5jZSdzIHNjb3BlIGFuZCByZWNlaXZlcyBvbmUgYXJndW1lbnQgLSB0aGUgYXJyYXkgcGFzc2VkIHRvIF9sb2FkX25vZGVzXFxuICAgICAqL1xcbiAgICBfbG9hZF9ub2RlczogZnVuY3Rpb24gX2xvYWRfbm9kZXMobm9kZXMsIGNhbGxiYWNrLCBpc19jYWxsYmFjaywgZm9yY2VfcmVsb2FkKSB7XFxuICAgICAgdmFyIHIgPSB0cnVlLFxcbiAgICAgICAgICBjID0gZnVuY3Rpb24gYygpIHtcXG4gICAgICAgIHRoaXMuX2xvYWRfbm9kZXMobm9kZXMsIGNhbGxiYWNrLCB0cnVlKTtcXG4gICAgICB9LFxcbiAgICAgICAgICBtID0gdGhpcy5fbW9kZWwuZGF0YSxcXG4gICAgICAgICAgaSxcXG4gICAgICAgICAgaixcXG4gICAgICAgICAgdG1wID0gW107XFxuXFxuICAgICAgZm9yIChpID0gMCwgaiA9IG5vZGVzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcbiAgICAgICAgaWYgKG1bbm9kZXNbaV1dICYmICghbVtub2Rlc1tpXV0uc3RhdGUubG9hZGVkICYmICFtW25vZGVzW2ldXS5zdGF0ZS5mYWlsZWQgfHwgIWlzX2NhbGxiYWNrICYmIGZvcmNlX3JlbG9hZCkpIHtcXG4gICAgICAgICAgaWYgKCF0aGlzLmlzX2xvYWRpbmcobm9kZXNbaV0pKSB7XFxuICAgICAgICAgICAgdGhpcy5sb2FkX25vZGUobm9kZXNbaV0sIGMpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHIgPSBmYWxzZTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHIpIHtcXG4gICAgICAgIGZvciAoaSA9IDAsIGogPSBub2Rlcy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG4gICAgICAgICAgaWYgKG1bbm9kZXNbaV1dICYmIG1bbm9kZXNbaV1dLnN0YXRlLmxvYWRlZCkge1xcbiAgICAgICAgICAgIHRtcC5wdXNoKG5vZGVzW2ldKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKGNhbGxiYWNrICYmICFjYWxsYmFjay5kb25lKSB7XFxuICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgdG1wKTtcXG4gICAgICAgICAgY2FsbGJhY2suZG9uZSA9IHRydWU7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogbG9hZHMgYWxsIHVubG9hZGVkIG5vZGVzXFxuICAgICAqIEBuYW1lIGxvYWRfYWxsKFtvYmosIGNhbGxiYWNrXSlcXG4gICAgICogQHBhcmFtIHttaXhlZH0gb2JqIHRoZSBub2RlIHRvIGxvYWQgcmVjdXJzaXZlbHksIG9taXQgdG8gbG9hZCBhbGwgbm9kZXMgaW4gdGhlIHRyZWVcXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgYSBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCBvbmNlIGxvYWRpbmcgYWxsIHRoZSBub2RlcyBpcyBjb21wbGV0ZSxcXG4gICAgICogQHRyaWdnZXIgbG9hZF9hbGwuanN0cmVlXFxuICAgICAqL1xcbiAgICBsb2FkX2FsbDogZnVuY3Rpb24gbG9hZF9hbGwob2JqLCBjYWxsYmFjaykge1xcbiAgICAgIGlmICghb2JqKSB7XFxuICAgICAgICBvYmogPSAkLmpzdHJlZS5yb290O1xcbiAgICAgIH1cXG5cXG4gICAgICBvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XFxuXFxuICAgICAgaWYgKCFvYmopIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIHRvX2xvYWQgPSBbXSxcXG4gICAgICAgICAgbSA9IHRoaXMuX21vZGVsLmRhdGEsXFxuICAgICAgICAgIGMgPSBtW29iai5pZF0uY2hpbGRyZW5fZCxcXG4gICAgICAgICAgaSxcXG4gICAgICAgICAgajtcXG5cXG4gICAgICBpZiAob2JqLnN0YXRlICYmICFvYmouc3RhdGUubG9hZGVkKSB7XFxuICAgICAgICB0b19sb2FkLnB1c2gob2JqLmlkKTtcXG4gICAgICB9XFxuXFxuICAgICAgZm9yIChpID0gMCwgaiA9IGMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICBpZiAobVtjW2ldXSAmJiBtW2NbaV1dLnN0YXRlICYmICFtW2NbaV1dLnN0YXRlLmxvYWRlZCkge1xcbiAgICAgICAgICB0b19sb2FkLnB1c2goY1tpXSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0b19sb2FkLmxlbmd0aCkge1xcbiAgICAgICAgdGhpcy5fbG9hZF9ub2Rlcyh0b19sb2FkLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHRoaXMubG9hZF9hbGwob2JqLCBjYWxsYmFjayk7XFxuICAgICAgICB9KTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgLyoqXFxuICAgICAgICAgKiB0cmlnZ2VyZWQgYWZ0ZXIgYSBsb2FkX2FsbCBjYWxsIGNvbXBsZXRlc1xcbiAgICAgICAgICogQGV2ZW50XFxuICAgICAgICAgKiBAbmFtZSBsb2FkX2FsbC5qc3RyZWVcXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIHRoZSByZWN1cnNpdmVseSBsb2FkZWQgbm9kZVxcbiAgICAgICAgICovXFxuICAgICAgICBpZiAoY2FsbGJhY2spIHtcXG4gICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCBvYmopO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdsb2FkX2FsbCcsIHtcXG4gICAgICAgICAgXFxcIm5vZGVcXFwiOiBvYmpcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIGhhbmRsZXMgdGhlIGFjdHVhbCBsb2FkaW5nIG9mIGEgbm9kZS4gVXNlZCBvbmx5IGludGVybmFsbHkuXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBuYW1lIF9sb2FkX25vZGUob2JqIFssIGNhbGxiYWNrXSlcXG4gICAgICogQHBhcmFtICB7bWl4ZWR9IG9ialxcbiAgICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gY2FsbGJhY2sgYSBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCBvbmNlIGxvYWRpbmcgaXMgY29tcGxldGUsIHRoZSBmdW5jdGlvbiBpcyBleGVjdXRlZCBpbiB0aGUgaW5zdGFuY2UncyBzY29wZSBhbmQgcmVjZWl2ZXMgb25lIGFyZ3VtZW50IC0gYSBib29sZWFuIHN0YXR1c1xcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxcbiAgICAgKi9cXG4gICAgX2xvYWRfbm9kZTogZnVuY3Rpb24gX2xvYWRfbm9kZShvYmosIGNhbGxiYWNrKSB7XFxuICAgICAgdmFyIHMgPSB0aGlzLnNldHRpbmdzLmNvcmUuZGF0YSxcXG4gICAgICAgICAgdDtcXG5cXG4gICAgICB2YXIgbm90VGV4dE9yQ29tbWVudE5vZGUgPSBmdW5jdGlvbiBub3RUZXh0T3JDb21tZW50Tm9kZSgpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVUeXBlICE9PSAzICYmIHRoaXMubm9kZVR5cGUgIT09IDg7XFxuICAgICAgfTsgLy8gdXNlIG9yaWdpbmFsIEhUTUxcXG5cXG5cXG4gICAgICBpZiAoIXMpIHtcXG4gICAgICAgIGlmIChvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcXG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGVuZF9odG1sX2RhdGEob2JqLCB0aGlzLl9kYXRhLmNvcmUub3JpZ2luYWxfY29udGFpbmVyX2h0bWwuY2xvbmUodHJ1ZSksIGZ1bmN0aW9uIChzdGF0dXMpIHtcXG4gICAgICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXMsIHN0YXR1cyk7XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwodGhpcywgZmFsc2UpO1xcbiAgICAgICAgfSAvLyByZXR1cm4gY2FsbGJhY2suY2FsbCh0aGlzLCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QgPyB0aGlzLl9hcHBlbmRfaHRtbF9kYXRhKG9iaiwgdGhpcy5fZGF0YS5jb3JlLm9yaWdpbmFsX2NvbnRhaW5lcl9odG1sLmNsb25lKHRydWUpKSA6IGZhbHNlKTtcXG5cXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCQuaXNGdW5jdGlvbihzKSkge1xcbiAgICAgICAgcmV0dXJuIHMuY2FsbCh0aGlzLCBvYmosICQucHJveHkoZnVuY3Rpb24gKGQpIHtcXG4gICAgICAgICAgaWYgKGQgPT09IGZhbHNlKSB7XFxuICAgICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCBmYWxzZSk7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgdGhpc1t0eXBlb2YgZCA9PT0gJ3N0cmluZycgPyAnX2FwcGVuZF9odG1sX2RhdGEnIDogJ19hcHBlbmRfanNvbl9kYXRhJ10ob2JqLCB0eXBlb2YgZCA9PT0gJ3N0cmluZycgPyAkKCQucGFyc2VIVE1MKGQpKS5maWx0ZXIobm90VGV4dE9yQ29tbWVudE5vZGUpIDogZCwgZnVuY3Rpb24gKHN0YXR1cykge1xcbiAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCBzdGF0dXMpO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICB9IC8vIHJldHVybiBkID09PSBmYWxzZSA/IGNhbGxiYWNrLmNhbGwodGhpcywgZmFsc2UpIDogY2FsbGJhY2suY2FsbCh0aGlzLCB0aGlzW3R5cGVvZiBkID09PSAnc3RyaW5nJyA/ICdfYXBwZW5kX2h0bWxfZGF0YScgOiAnX2FwcGVuZF9qc29uX2RhdGEnXShvYmosIHR5cGVvZiBkID09PSAnc3RyaW5nJyA/ICQoZCkgOiBkKSk7XFxuXFxuICAgICAgICB9LCB0aGlzKSk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChfdHlwZW9mKHMpID09PSAnb2JqZWN0Jykge1xcbiAgICAgICAgaWYgKHMudXJsKSB7XFxuICAgICAgICAgIHMgPSAkLmV4dGVuZCh0cnVlLCB7fSwgcyk7XFxuXFxuICAgICAgICAgIGlmICgkLmlzRnVuY3Rpb24ocy51cmwpKSB7XFxuICAgICAgICAgICAgcy51cmwgPSBzLnVybC5jYWxsKHRoaXMsIG9iaik7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaWYgKCQuaXNGdW5jdGlvbihzLmRhdGEpKSB7XFxuICAgICAgICAgICAgcy5kYXRhID0gcy5kYXRhLmNhbGwodGhpcywgb2JqKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICByZXR1cm4gJC5hamF4KHMpLmRvbmUoJC5wcm94eShmdW5jdGlvbiAoZCwgdCwgeCkge1xcbiAgICAgICAgICAgIHZhciB0eXBlID0geC5nZXRSZXNwb25zZUhlYWRlcignQ29udGVudC1UeXBlJyk7XFxuXFxuICAgICAgICAgICAgaWYgKHR5cGUgJiYgdHlwZS5pbmRleE9mKCdqc29uJykgIT09IC0xIHx8IF90eXBlb2YoZCkgPT09IFxcXCJvYmplY3RcXFwiKSB7XFxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYXBwZW5kX2pzb25fZGF0YShvYmosIGQsIGZ1bmN0aW9uIChzdGF0dXMpIHtcXG4gICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCBzdGF0dXMpO1xcbiAgICAgICAgICAgICAgfSk7IC8vcmV0dXJuIGNhbGxiYWNrLmNhbGwodGhpcywgdGhpcy5fYXBwZW5kX2pzb25fZGF0YShvYmosIGQpKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaWYgKHR5cGUgJiYgdHlwZS5pbmRleE9mKCdodG1sJykgIT09IC0xIHx8IHR5cGVvZiBkID09PSBcXFwic3RyaW5nXFxcIikge1xcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGVuZF9odG1sX2RhdGEob2JqLCAkKCQucGFyc2VIVE1MKGQpKS5maWx0ZXIobm90VGV4dE9yQ29tbWVudE5vZGUpLCBmdW5jdGlvbiAoc3RhdHVzKSB7XFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgc3RhdHVzKTtcXG4gICAgICAgICAgICAgIH0pOyAvLyByZXR1cm4gY2FsbGJhY2suY2FsbCh0aGlzLCB0aGlzLl9hcHBlbmRfaHRtbF9kYXRhKG9iaiwgJChkKSkpO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICB0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvciA9IHtcXG4gICAgICAgICAgICAgICdlcnJvcic6ICdhamF4JyxcXG4gICAgICAgICAgICAgICdwbHVnaW4nOiAnY29yZScsXFxuICAgICAgICAgICAgICAnaWQnOiAnY29yZV8wNCcsXFxuICAgICAgICAgICAgICAncmVhc29uJzogJ0NvdWxkIG5vdCBsb2FkIG5vZGUnLFxcbiAgICAgICAgICAgICAgJ2RhdGEnOiBKU09OLnN0cmluZ2lmeSh7XFxuICAgICAgICAgICAgICAgICdpZCc6IG9iai5pZCxcXG4gICAgICAgICAgICAgICAgJ3hocic6IHhcXG4gICAgICAgICAgICAgIH0pXFxuICAgICAgICAgICAgfTtcXG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzLmNvcmUuZXJyb3IuY2FsbCh0aGlzLCB0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvcik7XFxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwodGhpcywgZmFsc2UpO1xcbiAgICAgICAgICB9LCB0aGlzKSkuZmFpbCgkLnByb3h5KGZ1bmN0aW9uIChmKSB7XFxuICAgICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCBmYWxzZSk7XFxuICAgICAgICAgICAgdGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IgPSB7XFxuICAgICAgICAgICAgICAnZXJyb3InOiAnYWpheCcsXFxuICAgICAgICAgICAgICAncGx1Z2luJzogJ2NvcmUnLFxcbiAgICAgICAgICAgICAgJ2lkJzogJ2NvcmVfMDQnLFxcbiAgICAgICAgICAgICAgJ3JlYXNvbic6ICdDb3VsZCBub3QgbG9hZCBub2RlJyxcXG4gICAgICAgICAgICAgICdkYXRhJzogSlNPTi5zdHJpbmdpZnkoe1xcbiAgICAgICAgICAgICAgICAnaWQnOiBvYmouaWQsXFxuICAgICAgICAgICAgICAgICd4aHInOiBmXFxuICAgICAgICAgICAgICB9KVxcbiAgICAgICAgICAgIH07XFxuICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5jb3JlLmVycm9yLmNhbGwodGhpcywgdGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IpO1xcbiAgICAgICAgICB9LCB0aGlzKSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0ID0gJC5pc0FycmF5KHMpIHx8ICQuaXNQbGFpbk9iamVjdChzKSA/IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocykpIDogcztcXG5cXG4gICAgICAgIGlmIChvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcXG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGVuZF9qc29uX2RhdGEob2JqLCB0LCBmdW5jdGlvbiAoc3RhdHVzKSB7XFxuICAgICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCBzdGF0dXMpO1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yID0ge1xcbiAgICAgICAgICAgICdlcnJvcic6ICdub2RhdGEnLFxcbiAgICAgICAgICAgICdwbHVnaW4nOiAnY29yZScsXFxuICAgICAgICAgICAgJ2lkJzogJ2NvcmVfMDUnLFxcbiAgICAgICAgICAgICdyZWFzb24nOiAnQ291bGQgbm90IGxvYWQgbm9kZScsXFxuICAgICAgICAgICAgJ2RhdGEnOiBKU09OLnN0cmluZ2lmeSh7XFxuICAgICAgICAgICAgICAnaWQnOiBvYmouaWRcXG4gICAgICAgICAgICB9KVxcbiAgICAgICAgICB9O1xcbiAgICAgICAgICB0aGlzLnNldHRpbmdzLmNvcmUuZXJyb3IuY2FsbCh0aGlzLCB0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvcik7XFxuICAgICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHRoaXMsIGZhbHNlKTtcXG4gICAgICAgIH0gLy9yZXR1cm4gY2FsbGJhY2suY2FsbCh0aGlzLCAob2JqLmlkID09PSAkLmpzdHJlZS5yb290ID8gdGhpcy5fYXBwZW5kX2pzb25fZGF0YShvYmosIHQpIDogZmFsc2UpICk7XFxuXFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0eXBlb2YgcyA9PT0gJ3N0cmluZycpIHtcXG4gICAgICAgIGlmIChvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcXG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGVuZF9odG1sX2RhdGEob2JqLCAkKCQucGFyc2VIVE1MKHMpKS5maWx0ZXIobm90VGV4dE9yQ29tbWVudE5vZGUpLCBmdW5jdGlvbiAoc3RhdHVzKSB7XFxuICAgICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCBzdGF0dXMpO1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yID0ge1xcbiAgICAgICAgICAgICdlcnJvcic6ICdub2RhdGEnLFxcbiAgICAgICAgICAgICdwbHVnaW4nOiAnY29yZScsXFxuICAgICAgICAgICAgJ2lkJzogJ2NvcmVfMDYnLFxcbiAgICAgICAgICAgICdyZWFzb24nOiAnQ291bGQgbm90IGxvYWQgbm9kZScsXFxuICAgICAgICAgICAgJ2RhdGEnOiBKU09OLnN0cmluZ2lmeSh7XFxuICAgICAgICAgICAgICAnaWQnOiBvYmouaWRcXG4gICAgICAgICAgICB9KVxcbiAgICAgICAgICB9O1xcbiAgICAgICAgICB0aGlzLnNldHRpbmdzLmNvcmUuZXJyb3IuY2FsbCh0aGlzLCB0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvcik7XFxuICAgICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHRoaXMsIGZhbHNlKTtcXG4gICAgICAgIH0gLy9yZXR1cm4gY2FsbGJhY2suY2FsbCh0aGlzLCAob2JqLmlkID09PSAkLmpzdHJlZS5yb290ID8gdGhpcy5fYXBwZW5kX2h0bWxfZGF0YShvYmosICQocykpIDogZmFsc2UpICk7XFxuXFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHRoaXMsIGZhbHNlKTtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIGFkZHMgYSBub2RlIHRvIHRoZSBsaXN0IG9mIG5vZGVzIHRvIHJlZHJhdy4gVXNlZCBvbmx5IGludGVybmFsbHkuXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBuYW1lIF9ub2RlX2NoYW5nZWQob2JqIFssIGNhbGxiYWNrXSlcXG4gICAgICogQHBhcmFtICB7bWl4ZWR9IG9ialxcbiAgICAgKi9cXG4gICAgX25vZGVfY2hhbmdlZDogZnVuY3Rpb24gX25vZGVfY2hhbmdlZChvYmopIHtcXG4gICAgICBvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XFxuXFxuICAgICAgaWYgKG9iaikge1xcbiAgICAgICAgdGhpcy5fbW9kZWwuY2hhbmdlZC5wdXNoKG9iai5pZCk7XFxuICAgICAgfVxcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogYXBwZW5kcyBIVE1MIGNvbnRlbnQgdG8gdGhlIHRyZWUuIFVzZWQgaW50ZXJuYWxseS5cXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQG5hbWUgX2FwcGVuZF9odG1sX2RhdGEob2JqLCBkYXRhKVxcbiAgICAgKiBAcGFyYW0gIHttaXhlZH0gb2JqIHRoZSBub2RlIHRvIGFwcGVuZCB0b1xcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGRhdGEgdGhlIEhUTUwgc3RyaW5nIHRvIHBhcnNlIGFuZCBhcHBlbmRcXG4gICAgICogQHRyaWdnZXIgbW9kZWwuanN0cmVlLCBjaGFuZ2VkLmpzdHJlZVxcbiAgICAgKi9cXG4gICAgX2FwcGVuZF9odG1sX2RhdGE6IGZ1bmN0aW9uIF9hcHBlbmRfaHRtbF9kYXRhKGRvbSwgZGF0YSwgY2IpIHtcXG4gICAgICBkb20gPSB0aGlzLmdldF9ub2RlKGRvbSk7XFxuICAgICAgZG9tLmNoaWxkcmVuID0gW107XFxuICAgICAgZG9tLmNoaWxkcmVuX2QgPSBbXTtcXG4gICAgICB2YXIgZGF0ID0gZGF0YS5pcygndWwnKSA/IGRhdGEuY2hpbGRyZW4oKSA6IGRhdGEsXFxuICAgICAgICAgIHBhciA9IGRvbS5pZCxcXG4gICAgICAgICAgY2hkID0gW10sXFxuICAgICAgICAgIGRwYyA9IFtdLFxcbiAgICAgICAgICBtID0gdGhpcy5fbW9kZWwuZGF0YSxcXG4gICAgICAgICAgcCA9IG1bcGFyXSxcXG4gICAgICAgICAgcyA9IHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZC5sZW5ndGgsXFxuICAgICAgICAgIHRtcCxcXG4gICAgICAgICAgaSxcXG4gICAgICAgICAgajtcXG4gICAgICBkYXQuZWFjaCgkLnByb3h5KGZ1bmN0aW9uIChpLCB2KSB7XFxuICAgICAgICB0bXAgPSB0aGlzLl9wYXJzZV9tb2RlbF9mcm9tX2h0bWwoJCh2KSwgcGFyLCBwLnBhcmVudHMuY29uY2F0KCkpO1xcblxcbiAgICAgICAgaWYgKHRtcCkge1xcbiAgICAgICAgICBjaGQucHVzaCh0bXApO1xcbiAgICAgICAgICBkcGMucHVzaCh0bXApO1xcblxcbiAgICAgICAgICBpZiAobVt0bXBdLmNoaWxkcmVuX2QubGVuZ3RoKSB7XFxuICAgICAgICAgICAgZHBjID0gZHBjLmNvbmNhdChtW3RtcF0uY2hpbGRyZW5fZCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9LCB0aGlzKSk7XFxuICAgICAgcC5jaGlsZHJlbiA9IGNoZDtcXG4gICAgICBwLmNoaWxkcmVuX2QgPSBkcGM7XFxuXFxuICAgICAgZm9yIChpID0gMCwgaiA9IHAucGFyZW50cy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG4gICAgICAgIG1bcC5wYXJlbnRzW2ldXS5jaGlsZHJlbl9kID0gbVtwLnBhcmVudHNbaV1dLmNoaWxkcmVuX2QuY29uY2F0KGRwYyk7XFxuICAgICAgfVxcbiAgICAgIC8qKlxcbiAgICAgICAqIHRyaWdnZXJlZCB3aGVuIG5ldyBkYXRhIGlzIGluc2VydGVkIHRvIHRoZSB0cmVlIG1vZGVsXFxuICAgICAgICogQGV2ZW50XFxuICAgICAgICogQG5hbWUgbW9kZWwuanN0cmVlXFxuICAgICAgICogQHBhcmFtIHtBcnJheX0gbm9kZXMgYW4gYXJyYXkgb2Ygbm9kZSBJRHNcXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyZW50IHRoZSBwYXJlbnQgSUQgb2YgdGhlIG5vZGVzXFxuICAgICAgICovXFxuXFxuXFxuICAgICAgdGhpcy50cmlnZ2VyKCdtb2RlbCcsIHtcXG4gICAgICAgIFxcXCJub2Rlc1xcXCI6IGRwYyxcXG4gICAgICAgICdwYXJlbnQnOiBwYXJcXG4gICAgICB9KTtcXG5cXG4gICAgICBpZiAocGFyICE9PSAkLmpzdHJlZS5yb290KSB7XFxuICAgICAgICB0aGlzLl9ub2RlX2NoYW5nZWQocGFyKTtcXG5cXG4gICAgICAgIHRoaXMucmVkcmF3KCk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpLmNoaWxkcmVuKCcuanN0cmVlLWluaXRpYWwtbm9kZScpLnJlbW92ZSgpO1xcbiAgICAgICAgdGhpcy5yZWRyYXcodHJ1ZSk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQubGVuZ3RoICE9PSBzKSB7XFxuICAgICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZWQnLCB7XFxuICAgICAgICAgICdhY3Rpb24nOiAnbW9kZWwnLFxcbiAgICAgICAgICAnc2VsZWN0ZWQnOiB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWRcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG5cXG4gICAgICBjYi5jYWxsKHRoaXMsIHRydWUpO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogYXBwZW5kcyBKU09OIGNvbnRlbnQgdG8gdGhlIHRyZWUuIFVzZWQgaW50ZXJuYWxseS5cXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQG5hbWUgX2FwcGVuZF9qc29uX2RhdGEob2JqLCBkYXRhKVxcbiAgICAgKiBAcGFyYW0gIHttaXhlZH0gb2JqIHRoZSBub2RlIHRvIGFwcGVuZCB0b1xcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGRhdGEgdGhlIEpTT04gb2JqZWN0IHRvIHBhcnNlIGFuZCBhcHBlbmRcXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gZm9yY2VfcHJvY2Vzc2luZyBpbnRlcm5hbCBwYXJhbSAtIGRvIG5vdCBzZXRcXG4gICAgICogQHRyaWdnZXIgbW9kZWwuanN0cmVlLCBjaGFuZ2VkLmpzdHJlZVxcbiAgICAgKi9cXG4gICAgX2FwcGVuZF9qc29uX2RhdGE6IGZ1bmN0aW9uIF9hcHBlbmRfanNvbl9kYXRhKGRvbSwgZGF0YSwgY2IsIGZvcmNlX3Byb2Nlc3NpbmcpIHtcXG4gICAgICBpZiAodGhpcy5lbGVtZW50ID09PSBudWxsKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGRvbSA9IHRoaXMuZ2V0X25vZGUoZG9tKTtcXG4gICAgICBkb20uY2hpbGRyZW4gPSBbXTtcXG4gICAgICBkb20uY2hpbGRyZW5fZCA9IFtdOyAvLyAqJSRAISEhXFxuXFxuICAgICAgaWYgKGRhdGEuZCkge1xcbiAgICAgICAgZGF0YSA9IGRhdGEuZDtcXG5cXG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXFxcInN0cmluZ1xcXCIpIHtcXG4gICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghJC5pc0FycmF5KGRhdGEpKSB7XFxuICAgICAgICBkYXRhID0gW2RhdGFdO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgdyA9IG51bGwsXFxuICAgICAgICAgIGFyZ3MgPSB7XFxuICAgICAgICAnZGYnOiB0aGlzLl9tb2RlbC5kZWZhdWx0X3N0YXRlLFxcbiAgICAgICAgJ2RhdCc6IGRhdGEsXFxuICAgICAgICAncGFyJzogZG9tLmlkLFxcbiAgICAgICAgJ20nOiB0aGlzLl9tb2RlbC5kYXRhLFxcbiAgICAgICAgJ3RfaWQnOiB0aGlzLl9pZCxcXG4gICAgICAgICd0X2NudCc6IHRoaXMuX2NudCxcXG4gICAgICAgICdzZWwnOiB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWRcXG4gICAgICB9LFxcbiAgICAgICAgICBmdW5jID0gZnVuY3Rpb24gZnVuYyhkYXRhLCB1bmRlZmluZWQpIHtcXG4gICAgICAgIGlmIChkYXRhLmRhdGEpIHtcXG4gICAgICAgICAgZGF0YSA9IGRhdGEuZGF0YTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHZhciBkYXQgPSBkYXRhLmRhdCxcXG4gICAgICAgICAgICBwYXIgPSBkYXRhLnBhcixcXG4gICAgICAgICAgICBjaGQgPSBbXSxcXG4gICAgICAgICAgICBkcGMgPSBbXSxcXG4gICAgICAgICAgICBhZGQgPSBbXSxcXG4gICAgICAgICAgICBkZiA9IGRhdGEuZGYsXFxuICAgICAgICAgICAgdF9pZCA9IGRhdGEudF9pZCxcXG4gICAgICAgICAgICB0X2NudCA9IGRhdGEudF9jbnQsXFxuICAgICAgICAgICAgbSA9IGRhdGEubSxcXG4gICAgICAgICAgICBwID0gbVtwYXJdLFxcbiAgICAgICAgICAgIHNlbCA9IGRhdGEuc2VsLFxcbiAgICAgICAgICAgIHRtcCxcXG4gICAgICAgICAgICBpLFxcbiAgICAgICAgICAgIGosXFxuICAgICAgICAgICAgcnNsdCxcXG4gICAgICAgICAgICBwYXJzZV9mbGF0ID0gZnVuY3Rpb24gcGFyc2VfZmxhdChkLCBwLCBwcykge1xcbiAgICAgICAgICBpZiAoIXBzKSB7XFxuICAgICAgICAgICAgcHMgPSBbXTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBwcyA9IHBzLmNvbmNhdCgpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmIChwKSB7XFxuICAgICAgICAgICAgcHMudW5zaGlmdChwKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICB2YXIgdGlkID0gZC5pZC50b1N0cmluZygpLFxcbiAgICAgICAgICAgICAgaSxcXG4gICAgICAgICAgICAgIGosXFxuICAgICAgICAgICAgICBjLFxcbiAgICAgICAgICAgICAgZSxcXG4gICAgICAgICAgICAgIHRtcCA9IHtcXG4gICAgICAgICAgICBpZDogdGlkLFxcbiAgICAgICAgICAgIHRleHQ6IGQudGV4dCB8fCAnJyxcXG4gICAgICAgICAgICBpY29uOiBkLmljb24gIT09IHVuZGVmaW5lZCA/IGQuaWNvbiA6IHRydWUsXFxuICAgICAgICAgICAgcGFyZW50OiBwLFxcbiAgICAgICAgICAgIHBhcmVudHM6IHBzLFxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBkLmNoaWxkcmVuIHx8IFtdLFxcbiAgICAgICAgICAgIGNoaWxkcmVuX2Q6IGQuY2hpbGRyZW5fZCB8fCBbXSxcXG4gICAgICAgICAgICBkYXRhOiBkLmRhdGEsXFxuICAgICAgICAgICAgc3RhdGU6IHt9LFxcbiAgICAgICAgICAgIGxpX2F0dHI6IHtcXG4gICAgICAgICAgICAgIGlkOiBmYWxzZVxcbiAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgYV9hdHRyOiB7XFxuICAgICAgICAgICAgICBocmVmOiAnIydcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIG9yaWdpbmFsOiBmYWxzZVxcbiAgICAgICAgICB9O1xcblxcbiAgICAgICAgICBmb3IgKGkgaW4gZGYpIHtcXG4gICAgICAgICAgICBpZiAoZGYuaGFzT3duUHJvcGVydHkoaSkpIHtcXG4gICAgICAgICAgICAgIHRtcC5zdGF0ZVtpXSA9IGRmW2ldO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAoZCAmJiBkLmRhdGEgJiYgZC5kYXRhLmpzdHJlZSAmJiBkLmRhdGEuanN0cmVlLmljb24pIHtcXG4gICAgICAgICAgICB0bXAuaWNvbiA9IGQuZGF0YS5qc3RyZWUuaWNvbjtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAodG1wLmljb24gPT09IHVuZGVmaW5lZCB8fCB0bXAuaWNvbiA9PT0gbnVsbCB8fCB0bXAuaWNvbiA9PT0gXFxcIlxcXCIpIHtcXG4gICAgICAgICAgICB0bXAuaWNvbiA9IHRydWU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaWYgKGQgJiYgZC5kYXRhKSB7XFxuICAgICAgICAgICAgdG1wLmRhdGEgPSBkLmRhdGE7XFxuXFxuICAgICAgICAgICAgaWYgKGQuZGF0YS5qc3RyZWUpIHtcXG4gICAgICAgICAgICAgIGZvciAoaSBpbiBkLmRhdGEuanN0cmVlKSB7XFxuICAgICAgICAgICAgICAgIGlmIChkLmRhdGEuanN0cmVlLmhhc093blByb3BlcnR5KGkpKSB7XFxuICAgICAgICAgICAgICAgICAgdG1wLnN0YXRlW2ldID0gZC5kYXRhLmpzdHJlZVtpXTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAoZCAmJiBfdHlwZW9mKGQuc3RhdGUpID09PSAnb2JqZWN0Jykge1xcbiAgICAgICAgICAgIGZvciAoaSBpbiBkLnN0YXRlKSB7XFxuICAgICAgICAgICAgICBpZiAoZC5zdGF0ZS5oYXNPd25Qcm9wZXJ0eShpKSkge1xcbiAgICAgICAgICAgICAgICB0bXAuc3RhdGVbaV0gPSBkLnN0YXRlW2ldO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAoZCAmJiBfdHlwZW9mKGQubGlfYXR0cikgPT09ICdvYmplY3QnKSB7XFxuICAgICAgICAgICAgZm9yIChpIGluIGQubGlfYXR0cikge1xcbiAgICAgICAgICAgICAgaWYgKGQubGlfYXR0ci5oYXNPd25Qcm9wZXJ0eShpKSkge1xcbiAgICAgICAgICAgICAgICB0bXAubGlfYXR0cltpXSA9IGQubGlfYXR0cltpXTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaWYgKCF0bXAubGlfYXR0ci5pZCkge1xcbiAgICAgICAgICAgIHRtcC5saV9hdHRyLmlkID0gdGlkO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmIChkICYmIF90eXBlb2YoZC5hX2F0dHIpID09PSAnb2JqZWN0Jykge1xcbiAgICAgICAgICAgIGZvciAoaSBpbiBkLmFfYXR0cikge1xcbiAgICAgICAgICAgICAgaWYgKGQuYV9hdHRyLmhhc093blByb3BlcnR5KGkpKSB7XFxuICAgICAgICAgICAgICAgIHRtcC5hX2F0dHJbaV0gPSBkLmFfYXR0cltpXTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaWYgKGQgJiYgZC5jaGlsZHJlbiAmJiBkLmNoaWxkcmVuID09PSB0cnVlKSB7XFxuICAgICAgICAgICAgdG1wLnN0YXRlLmxvYWRlZCA9IGZhbHNlO1xcbiAgICAgICAgICAgIHRtcC5jaGlsZHJlbiA9IFtdO1xcbiAgICAgICAgICAgIHRtcC5jaGlsZHJlbl9kID0gW107XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgbVt0bXAuaWRdID0gdG1wO1xcblxcbiAgICAgICAgICBmb3IgKGkgPSAwLCBqID0gdG1wLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcbiAgICAgICAgICAgIGMgPSBwYXJzZV9mbGF0KG1bdG1wLmNoaWxkcmVuW2ldXSwgdG1wLmlkLCBwcyk7XFxuICAgICAgICAgICAgZSA9IG1bY107XFxuICAgICAgICAgICAgdG1wLmNoaWxkcmVuX2QucHVzaChjKTtcXG5cXG4gICAgICAgICAgICBpZiAoZS5jaGlsZHJlbl9kLmxlbmd0aCkge1xcbiAgICAgICAgICAgICAgdG1wLmNoaWxkcmVuX2QgPSB0bXAuY2hpbGRyZW5fZC5jb25jYXQoZS5jaGlsZHJlbl9kKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZGVsZXRlIGQuZGF0YTtcXG4gICAgICAgICAgZGVsZXRlIGQuY2hpbGRyZW47XFxuICAgICAgICAgIG1bdG1wLmlkXS5vcmlnaW5hbCA9IGQ7XFxuXFxuICAgICAgICAgIGlmICh0bXAuc3RhdGUuc2VsZWN0ZWQpIHtcXG4gICAgICAgICAgICBhZGQucHVzaCh0bXAuaWQpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHJldHVybiB0bXAuaWQ7XFxuICAgICAgICB9LFxcbiAgICAgICAgICAgIHBhcnNlX25lc3QgPSBmdW5jdGlvbiBwYXJzZV9uZXN0KGQsIHAsIHBzKSB7XFxuICAgICAgICAgIGlmICghcHMpIHtcXG4gICAgICAgICAgICBwcyA9IFtdO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHBzID0gcHMuY29uY2F0KCk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaWYgKHApIHtcXG4gICAgICAgICAgICBwcy51bnNoaWZ0KHApO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHZhciB0aWQgPSBmYWxzZSxcXG4gICAgICAgICAgICAgIGksXFxuICAgICAgICAgICAgICBqLFxcbiAgICAgICAgICAgICAgYyxcXG4gICAgICAgICAgICAgIGUsXFxuICAgICAgICAgICAgICB0bXA7XFxuXFxuICAgICAgICAgIGRvIHtcXG4gICAgICAgICAgICB0aWQgPSAnaicgKyB0X2lkICsgJ18nICsgKyt0X2NudDtcXG4gICAgICAgICAgfSB3aGlsZSAobVt0aWRdKTtcXG5cXG4gICAgICAgICAgdG1wID0ge1xcbiAgICAgICAgICAgIGlkOiBmYWxzZSxcXG4gICAgICAgICAgICB0ZXh0OiB0eXBlb2YgZCA9PT0gJ3N0cmluZycgPyBkIDogJycsXFxuICAgICAgICAgICAgaWNvbjogX3R5cGVvZihkKSA9PT0gJ29iamVjdCcgJiYgZC5pY29uICE9PSB1bmRlZmluZWQgPyBkLmljb24gOiB0cnVlLFxcbiAgICAgICAgICAgIHBhcmVudDogcCxcXG4gICAgICAgICAgICBwYXJlbnRzOiBwcyxcXG4gICAgICAgICAgICBjaGlsZHJlbjogW10sXFxuICAgICAgICAgICAgY2hpbGRyZW5fZDogW10sXFxuICAgICAgICAgICAgZGF0YTogbnVsbCxcXG4gICAgICAgICAgICBzdGF0ZToge30sXFxuICAgICAgICAgICAgbGlfYXR0cjoge1xcbiAgICAgICAgICAgICAgaWQ6IGZhbHNlXFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICBhX2F0dHI6IHtcXG4gICAgICAgICAgICAgIGhyZWY6ICcjJ1xcbiAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgb3JpZ2luYWw6IGZhbHNlXFxuICAgICAgICAgIH07XFxuXFxuICAgICAgICAgIGZvciAoaSBpbiBkZikge1xcbiAgICAgICAgICAgIGlmIChkZi5oYXNPd25Qcm9wZXJ0eShpKSkge1xcbiAgICAgICAgICAgICAgdG1wLnN0YXRlW2ldID0gZGZbaV07XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmIChkICYmIGQuaWQpIHtcXG4gICAgICAgICAgICB0bXAuaWQgPSBkLmlkLnRvU3RyaW5nKCk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaWYgKGQgJiYgZC50ZXh0KSB7XFxuICAgICAgICAgICAgdG1wLnRleHQgPSBkLnRleHQ7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaWYgKGQgJiYgZC5kYXRhICYmIGQuZGF0YS5qc3RyZWUgJiYgZC5kYXRhLmpzdHJlZS5pY29uKSB7XFxuICAgICAgICAgICAgdG1wLmljb24gPSBkLmRhdGEuanN0cmVlLmljb247XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaWYgKHRtcC5pY29uID09PSB1bmRlZmluZWQgfHwgdG1wLmljb24gPT09IG51bGwgfHwgdG1wLmljb24gPT09IFxcXCJcXFwiKSB7XFxuICAgICAgICAgICAgdG1wLmljb24gPSB0cnVlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmIChkICYmIGQuZGF0YSkge1xcbiAgICAgICAgICAgIHRtcC5kYXRhID0gZC5kYXRhO1xcblxcbiAgICAgICAgICAgIGlmIChkLmRhdGEuanN0cmVlKSB7XFxuICAgICAgICAgICAgICBmb3IgKGkgaW4gZC5kYXRhLmpzdHJlZSkge1xcbiAgICAgICAgICAgICAgICBpZiAoZC5kYXRhLmpzdHJlZS5oYXNPd25Qcm9wZXJ0eShpKSkge1xcbiAgICAgICAgICAgICAgICAgIHRtcC5zdGF0ZVtpXSA9IGQuZGF0YS5qc3RyZWVbaV07XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaWYgKGQgJiYgX3R5cGVvZihkLnN0YXRlKSA9PT0gJ29iamVjdCcpIHtcXG4gICAgICAgICAgICBmb3IgKGkgaW4gZC5zdGF0ZSkge1xcbiAgICAgICAgICAgICAgaWYgKGQuc3RhdGUuaGFzT3duUHJvcGVydHkoaSkpIHtcXG4gICAgICAgICAgICAgICAgdG1wLnN0YXRlW2ldID0gZC5zdGF0ZVtpXTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaWYgKGQgJiYgX3R5cGVvZihkLmxpX2F0dHIpID09PSAnb2JqZWN0Jykge1xcbiAgICAgICAgICAgIGZvciAoaSBpbiBkLmxpX2F0dHIpIHtcXG4gICAgICAgICAgICAgIGlmIChkLmxpX2F0dHIuaGFzT3duUHJvcGVydHkoaSkpIHtcXG4gICAgICAgICAgICAgICAgdG1wLmxpX2F0dHJbaV0gPSBkLmxpX2F0dHJbaV07XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmICh0bXAubGlfYXR0ci5pZCAmJiAhdG1wLmlkKSB7XFxuICAgICAgICAgICAgdG1wLmlkID0gdG1wLmxpX2F0dHIuaWQudG9TdHJpbmcoKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAoIXRtcC5pZCkge1xcbiAgICAgICAgICAgIHRtcC5pZCA9IHRpZDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAoIXRtcC5saV9hdHRyLmlkKSB7XFxuICAgICAgICAgICAgdG1wLmxpX2F0dHIuaWQgPSB0bXAuaWQ7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaWYgKGQgJiYgX3R5cGVvZihkLmFfYXR0cikgPT09ICdvYmplY3QnKSB7XFxuICAgICAgICAgICAgZm9yIChpIGluIGQuYV9hdHRyKSB7XFxuICAgICAgICAgICAgICBpZiAoZC5hX2F0dHIuaGFzT3duUHJvcGVydHkoaSkpIHtcXG4gICAgICAgICAgICAgICAgdG1wLmFfYXR0cltpXSA9IGQuYV9hdHRyW2ldO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAoZCAmJiBkLmNoaWxkcmVuICYmIGQuY2hpbGRyZW4ubGVuZ3RoKSB7XFxuICAgICAgICAgICAgZm9yIChpID0gMCwgaiA9IGQuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICAgICAgICBjID0gcGFyc2VfbmVzdChkLmNoaWxkcmVuW2ldLCB0bXAuaWQsIHBzKTtcXG4gICAgICAgICAgICAgIGUgPSBtW2NdO1xcbiAgICAgICAgICAgICAgdG1wLmNoaWxkcmVuLnB1c2goYyk7XFxuXFxuICAgICAgICAgICAgICBpZiAoZS5jaGlsZHJlbl9kLmxlbmd0aCkge1xcbiAgICAgICAgICAgICAgICB0bXAuY2hpbGRyZW5fZCA9IHRtcC5jaGlsZHJlbl9kLmNvbmNhdChlLmNoaWxkcmVuX2QpO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICB0bXAuY2hpbGRyZW5fZCA9IHRtcC5jaGlsZHJlbl9kLmNvbmNhdCh0bXAuY2hpbGRyZW4pO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmIChkICYmIGQuY2hpbGRyZW4gJiYgZC5jaGlsZHJlbiA9PT0gdHJ1ZSkge1xcbiAgICAgICAgICAgIHRtcC5zdGF0ZS5sb2FkZWQgPSBmYWxzZTtcXG4gICAgICAgICAgICB0bXAuY2hpbGRyZW4gPSBbXTtcXG4gICAgICAgICAgICB0bXAuY2hpbGRyZW5fZCA9IFtdO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGRlbGV0ZSBkLmRhdGE7XFxuICAgICAgICAgIGRlbGV0ZSBkLmNoaWxkcmVuO1xcbiAgICAgICAgICB0bXAub3JpZ2luYWwgPSBkO1xcbiAgICAgICAgICBtW3RtcC5pZF0gPSB0bXA7XFxuXFxuICAgICAgICAgIGlmICh0bXAuc3RhdGUuc2VsZWN0ZWQpIHtcXG4gICAgICAgICAgICBhZGQucHVzaCh0bXAuaWQpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHJldHVybiB0bXAuaWQ7XFxuICAgICAgICB9O1xcblxcbiAgICAgICAgaWYgKGRhdC5sZW5ndGggJiYgZGF0WzBdLmlkICE9PSB1bmRlZmluZWQgJiYgZGF0WzBdLnBhcmVudCAhPT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgIC8vIEZsYXQgSlNPTiBzdXBwb3J0IChmb3IgZWFzeSBpbXBvcnQgZnJvbSBEQik6XFxuICAgICAgICAgIC8vIDEpIGNvbnZlcnQgdG8gb2JqZWN0IChmb3JlYWNoKVxcbiAgICAgICAgICBmb3IgKGkgPSAwLCBqID0gZGF0Lmxlbmd0aDsgaSA8IGo7IGkrKykge1xcbiAgICAgICAgICAgIGlmICghZGF0W2ldLmNoaWxkcmVuKSB7XFxuICAgICAgICAgICAgICBkYXRbaV0uY2hpbGRyZW4gPSBbXTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgbVtkYXRbaV0uaWQudG9TdHJpbmcoKV0gPSBkYXRbaV07XFxuICAgICAgICAgIH0gLy8gMikgcG9wdWxhdGUgY2hpbGRyZW4gKGZvcmVhY2gpXFxuXFxuXFxuICAgICAgICAgIGZvciAoaSA9IDAsIGogPSBkYXQubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICAgICAgbVtkYXRbaV0ucGFyZW50LnRvU3RyaW5nKCldLmNoaWxkcmVuLnB1c2goZGF0W2ldLmlkLnRvU3RyaW5nKCkpOyAvLyBwb3B1bGF0ZSBwYXJlbnQuY2hpbGRyZW5fZFxcblxcbiAgICAgICAgICAgIHAuY2hpbGRyZW5fZC5wdXNoKGRhdFtpXS5pZC50b1N0cmluZygpKTtcXG4gICAgICAgICAgfSAvLyAzKSBub3JtYWxpemUgJiYgcG9wdWxhdGUgcGFyZW50cyBhbmQgY2hpbGRyZW5fZCB3aXRoIHJlY3Vyc2lvblxcblxcblxcbiAgICAgICAgICBmb3IgKGkgPSAwLCBqID0gcC5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG4gICAgICAgICAgICB0bXAgPSBwYXJzZV9mbGF0KG1bcC5jaGlsZHJlbltpXV0sIHBhciwgcC5wYXJlbnRzLmNvbmNhdCgpKTtcXG4gICAgICAgICAgICBkcGMucHVzaCh0bXApO1xcblxcbiAgICAgICAgICAgIGlmIChtW3RtcF0uY2hpbGRyZW5fZC5sZW5ndGgpIHtcXG4gICAgICAgICAgICAgIGRwYyA9IGRwYy5jb25jYXQobVt0bXBdLmNoaWxkcmVuX2QpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBmb3IgKGkgPSAwLCBqID0gcC5wYXJlbnRzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcbiAgICAgICAgICAgIG1bcC5wYXJlbnRzW2ldXS5jaGlsZHJlbl9kID0gbVtwLnBhcmVudHNbaV1dLmNoaWxkcmVuX2QuY29uY2F0KGRwYyk7XFxuICAgICAgICAgIH0gLy8gPykgdGhyZWVfc3RhdGUgc2VsZWN0aW9uIC0gcC5zdGF0ZS5zZWxlY3RlZCAmJiB0IC0gKGlmIHRocmVlX3N0YXRlIGZvcmVhY2goZGF0ID0+IGNoKSAtPiBmb3JlYWNoKHBhcmVudHMpIGlmKHBhcmVudC5zZWxlY3RlZCkgY2hpbGQuc2VsZWN0ZWQgPSB0cnVlO1xcblxcblxcbiAgICAgICAgICByc2x0ID0ge1xcbiAgICAgICAgICAgICdjbnQnOiB0X2NudCxcXG4gICAgICAgICAgICAnbW9kJzogbSxcXG4gICAgICAgICAgICAnc2VsJzogc2VsLFxcbiAgICAgICAgICAgICdwYXInOiBwYXIsXFxuICAgICAgICAgICAgJ2RwYyc6IGRwYyxcXG4gICAgICAgICAgICAnYWRkJzogYWRkXFxuICAgICAgICAgIH07XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBmb3IgKGkgPSAwLCBqID0gZGF0Lmxlbmd0aDsgaSA8IGo7IGkrKykge1xcbiAgICAgICAgICAgIHRtcCA9IHBhcnNlX25lc3QoZGF0W2ldLCBwYXIsIHAucGFyZW50cy5jb25jYXQoKSk7XFxuXFxuICAgICAgICAgICAgaWYgKHRtcCkge1xcbiAgICAgICAgICAgICAgY2hkLnB1c2godG1wKTtcXG4gICAgICAgICAgICAgIGRwYy5wdXNoKHRtcCk7XFxuXFxuICAgICAgICAgICAgICBpZiAobVt0bXBdLmNoaWxkcmVuX2QubGVuZ3RoKSB7XFxuICAgICAgICAgICAgICAgIGRwYyA9IGRwYy5jb25jYXQobVt0bXBdLmNoaWxkcmVuX2QpO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBwLmNoaWxkcmVuID0gY2hkO1xcbiAgICAgICAgICBwLmNoaWxkcmVuX2QgPSBkcGM7XFxuXFxuICAgICAgICAgIGZvciAoaSA9IDAsIGogPSBwLnBhcmVudHMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICAgICAgbVtwLnBhcmVudHNbaV1dLmNoaWxkcmVuX2QgPSBtW3AucGFyZW50c1tpXV0uY2hpbGRyZW5fZC5jb25jYXQoZHBjKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICByc2x0ID0ge1xcbiAgICAgICAgICAgICdjbnQnOiB0X2NudCxcXG4gICAgICAgICAgICAnbW9kJzogbSxcXG4gICAgICAgICAgICAnc2VsJzogc2VsLFxcbiAgICAgICAgICAgICdwYXInOiBwYXIsXFxuICAgICAgICAgICAgJ2RwYyc6IGRwYyxcXG4gICAgICAgICAgICAnYWRkJzogYWRkXFxuICAgICAgICAgIH07XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAgICAgcG9zdE1lc3NhZ2UocnNsdCk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICByZXR1cm4gcnNsdDtcXG4gICAgICAgIH1cXG4gICAgICB9LFxcbiAgICAgICAgICByc2x0ID0gZnVuY3Rpb24gcnNsdChfcnNsdCwgd29ya2VyKSB7XFxuICAgICAgICBpZiAodGhpcy5lbGVtZW50ID09PSBudWxsKSB7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHRoaXMuX2NudCA9IF9yc2x0LmNudDtcXG4gICAgICAgIHZhciBpLFxcbiAgICAgICAgICAgIG0gPSB0aGlzLl9tb2RlbC5kYXRhO1xcblxcbiAgICAgICAgZm9yIChpIGluIG0pIHtcXG4gICAgICAgICAgaWYgKG0uaGFzT3duUHJvcGVydHkoaSkgJiYgbVtpXS5zdGF0ZSAmJiBtW2ldLnN0YXRlLmxvYWRpbmcgJiYgX3JzbHQubW9kW2ldKSB7XFxuICAgICAgICAgICAgX3JzbHQubW9kW2ldLnN0YXRlLmxvYWRpbmcgPSB0cnVlO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0aGlzLl9tb2RlbC5kYXRhID0gX3JzbHQubW9kOyAvLyBicmVha3MgdGhlIHJlZmVyZW5jZSBpbiBsb2FkX25vZGUgLSBjYXJlZnVsXFxuXFxuICAgICAgICBpZiAod29ya2VyKSB7XFxuICAgICAgICAgIHZhciBqLFxcbiAgICAgICAgICAgICAgYSA9IF9yc2x0LmFkZCxcXG4gICAgICAgICAgICAgIHIgPSBfcnNsdC5zZWwsXFxuICAgICAgICAgICAgICBzID0gdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLnNsaWNlKCk7XFxuXFxuICAgICAgICAgIG0gPSB0aGlzLl9tb2RlbC5kYXRhOyAvLyBpZiBzZWxlY3Rpb24gd2FzIGNoYW5nZWQgd2hpbGUgY2FsY3VsYXRpbmcgaW4gd29ya2VyXFxuXFxuICAgICAgICAgIGlmIChyLmxlbmd0aCAhPT0gcy5sZW5ndGggfHwgJC52YWthdGEuYXJyYXlfdW5pcXVlKHIuY29uY2F0KHMpKS5sZW5ndGggIT09IHIubGVuZ3RoKSB7XFxuICAgICAgICAgICAgLy8gZGVzZWxlY3Qgbm9kZXMgdGhhdCBhcmUgbm8gbG9uZ2VyIHNlbGVjdGVkXFxuICAgICAgICAgICAgZm9yIChpID0gMCwgaiA9IHIubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICAgICAgICBpZiAoJC5pbkFycmF5KHJbaV0sIGEpID09PSAtMSAmJiAkLmluQXJyYXkocltpXSwgcykgPT09IC0xKSB7XFxuICAgICAgICAgICAgICAgIG1bcltpXV0uc3RhdGUuc2VsZWN0ZWQgPSBmYWxzZTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9IC8vIHNlbGVjdCBub2RlcyB0aGF0IHdlcmUgc2VsZWN0ZWQgaW4gdGhlIG1lYW4gdGltZVxcblxcblxcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGogPSBzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcbiAgICAgICAgICAgICAgaWYgKCQuaW5BcnJheShzW2ldLCByKSA9PT0gLTEpIHtcXG4gICAgICAgICAgICAgICAgbVtzW2ldXS5zdGF0ZS5zZWxlY3RlZCA9IHRydWU7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoX3JzbHQuYWRkLmxlbmd0aCkge1xcbiAgICAgICAgICB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQgPSB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQuY29uY2F0KF9yc2x0LmFkZCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0aGlzLnRyaWdnZXIoJ21vZGVsJywge1xcbiAgICAgICAgICBcXFwibm9kZXNcXFwiOiBfcnNsdC5kcGMsXFxuICAgICAgICAgICdwYXJlbnQnOiBfcnNsdC5wYXJcXG4gICAgICAgIH0pO1xcblxcbiAgICAgICAgaWYgKF9yc2x0LnBhciAhPT0gJC5qc3RyZWUucm9vdCkge1xcbiAgICAgICAgICB0aGlzLl9ub2RlX2NoYW5nZWQoX3JzbHQucGFyKTtcXG5cXG4gICAgICAgICAgdGhpcy5yZWRyYXcoKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIC8vIHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpLmNoaWxkcmVuKCcuanN0cmVlLWluaXRpYWwtbm9kZScpLnJlbW92ZSgpO1xcbiAgICAgICAgICB0aGlzLnJlZHJhdyh0cnVlKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChfcnNsdC5hZGQubGVuZ3RoKSB7XFxuICAgICAgICAgIHRoaXMudHJpZ2dlcignY2hhbmdlZCcsIHtcXG4gICAgICAgICAgICAnYWN0aW9uJzogJ21vZGVsJyxcXG4gICAgICAgICAgICAnc2VsZWN0ZWQnOiB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWRcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBjYi5jYWxsKHRoaXMsIHRydWUpO1xcbiAgICAgIH07XFxuXFxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuY29yZS53b3JrZXIgJiYgd2luZG93LkJsb2IgJiYgd2luZG93LlVSTCAmJiB3aW5kb3cuV29ya2VyKSB7XFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICBpZiAodGhpcy5fd3JrID09PSBudWxsKSB7XFxuICAgICAgICAgICAgdGhpcy5fd3JrID0gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwobmV3IHdpbmRvdy5CbG9iKFsnc2VsZi5vbm1lc3NhZ2UgPSAnICsgZnVuYy50b1N0cmluZygpXSwge1xcbiAgICAgICAgICAgICAgdHlwZTogXFxcInRleHQvamF2YXNjcmlwdFxcXCJcXG4gICAgICAgICAgICB9KSk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaWYgKCF0aGlzLl9kYXRhLmNvcmUud29ya2luZyB8fCBmb3JjZV9wcm9jZXNzaW5nKSB7XFxuICAgICAgICAgICAgdGhpcy5fZGF0YS5jb3JlLndvcmtpbmcgPSB0cnVlO1xcbiAgICAgICAgICAgIHcgPSBuZXcgd2luZG93Lldvcmtlcih0aGlzLl93cmspO1xcbiAgICAgICAgICAgIHcub25tZXNzYWdlID0gJC5wcm94eShmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICAgICAgcnNsdC5jYWxsKHRoaXMsIGUuZGF0YSwgdHJ1ZSk7XFxuXFxuICAgICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgICB3LnRlcm1pbmF0ZSgpO1xcbiAgICAgICAgICAgICAgICB3ID0gbnVsbDtcXG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cXG5cXG4gICAgICAgICAgICAgIGlmICh0aGlzLl9kYXRhLmNvcmUud29ya2VyX3F1ZXVlLmxlbmd0aCkge1xcbiAgICAgICAgICAgICAgICB0aGlzLl9hcHBlbmRfanNvbl9kYXRhLmFwcGx5KHRoaXMsIHRoaXMuX2RhdGEuY29yZS53b3JrZXJfcXVldWUuc2hpZnQoKSk7XFxuICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICB0aGlzLl9kYXRhLmNvcmUud29ya2luZyA9IGZhbHNlO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0sIHRoaXMpO1xcblxcbiAgICAgICAgICAgIGlmICghYXJncy5wYXIpIHtcXG4gICAgICAgICAgICAgIGlmICh0aGlzLl9kYXRhLmNvcmUud29ya2VyX3F1ZXVlLmxlbmd0aCkge1xcbiAgICAgICAgICAgICAgICB0aGlzLl9hcHBlbmRfanNvbl9kYXRhLmFwcGx5KHRoaXMsIHRoaXMuX2RhdGEuY29yZS53b3JrZXJfcXVldWUuc2hpZnQoKSk7XFxuICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICB0aGlzLl9kYXRhLmNvcmUud29ya2luZyA9IGZhbHNlO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICB3LnBvc3RNZXNzYWdlKGFyZ3MpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICB0aGlzLl9kYXRhLmNvcmUud29ya2VyX3F1ZXVlLnB1c2goW2RvbSwgZGF0YSwgY2IsIHRydWVdKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgICByc2x0LmNhbGwodGhpcywgZnVuYyhhcmdzKSwgZmFsc2UpO1xcblxcbiAgICAgICAgICBpZiAodGhpcy5fZGF0YS5jb3JlLndvcmtlcl9xdWV1ZS5sZW5ndGgpIHtcXG4gICAgICAgICAgICB0aGlzLl9hcHBlbmRfanNvbl9kYXRhLmFwcGx5KHRoaXMsIHRoaXMuX2RhdGEuY29yZS53b3JrZXJfcXVldWUuc2hpZnQoKSk7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgdGhpcy5fZGF0YS5jb3JlLndvcmtpbmcgPSBmYWxzZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICByc2x0LmNhbGwodGhpcywgZnVuYyhhcmdzKSwgZmFsc2UpO1xcbiAgICAgIH1cXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIHBhcnNlcyBhIG5vZGUgZnJvbSBhIGpRdWVyeSBvYmplY3QgYW5kIGFwcGVuZHMgdGhlbSB0byB0aGUgaW4gbWVtb3J5IHRyZWUgbW9kZWwuIFVzZWQgaW50ZXJuYWxseS5cXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQG5hbWUgX3BhcnNlX21vZGVsX2Zyb21faHRtbChkIFssIHAsIHBzXSlcXG4gICAgICogQHBhcmFtICB7alF1ZXJ5fSBkIHRoZSBqUXVlcnkgb2JqZWN0IHRvIHBhcnNlXFxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gcCB0aGUgcGFyZW50IElEXFxuICAgICAqIEBwYXJhbSAge0FycmF5fSBwcyBsaXN0IG9mIGFsbCBwYXJlbnRzXFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gdGhlIElEIG9mIHRoZSBvYmplY3QgYWRkZWQgdG8gdGhlIG1vZGVsXFxuICAgICAqL1xcbiAgICBfcGFyc2VfbW9kZWxfZnJvbV9odG1sOiBmdW5jdGlvbiBfcGFyc2VfbW9kZWxfZnJvbV9odG1sKGQsIHAsIHBzKSB7XFxuICAgICAgaWYgKCFwcykge1xcbiAgICAgICAgcHMgPSBbXTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgcHMgPSBbXS5jb25jYXQocHMpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAocCkge1xcbiAgICAgICAgcHMudW5zaGlmdChwKTtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIGMsXFxuICAgICAgICAgIGUsXFxuICAgICAgICAgIG0gPSB0aGlzLl9tb2RlbC5kYXRhLFxcbiAgICAgICAgICBkYXRhID0ge1xcbiAgICAgICAgaWQ6IGZhbHNlLFxcbiAgICAgICAgdGV4dDogZmFsc2UsXFxuICAgICAgICBpY29uOiB0cnVlLFxcbiAgICAgICAgcGFyZW50OiBwLFxcbiAgICAgICAgcGFyZW50czogcHMsXFxuICAgICAgICBjaGlsZHJlbjogW10sXFxuICAgICAgICBjaGlsZHJlbl9kOiBbXSxcXG4gICAgICAgIGRhdGE6IG51bGwsXFxuICAgICAgICBzdGF0ZToge30sXFxuICAgICAgICBsaV9hdHRyOiB7XFxuICAgICAgICAgIGlkOiBmYWxzZVxcbiAgICAgICAgfSxcXG4gICAgICAgIGFfYXR0cjoge1xcbiAgICAgICAgICBocmVmOiAnIydcXG4gICAgICAgIH0sXFxuICAgICAgICBvcmlnaW5hbDogZmFsc2VcXG4gICAgICB9LFxcbiAgICAgICAgICBpLFxcbiAgICAgICAgICB0bXAsXFxuICAgICAgICAgIHRpZDtcXG5cXG4gICAgICBmb3IgKGkgaW4gdGhpcy5fbW9kZWwuZGVmYXVsdF9zdGF0ZSkge1xcbiAgICAgICAgaWYgKHRoaXMuX21vZGVsLmRlZmF1bHRfc3RhdGUuaGFzT3duUHJvcGVydHkoaSkpIHtcXG4gICAgICAgICAgZGF0YS5zdGF0ZVtpXSA9IHRoaXMuX21vZGVsLmRlZmF1bHRfc3RhdGVbaV07XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHRtcCA9ICQudmFrYXRhLmF0dHJpYnV0ZXMoZCwgdHJ1ZSk7XFxuICAgICAgJC5lYWNoKHRtcCwgZnVuY3Rpb24gKGksIHYpIHtcXG4gICAgICAgIHYgPSAkLnRyaW0odik7XFxuXFxuICAgICAgICBpZiAoIXYubGVuZ3RoKSB7XFxuICAgICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZGF0YS5saV9hdHRyW2ldID0gdjtcXG5cXG4gICAgICAgIGlmIChpID09PSAnaWQnKSB7XFxuICAgICAgICAgIGRhdGEuaWQgPSB2LnRvU3RyaW5nKCk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgICAgdG1wID0gZC5jaGlsZHJlbignYScpLmZpcnN0KCk7XFxuXFxuICAgICAgaWYgKHRtcC5sZW5ndGgpIHtcXG4gICAgICAgIHRtcCA9ICQudmFrYXRhLmF0dHJpYnV0ZXModG1wLCB0cnVlKTtcXG4gICAgICAgICQuZWFjaCh0bXAsIGZ1bmN0aW9uIChpLCB2KSB7XFxuICAgICAgICAgIHYgPSAkLnRyaW0odik7XFxuXFxuICAgICAgICAgIGlmICh2Lmxlbmd0aCkge1xcbiAgICAgICAgICAgIGRhdGEuYV9hdHRyW2ldID0gdjtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIHRtcCA9IGQuY2hpbGRyZW4oXFxcImFcXFwiKS5maXJzdCgpLmxlbmd0aCA/IGQuY2hpbGRyZW4oXFxcImFcXFwiKS5maXJzdCgpLmNsb25lKCkgOiBkLmNsb25lKCk7XFxuICAgICAgdG1wLmNoaWxkcmVuKFxcXCJpbnMsIGksIHVsXFxcIikucmVtb3ZlKCk7XFxuICAgICAgdG1wID0gdG1wLmh0bWwoKTtcXG4gICAgICB0bXAgPSAkKCc8ZGl2IC8+JykuaHRtbCh0bXApO1xcbiAgICAgIGRhdGEudGV4dCA9IHRoaXMuc2V0dGluZ3MuY29yZS5mb3JjZV90ZXh0ID8gdG1wLnRleHQoKSA6IHRtcC5odG1sKCk7XFxuICAgICAgdG1wID0gZC5kYXRhKCk7XFxuICAgICAgZGF0YS5kYXRhID0gdG1wID8gJC5leHRlbmQodHJ1ZSwge30sIHRtcCkgOiBudWxsO1xcbiAgICAgIGRhdGEuc3RhdGUub3BlbmVkID0gZC5oYXNDbGFzcygnanN0cmVlLW9wZW4nKTtcXG4gICAgICBkYXRhLnN0YXRlLnNlbGVjdGVkID0gZC5jaGlsZHJlbignYScpLmhhc0NsYXNzKCdqc3RyZWUtY2xpY2tlZCcpO1xcbiAgICAgIGRhdGEuc3RhdGUuZGlzYWJsZWQgPSBkLmNoaWxkcmVuKCdhJykuaGFzQ2xhc3MoJ2pzdHJlZS1kaXNhYmxlZCcpO1xcblxcbiAgICAgIGlmIChkYXRhLmRhdGEgJiYgZGF0YS5kYXRhLmpzdHJlZSkge1xcbiAgICAgICAgZm9yIChpIGluIGRhdGEuZGF0YS5qc3RyZWUpIHtcXG4gICAgICAgICAgaWYgKGRhdGEuZGF0YS5qc3RyZWUuaGFzT3duUHJvcGVydHkoaSkpIHtcXG4gICAgICAgICAgICBkYXRhLnN0YXRlW2ldID0gZGF0YS5kYXRhLmpzdHJlZVtpXTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICB0bXAgPSBkLmNoaWxkcmVuKFxcXCJhXFxcIikuY2hpbGRyZW4oXFxcIi5qc3RyZWUtdGhlbWVpY29uXFxcIik7XFxuXFxuICAgICAgaWYgKHRtcC5sZW5ndGgpIHtcXG4gICAgICAgIGRhdGEuaWNvbiA9IHRtcC5oYXNDbGFzcygnanN0cmVlLXRoZW1laWNvbi1oaWRkZW4nKSA/IGZhbHNlIDogdG1wLmF0dHIoJ3JlbCcpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoZGF0YS5zdGF0ZS5pY29uICE9PSB1bmRlZmluZWQpIHtcXG4gICAgICAgIGRhdGEuaWNvbiA9IGRhdGEuc3RhdGUuaWNvbjtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGRhdGEuaWNvbiA9PT0gdW5kZWZpbmVkIHx8IGRhdGEuaWNvbiA9PT0gbnVsbCB8fCBkYXRhLmljb24gPT09IFxcXCJcXFwiKSB7XFxuICAgICAgICBkYXRhLmljb24gPSB0cnVlO1xcbiAgICAgIH1cXG5cXG4gICAgICB0bXAgPSBkLmNoaWxkcmVuKFxcXCJ1bFxcXCIpLmNoaWxkcmVuKFxcXCJsaVxcXCIpO1xcblxcbiAgICAgIGRvIHtcXG4gICAgICAgIHRpZCA9ICdqJyArIHRoaXMuX2lkICsgJ18nICsgKyt0aGlzLl9jbnQ7XFxuICAgICAgfSB3aGlsZSAobVt0aWRdKTtcXG5cXG4gICAgICBkYXRhLmlkID0gZGF0YS5saV9hdHRyLmlkID8gZGF0YS5saV9hdHRyLmlkLnRvU3RyaW5nKCkgOiB0aWQ7XFxuXFxuICAgICAgaWYgKHRtcC5sZW5ndGgpIHtcXG4gICAgICAgIHRtcC5lYWNoKCQucHJveHkoZnVuY3Rpb24gKGksIHYpIHtcXG4gICAgICAgICAgYyA9IHRoaXMuX3BhcnNlX21vZGVsX2Zyb21faHRtbCgkKHYpLCBkYXRhLmlkLCBwcyk7XFxuICAgICAgICAgIGUgPSB0aGlzLl9tb2RlbC5kYXRhW2NdO1xcbiAgICAgICAgICBkYXRhLmNoaWxkcmVuLnB1c2goYyk7XFxuXFxuICAgICAgICAgIGlmIChlLmNoaWxkcmVuX2QubGVuZ3RoKSB7XFxuICAgICAgICAgICAgZGF0YS5jaGlsZHJlbl9kID0gZGF0YS5jaGlsZHJlbl9kLmNvbmNhdChlLmNoaWxkcmVuX2QpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9LCB0aGlzKSk7XFxuICAgICAgICBkYXRhLmNoaWxkcmVuX2QgPSBkYXRhLmNoaWxkcmVuX2QuY29uY2F0KGRhdGEuY2hpbGRyZW4pO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBpZiAoZC5oYXNDbGFzcygnanN0cmVlLWNsb3NlZCcpKSB7XFxuICAgICAgICAgIGRhdGEuc3RhdGUubG9hZGVkID0gZmFsc2U7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChkYXRhLmxpX2F0dHJbJ2NsYXNzJ10pIHtcXG4gICAgICAgIGRhdGEubGlfYXR0clsnY2xhc3MnXSA9IGRhdGEubGlfYXR0clsnY2xhc3MnXS5yZXBsYWNlKCdqc3RyZWUtY2xvc2VkJywgJycpLnJlcGxhY2UoJ2pzdHJlZS1vcGVuJywgJycpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoZGF0YS5hX2F0dHJbJ2NsYXNzJ10pIHtcXG4gICAgICAgIGRhdGEuYV9hdHRyWydjbGFzcyddID0gZGF0YS5hX2F0dHJbJ2NsYXNzJ10ucmVwbGFjZSgnanN0cmVlLWNsaWNrZWQnLCAnJykucmVwbGFjZSgnanN0cmVlLWRpc2FibGVkJywgJycpO1xcbiAgICAgIH1cXG5cXG4gICAgICBtW2RhdGEuaWRdID0gZGF0YTtcXG5cXG4gICAgICBpZiAoZGF0YS5zdGF0ZS5zZWxlY3RlZCkge1xcbiAgICAgICAgdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLnB1c2goZGF0YS5pZCk7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBkYXRhLmlkO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogcGFyc2VzIGEgbm9kZSBmcm9tIGEgSlNPTiBvYmplY3QgKHVzZWQgd2hlbiBkZWFsaW5nIHdpdGggZmxhdCBkYXRhLCB3aGljaCBoYXMgbm8gbmVzdGluZyBvZiBjaGlsZHJlbiwgYnV0IGhhcyBpZCBhbmQgcGFyZW50IHByb3BlcnRpZXMpIGFuZCBhcHBlbmRzIGl0IHRvIHRoZSBpbiBtZW1vcnkgdHJlZSBtb2RlbC4gVXNlZCBpbnRlcm5hbGx5LlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAbmFtZSBfcGFyc2VfbW9kZWxfZnJvbV9mbGF0X2pzb24oZCBbLCBwLCBwc10pXFxuICAgICAqIEBwYXJhbSAge09iamVjdH0gZCB0aGUgSlNPTiBvYmplY3QgdG8gcGFyc2VcXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBwIHRoZSBwYXJlbnQgSURcXG4gICAgICogQHBhcmFtICB7QXJyYXl9IHBzIGxpc3Qgb2YgYWxsIHBhcmVudHNcXG4gICAgICogQHJldHVybiB7U3RyaW5nfSB0aGUgSUQgb2YgdGhlIG9iamVjdCBhZGRlZCB0byB0aGUgbW9kZWxcXG4gICAgICovXFxuICAgIF9wYXJzZV9tb2RlbF9mcm9tX2ZsYXRfanNvbjogZnVuY3Rpb24gX3BhcnNlX21vZGVsX2Zyb21fZmxhdF9qc29uKGQsIHAsIHBzKSB7XFxuICAgICAgaWYgKCFwcykge1xcbiAgICAgICAgcHMgPSBbXTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgcHMgPSBwcy5jb25jYXQoKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHApIHtcXG4gICAgICAgIHBzLnVuc2hpZnQocCk7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciB0aWQgPSBkLmlkLnRvU3RyaW5nKCksXFxuICAgICAgICAgIG0gPSB0aGlzLl9tb2RlbC5kYXRhLFxcbiAgICAgICAgICBkZiA9IHRoaXMuX21vZGVsLmRlZmF1bHRfc3RhdGUsXFxuICAgICAgICAgIGksXFxuICAgICAgICAgIGosXFxuICAgICAgICAgIGMsXFxuICAgICAgICAgIGUsXFxuICAgICAgICAgIHRtcCA9IHtcXG4gICAgICAgIGlkOiB0aWQsXFxuICAgICAgICB0ZXh0OiBkLnRleHQgfHwgJycsXFxuICAgICAgICBpY29uOiBkLmljb24gIT09IHVuZGVmaW5lZCA/IGQuaWNvbiA6IHRydWUsXFxuICAgICAgICBwYXJlbnQ6IHAsXFxuICAgICAgICBwYXJlbnRzOiBwcyxcXG4gICAgICAgIGNoaWxkcmVuOiBkLmNoaWxkcmVuIHx8IFtdLFxcbiAgICAgICAgY2hpbGRyZW5fZDogZC5jaGlsZHJlbl9kIHx8IFtdLFxcbiAgICAgICAgZGF0YTogZC5kYXRhLFxcbiAgICAgICAgc3RhdGU6IHt9LFxcbiAgICAgICAgbGlfYXR0cjoge1xcbiAgICAgICAgICBpZDogZmFsc2VcXG4gICAgICAgIH0sXFxuICAgICAgICBhX2F0dHI6IHtcXG4gICAgICAgICAgaHJlZjogJyMnXFxuICAgICAgICB9LFxcbiAgICAgICAgb3JpZ2luYWw6IGZhbHNlXFxuICAgICAgfTtcXG5cXG4gICAgICBmb3IgKGkgaW4gZGYpIHtcXG4gICAgICAgIGlmIChkZi5oYXNPd25Qcm9wZXJ0eShpKSkge1xcbiAgICAgICAgICB0bXAuc3RhdGVbaV0gPSBkZltpXTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGQgJiYgZC5kYXRhICYmIGQuZGF0YS5qc3RyZWUgJiYgZC5kYXRhLmpzdHJlZS5pY29uKSB7XFxuICAgICAgICB0bXAuaWNvbiA9IGQuZGF0YS5qc3RyZWUuaWNvbjtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRtcC5pY29uID09PSB1bmRlZmluZWQgfHwgdG1wLmljb24gPT09IG51bGwgfHwgdG1wLmljb24gPT09IFxcXCJcXFwiKSB7XFxuICAgICAgICB0bXAuaWNvbiA9IHRydWU7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChkICYmIGQuZGF0YSkge1xcbiAgICAgICAgdG1wLmRhdGEgPSBkLmRhdGE7XFxuXFxuICAgICAgICBpZiAoZC5kYXRhLmpzdHJlZSkge1xcbiAgICAgICAgICBmb3IgKGkgaW4gZC5kYXRhLmpzdHJlZSkge1xcbiAgICAgICAgICAgIGlmIChkLmRhdGEuanN0cmVlLmhhc093blByb3BlcnR5KGkpKSB7XFxuICAgICAgICAgICAgICB0bXAuc3RhdGVbaV0gPSBkLmRhdGEuanN0cmVlW2ldO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoZCAmJiBfdHlwZW9mKGQuc3RhdGUpID09PSAnb2JqZWN0Jykge1xcbiAgICAgICAgZm9yIChpIGluIGQuc3RhdGUpIHtcXG4gICAgICAgICAgaWYgKGQuc3RhdGUuaGFzT3duUHJvcGVydHkoaSkpIHtcXG4gICAgICAgICAgICB0bXAuc3RhdGVbaV0gPSBkLnN0YXRlW2ldO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChkICYmIF90eXBlb2YoZC5saV9hdHRyKSA9PT0gJ29iamVjdCcpIHtcXG4gICAgICAgIGZvciAoaSBpbiBkLmxpX2F0dHIpIHtcXG4gICAgICAgICAgaWYgKGQubGlfYXR0ci5oYXNPd25Qcm9wZXJ0eShpKSkge1xcbiAgICAgICAgICAgIHRtcC5saV9hdHRyW2ldID0gZC5saV9hdHRyW2ldO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghdG1wLmxpX2F0dHIuaWQpIHtcXG4gICAgICAgIHRtcC5saV9hdHRyLmlkID0gdGlkO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoZCAmJiBfdHlwZW9mKGQuYV9hdHRyKSA9PT0gJ29iamVjdCcpIHtcXG4gICAgICAgIGZvciAoaSBpbiBkLmFfYXR0cikge1xcbiAgICAgICAgICBpZiAoZC5hX2F0dHIuaGFzT3duUHJvcGVydHkoaSkpIHtcXG4gICAgICAgICAgICB0bXAuYV9hdHRyW2ldID0gZC5hX2F0dHJbaV07XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGQgJiYgZC5jaGlsZHJlbiAmJiBkLmNoaWxkcmVuID09PSB0cnVlKSB7XFxuICAgICAgICB0bXAuc3RhdGUubG9hZGVkID0gZmFsc2U7XFxuICAgICAgICB0bXAuY2hpbGRyZW4gPSBbXTtcXG4gICAgICAgIHRtcC5jaGlsZHJlbl9kID0gW107XFxuICAgICAgfVxcblxcbiAgICAgIG1bdG1wLmlkXSA9IHRtcDtcXG5cXG4gICAgICBmb3IgKGkgPSAwLCBqID0gdG1wLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcbiAgICAgICAgYyA9IHRoaXMuX3BhcnNlX21vZGVsX2Zyb21fZmxhdF9qc29uKG1bdG1wLmNoaWxkcmVuW2ldXSwgdG1wLmlkLCBwcyk7XFxuICAgICAgICBlID0gbVtjXTtcXG4gICAgICAgIHRtcC5jaGlsZHJlbl9kLnB1c2goYyk7XFxuXFxuICAgICAgICBpZiAoZS5jaGlsZHJlbl9kLmxlbmd0aCkge1xcbiAgICAgICAgICB0bXAuY2hpbGRyZW5fZCA9IHRtcC5jaGlsZHJlbl9kLmNvbmNhdChlLmNoaWxkcmVuX2QpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBkZWxldGUgZC5kYXRhO1xcbiAgICAgIGRlbGV0ZSBkLmNoaWxkcmVuO1xcbiAgICAgIG1bdG1wLmlkXS5vcmlnaW5hbCA9IGQ7XFxuXFxuICAgICAgaWYgKHRtcC5zdGF0ZS5zZWxlY3RlZCkge1xcbiAgICAgICAgdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLnB1c2godG1wLmlkKTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHRtcC5pZDtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIHBhcnNlcyBhIG5vZGUgZnJvbSBhIEpTT04gb2JqZWN0IGFuZCBhcHBlbmRzIGl0IHRvIHRoZSBpbiBtZW1vcnkgdHJlZSBtb2RlbC4gVXNlZCBpbnRlcm5hbGx5LlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAbmFtZSBfcGFyc2VfbW9kZWxfZnJvbV9qc29uKGQgWywgcCwgcHNdKVxcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGQgdGhlIEpTT04gb2JqZWN0IHRvIHBhcnNlXFxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gcCB0aGUgcGFyZW50IElEXFxuICAgICAqIEBwYXJhbSAge0FycmF5fSBwcyBsaXN0IG9mIGFsbCBwYXJlbnRzXFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gdGhlIElEIG9mIHRoZSBvYmplY3QgYWRkZWQgdG8gdGhlIG1vZGVsXFxuICAgICAqL1xcbiAgICBfcGFyc2VfbW9kZWxfZnJvbV9qc29uOiBmdW5jdGlvbiBfcGFyc2VfbW9kZWxfZnJvbV9qc29uKGQsIHAsIHBzKSB7XFxuICAgICAgaWYgKCFwcykge1xcbiAgICAgICAgcHMgPSBbXTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgcHMgPSBwcy5jb25jYXQoKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHApIHtcXG4gICAgICAgIHBzLnVuc2hpZnQocCk7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciB0aWQgPSBmYWxzZSxcXG4gICAgICAgICAgaSxcXG4gICAgICAgICAgaixcXG4gICAgICAgICAgYyxcXG4gICAgICAgICAgZSxcXG4gICAgICAgICAgbSA9IHRoaXMuX21vZGVsLmRhdGEsXFxuICAgICAgICAgIGRmID0gdGhpcy5fbW9kZWwuZGVmYXVsdF9zdGF0ZSxcXG4gICAgICAgICAgdG1wO1xcblxcbiAgICAgIGRvIHtcXG4gICAgICAgIHRpZCA9ICdqJyArIHRoaXMuX2lkICsgJ18nICsgKyt0aGlzLl9jbnQ7XFxuICAgICAgfSB3aGlsZSAobVt0aWRdKTtcXG5cXG4gICAgICB0bXAgPSB7XFxuICAgICAgICBpZDogZmFsc2UsXFxuICAgICAgICB0ZXh0OiB0eXBlb2YgZCA9PT0gJ3N0cmluZycgPyBkIDogJycsXFxuICAgICAgICBpY29uOiBfdHlwZW9mKGQpID09PSAnb2JqZWN0JyAmJiBkLmljb24gIT09IHVuZGVmaW5lZCA/IGQuaWNvbiA6IHRydWUsXFxuICAgICAgICBwYXJlbnQ6IHAsXFxuICAgICAgICBwYXJlbnRzOiBwcyxcXG4gICAgICAgIGNoaWxkcmVuOiBbXSxcXG4gICAgICAgIGNoaWxkcmVuX2Q6IFtdLFxcbiAgICAgICAgZGF0YTogbnVsbCxcXG4gICAgICAgIHN0YXRlOiB7fSxcXG4gICAgICAgIGxpX2F0dHI6IHtcXG4gICAgICAgICAgaWQ6IGZhbHNlXFxuICAgICAgICB9LFxcbiAgICAgICAgYV9hdHRyOiB7XFxuICAgICAgICAgIGhyZWY6ICcjJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIG9yaWdpbmFsOiBmYWxzZVxcbiAgICAgIH07XFxuXFxuICAgICAgZm9yIChpIGluIGRmKSB7XFxuICAgICAgICBpZiAoZGYuaGFzT3duUHJvcGVydHkoaSkpIHtcXG4gICAgICAgICAgdG1wLnN0YXRlW2ldID0gZGZbaV07XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChkICYmIGQuaWQpIHtcXG4gICAgICAgIHRtcC5pZCA9IGQuaWQudG9TdHJpbmcoKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGQgJiYgZC50ZXh0KSB7XFxuICAgICAgICB0bXAudGV4dCA9IGQudGV4dDtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGQgJiYgZC5kYXRhICYmIGQuZGF0YS5qc3RyZWUgJiYgZC5kYXRhLmpzdHJlZS5pY29uKSB7XFxuICAgICAgICB0bXAuaWNvbiA9IGQuZGF0YS5qc3RyZWUuaWNvbjtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRtcC5pY29uID09PSB1bmRlZmluZWQgfHwgdG1wLmljb24gPT09IG51bGwgfHwgdG1wLmljb24gPT09IFxcXCJcXFwiKSB7XFxuICAgICAgICB0bXAuaWNvbiA9IHRydWU7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChkICYmIGQuZGF0YSkge1xcbiAgICAgICAgdG1wLmRhdGEgPSBkLmRhdGE7XFxuXFxuICAgICAgICBpZiAoZC5kYXRhLmpzdHJlZSkge1xcbiAgICAgICAgICBmb3IgKGkgaW4gZC5kYXRhLmpzdHJlZSkge1xcbiAgICAgICAgICAgIGlmIChkLmRhdGEuanN0cmVlLmhhc093blByb3BlcnR5KGkpKSB7XFxuICAgICAgICAgICAgICB0bXAuc3RhdGVbaV0gPSBkLmRhdGEuanN0cmVlW2ldO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoZCAmJiBfdHlwZW9mKGQuc3RhdGUpID09PSAnb2JqZWN0Jykge1xcbiAgICAgICAgZm9yIChpIGluIGQuc3RhdGUpIHtcXG4gICAgICAgICAgaWYgKGQuc3RhdGUuaGFzT3duUHJvcGVydHkoaSkpIHtcXG4gICAgICAgICAgICB0bXAuc3RhdGVbaV0gPSBkLnN0YXRlW2ldO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChkICYmIF90eXBlb2YoZC5saV9hdHRyKSA9PT0gJ29iamVjdCcpIHtcXG4gICAgICAgIGZvciAoaSBpbiBkLmxpX2F0dHIpIHtcXG4gICAgICAgICAgaWYgKGQubGlfYXR0ci5oYXNPd25Qcm9wZXJ0eShpKSkge1xcbiAgICAgICAgICAgIHRtcC5saV9hdHRyW2ldID0gZC5saV9hdHRyW2ldO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0bXAubGlfYXR0ci5pZCAmJiAhdG1wLmlkKSB7XFxuICAgICAgICB0bXAuaWQgPSB0bXAubGlfYXR0ci5pZC50b1N0cmluZygpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIXRtcC5pZCkge1xcbiAgICAgICAgdG1wLmlkID0gdGlkO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIXRtcC5saV9hdHRyLmlkKSB7XFxuICAgICAgICB0bXAubGlfYXR0ci5pZCA9IHRtcC5pZDtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGQgJiYgX3R5cGVvZihkLmFfYXR0cikgPT09ICdvYmplY3QnKSB7XFxuICAgICAgICBmb3IgKGkgaW4gZC5hX2F0dHIpIHtcXG4gICAgICAgICAgaWYgKGQuYV9hdHRyLmhhc093blByb3BlcnR5KGkpKSB7XFxuICAgICAgICAgICAgdG1wLmFfYXR0cltpXSA9IGQuYV9hdHRyW2ldO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChkICYmIGQuY2hpbGRyZW4gJiYgZC5jaGlsZHJlbi5sZW5ndGgpIHtcXG4gICAgICAgIGZvciAoaSA9IDAsIGogPSBkLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcbiAgICAgICAgICBjID0gdGhpcy5fcGFyc2VfbW9kZWxfZnJvbV9qc29uKGQuY2hpbGRyZW5baV0sIHRtcC5pZCwgcHMpO1xcbiAgICAgICAgICBlID0gbVtjXTtcXG4gICAgICAgICAgdG1wLmNoaWxkcmVuLnB1c2goYyk7XFxuXFxuICAgICAgICAgIGlmIChlLmNoaWxkcmVuX2QubGVuZ3RoKSB7XFxuICAgICAgICAgICAgdG1wLmNoaWxkcmVuX2QgPSB0bXAuY2hpbGRyZW5fZC5jb25jYXQoZS5jaGlsZHJlbl9kKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgdG1wLmNoaWxkcmVuX2QgPSB0bXAuY2hpbGRyZW5fZC5jb25jYXQodG1wLmNoaWxkcmVuKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGQgJiYgZC5jaGlsZHJlbiAmJiBkLmNoaWxkcmVuID09PSB0cnVlKSB7XFxuICAgICAgICB0bXAuc3RhdGUubG9hZGVkID0gZmFsc2U7XFxuICAgICAgICB0bXAuY2hpbGRyZW4gPSBbXTtcXG4gICAgICAgIHRtcC5jaGlsZHJlbl9kID0gW107XFxuICAgICAgfVxcblxcbiAgICAgIGRlbGV0ZSBkLmRhdGE7XFxuICAgICAgZGVsZXRlIGQuY2hpbGRyZW47XFxuICAgICAgdG1wLm9yaWdpbmFsID0gZDtcXG4gICAgICBtW3RtcC5pZF0gPSB0bXA7XFxuXFxuICAgICAgaWYgKHRtcC5zdGF0ZS5zZWxlY3RlZCkge1xcbiAgICAgICAgdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLnB1c2godG1wLmlkKTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHRtcC5pZDtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIHJlZHJhd3MgYWxsIG5vZGVzIHRoYXQgbmVlZCB0byBiZSByZWRyYXduLiBVc2VkIGludGVybmFsbHkuXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBuYW1lIF9yZWRyYXcoKVxcbiAgICAgKiBAdHJpZ2dlciByZWRyYXcuanN0cmVlXFxuICAgICAqL1xcbiAgICBfcmVkcmF3OiBmdW5jdGlvbiBfcmVkcmF3KCkge1xcbiAgICAgIHZhciBub2RlcyA9IHRoaXMuX21vZGVsLmZvcmNlX2Z1bGxfcmVkcmF3ID8gdGhpcy5fbW9kZWwuZGF0YVskLmpzdHJlZS5yb290XS5jaGlsZHJlbi5jb25jYXQoW10pIDogdGhpcy5fbW9kZWwuY2hhbmdlZC5jb25jYXQoW10pLFxcbiAgICAgICAgICBmID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnVUwnKSxcXG4gICAgICAgICAgdG1wLFxcbiAgICAgICAgICBpLFxcbiAgICAgICAgICBqLFxcbiAgICAgICAgICBmZSA9IHRoaXMuX2RhdGEuY29yZS5mb2N1c2VkO1xcblxcbiAgICAgIGZvciAoaSA9IDAsIGogPSBub2Rlcy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG4gICAgICAgIHRtcCA9IHRoaXMucmVkcmF3X25vZGUobm9kZXNbaV0sIHRydWUsIHRoaXMuX21vZGVsLmZvcmNlX2Z1bGxfcmVkcmF3KTtcXG5cXG4gICAgICAgIGlmICh0bXAgJiYgdGhpcy5fbW9kZWwuZm9yY2VfZnVsbF9yZWRyYXcpIHtcXG4gICAgICAgICAgZi5hcHBlbmRDaGlsZCh0bXApO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5fbW9kZWwuZm9yY2VfZnVsbF9yZWRyYXcpIHtcXG4gICAgICAgIGYuY2xhc3NOYW1lID0gdGhpcy5nZXRfY29udGFpbmVyX3VsKClbMF0uY2xhc3NOYW1lO1xcbiAgICAgICAgZi5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnZ3JvdXAnKTtcXG4gICAgICAgIHRoaXMuZWxlbWVudC5lbXB0eSgpLmFwcGVuZChmKTsgLy90aGlzLmdldF9jb250YWluZXJfdWwoKVswXS5hcHBlbmRDaGlsZChmKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGZlICE9PSBudWxsKSB7XFxuICAgICAgICB0bXAgPSB0aGlzLmdldF9ub2RlKGZlLCB0cnVlKTtcXG5cXG4gICAgICAgIGlmICh0bXAgJiYgdG1wLmxlbmd0aCAmJiB0bXAuY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJylbMF0gIT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIHtcXG4gICAgICAgICAgdG1wLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLmZvY3VzKCk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICB0aGlzLl9kYXRhLmNvcmUuZm9jdXNlZCA9IG51bGw7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX21vZGVsLmZvcmNlX2Z1bGxfcmVkcmF3ID0gZmFsc2U7XFxuICAgICAgdGhpcy5fbW9kZWwuY2hhbmdlZCA9IFtdO1xcbiAgICAgIC8qKlxcbiAgICAgICAqIHRyaWdnZXJlZCBhZnRlciBub2RlcyBhcmUgcmVkcmF3blxcbiAgICAgICAqIEBldmVudFxcbiAgICAgICAqIEBuYW1lIHJlZHJhdy5qc3RyZWVcXG4gICAgICAgKiBAcGFyYW0ge2FycmF5fSBub2RlcyB0aGUgcmVkcmF3biBub2Rlc1xcbiAgICAgICAqL1xcblxcbiAgICAgIHRoaXMudHJpZ2dlcigncmVkcmF3Jywge1xcbiAgICAgICAgXFxcIm5vZGVzXFxcIjogbm9kZXNcXG4gICAgICB9KTtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIHJlZHJhd3MgYWxsIG5vZGVzIHRoYXQgbmVlZCB0byBiZSByZWRyYXduIG9yIG9wdGlvbmFsbHkgLSB0aGUgd2hvbGUgdHJlZVxcbiAgICAgKiBAbmFtZSByZWRyYXcoW2Z1bGxdKVxcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZ1bGwgaWYgc2V0IHRvIGB0cnVlYCBhbGwgbm9kZXMgYXJlIHJlZHJhd24uXFxuICAgICAqL1xcbiAgICByZWRyYXc6IGZ1bmN0aW9uIHJlZHJhdyhmdWxsKSB7XFxuICAgICAgaWYgKGZ1bGwpIHtcXG4gICAgICAgIHRoaXMuX21vZGVsLmZvcmNlX2Z1bGxfcmVkcmF3ID0gdHJ1ZTtcXG4gICAgICB9IC8vaWYodGhpcy5fbW9kZWwucmVkcmF3X3RpbWVvdXQpIHtcXG4gICAgICAvL1xcdGNsZWFyVGltZW91dCh0aGlzLl9tb2RlbC5yZWRyYXdfdGltZW91dCk7XFxuICAgICAgLy99XFxuICAgICAgLy90aGlzLl9tb2RlbC5yZWRyYXdfdGltZW91dCA9IHNldFRpbWVvdXQoJC5wcm94eSh0aGlzLl9yZWRyYXcsIHRoaXMpLDApO1xcblxcblxcbiAgICAgIHRoaXMuX3JlZHJhdygpO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogcmVkcmF3cyBhIHNpbmdsZSBub2RlJ3MgY2hpbGRyZW4uIFVzZWQgaW50ZXJuYWxseS5cXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQG5hbWUgZHJhd19jaGlsZHJlbihub2RlKVxcbiAgICAgKiBAcGFyYW0ge21peGVkfSBub2RlIHRoZSBub2RlIHdob3NlIGNoaWxkcmVuIHdpbGwgYmUgcmVkcmF3blxcbiAgICAgKi9cXG4gICAgZHJhd19jaGlsZHJlbjogZnVuY3Rpb24gZHJhd19jaGlsZHJlbihub2RlKSB7XFxuICAgICAgdmFyIG9iaiA9IHRoaXMuZ2V0X25vZGUobm9kZSksXFxuICAgICAgICAgIGkgPSBmYWxzZSxcXG4gICAgICAgICAgaiA9IGZhbHNlLFxcbiAgICAgICAgICBrID0gZmFsc2UsXFxuICAgICAgICAgIGQgPSBkb2N1bWVudDtcXG5cXG4gICAgICBpZiAoIW9iaikge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAob2JqLmlkID09PSAkLmpzdHJlZS5yb290KSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5yZWRyYXcodHJ1ZSk7XFxuICAgICAgfVxcblxcbiAgICAgIG5vZGUgPSB0aGlzLmdldF9ub2RlKG5vZGUsIHRydWUpO1xcblxcbiAgICAgIGlmICghbm9kZSB8fCAhbm9kZS5sZW5ndGgpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9IC8vIFRPRE86IHF1aWNrIHRvZ2dsZVxcblxcblxcbiAgICAgIG5vZGUuY2hpbGRyZW4oJy5qc3RyZWUtY2hpbGRyZW4nKS5yZW1vdmUoKTtcXG4gICAgICBub2RlID0gbm9kZVswXTtcXG5cXG4gICAgICBpZiAob2JqLmNoaWxkcmVuLmxlbmd0aCAmJiBvYmouc3RhdGUubG9hZGVkKSB7XFxuICAgICAgICBrID0gZC5jcmVhdGVFbGVtZW50KCdVTCcpO1xcbiAgICAgICAgay5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnZ3JvdXAnKTtcXG4gICAgICAgIGsuY2xhc3NOYW1lID0gJ2pzdHJlZS1jaGlsZHJlbic7XFxuXFxuICAgICAgICBmb3IgKGkgPSAwLCBqID0gb2JqLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcbiAgICAgICAgICBrLmFwcGVuZENoaWxkKHRoaXMucmVkcmF3X25vZGUob2JqLmNoaWxkcmVuW2ldLCB0cnVlLCB0cnVlKSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBub2RlLmFwcGVuZENoaWxkKGspO1xcbiAgICAgIH1cXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIHJlZHJhd3MgYSBzaW5nbGUgbm9kZS4gVXNlZCBpbnRlcm5hbGx5LlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAbmFtZSByZWRyYXdfbm9kZShub2RlLCBkZWVwLCBpc19jYWxsYmFjaywgZm9yY2VfcmVuZGVyKVxcbiAgICAgKiBAcGFyYW0ge21peGVkfSBub2RlIHRoZSBub2RlIHRvIHJlZHJhd1xcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRlZXAgc2hvdWxkIGNoaWxkIG5vZGVzIGJlIHJlZHJhd24gdG9vXFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNfY2FsbGJhY2sgaXMgdGhpcyBhIHJlY3Vyc2lvbiBjYWxsXFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZm9yY2VfcmVuZGVyIHNob3VsZCBjaGlsZHJlbiBvZiBjbG9zZWQgcGFyZW50cyBiZSBkcmF3biBhbnl3YXlcXG4gICAgICovXFxuICAgIHJlZHJhd19ub2RlOiBmdW5jdGlvbiByZWRyYXdfbm9kZShub2RlLCBkZWVwLCBpc19jYWxsYmFjaywgZm9yY2VfcmVuZGVyKSB7XFxuICAgICAgdmFyIG9iaiA9IHRoaXMuZ2V0X25vZGUobm9kZSksXFxuICAgICAgICAgIHBhciA9IGZhbHNlLFxcbiAgICAgICAgICBpbmQgPSBmYWxzZSxcXG4gICAgICAgICAgb2xkID0gZmFsc2UsXFxuICAgICAgICAgIGkgPSBmYWxzZSxcXG4gICAgICAgICAgaiA9IGZhbHNlLFxcbiAgICAgICAgICBrID0gZmFsc2UsXFxuICAgICAgICAgIGMgPSAnJyxcXG4gICAgICAgICAgZCA9IGRvY3VtZW50LFxcbiAgICAgICAgICBtID0gdGhpcy5fbW9kZWwuZGF0YSxcXG4gICAgICAgICAgZiA9IGZhbHNlLFxcbiAgICAgICAgICBzID0gZmFsc2UsXFxuICAgICAgICAgIHRtcCA9IG51bGwsXFxuICAgICAgICAgIHQgPSAwLFxcbiAgICAgICAgICBsID0gMCxcXG4gICAgICAgICAgaGFzX2NoaWxkcmVuID0gZmFsc2UsXFxuICAgICAgICAgIGxhc3Rfc2libGluZyA9IGZhbHNlO1xcblxcbiAgICAgIGlmICghb2JqKSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLnJlZHJhdyh0cnVlKTtcXG4gICAgICB9XFxuXFxuICAgICAgZGVlcCA9IGRlZXAgfHwgb2JqLmNoaWxkcmVuLmxlbmd0aCA9PT0gMDtcXG4gICAgICBub2RlID0gIWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IgPyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChvYmouaWQpIDogdGhpcy5lbGVtZW50WzBdLnF1ZXJ5U2VsZWN0b3IoJyMnICsgKFxcXCIwMTIzNDU2Nzg5XFxcIi5pbmRleE9mKG9iai5pZFswXSkgIT09IC0xID8gJ1xcXFxcXFxcMycgKyBvYmouaWRbMF0gKyAnICcgKyBvYmouaWQuc3Vic3RyKDEpLnJlcGxhY2UoJC5qc3RyZWUuaWRyZWdleCwgJ1xcXFxcXFxcJCYnKSA6IG9iai5pZC5yZXBsYWNlKCQuanN0cmVlLmlkcmVnZXgsICdcXFxcXFxcXCQmJykpKTsgLy8sIHRoaXMuZWxlbWVudCk7XFxuXFxuICAgICAgaWYgKCFub2RlKSB7XFxuICAgICAgICBkZWVwID0gdHJ1ZTsgLy9ub2RlID0gZC5jcmVhdGVFbGVtZW50KCdMSScpO1xcblxcbiAgICAgICAgaWYgKCFpc19jYWxsYmFjaykge1xcbiAgICAgICAgICBwYXIgPSBvYmoucGFyZW50ICE9PSAkLmpzdHJlZS5yb290ID8gJCgnIycgKyBvYmoucGFyZW50LnJlcGxhY2UoJC5qc3RyZWUuaWRyZWdleCwgJ1xcXFxcXFxcJCYnKSwgdGhpcy5lbGVtZW50KVswXSA6IG51bGw7XFxuXFxuICAgICAgICAgIGlmIChwYXIgIT09IG51bGwgJiYgKCFwYXIgfHwgIW1bb2JqLnBhcmVudF0uc3RhdGUub3BlbmVkKSkge1xcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpbmQgPSAkLmluQXJyYXkob2JqLmlkLCBwYXIgPT09IG51bGwgPyBtWyQuanN0cmVlLnJvb3RdLmNoaWxkcmVuIDogbVtvYmoucGFyZW50XS5jaGlsZHJlbik7XFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIG5vZGUgPSAkKG5vZGUpO1xcblxcbiAgICAgICAgaWYgKCFpc19jYWxsYmFjaykge1xcbiAgICAgICAgICBwYXIgPSBub2RlLnBhcmVudCgpLnBhcmVudCgpWzBdO1xcblxcbiAgICAgICAgICBpZiAocGFyID09PSB0aGlzLmVsZW1lbnRbMF0pIHtcXG4gICAgICAgICAgICBwYXIgPSBudWxsO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGluZCA9IG5vZGUuaW5kZXgoKTtcXG4gICAgICAgIH0gLy8gbVtvYmouaWRdLmRhdGEgPSBub2RlLmRhdGEoKTsgLy8gdXNlIG9ubHkgbm9kZSdzIGRhdGEsIG5vIG5lZWQgdG8gdG91Y2gganF1ZXJ5IHN0b3JhZ2VcXG5cXG5cXG4gICAgICAgIGlmICghZGVlcCAmJiBvYmouY2hpbGRyZW4ubGVuZ3RoICYmICFub2RlLmNoaWxkcmVuKCcuanN0cmVlLWNoaWxkcmVuJykubGVuZ3RoKSB7XFxuICAgICAgICAgIGRlZXAgPSB0cnVlO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKCFkZWVwKSB7XFxuICAgICAgICAgIG9sZCA9IG5vZGUuY2hpbGRyZW4oJy5qc3RyZWUtY2hpbGRyZW4nKVswXTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGYgPSBub2RlLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpWzBdID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xcbiAgICAgICAgbm9kZS5yZW1vdmUoKTsgLy9ub2RlID0gZC5jcmVhdGVFbGVtZW50KCdMSScpO1xcbiAgICAgICAgLy9ub2RlID0gbm9kZVswXTtcXG4gICAgICB9XFxuXFxuICAgICAgbm9kZSA9IHRoaXMuX2RhdGEuY29yZS5ub2RlLmNsb25lTm9kZSh0cnVlKTsgLy8gbm9kZSBpcyBET00sIGRlZXAgaXMgYm9vbGVhblxcblxcbiAgICAgIGMgPSAnanN0cmVlLW5vZGUgJztcXG5cXG4gICAgICBmb3IgKGkgaW4gb2JqLmxpX2F0dHIpIHtcXG4gICAgICAgIGlmIChvYmoubGlfYXR0ci5oYXNPd25Qcm9wZXJ0eShpKSkge1xcbiAgICAgICAgICBpZiAoaSA9PT0gJ2lkJykge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmIChpICE9PSAnY2xhc3MnKSB7XFxuICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoaSwgb2JqLmxpX2F0dHJbaV0pO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGMgKz0gb2JqLmxpX2F0dHJbaV07XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCFvYmouYV9hdHRyLmlkKSB7XFxuICAgICAgICBvYmouYV9hdHRyLmlkID0gb2JqLmlkICsgJ19hbmNob3InO1xcbiAgICAgIH1cXG5cXG4gICAgICBub2RlLnNldEF0dHJpYnV0ZSgnYXJpYS1zZWxlY3RlZCcsICEhb2JqLnN0YXRlLnNlbGVjdGVkKTtcXG4gICAgICBub2RlLnNldEF0dHJpYnV0ZSgnYXJpYS1sZXZlbCcsIG9iai5wYXJlbnRzLmxlbmd0aCk7XFxuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWxsZWRieScsIG9iai5hX2F0dHIuaWQpO1xcblxcbiAgICAgIGlmIChvYmouc3RhdGUuZGlzYWJsZWQpIHtcXG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCdhcmlhLWRpc2FibGVkJywgdHJ1ZSk7XFxuICAgICAgfVxcblxcbiAgICAgIGZvciAoaSA9IDAsIGogPSBvYmouY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICBpZiAoIW1bb2JqLmNoaWxkcmVuW2ldXS5zdGF0ZS5oaWRkZW4pIHtcXG4gICAgICAgICAgaGFzX2NoaWxkcmVuID0gdHJ1ZTtcXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChvYmoucGFyZW50ICE9PSBudWxsICYmIG1bb2JqLnBhcmVudF0gJiYgIW9iai5zdGF0ZS5oaWRkZW4pIHtcXG4gICAgICAgIGkgPSAkLmluQXJyYXkob2JqLmlkLCBtW29iai5wYXJlbnRdLmNoaWxkcmVuKTtcXG4gICAgICAgIGxhc3Rfc2libGluZyA9IG9iai5pZDtcXG5cXG4gICAgICAgIGlmIChpICE9PSAtMSkge1xcbiAgICAgICAgICBpKys7XFxuXFxuICAgICAgICAgIGZvciAoaiA9IG1bb2JqLnBhcmVudF0uY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICAgICAgaWYgKCFtW21bb2JqLnBhcmVudF0uY2hpbGRyZW5baV1dLnN0YXRlLmhpZGRlbikge1xcbiAgICAgICAgICAgICAgbGFzdF9zaWJsaW5nID0gbVtvYmoucGFyZW50XS5jaGlsZHJlbltpXTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaWYgKGxhc3Rfc2libGluZyAhPT0gb2JqLmlkKSB7XFxuICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgaWYgKG9iai5zdGF0ZS5oaWRkZW4pIHtcXG4gICAgICAgIGMgKz0gJyBqc3RyZWUtaGlkZGVuJztcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKG9iai5zdGF0ZS5sb2FkZWQgJiYgIWhhc19jaGlsZHJlbikge1xcbiAgICAgICAgYyArPSAnIGpzdHJlZS1sZWFmJztcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgYyArPSBvYmouc3RhdGUub3BlbmVkICYmIG9iai5zdGF0ZS5sb2FkZWQgPyAnIGpzdHJlZS1vcGVuJyA6ICcganN0cmVlLWNsb3NlZCc7XFxuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsIG9iai5zdGF0ZS5vcGVuZWQgJiYgb2JqLnN0YXRlLmxvYWRlZCk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChsYXN0X3NpYmxpbmcgPT09IG9iai5pZCkge1xcbiAgICAgICAgYyArPSAnIGpzdHJlZS1sYXN0JztcXG4gICAgICB9XFxuXFxuICAgICAgbm9kZS5pZCA9IG9iai5pZDtcXG4gICAgICBub2RlLmNsYXNzTmFtZSA9IGM7XFxuICAgICAgYyA9IChvYmouc3RhdGUuc2VsZWN0ZWQgPyAnIGpzdHJlZS1jbGlja2VkJyA6ICcnKSArIChvYmouc3RhdGUuZGlzYWJsZWQgPyAnIGpzdHJlZS1kaXNhYmxlZCcgOiAnJyk7XFxuXFxuICAgICAgZm9yIChqIGluIG9iai5hX2F0dHIpIHtcXG4gICAgICAgIGlmIChvYmouYV9hdHRyLmhhc093blByb3BlcnR5KGopKSB7XFxuICAgICAgICAgIGlmIChqID09PSAnaHJlZicgJiYgb2JqLmFfYXR0cltqXSA9PT0gJyMnKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaWYgKGogIT09ICdjbGFzcycpIHtcXG4gICAgICAgICAgICBub2RlLmNoaWxkTm9kZXNbMV0uc2V0QXR0cmlidXRlKGosIG9iai5hX2F0dHJbal0pO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGMgKz0gJyAnICsgb2JqLmFfYXR0cltqXTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoYy5sZW5ndGgpIHtcXG4gICAgICAgIG5vZGUuY2hpbGROb2Rlc1sxXS5jbGFzc05hbWUgPSAnanN0cmVlLWFuY2hvciAnICsgYztcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKG9iai5pY29uICYmIG9iai5pY29uICE9PSB0cnVlIHx8IG9iai5pY29uID09PSBmYWxzZSkge1xcbiAgICAgICAgaWYgKG9iai5pY29uID09PSBmYWxzZSkge1xcbiAgICAgICAgICBub2RlLmNoaWxkTm9kZXNbMV0uY2hpbGROb2Rlc1swXS5jbGFzc05hbWUgKz0gJyBqc3RyZWUtdGhlbWVpY29uLWhpZGRlbic7XFxuICAgICAgICB9IGVsc2UgaWYgKG9iai5pY29uLmluZGV4T2YoJy8nKSA9PT0gLTEgJiYgb2JqLmljb24uaW5kZXhPZignLicpID09PSAtMSkge1xcbiAgICAgICAgICBub2RlLmNoaWxkTm9kZXNbMV0uY2hpbGROb2Rlc1swXS5jbGFzc05hbWUgKz0gJyAnICsgb2JqLmljb24gKyAnIGpzdHJlZS10aGVtZWljb24tY3VzdG9tJztcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIG5vZGUuY2hpbGROb2Rlc1sxXS5jaGlsZE5vZGVzWzBdLnN0eWxlLmJhY2tncm91bmRJbWFnZSA9ICd1cmwoXFxcIicgKyBvYmouaWNvbiArICdcXFwiKSc7XFxuICAgICAgICAgIG5vZGUuY2hpbGROb2Rlc1sxXS5jaGlsZE5vZGVzWzBdLnN0eWxlLmJhY2tncm91bmRQb3NpdGlvbiA9ICdjZW50ZXIgY2VudGVyJztcXG4gICAgICAgICAgbm9kZS5jaGlsZE5vZGVzWzFdLmNoaWxkTm9kZXNbMF0uc3R5bGUuYmFja2dyb3VuZFNpemUgPSAnYXV0byc7XFxuICAgICAgICAgIG5vZGUuY2hpbGROb2Rlc1sxXS5jaGlsZE5vZGVzWzBdLmNsYXNzTmFtZSArPSAnIGpzdHJlZS10aGVtZWljb24tY3VzdG9tJztcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuY29yZS5mb3JjZV90ZXh0KSB7XFxuICAgICAgICBub2RlLmNoaWxkTm9kZXNbMV0uYXBwZW5kQ2hpbGQoZC5jcmVhdGVUZXh0Tm9kZShvYmoudGV4dCkpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBub2RlLmNoaWxkTm9kZXNbMV0uaW5uZXJIVE1MICs9IG9iai50ZXh0O1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoZGVlcCAmJiBvYmouY2hpbGRyZW4ubGVuZ3RoICYmIChvYmouc3RhdGUub3BlbmVkIHx8IGZvcmNlX3JlbmRlcikgJiYgb2JqLnN0YXRlLmxvYWRlZCkge1xcbiAgICAgICAgayA9IGQuY3JlYXRlRWxlbWVudCgnVUwnKTtcXG4gICAgICAgIGsuc2V0QXR0cmlidXRlKCdyb2xlJywgJ2dyb3VwJyk7XFxuICAgICAgICBrLmNsYXNzTmFtZSA9ICdqc3RyZWUtY2hpbGRyZW4nO1xcblxcbiAgICAgICAgZm9yIChpID0gMCwgaiA9IG9iai5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG4gICAgICAgICAgay5hcHBlbmRDaGlsZCh0aGlzLnJlZHJhd19ub2RlKG9iai5jaGlsZHJlbltpXSwgZGVlcCwgdHJ1ZSkpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgbm9kZS5hcHBlbmRDaGlsZChrKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKG9sZCkge1xcbiAgICAgICAgbm9kZS5hcHBlbmRDaGlsZChvbGQpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIWlzX2NhbGxiYWNrKSB7XFxuICAgICAgICAvLyBhcHBlbmQgYmFjayB1c2luZyBwYXIgLyBpbmRcXG4gICAgICAgIGlmICghcGFyKSB7XFxuICAgICAgICAgIHBhciA9IHRoaXMuZWxlbWVudFswXTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGZvciAoaSA9IDAsIGogPSBwYXIuY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG4gICAgICAgICAgaWYgKHBhci5jaGlsZE5vZGVzW2ldICYmIHBhci5jaGlsZE5vZGVzW2ldLmNsYXNzTmFtZSAmJiBwYXIuY2hpbGROb2Rlc1tpXS5jbGFzc05hbWUuaW5kZXhPZignanN0cmVlLWNoaWxkcmVuJykgIT09IC0xKSB7XFxuICAgICAgICAgICAgdG1wID0gcGFyLmNoaWxkTm9kZXNbaV07XFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICghdG1wKSB7XFxuICAgICAgICAgIHRtcCA9IGQuY3JlYXRlRWxlbWVudCgnVUwnKTtcXG4gICAgICAgICAgdG1wLnNldEF0dHJpYnV0ZSgncm9sZScsICdncm91cCcpO1xcbiAgICAgICAgICB0bXAuY2xhc3NOYW1lID0gJ2pzdHJlZS1jaGlsZHJlbic7XFxuICAgICAgICAgIHBhci5hcHBlbmRDaGlsZCh0bXApO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcGFyID0gdG1wO1xcblxcbiAgICAgICAgaWYgKGluZCA8IHBhci5jaGlsZE5vZGVzLmxlbmd0aCkge1xcbiAgICAgICAgICBwYXIuaW5zZXJ0QmVmb3JlKG5vZGUsIHBhci5jaGlsZE5vZGVzW2luZF0pO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgcGFyLmFwcGVuZENoaWxkKG5vZGUpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKGYpIHtcXG4gICAgICAgICAgdCA9IHRoaXMuZWxlbWVudFswXS5zY3JvbGxUb3A7XFxuICAgICAgICAgIGwgPSB0aGlzLmVsZW1lbnRbMF0uc2Nyb2xsTGVmdDtcXG4gICAgICAgICAgbm9kZS5jaGlsZE5vZGVzWzFdLmZvY3VzKCk7XFxuICAgICAgICAgIHRoaXMuZWxlbWVudFswXS5zY3JvbGxUb3AgPSB0O1xcbiAgICAgICAgICB0aGlzLmVsZW1lbnRbMF0uc2Nyb2xsTGVmdCA9IGw7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChvYmouc3RhdGUub3BlbmVkICYmICFvYmouc3RhdGUubG9hZGVkKSB7XFxuICAgICAgICBvYmouc3RhdGUub3BlbmVkID0gZmFsc2U7XFxuICAgICAgICBzZXRUaW1lb3V0KCQucHJveHkoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICB0aGlzLm9wZW5fbm9kZShvYmouaWQsIGZhbHNlLCAwKTtcXG4gICAgICAgIH0sIHRoaXMpLCAwKTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIG5vZGU7XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBvcGVucyBhIG5vZGUsIHJldmFsaW5nIGl0cyBjaGlsZHJlbi4gSWYgdGhlIG5vZGUgaXMgbm90IGxvYWRlZCBpdCB3aWxsIGJlIGxvYWRlZCBhbmQgb3BlbmVkIG9uY2UgcmVhZHkuXFxuICAgICAqIEBuYW1lIG9wZW5fbm9kZShvYmogWywgY2FsbGJhY2ssIGFuaW1hdGlvbl0pXFxuICAgICAqIEBwYXJhbSB7bWl4ZWR9IG9iaiB0aGUgbm9kZSB0byBvcGVuXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGEgZnVuY3Rpb24gdG8gZXhlY3V0ZSBvbmNlIHRoZSBub2RlIGlzIG9wZW5lZFxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYW5pbWF0aW9uIHRoZSBhbmltYXRpb24gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzIHdoZW4gb3BlbmluZyB0aGUgbm9kZSAob3ZlcnJpZGVzIHRoZSBgY29yZS5hbmltYXRpb25gIHNldHRpbmcpLiBVc2UgYGZhbHNlYCBmb3Igbm8gYW5pbWF0aW9uLlxcbiAgICAgKiBAdHJpZ2dlciBvcGVuX25vZGUuanN0cmVlLCBhZnRlcl9vcGVuLmpzdHJlZSwgYmVmb3JlX29wZW4uanN0cmVlXFxuICAgICAqL1xcbiAgICBvcGVuX25vZGU6IGZ1bmN0aW9uIG9wZW5fbm9kZShvYmosIGNhbGxiYWNrLCBhbmltYXRpb24pIHtcXG4gICAgICB2YXIgdDEsIHQyLCBkLCB0O1xcblxcbiAgICAgIGlmICgkLmlzQXJyYXkob2JqKSkge1xcbiAgICAgICAgb2JqID0gb2JqLnNsaWNlKCk7XFxuXFxuICAgICAgICBmb3IgKHQxID0gMCwgdDIgPSBvYmoubGVuZ3RoOyB0MSA8IHQyOyB0MSsrKSB7XFxuICAgICAgICAgIHRoaXMub3Blbl9ub2RlKG9ialt0MV0sIGNhbGxiYWNrLCBhbmltYXRpb24pO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgfVxcblxcbiAgICAgIG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXG4gICAgICBpZiAoIW9iaiB8fCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgYW5pbWF0aW9uID0gYW5pbWF0aW9uID09PSB1bmRlZmluZWQgPyB0aGlzLnNldHRpbmdzLmNvcmUuYW5pbWF0aW9uIDogYW5pbWF0aW9uO1xcblxcbiAgICAgIGlmICghdGhpcy5pc19jbG9zZWQob2JqKSkge1xcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XFxuICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgb2JqLCBmYWxzZSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghdGhpcy5pc19sb2FkZWQob2JqKSkge1xcbiAgICAgICAgaWYgKHRoaXMuaXNfbG9hZGluZyhvYmopKSB7XFxuICAgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KCQucHJveHkoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIHRoaXMub3Blbl9ub2RlKG9iaiwgY2FsbGJhY2ssIGFuaW1hdGlvbik7XFxuICAgICAgICAgIH0sIHRoaXMpLCA1MDApO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdGhpcy5sb2FkX25vZGUob2JqLCBmdW5jdGlvbiAobywgb2spIHtcXG4gICAgICAgICAgcmV0dXJuIG9rID8gdGhpcy5vcGVuX25vZGUobywgY2FsbGJhY2ssIGFuaW1hdGlvbikgOiBjYWxsYmFjayA/IGNhbGxiYWNrLmNhbGwodGhpcywgbywgZmFsc2UpIDogZmFsc2U7XFxuICAgICAgICB9KTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgZCA9IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKTtcXG4gICAgICAgIHQgPSB0aGlzO1xcblxcbiAgICAgICAgaWYgKGQubGVuZ3RoKSB7XFxuICAgICAgICAgIGlmIChhbmltYXRpb24gJiYgZC5jaGlsZHJlbihcXFwiLmpzdHJlZS1jaGlsZHJlblxcXCIpLmxlbmd0aCkge1xcbiAgICAgICAgICAgIGQuY2hpbGRyZW4oXFxcIi5qc3RyZWUtY2hpbGRyZW5cXFwiKS5zdG9wKHRydWUsIHRydWUpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmIChvYmouY2hpbGRyZW4ubGVuZ3RoICYmICF0aGlzLl9maXJzdENoaWxkKGQuY2hpbGRyZW4oJy5qc3RyZWUtY2hpbGRyZW4nKVswXSkpIHtcXG4gICAgICAgICAgICB0aGlzLmRyYXdfY2hpbGRyZW4ob2JqKTsgLy9kID0gdGhpcy5nZXRfbm9kZShvYmosIHRydWUpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmICghYW5pbWF0aW9uKSB7XFxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdiZWZvcmVfb3BlbicsIHtcXG4gICAgICAgICAgICAgIFxcXCJub2RlXFxcIjogb2JqXFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgZFswXS5jbGFzc05hbWUgPSBkWzBdLmNsYXNzTmFtZS5yZXBsYWNlKCdqc3RyZWUtY2xvc2VkJywgJ2pzdHJlZS1vcGVuJyk7XFxuICAgICAgICAgICAgZFswXS5zZXRBdHRyaWJ1dGUoXFxcImFyaWEtZXhwYW5kZWRcXFwiLCB0cnVlKTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2JlZm9yZV9vcGVuJywge1xcbiAgICAgICAgICAgICAgXFxcIm5vZGVcXFwiOiBvYmpcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICBkLmNoaWxkcmVuKFxcXCIuanN0cmVlLWNoaWxkcmVuXFxcIikuY3NzKFxcXCJkaXNwbGF5XFxcIiwgXFxcIm5vbmVcXFwiKS5lbmQoKS5yZW1vdmVDbGFzcyhcXFwianN0cmVlLWNsb3NlZFxcXCIpLmFkZENsYXNzKFxcXCJqc3RyZWUtb3BlblxcXCIpLmF0dHIoXFxcImFyaWEtZXhwYW5kZWRcXFwiLCB0cnVlKS5jaGlsZHJlbihcXFwiLmpzdHJlZS1jaGlsZHJlblxcXCIpLnN0b3AodHJ1ZSwgdHJ1ZSkuc2xpZGVEb3duKGFuaW1hdGlvbiwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gXFxcIlxcXCI7XFxuXFxuICAgICAgICAgICAgICBpZiAodC5lbGVtZW50KSB7XFxuICAgICAgICAgICAgICAgIHQudHJpZ2dlcihcXFwiYWZ0ZXJfb3BlblxcXCIsIHtcXG4gICAgICAgICAgICAgICAgICBcXFwibm9kZVxcXCI6IG9ialxcbiAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgb2JqLnN0YXRlLm9wZW5lZCA9IHRydWU7XFxuXFxuICAgICAgICBpZiAoY2FsbGJhY2spIHtcXG4gICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCBvYmosIHRydWUpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKCFkLmxlbmd0aCkge1xcbiAgICAgICAgICAvKipcXG4gICAgICAgICAgICogdHJpZ2dlcmVkIHdoZW4gYSBub2RlIGlzIGFib3V0IHRvIGJlIG9wZW5lZCAoaWYgdGhlIG5vZGUgaXMgc3VwcG9zZWQgdG8gYmUgaW4gdGhlIERPTSwgaXQgd2lsbCBiZSwgYnV0IGl0IHdvbid0IGJlIHZpc2libGUgeWV0KVxcbiAgICAgICAgICAgKiBAZXZlbnRcXG4gICAgICAgICAgICogQG5hbWUgYmVmb3JlX29wZW4uanN0cmVlXFxuICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIHRoZSBvcGVuZWQgbm9kZVxcbiAgICAgICAgICAgKi9cXG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCdiZWZvcmVfb3BlbicsIHtcXG4gICAgICAgICAgICBcXFwibm9kZVxcXCI6IG9ialxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogdHJpZ2dlcmVkIHdoZW4gYSBub2RlIGlzIG9wZW5lZCAoaWYgdGhlcmUgaXMgYW4gYW5pbWF0aW9uIGl0IHdpbGwgbm90IGJlIGNvbXBsZXRlZCB5ZXQpXFxuICAgICAgICAgKiBAZXZlbnRcXG4gICAgICAgICAqIEBuYW1lIG9wZW5fbm9kZS5qc3RyZWVcXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIHRoZSBvcGVuZWQgbm9kZVxcbiAgICAgICAgICovXFxuXFxuXFxuICAgICAgICB0aGlzLnRyaWdnZXIoJ29wZW5fbm9kZScsIHtcXG4gICAgICAgICAgXFxcIm5vZGVcXFwiOiBvYmpcXG4gICAgICAgIH0pO1xcblxcbiAgICAgICAgaWYgKCFhbmltYXRpb24gfHwgIWQubGVuZ3RoKSB7XFxuICAgICAgICAgIC8qKlxcbiAgICAgICAgICAgKiB0cmlnZ2VyZWQgd2hlbiBhIG5vZGUgaXMgb3BlbmVkIGFuZCB0aGUgYW5pbWF0aW9uIGlzIGNvbXBsZXRlXFxuICAgICAgICAgICAqIEBldmVudFxcbiAgICAgICAgICAgKiBAbmFtZSBhZnRlcl9vcGVuLmpzdHJlZVxcbiAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZSB0aGUgb3BlbmVkIG5vZGVcXG4gICAgICAgICAgICovXFxuICAgICAgICAgIHRoaXMudHJpZ2dlcihcXFwiYWZ0ZXJfb3BlblxcXCIsIHtcXG4gICAgICAgICAgICBcXFwibm9kZVxcXCI6IG9ialxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgIH1cXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIG9wZW5zIGV2ZXJ5IHBhcmVudCBvZiBhIG5vZGUgKG5vZGUgc2hvdWxkIGJlIGxvYWRlZClcXG4gICAgICogQG5hbWUgX29wZW5fdG8ob2JqKVxcbiAgICAgKiBAcGFyYW0ge21peGVkfSBvYmogdGhlIG5vZGUgdG8gcmV2ZWFsXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcbiAgICBfb3Blbl90bzogZnVuY3Rpb24gX29wZW5fdG8ob2JqKSB7XFxuICAgICAgb2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xcblxcbiAgICAgIGlmICghb2JqIHx8IG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCkge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgaSxcXG4gICAgICAgICAgaixcXG4gICAgICAgICAgcCA9IG9iai5wYXJlbnRzO1xcblxcbiAgICAgIGZvciAoaSA9IDAsIGogPSBwLmxlbmd0aDsgaSA8IGo7IGkgKz0gMSkge1xcbiAgICAgICAgaWYgKGkgIT09ICQuanN0cmVlLnJvb3QpIHtcXG4gICAgICAgICAgdGhpcy5vcGVuX25vZGUocFtpXSwgZmFsc2UsIDApO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gJCgnIycgKyBvYmouaWQucmVwbGFjZSgkLmpzdHJlZS5pZHJlZ2V4LCAnXFxcXFxcXFwkJicpLCB0aGlzLmVsZW1lbnQpO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogY2xvc2VzIGEgbm9kZSwgaGlkaW5nIGl0cyBjaGlsZHJlblxcbiAgICAgKiBAbmFtZSBjbG9zZV9ub2RlKG9iaiBbLCBhbmltYXRpb25dKVxcbiAgICAgKiBAcGFyYW0ge21peGVkfSBvYmogdGhlIG5vZGUgdG8gY2xvc2VcXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFuaW1hdGlvbiB0aGUgYW5pbWF0aW9uIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcyB3aGVuIGNsb3NpbmcgdGhlIG5vZGUgKG92ZXJyaWRlcyB0aGUgYGNvcmUuYW5pbWF0aW9uYCBzZXR0aW5nKS4gVXNlIGBmYWxzZWAgZm9yIG5vIGFuaW1hdGlvbi5cXG4gICAgICogQHRyaWdnZXIgY2xvc2Vfbm9kZS5qc3RyZWUsIGFmdGVyX2Nsb3NlLmpzdHJlZVxcbiAgICAgKi9cXG4gICAgY2xvc2Vfbm9kZTogZnVuY3Rpb24gY2xvc2Vfbm9kZShvYmosIGFuaW1hdGlvbikge1xcbiAgICAgIHZhciB0MSwgdDIsIHQsIGQ7XFxuXFxuICAgICAgaWYgKCQuaXNBcnJheShvYmopKSB7XFxuICAgICAgICBvYmogPSBvYmouc2xpY2UoKTtcXG5cXG4gICAgICAgIGZvciAodDEgPSAwLCB0MiA9IG9iai5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcXG4gICAgICAgICAgdGhpcy5jbG9zZV9ub2RlKG9ialt0MV0sIGFuaW1hdGlvbik7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICB9XFxuXFxuICAgICAgb2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xcblxcbiAgICAgIGlmICghb2JqIHx8IG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCkge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5pc19jbG9zZWQob2JqKSkge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICBhbmltYXRpb24gPSBhbmltYXRpb24gPT09IHVuZGVmaW5lZCA/IHRoaXMuc2V0dGluZ3MuY29yZS5hbmltYXRpb24gOiBhbmltYXRpb247XFxuICAgICAgdCA9IHRoaXM7XFxuICAgICAgZCA9IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKTtcXG4gICAgICBvYmouc3RhdGUub3BlbmVkID0gZmFsc2U7XFxuICAgICAgLyoqXFxuICAgICAgICogdHJpZ2dlcmVkIHdoZW4gYSBub2RlIGlzIGNsb3NlZCAoaWYgdGhlcmUgaXMgYW4gYW5pbWF0aW9uIGl0IHdpbGwgbm90IGJlIGNvbXBsZXRlIHlldClcXG4gICAgICAgKiBAZXZlbnRcXG4gICAgICAgKiBAbmFtZSBjbG9zZV9ub2RlLmpzdHJlZVxcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIHRoZSBjbG9zZWQgbm9kZVxcbiAgICAgICAqL1xcblxcbiAgICAgIHRoaXMudHJpZ2dlcignY2xvc2Vfbm9kZScsIHtcXG4gICAgICAgIFxcXCJub2RlXFxcIjogb2JqXFxuICAgICAgfSk7XFxuXFxuICAgICAgaWYgKCFkLmxlbmd0aCkge1xcbiAgICAgICAgLyoqXFxuICAgICAgICAgKiB0cmlnZ2VyZWQgd2hlbiBhIG5vZGUgaXMgY2xvc2VkIGFuZCB0aGUgYW5pbWF0aW9uIGlzIGNvbXBsZXRlXFxuICAgICAgICAgKiBAZXZlbnRcXG4gICAgICAgICAqIEBuYW1lIGFmdGVyX2Nsb3NlLmpzdHJlZVxcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGUgdGhlIGNsb3NlZCBub2RlXFxuICAgICAgICAgKi9cXG4gICAgICAgIHRoaXMudHJpZ2dlcihcXFwiYWZ0ZXJfY2xvc2VcXFwiLCB7XFxuICAgICAgICAgIFxcXCJub2RlXFxcIjogb2JqXFxuICAgICAgICB9KTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgaWYgKCFhbmltYXRpb24pIHtcXG4gICAgICAgICAgZFswXS5jbGFzc05hbWUgPSBkWzBdLmNsYXNzTmFtZS5yZXBsYWNlKCdqc3RyZWUtb3BlbicsICdqc3RyZWUtY2xvc2VkJyk7XFxuICAgICAgICAgIGQuYXR0cihcXFwiYXJpYS1leHBhbmRlZFxcXCIsIGZhbHNlKS5jaGlsZHJlbignLmpzdHJlZS1jaGlsZHJlbicpLnJlbW92ZSgpO1xcbiAgICAgICAgICB0aGlzLnRyaWdnZXIoXFxcImFmdGVyX2Nsb3NlXFxcIiwge1xcbiAgICAgICAgICAgIFxcXCJub2RlXFxcIjogb2JqXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgZC5jaGlsZHJlbihcXFwiLmpzdHJlZS1jaGlsZHJlblxcXCIpLmF0dHIoXFxcInN0eWxlXFxcIiwgXFxcImRpc3BsYXk6YmxvY2sgIWltcG9ydGFudFxcXCIpLmVuZCgpLnJlbW92ZUNsYXNzKFxcXCJqc3RyZWUtb3BlblxcXCIpLmFkZENsYXNzKFxcXCJqc3RyZWUtY2xvc2VkXFxcIikuYXR0cihcXFwiYXJpYS1leHBhbmRlZFxcXCIsIGZhbHNlKS5jaGlsZHJlbihcXFwiLmpzdHJlZS1jaGlsZHJlblxcXCIpLnN0b3AodHJ1ZSwgdHJ1ZSkuc2xpZGVVcChhbmltYXRpb24sIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSBcXFwiXFxcIjtcXG4gICAgICAgICAgICBkLmNoaWxkcmVuKCcuanN0cmVlLWNoaWxkcmVuJykucmVtb3ZlKCk7XFxuXFxuICAgICAgICAgICAgaWYgKHQuZWxlbWVudCkge1xcbiAgICAgICAgICAgICAgdC50cmlnZ2VyKFxcXCJhZnRlcl9jbG9zZVxcXCIsIHtcXG4gICAgICAgICAgICAgICAgXFxcIm5vZGVcXFwiOiBvYmpcXG4gICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogdG9nZ2xlcyBhIG5vZGUgLSBjbG9zaW5nIGl0IGlmIGl0IGlzIG9wZW4sIG9wZW5pbmcgaXQgaWYgaXQgaXMgY2xvc2VkXFxuICAgICAqIEBuYW1lIHRvZ2dsZV9ub2RlKG9iailcXG4gICAgICogQHBhcmFtIHttaXhlZH0gb2JqIHRoZSBub2RlIHRvIHRvZ2dsZVxcbiAgICAgKi9cXG4gICAgdG9nZ2xlX25vZGU6IGZ1bmN0aW9uIHRvZ2dsZV9ub2RlKG9iaikge1xcbiAgICAgIHZhciB0MSwgdDI7XFxuXFxuICAgICAgaWYgKCQuaXNBcnJheShvYmopKSB7XFxuICAgICAgICBvYmogPSBvYmouc2xpY2UoKTtcXG5cXG4gICAgICAgIGZvciAodDEgPSAwLCB0MiA9IG9iai5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcXG4gICAgICAgICAgdGhpcy50b2dnbGVfbm9kZShvYmpbdDFdKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5pc19jbG9zZWQob2JqKSkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMub3Blbl9ub2RlKG9iaik7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLmlzX29wZW4ob2JqKSkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvc2Vfbm9kZShvYmopO1xcbiAgICAgIH1cXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIG9wZW5zIGFsbCBub2RlcyB3aXRoaW4gYSBub2RlIChvciB0aGUgdHJlZSksIHJldmFsaW5nIHRoZWlyIGNoaWxkcmVuLiBJZiB0aGUgbm9kZSBpcyBub3QgbG9hZGVkIGl0IHdpbGwgYmUgbG9hZGVkIGFuZCBvcGVuZWQgb25jZSByZWFkeS5cXG4gICAgICogQG5hbWUgb3Blbl9hbGwoW29iaiwgYW5pbWF0aW9uLCBvcmlnaW5hbF9vYmpdKVxcbiAgICAgKiBAcGFyYW0ge21peGVkfSBvYmogdGhlIG5vZGUgdG8gb3BlbiByZWN1cnNpdmVseSwgb21pdCB0byBvcGVuIGFsbCBub2RlcyBpbiB0aGUgdHJlZVxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYW5pbWF0aW9uIHRoZSBhbmltYXRpb24gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzIHdoZW4gb3BlbmluZyB0aGUgbm9kZXMsIHRoZSBkZWZhdWx0IGlzIG5vIGFuaW1hdGlvblxcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gcmVmZXJlbmNlIHRvIHRoZSBub2RlIHRoYXQgc3RhcnRlZCB0aGUgcHJvY2VzcyAoaW50ZXJuYWwgdXNlKVxcbiAgICAgKiBAdHJpZ2dlciBvcGVuX2FsbC5qc3RyZWVcXG4gICAgICovXFxuICAgIG9wZW5fYWxsOiBmdW5jdGlvbiBvcGVuX2FsbChvYmosIGFuaW1hdGlvbiwgb3JpZ2luYWxfb2JqKSB7XFxuICAgICAgaWYgKCFvYmopIHtcXG4gICAgICAgIG9iaiA9ICQuanN0cmVlLnJvb3Q7XFxuICAgICAgfVxcblxcbiAgICAgIG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXG4gICAgICBpZiAoIW9iaikge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgZG9tID0gb2JqLmlkID09PSAkLmpzdHJlZS5yb290ID8gdGhpcy5nZXRfY29udGFpbmVyX3VsKCkgOiB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSksXFxuICAgICAgICAgIGksXFxuICAgICAgICAgIGosXFxuICAgICAgICAgIF90aGlzO1xcblxcbiAgICAgIGlmICghZG9tLmxlbmd0aCkge1xcbiAgICAgICAgZm9yIChpID0gMCwgaiA9IG9iai5jaGlsZHJlbl9kLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcbiAgICAgICAgICBpZiAodGhpcy5pc19jbG9zZWQodGhpcy5fbW9kZWwuZGF0YVtvYmouY2hpbGRyZW5fZFtpXV0pKSB7XFxuICAgICAgICAgICAgdGhpcy5fbW9kZWwuZGF0YVtvYmouY2hpbGRyZW5fZFtpXV0uc3RhdGUub3BlbmVkID0gdHJ1ZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlcignb3Blbl9hbGwnLCB7XFxuICAgICAgICAgIFxcXCJub2RlXFxcIjogb2JqXFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuXFxuICAgICAgb3JpZ2luYWxfb2JqID0gb3JpZ2luYWxfb2JqIHx8IGRvbTtcXG4gICAgICBfdGhpcyA9IHRoaXM7XFxuICAgICAgZG9tID0gdGhpcy5pc19jbG9zZWQob2JqKSA/IGRvbS5maW5kKCcuanN0cmVlLWNsb3NlZCcpLmFkZEJhY2soKSA6IGRvbS5maW5kKCcuanN0cmVlLWNsb3NlZCcpO1xcbiAgICAgIGRvbS5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIF90aGlzLm9wZW5fbm9kZSh0aGlzLCBmdW5jdGlvbiAobm9kZSwgc3RhdHVzKSB7XFxuICAgICAgICAgIGlmIChzdGF0dXMgJiYgdGhpcy5pc19wYXJlbnQobm9kZSkpIHtcXG4gICAgICAgICAgICB0aGlzLm9wZW5fYWxsKG5vZGUsIGFuaW1hdGlvbiwgb3JpZ2luYWxfb2JqKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSwgYW5pbWF0aW9uIHx8IDApO1xcbiAgICAgIH0pO1xcblxcbiAgICAgIGlmIChvcmlnaW5hbF9vYmouZmluZCgnLmpzdHJlZS1jbG9zZWQnKS5sZW5ndGggPT09IDApIHtcXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogdHJpZ2dlcmVkIHdoZW4gYW4gYG9wZW5fYWxsYCBjYWxsIGNvbXBsZXRlc1xcbiAgICAgICAgICogQGV2ZW50XFxuICAgICAgICAgKiBAbmFtZSBvcGVuX2FsbC5qc3RyZWVcXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIHRoZSBvcGVuZWQgbm9kZVxcbiAgICAgICAgICovXFxuICAgICAgICB0aGlzLnRyaWdnZXIoJ29wZW5fYWxsJywge1xcbiAgICAgICAgICBcXFwibm9kZVxcXCI6IHRoaXMuZ2V0X25vZGUob3JpZ2luYWxfb2JqKVxcbiAgICAgICAgfSk7XFxuICAgICAgfVxcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogY2xvc2VzIGFsbCBub2RlcyB3aXRoaW4gYSBub2RlIChvciB0aGUgdHJlZSksIHJldmFsaW5nIHRoZWlyIGNoaWxkcmVuXFxuICAgICAqIEBuYW1lIGNsb3NlX2FsbChbb2JqLCBhbmltYXRpb25dKVxcbiAgICAgKiBAcGFyYW0ge21peGVkfSBvYmogdGhlIG5vZGUgdG8gY2xvc2UgcmVjdXJzaXZlbHksIG9taXQgdG8gY2xvc2UgYWxsIG5vZGVzIGluIHRoZSB0cmVlXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhbmltYXRpb24gdGhlIGFuaW1hdGlvbiBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMgd2hlbiBjbG9zaW5nIHRoZSBub2RlcywgdGhlIGRlZmF1bHQgaXMgbm8gYW5pbWF0aW9uXFxuICAgICAqIEB0cmlnZ2VyIGNsb3NlX2FsbC5qc3RyZWVcXG4gICAgICovXFxuICAgIGNsb3NlX2FsbDogZnVuY3Rpb24gY2xvc2VfYWxsKG9iaiwgYW5pbWF0aW9uKSB7XFxuICAgICAgaWYgKCFvYmopIHtcXG4gICAgICAgIG9iaiA9ICQuanN0cmVlLnJvb3Q7XFxuICAgICAgfVxcblxcbiAgICAgIG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXG4gICAgICBpZiAoIW9iaikge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgZG9tID0gb2JqLmlkID09PSAkLmpzdHJlZS5yb290ID8gdGhpcy5nZXRfY29udGFpbmVyX3VsKCkgOiB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSksXFxuICAgICAgICAgIF90aGlzID0gdGhpcyxcXG4gICAgICAgICAgaSxcXG4gICAgICAgICAgajtcXG5cXG4gICAgICBpZiAoZG9tLmxlbmd0aCkge1xcbiAgICAgICAgZG9tID0gdGhpcy5pc19vcGVuKG9iaikgPyBkb20uZmluZCgnLmpzdHJlZS1vcGVuJykuYWRkQmFjaygpIDogZG9tLmZpbmQoJy5qc3RyZWUtb3BlbicpO1xcbiAgICAgICAgJChkb20uZ2V0KCkucmV2ZXJzZSgpKS5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgX3RoaXMuY2xvc2Vfbm9kZSh0aGlzLCBhbmltYXRpb24gfHwgMCk7XFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuXFxuICAgICAgZm9yIChpID0gMCwgaiA9IG9iai5jaGlsZHJlbl9kLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcbiAgICAgICAgdGhpcy5fbW9kZWwuZGF0YVtvYmouY2hpbGRyZW5fZFtpXV0uc3RhdGUub3BlbmVkID0gZmFsc2U7XFxuICAgICAgfVxcbiAgICAgIC8qKlxcbiAgICAgICAqIHRyaWdnZXJlZCB3aGVuIGFuIGBjbG9zZV9hbGxgIGNhbGwgY29tcGxldGVzXFxuICAgICAgICogQGV2ZW50XFxuICAgICAgICogQG5hbWUgY2xvc2VfYWxsLmpzdHJlZVxcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIHRoZSBjbG9zZWQgbm9kZVxcbiAgICAgICAqL1xcblxcblxcbiAgICAgIHRoaXMudHJpZ2dlcignY2xvc2VfYWxsJywge1xcbiAgICAgICAgXFxcIm5vZGVcXFwiOiBvYmpcXG4gICAgICB9KTtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIGNoZWNrcyBpZiBhIG5vZGUgaXMgZGlzYWJsZWQgKG5vdCBzZWxlY3RhYmxlKVxcbiAgICAgKiBAbmFtZSBpc19kaXNhYmxlZChvYmopXFxuICAgICAqIEBwYXJhbSAge21peGVkfSBvYmpcXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cXG4gICAgICovXFxuICAgIGlzX2Rpc2FibGVkOiBmdW5jdGlvbiBpc19kaXNhYmxlZChvYmopIHtcXG4gICAgICBvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XFxuICAgICAgcmV0dXJuIG9iaiAmJiBvYmouc3RhdGUgJiYgb2JqLnN0YXRlLmRpc2FibGVkO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogZW5hYmxlcyBhIG5vZGUgLSBzbyB0aGF0IGl0IGNhbiBiZSBzZWxlY3RlZFxcbiAgICAgKiBAbmFtZSBlbmFibGVfbm9kZShvYmopXFxuICAgICAqIEBwYXJhbSB7bWl4ZWR9IG9iaiB0aGUgbm9kZSB0byBlbmFibGVcXG4gICAgICogQHRyaWdnZXIgZW5hYmxlX25vZGUuanN0cmVlXFxuICAgICAqL1xcbiAgICBlbmFibGVfbm9kZTogZnVuY3Rpb24gZW5hYmxlX25vZGUob2JqKSB7XFxuICAgICAgdmFyIHQxLCB0MjtcXG5cXG4gICAgICBpZiAoJC5pc0FycmF5KG9iaikpIHtcXG4gICAgICAgIG9iaiA9IG9iai5zbGljZSgpO1xcblxcbiAgICAgICAgZm9yICh0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xcbiAgICAgICAgICB0aGlzLmVuYWJsZV9ub2RlKG9ialt0MV0pO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgfVxcblxcbiAgICAgIG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXG4gICAgICBpZiAoIW9iaiB8fCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgb2JqLnN0YXRlLmRpc2FibGVkID0gZmFsc2U7XFxuICAgICAgdGhpcy5nZXRfbm9kZShvYmosIHRydWUpLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLnJlbW92ZUNsYXNzKCdqc3RyZWUtZGlzYWJsZWQnKS5hdHRyKCdhcmlhLWRpc2FibGVkJywgZmFsc2UpO1xcbiAgICAgIC8qKlxcbiAgICAgICAqIHRyaWdnZXJlZCB3aGVuIGFuIG5vZGUgaXMgZW5hYmxlZFxcbiAgICAgICAqIEBldmVudFxcbiAgICAgICAqIEBuYW1lIGVuYWJsZV9ub2RlLmpzdHJlZVxcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIHRoZSBlbmFibGVkIG5vZGVcXG4gICAgICAgKi9cXG5cXG4gICAgICB0aGlzLnRyaWdnZXIoJ2VuYWJsZV9ub2RlJywge1xcbiAgICAgICAgJ25vZGUnOiBvYmpcXG4gICAgICB9KTtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIGRpc2FibGVzIGEgbm9kZSAtIHNvIHRoYXQgaXQgY2FuIG5vdCBiZSBzZWxlY3RlZFxcbiAgICAgKiBAbmFtZSBkaXNhYmxlX25vZGUob2JqKVxcbiAgICAgKiBAcGFyYW0ge21peGVkfSBvYmogdGhlIG5vZGUgdG8gZGlzYWJsZVxcbiAgICAgKiBAdHJpZ2dlciBkaXNhYmxlX25vZGUuanN0cmVlXFxuICAgICAqL1xcbiAgICBkaXNhYmxlX25vZGU6IGZ1bmN0aW9uIGRpc2FibGVfbm9kZShvYmopIHtcXG4gICAgICB2YXIgdDEsIHQyO1xcblxcbiAgICAgIGlmICgkLmlzQXJyYXkob2JqKSkge1xcbiAgICAgICAgb2JqID0gb2JqLnNsaWNlKCk7XFxuXFxuICAgICAgICBmb3IgKHQxID0gMCwgdDIgPSBvYmoubGVuZ3RoOyB0MSA8IHQyOyB0MSsrKSB7XFxuICAgICAgICAgIHRoaXMuZGlzYWJsZV9ub2RlKG9ialt0MV0pO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgfVxcblxcbiAgICAgIG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXG4gICAgICBpZiAoIW9iaiB8fCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgb2JqLnN0YXRlLmRpc2FibGVkID0gdHJ1ZTtcXG4gICAgICB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSkuY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuYWRkQ2xhc3MoJ2pzdHJlZS1kaXNhYmxlZCcpLmF0dHIoJ2FyaWEtZGlzYWJsZWQnLCB0cnVlKTtcXG4gICAgICAvKipcXG4gICAgICAgKiB0cmlnZ2VyZWQgd2hlbiBhbiBub2RlIGlzIGRpc2FibGVkXFxuICAgICAgICogQGV2ZW50XFxuICAgICAgICogQG5hbWUgZGlzYWJsZV9ub2RlLmpzdHJlZVxcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIHRoZSBkaXNhYmxlZCBub2RlXFxuICAgICAgICovXFxuXFxuICAgICAgdGhpcy50cmlnZ2VyKCdkaXNhYmxlX25vZGUnLCB7XFxuICAgICAgICAnbm9kZSc6IG9ialxcbiAgICAgIH0pO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogZGV0ZXJtaW5lcyBpZiBhIG5vZGUgaXMgaGlkZGVuXFxuICAgICAqIEBuYW1lIGlzX2hpZGRlbihvYmopXFxuICAgICAqIEBwYXJhbSB7bWl4ZWR9IG9iaiB0aGUgbm9kZVxcbiAgICAgKi9cXG4gICAgaXNfaGlkZGVuOiBmdW5jdGlvbiBpc19oaWRkZW4ob2JqKSB7XFxuICAgICAgb2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xcbiAgICAgIHJldHVybiBvYmouc3RhdGUuaGlkZGVuID09PSB0cnVlO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogaGlkZXMgYSBub2RlIC0gaXQgaXMgc3RpbGwgaW4gdGhlIHN0cnVjdHVyZSBidXQgd2lsbCBub3QgYmUgdmlzaWJsZVxcbiAgICAgKiBAbmFtZSBoaWRlX25vZGUob2JqKVxcbiAgICAgKiBAcGFyYW0ge21peGVkfSBvYmogdGhlIG5vZGUgdG8gaGlkZVxcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNraXBfcmVkcmF3IGludGVybmFsIHBhcmFtZXRlciBjb250cm9sbGluZyBpZiByZWRyYXcgaXMgY2FsbGVkXFxuICAgICAqIEB0cmlnZ2VyIGhpZGVfbm9kZS5qc3RyZWVcXG4gICAgICovXFxuICAgIGhpZGVfbm9kZTogZnVuY3Rpb24gaGlkZV9ub2RlKG9iaiwgc2tpcF9yZWRyYXcpIHtcXG4gICAgICB2YXIgdDEsIHQyO1xcblxcbiAgICAgIGlmICgkLmlzQXJyYXkob2JqKSkge1xcbiAgICAgICAgb2JqID0gb2JqLnNsaWNlKCk7XFxuXFxuICAgICAgICBmb3IgKHQxID0gMCwgdDIgPSBvYmoubGVuZ3RoOyB0MSA8IHQyOyB0MSsrKSB7XFxuICAgICAgICAgIHRoaXMuaGlkZV9ub2RlKG9ialt0MV0sIHRydWUpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKCFza2lwX3JlZHJhdykge1xcbiAgICAgICAgICB0aGlzLnJlZHJhdygpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgfVxcblxcbiAgICAgIG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXG4gICAgICBpZiAoIW9iaiB8fCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCFvYmouc3RhdGUuaGlkZGVuKSB7XFxuICAgICAgICBvYmouc3RhdGUuaGlkZGVuID0gdHJ1ZTtcXG5cXG4gICAgICAgIHRoaXMuX25vZGVfY2hhbmdlZChvYmoucGFyZW50KTtcXG5cXG4gICAgICAgIGlmICghc2tpcF9yZWRyYXcpIHtcXG4gICAgICAgICAgdGhpcy5yZWRyYXcoKTtcXG4gICAgICAgIH1cXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogdHJpZ2dlcmVkIHdoZW4gYW4gbm9kZSBpcyBoaWRkZW5cXG4gICAgICAgICAqIEBldmVudFxcbiAgICAgICAgICogQG5hbWUgaGlkZV9ub2RlLmpzdHJlZVxcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGUgdGhlIGhpZGRlbiBub2RlXFxuICAgICAgICAgKi9cXG5cXG5cXG4gICAgICAgIHRoaXMudHJpZ2dlcignaGlkZV9ub2RlJywge1xcbiAgICAgICAgICAnbm9kZSc6IG9ialxcbiAgICAgICAgfSk7XFxuICAgICAgfVxcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogc2hvd3MgYSBub2RlXFxuICAgICAqIEBuYW1lIHNob3dfbm9kZShvYmopXFxuICAgICAqIEBwYXJhbSB7bWl4ZWR9IG9iaiB0aGUgbm9kZSB0byBzaG93XFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2tpcF9yZWRyYXcgaW50ZXJuYWwgcGFyYW1ldGVyIGNvbnRyb2xsaW5nIGlmIHJlZHJhdyBpcyBjYWxsZWRcXG4gICAgICogQHRyaWdnZXIgc2hvd19ub2RlLmpzdHJlZVxcbiAgICAgKi9cXG4gICAgc2hvd19ub2RlOiBmdW5jdGlvbiBzaG93X25vZGUob2JqLCBza2lwX3JlZHJhdykge1xcbiAgICAgIHZhciB0MSwgdDI7XFxuXFxuICAgICAgaWYgKCQuaXNBcnJheShvYmopKSB7XFxuICAgICAgICBvYmogPSBvYmouc2xpY2UoKTtcXG5cXG4gICAgICAgIGZvciAodDEgPSAwLCB0MiA9IG9iai5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcXG4gICAgICAgICAgdGhpcy5zaG93X25vZGUob2JqW3QxXSwgdHJ1ZSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoIXNraXBfcmVkcmF3KSB7XFxuICAgICAgICAgIHRoaXMucmVkcmF3KCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICB9XFxuXFxuICAgICAgb2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xcblxcbiAgICAgIGlmICghb2JqIHx8IG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCkge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAob2JqLnN0YXRlLmhpZGRlbikge1xcbiAgICAgICAgb2JqLnN0YXRlLmhpZGRlbiA9IGZhbHNlO1xcblxcbiAgICAgICAgdGhpcy5fbm9kZV9jaGFuZ2VkKG9iai5wYXJlbnQpO1xcblxcbiAgICAgICAgaWYgKCFza2lwX3JlZHJhdykge1xcbiAgICAgICAgICB0aGlzLnJlZHJhdygpO1xcbiAgICAgICAgfVxcbiAgICAgICAgLyoqXFxuICAgICAgICAgKiB0cmlnZ2VyZWQgd2hlbiBhbiBub2RlIGlzIHNob3duXFxuICAgICAgICAgKiBAZXZlbnRcXG4gICAgICAgICAqIEBuYW1lIHNob3dfbm9kZS5qc3RyZWVcXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIHRoZSBzaG93biBub2RlXFxuICAgICAgICAgKi9cXG5cXG5cXG4gICAgICAgIHRoaXMudHJpZ2dlcignc2hvd19ub2RlJywge1xcbiAgICAgICAgICAnbm9kZSc6IG9ialxcbiAgICAgICAgfSk7XFxuICAgICAgfVxcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogaGlkZXMgYWxsIG5vZGVzXFxuICAgICAqIEBuYW1lIGhpZGVfYWxsKClcXG4gICAgICogQHRyaWdnZXIgaGlkZV9hbGwuanN0cmVlXFxuICAgICAqL1xcbiAgICBoaWRlX2FsbDogZnVuY3Rpb24gaGlkZV9hbGwoc2tpcF9yZWRyYXcpIHtcXG4gICAgICB2YXIgaSxcXG4gICAgICAgICAgbSA9IHRoaXMuX21vZGVsLmRhdGEsXFxuICAgICAgICAgIGlkcyA9IFtdO1xcblxcbiAgICAgIGZvciAoaSBpbiBtKSB7XFxuICAgICAgICBpZiAobS5oYXNPd25Qcm9wZXJ0eShpKSAmJiBpICE9PSAkLmpzdHJlZS5yb290ICYmICFtW2ldLnN0YXRlLmhpZGRlbikge1xcbiAgICAgICAgICBtW2ldLnN0YXRlLmhpZGRlbiA9IHRydWU7XFxuICAgICAgICAgIGlkcy5wdXNoKGkpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9tb2RlbC5mb3JjZV9mdWxsX3JlZHJhdyA9IHRydWU7XFxuXFxuICAgICAgaWYgKCFza2lwX3JlZHJhdykge1xcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcXG4gICAgICB9XFxuICAgICAgLyoqXFxuICAgICAgICogdHJpZ2dlcmVkIHdoZW4gYWxsIG5vZGVzIGFyZSBoaWRkZW5cXG4gICAgICAgKiBAZXZlbnRcXG4gICAgICAgKiBAbmFtZSBoaWRlX2FsbC5qc3RyZWVcXG4gICAgICAgKiBAcGFyYW0ge0FycmF5fSBub2RlcyB0aGUgSURzIG9mIGFsbCBoaWRkZW4gbm9kZXNcXG4gICAgICAgKi9cXG5cXG5cXG4gICAgICB0aGlzLnRyaWdnZXIoJ2hpZGVfYWxsJywge1xcbiAgICAgICAgJ25vZGVzJzogaWRzXFxuICAgICAgfSk7XFxuICAgICAgcmV0dXJuIGlkcztcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIHNob3dzIGFsbCBub2Rlc1xcbiAgICAgKiBAbmFtZSBzaG93X2FsbCgpXFxuICAgICAqIEB0cmlnZ2VyIHNob3dfYWxsLmpzdHJlZVxcbiAgICAgKi9cXG4gICAgc2hvd19hbGw6IGZ1bmN0aW9uIHNob3dfYWxsKHNraXBfcmVkcmF3KSB7XFxuICAgICAgdmFyIGksXFxuICAgICAgICAgIG0gPSB0aGlzLl9tb2RlbC5kYXRhLFxcbiAgICAgICAgICBpZHMgPSBbXTtcXG5cXG4gICAgICBmb3IgKGkgaW4gbSkge1xcbiAgICAgICAgaWYgKG0uaGFzT3duUHJvcGVydHkoaSkgJiYgaSAhPT0gJC5qc3RyZWUucm9vdCAmJiBtW2ldLnN0YXRlLmhpZGRlbikge1xcbiAgICAgICAgICBtW2ldLnN0YXRlLmhpZGRlbiA9IGZhbHNlO1xcbiAgICAgICAgICBpZHMucHVzaChpKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fbW9kZWwuZm9yY2VfZnVsbF9yZWRyYXcgPSB0cnVlO1xcblxcbiAgICAgIGlmICghc2tpcF9yZWRyYXcpIHtcXG4gICAgICAgIHRoaXMucmVkcmF3KCk7XFxuICAgICAgfVxcbiAgICAgIC8qKlxcbiAgICAgICAqIHRyaWdnZXJlZCB3aGVuIGFsbCBub2RlcyBhcmUgc2hvd25cXG4gICAgICAgKiBAZXZlbnRcXG4gICAgICAgKiBAbmFtZSBzaG93X2FsbC5qc3RyZWVcXG4gICAgICAgKiBAcGFyYW0ge0FycmF5fSBub2RlcyB0aGUgSURzIG9mIGFsbCBzaG93biBub2Rlc1xcbiAgICAgICAqL1xcblxcblxcbiAgICAgIHRoaXMudHJpZ2dlcignc2hvd19hbGwnLCB7XFxuICAgICAgICAnbm9kZXMnOiBpZHNcXG4gICAgICB9KTtcXG4gICAgICByZXR1cm4gaWRzO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogY2FsbGVkIHdoZW4gYSBub2RlIGlzIHNlbGVjdGVkIGJ5IHRoZSB1c2VyLiBVc2VkIGludGVybmFsbHkuXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBuYW1lIGFjdGl2YXRlX25vZGUob2JqLCBlKVxcbiAgICAgKiBAcGFyYW0ge21peGVkfSBvYmogdGhlIG5vZGVcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGUgdGhlIHJlbGF0ZWQgZXZlbnRcXG4gICAgICogQHRyaWdnZXIgYWN0aXZhdGVfbm9kZS5qc3RyZWUsIGNoYW5nZWQuanN0cmVlXFxuICAgICAqL1xcbiAgICBhY3RpdmF0ZV9ub2RlOiBmdW5jdGlvbiBhY3RpdmF0ZV9ub2RlKG9iaiwgZSkge1xcbiAgICAgIGlmICh0aGlzLmlzX2Rpc2FibGVkKG9iaikpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCFlIHx8IF90eXBlb2YoZSkgIT09ICdvYmplY3QnKSB7XFxuICAgICAgICBlID0ge307XFxuICAgICAgfSAvLyBlbnN1cmUgbGFzdF9jbGlja2VkIGlzIHN0aWxsIGluIHRoZSBET00sIG1ha2UgaXQgZnJlc2ggKG1heWJlIGl0IHdhcyBtb3ZlZD8pIGFuZCBtYWtlIHN1cmUgaXQgaXMgc3RpbGwgc2VsZWN0ZWQsIGlmIG5vdCAtIG1ha2UgbGFzdF9jbGlja2VkIHRoZSBsYXN0IHNlbGVjdGVkIG5vZGVcXG5cXG5cXG4gICAgICB0aGlzLl9kYXRhLmNvcmUubGFzdF9jbGlja2VkID0gdGhpcy5fZGF0YS5jb3JlLmxhc3RfY2xpY2tlZCAmJiB0aGlzLl9kYXRhLmNvcmUubGFzdF9jbGlja2VkLmlkICE9PSB1bmRlZmluZWQgPyB0aGlzLmdldF9ub2RlKHRoaXMuX2RhdGEuY29yZS5sYXN0X2NsaWNrZWQuaWQpIDogbnVsbDtcXG5cXG4gICAgICBpZiAodGhpcy5fZGF0YS5jb3JlLmxhc3RfY2xpY2tlZCAmJiAhdGhpcy5fZGF0YS5jb3JlLmxhc3RfY2xpY2tlZC5zdGF0ZS5zZWxlY3RlZCkge1xcbiAgICAgICAgdGhpcy5fZGF0YS5jb3JlLmxhc3RfY2xpY2tlZCA9IG51bGw7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghdGhpcy5fZGF0YS5jb3JlLmxhc3RfY2xpY2tlZCAmJiB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQubGVuZ3RoKSB7XFxuICAgICAgICB0aGlzLl9kYXRhLmNvcmUubGFzdF9jbGlja2VkID0gdGhpcy5nZXRfbm9kZSh0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWRbdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLmxlbmd0aCAtIDFdKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCF0aGlzLnNldHRpbmdzLmNvcmUubXVsdGlwbGUgfHwgIWUubWV0YUtleSAmJiAhZS5jdHJsS2V5ICYmICFlLnNoaWZ0S2V5IHx8IGUuc2hpZnRLZXkgJiYgKCF0aGlzLl9kYXRhLmNvcmUubGFzdF9jbGlja2VkIHx8ICF0aGlzLmdldF9wYXJlbnQob2JqKSB8fCB0aGlzLmdldF9wYXJlbnQob2JqKSAhPT0gdGhpcy5fZGF0YS5jb3JlLmxhc3RfY2xpY2tlZC5wYXJlbnQpKSB7XFxuICAgICAgICBpZiAoIXRoaXMuc2V0dGluZ3MuY29yZS5tdWx0aXBsZSAmJiAoZS5tZXRhS2V5IHx8IGUuY3RybEtleSB8fCBlLnNoaWZ0S2V5KSAmJiB0aGlzLmlzX3NlbGVjdGVkKG9iaikpIHtcXG4gICAgICAgICAgdGhpcy5kZXNlbGVjdF9ub2RlKG9iaiwgZmFsc2UsIGUpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgdGhpcy5kZXNlbGVjdF9hbGwodHJ1ZSk7XFxuICAgICAgICAgIHRoaXMuc2VsZWN0X25vZGUob2JqLCBmYWxzZSwgZmFsc2UsIGUpO1xcbiAgICAgICAgICB0aGlzLl9kYXRhLmNvcmUubGFzdF9jbGlja2VkID0gdGhpcy5nZXRfbm9kZShvYmopO1xcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBpZiAoZS5zaGlmdEtleSkge1xcbiAgICAgICAgICB2YXIgbyA9IHRoaXMuZ2V0X25vZGUob2JqKS5pZCxcXG4gICAgICAgICAgICAgIGwgPSB0aGlzLl9kYXRhLmNvcmUubGFzdF9jbGlja2VkLmlkLFxcbiAgICAgICAgICAgICAgcCA9IHRoaXMuZ2V0X25vZGUodGhpcy5fZGF0YS5jb3JlLmxhc3RfY2xpY2tlZC5wYXJlbnQpLmNoaWxkcmVuLFxcbiAgICAgICAgICAgICAgYyA9IGZhbHNlLFxcbiAgICAgICAgICAgICAgaSxcXG4gICAgICAgICAgICAgIGo7XFxuXFxuICAgICAgICAgIGZvciAoaSA9IDAsIGogPSBwLmxlbmd0aDsgaSA8IGo7IGkgKz0gMSkge1xcbiAgICAgICAgICAgIC8vIHNlcGFyYXRlIElGcyB3b3JrIHdoZW0gbyBhbmQgbCBhcmUgdGhlIHNhbWVcXG4gICAgICAgICAgICBpZiAocFtpXSA9PT0gbykge1xcbiAgICAgICAgICAgICAgYyA9ICFjO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpZiAocFtpXSA9PT0gbCkge1xcbiAgICAgICAgICAgICAgYyA9ICFjO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNfZGlzYWJsZWQocFtpXSkgJiYgKGMgfHwgcFtpXSA9PT0gbyB8fCBwW2ldID09PSBsKSkge1xcbiAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzX2hpZGRlbihwW2ldKSkge1xcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdF9ub2RlKHBbaV0sIHRydWUsIGZhbHNlLCBlKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgdGhpcy5kZXNlbGVjdF9ub2RlKHBbaV0sIHRydWUsIGUpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZWQnLCB7XFxuICAgICAgICAgICAgJ2FjdGlvbic6ICdzZWxlY3Rfbm9kZScsXFxuICAgICAgICAgICAgJ25vZGUnOiB0aGlzLmdldF9ub2RlKG9iaiksXFxuICAgICAgICAgICAgJ3NlbGVjdGVkJzogdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLFxcbiAgICAgICAgICAgICdldmVudCc6IGVcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBpZiAoIXRoaXMuaXNfc2VsZWN0ZWQob2JqKSkge1xcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0X25vZGUob2JqLCBmYWxzZSwgZmFsc2UsIGUpO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHRoaXMuZGVzZWxlY3Rfbm9kZShvYmosIGZhbHNlLCBlKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICAvKipcXG4gICAgICAgKiB0cmlnZ2VyZWQgd2hlbiBhbiBub2RlIGlzIGNsaWNrZWQgb3IgaW50ZXJjYXRlZCB3aXRoIGJ5IHRoZSB1c2VyXFxuICAgICAgICogQGV2ZW50XFxuICAgICAgICogQG5hbWUgYWN0aXZhdGVfbm9kZS5qc3RyZWVcXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZVxcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCB0aGUgb29yaWdpbmFsIGV2ZW50IChpZiBhbnkpIHdoaWNoIHRyaWdnZXJlZCB0aGUgY2FsbCAobWF5IGJlIGFuIGVtcHR5IG9iamVjdClcXG4gICAgICAgKi9cXG5cXG5cXG4gICAgICB0aGlzLnRyaWdnZXIoJ2FjdGl2YXRlX25vZGUnLCB7XFxuICAgICAgICAnbm9kZSc6IHRoaXMuZ2V0X25vZGUob2JqKSxcXG4gICAgICAgICdldmVudCc6IGVcXG4gICAgICB9KTtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIGFwcGxpZXMgdGhlIGhvdmVyIHN0YXRlIG9uIGEgbm9kZSwgY2FsbGVkIHdoZW4gYSBub2RlIGlzIGhvdmVyZWQgYnkgdGhlIHVzZXIuIFVzZWQgaW50ZXJuYWxseS5cXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQG5hbWUgaG92ZXJfbm9kZShvYmopXFxuICAgICAqIEBwYXJhbSB7bWl4ZWR9IG9ialxcbiAgICAgKiBAdHJpZ2dlciBob3Zlcl9ub2RlLmpzdHJlZVxcbiAgICAgKi9cXG4gICAgaG92ZXJfbm9kZTogZnVuY3Rpb24gaG92ZXJfbm9kZShvYmopIHtcXG4gICAgICBvYmogPSB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSk7XFxuXFxuICAgICAgaWYgKCFvYmogfHwgIW9iai5sZW5ndGggfHwgb2JqLmNoaWxkcmVuKCcuanN0cmVlLWhvdmVyZWQnKS5sZW5ndGgpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIG8gPSB0aGlzLmVsZW1lbnQuZmluZCgnLmpzdHJlZS1ob3ZlcmVkJyksXFxuICAgICAgICAgIHQgPSB0aGlzLmVsZW1lbnQ7XFxuXFxuICAgICAgaWYgKG8gJiYgby5sZW5ndGgpIHtcXG4gICAgICAgIHRoaXMuZGVob3Zlcl9ub2RlKG8pO1xcbiAgICAgIH1cXG5cXG4gICAgICBvYmouY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuYWRkQ2xhc3MoJ2pzdHJlZS1ob3ZlcmVkJyk7XFxuICAgICAgLyoqXFxuICAgICAgICogdHJpZ2dlcmVkIHdoZW4gYW4gbm9kZSBpcyBob3ZlcmVkXFxuICAgICAgICogQGV2ZW50XFxuICAgICAgICogQG5hbWUgaG92ZXJfbm9kZS5qc3RyZWVcXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZVxcbiAgICAgICAqL1xcblxcbiAgICAgIHRoaXMudHJpZ2dlcignaG92ZXJfbm9kZScsIHtcXG4gICAgICAgICdub2RlJzogdGhpcy5nZXRfbm9kZShvYmopXFxuICAgICAgfSk7XFxuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgICB0LmF0dHIoJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCcsIG9ialswXS5pZCk7XFxuICAgICAgfSwgMCk7XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiByZW1vdmVzIHRoZSBob3ZlciBzdGF0ZSBmcm9tIGEgbm9kZWNhbGxlZCB3aGVuIGEgbm9kZSBpcyBubyBsb25nZXIgaG92ZXJlZCBieSB0aGUgdXNlci4gVXNlZCBpbnRlcm5hbGx5LlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAbmFtZSBkZWhvdmVyX25vZGUob2JqKVxcbiAgICAgKiBAcGFyYW0ge21peGVkfSBvYmpcXG4gICAgICogQHRyaWdnZXIgZGVob3Zlcl9ub2RlLmpzdHJlZVxcbiAgICAgKi9cXG4gICAgZGVob3Zlcl9ub2RlOiBmdW5jdGlvbiBkZWhvdmVyX25vZGUob2JqKSB7XFxuICAgICAgb2JqID0gdGhpcy5nZXRfbm9kZShvYmosIHRydWUpO1xcblxcbiAgICAgIGlmICghb2JqIHx8ICFvYmoubGVuZ3RoIHx8ICFvYmouY2hpbGRyZW4oJy5qc3RyZWUtaG92ZXJlZCcpLmxlbmd0aCkge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICBvYmouY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykucmVtb3ZlQ2xhc3MoJ2pzdHJlZS1ob3ZlcmVkJyk7XFxuICAgICAgLyoqXFxuICAgICAgICogdHJpZ2dlcmVkIHdoZW4gYW4gbm9kZSBpcyBubyBsb25nZXIgaG92ZXJlZFxcbiAgICAgICAqIEBldmVudFxcbiAgICAgICAqIEBuYW1lIGRlaG92ZXJfbm9kZS5qc3RyZWVcXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZVxcbiAgICAgICAqL1xcblxcbiAgICAgIHRoaXMudHJpZ2dlcignZGVob3Zlcl9ub2RlJywge1xcbiAgICAgICAgJ25vZGUnOiB0aGlzLmdldF9ub2RlKG9iailcXG4gICAgICB9KTtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIHNlbGVjdCBhIG5vZGVcXG4gICAgICogQG5hbWUgc2VsZWN0X25vZGUob2JqIFssIHN1cHJlc3NfZXZlbnQsIHByZXZlbnRfb3Blbl0pXFxuICAgICAqIEBwYXJhbSB7bWl4ZWR9IG9iaiBhbiBhcnJheSBjYW4gYmUgdXNlZCB0byBzZWxlY3QgbXVsdGlwbGUgbm9kZXNcXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzdXByZXNzX2V2ZW50IGlmIHNldCB0byBgdHJ1ZWAgdGhlIGBjaGFuZ2VkLmpzdHJlZWAgZXZlbnQgd29uJ3QgYmUgdHJpZ2dlcmVkXFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcHJldmVudF9vcGVuIGlmIHNldCB0byBgdHJ1ZWAgcGFyZW50cyBvZiB0aGUgc2VsZWN0ZWQgbm9kZSB3b24ndCBiZSBvcGVuZWRcXG4gICAgICogQHRyaWdnZXIgc2VsZWN0X25vZGUuanN0cmVlLCBjaGFuZ2VkLmpzdHJlZVxcbiAgICAgKi9cXG4gICAgc2VsZWN0X25vZGU6IGZ1bmN0aW9uIHNlbGVjdF9ub2RlKG9iaiwgc3VwcmVzc19ldmVudCwgcHJldmVudF9vcGVuLCBlKSB7XFxuICAgICAgdmFyIGRvbSwgdDEsIHQyLCB0aDtcXG5cXG4gICAgICBpZiAoJC5pc0FycmF5KG9iaikpIHtcXG4gICAgICAgIG9iaiA9IG9iai5zbGljZSgpO1xcblxcbiAgICAgICAgZm9yICh0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xcbiAgICAgICAgICB0aGlzLnNlbGVjdF9ub2RlKG9ialt0MV0sIHN1cHJlc3NfZXZlbnQsIHByZXZlbnRfb3BlbiwgZSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICB9XFxuXFxuICAgICAgb2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xcblxcbiAgICAgIGlmICghb2JqIHx8IG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCkge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICBkb20gPSB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSk7XFxuXFxuICAgICAgaWYgKCFvYmouc3RhdGUuc2VsZWN0ZWQpIHtcXG4gICAgICAgIG9iai5zdGF0ZS5zZWxlY3RlZCA9IHRydWU7XFxuXFxuICAgICAgICB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQucHVzaChvYmouaWQpO1xcblxcbiAgICAgICAgaWYgKCFwcmV2ZW50X29wZW4pIHtcXG4gICAgICAgICAgZG9tID0gdGhpcy5fb3Blbl90byhvYmopO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKGRvbSAmJiBkb20ubGVuZ3RoKSB7XFxuICAgICAgICAgIGRvbS5hdHRyKCdhcmlhLXNlbGVjdGVkJywgdHJ1ZSkuY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuYWRkQ2xhc3MoJ2pzdHJlZS1jbGlja2VkJyk7XFxuICAgICAgICB9XFxuICAgICAgICAvKipcXG4gICAgICAgICAqIHRyaWdnZXJlZCB3aGVuIGFuIG5vZGUgaXMgc2VsZWN0ZWRcXG4gICAgICAgICAqIEBldmVudFxcbiAgICAgICAgICogQG5hbWUgc2VsZWN0X25vZGUuanN0cmVlXFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZVxcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gc2VsZWN0ZWQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uXFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgdGhlIGV2ZW50IChpZiBhbnkpIHRoYXQgdHJpZ2dlcmVkIHRoaXMgc2VsZWN0X25vZGVcXG4gICAgICAgICAqL1xcblxcblxcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdzZWxlY3Rfbm9kZScsIHtcXG4gICAgICAgICAgJ25vZGUnOiBvYmosXFxuICAgICAgICAgICdzZWxlY3RlZCc6IHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZCxcXG4gICAgICAgICAgJ2V2ZW50JzogZVxcbiAgICAgICAgfSk7XFxuXFxuICAgICAgICBpZiAoIXN1cHJlc3NfZXZlbnQpIHtcXG4gICAgICAgICAgLyoqXFxuICAgICAgICAgICAqIHRyaWdnZXJlZCB3aGVuIHNlbGVjdGlvbiBjaGFuZ2VzXFxuICAgICAgICAgICAqIEBldmVudFxcbiAgICAgICAgICAgKiBAbmFtZSBjaGFuZ2VkLmpzdHJlZVxcbiAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZVxcbiAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gYWN0aW9uIHRoZSBhY3Rpb24gdGhhdCBjYXVzZWQgdGhlIHNlbGVjdGlvbiB0byBjaGFuZ2VcXG4gICAgICAgICAgICogQHBhcmFtIHtBcnJheX0gc2VsZWN0ZWQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uXFxuICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCB0aGUgZXZlbnQgKGlmIGFueSkgdGhhdCB0cmlnZ2VyZWQgdGhpcyBjaGFuZ2VkIGV2ZW50XFxuICAgICAgICAgICAqL1xcbiAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZWQnLCB7XFxuICAgICAgICAgICAgJ2FjdGlvbic6ICdzZWxlY3Rfbm9kZScsXFxuICAgICAgICAgICAgJ25vZGUnOiBvYmosXFxuICAgICAgICAgICAgJ3NlbGVjdGVkJzogdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLFxcbiAgICAgICAgICAgICdldmVudCc6IGVcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogZGVzZWxlY3QgYSBub2RlXFxuICAgICAqIEBuYW1lIGRlc2VsZWN0X25vZGUob2JqIFssIHN1cHJlc3NfZXZlbnRdKVxcbiAgICAgKiBAcGFyYW0ge21peGVkfSBvYmogYW4gYXJyYXkgY2FuIGJlIHVzZWQgdG8gZGVzZWxlY3QgbXVsdGlwbGUgbm9kZXNcXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzdXByZXNzX2V2ZW50IGlmIHNldCB0byBgdHJ1ZWAgdGhlIGBjaGFuZ2VkLmpzdHJlZWAgZXZlbnQgd29uJ3QgYmUgdHJpZ2dlcmVkXFxuICAgICAqIEB0cmlnZ2VyIGRlc2VsZWN0X25vZGUuanN0cmVlLCBjaGFuZ2VkLmpzdHJlZVxcbiAgICAgKi9cXG4gICAgZGVzZWxlY3Rfbm9kZTogZnVuY3Rpb24gZGVzZWxlY3Rfbm9kZShvYmosIHN1cHJlc3NfZXZlbnQsIGUpIHtcXG4gICAgICB2YXIgdDEsIHQyLCBkb207XFxuXFxuICAgICAgaWYgKCQuaXNBcnJheShvYmopKSB7XFxuICAgICAgICBvYmogPSBvYmouc2xpY2UoKTtcXG5cXG4gICAgICAgIGZvciAodDEgPSAwLCB0MiA9IG9iai5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcXG4gICAgICAgICAgdGhpcy5kZXNlbGVjdF9ub2RlKG9ialt0MV0sIHN1cHJlc3NfZXZlbnQsIGUpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgfVxcblxcbiAgICAgIG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXG4gICAgICBpZiAoIW9iaiB8fCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgZG9tID0gdGhpcy5nZXRfbm9kZShvYmosIHRydWUpO1xcblxcbiAgICAgIGlmIChvYmouc3RhdGUuc2VsZWN0ZWQpIHtcXG4gICAgICAgIG9iai5zdGF0ZS5zZWxlY3RlZCA9IGZhbHNlO1xcbiAgICAgICAgdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkID0gJC52YWthdGEuYXJyYXlfcmVtb3ZlX2l0ZW0odGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLCBvYmouaWQpO1xcblxcbiAgICAgICAgaWYgKGRvbS5sZW5ndGgpIHtcXG4gICAgICAgICAgZG9tLmF0dHIoJ2FyaWEtc2VsZWN0ZWQnLCBmYWxzZSkuY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykucmVtb3ZlQ2xhc3MoJ2pzdHJlZS1jbGlja2VkJyk7XFxuICAgICAgICB9XFxuICAgICAgICAvKipcXG4gICAgICAgICAqIHRyaWdnZXJlZCB3aGVuIGFuIG5vZGUgaXMgZGVzZWxlY3RlZFxcbiAgICAgICAgICogQGV2ZW50XFxuICAgICAgICAgKiBAbmFtZSBkZXNlbGVjdF9ub2RlLmpzdHJlZVxcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGVcXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IHNlbGVjdGVkIHRoZSBjdXJyZW50IHNlbGVjdGlvblxcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IHRoZSBldmVudCAoaWYgYW55KSB0aGF0IHRyaWdnZXJlZCB0aGlzIGRlc2VsZWN0X25vZGVcXG4gICAgICAgICAqL1xcblxcblxcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdkZXNlbGVjdF9ub2RlJywge1xcbiAgICAgICAgICAnbm9kZSc6IG9iaixcXG4gICAgICAgICAgJ3NlbGVjdGVkJzogdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLFxcbiAgICAgICAgICAnZXZlbnQnOiBlXFxuICAgICAgICB9KTtcXG5cXG4gICAgICAgIGlmICghc3VwcmVzc19ldmVudCkge1xcbiAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZWQnLCB7XFxuICAgICAgICAgICAgJ2FjdGlvbic6ICdkZXNlbGVjdF9ub2RlJyxcXG4gICAgICAgICAgICAnbm9kZSc6IG9iaixcXG4gICAgICAgICAgICAnc2VsZWN0ZWQnOiB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQsXFxuICAgICAgICAgICAgJ2V2ZW50JzogZVxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBzZWxlY3QgYWxsIG5vZGVzIGluIHRoZSB0cmVlXFxuICAgICAqIEBuYW1lIHNlbGVjdF9hbGwoW3N1cHJlc3NfZXZlbnRdKVxcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHN1cHJlc3NfZXZlbnQgaWYgc2V0IHRvIGB0cnVlYCB0aGUgYGNoYW5nZWQuanN0cmVlYCBldmVudCB3b24ndCBiZSB0cmlnZ2VyZWRcXG4gICAgICogQHRyaWdnZXIgc2VsZWN0X2FsbC5qc3RyZWUsIGNoYW5nZWQuanN0cmVlXFxuICAgICAqL1xcbiAgICBzZWxlY3RfYWxsOiBmdW5jdGlvbiBzZWxlY3RfYWxsKHN1cHJlc3NfZXZlbnQpIHtcXG4gICAgICB2YXIgdG1wID0gdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLmNvbmNhdChbXSksXFxuICAgICAgICAgIGksXFxuICAgICAgICAgIGo7XFxuXFxuICAgICAgdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkID0gdGhpcy5fbW9kZWwuZGF0YVskLmpzdHJlZS5yb290XS5jaGlsZHJlbl9kLmNvbmNhdCgpO1xcblxcbiAgICAgIGZvciAoaSA9IDAsIGogPSB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICBpZiAodGhpcy5fbW9kZWwuZGF0YVt0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWRbaV1dKSB7XFxuICAgICAgICAgIHRoaXMuX21vZGVsLmRhdGFbdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkW2ldXS5zdGF0ZS5zZWxlY3RlZCA9IHRydWU7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMucmVkcmF3KHRydWUpO1xcbiAgICAgIC8qKlxcbiAgICAgICAqIHRyaWdnZXJlZCB3aGVuIGFsbCBub2RlcyBhcmUgc2VsZWN0ZWRcXG4gICAgICAgKiBAZXZlbnRcXG4gICAgICAgKiBAbmFtZSBzZWxlY3RfYWxsLmpzdHJlZVxcbiAgICAgICAqIEBwYXJhbSB7QXJyYXl9IHNlbGVjdGVkIHRoZSBjdXJyZW50IHNlbGVjdGlvblxcbiAgICAgICAqL1xcblxcbiAgICAgIHRoaXMudHJpZ2dlcignc2VsZWN0X2FsbCcsIHtcXG4gICAgICAgICdzZWxlY3RlZCc6IHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZFxcbiAgICAgIH0pO1xcblxcbiAgICAgIGlmICghc3VwcmVzc19ldmVudCkge1xcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdjaGFuZ2VkJywge1xcbiAgICAgICAgICAnYWN0aW9uJzogJ3NlbGVjdF9hbGwnLFxcbiAgICAgICAgICAnc2VsZWN0ZWQnOiB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQsXFxuICAgICAgICAgICdvbGRfc2VsZWN0aW9uJzogdG1wXFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBkZXNlbGVjdCBhbGwgc2VsZWN0ZWQgbm9kZXNcXG4gICAgICogQG5hbWUgZGVzZWxlY3RfYWxsKFtzdXByZXNzX2V2ZW50XSlcXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzdXByZXNzX2V2ZW50IGlmIHNldCB0byBgdHJ1ZWAgdGhlIGBjaGFuZ2VkLmpzdHJlZWAgZXZlbnQgd29uJ3QgYmUgdHJpZ2dlcmVkXFxuICAgICAqIEB0cmlnZ2VyIGRlc2VsZWN0X2FsbC5qc3RyZWUsIGNoYW5nZWQuanN0cmVlXFxuICAgICAqL1xcbiAgICBkZXNlbGVjdF9hbGw6IGZ1bmN0aW9uIGRlc2VsZWN0X2FsbChzdXByZXNzX2V2ZW50KSB7XFxuICAgICAgdmFyIHRtcCA9IHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZC5jb25jYXQoW10pLFxcbiAgICAgICAgICBpLFxcbiAgICAgICAgICBqO1xcblxcbiAgICAgIGZvciAoaSA9IDAsIGogPSB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICBpZiAodGhpcy5fbW9kZWwuZGF0YVt0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWRbaV1dKSB7XFxuICAgICAgICAgIHRoaXMuX21vZGVsLmRhdGFbdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkW2ldXS5zdGF0ZS5zZWxlY3RlZCA9IGZhbHNlO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQgPSBbXTtcXG4gICAgICB0aGlzLmVsZW1lbnQuZmluZCgnLmpzdHJlZS1jbGlja2VkJykucmVtb3ZlQ2xhc3MoJ2pzdHJlZS1jbGlja2VkJykucGFyZW50KCkuYXR0cignYXJpYS1zZWxlY3RlZCcsIGZhbHNlKTtcXG4gICAgICAvKipcXG4gICAgICAgKiB0cmlnZ2VyZWQgd2hlbiBhbGwgbm9kZXMgYXJlIGRlc2VsZWN0ZWRcXG4gICAgICAgKiBAZXZlbnRcXG4gICAgICAgKiBAbmFtZSBkZXNlbGVjdF9hbGwuanN0cmVlXFxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGUgdGhlIHByZXZpb3VzIHNlbGVjdGlvblxcbiAgICAgICAqIEBwYXJhbSB7QXJyYXl9IHNlbGVjdGVkIHRoZSBjdXJyZW50IHNlbGVjdGlvblxcbiAgICAgICAqL1xcblxcbiAgICAgIHRoaXMudHJpZ2dlcignZGVzZWxlY3RfYWxsJywge1xcbiAgICAgICAgJ3NlbGVjdGVkJzogdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLFxcbiAgICAgICAgJ25vZGUnOiB0bXBcXG4gICAgICB9KTtcXG5cXG4gICAgICBpZiAoIXN1cHJlc3NfZXZlbnQpIHtcXG4gICAgICAgIHRoaXMudHJpZ2dlcignY2hhbmdlZCcsIHtcXG4gICAgICAgICAgJ2FjdGlvbic6ICdkZXNlbGVjdF9hbGwnLFxcbiAgICAgICAgICAnc2VsZWN0ZWQnOiB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQsXFxuICAgICAgICAgICdvbGRfc2VsZWN0aW9uJzogdG1wXFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBjaGVja3MgaWYgYSBub2RlIGlzIHNlbGVjdGVkXFxuICAgICAqIEBuYW1lIGlzX3NlbGVjdGVkKG9iailcXG4gICAgICogQHBhcmFtICB7bWl4ZWR9ICBvYmpcXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cXG4gICAgICovXFxuICAgIGlzX3NlbGVjdGVkOiBmdW5jdGlvbiBpc19zZWxlY3RlZChvYmopIHtcXG4gICAgICBvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XFxuXFxuICAgICAgaWYgKCFvYmogfHwgb2JqLmlkID09PSAkLmpzdHJlZS5yb290KSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBvYmouc3RhdGUuc2VsZWN0ZWQ7XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBnZXQgYW4gYXJyYXkgb2YgYWxsIHNlbGVjdGVkIG5vZGVzXFxuICAgICAqIEBuYW1lIGdldF9zZWxlY3RlZChbZnVsbF0pXFxuICAgICAqIEBwYXJhbSAge21peGVkfSAgZnVsbCBpZiBzZXQgdG8gYHRydWVgIHRoZSByZXR1cm5lZCBhcnJheSB3aWxsIGNvbnNpc3Qgb2YgdGhlIGZ1bGwgbm9kZSBvYmplY3RzLCBvdGhlcndpc2UgLSBvbmx5IElEcyB3aWxsIGJlIHJldHVybmVkXFxuICAgICAqIEByZXR1cm4ge0FycmF5fVxcbiAgICAgKi9cXG4gICAgZ2V0X3NlbGVjdGVkOiBmdW5jdGlvbiBnZXRfc2VsZWN0ZWQoZnVsbCkge1xcbiAgICAgIHJldHVybiBmdWxsID8gJC5tYXAodGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLCAkLnByb3h5KGZ1bmN0aW9uIChpKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5nZXRfbm9kZShpKTtcXG4gICAgICB9LCB0aGlzKSkgOiB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQuc2xpY2UoKTtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIGdldCBhbiBhcnJheSBvZiBhbGwgdG9wIGxldmVsIHNlbGVjdGVkIG5vZGVzIChpZ25vcmluZyBjaGlsZHJlbiBvZiBzZWxlY3RlZCBub2RlcylcXG4gICAgICogQG5hbWUgZ2V0X3RvcF9zZWxlY3RlZChbZnVsbF0pXFxuICAgICAqIEBwYXJhbSAge21peGVkfSAgZnVsbCBpZiBzZXQgdG8gYHRydWVgIHRoZSByZXR1cm5lZCBhcnJheSB3aWxsIGNvbnNpc3Qgb2YgdGhlIGZ1bGwgbm9kZSBvYmplY3RzLCBvdGhlcndpc2UgLSBvbmx5IElEcyB3aWxsIGJlIHJldHVybmVkXFxuICAgICAqIEByZXR1cm4ge0FycmF5fVxcbiAgICAgKi9cXG4gICAgZ2V0X3RvcF9zZWxlY3RlZDogZnVuY3Rpb24gZ2V0X3RvcF9zZWxlY3RlZChmdWxsKSB7XFxuICAgICAgdmFyIHRtcCA9IHRoaXMuZ2V0X3NlbGVjdGVkKHRydWUpLFxcbiAgICAgICAgICBvYmogPSB7fSxcXG4gICAgICAgICAgaSxcXG4gICAgICAgICAgaixcXG4gICAgICAgICAgayxcXG4gICAgICAgICAgbDtcXG5cXG4gICAgICBmb3IgKGkgPSAwLCBqID0gdG1wLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcbiAgICAgICAgb2JqW3RtcFtpXS5pZF0gPSB0bXBbaV07XFxuICAgICAgfVxcblxcbiAgICAgIGZvciAoaSA9IDAsIGogPSB0bXAubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICBmb3IgKGsgPSAwLCBsID0gdG1wW2ldLmNoaWxkcmVuX2QubGVuZ3RoOyBrIDwgbDsgaysrKSB7XFxuICAgICAgICAgIGlmIChvYmpbdG1wW2ldLmNoaWxkcmVuX2Rba11dKSB7XFxuICAgICAgICAgICAgZGVsZXRlIG9ialt0bXBbaV0uY2hpbGRyZW5fZFtrXV07XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgdG1wID0gW107XFxuXFxuICAgICAgZm9yIChpIGluIG9iaikge1xcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShpKSkge1xcbiAgICAgICAgICB0bXAucHVzaChpKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIGZ1bGwgPyAkLm1hcCh0bXAsICQucHJveHkoZnVuY3Rpb24gKGkpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLmdldF9ub2RlKGkpO1xcbiAgICAgIH0sIHRoaXMpKSA6IHRtcDtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIGdldCBhbiBhcnJheSBvZiBhbGwgYm90dG9tIGxldmVsIHNlbGVjdGVkIG5vZGVzIChpZ25vcmluZyBzZWxlY3RlZCBwYXJlbnRzKVxcbiAgICAgKiBAbmFtZSBnZXRfYm90dG9tX3NlbGVjdGVkKFtmdWxsXSlcXG4gICAgICogQHBhcmFtICB7bWl4ZWR9ICBmdWxsIGlmIHNldCB0byBgdHJ1ZWAgdGhlIHJldHVybmVkIGFycmF5IHdpbGwgY29uc2lzdCBvZiB0aGUgZnVsbCBub2RlIG9iamVjdHMsIG90aGVyd2lzZSAtIG9ubHkgSURzIHdpbGwgYmUgcmV0dXJuZWRcXG4gICAgICogQHJldHVybiB7QXJyYXl9XFxuICAgICAqL1xcbiAgICBnZXRfYm90dG9tX3NlbGVjdGVkOiBmdW5jdGlvbiBnZXRfYm90dG9tX3NlbGVjdGVkKGZ1bGwpIHtcXG4gICAgICB2YXIgdG1wID0gdGhpcy5nZXRfc2VsZWN0ZWQodHJ1ZSksXFxuICAgICAgICAgIG9iaiA9IFtdLFxcbiAgICAgICAgICBpLFxcbiAgICAgICAgICBqO1xcblxcbiAgICAgIGZvciAoaSA9IDAsIGogPSB0bXAubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICBpZiAoIXRtcFtpXS5jaGlsZHJlbi5sZW5ndGgpIHtcXG4gICAgICAgICAgb2JqLnB1c2godG1wW2ldLmlkKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIGZ1bGwgPyAkLm1hcChvYmosICQucHJveHkoZnVuY3Rpb24gKGkpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLmdldF9ub2RlKGkpO1xcbiAgICAgIH0sIHRoaXMpKSA6IG9iajtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIGdldHMgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHRyZWUgc28gdGhhdCBpdCBjYW4gYmUgcmVzdG9yZWQgbGF0ZXIgd2l0aCBgc2V0X3N0YXRlKHN0YXRlKWAuIFVzZWQgaW50ZXJuYWxseS5cXG4gICAgICogQG5hbWUgZ2V0X3N0YXRlKClcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxcbiAgICAgKi9cXG4gICAgZ2V0X3N0YXRlOiBmdW5jdGlvbiBnZXRfc3RhdGUoKSB7XFxuICAgICAgdmFyIHN0YXRlID0ge1xcbiAgICAgICAgJ2NvcmUnOiB7XFxuICAgICAgICAgICdvcGVuJzogW10sXFxuICAgICAgICAgICdzY3JvbGwnOiB7XFxuICAgICAgICAgICAgJ2xlZnQnOiB0aGlzLmVsZW1lbnQuc2Nyb2xsTGVmdCgpLFxcbiAgICAgICAgICAgICd0b3AnOiB0aGlzLmVsZW1lbnQuc2Nyb2xsVG9wKClcXG4gICAgICAgICAgfSxcXG5cXG4gICAgICAgICAgLyohXFxuICAgICAgICAgICd0aGVtZXMnIDoge1xcbiAgICAgICAgICBcXHQnbmFtZScgOiB0aGlzLmdldF90aGVtZSgpLFxcbiAgICAgICAgICBcXHQnaWNvbnMnIDogdGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5pY29ucyxcXG4gICAgICAgICAgXFx0J2RvdHMnIDogdGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5kb3RzXFxuICAgICAgICAgIH0sXFxuICAgICAgICAgICovXFxuICAgICAgICAgICdzZWxlY3RlZCc6IFtdXFxuICAgICAgICB9XFxuICAgICAgfSxcXG4gICAgICAgICAgaTtcXG5cXG4gICAgICBmb3IgKGkgaW4gdGhpcy5fbW9kZWwuZGF0YSkge1xcbiAgICAgICAgaWYgKHRoaXMuX21vZGVsLmRhdGEuaGFzT3duUHJvcGVydHkoaSkpIHtcXG4gICAgICAgICAgaWYgKGkgIT09ICQuanN0cmVlLnJvb3QpIHtcXG4gICAgICAgICAgICBpZiAodGhpcy5fbW9kZWwuZGF0YVtpXS5zdGF0ZS5vcGVuZWQpIHtcXG4gICAgICAgICAgICAgIHN0YXRlLmNvcmUub3Blbi5wdXNoKGkpO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpZiAodGhpcy5fbW9kZWwuZGF0YVtpXS5zdGF0ZS5zZWxlY3RlZCkge1xcbiAgICAgICAgICAgICAgc3RhdGUuY29yZS5zZWxlY3RlZC5wdXNoKGkpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gc3RhdGU7XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBzZXRzIHRoZSBzdGF0ZSBvZiB0aGUgdHJlZS4gVXNlZCBpbnRlcm5hbGx5LlxcbiAgICAgKiBAbmFtZSBzZXRfc3RhdGUoc3RhdGUgWywgY2FsbGJhY2tdKVxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3RhdGUgdGhlIHN0YXRlIHRvIHJlc3RvcmUuIEtlZXAgaW4gbWluZCB0aGlzIG9iamVjdCBpcyBwYXNzZWQgYnkgcmVmZXJlbmNlIGFuZCBqc3RyZWUgd2lsbCBtb2RpZnkgaXQuXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGFuIG9wdGlvbmFsIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgb25jZSB0aGUgc3RhdGUgaXMgcmVzdG9yZWQuXFxuICAgICAqIEB0cmlnZ2VyIHNldF9zdGF0ZS5qc3RyZWVcXG4gICAgICovXFxuICAgIHNldF9zdGF0ZTogZnVuY3Rpb24gc2V0X3N0YXRlKHN0YXRlLCBjYWxsYmFjaykge1xcbiAgICAgIGlmIChzdGF0ZSkge1xcbiAgICAgICAgaWYgKHN0YXRlLmNvcmUpIHtcXG4gICAgICAgICAgdmFyIHJlcywgbiwgdCwgX3RoaXMsIGk7XFxuXFxuICAgICAgICAgIGlmIChzdGF0ZS5jb3JlLm9wZW4pIHtcXG4gICAgICAgICAgICBpZiAoISQuaXNBcnJheShzdGF0ZS5jb3JlLm9wZW4pIHx8ICFzdGF0ZS5jb3JlLm9wZW4ubGVuZ3RoKSB7XFxuICAgICAgICAgICAgICBkZWxldGUgc3RhdGUuY29yZS5vcGVuO1xcbiAgICAgICAgICAgICAgdGhpcy5zZXRfc3RhdGUoc3RhdGUsIGNhbGxiYWNrKTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgdGhpcy5fbG9hZF9ub2RlcyhzdGF0ZS5jb3JlLm9wZW4sIGZ1bmN0aW9uIChub2Rlcykge1xcbiAgICAgICAgICAgICAgICB0aGlzLm9wZW5fbm9kZShub2RlcywgZmFsc2UsIDApO1xcbiAgICAgICAgICAgICAgICBkZWxldGUgc3RhdGUuY29yZS5vcGVuO1xcbiAgICAgICAgICAgICAgICB0aGlzLnNldF9zdGF0ZShzdGF0ZSwgY2FsbGJhY2spO1xcbiAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAoc3RhdGUuY29yZS5zY3JvbGwpIHtcXG4gICAgICAgICAgICBpZiAoc3RhdGUuY29yZS5zY3JvbGwgJiYgc3RhdGUuY29yZS5zY3JvbGwubGVmdCAhPT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuc2Nyb2xsTGVmdChzdGF0ZS5jb3JlLnNjcm9sbC5sZWZ0KTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaWYgKHN0YXRlLmNvcmUuc2Nyb2xsICYmIHN0YXRlLmNvcmUuc2Nyb2xsLnRvcCAhPT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuc2Nyb2xsVG9wKHN0YXRlLmNvcmUuc2Nyb2xsLnRvcCk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGRlbGV0ZSBzdGF0ZS5jb3JlLnNjcm9sbDtcXG4gICAgICAgICAgICB0aGlzLnNldF9zdGF0ZShzdGF0ZSwgY2FsbGJhY2spO1xcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAoc3RhdGUuY29yZS5zZWxlY3RlZCkge1xcbiAgICAgICAgICAgIF90aGlzID0gdGhpcztcXG4gICAgICAgICAgICB0aGlzLmRlc2VsZWN0X2FsbCgpO1xcbiAgICAgICAgICAgICQuZWFjaChzdGF0ZS5jb3JlLnNlbGVjdGVkLCBmdW5jdGlvbiAoaSwgdikge1xcbiAgICAgICAgICAgICAgX3RoaXMuc2VsZWN0X25vZGUodiwgZmFsc2UsIHRydWUpO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIGRlbGV0ZSBzdGF0ZS5jb3JlLnNlbGVjdGVkO1xcbiAgICAgICAgICAgIHRoaXMuc2V0X3N0YXRlKHN0YXRlLCBjYWxsYmFjayk7XFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGZvciAoaSBpbiBzdGF0ZSkge1xcbiAgICAgICAgICAgIGlmIChzdGF0ZS5oYXNPd25Qcm9wZXJ0eShpKSAmJiBpICE9PSBcXFwiY29yZVxcXCIgJiYgJC5pbkFycmF5KGksIHRoaXMuc2V0dGluZ3MucGx1Z2lucykgPT09IC0xKSB7XFxuICAgICAgICAgICAgICBkZWxldGUgc3RhdGVbaV07XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmICgkLmlzRW1wdHlPYmplY3Qoc3RhdGUuY29yZSkpIHtcXG4gICAgICAgICAgICBkZWxldGUgc3RhdGUuY29yZTtcXG4gICAgICAgICAgICB0aGlzLnNldF9zdGF0ZShzdGF0ZSwgY2FsbGJhY2spO1xcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKCQuaXNFbXB0eU9iamVjdChzdGF0ZSkpIHtcXG4gICAgICAgICAgc3RhdGUgPSBudWxsO1xcblxcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcXG4gICAgICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXMpO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIC8qKlxcbiAgICAgICAgICAgKiB0cmlnZ2VyZWQgd2hlbiBhIGBzZXRfc3RhdGVgIGNhbGwgY29tcGxldGVzXFxuICAgICAgICAgICAqIEBldmVudFxcbiAgICAgICAgICAgKiBAbmFtZSBzZXRfc3RhdGUuanN0cmVlXFxuICAgICAgICAgICAqL1xcblxcblxcbiAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3NldF9zdGF0ZScpO1xcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogcmVmcmVzaGVzIHRoZSB0cmVlIC0gYWxsIG5vZGVzIGFyZSByZWxvYWRlZCB3aXRoIGNhbGxzIHRvIGBsb2FkX25vZGVgLlxcbiAgICAgKiBAbmFtZSByZWZyZXNoKClcXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBza2lwX2xvYWRpbmcgYW4gb3B0aW9uIHRvIHNraXAgc2hvd2luZyB0aGUgbG9hZGluZyBpbmRpY2F0b3JcXG4gICAgICogQHBhcmFtIHtNaXhlZH0gZm9yZ2V0X3N0YXRlIGlmIHNldCB0byBgdHJ1ZWAgc3RhdGUgd2lsbCBub3QgYmUgcmVhcHBsaWVkLCBpZiBzZXQgdG8gYSBmdW5jdGlvbiAocmVjZWl2aW5nIHRoZSBjdXJyZW50IHN0YXRlIGFzIGFyZ3VtZW50KSB0aGUgcmVzdWx0IG9mIHRoYXQgZnVuY3Rpb24gd2lsbCBiZSB1c2VkIGFzIHN0YXRlXFxuICAgICAqIEB0cmlnZ2VyIHJlZnJlc2guanN0cmVlXFxuICAgICAqL1xcbiAgICByZWZyZXNoOiBmdW5jdGlvbiByZWZyZXNoKHNraXBfbG9hZGluZywgZm9yZ2V0X3N0YXRlKSB7XFxuICAgICAgdGhpcy5fZGF0YS5jb3JlLnN0YXRlID0gZm9yZ2V0X3N0YXRlID09PSB0cnVlID8ge30gOiB0aGlzLmdldF9zdGF0ZSgpO1xcblxcbiAgICAgIGlmIChmb3JnZXRfc3RhdGUgJiYgJC5pc0Z1bmN0aW9uKGZvcmdldF9zdGF0ZSkpIHtcXG4gICAgICAgIHRoaXMuX2RhdGEuY29yZS5zdGF0ZSA9IGZvcmdldF9zdGF0ZS5jYWxsKHRoaXMsIHRoaXMuX2RhdGEuY29yZS5zdGF0ZSk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX2NudCA9IDA7XFxuICAgICAgdGhpcy5fbW9kZWwuZGF0YSA9IHt9O1xcbiAgICAgIHRoaXMuX21vZGVsLmRhdGFbJC5qc3RyZWUucm9vdF0gPSB7XFxuICAgICAgICBpZDogJC5qc3RyZWUucm9vdCxcXG4gICAgICAgIHBhcmVudDogbnVsbCxcXG4gICAgICAgIHBhcmVudHM6IFtdLFxcbiAgICAgICAgY2hpbGRyZW46IFtdLFxcbiAgICAgICAgY2hpbGRyZW5fZDogW10sXFxuICAgICAgICBzdGF0ZToge1xcbiAgICAgICAgICBsb2FkZWQ6IGZhbHNlXFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQgPSBbXTtcXG4gICAgICB0aGlzLl9kYXRhLmNvcmUubGFzdF9jbGlja2VkID0gbnVsbDtcXG4gICAgICB0aGlzLl9kYXRhLmNvcmUuZm9jdXNlZCA9IG51bGw7XFxuICAgICAgdmFyIGMgPSB0aGlzLmdldF9jb250YWluZXJfdWwoKVswXS5jbGFzc05hbWU7XFxuXFxuICAgICAgaWYgKCFza2lwX2xvYWRpbmcpIHtcXG4gICAgICAgIHRoaXMuZWxlbWVudC5odG1sKFxcXCI8XFxcIiArIFxcXCJ1bCBjbGFzcz0nXFxcIiArIGMgKyBcXFwiJyByb2xlPSdncm91cCc+PFxcXCIgKyBcXFwibGkgY2xhc3M9J2pzdHJlZS1pbml0aWFsLW5vZGUganN0cmVlLWxvYWRpbmcganN0cmVlLWxlYWYganN0cmVlLWxhc3QnIHJvbGU9J3RyZWVpdGVtJyBpZD0nalxcXCIgKyB0aGlzLl9pZCArIFxcXCJfbG9hZGluZyc+PGkgY2xhc3M9J2pzdHJlZS1pY29uIGpzdHJlZS1vY2wnPjwvaT48XFxcIiArIFxcXCJhIGNsYXNzPSdqc3RyZWUtYW5jaG9yJyBocmVmPScjJz48aSBjbGFzcz0nanN0cmVlLWljb24ganN0cmVlLXRoZW1laWNvbi1oaWRkZW4nPjwvaT5cXFwiICsgdGhpcy5nZXRfc3RyaW5nKFxcXCJMb2FkaW5nIC4uLlxcXCIpICsgXFxcIjwvYT48L2xpPjwvdWw+XFxcIik7XFxuICAgICAgICB0aGlzLmVsZW1lbnQuYXR0cignYXJpYS1hY3RpdmVkZXNjZW5kYW50JywgJ2onICsgdGhpcy5faWQgKyAnX2xvYWRpbmcnKTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5sb2FkX25vZGUoJC5qc3RyZWUucm9vdCwgZnVuY3Rpb24gKG8sIHMpIHtcXG4gICAgICAgIGlmIChzKSB7XFxuICAgICAgICAgIHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpWzBdLmNsYXNzTmFtZSA9IGM7XFxuXFxuICAgICAgICAgIGlmICh0aGlzLl9maXJzdENoaWxkKHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpWzBdKSkge1xcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5hdHRyKCdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnLCB0aGlzLl9maXJzdENoaWxkKHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpWzBdKS5pZCk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgdGhpcy5zZXRfc3RhdGUoJC5leHRlbmQodHJ1ZSwge30sIHRoaXMuX2RhdGEuY29yZS5zdGF0ZSksIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAvKipcXG4gICAgICAgICAgICAgKiB0cmlnZ2VyZWQgd2hlbiBhIGByZWZyZXNoYCBjYWxsIGNvbXBsZXRlc1xcbiAgICAgICAgICAgICAqIEBldmVudFxcbiAgICAgICAgICAgICAqIEBuYW1lIHJlZnJlc2guanN0cmVlXFxuICAgICAgICAgICAgICovXFxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdyZWZyZXNoJyk7XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdGhpcy5fZGF0YS5jb3JlLnN0YXRlID0gbnVsbDtcXG4gICAgICB9KTtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIHJlZnJlc2hlcyBhIG5vZGUgaW4gdGhlIHRyZWUgKHJlbG9hZCBpdHMgY2hpbGRyZW4pIGFsbCBvcGVuZWQgbm9kZXMgaW5zaWRlIHRoYXQgbm9kZSBhcmUgcmVsb2FkZWQgd2l0aCBjYWxscyB0byBgbG9hZF9ub2RlYC5cXG4gICAgICogQG5hbWUgcmVmcmVzaF9ub2RlKG9iailcXG4gICAgICogQHBhcmFtICB7bWl4ZWR9IG9iaiB0aGUgbm9kZVxcbiAgICAgKiBAdHJpZ2dlciByZWZyZXNoX25vZGUuanN0cmVlXFxuICAgICAqL1xcbiAgICByZWZyZXNoX25vZGU6IGZ1bmN0aW9uIHJlZnJlc2hfbm9kZShvYmopIHtcXG4gICAgICBvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XFxuXFxuICAgICAgaWYgKCFvYmogfHwgb2JqLmlkID09PSAkLmpzdHJlZS5yb290KSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBvcGVuZWQgPSBbXSxcXG4gICAgICAgICAgdG9fbG9hZCA9IFtdLFxcbiAgICAgICAgICBzID0gdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLmNvbmNhdChbXSk7XFxuXFxuICAgICAgdG9fbG9hZC5wdXNoKG9iai5pZCk7XFxuXFxuICAgICAgaWYgKG9iai5zdGF0ZS5vcGVuZWQgPT09IHRydWUpIHtcXG4gICAgICAgIG9wZW5lZC5wdXNoKG9iai5pZCk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKS5maW5kKCcuanN0cmVlLW9wZW4nKS5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHRvX2xvYWQucHVzaCh0aGlzLmlkKTtcXG4gICAgICAgIG9wZW5lZC5wdXNoKHRoaXMuaWQpO1xcbiAgICAgIH0pO1xcblxcbiAgICAgIHRoaXMuX2xvYWRfbm9kZXModG9fbG9hZCwgJC5wcm94eShmdW5jdGlvbiAobm9kZXMpIHtcXG4gICAgICAgIHRoaXMub3Blbl9ub2RlKG9wZW5lZCwgZmFsc2UsIDApO1xcbiAgICAgICAgdGhpcy5zZWxlY3Rfbm9kZShzKTtcXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogdHJpZ2dlcmVkIHdoZW4gYSBub2RlIGlzIHJlZnJlc2hlZFxcbiAgICAgICAgICogQGV2ZW50XFxuICAgICAgICAgKiBAbmFtZSByZWZyZXNoX25vZGUuanN0cmVlXFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZSAtIHRoZSByZWZyZXNoZWQgbm9kZVxcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gbm9kZXMgLSBhbiBhcnJheSBvZiB0aGUgSURzIG9mIHRoZSBub2RlcyB0aGF0IHdlcmUgcmVsb2FkZWRcXG4gICAgICAgICAqL1xcblxcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdyZWZyZXNoX25vZGUnLCB7XFxuICAgICAgICAgICdub2RlJzogb2JqLFxcbiAgICAgICAgICAnbm9kZXMnOiBub2Rlc1xcbiAgICAgICAgfSk7XFxuICAgICAgfSwgdGhpcyksIGZhbHNlLCB0cnVlKTtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIHNldCAoY2hhbmdlKSB0aGUgSUQgb2YgYSBub2RlXFxuICAgICAqIEBuYW1lIHNldF9pZChvYmosIGlkKVxcbiAgICAgKiBAcGFyYW0gIHttaXhlZH0gb2JqIHRoZSBub2RlXFxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gaWQgdGhlIG5ldyBJRFxcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxcbiAgICAgKiBAdHJpZ2dlciBzZXRfaWQuanN0cmVlXFxuICAgICAqL1xcbiAgICBzZXRfaWQ6IGZ1bmN0aW9uIHNldF9pZChvYmosIGlkKSB7XFxuICAgICAgb2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xcblxcbiAgICAgIGlmICghb2JqIHx8IG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCkge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgaSxcXG4gICAgICAgICAgaixcXG4gICAgICAgICAgbSA9IHRoaXMuX21vZGVsLmRhdGEsXFxuICAgICAgICAgIG9sZCA9IG9iai5pZDtcXG4gICAgICBpZCA9IGlkLnRvU3RyaW5nKCk7IC8vIHVwZGF0ZSBwYXJlbnRzIChyZXBsYWNlIGN1cnJlbnQgSUQgd2l0aCBuZXcgb25lIGluIGNoaWxkcmVuIGFuZCBjaGlsZHJlbl9kKVxcblxcbiAgICAgIG1bb2JqLnBhcmVudF0uY2hpbGRyZW5bJC5pbkFycmF5KG9iai5pZCwgbVtvYmoucGFyZW50XS5jaGlsZHJlbildID0gaWQ7XFxuXFxuICAgICAgZm9yIChpID0gMCwgaiA9IG9iai5wYXJlbnRzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcbiAgICAgICAgbVtvYmoucGFyZW50c1tpXV0uY2hpbGRyZW5fZFskLmluQXJyYXkob2JqLmlkLCBtW29iai5wYXJlbnRzW2ldXS5jaGlsZHJlbl9kKV0gPSBpZDtcXG4gICAgICB9IC8vIHVwZGF0ZSBjaGlsZHJlbiAocmVwbGFjZSBjdXJyZW50IElEIHdpdGggbmV3IG9uZSBpbiBwYXJlbnQgYW5kIHBhcmVudHMpXFxuXFxuXFxuICAgICAgZm9yIChpID0gMCwgaiA9IG9iai5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG4gICAgICAgIG1bb2JqLmNoaWxkcmVuW2ldXS5wYXJlbnQgPSBpZDtcXG4gICAgICB9XFxuXFxuICAgICAgZm9yIChpID0gMCwgaiA9IG9iai5jaGlsZHJlbl9kLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcbiAgICAgICAgbVtvYmouY2hpbGRyZW5fZFtpXV0ucGFyZW50c1skLmluQXJyYXkob2JqLmlkLCBtW29iai5jaGlsZHJlbl9kW2ldXS5wYXJlbnRzKV0gPSBpZDtcXG4gICAgICB9XFxuXFxuICAgICAgaSA9ICQuaW5BcnJheShvYmouaWQsIHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZCk7XFxuXFxuICAgICAgaWYgKGkgIT09IC0xKSB7XFxuICAgICAgICB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWRbaV0gPSBpZDtcXG4gICAgICB9IC8vIHVwZGF0ZSBtb2RlbCBhbmQgb2JqIGl0c2VsZiAob2JqLmlkLCB0aGlzLl9tb2RlbC5kYXRhW0tFWV0pXFxuXFxuXFxuICAgICAgaSA9IHRoaXMuZ2V0X25vZGUob2JqLmlkLCB0cnVlKTtcXG5cXG4gICAgICBpZiAoaSkge1xcbiAgICAgICAgaS5hdHRyKCdpZCcsIGlkKTsgLy8uY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuYXR0cignaWQnLCBpZCArICdfYW5jaG9yJykuZW5kKCkuYXR0cignYXJpYS1sYWJlbGxlZGJ5JywgaWQgKyAnX2FuY2hvcicpO1xcblxcbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudC5hdHRyKCdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnKSA9PT0gb2JqLmlkKSB7XFxuICAgICAgICAgIHRoaXMuZWxlbWVudC5hdHRyKCdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnLCBpZCk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGRlbGV0ZSBtW29iai5pZF07XFxuICAgICAgb2JqLmlkID0gaWQ7XFxuICAgICAgb2JqLmxpX2F0dHIuaWQgPSBpZDtcXG4gICAgICBtW2lkXSA9IG9iajtcXG4gICAgICAvKipcXG4gICAgICAgKiB0cmlnZ2VyZWQgd2hlbiBhIG5vZGUgaWQgdmFsdWUgaXMgY2hhbmdlZFxcbiAgICAgICAqIEBldmVudFxcbiAgICAgICAqIEBuYW1lIHNldF9pZC5qc3RyZWVcXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZVxcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGQgdGhlIG9sZCBpZFxcbiAgICAgICAqL1xcblxcbiAgICAgIHRoaXMudHJpZ2dlcignc2V0X2lkJywge1xcbiAgICAgICAgXFxcIm5vZGVcXFwiOiBvYmosXFxuICAgICAgICBcXFwibmV3XFxcIjogb2JqLmlkLFxcbiAgICAgICAgXFxcIm9sZFxcXCI6IG9sZFxcbiAgICAgIH0pO1xcbiAgICAgIHJldHVybiB0cnVlO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogZ2V0IHRoZSB0ZXh0IHZhbHVlIG9mIGEgbm9kZVxcbiAgICAgKiBAbmFtZSBnZXRfdGV4dChvYmopXFxuICAgICAqIEBwYXJhbSAge21peGVkfSBvYmogdGhlIG5vZGVcXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxcbiAgICAgKi9cXG4gICAgZ2V0X3RleHQ6IGZ1bmN0aW9uIGdldF90ZXh0KG9iaikge1xcbiAgICAgIG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcXG4gICAgICByZXR1cm4gIW9iaiB8fCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QgPyBmYWxzZSA6IG9iai50ZXh0O1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogc2V0IHRoZSB0ZXh0IHZhbHVlIG9mIGEgbm9kZS4gVXNlZCBpbnRlcm5hbGx5LCBwbGVhc2UgdXNlIGByZW5hbWVfbm9kZShvYmosIHZhbClgLlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAbmFtZSBzZXRfdGV4dChvYmosIHZhbClcXG4gICAgICogQHBhcmFtICB7bWl4ZWR9IG9iaiB0aGUgbm9kZSwgeW91IGNhbiBwYXNzIGFuIGFycmF5IHRvIHNldCB0aGUgdGV4dCBvbiBtdWx0aXBsZSBub2Rlc1xcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHZhbCB0aGUgbmV3IHRleHQgdmFsdWVcXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cXG4gICAgICogQHRyaWdnZXIgc2V0X3RleHQuanN0cmVlXFxuICAgICAqL1xcbiAgICBzZXRfdGV4dDogZnVuY3Rpb24gc2V0X3RleHQob2JqLCB2YWwpIHtcXG4gICAgICB2YXIgdDEsIHQyO1xcblxcbiAgICAgIGlmICgkLmlzQXJyYXkob2JqKSkge1xcbiAgICAgICAgb2JqID0gb2JqLnNsaWNlKCk7XFxuXFxuICAgICAgICBmb3IgKHQxID0gMCwgdDIgPSBvYmoubGVuZ3RoOyB0MSA8IHQyOyB0MSsrKSB7XFxuICAgICAgICAgIHRoaXMuc2V0X3RleHQob2JqW3QxXSwgdmFsKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgIH1cXG5cXG4gICAgICBvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XFxuXFxuICAgICAgaWYgKCFvYmogfHwgb2JqLmlkID09PSAkLmpzdHJlZS5yb290KSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcblxcbiAgICAgIG9iai50ZXh0ID0gdmFsO1xcblxcbiAgICAgIGlmICh0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSkubGVuZ3RoKSB7XFxuICAgICAgICB0aGlzLnJlZHJhd19ub2RlKG9iai5pZCk7XFxuICAgICAgfVxcbiAgICAgIC8qKlxcbiAgICAgICAqIHRyaWdnZXJlZCB3aGVuIGEgbm9kZSB0ZXh0IHZhbHVlIGlzIGNoYW5nZWRcXG4gICAgICAgKiBAZXZlbnRcXG4gICAgICAgKiBAbmFtZSBzZXRfdGV4dC5qc3RyZWVcXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqXFxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHRleHQgdGhlIG5ldyB2YWx1ZVxcbiAgICAgICAqL1xcblxcblxcbiAgICAgIHRoaXMudHJpZ2dlcignc2V0X3RleHQnLCB7XFxuICAgICAgICBcXFwib2JqXFxcIjogb2JqLFxcbiAgICAgICAgXFxcInRleHRcXFwiOiB2YWxcXG4gICAgICB9KTtcXG4gICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIGdldHMgYSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGEgbm9kZSAob3IgdGhlIHdob2xlIHRyZWUpXFxuICAgICAqIEBuYW1lIGdldF9qc29uKFtvYmosIG9wdGlvbnNdKVxcbiAgICAgKiBAcGFyYW0gIHttaXhlZH0gb2JqXFxuICAgICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xcbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBvcHRpb25zLm5vX3N0YXRlIGRvIG5vdCByZXR1cm4gc3RhdGUgaW5mb3JtYXRpb25cXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gb3B0aW9ucy5ub19pZCBkbyBub3QgcmV0dXJuIElEXFxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IG9wdGlvbnMubm9fY2hpbGRyZW4gZG8gbm90IGluY2x1ZGUgY2hpbGRyZW5cXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gb3B0aW9ucy5ub19kYXRhIGRvIG5vdCBpbmNsdWRlIG5vZGUgZGF0YVxcbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBvcHRpb25zLm5vX2xpX2F0dHIgZG8gbm90IGluY2x1ZGUgTEkgYXR0cmlidXRlc1xcbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBvcHRpb25zLm5vX2FfYXR0ciBkbyBub3QgaW5jbHVkZSBBIGF0dHJpYnV0ZXNcXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gb3B0aW9ucy5mbGF0IHJldHVybiBmbGF0IEpTT04gaW5zdGVhZCBvZiBuZXN0ZWRcXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxcbiAgICAgKi9cXG4gICAgZ2V0X2pzb246IGZ1bmN0aW9uIGdldF9qc29uKG9iaiwgb3B0aW9ucywgZmxhdCkge1xcbiAgICAgIG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqIHx8ICQuanN0cmVlLnJvb3QpO1xcblxcbiAgICAgIGlmICghb2JqKSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZmxhdCAmJiAhZmxhdCkge1xcbiAgICAgICAgZmxhdCA9IFtdO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgdG1wID0ge1xcbiAgICAgICAgJ2lkJzogb2JqLmlkLFxcbiAgICAgICAgJ3RleHQnOiBvYmoudGV4dCxcXG4gICAgICAgICdpY29uJzogdGhpcy5nZXRfaWNvbihvYmopLFxcbiAgICAgICAgJ2xpX2F0dHInOiAkLmV4dGVuZCh0cnVlLCB7fSwgb2JqLmxpX2F0dHIpLFxcbiAgICAgICAgJ2FfYXR0cic6ICQuZXh0ZW5kKHRydWUsIHt9LCBvYmouYV9hdHRyKSxcXG4gICAgICAgICdzdGF0ZSc6IHt9LFxcbiAgICAgICAgJ2RhdGEnOiBvcHRpb25zICYmIG9wdGlvbnMubm9fZGF0YSA/IGZhbHNlIDogJC5leHRlbmQodHJ1ZSwge30sIG9iai5kYXRhKSAvLyggdGhpcy5nZXRfbm9kZShvYmosIHRydWUpLmxlbmd0aCA/IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKS5kYXRhKCkgOiBvYmouZGF0YSApLFxcblxcbiAgICAgIH0sXFxuICAgICAgICAgIGksXFxuICAgICAgICAgIGo7XFxuXFxuICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5mbGF0KSB7XFxuICAgICAgICB0bXAucGFyZW50ID0gb2JqLnBhcmVudDtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdG1wLmNoaWxkcmVuID0gW107XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghb3B0aW9ucyB8fCAhb3B0aW9ucy5ub19zdGF0ZSkge1xcbiAgICAgICAgZm9yIChpIGluIG9iai5zdGF0ZSkge1xcbiAgICAgICAgICBpZiAob2JqLnN0YXRlLmhhc093blByb3BlcnR5KGkpKSB7XFxuICAgICAgICAgICAgdG1wLnN0YXRlW2ldID0gb2JqLnN0YXRlW2ldO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGRlbGV0ZSB0bXAuc3RhdGU7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMubm9fbGlfYXR0cikge1xcbiAgICAgICAgZGVsZXRlIHRtcC5saV9hdHRyO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLm5vX2FfYXR0cikge1xcbiAgICAgICAgZGVsZXRlIHRtcC5hX2F0dHI7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMubm9faWQpIHtcXG4gICAgICAgIGRlbGV0ZSB0bXAuaWQ7XFxuXFxuICAgICAgICBpZiAodG1wLmxpX2F0dHIgJiYgdG1wLmxpX2F0dHIuaWQpIHtcXG4gICAgICAgICAgZGVsZXRlIHRtcC5saV9hdHRyLmlkO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKHRtcC5hX2F0dHIgJiYgdG1wLmFfYXR0ci5pZCkge1xcbiAgICAgICAgICBkZWxldGUgdG1wLmFfYXR0ci5pZDtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5mbGF0ICYmIG9iai5pZCAhPT0gJC5qc3RyZWUucm9vdCkge1xcbiAgICAgICAgZmxhdC5wdXNoKHRtcCk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghb3B0aW9ucyB8fCAhb3B0aW9ucy5ub19jaGlsZHJlbikge1xcbiAgICAgICAgZm9yIChpID0gMCwgaiA9IG9iai5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG4gICAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5mbGF0KSB7XFxuICAgICAgICAgICAgdGhpcy5nZXRfanNvbihvYmouY2hpbGRyZW5baV0sIG9wdGlvbnMsIGZsYXQpO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHRtcC5jaGlsZHJlbi5wdXNoKHRoaXMuZ2V0X2pzb24ob2JqLmNoaWxkcmVuW2ldLCBvcHRpb25zKSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIG9wdGlvbnMgJiYgb3B0aW9ucy5mbGF0ID8gZmxhdCA6IG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCA/IHRtcC5jaGlsZHJlbiA6IHRtcDtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIGNyZWF0ZSBhIG5ldyBub2RlIChkbyBub3QgY29uZnVzZSB3aXRoIGxvYWRfbm9kZSlcXG4gICAgICogQG5hbWUgY3JlYXRlX25vZGUoW3Bhciwgbm9kZSwgcG9zLCBjYWxsYmFjaywgaXNfbG9hZGVkXSlcXG4gICAgICogQHBhcmFtICB7bWl4ZWR9ICAgcGFyICAgICAgIHRoZSBwYXJlbnQgbm9kZSAodG8gY3JlYXRlIGEgcm9vdCBub2RlIHVzZSBlaXRoZXIgXFxcIiNcXFwiIChzdHJpbmcpIG9yIGBudWxsYClcXG4gICAgICogQHBhcmFtICB7bWl4ZWR9ICAgbm9kZSAgICAgIHRoZSBkYXRhIGZvciB0aGUgbmV3IG5vZGUgKGEgdmFsaWQgSlNPTiBvYmplY3QsIG9yIGEgc2ltcGxlIHN0cmluZyB3aXRoIHRoZSBuYW1lKVxcbiAgICAgKiBAcGFyYW0gIHttaXhlZH0gICBwb3MgICAgICAgdGhlIGluZGV4IGF0IHdoaWNoIHRvIGluc2VydCB0aGUgbm9kZSwgXFxcImZpcnN0XFxcIiBhbmQgXFxcImxhc3RcXFwiIGFyZSBhbHNvIHN1cHBvcnRlZCwgZGVmYXVsdCBpcyBcXFwibGFzdFxcXCJcXG4gICAgICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrIGEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uY2UgdGhlIG5vZGUgaXMgY3JlYXRlZFxcbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBpc19sb2FkZWQgaW50ZXJuYWwgYXJndW1lbnQgaW5kaWNhdGluZyBpZiB0aGUgcGFyZW50IG5vZGUgd2FzIHN1Y2Nlc2Z1bGx5IGxvYWRlZFxcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgICAgdGhlIElEIG9mIHRoZSBuZXdseSBjcmVhdGUgbm9kZVxcbiAgICAgKiBAdHJpZ2dlciBtb2RlbC5qc3RyZWUsIGNyZWF0ZV9ub2RlLmpzdHJlZVxcbiAgICAgKi9cXG4gICAgY3JlYXRlX25vZGU6IGZ1bmN0aW9uIGNyZWF0ZV9ub2RlKHBhciwgbm9kZSwgcG9zLCBjYWxsYmFjaywgaXNfbG9hZGVkKSB7XFxuICAgICAgaWYgKHBhciA9PT0gbnVsbCkge1xcbiAgICAgICAgcGFyID0gJC5qc3RyZWUucm9vdDtcXG4gICAgICB9XFxuXFxuICAgICAgcGFyID0gdGhpcy5nZXRfbm9kZShwYXIpO1xcblxcbiAgICAgIGlmICghcGFyKSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcblxcbiAgICAgIHBvcyA9IHBvcyA9PT0gdW5kZWZpbmVkID8gXFxcImxhc3RcXFwiIDogcG9zO1xcblxcbiAgICAgIGlmICghcG9zLnRvU3RyaW5nKCkubWF0Y2goL14oYmVmb3JlfGFmdGVyKSQvKSAmJiAhaXNfbG9hZGVkICYmICF0aGlzLmlzX2xvYWRlZChwYXIpKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5sb2FkX25vZGUocGFyLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHRoaXMuY3JlYXRlX25vZGUocGFyLCBub2RlLCBwb3MsIGNhbGxiYWNrLCB0cnVlKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIW5vZGUpIHtcXG4gICAgICAgIG5vZGUgPSB7XFxuICAgICAgICAgIFxcXCJ0ZXh0XFxcIjogdGhpcy5nZXRfc3RyaW5nKCdOZXcgbm9kZScpXFxuICAgICAgICB9O1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodHlwZW9mIG5vZGUgPT09IFxcXCJzdHJpbmdcXFwiKSB7XFxuICAgICAgICBub2RlID0ge1xcbiAgICAgICAgICBcXFwidGV4dFxcXCI6IG5vZGVcXG4gICAgICAgIH07XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChub2RlLnRleHQgPT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgbm9kZS50ZXh0ID0gdGhpcy5nZXRfc3RyaW5nKCdOZXcgbm9kZScpO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgdG1wLCBkcGMsIGksIGo7XFxuXFxuICAgICAgaWYgKHBhci5pZCA9PT0gJC5qc3RyZWUucm9vdCkge1xcbiAgICAgICAgaWYgKHBvcyA9PT0gXFxcImJlZm9yZVxcXCIpIHtcXG4gICAgICAgICAgcG9zID0gXFxcImZpcnN0XFxcIjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChwb3MgPT09IFxcXCJhZnRlclxcXCIpIHtcXG4gICAgICAgICAgcG9zID0gXFxcImxhc3RcXFwiO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBzd2l0Y2ggKHBvcykge1xcbiAgICAgICAgY2FzZSBcXFwiYmVmb3JlXFxcIjpcXG4gICAgICAgICAgdG1wID0gdGhpcy5nZXRfbm9kZShwYXIucGFyZW50KTtcXG4gICAgICAgICAgcG9zID0gJC5pbkFycmF5KHBhci5pZCwgdG1wLmNoaWxkcmVuKTtcXG4gICAgICAgICAgcGFyID0gdG1wO1xcbiAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgIGNhc2UgXFxcImFmdGVyXFxcIjpcXG4gICAgICAgICAgdG1wID0gdGhpcy5nZXRfbm9kZShwYXIucGFyZW50KTtcXG4gICAgICAgICAgcG9zID0gJC5pbkFycmF5KHBhci5pZCwgdG1wLmNoaWxkcmVuKSArIDE7XFxuICAgICAgICAgIHBhciA9IHRtcDtcXG4gICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICBjYXNlIFxcXCJpbnNpZGVcXFwiOlxcbiAgICAgICAgY2FzZSBcXFwiZmlyc3RcXFwiOlxcbiAgICAgICAgICBwb3MgPSAwO1xcbiAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgIGNhc2UgXFxcImxhc3RcXFwiOlxcbiAgICAgICAgICBwb3MgPSBwYXIuY2hpbGRyZW4ubGVuZ3RoO1xcbiAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgIGRlZmF1bHQ6XFxuICAgICAgICAgIGlmICghcG9zKSB7XFxuICAgICAgICAgICAgcG9zID0gMDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBicmVhaztcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHBvcyA+IHBhci5jaGlsZHJlbi5sZW5ndGgpIHtcXG4gICAgICAgIHBvcyA9IHBhci5jaGlsZHJlbi5sZW5ndGg7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghbm9kZS5pZCkge1xcbiAgICAgICAgbm9kZS5pZCA9IHRydWU7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghdGhpcy5jaGVjayhcXFwiY3JlYXRlX25vZGVcXFwiLCBub2RlLCBwYXIsIHBvcykpIHtcXG4gICAgICAgIHRoaXMuc2V0dGluZ3MuY29yZS5lcnJvci5jYWxsKHRoaXMsIHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yKTtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKG5vZGUuaWQgPT09IHRydWUpIHtcXG4gICAgICAgIGRlbGV0ZSBub2RlLmlkO1xcbiAgICAgIH1cXG5cXG4gICAgICBub2RlID0gdGhpcy5fcGFyc2VfbW9kZWxfZnJvbV9qc29uKG5vZGUsIHBhci5pZCwgcGFyLnBhcmVudHMuY29uY2F0KCkpO1xcblxcbiAgICAgIGlmICghbm9kZSkge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICB0bXAgPSB0aGlzLmdldF9ub2RlKG5vZGUpO1xcbiAgICAgIGRwYyA9IFtdO1xcbiAgICAgIGRwYy5wdXNoKG5vZGUpO1xcbiAgICAgIGRwYyA9IGRwYy5jb25jYXQodG1wLmNoaWxkcmVuX2QpO1xcbiAgICAgIHRoaXMudHJpZ2dlcignbW9kZWwnLCB7XFxuICAgICAgICBcXFwibm9kZXNcXFwiOiBkcGMsXFxuICAgICAgICBcXFwicGFyZW50XFxcIjogcGFyLmlkXFxuICAgICAgfSk7XFxuICAgICAgcGFyLmNoaWxkcmVuX2QgPSBwYXIuY2hpbGRyZW5fZC5jb25jYXQoZHBjKTtcXG5cXG4gICAgICBmb3IgKGkgPSAwLCBqID0gcGFyLnBhcmVudHMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICB0aGlzLl9tb2RlbC5kYXRhW3Bhci5wYXJlbnRzW2ldXS5jaGlsZHJlbl9kID0gdGhpcy5fbW9kZWwuZGF0YVtwYXIucGFyZW50c1tpXV0uY2hpbGRyZW5fZC5jb25jYXQoZHBjKTtcXG4gICAgICB9XFxuXFxuICAgICAgbm9kZSA9IHRtcDtcXG4gICAgICB0bXAgPSBbXTtcXG5cXG4gICAgICBmb3IgKGkgPSAwLCBqID0gcGFyLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcbiAgICAgICAgdG1wW2kgPj0gcG9zID8gaSArIDEgOiBpXSA9IHBhci5jaGlsZHJlbltpXTtcXG4gICAgICB9XFxuXFxuICAgICAgdG1wW3Bvc10gPSBub2RlLmlkO1xcbiAgICAgIHBhci5jaGlsZHJlbiA9IHRtcDtcXG4gICAgICB0aGlzLnJlZHJhd19ub2RlKHBhciwgdHJ1ZSk7XFxuXFxuICAgICAgaWYgKGNhbGxiYWNrKSB7XFxuICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXMsIHRoaXMuZ2V0X25vZGUobm9kZSkpO1xcbiAgICAgIH1cXG4gICAgICAvKipcXG4gICAgICAgKiB0cmlnZ2VyZWQgd2hlbiBhIG5vZGUgaXMgY3JlYXRlZFxcbiAgICAgICAqIEBldmVudFxcbiAgICAgICAqIEBuYW1lIGNyZWF0ZV9ub2RlLmpzdHJlZVxcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlXFxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmVudCB0aGUgcGFyZW50J3MgSURcXG4gICAgICAgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb24gdGhlIHBvc2l0aW9uIG9mIHRoZSBuZXcgbm9kZSBhbW9uZyB0aGUgcGFyZW50J3MgY2hpbGRyZW5cXG4gICAgICAgKi9cXG5cXG5cXG4gICAgICB0aGlzLnRyaWdnZXIoJ2NyZWF0ZV9ub2RlJywge1xcbiAgICAgICAgXFxcIm5vZGVcXFwiOiB0aGlzLmdldF9ub2RlKG5vZGUpLFxcbiAgICAgICAgXFxcInBhcmVudFxcXCI6IHBhci5pZCxcXG4gICAgICAgIFxcXCJwb3NpdGlvblxcXCI6IHBvc1xcbiAgICAgIH0pO1xcbiAgICAgIHJldHVybiBub2RlLmlkO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogc2V0IHRoZSB0ZXh0IHZhbHVlIG9mIGEgbm9kZVxcbiAgICAgKiBAbmFtZSByZW5hbWVfbm9kZShvYmosIHZhbClcXG4gICAgICogQHBhcmFtICB7bWl4ZWR9IG9iaiB0aGUgbm9kZSwgeW91IGNhbiBwYXNzIGFuIGFycmF5IHRvIHJlbmFtZSBtdWx0aXBsZSBub2RlcyB0byB0aGUgc2FtZSBuYW1lXFxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gdmFsIHRoZSBuZXcgdGV4dCB2YWx1ZVxcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxcbiAgICAgKiBAdHJpZ2dlciByZW5hbWVfbm9kZS5qc3RyZWVcXG4gICAgICovXFxuICAgIHJlbmFtZV9ub2RlOiBmdW5jdGlvbiByZW5hbWVfbm9kZShvYmosIHZhbCkge1xcbiAgICAgIHZhciB0MSwgdDIsIG9sZDtcXG5cXG4gICAgICBpZiAoJC5pc0FycmF5KG9iaikpIHtcXG4gICAgICAgIG9iaiA9IG9iai5zbGljZSgpO1xcblxcbiAgICAgICAgZm9yICh0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xcbiAgICAgICAgICB0aGlzLnJlbmFtZV9ub2RlKG9ialt0MV0sIHZhbCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICB9XFxuXFxuICAgICAgb2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xcblxcbiAgICAgIGlmICghb2JqIHx8IG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCkge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICBvbGQgPSBvYmoudGV4dDtcXG5cXG4gICAgICBpZiAoIXRoaXMuY2hlY2soXFxcInJlbmFtZV9ub2RlXFxcIiwgb2JqLCB0aGlzLmdldF9wYXJlbnQob2JqKSwgdmFsKSkge1xcbiAgICAgICAgdGhpcy5zZXR0aW5ncy5jb3JlLmVycm9yLmNhbGwodGhpcywgdGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IpO1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLnNldF90ZXh0KG9iaiwgdmFsKTsgLy8gLmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpXFxuXFxuICAgICAgLyoqXFxuICAgICAgICogdHJpZ2dlcmVkIHdoZW4gYSBub2RlIGlzIHJlbmFtZWRcXG4gICAgICAgKiBAZXZlbnRcXG4gICAgICAgKiBAbmFtZSByZW5hbWVfbm9kZS5qc3RyZWVcXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZVxcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IHRoZSBuZXcgdmFsdWVcXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkIHRoZSBvbGQgdmFsdWVcXG4gICAgICAgKi9cXG5cXG4gICAgICB0aGlzLnRyaWdnZXIoJ3JlbmFtZV9ub2RlJywge1xcbiAgICAgICAgXFxcIm5vZGVcXFwiOiBvYmosXFxuICAgICAgICBcXFwidGV4dFxcXCI6IHZhbCxcXG4gICAgICAgIFxcXCJvbGRcXFwiOiBvbGRcXG4gICAgICB9KTtcXG4gICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIHJlbW92ZSBhIG5vZGVcXG4gICAgICogQG5hbWUgZGVsZXRlX25vZGUob2JqKVxcbiAgICAgKiBAcGFyYW0gIHttaXhlZH0gb2JqIHRoZSBub2RlLCB5b3UgY2FuIHBhc3MgYW4gYXJyYXkgdG8gZGVsZXRlIG11bHRpcGxlIG5vZGVzXFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XFxuICAgICAqIEB0cmlnZ2VyIGRlbGV0ZV9ub2RlLmpzdHJlZSwgY2hhbmdlZC5qc3RyZWVcXG4gICAgICovXFxuICAgIGRlbGV0ZV9ub2RlOiBmdW5jdGlvbiBkZWxldGVfbm9kZShvYmopIHtcXG4gICAgICB2YXIgdDEsIHQyLCBwYXIsIHBvcywgdG1wLCBpLCBqLCBrLCBsLCBjLCB0b3AsIGxmdDtcXG5cXG4gICAgICBpZiAoJC5pc0FycmF5KG9iaikpIHtcXG4gICAgICAgIG9iaiA9IG9iai5zbGljZSgpO1xcblxcbiAgICAgICAgZm9yICh0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xcbiAgICAgICAgICB0aGlzLmRlbGV0ZV9ub2RlKG9ialt0MV0pO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgfVxcblxcbiAgICAgIG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXG4gICAgICBpZiAoIW9iaiB8fCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgcGFyID0gdGhpcy5nZXRfbm9kZShvYmoucGFyZW50KTtcXG4gICAgICBwb3MgPSAkLmluQXJyYXkob2JqLmlkLCBwYXIuY2hpbGRyZW4pO1xcbiAgICAgIGMgPSBmYWxzZTtcXG5cXG4gICAgICBpZiAoIXRoaXMuY2hlY2soXFxcImRlbGV0ZV9ub2RlXFxcIiwgb2JqLCBwYXIsIHBvcykpIHtcXG4gICAgICAgIHRoaXMuc2V0dGluZ3MuY29yZS5lcnJvci5jYWxsKHRoaXMsIHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yKTtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHBvcyAhPT0gLTEpIHtcXG4gICAgICAgIHBhci5jaGlsZHJlbiA9ICQudmFrYXRhLmFycmF5X3JlbW92ZShwYXIuY2hpbGRyZW4sIHBvcyk7XFxuICAgICAgfVxcblxcbiAgICAgIHRtcCA9IG9iai5jaGlsZHJlbl9kLmNvbmNhdChbXSk7XFxuICAgICAgdG1wLnB1c2gob2JqLmlkKTtcXG5cXG4gICAgICBmb3IgKGkgPSAwLCBqID0gb2JqLnBhcmVudHMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICB0aGlzLl9tb2RlbC5kYXRhW29iai5wYXJlbnRzW2ldXS5jaGlsZHJlbl9kID0gJC52YWthdGEuYXJyYXlfZmlsdGVyKHRoaXMuX21vZGVsLmRhdGFbb2JqLnBhcmVudHNbaV1dLmNoaWxkcmVuX2QsIGZ1bmN0aW9uICh2KSB7XFxuICAgICAgICAgIHJldHVybiAkLmluQXJyYXkodiwgdG1wKSA9PT0gLTE7XFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuXFxuICAgICAgZm9yIChrID0gMCwgbCA9IHRtcC5sZW5ndGg7IGsgPCBsOyBrKyspIHtcXG4gICAgICAgIGlmICh0aGlzLl9tb2RlbC5kYXRhW3RtcFtrXV0uc3RhdGUuc2VsZWN0ZWQpIHtcXG4gICAgICAgICAgYyA9IHRydWU7XFxuICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoYykge1xcbiAgICAgICAgdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkID0gJC52YWthdGEuYXJyYXlfZmlsdGVyKHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZCwgZnVuY3Rpb24gKHYpIHtcXG4gICAgICAgICAgcmV0dXJuICQuaW5BcnJheSh2LCB0bXApID09PSAtMTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG4gICAgICAvKipcXG4gICAgICAgKiB0cmlnZ2VyZWQgd2hlbiBhIG5vZGUgaXMgZGVsZXRlZFxcbiAgICAgICAqIEBldmVudFxcbiAgICAgICAqIEBuYW1lIGRlbGV0ZV9ub2RlLmpzdHJlZVxcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlXFxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmVudCB0aGUgcGFyZW50J3MgSURcXG4gICAgICAgKi9cXG5cXG5cXG4gICAgICB0aGlzLnRyaWdnZXIoJ2RlbGV0ZV9ub2RlJywge1xcbiAgICAgICAgXFxcIm5vZGVcXFwiOiBvYmosXFxuICAgICAgICBcXFwicGFyZW50XFxcIjogcGFyLmlkXFxuICAgICAgfSk7XFxuXFxuICAgICAgaWYgKGMpIHtcXG4gICAgICAgIHRoaXMudHJpZ2dlcignY2hhbmdlZCcsIHtcXG4gICAgICAgICAgJ2FjdGlvbic6ICdkZWxldGVfbm9kZScsXFxuICAgICAgICAgICdub2RlJzogb2JqLFxcbiAgICAgICAgICAnc2VsZWN0ZWQnOiB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQsXFxuICAgICAgICAgICdwYXJlbnQnOiBwYXIuaWRcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG5cXG4gICAgICBmb3IgKGsgPSAwLCBsID0gdG1wLmxlbmd0aDsgayA8IGw7IGsrKykge1xcbiAgICAgICAgZGVsZXRlIHRoaXMuX21vZGVsLmRhdGFbdG1wW2tdXTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCQuaW5BcnJheSh0aGlzLl9kYXRhLmNvcmUuZm9jdXNlZCwgdG1wKSAhPT0gLTEpIHtcXG4gICAgICAgIHRoaXMuX2RhdGEuY29yZS5mb2N1c2VkID0gbnVsbDtcXG4gICAgICAgIHRvcCA9IHRoaXMuZWxlbWVudFswXS5zY3JvbGxUb3A7XFxuICAgICAgICBsZnQgPSB0aGlzLmVsZW1lbnRbMF0uc2Nyb2xsTGVmdDtcXG5cXG4gICAgICAgIGlmIChwYXIuaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcXG4gICAgICAgICAgaWYgKHRoaXMuX21vZGVsLmRhdGFbJC5qc3RyZWUucm9vdF0uY2hpbGRyZW5bMF0pIHtcXG4gICAgICAgICAgICB0aGlzLmdldF9ub2RlKHRoaXMuX21vZGVsLmRhdGFbJC5qc3RyZWUucm9vdF0uY2hpbGRyZW5bMF0sIHRydWUpLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLmZvY3VzKCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHRoaXMuZ2V0X25vZGUocGFyLCB0cnVlKS5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5mb2N1cygpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdGhpcy5lbGVtZW50WzBdLnNjcm9sbFRvcCA9IHRvcDtcXG4gICAgICAgIHRoaXMuZWxlbWVudFswXS5zY3JvbGxMZWZ0ID0gbGZ0O1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLnJlZHJhd19ub2RlKHBhciwgdHJ1ZSk7XFxuICAgICAgcmV0dXJuIHRydWU7XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBjaGVjayBpZiBhbiBvcGVyYXRpb24gaXMgcHJlbWl0dGVkIG9uIHRoZSB0cmVlLiBVc2VkIGludGVybmFsbHkuXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBuYW1lIGNoZWNrKGNoaywgb2JqLCBwYXIsIHBvcylcXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBjaGsgdGhlIG9wZXJhdGlvbiB0byBjaGVjaywgY2FuIGJlIFxcXCJjcmVhdGVfbm9kZVxcXCIsIFxcXCJyZW5hbWVfbm9kZVxcXCIsIFxcXCJkZWxldGVfbm9kZVxcXCIsIFxcXCJjb3B5X25vZGVcXFwiIG9yIFxcXCJtb3ZlX25vZGVcXFwiXFxuICAgICAqIEBwYXJhbSAge21peGVkfSBvYmogdGhlIG5vZGVcXG4gICAgICogQHBhcmFtICB7bWl4ZWR9IHBhciB0aGUgcGFyZW50XFxuICAgICAqIEBwYXJhbSAge21peGVkfSBwb3MgdGhlIHBvc2l0aW9uIHRvIGluc2VydCBhdCwgb3IgaWYgXFxcInJlbmFtZV9ub2RlXFxcIiAtIHRoZSBuZXcgbmFtZVxcbiAgICAgKiBAcGFyYW0gIHttaXhlZH0gbW9yZSBzb21lIHZhcmlvdXMgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiwgZm9yIGV4YW1wbGUgaWYgYSBcXFwibW92ZV9ub2RlXFxcIiBvcGVyYXRpb25zIGlzIHRyaWdnZXJlZCBieSBETkQgdGhpcyB3aWxsIGJlIHRoZSBob3ZlcmVkIG5vZGVcXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cXG4gICAgICovXFxuICAgIGNoZWNrOiBmdW5jdGlvbiBjaGVjayhjaGssIG9iaiwgcGFyLCBwb3MsIG1vcmUpIHtcXG4gICAgICBvYmogPSBvYmogJiYgb2JqLmlkID8gb2JqIDogdGhpcy5nZXRfbm9kZShvYmopO1xcbiAgICAgIHBhciA9IHBhciAmJiBwYXIuaWQgPyBwYXIgOiB0aGlzLmdldF9ub2RlKHBhcik7XFxuICAgICAgdmFyIHRtcCA9IGNoay5tYXRjaCgvXm1vdmVfbm9kZXxjb3B5X25vZGV8Y3JlYXRlX25vZGUkL2kpID8gcGFyIDogb2JqLFxcbiAgICAgICAgICBjaGMgPSB0aGlzLnNldHRpbmdzLmNvcmUuY2hlY2tfY2FsbGJhY2s7XFxuXFxuICAgICAgaWYgKGNoayA9PT0gXFxcIm1vdmVfbm9kZVxcXCIgfHwgY2hrID09PSBcXFwiY29weV9ub2RlXFxcIikge1xcbiAgICAgICAgaWYgKCghbW9yZSB8fCAhbW9yZS5pc19tdWx0aSkgJiYgKG9iai5pZCA9PT0gcGFyLmlkIHx8IGNoayA9PT0gXFxcIm1vdmVfbm9kZVxcXCIgJiYgJC5pbkFycmF5KG9iai5pZCwgcGFyLmNoaWxkcmVuKSA9PT0gcG9zIHx8ICQuaW5BcnJheShwYXIuaWQsIG9iai5jaGlsZHJlbl9kKSAhPT0gLTEpKSB7XFxuICAgICAgICAgIHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yID0ge1xcbiAgICAgICAgICAgICdlcnJvcic6ICdjaGVjaycsXFxuICAgICAgICAgICAgJ3BsdWdpbic6ICdjb3JlJyxcXG4gICAgICAgICAgICAnaWQnOiAnY29yZV8wMScsXFxuICAgICAgICAgICAgJ3JlYXNvbic6ICdNb3ZpbmcgcGFyZW50IGluc2lkZSBjaGlsZCcsXFxuICAgICAgICAgICAgJ2RhdGEnOiBKU09OLnN0cmluZ2lmeSh7XFxuICAgICAgICAgICAgICAnY2hrJzogY2hrLFxcbiAgICAgICAgICAgICAgJ3Bvcyc6IHBvcyxcXG4gICAgICAgICAgICAgICdvYmonOiBvYmogJiYgb2JqLmlkID8gb2JqLmlkIDogZmFsc2UsXFxuICAgICAgICAgICAgICAncGFyJzogcGFyICYmIHBhci5pZCA/IHBhci5pZCA6IGZhbHNlXFxuICAgICAgICAgICAgfSlcXG4gICAgICAgICAgfTtcXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodG1wICYmIHRtcC5kYXRhKSB7XFxuICAgICAgICB0bXAgPSB0bXAuZGF0YTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRtcCAmJiB0bXAuZnVuY3Rpb25zICYmICh0bXAuZnVuY3Rpb25zW2Noa10gPT09IGZhbHNlIHx8IHRtcC5mdW5jdGlvbnNbY2hrXSA9PT0gdHJ1ZSkpIHtcXG4gICAgICAgIGlmICh0bXAuZnVuY3Rpb25zW2Noa10gPT09IGZhbHNlKSB7XFxuICAgICAgICAgIHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yID0ge1xcbiAgICAgICAgICAgICdlcnJvcic6ICdjaGVjaycsXFxuICAgICAgICAgICAgJ3BsdWdpbic6ICdjb3JlJyxcXG4gICAgICAgICAgICAnaWQnOiAnY29yZV8wMicsXFxuICAgICAgICAgICAgJ3JlYXNvbic6ICdOb2RlIGRhdGEgcHJldmVudHMgZnVuY3Rpb246ICcgKyBjaGssXFxuICAgICAgICAgICAgJ2RhdGEnOiBKU09OLnN0cmluZ2lmeSh7XFxuICAgICAgICAgICAgICAnY2hrJzogY2hrLFxcbiAgICAgICAgICAgICAgJ3Bvcyc6IHBvcyxcXG4gICAgICAgICAgICAgICdvYmonOiBvYmogJiYgb2JqLmlkID8gb2JqLmlkIDogZmFsc2UsXFxuICAgICAgICAgICAgICAncGFyJzogcGFyICYmIHBhci5pZCA/IHBhci5pZCA6IGZhbHNlXFxuICAgICAgICAgICAgfSlcXG4gICAgICAgICAgfTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiB0bXAuZnVuY3Rpb25zW2Noa107XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChjaGMgPT09IGZhbHNlIHx8ICQuaXNGdW5jdGlvbihjaGMpICYmIGNoYy5jYWxsKHRoaXMsIGNoaywgb2JqLCBwYXIsIHBvcywgbW9yZSkgPT09IGZhbHNlIHx8IGNoYyAmJiBjaGNbY2hrXSA9PT0gZmFsc2UpIHtcXG4gICAgICAgIHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yID0ge1xcbiAgICAgICAgICAnZXJyb3InOiAnY2hlY2snLFxcbiAgICAgICAgICAncGx1Z2luJzogJ2NvcmUnLFxcbiAgICAgICAgICAnaWQnOiAnY29yZV8wMycsXFxuICAgICAgICAgICdyZWFzb24nOiAnVXNlciBjb25maWcgZm9yIGNvcmUuY2hlY2tfY2FsbGJhY2sgcHJldmVudHMgZnVuY3Rpb246ICcgKyBjaGssXFxuICAgICAgICAgICdkYXRhJzogSlNPTi5zdHJpbmdpZnkoe1xcbiAgICAgICAgICAgICdjaGsnOiBjaGssXFxuICAgICAgICAgICAgJ3Bvcyc6IHBvcyxcXG4gICAgICAgICAgICAnb2JqJzogb2JqICYmIG9iai5pZCA/IG9iai5pZCA6IGZhbHNlLFxcbiAgICAgICAgICAgICdwYXInOiBwYXIgJiYgcGFyLmlkID8gcGFyLmlkIDogZmFsc2VcXG4gICAgICAgICAgfSlcXG4gICAgICAgIH07XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiB0cnVlO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogZ2V0IHRoZSBsYXN0IGVycm9yXFxuICAgICAqIEBuYW1lIGxhc3RfZXJyb3IoKVxcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XFxuICAgICAqL1xcbiAgICBsYXN0X2Vycm9yOiBmdW5jdGlvbiBsYXN0X2Vycm9yKCkge1xcbiAgICAgIHJldHVybiB0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvcjtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIG1vdmUgYSBub2RlIHRvIGEgbmV3IHBhcmVudFxcbiAgICAgKiBAbmFtZSBtb3ZlX25vZGUob2JqLCBwYXIgWywgcG9zLCBjYWxsYmFjaywgaXNfbG9hZGVkXSlcXG4gICAgICogQHBhcmFtICB7bWl4ZWR9IG9iaiB0aGUgbm9kZSB0byBtb3ZlLCBwYXNzIGFuIGFycmF5IHRvIG1vdmUgbXVsdGlwbGUgbm9kZXNcXG4gICAgICogQHBhcmFtICB7bWl4ZWR9IHBhciB0aGUgbmV3IHBhcmVudFxcbiAgICAgKiBAcGFyYW0gIHttaXhlZH0gcG9zIHRoZSBwb3NpdGlvbiB0byBpbnNlcnQgYXQgKGJlc2lkZXMgaW50ZWdlciB2YWx1ZXMsIFxcXCJmaXJzdFxcXCIgYW5kIFxcXCJsYXN0XFxcIiBhcmUgc3VwcG9ydGVkLCBhcyB3ZWxsIGFzIFxcXCJiZWZvcmVcXFwiIGFuZCBcXFwiYWZ0ZXJcXFwiKSwgZGVmYXVsdHMgdG8gaW50ZWdlciBgMGBcXG4gICAgICogQHBhcmFtICB7ZnVuY3Rpb259IGNhbGxiYWNrIGEgZnVuY3Rpb24gdG8gY2FsbCBvbmNlIHRoZSBtb3ZlIGlzIGNvbXBsZXRlZCwgcmVjZWl2ZXMgMyBhcmd1bWVudHMgLSB0aGUgbm9kZSwgdGhlIG5ldyBwYXJlbnQgYW5kIHRoZSBwb3NpdGlvblxcbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBpc19sb2FkZWQgaW50ZXJuYWwgcGFyYW1ldGVyIGluZGljYXRpbmcgaWYgdGhlIHBhcmVudCBub2RlIGhhcyBiZWVuIGxvYWRlZFxcbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBza2lwX3JlZHJhdyBpbnRlcm5hbCBwYXJhbWV0ZXIgaW5kaWNhdGluZyBpZiB0aGUgdHJlZSBzaG91bGQgYmUgcmVkcmF3blxcbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBpbnN0YW5jZSBpbnRlcm5hbCBwYXJhbWV0ZXIgaW5kaWNhdGluZyBpZiB0aGUgbm9kZSBjb21lcyBmcm9tIGFub3RoZXIgaW5zdGFuY2VcXG4gICAgICogQHRyaWdnZXIgbW92ZV9ub2RlLmpzdHJlZVxcbiAgICAgKi9cXG4gICAgbW92ZV9ub2RlOiBmdW5jdGlvbiBtb3ZlX25vZGUob2JqLCBwYXIsIHBvcywgY2FsbGJhY2ssIGlzX2xvYWRlZCwgc2tpcF9yZWRyYXcsIG9yaWdpbikge1xcbiAgICAgIHZhciB0MSwgdDIsIG9sZF9wYXIsIG9sZF9wb3MsIG5ld19wYXIsIG9sZF9pbnMsIGlzX211bHRpLCBkcGMsIHRtcCwgaSwgaiwgaywgbCwgcDtcXG4gICAgICBwYXIgPSB0aGlzLmdldF9ub2RlKHBhcik7XFxuICAgICAgcG9zID0gcG9zID09PSB1bmRlZmluZWQgPyAwIDogcG9zO1xcblxcbiAgICAgIGlmICghcGFyKSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghcG9zLnRvU3RyaW5nKCkubWF0Y2goL14oYmVmb3JlfGFmdGVyKSQvKSAmJiAhaXNfbG9hZGVkICYmICF0aGlzLmlzX2xvYWRlZChwYXIpKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5sb2FkX25vZGUocGFyLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHRoaXMubW92ZV9ub2RlKG9iaiwgcGFyLCBwb3MsIGNhbGxiYWNrLCB0cnVlLCBmYWxzZSwgb3JpZ2luKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoJC5pc0FycmF5KG9iaikpIHtcXG4gICAgICAgIGlmIChvYmoubGVuZ3RoID09PSAxKSB7XFxuICAgICAgICAgIG9iaiA9IG9ialswXTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIC8vb2JqID0gb2JqLnNsaWNlKCk7XFxuICAgICAgICAgIGZvciAodDEgPSAwLCB0MiA9IG9iai5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcXG4gICAgICAgICAgICBpZiAodG1wID0gdGhpcy5tb3ZlX25vZGUob2JqW3QxXSwgcGFyLCBwb3MsIGNhbGxiYWNrLCBpc19sb2FkZWQsIGZhbHNlLCBvcmlnaW4pKSB7XFxuICAgICAgICAgICAgICBwYXIgPSB0bXA7XFxuICAgICAgICAgICAgICBwb3MgPSBcXFwiYWZ0ZXJcXFwiO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICB0aGlzLnJlZHJhdygpO1xcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgb2JqID0gb2JqICYmIG9iai5pZCA/IG9iaiA6IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXG4gICAgICBpZiAoIW9iaiB8fCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgb2xkX3BhciA9IChvYmoucGFyZW50IHx8ICQuanN0cmVlLnJvb3QpLnRvU3RyaW5nKCk7XFxuICAgICAgbmV3X3BhciA9ICFwb3MudG9TdHJpbmcoKS5tYXRjaCgvXihiZWZvcmV8YWZ0ZXIpJC8pIHx8IHBhci5pZCA9PT0gJC5qc3RyZWUucm9vdCA/IHBhciA6IHRoaXMuZ2V0X25vZGUocGFyLnBhcmVudCk7XFxuICAgICAgb2xkX2lucyA9IG9yaWdpbiA/IG9yaWdpbiA6IHRoaXMuX21vZGVsLmRhdGFbb2JqLmlkXSA/IHRoaXMgOiAkLmpzdHJlZS5yZWZlcmVuY2Uob2JqLmlkKTtcXG4gICAgICBpc19tdWx0aSA9ICFvbGRfaW5zIHx8ICFvbGRfaW5zLl9pZCB8fCB0aGlzLl9pZCAhPT0gb2xkX2lucy5faWQ7XFxuICAgICAgb2xkX3BvcyA9IG9sZF9pbnMgJiYgb2xkX2lucy5faWQgJiYgb2xkX3BhciAmJiBvbGRfaW5zLl9tb2RlbC5kYXRhW29sZF9wYXJdICYmIG9sZF9pbnMuX21vZGVsLmRhdGFbb2xkX3Bhcl0uY2hpbGRyZW4gPyAkLmluQXJyYXkob2JqLmlkLCBvbGRfaW5zLl9tb2RlbC5kYXRhW29sZF9wYXJdLmNoaWxkcmVuKSA6IC0xO1xcblxcbiAgICAgIGlmIChvbGRfaW5zICYmIG9sZF9pbnMuX2lkKSB7XFxuICAgICAgICBvYmogPSBvbGRfaW5zLl9tb2RlbC5kYXRhW29iai5pZF07XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChpc19tdWx0aSkge1xcbiAgICAgICAgaWYgKHRtcCA9IHRoaXMuY29weV9ub2RlKG9iaiwgcGFyLCBwb3MsIGNhbGxiYWNrLCBpc19sb2FkZWQsIGZhbHNlLCBvcmlnaW4pKSB7XFxuICAgICAgICAgIGlmIChvbGRfaW5zKSB7XFxuICAgICAgICAgICAgb2xkX2lucy5kZWxldGVfbm9kZShvYmopO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHJldHVybiB0bXA7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfSAvL3ZhciBtID0gdGhpcy5fbW9kZWwuZGF0YTtcXG5cXG5cXG4gICAgICBpZiAocGFyLmlkID09PSAkLmpzdHJlZS5yb290KSB7XFxuICAgICAgICBpZiAocG9zID09PSBcXFwiYmVmb3JlXFxcIikge1xcbiAgICAgICAgICBwb3MgPSBcXFwiZmlyc3RcXFwiO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKHBvcyA9PT0gXFxcImFmdGVyXFxcIikge1xcbiAgICAgICAgICBwb3MgPSBcXFwibGFzdFxcXCI7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHN3aXRjaCAocG9zKSB7XFxuICAgICAgICBjYXNlIFxcXCJiZWZvcmVcXFwiOlxcbiAgICAgICAgICBwb3MgPSAkLmluQXJyYXkocGFyLmlkLCBuZXdfcGFyLmNoaWxkcmVuKTtcXG4gICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICBjYXNlIFxcXCJhZnRlclxcXCI6XFxuICAgICAgICAgIHBvcyA9ICQuaW5BcnJheShwYXIuaWQsIG5ld19wYXIuY2hpbGRyZW4pICsgMTtcXG4gICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICBjYXNlIFxcXCJpbnNpZGVcXFwiOlxcbiAgICAgICAgY2FzZSBcXFwiZmlyc3RcXFwiOlxcbiAgICAgICAgICBwb3MgPSAwO1xcbiAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgIGNhc2UgXFxcImxhc3RcXFwiOlxcbiAgICAgICAgICBwb3MgPSBuZXdfcGFyLmNoaWxkcmVuLmxlbmd0aDtcXG4gICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICBkZWZhdWx0OlxcbiAgICAgICAgICBpZiAoIXBvcykge1xcbiAgICAgICAgICAgIHBvcyA9IDA7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChwb3MgPiBuZXdfcGFyLmNoaWxkcmVuLmxlbmd0aCkge1xcbiAgICAgICAgcG9zID0gbmV3X3Bhci5jaGlsZHJlbi5sZW5ndGg7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghdGhpcy5jaGVjayhcXFwibW92ZV9ub2RlXFxcIiwgb2JqLCBuZXdfcGFyLCBwb3MsIHtcXG4gICAgICAgICdjb3JlJzogdHJ1ZSxcXG4gICAgICAgICdvcmlnaW4nOiBvcmlnaW4sXFxuICAgICAgICAnaXNfbXVsdGknOiBvbGRfaW5zICYmIG9sZF9pbnMuX2lkICYmIG9sZF9pbnMuX2lkICE9PSB0aGlzLl9pZCxcXG4gICAgICAgICdpc19mb3JlaWduJzogIW9sZF9pbnMgfHwgIW9sZF9pbnMuX2lkXFxuICAgICAgfSkpIHtcXG4gICAgICAgIHRoaXMuc2V0dGluZ3MuY29yZS5lcnJvci5jYWxsKHRoaXMsIHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yKTtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKG9iai5wYXJlbnQgPT09IG5ld19wYXIuaWQpIHtcXG4gICAgICAgIGRwYyA9IG5ld19wYXIuY2hpbGRyZW4uY29uY2F0KCk7XFxuICAgICAgICB0bXAgPSAkLmluQXJyYXkob2JqLmlkLCBkcGMpO1xcblxcbiAgICAgICAgaWYgKHRtcCAhPT0gLTEpIHtcXG4gICAgICAgICAgZHBjID0gJC52YWthdGEuYXJyYXlfcmVtb3ZlKGRwYywgdG1wKTtcXG5cXG4gICAgICAgICAgaWYgKHBvcyA+IHRtcCkge1xcbiAgICAgICAgICAgIHBvcy0tO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0bXAgPSBbXTtcXG5cXG4gICAgICAgIGZvciAoaSA9IDAsIGogPSBkcGMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICAgIHRtcFtpID49IHBvcyA/IGkgKyAxIDogaV0gPSBkcGNbaV07XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0bXBbcG9zXSA9IG9iai5pZDtcXG4gICAgICAgIG5ld19wYXIuY2hpbGRyZW4gPSB0bXA7XFxuXFxuICAgICAgICB0aGlzLl9ub2RlX2NoYW5nZWQobmV3X3Bhci5pZCk7XFxuXFxuICAgICAgICB0aGlzLnJlZHJhdyhuZXdfcGFyLmlkID09PSAkLmpzdHJlZS5yb290KTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgLy8gY2xlYW4gb2xkIHBhcmVudCBhbmQgdXBcXG4gICAgICAgIHRtcCA9IG9iai5jaGlsZHJlbl9kLmNvbmNhdCgpO1xcbiAgICAgICAgdG1wLnB1c2gob2JqLmlkKTtcXG5cXG4gICAgICAgIGZvciAoaSA9IDAsIGogPSBvYmoucGFyZW50cy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG4gICAgICAgICAgZHBjID0gW107XFxuICAgICAgICAgIHAgPSBvbGRfaW5zLl9tb2RlbC5kYXRhW29iai5wYXJlbnRzW2ldXS5jaGlsZHJlbl9kO1xcblxcbiAgICAgICAgICBmb3IgKGsgPSAwLCBsID0gcC5sZW5ndGg7IGsgPCBsOyBrKyspIHtcXG4gICAgICAgICAgICBpZiAoJC5pbkFycmF5KHBba10sIHRtcCkgPT09IC0xKSB7XFxuICAgICAgICAgICAgICBkcGMucHVzaChwW2tdKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgb2xkX2lucy5fbW9kZWwuZGF0YVtvYmoucGFyZW50c1tpXV0uY2hpbGRyZW5fZCA9IGRwYztcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIG9sZF9pbnMuX21vZGVsLmRhdGFbb2xkX3Bhcl0uY2hpbGRyZW4gPSAkLnZha2F0YS5hcnJheV9yZW1vdmVfaXRlbShvbGRfaW5zLl9tb2RlbC5kYXRhW29sZF9wYXJdLmNoaWxkcmVuLCBvYmouaWQpOyAvLyBpbnNlcnQgaW50byBuZXcgcGFyZW50IGFuZCB1cFxcblxcbiAgICAgICAgZm9yIChpID0gMCwgaiA9IG5ld19wYXIucGFyZW50cy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG4gICAgICAgICAgdGhpcy5fbW9kZWwuZGF0YVtuZXdfcGFyLnBhcmVudHNbaV1dLmNoaWxkcmVuX2QgPSB0aGlzLl9tb2RlbC5kYXRhW25ld19wYXIucGFyZW50c1tpXV0uY2hpbGRyZW5fZC5jb25jYXQodG1wKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGRwYyA9IFtdO1xcblxcbiAgICAgICAgZm9yIChpID0gMCwgaiA9IG5ld19wYXIuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICAgIGRwY1tpID49IHBvcyA/IGkgKyAxIDogaV0gPSBuZXdfcGFyLmNoaWxkcmVuW2ldO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZHBjW3Bvc10gPSBvYmouaWQ7XFxuICAgICAgICBuZXdfcGFyLmNoaWxkcmVuID0gZHBjO1xcbiAgICAgICAgbmV3X3Bhci5jaGlsZHJlbl9kLnB1c2gob2JqLmlkKTtcXG4gICAgICAgIG5ld19wYXIuY2hpbGRyZW5fZCA9IG5ld19wYXIuY2hpbGRyZW5fZC5jb25jYXQob2JqLmNoaWxkcmVuX2QpOyAvLyB1cGRhdGUgb2JqZWN0XFxuXFxuICAgICAgICBvYmoucGFyZW50ID0gbmV3X3Bhci5pZDtcXG4gICAgICAgIHRtcCA9IG5ld19wYXIucGFyZW50cy5jb25jYXQoKTtcXG4gICAgICAgIHRtcC51bnNoaWZ0KG5ld19wYXIuaWQpO1xcbiAgICAgICAgcCA9IG9iai5wYXJlbnRzLmxlbmd0aDtcXG4gICAgICAgIG9iai5wYXJlbnRzID0gdG1wOyAvLyB1cGRhdGUgb2JqZWN0IGNoaWxkcmVuXFxuXFxuICAgICAgICB0bXAgPSB0bXAuY29uY2F0KCk7XFxuXFxuICAgICAgICBmb3IgKGkgPSAwLCBqID0gb2JqLmNoaWxkcmVuX2QubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICAgIHRoaXMuX21vZGVsLmRhdGFbb2JqLmNoaWxkcmVuX2RbaV1dLnBhcmVudHMgPSB0aGlzLl9tb2RlbC5kYXRhW29iai5jaGlsZHJlbl9kW2ldXS5wYXJlbnRzLnNsaWNlKDAsIHAgKiAtMSk7XFxuICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHRoaXMuX21vZGVsLmRhdGFbb2JqLmNoaWxkcmVuX2RbaV1dLnBhcmVudHMsIHRtcCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAob2xkX3BhciA9PT0gJC5qc3RyZWUucm9vdCB8fCBuZXdfcGFyLmlkID09PSAkLmpzdHJlZS5yb290KSB7XFxuICAgICAgICAgIHRoaXMuX21vZGVsLmZvcmNlX2Z1bGxfcmVkcmF3ID0gdHJ1ZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICghdGhpcy5fbW9kZWwuZm9yY2VfZnVsbF9yZWRyYXcpIHtcXG4gICAgICAgICAgdGhpcy5fbm9kZV9jaGFuZ2VkKG9sZF9wYXIpO1xcblxcbiAgICAgICAgICB0aGlzLl9ub2RlX2NoYW5nZWQobmV3X3Bhci5pZCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoIXNraXBfcmVkcmF3KSB7XFxuICAgICAgICAgIHRoaXMucmVkcmF3KCk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChjYWxsYmFjaykge1xcbiAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCBvYmosIG5ld19wYXIsIHBvcyk7XFxuICAgICAgfVxcbiAgICAgIC8qKlxcbiAgICAgICAqIHRyaWdnZXJlZCB3aGVuIGEgbm9kZSBpcyBtb3ZlZFxcbiAgICAgICAqIEBldmVudFxcbiAgICAgICAqIEBuYW1lIG1vdmVfbm9kZS5qc3RyZWVcXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZVxcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJlbnQgdGhlIHBhcmVudCdzIElEXFxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uIHRoZSBwb3NpdGlvbiBvZiB0aGUgbm9kZSBhbW9uZyB0aGUgcGFyZW50J3MgY2hpbGRyZW5cXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkX3BhcmVudCB0aGUgb2xkIHBhcmVudCBvZiB0aGUgbm9kZVxcbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRfcG9zaXRpb24gdGhlIG9sZCBwb3NpdGlvbiBvZiB0aGUgbm9kZVxcbiAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNfbXVsdGkgZG8gdGhlIG5vZGUgYW5kIG5ldyBwYXJlbnQgYmVsb25nIHRvIGRpZmZlcmVudCBpbnN0YW5jZXNcXG4gICAgICAgKiBAcGFyYW0ge2pzVHJlZX0gb2xkX2luc3RhbmNlIHRoZSBpbnN0YW5jZSB0aGUgbm9kZSBjYW1lIGZyb21cXG4gICAgICAgKiBAcGFyYW0ge2pzVHJlZX0gbmV3X2luc3RhbmNlIHRoZSBpbnN0YW5jZSBvZiB0aGUgbmV3IHBhcmVudFxcbiAgICAgICAqL1xcblxcblxcbiAgICAgIHRoaXMudHJpZ2dlcignbW92ZV9ub2RlJywge1xcbiAgICAgICAgXFxcIm5vZGVcXFwiOiBvYmosXFxuICAgICAgICBcXFwicGFyZW50XFxcIjogbmV3X3Bhci5pZCxcXG4gICAgICAgIFxcXCJwb3NpdGlvblxcXCI6IHBvcyxcXG4gICAgICAgIFxcXCJvbGRfcGFyZW50XFxcIjogb2xkX3BhcixcXG4gICAgICAgIFxcXCJvbGRfcG9zaXRpb25cXFwiOiBvbGRfcG9zLFxcbiAgICAgICAgJ2lzX211bHRpJzogb2xkX2lucyAmJiBvbGRfaW5zLl9pZCAmJiBvbGRfaW5zLl9pZCAhPT0gdGhpcy5faWQsXFxuICAgICAgICAnaXNfZm9yZWlnbic6ICFvbGRfaW5zIHx8ICFvbGRfaW5zLl9pZCxcXG4gICAgICAgICdvbGRfaW5zdGFuY2UnOiBvbGRfaW5zLFxcbiAgICAgICAgJ25ld19pbnN0YW5jZSc6IHRoaXNcXG4gICAgICB9KTtcXG4gICAgICByZXR1cm4gb2JqLmlkO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogY29weSBhIG5vZGUgdG8gYSBuZXcgcGFyZW50XFxuICAgICAqIEBuYW1lIGNvcHlfbm9kZShvYmosIHBhciBbLCBwb3MsIGNhbGxiYWNrLCBpc19sb2FkZWRdKVxcbiAgICAgKiBAcGFyYW0gIHttaXhlZH0gb2JqIHRoZSBub2RlIHRvIGNvcHksIHBhc3MgYW4gYXJyYXkgdG8gY29weSBtdWx0aXBsZSBub2Rlc1xcbiAgICAgKiBAcGFyYW0gIHttaXhlZH0gcGFyIHRoZSBuZXcgcGFyZW50XFxuICAgICAqIEBwYXJhbSAge21peGVkfSBwb3MgdGhlIHBvc2l0aW9uIHRvIGluc2VydCBhdCAoYmVzaWRlcyBpbnRlZ2VyIHZhbHVlcywgXFxcImZpcnN0XFxcIiBhbmQgXFxcImxhc3RcXFwiIGFyZSBzdXBwb3J0ZWQsIGFzIHdlbGwgYXMgXFxcImJlZm9yZVxcXCIgYW5kIFxcXCJhZnRlclxcXCIpLCBkZWZhdWx0cyB0byBpbnRlZ2VyIGAwYFxcbiAgICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gY2FsbGJhY2sgYSBmdW5jdGlvbiB0byBjYWxsIG9uY2UgdGhlIG1vdmUgaXMgY29tcGxldGVkLCByZWNlaXZlcyAzIGFyZ3VtZW50cyAtIHRoZSBub2RlLCB0aGUgbmV3IHBhcmVudCBhbmQgdGhlIHBvc2l0aW9uXFxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IGlzX2xvYWRlZCBpbnRlcm5hbCBwYXJhbWV0ZXIgaW5kaWNhdGluZyBpZiB0aGUgcGFyZW50IG5vZGUgaGFzIGJlZW4gbG9hZGVkXFxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IHNraXBfcmVkcmF3IGludGVybmFsIHBhcmFtZXRlciBpbmRpY2F0aW5nIGlmIHRoZSB0cmVlIHNob3VsZCBiZSByZWRyYXduXFxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IGluc3RhbmNlIGludGVybmFsIHBhcmFtZXRlciBpbmRpY2F0aW5nIGlmIHRoZSBub2RlIGNvbWVzIGZyb20gYW5vdGhlciBpbnN0YW5jZVxcbiAgICAgKiBAdHJpZ2dlciBtb2RlbC5qc3RyZWUgY29weV9ub2RlLmpzdHJlZVxcbiAgICAgKi9cXG4gICAgY29weV9ub2RlOiBmdW5jdGlvbiBjb3B5X25vZGUob2JqLCBwYXIsIHBvcywgY2FsbGJhY2ssIGlzX2xvYWRlZCwgc2tpcF9yZWRyYXcsIG9yaWdpbikge1xcbiAgICAgIHZhciB0MSwgdDIsIGRwYywgdG1wLCBpLCBqLCBub2RlLCBvbGRfcGFyLCBuZXdfcGFyLCBvbGRfaW5zLCBpc19tdWx0aTtcXG4gICAgICBwYXIgPSB0aGlzLmdldF9ub2RlKHBhcik7XFxuICAgICAgcG9zID0gcG9zID09PSB1bmRlZmluZWQgPyAwIDogcG9zO1xcblxcbiAgICAgIGlmICghcGFyKSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghcG9zLnRvU3RyaW5nKCkubWF0Y2goL14oYmVmb3JlfGFmdGVyKSQvKSAmJiAhaXNfbG9hZGVkICYmICF0aGlzLmlzX2xvYWRlZChwYXIpKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5sb2FkX25vZGUocGFyLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHRoaXMuY29weV9ub2RlKG9iaiwgcGFyLCBwb3MsIGNhbGxiYWNrLCB0cnVlLCBmYWxzZSwgb3JpZ2luKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoJC5pc0FycmF5KG9iaikpIHtcXG4gICAgICAgIGlmIChvYmoubGVuZ3RoID09PSAxKSB7XFxuICAgICAgICAgIG9iaiA9IG9ialswXTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIC8vb2JqID0gb2JqLnNsaWNlKCk7XFxuICAgICAgICAgIGZvciAodDEgPSAwLCB0MiA9IG9iai5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcXG4gICAgICAgICAgICBpZiAodG1wID0gdGhpcy5jb3B5X25vZGUob2JqW3QxXSwgcGFyLCBwb3MsIGNhbGxiYWNrLCBpc19sb2FkZWQsIHRydWUsIG9yaWdpbikpIHtcXG4gICAgICAgICAgICAgIHBhciA9IHRtcDtcXG4gICAgICAgICAgICAgIHBvcyA9IFxcXCJhZnRlclxcXCI7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHRoaXMucmVkcmF3KCk7XFxuICAgICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBvYmogPSBvYmogJiYgb2JqLmlkID8gb2JqIDogdGhpcy5nZXRfbm9kZShvYmopO1xcblxcbiAgICAgIGlmICghb2JqIHx8IG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCkge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICBvbGRfcGFyID0gKG9iai5wYXJlbnQgfHwgJC5qc3RyZWUucm9vdCkudG9TdHJpbmcoKTtcXG4gICAgICBuZXdfcGFyID0gIXBvcy50b1N0cmluZygpLm1hdGNoKC9eKGJlZm9yZXxhZnRlcikkLykgfHwgcGFyLmlkID09PSAkLmpzdHJlZS5yb290ID8gcGFyIDogdGhpcy5nZXRfbm9kZShwYXIucGFyZW50KTtcXG4gICAgICBvbGRfaW5zID0gb3JpZ2luID8gb3JpZ2luIDogdGhpcy5fbW9kZWwuZGF0YVtvYmouaWRdID8gdGhpcyA6ICQuanN0cmVlLnJlZmVyZW5jZShvYmouaWQpO1xcbiAgICAgIGlzX211bHRpID0gIW9sZF9pbnMgfHwgIW9sZF9pbnMuX2lkIHx8IHRoaXMuX2lkICE9PSBvbGRfaW5zLl9pZDtcXG5cXG4gICAgICBpZiAob2xkX2lucyAmJiBvbGRfaW5zLl9pZCkge1xcbiAgICAgICAgb2JqID0gb2xkX2lucy5fbW9kZWwuZGF0YVtvYmouaWRdO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAocGFyLmlkID09PSAkLmpzdHJlZS5yb290KSB7XFxuICAgICAgICBpZiAocG9zID09PSBcXFwiYmVmb3JlXFxcIikge1xcbiAgICAgICAgICBwb3MgPSBcXFwiZmlyc3RcXFwiO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKHBvcyA9PT0gXFxcImFmdGVyXFxcIikge1xcbiAgICAgICAgICBwb3MgPSBcXFwibGFzdFxcXCI7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHN3aXRjaCAocG9zKSB7XFxuICAgICAgICBjYXNlIFxcXCJiZWZvcmVcXFwiOlxcbiAgICAgICAgICBwb3MgPSAkLmluQXJyYXkocGFyLmlkLCBuZXdfcGFyLmNoaWxkcmVuKTtcXG4gICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICBjYXNlIFxcXCJhZnRlclxcXCI6XFxuICAgICAgICAgIHBvcyA9ICQuaW5BcnJheShwYXIuaWQsIG5ld19wYXIuY2hpbGRyZW4pICsgMTtcXG4gICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICBjYXNlIFxcXCJpbnNpZGVcXFwiOlxcbiAgICAgICAgY2FzZSBcXFwiZmlyc3RcXFwiOlxcbiAgICAgICAgICBwb3MgPSAwO1xcbiAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgIGNhc2UgXFxcImxhc3RcXFwiOlxcbiAgICAgICAgICBwb3MgPSBuZXdfcGFyLmNoaWxkcmVuLmxlbmd0aDtcXG4gICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICBkZWZhdWx0OlxcbiAgICAgICAgICBpZiAoIXBvcykge1xcbiAgICAgICAgICAgIHBvcyA9IDA7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChwb3MgPiBuZXdfcGFyLmNoaWxkcmVuLmxlbmd0aCkge1xcbiAgICAgICAgcG9zID0gbmV3X3Bhci5jaGlsZHJlbi5sZW5ndGg7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghdGhpcy5jaGVjayhcXFwiY29weV9ub2RlXFxcIiwgb2JqLCBuZXdfcGFyLCBwb3MsIHtcXG4gICAgICAgICdjb3JlJzogdHJ1ZSxcXG4gICAgICAgICdvcmlnaW4nOiBvcmlnaW4sXFxuICAgICAgICAnaXNfbXVsdGknOiBvbGRfaW5zICYmIG9sZF9pbnMuX2lkICYmIG9sZF9pbnMuX2lkICE9PSB0aGlzLl9pZCxcXG4gICAgICAgICdpc19mb3JlaWduJzogIW9sZF9pbnMgfHwgIW9sZF9pbnMuX2lkXFxuICAgICAgfSkpIHtcXG4gICAgICAgIHRoaXMuc2V0dGluZ3MuY29yZS5lcnJvci5jYWxsKHRoaXMsIHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yKTtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgbm9kZSA9IG9sZF9pbnMgPyBvbGRfaW5zLmdldF9qc29uKG9iaiwge1xcbiAgICAgICAgbm9faWQ6IHRydWUsXFxuICAgICAgICBub19kYXRhOiB0cnVlLFxcbiAgICAgICAgbm9fc3RhdGU6IHRydWVcXG4gICAgICB9KSA6IG9iajtcXG5cXG4gICAgICBpZiAoIW5vZGUpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKG5vZGUuaWQgPT09IHRydWUpIHtcXG4gICAgICAgIGRlbGV0ZSBub2RlLmlkO1xcbiAgICAgIH1cXG5cXG4gICAgICBub2RlID0gdGhpcy5fcGFyc2VfbW9kZWxfZnJvbV9qc29uKG5vZGUsIG5ld19wYXIuaWQsIG5ld19wYXIucGFyZW50cy5jb25jYXQoKSk7XFxuXFxuICAgICAgaWYgKCFub2RlKSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcblxcbiAgICAgIHRtcCA9IHRoaXMuZ2V0X25vZGUobm9kZSk7XFxuXFxuICAgICAgaWYgKG9iaiAmJiBvYmouc3RhdGUgJiYgb2JqLnN0YXRlLmxvYWRlZCA9PT0gZmFsc2UpIHtcXG4gICAgICAgIHRtcC5zdGF0ZS5sb2FkZWQgPSBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgZHBjID0gW107XFxuICAgICAgZHBjLnB1c2gobm9kZSk7XFxuICAgICAgZHBjID0gZHBjLmNvbmNhdCh0bXAuY2hpbGRyZW5fZCk7XFxuICAgICAgdGhpcy50cmlnZ2VyKCdtb2RlbCcsIHtcXG4gICAgICAgIFxcXCJub2Rlc1xcXCI6IGRwYyxcXG4gICAgICAgIFxcXCJwYXJlbnRcXFwiOiBuZXdfcGFyLmlkXFxuICAgICAgfSk7IC8vIGluc2VydCBpbnRvIG5ldyBwYXJlbnQgYW5kIHVwXFxuXFxuICAgICAgZm9yIChpID0gMCwgaiA9IG5ld19wYXIucGFyZW50cy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG4gICAgICAgIHRoaXMuX21vZGVsLmRhdGFbbmV3X3Bhci5wYXJlbnRzW2ldXS5jaGlsZHJlbl9kID0gdGhpcy5fbW9kZWwuZGF0YVtuZXdfcGFyLnBhcmVudHNbaV1dLmNoaWxkcmVuX2QuY29uY2F0KGRwYyk7XFxuICAgICAgfVxcblxcbiAgICAgIGRwYyA9IFtdO1xcblxcbiAgICAgIGZvciAoaSA9IDAsIGogPSBuZXdfcGFyLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcbiAgICAgICAgZHBjW2kgPj0gcG9zID8gaSArIDEgOiBpXSA9IG5ld19wYXIuY2hpbGRyZW5baV07XFxuICAgICAgfVxcblxcbiAgICAgIGRwY1twb3NdID0gdG1wLmlkO1xcbiAgICAgIG5ld19wYXIuY2hpbGRyZW4gPSBkcGM7XFxuICAgICAgbmV3X3Bhci5jaGlsZHJlbl9kLnB1c2godG1wLmlkKTtcXG4gICAgICBuZXdfcGFyLmNoaWxkcmVuX2QgPSBuZXdfcGFyLmNoaWxkcmVuX2QuY29uY2F0KHRtcC5jaGlsZHJlbl9kKTtcXG5cXG4gICAgICBpZiAobmV3X3Bhci5pZCA9PT0gJC5qc3RyZWUucm9vdCkge1xcbiAgICAgICAgdGhpcy5fbW9kZWwuZm9yY2VfZnVsbF9yZWRyYXcgPSB0cnVlO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIXRoaXMuX21vZGVsLmZvcmNlX2Z1bGxfcmVkcmF3KSB7XFxuICAgICAgICB0aGlzLl9ub2RlX2NoYW5nZWQobmV3X3Bhci5pZCk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghc2tpcF9yZWRyYXcpIHtcXG4gICAgICAgIHRoaXMucmVkcmF3KG5ld19wYXIuaWQgPT09ICQuanN0cmVlLnJvb3QpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoY2FsbGJhY2spIHtcXG4gICAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgdG1wLCBuZXdfcGFyLCBwb3MpO1xcbiAgICAgIH1cXG4gICAgICAvKipcXG4gICAgICAgKiB0cmlnZ2VyZWQgd2hlbiBhIG5vZGUgaXMgY29waWVkXFxuICAgICAgICogQGV2ZW50XFxuICAgICAgICogQG5hbWUgY29weV9ub2RlLmpzdHJlZVxcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIHRoZSBjb3BpZWQgbm9kZVxcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcmlnaW5hbCB0aGUgb3JpZ2luYWwgbm9kZVxcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJlbnQgdGhlIHBhcmVudCdzIElEXFxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uIHRoZSBwb3NpdGlvbiBvZiB0aGUgbm9kZSBhbW9uZyB0aGUgcGFyZW50J3MgY2hpbGRyZW5cXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkX3BhcmVudCB0aGUgb2xkIHBhcmVudCBvZiB0aGUgbm9kZVxcbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRfcG9zaXRpb24gdGhlIHBvc2l0aW9uIG9mIHRoZSBvcmlnaW5hbCBub2RlXFxuICAgICAgICogQHBhcmFtIHtCb29sZWFufSBpc19tdWx0aSBkbyB0aGUgbm9kZSBhbmQgbmV3IHBhcmVudCBiZWxvbmcgdG8gZGlmZmVyZW50IGluc3RhbmNlc1xcbiAgICAgICAqIEBwYXJhbSB7anNUcmVlfSBvbGRfaW5zdGFuY2UgdGhlIGluc3RhbmNlIHRoZSBub2RlIGNhbWUgZnJvbVxcbiAgICAgICAqIEBwYXJhbSB7anNUcmVlfSBuZXdfaW5zdGFuY2UgdGhlIGluc3RhbmNlIG9mIHRoZSBuZXcgcGFyZW50XFxuICAgICAgICovXFxuXFxuXFxuICAgICAgdGhpcy50cmlnZ2VyKCdjb3B5X25vZGUnLCB7XFxuICAgICAgICBcXFwibm9kZVxcXCI6IHRtcCxcXG4gICAgICAgIFxcXCJvcmlnaW5hbFxcXCI6IG9iaixcXG4gICAgICAgIFxcXCJwYXJlbnRcXFwiOiBuZXdfcGFyLmlkLFxcbiAgICAgICAgXFxcInBvc2l0aW9uXFxcIjogcG9zLFxcbiAgICAgICAgXFxcIm9sZF9wYXJlbnRcXFwiOiBvbGRfcGFyLFxcbiAgICAgICAgXFxcIm9sZF9wb3NpdGlvblxcXCI6IG9sZF9pbnMgJiYgb2xkX2lucy5faWQgJiYgb2xkX3BhciAmJiBvbGRfaW5zLl9tb2RlbC5kYXRhW29sZF9wYXJdICYmIG9sZF9pbnMuX21vZGVsLmRhdGFbb2xkX3Bhcl0uY2hpbGRyZW4gPyAkLmluQXJyYXkob2JqLmlkLCBvbGRfaW5zLl9tb2RlbC5kYXRhW29sZF9wYXJdLmNoaWxkcmVuKSA6IC0xLFxcbiAgICAgICAgJ2lzX211bHRpJzogb2xkX2lucyAmJiBvbGRfaW5zLl9pZCAmJiBvbGRfaW5zLl9pZCAhPT0gdGhpcy5faWQsXFxuICAgICAgICAnaXNfZm9yZWlnbic6ICFvbGRfaW5zIHx8ICFvbGRfaW5zLl9pZCxcXG4gICAgICAgICdvbGRfaW5zdGFuY2UnOiBvbGRfaW5zLFxcbiAgICAgICAgJ25ld19pbnN0YW5jZSc6IHRoaXNcXG4gICAgICB9KTtcXG4gICAgICByZXR1cm4gdG1wLmlkO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogY3V0IGEgbm9kZSAoYSBsYXRlciBjYWxsIHRvIGBwYXN0ZShvYmopYCB3b3VsZCBtb3ZlIHRoZSBub2RlKVxcbiAgICAgKiBAbmFtZSBjdXQob2JqKVxcbiAgICAgKiBAcGFyYW0gIHttaXhlZH0gb2JqIG11bHRpcGxlIG9iamVjdHMgY2FuIGJlIHBhc3NlZCB1c2luZyBhbiBhcnJheVxcbiAgICAgKiBAdHJpZ2dlciBjdXQuanN0cmVlXFxuICAgICAqL1xcbiAgICBjdXQ6IGZ1bmN0aW9uIGN1dChvYmopIHtcXG4gICAgICBpZiAoIW9iaikge1xcbiAgICAgICAgb2JqID0gdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLmNvbmNhdCgpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoISQuaXNBcnJheShvYmopKSB7XFxuICAgICAgICBvYmogPSBbb2JqXTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCFvYmoubGVuZ3RoKSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciB0bXAgPSBbXSxcXG4gICAgICAgICAgbyxcXG4gICAgICAgICAgdDEsXFxuICAgICAgICAgIHQyO1xcblxcbiAgICAgIGZvciAodDEgPSAwLCB0MiA9IG9iai5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcXG4gICAgICAgIG8gPSB0aGlzLmdldF9ub2RlKG9ialt0MV0pO1xcblxcbiAgICAgICAgaWYgKG8gJiYgby5pZCAmJiBvLmlkICE9PSAkLmpzdHJlZS5yb290KSB7XFxuICAgICAgICAgIHRtcC5wdXNoKG8pO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIXRtcC5sZW5ndGgpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgY2NwX25vZGUgPSB0bXA7XFxuICAgICAgY2NwX2luc3QgPSB0aGlzO1xcbiAgICAgIGNjcF9tb2RlID0gJ21vdmVfbm9kZSc7XFxuICAgICAgLyoqXFxuICAgICAgICogdHJpZ2dlcmVkIHdoZW4gbm9kZXMgYXJlIGFkZGVkIHRvIHRoZSBidWZmZXIgZm9yIG1vdmluZ1xcbiAgICAgICAqIEBldmVudFxcbiAgICAgICAqIEBuYW1lIGN1dC5qc3RyZWVcXG4gICAgICAgKiBAcGFyYW0ge0FycmF5fSBub2RlXFxuICAgICAgICovXFxuXFxuICAgICAgdGhpcy50cmlnZ2VyKCdjdXQnLCB7XFxuICAgICAgICBcXFwibm9kZVxcXCI6IG9ialxcbiAgICAgIH0pO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogY29weSBhIG5vZGUgKGEgbGF0ZXIgY2FsbCB0byBgcGFzdGUob2JqKWAgd291bGQgY29weSB0aGUgbm9kZSlcXG4gICAgICogQG5hbWUgY29weShvYmopXFxuICAgICAqIEBwYXJhbSAge21peGVkfSBvYmogbXVsdGlwbGUgb2JqZWN0cyBjYW4gYmUgcGFzc2VkIHVzaW5nIGFuIGFycmF5XFxuICAgICAqIEB0cmlnZ2VyIGNvcHkuanN0cmVlXFxuICAgICAqL1xcbiAgICBjb3B5OiBmdW5jdGlvbiBjb3B5KG9iaikge1xcbiAgICAgIGlmICghb2JqKSB7XFxuICAgICAgICBvYmogPSB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQuY29uY2F0KCk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghJC5pc0FycmF5KG9iaikpIHtcXG4gICAgICAgIG9iaiA9IFtvYmpdO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIW9iai5sZW5ndGgpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIHRtcCA9IFtdLFxcbiAgICAgICAgICBvLFxcbiAgICAgICAgICB0MSxcXG4gICAgICAgICAgdDI7XFxuXFxuICAgICAgZm9yICh0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xcbiAgICAgICAgbyA9IHRoaXMuZ2V0X25vZGUob2JqW3QxXSk7XFxuXFxuICAgICAgICBpZiAobyAmJiBvLmlkICYmIG8uaWQgIT09ICQuanN0cmVlLnJvb3QpIHtcXG4gICAgICAgICAgdG1wLnB1c2gobyk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghdG1wLmxlbmd0aCkge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICBjY3Bfbm9kZSA9IHRtcDtcXG4gICAgICBjY3BfaW5zdCA9IHRoaXM7XFxuICAgICAgY2NwX21vZGUgPSAnY29weV9ub2RlJztcXG4gICAgICAvKipcXG4gICAgICAgKiB0cmlnZ2VyZWQgd2hlbiBub2RlcyBhcmUgYWRkZWQgdG8gdGhlIGJ1ZmZlciBmb3IgY29weWluZ1xcbiAgICAgICAqIEBldmVudFxcbiAgICAgICAqIEBuYW1lIGNvcHkuanN0cmVlXFxuICAgICAgICogQHBhcmFtIHtBcnJheX0gbm9kZVxcbiAgICAgICAqL1xcblxcbiAgICAgIHRoaXMudHJpZ2dlcignY29weScsIHtcXG4gICAgICAgIFxcXCJub2RlXFxcIjogb2JqXFxuICAgICAgfSk7XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBnZXQgdGhlIGN1cnJlbnQgYnVmZmVyIChhbnkgbm9kZXMgdGhhdCBhcmUgd2FpdGluZyBmb3IgYSBwYXN0ZSBvcGVyYXRpb24pXFxuICAgICAqIEBuYW1lIGdldF9idWZmZXIoKVxcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGFuIG9iamVjdCBjb25zaXN0aW5nIG9mIGBtb2RlYCAoXFxcImNvcHlfbm9kZVxcXCIgb3IgXFxcIm1vdmVfbm9kZVxcXCIpLCBgbm9kZWAgKGFuIGFycmF5IG9mIG9iamVjdHMpIGFuZCBgaW5zdGAgKHRoZSBpbnN0YW5jZSlcXG4gICAgICovXFxuICAgIGdldF9idWZmZXI6IGZ1bmN0aW9uIGdldF9idWZmZXIoKSB7XFxuICAgICAgcmV0dXJuIHtcXG4gICAgICAgICdtb2RlJzogY2NwX21vZGUsXFxuICAgICAgICAnbm9kZSc6IGNjcF9ub2RlLFxcbiAgICAgICAgJ2luc3QnOiBjY3BfaW5zdFxcbiAgICAgIH07XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBjaGVjayBpZiB0aGVyZSBpcyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB0byBwYXN0ZVxcbiAgICAgKiBAbmFtZSBjYW5fcGFzdGUoKVxcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxcbiAgICAgKi9cXG4gICAgY2FuX3Bhc3RlOiBmdW5jdGlvbiBjYW5fcGFzdGUoKSB7XFxuICAgICAgcmV0dXJuIGNjcF9tb2RlICE9PSBmYWxzZSAmJiBjY3Bfbm9kZSAhPT0gZmFsc2U7IC8vICYmIGNjcF9pbnN0Ll9tb2RlbC5kYXRhW2NjcF9ub2RlXTtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIGNvcHkgb3IgbW92ZSB0aGUgcHJldmlvdXNseSBjdXQgb3IgY29waWVkIG5vZGVzIHRvIGEgbmV3IHBhcmVudFxcbiAgICAgKiBAbmFtZSBwYXN0ZShvYmogWywgcG9zXSlcXG4gICAgICogQHBhcmFtICB7bWl4ZWR9IG9iaiB0aGUgbmV3IHBhcmVudFxcbiAgICAgKiBAcGFyYW0gIHttaXhlZH0gcG9zIHRoZSBwb3NpdGlvbiB0byBpbnNlcnQgYXQgKGJlc2lkZXMgaW50ZWdlciwgXFxcImZpcnN0XFxcIiBhbmQgXFxcImxhc3RcXFwiIGFyZSBzdXBwb3J0ZWQpLCBkZWZhdWx0cyB0byBpbnRlZ2VyIGAwYFxcbiAgICAgKiBAdHJpZ2dlciBwYXN0ZS5qc3RyZWVcXG4gICAgICovXFxuICAgIHBhc3RlOiBmdW5jdGlvbiBwYXN0ZShvYmosIHBvcykge1xcbiAgICAgIG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXG4gICAgICBpZiAoIW9iaiB8fCAhY2NwX21vZGUgfHwgIWNjcF9tb2RlLm1hdGNoKC9eKGNvcHlfbm9kZXxtb3ZlX25vZGUpJC8pIHx8ICFjY3Bfbm9kZSkge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpc1tjY3BfbW9kZV0oY2NwX25vZGUsIG9iaiwgcG9zLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBjY3BfaW5zdCkpIHtcXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogdHJpZ2dlcmVkIHdoZW4gcGFzdGUgaXMgaW52b2tlZFxcbiAgICAgICAgICogQGV2ZW50XFxuICAgICAgICAgKiBAbmFtZSBwYXN0ZS5qc3RyZWVcXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJlbnQgdGhlIElEIG9mIHRoZSByZWNlaXZpbmcgbm9kZVxcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gbm9kZSB0aGUgbm9kZXMgaW4gdGhlIGJ1ZmZlclxcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG1vZGUgdGhlIHBlcmZvcm1lZCBvcGVyYXRpb24gLSBcXFwiY29weV9ub2RlXFxcIiBvciBcXFwibW92ZV9ub2RlXFxcIlxcbiAgICAgICAgICovXFxuICAgICAgICB0aGlzLnRyaWdnZXIoJ3Bhc3RlJywge1xcbiAgICAgICAgICBcXFwicGFyZW50XFxcIjogb2JqLmlkLFxcbiAgICAgICAgICBcXFwibm9kZVxcXCI6IGNjcF9ub2RlLFxcbiAgICAgICAgICBcXFwibW9kZVxcXCI6IGNjcF9tb2RlXFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuXFxuICAgICAgY2NwX25vZGUgPSBmYWxzZTtcXG4gICAgICBjY3BfbW9kZSA9IGZhbHNlO1xcbiAgICAgIGNjcF9pbnN0ID0gZmFsc2U7XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBjbGVhciB0aGUgYnVmZmVyIG9mIHByZXZpb3VzbHkgY29waWVkIG9yIGN1dCBub2Rlc1xcbiAgICAgKiBAbmFtZSBjbGVhcl9idWZmZXIoKVxcbiAgICAgKiBAdHJpZ2dlciBjbGVhcl9idWZmZXIuanN0cmVlXFxuICAgICAqL1xcbiAgICBjbGVhcl9idWZmZXI6IGZ1bmN0aW9uIGNsZWFyX2J1ZmZlcigpIHtcXG4gICAgICBjY3Bfbm9kZSA9IGZhbHNlO1xcbiAgICAgIGNjcF9tb2RlID0gZmFsc2U7XFxuICAgICAgY2NwX2luc3QgPSBmYWxzZTtcXG4gICAgICAvKipcXG4gICAgICAgKiB0cmlnZ2VyZWQgd2hlbiB0aGUgY29weSAvIGN1dCBidWZmZXIgaXMgY2xlYXJlZFxcbiAgICAgICAqIEBldmVudFxcbiAgICAgICAqIEBuYW1lIGNsZWFyX2J1ZmZlci5qc3RyZWVcXG4gICAgICAgKi9cXG5cXG4gICAgICB0aGlzLnRyaWdnZXIoJ2NsZWFyX2J1ZmZlcicpO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogcHV0IGEgbm9kZSBpbiBlZGl0IG1vZGUgKGlucHV0IGZpZWxkIHRvIHJlbmFtZSB0aGUgbm9kZSlcXG4gICAgICogQG5hbWUgZWRpdChvYmogWywgZGVmYXVsdF90ZXh0LCBjYWxsYmFja10pXFxuICAgICAqIEBwYXJhbSAge21peGVkfSBvYmpcXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBkZWZhdWx0X3RleHQgdGhlIHRleHQgdG8gcG9wdWxhdGUgdGhlIGlucHV0IHdpdGggKGlmIG9taXR0ZWQgb3Igc2V0IHRvIGEgbm9uLXN0cmluZyB2YWx1ZSB0aGUgbm9kZSdzIHRleHQgdmFsdWUgaXMgdXNlZClcXG4gICAgICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrIGEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uY2UgdGhlIHRleHQgYm94IGlzIGJsdXJyZWQsIGl0IGlzIGNhbGxlZCBpbiB0aGUgaW5zdGFuY2UncyBzY29wZSBhbmQgcmVjZWl2ZXMgdGhlIG5vZGUsIGEgc3RhdHVzIHBhcmFtZXRlciAodHJ1ZSBpZiB0aGUgcmVuYW1lIGlzIHN1Y2Nlc3NmdWwsIGZhbHNlIG90aGVyd2lzZSkgYW5kIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoZSB1c2VyIGNhbmNlbGxlZCB0aGUgZWRpdC4gWW91IGNhbiBhY2Nlc3MgdGhlIG5vZGUncyB0aXRsZSB1c2luZyAudGV4dFxcbiAgICAgKi9cXG4gICAgZWRpdDogZnVuY3Rpb24gZWRpdChvYmosIGRlZmF1bHRfdGV4dCwgY2FsbGJhY2spIHtcXG4gICAgICB2YXIgcnRsLFxcbiAgICAgICAgICB3LFxcbiAgICAgICAgICBhLFxcbiAgICAgICAgICBzLFxcbiAgICAgICAgICB0LFxcbiAgICAgICAgICBoMSxcXG4gICAgICAgICAgaDIsXFxuICAgICAgICAgIGZuLFxcbiAgICAgICAgICB0bXAsXFxuICAgICAgICAgIGNhbmNlbCA9IGZhbHNlO1xcbiAgICAgIG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXG4gICAgICBpZiAoIW9iaikge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5jb3JlLmNoZWNrX2NhbGxiYWNrID09PSBmYWxzZSkge1xcbiAgICAgICAgdGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IgPSB7XFxuICAgICAgICAgICdlcnJvcic6ICdjaGVjaycsXFxuICAgICAgICAgICdwbHVnaW4nOiAnY29yZScsXFxuICAgICAgICAgICdpZCc6ICdjb3JlXzA3JyxcXG4gICAgICAgICAgJ3JlYXNvbic6ICdDb3VsZCBub3QgZWRpdCBub2RlIGJlY2F1c2Ugb2YgY2hlY2tfY2FsbGJhY2snXFxuICAgICAgICB9O1xcbiAgICAgICAgdGhpcy5zZXR0aW5ncy5jb3JlLmVycm9yLmNhbGwodGhpcywgdGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IpO1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICB0bXAgPSBvYmo7XFxuICAgICAgZGVmYXVsdF90ZXh0ID0gdHlwZW9mIGRlZmF1bHRfdGV4dCA9PT0gJ3N0cmluZycgPyBkZWZhdWx0X3RleHQgOiBvYmoudGV4dDtcXG4gICAgICB0aGlzLnNldF90ZXh0KG9iaiwgXFxcIlxcXCIpO1xcbiAgICAgIG9iaiA9IHRoaXMuX29wZW5fdG8ob2JqKTtcXG4gICAgICB0bXAudGV4dCA9IGRlZmF1bHRfdGV4dDtcXG4gICAgICBydGwgPSB0aGlzLl9kYXRhLmNvcmUucnRsO1xcbiAgICAgIHcgPSB0aGlzLmVsZW1lbnQud2lkdGgoKTtcXG4gICAgICB0aGlzLl9kYXRhLmNvcmUuZm9jdXNlZCA9IHRtcC5pZDtcXG4gICAgICBhID0gb2JqLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLmZvY3VzKCk7XFxuICAgICAgcyA9ICQoJzxzcGFuPicpO1xcbiAgICAgIC8qIVxcbiAgICAgIG9pID0gb2JqLmNoaWxkcmVuKFxcXCJpOnZpc2libGVcXFwiKSxcXG4gICAgICBhaSA9IGEuY2hpbGRyZW4oXFxcImk6dmlzaWJsZVxcXCIpLFxcbiAgICAgIHcxID0gb2kud2lkdGgoKSAqIG9pLmxlbmd0aCxcXG4gICAgICB3MiA9IGFpLndpZHRoKCkgKiBhaS5sZW5ndGgsXFxuICAgICAgKi9cXG5cXG4gICAgICB0ID0gZGVmYXVsdF90ZXh0O1xcbiAgICAgIGgxID0gJChcXFwiPFxcXCIgKyBcXFwiZGl2IC8+XFxcIiwge1xcbiAgICAgICAgY3NzOiB7XFxuICAgICAgICAgIFxcXCJwb3NpdGlvblxcXCI6IFxcXCJhYnNvbHV0ZVxcXCIsXFxuICAgICAgICAgIFxcXCJ0b3BcXFwiOiBcXFwiLTIwMHB4XFxcIixcXG4gICAgICAgICAgXFxcImxlZnRcXFwiOiBydGwgPyBcXFwiMHB4XFxcIiA6IFxcXCItMTAwMHB4XFxcIixcXG4gICAgICAgICAgXFxcInZpc2liaWxpdHlcXFwiOiBcXFwiaGlkZGVuXFxcIlxcbiAgICAgICAgfVxcbiAgICAgIH0pLmFwcGVuZFRvKFxcXCJib2R5XFxcIik7XFxuICAgICAgaDIgPSAkKFxcXCI8XFxcIiArIFxcXCJpbnB1dCAvPlxcXCIsIHtcXG4gICAgICAgIFxcXCJ2YWx1ZVxcXCI6IHQsXFxuICAgICAgICBcXFwiY2xhc3NcXFwiOiBcXFwianN0cmVlLXJlbmFtZS1pbnB1dFxcXCIsXFxuICAgICAgICAvLyBcXFwic2l6ZVxcXCIgOiB0Lmxlbmd0aCxcXG4gICAgICAgIFxcXCJjc3NcXFwiOiB7XFxuICAgICAgICAgIFxcXCJwYWRkaW5nXFxcIjogXFxcIjBcXFwiLFxcbiAgICAgICAgICBcXFwiYm9yZGVyXFxcIjogXFxcIjFweCBzb2xpZCBzaWx2ZXJcXFwiLFxcbiAgICAgICAgICBcXFwiYm94LXNpemluZ1xcXCI6IFxcXCJib3JkZXItYm94XFxcIixcXG4gICAgICAgICAgXFxcImRpc3BsYXlcXFwiOiBcXFwiaW5saW5lLWJsb2NrXFxcIixcXG4gICAgICAgICAgXFxcImhlaWdodFxcXCI6IHRoaXMuX2RhdGEuY29yZS5saV9oZWlnaHQgKyBcXFwicHhcXFwiLFxcbiAgICAgICAgICBcXFwibGluZUhlaWdodFxcXCI6IHRoaXMuX2RhdGEuY29yZS5saV9oZWlnaHQgKyBcXFwicHhcXFwiLFxcbiAgICAgICAgICBcXFwid2lkdGhcXFwiOiBcXFwiMTUwcHhcXFwiIC8vIHdpbGwgYmUgc2V0IGEgYml0IGZ1cnRoZXIgZG93blxcblxcbiAgICAgICAgfSxcXG4gICAgICAgIFxcXCJibHVyXFxcIjogJC5wcm94eShmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICAgIHZhciBpID0gcy5jaGlsZHJlbihcXFwiLmpzdHJlZS1yZW5hbWUtaW5wdXRcXFwiKSxcXG4gICAgICAgICAgICAgIHYgPSBpLnZhbCgpLFxcbiAgICAgICAgICAgICAgZiA9IHRoaXMuc2V0dGluZ3MuY29yZS5mb3JjZV90ZXh0LFxcbiAgICAgICAgICAgICAgbnY7XFxuXFxuICAgICAgICAgIGlmICh2ID09PSBcXFwiXFxcIikge1xcbiAgICAgICAgICAgIHYgPSB0O1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGgxLnJlbW92ZSgpO1xcbiAgICAgICAgICBzLnJlcGxhY2VXaXRoKGEpO1xcbiAgICAgICAgICBzLnJlbW92ZSgpO1xcbiAgICAgICAgICB0ID0gZiA/IHQgOiAkKCc8ZGl2PjwvZGl2PicpLmFwcGVuZCgkLnBhcnNlSFRNTCh0KSkuaHRtbCgpO1xcbiAgICAgICAgICB0aGlzLnNldF90ZXh0KG9iaiwgdCk7XFxuICAgICAgICAgIG52ID0gISF0aGlzLnJlbmFtZV9ub2RlKG9iaiwgZiA/ICQoJzxkaXY+PC9kaXY+JykudGV4dCh2KS50ZXh0KCkgOiAkKCc8ZGl2PjwvZGl2PicpLmFwcGVuZCgkLnBhcnNlSFRNTCh2KSkuaHRtbCgpKTtcXG5cXG4gICAgICAgICAgaWYgKCFudikge1xcbiAgICAgICAgICAgIHRoaXMuc2V0X3RleHQob2JqLCB0KTsgLy8gbW92ZSB0aGlzIHVwPyBhbmQgZml4ICM0ODNcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICB0aGlzLl9kYXRhLmNvcmUuZm9jdXNlZCA9IHRtcC5pZDtcXG4gICAgICAgICAgc2V0VGltZW91dCgkLnByb3h5KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuZ2V0X25vZGUodG1wLmlkLCB0cnVlKTtcXG5cXG4gICAgICAgICAgICBpZiAobm9kZS5sZW5ndGgpIHtcXG4gICAgICAgICAgICAgIHRoaXMuX2RhdGEuY29yZS5mb2N1c2VkID0gdG1wLmlkO1xcbiAgICAgICAgICAgICAgbm9kZS5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5mb2N1cygpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSwgdGhpcyksIDApO1xcblxcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcXG4gICAgICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXMsIHRtcCwgbnYsIGNhbmNlbCk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaDIgPSBudWxsO1xcbiAgICAgICAgfSwgdGhpcyksXFxuICAgICAgICBcXFwia2V5ZG93blxcXCI6IGZ1bmN0aW9uIGtleWRvd24oZSkge1xcbiAgICAgICAgICB2YXIga2V5ID0gZS53aGljaDtcXG5cXG4gICAgICAgICAgaWYgKGtleSA9PT0gMjcpIHtcXG4gICAgICAgICAgICBjYW5jZWwgPSB0cnVlO1xcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0O1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmIChrZXkgPT09IDI3IHx8IGtleSA9PT0gMTMgfHwga2V5ID09PSAzNyB8fCBrZXkgPT09IDM4IHx8IGtleSA9PT0gMzkgfHwga2V5ID09PSA0MCB8fCBrZXkgPT09IDMyKSB7XFxuICAgICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAoa2V5ID09PSAyNyB8fCBrZXkgPT09IDEzKSB7XFxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgICAgIHRoaXMuYmx1cigpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgXFxcImNsaWNrXFxcIjogZnVuY3Rpb24gY2xpY2soZSkge1xcbiAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xcbiAgICAgICAgfSxcXG4gICAgICAgIFxcXCJtb3VzZWRvd25cXFwiOiBmdW5jdGlvbiBtb3VzZWRvd24oZSkge1xcbiAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xcbiAgICAgICAgfSxcXG4gICAgICAgIFxcXCJrZXl1cFxcXCI6IGZ1bmN0aW9uIGtleXVwKGUpIHtcXG4gICAgICAgICAgaDIud2lkdGgoTWF0aC5taW4oaDEudGV4dChcXFwicFdcXFwiICsgdGhpcy52YWx1ZSkud2lkdGgoKSwgdykpO1xcbiAgICAgICAgfSxcXG4gICAgICAgIFxcXCJrZXlwcmVzc1xcXCI6IGZ1bmN0aW9uIGtleXByZXNzKGUpIHtcXG4gICAgICAgICAgaWYgKGUud2hpY2ggPT09IDEzKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgICAgZm4gPSB7XFxuICAgICAgICBmb250RmFtaWx5OiBhLmNzcygnZm9udEZhbWlseScpIHx8ICcnLFxcbiAgICAgICAgZm9udFNpemU6IGEuY3NzKCdmb250U2l6ZScpIHx8ICcnLFxcbiAgICAgICAgZm9udFdlaWdodDogYS5jc3MoJ2ZvbnRXZWlnaHQnKSB8fCAnJyxcXG4gICAgICAgIGZvbnRTdHlsZTogYS5jc3MoJ2ZvbnRTdHlsZScpIHx8ICcnLFxcbiAgICAgICAgZm9udFN0cmV0Y2g6IGEuY3NzKCdmb250U3RyZXRjaCcpIHx8ICcnLFxcbiAgICAgICAgZm9udFZhcmlhbnQ6IGEuY3NzKCdmb250VmFyaWFudCcpIHx8ICcnLFxcbiAgICAgICAgbGV0dGVyU3BhY2luZzogYS5jc3MoJ2xldHRlclNwYWNpbmcnKSB8fCAnJyxcXG4gICAgICAgIHdvcmRTcGFjaW5nOiBhLmNzcygnd29yZFNwYWNpbmcnKSB8fCAnJ1xcbiAgICAgIH07XFxuICAgICAgcy5hdHRyKCdjbGFzcycsIGEuYXR0cignY2xhc3MnKSkuYXBwZW5kKGEuY29udGVudHMoKS5jbG9uZSgpKS5hcHBlbmQoaDIpO1xcbiAgICAgIGEucmVwbGFjZVdpdGgocyk7XFxuICAgICAgaDEuY3NzKGZuKTtcXG4gICAgICBoMi5jc3MoZm4pLndpZHRoKE1hdGgubWluKGgxLnRleHQoXFxcInBXXFxcIiArIGgyWzBdLnZhbHVlKS53aWR0aCgpLCB3KSlbMF0uc2VsZWN0KCk7XFxuICAgICAgJChkb2N1bWVudCkub25lKCdtb3VzZWRvd24uanN0cmVlIHRvdWNoc3RhcnQuanN0cmVlIGRuZF9zdGFydC52YWthdGEnLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgaWYgKGgyICYmIGUudGFyZ2V0ICE9PSBoMikge1xcbiAgICAgICAgICAkKGgyKS5ibHVyKCk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBjaGFuZ2VzIHRoZSB0aGVtZVxcbiAgICAgKiBAbmFtZSBzZXRfdGhlbWUodGhlbWVfbmFtZSBbLCB0aGVtZV91cmxdKVxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGhlbWVfbmFtZSB0aGUgbmFtZSBvZiB0aGUgbmV3IHRoZW1lIHRvIGFwcGx5XFxuICAgICAqIEBwYXJhbSB7bWl4ZWR9IHRoZW1lX3VybCAgdGhlIGxvY2F0aW9uIG9mIHRoZSBDU1MgZmlsZSBmb3IgdGhpcyB0aGVtZS4gT21pdCBvciBzZXQgdG8gYGZhbHNlYCBpZiB5b3UgbWFudWFsbHkgaW5jbHVkZWQgdGhlIGZpbGUuIFNldCB0byBgdHJ1ZWAgdG8gYXV0b2xvYWQgZnJvbSB0aGUgYGNvcmUudGhlbWVzLmRpcmAgZGlyZWN0b3J5LlxcbiAgICAgKiBAdHJpZ2dlciBzZXRfdGhlbWUuanN0cmVlXFxuICAgICAqL1xcbiAgICBzZXRfdGhlbWU6IGZ1bmN0aW9uIHNldF90aGVtZSh0aGVtZV9uYW1lLCB0aGVtZV91cmwpIHtcXG4gICAgICBpZiAoIXRoZW1lX25hbWUpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoZW1lX3VybCA9PT0gdHJ1ZSkge1xcbiAgICAgICAgdmFyIGRpciA9IHRoaXMuc2V0dGluZ3MuY29yZS50aGVtZXMuZGlyO1xcblxcbiAgICAgICAgaWYgKCFkaXIpIHtcXG4gICAgICAgICAgZGlyID0gJC5qc3RyZWUucGF0aCArICcvdGhlbWVzJztcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHRoZW1lX3VybCA9IGRpciArICcvJyArIHRoZW1lX25hbWUgKyAnL3N0eWxlLmNzcyc7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGVtZV91cmwgJiYgJC5pbkFycmF5KHRoZW1lX3VybCwgdGhlbWVzX2xvYWRlZCkgPT09IC0xKSB7XFxuICAgICAgICAkKCdoZWFkJykuYXBwZW5kKCc8JyArICdsaW5rIHJlbD1cXFwic3R5bGVzaGVldFxcXCIgaHJlZj1cXFwiJyArIHRoZW1lX3VybCArICdcXFwiIHR5cGU9XFxcInRleHQvY3NzXFxcIiAvPicpO1xcbiAgICAgICAgdGhlbWVzX2xvYWRlZC5wdXNoKHRoZW1lX3VybCk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLl9kYXRhLmNvcmUudGhlbWVzLm5hbWUpIHtcXG4gICAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVDbGFzcygnanN0cmVlLScgKyB0aGlzLl9kYXRhLmNvcmUudGhlbWVzLm5hbWUpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9kYXRhLmNvcmUudGhlbWVzLm5hbWUgPSB0aGVtZV9uYW1lO1xcbiAgICAgIHRoaXMuZWxlbWVudC5hZGRDbGFzcygnanN0cmVlLScgKyB0aGVtZV9uYW1lKTtcXG4gICAgICB0aGlzLmVsZW1lbnRbdGhpcy5zZXR0aW5ncy5jb3JlLnRoZW1lcy5yZXNwb25zaXZlID8gJ2FkZENsYXNzJyA6ICdyZW1vdmVDbGFzcyddKCdqc3RyZWUtJyArIHRoZW1lX25hbWUgKyAnLXJlc3BvbnNpdmUnKTtcXG4gICAgICAvKipcXG4gICAgICAgKiB0cmlnZ2VyZWQgd2hlbiBhIHRoZW1lIGlzIHNldFxcbiAgICAgICAqIEBldmVudFxcbiAgICAgICAqIEBuYW1lIHNldF90aGVtZS5qc3RyZWVcXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGhlbWUgdGhlIG5ldyB0aGVtZVxcbiAgICAgICAqL1xcblxcbiAgICAgIHRoaXMudHJpZ2dlcignc2V0X3RoZW1lJywge1xcbiAgICAgICAgJ3RoZW1lJzogdGhlbWVfbmFtZVxcbiAgICAgIH0pO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogZ2V0cyB0aGUgbmFtZSBvZiB0aGUgY3VycmVudGx5IGFwcGxpZWQgdGhlbWUgbmFtZVxcbiAgICAgKiBAbmFtZSBnZXRfdGhlbWUoKVxcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XFxuICAgICAqL1xcbiAgICBnZXRfdGhlbWU6IGZ1bmN0aW9uIGdldF90aGVtZSgpIHtcXG4gICAgICByZXR1cm4gdGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5uYW1lO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogY2hhbmdlcyB0aGUgdGhlbWUgdmFyaWFudCAoaWYgdGhlIHRoZW1lIGhhcyB2YXJpYW50cylcXG4gICAgICogQG5hbWUgc2V0X3RoZW1lX3ZhcmlhbnQodmFyaWFudF9uYW1lKVxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xCb29sZWFufSB2YXJpYW50X25hbWUgdGhlIHZhcmlhbnQgdG8gYXBwbHkgKGlmIGBmYWxzZWAgaXMgdXNlZCB0aGUgY3VycmVudCB2YXJpYW50IGlzIHJlbW92ZWQpXFxuICAgICAqL1xcbiAgICBzZXRfdGhlbWVfdmFyaWFudDogZnVuY3Rpb24gc2V0X3RoZW1lX3ZhcmlhbnQodmFyaWFudF9uYW1lKSB7XFxuICAgICAgaWYgKHRoaXMuX2RhdGEuY29yZS50aGVtZXMudmFyaWFudCkge1xcbiAgICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZUNsYXNzKCdqc3RyZWUtJyArIHRoaXMuX2RhdGEuY29yZS50aGVtZXMubmFtZSArICctJyArIHRoaXMuX2RhdGEuY29yZS50aGVtZXMudmFyaWFudCk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX2RhdGEuY29yZS50aGVtZXMudmFyaWFudCA9IHZhcmlhbnRfbmFtZTtcXG5cXG4gICAgICBpZiAodmFyaWFudF9uYW1lKSB7XFxuICAgICAgICB0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoJ2pzdHJlZS0nICsgdGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5uYW1lICsgJy0nICsgdGhpcy5fZGF0YS5jb3JlLnRoZW1lcy52YXJpYW50KTtcXG4gICAgICB9XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBnZXRzIHRoZSBuYW1lIG9mIHRoZSBjdXJyZW50bHkgYXBwbGllZCB0aGVtZSB2YXJpYW50XFxuICAgICAqIEBuYW1lIGdldF90aGVtZSgpXFxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cXG4gICAgICovXFxuICAgIGdldF90aGVtZV92YXJpYW50OiBmdW5jdGlvbiBnZXRfdGhlbWVfdmFyaWFudCgpIHtcXG4gICAgICByZXR1cm4gdGhpcy5fZGF0YS5jb3JlLnRoZW1lcy52YXJpYW50O1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogc2hvd3MgYSBzdHJpcGVkIGJhY2tncm91bmQgb24gdGhlIGNvbnRhaW5lciAoaWYgdGhlIHRoZW1lIHN1cHBvcnRzIGl0KVxcbiAgICAgKiBAbmFtZSBzaG93X3N0cmlwZXMoKVxcbiAgICAgKi9cXG4gICAgc2hvd19zdHJpcGVzOiBmdW5jdGlvbiBzaG93X3N0cmlwZXMoKSB7XFxuICAgICAgdGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5zdHJpcGVzID0gdHJ1ZTtcXG4gICAgICB0aGlzLmdldF9jb250YWluZXJfdWwoKS5hZGRDbGFzcyhcXFwianN0cmVlLXN0cmlwZWRcXFwiKTtcXG4gICAgICAvKipcXG4gICAgICAgKiB0cmlnZ2VyZWQgd2hlbiBzdHJpcGVzIGFyZSBzaG93blxcbiAgICAgICAqIEBldmVudFxcbiAgICAgICAqIEBuYW1lIHNob3dfc3RyaXBlcy5qc3RyZWVcXG4gICAgICAgKi9cXG5cXG4gICAgICB0aGlzLnRyaWdnZXIoJ3Nob3dfc3RyaXBlcycpO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogaGlkZXMgdGhlIHN0cmlwZWQgYmFja2dyb3VuZCBvbiB0aGUgY29udGFpbmVyXFxuICAgICAqIEBuYW1lIGhpZGVfc3RyaXBlcygpXFxuICAgICAqL1xcbiAgICBoaWRlX3N0cmlwZXM6IGZ1bmN0aW9uIGhpZGVfc3RyaXBlcygpIHtcXG4gICAgICB0aGlzLl9kYXRhLmNvcmUudGhlbWVzLnN0cmlwZXMgPSBmYWxzZTtcXG4gICAgICB0aGlzLmdldF9jb250YWluZXJfdWwoKS5yZW1vdmVDbGFzcyhcXFwianN0cmVlLXN0cmlwZWRcXFwiKTtcXG4gICAgICAvKipcXG4gICAgICAgKiB0cmlnZ2VyZWQgd2hlbiBzdHJpcGVzIGFyZSBoaWRkZW5cXG4gICAgICAgKiBAZXZlbnRcXG4gICAgICAgKiBAbmFtZSBoaWRlX3N0cmlwZXMuanN0cmVlXFxuICAgICAgICovXFxuXFxuICAgICAgdGhpcy50cmlnZ2VyKCdoaWRlX3N0cmlwZXMnKTtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIHRvZ2dsZXMgdGhlIHN0cmlwZWQgYmFja2dyb3VuZCBvbiB0aGUgY29udGFpbmVyXFxuICAgICAqIEBuYW1lIHRvZ2dsZV9zdHJpcGVzKClcXG4gICAgICovXFxuICAgIHRvZ2dsZV9zdHJpcGVzOiBmdW5jdGlvbiB0b2dnbGVfc3RyaXBlcygpIHtcXG4gICAgICBpZiAodGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5zdHJpcGVzKSB7XFxuICAgICAgICB0aGlzLmhpZGVfc3RyaXBlcygpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB0aGlzLnNob3dfc3RyaXBlcygpO1xcbiAgICAgIH1cXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIHNob3dzIHRoZSBjb25uZWN0aW5nIGRvdHMgKGlmIHRoZSB0aGVtZSBzdXBwb3J0cyBpdClcXG4gICAgICogQG5hbWUgc2hvd19kb3RzKClcXG4gICAgICovXFxuICAgIHNob3dfZG90czogZnVuY3Rpb24gc2hvd19kb3RzKCkge1xcbiAgICAgIHRoaXMuX2RhdGEuY29yZS50aGVtZXMuZG90cyA9IHRydWU7XFxuICAgICAgdGhpcy5nZXRfY29udGFpbmVyX3VsKCkucmVtb3ZlQ2xhc3MoXFxcImpzdHJlZS1uby1kb3RzXFxcIik7XFxuICAgICAgLyoqXFxuICAgICAgICogdHJpZ2dlcmVkIHdoZW4gZG90cyBhcmUgc2hvd25cXG4gICAgICAgKiBAZXZlbnRcXG4gICAgICAgKiBAbmFtZSBzaG93X2RvdHMuanN0cmVlXFxuICAgICAgICovXFxuXFxuICAgICAgdGhpcy50cmlnZ2VyKCdzaG93X2RvdHMnKTtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIGhpZGVzIHRoZSBjb25uZWN0aW5nIGRvdHNcXG4gICAgICogQG5hbWUgaGlkZV9kb3RzKClcXG4gICAgICovXFxuICAgIGhpZGVfZG90czogZnVuY3Rpb24gaGlkZV9kb3RzKCkge1xcbiAgICAgIHRoaXMuX2RhdGEuY29yZS50aGVtZXMuZG90cyA9IGZhbHNlO1xcbiAgICAgIHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpLmFkZENsYXNzKFxcXCJqc3RyZWUtbm8tZG90c1xcXCIpO1xcbiAgICAgIC8qKlxcbiAgICAgICAqIHRyaWdnZXJlZCB3aGVuIGRvdHMgYXJlIGhpZGRlblxcbiAgICAgICAqIEBldmVudFxcbiAgICAgICAqIEBuYW1lIGhpZGVfZG90cy5qc3RyZWVcXG4gICAgICAgKi9cXG5cXG4gICAgICB0aGlzLnRyaWdnZXIoJ2hpZGVfZG90cycpO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogdG9nZ2xlcyB0aGUgY29ubmVjdGluZyBkb3RzXFxuICAgICAqIEBuYW1lIHRvZ2dsZV9kb3RzKClcXG4gICAgICovXFxuICAgIHRvZ2dsZV9kb3RzOiBmdW5jdGlvbiB0b2dnbGVfZG90cygpIHtcXG4gICAgICBpZiAodGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5kb3RzKSB7XFxuICAgICAgICB0aGlzLmhpZGVfZG90cygpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB0aGlzLnNob3dfZG90cygpO1xcbiAgICAgIH1cXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIHNob3cgdGhlIG5vZGUgaWNvbnNcXG4gICAgICogQG5hbWUgc2hvd19pY29ucygpXFxuICAgICAqL1xcbiAgICBzaG93X2ljb25zOiBmdW5jdGlvbiBzaG93X2ljb25zKCkge1xcbiAgICAgIHRoaXMuX2RhdGEuY29yZS50aGVtZXMuaWNvbnMgPSB0cnVlO1xcbiAgICAgIHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpLnJlbW92ZUNsYXNzKFxcXCJqc3RyZWUtbm8taWNvbnNcXFwiKTtcXG4gICAgICAvKipcXG4gICAgICAgKiB0cmlnZ2VyZWQgd2hlbiBpY29ucyBhcmUgc2hvd25cXG4gICAgICAgKiBAZXZlbnRcXG4gICAgICAgKiBAbmFtZSBzaG93X2ljb25zLmpzdHJlZVxcbiAgICAgICAqL1xcblxcbiAgICAgIHRoaXMudHJpZ2dlcignc2hvd19pY29ucycpO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogaGlkZSB0aGUgbm9kZSBpY29uc1xcbiAgICAgKiBAbmFtZSBoaWRlX2ljb25zKClcXG4gICAgICovXFxuICAgIGhpZGVfaWNvbnM6IGZ1bmN0aW9uIGhpZGVfaWNvbnMoKSB7XFxuICAgICAgdGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5pY29ucyA9IGZhbHNlO1xcbiAgICAgIHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpLmFkZENsYXNzKFxcXCJqc3RyZWUtbm8taWNvbnNcXFwiKTtcXG4gICAgICAvKipcXG4gICAgICAgKiB0cmlnZ2VyZWQgd2hlbiBpY29ucyBhcmUgaGlkZGVuXFxuICAgICAgICogQGV2ZW50XFxuICAgICAgICogQG5hbWUgaGlkZV9pY29ucy5qc3RyZWVcXG4gICAgICAgKi9cXG5cXG4gICAgICB0aGlzLnRyaWdnZXIoJ2hpZGVfaWNvbnMnKTtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIHRvZ2dsZSB0aGUgbm9kZSBpY29uc1xcbiAgICAgKiBAbmFtZSB0b2dnbGVfaWNvbnMoKVxcbiAgICAgKi9cXG4gICAgdG9nZ2xlX2ljb25zOiBmdW5jdGlvbiB0b2dnbGVfaWNvbnMoKSB7XFxuICAgICAgaWYgKHRoaXMuX2RhdGEuY29yZS50aGVtZXMuaWNvbnMpIHtcXG4gICAgICAgIHRoaXMuaGlkZV9pY29ucygpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB0aGlzLnNob3dfaWNvbnMoKTtcXG4gICAgICB9XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBzaG93IHRoZSBub2RlIGVsbGlwc2lzXFxuICAgICAqIEBuYW1lIHNob3dfaWNvbnMoKVxcbiAgICAgKi9cXG4gICAgc2hvd19lbGxpcHNpczogZnVuY3Rpb24gc2hvd19lbGxpcHNpcygpIHtcXG4gICAgICB0aGlzLl9kYXRhLmNvcmUudGhlbWVzLmVsbGlwc2lzID0gdHJ1ZTtcXG4gICAgICB0aGlzLmdldF9jb250YWluZXJfdWwoKS5hZGRDbGFzcyhcXFwianN0cmVlLWVsbGlwc2lzXFxcIik7XFxuICAgICAgLyoqXFxuICAgICAgICogdHJpZ2dlcmVkIHdoZW4gZWxsaXNpcyBpcyBzaG93blxcbiAgICAgICAqIEBldmVudFxcbiAgICAgICAqIEBuYW1lIHNob3dfZWxsaXBzaXMuanN0cmVlXFxuICAgICAgICovXFxuXFxuICAgICAgdGhpcy50cmlnZ2VyKCdzaG93X2VsbGlwc2lzJyk7XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBoaWRlIHRoZSBub2RlIGVsbGlwc2lzXFxuICAgICAqIEBuYW1lIGhpZGVfZWxsaXBzaXMoKVxcbiAgICAgKi9cXG4gICAgaGlkZV9lbGxpcHNpczogZnVuY3Rpb24gaGlkZV9lbGxpcHNpcygpIHtcXG4gICAgICB0aGlzLl9kYXRhLmNvcmUudGhlbWVzLmVsbGlwc2lzID0gZmFsc2U7XFxuICAgICAgdGhpcy5nZXRfY29udGFpbmVyX3VsKCkucmVtb3ZlQ2xhc3MoXFxcImpzdHJlZS1lbGxpcHNpc1xcXCIpO1xcbiAgICAgIC8qKlxcbiAgICAgICAqIHRyaWdnZXJlZCB3aGVuIGVsbGlzaXMgaXMgaGlkZGVuXFxuICAgICAgICogQGV2ZW50XFxuICAgICAgICogQG5hbWUgaGlkZV9lbGxpcHNpcy5qc3RyZWVcXG4gICAgICAgKi9cXG5cXG4gICAgICB0aGlzLnRyaWdnZXIoJ2hpZGVfZWxsaXBzaXMnKTtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIHRvZ2dsZSB0aGUgbm9kZSBlbGxpcHNpc1xcbiAgICAgKiBAbmFtZSB0b2dnbGVfaWNvbnMoKVxcbiAgICAgKi9cXG4gICAgdG9nZ2xlX2VsbGlwc2lzOiBmdW5jdGlvbiB0b2dnbGVfZWxsaXBzaXMoKSB7XFxuICAgICAgaWYgKHRoaXMuX2RhdGEuY29yZS50aGVtZXMuZWxsaXBzaXMpIHtcXG4gICAgICAgIHRoaXMuaGlkZV9lbGxpcHNpcygpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB0aGlzLnNob3dfZWxsaXBzaXMoKTtcXG4gICAgICB9XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBzZXQgdGhlIG5vZGUgaWNvbiBmb3IgYSBub2RlXFxuICAgICAqIEBuYW1lIHNldF9pY29uKG9iaiwgaWNvbilcXG4gICAgICogQHBhcmFtIHttaXhlZH0gb2JqXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpY29uIHRoZSBuZXcgaWNvbiAtIGNhbiBiZSBhIHBhdGggdG8gYW4gaWNvbiBvciBhIGNsYXNzTmFtZSwgaWYgdXNpbmcgYW4gaW1hZ2UgdGhhdCBpcyBpbiB0aGUgY3VycmVudCBkaXJlY3RvcnkgdXNlIGEgYC4vYCBwcmVmaXgsIG90aGVyd2lzZSBpdCB3aWxsIGJlIGRldGVjdGVkIGFzIGEgY2xhc3NcXG4gICAgICovXFxuICAgIHNldF9pY29uOiBmdW5jdGlvbiBzZXRfaWNvbihvYmosIGljb24pIHtcXG4gICAgICB2YXIgdDEsIHQyLCBkb20sIG9sZDtcXG5cXG4gICAgICBpZiAoJC5pc0FycmF5KG9iaikpIHtcXG4gICAgICAgIG9iaiA9IG9iai5zbGljZSgpO1xcblxcbiAgICAgICAgZm9yICh0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xcbiAgICAgICAgICB0aGlzLnNldF9pY29uKG9ialt0MV0sIGljb24pO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgfVxcblxcbiAgICAgIG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXG4gICAgICBpZiAoIW9iaiB8fCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgb2xkID0gb2JqLmljb247XFxuICAgICAgb2JqLmljb24gPSBpY29uID09PSB0cnVlIHx8IGljb24gPT09IG51bGwgfHwgaWNvbiA9PT0gdW5kZWZpbmVkIHx8IGljb24gPT09ICcnID8gdHJ1ZSA6IGljb247XFxuICAgICAgZG9tID0gdGhpcy5nZXRfbm9kZShvYmosIHRydWUpLmNoaWxkcmVuKFxcXCIuanN0cmVlLWFuY2hvclxcXCIpLmNoaWxkcmVuKFxcXCIuanN0cmVlLXRoZW1laWNvblxcXCIpO1xcblxcbiAgICAgIGlmIChpY29uID09PSBmYWxzZSkge1xcbiAgICAgICAgdGhpcy5oaWRlX2ljb24ob2JqKTtcXG4gICAgICB9IGVsc2UgaWYgKGljb24gPT09IHRydWUgfHwgaWNvbiA9PT0gbnVsbCB8fCBpY29uID09PSB1bmRlZmluZWQgfHwgaWNvbiA9PT0gJycpIHtcXG4gICAgICAgIGRvbS5yZW1vdmVDbGFzcygnanN0cmVlLXRoZW1laWNvbi1jdXN0b20gJyArIG9sZCkuY3NzKFxcXCJiYWNrZ3JvdW5kXFxcIiwgXFxcIlxcXCIpLnJlbW92ZUF0dHIoXFxcInJlbFxcXCIpO1xcblxcbiAgICAgICAgaWYgKG9sZCA9PT0gZmFsc2UpIHtcXG4gICAgICAgICAgdGhpcy5zaG93X2ljb24ob2JqKTtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2UgaWYgKGljb24uaW5kZXhPZihcXFwiL1xcXCIpID09PSAtMSAmJiBpY29uLmluZGV4T2YoXFxcIi5cXFwiKSA9PT0gLTEpIHtcXG4gICAgICAgIGRvbS5yZW1vdmVDbGFzcyhvbGQpLmNzcyhcXFwiYmFja2dyb3VuZFxcXCIsIFxcXCJcXFwiKTtcXG4gICAgICAgIGRvbS5hZGRDbGFzcyhpY29uICsgJyBqc3RyZWUtdGhlbWVpY29uLWN1c3RvbScpLmF0dHIoXFxcInJlbFxcXCIsIGljb24pO1xcblxcbiAgICAgICAgaWYgKG9sZCA9PT0gZmFsc2UpIHtcXG4gICAgICAgICAgdGhpcy5zaG93X2ljb24ob2JqKTtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgZG9tLnJlbW92ZUNsYXNzKG9sZCkuY3NzKFxcXCJiYWNrZ3JvdW5kXFxcIiwgXFxcIlxcXCIpO1xcbiAgICAgICAgZG9tLmFkZENsYXNzKCdqc3RyZWUtdGhlbWVpY29uLWN1c3RvbScpLmNzcyhcXFwiYmFja2dyb3VuZFxcXCIsIFxcXCJ1cmwoJ1xcXCIgKyBpY29uICsgXFxcIicpIGNlbnRlciBjZW50ZXIgbm8tcmVwZWF0XFxcIikuYXR0cihcXFwicmVsXFxcIiwgaWNvbik7XFxuXFxuICAgICAgICBpZiAob2xkID09PSBmYWxzZSkge1xcbiAgICAgICAgICB0aGlzLnNob3dfaWNvbihvYmopO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIGdldCB0aGUgbm9kZSBpY29uIGZvciBhIG5vZGVcXG4gICAgICogQG5hbWUgZ2V0X2ljb24ob2JqKVxcbiAgICAgKiBAcGFyYW0ge21peGVkfSBvYmpcXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxcbiAgICAgKi9cXG4gICAgZ2V0X2ljb246IGZ1bmN0aW9uIGdldF9pY29uKG9iaikge1xcbiAgICAgIG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcXG4gICAgICByZXR1cm4gIW9iaiB8fCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QgPyBmYWxzZSA6IG9iai5pY29uO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogaGlkZSB0aGUgaWNvbiBvbiBhbiBpbmRpdmlkdWFsIG5vZGVcXG4gICAgICogQG5hbWUgaGlkZV9pY29uKG9iailcXG4gICAgICogQHBhcmFtIHttaXhlZH0gb2JqXFxuICAgICAqL1xcbiAgICBoaWRlX2ljb246IGZ1bmN0aW9uIGhpZGVfaWNvbihvYmopIHtcXG4gICAgICB2YXIgdDEsIHQyO1xcblxcbiAgICAgIGlmICgkLmlzQXJyYXkob2JqKSkge1xcbiAgICAgICAgb2JqID0gb2JqLnNsaWNlKCk7XFxuXFxuICAgICAgICBmb3IgKHQxID0gMCwgdDIgPSBvYmoubGVuZ3RoOyB0MSA8IHQyOyB0MSsrKSB7XFxuICAgICAgICAgIHRoaXMuaGlkZV9pY29uKG9ialt0MV0pO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgfVxcblxcbiAgICAgIG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXG4gICAgICBpZiAoIW9iaiB8fCBvYmogPT09ICQuanN0cmVlLnJvb3QpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgb2JqLmljb24gPSBmYWxzZTtcXG4gICAgICB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSkuY2hpbGRyZW4oXFxcIi5qc3RyZWUtYW5jaG9yXFxcIikuY2hpbGRyZW4oXFxcIi5qc3RyZWUtdGhlbWVpY29uXFxcIikuYWRkQ2xhc3MoJ2pzdHJlZS10aGVtZWljb24taGlkZGVuJyk7XFxuICAgICAgcmV0dXJuIHRydWU7XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBzaG93IHRoZSBpY29uIG9uIGFuIGluZGl2aWR1YWwgbm9kZVxcbiAgICAgKiBAbmFtZSBzaG93X2ljb24ob2JqKVxcbiAgICAgKiBAcGFyYW0ge21peGVkfSBvYmpcXG4gICAgICovXFxuICAgIHNob3dfaWNvbjogZnVuY3Rpb24gc2hvd19pY29uKG9iaikge1xcbiAgICAgIHZhciB0MSwgdDIsIGRvbTtcXG5cXG4gICAgICBpZiAoJC5pc0FycmF5KG9iaikpIHtcXG4gICAgICAgIG9iaiA9IG9iai5zbGljZSgpO1xcblxcbiAgICAgICAgZm9yICh0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xcbiAgICAgICAgICB0aGlzLnNob3dfaWNvbihvYmpbdDFdKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgIH1cXG5cXG4gICAgICBvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XFxuXFxuICAgICAgaWYgKCFvYmogfHwgb2JqID09PSAkLmpzdHJlZS5yb290KSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcblxcbiAgICAgIGRvbSA9IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKTtcXG4gICAgICBvYmouaWNvbiA9IGRvbS5sZW5ndGggPyBkb20uY2hpbGRyZW4oXFxcIi5qc3RyZWUtYW5jaG9yXFxcIikuY2hpbGRyZW4oXFxcIi5qc3RyZWUtdGhlbWVpY29uXFxcIikuYXR0cigncmVsJykgOiB0cnVlO1xcblxcbiAgICAgIGlmICghb2JqLmljb24pIHtcXG4gICAgICAgIG9iai5pY29uID0gdHJ1ZTtcXG4gICAgICB9XFxuXFxuICAgICAgZG9tLmNoaWxkcmVuKFxcXCIuanN0cmVlLWFuY2hvclxcXCIpLmNoaWxkcmVuKFxcXCIuanN0cmVlLXRoZW1laWNvblxcXCIpLnJlbW92ZUNsYXNzKCdqc3RyZWUtdGhlbWVpY29uLWhpZGRlbicpO1xcbiAgICAgIHJldHVybiB0cnVlO1xcbiAgICB9XFxuICB9OyAvLyBoZWxwZXJzXFxuXFxuICAkLnZha2F0YSA9IHt9OyAvLyBjb2xsZWN0IGF0dHJpYnV0ZXNcXG5cXG4gICQudmFrYXRhLmF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAobm9kZSwgd2l0aF92YWx1ZXMpIHtcXG4gICAgbm9kZSA9ICQobm9kZSlbMF07XFxuICAgIHZhciBhdHRyID0gd2l0aF92YWx1ZXMgPyB7fSA6IFtdO1xcblxcbiAgICBpZiAobm9kZSAmJiBub2RlLmF0dHJpYnV0ZXMpIHtcXG4gICAgICAkLmVhY2gobm9kZS5hdHRyaWJ1dGVzLCBmdW5jdGlvbiAoaSwgdikge1xcbiAgICAgICAgaWYgKCQuaW5BcnJheSh2Lm5hbWUudG9Mb3dlckNhc2UoKSwgWydzdHlsZScsICdjb250ZW50ZWRpdGFibGUnLCAnaGFzZm9jdXMnLCAndGFiaW5kZXgnXSkgIT09IC0xKSB7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICh2LnZhbHVlICE9PSBudWxsICYmICQudHJpbSh2LnZhbHVlKSAhPT0gJycpIHtcXG4gICAgICAgICAgaWYgKHdpdGhfdmFsdWVzKSB7XFxuICAgICAgICAgICAgYXR0clt2Lm5hbWVdID0gdi52YWx1ZTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBhdHRyLnB1c2godi5uYW1lKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBhdHRyO1xcbiAgfTtcXG5cXG4gICQudmFrYXRhLmFycmF5X3VuaXF1ZSA9IGZ1bmN0aW9uIChhcnJheSkge1xcbiAgICB2YXIgYSA9IFtdLFxcbiAgICAgICAgaSxcXG4gICAgICAgIGosXFxuICAgICAgICBsLFxcbiAgICAgICAgbyA9IHt9O1xcblxcbiAgICBmb3IgKGkgPSAwLCBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XFxuICAgICAgaWYgKG9bYXJyYXlbaV1dID09PSB1bmRlZmluZWQpIHtcXG4gICAgICAgIGEucHVzaChhcnJheVtpXSk7XFxuICAgICAgICBvW2FycmF5W2ldXSA9IHRydWU7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHJldHVybiBhO1xcbiAgfTsgLy8gcmVtb3ZlIGl0ZW0gZnJvbSBhcnJheVxcblxcblxcbiAgJC52YWthdGEuYXJyYXlfcmVtb3ZlID0gZnVuY3Rpb24gKGFycmF5LCBmcm9tKSB7XFxuICAgIGFycmF5LnNwbGljZShmcm9tLCAxKTtcXG4gICAgcmV0dXJuIGFycmF5OyAvL3ZhciByZXN0ID0gYXJyYXkuc2xpY2UoKHRvIHx8IGZyb20pICsgMSB8fCBhcnJheS5sZW5ndGgpO1xcbiAgICAvL2FycmF5Lmxlbmd0aCA9IGZyb20gPCAwID8gYXJyYXkubGVuZ3RoICsgZnJvbSA6IGZyb207XFxuICAgIC8vYXJyYXkucHVzaC5hcHBseShhcnJheSwgcmVzdCk7XFxuICAgIC8vcmV0dXJuIGFycmF5O1xcbiAgfTsgLy8gcmVtb3ZlIGl0ZW0gZnJvbSBhcnJheVxcblxcblxcbiAgJC52YWthdGEuYXJyYXlfcmVtb3ZlX2l0ZW0gPSBmdW5jdGlvbiAoYXJyYXksIGl0ZW0pIHtcXG4gICAgdmFyIHRtcCA9ICQuaW5BcnJheShpdGVtLCBhcnJheSk7XFxuICAgIHJldHVybiB0bXAgIT09IC0xID8gJC52YWthdGEuYXJyYXlfcmVtb3ZlKGFycmF5LCB0bXApIDogYXJyYXk7XFxuICB9O1xcblxcbiAgJC52YWthdGEuYXJyYXlfZmlsdGVyID0gZnVuY3Rpb24gKGMsIGEsIGIsIGQsIGUpIHtcXG4gICAgaWYgKGMuZmlsdGVyKSB7XFxuICAgICAgcmV0dXJuIGMuZmlsdGVyKGEsIGIpO1xcbiAgICB9XFxuXFxuICAgIGQgPSBbXTtcXG5cXG4gICAgZm9yIChlIGluIGMpIHtcXG4gICAgICBpZiAofn5lICsgJycgPT09IGUgKyAnJyAmJiBlID49IDAgJiYgYS5jYWxsKGIsIGNbZV0sICtlLCBjKSkge1xcbiAgICAgICAgZC5wdXNoKGNbZV0pO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICByZXR1cm4gZDtcXG4gIH07XFxuICAvKipcXG4gICAqICMjIyBDaGFuZ2VkIHBsdWdpblxcbiAgICpcXG4gICAqIFRoaXMgcGx1Z2luIGFkZHMgbW9yZSBpbmZvcm1hdGlvbiB0byB0aGUgYGNoYW5nZWQuanN0cmVlYCBldmVudC4gVGhlIG5ldyBkYXRhIGlzIGNvbnRhaW5lZCBpbiB0aGUgYGNoYW5nZWRgIGV2ZW50IGRhdGEgcHJvcGVydHksIGFuZCBjb250YWlucyBhIGxpc3RzIG9mIGBzZWxlY3RlZGAgYW5kIGBkZXNlbGVjdGVkYCBub2Rlcy5cXG4gICAqL1xcblxcblxcbiAgJC5qc3RyZWUucGx1Z2lucy5jaGFuZ2VkID0gZnVuY3Rpb24gKG9wdGlvbnMsIHBhcmVudCkge1xcbiAgICB2YXIgbGFzdCA9IFtdO1xcblxcbiAgICB0aGlzLnRyaWdnZXIgPSBmdW5jdGlvbiAoZXYsIGRhdGEpIHtcXG4gICAgICB2YXIgaSwgajtcXG5cXG4gICAgICBpZiAoIWRhdGEpIHtcXG4gICAgICAgIGRhdGEgPSB7fTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGV2LnJlcGxhY2UoJy5qc3RyZWUnLCAnJykgPT09ICdjaGFuZ2VkJykge1xcbiAgICAgICAgZGF0YS5jaGFuZ2VkID0ge1xcbiAgICAgICAgICBzZWxlY3RlZDogW10sXFxuICAgICAgICAgIGRlc2VsZWN0ZWQ6IFtdXFxuICAgICAgICB9O1xcbiAgICAgICAgdmFyIHRtcCA9IHt9O1xcblxcbiAgICAgICAgZm9yIChpID0gMCwgaiA9IGxhc3QubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICAgIHRtcFtsYXN0W2ldXSA9IDE7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBmb3IgKGkgPSAwLCBqID0gZGF0YS5zZWxlY3RlZC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG4gICAgICAgICAgaWYgKCF0bXBbZGF0YS5zZWxlY3RlZFtpXV0pIHtcXG4gICAgICAgICAgICBkYXRhLmNoYW5nZWQuc2VsZWN0ZWQucHVzaChkYXRhLnNlbGVjdGVkW2ldKTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICB0bXBbZGF0YS5zZWxlY3RlZFtpXV0gPSAyO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICBmb3IgKGkgPSAwLCBqID0gbGFzdC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG4gICAgICAgICAgaWYgKHRtcFtsYXN0W2ldXSA9PT0gMSkge1xcbiAgICAgICAgICAgIGRhdGEuY2hhbmdlZC5kZXNlbGVjdGVkLnB1c2gobGFzdFtpXSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGxhc3QgPSBkYXRhLnNlbGVjdGVkLnNsaWNlKCk7XFxuICAgICAgfVxcbiAgICAgIC8qKlxcbiAgICAgICAqIHRyaWdnZXJlZCB3aGVuIHNlbGVjdGlvbiBjaGFuZ2VzICh0aGUgXFxcImNoYW5nZWRcXFwiIHBsdWdpbiBlbmhhbmNlcyB0aGUgb3JpZ2luYWwgZXZlbnQgd2l0aCBtb3JlIGRhdGEpXFxuICAgICAgICogQGV2ZW50XFxuICAgICAgICogQG5hbWUgY2hhbmdlZC5qc3RyZWVcXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZVxcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24gdGhlIGFjdGlvbiB0aGF0IGNhdXNlZCB0aGUgc2VsZWN0aW9uIHRvIGNoYW5nZVxcbiAgICAgICAqIEBwYXJhbSB7QXJyYXl9IHNlbGVjdGVkIHRoZSBjdXJyZW50IHNlbGVjdGlvblxcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjaGFuZ2VkIGFuIG9iamVjdCBjb250YWluaW5nIHR3byBwcm9wZXJ0aWVzIGBzZWxlY3RlZGAgYW5kIGBkZXNlbGVjdGVkYCAtIGJvdGggYXJyYXlzIG9mIG5vZGUgSURzLCB3aGljaCB3ZXJlIHNlbGVjdGVkIG9yIGRlc2VsZWN0ZWQgc2luY2UgdGhlIGxhc3QgY2hhbmdlZCBldmVudFxcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCB0aGUgZXZlbnQgKGlmIGFueSkgdGhhdCB0cmlnZ2VyZWQgdGhpcyBjaGFuZ2VkIGV2ZW50XFxuICAgICAgICogQHBsdWdpbiBjaGFuZ2VkXFxuICAgICAgICovXFxuXFxuXFxuICAgICAgcGFyZW50LnRyaWdnZXIuY2FsbCh0aGlzLCBldiwgZGF0YSk7XFxuICAgIH07XFxuXFxuICAgIHRoaXMucmVmcmVzaCA9IGZ1bmN0aW9uIChza2lwX2xvYWRpbmcsIGZvcmdldF9zdGF0ZSkge1xcbiAgICAgIGxhc3QgPSBbXTtcXG4gICAgICByZXR1cm4gcGFyZW50LnJlZnJlc2guYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gICAgfTtcXG4gIH07XFxuICAvKipcXG4gICAqICMjIyBDaGVja2JveCBwbHVnaW5cXG4gICAqXFxuICAgKiBUaGlzIHBsdWdpbiByZW5kZXJzIGNoZWNrYm94IGljb25zIGluIGZyb250IG9mIGVhY2ggbm9kZSwgbWFraW5nIG11bHRpcGxlIHNlbGVjdGlvbiBtdWNoIGVhc2llci5cXG4gICAqIEl0IGFsc28gc3VwcG9ydHMgdHJpLXN0YXRlIGJlaGF2aW9yLCBtZWFuaW5nIHRoYXQgaWYgYSBub2RlIGhhcyBhIGZldyBvZiBpdHMgY2hpbGRyZW4gY2hlY2tlZCBpdCB3aWxsIGJlIHJlbmRlcmVkIGFzIHVuZGV0ZXJtaW5lZCwgYW5kIHN0YXRlIHdpbGwgYmUgcHJvcGFnYXRlZCB1cC5cXG4gICAqL1xcblxcblxcbiAgdmFyIF9pID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnSScpO1xcblxcbiAgX2kuY2xhc3NOYW1lID0gJ2pzdHJlZS1pY29uIGpzdHJlZS1jaGVja2JveCc7XFxuXFxuICBfaS5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAncHJlc2VudGF0aW9uJyk7XFxuICAvKipcXG4gICAqIHN0b3JlcyBhbGwgZGVmYXVsdHMgZm9yIHRoZSBjaGVja2JveCBwbHVnaW5cXG4gICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNoZWNrYm94XFxuICAgKiBAcGx1Z2luIGNoZWNrYm94XFxuICAgKi9cXG5cXG5cXG4gICQuanN0cmVlLmRlZmF1bHRzLmNoZWNrYm94ID0ge1xcbiAgICAvKipcXG4gICAgICogYSBib29sZWFuIGluZGljYXRpbmcgaWYgY2hlY2tib3hlcyBzaG91bGQgYmUgdmlzaWJsZSAoY2FuIGJlIGNoYW5nZWQgYXQgYSBsYXRlciB0aW1lIHVzaW5nIGBzaG93X2NoZWNrYm94ZXMoKWAgYW5kIGBoaWRlX2NoZWNrYm94ZXNgKS4gRGVmYXVsdHMgdG8gYHRydWVgLlxcbiAgICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jaGVja2JveC52aXNpYmxlXFxuICAgICAqIEBwbHVnaW4gY2hlY2tib3hcXG4gICAgICovXFxuICAgIHZpc2libGU6IHRydWUsXFxuXFxuICAgIC8qKlxcbiAgICAgKiBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiBjaGVja2JveGVzIHNob3VsZCBjYXNjYWRlIGRvd24gYW5kIGhhdmUgYW4gdW5kZXRlcm1pbmVkIHN0YXRlLiBEZWZhdWx0cyB0byBgdHJ1ZWAuXFxuICAgICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNoZWNrYm94LnRocmVlX3N0YXRlXFxuICAgICAqIEBwbHVnaW4gY2hlY2tib3hcXG4gICAgICovXFxuICAgIHRocmVlX3N0YXRlOiB0cnVlLFxcblxcbiAgICAvKipcXG4gICAgICogYSBib29sZWFuIGluZGljYXRpbmcgaWYgY2xpY2tpbmcgYW55d2hlcmUgb24gdGhlIG5vZGUgc2hvdWxkIGFjdCBhcyBjbGlja2luZyBvbiB0aGUgY2hlY2tib3guIERlZmF1bHRzIHRvIGB0cnVlYC5cXG4gICAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY2hlY2tib3gud2hvbGVfbm9kZVxcbiAgICAgKiBAcGx1Z2luIGNoZWNrYm94XFxuICAgICAqL1xcbiAgICB3aG9sZV9ub2RlOiB0cnVlLFxcblxcbiAgICAvKipcXG4gICAgICogYSBib29sZWFuIGluZGljYXRpbmcgaWYgdGhlIHNlbGVjdGVkIHN0eWxlIG9mIGEgbm9kZSBzaG91bGQgYmUga2VwdCwgb3IgcmVtb3ZlZC4gRGVmYXVsdHMgdG8gYHRydWVgLlxcbiAgICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jaGVja2JveC5rZWVwX3NlbGVjdGVkX3N0eWxlXFxuICAgICAqIEBwbHVnaW4gY2hlY2tib3hcXG4gICAgICovXFxuICAgIGtlZXBfc2VsZWN0ZWRfc3R5bGU6IHRydWUsXFxuXFxuICAgIC8qKlxcbiAgICAgKiBUaGlzIHNldHRpbmcgY29udHJvbHMgaG93IGNhc2NhZGluZyBhbmQgdW5kZXRlcm1pbmVkIG5vZGVzIGFyZSBhcHBsaWVkLlxcbiAgICAgKiBJZiAndXAnIGlzIGluIHRoZSBzdHJpbmcgLSBjYXNjYWRpbmcgdXAgaXMgZW5hYmxlZCwgaWYgJ2Rvd24nIGlzIGluIHRoZSBzdHJpbmcgLSBjYXNjYWRpbmcgZG93biBpcyBlbmFibGVkLCBpZiAndW5kZXRlcm1pbmVkJyBpcyBpbiB0aGUgc3RyaW5nIC0gdW5kZXRlcm1pbmVkIG5vZGVzIHdpbGwgYmUgdXNlZC5cXG4gICAgICogSWYgYHRocmVlX3N0YXRlYCBpcyBzZXQgdG8gYHRydWVgIHRoaXMgc2V0dGluZyBpcyBhdXRvbWF0aWNhbGx5IHNldCB0byAndXArZG93bit1bmRldGVybWluZWQnLiBEZWZhdWx0cyB0byAnJy5cXG4gICAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY2hlY2tib3guY2FzY2FkZVxcbiAgICAgKiBAcGx1Z2luIGNoZWNrYm94XFxuICAgICAqL1xcbiAgICBjYXNjYWRlOiAnJyxcXG5cXG4gICAgLyoqXFxuICAgICAqIFRoaXMgc2V0dGluZyBjb250cm9scyBpZiBjaGVja2JveCBhcmUgYm91bmQgdG8gdGhlIGdlbmVyYWwgdHJlZSBzZWxlY3Rpb24gb3IgdG8gYW4gaW50ZXJuYWwgYXJyYXkgbWFpbnRhaW5lZCBieSB0aGUgY2hlY2tib3ggcGx1Z2luLiBEZWZhdWx0cyB0byBgdHJ1ZWAsIG9ubHkgc2V0IHRvIGBmYWxzZWAgaWYgeW91IGtub3cgZXhhY3RseSB3aGF0IHlvdSBhcmUgZG9pbmcuXFxuICAgICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb25cXG4gICAgICogQHBsdWdpbiBjaGVja2JveFxcbiAgICAgKi9cXG4gICAgdGllX3NlbGVjdGlvbjogdHJ1ZVxcbiAgfTtcXG5cXG4gICQuanN0cmVlLnBsdWdpbnMuY2hlY2tib3ggPSBmdW5jdGlvbiAob3B0aW9ucywgcGFyZW50KSB7XFxuICAgIHRoaXMuYmluZCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICBwYXJlbnQuYmluZC5jYWxsKHRoaXMpO1xcbiAgICAgIHRoaXMuX2RhdGEuY2hlY2tib3gudXRvID0gZmFsc2U7XFxuICAgICAgdGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZCA9IFtdO1xcblxcbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRocmVlX3N0YXRlKSB7XFxuICAgICAgICB0aGlzLnNldHRpbmdzLmNoZWNrYm94LmNhc2NhZGUgPSAndXArZG93bit1bmRldGVybWluZWQnO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLmVsZW1lbnQub24oXFxcImluaXQuanN0cmVlXFxcIiwgJC5wcm94eShmdW5jdGlvbiAoKSB7XFxuICAgICAgICB0aGlzLl9kYXRhLmNoZWNrYm94LnZpc2libGUgPSB0aGlzLnNldHRpbmdzLmNoZWNrYm94LnZpc2libGU7XFxuXFxuICAgICAgICBpZiAoIXRoaXMuc2V0dGluZ3MuY2hlY2tib3gua2VlcF9zZWxlY3RlZF9zdHlsZSkge1xcbiAgICAgICAgICB0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoJ2pzdHJlZS1jaGVja2JveC1uby1jbGlja2VkJyk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uKSB7XFxuICAgICAgICAgIHRoaXMuZWxlbWVudC5hZGRDbGFzcygnanN0cmVlLWNoZWNrYm94LXNlbGVjdGlvbicpO1xcbiAgICAgICAgfVxcbiAgICAgIH0sIHRoaXMpKS5vbihcXFwibG9hZGluZy5qc3RyZWVcXFwiLCAkLnByb3h5KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHRoaXNbdGhpcy5fZGF0YS5jaGVja2JveC52aXNpYmxlID8gJ3Nob3dfY2hlY2tib3hlcycgOiAnaGlkZV9jaGVja2JveGVzJ10oKTtcXG4gICAgICB9LCB0aGlzKSk7XFxuXFxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuY2hlY2tib3guY2FzY2FkZS5pbmRleE9mKCd1bmRldGVybWluZWQnKSAhPT0gLTEpIHtcXG4gICAgICAgIHRoaXMuZWxlbWVudC5vbignY2hhbmdlZC5qc3RyZWUgdW5jaGVja19ub2RlLmpzdHJlZSBjaGVja19ub2RlLmpzdHJlZSB1bmNoZWNrX2FsbC5qc3RyZWUgY2hlY2tfYWxsLmpzdHJlZSBtb3ZlX25vZGUuanN0cmVlIGNvcHlfbm9kZS5qc3RyZWUgcmVkcmF3LmpzdHJlZSBvcGVuX25vZGUuanN0cmVlJywgJC5wcm94eShmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIC8vIG9ubHkgaWYgdW5kZXRlcm1pbmVkIGlzIGluIHNldHRpbmdcXG4gICAgICAgICAgaWYgKHRoaXMuX2RhdGEuY2hlY2tib3gudXRvKSB7XFxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2RhdGEuY2hlY2tib3gudXRvKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICB0aGlzLl9kYXRhLmNoZWNrYm94LnV0byA9IHNldFRpbWVvdXQoJC5wcm94eSh0aGlzLl91bmRldGVybWluZWQsIHRoaXMpLCA1MCk7XFxuICAgICAgICB9LCB0aGlzKSk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghdGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uKSB7XFxuICAgICAgICB0aGlzLmVsZW1lbnQub24oJ21vZGVsLmpzdHJlZScsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcXG4gICAgICAgICAgdmFyIG0gPSB0aGlzLl9tb2RlbC5kYXRhLFxcbiAgICAgICAgICAgICAgcCA9IG1bZGF0YS5wYXJlbnRdLFxcbiAgICAgICAgICAgICAgZHBjID0gZGF0YS5ub2RlcyxcXG4gICAgICAgICAgICAgIGksXFxuICAgICAgICAgICAgICBqO1xcblxcbiAgICAgICAgICBmb3IgKGkgPSAwLCBqID0gZHBjLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcbiAgICAgICAgICAgIG1bZHBjW2ldXS5zdGF0ZS5jaGVja2VkID0gbVtkcGNbaV1dLnN0YXRlLmNoZWNrZWQgfHwgbVtkcGNbaV1dLm9yaWdpbmFsICYmIG1bZHBjW2ldXS5vcmlnaW5hbC5zdGF0ZSAmJiBtW2RwY1tpXV0ub3JpZ2luYWwuc3RhdGUuY2hlY2tlZDtcXG5cXG4gICAgICAgICAgICBpZiAobVtkcGNbaV1dLnN0YXRlLmNoZWNrZWQpIHtcXG4gICAgICAgICAgICAgIHRoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWQucHVzaChkcGNbaV0pO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfSwgdGhpcykpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5jaGVja2JveC5jYXNjYWRlLmluZGV4T2YoJ3VwJykgIT09IC0xIHx8IHRoaXMuc2V0dGluZ3MuY2hlY2tib3guY2FzY2FkZS5pbmRleE9mKCdkb3duJykgIT09IC0xKSB7XFxuICAgICAgICB0aGlzLmVsZW1lbnQub24oJ21vZGVsLmpzdHJlZScsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcXG4gICAgICAgICAgdmFyIG0gPSB0aGlzLl9tb2RlbC5kYXRhLFxcbiAgICAgICAgICAgICAgcCA9IG1bZGF0YS5wYXJlbnRdLFxcbiAgICAgICAgICAgICAgZHBjID0gZGF0YS5ub2RlcyxcXG4gICAgICAgICAgICAgIGNoZCA9IFtdLFxcbiAgICAgICAgICAgICAgYyxcXG4gICAgICAgICAgICAgIGksXFxuICAgICAgICAgICAgICBqLFxcbiAgICAgICAgICAgICAgayxcXG4gICAgICAgICAgICAgIGwsXFxuICAgICAgICAgICAgICB0bXAsXFxuICAgICAgICAgICAgICBzID0gdGhpcy5zZXR0aW5ncy5jaGVja2JveC5jYXNjYWRlLFxcbiAgICAgICAgICAgICAgdCA9IHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbjtcXG5cXG4gICAgICAgICAgaWYgKHMuaW5kZXhPZignZG93bicpICE9PSAtMSkge1xcbiAgICAgICAgICAgIC8vIGFwcGx5IGRvd25cXG4gICAgICAgICAgICBpZiAocC5zdGF0ZVt0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJ10pIHtcXG4gICAgICAgICAgICAgIGZvciAoaSA9IDAsIGogPSBkcGMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICAgICAgICAgIG1bZHBjW2ldXS5zdGF0ZVt0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJ10gPSB0cnVlO1xcbiAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgdGhpcy5fZGF0YVt0ID8gJ2NvcmUnIDogJ2NoZWNrYm94J10uc2VsZWN0ZWQgPSB0aGlzLl9kYXRhW3QgPyAnY29yZScgOiAnY2hlY2tib3gnXS5zZWxlY3RlZC5jb25jYXQoZHBjKTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgZm9yIChpID0gMCwgaiA9IGRwYy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG4gICAgICAgICAgICAgICAgaWYgKG1bZHBjW2ldXS5zdGF0ZVt0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJ10pIHtcXG4gICAgICAgICAgICAgICAgICBmb3IgKGsgPSAwLCBsID0gbVtkcGNbaV1dLmNoaWxkcmVuX2QubGVuZ3RoOyBrIDwgbDsgaysrKSB7XFxuICAgICAgICAgICAgICAgICAgICBtW21bZHBjW2ldXS5jaGlsZHJlbl9kW2tdXS5zdGF0ZVt0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJ10gPSB0cnVlO1xcbiAgICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgICB0aGlzLl9kYXRhW3QgPyAnY29yZScgOiAnY2hlY2tib3gnXS5zZWxlY3RlZCA9IHRoaXMuX2RhdGFbdCA/ICdjb3JlJyA6ICdjaGVja2JveCddLnNlbGVjdGVkLmNvbmNhdChtW2RwY1tpXV0uY2hpbGRyZW5fZCk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaWYgKHMuaW5kZXhPZigndXAnKSAhPT0gLTEpIHtcXG4gICAgICAgICAgICAvLyBhcHBseSB1cFxcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGogPSBwLmNoaWxkcmVuX2QubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICAgICAgICBpZiAoIW1bcC5jaGlsZHJlbl9kW2ldXS5jaGlsZHJlbi5sZW5ndGgpIHtcXG4gICAgICAgICAgICAgICAgY2hkLnB1c2gobVtwLmNoaWxkcmVuX2RbaV1dLnBhcmVudCk7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGNoZCA9ICQudmFrYXRhLmFycmF5X3VuaXF1ZShjaGQpO1xcblxcbiAgICAgICAgICAgIGZvciAoayA9IDAsIGwgPSBjaGQubGVuZ3RoOyBrIDwgbDsgaysrKSB7XFxuICAgICAgICAgICAgICBwID0gbVtjaGRba11dO1xcblxcbiAgICAgICAgICAgICAgd2hpbGUgKHAgJiYgcC5pZCAhPT0gJC5qc3RyZWUucm9vdCkge1xcbiAgICAgICAgICAgICAgICBjID0gMDtcXG5cXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaiA9IHAuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICAgICAgICAgICAgYyArPSBtW3AuY2hpbGRyZW5baV1dLnN0YXRlW3QgPyAnc2VsZWN0ZWQnIDogJ2NoZWNrZWQnXTtcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICBpZiAoYyA9PT0gaikge1xcbiAgICAgICAgICAgICAgICAgIHAuc3RhdGVbdCA/ICdzZWxlY3RlZCcgOiAnY2hlY2tlZCddID0gdHJ1ZTtcXG5cXG4gICAgICAgICAgICAgICAgICB0aGlzLl9kYXRhW3QgPyAnY29yZScgOiAnY2hlY2tib3gnXS5zZWxlY3RlZC5wdXNoKHAuaWQpO1xcblxcbiAgICAgICAgICAgICAgICAgIHRtcCA9IHRoaXMuZ2V0X25vZGUocCwgdHJ1ZSk7XFxuXFxuICAgICAgICAgICAgICAgICAgaWYgKHRtcCAmJiB0bXAubGVuZ3RoKSB7XFxuICAgICAgICAgICAgICAgICAgICB0bXAuYXR0cignYXJpYS1zZWxlY3RlZCcsIHRydWUpLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLmFkZENsYXNzKHQgPyAnanN0cmVlLWNsaWNrZWQnIDogJ2pzdHJlZS1jaGVja2VkJyk7XFxuICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIHAgPSB0aGlzLmdldF9ub2RlKHAucGFyZW50KTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgdGhpcy5fZGF0YVt0ID8gJ2NvcmUnIDogJ2NoZWNrYm94J10uc2VsZWN0ZWQgPSAkLnZha2F0YS5hcnJheV91bmlxdWUodGhpcy5fZGF0YVt0ID8gJ2NvcmUnIDogJ2NoZWNrYm94J10uc2VsZWN0ZWQpO1xcbiAgICAgICAgfSwgdGhpcykpLm9uKHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbiA/ICdzZWxlY3Rfbm9kZS5qc3RyZWUnIDogJ2NoZWNrX25vZGUuanN0cmVlJywgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xcbiAgICAgICAgICB2YXIgb2JqID0gZGF0YS5ub2RlLFxcbiAgICAgICAgICAgICAgbSA9IHRoaXMuX21vZGVsLmRhdGEsXFxuICAgICAgICAgICAgICBwYXIgPSB0aGlzLmdldF9ub2RlKG9iai5wYXJlbnQpLFxcbiAgICAgICAgICAgICAgZG9tID0gdGhpcy5nZXRfbm9kZShvYmosIHRydWUpLFxcbiAgICAgICAgICAgICAgaSxcXG4gICAgICAgICAgICAgIGosXFxuICAgICAgICAgICAgICBjLFxcbiAgICAgICAgICAgICAgdG1wLFxcbiAgICAgICAgICAgICAgcyA9IHRoaXMuc2V0dGluZ3MuY2hlY2tib3guY2FzY2FkZSxcXG4gICAgICAgICAgICAgIHQgPSB0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb24sXFxuICAgICAgICAgICAgICBzZWwgPSB7fSxcXG4gICAgICAgICAgICAgIGN1ciA9IHRoaXMuX2RhdGFbdCA/ICdjb3JlJyA6ICdjaGVja2JveCddLnNlbGVjdGVkO1xcblxcbiAgICAgICAgICBmb3IgKGkgPSAwLCBqID0gY3VyLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcbiAgICAgICAgICAgIHNlbFtjdXJbaV1dID0gdHJ1ZTtcXG4gICAgICAgICAgfSAvLyBhcHBseSBkb3duXFxuXFxuXFxuICAgICAgICAgIGlmIChzLmluZGV4T2YoJ2Rvd24nKSAhPT0gLTEpIHtcXG4gICAgICAgICAgICAvL3RoaXMuX2RhdGFbIHQgPyAnY29yZScgOiAnY2hlY2tib3gnIF0uc2VsZWN0ZWQgPSAkLnZha2F0YS5hcnJheV91bmlxdWUodGhpcy5fZGF0YVsgdCA/ICdjb3JlJyA6ICdjaGVja2JveCcgXS5zZWxlY3RlZC5jb25jYXQob2JqLmNoaWxkcmVuX2QpKTtcXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBqID0gb2JqLmNoaWxkcmVuX2QubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICAgICAgICBzZWxbb2JqLmNoaWxkcmVuX2RbaV1dID0gdHJ1ZTtcXG4gICAgICAgICAgICAgIHRtcCA9IG1bb2JqLmNoaWxkcmVuX2RbaV1dO1xcbiAgICAgICAgICAgICAgdG1wLnN0YXRlW3QgPyAnc2VsZWN0ZWQnIDogJ2NoZWNrZWQnXSA9IHRydWU7XFxuXFxuICAgICAgICAgICAgICBpZiAodG1wICYmIHRtcC5vcmlnaW5hbCAmJiB0bXAub3JpZ2luYWwuc3RhdGUgJiYgdG1wLm9yaWdpbmFsLnN0YXRlLnVuZGV0ZXJtaW5lZCkge1xcbiAgICAgICAgICAgICAgICB0bXAub3JpZ2luYWwuc3RhdGUudW5kZXRlcm1pbmVkID0gZmFsc2U7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9IC8vIGFwcGx5IHVwXFxuXFxuXFxuICAgICAgICAgIGlmIChzLmluZGV4T2YoJ3VwJykgIT09IC0xKSB7XFxuICAgICAgICAgICAgd2hpbGUgKHBhciAmJiBwYXIuaWQgIT09ICQuanN0cmVlLnJvb3QpIHtcXG4gICAgICAgICAgICAgIGMgPSAwO1xcblxcbiAgICAgICAgICAgICAgZm9yIChpID0gMCwgaiA9IHBhci5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG4gICAgICAgICAgICAgICAgYyArPSBtW3Bhci5jaGlsZHJlbltpXV0uc3RhdGVbdCA/ICdzZWxlY3RlZCcgOiAnY2hlY2tlZCddO1xcbiAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgaWYgKGMgPT09IGopIHtcXG4gICAgICAgICAgICAgICAgcGFyLnN0YXRlW3QgPyAnc2VsZWN0ZWQnIDogJ2NoZWNrZWQnXSA9IHRydWU7XFxuICAgICAgICAgICAgICAgIHNlbFtwYXIuaWRdID0gdHJ1ZTsgLy90aGlzLl9kYXRhWyB0ID8gJ2NvcmUnIDogJ2NoZWNrYm94JyBdLnNlbGVjdGVkLnB1c2gocGFyLmlkKTtcXG5cXG4gICAgICAgICAgICAgICAgdG1wID0gdGhpcy5nZXRfbm9kZShwYXIsIHRydWUpO1xcblxcbiAgICAgICAgICAgICAgICBpZiAodG1wICYmIHRtcC5sZW5ndGgpIHtcXG4gICAgICAgICAgICAgICAgICB0bXAuYXR0cignYXJpYS1zZWxlY3RlZCcsIHRydWUpLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLmFkZENsYXNzKHQgPyAnanN0cmVlLWNsaWNrZWQnIDogJ2pzdHJlZS1jaGVja2VkJyk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgcGFyID0gdGhpcy5nZXRfbm9kZShwYXIucGFyZW50KTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgY3VyID0gW107XFxuXFxuICAgICAgICAgIGZvciAoaSBpbiBzZWwpIHtcXG4gICAgICAgICAgICBpZiAoc2VsLmhhc093blByb3BlcnR5KGkpKSB7XFxuICAgICAgICAgICAgICBjdXIucHVzaChpKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgdGhpcy5fZGF0YVt0ID8gJ2NvcmUnIDogJ2NoZWNrYm94J10uc2VsZWN0ZWQgPSBjdXI7IC8vIGFwcGx5IGRvd24gKHByb2Nlc3MgLmNoaWxkcmVuIHNlcGFyYXRlbHk/KVxcblxcbiAgICAgICAgICBpZiAocy5pbmRleE9mKCdkb3duJykgIT09IC0xICYmIGRvbS5sZW5ndGgpIHtcXG4gICAgICAgICAgICBkb20uZmluZCgnLmpzdHJlZS1hbmNob3InKS5hZGRDbGFzcyh0ID8gJ2pzdHJlZS1jbGlja2VkJyA6ICdqc3RyZWUtY2hlY2tlZCcpLnBhcmVudCgpLmF0dHIoJ2FyaWEtc2VsZWN0ZWQnLCB0cnVlKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSwgdGhpcykpLm9uKHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbiA/ICdkZXNlbGVjdF9hbGwuanN0cmVlJyA6ICd1bmNoZWNrX2FsbC5qc3RyZWUnLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XFxuICAgICAgICAgIHZhciBvYmogPSB0aGlzLmdldF9ub2RlKCQuanN0cmVlLnJvb3QpLFxcbiAgICAgICAgICAgICAgbSA9IHRoaXMuX21vZGVsLmRhdGEsXFxuICAgICAgICAgICAgICBpLFxcbiAgICAgICAgICAgICAgaixcXG4gICAgICAgICAgICAgIHRtcDtcXG5cXG4gICAgICAgICAgZm9yIChpID0gMCwgaiA9IG9iai5jaGlsZHJlbl9kLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcbiAgICAgICAgICAgIHRtcCA9IG1bb2JqLmNoaWxkcmVuX2RbaV1dO1xcblxcbiAgICAgICAgICAgIGlmICh0bXAgJiYgdG1wLm9yaWdpbmFsICYmIHRtcC5vcmlnaW5hbC5zdGF0ZSAmJiB0bXAub3JpZ2luYWwuc3RhdGUudW5kZXRlcm1pbmVkKSB7XFxuICAgICAgICAgICAgICB0bXAub3JpZ2luYWwuc3RhdGUudW5kZXRlcm1pbmVkID0gZmFsc2U7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9LCB0aGlzKSkub24odGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uID8gJ2Rlc2VsZWN0X25vZGUuanN0cmVlJyA6ICd1bmNoZWNrX25vZGUuanN0cmVlJywgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xcbiAgICAgICAgICB2YXIgb2JqID0gZGF0YS5ub2RlLFxcbiAgICAgICAgICAgICAgZG9tID0gdGhpcy5nZXRfbm9kZShvYmosIHRydWUpLFxcbiAgICAgICAgICAgICAgaSxcXG4gICAgICAgICAgICAgIGosXFxuICAgICAgICAgICAgICB0bXAsXFxuICAgICAgICAgICAgICBzID0gdGhpcy5zZXR0aW5ncy5jaGVja2JveC5jYXNjYWRlLFxcbiAgICAgICAgICAgICAgdCA9IHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbixcXG4gICAgICAgICAgICAgIGN1ciA9IHRoaXMuX2RhdGFbdCA/ICdjb3JlJyA6ICdjaGVja2JveCddLnNlbGVjdGVkLFxcbiAgICAgICAgICAgICAgc2VsID0ge307XFxuXFxuICAgICAgICAgIGlmIChvYmogJiYgb2JqLm9yaWdpbmFsICYmIG9iai5vcmlnaW5hbC5zdGF0ZSAmJiBvYmoub3JpZ2luYWwuc3RhdGUudW5kZXRlcm1pbmVkKSB7XFxuICAgICAgICAgICAgb2JqLm9yaWdpbmFsLnN0YXRlLnVuZGV0ZXJtaW5lZCA9IGZhbHNlO1xcbiAgICAgICAgICB9IC8vIGFwcGx5IGRvd25cXG5cXG5cXG4gICAgICAgICAgaWYgKHMuaW5kZXhPZignZG93bicpICE9PSAtMSkge1xcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGogPSBvYmouY2hpbGRyZW5fZC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG4gICAgICAgICAgICAgIHRtcCA9IHRoaXMuX21vZGVsLmRhdGFbb2JqLmNoaWxkcmVuX2RbaV1dO1xcbiAgICAgICAgICAgICAgdG1wLnN0YXRlW3QgPyAnc2VsZWN0ZWQnIDogJ2NoZWNrZWQnXSA9IGZhbHNlO1xcblxcbiAgICAgICAgICAgICAgaWYgKHRtcCAmJiB0bXAub3JpZ2luYWwgJiYgdG1wLm9yaWdpbmFsLnN0YXRlICYmIHRtcC5vcmlnaW5hbC5zdGF0ZS51bmRldGVybWluZWQpIHtcXG4gICAgICAgICAgICAgICAgdG1wLm9yaWdpbmFsLnN0YXRlLnVuZGV0ZXJtaW5lZCA9IGZhbHNlO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSAvLyBhcHBseSB1cFxcblxcblxcbiAgICAgICAgICBpZiAocy5pbmRleE9mKCd1cCcpICE9PSAtMSkge1xcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGogPSBvYmoucGFyZW50cy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG4gICAgICAgICAgICAgIHRtcCA9IHRoaXMuX21vZGVsLmRhdGFbb2JqLnBhcmVudHNbaV1dO1xcbiAgICAgICAgICAgICAgdG1wLnN0YXRlW3QgPyAnc2VsZWN0ZWQnIDogJ2NoZWNrZWQnXSA9IGZhbHNlO1xcblxcbiAgICAgICAgICAgICAgaWYgKHRtcCAmJiB0bXAub3JpZ2luYWwgJiYgdG1wLm9yaWdpbmFsLnN0YXRlICYmIHRtcC5vcmlnaW5hbC5zdGF0ZS51bmRldGVybWluZWQpIHtcXG4gICAgICAgICAgICAgICAgdG1wLm9yaWdpbmFsLnN0YXRlLnVuZGV0ZXJtaW5lZCA9IGZhbHNlO1xcbiAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgdG1wID0gdGhpcy5nZXRfbm9kZShvYmoucGFyZW50c1tpXSwgdHJ1ZSk7XFxuXFxuICAgICAgICAgICAgICBpZiAodG1wICYmIHRtcC5sZW5ndGgpIHtcXG4gICAgICAgICAgICAgICAgdG1wLmF0dHIoJ2FyaWEtc2VsZWN0ZWQnLCBmYWxzZSkuY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykucmVtb3ZlQ2xhc3ModCA/ICdqc3RyZWUtY2xpY2tlZCcgOiAnanN0cmVlLWNoZWNrZWQnKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgc2VsID0ge307XFxuXFxuICAgICAgICAgIGZvciAoaSA9IDAsIGogPSBjdXIubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICAgICAgLy8gYXBwbHkgZG93biArIGFwcGx5IHVwXFxuICAgICAgICAgICAgaWYgKChzLmluZGV4T2YoJ2Rvd24nKSA9PT0gLTEgfHwgJC5pbkFycmF5KGN1cltpXSwgb2JqLmNoaWxkcmVuX2QpID09PSAtMSkgJiYgKHMuaW5kZXhPZigndXAnKSA9PT0gLTEgfHwgJC5pbkFycmF5KGN1cltpXSwgb2JqLnBhcmVudHMpID09PSAtMSkpIHtcXG4gICAgICAgICAgICAgIHNlbFtjdXJbaV1dID0gdHJ1ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgY3VyID0gW107XFxuXFxuICAgICAgICAgIGZvciAoaSBpbiBzZWwpIHtcXG4gICAgICAgICAgICBpZiAoc2VsLmhhc093blByb3BlcnR5KGkpKSB7XFxuICAgICAgICAgICAgICBjdXIucHVzaChpKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgdGhpcy5fZGF0YVt0ID8gJ2NvcmUnIDogJ2NoZWNrYm94J10uc2VsZWN0ZWQgPSBjdXI7IC8vIGFwcGx5IGRvd24gKHByb2Nlc3MgLmNoaWxkcmVuIHNlcGFyYXRlbHk/KVxcblxcbiAgICAgICAgICBpZiAocy5pbmRleE9mKCdkb3duJykgIT09IC0xICYmIGRvbS5sZW5ndGgpIHtcXG4gICAgICAgICAgICBkb20uZmluZCgnLmpzdHJlZS1hbmNob3InKS5yZW1vdmVDbGFzcyh0ID8gJ2pzdHJlZS1jbGlja2VkJyA6ICdqc3RyZWUtY2hlY2tlZCcpLnBhcmVudCgpLmF0dHIoJ2FyaWEtc2VsZWN0ZWQnLCBmYWxzZSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0sIHRoaXMpKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuY2hlY2tib3guY2FzY2FkZS5pbmRleE9mKCd1cCcpICE9PSAtMSkge1xcbiAgICAgICAgdGhpcy5lbGVtZW50Lm9uKCdkZWxldGVfbm9kZS5qc3RyZWUnLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XFxuICAgICAgICAgIC8vIGFwcGx5IHVwICh3aG9sZSBoYW5kbGVyKVxcbiAgICAgICAgICB2YXIgcCA9IHRoaXMuZ2V0X25vZGUoZGF0YS5wYXJlbnQpLFxcbiAgICAgICAgICAgICAgbSA9IHRoaXMuX21vZGVsLmRhdGEsXFxuICAgICAgICAgICAgICBpLFxcbiAgICAgICAgICAgICAgaixcXG4gICAgICAgICAgICAgIGMsXFxuICAgICAgICAgICAgICB0bXAsXFxuICAgICAgICAgICAgICB0ID0gdGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uO1xcblxcbiAgICAgICAgICB3aGlsZSAocCAmJiBwLmlkICE9PSAkLmpzdHJlZS5yb290ICYmICFwLnN0YXRlW3QgPyAnc2VsZWN0ZWQnIDogJ2NoZWNrZWQnXSkge1xcbiAgICAgICAgICAgIGMgPSAwO1xcblxcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGogPSBwLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcbiAgICAgICAgICAgICAgYyArPSBtW3AuY2hpbGRyZW5baV1dLnN0YXRlW3QgPyAnc2VsZWN0ZWQnIDogJ2NoZWNrZWQnXTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaWYgKGogPiAwICYmIGMgPT09IGopIHtcXG4gICAgICAgICAgICAgIHAuc3RhdGVbdCA/ICdzZWxlY3RlZCcgOiAnY2hlY2tlZCddID0gdHJ1ZTtcXG5cXG4gICAgICAgICAgICAgIHRoaXMuX2RhdGFbdCA/ICdjb3JlJyA6ICdjaGVja2JveCddLnNlbGVjdGVkLnB1c2gocC5pZCk7XFxuXFxuICAgICAgICAgICAgICB0bXAgPSB0aGlzLmdldF9ub2RlKHAsIHRydWUpO1xcblxcbiAgICAgICAgICAgICAgaWYgKHRtcCAmJiB0bXAubGVuZ3RoKSB7XFxuICAgICAgICAgICAgICAgIHRtcC5hdHRyKCdhcmlhLXNlbGVjdGVkJywgdHJ1ZSkuY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuYWRkQ2xhc3ModCA/ICdqc3RyZWUtY2xpY2tlZCcgOiAnanN0cmVlLWNoZWNrZWQnKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIHAgPSB0aGlzLmdldF9ub2RlKHAucGFyZW50KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSwgdGhpcykpLm9uKCdtb3ZlX25vZGUuanN0cmVlJywgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xcbiAgICAgICAgICAvLyBhcHBseSB1cCAod2hvbGUgaGFuZGxlcilcXG4gICAgICAgICAgdmFyIGlzX211bHRpID0gZGF0YS5pc19tdWx0aSxcXG4gICAgICAgICAgICAgIG9sZF9wYXIgPSBkYXRhLm9sZF9wYXJlbnQsXFxuICAgICAgICAgICAgICBuZXdfcGFyID0gdGhpcy5nZXRfbm9kZShkYXRhLnBhcmVudCksXFxuICAgICAgICAgICAgICBtID0gdGhpcy5fbW9kZWwuZGF0YSxcXG4gICAgICAgICAgICAgIHAsXFxuICAgICAgICAgICAgICBjLFxcbiAgICAgICAgICAgICAgaSxcXG4gICAgICAgICAgICAgIGosXFxuICAgICAgICAgICAgICB0bXAsXFxuICAgICAgICAgICAgICB0ID0gdGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uO1xcblxcbiAgICAgICAgICBpZiAoIWlzX211bHRpKSB7XFxuICAgICAgICAgICAgcCA9IHRoaXMuZ2V0X25vZGUob2xkX3Bhcik7XFxuXFxuICAgICAgICAgICAgd2hpbGUgKHAgJiYgcC5pZCAhPT0gJC5qc3RyZWUucm9vdCAmJiAhcC5zdGF0ZVt0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJ10pIHtcXG4gICAgICAgICAgICAgIGMgPSAwO1xcblxcbiAgICAgICAgICAgICAgZm9yIChpID0gMCwgaiA9IHAuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICAgICAgICAgIGMgKz0gbVtwLmNoaWxkcmVuW2ldXS5zdGF0ZVt0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJ107XFxuICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICBpZiAoaiA+IDAgJiYgYyA9PT0gaikge1xcbiAgICAgICAgICAgICAgICBwLnN0YXRlW3QgPyAnc2VsZWN0ZWQnIDogJ2NoZWNrZWQnXSA9IHRydWU7XFxuXFxuICAgICAgICAgICAgICAgIHRoaXMuX2RhdGFbdCA/ICdjb3JlJyA6ICdjaGVja2JveCddLnNlbGVjdGVkLnB1c2gocC5pZCk7XFxuXFxuICAgICAgICAgICAgICAgIHRtcCA9IHRoaXMuZ2V0X25vZGUocCwgdHJ1ZSk7XFxuXFxuICAgICAgICAgICAgICAgIGlmICh0bXAgJiYgdG1wLmxlbmd0aCkge1xcbiAgICAgICAgICAgICAgICAgIHRtcC5hdHRyKCdhcmlhLXNlbGVjdGVkJywgdHJ1ZSkuY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuYWRkQ2xhc3ModCA/ICdqc3RyZWUtY2xpY2tlZCcgOiAnanN0cmVlLWNoZWNrZWQnKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICBwID0gdGhpcy5nZXRfbm9kZShwLnBhcmVudCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHAgPSBuZXdfcGFyO1xcblxcbiAgICAgICAgICB3aGlsZSAocCAmJiBwLmlkICE9PSAkLmpzdHJlZS5yb290KSB7XFxuICAgICAgICAgICAgYyA9IDA7XFxuXFxuICAgICAgICAgICAgZm9yIChpID0gMCwgaiA9IHAuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICAgICAgICBjICs9IG1bcC5jaGlsZHJlbltpXV0uc3RhdGVbdCA/ICdzZWxlY3RlZCcgOiAnY2hlY2tlZCddO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpZiAoYyA9PT0gaikge1xcbiAgICAgICAgICAgICAgaWYgKCFwLnN0YXRlW3QgPyAnc2VsZWN0ZWQnIDogJ2NoZWNrZWQnXSkge1xcbiAgICAgICAgICAgICAgICBwLnN0YXRlW3QgPyAnc2VsZWN0ZWQnIDogJ2NoZWNrZWQnXSA9IHRydWU7XFxuXFxuICAgICAgICAgICAgICAgIHRoaXMuX2RhdGFbdCA/ICdjb3JlJyA6ICdjaGVja2JveCddLnNlbGVjdGVkLnB1c2gocC5pZCk7XFxuXFxuICAgICAgICAgICAgICAgIHRtcCA9IHRoaXMuZ2V0X25vZGUocCwgdHJ1ZSk7XFxuXFxuICAgICAgICAgICAgICAgIGlmICh0bXAgJiYgdG1wLmxlbmd0aCkge1xcbiAgICAgICAgICAgICAgICAgIHRtcC5hdHRyKCdhcmlhLXNlbGVjdGVkJywgdHJ1ZSkuY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuYWRkQ2xhc3ModCA/ICdqc3RyZWUtY2xpY2tlZCcgOiAnanN0cmVlLWNoZWNrZWQnKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICBpZiAocC5zdGF0ZVt0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJ10pIHtcXG4gICAgICAgICAgICAgICAgcC5zdGF0ZVt0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJ10gPSBmYWxzZTtcXG4gICAgICAgICAgICAgICAgdGhpcy5fZGF0YVt0ID8gJ2NvcmUnIDogJ2NoZWNrYm94J10uc2VsZWN0ZWQgPSAkLnZha2F0YS5hcnJheV9yZW1vdmVfaXRlbSh0aGlzLl9kYXRhW3QgPyAnY29yZScgOiAnY2hlY2tib3gnXS5zZWxlY3RlZCwgcC5pZCk7XFxuICAgICAgICAgICAgICAgIHRtcCA9IHRoaXMuZ2V0X25vZGUocCwgdHJ1ZSk7XFxuXFxuICAgICAgICAgICAgICAgIGlmICh0bXAgJiYgdG1wLmxlbmd0aCkge1xcbiAgICAgICAgICAgICAgICAgIHRtcC5hdHRyKCdhcmlhLXNlbGVjdGVkJywgZmFsc2UpLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLnJlbW92ZUNsYXNzKHQgPyAnanN0cmVlLWNsaWNrZWQnIDogJ2pzdHJlZS1jaGVja2VkJyk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBwID0gdGhpcy5nZXRfbm9kZShwLnBhcmVudCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0sIHRoaXMpKTtcXG4gICAgICB9XFxuICAgIH07XFxuICAgIC8qKlxcbiAgICAgKiBzZXQgdGhlIHVuZGV0ZXJtaW5lZCBzdGF0ZSB3aGVyZSBhbmQgaWYgbmVjZXNzYXJ5LiBVc2VkIGludGVybmFsbHkuXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBuYW1lIF91bmRldGVybWluZWQoKVxcbiAgICAgKiBAcGx1Z2luIGNoZWNrYm94XFxuICAgICAqL1xcblxcblxcbiAgICB0aGlzLl91bmRldGVybWluZWQgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgaWYgKHRoaXMuZWxlbWVudCA9PT0gbnVsbCkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgaSxcXG4gICAgICAgICAgaixcXG4gICAgICAgICAgayxcXG4gICAgICAgICAgbCxcXG4gICAgICAgICAgbyA9IHt9LFxcbiAgICAgICAgICBtID0gdGhpcy5fbW9kZWwuZGF0YSxcXG4gICAgICAgICAgdCA9IHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbixcXG4gICAgICAgICAgcyA9IHRoaXMuX2RhdGFbdCA/ICdjb3JlJyA6ICdjaGVja2JveCddLnNlbGVjdGVkLFxcbiAgICAgICAgICBwID0gW10sXFxuICAgICAgICAgIHR0ID0gdGhpcztcXG5cXG4gICAgICBmb3IgKGkgPSAwLCBqID0gcy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG4gICAgICAgIGlmIChtW3NbaV1dICYmIG1bc1tpXV0ucGFyZW50cykge1xcbiAgICAgICAgICBmb3IgKGsgPSAwLCBsID0gbVtzW2ldXS5wYXJlbnRzLmxlbmd0aDsgayA8IGw7IGsrKykge1xcbiAgICAgICAgICAgIGlmIChvW21bc1tpXV0ucGFyZW50c1trXV0gIT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmIChtW3NbaV1dLnBhcmVudHNba10gIT09ICQuanN0cmVlLnJvb3QpIHtcXG4gICAgICAgICAgICAgIG9bbVtzW2ldXS5wYXJlbnRzW2tdXSA9IHRydWU7XFxuICAgICAgICAgICAgICBwLnB1c2gobVtzW2ldXS5wYXJlbnRzW2tdKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9IC8vIGF0dGVtcHQgZm9yIHNlcnZlciBzaWRlIHVuZGV0ZXJtaW5lZCBzdGF0ZVxcblxcblxcbiAgICAgIHRoaXMuZWxlbWVudC5maW5kKCcuanN0cmVlLWNsb3NlZCcpLm5vdCgnOmhhcyguanN0cmVlLWNoaWxkcmVuKScpLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIHRtcCA9IHR0LmdldF9ub2RlKHRoaXMpLFxcbiAgICAgICAgICAgIHRtcDI7XFxuXFxuICAgICAgICBpZiAoIXRtcC5zdGF0ZS5sb2FkZWQpIHtcXG4gICAgICAgICAgaWYgKHRtcC5vcmlnaW5hbCAmJiB0bXAub3JpZ2luYWwuc3RhdGUgJiYgdG1wLm9yaWdpbmFsLnN0YXRlLnVuZGV0ZXJtaW5lZCAmJiB0bXAub3JpZ2luYWwuc3RhdGUudW5kZXRlcm1pbmVkID09PSB0cnVlKSB7XFxuICAgICAgICAgICAgaWYgKG9bdG1wLmlkXSA9PT0gdW5kZWZpbmVkICYmIHRtcC5pZCAhPT0gJC5qc3RyZWUucm9vdCkge1xcbiAgICAgICAgICAgICAgb1t0bXAuaWRdID0gdHJ1ZTtcXG4gICAgICAgICAgICAgIHAucHVzaCh0bXAuaWQpO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBmb3IgKGsgPSAwLCBsID0gdG1wLnBhcmVudHMubGVuZ3RoOyBrIDwgbDsgaysrKSB7XFxuICAgICAgICAgICAgICBpZiAob1t0bXAucGFyZW50c1trXV0gPT09IHVuZGVmaW5lZCAmJiB0bXAucGFyZW50c1trXSAhPT0gJC5qc3RyZWUucm9vdCkge1xcbiAgICAgICAgICAgICAgICBvW3RtcC5wYXJlbnRzW2tdXSA9IHRydWU7XFxuICAgICAgICAgICAgICAgIHAucHVzaCh0bXAucGFyZW50c1trXSk7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBmb3IgKGkgPSAwLCBqID0gdG1wLmNoaWxkcmVuX2QubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICAgICAgdG1wMiA9IG1bdG1wLmNoaWxkcmVuX2RbaV1dO1xcblxcbiAgICAgICAgICAgIGlmICghdG1wMi5zdGF0ZS5sb2FkZWQgJiYgdG1wMi5vcmlnaW5hbCAmJiB0bXAyLm9yaWdpbmFsLnN0YXRlICYmIHRtcDIub3JpZ2luYWwuc3RhdGUudW5kZXRlcm1pbmVkICYmIHRtcDIub3JpZ2luYWwuc3RhdGUudW5kZXRlcm1pbmVkID09PSB0cnVlKSB7XFxuICAgICAgICAgICAgICBpZiAob1t0bXAyLmlkXSA9PT0gdW5kZWZpbmVkICYmIHRtcDIuaWQgIT09ICQuanN0cmVlLnJvb3QpIHtcXG4gICAgICAgICAgICAgICAgb1t0bXAyLmlkXSA9IHRydWU7XFxuICAgICAgICAgICAgICAgIHAucHVzaCh0bXAyLmlkKTtcXG4gICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgIGZvciAoayA9IDAsIGwgPSB0bXAyLnBhcmVudHMubGVuZ3RoOyBrIDwgbDsgaysrKSB7XFxuICAgICAgICAgICAgICAgIGlmIChvW3RtcDIucGFyZW50c1trXV0gPT09IHVuZGVmaW5lZCAmJiB0bXAyLnBhcmVudHNba10gIT09ICQuanN0cmVlLnJvb3QpIHtcXG4gICAgICAgICAgICAgICAgICBvW3RtcDIucGFyZW50c1trXV0gPSB0cnVlO1xcbiAgICAgICAgICAgICAgICAgIHAucHVzaCh0bXAyLnBhcmVudHNba10pO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgICAgdGhpcy5lbGVtZW50LmZpbmQoJy5qc3RyZWUtdW5kZXRlcm1pbmVkJykucmVtb3ZlQ2xhc3MoJ2pzdHJlZS11bmRldGVybWluZWQnKTtcXG5cXG4gICAgICBmb3IgKGkgPSAwLCBqID0gcC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG4gICAgICAgIGlmICghbVtwW2ldXS5zdGF0ZVt0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJ10pIHtcXG4gICAgICAgICAgcyA9IHRoaXMuZ2V0X25vZGUocFtpXSwgdHJ1ZSk7XFxuXFxuICAgICAgICAgIGlmIChzICYmIHMubGVuZ3RoKSB7XFxuICAgICAgICAgICAgcy5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5jaGlsZHJlbignLmpzdHJlZS1jaGVja2JveCcpLmFkZENsYXNzKCdqc3RyZWUtdW5kZXRlcm1pbmVkJyk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH07XFxuXFxuICAgIHRoaXMucmVkcmF3X25vZGUgPSBmdW5jdGlvbiAob2JqLCBkZWVwLCBpc19jYWxsYmFjaywgZm9yY2VfcmVuZGVyKSB7XFxuICAgICAgb2JqID0gcGFyZW50LnJlZHJhd19ub2RlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuXFxuICAgICAgaWYgKG9iaikge1xcbiAgICAgICAgdmFyIGksXFxuICAgICAgICAgICAgaixcXG4gICAgICAgICAgICB0bXAgPSBudWxsLFxcbiAgICAgICAgICAgIGljb24gPSBudWxsO1xcblxcbiAgICAgICAgZm9yIChpID0gMCwgaiA9IG9iai5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcbiAgICAgICAgICBpZiAob2JqLmNoaWxkTm9kZXNbaV0gJiYgb2JqLmNoaWxkTm9kZXNbaV0uY2xhc3NOYW1lICYmIG9iai5jaGlsZE5vZGVzW2ldLmNsYXNzTmFtZS5pbmRleE9mKFxcXCJqc3RyZWUtYW5jaG9yXFxcIikgIT09IC0xKSB7XFxuICAgICAgICAgICAgdG1wID0gb2JqLmNoaWxkTm9kZXNbaV07XFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICh0bXApIHtcXG4gICAgICAgICAgaWYgKCF0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb24gJiYgdGhpcy5fbW9kZWwuZGF0YVtvYmouaWRdLnN0YXRlLmNoZWNrZWQpIHtcXG4gICAgICAgICAgICB0bXAuY2xhc3NOYW1lICs9ICcganN0cmVlLWNoZWNrZWQnO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGljb24gPSBfaS5jbG9uZU5vZGUoZmFsc2UpO1xcblxcbiAgICAgICAgICBpZiAodGhpcy5fbW9kZWwuZGF0YVtvYmouaWRdLnN0YXRlLmNoZWNrYm94X2Rpc2FibGVkKSB7XFxuICAgICAgICAgICAgaWNvbi5jbGFzc05hbWUgKz0gJyBqc3RyZWUtY2hlY2tib3gtZGlzYWJsZWQnO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHRtcC5pbnNlcnRCZWZvcmUoaWNvbiwgdG1wLmNoaWxkTm9kZXNbMF0pO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIWlzX2NhbGxiYWNrICYmIHRoaXMuc2V0dGluZ3MuY2hlY2tib3guY2FzY2FkZS5pbmRleE9mKCd1bmRldGVybWluZWQnKSAhPT0gLTEpIHtcXG4gICAgICAgIGlmICh0aGlzLl9kYXRhLmNoZWNrYm94LnV0bykge1xcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fZGF0YS5jaGVja2JveC51dG8pO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdGhpcy5fZGF0YS5jaGVja2JveC51dG8gPSBzZXRUaW1lb3V0KCQucHJveHkodGhpcy5fdW5kZXRlcm1pbmVkLCB0aGlzKSwgNTApO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gb2JqO1xcbiAgICB9O1xcbiAgICAvKipcXG4gICAgICogc2hvdyB0aGUgbm9kZSBjaGVja2JveCBpY29uc1xcbiAgICAgKiBAbmFtZSBzaG93X2NoZWNrYm94ZXMoKVxcbiAgICAgKiBAcGx1Z2luIGNoZWNrYm94XFxuICAgICAqL1xcblxcblxcbiAgICB0aGlzLnNob3dfY2hlY2tib3hlcyA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICB0aGlzLl9kYXRhLmNvcmUudGhlbWVzLmNoZWNrYm94ZXMgPSB0cnVlO1xcbiAgICAgIHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpLnJlbW92ZUNsYXNzKFxcXCJqc3RyZWUtbm8tY2hlY2tib3hlc1xcXCIpO1xcbiAgICB9O1xcbiAgICAvKipcXG4gICAgICogaGlkZSB0aGUgbm9kZSBjaGVja2JveCBpY29uc1xcbiAgICAgKiBAbmFtZSBoaWRlX2NoZWNrYm94ZXMoKVxcbiAgICAgKiBAcGx1Z2luIGNoZWNrYm94XFxuICAgICAqL1xcblxcblxcbiAgICB0aGlzLmhpZGVfY2hlY2tib3hlcyA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICB0aGlzLl9kYXRhLmNvcmUudGhlbWVzLmNoZWNrYm94ZXMgPSBmYWxzZTtcXG4gICAgICB0aGlzLmdldF9jb250YWluZXJfdWwoKS5hZGRDbGFzcyhcXFwianN0cmVlLW5vLWNoZWNrYm94ZXNcXFwiKTtcXG4gICAgfTtcXG4gICAgLyoqXFxuICAgICAqIHRvZ2dsZSB0aGUgbm9kZSBpY29uc1xcbiAgICAgKiBAbmFtZSB0b2dnbGVfY2hlY2tib3hlcygpXFxuICAgICAqIEBwbHVnaW4gY2hlY2tib3hcXG4gICAgICovXFxuXFxuXFxuICAgIHRoaXMudG9nZ2xlX2NoZWNrYm94ZXMgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgaWYgKHRoaXMuX2RhdGEuY29yZS50aGVtZXMuY2hlY2tib3hlcykge1xcbiAgICAgICAgdGhpcy5oaWRlX2NoZWNrYm94ZXMoKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdGhpcy5zaG93X2NoZWNrYm94ZXMoKTtcXG4gICAgICB9XFxuICAgIH07XFxuICAgIC8qKlxcbiAgICAgKiBjaGVja3MgaWYgYSBub2RlIGlzIGluIGFuIHVuZGV0ZXJtaW5lZCBzdGF0ZVxcbiAgICAgKiBAbmFtZSBpc191bmRldGVybWluZWQob2JqKVxcbiAgICAgKiBAcGFyYW0gIHttaXhlZH0gb2JqXFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XFxuICAgICAqL1xcblxcblxcbiAgICB0aGlzLmlzX3VuZGV0ZXJtaW5lZCA9IGZ1bmN0aW9uIChvYmopIHtcXG4gICAgICBvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XFxuICAgICAgdmFyIHMgPSB0aGlzLnNldHRpbmdzLmNoZWNrYm94LmNhc2NhZGUsXFxuICAgICAgICAgIGksXFxuICAgICAgICAgIGosXFxuICAgICAgICAgIHQgPSB0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb24sXFxuICAgICAgICAgIGQgPSB0aGlzLl9kYXRhW3QgPyAnY29yZScgOiAnY2hlY2tib3gnXS5zZWxlY3RlZCxcXG4gICAgICAgICAgbSA9IHRoaXMuX21vZGVsLmRhdGE7XFxuXFxuICAgICAgaWYgKCFvYmogfHwgb2JqLnN0YXRlW3QgPyAnc2VsZWN0ZWQnIDogJ2NoZWNrZWQnXSA9PT0gdHJ1ZSB8fCBzLmluZGV4T2YoJ3VuZGV0ZXJtaW5lZCcpID09PSAtMSB8fCBzLmluZGV4T2YoJ2Rvd24nKSA9PT0gLTEgJiYgcy5pbmRleE9mKCd1cCcpID09PSAtMSkge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIW9iai5zdGF0ZS5sb2FkZWQgJiYgb2JqLm9yaWdpbmFsLnN0YXRlLnVuZGV0ZXJtaW5lZCA9PT0gdHJ1ZSkge1xcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgfVxcblxcbiAgICAgIGZvciAoaSA9IDAsIGogPSBvYmouY2hpbGRyZW5fZC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG4gICAgICAgIGlmICgkLmluQXJyYXkob2JqLmNoaWxkcmVuX2RbaV0sIGQpICE9PSAtMSB8fCAhbVtvYmouY2hpbGRyZW5fZFtpXV0uc3RhdGUubG9hZGVkICYmIG1bb2JqLmNoaWxkcmVuX2RbaV1dLm9yaWdpbmFsLnN0YXRlLnVuZGV0ZXJtaW5lZCkge1xcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9O1xcbiAgICAvKipcXG4gICAgICogZGlzYWJsZSBhIG5vZGUncyBjaGVja2JveFxcbiAgICAgKiBAbmFtZSBkaXNhYmxlX2NoZWNrYm94KG9iailcXG4gICAgICogQHBhcmFtIHttaXhlZH0gb2JqIGFuIGFycmF5IGNhbiBiZSB1c2VkIHRvb1xcbiAgICAgKiBAdHJpZ2dlciBkaXNhYmxlX2NoZWNrYm94LmpzdHJlZVxcbiAgICAgKiBAcGx1Z2luIGNoZWNrYm94XFxuICAgICAqL1xcblxcblxcbiAgICB0aGlzLmRpc2FibGVfY2hlY2tib3ggPSBmdW5jdGlvbiAob2JqKSB7XFxuICAgICAgdmFyIHQxLCB0MiwgZG9tO1xcblxcbiAgICAgIGlmICgkLmlzQXJyYXkob2JqKSkge1xcbiAgICAgICAgb2JqID0gb2JqLnNsaWNlKCk7XFxuXFxuICAgICAgICBmb3IgKHQxID0gMCwgdDIgPSBvYmoubGVuZ3RoOyB0MSA8IHQyOyB0MSsrKSB7XFxuICAgICAgICAgIHRoaXMuZGlzYWJsZV9jaGVja2JveChvYmpbdDFdKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgIH1cXG5cXG4gICAgICBvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XFxuXFxuICAgICAgaWYgKCFvYmogfHwgb2JqLmlkID09PSAkLmpzdHJlZS5yb290KSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcblxcbiAgICAgIGRvbSA9IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKTtcXG5cXG4gICAgICBpZiAoIW9iai5zdGF0ZS5jaGVja2JveF9kaXNhYmxlZCkge1xcbiAgICAgICAgb2JqLnN0YXRlLmNoZWNrYm94X2Rpc2FibGVkID0gdHJ1ZTtcXG5cXG4gICAgICAgIGlmIChkb20gJiYgZG9tLmxlbmd0aCkge1xcbiAgICAgICAgICBkb20uY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuY2hpbGRyZW4oJy5qc3RyZWUtY2hlY2tib3gnKS5hZGRDbGFzcygnanN0cmVlLWNoZWNrYm94LWRpc2FibGVkJyk7XFxuICAgICAgICB9XFxuICAgICAgICAvKipcXG4gICAgICAgICAqIHRyaWdnZXJlZCB3aGVuIGFuIG5vZGUncyBjaGVja2JveCBpcyBkaXNhYmxlZFxcbiAgICAgICAgICogQGV2ZW50XFxuICAgICAgICAgKiBAbmFtZSBkaXNhYmxlX2NoZWNrYm94LmpzdHJlZVxcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGVcXG4gICAgICAgICAqIEBwbHVnaW4gY2hlY2tib3hcXG4gICAgICAgICAqL1xcblxcblxcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdkaXNhYmxlX2NoZWNrYm94Jywge1xcbiAgICAgICAgICAnbm9kZSc6IG9ialxcbiAgICAgICAgfSk7XFxuICAgICAgfVxcbiAgICB9O1xcbiAgICAvKipcXG4gICAgICogZW5hYmxlIGEgbm9kZSdzIGNoZWNrYm94XFxuICAgICAqIEBuYW1lIGRpc2FibGVfY2hlY2tib3gob2JqKVxcbiAgICAgKiBAcGFyYW0ge21peGVkfSBvYmogYW4gYXJyYXkgY2FuIGJlIHVzZWQgdG9vXFxuICAgICAqIEB0cmlnZ2VyIGVuYWJsZV9jaGVja2JveC5qc3RyZWVcXG4gICAgICogQHBsdWdpbiBjaGVja2JveFxcbiAgICAgKi9cXG5cXG5cXG4gICAgdGhpcy5lbmFibGVfY2hlY2tib3ggPSBmdW5jdGlvbiAob2JqKSB7XFxuICAgICAgdmFyIHQxLCB0MiwgZG9tO1xcblxcbiAgICAgIGlmICgkLmlzQXJyYXkob2JqKSkge1xcbiAgICAgICAgb2JqID0gb2JqLnNsaWNlKCk7XFxuXFxuICAgICAgICBmb3IgKHQxID0gMCwgdDIgPSBvYmoubGVuZ3RoOyB0MSA8IHQyOyB0MSsrKSB7XFxuICAgICAgICAgIHRoaXMuZW5hYmxlX2NoZWNrYm94KG9ialt0MV0pO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgfVxcblxcbiAgICAgIG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXG4gICAgICBpZiAoIW9iaiB8fCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgZG9tID0gdGhpcy5nZXRfbm9kZShvYmosIHRydWUpO1xcblxcbiAgICAgIGlmIChvYmouc3RhdGUuY2hlY2tib3hfZGlzYWJsZWQpIHtcXG4gICAgICAgIG9iai5zdGF0ZS5jaGVja2JveF9kaXNhYmxlZCA9IGZhbHNlO1xcblxcbiAgICAgICAgaWYgKGRvbSAmJiBkb20ubGVuZ3RoKSB7XFxuICAgICAgICAgIGRvbS5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5jaGlsZHJlbignLmpzdHJlZS1jaGVja2JveCcpLnJlbW92ZUNsYXNzKCdqc3RyZWUtY2hlY2tib3gtZGlzYWJsZWQnKTtcXG4gICAgICAgIH1cXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogdHJpZ2dlcmVkIHdoZW4gYW4gbm9kZSdzIGNoZWNrYm94IGlzIGVuYWJsZWRcXG4gICAgICAgICAqIEBldmVudFxcbiAgICAgICAgICogQG5hbWUgZW5hYmxlX2NoZWNrYm94LmpzdHJlZVxcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGVcXG4gICAgICAgICAqIEBwbHVnaW4gY2hlY2tib3hcXG4gICAgICAgICAqL1xcblxcblxcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdlbmFibGVfY2hlY2tib3gnLCB7XFxuICAgICAgICAgICdub2RlJzogb2JqXFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuICAgIH07XFxuXFxuICAgIHRoaXMuYWN0aXZhdGVfbm9kZSA9IGZ1bmN0aW9uIChvYmosIGUpIHtcXG4gICAgICBpZiAoJChlLnRhcmdldCkuaGFzQ2xhc3MoJ2pzdHJlZS1jaGVja2JveC1kaXNhYmxlZCcpKSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb24gJiYgKHRoaXMuc2V0dGluZ3MuY2hlY2tib3gud2hvbGVfbm9kZSB8fCAkKGUudGFyZ2V0KS5oYXNDbGFzcygnanN0cmVlLWNoZWNrYm94JykpKSB7XFxuICAgICAgICBlLmN0cmxLZXkgPSB0cnVlO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uIHx8ICF0aGlzLnNldHRpbmdzLmNoZWNrYm94Lndob2xlX25vZGUgJiYgISQoZS50YXJnZXQpLmhhc0NsYXNzKCdqc3RyZWUtY2hlY2tib3gnKSkge1xcbiAgICAgICAgcmV0dXJuIHBhcmVudC5hY3RpdmF0ZV9ub2RlLmNhbGwodGhpcywgb2JqLCBlKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMuaXNfZGlzYWJsZWQob2JqKSkge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5pc19jaGVja2VkKG9iaikpIHtcXG4gICAgICAgIHRoaXMudW5jaGVja19ub2RlKG9iaiwgZSk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRoaXMuY2hlY2tfbm9kZShvYmosIGUpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLnRyaWdnZXIoJ2FjdGl2YXRlX25vZGUnLCB7XFxuICAgICAgICAnbm9kZSc6IHRoaXMuZ2V0X25vZGUob2JqKVxcbiAgICAgIH0pO1xcbiAgICB9O1xcbiAgICAvKipcXG4gICAgICogY2hlY2sgYSBub2RlIChvbmx5IGlmIHRpZV9zZWxlY3Rpb24gaW4gY2hlY2tib3ggc2V0dGluZ3MgaXMgZmFsc2UsIG90aGVyd2lzZSBzZWxlY3Rfbm9kZSB3aWxsIGJlIGNhbGxlZCBpbnRlcm5hbGx5KVxcbiAgICAgKiBAbmFtZSBjaGVja19ub2RlKG9iailcXG4gICAgICogQHBhcmFtIHttaXhlZH0gb2JqIGFuIGFycmF5IGNhbiBiZSB1c2VkIHRvIGNoZWNrIG11bHRpcGxlIG5vZGVzXFxuICAgICAqIEB0cmlnZ2VyIGNoZWNrX25vZGUuanN0cmVlXFxuICAgICAqIEBwbHVnaW4gY2hlY2tib3hcXG4gICAgICovXFxuXFxuXFxuICAgIHRoaXMuY2hlY2tfbm9kZSA9IGZ1bmN0aW9uIChvYmosIGUpIHtcXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rfbm9kZShvYmosIGZhbHNlLCB0cnVlLCBlKTtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIGRvbSwgdDEsIHQyLCB0aDtcXG5cXG4gICAgICBpZiAoJC5pc0FycmF5KG9iaikpIHtcXG4gICAgICAgIG9iaiA9IG9iai5zbGljZSgpO1xcblxcbiAgICAgICAgZm9yICh0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xcbiAgICAgICAgICB0aGlzLmNoZWNrX25vZGUob2JqW3QxXSwgZSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICB9XFxuXFxuICAgICAgb2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xcblxcbiAgICAgIGlmICghb2JqIHx8IG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCkge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICBkb20gPSB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSk7XFxuXFxuICAgICAgaWYgKCFvYmouc3RhdGUuY2hlY2tlZCkge1xcbiAgICAgICAgb2JqLnN0YXRlLmNoZWNrZWQgPSB0cnVlO1xcblxcbiAgICAgICAgdGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZC5wdXNoKG9iai5pZCk7XFxuXFxuICAgICAgICBpZiAoZG9tICYmIGRvbS5sZW5ndGgpIHtcXG4gICAgICAgICAgZG9tLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLmFkZENsYXNzKCdqc3RyZWUtY2hlY2tlZCcpO1xcbiAgICAgICAgfVxcbiAgICAgICAgLyoqXFxuICAgICAgICAgKiB0cmlnZ2VyZWQgd2hlbiBhbiBub2RlIGlzIGNoZWNrZWQgKG9ubHkgaWYgdGllX3NlbGVjdGlvbiBpbiBjaGVja2JveCBzZXR0aW5ncyBpcyBmYWxzZSlcXG4gICAgICAgICAqIEBldmVudFxcbiAgICAgICAgICogQG5hbWUgY2hlY2tfbm9kZS5qc3RyZWVcXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlXFxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBzZWxlY3RlZCB0aGUgY3VycmVudCBzZWxlY3Rpb25cXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCB0aGUgZXZlbnQgKGlmIGFueSkgdGhhdCB0cmlnZ2VyZWQgdGhpcyBjaGVja19ub2RlXFxuICAgICAgICAgKiBAcGx1Z2luIGNoZWNrYm94XFxuICAgICAgICAgKi9cXG5cXG5cXG4gICAgICAgIHRoaXMudHJpZ2dlcignY2hlY2tfbm9kZScsIHtcXG4gICAgICAgICAgJ25vZGUnOiBvYmosXFxuICAgICAgICAgICdzZWxlY3RlZCc6IHRoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWQsXFxuICAgICAgICAgICdldmVudCc6IGVcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG4gICAgfTtcXG4gICAgLyoqXFxuICAgICAqIHVuY2hlY2sgYSBub2RlIChvbmx5IGlmIHRpZV9zZWxlY3Rpb24gaW4gY2hlY2tib3ggc2V0dGluZ3MgaXMgZmFsc2UsIG90aGVyd2lzZSBkZXNlbGVjdF9ub2RlIHdpbGwgYmUgY2FsbGVkIGludGVybmFsbHkpXFxuICAgICAqIEBuYW1lIHVuY2hlY2tfbm9kZShvYmopXFxuICAgICAqIEBwYXJhbSB7bWl4ZWR9IG9iaiBhbiBhcnJheSBjYW4gYmUgdXNlZCB0byB1bmNoZWNrIG11bHRpcGxlIG5vZGVzXFxuICAgICAqIEB0cmlnZ2VyIHVuY2hlY2tfbm9kZS5qc3RyZWVcXG4gICAgICogQHBsdWdpbiBjaGVja2JveFxcbiAgICAgKi9cXG5cXG5cXG4gICAgdGhpcy51bmNoZWNrX25vZGUgPSBmdW5jdGlvbiAob2JqLCBlKSB7XFxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbikge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVzZWxlY3Rfbm9kZShvYmosIGZhbHNlLCBlKTtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIHQxLCB0MiwgZG9tO1xcblxcbiAgICAgIGlmICgkLmlzQXJyYXkob2JqKSkge1xcbiAgICAgICAgb2JqID0gb2JqLnNsaWNlKCk7XFxuXFxuICAgICAgICBmb3IgKHQxID0gMCwgdDIgPSBvYmoubGVuZ3RoOyB0MSA8IHQyOyB0MSsrKSB7XFxuICAgICAgICAgIHRoaXMudW5jaGVja19ub2RlKG9ialt0MV0sIGUpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgfVxcblxcbiAgICAgIG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXG4gICAgICBpZiAoIW9iaiB8fCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgZG9tID0gdGhpcy5nZXRfbm9kZShvYmosIHRydWUpO1xcblxcbiAgICAgIGlmIChvYmouc3RhdGUuY2hlY2tlZCkge1xcbiAgICAgICAgb2JqLnN0YXRlLmNoZWNrZWQgPSBmYWxzZTtcXG4gICAgICAgIHRoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWQgPSAkLnZha2F0YS5hcnJheV9yZW1vdmVfaXRlbSh0aGlzLl9kYXRhLmNoZWNrYm94LnNlbGVjdGVkLCBvYmouaWQpO1xcblxcbiAgICAgICAgaWYgKGRvbS5sZW5ndGgpIHtcXG4gICAgICAgICAgZG9tLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLnJlbW92ZUNsYXNzKCdqc3RyZWUtY2hlY2tlZCcpO1xcbiAgICAgICAgfVxcbiAgICAgICAgLyoqXFxuICAgICAgICAgKiB0cmlnZ2VyZWQgd2hlbiBhbiBub2RlIGlzIHVuY2hlY2tlZCAob25seSBpZiB0aWVfc2VsZWN0aW9uIGluIGNoZWNrYm94IHNldHRpbmdzIGlzIGZhbHNlKVxcbiAgICAgICAgICogQGV2ZW50XFxuICAgICAgICAgKiBAbmFtZSB1bmNoZWNrX25vZGUuanN0cmVlXFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZVxcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gc2VsZWN0ZWQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uXFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgdGhlIGV2ZW50IChpZiBhbnkpIHRoYXQgdHJpZ2dlcmVkIHRoaXMgdW5jaGVja19ub2RlXFxuICAgICAgICAgKiBAcGx1Z2luIGNoZWNrYm94XFxuICAgICAgICAgKi9cXG5cXG5cXG4gICAgICAgIHRoaXMudHJpZ2dlcigndW5jaGVja19ub2RlJywge1xcbiAgICAgICAgICAnbm9kZSc6IG9iaixcXG4gICAgICAgICAgJ3NlbGVjdGVkJzogdGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZCxcXG4gICAgICAgICAgJ2V2ZW50JzogZVxcbiAgICAgICAgfSk7XFxuICAgICAgfVxcbiAgICB9O1xcbiAgICAvKipcXG4gICAgICogY2hlY2tzIGFsbCBub2RlcyBpbiB0aGUgdHJlZSAob25seSBpZiB0aWVfc2VsZWN0aW9uIGluIGNoZWNrYm94IHNldHRpbmdzIGlzIGZhbHNlLCBvdGhlcndpc2Ugc2VsZWN0X2FsbCB3aWxsIGJlIGNhbGxlZCBpbnRlcm5hbGx5KVxcbiAgICAgKiBAbmFtZSBjaGVja19hbGwoKVxcbiAgICAgKiBAdHJpZ2dlciBjaGVja19hbGwuanN0cmVlLCBjaGFuZ2VkLmpzdHJlZVxcbiAgICAgKiBAcGx1Z2luIGNoZWNrYm94XFxuICAgICAqL1xcblxcblxcbiAgICB0aGlzLmNoZWNrX2FsbCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RfYWxsKCk7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciB0bXAgPSB0aGlzLl9kYXRhLmNoZWNrYm94LnNlbGVjdGVkLmNvbmNhdChbXSksXFxuICAgICAgICAgIGksXFxuICAgICAgICAgIGo7XFxuXFxuICAgICAgdGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZCA9IHRoaXMuX21vZGVsLmRhdGFbJC5qc3RyZWUucm9vdF0uY2hpbGRyZW5fZC5jb25jYXQoKTtcXG5cXG4gICAgICBmb3IgKGkgPSAwLCBqID0gdGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG4gICAgICAgIGlmICh0aGlzLl9tb2RlbC5kYXRhW3RoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWRbaV1dKSB7XFxuICAgICAgICAgIHRoaXMuX21vZGVsLmRhdGFbdGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZFtpXV0uc3RhdGUuY2hlY2tlZCA9IHRydWU7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMucmVkcmF3KHRydWUpO1xcbiAgICAgIC8qKlxcbiAgICAgICAqIHRyaWdnZXJlZCB3aGVuIGFsbCBub2RlcyBhcmUgY2hlY2tlZCAob25seSBpZiB0aWVfc2VsZWN0aW9uIGluIGNoZWNrYm94IHNldHRpbmdzIGlzIGZhbHNlKVxcbiAgICAgICAqIEBldmVudFxcbiAgICAgICAqIEBuYW1lIGNoZWNrX2FsbC5qc3RyZWVcXG4gICAgICAgKiBAcGFyYW0ge0FycmF5fSBzZWxlY3RlZCB0aGUgY3VycmVudCBzZWxlY3Rpb25cXG4gICAgICAgKiBAcGx1Z2luIGNoZWNrYm94XFxuICAgICAgICovXFxuXFxuICAgICAgdGhpcy50cmlnZ2VyKCdjaGVja19hbGwnLCB7XFxuICAgICAgICAnc2VsZWN0ZWQnOiB0aGlzLl9kYXRhLmNoZWNrYm94LnNlbGVjdGVkXFxuICAgICAgfSk7XFxuICAgIH07XFxuICAgIC8qKlxcbiAgICAgKiB1bmNoZWNrIGFsbCBjaGVja2VkIG5vZGVzIChvbmx5IGlmIHRpZV9zZWxlY3Rpb24gaW4gY2hlY2tib3ggc2V0dGluZ3MgaXMgZmFsc2UsIG90aGVyd2lzZSBkZXNlbGVjdF9hbGwgd2lsbCBiZSBjYWxsZWQgaW50ZXJuYWxseSlcXG4gICAgICogQG5hbWUgdW5jaGVja19hbGwoKVxcbiAgICAgKiBAdHJpZ2dlciB1bmNoZWNrX2FsbC5qc3RyZWVcXG4gICAgICogQHBsdWdpbiBjaGVja2JveFxcbiAgICAgKi9cXG5cXG5cXG4gICAgdGhpcy51bmNoZWNrX2FsbCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5kZXNlbGVjdF9hbGwoKTtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIHRtcCA9IHRoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWQuY29uY2F0KFtdKSxcXG4gICAgICAgICAgaSxcXG4gICAgICAgICAgajtcXG5cXG4gICAgICBmb3IgKGkgPSAwLCBqID0gdGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG4gICAgICAgIGlmICh0aGlzLl9tb2RlbC5kYXRhW3RoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWRbaV1dKSB7XFxuICAgICAgICAgIHRoaXMuX21vZGVsLmRhdGFbdGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZFtpXV0uc3RhdGUuY2hlY2tlZCA9IGZhbHNlO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9kYXRhLmNoZWNrYm94LnNlbGVjdGVkID0gW107XFxuICAgICAgdGhpcy5lbGVtZW50LmZpbmQoJy5qc3RyZWUtY2hlY2tlZCcpLnJlbW92ZUNsYXNzKCdqc3RyZWUtY2hlY2tlZCcpO1xcbiAgICAgIC8qKlxcbiAgICAgICAqIHRyaWdnZXJlZCB3aGVuIGFsbCBub2RlcyBhcmUgdW5jaGVja2VkIChvbmx5IGlmIHRpZV9zZWxlY3Rpb24gaW4gY2hlY2tib3ggc2V0dGluZ3MgaXMgZmFsc2UpXFxuICAgICAgICogQGV2ZW50XFxuICAgICAgICogQG5hbWUgdW5jaGVja19hbGwuanN0cmVlXFxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGUgdGhlIHByZXZpb3VzIHNlbGVjdGlvblxcbiAgICAgICAqIEBwYXJhbSB7QXJyYXl9IHNlbGVjdGVkIHRoZSBjdXJyZW50IHNlbGVjdGlvblxcbiAgICAgICAqIEBwbHVnaW4gY2hlY2tib3hcXG4gICAgICAgKi9cXG5cXG4gICAgICB0aGlzLnRyaWdnZXIoJ3VuY2hlY2tfYWxsJywge1xcbiAgICAgICAgJ3NlbGVjdGVkJzogdGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZCxcXG4gICAgICAgICdub2RlJzogdG1wXFxuICAgICAgfSk7XFxuICAgIH07XFxuICAgIC8qKlxcbiAgICAgKiBjaGVja3MgaWYgYSBub2RlIGlzIGNoZWNrZWQgKGlmIHRpZV9zZWxlY3Rpb24gaXMgb24gaW4gdGhlIHNldHRpbmdzIHRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gdGhlIHNhbWUgYXMgaXNfc2VsZWN0ZWQpXFxuICAgICAqIEBuYW1lIGlzX2NoZWNrZWQob2JqKVxcbiAgICAgKiBAcGFyYW0gIHttaXhlZH0gIG9ialxcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxcbiAgICAgKiBAcGx1Z2luIGNoZWNrYm94XFxuICAgICAqL1xcblxcblxcbiAgICB0aGlzLmlzX2NoZWNrZWQgPSBmdW5jdGlvbiAob2JqKSB7XFxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbikge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNfc2VsZWN0ZWQob2JqKTtcXG4gICAgICB9XFxuXFxuICAgICAgb2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xcblxcbiAgICAgIGlmICghb2JqIHx8IG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCkge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gb2JqLnN0YXRlLmNoZWNrZWQ7XFxuICAgIH07XFxuICAgIC8qKlxcbiAgICAgKiBnZXQgYW4gYXJyYXkgb2YgYWxsIGNoZWNrZWQgbm9kZXMgKGlmIHRpZV9zZWxlY3Rpb24gaXMgb24gaW4gdGhlIHNldHRpbmdzIHRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gdGhlIHNhbWUgYXMgZ2V0X3NlbGVjdGVkKVxcbiAgICAgKiBAbmFtZSBnZXRfY2hlY2tlZChbZnVsbF0pXFxuICAgICAqIEBwYXJhbSAge21peGVkfSAgZnVsbCBpZiBzZXQgdG8gYHRydWVgIHRoZSByZXR1cm5lZCBhcnJheSB3aWxsIGNvbnNpc3Qgb2YgdGhlIGZ1bGwgbm9kZSBvYmplY3RzLCBvdGhlcndpc2UgLSBvbmx5IElEcyB3aWxsIGJlIHJldHVybmVkXFxuICAgICAqIEByZXR1cm4ge0FycmF5fVxcbiAgICAgKiBAcGx1Z2luIGNoZWNrYm94XFxuICAgICAqL1xcblxcblxcbiAgICB0aGlzLmdldF9jaGVja2VkID0gZnVuY3Rpb24gKGZ1bGwpIHtcXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5nZXRfc2VsZWN0ZWQoZnVsbCk7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBmdWxsID8gJC5tYXAodGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZCwgJC5wcm94eShmdW5jdGlvbiAoaSkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0X25vZGUoaSk7XFxuICAgICAgfSwgdGhpcykpIDogdGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZDtcXG4gICAgfTtcXG4gICAgLyoqXFxuICAgICAqIGdldCBhbiBhcnJheSBvZiBhbGwgdG9wIGxldmVsIGNoZWNrZWQgbm9kZXMgKGlnbm9yaW5nIGNoaWxkcmVuIG9mIGNoZWNrZWQgbm9kZXMpIChpZiB0aWVfc2VsZWN0aW9uIGlzIG9uIGluIHRoZSBzZXR0aW5ncyB0aGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSBzYW1lIGFzIGdldF90b3Bfc2VsZWN0ZWQpXFxuICAgICAqIEBuYW1lIGdldF90b3BfY2hlY2tlZChbZnVsbF0pXFxuICAgICAqIEBwYXJhbSAge21peGVkfSAgZnVsbCBpZiBzZXQgdG8gYHRydWVgIHRoZSByZXR1cm5lZCBhcnJheSB3aWxsIGNvbnNpc3Qgb2YgdGhlIGZ1bGwgbm9kZSBvYmplY3RzLCBvdGhlcndpc2UgLSBvbmx5IElEcyB3aWxsIGJlIHJldHVybmVkXFxuICAgICAqIEByZXR1cm4ge0FycmF5fVxcbiAgICAgKiBAcGx1Z2luIGNoZWNrYm94XFxuICAgICAqL1xcblxcblxcbiAgICB0aGlzLmdldF90b3BfY2hlY2tlZCA9IGZ1bmN0aW9uIChmdWxsKSB7XFxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbikge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0X3RvcF9zZWxlY3RlZChmdWxsKTtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIHRtcCA9IHRoaXMuZ2V0X2NoZWNrZWQodHJ1ZSksXFxuICAgICAgICAgIG9iaiA9IHt9LFxcbiAgICAgICAgICBpLFxcbiAgICAgICAgICBqLFxcbiAgICAgICAgICBrLFxcbiAgICAgICAgICBsO1xcblxcbiAgICAgIGZvciAoaSA9IDAsIGogPSB0bXAubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICBvYmpbdG1wW2ldLmlkXSA9IHRtcFtpXTtcXG4gICAgICB9XFxuXFxuICAgICAgZm9yIChpID0gMCwgaiA9IHRtcC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG4gICAgICAgIGZvciAoayA9IDAsIGwgPSB0bXBbaV0uY2hpbGRyZW5fZC5sZW5ndGg7IGsgPCBsOyBrKyspIHtcXG4gICAgICAgICAgaWYgKG9ialt0bXBbaV0uY2hpbGRyZW5fZFtrXV0pIHtcXG4gICAgICAgICAgICBkZWxldGUgb2JqW3RtcFtpXS5jaGlsZHJlbl9kW2tdXTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICB0bXAgPSBbXTtcXG5cXG4gICAgICBmb3IgKGkgaW4gb2JqKSB7XFxuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGkpKSB7XFxuICAgICAgICAgIHRtcC5wdXNoKGkpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gZnVsbCA/ICQubWFwKHRtcCwgJC5wcm94eShmdW5jdGlvbiAoaSkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0X25vZGUoaSk7XFxuICAgICAgfSwgdGhpcykpIDogdG1wO1xcbiAgICB9O1xcbiAgICAvKipcXG4gICAgICogZ2V0IGFuIGFycmF5IG9mIGFsbCBib3R0b20gbGV2ZWwgY2hlY2tlZCBub2RlcyAoaWdub3Jpbmcgc2VsZWN0ZWQgcGFyZW50cykgKGlmIHRpZV9zZWxlY3Rpb24gaXMgb24gaW4gdGhlIHNldHRpbmdzIHRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gdGhlIHNhbWUgYXMgZ2V0X2JvdHRvbV9zZWxlY3RlZClcXG4gICAgICogQG5hbWUgZ2V0X2JvdHRvbV9jaGVja2VkKFtmdWxsXSlcXG4gICAgICogQHBhcmFtICB7bWl4ZWR9ICBmdWxsIGlmIHNldCB0byBgdHJ1ZWAgdGhlIHJldHVybmVkIGFycmF5IHdpbGwgY29uc2lzdCBvZiB0aGUgZnVsbCBub2RlIG9iamVjdHMsIG90aGVyd2lzZSAtIG9ubHkgSURzIHdpbGwgYmUgcmV0dXJuZWRcXG4gICAgICogQHJldHVybiB7QXJyYXl9XFxuICAgICAqIEBwbHVnaW4gY2hlY2tib3hcXG4gICAgICovXFxuXFxuXFxuICAgIHRoaXMuZ2V0X2JvdHRvbV9jaGVja2VkID0gZnVuY3Rpb24gKGZ1bGwpIHtcXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5nZXRfYm90dG9tX3NlbGVjdGVkKGZ1bGwpO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgdG1wID0gdGhpcy5nZXRfY2hlY2tlZCh0cnVlKSxcXG4gICAgICAgICAgb2JqID0gW10sXFxuICAgICAgICAgIGksXFxuICAgICAgICAgIGo7XFxuXFxuICAgICAgZm9yIChpID0gMCwgaiA9IHRtcC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG4gICAgICAgIGlmICghdG1wW2ldLmNoaWxkcmVuLmxlbmd0aCkge1xcbiAgICAgICAgICBvYmoucHVzaCh0bXBbaV0uaWQpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gZnVsbCA/ICQubWFwKG9iaiwgJC5wcm94eShmdW5jdGlvbiAoaSkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0X25vZGUoaSk7XFxuICAgICAgfSwgdGhpcykpIDogb2JqO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLmxvYWRfbm9kZSA9IGZ1bmN0aW9uIChvYmosIGNhbGxiYWNrKSB7XFxuICAgICAgdmFyIGssIGwsIGksIGosIGMsIHRtcDtcXG5cXG4gICAgICBpZiAoISQuaXNBcnJheShvYmopICYmICF0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb24pIHtcXG4gICAgICAgIHRtcCA9IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXG4gICAgICAgIGlmICh0bXAgJiYgdG1wLnN0YXRlLmxvYWRlZCkge1xcbiAgICAgICAgICBmb3IgKGsgPSAwLCBsID0gdG1wLmNoaWxkcmVuX2QubGVuZ3RoOyBrIDwgbDsgaysrKSB7XFxuICAgICAgICAgICAgaWYgKHRoaXMuX21vZGVsLmRhdGFbdG1wLmNoaWxkcmVuX2Rba11dLnN0YXRlLmNoZWNrZWQpIHtcXG4gICAgICAgICAgICAgIGMgPSB0cnVlO1xcbiAgICAgICAgICAgICAgdGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZCA9ICQudmFrYXRhLmFycmF5X3JlbW92ZV9pdGVtKHRoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWQsIHRtcC5jaGlsZHJlbl9kW2tdKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHBhcmVudC5sb2FkX25vZGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5nZXRfc3RhdGUgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgdmFyIHN0YXRlID0gcGFyZW50LmdldF9zdGF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcblxcbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb24pIHtcXG4gICAgICAgIHJldHVybiBzdGF0ZTtcXG4gICAgICB9XFxuXFxuICAgICAgc3RhdGUuY2hlY2tib3ggPSB0aGlzLl9kYXRhLmNoZWNrYm94LnNlbGVjdGVkLnNsaWNlKCk7XFxuICAgICAgcmV0dXJuIHN0YXRlO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLnNldF9zdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgY2FsbGJhY2spIHtcXG4gICAgICB2YXIgcmVzID0gcGFyZW50LnNldF9zdGF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcblxcbiAgICAgIGlmIChyZXMgJiYgc3RhdGUuY2hlY2tib3gpIHtcXG4gICAgICAgIGlmICghdGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uKSB7XFxuICAgICAgICAgIHRoaXMudW5jaGVja19hbGwoKTtcXG5cXG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcXG5cXG4gICAgICAgICAgJC5lYWNoKHN0YXRlLmNoZWNrYm94LCBmdW5jdGlvbiAoaSwgdikge1xcbiAgICAgICAgICAgIF90aGlzLmNoZWNrX25vZGUodik7XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZGVsZXRlIHN0YXRlLmNoZWNrYm94O1xcbiAgICAgICAgdGhpcy5zZXRfc3RhdGUoc3RhdGUsIGNhbGxiYWNrKTtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHJlcztcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5yZWZyZXNoID0gZnVuY3Rpb24gKHNraXBfbG9hZGluZywgZm9yZ2V0X3N0YXRlKSB7XFxuICAgICAgaWYgKCF0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb24pIHtcXG4gICAgICAgIHRoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWQgPSBbXTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHBhcmVudC5yZWZyZXNoLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICAgIH07XFxuICB9OyAvLyBpbmNsdWRlIHRoZSBjaGVja2JveCBwbHVnaW4gYnkgZGVmYXVsdFxcbiAgLy8gJC5qc3RyZWUuZGVmYXVsdHMucGx1Z2lucy5wdXNoKFxcXCJjaGVja2JveFxcXCIpO1xcblxcbiAgLyoqXFxuICAgKiAjIyMgQ29uZGl0aW9uYWxzZWxlY3QgcGx1Z2luXFxuICAgKlxcbiAgICogVGhpcyBwbHVnaW4gYWxsb3dzIGRlZmluaW5nIGEgY2FsbGJhY2sgdG8gYWxsb3cgb3IgZGVueSBub2RlIHNlbGVjdGlvbiBieSB1c2VyIGlucHV0IChhY3RpdmF0ZSBub2RlIG1ldGhvZCkuXFxuICAgKi9cXG5cXG4gIC8qKlxcbiAgICogYSBjYWxsYmFjayAoZnVuY3Rpb24pIHdoaWNoIGlzIGludm9rZWQgaW4gdGhlIGluc3RhbmNlJ3Mgc2NvcGUgYW5kIHJlY2VpdmVzIHR3byBhcmd1bWVudHMgLSB0aGUgbm9kZSBhbmQgdGhlIGV2ZW50IHRoYXQgdHJpZ2dlcmVkIHRoZSBgYWN0aXZhdGVfbm9kZWAgY2FsbC4gUmV0dXJuaW5nIGZhbHNlIHByZXZlbnRzIHdvcmtpbmcgd2l0aCB0aGUgbm9kZSwgcmV0dXJuaW5nIHRydWUgYWxsb3dzIGludm9raW5nIGFjdGl2YXRlX25vZGUuIERlZmF1bHRzIHRvIHJldHVybmluZyBgdHJ1ZWAuXFxuICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jaGVja2JveC52aXNpYmxlXFxuICAgKiBAcGx1Z2luIGNoZWNrYm94XFxuICAgKi9cXG5cXG5cXG4gICQuanN0cmVlLmRlZmF1bHRzLmNvbmRpdGlvbmFsc2VsZWN0ID0gZnVuY3Rpb24gKCkge1xcbiAgICByZXR1cm4gdHJ1ZTtcXG4gIH07XFxuXFxuICAkLmpzdHJlZS5wbHVnaW5zLmNvbmRpdGlvbmFsc2VsZWN0ID0gZnVuY3Rpb24gKG9wdGlvbnMsIHBhcmVudCkge1xcbiAgICAvLyBvd24gZnVuY3Rpb25cXG4gICAgdGhpcy5hY3RpdmF0ZV9ub2RlID0gZnVuY3Rpb24gKG9iaiwgZSkge1xcbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLmNvbmRpdGlvbmFsc2VsZWN0LmNhbGwodGhpcywgdGhpcy5nZXRfbm9kZShvYmopLCBlKSkge1xcbiAgICAgICAgcGFyZW50LmFjdGl2YXRlX25vZGUuY2FsbCh0aGlzLCBvYmosIGUpO1xcbiAgICAgIH1cXG4gICAgfTtcXG4gIH07XFxuICAvKipcXG4gICAqICMjIyBDb250ZXh0bWVudSBwbHVnaW5cXG4gICAqXFxuICAgKiBTaG93cyBhIGNvbnRleHQgbWVudSB3aGVuIGEgbm9kZSBpcyByaWdodC1jbGlja2VkLlxcbiAgICovXFxuXFxuICAvKipcXG4gICAqIHN0b3JlcyBhbGwgZGVmYXVsdHMgZm9yIHRoZSBjb250ZXh0bWVudSBwbHVnaW5cXG4gICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvbnRleHRtZW51XFxuICAgKiBAcGx1Z2luIGNvbnRleHRtZW51XFxuICAgKi9cXG5cXG5cXG4gICQuanN0cmVlLmRlZmF1bHRzLmNvbnRleHRtZW51ID0ge1xcbiAgICAvKipcXG4gICAgICogYSBib29sZWFuIGluZGljYXRpbmcgaWYgdGhlIG5vZGUgc2hvdWxkIGJlIHNlbGVjdGVkIHdoZW4gdGhlIGNvbnRleHQgbWVudSBpcyBpbnZva2VkIG9uIGl0LiBEZWZhdWx0cyB0byBgdHJ1ZWAuXFxuICAgICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvbnRleHRtZW51LnNlbGVjdF9ub2RlXFxuICAgICAqIEBwbHVnaW4gY29udGV4dG1lbnVcXG4gICAgICovXFxuICAgIHNlbGVjdF9ub2RlOiB0cnVlLFxcblxcbiAgICAvKipcXG4gICAgICogYSBib29sZWFuIGluZGljYXRpbmcgaWYgdGhlIG1lbnUgc2hvdWxkIGJlIHNob3duIGFsaWduZWQgd2l0aCB0aGUgbm9kZS4gRGVmYXVsdHMgdG8gYHRydWVgLCBvdGhlcndpc2UgdGhlIG1vdXNlIGNvb3JkaW5hdGVzIGFyZSB1c2VkLlxcbiAgICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb250ZXh0bWVudS5zaG93X2F0X25vZGVcXG4gICAgICogQHBsdWdpbiBjb250ZXh0bWVudVxcbiAgICAgKi9cXG4gICAgc2hvd19hdF9ub2RlOiB0cnVlLFxcblxcbiAgICAvKipcXG4gICAgICogYW4gb2JqZWN0IG9mIGFjdGlvbnMsIG9yIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIGEgbm9kZSBhbmQgYSBjYWxsYmFjayBmdW5jdGlvbiBhbmQgY2FsbHMgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdpdGggYW4gb2JqZWN0IG9mIGFjdGlvbnMgYXZhaWxhYmxlIGZvciB0aGF0IG5vZGUgKHlvdSBjYW4gYWxzbyByZXR1cm4gdGhlIGl0ZW1zIHRvbykuXFxuICAgICAqXFxuICAgICAqIEVhY2ggYWN0aW9uIGNvbnNpc3RzIG9mIGEga2V5IChhIHVuaXF1ZSBuYW1lKSBhbmQgYSB2YWx1ZSB3aGljaCBpcyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXMgKG9ubHkgbGFiZWwgYW5kIGFjdGlvbiBhcmUgcmVxdWlyZWQpLiBPbmNlIGEgbWVudSBpdGVtIGlzIGFjdGl2YXRlZCB0aGUgYGFjdGlvbmAgZnVuY3Rpb24gd2lsbCBiZSBpbnZva2VkIHdpdGggYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGZvbGxvd2luZyBrZXlzOiBpdGVtIC0gdGhlIGNvbnRleHRtZW51IGl0ZW0gZGVmaW5pdGlvbiBhcyBzZWVuIGJlbG93LCByZWZlcmVuY2UgLSB0aGUgRE9NIG5vZGUgdGhhdCB3YXMgdXNlZCAodGhlIHRyZWUgbm9kZSksIGVsZW1lbnQgLSB0aGUgY29udGV4dG1lbnUgRE9NIGVsZW1lbnQsIHBvc2l0aW9uIC0gYW4gb2JqZWN0IHdpdGggeC95IHByb3BlcnRpZXMgaW5kaWNhdGluZyB0aGUgcG9zaXRpb24gb2YgdGhlIG1lbnUuXFxuICAgICAqXFxuICAgICAqICogYHNlcGFyYXRvcl9iZWZvcmVgIC0gYSBib29sZWFuIGluZGljYXRpbmcgaWYgdGhlcmUgc2hvdWxkIGJlIGEgc2VwYXJhdG9yIGJlZm9yZSB0aGlzIGl0ZW1cXG4gICAgICogKiBgc2VwYXJhdG9yX2FmdGVyYCAtIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoZXJlIHNob3VsZCBiZSBhIHNlcGFyYXRvciBhZnRlciB0aGlzIGl0ZW1cXG4gICAgICogKiBgX2Rpc2FibGVkYCAtIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoaXMgYWN0aW9uIHNob3VsZCBiZSBkaXNhYmxlZFxcbiAgICAgKiAqIGBsYWJlbGAgLSBhIHN0cmluZyAtIHRoZSBuYW1lIG9mIHRoZSBhY3Rpb24gKGNvdWxkIGJlIGEgZnVuY3Rpb24gcmV0dXJuaW5nIGEgc3RyaW5nKVxcbiAgICAgKiAqIGB0aXRsZWAgLSBhIHN0cmluZyAtIGFuIG9wdGlvbmFsIHRvb2x0aXAgZm9yIHRoZSBpdGVtXFxuICAgICAqICogYGFjdGlvbmAgLSBhIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIGlmIHRoaXMgaXRlbSBpcyBjaG9zZW4sIHRoZSBmdW5jdGlvbiB3aWxsIHJlY2VpdmUgXFxuICAgICAqICogYGljb25gIC0gYSBzdHJpbmcsIGNhbiBiZSBhIHBhdGggdG8gYW4gaWNvbiBvciBhIGNsYXNzTmFtZSwgaWYgdXNpbmcgYW4gaW1hZ2UgdGhhdCBpcyBpbiB0aGUgY3VycmVudCBkaXJlY3RvcnkgdXNlIGEgYC4vYCBwcmVmaXgsIG90aGVyd2lzZSBpdCB3aWxsIGJlIGRldGVjdGVkIGFzIGEgY2xhc3NcXG4gICAgICogKiBgc2hvcnRjdXRgIC0ga2V5Q29kZSB3aGljaCB3aWxsIHRyaWdnZXIgdGhlIGFjdGlvbiBpZiB0aGUgbWVudSBpcyBvcGVuIChmb3IgZXhhbXBsZSBgMTEzYCBmb3IgcmVuYW1lLCB3aGljaCBlcXVhbHMgRjIpXFxuICAgICAqICogYHNob3J0Y3V0X2xhYmVsYCAtIHNob3J0Y3V0IGxhYmVsIChsaWtlIGZvciBleGFtcGxlIGBGMmAgZm9yIHJlbmFtZSlcXG4gICAgICogKiBgc3VibWVudWAgLSBhbiBvYmplY3Qgd2l0aCB0aGUgc2FtZSBzdHJ1Y3R1cmUgYXMgJC5qc3RyZWUuZGVmYXVsdHMuY29udGV4dG1lbnUuaXRlbXMgd2hpY2ggY2FuIGJlIHVzZWQgdG8gY3JlYXRlIGEgc3VibWVudSAtIGVhY2gga2V5IHdpbGwgYmUgcmVuZGVyZWQgYXMgYSBzZXBhcmF0ZSBvcHRpb24gaW4gYSBzdWJtZW51IHRoYXQgd2lsbCBhcHBlYXIgb25jZSB0aGUgY3VycmVudCBpdGVtIGlzIGhvdmVyZWRcXG4gICAgICpcXG4gICAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY29udGV4dG1lbnUuaXRlbXNcXG4gICAgICogQHBsdWdpbiBjb250ZXh0bWVudVxcbiAgICAgKi9cXG4gICAgaXRlbXM6IGZ1bmN0aW9uIGl0ZW1zKG8sIGNiKSB7XFxuICAgICAgLy8gQ291bGQgYmUgYW4gb2JqZWN0IGRpcmVjdGx5XFxuICAgICAgcmV0dXJuIHtcXG4gICAgICAgIFxcXCJjcmVhdGVcXFwiOiB7XFxuICAgICAgICAgIFxcXCJzZXBhcmF0b3JfYmVmb3JlXFxcIjogZmFsc2UsXFxuICAgICAgICAgIFxcXCJzZXBhcmF0b3JfYWZ0ZXJcXFwiOiB0cnVlLFxcbiAgICAgICAgICBcXFwiX2Rpc2FibGVkXFxcIjogZmFsc2UsXFxuICAgICAgICAgIC8vKHRoaXMuY2hlY2soXFxcImNyZWF0ZV9ub2RlXFxcIiwgZGF0YS5yZWZlcmVuY2UsIHt9LCBcXFwibGFzdFxcXCIpKSxcXG4gICAgICAgICAgXFxcImxhYmVsXFxcIjogXFxcIkNyZWF0ZVxcXCIsXFxuICAgICAgICAgIFxcXCJhY3Rpb25cXFwiOiBmdW5jdGlvbiBhY3Rpb24oZGF0YSkge1xcbiAgICAgICAgICAgIHZhciBpbnN0ID0gJC5qc3RyZWUucmVmZXJlbmNlKGRhdGEucmVmZXJlbmNlKSxcXG4gICAgICAgICAgICAgICAgb2JqID0gaW5zdC5nZXRfbm9kZShkYXRhLnJlZmVyZW5jZSk7XFxuICAgICAgICAgICAgaW5zdC5jcmVhdGVfbm9kZShvYmosIHt9LCBcXFwibGFzdFxcXCIsIGZ1bmN0aW9uIChuZXdfbm9kZSkge1xcbiAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgIGluc3QuZWRpdChuZXdfbm9kZSk7XFxuICAgICAgICAgICAgICB9LCAwKTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSxcXG4gICAgICAgIFxcXCJyZW5hbWVcXFwiOiB7XFxuICAgICAgICAgIFxcXCJzZXBhcmF0b3JfYmVmb3JlXFxcIjogZmFsc2UsXFxuICAgICAgICAgIFxcXCJzZXBhcmF0b3JfYWZ0ZXJcXFwiOiBmYWxzZSxcXG4gICAgICAgICAgXFxcIl9kaXNhYmxlZFxcXCI6IGZhbHNlLFxcbiAgICAgICAgICAvLyh0aGlzLmNoZWNrKFxcXCJyZW5hbWVfbm9kZVxcXCIsIGRhdGEucmVmZXJlbmNlLCB0aGlzLmdldF9wYXJlbnQoZGF0YS5yZWZlcmVuY2UpLCBcXFwiXFxcIikpLFxcbiAgICAgICAgICBcXFwibGFiZWxcXFwiOiBcXFwiUmVuYW1lXFxcIixcXG5cXG4gICAgICAgICAgLyohXFxuICAgICAgICAgIFxcXCJzaG9ydGN1dFxcXCJcXHRcXHRcXHQ6IDExMyxcXG4gICAgICAgICAgXFxcInNob3J0Y3V0X2xhYmVsXFxcIlxcdDogJ0YyJyxcXG4gICAgICAgICAgXFxcImljb25cXFwiXFx0XFx0XFx0XFx0OiBcXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1sZWFmXFxcIixcXG4gICAgICAgICAgKi9cXG4gICAgICAgICAgXFxcImFjdGlvblxcXCI6IGZ1bmN0aW9uIGFjdGlvbihkYXRhKSB7XFxuICAgICAgICAgICAgdmFyIGluc3QgPSAkLmpzdHJlZS5yZWZlcmVuY2UoZGF0YS5yZWZlcmVuY2UpLFxcbiAgICAgICAgICAgICAgICBvYmogPSBpbnN0LmdldF9ub2RlKGRhdGEucmVmZXJlbmNlKTtcXG4gICAgICAgICAgICBpbnN0LmVkaXQob2JqKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSxcXG4gICAgICAgIFxcXCJyZW1vdmVcXFwiOiB7XFxuICAgICAgICAgIFxcXCJzZXBhcmF0b3JfYmVmb3JlXFxcIjogZmFsc2UsXFxuICAgICAgICAgIFxcXCJpY29uXFxcIjogZmFsc2UsXFxuICAgICAgICAgIFxcXCJzZXBhcmF0b3JfYWZ0ZXJcXFwiOiBmYWxzZSxcXG4gICAgICAgICAgXFxcIl9kaXNhYmxlZFxcXCI6IGZhbHNlLFxcbiAgICAgICAgICAvLyh0aGlzLmNoZWNrKFxcXCJkZWxldGVfbm9kZVxcXCIsIGRhdGEucmVmZXJlbmNlLCB0aGlzLmdldF9wYXJlbnQoZGF0YS5yZWZlcmVuY2UpLCBcXFwiXFxcIikpLFxcbiAgICAgICAgICBcXFwibGFiZWxcXFwiOiBcXFwiRGVsZXRlXFxcIixcXG4gICAgICAgICAgXFxcImFjdGlvblxcXCI6IGZ1bmN0aW9uIGFjdGlvbihkYXRhKSB7XFxuICAgICAgICAgICAgdmFyIGluc3QgPSAkLmpzdHJlZS5yZWZlcmVuY2UoZGF0YS5yZWZlcmVuY2UpLFxcbiAgICAgICAgICAgICAgICBvYmogPSBpbnN0LmdldF9ub2RlKGRhdGEucmVmZXJlbmNlKTtcXG5cXG4gICAgICAgICAgICBpZiAoaW5zdC5pc19zZWxlY3RlZChvYmopKSB7XFxuICAgICAgICAgICAgICBpbnN0LmRlbGV0ZV9ub2RlKGluc3QuZ2V0X3NlbGVjdGVkKCkpO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICBpbnN0LmRlbGV0ZV9ub2RlKG9iaik7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgXFxcImNjcFxcXCI6IHtcXG4gICAgICAgICAgXFxcInNlcGFyYXRvcl9iZWZvcmVcXFwiOiB0cnVlLFxcbiAgICAgICAgICBcXFwiaWNvblxcXCI6IGZhbHNlLFxcbiAgICAgICAgICBcXFwic2VwYXJhdG9yX2FmdGVyXFxcIjogZmFsc2UsXFxuICAgICAgICAgIFxcXCJsYWJlbFxcXCI6IFxcXCJFZGl0XFxcIixcXG4gICAgICAgICAgXFxcImFjdGlvblxcXCI6IGZhbHNlLFxcbiAgICAgICAgICBcXFwic3VibWVudVxcXCI6IHtcXG4gICAgICAgICAgICBcXFwiY3V0XFxcIjoge1xcbiAgICAgICAgICAgICAgXFxcInNlcGFyYXRvcl9iZWZvcmVcXFwiOiBmYWxzZSxcXG4gICAgICAgICAgICAgIFxcXCJzZXBhcmF0b3JfYWZ0ZXJcXFwiOiBmYWxzZSxcXG4gICAgICAgICAgICAgIFxcXCJsYWJlbFxcXCI6IFxcXCJDdXRcXFwiLFxcbiAgICAgICAgICAgICAgXFxcImFjdGlvblxcXCI6IGZ1bmN0aW9uIGFjdGlvbihkYXRhKSB7XFxuICAgICAgICAgICAgICAgIHZhciBpbnN0ID0gJC5qc3RyZWUucmVmZXJlbmNlKGRhdGEucmVmZXJlbmNlKSxcXG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IGluc3QuZ2V0X25vZGUoZGF0YS5yZWZlcmVuY2UpO1xcblxcbiAgICAgICAgICAgICAgICBpZiAoaW5zdC5pc19zZWxlY3RlZChvYmopKSB7XFxuICAgICAgICAgICAgICAgICAgaW5zdC5jdXQoaW5zdC5nZXRfdG9wX3NlbGVjdGVkKCkpO1xcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgIGluc3QuY3V0KG9iaik7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIFxcXCJjb3B5XFxcIjoge1xcbiAgICAgICAgICAgICAgXFxcInNlcGFyYXRvcl9iZWZvcmVcXFwiOiBmYWxzZSxcXG4gICAgICAgICAgICAgIFxcXCJpY29uXFxcIjogZmFsc2UsXFxuICAgICAgICAgICAgICBcXFwic2VwYXJhdG9yX2FmdGVyXFxcIjogZmFsc2UsXFxuICAgICAgICAgICAgICBcXFwibGFiZWxcXFwiOiBcXFwiQ29weVxcXCIsXFxuICAgICAgICAgICAgICBcXFwiYWN0aW9uXFxcIjogZnVuY3Rpb24gYWN0aW9uKGRhdGEpIHtcXG4gICAgICAgICAgICAgICAgdmFyIGluc3QgPSAkLmpzdHJlZS5yZWZlcmVuY2UoZGF0YS5yZWZlcmVuY2UpLFxcbiAgICAgICAgICAgICAgICAgICAgb2JqID0gaW5zdC5nZXRfbm9kZShkYXRhLnJlZmVyZW5jZSk7XFxuXFxuICAgICAgICAgICAgICAgIGlmIChpbnN0LmlzX3NlbGVjdGVkKG9iaikpIHtcXG4gICAgICAgICAgICAgICAgICBpbnN0LmNvcHkoaW5zdC5nZXRfdG9wX3NlbGVjdGVkKCkpO1xcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgIGluc3QuY29weShvYmopO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICBcXFwicGFzdGVcXFwiOiB7XFxuICAgICAgICAgICAgICBcXFwic2VwYXJhdG9yX2JlZm9yZVxcXCI6IGZhbHNlLFxcbiAgICAgICAgICAgICAgXFxcImljb25cXFwiOiBmYWxzZSxcXG4gICAgICAgICAgICAgIFxcXCJfZGlzYWJsZWRcXFwiOiBmdW5jdGlvbiBfZGlzYWJsZWQoZGF0YSkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gISQuanN0cmVlLnJlZmVyZW5jZShkYXRhLnJlZmVyZW5jZSkuY2FuX3Bhc3RlKCk7XFxuICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgXFxcInNlcGFyYXRvcl9hZnRlclxcXCI6IGZhbHNlLFxcbiAgICAgICAgICAgICAgXFxcImxhYmVsXFxcIjogXFxcIlBhc3RlXFxcIixcXG4gICAgICAgICAgICAgIFxcXCJhY3Rpb25cXFwiOiBmdW5jdGlvbiBhY3Rpb24oZGF0YSkge1xcbiAgICAgICAgICAgICAgICB2YXIgaW5zdCA9ICQuanN0cmVlLnJlZmVyZW5jZShkYXRhLnJlZmVyZW5jZSksXFxuICAgICAgICAgICAgICAgICAgICBvYmogPSBpbnN0LmdldF9ub2RlKGRhdGEucmVmZXJlbmNlKTtcXG4gICAgICAgICAgICAgICAgaW5zdC5wYXN0ZShvYmopO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgIH1cXG4gIH07XFxuXFxuICAkLmpzdHJlZS5wbHVnaW5zLmNvbnRleHRtZW51ID0gZnVuY3Rpb24gKG9wdGlvbnMsIHBhcmVudCkge1xcbiAgICB0aGlzLmJpbmQgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgcGFyZW50LmJpbmQuY2FsbCh0aGlzKTtcXG4gICAgICB2YXIgbGFzdF90cyA9IDAsXFxuICAgICAgICAgIGN0byA9IG51bGwsXFxuICAgICAgICAgIGV4LFxcbiAgICAgICAgICBleTtcXG4gICAgICB0aGlzLmVsZW1lbnQub24oXFxcImNvbnRleHRtZW51LmpzdHJlZVxcXCIsIFxcXCIuanN0cmVlLWFuY2hvclxcXCIsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcXG4gICAgICAgIGlmIChlLnRhcmdldC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcpIHtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgbGFzdF90cyA9IGUuY3RybEtleSA/ICtuZXcgRGF0ZSgpIDogMDtcXG5cXG4gICAgICAgIGlmIChkYXRhIHx8IGN0bykge1xcbiAgICAgICAgICBsYXN0X3RzID0gK25ldyBEYXRlKCkgKyAxMDAwMDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChjdG8pIHtcXG4gICAgICAgICAgY2xlYXJUaW1lb3V0KGN0byk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoIXRoaXMuaXNfbG9hZGluZyhlLmN1cnJlbnRUYXJnZXQpKSB7XFxuICAgICAgICAgIHRoaXMuc2hvd19jb250ZXh0bWVudShlLmN1cnJlbnRUYXJnZXQsIGUucGFnZVgsIGUucGFnZVksIGUpO1xcbiAgICAgICAgfVxcbiAgICAgIH0sIHRoaXMpKS5vbihcXFwiY2xpY2suanN0cmVlXFxcIiwgXFxcIi5qc3RyZWUtYW5jaG9yXFxcIiwgJC5wcm94eShmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgaWYgKHRoaXMuX2RhdGEuY29udGV4dG1lbnUudmlzaWJsZSAmJiAoIWxhc3RfdHMgfHwgK25ldyBEYXRlKCkgLSBsYXN0X3RzID4gMjUwKSkge1xcbiAgICAgICAgICAvLyB3b3JrIGFyb3VuZCBzYWZhcmkgJiBtYWNPUyBjdHJsK2NsaWNrXFxuICAgICAgICAgICQudmFrYXRhLmNvbnRleHQuaGlkZSgpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgbGFzdF90cyA9IDA7XFxuICAgICAgfSwgdGhpcykpLm9uKFxcXCJ0b3VjaHN0YXJ0LmpzdHJlZVxcXCIsIFxcXCIuanN0cmVlLWFuY2hvclxcXCIsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICBpZiAoIWUub3JpZ2luYWxFdmVudCB8fCAhZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzIHx8ICFlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0pIHtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZXggPSBlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WDtcXG4gICAgICAgIGV5ID0gZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFk7XFxuICAgICAgICBjdG8gPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgJChlLmN1cnJlbnRUYXJnZXQpLnRyaWdnZXIoJ2NvbnRleHRtZW51JywgdHJ1ZSk7XFxuICAgICAgICB9LCA3NTApO1xcbiAgICAgIH0pLm9uKCd0b3VjaG1vdmUudmFrYXRhLmpzdHJlZScsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICBpZiAoY3RvICYmIGUub3JpZ2luYWxFdmVudCAmJiBlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXMgJiYgZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdICYmIChNYXRoLmFicyhleCAtIGUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRYKSA+IDUwIHx8IE1hdGguYWJzKGV5IC0gZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFkpID4gNTApKSB7XFxuICAgICAgICAgIGNsZWFyVGltZW91dChjdG8pO1xcbiAgICAgICAgfVxcbiAgICAgIH0pLm9uKCd0b3VjaGVuZC52YWthdGEuanN0cmVlJywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgIGlmIChjdG8pIHtcXG4gICAgICAgICAgY2xlYXJUaW1lb3V0KGN0byk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgICAgLyohXFxuICAgICAgaWYoISgnb25jb250ZXh0bWVudScgaW4gZG9jdW1lbnQuYm9keSkgJiYgKCdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmJvZHkpKSB7XFxuICAgICAgXFx0dmFyIGVsID0gbnVsbCwgdG0gPSBudWxsO1xcbiAgICAgIFxcdHRoaXMuZWxlbWVudFxcbiAgICAgIFxcdFxcdC5vbihcXFwidG91Y2hzdGFydFxcXCIsIFxcXCIuanN0cmVlLWFuY2hvclxcXCIsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgXFx0XFx0XFx0ZWwgPSBlLmN1cnJlbnRUYXJnZXQ7XFxuICAgICAgXFx0XFx0XFx0dG0gPSArbmV3IERhdGUoKTtcXG4gICAgICBcXHRcXHRcXHQkKGRvY3VtZW50KS5vbmUoXFxcInRvdWNoZW5kXFxcIiwgZnVuY3Rpb24gKGUpIHtcXG4gICAgICBcXHRcXHRcXHRcXHRlLnRhcmdldCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoZS5vcmlnaW5hbEV2ZW50LnRhcmdldFRvdWNoZXNbMF0ucGFnZVggLSB3aW5kb3cucGFnZVhPZmZzZXQsIGUub3JpZ2luYWxFdmVudC50YXJnZXRUb3VjaGVzWzBdLnBhZ2VZIC0gd2luZG93LnBhZ2VZT2Zmc2V0KTtcXG4gICAgICBcXHRcXHRcXHRcXHRlLmN1cnJlbnRUYXJnZXQgPSBlLnRhcmdldDtcXG4gICAgICBcXHRcXHRcXHRcXHR0bSA9ICgoKyhuZXcgRGF0ZSgpKSkgLSB0bSk7XFxuICAgICAgXFx0XFx0XFx0XFx0aWYoZS50YXJnZXQgPT09IGVsICYmIHRtID4gNjAwICYmIHRtIDwgMTAwMCkge1xcbiAgICAgIFxcdFxcdFxcdFxcdFxcdGUucHJldmVudERlZmF1bHQoKTtcXG4gICAgICBcXHRcXHRcXHRcXHRcXHQkKGVsKS50cmlnZ2VyKCdjb250ZXh0bWVudScsIGUpO1xcbiAgICAgIFxcdFxcdFxcdFxcdH1cXG4gICAgICBcXHRcXHRcXHRcXHRlbCA9IG51bGw7XFxuICAgICAgXFx0XFx0XFx0XFx0dG0gPSBudWxsO1xcbiAgICAgIFxcdFxcdFxcdH0pO1xcbiAgICAgIFxcdFxcdH0pO1xcbiAgICAgIH1cXG4gICAgICAqL1xcblxcbiAgICAgICQoZG9jdW1lbnQpLm9uKFxcXCJjb250ZXh0X2hpZGUudmFrYXRhLmpzdHJlZVxcXCIsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcXG4gICAgICAgIHRoaXMuX2RhdGEuY29udGV4dG1lbnUudmlzaWJsZSA9IGZhbHNlO1xcbiAgICAgICAgJChkYXRhLnJlZmVyZW5jZSkucmVtb3ZlQ2xhc3MoJ2pzdHJlZS1jb250ZXh0Jyk7XFxuICAgICAgfSwgdGhpcykpO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLnRlYXJkb3duID0gZnVuY3Rpb24gKCkge1xcbiAgICAgIGlmICh0aGlzLl9kYXRhLmNvbnRleHRtZW51LnZpc2libGUpIHtcXG4gICAgICAgICQudmFrYXRhLmNvbnRleHQuaGlkZSgpO1xcbiAgICAgIH1cXG5cXG4gICAgICBwYXJlbnQudGVhcmRvd24uY2FsbCh0aGlzKTtcXG4gICAgfTtcXG4gICAgLyoqXFxuICAgICAqIHByZXBhcmUgYW5kIHNob3cgdGhlIGNvbnRleHQgbWVudSBmb3IgYSBub2RlXFxuICAgICAqIEBuYW1lIHNob3dfY29udGV4dG1lbnUob2JqIFssIHgsIHldKVxcbiAgICAgKiBAcGFyYW0ge21peGVkfSBvYmogdGhlIG5vZGVcXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggdGhlIHgtY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgZG9jdW1lbnQgdG8gc2hvdyB0aGUgbWVudSBhdFxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSB0aGUgeS1jb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBkb2N1bWVudCB0byBzaG93IHRoZSBtZW51IGF0XFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlIHRoZSBldmVudCBpZiBhdmFpbGFibGUgdGhhdCB0cmlnZ2VyZWQgdGhlIGNvbnRleHRtZW51XFxuICAgICAqIEBwbHVnaW4gY29udGV4dG1lbnVcXG4gICAgICogQHRyaWdnZXIgc2hvd19jb250ZXh0bWVudS5qc3RyZWVcXG4gICAgICovXFxuXFxuXFxuICAgIHRoaXMuc2hvd19jb250ZXh0bWVudSA9IGZ1bmN0aW9uIChvYmosIHgsIHksIGUpIHtcXG4gICAgICBvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XFxuXFxuICAgICAgaWYgKCFvYmogfHwgb2JqLmlkID09PSAkLmpzdHJlZS5yb290KSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBzID0gdGhpcy5zZXR0aW5ncy5jb250ZXh0bWVudSxcXG4gICAgICAgICAgZCA9IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKSxcXG4gICAgICAgICAgYSA9IGQuY2hpbGRyZW4oXFxcIi5qc3RyZWUtYW5jaG9yXFxcIiksXFxuICAgICAgICAgIG8gPSBmYWxzZSxcXG4gICAgICAgICAgaSA9IGZhbHNlO1xcblxcbiAgICAgIGlmIChzLnNob3dfYXRfbm9kZSB8fCB4ID09PSB1bmRlZmluZWQgfHwgeSA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICBvID0gYS5vZmZzZXQoKTtcXG4gICAgICAgIHggPSBvLmxlZnQ7XFxuICAgICAgICB5ID0gby50b3AgKyB0aGlzLl9kYXRhLmNvcmUubGlfaGVpZ2h0O1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5jb250ZXh0bWVudS5zZWxlY3Rfbm9kZSAmJiAhdGhpcy5pc19zZWxlY3RlZChvYmopKSB7XFxuICAgICAgICB0aGlzLmFjdGl2YXRlX25vZGUob2JqLCBlKTtcXG4gICAgICB9XFxuXFxuICAgICAgaSA9IHMuaXRlbXM7XFxuXFxuICAgICAgaWYgKCQuaXNGdW5jdGlvbihpKSkge1xcbiAgICAgICAgaSA9IGkuY2FsbCh0aGlzLCBvYmosICQucHJveHkoZnVuY3Rpb24gKGkpIHtcXG4gICAgICAgICAgdGhpcy5fc2hvd19jb250ZXh0bWVudShvYmosIHgsIHksIGkpO1xcbiAgICAgICAgfSwgdGhpcykpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoJC5pc1BsYWluT2JqZWN0KGkpKSB7XFxuICAgICAgICB0aGlzLl9zaG93X2NvbnRleHRtZW51KG9iaiwgeCwgeSwgaSk7XFxuICAgICAgfVxcbiAgICB9O1xcbiAgICAvKipcXG4gICAgICogc2hvdyB0aGUgcHJlcGFyZWQgY29udGV4dCBtZW51IGZvciBhIG5vZGVcXG4gICAgICogQG5hbWUgX3Nob3dfY29udGV4dG1lbnUob2JqLCB4LCB5LCBpKVxcbiAgICAgKiBAcGFyYW0ge21peGVkfSBvYmogdGhlIG5vZGVcXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggdGhlIHgtY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgZG9jdW1lbnQgdG8gc2hvdyB0aGUgbWVudSBhdFxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSB0aGUgeS1jb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBkb2N1bWVudCB0byBzaG93IHRoZSBtZW51IGF0XFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpIHRoZSBvYmplY3Qgb2YgaXRlbXMgdG8gc2hvd1xcbiAgICAgKiBAcGx1Z2luIGNvbnRleHRtZW51XFxuICAgICAqIEB0cmlnZ2VyIHNob3dfY29udGV4dG1lbnUuanN0cmVlXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcblxcbiAgICB0aGlzLl9zaG93X2NvbnRleHRtZW51ID0gZnVuY3Rpb24gKG9iaiwgeCwgeSwgaSkge1xcbiAgICAgIHZhciBkID0gdGhpcy5nZXRfbm9kZShvYmosIHRydWUpLFxcbiAgICAgICAgICBhID0gZC5jaGlsZHJlbihcXFwiLmpzdHJlZS1hbmNob3JcXFwiKTtcXG4gICAgICAkKGRvY3VtZW50KS5vbmUoXFxcImNvbnRleHRfc2hvdy52YWthdGEuanN0cmVlXFxcIiwgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xcbiAgICAgICAgdmFyIGNscyA9ICdqc3RyZWUtY29udGV4dG1lbnUganN0cmVlLScgKyB0aGlzLmdldF90aGVtZSgpICsgJy1jb250ZXh0bWVudSc7XFxuICAgICAgICAkKGRhdGEuZWxlbWVudCkuYWRkQ2xhc3MoY2xzKTtcXG4gICAgICAgIGEuYWRkQ2xhc3MoJ2pzdHJlZS1jb250ZXh0Jyk7XFxuICAgICAgfSwgdGhpcykpO1xcbiAgICAgIHRoaXMuX2RhdGEuY29udGV4dG1lbnUudmlzaWJsZSA9IHRydWU7XFxuICAgICAgJC52YWthdGEuY29udGV4dC5zaG93KGEsIHtcXG4gICAgICAgICd4JzogeCxcXG4gICAgICAgICd5JzogeVxcbiAgICAgIH0sIGkpO1xcbiAgICAgIC8qKlxcbiAgICAgICAqIHRyaWdnZXJlZCB3aGVuIHRoZSBjb250ZXh0bWVudSBpcyBzaG93biBmb3IgYSBub2RlXFxuICAgICAgICogQGV2ZW50XFxuICAgICAgICogQG5hbWUgc2hvd19jb250ZXh0bWVudS5qc3RyZWVcXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZSB0aGUgbm9kZVxcbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IHRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIG1lbnUgcmVsYXRpdmUgdG8gdGhlIGRvY3VtZW50XFxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgdGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgbWVudSByZWxhdGl2ZSB0byB0aGUgZG9jdW1lbnRcXG4gICAgICAgKiBAcGx1Z2luIGNvbnRleHRtZW51XFxuICAgICAgICovXFxuXFxuICAgICAgdGhpcy50cmlnZ2VyKCdzaG93X2NvbnRleHRtZW51Jywge1xcbiAgICAgICAgXFxcIm5vZGVcXFwiOiBvYmosXFxuICAgICAgICBcXFwieFxcXCI6IHgsXFxuICAgICAgICBcXFwieVxcXCI6IHlcXG4gICAgICB9KTtcXG4gICAgfTtcXG4gIH07IC8vIGNvbnRleHRtZW51IGhlbHBlclxcblxcblxcbiAgKGZ1bmN0aW9uICgkKSB7XFxuICAgIHZhciByaWdodF90b19sZWZ0ID0gZmFsc2UsXFxuICAgICAgICB2YWthdGFfY29udGV4dCA9IHtcXG4gICAgICBlbGVtZW50OiBmYWxzZSxcXG4gICAgICByZWZlcmVuY2U6IGZhbHNlLFxcbiAgICAgIHBvc2l0aW9uX3g6IDAsXFxuICAgICAgcG9zaXRpb25feTogMCxcXG4gICAgICBpdGVtczogW10sXFxuICAgICAgaHRtbDogXFxcIlxcXCIsXFxuICAgICAgaXNfdmlzaWJsZTogZmFsc2VcXG4gICAgfTtcXG4gICAgJC52YWthdGEuY29udGV4dCA9IHtcXG4gICAgICBzZXR0aW5nczoge1xcbiAgICAgICAgaGlkZV9vbm1vdXNlbGVhdmU6IDAsXFxuICAgICAgICBpY29uczogdHJ1ZVxcbiAgICAgIH0sXFxuICAgICAgX3RyaWdnZXI6IGZ1bmN0aW9uIF90cmlnZ2VyKGV2ZW50X25hbWUpIHtcXG4gICAgICAgICQoZG9jdW1lbnQpLnRyaWdnZXJIYW5kbGVyKFxcXCJjb250ZXh0X1xcXCIgKyBldmVudF9uYW1lICsgXFxcIi52YWthdGFcXFwiLCB7XFxuICAgICAgICAgIFxcXCJyZWZlcmVuY2VcXFwiOiB2YWthdGFfY29udGV4dC5yZWZlcmVuY2UsXFxuICAgICAgICAgIFxcXCJlbGVtZW50XFxcIjogdmFrYXRhX2NvbnRleHQuZWxlbWVudCxcXG4gICAgICAgICAgXFxcInBvc2l0aW9uXFxcIjoge1xcbiAgICAgICAgICAgIFxcXCJ4XFxcIjogdmFrYXRhX2NvbnRleHQucG9zaXRpb25feCxcXG4gICAgICAgICAgICBcXFwieVxcXCI6IHZha2F0YV9jb250ZXh0LnBvc2l0aW9uX3lcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgICAgfSxcXG4gICAgICBfZXhlY3V0ZTogZnVuY3Rpb24gX2V4ZWN1dGUoaSkge1xcbiAgICAgICAgaSA9IHZha2F0YV9jb250ZXh0Lml0ZW1zW2ldO1xcbiAgICAgICAgcmV0dXJuIGkgJiYgKCFpLl9kaXNhYmxlZCB8fCAkLmlzRnVuY3Rpb24oaS5fZGlzYWJsZWQpICYmICFpLl9kaXNhYmxlZCh7XFxuICAgICAgICAgIFxcXCJpdGVtXFxcIjogaSxcXG4gICAgICAgICAgXFxcInJlZmVyZW5jZVxcXCI6IHZha2F0YV9jb250ZXh0LnJlZmVyZW5jZSxcXG4gICAgICAgICAgXFxcImVsZW1lbnRcXFwiOiB2YWthdGFfY29udGV4dC5lbGVtZW50XFxuICAgICAgICB9KSkgJiYgaS5hY3Rpb24gPyBpLmFjdGlvbi5jYWxsKG51bGwsIHtcXG4gICAgICAgICAgXFxcIml0ZW1cXFwiOiBpLFxcbiAgICAgICAgICBcXFwicmVmZXJlbmNlXFxcIjogdmFrYXRhX2NvbnRleHQucmVmZXJlbmNlLFxcbiAgICAgICAgICBcXFwiZWxlbWVudFxcXCI6IHZha2F0YV9jb250ZXh0LmVsZW1lbnQsXFxuICAgICAgICAgIFxcXCJwb3NpdGlvblxcXCI6IHtcXG4gICAgICAgICAgICBcXFwieFxcXCI6IHZha2F0YV9jb250ZXh0LnBvc2l0aW9uX3gsXFxuICAgICAgICAgICAgXFxcInlcXFwiOiB2YWthdGFfY29udGV4dC5wb3NpdGlvbl95XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0pIDogZmFsc2U7XFxuICAgICAgfSxcXG4gICAgICBfcGFyc2U6IGZ1bmN0aW9uIF9wYXJzZShvLCBpc19jYWxsYmFjaykge1xcbiAgICAgICAgaWYgKCFvKSB7XFxuICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICghaXNfY2FsbGJhY2spIHtcXG4gICAgICAgICAgdmFrYXRhX2NvbnRleHQuaHRtbCA9IFxcXCJcXFwiO1xcbiAgICAgICAgICB2YWthdGFfY29udGV4dC5pdGVtcyA9IFtdO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdmFyIHN0ciA9IFxcXCJcXFwiLFxcbiAgICAgICAgICAgIHNlcCA9IGZhbHNlLFxcbiAgICAgICAgICAgIHRtcDtcXG5cXG4gICAgICAgIGlmIChpc19jYWxsYmFjaykge1xcbiAgICAgICAgICBzdHIgKz0gXFxcIjxcXFwiICsgXFxcInVsPlxcXCI7XFxuICAgICAgICB9XFxuXFxuICAgICAgICAkLmVhY2gobywgZnVuY3Rpb24gKGksIHZhbCkge1xcbiAgICAgICAgICBpZiAoIXZhbCkge1xcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHZha2F0YV9jb250ZXh0Lml0ZW1zLnB1c2godmFsKTtcXG5cXG4gICAgICAgICAgaWYgKCFzZXAgJiYgdmFsLnNlcGFyYXRvcl9iZWZvcmUpIHtcXG4gICAgICAgICAgICBzdHIgKz0gXFxcIjxcXFwiICsgXFxcImxpIGNsYXNzPSd2YWthdGEtY29udGV4dC1zZXBhcmF0b3InPjxcXFwiICsgXFxcImEgaHJlZj0nIycgXFxcIiArICgkLnZha2F0YS5jb250ZXh0LnNldHRpbmdzLmljb25zID8gJycgOiAnc3R5bGU9XFxcIm1hcmdpbi1sZWZ0OjBweDtcXFwiJykgKyBcXFwiPiYjMTYwOzxcXFwiICsgXFxcIi9hPjxcXFwiICsgXFxcIi9saT5cXFwiO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHNlcCA9IGZhbHNlO1xcbiAgICAgICAgICBzdHIgKz0gXFxcIjxcXFwiICsgXFxcImxpIGNsYXNzPSdcXFwiICsgKHZhbC5fY2xhc3MgfHwgXFxcIlxcXCIpICsgKHZhbC5fZGlzYWJsZWQgPT09IHRydWUgfHwgJC5pc0Z1bmN0aW9uKHZhbC5fZGlzYWJsZWQpICYmIHZhbC5fZGlzYWJsZWQoe1xcbiAgICAgICAgICAgIFxcXCJpdGVtXFxcIjogdmFsLFxcbiAgICAgICAgICAgIFxcXCJyZWZlcmVuY2VcXFwiOiB2YWthdGFfY29udGV4dC5yZWZlcmVuY2UsXFxuICAgICAgICAgICAgXFxcImVsZW1lbnRcXFwiOiB2YWthdGFfY29udGV4dC5lbGVtZW50XFxuICAgICAgICAgIH0pID8gXFxcIiB2YWthdGEtY29udGV4dG1lbnUtZGlzYWJsZWQgXFxcIiA6IFxcXCJcXFwiKSArIFxcXCInIFxcXCIgKyAodmFsLnNob3J0Y3V0ID8gXFxcIiBkYXRhLXNob3J0Y3V0PSdcXFwiICsgdmFsLnNob3J0Y3V0ICsgXFxcIicgXFxcIiA6ICcnKSArIFxcXCI+XFxcIjtcXG4gICAgICAgICAgc3RyICs9IFxcXCI8XFxcIiArIFxcXCJhIGhyZWY9JyMnIHJlbD0nXFxcIiArICh2YWthdGFfY29udGV4dC5pdGVtcy5sZW5ndGggLSAxKSArIFxcXCInIFxcXCIgKyAodmFsLnRpdGxlID8gXFxcInRpdGxlPSdcXFwiICsgdmFsLnRpdGxlICsgXFxcIidcXFwiIDogXFxcIlxcXCIpICsgXFxcIj5cXFwiO1xcblxcbiAgICAgICAgICBpZiAoJC52YWthdGEuY29udGV4dC5zZXR0aW5ncy5pY29ucykge1xcbiAgICAgICAgICAgIHN0ciArPSBcXFwiPFxcXCIgKyBcXFwiaSBcXFwiO1xcblxcbiAgICAgICAgICAgIGlmICh2YWwuaWNvbikge1xcbiAgICAgICAgICAgICAgaWYgKHZhbC5pY29uLmluZGV4T2YoXFxcIi9cXFwiKSAhPT0gLTEgfHwgdmFsLmljb24uaW5kZXhPZihcXFwiLlxcXCIpICE9PSAtMSkge1xcbiAgICAgICAgICAgICAgICBzdHIgKz0gXFxcIiBzdHlsZT0nYmFja2dyb3VuZDp1cmwoXFxcXFxcXCJcXFwiICsgdmFsLmljb24gKyBcXFwiXFxcXFxcXCIpIGNlbnRlciBjZW50ZXIgbm8tcmVwZWF0JyBcXFwiO1xcbiAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgc3RyICs9IFxcXCIgY2xhc3M9J1xcXCIgKyB2YWwuaWNvbiArIFxcXCInIFxcXCI7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIHN0ciArPSBcXFwiPjxcXFwiICsgXFxcIi9pPjxcXFwiICsgXFxcInNwYW4gY2xhc3M9J3Zha2F0YS1jb250ZXh0bWVudS1zZXAnPiYjMTYwOzxcXFwiICsgXFxcIi9zcGFuPlxcXCI7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgc3RyICs9ICgkLmlzRnVuY3Rpb24odmFsLmxhYmVsKSA/IHZhbC5sYWJlbCh7XFxuICAgICAgICAgICAgXFxcIml0ZW1cXFwiOiBpLFxcbiAgICAgICAgICAgIFxcXCJyZWZlcmVuY2VcXFwiOiB2YWthdGFfY29udGV4dC5yZWZlcmVuY2UsXFxuICAgICAgICAgICAgXFxcImVsZW1lbnRcXFwiOiB2YWthdGFfY29udGV4dC5lbGVtZW50XFxuICAgICAgICAgIH0pIDogdmFsLmxhYmVsKSArICh2YWwuc2hvcnRjdXQgPyAnIDxzcGFuIGNsYXNzPVxcXCJ2YWthdGEtY29udGV4dG1lbnUtc2hvcnRjdXQgdmFrYXRhLWNvbnRleHRtZW51LXNob3J0Y3V0LScgKyB2YWwuc2hvcnRjdXQgKyAnXFxcIj4nICsgKHZhbC5zaG9ydGN1dF9sYWJlbCB8fCAnJykgKyAnPC9zcGFuPicgOiAnJykgKyBcXFwiPFxcXCIgKyBcXFwiL2E+XFxcIjtcXG5cXG4gICAgICAgICAgaWYgKHZhbC5zdWJtZW51KSB7XFxuICAgICAgICAgICAgdG1wID0gJC52YWthdGEuY29udGV4dC5fcGFyc2UodmFsLnN1Ym1lbnUsIHRydWUpO1xcblxcbiAgICAgICAgICAgIGlmICh0bXApIHtcXG4gICAgICAgICAgICAgIHN0ciArPSB0bXA7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHN0ciArPSBcXFwiPFxcXCIgKyBcXFwiL2xpPlxcXCI7XFxuXFxuICAgICAgICAgIGlmICh2YWwuc2VwYXJhdG9yX2FmdGVyKSB7XFxuICAgICAgICAgICAgc3RyICs9IFxcXCI8XFxcIiArIFxcXCJsaSBjbGFzcz0ndmFrYXRhLWNvbnRleHQtc2VwYXJhdG9yJz48XFxcIiArIFxcXCJhIGhyZWY9JyMnIFxcXCIgKyAoJC52YWthdGEuY29udGV4dC5zZXR0aW5ncy5pY29ucyA/ICcnIDogJ3N0eWxlPVxcXCJtYXJnaW4tbGVmdDowcHg7XFxcIicpICsgXFxcIj4mIzE2MDs8XFxcIiArIFxcXCIvYT48XFxcIiArIFxcXCIvbGk+XFxcIjtcXG4gICAgICAgICAgICBzZXAgPSB0cnVlO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKC88bGkgY2xhc3NcXFxcPSd2YWthdGEtY29udGV4dC1zZXBhcmF0b3InXFxcXD48XFxcXC9saVxcXFw+JC8sIFxcXCJcXFwiKTtcXG5cXG4gICAgICAgIGlmIChpc19jYWxsYmFjaykge1xcbiAgICAgICAgICBzdHIgKz0gXFxcIjwvdWw+XFxcIjtcXG4gICAgICAgIH1cXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogdHJpZ2dlcmVkIG9uIHRoZSBkb2N1bWVudCB3aGVuIHRoZSBjb250ZXh0bWVudSBpcyBwYXJzZWQgKEhUTUwgaXMgYnVpbHQpXFxuICAgICAgICAgKiBAZXZlbnRcXG4gICAgICAgICAqIEBwbHVnaW4gY29udGV4dG1lbnVcXG4gICAgICAgICAqIEBuYW1lIGNvbnRleHRfcGFyc2UudmFrYXRhXFxuICAgICAgICAgKiBAcGFyYW0ge2pRdWVyeX0gcmVmZXJlbmNlIHRoZSBlbGVtZW50IHRoYXQgd2FzIHJpZ2h0IGNsaWNrZWRcXG4gICAgICAgICAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IHRoZSBET00gZWxlbWVudCBvZiB0aGUgbWVudSBpdHNlbGZcXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb3NpdGlvbiB0aGUgeCAmIHkgY29vcmRpbmF0ZXMgb2YgdGhlIG1lbnVcXG4gICAgICAgICAqL1xcblxcblxcbiAgICAgICAgaWYgKCFpc19jYWxsYmFjaykge1xcbiAgICAgICAgICB2YWthdGFfY29udGV4dC5odG1sID0gc3RyO1xcblxcbiAgICAgICAgICAkLnZha2F0YS5jb250ZXh0Ll90cmlnZ2VyKFxcXCJwYXJzZVxcXCIpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIHN0ci5sZW5ndGggPiAxMCA/IHN0ciA6IGZhbHNlO1xcbiAgICAgIH0sXFxuICAgICAgX3Nob3dfc3VibWVudTogZnVuY3Rpb24gX3Nob3dfc3VibWVudShvKSB7XFxuICAgICAgICBvID0gJChvKTtcXG5cXG4gICAgICAgIGlmICghby5sZW5ndGggfHwgIW8uY2hpbGRyZW4oXFxcInVsXFxcIikubGVuZ3RoKSB7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHZhciBlID0gby5jaGlsZHJlbihcXFwidWxcXFwiKSxcXG4gICAgICAgICAgICB4bCA9IG8ub2Zmc2V0KCkubGVmdCxcXG4gICAgICAgICAgICB4ID0geGwgKyBvLm91dGVyV2lkdGgoKSxcXG4gICAgICAgICAgICB5ID0gby5vZmZzZXQoKS50b3AsXFxuICAgICAgICAgICAgdyA9IGUud2lkdGgoKSxcXG4gICAgICAgICAgICBoID0gZS5oZWlnaHQoKSxcXG4gICAgICAgICAgICBkdyA9ICQod2luZG93KS53aWR0aCgpICsgJCh3aW5kb3cpLnNjcm9sbExlZnQoKSxcXG4gICAgICAgICAgICBkaCA9ICQod2luZG93KS5oZWlnaHQoKSArICQod2luZG93KS5zY3JvbGxUb3AoKTsgLy8g0LzQvtC20LUg0LTQsCDRgdC1INGB0L/QtdGB0YLQuCDQtSDQtdC00L3QsCDQv9GA0L7QstC10YDQutCwIC0g0LTQsNC70Lgg0L3Rj9C80LAg0L3Rj9C60L7QuSDQvtGCINC60LvQsNGB0L7QstC10YLQtSDQstC10YfQtSDQvdCw0LPQvtGA0LVcXG5cXG4gICAgICAgIGlmIChyaWdodF90b19sZWZ0KSB7XFxuICAgICAgICAgIG9beCAtICh3ICsgMTAgKyBvLm91dGVyV2lkdGgoKSkgPCAwID8gXFxcImFkZENsYXNzXFxcIiA6IFxcXCJyZW1vdmVDbGFzc1xcXCJdKFxcXCJ2YWthdGEtY29udGV4dC1sZWZ0XFxcIik7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBvW3ggKyB3ID4gZHcgJiYgeGwgPiBkdyAtIHggPyBcXFwiYWRkQ2xhc3NcXFwiIDogXFxcInJlbW92ZUNsYXNzXFxcIl0oXFxcInZha2F0YS1jb250ZXh0LXJpZ2h0XFxcIik7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoeSArIGggKyAxMCA+IGRoKSB7XFxuICAgICAgICAgIGUuY3NzKFxcXCJib3R0b21cXFwiLCBcXFwiLTFweFxcXCIpO1xcbiAgICAgICAgfSAvL2lmIGRvZXMgbm90IGZpdCAtIHN0aWNrIGl0IHRvIHRoZSBzaWRlXFxuXFxuXFxuICAgICAgICBpZiAoby5oYXNDbGFzcygndmFrYXRhLWNvbnRleHQtcmlnaHQnKSkge1xcbiAgICAgICAgICBpZiAoeGwgPCB3KSB7XFxuICAgICAgICAgICAgZS5jc3MoXFxcIm1hcmdpbi1yaWdodFxcXCIsIHhsIC0gdyk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGlmIChkdyAtIHggPCB3KSB7XFxuICAgICAgICAgICAgZS5jc3MoXFxcIm1hcmdpbi1sZWZ0XFxcIiwgZHcgLSB4IC0gdyk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGUuc2hvdygpO1xcbiAgICAgIH0sXFxuICAgICAgc2hvdzogZnVuY3Rpb24gc2hvdyhyZWZlcmVuY2UsIHBvc2l0aW9uLCBkYXRhKSB7XFxuICAgICAgICB2YXIgbyxcXG4gICAgICAgICAgICBlLFxcbiAgICAgICAgICAgIHgsXFxuICAgICAgICAgICAgeSxcXG4gICAgICAgICAgICB3LFxcbiAgICAgICAgICAgIGgsXFxuICAgICAgICAgICAgZHcsXFxuICAgICAgICAgICAgZGgsXFxuICAgICAgICAgICAgY29uZCA9IHRydWU7XFxuXFxuICAgICAgICBpZiAodmFrYXRhX2NvbnRleHQuZWxlbWVudCAmJiB2YWthdGFfY29udGV4dC5lbGVtZW50Lmxlbmd0aCkge1xcbiAgICAgICAgICB2YWthdGFfY29udGV4dC5lbGVtZW50LndpZHRoKCcnKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHN3aXRjaCAoY29uZCkge1xcbiAgICAgICAgICBjYXNlICFwb3NpdGlvbiAmJiAhcmVmZXJlbmNlOlxcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG5cXG4gICAgICAgICAgY2FzZSAhIXBvc2l0aW9uICYmICEhcmVmZXJlbmNlOlxcbiAgICAgICAgICAgIHZha2F0YV9jb250ZXh0LnJlZmVyZW5jZSA9IHJlZmVyZW5jZTtcXG4gICAgICAgICAgICB2YWthdGFfY29udGV4dC5wb3NpdGlvbl94ID0gcG9zaXRpb24ueDtcXG4gICAgICAgICAgICB2YWthdGFfY29udGV4dC5wb3NpdGlvbl95ID0gcG9zaXRpb24ueTtcXG4gICAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgICAgY2FzZSAhcG9zaXRpb24gJiYgISFyZWZlcmVuY2U6XFxuICAgICAgICAgICAgdmFrYXRhX2NvbnRleHQucmVmZXJlbmNlID0gcmVmZXJlbmNlO1xcbiAgICAgICAgICAgIG8gPSByZWZlcmVuY2Uub2Zmc2V0KCk7XFxuICAgICAgICAgICAgdmFrYXRhX2NvbnRleHQucG9zaXRpb25feCA9IG8ubGVmdCArIHJlZmVyZW5jZS5vdXRlckhlaWdodCgpO1xcbiAgICAgICAgICAgIHZha2F0YV9jb250ZXh0LnBvc2l0aW9uX3kgPSBvLnRvcDtcXG4gICAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgICAgY2FzZSAhIXBvc2l0aW9uICYmICFyZWZlcmVuY2U6XFxuICAgICAgICAgICAgdmFrYXRhX2NvbnRleHQucG9zaXRpb25feCA9IHBvc2l0aW9uLng7XFxuICAgICAgICAgICAgdmFrYXRhX2NvbnRleHQucG9zaXRpb25feSA9IHBvc2l0aW9uLnk7XFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoISFyZWZlcmVuY2UgJiYgIWRhdGEgJiYgJChyZWZlcmVuY2UpLmRhdGEoJ3Zha2F0YV9jb250ZXh0bWVudScpKSB7XFxuICAgICAgICAgIGRhdGEgPSAkKHJlZmVyZW5jZSkuZGF0YSgndmFrYXRhX2NvbnRleHRtZW51Jyk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoJC52YWthdGEuY29udGV4dC5fcGFyc2UoZGF0YSkpIHtcXG4gICAgICAgICAgdmFrYXRhX2NvbnRleHQuZWxlbWVudC5odG1sKHZha2F0YV9jb250ZXh0Lmh0bWwpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKHZha2F0YV9jb250ZXh0Lml0ZW1zLmxlbmd0aCkge1xcbiAgICAgICAgICB2YWthdGFfY29udGV4dC5lbGVtZW50LmFwcGVuZFRvKFxcXCJib2R5XFxcIik7XFxuICAgICAgICAgIGUgPSB2YWthdGFfY29udGV4dC5lbGVtZW50O1xcbiAgICAgICAgICB4ID0gdmFrYXRhX2NvbnRleHQucG9zaXRpb25feDtcXG4gICAgICAgICAgeSA9IHZha2F0YV9jb250ZXh0LnBvc2l0aW9uX3k7XFxuICAgICAgICAgIHcgPSBlLndpZHRoKCk7XFxuICAgICAgICAgIGggPSBlLmhlaWdodCgpO1xcbiAgICAgICAgICBkdyA9ICQod2luZG93KS53aWR0aCgpICsgJCh3aW5kb3cpLnNjcm9sbExlZnQoKTtcXG4gICAgICAgICAgZGggPSAkKHdpbmRvdykuaGVpZ2h0KCkgKyAkKHdpbmRvdykuc2Nyb2xsVG9wKCk7XFxuXFxuICAgICAgICAgIGlmIChyaWdodF90b19sZWZ0KSB7XFxuICAgICAgICAgICAgeCAtPSBlLm91dGVyV2lkdGgoKSAtICQocmVmZXJlbmNlKS5vdXRlcldpZHRoKCk7XFxuXFxuICAgICAgICAgICAgaWYgKHggPCAkKHdpbmRvdykuc2Nyb2xsTGVmdCgpICsgMjApIHtcXG4gICAgICAgICAgICAgIHggPSAkKHdpbmRvdykuc2Nyb2xsTGVmdCgpICsgMjA7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmICh4ICsgdyArIDIwID4gZHcpIHtcXG4gICAgICAgICAgICB4ID0gZHcgLSAodyArIDIwKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAoeSArIGggKyAyMCA+IGRoKSB7XFxuICAgICAgICAgICAgeSA9IGRoIC0gKGggKyAyMCk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgdmFrYXRhX2NvbnRleHQuZWxlbWVudC5jc3Moe1xcbiAgICAgICAgICAgIFxcXCJsZWZ0XFxcIjogeCxcXG4gICAgICAgICAgICBcXFwidG9wXFxcIjogeVxcbiAgICAgICAgICB9KS5zaG93KCkuZmluZCgnYScpLmZpcnN0KCkuZm9jdXMoKS5wYXJlbnQoKS5hZGRDbGFzcyhcXFwidmFrYXRhLWNvbnRleHQtaG92ZXJcXFwiKTtcXG4gICAgICAgICAgdmFrYXRhX2NvbnRleHQuaXNfdmlzaWJsZSA9IHRydWU7XFxuICAgICAgICAgIC8qKlxcbiAgICAgICAgICAgKiB0cmlnZ2VyZWQgb24gdGhlIGRvY3VtZW50IHdoZW4gdGhlIGNvbnRleHRtZW51IGlzIHNob3duXFxuICAgICAgICAgICAqIEBldmVudFxcbiAgICAgICAgICAgKiBAcGx1Z2luIGNvbnRleHRtZW51XFxuICAgICAgICAgICAqIEBuYW1lIGNvbnRleHRfc2hvdy52YWthdGFcXG4gICAgICAgICAgICogQHBhcmFtIHtqUXVlcnl9IHJlZmVyZW5jZSB0aGUgZWxlbWVudCB0aGF0IHdhcyByaWdodCBjbGlja2VkXFxuICAgICAgICAgICAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IHRoZSBET00gZWxlbWVudCBvZiB0aGUgbWVudSBpdHNlbGZcXG4gICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHBvc2l0aW9uIHRoZSB4ICYgeSBjb29yZGluYXRlcyBvZiB0aGUgbWVudVxcbiAgICAgICAgICAgKi9cXG5cXG4gICAgICAgICAgJC52YWthdGEuY29udGV4dC5fdHJpZ2dlcihcXFwic2hvd1xcXCIpO1xcbiAgICAgICAgfVxcbiAgICAgIH0sXFxuICAgICAgaGlkZTogZnVuY3Rpb24gaGlkZSgpIHtcXG4gICAgICAgIGlmICh2YWthdGFfY29udGV4dC5pc192aXNpYmxlKSB7XFxuICAgICAgICAgIHZha2F0YV9jb250ZXh0LmVsZW1lbnQuaGlkZSgpLmZpbmQoXFxcInVsXFxcIikuaGlkZSgpLmVuZCgpLmZpbmQoJzpmb2N1cycpLmJsdXIoKS5lbmQoKS5kZXRhY2goKTtcXG4gICAgICAgICAgdmFrYXRhX2NvbnRleHQuaXNfdmlzaWJsZSA9IGZhbHNlO1xcbiAgICAgICAgICAvKipcXG4gICAgICAgICAgICogdHJpZ2dlcmVkIG9uIHRoZSBkb2N1bWVudCB3aGVuIHRoZSBjb250ZXh0bWVudSBpcyBoaWRkZW5cXG4gICAgICAgICAgICogQGV2ZW50XFxuICAgICAgICAgICAqIEBwbHVnaW4gY29udGV4dG1lbnVcXG4gICAgICAgICAgICogQG5hbWUgY29udGV4dF9oaWRlLnZha2F0YVxcbiAgICAgICAgICAgKiBAcGFyYW0ge2pRdWVyeX0gcmVmZXJlbmNlIHRoZSBlbGVtZW50IHRoYXQgd2FzIHJpZ2h0IGNsaWNrZWRcXG4gICAgICAgICAgICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgdGhlIERPTSBlbGVtZW50IG9mIHRoZSBtZW51IGl0c2VsZlxcbiAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9zaXRpb24gdGhlIHggJiB5IGNvb3JkaW5hdGVzIG9mIHRoZSBtZW51XFxuICAgICAgICAgICAqL1xcblxcbiAgICAgICAgICAkLnZha2F0YS5jb250ZXh0Ll90cmlnZ2VyKFxcXCJoaWRlXFxcIik7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9O1xcbiAgICAkKGZ1bmN0aW9uICgpIHtcXG4gICAgICByaWdodF90b19sZWZ0ID0gJChcXFwiYm9keVxcXCIpLmNzcyhcXFwiZGlyZWN0aW9uXFxcIikgPT09IFxcXCJydGxcXFwiO1xcbiAgICAgIHZhciB0byA9IGZhbHNlO1xcbiAgICAgIHZha2F0YV9jb250ZXh0LmVsZW1lbnQgPSAkKFxcXCI8dWwgY2xhc3M9J3Zha2F0YS1jb250ZXh0Jz48L3VsPlxcXCIpO1xcbiAgICAgIHZha2F0YV9jb250ZXh0LmVsZW1lbnQub24oXFxcIm1vdXNlZW50ZXJcXFwiLCBcXFwibGlcXFwiLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcXG5cXG4gICAgICAgIGlmICgkLmNvbnRhaW5zKHRoaXMsIGUucmVsYXRlZFRhcmdldCkpIHtcXG4gICAgICAgICAgLy8g0L/RgNC10LzQsNGF0L3QsNGC0L4g0LfQsNGA0LDQtNC4IGRlbGVnYXRlIG1vdXNlbGVhdmUg0L/Qvi3QtNC+0LvRg1xcbiAgICAgICAgICAvLyAkKHRoaXMpLmZpbmQoXFxcIi52YWthdGEtY29udGV4dC1ob3ZlclxcXCIpLnJlbW92ZUNsYXNzKFxcXCJ2YWthdGEtY29udGV4dC1ob3ZlclxcXCIpO1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAodG8pIHtcXG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRvKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHZha2F0YV9jb250ZXh0LmVsZW1lbnQuZmluZChcXFwiLnZha2F0YS1jb250ZXh0LWhvdmVyXFxcIikucmVtb3ZlQ2xhc3MoXFxcInZha2F0YS1jb250ZXh0LWhvdmVyXFxcIikuZW5kKCk7XFxuICAgICAgICAkKHRoaXMpLnNpYmxpbmdzKCkuZmluZChcXFwidWxcXFwiKS5oaWRlKCkuZW5kKCkuZW5kKCkucGFyZW50c1VudGlsKFxcXCIudmFrYXRhLWNvbnRleHRcXFwiLCBcXFwibGlcXFwiKS5hZGRCYWNrKCkuYWRkQ2xhc3MoXFxcInZha2F0YS1jb250ZXh0LWhvdmVyXFxcIik7XFxuXFxuICAgICAgICAkLnZha2F0YS5jb250ZXh0Ll9zaG93X3N1Ym1lbnUodGhpcyk7XFxuICAgICAgfSkgLy8g0YLQtdGB0YLQvtCy0L4gLSDQtNCw0LvQuCDQvdC1INC90LDRgtC+0LLQsNGA0LLQsD9cXG4gICAgICAub24oXFxcIm1vdXNlbGVhdmVcXFwiLCBcXFwibGlcXFwiLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgaWYgKCQuY29udGFpbnModGhpcywgZS5yZWxhdGVkVGFyZ2V0KSkge1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICAkKHRoaXMpLmZpbmQoXFxcIi52YWthdGEtY29udGV4dC1ob3ZlclxcXCIpLmFkZEJhY2soKS5yZW1vdmVDbGFzcyhcXFwidmFrYXRhLWNvbnRleHQtaG92ZXJcXFwiKTtcXG4gICAgICB9KS5vbihcXFwibW91c2VsZWF2ZVxcXCIsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICAkKHRoaXMpLmZpbmQoXFxcIi52YWthdGEtY29udGV4dC1ob3ZlclxcXCIpLnJlbW92ZUNsYXNzKFxcXCJ2YWthdGEtY29udGV4dC1ob3ZlclxcXCIpO1xcblxcbiAgICAgICAgaWYgKCQudmFrYXRhLmNvbnRleHQuc2V0dGluZ3MuaGlkZV9vbm1vdXNlbGVhdmUpIHtcXG4gICAgICAgICAgdG8gPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICh0KSB7XFxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICQudmFrYXRhLmNvbnRleHQuaGlkZSgpO1xcbiAgICAgICAgICAgIH07XFxuICAgICAgICAgIH0odGhpcyksICQudmFrYXRhLmNvbnRleHQuc2V0dGluZ3MuaGlkZV9vbm1vdXNlbGVhdmUpO1xcbiAgICAgICAgfVxcbiAgICAgIH0pLm9uKFxcXCJjbGlja1xcXCIsIFxcXCJhXFxcIiwgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTsgLy99KVxcbiAgICAgICAgLy8ub24oXFxcIm1vdXNldXBcXFwiLCBcXFwiYVxcXCIsIGZ1bmN0aW9uIChlKSB7XFxuXFxuICAgICAgICBpZiAoISQodGhpcykuYmx1cigpLnBhcmVudCgpLmhhc0NsYXNzKFxcXCJ2YWthdGEtY29udGV4dC1kaXNhYmxlZFxcXCIpICYmICQudmFrYXRhLmNvbnRleHQuX2V4ZWN1dGUoJCh0aGlzKS5hdHRyKFxcXCJyZWxcXFwiKSkgIT09IGZhbHNlKSB7XFxuICAgICAgICAgICQudmFrYXRhLmNvbnRleHQuaGlkZSgpO1xcbiAgICAgICAgfVxcbiAgICAgIH0pLm9uKCdrZXlkb3duJywgJ2EnLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgdmFyIG8gPSBudWxsO1xcblxcbiAgICAgICAgc3dpdGNoIChlLndoaWNoKSB7XFxuICAgICAgICAgIGNhc2UgMTM6XFxuICAgICAgICAgIGNhc2UgMzI6XFxuICAgICAgICAgICAgZS50eXBlID0gXFxcImNsaWNrXFxcIjtcXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICAgICAgJChlLmN1cnJlbnRUYXJnZXQpLnRyaWdnZXIoZSk7XFxuICAgICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICAgIGNhc2UgMzc6XFxuICAgICAgICAgICAgaWYgKHZha2F0YV9jb250ZXh0LmlzX3Zpc2libGUpIHtcXG4gICAgICAgICAgICAgIHZha2F0YV9jb250ZXh0LmVsZW1lbnQuZmluZChcXFwiLnZha2F0YS1jb250ZXh0LWhvdmVyXFxcIikubGFzdCgpLmNsb3Nlc3QoXFxcImxpXFxcIikuZmlyc3QoKS5maW5kKFxcXCJ1bFxcXCIpLmhpZGUoKS5maW5kKFxcXCIudmFrYXRhLWNvbnRleHQtaG92ZXJcXFwiKS5yZW1vdmVDbGFzcyhcXFwidmFrYXRhLWNvbnRleHQtaG92ZXJcXFwiKS5lbmQoKS5lbmQoKS5jaGlsZHJlbignYScpLmZvY3VzKCk7XFxuICAgICAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xcbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgICAgY2FzZSAzODpcXG4gICAgICAgICAgICBpZiAodmFrYXRhX2NvbnRleHQuaXNfdmlzaWJsZSkge1xcbiAgICAgICAgICAgICAgbyA9IHZha2F0YV9jb250ZXh0LmVsZW1lbnQuZmluZChcXFwidWw6dmlzaWJsZVxcXCIpLmFkZEJhY2soKS5sYXN0KCkuY2hpbGRyZW4oXFxcIi52YWthdGEtY29udGV4dC1ob3ZlclxcXCIpLnJlbW92ZUNsYXNzKFxcXCJ2YWthdGEtY29udGV4dC1ob3ZlclxcXCIpLnByZXZBbGwoXFxcImxpOm5vdCgudmFrYXRhLWNvbnRleHQtc2VwYXJhdG9yKVxcXCIpLmZpcnN0KCk7XFxuXFxuICAgICAgICAgICAgICBpZiAoIW8ubGVuZ3RoKSB7XFxuICAgICAgICAgICAgICAgIG8gPSB2YWthdGFfY29udGV4dC5lbGVtZW50LmZpbmQoXFxcInVsOnZpc2libGVcXFwiKS5hZGRCYWNrKCkubGFzdCgpLmNoaWxkcmVuKFxcXCJsaTpub3QoLnZha2F0YS1jb250ZXh0LXNlcGFyYXRvcilcXFwiKS5sYXN0KCk7XFxuICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICBvLmFkZENsYXNzKFxcXCJ2YWthdGEtY29udGV4dC1ob3ZlclxcXCIpLmNoaWxkcmVuKCdhJykuZm9jdXMoKTtcXG4gICAgICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XFxuICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICBjYXNlIDM5OlxcbiAgICAgICAgICAgIGlmICh2YWthdGFfY29udGV4dC5pc192aXNpYmxlKSB7XFxuICAgICAgICAgICAgICB2YWthdGFfY29udGV4dC5lbGVtZW50LmZpbmQoXFxcIi52YWthdGEtY29udGV4dC1ob3ZlclxcXCIpLmxhc3QoKS5jaGlsZHJlbihcXFwidWxcXFwiKS5zaG93KCkuY2hpbGRyZW4oXFxcImxpOm5vdCgudmFrYXRhLWNvbnRleHQtc2VwYXJhdG9yKVxcXCIpLnJlbW92ZUNsYXNzKFxcXCJ2YWthdGEtY29udGV4dC1ob3ZlclxcXCIpLmZpcnN0KCkuYWRkQ2xhc3MoXFxcInZha2F0YS1jb250ZXh0LWhvdmVyXFxcIikuY2hpbGRyZW4oJ2EnKS5mb2N1cygpO1xcbiAgICAgICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcXG4gICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICAgIGNhc2UgNDA6XFxuICAgICAgICAgICAgaWYgKHZha2F0YV9jb250ZXh0LmlzX3Zpc2libGUpIHtcXG4gICAgICAgICAgICAgIG8gPSB2YWthdGFfY29udGV4dC5lbGVtZW50LmZpbmQoXFxcInVsOnZpc2libGVcXFwiKS5hZGRCYWNrKCkubGFzdCgpLmNoaWxkcmVuKFxcXCIudmFrYXRhLWNvbnRleHQtaG92ZXJcXFwiKS5yZW1vdmVDbGFzcyhcXFwidmFrYXRhLWNvbnRleHQtaG92ZXJcXFwiKS5uZXh0QWxsKFxcXCJsaTpub3QoLnZha2F0YS1jb250ZXh0LXNlcGFyYXRvcilcXFwiKS5maXJzdCgpO1xcblxcbiAgICAgICAgICAgICAgaWYgKCFvLmxlbmd0aCkge1xcbiAgICAgICAgICAgICAgICBvID0gdmFrYXRhX2NvbnRleHQuZWxlbWVudC5maW5kKFxcXCJ1bDp2aXNpYmxlXFxcIikuYWRkQmFjaygpLmxhc3QoKS5jaGlsZHJlbihcXFwibGk6bm90KC52YWthdGEtY29udGV4dC1zZXBhcmF0b3IpXFxcIikuZmlyc3QoKTtcXG4gICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgIG8uYWRkQ2xhc3MoXFxcInZha2F0YS1jb250ZXh0LWhvdmVyXFxcIikuY2hpbGRyZW4oJ2EnKS5mb2N1cygpO1xcbiAgICAgICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcXG4gICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICAgIGNhc2UgMjc6XFxuICAgICAgICAgICAgJC52YWthdGEuY29udGV4dC5oaWRlKCk7XFxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICBkZWZhdWx0OlxcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coZS53aGljaCk7XFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICB9XFxuICAgICAgfSkub24oJ2tleWRvd24nLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgdmFyIGEgPSB2YWthdGFfY29udGV4dC5lbGVtZW50LmZpbmQoJy52YWthdGEtY29udGV4dG1lbnUtc2hvcnRjdXQtJyArIGUud2hpY2gpLnBhcmVudCgpO1xcblxcbiAgICAgICAgaWYgKGEucGFyZW50KCkubm90KCcudmFrYXRhLWNvbnRleHQtZGlzYWJsZWQnKSkge1xcbiAgICAgICAgICBhLmNsaWNrKCk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgICAgJChkb2N1bWVudCkub24oXFxcIm1vdXNlZG93bi52YWthdGEuanN0cmVlXFxcIiwgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgIGlmICh2YWthdGFfY29udGV4dC5pc192aXNpYmxlICYmICEkLmNvbnRhaW5zKHZha2F0YV9jb250ZXh0LmVsZW1lbnRbMF0sIGUudGFyZ2V0KSkge1xcbiAgICAgICAgICAkLnZha2F0YS5jb250ZXh0LmhpZGUoKTtcXG4gICAgICAgIH1cXG4gICAgICB9KS5vbihcXFwiY29udGV4dF9zaG93LnZha2F0YS5qc3RyZWVcXFwiLCBmdW5jdGlvbiAoZSwgZGF0YSkge1xcbiAgICAgICAgdmFrYXRhX2NvbnRleHQuZWxlbWVudC5maW5kKFxcXCJsaTpoYXModWwpXFxcIikuY2hpbGRyZW4oXFxcImFcXFwiKS5hZGRDbGFzcyhcXFwidmFrYXRhLWNvbnRleHQtcGFyZW50XFxcIik7XFxuXFxuICAgICAgICBpZiAocmlnaHRfdG9fbGVmdCkge1xcbiAgICAgICAgICB2YWthdGFfY29udGV4dC5lbGVtZW50LmFkZENsYXNzKFxcXCJ2YWthdGEtY29udGV4dC1ydGxcXFwiKS5jc3MoXFxcImRpcmVjdGlvblxcXCIsIFxcXCJydGxcXFwiKTtcXG4gICAgICAgIH0gLy8gYWxzbyBhcHBseSBhIFJUTCBjbGFzcz9cXG5cXG5cXG4gICAgICAgIHZha2F0YV9jb250ZXh0LmVsZW1lbnQuZmluZChcXFwidWxcXFwiKS5oaWRlKCkuZW5kKCk7XFxuICAgICAgfSk7XFxuICAgIH0pO1xcbiAgfSkoJCk7IC8vICQuanN0cmVlLmRlZmF1bHRzLnBsdWdpbnMucHVzaChcXFwiY29udGV4dG1lbnVcXFwiKTtcXG5cXG4gIC8qKlxcbiAgICogIyMjIERyYWcnbidkcm9wIHBsdWdpblxcbiAgICpcXG4gICAqIEVuYWJsZXMgZHJhZ2dpbmcgYW5kIGRyb3BwaW5nIG9mIG5vZGVzIGluIHRoZSB0cmVlLCByZXN1bHRpbmcgaW4gYSBtb3ZlIG9yIGNvcHkgb3BlcmF0aW9ucy5cXG4gICAqL1xcblxcbiAgLyoqXFxuICAgKiBzdG9yZXMgYWxsIGRlZmF1bHRzIGZvciB0aGUgZHJhZyduJ2Ryb3AgcGx1Z2luXFxuICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5kbmRcXG4gICAqIEBwbHVnaW4gZG5kXFxuICAgKi9cXG5cXG5cXG4gICQuanN0cmVlLmRlZmF1bHRzLmRuZCA9IHtcXG4gICAgLyoqXFxuICAgICAqIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIGEgY29weSBzaG91bGQgYmUgcG9zc2libGUgd2hpbGUgZHJhZ2dpbmcgKGJ5IHByZXNzaW50IHRoZSBtZXRhIGtleSBvciBDdHJsKS4gRGVmYXVsdHMgdG8gYHRydWVgLlxcbiAgICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5kbmQuY29weVxcbiAgICAgKiBAcGx1Z2luIGRuZFxcbiAgICAgKi9cXG4gICAgY29weTogdHJ1ZSxcXG5cXG4gICAgLyoqXFxuICAgICAqIGEgbnVtYmVyIGluZGljYXRpbmcgaG93IGxvbmcgYSBub2RlIHNob3VsZCByZW1haW4gaG92ZXJlZCB3aGlsZSBkcmFnZ2luZyB0byBiZSBvcGVuZWQuIERlZmF1bHRzIHRvIGA1MDBgLlxcbiAgICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5kbmQub3Blbl90aW1lb3V0XFxuICAgICAqIEBwbHVnaW4gZG5kXFxuICAgICAqL1xcbiAgICBvcGVuX3RpbWVvdXQ6IDUwMCxcXG5cXG4gICAgLyoqXFxuICAgICAqIGEgZnVuY3Rpb24gaW52b2tlZCBlYWNoIHRpbWUgYSBub2RlIGlzIGFib3V0IHRvIGJlIGRyYWdnZWQsIGludm9rZWQgaW4gdGhlIHRyZWUncyBzY29wZSBhbmQgcmVjZWl2ZXMgdGhlIG5vZGVzIGFib3V0IHRvIGJlIGRyYWdnZWQgYXMgYW4gYXJndW1lbnQgKGFycmF5KSBhbmQgdGhlIGV2ZW50IHRoYXQgc3RhcnRlZCB0aGUgZHJhZyAtIHJldHVybiBgZmFsc2VgIHRvIHByZXZlbnQgZHJhZ2dpbmdcXG4gICAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuZG5kLmlzX2RyYWdnYWJsZVxcbiAgICAgKiBAcGx1Z2luIGRuZFxcbiAgICAgKi9cXG4gICAgaXNfZHJhZ2dhYmxlOiB0cnVlLFxcblxcbiAgICAvKipcXG4gICAgICogYSBib29sZWFuIGluZGljYXRpbmcgaWYgY2hlY2tzIHNob3VsZCBjb25zdGFudGx5IGJlIG1hZGUgd2hpbGUgdGhlIHVzZXIgaXMgZHJhZ2dpbmcgdGhlIG5vZGUgKGFzIG9wcG9zZWQgdG8gY2hlY2tpbmcgb25seSBvbiBkcm9wKSwgZGVmYXVsdCBpcyBgdHJ1ZWBcXG4gICAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuZG5kLmNoZWNrX3doaWxlX2RyYWdnaW5nXFxuICAgICAqIEBwbHVnaW4gZG5kXFxuICAgICAqL1xcbiAgICBjaGVja193aGlsZV9kcmFnZ2luZzogdHJ1ZSxcXG5cXG4gICAgLyoqXFxuICAgICAqIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIG5vZGVzIGZyb20gdGhpcyB0cmVlIHNob3VsZCBvbmx5IGJlIGNvcGllZCB3aXRoIGRuZCAoYXMgb3Bwb3NlZCB0byBtb3ZlZCksIGRlZmF1bHQgaXMgYGZhbHNlYFxcbiAgICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5kbmQuYWx3YXlzX2NvcHlcXG4gICAgICogQHBsdWdpbiBkbmRcXG4gICAgICovXFxuICAgIGFsd2F5c19jb3B5OiBmYWxzZSxcXG5cXG4gICAgLyoqXFxuICAgICAqIHdoZW4gZHJvcHBpbmcgYSBub2RlIFxcXCJpbnNpZGVcXFwiLCB0aGlzIHNldHRpbmcgaW5kaWNhdGVzIHRoZSBwb3NpdGlvbiB0aGUgbm9kZSBzaG91bGQgZ28gdG8gLSBpdCBjYW4gYmUgYW4gaW50ZWdlciBvciBhIHN0cmluZzogXFxcImZpcnN0XFxcIiAoc2FtZSBhcyAwKSBvciBcXFwibGFzdFxcXCIsIGRlZmF1bHQgaXMgYDBgXFxuICAgICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmRuZC5pbnNpZGVfcG9zXFxuICAgICAqIEBwbHVnaW4gZG5kXFxuICAgICAqL1xcbiAgICBpbnNpZGVfcG9zOiAwLFxcblxcbiAgICAvKipcXG4gICAgICogd2hlbiBzdGFydGluZyB0aGUgZHJhZyBvbiBhIG5vZGUgdGhhdCBpcyBzZWxlY3RlZCB0aGlzIHNldHRpbmcgY29udHJvbHMgaWYgYWxsIHNlbGVjdGVkIG5vZGVzIGFyZSBkcmFnZ2VkIG9yIG9ubHkgdGhlIHNpbmdsZSBub2RlLCBkZWZhdWx0IGlzIGB0cnVlYCwgd2hpY2ggbWVhbnMgYWxsIHNlbGVjdGVkIG5vZGVzIGFyZSBkcmFnZ2VkIHdoZW4gdGhlIGRyYWcgaXMgc3RhcnRlZCBvbiBhIHNlbGVjdGVkIG5vZGVcXG4gICAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuZG5kLmRyYWdfc2VsZWN0aW9uXFxuICAgICAqIEBwbHVnaW4gZG5kXFxuICAgICAqL1xcbiAgICBkcmFnX3NlbGVjdGlvbjogdHJ1ZSxcXG5cXG4gICAgLyoqXFxuICAgICAqIGNvbnRyb2xzIHdoZXRoZXIgZG5kIHdvcmtzIG9uIHRvdWNoIGRldmljZXMuIElmIGxlZnQgYXMgYm9vbGVhbiB0cnVlIGRuZCB3aWxsIHdvcmsgdGhlIHNhbWUgYXMgaW4gZGVza3RvcCBicm93c2Vycywgd2hpY2ggaW4gc29tZSBjYXNlcyBtYXkgaW1wYWlyIHNjcm9sbGluZy4gSWYgc2V0IHRvIGJvb2xlYW4gZmFsc2UgZG5kIHdpbGwgbm90IHdvcmsgb24gdG91Y2ggZGV2aWNlcy4gVGhlcmUgaXMgYSBzcGVjaWFsIHRoaXJkIG9wdGlvbiAtIHN0cmluZyBcXFwic2VsZWN0ZWRcXFwiIHdoaWNoIG1lYW5zIG9ubHkgc2VsZWN0ZWQgbm9kZXMgY2FuIGJlIGRyYWdnZWQgb24gdG91Y2ggZGV2aWNlcy5cXG4gICAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuZG5kLnRvdWNoXFxuICAgICAqIEBwbHVnaW4gZG5kXFxuICAgICAqL1xcbiAgICB0b3VjaDogdHJ1ZSxcXG5cXG4gICAgLyoqXFxuICAgICAqIGNvbnRyb2xzIHdoZXRoZXIgaXRlbXMgY2FuIGJlIGRyb3BwZWQgYW55d2hlcmUgb24gdGhlIG5vZGUsIG5vdCBqdXN0IG9uIHRoZSBhbmNob3IsIGJ5IGRlZmF1bHQgb25seSB0aGUgbm9kZSBhbmNob3IgaXMgYSB2YWxpZCBkcm9wIHRhcmdldC4gV29ya3MgYmVzdCB3aXRoIHRoZSB3aG9sZXJvdyBwbHVnaW4uIElmIGVuYWJsZWQgb24gbW9iaWxlIGRlcGVuZGluZyBvbiB0aGUgaW50ZXJmYWNlIGl0IG1pZ2h0IGJlIGhhcmQgZm9yIHRoZSB1c2VyIHRvIGNhbmNlbCB0aGUgZHJvcCwgc2luY2UgdGhlIHdob2xlIHRyZWUgY29udGFpbmVyIHdpbGwgYmUgYSB2YWxpZCBkcm9wIHRhcmdldC5cXG4gICAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuZG5kLmxhcmdlX2Ryb3BfdGFyZ2V0XFxuICAgICAqIEBwbHVnaW4gZG5kXFxuICAgICAqL1xcbiAgICBsYXJnZV9kcm9wX3RhcmdldDogZmFsc2UsXFxuXFxuICAgIC8qKlxcbiAgICAgKiBjb250cm9scyB3aGV0aGVyIGEgZHJhZyBjYW4gYmUgaW5pdGlhdGVkIGZyb20gYW55IHBhcnQgb2YgdGhlIG5vZGUgYW5kIG5vdCBqdXN0IHRoZSB0ZXh0L2ljb24gcGFydCwgd29ya3MgYmVzdCB3aXRoIHRoZSB3aG9sZXJvdyBwbHVnaW4uIEtlZXAgaW4gbWluZCBpdCBjYW4gY2F1c2UgcHJvYmxlbXMgd2l0aCB0cmVlIHNjcm9sbGluZyBvbiBtb2JpbGUgZGVwZW5kaW5nIG9uIHRoZSBpbnRlcmZhY2UgLSBpbiB0aGF0IGNhc2Ugc2V0IHRoZSB0b3VjaCBvcHRpb24gdG8gXFxcInNlbGVjdGVkXFxcIi5cXG4gICAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuZG5kLmxhcmdlX2RyYWdfdGFyZ2V0XFxuICAgICAqIEBwbHVnaW4gZG5kXFxuICAgICAqL1xcbiAgICBsYXJnZV9kcmFnX3RhcmdldDogZmFsc2UsXFxuXFxuICAgIC8qKlxcbiAgICAgKiBjb250cm9scyB3aGV0aGVyIHVzZSBIVE1MNSBkbmQgYXBpIGluc3RlYWQgb2YgY2xhc3NpY2FsLiBUaGF0IHdpbGwgYWxsb3cgYmV0dGVyIGludGVncmF0aW9uIG9mIGRuZCBldmVudHMgd2l0aCBvdGhlciBIVE1MNSBjb250cm9scy5cXG4gICAgICogQHJlZmVyZW5jZSBodHRwOi8vY2FuaXVzZS5jb20vI2ZlYXQ9ZHJhZ25kcm9wXFxuICAgICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmRuZC51c2VfaHRtbDVcXG4gICAgICogQHBsdWdpbiBkbmRcXG4gICAgICovXFxuICAgIHVzZV9odG1sNTogZmFsc2VcXG4gIH07XFxuICB2YXIgZHJnLCBlbG07IC8vIFRPRE86IG5vdyBjaGVjayB3b3JrcyBieSBjaGVja2luZyBmb3IgZWFjaCBub2RlIGluZGl2aWR1YWxseSwgaG93IGFib3V0IG1heF9jaGlsZHJlbiwgdW5pcXVlLCBldGM/XFxuXFxuICAkLmpzdHJlZS5wbHVnaW5zLmRuZCA9IGZ1bmN0aW9uIChvcHRpb25zLCBwYXJlbnQpIHtcXG4gICAgdGhpcy5pbml0ID0gZnVuY3Rpb24gKGVsLCBvcHRpb25zKSB7XFxuICAgICAgcGFyZW50LmluaXQuY2FsbCh0aGlzLCBlbCwgb3B0aW9ucyk7XFxuICAgICAgdGhpcy5zZXR0aW5ncy5kbmQudXNlX2h0bWw1ID0gdGhpcy5zZXR0aW5ncy5kbmQudXNlX2h0bWw1ICYmICdkcmFnZ2FibGUnIGluIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5iaW5kID0gZnVuY3Rpb24gKCkge1xcbiAgICAgIHBhcmVudC5iaW5kLmNhbGwodGhpcyk7XFxuICAgICAgdGhpcy5lbGVtZW50Lm9uKHRoaXMuc2V0dGluZ3MuZG5kLnVzZV9odG1sNSA/ICdkcmFnc3RhcnQuanN0cmVlJyA6ICdtb3VzZWRvd24uanN0cmVlIHRvdWNoc3RhcnQuanN0cmVlJywgdGhpcy5zZXR0aW5ncy5kbmQubGFyZ2VfZHJhZ190YXJnZXQgPyAnLmpzdHJlZS1ub2RlJyA6ICcuanN0cmVlLWFuY2hvcicsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmRuZC5sYXJnZV9kcmFnX3RhcmdldCAmJiAkKGUudGFyZ2V0KS5jbG9zZXN0KCcuanN0cmVlLW5vZGUnKVswXSAhPT0gZS5jdXJyZW50VGFyZ2V0KSB7XFxuICAgICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKGUudHlwZSA9PT0gXFxcInRvdWNoc3RhcnRcXFwiICYmICghdGhpcy5zZXR0aW5ncy5kbmQudG91Y2ggfHwgdGhpcy5zZXR0aW5ncy5kbmQudG91Y2ggPT09ICdzZWxlY3RlZCcgJiYgISQoZS5jdXJyZW50VGFyZ2V0KS5jbG9zZXN0KCcuanN0cmVlLW5vZGUnKS5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5oYXNDbGFzcygnanN0cmVlLWNsaWNrZWQnKSkpIHtcXG4gICAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB2YXIgb2JqID0gdGhpcy5nZXRfbm9kZShlLnRhcmdldCksXFxuICAgICAgICAgICAgbWx0ID0gdGhpcy5pc19zZWxlY3RlZChvYmopICYmIHRoaXMuc2V0dGluZ3MuZG5kLmRyYWdfc2VsZWN0aW9uID8gdGhpcy5nZXRfdG9wX3NlbGVjdGVkKCkubGVuZ3RoIDogMSxcXG4gICAgICAgICAgICB0eHQgPSBtbHQgPiAxID8gbWx0ICsgJyAnICsgdGhpcy5nZXRfc3RyaW5nKCdub2RlcycpIDogdGhpcy5nZXRfdGV4dChlLmN1cnJlbnRUYXJnZXQpO1xcblxcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuY29yZS5mb3JjZV90ZXh0KSB7XFxuICAgICAgICAgIHR4dCA9ICQudmFrYXRhLmh0bWwuZXNjYXBlKHR4dCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAob2JqICYmIG9iai5pZCAmJiBvYmouaWQgIT09ICQuanN0cmVlLnJvb3QgJiYgKGUud2hpY2ggPT09IDEgfHwgZS50eXBlID09PSBcXFwidG91Y2hzdGFydFxcXCIgfHwgZS50eXBlID09PSBcXFwiZHJhZ3N0YXJ0XFxcIikgJiYgKHRoaXMuc2V0dGluZ3MuZG5kLmlzX2RyYWdnYWJsZSA9PT0gdHJ1ZSB8fCAkLmlzRnVuY3Rpb24odGhpcy5zZXR0aW5ncy5kbmQuaXNfZHJhZ2dhYmxlKSAmJiB0aGlzLnNldHRpbmdzLmRuZC5pc19kcmFnZ2FibGUuY2FsbCh0aGlzLCBtbHQgPiAxID8gdGhpcy5nZXRfdG9wX3NlbGVjdGVkKHRydWUpIDogW29ial0sIGUpKSkge1xcbiAgICAgICAgICBkcmcgPSB7XFxuICAgICAgICAgICAgJ2pzdHJlZSc6IHRydWUsXFxuICAgICAgICAgICAgJ29yaWdpbic6IHRoaXMsXFxuICAgICAgICAgICAgJ29iaic6IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKSxcXG4gICAgICAgICAgICAnbm9kZXMnOiBtbHQgPiAxID8gdGhpcy5nZXRfdG9wX3NlbGVjdGVkKCkgOiBbb2JqLmlkXVxcbiAgICAgICAgICB9O1xcbiAgICAgICAgICBlbG0gPSBlLmN1cnJlbnRUYXJnZXQ7XFxuXFxuICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmRuZC51c2VfaHRtbDUpIHtcXG4gICAgICAgICAgICAkLnZha2F0YS5kbmQuX3RyaWdnZXIoJ3N0YXJ0JywgZSwge1xcbiAgICAgICAgICAgICAgJ2hlbHBlcic6ICQoKSxcXG4gICAgICAgICAgICAgICdlbGVtZW50JzogZWxtLFxcbiAgICAgICAgICAgICAgJ2RhdGEnOiBkcmdcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQudHJpZ2dlcignbW91c2Vkb3duLmpzdHJlZScpO1xcbiAgICAgICAgICAgIHJldHVybiAkLnZha2F0YS5kbmQuc3RhcnQoZSwgZHJnLCAnPGRpdiBpZD1cXFwianN0cmVlLWRuZFxcXCIgY2xhc3M9XFxcImpzdHJlZS0nICsgdGhpcy5nZXRfdGhlbWUoKSArICcganN0cmVlLScgKyB0aGlzLmdldF90aGVtZSgpICsgJy0nICsgdGhpcy5nZXRfdGhlbWVfdmFyaWFudCgpICsgJyAnICsgKHRoaXMuc2V0dGluZ3MuY29yZS50aGVtZXMucmVzcG9uc2l2ZSA/ICcganN0cmVlLWRuZC1yZXNwb25zaXZlJyA6ICcnKSArICdcXFwiPjxpIGNsYXNzPVxcXCJqc3RyZWUtaWNvbiBqc3RyZWUtZXJcXFwiPjwvaT4nICsgdHh0ICsgJzxpbnMgY2xhc3M9XFxcImpzdHJlZS1jb3B5XFxcIiBzdHlsZT1cXFwiZGlzcGxheTpub25lO1xcXCI+KzwvaW5zPjwvZGl2PicpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfSwgdGhpcykpO1xcblxcbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLmRuZC51c2VfaHRtbDUpIHtcXG4gICAgICAgIHRoaXMuZWxlbWVudC5vbignZHJhZ292ZXIuanN0cmVlJywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcblxcbiAgICAgICAgICAkLnZha2F0YS5kbmQuX3RyaWdnZXIoJ21vdmUnLCBlLCB7XFxuICAgICAgICAgICAgJ2hlbHBlcic6ICQoKSxcXG4gICAgICAgICAgICAnZWxlbWVudCc6IGVsbSxcXG4gICAgICAgICAgICAnZGF0YSc6IGRyZ1xcbiAgICAgICAgICB9KTtcXG5cXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgfSkgLy8ub24oJ2RyYWdlbnRlci5qc3RyZWUnLCB0aGlzLnNldHRpbmdzLmRuZC5sYXJnZV9kcm9wX3RhcmdldCA/ICcuanN0cmVlLW5vZGUnIDogJy5qc3RyZWUtYW5jaG9yJywgJC5wcm94eShmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgLy9cXHRcXHRlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICAvL1xcdFxcdCQudmFrYXRhLmRuZC5fdHJpZ2dlcignbW92ZScsIGUsIHsgJ2hlbHBlcic6ICQoKSwgJ2VsZW1lbnQnOiBlbG0sICdkYXRhJzogZHJnIH0pO1xcbiAgICAgICAgLy9cXHRcXHRyZXR1cm4gZmFsc2U7XFxuICAgICAgICAvL1xcdH0sIHRoaXMpKVxcbiAgICAgICAgLm9uKCdkcm9wLmpzdHJlZScsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcblxcbiAgICAgICAgICAkLnZha2F0YS5kbmQuX3RyaWdnZXIoJ3N0b3AnLCBlLCB7XFxuICAgICAgICAgICAgJ2hlbHBlcic6ICQoKSxcXG4gICAgICAgICAgICAnZWxlbWVudCc6IGVsbSxcXG4gICAgICAgICAgICAnZGF0YSc6IGRyZ1xcbiAgICAgICAgICB9KTtcXG5cXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgfSwgdGhpcykpO1xcbiAgICAgIH1cXG4gICAgfTtcXG5cXG4gICAgdGhpcy5yZWRyYXdfbm9kZSA9IGZ1bmN0aW9uIChvYmosIGRlZXAsIGNhbGxiYWNrLCBmb3JjZV9yZW5kZXIpIHtcXG4gICAgICBvYmogPSBwYXJlbnQucmVkcmF3X25vZGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG5cXG4gICAgICBpZiAob2JqICYmIHRoaXMuc2V0dGluZ3MuZG5kLnVzZV9odG1sNSkge1xcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuZG5kLmxhcmdlX2RyYWdfdGFyZ2V0KSB7XFxuICAgICAgICAgIG9iai5zZXRBdHRyaWJ1dGUoJ2RyYWdnYWJsZScsIHRydWUpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgdmFyIGksXFxuICAgICAgICAgICAgICBqLFxcbiAgICAgICAgICAgICAgdG1wID0gbnVsbDtcXG5cXG4gICAgICAgICAgZm9yIChpID0gMCwgaiA9IG9iai5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcbiAgICAgICAgICAgIGlmIChvYmouY2hpbGROb2Rlc1tpXSAmJiBvYmouY2hpbGROb2Rlc1tpXS5jbGFzc05hbWUgJiYgb2JqLmNoaWxkTm9kZXNbaV0uY2xhc3NOYW1lLmluZGV4T2YoXFxcImpzdHJlZS1hbmNob3JcXFwiKSAhPT0gLTEpIHtcXG4gICAgICAgICAgICAgIHRtcCA9IG9iai5jaGlsZE5vZGVzW2ldO1xcbiAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmICh0bXApIHtcXG4gICAgICAgICAgICB0bXAuc2V0QXR0cmlidXRlKCdkcmFnZ2FibGUnLCB0cnVlKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gb2JqO1xcbiAgICB9O1xcbiAgfTtcXG5cXG4gICQoZnVuY3Rpb24gKCkge1xcbiAgICAvLyBiaW5kIG9ubHkgb25jZSBmb3IgYWxsIGluc3RhbmNlc1xcbiAgICB2YXIgbGFzdG12ID0gZmFsc2UsXFxuICAgICAgICBsYXN0ZXIgPSBmYWxzZSxcXG4gICAgICAgIGxhc3RldiA9IGZhbHNlLFxcbiAgICAgICAgb3BlbnRvID0gZmFsc2UsXFxuICAgICAgICBtYXJrZXIgPSAkKCc8ZGl2IGlkPVxcXCJqc3RyZWUtbWFya2VyXFxcIj4mIzE2MDs8L2Rpdj4nKS5oaWRlKCk7IC8vLmFwcGVuZFRvKCdib2R5Jyk7XFxuXFxuICAgICQoZG9jdW1lbnQpLm9uKCdkbmRfc3RhcnQudmFrYXRhLmpzdHJlZScsIGZ1bmN0aW9uIChlLCBkYXRhKSB7XFxuICAgICAgbGFzdG12ID0gZmFsc2U7XFxuICAgICAgbGFzdGV2ID0gZmFsc2U7XFxuXFxuICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmRhdGEgfHwgIWRhdGEuZGF0YS5qc3RyZWUpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgbWFya2VyLmFwcGVuZFRvKCdib2R5Jyk7IC8vLnNob3coKTtcXG4gICAgfSkub24oJ2RuZF9tb3ZlLnZha2F0YS5qc3RyZWUnLCBmdW5jdGlvbiAoZSwgZGF0YSkge1xcbiAgICAgIGlmIChvcGVudG8pIHtcXG4gICAgICAgIGlmICghZGF0YS5ldmVudCB8fCBkYXRhLmV2ZW50LnR5cGUgIT09ICdkcmFnb3ZlcicgfHwgZGF0YS5ldmVudC50YXJnZXQgIT09IGxhc3Rldi50YXJnZXQpIHtcXG4gICAgICAgICAgY2xlYXJUaW1lb3V0KG9wZW50byk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghZGF0YSB8fCAhZGF0YS5kYXRhIHx8ICFkYXRhLmRhdGEuanN0cmVlKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfSAvLyBpZiB3ZSBhcmUgaG92ZXJpbmcgdGhlIG1hcmtlciBpbWFnZSBkbyBub3RoaW5nIChjYW4gaGFwcGVuIG9uIFxcXCJpbnNpZGVcXFwiIGRyYWdzKVxcblxcblxcbiAgICAgIGlmIChkYXRhLmV2ZW50LnRhcmdldC5pZCAmJiBkYXRhLmV2ZW50LnRhcmdldC5pZCA9PT0gJ2pzdHJlZS1tYXJrZXInKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGxhc3RldiA9IGRhdGEuZXZlbnQ7XFxuICAgICAgdmFyIGlucyA9ICQuanN0cmVlLnJlZmVyZW5jZShkYXRhLmV2ZW50LnRhcmdldCksXFxuICAgICAgICAgIHJlZiA9IGZhbHNlLFxcbiAgICAgICAgICBvZmYgPSBmYWxzZSxcXG4gICAgICAgICAgcmVsID0gZmFsc2UsXFxuICAgICAgICAgIHRtcCxcXG4gICAgICAgICAgbCxcXG4gICAgICAgICAgdCxcXG4gICAgICAgICAgaCxcXG4gICAgICAgICAgcCxcXG4gICAgICAgICAgaSxcXG4gICAgICAgICAgbyxcXG4gICAgICAgICAgb2ssXFxuICAgICAgICAgIHQxLFxcbiAgICAgICAgICB0MixcXG4gICAgICAgICAgb3AsXFxuICAgICAgICAgIHBzLFxcbiAgICAgICAgICBwcixcXG4gICAgICAgICAgaXAsXFxuICAgICAgICAgIHRtLFxcbiAgICAgICAgICBpc19jb3B5LFxcbiAgICAgICAgICBwbjsgLy8gaWYgd2UgYXJlIG92ZXIgYW4gaW5zdGFuY2VcXG5cXG4gICAgICBpZiAoaW5zICYmIGlucy5fZGF0YSAmJiBpbnMuX2RhdGEuZG5kKSB7XFxuICAgICAgICBtYXJrZXIuYXR0cignY2xhc3MnLCAnanN0cmVlLScgKyBpbnMuZ2V0X3RoZW1lKCkgKyAoaW5zLnNldHRpbmdzLmNvcmUudGhlbWVzLnJlc3BvbnNpdmUgPyAnIGpzdHJlZS1kbmQtcmVzcG9uc2l2ZScgOiAnJykpO1xcbiAgICAgICAgaXNfY29weSA9IGRhdGEuZGF0YS5vcmlnaW4gJiYgKGRhdGEuZGF0YS5vcmlnaW4uc2V0dGluZ3MuZG5kLmFsd2F5c19jb3B5IHx8IGRhdGEuZGF0YS5vcmlnaW4uc2V0dGluZ3MuZG5kLmNvcHkgJiYgKGRhdGEuZXZlbnQubWV0YUtleSB8fCBkYXRhLmV2ZW50LmN0cmxLZXkpKTtcXG4gICAgICAgIGRhdGEuaGVscGVyLmNoaWxkcmVuKCkuYXR0cignY2xhc3MnLCAnanN0cmVlLScgKyBpbnMuZ2V0X3RoZW1lKCkgKyAnIGpzdHJlZS0nICsgaW5zLmdldF90aGVtZSgpICsgJy0nICsgaW5zLmdldF90aGVtZV92YXJpYW50KCkgKyAnICcgKyAoaW5zLnNldHRpbmdzLmNvcmUudGhlbWVzLnJlc3BvbnNpdmUgPyAnIGpzdHJlZS1kbmQtcmVzcG9uc2l2ZScgOiAnJykpLmZpbmQoJy5qc3RyZWUtY29weScpLmZpcnN0KClbaXNfY29weSA/ICdzaG93JyA6ICdoaWRlJ10oKTsgLy8gaWYgYXJlIGhvdmVyaW5nIHRoZSBjb250YWluZXIgaXRzZWxmIGFkZCBhIG5ldyByb290IG5vZGVcXG4gICAgICAgIC8vY29uc29sZS5sb2coZGF0YS5ldmVudCk7XFxuXFxuICAgICAgICBpZiAoKGRhdGEuZXZlbnQudGFyZ2V0ID09PSBpbnMuZWxlbWVudFswXSB8fCBkYXRhLmV2ZW50LnRhcmdldCA9PT0gaW5zLmdldF9jb250YWluZXJfdWwoKVswXSkgJiYgaW5zLmdldF9jb250YWluZXJfdWwoKS5jaGlsZHJlbigpLmxlbmd0aCA9PT0gMCkge1xcbiAgICAgICAgICBvayA9IHRydWU7XFxuXFxuICAgICAgICAgIGZvciAodDEgPSAwLCB0MiA9IGRhdGEuZGF0YS5ub2Rlcy5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcXG4gICAgICAgICAgICBvayA9IG9rICYmIGlucy5jaGVjayhkYXRhLmRhdGEub3JpZ2luICYmIChkYXRhLmRhdGEub3JpZ2luLnNldHRpbmdzLmRuZC5hbHdheXNfY29weSB8fCBkYXRhLmRhdGEub3JpZ2luLnNldHRpbmdzLmRuZC5jb3B5ICYmIChkYXRhLmV2ZW50Lm1ldGFLZXkgfHwgZGF0YS5ldmVudC5jdHJsS2V5KSkgPyBcXFwiY29weV9ub2RlXFxcIiA6IFxcXCJtb3ZlX25vZGVcXFwiLCBkYXRhLmRhdGEub3JpZ2luICYmIGRhdGEuZGF0YS5vcmlnaW4gIT09IGlucyA/IGRhdGEuZGF0YS5vcmlnaW4uZ2V0X25vZGUoZGF0YS5kYXRhLm5vZGVzW3QxXSkgOiBkYXRhLmRhdGEubm9kZXNbdDFdLCAkLmpzdHJlZS5yb290LCAnbGFzdCcsIHtcXG4gICAgICAgICAgICAgICdkbmQnOiB0cnVlLFxcbiAgICAgICAgICAgICAgJ3JlZic6IGlucy5nZXRfbm9kZSgkLmpzdHJlZS5yb290KSxcXG4gICAgICAgICAgICAgICdwb3MnOiAnaScsXFxuICAgICAgICAgICAgICAnb3JpZ2luJzogZGF0YS5kYXRhLm9yaWdpbixcXG4gICAgICAgICAgICAgICdpc19tdWx0aSc6IGRhdGEuZGF0YS5vcmlnaW4gJiYgZGF0YS5kYXRhLm9yaWdpbiAhPT0gaW5zLFxcbiAgICAgICAgICAgICAgJ2lzX2ZvcmVpZ24nOiAhZGF0YS5kYXRhLm9yaWdpblxcbiAgICAgICAgICAgIH0pO1xcblxcbiAgICAgICAgICAgIGlmICghb2spIHtcXG4gICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAob2spIHtcXG4gICAgICAgICAgICBsYXN0bXYgPSB7XFxuICAgICAgICAgICAgICAnaW5zJzogaW5zLFxcbiAgICAgICAgICAgICAgJ3Bhcic6ICQuanN0cmVlLnJvb3QsXFxuICAgICAgICAgICAgICAncG9zJzogJ2xhc3QnXFxuICAgICAgICAgICAgfTtcXG4gICAgICAgICAgICBtYXJrZXIuaGlkZSgpO1xcbiAgICAgICAgICAgIGRhdGEuaGVscGVyLmZpbmQoJy5qc3RyZWUtaWNvbicpLmZpcnN0KCkucmVtb3ZlQ2xhc3MoJ2pzdHJlZS1lcicpLmFkZENsYXNzKCdqc3RyZWUtb2snKTtcXG5cXG4gICAgICAgICAgICBpZiAoZGF0YS5ldmVudC5vcmlnaW5hbEV2ZW50ICYmIGRhdGEuZXZlbnQub3JpZ2luYWxFdmVudC5kYXRhVHJhbnNmZXIpIHtcXG4gICAgICAgICAgICAgIGRhdGEuZXZlbnQub3JpZ2luYWxFdmVudC5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9IGlzX2NvcHkgPyAnY29weScgOiAnbW92ZSc7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgLy8gaWYgd2UgYXJlIGhvdmVyaW5nIGEgdHJlZSBub2RlXFxuICAgICAgICAgIHJlZiA9IGlucy5zZXR0aW5ncy5kbmQubGFyZ2VfZHJvcF90YXJnZXQgPyAkKGRhdGEuZXZlbnQudGFyZ2V0KS5jbG9zZXN0KCcuanN0cmVlLW5vZGUnKS5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKSA6ICQoZGF0YS5ldmVudC50YXJnZXQpLmNsb3Nlc3QoJy5qc3RyZWUtYW5jaG9yJyk7XFxuXFxuICAgICAgICAgIGlmIChyZWYgJiYgcmVmLmxlbmd0aCAmJiByZWYucGFyZW50KCkuaXMoJy5qc3RyZWUtY2xvc2VkLCAuanN0cmVlLW9wZW4sIC5qc3RyZWUtbGVhZicpKSB7XFxuICAgICAgICAgICAgb2ZmID0gcmVmLm9mZnNldCgpO1xcbiAgICAgICAgICAgIHJlbCA9IChkYXRhLmV2ZW50LnBhZ2VZICE9PSB1bmRlZmluZWQgPyBkYXRhLmV2ZW50LnBhZ2VZIDogZGF0YS5ldmVudC5vcmlnaW5hbEV2ZW50LnBhZ2VZKSAtIG9mZi50b3A7XFxuICAgICAgICAgICAgaCA9IHJlZi5vdXRlckhlaWdodCgpO1xcblxcbiAgICAgICAgICAgIGlmIChyZWwgPCBoIC8gMykge1xcbiAgICAgICAgICAgICAgbyA9IFsnYicsICdpJywgJ2EnXTtcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlbCA+IGggLSBoIC8gMykge1xcbiAgICAgICAgICAgICAgbyA9IFsnYScsICdpJywgJ2InXTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgbyA9IHJlbCA+IGggLyAyID8gWydpJywgJ2EnLCAnYiddIDogWydpJywgJ2InLCAnYSddO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAkLmVhY2gobywgZnVuY3Rpb24gKGosIHYpIHtcXG4gICAgICAgICAgICAgIHN3aXRjaCAodikge1xcbiAgICAgICAgICAgICAgICBjYXNlICdiJzpcXG4gICAgICAgICAgICAgICAgICBsID0gb2ZmLmxlZnQgLSA2O1xcbiAgICAgICAgICAgICAgICAgIHQgPSBvZmYudG9wO1xcbiAgICAgICAgICAgICAgICAgIHAgPSBpbnMuZ2V0X3BhcmVudChyZWYpO1xcbiAgICAgICAgICAgICAgICAgIGkgPSByZWYucGFyZW50KCkuaW5kZXgoKTtcXG4gICAgICAgICAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgICAgICAgICAgY2FzZSAnaSc6XFxuICAgICAgICAgICAgICAgICAgaXAgPSBpbnMuc2V0dGluZ3MuZG5kLmluc2lkZV9wb3M7XFxuICAgICAgICAgICAgICAgICAgdG0gPSBpbnMuZ2V0X25vZGUocmVmLnBhcmVudCgpKTtcXG4gICAgICAgICAgICAgICAgICBsID0gb2ZmLmxlZnQgLSAyO1xcbiAgICAgICAgICAgICAgICAgIHQgPSBvZmYudG9wICsgaCAvIDIgKyAxO1xcbiAgICAgICAgICAgICAgICAgIHAgPSB0bS5pZDtcXG4gICAgICAgICAgICAgICAgICBpID0gaXAgPT09ICdmaXJzdCcgPyAwIDogaXAgPT09ICdsYXN0JyA/IHRtLmNoaWxkcmVuLmxlbmd0aCA6IE1hdGgubWluKGlwLCB0bS5jaGlsZHJlbi5sZW5ndGgpO1xcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICAgICAgICBjYXNlICdhJzpcXG4gICAgICAgICAgICAgICAgICBsID0gb2ZmLmxlZnQgLSA2O1xcbiAgICAgICAgICAgICAgICAgIHQgPSBvZmYudG9wICsgaDtcXG4gICAgICAgICAgICAgICAgICBwID0gaW5zLmdldF9wYXJlbnQocmVmKTtcXG4gICAgICAgICAgICAgICAgICBpID0gcmVmLnBhcmVudCgpLmluZGV4KCkgKyAxO1xcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgb2sgPSB0cnVlO1xcblxcbiAgICAgICAgICAgICAgZm9yICh0MSA9IDAsIHQyID0gZGF0YS5kYXRhLm5vZGVzLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xcbiAgICAgICAgICAgICAgICBvcCA9IGRhdGEuZGF0YS5vcmlnaW4gJiYgKGRhdGEuZGF0YS5vcmlnaW4uc2V0dGluZ3MuZG5kLmFsd2F5c19jb3B5IHx8IGRhdGEuZGF0YS5vcmlnaW4uc2V0dGluZ3MuZG5kLmNvcHkgJiYgKGRhdGEuZXZlbnQubWV0YUtleSB8fCBkYXRhLmV2ZW50LmN0cmxLZXkpKSA/IFxcXCJjb3B5X25vZGVcXFwiIDogXFxcIm1vdmVfbm9kZVxcXCI7XFxuICAgICAgICAgICAgICAgIHBzID0gaTtcXG5cXG4gICAgICAgICAgICAgICAgaWYgKG9wID09PSBcXFwibW92ZV9ub2RlXFxcIiAmJiB2ID09PSAnYScgJiYgZGF0YS5kYXRhLm9yaWdpbiAmJiBkYXRhLmRhdGEub3JpZ2luID09PSBpbnMgJiYgcCA9PT0gaW5zLmdldF9wYXJlbnQoZGF0YS5kYXRhLm5vZGVzW3QxXSkpIHtcXG4gICAgICAgICAgICAgICAgICBwciA9IGlucy5nZXRfbm9kZShwKTtcXG5cXG4gICAgICAgICAgICAgICAgICBpZiAocHMgPiAkLmluQXJyYXkoZGF0YS5kYXRhLm5vZGVzW3QxXSwgcHIuY2hpbGRyZW4pKSB7XFxuICAgICAgICAgICAgICAgICAgICBwcyAtPSAxO1xcbiAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICBvayA9IG9rICYmIChpbnMgJiYgaW5zLnNldHRpbmdzICYmIGlucy5zZXR0aW5ncy5kbmQgJiYgaW5zLnNldHRpbmdzLmRuZC5jaGVja193aGlsZV9kcmFnZ2luZyA9PT0gZmFsc2UgfHwgaW5zLmNoZWNrKG9wLCBkYXRhLmRhdGEub3JpZ2luICYmIGRhdGEuZGF0YS5vcmlnaW4gIT09IGlucyA/IGRhdGEuZGF0YS5vcmlnaW4uZ2V0X25vZGUoZGF0YS5kYXRhLm5vZGVzW3QxXSkgOiBkYXRhLmRhdGEubm9kZXNbdDFdLCBwLCBwcywge1xcbiAgICAgICAgICAgICAgICAgICdkbmQnOiB0cnVlLFxcbiAgICAgICAgICAgICAgICAgICdyZWYnOiBpbnMuZ2V0X25vZGUocmVmLnBhcmVudCgpKSxcXG4gICAgICAgICAgICAgICAgICAncG9zJzogdixcXG4gICAgICAgICAgICAgICAgICAnb3JpZ2luJzogZGF0YS5kYXRhLm9yaWdpbixcXG4gICAgICAgICAgICAgICAgICAnaXNfbXVsdGknOiBkYXRhLmRhdGEub3JpZ2luICYmIGRhdGEuZGF0YS5vcmlnaW4gIT09IGlucyxcXG4gICAgICAgICAgICAgICAgICAnaXNfZm9yZWlnbic6ICFkYXRhLmRhdGEub3JpZ2luXFxuICAgICAgICAgICAgICAgIH0pKTtcXG5cXG4gICAgICAgICAgICAgICAgaWYgKCFvaykge1xcbiAgICAgICAgICAgICAgICAgIGlmIChpbnMgJiYgaW5zLmxhc3RfZXJyb3IpIHtcXG4gICAgICAgICAgICAgICAgICAgIGxhc3RlciA9IGlucy5sYXN0X2Vycm9yKCk7XFxuICAgICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICBpZiAodiA9PT0gJ2knICYmIHJlZi5wYXJlbnQoKS5pcygnLmpzdHJlZS1jbG9zZWQnKSAmJiBpbnMuc2V0dGluZ3MuZG5kLm9wZW5fdGltZW91dCkge1xcbiAgICAgICAgICAgICAgICBvcGVudG8gPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICh4LCB6KSB7XFxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgICAgIHgub3Blbl9ub2RlKHopO1xcbiAgICAgICAgICAgICAgICAgIH07XFxuICAgICAgICAgICAgICAgIH0oaW5zLCByZWYpLCBpbnMuc2V0dGluZ3MuZG5kLm9wZW5fdGltZW91dCk7XFxuICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICBpZiAob2spIHtcXG4gICAgICAgICAgICAgICAgcG4gPSBpbnMuZ2V0X25vZGUocCwgdHJ1ZSk7XFxuXFxuICAgICAgICAgICAgICAgIGlmICghcG4uaGFzQ2xhc3MoJy5qc3RyZWUtZG5kLXBhcmVudCcpKSB7XFxuICAgICAgICAgICAgICAgICAgJCgnLmpzdHJlZS1kbmQtcGFyZW50JykucmVtb3ZlQ2xhc3MoJ2pzdHJlZS1kbmQtcGFyZW50Jyk7XFxuICAgICAgICAgICAgICAgICAgcG4uYWRkQ2xhc3MoJ2pzdHJlZS1kbmQtcGFyZW50Jyk7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgbGFzdG12ID0ge1xcbiAgICAgICAgICAgICAgICAgICdpbnMnOiBpbnMsXFxuICAgICAgICAgICAgICAgICAgJ3Bhcic6IHAsXFxuICAgICAgICAgICAgICAgICAgJ3Bvcyc6IHYgPT09ICdpJyAmJiBpcCA9PT0gJ2xhc3QnICYmIGkgPT09IDAgJiYgIWlucy5pc19sb2FkZWQodG0pID8gJ2xhc3QnIDogaVxcbiAgICAgICAgICAgICAgICB9O1xcbiAgICAgICAgICAgICAgICBtYXJrZXIuY3NzKHtcXG4gICAgICAgICAgICAgICAgICAnbGVmdCc6IGwgKyAncHgnLFxcbiAgICAgICAgICAgICAgICAgICd0b3AnOiB0ICsgJ3B4J1xcbiAgICAgICAgICAgICAgICB9KS5zaG93KCk7XFxuICAgICAgICAgICAgICAgIGRhdGEuaGVscGVyLmZpbmQoJy5qc3RyZWUtaWNvbicpLmZpcnN0KCkucmVtb3ZlQ2xhc3MoJ2pzdHJlZS1lcicpLmFkZENsYXNzKCdqc3RyZWUtb2snKTtcXG5cXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuZXZlbnQub3JpZ2luYWxFdmVudCAmJiBkYXRhLmV2ZW50Lm9yaWdpbmFsRXZlbnQuZGF0YVRyYW5zZmVyKSB7XFxuICAgICAgICAgICAgICAgICAgZGF0YS5ldmVudC5vcmlnaW5hbEV2ZW50LmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gaXNfY29weSA/ICdjb3B5JyA6ICdtb3ZlJztcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICBsYXN0ZXIgPSB7fTtcXG4gICAgICAgICAgICAgICAgbyA9IHRydWU7XFxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KTtcXG5cXG4gICAgICAgICAgICBpZiAobyA9PT0gdHJ1ZSkge1xcbiAgICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICAkKCcuanN0cmVlLWRuZC1wYXJlbnQnKS5yZW1vdmVDbGFzcygnanN0cmVlLWRuZC1wYXJlbnQnKTtcXG4gICAgICBsYXN0bXYgPSBmYWxzZTtcXG4gICAgICBkYXRhLmhlbHBlci5maW5kKCcuanN0cmVlLWljb24nKS5yZW1vdmVDbGFzcygnanN0cmVlLW9rJykuYWRkQ2xhc3MoJ2pzdHJlZS1lcicpO1xcblxcbiAgICAgIGlmIChkYXRhLmV2ZW50Lm9yaWdpbmFsRXZlbnQgJiYgZGF0YS5ldmVudC5vcmlnaW5hbEV2ZW50LmRhdGFUcmFuc2Zlcikge1xcbiAgICAgICAgZGF0YS5ldmVudC5vcmlnaW5hbEV2ZW50LmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gJ25vbmUnO1xcbiAgICAgIH1cXG5cXG4gICAgICBtYXJrZXIuaGlkZSgpO1xcbiAgICB9KS5vbignZG5kX3Njcm9sbC52YWthdGEuanN0cmVlJywgZnVuY3Rpb24gKGUsIGRhdGEpIHtcXG4gICAgICBpZiAoIWRhdGEgfHwgIWRhdGEuZGF0YSB8fCAhZGF0YS5kYXRhLmpzdHJlZSkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBtYXJrZXIuaGlkZSgpO1xcbiAgICAgIGxhc3RtdiA9IGZhbHNlO1xcbiAgICAgIGxhc3RldiA9IGZhbHNlO1xcbiAgICAgIGRhdGEuaGVscGVyLmZpbmQoJy5qc3RyZWUtaWNvbicpLmZpcnN0KCkucmVtb3ZlQ2xhc3MoJ2pzdHJlZS1vaycpLmFkZENsYXNzKCdqc3RyZWUtZXInKTtcXG4gICAgfSkub24oJ2RuZF9zdG9wLnZha2F0YS5qc3RyZWUnLCBmdW5jdGlvbiAoZSwgZGF0YSkge1xcbiAgICAgICQoJy5qc3RyZWUtZG5kLXBhcmVudCcpLnJlbW92ZUNsYXNzKCdqc3RyZWUtZG5kLXBhcmVudCcpO1xcblxcbiAgICAgIGlmIChvcGVudG8pIHtcXG4gICAgICAgIGNsZWFyVGltZW91dChvcGVudG8pO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIWRhdGEgfHwgIWRhdGEuZGF0YSB8fCAhZGF0YS5kYXRhLmpzdHJlZSkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBtYXJrZXIuaGlkZSgpLmRldGFjaCgpO1xcbiAgICAgIHZhciBpLFxcbiAgICAgICAgICBqLFxcbiAgICAgICAgICBub2RlcyA9IFtdO1xcblxcbiAgICAgIGlmIChsYXN0bXYpIHtcXG4gICAgICAgIGZvciAoaSA9IDAsIGogPSBkYXRhLmRhdGEubm9kZXMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICAgIG5vZGVzW2ldID0gZGF0YS5kYXRhLm9yaWdpbiA/IGRhdGEuZGF0YS5vcmlnaW4uZ2V0X25vZGUoZGF0YS5kYXRhLm5vZGVzW2ldKSA6IGRhdGEuZGF0YS5ub2Rlc1tpXTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGxhc3Rtdi5pbnNbZGF0YS5kYXRhLm9yaWdpbiAmJiAoZGF0YS5kYXRhLm9yaWdpbi5zZXR0aW5ncy5kbmQuYWx3YXlzX2NvcHkgfHwgZGF0YS5kYXRhLm9yaWdpbi5zZXR0aW5ncy5kbmQuY29weSAmJiAoZGF0YS5ldmVudC5tZXRhS2V5IHx8IGRhdGEuZXZlbnQuY3RybEtleSkpID8gJ2NvcHlfbm9kZScgOiAnbW92ZV9ub2RlJ10obm9kZXMsIGxhc3Rtdi5wYXIsIGxhc3Rtdi5wb3MsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGRhdGEuZGF0YS5vcmlnaW4pO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBpID0gJChkYXRhLmV2ZW50LnRhcmdldCkuY2xvc2VzdCgnLmpzdHJlZScpO1xcblxcbiAgICAgICAgaWYgKGkubGVuZ3RoICYmIGxhc3RlciAmJiBsYXN0ZXIuZXJyb3IgJiYgbGFzdGVyLmVycm9yID09PSAnY2hlY2snKSB7XFxuICAgICAgICAgIGkgPSBpLmpzdHJlZSh0cnVlKTtcXG5cXG4gICAgICAgICAgaWYgKGkpIHtcXG4gICAgICAgICAgICBpLnNldHRpbmdzLmNvcmUuZXJyb3IuY2FsbCh0aGlzLCBsYXN0ZXIpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGxhc3RldiA9IGZhbHNlO1xcbiAgICAgIGxhc3RtdiA9IGZhbHNlO1xcbiAgICB9KS5vbigna2V5dXAuanN0cmVlIGtleWRvd24uanN0cmVlJywgZnVuY3Rpb24gKGUsIGRhdGEpIHtcXG4gICAgICBkYXRhID0gJC52YWthdGEuZG5kLl9nZXQoKTtcXG5cXG4gICAgICBpZiAoZGF0YSAmJiBkYXRhLmRhdGEgJiYgZGF0YS5kYXRhLmpzdHJlZSkge1xcbiAgICAgICAgaWYgKGUudHlwZSA9PT0gXFxcImtleXVwXFxcIiAmJiBlLndoaWNoID09PSAyNykge1xcbiAgICAgICAgICBpZiAob3BlbnRvKSB7XFxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KG9wZW50byk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgbGFzdG12ID0gZmFsc2U7XFxuICAgICAgICAgIGxhc3RlciA9IGZhbHNlO1xcbiAgICAgICAgICBsYXN0ZXYgPSBmYWxzZTtcXG4gICAgICAgICAgb3BlbnRvID0gZmFsc2U7XFxuICAgICAgICAgIG1hcmtlci5oaWRlKCkuZGV0YWNoKCk7XFxuXFxuICAgICAgICAgICQudmFrYXRhLmRuZC5fY2xlYW4oKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGRhdGEuaGVscGVyLmZpbmQoJy5qc3RyZWUtY29weScpLmZpcnN0KClbZGF0YS5kYXRhLm9yaWdpbiAmJiAoZGF0YS5kYXRhLm9yaWdpbi5zZXR0aW5ncy5kbmQuYWx3YXlzX2NvcHkgfHwgZGF0YS5kYXRhLm9yaWdpbi5zZXR0aW5ncy5kbmQuY29weSAmJiAoZS5tZXRhS2V5IHx8IGUuY3RybEtleSkpID8gJ3Nob3cnIDogJ2hpZGUnXSgpO1xcblxcbiAgICAgICAgICBpZiAobGFzdGV2KSB7XFxuICAgICAgICAgICAgbGFzdGV2Lm1ldGFLZXkgPSBlLm1ldGFLZXk7XFxuICAgICAgICAgICAgbGFzdGV2LmN0cmxLZXkgPSBlLmN0cmxLZXk7XFxuXFxuICAgICAgICAgICAgJC52YWthdGEuZG5kLl90cmlnZ2VyKCdtb3ZlJywgbGFzdGV2KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfSk7XFxuICB9KTsgLy8gaGVscGVyc1xcblxcbiAgKGZ1bmN0aW9uICgkKSB7XFxuICAgICQudmFrYXRhLmh0bWwgPSB7XFxuICAgICAgZGl2OiAkKCc8ZGl2IC8+JyksXFxuICAgICAgZXNjYXBlOiBmdW5jdGlvbiBlc2NhcGUoc3RyKSB7XFxuICAgICAgICByZXR1cm4gJC52YWthdGEuaHRtbC5kaXYudGV4dChzdHIpLmh0bWwoKTtcXG4gICAgICB9LFxcbiAgICAgIHN0cmlwOiBmdW5jdGlvbiBzdHJpcChzdHIpIHtcXG4gICAgICAgIHJldHVybiAkLnZha2F0YS5odG1sLmRpdi5lbXB0eSgpLmFwcGVuZCgkLnBhcnNlSFRNTChzdHIpKS50ZXh0KCk7XFxuICAgICAgfVxcbiAgICB9OyAvLyBwcml2YXRlIHZhcmlhYmxlXFxuXFxuICAgIHZhciB2YWthdGFfZG5kID0ge1xcbiAgICAgIGVsZW1lbnQ6IGZhbHNlLFxcbiAgICAgIHRhcmdldDogZmFsc2UsXFxuICAgICAgaXNfZG93bjogZmFsc2UsXFxuICAgICAgaXNfZHJhZzogZmFsc2UsXFxuICAgICAgaGVscGVyOiBmYWxzZSxcXG4gICAgICBoZWxwZXJfdzogMCxcXG4gICAgICBkYXRhOiBmYWxzZSxcXG4gICAgICBpbml0X3g6IDAsXFxuICAgICAgaW5pdF95OiAwLFxcbiAgICAgIHNjcm9sbF9sOiAwLFxcbiAgICAgIHNjcm9sbF90OiAwLFxcbiAgICAgIHNjcm9sbF9lOiBmYWxzZSxcXG4gICAgICBzY3JvbGxfaTogZmFsc2UsXFxuICAgICAgaXNfdG91Y2g6IGZhbHNlXFxuICAgIH07XFxuICAgICQudmFrYXRhLmRuZCA9IHtcXG4gICAgICBzZXR0aW5nczoge1xcbiAgICAgICAgc2Nyb2xsX3NwZWVkOiAxMCxcXG4gICAgICAgIHNjcm9sbF9wcm94aW1pdHk6IDIwLFxcbiAgICAgICAgaGVscGVyX2xlZnQ6IDUsXFxuICAgICAgICBoZWxwZXJfdG9wOiAxMCxcXG4gICAgICAgIHRocmVzaG9sZDogNSxcXG4gICAgICAgIHRocmVzaG9sZF90b3VjaDogNTBcXG4gICAgICB9LFxcbiAgICAgIF90cmlnZ2VyOiBmdW5jdGlvbiBfdHJpZ2dlcihldmVudF9uYW1lLCBlLCBkYXRhKSB7XFxuICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgIGRhdGEgPSAkLnZha2F0YS5kbmQuX2dldCgpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZGF0YS5ldmVudCA9IGU7XFxuICAgICAgICAkKGRvY3VtZW50KS50cmlnZ2VySGFuZGxlcihcXFwiZG5kX1xcXCIgKyBldmVudF9uYW1lICsgXFxcIi52YWthdGFcXFwiLCBkYXRhKTtcXG4gICAgICB9LFxcbiAgICAgIF9nZXQ6IGZ1bmN0aW9uIF9nZXQoKSB7XFxuICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICBcXFwiZGF0YVxcXCI6IHZha2F0YV9kbmQuZGF0YSxcXG4gICAgICAgICAgXFxcImVsZW1lbnRcXFwiOiB2YWthdGFfZG5kLmVsZW1lbnQsXFxuICAgICAgICAgIFxcXCJoZWxwZXJcXFwiOiB2YWthdGFfZG5kLmhlbHBlclxcbiAgICAgICAgfTtcXG4gICAgICB9LFxcbiAgICAgIF9jbGVhbjogZnVuY3Rpb24gX2NsZWFuKCkge1xcbiAgICAgICAgaWYgKHZha2F0YV9kbmQuaGVscGVyKSB7XFxuICAgICAgICAgIHZha2F0YV9kbmQuaGVscGVyLnJlbW92ZSgpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKHZha2F0YV9kbmQuc2Nyb2xsX2kpIHtcXG4gICAgICAgICAgY2xlYXJJbnRlcnZhbCh2YWthdGFfZG5kLnNjcm9sbF9pKTtcXG4gICAgICAgICAgdmFrYXRhX2RuZC5zY3JvbGxfaSA9IGZhbHNlO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdmFrYXRhX2RuZCA9IHtcXG4gICAgICAgICAgZWxlbWVudDogZmFsc2UsXFxuICAgICAgICAgIHRhcmdldDogZmFsc2UsXFxuICAgICAgICAgIGlzX2Rvd246IGZhbHNlLFxcbiAgICAgICAgICBpc19kcmFnOiBmYWxzZSxcXG4gICAgICAgICAgaGVscGVyOiBmYWxzZSxcXG4gICAgICAgICAgaGVscGVyX3c6IDAsXFxuICAgICAgICAgIGRhdGE6IGZhbHNlLFxcbiAgICAgICAgICBpbml0X3g6IDAsXFxuICAgICAgICAgIGluaXRfeTogMCxcXG4gICAgICAgICAgc2Nyb2xsX2w6IDAsXFxuICAgICAgICAgIHNjcm9sbF90OiAwLFxcbiAgICAgICAgICBzY3JvbGxfZTogZmFsc2UsXFxuICAgICAgICAgIHNjcm9sbF9pOiBmYWxzZSxcXG4gICAgICAgICAgaXNfdG91Y2g6IGZhbHNlXFxuICAgICAgICB9O1xcbiAgICAgICAgJChkb2N1bWVudCkub2ZmKFxcXCJtb3VzZW1vdmUudmFrYXRhLmpzdHJlZSB0b3VjaG1vdmUudmFrYXRhLmpzdHJlZVxcXCIsICQudmFrYXRhLmRuZC5kcmFnKTtcXG4gICAgICAgICQoZG9jdW1lbnQpLm9mZihcXFwibW91c2V1cC52YWthdGEuanN0cmVlIHRvdWNoZW5kLnZha2F0YS5qc3RyZWVcXFwiLCAkLnZha2F0YS5kbmQuc3RvcCk7XFxuICAgICAgfSxcXG4gICAgICBfc2Nyb2xsOiBmdW5jdGlvbiBfc2Nyb2xsKGluaXRfb25seSkge1xcbiAgICAgICAgaWYgKCF2YWthdGFfZG5kLnNjcm9sbF9lIHx8ICF2YWthdGFfZG5kLnNjcm9sbF9sICYmICF2YWthdGFfZG5kLnNjcm9sbF90KSB7XFxuICAgICAgICAgIGlmICh2YWthdGFfZG5kLnNjcm9sbF9pKSB7XFxuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh2YWthdGFfZG5kLnNjcm9sbF9pKTtcXG4gICAgICAgICAgICB2YWthdGFfZG5kLnNjcm9sbF9pID0gZmFsc2U7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKCF2YWthdGFfZG5kLnNjcm9sbF9pKSB7XFxuICAgICAgICAgIHZha2F0YV9kbmQuc2Nyb2xsX2kgPSBzZXRJbnRlcnZhbCgkLnZha2F0YS5kbmQuX3Njcm9sbCwgMTAwKTtcXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKGluaXRfb25seSA9PT0gdHJ1ZSkge1xcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB2YXIgaSA9IHZha2F0YV9kbmQuc2Nyb2xsX2Uuc2Nyb2xsVG9wKCksXFxuICAgICAgICAgICAgaiA9IHZha2F0YV9kbmQuc2Nyb2xsX2Uuc2Nyb2xsTGVmdCgpO1xcbiAgICAgICAgdmFrYXRhX2RuZC5zY3JvbGxfZS5zY3JvbGxUb3AoaSArIHZha2F0YV9kbmQuc2Nyb2xsX3QgKiAkLnZha2F0YS5kbmQuc2V0dGluZ3Muc2Nyb2xsX3NwZWVkKTtcXG4gICAgICAgIHZha2F0YV9kbmQuc2Nyb2xsX2Uuc2Nyb2xsTGVmdChqICsgdmFrYXRhX2RuZC5zY3JvbGxfbCAqICQudmFrYXRhLmRuZC5zZXR0aW5ncy5zY3JvbGxfc3BlZWQpO1xcblxcbiAgICAgICAgaWYgKGkgIT09IHZha2F0YV9kbmQuc2Nyb2xsX2Uuc2Nyb2xsVG9wKCkgfHwgaiAhPT0gdmFrYXRhX2RuZC5zY3JvbGxfZS5zY3JvbGxMZWZ0KCkpIHtcXG4gICAgICAgICAgLyoqXFxuICAgICAgICAgICAqIHRyaWdnZXJlZCBvbiB0aGUgZG9jdW1lbnQgd2hlbiBhIGRyYWcgY2F1c2VzIGFuIGVsZW1lbnQgdG8gc2Nyb2xsXFxuICAgICAgICAgICAqIEBldmVudFxcbiAgICAgICAgICAgKiBAcGx1Z2luIGRuZFxcbiAgICAgICAgICAgKiBAbmFtZSBkbmRfc2Nyb2xsLnZha2F0YVxcbiAgICAgICAgICAgKiBAcGFyYW0ge01peGVkfSBkYXRhIGFueSBkYXRhIHN1cHBsaWVkIHdpdGggdGhlIGNhbGwgdG8gJC52YWthdGEuZG5kLnN0YXJ0XFxuICAgICAgICAgICAqIEBwYXJhbSB7RE9NfSBlbGVtZW50IHRoZSBET00gZWxlbWVudCBiZWluZyBkcmFnZ2VkXFxuICAgICAgICAgICAqIEBwYXJhbSB7alF1ZXJ5fSBoZWxwZXIgdGhlIGhlbHBlciBzaG93biBuZXh0IHRvIHRoZSBtb3VzZVxcbiAgICAgICAgICAgKiBAcGFyYW0ge2pRdWVyeX0gZXZlbnQgdGhlIGVsZW1lbnQgdGhhdCBpcyBzY3JvbGxpbmdcXG4gICAgICAgICAgICovXFxuICAgICAgICAgICQudmFrYXRhLmRuZC5fdHJpZ2dlcihcXFwic2Nyb2xsXFxcIiwgdmFrYXRhX2RuZC5zY3JvbGxfZSk7XFxuICAgICAgICB9XFxuICAgICAgfSxcXG4gICAgICBzdGFydDogZnVuY3Rpb24gc3RhcnQoZSwgZGF0YSwgaHRtbCkge1xcbiAgICAgICAgaWYgKGUudHlwZSA9PT0gXFxcInRvdWNoc3RhcnRcXFwiICYmIGUub3JpZ2luYWxFdmVudCAmJiBlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXMgJiYgZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdKSB7XFxuICAgICAgICAgIGUucGFnZVggPSBlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVg7XFxuICAgICAgICAgIGUucGFnZVkgPSBlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVk7XFxuICAgICAgICAgIGUudGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVggLSB3aW5kb3cucGFnZVhPZmZzZXQsIGUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWSAtIHdpbmRvdy5wYWdlWU9mZnNldCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAodmFrYXRhX2RuZC5pc19kcmFnKSB7XFxuICAgICAgICAgICQudmFrYXRhLmRuZC5zdG9wKHt9KTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgIGUuY3VycmVudFRhcmdldC51bnNlbGVjdGFibGUgPSBcXFwib25cXFwiO1xcblxcbiAgICAgICAgICBlLmN1cnJlbnRUYXJnZXQub25zZWxlY3RzdGFydCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICAgIH07XFxuXFxuICAgICAgICAgIGlmIChlLmN1cnJlbnRUYXJnZXQuc3R5bGUpIHtcXG4gICAgICAgICAgICBlLmN1cnJlbnRUYXJnZXQuc3R5bGUudG91Y2hBY3Rpb24gPSBcXFwibm9uZVxcXCI7XFxuICAgICAgICAgICAgZS5jdXJyZW50VGFyZ2V0LnN0eWxlLm1zVG91Y2hBY3Rpb24gPSBcXFwibm9uZVxcXCI7XFxuICAgICAgICAgICAgZS5jdXJyZW50VGFyZ2V0LnN0eWxlLk1velVzZXJTZWxlY3QgPSBcXFwibm9uZVxcXCI7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cXG5cXG4gICAgICAgIHZha2F0YV9kbmQuaW5pdF94ID0gZS5wYWdlWDtcXG4gICAgICAgIHZha2F0YV9kbmQuaW5pdF95ID0gZS5wYWdlWTtcXG4gICAgICAgIHZha2F0YV9kbmQuZGF0YSA9IGRhdGE7XFxuICAgICAgICB2YWthdGFfZG5kLmlzX2Rvd24gPSB0cnVlO1xcbiAgICAgICAgdmFrYXRhX2RuZC5lbGVtZW50ID0gZS5jdXJyZW50VGFyZ2V0O1xcbiAgICAgICAgdmFrYXRhX2RuZC50YXJnZXQgPSBlLnRhcmdldDtcXG4gICAgICAgIHZha2F0YV9kbmQuaXNfdG91Y2ggPSBlLnR5cGUgPT09IFxcXCJ0b3VjaHN0YXJ0XFxcIjtcXG5cXG4gICAgICAgIGlmIChodG1sICE9PSBmYWxzZSkge1xcbiAgICAgICAgICB2YWthdGFfZG5kLmhlbHBlciA9ICQoXFxcIjxkaXYgaWQ9J3Zha2F0YS1kbmQnPjwvZGl2PlxcXCIpLmh0bWwoaHRtbCkuY3NzKHtcXG4gICAgICAgICAgICBcXFwiZGlzcGxheVxcXCI6IFxcXCJibG9ja1xcXCIsXFxuICAgICAgICAgICAgXFxcIm1hcmdpblxcXCI6IFxcXCIwXFxcIixcXG4gICAgICAgICAgICBcXFwicGFkZGluZ1xcXCI6IFxcXCIwXFxcIixcXG4gICAgICAgICAgICBcXFwicG9zaXRpb25cXFwiOiBcXFwiYWJzb2x1dGVcXFwiLFxcbiAgICAgICAgICAgIFxcXCJ0b3BcXFwiOiBcXFwiLTIwMDBweFxcXCIsXFxuICAgICAgICAgICAgXFxcImxpbmVIZWlnaHRcXFwiOiBcXFwiMTZweFxcXCIsXFxuICAgICAgICAgICAgXFxcInpJbmRleFxcXCI6IFxcXCIxMDAwMFxcXCJcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICAkKGRvY3VtZW50KS5vbihcXFwibW91c2Vtb3ZlLnZha2F0YS5qc3RyZWUgdG91Y2htb3ZlLnZha2F0YS5qc3RyZWVcXFwiLCAkLnZha2F0YS5kbmQuZHJhZyk7XFxuICAgICAgICAkKGRvY3VtZW50KS5vbihcXFwibW91c2V1cC52YWthdGEuanN0cmVlIHRvdWNoZW5kLnZha2F0YS5qc3RyZWVcXFwiLCAkLnZha2F0YS5kbmQuc3RvcCk7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfSxcXG4gICAgICBkcmFnOiBmdW5jdGlvbiBkcmFnKGUpIHtcXG4gICAgICAgIGlmIChlLnR5cGUgPT09IFxcXCJ0b3VjaG1vdmVcXFwiICYmIGUub3JpZ2luYWxFdmVudCAmJiBlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXMgJiYgZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdKSB7XFxuICAgICAgICAgIGUucGFnZVggPSBlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVg7XFxuICAgICAgICAgIGUucGFnZVkgPSBlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVk7XFxuICAgICAgICAgIGUudGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVggLSB3aW5kb3cucGFnZVhPZmZzZXQsIGUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWSAtIHdpbmRvdy5wYWdlWU9mZnNldCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoIXZha2F0YV9kbmQuaXNfZG93bikge1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoIXZha2F0YV9kbmQuaXNfZHJhZykge1xcbiAgICAgICAgICBpZiAoTWF0aC5hYnMoZS5wYWdlWCAtIHZha2F0YV9kbmQuaW5pdF94KSA+ICh2YWthdGFfZG5kLmlzX3RvdWNoID8gJC52YWthdGEuZG5kLnNldHRpbmdzLnRocmVzaG9sZF90b3VjaCA6ICQudmFrYXRhLmRuZC5zZXR0aW5ncy50aHJlc2hvbGQpIHx8IE1hdGguYWJzKGUucGFnZVkgLSB2YWthdGFfZG5kLmluaXRfeSkgPiAodmFrYXRhX2RuZC5pc190b3VjaCA/ICQudmFrYXRhLmRuZC5zZXR0aW5ncy50aHJlc2hvbGRfdG91Y2ggOiAkLnZha2F0YS5kbmQuc2V0dGluZ3MudGhyZXNob2xkKSkge1xcbiAgICAgICAgICAgIGlmICh2YWthdGFfZG5kLmhlbHBlcikge1xcbiAgICAgICAgICAgICAgdmFrYXRhX2RuZC5oZWxwZXIuYXBwZW5kVG8oXFxcImJvZHlcXFwiKTtcXG4gICAgICAgICAgICAgIHZha2F0YV9kbmQuaGVscGVyX3cgPSB2YWthdGFfZG5kLmhlbHBlci5vdXRlcldpZHRoKCk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIHZha2F0YV9kbmQuaXNfZHJhZyA9IHRydWU7XFxuICAgICAgICAgICAgJCh2YWthdGFfZG5kLnRhcmdldCkub25lKCdjbGljay52YWthdGEnLCBmYWxzZSk7XFxuICAgICAgICAgICAgLyoqXFxuICAgICAgICAgICAgICogdHJpZ2dlcmVkIG9uIHRoZSBkb2N1bWVudCB3aGVuIGEgZHJhZyBzdGFydHNcXG4gICAgICAgICAgICAgKiBAZXZlbnRcXG4gICAgICAgICAgICAgKiBAcGx1Z2luIGRuZFxcbiAgICAgICAgICAgICAqIEBuYW1lIGRuZF9zdGFydC52YWthdGFcXG4gICAgICAgICAgICAgKiBAcGFyYW0ge01peGVkfSBkYXRhIGFueSBkYXRhIHN1cHBsaWVkIHdpdGggdGhlIGNhbGwgdG8gJC52YWthdGEuZG5kLnN0YXJ0XFxuICAgICAgICAgICAgICogQHBhcmFtIHtET019IGVsZW1lbnQgdGhlIERPTSBlbGVtZW50IGJlaW5nIGRyYWdnZWRcXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2pRdWVyeX0gaGVscGVyIHRoZSBoZWxwZXIgc2hvd24gbmV4dCB0byB0aGUgbW91c2VcXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgdGhlIGV2ZW50IHRoYXQgY2F1c2VkIHRoZSBzdGFydCAocHJvYmFibHkgbW91c2Vtb3ZlKVxcbiAgICAgICAgICAgICAqL1xcblxcbiAgICAgICAgICAgICQudmFrYXRhLmRuZC5fdHJpZ2dlcihcXFwic3RhcnRcXFwiLCBlKTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHZhciBkID0gZmFsc2UsXFxuICAgICAgICAgICAgdyA9IGZhbHNlLFxcbiAgICAgICAgICAgIGRoID0gZmFsc2UsXFxuICAgICAgICAgICAgd2ggPSBmYWxzZSxcXG4gICAgICAgICAgICBkdyA9IGZhbHNlLFxcbiAgICAgICAgICAgIHd3ID0gZmFsc2UsXFxuICAgICAgICAgICAgZHQgPSBmYWxzZSxcXG4gICAgICAgICAgICBkbCA9IGZhbHNlLFxcbiAgICAgICAgICAgIGh0ID0gZmFsc2UsXFxuICAgICAgICAgICAgaGwgPSBmYWxzZTtcXG4gICAgICAgIHZha2F0YV9kbmQuc2Nyb2xsX3QgPSAwO1xcbiAgICAgICAgdmFrYXRhX2RuZC5zY3JvbGxfbCA9IDA7XFxuICAgICAgICB2YWthdGFfZG5kLnNjcm9sbF9lID0gZmFsc2U7XFxuICAgICAgICAkKCQoZS50YXJnZXQpLnBhcmVudHNVbnRpbChcXFwiYm9keVxcXCIpLmFkZEJhY2soKS5nZXQoKS5yZXZlcnNlKCkpLmZpbHRlcihmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHJldHVybiAvXmF1dG98c2Nyb2xsJC8udGVzdCgkKHRoaXMpLmNzcyhcXFwib3ZlcmZsb3dcXFwiKSkgJiYgKHRoaXMuc2Nyb2xsSGVpZ2h0ID4gdGhpcy5vZmZzZXRIZWlnaHQgfHwgdGhpcy5zY3JvbGxXaWR0aCA+IHRoaXMub2Zmc2V0V2lkdGgpO1xcbiAgICAgICAgfSkuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHZhciB0ID0gJCh0aGlzKSxcXG4gICAgICAgICAgICAgIG8gPSB0Lm9mZnNldCgpO1xcblxcbiAgICAgICAgICBpZiAodGhpcy5zY3JvbGxIZWlnaHQgPiB0aGlzLm9mZnNldEhlaWdodCkge1xcbiAgICAgICAgICAgIGlmIChvLnRvcCArIHQuaGVpZ2h0KCkgLSBlLnBhZ2VZIDwgJC52YWthdGEuZG5kLnNldHRpbmdzLnNjcm9sbF9wcm94aW1pdHkpIHtcXG4gICAgICAgICAgICAgIHZha2F0YV9kbmQuc2Nyb2xsX3QgPSAxO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpZiAoZS5wYWdlWSAtIG8udG9wIDwgJC52YWthdGEuZG5kLnNldHRpbmdzLnNjcm9sbF9wcm94aW1pdHkpIHtcXG4gICAgICAgICAgICAgIHZha2F0YV9kbmQuc2Nyb2xsX3QgPSAtMTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaWYgKHRoaXMuc2Nyb2xsV2lkdGggPiB0aGlzLm9mZnNldFdpZHRoKSB7XFxuICAgICAgICAgICAgaWYgKG8ubGVmdCArIHQud2lkdGgoKSAtIGUucGFnZVggPCAkLnZha2F0YS5kbmQuc2V0dGluZ3Muc2Nyb2xsX3Byb3hpbWl0eSkge1xcbiAgICAgICAgICAgICAgdmFrYXRhX2RuZC5zY3JvbGxfbCA9IDE7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmIChlLnBhZ2VYIC0gby5sZWZ0IDwgJC52YWthdGEuZG5kLnNldHRpbmdzLnNjcm9sbF9wcm94aW1pdHkpIHtcXG4gICAgICAgICAgICAgIHZha2F0YV9kbmQuc2Nyb2xsX2wgPSAtMTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaWYgKHZha2F0YV9kbmQuc2Nyb2xsX3QgfHwgdmFrYXRhX2RuZC5zY3JvbGxfbCkge1xcbiAgICAgICAgICAgIHZha2F0YV9kbmQuc2Nyb2xsX2UgPSAkKHRoaXMpO1xcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuXFxuICAgICAgICBpZiAoIXZha2F0YV9kbmQuc2Nyb2xsX2UpIHtcXG4gICAgICAgICAgZCA9ICQoZG9jdW1lbnQpO1xcbiAgICAgICAgICB3ID0gJCh3aW5kb3cpO1xcbiAgICAgICAgICBkaCA9IGQuaGVpZ2h0KCk7XFxuICAgICAgICAgIHdoID0gdy5oZWlnaHQoKTtcXG4gICAgICAgICAgZHcgPSBkLndpZHRoKCk7XFxuICAgICAgICAgIHd3ID0gdy53aWR0aCgpO1xcbiAgICAgICAgICBkdCA9IGQuc2Nyb2xsVG9wKCk7XFxuICAgICAgICAgIGRsID0gZC5zY3JvbGxMZWZ0KCk7XFxuXFxuICAgICAgICAgIGlmIChkaCA+IHdoICYmIGUucGFnZVkgLSBkdCA8ICQudmFrYXRhLmRuZC5zZXR0aW5ncy5zY3JvbGxfcHJveGltaXR5KSB7XFxuICAgICAgICAgICAgdmFrYXRhX2RuZC5zY3JvbGxfdCA9IC0xO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmIChkaCA+IHdoICYmIHdoIC0gKGUucGFnZVkgLSBkdCkgPCAkLnZha2F0YS5kbmQuc2V0dGluZ3Muc2Nyb2xsX3Byb3hpbWl0eSkge1xcbiAgICAgICAgICAgIHZha2F0YV9kbmQuc2Nyb2xsX3QgPSAxO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmIChkdyA+IHd3ICYmIGUucGFnZVggLSBkbCA8ICQudmFrYXRhLmRuZC5zZXR0aW5ncy5zY3JvbGxfcHJveGltaXR5KSB7XFxuICAgICAgICAgICAgdmFrYXRhX2RuZC5zY3JvbGxfbCA9IC0xO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmIChkdyA+IHd3ICYmIHd3IC0gKGUucGFnZVggLSBkbCkgPCAkLnZha2F0YS5kbmQuc2V0dGluZ3Muc2Nyb2xsX3Byb3hpbWl0eSkge1xcbiAgICAgICAgICAgIHZha2F0YV9kbmQuc2Nyb2xsX2wgPSAxO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmICh2YWthdGFfZG5kLnNjcm9sbF90IHx8IHZha2F0YV9kbmQuc2Nyb2xsX2wpIHtcXG4gICAgICAgICAgICB2YWthdGFfZG5kLnNjcm9sbF9lID0gZDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKHZha2F0YV9kbmQuc2Nyb2xsX2UpIHtcXG4gICAgICAgICAgJC52YWthdGEuZG5kLl9zY3JvbGwodHJ1ZSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAodmFrYXRhX2RuZC5oZWxwZXIpIHtcXG4gICAgICAgICAgaHQgPSBwYXJzZUludChlLnBhZ2VZICsgJC52YWthdGEuZG5kLnNldHRpbmdzLmhlbHBlcl90b3AsIDEwKTtcXG4gICAgICAgICAgaGwgPSBwYXJzZUludChlLnBhZ2VYICsgJC52YWthdGEuZG5kLnNldHRpbmdzLmhlbHBlcl9sZWZ0LCAxMCk7XFxuXFxuICAgICAgICAgIGlmIChkaCAmJiBodCArIDI1ID4gZGgpIHtcXG4gICAgICAgICAgICBodCA9IGRoIC0gNTA7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaWYgKGR3ICYmIGhsICsgdmFrYXRhX2RuZC5oZWxwZXJfdyA+IGR3KSB7XFxuICAgICAgICAgICAgaGwgPSBkdyAtICh2YWthdGFfZG5kLmhlbHBlcl93ICsgMik7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgdmFrYXRhX2RuZC5oZWxwZXIuY3NzKHtcXG4gICAgICAgICAgICBsZWZ0OiBobCArIFxcXCJweFxcXCIsXFxuICAgICAgICAgICAgdG9wOiBodCArIFxcXCJweFxcXCJcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgICAvKipcXG4gICAgICAgICAqIHRyaWdnZXJlZCBvbiB0aGUgZG9jdW1lbnQgd2hlbiBhIGRyYWcgaXMgaW4gcHJvZ3Jlc3NcXG4gICAgICAgICAqIEBldmVudFxcbiAgICAgICAgICogQHBsdWdpbiBkbmRcXG4gICAgICAgICAqIEBuYW1lIGRuZF9tb3ZlLnZha2F0YVxcbiAgICAgICAgICogQHBhcmFtIHtNaXhlZH0gZGF0YSBhbnkgZGF0YSBzdXBwbGllZCB3aXRoIHRoZSBjYWxsIHRvICQudmFrYXRhLmRuZC5zdGFydFxcbiAgICAgICAgICogQHBhcmFtIHtET019IGVsZW1lbnQgdGhlIERPTSBlbGVtZW50IGJlaW5nIGRyYWdnZWRcXG4gICAgICAgICAqIEBwYXJhbSB7alF1ZXJ5fSBoZWxwZXIgdGhlIGhlbHBlciBzaG93biBuZXh0IHRvIHRoZSBtb3VzZVxcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IHRoZSBldmVudCB0aGF0IGNhdXNlZCB0aGlzIHRvIHRyaWdnZXIgKG1vc3QgbGlrZWx5IG1vdXNlbW92ZSlcXG4gICAgICAgICAqL1xcblxcblxcbiAgICAgICAgJC52YWthdGEuZG5kLl90cmlnZ2VyKFxcXCJtb3ZlXFxcIiwgZSk7XFxuXFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfSxcXG4gICAgICBzdG9wOiBmdW5jdGlvbiBzdG9wKGUpIHtcXG4gICAgICAgIGlmIChlLnR5cGUgPT09IFxcXCJ0b3VjaGVuZFxcXCIgJiYgZS5vcmlnaW5hbEV2ZW50ICYmIGUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlcyAmJiBlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0pIHtcXG4gICAgICAgICAgZS5wYWdlWCA9IGUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWDtcXG4gICAgICAgICAgZS5wYWdlWSA9IGUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWTtcXG4gICAgICAgICAgZS50YXJnZXQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KGUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWCAtIHdpbmRvdy5wYWdlWE9mZnNldCwgZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VZIC0gd2luZG93LnBhZ2VZT2Zmc2V0KTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICh2YWthdGFfZG5kLmlzX2RyYWcpIHtcXG4gICAgICAgICAgLyoqXFxuICAgICAgICAgICAqIHRyaWdnZXJlZCBvbiB0aGUgZG9jdW1lbnQgd2hlbiBhIGRyYWcgc3RvcHMgKHRoZSBkcmFnZ2VkIGVsZW1lbnQgaXMgZHJvcHBlZClcXG4gICAgICAgICAgICogQGV2ZW50XFxuICAgICAgICAgICAqIEBwbHVnaW4gZG5kXFxuICAgICAgICAgICAqIEBuYW1lIGRuZF9zdG9wLnZha2F0YVxcbiAgICAgICAgICAgKiBAcGFyYW0ge01peGVkfSBkYXRhIGFueSBkYXRhIHN1cHBsaWVkIHdpdGggdGhlIGNhbGwgdG8gJC52YWthdGEuZG5kLnN0YXJ0XFxuICAgICAgICAgICAqIEBwYXJhbSB7RE9NfSBlbGVtZW50IHRoZSBET00gZWxlbWVudCBiZWluZyBkcmFnZ2VkXFxuICAgICAgICAgICAqIEBwYXJhbSB7alF1ZXJ5fSBoZWxwZXIgdGhlIGhlbHBlciBzaG93biBuZXh0IHRvIHRoZSBtb3VzZVxcbiAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgdGhlIGV2ZW50IHRoYXQgY2F1c2VkIHRoZSBzdG9wXFxuICAgICAgICAgICAqL1xcbiAgICAgICAgICBpZiAoZS50YXJnZXQgIT09IHZha2F0YV9kbmQudGFyZ2V0KSB7XFxuICAgICAgICAgICAgJCh2YWthdGFfZG5kLnRhcmdldCkub2ZmKCdjbGljay52YWthdGEnKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICAkLnZha2F0YS5kbmQuX3RyaWdnZXIoXFxcInN0b3BcXFwiLCBlKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGlmIChlLnR5cGUgPT09IFxcXCJ0b3VjaGVuZFxcXCIgJiYgZS50YXJnZXQgPT09IHZha2F0YV9kbmQudGFyZ2V0KSB7XFxuICAgICAgICAgICAgdmFyIHRvID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAkKGUudGFyZ2V0KS5jbGljaygpO1xcbiAgICAgICAgICAgIH0sIDEwMCk7XFxuICAgICAgICAgICAgJChlLnRhcmdldCkub25lKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgIGlmICh0bykge1xcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodG8pO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICAkLnZha2F0YS5kbmQuX2NsZWFuKCk7XFxuXFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcbiAgICB9O1xcbiAgfSkoJCk7IC8vIGluY2x1ZGUgdGhlIGRuZCBwbHVnaW4gYnkgZGVmYXVsdFxcbiAgLy8gJC5qc3RyZWUuZGVmYXVsdHMucGx1Z2lucy5wdXNoKFxcXCJkbmRcXFwiKTtcXG5cXG4gIC8qKlxcbiAgICogIyMjIE1hc3Nsb2FkIHBsdWdpblxcbiAgICpcXG4gICAqIEFkZHMgbWFzc2xvYWQgZnVuY3Rpb25hbGl0eSB0byBqc1RyZWUsIHNvIHRoYXQgbXVsdGlwbGUgbm9kZXMgY2FuIGJlIGxvYWRlZCBpbiBhIHNpbmdsZSByZXF1ZXN0IChvbmx5IHVzZWZ1bCB3aXRoIGxhenkgbG9hZGluZykuXFxuICAgKi9cXG5cXG4gIC8qKlxcbiAgICogbWFzc2xvYWQgY29uZmlndXJhdGlvblxcbiAgICpcXG4gICAqIEl0IGlzIHBvc3NpYmxlIHRvIHNldCB0aGlzIHRvIGEgc3RhbmRhcmQgalF1ZXJ5LWxpa2UgQUpBWCBjb25maWcuXFxuICAgKiBJbiBhZGRpdGlvbiB0byB0aGUgc3RhbmRhcmQgalF1ZXJ5IGFqYXggb3B0aW9ucyBoZXJlIHlvdSBjYW4gc3VwcGx5IGZ1bmN0aW9ucyBmb3IgYGRhdGFgIGFuZCBgdXJsYCwgdGhlIGZ1bmN0aW9ucyB3aWxsIGJlIHJ1biBpbiB0aGUgY3VycmVudCBpbnN0YW5jZSdzIHNjb3BlIGFuZCBhIHBhcmFtIHdpbGwgYmUgcGFzc2VkIGluZGljYXRpbmcgd2hpY2ggbm9kZSBJRHMgbmVlZCB0byBiZSBsb2FkZWQsIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhvc2UgZnVuY3Rpb25zIHdpbGwgYmUgdXNlZC5cXG4gICAqXFxuICAgKiBZb3UgY2FuIGFsc28gc2V0IHRoaXMgdG8gYSBmdW5jdGlvbiwgdGhhdCBmdW5jdGlvbiB3aWxsIHJlY2VpdmUgdGhlIG5vZGUgSURzIGJlaW5nIGxvYWRlZCBhcyBhcmd1bWVudCBhbmQgYSBzZWNvbmQgcGFyYW0gd2hpY2ggaXMgYSBmdW5jdGlvbiAoY2FsbGJhY2spIHdoaWNoIHNob3VsZCBiZSBjYWxsZWQgd2l0aCB0aGUgcmVzdWx0LlxcbiAgICpcXG4gICAqIEJvdGggdGhlIEFKQVggYW5kIHRoZSBmdW5jdGlvbiBhcHByb2FjaCByZWx5IG9uIHRoZSBzYW1lIHJldHVybiB2YWx1ZSAtIGFuIG9iamVjdCB3aGVyZSB0aGUga2V5cyBhcmUgdGhlIG5vZGUgSURzLCBhbmQgdGhlIHZhbHVlIGlzIHRoZSBjaGlsZHJlbiBvZiB0aGF0IG5vZGUgYXMgYW4gYXJyYXkuXFxuICAgKlxcbiAgICpcXHR7XFxuICAgKlxcdFxcdFxcXCJpZDFcXFwiIDogW3sgXFxcInRleHRcXFwiIDogXFxcIkNoaWxkIG9mIElEMVxcXCIsIFxcXCJpZFxcXCIgOiBcXFwiYzFcXFwiIH0sIHsgXFxcInRleHRcXFwiIDogXFxcIkFub3RoZXIgY2hpbGQgb2YgSUQxXFxcIiwgXFxcImlkXFxcIiA6IFxcXCJjMlxcXCIgfV0sXFxuICAgKlxcdFxcdFxcXCJpZDJcXFwiIDogW3sgXFxcInRleHRcXFwiIDogXFxcIkNoaWxkIG9mIElEMlxcXCIsIFxcXCJpZFxcXCIgOiBcXFwiYzNcXFwiIH1dXFxuICAgKlxcdH1cXG4gICAqIFxcbiAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMubWFzc2xvYWRcXG4gICAqIEBwbHVnaW4gbWFzc2xvYWRcXG4gICAqL1xcblxcblxcbiAgJC5qc3RyZWUuZGVmYXVsdHMubWFzc2xvYWQgPSBudWxsO1xcblxcbiAgJC5qc3RyZWUucGx1Z2lucy5tYXNzbG9hZCA9IGZ1bmN0aW9uIChvcHRpb25zLCBwYXJlbnQpIHtcXG4gICAgdGhpcy5pbml0ID0gZnVuY3Rpb24gKGVsLCBvcHRpb25zKSB7XFxuICAgICAgdGhpcy5fZGF0YS5tYXNzbG9hZCA9IHt9O1xcbiAgICAgIHBhcmVudC5pbml0LmNhbGwodGhpcywgZWwsIG9wdGlvbnMpO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLl9sb2FkX25vZGVzID0gZnVuY3Rpb24gKG5vZGVzLCBjYWxsYmFjaywgaXNfY2FsbGJhY2ssIGZvcmNlX3JlbG9hZCkge1xcbiAgICAgIHZhciBzID0gdGhpcy5zZXR0aW5ncy5tYXNzbG9hZCxcXG4gICAgICAgICAgbm9kZXNTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShub2RlcyksXFxuICAgICAgICAgIHRvTG9hZCA9IFtdLFxcbiAgICAgICAgICBtID0gdGhpcy5fbW9kZWwuZGF0YSxcXG4gICAgICAgICAgaSxcXG4gICAgICAgICAgaixcXG4gICAgICAgICAgZG9tO1xcblxcbiAgICAgIGlmICghaXNfY2FsbGJhY2spIHtcXG4gICAgICAgIGZvciAoaSA9IDAsIGogPSBub2Rlcy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG4gICAgICAgICAgaWYgKCFtW25vZGVzW2ldXSB8fCAhbVtub2Rlc1tpXV0uc3RhdGUubG9hZGVkICYmICFtW25vZGVzW2ldXS5zdGF0ZS5mYWlsZWQgfHwgZm9yY2VfcmVsb2FkKSB7XFxuICAgICAgICAgICAgdG9Mb2FkLnB1c2gobm9kZXNbaV0pO1xcbiAgICAgICAgICAgIGRvbSA9IHRoaXMuZ2V0X25vZGUobm9kZXNbaV0sIHRydWUpO1xcblxcbiAgICAgICAgICAgIGlmIChkb20gJiYgZG9tLmxlbmd0aCkge1xcbiAgICAgICAgICAgICAgZG9tLmFkZENsYXNzKFxcXCJqc3RyZWUtbG9hZGluZ1xcXCIpLmF0dHIoJ2FyaWEtYnVzeScsIHRydWUpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgdGhpcy5fZGF0YS5tYXNzbG9hZCA9IHt9O1xcblxcbiAgICAgICAgaWYgKHRvTG9hZC5sZW5ndGgpIHtcXG4gICAgICAgICAgaWYgKCQuaXNGdW5jdGlvbihzKSkge1xcbiAgICAgICAgICAgIHJldHVybiBzLmNhbGwodGhpcywgdG9Mb2FkLCAkLnByb3h5KGZ1bmN0aW9uIChkYXRhKSB7XFxuICAgICAgICAgICAgICB2YXIgaSwgajtcXG5cXG4gICAgICAgICAgICAgIGlmIChkYXRhKSB7XFxuICAgICAgICAgICAgICAgIGZvciAoaSBpbiBkYXRhKSB7XFxuICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkoaSkpIHtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RhdGEubWFzc2xvYWRbaV0gPSBkYXRhW2ldO1xcbiAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgZm9yIChpID0gMCwgaiA9IG5vZGVzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcbiAgICAgICAgICAgICAgICBkb20gPSB0aGlzLmdldF9ub2RlKG5vZGVzW2ldLCB0cnVlKTtcXG5cXG4gICAgICAgICAgICAgICAgaWYgKGRvbSAmJiBkb20ubGVuZ3RoKSB7XFxuICAgICAgICAgICAgICAgICAgZG9tLnJlbW92ZUNsYXNzKFxcXCJqc3RyZWUtbG9hZGluZ1xcXCIpLmF0dHIoJ2FyaWEtYnVzeScsIGZhbHNlKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgcGFyZW50Ll9sb2FkX25vZGVzLmNhbGwodGhpcywgbm9kZXMsIGNhbGxiYWNrLCBpc19jYWxsYmFjaywgZm9yY2VfcmVsb2FkKTtcXG4gICAgICAgICAgICB9LCB0aGlzKSk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaWYgKF90eXBlb2YocykgPT09ICdvYmplY3QnICYmIHMgJiYgcy51cmwpIHtcXG4gICAgICAgICAgICBzID0gJC5leHRlbmQodHJ1ZSwge30sIHMpO1xcblxcbiAgICAgICAgICAgIGlmICgkLmlzRnVuY3Rpb24ocy51cmwpKSB7XFxuICAgICAgICAgICAgICBzLnVybCA9IHMudXJsLmNhbGwodGhpcywgdG9Mb2FkKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaWYgKCQuaXNGdW5jdGlvbihzLmRhdGEpKSB7XFxuICAgICAgICAgICAgICBzLmRhdGEgPSBzLmRhdGEuY2FsbCh0aGlzLCB0b0xvYWQpO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICByZXR1cm4gJC5hamF4KHMpLmRvbmUoJC5wcm94eShmdW5jdGlvbiAoZGF0YSwgdCwgeCkge1xcbiAgICAgICAgICAgICAgdmFyIGksIGo7XFxuXFxuICAgICAgICAgICAgICBpZiAoZGF0YSkge1xcbiAgICAgICAgICAgICAgICBmb3IgKGkgaW4gZGF0YSkge1xcbiAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KGkpKSB7XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kYXRhLm1hc3Nsb2FkW2ldID0gZGF0YVtpXTtcXG4gICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgIGZvciAoaSA9IDAsIGogPSBub2Rlcy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG4gICAgICAgICAgICAgICAgZG9tID0gdGhpcy5nZXRfbm9kZShub2Rlc1tpXSwgdHJ1ZSk7XFxuXFxuICAgICAgICAgICAgICAgIGlmIChkb20gJiYgZG9tLmxlbmd0aCkge1xcbiAgICAgICAgICAgICAgICAgIGRvbS5yZW1vdmVDbGFzcyhcXFwianN0cmVlLWxvYWRpbmdcXFwiKS5hdHRyKCdhcmlhLWJ1c3knLCBmYWxzZSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgIHBhcmVudC5fbG9hZF9ub2Rlcy5jYWxsKHRoaXMsIG5vZGVzLCBjYWxsYmFjaywgaXNfY2FsbGJhY2ssIGZvcmNlX3JlbG9hZCk7XFxuICAgICAgICAgICAgfSwgdGhpcykpLmZhaWwoJC5wcm94eShmdW5jdGlvbiAoZikge1xcbiAgICAgICAgICAgICAgcGFyZW50Ll9sb2FkX25vZGVzLmNhbGwodGhpcywgbm9kZXMsIGNhbGxiYWNrLCBpc19jYWxsYmFjaywgZm9yY2VfcmVsb2FkKTtcXG4gICAgICAgICAgICB9LCB0aGlzKSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHBhcmVudC5fbG9hZF9ub2Rlcy5jYWxsKHRoaXMsIG5vZGVzLCBjYWxsYmFjaywgaXNfY2FsbGJhY2ssIGZvcmNlX3JlbG9hZCk7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuX2xvYWRfbm9kZSA9IGZ1bmN0aW9uIChvYmosIGNhbGxiYWNrKSB7XFxuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhLm1hc3Nsb2FkW29iai5pZF0sXFxuICAgICAgICAgIHJzbHQgPSBudWxsLFxcbiAgICAgICAgICBkb207XFxuXFxuICAgICAgaWYgKGRhdGEpIHtcXG4gICAgICAgIHJzbHQgPSB0aGlzW3R5cGVvZiBkYXRhID09PSAnc3RyaW5nJyA/ICdfYXBwZW5kX2h0bWxfZGF0YScgOiAnX2FwcGVuZF9qc29uX2RhdGEnXShvYmosIHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyA/ICQoJC5wYXJzZUhUTUwoZGF0YSkpLmZpbHRlcihmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHJldHVybiB0aGlzLm5vZGVUeXBlICE9PSAzO1xcbiAgICAgICAgfSkgOiBkYXRhLCBmdW5jdGlvbiAoc3RhdHVzKSB7XFxuICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgc3RhdHVzKTtcXG4gICAgICAgIH0pO1xcbiAgICAgICAgZG9tID0gdGhpcy5nZXRfbm9kZShvYmouaWQsIHRydWUpO1xcblxcbiAgICAgICAgaWYgKGRvbSAmJiBkb20ubGVuZ3RoKSB7XFxuICAgICAgICAgIGRvbS5yZW1vdmVDbGFzcyhcXFwianN0cmVlLWxvYWRpbmdcXFwiKS5hdHRyKCdhcmlhLWJ1c3knLCBmYWxzZSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBkZWxldGUgdGhpcy5fZGF0YS5tYXNzbG9hZFtvYmouaWRdO1xcbiAgICAgICAgcmV0dXJuIHJzbHQ7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBwYXJlbnQuX2xvYWRfbm9kZS5jYWxsKHRoaXMsIG9iaiwgY2FsbGJhY2spO1xcbiAgICB9O1xcbiAgfTtcXG4gIC8qKlxcbiAgICogIyMjIFNlYXJjaCBwbHVnaW5cXG4gICAqXFxuICAgKiBBZGRzIHNlYXJjaCBmdW5jdGlvbmFsaXR5IHRvIGpzVHJlZS5cXG4gICAqL1xcblxcbiAgLyoqXFxuICAgKiBzdG9yZXMgYWxsIGRlZmF1bHRzIGZvciB0aGUgc2VhcmNoIHBsdWdpblxcbiAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuc2VhcmNoXFxuICAgKiBAcGx1Z2luIHNlYXJjaFxcbiAgICovXFxuXFxuXFxuICAkLmpzdHJlZS5kZWZhdWx0cy5zZWFyY2ggPSB7XFxuICAgIC8qKlxcbiAgICAgKiBhIGpRdWVyeS1saWtlIEFKQVggY29uZmlnLCB3aGljaCBqc3RyZWUgdXNlcyBpZiBhIHNlcnZlciBzaG91bGQgYmUgcXVlcmllZCBmb3IgcmVzdWx0cy5cXG4gICAgICpcXG4gICAgICogQSBgc3RyYCAod2hpY2ggaXMgdGhlIHNlYXJjaCBzdHJpbmcpIHBhcmFtZXRlciB3aWxsIGJlIGFkZGVkIHdpdGggdGhlIHJlcXVlc3QsIGFuIG9wdGlvbmFsIGBpbnNpZGVgIHBhcmFtZXRlciB3aWxsIGJlIGFkZGVkIGlmIHRoZSBzZWFyY2ggaXMgbGltaXRlZCB0byBhIG5vZGUgaWQuIFRoZSBleHBlY3RlZCByZXN1bHQgaXMgYSBKU09OIGFycmF5IHdpdGggbm9kZXMgdGhhdCBuZWVkIHRvIGJlIG9wZW5lZCBzbyB0aGF0IG1hdGNoaW5nIG5vZGVzIHdpbGwgYmUgcmV2ZWFsZWQuXFxuICAgICAqIExlYXZlIHRoaXMgc2V0dGluZyBhcyBgZmFsc2VgIHRvIG5vdCBxdWVyeSB0aGUgc2VydmVyLiBZb3UgY2FuIGFsc28gc2V0IHRoaXMgdG8gYSBmdW5jdGlvbiwgd2hpY2ggd2lsbCBiZSBpbnZva2VkIGluIHRoZSBpbnN0YW5jZSdzIHNjb3BlIGFuZCByZWNlaXZlIDMgcGFyYW1ldGVycyAtIHRoZSBzZWFyY2ggc3RyaW5nLCB0aGUgY2FsbGJhY2sgdG8gY2FsbCB3aXRoIHRoZSBhcnJheSBvZiBub2RlcyB0byBsb2FkLCBhbmQgdGhlIG9wdGlvbmFsIG5vZGUgSUQgdG8gbGltaXQgdGhlIHNlYXJjaCB0b1xcbiAgICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5zZWFyY2guYWpheFxcbiAgICAgKiBAcGx1Z2luIHNlYXJjaFxcbiAgICAgKi9cXG4gICAgYWpheDogZmFsc2UsXFxuXFxuICAgIC8qKlxcbiAgICAgKiBJbmRpY2F0ZXMgaWYgdGhlIHNlYXJjaCBzaG91bGQgYmUgZnV6enkgb3Igbm90IChzaG91bGQgYGNobmQzYCBtYXRjaCBgY2hpbGQgbm9kZSAzYCkuIERlZmF1bHQgaXMgYGZhbHNlYC5cXG4gICAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuc2VhcmNoLmZ1enp5XFxuICAgICAqIEBwbHVnaW4gc2VhcmNoXFxuICAgICAqL1xcbiAgICBmdXp6eTogZmFsc2UsXFxuXFxuICAgIC8qKlxcbiAgICAgKiBJbmRpY2F0ZXMgaWYgdGhlIHNlYXJjaCBzaG91bGQgYmUgY2FzZSBzZW5zaXRpdmUuIERlZmF1bHQgaXMgYGZhbHNlYC5cXG4gICAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuc2VhcmNoLmNhc2Vfc2Vuc2l0aXZlXFxuICAgICAqIEBwbHVnaW4gc2VhcmNoXFxuICAgICAqL1xcbiAgICBjYXNlX3NlbnNpdGl2ZTogZmFsc2UsXFxuXFxuICAgIC8qKlxcbiAgICAgKiBJbmRpY2F0ZXMgaWYgdGhlIHRyZWUgc2hvdWxkIGJlIGZpbHRlcmVkIChieSBkZWZhdWx0KSB0byBzaG93IG9ubHkgbWF0Y2hpbmcgbm9kZXMgKGtlZXAgaW4gbWluZCB0aGlzIGNhbiBiZSBhIGhlYXZ5IG9uIGxhcmdlIHRyZWVzIGluIG9sZCBicm93c2VycykuXFxuICAgICAqIFRoaXMgc2V0dGluZyBjYW4gYmUgY2hhbmdlZCBhdCBydW50aW1lIHdoZW4gY2FsbGluZyB0aGUgc2VhcmNoIG1ldGhvZC4gRGVmYXVsdCBpcyBgZmFsc2VgLlxcbiAgICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5zZWFyY2guc2hvd19vbmx5X21hdGNoZXNcXG4gICAgICogQHBsdWdpbiBzZWFyY2hcXG4gICAgICovXFxuICAgIHNob3dfb25seV9tYXRjaGVzOiBmYWxzZSxcXG5cXG4gICAgLyoqXFxuICAgICAqIEluZGljYXRlcyBpZiB0aGUgY2hpbGRyZW4gb2YgbWF0Y2hlZCBlbGVtZW50IGFyZSBzaG93biAod2hlbiBzaG93X29ubHlfbWF0Y2hlcyBpcyB0cnVlKVxcbiAgICAgKiBUaGlzIHNldHRpbmcgY2FuIGJlIGNoYW5nZWQgYXQgcnVudGltZSB3aGVuIGNhbGxpbmcgdGhlIHNlYXJjaCBtZXRob2QuIERlZmF1bHQgaXMgYGZhbHNlYC5cXG4gICAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuc2VhcmNoLnNob3dfb25seV9tYXRjaGVzX2NoaWxkcmVuXFxuICAgICAqIEBwbHVnaW4gc2VhcmNoXFxuICAgICAqL1xcbiAgICBzaG93X29ubHlfbWF0Y2hlc19jaGlsZHJlbjogZmFsc2UsXFxuXFxuICAgIC8qKlxcbiAgICAgKiBJbmRpY2F0ZXMgaWYgYWxsIG5vZGVzIG9wZW5lZCB0byByZXZlYWwgdGhlIHNlYXJjaCByZXN1bHQsIHNob3VsZCBiZSBjbG9zZWQgd2hlbiB0aGUgc2VhcmNoIGlzIGNsZWFyZWQgb3IgYSBuZXcgc2VhcmNoIGlzIHBlcmZvcm1lZC4gRGVmYXVsdCBpcyBgdHJ1ZWAuXFxuICAgICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLnNlYXJjaC5jbG9zZV9vcGVuZWRfb25jbGVhclxcbiAgICAgKiBAcGx1Z2luIHNlYXJjaFxcbiAgICAgKi9cXG4gICAgY2xvc2Vfb3BlbmVkX29uY2xlYXI6IHRydWUsXFxuXFxuICAgIC8qKlxcbiAgICAgKiBJbmRpY2F0ZXMgaWYgb25seSBsZWFmIG5vZGVzIHNob3VsZCBiZSBpbmNsdWRlZCBpbiBzZWFyY2ggcmVzdWx0cy4gRGVmYXVsdCBpcyBgZmFsc2VgLlxcbiAgICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5zZWFyY2guc2VhcmNoX2xlYXZlc19vbmx5XFxuICAgICAqIEBwbHVnaW4gc2VhcmNoXFxuICAgICAqL1xcbiAgICBzZWFyY2hfbGVhdmVzX29ubHk6IGZhbHNlLFxcblxcbiAgICAvKipcXG4gICAgICogSWYgc2V0IHRvIGEgZnVuY3Rpb24gaXQgd2lsIGJlIGNhbGxlZCBpbiB0aGUgaW5zdGFuY2UncyBzY29wZSB3aXRoIHR3byBhcmd1bWVudHMgLSBzZWFyY2ggc3RyaW5nIGFuZCBub2RlICh3aGVyZSBub2RlIHdpbGwgYmUgZXZlcnkgbm9kZSBpbiB0aGUgc3RydWN0dXJlLCBzbyB1c2Ugd2l0aCBjYXV0aW9uKS5cXG4gICAgICogSWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgYSB0cnV0aHkgdmFsdWUgdGhlIG5vZGUgd2lsbCBiZSBjb25zaWRlcmVkIGEgbWF0Y2ggKGl0IG1pZ2h0IG5vdCBiZSBkaXNwbGF5ZWQgaWYgc2VhcmNoX29ubHlfbGVhdmVzIGlzIHNldCB0byB0cnVlIGFuZCB0aGUgbm9kZSBpcyBub3QgYSBsZWFmKS4gRGVmYXVsdCBpcyBgZmFsc2VgLlxcbiAgICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5zZWFyY2guc2VhcmNoX2NhbGxiYWNrXFxuICAgICAqIEBwbHVnaW4gc2VhcmNoXFxuICAgICAqL1xcbiAgICBzZWFyY2hfY2FsbGJhY2s6IGZhbHNlXFxuICB9O1xcblxcbiAgJC5qc3RyZWUucGx1Z2lucy5zZWFyY2ggPSBmdW5jdGlvbiAob3B0aW9ucywgcGFyZW50KSB7XFxuICAgIHRoaXMuYmluZCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICBwYXJlbnQuYmluZC5jYWxsKHRoaXMpO1xcbiAgICAgIHRoaXMuX2RhdGEuc2VhcmNoLnN0ciA9IFxcXCJcXFwiO1xcbiAgICAgIHRoaXMuX2RhdGEuc2VhcmNoLmRvbSA9ICQoKTtcXG4gICAgICB0aGlzLl9kYXRhLnNlYXJjaC5yZXMgPSBbXTtcXG4gICAgICB0aGlzLl9kYXRhLnNlYXJjaC5vcG4gPSBbXTtcXG4gICAgICB0aGlzLl9kYXRhLnNlYXJjaC5zb20gPSBmYWxzZTtcXG4gICAgICB0aGlzLl9kYXRhLnNlYXJjaC5zbWMgPSBmYWxzZTtcXG4gICAgICB0aGlzLl9kYXRhLnNlYXJjaC5oZG4gPSBbXTtcXG4gICAgICB0aGlzLmVsZW1lbnQub24oXFxcInNlYXJjaC5qc3RyZWVcXFwiLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XFxuICAgICAgICBpZiAodGhpcy5fZGF0YS5zZWFyY2guc29tICYmIGRhdGEucmVzLmxlbmd0aCkge1xcbiAgICAgICAgICB2YXIgbSA9IHRoaXMuX21vZGVsLmRhdGEsXFxuICAgICAgICAgICAgICBpLFxcbiAgICAgICAgICAgICAgaixcXG4gICAgICAgICAgICAgIHAgPSBbXSxcXG4gICAgICAgICAgICAgIGssXFxuICAgICAgICAgICAgICBsO1xcblxcbiAgICAgICAgICBmb3IgKGkgPSAwLCBqID0gZGF0YS5yZXMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICAgICAgaWYgKG1bZGF0YS5yZXNbaV1dICYmICFtW2RhdGEucmVzW2ldXS5zdGF0ZS5oaWRkZW4pIHtcXG4gICAgICAgICAgICAgIHAucHVzaChkYXRhLnJlc1tpXSk7XFxuICAgICAgICAgICAgICBwID0gcC5jb25jYXQobVtkYXRhLnJlc1tpXV0ucGFyZW50cyk7XFxuXFxuICAgICAgICAgICAgICBpZiAodGhpcy5fZGF0YS5zZWFyY2guc21jKSB7XFxuICAgICAgICAgICAgICAgIGZvciAoayA9IDAsIGwgPSBtW2RhdGEucmVzW2ldXS5jaGlsZHJlbl9kLmxlbmd0aDsgayA8IGw7IGsrKykge1xcbiAgICAgICAgICAgICAgICAgIGlmIChtW21bZGF0YS5yZXNbaV1dLmNoaWxkcmVuX2Rba11dICYmICFtW21bZGF0YS5yZXNbaV1dLmNoaWxkcmVuX2Rba11dLnN0YXRlLmhpZGRlbikge1xcbiAgICAgICAgICAgICAgICAgICAgcC5wdXNoKG1bZGF0YS5yZXNbaV1dLmNoaWxkcmVuX2Rba10pO1xcbiAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBwID0gJC52YWthdGEuYXJyYXlfcmVtb3ZlX2l0ZW0oJC52YWthdGEuYXJyYXlfdW5pcXVlKHApLCAkLmpzdHJlZS5yb290KTtcXG4gICAgICAgICAgdGhpcy5fZGF0YS5zZWFyY2guaGRuID0gdGhpcy5oaWRlX2FsbCh0cnVlKTtcXG4gICAgICAgICAgdGhpcy5zaG93X25vZGUocCwgdHJ1ZSk7XFxuICAgICAgICAgIHRoaXMucmVkcmF3KHRydWUpO1xcbiAgICAgICAgfVxcbiAgICAgIH0sIHRoaXMpKS5vbihcXFwiY2xlYXJfc2VhcmNoLmpzdHJlZVxcXCIsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcXG4gICAgICAgIGlmICh0aGlzLl9kYXRhLnNlYXJjaC5zb20gJiYgZGF0YS5yZXMubGVuZ3RoKSB7XFxuICAgICAgICAgIHRoaXMuc2hvd19ub2RlKHRoaXMuX2RhdGEuc2VhcmNoLmhkbiwgdHJ1ZSk7XFxuICAgICAgICAgIHRoaXMucmVkcmF3KHRydWUpO1xcbiAgICAgICAgfVxcbiAgICAgIH0sIHRoaXMpKTtcXG4gICAgfTtcXG4gICAgLyoqXFxuICAgICAqIHVzZWQgdG8gc2VhcmNoIHRoZSB0cmVlIG5vZGVzIGZvciBhIGdpdmVuIHN0cmluZ1xcbiAgICAgKiBAbmFtZSBzZWFyY2goc3RyIFssIHNraXBfYXN5bmNdKVxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIHRoZSBzZWFyY2ggc3RyaW5nXFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2tpcF9hc3luYyBpZiBzZXQgdG8gdHJ1ZSBzZXJ2ZXIgd2lsbCBub3QgYmUgcXVlcmllZCBldmVuIGlmIGNvbmZpZ3VyZWRcXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzaG93X29ubHlfbWF0Y2hlcyBpZiBzZXQgdG8gdHJ1ZSBvbmx5IG1hdGNoaW5nIG5vZGVzIHdpbGwgYmUgc2hvd24gKGtlZXAgaW4gbWluZCB0aGlzIGNhbiBiZSB2ZXJ5IHNsb3cgb24gbGFyZ2UgdHJlZXMgb3Igb2xkIGJyb3dzZXJzKVxcbiAgICAgKiBAcGFyYW0ge21peGVkfSBpbnNpZGUgYW4gb3B0aW9uYWwgbm9kZSB0byB3aG9zZSBjaGlsZHJlbiB0byBsaW1pdCB0aGUgc2VhcmNoXFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gYXBwZW5kIGlmIHNldCB0byB0cnVlIHRoZSByZXN1bHRzIG9mIHRoaXMgc2VhcmNoIGFyZSBhcHBlbmRlZCB0byB0aGUgcHJldmlvdXMgc2VhcmNoXFxuICAgICAqIEBwbHVnaW4gc2VhcmNoXFxuICAgICAqIEB0cmlnZ2VyIHNlYXJjaC5qc3RyZWVcXG4gICAgICovXFxuXFxuXFxuICAgIHRoaXMuc2VhcmNoID0gZnVuY3Rpb24gKHN0ciwgc2tpcF9hc3luYywgc2hvd19vbmx5X21hdGNoZXMsIGluc2lkZSwgYXBwZW5kLCBzaG93X29ubHlfbWF0Y2hlc19jaGlsZHJlbikge1xcbiAgICAgIGlmIChzdHIgPT09IGZhbHNlIHx8ICQudHJpbShzdHIudG9TdHJpbmcoKSkgPT09IFxcXCJcXFwiKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5jbGVhcl9zZWFyY2goKTtcXG4gICAgICB9XFxuXFxuICAgICAgaW5zaWRlID0gdGhpcy5nZXRfbm9kZShpbnNpZGUpO1xcbiAgICAgIGluc2lkZSA9IGluc2lkZSAmJiBpbnNpZGUuaWQgPyBpbnNpZGUuaWQgOiBudWxsO1xcbiAgICAgIHN0ciA9IHN0ci50b1N0cmluZygpO1xcbiAgICAgIHZhciBzID0gdGhpcy5zZXR0aW5ncy5zZWFyY2gsXFxuICAgICAgICAgIGEgPSBzLmFqYXggPyBzLmFqYXggOiBmYWxzZSxcXG4gICAgICAgICAgbSA9IHRoaXMuX21vZGVsLmRhdGEsXFxuICAgICAgICAgIGYgPSBudWxsLFxcbiAgICAgICAgICByID0gW10sXFxuICAgICAgICAgIHAgPSBbXSxcXG4gICAgICAgICAgaSxcXG4gICAgICAgICAgajtcXG5cXG4gICAgICBpZiAodGhpcy5fZGF0YS5zZWFyY2gucmVzLmxlbmd0aCAmJiAhYXBwZW5kKSB7XFxuICAgICAgICB0aGlzLmNsZWFyX3NlYXJjaCgpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoc2hvd19vbmx5X21hdGNoZXMgPT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgc2hvd19vbmx5X21hdGNoZXMgPSBzLnNob3dfb25seV9tYXRjaGVzO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoc2hvd19vbmx5X21hdGNoZXNfY2hpbGRyZW4gPT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgc2hvd19vbmx5X21hdGNoZXNfY2hpbGRyZW4gPSBzLnNob3dfb25seV9tYXRjaGVzX2NoaWxkcmVuO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIXNraXBfYXN5bmMgJiYgYSAhPT0gZmFsc2UpIHtcXG4gICAgICAgIGlmICgkLmlzRnVuY3Rpb24oYSkpIHtcXG4gICAgICAgICAgcmV0dXJuIGEuY2FsbCh0aGlzLCBzdHIsICQucHJveHkoZnVuY3Rpb24gKGQpIHtcXG4gICAgICAgICAgICBpZiAoZCAmJiBkLmQpIHtcXG4gICAgICAgICAgICAgIGQgPSBkLmQ7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIHRoaXMuX2xvYWRfbm9kZXMoISQuaXNBcnJheShkKSA/IFtdIDogJC52YWthdGEuYXJyYXlfdW5pcXVlKGQpLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICB0aGlzLnNlYXJjaChzdHIsIHRydWUsIHNob3dfb25seV9tYXRjaGVzLCBpbnNpZGUsIGFwcGVuZCwgc2hvd19vbmx5X21hdGNoZXNfY2hpbGRyZW4pO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICB9LCB0aGlzKSwgaW5zaWRlKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGEgPSAkLmV4dGVuZCh7fSwgYSk7XFxuXFxuICAgICAgICAgIGlmICghYS5kYXRhKSB7XFxuICAgICAgICAgICAgYS5kYXRhID0ge307XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgYS5kYXRhLnN0ciA9IHN0cjtcXG5cXG4gICAgICAgICAgaWYgKGluc2lkZSkge1xcbiAgICAgICAgICAgIGEuZGF0YS5pbnNpZGUgPSBpbnNpZGU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaWYgKHRoaXMuX2RhdGEuc2VhcmNoLmxhc3RSZXF1ZXN0KSB7XFxuICAgICAgICAgICAgdGhpcy5fZGF0YS5zZWFyY2gubGFzdFJlcXVlc3QuYWJvcnQoKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICB0aGlzLl9kYXRhLnNlYXJjaC5sYXN0UmVxdWVzdCA9ICQuYWpheChhKS5mYWlsKCQucHJveHkoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yID0ge1xcbiAgICAgICAgICAgICAgJ2Vycm9yJzogJ2FqYXgnLFxcbiAgICAgICAgICAgICAgJ3BsdWdpbic6ICdzZWFyY2gnLFxcbiAgICAgICAgICAgICAgJ2lkJzogJ3NlYXJjaF8wMScsXFxuICAgICAgICAgICAgICAncmVhc29uJzogJ0NvdWxkIG5vdCBsb2FkIHNlYXJjaCBwYXJlbnRzJyxcXG4gICAgICAgICAgICAgICdkYXRhJzogSlNPTi5zdHJpbmdpZnkoYSlcXG4gICAgICAgICAgICB9O1xcbiAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MuY29yZS5lcnJvci5jYWxsKHRoaXMsIHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yKTtcXG4gICAgICAgICAgfSwgdGhpcykpLmRvbmUoJC5wcm94eShmdW5jdGlvbiAoZCkge1xcbiAgICAgICAgICAgIGlmIChkICYmIGQuZCkge1xcbiAgICAgICAgICAgICAgZCA9IGQuZDtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgdGhpcy5fbG9hZF9ub2RlcyghJC5pc0FycmF5KGQpID8gW10gOiAkLnZha2F0YS5hcnJheV91bmlxdWUoZCksIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgIHRoaXMuc2VhcmNoKHN0ciwgdHJ1ZSwgc2hvd19vbmx5X21hdGNoZXMsIGluc2lkZSwgYXBwZW5kLCBzaG93X29ubHlfbWF0Y2hlc19jaGlsZHJlbik7XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgIH0sIHRoaXMpKTtcXG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuc2VhcmNoLmxhc3RSZXF1ZXN0O1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIWFwcGVuZCkge1xcbiAgICAgICAgdGhpcy5fZGF0YS5zZWFyY2guc3RyID0gc3RyO1xcbiAgICAgICAgdGhpcy5fZGF0YS5zZWFyY2guZG9tID0gJCgpO1xcbiAgICAgICAgdGhpcy5fZGF0YS5zZWFyY2gucmVzID0gW107XFxuICAgICAgICB0aGlzLl9kYXRhLnNlYXJjaC5vcG4gPSBbXTtcXG4gICAgICAgIHRoaXMuX2RhdGEuc2VhcmNoLnNvbSA9IHNob3dfb25seV9tYXRjaGVzO1xcbiAgICAgICAgdGhpcy5fZGF0YS5zZWFyY2guc21jID0gc2hvd19vbmx5X21hdGNoZXNfY2hpbGRyZW47XFxuICAgICAgfVxcblxcbiAgICAgIGYgPSBuZXcgJC52YWthdGEuc2VhcmNoKHN0ciwgdHJ1ZSwge1xcbiAgICAgICAgY2FzZVNlbnNpdGl2ZTogcy5jYXNlX3NlbnNpdGl2ZSxcXG4gICAgICAgIGZ1enp5OiBzLmZ1enp5XFxuICAgICAgfSk7XFxuICAgICAgJC5lYWNoKG1baW5zaWRlID8gaW5zaWRlIDogJC5qc3RyZWUucm9vdF0uY2hpbGRyZW5fZCwgZnVuY3Rpb24gKGlpLCBpKSB7XFxuICAgICAgICB2YXIgdiA9IG1baV07XFxuXFxuICAgICAgICBpZiAodi50ZXh0ICYmICF2LnN0YXRlLmhpZGRlbiAmJiAoIXMuc2VhcmNoX2xlYXZlc19vbmx5IHx8IHYuc3RhdGUubG9hZGVkICYmIHYuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSAmJiAocy5zZWFyY2hfY2FsbGJhY2sgJiYgcy5zZWFyY2hfY2FsbGJhY2suY2FsbCh0aGlzLCBzdHIsIHYpIHx8ICFzLnNlYXJjaF9jYWxsYmFjayAmJiBmLnNlYXJjaCh2LnRleHQpLmlzTWF0Y2gpKSB7XFxuICAgICAgICAgIHIucHVzaChpKTtcXG4gICAgICAgICAgcCA9IHAuY29uY2F0KHYucGFyZW50cyk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuXFxuICAgICAgaWYgKHIubGVuZ3RoKSB7XFxuICAgICAgICBwID0gJC52YWthdGEuYXJyYXlfdW5pcXVlKHApO1xcblxcbiAgICAgICAgZm9yIChpID0gMCwgaiA9IHAubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICAgIGlmIChwW2ldICE9PSAkLmpzdHJlZS5yb290ICYmIG1bcFtpXV0gJiYgdGhpcy5vcGVuX25vZGUocFtpXSwgbnVsbCwgMCkgPT09IHRydWUpIHtcXG4gICAgICAgICAgICB0aGlzLl9kYXRhLnNlYXJjaC5vcG4ucHVzaChwW2ldKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKCFhcHBlbmQpIHtcXG4gICAgICAgICAgdGhpcy5fZGF0YS5zZWFyY2guZG9tID0gJCh0aGlzLmVsZW1lbnRbMF0ucXVlcnlTZWxlY3RvckFsbCgnIycgKyAkLm1hcChyLCBmdW5jdGlvbiAodikge1xcbiAgICAgICAgICAgIHJldHVybiBcXFwiMDEyMzQ1Njc4OVxcXCIuaW5kZXhPZih2WzBdKSAhPT0gLTEgPyAnXFxcXFxcXFwzJyArIHZbMF0gKyAnICcgKyB2LnN1YnN0cigxKS5yZXBsYWNlKCQuanN0cmVlLmlkcmVnZXgsICdcXFxcXFxcXCQmJykgOiB2LnJlcGxhY2UoJC5qc3RyZWUuaWRyZWdleCwgJ1xcXFxcXFxcJCYnKTtcXG4gICAgICAgICAgfSkuam9pbignLCAjJykpKTtcXG4gICAgICAgICAgdGhpcy5fZGF0YS5zZWFyY2gucmVzID0gcjtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHRoaXMuX2RhdGEuc2VhcmNoLmRvbSA9IHRoaXMuX2RhdGEuc2VhcmNoLmRvbS5hZGQoJCh0aGlzLmVsZW1lbnRbMF0ucXVlcnlTZWxlY3RvckFsbCgnIycgKyAkLm1hcChyLCBmdW5jdGlvbiAodikge1xcbiAgICAgICAgICAgIHJldHVybiBcXFwiMDEyMzQ1Njc4OVxcXCIuaW5kZXhPZih2WzBdKSAhPT0gLTEgPyAnXFxcXFxcXFwzJyArIHZbMF0gKyAnICcgKyB2LnN1YnN0cigxKS5yZXBsYWNlKCQuanN0cmVlLmlkcmVnZXgsICdcXFxcXFxcXCQmJykgOiB2LnJlcGxhY2UoJC5qc3RyZWUuaWRyZWdleCwgJ1xcXFxcXFxcJCYnKTtcXG4gICAgICAgICAgfSkuam9pbignLCAjJykpKSk7XFxuICAgICAgICAgIHRoaXMuX2RhdGEuc2VhcmNoLnJlcyA9ICQudmFrYXRhLmFycmF5X3VuaXF1ZSh0aGlzLl9kYXRhLnNlYXJjaC5yZXMuY29uY2F0KHIpKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHRoaXMuX2RhdGEuc2VhcmNoLmRvbS5jaGlsZHJlbihcXFwiLmpzdHJlZS1hbmNob3JcXFwiKS5hZGRDbGFzcygnanN0cmVlLXNlYXJjaCcpO1xcbiAgICAgIH1cXG4gICAgICAvKipcXG4gICAgICAgKiB0cmlnZ2VyZWQgYWZ0ZXIgc2VhcmNoIGlzIGNvbXBsZXRlXFxuICAgICAgICogQGV2ZW50XFxuICAgICAgICogQG5hbWUgc2VhcmNoLmpzdHJlZVxcbiAgICAgICAqIEBwYXJhbSB7alF1ZXJ5fSBub2RlcyBhIGpRdWVyeSBjb2xsZWN0aW9uIG9mIG1hdGNoaW5nIG5vZGVzXFxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciB0aGUgc2VhcmNoIHN0cmluZ1xcbiAgICAgICAqIEBwYXJhbSB7QXJyYXl9IHJlcyBhIGNvbGxlY3Rpb24gb2Ygb2JqZWN0cyByZXByZXNlaW5nIHRoZSBtYXRjaGluZyBub2Rlc1xcbiAgICAgICAqIEBwbHVnaW4gc2VhcmNoXFxuICAgICAgICovXFxuXFxuXFxuICAgICAgdGhpcy50cmlnZ2VyKCdzZWFyY2gnLCB7XFxuICAgICAgICBub2RlczogdGhpcy5fZGF0YS5zZWFyY2guZG9tLFxcbiAgICAgICAgc3RyOiBzdHIsXFxuICAgICAgICByZXM6IHRoaXMuX2RhdGEuc2VhcmNoLnJlcyxcXG4gICAgICAgIHNob3dfb25seV9tYXRjaGVzOiBzaG93X29ubHlfbWF0Y2hlc1xcbiAgICAgIH0pO1xcbiAgICB9O1xcbiAgICAvKipcXG4gICAgICogdXNlZCB0byBjbGVhciB0aGUgbGFzdCBzZWFyY2ggKHJlbW92ZXMgY2xhc3NlcyBhbmQgc2hvd3MgYWxsIG5vZGVzIGlmIGZpbHRlcmluZyBpcyBvbilcXG4gICAgICogQG5hbWUgY2xlYXJfc2VhcmNoKClcXG4gICAgICogQHBsdWdpbiBzZWFyY2hcXG4gICAgICogQHRyaWdnZXIgY2xlYXJfc2VhcmNoLmpzdHJlZVxcbiAgICAgKi9cXG5cXG5cXG4gICAgdGhpcy5jbGVhcl9zZWFyY2ggPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3Muc2VhcmNoLmNsb3NlX29wZW5lZF9vbmNsZWFyKSB7XFxuICAgICAgICB0aGlzLmNsb3NlX25vZGUodGhpcy5fZGF0YS5zZWFyY2gub3BuLCAwKTtcXG4gICAgICB9XFxuICAgICAgLyoqXFxuICAgICAgICogdHJpZ2dlcmVkIGFmdGVyIHNlYXJjaCBpcyBjb21wbGV0ZVxcbiAgICAgICAqIEBldmVudFxcbiAgICAgICAqIEBuYW1lIGNsZWFyX3NlYXJjaC5qc3RyZWVcXG4gICAgICAgKiBAcGFyYW0ge2pRdWVyeX0gbm9kZXMgYSBqUXVlcnkgY29sbGVjdGlvbiBvZiBtYXRjaGluZyBub2RlcyAodGhlIHJlc3VsdCBmcm9tIHRoZSBsYXN0IHNlYXJjaClcXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIHRoZSBzZWFyY2ggc3RyaW5nICh0aGUgbGFzdCBzZWFyY2ggc3RyaW5nKVxcbiAgICAgICAqIEBwYXJhbSB7QXJyYXl9IHJlcyBhIGNvbGxlY3Rpb24gb2Ygb2JqZWN0cyByZXByZXNlaW5nIHRoZSBtYXRjaGluZyBub2RlcyAodGhlIHJlc3VsdCBmcm9tIHRoZSBsYXN0IHNlYXJjaClcXG4gICAgICAgKiBAcGx1Z2luIHNlYXJjaFxcbiAgICAgICAqL1xcblxcblxcbiAgICAgIHRoaXMudHJpZ2dlcignY2xlYXJfc2VhcmNoJywge1xcbiAgICAgICAgJ25vZGVzJzogdGhpcy5fZGF0YS5zZWFyY2guZG9tLFxcbiAgICAgICAgc3RyOiB0aGlzLl9kYXRhLnNlYXJjaC5zdHIsXFxuICAgICAgICByZXM6IHRoaXMuX2RhdGEuc2VhcmNoLnJlc1xcbiAgICAgIH0pO1xcblxcbiAgICAgIGlmICh0aGlzLl9kYXRhLnNlYXJjaC5yZXMubGVuZ3RoKSB7XFxuICAgICAgICB0aGlzLl9kYXRhLnNlYXJjaC5kb20gPSAkKHRoaXMuZWxlbWVudFswXS5xdWVyeVNlbGVjdG9yQWxsKCcjJyArICQubWFwKHRoaXMuX2RhdGEuc2VhcmNoLnJlcywgZnVuY3Rpb24gKHYpIHtcXG4gICAgICAgICAgcmV0dXJuIFxcXCIwMTIzNDU2Nzg5XFxcIi5pbmRleE9mKHZbMF0pICE9PSAtMSA/ICdcXFxcXFxcXDMnICsgdlswXSArICcgJyArIHYuc3Vic3RyKDEpLnJlcGxhY2UoJC5qc3RyZWUuaWRyZWdleCwgJ1xcXFxcXFxcJCYnKSA6IHYucmVwbGFjZSgkLmpzdHJlZS5pZHJlZ2V4LCAnXFxcXFxcXFwkJicpO1xcbiAgICAgICAgfSkuam9pbignLCAjJykpKTtcXG5cXG4gICAgICAgIHRoaXMuX2RhdGEuc2VhcmNoLmRvbS5jaGlsZHJlbihcXFwiLmpzdHJlZS1hbmNob3JcXFwiKS5yZW1vdmVDbGFzcyhcXFwianN0cmVlLXNlYXJjaFxcXCIpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9kYXRhLnNlYXJjaC5zdHIgPSBcXFwiXFxcIjtcXG4gICAgICB0aGlzLl9kYXRhLnNlYXJjaC5yZXMgPSBbXTtcXG4gICAgICB0aGlzLl9kYXRhLnNlYXJjaC5vcG4gPSBbXTtcXG4gICAgICB0aGlzLl9kYXRhLnNlYXJjaC5kb20gPSAkKCk7XFxuICAgIH07XFxuXFxuICAgIHRoaXMucmVkcmF3X25vZGUgPSBmdW5jdGlvbiAob2JqLCBkZWVwLCBjYWxsYmFjaywgZm9yY2VfcmVuZGVyKSB7XFxuICAgICAgb2JqID0gcGFyZW50LnJlZHJhd19ub2RlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuXFxuICAgICAgaWYgKG9iaikge1xcbiAgICAgICAgaWYgKCQuaW5BcnJheShvYmouaWQsIHRoaXMuX2RhdGEuc2VhcmNoLnJlcykgIT09IC0xKSB7XFxuICAgICAgICAgIHZhciBpLFxcbiAgICAgICAgICAgICAgaixcXG4gICAgICAgICAgICAgIHRtcCA9IG51bGw7XFxuXFxuICAgICAgICAgIGZvciAoaSA9IDAsIGogPSBvYmouY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG4gICAgICAgICAgICBpZiAob2JqLmNoaWxkTm9kZXNbaV0gJiYgb2JqLmNoaWxkTm9kZXNbaV0uY2xhc3NOYW1lICYmIG9iai5jaGlsZE5vZGVzW2ldLmNsYXNzTmFtZS5pbmRleE9mKFxcXCJqc3RyZWUtYW5jaG9yXFxcIikgIT09IC0xKSB7XFxuICAgICAgICAgICAgICB0bXAgPSBvYmouY2hpbGROb2Rlc1tpXTtcXG4gICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAodG1wKSB7XFxuICAgICAgICAgICAgdG1wLmNsYXNzTmFtZSArPSAnIGpzdHJlZS1zZWFyY2gnO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBvYmo7XFxuICAgIH07XFxuICB9OyAvLyBoZWxwZXJzXFxuXFxuXFxuICAoZnVuY3Rpb24gKCQpIHtcXG4gICAgLy8gZnJvbSBodHRwOi8va2lyby5tZS9wcm9qZWN0cy9mdXNlLmh0bWxcXG4gICAgJC52YWthdGEuc2VhcmNoID0gZnVuY3Rpb24gKHBhdHRlcm4sIHR4dCwgb3B0aW9ucykge1xcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xcbiAgICAgIG9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgJC52YWthdGEuc2VhcmNoLmRlZmF1bHRzLCBvcHRpb25zKTtcXG5cXG4gICAgICBpZiAob3B0aW9ucy5mdXp6eSAhPT0gZmFsc2UpIHtcXG4gICAgICAgIG9wdGlvbnMuZnV6enkgPSB0cnVlO1xcbiAgICAgIH1cXG5cXG4gICAgICBwYXR0ZXJuID0gb3B0aW9ucy5jYXNlU2Vuc2l0aXZlID8gcGF0dGVybiA6IHBhdHRlcm4udG9Mb3dlckNhc2UoKTtcXG4gICAgICB2YXIgTUFUQ0hfTE9DQVRJT04gPSBvcHRpb25zLmxvY2F0aW9uLFxcbiAgICAgICAgICBNQVRDSF9ESVNUQU5DRSA9IG9wdGlvbnMuZGlzdGFuY2UsXFxuICAgICAgICAgIE1BVENIX1RIUkVTSE9MRCA9IG9wdGlvbnMudGhyZXNob2xkLFxcbiAgICAgICAgICBwYXR0ZXJuTGVuID0gcGF0dGVybi5sZW5ndGgsXFxuICAgICAgICAgIG1hdGNobWFzayxcXG4gICAgICAgICAgcGF0dGVybl9hbHBoYWJldCxcXG4gICAgICAgICAgbWF0Y2hfYml0YXBTY29yZSxcXG4gICAgICAgICAgc2VhcmNoO1xcblxcbiAgICAgIGlmIChwYXR0ZXJuTGVuID4gMzIpIHtcXG4gICAgICAgIG9wdGlvbnMuZnV6enkgPSBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKG9wdGlvbnMuZnV6enkpIHtcXG4gICAgICAgIG1hdGNobWFzayA9IDEgPDwgcGF0dGVybkxlbiAtIDE7XFxuXFxuICAgICAgICBwYXR0ZXJuX2FscGhhYmV0ID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICB2YXIgbWFzayA9IHt9LFxcbiAgICAgICAgICAgICAgaSA9IDA7XFxuXFxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYXR0ZXJuTGVuOyBpKyspIHtcXG4gICAgICAgICAgICBtYXNrW3BhdHRlcm4uY2hhckF0KGkpXSA9IDA7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhdHRlcm5MZW47IGkrKykge1xcbiAgICAgICAgICAgIG1hc2tbcGF0dGVybi5jaGFyQXQoaSldIHw9IDEgPDwgcGF0dGVybkxlbiAtIGkgLSAxO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHJldHVybiBtYXNrO1xcbiAgICAgICAgfSgpO1xcblxcbiAgICAgICAgbWF0Y2hfYml0YXBTY29yZSA9IGZ1bmN0aW9uIG1hdGNoX2JpdGFwU2NvcmUoZSwgeCkge1xcbiAgICAgICAgICB2YXIgYWNjdXJhY3kgPSBlIC8gcGF0dGVybkxlbixcXG4gICAgICAgICAgICAgIHByb3hpbWl0eSA9IE1hdGguYWJzKE1BVENIX0xPQ0FUSU9OIC0geCk7XFxuXFxuICAgICAgICAgIGlmICghTUFUQ0hfRElTVEFOQ0UpIHtcXG4gICAgICAgICAgICByZXR1cm4gcHJveGltaXR5ID8gMS4wIDogYWNjdXJhY3k7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgcmV0dXJuIGFjY3VyYWN5ICsgcHJveGltaXR5IC8gTUFUQ0hfRElTVEFOQ0U7XFxuICAgICAgICB9O1xcbiAgICAgIH1cXG5cXG4gICAgICBzZWFyY2ggPSBmdW5jdGlvbiBzZWFyY2godGV4dCkge1xcbiAgICAgICAgdGV4dCA9IG9wdGlvbnMuY2FzZVNlbnNpdGl2ZSA/IHRleHQgOiB0ZXh0LnRvTG93ZXJDYXNlKCk7XFxuXFxuICAgICAgICBpZiAocGF0dGVybiA9PT0gdGV4dCB8fCB0ZXh0LmluZGV4T2YocGF0dGVybikgIT09IC0xKSB7XFxuICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgaXNNYXRjaDogdHJ1ZSxcXG4gICAgICAgICAgICBzY29yZTogMFxcbiAgICAgICAgICB9O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKCFvcHRpb25zLmZ1enp5KSB7XFxuICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgaXNNYXRjaDogZmFsc2UsXFxuICAgICAgICAgICAgc2NvcmU6IDFcXG4gICAgICAgICAgfTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHZhciBpLFxcbiAgICAgICAgICAgIGosXFxuICAgICAgICAgICAgdGV4dExlbiA9IHRleHQubGVuZ3RoLFxcbiAgICAgICAgICAgIHNjb3JlVGhyZXNob2xkID0gTUFUQ0hfVEhSRVNIT0xELFxcbiAgICAgICAgICAgIGJlc3RMb2MgPSB0ZXh0LmluZGV4T2YocGF0dGVybiwgTUFUQ0hfTE9DQVRJT04pLFxcbiAgICAgICAgICAgIGJpbk1pbixcXG4gICAgICAgICAgICBiaW5NaWQsXFxuICAgICAgICAgICAgYmluTWF4ID0gcGF0dGVybkxlbiArIHRleHRMZW4sXFxuICAgICAgICAgICAgbGFzdFJkLFxcbiAgICAgICAgICAgIHN0YXJ0LFxcbiAgICAgICAgICAgIGZpbmlzaCxcXG4gICAgICAgICAgICByZCxcXG4gICAgICAgICAgICBjaGFyTWF0Y2gsXFxuICAgICAgICAgICAgc2NvcmUgPSAxLFxcbiAgICAgICAgICAgIGxvY2F0aW9ucyA9IFtdO1xcblxcbiAgICAgICAgaWYgKGJlc3RMb2MgIT09IC0xKSB7XFxuICAgICAgICAgIHNjb3JlVGhyZXNob2xkID0gTWF0aC5taW4obWF0Y2hfYml0YXBTY29yZSgwLCBiZXN0TG9jKSwgc2NvcmVUaHJlc2hvbGQpO1xcbiAgICAgICAgICBiZXN0TG9jID0gdGV4dC5sYXN0SW5kZXhPZihwYXR0ZXJuLCBNQVRDSF9MT0NBVElPTiArIHBhdHRlcm5MZW4pO1xcblxcbiAgICAgICAgICBpZiAoYmVzdExvYyAhPT0gLTEpIHtcXG4gICAgICAgICAgICBzY29yZVRocmVzaG9sZCA9IE1hdGgubWluKG1hdGNoX2JpdGFwU2NvcmUoMCwgYmVzdExvYyksIHNjb3JlVGhyZXNob2xkKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgYmVzdExvYyA9IC0xO1xcblxcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhdHRlcm5MZW47IGkrKykge1xcbiAgICAgICAgICBiaW5NaW4gPSAwO1xcbiAgICAgICAgICBiaW5NaWQgPSBiaW5NYXg7XFxuXFxuICAgICAgICAgIHdoaWxlIChiaW5NaW4gPCBiaW5NaWQpIHtcXG4gICAgICAgICAgICBpZiAobWF0Y2hfYml0YXBTY29yZShpLCBNQVRDSF9MT0NBVElPTiArIGJpbk1pZCkgPD0gc2NvcmVUaHJlc2hvbGQpIHtcXG4gICAgICAgICAgICAgIGJpbk1pbiA9IGJpbk1pZDtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgYmluTWF4ID0gYmluTWlkO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBiaW5NaWQgPSBNYXRoLmZsb29yKChiaW5NYXggLSBiaW5NaW4pIC8gMiArIGJpbk1pbik7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgYmluTWF4ID0gYmluTWlkO1xcbiAgICAgICAgICBzdGFydCA9IE1hdGgubWF4KDEsIE1BVENIX0xPQ0FUSU9OIC0gYmluTWlkICsgMSk7XFxuICAgICAgICAgIGZpbmlzaCA9IE1hdGgubWluKE1BVENIX0xPQ0FUSU9OICsgYmluTWlkLCB0ZXh0TGVuKSArIHBhdHRlcm5MZW47XFxuICAgICAgICAgIHJkID0gbmV3IEFycmF5KGZpbmlzaCArIDIpO1xcbiAgICAgICAgICByZFtmaW5pc2ggKyAxXSA9ICgxIDw8IGkpIC0gMTtcXG5cXG4gICAgICAgICAgZm9yIChqID0gZmluaXNoOyBqID49IHN0YXJ0OyBqLS0pIHtcXG4gICAgICAgICAgICBjaGFyTWF0Y2ggPSBwYXR0ZXJuX2FscGhhYmV0W3RleHQuY2hhckF0KGogLSAxKV07XFxuXFxuICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcXG4gICAgICAgICAgICAgIHJkW2pdID0gKHJkW2ogKyAxXSA8PCAxIHwgMSkgJiBjaGFyTWF0Y2g7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgIHJkW2pdID0gKHJkW2ogKyAxXSA8PCAxIHwgMSkgJiBjaGFyTWF0Y2ggfCAoKGxhc3RSZFtqICsgMV0gfCBsYXN0UmRbal0pIDw8IDEgfCAxKSB8IGxhc3RSZFtqICsgMV07XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmIChyZFtqXSAmIG1hdGNobWFzaykge1xcbiAgICAgICAgICAgICAgc2NvcmUgPSBtYXRjaF9iaXRhcFNjb3JlKGksIGogLSAxKTtcXG5cXG4gICAgICAgICAgICAgIGlmIChzY29yZSA8PSBzY29yZVRocmVzaG9sZCkge1xcbiAgICAgICAgICAgICAgICBzY29yZVRocmVzaG9sZCA9IHNjb3JlO1xcbiAgICAgICAgICAgICAgICBiZXN0TG9jID0gaiAtIDE7XFxuICAgICAgICAgICAgICAgIGxvY2F0aW9ucy5wdXNoKGJlc3RMb2MpO1xcblxcbiAgICAgICAgICAgICAgICBpZiAoYmVzdExvYyA+IE1BVENIX0xPQ0FUSU9OKSB7XFxuICAgICAgICAgICAgICAgICAgc3RhcnQgPSBNYXRoLm1heCgxLCAyICogTUFUQ0hfTE9DQVRJT04gLSBiZXN0TG9jKTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAobWF0Y2hfYml0YXBTY29yZShpICsgMSwgTUFUQ0hfTE9DQVRJT04pID4gc2NvcmVUaHJlc2hvbGQpIHtcXG4gICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBsYXN0UmQgPSByZDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgIGlzTWF0Y2g6IGJlc3RMb2MgPj0gMCxcXG4gICAgICAgICAgc2NvcmU6IHNjb3JlXFxuICAgICAgICB9O1xcbiAgICAgIH07XFxuXFxuICAgICAgcmV0dXJuIHR4dCA9PT0gdHJ1ZSA/IHtcXG4gICAgICAgICdzZWFyY2gnOiBzZWFyY2hcXG4gICAgICB9IDogc2VhcmNoKHR4dCk7XFxuICAgIH07XFxuXFxuICAgICQudmFrYXRhLnNlYXJjaC5kZWZhdWx0cyA9IHtcXG4gICAgICBsb2NhdGlvbjogMCxcXG4gICAgICBkaXN0YW5jZTogMTAwLFxcbiAgICAgIHRocmVzaG9sZDogMC42LFxcbiAgICAgIGZ1enp5OiBmYWxzZSxcXG4gICAgICBjYXNlU2Vuc2l0aXZlOiBmYWxzZVxcbiAgICB9O1xcbiAgfSkoJCk7IC8vIGluY2x1ZGUgdGhlIHNlYXJjaCBwbHVnaW4gYnkgZGVmYXVsdFxcbiAgLy8gJC5qc3RyZWUuZGVmYXVsdHMucGx1Z2lucy5wdXNoKFxcXCJzZWFyY2hcXFwiKTtcXG5cXG4gIC8qKlxcbiAgICogIyMjIFNvcnQgcGx1Z2luXFxuICAgKlxcbiAgICogQXV0b21hdGljYWxseSBzb3J0cyBhbGwgc2libGluZ3MgaW4gdGhlIHRyZWUgYWNjb3JkaW5nIHRvIGEgc29ydGluZyBmdW5jdGlvbi5cXG4gICAqL1xcblxcbiAgLyoqXFxuICAgKiB0aGUgc2V0dGluZ3MgZnVuY3Rpb24gdXNlZCB0byBzb3J0IHRoZSBub2Rlcy5cXG4gICAqIEl0IGlzIGV4ZWN1dGVkIGluIHRoZSB0cmVlJ3MgY29udGV4dCwgYWNjZXB0cyB0d28gbm9kZXMgYXMgYXJndW1lbnRzIGFuZCBzaG91bGQgcmV0dXJuIGAxYCBvciBgLTFgLlxcbiAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuc29ydFxcbiAgICogQHBsdWdpbiBzb3J0XFxuICAgKi9cXG5cXG5cXG4gICQuanN0cmVlLmRlZmF1bHRzLnNvcnQgPSBmdW5jdGlvbiAoYSwgYikge1xcbiAgICAvL3JldHVybiB0aGlzLmdldF90eXBlKGEpID09PSB0aGlzLmdldF90eXBlKGIpID8gKHRoaXMuZ2V0X3RleHQoYSkgPiB0aGlzLmdldF90ZXh0KGIpID8gMSA6IC0xKSA6IHRoaXMuZ2V0X3R5cGUoYSkgPj0gdGhpcy5nZXRfdHlwZShiKTtcXG4gICAgcmV0dXJuIHRoaXMuZ2V0X3RleHQoYSkgPiB0aGlzLmdldF90ZXh0KGIpID8gMSA6IC0xO1xcbiAgfTtcXG5cXG4gICQuanN0cmVlLnBsdWdpbnMuc29ydCA9IGZ1bmN0aW9uIChvcHRpb25zLCBwYXJlbnQpIHtcXG4gICAgdGhpcy5iaW5kID0gZnVuY3Rpb24gKCkge1xcbiAgICAgIHBhcmVudC5iaW5kLmNhbGwodGhpcyk7XFxuICAgICAgdGhpcy5lbGVtZW50Lm9uKFxcXCJtb2RlbC5qc3RyZWVcXFwiLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XFxuICAgICAgICB0aGlzLnNvcnQoZGF0YS5wYXJlbnQsIHRydWUpO1xcbiAgICAgIH0sIHRoaXMpKS5vbihcXFwicmVuYW1lX25vZGUuanN0cmVlIGNyZWF0ZV9ub2RlLmpzdHJlZVxcXCIsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcXG4gICAgICAgIHRoaXMuc29ydChkYXRhLnBhcmVudCB8fCBkYXRhLm5vZGUucGFyZW50LCBmYWxzZSk7XFxuICAgICAgICB0aGlzLnJlZHJhd19ub2RlKGRhdGEucGFyZW50IHx8IGRhdGEubm9kZS5wYXJlbnQsIHRydWUpO1xcbiAgICAgIH0sIHRoaXMpKS5vbihcXFwibW92ZV9ub2RlLmpzdHJlZSBjb3B5X25vZGUuanN0cmVlXFxcIiwgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xcbiAgICAgICAgdGhpcy5zb3J0KGRhdGEucGFyZW50LCBmYWxzZSk7XFxuICAgICAgICB0aGlzLnJlZHJhd19ub2RlKGRhdGEucGFyZW50LCB0cnVlKTtcXG4gICAgICB9LCB0aGlzKSk7XFxuICAgIH07XFxuICAgIC8qKlxcbiAgICAgKiB1c2VkIHRvIHNvcnQgYSBub2RlJ3MgY2hpbGRyZW5cXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQG5hbWUgc29ydChvYmogWywgZGVlcF0pXFxuICAgICAqIEBwYXJhbSAge21peGVkfSBvYmogdGhlIG5vZGVcXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBkZWVwIGlmIHNldCB0byBgdHJ1ZWAgbm9kZXMgYXJlIHNvcnRlZCByZWN1cnNpdmVseS5cXG4gICAgICogQHBsdWdpbiBzb3J0XFxuICAgICAqIEB0cmlnZ2VyIHNlYXJjaC5qc3RyZWVcXG4gICAgICovXFxuXFxuXFxuICAgIHRoaXMuc29ydCA9IGZ1bmN0aW9uIChvYmosIGRlZXApIHtcXG4gICAgICB2YXIgaSwgajtcXG4gICAgICBvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XFxuXFxuICAgICAgaWYgKG9iaiAmJiBvYmouY2hpbGRyZW4gJiYgb2JqLmNoaWxkcmVuLmxlbmd0aCkge1xcbiAgICAgICAgb2JqLmNoaWxkcmVuLnNvcnQoJC5wcm94eSh0aGlzLnNldHRpbmdzLnNvcnQsIHRoaXMpKTtcXG5cXG4gICAgICAgIGlmIChkZWVwKSB7XFxuICAgICAgICAgIGZvciAoaSA9IDAsIGogPSBvYmouY2hpbGRyZW5fZC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG4gICAgICAgICAgICB0aGlzLnNvcnQob2JqLmNoaWxkcmVuX2RbaV0sIGZhbHNlKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfTtcXG4gIH07IC8vIGluY2x1ZGUgdGhlIHNvcnQgcGx1Z2luIGJ5IGRlZmF1bHRcXG4gIC8vICQuanN0cmVlLmRlZmF1bHRzLnBsdWdpbnMucHVzaChcXFwic29ydFxcXCIpO1xcblxcbiAgLyoqXFxuICAgKiAjIyMgU3RhdGUgcGx1Z2luXFxuICAgKlxcbiAgICogU2F2ZXMgdGhlIHN0YXRlIG9mIHRoZSB0cmVlIChzZWxlY3RlZCBub2Rlcywgb3BlbmVkIG5vZGVzKSBvbiB0aGUgdXNlcidzIGNvbXB1dGVyIHVzaW5nIGF2YWlsYWJsZSBvcHRpb25zIChsb2NhbFN0b3JhZ2UsIGNvb2tpZXMsIGV0YylcXG4gICAqL1xcblxcblxcbiAgdmFyIHRvID0gZmFsc2U7XFxuICAvKipcXG4gICAqIHN0b3JlcyBhbGwgZGVmYXVsdHMgZm9yIHRoZSBzdGF0ZSBwbHVnaW5cXG4gICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLnN0YXRlXFxuICAgKiBAcGx1Z2luIHN0YXRlXFxuICAgKi9cXG5cXG4gICQuanN0cmVlLmRlZmF1bHRzLnN0YXRlID0ge1xcbiAgICAvKipcXG4gICAgICogQSBzdHJpbmcgZm9yIHRoZSBrZXkgdG8gdXNlIHdoZW4gc2F2aW5nIHRoZSBjdXJyZW50IHRyZWUgKGNoYW5nZSBpZiB1c2luZyBtdWx0aXBsZSB0cmVlcyBpbiB5b3VyIHByb2plY3QpLiBEZWZhdWx0cyB0byBganN0cmVlYC5cXG4gICAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuc3RhdGUua2V5XFxuICAgICAqIEBwbHVnaW4gc3RhdGVcXG4gICAgICovXFxuICAgIGtleTogJ2pzdHJlZScsXFxuXFxuICAgIC8qKlxcbiAgICAgKiBBIHNwYWNlIHNlcGFyYXRlZCBsaXN0IG9mIGV2ZW50cyB0aGF0IHRyaWdnZXIgYSBzdGF0ZSBzYXZlLiBEZWZhdWx0cyB0byBgY2hhbmdlZC5qc3RyZWUgb3Blbl9ub2RlLmpzdHJlZSBjbG9zZV9ub2RlLmpzdHJlZWAuXFxuICAgICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLnN0YXRlLmV2ZW50c1xcbiAgICAgKiBAcGx1Z2luIHN0YXRlXFxuICAgICAqL1xcbiAgICBldmVudHM6ICdjaGFuZ2VkLmpzdHJlZSBvcGVuX25vZGUuanN0cmVlIGNsb3NlX25vZGUuanN0cmVlIGNoZWNrX25vZGUuanN0cmVlIHVuY2hlY2tfbm9kZS5qc3RyZWUnLFxcblxcbiAgICAvKipcXG4gICAgICogVGltZSBpbiBtaWxsaXNlY29uZHMgYWZ0ZXIgd2hpY2ggdGhlIHN0YXRlIHdpbGwgZXhwaXJlLiBEZWZhdWx0cyB0byAnZmFsc2UnIG1lYW5pbmcgLSBubyBleHBpcmUuXFxuICAgICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLnN0YXRlLnR0bFxcbiAgICAgKiBAcGx1Z2luIHN0YXRlXFxuICAgICAqL1xcbiAgICB0dGw6IGZhbHNlLFxcblxcbiAgICAvKipcXG4gICAgICogQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgcHJpb3IgdG8gcmVzdG9yaW5nIHN0YXRlIHdpdGggb25lIGFyZ3VtZW50IC0gdGhlIHN0YXRlIG9iamVjdC4gQ2FuIGJlIHVzZWQgdG8gY2xlYXIgdW53YW50ZWQgcGFydHMgb2YgdGhlIHN0YXRlLlxcbiAgICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5zdGF0ZS5maWx0ZXJcXG4gICAgICogQHBsdWdpbiBzdGF0ZVxcbiAgICAgKi9cXG4gICAgZmlsdGVyOiBmYWxzZVxcbiAgfTtcXG5cXG4gICQuanN0cmVlLnBsdWdpbnMuc3RhdGUgPSBmdW5jdGlvbiAob3B0aW9ucywgcGFyZW50KSB7XFxuICAgIHRoaXMuYmluZCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICBwYXJlbnQuYmluZC5jYWxsKHRoaXMpO1xcbiAgICAgIHZhciBiaW5kID0gJC5wcm94eShmdW5jdGlvbiAoKSB7XFxuICAgICAgICB0aGlzLmVsZW1lbnQub24odGhpcy5zZXR0aW5ncy5zdGF0ZS5ldmVudHMsICQucHJveHkoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBpZiAodG8pIHtcXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodG8pO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHRvID0gc2V0VGltZW91dCgkLnByb3h5KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICB0aGlzLnNhdmVfc3RhdGUoKTtcXG4gICAgICAgICAgfSwgdGhpcyksIDEwMCk7XFxuICAgICAgICB9LCB0aGlzKSk7XFxuICAgICAgICAvKipcXG4gICAgICAgICAqIHRyaWdnZXJlZCB3aGVuIHRoZSBzdGF0ZSBwbHVnaW4gaXMgZmluaXNoZWQgcmVzdG9yaW5nIHRoZSBzdGF0ZSAoYW5kIGltbWVkaWF0ZWx5IGFmdGVyIHJlYWR5IGlmIHRoZXJlIGlzIG5vIHN0YXRlIHRvIHJlc3RvcmUpLlxcbiAgICAgICAgICogQGV2ZW50XFxuICAgICAgICAgKiBAbmFtZSBzdGF0ZV9yZWFkeS5qc3RyZWVcXG4gICAgICAgICAqIEBwbHVnaW4gc3RhdGVcXG4gICAgICAgICAqL1xcblxcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdzdGF0ZV9yZWFkeScpO1xcbiAgICAgIH0sIHRoaXMpO1xcbiAgICAgIHRoaXMuZWxlbWVudC5vbihcXFwicmVhZHkuanN0cmVlXFxcIiwgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xcbiAgICAgICAgdGhpcy5lbGVtZW50Lm9uZShcXFwicmVzdG9yZV9zdGF0ZS5qc3RyZWVcXFwiLCBiaW5kKTtcXG5cXG4gICAgICAgIGlmICghdGhpcy5yZXN0b3JlX3N0YXRlKCkpIHtcXG4gICAgICAgICAgYmluZCgpO1xcbiAgICAgICAgfVxcbiAgICAgIH0sIHRoaXMpKTtcXG4gICAgfTtcXG4gICAgLyoqXFxuICAgICAqIHNhdmUgdGhlIHN0YXRlXFxuICAgICAqIEBuYW1lIHNhdmVfc3RhdGUoKVxcbiAgICAgKiBAcGx1Z2luIHN0YXRlXFxuICAgICAqL1xcblxcblxcbiAgICB0aGlzLnNhdmVfc3RhdGUgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgdmFyIHN0ID0ge1xcbiAgICAgICAgJ3N0YXRlJzogdGhpcy5nZXRfc3RhdGUoKSxcXG4gICAgICAgICd0dGwnOiB0aGlzLnNldHRpbmdzLnN0YXRlLnR0bCxcXG4gICAgICAgICdzZWMnOiArbmV3IERhdGUoKVxcbiAgICAgIH07XFxuICAgICAgJC52YWthdGEuc3RvcmFnZS5zZXQodGhpcy5zZXR0aW5ncy5zdGF0ZS5rZXksIEpTT04uc3RyaW5naWZ5KHN0KSk7XFxuICAgIH07XFxuICAgIC8qKlxcbiAgICAgKiByZXN0b3JlIHRoZSBzdGF0ZSBmcm9tIHRoZSB1c2VyJ3MgY29tcHV0ZXJcXG4gICAgICogQG5hbWUgcmVzdG9yZV9zdGF0ZSgpXFxuICAgICAqIEBwbHVnaW4gc3RhdGVcXG4gICAgICovXFxuXFxuXFxuICAgIHRoaXMucmVzdG9yZV9zdGF0ZSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICB2YXIgayA9ICQudmFrYXRhLnN0b3JhZ2UuZ2V0KHRoaXMuc2V0dGluZ3Muc3RhdGUua2V5KTtcXG5cXG4gICAgICBpZiAoISFrKSB7XFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICBrID0gSlNPTi5wYXJzZShrKTtcXG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XFxuICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCEhayAmJiBrLnR0bCAmJiBrLnNlYyAmJiArbmV3IERhdGUoKSAtIGsuc2VjID4gay50dGwpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCEhayAmJiBrLnN0YXRlKSB7XFxuICAgICAgICBrID0gay5zdGF0ZTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCEhayAmJiAkLmlzRnVuY3Rpb24odGhpcy5zZXR0aW5ncy5zdGF0ZS5maWx0ZXIpKSB7XFxuICAgICAgICBrID0gdGhpcy5zZXR0aW5ncy5zdGF0ZS5maWx0ZXIuY2FsbCh0aGlzLCBrKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCEhaykge1xcbiAgICAgICAgdGhpcy5lbGVtZW50Lm9uZShcXFwic2V0X3N0YXRlLmpzdHJlZVxcXCIsIGZ1bmN0aW9uIChlLCBkYXRhKSB7XFxuICAgICAgICAgIGRhdGEuaW5zdGFuY2UudHJpZ2dlcigncmVzdG9yZV9zdGF0ZScsIHtcXG4gICAgICAgICAgICAnc3RhdGUnOiAkLmV4dGVuZCh0cnVlLCB7fSwgaylcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9KTtcXG4gICAgICAgIHRoaXMuc2V0X3N0YXRlKGspO1xcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfTtcXG4gICAgLyoqXFxuICAgICAqIGNsZWFyIHRoZSBzdGF0ZSBvbiB0aGUgdXNlcidzIGNvbXB1dGVyXFxuICAgICAqIEBuYW1lIGNsZWFyX3N0YXRlKClcXG4gICAgICogQHBsdWdpbiBzdGF0ZVxcbiAgICAgKi9cXG5cXG5cXG4gICAgdGhpcy5jbGVhcl9zdGF0ZSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICByZXR1cm4gJC52YWthdGEuc3RvcmFnZS5kZWwodGhpcy5zZXR0aW5ncy5zdGF0ZS5rZXkpO1xcbiAgICB9O1xcbiAgfTtcXG5cXG4gIChmdW5jdGlvbiAoJCwgdW5kZWZpbmVkKSB7XFxuICAgICQudmFrYXRhLnN0b3JhZ2UgPSB7XFxuICAgICAgLy8gc2ltcGx5IHNwZWNpZnlpbmcgdGhlIGZ1bmN0aW9ucyBpbiBGRiB0aHJvd3MgYW4gZXJyb3JcXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldChrZXksIHZhbCkge1xcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIHZhbCk7XFxuICAgICAgfSxcXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldChrZXkpIHtcXG4gICAgICAgIHJldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KTtcXG4gICAgICB9LFxcbiAgICAgIGRlbDogZnVuY3Rpb24gZGVsKGtleSkge1xcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xcbiAgICAgIH1cXG4gICAgfTtcXG4gIH0pKCQpOyAvLyBpbmNsdWRlIHRoZSBzdGF0ZSBwbHVnaW4gYnkgZGVmYXVsdFxcbiAgLy8gJC5qc3RyZWUuZGVmYXVsdHMucGx1Z2lucy5wdXNoKFxcXCJzdGF0ZVxcXCIpO1xcblxcbiAgLyoqXFxuICAgKiAjIyMgVHlwZXMgcGx1Z2luXFxuICAgKlxcbiAgICogTWFrZXMgaXQgcG9zc2libGUgdG8gYWRkIHByZWRlZmluZWQgdHlwZXMgZm9yIGdyb3VwcyBvZiBub2Rlcywgd2hpY2ggbWFrZSBpdCBwb3NzaWJsZSB0byBlYXNpbHkgY29udHJvbCBuZXN0aW5nIHJ1bGVzIGFuZCBpY29uIGZvciBlYWNoIGdyb3VwLlxcbiAgICovXFxuXFxuICAvKipcXG4gICAqIEFuIG9iamVjdCBzdG9yaW5nIGFsbCB0eXBlcyBhcyBrZXkgdmFsdWUgcGFpcnMsIHdoZXJlIHRoZSBrZXkgaXMgdGhlIHR5cGUgbmFtZSBhbmQgdGhlIHZhbHVlIGlzIGFuIG9iamVjdCB0aGF0IGNvdWxkIGNvbnRhaW4gZm9sbG93aW5nIGtleXMgKGFsbCBvcHRpb25hbCkuXFxuICAgKlxcbiAgICogKiBgbWF4X2NoaWxkcmVuYCB0aGUgbWF4aW11bSBudW1iZXIgb2YgaW1tZWRpYXRlIGNoaWxkcmVuIHRoaXMgbm9kZSB0eXBlIGNhbiBoYXZlLiBEbyBub3Qgc3BlY2lmeSBvciBzZXQgdG8gYC0xYCBmb3IgdW5saW1pdGVkLlxcbiAgICogKiBgbWF4X2RlcHRoYCB0aGUgbWF4aW11bSBudW1iZXIgb2YgbmVzdGluZyB0aGlzIG5vZGUgdHlwZSBjYW4gaGF2ZS4gQSB2YWx1ZSBvZiBgMWAgd291bGQgbWVhbiB0aGF0IHRoZSBub2RlIGNhbiBoYXZlIGNoaWxkcmVuLCBidXQgbm8gZ3JhbmRjaGlsZHJlbi4gRG8gbm90IHNwZWNpZnkgb3Igc2V0IHRvIGAtMWAgZm9yIHVubGltaXRlZC5cXG4gICAqICogYHZhbGlkX2NoaWxkcmVuYCBhbiBhcnJheSBvZiBub2RlIHR5cGUgc3RyaW5ncywgdGhhdCBub2RlcyBvZiB0aGlzIHR5cGUgY2FuIGhhdmUgYXMgY2hpbGRyZW4uIERvIG5vdCBzcGVjaWZ5IG9yIHNldCB0byBgLTFgIGZvciBubyBsaW1pdHMuXFxuICAgKiAqIGBpY29uYCBhIHN0cmluZyAtIGNhbiBiZSBhIHBhdGggdG8gYW4gaWNvbiBvciBhIGNsYXNzTmFtZSwgaWYgdXNpbmcgYW4gaW1hZ2UgdGhhdCBpcyBpbiB0aGUgY3VycmVudCBkaXJlY3RvcnkgdXNlIGEgYC4vYCBwcmVmaXgsIG90aGVyd2lzZSBpdCB3aWxsIGJlIGRldGVjdGVkIGFzIGEgY2xhc3MuIE9taXQgdG8gdXNlIHRoZSBkZWZhdWx0IGljb24gZnJvbSB5b3VyIHRoZW1lLlxcbiAgICogKiBgbGlfYXR0cmAgYW4gb2JqZWN0IG9mIHZhbHVlcyB3aGljaCB3aWxsIGJlIHVzZWQgdG8gYWRkIEhUTUwgYXR0cmlidXRlcyBvbiB0aGUgcmVzdWx0aW5nIExJIERPTSBub2RlIChtZXJnZWQgd2l0aCB0aGUgbm9kZSdzIG93biBkYXRhKVxcbiAgICogKiBgYV9hdHRyYCBhbiBvYmplY3Qgb2YgdmFsdWVzIHdoaWNoIHdpbGwgYmUgdXNlZCB0byBhZGQgSFRNTCBhdHRyaWJ1dGVzIG9uIHRoZSByZXN1bHRpbmcgQSBET00gbm9kZSAobWVyZ2VkIHdpdGggdGhlIG5vZGUncyBvd24gZGF0YSlcXG4gICAqXFxuICAgKiBUaGVyZSBhcmUgdHdvIHByZWRlZmluZWQgdHlwZXM6XFxuICAgKlxcbiAgICogKiBgI2AgcmVwcmVzZW50cyB0aGUgcm9vdCBvZiB0aGUgdHJlZSwgZm9yIGV4YW1wbGUgYG1heF9jaGlsZHJlbmAgd291bGQgY29udHJvbCB0aGUgbWF4aW11bSBudW1iZXIgb2Ygcm9vdCBub2Rlcy5cXG4gICAqICogYGRlZmF1bHRgIHJlcHJlc2VudHMgdGhlIGRlZmF1bHQgbm9kZSAtIGFueSBzZXR0aW5ncyBoZXJlIHdpbGwgYmUgYXBwbGllZCB0byBhbGwgbm9kZXMgdGhhdCBkbyBub3QgaGF2ZSBhIHR5cGUgc3BlY2lmaWVkLlxcbiAgICpcXG4gICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLnR5cGVzXFxuICAgKiBAcGx1Z2luIHR5cGVzXFxuICAgKi9cXG5cXG5cXG4gICQuanN0cmVlLmRlZmF1bHRzLnR5cGVzID0ge1xcbiAgICAnZGVmYXVsdCc6IHt9XFxuICB9O1xcbiAgJC5qc3RyZWUuZGVmYXVsdHMudHlwZXNbJC5qc3RyZWUucm9vdF0gPSB7fTtcXG5cXG4gICQuanN0cmVlLnBsdWdpbnMudHlwZXMgPSBmdW5jdGlvbiAob3B0aW9ucywgcGFyZW50KSB7XFxuICAgIHRoaXMuaW5pdCA9IGZ1bmN0aW9uIChlbCwgb3B0aW9ucykge1xcbiAgICAgIHZhciBpLCBqO1xcblxcbiAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMudHlwZXMgJiYgb3B0aW9ucy50eXBlc1snZGVmYXVsdCddKSB7XFxuICAgICAgICBmb3IgKGkgaW4gb3B0aW9ucy50eXBlcykge1xcbiAgICAgICAgICBpZiAoaSAhPT0gXFxcImRlZmF1bHRcXFwiICYmIGkgIT09ICQuanN0cmVlLnJvb3QgJiYgb3B0aW9ucy50eXBlcy5oYXNPd25Qcm9wZXJ0eShpKSkge1xcbiAgICAgICAgICAgIGZvciAoaiBpbiBvcHRpb25zLnR5cGVzWydkZWZhdWx0J10pIHtcXG4gICAgICAgICAgICAgIGlmIChvcHRpb25zLnR5cGVzWydkZWZhdWx0J10uaGFzT3duUHJvcGVydHkoaikgJiYgb3B0aW9ucy50eXBlc1tpXVtqXSA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgICAgICAgIG9wdGlvbnMudHlwZXNbaV1bal0gPSBvcHRpb25zLnR5cGVzWydkZWZhdWx0J11bal07XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHBhcmVudC5pbml0LmNhbGwodGhpcywgZWwsIG9wdGlvbnMpO1xcbiAgICAgIHRoaXMuX21vZGVsLmRhdGFbJC5qc3RyZWUucm9vdF0udHlwZSA9ICQuanN0cmVlLnJvb3Q7XFxuICAgIH07XFxuXFxuICAgIHRoaXMucmVmcmVzaCA9IGZ1bmN0aW9uIChza2lwX2xvYWRpbmcsIGZvcmdldF9zdGF0ZSkge1xcbiAgICAgIHBhcmVudC5yZWZyZXNoLmNhbGwodGhpcywgc2tpcF9sb2FkaW5nLCBmb3JnZXRfc3RhdGUpO1xcbiAgICAgIHRoaXMuX21vZGVsLmRhdGFbJC5qc3RyZWUucm9vdF0udHlwZSA9ICQuanN0cmVlLnJvb3Q7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuYmluZCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICB0aGlzLmVsZW1lbnQub24oJ21vZGVsLmpzdHJlZScsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcXG4gICAgICAgIHZhciBtID0gdGhpcy5fbW9kZWwuZGF0YSxcXG4gICAgICAgICAgICBkcGMgPSBkYXRhLm5vZGVzLFxcbiAgICAgICAgICAgIHQgPSB0aGlzLnNldHRpbmdzLnR5cGVzLFxcbiAgICAgICAgICAgIGksXFxuICAgICAgICAgICAgaixcXG4gICAgICAgICAgICBjID0gJ2RlZmF1bHQnLFxcbiAgICAgICAgICAgIGs7XFxuXFxuICAgICAgICBmb3IgKGkgPSAwLCBqID0gZHBjLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcbiAgICAgICAgICBjID0gJ2RlZmF1bHQnO1xcblxcbiAgICAgICAgICBpZiAobVtkcGNbaV1dLm9yaWdpbmFsICYmIG1bZHBjW2ldXS5vcmlnaW5hbC50eXBlICYmIHRbbVtkcGNbaV1dLm9yaWdpbmFsLnR5cGVdKSB7XFxuICAgICAgICAgICAgYyA9IG1bZHBjW2ldXS5vcmlnaW5hbC50eXBlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmIChtW2RwY1tpXV0uZGF0YSAmJiBtW2RwY1tpXV0uZGF0YS5qc3RyZWUgJiYgbVtkcGNbaV1dLmRhdGEuanN0cmVlLnR5cGUgJiYgdFttW2RwY1tpXV0uZGF0YS5qc3RyZWUudHlwZV0pIHtcXG4gICAgICAgICAgICBjID0gbVtkcGNbaV1dLmRhdGEuanN0cmVlLnR5cGU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgbVtkcGNbaV1dLnR5cGUgPSBjO1xcblxcbiAgICAgICAgICBpZiAobVtkcGNbaV1dLmljb24gPT09IHRydWUgJiYgdFtjXS5pY29uICE9PSB1bmRlZmluZWQpIHtcXG4gICAgICAgICAgICBtW2RwY1tpXV0uaWNvbiA9IHRbY10uaWNvbjtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAodFtjXS5saV9hdHRyICE9PSB1bmRlZmluZWQgJiYgX3R5cGVvZih0W2NdLmxpX2F0dHIpID09PSAnb2JqZWN0Jykge1xcbiAgICAgICAgICAgIGZvciAoayBpbiB0W2NdLmxpX2F0dHIpIHtcXG4gICAgICAgICAgICAgIGlmICh0W2NdLmxpX2F0dHIuaGFzT3duUHJvcGVydHkoaykpIHtcXG4gICAgICAgICAgICAgICAgaWYgKGsgPT09ICdpZCcpIHtcXG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtW2RwY1tpXV0ubGlfYXR0cltrXSA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgICAgICAgICAgbVtkcGNbaV1dLmxpX2F0dHJba10gPSB0W2NdLmxpX2F0dHJba107XFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoayA9PT0gJ2NsYXNzJykge1xcbiAgICAgICAgICAgICAgICAgIG1bZHBjW2ldXS5saV9hdHRyWydjbGFzcyddID0gdFtjXS5saV9hdHRyWydjbGFzcyddICsgJyAnICsgbVtkcGNbaV1dLmxpX2F0dHJbJ2NsYXNzJ107XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaWYgKHRbY10uYV9hdHRyICE9PSB1bmRlZmluZWQgJiYgX3R5cGVvZih0W2NdLmFfYXR0cikgPT09ICdvYmplY3QnKSB7XFxuICAgICAgICAgICAgZm9yIChrIGluIHRbY10uYV9hdHRyKSB7XFxuICAgICAgICAgICAgICBpZiAodFtjXS5hX2F0dHIuaGFzT3duUHJvcGVydHkoaykpIHtcXG4gICAgICAgICAgICAgICAgaWYgKGsgPT09ICdpZCcpIHtcXG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtW2RwY1tpXV0uYV9hdHRyW2tdID09PSB1bmRlZmluZWQpIHtcXG4gICAgICAgICAgICAgICAgICBtW2RwY1tpXV0uYV9hdHRyW2tdID0gdFtjXS5hX2F0dHJba107XFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoayA9PT0gJ2hyZWYnICYmIG1bZHBjW2ldXS5hX2F0dHJba10gPT09ICcjJykge1xcbiAgICAgICAgICAgICAgICAgIG1bZHBjW2ldXS5hX2F0dHJbJ2hyZWYnXSA9IHRbY10uYV9hdHRyWydocmVmJ107XFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoayA9PT0gJ2NsYXNzJykge1xcbiAgICAgICAgICAgICAgICAgIG1bZHBjW2ldXS5hX2F0dHJbJ2NsYXNzJ10gPSB0W2NdLmFfYXR0clsnY2xhc3MnXSArICcgJyArIG1bZHBjW2ldXS5hX2F0dHJbJ2NsYXNzJ107XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIG1bJC5qc3RyZWUucm9vdF0udHlwZSA9ICQuanN0cmVlLnJvb3Q7XFxuICAgICAgfSwgdGhpcykpO1xcbiAgICAgIHBhcmVudC5iaW5kLmNhbGwodGhpcyk7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuZ2V0X2pzb24gPSBmdW5jdGlvbiAob2JqLCBvcHRpb25zLCBmbGF0KSB7XFxuICAgICAgdmFyIGksXFxuICAgICAgICAgIGosXFxuICAgICAgICAgIG0gPSB0aGlzLl9tb2RlbC5kYXRhLFxcbiAgICAgICAgICBvcHQgPSBvcHRpb25zID8gJC5leHRlbmQodHJ1ZSwge30sIG9wdGlvbnMsIHtcXG4gICAgICAgIG5vX2lkOiBmYWxzZVxcbiAgICAgIH0pIDoge30sXFxuICAgICAgICAgIHRtcCA9IHBhcmVudC5nZXRfanNvbi5jYWxsKHRoaXMsIG9iaiwgb3B0LCBmbGF0KTtcXG5cXG4gICAgICBpZiAodG1wID09PSBmYWxzZSkge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoJC5pc0FycmF5KHRtcCkpIHtcXG4gICAgICAgIGZvciAoaSA9IDAsIGogPSB0bXAubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICAgIHRtcFtpXS50eXBlID0gdG1wW2ldLmlkICYmIG1bdG1wW2ldLmlkXSAmJiBtW3RtcFtpXS5pZF0udHlwZSA/IG1bdG1wW2ldLmlkXS50eXBlIDogXFxcImRlZmF1bHRcXFwiO1xcblxcbiAgICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLm5vX2lkKSB7XFxuICAgICAgICAgICAgZGVsZXRlIHRtcFtpXS5pZDtcXG5cXG4gICAgICAgICAgICBpZiAodG1wW2ldLmxpX2F0dHIgJiYgdG1wW2ldLmxpX2F0dHIuaWQpIHtcXG4gICAgICAgICAgICAgIGRlbGV0ZSB0bXBbaV0ubGlfYXR0ci5pZDtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaWYgKHRtcFtpXS5hX2F0dHIgJiYgdG1wW2ldLmFfYXR0ci5pZCkge1xcbiAgICAgICAgICAgICAgZGVsZXRlIHRtcFtpXS5hX2F0dHIuaWQ7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRtcC50eXBlID0gdG1wLmlkICYmIG1bdG1wLmlkXSAmJiBtW3RtcC5pZF0udHlwZSA/IG1bdG1wLmlkXS50eXBlIDogXFxcImRlZmF1bHRcXFwiO1xcblxcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5ub19pZCkge1xcbiAgICAgICAgICB0bXAgPSB0aGlzLl9kZWxldGVfaWRzKHRtcCk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiB0bXA7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuX2RlbGV0ZV9pZHMgPSBmdW5jdGlvbiAodG1wKSB7XFxuICAgICAgaWYgKCQuaXNBcnJheSh0bXApKSB7XFxuICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IHRtcC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG4gICAgICAgICAgdG1wW2ldID0gdGhpcy5fZGVsZXRlX2lkcyh0bXBbaV0pO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIHRtcDtcXG4gICAgICB9XFxuXFxuICAgICAgZGVsZXRlIHRtcC5pZDtcXG5cXG4gICAgICBpZiAodG1wLmxpX2F0dHIgJiYgdG1wLmxpX2F0dHIuaWQpIHtcXG4gICAgICAgIGRlbGV0ZSB0bXAubGlfYXR0ci5pZDtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRtcC5hX2F0dHIgJiYgdG1wLmFfYXR0ci5pZCkge1xcbiAgICAgICAgZGVsZXRlIHRtcC5hX2F0dHIuaWQ7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0bXAuY2hpbGRyZW4gJiYgJC5pc0FycmF5KHRtcC5jaGlsZHJlbikpIHtcXG4gICAgICAgIHRtcC5jaGlsZHJlbiA9IHRoaXMuX2RlbGV0ZV9pZHModG1wLmNoaWxkcmVuKTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHRtcDtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5jaGVjayA9IGZ1bmN0aW9uIChjaGssIG9iaiwgcGFyLCBwb3MsIG1vcmUpIHtcXG4gICAgICBpZiAocGFyZW50LmNoZWNrLmNhbGwodGhpcywgY2hrLCBvYmosIHBhciwgcG9zLCBtb3JlKSA9PT0gZmFsc2UpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgb2JqID0gb2JqICYmIG9iai5pZCA/IG9iaiA6IHRoaXMuZ2V0X25vZGUob2JqKTtcXG4gICAgICBwYXIgPSBwYXIgJiYgcGFyLmlkID8gcGFyIDogdGhpcy5nZXRfbm9kZShwYXIpO1xcbiAgICAgIHZhciBtID0gb2JqICYmIG9iai5pZCA/IG1vcmUgJiYgbW9yZS5vcmlnaW4gPyBtb3JlLm9yaWdpbiA6ICQuanN0cmVlLnJlZmVyZW5jZShvYmouaWQpIDogbnVsbCxcXG4gICAgICAgICAgdG1wLFxcbiAgICAgICAgICBkLFxcbiAgICAgICAgICBpLFxcbiAgICAgICAgICBqO1xcbiAgICAgIG0gPSBtICYmIG0uX21vZGVsICYmIG0uX21vZGVsLmRhdGEgPyBtLl9tb2RlbC5kYXRhIDogbnVsbDtcXG5cXG4gICAgICBzd2l0Y2ggKGNoaykge1xcbiAgICAgICAgY2FzZSBcXFwiY3JlYXRlX25vZGVcXFwiOlxcbiAgICAgICAgY2FzZSBcXFwibW92ZV9ub2RlXFxcIjpcXG4gICAgICAgIGNhc2UgXFxcImNvcHlfbm9kZVxcXCI6XFxuICAgICAgICAgIGlmIChjaGsgIT09ICdtb3ZlX25vZGUnIHx8ICQuaW5BcnJheShvYmouaWQsIHBhci5jaGlsZHJlbikgPT09IC0xKSB7XFxuICAgICAgICAgICAgdG1wID0gdGhpcy5nZXRfcnVsZXMocGFyKTtcXG5cXG4gICAgICAgICAgICBpZiAodG1wLm1heF9jaGlsZHJlbiAhPT0gdW5kZWZpbmVkICYmIHRtcC5tYXhfY2hpbGRyZW4gIT09IC0xICYmIHRtcC5tYXhfY2hpbGRyZW4gPT09IHBhci5jaGlsZHJlbi5sZW5ndGgpIHtcXG4gICAgICAgICAgICAgIHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yID0ge1xcbiAgICAgICAgICAgICAgICAnZXJyb3InOiAnY2hlY2snLFxcbiAgICAgICAgICAgICAgICAncGx1Z2luJzogJ3R5cGVzJyxcXG4gICAgICAgICAgICAgICAgJ2lkJzogJ3R5cGVzXzAxJyxcXG4gICAgICAgICAgICAgICAgJ3JlYXNvbic6ICdtYXhfY2hpbGRyZW4gcHJldmVudHMgZnVuY3Rpb246ICcgKyBjaGssXFxuICAgICAgICAgICAgICAgICdkYXRhJzogSlNPTi5zdHJpbmdpZnkoe1xcbiAgICAgICAgICAgICAgICAgICdjaGsnOiBjaGssXFxuICAgICAgICAgICAgICAgICAgJ3Bvcyc6IHBvcyxcXG4gICAgICAgICAgICAgICAgICAnb2JqJzogb2JqICYmIG9iai5pZCA/IG9iai5pZCA6IGZhbHNlLFxcbiAgICAgICAgICAgICAgICAgICdwYXInOiBwYXIgJiYgcGFyLmlkID8gcGFyLmlkIDogZmFsc2VcXG4gICAgICAgICAgICAgICAgfSlcXG4gICAgICAgICAgICAgIH07XFxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmICh0bXAudmFsaWRfY2hpbGRyZW4gIT09IHVuZGVmaW5lZCAmJiB0bXAudmFsaWRfY2hpbGRyZW4gIT09IC0xICYmICQuaW5BcnJheShvYmoudHlwZSB8fCAnZGVmYXVsdCcsIHRtcC52YWxpZF9jaGlsZHJlbikgPT09IC0xKSB7XFxuICAgICAgICAgICAgICB0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvciA9IHtcXG4gICAgICAgICAgICAgICAgJ2Vycm9yJzogJ2NoZWNrJyxcXG4gICAgICAgICAgICAgICAgJ3BsdWdpbic6ICd0eXBlcycsXFxuICAgICAgICAgICAgICAgICdpZCc6ICd0eXBlc18wMicsXFxuICAgICAgICAgICAgICAgICdyZWFzb24nOiAndmFsaWRfY2hpbGRyZW4gcHJldmVudHMgZnVuY3Rpb246ICcgKyBjaGssXFxuICAgICAgICAgICAgICAgICdkYXRhJzogSlNPTi5zdHJpbmdpZnkoe1xcbiAgICAgICAgICAgICAgICAgICdjaGsnOiBjaGssXFxuICAgICAgICAgICAgICAgICAgJ3Bvcyc6IHBvcyxcXG4gICAgICAgICAgICAgICAgICAnb2JqJzogb2JqICYmIG9iai5pZCA/IG9iai5pZCA6IGZhbHNlLFxcbiAgICAgICAgICAgICAgICAgICdwYXInOiBwYXIgJiYgcGFyLmlkID8gcGFyLmlkIDogZmFsc2VcXG4gICAgICAgICAgICAgICAgfSlcXG4gICAgICAgICAgICAgIH07XFxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmIChtICYmIG9iai5jaGlsZHJlbl9kICYmIG9iai5wYXJlbnRzKSB7XFxuICAgICAgICAgICAgICBkID0gMDtcXG5cXG4gICAgICAgICAgICAgIGZvciAoaSA9IDAsIGogPSBvYmouY2hpbGRyZW5fZC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG4gICAgICAgICAgICAgICAgZCA9IE1hdGgubWF4KGQsIG1bb2JqLmNoaWxkcmVuX2RbaV1dLnBhcmVudHMubGVuZ3RoKTtcXG4gICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgIGQgPSBkIC0gb2JqLnBhcmVudHMubGVuZ3RoICsgMTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaWYgKGQgPD0gMCB8fCBkID09PSB1bmRlZmluZWQpIHtcXG4gICAgICAgICAgICAgIGQgPSAxO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBkbyB7XFxuICAgICAgICAgICAgICBpZiAodG1wLm1heF9kZXB0aCAhPT0gdW5kZWZpbmVkICYmIHRtcC5tYXhfZGVwdGggIT09IC0xICYmIHRtcC5tYXhfZGVwdGggPCBkKSB7XFxuICAgICAgICAgICAgICAgIHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yID0ge1xcbiAgICAgICAgICAgICAgICAgICdlcnJvcic6ICdjaGVjaycsXFxuICAgICAgICAgICAgICAgICAgJ3BsdWdpbic6ICd0eXBlcycsXFxuICAgICAgICAgICAgICAgICAgJ2lkJzogJ3R5cGVzXzAzJyxcXG4gICAgICAgICAgICAgICAgICAncmVhc29uJzogJ21heF9kZXB0aCBwcmV2ZW50cyBmdW5jdGlvbjogJyArIGNoayxcXG4gICAgICAgICAgICAgICAgICAnZGF0YSc6IEpTT04uc3RyaW5naWZ5KHtcXG4gICAgICAgICAgICAgICAgICAgICdjaGsnOiBjaGssXFxuICAgICAgICAgICAgICAgICAgICAncG9zJzogcG9zLFxcbiAgICAgICAgICAgICAgICAgICAgJ29iaic6IG9iaiAmJiBvYmouaWQgPyBvYmouaWQgOiBmYWxzZSxcXG4gICAgICAgICAgICAgICAgICAgICdwYXInOiBwYXIgJiYgcGFyLmlkID8gcGFyLmlkIDogZmFsc2VcXG4gICAgICAgICAgICAgICAgICB9KVxcbiAgICAgICAgICAgICAgICB9O1xcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICBwYXIgPSB0aGlzLmdldF9ub2RlKHBhci5wYXJlbnQpO1xcbiAgICAgICAgICAgICAgdG1wID0gdGhpcy5nZXRfcnVsZXMocGFyKTtcXG4gICAgICAgICAgICAgIGQrKztcXG4gICAgICAgICAgICB9IHdoaWxlIChwYXIpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGJyZWFrO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgfTtcXG4gICAgLyoqXFxuICAgICAqIHVzZWQgdG8gcmV0cmlldmUgdGhlIHR5cGUgc2V0dGluZ3Mgb2JqZWN0IGZvciBhIG5vZGVcXG4gICAgICogQG5hbWUgZ2V0X3J1bGVzKG9iailcXG4gICAgICogQHBhcmFtIHttaXhlZH0gb2JqIHRoZSBub2RlIHRvIGZpbmQgdGhlIHJ1bGVzIGZvclxcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XFxuICAgICAqIEBwbHVnaW4gdHlwZXNcXG4gICAgICovXFxuXFxuXFxuICAgIHRoaXMuZ2V0X3J1bGVzID0gZnVuY3Rpb24gKG9iaikge1xcbiAgICAgIG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXG4gICAgICBpZiAoIW9iaikge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgdG1wID0gdGhpcy5nZXRfdHlwZShvYmosIHRydWUpO1xcblxcbiAgICAgIGlmICh0bXAubWF4X2RlcHRoID09PSB1bmRlZmluZWQpIHtcXG4gICAgICAgIHRtcC5tYXhfZGVwdGggPSAtMTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRtcC5tYXhfY2hpbGRyZW4gPT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgdG1wLm1heF9jaGlsZHJlbiA9IC0xO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodG1wLnZhbGlkX2NoaWxkcmVuID09PSB1bmRlZmluZWQpIHtcXG4gICAgICAgIHRtcC52YWxpZF9jaGlsZHJlbiA9IC0xO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gdG1wO1xcbiAgICB9O1xcbiAgICAvKipcXG4gICAgICogdXNlZCB0byByZXRyaWV2ZSB0aGUgdHlwZSBzdHJpbmcgb3Igc2V0dGluZ3Mgb2JqZWN0IGZvciBhIG5vZGVcXG4gICAgICogQG5hbWUgZ2V0X3R5cGUob2JqIFssIHJ1bGVzXSlcXG4gICAgICogQHBhcmFtIHttaXhlZH0gb2JqIHRoZSBub2RlIHRvIGZpbmQgdGhlIHJ1bGVzIGZvclxcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJ1bGVzIGlmIHNldCB0byBgdHJ1ZWAgaW5zdGVhZCBvZiBhIHN0cmluZyB0aGUgc2V0dGluZ3Mgb2JqZWN0IHdpbGwgYmUgcmV0dXJuZWRcXG4gICAgICogQHJldHVybiB7U3RyaW5nfE9iamVjdH1cXG4gICAgICogQHBsdWdpbiB0eXBlc1xcbiAgICAgKi9cXG5cXG5cXG4gICAgdGhpcy5nZXRfdHlwZSA9IGZ1bmN0aW9uIChvYmosIHJ1bGVzKSB7XFxuICAgICAgb2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xcbiAgICAgIHJldHVybiAhb2JqID8gZmFsc2UgOiBydWxlcyA/ICQuZXh0ZW5kKHtcXG4gICAgICAgICd0eXBlJzogb2JqLnR5cGVcXG4gICAgICB9LCB0aGlzLnNldHRpbmdzLnR5cGVzW29iai50eXBlXSkgOiBvYmoudHlwZTtcXG4gICAgfTtcXG4gICAgLyoqXFxuICAgICAqIHVzZWQgdG8gY2hhbmdlIGEgbm9kZSdzIHR5cGVcXG4gICAgICogQG5hbWUgc2V0X3R5cGUob2JqLCB0eXBlKVxcbiAgICAgKiBAcGFyYW0ge21peGVkfSBvYmogdGhlIG5vZGUgdG8gY2hhbmdlXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIHRoZSBuZXcgdHlwZVxcbiAgICAgKiBAcGx1Z2luIHR5cGVzXFxuICAgICAqL1xcblxcblxcbiAgICB0aGlzLnNldF90eXBlID0gZnVuY3Rpb24gKG9iaiwgdHlwZSkge1xcbiAgICAgIHZhciBtID0gdGhpcy5fbW9kZWwuZGF0YSxcXG4gICAgICAgICAgdCxcXG4gICAgICAgICAgdDEsXFxuICAgICAgICAgIHQyLFxcbiAgICAgICAgICBvbGRfdHlwZSxcXG4gICAgICAgICAgb2xkX2ljb24sXFxuICAgICAgICAgIGssXFxuICAgICAgICAgIGQsXFxuICAgICAgICAgIGE7XFxuXFxuICAgICAgaWYgKCQuaXNBcnJheShvYmopKSB7XFxuICAgICAgICBvYmogPSBvYmouc2xpY2UoKTtcXG5cXG4gICAgICAgIGZvciAodDEgPSAwLCB0MiA9IG9iai5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcXG4gICAgICAgICAgdGhpcy5zZXRfdHlwZShvYmpbdDFdLCB0eXBlKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgIH1cXG5cXG4gICAgICB0ID0gdGhpcy5zZXR0aW5ncy50eXBlcztcXG4gICAgICBvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XFxuXFxuICAgICAgaWYgKCF0W3R5cGVdIHx8ICFvYmopIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgZCA9IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKTtcXG5cXG4gICAgICBpZiAoZCAmJiBkLmxlbmd0aCkge1xcbiAgICAgICAgYSA9IGQuY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJyk7XFxuICAgICAgfVxcblxcbiAgICAgIG9sZF90eXBlID0gb2JqLnR5cGU7XFxuICAgICAgb2xkX2ljb24gPSB0aGlzLmdldF9pY29uKG9iaik7XFxuICAgICAgb2JqLnR5cGUgPSB0eXBlO1xcblxcbiAgICAgIGlmIChvbGRfaWNvbiA9PT0gdHJ1ZSB8fCAhdFtvbGRfdHlwZV0gfHwgdFtvbGRfdHlwZV0uaWNvbiAhPT0gdW5kZWZpbmVkICYmIG9sZF9pY29uID09PSB0W29sZF90eXBlXS5pY29uKSB7XFxuICAgICAgICB0aGlzLnNldF9pY29uKG9iaiwgdFt0eXBlXS5pY29uICE9PSB1bmRlZmluZWQgPyB0W3R5cGVdLmljb24gOiB0cnVlKTtcXG4gICAgICB9IC8vIHJlbW92ZSBvbGQgdHlwZSBwcm9wc1xcblxcblxcbiAgICAgIGlmICh0W29sZF90eXBlXSAmJiB0W29sZF90eXBlXS5saV9hdHRyICE9PSB1bmRlZmluZWQgJiYgX3R5cGVvZih0W29sZF90eXBlXS5saV9hdHRyKSA9PT0gJ29iamVjdCcpIHtcXG4gICAgICAgIGZvciAoayBpbiB0W29sZF90eXBlXS5saV9hdHRyKSB7XFxuICAgICAgICAgIGlmICh0W29sZF90eXBlXS5saV9hdHRyLmhhc093blByb3BlcnR5KGspKSB7XFxuICAgICAgICAgICAgaWYgKGsgPT09ICdpZCcpIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoayA9PT0gJ2NsYXNzJykge1xcbiAgICAgICAgICAgICAgbVtvYmouaWRdLmxpX2F0dHJbJ2NsYXNzJ10gPSAobVtvYmouaWRdLmxpX2F0dHJbJ2NsYXNzJ10gfHwgJycpLnJlcGxhY2UodFtvbGRfdHlwZV0ubGlfYXR0cltrXSwgJycpO1xcblxcbiAgICAgICAgICAgICAgaWYgKGQpIHtcXG4gICAgICAgICAgICAgICAgZC5yZW1vdmVDbGFzcyh0W29sZF90eXBlXS5saV9hdHRyW2tdKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1bb2JqLmlkXS5saV9hdHRyW2tdID09PSB0W29sZF90eXBlXS5saV9hdHRyW2tdKSB7XFxuICAgICAgICAgICAgICBtW29iai5pZF0ubGlfYXR0cltrXSA9IG51bGw7XFxuXFxuICAgICAgICAgICAgICBpZiAoZCkge1xcbiAgICAgICAgICAgICAgICBkLnJlbW92ZUF0dHIoayk7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0W29sZF90eXBlXSAmJiB0W29sZF90eXBlXS5hX2F0dHIgIT09IHVuZGVmaW5lZCAmJiBfdHlwZW9mKHRbb2xkX3R5cGVdLmFfYXR0cikgPT09ICdvYmplY3QnKSB7XFxuICAgICAgICBmb3IgKGsgaW4gdFtvbGRfdHlwZV0uYV9hdHRyKSB7XFxuICAgICAgICAgIGlmICh0W29sZF90eXBlXS5hX2F0dHIuaGFzT3duUHJvcGVydHkoaykpIHtcXG4gICAgICAgICAgICBpZiAoayA9PT0gJ2lkJykge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfSBlbHNlIGlmIChrID09PSAnY2xhc3MnKSB7XFxuICAgICAgICAgICAgICBtW29iai5pZF0uYV9hdHRyWydjbGFzcyddID0gKG1bb2JqLmlkXS5hX2F0dHJbJ2NsYXNzJ10gfHwgJycpLnJlcGxhY2UodFtvbGRfdHlwZV0uYV9hdHRyW2tdLCAnJyk7XFxuXFxuICAgICAgICAgICAgICBpZiAoYSkge1xcbiAgICAgICAgICAgICAgICBhLnJlbW92ZUNsYXNzKHRbb2xkX3R5cGVdLmFfYXR0cltrXSk7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSBlbHNlIGlmIChtW29iai5pZF0uYV9hdHRyW2tdID09PSB0W29sZF90eXBlXS5hX2F0dHJba10pIHtcXG4gICAgICAgICAgICAgIGlmIChrID09PSAnaHJlZicpIHtcXG4gICAgICAgICAgICAgICAgbVtvYmouaWRdLmFfYXR0cltrXSA9ICcjJztcXG5cXG4gICAgICAgICAgICAgICAgaWYgKGEpIHtcXG4gICAgICAgICAgICAgICAgICBhLmF0dHIoJ2hyZWYnLCAnIycpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICBkZWxldGUgbVtvYmouaWRdLmFfYXR0cltrXTtcXG5cXG4gICAgICAgICAgICAgICAgaWYgKGEpIHtcXG4gICAgICAgICAgICAgICAgICBhLnJlbW92ZUF0dHIoayk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9IC8vIGFkZCBuZXcgcHJvcHNcXG5cXG5cXG4gICAgICBpZiAodFt0eXBlXS5saV9hdHRyICE9PSB1bmRlZmluZWQgJiYgX3R5cGVvZih0W3R5cGVdLmxpX2F0dHIpID09PSAnb2JqZWN0Jykge1xcbiAgICAgICAgZm9yIChrIGluIHRbdHlwZV0ubGlfYXR0cikge1xcbiAgICAgICAgICBpZiAodFt0eXBlXS5saV9hdHRyLmhhc093blByb3BlcnR5KGspKSB7XFxuICAgICAgICAgICAgaWYgKGsgPT09ICdpZCcpIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobVtvYmouaWRdLmxpX2F0dHJba10gPT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgICAgICAgbVtvYmouaWRdLmxpX2F0dHJba10gPSB0W3R5cGVdLmxpX2F0dHJba107XFxuXFxuICAgICAgICAgICAgICBpZiAoZCkge1xcbiAgICAgICAgICAgICAgICBpZiAoayA9PT0gJ2NsYXNzJykge1xcbiAgICAgICAgICAgICAgICAgIGQuYWRkQ2xhc3ModFt0eXBlXS5saV9hdHRyW2tdKTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICBkLmF0dHIoaywgdFt0eXBlXS5saV9hdHRyW2tdKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoayA9PT0gJ2NsYXNzJykge1xcbiAgICAgICAgICAgICAgbVtvYmouaWRdLmxpX2F0dHJbJ2NsYXNzJ10gPSB0W3R5cGVdLmxpX2F0dHJba10gKyAnICcgKyBtW29iai5pZF0ubGlfYXR0clsnY2xhc3MnXTtcXG5cXG4gICAgICAgICAgICAgIGlmIChkKSB7XFxuICAgICAgICAgICAgICAgIGQuYWRkQ2xhc3ModFt0eXBlXS5saV9hdHRyW2tdKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRbdHlwZV0uYV9hdHRyICE9PSB1bmRlZmluZWQgJiYgX3R5cGVvZih0W3R5cGVdLmFfYXR0cikgPT09ICdvYmplY3QnKSB7XFxuICAgICAgICBmb3IgKGsgaW4gdFt0eXBlXS5hX2F0dHIpIHtcXG4gICAgICAgICAgaWYgKHRbdHlwZV0uYV9hdHRyLmhhc093blByb3BlcnR5KGspKSB7XFxuICAgICAgICAgICAgaWYgKGsgPT09ICdpZCcpIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobVtvYmouaWRdLmFfYXR0cltrXSA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgICAgICBtW29iai5pZF0uYV9hdHRyW2tdID0gdFt0eXBlXS5hX2F0dHJba107XFxuXFxuICAgICAgICAgICAgICBpZiAoYSkge1xcbiAgICAgICAgICAgICAgICBpZiAoayA9PT0gJ2NsYXNzJykge1xcbiAgICAgICAgICAgICAgICAgIGEuYWRkQ2xhc3ModFt0eXBlXS5hX2F0dHJba10pO1xcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgIGEuYXR0cihrLCB0W3R5cGVdLmFfYXR0cltrXSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGsgPT09ICdocmVmJyAmJiBtW29iai5pZF0uYV9hdHRyW2tdID09PSAnIycpIHtcXG4gICAgICAgICAgICAgIG1bb2JqLmlkXS5hX2F0dHJbJ2hyZWYnXSA9IHRbdHlwZV0uYV9hdHRyWydocmVmJ107XFxuXFxuICAgICAgICAgICAgICBpZiAoYSkge1xcbiAgICAgICAgICAgICAgICBhLmF0dHIoJ2hyZWYnLCB0W3R5cGVdLmFfYXR0clsnaHJlZiddKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGsgPT09ICdjbGFzcycpIHtcXG4gICAgICAgICAgICAgIG1bb2JqLmlkXS5hX2F0dHJbJ2NsYXNzJ10gPSB0W3R5cGVdLmFfYXR0clsnY2xhc3MnXSArICcgJyArIG1bb2JqLmlkXS5hX2F0dHJbJ2NsYXNzJ107XFxuXFxuICAgICAgICAgICAgICBpZiAoYSkge1xcbiAgICAgICAgICAgICAgICBhLmFkZENsYXNzKHRbdHlwZV0uYV9hdHRyW2tdKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHRydWU7XFxuICAgIH07XFxuICB9OyAvLyBpbmNsdWRlIHRoZSB0eXBlcyBwbHVnaW4gYnkgZGVmYXVsdFxcbiAgLy8gJC5qc3RyZWUuZGVmYXVsdHMucGx1Z2lucy5wdXNoKFxcXCJ0eXBlc1xcXCIpO1xcblxcbiAgLyoqXFxuICAgKiAjIyMgVW5pcXVlIHBsdWdpblxcbiAgICpcXG4gICAqIEVuZm9yY2VzIHRoYXQgbm8gbm9kZXMgd2l0aCB0aGUgc2FtZSBuYW1lIGNhbiBjb2V4aXN0IGFzIHNpYmxpbmdzLlxcbiAgICovXFxuXFxuICAvKipcXG4gICAqIHN0b3JlcyBhbGwgZGVmYXVsdHMgZm9yIHRoZSB1bmlxdWUgcGx1Z2luXFxuICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy51bmlxdWVcXG4gICAqIEBwbHVnaW4gdW5pcXVlXFxuICAgKi9cXG5cXG5cXG4gICQuanN0cmVlLmRlZmF1bHRzLnVuaXF1ZSA9IHtcXG4gICAgLyoqXFxuICAgICAqIEluZGljYXRlcyBpZiB0aGUgY29tcGFyaXNvbiBzaG91bGQgYmUgY2FzZSBzZW5zaXRpdmUuIERlZmF1bHQgaXMgYGZhbHNlYC5cXG4gICAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMudW5pcXVlLmNhc2Vfc2Vuc2l0aXZlXFxuICAgICAqIEBwbHVnaW4gdW5pcXVlXFxuICAgICAqL1xcbiAgICBjYXNlX3NlbnNpdGl2ZTogZmFsc2UsXFxuXFxuICAgIC8qKlxcbiAgICAgKiBBIGNhbGxiYWNrIGV4ZWN1dGVkIGluIHRoZSBpbnN0YW5jZSdzIHNjb3BlIHdoZW4gYSBuZXcgbm9kZSBpcyBjcmVhdGVkIGFuZCB0aGUgbmFtZSBpcyBhbHJlYWR5IHRha2VuLCB0aGUgdHdvIGFyZ3VtZW50cyBhcmUgdGhlIGNvbmZsaWN0aW5nIG5hbWUgYW5kIHRoZSBjb3VudGVyLiBUaGUgZGVmYXVsdCB3aWxsIHByb2R1Y2UgcmVzdWx0cyBsaWtlIGBOZXcgbm9kZSAoMilgLlxcbiAgICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy51bmlxdWUuZHVwbGljYXRlXFxuICAgICAqIEBwbHVnaW4gdW5pcXVlXFxuICAgICAqL1xcbiAgICBkdXBsaWNhdGU6IGZ1bmN0aW9uIGR1cGxpY2F0ZShuYW1lLCBjb3VudGVyKSB7XFxuICAgICAgcmV0dXJuIG5hbWUgKyAnICgnICsgY291bnRlciArICcpJztcXG4gICAgfVxcbiAgfTtcXG5cXG4gICQuanN0cmVlLnBsdWdpbnMudW5pcXVlID0gZnVuY3Rpb24gKG9wdGlvbnMsIHBhcmVudCkge1xcbiAgICB0aGlzLmNoZWNrID0gZnVuY3Rpb24gKGNoaywgb2JqLCBwYXIsIHBvcywgbW9yZSkge1xcbiAgICAgIGlmIChwYXJlbnQuY2hlY2suY2FsbCh0aGlzLCBjaGssIG9iaiwgcGFyLCBwb3MsIG1vcmUpID09PSBmYWxzZSkge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICBvYmogPSBvYmogJiYgb2JqLmlkID8gb2JqIDogdGhpcy5nZXRfbm9kZShvYmopO1xcbiAgICAgIHBhciA9IHBhciAmJiBwYXIuaWQgPyBwYXIgOiB0aGlzLmdldF9ub2RlKHBhcik7XFxuXFxuICAgICAgaWYgKCFwYXIgfHwgIXBhci5jaGlsZHJlbikge1xcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBuID0gY2hrID09PSBcXFwicmVuYW1lX25vZGVcXFwiID8gcG9zIDogb2JqLnRleHQsXFxuICAgICAgICAgIGMgPSBbXSxcXG4gICAgICAgICAgcyA9IHRoaXMuc2V0dGluZ3MudW5pcXVlLmNhc2Vfc2Vuc2l0aXZlLFxcbiAgICAgICAgICBtID0gdGhpcy5fbW9kZWwuZGF0YSxcXG4gICAgICAgICAgaSxcXG4gICAgICAgICAgajtcXG5cXG4gICAgICBmb3IgKGkgPSAwLCBqID0gcGFyLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcbiAgICAgICAgYy5wdXNoKHMgPyBtW3Bhci5jaGlsZHJlbltpXV0udGV4dCA6IG1bcGFyLmNoaWxkcmVuW2ldXS50ZXh0LnRvTG93ZXJDYXNlKCkpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIXMpIHtcXG4gICAgICAgIG4gPSBuLnRvTG93ZXJDYXNlKCk7XFxuICAgICAgfVxcblxcbiAgICAgIHN3aXRjaCAoY2hrKSB7XFxuICAgICAgICBjYXNlIFxcXCJkZWxldGVfbm9kZVxcXCI6XFxuICAgICAgICAgIHJldHVybiB0cnVlO1xcblxcbiAgICAgICAgY2FzZSBcXFwicmVuYW1lX25vZGVcXFwiOlxcbiAgICAgICAgICBpID0gJC5pbkFycmF5KG4sIGMpID09PSAtMSB8fCBvYmoudGV4dCAmJiBvYmoudGV4dFtzID8gJ3RvU3RyaW5nJyA6ICd0b0xvd2VyQ2FzZSddKCkgPT09IG47XFxuXFxuICAgICAgICAgIGlmICghaSkge1xcbiAgICAgICAgICAgIHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yID0ge1xcbiAgICAgICAgICAgICAgJ2Vycm9yJzogJ2NoZWNrJyxcXG4gICAgICAgICAgICAgICdwbHVnaW4nOiAndW5pcXVlJyxcXG4gICAgICAgICAgICAgICdpZCc6ICd1bmlxdWVfMDEnLFxcbiAgICAgICAgICAgICAgJ3JlYXNvbic6ICdDaGlsZCB3aXRoIG5hbWUgJyArIG4gKyAnIGFscmVhZHkgZXhpc3RzLiBQcmV2ZW50aW5nOiAnICsgY2hrLFxcbiAgICAgICAgICAgICAgJ2RhdGEnOiBKU09OLnN0cmluZ2lmeSh7XFxuICAgICAgICAgICAgICAgICdjaGsnOiBjaGssXFxuICAgICAgICAgICAgICAgICdwb3MnOiBwb3MsXFxuICAgICAgICAgICAgICAgICdvYmonOiBvYmogJiYgb2JqLmlkID8gb2JqLmlkIDogZmFsc2UsXFxuICAgICAgICAgICAgICAgICdwYXInOiBwYXIgJiYgcGFyLmlkID8gcGFyLmlkIDogZmFsc2VcXG4gICAgICAgICAgICAgIH0pXFxuICAgICAgICAgICAgfTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICByZXR1cm4gaTtcXG5cXG4gICAgICAgIGNhc2UgXFxcImNyZWF0ZV9ub2RlXFxcIjpcXG4gICAgICAgICAgaSA9ICQuaW5BcnJheShuLCBjKSA9PT0gLTE7XFxuXFxuICAgICAgICAgIGlmICghaSkge1xcbiAgICAgICAgICAgIHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yID0ge1xcbiAgICAgICAgICAgICAgJ2Vycm9yJzogJ2NoZWNrJyxcXG4gICAgICAgICAgICAgICdwbHVnaW4nOiAndW5pcXVlJyxcXG4gICAgICAgICAgICAgICdpZCc6ICd1bmlxdWVfMDQnLFxcbiAgICAgICAgICAgICAgJ3JlYXNvbic6ICdDaGlsZCB3aXRoIG5hbWUgJyArIG4gKyAnIGFscmVhZHkgZXhpc3RzLiBQcmV2ZW50aW5nOiAnICsgY2hrLFxcbiAgICAgICAgICAgICAgJ2RhdGEnOiBKU09OLnN0cmluZ2lmeSh7XFxuICAgICAgICAgICAgICAgICdjaGsnOiBjaGssXFxuICAgICAgICAgICAgICAgICdwb3MnOiBwb3MsXFxuICAgICAgICAgICAgICAgICdvYmonOiBvYmogJiYgb2JqLmlkID8gb2JqLmlkIDogZmFsc2UsXFxuICAgICAgICAgICAgICAgICdwYXInOiBwYXIgJiYgcGFyLmlkID8gcGFyLmlkIDogZmFsc2VcXG4gICAgICAgICAgICAgIH0pXFxuICAgICAgICAgICAgfTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICByZXR1cm4gaTtcXG5cXG4gICAgICAgIGNhc2UgXFxcImNvcHlfbm9kZVxcXCI6XFxuICAgICAgICAgIGkgPSAkLmluQXJyYXkobiwgYykgPT09IC0xO1xcblxcbiAgICAgICAgICBpZiAoIWkpIHtcXG4gICAgICAgICAgICB0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvciA9IHtcXG4gICAgICAgICAgICAgICdlcnJvcic6ICdjaGVjaycsXFxuICAgICAgICAgICAgICAncGx1Z2luJzogJ3VuaXF1ZScsXFxuICAgICAgICAgICAgICAnaWQnOiAndW5pcXVlXzAyJyxcXG4gICAgICAgICAgICAgICdyZWFzb24nOiAnQ2hpbGQgd2l0aCBuYW1lICcgKyBuICsgJyBhbHJlYWR5IGV4aXN0cy4gUHJldmVudGluZzogJyArIGNoayxcXG4gICAgICAgICAgICAgICdkYXRhJzogSlNPTi5zdHJpbmdpZnkoe1xcbiAgICAgICAgICAgICAgICAnY2hrJzogY2hrLFxcbiAgICAgICAgICAgICAgICAncG9zJzogcG9zLFxcbiAgICAgICAgICAgICAgICAnb2JqJzogb2JqICYmIG9iai5pZCA/IG9iai5pZCA6IGZhbHNlLFxcbiAgICAgICAgICAgICAgICAncGFyJzogcGFyICYmIHBhci5pZCA/IHBhci5pZCA6IGZhbHNlXFxuICAgICAgICAgICAgICB9KVxcbiAgICAgICAgICAgIH07XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgcmV0dXJuIGk7XFxuXFxuICAgICAgICBjYXNlIFxcXCJtb3ZlX25vZGVcXFwiOlxcbiAgICAgICAgICBpID0gb2JqLnBhcmVudCA9PT0gcGFyLmlkICYmICghbW9yZSB8fCAhbW9yZS5pc19tdWx0aSkgfHwgJC5pbkFycmF5KG4sIGMpID09PSAtMTtcXG5cXG4gICAgICAgICAgaWYgKCFpKSB7XFxuICAgICAgICAgICAgdGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IgPSB7XFxuICAgICAgICAgICAgICAnZXJyb3InOiAnY2hlY2snLFxcbiAgICAgICAgICAgICAgJ3BsdWdpbic6ICd1bmlxdWUnLFxcbiAgICAgICAgICAgICAgJ2lkJzogJ3VuaXF1ZV8wMycsXFxuICAgICAgICAgICAgICAncmVhc29uJzogJ0NoaWxkIHdpdGggbmFtZSAnICsgbiArICcgYWxyZWFkeSBleGlzdHMuIFByZXZlbnRpbmc6ICcgKyBjaGssXFxuICAgICAgICAgICAgICAnZGF0YSc6IEpTT04uc3RyaW5naWZ5KHtcXG4gICAgICAgICAgICAgICAgJ2Noayc6IGNoayxcXG4gICAgICAgICAgICAgICAgJ3Bvcyc6IHBvcyxcXG4gICAgICAgICAgICAgICAgJ29iaic6IG9iaiAmJiBvYmouaWQgPyBvYmouaWQgOiBmYWxzZSxcXG4gICAgICAgICAgICAgICAgJ3Bhcic6IHBhciAmJiBwYXIuaWQgPyBwYXIuaWQgOiBmYWxzZVxcbiAgICAgICAgICAgICAgfSlcXG4gICAgICAgICAgICB9O1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHJldHVybiBpO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5jcmVhdGVfbm9kZSA9IGZ1bmN0aW9uIChwYXIsIG5vZGUsIHBvcywgY2FsbGJhY2ssIGlzX2xvYWRlZCkge1xcbiAgICAgIGlmICghbm9kZSB8fCBub2RlLnRleHQgPT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgaWYgKHBhciA9PT0gbnVsbCkge1xcbiAgICAgICAgICBwYXIgPSAkLmpzdHJlZS5yb290O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcGFyID0gdGhpcy5nZXRfbm9kZShwYXIpO1xcblxcbiAgICAgICAgaWYgKCFwYXIpIHtcXG4gICAgICAgICAgcmV0dXJuIHBhcmVudC5jcmVhdGVfbm9kZS5jYWxsKHRoaXMsIHBhciwgbm9kZSwgcG9zLCBjYWxsYmFjaywgaXNfbG9hZGVkKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHBvcyA9IHBvcyA9PT0gdW5kZWZpbmVkID8gXFxcImxhc3RcXFwiIDogcG9zO1xcblxcbiAgICAgICAgaWYgKCFwb3MudG9TdHJpbmcoKS5tYXRjaCgvXihiZWZvcmV8YWZ0ZXIpJC8pICYmICFpc19sb2FkZWQgJiYgIXRoaXMuaXNfbG9hZGVkKHBhcikpIHtcXG4gICAgICAgICAgcmV0dXJuIHBhcmVudC5jcmVhdGVfbm9kZS5jYWxsKHRoaXMsIHBhciwgbm9kZSwgcG9zLCBjYWxsYmFjaywgaXNfbG9hZGVkKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICghbm9kZSkge1xcbiAgICAgICAgICBub2RlID0ge307XFxuICAgICAgICB9XFxuXFxuICAgICAgICB2YXIgdG1wLFxcbiAgICAgICAgICAgIG4sXFxuICAgICAgICAgICAgZHBjLFxcbiAgICAgICAgICAgIGksXFxuICAgICAgICAgICAgaixcXG4gICAgICAgICAgICBtID0gdGhpcy5fbW9kZWwuZGF0YSxcXG4gICAgICAgICAgICBzID0gdGhpcy5zZXR0aW5ncy51bmlxdWUuY2FzZV9zZW5zaXRpdmUsXFxuICAgICAgICAgICAgY2IgPSB0aGlzLnNldHRpbmdzLnVuaXF1ZS5kdXBsaWNhdGU7XFxuICAgICAgICBuID0gdG1wID0gdGhpcy5nZXRfc3RyaW5nKCdOZXcgbm9kZScpO1xcbiAgICAgICAgZHBjID0gW107XFxuXFxuICAgICAgICBmb3IgKGkgPSAwLCBqID0gcGFyLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcbiAgICAgICAgICBkcGMucHVzaChzID8gbVtwYXIuY2hpbGRyZW5baV1dLnRleHQgOiBtW3Bhci5jaGlsZHJlbltpXV0udGV4dC50b0xvd2VyQ2FzZSgpKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGkgPSAxO1xcblxcbiAgICAgICAgd2hpbGUgKCQuaW5BcnJheShzID8gbiA6IG4udG9Mb3dlckNhc2UoKSwgZHBjKSAhPT0gLTEpIHtcXG4gICAgICAgICAgbiA9IGNiLmNhbGwodGhpcywgdG1wLCArK2kpLnRvU3RyaW5nKCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBub2RlLnRleHQgPSBuO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gcGFyZW50LmNyZWF0ZV9ub2RlLmNhbGwodGhpcywgcGFyLCBub2RlLCBwb3MsIGNhbGxiYWNrLCBpc19sb2FkZWQpO1xcbiAgICB9O1xcbiAgfTsgLy8gaW5jbHVkZSB0aGUgdW5pcXVlIHBsdWdpbiBieSBkZWZhdWx0XFxuICAvLyAkLmpzdHJlZS5kZWZhdWx0cy5wbHVnaW5zLnB1c2goXFxcInVuaXF1ZVxcXCIpO1xcblxcbiAgLyoqXFxuICAgKiAjIyMgV2hvbGVyb3cgcGx1Z2luXFxuICAgKlxcbiAgICogTWFrZXMgZWFjaCBub2RlIGFwcGVhciBibG9jayBsZXZlbC4gTWFraW5nIHNlbGVjdGlvbiBlYXNpZXIuIE1heSBjYXVzZSBzbG93IGRvd24gZm9yIGxhcmdlIHRyZWVzIGluIG9sZCBicm93c2Vycy5cXG4gICAqL1xcblxcblxcbiAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xcbiAgZGl2LnNldEF0dHJpYnV0ZSgndW5zZWxlY3RhYmxlJywgJ29uJyk7XFxuICBkaXYuc2V0QXR0cmlidXRlKCdyb2xlJywgJ3ByZXNlbnRhdGlvbicpO1xcbiAgZGl2LmNsYXNzTmFtZSA9ICdqc3RyZWUtd2hvbGVyb3cnO1xcbiAgZGl2LmlubmVySFRNTCA9ICcmIzE2MDsnO1xcblxcbiAgJC5qc3RyZWUucGx1Z2lucy53aG9sZXJvdyA9IGZ1bmN0aW9uIChvcHRpb25zLCBwYXJlbnQpIHtcXG4gICAgdGhpcy5iaW5kID0gZnVuY3Rpb24gKCkge1xcbiAgICAgIHBhcmVudC5iaW5kLmNhbGwodGhpcyk7XFxuICAgICAgdGhpcy5lbGVtZW50Lm9uKCdyZWFkeS5qc3RyZWUgc2V0X3N0YXRlLmpzdHJlZScsICQucHJveHkoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdGhpcy5oaWRlX2RvdHMoKTtcXG4gICAgICB9LCB0aGlzKSkub24oXFxcImluaXQuanN0cmVlIGxvYWRpbmcuanN0cmVlIHJlYWR5LmpzdHJlZVxcXCIsICQucHJveHkoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgLy9kaXYuc3R5bGUuaGVpZ2h0ID0gdGhpcy5fZGF0YS5jb3JlLmxpX2hlaWdodCArICdweCc7XFxuICAgICAgICB0aGlzLmdldF9jb250YWluZXJfdWwoKS5hZGRDbGFzcygnanN0cmVlLXdob2xlcm93LXVsJyk7XFxuICAgICAgfSwgdGhpcykpLm9uKFxcXCJkZXNlbGVjdF9hbGwuanN0cmVlXFxcIiwgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xcbiAgICAgICAgdGhpcy5lbGVtZW50LmZpbmQoJy5qc3RyZWUtd2hvbGVyb3ctY2xpY2tlZCcpLnJlbW92ZUNsYXNzKCdqc3RyZWUtd2hvbGVyb3ctY2xpY2tlZCcpO1xcbiAgICAgIH0sIHRoaXMpKS5vbihcXFwiY2hhbmdlZC5qc3RyZWVcXFwiLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XFxuICAgICAgICB0aGlzLmVsZW1lbnQuZmluZCgnLmpzdHJlZS13aG9sZXJvdy1jbGlja2VkJykucmVtb3ZlQ2xhc3MoJ2pzdHJlZS13aG9sZXJvdy1jbGlja2VkJyk7XFxuICAgICAgICB2YXIgdG1wID0gZmFsc2UsXFxuICAgICAgICAgICAgaSxcXG4gICAgICAgICAgICBqO1xcblxcbiAgICAgICAgZm9yIChpID0gMCwgaiA9IGRhdGEuc2VsZWN0ZWQubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICAgIHRtcCA9IHRoaXMuZ2V0X25vZGUoZGF0YS5zZWxlY3RlZFtpXSwgdHJ1ZSk7XFxuXFxuICAgICAgICAgIGlmICh0bXAgJiYgdG1wLmxlbmd0aCkge1xcbiAgICAgICAgICAgIHRtcC5jaGlsZHJlbignLmpzdHJlZS13aG9sZXJvdycpLmFkZENsYXNzKCdqc3RyZWUtd2hvbGVyb3ctY2xpY2tlZCcpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfSwgdGhpcykpLm9uKFxcXCJvcGVuX25vZGUuanN0cmVlXFxcIiwgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xcbiAgICAgICAgdGhpcy5nZXRfbm9kZShkYXRhLm5vZGUsIHRydWUpLmZpbmQoJy5qc3RyZWUtY2xpY2tlZCcpLnBhcmVudCgpLmNoaWxkcmVuKCcuanN0cmVlLXdob2xlcm93JykuYWRkQ2xhc3MoJ2pzdHJlZS13aG9sZXJvdy1jbGlja2VkJyk7XFxuICAgICAgfSwgdGhpcykpLm9uKFxcXCJob3Zlcl9ub2RlLmpzdHJlZSBkZWhvdmVyX25vZGUuanN0cmVlXFxcIiwgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xcbiAgICAgICAgaWYgKGUudHlwZSA9PT0gXFxcImhvdmVyX25vZGVcXFwiICYmIHRoaXMuaXNfZGlzYWJsZWQoZGF0YS5ub2RlKSkge1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0aGlzLmdldF9ub2RlKGRhdGEubm9kZSwgdHJ1ZSkuY2hpbGRyZW4oJy5qc3RyZWUtd2hvbGVyb3cnKVtlLnR5cGUgPT09IFxcXCJob3Zlcl9ub2RlXFxcIiA/IFxcXCJhZGRDbGFzc1xcXCIgOiBcXFwicmVtb3ZlQ2xhc3NcXFwiXSgnanN0cmVlLXdob2xlcm93LWhvdmVyZWQnKTtcXG4gICAgICB9LCB0aGlzKSkub24oXFxcImNvbnRleHRtZW51LmpzdHJlZVxcXCIsIFxcXCIuanN0cmVlLXdob2xlcm93XFxcIiwgJC5wcm94eShmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgaWYgKHRoaXMuX2RhdGEuY29udGV4dG1lbnUpIHtcXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgICB2YXIgdG1wID0gJC5FdmVudCgnY29udGV4dG1lbnUnLCB7XFxuICAgICAgICAgICAgbWV0YUtleTogZS5tZXRhS2V5LFxcbiAgICAgICAgICAgIGN0cmxLZXk6IGUuY3RybEtleSxcXG4gICAgICAgICAgICBhbHRLZXk6IGUuYWx0S2V5LFxcbiAgICAgICAgICAgIHNoaWZ0S2V5OiBlLnNoaWZ0S2V5LFxcbiAgICAgICAgICAgIHBhZ2VYOiBlLnBhZ2VYLFxcbiAgICAgICAgICAgIHBhZ2VZOiBlLnBhZ2VZXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgICAkKGUuY3VycmVudFRhcmdldCkuY2xvc2VzdChcXFwiLmpzdHJlZS1ub2RlXFxcIikuY2hpbGRyZW4oXFxcIi5qc3RyZWUtYW5jaG9yXFxcIikuZmlyc3QoKS50cmlnZ2VyKHRtcCk7XFxuICAgICAgICB9XFxuICAgICAgfSwgdGhpcykpXFxuICAgICAgLyohXFxuICAgICAgLm9uKFxcXCJtb3VzZWRvd24uanN0cmVlIHRvdWNoc3RhcnQuanN0cmVlXFxcIiwgXFxcIi5qc3RyZWUtd2hvbGVyb3dcXFwiLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgIFxcdFxcdGlmKGUudGFyZ2V0ID09PSBlLmN1cnJlbnRUYXJnZXQpIHtcXG4gICAgICBcXHRcXHRcXHR2YXIgYSA9ICQoZS5jdXJyZW50VGFyZ2V0KS5jbG9zZXN0KFxcXCIuanN0cmVlLW5vZGVcXFwiKS5jaGlsZHJlbihcXFwiLmpzdHJlZS1hbmNob3JcXFwiKTtcXG4gICAgICBcXHRcXHRcXHRlLnRhcmdldCA9IGFbMF07XFxuICAgICAgXFx0XFx0XFx0YS50cmlnZ2VyKGUpO1xcbiAgICAgIFxcdFxcdH1cXG4gICAgICBcXHR9KVxcbiAgICAgICovXFxuICAgICAgLm9uKFxcXCJjbGljay5qc3RyZWVcXFwiLCBcXFwiLmpzdHJlZS13aG9sZXJvd1xcXCIsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xcbiAgICAgICAgdmFyIHRtcCA9ICQuRXZlbnQoJ2NsaWNrJywge1xcbiAgICAgICAgICBtZXRhS2V5OiBlLm1ldGFLZXksXFxuICAgICAgICAgIGN0cmxLZXk6IGUuY3RybEtleSxcXG4gICAgICAgICAgYWx0S2V5OiBlLmFsdEtleSxcXG4gICAgICAgICAgc2hpZnRLZXk6IGUuc2hpZnRLZXlcXG4gICAgICAgIH0pO1xcbiAgICAgICAgJChlLmN1cnJlbnRUYXJnZXQpLmNsb3Nlc3QoXFxcIi5qc3RyZWUtbm9kZVxcXCIpLmNoaWxkcmVuKFxcXCIuanN0cmVlLWFuY2hvclxcXCIpLmZpcnN0KCkudHJpZ2dlcih0bXApLmZvY3VzKCk7XFxuICAgICAgfSkub24oXFxcImRibGNsaWNrLmpzdHJlZVxcXCIsIFxcXCIuanN0cmVlLXdob2xlcm93XFxcIiwgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XFxuICAgICAgICB2YXIgdG1wID0gJC5FdmVudCgnZGJsY2xpY2snLCB7XFxuICAgICAgICAgIG1ldGFLZXk6IGUubWV0YUtleSxcXG4gICAgICAgICAgY3RybEtleTogZS5jdHJsS2V5LFxcbiAgICAgICAgICBhbHRLZXk6IGUuYWx0S2V5LFxcbiAgICAgICAgICBzaGlmdEtleTogZS5zaGlmdEtleVxcbiAgICAgICAgfSk7XFxuICAgICAgICAkKGUuY3VycmVudFRhcmdldCkuY2xvc2VzdChcXFwiLmpzdHJlZS1ub2RlXFxcIikuY2hpbGRyZW4oXFxcIi5qc3RyZWUtYW5jaG9yXFxcIikuZmlyc3QoKS50cmlnZ2VyKHRtcCkuZm9jdXMoKTtcXG4gICAgICB9KS5vbihcXFwiY2xpY2suanN0cmVlXFxcIiwgXFxcIi5qc3RyZWUtbGVhZiA+IC5qc3RyZWUtb2NsXFxcIiwgJC5wcm94eShmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcXG4gICAgICAgIHZhciB0bXAgPSAkLkV2ZW50KCdjbGljaycsIHtcXG4gICAgICAgICAgbWV0YUtleTogZS5tZXRhS2V5LFxcbiAgICAgICAgICBjdHJsS2V5OiBlLmN0cmxLZXksXFxuICAgICAgICAgIGFsdEtleTogZS5hbHRLZXksXFxuICAgICAgICAgIHNoaWZ0S2V5OiBlLnNoaWZ0S2V5XFxuICAgICAgICB9KTtcXG4gICAgICAgICQoZS5jdXJyZW50VGFyZ2V0KS5jbG9zZXN0KFxcXCIuanN0cmVlLW5vZGVcXFwiKS5jaGlsZHJlbihcXFwiLmpzdHJlZS1hbmNob3JcXFwiKS5maXJzdCgpLnRyaWdnZXIodG1wKS5mb2N1cygpO1xcbiAgICAgIH0sIHRoaXMpKS5vbihcXFwibW91c2VvdmVyLmpzdHJlZVxcXCIsIFxcXCIuanN0cmVlLXdob2xlcm93LCAuanN0cmVlLWljb25cXFwiLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xcblxcbiAgICAgICAgaWYgKCF0aGlzLmlzX2Rpc2FibGVkKGUuY3VycmVudFRhcmdldCkpIHtcXG4gICAgICAgICAgdGhpcy5ob3Zlcl9ub2RlKGUuY3VycmVudFRhcmdldCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfSwgdGhpcykpLm9uKFxcXCJtb3VzZWxlYXZlLmpzdHJlZVxcXCIsIFxcXCIuanN0cmVlLW5vZGVcXFwiLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICB0aGlzLmRlaG92ZXJfbm9kZShlLmN1cnJlbnRUYXJnZXQpO1xcbiAgICAgIH0sIHRoaXMpKTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy50ZWFyZG93biA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy53aG9sZXJvdykge1xcbiAgICAgICAgdGhpcy5lbGVtZW50LmZpbmQoXFxcIi5qc3RyZWUtd2hvbGVyb3dcXFwiKS5yZW1vdmUoKTtcXG4gICAgICB9XFxuXFxuICAgICAgcGFyZW50LnRlYXJkb3duLmNhbGwodGhpcyk7XFxuICAgIH07XFxuXFxuICAgIHRoaXMucmVkcmF3X25vZGUgPSBmdW5jdGlvbiAob2JqLCBkZWVwLCBjYWxsYmFjaywgZm9yY2VfcmVuZGVyKSB7XFxuICAgICAgb2JqID0gcGFyZW50LnJlZHJhd19ub2RlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuXFxuICAgICAgaWYgKG9iaikge1xcbiAgICAgICAgdmFyIHRtcCA9IGRpdi5jbG9uZU5vZGUodHJ1ZSk7IC8vdG1wLnN0eWxlLmhlaWdodCA9IHRoaXMuX2RhdGEuY29yZS5saV9oZWlnaHQgKyAncHgnO1xcblxcbiAgICAgICAgaWYgKCQuaW5BcnJheShvYmouaWQsIHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZCkgIT09IC0xKSB7XFxuICAgICAgICAgIHRtcC5jbGFzc05hbWUgKz0gJyBqc3RyZWUtd2hvbGVyb3ctY2xpY2tlZCc7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAodGhpcy5fZGF0YS5jb3JlLmZvY3VzZWQgJiYgdGhpcy5fZGF0YS5jb3JlLmZvY3VzZWQgPT09IG9iai5pZCkge1xcbiAgICAgICAgICB0bXAuY2xhc3NOYW1lICs9ICcganN0cmVlLXdob2xlcm93LWhvdmVyZWQnO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgb2JqLmluc2VydEJlZm9yZSh0bXAsIG9iai5jaGlsZE5vZGVzWzBdKTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIG9iajtcXG4gICAgfTtcXG4gIH07IC8vIGluY2x1ZGUgdGhlIHdob2xlcm93IHBsdWdpbiBieSBkZWZhdWx0XFxuICAvLyAkLmpzdHJlZS5kZWZhdWx0cy5wbHVnaW5zLnB1c2goXFxcIndob2xlcm93XFxcIik7XFxuXFxuXFxuICBpZiAoZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50ICYmIE9iamVjdCAmJiBPYmplY3QuY3JlYXRlKSB7XFxuICAgIHZhciBwcm90byA9IE9iamVjdC5jcmVhdGUoSFRNTEVsZW1lbnQucHJvdG90eXBlKTtcXG5cXG4gICAgcHJvdG8uY3JlYXRlZENhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xcbiAgICAgIHZhciBjID0ge1xcbiAgICAgICAgY29yZToge30sXFxuICAgICAgICBwbHVnaW5zOiBbXVxcbiAgICAgIH0sXFxuICAgICAgICAgIGk7XFxuXFxuICAgICAgZm9yIChpIGluICQuanN0cmVlLnBsdWdpbnMpIHtcXG4gICAgICAgIGlmICgkLmpzdHJlZS5wbHVnaW5zLmhhc093blByb3BlcnR5KGkpICYmIHRoaXMuYXR0cmlidXRlc1tpXSkge1xcbiAgICAgICAgICBjLnBsdWdpbnMucHVzaChpKTtcXG5cXG4gICAgICAgICAgaWYgKHRoaXMuZ2V0QXR0cmlidXRlKGkpICYmIEpTT04ucGFyc2UodGhpcy5nZXRBdHRyaWJ1dGUoaSkpKSB7XFxuICAgICAgICAgICAgY1tpXSA9IEpTT04ucGFyc2UodGhpcy5nZXRBdHRyaWJ1dGUoaSkpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGZvciAoaSBpbiAkLmpzdHJlZS5kZWZhdWx0cy5jb3JlKSB7XFxuICAgICAgICBpZiAoJC5qc3RyZWUuZGVmYXVsdHMuY29yZS5oYXNPd25Qcm9wZXJ0eShpKSAmJiB0aGlzLmF0dHJpYnV0ZXNbaV0pIHtcXG4gICAgICAgICAgYy5jb3JlW2ldID0gSlNPTi5wYXJzZSh0aGlzLmdldEF0dHJpYnV0ZShpKSkgfHwgdGhpcy5nZXRBdHRyaWJ1dGUoaSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgICQodGhpcykuanN0cmVlKGMpO1xcbiAgICB9OyAvLyBwcm90by5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sgPSBmdW5jdGlvbiAobmFtZSwgcHJldmlvdXMsIHZhbHVlKSB7IH07XFxuXFxuXFxuICAgIHRyeSB7XFxuICAgICAgZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KFxcXCJ2YWthdGEtanN0cmVlXFxcIiwge1xcbiAgICAgICAgcHJvdG90eXBlOiBwcm90b1xcbiAgICAgIH0pO1xcbiAgICB9IGNhdGNoIChpZ25vcmUpIHt9XFxuICB9XFxufSk7XCIiLCIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzcmMpIHtcblx0ZnVuY3Rpb24gbG9nKGVycm9yKSB7XG5cdFx0KHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiKVxuXHRcdCYmIChjb25zb2xlLmVycm9yIHx8IGNvbnNvbGUubG9nKShcIltTY3JpcHQgTG9hZGVyXVwiLCBlcnJvcik7XG5cdH1cblxuXHQvLyBDaGVjayBmb3IgSUUgPTwgOFxuXHRmdW5jdGlvbiBpc0lFKCkge1xuXHRcdHJldHVybiB0eXBlb2YgYXR0YWNoRXZlbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGFkZEV2ZW50TGlzdGVuZXIgPT09IFwidW5kZWZpbmVkXCI7XG5cdH1cblxuXHR0cnkge1xuXHRcdGlmICh0eXBlb2YgZXhlY1NjcmlwdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpc0lFKCkpIHtcblx0XHRcdGV4ZWNTY3JpcHQoc3JjKTtcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiBldmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHRldmFsLmNhbGwobnVsbCwgc3JjKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bG9nKFwiRXZhbEVycm9yOiBObyBldmFsIGZ1bmN0aW9uIGF2YWlsYWJsZVwiKTtcblx0XHR9XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0bG9nKGVycm9yKTtcblx0fVxufVxuIiwicmVxdWlyZShcIiEhL2hvbWUvb3Nib3hlcy93b3Jrc3BhY2UvbWxhYi5sb2NhbC50ZXN0L25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qc1wiKShyZXF1aXJlKFwiISEvaG9tZS9vc2JveGVzL3dvcmtzcGFjZS9tbGFiLmxvY2FsLnRlc3Qvbm9kZV9tb2R1bGVzL3Jhdy1sb2FkZXIvaW5kZXguanMhL2hvbWUvb3Nib3hlcy93b3Jrc3BhY2UvbWxhYi5sb2NhbC50ZXN0L25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTQtMCEvaG9tZS9vc2JveGVzL3dvcmtzcGFjZS9tbGFiLmxvY2FsLnRlc3QvYXNzZXRzL2pzL2pzdHJlZS0zLjMuMy5qc1wiKStcIlxcblxcbi8vIFNDUklQVC1MT0FERVIgRk9PVEVSXFxuLy8jIHNvdXJjZVVSTD1zY3JpcHQ6Ly8vaG9tZS9vc2JveGVzL3dvcmtzcGFjZS9tbGFiLmxvY2FsLnRlc3Qvbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMlM0Y/cmVmLS00LTAhL2hvbWUvb3Nib3hlcy93b3Jrc3BhY2UvbWxhYi5sb2NhbC50ZXN0L2Fzc2V0cy9qcy9qc3RyZWUtMy4zLjMuanNcIikiXSwic291cmNlUm9vdCI6IiJ9