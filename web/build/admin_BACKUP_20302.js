/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/build/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./assets/js/admin.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./assets/js/admin.js":
/*!****************************!*\
  !*** ./assets/js/admin.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* 
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
__webpack_require__(/*! script-loader!./jstree-3.3.3.js */ "./node_modules/script-loader/index.js!./assets/js/jstree-3.3.3.js");

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./node_modules/babel-loader/lib/index.js?!./assets/js/jstree-3.3.3.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/raw-loader!./node_modules/babel-loader/lib??ref--4-0!./assets/js/jstree-3.3.3.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*globals jQuery, define, module, exports, require, window, document, postMessage */\n(function (factory) {\n  \"use strict\";\n\n  if (typeof define === 'function' && define.amd) {\n    define(['jquery'], factory);\n  } else if (typeof module !== 'undefined' && module.exports) {\n    module.exports = factory(require('jquery'));\n  } else {\n    factory(jQuery);\n  }\n})(function ($, undefined) {\n  \"use strict\";\n  /*!\n   * jsTree 3.3.3\n   * http://jstree.com/\n   *\n   * Copyright (c) 2014 Ivan Bozhanov (http://vakata.com)\n   *\n   * Licensed same as jquery - under the terms of the MIT License\n   *   http://www.opensource.org/licenses/mit-license.php\n   */\n\n  /*!\n   * if using jslint please allow for the jQuery global and use following options:\n   * jslint: loopfunc: true, browser: true, ass: true, bitwise: true, continue: true, nomen: true, plusplus: true, regexp: true, unparam: true, todo: true, white: true\n   */\n\n  /*jshint -W083 */\n  // prevent another load? maybe there is a better way?\n\n  if ($.jstree) {\n    return;\n  }\n  /**\n   * ### jsTree core functionality\n   */\n  // internal variables\n\n\n  var instance_counter = 0,\n      ccp_node = false,\n      ccp_mode = false,\n      ccp_inst = false,\n      themes_loaded = [],\n      src = $('script:last').attr('src'),\n      document = window.document; // local variable is always faster to access then a global\n\n  /**\n   * holds all jstree related functions and variables, including the actual class and methods to create, access and manipulate instances.\n   * @name $.jstree\n   */\n\n  $.jstree = {\n    /**\n     * specifies the jstree version in use\n     * @name $.jstree.version\n     */\n    version: '3.3.3',\n\n    /**\n     * holds all the default options used when creating new instances\n     * @name $.jstree.defaults\n     */\n    defaults: {\n      /**\n       * configure which plugins will be active on an instance. Should be an array of strings, where each element is a plugin name. The default is `[]`\n       * @name $.jstree.defaults.plugins\n       */\n      plugins: []\n    },\n\n    /**\n     * stores all loaded jstree plugins (used internally)\n     * @name $.jstree.plugins\n     */\n    plugins: {},\n    path: src && src.indexOf('/') !== -1 ? src.replace(/\\/[^\\/]+$/, '') : '',\n    idregex: /[\\\\:&!^|()\\[\\]<>@*'+~#\";.,=\\- \\/${}%?`]/g,\n    root: '#'\n  };\n  /**\n   * creates a jstree instance\n   * @name $.jstree.create(el [, options])\n   * @param {DOMElement|jQuery|String} el the element to create the instance on, can be jQuery extended or a selector\n   * @param {Object} options options for this instance (extends `$.jstree.defaults`)\n   * @return {jsTree} the new instance\n   */\n\n  $.jstree.create = function (el, options) {\n    var tmp = new $.jstree.core(++instance_counter),\n        opt = options;\n    options = $.extend(true, {}, $.jstree.defaults, options);\n\n    if (opt && opt.plugins) {\n      options.plugins = opt.plugins;\n    }\n\n    $.each(options.plugins, function (i, k) {\n      if (i !== 'core') {\n        tmp = tmp.plugin(k, options[k]);\n      }\n    });\n    $(el).data('jstree', tmp);\n    tmp.init(el, options);\n    return tmp;\n  };\n  /**\n   * remove all traces of jstree from the DOM and destroy all instances\n   * @name $.jstree.destroy()\n   */\n\n\n  $.jstree.destroy = function () {\n    $('.jstree:jstree').jstree('destroy');\n    $(document).off('.jstree');\n  };\n  /**\n   * the jstree class constructor, used only internally\n   * @private\n   * @name $.jstree.core(id)\n   * @param {Number} id this instance's index\n   */\n\n\n  $.jstree.core = function (id) {\n    this._id = id;\n    this._cnt = 0;\n    this._wrk = null;\n    this._data = {\n      core: {\n        themes: {\n          name: false,\n          dots: false,\n          icons: false,\n          ellipsis: false\n        },\n        selected: [],\n        last_error: {},\n        working: false,\n        worker_queue: [],\n        focused: null\n      }\n    };\n  };\n  /**\n   * get a reference to an existing instance\n   *\n   * __Examples__\n   *\n   *\t// provided a container with an ID of \"tree\", and a nested node with an ID of \"branch\"\n   *\t// all of there will return the same instance\n   *\t$.jstree.reference('tree');\n   *\t$.jstree.reference('#tree');\n   *\t$.jstree.reference($('#tree'));\n   *\t$.jstree.reference(document.getElementByID('tree'));\n   *\t$.jstree.reference('branch');\n   *\t$.jstree.reference('#branch');\n   *\t$.jstree.reference($('#branch'));\n   *\t$.jstree.reference(document.getElementByID('branch'));\n   *\n   * @name $.jstree.reference(needle)\n   * @param {DOMElement|jQuery|String} needle\n   * @return {jsTree|null} the instance or `null` if not found\n   */\n\n\n  $.jstree.reference = function (needle) {\n    var tmp = null,\n        obj = null;\n\n    if (needle && needle.id && (!needle.tagName || !needle.nodeType)) {\n      needle = needle.id;\n    }\n\n    if (!obj || !obj.length) {\n      try {\n        obj = $(needle);\n      } catch (ignore) {}\n    }\n\n    if (!obj || !obj.length) {\n      try {\n        obj = $('#' + needle.replace($.jstree.idregex, '\\\\$&'));\n      } catch (ignore) {}\n    }\n\n    if (obj && obj.length && (obj = obj.closest('.jstree')).length && (obj = obj.data('jstree'))) {\n      tmp = obj;\n    } else {\n      $('.jstree').each(function () {\n        var inst = $(this).data('jstree');\n\n        if (inst && inst._model.data[needle]) {\n          tmp = inst;\n          return false;\n        }\n      });\n    }\n\n    return tmp;\n  };\n  /**\n   * Create an instance, get an instance or invoke a command on a instance.\n   *\n   * If there is no instance associated with the current node a new one is created and `arg` is used to extend `$.jstree.defaults` for this new instance. There would be no return value (chaining is not broken).\n   *\n   * If there is an existing instance and `arg` is a string the command specified by `arg` is executed on the instance, with any additional arguments passed to the function. If the function returns a value it will be returned (chaining could break depending on function).\n   *\n   * If there is an existing instance and `arg` is not a string the instance itself is returned (similar to `$.jstree.reference`).\n   *\n   * In any other case - nothing is returned and chaining is not broken.\n   *\n   * __Examples__\n   *\n   *\t$('#tree1').jstree(); // creates an instance\n   *\t$('#tree2').jstree({ plugins : [] }); // create an instance with some options\n   *\t$('#tree1').jstree('open_node', '#branch_1'); // call a method on an existing instance, passing additional arguments\n   *\t$('#tree2').jstree(); // get an existing instance (or create an instance)\n   *\t$('#tree2').jstree(true); // get an existing instance (will not create new instance)\n   *\t$('#branch_1').jstree().select_node('#branch_1'); // get an instance (using a nested element and call a method)\n   *\n   * @name $().jstree([arg])\n   * @param {String|Object} arg\n   * @return {Mixed}\n   */\n\n\n  $.fn.jstree = function (arg) {\n    // check for string argument\n    var is_method = typeof arg === 'string',\n        args = Array.prototype.slice.call(arguments, 1),\n        result = null;\n\n    if (arg === true && !this.length) {\n      return false;\n    }\n\n    this.each(function () {\n      // get the instance (if there is one) and method (if it exists)\n      var instance = $.jstree.reference(this),\n          method = is_method && instance ? instance[arg] : null; // if calling a method, and method is available - execute on the instance\n\n      result = is_method && method ? method.apply(instance, args) : null; // if there is no instance and no method is being called - create one\n\n      if (!instance && !is_method && (arg === undefined || $.isPlainObject(arg))) {\n        $.jstree.create(this, arg);\n      } // if there is an instance and no method is called - return the instance\n\n\n      if (instance && !is_method || arg === true) {\n        result = instance || false;\n      } // if there was a method call which returned a result - break and return the value\n\n\n      if (result !== null && result !== undefined) {\n        return false;\n      }\n    }); // if there was a method call with a valid return value - return that, otherwise continue the chain\n\n    return result !== null && result !== undefined ? result : this;\n  };\n  /**\n   * used to find elements containing an instance\n   *\n   * __Examples__\n   *\n   *\t$('div:jstree').each(function () {\n   *\t\t$(this).jstree('destroy');\n   *\t});\n   *\n   * @name $(':jstree')\n   * @return {jQuery}\n   */\n\n\n  $.expr.pseudos.jstree = $.expr.createPseudo(function (search) {\n    return function (a) {\n      return $(a).hasClass('jstree') && $(a).data('jstree') !== undefined;\n    };\n  });\n  /**\n   * stores all defaults for the core\n   * @name $.jstree.defaults.core\n   */\n\n  $.jstree.defaults.core = {\n    /**\n     * data configuration\n     *\n     * If left as `false` the HTML inside the jstree container element is used to populate the tree (that should be an unordered list with list items).\n     *\n     * You can also pass in a HTML string or a JSON array here.\n     *\n     * It is possible to pass in a standard jQuery-like AJAX config and jstree will automatically determine if the response is JSON or HTML and use that to populate the tree.\n     * In addition to the standard jQuery ajax options here you can suppy functions for `data` and `url`, the functions will be run in the current instance's scope and a param will be passed indicating which node is being loaded, the return value of those functions will be used.\n     *\n     * The last option is to specify a function, that function will receive the node being loaded as argument and a second param which is a function which should be called with the result.\n     *\n     * __Examples__\n     *\n     *\t// AJAX\n     *\t$('#tree').jstree({\n     *\t\t'core' : {\n     *\t\t\t'data' : {\n     *\t\t\t\t'url' : '/get/children/',\n     *\t\t\t\t'data' : function (node) {\n     *\t\t\t\t\treturn { 'id' : node.id };\n     *\t\t\t\t}\n     *\t\t\t}\n     *\t\t});\n     *\n     *\t// direct data\n     *\t$('#tree').jstree({\n     *\t\t'core' : {\n     *\t\t\t'data' : [\n     *\t\t\t\t'Simple root node',\n     *\t\t\t\t{\n     *\t\t\t\t\t'id' : 'node_2',\n     *\t\t\t\t\t'text' : 'Root node with options',\n     *\t\t\t\t\t'state' : { 'opened' : true, 'selected' : true },\n     *\t\t\t\t\t'children' : [ { 'text' : 'Child 1' }, 'Child 2']\n     *\t\t\t\t}\n     *\t\t\t]\n     *\t\t}\n     *\t});\n     *\n     *\t// function\n     *\t$('#tree').jstree({\n     *\t\t'core' : {\n     *\t\t\t'data' : function (obj, callback) {\n     *\t\t\t\tcallback.call(this, ['Root 1', 'Root 2']);\n     *\t\t\t}\n     *\t\t});\n     *\n     * @name $.jstree.defaults.core.data\n     */\n    data: false,\n\n    /**\n     * configure the various strings used throughout the tree\n     *\n     * You can use an object where the key is the string you need to replace and the value is your replacement.\n     * Another option is to specify a function which will be called with an argument of the needed string and should return the replacement.\n     * If left as `false` no replacement is made.\n     *\n     * __Examples__\n     *\n     *\t$('#tree').jstree({\n     *\t\t'core' : {\n     *\t\t\t'strings' : {\n     *\t\t\t\t'Loading ...' : 'Please wait ...'\n     *\t\t\t}\n     *\t\t}\n     *\t});\n     *\n     * @name $.jstree.defaults.core.strings\n     */\n    strings: false,\n\n    /**\n     * determines what happens when a user tries to modify the structure of the tree\n     * If left as `false` all operations like create, rename, delete, move or copy are prevented.\n     * You can set this to `true` to allow all interactions or use a function to have better control.\n     *\n     * __Examples__\n     *\n     *\t$('#tree').jstree({\n     *\t\t'core' : {\n     *\t\t\t'check_callback' : function (operation, node, node_parent, node_position, more) {\n     *\t\t\t\t// operation can be 'create_node', 'rename_node', 'delete_node', 'move_node' or 'copy_node'\n     *\t\t\t\t// in case of 'rename_node' node_position is filled with the new node name\n     *\t\t\t\treturn operation === 'rename_node' ? true : false;\n     *\t\t\t}\n     *\t\t}\n     *\t});\n     *\n     * @name $.jstree.defaults.core.check_callback\n     */\n    check_callback: false,\n\n    /**\n     * a callback called with a single object parameter in the instance's scope when something goes wrong (operation prevented, ajax failed, etc)\n     * @name $.jstree.defaults.core.error\n     */\n    error: $.noop,\n\n    /**\n     * the open / close animation duration in milliseconds - set this to `false` to disable the animation (default is `200`)\n     * @name $.jstree.defaults.core.animation\n     */\n    animation: 200,\n\n    /**\n     * a boolean indicating if multiple nodes can be selected\n     * @name $.jstree.defaults.core.multiple\n     */\n    multiple: true,\n\n    /**\n     * theme configuration object\n     * @name $.jstree.defaults.core.themes\n     */\n    themes: {\n      /**\n       * the name of the theme to use (if left as `false` the default theme is used)\n       * @name $.jstree.defaults.core.themes.name\n       */\n      name: false,\n\n      /**\n       * the URL of the theme's CSS file, leave this as `false` if you have manually included the theme CSS (recommended). You can set this to `true` too which will try to autoload the theme.\n       * @name $.jstree.defaults.core.themes.url\n       */\n      url: false,\n\n      /**\n       * the location of all jstree themes - only used if `url` is set to `true`\n       * @name $.jstree.defaults.core.themes.dir\n       */\n      dir: false,\n\n      /**\n       * a boolean indicating if connecting dots are shown\n       * @name $.jstree.defaults.core.themes.dots\n       */\n      dots: true,\n\n      /**\n       * a boolean indicating if node icons are shown\n       * @name $.jstree.defaults.core.themes.icons\n       */\n      icons: true,\n\n      /**\n       * a boolean indicating if node ellipsis should be shown - this only works with a fixed with on the container\n       * @name $.jstree.defaults.core.themes.ellipsis\n       */\n      ellipsis: false,\n\n      /**\n       * a boolean indicating if the tree background is striped\n       * @name $.jstree.defaults.core.themes.stripes\n       */\n      stripes: false,\n\n      /**\n       * a string (or boolean `false`) specifying the theme variant to use (if the theme supports variants)\n       * @name $.jstree.defaults.core.themes.variant\n       */\n      variant: false,\n\n      /**\n       * a boolean specifying if a reponsive version of the theme should kick in on smaller screens (if the theme supports it). Defaults to `false`.\n       * @name $.jstree.defaults.core.themes.responsive\n       */\n      responsive: false\n    },\n\n    /**\n     * if left as `true` all parents of all selected nodes will be opened once the tree loads (so that all selected nodes are visible to the user)\n     * @name $.jstree.defaults.core.expand_selected_onload\n     */\n    expand_selected_onload: true,\n\n    /**\n     * if left as `true` web workers will be used to parse incoming JSON data where possible, so that the UI will not be blocked by large requests. Workers are however about 30% slower. Defaults to `true`\n     * @name $.jstree.defaults.core.worker\n     */\n    worker: true,\n\n    /**\n     * Force node text to plain text (and escape HTML). Defaults to `false`\n     * @name $.jstree.defaults.core.force_text\n     */\n    force_text: false,\n\n    /**\n     * Should the node should be toggled if the text is double clicked . Defaults to `true`\n     * @name $.jstree.defaults.core.dblclick_toggle\n     */\n    dblclick_toggle: true\n  };\n  $.jstree.core.prototype = {\n    /**\n     * used to decorate an instance with a plugin. Used internally.\n     * @private\n     * @name plugin(deco [, opts])\n     * @param  {String} deco the plugin to decorate with\n     * @param  {Object} opts options for the plugin\n     * @return {jsTree}\n     */\n    plugin: function plugin(deco, opts) {\n      var Child = $.jstree.plugins[deco];\n\n      if (Child) {\n        this._data[deco] = {};\n        Child.prototype = this;\n        return new Child(opts, this);\n      }\n\n      return this;\n    },\n\n    /**\n     * initialize the instance. Used internally.\n     * @private\n     * @name init(el, optons)\n     * @param {DOMElement|jQuery|String} el the element we are transforming\n     * @param {Object} options options for this instance\n     * @trigger init.jstree, loading.jstree, loaded.jstree, ready.jstree, changed.jstree\n     */\n    init: function init(el, options) {\n      this._model = {\n        data: {},\n        changed: [],\n        force_full_redraw: false,\n        redraw_timeout: false,\n        default_state: {\n          loaded: true,\n          opened: false,\n          selected: false,\n          disabled: false\n        }\n      };\n      this._model.data[$.jstree.root] = {\n        id: $.jstree.root,\n        parent: null,\n        parents: [],\n        children: [],\n        children_d: [],\n        state: {\n          loaded: false\n        }\n      };\n      this.element = $(el).addClass('jstree jstree-' + this._id);\n      this.settings = options;\n      this._data.core.ready = false;\n      this._data.core.loaded = false;\n      this._data.core.rtl = this.element.css(\"direction\") === \"rtl\";\n      this.element[this._data.core.rtl ? 'addClass' : 'removeClass'](\"jstree-rtl\");\n      this.element.attr('role', 'tree');\n\n      if (this.settings.core.multiple) {\n        this.element.attr('aria-multiselectable', true);\n      }\n\n      if (!this.element.attr('tabindex')) {\n        this.element.attr('tabindex', '0');\n      }\n\n      this.bind();\n      /**\n       * triggered after all events are bound\n       * @event\n       * @name init.jstree\n       */\n\n      this.trigger(\"init\");\n      this._data.core.original_container_html = this.element.find(\" > ul > li\").clone(true);\n\n      this._data.core.original_container_html.find(\"li\").addBack().contents().filter(function () {\n        return this.nodeType === 3 && (!this.nodeValue || /^\\s+$/.test(this.nodeValue));\n      }).remove();\n\n      this.element.html(\"<\" + \"ul class='jstree-container-ul jstree-children' role='group'><\" + \"li id='j\" + this._id + \"_loading' class='jstree-initial-node jstree-loading jstree-leaf jstree-last' role='tree-item'><i class='jstree-icon jstree-ocl'></i><\" + \"a class='jstree-anchor' href='#'><i class='jstree-icon jstree-themeicon-hidden'></i>\" + this.get_string(\"Loading ...\") + \"</a></li></ul>\");\n      this.element.attr('aria-activedescendant', 'j' + this._id + '_loading');\n      this._data.core.li_height = this.get_container_ul().children(\"li\").first().height() || 24;\n      this._data.core.node = this._create_prototype_node();\n      /**\n       * triggered after the loading text is shown and before loading starts\n       * @event\n       * @name loading.jstree\n       */\n\n      this.trigger(\"loading\");\n      this.load_node($.jstree.root);\n    },\n\n    /**\n     * destroy an instance\n     * @name destroy()\n     * @param  {Boolean} keep_html if not set to `true` the container will be emptied, otherwise the current DOM elements will be kept intact\n     */\n    destroy: function destroy(keep_html) {\n      if (this._wrk) {\n        try {\n          window.URL.revokeObjectURL(this._wrk);\n          this._wrk = null;\n        } catch (ignore) {}\n      }\n\n      if (!keep_html) {\n        this.element.empty();\n      }\n\n      this.teardown();\n    },\n\n    /**\n     * Create prototype node\n     */\n    _create_prototype_node: function _create_prototype_node() {\n      var _node = document.createElement('LI'),\n          _temp1,\n          _temp2;\n\n      _node.setAttribute('role', 'treeitem');\n\n      _temp1 = document.createElement('I');\n      _temp1.className = 'jstree-icon jstree-ocl';\n\n      _temp1.setAttribute('role', 'presentation');\n\n      _node.appendChild(_temp1);\n\n      _temp1 = document.createElement('A');\n      _temp1.className = 'jstree-anchor';\n\n      _temp1.setAttribute('href', '#');\n\n      _temp1.setAttribute('tabindex', '-1');\n\n      _temp2 = document.createElement('I');\n      _temp2.className = 'jstree-icon jstree-themeicon';\n\n      _temp2.setAttribute('role', 'presentation');\n\n      _temp1.appendChild(_temp2);\n\n      _node.appendChild(_temp1);\n\n      _temp1 = _temp2 = null;\n      return _node;\n    },\n\n    /**\n     * part of the destroying of an instance. Used internally.\n     * @private\n     * @name teardown()\n     */\n    teardown: function teardown() {\n      this.unbind();\n      this.element.removeClass('jstree').removeData('jstree').find(\"[class^='jstree']\").addBack().attr(\"class\", function () {\n        return this.className.replace(/jstree[^ ]*|$/ig, '');\n      });\n      this.element = null;\n    },\n\n    /**\n     * bind all events. Used internally.\n     * @private\n     * @name bind()\n     */\n    bind: function bind() {\n      var word = '',\n          tout = null,\n          was_click = 0;\n      this.element.on(\"dblclick.jstree\", function (e) {\n        if (e.target.tagName && e.target.tagName.toLowerCase() === \"input\") {\n          return true;\n        }\n\n        if (document.selection && document.selection.empty) {\n          document.selection.empty();\n        } else {\n          if (window.getSelection) {\n            var sel = window.getSelection();\n\n            try {\n              sel.removeAllRanges();\n              sel.collapse();\n            } catch (ignore) {}\n          }\n        }\n      }).on(\"mousedown.jstree\", $.proxy(function (e) {\n        if (e.target === this.element[0]) {\n          e.preventDefault(); // prevent losing focus when clicking scroll arrows (FF, Chrome)\n\n          was_click = +new Date(); // ie does not allow to prevent losing focus\n        }\n      }, this)).on(\"mousedown.jstree\", \".jstree-ocl\", function (e) {\n        e.preventDefault(); // prevent any node inside from losing focus when clicking the open/close icon\n      }).on(\"click.jstree\", \".jstree-ocl\", $.proxy(function (e) {\n        this.toggle_node(e.target);\n      }, this)).on(\"dblclick.jstree\", \".jstree-anchor\", $.proxy(function (e) {\n        if (e.target.tagName && e.target.tagName.toLowerCase() === \"input\") {\n          return true;\n        }\n\n        if (this.settings.core.dblclick_toggle) {\n          this.toggle_node(e.target);\n        }\n      }, this)).on(\"click.jstree\", \".jstree-anchor\", $.proxy(function (e) {\n        e.preventDefault();\n\n        if (e.currentTarget !== document.activeElement) {\n          $(e.currentTarget).focus();\n        }\n\n        this.activate_node(e.currentTarget, e);\n      }, this)).on('keydown.jstree', '.jstree-anchor', $.proxy(function (e) {\n        if (e.target.tagName && e.target.tagName.toLowerCase() === \"input\") {\n          return true;\n        }\n\n        if (e.which !== 32 && e.which !== 13 && (e.shiftKey || e.ctrlKey || e.altKey || e.metaKey)) {\n          return true;\n        }\n\n        var o = null;\n\n        if (this._data.core.rtl) {\n          if (e.which === 37) {\n            e.which = 39;\n          } else if (e.which === 39) {\n            e.which = 37;\n          }\n        }\n\n        switch (e.which) {\n          case 32:\n            // aria defines space only with Ctrl\n            if (e.ctrlKey) {\n              e.type = \"click\";\n              $(e.currentTarget).trigger(e);\n            }\n\n            break;\n\n          case 13:\n            // enter\n            e.type = \"click\";\n            $(e.currentTarget).trigger(e);\n            break;\n\n          case 37:\n            // left\n            e.preventDefault();\n\n            if (this.is_open(e.currentTarget)) {\n              this.close_node(e.currentTarget);\n            } else {\n              o = this.get_parent(e.currentTarget);\n\n              if (o && o.id !== $.jstree.root) {\n                this.get_node(o, true).children('.jstree-anchor').focus();\n              }\n            }\n\n            break;\n\n          case 38:\n            // up\n            e.preventDefault();\n            o = this.get_prev_dom(e.currentTarget);\n\n            if (o && o.length) {\n              o.children('.jstree-anchor').focus();\n            }\n\n            break;\n\n          case 39:\n            // right\n            e.preventDefault();\n\n            if (this.is_closed(e.currentTarget)) {\n              this.open_node(e.currentTarget, function (o) {\n                this.get_node(o, true).children('.jstree-anchor').focus();\n              });\n            } else if (this.is_open(e.currentTarget)) {\n              o = this.get_node(e.currentTarget, true).children('.jstree-children')[0];\n\n              if (o) {\n                $(this._firstChild(o)).children('.jstree-anchor').focus();\n              }\n            }\n\n            break;\n\n          case 40:\n            // down\n            e.preventDefault();\n            o = this.get_next_dom(e.currentTarget);\n\n            if (o && o.length) {\n              o.children('.jstree-anchor').focus();\n            }\n\n            break;\n\n          case 106:\n            // aria defines * on numpad as open_all - not very common\n            this.open_all();\n            break;\n\n          case 36:\n            // home\n            e.preventDefault();\n            o = this._firstChild(this.get_container_ul()[0]);\n\n            if (o) {\n              $(o).children('.jstree-anchor').filter(':visible').focus();\n            }\n\n            break;\n\n          case 35:\n            // end\n            e.preventDefault();\n            this.element.find('.jstree-anchor').filter(':visible').last().focus();\n            break;\n\n          case 113:\n            // f2 - safe to include - if check_callback is false it will fail\n            e.preventDefault();\n            this.edit(e.currentTarget);\n            break;\n\n          default:\n            break;\n\n          /*!\n          // delete\n          case 46:\n          \te.preventDefault();\n          \to = this.get_node(e.currentTarget);\n          \tif(o && o.id && o.id !== $.jstree.root) {\n          \t\to = this.is_selected(o) ? this.get_selected() : o;\n          \t\tthis.delete_node(o);\n          \t}\n          \tbreak;\n          \t*/\n        }\n      }, this)).on(\"load_node.jstree\", $.proxy(function (e, data) {\n        if (data.status) {\n          if (data.node.id === $.jstree.root && !this._data.core.loaded) {\n            this._data.core.loaded = true;\n\n            if (this._firstChild(this.get_container_ul()[0])) {\n              this.element.attr('aria-activedescendant', this._firstChild(this.get_container_ul()[0]).id);\n            }\n            /**\n             * triggered after the root node is loaded for the first time\n             * @event\n             * @name loaded.jstree\n             */\n\n\n            this.trigger(\"loaded\");\n          }\n\n          if (!this._data.core.ready) {\n            setTimeout($.proxy(function () {\n              if (this.element && !this.get_container_ul().find('.jstree-loading').length) {\n                this._data.core.ready = true;\n\n                if (this._data.core.selected.length) {\n                  if (this.settings.core.expand_selected_onload) {\n                    var tmp = [],\n                        i,\n                        j;\n\n                    for (i = 0, j = this._data.core.selected.length; i < j; i++) {\n                      tmp = tmp.concat(this._model.data[this._data.core.selected[i]].parents);\n                    }\n\n                    tmp = $.vakata.array_unique(tmp);\n\n                    for (i = 0, j = tmp.length; i < j; i++) {\n                      this.open_node(tmp[i], false, 0);\n                    }\n                  }\n\n                  this.trigger('changed', {\n                    'action': 'ready',\n                    'selected': this._data.core.selected\n                  });\n                }\n                /**\n                 * triggered after all nodes are finished loading\n                 * @event\n                 * @name ready.jstree\n                 */\n\n\n                this.trigger(\"ready\");\n              }\n            }, this), 0);\n          }\n        }\n      }, this)) // quick searching when the tree is focused\n      .on('keypress.jstree', $.proxy(function (e) {\n        if (e.target.tagName && e.target.tagName.toLowerCase() === \"input\") {\n          return true;\n        }\n\n        if (tout) {\n          clearTimeout(tout);\n        }\n\n        tout = setTimeout(function () {\n          word = '';\n        }, 500);\n        var chr = String.fromCharCode(e.which).toLowerCase(),\n            col = this.element.find('.jstree-anchor').filter(':visible'),\n            ind = col.index(document.activeElement) || 0,\n            end = false;\n        word += chr; // match for whole word from current node down (including the current node)\n\n        if (word.length > 1) {\n          col.slice(ind).each($.proxy(function (i, v) {\n            if ($(v).text().toLowerCase().indexOf(word) === 0) {\n              $(v).focus();\n              end = true;\n              return false;\n            }\n          }, this));\n\n          if (end) {\n            return;\n          } // match for whole word from the beginning of the tree\n\n\n          col.slice(0, ind).each($.proxy(function (i, v) {\n            if ($(v).text().toLowerCase().indexOf(word) === 0) {\n              $(v).focus();\n              end = true;\n              return false;\n            }\n          }, this));\n\n          if (end) {\n            return;\n          }\n        } // list nodes that start with that letter (only if word consists of a single char)\n\n\n        if (new RegExp('^' + chr.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&') + '+$').test(word)) {\n          // search for the next node starting with that letter\n          col.slice(ind + 1).each($.proxy(function (i, v) {\n            if ($(v).text().toLowerCase().charAt(0) === chr) {\n              $(v).focus();\n              end = true;\n              return false;\n            }\n          }, this));\n\n          if (end) {\n            return;\n          } // search from the beginning\n\n\n          col.slice(0, ind + 1).each($.proxy(function (i, v) {\n            if ($(v).text().toLowerCase().charAt(0) === chr) {\n              $(v).focus();\n              end = true;\n              return false;\n            }\n          }, this));\n\n          if (end) {\n            return;\n          }\n        }\n      }, this)) // THEME RELATED\n      .on(\"init.jstree\", $.proxy(function () {\n        var s = this.settings.core.themes;\n        this._data.core.themes.dots = s.dots;\n        this._data.core.themes.stripes = s.stripes;\n        this._data.core.themes.icons = s.icons;\n        this._data.core.themes.ellipsis = s.ellipsis;\n        this.set_theme(s.name || \"default\", s.url);\n        this.set_theme_variant(s.variant);\n      }, this)).on(\"loading.jstree\", $.proxy(function () {\n        this[this._data.core.themes.dots ? \"show_dots\" : \"hide_dots\"]();\n        this[this._data.core.themes.icons ? \"show_icons\" : \"hide_icons\"]();\n        this[this._data.core.themes.stripes ? \"show_stripes\" : \"hide_stripes\"]();\n        this[this._data.core.themes.ellipsis ? \"show_ellipsis\" : \"hide_ellipsis\"]();\n      }, this)).on('blur.jstree', '.jstree-anchor', $.proxy(function (e) {\n        this._data.core.focused = null;\n        $(e.currentTarget).filter('.jstree-hovered').mouseleave();\n        this.element.attr('tabindex', '0');\n      }, this)).on('focus.jstree', '.jstree-anchor', $.proxy(function (e) {\n        var tmp = this.get_node(e.currentTarget);\n\n        if (tmp && tmp.id) {\n          this._data.core.focused = tmp.id;\n        }\n\n        this.element.find('.jstree-hovered').not(e.currentTarget).mouseleave();\n        $(e.currentTarget).mouseenter();\n        this.element.attr('tabindex', '-1');\n      }, this)).on('focus.jstree', $.proxy(function () {\n        if (+new Date() - was_click > 500 && !this._data.core.focused) {\n          was_click = 0;\n          var act = this.get_node(this.element.attr('aria-activedescendant'), true);\n\n          if (act) {\n            act.find('> .jstree-anchor').focus();\n          }\n        }\n      }, this)).on('mouseenter.jstree', '.jstree-anchor', $.proxy(function (e) {\n        this.hover_node(e.currentTarget);\n      }, this)).on('mouseleave.jstree', '.jstree-anchor', $.proxy(function (e) {\n        this.dehover_node(e.currentTarget);\n      }, this));\n    },\n\n    /**\n     * part of the destroying of an instance. Used internally.\n     * @private\n     * @name unbind()\n     */\n    unbind: function unbind() {\n      this.element.off('.jstree');\n      $(document).off('.jstree-' + this._id);\n    },\n\n    /**\n     * trigger an event. Used internally.\n     * @private\n     * @name trigger(ev [, data])\n     * @param  {String} ev the name of the event to trigger\n     * @param  {Object} data additional data to pass with the event\n     */\n    trigger: function trigger(ev, data) {\n      if (!data) {\n        data = {};\n      }\n\n      data.instance = this;\n      this.element.triggerHandler(ev.replace('.jstree', '') + '.jstree', data);\n    },\n\n    /**\n     * returns the jQuery extended instance container\n     * @name get_container()\n     * @return {jQuery}\n     */\n    get_container: function get_container() {\n      return this.element;\n    },\n\n    /**\n     * returns the jQuery extended main UL node inside the instance container. Used internally.\n     * @private\n     * @name get_container_ul()\n     * @return {jQuery}\n     */\n    get_container_ul: function get_container_ul() {\n      return this.element.children(\".jstree-children\").first();\n    },\n\n    /**\n     * gets string replacements (localization). Used internally.\n     * @private\n     * @name get_string(key)\n     * @param  {String} key\n     * @return {String}\n     */\n    get_string: function get_string(key) {\n      var a = this.settings.core.strings;\n\n      if ($.isFunction(a)) {\n        return a.call(this, key);\n      }\n\n      if (a && a[key]) {\n        return a[key];\n      }\n\n      return key;\n    },\n\n    /**\n     * gets the first child of a DOM node. Used internally.\n     * @private\n     * @name _firstChild(dom)\n     * @param  {DOMElement} dom\n     * @return {DOMElement}\n     */\n    _firstChild: function _firstChild(dom) {\n      dom = dom ? dom.firstChild : null;\n\n      while (dom !== null && dom.nodeType !== 1) {\n        dom = dom.nextSibling;\n      }\n\n      return dom;\n    },\n\n    /**\n     * gets the next sibling of a DOM node. Used internally.\n     * @private\n     * @name _nextSibling(dom)\n     * @param  {DOMElement} dom\n     * @return {DOMElement}\n     */\n    _nextSibling: function _nextSibling(dom) {\n      dom = dom ? dom.nextSibling : null;\n\n      while (dom !== null && dom.nodeType !== 1) {\n        dom = dom.nextSibling;\n      }\n\n      return dom;\n    },\n\n    /**\n     * gets the previous sibling of a DOM node. Used internally.\n     * @private\n     * @name _previousSibling(dom)\n     * @param  {DOMElement} dom\n     * @return {DOMElement}\n     */\n    _previousSibling: function _previousSibling(dom) {\n      dom = dom ? dom.previousSibling : null;\n\n      while (dom !== null && dom.nodeType !== 1) {\n        dom = dom.previousSibling;\n      }\n\n      return dom;\n    },\n\n    /**\n     * get the JSON representation of a node (or the actual jQuery extended DOM node) by using any input (child DOM element, ID string, selector, etc)\n     * @name get_node(obj [, as_dom])\n     * @param  {mixed} obj\n     * @param  {Boolean} as_dom\n     * @return {Object|jQuery}\n     */\n    get_node: function get_node(obj, as_dom) {\n      if (obj && obj.id) {\n        obj = obj.id;\n      }\n\n      var dom;\n\n      try {\n        if (this._model.data[obj]) {\n          obj = this._model.data[obj];\n        } else if (typeof obj === \"string\" && this._model.data[obj.replace(/^#/, '')]) {\n          obj = this._model.data[obj.replace(/^#/, '')];\n        } else if (typeof obj === \"string\" && (dom = $('#' + obj.replace($.jstree.idregex, '\\\\$&'), this.element)).length && this._model.data[dom.closest('.jstree-node').attr('id')]) {\n          obj = this._model.data[dom.closest('.jstree-node').attr('id')];\n        } else if ((dom = $(obj, this.element)).length && this._model.data[dom.closest('.jstree-node').attr('id')]) {\n          obj = this._model.data[dom.closest('.jstree-node').attr('id')];\n        } else if ((dom = $(obj, this.element)).length && dom.hasClass('jstree')) {\n          obj = this._model.data[$.jstree.root];\n        } else {\n          return false;\n        }\n\n        if (as_dom) {\n          obj = obj.id === $.jstree.root ? this.element : $('#' + obj.id.replace($.jstree.idregex, '\\\\$&'), this.element);\n        }\n\n        return obj;\n      } catch (ex) {\n        return false;\n      }\n    },\n\n    /**\n     * get the path to a node, either consisting of node texts, or of node IDs, optionally glued together (otherwise an array)\n     * @name get_path(obj [, glue, ids])\n     * @param  {mixed} obj the node\n     * @param  {String} glue if you want the path as a string - pass the glue here (for example '/'), if a falsy value is supplied here, an array is returned\n     * @param  {Boolean} ids if set to true build the path using ID, otherwise node text is used\n     * @return {mixed}\n     */\n    get_path: function get_path(obj, glue, ids) {\n      obj = obj.parents ? obj : this.get_node(obj);\n\n      if (!obj || obj.id === $.jstree.root || !obj.parents) {\n        return false;\n      }\n\n      var i,\n          j,\n          p = [];\n      p.push(ids ? obj.id : obj.text);\n\n      for (i = 0, j = obj.parents.length; i < j; i++) {\n        p.push(ids ? obj.parents[i] : this.get_text(obj.parents[i]));\n      }\n\n      p = p.reverse().slice(1);\n      return glue ? p.join(glue) : p;\n    },\n\n    /**\n     * get the next visible node that is below the `obj` node. If `strict` is set to `true` only sibling nodes are returned.\n     * @name get_next_dom(obj [, strict])\n     * @param  {mixed} obj\n     * @param  {Boolean} strict\n     * @return {jQuery}\n     */\n    get_next_dom: function get_next_dom(obj, strict) {\n      var tmp;\n      obj = this.get_node(obj, true);\n\n      if (obj[0] === this.element[0]) {\n        tmp = this._firstChild(this.get_container_ul()[0]);\n\n        while (tmp && tmp.offsetHeight === 0) {\n          tmp = this._nextSibling(tmp);\n        }\n\n        return tmp ? $(tmp) : false;\n      }\n\n      if (!obj || !obj.length) {\n        return false;\n      }\n\n      if (strict) {\n        tmp = obj[0];\n\n        do {\n          tmp = this._nextSibling(tmp);\n        } while (tmp && tmp.offsetHeight === 0);\n\n        return tmp ? $(tmp) : false;\n      }\n\n      if (obj.hasClass(\"jstree-open\")) {\n        tmp = this._firstChild(obj.children('.jstree-children')[0]);\n\n        while (tmp && tmp.offsetHeight === 0) {\n          tmp = this._nextSibling(tmp);\n        }\n\n        if (tmp !== null) {\n          return $(tmp);\n        }\n      }\n\n      tmp = obj[0];\n\n      do {\n        tmp = this._nextSibling(tmp);\n      } while (tmp && tmp.offsetHeight === 0);\n\n      if (tmp !== null) {\n        return $(tmp);\n      }\n\n      return obj.parentsUntil(\".jstree\", \".jstree-node\").nextAll(\".jstree-node:visible\").first();\n    },\n\n    /**\n     * get the previous visible node that is above the `obj` node. If `strict` is set to `true` only sibling nodes are returned.\n     * @name get_prev_dom(obj [, strict])\n     * @param  {mixed} obj\n     * @param  {Boolean} strict\n     * @return {jQuery}\n     */\n    get_prev_dom: function get_prev_dom(obj, strict) {\n      var tmp;\n      obj = this.get_node(obj, true);\n\n      if (obj[0] === this.element[0]) {\n        tmp = this.get_container_ul()[0].lastChild;\n\n        while (tmp && tmp.offsetHeight === 0) {\n          tmp = this._previousSibling(tmp);\n        }\n\n        return tmp ? $(tmp) : false;\n      }\n\n      if (!obj || !obj.length) {\n        return false;\n      }\n\n      if (strict) {\n        tmp = obj[0];\n\n        do {\n          tmp = this._previousSibling(tmp);\n        } while (tmp && tmp.offsetHeight === 0);\n\n        return tmp ? $(tmp) : false;\n      }\n\n      tmp = obj[0];\n\n      do {\n        tmp = this._previousSibling(tmp);\n      } while (tmp && tmp.offsetHeight === 0);\n\n      if (tmp !== null) {\n        obj = $(tmp);\n\n        while (obj.hasClass(\"jstree-open\")) {\n          obj = obj.children(\".jstree-children\").first().children(\".jstree-node:visible:last\");\n        }\n\n        return obj;\n      }\n\n      tmp = obj[0].parentNode.parentNode;\n      return tmp && tmp.className && tmp.className.indexOf('jstree-node') !== -1 ? $(tmp) : false;\n    },\n\n    /**\n     * get the parent ID of a node\n     * @name get_parent(obj)\n     * @param  {mixed} obj\n     * @return {String}\n     */\n    get_parent: function get_parent(obj) {\n      obj = this.get_node(obj);\n\n      if (!obj || obj.id === $.jstree.root) {\n        return false;\n      }\n\n      return obj.parent;\n    },\n\n    /**\n     * get a jQuery collection of all the children of a node (node must be rendered)\n     * @name get_children_dom(obj)\n     * @param  {mixed} obj\n     * @return {jQuery}\n     */\n    get_children_dom: function get_children_dom(obj) {\n      obj = this.get_node(obj, true);\n\n      if (obj[0] === this.element[0]) {\n        return this.get_container_ul().children(\".jstree-node\");\n      }\n\n      if (!obj || !obj.length) {\n        return false;\n      }\n\n      return obj.children(\".jstree-children\").children(\".jstree-node\");\n    },\n\n    /**\n     * checks if a node has children\n     * @name is_parent(obj)\n     * @param  {mixed} obj\n     * @return {Boolean}\n     */\n    is_parent: function is_parent(obj) {\n      obj = this.get_node(obj);\n      return obj && (obj.state.loaded === false || obj.children.length > 0);\n    },\n\n    /**\n     * checks if a node is loaded (its children are available)\n     * @name is_loaded(obj)\n     * @param  {mixed} obj\n     * @return {Boolean}\n     */\n    is_loaded: function is_loaded(obj) {\n      obj = this.get_node(obj);\n      return obj && obj.state.loaded;\n    },\n\n    /**\n     * check if a node is currently loading (fetching children)\n     * @name is_loading(obj)\n     * @param  {mixed} obj\n     * @return {Boolean}\n     */\n    is_loading: function is_loading(obj) {\n      obj = this.get_node(obj);\n      return obj && obj.state && obj.state.loading;\n    },\n\n    /**\n     * check if a node is opened\n     * @name is_open(obj)\n     * @param  {mixed} obj\n     * @return {Boolean}\n     */\n    is_open: function is_open(obj) {\n      obj = this.get_node(obj);\n      return obj && obj.state.opened;\n    },\n\n    /**\n     * check if a node is in a closed state\n     * @name is_closed(obj)\n     * @param  {mixed} obj\n     * @return {Boolean}\n     */\n    is_closed: function is_closed(obj) {\n      obj = this.get_node(obj);\n      return obj && this.is_parent(obj) && !obj.state.opened;\n    },\n\n    /**\n     * check if a node has no children\n     * @name is_leaf(obj)\n     * @param  {mixed} obj\n     * @return {Boolean}\n     */\n    is_leaf: function is_leaf(obj) {\n      return !this.is_parent(obj);\n    },\n\n    /**\n     * loads a node (fetches its children using the `core.data` setting). Multiple nodes can be passed to by using an array.\n     * @name load_node(obj [, callback])\n     * @param  {mixed} obj\n     * @param  {function} callback a function to be executed once loading is complete, the function is executed in the instance's scope and receives two arguments - the node and a boolean status\n     * @return {Boolean}\n     * @trigger load_node.jstree\n     */\n    load_node: function load_node(obj, callback) {\n      var k, l, i, j, c;\n\n      if ($.isArray(obj)) {\n        this._load_nodes(obj.slice(), callback);\n\n        return true;\n      }\n\n      obj = this.get_node(obj);\n\n      if (!obj) {\n        if (callback) {\n          callback.call(this, obj, false);\n        }\n\n        return false;\n      } // if(obj.state.loading) { } // the node is already loading - just wait for it to load and invoke callback? but if called implicitly it should be loaded again?\n\n\n      if (obj.state.loaded) {\n        obj.state.loaded = false;\n\n        for (i = 0, j = obj.parents.length; i < j; i++) {\n          this._model.data[obj.parents[i]].children_d = $.vakata.array_filter(this._model.data[obj.parents[i]].children_d, function (v) {\n            return $.inArray(v, obj.children_d) === -1;\n          });\n        }\n\n        for (k = 0, l = obj.children_d.length; k < l; k++) {\n          if (this._model.data[obj.children_d[k]].state.selected) {\n            c = true;\n          }\n\n          delete this._model.data[obj.children_d[k]];\n        }\n\n        if (c) {\n          this._data.core.selected = $.vakata.array_filter(this._data.core.selected, function (v) {\n            return $.inArray(v, obj.children_d) === -1;\n          });\n        }\n\n        obj.children = [];\n        obj.children_d = [];\n\n        if (c) {\n          this.trigger('changed', {\n            'action': 'load_node',\n            'node': obj,\n            'selected': this._data.core.selected\n          });\n        }\n      }\n\n      obj.state.failed = false;\n      obj.state.loading = true;\n      this.get_node(obj, true).addClass(\"jstree-loading\").attr('aria-busy', true);\n\n      this._load_node(obj, $.proxy(function (status) {\n        obj = this._model.data[obj.id];\n        obj.state.loading = false;\n        obj.state.loaded = status;\n        obj.state.failed = !obj.state.loaded;\n        var dom = this.get_node(obj, true),\n            i = 0,\n            j = 0,\n            m = this._model.data,\n            has_children = false;\n\n        for (i = 0, j = obj.children.length; i < j; i++) {\n          if (m[obj.children[i]] && !m[obj.children[i]].state.hidden) {\n            has_children = true;\n            break;\n          }\n        }\n\n        if (obj.state.loaded && dom && dom.length) {\n          dom.removeClass('jstree-closed jstree-open jstree-leaf');\n\n          if (!has_children) {\n            dom.addClass('jstree-leaf');\n          } else {\n            if (obj.id !== '#') {\n              dom.addClass(obj.state.opened ? 'jstree-open' : 'jstree-closed');\n            }\n          }\n        }\n\n        dom.removeClass(\"jstree-loading\").attr('aria-busy', false);\n        /**\n         * triggered after a node is loaded\n         * @event\n         * @name load_node.jstree\n         * @param {Object} node the node that was loading\n         * @param {Boolean} status was the node loaded successfully\n         */\n\n        this.trigger('load_node', {\n          \"node\": obj,\n          \"status\": status\n        });\n\n        if (callback) {\n          callback.call(this, obj, status);\n        }\n      }, this));\n\n      return true;\n    },\n\n    /**\n     * load an array of nodes (will also load unavailable nodes as soon as the appear in the structure). Used internally.\n     * @private\n     * @name _load_nodes(nodes [, callback])\n     * @param  {array} nodes\n     * @param  {function} callback a function to be executed once loading is complete, the function is executed in the instance's scope and receives one argument - the array passed to _load_nodes\n     */\n    _load_nodes: function _load_nodes(nodes, callback, is_callback, force_reload) {\n      var r = true,\n          c = function c() {\n        this._load_nodes(nodes, callback, true);\n      },\n          m = this._model.data,\n          i,\n          j,\n          tmp = [];\n\n      for (i = 0, j = nodes.length; i < j; i++) {\n        if (m[nodes[i]] && (!m[nodes[i]].state.loaded && !m[nodes[i]].state.failed || !is_callback && force_reload)) {\n          if (!this.is_loading(nodes[i])) {\n            this.load_node(nodes[i], c);\n          }\n\n          r = false;\n        }\n      }\n\n      if (r) {\n        for (i = 0, j = nodes.length; i < j; i++) {\n          if (m[nodes[i]] && m[nodes[i]].state.loaded) {\n            tmp.push(nodes[i]);\n          }\n        }\n\n        if (callback && !callback.done) {\n          callback.call(this, tmp);\n          callback.done = true;\n        }\n      }\n    },\n\n    /**\n     * loads all unloaded nodes\n     * @name load_all([obj, callback])\n     * @param {mixed} obj the node to load recursively, omit to load all nodes in the tree\n     * @param {function} callback a function to be executed once loading all the nodes is complete,\n     * @trigger load_all.jstree\n     */\n    load_all: function load_all(obj, callback) {\n      if (!obj) {\n        obj = $.jstree.root;\n      }\n\n      obj = this.get_node(obj);\n\n      if (!obj) {\n        return false;\n      }\n\n      var to_load = [],\n          m = this._model.data,\n          c = m[obj.id].children_d,\n          i,\n          j;\n\n      if (obj.state && !obj.state.loaded) {\n        to_load.push(obj.id);\n      }\n\n      for (i = 0, j = c.length; i < j; i++) {\n        if (m[c[i]] && m[c[i]].state && !m[c[i]].state.loaded) {\n          to_load.push(c[i]);\n        }\n      }\n\n      if (to_load.length) {\n        this._load_nodes(to_load, function () {\n          this.load_all(obj, callback);\n        });\n      } else {\n        /**\n         * triggered after a load_all call completes\n         * @event\n         * @name load_all.jstree\n         * @param {Object} node the recursively loaded node\n         */\n        if (callback) {\n          callback.call(this, obj);\n        }\n\n        this.trigger('load_all', {\n          \"node\": obj\n        });\n      }\n    },\n\n    /**\n     * handles the actual loading of a node. Used only internally.\n     * @private\n     * @name _load_node(obj [, callback])\n     * @param  {mixed} obj\n     * @param  {function} callback a function to be executed once loading is complete, the function is executed in the instance's scope and receives one argument - a boolean status\n     * @return {Boolean}\n     */\n    _load_node: function _load_node(obj, callback) {\n      var s = this.settings.core.data,\n          t;\n\n      var notTextOrCommentNode = function notTextOrCommentNode() {\n        return this.nodeType !== 3 && this.nodeType !== 8;\n      }; // use original HTML\n\n\n      if (!s) {\n        if (obj.id === $.jstree.root) {\n          return this._append_html_data(obj, this._data.core.original_container_html.clone(true), function (status) {\n            callback.call(this, status);\n          });\n        } else {\n          return callback.call(this, false);\n        } // return callback.call(this, obj.id === $.jstree.root ? this._append_html_data(obj, this._data.core.original_container_html.clone(true)) : false);\n\n      }\n\n      if ($.isFunction(s)) {\n        return s.call(this, obj, $.proxy(function (d) {\n          if (d === false) {\n            callback.call(this, false);\n          } else {\n            this[typeof d === 'string' ? '_append_html_data' : '_append_json_data'](obj, typeof d === 'string' ? $($.parseHTML(d)).filter(notTextOrCommentNode) : d, function (status) {\n              callback.call(this, status);\n            });\n          } // return d === false ? callback.call(this, false) : callback.call(this, this[typeof d === 'string' ? '_append_html_data' : '_append_json_data'](obj, typeof d === 'string' ? $(d) : d));\n\n        }, this));\n      }\n\n      if (_typeof(s) === 'object') {\n        if (s.url) {\n          s = $.extend(true, {}, s);\n\n          if ($.isFunction(s.url)) {\n            s.url = s.url.call(this, obj);\n          }\n\n          if ($.isFunction(s.data)) {\n            s.data = s.data.call(this, obj);\n          }\n\n          return $.ajax(s).done($.proxy(function (d, t, x) {\n            var type = x.getResponseHeader('Content-Type');\n\n            if (type && type.indexOf('json') !== -1 || _typeof(d) === \"object\") {\n              return this._append_json_data(obj, d, function (status) {\n                callback.call(this, status);\n              }); //return callback.call(this, this._append_json_data(obj, d));\n            }\n\n            if (type && type.indexOf('html') !== -1 || typeof d === \"string\") {\n              return this._append_html_data(obj, $($.parseHTML(d)).filter(notTextOrCommentNode), function (status) {\n                callback.call(this, status);\n              }); // return callback.call(this, this._append_html_data(obj, $(d)));\n            }\n\n            this._data.core.last_error = {\n              'error': 'ajax',\n              'plugin': 'core',\n              'id': 'core_04',\n              'reason': 'Could not load node',\n              'data': JSON.stringify({\n                'id': obj.id,\n                'xhr': x\n              })\n            };\n            this.settings.core.error.call(this, this._data.core.last_error);\n            return callback.call(this, false);\n          }, this)).fail($.proxy(function (f) {\n            callback.call(this, false);\n            this._data.core.last_error = {\n              'error': 'ajax',\n              'plugin': 'core',\n              'id': 'core_04',\n              'reason': 'Could not load node',\n              'data': JSON.stringify({\n                'id': obj.id,\n                'xhr': f\n              })\n            };\n            this.settings.core.error.call(this, this._data.core.last_error);\n          }, this));\n        }\n\n        t = $.isArray(s) || $.isPlainObject(s) ? JSON.parse(JSON.stringify(s)) : s;\n\n        if (obj.id === $.jstree.root) {\n          return this._append_json_data(obj, t, function (status) {\n            callback.call(this, status);\n          });\n        } else {\n          this._data.core.last_error = {\n            'error': 'nodata',\n            'plugin': 'core',\n            'id': 'core_05',\n            'reason': 'Could not load node',\n            'data': JSON.stringify({\n              'id': obj.id\n            })\n          };\n          this.settings.core.error.call(this, this._data.core.last_error);\n          return callback.call(this, false);\n        } //return callback.call(this, (obj.id === $.jstree.root ? this._append_json_data(obj, t) : false) );\n\n      }\n\n      if (typeof s === 'string') {\n        if (obj.id === $.jstree.root) {\n          return this._append_html_data(obj, $($.parseHTML(s)).filter(notTextOrCommentNode), function (status) {\n            callback.call(this, status);\n          });\n        } else {\n          this._data.core.last_error = {\n            'error': 'nodata',\n            'plugin': 'core',\n            'id': 'core_06',\n            'reason': 'Could not load node',\n            'data': JSON.stringify({\n              'id': obj.id\n            })\n          };\n          this.settings.core.error.call(this, this._data.core.last_error);\n          return callback.call(this, false);\n        } //return callback.call(this, (obj.id === $.jstree.root ? this._append_html_data(obj, $(s)) : false) );\n\n      }\n\n      return callback.call(this, false);\n    },\n\n    /**\n     * adds a node to the list of nodes to redraw. Used only internally.\n     * @private\n     * @name _node_changed(obj [, callback])\n     * @param  {mixed} obj\n     */\n    _node_changed: function _node_changed(obj) {\n      obj = this.get_node(obj);\n\n      if (obj) {\n        this._model.changed.push(obj.id);\n      }\n    },\n\n    /**\n     * appends HTML content to the tree. Used internally.\n     * @private\n     * @name _append_html_data(obj, data)\n     * @param  {mixed} obj the node to append to\n     * @param  {String} data the HTML string to parse and append\n     * @trigger model.jstree, changed.jstree\n     */\n    _append_html_data: function _append_html_data(dom, data, cb) {\n      dom = this.get_node(dom);\n      dom.children = [];\n      dom.children_d = [];\n      var dat = data.is('ul') ? data.children() : data,\n          par = dom.id,\n          chd = [],\n          dpc = [],\n          m = this._model.data,\n          p = m[par],\n          s = this._data.core.selected.length,\n          tmp,\n          i,\n          j;\n      dat.each($.proxy(function (i, v) {\n        tmp = this._parse_model_from_html($(v), par, p.parents.concat());\n\n        if (tmp) {\n          chd.push(tmp);\n          dpc.push(tmp);\n\n          if (m[tmp].children_d.length) {\n            dpc = dpc.concat(m[tmp].children_d);\n          }\n        }\n      }, this));\n      p.children = chd;\n      p.children_d = dpc;\n\n      for (i = 0, j = p.parents.length; i < j; i++) {\n        m[p.parents[i]].children_d = m[p.parents[i]].children_d.concat(dpc);\n      }\n      /**\n       * triggered when new data is inserted to the tree model\n       * @event\n       * @name model.jstree\n       * @param {Array} nodes an array of node IDs\n       * @param {String} parent the parent ID of the nodes\n       */\n\n\n      this.trigger('model', {\n        \"nodes\": dpc,\n        'parent': par\n      });\n\n      if (par !== $.jstree.root) {\n        this._node_changed(par);\n\n        this.redraw();\n      } else {\n        this.get_container_ul().children('.jstree-initial-node').remove();\n        this.redraw(true);\n      }\n\n      if (this._data.core.selected.length !== s) {\n        this.trigger('changed', {\n          'action': 'model',\n          'selected': this._data.core.selected\n        });\n      }\n\n      cb.call(this, true);\n    },\n\n    /**\n     * appends JSON content to the tree. Used internally.\n     * @private\n     * @name _append_json_data(obj, data)\n     * @param  {mixed} obj the node to append to\n     * @param  {String} data the JSON object to parse and append\n     * @param  {Boolean} force_processing internal param - do not set\n     * @trigger model.jstree, changed.jstree\n     */\n    _append_json_data: function _append_json_data(dom, data, cb, force_processing) {\n      if (this.element === null) {\n        return;\n      }\n\n      dom = this.get_node(dom);\n      dom.children = [];\n      dom.children_d = []; // *%$@!!!\n\n      if (data.d) {\n        data = data.d;\n\n        if (typeof data === \"string\") {\n          data = JSON.parse(data);\n        }\n      }\n\n      if (!$.isArray(data)) {\n        data = [data];\n      }\n\n      var w = null,\n          args = {\n        'df': this._model.default_state,\n        'dat': data,\n        'par': dom.id,\n        'm': this._model.data,\n        't_id': this._id,\n        't_cnt': this._cnt,\n        'sel': this._data.core.selected\n      },\n          func = function func(data, undefined) {\n        if (data.data) {\n          data = data.data;\n        }\n\n        var dat = data.dat,\n            par = data.par,\n            chd = [],\n            dpc = [],\n            add = [],\n            df = data.df,\n            t_id = data.t_id,\n            t_cnt = data.t_cnt,\n            m = data.m,\n            p = m[par],\n            sel = data.sel,\n            tmp,\n            i,\n            j,\n            rslt,\n            parse_flat = function parse_flat(d, p, ps) {\n          if (!ps) {\n            ps = [];\n          } else {\n            ps = ps.concat();\n          }\n\n          if (p) {\n            ps.unshift(p);\n          }\n\n          var tid = d.id.toString(),\n              i,\n              j,\n              c,\n              e,\n              tmp = {\n            id: tid,\n            text: d.text || '',\n            icon: d.icon !== undefined ? d.icon : true,\n            parent: p,\n            parents: ps,\n            children: d.children || [],\n            children_d: d.children_d || [],\n            data: d.data,\n            state: {},\n            li_attr: {\n              id: false\n            },\n            a_attr: {\n              href: '#'\n            },\n            original: false\n          };\n\n          for (i in df) {\n            if (df.hasOwnProperty(i)) {\n              tmp.state[i] = df[i];\n            }\n          }\n\n          if (d && d.data && d.data.jstree && d.data.jstree.icon) {\n            tmp.icon = d.data.jstree.icon;\n          }\n\n          if (tmp.icon === undefined || tmp.icon === null || tmp.icon === \"\") {\n            tmp.icon = true;\n          }\n\n          if (d && d.data) {\n            tmp.data = d.data;\n\n            if (d.data.jstree) {\n              for (i in d.data.jstree) {\n                if (d.data.jstree.hasOwnProperty(i)) {\n                  tmp.state[i] = d.data.jstree[i];\n                }\n              }\n            }\n          }\n\n          if (d && _typeof(d.state) === 'object') {\n            for (i in d.state) {\n              if (d.state.hasOwnProperty(i)) {\n                tmp.state[i] = d.state[i];\n              }\n            }\n          }\n\n          if (d && _typeof(d.li_attr) === 'object') {\n            for (i in d.li_attr) {\n              if (d.li_attr.hasOwnProperty(i)) {\n                tmp.li_attr[i] = d.li_attr[i];\n              }\n            }\n          }\n\n          if (!tmp.li_attr.id) {\n            tmp.li_attr.id = tid;\n          }\n\n          if (d && _typeof(d.a_attr) === 'object') {\n            for (i in d.a_attr) {\n              if (d.a_attr.hasOwnProperty(i)) {\n                tmp.a_attr[i] = d.a_attr[i];\n              }\n            }\n          }\n\n          if (d && d.children && d.children === true) {\n            tmp.state.loaded = false;\n            tmp.children = [];\n            tmp.children_d = [];\n          }\n\n          m[tmp.id] = tmp;\n\n          for (i = 0, j = tmp.children.length; i < j; i++) {\n            c = parse_flat(m[tmp.children[i]], tmp.id, ps);\n            e = m[c];\n            tmp.children_d.push(c);\n\n            if (e.children_d.length) {\n              tmp.children_d = tmp.children_d.concat(e.children_d);\n            }\n          }\n\n          delete d.data;\n          delete d.children;\n          m[tmp.id].original = d;\n\n          if (tmp.state.selected) {\n            add.push(tmp.id);\n          }\n\n          return tmp.id;\n        },\n            parse_nest = function parse_nest(d, p, ps) {\n          if (!ps) {\n            ps = [];\n          } else {\n            ps = ps.concat();\n          }\n\n          if (p) {\n            ps.unshift(p);\n          }\n\n          var tid = false,\n              i,\n              j,\n              c,\n              e,\n              tmp;\n\n          do {\n            tid = 'j' + t_id + '_' + ++t_cnt;\n          } while (m[tid]);\n\n          tmp = {\n            id: false,\n            text: typeof d === 'string' ? d : '',\n            icon: _typeof(d) === 'object' && d.icon !== undefined ? d.icon : true,\n            parent: p,\n            parents: ps,\n            children: [],\n            children_d: [],\n            data: null,\n            state: {},\n            li_attr: {\n              id: false\n            },\n            a_attr: {\n              href: '#'\n            },\n            original: false\n          };\n\n          for (i in df) {\n            if (df.hasOwnProperty(i)) {\n              tmp.state[i] = df[i];\n            }\n          }\n\n          if (d && d.id) {\n            tmp.id = d.id.toString();\n          }\n\n          if (d && d.text) {\n            tmp.text = d.text;\n          }\n\n          if (d && d.data && d.data.jstree && d.data.jstree.icon) {\n            tmp.icon = d.data.jstree.icon;\n          }\n\n          if (tmp.icon === undefined || tmp.icon === null || tmp.icon === \"\") {\n            tmp.icon = true;\n          }\n\n          if (d && d.data) {\n            tmp.data = d.data;\n\n            if (d.data.jstree) {\n              for (i in d.data.jstree) {\n                if (d.data.jstree.hasOwnProperty(i)) {\n                  tmp.state[i] = d.data.jstree[i];\n                }\n              }\n            }\n          }\n\n          if (d && _typeof(d.state) === 'object') {\n            for (i in d.state) {\n              if (d.state.hasOwnProperty(i)) {\n                tmp.state[i] = d.state[i];\n              }\n            }\n          }\n\n          if (d && _typeof(d.li_attr) === 'object') {\n            for (i in d.li_attr) {\n              if (d.li_attr.hasOwnProperty(i)) {\n                tmp.li_attr[i] = d.li_attr[i];\n              }\n            }\n          }\n\n          if (tmp.li_attr.id && !tmp.id) {\n            tmp.id = tmp.li_attr.id.toString();\n          }\n\n          if (!tmp.id) {\n            tmp.id = tid;\n          }\n\n          if (!tmp.li_attr.id) {\n            tmp.li_attr.id = tmp.id;\n          }\n\n          if (d && _typeof(d.a_attr) === 'object') {\n            for (i in d.a_attr) {\n              if (d.a_attr.hasOwnProperty(i)) {\n                tmp.a_attr[i] = d.a_attr[i];\n              }\n            }\n          }\n\n          if (d && d.children && d.children.length) {\n            for (i = 0, j = d.children.length; i < j; i++) {\n              c = parse_nest(d.children[i], tmp.id, ps);\n              e = m[c];\n              tmp.children.push(c);\n\n              if (e.children_d.length) {\n                tmp.children_d = tmp.children_d.concat(e.children_d);\n              }\n            }\n\n            tmp.children_d = tmp.children_d.concat(tmp.children);\n          }\n\n          if (d && d.children && d.children === true) {\n            tmp.state.loaded = false;\n            tmp.children = [];\n            tmp.children_d = [];\n          }\n\n          delete d.data;\n          delete d.children;\n          tmp.original = d;\n          m[tmp.id] = tmp;\n\n          if (tmp.state.selected) {\n            add.push(tmp.id);\n          }\n\n          return tmp.id;\n        };\n\n        if (dat.length && dat[0].id !== undefined && dat[0].parent !== undefined) {\n          // Flat JSON support (for easy import from DB):\n          // 1) convert to object (foreach)\n          for (i = 0, j = dat.length; i < j; i++) {\n            if (!dat[i].children) {\n              dat[i].children = [];\n            }\n\n            m[dat[i].id.toString()] = dat[i];\n          } // 2) populate children (foreach)\n\n\n          for (i = 0, j = dat.length; i < j; i++) {\n            m[dat[i].parent.toString()].children.push(dat[i].id.toString()); // populate parent.children_d\n\n            p.children_d.push(dat[i].id.toString());\n          } // 3) normalize && populate parents and children_d with recursion\n\n\n          for (i = 0, j = p.children.length; i < j; i++) {\n            tmp = parse_flat(m[p.children[i]], par, p.parents.concat());\n            dpc.push(tmp);\n\n            if (m[tmp].children_d.length) {\n              dpc = dpc.concat(m[tmp].children_d);\n            }\n          }\n\n          for (i = 0, j = p.parents.length; i < j; i++) {\n            m[p.parents[i]].children_d = m[p.parents[i]].children_d.concat(dpc);\n          } // ?) three_state selection - p.state.selected && t - (if three_state foreach(dat => ch) -> foreach(parents) if(parent.selected) child.selected = true;\n\n\n          rslt = {\n            'cnt': t_cnt,\n            'mod': m,\n            'sel': sel,\n            'par': par,\n            'dpc': dpc,\n            'add': add\n          };\n        } else {\n          for (i = 0, j = dat.length; i < j; i++) {\n            tmp = parse_nest(dat[i], par, p.parents.concat());\n\n            if (tmp) {\n              chd.push(tmp);\n              dpc.push(tmp);\n\n              if (m[tmp].children_d.length) {\n                dpc = dpc.concat(m[tmp].children_d);\n              }\n            }\n          }\n\n          p.children = chd;\n          p.children_d = dpc;\n\n          for (i = 0, j = p.parents.length; i < j; i++) {\n            m[p.parents[i]].children_d = m[p.parents[i]].children_d.concat(dpc);\n          }\n\n          rslt = {\n            'cnt': t_cnt,\n            'mod': m,\n            'sel': sel,\n            'par': par,\n            'dpc': dpc,\n            'add': add\n          };\n        }\n\n        if (typeof window === 'undefined' || typeof window.document === 'undefined') {\n          postMessage(rslt);\n        } else {\n          return rslt;\n        }\n      },\n          rslt = function rslt(_rslt, worker) {\n        if (this.element === null) {\n          return;\n        }\n\n        this._cnt = _rslt.cnt;\n        var i,\n            m = this._model.data;\n\n        for (i in m) {\n          if (m.hasOwnProperty(i) && m[i].state && m[i].state.loading && _rslt.mod[i]) {\n            _rslt.mod[i].state.loading = true;\n          }\n        }\n\n        this._model.data = _rslt.mod; // breaks the reference in load_node - careful\n\n        if (worker) {\n          var j,\n              a = _rslt.add,\n              r = _rslt.sel,\n              s = this._data.core.selected.slice();\n\n          m = this._model.data; // if selection was changed while calculating in worker\n\n          if (r.length !== s.length || $.vakata.array_unique(r.concat(s)).length !== r.length) {\n            // deselect nodes that are no longer selected\n            for (i = 0, j = r.length; i < j; i++) {\n              if ($.inArray(r[i], a) === -1 && $.inArray(r[i], s) === -1) {\n                m[r[i]].state.selected = false;\n              }\n            } // select nodes that were selected in the mean time\n\n\n            for (i = 0, j = s.length; i < j; i++) {\n              if ($.inArray(s[i], r) === -1) {\n                m[s[i]].state.selected = true;\n              }\n            }\n          }\n        }\n\n        if (_rslt.add.length) {\n          this._data.core.selected = this._data.core.selected.concat(_rslt.add);\n        }\n\n        this.trigger('model', {\n          \"nodes\": _rslt.dpc,\n          'parent': _rslt.par\n        });\n\n        if (_rslt.par !== $.jstree.root) {\n          this._node_changed(_rslt.par);\n\n          this.redraw();\n        } else {\n          // this.get_container_ul().children('.jstree-initial-node').remove();\n          this.redraw(true);\n        }\n\n        if (_rslt.add.length) {\n          this.trigger('changed', {\n            'action': 'model',\n            'selected': this._data.core.selected\n          });\n        }\n\n        cb.call(this, true);\n      };\n\n      if (this.settings.core.worker && window.Blob && window.URL && window.Worker) {\n        try {\n          if (this._wrk === null) {\n            this._wrk = window.URL.createObjectURL(new window.Blob(['self.onmessage = ' + func.toString()], {\n              type: \"text/javascript\"\n            }));\n          }\n\n          if (!this._data.core.working || force_processing) {\n            this._data.core.working = true;\n            w = new window.Worker(this._wrk);\n            w.onmessage = $.proxy(function (e) {\n              rslt.call(this, e.data, true);\n\n              try {\n                w.terminate();\n                w = null;\n              } catch (ignore) {}\n\n              if (this._data.core.worker_queue.length) {\n                this._append_json_data.apply(this, this._data.core.worker_queue.shift());\n              } else {\n                this._data.core.working = false;\n              }\n            }, this);\n\n            if (!args.par) {\n              if (this._data.core.worker_queue.length) {\n                this._append_json_data.apply(this, this._data.core.worker_queue.shift());\n              } else {\n                this._data.core.working = false;\n              }\n            } else {\n              w.postMessage(args);\n            }\n          } else {\n            this._data.core.worker_queue.push([dom, data, cb, true]);\n          }\n        } catch (e) {\n          rslt.call(this, func(args), false);\n\n          if (this._data.core.worker_queue.length) {\n            this._append_json_data.apply(this, this._data.core.worker_queue.shift());\n          } else {\n            this._data.core.working = false;\n          }\n        }\n      } else {\n        rslt.call(this, func(args), false);\n      }\n    },\n\n    /**\n     * parses a node from a jQuery object and appends them to the in memory tree model. Used internally.\n     * @private\n     * @name _parse_model_from_html(d [, p, ps])\n     * @param  {jQuery} d the jQuery object to parse\n     * @param  {String} p the parent ID\n     * @param  {Array} ps list of all parents\n     * @return {String} the ID of the object added to the model\n     */\n    _parse_model_from_html: function _parse_model_from_html(d, p, ps) {\n      if (!ps) {\n        ps = [];\n      } else {\n        ps = [].concat(ps);\n      }\n\n      if (p) {\n        ps.unshift(p);\n      }\n\n      var c,\n          e,\n          m = this._model.data,\n          data = {\n        id: false,\n        text: false,\n        icon: true,\n        parent: p,\n        parents: ps,\n        children: [],\n        children_d: [],\n        data: null,\n        state: {},\n        li_attr: {\n          id: false\n        },\n        a_attr: {\n          href: '#'\n        },\n        original: false\n      },\n          i,\n          tmp,\n          tid;\n\n      for (i in this._model.default_state) {\n        if (this._model.default_state.hasOwnProperty(i)) {\n          data.state[i] = this._model.default_state[i];\n        }\n      }\n\n      tmp = $.vakata.attributes(d, true);\n      $.each(tmp, function (i, v) {\n        v = $.trim(v);\n\n        if (!v.length) {\n          return true;\n        }\n\n        data.li_attr[i] = v;\n\n        if (i === 'id') {\n          data.id = v.toString();\n        }\n      });\n      tmp = d.children('a').first();\n\n      if (tmp.length) {\n        tmp = $.vakata.attributes(tmp, true);\n        $.each(tmp, function (i, v) {\n          v = $.trim(v);\n\n          if (v.length) {\n            data.a_attr[i] = v;\n          }\n        });\n      }\n\n      tmp = d.children(\"a\").first().length ? d.children(\"a\").first().clone() : d.clone();\n      tmp.children(\"ins, i, ul\").remove();\n      tmp = tmp.html();\n      tmp = $('<div />').html(tmp);\n      data.text = this.settings.core.force_text ? tmp.text() : tmp.html();\n      tmp = d.data();\n      data.data = tmp ? $.extend(true, {}, tmp) : null;\n      data.state.opened = d.hasClass('jstree-open');\n      data.state.selected = d.children('a').hasClass('jstree-clicked');\n      data.state.disabled = d.children('a').hasClass('jstree-disabled');\n\n      if (data.data && data.data.jstree) {\n        for (i in data.data.jstree) {\n          if (data.data.jstree.hasOwnProperty(i)) {\n            data.state[i] = data.data.jstree[i];\n          }\n        }\n      }\n\n      tmp = d.children(\"a\").children(\".jstree-themeicon\");\n\n      if (tmp.length) {\n        data.icon = tmp.hasClass('jstree-themeicon-hidden') ? false : tmp.attr('rel');\n      }\n\n      if (data.state.icon !== undefined) {\n        data.icon = data.state.icon;\n      }\n\n      if (data.icon === undefined || data.icon === null || data.icon === \"\") {\n        data.icon = true;\n      }\n\n      tmp = d.children(\"ul\").children(\"li\");\n\n      do {\n        tid = 'j' + this._id + '_' + ++this._cnt;\n      } while (m[tid]);\n\n      data.id = data.li_attr.id ? data.li_attr.id.toString() : tid;\n\n      if (tmp.length) {\n        tmp.each($.proxy(function (i, v) {\n          c = this._parse_model_from_html($(v), data.id, ps);\n          e = this._model.data[c];\n          data.children.push(c);\n\n          if (e.children_d.length) {\n            data.children_d = data.children_d.concat(e.children_d);\n          }\n        }, this));\n        data.children_d = data.children_d.concat(data.children);\n      } else {\n        if (d.hasClass('jstree-closed')) {\n          data.state.loaded = false;\n        }\n      }\n\n      if (data.li_attr['class']) {\n        data.li_attr['class'] = data.li_attr['class'].replace('jstree-closed', '').replace('jstree-open', '');\n      }\n\n      if (data.a_attr['class']) {\n        data.a_attr['class'] = data.a_attr['class'].replace('jstree-clicked', '').replace('jstree-disabled', '');\n      }\n\n      m[data.id] = data;\n\n      if (data.state.selected) {\n        this._data.core.selected.push(data.id);\n      }\n\n      return data.id;\n    },\n\n    /**\n     * parses a node from a JSON object (used when dealing with flat data, which has no nesting of children, but has id and parent properties) and appends it to the in memory tree model. Used internally.\n     * @private\n     * @name _parse_model_from_flat_json(d [, p, ps])\n     * @param  {Object} d the JSON object to parse\n     * @param  {String} p the parent ID\n     * @param  {Array} ps list of all parents\n     * @return {String} the ID of the object added to the model\n     */\n    _parse_model_from_flat_json: function _parse_model_from_flat_json(d, p, ps) {\n      if (!ps) {\n        ps = [];\n      } else {\n        ps = ps.concat();\n      }\n\n      if (p) {\n        ps.unshift(p);\n      }\n\n      var tid = d.id.toString(),\n          m = this._model.data,\n          df = this._model.default_state,\n          i,\n          j,\n          c,\n          e,\n          tmp = {\n        id: tid,\n        text: d.text || '',\n        icon: d.icon !== undefined ? d.icon : true,\n        parent: p,\n        parents: ps,\n        children: d.children || [],\n        children_d: d.children_d || [],\n        data: d.data,\n        state: {},\n        li_attr: {\n          id: false\n        },\n        a_attr: {\n          href: '#'\n        },\n        original: false\n      };\n\n      for (i in df) {\n        if (df.hasOwnProperty(i)) {\n          tmp.state[i] = df[i];\n        }\n      }\n\n      if (d && d.data && d.data.jstree && d.data.jstree.icon) {\n        tmp.icon = d.data.jstree.icon;\n      }\n\n      if (tmp.icon === undefined || tmp.icon === null || tmp.icon === \"\") {\n        tmp.icon = true;\n      }\n\n      if (d && d.data) {\n        tmp.data = d.data;\n\n        if (d.data.jstree) {\n          for (i in d.data.jstree) {\n            if (d.data.jstree.hasOwnProperty(i)) {\n              tmp.state[i] = d.data.jstree[i];\n            }\n          }\n        }\n      }\n\n      if (d && _typeof(d.state) === 'object') {\n        for (i in d.state) {\n          if (d.state.hasOwnProperty(i)) {\n            tmp.state[i] = d.state[i];\n          }\n        }\n      }\n\n      if (d && _typeof(d.li_attr) === 'object') {\n        for (i in d.li_attr) {\n          if (d.li_attr.hasOwnProperty(i)) {\n            tmp.li_attr[i] = d.li_attr[i];\n          }\n        }\n      }\n\n      if (!tmp.li_attr.id) {\n        tmp.li_attr.id = tid;\n      }\n\n      if (d && _typeof(d.a_attr) === 'object') {\n        for (i in d.a_attr) {\n          if (d.a_attr.hasOwnProperty(i)) {\n            tmp.a_attr[i] = d.a_attr[i];\n          }\n        }\n      }\n\n      if (d && d.children && d.children === true) {\n        tmp.state.loaded = false;\n        tmp.children = [];\n        tmp.children_d = [];\n      }\n\n      m[tmp.id] = tmp;\n\n      for (i = 0, j = tmp.children.length; i < j; i++) {\n        c = this._parse_model_from_flat_json(m[tmp.children[i]], tmp.id, ps);\n        e = m[c];\n        tmp.children_d.push(c);\n\n        if (e.children_d.length) {\n          tmp.children_d = tmp.children_d.concat(e.children_d);\n        }\n      }\n\n      delete d.data;\n      delete d.children;\n      m[tmp.id].original = d;\n\n      if (tmp.state.selected) {\n        this._data.core.selected.push(tmp.id);\n      }\n\n      return tmp.id;\n    },\n\n    /**\n     * parses a node from a JSON object and appends it to the in memory tree model. Used internally.\n     * @private\n     * @name _parse_model_from_json(d [, p, ps])\n     * @param  {Object} d the JSON object to parse\n     * @param  {String} p the parent ID\n     * @param  {Array} ps list of all parents\n     * @return {String} the ID of the object added to the model\n     */\n    _parse_model_from_json: function _parse_model_from_json(d, p, ps) {\n      if (!ps) {\n        ps = [];\n      } else {\n        ps = ps.concat();\n      }\n\n      if (p) {\n        ps.unshift(p);\n      }\n\n      var tid = false,\n          i,\n          j,\n          c,\n          e,\n          m = this._model.data,\n          df = this._model.default_state,\n          tmp;\n\n      do {\n        tid = 'j' + this._id + '_' + ++this._cnt;\n      } while (m[tid]);\n\n      tmp = {\n        id: false,\n        text: typeof d === 'string' ? d : '',\n        icon: _typeof(d) === 'object' && d.icon !== undefined ? d.icon : true,\n        parent: p,\n        parents: ps,\n        children: [],\n        children_d: [],\n        data: null,\n        state: {},\n        li_attr: {\n          id: false\n        },\n        a_attr: {\n          href: '#'\n        },\n        original: false\n      };\n\n      for (i in df) {\n        if (df.hasOwnProperty(i)) {\n          tmp.state[i] = df[i];\n        }\n      }\n\n      if (d && d.id) {\n        tmp.id = d.id.toString();\n      }\n\n      if (d && d.text) {\n        tmp.text = d.text;\n      }\n\n      if (d && d.data && d.data.jstree && d.data.jstree.icon) {\n        tmp.icon = d.data.jstree.icon;\n      }\n\n      if (tmp.icon === undefined || tmp.icon === null || tmp.icon === \"\") {\n        tmp.icon = true;\n      }\n\n      if (d && d.data) {\n        tmp.data = d.data;\n\n        if (d.data.jstree) {\n          for (i in d.data.jstree) {\n            if (d.data.jstree.hasOwnProperty(i)) {\n              tmp.state[i] = d.data.jstree[i];\n            }\n          }\n        }\n      }\n\n      if (d && _typeof(d.state) === 'object') {\n        for (i in d.state) {\n          if (d.state.hasOwnProperty(i)) {\n            tmp.state[i] = d.state[i];\n          }\n        }\n      }\n\n      if (d && _typeof(d.li_attr) === 'object') {\n        for (i in d.li_attr) {\n          if (d.li_attr.hasOwnProperty(i)) {\n            tmp.li_attr[i] = d.li_attr[i];\n          }\n        }\n      }\n\n      if (tmp.li_attr.id && !tmp.id) {\n        tmp.id = tmp.li_attr.id.toString();\n      }\n\n      if (!tmp.id) {\n        tmp.id = tid;\n      }\n\n      if (!tmp.li_attr.id) {\n        tmp.li_attr.id = tmp.id;\n      }\n\n      if (d && _typeof(d.a_attr) === 'object') {\n        for (i in d.a_attr) {\n          if (d.a_attr.hasOwnProperty(i)) {\n            tmp.a_attr[i] = d.a_attr[i];\n          }\n        }\n      }\n\n      if (d && d.children && d.children.length) {\n        for (i = 0, j = d.children.length; i < j; i++) {\n          c = this._parse_model_from_json(d.children[i], tmp.id, ps);\n          e = m[c];\n          tmp.children.push(c);\n\n          if (e.children_d.length) {\n            tmp.children_d = tmp.children_d.concat(e.children_d);\n          }\n        }\n\n        tmp.children_d = tmp.children_d.concat(tmp.children);\n      }\n\n      if (d && d.children && d.children === true) {\n        tmp.state.loaded = false;\n        tmp.children = [];\n        tmp.children_d = [];\n      }\n\n      delete d.data;\n      delete d.children;\n      tmp.original = d;\n      m[tmp.id] = tmp;\n\n      if (tmp.state.selected) {\n        this._data.core.selected.push(tmp.id);\n      }\n\n      return tmp.id;\n    },\n\n    /**\n     * redraws all nodes that need to be redrawn. Used internally.\n     * @private\n     * @name _redraw()\n     * @trigger redraw.jstree\n     */\n    _redraw: function _redraw() {\n      var nodes = this._model.force_full_redraw ? this._model.data[$.jstree.root].children.concat([]) : this._model.changed.concat([]),\n          f = document.createElement('UL'),\n          tmp,\n          i,\n          j,\n          fe = this._data.core.focused;\n\n      for (i = 0, j = nodes.length; i < j; i++) {\n        tmp = this.redraw_node(nodes[i], true, this._model.force_full_redraw);\n\n        if (tmp && this._model.force_full_redraw) {\n          f.appendChild(tmp);\n        }\n      }\n\n      if (this._model.force_full_redraw) {\n        f.className = this.get_container_ul()[0].className;\n        f.setAttribute('role', 'group');\n        this.element.empty().append(f); //this.get_container_ul()[0].appendChild(f);\n      }\n\n      if (fe !== null) {\n        tmp = this.get_node(fe, true);\n\n        if (tmp && tmp.length && tmp.children('.jstree-anchor')[0] !== document.activeElement) {\n          tmp.children('.jstree-anchor').focus();\n        } else {\n          this._data.core.focused = null;\n        }\n      }\n\n      this._model.force_full_redraw = false;\n      this._model.changed = [];\n      /**\n       * triggered after nodes are redrawn\n       * @event\n       * @name redraw.jstree\n       * @param {array} nodes the redrawn nodes\n       */\n\n      this.trigger('redraw', {\n        \"nodes\": nodes\n      });\n    },\n\n    /**\n     * redraws all nodes that need to be redrawn or optionally - the whole tree\n     * @name redraw([full])\n     * @param {Boolean} full if set to `true` all nodes are redrawn.\n     */\n    redraw: function redraw(full) {\n      if (full) {\n        this._model.force_full_redraw = true;\n      } //if(this._model.redraw_timeout) {\n      //\tclearTimeout(this._model.redraw_timeout);\n      //}\n      //this._model.redraw_timeout = setTimeout($.proxy(this._redraw, this),0);\n\n\n      this._redraw();\n    },\n\n    /**\n     * redraws a single node's children. Used internally.\n     * @private\n     * @name draw_children(node)\n     * @param {mixed} node the node whose children will be redrawn\n     */\n    draw_children: function draw_children(node) {\n      var obj = this.get_node(node),\n          i = false,\n          j = false,\n          k = false,\n          d = document;\n\n      if (!obj) {\n        return false;\n      }\n\n      if (obj.id === $.jstree.root) {\n        return this.redraw(true);\n      }\n\n      node = this.get_node(node, true);\n\n      if (!node || !node.length) {\n        return false;\n      } // TODO: quick toggle\n\n\n      node.children('.jstree-children').remove();\n      node = node[0];\n\n      if (obj.children.length && obj.state.loaded) {\n        k = d.createElement('UL');\n        k.setAttribute('role', 'group');\n        k.className = 'jstree-children';\n\n        for (i = 0, j = obj.children.length; i < j; i++) {\n          k.appendChild(this.redraw_node(obj.children[i], true, true));\n        }\n\n        node.appendChild(k);\n      }\n    },\n\n    /**\n     * redraws a single node. Used internally.\n     * @private\n     * @name redraw_node(node, deep, is_callback, force_render)\n     * @param {mixed} node the node to redraw\n     * @param {Boolean} deep should child nodes be redrawn too\n     * @param {Boolean} is_callback is this a recursion call\n     * @param {Boolean} force_render should children of closed parents be drawn anyway\n     */\n    redraw_node: function redraw_node(node, deep, is_callback, force_render) {\n      var obj = this.get_node(node),\n          par = false,\n          ind = false,\n          old = false,\n          i = false,\n          j = false,\n          k = false,\n          c = '',\n          d = document,\n          m = this._model.data,\n          f = false,\n          s = false,\n          tmp = null,\n          t = 0,\n          l = 0,\n          has_children = false,\n          last_sibling = false;\n\n      if (!obj) {\n        return false;\n      }\n\n      if (obj.id === $.jstree.root) {\n        return this.redraw(true);\n      }\n\n      deep = deep || obj.children.length === 0;\n      node = !document.querySelector ? document.getElementById(obj.id) : this.element[0].querySelector('#' + (\"0123456789\".indexOf(obj.id[0]) !== -1 ? '\\\\3' + obj.id[0] + ' ' + obj.id.substr(1).replace($.jstree.idregex, '\\\\$&') : obj.id.replace($.jstree.idregex, '\\\\$&'))); //, this.element);\n\n      if (!node) {\n        deep = true; //node = d.createElement('LI');\n\n        if (!is_callback) {\n          par = obj.parent !== $.jstree.root ? $('#' + obj.parent.replace($.jstree.idregex, '\\\\$&'), this.element)[0] : null;\n\n          if (par !== null && (!par || !m[obj.parent].state.opened)) {\n            return false;\n          }\n\n          ind = $.inArray(obj.id, par === null ? m[$.jstree.root].children : m[obj.parent].children);\n        }\n      } else {\n        node = $(node);\n\n        if (!is_callback) {\n          par = node.parent().parent()[0];\n\n          if (par === this.element[0]) {\n            par = null;\n          }\n\n          ind = node.index();\n        } // m[obj.id].data = node.data(); // use only node's data, no need to touch jquery storage\n\n\n        if (!deep && obj.children.length && !node.children('.jstree-children').length) {\n          deep = true;\n        }\n\n        if (!deep) {\n          old = node.children('.jstree-children')[0];\n        }\n\n        f = node.children('.jstree-anchor')[0] === document.activeElement;\n        node.remove(); //node = d.createElement('LI');\n        //node = node[0];\n      }\n\n      node = this._data.core.node.cloneNode(true); // node is DOM, deep is boolean\n\n      c = 'jstree-node ';\n\n      for (i in obj.li_attr) {\n        if (obj.li_attr.hasOwnProperty(i)) {\n          if (i === 'id') {\n            continue;\n          }\n\n          if (i !== 'class') {\n            node.setAttribute(i, obj.li_attr[i]);\n          } else {\n            c += obj.li_attr[i];\n          }\n        }\n      }\n\n      if (!obj.a_attr.id) {\n        obj.a_attr.id = obj.id + '_anchor';\n      }\n\n      node.setAttribute('aria-selected', !!obj.state.selected);\n      node.setAttribute('aria-level', obj.parents.length);\n      node.setAttribute('aria-labelledby', obj.a_attr.id);\n\n      if (obj.state.disabled) {\n        node.setAttribute('aria-disabled', true);\n      }\n\n      for (i = 0, j = obj.children.length; i < j; i++) {\n        if (!m[obj.children[i]].state.hidden) {\n          has_children = true;\n          break;\n        }\n      }\n\n      if (obj.parent !== null && m[obj.parent] && !obj.state.hidden) {\n        i = $.inArray(obj.id, m[obj.parent].children);\n        last_sibling = obj.id;\n\n        if (i !== -1) {\n          i++;\n\n          for (j = m[obj.parent].children.length; i < j; i++) {\n            if (!m[m[obj.parent].children[i]].state.hidden) {\n              last_sibling = m[obj.parent].children[i];\n            }\n\n            if (last_sibling !== obj.id) {\n              break;\n            }\n          }\n        }\n      }\n\n      if (obj.state.hidden) {\n        c += ' jstree-hidden';\n      }\n\n      if (obj.state.loaded && !has_children) {\n        c += ' jstree-leaf';\n      } else {\n        c += obj.state.opened && obj.state.loaded ? ' jstree-open' : ' jstree-closed';\n        node.setAttribute('aria-expanded', obj.state.opened && obj.state.loaded);\n      }\n\n      if (last_sibling === obj.id) {\n        c += ' jstree-last';\n      }\n\n      node.id = obj.id;\n      node.className = c;\n      c = (obj.state.selected ? ' jstree-clicked' : '') + (obj.state.disabled ? ' jstree-disabled' : '');\n\n      for (j in obj.a_attr) {\n        if (obj.a_attr.hasOwnProperty(j)) {\n          if (j === 'href' && obj.a_attr[j] === '#') {\n            continue;\n          }\n\n          if (j !== 'class') {\n            node.childNodes[1].setAttribute(j, obj.a_attr[j]);\n          } else {\n            c += ' ' + obj.a_attr[j];\n          }\n        }\n      }\n\n      if (c.length) {\n        node.childNodes[1].className = 'jstree-anchor ' + c;\n      }\n\n      if (obj.icon && obj.icon !== true || obj.icon === false) {\n        if (obj.icon === false) {\n          node.childNodes[1].childNodes[0].className += ' jstree-themeicon-hidden';\n        } else if (obj.icon.indexOf('/') === -1 && obj.icon.indexOf('.') === -1) {\n          node.childNodes[1].childNodes[0].className += ' ' + obj.icon + ' jstree-themeicon-custom';\n        } else {\n          node.childNodes[1].childNodes[0].style.backgroundImage = 'url(\"' + obj.icon + '\")';\n          node.childNodes[1].childNodes[0].style.backgroundPosition = 'center center';\n          node.childNodes[1].childNodes[0].style.backgroundSize = 'auto';\n          node.childNodes[1].childNodes[0].className += ' jstree-themeicon-custom';\n        }\n      }\n\n      if (this.settings.core.force_text) {\n        node.childNodes[1].appendChild(d.createTextNode(obj.text));\n      } else {\n        node.childNodes[1].innerHTML += obj.text;\n      }\n\n      if (deep && obj.children.length && (obj.state.opened || force_render) && obj.state.loaded) {\n        k = d.createElement('UL');\n        k.setAttribute('role', 'group');\n        k.className = 'jstree-children';\n\n        for (i = 0, j = obj.children.length; i < j; i++) {\n          k.appendChild(this.redraw_node(obj.children[i], deep, true));\n        }\n\n        node.appendChild(k);\n      }\n\n      if (old) {\n        node.appendChild(old);\n      }\n\n      if (!is_callback) {\n        // append back using par / ind\n        if (!par) {\n          par = this.element[0];\n        }\n\n        for (i = 0, j = par.childNodes.length; i < j; i++) {\n          if (par.childNodes[i] && par.childNodes[i].className && par.childNodes[i].className.indexOf('jstree-children') !== -1) {\n            tmp = par.childNodes[i];\n            break;\n          }\n        }\n\n        if (!tmp) {\n          tmp = d.createElement('UL');\n          tmp.setAttribute('role', 'group');\n          tmp.className = 'jstree-children';\n          par.appendChild(tmp);\n        }\n\n        par = tmp;\n\n        if (ind < par.childNodes.length) {\n          par.insertBefore(node, par.childNodes[ind]);\n        } else {\n          par.appendChild(node);\n        }\n\n        if (f) {\n          t = this.element[0].scrollTop;\n          l = this.element[0].scrollLeft;\n          node.childNodes[1].focus();\n          this.element[0].scrollTop = t;\n          this.element[0].scrollLeft = l;\n        }\n      }\n\n      if (obj.state.opened && !obj.state.loaded) {\n        obj.state.opened = false;\n        setTimeout($.proxy(function () {\n          this.open_node(obj.id, false, 0);\n        }, this), 0);\n      }\n\n      return node;\n    },\n\n    /**\n     * opens a node, revaling its children. If the node is not loaded it will be loaded and opened once ready.\n     * @name open_node(obj [, callback, animation])\n     * @param {mixed} obj the node to open\n     * @param {Function} callback a function to execute once the node is opened\n     * @param {Number} animation the animation duration in milliseconds when opening the node (overrides the `core.animation` setting). Use `false` for no animation.\n     * @trigger open_node.jstree, after_open.jstree, before_open.jstree\n     */\n    open_node: function open_node(obj, callback, animation) {\n      var t1, t2, d, t;\n\n      if ($.isArray(obj)) {\n        obj = obj.slice();\n\n        for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n          this.open_node(obj[t1], callback, animation);\n        }\n\n        return true;\n      }\n\n      obj = this.get_node(obj);\n\n      if (!obj || obj.id === $.jstree.root) {\n        return false;\n      }\n\n      animation = animation === undefined ? this.settings.core.animation : animation;\n\n      if (!this.is_closed(obj)) {\n        if (callback) {\n          callback.call(this, obj, false);\n        }\n\n        return false;\n      }\n\n      if (!this.is_loaded(obj)) {\n        if (this.is_loading(obj)) {\n          return setTimeout($.proxy(function () {\n            this.open_node(obj, callback, animation);\n          }, this), 500);\n        }\n\n        this.load_node(obj, function (o, ok) {\n          return ok ? this.open_node(o, callback, animation) : callback ? callback.call(this, o, false) : false;\n        });\n      } else {\n        d = this.get_node(obj, true);\n        t = this;\n\n        if (d.length) {\n          if (animation && d.children(\".jstree-children\").length) {\n            d.children(\".jstree-children\").stop(true, true);\n          }\n\n          if (obj.children.length && !this._firstChild(d.children('.jstree-children')[0])) {\n            this.draw_children(obj); //d = this.get_node(obj, true);\n          }\n\n          if (!animation) {\n            this.trigger('before_open', {\n              \"node\": obj\n            });\n            d[0].className = d[0].className.replace('jstree-closed', 'jstree-open');\n            d[0].setAttribute(\"aria-expanded\", true);\n          } else {\n            this.trigger('before_open', {\n              \"node\": obj\n            });\n            d.children(\".jstree-children\").css(\"display\", \"none\").end().removeClass(\"jstree-closed\").addClass(\"jstree-open\").attr(\"aria-expanded\", true).children(\".jstree-children\").stop(true, true).slideDown(animation, function () {\n              this.style.display = \"\";\n\n              if (t.element) {\n                t.trigger(\"after_open\", {\n                  \"node\": obj\n                });\n              }\n            });\n          }\n        }\n\n        obj.state.opened = true;\n\n        if (callback) {\n          callback.call(this, obj, true);\n        }\n\n        if (!d.length) {\n          /**\n           * triggered when a node is about to be opened (if the node is supposed to be in the DOM, it will be, but it won't be visible yet)\n           * @event\n           * @name before_open.jstree\n           * @param {Object} node the opened node\n           */\n          this.trigger('before_open', {\n            \"node\": obj\n          });\n        }\n        /**\n         * triggered when a node is opened (if there is an animation it will not be completed yet)\n         * @event\n         * @name open_node.jstree\n         * @param {Object} node the opened node\n         */\n\n\n        this.trigger('open_node', {\n          \"node\": obj\n        });\n\n        if (!animation || !d.length) {\n          /**\n           * triggered when a node is opened and the animation is complete\n           * @event\n           * @name after_open.jstree\n           * @param {Object} node the opened node\n           */\n          this.trigger(\"after_open\", {\n            \"node\": obj\n          });\n        }\n\n        return true;\n      }\n    },\n\n    /**\n     * opens every parent of a node (node should be loaded)\n     * @name _open_to(obj)\n     * @param {mixed} obj the node to reveal\n     * @private\n     */\n    _open_to: function _open_to(obj) {\n      obj = this.get_node(obj);\n\n      if (!obj || obj.id === $.jstree.root) {\n        return false;\n      }\n\n      var i,\n          j,\n          p = obj.parents;\n\n      for (i = 0, j = p.length; i < j; i += 1) {\n        if (i !== $.jstree.root) {\n          this.open_node(p[i], false, 0);\n        }\n      }\n\n      return $('#' + obj.id.replace($.jstree.idregex, '\\\\$&'), this.element);\n    },\n\n    /**\n     * closes a node, hiding its children\n     * @name close_node(obj [, animation])\n     * @param {mixed} obj the node to close\n     * @param {Number} animation the animation duration in milliseconds when closing the node (overrides the `core.animation` setting). Use `false` for no animation.\n     * @trigger close_node.jstree, after_close.jstree\n     */\n    close_node: function close_node(obj, animation) {\n      var t1, t2, t, d;\n\n      if ($.isArray(obj)) {\n        obj = obj.slice();\n\n        for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n          this.close_node(obj[t1], animation);\n        }\n\n        return true;\n      }\n\n      obj = this.get_node(obj);\n\n      if (!obj || obj.id === $.jstree.root) {\n        return false;\n      }\n\n      if (this.is_closed(obj)) {\n        return false;\n      }\n\n      animation = animation === undefined ? this.settings.core.animation : animation;\n      t = this;\n      d = this.get_node(obj, true);\n      obj.state.opened = false;\n      /**\n       * triggered when a node is closed (if there is an animation it will not be complete yet)\n       * @event\n       * @name close_node.jstree\n       * @param {Object} node the closed node\n       */\n\n      this.trigger('close_node', {\n        \"node\": obj\n      });\n\n      if (!d.length) {\n        /**\n         * triggered when a node is closed and the animation is complete\n         * @event\n         * @name after_close.jstree\n         * @param {Object} node the closed node\n         */\n        this.trigger(\"after_close\", {\n          \"node\": obj\n        });\n      } else {\n        if (!animation) {\n          d[0].className = d[0].className.replace('jstree-open', 'jstree-closed');\n          d.attr(\"aria-expanded\", false).children('.jstree-children').remove();\n          this.trigger(\"after_close\", {\n            \"node\": obj\n          });\n        } else {\n          d.children(\".jstree-children\").attr(\"style\", \"display:block !important\").end().removeClass(\"jstree-open\").addClass(\"jstree-closed\").attr(\"aria-expanded\", false).children(\".jstree-children\").stop(true, true).slideUp(animation, function () {\n            this.style.display = \"\";\n            d.children('.jstree-children').remove();\n\n            if (t.element) {\n              t.trigger(\"after_close\", {\n                \"node\": obj\n              });\n            }\n          });\n        }\n      }\n    },\n\n    /**\n     * toggles a node - closing it if it is open, opening it if it is closed\n     * @name toggle_node(obj)\n     * @param {mixed} obj the node to toggle\n     */\n    toggle_node: function toggle_node(obj) {\n      var t1, t2;\n\n      if ($.isArray(obj)) {\n        obj = obj.slice();\n\n        for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n          this.toggle_node(obj[t1]);\n        }\n\n        return true;\n      }\n\n      if (this.is_closed(obj)) {\n        return this.open_node(obj);\n      }\n\n      if (this.is_open(obj)) {\n        return this.close_node(obj);\n      }\n    },\n\n    /**\n     * opens all nodes within a node (or the tree), revaling their children. If the node is not loaded it will be loaded and opened once ready.\n     * @name open_all([obj, animation, original_obj])\n     * @param {mixed} obj the node to open recursively, omit to open all nodes in the tree\n     * @param {Number} animation the animation duration in milliseconds when opening the nodes, the default is no animation\n     * @param {jQuery} reference to the node that started the process (internal use)\n     * @trigger open_all.jstree\n     */\n    open_all: function open_all(obj, animation, original_obj) {\n      if (!obj) {\n        obj = $.jstree.root;\n      }\n\n      obj = this.get_node(obj);\n\n      if (!obj) {\n        return false;\n      }\n\n      var dom = obj.id === $.jstree.root ? this.get_container_ul() : this.get_node(obj, true),\n          i,\n          j,\n          _this;\n\n      if (!dom.length) {\n        for (i = 0, j = obj.children_d.length; i < j; i++) {\n          if (this.is_closed(this._model.data[obj.children_d[i]])) {\n            this._model.data[obj.children_d[i]].state.opened = true;\n          }\n        }\n\n        return this.trigger('open_all', {\n          \"node\": obj\n        });\n      }\n\n      original_obj = original_obj || dom;\n      _this = this;\n      dom = this.is_closed(obj) ? dom.find('.jstree-closed').addBack() : dom.find('.jstree-closed');\n      dom.each(function () {\n        _this.open_node(this, function (node, status) {\n          if (status && this.is_parent(node)) {\n            this.open_all(node, animation, original_obj);\n          }\n        }, animation || 0);\n      });\n\n      if (original_obj.find('.jstree-closed').length === 0) {\n        /**\n         * triggered when an `open_all` call completes\n         * @event\n         * @name open_all.jstree\n         * @param {Object} node the opened node\n         */\n        this.trigger('open_all', {\n          \"node\": this.get_node(original_obj)\n        });\n      }\n    },\n\n    /**\n     * closes all nodes within a node (or the tree), revaling their children\n     * @name close_all([obj, animation])\n     * @param {mixed} obj the node to close recursively, omit to close all nodes in the tree\n     * @param {Number} animation the animation duration in milliseconds when closing the nodes, the default is no animation\n     * @trigger close_all.jstree\n     */\n    close_all: function close_all(obj, animation) {\n      if (!obj) {\n        obj = $.jstree.root;\n      }\n\n      obj = this.get_node(obj);\n\n      if (!obj) {\n        return false;\n      }\n\n      var dom = obj.id === $.jstree.root ? this.get_container_ul() : this.get_node(obj, true),\n          _this = this,\n          i,\n          j;\n\n      if (dom.length) {\n        dom = this.is_open(obj) ? dom.find('.jstree-open').addBack() : dom.find('.jstree-open');\n        $(dom.get().reverse()).each(function () {\n          _this.close_node(this, animation || 0);\n        });\n      }\n\n      for (i = 0, j = obj.children_d.length; i < j; i++) {\n        this._model.data[obj.children_d[i]].state.opened = false;\n      }\n      /**\n       * triggered when an `close_all` call completes\n       * @event\n       * @name close_all.jstree\n       * @param {Object} node the closed node\n       */\n\n\n      this.trigger('close_all', {\n        \"node\": obj\n      });\n    },\n\n    /**\n     * checks if a node is disabled (not selectable)\n     * @name is_disabled(obj)\n     * @param  {mixed} obj\n     * @return {Boolean}\n     */\n    is_disabled: function is_disabled(obj) {\n      obj = this.get_node(obj);\n      return obj && obj.state && obj.state.disabled;\n    },\n\n    /**\n     * enables a node - so that it can be selected\n     * @name enable_node(obj)\n     * @param {mixed} obj the node to enable\n     * @trigger enable_node.jstree\n     */\n    enable_node: function enable_node(obj) {\n      var t1, t2;\n\n      if ($.isArray(obj)) {\n        obj = obj.slice();\n\n        for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n          this.enable_node(obj[t1]);\n        }\n\n        return true;\n      }\n\n      obj = this.get_node(obj);\n\n      if (!obj || obj.id === $.jstree.root) {\n        return false;\n      }\n\n      obj.state.disabled = false;\n      this.get_node(obj, true).children('.jstree-anchor').removeClass('jstree-disabled').attr('aria-disabled', false);\n      /**\n       * triggered when an node is enabled\n       * @event\n       * @name enable_node.jstree\n       * @param {Object} node the enabled node\n       */\n\n      this.trigger('enable_node', {\n        'node': obj\n      });\n    },\n\n    /**\n     * disables a node - so that it can not be selected\n     * @name disable_node(obj)\n     * @param {mixed} obj the node to disable\n     * @trigger disable_node.jstree\n     */\n    disable_node: function disable_node(obj) {\n      var t1, t2;\n\n      if ($.isArray(obj)) {\n        obj = obj.slice();\n\n        for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n          this.disable_node(obj[t1]);\n        }\n\n        return true;\n      }\n\n      obj = this.get_node(obj);\n\n      if (!obj || obj.id === $.jstree.root) {\n        return false;\n      }\n\n      obj.state.disabled = true;\n      this.get_node(obj, true).children('.jstree-anchor').addClass('jstree-disabled').attr('aria-disabled', true);\n      /**\n       * triggered when an node is disabled\n       * @event\n       * @name disable_node.jstree\n       * @param {Object} node the disabled node\n       */\n\n      this.trigger('disable_node', {\n        'node': obj\n      });\n    },\n\n    /**\n     * determines if a node is hidden\n     * @name is_hidden(obj)\n     * @param {mixed} obj the node\n     */\n    is_hidden: function is_hidden(obj) {\n      obj = this.get_node(obj);\n      return obj.state.hidden === true;\n    },\n\n    /**\n     * hides a node - it is still in the structure but will not be visible\n     * @name hide_node(obj)\n     * @param {mixed} obj the node to hide\n     * @param {Boolean} skip_redraw internal parameter controlling if redraw is called\n     * @trigger hide_node.jstree\n     */\n    hide_node: function hide_node(obj, skip_redraw) {\n      var t1, t2;\n\n      if ($.isArray(obj)) {\n        obj = obj.slice();\n\n        for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n          this.hide_node(obj[t1], true);\n        }\n\n        if (!skip_redraw) {\n          this.redraw();\n        }\n\n        return true;\n      }\n\n      obj = this.get_node(obj);\n\n      if (!obj || obj.id === $.jstree.root) {\n        return false;\n      }\n\n      if (!obj.state.hidden) {\n        obj.state.hidden = true;\n\n        this._node_changed(obj.parent);\n\n        if (!skip_redraw) {\n          this.redraw();\n        }\n        /**\n         * triggered when an node is hidden\n         * @event\n         * @name hide_node.jstree\n         * @param {Object} node the hidden node\n         */\n\n\n        this.trigger('hide_node', {\n          'node': obj\n        });\n      }\n    },\n\n    /**\n     * shows a node\n     * @name show_node(obj)\n     * @param {mixed} obj the node to show\n     * @param {Boolean} skip_redraw internal parameter controlling if redraw is called\n     * @trigger show_node.jstree\n     */\n    show_node: function show_node(obj, skip_redraw) {\n      var t1, t2;\n\n      if ($.isArray(obj)) {\n        obj = obj.slice();\n\n        for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n          this.show_node(obj[t1], true);\n        }\n\n        if (!skip_redraw) {\n          this.redraw();\n        }\n\n        return true;\n      }\n\n      obj = this.get_node(obj);\n\n      if (!obj || obj.id === $.jstree.root) {\n        return false;\n      }\n\n      if (obj.state.hidden) {\n        obj.state.hidden = false;\n\n        this._node_changed(obj.parent);\n\n        if (!skip_redraw) {\n          this.redraw();\n        }\n        /**\n         * triggered when an node is shown\n         * @event\n         * @name show_node.jstree\n         * @param {Object} node the shown node\n         */\n\n\n        this.trigger('show_node', {\n          'node': obj\n        });\n      }\n    },\n\n    /**\n     * hides all nodes\n     * @name hide_all()\n     * @trigger hide_all.jstree\n     */\n    hide_all: function hide_all(skip_redraw) {\n      var i,\n          m = this._model.data,\n          ids = [];\n\n      for (i in m) {\n        if (m.hasOwnProperty(i) && i !== $.jstree.root && !m[i].state.hidden) {\n          m[i].state.hidden = true;\n          ids.push(i);\n        }\n      }\n\n      this._model.force_full_redraw = true;\n\n      if (!skip_redraw) {\n        this.redraw();\n      }\n      /**\n       * triggered when all nodes are hidden\n       * @event\n       * @name hide_all.jstree\n       * @param {Array} nodes the IDs of all hidden nodes\n       */\n\n\n      this.trigger('hide_all', {\n        'nodes': ids\n      });\n      return ids;\n    },\n\n    /**\n     * shows all nodes\n     * @name show_all()\n     * @trigger show_all.jstree\n     */\n    show_all: function show_all(skip_redraw) {\n      var i,\n          m = this._model.data,\n          ids = [];\n\n      for (i in m) {\n        if (m.hasOwnProperty(i) && i !== $.jstree.root && m[i].state.hidden) {\n          m[i].state.hidden = false;\n          ids.push(i);\n        }\n      }\n\n      this._model.force_full_redraw = true;\n\n      if (!skip_redraw) {\n        this.redraw();\n      }\n      /**\n       * triggered when all nodes are shown\n       * @event\n       * @name show_all.jstree\n       * @param {Array} nodes the IDs of all shown nodes\n       */\n\n\n      this.trigger('show_all', {\n        'nodes': ids\n      });\n      return ids;\n    },\n\n    /**\n     * called when a node is selected by the user. Used internally.\n     * @private\n     * @name activate_node(obj, e)\n     * @param {mixed} obj the node\n     * @param {Object} e the related event\n     * @trigger activate_node.jstree, changed.jstree\n     */\n    activate_node: function activate_node(obj, e) {\n      if (this.is_disabled(obj)) {\n        return false;\n      }\n\n      if (!e || _typeof(e) !== 'object') {\n        e = {};\n      } // ensure last_clicked is still in the DOM, make it fresh (maybe it was moved?) and make sure it is still selected, if not - make last_clicked the last selected node\n\n\n      this._data.core.last_clicked = this._data.core.last_clicked && this._data.core.last_clicked.id !== undefined ? this.get_node(this._data.core.last_clicked.id) : null;\n\n      if (this._data.core.last_clicked && !this._data.core.last_clicked.state.selected) {\n        this._data.core.last_clicked = null;\n      }\n\n      if (!this._data.core.last_clicked && this._data.core.selected.length) {\n        this._data.core.last_clicked = this.get_node(this._data.core.selected[this._data.core.selected.length - 1]);\n      }\n\n      if (!this.settings.core.multiple || !e.metaKey && !e.ctrlKey && !e.shiftKey || e.shiftKey && (!this._data.core.last_clicked || !this.get_parent(obj) || this.get_parent(obj) !== this._data.core.last_clicked.parent)) {\n        if (!this.settings.core.multiple && (e.metaKey || e.ctrlKey || e.shiftKey) && this.is_selected(obj)) {\n          this.deselect_node(obj, false, e);\n        } else {\n          this.deselect_all(true);\n          this.select_node(obj, false, false, e);\n          this._data.core.last_clicked = this.get_node(obj);\n        }\n      } else {\n        if (e.shiftKey) {\n          var o = this.get_node(obj).id,\n              l = this._data.core.last_clicked.id,\n              p = this.get_node(this._data.core.last_clicked.parent).children,\n              c = false,\n              i,\n              j;\n\n          for (i = 0, j = p.length; i < j; i += 1) {\n            // separate IFs work whem o and l are the same\n            if (p[i] === o) {\n              c = !c;\n            }\n\n            if (p[i] === l) {\n              c = !c;\n            }\n\n            if (!this.is_disabled(p[i]) && (c || p[i] === o || p[i] === l)) {\n              if (!this.is_hidden(p[i])) {\n                this.select_node(p[i], true, false, e);\n              }\n            } else {\n              this.deselect_node(p[i], true, e);\n            }\n          }\n\n          this.trigger('changed', {\n            'action': 'select_node',\n            'node': this.get_node(obj),\n            'selected': this._data.core.selected,\n            'event': e\n          });\n        } else {\n          if (!this.is_selected(obj)) {\n            this.select_node(obj, false, false, e);\n          } else {\n            this.deselect_node(obj, false, e);\n          }\n        }\n      }\n      /**\n       * triggered when an node is clicked or intercated with by the user\n       * @event\n       * @name activate_node.jstree\n       * @param {Object} node\n       * @param {Object} event the ooriginal event (if any) which triggered the call (may be an empty object)\n       */\n\n\n      this.trigger('activate_node', {\n        'node': this.get_node(obj),\n        'event': e\n      });\n    },\n\n    /**\n     * applies the hover state on a node, called when a node is hovered by the user. Used internally.\n     * @private\n     * @name hover_node(obj)\n     * @param {mixed} obj\n     * @trigger hover_node.jstree\n     */\n    hover_node: function hover_node(obj) {\n      obj = this.get_node(obj, true);\n\n      if (!obj || !obj.length || obj.children('.jstree-hovered').length) {\n        return false;\n      }\n\n      var o = this.element.find('.jstree-hovered'),\n          t = this.element;\n\n      if (o && o.length) {\n        this.dehover_node(o);\n      }\n\n      obj.children('.jstree-anchor').addClass('jstree-hovered');\n      /**\n       * triggered when an node is hovered\n       * @event\n       * @name hover_node.jstree\n       * @param {Object} node\n       */\n\n      this.trigger('hover_node', {\n        'node': this.get_node(obj)\n      });\n      setTimeout(function () {\n        t.attr('aria-activedescendant', obj[0].id);\n      }, 0);\n    },\n\n    /**\n     * removes the hover state from a nodecalled when a node is no longer hovered by the user. Used internally.\n     * @private\n     * @name dehover_node(obj)\n     * @param {mixed} obj\n     * @trigger dehover_node.jstree\n     */\n    dehover_node: function dehover_node(obj) {\n      obj = this.get_node(obj, true);\n\n      if (!obj || !obj.length || !obj.children('.jstree-hovered').length) {\n        return false;\n      }\n\n      obj.children('.jstree-anchor').removeClass('jstree-hovered');\n      /**\n       * triggered when an node is no longer hovered\n       * @event\n       * @name dehover_node.jstree\n       * @param {Object} node\n       */\n\n      this.trigger('dehover_node', {\n        'node': this.get_node(obj)\n      });\n    },\n\n    /**\n     * select a node\n     * @name select_node(obj [, supress_event, prevent_open])\n     * @param {mixed} obj an array can be used to select multiple nodes\n     * @param {Boolean} supress_event if set to `true` the `changed.jstree` event won't be triggered\n     * @param {Boolean} prevent_open if set to `true` parents of the selected node won't be opened\n     * @trigger select_node.jstree, changed.jstree\n     */\n    select_node: function select_node(obj, supress_event, prevent_open, e) {\n      var dom, t1, t2, th;\n\n      if ($.isArray(obj)) {\n        obj = obj.slice();\n\n        for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n          this.select_node(obj[t1], supress_event, prevent_open, e);\n        }\n\n        return true;\n      }\n\n      obj = this.get_node(obj);\n\n      if (!obj || obj.id === $.jstree.root) {\n        return false;\n      }\n\n      dom = this.get_node(obj, true);\n\n      if (!obj.state.selected) {\n        obj.state.selected = true;\n\n        this._data.core.selected.push(obj.id);\n\n        if (!prevent_open) {\n          dom = this._open_to(obj);\n        }\n\n        if (dom && dom.length) {\n          dom.attr('aria-selected', true).children('.jstree-anchor').addClass('jstree-clicked');\n        }\n        /**\n         * triggered when an node is selected\n         * @event\n         * @name select_node.jstree\n         * @param {Object} node\n         * @param {Array} selected the current selection\n         * @param {Object} event the event (if any) that triggered this select_node\n         */\n\n\n        this.trigger('select_node', {\n          'node': obj,\n          'selected': this._data.core.selected,\n          'event': e\n        });\n\n        if (!supress_event) {\n          /**\n           * triggered when selection changes\n           * @event\n           * @name changed.jstree\n           * @param {Object} node\n           * @param {Object} action the action that caused the selection to change\n           * @param {Array} selected the current selection\n           * @param {Object} event the event (if any) that triggered this changed event\n           */\n          this.trigger('changed', {\n            'action': 'select_node',\n            'node': obj,\n            'selected': this._data.core.selected,\n            'event': e\n          });\n        }\n      }\n    },\n\n    /**\n     * deselect a node\n     * @name deselect_node(obj [, supress_event])\n     * @param {mixed} obj an array can be used to deselect multiple nodes\n     * @param {Boolean} supress_event if set to `true` the `changed.jstree` event won't be triggered\n     * @trigger deselect_node.jstree, changed.jstree\n     */\n    deselect_node: function deselect_node(obj, supress_event, e) {\n      var t1, t2, dom;\n\n      if ($.isArray(obj)) {\n        obj = obj.slice();\n\n        for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n          this.deselect_node(obj[t1], supress_event, e);\n        }\n\n        return true;\n      }\n\n      obj = this.get_node(obj);\n\n      if (!obj || obj.id === $.jstree.root) {\n        return false;\n      }\n\n      dom = this.get_node(obj, true);\n\n      if (obj.state.selected) {\n        obj.state.selected = false;\n        this._data.core.selected = $.vakata.array_remove_item(this._data.core.selected, obj.id);\n\n        if (dom.length) {\n          dom.attr('aria-selected', false).children('.jstree-anchor').removeClass('jstree-clicked');\n        }\n        /**\n         * triggered when an node is deselected\n         * @event\n         * @name deselect_node.jstree\n         * @param {Object} node\n         * @param {Array} selected the current selection\n         * @param {Object} event the event (if any) that triggered this deselect_node\n         */\n\n\n        this.trigger('deselect_node', {\n          'node': obj,\n          'selected': this._data.core.selected,\n          'event': e\n        });\n\n        if (!supress_event) {\n          this.trigger('changed', {\n            'action': 'deselect_node',\n            'node': obj,\n            'selected': this._data.core.selected,\n            'event': e\n          });\n        }\n      }\n    },\n\n    /**\n     * select all nodes in the tree\n     * @name select_all([supress_event])\n     * @param {Boolean} supress_event if set to `true` the `changed.jstree` event won't be triggered\n     * @trigger select_all.jstree, changed.jstree\n     */\n    select_all: function select_all(supress_event) {\n      var tmp = this._data.core.selected.concat([]),\n          i,\n          j;\n\n      this._data.core.selected = this._model.data[$.jstree.root].children_d.concat();\n\n      for (i = 0, j = this._data.core.selected.length; i < j; i++) {\n        if (this._model.data[this._data.core.selected[i]]) {\n          this._model.data[this._data.core.selected[i]].state.selected = true;\n        }\n      }\n\n      this.redraw(true);\n      /**\n       * triggered when all nodes are selected\n       * @event\n       * @name select_all.jstree\n       * @param {Array} selected the current selection\n       */\n\n      this.trigger('select_all', {\n        'selected': this._data.core.selected\n      });\n\n      if (!supress_event) {\n        this.trigger('changed', {\n          'action': 'select_all',\n          'selected': this._data.core.selected,\n          'old_selection': tmp\n        });\n      }\n    },\n\n    /**\n     * deselect all selected nodes\n     * @name deselect_all([supress_event])\n     * @param {Boolean} supress_event if set to `true` the `changed.jstree` event won't be triggered\n     * @trigger deselect_all.jstree, changed.jstree\n     */\n    deselect_all: function deselect_all(supress_event) {\n      var tmp = this._data.core.selected.concat([]),\n          i,\n          j;\n\n      for (i = 0, j = this._data.core.selected.length; i < j; i++) {\n        if (this._model.data[this._data.core.selected[i]]) {\n          this._model.data[this._data.core.selected[i]].state.selected = false;\n        }\n      }\n\n      this._data.core.selected = [];\n      this.element.find('.jstree-clicked').removeClass('jstree-clicked').parent().attr('aria-selected', false);\n      /**\n       * triggered when all nodes are deselected\n       * @event\n       * @name deselect_all.jstree\n       * @param {Object} node the previous selection\n       * @param {Array} selected the current selection\n       */\n\n      this.trigger('deselect_all', {\n        'selected': this._data.core.selected,\n        'node': tmp\n      });\n\n      if (!supress_event) {\n        this.trigger('changed', {\n          'action': 'deselect_all',\n          'selected': this._data.core.selected,\n          'old_selection': tmp\n        });\n      }\n    },\n\n    /**\n     * checks if a node is selected\n     * @name is_selected(obj)\n     * @param  {mixed}  obj\n     * @return {Boolean}\n     */\n    is_selected: function is_selected(obj) {\n      obj = this.get_node(obj);\n\n      if (!obj || obj.id === $.jstree.root) {\n        return false;\n      }\n\n      return obj.state.selected;\n    },\n\n    /**\n     * get an array of all selected nodes\n     * @name get_selected([full])\n     * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned\n     * @return {Array}\n     */\n    get_selected: function get_selected(full) {\n      return full ? $.map(this._data.core.selected, $.proxy(function (i) {\n        return this.get_node(i);\n      }, this)) : this._data.core.selected.slice();\n    },\n\n    /**\n     * get an array of all top level selected nodes (ignoring children of selected nodes)\n     * @name get_top_selected([full])\n     * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned\n     * @return {Array}\n     */\n    get_top_selected: function get_top_selected(full) {\n      var tmp = this.get_selected(true),\n          obj = {},\n          i,\n          j,\n          k,\n          l;\n\n      for (i = 0, j = tmp.length; i < j; i++) {\n        obj[tmp[i].id] = tmp[i];\n      }\n\n      for (i = 0, j = tmp.length; i < j; i++) {\n        for (k = 0, l = tmp[i].children_d.length; k < l; k++) {\n          if (obj[tmp[i].children_d[k]]) {\n            delete obj[tmp[i].children_d[k]];\n          }\n        }\n      }\n\n      tmp = [];\n\n      for (i in obj) {\n        if (obj.hasOwnProperty(i)) {\n          tmp.push(i);\n        }\n      }\n\n      return full ? $.map(tmp, $.proxy(function (i) {\n        return this.get_node(i);\n      }, this)) : tmp;\n    },\n\n    /**\n     * get an array of all bottom level selected nodes (ignoring selected parents)\n     * @name get_bottom_selected([full])\n     * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned\n     * @return {Array}\n     */\n    get_bottom_selected: function get_bottom_selected(full) {\n      var tmp = this.get_selected(true),\n          obj = [],\n          i,\n          j;\n\n      for (i = 0, j = tmp.length; i < j; i++) {\n        if (!tmp[i].children.length) {\n          obj.push(tmp[i].id);\n        }\n      }\n\n      return full ? $.map(obj, $.proxy(function (i) {\n        return this.get_node(i);\n      }, this)) : obj;\n    },\n\n    /**\n     * gets the current state of the tree so that it can be restored later with `set_state(state)`. Used internally.\n     * @name get_state()\n     * @private\n     * @return {Object}\n     */\n    get_state: function get_state() {\n      var state = {\n        'core': {\n          'open': [],\n          'scroll': {\n            'left': this.element.scrollLeft(),\n            'top': this.element.scrollTop()\n          },\n\n          /*!\n          'themes' : {\n          \t'name' : this.get_theme(),\n          \t'icons' : this._data.core.themes.icons,\n          \t'dots' : this._data.core.themes.dots\n          },\n          */\n          'selected': []\n        }\n      },\n          i;\n\n      for (i in this._model.data) {\n        if (this._model.data.hasOwnProperty(i)) {\n          if (i !== $.jstree.root) {\n            if (this._model.data[i].state.opened) {\n              state.core.open.push(i);\n            }\n\n            if (this._model.data[i].state.selected) {\n              state.core.selected.push(i);\n            }\n          }\n        }\n      }\n\n      return state;\n    },\n\n    /**\n     * sets the state of the tree. Used internally.\n     * @name set_state(state [, callback])\n     * @private\n     * @param {Object} state the state to restore. Keep in mind this object is passed by reference and jstree will modify it.\n     * @param {Function} callback an optional function to execute once the state is restored.\n     * @trigger set_state.jstree\n     */\n    set_state: function set_state(state, callback) {\n      if (state) {\n        if (state.core) {\n          var res, n, t, _this, i;\n\n          if (state.core.open) {\n            if (!$.isArray(state.core.open) || !state.core.open.length) {\n              delete state.core.open;\n              this.set_state(state, callback);\n            } else {\n              this._load_nodes(state.core.open, function (nodes) {\n                this.open_node(nodes, false, 0);\n                delete state.core.open;\n                this.set_state(state, callback);\n              });\n            }\n\n            return false;\n          }\n\n          if (state.core.scroll) {\n            if (state.core.scroll && state.core.scroll.left !== undefined) {\n              this.element.scrollLeft(state.core.scroll.left);\n            }\n\n            if (state.core.scroll && state.core.scroll.top !== undefined) {\n              this.element.scrollTop(state.core.scroll.top);\n            }\n\n            delete state.core.scroll;\n            this.set_state(state, callback);\n            return false;\n          }\n\n          if (state.core.selected) {\n            _this = this;\n            this.deselect_all();\n            $.each(state.core.selected, function (i, v) {\n              _this.select_node(v, false, true);\n            });\n            delete state.core.selected;\n            this.set_state(state, callback);\n            return false;\n          }\n\n          for (i in state) {\n            if (state.hasOwnProperty(i) && i !== \"core\" && $.inArray(i, this.settings.plugins) === -1) {\n              delete state[i];\n            }\n          }\n\n          if ($.isEmptyObject(state.core)) {\n            delete state.core;\n            this.set_state(state, callback);\n            return false;\n          }\n        }\n\n        if ($.isEmptyObject(state)) {\n          state = null;\n\n          if (callback) {\n            callback.call(this);\n          }\n          /**\n           * triggered when a `set_state` call completes\n           * @event\n           * @name set_state.jstree\n           */\n\n\n          this.trigger('set_state');\n          return false;\n        }\n\n        return true;\n      }\n\n      return false;\n    },\n\n    /**\n     * refreshes the tree - all nodes are reloaded with calls to `load_node`.\n     * @name refresh()\n     * @param {Boolean} skip_loading an option to skip showing the loading indicator\n     * @param {Mixed} forget_state if set to `true` state will not be reapplied, if set to a function (receiving the current state as argument) the result of that function will be used as state\n     * @trigger refresh.jstree\n     */\n    refresh: function refresh(skip_loading, forget_state) {\n      this._data.core.state = forget_state === true ? {} : this.get_state();\n\n      if (forget_state && $.isFunction(forget_state)) {\n        this._data.core.state = forget_state.call(this, this._data.core.state);\n      }\n\n      this._cnt = 0;\n      this._model.data = {};\n      this._model.data[$.jstree.root] = {\n        id: $.jstree.root,\n        parent: null,\n        parents: [],\n        children: [],\n        children_d: [],\n        state: {\n          loaded: false\n        }\n      };\n      this._data.core.selected = [];\n      this._data.core.last_clicked = null;\n      this._data.core.focused = null;\n      var c = this.get_container_ul()[0].className;\n\n      if (!skip_loading) {\n        this.element.html(\"<\" + \"ul class='\" + c + \"' role='group'><\" + \"li class='jstree-initial-node jstree-loading jstree-leaf jstree-last' role='treeitem' id='j\" + this._id + \"_loading'><i class='jstree-icon jstree-ocl'></i><\" + \"a class='jstree-anchor' href='#'><i class='jstree-icon jstree-themeicon-hidden'></i>\" + this.get_string(\"Loading ...\") + \"</a></li></ul>\");\n        this.element.attr('aria-activedescendant', 'j' + this._id + '_loading');\n      }\n\n      this.load_node($.jstree.root, function (o, s) {\n        if (s) {\n          this.get_container_ul()[0].className = c;\n\n          if (this._firstChild(this.get_container_ul()[0])) {\n            this.element.attr('aria-activedescendant', this._firstChild(this.get_container_ul()[0]).id);\n          }\n\n          this.set_state($.extend(true, {}, this._data.core.state), function () {\n            /**\n             * triggered when a `refresh` call completes\n             * @event\n             * @name refresh.jstree\n             */\n            this.trigger('refresh');\n          });\n        }\n\n        this._data.core.state = null;\n      });\n    },\n\n    /**\n     * refreshes a node in the tree (reload its children) all opened nodes inside that node are reloaded with calls to `load_node`.\n     * @name refresh_node(obj)\n     * @param  {mixed} obj the node\n     * @trigger refresh_node.jstree\n     */\n    refresh_node: function refresh_node(obj) {\n      obj = this.get_node(obj);\n\n      if (!obj || obj.id === $.jstree.root) {\n        return false;\n      }\n\n      var opened = [],\n          to_load = [],\n          s = this._data.core.selected.concat([]);\n\n      to_load.push(obj.id);\n\n      if (obj.state.opened === true) {\n        opened.push(obj.id);\n      }\n\n      this.get_node(obj, true).find('.jstree-open').each(function () {\n        to_load.push(this.id);\n        opened.push(this.id);\n      });\n\n      this._load_nodes(to_load, $.proxy(function (nodes) {\n        this.open_node(opened, false, 0);\n        this.select_node(s);\n        /**\n         * triggered when a node is refreshed\n         * @event\n         * @name refresh_node.jstree\n         * @param {Object} node - the refreshed node\n         * @param {Array} nodes - an array of the IDs of the nodes that were reloaded\n         */\n\n        this.trigger('refresh_node', {\n          'node': obj,\n          'nodes': nodes\n        });\n      }, this), false, true);\n    },\n\n    /**\n     * set (change) the ID of a node\n     * @name set_id(obj, id)\n     * @param  {mixed} obj the node\n     * @param  {String} id the new ID\n     * @return {Boolean}\n     * @trigger set_id.jstree\n     */\n    set_id: function set_id(obj, id) {\n      obj = this.get_node(obj);\n\n      if (!obj || obj.id === $.jstree.root) {\n        return false;\n      }\n\n      var i,\n          j,\n          m = this._model.data,\n          old = obj.id;\n      id = id.toString(); // update parents (replace current ID with new one in children and children_d)\n\n      m[obj.parent].children[$.inArray(obj.id, m[obj.parent].children)] = id;\n\n      for (i = 0, j = obj.parents.length; i < j; i++) {\n        m[obj.parents[i]].children_d[$.inArray(obj.id, m[obj.parents[i]].children_d)] = id;\n      } // update children (replace current ID with new one in parent and parents)\n\n\n      for (i = 0, j = obj.children.length; i < j; i++) {\n        m[obj.children[i]].parent = id;\n      }\n\n      for (i = 0, j = obj.children_d.length; i < j; i++) {\n        m[obj.children_d[i]].parents[$.inArray(obj.id, m[obj.children_d[i]].parents)] = id;\n      }\n\n      i = $.inArray(obj.id, this._data.core.selected);\n\n      if (i !== -1) {\n        this._data.core.selected[i] = id;\n      } // update model and obj itself (obj.id, this._model.data[KEY])\n\n\n      i = this.get_node(obj.id, true);\n\n      if (i) {\n        i.attr('id', id); //.children('.jstree-anchor').attr('id', id + '_anchor').end().attr('aria-labelledby', id + '_anchor');\n\n        if (this.element.attr('aria-activedescendant') === obj.id) {\n          this.element.attr('aria-activedescendant', id);\n        }\n      }\n\n      delete m[obj.id];\n      obj.id = id;\n      obj.li_attr.id = id;\n      m[id] = obj;\n      /**\n       * triggered when a node id value is changed\n       * @event\n       * @name set_id.jstree\n       * @param {Object} node\n       * @param {String} old the old id\n       */\n\n      this.trigger('set_id', {\n        \"node\": obj,\n        \"new\": obj.id,\n        \"old\": old\n      });\n      return true;\n    },\n\n    /**\n     * get the text value of a node\n     * @name get_text(obj)\n     * @param  {mixed} obj the node\n     * @return {String}\n     */\n    get_text: function get_text(obj) {\n      obj = this.get_node(obj);\n      return !obj || obj.id === $.jstree.root ? false : obj.text;\n    },\n\n    /**\n     * set the text value of a node. Used internally, please use `rename_node(obj, val)`.\n     * @private\n     * @name set_text(obj, val)\n     * @param  {mixed} obj the node, you can pass an array to set the text on multiple nodes\n     * @param  {String} val the new text value\n     * @return {Boolean}\n     * @trigger set_text.jstree\n     */\n    set_text: function set_text(obj, val) {\n      var t1, t2;\n\n      if ($.isArray(obj)) {\n        obj = obj.slice();\n\n        for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n          this.set_text(obj[t1], val);\n        }\n\n        return true;\n      }\n\n      obj = this.get_node(obj);\n\n      if (!obj || obj.id === $.jstree.root) {\n        return false;\n      }\n\n      obj.text = val;\n\n      if (this.get_node(obj, true).length) {\n        this.redraw_node(obj.id);\n      }\n      /**\n       * triggered when a node text value is changed\n       * @event\n       * @name set_text.jstree\n       * @param {Object} obj\n       * @param {String} text the new value\n       */\n\n\n      this.trigger('set_text', {\n        \"obj\": obj,\n        \"text\": val\n      });\n      return true;\n    },\n\n    /**\n     * gets a JSON representation of a node (or the whole tree)\n     * @name get_json([obj, options])\n     * @param  {mixed} obj\n     * @param  {Object} options\n     * @param  {Boolean} options.no_state do not return state information\n     * @param  {Boolean} options.no_id do not return ID\n     * @param  {Boolean} options.no_children do not include children\n     * @param  {Boolean} options.no_data do not include node data\n     * @param  {Boolean} options.no_li_attr do not include LI attributes\n     * @param  {Boolean} options.no_a_attr do not include A attributes\n     * @param  {Boolean} options.flat return flat JSON instead of nested\n     * @return {Object}\n     */\n    get_json: function get_json(obj, options, flat) {\n      obj = this.get_node(obj || $.jstree.root);\n\n      if (!obj) {\n        return false;\n      }\n\n      if (options && options.flat && !flat) {\n        flat = [];\n      }\n\n      var tmp = {\n        'id': obj.id,\n        'text': obj.text,\n        'icon': this.get_icon(obj),\n        'li_attr': $.extend(true, {}, obj.li_attr),\n        'a_attr': $.extend(true, {}, obj.a_attr),\n        'state': {},\n        'data': options && options.no_data ? false : $.extend(true, {}, obj.data) //( this.get_node(obj, true).length ? this.get_node(obj, true).data() : obj.data ),\n\n      },\n          i,\n          j;\n\n      if (options && options.flat) {\n        tmp.parent = obj.parent;\n      } else {\n        tmp.children = [];\n      }\n\n      if (!options || !options.no_state) {\n        for (i in obj.state) {\n          if (obj.state.hasOwnProperty(i)) {\n            tmp.state[i] = obj.state[i];\n          }\n        }\n      } else {\n        delete tmp.state;\n      }\n\n      if (options && options.no_li_attr) {\n        delete tmp.li_attr;\n      }\n\n      if (options && options.no_a_attr) {\n        delete tmp.a_attr;\n      }\n\n      if (options && options.no_id) {\n        delete tmp.id;\n\n        if (tmp.li_attr && tmp.li_attr.id) {\n          delete tmp.li_attr.id;\n        }\n\n        if (tmp.a_attr && tmp.a_attr.id) {\n          delete tmp.a_attr.id;\n        }\n      }\n\n      if (options && options.flat && obj.id !== $.jstree.root) {\n        flat.push(tmp);\n      }\n\n      if (!options || !options.no_children) {\n        for (i = 0, j = obj.children.length; i < j; i++) {\n          if (options && options.flat) {\n            this.get_json(obj.children[i], options, flat);\n          } else {\n            tmp.children.push(this.get_json(obj.children[i], options));\n          }\n        }\n      }\n\n      return options && options.flat ? flat : obj.id === $.jstree.root ? tmp.children : tmp;\n    },\n\n    /**\n     * create a new node (do not confuse with load_node)\n     * @name create_node([par, node, pos, callback, is_loaded])\n     * @param  {mixed}   par       the parent node (to create a root node use either \"#\" (string) or `null`)\n     * @param  {mixed}   node      the data for the new node (a valid JSON object, or a simple string with the name)\n     * @param  {mixed}   pos       the index at which to insert the node, \"first\" and \"last\" are also supported, default is \"last\"\n     * @param  {Function} callback a function to be called once the node is created\n     * @param  {Boolean} is_loaded internal argument indicating if the parent node was succesfully loaded\n     * @return {String}            the ID of the newly create node\n     * @trigger model.jstree, create_node.jstree\n     */\n    create_node: function create_node(par, node, pos, callback, is_loaded) {\n      if (par === null) {\n        par = $.jstree.root;\n      }\n\n      par = this.get_node(par);\n\n      if (!par) {\n        return false;\n      }\n\n      pos = pos === undefined ? \"last\" : pos;\n\n      if (!pos.toString().match(/^(before|after)$/) && !is_loaded && !this.is_loaded(par)) {\n        return this.load_node(par, function () {\n          this.create_node(par, node, pos, callback, true);\n        });\n      }\n\n      if (!node) {\n        node = {\n          \"text\": this.get_string('New node')\n        };\n      }\n\n      if (typeof node === \"string\") {\n        node = {\n          \"text\": node\n        };\n      }\n\n      if (node.text === undefined) {\n        node.text = this.get_string('New node');\n      }\n\n      var tmp, dpc, i, j;\n\n      if (par.id === $.jstree.root) {\n        if (pos === \"before\") {\n          pos = \"first\";\n        }\n\n        if (pos === \"after\") {\n          pos = \"last\";\n        }\n      }\n\n      switch (pos) {\n        case \"before\":\n          tmp = this.get_node(par.parent);\n          pos = $.inArray(par.id, tmp.children);\n          par = tmp;\n          break;\n\n        case \"after\":\n          tmp = this.get_node(par.parent);\n          pos = $.inArray(par.id, tmp.children) + 1;\n          par = tmp;\n          break;\n\n        case \"inside\":\n        case \"first\":\n          pos = 0;\n          break;\n\n        case \"last\":\n          pos = par.children.length;\n          break;\n\n        default:\n          if (!pos) {\n            pos = 0;\n          }\n\n          break;\n      }\n\n      if (pos > par.children.length) {\n        pos = par.children.length;\n      }\n\n      if (!node.id) {\n        node.id = true;\n      }\n\n      if (!this.check(\"create_node\", node, par, pos)) {\n        this.settings.core.error.call(this, this._data.core.last_error);\n        return false;\n      }\n\n      if (node.id === true) {\n        delete node.id;\n      }\n\n      node = this._parse_model_from_json(node, par.id, par.parents.concat());\n\n      if (!node) {\n        return false;\n      }\n\n      tmp = this.get_node(node);\n      dpc = [];\n      dpc.push(node);\n      dpc = dpc.concat(tmp.children_d);\n      this.trigger('model', {\n        \"nodes\": dpc,\n        \"parent\": par.id\n      });\n      par.children_d = par.children_d.concat(dpc);\n\n      for (i = 0, j = par.parents.length; i < j; i++) {\n        this._model.data[par.parents[i]].children_d = this._model.data[par.parents[i]].children_d.concat(dpc);\n      }\n\n      node = tmp;\n      tmp = [];\n\n      for (i = 0, j = par.children.length; i < j; i++) {\n        tmp[i >= pos ? i + 1 : i] = par.children[i];\n      }\n\n      tmp[pos] = node.id;\n      par.children = tmp;\n      this.redraw_node(par, true);\n\n      if (callback) {\n        callback.call(this, this.get_node(node));\n      }\n      /**\n       * triggered when a node is created\n       * @event\n       * @name create_node.jstree\n       * @param {Object} node\n       * @param {String} parent the parent's ID\n       * @param {Number} position the position of the new node among the parent's children\n       */\n\n\n      this.trigger('create_node', {\n        \"node\": this.get_node(node),\n        \"parent\": par.id,\n        \"position\": pos\n      });\n      return node.id;\n    },\n\n    /**\n     * set the text value of a node\n     * @name rename_node(obj, val)\n     * @param  {mixed} obj the node, you can pass an array to rename multiple nodes to the same name\n     * @param  {String} val the new text value\n     * @return {Boolean}\n     * @trigger rename_node.jstree\n     */\n    rename_node: function rename_node(obj, val) {\n      var t1, t2, old;\n\n      if ($.isArray(obj)) {\n        obj = obj.slice();\n\n        for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n          this.rename_node(obj[t1], val);\n        }\n\n        return true;\n      }\n\n      obj = this.get_node(obj);\n\n      if (!obj || obj.id === $.jstree.root) {\n        return false;\n      }\n\n      old = obj.text;\n\n      if (!this.check(\"rename_node\", obj, this.get_parent(obj), val)) {\n        this.settings.core.error.call(this, this._data.core.last_error);\n        return false;\n      }\n\n      this.set_text(obj, val); // .apply(this, Array.prototype.slice.call(arguments))\n\n      /**\n       * triggered when a node is renamed\n       * @event\n       * @name rename_node.jstree\n       * @param {Object} node\n       * @param {String} text the new value\n       * @param {String} old the old value\n       */\n\n      this.trigger('rename_node', {\n        \"node\": obj,\n        \"text\": val,\n        \"old\": old\n      });\n      return true;\n    },\n\n    /**\n     * remove a node\n     * @name delete_node(obj)\n     * @param  {mixed} obj the node, you can pass an array to delete multiple nodes\n     * @return {Boolean}\n     * @trigger delete_node.jstree, changed.jstree\n     */\n    delete_node: function delete_node(obj) {\n      var t1, t2, par, pos, tmp, i, j, k, l, c, top, lft;\n\n      if ($.isArray(obj)) {\n        obj = obj.slice();\n\n        for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n          this.delete_node(obj[t1]);\n        }\n\n        return true;\n      }\n\n      obj = this.get_node(obj);\n\n      if (!obj || obj.id === $.jstree.root) {\n        return false;\n      }\n\n      par = this.get_node(obj.parent);\n      pos = $.inArray(obj.id, par.children);\n      c = false;\n\n      if (!this.check(\"delete_node\", obj, par, pos)) {\n        this.settings.core.error.call(this, this._data.core.last_error);\n        return false;\n      }\n\n      if (pos !== -1) {\n        par.children = $.vakata.array_remove(par.children, pos);\n      }\n\n      tmp = obj.children_d.concat([]);\n      tmp.push(obj.id);\n\n      for (i = 0, j = obj.parents.length; i < j; i++) {\n        this._model.data[obj.parents[i]].children_d = $.vakata.array_filter(this._model.data[obj.parents[i]].children_d, function (v) {\n          return $.inArray(v, tmp) === -1;\n        });\n      }\n\n      for (k = 0, l = tmp.length; k < l; k++) {\n        if (this._model.data[tmp[k]].state.selected) {\n          c = true;\n          break;\n        }\n      }\n\n      if (c) {\n        this._data.core.selected = $.vakata.array_filter(this._data.core.selected, function (v) {\n          return $.inArray(v, tmp) === -1;\n        });\n      }\n      /**\n       * triggered when a node is deleted\n       * @event\n       * @name delete_node.jstree\n       * @param {Object} node\n       * @param {String} parent the parent's ID\n       */\n\n\n      this.trigger('delete_node', {\n        \"node\": obj,\n        \"parent\": par.id\n      });\n\n      if (c) {\n        this.trigger('changed', {\n          'action': 'delete_node',\n          'node': obj,\n          'selected': this._data.core.selected,\n          'parent': par.id\n        });\n      }\n\n      for (k = 0, l = tmp.length; k < l; k++) {\n        delete this._model.data[tmp[k]];\n      }\n\n      if ($.inArray(this._data.core.focused, tmp) !== -1) {\n        this._data.core.focused = null;\n        top = this.element[0].scrollTop;\n        lft = this.element[0].scrollLeft;\n\n        if (par.id === $.jstree.root) {\n          if (this._model.data[$.jstree.root].children[0]) {\n            this.get_node(this._model.data[$.jstree.root].children[0], true).children('.jstree-anchor').focus();\n          }\n        } else {\n          this.get_node(par, true).children('.jstree-anchor').focus();\n        }\n\n        this.element[0].scrollTop = top;\n        this.element[0].scrollLeft = lft;\n      }\n\n      this.redraw_node(par, true);\n      return true;\n    },\n\n    /**\n     * check if an operation is premitted on the tree. Used internally.\n     * @private\n     * @name check(chk, obj, par, pos)\n     * @param  {String} chk the operation to check, can be \"create_node\", \"rename_node\", \"delete_node\", \"copy_node\" or \"move_node\"\n     * @param  {mixed} obj the node\n     * @param  {mixed} par the parent\n     * @param  {mixed} pos the position to insert at, or if \"rename_node\" - the new name\n     * @param  {mixed} more some various additional information, for example if a \"move_node\" operations is triggered by DND this will be the hovered node\n     * @return {Boolean}\n     */\n    check: function check(chk, obj, par, pos, more) {\n      obj = obj && obj.id ? obj : this.get_node(obj);\n      par = par && par.id ? par : this.get_node(par);\n      var tmp = chk.match(/^move_node|copy_node|create_node$/i) ? par : obj,\n          chc = this.settings.core.check_callback;\n\n      if (chk === \"move_node\" || chk === \"copy_node\") {\n        if ((!more || !more.is_multi) && (obj.id === par.id || chk === \"move_node\" && $.inArray(obj.id, par.children) === pos || $.inArray(par.id, obj.children_d) !== -1)) {\n          this._data.core.last_error = {\n            'error': 'check',\n            'plugin': 'core',\n            'id': 'core_01',\n            'reason': 'Moving parent inside child',\n            'data': JSON.stringify({\n              'chk': chk,\n              'pos': pos,\n              'obj': obj && obj.id ? obj.id : false,\n              'par': par && par.id ? par.id : false\n            })\n          };\n          return false;\n        }\n      }\n\n      if (tmp && tmp.data) {\n        tmp = tmp.data;\n      }\n\n      if (tmp && tmp.functions && (tmp.functions[chk] === false || tmp.functions[chk] === true)) {\n        if (tmp.functions[chk] === false) {\n          this._data.core.last_error = {\n            'error': 'check',\n            'plugin': 'core',\n            'id': 'core_02',\n            'reason': 'Node data prevents function: ' + chk,\n            'data': JSON.stringify({\n              'chk': chk,\n              'pos': pos,\n              'obj': obj && obj.id ? obj.id : false,\n              'par': par && par.id ? par.id : false\n            })\n          };\n        }\n\n        return tmp.functions[chk];\n      }\n\n      if (chc === false || $.isFunction(chc) && chc.call(this, chk, obj, par, pos, more) === false || chc && chc[chk] === false) {\n        this._data.core.last_error = {\n          'error': 'check',\n          'plugin': 'core',\n          'id': 'core_03',\n          'reason': 'User config for core.check_callback prevents function: ' + chk,\n          'data': JSON.stringify({\n            'chk': chk,\n            'pos': pos,\n            'obj': obj && obj.id ? obj.id : false,\n            'par': par && par.id ? par.id : false\n          })\n        };\n        return false;\n      }\n\n      return true;\n    },\n\n    /**\n     * get the last error\n     * @name last_error()\n     * @return {Object}\n     */\n    last_error: function last_error() {\n      return this._data.core.last_error;\n    },\n\n    /**\n     * move a node to a new parent\n     * @name move_node(obj, par [, pos, callback, is_loaded])\n     * @param  {mixed} obj the node to move, pass an array to move multiple nodes\n     * @param  {mixed} par the new parent\n     * @param  {mixed} pos the position to insert at (besides integer values, \"first\" and \"last\" are supported, as well as \"before\" and \"after\"), defaults to integer `0`\n     * @param  {function} callback a function to call once the move is completed, receives 3 arguments - the node, the new parent and the position\n     * @param  {Boolean} is_loaded internal parameter indicating if the parent node has been loaded\n     * @param  {Boolean} skip_redraw internal parameter indicating if the tree should be redrawn\n     * @param  {Boolean} instance internal parameter indicating if the node comes from another instance\n     * @trigger move_node.jstree\n     */\n    move_node: function move_node(obj, par, pos, callback, is_loaded, skip_redraw, origin) {\n      var t1, t2, old_par, old_pos, new_par, old_ins, is_multi, dpc, tmp, i, j, k, l, p;\n      par = this.get_node(par);\n      pos = pos === undefined ? 0 : pos;\n\n      if (!par) {\n        return false;\n      }\n\n      if (!pos.toString().match(/^(before|after)$/) && !is_loaded && !this.is_loaded(par)) {\n        return this.load_node(par, function () {\n          this.move_node(obj, par, pos, callback, true, false, origin);\n        });\n      }\n\n      if ($.isArray(obj)) {\n        if (obj.length === 1) {\n          obj = obj[0];\n        } else {\n          //obj = obj.slice();\n          for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n            if (tmp = this.move_node(obj[t1], par, pos, callback, is_loaded, false, origin)) {\n              par = tmp;\n              pos = \"after\";\n            }\n          }\n\n          this.redraw();\n          return true;\n        }\n      }\n\n      obj = obj && obj.id ? obj : this.get_node(obj);\n\n      if (!obj || obj.id === $.jstree.root) {\n        return false;\n      }\n\n      old_par = (obj.parent || $.jstree.root).toString();\n      new_par = !pos.toString().match(/^(before|after)$/) || par.id === $.jstree.root ? par : this.get_node(par.parent);\n      old_ins = origin ? origin : this._model.data[obj.id] ? this : $.jstree.reference(obj.id);\n      is_multi = !old_ins || !old_ins._id || this._id !== old_ins._id;\n      old_pos = old_ins && old_ins._id && old_par && old_ins._model.data[old_par] && old_ins._model.data[old_par].children ? $.inArray(obj.id, old_ins._model.data[old_par].children) : -1;\n\n      if (old_ins && old_ins._id) {\n        obj = old_ins._model.data[obj.id];\n      }\n\n      if (is_multi) {\n        if (tmp = this.copy_node(obj, par, pos, callback, is_loaded, false, origin)) {\n          if (old_ins) {\n            old_ins.delete_node(obj);\n          }\n\n          return tmp;\n        }\n\n        return false;\n      } //var m = this._model.data;\n\n\n      if (par.id === $.jstree.root) {\n        if (pos === \"before\") {\n          pos = \"first\";\n        }\n\n        if (pos === \"after\") {\n          pos = \"last\";\n        }\n      }\n\n      switch (pos) {\n        case \"before\":\n          pos = $.inArray(par.id, new_par.children);\n          break;\n\n        case \"after\":\n          pos = $.inArray(par.id, new_par.children) + 1;\n          break;\n\n        case \"inside\":\n        case \"first\":\n          pos = 0;\n          break;\n\n        case \"last\":\n          pos = new_par.children.length;\n          break;\n\n        default:\n          if (!pos) {\n            pos = 0;\n          }\n\n          break;\n      }\n\n      if (pos > new_par.children.length) {\n        pos = new_par.children.length;\n      }\n\n      if (!this.check(\"move_node\", obj, new_par, pos, {\n        'core': true,\n        'origin': origin,\n        'is_multi': old_ins && old_ins._id && old_ins._id !== this._id,\n        'is_foreign': !old_ins || !old_ins._id\n      })) {\n        this.settings.core.error.call(this, this._data.core.last_error);\n        return false;\n      }\n\n      if (obj.parent === new_par.id) {\n        dpc = new_par.children.concat();\n        tmp = $.inArray(obj.id, dpc);\n\n        if (tmp !== -1) {\n          dpc = $.vakata.array_remove(dpc, tmp);\n\n          if (pos > tmp) {\n            pos--;\n          }\n        }\n\n        tmp = [];\n\n        for (i = 0, j = dpc.length; i < j; i++) {\n          tmp[i >= pos ? i + 1 : i] = dpc[i];\n        }\n\n        tmp[pos] = obj.id;\n        new_par.children = tmp;\n\n        this._node_changed(new_par.id);\n\n        this.redraw(new_par.id === $.jstree.root);\n      } else {\n        // clean old parent and up\n        tmp = obj.children_d.concat();\n        tmp.push(obj.id);\n\n        for (i = 0, j = obj.parents.length; i < j; i++) {\n          dpc = [];\n          p = old_ins._model.data[obj.parents[i]].children_d;\n\n          for (k = 0, l = p.length; k < l; k++) {\n            if ($.inArray(p[k], tmp) === -1) {\n              dpc.push(p[k]);\n            }\n          }\n\n          old_ins._model.data[obj.parents[i]].children_d = dpc;\n        }\n\n        old_ins._model.data[old_par].children = $.vakata.array_remove_item(old_ins._model.data[old_par].children, obj.id); // insert into new parent and up\n\n        for (i = 0, j = new_par.parents.length; i < j; i++) {\n          this._model.data[new_par.parents[i]].children_d = this._model.data[new_par.parents[i]].children_d.concat(tmp);\n        }\n\n        dpc = [];\n\n        for (i = 0, j = new_par.children.length; i < j; i++) {\n          dpc[i >= pos ? i + 1 : i] = new_par.children[i];\n        }\n\n        dpc[pos] = obj.id;\n        new_par.children = dpc;\n        new_par.children_d.push(obj.id);\n        new_par.children_d = new_par.children_d.concat(obj.children_d); // update object\n\n        obj.parent = new_par.id;\n        tmp = new_par.parents.concat();\n        tmp.unshift(new_par.id);\n        p = obj.parents.length;\n        obj.parents = tmp; // update object children\n\n        tmp = tmp.concat();\n\n        for (i = 0, j = obj.children_d.length; i < j; i++) {\n          this._model.data[obj.children_d[i]].parents = this._model.data[obj.children_d[i]].parents.slice(0, p * -1);\n          Array.prototype.push.apply(this._model.data[obj.children_d[i]].parents, tmp);\n        }\n\n        if (old_par === $.jstree.root || new_par.id === $.jstree.root) {\n          this._model.force_full_redraw = true;\n        }\n\n        if (!this._model.force_full_redraw) {\n          this._node_changed(old_par);\n\n          this._node_changed(new_par.id);\n        }\n\n        if (!skip_redraw) {\n          this.redraw();\n        }\n      }\n\n      if (callback) {\n        callback.call(this, obj, new_par, pos);\n      }\n      /**\n       * triggered when a node is moved\n       * @event\n       * @name move_node.jstree\n       * @param {Object} node\n       * @param {String} parent the parent's ID\n       * @param {Number} position the position of the node among the parent's children\n       * @param {String} old_parent the old parent of the node\n       * @param {Number} old_position the old position of the node\n       * @param {Boolean} is_multi do the node and new parent belong to different instances\n       * @param {jsTree} old_instance the instance the node came from\n       * @param {jsTree} new_instance the instance of the new parent\n       */\n\n\n      this.trigger('move_node', {\n        \"node\": obj,\n        \"parent\": new_par.id,\n        \"position\": pos,\n        \"old_parent\": old_par,\n        \"old_position\": old_pos,\n        'is_multi': old_ins && old_ins._id && old_ins._id !== this._id,\n        'is_foreign': !old_ins || !old_ins._id,\n        'old_instance': old_ins,\n        'new_instance': this\n      });\n      return obj.id;\n    },\n\n    /**\n     * copy a node to a new parent\n     * @name copy_node(obj, par [, pos, callback, is_loaded])\n     * @param  {mixed} obj the node to copy, pass an array to copy multiple nodes\n     * @param  {mixed} par the new parent\n     * @param  {mixed} pos the position to insert at (besides integer values, \"first\" and \"last\" are supported, as well as \"before\" and \"after\"), defaults to integer `0`\n     * @param  {function} callback a function to call once the move is completed, receives 3 arguments - the node, the new parent and the position\n     * @param  {Boolean} is_loaded internal parameter indicating if the parent node has been loaded\n     * @param  {Boolean} skip_redraw internal parameter indicating if the tree should be redrawn\n     * @param  {Boolean} instance internal parameter indicating if the node comes from another instance\n     * @trigger model.jstree copy_node.jstree\n     */\n    copy_node: function copy_node(obj, par, pos, callback, is_loaded, skip_redraw, origin) {\n      var t1, t2, dpc, tmp, i, j, node, old_par, new_par, old_ins, is_multi;\n      par = this.get_node(par);\n      pos = pos === undefined ? 0 : pos;\n\n      if (!par) {\n        return false;\n      }\n\n      if (!pos.toString().match(/^(before|after)$/) && !is_loaded && !this.is_loaded(par)) {\n        return this.load_node(par, function () {\n          this.copy_node(obj, par, pos, callback, true, false, origin);\n        });\n      }\n\n      if ($.isArray(obj)) {\n        if (obj.length === 1) {\n          obj = obj[0];\n        } else {\n          //obj = obj.slice();\n          for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n            if (tmp = this.copy_node(obj[t1], par, pos, callback, is_loaded, true, origin)) {\n              par = tmp;\n              pos = \"after\";\n            }\n          }\n\n          this.redraw();\n          return true;\n        }\n      }\n\n      obj = obj && obj.id ? obj : this.get_node(obj);\n\n      if (!obj || obj.id === $.jstree.root) {\n        return false;\n      }\n\n      old_par = (obj.parent || $.jstree.root).toString();\n      new_par = !pos.toString().match(/^(before|after)$/) || par.id === $.jstree.root ? par : this.get_node(par.parent);\n      old_ins = origin ? origin : this._model.data[obj.id] ? this : $.jstree.reference(obj.id);\n      is_multi = !old_ins || !old_ins._id || this._id !== old_ins._id;\n\n      if (old_ins && old_ins._id) {\n        obj = old_ins._model.data[obj.id];\n      }\n\n      if (par.id === $.jstree.root) {\n        if (pos === \"before\") {\n          pos = \"first\";\n        }\n\n        if (pos === \"after\") {\n          pos = \"last\";\n        }\n      }\n\n      switch (pos) {\n        case \"before\":\n          pos = $.inArray(par.id, new_par.children);\n          break;\n\n        case \"after\":\n          pos = $.inArray(par.id, new_par.children) + 1;\n          break;\n\n        case \"inside\":\n        case \"first\":\n          pos = 0;\n          break;\n\n        case \"last\":\n          pos = new_par.children.length;\n          break;\n\n        default:\n          if (!pos) {\n            pos = 0;\n          }\n\n          break;\n      }\n\n      if (pos > new_par.children.length) {\n        pos = new_par.children.length;\n      }\n\n      if (!this.check(\"copy_node\", obj, new_par, pos, {\n        'core': true,\n        'origin': origin,\n        'is_multi': old_ins && old_ins._id && old_ins._id !== this._id,\n        'is_foreign': !old_ins || !old_ins._id\n      })) {\n        this.settings.core.error.call(this, this._data.core.last_error);\n        return false;\n      }\n\n      node = old_ins ? old_ins.get_json(obj, {\n        no_id: true,\n        no_data: true,\n        no_state: true\n      }) : obj;\n\n      if (!node) {\n        return false;\n      }\n\n      if (node.id === true) {\n        delete node.id;\n      }\n\n      node = this._parse_model_from_json(node, new_par.id, new_par.parents.concat());\n\n      if (!node) {\n        return false;\n      }\n\n      tmp = this.get_node(node);\n\n      if (obj && obj.state && obj.state.loaded === false) {\n        tmp.state.loaded = false;\n      }\n\n      dpc = [];\n      dpc.push(node);\n      dpc = dpc.concat(tmp.children_d);\n      this.trigger('model', {\n        \"nodes\": dpc,\n        \"parent\": new_par.id\n      }); // insert into new parent and up\n\n      for (i = 0, j = new_par.parents.length; i < j; i++) {\n        this._model.data[new_par.parents[i]].children_d = this._model.data[new_par.parents[i]].children_d.concat(dpc);\n      }\n\n      dpc = [];\n\n      for (i = 0, j = new_par.children.length; i < j; i++) {\n        dpc[i >= pos ? i + 1 : i] = new_par.children[i];\n      }\n\n      dpc[pos] = tmp.id;\n      new_par.children = dpc;\n      new_par.children_d.push(tmp.id);\n      new_par.children_d = new_par.children_d.concat(tmp.children_d);\n\n      if (new_par.id === $.jstree.root) {\n        this._model.force_full_redraw = true;\n      }\n\n      if (!this._model.force_full_redraw) {\n        this._node_changed(new_par.id);\n      }\n\n      if (!skip_redraw) {\n        this.redraw(new_par.id === $.jstree.root);\n      }\n\n      if (callback) {\n        callback.call(this, tmp, new_par, pos);\n      }\n      /**\n       * triggered when a node is copied\n       * @event\n       * @name copy_node.jstree\n       * @param {Object} node the copied node\n       * @param {Object} original the original node\n       * @param {String} parent the parent's ID\n       * @param {Number} position the position of the node among the parent's children\n       * @param {String} old_parent the old parent of the node\n       * @param {Number} old_position the position of the original node\n       * @param {Boolean} is_multi do the node and new parent belong to different instances\n       * @param {jsTree} old_instance the instance the node came from\n       * @param {jsTree} new_instance the instance of the new parent\n       */\n\n\n      this.trigger('copy_node', {\n        \"node\": tmp,\n        \"original\": obj,\n        \"parent\": new_par.id,\n        \"position\": pos,\n        \"old_parent\": old_par,\n        \"old_position\": old_ins && old_ins._id && old_par && old_ins._model.data[old_par] && old_ins._model.data[old_par].children ? $.inArray(obj.id, old_ins._model.data[old_par].children) : -1,\n        'is_multi': old_ins && old_ins._id && old_ins._id !== this._id,\n        'is_foreign': !old_ins || !old_ins._id,\n        'old_instance': old_ins,\n        'new_instance': this\n      });\n      return tmp.id;\n    },\n\n    /**\n     * cut a node (a later call to `paste(obj)` would move the node)\n     * @name cut(obj)\n     * @param  {mixed} obj multiple objects can be passed using an array\n     * @trigger cut.jstree\n     */\n    cut: function cut(obj) {\n      if (!obj) {\n        obj = this._data.core.selected.concat();\n      }\n\n      if (!$.isArray(obj)) {\n        obj = [obj];\n      }\n\n      if (!obj.length) {\n        return false;\n      }\n\n      var tmp = [],\n          o,\n          t1,\n          t2;\n\n      for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n        o = this.get_node(obj[t1]);\n\n        if (o && o.id && o.id !== $.jstree.root) {\n          tmp.push(o);\n        }\n      }\n\n      if (!tmp.length) {\n        return false;\n      }\n\n      ccp_node = tmp;\n      ccp_inst = this;\n      ccp_mode = 'move_node';\n      /**\n       * triggered when nodes are added to the buffer for moving\n       * @event\n       * @name cut.jstree\n       * @param {Array} node\n       */\n\n      this.trigger('cut', {\n        \"node\": obj\n      });\n    },\n\n    /**\n     * copy a node (a later call to `paste(obj)` would copy the node)\n     * @name copy(obj)\n     * @param  {mixed} obj multiple objects can be passed using an array\n     * @trigger copy.jstree\n     */\n    copy: function copy(obj) {\n      if (!obj) {\n        obj = this._data.core.selected.concat();\n      }\n\n      if (!$.isArray(obj)) {\n        obj = [obj];\n      }\n\n      if (!obj.length) {\n        return false;\n      }\n\n      var tmp = [],\n          o,\n          t1,\n          t2;\n\n      for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n        o = this.get_node(obj[t1]);\n\n        if (o && o.id && o.id !== $.jstree.root) {\n          tmp.push(o);\n        }\n      }\n\n      if (!tmp.length) {\n        return false;\n      }\n\n      ccp_node = tmp;\n      ccp_inst = this;\n      ccp_mode = 'copy_node';\n      /**\n       * triggered when nodes are added to the buffer for copying\n       * @event\n       * @name copy.jstree\n       * @param {Array} node\n       */\n\n      this.trigger('copy', {\n        \"node\": obj\n      });\n    },\n\n    /**\n     * get the current buffer (any nodes that are waiting for a paste operation)\n     * @name get_buffer()\n     * @return {Object} an object consisting of `mode` (\"copy_node\" or \"move_node\"), `node` (an array of objects) and `inst` (the instance)\n     */\n    get_buffer: function get_buffer() {\n      return {\n        'mode': ccp_mode,\n        'node': ccp_node,\n        'inst': ccp_inst\n      };\n    },\n\n    /**\n     * check if there is something in the buffer to paste\n     * @name can_paste()\n     * @return {Boolean}\n     */\n    can_paste: function can_paste() {\n      return ccp_mode !== false && ccp_node !== false; // && ccp_inst._model.data[ccp_node];\n    },\n\n    /**\n     * copy or move the previously cut or copied nodes to a new parent\n     * @name paste(obj [, pos])\n     * @param  {mixed} obj the new parent\n     * @param  {mixed} pos the position to insert at (besides integer, \"first\" and \"last\" are supported), defaults to integer `0`\n     * @trigger paste.jstree\n     */\n    paste: function paste(obj, pos) {\n      obj = this.get_node(obj);\n\n      if (!obj || !ccp_mode || !ccp_mode.match(/^(copy_node|move_node)$/) || !ccp_node) {\n        return false;\n      }\n\n      if (this[ccp_mode](ccp_node, obj, pos, false, false, false, ccp_inst)) {\n        /**\n         * triggered when paste is invoked\n         * @event\n         * @name paste.jstree\n         * @param {String} parent the ID of the receiving node\n         * @param {Array} node the nodes in the buffer\n         * @param {String} mode the performed operation - \"copy_node\" or \"move_node\"\n         */\n        this.trigger('paste', {\n          \"parent\": obj.id,\n          \"node\": ccp_node,\n          \"mode\": ccp_mode\n        });\n      }\n\n      ccp_node = false;\n      ccp_mode = false;\n      ccp_inst = false;\n    },\n\n    /**\n     * clear the buffer of previously copied or cut nodes\n     * @name clear_buffer()\n     * @trigger clear_buffer.jstree\n     */\n    clear_buffer: function clear_buffer() {\n      ccp_node = false;\n      ccp_mode = false;\n      ccp_inst = false;\n      /**\n       * triggered when the copy / cut buffer is cleared\n       * @event\n       * @name clear_buffer.jstree\n       */\n\n      this.trigger('clear_buffer');\n    },\n\n    /**\n     * put a node in edit mode (input field to rename the node)\n     * @name edit(obj [, default_text, callback])\n     * @param  {mixed} obj\n     * @param  {String} default_text the text to populate the input with (if omitted or set to a non-string value the node's text value is used)\n     * @param  {Function} callback a function to be called once the text box is blurred, it is called in the instance's scope and receives the node, a status parameter (true if the rename is successful, false otherwise) and a boolean indicating if the user cancelled the edit. You can access the node's title using .text\n     */\n    edit: function edit(obj, default_text, callback) {\n      var rtl,\n          w,\n          a,\n          s,\n          t,\n          h1,\n          h2,\n          fn,\n          tmp,\n          cancel = false;\n      obj = this.get_node(obj);\n\n      if (!obj) {\n        return false;\n      }\n\n      if (this.settings.core.check_callback === false) {\n        this._data.core.last_error = {\n          'error': 'check',\n          'plugin': 'core',\n          'id': 'core_07',\n          'reason': 'Could not edit node because of check_callback'\n        };\n        this.settings.core.error.call(this, this._data.core.last_error);\n        return false;\n      }\n\n      tmp = obj;\n      default_text = typeof default_text === 'string' ? default_text : obj.text;\n      this.set_text(obj, \"\");\n      obj = this._open_to(obj);\n      tmp.text = default_text;\n      rtl = this._data.core.rtl;\n      w = this.element.width();\n      this._data.core.focused = tmp.id;\n      a = obj.children('.jstree-anchor').focus();\n      s = $('<span>');\n      /*!\n      oi = obj.children(\"i:visible\"),\n      ai = a.children(\"i:visible\"),\n      w1 = oi.width() * oi.length,\n      w2 = ai.width() * ai.length,\n      */\n\n      t = default_text;\n      h1 = $(\"<\" + \"div />\", {\n        css: {\n          \"position\": \"absolute\",\n          \"top\": \"-200px\",\n          \"left\": rtl ? \"0px\" : \"-1000px\",\n          \"visibility\": \"hidden\"\n        }\n      }).appendTo(\"body\");\n      h2 = $(\"<\" + \"input />\", {\n        \"value\": t,\n        \"class\": \"jstree-rename-input\",\n        // \"size\" : t.length,\n        \"css\": {\n          \"padding\": \"0\",\n          \"border\": \"1px solid silver\",\n          \"box-sizing\": \"border-box\",\n          \"display\": \"inline-block\",\n          \"height\": this._data.core.li_height + \"px\",\n          \"lineHeight\": this._data.core.li_height + \"px\",\n          \"width\": \"150px\" // will be set a bit further down\n\n        },\n        \"blur\": $.proxy(function (e) {\n          e.stopImmediatePropagation();\n          e.preventDefault();\n          var i = s.children(\".jstree-rename-input\"),\n              v = i.val(),\n              f = this.settings.core.force_text,\n              nv;\n\n          if (v === \"\") {\n            v = t;\n          }\n\n          h1.remove();\n          s.replaceWith(a);\n          s.remove();\n          t = f ? t : $('<div></div>').append($.parseHTML(t)).html();\n          this.set_text(obj, t);\n          nv = !!this.rename_node(obj, f ? $('<div></div>').text(v).text() : $('<div></div>').append($.parseHTML(v)).html());\n\n          if (!nv) {\n            this.set_text(obj, t); // move this up? and fix #483\n          }\n\n          this._data.core.focused = tmp.id;\n          setTimeout($.proxy(function () {\n            var node = this.get_node(tmp.id, true);\n\n            if (node.length) {\n              this._data.core.focused = tmp.id;\n              node.children('.jstree-anchor').focus();\n            }\n          }, this), 0);\n\n          if (callback) {\n            callback.call(this, tmp, nv, cancel);\n          }\n\n          h2 = null;\n        }, this),\n        \"keydown\": function keydown(e) {\n          var key = e.which;\n\n          if (key === 27) {\n            cancel = true;\n            this.value = t;\n          }\n\n          if (key === 27 || key === 13 || key === 37 || key === 38 || key === 39 || key === 40 || key === 32) {\n            e.stopImmediatePropagation();\n          }\n\n          if (key === 27 || key === 13) {\n            e.preventDefault();\n            this.blur();\n          }\n        },\n        \"click\": function click(e) {\n          e.stopImmediatePropagation();\n        },\n        \"mousedown\": function mousedown(e) {\n          e.stopImmediatePropagation();\n        },\n        \"keyup\": function keyup(e) {\n          h2.width(Math.min(h1.text(\"pW\" + this.value).width(), w));\n        },\n        \"keypress\": function keypress(e) {\n          if (e.which === 13) {\n            return false;\n          }\n        }\n      });\n      fn = {\n        fontFamily: a.css('fontFamily') || '',\n        fontSize: a.css('fontSize') || '',\n        fontWeight: a.css('fontWeight') || '',\n        fontStyle: a.css('fontStyle') || '',\n        fontStretch: a.css('fontStretch') || '',\n        fontVariant: a.css('fontVariant') || '',\n        letterSpacing: a.css('letterSpacing') || '',\n        wordSpacing: a.css('wordSpacing') || ''\n      };\n      s.attr('class', a.attr('class')).append(a.contents().clone()).append(h2);\n      a.replaceWith(s);\n      h1.css(fn);\n      h2.css(fn).width(Math.min(h1.text(\"pW\" + h2[0].value).width(), w))[0].select();\n      $(document).one('mousedown.jstree touchstart.jstree dnd_start.vakata', function (e) {\n        if (h2 && e.target !== h2) {\n          $(h2).blur();\n        }\n      });\n    },\n\n    /**\n     * changes the theme\n     * @name set_theme(theme_name [, theme_url])\n     * @param {String} theme_name the name of the new theme to apply\n     * @param {mixed} theme_url  the location of the CSS file for this theme. Omit or set to `false` if you manually included the file. Set to `true` to autoload from the `core.themes.dir` directory.\n     * @trigger set_theme.jstree\n     */\n    set_theme: function set_theme(theme_name, theme_url) {\n      if (!theme_name) {\n        return false;\n      }\n\n      if (theme_url === true) {\n        var dir = this.settings.core.themes.dir;\n\n        if (!dir) {\n          dir = $.jstree.path + '/themes';\n        }\n\n        theme_url = dir + '/' + theme_name + '/style.css';\n      }\n\n      if (theme_url && $.inArray(theme_url, themes_loaded) === -1) {\n        $('head').append('<' + 'link rel=\"stylesheet\" href=\"' + theme_url + '\" type=\"text/css\" />');\n        themes_loaded.push(theme_url);\n      }\n\n      if (this._data.core.themes.name) {\n        this.element.removeClass('jstree-' + this._data.core.themes.name);\n      }\n\n      this._data.core.themes.name = theme_name;\n      this.element.addClass('jstree-' + theme_name);\n      this.element[this.settings.core.themes.responsive ? 'addClass' : 'removeClass']('jstree-' + theme_name + '-responsive');\n      /**\n       * triggered when a theme is set\n       * @event\n       * @name set_theme.jstree\n       * @param {String} theme the new theme\n       */\n\n      this.trigger('set_theme', {\n        'theme': theme_name\n      });\n    },\n\n    /**\n     * gets the name of the currently applied theme name\n     * @name get_theme()\n     * @return {String}\n     */\n    get_theme: function get_theme() {\n      return this._data.core.themes.name;\n    },\n\n    /**\n     * changes the theme variant (if the theme has variants)\n     * @name set_theme_variant(variant_name)\n     * @param {String|Boolean} variant_name the variant to apply (if `false` is used the current variant is removed)\n     */\n    set_theme_variant: function set_theme_variant(variant_name) {\n      if (this._data.core.themes.variant) {\n        this.element.removeClass('jstree-' + this._data.core.themes.name + '-' + this._data.core.themes.variant);\n      }\n\n      this._data.core.themes.variant = variant_name;\n\n      if (variant_name) {\n        this.element.addClass('jstree-' + this._data.core.themes.name + '-' + this._data.core.themes.variant);\n      }\n    },\n\n    /**\n     * gets the name of the currently applied theme variant\n     * @name get_theme()\n     * @return {String}\n     */\n    get_theme_variant: function get_theme_variant() {\n      return this._data.core.themes.variant;\n    },\n\n    /**\n     * shows a striped background on the container (if the theme supports it)\n     * @name show_stripes()\n     */\n    show_stripes: function show_stripes() {\n      this._data.core.themes.stripes = true;\n      this.get_container_ul().addClass(\"jstree-striped\");\n      /**\n       * triggered when stripes are shown\n       * @event\n       * @name show_stripes.jstree\n       */\n\n      this.trigger('show_stripes');\n    },\n\n    /**\n     * hides the striped background on the container\n     * @name hide_stripes()\n     */\n    hide_stripes: function hide_stripes() {\n      this._data.core.themes.stripes = false;\n      this.get_container_ul().removeClass(\"jstree-striped\");\n      /**\n       * triggered when stripes are hidden\n       * @event\n       * @name hide_stripes.jstree\n       */\n\n      this.trigger('hide_stripes');\n    },\n\n    /**\n     * toggles the striped background on the container\n     * @name toggle_stripes()\n     */\n    toggle_stripes: function toggle_stripes() {\n      if (this._data.core.themes.stripes) {\n        this.hide_stripes();\n      } else {\n        this.show_stripes();\n      }\n    },\n\n    /**\n     * shows the connecting dots (if the theme supports it)\n     * @name show_dots()\n     */\n    show_dots: function show_dots() {\n      this._data.core.themes.dots = true;\n      this.get_container_ul().removeClass(\"jstree-no-dots\");\n      /**\n       * triggered when dots are shown\n       * @event\n       * @name show_dots.jstree\n       */\n\n      this.trigger('show_dots');\n    },\n\n    /**\n     * hides the connecting dots\n     * @name hide_dots()\n     */\n    hide_dots: function hide_dots() {\n      this._data.core.themes.dots = false;\n      this.get_container_ul().addClass(\"jstree-no-dots\");\n      /**\n       * triggered when dots are hidden\n       * @event\n       * @name hide_dots.jstree\n       */\n\n      this.trigger('hide_dots');\n    },\n\n    /**\n     * toggles the connecting dots\n     * @name toggle_dots()\n     */\n    toggle_dots: function toggle_dots() {\n      if (this._data.core.themes.dots) {\n        this.hide_dots();\n      } else {\n        this.show_dots();\n      }\n    },\n\n    /**\n     * show the node icons\n     * @name show_icons()\n     */\n    show_icons: function show_icons() {\n      this._data.core.themes.icons = true;\n      this.get_container_ul().removeClass(\"jstree-no-icons\");\n      /**\n       * triggered when icons are shown\n       * @event\n       * @name show_icons.jstree\n       */\n\n      this.trigger('show_icons');\n    },\n\n    /**\n     * hide the node icons\n     * @name hide_icons()\n     */\n    hide_icons: function hide_icons() {\n      this._data.core.themes.icons = false;\n      this.get_container_ul().addClass(\"jstree-no-icons\");\n      /**\n       * triggered when icons are hidden\n       * @event\n       * @name hide_icons.jstree\n       */\n\n      this.trigger('hide_icons');\n    },\n\n    /**\n     * toggle the node icons\n     * @name toggle_icons()\n     */\n    toggle_icons: function toggle_icons() {\n      if (this._data.core.themes.icons) {\n        this.hide_icons();\n      } else {\n        this.show_icons();\n      }\n    },\n\n    /**\n     * show the node ellipsis\n     * @name show_icons()\n     */\n    show_ellipsis: function show_ellipsis() {\n      this._data.core.themes.ellipsis = true;\n      this.get_container_ul().addClass(\"jstree-ellipsis\");\n      /**\n       * triggered when ellisis is shown\n       * @event\n       * @name show_ellipsis.jstree\n       */\n\n      this.trigger('show_ellipsis');\n    },\n\n    /**\n     * hide the node ellipsis\n     * @name hide_ellipsis()\n     */\n    hide_ellipsis: function hide_ellipsis() {\n      this._data.core.themes.ellipsis = false;\n      this.get_container_ul().removeClass(\"jstree-ellipsis\");\n      /**\n       * triggered when ellisis is hidden\n       * @event\n       * @name hide_ellipsis.jstree\n       */\n\n      this.trigger('hide_ellipsis');\n    },\n\n    /**\n     * toggle the node ellipsis\n     * @name toggle_icons()\n     */\n    toggle_ellipsis: function toggle_ellipsis() {\n      if (this._data.core.themes.ellipsis) {\n        this.hide_ellipsis();\n      } else {\n        this.show_ellipsis();\n      }\n    },\n\n    /**\n     * set the node icon for a node\n     * @name set_icon(obj, icon)\n     * @param {mixed} obj\n     * @param {String} icon the new icon - can be a path to an icon or a className, if using an image that is in the current directory use a `./` prefix, otherwise it will be detected as a class\n     */\n    set_icon: function set_icon(obj, icon) {\n      var t1, t2, dom, old;\n\n      if ($.isArray(obj)) {\n        obj = obj.slice();\n\n        for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n          this.set_icon(obj[t1], icon);\n        }\n\n        return true;\n      }\n\n      obj = this.get_node(obj);\n\n      if (!obj || obj.id === $.jstree.root) {\n        return false;\n      }\n\n      old = obj.icon;\n      obj.icon = icon === true || icon === null || icon === undefined || icon === '' ? true : icon;\n      dom = this.get_node(obj, true).children(\".jstree-anchor\").children(\".jstree-themeicon\");\n\n      if (icon === false) {\n        this.hide_icon(obj);\n      } else if (icon === true || icon === null || icon === undefined || icon === '') {\n        dom.removeClass('jstree-themeicon-custom ' + old).css(\"background\", \"\").removeAttr(\"rel\");\n\n        if (old === false) {\n          this.show_icon(obj);\n        }\n      } else if (icon.indexOf(\"/\") === -1 && icon.indexOf(\".\") === -1) {\n        dom.removeClass(old).css(\"background\", \"\");\n        dom.addClass(icon + ' jstree-themeicon-custom').attr(\"rel\", icon);\n\n        if (old === false) {\n          this.show_icon(obj);\n        }\n      } else {\n        dom.removeClass(old).css(\"background\", \"\");\n        dom.addClass('jstree-themeicon-custom').css(\"background\", \"url('\" + icon + \"') center center no-repeat\").attr(\"rel\", icon);\n\n        if (old === false) {\n          this.show_icon(obj);\n        }\n      }\n\n      return true;\n    },\n\n    /**\n     * get the node icon for a node\n     * @name get_icon(obj)\n     * @param {mixed} obj\n     * @return {String}\n     */\n    get_icon: function get_icon(obj) {\n      obj = this.get_node(obj);\n      return !obj || obj.id === $.jstree.root ? false : obj.icon;\n    },\n\n    /**\n     * hide the icon on an individual node\n     * @name hide_icon(obj)\n     * @param {mixed} obj\n     */\n    hide_icon: function hide_icon(obj) {\n      var t1, t2;\n\n      if ($.isArray(obj)) {\n        obj = obj.slice();\n\n        for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n          this.hide_icon(obj[t1]);\n        }\n\n        return true;\n      }\n\n      obj = this.get_node(obj);\n\n      if (!obj || obj === $.jstree.root) {\n        return false;\n      }\n\n      obj.icon = false;\n      this.get_node(obj, true).children(\".jstree-anchor\").children(\".jstree-themeicon\").addClass('jstree-themeicon-hidden');\n      return true;\n    },\n\n    /**\n     * show the icon on an individual node\n     * @name show_icon(obj)\n     * @param {mixed} obj\n     */\n    show_icon: function show_icon(obj) {\n      var t1, t2, dom;\n\n      if ($.isArray(obj)) {\n        obj = obj.slice();\n\n        for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n          this.show_icon(obj[t1]);\n        }\n\n        return true;\n      }\n\n      obj = this.get_node(obj);\n\n      if (!obj || obj === $.jstree.root) {\n        return false;\n      }\n\n      dom = this.get_node(obj, true);\n      obj.icon = dom.length ? dom.children(\".jstree-anchor\").children(\".jstree-themeicon\").attr('rel') : true;\n\n      if (!obj.icon) {\n        obj.icon = true;\n      }\n\n      dom.children(\".jstree-anchor\").children(\".jstree-themeicon\").removeClass('jstree-themeicon-hidden');\n      return true;\n    }\n  }; // helpers\n\n  $.vakata = {}; // collect attributes\n\n  $.vakata.attributes = function (node, with_values) {\n    node = $(node)[0];\n    var attr = with_values ? {} : [];\n\n    if (node && node.attributes) {\n      $.each(node.attributes, function (i, v) {\n        if ($.inArray(v.name.toLowerCase(), ['style', 'contenteditable', 'hasfocus', 'tabindex']) !== -1) {\n          return;\n        }\n\n        if (v.value !== null && $.trim(v.value) !== '') {\n          if (with_values) {\n            attr[v.name] = v.value;\n          } else {\n            attr.push(v.name);\n          }\n        }\n      });\n    }\n\n    return attr;\n  };\n\n  $.vakata.array_unique = function (array) {\n    var a = [],\n        i,\n        j,\n        l,\n        o = {};\n\n    for (i = 0, l = array.length; i < l; i++) {\n      if (o[array[i]] === undefined) {\n        a.push(array[i]);\n        o[array[i]] = true;\n      }\n    }\n\n    return a;\n  }; // remove item from array\n\n\n  $.vakata.array_remove = function (array, from) {\n    array.splice(from, 1);\n    return array; //var rest = array.slice((to || from) + 1 || array.length);\n    //array.length = from < 0 ? array.length + from : from;\n    //array.push.apply(array, rest);\n    //return array;\n  }; // remove item from array\n\n\n  $.vakata.array_remove_item = function (array, item) {\n    var tmp = $.inArray(item, array);\n    return tmp !== -1 ? $.vakata.array_remove(array, tmp) : array;\n  };\n\n  $.vakata.array_filter = function (c, a, b, d, e) {\n    if (c.filter) {\n      return c.filter(a, b);\n    }\n\n    d = [];\n\n    for (e in c) {\n      if (~~e + '' === e + '' && e >= 0 && a.call(b, c[e], +e, c)) {\n        d.push(c[e]);\n      }\n    }\n\n    return d;\n  };\n  /**\n   * ### Changed plugin\n   *\n   * This plugin adds more information to the `changed.jstree` event. The new data is contained in the `changed` event data property, and contains a lists of `selected` and `deselected` nodes.\n   */\n\n\n  $.jstree.plugins.changed = function (options, parent) {\n    var last = [];\n\n    this.trigger = function (ev, data) {\n      var i, j;\n\n      if (!data) {\n        data = {};\n      }\n\n      if (ev.replace('.jstree', '') === 'changed') {\n        data.changed = {\n          selected: [],\n          deselected: []\n        };\n        var tmp = {};\n\n        for (i = 0, j = last.length; i < j; i++) {\n          tmp[last[i]] = 1;\n        }\n\n        for (i = 0, j = data.selected.length; i < j; i++) {\n          if (!tmp[data.selected[i]]) {\n            data.changed.selected.push(data.selected[i]);\n          } else {\n            tmp[data.selected[i]] = 2;\n          }\n        }\n\n        for (i = 0, j = last.length; i < j; i++) {\n          if (tmp[last[i]] === 1) {\n            data.changed.deselected.push(last[i]);\n          }\n        }\n\n        last = data.selected.slice();\n      }\n      /**\n       * triggered when selection changes (the \"changed\" plugin enhances the original event with more data)\n       * @event\n       * @name changed.jstree\n       * @param {Object} node\n       * @param {Object} action the action that caused the selection to change\n       * @param {Array} selected the current selection\n       * @param {Object} changed an object containing two properties `selected` and `deselected` - both arrays of node IDs, which were selected or deselected since the last changed event\n       * @param {Object} event the event (if any) that triggered this changed event\n       * @plugin changed\n       */\n\n\n      parent.trigger.call(this, ev, data);\n    };\n\n    this.refresh = function (skip_loading, forget_state) {\n      last = [];\n      return parent.refresh.apply(this, arguments);\n    };\n  };\n  /**\n   * ### Checkbox plugin\n   *\n   * This plugin renders checkbox icons in front of each node, making multiple selection much easier.\n   * It also supports tri-state behavior, meaning that if a node has a few of its children checked it will be rendered as undetermined, and state will be propagated up.\n   */\n\n\n  var _i = document.createElement('I');\n\n  _i.className = 'jstree-icon jstree-checkbox';\n\n  _i.setAttribute('role', 'presentation');\n  /**\n   * stores all defaults for the checkbox plugin\n   * @name $.jstree.defaults.checkbox\n   * @plugin checkbox\n   */\n\n\n  $.jstree.defaults.checkbox = {\n    /**\n     * a boolean indicating if checkboxes should be visible (can be changed at a later time using `show_checkboxes()` and `hide_checkboxes`). Defaults to `true`.\n     * @name $.jstree.defaults.checkbox.visible\n     * @plugin checkbox\n     */\n    visible: true,\n\n    /**\n     * a boolean indicating if checkboxes should cascade down and have an undetermined state. Defaults to `true`.\n     * @name $.jstree.defaults.checkbox.three_state\n     * @plugin checkbox\n     */\n    three_state: true,\n\n    /**\n     * a boolean indicating if clicking anywhere on the node should act as clicking on the checkbox. Defaults to `true`.\n     * @name $.jstree.defaults.checkbox.whole_node\n     * @plugin checkbox\n     */\n    whole_node: true,\n\n    /**\n     * a boolean indicating if the selected style of a node should be kept, or removed. Defaults to `true`.\n     * @name $.jstree.defaults.checkbox.keep_selected_style\n     * @plugin checkbox\n     */\n    keep_selected_style: true,\n\n    /**\n     * This setting controls how cascading and undetermined nodes are applied.\n     * If 'up' is in the string - cascading up is enabled, if 'down' is in the string - cascading down is enabled, if 'undetermined' is in the string - undetermined nodes will be used.\n     * If `three_state` is set to `true` this setting is automatically set to 'up+down+undetermined'. Defaults to ''.\n     * @name $.jstree.defaults.checkbox.cascade\n     * @plugin checkbox\n     */\n    cascade: '',\n\n    /**\n     * This setting controls if checkbox are bound to the general tree selection or to an internal array maintained by the checkbox plugin. Defaults to `true`, only set to `false` if you know exactly what you are doing.\n     * @name $.jstree.defaults.checkbox.tie_selection\n     * @plugin checkbox\n     */\n    tie_selection: true\n  };\n\n  $.jstree.plugins.checkbox = function (options, parent) {\n    this.bind = function () {\n      parent.bind.call(this);\n      this._data.checkbox.uto = false;\n      this._data.checkbox.selected = [];\n\n      if (this.settings.checkbox.three_state) {\n        this.settings.checkbox.cascade = 'up+down+undetermined';\n      }\n\n      this.element.on(\"init.jstree\", $.proxy(function () {\n        this._data.checkbox.visible = this.settings.checkbox.visible;\n\n        if (!this.settings.checkbox.keep_selected_style) {\n          this.element.addClass('jstree-checkbox-no-clicked');\n        }\n\n        if (this.settings.checkbox.tie_selection) {\n          this.element.addClass('jstree-checkbox-selection');\n        }\n      }, this)).on(\"loading.jstree\", $.proxy(function () {\n        this[this._data.checkbox.visible ? 'show_checkboxes' : 'hide_checkboxes']();\n      }, this));\n\n      if (this.settings.checkbox.cascade.indexOf('undetermined') !== -1) {\n        this.element.on('changed.jstree uncheck_node.jstree check_node.jstree uncheck_all.jstree check_all.jstree move_node.jstree copy_node.jstree redraw.jstree open_node.jstree', $.proxy(function () {\n          // only if undetermined is in setting\n          if (this._data.checkbox.uto) {\n            clearTimeout(this._data.checkbox.uto);\n          }\n\n          this._data.checkbox.uto = setTimeout($.proxy(this._undetermined, this), 50);\n        }, this));\n      }\n\n      if (!this.settings.checkbox.tie_selection) {\n        this.element.on('model.jstree', $.proxy(function (e, data) {\n          var m = this._model.data,\n              p = m[data.parent],\n              dpc = data.nodes,\n              i,\n              j;\n\n          for (i = 0, j = dpc.length; i < j; i++) {\n            m[dpc[i]].state.checked = m[dpc[i]].state.checked || m[dpc[i]].original && m[dpc[i]].original.state && m[dpc[i]].original.state.checked;\n\n            if (m[dpc[i]].state.checked) {\n              this._data.checkbox.selected.push(dpc[i]);\n            }\n          }\n        }, this));\n      }\n\n      if (this.settings.checkbox.cascade.indexOf('up') !== -1 || this.settings.checkbox.cascade.indexOf('down') !== -1) {\n        this.element.on('model.jstree', $.proxy(function (e, data) {\n          var m = this._model.data,\n              p = m[data.parent],\n              dpc = data.nodes,\n              chd = [],\n              c,\n              i,\n              j,\n              k,\n              l,\n              tmp,\n              s = this.settings.checkbox.cascade,\n              t = this.settings.checkbox.tie_selection;\n\n          if (s.indexOf('down') !== -1) {\n            // apply down\n            if (p.state[t ? 'selected' : 'checked']) {\n              for (i = 0, j = dpc.length; i < j; i++) {\n                m[dpc[i]].state[t ? 'selected' : 'checked'] = true;\n              }\n\n              this._data[t ? 'core' : 'checkbox'].selected = this._data[t ? 'core' : 'checkbox'].selected.concat(dpc);\n            } else {\n              for (i = 0, j = dpc.length; i < j; i++) {\n                if (m[dpc[i]].state[t ? 'selected' : 'checked']) {\n                  for (k = 0, l = m[dpc[i]].children_d.length; k < l; k++) {\n                    m[m[dpc[i]].children_d[k]].state[t ? 'selected' : 'checked'] = true;\n                  }\n\n                  this._data[t ? 'core' : 'checkbox'].selected = this._data[t ? 'core' : 'checkbox'].selected.concat(m[dpc[i]].children_d);\n                }\n              }\n            }\n          }\n\n          if (s.indexOf('up') !== -1) {\n            // apply up\n            for (i = 0, j = p.children_d.length; i < j; i++) {\n              if (!m[p.children_d[i]].children.length) {\n                chd.push(m[p.children_d[i]].parent);\n              }\n            }\n\n            chd = $.vakata.array_unique(chd);\n\n            for (k = 0, l = chd.length; k < l; k++) {\n              p = m[chd[k]];\n\n              while (p && p.id !== $.jstree.root) {\n                c = 0;\n\n                for (i = 0, j = p.children.length; i < j; i++) {\n                  c += m[p.children[i]].state[t ? 'selected' : 'checked'];\n                }\n\n                if (c === j) {\n                  p.state[t ? 'selected' : 'checked'] = true;\n\n                  this._data[t ? 'core' : 'checkbox'].selected.push(p.id);\n\n                  tmp = this.get_node(p, true);\n\n                  if (tmp && tmp.length) {\n                    tmp.attr('aria-selected', true).children('.jstree-anchor').addClass(t ? 'jstree-clicked' : 'jstree-checked');\n                  }\n                } else {\n                  break;\n                }\n\n                p = this.get_node(p.parent);\n              }\n            }\n          }\n\n          this._data[t ? 'core' : 'checkbox'].selected = $.vakata.array_unique(this._data[t ? 'core' : 'checkbox'].selected);\n        }, this)).on(this.settings.checkbox.tie_selection ? 'select_node.jstree' : 'check_node.jstree', $.proxy(function (e, data) {\n          var obj = data.node,\n              m = this._model.data,\n              par = this.get_node(obj.parent),\n              dom = this.get_node(obj, true),\n              i,\n              j,\n              c,\n              tmp,\n              s = this.settings.checkbox.cascade,\n              t = this.settings.checkbox.tie_selection,\n              sel = {},\n              cur = this._data[t ? 'core' : 'checkbox'].selected;\n\n          for (i = 0, j = cur.length; i < j; i++) {\n            sel[cur[i]] = true;\n          } // apply down\n\n\n          if (s.indexOf('down') !== -1) {\n            //this._data[ t ? 'core' : 'checkbox' ].selected = $.vakata.array_unique(this._data[ t ? 'core' : 'checkbox' ].selected.concat(obj.children_d));\n            for (i = 0, j = obj.children_d.length; i < j; i++) {\n              sel[obj.children_d[i]] = true;\n              tmp = m[obj.children_d[i]];\n              tmp.state[t ? 'selected' : 'checked'] = true;\n\n              if (tmp && tmp.original && tmp.original.state && tmp.original.state.undetermined) {\n                tmp.original.state.undetermined = false;\n              }\n            }\n          } // apply up\n\n\n          if (s.indexOf('up') !== -1) {\n            while (par && par.id !== $.jstree.root) {\n              c = 0;\n\n              for (i = 0, j = par.children.length; i < j; i++) {\n                c += m[par.children[i]].state[t ? 'selected' : 'checked'];\n              }\n\n              if (c === j) {\n                par.state[t ? 'selected' : 'checked'] = true;\n                sel[par.id] = true; //this._data[ t ? 'core' : 'checkbox' ].selected.push(par.id);\n\n                tmp = this.get_node(par, true);\n\n                if (tmp && tmp.length) {\n                  tmp.attr('aria-selected', true).children('.jstree-anchor').addClass(t ? 'jstree-clicked' : 'jstree-checked');\n                }\n              } else {\n                break;\n              }\n\n              par = this.get_node(par.parent);\n            }\n          }\n\n          cur = [];\n\n          for (i in sel) {\n            if (sel.hasOwnProperty(i)) {\n              cur.push(i);\n            }\n          }\n\n          this._data[t ? 'core' : 'checkbox'].selected = cur; // apply down (process .children separately?)\n\n          if (s.indexOf('down') !== -1 && dom.length) {\n            dom.find('.jstree-anchor').addClass(t ? 'jstree-clicked' : 'jstree-checked').parent().attr('aria-selected', true);\n          }\n        }, this)).on(this.settings.checkbox.tie_selection ? 'deselect_all.jstree' : 'uncheck_all.jstree', $.proxy(function (e, data) {\n          var obj = this.get_node($.jstree.root),\n              m = this._model.data,\n              i,\n              j,\n              tmp;\n\n          for (i = 0, j = obj.children_d.length; i < j; i++) {\n            tmp = m[obj.children_d[i]];\n\n            if (tmp && tmp.original && tmp.original.state && tmp.original.state.undetermined) {\n              tmp.original.state.undetermined = false;\n            }\n          }\n        }, this)).on(this.settings.checkbox.tie_selection ? 'deselect_node.jstree' : 'uncheck_node.jstree', $.proxy(function (e, data) {\n          var obj = data.node,\n              dom = this.get_node(obj, true),\n              i,\n              j,\n              tmp,\n              s = this.settings.checkbox.cascade,\n              t = this.settings.checkbox.tie_selection,\n              cur = this._data[t ? 'core' : 'checkbox'].selected,\n              sel = {};\n\n          if (obj && obj.original && obj.original.state && obj.original.state.undetermined) {\n            obj.original.state.undetermined = false;\n          } // apply down\n\n\n          if (s.indexOf('down') !== -1) {\n            for (i = 0, j = obj.children_d.length; i < j; i++) {\n              tmp = this._model.data[obj.children_d[i]];\n              tmp.state[t ? 'selected' : 'checked'] = false;\n\n              if (tmp && tmp.original && tmp.original.state && tmp.original.state.undetermined) {\n                tmp.original.state.undetermined = false;\n              }\n            }\n          } // apply up\n\n\n          if (s.indexOf('up') !== -1) {\n            for (i = 0, j = obj.parents.length; i < j; i++) {\n              tmp = this._model.data[obj.parents[i]];\n              tmp.state[t ? 'selected' : 'checked'] = false;\n\n              if (tmp && tmp.original && tmp.original.state && tmp.original.state.undetermined) {\n                tmp.original.state.undetermined = false;\n              }\n\n              tmp = this.get_node(obj.parents[i], true);\n\n              if (tmp && tmp.length) {\n                tmp.attr('aria-selected', false).children('.jstree-anchor').removeClass(t ? 'jstree-clicked' : 'jstree-checked');\n              }\n            }\n          }\n\n          sel = {};\n\n          for (i = 0, j = cur.length; i < j; i++) {\n            // apply down + apply up\n            if ((s.indexOf('down') === -1 || $.inArray(cur[i], obj.children_d) === -1) && (s.indexOf('up') === -1 || $.inArray(cur[i], obj.parents) === -1)) {\n              sel[cur[i]] = true;\n            }\n          }\n\n          cur = [];\n\n          for (i in sel) {\n            if (sel.hasOwnProperty(i)) {\n              cur.push(i);\n            }\n          }\n\n          this._data[t ? 'core' : 'checkbox'].selected = cur; // apply down (process .children separately?)\n\n          if (s.indexOf('down') !== -1 && dom.length) {\n            dom.find('.jstree-anchor').removeClass(t ? 'jstree-clicked' : 'jstree-checked').parent().attr('aria-selected', false);\n          }\n        }, this));\n      }\n\n      if (this.settings.checkbox.cascade.indexOf('up') !== -1) {\n        this.element.on('delete_node.jstree', $.proxy(function (e, data) {\n          // apply up (whole handler)\n          var p = this.get_node(data.parent),\n              m = this._model.data,\n              i,\n              j,\n              c,\n              tmp,\n              t = this.settings.checkbox.tie_selection;\n\n          while (p && p.id !== $.jstree.root && !p.state[t ? 'selected' : 'checked']) {\n            c = 0;\n\n            for (i = 0, j = p.children.length; i < j; i++) {\n              c += m[p.children[i]].state[t ? 'selected' : 'checked'];\n            }\n\n            if (j > 0 && c === j) {\n              p.state[t ? 'selected' : 'checked'] = true;\n\n              this._data[t ? 'core' : 'checkbox'].selected.push(p.id);\n\n              tmp = this.get_node(p, true);\n\n              if (tmp && tmp.length) {\n                tmp.attr('aria-selected', true).children('.jstree-anchor').addClass(t ? 'jstree-clicked' : 'jstree-checked');\n              }\n            } else {\n              break;\n            }\n\n            p = this.get_node(p.parent);\n          }\n        }, this)).on('move_node.jstree', $.proxy(function (e, data) {\n          // apply up (whole handler)\n          var is_multi = data.is_multi,\n              old_par = data.old_parent,\n              new_par = this.get_node(data.parent),\n              m = this._model.data,\n              p,\n              c,\n              i,\n              j,\n              tmp,\n              t = this.settings.checkbox.tie_selection;\n\n          if (!is_multi) {\n            p = this.get_node(old_par);\n\n            while (p && p.id !== $.jstree.root && !p.state[t ? 'selected' : 'checked']) {\n              c = 0;\n\n              for (i = 0, j = p.children.length; i < j; i++) {\n                c += m[p.children[i]].state[t ? 'selected' : 'checked'];\n              }\n\n              if (j > 0 && c === j) {\n                p.state[t ? 'selected' : 'checked'] = true;\n\n                this._data[t ? 'core' : 'checkbox'].selected.push(p.id);\n\n                tmp = this.get_node(p, true);\n\n                if (tmp && tmp.length) {\n                  tmp.attr('aria-selected', true).children('.jstree-anchor').addClass(t ? 'jstree-clicked' : 'jstree-checked');\n                }\n              } else {\n                break;\n              }\n\n              p = this.get_node(p.parent);\n            }\n          }\n\n          p = new_par;\n\n          while (p && p.id !== $.jstree.root) {\n            c = 0;\n\n            for (i = 0, j = p.children.length; i < j; i++) {\n              c += m[p.children[i]].state[t ? 'selected' : 'checked'];\n            }\n\n            if (c === j) {\n              if (!p.state[t ? 'selected' : 'checked']) {\n                p.state[t ? 'selected' : 'checked'] = true;\n\n                this._data[t ? 'core' : 'checkbox'].selected.push(p.id);\n\n                tmp = this.get_node(p, true);\n\n                if (tmp && tmp.length) {\n                  tmp.attr('aria-selected', true).children('.jstree-anchor').addClass(t ? 'jstree-clicked' : 'jstree-checked');\n                }\n              }\n            } else {\n              if (p.state[t ? 'selected' : 'checked']) {\n                p.state[t ? 'selected' : 'checked'] = false;\n                this._data[t ? 'core' : 'checkbox'].selected = $.vakata.array_remove_item(this._data[t ? 'core' : 'checkbox'].selected, p.id);\n                tmp = this.get_node(p, true);\n\n                if (tmp && tmp.length) {\n                  tmp.attr('aria-selected', false).children('.jstree-anchor').removeClass(t ? 'jstree-clicked' : 'jstree-checked');\n                }\n              } else {\n                break;\n              }\n            }\n\n            p = this.get_node(p.parent);\n          }\n        }, this));\n      }\n    };\n    /**\n     * set the undetermined state where and if necessary. Used internally.\n     * @private\n     * @name _undetermined()\n     * @plugin checkbox\n     */\n\n\n    this._undetermined = function () {\n      if (this.element === null) {\n        return;\n      }\n\n      var i,\n          j,\n          k,\n          l,\n          o = {},\n          m = this._model.data,\n          t = this.settings.checkbox.tie_selection,\n          s = this._data[t ? 'core' : 'checkbox'].selected,\n          p = [],\n          tt = this;\n\n      for (i = 0, j = s.length; i < j; i++) {\n        if (m[s[i]] && m[s[i]].parents) {\n          for (k = 0, l = m[s[i]].parents.length; k < l; k++) {\n            if (o[m[s[i]].parents[k]] !== undefined) {\n              break;\n            }\n\n            if (m[s[i]].parents[k] !== $.jstree.root) {\n              o[m[s[i]].parents[k]] = true;\n              p.push(m[s[i]].parents[k]);\n            }\n          }\n        }\n      } // attempt for server side undetermined state\n\n\n      this.element.find('.jstree-closed').not(':has(.jstree-children)').each(function () {\n        var tmp = tt.get_node(this),\n            tmp2;\n\n        if (!tmp.state.loaded) {\n          if (tmp.original && tmp.original.state && tmp.original.state.undetermined && tmp.original.state.undetermined === true) {\n            if (o[tmp.id] === undefined && tmp.id !== $.jstree.root) {\n              o[tmp.id] = true;\n              p.push(tmp.id);\n            }\n\n            for (k = 0, l = tmp.parents.length; k < l; k++) {\n              if (o[tmp.parents[k]] === undefined && tmp.parents[k] !== $.jstree.root) {\n                o[tmp.parents[k]] = true;\n                p.push(tmp.parents[k]);\n              }\n            }\n          }\n        } else {\n          for (i = 0, j = tmp.children_d.length; i < j; i++) {\n            tmp2 = m[tmp.children_d[i]];\n\n            if (!tmp2.state.loaded && tmp2.original && tmp2.original.state && tmp2.original.state.undetermined && tmp2.original.state.undetermined === true) {\n              if (o[tmp2.id] === undefined && tmp2.id !== $.jstree.root) {\n                o[tmp2.id] = true;\n                p.push(tmp2.id);\n              }\n\n              for (k = 0, l = tmp2.parents.length; k < l; k++) {\n                if (o[tmp2.parents[k]] === undefined && tmp2.parents[k] !== $.jstree.root) {\n                  o[tmp2.parents[k]] = true;\n                  p.push(tmp2.parents[k]);\n                }\n              }\n            }\n          }\n        }\n      });\n      this.element.find('.jstree-undetermined').removeClass('jstree-undetermined');\n\n      for (i = 0, j = p.length; i < j; i++) {\n        if (!m[p[i]].state[t ? 'selected' : 'checked']) {\n          s = this.get_node(p[i], true);\n\n          if (s && s.length) {\n            s.children('.jstree-anchor').children('.jstree-checkbox').addClass('jstree-undetermined');\n          }\n        }\n      }\n    };\n\n    this.redraw_node = function (obj, deep, is_callback, force_render) {\n      obj = parent.redraw_node.apply(this, arguments);\n\n      if (obj) {\n        var i,\n            j,\n            tmp = null,\n            icon = null;\n\n        for (i = 0, j = obj.childNodes.length; i < j; i++) {\n          if (obj.childNodes[i] && obj.childNodes[i].className && obj.childNodes[i].className.indexOf(\"jstree-anchor\") !== -1) {\n            tmp = obj.childNodes[i];\n            break;\n          }\n        }\n\n        if (tmp) {\n          if (!this.settings.checkbox.tie_selection && this._model.data[obj.id].state.checked) {\n            tmp.className += ' jstree-checked';\n          }\n\n          icon = _i.cloneNode(false);\n\n          if (this._model.data[obj.id].state.checkbox_disabled) {\n            icon.className += ' jstree-checkbox-disabled';\n          }\n\n          tmp.insertBefore(icon, tmp.childNodes[0]);\n        }\n      }\n\n      if (!is_callback && this.settings.checkbox.cascade.indexOf('undetermined') !== -1) {\n        if (this._data.checkbox.uto) {\n          clearTimeout(this._data.checkbox.uto);\n        }\n\n        this._data.checkbox.uto = setTimeout($.proxy(this._undetermined, this), 50);\n      }\n\n      return obj;\n    };\n    /**\n     * show the node checkbox icons\n     * @name show_checkboxes()\n     * @plugin checkbox\n     */\n\n\n    this.show_checkboxes = function () {\n      this._data.core.themes.checkboxes = true;\n      this.get_container_ul().removeClass(\"jstree-no-checkboxes\");\n    };\n    /**\n     * hide the node checkbox icons\n     * @name hide_checkboxes()\n     * @plugin checkbox\n     */\n\n\n    this.hide_checkboxes = function () {\n      this._data.core.themes.checkboxes = false;\n      this.get_container_ul().addClass(\"jstree-no-checkboxes\");\n    };\n    /**\n     * toggle the node icons\n     * @name toggle_checkboxes()\n     * @plugin checkbox\n     */\n\n\n    this.toggle_checkboxes = function () {\n      if (this._data.core.themes.checkboxes) {\n        this.hide_checkboxes();\n      } else {\n        this.show_checkboxes();\n      }\n    };\n    /**\n     * checks if a node is in an undetermined state\n     * @name is_undetermined(obj)\n     * @param  {mixed} obj\n     * @return {Boolean}\n     */\n\n\n    this.is_undetermined = function (obj) {\n      obj = this.get_node(obj);\n      var s = this.settings.checkbox.cascade,\n          i,\n          j,\n          t = this.settings.checkbox.tie_selection,\n          d = this._data[t ? 'core' : 'checkbox'].selected,\n          m = this._model.data;\n\n      if (!obj || obj.state[t ? 'selected' : 'checked'] === true || s.indexOf('undetermined') === -1 || s.indexOf('down') === -1 && s.indexOf('up') === -1) {\n        return false;\n      }\n\n      if (!obj.state.loaded && obj.original.state.undetermined === true) {\n        return true;\n      }\n\n      for (i = 0, j = obj.children_d.length; i < j; i++) {\n        if ($.inArray(obj.children_d[i], d) !== -1 || !m[obj.children_d[i]].state.loaded && m[obj.children_d[i]].original.state.undetermined) {\n          return true;\n        }\n      }\n\n      return false;\n    };\n    /**\n     * disable a node's checkbox\n     * @name disable_checkbox(obj)\n     * @param {mixed} obj an array can be used too\n     * @trigger disable_checkbox.jstree\n     * @plugin checkbox\n     */\n\n\n    this.disable_checkbox = function (obj) {\n      var t1, t2, dom;\n\n      if ($.isArray(obj)) {\n        obj = obj.slice();\n\n        for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n          this.disable_checkbox(obj[t1]);\n        }\n\n        return true;\n      }\n\n      obj = this.get_node(obj);\n\n      if (!obj || obj.id === $.jstree.root) {\n        return false;\n      }\n\n      dom = this.get_node(obj, true);\n\n      if (!obj.state.checkbox_disabled) {\n        obj.state.checkbox_disabled = true;\n\n        if (dom && dom.length) {\n          dom.children('.jstree-anchor').children('.jstree-checkbox').addClass('jstree-checkbox-disabled');\n        }\n        /**\n         * triggered when an node's checkbox is disabled\n         * @event\n         * @name disable_checkbox.jstree\n         * @param {Object} node\n         * @plugin checkbox\n         */\n\n\n        this.trigger('disable_checkbox', {\n          'node': obj\n        });\n      }\n    };\n    /**\n     * enable a node's checkbox\n     * @name disable_checkbox(obj)\n     * @param {mixed} obj an array can be used too\n     * @trigger enable_checkbox.jstree\n     * @plugin checkbox\n     */\n\n\n    this.enable_checkbox = function (obj) {\n      var t1, t2, dom;\n\n      if ($.isArray(obj)) {\n        obj = obj.slice();\n\n        for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n          this.enable_checkbox(obj[t1]);\n        }\n\n        return true;\n      }\n\n      obj = this.get_node(obj);\n\n      if (!obj || obj.id === $.jstree.root) {\n        return false;\n      }\n\n      dom = this.get_node(obj, true);\n\n      if (obj.state.checkbox_disabled) {\n        obj.state.checkbox_disabled = false;\n\n        if (dom && dom.length) {\n          dom.children('.jstree-anchor').children('.jstree-checkbox').removeClass('jstree-checkbox-disabled');\n        }\n        /**\n         * triggered when an node's checkbox is enabled\n         * @event\n         * @name enable_checkbox.jstree\n         * @param {Object} node\n         * @plugin checkbox\n         */\n\n\n        this.trigger('enable_checkbox', {\n          'node': obj\n        });\n      }\n    };\n\n    this.activate_node = function (obj, e) {\n      if ($(e.target).hasClass('jstree-checkbox-disabled')) {\n        return false;\n      }\n\n      if (this.settings.checkbox.tie_selection && (this.settings.checkbox.whole_node || $(e.target).hasClass('jstree-checkbox'))) {\n        e.ctrlKey = true;\n      }\n\n      if (this.settings.checkbox.tie_selection || !this.settings.checkbox.whole_node && !$(e.target).hasClass('jstree-checkbox')) {\n        return parent.activate_node.call(this, obj, e);\n      }\n\n      if (this.is_disabled(obj)) {\n        return false;\n      }\n\n      if (this.is_checked(obj)) {\n        this.uncheck_node(obj, e);\n      } else {\n        this.check_node(obj, e);\n      }\n\n      this.trigger('activate_node', {\n        'node': this.get_node(obj)\n      });\n    };\n    /**\n     * check a node (only if tie_selection in checkbox settings is false, otherwise select_node will be called internally)\n     * @name check_node(obj)\n     * @param {mixed} obj an array can be used to check multiple nodes\n     * @trigger check_node.jstree\n     * @plugin checkbox\n     */\n\n\n    this.check_node = function (obj, e) {\n      if (this.settings.checkbox.tie_selection) {\n        return this.select_node(obj, false, true, e);\n      }\n\n      var dom, t1, t2, th;\n\n      if ($.isArray(obj)) {\n        obj = obj.slice();\n\n        for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n          this.check_node(obj[t1], e);\n        }\n\n        return true;\n      }\n\n      obj = this.get_node(obj);\n\n      if (!obj || obj.id === $.jstree.root) {\n        return false;\n      }\n\n      dom = this.get_node(obj, true);\n\n      if (!obj.state.checked) {\n        obj.state.checked = true;\n\n        this._data.checkbox.selected.push(obj.id);\n\n        if (dom && dom.length) {\n          dom.children('.jstree-anchor').addClass('jstree-checked');\n        }\n        /**\n         * triggered when an node is checked (only if tie_selection in checkbox settings is false)\n         * @event\n         * @name check_node.jstree\n         * @param {Object} node\n         * @param {Array} selected the current selection\n         * @param {Object} event the event (if any) that triggered this check_node\n         * @plugin checkbox\n         */\n\n\n        this.trigger('check_node', {\n          'node': obj,\n          'selected': this._data.checkbox.selected,\n          'event': e\n        });\n      }\n    };\n    /**\n     * uncheck a node (only if tie_selection in checkbox settings is false, otherwise deselect_node will be called internally)\n     * @name uncheck_node(obj)\n     * @param {mixed} obj an array can be used to uncheck multiple nodes\n     * @trigger uncheck_node.jstree\n     * @plugin checkbox\n     */\n\n\n    this.uncheck_node = function (obj, e) {\n      if (this.settings.checkbox.tie_selection) {\n        return this.deselect_node(obj, false, e);\n      }\n\n      var t1, t2, dom;\n\n      if ($.isArray(obj)) {\n        obj = obj.slice();\n\n        for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n          this.uncheck_node(obj[t1], e);\n        }\n\n        return true;\n      }\n\n      obj = this.get_node(obj);\n\n      if (!obj || obj.id === $.jstree.root) {\n        return false;\n      }\n\n      dom = this.get_node(obj, true);\n\n      if (obj.state.checked) {\n        obj.state.checked = false;\n        this._data.checkbox.selected = $.vakata.array_remove_item(this._data.checkbox.selected, obj.id);\n\n        if (dom.length) {\n          dom.children('.jstree-anchor').removeClass('jstree-checked');\n        }\n        /**\n         * triggered when an node is unchecked (only if tie_selection in checkbox settings is false)\n         * @event\n         * @name uncheck_node.jstree\n         * @param {Object} node\n         * @param {Array} selected the current selection\n         * @param {Object} event the event (if any) that triggered this uncheck_node\n         * @plugin checkbox\n         */\n\n\n        this.trigger('uncheck_node', {\n          'node': obj,\n          'selected': this._data.checkbox.selected,\n          'event': e\n        });\n      }\n    };\n    /**\n     * checks all nodes in the tree (only if tie_selection in checkbox settings is false, otherwise select_all will be called internally)\n     * @name check_all()\n     * @trigger check_all.jstree, changed.jstree\n     * @plugin checkbox\n     */\n\n\n    this.check_all = function () {\n      if (this.settings.checkbox.tie_selection) {\n        return this.select_all();\n      }\n\n      var tmp = this._data.checkbox.selected.concat([]),\n          i,\n          j;\n\n      this._data.checkbox.selected = this._model.data[$.jstree.root].children_d.concat();\n\n      for (i = 0, j = this._data.checkbox.selected.length; i < j; i++) {\n        if (this._model.data[this._data.checkbox.selected[i]]) {\n          this._model.data[this._data.checkbox.selected[i]].state.checked = true;\n        }\n      }\n\n      this.redraw(true);\n      /**\n       * triggered when all nodes are checked (only if tie_selection in checkbox settings is false)\n       * @event\n       * @name check_all.jstree\n       * @param {Array} selected the current selection\n       * @plugin checkbox\n       */\n\n      this.trigger('check_all', {\n        'selected': this._data.checkbox.selected\n      });\n    };\n    /**\n     * uncheck all checked nodes (only if tie_selection in checkbox settings is false, otherwise deselect_all will be called internally)\n     * @name uncheck_all()\n     * @trigger uncheck_all.jstree\n     * @plugin checkbox\n     */\n\n\n    this.uncheck_all = function () {\n      if (this.settings.checkbox.tie_selection) {\n        return this.deselect_all();\n      }\n\n      var tmp = this._data.checkbox.selected.concat([]),\n          i,\n          j;\n\n      for (i = 0, j = this._data.checkbox.selected.length; i < j; i++) {\n        if (this._model.data[this._data.checkbox.selected[i]]) {\n          this._model.data[this._data.checkbox.selected[i]].state.checked = false;\n        }\n      }\n\n      this._data.checkbox.selected = [];\n      this.element.find('.jstree-checked').removeClass('jstree-checked');\n      /**\n       * triggered when all nodes are unchecked (only if tie_selection in checkbox settings is false)\n       * @event\n       * @name uncheck_all.jstree\n       * @param {Object} node the previous selection\n       * @param {Array} selected the current selection\n       * @plugin checkbox\n       */\n\n      this.trigger('uncheck_all', {\n        'selected': this._data.checkbox.selected,\n        'node': tmp\n      });\n    };\n    /**\n     * checks if a node is checked (if tie_selection is on in the settings this function will return the same as is_selected)\n     * @name is_checked(obj)\n     * @param  {mixed}  obj\n     * @return {Boolean}\n     * @plugin checkbox\n     */\n\n\n    this.is_checked = function (obj) {\n      if (this.settings.checkbox.tie_selection) {\n        return this.is_selected(obj);\n      }\n\n      obj = this.get_node(obj);\n\n      if (!obj || obj.id === $.jstree.root) {\n        return false;\n      }\n\n      return obj.state.checked;\n    };\n    /**\n     * get an array of all checked nodes (if tie_selection is on in the settings this function will return the same as get_selected)\n     * @name get_checked([full])\n     * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned\n     * @return {Array}\n     * @plugin checkbox\n     */\n\n\n    this.get_checked = function (full) {\n      if (this.settings.checkbox.tie_selection) {\n        return this.get_selected(full);\n      }\n\n      return full ? $.map(this._data.checkbox.selected, $.proxy(function (i) {\n        return this.get_node(i);\n      }, this)) : this._data.checkbox.selected;\n    };\n    /**\n     * get an array of all top level checked nodes (ignoring children of checked nodes) (if tie_selection is on in the settings this function will return the same as get_top_selected)\n     * @name get_top_checked([full])\n     * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned\n     * @return {Array}\n     * @plugin checkbox\n     */\n\n\n    this.get_top_checked = function (full) {\n      if (this.settings.checkbox.tie_selection) {\n        return this.get_top_selected(full);\n      }\n\n      var tmp = this.get_checked(true),\n          obj = {},\n          i,\n          j,\n          k,\n          l;\n\n      for (i = 0, j = tmp.length; i < j; i++) {\n        obj[tmp[i].id] = tmp[i];\n      }\n\n      for (i = 0, j = tmp.length; i < j; i++) {\n        for (k = 0, l = tmp[i].children_d.length; k < l; k++) {\n          if (obj[tmp[i].children_d[k]]) {\n            delete obj[tmp[i].children_d[k]];\n          }\n        }\n      }\n\n      tmp = [];\n\n      for (i in obj) {\n        if (obj.hasOwnProperty(i)) {\n          tmp.push(i);\n        }\n      }\n\n      return full ? $.map(tmp, $.proxy(function (i) {\n        return this.get_node(i);\n      }, this)) : tmp;\n    };\n    /**\n     * get an array of all bottom level checked nodes (ignoring selected parents) (if tie_selection is on in the settings this function will return the same as get_bottom_selected)\n     * @name get_bottom_checked([full])\n     * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned\n     * @return {Array}\n     * @plugin checkbox\n     */\n\n\n    this.get_bottom_checked = function (full) {\n      if (this.settings.checkbox.tie_selection) {\n        return this.get_bottom_selected(full);\n      }\n\n      var tmp = this.get_checked(true),\n          obj = [],\n          i,\n          j;\n\n      for (i = 0, j = tmp.length; i < j; i++) {\n        if (!tmp[i].children.length) {\n          obj.push(tmp[i].id);\n        }\n      }\n\n      return full ? $.map(obj, $.proxy(function (i) {\n        return this.get_node(i);\n      }, this)) : obj;\n    };\n\n    this.load_node = function (obj, callback) {\n      var k, l, i, j, c, tmp;\n\n      if (!$.isArray(obj) && !this.settings.checkbox.tie_selection) {\n        tmp = this.get_node(obj);\n\n        if (tmp && tmp.state.loaded) {\n          for (k = 0, l = tmp.children_d.length; k < l; k++) {\n            if (this._model.data[tmp.children_d[k]].state.checked) {\n              c = true;\n              this._data.checkbox.selected = $.vakata.array_remove_item(this._data.checkbox.selected, tmp.children_d[k]);\n            }\n          }\n        }\n      }\n\n      return parent.load_node.apply(this, arguments);\n    };\n\n    this.get_state = function () {\n      var state = parent.get_state.apply(this, arguments);\n\n      if (this.settings.checkbox.tie_selection) {\n        return state;\n      }\n\n      state.checkbox = this._data.checkbox.selected.slice();\n      return state;\n    };\n\n    this.set_state = function (state, callback) {\n      var res = parent.set_state.apply(this, arguments);\n\n      if (res && state.checkbox) {\n        if (!this.settings.checkbox.tie_selection) {\n          this.uncheck_all();\n\n          var _this = this;\n\n          $.each(state.checkbox, function (i, v) {\n            _this.check_node(v);\n          });\n        }\n\n        delete state.checkbox;\n        this.set_state(state, callback);\n        return false;\n      }\n\n      return res;\n    };\n\n    this.refresh = function (skip_loading, forget_state) {\n      if (!this.settings.checkbox.tie_selection) {\n        this._data.checkbox.selected = [];\n      }\n\n      return parent.refresh.apply(this, arguments);\n    };\n  }; // include the checkbox plugin by default\n  // $.jstree.defaults.plugins.push(\"checkbox\");\n\n  /**\n   * ### Conditionalselect plugin\n   *\n   * This plugin allows defining a callback to allow or deny node selection by user input (activate node method).\n   */\n\n  /**\n   * a callback (function) which is invoked in the instance's scope and receives two arguments - the node and the event that triggered the `activate_node` call. Returning false prevents working with the node, returning true allows invoking activate_node. Defaults to returning `true`.\n   * @name $.jstree.defaults.checkbox.visible\n   * @plugin checkbox\n   */\n\n\n  $.jstree.defaults.conditionalselect = function () {\n    return true;\n  };\n\n  $.jstree.plugins.conditionalselect = function (options, parent) {\n    // own function\n    this.activate_node = function (obj, e) {\n      if (this.settings.conditionalselect.call(this, this.get_node(obj), e)) {\n        parent.activate_node.call(this, obj, e);\n      }\n    };\n  };\n  /**\n   * ### Contextmenu plugin\n   *\n   * Shows a context menu when a node is right-clicked.\n   */\n\n  /**\n   * stores all defaults for the contextmenu plugin\n   * @name $.jstree.defaults.contextmenu\n   * @plugin contextmenu\n   */\n\n\n  $.jstree.defaults.contextmenu = {\n    /**\n     * a boolean indicating if the node should be selected when the context menu is invoked on it. Defaults to `true`.\n     * @name $.jstree.defaults.contextmenu.select_node\n     * @plugin contextmenu\n     */\n    select_node: true,\n\n    /**\n     * a boolean indicating if the menu should be shown aligned with the node. Defaults to `true`, otherwise the mouse coordinates are used.\n     * @name $.jstree.defaults.contextmenu.show_at_node\n     * @plugin contextmenu\n     */\n    show_at_node: true,\n\n    /**\n     * an object of actions, or a function that accepts a node and a callback function and calls the callback function with an object of actions available for that node (you can also return the items too).\n     *\n     * Each action consists of a key (a unique name) and a value which is an object with the following properties (only label and action are required). Once a menu item is activated the `action` function will be invoked with an object containing the following keys: item - the contextmenu item definition as seen below, reference - the DOM node that was used (the tree node), element - the contextmenu DOM element, position - an object with x/y properties indicating the position of the menu.\n     *\n     * * `separator_before` - a boolean indicating if there should be a separator before this item\n     * * `separator_after` - a boolean indicating if there should be a separator after this item\n     * * `_disabled` - a boolean indicating if this action should be disabled\n     * * `label` - a string - the name of the action (could be a function returning a string)\n     * * `title` - a string - an optional tooltip for the item\n     * * `action` - a function to be executed if this item is chosen, the function will receive \n     * * `icon` - a string, can be a path to an icon or a className, if using an image that is in the current directory use a `./` prefix, otherwise it will be detected as a class\n     * * `shortcut` - keyCode which will trigger the action if the menu is open (for example `113` for rename, which equals F2)\n     * * `shortcut_label` - shortcut label (like for example `F2` for rename)\n     * * `submenu` - an object with the same structure as $.jstree.defaults.contextmenu.items which can be used to create a submenu - each key will be rendered as a separate option in a submenu that will appear once the current item is hovered\n     *\n     * @name $.jstree.defaults.contextmenu.items\n     * @plugin contextmenu\n     */\n    items: function items(o, cb) {\n      // Could be an object directly\n      return {\n        \"create\": {\n          \"separator_before\": false,\n          \"separator_after\": true,\n          \"_disabled\": false,\n          //(this.check(\"create_node\", data.reference, {}, \"last\")),\n          \"label\": \"Create\",\n          \"action\": function action(data) {\n            var inst = $.jstree.reference(data.reference),\n                obj = inst.get_node(data.reference);\n            inst.create_node(obj, {}, \"last\", function (new_node) {\n              setTimeout(function () {\n                inst.edit(new_node);\n              }, 0);\n            });\n          }\n        },\n        \"rename\": {\n          \"separator_before\": false,\n          \"separator_after\": false,\n          \"_disabled\": false,\n          //(this.check(\"rename_node\", data.reference, this.get_parent(data.reference), \"\")),\n          \"label\": \"Rename\",\n\n          /*!\n          \"shortcut\"\t\t\t: 113,\n          \"shortcut_label\"\t: 'F2',\n          \"icon\"\t\t\t\t: \"glyphicon glyphicon-leaf\",\n          */\n          \"action\": function action(data) {\n            var inst = $.jstree.reference(data.reference),\n                obj = inst.get_node(data.reference);\n            inst.edit(obj);\n          }\n        },\n        \"remove\": {\n          \"separator_before\": false,\n          \"icon\": false,\n          \"separator_after\": false,\n          \"_disabled\": false,\n          //(this.check(\"delete_node\", data.reference, this.get_parent(data.reference), \"\")),\n          \"label\": \"Delete\",\n          \"action\": function action(data) {\n            var inst = $.jstree.reference(data.reference),\n                obj = inst.get_node(data.reference);\n\n            if (inst.is_selected(obj)) {\n              inst.delete_node(inst.get_selected());\n            } else {\n              inst.delete_node(obj);\n            }\n          }\n        },\n        \"ccp\": {\n          \"separator_before\": true,\n          \"icon\": false,\n          \"separator_after\": false,\n          \"label\": \"Edit\",\n          \"action\": false,\n          \"submenu\": {\n            \"cut\": {\n              \"separator_before\": false,\n              \"separator_after\": false,\n              \"label\": \"Cut\",\n              \"action\": function action(data) {\n                var inst = $.jstree.reference(data.reference),\n                    obj = inst.get_node(data.reference);\n\n                if (inst.is_selected(obj)) {\n                  inst.cut(inst.get_top_selected());\n                } else {\n                  inst.cut(obj);\n                }\n              }\n            },\n            \"copy\": {\n              \"separator_before\": false,\n              \"icon\": false,\n              \"separator_after\": false,\n              \"label\": \"Copy\",\n              \"action\": function action(data) {\n                var inst = $.jstree.reference(data.reference),\n                    obj = inst.get_node(data.reference);\n\n                if (inst.is_selected(obj)) {\n                  inst.copy(inst.get_top_selected());\n                } else {\n                  inst.copy(obj);\n                }\n              }\n            },\n            \"paste\": {\n              \"separator_before\": false,\n              \"icon\": false,\n              \"_disabled\": function _disabled(data) {\n                return !$.jstree.reference(data.reference).can_paste();\n              },\n              \"separator_after\": false,\n              \"label\": \"Paste\",\n              \"action\": function action(data) {\n                var inst = $.jstree.reference(data.reference),\n                    obj = inst.get_node(data.reference);\n                inst.paste(obj);\n              }\n            }\n          }\n        }\n      };\n    }\n  };\n\n  $.jstree.plugins.contextmenu = function (options, parent) {\n    this.bind = function () {\n      parent.bind.call(this);\n      var last_ts = 0,\n          cto = null,\n          ex,\n          ey;\n      this.element.on(\"contextmenu.jstree\", \".jstree-anchor\", $.proxy(function (e, data) {\n        if (e.target.tagName.toLowerCase() === 'input') {\n          return;\n        }\n\n        e.preventDefault();\n        last_ts = e.ctrlKey ? +new Date() : 0;\n\n        if (data || cto) {\n          last_ts = +new Date() + 10000;\n        }\n\n        if (cto) {\n          clearTimeout(cto);\n        }\n\n        if (!this.is_loading(e.currentTarget)) {\n          this.show_contextmenu(e.currentTarget, e.pageX, e.pageY, e);\n        }\n      }, this)).on(\"click.jstree\", \".jstree-anchor\", $.proxy(function (e) {\n        if (this._data.contextmenu.visible && (!last_ts || +new Date() - last_ts > 250)) {\n          // work around safari & macOS ctrl+click\n          $.vakata.context.hide();\n        }\n\n        last_ts = 0;\n      }, this)).on(\"touchstart.jstree\", \".jstree-anchor\", function (e) {\n        if (!e.originalEvent || !e.originalEvent.changedTouches || !e.originalEvent.changedTouches[0]) {\n          return;\n        }\n\n        ex = e.originalEvent.changedTouches[0].clientX;\n        ey = e.originalEvent.changedTouches[0].clientY;\n        cto = setTimeout(function () {\n          $(e.currentTarget).trigger('contextmenu', true);\n        }, 750);\n      }).on('touchmove.vakata.jstree', function (e) {\n        if (cto && e.originalEvent && e.originalEvent.changedTouches && e.originalEvent.changedTouches[0] && (Math.abs(ex - e.originalEvent.changedTouches[0].clientX) > 50 || Math.abs(ey - e.originalEvent.changedTouches[0].clientY) > 50)) {\n          clearTimeout(cto);\n        }\n      }).on('touchend.vakata.jstree', function (e) {\n        if (cto) {\n          clearTimeout(cto);\n        }\n      });\n      /*!\n      if(!('oncontextmenu' in document.body) && ('ontouchstart' in document.body)) {\n      \tvar el = null, tm = null;\n      \tthis.element\n      \t\t.on(\"touchstart\", \".jstree-anchor\", function (e) {\n      \t\t\tel = e.currentTarget;\n      \t\t\ttm = +new Date();\n      \t\t\t$(document).one(\"touchend\", function (e) {\n      \t\t\t\te.target = document.elementFromPoint(e.originalEvent.targetTouches[0].pageX - window.pageXOffset, e.originalEvent.targetTouches[0].pageY - window.pageYOffset);\n      \t\t\t\te.currentTarget = e.target;\n      \t\t\t\ttm = ((+(new Date())) - tm);\n      \t\t\t\tif(e.target === el && tm > 600 && tm < 1000) {\n      \t\t\t\t\te.preventDefault();\n      \t\t\t\t\t$(el).trigger('contextmenu', e);\n      \t\t\t\t}\n      \t\t\t\tel = null;\n      \t\t\t\ttm = null;\n      \t\t\t});\n      \t\t});\n      }\n      */\n\n      $(document).on(\"context_hide.vakata.jstree\", $.proxy(function (e, data) {\n        this._data.contextmenu.visible = false;\n        $(data.reference).removeClass('jstree-context');\n      }, this));\n    };\n\n    this.teardown = function () {\n      if (this._data.contextmenu.visible) {\n        $.vakata.context.hide();\n      }\n\n      parent.teardown.call(this);\n    };\n    /**\n     * prepare and show the context menu for a node\n     * @name show_contextmenu(obj [, x, y])\n     * @param {mixed} obj the node\n     * @param {Number} x the x-coordinate relative to the document to show the menu at\n     * @param {Number} y the y-coordinate relative to the document to show the menu at\n     * @param {Object} e the event if available that triggered the contextmenu\n     * @plugin contextmenu\n     * @trigger show_contextmenu.jstree\n     */\n\n\n    this.show_contextmenu = function (obj, x, y, e) {\n      obj = this.get_node(obj);\n\n      if (!obj || obj.id === $.jstree.root) {\n        return false;\n      }\n\n      var s = this.settings.contextmenu,\n          d = this.get_node(obj, true),\n          a = d.children(\".jstree-anchor\"),\n          o = false,\n          i = false;\n\n      if (s.show_at_node || x === undefined || y === undefined) {\n        o = a.offset();\n        x = o.left;\n        y = o.top + this._data.core.li_height;\n      }\n\n      if (this.settings.contextmenu.select_node && !this.is_selected(obj)) {\n        this.activate_node(obj, e);\n      }\n\n      i = s.items;\n\n      if ($.isFunction(i)) {\n        i = i.call(this, obj, $.proxy(function (i) {\n          this._show_contextmenu(obj, x, y, i);\n        }, this));\n      }\n\n      if ($.isPlainObject(i)) {\n        this._show_contextmenu(obj, x, y, i);\n      }\n    };\n    /**\n     * show the prepared context menu for a node\n     * @name _show_contextmenu(obj, x, y, i)\n     * @param {mixed} obj the node\n     * @param {Number} x the x-coordinate relative to the document to show the menu at\n     * @param {Number} y the y-coordinate relative to the document to show the menu at\n     * @param {Number} i the object of items to show\n     * @plugin contextmenu\n     * @trigger show_contextmenu.jstree\n     * @private\n     */\n\n\n    this._show_contextmenu = function (obj, x, y, i) {\n      var d = this.get_node(obj, true),\n          a = d.children(\".jstree-anchor\");\n      $(document).one(\"context_show.vakata.jstree\", $.proxy(function (e, data) {\n        var cls = 'jstree-contextmenu jstree-' + this.get_theme() + '-contextmenu';\n        $(data.element).addClass(cls);\n        a.addClass('jstree-context');\n      }, this));\n      this._data.contextmenu.visible = true;\n      $.vakata.context.show(a, {\n        'x': x,\n        'y': y\n      }, i);\n      /**\n       * triggered when the contextmenu is shown for a node\n       * @event\n       * @name show_contextmenu.jstree\n       * @param {Object} node the node\n       * @param {Number} x the x-coordinate of the menu relative to the document\n       * @param {Number} y the y-coordinate of the menu relative to the document\n       * @plugin contextmenu\n       */\n\n      this.trigger('show_contextmenu', {\n        \"node\": obj,\n        \"x\": x,\n        \"y\": y\n      });\n    };\n  }; // contextmenu helper\n\n\n  (function ($) {\n    var right_to_left = false,\n        vakata_context = {\n      element: false,\n      reference: false,\n      position_x: 0,\n      position_y: 0,\n      items: [],\n      html: \"\",\n      is_visible: false\n    };\n    $.vakata.context = {\n      settings: {\n        hide_onmouseleave: 0,\n        icons: true\n      },\n      _trigger: function _trigger(event_name) {\n        $(document).triggerHandler(\"context_\" + event_name + \".vakata\", {\n          \"reference\": vakata_context.reference,\n          \"element\": vakata_context.element,\n          \"position\": {\n            \"x\": vakata_context.position_x,\n            \"y\": vakata_context.position_y\n          }\n        });\n      },\n      _execute: function _execute(i) {\n        i = vakata_context.items[i];\n        return i && (!i._disabled || $.isFunction(i._disabled) && !i._disabled({\n          \"item\": i,\n          \"reference\": vakata_context.reference,\n          \"element\": vakata_context.element\n        })) && i.action ? i.action.call(null, {\n          \"item\": i,\n          \"reference\": vakata_context.reference,\n          \"element\": vakata_context.element,\n          \"position\": {\n            \"x\": vakata_context.position_x,\n            \"y\": vakata_context.position_y\n          }\n        }) : false;\n      },\n      _parse: function _parse(o, is_callback) {\n        if (!o) {\n          return false;\n        }\n\n        if (!is_callback) {\n          vakata_context.html = \"\";\n          vakata_context.items = [];\n        }\n\n        var str = \"\",\n            sep = false,\n            tmp;\n\n        if (is_callback) {\n          str += \"<\" + \"ul>\";\n        }\n\n        $.each(o, function (i, val) {\n          if (!val) {\n            return true;\n          }\n\n          vakata_context.items.push(val);\n\n          if (!sep && val.separator_before) {\n            str += \"<\" + \"li class='vakata-context-separator'><\" + \"a href='#' \" + ($.vakata.context.settings.icons ? '' : 'style=\"margin-left:0px;\"') + \">&#160;<\" + \"/a><\" + \"/li>\";\n          }\n\n          sep = false;\n          str += \"<\" + \"li class='\" + (val._class || \"\") + (val._disabled === true || $.isFunction(val._disabled) && val._disabled({\n            \"item\": val,\n            \"reference\": vakata_context.reference,\n            \"element\": vakata_context.element\n          }) ? \" vakata-contextmenu-disabled \" : \"\") + \"' \" + (val.shortcut ? \" data-shortcut='\" + val.shortcut + \"' \" : '') + \">\";\n          str += \"<\" + \"a href='#' rel='\" + (vakata_context.items.length - 1) + \"' \" + (val.title ? \"title='\" + val.title + \"'\" : \"\") + \">\";\n\n          if ($.vakata.context.settings.icons) {\n            str += \"<\" + \"i \";\n\n            if (val.icon) {\n              if (val.icon.indexOf(\"/\") !== -1 || val.icon.indexOf(\".\") !== -1) {\n                str += \" style='background:url(\\\"\" + val.icon + \"\\\") center center no-repeat' \";\n              } else {\n                str += \" class='\" + val.icon + \"' \";\n              }\n            }\n\n            str += \"><\" + \"/i><\" + \"span class='vakata-contextmenu-sep'>&#160;<\" + \"/span>\";\n          }\n\n          str += ($.isFunction(val.label) ? val.label({\n            \"item\": i,\n            \"reference\": vakata_context.reference,\n            \"element\": vakata_context.element\n          }) : val.label) + (val.shortcut ? ' <span class=\"vakata-contextmenu-shortcut vakata-contextmenu-shortcut-' + val.shortcut + '\">' + (val.shortcut_label || '') + '</span>' : '') + \"<\" + \"/a>\";\n\n          if (val.submenu) {\n            tmp = $.vakata.context._parse(val.submenu, true);\n\n            if (tmp) {\n              str += tmp;\n            }\n          }\n\n          str += \"<\" + \"/li>\";\n\n          if (val.separator_after) {\n            str += \"<\" + \"li class='vakata-context-separator'><\" + \"a href='#' \" + ($.vakata.context.settings.icons ? '' : 'style=\"margin-left:0px;\"') + \">&#160;<\" + \"/a><\" + \"/li>\";\n            sep = true;\n          }\n        });\n        str = str.replace(/<li class\\='vakata-context-separator'\\><\\/li\\>$/, \"\");\n\n        if (is_callback) {\n          str += \"</ul>\";\n        }\n        /**\n         * triggered on the document when the contextmenu is parsed (HTML is built)\n         * @event\n         * @plugin contextmenu\n         * @name context_parse.vakata\n         * @param {jQuery} reference the element that was right clicked\n         * @param {jQuery} element the DOM element of the menu itself\n         * @param {Object} position the x & y coordinates of the menu\n         */\n\n\n        if (!is_callback) {\n          vakata_context.html = str;\n\n          $.vakata.context._trigger(\"parse\");\n        }\n\n        return str.length > 10 ? str : false;\n      },\n      _show_submenu: function _show_submenu(o) {\n        o = $(o);\n\n        if (!o.length || !o.children(\"ul\").length) {\n          return;\n        }\n\n        var e = o.children(\"ul\"),\n            xl = o.offset().left,\n            x = xl + o.outerWidth(),\n            y = o.offset().top,\n            w = e.width(),\n            h = e.height(),\n            dw = $(window).width() + $(window).scrollLeft(),\n            dh = $(window).height() + $(window).scrollTop(); //        -       \n\n        if (right_to_left) {\n          o[x - (w + 10 + o.outerWidth()) < 0 ? \"addClass\" : \"removeClass\"](\"vakata-context-left\");\n        } else {\n          o[x + w > dw && xl > dw - x ? \"addClass\" : \"removeClass\"](\"vakata-context-right\");\n        }\n\n        if (y + h + 10 > dh) {\n          e.css(\"bottom\", \"-1px\");\n        } //if does not fit - stick it to the side\n\n\n        if (o.hasClass('vakata-context-right')) {\n          if (xl < w) {\n            e.css(\"margin-right\", xl - w);\n          }\n        } else {\n          if (dw - x < w) {\n            e.css(\"margin-left\", dw - x - w);\n          }\n        }\n\n        e.show();\n      },\n      show: function show(reference, position, data) {\n        var o,\n            e,\n            x,\n            y,\n            w,\n            h,\n            dw,\n            dh,\n            cond = true;\n\n        if (vakata_context.element && vakata_context.element.length) {\n          vakata_context.element.width('');\n        }\n\n        switch (cond) {\n          case !position && !reference:\n            return false;\n\n          case !!position && !!reference:\n            vakata_context.reference = reference;\n            vakata_context.position_x = position.x;\n            vakata_context.position_y = position.y;\n            break;\n\n          case !position && !!reference:\n            vakata_context.reference = reference;\n            o = reference.offset();\n            vakata_context.position_x = o.left + reference.outerHeight();\n            vakata_context.position_y = o.top;\n            break;\n\n          case !!position && !reference:\n            vakata_context.position_x = position.x;\n            vakata_context.position_y = position.y;\n            break;\n        }\n\n        if (!!reference && !data && $(reference).data('vakata_contextmenu')) {\n          data = $(reference).data('vakata_contextmenu');\n        }\n\n        if ($.vakata.context._parse(data)) {\n          vakata_context.element.html(vakata_context.html);\n        }\n\n        if (vakata_context.items.length) {\n          vakata_context.element.appendTo(\"body\");\n          e = vakata_context.element;\n          x = vakata_context.position_x;\n          y = vakata_context.position_y;\n          w = e.width();\n          h = e.height();\n          dw = $(window).width() + $(window).scrollLeft();\n          dh = $(window).height() + $(window).scrollTop();\n\n          if (right_to_left) {\n            x -= e.outerWidth() - $(reference).outerWidth();\n\n            if (x < $(window).scrollLeft() + 20) {\n              x = $(window).scrollLeft() + 20;\n            }\n          }\n\n          if (x + w + 20 > dw) {\n            x = dw - (w + 20);\n          }\n\n          if (y + h + 20 > dh) {\n            y = dh - (h + 20);\n          }\n\n          vakata_context.element.css({\n            \"left\": x,\n            \"top\": y\n          }).show().find('a').first().focus().parent().addClass(\"vakata-context-hover\");\n          vakata_context.is_visible = true;\n          /**\n           * triggered on the document when the contextmenu is shown\n           * @event\n           * @plugin contextmenu\n           * @name context_show.vakata\n           * @param {jQuery} reference the element that was right clicked\n           * @param {jQuery} element the DOM element of the menu itself\n           * @param {Object} position the x & y coordinates of the menu\n           */\n\n          $.vakata.context._trigger(\"show\");\n        }\n      },\n      hide: function hide() {\n        if (vakata_context.is_visible) {\n          vakata_context.element.hide().find(\"ul\").hide().end().find(':focus').blur().end().detach();\n          vakata_context.is_visible = false;\n          /**\n           * triggered on the document when the contextmenu is hidden\n           * @event\n           * @plugin contextmenu\n           * @name context_hide.vakata\n           * @param {jQuery} reference the element that was right clicked\n           * @param {jQuery} element the DOM element of the menu itself\n           * @param {Object} position the x & y coordinates of the menu\n           */\n\n          $.vakata.context._trigger(\"hide\");\n        }\n      }\n    };\n    $(function () {\n      right_to_left = $(\"body\").css(\"direction\") === \"rtl\";\n      var to = false;\n      vakata_context.element = $(\"<ul class='vakata-context'></ul>\");\n      vakata_context.element.on(\"mouseenter\", \"li\", function (e) {\n        e.stopImmediatePropagation();\n\n        if ($.contains(this, e.relatedTarget)) {\n          //   delegate mouseleave -\n          // $(this).find(\".vakata-context-hover\").removeClass(\"vakata-context-hover\");\n          return;\n        }\n\n        if (to) {\n          clearTimeout(to);\n        }\n\n        vakata_context.element.find(\".vakata-context-hover\").removeClass(\"vakata-context-hover\").end();\n        $(this).siblings().find(\"ul\").hide().end().end().parentsUntil(\".vakata-context\", \"li\").addBack().addClass(\"vakata-context-hover\");\n\n        $.vakata.context._show_submenu(this);\n      }) //  -   ?\n      .on(\"mouseleave\", \"li\", function (e) {\n        if ($.contains(this, e.relatedTarget)) {\n          return;\n        }\n\n        $(this).find(\".vakata-context-hover\").addBack().removeClass(\"vakata-context-hover\");\n      }).on(\"mouseleave\", function (e) {\n        $(this).find(\".vakata-context-hover\").removeClass(\"vakata-context-hover\");\n\n        if ($.vakata.context.settings.hide_onmouseleave) {\n          to = setTimeout(function (t) {\n            return function () {\n              $.vakata.context.hide();\n            };\n          }(this), $.vakata.context.settings.hide_onmouseleave);\n        }\n      }).on(\"click\", \"a\", function (e) {\n        e.preventDefault(); //})\n        //.on(\"mouseup\", \"a\", function (e) {\n\n        if (!$(this).blur().parent().hasClass(\"vakata-context-disabled\") && $.vakata.context._execute($(this).attr(\"rel\")) !== false) {\n          $.vakata.context.hide();\n        }\n      }).on('keydown', 'a', function (e) {\n        var o = null;\n\n        switch (e.which) {\n          case 13:\n          case 32:\n            e.type = \"click\";\n            e.preventDefault();\n            $(e.currentTarget).trigger(e);\n            break;\n\n          case 37:\n            if (vakata_context.is_visible) {\n              vakata_context.element.find(\".vakata-context-hover\").last().closest(\"li\").first().find(\"ul\").hide().find(\".vakata-context-hover\").removeClass(\"vakata-context-hover\").end().end().children('a').focus();\n              e.stopImmediatePropagation();\n              e.preventDefault();\n            }\n\n            break;\n\n          case 38:\n            if (vakata_context.is_visible) {\n              o = vakata_context.element.find(\"ul:visible\").addBack().last().children(\".vakata-context-hover\").removeClass(\"vakata-context-hover\").prevAll(\"li:not(.vakata-context-separator)\").first();\n\n              if (!o.length) {\n                o = vakata_context.element.find(\"ul:visible\").addBack().last().children(\"li:not(.vakata-context-separator)\").last();\n              }\n\n              o.addClass(\"vakata-context-hover\").children('a').focus();\n              e.stopImmediatePropagation();\n              e.preventDefault();\n            }\n\n            break;\n\n          case 39:\n            if (vakata_context.is_visible) {\n              vakata_context.element.find(\".vakata-context-hover\").last().children(\"ul\").show().children(\"li:not(.vakata-context-separator)\").removeClass(\"vakata-context-hover\").first().addClass(\"vakata-context-hover\").children('a').focus();\n              e.stopImmediatePropagation();\n              e.preventDefault();\n            }\n\n            break;\n\n          case 40:\n            if (vakata_context.is_visible) {\n              o = vakata_context.element.find(\"ul:visible\").addBack().last().children(\".vakata-context-hover\").removeClass(\"vakata-context-hover\").nextAll(\"li:not(.vakata-context-separator)\").first();\n\n              if (!o.length) {\n                o = vakata_context.element.find(\"ul:visible\").addBack().last().children(\"li:not(.vakata-context-separator)\").first();\n              }\n\n              o.addClass(\"vakata-context-hover\").children('a').focus();\n              e.stopImmediatePropagation();\n              e.preventDefault();\n            }\n\n            break;\n\n          case 27:\n            $.vakata.context.hide();\n            e.preventDefault();\n            break;\n\n          default:\n            //console.log(e.which);\n            break;\n        }\n      }).on('keydown', function (e) {\n        e.preventDefault();\n        var a = vakata_context.element.find('.vakata-contextmenu-shortcut-' + e.which).parent();\n\n        if (a.parent().not('.vakata-context-disabled')) {\n          a.click();\n        }\n      });\n      $(document).on(\"mousedown.vakata.jstree\", function (e) {\n        if (vakata_context.is_visible && !$.contains(vakata_context.element[0], e.target)) {\n          $.vakata.context.hide();\n        }\n      }).on(\"context_show.vakata.jstree\", function (e, data) {\n        vakata_context.element.find(\"li:has(ul)\").children(\"a\").addClass(\"vakata-context-parent\");\n\n        if (right_to_left) {\n          vakata_context.element.addClass(\"vakata-context-rtl\").css(\"direction\", \"rtl\");\n        } // also apply a RTL class?\n\n\n        vakata_context.element.find(\"ul\").hide().end();\n      });\n    });\n  })($); // $.jstree.defaults.plugins.push(\"contextmenu\");\n\n  /**\n   * ### Drag'n'drop plugin\n   *\n   * Enables dragging and dropping of nodes in the tree, resulting in a move or copy operations.\n   */\n\n  /**\n   * stores all defaults for the drag'n'drop plugin\n   * @name $.jstree.defaults.dnd\n   * @plugin dnd\n   */\n\n\n  $.jstree.defaults.dnd = {\n    /**\n     * a boolean indicating if a copy should be possible while dragging (by pressint the meta key or Ctrl). Defaults to `true`.\n     * @name $.jstree.defaults.dnd.copy\n     * @plugin dnd\n     */\n    copy: true,\n\n    /**\n     * a number indicating how long a node should remain hovered while dragging to be opened. Defaults to `500`.\n     * @name $.jstree.defaults.dnd.open_timeout\n     * @plugin dnd\n     */\n    open_timeout: 500,\n\n    /**\n     * a function invoked each time a node is about to be dragged, invoked in the tree's scope and receives the nodes about to be dragged as an argument (array) and the event that started the drag - return `false` to prevent dragging\n     * @name $.jstree.defaults.dnd.is_draggable\n     * @plugin dnd\n     */\n    is_draggable: true,\n\n    /**\n     * a boolean indicating if checks should constantly be made while the user is dragging the node (as opposed to checking only on drop), default is `true`\n     * @name $.jstree.defaults.dnd.check_while_dragging\n     * @plugin dnd\n     */\n    check_while_dragging: true,\n\n    /**\n     * a boolean indicating if nodes from this tree should only be copied with dnd (as opposed to moved), default is `false`\n     * @name $.jstree.defaults.dnd.always_copy\n     * @plugin dnd\n     */\n    always_copy: false,\n\n    /**\n     * when dropping a node \"inside\", this setting indicates the position the node should go to - it can be an integer or a string: \"first\" (same as 0) or \"last\", default is `0`\n     * @name $.jstree.defaults.dnd.inside_pos\n     * @plugin dnd\n     */\n    inside_pos: 0,\n\n    /**\n     * when starting the drag on a node that is selected this setting controls if all selected nodes are dragged or only the single node, default is `true`, which means all selected nodes are dragged when the drag is started on a selected node\n     * @name $.jstree.defaults.dnd.drag_selection\n     * @plugin dnd\n     */\n    drag_selection: true,\n\n    /**\n     * controls whether dnd works on touch devices. If left as boolean true dnd will work the same as in desktop browsers, which in some cases may impair scrolling. If set to boolean false dnd will not work on touch devices. There is a special third option - string \"selected\" which means only selected nodes can be dragged on touch devices.\n     * @name $.jstree.defaults.dnd.touch\n     * @plugin dnd\n     */\n    touch: true,\n\n    /**\n     * controls whether items can be dropped anywhere on the node, not just on the anchor, by default only the node anchor is a valid drop target. Works best with the wholerow plugin. If enabled on mobile depending on the interface it might be hard for the user to cancel the drop, since the whole tree container will be a valid drop target.\n     * @name $.jstree.defaults.dnd.large_drop_target\n     * @plugin dnd\n     */\n    large_drop_target: false,\n\n    /**\n     * controls whether a drag can be initiated from any part of the node and not just the text/icon part, works best with the wholerow plugin. Keep in mind it can cause problems with tree scrolling on mobile depending on the interface - in that case set the touch option to \"selected\".\n     * @name $.jstree.defaults.dnd.large_drag_target\n     * @plugin dnd\n     */\n    large_drag_target: false,\n\n    /**\n     * controls whether use HTML5 dnd api instead of classical. That will allow better integration of dnd events with other HTML5 controls.\n     * @reference http://caniuse.com/#feat=dragndrop\n     * @name $.jstree.defaults.dnd.use_html5\n     * @plugin dnd\n     */\n    use_html5: false\n  };\n  var drg, elm; // TODO: now check works by checking for each node individually, how about max_children, unique, etc?\n\n  $.jstree.plugins.dnd = function (options, parent) {\n    this.init = function (el, options) {\n      parent.init.call(this, el, options);\n      this.settings.dnd.use_html5 = this.settings.dnd.use_html5 && 'draggable' in document.createElement('span');\n    };\n\n    this.bind = function () {\n      parent.bind.call(this);\n      this.element.on(this.settings.dnd.use_html5 ? 'dragstart.jstree' : 'mousedown.jstree touchstart.jstree', this.settings.dnd.large_drag_target ? '.jstree-node' : '.jstree-anchor', $.proxy(function (e) {\n        if (this.settings.dnd.large_drag_target && $(e.target).closest('.jstree-node')[0] !== e.currentTarget) {\n          return true;\n        }\n\n        if (e.type === \"touchstart\" && (!this.settings.dnd.touch || this.settings.dnd.touch === 'selected' && !$(e.currentTarget).closest('.jstree-node').children('.jstree-anchor').hasClass('jstree-clicked'))) {\n          return true;\n        }\n\n        var obj = this.get_node(e.target),\n            mlt = this.is_selected(obj) && this.settings.dnd.drag_selection ? this.get_top_selected().length : 1,\n            txt = mlt > 1 ? mlt + ' ' + this.get_string('nodes') : this.get_text(e.currentTarget);\n\n        if (this.settings.core.force_text) {\n          txt = $.vakata.html.escape(txt);\n        }\n\n        if (obj && obj.id && obj.id !== $.jstree.root && (e.which === 1 || e.type === \"touchstart\" || e.type === \"dragstart\") && (this.settings.dnd.is_draggable === true || $.isFunction(this.settings.dnd.is_draggable) && this.settings.dnd.is_draggable.call(this, mlt > 1 ? this.get_top_selected(true) : [obj], e))) {\n          drg = {\n            'jstree': true,\n            'origin': this,\n            'obj': this.get_node(obj, true),\n            'nodes': mlt > 1 ? this.get_top_selected() : [obj.id]\n          };\n          elm = e.currentTarget;\n\n          if (this.settings.dnd.use_html5) {\n            $.vakata.dnd._trigger('start', e, {\n              'helper': $(),\n              'element': elm,\n              'data': drg\n            });\n          } else {\n            this.element.trigger('mousedown.jstree');\n            return $.vakata.dnd.start(e, drg, '<div id=\"jstree-dnd\" class=\"jstree-' + this.get_theme() + ' jstree-' + this.get_theme() + '-' + this.get_theme_variant() + ' ' + (this.settings.core.themes.responsive ? ' jstree-dnd-responsive' : '') + '\"><i class=\"jstree-icon jstree-er\"></i>' + txt + '<ins class=\"jstree-copy\" style=\"display:none;\">+</ins></div>');\n          }\n        }\n      }, this));\n\n      if (this.settings.dnd.use_html5) {\n        this.element.on('dragover.jstree', function (e) {\n          e.preventDefault();\n\n          $.vakata.dnd._trigger('move', e, {\n            'helper': $(),\n            'element': elm,\n            'data': drg\n          });\n\n          return false;\n        }) //.on('dragenter.jstree', this.settings.dnd.large_drop_target ? '.jstree-node' : '.jstree-anchor', $.proxy(function (e) {\n        //\t\te.preventDefault();\n        //\t\t$.vakata.dnd._trigger('move', e, { 'helper': $(), 'element': elm, 'data': drg });\n        //\t\treturn false;\n        //\t}, this))\n        .on('drop.jstree', $.proxy(function (e) {\n          e.preventDefault();\n\n          $.vakata.dnd._trigger('stop', e, {\n            'helper': $(),\n            'element': elm,\n            'data': drg\n          });\n\n          return false;\n        }, this));\n      }\n    };\n\n    this.redraw_node = function (obj, deep, callback, force_render) {\n      obj = parent.redraw_node.apply(this, arguments);\n\n      if (obj && this.settings.dnd.use_html5) {\n        if (this.settings.dnd.large_drag_target) {\n          obj.setAttribute('draggable', true);\n        } else {\n          var i,\n              j,\n              tmp = null;\n\n          for (i = 0, j = obj.childNodes.length; i < j; i++) {\n            if (obj.childNodes[i] && obj.childNodes[i].className && obj.childNodes[i].className.indexOf(\"jstree-anchor\") !== -1) {\n              tmp = obj.childNodes[i];\n              break;\n            }\n          }\n\n          if (tmp) {\n            tmp.setAttribute('draggable', true);\n          }\n        }\n      }\n\n      return obj;\n    };\n  };\n\n  $(function () {\n    // bind only once for all instances\n    var lastmv = false,\n        laster = false,\n        lastev = false,\n        opento = false,\n        marker = $('<div id=\"jstree-marker\">&#160;</div>').hide(); //.appendTo('body');\n\n    $(document).on('dnd_start.vakata.jstree', function (e, data) {\n      lastmv = false;\n      lastev = false;\n\n      if (!data || !data.data || !data.data.jstree) {\n        return;\n      }\n\n      marker.appendTo('body'); //.show();\n    }).on('dnd_move.vakata.jstree', function (e, data) {\n      if (opento) {\n        if (!data.event || data.event.type !== 'dragover' || data.event.target !== lastev.target) {\n          clearTimeout(opento);\n        }\n      }\n\n      if (!data || !data.data || !data.data.jstree) {\n        return;\n      } // if we are hovering the marker image do nothing (can happen on \"inside\" drags)\n\n\n      if (data.event.target.id && data.event.target.id === 'jstree-marker') {\n        return;\n      }\n\n      lastev = data.event;\n      var ins = $.jstree.reference(data.event.target),\n          ref = false,\n          off = false,\n          rel = false,\n          tmp,\n          l,\n          t,\n          h,\n          p,\n          i,\n          o,\n          ok,\n          t1,\n          t2,\n          op,\n          ps,\n          pr,\n          ip,\n          tm,\n          is_copy,\n          pn; // if we are over an instance\n\n      if (ins && ins._data && ins._data.dnd) {\n        marker.attr('class', 'jstree-' + ins.get_theme() + (ins.settings.core.themes.responsive ? ' jstree-dnd-responsive' : ''));\n        is_copy = data.data.origin && (data.data.origin.settings.dnd.always_copy || data.data.origin.settings.dnd.copy && (data.event.metaKey || data.event.ctrlKey));\n        data.helper.children().attr('class', 'jstree-' + ins.get_theme() + ' jstree-' + ins.get_theme() + '-' + ins.get_theme_variant() + ' ' + (ins.settings.core.themes.responsive ? ' jstree-dnd-responsive' : '')).find('.jstree-copy').first()[is_copy ? 'show' : 'hide'](); // if are hovering the container itself add a new root node\n        //console.log(data.event);\n\n        if ((data.event.target === ins.element[0] || data.event.target === ins.get_container_ul()[0]) && ins.get_container_ul().children().length === 0) {\n          ok = true;\n\n          for (t1 = 0, t2 = data.data.nodes.length; t1 < t2; t1++) {\n            ok = ok && ins.check(data.data.origin && (data.data.origin.settings.dnd.always_copy || data.data.origin.settings.dnd.copy && (data.event.metaKey || data.event.ctrlKey)) ? \"copy_node\" : \"move_node\", data.data.origin && data.data.origin !== ins ? data.data.origin.get_node(data.data.nodes[t1]) : data.data.nodes[t1], $.jstree.root, 'last', {\n              'dnd': true,\n              'ref': ins.get_node($.jstree.root),\n              'pos': 'i',\n              'origin': data.data.origin,\n              'is_multi': data.data.origin && data.data.origin !== ins,\n              'is_foreign': !data.data.origin\n            });\n\n            if (!ok) {\n              break;\n            }\n          }\n\n          if (ok) {\n            lastmv = {\n              'ins': ins,\n              'par': $.jstree.root,\n              'pos': 'last'\n            };\n            marker.hide();\n            data.helper.find('.jstree-icon').first().removeClass('jstree-er').addClass('jstree-ok');\n\n            if (data.event.originalEvent && data.event.originalEvent.dataTransfer) {\n              data.event.originalEvent.dataTransfer.dropEffect = is_copy ? 'copy' : 'move';\n            }\n\n            return;\n          }\n        } else {\n          // if we are hovering a tree node\n          ref = ins.settings.dnd.large_drop_target ? $(data.event.target).closest('.jstree-node').children('.jstree-anchor') : $(data.event.target).closest('.jstree-anchor');\n\n          if (ref && ref.length && ref.parent().is('.jstree-closed, .jstree-open, .jstree-leaf')) {\n            off = ref.offset();\n            rel = (data.event.pageY !== undefined ? data.event.pageY : data.event.originalEvent.pageY) - off.top;\n            h = ref.outerHeight();\n\n            if (rel < h / 3) {\n              o = ['b', 'i', 'a'];\n            } else if (rel > h - h / 3) {\n              o = ['a', 'i', 'b'];\n            } else {\n              o = rel > h / 2 ? ['i', 'a', 'b'] : ['i', 'b', 'a'];\n            }\n\n            $.each(o, function (j, v) {\n              switch (v) {\n                case 'b':\n                  l = off.left - 6;\n                  t = off.top;\n                  p = ins.get_parent(ref);\n                  i = ref.parent().index();\n                  break;\n\n                case 'i':\n                  ip = ins.settings.dnd.inside_pos;\n                  tm = ins.get_node(ref.parent());\n                  l = off.left - 2;\n                  t = off.top + h / 2 + 1;\n                  p = tm.id;\n                  i = ip === 'first' ? 0 : ip === 'last' ? tm.children.length : Math.min(ip, tm.children.length);\n                  break;\n\n                case 'a':\n                  l = off.left - 6;\n                  t = off.top + h;\n                  p = ins.get_parent(ref);\n                  i = ref.parent().index() + 1;\n                  break;\n              }\n\n              ok = true;\n\n              for (t1 = 0, t2 = data.data.nodes.length; t1 < t2; t1++) {\n                op = data.data.origin && (data.data.origin.settings.dnd.always_copy || data.data.origin.settings.dnd.copy && (data.event.metaKey || data.event.ctrlKey)) ? \"copy_node\" : \"move_node\";\n                ps = i;\n\n                if (op === \"move_node\" && v === 'a' && data.data.origin && data.data.origin === ins && p === ins.get_parent(data.data.nodes[t1])) {\n                  pr = ins.get_node(p);\n\n                  if (ps > $.inArray(data.data.nodes[t1], pr.children)) {\n                    ps -= 1;\n                  }\n                }\n\n                ok = ok && (ins && ins.settings && ins.settings.dnd && ins.settings.dnd.check_while_dragging === false || ins.check(op, data.data.origin && data.data.origin !== ins ? data.data.origin.get_node(data.data.nodes[t1]) : data.data.nodes[t1], p, ps, {\n                  'dnd': true,\n                  'ref': ins.get_node(ref.parent()),\n                  'pos': v,\n                  'origin': data.data.origin,\n                  'is_multi': data.data.origin && data.data.origin !== ins,\n                  'is_foreign': !data.data.origin\n                }));\n\n                if (!ok) {\n                  if (ins && ins.last_error) {\n                    laster = ins.last_error();\n                  }\n\n                  break;\n                }\n              }\n\n              if (v === 'i' && ref.parent().is('.jstree-closed') && ins.settings.dnd.open_timeout) {\n                opento = setTimeout(function (x, z) {\n                  return function () {\n                    x.open_node(z);\n                  };\n                }(ins, ref), ins.settings.dnd.open_timeout);\n              }\n\n              if (ok) {\n                pn = ins.get_node(p, true);\n\n                if (!pn.hasClass('.jstree-dnd-parent')) {\n                  $('.jstree-dnd-parent').removeClass('jstree-dnd-parent');\n                  pn.addClass('jstree-dnd-parent');\n                }\n\n                lastmv = {\n                  'ins': ins,\n                  'par': p,\n                  'pos': v === 'i' && ip === 'last' && i === 0 && !ins.is_loaded(tm) ? 'last' : i\n                };\n                marker.css({\n                  'left': l + 'px',\n                  'top': t + 'px'\n                }).show();\n                data.helper.find('.jstree-icon').first().removeClass('jstree-er').addClass('jstree-ok');\n\n                if (data.event.originalEvent && data.event.originalEvent.dataTransfer) {\n                  data.event.originalEvent.dataTransfer.dropEffect = is_copy ? 'copy' : 'move';\n                }\n\n                laster = {};\n                o = true;\n                return false;\n              }\n            });\n\n            if (o === true) {\n              return;\n            }\n          }\n        }\n      }\n\n      $('.jstree-dnd-parent').removeClass('jstree-dnd-parent');\n      lastmv = false;\n      data.helper.find('.jstree-icon').removeClass('jstree-ok').addClass('jstree-er');\n\n      if (data.event.originalEvent && data.event.originalEvent.dataTransfer) {\n        data.event.originalEvent.dataTransfer.dropEffect = 'none';\n      }\n\n      marker.hide();\n    }).on('dnd_scroll.vakata.jstree', function (e, data) {\n      if (!data || !data.data || !data.data.jstree) {\n        return;\n      }\n\n      marker.hide();\n      lastmv = false;\n      lastev = false;\n      data.helper.find('.jstree-icon').first().removeClass('jstree-ok').addClass('jstree-er');\n    }).on('dnd_stop.vakata.jstree', function (e, data) {\n      $('.jstree-dnd-parent').removeClass('jstree-dnd-parent');\n\n      if (opento) {\n        clearTimeout(opento);\n      }\n\n      if (!data || !data.data || !data.data.jstree) {\n        return;\n      }\n\n      marker.hide().detach();\n      var i,\n          j,\n          nodes = [];\n\n      if (lastmv) {\n        for (i = 0, j = data.data.nodes.length; i < j; i++) {\n          nodes[i] = data.data.origin ? data.data.origin.get_node(data.data.nodes[i]) : data.data.nodes[i];\n        }\n\n        lastmv.ins[data.data.origin && (data.data.origin.settings.dnd.always_copy || data.data.origin.settings.dnd.copy && (data.event.metaKey || data.event.ctrlKey)) ? 'copy_node' : 'move_node'](nodes, lastmv.par, lastmv.pos, false, false, false, data.data.origin);\n      } else {\n        i = $(data.event.target).closest('.jstree');\n\n        if (i.length && laster && laster.error && laster.error === 'check') {\n          i = i.jstree(true);\n\n          if (i) {\n            i.settings.core.error.call(this, laster);\n          }\n        }\n      }\n\n      lastev = false;\n      lastmv = false;\n    }).on('keyup.jstree keydown.jstree', function (e, data) {\n      data = $.vakata.dnd._get();\n\n      if (data && data.data && data.data.jstree) {\n        if (e.type === \"keyup\" && e.which === 27) {\n          if (opento) {\n            clearTimeout(opento);\n          }\n\n          lastmv = false;\n          laster = false;\n          lastev = false;\n          opento = false;\n          marker.hide().detach();\n\n          $.vakata.dnd._clean();\n        } else {\n          data.helper.find('.jstree-copy').first()[data.data.origin && (data.data.origin.settings.dnd.always_copy || data.data.origin.settings.dnd.copy && (e.metaKey || e.ctrlKey)) ? 'show' : 'hide']();\n\n          if (lastev) {\n            lastev.metaKey = e.metaKey;\n            lastev.ctrlKey = e.ctrlKey;\n\n            $.vakata.dnd._trigger('move', lastev);\n          }\n        }\n      }\n    });\n  }); // helpers\n\n  (function ($) {\n    $.vakata.html = {\n      div: $('<div />'),\n      escape: function escape(str) {\n        return $.vakata.html.div.text(str).html();\n      },\n      strip: function strip(str) {\n        return $.vakata.html.div.empty().append($.parseHTML(str)).text();\n      }\n    }; // private variable\n\n    var vakata_dnd = {\n      element: false,\n      target: false,\n      is_down: false,\n      is_drag: false,\n      helper: false,\n      helper_w: 0,\n      data: false,\n      init_x: 0,\n      init_y: 0,\n      scroll_l: 0,\n      scroll_t: 0,\n      scroll_e: false,\n      scroll_i: false,\n      is_touch: false\n    };\n    $.vakata.dnd = {\n      settings: {\n        scroll_speed: 10,\n        scroll_proximity: 20,\n        helper_left: 5,\n        helper_top: 10,\n        threshold: 5,\n        threshold_touch: 50\n      },\n      _trigger: function _trigger(event_name, e, data) {\n        if (data === undefined) {\n          data = $.vakata.dnd._get();\n        }\n\n        data.event = e;\n        $(document).triggerHandler(\"dnd_\" + event_name + \".vakata\", data);\n      },\n      _get: function _get() {\n        return {\n          \"data\": vakata_dnd.data,\n          \"element\": vakata_dnd.element,\n          \"helper\": vakata_dnd.helper\n        };\n      },\n      _clean: function _clean() {\n        if (vakata_dnd.helper) {\n          vakata_dnd.helper.remove();\n        }\n\n        if (vakata_dnd.scroll_i) {\n          clearInterval(vakata_dnd.scroll_i);\n          vakata_dnd.scroll_i = false;\n        }\n\n        vakata_dnd = {\n          element: false,\n          target: false,\n          is_down: false,\n          is_drag: false,\n          helper: false,\n          helper_w: 0,\n          data: false,\n          init_x: 0,\n          init_y: 0,\n          scroll_l: 0,\n          scroll_t: 0,\n          scroll_e: false,\n          scroll_i: false,\n          is_touch: false\n        };\n        $(document).off(\"mousemove.vakata.jstree touchmove.vakata.jstree\", $.vakata.dnd.drag);\n        $(document).off(\"mouseup.vakata.jstree touchend.vakata.jstree\", $.vakata.dnd.stop);\n      },\n      _scroll: function _scroll(init_only) {\n        if (!vakata_dnd.scroll_e || !vakata_dnd.scroll_l && !vakata_dnd.scroll_t) {\n          if (vakata_dnd.scroll_i) {\n            clearInterval(vakata_dnd.scroll_i);\n            vakata_dnd.scroll_i = false;\n          }\n\n          return false;\n        }\n\n        if (!vakata_dnd.scroll_i) {\n          vakata_dnd.scroll_i = setInterval($.vakata.dnd._scroll, 100);\n          return false;\n        }\n\n        if (init_only === true) {\n          return false;\n        }\n\n        var i = vakata_dnd.scroll_e.scrollTop(),\n            j = vakata_dnd.scroll_e.scrollLeft();\n        vakata_dnd.scroll_e.scrollTop(i + vakata_dnd.scroll_t * $.vakata.dnd.settings.scroll_speed);\n        vakata_dnd.scroll_e.scrollLeft(j + vakata_dnd.scroll_l * $.vakata.dnd.settings.scroll_speed);\n\n        if (i !== vakata_dnd.scroll_e.scrollTop() || j !== vakata_dnd.scroll_e.scrollLeft()) {\n          /**\n           * triggered on the document when a drag causes an element to scroll\n           * @event\n           * @plugin dnd\n           * @name dnd_scroll.vakata\n           * @param {Mixed} data any data supplied with the call to $.vakata.dnd.start\n           * @param {DOM} element the DOM element being dragged\n           * @param {jQuery} helper the helper shown next to the mouse\n           * @param {jQuery} event the element that is scrolling\n           */\n          $.vakata.dnd._trigger(\"scroll\", vakata_dnd.scroll_e);\n        }\n      },\n      start: function start(e, data, html) {\n        if (e.type === \"touchstart\" && e.originalEvent && e.originalEvent.changedTouches && e.originalEvent.changedTouches[0]) {\n          e.pageX = e.originalEvent.changedTouches[0].pageX;\n          e.pageY = e.originalEvent.changedTouches[0].pageY;\n          e.target = document.elementFromPoint(e.originalEvent.changedTouches[0].pageX - window.pageXOffset, e.originalEvent.changedTouches[0].pageY - window.pageYOffset);\n        }\n\n        if (vakata_dnd.is_drag) {\n          $.vakata.dnd.stop({});\n        }\n\n        try {\n          e.currentTarget.unselectable = \"on\";\n\n          e.currentTarget.onselectstart = function () {\n            return false;\n          };\n\n          if (e.currentTarget.style) {\n            e.currentTarget.style.touchAction = \"none\";\n            e.currentTarget.style.msTouchAction = \"none\";\n            e.currentTarget.style.MozUserSelect = \"none\";\n          }\n        } catch (ignore) {}\n\n        vakata_dnd.init_x = e.pageX;\n        vakata_dnd.init_y = e.pageY;\n        vakata_dnd.data = data;\n        vakata_dnd.is_down = true;\n        vakata_dnd.element = e.currentTarget;\n        vakata_dnd.target = e.target;\n        vakata_dnd.is_touch = e.type === \"touchstart\";\n\n        if (html !== false) {\n          vakata_dnd.helper = $(\"<div id='vakata-dnd'></div>\").html(html).css({\n            \"display\": \"block\",\n            \"margin\": \"0\",\n            \"padding\": \"0\",\n            \"position\": \"absolute\",\n            \"top\": \"-2000px\",\n            \"lineHeight\": \"16px\",\n            \"zIndex\": \"10000\"\n          });\n        }\n\n        $(document).on(\"mousemove.vakata.jstree touchmove.vakata.jstree\", $.vakata.dnd.drag);\n        $(document).on(\"mouseup.vakata.jstree touchend.vakata.jstree\", $.vakata.dnd.stop);\n        return false;\n      },\n      drag: function drag(e) {\n        if (e.type === \"touchmove\" && e.originalEvent && e.originalEvent.changedTouches && e.originalEvent.changedTouches[0]) {\n          e.pageX = e.originalEvent.changedTouches[0].pageX;\n          e.pageY = e.originalEvent.changedTouches[0].pageY;\n          e.target = document.elementFromPoint(e.originalEvent.changedTouches[0].pageX - window.pageXOffset, e.originalEvent.changedTouches[0].pageY - window.pageYOffset);\n        }\n\n        if (!vakata_dnd.is_down) {\n          return;\n        }\n\n        if (!vakata_dnd.is_drag) {\n          if (Math.abs(e.pageX - vakata_dnd.init_x) > (vakata_dnd.is_touch ? $.vakata.dnd.settings.threshold_touch : $.vakata.dnd.settings.threshold) || Math.abs(e.pageY - vakata_dnd.init_y) > (vakata_dnd.is_touch ? $.vakata.dnd.settings.threshold_touch : $.vakata.dnd.settings.threshold)) {\n            if (vakata_dnd.helper) {\n              vakata_dnd.helper.appendTo(\"body\");\n              vakata_dnd.helper_w = vakata_dnd.helper.outerWidth();\n            }\n\n            vakata_dnd.is_drag = true;\n            $(vakata_dnd.target).one('click.vakata', false);\n            /**\n             * triggered on the document when a drag starts\n             * @event\n             * @plugin dnd\n             * @name dnd_start.vakata\n             * @param {Mixed} data any data supplied with the call to $.vakata.dnd.start\n             * @param {DOM} element the DOM element being dragged\n             * @param {jQuery} helper the helper shown next to the mouse\n             * @param {Object} event the event that caused the start (probably mousemove)\n             */\n\n            $.vakata.dnd._trigger(\"start\", e);\n          } else {\n            return;\n          }\n        }\n\n        var d = false,\n            w = false,\n            dh = false,\n            wh = false,\n            dw = false,\n            ww = false,\n            dt = false,\n            dl = false,\n            ht = false,\n            hl = false;\n        vakata_dnd.scroll_t = 0;\n        vakata_dnd.scroll_l = 0;\n        vakata_dnd.scroll_e = false;\n        $($(e.target).parentsUntil(\"body\").addBack().get().reverse()).filter(function () {\n          return /^auto|scroll$/.test($(this).css(\"overflow\")) && (this.scrollHeight > this.offsetHeight || this.scrollWidth > this.offsetWidth);\n        }).each(function () {\n          var t = $(this),\n              o = t.offset();\n\n          if (this.scrollHeight > this.offsetHeight) {\n            if (o.top + t.height() - e.pageY < $.vakata.dnd.settings.scroll_proximity) {\n              vakata_dnd.scroll_t = 1;\n            }\n\n            if (e.pageY - o.top < $.vakata.dnd.settings.scroll_proximity) {\n              vakata_dnd.scroll_t = -1;\n            }\n          }\n\n          if (this.scrollWidth > this.offsetWidth) {\n            if (o.left + t.width() - e.pageX < $.vakata.dnd.settings.scroll_proximity) {\n              vakata_dnd.scroll_l = 1;\n            }\n\n            if (e.pageX - o.left < $.vakata.dnd.settings.scroll_proximity) {\n              vakata_dnd.scroll_l = -1;\n            }\n          }\n\n          if (vakata_dnd.scroll_t || vakata_dnd.scroll_l) {\n            vakata_dnd.scroll_e = $(this);\n            return false;\n          }\n        });\n\n        if (!vakata_dnd.scroll_e) {\n          d = $(document);\n          w = $(window);\n          dh = d.height();\n          wh = w.height();\n          dw = d.width();\n          ww = w.width();\n          dt = d.scrollTop();\n          dl = d.scrollLeft();\n\n          if (dh > wh && e.pageY - dt < $.vakata.dnd.settings.scroll_proximity) {\n            vakata_dnd.scroll_t = -1;\n          }\n\n          if (dh > wh && wh - (e.pageY - dt) < $.vakata.dnd.settings.scroll_proximity) {\n            vakata_dnd.scroll_t = 1;\n          }\n\n          if (dw > ww && e.pageX - dl < $.vakata.dnd.settings.scroll_proximity) {\n            vakata_dnd.scroll_l = -1;\n          }\n\n          if (dw > ww && ww - (e.pageX - dl) < $.vakata.dnd.settings.scroll_proximity) {\n            vakata_dnd.scroll_l = 1;\n          }\n\n          if (vakata_dnd.scroll_t || vakata_dnd.scroll_l) {\n            vakata_dnd.scroll_e = d;\n          }\n        }\n\n        if (vakata_dnd.scroll_e) {\n          $.vakata.dnd._scroll(true);\n        }\n\n        if (vakata_dnd.helper) {\n          ht = parseInt(e.pageY + $.vakata.dnd.settings.helper_top, 10);\n          hl = parseInt(e.pageX + $.vakata.dnd.settings.helper_left, 10);\n\n          if (dh && ht + 25 > dh) {\n            ht = dh - 50;\n          }\n\n          if (dw && hl + vakata_dnd.helper_w > dw) {\n            hl = dw - (vakata_dnd.helper_w + 2);\n          }\n\n          vakata_dnd.helper.css({\n            left: hl + \"px\",\n            top: ht + \"px\"\n          });\n        }\n        /**\n         * triggered on the document when a drag is in progress\n         * @event\n         * @plugin dnd\n         * @name dnd_move.vakata\n         * @param {Mixed} data any data supplied with the call to $.vakata.dnd.start\n         * @param {DOM} element the DOM element being dragged\n         * @param {jQuery} helper the helper shown next to the mouse\n         * @param {Object} event the event that caused this to trigger (most likely mousemove)\n         */\n\n\n        $.vakata.dnd._trigger(\"move\", e);\n\n        return false;\n      },\n      stop: function stop(e) {\n        if (e.type === \"touchend\" && e.originalEvent && e.originalEvent.changedTouches && e.originalEvent.changedTouches[0]) {\n          e.pageX = e.originalEvent.changedTouches[0].pageX;\n          e.pageY = e.originalEvent.changedTouches[0].pageY;\n          e.target = document.elementFromPoint(e.originalEvent.changedTouches[0].pageX - window.pageXOffset, e.originalEvent.changedTouches[0].pageY - window.pageYOffset);\n        }\n\n        if (vakata_dnd.is_drag) {\n          /**\n           * triggered on the document when a drag stops (the dragged element is dropped)\n           * @event\n           * @plugin dnd\n           * @name dnd_stop.vakata\n           * @param {Mixed} data any data supplied with the call to $.vakata.dnd.start\n           * @param {DOM} element the DOM element being dragged\n           * @param {jQuery} helper the helper shown next to the mouse\n           * @param {Object} event the event that caused the stop\n           */\n          if (e.target !== vakata_dnd.target) {\n            $(vakata_dnd.target).off('click.vakata');\n          }\n\n          $.vakata.dnd._trigger(\"stop\", e);\n        } else {\n          if (e.type === \"touchend\" && e.target === vakata_dnd.target) {\n            var to = setTimeout(function () {\n              $(e.target).click();\n            }, 100);\n            $(e.target).one('click', function () {\n              if (to) {\n                clearTimeout(to);\n              }\n            });\n          }\n        }\n\n        $.vakata.dnd._clean();\n\n        return false;\n      }\n    };\n  })($); // include the dnd plugin by default\n  // $.jstree.defaults.plugins.push(\"dnd\");\n\n  /**\n   * ### Massload plugin\n   *\n   * Adds massload functionality to jsTree, so that multiple nodes can be loaded in a single request (only useful with lazy loading).\n   */\n\n  /**\n   * massload configuration\n   *\n   * It is possible to set this to a standard jQuery-like AJAX config.\n   * In addition to the standard jQuery ajax options here you can supply functions for `data` and `url`, the functions will be run in the current instance's scope and a param will be passed indicating which node IDs need to be loaded, the return value of those functions will be used.\n   *\n   * You can also set this to a function, that function will receive the node IDs being loaded as argument and a second param which is a function (callback) which should be called with the result.\n   *\n   * Both the AJAX and the function approach rely on the same return value - an object where the keys are the node IDs, and the value is the children of that node as an array.\n   *\n   *\t{\n   *\t\t\"id1\" : [{ \"text\" : \"Child of ID1\", \"id\" : \"c1\" }, { \"text\" : \"Another child of ID1\", \"id\" : \"c2\" }],\n   *\t\t\"id2\" : [{ \"text\" : \"Child of ID2\", \"id\" : \"c3\" }]\n   *\t}\n   * \n   * @name $.jstree.defaults.massload\n   * @plugin massload\n   */\n\n\n  $.jstree.defaults.massload = null;\n\n  $.jstree.plugins.massload = function (options, parent) {\n    this.init = function (el, options) {\n      this._data.massload = {};\n      parent.init.call(this, el, options);\n    };\n\n    this._load_nodes = function (nodes, callback, is_callback, force_reload) {\n      var s = this.settings.massload,\n          nodesString = JSON.stringify(nodes),\n          toLoad = [],\n          m = this._model.data,\n          i,\n          j,\n          dom;\n\n      if (!is_callback) {\n        for (i = 0, j = nodes.length; i < j; i++) {\n          if (!m[nodes[i]] || !m[nodes[i]].state.loaded && !m[nodes[i]].state.failed || force_reload) {\n            toLoad.push(nodes[i]);\n            dom = this.get_node(nodes[i], true);\n\n            if (dom && dom.length) {\n              dom.addClass(\"jstree-loading\").attr('aria-busy', true);\n            }\n          }\n        }\n\n        this._data.massload = {};\n\n        if (toLoad.length) {\n          if ($.isFunction(s)) {\n            return s.call(this, toLoad, $.proxy(function (data) {\n              var i, j;\n\n              if (data) {\n                for (i in data) {\n                  if (data.hasOwnProperty(i)) {\n                    this._data.massload[i] = data[i];\n                  }\n                }\n              }\n\n              for (i = 0, j = nodes.length; i < j; i++) {\n                dom = this.get_node(nodes[i], true);\n\n                if (dom && dom.length) {\n                  dom.removeClass(\"jstree-loading\").attr('aria-busy', false);\n                }\n              }\n\n              parent._load_nodes.call(this, nodes, callback, is_callback, force_reload);\n            }, this));\n          }\n\n          if (_typeof(s) === 'object' && s && s.url) {\n            s = $.extend(true, {}, s);\n\n            if ($.isFunction(s.url)) {\n              s.url = s.url.call(this, toLoad);\n            }\n\n            if ($.isFunction(s.data)) {\n              s.data = s.data.call(this, toLoad);\n            }\n\n            return $.ajax(s).done($.proxy(function (data, t, x) {\n              var i, j;\n\n              if (data) {\n                for (i in data) {\n                  if (data.hasOwnProperty(i)) {\n                    this._data.massload[i] = data[i];\n                  }\n                }\n              }\n\n              for (i = 0, j = nodes.length; i < j; i++) {\n                dom = this.get_node(nodes[i], true);\n\n                if (dom && dom.length) {\n                  dom.removeClass(\"jstree-loading\").attr('aria-busy', false);\n                }\n              }\n\n              parent._load_nodes.call(this, nodes, callback, is_callback, force_reload);\n            }, this)).fail($.proxy(function (f) {\n              parent._load_nodes.call(this, nodes, callback, is_callback, force_reload);\n            }, this));\n          }\n        }\n      }\n\n      return parent._load_nodes.call(this, nodes, callback, is_callback, force_reload);\n    };\n\n    this._load_node = function (obj, callback) {\n      var data = this._data.massload[obj.id],\n          rslt = null,\n          dom;\n\n      if (data) {\n        rslt = this[typeof data === 'string' ? '_append_html_data' : '_append_json_data'](obj, typeof data === 'string' ? $($.parseHTML(data)).filter(function () {\n          return this.nodeType !== 3;\n        }) : data, function (status) {\n          callback.call(this, status);\n        });\n        dom = this.get_node(obj.id, true);\n\n        if (dom && dom.length) {\n          dom.removeClass(\"jstree-loading\").attr('aria-busy', false);\n        }\n\n        delete this._data.massload[obj.id];\n        return rslt;\n      }\n\n      return parent._load_node.call(this, obj, callback);\n    };\n  };\n  /**\n   * ### Search plugin\n   *\n   * Adds search functionality to jsTree.\n   */\n\n  /**\n   * stores all defaults for the search plugin\n   * @name $.jstree.defaults.search\n   * @plugin search\n   */\n\n\n  $.jstree.defaults.search = {\n    /**\n     * a jQuery-like AJAX config, which jstree uses if a server should be queried for results.\n     *\n     * A `str` (which is the search string) parameter will be added with the request, an optional `inside` parameter will be added if the search is limited to a node id. The expected result is a JSON array with nodes that need to be opened so that matching nodes will be revealed.\n     * Leave this setting as `false` to not query the server. You can also set this to a function, which will be invoked in the instance's scope and receive 3 parameters - the search string, the callback to call with the array of nodes to load, and the optional node ID to limit the search to\n     * @name $.jstree.defaults.search.ajax\n     * @plugin search\n     */\n    ajax: false,\n\n    /**\n     * Indicates if the search should be fuzzy or not (should `chnd3` match `child node 3`). Default is `false`.\n     * @name $.jstree.defaults.search.fuzzy\n     * @plugin search\n     */\n    fuzzy: false,\n\n    /**\n     * Indicates if the search should be case sensitive. Default is `false`.\n     * @name $.jstree.defaults.search.case_sensitive\n     * @plugin search\n     */\n    case_sensitive: false,\n\n    /**\n     * Indicates if the tree should be filtered (by default) to show only matching nodes (keep in mind this can be a heavy on large trees in old browsers).\n     * This setting can be changed at runtime when calling the search method. Default is `false`.\n     * @name $.jstree.defaults.search.show_only_matches\n     * @plugin search\n     */\n    show_only_matches: false,\n\n    /**\n     * Indicates if the children of matched element are shown (when show_only_matches is true)\n     * This setting can be changed at runtime when calling the search method. Default is `false`.\n     * @name $.jstree.defaults.search.show_only_matches_children\n     * @plugin search\n     */\n    show_only_matches_children: false,\n\n    /**\n     * Indicates if all nodes opened to reveal the search result, should be closed when the search is cleared or a new search is performed. Default is `true`.\n     * @name $.jstree.defaults.search.close_opened_onclear\n     * @plugin search\n     */\n    close_opened_onclear: true,\n\n    /**\n     * Indicates if only leaf nodes should be included in search results. Default is `false`.\n     * @name $.jstree.defaults.search.search_leaves_only\n     * @plugin search\n     */\n    search_leaves_only: false,\n\n    /**\n     * If set to a function it wil be called in the instance's scope with two arguments - search string and node (where node will be every node in the structure, so use with caution).\n     * If the function returns a truthy value the node will be considered a match (it might not be displayed if search_only_leaves is set to true and the node is not a leaf). Default is `false`.\n     * @name $.jstree.defaults.search.search_callback\n     * @plugin search\n     */\n    search_callback: false\n  };\n\n  $.jstree.plugins.search = function (options, parent) {\n    this.bind = function () {\n      parent.bind.call(this);\n      this._data.search.str = \"\";\n      this._data.search.dom = $();\n      this._data.search.res = [];\n      this._data.search.opn = [];\n      this._data.search.som = false;\n      this._data.search.smc = false;\n      this._data.search.hdn = [];\n      this.element.on(\"search.jstree\", $.proxy(function (e, data) {\n        if (this._data.search.som && data.res.length) {\n          var m = this._model.data,\n              i,\n              j,\n              p = [],\n              k,\n              l;\n\n          for (i = 0, j = data.res.length; i < j; i++) {\n            if (m[data.res[i]] && !m[data.res[i]].state.hidden) {\n              p.push(data.res[i]);\n              p = p.concat(m[data.res[i]].parents);\n\n              if (this._data.search.smc) {\n                for (k = 0, l = m[data.res[i]].children_d.length; k < l; k++) {\n                  if (m[m[data.res[i]].children_d[k]] && !m[m[data.res[i]].children_d[k]].state.hidden) {\n                    p.push(m[data.res[i]].children_d[k]);\n                  }\n                }\n              }\n            }\n          }\n\n          p = $.vakata.array_remove_item($.vakata.array_unique(p), $.jstree.root);\n          this._data.search.hdn = this.hide_all(true);\n          this.show_node(p, true);\n          this.redraw(true);\n        }\n      }, this)).on(\"clear_search.jstree\", $.proxy(function (e, data) {\n        if (this._data.search.som && data.res.length) {\n          this.show_node(this._data.search.hdn, true);\n          this.redraw(true);\n        }\n      }, this));\n    };\n    /**\n     * used to search the tree nodes for a given string\n     * @name search(str [, skip_async])\n     * @param {String} str the search string\n     * @param {Boolean} skip_async if set to true server will not be queried even if configured\n     * @param {Boolean} show_only_matches if set to true only matching nodes will be shown (keep in mind this can be very slow on large trees or old browsers)\n     * @param {mixed} inside an optional node to whose children to limit the search\n     * @param {Boolean} append if set to true the results of this search are appended to the previous search\n     * @plugin search\n     * @trigger search.jstree\n     */\n\n\n    this.search = function (str, skip_async, show_only_matches, inside, append, show_only_matches_children) {\n      if (str === false || $.trim(str.toString()) === \"\") {\n        return this.clear_search();\n      }\n\n      inside = this.get_node(inside);\n      inside = inside && inside.id ? inside.id : null;\n      str = str.toString();\n      var s = this.settings.search,\n          a = s.ajax ? s.ajax : false,\n          m = this._model.data,\n          f = null,\n          r = [],\n          p = [],\n          i,\n          j;\n\n      if (this._data.search.res.length && !append) {\n        this.clear_search();\n      }\n\n      if (show_only_matches === undefined) {\n        show_only_matches = s.show_only_matches;\n      }\n\n      if (show_only_matches_children === undefined) {\n        show_only_matches_children = s.show_only_matches_children;\n      }\n\n      if (!skip_async && a !== false) {\n        if ($.isFunction(a)) {\n          return a.call(this, str, $.proxy(function (d) {\n            if (d && d.d) {\n              d = d.d;\n            }\n\n            this._load_nodes(!$.isArray(d) ? [] : $.vakata.array_unique(d), function () {\n              this.search(str, true, show_only_matches, inside, append, show_only_matches_children);\n            });\n          }, this), inside);\n        } else {\n          a = $.extend({}, a);\n\n          if (!a.data) {\n            a.data = {};\n          }\n\n          a.data.str = str;\n\n          if (inside) {\n            a.data.inside = inside;\n          }\n\n          if (this._data.search.lastRequest) {\n            this._data.search.lastRequest.abort();\n          }\n\n          this._data.search.lastRequest = $.ajax(a).fail($.proxy(function () {\n            this._data.core.last_error = {\n              'error': 'ajax',\n              'plugin': 'search',\n              'id': 'search_01',\n              'reason': 'Could not load search parents',\n              'data': JSON.stringify(a)\n            };\n            this.settings.core.error.call(this, this._data.core.last_error);\n          }, this)).done($.proxy(function (d) {\n            if (d && d.d) {\n              d = d.d;\n            }\n\n            this._load_nodes(!$.isArray(d) ? [] : $.vakata.array_unique(d), function () {\n              this.search(str, true, show_only_matches, inside, append, show_only_matches_children);\n            });\n          }, this));\n          return this._data.search.lastRequest;\n        }\n      }\n\n      if (!append) {\n        this._data.search.str = str;\n        this._data.search.dom = $();\n        this._data.search.res = [];\n        this._data.search.opn = [];\n        this._data.search.som = show_only_matches;\n        this._data.search.smc = show_only_matches_children;\n      }\n\n      f = new $.vakata.search(str, true, {\n        caseSensitive: s.case_sensitive,\n        fuzzy: s.fuzzy\n      });\n      $.each(m[inside ? inside : $.jstree.root].children_d, function (ii, i) {\n        var v = m[i];\n\n        if (v.text && !v.state.hidden && (!s.search_leaves_only || v.state.loaded && v.children.length === 0) && (s.search_callback && s.search_callback.call(this, str, v) || !s.search_callback && f.search(v.text).isMatch)) {\n          r.push(i);\n          p = p.concat(v.parents);\n        }\n      });\n\n      if (r.length) {\n        p = $.vakata.array_unique(p);\n\n        for (i = 0, j = p.length; i < j; i++) {\n          if (p[i] !== $.jstree.root && m[p[i]] && this.open_node(p[i], null, 0) === true) {\n            this._data.search.opn.push(p[i]);\n          }\n        }\n\n        if (!append) {\n          this._data.search.dom = $(this.element[0].querySelectorAll('#' + $.map(r, function (v) {\n            return \"0123456789\".indexOf(v[0]) !== -1 ? '\\\\3' + v[0] + ' ' + v.substr(1).replace($.jstree.idregex, '\\\\$&') : v.replace($.jstree.idregex, '\\\\$&');\n          }).join(', #')));\n          this._data.search.res = r;\n        } else {\n          this._data.search.dom = this._data.search.dom.add($(this.element[0].querySelectorAll('#' + $.map(r, function (v) {\n            return \"0123456789\".indexOf(v[0]) !== -1 ? '\\\\3' + v[0] + ' ' + v.substr(1).replace($.jstree.idregex, '\\\\$&') : v.replace($.jstree.idregex, '\\\\$&');\n          }).join(', #'))));\n          this._data.search.res = $.vakata.array_unique(this._data.search.res.concat(r));\n        }\n\n        this._data.search.dom.children(\".jstree-anchor\").addClass('jstree-search');\n      }\n      /**\n       * triggered after search is complete\n       * @event\n       * @name search.jstree\n       * @param {jQuery} nodes a jQuery collection of matching nodes\n       * @param {String} str the search string\n       * @param {Array} res a collection of objects represeing the matching nodes\n       * @plugin search\n       */\n\n\n      this.trigger('search', {\n        nodes: this._data.search.dom,\n        str: str,\n        res: this._data.search.res,\n        show_only_matches: show_only_matches\n      });\n    };\n    /**\n     * used to clear the last search (removes classes and shows all nodes if filtering is on)\n     * @name clear_search()\n     * @plugin search\n     * @trigger clear_search.jstree\n     */\n\n\n    this.clear_search = function () {\n      if (this.settings.search.close_opened_onclear) {\n        this.close_node(this._data.search.opn, 0);\n      }\n      /**\n       * triggered after search is complete\n       * @event\n       * @name clear_search.jstree\n       * @param {jQuery} nodes a jQuery collection of matching nodes (the result from the last search)\n       * @param {String} str the search string (the last search string)\n       * @param {Array} res a collection of objects represeing the matching nodes (the result from the last search)\n       * @plugin search\n       */\n\n\n      this.trigger('clear_search', {\n        'nodes': this._data.search.dom,\n        str: this._data.search.str,\n        res: this._data.search.res\n      });\n\n      if (this._data.search.res.length) {\n        this._data.search.dom = $(this.element[0].querySelectorAll('#' + $.map(this._data.search.res, function (v) {\n          return \"0123456789\".indexOf(v[0]) !== -1 ? '\\\\3' + v[0] + ' ' + v.substr(1).replace($.jstree.idregex, '\\\\$&') : v.replace($.jstree.idregex, '\\\\$&');\n        }).join(', #')));\n\n        this._data.search.dom.children(\".jstree-anchor\").removeClass(\"jstree-search\");\n      }\n\n      this._data.search.str = \"\";\n      this._data.search.res = [];\n      this._data.search.opn = [];\n      this._data.search.dom = $();\n    };\n\n    this.redraw_node = function (obj, deep, callback, force_render) {\n      obj = parent.redraw_node.apply(this, arguments);\n\n      if (obj) {\n        if ($.inArray(obj.id, this._data.search.res) !== -1) {\n          var i,\n              j,\n              tmp = null;\n\n          for (i = 0, j = obj.childNodes.length; i < j; i++) {\n            if (obj.childNodes[i] && obj.childNodes[i].className && obj.childNodes[i].className.indexOf(\"jstree-anchor\") !== -1) {\n              tmp = obj.childNodes[i];\n              break;\n            }\n          }\n\n          if (tmp) {\n            tmp.className += ' jstree-search';\n          }\n        }\n      }\n\n      return obj;\n    };\n  }; // helpers\n\n\n  (function ($) {\n    // from http://kiro.me/projects/fuse.html\n    $.vakata.search = function (pattern, txt, options) {\n      options = options || {};\n      options = $.extend({}, $.vakata.search.defaults, options);\n\n      if (options.fuzzy !== false) {\n        options.fuzzy = true;\n      }\n\n      pattern = options.caseSensitive ? pattern : pattern.toLowerCase();\n      var MATCH_LOCATION = options.location,\n          MATCH_DISTANCE = options.distance,\n          MATCH_THRESHOLD = options.threshold,\n          patternLen = pattern.length,\n          matchmask,\n          pattern_alphabet,\n          match_bitapScore,\n          search;\n\n      if (patternLen > 32) {\n        options.fuzzy = false;\n      }\n\n      if (options.fuzzy) {\n        matchmask = 1 << patternLen - 1;\n\n        pattern_alphabet = function () {\n          var mask = {},\n              i = 0;\n\n          for (i = 0; i < patternLen; i++) {\n            mask[pattern.charAt(i)] = 0;\n          }\n\n          for (i = 0; i < patternLen; i++) {\n            mask[pattern.charAt(i)] |= 1 << patternLen - i - 1;\n          }\n\n          return mask;\n        }();\n\n        match_bitapScore = function match_bitapScore(e, x) {\n          var accuracy = e / patternLen,\n              proximity = Math.abs(MATCH_LOCATION - x);\n\n          if (!MATCH_DISTANCE) {\n            return proximity ? 1.0 : accuracy;\n          }\n\n          return accuracy + proximity / MATCH_DISTANCE;\n        };\n      }\n\n      search = function search(text) {\n        text = options.caseSensitive ? text : text.toLowerCase();\n\n        if (pattern === text || text.indexOf(pattern) !== -1) {\n          return {\n            isMatch: true,\n            score: 0\n          };\n        }\n\n        if (!options.fuzzy) {\n          return {\n            isMatch: false,\n            score: 1\n          };\n        }\n\n        var i,\n            j,\n            textLen = text.length,\n            scoreThreshold = MATCH_THRESHOLD,\n            bestLoc = text.indexOf(pattern, MATCH_LOCATION),\n            binMin,\n            binMid,\n            binMax = patternLen + textLen,\n            lastRd,\n            start,\n            finish,\n            rd,\n            charMatch,\n            score = 1,\n            locations = [];\n\n        if (bestLoc !== -1) {\n          scoreThreshold = Math.min(match_bitapScore(0, bestLoc), scoreThreshold);\n          bestLoc = text.lastIndexOf(pattern, MATCH_LOCATION + patternLen);\n\n          if (bestLoc !== -1) {\n            scoreThreshold = Math.min(match_bitapScore(0, bestLoc), scoreThreshold);\n          }\n        }\n\n        bestLoc = -1;\n\n        for (i = 0; i < patternLen; i++) {\n          binMin = 0;\n          binMid = binMax;\n\n          while (binMin < binMid) {\n            if (match_bitapScore(i, MATCH_LOCATION + binMid) <= scoreThreshold) {\n              binMin = binMid;\n            } else {\n              binMax = binMid;\n            }\n\n            binMid = Math.floor((binMax - binMin) / 2 + binMin);\n          }\n\n          binMax = binMid;\n          start = Math.max(1, MATCH_LOCATION - binMid + 1);\n          finish = Math.min(MATCH_LOCATION + binMid, textLen) + patternLen;\n          rd = new Array(finish + 2);\n          rd[finish + 1] = (1 << i) - 1;\n\n          for (j = finish; j >= start; j--) {\n            charMatch = pattern_alphabet[text.charAt(j - 1)];\n\n            if (i === 0) {\n              rd[j] = (rd[j + 1] << 1 | 1) & charMatch;\n            } else {\n              rd[j] = (rd[j + 1] << 1 | 1) & charMatch | ((lastRd[j + 1] | lastRd[j]) << 1 | 1) | lastRd[j + 1];\n            }\n\n            if (rd[j] & matchmask) {\n              score = match_bitapScore(i, j - 1);\n\n              if (score <= scoreThreshold) {\n                scoreThreshold = score;\n                bestLoc = j - 1;\n                locations.push(bestLoc);\n\n                if (bestLoc > MATCH_LOCATION) {\n                  start = Math.max(1, 2 * MATCH_LOCATION - bestLoc);\n                } else {\n                  break;\n                }\n              }\n            }\n          }\n\n          if (match_bitapScore(i + 1, MATCH_LOCATION) > scoreThreshold) {\n            break;\n          }\n\n          lastRd = rd;\n        }\n\n        return {\n          isMatch: bestLoc >= 0,\n          score: score\n        };\n      };\n\n      return txt === true ? {\n        'search': search\n      } : search(txt);\n    };\n\n    $.vakata.search.defaults = {\n      location: 0,\n      distance: 100,\n      threshold: 0.6,\n      fuzzy: false,\n      caseSensitive: false\n    };\n  })($); // include the search plugin by default\n  // $.jstree.defaults.plugins.push(\"search\");\n\n  /**\n   * ### Sort plugin\n   *\n   * Automatically sorts all siblings in the tree according to a sorting function.\n   */\n\n  /**\n   * the settings function used to sort the nodes.\n   * It is executed in the tree's context, accepts two nodes as arguments and should return `1` or `-1`.\n   * @name $.jstree.defaults.sort\n   * @plugin sort\n   */\n\n\n  $.jstree.defaults.sort = function (a, b) {\n    //return this.get_type(a) === this.get_type(b) ? (this.get_text(a) > this.get_text(b) ? 1 : -1) : this.get_type(a) >= this.get_type(b);\n    return this.get_text(a) > this.get_text(b) ? 1 : -1;\n  };\n\n  $.jstree.plugins.sort = function (options, parent) {\n    this.bind = function () {\n      parent.bind.call(this);\n      this.element.on(\"model.jstree\", $.proxy(function (e, data) {\n        this.sort(data.parent, true);\n      }, this)).on(\"rename_node.jstree create_node.jstree\", $.proxy(function (e, data) {\n        this.sort(data.parent || data.node.parent, false);\n        this.redraw_node(data.parent || data.node.parent, true);\n      }, this)).on(\"move_node.jstree copy_node.jstree\", $.proxy(function (e, data) {\n        this.sort(data.parent, false);\n        this.redraw_node(data.parent, true);\n      }, this));\n    };\n    /**\n     * used to sort a node's children\n     * @private\n     * @name sort(obj [, deep])\n     * @param  {mixed} obj the node\n     * @param {Boolean} deep if set to `true` nodes are sorted recursively.\n     * @plugin sort\n     * @trigger search.jstree\n     */\n\n\n    this.sort = function (obj, deep) {\n      var i, j;\n      obj = this.get_node(obj);\n\n      if (obj && obj.children && obj.children.length) {\n        obj.children.sort($.proxy(this.settings.sort, this));\n\n        if (deep) {\n          for (i = 0, j = obj.children_d.length; i < j; i++) {\n            this.sort(obj.children_d[i], false);\n          }\n        }\n      }\n    };\n  }; // include the sort plugin by default\n  // $.jstree.defaults.plugins.push(\"sort\");\n\n  /**\n   * ### State plugin\n   *\n   * Saves the state of the tree (selected nodes, opened nodes) on the user's computer using available options (localStorage, cookies, etc)\n   */\n\n\n  var to = false;\n  /**\n   * stores all defaults for the state plugin\n   * @name $.jstree.defaults.state\n   * @plugin state\n   */\n\n  $.jstree.defaults.state = {\n    /**\n     * A string for the key to use when saving the current tree (change if using multiple trees in your project). Defaults to `jstree`.\n     * @name $.jstree.defaults.state.key\n     * @plugin state\n     */\n    key: 'jstree',\n\n    /**\n     * A space separated list of events that trigger a state save. Defaults to `changed.jstree open_node.jstree close_node.jstree`.\n     * @name $.jstree.defaults.state.events\n     * @plugin state\n     */\n    events: 'changed.jstree open_node.jstree close_node.jstree check_node.jstree uncheck_node.jstree',\n\n    /**\n     * Time in milliseconds after which the state will expire. Defaults to 'false' meaning - no expire.\n     * @name $.jstree.defaults.state.ttl\n     * @plugin state\n     */\n    ttl: false,\n\n    /**\n     * A function that will be executed prior to restoring state with one argument - the state object. Can be used to clear unwanted parts of the state.\n     * @name $.jstree.defaults.state.filter\n     * @plugin state\n     */\n    filter: false\n  };\n\n  $.jstree.plugins.state = function (options, parent) {\n    this.bind = function () {\n      parent.bind.call(this);\n      var bind = $.proxy(function () {\n        this.element.on(this.settings.state.events, $.proxy(function () {\n          if (to) {\n            clearTimeout(to);\n          }\n\n          to = setTimeout($.proxy(function () {\n            this.save_state();\n          }, this), 100);\n        }, this));\n        /**\n         * triggered when the state plugin is finished restoring the state (and immediately after ready if there is no state to restore).\n         * @event\n         * @name state_ready.jstree\n         * @plugin state\n         */\n\n        this.trigger('state_ready');\n      }, this);\n      this.element.on(\"ready.jstree\", $.proxy(function (e, data) {\n        this.element.one(\"restore_state.jstree\", bind);\n\n        if (!this.restore_state()) {\n          bind();\n        }\n      }, this));\n    };\n    /**\n     * save the state\n     * @name save_state()\n     * @plugin state\n     */\n\n\n    this.save_state = function () {\n      var st = {\n        'state': this.get_state(),\n        'ttl': this.settings.state.ttl,\n        'sec': +new Date()\n      };\n      $.vakata.storage.set(this.settings.state.key, JSON.stringify(st));\n    };\n    /**\n     * restore the state from the user's computer\n     * @name restore_state()\n     * @plugin state\n     */\n\n\n    this.restore_state = function () {\n      var k = $.vakata.storage.get(this.settings.state.key);\n\n      if (!!k) {\n        try {\n          k = JSON.parse(k);\n        } catch (ex) {\n          return false;\n        }\n      }\n\n      if (!!k && k.ttl && k.sec && +new Date() - k.sec > k.ttl) {\n        return false;\n      }\n\n      if (!!k && k.state) {\n        k = k.state;\n      }\n\n      if (!!k && $.isFunction(this.settings.state.filter)) {\n        k = this.settings.state.filter.call(this, k);\n      }\n\n      if (!!k) {\n        this.element.one(\"set_state.jstree\", function (e, data) {\n          data.instance.trigger('restore_state', {\n            'state': $.extend(true, {}, k)\n          });\n        });\n        this.set_state(k);\n        return true;\n      }\n\n      return false;\n    };\n    /**\n     * clear the state on the user's computer\n     * @name clear_state()\n     * @plugin state\n     */\n\n\n    this.clear_state = function () {\n      return $.vakata.storage.del(this.settings.state.key);\n    };\n  };\n\n  (function ($, undefined) {\n    $.vakata.storage = {\n      // simply specifying the functions in FF throws an error\n      set: function set(key, val) {\n        return window.localStorage.setItem(key, val);\n      },\n      get: function get(key) {\n        return window.localStorage.getItem(key);\n      },\n      del: function del(key) {\n        return window.localStorage.removeItem(key);\n      }\n    };\n  })($); // include the state plugin by default\n  // $.jstree.defaults.plugins.push(\"state\");\n\n  /**\n   * ### Types plugin\n   *\n   * Makes it possible to add predefined types for groups of nodes, which make it possible to easily control nesting rules and icon for each group.\n   */\n\n  /**\n   * An object storing all types as key value pairs, where the key is the type name and the value is an object that could contain following keys (all optional).\n   *\n   * * `max_children` the maximum number of immediate children this node type can have. Do not specify or set to `-1` for unlimited.\n   * * `max_depth` the maximum number of nesting this node type can have. A value of `1` would mean that the node can have children, but no grandchildren. Do not specify or set to `-1` for unlimited.\n   * * `valid_children` an array of node type strings, that nodes of this type can have as children. Do not specify or set to `-1` for no limits.\n   * * `icon` a string - can be a path to an icon or a className, if using an image that is in the current directory use a `./` prefix, otherwise it will be detected as a class. Omit to use the default icon from your theme.\n   * * `li_attr` an object of values which will be used to add HTML attributes on the resulting LI DOM node (merged with the node's own data)\n   * * `a_attr` an object of values which will be used to add HTML attributes on the resulting A DOM node (merged with the node's own data)\n   *\n   * There are two predefined types:\n   *\n   * * `#` represents the root of the tree, for example `max_children` would control the maximum number of root nodes.\n   * * `default` represents the default node - any settings here will be applied to all nodes that do not have a type specified.\n   *\n   * @name $.jstree.defaults.types\n   * @plugin types\n   */\n\n\n  $.jstree.defaults.types = {\n    'default': {}\n  };\n  $.jstree.defaults.types[$.jstree.root] = {};\n\n  $.jstree.plugins.types = function (options, parent) {\n    this.init = function (el, options) {\n      var i, j;\n\n      if (options && options.types && options.types['default']) {\n        for (i in options.types) {\n          if (i !== \"default\" && i !== $.jstree.root && options.types.hasOwnProperty(i)) {\n            for (j in options.types['default']) {\n              if (options.types['default'].hasOwnProperty(j) && options.types[i][j] === undefined) {\n                options.types[i][j] = options.types['default'][j];\n              }\n            }\n          }\n        }\n      }\n\n      parent.init.call(this, el, options);\n      this._model.data[$.jstree.root].type = $.jstree.root;\n    };\n\n    this.refresh = function (skip_loading, forget_state) {\n      parent.refresh.call(this, skip_loading, forget_state);\n      this._model.data[$.jstree.root].type = $.jstree.root;\n    };\n\n    this.bind = function () {\n      this.element.on('model.jstree', $.proxy(function (e, data) {\n        var m = this._model.data,\n            dpc = data.nodes,\n            t = this.settings.types,\n            i,\n            j,\n            c = 'default',\n            k;\n\n        for (i = 0, j = dpc.length; i < j; i++) {\n          c = 'default';\n\n          if (m[dpc[i]].original && m[dpc[i]].original.type && t[m[dpc[i]].original.type]) {\n            c = m[dpc[i]].original.type;\n          }\n\n          if (m[dpc[i]].data && m[dpc[i]].data.jstree && m[dpc[i]].data.jstree.type && t[m[dpc[i]].data.jstree.type]) {\n            c = m[dpc[i]].data.jstree.type;\n          }\n\n          m[dpc[i]].type = c;\n\n          if (m[dpc[i]].icon === true && t[c].icon !== undefined) {\n            m[dpc[i]].icon = t[c].icon;\n          }\n\n          if (t[c].li_attr !== undefined && _typeof(t[c].li_attr) === 'object') {\n            for (k in t[c].li_attr) {\n              if (t[c].li_attr.hasOwnProperty(k)) {\n                if (k === 'id') {\n                  continue;\n                } else if (m[dpc[i]].li_attr[k] === undefined) {\n                  m[dpc[i]].li_attr[k] = t[c].li_attr[k];\n                } else if (k === 'class') {\n                  m[dpc[i]].li_attr['class'] = t[c].li_attr['class'] + ' ' + m[dpc[i]].li_attr['class'];\n                }\n              }\n            }\n          }\n\n          if (t[c].a_attr !== undefined && _typeof(t[c].a_attr) === 'object') {\n            for (k in t[c].a_attr) {\n              if (t[c].a_attr.hasOwnProperty(k)) {\n                if (k === 'id') {\n                  continue;\n                } else if (m[dpc[i]].a_attr[k] === undefined) {\n                  m[dpc[i]].a_attr[k] = t[c].a_attr[k];\n                } else if (k === 'href' && m[dpc[i]].a_attr[k] === '#') {\n                  m[dpc[i]].a_attr['href'] = t[c].a_attr['href'];\n                } else if (k === 'class') {\n                  m[dpc[i]].a_attr['class'] = t[c].a_attr['class'] + ' ' + m[dpc[i]].a_attr['class'];\n                }\n              }\n            }\n          }\n        }\n\n        m[$.jstree.root].type = $.jstree.root;\n      }, this));\n      parent.bind.call(this);\n    };\n\n    this.get_json = function (obj, options, flat) {\n      var i,\n          j,\n          m = this._model.data,\n          opt = options ? $.extend(true, {}, options, {\n        no_id: false\n      }) : {},\n          tmp = parent.get_json.call(this, obj, opt, flat);\n\n      if (tmp === false) {\n        return false;\n      }\n\n      if ($.isArray(tmp)) {\n        for (i = 0, j = tmp.length; i < j; i++) {\n          tmp[i].type = tmp[i].id && m[tmp[i].id] && m[tmp[i].id].type ? m[tmp[i].id].type : \"default\";\n\n          if (options && options.no_id) {\n            delete tmp[i].id;\n\n            if (tmp[i].li_attr && tmp[i].li_attr.id) {\n              delete tmp[i].li_attr.id;\n            }\n\n            if (tmp[i].a_attr && tmp[i].a_attr.id) {\n              delete tmp[i].a_attr.id;\n            }\n          }\n        }\n      } else {\n        tmp.type = tmp.id && m[tmp.id] && m[tmp.id].type ? m[tmp.id].type : \"default\";\n\n        if (options && options.no_id) {\n          tmp = this._delete_ids(tmp);\n        }\n      }\n\n      return tmp;\n    };\n\n    this._delete_ids = function (tmp) {\n      if ($.isArray(tmp)) {\n        for (var i = 0, j = tmp.length; i < j; i++) {\n          tmp[i] = this._delete_ids(tmp[i]);\n        }\n\n        return tmp;\n      }\n\n      delete tmp.id;\n\n      if (tmp.li_attr && tmp.li_attr.id) {\n        delete tmp.li_attr.id;\n      }\n\n      if (tmp.a_attr && tmp.a_attr.id) {\n        delete tmp.a_attr.id;\n      }\n\n      if (tmp.children && $.isArray(tmp.children)) {\n        tmp.children = this._delete_ids(tmp.children);\n      }\n\n      return tmp;\n    };\n\n    this.check = function (chk, obj, par, pos, more) {\n      if (parent.check.call(this, chk, obj, par, pos, more) === false) {\n        return false;\n      }\n\n      obj = obj && obj.id ? obj : this.get_node(obj);\n      par = par && par.id ? par : this.get_node(par);\n      var m = obj && obj.id ? more && more.origin ? more.origin : $.jstree.reference(obj.id) : null,\n          tmp,\n          d,\n          i,\n          j;\n      m = m && m._model && m._model.data ? m._model.data : null;\n\n      switch (chk) {\n        case \"create_node\":\n        case \"move_node\":\n        case \"copy_node\":\n          if (chk !== 'move_node' || $.inArray(obj.id, par.children) === -1) {\n            tmp = this.get_rules(par);\n\n            if (tmp.max_children !== undefined && tmp.max_children !== -1 && tmp.max_children === par.children.length) {\n              this._data.core.last_error = {\n                'error': 'check',\n                'plugin': 'types',\n                'id': 'types_01',\n                'reason': 'max_children prevents function: ' + chk,\n                'data': JSON.stringify({\n                  'chk': chk,\n                  'pos': pos,\n                  'obj': obj && obj.id ? obj.id : false,\n                  'par': par && par.id ? par.id : false\n                })\n              };\n              return false;\n            }\n\n            if (tmp.valid_children !== undefined && tmp.valid_children !== -1 && $.inArray(obj.type || 'default', tmp.valid_children) === -1) {\n              this._data.core.last_error = {\n                'error': 'check',\n                'plugin': 'types',\n                'id': 'types_02',\n                'reason': 'valid_children prevents function: ' + chk,\n                'data': JSON.stringify({\n                  'chk': chk,\n                  'pos': pos,\n                  'obj': obj && obj.id ? obj.id : false,\n                  'par': par && par.id ? par.id : false\n                })\n              };\n              return false;\n            }\n\n            if (m && obj.children_d && obj.parents) {\n              d = 0;\n\n              for (i = 0, j = obj.children_d.length; i < j; i++) {\n                d = Math.max(d, m[obj.children_d[i]].parents.length);\n              }\n\n              d = d - obj.parents.length + 1;\n            }\n\n            if (d <= 0 || d === undefined) {\n              d = 1;\n            }\n\n            do {\n              if (tmp.max_depth !== undefined && tmp.max_depth !== -1 && tmp.max_depth < d) {\n                this._data.core.last_error = {\n                  'error': 'check',\n                  'plugin': 'types',\n                  'id': 'types_03',\n                  'reason': 'max_depth prevents function: ' + chk,\n                  'data': JSON.stringify({\n                    'chk': chk,\n                    'pos': pos,\n                    'obj': obj && obj.id ? obj.id : false,\n                    'par': par && par.id ? par.id : false\n                  })\n                };\n                return false;\n              }\n\n              par = this.get_node(par.parent);\n              tmp = this.get_rules(par);\n              d++;\n            } while (par);\n          }\n\n          break;\n      }\n\n      return true;\n    };\n    /**\n     * used to retrieve the type settings object for a node\n     * @name get_rules(obj)\n     * @param {mixed} obj the node to find the rules for\n     * @return {Object}\n     * @plugin types\n     */\n\n\n    this.get_rules = function (obj) {\n      obj = this.get_node(obj);\n\n      if (!obj) {\n        return false;\n      }\n\n      var tmp = this.get_type(obj, true);\n\n      if (tmp.max_depth === undefined) {\n        tmp.max_depth = -1;\n      }\n\n      if (tmp.max_children === undefined) {\n        tmp.max_children = -1;\n      }\n\n      if (tmp.valid_children === undefined) {\n        tmp.valid_children = -1;\n      }\n\n      return tmp;\n    };\n    /**\n     * used to retrieve the type string or settings object for a node\n     * @name get_type(obj [, rules])\n     * @param {mixed} obj the node to find the rules for\n     * @param {Boolean} rules if set to `true` instead of a string the settings object will be returned\n     * @return {String|Object}\n     * @plugin types\n     */\n\n\n    this.get_type = function (obj, rules) {\n      obj = this.get_node(obj);\n      return !obj ? false : rules ? $.extend({\n        'type': obj.type\n      }, this.settings.types[obj.type]) : obj.type;\n    };\n    /**\n     * used to change a node's type\n     * @name set_type(obj, type)\n     * @param {mixed} obj the node to change\n     * @param {String} type the new type\n     * @plugin types\n     */\n\n\n    this.set_type = function (obj, type) {\n      var m = this._model.data,\n          t,\n          t1,\n          t2,\n          old_type,\n          old_icon,\n          k,\n          d,\n          a;\n\n      if ($.isArray(obj)) {\n        obj = obj.slice();\n\n        for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {\n          this.set_type(obj[t1], type);\n        }\n\n        return true;\n      }\n\n      t = this.settings.types;\n      obj = this.get_node(obj);\n\n      if (!t[type] || !obj) {\n        return false;\n      }\n\n      d = this.get_node(obj, true);\n\n      if (d && d.length) {\n        a = d.children('.jstree-anchor');\n      }\n\n      old_type = obj.type;\n      old_icon = this.get_icon(obj);\n      obj.type = type;\n\n      if (old_icon === true || !t[old_type] || t[old_type].icon !== undefined && old_icon === t[old_type].icon) {\n        this.set_icon(obj, t[type].icon !== undefined ? t[type].icon : true);\n      } // remove old type props\n\n\n      if (t[old_type] && t[old_type].li_attr !== undefined && _typeof(t[old_type].li_attr) === 'object') {\n        for (k in t[old_type].li_attr) {\n          if (t[old_type].li_attr.hasOwnProperty(k)) {\n            if (k === 'id') {\n              continue;\n            } else if (k === 'class') {\n              m[obj.id].li_attr['class'] = (m[obj.id].li_attr['class'] || '').replace(t[old_type].li_attr[k], '');\n\n              if (d) {\n                d.removeClass(t[old_type].li_attr[k]);\n              }\n            } else if (m[obj.id].li_attr[k] === t[old_type].li_attr[k]) {\n              m[obj.id].li_attr[k] = null;\n\n              if (d) {\n                d.removeAttr(k);\n              }\n            }\n          }\n        }\n      }\n\n      if (t[old_type] && t[old_type].a_attr !== undefined && _typeof(t[old_type].a_attr) === 'object') {\n        for (k in t[old_type].a_attr) {\n          if (t[old_type].a_attr.hasOwnProperty(k)) {\n            if (k === 'id') {\n              continue;\n            } else if (k === 'class') {\n              m[obj.id].a_attr['class'] = (m[obj.id].a_attr['class'] || '').replace(t[old_type].a_attr[k], '');\n\n              if (a) {\n                a.removeClass(t[old_type].a_attr[k]);\n              }\n            } else if (m[obj.id].a_attr[k] === t[old_type].a_attr[k]) {\n              if (k === 'href') {\n                m[obj.id].a_attr[k] = '#';\n\n                if (a) {\n                  a.attr('href', '#');\n                }\n              } else {\n                delete m[obj.id].a_attr[k];\n\n                if (a) {\n                  a.removeAttr(k);\n                }\n              }\n            }\n          }\n        }\n      } // add new props\n\n\n      if (t[type].li_attr !== undefined && _typeof(t[type].li_attr) === 'object') {\n        for (k in t[type].li_attr) {\n          if (t[type].li_attr.hasOwnProperty(k)) {\n            if (k === 'id') {\n              continue;\n            } else if (m[obj.id].li_attr[k] === undefined) {\n              m[obj.id].li_attr[k] = t[type].li_attr[k];\n\n              if (d) {\n                if (k === 'class') {\n                  d.addClass(t[type].li_attr[k]);\n                } else {\n                  d.attr(k, t[type].li_attr[k]);\n                }\n              }\n            } else if (k === 'class') {\n              m[obj.id].li_attr['class'] = t[type].li_attr[k] + ' ' + m[obj.id].li_attr['class'];\n\n              if (d) {\n                d.addClass(t[type].li_attr[k]);\n              }\n            }\n          }\n        }\n      }\n\n      if (t[type].a_attr !== undefined && _typeof(t[type].a_attr) === 'object') {\n        for (k in t[type].a_attr) {\n          if (t[type].a_attr.hasOwnProperty(k)) {\n            if (k === 'id') {\n              continue;\n            } else if (m[obj.id].a_attr[k] === undefined) {\n              m[obj.id].a_attr[k] = t[type].a_attr[k];\n\n              if (a) {\n                if (k === 'class') {\n                  a.addClass(t[type].a_attr[k]);\n                } else {\n                  a.attr(k, t[type].a_attr[k]);\n                }\n              }\n            } else if (k === 'href' && m[obj.id].a_attr[k] === '#') {\n              m[obj.id].a_attr['href'] = t[type].a_attr['href'];\n\n              if (a) {\n                a.attr('href', t[type].a_attr['href']);\n              }\n            } else if (k === 'class') {\n              m[obj.id].a_attr['class'] = t[type].a_attr['class'] + ' ' + m[obj.id].a_attr['class'];\n\n              if (a) {\n                a.addClass(t[type].a_attr[k]);\n              }\n            }\n          }\n        }\n      }\n\n      return true;\n    };\n  }; // include the types plugin by default\n  // $.jstree.defaults.plugins.push(\"types\");\n\n  /**\n   * ### Unique plugin\n   *\n   * Enforces that no nodes with the same name can coexist as siblings.\n   */\n\n  /**\n   * stores all defaults for the unique plugin\n   * @name $.jstree.defaults.unique\n   * @plugin unique\n   */\n\n\n  $.jstree.defaults.unique = {\n    /**\n     * Indicates if the comparison should be case sensitive. Default is `false`.\n     * @name $.jstree.defaults.unique.case_sensitive\n     * @plugin unique\n     */\n    case_sensitive: false,\n\n    /**\n     * A callback executed in the instance's scope when a new node is created and the name is already taken, the two arguments are the conflicting name and the counter. The default will produce results like `New node (2)`.\n     * @name $.jstree.defaults.unique.duplicate\n     * @plugin unique\n     */\n    duplicate: function duplicate(name, counter) {\n      return name + ' (' + counter + ')';\n    }\n  };\n\n  $.jstree.plugins.unique = function (options, parent) {\n    this.check = function (chk, obj, par, pos, more) {\n      if (parent.check.call(this, chk, obj, par, pos, more) === false) {\n        return false;\n      }\n\n      obj = obj && obj.id ? obj : this.get_node(obj);\n      par = par && par.id ? par : this.get_node(par);\n\n      if (!par || !par.children) {\n        return true;\n      }\n\n      var n = chk === \"rename_node\" ? pos : obj.text,\n          c = [],\n          s = this.settings.unique.case_sensitive,\n          m = this._model.data,\n          i,\n          j;\n\n      for (i = 0, j = par.children.length; i < j; i++) {\n        c.push(s ? m[par.children[i]].text : m[par.children[i]].text.toLowerCase());\n      }\n\n      if (!s) {\n        n = n.toLowerCase();\n      }\n\n      switch (chk) {\n        case \"delete_node\":\n          return true;\n\n        case \"rename_node\":\n          i = $.inArray(n, c) === -1 || obj.text && obj.text[s ? 'toString' : 'toLowerCase']() === n;\n\n          if (!i) {\n            this._data.core.last_error = {\n              'error': 'check',\n              'plugin': 'unique',\n              'id': 'unique_01',\n              'reason': 'Child with name ' + n + ' already exists. Preventing: ' + chk,\n              'data': JSON.stringify({\n                'chk': chk,\n                'pos': pos,\n                'obj': obj && obj.id ? obj.id : false,\n                'par': par && par.id ? par.id : false\n              })\n            };\n          }\n\n          return i;\n\n        case \"create_node\":\n          i = $.inArray(n, c) === -1;\n\n          if (!i) {\n            this._data.core.last_error = {\n              'error': 'check',\n              'plugin': 'unique',\n              'id': 'unique_04',\n              'reason': 'Child with name ' + n + ' already exists. Preventing: ' + chk,\n              'data': JSON.stringify({\n                'chk': chk,\n                'pos': pos,\n                'obj': obj && obj.id ? obj.id : false,\n                'par': par && par.id ? par.id : false\n              })\n            };\n          }\n\n          return i;\n\n        case \"copy_node\":\n          i = $.inArray(n, c) === -1;\n\n          if (!i) {\n            this._data.core.last_error = {\n              'error': 'check',\n              'plugin': 'unique',\n              'id': 'unique_02',\n              'reason': 'Child with name ' + n + ' already exists. Preventing: ' + chk,\n              'data': JSON.stringify({\n                'chk': chk,\n                'pos': pos,\n                'obj': obj && obj.id ? obj.id : false,\n                'par': par && par.id ? par.id : false\n              })\n            };\n          }\n\n          return i;\n\n        case \"move_node\":\n          i = obj.parent === par.id && (!more || !more.is_multi) || $.inArray(n, c) === -1;\n\n          if (!i) {\n            this._data.core.last_error = {\n              'error': 'check',\n              'plugin': 'unique',\n              'id': 'unique_03',\n              'reason': 'Child with name ' + n + ' already exists. Preventing: ' + chk,\n              'data': JSON.stringify({\n                'chk': chk,\n                'pos': pos,\n                'obj': obj && obj.id ? obj.id : false,\n                'par': par && par.id ? par.id : false\n              })\n            };\n          }\n\n          return i;\n      }\n\n      return true;\n    };\n\n    this.create_node = function (par, node, pos, callback, is_loaded) {\n      if (!node || node.text === undefined) {\n        if (par === null) {\n          par = $.jstree.root;\n        }\n\n        par = this.get_node(par);\n\n        if (!par) {\n          return parent.create_node.call(this, par, node, pos, callback, is_loaded);\n        }\n\n        pos = pos === undefined ? \"last\" : pos;\n\n        if (!pos.toString().match(/^(before|after)$/) && !is_loaded && !this.is_loaded(par)) {\n          return parent.create_node.call(this, par, node, pos, callback, is_loaded);\n        }\n\n        if (!node) {\n          node = {};\n        }\n\n        var tmp,\n            n,\n            dpc,\n            i,\n            j,\n            m = this._model.data,\n            s = this.settings.unique.case_sensitive,\n            cb = this.settings.unique.duplicate;\n        n = tmp = this.get_string('New node');\n        dpc = [];\n\n        for (i = 0, j = par.children.length; i < j; i++) {\n          dpc.push(s ? m[par.children[i]].text : m[par.children[i]].text.toLowerCase());\n        }\n\n        i = 1;\n\n        while ($.inArray(s ? n : n.toLowerCase(), dpc) !== -1) {\n          n = cb.call(this, tmp, ++i).toString();\n        }\n\n        node.text = n;\n      }\n\n      return parent.create_node.call(this, par, node, pos, callback, is_loaded);\n    };\n  }; // include the unique plugin by default\n  // $.jstree.defaults.plugins.push(\"unique\");\n\n  /**\n   * ### Wholerow plugin\n   *\n   * Makes each node appear block level. Making selection easier. May cause slow down for large trees in old browsers.\n   */\n\n\n  var div = document.createElement('DIV');\n  div.setAttribute('unselectable', 'on');\n  div.setAttribute('role', 'presentation');\n  div.className = 'jstree-wholerow';\n  div.innerHTML = '&#160;';\n\n  $.jstree.plugins.wholerow = function (options, parent) {\n    this.bind = function () {\n      parent.bind.call(this);\n      this.element.on('ready.jstree set_state.jstree', $.proxy(function () {\n        this.hide_dots();\n      }, this)).on(\"init.jstree loading.jstree ready.jstree\", $.proxy(function () {\n        //div.style.height = this._data.core.li_height + 'px';\n        this.get_container_ul().addClass('jstree-wholerow-ul');\n      }, this)).on(\"deselect_all.jstree\", $.proxy(function (e, data) {\n        this.element.find('.jstree-wholerow-clicked').removeClass('jstree-wholerow-clicked');\n      }, this)).on(\"changed.jstree\", $.proxy(function (e, data) {\n        this.element.find('.jstree-wholerow-clicked').removeClass('jstree-wholerow-clicked');\n        var tmp = false,\n            i,\n            j;\n\n        for (i = 0, j = data.selected.length; i < j; i++) {\n          tmp = this.get_node(data.selected[i], true);\n\n          if (tmp && tmp.length) {\n            tmp.children('.jstree-wholerow').addClass('jstree-wholerow-clicked');\n          }\n        }\n      }, this)).on(\"open_node.jstree\", $.proxy(function (e, data) {\n        this.get_node(data.node, true).find('.jstree-clicked').parent().children('.jstree-wholerow').addClass('jstree-wholerow-clicked');\n      }, this)).on(\"hover_node.jstree dehover_node.jstree\", $.proxy(function (e, data) {\n        if (e.type === \"hover_node\" && this.is_disabled(data.node)) {\n          return;\n        }\n\n        this.get_node(data.node, true).children('.jstree-wholerow')[e.type === \"hover_node\" ? \"addClass\" : \"removeClass\"]('jstree-wholerow-hovered');\n      }, this)).on(\"contextmenu.jstree\", \".jstree-wholerow\", $.proxy(function (e) {\n        if (this._data.contextmenu) {\n          e.preventDefault();\n          var tmp = $.Event('contextmenu', {\n            metaKey: e.metaKey,\n            ctrlKey: e.ctrlKey,\n            altKey: e.altKey,\n            shiftKey: e.shiftKey,\n            pageX: e.pageX,\n            pageY: e.pageY\n          });\n          $(e.currentTarget).closest(\".jstree-node\").children(\".jstree-anchor\").first().trigger(tmp);\n        }\n      }, this))\n      /*!\n      .on(\"mousedown.jstree touchstart.jstree\", \".jstree-wholerow\", function (e) {\n      \t\tif(e.target === e.currentTarget) {\n      \t\t\tvar a = $(e.currentTarget).closest(\".jstree-node\").children(\".jstree-anchor\");\n      \t\t\te.target = a[0];\n      \t\t\ta.trigger(e);\n      \t\t}\n      \t})\n      */\n      .on(\"click.jstree\", \".jstree-wholerow\", function (e) {\n        e.stopImmediatePropagation();\n        var tmp = $.Event('click', {\n          metaKey: e.metaKey,\n          ctrlKey: e.ctrlKey,\n          altKey: e.altKey,\n          shiftKey: e.shiftKey\n        });\n        $(e.currentTarget).closest(\".jstree-node\").children(\".jstree-anchor\").first().trigger(tmp).focus();\n      }).on(\"dblclick.jstree\", \".jstree-wholerow\", function (e) {\n        e.stopImmediatePropagation();\n        var tmp = $.Event('dblclick', {\n          metaKey: e.metaKey,\n          ctrlKey: e.ctrlKey,\n          altKey: e.altKey,\n          shiftKey: e.shiftKey\n        });\n        $(e.currentTarget).closest(\".jstree-node\").children(\".jstree-anchor\").first().trigger(tmp).focus();\n      }).on(\"click.jstree\", \".jstree-leaf > .jstree-ocl\", $.proxy(function (e) {\n        e.stopImmediatePropagation();\n        var tmp = $.Event('click', {\n          metaKey: e.metaKey,\n          ctrlKey: e.ctrlKey,\n          altKey: e.altKey,\n          shiftKey: e.shiftKey\n        });\n        $(e.currentTarget).closest(\".jstree-node\").children(\".jstree-anchor\").first().trigger(tmp).focus();\n      }, this)).on(\"mouseover.jstree\", \".jstree-wholerow, .jstree-icon\", $.proxy(function (e) {\n        e.stopImmediatePropagation();\n\n        if (!this.is_disabled(e.currentTarget)) {\n          this.hover_node(e.currentTarget);\n        }\n\n        return false;\n      }, this)).on(\"mouseleave.jstree\", \".jstree-node\", $.proxy(function (e) {\n        this.dehover_node(e.currentTarget);\n      }, this));\n    };\n\n    this.teardown = function () {\n      if (this.settings.wholerow) {\n        this.element.find(\".jstree-wholerow\").remove();\n      }\n\n      parent.teardown.call(this);\n    };\n\n    this.redraw_node = function (obj, deep, callback, force_render) {\n      obj = parent.redraw_node.apply(this, arguments);\n\n      if (obj) {\n        var tmp = div.cloneNode(true); //tmp.style.height = this._data.core.li_height + 'px';\n\n        if ($.inArray(obj.id, this._data.core.selected) !== -1) {\n          tmp.className += ' jstree-wholerow-clicked';\n        }\n\n        if (this._data.core.focused && this._data.core.focused === obj.id) {\n          tmp.className += ' jstree-wholerow-hovered';\n        }\n\n        obj.insertBefore(tmp, obj.childNodes[0]);\n      }\n\n      return obj;\n    };\n  }; // include the wholerow plugin by default\n  // $.jstree.defaults.plugins.push(\"wholerow\");\n\n\n  if (document.registerElement && Object && Object.create) {\n    var proto = Object.create(HTMLElement.prototype);\n\n    proto.createdCallback = function () {\n      var c = {\n        core: {},\n        plugins: []\n      },\n          i;\n\n      for (i in $.jstree.plugins) {\n        if ($.jstree.plugins.hasOwnProperty(i) && this.attributes[i]) {\n          c.plugins.push(i);\n\n          if (this.getAttribute(i) && JSON.parse(this.getAttribute(i))) {\n            c[i] = JSON.parse(this.getAttribute(i));\n          }\n        }\n      }\n\n      for (i in $.jstree.defaults.core) {\n        if ($.jstree.defaults.core.hasOwnProperty(i) && this.attributes[i]) {\n          c.core[i] = JSON.parse(this.getAttribute(i)) || this.getAttribute(i);\n        }\n      }\n\n      $(this).jstree(c);\n    }; // proto.attributeChangedCallback = function (name, previous, value) { };\n\n\n    try {\n      document.registerElement(\"vakata-jstree\", {\n        prototype: proto\n      });\n    } catch (ignore) {}\n  }\n});"

/***/ }),

/***/ "./node_modules/script-loader/addScript.js":
/*!*************************************************!*\
  !*** ./node_modules/script-loader/addScript.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
module.exports = function(src) {
	function log(error) {
		(typeof console !== "undefined")
		&& (console.error || console.log)("[Script Loader]", error);
	}

	// Check for IE =< 8
	function isIE() {
		return typeof attachEvent !== "undefined" && typeof addEventListener === "undefined";
	}

	try {
		if (typeof execScript !== "undefined" && isIE()) {
			execScript(src);
		} else if (typeof eval !== "undefined") {
			eval.call(null, src);
		} else {
			log("EvalError: No eval function available");
		}
	} catch (error) {
		log(error);
	}
}


/***/ }),

/***/ "./node_modules/script-loader/index.js!./assets/js/jstree-3.3.3.js":
/*!****************************************************************!*\
  !*** ./node_modules/script-loader!./assets/js/jstree-3.3.3.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

<<<<<<< HEAD
__webpack_require__(/*! !./node_modules/script-loader/addScript.js */ "./node_modules/script-loader/addScript.js")(__webpack_require__(/*! !./node_modules/raw-loader!./node_modules/babel-loader/lib??ref--0-0!./assets/js/jstree-3.3.3.js */ "./node_modules/raw-loader/index.js!./node_modules/babel-loader/lib/index.js??ref--0-0!./assets/js/jstree-3.3.3.js")+"\n\n// SCRIPT-LOADER FOOTER\n//# sourceURL=script:///home/osboxes/workspace/mlab.local.test/node_modules/babel-loader/lib/index.js%3F?ref--0-0!/home/osboxes/workspace/mlab.local.test/assets/js/jstree-3.3.3.js")
=======
__webpack_require__(/*! !./node_modules/script-loader/addScript.js */ "./node_modules/script-loader/addScript.js")(__webpack_require__(/*! !./node_modules/raw-loader!./node_modules/babel-loader/lib??ref--4-0!./assets/js/jstree-3.3.3.js */ "./node_modules/raw-loader/index.js!./node_modules/babel-loader/lib/index.js?!./assets/js/jstree-3.3.3.js")+"\n\n// SCRIPT-LOADER FOOTER\n//# sourceURL=script:///home/osboxes/workspace/mlab.local.test/node_modules/babel-loader/lib/index.js%3F?ref--4-0!/home/osboxes/workspace/mlab.local.test/assets/js/jstree-3.3.3.js")
>>>>>>> develop

/***/ })

/******/ });
<<<<<<< HEAD
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgN2I4NGY0ODAzMmVkZTNmMDcwOWMiLCJ3ZWJwYWNrOi8vLy4vYXNzZXRzL2pzL2FkbWluLmpzIiwid2VicGFjazovLy8uL2Fzc2V0cy9qcy9qc3RyZWUtMy4zLjMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzIiwid2VicGFjazovLy8uL2Fzc2V0cy9qcy9qc3RyZWUtMy4zLjMuanM/NDc1OCJdLCJuYW1lcyI6WyJyZXF1aXJlIl0sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUEyQiwwQkFBMEIsRUFBRTtBQUN2RCx5Q0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBc0QsK0RBQStEOztBQUVySDtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM3REE7Ozs7O0FBS0FBLG1CQUFPQSxDQUFDLDBHQUFSLEU7Ozs7Ozs7Ozs7OztBQ0xBLDBIQUEwSCxtQkFBbUIsRUFBRSxtQkFBbUIsa0lBQWtJLEdBQUcsK0dBQStHLG1CQUFtQix1REFBdUQsa0NBQWtDLEtBQUssNERBQTRELGtEQUFrRCxLQUFLLE9BQU8sc0JBQXNCLEtBQUssR0FBRywyQkFBMkIsbUJBQW1CLG9tQkFBb21CLGFBQWEsS0FBSyw4UkFBOFIsd1BBQXdQLGtQQUFrUCwwT0FBME8sd0hBQXdILCtIQUErSCxhQUFhLDRCQUE0QixpR0FBaUcseUJBQXlCLDZGQUE2RixPQUFPLCtFQUErRSxPQUFPLHFF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QUF1RCwyQ0FBMkMsaUJBQWlCLFNBQVMsZUFBZSxlQUFlLHFDQUFxQyx5RUFBeUUsOEJBQThCLDJFQUEyRSxzREFBc0QsYUFBYSxXQUFXLFNBQVMsMkNBQTJDLCtFQUErRSxpRkFBaUYsV0FBVyxTQUFTLDBCQUEwQixRQUFRLDRFQUE0RSxHQUFHLFdBQVcscURBQXFELG1CQUFtQixFQUFFLE9BQU8sa0JBQWtCLEtBQUssR0FBRyxFQUFFLEM7Ozs7Ozs7Ozs7OztBQ0FqdnhVO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMxQkEsbUJBQU8sQ0FBQyw2RkFBbUYsRUFBRSxtQkFBTyxDQUFDLDJOQUF1TyxxTiIsImZpbGUiOiJhZG1pbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIi9idWlsZC9cIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vYXNzZXRzL2pzL2FkbWluLmpzXCIpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIDdiODRmNDgwMzJlZGUzZjA3MDljIiwiLyogXG4gKiBUbyBjaGFuZ2UgdGhpcyBsaWNlbnNlIGhlYWRlciwgY2hvb3NlIExpY2Vuc2UgSGVhZGVycyBpbiBQcm9qZWN0IFByb3BlcnRpZXMuXG4gKiBUbyBjaGFuZ2UgdGhpcyB0ZW1wbGF0ZSBmaWxlLCBjaG9vc2UgVG9vbHMgfCBUZW1wbGF0ZXNcbiAqIGFuZCBvcGVuIHRoZSB0ZW1wbGF0ZSBpbiB0aGUgZWRpdG9yLlxuICovXG5yZXF1aXJlKCdzY3JpcHQtbG9hZGVyIS4vanN0cmVlLTMuMy4zLmpzJyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9hc3NldHMvanMvYWRtaW4uanMiLCJtb2R1bGUuZXhwb3J0cyA9IFwidmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFxcXCJzeW1ib2xcXFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFxcXCJzeW1ib2xcXFwiIDogdHlwZW9mIG9iajsgfTtcXG5cXG4vKmdsb2JhbHMgalF1ZXJ5LCBkZWZpbmUsIG1vZHVsZSwgZXhwb3J0cywgcmVxdWlyZSwgd2luZG93LCBkb2N1bWVudCwgcG9zdE1lc3NhZ2UgKi9cXG4oZnVuY3Rpb24gKGZhY3RvcnkpIHtcXG5cXHRcXFwidXNlIHN0cmljdFxcXCI7XFxuXFxuXFx0aWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xcblxcdFxcdGRlZmluZShbJ2pxdWVyeSddLCBmYWN0b3J5KTtcXG5cXHR9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XFxuXFx0XFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoJ2pxdWVyeScpKTtcXG5cXHR9IGVsc2Uge1xcblxcdFxcdGZhY3RvcnkoalF1ZXJ5KTtcXG5cXHR9XFxufSkoZnVuY3Rpb24gKCQsIHVuZGVmaW5lZCkge1xcblxcdFxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXHQvKiFcXG4gICoganNUcmVlIDMuMy4zXFxuICAqIGh0dHA6Ly9qc3RyZWUuY29tL1xcbiAgKlxcbiAgKiBDb3B5cmlnaHQgKGMpIDIwMTQgSXZhbiBCb3poYW5vdiAoaHR0cDovL3Zha2F0YS5jb20pXFxuICAqXFxuICAqIExpY2Vuc2VkIHNhbWUgYXMganF1ZXJ5IC0gdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNSVQgTGljZW5zZVxcbiAgKiAgIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXFxuICAqL1xcblxcdC8qIVxcbiAgKiBpZiB1c2luZyBqc2xpbnQgcGxlYXNlIGFsbG93IGZvciB0aGUgalF1ZXJ5IGdsb2JhbCBhbmQgdXNlIGZvbGxvd2luZyBvcHRpb25zOlxcbiAgKiBqc2xpbnQ6IGxvb3BmdW5jOiB0cnVlLCBicm93c2VyOiB0cnVlLCBhc3M6IHRydWUsIGJpdHdpc2U6IHRydWUsIGNvbnRpbnVlOiB0cnVlLCBub21lbjogdHJ1ZSwgcGx1c3BsdXM6IHRydWUsIHJlZ2V4cDogdHJ1ZSwgdW5wYXJhbTogdHJ1ZSwgdG9kbzogdHJ1ZSwgd2hpdGU6IHRydWVcXG4gICovXFxuXFx0Lypqc2hpbnQgLVcwODMgKi9cXG5cXG5cXHQvLyBwcmV2ZW50IGFub3RoZXIgbG9hZD8gbWF5YmUgdGhlcmUgaXMgYSBiZXR0ZXIgd2F5P1xcblxcblxcdGlmICgkLmpzdHJlZSkge1xcblxcdFxcdHJldHVybjtcXG5cXHR9XFxuXFxuXFx0LyoqXFxuICAqICMjIyBqc1RyZWUgY29yZSBmdW5jdGlvbmFsaXR5XFxuICAqL1xcblxcblxcdC8vIGludGVybmFsIHZhcmlhYmxlc1xcblxcdHZhciBpbnN0YW5jZV9jb3VudGVyID0gMCxcXG5cXHQgICAgY2NwX25vZGUgPSBmYWxzZSxcXG5cXHQgICAgY2NwX21vZGUgPSBmYWxzZSxcXG5cXHQgICAgY2NwX2luc3QgPSBmYWxzZSxcXG5cXHQgICAgdGhlbWVzX2xvYWRlZCA9IFtdLFxcblxcdCAgICBzcmMgPSAkKCdzY3JpcHQ6bGFzdCcpLmF0dHIoJ3NyYycpLFxcblxcdCAgICBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDsgLy8gbG9jYWwgdmFyaWFibGUgaXMgYWx3YXlzIGZhc3RlciB0byBhY2Nlc3MgdGhlbiBhIGdsb2JhbFxcblxcblxcdC8qKlxcbiAgKiBob2xkcyBhbGwganN0cmVlIHJlbGF0ZWQgZnVuY3Rpb25zIGFuZCB2YXJpYWJsZXMsIGluY2x1ZGluZyB0aGUgYWN0dWFsIGNsYXNzIGFuZCBtZXRob2RzIHRvIGNyZWF0ZSwgYWNjZXNzIGFuZCBtYW5pcHVsYXRlIGluc3RhbmNlcy5cXG4gICogQG5hbWUgJC5qc3RyZWVcXG4gICovXFxuXFx0JC5qc3RyZWUgPSB7XFxuXFx0XFx0LyoqXFxuICAgKiBzcGVjaWZpZXMgdGhlIGpzdHJlZSB2ZXJzaW9uIGluIHVzZVxcbiAgICogQG5hbWUgJC5qc3RyZWUudmVyc2lvblxcbiAgICovXFxuXFx0XFx0dmVyc2lvbjogJzMuMy4zJyxcXG5cXHRcXHQvKipcXG4gICAqIGhvbGRzIGFsbCB0aGUgZGVmYXVsdCBvcHRpb25zIHVzZWQgd2hlbiBjcmVhdGluZyBuZXcgaW5zdGFuY2VzXFxuICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0c1xcbiAgICovXFxuXFx0XFx0ZGVmYXVsdHM6IHtcXG5cXHRcXHRcXHQvKipcXG4gICAgKiBjb25maWd1cmUgd2hpY2ggcGx1Z2lucyB3aWxsIGJlIGFjdGl2ZSBvbiBhbiBpbnN0YW5jZS4gU2hvdWxkIGJlIGFuIGFycmF5IG9mIHN0cmluZ3MsIHdoZXJlIGVhY2ggZWxlbWVudCBpcyBhIHBsdWdpbiBuYW1lLiBUaGUgZGVmYXVsdCBpcyBgW11gXFxuICAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMucGx1Z2luc1xcbiAgICAqL1xcblxcdFxcdFxcdHBsdWdpbnM6IFtdXFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIHN0b3JlcyBhbGwgbG9hZGVkIGpzdHJlZSBwbHVnaW5zICh1c2VkIGludGVybmFsbHkpXFxuICAgKiBAbmFtZSAkLmpzdHJlZS5wbHVnaW5zXFxuICAgKi9cXG5cXHRcXHRwbHVnaW5zOiB7fSxcXG5cXHRcXHRwYXRoOiBzcmMgJiYgc3JjLmluZGV4T2YoJy8nKSAhPT0gLTEgPyBzcmMucmVwbGFjZSgvXFxcXC9bXlxcXFwvXSskLywgJycpIDogJycsXFxuXFx0XFx0aWRyZWdleDogL1tcXFxcXFxcXDomIV58KClcXFxcW1xcXFxdPD5AKicrfiNcXFwiOy4sPVxcXFwtIFxcXFwvJHt9JT9gXS9nLFxcblxcdFxcdHJvb3Q6ICcjJ1xcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqIGNyZWF0ZXMgYSBqc3RyZWUgaW5zdGFuY2VcXG4gICogQG5hbWUgJC5qc3RyZWUuY3JlYXRlKGVsIFssIG9wdGlvbnNdKVxcbiAgKiBAcGFyYW0ge0RPTUVsZW1lbnR8alF1ZXJ5fFN0cmluZ30gZWwgdGhlIGVsZW1lbnQgdG8gY3JlYXRlIHRoZSBpbnN0YW5jZSBvbiwgY2FuIGJlIGpRdWVyeSBleHRlbmRlZCBvciBhIHNlbGVjdG9yXFxuICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIG9wdGlvbnMgZm9yIHRoaXMgaW5zdGFuY2UgKGV4dGVuZHMgYCQuanN0cmVlLmRlZmF1bHRzYClcXG4gICogQHJldHVybiB7anNUcmVlfSB0aGUgbmV3IGluc3RhbmNlXFxuICAqL1xcblxcdCQuanN0cmVlLmNyZWF0ZSA9IGZ1bmN0aW9uIChlbCwgb3B0aW9ucykge1xcblxcdFxcdHZhciB0bXAgPSBuZXcgJC5qc3RyZWUuY29yZSgrK2luc3RhbmNlX2NvdW50ZXIpLFxcblxcdFxcdCAgICBvcHQgPSBvcHRpb25zO1xcblxcdFxcdG9wdGlvbnMgPSAkLmV4dGVuZCh0cnVlLCB7fSwgJC5qc3RyZWUuZGVmYXVsdHMsIG9wdGlvbnMpO1xcblxcdFxcdGlmIChvcHQgJiYgb3B0LnBsdWdpbnMpIHtcXG5cXHRcXHRcXHRvcHRpb25zLnBsdWdpbnMgPSBvcHQucGx1Z2lucztcXG5cXHRcXHR9XFxuXFx0XFx0JC5lYWNoKG9wdGlvbnMucGx1Z2lucywgZnVuY3Rpb24gKGksIGspIHtcXG5cXHRcXHRcXHRpZiAoaSAhPT0gJ2NvcmUnKSB7XFxuXFx0XFx0XFx0XFx0dG1wID0gdG1wLnBsdWdpbihrLCBvcHRpb25zW2tdKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSk7XFxuXFx0XFx0JChlbCkuZGF0YSgnanN0cmVlJywgdG1wKTtcXG5cXHRcXHR0bXAuaW5pdChlbCwgb3B0aW9ucyk7XFxuXFx0XFx0cmV0dXJuIHRtcDtcXG5cXHR9O1xcblxcdC8qKlxcbiAgKiByZW1vdmUgYWxsIHRyYWNlcyBvZiBqc3RyZWUgZnJvbSB0aGUgRE9NIGFuZCBkZXN0cm95IGFsbCBpbnN0YW5jZXNcXG4gICogQG5hbWUgJC5qc3RyZWUuZGVzdHJveSgpXFxuICAqL1xcblxcdCQuanN0cmVlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0JCgnLmpzdHJlZTpqc3RyZWUnKS5qc3RyZWUoJ2Rlc3Ryb3knKTtcXG5cXHRcXHQkKGRvY3VtZW50KS5vZmYoJy5qc3RyZWUnKTtcXG5cXHR9O1xcblxcdC8qKlxcbiAgKiB0aGUganN0cmVlIGNsYXNzIGNvbnN0cnVjdG9yLCB1c2VkIG9ubHkgaW50ZXJuYWxseVxcbiAgKiBAcHJpdmF0ZVxcbiAgKiBAbmFtZSAkLmpzdHJlZS5jb3JlKGlkKVxcbiAgKiBAcGFyYW0ge051bWJlcn0gaWQgdGhpcyBpbnN0YW5jZSdzIGluZGV4XFxuICAqL1xcblxcdCQuanN0cmVlLmNvcmUgPSBmdW5jdGlvbiAoaWQpIHtcXG5cXHRcXHR0aGlzLl9pZCA9IGlkO1xcblxcdFxcdHRoaXMuX2NudCA9IDA7XFxuXFx0XFx0dGhpcy5fd3JrID0gbnVsbDtcXG5cXHRcXHR0aGlzLl9kYXRhID0ge1xcblxcdFxcdFxcdGNvcmU6IHtcXG5cXHRcXHRcXHRcXHR0aGVtZXM6IHtcXG5cXHRcXHRcXHRcXHRcXHRuYW1lOiBmYWxzZSxcXG5cXHRcXHRcXHRcXHRcXHRkb3RzOiBmYWxzZSxcXG5cXHRcXHRcXHRcXHRcXHRpY29uczogZmFsc2UsXFxuXFx0XFx0XFx0XFx0XFx0ZWxsaXBzaXM6IGZhbHNlXFxuXFx0XFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRcXHRzZWxlY3RlZDogW10sXFxuXFx0XFx0XFx0XFx0bGFzdF9lcnJvcjoge30sXFxuXFx0XFx0XFx0XFx0d29ya2luZzogZmFsc2UsXFxuXFx0XFx0XFx0XFx0d29ya2VyX3F1ZXVlOiBbXSxcXG5cXHRcXHRcXHRcXHRmb2N1c2VkOiBudWxsXFxuXFx0XFx0XFx0fVxcblxcdFxcdH07XFxuXFx0fTtcXG5cXHQvKipcXG4gICogZ2V0IGEgcmVmZXJlbmNlIHRvIGFuIGV4aXN0aW5nIGluc3RhbmNlXFxuICAqXFxuICAqIF9fRXhhbXBsZXNfX1xcbiAgKlxcbiAgKlxcdC8vIHByb3ZpZGVkIGEgY29udGFpbmVyIHdpdGggYW4gSUQgb2YgXFxcInRyZWVcXFwiLCBhbmQgYSBuZXN0ZWQgbm9kZSB3aXRoIGFuIElEIG9mIFxcXCJicmFuY2hcXFwiXFxuICAqXFx0Ly8gYWxsIG9mIHRoZXJlIHdpbGwgcmV0dXJuIHRoZSBzYW1lIGluc3RhbmNlXFxuICAqXFx0JC5qc3RyZWUucmVmZXJlbmNlKCd0cmVlJyk7XFxuICAqXFx0JC5qc3RyZWUucmVmZXJlbmNlKCcjdHJlZScpO1xcbiAgKlxcdCQuanN0cmVlLnJlZmVyZW5jZSgkKCcjdHJlZScpKTtcXG4gICpcXHQkLmpzdHJlZS5yZWZlcmVuY2UoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SUQoJ3RyZWUnKSk7XFxuICAqXFx0JC5qc3RyZWUucmVmZXJlbmNlKCdicmFuY2gnKTtcXG4gICpcXHQkLmpzdHJlZS5yZWZlcmVuY2UoJyNicmFuY2gnKTtcXG4gICpcXHQkLmpzdHJlZS5yZWZlcmVuY2UoJCgnI2JyYW5jaCcpKTtcXG4gICpcXHQkLmpzdHJlZS5yZWZlcmVuY2UoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SUQoJ2JyYW5jaCcpKTtcXG4gICpcXG4gICogQG5hbWUgJC5qc3RyZWUucmVmZXJlbmNlKG5lZWRsZSlcXG4gICogQHBhcmFtIHtET01FbGVtZW50fGpRdWVyeXxTdHJpbmd9IG5lZWRsZVxcbiAgKiBAcmV0dXJuIHtqc1RyZWV8bnVsbH0gdGhlIGluc3RhbmNlIG9yIGBudWxsYCBpZiBub3QgZm91bmRcXG4gICovXFxuXFx0JC5qc3RyZWUucmVmZXJlbmNlID0gZnVuY3Rpb24gKG5lZWRsZSkge1xcblxcdFxcdHZhciB0bXAgPSBudWxsLFxcblxcdFxcdCAgICBvYmogPSBudWxsO1xcblxcdFxcdGlmIChuZWVkbGUgJiYgbmVlZGxlLmlkICYmICghbmVlZGxlLnRhZ05hbWUgfHwgIW5lZWRsZS5ub2RlVHlwZSkpIHtcXG5cXHRcXHRcXHRuZWVkbGUgPSBuZWVkbGUuaWQ7XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICghb2JqIHx8ICFvYmoubGVuZ3RoKSB7XFxuXFx0XFx0XFx0dHJ5IHtcXG5cXHRcXHRcXHRcXHRvYmogPSAkKG5lZWRsZSk7XFxuXFx0XFx0XFx0fSBjYXRjaCAoaWdub3JlKSB7fVxcblxcdFxcdH1cXG5cXHRcXHRpZiAoIW9iaiB8fCAhb2JqLmxlbmd0aCkge1xcblxcdFxcdFxcdHRyeSB7XFxuXFx0XFx0XFx0XFx0b2JqID0gJCgnIycgKyBuZWVkbGUucmVwbGFjZSgkLmpzdHJlZS5pZHJlZ2V4LCAnXFxcXFxcXFwkJicpKTtcXG5cXHRcXHRcXHR9IGNhdGNoIChpZ25vcmUpIHt9XFxuXFx0XFx0fVxcblxcdFxcdGlmIChvYmogJiYgb2JqLmxlbmd0aCAmJiAob2JqID0gb2JqLmNsb3Nlc3QoJy5qc3RyZWUnKSkubGVuZ3RoICYmIChvYmogPSBvYmouZGF0YSgnanN0cmVlJykpKSB7XFxuXFx0XFx0XFx0dG1wID0gb2JqO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0JCgnLmpzdHJlZScpLmVhY2goZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdHZhciBpbnN0ID0gJCh0aGlzKS5kYXRhKCdqc3RyZWUnKTtcXG5cXHRcXHRcXHRcXHRpZiAoaW5zdCAmJiBpbnN0Ll9tb2RlbC5kYXRhW25lZWRsZV0pIHtcXG5cXHRcXHRcXHRcXHRcXHR0bXAgPSBpbnN0O1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiB0bXA7XFxuXFx0fTtcXG5cXHQvKipcXG4gICogQ3JlYXRlIGFuIGluc3RhbmNlLCBnZXQgYW4gaW5zdGFuY2Ugb3IgaW52b2tlIGEgY29tbWFuZCBvbiBhIGluc3RhbmNlLlxcbiAgKlxcbiAgKiBJZiB0aGVyZSBpcyBubyBpbnN0YW5jZSBhc3NvY2lhdGVkIHdpdGggdGhlIGN1cnJlbnQgbm9kZSBhIG5ldyBvbmUgaXMgY3JlYXRlZCBhbmQgYGFyZ2AgaXMgdXNlZCB0byBleHRlbmQgYCQuanN0cmVlLmRlZmF1bHRzYCBmb3IgdGhpcyBuZXcgaW5zdGFuY2UuIFRoZXJlIHdvdWxkIGJlIG5vIHJldHVybiB2YWx1ZSAoY2hhaW5pbmcgaXMgbm90IGJyb2tlbikuXFxuICAqXFxuICAqIElmIHRoZXJlIGlzIGFuIGV4aXN0aW5nIGluc3RhbmNlIGFuZCBgYXJnYCBpcyBhIHN0cmluZyB0aGUgY29tbWFuZCBzcGVjaWZpZWQgYnkgYGFyZ2AgaXMgZXhlY3V0ZWQgb24gdGhlIGluc3RhbmNlLCB3aXRoIGFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIGZ1bmN0aW9uLiBJZiB0aGUgZnVuY3Rpb24gcmV0dXJucyBhIHZhbHVlIGl0IHdpbGwgYmUgcmV0dXJuZWQgKGNoYWluaW5nIGNvdWxkIGJyZWFrIGRlcGVuZGluZyBvbiBmdW5jdGlvbikuXFxuICAqXFxuICAqIElmIHRoZXJlIGlzIGFuIGV4aXN0aW5nIGluc3RhbmNlIGFuZCBgYXJnYCBpcyBub3QgYSBzdHJpbmcgdGhlIGluc3RhbmNlIGl0c2VsZiBpcyByZXR1cm5lZCAoc2ltaWxhciB0byBgJC5qc3RyZWUucmVmZXJlbmNlYCkuXFxuICAqXFxuICAqIEluIGFueSBvdGhlciBjYXNlIC0gbm90aGluZyBpcyByZXR1cm5lZCBhbmQgY2hhaW5pbmcgaXMgbm90IGJyb2tlbi5cXG4gICpcXG4gICogX19FeGFtcGxlc19fXFxuICAqXFxuICAqXFx0JCgnI3RyZWUxJykuanN0cmVlKCk7IC8vIGNyZWF0ZXMgYW4gaW5zdGFuY2VcXG4gICpcXHQkKCcjdHJlZTInKS5qc3RyZWUoeyBwbHVnaW5zIDogW10gfSk7IC8vIGNyZWF0ZSBhbiBpbnN0YW5jZSB3aXRoIHNvbWUgb3B0aW9uc1xcbiAgKlxcdCQoJyN0cmVlMScpLmpzdHJlZSgnb3Blbl9ub2RlJywgJyNicmFuY2hfMScpOyAvLyBjYWxsIGEgbWV0aG9kIG9uIGFuIGV4aXN0aW5nIGluc3RhbmNlLCBwYXNzaW5nIGFkZGl0aW9uYWwgYXJndW1lbnRzXFxuICAqXFx0JCgnI3RyZWUyJykuanN0cmVlKCk7IC8vIGdldCBhbiBleGlzdGluZyBpbnN0YW5jZSAob3IgY3JlYXRlIGFuIGluc3RhbmNlKVxcbiAgKlxcdCQoJyN0cmVlMicpLmpzdHJlZSh0cnVlKTsgLy8gZ2V0IGFuIGV4aXN0aW5nIGluc3RhbmNlICh3aWxsIG5vdCBjcmVhdGUgbmV3IGluc3RhbmNlKVxcbiAgKlxcdCQoJyNicmFuY2hfMScpLmpzdHJlZSgpLnNlbGVjdF9ub2RlKCcjYnJhbmNoXzEnKTsgLy8gZ2V0IGFuIGluc3RhbmNlICh1c2luZyBhIG5lc3RlZCBlbGVtZW50IGFuZCBjYWxsIGEgbWV0aG9kKVxcbiAgKlxcbiAgKiBAbmFtZSAkKCkuanN0cmVlKFthcmddKVxcbiAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGFyZ1xcbiAgKiBAcmV0dXJuIHtNaXhlZH1cXG4gICovXFxuXFx0JC5mbi5qc3RyZWUgPSBmdW5jdGlvbiAoYXJnKSB7XFxuXFx0XFx0Ly8gY2hlY2sgZm9yIHN0cmluZyBhcmd1bWVudFxcblxcdFxcdHZhciBpc19tZXRob2QgPSB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyxcXG5cXHRcXHQgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXFxuXFx0XFx0ICAgIHJlc3VsdCA9IG51bGw7XFxuXFx0XFx0aWYgKGFyZyA9PT0gdHJ1ZSAmJiAhdGhpcy5sZW5ndGgpIHtcXG5cXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0fVxcblxcdFxcdHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0Ly8gZ2V0IHRoZSBpbnN0YW5jZSAoaWYgdGhlcmUgaXMgb25lKSBhbmQgbWV0aG9kIChpZiBpdCBleGlzdHMpXFxuXFx0XFx0XFx0dmFyIGluc3RhbmNlID0gJC5qc3RyZWUucmVmZXJlbmNlKHRoaXMpLFxcblxcdFxcdFxcdCAgICBtZXRob2QgPSBpc19tZXRob2QgJiYgaW5zdGFuY2UgPyBpbnN0YW5jZVthcmddIDogbnVsbDtcXG5cXHRcXHRcXHQvLyBpZiBjYWxsaW5nIGEgbWV0aG9kLCBhbmQgbWV0aG9kIGlzIGF2YWlsYWJsZSAtIGV4ZWN1dGUgb24gdGhlIGluc3RhbmNlXFxuXFx0XFx0XFx0cmVzdWx0ID0gaXNfbWV0aG9kICYmIG1ldGhvZCA/IG1ldGhvZC5hcHBseShpbnN0YW5jZSwgYXJncykgOiBudWxsO1xcblxcdFxcdFxcdC8vIGlmIHRoZXJlIGlzIG5vIGluc3RhbmNlIGFuZCBubyBtZXRob2QgaXMgYmVpbmcgY2FsbGVkIC0gY3JlYXRlIG9uZVxcblxcdFxcdFxcdGlmICghaW5zdGFuY2UgJiYgIWlzX21ldGhvZCAmJiAoYXJnID09PSB1bmRlZmluZWQgfHwgJC5pc1BsYWluT2JqZWN0KGFyZykpKSB7XFxuXFx0XFx0XFx0XFx0JC5qc3RyZWUuY3JlYXRlKHRoaXMsIGFyZyk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdC8vIGlmIHRoZXJlIGlzIGFuIGluc3RhbmNlIGFuZCBubyBtZXRob2QgaXMgY2FsbGVkIC0gcmV0dXJuIHRoZSBpbnN0YW5jZVxcblxcdFxcdFxcdGlmIChpbnN0YW5jZSAmJiAhaXNfbWV0aG9kIHx8IGFyZyA9PT0gdHJ1ZSkge1xcblxcdFxcdFxcdFxcdHJlc3VsdCA9IGluc3RhbmNlIHx8IGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHQvLyBpZiB0aGVyZSB3YXMgYSBtZXRob2QgY2FsbCB3aGljaCByZXR1cm5lZCBhIHJlc3VsdCAtIGJyZWFrIGFuZCByZXR1cm4gdGhlIHZhbHVlXFxuXFx0XFx0XFx0aWYgKHJlc3VsdCAhPT0gbnVsbCAmJiByZXN1bHQgIT09IHVuZGVmaW5lZCkge1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSk7XFxuXFx0XFx0Ly8gaWYgdGhlcmUgd2FzIGEgbWV0aG9kIGNhbGwgd2l0aCBhIHZhbGlkIHJldHVybiB2YWx1ZSAtIHJldHVybiB0aGF0LCBvdGhlcndpc2UgY29udGludWUgdGhlIGNoYWluXFxuXFx0XFx0cmV0dXJuIHJlc3VsdCAhPT0gbnVsbCAmJiByZXN1bHQgIT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IHRoaXM7XFxuXFx0fTtcXG5cXHQvKipcXG4gICogdXNlZCB0byBmaW5kIGVsZW1lbnRzIGNvbnRhaW5pbmcgYW4gaW5zdGFuY2VcXG4gICpcXG4gICogX19FeGFtcGxlc19fXFxuICAqXFxuICAqXFx0JCgnZGl2OmpzdHJlZScpLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgKlxcdFxcdCQodGhpcykuanN0cmVlKCdkZXN0cm95Jyk7XFxuICAqXFx0fSk7XFxuICAqXFxuICAqIEBuYW1lICQoJzpqc3RyZWUnKVxcbiAgKiBAcmV0dXJuIHtqUXVlcnl9XFxuICAqL1xcblxcdCQuZXhwci5wc2V1ZG9zLmpzdHJlZSA9ICQuZXhwci5jcmVhdGVQc2V1ZG8oZnVuY3Rpb24gKHNlYXJjaCkge1xcblxcdFxcdHJldHVybiBmdW5jdGlvbiAoYSkge1xcblxcdFxcdFxcdHJldHVybiAkKGEpLmhhc0NsYXNzKCdqc3RyZWUnKSAmJiAkKGEpLmRhdGEoJ2pzdHJlZScpICE9PSB1bmRlZmluZWQ7XFxuXFx0XFx0fTtcXG5cXHR9KTtcXG5cXG5cXHQvKipcXG4gICogc3RvcmVzIGFsbCBkZWZhdWx0cyBmb3IgdGhlIGNvcmVcXG4gICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY29yZVxcbiAgKi9cXG5cXHQkLmpzdHJlZS5kZWZhdWx0cy5jb3JlID0ge1xcblxcdFxcdC8qKlxcbiAgICogZGF0YSBjb25maWd1cmF0aW9uXFxuICAgKlxcbiAgICogSWYgbGVmdCBhcyBgZmFsc2VgIHRoZSBIVE1MIGluc2lkZSB0aGUganN0cmVlIGNvbnRhaW5lciBlbGVtZW50IGlzIHVzZWQgdG8gcG9wdWxhdGUgdGhlIHRyZWUgKHRoYXQgc2hvdWxkIGJlIGFuIHVub3JkZXJlZCBsaXN0IHdpdGggbGlzdCBpdGVtcykuXFxuICAgKlxcbiAgICogWW91IGNhbiBhbHNvIHBhc3MgaW4gYSBIVE1MIHN0cmluZyBvciBhIEpTT04gYXJyYXkgaGVyZS5cXG4gICAqXFxuICAgKiBJdCBpcyBwb3NzaWJsZSB0byBwYXNzIGluIGEgc3RhbmRhcmQgalF1ZXJ5LWxpa2UgQUpBWCBjb25maWcgYW5kIGpzdHJlZSB3aWxsIGF1dG9tYXRpY2FsbHkgZGV0ZXJtaW5lIGlmIHRoZSByZXNwb25zZSBpcyBKU09OIG9yIEhUTUwgYW5kIHVzZSB0aGF0IHRvIHBvcHVsYXRlIHRoZSB0cmVlLlxcbiAgICogSW4gYWRkaXRpb24gdG8gdGhlIHN0YW5kYXJkIGpRdWVyeSBhamF4IG9wdGlvbnMgaGVyZSB5b3UgY2FuIHN1cHB5IGZ1bmN0aW9ucyBmb3IgYGRhdGFgIGFuZCBgdXJsYCwgdGhlIGZ1bmN0aW9ucyB3aWxsIGJlIHJ1biBpbiB0aGUgY3VycmVudCBpbnN0YW5jZSdzIHNjb3BlIGFuZCBhIHBhcmFtIHdpbGwgYmUgcGFzc2VkIGluZGljYXRpbmcgd2hpY2ggbm9kZSBpcyBiZWluZyBsb2FkZWQsIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhvc2UgZnVuY3Rpb25zIHdpbGwgYmUgdXNlZC5cXG4gICAqXFxuICAgKiBUaGUgbGFzdCBvcHRpb24gaXMgdG8gc3BlY2lmeSBhIGZ1bmN0aW9uLCB0aGF0IGZ1bmN0aW9uIHdpbGwgcmVjZWl2ZSB0aGUgbm9kZSBiZWluZyBsb2FkZWQgYXMgYXJndW1lbnQgYW5kIGEgc2Vjb25kIHBhcmFtIHdoaWNoIGlzIGEgZnVuY3Rpb24gd2hpY2ggc2hvdWxkIGJlIGNhbGxlZCB3aXRoIHRoZSByZXN1bHQuXFxuICAgKlxcbiAgICogX19FeGFtcGxlc19fXFxuICAgKlxcbiAgICpcXHQvLyBBSkFYXFxuICAgKlxcdCQoJyN0cmVlJykuanN0cmVlKHtcXG4gICAqXFx0XFx0J2NvcmUnIDoge1xcbiAgICpcXHRcXHRcXHQnZGF0YScgOiB7XFxuICAgKlxcdFxcdFxcdFxcdCd1cmwnIDogJy9nZXQvY2hpbGRyZW4vJyxcXG4gICAqXFx0XFx0XFx0XFx0J2RhdGEnIDogZnVuY3Rpb24gKG5vZGUpIHtcXG4gICAqXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHsgJ2lkJyA6IG5vZGUuaWQgfTtcXG4gICAqXFx0XFx0XFx0XFx0fVxcbiAgICpcXHRcXHRcXHR9XFxuICAgKlxcdFxcdH0pO1xcbiAgICpcXG4gICAqXFx0Ly8gZGlyZWN0IGRhdGFcXG4gICAqXFx0JCgnI3RyZWUnKS5qc3RyZWUoe1xcbiAgICpcXHRcXHQnY29yZScgOiB7XFxuICAgKlxcdFxcdFxcdCdkYXRhJyA6IFtcXG4gICAqXFx0XFx0XFx0XFx0J1NpbXBsZSByb290IG5vZGUnLFxcbiAgICpcXHRcXHRcXHRcXHR7XFxuICAgKlxcdFxcdFxcdFxcdFxcdCdpZCcgOiAnbm9kZV8yJyxcXG4gICAqXFx0XFx0XFx0XFx0XFx0J3RleHQnIDogJ1Jvb3Qgbm9kZSB3aXRoIG9wdGlvbnMnLFxcbiAgICpcXHRcXHRcXHRcXHRcXHQnc3RhdGUnIDogeyAnb3BlbmVkJyA6IHRydWUsICdzZWxlY3RlZCcgOiB0cnVlIH0sXFxuICAgKlxcdFxcdFxcdFxcdFxcdCdjaGlsZHJlbicgOiBbIHsgJ3RleHQnIDogJ0NoaWxkIDEnIH0sICdDaGlsZCAyJ11cXG4gICAqXFx0XFx0XFx0XFx0fVxcbiAgICpcXHRcXHRcXHRdXFxuICAgKlxcdFxcdH1cXG4gICAqXFx0fSk7XFxuICAgKlxcbiAgICpcXHQvLyBmdW5jdGlvblxcbiAgICpcXHQkKCcjdHJlZScpLmpzdHJlZSh7XFxuICAgKlxcdFxcdCdjb3JlJyA6IHtcXG4gICAqXFx0XFx0XFx0J2RhdGEnIDogZnVuY3Rpb24gKG9iaiwgY2FsbGJhY2spIHtcXG4gICAqXFx0XFx0XFx0XFx0Y2FsbGJhY2suY2FsbCh0aGlzLCBbJ1Jvb3QgMScsICdSb290IDInXSk7XFxuICAgKlxcdFxcdFxcdH1cXG4gICAqXFx0XFx0fSk7XFxuICAgKlxcbiAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY29yZS5kYXRhXFxuICAgKi9cXG5cXHRcXHRkYXRhOiBmYWxzZSxcXG5cXHRcXHQvKipcXG4gICAqIGNvbmZpZ3VyZSB0aGUgdmFyaW91cyBzdHJpbmdzIHVzZWQgdGhyb3VnaG91dCB0aGUgdHJlZVxcbiAgICpcXG4gICAqIFlvdSBjYW4gdXNlIGFuIG9iamVjdCB3aGVyZSB0aGUga2V5IGlzIHRoZSBzdHJpbmcgeW91IG5lZWQgdG8gcmVwbGFjZSBhbmQgdGhlIHZhbHVlIGlzIHlvdXIgcmVwbGFjZW1lbnQuXFxuICAgKiBBbm90aGVyIG9wdGlvbiBpcyB0byBzcGVjaWZ5IGEgZnVuY3Rpb24gd2hpY2ggd2lsbCBiZSBjYWxsZWQgd2l0aCBhbiBhcmd1bWVudCBvZiB0aGUgbmVlZGVkIHN0cmluZyBhbmQgc2hvdWxkIHJldHVybiB0aGUgcmVwbGFjZW1lbnQuXFxuICAgKiBJZiBsZWZ0IGFzIGBmYWxzZWAgbm8gcmVwbGFjZW1lbnQgaXMgbWFkZS5cXG4gICAqXFxuICAgKiBfX0V4YW1wbGVzX19cXG4gICAqXFxuICAgKlxcdCQoJyN0cmVlJykuanN0cmVlKHtcXG4gICAqXFx0XFx0J2NvcmUnIDoge1xcbiAgICpcXHRcXHRcXHQnc3RyaW5ncycgOiB7XFxuICAgKlxcdFxcdFxcdFxcdCdMb2FkaW5nIC4uLicgOiAnUGxlYXNlIHdhaXQgLi4uJ1xcbiAgICpcXHRcXHRcXHR9XFxuICAgKlxcdFxcdH1cXG4gICAqXFx0fSk7XFxuICAgKlxcbiAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY29yZS5zdHJpbmdzXFxuICAgKi9cXG5cXHRcXHRzdHJpbmdzOiBmYWxzZSxcXG5cXHRcXHQvKipcXG4gICAqIGRldGVybWluZXMgd2hhdCBoYXBwZW5zIHdoZW4gYSB1c2VyIHRyaWVzIHRvIG1vZGlmeSB0aGUgc3RydWN0dXJlIG9mIHRoZSB0cmVlXFxuICAgKiBJZiBsZWZ0IGFzIGBmYWxzZWAgYWxsIG9wZXJhdGlvbnMgbGlrZSBjcmVhdGUsIHJlbmFtZSwgZGVsZXRlLCBtb3ZlIG9yIGNvcHkgYXJlIHByZXZlbnRlZC5cXG4gICAqIFlvdSBjYW4gc2V0IHRoaXMgdG8gYHRydWVgIHRvIGFsbG93IGFsbCBpbnRlcmFjdGlvbnMgb3IgdXNlIGEgZnVuY3Rpb24gdG8gaGF2ZSBiZXR0ZXIgY29udHJvbC5cXG4gICAqXFxuICAgKiBfX0V4YW1wbGVzX19cXG4gICAqXFxuICAgKlxcdCQoJyN0cmVlJykuanN0cmVlKHtcXG4gICAqXFx0XFx0J2NvcmUnIDoge1xcbiAgICpcXHRcXHRcXHQnY2hlY2tfY2FsbGJhY2snIDogZnVuY3Rpb24gKG9wZXJhdGlvbiwgbm9kZSwgbm9kZV9wYXJlbnQsIG5vZGVfcG9zaXRpb24sIG1vcmUpIHtcXG4gICAqXFx0XFx0XFx0XFx0Ly8gb3BlcmF0aW9uIGNhbiBiZSAnY3JlYXRlX25vZGUnLCAncmVuYW1lX25vZGUnLCAnZGVsZXRlX25vZGUnLCAnbW92ZV9ub2RlJyBvciAnY29weV9ub2RlJ1xcbiAgICpcXHRcXHRcXHRcXHQvLyBpbiBjYXNlIG9mICdyZW5hbWVfbm9kZScgbm9kZV9wb3NpdGlvbiBpcyBmaWxsZWQgd2l0aCB0aGUgbmV3IG5vZGUgbmFtZVxcbiAgICpcXHRcXHRcXHRcXHRyZXR1cm4gb3BlcmF0aW9uID09PSAncmVuYW1lX25vZGUnID8gdHJ1ZSA6IGZhbHNlO1xcbiAgICpcXHRcXHRcXHR9XFxuICAgKlxcdFxcdH1cXG4gICAqXFx0fSk7XFxuICAgKlxcbiAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY29yZS5jaGVja19jYWxsYmFja1xcbiAgICovXFxuXFx0XFx0Y2hlY2tfY2FsbGJhY2s6IGZhbHNlLFxcblxcdFxcdC8qKlxcbiAgICogYSBjYWxsYmFjayBjYWxsZWQgd2l0aCBhIHNpbmdsZSBvYmplY3QgcGFyYW1ldGVyIGluIHRoZSBpbnN0YW5jZSdzIHNjb3BlIHdoZW4gc29tZXRoaW5nIGdvZXMgd3JvbmcgKG9wZXJhdGlvbiBwcmV2ZW50ZWQsIGFqYXggZmFpbGVkLCBldGMpXFxuICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb3JlLmVycm9yXFxuICAgKi9cXG5cXHRcXHRlcnJvcjogJC5ub29wLFxcblxcdFxcdC8qKlxcbiAgICogdGhlIG9wZW4gLyBjbG9zZSBhbmltYXRpb24gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzIC0gc2V0IHRoaXMgdG8gYGZhbHNlYCB0byBkaXNhYmxlIHRoZSBhbmltYXRpb24gKGRlZmF1bHQgaXMgYDIwMGApXFxuICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb3JlLmFuaW1hdGlvblxcbiAgICovXFxuXFx0XFx0YW5pbWF0aW9uOiAyMDAsXFxuXFx0XFx0LyoqXFxuICAgKiBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiBtdWx0aXBsZSBub2RlcyBjYW4gYmUgc2VsZWN0ZWRcXG4gICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvcmUubXVsdGlwbGVcXG4gICAqL1xcblxcdFxcdG11bHRpcGxlOiB0cnVlLFxcblxcdFxcdC8qKlxcbiAgICogdGhlbWUgY29uZmlndXJhdGlvbiBvYmplY3RcXG4gICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvcmUudGhlbWVzXFxuICAgKi9cXG5cXHRcXHR0aGVtZXM6IHtcXG5cXHRcXHRcXHQvKipcXG4gICAgKiB0aGUgbmFtZSBvZiB0aGUgdGhlbWUgdG8gdXNlIChpZiBsZWZ0IGFzIGBmYWxzZWAgdGhlIGRlZmF1bHQgdGhlbWUgaXMgdXNlZClcXG4gICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb3JlLnRoZW1lcy5uYW1lXFxuICAgICovXFxuXFx0XFx0XFx0bmFtZTogZmFsc2UsXFxuXFx0XFx0XFx0LyoqXFxuICAgICogdGhlIFVSTCBvZiB0aGUgdGhlbWUncyBDU1MgZmlsZSwgbGVhdmUgdGhpcyBhcyBgZmFsc2VgIGlmIHlvdSBoYXZlIG1hbnVhbGx5IGluY2x1ZGVkIHRoZSB0aGVtZSBDU1MgKHJlY29tbWVuZGVkKS4gWW91IGNhbiBzZXQgdGhpcyB0byBgdHJ1ZWAgdG9vIHdoaWNoIHdpbGwgdHJ5IHRvIGF1dG9sb2FkIHRoZSB0aGVtZS5cXG4gICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb3JlLnRoZW1lcy51cmxcXG4gICAgKi9cXG5cXHRcXHRcXHR1cmw6IGZhbHNlLFxcblxcdFxcdFxcdC8qKlxcbiAgICAqIHRoZSBsb2NhdGlvbiBvZiBhbGwganN0cmVlIHRoZW1lcyAtIG9ubHkgdXNlZCBpZiBgdXJsYCBpcyBzZXQgdG8gYHRydWVgXFxuICAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY29yZS50aGVtZXMuZGlyXFxuICAgICovXFxuXFx0XFx0XFx0ZGlyOiBmYWxzZSxcXG5cXHRcXHRcXHQvKipcXG4gICAgKiBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiBjb25uZWN0aW5nIGRvdHMgYXJlIHNob3duXFxuICAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY29yZS50aGVtZXMuZG90c1xcbiAgICAqL1xcblxcdFxcdFxcdGRvdHM6IHRydWUsXFxuXFx0XFx0XFx0LyoqXFxuICAgICogYSBib29sZWFuIGluZGljYXRpbmcgaWYgbm9kZSBpY29ucyBhcmUgc2hvd25cXG4gICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb3JlLnRoZW1lcy5pY29uc1xcbiAgICAqL1xcblxcdFxcdFxcdGljb25zOiB0cnVlLFxcblxcdFxcdFxcdC8qKlxcbiAgICAqIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIG5vZGUgZWxsaXBzaXMgc2hvdWxkIGJlIHNob3duIC0gdGhpcyBvbmx5IHdvcmtzIHdpdGggYSBmaXhlZCB3aXRoIG9uIHRoZSBjb250YWluZXJcXG4gICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb3JlLnRoZW1lcy5lbGxpcHNpc1xcbiAgICAqL1xcblxcdFxcdFxcdGVsbGlwc2lzOiBmYWxzZSxcXG5cXHRcXHRcXHQvKipcXG4gICAgKiBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiB0aGUgdHJlZSBiYWNrZ3JvdW5kIGlzIHN0cmlwZWRcXG4gICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb3JlLnRoZW1lcy5zdHJpcGVzXFxuICAgICovXFxuXFx0XFx0XFx0c3RyaXBlczogZmFsc2UsXFxuXFx0XFx0XFx0LyoqXFxuICAgICogYSBzdHJpbmcgKG9yIGJvb2xlYW4gYGZhbHNlYCkgc3BlY2lmeWluZyB0aGUgdGhlbWUgdmFyaWFudCB0byB1c2UgKGlmIHRoZSB0aGVtZSBzdXBwb3J0cyB2YXJpYW50cylcXG4gICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb3JlLnRoZW1lcy52YXJpYW50XFxuICAgICovXFxuXFx0XFx0XFx0dmFyaWFudDogZmFsc2UsXFxuXFx0XFx0XFx0LyoqXFxuICAgICogYSBib29sZWFuIHNwZWNpZnlpbmcgaWYgYSByZXBvbnNpdmUgdmVyc2lvbiBvZiB0aGUgdGhlbWUgc2hvdWxkIGtpY2sgaW4gb24gc21hbGxlciBzY3JlZW5zIChpZiB0aGUgdGhlbWUgc3VwcG9ydHMgaXQpLiBEZWZhdWx0cyB0byBgZmFsc2VgLlxcbiAgICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvcmUudGhlbWVzLnJlc3BvbnNpdmVcXG4gICAgKi9cXG5cXHRcXHRcXHRyZXNwb25zaXZlOiBmYWxzZVxcblxcdFxcdH0sXFxuXFx0XFx0LyoqXFxuICAgKiBpZiBsZWZ0IGFzIGB0cnVlYCBhbGwgcGFyZW50cyBvZiBhbGwgc2VsZWN0ZWQgbm9kZXMgd2lsbCBiZSBvcGVuZWQgb25jZSB0aGUgdHJlZSBsb2FkcyAoc28gdGhhdCBhbGwgc2VsZWN0ZWQgbm9kZXMgYXJlIHZpc2libGUgdG8gdGhlIHVzZXIpXFxuICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb3JlLmV4cGFuZF9zZWxlY3RlZF9vbmxvYWRcXG4gICAqL1xcblxcdFxcdGV4cGFuZF9zZWxlY3RlZF9vbmxvYWQ6IHRydWUsXFxuXFx0XFx0LyoqXFxuICAgKiBpZiBsZWZ0IGFzIGB0cnVlYCB3ZWIgd29ya2VycyB3aWxsIGJlIHVzZWQgdG8gcGFyc2UgaW5jb21pbmcgSlNPTiBkYXRhIHdoZXJlIHBvc3NpYmxlLCBzbyB0aGF0IHRoZSBVSSB3aWxsIG5vdCBiZSBibG9ja2VkIGJ5IGxhcmdlIHJlcXVlc3RzLiBXb3JrZXJzIGFyZSBob3dldmVyIGFib3V0IDMwJSBzbG93ZXIuIERlZmF1bHRzIHRvIGB0cnVlYFxcbiAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY29yZS53b3JrZXJcXG4gICAqL1xcblxcdFxcdHdvcmtlcjogdHJ1ZSxcXG5cXHRcXHQvKipcXG4gICAqIEZvcmNlIG5vZGUgdGV4dCB0byBwbGFpbiB0ZXh0IChhbmQgZXNjYXBlIEhUTUwpLiBEZWZhdWx0cyB0byBgZmFsc2VgXFxuICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb3JlLmZvcmNlX3RleHRcXG4gICAqL1xcblxcdFxcdGZvcmNlX3RleHQ6IGZhbHNlLFxcblxcdFxcdC8qKlxcbiAgICogU2hvdWxkIHRoZSBub2RlIHNob3VsZCBiZSB0b2dnbGVkIGlmIHRoZSB0ZXh0IGlzIGRvdWJsZSBjbGlja2VkIC4gRGVmYXVsdHMgdG8gYHRydWVgXFxuICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb3JlLmRibGNsaWNrX3RvZ2dsZVxcbiAgICovXFxuXFx0XFx0ZGJsY2xpY2tfdG9nZ2xlOiB0cnVlXFxuXFx0fTtcXG5cXHQkLmpzdHJlZS5jb3JlLnByb3RvdHlwZSA9IHtcXG5cXHRcXHQvKipcXG4gICAqIHVzZWQgdG8gZGVjb3JhdGUgYW4gaW5zdGFuY2Ugd2l0aCBhIHBsdWdpbi4gVXNlZCBpbnRlcm5hbGx5LlxcbiAgICogQHByaXZhdGVcXG4gICAqIEBuYW1lIHBsdWdpbihkZWNvIFssIG9wdHNdKVxcbiAgICogQHBhcmFtICB7U3RyaW5nfSBkZWNvIHRoZSBwbHVnaW4gdG8gZGVjb3JhdGUgd2l0aFxcbiAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRzIG9wdGlvbnMgZm9yIHRoZSBwbHVnaW5cXG4gICAqIEByZXR1cm4ge2pzVHJlZX1cXG4gICAqL1xcblxcdFxcdHBsdWdpbjogZnVuY3Rpb24gcGx1Z2luKGRlY28sIG9wdHMpIHtcXG5cXHRcXHRcXHR2YXIgQ2hpbGQgPSAkLmpzdHJlZS5wbHVnaW5zW2RlY29dO1xcblxcdFxcdFxcdGlmIChDaGlsZCkge1xcblxcdFxcdFxcdFxcdHRoaXMuX2RhdGFbZGVjb10gPSB7fTtcXG5cXHRcXHRcXHRcXHRDaGlsZC5wcm90b3R5cGUgPSB0aGlzO1xcblxcdFxcdFxcdFxcdHJldHVybiBuZXcgQ2hpbGQob3B0cywgdGhpcyk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcdFxcdH0sXFxuXFx0XFx0LyoqXFxuICAgKiBpbml0aWFsaXplIHRoZSBpbnN0YW5jZS4gVXNlZCBpbnRlcm5hbGx5LlxcbiAgICogQHByaXZhdGVcXG4gICAqIEBuYW1lIGluaXQoZWwsIG9wdG9ucylcXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudHxqUXVlcnl8U3RyaW5nfSBlbCB0aGUgZWxlbWVudCB3ZSBhcmUgdHJhbnNmb3JtaW5nXFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBvcHRpb25zIGZvciB0aGlzIGluc3RhbmNlXFxuICAgKiBAdHJpZ2dlciBpbml0LmpzdHJlZSwgbG9hZGluZy5qc3RyZWUsIGxvYWRlZC5qc3RyZWUsIHJlYWR5LmpzdHJlZSwgY2hhbmdlZC5qc3RyZWVcXG4gICAqL1xcblxcdFxcdGluaXQ6IGZ1bmN0aW9uIGluaXQoZWwsIG9wdGlvbnMpIHtcXG5cXHRcXHRcXHR0aGlzLl9tb2RlbCA9IHtcXG5cXHRcXHRcXHRcXHRkYXRhOiB7fSxcXG5cXHRcXHRcXHRcXHRjaGFuZ2VkOiBbXSxcXG5cXHRcXHRcXHRcXHRmb3JjZV9mdWxsX3JlZHJhdzogZmFsc2UsXFxuXFx0XFx0XFx0XFx0cmVkcmF3X3RpbWVvdXQ6IGZhbHNlLFxcblxcdFxcdFxcdFxcdGRlZmF1bHRfc3RhdGU6IHtcXG5cXHRcXHRcXHRcXHRcXHRsb2FkZWQ6IHRydWUsXFxuXFx0XFx0XFx0XFx0XFx0b3BlbmVkOiBmYWxzZSxcXG5cXHRcXHRcXHRcXHRcXHRzZWxlY3RlZDogZmFsc2UsXFxuXFx0XFx0XFx0XFx0XFx0ZGlzYWJsZWQ6IGZhbHNlXFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH07XFxuXFx0XFx0XFx0dGhpcy5fbW9kZWwuZGF0YVskLmpzdHJlZS5yb290XSA9IHtcXG5cXHRcXHRcXHRcXHRpZDogJC5qc3RyZWUucm9vdCxcXG5cXHRcXHRcXHRcXHRwYXJlbnQ6IG51bGwsXFxuXFx0XFx0XFx0XFx0cGFyZW50czogW10sXFxuXFx0XFx0XFx0XFx0Y2hpbGRyZW46IFtdLFxcblxcdFxcdFxcdFxcdGNoaWxkcmVuX2Q6IFtdLFxcblxcdFxcdFxcdFxcdHN0YXRlOiB7IGxvYWRlZDogZmFsc2UgfVxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0XFx0dGhpcy5lbGVtZW50ID0gJChlbCkuYWRkQ2xhc3MoJ2pzdHJlZSBqc3RyZWUtJyArIHRoaXMuX2lkKTtcXG5cXHRcXHRcXHR0aGlzLnNldHRpbmdzID0gb3B0aW9ucztcXG5cXG5cXHRcXHRcXHR0aGlzLl9kYXRhLmNvcmUucmVhZHkgPSBmYWxzZTtcXG5cXHRcXHRcXHR0aGlzLl9kYXRhLmNvcmUubG9hZGVkID0gZmFsc2U7XFxuXFx0XFx0XFx0dGhpcy5fZGF0YS5jb3JlLnJ0bCA9IHRoaXMuZWxlbWVudC5jc3MoXFxcImRpcmVjdGlvblxcXCIpID09PSBcXFwicnRsXFxcIjtcXG5cXHRcXHRcXHR0aGlzLmVsZW1lbnRbdGhpcy5fZGF0YS5jb3JlLnJ0bCA/ICdhZGRDbGFzcycgOiAncmVtb3ZlQ2xhc3MnXShcXFwianN0cmVlLXJ0bFxcXCIpO1xcblxcdFxcdFxcdHRoaXMuZWxlbWVudC5hdHRyKCdyb2xlJywgJ3RyZWUnKTtcXG5cXHRcXHRcXHRpZiAodGhpcy5zZXR0aW5ncy5jb3JlLm11bHRpcGxlKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5lbGVtZW50LmF0dHIoJ2FyaWEtbXVsdGlzZWxlY3RhYmxlJywgdHJ1ZSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICghdGhpcy5lbGVtZW50LmF0dHIoJ3RhYmluZGV4JykpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLmVsZW1lbnQuYXR0cigndGFiaW5kZXgnLCAnMCcpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLmJpbmQoKTtcXG5cXHRcXHRcXHQvKipcXG4gICAgKiB0cmlnZ2VyZWQgYWZ0ZXIgYWxsIGV2ZW50cyBhcmUgYm91bmRcXG4gICAgKiBAZXZlbnRcXG4gICAgKiBAbmFtZSBpbml0LmpzdHJlZVxcbiAgICAqL1xcblxcdFxcdFxcdHRoaXMudHJpZ2dlcihcXFwiaW5pdFxcXCIpO1xcblxcblxcdFxcdFxcdHRoaXMuX2RhdGEuY29yZS5vcmlnaW5hbF9jb250YWluZXJfaHRtbCA9IHRoaXMuZWxlbWVudC5maW5kKFxcXCIgPiB1bCA+IGxpXFxcIikuY2xvbmUodHJ1ZSk7XFxuXFx0XFx0XFx0dGhpcy5fZGF0YS5jb3JlLm9yaWdpbmFsX2NvbnRhaW5lcl9odG1sLmZpbmQoXFxcImxpXFxcIikuYWRkQmFjaygpLmNvbnRlbnRzKCkuZmlsdGVyKGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5ub2RlVHlwZSA9PT0gMyAmJiAoIXRoaXMubm9kZVZhbHVlIHx8IC9eXFxcXHMrJC8udGVzdCh0aGlzLm5vZGVWYWx1ZSkpO1xcblxcdFxcdFxcdH0pLnJlbW92ZSgpO1xcblxcdFxcdFxcdHRoaXMuZWxlbWVudC5odG1sKFxcXCI8XFxcIiArIFxcXCJ1bCBjbGFzcz0nanN0cmVlLWNvbnRhaW5lci11bCBqc3RyZWUtY2hpbGRyZW4nIHJvbGU9J2dyb3VwJz48XFxcIiArIFxcXCJsaSBpZD0nalxcXCIgKyB0aGlzLl9pZCArIFxcXCJfbG9hZGluZycgY2xhc3M9J2pzdHJlZS1pbml0aWFsLW5vZGUganN0cmVlLWxvYWRpbmcganN0cmVlLWxlYWYganN0cmVlLWxhc3QnIHJvbGU9J3RyZWUtaXRlbSc+PGkgY2xhc3M9J2pzdHJlZS1pY29uIGpzdHJlZS1vY2wnPjwvaT48XFxcIiArIFxcXCJhIGNsYXNzPSdqc3RyZWUtYW5jaG9yJyBocmVmPScjJz48aSBjbGFzcz0nanN0cmVlLWljb24ganN0cmVlLXRoZW1laWNvbi1oaWRkZW4nPjwvaT5cXFwiICsgdGhpcy5nZXRfc3RyaW5nKFxcXCJMb2FkaW5nIC4uLlxcXCIpICsgXFxcIjwvYT48L2xpPjwvdWw+XFxcIik7XFxuXFx0XFx0XFx0dGhpcy5lbGVtZW50LmF0dHIoJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCcsICdqJyArIHRoaXMuX2lkICsgJ19sb2FkaW5nJyk7XFxuXFx0XFx0XFx0dGhpcy5fZGF0YS5jb3JlLmxpX2hlaWdodCA9IHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpLmNoaWxkcmVuKFxcXCJsaVxcXCIpLmZpcnN0KCkuaGVpZ2h0KCkgfHwgMjQ7XFxuXFx0XFx0XFx0dGhpcy5fZGF0YS5jb3JlLm5vZGUgPSB0aGlzLl9jcmVhdGVfcHJvdG90eXBlX25vZGUoKTtcXG5cXHRcXHRcXHQvKipcXG4gICAgKiB0cmlnZ2VyZWQgYWZ0ZXIgdGhlIGxvYWRpbmcgdGV4dCBpcyBzaG93biBhbmQgYmVmb3JlIGxvYWRpbmcgc3RhcnRzXFxuICAgICogQGV2ZW50XFxuICAgICogQG5hbWUgbG9hZGluZy5qc3RyZWVcXG4gICAgKi9cXG5cXHRcXHRcXHR0aGlzLnRyaWdnZXIoXFxcImxvYWRpbmdcXFwiKTtcXG5cXHRcXHRcXHR0aGlzLmxvYWRfbm9kZSgkLmpzdHJlZS5yb290KTtcXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogZGVzdHJveSBhbiBpbnN0YW5jZVxcbiAgICogQG5hbWUgZGVzdHJveSgpXFxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBrZWVwX2h0bWwgaWYgbm90IHNldCB0byBgdHJ1ZWAgdGhlIGNvbnRhaW5lciB3aWxsIGJlIGVtcHRpZWQsIG90aGVyd2lzZSB0aGUgY3VycmVudCBET00gZWxlbWVudHMgd2lsbCBiZSBrZXB0IGludGFjdFxcbiAgICovXFxuXFx0XFx0ZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveShrZWVwX2h0bWwpIHtcXG5cXHRcXHRcXHRpZiAodGhpcy5fd3JrKSB7XFxuXFx0XFx0XFx0XFx0dHJ5IHtcXG5cXHRcXHRcXHRcXHRcXHR3aW5kb3cuVVJMLnJldm9rZU9iamVjdFVSTCh0aGlzLl93cmspO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX3dyayA9IG51bGw7XFxuXFx0XFx0XFx0XFx0fSBjYXRjaCAoaWdub3JlKSB7fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoIWtlZXBfaHRtbCkge1xcblxcdFxcdFxcdFxcdHRoaXMuZWxlbWVudC5lbXB0eSgpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR0aGlzLnRlYXJkb3duKCk7XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIENyZWF0ZSBwcm90b3R5cGUgbm9kZVxcbiAgICovXFxuXFx0XFx0X2NyZWF0ZV9wcm90b3R5cGVfbm9kZTogZnVuY3Rpb24gX2NyZWF0ZV9wcm90b3R5cGVfbm9kZSgpIHtcXG5cXHRcXHRcXHR2YXIgX25vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdMSScpLFxcblxcdFxcdFxcdCAgICBfdGVtcDEsXFxuXFx0XFx0XFx0ICAgIF90ZW1wMjtcXG5cXHRcXHRcXHRfbm9kZS5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAndHJlZWl0ZW0nKTtcXG5cXHRcXHRcXHRfdGVtcDEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdJJyk7XFxuXFx0XFx0XFx0X3RlbXAxLmNsYXNzTmFtZSA9ICdqc3RyZWUtaWNvbiBqc3RyZWUtb2NsJztcXG5cXHRcXHRcXHRfdGVtcDEuc2V0QXR0cmlidXRlKCdyb2xlJywgJ3ByZXNlbnRhdGlvbicpO1xcblxcdFxcdFxcdF9ub2RlLmFwcGVuZENoaWxkKF90ZW1wMSk7XFxuXFx0XFx0XFx0X3RlbXAxID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnQScpO1xcblxcdFxcdFxcdF90ZW1wMS5jbGFzc05hbWUgPSAnanN0cmVlLWFuY2hvcic7XFxuXFx0XFx0XFx0X3RlbXAxLnNldEF0dHJpYnV0ZSgnaHJlZicsICcjJyk7XFxuXFx0XFx0XFx0X3RlbXAxLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKTtcXG5cXHRcXHRcXHRfdGVtcDIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdJJyk7XFxuXFx0XFx0XFx0X3RlbXAyLmNsYXNzTmFtZSA9ICdqc3RyZWUtaWNvbiBqc3RyZWUtdGhlbWVpY29uJztcXG5cXHRcXHRcXHRfdGVtcDIuc2V0QXR0cmlidXRlKCdyb2xlJywgJ3ByZXNlbnRhdGlvbicpO1xcblxcdFxcdFxcdF90ZW1wMS5hcHBlbmRDaGlsZChfdGVtcDIpO1xcblxcdFxcdFxcdF9ub2RlLmFwcGVuZENoaWxkKF90ZW1wMSk7XFxuXFx0XFx0XFx0X3RlbXAxID0gX3RlbXAyID0gbnVsbDtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gX25vZGU7XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIHBhcnQgb2YgdGhlIGRlc3Ryb3lpbmcgb2YgYW4gaW5zdGFuY2UuIFVzZWQgaW50ZXJuYWxseS5cXG4gICAqIEBwcml2YXRlXFxuICAgKiBAbmFtZSB0ZWFyZG93bigpXFxuICAgKi9cXG5cXHRcXHR0ZWFyZG93bjogZnVuY3Rpb24gdGVhcmRvd24oKSB7XFxuXFx0XFx0XFx0dGhpcy51bmJpbmQoKTtcXG5cXHRcXHRcXHR0aGlzLmVsZW1lbnQucmVtb3ZlQ2xhc3MoJ2pzdHJlZScpLnJlbW92ZURhdGEoJ2pzdHJlZScpLmZpbmQoXFxcIltjbGFzc149J2pzdHJlZSddXFxcIikuYWRkQmFjaygpLmF0dHIoXFxcImNsYXNzXFxcIiwgZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLmNsYXNzTmFtZS5yZXBsYWNlKC9qc3RyZWVbXiBdKnwkL2lnLCAnJyk7XFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0dGhpcy5lbGVtZW50ID0gbnVsbDtcXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogYmluZCBhbGwgZXZlbnRzLiBVc2VkIGludGVybmFsbHkuXFxuICAgKiBAcHJpdmF0ZVxcbiAgICogQG5hbWUgYmluZCgpXFxuICAgKi9cXG5cXHRcXHRiaW5kOiBmdW5jdGlvbiBiaW5kKCkge1xcblxcdFxcdFxcdHZhciB3b3JkID0gJycsXFxuXFx0XFx0XFx0ICAgIHRvdXQgPSBudWxsLFxcblxcdFxcdFxcdCAgICB3YXNfY2xpY2sgPSAwO1xcblxcdFxcdFxcdHRoaXMuZWxlbWVudC5vbihcXFwiZGJsY2xpY2suanN0cmVlXFxcIiwgZnVuY3Rpb24gKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZS50YXJnZXQudGFnTmFtZSAmJiBlLnRhcmdldC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFxcXCJpbnB1dFxcXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aWYgKGRvY3VtZW50LnNlbGVjdGlvbiAmJiBkb2N1bWVudC5zZWxlY3Rpb24uZW1wdHkpIHtcXG5cXHRcXHRcXHRcXHRcXHRkb2N1bWVudC5zZWxlY3Rpb24uZW1wdHkoKTtcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdGlmICh3aW5kb3cuZ2V0U2VsZWN0aW9uKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIHNlbCA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0cnkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzZWwuY29sbGFwc2UoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9IGNhdGNoIChpZ25vcmUpIHt9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9KS5vbihcXFwibW91c2Vkb3duLmpzdHJlZVxcXCIsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZS50YXJnZXQgPT09IHRoaXMuZWxlbWVudFswXSkge1xcblxcdFxcdFxcdFxcdFxcdGUucHJldmVudERlZmF1bHQoKTsgLy8gcHJldmVudCBsb3NpbmcgZm9jdXMgd2hlbiBjbGlja2luZyBzY3JvbGwgYXJyb3dzIChGRiwgQ2hyb21lKVxcblxcdFxcdFxcdFxcdFxcdHdhc19jbGljayA9ICtuZXcgRGF0ZSgpOyAvLyBpZSBkb2VzIG5vdCBhbGxvdyB0byBwcmV2ZW50IGxvc2luZyBmb2N1c1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LCB0aGlzKSkub24oXFxcIm1vdXNlZG93bi5qc3RyZWVcXFwiLCBcXFwiLmpzdHJlZS1vY2xcXFwiLCBmdW5jdGlvbiAoZSkge1xcblxcdFxcdFxcdFxcdGUucHJldmVudERlZmF1bHQoKTsgLy8gcHJldmVudCBhbnkgbm9kZSBpbnNpZGUgZnJvbSBsb3NpbmcgZm9jdXMgd2hlbiBjbGlja2luZyB0aGUgb3Blbi9jbG9zZSBpY29uXFxuXFx0XFx0XFx0fSkub24oXFxcImNsaWNrLmpzdHJlZVxcXCIsIFxcXCIuanN0cmVlLW9jbFxcXCIsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLnRvZ2dsZV9ub2RlKGUudGFyZ2V0KTtcXG5cXHRcXHRcXHR9LCB0aGlzKSkub24oXFxcImRibGNsaWNrLmpzdHJlZVxcXCIsIFxcXCIuanN0cmVlLWFuY2hvclxcXCIsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZS50YXJnZXQudGFnTmFtZSAmJiBlLnRhcmdldC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFxcXCJpbnB1dFxcXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aWYgKHRoaXMuc2V0dGluZ3MuY29yZS5kYmxjbGlja190b2dnbGUpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnRvZ2dsZV9ub2RlKGUudGFyZ2V0KTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSwgdGhpcykpLm9uKFxcXCJjbGljay5qc3RyZWVcXFwiLCBcXFwiLmpzdHJlZS1hbmNob3JcXFwiLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XFxuXFx0XFx0XFx0XFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdFxcdFxcdFxcdGlmIChlLmN1cnJlbnRUYXJnZXQgIT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIHtcXG5cXHRcXHRcXHRcXHRcXHQkKGUuY3VycmVudFRhcmdldCkuZm9jdXMoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0dGhpcy5hY3RpdmF0ZV9ub2RlKGUuY3VycmVudFRhcmdldCwgZSk7XFxuXFx0XFx0XFx0fSwgdGhpcykpLm9uKCdrZXlkb3duLmpzdHJlZScsICcuanN0cmVlLWFuY2hvcicsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZS50YXJnZXQudGFnTmFtZSAmJiBlLnRhcmdldC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFxcXCJpbnB1dFxcXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aWYgKGUud2hpY2ggIT09IDMyICYmIGUud2hpY2ggIT09IDEzICYmIChlLnNoaWZ0S2V5IHx8IGUuY3RybEtleSB8fCBlLmFsdEtleSB8fCBlLm1ldGFLZXkpKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHZhciBvID0gbnVsbDtcXG5cXHRcXHRcXHRcXHRpZiAodGhpcy5fZGF0YS5jb3JlLnJ0bCkge1xcblxcdFxcdFxcdFxcdFxcdGlmIChlLndoaWNoID09PSAzNykge1xcblxcdFxcdFxcdFxcdFxcdFxcdGUud2hpY2ggPSAzOTtcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2UgaWYgKGUud2hpY2ggPT09IDM5KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZS53aGljaCA9IDM3O1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0c3dpdGNoIChlLndoaWNoKSB7XFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAzMjpcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBhcmlhIGRlZmluZXMgc3BhY2Ugb25seSB3aXRoIEN0cmxcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoZS5jdHJsS2V5KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZS50eXBlID0gXFxcImNsaWNrXFxcIjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQkKGUuY3VycmVudFRhcmdldCkudHJpZ2dlcihlKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAxMzpcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBlbnRlclxcblxcdFxcdFxcdFxcdFxcdFxcdGUudHlwZSA9IFxcXCJjbGlja1xcXCI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0JChlLmN1cnJlbnRUYXJnZXQpLnRyaWdnZXIoZSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAzNzpcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBsZWZ0XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICh0aGlzLmlzX29wZW4oZS5jdXJyZW50VGFyZ2V0KSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuY2xvc2Vfbm9kZShlLmN1cnJlbnRUYXJnZXQpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0byA9IHRoaXMuZ2V0X3BhcmVudChlLmN1cnJlbnRUYXJnZXQpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChvICYmIG8uaWQgIT09ICQuanN0cmVlLnJvb3QpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLmdldF9ub2RlKG8sIHRydWUpLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLmZvY3VzKCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRjYXNlIDM4OlxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIHVwXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdFxcdFxcdFxcdFxcdFxcdG8gPSB0aGlzLmdldF9wcmV2X2RvbShlLmN1cnJlbnRUYXJnZXQpO1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChvICYmIG8ubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0by5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5mb2N1cygpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRjYXNlIDM5OlxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIHJpZ2h0XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICh0aGlzLmlzX2Nsb3NlZChlLmN1cnJlbnRUYXJnZXQpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5vcGVuX25vZGUoZS5jdXJyZW50VGFyZ2V0LCBmdW5jdGlvbiAobykge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuZ2V0X25vZGUobywgdHJ1ZSkuY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuZm9jdXMoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2UgaWYgKHRoaXMuaXNfb3BlbihlLmN1cnJlbnRUYXJnZXQpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0byA9IHRoaXMuZ2V0X25vZGUoZS5jdXJyZW50VGFyZ2V0LCB0cnVlKS5jaGlsZHJlbignLmpzdHJlZS1jaGlsZHJlbicpWzBdO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChvKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0JCh0aGlzLl9maXJzdENoaWxkKG8pKS5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5mb2N1cygpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSA0MDpcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBkb3duXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdFxcdFxcdFxcdFxcdFxcdG8gPSB0aGlzLmdldF9uZXh0X2RvbShlLmN1cnJlbnRUYXJnZXQpO1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChvICYmIG8ubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0by5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5mb2N1cygpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRjYXNlIDEwNjpcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBhcmlhIGRlZmluZXMgKiBvbiBudW1wYWQgYXMgb3Blbl9hbGwgLSBub3QgdmVyeSBjb21tb25cXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLm9wZW5fYWxsKCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAzNjpcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBob21lXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdFxcdFxcdFxcdFxcdFxcdG8gPSB0aGlzLl9maXJzdENoaWxkKHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpWzBdKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAobykge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdCQobykuY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuZmlsdGVyKCc6dmlzaWJsZScpLmZvY3VzKCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdGNhc2UgMzU6XFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gZW5kXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuZWxlbWVudC5maW5kKCcuanN0cmVlLWFuY2hvcicpLmZpbHRlcignOnZpc2libGUnKS5sYXN0KCkuZm9jdXMoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRjYXNlIDExMzpcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBmMiAtIHNhZmUgdG8gaW5jbHVkZSAtIGlmIGNoZWNrX2NhbGxiYWNrIGlzIGZhbHNlIGl0IHdpbGwgZmFpbFxcblxcdFxcdFxcdFxcdFxcdFxcdGUucHJldmVudERlZmF1bHQoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLmVkaXQoZS5jdXJyZW50VGFyZ2V0KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRkZWZhdWx0OlxcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdC8qIVxcbiAgICAgLy8gZGVsZXRlXFxuICAgICBjYXNlIDQ2OlxcbiAgICAgXFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgXFx0byA9IHRoaXMuZ2V0X25vZGUoZS5jdXJyZW50VGFyZ2V0KTtcXG4gICAgIFxcdGlmKG8gJiYgby5pZCAmJiBvLmlkICE9PSAkLmpzdHJlZS5yb290KSB7XFxuICAgICBcXHRcXHRvID0gdGhpcy5pc19zZWxlY3RlZChvKSA/IHRoaXMuZ2V0X3NlbGVjdGVkKCkgOiBvO1xcbiAgICAgXFx0XFx0dGhpcy5kZWxldGVfbm9kZShvKTtcXG4gICAgIFxcdH1cXG4gICAgIFxcdGJyZWFrO1xcbiAgICAgXFx0Ki9cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSwgdGhpcykpLm9uKFxcXCJsb2FkX25vZGUuanN0cmVlXFxcIiwgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xcblxcdFxcdFxcdFxcdGlmIChkYXRhLnN0YXR1cykge1xcblxcdFxcdFxcdFxcdFxcdGlmIChkYXRhLm5vZGUuaWQgPT09ICQuanN0cmVlLnJvb3QgJiYgIXRoaXMuX2RhdGEuY29yZS5sb2FkZWQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl9kYXRhLmNvcmUubG9hZGVkID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAodGhpcy5fZmlyc3RDaGlsZCh0aGlzLmdldF9jb250YWluZXJfdWwoKVswXSkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLmVsZW1lbnQuYXR0cignYXJpYS1hY3RpdmVkZXNjZW5kYW50JywgdGhpcy5fZmlyc3RDaGlsZCh0aGlzLmdldF9jb250YWluZXJfdWwoKVswXSkuaWQpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHQvKipcXG4gICAgICAgKiB0cmlnZ2VyZWQgYWZ0ZXIgdGhlIHJvb3Qgbm9kZSBpcyBsb2FkZWQgZm9yIHRoZSBmaXJzdCB0aW1lXFxuICAgICAgICogQGV2ZW50XFxuICAgICAgICogQG5hbWUgbG9hZGVkLmpzdHJlZVxcbiAgICAgICAqL1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMudHJpZ2dlcihcXFwibG9hZGVkXFxcIik7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmICghdGhpcy5fZGF0YS5jb3JlLnJlYWR5KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0c2V0VGltZW91dCgkLnByb3h5KGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAodGhpcy5lbGVtZW50ICYmICF0aGlzLmdldF9jb250YWluZXJfdWwoKS5maW5kKCcuanN0cmVlLWxvYWRpbmcnKS5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl9kYXRhLmNvcmUucmVhZHkgPSB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICh0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKHRoaXMuc2V0dGluZ3MuY29yZS5leHBhbmRfc2VsZWN0ZWRfb25sb2FkKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIHRtcCA9IFtdLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdCAgICBpLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdCAgICBqO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGZvciAoaSA9IDAsIGogPSB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dG1wID0gdG1wLmNvbmNhdCh0aGlzLl9tb2RlbC5kYXRhW3RoaXMuX2RhdGEuY29yZS5zZWxlY3RlZFtpXV0ucGFyZW50cyk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRtcCA9ICQudmFrYXRhLmFycmF5X3VuaXF1ZSh0bXApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGZvciAoaSA9IDAsIGogPSB0bXAubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5vcGVuX25vZGUodG1wW2ldLCBmYWxzZSwgMCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLnRyaWdnZXIoJ2NoYW5nZWQnLCB7ICdhY3Rpb24nOiAncmVhZHknLCAnc2VsZWN0ZWQnOiB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQgfSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8qKlxcbiAgICAgICAgICogdHJpZ2dlcmVkIGFmdGVyIGFsbCBub2RlcyBhcmUgZmluaXNoZWQgbG9hZGluZ1xcbiAgICAgICAgICogQGV2ZW50XFxuICAgICAgICAgKiBAbmFtZSByZWFkeS5qc3RyZWVcXG4gICAgICAgICAqL1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoaXMudHJpZ2dlcihcXFwicmVhZHlcXFwiKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSwgdGhpcyksIDApO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSwgdGhpcykpXFxuXFx0XFx0XFx0Ly8gcXVpY2sgc2VhcmNoaW5nIHdoZW4gdGhlIHRyZWUgaXMgZm9jdXNlZFxcblxcdFxcdFxcdC5vbigna2V5cHJlc3MuanN0cmVlJywgJC5wcm94eShmdW5jdGlvbiAoZSkge1xcblxcdFxcdFxcdFxcdGlmIChlLnRhcmdldC50YWdOYW1lICYmIGUudGFyZ2V0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXFxcImlucHV0XFxcIikge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRpZiAodG91dCkge1xcblxcdFxcdFxcdFxcdFxcdGNsZWFyVGltZW91dCh0b3V0KTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0dG91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdHdvcmQgPSAnJztcXG5cXHRcXHRcXHRcXHR9LCA1MDApO1xcblxcblxcdFxcdFxcdFxcdHZhciBjaHIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGUud2hpY2gpLnRvTG93ZXJDYXNlKCksXFxuXFx0XFx0XFx0XFx0ICAgIGNvbCA9IHRoaXMuZWxlbWVudC5maW5kKCcuanN0cmVlLWFuY2hvcicpLmZpbHRlcignOnZpc2libGUnKSxcXG5cXHRcXHRcXHRcXHQgICAgaW5kID0gY29sLmluZGV4KGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIHx8IDAsXFxuXFx0XFx0XFx0XFx0ICAgIGVuZCA9IGZhbHNlO1xcblxcdFxcdFxcdFxcdHdvcmQgKz0gY2hyO1xcblxcblxcdFxcdFxcdFxcdC8vIG1hdGNoIGZvciB3aG9sZSB3b3JkIGZyb20gY3VycmVudCBub2RlIGRvd24gKGluY2x1ZGluZyB0aGUgY3VycmVudCBub2RlKVxcblxcdFxcdFxcdFxcdGlmICh3b3JkLmxlbmd0aCA+IDEpIHtcXG5cXHRcXHRcXHRcXHRcXHRjb2wuc2xpY2UoaW5kKS5lYWNoKCQucHJveHkoZnVuY3Rpb24gKGksIHYpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoJCh2KS50ZXh0KCkudG9Mb3dlckNhc2UoKS5pbmRleE9mKHdvcmQpID09PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0JCh2KS5mb2N1cygpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGVuZCA9IHRydWU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9LCB0aGlzKSk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGVuZCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gbWF0Y2ggZm9yIHdob2xlIHdvcmQgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0cmVlXFxuXFx0XFx0XFx0XFx0XFx0Y29sLnNsaWNlKDAsIGluZCkuZWFjaCgkLnByb3h5KGZ1bmN0aW9uIChpLCB2KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCQodikudGV4dCgpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZih3b3JkKSA9PT0gMCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdCQodikuZm9jdXMoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRlbmQgPSB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fSwgdGhpcykpO1xcblxcdFxcdFxcdFxcdFxcdGlmIChlbmQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHQvLyBsaXN0IG5vZGVzIHRoYXQgc3RhcnQgd2l0aCB0aGF0IGxldHRlciAob25seSBpZiB3b3JkIGNvbnNpc3RzIG9mIGEgc2luZ2xlIGNoYXIpXFxuXFx0XFx0XFx0XFx0aWYgKG5ldyBSZWdFeHAoJ14nICsgY2hyLnJlcGxhY2UoL1stXFxcXC9cXFxcXFxcXF4kKis/LigpfFtcXFxcXXt9XS9nLCAnXFxcXFxcXFwkJicpICsgJyskJykudGVzdCh3b3JkKSkge1xcblxcdFxcdFxcdFxcdFxcdC8vIHNlYXJjaCBmb3IgdGhlIG5leHQgbm9kZSBzdGFydGluZyB3aXRoIHRoYXQgbGV0dGVyXFxuXFx0XFx0XFx0XFx0XFx0Y29sLnNsaWNlKGluZCArIDEpLmVhY2goJC5wcm94eShmdW5jdGlvbiAoaSwgdikge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICgkKHYpLnRleHQoKS50b0xvd2VyQ2FzZSgpLmNoYXJBdCgwKSA9PT0gY2hyKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0JCh2KS5mb2N1cygpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGVuZCA9IHRydWU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9LCB0aGlzKSk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGVuZCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gc2VhcmNoIGZyb20gdGhlIGJlZ2lubmluZ1xcblxcdFxcdFxcdFxcdFxcdGNvbC5zbGljZSgwLCBpbmQgKyAxKS5lYWNoKCQucHJveHkoZnVuY3Rpb24gKGksIHYpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoJCh2KS50ZXh0KCkudG9Mb3dlckNhc2UoKS5jaGFyQXQoMCkgPT09IGNocikge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdCQodikuZm9jdXMoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRlbmQgPSB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fSwgdGhpcykpO1xcblxcdFxcdFxcdFxcdFxcdGlmIChlbmQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LCB0aGlzKSlcXG5cXHRcXHRcXHQvLyBUSEVNRSBSRUxBVEVEXFxuXFx0XFx0XFx0Lm9uKFxcXCJpbml0LmpzdHJlZVxcXCIsICQucHJveHkoZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdHZhciBzID0gdGhpcy5zZXR0aW5ncy5jb3JlLnRoZW1lcztcXG5cXHRcXHRcXHRcXHR0aGlzLl9kYXRhLmNvcmUudGhlbWVzLmRvdHMgPSBzLmRvdHM7XFxuXFx0XFx0XFx0XFx0dGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5zdHJpcGVzID0gcy5zdHJpcGVzO1xcblxcdFxcdFxcdFxcdHRoaXMuX2RhdGEuY29yZS50aGVtZXMuaWNvbnMgPSBzLmljb25zO1xcblxcdFxcdFxcdFxcdHRoaXMuX2RhdGEuY29yZS50aGVtZXMuZWxsaXBzaXMgPSBzLmVsbGlwc2lzO1xcblxcdFxcdFxcdFxcdHRoaXMuc2V0X3RoZW1lKHMubmFtZSB8fCBcXFwiZGVmYXVsdFxcXCIsIHMudXJsKTtcXG5cXHRcXHRcXHRcXHR0aGlzLnNldF90aGVtZV92YXJpYW50KHMudmFyaWFudCk7XFxuXFx0XFx0XFx0fSwgdGhpcykpLm9uKFxcXCJsb2FkaW5nLmpzdHJlZVxcXCIsICQucHJveHkoZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdHRoaXNbdGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5kb3RzID8gXFxcInNob3dfZG90c1xcXCIgOiBcXFwiaGlkZV9kb3RzXFxcIl0oKTtcXG5cXHRcXHRcXHRcXHR0aGlzW3RoaXMuX2RhdGEuY29yZS50aGVtZXMuaWNvbnMgPyBcXFwic2hvd19pY29uc1xcXCIgOiBcXFwiaGlkZV9pY29uc1xcXCJdKCk7XFxuXFx0XFx0XFx0XFx0dGhpc1t0aGlzLl9kYXRhLmNvcmUudGhlbWVzLnN0cmlwZXMgPyBcXFwic2hvd19zdHJpcGVzXFxcIiA6IFxcXCJoaWRlX3N0cmlwZXNcXFwiXSgpO1xcblxcdFxcdFxcdFxcdHRoaXNbdGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5lbGxpcHNpcyA/IFxcXCJzaG93X2VsbGlwc2lzXFxcIiA6IFxcXCJoaWRlX2VsbGlwc2lzXFxcIl0oKTtcXG5cXHRcXHRcXHR9LCB0aGlzKSkub24oJ2JsdXIuanN0cmVlJywgJy5qc3RyZWUtYW5jaG9yJywgJC5wcm94eShmdW5jdGlvbiAoZSkge1xcblxcdFxcdFxcdFxcdHRoaXMuX2RhdGEuY29yZS5mb2N1c2VkID0gbnVsbDtcXG5cXHRcXHRcXHRcXHQkKGUuY3VycmVudFRhcmdldCkuZmlsdGVyKCcuanN0cmVlLWhvdmVyZWQnKS5tb3VzZWxlYXZlKCk7XFxuXFx0XFx0XFx0XFx0dGhpcy5lbGVtZW50LmF0dHIoJ3RhYmluZGV4JywgJzAnKTtcXG5cXHRcXHRcXHR9LCB0aGlzKSkub24oJ2ZvY3VzLmpzdHJlZScsICcuanN0cmVlLWFuY2hvcicsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcXG5cXHRcXHRcXHRcXHR2YXIgdG1wID0gdGhpcy5nZXRfbm9kZShlLmN1cnJlbnRUYXJnZXQpO1xcblxcdFxcdFxcdFxcdGlmICh0bXAgJiYgdG1wLmlkKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fZGF0YS5jb3JlLmZvY3VzZWQgPSB0bXAuaWQ7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHRoaXMuZWxlbWVudC5maW5kKCcuanN0cmVlLWhvdmVyZWQnKS5ub3QoZS5jdXJyZW50VGFyZ2V0KS5tb3VzZWxlYXZlKCk7XFxuXFx0XFx0XFx0XFx0JChlLmN1cnJlbnRUYXJnZXQpLm1vdXNlZW50ZXIoKTtcXG5cXHRcXHRcXHRcXHR0aGlzLmVsZW1lbnQuYXR0cigndGFiaW5kZXgnLCAnLTEnKTtcXG5cXHRcXHRcXHR9LCB0aGlzKSkub24oJ2ZvY3VzLmpzdHJlZScsICQucHJveHkoZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdGlmICgrbmV3IERhdGUoKSAtIHdhc19jbGljayA+IDUwMCAmJiAhdGhpcy5fZGF0YS5jb3JlLmZvY3VzZWQpIHtcXG5cXHRcXHRcXHRcXHRcXHR3YXNfY2xpY2sgPSAwO1xcblxcdFxcdFxcdFxcdFxcdHZhciBhY3QgPSB0aGlzLmdldF9ub2RlKHRoaXMuZWxlbWVudC5hdHRyKCdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnKSwgdHJ1ZSk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGFjdCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGFjdC5maW5kKCc+IC5qc3RyZWUtYW5jaG9yJykuZm9jdXMoKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sIHRoaXMpKS5vbignbW91c2VlbnRlci5qc3RyZWUnLCAnLmpzdHJlZS1hbmNob3InLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5ob3Zlcl9ub2RlKGUuY3VycmVudFRhcmdldCk7XFxuXFx0XFx0XFx0fSwgdGhpcykpLm9uKCdtb3VzZWxlYXZlLmpzdHJlZScsICcuanN0cmVlLWFuY2hvcicsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLmRlaG92ZXJfbm9kZShlLmN1cnJlbnRUYXJnZXQpO1xcblxcdFxcdFxcdH0sIHRoaXMpKTtcXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogcGFydCBvZiB0aGUgZGVzdHJveWluZyBvZiBhbiBpbnN0YW5jZS4gVXNlZCBpbnRlcm5hbGx5LlxcbiAgICogQHByaXZhdGVcXG4gICAqIEBuYW1lIHVuYmluZCgpXFxuICAgKi9cXG5cXHRcXHR1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCgpIHtcXG5cXHRcXHRcXHR0aGlzLmVsZW1lbnQub2ZmKCcuanN0cmVlJyk7XFxuXFx0XFx0XFx0JChkb2N1bWVudCkub2ZmKCcuanN0cmVlLScgKyB0aGlzLl9pZCk7XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIHRyaWdnZXIgYW4gZXZlbnQuIFVzZWQgaW50ZXJuYWxseS5cXG4gICAqIEBwcml2YXRlXFxuICAgKiBAbmFtZSB0cmlnZ2VyKGV2IFssIGRhdGFdKVxcbiAgICogQHBhcmFtICB7U3RyaW5nfSBldiB0aGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gdHJpZ2dlclxcbiAgICogQHBhcmFtICB7T2JqZWN0fSBkYXRhIGFkZGl0aW9uYWwgZGF0YSB0byBwYXNzIHdpdGggdGhlIGV2ZW50XFxuICAgKi9cXG5cXHRcXHR0cmlnZ2VyOiBmdW5jdGlvbiB0cmlnZ2VyKGV2LCBkYXRhKSB7XFxuXFx0XFx0XFx0aWYgKCFkYXRhKSB7XFxuXFx0XFx0XFx0XFx0ZGF0YSA9IHt9O1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRkYXRhLmluc3RhbmNlID0gdGhpcztcXG5cXHRcXHRcXHR0aGlzLmVsZW1lbnQudHJpZ2dlckhhbmRsZXIoZXYucmVwbGFjZSgnLmpzdHJlZScsICcnKSArICcuanN0cmVlJywgZGF0YSk7XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIHJldHVybnMgdGhlIGpRdWVyeSBleHRlbmRlZCBpbnN0YW5jZSBjb250YWluZXJcXG4gICAqIEBuYW1lIGdldF9jb250YWluZXIoKVxcbiAgICogQHJldHVybiB7alF1ZXJ5fVxcbiAgICovXFxuXFx0XFx0Z2V0X2NvbnRhaW5lcjogZnVuY3Rpb24gZ2V0X2NvbnRhaW5lcigpIHtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5lbGVtZW50O1xcblxcdFxcdH0sXFxuXFx0XFx0LyoqXFxuICAgKiByZXR1cm5zIHRoZSBqUXVlcnkgZXh0ZW5kZWQgbWFpbiBVTCBub2RlIGluc2lkZSB0aGUgaW5zdGFuY2UgY29udGFpbmVyLiBVc2VkIGludGVybmFsbHkuXFxuICAgKiBAcHJpdmF0ZVxcbiAgICogQG5hbWUgZ2V0X2NvbnRhaW5lcl91bCgpXFxuICAgKiBAcmV0dXJuIHtqUXVlcnl9XFxuICAgKi9cXG5cXHRcXHRnZXRfY29udGFpbmVyX3VsOiBmdW5jdGlvbiBnZXRfY29udGFpbmVyX3VsKCkge1xcblxcdFxcdFxcdHJldHVybiB0aGlzLmVsZW1lbnQuY2hpbGRyZW4oXFxcIi5qc3RyZWUtY2hpbGRyZW5cXFwiKS5maXJzdCgpO1xcblxcdFxcdH0sXFxuXFx0XFx0LyoqXFxuICAgKiBnZXRzIHN0cmluZyByZXBsYWNlbWVudHMgKGxvY2FsaXphdGlvbikuIFVzZWQgaW50ZXJuYWxseS5cXG4gICAqIEBwcml2YXRlXFxuICAgKiBAbmFtZSBnZXRfc3RyaW5nKGtleSlcXG4gICAqIEBwYXJhbSAge1N0cmluZ30ga2V5XFxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XFxuICAgKi9cXG5cXHRcXHRnZXRfc3RyaW5nOiBmdW5jdGlvbiBnZXRfc3RyaW5nKGtleSkge1xcblxcdFxcdFxcdHZhciBhID0gdGhpcy5zZXR0aW5ncy5jb3JlLnN0cmluZ3M7XFxuXFx0XFx0XFx0aWYgKCQuaXNGdW5jdGlvbihhKSkge1xcblxcdFxcdFxcdFxcdHJldHVybiBhLmNhbGwodGhpcywga2V5KTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKGEgJiYgYVtrZXldKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGFba2V5XTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIGtleTtcXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogZ2V0cyB0aGUgZmlyc3QgY2hpbGQgb2YgYSBET00gbm9kZS4gVXNlZCBpbnRlcm5hbGx5LlxcbiAgICogQHByaXZhdGVcXG4gICAqIEBuYW1lIF9maXJzdENoaWxkKGRvbSlcXG4gICAqIEBwYXJhbSAge0RPTUVsZW1lbnR9IGRvbVxcbiAgICogQHJldHVybiB7RE9NRWxlbWVudH1cXG4gICAqL1xcblxcdFxcdF9maXJzdENoaWxkOiBmdW5jdGlvbiBfZmlyc3RDaGlsZChkb20pIHtcXG5cXHRcXHRcXHRkb20gPSBkb20gPyBkb20uZmlyc3RDaGlsZCA6IG51bGw7XFxuXFx0XFx0XFx0d2hpbGUgKGRvbSAhPT0gbnVsbCAmJiBkb20ubm9kZVR5cGUgIT09IDEpIHtcXG5cXHRcXHRcXHRcXHRkb20gPSBkb20ubmV4dFNpYmxpbmc7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiBkb207XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIGdldHMgdGhlIG5leHQgc2libGluZyBvZiBhIERPTSBub2RlLiBVc2VkIGludGVybmFsbHkuXFxuICAgKiBAcHJpdmF0ZVxcbiAgICogQG5hbWUgX25leHRTaWJsaW5nKGRvbSlcXG4gICAqIEBwYXJhbSAge0RPTUVsZW1lbnR9IGRvbVxcbiAgICogQHJldHVybiB7RE9NRWxlbWVudH1cXG4gICAqL1xcblxcdFxcdF9uZXh0U2libGluZzogZnVuY3Rpb24gX25leHRTaWJsaW5nKGRvbSkge1xcblxcdFxcdFxcdGRvbSA9IGRvbSA/IGRvbS5uZXh0U2libGluZyA6IG51bGw7XFxuXFx0XFx0XFx0d2hpbGUgKGRvbSAhPT0gbnVsbCAmJiBkb20ubm9kZVR5cGUgIT09IDEpIHtcXG5cXHRcXHRcXHRcXHRkb20gPSBkb20ubmV4dFNpYmxpbmc7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiBkb207XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIGdldHMgdGhlIHByZXZpb3VzIHNpYmxpbmcgb2YgYSBET00gbm9kZS4gVXNlZCBpbnRlcm5hbGx5LlxcbiAgICogQHByaXZhdGVcXG4gICAqIEBuYW1lIF9wcmV2aW91c1NpYmxpbmcoZG9tKVxcbiAgICogQHBhcmFtICB7RE9NRWxlbWVudH0gZG9tXFxuICAgKiBAcmV0dXJuIHtET01FbGVtZW50fVxcbiAgICovXFxuXFx0XFx0X3ByZXZpb3VzU2libGluZzogZnVuY3Rpb24gX3ByZXZpb3VzU2libGluZyhkb20pIHtcXG5cXHRcXHRcXHRkb20gPSBkb20gPyBkb20ucHJldmlvdXNTaWJsaW5nIDogbnVsbDtcXG5cXHRcXHRcXHR3aGlsZSAoZG9tICE9PSBudWxsICYmIGRvbS5ub2RlVHlwZSAhPT0gMSkge1xcblxcdFxcdFxcdFxcdGRvbSA9IGRvbS5wcmV2aW91c1NpYmxpbmc7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiBkb207XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIGdldCB0aGUgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBhIG5vZGUgKG9yIHRoZSBhY3R1YWwgalF1ZXJ5IGV4dGVuZGVkIERPTSBub2RlKSBieSB1c2luZyBhbnkgaW5wdXQgKGNoaWxkIERPTSBlbGVtZW50LCBJRCBzdHJpbmcsIHNlbGVjdG9yLCBldGMpXFxuICAgKiBAbmFtZSBnZXRfbm9kZShvYmogWywgYXNfZG9tXSlcXG4gICAqIEBwYXJhbSAge21peGVkfSBvYmpcXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IGFzX2RvbVxcbiAgICogQHJldHVybiB7T2JqZWN0fGpRdWVyeX1cXG4gICAqL1xcblxcdFxcdGdldF9ub2RlOiBmdW5jdGlvbiBnZXRfbm9kZShvYmosIGFzX2RvbSkge1xcblxcdFxcdFxcdGlmIChvYmogJiYgb2JqLmlkKSB7XFxuXFx0XFx0XFx0XFx0b2JqID0gb2JqLmlkO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR2YXIgZG9tO1xcblxcdFxcdFxcdHRyeSB7XFxuXFx0XFx0XFx0XFx0aWYgKHRoaXMuX21vZGVsLmRhdGFbb2JqXSkge1xcblxcdFxcdFxcdFxcdFxcdG9iaiA9IHRoaXMuX21vZGVsLmRhdGFbb2JqXTtcXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09IFxcXCJzdHJpbmdcXFwiICYmIHRoaXMuX21vZGVsLmRhdGFbb2JqLnJlcGxhY2UoL14jLywgJycpXSkge1xcblxcdFxcdFxcdFxcdFxcdG9iaiA9IHRoaXMuX21vZGVsLmRhdGFbb2JqLnJlcGxhY2UoL14jLywgJycpXTtcXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09IFxcXCJzdHJpbmdcXFwiICYmIChkb20gPSAkKCcjJyArIG9iai5yZXBsYWNlKCQuanN0cmVlLmlkcmVnZXgsICdcXFxcXFxcXCQmJyksIHRoaXMuZWxlbWVudCkpLmxlbmd0aCAmJiB0aGlzLl9tb2RlbC5kYXRhW2RvbS5jbG9zZXN0KCcuanN0cmVlLW5vZGUnKS5hdHRyKCdpZCcpXSkge1xcblxcdFxcdFxcdFxcdFxcdG9iaiA9IHRoaXMuX21vZGVsLmRhdGFbZG9tLmNsb3Nlc3QoJy5qc3RyZWUtbm9kZScpLmF0dHIoJ2lkJyldO1xcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoKGRvbSA9ICQob2JqLCB0aGlzLmVsZW1lbnQpKS5sZW5ndGggJiYgdGhpcy5fbW9kZWwuZGF0YVtkb20uY2xvc2VzdCgnLmpzdHJlZS1ub2RlJykuYXR0cignaWQnKV0pIHtcXG5cXHRcXHRcXHRcXHRcXHRvYmogPSB0aGlzLl9tb2RlbC5kYXRhW2RvbS5jbG9zZXN0KCcuanN0cmVlLW5vZGUnKS5hdHRyKCdpZCcpXTtcXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKChkb20gPSAkKG9iaiwgdGhpcy5lbGVtZW50KSkubGVuZ3RoICYmIGRvbS5oYXNDbGFzcygnanN0cmVlJykpIHtcXG5cXHRcXHRcXHRcXHRcXHRvYmogPSB0aGlzLl9tb2RlbC5kYXRhWyQuanN0cmVlLnJvb3RdO1xcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAoYXNfZG9tKSB7XFxuXFx0XFx0XFx0XFx0XFx0b2JqID0gb2JqLmlkID09PSAkLmpzdHJlZS5yb290ID8gdGhpcy5lbGVtZW50IDogJCgnIycgKyBvYmouaWQucmVwbGFjZSgkLmpzdHJlZS5pZHJlZ2V4LCAnXFxcXFxcXFwkJicpLCB0aGlzLmVsZW1lbnQpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRyZXR1cm4gb2JqO1xcblxcdFxcdFxcdH0gY2F0Y2ggKGV4KSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogZ2V0IHRoZSBwYXRoIHRvIGEgbm9kZSwgZWl0aGVyIGNvbnNpc3Rpbmcgb2Ygbm9kZSB0ZXh0cywgb3Igb2Ygbm9kZSBJRHMsIG9wdGlvbmFsbHkgZ2x1ZWQgdG9nZXRoZXIgKG90aGVyd2lzZSBhbiBhcnJheSlcXG4gICAqIEBuYW1lIGdldF9wYXRoKG9iaiBbLCBnbHVlLCBpZHNdKVxcbiAgICogQHBhcmFtICB7bWl4ZWR9IG9iaiB0aGUgbm9kZVxcbiAgICogQHBhcmFtICB7U3RyaW5nfSBnbHVlIGlmIHlvdSB3YW50IHRoZSBwYXRoIGFzIGEgc3RyaW5nIC0gcGFzcyB0aGUgZ2x1ZSBoZXJlIChmb3IgZXhhbXBsZSAnLycpLCBpZiBhIGZhbHN5IHZhbHVlIGlzIHN1cHBsaWVkIGhlcmUsIGFuIGFycmF5IGlzIHJldHVybmVkXFxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBpZHMgaWYgc2V0IHRvIHRydWUgYnVpbGQgdGhlIHBhdGggdXNpbmcgSUQsIG90aGVyd2lzZSBub2RlIHRleHQgaXMgdXNlZFxcbiAgICogQHJldHVybiB7bWl4ZWR9XFxuICAgKi9cXG5cXHRcXHRnZXRfcGF0aDogZnVuY3Rpb24gZ2V0X3BhdGgob2JqLCBnbHVlLCBpZHMpIHtcXG5cXHRcXHRcXHRvYmogPSBvYmoucGFyZW50cyA/IG9iaiA6IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXHRcXHRcXHRpZiAoIW9iaiB8fCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QgfHwgIW9iai5wYXJlbnRzKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR2YXIgaSxcXG5cXHRcXHRcXHQgICAgaixcXG5cXHRcXHRcXHQgICAgcCA9IFtdO1xcblxcdFxcdFxcdHAucHVzaChpZHMgPyBvYmouaWQgOiBvYmoudGV4dCk7XFxuXFx0XFx0XFx0Zm9yIChpID0gMCwgaiA9IG9iai5wYXJlbnRzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcblxcdFxcdFxcdFxcdHAucHVzaChpZHMgPyBvYmoucGFyZW50c1tpXSA6IHRoaXMuZ2V0X3RleHQob2JqLnBhcmVudHNbaV0pKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cCA9IHAucmV2ZXJzZSgpLnNsaWNlKDEpO1xcblxcdFxcdFxcdHJldHVybiBnbHVlID8gcC5qb2luKGdsdWUpIDogcDtcXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogZ2V0IHRoZSBuZXh0IHZpc2libGUgbm9kZSB0aGF0IGlzIGJlbG93IHRoZSBgb2JqYCBub2RlLiBJZiBgc3RyaWN0YCBpcyBzZXQgdG8gYHRydWVgIG9ubHkgc2libGluZyBub2RlcyBhcmUgcmV0dXJuZWQuXFxuICAgKiBAbmFtZSBnZXRfbmV4dF9kb20ob2JqIFssIHN0cmljdF0pXFxuICAgKiBAcGFyYW0gIHttaXhlZH0gb2JqXFxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBzdHJpY3RcXG4gICAqIEByZXR1cm4ge2pRdWVyeX1cXG4gICAqL1xcblxcdFxcdGdldF9uZXh0X2RvbTogZnVuY3Rpb24gZ2V0X25leHRfZG9tKG9iaiwgc3RyaWN0KSB7XFxuXFx0XFx0XFx0dmFyIHRtcDtcXG5cXHRcXHRcXHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSk7XFxuXFx0XFx0XFx0aWYgKG9ialswXSA9PT0gdGhpcy5lbGVtZW50WzBdKSB7XFxuXFx0XFx0XFx0XFx0dG1wID0gdGhpcy5fZmlyc3RDaGlsZCh0aGlzLmdldF9jb250YWluZXJfdWwoKVswXSk7XFxuXFx0XFx0XFx0XFx0d2hpbGUgKHRtcCAmJiB0bXAub2Zmc2V0SGVpZ2h0ID09PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0dG1wID0gdGhpcy5fbmV4dFNpYmxpbmcodG1wKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRtcCA/ICQodG1wKSA6IGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoIW9iaiB8fCAhb2JqLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKHN0cmljdCkge1xcblxcdFxcdFxcdFxcdHRtcCA9IG9ialswXTtcXG5cXHRcXHRcXHRcXHRkbyB7XFxuXFx0XFx0XFx0XFx0XFx0dG1wID0gdGhpcy5fbmV4dFNpYmxpbmcodG1wKTtcXG5cXHRcXHRcXHRcXHR9IHdoaWxlICh0bXAgJiYgdG1wLm9mZnNldEhlaWdodCA9PT0gMCk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRtcCA/ICQodG1wKSA6IGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAob2JqLmhhc0NsYXNzKFxcXCJqc3RyZWUtb3BlblxcXCIpKSB7XFxuXFx0XFx0XFx0XFx0dG1wID0gdGhpcy5fZmlyc3RDaGlsZChvYmouY2hpbGRyZW4oJy5qc3RyZWUtY2hpbGRyZW4nKVswXSk7XFxuXFx0XFx0XFx0XFx0d2hpbGUgKHRtcCAmJiB0bXAub2Zmc2V0SGVpZ2h0ID09PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0dG1wID0gdGhpcy5fbmV4dFNpYmxpbmcodG1wKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aWYgKHRtcCAhPT0gbnVsbCkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiAkKHRtcCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR0bXAgPSBvYmpbMF07XFxuXFx0XFx0XFx0ZG8ge1xcblxcdFxcdFxcdFxcdHRtcCA9IHRoaXMuX25leHRTaWJsaW5nKHRtcCk7XFxuXFx0XFx0XFx0fSB3aGlsZSAodG1wICYmIHRtcC5vZmZzZXRIZWlnaHQgPT09IDApO1xcblxcdFxcdFxcdGlmICh0bXAgIT09IG51bGwpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gJCh0bXApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gb2JqLnBhcmVudHNVbnRpbChcXFwiLmpzdHJlZVxcXCIsIFxcXCIuanN0cmVlLW5vZGVcXFwiKS5uZXh0QWxsKFxcXCIuanN0cmVlLW5vZGU6dmlzaWJsZVxcXCIpLmZpcnN0KCk7XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIGdldCB0aGUgcHJldmlvdXMgdmlzaWJsZSBub2RlIHRoYXQgaXMgYWJvdmUgdGhlIGBvYmpgIG5vZGUuIElmIGBzdHJpY3RgIGlzIHNldCB0byBgdHJ1ZWAgb25seSBzaWJsaW5nIG5vZGVzIGFyZSByZXR1cm5lZC5cXG4gICAqIEBuYW1lIGdldF9wcmV2X2RvbShvYmogWywgc3RyaWN0XSlcXG4gICAqIEBwYXJhbSAge21peGVkfSBvYmpcXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IHN0cmljdFxcbiAgICogQHJldHVybiB7alF1ZXJ5fVxcbiAgICovXFxuXFx0XFx0Z2V0X3ByZXZfZG9tOiBmdW5jdGlvbiBnZXRfcHJldl9kb20ob2JqLCBzdHJpY3QpIHtcXG5cXHRcXHRcXHR2YXIgdG1wO1xcblxcdFxcdFxcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKTtcXG5cXHRcXHRcXHRpZiAob2JqWzBdID09PSB0aGlzLmVsZW1lbnRbMF0pIHtcXG5cXHRcXHRcXHRcXHR0bXAgPSB0aGlzLmdldF9jb250YWluZXJfdWwoKVswXS5sYXN0Q2hpbGQ7XFxuXFx0XFx0XFx0XFx0d2hpbGUgKHRtcCAmJiB0bXAub2Zmc2V0SGVpZ2h0ID09PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0dG1wID0gdGhpcy5fcHJldmlvdXNTaWJsaW5nKHRtcCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHJldHVybiB0bXAgPyAkKHRtcCkgOiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKCFvYmogfHwgIW9iai5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmIChzdHJpY3QpIHtcXG5cXHRcXHRcXHRcXHR0bXAgPSBvYmpbMF07XFxuXFx0XFx0XFx0XFx0ZG8ge1xcblxcdFxcdFxcdFxcdFxcdHRtcCA9IHRoaXMuX3ByZXZpb3VzU2libGluZyh0bXApO1xcblxcdFxcdFxcdFxcdH0gd2hpbGUgKHRtcCAmJiB0bXAub2Zmc2V0SGVpZ2h0ID09PSAwKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdG1wID8gJCh0bXApIDogZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHRtcCA9IG9ialswXTtcXG5cXHRcXHRcXHRkbyB7XFxuXFx0XFx0XFx0XFx0dG1wID0gdGhpcy5fcHJldmlvdXNTaWJsaW5nKHRtcCk7XFxuXFx0XFx0XFx0fSB3aGlsZSAodG1wICYmIHRtcC5vZmZzZXRIZWlnaHQgPT09IDApO1xcblxcdFxcdFxcdGlmICh0bXAgIT09IG51bGwpIHtcXG5cXHRcXHRcXHRcXHRvYmogPSAkKHRtcCk7XFxuXFx0XFx0XFx0XFx0d2hpbGUgKG9iai5oYXNDbGFzcyhcXFwianN0cmVlLW9wZW5cXFwiKSkge1xcblxcdFxcdFxcdFxcdFxcdG9iaiA9IG9iai5jaGlsZHJlbihcXFwiLmpzdHJlZS1jaGlsZHJlblxcXCIpLmZpcnN0KCkuY2hpbGRyZW4oXFxcIi5qc3RyZWUtbm9kZTp2aXNpYmxlOmxhc3RcXFwiKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0cmV0dXJuIG9iajtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0dG1wID0gb2JqWzBdLnBhcmVudE5vZGUucGFyZW50Tm9kZTtcXG5cXHRcXHRcXHRyZXR1cm4gdG1wICYmIHRtcC5jbGFzc05hbWUgJiYgdG1wLmNsYXNzTmFtZS5pbmRleE9mKCdqc3RyZWUtbm9kZScpICE9PSAtMSA/ICQodG1wKSA6IGZhbHNlO1xcblxcdFxcdH0sXFxuXFx0XFx0LyoqXFxuICAgKiBnZXQgdGhlIHBhcmVudCBJRCBvZiBhIG5vZGVcXG4gICAqIEBuYW1lIGdldF9wYXJlbnQob2JqKVxcbiAgICogQHBhcmFtICB7bWl4ZWR9IG9ialxcbiAgICogQHJldHVybiB7U3RyaW5nfVxcbiAgICovXFxuXFx0XFx0Z2V0X3BhcmVudDogZnVuY3Rpb24gZ2V0X3BhcmVudChvYmopIHtcXG5cXHRcXHRcXHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XFxuXFx0XFx0XFx0aWYgKCFvYmogfHwgb2JqLmlkID09PSAkLmpzdHJlZS5yb290KSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gb2JqLnBhcmVudDtcXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogZ2V0IGEgalF1ZXJ5IGNvbGxlY3Rpb24gb2YgYWxsIHRoZSBjaGlsZHJlbiBvZiBhIG5vZGUgKG5vZGUgbXVzdCBiZSByZW5kZXJlZClcXG4gICAqIEBuYW1lIGdldF9jaGlsZHJlbl9kb20ob2JqKVxcbiAgICogQHBhcmFtICB7bWl4ZWR9IG9ialxcbiAgICogQHJldHVybiB7alF1ZXJ5fVxcbiAgICovXFxuXFx0XFx0Z2V0X2NoaWxkcmVuX2RvbTogZnVuY3Rpb24gZ2V0X2NoaWxkcmVuX2RvbShvYmopIHtcXG5cXHRcXHRcXHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSk7XFxuXFx0XFx0XFx0aWYgKG9ialswXSA9PT0gdGhpcy5lbGVtZW50WzBdKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpLmNoaWxkcmVuKFxcXCIuanN0cmVlLW5vZGVcXFwiKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKCFvYmogfHwgIW9iai5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiBvYmouY2hpbGRyZW4oXFxcIi5qc3RyZWUtY2hpbGRyZW5cXFwiKS5jaGlsZHJlbihcXFwiLmpzdHJlZS1ub2RlXFxcIik7XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIGNoZWNrcyBpZiBhIG5vZGUgaGFzIGNoaWxkcmVuXFxuICAgKiBAbmFtZSBpc19wYXJlbnQob2JqKVxcbiAgICogQHBhcmFtICB7bWl4ZWR9IG9ialxcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cXG4gICAqL1xcblxcdFxcdGlzX3BhcmVudDogZnVuY3Rpb24gaXNfcGFyZW50KG9iaikge1xcblxcdFxcdFxcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXHRcXHRcXHRyZXR1cm4gb2JqICYmIChvYmouc3RhdGUubG9hZGVkID09PSBmYWxzZSB8fCBvYmouY2hpbGRyZW4ubGVuZ3RoID4gMCk7XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIGNoZWNrcyBpZiBhIG5vZGUgaXMgbG9hZGVkIChpdHMgY2hpbGRyZW4gYXJlIGF2YWlsYWJsZSlcXG4gICAqIEBuYW1lIGlzX2xvYWRlZChvYmopXFxuICAgKiBAcGFyYW0gIHttaXhlZH0gb2JqXFxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxcbiAgICovXFxuXFx0XFx0aXNfbG9hZGVkOiBmdW5jdGlvbiBpc19sb2FkZWQob2JqKSB7XFxuXFx0XFx0XFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xcblxcdFxcdFxcdHJldHVybiBvYmogJiYgb2JqLnN0YXRlLmxvYWRlZDtcXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogY2hlY2sgaWYgYSBub2RlIGlzIGN1cnJlbnRseSBsb2FkaW5nIChmZXRjaGluZyBjaGlsZHJlbilcXG4gICAqIEBuYW1lIGlzX2xvYWRpbmcob2JqKVxcbiAgICogQHBhcmFtICB7bWl4ZWR9IG9ialxcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cXG4gICAqL1xcblxcdFxcdGlzX2xvYWRpbmc6IGZ1bmN0aW9uIGlzX2xvYWRpbmcob2JqKSB7XFxuXFx0XFx0XFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xcblxcdFxcdFxcdHJldHVybiBvYmogJiYgb2JqLnN0YXRlICYmIG9iai5zdGF0ZS5sb2FkaW5nO1xcblxcdFxcdH0sXFxuXFx0XFx0LyoqXFxuICAgKiBjaGVjayBpZiBhIG5vZGUgaXMgb3BlbmVkXFxuICAgKiBAbmFtZSBpc19vcGVuKG9iailcXG4gICAqIEBwYXJhbSAge21peGVkfSBvYmpcXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XFxuICAgKi9cXG5cXHRcXHRpc19vcGVuOiBmdW5jdGlvbiBpc19vcGVuKG9iaikge1xcblxcdFxcdFxcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXHRcXHRcXHRyZXR1cm4gb2JqICYmIG9iai5zdGF0ZS5vcGVuZWQ7XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIGNoZWNrIGlmIGEgbm9kZSBpcyBpbiBhIGNsb3NlZCBzdGF0ZVxcbiAgICogQG5hbWUgaXNfY2xvc2VkKG9iailcXG4gICAqIEBwYXJhbSAge21peGVkfSBvYmpcXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XFxuICAgKi9cXG5cXHRcXHRpc19jbG9zZWQ6IGZ1bmN0aW9uIGlzX2Nsb3NlZChvYmopIHtcXG5cXHRcXHRcXHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XFxuXFx0XFx0XFx0cmV0dXJuIG9iaiAmJiB0aGlzLmlzX3BhcmVudChvYmopICYmICFvYmouc3RhdGUub3BlbmVkO1xcblxcdFxcdH0sXFxuXFx0XFx0LyoqXFxuICAgKiBjaGVjayBpZiBhIG5vZGUgaGFzIG5vIGNoaWxkcmVuXFxuICAgKiBAbmFtZSBpc19sZWFmKG9iailcXG4gICAqIEBwYXJhbSAge21peGVkfSBvYmpcXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XFxuICAgKi9cXG5cXHRcXHRpc19sZWFmOiBmdW5jdGlvbiBpc19sZWFmKG9iaikge1xcblxcdFxcdFxcdHJldHVybiAhdGhpcy5pc19wYXJlbnQob2JqKTtcXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogbG9hZHMgYSBub2RlIChmZXRjaGVzIGl0cyBjaGlsZHJlbiB1c2luZyB0aGUgYGNvcmUuZGF0YWAgc2V0dGluZykuIE11bHRpcGxlIG5vZGVzIGNhbiBiZSBwYXNzZWQgdG8gYnkgdXNpbmcgYW4gYXJyYXkuXFxuICAgKiBAbmFtZSBsb2FkX25vZGUob2JqIFssIGNhbGxiYWNrXSlcXG4gICAqIEBwYXJhbSAge21peGVkfSBvYmpcXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSBjYWxsYmFjayBhIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIG9uY2UgbG9hZGluZyBpcyBjb21wbGV0ZSwgdGhlIGZ1bmN0aW9uIGlzIGV4ZWN1dGVkIGluIHRoZSBpbnN0YW5jZSdzIHNjb3BlIGFuZCByZWNlaXZlcyB0d28gYXJndW1lbnRzIC0gdGhlIG5vZGUgYW5kIGEgYm9vbGVhbiBzdGF0dXNcXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XFxuICAgKiBAdHJpZ2dlciBsb2FkX25vZGUuanN0cmVlXFxuICAgKi9cXG5cXHRcXHRsb2FkX25vZGU6IGZ1bmN0aW9uIGxvYWRfbm9kZShvYmosIGNhbGxiYWNrKSB7XFxuXFx0XFx0XFx0dmFyIGssIGwsIGksIGosIGM7XFxuXFx0XFx0XFx0aWYgKCQuaXNBcnJheShvYmopKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5fbG9hZF9ub2RlcyhvYmouc2xpY2UoKSwgY2FsbGJhY2spO1xcblxcdFxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XFxuXFx0XFx0XFx0aWYgKCFvYmopIHtcXG5cXHRcXHRcXHRcXHRpZiAoY2FsbGJhY2spIHtcXG5cXHRcXHRcXHRcXHRcXHRjYWxsYmFjay5jYWxsKHRoaXMsIG9iaiwgZmFsc2UpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdC8vIGlmKG9iai5zdGF0ZS5sb2FkaW5nKSB7IH0gLy8gdGhlIG5vZGUgaXMgYWxyZWFkeSBsb2FkaW5nIC0ganVzdCB3YWl0IGZvciBpdCB0byBsb2FkIGFuZCBpbnZva2UgY2FsbGJhY2s/IGJ1dCBpZiBjYWxsZWQgaW1wbGljaXRseSBpdCBzaG91bGQgYmUgbG9hZGVkIGFnYWluP1xcblxcdFxcdFxcdGlmIChvYmouc3RhdGUubG9hZGVkKSB7XFxuXFx0XFx0XFx0XFx0b2JqLnN0YXRlLmxvYWRlZCA9IGZhbHNlO1xcblxcdFxcdFxcdFxcdGZvciAoaSA9IDAsIGogPSBvYmoucGFyZW50cy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9tb2RlbC5kYXRhW29iai5wYXJlbnRzW2ldXS5jaGlsZHJlbl9kID0gJC52YWthdGEuYXJyYXlfZmlsdGVyKHRoaXMuX21vZGVsLmRhdGFbb2JqLnBhcmVudHNbaV1dLmNoaWxkcmVuX2QsIGZ1bmN0aW9uICh2KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuICQuaW5BcnJheSh2LCBvYmouY2hpbGRyZW5fZCkgPT09IC0xO1xcblxcdFxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRmb3IgKGsgPSAwLCBsID0gb2JqLmNoaWxkcmVuX2QubGVuZ3RoOyBrIDwgbDsgaysrKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHRoaXMuX21vZGVsLmRhdGFbb2JqLmNoaWxkcmVuX2Rba11dLnN0YXRlLnNlbGVjdGVkKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YyA9IHRydWU7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGRlbGV0ZSB0aGlzLl9tb2RlbC5kYXRhW29iai5jaGlsZHJlbl9kW2tdXTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aWYgKGMpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQgPSAkLnZha2F0YS5hcnJheV9maWx0ZXIodGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLCBmdW5jdGlvbiAodikge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiAkLmluQXJyYXkodiwgb2JqLmNoaWxkcmVuX2QpID09PSAtMTtcXG5cXHRcXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0b2JqLmNoaWxkcmVuID0gW107XFxuXFx0XFx0XFx0XFx0b2JqLmNoaWxkcmVuX2QgPSBbXTtcXG5cXHRcXHRcXHRcXHRpZiAoYykge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMudHJpZ2dlcignY2hhbmdlZCcsIHsgJ2FjdGlvbic6ICdsb2FkX25vZGUnLCAnbm9kZSc6IG9iaiwgJ3NlbGVjdGVkJzogdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkIH0pO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0b2JqLnN0YXRlLmZhaWxlZCA9IGZhbHNlO1xcblxcdFxcdFxcdG9iai5zdGF0ZS5sb2FkaW5nID0gdHJ1ZTtcXG5cXHRcXHRcXHR0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSkuYWRkQ2xhc3MoXFxcImpzdHJlZS1sb2FkaW5nXFxcIikuYXR0cignYXJpYS1idXN5JywgdHJ1ZSk7XFxuXFx0XFx0XFx0dGhpcy5fbG9hZF9ub2RlKG9iaiwgJC5wcm94eShmdW5jdGlvbiAoc3RhdHVzKSB7XFxuXFx0XFx0XFx0XFx0b2JqID0gdGhpcy5fbW9kZWwuZGF0YVtvYmouaWRdO1xcblxcdFxcdFxcdFxcdG9iai5zdGF0ZS5sb2FkaW5nID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0b2JqLnN0YXRlLmxvYWRlZCA9IHN0YXR1cztcXG5cXHRcXHRcXHRcXHRvYmouc3RhdGUuZmFpbGVkID0gIW9iai5zdGF0ZS5sb2FkZWQ7XFxuXFx0XFx0XFx0XFx0dmFyIGRvbSA9IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKSxcXG5cXHRcXHRcXHRcXHQgICAgaSA9IDAsXFxuXFx0XFx0XFx0XFx0ICAgIGogPSAwLFxcblxcdFxcdFxcdFxcdCAgICBtID0gdGhpcy5fbW9kZWwuZGF0YSxcXG5cXHRcXHRcXHRcXHQgICAgaGFzX2NoaWxkcmVuID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0Zm9yIChpID0gMCwgaiA9IG9iai5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAobVtvYmouY2hpbGRyZW5baV1dICYmICFtW29iai5jaGlsZHJlbltpXV0uc3RhdGUuaGlkZGVuKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aGFzX2NoaWxkcmVuID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGlmIChvYmouc3RhdGUubG9hZGVkICYmIGRvbSAmJiBkb20ubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZG9tLnJlbW92ZUNsYXNzKCdqc3RyZWUtY2xvc2VkIGpzdHJlZS1vcGVuIGpzdHJlZS1sZWFmJyk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCFoYXNfY2hpbGRyZW4pIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRkb20uYWRkQ2xhc3MoJ2pzdHJlZS1sZWFmJyk7XFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAob2JqLmlkICE9PSAnIycpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRkb20uYWRkQ2xhc3Mob2JqLnN0YXRlLm9wZW5lZCA/ICdqc3RyZWUtb3BlbicgOiAnanN0cmVlLWNsb3NlZCcpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGRvbS5yZW1vdmVDbGFzcyhcXFwianN0cmVlLWxvYWRpbmdcXFwiKS5hdHRyKCdhcmlhLWJ1c3knLCBmYWxzZSk7XFxuXFx0XFx0XFx0XFx0LyoqXFxuICAgICAqIHRyaWdnZXJlZCBhZnRlciBhIG5vZGUgaXMgbG9hZGVkXFxuICAgICAqIEBldmVudFxcbiAgICAgKiBAbmFtZSBsb2FkX25vZGUuanN0cmVlXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIHRoZSBub2RlIHRoYXQgd2FzIGxvYWRpbmdcXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzdGF0dXMgd2FzIHRoZSBub2RlIGxvYWRlZCBzdWNjZXNzZnVsbHlcXG4gICAgICovXFxuXFx0XFx0XFx0XFx0dGhpcy50cmlnZ2VyKCdsb2FkX25vZGUnLCB7IFxcXCJub2RlXFxcIjogb2JqLCBcXFwic3RhdHVzXFxcIjogc3RhdHVzIH0pO1xcblxcdFxcdFxcdFxcdGlmIChjYWxsYmFjaykge1xcblxcdFxcdFxcdFxcdFxcdGNhbGxiYWNrLmNhbGwodGhpcywgb2JqLCBzdGF0dXMpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LCB0aGlzKSk7XFxuXFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIGxvYWQgYW4gYXJyYXkgb2Ygbm9kZXMgKHdpbGwgYWxzbyBsb2FkIHVuYXZhaWxhYmxlIG5vZGVzIGFzIHNvb24gYXMgdGhlIGFwcGVhciBpbiB0aGUgc3RydWN0dXJlKS4gVXNlZCBpbnRlcm5hbGx5LlxcbiAgICogQHByaXZhdGVcXG4gICAqIEBuYW1lIF9sb2FkX25vZGVzKG5vZGVzIFssIGNhbGxiYWNrXSlcXG4gICAqIEBwYXJhbSAge2FycmF5fSBub2Rlc1xcbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IGNhbGxiYWNrIGEgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgb25jZSBsb2FkaW5nIGlzIGNvbXBsZXRlLCB0aGUgZnVuY3Rpb24gaXMgZXhlY3V0ZWQgaW4gdGhlIGluc3RhbmNlJ3Mgc2NvcGUgYW5kIHJlY2VpdmVzIG9uZSBhcmd1bWVudCAtIHRoZSBhcnJheSBwYXNzZWQgdG8gX2xvYWRfbm9kZXNcXG4gICAqL1xcblxcdFxcdF9sb2FkX25vZGVzOiBmdW5jdGlvbiBfbG9hZF9ub2Rlcyhub2RlcywgY2FsbGJhY2ssIGlzX2NhbGxiYWNrLCBmb3JjZV9yZWxvYWQpIHtcXG5cXHRcXHRcXHR2YXIgciA9IHRydWUsXFxuXFx0XFx0XFx0ICAgIGMgPSBmdW5jdGlvbiBjKCkge1xcblxcdFxcdFxcdFxcdHRoaXMuX2xvYWRfbm9kZXMobm9kZXMsIGNhbGxiYWNrLCB0cnVlKTtcXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdCAgICBtID0gdGhpcy5fbW9kZWwuZGF0YSxcXG5cXHRcXHRcXHQgICAgaSxcXG5cXHRcXHRcXHQgICAgaixcXG5cXHRcXHRcXHQgICAgdG1wID0gW107XFxuXFx0XFx0XFx0Zm9yIChpID0gMCwgaiA9IG5vZGVzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcblxcdFxcdFxcdFxcdGlmIChtW25vZGVzW2ldXSAmJiAoIW1bbm9kZXNbaV1dLnN0YXRlLmxvYWRlZCAmJiAhbVtub2Rlc1tpXV0uc3RhdGUuZmFpbGVkIHx8ICFpc19jYWxsYmFjayAmJiBmb3JjZV9yZWxvYWQpKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCF0aGlzLmlzX2xvYWRpbmcobm9kZXNbaV0pKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5sb2FkX25vZGUobm9kZXNbaV0sIGMpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRyID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAocikge1xcblxcdFxcdFxcdFxcdGZvciAoaSA9IDAsIGogPSBub2Rlcy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAobVtub2Rlc1tpXV0gJiYgbVtub2Rlc1tpXV0uc3RhdGUubG9hZGVkKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dG1wLnB1c2gobm9kZXNbaV0pO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aWYgKGNhbGxiYWNrICYmICFjYWxsYmFjay5kb25lKSB7XFxuXFx0XFx0XFx0XFx0XFx0Y2FsbGJhY2suY2FsbCh0aGlzLCB0bXApO1xcblxcdFxcdFxcdFxcdFxcdGNhbGxiYWNrLmRvbmUgPSB0cnVlO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIGxvYWRzIGFsbCB1bmxvYWRlZCBub2Rlc1xcbiAgICogQG5hbWUgbG9hZF9hbGwoW29iaiwgY2FsbGJhY2tdKVxcbiAgICogQHBhcmFtIHttaXhlZH0gb2JqIHRoZSBub2RlIHRvIGxvYWQgcmVjdXJzaXZlbHksIG9taXQgdG8gbG9hZCBhbGwgbm9kZXMgaW4gdGhlIHRyZWVcXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIGEgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgb25jZSBsb2FkaW5nIGFsbCB0aGUgbm9kZXMgaXMgY29tcGxldGUsXFxuICAgKiBAdHJpZ2dlciBsb2FkX2FsbC5qc3RyZWVcXG4gICAqL1xcblxcdFxcdGxvYWRfYWxsOiBmdW5jdGlvbiBsb2FkX2FsbChvYmosIGNhbGxiYWNrKSB7XFxuXFx0XFx0XFx0aWYgKCFvYmopIHtcXG5cXHRcXHRcXHRcXHRvYmogPSAkLmpzdHJlZS5yb290O1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XFxuXFx0XFx0XFx0aWYgKCFvYmopIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHZhciB0b19sb2FkID0gW10sXFxuXFx0XFx0XFx0ICAgIG0gPSB0aGlzLl9tb2RlbC5kYXRhLFxcblxcdFxcdFxcdCAgICBjID0gbVtvYmouaWRdLmNoaWxkcmVuX2QsXFxuXFx0XFx0XFx0ICAgIGksXFxuXFx0XFx0XFx0ICAgIGo7XFxuXFx0XFx0XFx0aWYgKG9iai5zdGF0ZSAmJiAhb2JqLnN0YXRlLmxvYWRlZCkge1xcblxcdFxcdFxcdFxcdHRvX2xvYWQucHVzaChvYmouaWQpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRmb3IgKGkgPSAwLCBqID0gYy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRpZiAobVtjW2ldXSAmJiBtW2NbaV1dLnN0YXRlICYmICFtW2NbaV1dLnN0YXRlLmxvYWRlZCkge1xcblxcdFxcdFxcdFxcdFxcdHRvX2xvYWQucHVzaChjW2ldKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICh0b19sb2FkLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdHRoaXMuX2xvYWRfbm9kZXModG9fbG9hZCwgZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMubG9hZF9hbGwob2JqLCBjYWxsYmFjayk7XFxuXFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHQvKipcXG4gICAgICogdHJpZ2dlcmVkIGFmdGVyIGEgbG9hZF9hbGwgY2FsbCBjb21wbGV0ZXNcXG4gICAgICogQGV2ZW50XFxuICAgICAqIEBuYW1lIGxvYWRfYWxsLmpzdHJlZVxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZSB0aGUgcmVjdXJzaXZlbHkgbG9hZGVkIG5vZGVcXG4gICAgICovXFxuXFx0XFx0XFx0XFx0aWYgKGNhbGxiYWNrKSB7XFxuXFx0XFx0XFx0XFx0XFx0Y2FsbGJhY2suY2FsbCh0aGlzLCBvYmopO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR0aGlzLnRyaWdnZXIoJ2xvYWRfYWxsJywgeyBcXFwibm9kZVxcXCI6IG9iaiB9KTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIGhhbmRsZXMgdGhlIGFjdHVhbCBsb2FkaW5nIG9mIGEgbm9kZS4gVXNlZCBvbmx5IGludGVybmFsbHkuXFxuICAgKiBAcHJpdmF0ZVxcbiAgICogQG5hbWUgX2xvYWRfbm9kZShvYmogWywgY2FsbGJhY2tdKVxcbiAgICogQHBhcmFtICB7bWl4ZWR9IG9ialxcbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IGNhbGxiYWNrIGEgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgb25jZSBsb2FkaW5nIGlzIGNvbXBsZXRlLCB0aGUgZnVuY3Rpb24gaXMgZXhlY3V0ZWQgaW4gdGhlIGluc3RhbmNlJ3Mgc2NvcGUgYW5kIHJlY2VpdmVzIG9uZSBhcmd1bWVudCAtIGEgYm9vbGVhbiBzdGF0dXNcXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XFxuICAgKi9cXG5cXHRcXHRfbG9hZF9ub2RlOiBmdW5jdGlvbiBfbG9hZF9ub2RlKG9iaiwgY2FsbGJhY2spIHtcXG5cXHRcXHRcXHR2YXIgcyA9IHRoaXMuc2V0dGluZ3MuY29yZS5kYXRhLFxcblxcdFxcdFxcdCAgICB0O1xcblxcdFxcdFxcdHZhciBub3RUZXh0T3JDb21tZW50Tm9kZSA9IGZ1bmN0aW9uIG5vdFRleHRPckNvbW1lbnROb2RlKCkge1xcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLm5vZGVUeXBlICE9PSAzICYmIHRoaXMubm9kZVR5cGUgIT09IDg7XFxuXFx0XFx0XFx0fTtcXG5cXHRcXHRcXHQvLyB1c2Ugb3JpZ2luYWwgSFRNTFxcblxcdFxcdFxcdGlmICghcykge1xcblxcdFxcdFxcdFxcdGlmIChvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5fYXBwZW5kX2h0bWxfZGF0YShvYmosIHRoaXMuX2RhdGEuY29yZS5vcmlnaW5hbF9jb250YWluZXJfaHRtbC5jbG9uZSh0cnVlKSwgZnVuY3Rpb24gKHN0YXR1cykge1xcblxcdFxcdFxcdFxcdFxcdFxcdGNhbGxiYWNrLmNhbGwodGhpcywgc3RhdHVzKTtcXG5cXHRcXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBjYWxsYmFjay5jYWxsKHRoaXMsIGZhbHNlKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0Ly8gcmV0dXJuIGNhbGxiYWNrLmNhbGwodGhpcywgb2JqLmlkID09PSAkLmpzdHJlZS5yb290ID8gdGhpcy5fYXBwZW5kX2h0bWxfZGF0YShvYmosIHRoaXMuX2RhdGEuY29yZS5vcmlnaW5hbF9jb250YWluZXJfaHRtbC5jbG9uZSh0cnVlKSkgOiBmYWxzZSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICgkLmlzRnVuY3Rpb24ocykpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gcy5jYWxsKHRoaXMsIG9iaiwgJC5wcm94eShmdW5jdGlvbiAoZCkge1xcblxcdFxcdFxcdFxcdFxcdGlmIChkID09PSBmYWxzZSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGNhbGxiYWNrLmNhbGwodGhpcywgZmFsc2UpO1xcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpc1t0eXBlb2YgZCA9PT0gJ3N0cmluZycgPyAnX2FwcGVuZF9odG1sX2RhdGEnIDogJ19hcHBlbmRfanNvbl9kYXRhJ10ob2JqLCB0eXBlb2YgZCA9PT0gJ3N0cmluZycgPyAkKCQucGFyc2VIVE1MKGQpKS5maWx0ZXIobm90VGV4dE9yQ29tbWVudE5vZGUpIDogZCwgZnVuY3Rpb24gKHN0YXR1cykge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGNhbGxiYWNrLmNhbGwodGhpcywgc3RhdHVzKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0Ly8gcmV0dXJuIGQgPT09IGZhbHNlID8gY2FsbGJhY2suY2FsbCh0aGlzLCBmYWxzZSkgOiBjYWxsYmFjay5jYWxsKHRoaXMsIHRoaXNbdHlwZW9mIGQgPT09ICdzdHJpbmcnID8gJ19hcHBlbmRfaHRtbF9kYXRhJyA6ICdfYXBwZW5kX2pzb25fZGF0YSddKG9iaiwgdHlwZW9mIGQgPT09ICdzdHJpbmcnID8gJChkKSA6IGQpKTtcXG5cXHRcXHRcXHRcXHR9LCB0aGlzKSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICgodHlwZW9mIHMgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHMpKSA9PT0gJ29iamVjdCcpIHtcXG5cXHRcXHRcXHRcXHRpZiAocy51cmwpIHtcXG5cXHRcXHRcXHRcXHRcXHRzID0gJC5leHRlbmQodHJ1ZSwge30sIHMpO1xcblxcdFxcdFxcdFxcdFxcdGlmICgkLmlzRnVuY3Rpb24ocy51cmwpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cy51cmwgPSBzLnVybC5jYWxsKHRoaXMsIG9iaik7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmICgkLmlzRnVuY3Rpb24ocy5kYXRhKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHMuZGF0YSA9IHMuZGF0YS5jYWxsKHRoaXMsIG9iaik7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdHJldHVybiAkLmFqYXgocykuZG9uZSgkLnByb3h5KGZ1bmN0aW9uIChkLCB0LCB4KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIHR5cGUgPSB4LmdldFJlc3BvbnNlSGVhZGVyKCdDb250ZW50LVR5cGUnKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAodHlwZSAmJiB0eXBlLmluZGV4T2YoJ2pzb24nKSAhPT0gLTEgfHwgKHR5cGVvZiBkID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihkKSkgPT09IFxcXCJvYmplY3RcXFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuX2FwcGVuZF9qc29uX2RhdGEob2JqLCBkLCBmdW5jdGlvbiAoc3RhdHVzKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Y2FsbGJhY2suY2FsbCh0aGlzLCBzdGF0dXMpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vcmV0dXJuIGNhbGxiYWNrLmNhbGwodGhpcywgdGhpcy5fYXBwZW5kX2pzb25fZGF0YShvYmosIGQpKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKHR5cGUgJiYgdHlwZS5pbmRleE9mKCdodG1sJykgIT09IC0xIHx8IHR5cGVvZiBkID09PSBcXFwic3RyaW5nXFxcIikge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiB0aGlzLl9hcHBlbmRfaHRtbF9kYXRhKG9iaiwgJCgkLnBhcnNlSFRNTChkKSkuZmlsdGVyKG5vdFRleHRPckNvbW1lbnROb2RlKSwgZnVuY3Rpb24gKHN0YXR1cykge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGNhbGxiYWNrLmNhbGwodGhpcywgc3RhdHVzKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyByZXR1cm4gY2FsbGJhY2suY2FsbCh0aGlzLCB0aGlzLl9hcHBlbmRfaHRtbF9kYXRhKG9iaiwgJChkKSkpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvciA9IHsgJ2Vycm9yJzogJ2FqYXgnLCAncGx1Z2luJzogJ2NvcmUnLCAnaWQnOiAnY29yZV8wNCcsICdyZWFzb24nOiAnQ291bGQgbm90IGxvYWQgbm9kZScsICdkYXRhJzogSlNPTi5zdHJpbmdpZnkoeyAnaWQnOiBvYmouaWQsICd4aHInOiB4IH0pIH07XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5zZXR0aW5ncy5jb3JlLmVycm9yLmNhbGwodGhpcywgdGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IpO1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBjYWxsYmFjay5jYWxsKHRoaXMsIGZhbHNlKTtcXG5cXHRcXHRcXHRcXHRcXHR9LCB0aGlzKSkuZmFpbCgkLnByb3h5KGZ1bmN0aW9uIChmKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FsbGJhY2suY2FsbCh0aGlzLCBmYWxzZSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IgPSB7ICdlcnJvcic6ICdhamF4JywgJ3BsdWdpbic6ICdjb3JlJywgJ2lkJzogJ2NvcmVfMDQnLCAncmVhc29uJzogJ0NvdWxkIG5vdCBsb2FkIG5vZGUnLCAnZGF0YSc6IEpTT04uc3RyaW5naWZ5KHsgJ2lkJzogb2JqLmlkLCAneGhyJzogZiB9KSB9O1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuc2V0dGluZ3MuY29yZS5lcnJvci5jYWxsKHRoaXMsIHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yKTtcXG5cXHRcXHRcXHRcXHRcXHR9LCB0aGlzKSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHQgPSAkLmlzQXJyYXkocykgfHwgJC5pc1BsYWluT2JqZWN0KHMpID8gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShzKSkgOiBzO1xcblxcdFxcdFxcdFxcdGlmIChvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5fYXBwZW5kX2pzb25fZGF0YShvYmosIHQsIGZ1bmN0aW9uIChzdGF0dXMpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYWxsYmFjay5jYWxsKHRoaXMsIHN0YXR1cyk7XFxuXFx0XFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvciA9IHsgJ2Vycm9yJzogJ25vZGF0YScsICdwbHVnaW4nOiAnY29yZScsICdpZCc6ICdjb3JlXzA1JywgJ3JlYXNvbic6ICdDb3VsZCBub3QgbG9hZCBub2RlJywgJ2RhdGEnOiBKU09OLnN0cmluZ2lmeSh7ICdpZCc6IG9iai5pZCB9KSB9O1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuc2V0dGluZ3MuY29yZS5lcnJvci5jYWxsKHRoaXMsIHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yKTtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gY2FsbGJhY2suY2FsbCh0aGlzLCBmYWxzZSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdC8vcmV0dXJuIGNhbGxiYWNrLmNhbGwodGhpcywgKG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCA/IHRoaXMuX2FwcGVuZF9qc29uX2RhdGEob2JqLCB0KSA6IGZhbHNlKSApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAodHlwZW9mIHMgPT09ICdzdHJpbmcnKSB7XFxuXFx0XFx0XFx0XFx0aWYgKG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiB0aGlzLl9hcHBlbmRfaHRtbF9kYXRhKG9iaiwgJCgkLnBhcnNlSFRNTChzKSkuZmlsdGVyKG5vdFRleHRPckNvbW1lbnROb2RlKSwgZnVuY3Rpb24gKHN0YXR1cykge1xcblxcdFxcdFxcdFxcdFxcdFxcdGNhbGxiYWNrLmNhbGwodGhpcywgc3RhdHVzKTtcXG5cXHRcXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yID0geyAnZXJyb3InOiAnbm9kYXRhJywgJ3BsdWdpbic6ICdjb3JlJywgJ2lkJzogJ2NvcmVfMDYnLCAncmVhc29uJzogJ0NvdWxkIG5vdCBsb2FkIG5vZGUnLCAnZGF0YSc6IEpTT04uc3RyaW5naWZ5KHsgJ2lkJzogb2JqLmlkIH0pIH07XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5zZXR0aW5ncy5jb3JlLmVycm9yLmNhbGwodGhpcywgdGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IpO1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBjYWxsYmFjay5jYWxsKHRoaXMsIGZhbHNlKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0Ly9yZXR1cm4gY2FsbGJhY2suY2FsbCh0aGlzLCAob2JqLmlkID09PSAkLmpzdHJlZS5yb290ID8gdGhpcy5fYXBwZW5kX2h0bWxfZGF0YShvYmosICQocykpIDogZmFsc2UpICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiBjYWxsYmFjay5jYWxsKHRoaXMsIGZhbHNlKTtcXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogYWRkcyBhIG5vZGUgdG8gdGhlIGxpc3Qgb2Ygbm9kZXMgdG8gcmVkcmF3LiBVc2VkIG9ubHkgaW50ZXJuYWxseS5cXG4gICAqIEBwcml2YXRlXFxuICAgKiBAbmFtZSBfbm9kZV9jaGFuZ2VkKG9iaiBbLCBjYWxsYmFja10pXFxuICAgKiBAcGFyYW0gIHttaXhlZH0gb2JqXFxuICAgKi9cXG5cXHRcXHRfbm9kZV9jaGFuZ2VkOiBmdW5jdGlvbiBfbm9kZV9jaGFuZ2VkKG9iaikge1xcblxcdFxcdFxcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXHRcXHRcXHRpZiAob2JqKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5fbW9kZWwuY2hhbmdlZC5wdXNoKG9iai5pZCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFx0XFx0LyoqXFxuICAgKiBhcHBlbmRzIEhUTUwgY29udGVudCB0byB0aGUgdHJlZS4gVXNlZCBpbnRlcm5hbGx5LlxcbiAgICogQHByaXZhdGVcXG4gICAqIEBuYW1lIF9hcHBlbmRfaHRtbF9kYXRhKG9iaiwgZGF0YSlcXG4gICAqIEBwYXJhbSAge21peGVkfSBvYmogdGhlIG5vZGUgdG8gYXBwZW5kIHRvXFxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGRhdGEgdGhlIEhUTUwgc3RyaW5nIHRvIHBhcnNlIGFuZCBhcHBlbmRcXG4gICAqIEB0cmlnZ2VyIG1vZGVsLmpzdHJlZSwgY2hhbmdlZC5qc3RyZWVcXG4gICAqL1xcblxcdFxcdF9hcHBlbmRfaHRtbF9kYXRhOiBmdW5jdGlvbiBfYXBwZW5kX2h0bWxfZGF0YShkb20sIGRhdGEsIGNiKSB7XFxuXFx0XFx0XFx0ZG9tID0gdGhpcy5nZXRfbm9kZShkb20pO1xcblxcdFxcdFxcdGRvbS5jaGlsZHJlbiA9IFtdO1xcblxcdFxcdFxcdGRvbS5jaGlsZHJlbl9kID0gW107XFxuXFx0XFx0XFx0dmFyIGRhdCA9IGRhdGEuaXMoJ3VsJykgPyBkYXRhLmNoaWxkcmVuKCkgOiBkYXRhLFxcblxcdFxcdFxcdCAgICBwYXIgPSBkb20uaWQsXFxuXFx0XFx0XFx0ICAgIGNoZCA9IFtdLFxcblxcdFxcdFxcdCAgICBkcGMgPSBbXSxcXG5cXHRcXHRcXHQgICAgbSA9IHRoaXMuX21vZGVsLmRhdGEsXFxuXFx0XFx0XFx0ICAgIHAgPSBtW3Bhcl0sXFxuXFx0XFx0XFx0ICAgIHMgPSB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQubGVuZ3RoLFxcblxcdFxcdFxcdCAgICB0bXAsXFxuXFx0XFx0XFx0ICAgIGksXFxuXFx0XFx0XFx0ICAgIGo7XFxuXFx0XFx0XFx0ZGF0LmVhY2goJC5wcm94eShmdW5jdGlvbiAoaSwgdikge1xcblxcdFxcdFxcdFxcdHRtcCA9IHRoaXMuX3BhcnNlX21vZGVsX2Zyb21faHRtbCgkKHYpLCBwYXIsIHAucGFyZW50cy5jb25jYXQoKSk7XFxuXFx0XFx0XFx0XFx0aWYgKHRtcCkge1xcblxcdFxcdFxcdFxcdFxcdGNoZC5wdXNoKHRtcCk7XFxuXFx0XFx0XFx0XFx0XFx0ZHBjLnB1c2godG1wKTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAobVt0bXBdLmNoaWxkcmVuX2QubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZHBjID0gZHBjLmNvbmNhdChtW3RtcF0uY2hpbGRyZW5fZCk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LCB0aGlzKSk7XFxuXFx0XFx0XFx0cC5jaGlsZHJlbiA9IGNoZDtcXG5cXHRcXHRcXHRwLmNoaWxkcmVuX2QgPSBkcGM7XFxuXFx0XFx0XFx0Zm9yIChpID0gMCwgaiA9IHAucGFyZW50cy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRtW3AucGFyZW50c1tpXV0uY2hpbGRyZW5fZCA9IG1bcC5wYXJlbnRzW2ldXS5jaGlsZHJlbl9kLmNvbmNhdChkcGMpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHQvKipcXG4gICAgKiB0cmlnZ2VyZWQgd2hlbiBuZXcgZGF0YSBpcyBpbnNlcnRlZCB0byB0aGUgdHJlZSBtb2RlbFxcbiAgICAqIEBldmVudFxcbiAgICAqIEBuYW1lIG1vZGVsLmpzdHJlZVxcbiAgICAqIEBwYXJhbSB7QXJyYXl9IG5vZGVzIGFuIGFycmF5IG9mIG5vZGUgSURzXFxuICAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmVudCB0aGUgcGFyZW50IElEIG9mIHRoZSBub2Rlc1xcbiAgICAqL1xcblxcdFxcdFxcdHRoaXMudHJpZ2dlcignbW9kZWwnLCB7IFxcXCJub2Rlc1xcXCI6IGRwYywgJ3BhcmVudCc6IHBhciB9KTtcXG5cXHRcXHRcXHRpZiAocGFyICE9PSAkLmpzdHJlZS5yb290KSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5fbm9kZV9jaGFuZ2VkKHBhcik7XFxuXFx0XFx0XFx0XFx0dGhpcy5yZWRyYXcoKTtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpLmNoaWxkcmVuKCcuanN0cmVlLWluaXRpYWwtbm9kZScpLnJlbW92ZSgpO1xcblxcdFxcdFxcdFxcdHRoaXMucmVkcmF3KHRydWUpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAodGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLmxlbmd0aCAhPT0gcykge1xcblxcdFxcdFxcdFxcdHRoaXMudHJpZ2dlcignY2hhbmdlZCcsIHsgJ2FjdGlvbic6ICdtb2RlbCcsICdzZWxlY3RlZCc6IHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZCB9KTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0Y2IuY2FsbCh0aGlzLCB0cnVlKTtcXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogYXBwZW5kcyBKU09OIGNvbnRlbnQgdG8gdGhlIHRyZWUuIFVzZWQgaW50ZXJuYWxseS5cXG4gICAqIEBwcml2YXRlXFxuICAgKiBAbmFtZSBfYXBwZW5kX2pzb25fZGF0YShvYmosIGRhdGEpXFxuICAgKiBAcGFyYW0gIHttaXhlZH0gb2JqIHRoZSBub2RlIHRvIGFwcGVuZCB0b1xcbiAgICogQHBhcmFtICB7U3RyaW5nfSBkYXRhIHRoZSBKU09OIG9iamVjdCB0byBwYXJzZSBhbmQgYXBwZW5kXFxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBmb3JjZV9wcm9jZXNzaW5nIGludGVybmFsIHBhcmFtIC0gZG8gbm90IHNldFxcbiAgICogQHRyaWdnZXIgbW9kZWwuanN0cmVlLCBjaGFuZ2VkLmpzdHJlZVxcbiAgICovXFxuXFx0XFx0X2FwcGVuZF9qc29uX2RhdGE6IGZ1bmN0aW9uIF9hcHBlbmRfanNvbl9kYXRhKGRvbSwgZGF0YSwgY2IsIGZvcmNlX3Byb2Nlc3NpbmcpIHtcXG5cXHRcXHRcXHRpZiAodGhpcy5lbGVtZW50ID09PSBudWxsKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRkb20gPSB0aGlzLmdldF9ub2RlKGRvbSk7XFxuXFx0XFx0XFx0ZG9tLmNoaWxkcmVuID0gW107XFxuXFx0XFx0XFx0ZG9tLmNoaWxkcmVuX2QgPSBbXTtcXG5cXHRcXHRcXHQvLyAqJSRAISEhXFxuXFx0XFx0XFx0aWYgKGRhdGEuZCkge1xcblxcdFxcdFxcdFxcdGRhdGEgPSBkYXRhLmQ7XFxuXFx0XFx0XFx0XFx0aWYgKHR5cGVvZiBkYXRhID09PSBcXFwic3RyaW5nXFxcIikge1xcblxcdFxcdFxcdFxcdFxcdGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKCEkLmlzQXJyYXkoZGF0YSkpIHtcXG5cXHRcXHRcXHRcXHRkYXRhID0gW2RhdGFdO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR2YXIgdyA9IG51bGwsXFxuXFx0XFx0XFx0ICAgIGFyZ3MgPSB7XFxuXFx0XFx0XFx0XFx0J2RmJzogdGhpcy5fbW9kZWwuZGVmYXVsdF9zdGF0ZSxcXG5cXHRcXHRcXHRcXHQnZGF0JzogZGF0YSxcXG5cXHRcXHRcXHRcXHQncGFyJzogZG9tLmlkLFxcblxcdFxcdFxcdFxcdCdtJzogdGhpcy5fbW9kZWwuZGF0YSxcXG5cXHRcXHRcXHRcXHQndF9pZCc6IHRoaXMuX2lkLFxcblxcdFxcdFxcdFxcdCd0X2NudCc6IHRoaXMuX2NudCxcXG5cXHRcXHRcXHRcXHQnc2VsJzogdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkXFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHQgICAgZnVuYyA9IGZ1bmN0aW9uIGZ1bmMoZGF0YSwgdW5kZWZpbmVkKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGRhdGEuZGF0YSkge1xcblxcdFxcdFxcdFxcdFxcdGRhdGEgPSBkYXRhLmRhdGE7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHZhciBkYXQgPSBkYXRhLmRhdCxcXG5cXHRcXHRcXHRcXHQgICAgcGFyID0gZGF0YS5wYXIsXFxuXFx0XFx0XFx0XFx0ICAgIGNoZCA9IFtdLFxcblxcdFxcdFxcdFxcdCAgICBkcGMgPSBbXSxcXG5cXHRcXHRcXHRcXHQgICAgYWRkID0gW10sXFxuXFx0XFx0XFx0XFx0ICAgIGRmID0gZGF0YS5kZixcXG5cXHRcXHRcXHRcXHQgICAgdF9pZCA9IGRhdGEudF9pZCxcXG5cXHRcXHRcXHRcXHQgICAgdF9jbnQgPSBkYXRhLnRfY250LFxcblxcdFxcdFxcdFxcdCAgICBtID0gZGF0YS5tLFxcblxcdFxcdFxcdFxcdCAgICBwID0gbVtwYXJdLFxcblxcdFxcdFxcdFxcdCAgICBzZWwgPSBkYXRhLnNlbCxcXG5cXHRcXHRcXHRcXHQgICAgdG1wLFxcblxcdFxcdFxcdFxcdCAgICBpLFxcblxcdFxcdFxcdFxcdCAgICBqLFxcblxcdFxcdFxcdFxcdCAgICByc2x0LFxcblxcdFxcdFxcdFxcdCAgICBwYXJzZV9mbGF0ID0gZnVuY3Rpb24gcGFyc2VfZmxhdChkLCBwLCBwcykge1xcblxcdFxcdFxcdFxcdFxcdGlmICghcHMpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRwcyA9IFtdO1xcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cHMgPSBwcy5jb25jYXQoKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRwcy51bnNoaWZ0KHApO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR2YXIgdGlkID0gZC5pZC50b1N0cmluZygpLFxcblxcdFxcdFxcdFxcdFxcdCAgICBpLFxcblxcdFxcdFxcdFxcdFxcdCAgICBqLFxcblxcdFxcdFxcdFxcdFxcdCAgICBjLFxcblxcdFxcdFxcdFxcdFxcdCAgICBlLFxcblxcdFxcdFxcdFxcdFxcdCAgICB0bXAgPSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWQ6IHRpZCxcXG5cXHRcXHRcXHRcXHRcXHRcXHR0ZXh0OiBkLnRleHQgfHwgJycsXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWNvbjogZC5pY29uICE9PSB1bmRlZmluZWQgPyBkLmljb24gOiB0cnVlLFxcblxcdFxcdFxcdFxcdFxcdFxcdHBhcmVudDogcCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRwYXJlbnRzOiBwcyxcXG5cXHRcXHRcXHRcXHRcXHRcXHRjaGlsZHJlbjogZC5jaGlsZHJlbiB8fCBbXSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRjaGlsZHJlbl9kOiBkLmNoaWxkcmVuX2QgfHwgW10sXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZGF0YTogZC5kYXRhLFxcblxcdFxcdFxcdFxcdFxcdFxcdHN0YXRlOiB7fSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRsaV9hdHRyOiB7IGlkOiBmYWxzZSB9LFxcblxcdFxcdFxcdFxcdFxcdFxcdGFfYXR0cjogeyBocmVmOiAnIycgfSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRvcmlnaW5hbDogZmFsc2VcXG5cXHRcXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdFxcdFxcdGZvciAoaSBpbiBkZikge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChkZi5oYXNPd25Qcm9wZXJ0eShpKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRtcC5zdGF0ZVtpXSA9IGRmW2ldO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGQgJiYgZC5kYXRhICYmIGQuZGF0YS5qc3RyZWUgJiYgZC5kYXRhLmpzdHJlZS5pY29uKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dG1wLmljb24gPSBkLmRhdGEuanN0cmVlLmljb247XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmICh0bXAuaWNvbiA9PT0gdW5kZWZpbmVkIHx8IHRtcC5pY29uID09PSBudWxsIHx8IHRtcC5pY29uID09PSBcXFwiXFxcIikge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRtcC5pY29uID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGQgJiYgZC5kYXRhKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dG1wLmRhdGEgPSBkLmRhdGE7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKGQuZGF0YS5qc3RyZWUpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRmb3IgKGkgaW4gZC5kYXRhLmpzdHJlZSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChkLmRhdGEuanN0cmVlLmhhc093blByb3BlcnR5KGkpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dG1wLnN0YXRlW2ldID0gZC5kYXRhLmpzdHJlZVtpXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGQgJiYgX3R5cGVvZihkLnN0YXRlKSA9PT0gJ29iamVjdCcpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRmb3IgKGkgaW4gZC5zdGF0ZSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChkLnN0YXRlLmhhc093blByb3BlcnR5KGkpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dG1wLnN0YXRlW2ldID0gZC5zdGF0ZVtpXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRpZiAoZCAmJiBfdHlwZW9mKGQubGlfYXR0cikgPT09ICdvYmplY3QnKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Zm9yIChpIGluIGQubGlfYXR0cikge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChkLmxpX2F0dHIuaGFzT3duUHJvcGVydHkoaSkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0bXAubGlfYXR0cltpXSA9IGQubGlfYXR0cltpXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIXRtcC5saV9hdHRyLmlkKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dG1wLmxpX2F0dHIuaWQgPSB0aWQ7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmIChkICYmIF90eXBlb2YoZC5hX2F0dHIpID09PSAnb2JqZWN0Jykge1xcblxcdFxcdFxcdFxcdFxcdFxcdGZvciAoaSBpbiBkLmFfYXR0cikge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChkLmFfYXR0ci5oYXNPd25Qcm9wZXJ0eShpKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRtcC5hX2F0dHJbaV0gPSBkLmFfYXR0cltpXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRpZiAoZCAmJiBkLmNoaWxkcmVuICYmIGQuY2hpbGRyZW4gPT09IHRydWUpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0bXAuc3RhdGUubG9hZGVkID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dG1wLmNoaWxkcmVuID0gW107XFxuXFx0XFx0XFx0XFx0XFx0XFx0dG1wLmNoaWxkcmVuX2QgPSBbXTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0bVt0bXAuaWRdID0gdG1wO1xcblxcdFxcdFxcdFxcdFxcdGZvciAoaSA9IDAsIGogPSB0bXAuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YyA9IHBhcnNlX2ZsYXQobVt0bXAuY2hpbGRyZW5baV1dLCB0bXAuaWQsIHBzKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRlID0gbVtjXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0bXAuY2hpbGRyZW5fZC5wdXNoKGMpO1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChlLmNoaWxkcmVuX2QubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dG1wLmNoaWxkcmVuX2QgPSB0bXAuY2hpbGRyZW5fZC5jb25jYXQoZS5jaGlsZHJlbl9kKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGRlbGV0ZSBkLmRhdGE7XFxuXFx0XFx0XFx0XFx0XFx0ZGVsZXRlIGQuY2hpbGRyZW47XFxuXFx0XFx0XFx0XFx0XFx0bVt0bXAuaWRdLm9yaWdpbmFsID0gZDtcXG5cXHRcXHRcXHRcXHRcXHRpZiAodG1wLnN0YXRlLnNlbGVjdGVkKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YWRkLnB1c2godG1wLmlkKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRtcC5pZDtcXG5cXHRcXHRcXHRcXHR9LFxcblxcdFxcdFxcdFxcdCAgICBwYXJzZV9uZXN0ID0gZnVuY3Rpb24gcGFyc2VfbmVzdChkLCBwLCBwcykge1xcblxcdFxcdFxcdFxcdFxcdGlmICghcHMpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRwcyA9IFtdO1xcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cHMgPSBwcy5jb25jYXQoKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRwcy51bnNoaWZ0KHApO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR2YXIgdGlkID0gZmFsc2UsXFxuXFx0XFx0XFx0XFx0XFx0ICAgIGksXFxuXFx0XFx0XFx0XFx0XFx0ICAgIGosXFxuXFx0XFx0XFx0XFx0XFx0ICAgIGMsXFxuXFx0XFx0XFx0XFx0XFx0ICAgIGUsXFxuXFx0XFx0XFx0XFx0XFx0ICAgIHRtcDtcXG5cXHRcXHRcXHRcXHRcXHRkbyB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGlkID0gJ2onICsgdF9pZCArICdfJyArICsrdF9jbnQ7XFxuXFx0XFx0XFx0XFx0XFx0fSB3aGlsZSAobVt0aWRdKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0bXAgPSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWQ6IGZhbHNlLFxcblxcdFxcdFxcdFxcdFxcdFxcdHRleHQ6IHR5cGVvZiBkID09PSAnc3RyaW5nJyA/IGQgOiAnJyxcXG5cXHRcXHRcXHRcXHRcXHRcXHRpY29uOiAodHlwZW9mIGQgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGQpKSA9PT0gJ29iamVjdCcgJiYgZC5pY29uICE9PSB1bmRlZmluZWQgPyBkLmljb24gOiB0cnVlLFxcblxcdFxcdFxcdFxcdFxcdFxcdHBhcmVudDogcCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRwYXJlbnRzOiBwcyxcXG5cXHRcXHRcXHRcXHRcXHRcXHRjaGlsZHJlbjogW10sXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2hpbGRyZW5fZDogW10sXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZGF0YTogbnVsbCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRzdGF0ZToge30sXFxuXFx0XFx0XFx0XFx0XFx0XFx0bGlfYXR0cjogeyBpZDogZmFsc2UgfSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRhX2F0dHI6IHsgaHJlZjogJyMnIH0sXFxuXFx0XFx0XFx0XFx0XFx0XFx0b3JpZ2luYWw6IGZhbHNlXFxuXFx0XFx0XFx0XFx0XFx0fTtcXG5cXHRcXHRcXHRcXHRcXHRmb3IgKGkgaW4gZGYpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoZGYuaGFzT3duUHJvcGVydHkoaSkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0bXAuc3RhdGVbaV0gPSBkZltpXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmIChkICYmIGQuaWQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0bXAuaWQgPSBkLmlkLnRvU3RyaW5nKCk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmIChkICYmIGQudGV4dCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRtcC50ZXh0ID0gZC50ZXh0O1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRpZiAoZCAmJiBkLmRhdGEgJiYgZC5kYXRhLmpzdHJlZSAmJiBkLmRhdGEuanN0cmVlLmljb24pIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0bXAuaWNvbiA9IGQuZGF0YS5qc3RyZWUuaWNvbjtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHRtcC5pY29uID09PSB1bmRlZmluZWQgfHwgdG1wLmljb24gPT09IG51bGwgfHwgdG1wLmljb24gPT09IFxcXCJcXFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dG1wLmljb24gPSB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRpZiAoZCAmJiBkLmRhdGEpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0bXAuZGF0YSA9IGQuZGF0YTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoZC5kYXRhLmpzdHJlZSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGZvciAoaSBpbiBkLmRhdGEuanN0cmVlKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKGQuZGF0YS5qc3RyZWUuaGFzT3duUHJvcGVydHkoaSkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0bXAuc3RhdGVbaV0gPSBkLmRhdGEuanN0cmVlW2ldO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRpZiAoZCAmJiBfdHlwZW9mKGQuc3RhdGUpID09PSAnb2JqZWN0Jykge1xcblxcdFxcdFxcdFxcdFxcdFxcdGZvciAoaSBpbiBkLnN0YXRlKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKGQuc3RhdGUuaGFzT3duUHJvcGVydHkoaSkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0bXAuc3RhdGVbaV0gPSBkLnN0YXRlW2ldO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmIChkICYmIF90eXBlb2YoZC5saV9hdHRyKSA9PT0gJ29iamVjdCcpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRmb3IgKGkgaW4gZC5saV9hdHRyKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKGQubGlfYXR0ci5oYXNPd25Qcm9wZXJ0eShpKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRtcC5saV9hdHRyW2ldID0gZC5saV9hdHRyW2ldO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmICh0bXAubGlfYXR0ci5pZCAmJiAhdG1wLmlkKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dG1wLmlkID0gdG1wLmxpX2F0dHIuaWQudG9TdHJpbmcoKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCF0bXAuaWQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0bXAuaWQgPSB0aWQ7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmICghdG1wLmxpX2F0dHIuaWQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0bXAubGlfYXR0ci5pZCA9IHRtcC5pZDtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGQgJiYgX3R5cGVvZihkLmFfYXR0cikgPT09ICdvYmplY3QnKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Zm9yIChpIGluIGQuYV9hdHRyKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKGQuYV9hdHRyLmhhc093blByb3BlcnR5KGkpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dG1wLmFfYXR0cltpXSA9IGQuYV9hdHRyW2ldO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmIChkICYmIGQuY2hpbGRyZW4gJiYgZC5jaGlsZHJlbi5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRmb3IgKGkgPSAwLCBqID0gZC5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjID0gcGFyc2VfbmVzdChkLmNoaWxkcmVuW2ldLCB0bXAuaWQsIHBzKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRlID0gbVtjXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0bXAuY2hpbGRyZW4ucHVzaChjKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoZS5jaGlsZHJlbl9kLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRtcC5jaGlsZHJlbl9kID0gdG1wLmNoaWxkcmVuX2QuY29uY2F0KGUuY2hpbGRyZW5fZCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR0bXAuY2hpbGRyZW5fZCA9IHRtcC5jaGlsZHJlbl9kLmNvbmNhdCh0bXAuY2hpbGRyZW4pO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRpZiAoZCAmJiBkLmNoaWxkcmVuICYmIGQuY2hpbGRyZW4gPT09IHRydWUpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0bXAuc3RhdGUubG9hZGVkID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dG1wLmNoaWxkcmVuID0gW107XFxuXFx0XFx0XFx0XFx0XFx0XFx0dG1wLmNoaWxkcmVuX2QgPSBbXTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0ZGVsZXRlIGQuZGF0YTtcXG5cXHRcXHRcXHRcXHRcXHRkZWxldGUgZC5jaGlsZHJlbjtcXG5cXHRcXHRcXHRcXHRcXHR0bXAub3JpZ2luYWwgPSBkO1xcblxcdFxcdFxcdFxcdFxcdG1bdG1wLmlkXSA9IHRtcDtcXG5cXHRcXHRcXHRcXHRcXHRpZiAodG1wLnN0YXRlLnNlbGVjdGVkKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YWRkLnB1c2godG1wLmlkKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRtcC5pZDtcXG5cXHRcXHRcXHRcXHR9O1xcblxcblxcdFxcdFxcdFxcdGlmIChkYXQubGVuZ3RoICYmIGRhdFswXS5pZCAhPT0gdW5kZWZpbmVkICYmIGRhdFswXS5wYXJlbnQgIT09IHVuZGVmaW5lZCkge1xcblxcdFxcdFxcdFxcdFxcdC8vIEZsYXQgSlNPTiBzdXBwb3J0IChmb3IgZWFzeSBpbXBvcnQgZnJvbSBEQik6XFxuXFx0XFx0XFx0XFx0XFx0Ly8gMSkgY29udmVydCB0byBvYmplY3QgKGZvcmVhY2gpXFxuXFx0XFx0XFx0XFx0XFx0Zm9yIChpID0gMCwgaiA9IGRhdC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIWRhdFtpXS5jaGlsZHJlbikge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdFtpXS5jaGlsZHJlbiA9IFtdO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRtW2RhdFtpXS5pZC50b1N0cmluZygpXSA9IGRhdFtpXTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0Ly8gMikgcG9wdWxhdGUgY2hpbGRyZW4gKGZvcmVhY2gpXFxuXFx0XFx0XFx0XFx0XFx0Zm9yIChpID0gMCwgaiA9IGRhdC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRtW2RhdFtpXS5wYXJlbnQudG9TdHJpbmcoKV0uY2hpbGRyZW4ucHVzaChkYXRbaV0uaWQudG9TdHJpbmcoKSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gcG9wdWxhdGUgcGFyZW50LmNoaWxkcmVuX2RcXG5cXHRcXHRcXHRcXHRcXHRcXHRwLmNoaWxkcmVuX2QucHVzaChkYXRbaV0uaWQudG9TdHJpbmcoKSk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdC8vIDMpIG5vcm1hbGl6ZSAmJiBwb3B1bGF0ZSBwYXJlbnRzIGFuZCBjaGlsZHJlbl9kIHdpdGggcmVjdXJzaW9uXFxuXFx0XFx0XFx0XFx0XFx0Zm9yIChpID0gMCwgaiA9IHAuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dG1wID0gcGFyc2VfZmxhdChtW3AuY2hpbGRyZW5baV1dLCBwYXIsIHAucGFyZW50cy5jb25jYXQoKSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZHBjLnB1c2godG1wKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAobVt0bXBdLmNoaWxkcmVuX2QubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZHBjID0gZHBjLmNvbmNhdChtW3RtcF0uY2hpbGRyZW5fZCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRmb3IgKGkgPSAwLCBqID0gcC5wYXJlbnRzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdFxcdG1bcC5wYXJlbnRzW2ldXS5jaGlsZHJlbl9kID0gbVtwLnBhcmVudHNbaV1dLmNoaWxkcmVuX2QuY29uY2F0KGRwYyk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdC8vID8pIHRocmVlX3N0YXRlIHNlbGVjdGlvbiAtIHAuc3RhdGUuc2VsZWN0ZWQgJiYgdCAtIChpZiB0aHJlZV9zdGF0ZSBmb3JlYWNoKGRhdCA9PiBjaCkgLT4gZm9yZWFjaChwYXJlbnRzKSBpZihwYXJlbnQuc2VsZWN0ZWQpIGNoaWxkLnNlbGVjdGVkID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHRyc2x0ID0ge1xcblxcdFxcdFxcdFxcdFxcdFxcdCdjbnQnOiB0X2NudCxcXG5cXHRcXHRcXHRcXHRcXHRcXHQnbW9kJzogbSxcXG5cXHRcXHRcXHRcXHRcXHRcXHQnc2VsJzogc2VsLFxcblxcdFxcdFxcdFxcdFxcdFxcdCdwYXInOiBwYXIsXFxuXFx0XFx0XFx0XFx0XFx0XFx0J2RwYyc6IGRwYyxcXG5cXHRcXHRcXHRcXHRcXHRcXHQnYWRkJzogYWRkXFxuXFx0XFx0XFx0XFx0XFx0fTtcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdGZvciAoaSA9IDAsIGogPSBkYXQubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dG1wID0gcGFyc2VfbmVzdChkYXRbaV0sIHBhciwgcC5wYXJlbnRzLmNvbmNhdCgpKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAodG1wKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y2hkLnB1c2godG1wKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRkcGMucHVzaCh0bXApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChtW3RtcF0uY2hpbGRyZW5fZC5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkcGMgPSBkcGMuY29uY2F0KG1bdG1wXS5jaGlsZHJlbl9kKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRwLmNoaWxkcmVuID0gY2hkO1xcblxcdFxcdFxcdFxcdFxcdHAuY2hpbGRyZW5fZCA9IGRwYztcXG5cXHRcXHRcXHRcXHRcXHRmb3IgKGkgPSAwLCBqID0gcC5wYXJlbnRzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdFxcdG1bcC5wYXJlbnRzW2ldXS5jaGlsZHJlbl9kID0gbVtwLnBhcmVudHNbaV1dLmNoaWxkcmVuX2QuY29uY2F0KGRwYyk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdHJzbHQgPSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0J2NudCc6IHRfY250LFxcblxcdFxcdFxcdFxcdFxcdFxcdCdtb2QnOiBtLFxcblxcdFxcdFxcdFxcdFxcdFxcdCdzZWwnOiBzZWwsXFxuXFx0XFx0XFx0XFx0XFx0XFx0J3Bhcic6IHBhcixcXG5cXHRcXHRcXHRcXHRcXHRcXHQnZHBjJzogZHBjLFxcblxcdFxcdFxcdFxcdFxcdFxcdCdhZGQnOiBhZGRcXG5cXHRcXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcXG5cXHRcXHRcXHRcXHRcXHRwb3N0TWVzc2FnZShyc2x0KTtcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiByc2x0O1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdCAgICByc2x0ID0gZnVuY3Rpb24gcnNsdChfcnNsdCwgd29ya2VyKSB7XFxuXFx0XFx0XFx0XFx0aWYgKHRoaXMuZWxlbWVudCA9PT0gbnVsbCkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0dGhpcy5fY250ID0gX3JzbHQuY250O1xcblxcdFxcdFxcdFxcdHZhciBpLFxcblxcdFxcdFxcdFxcdCAgICBtID0gdGhpcy5fbW9kZWwuZGF0YTtcXG5cXHRcXHRcXHRcXHRmb3IgKGkgaW4gbSkge1xcblxcdFxcdFxcdFxcdFxcdGlmIChtLmhhc093blByb3BlcnR5KGkpICYmIG1baV0uc3RhdGUgJiYgbVtpXS5zdGF0ZS5sb2FkaW5nICYmIF9yc2x0Lm1vZFtpXSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdF9yc2x0Lm1vZFtpXS5zdGF0ZS5sb2FkaW5nID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHRoaXMuX21vZGVsLmRhdGEgPSBfcnNsdC5tb2Q7IC8vIGJyZWFrcyB0aGUgcmVmZXJlbmNlIGluIGxvYWRfbm9kZSAtIGNhcmVmdWxcXG5cXG5cXHRcXHRcXHRcXHRpZiAod29ya2VyKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGosXFxuXFx0XFx0XFx0XFx0XFx0ICAgIGEgPSBfcnNsdC5hZGQsXFxuXFx0XFx0XFx0XFx0XFx0ICAgIHIgPSBfcnNsdC5zZWwsXFxuXFx0XFx0XFx0XFx0XFx0ICAgIHMgPSB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQuc2xpY2UoKTtcXG5cXHRcXHRcXHRcXHRcXHRtID0gdGhpcy5fbW9kZWwuZGF0YTtcXG5cXHRcXHRcXHRcXHRcXHQvLyBpZiBzZWxlY3Rpb24gd2FzIGNoYW5nZWQgd2hpbGUgY2FsY3VsYXRpbmcgaW4gd29ya2VyXFxuXFx0XFx0XFx0XFx0XFx0aWYgKHIubGVuZ3RoICE9PSBzLmxlbmd0aCB8fCAkLnZha2F0YS5hcnJheV91bmlxdWUoci5jb25jYXQocykpLmxlbmd0aCAhPT0gci5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBkZXNlbGVjdCBub2RlcyB0aGF0IGFyZSBubyBsb25nZXIgc2VsZWN0ZWRcXG5cXHRcXHRcXHRcXHRcXHRcXHRmb3IgKGkgPSAwLCBqID0gci5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoJC5pbkFycmF5KHJbaV0sIGEpID09PSAtMSAmJiAkLmluQXJyYXkocltpXSwgcykgPT09IC0xKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bVtyW2ldXS5zdGF0ZS5zZWxlY3RlZCA9IGZhbHNlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gc2VsZWN0IG5vZGVzIHRoYXQgd2VyZSBzZWxlY3RlZCBpbiB0aGUgbWVhbiB0aW1lXFxuXFx0XFx0XFx0XFx0XFx0XFx0Zm9yIChpID0gMCwgaiA9IHMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCQuaW5BcnJheShzW2ldLCByKSA9PT0gLTEpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRtW3NbaV1dLnN0YXRlLnNlbGVjdGVkID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aWYgKF9yc2x0LmFkZC5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQgPSB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQuY29uY2F0KF9yc2x0LmFkZCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHRoaXMudHJpZ2dlcignbW9kZWwnLCB7IFxcXCJub2Rlc1xcXCI6IF9yc2x0LmRwYywgJ3BhcmVudCc6IF9yc2x0LnBhciB9KTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoX3JzbHQucGFyICE9PSAkLmpzdHJlZS5yb290KSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fbm9kZV9jaGFuZ2VkKF9yc2x0LnBhcik7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5yZWRyYXcoKTtcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdC8vIHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpLmNoaWxkcmVuKCcuanN0cmVlLWluaXRpYWwtbm9kZScpLnJlbW92ZSgpO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMucmVkcmF3KHRydWUpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRpZiAoX3JzbHQuYWRkLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMudHJpZ2dlcignY2hhbmdlZCcsIHsgJ2FjdGlvbic6ICdtb2RlbCcsICdzZWxlY3RlZCc6IHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZCB9KTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0Y2IuY2FsbCh0aGlzLCB0cnVlKTtcXG5cXHRcXHRcXHR9O1xcblxcdFxcdFxcdGlmICh0aGlzLnNldHRpbmdzLmNvcmUud29ya2VyICYmIHdpbmRvdy5CbG9iICYmIHdpbmRvdy5VUkwgJiYgd2luZG93Lldvcmtlcikge1xcblxcdFxcdFxcdFxcdHRyeSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHRoaXMuX3dyayA9PT0gbnVsbCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuX3dyayA9IHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyB3aW5kb3cuQmxvYihbJ3NlbGYub25tZXNzYWdlID0gJyArIGZ1bmMudG9TdHJpbmcoKV0sIHsgdHlwZTogXFxcInRleHQvamF2YXNjcmlwdFxcXCIgfSkpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIXRoaXMuX2RhdGEuY29yZS53b3JraW5nIHx8IGZvcmNlX3Byb2Nlc3NpbmcpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl9kYXRhLmNvcmUud29ya2luZyA9IHRydWU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dyA9IG5ldyB3aW5kb3cuV29ya2VyKHRoaXMuX3dyayk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dy5vbm1lc3NhZ2UgPSAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cnNsdC5jYWxsKHRoaXMsIGUuZGF0YSwgdHJ1ZSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dHJ5IHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR3LnRlcm1pbmF0ZSgpO3cgPSBudWxsO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gY2F0Y2ggKGlnbm9yZSkge31cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAodGhpcy5fZGF0YS5jb3JlLndvcmtlcl9xdWV1ZS5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl9hcHBlbmRfanNvbl9kYXRhLmFwcGx5KHRoaXMsIHRoaXMuX2RhdGEuY29yZS53b3JrZXJfcXVldWUuc2hpZnQoKSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl9kYXRhLmNvcmUud29ya2luZyA9IGZhbHNlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9LCB0aGlzKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIWFyZ3MucGFyKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKHRoaXMuX2RhdGEuY29yZS53b3JrZXJfcXVldWUubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5fYXBwZW5kX2pzb25fZGF0YS5hcHBseSh0aGlzLCB0aGlzLl9kYXRhLmNvcmUud29ya2VyX3F1ZXVlLnNoaWZ0KCkpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5fZGF0YS5jb3JlLndvcmtpbmcgPSBmYWxzZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR3LnBvc3RNZXNzYWdlKGFyZ3MpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuX2RhdGEuY29yZS53b3JrZXJfcXVldWUucHVzaChbZG9tLCBkYXRhLCBjYiwgdHJ1ZV0pO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9IGNhdGNoIChlKSB7XFxuXFx0XFx0XFx0XFx0XFx0cnNsdC5jYWxsKHRoaXMsIGZ1bmMoYXJncyksIGZhbHNlKTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAodGhpcy5fZGF0YS5jb3JlLndvcmtlcl9xdWV1ZS5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl9hcHBlbmRfanNvbl9kYXRhLmFwcGx5KHRoaXMsIHRoaXMuX2RhdGEuY29yZS53b3JrZXJfcXVldWUuc2hpZnQoKSk7XFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl9kYXRhLmNvcmUud29ya2luZyA9IGZhbHNlO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRyc2x0LmNhbGwodGhpcywgZnVuYyhhcmdzKSwgZmFsc2UpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogcGFyc2VzIGEgbm9kZSBmcm9tIGEgalF1ZXJ5IG9iamVjdCBhbmQgYXBwZW5kcyB0aGVtIHRvIHRoZSBpbiBtZW1vcnkgdHJlZSBtb2RlbC4gVXNlZCBpbnRlcm5hbGx5LlxcbiAgICogQHByaXZhdGVcXG4gICAqIEBuYW1lIF9wYXJzZV9tb2RlbF9mcm9tX2h0bWwoZCBbLCBwLCBwc10pXFxuICAgKiBAcGFyYW0gIHtqUXVlcnl9IGQgdGhlIGpRdWVyeSBvYmplY3QgdG8gcGFyc2VcXG4gICAqIEBwYXJhbSAge1N0cmluZ30gcCB0aGUgcGFyZW50IElEXFxuICAgKiBAcGFyYW0gIHtBcnJheX0gcHMgbGlzdCBvZiBhbGwgcGFyZW50c1xcbiAgICogQHJldHVybiB7U3RyaW5nfSB0aGUgSUQgb2YgdGhlIG9iamVjdCBhZGRlZCB0byB0aGUgbW9kZWxcXG4gICAqL1xcblxcdFxcdF9wYXJzZV9tb2RlbF9mcm9tX2h0bWw6IGZ1bmN0aW9uIF9wYXJzZV9tb2RlbF9mcm9tX2h0bWwoZCwgcCwgcHMpIHtcXG5cXHRcXHRcXHRpZiAoIXBzKSB7XFxuXFx0XFx0XFx0XFx0cHMgPSBbXTtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdHBzID0gW10uY29uY2F0KHBzKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKHApIHtcXG5cXHRcXHRcXHRcXHRwcy51bnNoaWZ0KHApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR2YXIgYyxcXG5cXHRcXHRcXHQgICAgZSxcXG5cXHRcXHRcXHQgICAgbSA9IHRoaXMuX21vZGVsLmRhdGEsXFxuXFx0XFx0XFx0ICAgIGRhdGEgPSB7XFxuXFx0XFx0XFx0XFx0aWQ6IGZhbHNlLFxcblxcdFxcdFxcdFxcdHRleHQ6IGZhbHNlLFxcblxcdFxcdFxcdFxcdGljb246IHRydWUsXFxuXFx0XFx0XFx0XFx0cGFyZW50OiBwLFxcblxcdFxcdFxcdFxcdHBhcmVudHM6IHBzLFxcblxcdFxcdFxcdFxcdGNoaWxkcmVuOiBbXSxcXG5cXHRcXHRcXHRcXHRjaGlsZHJlbl9kOiBbXSxcXG5cXHRcXHRcXHRcXHRkYXRhOiBudWxsLFxcblxcdFxcdFxcdFxcdHN0YXRlOiB7fSxcXG5cXHRcXHRcXHRcXHRsaV9hdHRyOiB7IGlkOiBmYWxzZSB9LFxcblxcdFxcdFxcdFxcdGFfYXR0cjogeyBocmVmOiAnIycgfSxcXG5cXHRcXHRcXHRcXHRvcmlnaW5hbDogZmFsc2VcXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdCAgICBpLFxcblxcdFxcdFxcdCAgICB0bXAsXFxuXFx0XFx0XFx0ICAgIHRpZDtcXG5cXHRcXHRcXHRmb3IgKGkgaW4gdGhpcy5fbW9kZWwuZGVmYXVsdF9zdGF0ZSkge1xcblxcdFxcdFxcdFxcdGlmICh0aGlzLl9tb2RlbC5kZWZhdWx0X3N0YXRlLmhhc093blByb3BlcnR5KGkpKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZGF0YS5zdGF0ZVtpXSA9IHRoaXMuX21vZGVsLmRlZmF1bHRfc3RhdGVbaV07XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR0bXAgPSAkLnZha2F0YS5hdHRyaWJ1dGVzKGQsIHRydWUpO1xcblxcdFxcdFxcdCQuZWFjaCh0bXAsIGZ1bmN0aW9uIChpLCB2KSB7XFxuXFx0XFx0XFx0XFx0diA9ICQudHJpbSh2KTtcXG5cXHRcXHRcXHRcXHRpZiAoIXYubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGRhdGEubGlfYXR0cltpXSA9IHY7XFxuXFx0XFx0XFx0XFx0aWYgKGkgPT09ICdpZCcpIHtcXG5cXHRcXHRcXHRcXHRcXHRkYXRhLmlkID0gdi50b1N0cmluZygpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHR0bXAgPSBkLmNoaWxkcmVuKCdhJykuZmlyc3QoKTtcXG5cXHRcXHRcXHRpZiAodG1wLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdHRtcCA9ICQudmFrYXRhLmF0dHJpYnV0ZXModG1wLCB0cnVlKTtcXG5cXHRcXHRcXHRcXHQkLmVhY2godG1wLCBmdW5jdGlvbiAoaSwgdikge1xcblxcdFxcdFxcdFxcdFxcdHYgPSAkLnRyaW0odik7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHYubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS5hX2F0dHJbaV0gPSB2O1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0dG1wID0gZC5jaGlsZHJlbihcXFwiYVxcXCIpLmZpcnN0KCkubGVuZ3RoID8gZC5jaGlsZHJlbihcXFwiYVxcXCIpLmZpcnN0KCkuY2xvbmUoKSA6IGQuY2xvbmUoKTtcXG5cXHRcXHRcXHR0bXAuY2hpbGRyZW4oXFxcImlucywgaSwgdWxcXFwiKS5yZW1vdmUoKTtcXG5cXHRcXHRcXHR0bXAgPSB0bXAuaHRtbCgpO1xcblxcdFxcdFxcdHRtcCA9ICQoJzxkaXYgLz4nKS5odG1sKHRtcCk7XFxuXFx0XFx0XFx0ZGF0YS50ZXh0ID0gdGhpcy5zZXR0aW5ncy5jb3JlLmZvcmNlX3RleHQgPyB0bXAudGV4dCgpIDogdG1wLmh0bWwoKTtcXG5cXHRcXHRcXHR0bXAgPSBkLmRhdGEoKTtcXG5cXHRcXHRcXHRkYXRhLmRhdGEgPSB0bXAgPyAkLmV4dGVuZCh0cnVlLCB7fSwgdG1wKSA6IG51bGw7XFxuXFx0XFx0XFx0ZGF0YS5zdGF0ZS5vcGVuZWQgPSBkLmhhc0NsYXNzKCdqc3RyZWUtb3BlbicpO1xcblxcdFxcdFxcdGRhdGEuc3RhdGUuc2VsZWN0ZWQgPSBkLmNoaWxkcmVuKCdhJykuaGFzQ2xhc3MoJ2pzdHJlZS1jbGlja2VkJyk7XFxuXFx0XFx0XFx0ZGF0YS5zdGF0ZS5kaXNhYmxlZCA9IGQuY2hpbGRyZW4oJ2EnKS5oYXNDbGFzcygnanN0cmVlLWRpc2FibGVkJyk7XFxuXFx0XFx0XFx0aWYgKGRhdGEuZGF0YSAmJiBkYXRhLmRhdGEuanN0cmVlKSB7XFxuXFx0XFx0XFx0XFx0Zm9yIChpIGluIGRhdGEuZGF0YS5qc3RyZWUpIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoZGF0YS5kYXRhLmpzdHJlZS5oYXNPd25Qcm9wZXJ0eShpKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGRhdGEuc3RhdGVbaV0gPSBkYXRhLmRhdGEuanN0cmVlW2ldO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHRtcCA9IGQuY2hpbGRyZW4oXFxcImFcXFwiKS5jaGlsZHJlbihcXFwiLmpzdHJlZS10aGVtZWljb25cXFwiKTtcXG5cXHRcXHRcXHRpZiAodG1wLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdGRhdGEuaWNvbiA9IHRtcC5oYXNDbGFzcygnanN0cmVlLXRoZW1laWNvbi1oaWRkZW4nKSA/IGZhbHNlIDogdG1wLmF0dHIoJ3JlbCcpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoZGF0YS5zdGF0ZS5pY29uICE9PSB1bmRlZmluZWQpIHtcXG5cXHRcXHRcXHRcXHRkYXRhLmljb24gPSBkYXRhLnN0YXRlLmljb247XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmIChkYXRhLmljb24gPT09IHVuZGVmaW5lZCB8fCBkYXRhLmljb24gPT09IG51bGwgfHwgZGF0YS5pY29uID09PSBcXFwiXFxcIikge1xcblxcdFxcdFxcdFxcdGRhdGEuaWNvbiA9IHRydWU7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHRtcCA9IGQuY2hpbGRyZW4oXFxcInVsXFxcIikuY2hpbGRyZW4oXFxcImxpXFxcIik7XFxuXFx0XFx0XFx0ZG8ge1xcblxcdFxcdFxcdFxcdHRpZCA9ICdqJyArIHRoaXMuX2lkICsgJ18nICsgKyt0aGlzLl9jbnQ7XFxuXFx0XFx0XFx0fSB3aGlsZSAobVt0aWRdKTtcXG5cXHRcXHRcXHRkYXRhLmlkID0gZGF0YS5saV9hdHRyLmlkID8gZGF0YS5saV9hdHRyLmlkLnRvU3RyaW5nKCkgOiB0aWQ7XFxuXFx0XFx0XFx0aWYgKHRtcC5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHR0bXAuZWFjaCgkLnByb3h5KGZ1bmN0aW9uIChpLCB2KSB7XFxuXFx0XFx0XFx0XFx0XFx0YyA9IHRoaXMuX3BhcnNlX21vZGVsX2Zyb21faHRtbCgkKHYpLCBkYXRhLmlkLCBwcyk7XFxuXFx0XFx0XFx0XFx0XFx0ZSA9IHRoaXMuX21vZGVsLmRhdGFbY107XFxuXFx0XFx0XFx0XFx0XFx0ZGF0YS5jaGlsZHJlbi5wdXNoKGMpO1xcblxcdFxcdFxcdFxcdFxcdGlmIChlLmNoaWxkcmVuX2QubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS5jaGlsZHJlbl9kID0gZGF0YS5jaGlsZHJlbl9kLmNvbmNhdChlLmNoaWxkcmVuX2QpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9LCB0aGlzKSk7XFxuXFx0XFx0XFx0XFx0ZGF0YS5jaGlsZHJlbl9kID0gZGF0YS5jaGlsZHJlbl9kLmNvbmNhdChkYXRhLmNoaWxkcmVuKTtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdGlmIChkLmhhc0NsYXNzKCdqc3RyZWUtY2xvc2VkJykpIHtcXG5cXHRcXHRcXHRcXHRcXHRkYXRhLnN0YXRlLmxvYWRlZCA9IGZhbHNlO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKGRhdGEubGlfYXR0clsnY2xhc3MnXSkge1xcblxcdFxcdFxcdFxcdGRhdGEubGlfYXR0clsnY2xhc3MnXSA9IGRhdGEubGlfYXR0clsnY2xhc3MnXS5yZXBsYWNlKCdqc3RyZWUtY2xvc2VkJywgJycpLnJlcGxhY2UoJ2pzdHJlZS1vcGVuJywgJycpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoZGF0YS5hX2F0dHJbJ2NsYXNzJ10pIHtcXG5cXHRcXHRcXHRcXHRkYXRhLmFfYXR0clsnY2xhc3MnXSA9IGRhdGEuYV9hdHRyWydjbGFzcyddLnJlcGxhY2UoJ2pzdHJlZS1jbGlja2VkJywgJycpLnJlcGxhY2UoJ2pzdHJlZS1kaXNhYmxlZCcsICcnKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0bVtkYXRhLmlkXSA9IGRhdGE7XFxuXFx0XFx0XFx0aWYgKGRhdGEuc3RhdGUuc2VsZWN0ZWQpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQucHVzaChkYXRhLmlkKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIGRhdGEuaWQ7XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIHBhcnNlcyBhIG5vZGUgZnJvbSBhIEpTT04gb2JqZWN0ICh1c2VkIHdoZW4gZGVhbGluZyB3aXRoIGZsYXQgZGF0YSwgd2hpY2ggaGFzIG5vIG5lc3Rpbmcgb2YgY2hpbGRyZW4sIGJ1dCBoYXMgaWQgYW5kIHBhcmVudCBwcm9wZXJ0aWVzKSBhbmQgYXBwZW5kcyBpdCB0byB0aGUgaW4gbWVtb3J5IHRyZWUgbW9kZWwuIFVzZWQgaW50ZXJuYWxseS5cXG4gICAqIEBwcml2YXRlXFxuICAgKiBAbmFtZSBfcGFyc2VfbW9kZWxfZnJvbV9mbGF0X2pzb24oZCBbLCBwLCBwc10pXFxuICAgKiBAcGFyYW0gIHtPYmplY3R9IGQgdGhlIEpTT04gb2JqZWN0IHRvIHBhcnNlXFxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHAgdGhlIHBhcmVudCBJRFxcbiAgICogQHBhcmFtICB7QXJyYXl9IHBzIGxpc3Qgb2YgYWxsIHBhcmVudHNcXG4gICAqIEByZXR1cm4ge1N0cmluZ30gdGhlIElEIG9mIHRoZSBvYmplY3QgYWRkZWQgdG8gdGhlIG1vZGVsXFxuICAgKi9cXG5cXHRcXHRfcGFyc2VfbW9kZWxfZnJvbV9mbGF0X2pzb246IGZ1bmN0aW9uIF9wYXJzZV9tb2RlbF9mcm9tX2ZsYXRfanNvbihkLCBwLCBwcykge1xcblxcdFxcdFxcdGlmICghcHMpIHtcXG5cXHRcXHRcXHRcXHRwcyA9IFtdO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0cHMgPSBwcy5jb25jYXQoKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKHApIHtcXG5cXHRcXHRcXHRcXHRwcy51bnNoaWZ0KHApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR2YXIgdGlkID0gZC5pZC50b1N0cmluZygpLFxcblxcdFxcdFxcdCAgICBtID0gdGhpcy5fbW9kZWwuZGF0YSxcXG5cXHRcXHRcXHQgICAgZGYgPSB0aGlzLl9tb2RlbC5kZWZhdWx0X3N0YXRlLFxcblxcdFxcdFxcdCAgICBpLFxcblxcdFxcdFxcdCAgICBqLFxcblxcdFxcdFxcdCAgICBjLFxcblxcdFxcdFxcdCAgICBlLFxcblxcdFxcdFxcdCAgICB0bXAgPSB7XFxuXFx0XFx0XFx0XFx0aWQ6IHRpZCxcXG5cXHRcXHRcXHRcXHR0ZXh0OiBkLnRleHQgfHwgJycsXFxuXFx0XFx0XFx0XFx0aWNvbjogZC5pY29uICE9PSB1bmRlZmluZWQgPyBkLmljb24gOiB0cnVlLFxcblxcdFxcdFxcdFxcdHBhcmVudDogcCxcXG5cXHRcXHRcXHRcXHRwYXJlbnRzOiBwcyxcXG5cXHRcXHRcXHRcXHRjaGlsZHJlbjogZC5jaGlsZHJlbiB8fCBbXSxcXG5cXHRcXHRcXHRcXHRjaGlsZHJlbl9kOiBkLmNoaWxkcmVuX2QgfHwgW10sXFxuXFx0XFx0XFx0XFx0ZGF0YTogZC5kYXRhLFxcblxcdFxcdFxcdFxcdHN0YXRlOiB7fSxcXG5cXHRcXHRcXHRcXHRsaV9hdHRyOiB7IGlkOiBmYWxzZSB9LFxcblxcdFxcdFxcdFxcdGFfYXR0cjogeyBocmVmOiAnIycgfSxcXG5cXHRcXHRcXHRcXHRvcmlnaW5hbDogZmFsc2VcXG5cXHRcXHRcXHR9O1xcblxcdFxcdFxcdGZvciAoaSBpbiBkZikge1xcblxcdFxcdFxcdFxcdGlmIChkZi5oYXNPd25Qcm9wZXJ0eShpKSkge1xcblxcdFxcdFxcdFxcdFxcdHRtcC5zdGF0ZVtpXSA9IGRmW2ldO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKGQgJiYgZC5kYXRhICYmIGQuZGF0YS5qc3RyZWUgJiYgZC5kYXRhLmpzdHJlZS5pY29uKSB7XFxuXFx0XFx0XFx0XFx0dG1wLmljb24gPSBkLmRhdGEuanN0cmVlLmljb247XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICh0bXAuaWNvbiA9PT0gdW5kZWZpbmVkIHx8IHRtcC5pY29uID09PSBudWxsIHx8IHRtcC5pY29uID09PSBcXFwiXFxcIikge1xcblxcdFxcdFxcdFxcdHRtcC5pY29uID0gdHJ1ZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKGQgJiYgZC5kYXRhKSB7XFxuXFx0XFx0XFx0XFx0dG1wLmRhdGEgPSBkLmRhdGE7XFxuXFx0XFx0XFx0XFx0aWYgKGQuZGF0YS5qc3RyZWUpIHtcXG5cXHRcXHRcXHRcXHRcXHRmb3IgKGkgaW4gZC5kYXRhLmpzdHJlZSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChkLmRhdGEuanN0cmVlLmhhc093blByb3BlcnR5KGkpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dG1wLnN0YXRlW2ldID0gZC5kYXRhLmpzdHJlZVtpXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKGQgJiYgX3R5cGVvZihkLnN0YXRlKSA9PT0gJ29iamVjdCcpIHtcXG5cXHRcXHRcXHRcXHRmb3IgKGkgaW4gZC5zdGF0ZSkge1xcblxcdFxcdFxcdFxcdFxcdGlmIChkLnN0YXRlLmhhc093blByb3BlcnR5KGkpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dG1wLnN0YXRlW2ldID0gZC5zdGF0ZVtpXTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoZCAmJiBfdHlwZW9mKGQubGlfYXR0cikgPT09ICdvYmplY3QnKSB7XFxuXFx0XFx0XFx0XFx0Zm9yIChpIGluIGQubGlfYXR0cikge1xcblxcdFxcdFxcdFxcdFxcdGlmIChkLmxpX2F0dHIuaGFzT3duUHJvcGVydHkoaSkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0bXAubGlfYXR0cltpXSA9IGQubGlfYXR0cltpXTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoIXRtcC5saV9hdHRyLmlkKSB7XFxuXFx0XFx0XFx0XFx0dG1wLmxpX2F0dHIuaWQgPSB0aWQ7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmIChkICYmIF90eXBlb2YoZC5hX2F0dHIpID09PSAnb2JqZWN0Jykge1xcblxcdFxcdFxcdFxcdGZvciAoaSBpbiBkLmFfYXR0cikge1xcblxcdFxcdFxcdFxcdFxcdGlmIChkLmFfYXR0ci5oYXNPd25Qcm9wZXJ0eShpKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRtcC5hX2F0dHJbaV0gPSBkLmFfYXR0cltpXTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoZCAmJiBkLmNoaWxkcmVuICYmIGQuY2hpbGRyZW4gPT09IHRydWUpIHtcXG5cXHRcXHRcXHRcXHR0bXAuc3RhdGUubG9hZGVkID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0dG1wLmNoaWxkcmVuID0gW107XFxuXFx0XFx0XFx0XFx0dG1wLmNoaWxkcmVuX2QgPSBbXTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0bVt0bXAuaWRdID0gdG1wO1xcblxcdFxcdFxcdGZvciAoaSA9IDAsIGogPSB0bXAuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0YyA9IHRoaXMuX3BhcnNlX21vZGVsX2Zyb21fZmxhdF9qc29uKG1bdG1wLmNoaWxkcmVuW2ldXSwgdG1wLmlkLCBwcyk7XFxuXFx0XFx0XFx0XFx0ZSA9IG1bY107XFxuXFx0XFx0XFx0XFx0dG1wLmNoaWxkcmVuX2QucHVzaChjKTtcXG5cXHRcXHRcXHRcXHRpZiAoZS5jaGlsZHJlbl9kLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdFxcdHRtcC5jaGlsZHJlbl9kID0gdG1wLmNoaWxkcmVuX2QuY29uY2F0KGUuY2hpbGRyZW5fZCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRkZWxldGUgZC5kYXRhO1xcblxcdFxcdFxcdGRlbGV0ZSBkLmNoaWxkcmVuO1xcblxcdFxcdFxcdG1bdG1wLmlkXS5vcmlnaW5hbCA9IGQ7XFxuXFx0XFx0XFx0aWYgKHRtcC5zdGF0ZS5zZWxlY3RlZCkge1xcblxcdFxcdFxcdFxcdHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZC5wdXNoKHRtcC5pZCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiB0bXAuaWQ7XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIHBhcnNlcyBhIG5vZGUgZnJvbSBhIEpTT04gb2JqZWN0IGFuZCBhcHBlbmRzIGl0IHRvIHRoZSBpbiBtZW1vcnkgdHJlZSBtb2RlbC4gVXNlZCBpbnRlcm5hbGx5LlxcbiAgICogQHByaXZhdGVcXG4gICAqIEBuYW1lIF9wYXJzZV9tb2RlbF9mcm9tX2pzb24oZCBbLCBwLCBwc10pXFxuICAgKiBAcGFyYW0gIHtPYmplY3R9IGQgdGhlIEpTT04gb2JqZWN0IHRvIHBhcnNlXFxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHAgdGhlIHBhcmVudCBJRFxcbiAgICogQHBhcmFtICB7QXJyYXl9IHBzIGxpc3Qgb2YgYWxsIHBhcmVudHNcXG4gICAqIEByZXR1cm4ge1N0cmluZ30gdGhlIElEIG9mIHRoZSBvYmplY3QgYWRkZWQgdG8gdGhlIG1vZGVsXFxuICAgKi9cXG5cXHRcXHRfcGFyc2VfbW9kZWxfZnJvbV9qc29uOiBmdW5jdGlvbiBfcGFyc2VfbW9kZWxfZnJvbV9qc29uKGQsIHAsIHBzKSB7XFxuXFx0XFx0XFx0aWYgKCFwcykge1xcblxcdFxcdFxcdFxcdHBzID0gW107XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRwcyA9IHBzLmNvbmNhdCgpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAocCkge1xcblxcdFxcdFxcdFxcdHBzLnVuc2hpZnQocCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHZhciB0aWQgPSBmYWxzZSxcXG5cXHRcXHRcXHQgICAgaSxcXG5cXHRcXHRcXHQgICAgaixcXG5cXHRcXHRcXHQgICAgYyxcXG5cXHRcXHRcXHQgICAgZSxcXG5cXHRcXHRcXHQgICAgbSA9IHRoaXMuX21vZGVsLmRhdGEsXFxuXFx0XFx0XFx0ICAgIGRmID0gdGhpcy5fbW9kZWwuZGVmYXVsdF9zdGF0ZSxcXG5cXHRcXHRcXHQgICAgdG1wO1xcblxcdFxcdFxcdGRvIHtcXG5cXHRcXHRcXHRcXHR0aWQgPSAnaicgKyB0aGlzLl9pZCArICdfJyArICsrdGhpcy5fY250O1xcblxcdFxcdFxcdH0gd2hpbGUgKG1bdGlkXSk7XFxuXFxuXFx0XFx0XFx0dG1wID0ge1xcblxcdFxcdFxcdFxcdGlkOiBmYWxzZSxcXG5cXHRcXHRcXHRcXHR0ZXh0OiB0eXBlb2YgZCA9PT0gJ3N0cmluZycgPyBkIDogJycsXFxuXFx0XFx0XFx0XFx0aWNvbjogKHR5cGVvZiBkID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihkKSkgPT09ICdvYmplY3QnICYmIGQuaWNvbiAhPT0gdW5kZWZpbmVkID8gZC5pY29uIDogdHJ1ZSxcXG5cXHRcXHRcXHRcXHRwYXJlbnQ6IHAsXFxuXFx0XFx0XFx0XFx0cGFyZW50czogcHMsXFxuXFx0XFx0XFx0XFx0Y2hpbGRyZW46IFtdLFxcblxcdFxcdFxcdFxcdGNoaWxkcmVuX2Q6IFtdLFxcblxcdFxcdFxcdFxcdGRhdGE6IG51bGwsXFxuXFx0XFx0XFx0XFx0c3RhdGU6IHt9LFxcblxcdFxcdFxcdFxcdGxpX2F0dHI6IHsgaWQ6IGZhbHNlIH0sXFxuXFx0XFx0XFx0XFx0YV9hdHRyOiB7IGhyZWY6ICcjJyB9LFxcblxcdFxcdFxcdFxcdG9yaWdpbmFsOiBmYWxzZVxcblxcdFxcdFxcdH07XFxuXFx0XFx0XFx0Zm9yIChpIGluIGRmKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGRmLmhhc093blByb3BlcnR5KGkpKSB7XFxuXFx0XFx0XFx0XFx0XFx0dG1wLnN0YXRlW2ldID0gZGZbaV07XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoZCAmJiBkLmlkKSB7XFxuXFx0XFx0XFx0XFx0dG1wLmlkID0gZC5pZC50b1N0cmluZygpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoZCAmJiBkLnRleHQpIHtcXG5cXHRcXHRcXHRcXHR0bXAudGV4dCA9IGQudGV4dDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKGQgJiYgZC5kYXRhICYmIGQuZGF0YS5qc3RyZWUgJiYgZC5kYXRhLmpzdHJlZS5pY29uKSB7XFxuXFx0XFx0XFx0XFx0dG1wLmljb24gPSBkLmRhdGEuanN0cmVlLmljb247XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICh0bXAuaWNvbiA9PT0gdW5kZWZpbmVkIHx8IHRtcC5pY29uID09PSBudWxsIHx8IHRtcC5pY29uID09PSBcXFwiXFxcIikge1xcblxcdFxcdFxcdFxcdHRtcC5pY29uID0gdHJ1ZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKGQgJiYgZC5kYXRhKSB7XFxuXFx0XFx0XFx0XFx0dG1wLmRhdGEgPSBkLmRhdGE7XFxuXFx0XFx0XFx0XFx0aWYgKGQuZGF0YS5qc3RyZWUpIHtcXG5cXHRcXHRcXHRcXHRcXHRmb3IgKGkgaW4gZC5kYXRhLmpzdHJlZSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChkLmRhdGEuanN0cmVlLmhhc093blByb3BlcnR5KGkpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dG1wLnN0YXRlW2ldID0gZC5kYXRhLmpzdHJlZVtpXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKGQgJiYgX3R5cGVvZihkLnN0YXRlKSA9PT0gJ29iamVjdCcpIHtcXG5cXHRcXHRcXHRcXHRmb3IgKGkgaW4gZC5zdGF0ZSkge1xcblxcdFxcdFxcdFxcdFxcdGlmIChkLnN0YXRlLmhhc093blByb3BlcnR5KGkpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dG1wLnN0YXRlW2ldID0gZC5zdGF0ZVtpXTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoZCAmJiBfdHlwZW9mKGQubGlfYXR0cikgPT09ICdvYmplY3QnKSB7XFxuXFx0XFx0XFx0XFx0Zm9yIChpIGluIGQubGlfYXR0cikge1xcblxcdFxcdFxcdFxcdFxcdGlmIChkLmxpX2F0dHIuaGFzT3duUHJvcGVydHkoaSkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0bXAubGlfYXR0cltpXSA9IGQubGlfYXR0cltpXTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAodG1wLmxpX2F0dHIuaWQgJiYgIXRtcC5pZCkge1xcblxcdFxcdFxcdFxcdHRtcC5pZCA9IHRtcC5saV9hdHRyLmlkLnRvU3RyaW5nKCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICghdG1wLmlkKSB7XFxuXFx0XFx0XFx0XFx0dG1wLmlkID0gdGlkO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoIXRtcC5saV9hdHRyLmlkKSB7XFxuXFx0XFx0XFx0XFx0dG1wLmxpX2F0dHIuaWQgPSB0bXAuaWQ7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmIChkICYmIF90eXBlb2YoZC5hX2F0dHIpID09PSAnb2JqZWN0Jykge1xcblxcdFxcdFxcdFxcdGZvciAoaSBpbiBkLmFfYXR0cikge1xcblxcdFxcdFxcdFxcdFxcdGlmIChkLmFfYXR0ci5oYXNPd25Qcm9wZXJ0eShpKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRtcC5hX2F0dHJbaV0gPSBkLmFfYXR0cltpXTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoZCAmJiBkLmNoaWxkcmVuICYmIGQuY2hpbGRyZW4ubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0Zm9yIChpID0gMCwgaiA9IGQuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0YyA9IHRoaXMuX3BhcnNlX21vZGVsX2Zyb21fanNvbihkLmNoaWxkcmVuW2ldLCB0bXAuaWQsIHBzKTtcXG5cXHRcXHRcXHRcXHRcXHRlID0gbVtjXTtcXG5cXHRcXHRcXHRcXHRcXHR0bXAuY2hpbGRyZW4ucHVzaChjKTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoZS5jaGlsZHJlbl9kLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRtcC5jaGlsZHJlbl9kID0gdG1wLmNoaWxkcmVuX2QuY29uY2F0KGUuY2hpbGRyZW5fZCk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR0bXAuY2hpbGRyZW5fZCA9IHRtcC5jaGlsZHJlbl9kLmNvbmNhdCh0bXAuY2hpbGRyZW4pO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoZCAmJiBkLmNoaWxkcmVuICYmIGQuY2hpbGRyZW4gPT09IHRydWUpIHtcXG5cXHRcXHRcXHRcXHR0bXAuc3RhdGUubG9hZGVkID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0dG1wLmNoaWxkcmVuID0gW107XFxuXFx0XFx0XFx0XFx0dG1wLmNoaWxkcmVuX2QgPSBbXTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0ZGVsZXRlIGQuZGF0YTtcXG5cXHRcXHRcXHRkZWxldGUgZC5jaGlsZHJlbjtcXG5cXHRcXHRcXHR0bXAub3JpZ2luYWwgPSBkO1xcblxcdFxcdFxcdG1bdG1wLmlkXSA9IHRtcDtcXG5cXHRcXHRcXHRpZiAodG1wLnN0YXRlLnNlbGVjdGVkKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLnB1c2godG1wLmlkKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIHRtcC5pZDtcXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogcmVkcmF3cyBhbGwgbm9kZXMgdGhhdCBuZWVkIHRvIGJlIHJlZHJhd24uIFVzZWQgaW50ZXJuYWxseS5cXG4gICAqIEBwcml2YXRlXFxuICAgKiBAbmFtZSBfcmVkcmF3KClcXG4gICAqIEB0cmlnZ2VyIHJlZHJhdy5qc3RyZWVcXG4gICAqL1xcblxcdFxcdF9yZWRyYXc6IGZ1bmN0aW9uIF9yZWRyYXcoKSB7XFxuXFx0XFx0XFx0dmFyIG5vZGVzID0gdGhpcy5fbW9kZWwuZm9yY2VfZnVsbF9yZWRyYXcgPyB0aGlzLl9tb2RlbC5kYXRhWyQuanN0cmVlLnJvb3RdLmNoaWxkcmVuLmNvbmNhdChbXSkgOiB0aGlzLl9tb2RlbC5jaGFuZ2VkLmNvbmNhdChbXSksXFxuXFx0XFx0XFx0ICAgIGYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdVTCcpLFxcblxcdFxcdFxcdCAgICB0bXAsXFxuXFx0XFx0XFx0ICAgIGksXFxuXFx0XFx0XFx0ICAgIGosXFxuXFx0XFx0XFx0ICAgIGZlID0gdGhpcy5fZGF0YS5jb3JlLmZvY3VzZWQ7XFxuXFx0XFx0XFx0Zm9yIChpID0gMCwgaiA9IG5vZGVzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcblxcdFxcdFxcdFxcdHRtcCA9IHRoaXMucmVkcmF3X25vZGUobm9kZXNbaV0sIHRydWUsIHRoaXMuX21vZGVsLmZvcmNlX2Z1bGxfcmVkcmF3KTtcXG5cXHRcXHRcXHRcXHRpZiAodG1wICYmIHRoaXMuX21vZGVsLmZvcmNlX2Z1bGxfcmVkcmF3KSB7XFxuXFx0XFx0XFx0XFx0XFx0Zi5hcHBlbmRDaGlsZCh0bXApO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKHRoaXMuX21vZGVsLmZvcmNlX2Z1bGxfcmVkcmF3KSB7XFxuXFx0XFx0XFx0XFx0Zi5jbGFzc05hbWUgPSB0aGlzLmdldF9jb250YWluZXJfdWwoKVswXS5jbGFzc05hbWU7XFxuXFx0XFx0XFx0XFx0Zi5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnZ3JvdXAnKTtcXG5cXHRcXHRcXHRcXHR0aGlzLmVsZW1lbnQuZW1wdHkoKS5hcHBlbmQoZik7XFxuXFx0XFx0XFx0XFx0Ly90aGlzLmdldF9jb250YWluZXJfdWwoKVswXS5hcHBlbmRDaGlsZChmKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKGZlICE9PSBudWxsKSB7XFxuXFx0XFx0XFx0XFx0dG1wID0gdGhpcy5nZXRfbm9kZShmZSwgdHJ1ZSk7XFxuXFx0XFx0XFx0XFx0aWYgKHRtcCAmJiB0bXAubGVuZ3RoICYmIHRtcC5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKVswXSAhPT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkge1xcblxcdFxcdFxcdFxcdFxcdHRtcC5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5mb2N1cygpO1xcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fZGF0YS5jb3JlLmZvY3VzZWQgPSBudWxsO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0dGhpcy5fbW9kZWwuZm9yY2VfZnVsbF9yZWRyYXcgPSBmYWxzZTtcXG5cXHRcXHRcXHR0aGlzLl9tb2RlbC5jaGFuZ2VkID0gW107XFxuXFx0XFx0XFx0LyoqXFxuICAgICogdHJpZ2dlcmVkIGFmdGVyIG5vZGVzIGFyZSByZWRyYXduXFxuICAgICogQGV2ZW50XFxuICAgICogQG5hbWUgcmVkcmF3LmpzdHJlZVxcbiAgICAqIEBwYXJhbSB7YXJyYXl9IG5vZGVzIHRoZSByZWRyYXduIG5vZGVzXFxuICAgICovXFxuXFx0XFx0XFx0dGhpcy50cmlnZ2VyKCdyZWRyYXcnLCB7IFxcXCJub2Rlc1xcXCI6IG5vZGVzIH0pO1xcblxcdFxcdH0sXFxuXFx0XFx0LyoqXFxuICAgKiByZWRyYXdzIGFsbCBub2RlcyB0aGF0IG5lZWQgdG8gYmUgcmVkcmF3biBvciBvcHRpb25hbGx5IC0gdGhlIHdob2xlIHRyZWVcXG4gICAqIEBuYW1lIHJlZHJhdyhbZnVsbF0pXFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZ1bGwgaWYgc2V0IHRvIGB0cnVlYCBhbGwgbm9kZXMgYXJlIHJlZHJhd24uXFxuICAgKi9cXG5cXHRcXHRyZWRyYXc6IGZ1bmN0aW9uIHJlZHJhdyhmdWxsKSB7XFxuXFx0XFx0XFx0aWYgKGZ1bGwpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9tb2RlbC5mb3JjZV9mdWxsX3JlZHJhdyA9IHRydWU7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdC8vaWYodGhpcy5fbW9kZWwucmVkcmF3X3RpbWVvdXQpIHtcXG5cXHRcXHRcXHQvL1xcdGNsZWFyVGltZW91dCh0aGlzLl9tb2RlbC5yZWRyYXdfdGltZW91dCk7XFxuXFx0XFx0XFx0Ly99XFxuXFx0XFx0XFx0Ly90aGlzLl9tb2RlbC5yZWRyYXdfdGltZW91dCA9IHNldFRpbWVvdXQoJC5wcm94eSh0aGlzLl9yZWRyYXcsIHRoaXMpLDApO1xcblxcdFxcdFxcdHRoaXMuX3JlZHJhdygpO1xcblxcdFxcdH0sXFxuXFx0XFx0LyoqXFxuICAgKiByZWRyYXdzIGEgc2luZ2xlIG5vZGUncyBjaGlsZHJlbi4gVXNlZCBpbnRlcm5hbGx5LlxcbiAgICogQHByaXZhdGVcXG4gICAqIEBuYW1lIGRyYXdfY2hpbGRyZW4obm9kZSlcXG4gICAqIEBwYXJhbSB7bWl4ZWR9IG5vZGUgdGhlIG5vZGUgd2hvc2UgY2hpbGRyZW4gd2lsbCBiZSByZWRyYXduXFxuICAgKi9cXG5cXHRcXHRkcmF3X2NoaWxkcmVuOiBmdW5jdGlvbiBkcmF3X2NoaWxkcmVuKG5vZGUpIHtcXG5cXHRcXHRcXHR2YXIgb2JqID0gdGhpcy5nZXRfbm9kZShub2RlKSxcXG5cXHRcXHRcXHQgICAgaSA9IGZhbHNlLFxcblxcdFxcdFxcdCAgICBqID0gZmFsc2UsXFxuXFx0XFx0XFx0ICAgIGsgPSBmYWxzZSxcXG5cXHRcXHRcXHQgICAgZCA9IGRvY3VtZW50O1xcblxcdFxcdFxcdGlmICghb2JqKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAob2JqLmlkID09PSAkLmpzdHJlZS5yb290KSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMucmVkcmF3KHRydWUpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRub2RlID0gdGhpcy5nZXRfbm9kZShub2RlLCB0cnVlKTtcXG5cXHRcXHRcXHRpZiAoIW5vZGUgfHwgIW5vZGUubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH0gLy8gVE9ETzogcXVpY2sgdG9nZ2xlXFxuXFxuXFx0XFx0XFx0bm9kZS5jaGlsZHJlbignLmpzdHJlZS1jaGlsZHJlbicpLnJlbW92ZSgpO1xcblxcdFxcdFxcdG5vZGUgPSBub2RlWzBdO1xcblxcdFxcdFxcdGlmIChvYmouY2hpbGRyZW4ubGVuZ3RoICYmIG9iai5zdGF0ZS5sb2FkZWQpIHtcXG5cXHRcXHRcXHRcXHRrID0gZC5jcmVhdGVFbGVtZW50KCdVTCcpO1xcblxcdFxcdFxcdFxcdGsuc2V0QXR0cmlidXRlKCdyb2xlJywgJ2dyb3VwJyk7XFxuXFx0XFx0XFx0XFx0ay5jbGFzc05hbWUgPSAnanN0cmVlLWNoaWxkcmVuJztcXG5cXHRcXHRcXHRcXHRmb3IgKGkgPSAwLCBqID0gb2JqLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdGsuYXBwZW5kQ2hpbGQodGhpcy5yZWRyYXdfbm9kZShvYmouY2hpbGRyZW5baV0sIHRydWUsIHRydWUpKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0bm9kZS5hcHBlbmRDaGlsZChrKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIHJlZHJhd3MgYSBzaW5nbGUgbm9kZS4gVXNlZCBpbnRlcm5hbGx5LlxcbiAgICogQHByaXZhdGVcXG4gICAqIEBuYW1lIHJlZHJhd19ub2RlKG5vZGUsIGRlZXAsIGlzX2NhbGxiYWNrLCBmb3JjZV9yZW5kZXIpXFxuICAgKiBAcGFyYW0ge21peGVkfSBub2RlIHRoZSBub2RlIHRvIHJlZHJhd1xcbiAgICogQHBhcmFtIHtCb29sZWFufSBkZWVwIHNob3VsZCBjaGlsZCBub2RlcyBiZSByZWRyYXduIHRvb1xcbiAgICogQHBhcmFtIHtCb29sZWFufSBpc19jYWxsYmFjayBpcyB0aGlzIGEgcmVjdXJzaW9uIGNhbGxcXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZm9yY2VfcmVuZGVyIHNob3VsZCBjaGlsZHJlbiBvZiBjbG9zZWQgcGFyZW50cyBiZSBkcmF3biBhbnl3YXlcXG4gICAqL1xcblxcdFxcdHJlZHJhd19ub2RlOiBmdW5jdGlvbiByZWRyYXdfbm9kZShub2RlLCBkZWVwLCBpc19jYWxsYmFjaywgZm9yY2VfcmVuZGVyKSB7XFxuXFx0XFx0XFx0dmFyIG9iaiA9IHRoaXMuZ2V0X25vZGUobm9kZSksXFxuXFx0XFx0XFx0ICAgIHBhciA9IGZhbHNlLFxcblxcdFxcdFxcdCAgICBpbmQgPSBmYWxzZSxcXG5cXHRcXHRcXHQgICAgb2xkID0gZmFsc2UsXFxuXFx0XFx0XFx0ICAgIGkgPSBmYWxzZSxcXG5cXHRcXHRcXHQgICAgaiA9IGZhbHNlLFxcblxcdFxcdFxcdCAgICBrID0gZmFsc2UsXFxuXFx0XFx0XFx0ICAgIGMgPSAnJyxcXG5cXHRcXHRcXHQgICAgZCA9IGRvY3VtZW50LFxcblxcdFxcdFxcdCAgICBtID0gdGhpcy5fbW9kZWwuZGF0YSxcXG5cXHRcXHRcXHQgICAgZiA9IGZhbHNlLFxcblxcdFxcdFxcdCAgICBzID0gZmFsc2UsXFxuXFx0XFx0XFx0ICAgIHRtcCA9IG51bGwsXFxuXFx0XFx0XFx0ICAgIHQgPSAwLFxcblxcdFxcdFxcdCAgICBsID0gMCxcXG5cXHRcXHRcXHQgICAgaGFzX2NoaWxkcmVuID0gZmFsc2UsXFxuXFx0XFx0XFx0ICAgIGxhc3Rfc2libGluZyA9IGZhbHNlO1xcblxcdFxcdFxcdGlmICghb2JqKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAob2JqLmlkID09PSAkLmpzdHJlZS5yb290KSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMucmVkcmF3KHRydWUpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRkZWVwID0gZGVlcCB8fCBvYmouY2hpbGRyZW4ubGVuZ3RoID09PSAwO1xcblxcdFxcdFxcdG5vZGUgPSAhZG9jdW1lbnQucXVlcnlTZWxlY3RvciA/IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG9iai5pZCkgOiB0aGlzLmVsZW1lbnRbMF0ucXVlcnlTZWxlY3RvcignIycgKyAoXFxcIjAxMjM0NTY3ODlcXFwiLmluZGV4T2Yob2JqLmlkWzBdKSAhPT0gLTEgPyAnXFxcXFxcXFwzJyArIG9iai5pZFswXSArICcgJyArIG9iai5pZC5zdWJzdHIoMSkucmVwbGFjZSgkLmpzdHJlZS5pZHJlZ2V4LCAnXFxcXFxcXFwkJicpIDogb2JqLmlkLnJlcGxhY2UoJC5qc3RyZWUuaWRyZWdleCwgJ1xcXFxcXFxcJCYnKSkpOyAvLywgdGhpcy5lbGVtZW50KTtcXG5cXHRcXHRcXHRpZiAoIW5vZGUpIHtcXG5cXHRcXHRcXHRcXHRkZWVwID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHQvL25vZGUgPSBkLmNyZWF0ZUVsZW1lbnQoJ0xJJyk7XFxuXFx0XFx0XFx0XFx0aWYgKCFpc19jYWxsYmFjaykge1xcblxcdFxcdFxcdFxcdFxcdHBhciA9IG9iai5wYXJlbnQgIT09ICQuanN0cmVlLnJvb3QgPyAkKCcjJyArIG9iai5wYXJlbnQucmVwbGFjZSgkLmpzdHJlZS5pZHJlZ2V4LCAnXFxcXFxcXFwkJicpLCB0aGlzLmVsZW1lbnQpWzBdIDogbnVsbDtcXG5cXHRcXHRcXHRcXHRcXHRpZiAocGFyICE9PSBudWxsICYmICghcGFyIHx8ICFtW29iai5wYXJlbnRdLnN0YXRlLm9wZW5lZCkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGluZCA9ICQuaW5BcnJheShvYmouaWQsIHBhciA9PT0gbnVsbCA/IG1bJC5qc3RyZWUucm9vdF0uY2hpbGRyZW4gOiBtW29iai5wYXJlbnRdLmNoaWxkcmVuKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRub2RlID0gJChub2RlKTtcXG5cXHRcXHRcXHRcXHRpZiAoIWlzX2NhbGxiYWNrKSB7XFxuXFx0XFx0XFx0XFx0XFx0cGFyID0gbm9kZS5wYXJlbnQoKS5wYXJlbnQoKVswXTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAocGFyID09PSB0aGlzLmVsZW1lbnRbMF0pIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRwYXIgPSBudWxsO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRpbmQgPSBub2RlLmluZGV4KCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdC8vIG1bb2JqLmlkXS5kYXRhID0gbm9kZS5kYXRhKCk7IC8vIHVzZSBvbmx5IG5vZGUncyBkYXRhLCBubyBuZWVkIHRvIHRvdWNoIGpxdWVyeSBzdG9yYWdlXFxuXFx0XFx0XFx0XFx0aWYgKCFkZWVwICYmIG9iai5jaGlsZHJlbi5sZW5ndGggJiYgIW5vZGUuY2hpbGRyZW4oJy5qc3RyZWUtY2hpbGRyZW4nKS5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRcXHRkZWVwID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aWYgKCFkZWVwKSB7XFxuXFx0XFx0XFx0XFx0XFx0b2xkID0gbm9kZS5jaGlsZHJlbignLmpzdHJlZS1jaGlsZHJlbicpWzBdO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRmID0gbm9kZS5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKVswXSA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcXG5cXHRcXHRcXHRcXHRub2RlLnJlbW92ZSgpO1xcblxcdFxcdFxcdFxcdC8vbm9kZSA9IGQuY3JlYXRlRWxlbWVudCgnTEknKTtcXG5cXHRcXHRcXHRcXHQvL25vZGUgPSBub2RlWzBdO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRub2RlID0gdGhpcy5fZGF0YS5jb3JlLm5vZGUuY2xvbmVOb2RlKHRydWUpO1xcblxcdFxcdFxcdC8vIG5vZGUgaXMgRE9NLCBkZWVwIGlzIGJvb2xlYW5cXG5cXG5cXHRcXHRcXHRjID0gJ2pzdHJlZS1ub2RlICc7XFxuXFx0XFx0XFx0Zm9yIChpIGluIG9iai5saV9hdHRyKSB7XFxuXFx0XFx0XFx0XFx0aWYgKG9iai5saV9hdHRyLmhhc093blByb3BlcnR5KGkpKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGkgPT09ICdpZCcpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRjb250aW51ZTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGkgIT09ICdjbGFzcycpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRub2RlLnNldEF0dHJpYnV0ZShpLCBvYmoubGlfYXR0cltpXSk7XFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRjICs9IG9iai5saV9hdHRyW2ldO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICghb2JqLmFfYXR0ci5pZCkge1xcblxcdFxcdFxcdFxcdG9iai5hX2F0dHIuaWQgPSBvYmouaWQgKyAnX2FuY2hvcic7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdG5vZGUuc2V0QXR0cmlidXRlKCdhcmlhLXNlbGVjdGVkJywgISFvYmouc3RhdGUuc2VsZWN0ZWQpO1xcblxcdFxcdFxcdG5vZGUuc2V0QXR0cmlidXRlKCdhcmlhLWxldmVsJywgb2JqLnBhcmVudHMubGVuZ3RoKTtcXG5cXHRcXHRcXHRub2RlLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbGxlZGJ5Jywgb2JqLmFfYXR0ci5pZCk7XFxuXFx0XFx0XFx0aWYgKG9iai5zdGF0ZS5kaXNhYmxlZCkge1xcblxcdFxcdFxcdFxcdG5vZGUuc2V0QXR0cmlidXRlKCdhcmlhLWRpc2FibGVkJywgdHJ1ZSk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGZvciAoaSA9IDAsIGogPSBvYmouY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCFtW29iai5jaGlsZHJlbltpXV0uc3RhdGUuaGlkZGVuKSB7XFxuXFx0XFx0XFx0XFx0XFx0aGFzX2NoaWxkcmVuID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmIChvYmoucGFyZW50ICE9PSBudWxsICYmIG1bb2JqLnBhcmVudF0gJiYgIW9iai5zdGF0ZS5oaWRkZW4pIHtcXG5cXHRcXHRcXHRcXHRpID0gJC5pbkFycmF5KG9iai5pZCwgbVtvYmoucGFyZW50XS5jaGlsZHJlbik7XFxuXFx0XFx0XFx0XFx0bGFzdF9zaWJsaW5nID0gb2JqLmlkO1xcblxcdFxcdFxcdFxcdGlmIChpICE9PSAtMSkge1xcblxcdFxcdFxcdFxcdFxcdGkrKztcXG5cXHRcXHRcXHRcXHRcXHRmb3IgKGogPSBtW29iai5wYXJlbnRdLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICghbVttW29iai5wYXJlbnRdLmNoaWxkcmVuW2ldXS5zdGF0ZS5oaWRkZW4pIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRsYXN0X3NpYmxpbmcgPSBtW29iai5wYXJlbnRdLmNoaWxkcmVuW2ldO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAobGFzdF9zaWJsaW5nICE9PSBvYmouaWQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKG9iai5zdGF0ZS5oaWRkZW4pIHtcXG5cXHRcXHRcXHRcXHRjICs9ICcganN0cmVlLWhpZGRlbic7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmIChvYmouc3RhdGUubG9hZGVkICYmICFoYXNfY2hpbGRyZW4pIHtcXG5cXHRcXHRcXHRcXHRjICs9ICcganN0cmVlLWxlYWYnO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0YyArPSBvYmouc3RhdGUub3BlbmVkICYmIG9iai5zdGF0ZS5sb2FkZWQgPyAnIGpzdHJlZS1vcGVuJyA6ICcganN0cmVlLWNsb3NlZCc7XFxuXFx0XFx0XFx0XFx0bm9kZS5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCBvYmouc3RhdGUub3BlbmVkICYmIG9iai5zdGF0ZS5sb2FkZWQpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAobGFzdF9zaWJsaW5nID09PSBvYmouaWQpIHtcXG5cXHRcXHRcXHRcXHRjICs9ICcganN0cmVlLWxhc3QnO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRub2RlLmlkID0gb2JqLmlkO1xcblxcdFxcdFxcdG5vZGUuY2xhc3NOYW1lID0gYztcXG5cXHRcXHRcXHRjID0gKG9iai5zdGF0ZS5zZWxlY3RlZCA/ICcganN0cmVlLWNsaWNrZWQnIDogJycpICsgKG9iai5zdGF0ZS5kaXNhYmxlZCA/ICcganN0cmVlLWRpc2FibGVkJyA6ICcnKTtcXG5cXHRcXHRcXHRmb3IgKGogaW4gb2JqLmFfYXR0cikge1xcblxcdFxcdFxcdFxcdGlmIChvYmouYV9hdHRyLmhhc093blByb3BlcnR5KGopKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGogPT09ICdocmVmJyAmJiBvYmouYV9hdHRyW2pdID09PSAnIycpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRjb250aW51ZTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGogIT09ICdjbGFzcycpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRub2RlLmNoaWxkTm9kZXNbMV0uc2V0QXR0cmlidXRlKGosIG9iai5hX2F0dHJbal0pO1xcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YyArPSAnICcgKyBvYmouYV9hdHRyW2pdO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmIChjLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdG5vZGUuY2hpbGROb2Rlc1sxXS5jbGFzc05hbWUgPSAnanN0cmVlLWFuY2hvciAnICsgYztcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKG9iai5pY29uICYmIG9iai5pY29uICE9PSB0cnVlIHx8IG9iai5pY29uID09PSBmYWxzZSkge1xcblxcdFxcdFxcdFxcdGlmIChvYmouaWNvbiA9PT0gZmFsc2UpIHtcXG5cXHRcXHRcXHRcXHRcXHRub2RlLmNoaWxkTm9kZXNbMV0uY2hpbGROb2Rlc1swXS5jbGFzc05hbWUgKz0gJyBqc3RyZWUtdGhlbWVpY29uLWhpZGRlbic7XFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmIChvYmouaWNvbi5pbmRleE9mKCcvJykgPT09IC0xICYmIG9iai5pY29uLmluZGV4T2YoJy4nKSA9PT0gLTEpIHtcXG5cXHRcXHRcXHRcXHRcXHRub2RlLmNoaWxkTm9kZXNbMV0uY2hpbGROb2Rlc1swXS5jbGFzc05hbWUgKz0gJyAnICsgb2JqLmljb24gKyAnIGpzdHJlZS10aGVtZWljb24tY3VzdG9tJztcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdG5vZGUuY2hpbGROb2Rlc1sxXS5jaGlsZE5vZGVzWzBdLnN0eWxlLmJhY2tncm91bmRJbWFnZSA9ICd1cmwoXFxcIicgKyBvYmouaWNvbiArICdcXFwiKSc7XFxuXFx0XFx0XFx0XFx0XFx0bm9kZS5jaGlsZE5vZGVzWzFdLmNoaWxkTm9kZXNbMF0uc3R5bGUuYmFja2dyb3VuZFBvc2l0aW9uID0gJ2NlbnRlciBjZW50ZXInO1xcblxcdFxcdFxcdFxcdFxcdG5vZGUuY2hpbGROb2Rlc1sxXS5jaGlsZE5vZGVzWzBdLnN0eWxlLmJhY2tncm91bmRTaXplID0gJ2F1dG8nO1xcblxcdFxcdFxcdFxcdFxcdG5vZGUuY2hpbGROb2Rlc1sxXS5jaGlsZE5vZGVzWzBdLmNsYXNzTmFtZSArPSAnIGpzdHJlZS10aGVtZWljb24tY3VzdG9tJztcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICh0aGlzLnNldHRpbmdzLmNvcmUuZm9yY2VfdGV4dCkge1xcblxcdFxcdFxcdFxcdG5vZGUuY2hpbGROb2Rlc1sxXS5hcHBlbmRDaGlsZChkLmNyZWF0ZVRleHROb2RlKG9iai50ZXh0KSk7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRub2RlLmNoaWxkTm9kZXNbMV0uaW5uZXJIVE1MICs9IG9iai50ZXh0O1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoZGVlcCAmJiBvYmouY2hpbGRyZW4ubGVuZ3RoICYmIChvYmouc3RhdGUub3BlbmVkIHx8IGZvcmNlX3JlbmRlcikgJiYgb2JqLnN0YXRlLmxvYWRlZCkge1xcblxcdFxcdFxcdFxcdGsgPSBkLmNyZWF0ZUVsZW1lbnQoJ1VMJyk7XFxuXFx0XFx0XFx0XFx0ay5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnZ3JvdXAnKTtcXG5cXHRcXHRcXHRcXHRrLmNsYXNzTmFtZSA9ICdqc3RyZWUtY2hpbGRyZW4nO1xcblxcdFxcdFxcdFxcdGZvciAoaSA9IDAsIGogPSBvYmouY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0ay5hcHBlbmRDaGlsZCh0aGlzLnJlZHJhd19ub2RlKG9iai5jaGlsZHJlbltpXSwgZGVlcCwgdHJ1ZSkpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRub2RlLmFwcGVuZENoaWxkKGspO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAob2xkKSB7XFxuXFx0XFx0XFx0XFx0bm9kZS5hcHBlbmRDaGlsZChvbGQpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoIWlzX2NhbGxiYWNrKSB7XFxuXFx0XFx0XFx0XFx0Ly8gYXBwZW5kIGJhY2sgdXNpbmcgcGFyIC8gaW5kXFxuXFx0XFx0XFx0XFx0aWYgKCFwYXIpIHtcXG5cXHRcXHRcXHRcXHRcXHRwYXIgPSB0aGlzLmVsZW1lbnRbMF07XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGZvciAoaSA9IDAsIGogPSBwYXIuY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAocGFyLmNoaWxkTm9kZXNbaV0gJiYgcGFyLmNoaWxkTm9kZXNbaV0uY2xhc3NOYW1lICYmIHBhci5jaGlsZE5vZGVzW2ldLmNsYXNzTmFtZS5pbmRleE9mKCdqc3RyZWUtY2hpbGRyZW4nKSAhPT0gLTEpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0bXAgPSBwYXIuY2hpbGROb2Rlc1tpXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGlmICghdG1wKSB7XFxuXFx0XFx0XFx0XFx0XFx0dG1wID0gZC5jcmVhdGVFbGVtZW50KCdVTCcpO1xcblxcdFxcdFxcdFxcdFxcdHRtcC5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnZ3JvdXAnKTtcXG5cXHRcXHRcXHRcXHRcXHR0bXAuY2xhc3NOYW1lID0gJ2pzdHJlZS1jaGlsZHJlbic7XFxuXFx0XFx0XFx0XFx0XFx0cGFyLmFwcGVuZENoaWxkKHRtcCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHBhciA9IHRtcDtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoaW5kIDwgcGFyLmNoaWxkTm9kZXMubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0cGFyLmluc2VydEJlZm9yZShub2RlLCBwYXIuY2hpbGROb2Rlc1tpbmRdKTtcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdHBhci5hcHBlbmRDaGlsZChub2RlKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aWYgKGYpIHtcXG5cXHRcXHRcXHRcXHRcXHR0ID0gdGhpcy5lbGVtZW50WzBdLnNjcm9sbFRvcDtcXG5cXHRcXHRcXHRcXHRcXHRsID0gdGhpcy5lbGVtZW50WzBdLnNjcm9sbExlZnQ7XFxuXFx0XFx0XFx0XFx0XFx0bm9kZS5jaGlsZE5vZGVzWzFdLmZvY3VzKCk7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5lbGVtZW50WzBdLnNjcm9sbFRvcCA9IHQ7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5lbGVtZW50WzBdLnNjcm9sbExlZnQgPSBsO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKG9iai5zdGF0ZS5vcGVuZWQgJiYgIW9iai5zdGF0ZS5sb2FkZWQpIHtcXG5cXHRcXHRcXHRcXHRvYmouc3RhdGUub3BlbmVkID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0c2V0VGltZW91dCgkLnByb3h5KGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLm9wZW5fbm9kZShvYmouaWQsIGZhbHNlLCAwKTtcXG5cXHRcXHRcXHRcXHR9LCB0aGlzKSwgMCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiBub2RlO1xcblxcdFxcdH0sXFxuXFx0XFx0LyoqXFxuICAgKiBvcGVucyBhIG5vZGUsIHJldmFsaW5nIGl0cyBjaGlsZHJlbi4gSWYgdGhlIG5vZGUgaXMgbm90IGxvYWRlZCBpdCB3aWxsIGJlIGxvYWRlZCBhbmQgb3BlbmVkIG9uY2UgcmVhZHkuXFxuICAgKiBAbmFtZSBvcGVuX25vZGUob2JqIFssIGNhbGxiYWNrLCBhbmltYXRpb25dKVxcbiAgICogQHBhcmFtIHttaXhlZH0gb2JqIHRoZSBub2RlIHRvIG9wZW5cXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGEgZnVuY3Rpb24gdG8gZXhlY3V0ZSBvbmNlIHRoZSBub2RlIGlzIG9wZW5lZFxcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFuaW1hdGlvbiB0aGUgYW5pbWF0aW9uIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcyB3aGVuIG9wZW5pbmcgdGhlIG5vZGUgKG92ZXJyaWRlcyB0aGUgYGNvcmUuYW5pbWF0aW9uYCBzZXR0aW5nKS4gVXNlIGBmYWxzZWAgZm9yIG5vIGFuaW1hdGlvbi5cXG4gICAqIEB0cmlnZ2VyIG9wZW5fbm9kZS5qc3RyZWUsIGFmdGVyX29wZW4uanN0cmVlLCBiZWZvcmVfb3Blbi5qc3RyZWVcXG4gICAqL1xcblxcdFxcdG9wZW5fbm9kZTogZnVuY3Rpb24gb3Blbl9ub2RlKG9iaiwgY2FsbGJhY2ssIGFuaW1hdGlvbikge1xcblxcdFxcdFxcdHZhciB0MSwgdDIsIGQsIHQ7XFxuXFx0XFx0XFx0aWYgKCQuaXNBcnJheShvYmopKSB7XFxuXFx0XFx0XFx0XFx0b2JqID0gb2JqLnNsaWNlKCk7XFxuXFx0XFx0XFx0XFx0Zm9yICh0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMub3Blbl9ub2RlKG9ialt0MV0sIGNhbGxiYWNrLCBhbmltYXRpb24pO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xcblxcdFxcdFxcdGlmICghb2JqIHx8IG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCkge1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0YW5pbWF0aW9uID0gYW5pbWF0aW9uID09PSB1bmRlZmluZWQgPyB0aGlzLnNldHRpbmdzLmNvcmUuYW5pbWF0aW9uIDogYW5pbWF0aW9uO1xcblxcdFxcdFxcdGlmICghdGhpcy5pc19jbG9zZWQob2JqKSkge1xcblxcdFxcdFxcdFxcdGlmIChjYWxsYmFjaykge1xcblxcdFxcdFxcdFxcdFxcdGNhbGxiYWNrLmNhbGwodGhpcywgb2JqLCBmYWxzZSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKCF0aGlzLmlzX2xvYWRlZChvYmopKSB7XFxuXFx0XFx0XFx0XFx0aWYgKHRoaXMuaXNfbG9hZGluZyhvYmopKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHNldFRpbWVvdXQoJC5wcm94eShmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5vcGVuX25vZGUob2JqLCBjYWxsYmFjaywgYW5pbWF0aW9uKTtcXG5cXHRcXHRcXHRcXHRcXHR9LCB0aGlzKSwgNTAwKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0dGhpcy5sb2FkX25vZGUob2JqLCBmdW5jdGlvbiAobywgb2spIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gb2sgPyB0aGlzLm9wZW5fbm9kZShvLCBjYWxsYmFjaywgYW5pbWF0aW9uKSA6IGNhbGxiYWNrID8gY2FsbGJhY2suY2FsbCh0aGlzLCBvLCBmYWxzZSkgOiBmYWxzZTtcXG5cXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdGQgPSB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSk7XFxuXFx0XFx0XFx0XFx0dCA9IHRoaXM7XFxuXFx0XFx0XFx0XFx0aWYgKGQubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGFuaW1hdGlvbiAmJiBkLmNoaWxkcmVuKFxcXCIuanN0cmVlLWNoaWxkcmVuXFxcIikubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZC5jaGlsZHJlbihcXFwiLmpzdHJlZS1jaGlsZHJlblxcXCIpLnN0b3AodHJ1ZSwgdHJ1ZSk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmIChvYmouY2hpbGRyZW4ubGVuZ3RoICYmICF0aGlzLl9maXJzdENoaWxkKGQuY2hpbGRyZW4oJy5qc3RyZWUtY2hpbGRyZW4nKVswXSkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLmRyYXdfY2hpbGRyZW4ob2JqKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHQvL2QgPSB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmICghYW5pbWF0aW9uKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy50cmlnZ2VyKCdiZWZvcmVfb3BlbicsIHsgXFxcIm5vZGVcXFwiOiBvYmogfSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZFswXS5jbGFzc05hbWUgPSBkWzBdLmNsYXNzTmFtZS5yZXBsYWNlKCdqc3RyZWUtY2xvc2VkJywgJ2pzdHJlZS1vcGVuJyk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZFswXS5zZXRBdHRyaWJ1dGUoXFxcImFyaWEtZXhwYW5kZWRcXFwiLCB0cnVlKTtcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMudHJpZ2dlcignYmVmb3JlX29wZW4nLCB7IFxcXCJub2RlXFxcIjogb2JqIH0pO1xcblxcdFxcdFxcdFxcdFxcdFxcdGQuY2hpbGRyZW4oXFxcIi5qc3RyZWUtY2hpbGRyZW5cXFwiKS5jc3MoXFxcImRpc3BsYXlcXFwiLCBcXFwibm9uZVxcXCIpLmVuZCgpLnJlbW92ZUNsYXNzKFxcXCJqc3RyZWUtY2xvc2VkXFxcIikuYWRkQ2xhc3MoXFxcImpzdHJlZS1vcGVuXFxcIikuYXR0cihcXFwiYXJpYS1leHBhbmRlZFxcXCIsIHRydWUpLmNoaWxkcmVuKFxcXCIuanN0cmVlLWNoaWxkcmVuXFxcIikuc3RvcCh0cnVlLCB0cnVlKS5zbGlkZURvd24oYW5pbWF0aW9uLCBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5zdHlsZS5kaXNwbGF5ID0gXFxcIlxcXCI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKHQuZWxlbWVudCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHQudHJpZ2dlcihcXFwiYWZ0ZXJfb3BlblxcXCIsIHsgXFxcIm5vZGVcXFwiOiBvYmogfSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0b2JqLnN0YXRlLm9wZW5lZCA9IHRydWU7XFxuXFx0XFx0XFx0XFx0aWYgKGNhbGxiYWNrKSB7XFxuXFx0XFx0XFx0XFx0XFx0Y2FsbGJhY2suY2FsbCh0aGlzLCBvYmosIHRydWUpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRpZiAoIWQubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0LyoqXFxuICAgICAgKiB0cmlnZ2VyZWQgd2hlbiBhIG5vZGUgaXMgYWJvdXQgdG8gYmUgb3BlbmVkIChpZiB0aGUgbm9kZSBpcyBzdXBwb3NlZCB0byBiZSBpbiB0aGUgRE9NLCBpdCB3aWxsIGJlLCBidXQgaXQgd29uJ3QgYmUgdmlzaWJsZSB5ZXQpXFxuICAgICAgKiBAZXZlbnRcXG4gICAgICAqIEBuYW1lIGJlZm9yZV9vcGVuLmpzdHJlZVxcbiAgICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGUgdGhlIG9wZW5lZCBub2RlXFxuICAgICAgKi9cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnRyaWdnZXIoJ2JlZm9yZV9vcGVuJywgeyBcXFwibm9kZVxcXCI6IG9iaiB9KTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0LyoqXFxuICAgICAqIHRyaWdnZXJlZCB3aGVuIGEgbm9kZSBpcyBvcGVuZWQgKGlmIHRoZXJlIGlzIGFuIGFuaW1hdGlvbiBpdCB3aWxsIG5vdCBiZSBjb21wbGV0ZWQgeWV0KVxcbiAgICAgKiBAZXZlbnRcXG4gICAgICogQG5hbWUgb3Blbl9ub2RlLmpzdHJlZVxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZSB0aGUgb3BlbmVkIG5vZGVcXG4gICAgICovXFxuXFx0XFx0XFx0XFx0dGhpcy50cmlnZ2VyKCdvcGVuX25vZGUnLCB7IFxcXCJub2RlXFxcIjogb2JqIH0pO1xcblxcdFxcdFxcdFxcdGlmICghYW5pbWF0aW9uIHx8ICFkLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdFxcdC8qKlxcbiAgICAgICogdHJpZ2dlcmVkIHdoZW4gYSBub2RlIGlzIG9wZW5lZCBhbmQgdGhlIGFuaW1hdGlvbiBpcyBjb21wbGV0ZVxcbiAgICAgICogQGV2ZW50XFxuICAgICAgKiBAbmFtZSBhZnRlcl9vcGVuLmpzdHJlZVxcbiAgICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGUgdGhlIG9wZW5lZCBub2RlXFxuICAgICAgKi9cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnRyaWdnZXIoXFxcImFmdGVyX29wZW5cXFwiLCB7IFxcXCJub2RlXFxcIjogb2JqIH0pO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIG9wZW5zIGV2ZXJ5IHBhcmVudCBvZiBhIG5vZGUgKG5vZGUgc2hvdWxkIGJlIGxvYWRlZClcXG4gICAqIEBuYW1lIF9vcGVuX3RvKG9iailcXG4gICAqIEBwYXJhbSB7bWl4ZWR9IG9iaiB0aGUgbm9kZSB0byByZXZlYWxcXG4gICAqIEBwcml2YXRlXFxuICAgKi9cXG5cXHRcXHRfb3Blbl90bzogZnVuY3Rpb24gX29wZW5fdG8ob2JqKSB7XFxuXFx0XFx0XFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xcblxcdFxcdFxcdGlmICghb2JqIHx8IG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCkge1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0dmFyIGksXFxuXFx0XFx0XFx0ICAgIGosXFxuXFx0XFx0XFx0ICAgIHAgPSBvYmoucGFyZW50cztcXG5cXHRcXHRcXHRmb3IgKGkgPSAwLCBqID0gcC5sZW5ndGg7IGkgPCBqOyBpICs9IDEpIHtcXG5cXHRcXHRcXHRcXHRpZiAoaSAhPT0gJC5qc3RyZWUucm9vdCkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMub3Blbl9ub2RlKHBbaV0sIGZhbHNlLCAwKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiAkKCcjJyArIG9iai5pZC5yZXBsYWNlKCQuanN0cmVlLmlkcmVnZXgsICdcXFxcXFxcXCQmJyksIHRoaXMuZWxlbWVudCk7XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIGNsb3NlcyBhIG5vZGUsIGhpZGluZyBpdHMgY2hpbGRyZW5cXG4gICAqIEBuYW1lIGNsb3NlX25vZGUob2JqIFssIGFuaW1hdGlvbl0pXFxuICAgKiBAcGFyYW0ge21peGVkfSBvYmogdGhlIG5vZGUgdG8gY2xvc2VcXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhbmltYXRpb24gdGhlIGFuaW1hdGlvbiBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMgd2hlbiBjbG9zaW5nIHRoZSBub2RlIChvdmVycmlkZXMgdGhlIGBjb3JlLmFuaW1hdGlvbmAgc2V0dGluZykuIFVzZSBgZmFsc2VgIGZvciBubyBhbmltYXRpb24uXFxuICAgKiBAdHJpZ2dlciBjbG9zZV9ub2RlLmpzdHJlZSwgYWZ0ZXJfY2xvc2UuanN0cmVlXFxuICAgKi9cXG5cXHRcXHRjbG9zZV9ub2RlOiBmdW5jdGlvbiBjbG9zZV9ub2RlKG9iaiwgYW5pbWF0aW9uKSB7XFxuXFx0XFx0XFx0dmFyIHQxLCB0MiwgdCwgZDtcXG5cXHRcXHRcXHRpZiAoJC5pc0FycmF5KG9iaikpIHtcXG5cXHRcXHRcXHRcXHRvYmogPSBvYmouc2xpY2UoKTtcXG5cXHRcXHRcXHRcXHRmb3IgKHQxID0gMCwgdDIgPSBvYmoubGVuZ3RoOyB0MSA8IHQyOyB0MSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5jbG9zZV9ub2RlKG9ialt0MV0sIGFuaW1hdGlvbik7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XFxuXFx0XFx0XFx0aWYgKCFvYmogfHwgb2JqLmlkID09PSAkLmpzdHJlZS5yb290KSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAodGhpcy5pc19jbG9zZWQob2JqKSkge1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0YW5pbWF0aW9uID0gYW5pbWF0aW9uID09PSB1bmRlZmluZWQgPyB0aGlzLnNldHRpbmdzLmNvcmUuYW5pbWF0aW9uIDogYW5pbWF0aW9uO1xcblxcdFxcdFxcdHQgPSB0aGlzO1xcblxcdFxcdFxcdGQgPSB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSk7XFxuXFxuXFx0XFx0XFx0b2JqLnN0YXRlLm9wZW5lZCA9IGZhbHNlO1xcblxcdFxcdFxcdC8qKlxcbiAgICAqIHRyaWdnZXJlZCB3aGVuIGEgbm9kZSBpcyBjbG9zZWQgKGlmIHRoZXJlIGlzIGFuIGFuaW1hdGlvbiBpdCB3aWxsIG5vdCBiZSBjb21wbGV0ZSB5ZXQpXFxuICAgICogQGV2ZW50XFxuICAgICogQG5hbWUgY2xvc2Vfbm9kZS5qc3RyZWVcXG4gICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZSB0aGUgY2xvc2VkIG5vZGVcXG4gICAgKi9cXG5cXHRcXHRcXHR0aGlzLnRyaWdnZXIoJ2Nsb3NlX25vZGUnLCB7IFxcXCJub2RlXFxcIjogb2JqIH0pO1xcblxcdFxcdFxcdGlmICghZC5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHQvKipcXG4gICAgICogdHJpZ2dlcmVkIHdoZW4gYSBub2RlIGlzIGNsb3NlZCBhbmQgdGhlIGFuaW1hdGlvbiBpcyBjb21wbGV0ZVxcbiAgICAgKiBAZXZlbnRcXG4gICAgICogQG5hbWUgYWZ0ZXJfY2xvc2UuanN0cmVlXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIHRoZSBjbG9zZWQgbm9kZVxcbiAgICAgKi9cXG5cXHRcXHRcXHRcXHR0aGlzLnRyaWdnZXIoXFxcImFmdGVyX2Nsb3NlXFxcIiwgeyBcXFwibm9kZVxcXCI6IG9iaiB9KTtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdGlmICghYW5pbWF0aW9uKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZFswXS5jbGFzc05hbWUgPSBkWzBdLmNsYXNzTmFtZS5yZXBsYWNlKCdqc3RyZWUtb3BlbicsICdqc3RyZWUtY2xvc2VkJyk7XFxuXFx0XFx0XFx0XFx0XFx0ZC5hdHRyKFxcXCJhcmlhLWV4cGFuZGVkXFxcIiwgZmFsc2UpLmNoaWxkcmVuKCcuanN0cmVlLWNoaWxkcmVuJykucmVtb3ZlKCk7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy50cmlnZ2VyKFxcXCJhZnRlcl9jbG9zZVxcXCIsIHsgXFxcIm5vZGVcXFwiOiBvYmogfSk7XFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRkLmNoaWxkcmVuKFxcXCIuanN0cmVlLWNoaWxkcmVuXFxcIikuYXR0cihcXFwic3R5bGVcXFwiLCBcXFwiZGlzcGxheTpibG9jayAhaW1wb3J0YW50XFxcIikuZW5kKCkucmVtb3ZlQ2xhc3MoXFxcImpzdHJlZS1vcGVuXFxcIikuYWRkQ2xhc3MoXFxcImpzdHJlZS1jbG9zZWRcXFwiKS5hdHRyKFxcXCJhcmlhLWV4cGFuZGVkXFxcIiwgZmFsc2UpLmNoaWxkcmVuKFxcXCIuanN0cmVlLWNoaWxkcmVuXFxcIikuc3RvcCh0cnVlLCB0cnVlKS5zbGlkZVVwKGFuaW1hdGlvbiwgZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuc3R5bGUuZGlzcGxheSA9IFxcXCJcXFwiO1xcblxcdFxcdFxcdFxcdFxcdFxcdGQuY2hpbGRyZW4oJy5qc3RyZWUtY2hpbGRyZW4nKS5yZW1vdmUoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAodC5lbGVtZW50KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dC50cmlnZ2VyKFxcXCJhZnRlcl9jbG9zZVxcXCIsIHsgXFxcIm5vZGVcXFwiOiBvYmogfSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIHRvZ2dsZXMgYSBub2RlIC0gY2xvc2luZyBpdCBpZiBpdCBpcyBvcGVuLCBvcGVuaW5nIGl0IGlmIGl0IGlzIGNsb3NlZFxcbiAgICogQG5hbWUgdG9nZ2xlX25vZGUob2JqKVxcbiAgICogQHBhcmFtIHttaXhlZH0gb2JqIHRoZSBub2RlIHRvIHRvZ2dsZVxcbiAgICovXFxuXFx0XFx0dG9nZ2xlX25vZGU6IGZ1bmN0aW9uIHRvZ2dsZV9ub2RlKG9iaikge1xcblxcdFxcdFxcdHZhciB0MSwgdDI7XFxuXFx0XFx0XFx0aWYgKCQuaXNBcnJheShvYmopKSB7XFxuXFx0XFx0XFx0XFx0b2JqID0gb2JqLnNsaWNlKCk7XFxuXFx0XFx0XFx0XFx0Zm9yICh0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMudG9nZ2xlX25vZGUob2JqW3QxXSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAodGhpcy5pc19jbG9zZWQob2JqKSkge1xcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLm9wZW5fbm9kZShvYmopO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAodGhpcy5pc19vcGVuKG9iaikpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5jbG9zZV9ub2RlKG9iaik7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFx0XFx0LyoqXFxuICAgKiBvcGVucyBhbGwgbm9kZXMgd2l0aGluIGEgbm9kZSAob3IgdGhlIHRyZWUpLCByZXZhbGluZyB0aGVpciBjaGlsZHJlbi4gSWYgdGhlIG5vZGUgaXMgbm90IGxvYWRlZCBpdCB3aWxsIGJlIGxvYWRlZCBhbmQgb3BlbmVkIG9uY2UgcmVhZHkuXFxuICAgKiBAbmFtZSBvcGVuX2FsbChbb2JqLCBhbmltYXRpb24sIG9yaWdpbmFsX29ial0pXFxuICAgKiBAcGFyYW0ge21peGVkfSBvYmogdGhlIG5vZGUgdG8gb3BlbiByZWN1cnNpdmVseSwgb21pdCB0byBvcGVuIGFsbCBub2RlcyBpbiB0aGUgdHJlZVxcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFuaW1hdGlvbiB0aGUgYW5pbWF0aW9uIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcyB3aGVuIG9wZW5pbmcgdGhlIG5vZGVzLCB0aGUgZGVmYXVsdCBpcyBubyBhbmltYXRpb25cXG4gICAqIEBwYXJhbSB7alF1ZXJ5fSByZWZlcmVuY2UgdG8gdGhlIG5vZGUgdGhhdCBzdGFydGVkIHRoZSBwcm9jZXNzIChpbnRlcm5hbCB1c2UpXFxuICAgKiBAdHJpZ2dlciBvcGVuX2FsbC5qc3RyZWVcXG4gICAqL1xcblxcdFxcdG9wZW5fYWxsOiBmdW5jdGlvbiBvcGVuX2FsbChvYmosIGFuaW1hdGlvbiwgb3JpZ2luYWxfb2JqKSB7XFxuXFx0XFx0XFx0aWYgKCFvYmopIHtcXG5cXHRcXHRcXHRcXHRvYmogPSAkLmpzdHJlZS5yb290O1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XFxuXFx0XFx0XFx0aWYgKCFvYmopIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHZhciBkb20gPSBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QgPyB0aGlzLmdldF9jb250YWluZXJfdWwoKSA6IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKSxcXG5cXHRcXHRcXHQgICAgaSxcXG5cXHRcXHRcXHQgICAgaixcXG5cXHRcXHRcXHQgICAgX3RoaXM7XFxuXFx0XFx0XFx0aWYgKCFkb20ubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0Zm9yIChpID0gMCwgaiA9IG9iai5jaGlsZHJlbl9kLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdGlmICh0aGlzLmlzX2Nsb3NlZCh0aGlzLl9tb2RlbC5kYXRhW29iai5jaGlsZHJlbl9kW2ldXSkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl9tb2RlbC5kYXRhW29iai5jaGlsZHJlbl9kW2ldXS5zdGF0ZS5vcGVuZWQgPSB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMudHJpZ2dlcignb3Blbl9hbGwnLCB7IFxcXCJub2RlXFxcIjogb2JqIH0pO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRvcmlnaW5hbF9vYmogPSBvcmlnaW5hbF9vYmogfHwgZG9tO1xcblxcdFxcdFxcdF90aGlzID0gdGhpcztcXG5cXHRcXHRcXHRkb20gPSB0aGlzLmlzX2Nsb3NlZChvYmopID8gZG9tLmZpbmQoJy5qc3RyZWUtY2xvc2VkJykuYWRkQmFjaygpIDogZG9tLmZpbmQoJy5qc3RyZWUtY2xvc2VkJyk7XFxuXFx0XFx0XFx0ZG9tLmVhY2goZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdF90aGlzLm9wZW5fbm9kZSh0aGlzLCBmdW5jdGlvbiAobm9kZSwgc3RhdHVzKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHN0YXR1cyAmJiB0aGlzLmlzX3BhcmVudChub2RlKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMub3Blbl9hbGwobm9kZSwgYW5pbWF0aW9uLCBvcmlnaW5hbF9vYmopO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9LCBhbmltYXRpb24gfHwgMCk7XFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0aWYgKG9yaWdpbmFsX29iai5maW5kKCcuanN0cmVlLWNsb3NlZCcpLmxlbmd0aCA9PT0gMCkge1xcblxcdFxcdFxcdFxcdC8qKlxcbiAgICAgKiB0cmlnZ2VyZWQgd2hlbiBhbiBgb3Blbl9hbGxgIGNhbGwgY29tcGxldGVzXFxuICAgICAqIEBldmVudFxcbiAgICAgKiBAbmFtZSBvcGVuX2FsbC5qc3RyZWVcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGUgdGhlIG9wZW5lZCBub2RlXFxuICAgICAqL1xcblxcdFxcdFxcdFxcdHRoaXMudHJpZ2dlcignb3Blbl9hbGwnLCB7IFxcXCJub2RlXFxcIjogdGhpcy5nZXRfbm9kZShvcmlnaW5hbF9vYmopIH0pO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogY2xvc2VzIGFsbCBub2RlcyB3aXRoaW4gYSBub2RlIChvciB0aGUgdHJlZSksIHJldmFsaW5nIHRoZWlyIGNoaWxkcmVuXFxuICAgKiBAbmFtZSBjbG9zZV9hbGwoW29iaiwgYW5pbWF0aW9uXSlcXG4gICAqIEBwYXJhbSB7bWl4ZWR9IG9iaiB0aGUgbm9kZSB0byBjbG9zZSByZWN1cnNpdmVseSwgb21pdCB0byBjbG9zZSBhbGwgbm9kZXMgaW4gdGhlIHRyZWVcXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhbmltYXRpb24gdGhlIGFuaW1hdGlvbiBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMgd2hlbiBjbG9zaW5nIHRoZSBub2RlcywgdGhlIGRlZmF1bHQgaXMgbm8gYW5pbWF0aW9uXFxuICAgKiBAdHJpZ2dlciBjbG9zZV9hbGwuanN0cmVlXFxuICAgKi9cXG5cXHRcXHRjbG9zZV9hbGw6IGZ1bmN0aW9uIGNsb3NlX2FsbChvYmosIGFuaW1hdGlvbikge1xcblxcdFxcdFxcdGlmICghb2JqKSB7XFxuXFx0XFx0XFx0XFx0b2JqID0gJC5qc3RyZWUucm9vdDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xcblxcdFxcdFxcdGlmICghb2JqKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR2YXIgZG9tID0gb2JqLmlkID09PSAkLmpzdHJlZS5yb290ID8gdGhpcy5nZXRfY29udGFpbmVyX3VsKCkgOiB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSksXFxuXFx0XFx0XFx0ICAgIF90aGlzID0gdGhpcyxcXG5cXHRcXHRcXHQgICAgaSxcXG5cXHRcXHRcXHQgICAgajtcXG5cXHRcXHRcXHRpZiAoZG9tLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdGRvbSA9IHRoaXMuaXNfb3BlbihvYmopID8gZG9tLmZpbmQoJy5qc3RyZWUtb3BlbicpLmFkZEJhY2soKSA6IGRvbS5maW5kKCcuanN0cmVlLW9wZW4nKTtcXG5cXHRcXHRcXHRcXHQkKGRvbS5nZXQoKS5yZXZlcnNlKCkpLmVhY2goZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdF90aGlzLmNsb3NlX25vZGUodGhpcywgYW5pbWF0aW9uIHx8IDApO1xcblxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRmb3IgKGkgPSAwLCBqID0gb2JqLmNoaWxkcmVuX2QubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5fbW9kZWwuZGF0YVtvYmouY2hpbGRyZW5fZFtpXV0uc3RhdGUub3BlbmVkID0gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdC8qKlxcbiAgICAqIHRyaWdnZXJlZCB3aGVuIGFuIGBjbG9zZV9hbGxgIGNhbGwgY29tcGxldGVzXFxuICAgICogQGV2ZW50XFxuICAgICogQG5hbWUgY2xvc2VfYWxsLmpzdHJlZVxcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIHRoZSBjbG9zZWQgbm9kZVxcbiAgICAqL1xcblxcdFxcdFxcdHRoaXMudHJpZ2dlcignY2xvc2VfYWxsJywgeyBcXFwibm9kZVxcXCI6IG9iaiB9KTtcXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogY2hlY2tzIGlmIGEgbm9kZSBpcyBkaXNhYmxlZCAobm90IHNlbGVjdGFibGUpXFxuICAgKiBAbmFtZSBpc19kaXNhYmxlZChvYmopXFxuICAgKiBAcGFyYW0gIHttaXhlZH0gb2JqXFxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxcbiAgICovXFxuXFx0XFx0aXNfZGlzYWJsZWQ6IGZ1bmN0aW9uIGlzX2Rpc2FibGVkKG9iaikge1xcblxcdFxcdFxcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXHRcXHRcXHRyZXR1cm4gb2JqICYmIG9iai5zdGF0ZSAmJiBvYmouc3RhdGUuZGlzYWJsZWQ7XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIGVuYWJsZXMgYSBub2RlIC0gc28gdGhhdCBpdCBjYW4gYmUgc2VsZWN0ZWRcXG4gICAqIEBuYW1lIGVuYWJsZV9ub2RlKG9iailcXG4gICAqIEBwYXJhbSB7bWl4ZWR9IG9iaiB0aGUgbm9kZSB0byBlbmFibGVcXG4gICAqIEB0cmlnZ2VyIGVuYWJsZV9ub2RlLmpzdHJlZVxcbiAgICovXFxuXFx0XFx0ZW5hYmxlX25vZGU6IGZ1bmN0aW9uIGVuYWJsZV9ub2RlKG9iaikge1xcblxcdFxcdFxcdHZhciB0MSwgdDI7XFxuXFx0XFx0XFx0aWYgKCQuaXNBcnJheShvYmopKSB7XFxuXFx0XFx0XFx0XFx0b2JqID0gb2JqLnNsaWNlKCk7XFxuXFx0XFx0XFx0XFx0Zm9yICh0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuZW5hYmxlX25vZGUob2JqW3QxXSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XFxuXFx0XFx0XFx0aWYgKCFvYmogfHwgb2JqLmlkID09PSAkLmpzdHJlZS5yb290KSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRvYmouc3RhdGUuZGlzYWJsZWQgPSBmYWxzZTtcXG5cXHRcXHRcXHR0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSkuY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykucmVtb3ZlQ2xhc3MoJ2pzdHJlZS1kaXNhYmxlZCcpLmF0dHIoJ2FyaWEtZGlzYWJsZWQnLCBmYWxzZSk7XFxuXFx0XFx0XFx0LyoqXFxuICAgICogdHJpZ2dlcmVkIHdoZW4gYW4gbm9kZSBpcyBlbmFibGVkXFxuICAgICogQGV2ZW50XFxuICAgICogQG5hbWUgZW5hYmxlX25vZGUuanN0cmVlXFxuICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGUgdGhlIGVuYWJsZWQgbm9kZVxcbiAgICAqL1xcblxcdFxcdFxcdHRoaXMudHJpZ2dlcignZW5hYmxlX25vZGUnLCB7ICdub2RlJzogb2JqIH0pO1xcblxcdFxcdH0sXFxuXFx0XFx0LyoqXFxuICAgKiBkaXNhYmxlcyBhIG5vZGUgLSBzbyB0aGF0IGl0IGNhbiBub3QgYmUgc2VsZWN0ZWRcXG4gICAqIEBuYW1lIGRpc2FibGVfbm9kZShvYmopXFxuICAgKiBAcGFyYW0ge21peGVkfSBvYmogdGhlIG5vZGUgdG8gZGlzYWJsZVxcbiAgICogQHRyaWdnZXIgZGlzYWJsZV9ub2RlLmpzdHJlZVxcbiAgICovXFxuXFx0XFx0ZGlzYWJsZV9ub2RlOiBmdW5jdGlvbiBkaXNhYmxlX25vZGUob2JqKSB7XFxuXFx0XFx0XFx0dmFyIHQxLCB0MjtcXG5cXHRcXHRcXHRpZiAoJC5pc0FycmF5KG9iaikpIHtcXG5cXHRcXHRcXHRcXHRvYmogPSBvYmouc2xpY2UoKTtcXG5cXHRcXHRcXHRcXHRmb3IgKHQxID0gMCwgdDIgPSBvYmoubGVuZ3RoOyB0MSA8IHQyOyB0MSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5kaXNhYmxlX25vZGUob2JqW3QxXSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XFxuXFx0XFx0XFx0aWYgKCFvYmogfHwgb2JqLmlkID09PSAkLmpzdHJlZS5yb290KSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRvYmouc3RhdGUuZGlzYWJsZWQgPSB0cnVlO1xcblxcdFxcdFxcdHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKS5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5hZGRDbGFzcygnanN0cmVlLWRpc2FibGVkJykuYXR0cignYXJpYS1kaXNhYmxlZCcsIHRydWUpO1xcblxcdFxcdFxcdC8qKlxcbiAgICAqIHRyaWdnZXJlZCB3aGVuIGFuIG5vZGUgaXMgZGlzYWJsZWRcXG4gICAgKiBAZXZlbnRcXG4gICAgKiBAbmFtZSBkaXNhYmxlX25vZGUuanN0cmVlXFxuICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGUgdGhlIGRpc2FibGVkIG5vZGVcXG4gICAgKi9cXG5cXHRcXHRcXHR0aGlzLnRyaWdnZXIoJ2Rpc2FibGVfbm9kZScsIHsgJ25vZGUnOiBvYmogfSk7XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIGRldGVybWluZXMgaWYgYSBub2RlIGlzIGhpZGRlblxcbiAgICogQG5hbWUgaXNfaGlkZGVuKG9iailcXG4gICAqIEBwYXJhbSB7bWl4ZWR9IG9iaiB0aGUgbm9kZVxcbiAgICovXFxuXFx0XFx0aXNfaGlkZGVuOiBmdW5jdGlvbiBpc19oaWRkZW4ob2JqKSB7XFxuXFx0XFx0XFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xcblxcdFxcdFxcdHJldHVybiBvYmouc3RhdGUuaGlkZGVuID09PSB0cnVlO1xcblxcdFxcdH0sXFxuXFx0XFx0LyoqXFxuICAgKiBoaWRlcyBhIG5vZGUgLSBpdCBpcyBzdGlsbCBpbiB0aGUgc3RydWN0dXJlIGJ1dCB3aWxsIG5vdCBiZSB2aXNpYmxlXFxuICAgKiBAbmFtZSBoaWRlX25vZGUob2JqKVxcbiAgICogQHBhcmFtIHttaXhlZH0gb2JqIHRoZSBub2RlIHRvIGhpZGVcXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2tpcF9yZWRyYXcgaW50ZXJuYWwgcGFyYW1ldGVyIGNvbnRyb2xsaW5nIGlmIHJlZHJhdyBpcyBjYWxsZWRcXG4gICAqIEB0cmlnZ2VyIGhpZGVfbm9kZS5qc3RyZWVcXG4gICAqL1xcblxcdFxcdGhpZGVfbm9kZTogZnVuY3Rpb24gaGlkZV9ub2RlKG9iaiwgc2tpcF9yZWRyYXcpIHtcXG5cXHRcXHRcXHR2YXIgdDEsIHQyO1xcblxcdFxcdFxcdGlmICgkLmlzQXJyYXkob2JqKSkge1xcblxcdFxcdFxcdFxcdG9iaiA9IG9iai5zbGljZSgpO1xcblxcdFxcdFxcdFxcdGZvciAodDEgPSAwLCB0MiA9IG9iai5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmhpZGVfbm9kZShvYmpbdDFdLCB0cnVlKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aWYgKCFza2lwX3JlZHJhdykge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMucmVkcmF3KCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XFxuXFx0XFx0XFx0aWYgKCFvYmogfHwgb2JqLmlkID09PSAkLmpzdHJlZS5yb290KSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoIW9iai5zdGF0ZS5oaWRkZW4pIHtcXG5cXHRcXHRcXHRcXHRvYmouc3RhdGUuaGlkZGVuID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHR0aGlzLl9ub2RlX2NoYW5nZWQob2JqLnBhcmVudCk7XFxuXFx0XFx0XFx0XFx0aWYgKCFza2lwX3JlZHJhdykge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMucmVkcmF3KCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdC8qKlxcbiAgICAgKiB0cmlnZ2VyZWQgd2hlbiBhbiBub2RlIGlzIGhpZGRlblxcbiAgICAgKiBAZXZlbnRcXG4gICAgICogQG5hbWUgaGlkZV9ub2RlLmpzdHJlZVxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZSB0aGUgaGlkZGVuIG5vZGVcXG4gICAgICovXFxuXFx0XFx0XFx0XFx0dGhpcy50cmlnZ2VyKCdoaWRlX25vZGUnLCB7ICdub2RlJzogb2JqIH0pO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogc2hvd3MgYSBub2RlXFxuICAgKiBAbmFtZSBzaG93X25vZGUob2JqKVxcbiAgICogQHBhcmFtIHttaXhlZH0gb2JqIHRoZSBub2RlIHRvIHNob3dcXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2tpcF9yZWRyYXcgaW50ZXJuYWwgcGFyYW1ldGVyIGNvbnRyb2xsaW5nIGlmIHJlZHJhdyBpcyBjYWxsZWRcXG4gICAqIEB0cmlnZ2VyIHNob3dfbm9kZS5qc3RyZWVcXG4gICAqL1xcblxcdFxcdHNob3dfbm9kZTogZnVuY3Rpb24gc2hvd19ub2RlKG9iaiwgc2tpcF9yZWRyYXcpIHtcXG5cXHRcXHRcXHR2YXIgdDEsIHQyO1xcblxcdFxcdFxcdGlmICgkLmlzQXJyYXkob2JqKSkge1xcblxcdFxcdFxcdFxcdG9iaiA9IG9iai5zbGljZSgpO1xcblxcdFxcdFxcdFxcdGZvciAodDEgPSAwLCB0MiA9IG9iai5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnNob3dfbm9kZShvYmpbdDFdLCB0cnVlKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aWYgKCFza2lwX3JlZHJhdykge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMucmVkcmF3KCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XFxuXFx0XFx0XFx0aWYgKCFvYmogfHwgb2JqLmlkID09PSAkLmpzdHJlZS5yb290KSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAob2JqLnN0YXRlLmhpZGRlbikge1xcblxcdFxcdFxcdFxcdG9iai5zdGF0ZS5oaWRkZW4gPSBmYWxzZTtcXG5cXHRcXHRcXHRcXHR0aGlzLl9ub2RlX2NoYW5nZWQob2JqLnBhcmVudCk7XFxuXFx0XFx0XFx0XFx0aWYgKCFza2lwX3JlZHJhdykge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMucmVkcmF3KCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdC8qKlxcbiAgICAgKiB0cmlnZ2VyZWQgd2hlbiBhbiBub2RlIGlzIHNob3duXFxuICAgICAqIEBldmVudFxcbiAgICAgKiBAbmFtZSBzaG93X25vZGUuanN0cmVlXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIHRoZSBzaG93biBub2RlXFxuICAgICAqL1xcblxcdFxcdFxcdFxcdHRoaXMudHJpZ2dlcignc2hvd19ub2RlJywgeyAnbm9kZSc6IG9iaiB9KTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIGhpZGVzIGFsbCBub2Rlc1xcbiAgICogQG5hbWUgaGlkZV9hbGwoKVxcbiAgICogQHRyaWdnZXIgaGlkZV9hbGwuanN0cmVlXFxuICAgKi9cXG5cXHRcXHRoaWRlX2FsbDogZnVuY3Rpb24gaGlkZV9hbGwoc2tpcF9yZWRyYXcpIHtcXG5cXHRcXHRcXHR2YXIgaSxcXG5cXHRcXHRcXHQgICAgbSA9IHRoaXMuX21vZGVsLmRhdGEsXFxuXFx0XFx0XFx0ICAgIGlkcyA9IFtdO1xcblxcdFxcdFxcdGZvciAoaSBpbiBtKSB7XFxuXFx0XFx0XFx0XFx0aWYgKG0uaGFzT3duUHJvcGVydHkoaSkgJiYgaSAhPT0gJC5qc3RyZWUucm9vdCAmJiAhbVtpXS5zdGF0ZS5oaWRkZW4pIHtcXG5cXHRcXHRcXHRcXHRcXHRtW2ldLnN0YXRlLmhpZGRlbiA9IHRydWU7XFxuXFx0XFx0XFx0XFx0XFx0aWRzLnB1c2goaSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR0aGlzLl9tb2RlbC5mb3JjZV9mdWxsX3JlZHJhdyA9IHRydWU7XFxuXFx0XFx0XFx0aWYgKCFza2lwX3JlZHJhdykge1xcblxcdFxcdFxcdFxcdHRoaXMucmVkcmF3KCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdC8qKlxcbiAgICAqIHRyaWdnZXJlZCB3aGVuIGFsbCBub2RlcyBhcmUgaGlkZGVuXFxuICAgICogQGV2ZW50XFxuICAgICogQG5hbWUgaGlkZV9hbGwuanN0cmVlXFxuICAgICogQHBhcmFtIHtBcnJheX0gbm9kZXMgdGhlIElEcyBvZiBhbGwgaGlkZGVuIG5vZGVzXFxuICAgICovXFxuXFx0XFx0XFx0dGhpcy50cmlnZ2VyKCdoaWRlX2FsbCcsIHsgJ25vZGVzJzogaWRzIH0pO1xcblxcdFxcdFxcdHJldHVybiBpZHM7XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIHNob3dzIGFsbCBub2Rlc1xcbiAgICogQG5hbWUgc2hvd19hbGwoKVxcbiAgICogQHRyaWdnZXIgc2hvd19hbGwuanN0cmVlXFxuICAgKi9cXG5cXHRcXHRzaG93X2FsbDogZnVuY3Rpb24gc2hvd19hbGwoc2tpcF9yZWRyYXcpIHtcXG5cXHRcXHRcXHR2YXIgaSxcXG5cXHRcXHRcXHQgICAgbSA9IHRoaXMuX21vZGVsLmRhdGEsXFxuXFx0XFx0XFx0ICAgIGlkcyA9IFtdO1xcblxcdFxcdFxcdGZvciAoaSBpbiBtKSB7XFxuXFx0XFx0XFx0XFx0aWYgKG0uaGFzT3duUHJvcGVydHkoaSkgJiYgaSAhPT0gJC5qc3RyZWUucm9vdCAmJiBtW2ldLnN0YXRlLmhpZGRlbikge1xcblxcdFxcdFxcdFxcdFxcdG1baV0uc3RhdGUuaGlkZGVuID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0XFx0aWRzLnB1c2goaSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR0aGlzLl9tb2RlbC5mb3JjZV9mdWxsX3JlZHJhdyA9IHRydWU7XFxuXFx0XFx0XFx0aWYgKCFza2lwX3JlZHJhdykge1xcblxcdFxcdFxcdFxcdHRoaXMucmVkcmF3KCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdC8qKlxcbiAgICAqIHRyaWdnZXJlZCB3aGVuIGFsbCBub2RlcyBhcmUgc2hvd25cXG4gICAgKiBAZXZlbnRcXG4gICAgKiBAbmFtZSBzaG93X2FsbC5qc3RyZWVcXG4gICAgKiBAcGFyYW0ge0FycmF5fSBub2RlcyB0aGUgSURzIG9mIGFsbCBzaG93biBub2Rlc1xcbiAgICAqL1xcblxcdFxcdFxcdHRoaXMudHJpZ2dlcignc2hvd19hbGwnLCB7ICdub2Rlcyc6IGlkcyB9KTtcXG5cXHRcXHRcXHRyZXR1cm4gaWRzO1xcblxcdFxcdH0sXFxuXFx0XFx0LyoqXFxuICAgKiBjYWxsZWQgd2hlbiBhIG5vZGUgaXMgc2VsZWN0ZWQgYnkgdGhlIHVzZXIuIFVzZWQgaW50ZXJuYWxseS5cXG4gICAqIEBwcml2YXRlXFxuICAgKiBAbmFtZSBhY3RpdmF0ZV9ub2RlKG9iaiwgZSlcXG4gICAqIEBwYXJhbSB7bWl4ZWR9IG9iaiB0aGUgbm9kZVxcbiAgICogQHBhcmFtIHtPYmplY3R9IGUgdGhlIHJlbGF0ZWQgZXZlbnRcXG4gICAqIEB0cmlnZ2VyIGFjdGl2YXRlX25vZGUuanN0cmVlLCBjaGFuZ2VkLmpzdHJlZVxcbiAgICovXFxuXFx0XFx0YWN0aXZhdGVfbm9kZTogZnVuY3Rpb24gYWN0aXZhdGVfbm9kZShvYmosIGUpIHtcXG5cXHRcXHRcXHRpZiAodGhpcy5pc19kaXNhYmxlZChvYmopKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoIWUgfHwgKHR5cGVvZiBlID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihlKSkgIT09ICdvYmplY3QnKSB7XFxuXFx0XFx0XFx0XFx0ZSA9IHt9O1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBlbnN1cmUgbGFzdF9jbGlja2VkIGlzIHN0aWxsIGluIHRoZSBET00sIG1ha2UgaXQgZnJlc2ggKG1heWJlIGl0IHdhcyBtb3ZlZD8pIGFuZCBtYWtlIHN1cmUgaXQgaXMgc3RpbGwgc2VsZWN0ZWQsIGlmIG5vdCAtIG1ha2UgbGFzdF9jbGlja2VkIHRoZSBsYXN0IHNlbGVjdGVkIG5vZGVcXG5cXHRcXHRcXHR0aGlzLl9kYXRhLmNvcmUubGFzdF9jbGlja2VkID0gdGhpcy5fZGF0YS5jb3JlLmxhc3RfY2xpY2tlZCAmJiB0aGlzLl9kYXRhLmNvcmUubGFzdF9jbGlja2VkLmlkICE9PSB1bmRlZmluZWQgPyB0aGlzLmdldF9ub2RlKHRoaXMuX2RhdGEuY29yZS5sYXN0X2NsaWNrZWQuaWQpIDogbnVsbDtcXG5cXHRcXHRcXHRpZiAodGhpcy5fZGF0YS5jb3JlLmxhc3RfY2xpY2tlZCAmJiAhdGhpcy5fZGF0YS5jb3JlLmxhc3RfY2xpY2tlZC5zdGF0ZS5zZWxlY3RlZCkge1xcblxcdFxcdFxcdFxcdHRoaXMuX2RhdGEuY29yZS5sYXN0X2NsaWNrZWQgPSBudWxsO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoIXRoaXMuX2RhdGEuY29yZS5sYXN0X2NsaWNrZWQgJiYgdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdHRoaXMuX2RhdGEuY29yZS5sYXN0X2NsaWNrZWQgPSB0aGlzLmdldF9ub2RlKHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZFt0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQubGVuZ3RoIC0gMV0pO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIXRoaXMuc2V0dGluZ3MuY29yZS5tdWx0aXBsZSB8fCAhZS5tZXRhS2V5ICYmICFlLmN0cmxLZXkgJiYgIWUuc2hpZnRLZXkgfHwgZS5zaGlmdEtleSAmJiAoIXRoaXMuX2RhdGEuY29yZS5sYXN0X2NsaWNrZWQgfHwgIXRoaXMuZ2V0X3BhcmVudChvYmopIHx8IHRoaXMuZ2V0X3BhcmVudChvYmopICE9PSB0aGlzLl9kYXRhLmNvcmUubGFzdF9jbGlja2VkLnBhcmVudCkpIHtcXG5cXHRcXHRcXHRcXHRpZiAoIXRoaXMuc2V0dGluZ3MuY29yZS5tdWx0aXBsZSAmJiAoZS5tZXRhS2V5IHx8IGUuY3RybEtleSB8fCBlLnNoaWZ0S2V5KSAmJiB0aGlzLmlzX3NlbGVjdGVkKG9iaikpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmRlc2VsZWN0X25vZGUob2JqLCBmYWxzZSwgZSk7XFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmRlc2VsZWN0X2FsbCh0cnVlKTtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnNlbGVjdF9ub2RlKG9iaiwgZmFsc2UsIGZhbHNlLCBlKTtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9kYXRhLmNvcmUubGFzdF9jbGlja2VkID0gdGhpcy5nZXRfbm9kZShvYmopO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdGlmIChlLnNoaWZ0S2V5KSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIG8gPSB0aGlzLmdldF9ub2RlKG9iaikuaWQsXFxuXFx0XFx0XFx0XFx0XFx0ICAgIGwgPSB0aGlzLl9kYXRhLmNvcmUubGFzdF9jbGlja2VkLmlkLFxcblxcdFxcdFxcdFxcdFxcdCAgICBwID0gdGhpcy5nZXRfbm9kZSh0aGlzLl9kYXRhLmNvcmUubGFzdF9jbGlja2VkLnBhcmVudCkuY2hpbGRyZW4sXFxuXFx0XFx0XFx0XFx0XFx0ICAgIGMgPSBmYWxzZSxcXG5cXHRcXHRcXHRcXHRcXHQgICAgaSxcXG5cXHRcXHRcXHRcXHRcXHQgICAgajtcXG5cXHRcXHRcXHRcXHRcXHRmb3IgKGkgPSAwLCBqID0gcC5sZW5ndGg7IGkgPCBqOyBpICs9IDEpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBzZXBhcmF0ZSBJRnMgd29yayB3aGVtIG8gYW5kIGwgYXJlIHRoZSBzYW1lXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKHBbaV0gPT09IG8pIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjID0gIWM7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChwW2ldID09PSBsKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YyA9ICFjO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIXRoaXMuaXNfZGlzYWJsZWQocFtpXSkgJiYgKGMgfHwgcFtpXSA9PT0gbyB8fCBwW2ldID09PSBsKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICghdGhpcy5pc19oaWRkZW4ocFtpXSkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLnNlbGVjdF9ub2RlKHBbaV0sIHRydWUsIGZhbHNlLCBlKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLmRlc2VsZWN0X25vZGUocFtpXSwgdHJ1ZSwgZSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnRyaWdnZXIoJ2NoYW5nZWQnLCB7ICdhY3Rpb24nOiAnc2VsZWN0X25vZGUnLCAnbm9kZSc6IHRoaXMuZ2V0X25vZGUob2JqKSwgJ3NlbGVjdGVkJzogdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLCAnZXZlbnQnOiBlIH0pO1xcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCF0aGlzLmlzX3NlbGVjdGVkKG9iaikpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLnNlbGVjdF9ub2RlKG9iaiwgZmFsc2UsIGZhbHNlLCBlKTtcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuZGVzZWxlY3Rfbm9kZShvYmosIGZhbHNlLCBlKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHQvKipcXG4gICAgKiB0cmlnZ2VyZWQgd2hlbiBhbiBub2RlIGlzIGNsaWNrZWQgb3IgaW50ZXJjYXRlZCB3aXRoIGJ5IHRoZSB1c2VyXFxuICAgICogQGV2ZW50XFxuICAgICogQG5hbWUgYWN0aXZhdGVfbm9kZS5qc3RyZWVcXG4gICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZVxcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCB0aGUgb29yaWdpbmFsIGV2ZW50IChpZiBhbnkpIHdoaWNoIHRyaWdnZXJlZCB0aGUgY2FsbCAobWF5IGJlIGFuIGVtcHR5IG9iamVjdClcXG4gICAgKi9cXG5cXHRcXHRcXHR0aGlzLnRyaWdnZXIoJ2FjdGl2YXRlX25vZGUnLCB7ICdub2RlJzogdGhpcy5nZXRfbm9kZShvYmopLCAnZXZlbnQnOiBlIH0pO1xcblxcdFxcdH0sXFxuXFx0XFx0LyoqXFxuICAgKiBhcHBsaWVzIHRoZSBob3ZlciBzdGF0ZSBvbiBhIG5vZGUsIGNhbGxlZCB3aGVuIGEgbm9kZSBpcyBob3ZlcmVkIGJ5IHRoZSB1c2VyLiBVc2VkIGludGVybmFsbHkuXFxuICAgKiBAcHJpdmF0ZVxcbiAgICogQG5hbWUgaG92ZXJfbm9kZShvYmopXFxuICAgKiBAcGFyYW0ge21peGVkfSBvYmpcXG4gICAqIEB0cmlnZ2VyIGhvdmVyX25vZGUuanN0cmVlXFxuICAgKi9cXG5cXHRcXHRob3Zlcl9ub2RlOiBmdW5jdGlvbiBob3Zlcl9ub2RlKG9iaikge1xcblxcdFxcdFxcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKTtcXG5cXHRcXHRcXHRpZiAoIW9iaiB8fCAhb2JqLmxlbmd0aCB8fCBvYmouY2hpbGRyZW4oJy5qc3RyZWUtaG92ZXJlZCcpLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0dmFyIG8gPSB0aGlzLmVsZW1lbnQuZmluZCgnLmpzdHJlZS1ob3ZlcmVkJyksXFxuXFx0XFx0XFx0ICAgIHQgPSB0aGlzLmVsZW1lbnQ7XFxuXFx0XFx0XFx0aWYgKG8gJiYgby5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLmRlaG92ZXJfbm9kZShvKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0b2JqLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLmFkZENsYXNzKCdqc3RyZWUtaG92ZXJlZCcpO1xcblxcdFxcdFxcdC8qKlxcbiAgICAqIHRyaWdnZXJlZCB3aGVuIGFuIG5vZGUgaXMgaG92ZXJlZFxcbiAgICAqIEBldmVudFxcbiAgICAqIEBuYW1lIGhvdmVyX25vZGUuanN0cmVlXFxuICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGVcXG4gICAgKi9cXG5cXHRcXHRcXHR0aGlzLnRyaWdnZXIoJ2hvdmVyX25vZGUnLCB7ICdub2RlJzogdGhpcy5nZXRfbm9kZShvYmopIH0pO1xcblxcdFxcdFxcdHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdHQuYXR0cignYXJpYS1hY3RpdmVkZXNjZW5kYW50Jywgb2JqWzBdLmlkKTtcXG5cXHRcXHRcXHR9LCAwKTtcXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogcmVtb3ZlcyB0aGUgaG92ZXIgc3RhdGUgZnJvbSBhIG5vZGVjYWxsZWQgd2hlbiBhIG5vZGUgaXMgbm8gbG9uZ2VyIGhvdmVyZWQgYnkgdGhlIHVzZXIuIFVzZWQgaW50ZXJuYWxseS5cXG4gICAqIEBwcml2YXRlXFxuICAgKiBAbmFtZSBkZWhvdmVyX25vZGUob2JqKVxcbiAgICogQHBhcmFtIHttaXhlZH0gb2JqXFxuICAgKiBAdHJpZ2dlciBkZWhvdmVyX25vZGUuanN0cmVlXFxuICAgKi9cXG5cXHRcXHRkZWhvdmVyX25vZGU6IGZ1bmN0aW9uIGRlaG92ZXJfbm9kZShvYmopIHtcXG5cXHRcXHRcXHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSk7XFxuXFx0XFx0XFx0aWYgKCFvYmogfHwgIW9iai5sZW5ndGggfHwgIW9iai5jaGlsZHJlbignLmpzdHJlZS1ob3ZlcmVkJykubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRvYmouY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykucmVtb3ZlQ2xhc3MoJ2pzdHJlZS1ob3ZlcmVkJyk7XFxuXFx0XFx0XFx0LyoqXFxuICAgICogdHJpZ2dlcmVkIHdoZW4gYW4gbm9kZSBpcyBubyBsb25nZXIgaG92ZXJlZFxcbiAgICAqIEBldmVudFxcbiAgICAqIEBuYW1lIGRlaG92ZXJfbm9kZS5qc3RyZWVcXG4gICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZVxcbiAgICAqL1xcblxcdFxcdFxcdHRoaXMudHJpZ2dlcignZGVob3Zlcl9ub2RlJywgeyAnbm9kZSc6IHRoaXMuZ2V0X25vZGUob2JqKSB9KTtcXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogc2VsZWN0IGEgbm9kZVxcbiAgICogQG5hbWUgc2VsZWN0X25vZGUob2JqIFssIHN1cHJlc3NfZXZlbnQsIHByZXZlbnRfb3Blbl0pXFxuICAgKiBAcGFyYW0ge21peGVkfSBvYmogYW4gYXJyYXkgY2FuIGJlIHVzZWQgdG8gc2VsZWN0IG11bHRpcGxlIG5vZGVzXFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHN1cHJlc3NfZXZlbnQgaWYgc2V0IHRvIGB0cnVlYCB0aGUgYGNoYW5nZWQuanN0cmVlYCBldmVudCB3b24ndCBiZSB0cmlnZ2VyZWRcXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gcHJldmVudF9vcGVuIGlmIHNldCB0byBgdHJ1ZWAgcGFyZW50cyBvZiB0aGUgc2VsZWN0ZWQgbm9kZSB3b24ndCBiZSBvcGVuZWRcXG4gICAqIEB0cmlnZ2VyIHNlbGVjdF9ub2RlLmpzdHJlZSwgY2hhbmdlZC5qc3RyZWVcXG4gICAqL1xcblxcdFxcdHNlbGVjdF9ub2RlOiBmdW5jdGlvbiBzZWxlY3Rfbm9kZShvYmosIHN1cHJlc3NfZXZlbnQsIHByZXZlbnRfb3BlbiwgZSkge1xcblxcdFxcdFxcdHZhciBkb20sIHQxLCB0MiwgdGg7XFxuXFx0XFx0XFx0aWYgKCQuaXNBcnJheShvYmopKSB7XFxuXFx0XFx0XFx0XFx0b2JqID0gb2JqLnNsaWNlKCk7XFxuXFx0XFx0XFx0XFx0Zm9yICh0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuc2VsZWN0X25vZGUob2JqW3QxXSwgc3VwcmVzc19ldmVudCwgcHJldmVudF9vcGVuLCBlKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXHRcXHRcXHRpZiAoIW9iaiB8fCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGRvbSA9IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKTtcXG5cXHRcXHRcXHRpZiAoIW9iai5zdGF0ZS5zZWxlY3RlZCkge1xcblxcdFxcdFxcdFxcdG9iai5zdGF0ZS5zZWxlY3RlZCA9IHRydWU7XFxuXFx0XFx0XFx0XFx0dGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLnB1c2gob2JqLmlkKTtcXG5cXHRcXHRcXHRcXHRpZiAoIXByZXZlbnRfb3Blbikge1xcblxcdFxcdFxcdFxcdFxcdGRvbSA9IHRoaXMuX29wZW5fdG8ob2JqKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aWYgKGRvbSAmJiBkb20ubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZG9tLmF0dHIoJ2FyaWEtc2VsZWN0ZWQnLCB0cnVlKS5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5hZGRDbGFzcygnanN0cmVlLWNsaWNrZWQnKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0LyoqXFxuICAgICAqIHRyaWdnZXJlZCB3aGVuIGFuIG5vZGUgaXMgc2VsZWN0ZWRcXG4gICAgICogQGV2ZW50XFxuICAgICAqIEBuYW1lIHNlbGVjdF9ub2RlLmpzdHJlZVxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZVxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBzZWxlY3RlZCB0aGUgY3VycmVudCBzZWxlY3Rpb25cXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IHRoZSBldmVudCAoaWYgYW55KSB0aGF0IHRyaWdnZXJlZCB0aGlzIHNlbGVjdF9ub2RlXFxuICAgICAqL1xcblxcdFxcdFxcdFxcdHRoaXMudHJpZ2dlcignc2VsZWN0X25vZGUnLCB7ICdub2RlJzogb2JqLCAnc2VsZWN0ZWQnOiB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQsICdldmVudCc6IGUgfSk7XFxuXFx0XFx0XFx0XFx0aWYgKCFzdXByZXNzX2V2ZW50KSB7XFxuXFx0XFx0XFx0XFx0XFx0LyoqXFxuICAgICAgKiB0cmlnZ2VyZWQgd2hlbiBzZWxlY3Rpb24gY2hhbmdlc1xcbiAgICAgICogQGV2ZW50XFxuICAgICAgKiBAbmFtZSBjaGFuZ2VkLmpzdHJlZVxcbiAgICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGVcXG4gICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24gdGhlIGFjdGlvbiB0aGF0IGNhdXNlZCB0aGUgc2VsZWN0aW9uIHRvIGNoYW5nZVxcbiAgICAgICogQHBhcmFtIHtBcnJheX0gc2VsZWN0ZWQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uXFxuICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgdGhlIGV2ZW50IChpZiBhbnkpIHRoYXQgdHJpZ2dlcmVkIHRoaXMgY2hhbmdlZCBldmVudFxcbiAgICAgICovXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy50cmlnZ2VyKCdjaGFuZ2VkJywgeyAnYWN0aW9uJzogJ3NlbGVjdF9ub2RlJywgJ25vZGUnOiBvYmosICdzZWxlY3RlZCc6IHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZCwgJ2V2ZW50JzogZSB9KTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFx0XFx0LyoqXFxuICAgKiBkZXNlbGVjdCBhIG5vZGVcXG4gICAqIEBuYW1lIGRlc2VsZWN0X25vZGUob2JqIFssIHN1cHJlc3NfZXZlbnRdKVxcbiAgICogQHBhcmFtIHttaXhlZH0gb2JqIGFuIGFycmF5IGNhbiBiZSB1c2VkIHRvIGRlc2VsZWN0IG11bHRpcGxlIG5vZGVzXFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHN1cHJlc3NfZXZlbnQgaWYgc2V0IHRvIGB0cnVlYCB0aGUgYGNoYW5nZWQuanN0cmVlYCBldmVudCB3b24ndCBiZSB0cmlnZ2VyZWRcXG4gICAqIEB0cmlnZ2VyIGRlc2VsZWN0X25vZGUuanN0cmVlLCBjaGFuZ2VkLmpzdHJlZVxcbiAgICovXFxuXFx0XFx0ZGVzZWxlY3Rfbm9kZTogZnVuY3Rpb24gZGVzZWxlY3Rfbm9kZShvYmosIHN1cHJlc3NfZXZlbnQsIGUpIHtcXG5cXHRcXHRcXHR2YXIgdDEsIHQyLCBkb207XFxuXFx0XFx0XFx0aWYgKCQuaXNBcnJheShvYmopKSB7XFxuXFx0XFx0XFx0XFx0b2JqID0gb2JqLnNsaWNlKCk7XFxuXFx0XFx0XFx0XFx0Zm9yICh0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuZGVzZWxlY3Rfbm9kZShvYmpbdDFdLCBzdXByZXNzX2V2ZW50LCBlKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXHRcXHRcXHRpZiAoIW9iaiB8fCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGRvbSA9IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKTtcXG5cXHRcXHRcXHRpZiAob2JqLnN0YXRlLnNlbGVjdGVkKSB7XFxuXFx0XFx0XFx0XFx0b2JqLnN0YXRlLnNlbGVjdGVkID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0dGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkID0gJC52YWthdGEuYXJyYXlfcmVtb3ZlX2l0ZW0odGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLCBvYmouaWQpO1xcblxcdFxcdFxcdFxcdGlmIChkb20ubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZG9tLmF0dHIoJ2FyaWEtc2VsZWN0ZWQnLCBmYWxzZSkuY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykucmVtb3ZlQ2xhc3MoJ2pzdHJlZS1jbGlja2VkJyk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdC8qKlxcbiAgICAgKiB0cmlnZ2VyZWQgd2hlbiBhbiBub2RlIGlzIGRlc2VsZWN0ZWRcXG4gICAgICogQGV2ZW50XFxuICAgICAqIEBuYW1lIGRlc2VsZWN0X25vZGUuanN0cmVlXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlXFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHNlbGVjdGVkIHRoZSBjdXJyZW50IHNlbGVjdGlvblxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgdGhlIGV2ZW50IChpZiBhbnkpIHRoYXQgdHJpZ2dlcmVkIHRoaXMgZGVzZWxlY3Rfbm9kZVxcbiAgICAgKi9cXG5cXHRcXHRcXHRcXHR0aGlzLnRyaWdnZXIoJ2Rlc2VsZWN0X25vZGUnLCB7ICdub2RlJzogb2JqLCAnc2VsZWN0ZWQnOiB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQsICdldmVudCc6IGUgfSk7XFxuXFx0XFx0XFx0XFx0aWYgKCFzdXByZXNzX2V2ZW50KSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy50cmlnZ2VyKCdjaGFuZ2VkJywgeyAnYWN0aW9uJzogJ2Rlc2VsZWN0X25vZGUnLCAnbm9kZSc6IG9iaiwgJ3NlbGVjdGVkJzogdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLCAnZXZlbnQnOiBlIH0pO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIHNlbGVjdCBhbGwgbm9kZXMgaW4gdGhlIHRyZWVcXG4gICAqIEBuYW1lIHNlbGVjdF9hbGwoW3N1cHJlc3NfZXZlbnRdKVxcbiAgICogQHBhcmFtIHtCb29sZWFufSBzdXByZXNzX2V2ZW50IGlmIHNldCB0byBgdHJ1ZWAgdGhlIGBjaGFuZ2VkLmpzdHJlZWAgZXZlbnQgd29uJ3QgYmUgdHJpZ2dlcmVkXFxuICAgKiBAdHJpZ2dlciBzZWxlY3RfYWxsLmpzdHJlZSwgY2hhbmdlZC5qc3RyZWVcXG4gICAqL1xcblxcdFxcdHNlbGVjdF9hbGw6IGZ1bmN0aW9uIHNlbGVjdF9hbGwoc3VwcmVzc19ldmVudCkge1xcblxcdFxcdFxcdHZhciB0bXAgPSB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQuY29uY2F0KFtdKSxcXG5cXHRcXHRcXHQgICAgaSxcXG5cXHRcXHRcXHQgICAgajtcXG5cXHRcXHRcXHR0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQgPSB0aGlzLl9tb2RlbC5kYXRhWyQuanN0cmVlLnJvb3RdLmNoaWxkcmVuX2QuY29uY2F0KCk7XFxuXFx0XFx0XFx0Zm9yIChpID0gMCwgaiA9IHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRpZiAodGhpcy5fbW9kZWwuZGF0YVt0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWRbaV1dKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fbW9kZWwuZGF0YVt0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWRbaV1dLnN0YXRlLnNlbGVjdGVkID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHRoaXMucmVkcmF3KHRydWUpO1xcblxcdFxcdFxcdC8qKlxcbiAgICAqIHRyaWdnZXJlZCB3aGVuIGFsbCBub2RlcyBhcmUgc2VsZWN0ZWRcXG4gICAgKiBAZXZlbnRcXG4gICAgKiBAbmFtZSBzZWxlY3RfYWxsLmpzdHJlZVxcbiAgICAqIEBwYXJhbSB7QXJyYXl9IHNlbGVjdGVkIHRoZSBjdXJyZW50IHNlbGVjdGlvblxcbiAgICAqL1xcblxcdFxcdFxcdHRoaXMudHJpZ2dlcignc2VsZWN0X2FsbCcsIHsgJ3NlbGVjdGVkJzogdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkIH0pO1xcblxcdFxcdFxcdGlmICghc3VwcmVzc19ldmVudCkge1xcblxcdFxcdFxcdFxcdHRoaXMudHJpZ2dlcignY2hhbmdlZCcsIHsgJ2FjdGlvbic6ICdzZWxlY3RfYWxsJywgJ3NlbGVjdGVkJzogdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLCAnb2xkX3NlbGVjdGlvbic6IHRtcCB9KTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIGRlc2VsZWN0IGFsbCBzZWxlY3RlZCBub2Rlc1xcbiAgICogQG5hbWUgZGVzZWxlY3RfYWxsKFtzdXByZXNzX2V2ZW50XSlcXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gc3VwcmVzc19ldmVudCBpZiBzZXQgdG8gYHRydWVgIHRoZSBgY2hhbmdlZC5qc3RyZWVgIGV2ZW50IHdvbid0IGJlIHRyaWdnZXJlZFxcbiAgICogQHRyaWdnZXIgZGVzZWxlY3RfYWxsLmpzdHJlZSwgY2hhbmdlZC5qc3RyZWVcXG4gICAqL1xcblxcdFxcdGRlc2VsZWN0X2FsbDogZnVuY3Rpb24gZGVzZWxlY3RfYWxsKHN1cHJlc3NfZXZlbnQpIHtcXG5cXHRcXHRcXHR2YXIgdG1wID0gdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLmNvbmNhdChbXSksXFxuXFx0XFx0XFx0ICAgIGksXFxuXFx0XFx0XFx0ICAgIGo7XFxuXFx0XFx0XFx0Zm9yIChpID0gMCwgaiA9IHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRpZiAodGhpcy5fbW9kZWwuZGF0YVt0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWRbaV1dKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fbW9kZWwuZGF0YVt0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWRbaV1dLnN0YXRlLnNlbGVjdGVkID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQgPSBbXTtcXG5cXHRcXHRcXHR0aGlzLmVsZW1lbnQuZmluZCgnLmpzdHJlZS1jbGlja2VkJykucmVtb3ZlQ2xhc3MoJ2pzdHJlZS1jbGlja2VkJykucGFyZW50KCkuYXR0cignYXJpYS1zZWxlY3RlZCcsIGZhbHNlKTtcXG5cXHRcXHRcXHQvKipcXG4gICAgKiB0cmlnZ2VyZWQgd2hlbiBhbGwgbm9kZXMgYXJlIGRlc2VsZWN0ZWRcXG4gICAgKiBAZXZlbnRcXG4gICAgKiBAbmFtZSBkZXNlbGVjdF9hbGwuanN0cmVlXFxuICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGUgdGhlIHByZXZpb3VzIHNlbGVjdGlvblxcbiAgICAqIEBwYXJhbSB7QXJyYXl9IHNlbGVjdGVkIHRoZSBjdXJyZW50IHNlbGVjdGlvblxcbiAgICAqL1xcblxcdFxcdFxcdHRoaXMudHJpZ2dlcignZGVzZWxlY3RfYWxsJywgeyAnc2VsZWN0ZWQnOiB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQsICdub2RlJzogdG1wIH0pO1xcblxcdFxcdFxcdGlmICghc3VwcmVzc19ldmVudCkge1xcblxcdFxcdFxcdFxcdHRoaXMudHJpZ2dlcignY2hhbmdlZCcsIHsgJ2FjdGlvbic6ICdkZXNlbGVjdF9hbGwnLCAnc2VsZWN0ZWQnOiB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQsICdvbGRfc2VsZWN0aW9uJzogdG1wIH0pO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogY2hlY2tzIGlmIGEgbm9kZSBpcyBzZWxlY3RlZFxcbiAgICogQG5hbWUgaXNfc2VsZWN0ZWQob2JqKVxcbiAgICogQHBhcmFtICB7bWl4ZWR9ICBvYmpcXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XFxuICAgKi9cXG5cXHRcXHRpc19zZWxlY3RlZDogZnVuY3Rpb24gaXNfc2VsZWN0ZWQob2JqKSB7XFxuXFx0XFx0XFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xcblxcdFxcdFxcdGlmICghb2JqIHx8IG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCkge1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIG9iai5zdGF0ZS5zZWxlY3RlZDtcXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogZ2V0IGFuIGFycmF5IG9mIGFsbCBzZWxlY3RlZCBub2Rlc1xcbiAgICogQG5hbWUgZ2V0X3NlbGVjdGVkKFtmdWxsXSlcXG4gICAqIEBwYXJhbSAge21peGVkfSAgZnVsbCBpZiBzZXQgdG8gYHRydWVgIHRoZSByZXR1cm5lZCBhcnJheSB3aWxsIGNvbnNpc3Qgb2YgdGhlIGZ1bGwgbm9kZSBvYmplY3RzLCBvdGhlcndpc2UgLSBvbmx5IElEcyB3aWxsIGJlIHJldHVybmVkXFxuICAgKiBAcmV0dXJuIHtBcnJheX1cXG4gICAqL1xcblxcdFxcdGdldF9zZWxlY3RlZDogZnVuY3Rpb24gZ2V0X3NlbGVjdGVkKGZ1bGwpIHtcXG5cXHRcXHRcXHRyZXR1cm4gZnVsbCA/ICQubWFwKHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZCwgJC5wcm94eShmdW5jdGlvbiAoaSkge1xcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLmdldF9ub2RlKGkpO1xcblxcdFxcdFxcdH0sIHRoaXMpKSA6IHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZC5zbGljZSgpO1xcblxcdFxcdH0sXFxuXFx0XFx0LyoqXFxuICAgKiBnZXQgYW4gYXJyYXkgb2YgYWxsIHRvcCBsZXZlbCBzZWxlY3RlZCBub2RlcyAoaWdub3JpbmcgY2hpbGRyZW4gb2Ygc2VsZWN0ZWQgbm9kZXMpXFxuICAgKiBAbmFtZSBnZXRfdG9wX3NlbGVjdGVkKFtmdWxsXSlcXG4gICAqIEBwYXJhbSAge21peGVkfSAgZnVsbCBpZiBzZXQgdG8gYHRydWVgIHRoZSByZXR1cm5lZCBhcnJheSB3aWxsIGNvbnNpc3Qgb2YgdGhlIGZ1bGwgbm9kZSBvYmplY3RzLCBvdGhlcndpc2UgLSBvbmx5IElEcyB3aWxsIGJlIHJldHVybmVkXFxuICAgKiBAcmV0dXJuIHtBcnJheX1cXG4gICAqL1xcblxcdFxcdGdldF90b3Bfc2VsZWN0ZWQ6IGZ1bmN0aW9uIGdldF90b3Bfc2VsZWN0ZWQoZnVsbCkge1xcblxcdFxcdFxcdHZhciB0bXAgPSB0aGlzLmdldF9zZWxlY3RlZCh0cnVlKSxcXG5cXHRcXHRcXHQgICAgb2JqID0ge30sXFxuXFx0XFx0XFx0ICAgIGksXFxuXFx0XFx0XFx0ICAgIGosXFxuXFx0XFx0XFx0ICAgIGssXFxuXFx0XFx0XFx0ICAgIGw7XFxuXFx0XFx0XFx0Zm9yIChpID0gMCwgaiA9IHRtcC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRvYmpbdG1wW2ldLmlkXSA9IHRtcFtpXTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0Zm9yIChpID0gMCwgaiA9IHRtcC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRmb3IgKGsgPSAwLCBsID0gdG1wW2ldLmNoaWxkcmVuX2QubGVuZ3RoOyBrIDwgbDsgaysrKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKG9ialt0bXBbaV0uY2hpbGRyZW5fZFtrXV0pIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRkZWxldGUgb2JqW3RtcFtpXS5jaGlsZHJlbl9kW2tdXTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR0bXAgPSBbXTtcXG5cXHRcXHRcXHRmb3IgKGkgaW4gb2JqKSB7XFxuXFx0XFx0XFx0XFx0aWYgKG9iai5oYXNPd25Qcm9wZXJ0eShpKSkge1xcblxcdFxcdFxcdFxcdFxcdHRtcC5wdXNoKGkpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIGZ1bGwgPyAkLm1hcCh0bXAsICQucHJveHkoZnVuY3Rpb24gKGkpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5nZXRfbm9kZShpKTtcXG5cXHRcXHRcXHR9LCB0aGlzKSkgOiB0bXA7XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIGdldCBhbiBhcnJheSBvZiBhbGwgYm90dG9tIGxldmVsIHNlbGVjdGVkIG5vZGVzIChpZ25vcmluZyBzZWxlY3RlZCBwYXJlbnRzKVxcbiAgICogQG5hbWUgZ2V0X2JvdHRvbV9zZWxlY3RlZChbZnVsbF0pXFxuICAgKiBAcGFyYW0gIHttaXhlZH0gIGZ1bGwgaWYgc2V0IHRvIGB0cnVlYCB0aGUgcmV0dXJuZWQgYXJyYXkgd2lsbCBjb25zaXN0IG9mIHRoZSBmdWxsIG5vZGUgb2JqZWN0cywgb3RoZXJ3aXNlIC0gb25seSBJRHMgd2lsbCBiZSByZXR1cm5lZFxcbiAgICogQHJldHVybiB7QXJyYXl9XFxuICAgKi9cXG5cXHRcXHRnZXRfYm90dG9tX3NlbGVjdGVkOiBmdW5jdGlvbiBnZXRfYm90dG9tX3NlbGVjdGVkKGZ1bGwpIHtcXG5cXHRcXHRcXHR2YXIgdG1wID0gdGhpcy5nZXRfc2VsZWN0ZWQodHJ1ZSksXFxuXFx0XFx0XFx0ICAgIG9iaiA9IFtdLFxcblxcdFxcdFxcdCAgICBpLFxcblxcdFxcdFxcdCAgICBqO1xcblxcdFxcdFxcdGZvciAoaSA9IDAsIGogPSB0bXAubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCF0bXBbaV0uY2hpbGRyZW4ubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0b2JqLnB1c2godG1wW2ldLmlkKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiBmdWxsID8gJC5tYXAob2JqLCAkLnByb3h5KGZ1bmN0aW9uIChpKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuZ2V0X25vZGUoaSk7XFxuXFx0XFx0XFx0fSwgdGhpcykpIDogb2JqO1xcblxcdFxcdH0sXFxuXFx0XFx0LyoqXFxuICAgKiBnZXRzIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSB0cmVlIHNvIHRoYXQgaXQgY2FuIGJlIHJlc3RvcmVkIGxhdGVyIHdpdGggYHNldF9zdGF0ZShzdGF0ZSlgLiBVc2VkIGludGVybmFsbHkuXFxuICAgKiBAbmFtZSBnZXRfc3RhdGUoKVxcbiAgICogQHByaXZhdGVcXG4gICAqIEByZXR1cm4ge09iamVjdH1cXG4gICAqL1xcblxcdFxcdGdldF9zdGF0ZTogZnVuY3Rpb24gZ2V0X3N0YXRlKCkge1xcblxcdFxcdFxcdHZhciBzdGF0ZSA9IHtcXG5cXHRcXHRcXHRcXHQnY29yZSc6IHtcXG5cXHRcXHRcXHRcXHRcXHQnb3Blbic6IFtdLFxcblxcdFxcdFxcdFxcdFxcdCdzY3JvbGwnOiB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0J2xlZnQnOiB0aGlzLmVsZW1lbnQuc2Nyb2xsTGVmdCgpLFxcblxcdFxcdFxcdFxcdFxcdFxcdCd0b3AnOiB0aGlzLmVsZW1lbnQuc2Nyb2xsVG9wKClcXG5cXHRcXHRcXHRcXHRcXHR9LFxcblxcdFxcdFxcdFxcdFxcdC8qIVxcbiAgICAgJ3RoZW1lcycgOiB7XFxuICAgICBcXHQnbmFtZScgOiB0aGlzLmdldF90aGVtZSgpLFxcbiAgICAgXFx0J2ljb25zJyA6IHRoaXMuX2RhdGEuY29yZS50aGVtZXMuaWNvbnMsXFxuICAgICBcXHQnZG90cycgOiB0aGlzLl9kYXRhLmNvcmUudGhlbWVzLmRvdHNcXG4gICAgIH0sXFxuICAgICAqL1xcblxcdFxcdFxcdFxcdFxcdCdzZWxlY3RlZCc6IFtdXFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0ICAgIGk7XFxuXFx0XFx0XFx0Zm9yIChpIGluIHRoaXMuX21vZGVsLmRhdGEpIHtcXG5cXHRcXHRcXHRcXHRpZiAodGhpcy5fbW9kZWwuZGF0YS5oYXNPd25Qcm9wZXJ0eShpKSkge1xcblxcdFxcdFxcdFxcdFxcdGlmIChpICE9PSAkLmpzdHJlZS5yb290KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKHRoaXMuX21vZGVsLmRhdGFbaV0uc3RhdGUub3BlbmVkKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c3RhdGUuY29yZS5vcGVuLnB1c2goaSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICh0aGlzLl9tb2RlbC5kYXRhW2ldLnN0YXRlLnNlbGVjdGVkKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c3RhdGUuY29yZS5zZWxlY3RlZC5wdXNoKGkpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gc3RhdGU7XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIHNldHMgdGhlIHN0YXRlIG9mIHRoZSB0cmVlLiBVc2VkIGludGVybmFsbHkuXFxuICAgKiBAbmFtZSBzZXRfc3RhdGUoc3RhdGUgWywgY2FsbGJhY2tdKVxcbiAgICogQHByaXZhdGVcXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZSB0aGUgc3RhdGUgdG8gcmVzdG9yZS4gS2VlcCBpbiBtaW5kIHRoaXMgb2JqZWN0IGlzIHBhc3NlZCBieSByZWZlcmVuY2UgYW5kIGpzdHJlZSB3aWxsIG1vZGlmeSBpdC5cXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGFuIG9wdGlvbmFsIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgb25jZSB0aGUgc3RhdGUgaXMgcmVzdG9yZWQuXFxuICAgKiBAdHJpZ2dlciBzZXRfc3RhdGUuanN0cmVlXFxuICAgKi9cXG5cXHRcXHRzZXRfc3RhdGU6IGZ1bmN0aW9uIHNldF9zdGF0ZShzdGF0ZSwgY2FsbGJhY2spIHtcXG5cXHRcXHRcXHRpZiAoc3RhdGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoc3RhdGUuY29yZSkge1xcblxcdFxcdFxcdFxcdFxcdHZhciByZXMsIG4sIHQsIF90aGlzLCBpO1xcblxcdFxcdFxcdFxcdFxcdGlmIChzdGF0ZS5jb3JlLm9wZW4pIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoISQuaXNBcnJheShzdGF0ZS5jb3JlLm9wZW4pIHx8ICFzdGF0ZS5jb3JlLm9wZW4ubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGVsZXRlIHN0YXRlLmNvcmUub3BlbjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLnNldF9zdGF0ZShzdGF0ZSwgY2FsbGJhY2spO1xcblxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5fbG9hZF9ub2RlcyhzdGF0ZS5jb3JlLm9wZW4sIGZ1bmN0aW9uIChub2Rlcykge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoaXMub3Blbl9ub2RlKG5vZGVzLCBmYWxzZSwgMCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGVsZXRlIHN0YXRlLmNvcmUub3BlbjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLnNldF9zdGF0ZShzdGF0ZSwgY2FsbGJhY2spO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmIChzdGF0ZS5jb3JlLnNjcm9sbCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChzdGF0ZS5jb3JlLnNjcm9sbCAmJiBzdGF0ZS5jb3JlLnNjcm9sbC5sZWZ0ICE9PSB1bmRlZmluZWQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLmVsZW1lbnQuc2Nyb2xsTGVmdChzdGF0ZS5jb3JlLnNjcm9sbC5sZWZ0KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKHN0YXRlLmNvcmUuc2Nyb2xsICYmIHN0YXRlLmNvcmUuc2Nyb2xsLnRvcCAhPT0gdW5kZWZpbmVkKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5lbGVtZW50LnNjcm9sbFRvcChzdGF0ZS5jb3JlLnNjcm9sbC50b3ApO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRkZWxldGUgc3RhdGUuY29yZS5zY3JvbGw7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5zZXRfc3RhdGUoc3RhdGUsIGNhbGxiYWNrKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmIChzdGF0ZS5jb3JlLnNlbGVjdGVkKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0X3RoaXMgPSB0aGlzO1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuZGVzZWxlY3RfYWxsKCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0JC5lYWNoKHN0YXRlLmNvcmUuc2VsZWN0ZWQsIGZ1bmN0aW9uIChpLCB2KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0X3RoaXMuc2VsZWN0X25vZGUodiwgZmFsc2UsIHRydWUpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdFxcdFxcdFxcdGRlbGV0ZSBzdGF0ZS5jb3JlLnNlbGVjdGVkO1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuc2V0X3N0YXRlKHN0YXRlLCBjYWxsYmFjayk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRmb3IgKGkgaW4gc3RhdGUpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoc3RhdGUuaGFzT3duUHJvcGVydHkoaSkgJiYgaSAhPT0gXFxcImNvcmVcXFwiICYmICQuaW5BcnJheShpLCB0aGlzLnNldHRpbmdzLnBsdWdpbnMpID09PSAtMSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGRlbGV0ZSBzdGF0ZVtpXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmICgkLmlzRW1wdHlPYmplY3Qoc3RhdGUuY29yZSkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRkZWxldGUgc3RhdGUuY29yZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLnNldF9zdGF0ZShzdGF0ZSwgY2FsbGJhY2spO1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGlmICgkLmlzRW1wdHlPYmplY3Qoc3RhdGUpKSB7XFxuXFx0XFx0XFx0XFx0XFx0c3RhdGUgPSBudWxsO1xcblxcdFxcdFxcdFxcdFxcdGlmIChjYWxsYmFjaykge1xcblxcdFxcdFxcdFxcdFxcdFxcdGNhbGxiYWNrLmNhbGwodGhpcyk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdC8qKlxcbiAgICAgICogdHJpZ2dlcmVkIHdoZW4gYSBgc2V0X3N0YXRlYCBjYWxsIGNvbXBsZXRlc1xcbiAgICAgICogQGV2ZW50XFxuICAgICAgKiBAbmFtZSBzZXRfc3RhdGUuanN0cmVlXFxuICAgICAgKi9cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnRyaWdnZXIoJ3NldF9zdGF0ZScpO1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogcmVmcmVzaGVzIHRoZSB0cmVlIC0gYWxsIG5vZGVzIGFyZSByZWxvYWRlZCB3aXRoIGNhbGxzIHRvIGBsb2FkX25vZGVgLlxcbiAgICogQG5hbWUgcmVmcmVzaCgpXFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNraXBfbG9hZGluZyBhbiBvcHRpb24gdG8gc2tpcCBzaG93aW5nIHRoZSBsb2FkaW5nIGluZGljYXRvclxcbiAgICogQHBhcmFtIHtNaXhlZH0gZm9yZ2V0X3N0YXRlIGlmIHNldCB0byBgdHJ1ZWAgc3RhdGUgd2lsbCBub3QgYmUgcmVhcHBsaWVkLCBpZiBzZXQgdG8gYSBmdW5jdGlvbiAocmVjZWl2aW5nIHRoZSBjdXJyZW50IHN0YXRlIGFzIGFyZ3VtZW50KSB0aGUgcmVzdWx0IG9mIHRoYXQgZnVuY3Rpb24gd2lsbCBiZSB1c2VkIGFzIHN0YXRlXFxuICAgKiBAdHJpZ2dlciByZWZyZXNoLmpzdHJlZVxcbiAgICovXFxuXFx0XFx0cmVmcmVzaDogZnVuY3Rpb24gcmVmcmVzaChza2lwX2xvYWRpbmcsIGZvcmdldF9zdGF0ZSkge1xcblxcdFxcdFxcdHRoaXMuX2RhdGEuY29yZS5zdGF0ZSA9IGZvcmdldF9zdGF0ZSA9PT0gdHJ1ZSA/IHt9IDogdGhpcy5nZXRfc3RhdGUoKTtcXG5cXHRcXHRcXHRpZiAoZm9yZ2V0X3N0YXRlICYmICQuaXNGdW5jdGlvbihmb3JnZXRfc3RhdGUpKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5fZGF0YS5jb3JlLnN0YXRlID0gZm9yZ2V0X3N0YXRlLmNhbGwodGhpcywgdGhpcy5fZGF0YS5jb3JlLnN0YXRlKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0dGhpcy5fY250ID0gMDtcXG5cXHRcXHRcXHR0aGlzLl9tb2RlbC5kYXRhID0ge307XFxuXFx0XFx0XFx0dGhpcy5fbW9kZWwuZGF0YVskLmpzdHJlZS5yb290XSA9IHtcXG5cXHRcXHRcXHRcXHRpZDogJC5qc3RyZWUucm9vdCxcXG5cXHRcXHRcXHRcXHRwYXJlbnQ6IG51bGwsXFxuXFx0XFx0XFx0XFx0cGFyZW50czogW10sXFxuXFx0XFx0XFx0XFx0Y2hpbGRyZW46IFtdLFxcblxcdFxcdFxcdFxcdGNoaWxkcmVuX2Q6IFtdLFxcblxcdFxcdFxcdFxcdHN0YXRlOiB7IGxvYWRlZDogZmFsc2UgfVxcblxcdFxcdFxcdH07XFxuXFx0XFx0XFx0dGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkID0gW107XFxuXFx0XFx0XFx0dGhpcy5fZGF0YS5jb3JlLmxhc3RfY2xpY2tlZCA9IG51bGw7XFxuXFx0XFx0XFx0dGhpcy5fZGF0YS5jb3JlLmZvY3VzZWQgPSBudWxsO1xcblxcblxcdFxcdFxcdHZhciBjID0gdGhpcy5nZXRfY29udGFpbmVyX3VsKClbMF0uY2xhc3NOYW1lO1xcblxcdFxcdFxcdGlmICghc2tpcF9sb2FkaW5nKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5lbGVtZW50Lmh0bWwoXFxcIjxcXFwiICsgXFxcInVsIGNsYXNzPSdcXFwiICsgYyArIFxcXCInIHJvbGU9J2dyb3VwJz48XFxcIiArIFxcXCJsaSBjbGFzcz0nanN0cmVlLWluaXRpYWwtbm9kZSBqc3RyZWUtbG9hZGluZyBqc3RyZWUtbGVhZiBqc3RyZWUtbGFzdCcgcm9sZT0ndHJlZWl0ZW0nIGlkPSdqXFxcIiArIHRoaXMuX2lkICsgXFxcIl9sb2FkaW5nJz48aSBjbGFzcz0nanN0cmVlLWljb24ganN0cmVlLW9jbCc+PC9pPjxcXFwiICsgXFxcImEgY2xhc3M9J2pzdHJlZS1hbmNob3InIGhyZWY9JyMnPjxpIGNsYXNzPSdqc3RyZWUtaWNvbiBqc3RyZWUtdGhlbWVpY29uLWhpZGRlbic+PC9pPlxcXCIgKyB0aGlzLmdldF9zdHJpbmcoXFxcIkxvYWRpbmcgLi4uXFxcIikgKyBcXFwiPC9hPjwvbGk+PC91bD5cXFwiKTtcXG5cXHRcXHRcXHRcXHR0aGlzLmVsZW1lbnQuYXR0cignYXJpYS1hY3RpdmVkZXNjZW5kYW50JywgJ2onICsgdGhpcy5faWQgKyAnX2xvYWRpbmcnKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0dGhpcy5sb2FkX25vZGUoJC5qc3RyZWUucm9vdCwgZnVuY3Rpb24gKG8sIHMpIHtcXG5cXHRcXHRcXHRcXHRpZiAocykge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpWzBdLmNsYXNzTmFtZSA9IGM7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHRoaXMuX2ZpcnN0Q2hpbGQodGhpcy5nZXRfY29udGFpbmVyX3VsKClbMF0pKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5lbGVtZW50LmF0dHIoJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCcsIHRoaXMuX2ZpcnN0Q2hpbGQodGhpcy5nZXRfY29udGFpbmVyX3VsKClbMF0pLmlkKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5zZXRfc3RhdGUoJC5leHRlbmQodHJ1ZSwge30sIHRoaXMuX2RhdGEuY29yZS5zdGF0ZSksIGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHQvKipcXG4gICAgICAgKiB0cmlnZ2VyZWQgd2hlbiBhIGByZWZyZXNoYCBjYWxsIGNvbXBsZXRlc1xcbiAgICAgICAqIEBldmVudFxcbiAgICAgICAqIEBuYW1lIHJlZnJlc2guanN0cmVlXFxuICAgICAgICovXFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy50cmlnZ2VyKCdyZWZyZXNoJyk7XFxuXFx0XFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHRoaXMuX2RhdGEuY29yZS5zdGF0ZSA9IG51bGw7XFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIHJlZnJlc2hlcyBhIG5vZGUgaW4gdGhlIHRyZWUgKHJlbG9hZCBpdHMgY2hpbGRyZW4pIGFsbCBvcGVuZWQgbm9kZXMgaW5zaWRlIHRoYXQgbm9kZSBhcmUgcmVsb2FkZWQgd2l0aCBjYWxscyB0byBgbG9hZF9ub2RlYC5cXG4gICAqIEBuYW1lIHJlZnJlc2hfbm9kZShvYmopXFxuICAgKiBAcGFyYW0gIHttaXhlZH0gb2JqIHRoZSBub2RlXFxuICAgKiBAdHJpZ2dlciByZWZyZXNoX25vZGUuanN0cmVlXFxuICAgKi9cXG5cXHRcXHRyZWZyZXNoX25vZGU6IGZ1bmN0aW9uIHJlZnJlc2hfbm9kZShvYmopIHtcXG5cXHRcXHRcXHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XFxuXFx0XFx0XFx0aWYgKCFvYmogfHwgb2JqLmlkID09PSAkLmpzdHJlZS5yb290KSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR2YXIgb3BlbmVkID0gW10sXFxuXFx0XFx0XFx0ICAgIHRvX2xvYWQgPSBbXSxcXG5cXHRcXHRcXHQgICAgcyA9IHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZC5jb25jYXQoW10pO1xcblxcdFxcdFxcdHRvX2xvYWQucHVzaChvYmouaWQpO1xcblxcdFxcdFxcdGlmIChvYmouc3RhdGUub3BlbmVkID09PSB0cnVlKSB7XFxuXFx0XFx0XFx0XFx0b3BlbmVkLnB1c2gob2JqLmlkKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0dGhpcy5nZXRfbm9kZShvYmosIHRydWUpLmZpbmQoJy5qc3RyZWUtb3BlbicpLmVhY2goZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdHRvX2xvYWQucHVzaCh0aGlzLmlkKTtvcGVuZWQucHVzaCh0aGlzLmlkKTtcXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHR0aGlzLl9sb2FkX25vZGVzKHRvX2xvYWQsICQucHJveHkoZnVuY3Rpb24gKG5vZGVzKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5vcGVuX25vZGUob3BlbmVkLCBmYWxzZSwgMCk7XFxuXFx0XFx0XFx0XFx0dGhpcy5zZWxlY3Rfbm9kZShzKTtcXG5cXHRcXHRcXHRcXHQvKipcXG4gICAgICogdHJpZ2dlcmVkIHdoZW4gYSBub2RlIGlzIHJlZnJlc2hlZFxcbiAgICAgKiBAZXZlbnRcXG4gICAgICogQG5hbWUgcmVmcmVzaF9ub2RlLmpzdHJlZVxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZSAtIHRoZSByZWZyZXNoZWQgbm9kZVxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBub2RlcyAtIGFuIGFycmF5IG9mIHRoZSBJRHMgb2YgdGhlIG5vZGVzIHRoYXQgd2VyZSByZWxvYWRlZFxcbiAgICAgKi9cXG5cXHRcXHRcXHRcXHR0aGlzLnRyaWdnZXIoJ3JlZnJlc2hfbm9kZScsIHsgJ25vZGUnOiBvYmosICdub2Rlcyc6IG5vZGVzIH0pO1xcblxcdFxcdFxcdH0sIHRoaXMpLCBmYWxzZSwgdHJ1ZSk7XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIHNldCAoY2hhbmdlKSB0aGUgSUQgb2YgYSBub2RlXFxuICAgKiBAbmFtZSBzZXRfaWQob2JqLCBpZClcXG4gICAqIEBwYXJhbSAge21peGVkfSBvYmogdGhlIG5vZGVcXG4gICAqIEBwYXJhbSAge1N0cmluZ30gaWQgdGhlIG5ldyBJRFxcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cXG4gICAqIEB0cmlnZ2VyIHNldF9pZC5qc3RyZWVcXG4gICAqL1xcblxcdFxcdHNldF9pZDogZnVuY3Rpb24gc2V0X2lkKG9iaiwgaWQpIHtcXG5cXHRcXHRcXHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XFxuXFx0XFx0XFx0aWYgKCFvYmogfHwgb2JqLmlkID09PSAkLmpzdHJlZS5yb290KSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR2YXIgaSxcXG5cXHRcXHRcXHQgICAgaixcXG5cXHRcXHRcXHQgICAgbSA9IHRoaXMuX21vZGVsLmRhdGEsXFxuXFx0XFx0XFx0ICAgIG9sZCA9IG9iai5pZDtcXG5cXHRcXHRcXHRpZCA9IGlkLnRvU3RyaW5nKCk7XFxuXFx0XFx0XFx0Ly8gdXBkYXRlIHBhcmVudHMgKHJlcGxhY2UgY3VycmVudCBJRCB3aXRoIG5ldyBvbmUgaW4gY2hpbGRyZW4gYW5kIGNoaWxkcmVuX2QpXFxuXFx0XFx0XFx0bVtvYmoucGFyZW50XS5jaGlsZHJlblskLmluQXJyYXkob2JqLmlkLCBtW29iai5wYXJlbnRdLmNoaWxkcmVuKV0gPSBpZDtcXG5cXHRcXHRcXHRmb3IgKGkgPSAwLCBqID0gb2JqLnBhcmVudHMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0bVtvYmoucGFyZW50c1tpXV0uY2hpbGRyZW5fZFskLmluQXJyYXkob2JqLmlkLCBtW29iai5wYXJlbnRzW2ldXS5jaGlsZHJlbl9kKV0gPSBpZDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0Ly8gdXBkYXRlIGNoaWxkcmVuIChyZXBsYWNlIGN1cnJlbnQgSUQgd2l0aCBuZXcgb25lIGluIHBhcmVudCBhbmQgcGFyZW50cylcXG5cXHRcXHRcXHRmb3IgKGkgPSAwLCBqID0gb2JqLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcblxcdFxcdFxcdFxcdG1bb2JqLmNoaWxkcmVuW2ldXS5wYXJlbnQgPSBpZDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0Zm9yIChpID0gMCwgaiA9IG9iai5jaGlsZHJlbl9kLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcblxcdFxcdFxcdFxcdG1bb2JqLmNoaWxkcmVuX2RbaV1dLnBhcmVudHNbJC5pbkFycmF5KG9iai5pZCwgbVtvYmouY2hpbGRyZW5fZFtpXV0ucGFyZW50cyldID0gaWQ7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGkgPSAkLmluQXJyYXkob2JqLmlkLCB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQpO1xcblxcdFxcdFxcdGlmIChpICE9PSAtMSkge1xcblxcdFxcdFxcdFxcdHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZFtpXSA9IGlkO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHQvLyB1cGRhdGUgbW9kZWwgYW5kIG9iaiBpdHNlbGYgKG9iai5pZCwgdGhpcy5fbW9kZWwuZGF0YVtLRVldKVxcblxcdFxcdFxcdGkgPSB0aGlzLmdldF9ub2RlKG9iai5pZCwgdHJ1ZSk7XFxuXFx0XFx0XFx0aWYgKGkpIHtcXG5cXHRcXHRcXHRcXHRpLmF0dHIoJ2lkJywgaWQpOyAvLy5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5hdHRyKCdpZCcsIGlkICsgJ19hbmNob3InKS5lbmQoKS5hdHRyKCdhcmlhLWxhYmVsbGVkYnknLCBpZCArICdfYW5jaG9yJyk7XFxuXFx0XFx0XFx0XFx0aWYgKHRoaXMuZWxlbWVudC5hdHRyKCdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnKSA9PT0gb2JqLmlkKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5lbGVtZW50LmF0dHIoJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCcsIGlkKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGRlbGV0ZSBtW29iai5pZF07XFxuXFx0XFx0XFx0b2JqLmlkID0gaWQ7XFxuXFx0XFx0XFx0b2JqLmxpX2F0dHIuaWQgPSBpZDtcXG5cXHRcXHRcXHRtW2lkXSA9IG9iajtcXG5cXHRcXHRcXHQvKipcXG4gICAgKiB0cmlnZ2VyZWQgd2hlbiBhIG5vZGUgaWQgdmFsdWUgaXMgY2hhbmdlZFxcbiAgICAqIEBldmVudFxcbiAgICAqIEBuYW1lIHNldF9pZC5qc3RyZWVcXG4gICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZVxcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGQgdGhlIG9sZCBpZFxcbiAgICAqL1xcblxcdFxcdFxcdHRoaXMudHJpZ2dlcignc2V0X2lkJywgeyBcXFwibm9kZVxcXCI6IG9iaiwgXFxcIm5ld1xcXCI6IG9iai5pZCwgXFxcIm9sZFxcXCI6IG9sZCB9KTtcXG5cXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogZ2V0IHRoZSB0ZXh0IHZhbHVlIG9mIGEgbm9kZVxcbiAgICogQG5hbWUgZ2V0X3RleHQob2JqKVxcbiAgICogQHBhcmFtICB7bWl4ZWR9IG9iaiB0aGUgbm9kZVxcbiAgICogQHJldHVybiB7U3RyaW5nfVxcbiAgICovXFxuXFx0XFx0Z2V0X3RleHQ6IGZ1bmN0aW9uIGdldF90ZXh0KG9iaikge1xcblxcdFxcdFxcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXHRcXHRcXHRyZXR1cm4gIW9iaiB8fCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QgPyBmYWxzZSA6IG9iai50ZXh0O1xcblxcdFxcdH0sXFxuXFx0XFx0LyoqXFxuICAgKiBzZXQgdGhlIHRleHQgdmFsdWUgb2YgYSBub2RlLiBVc2VkIGludGVybmFsbHksIHBsZWFzZSB1c2UgYHJlbmFtZV9ub2RlKG9iaiwgdmFsKWAuXFxuICAgKiBAcHJpdmF0ZVxcbiAgICogQG5hbWUgc2V0X3RleHQob2JqLCB2YWwpXFxuICAgKiBAcGFyYW0gIHttaXhlZH0gb2JqIHRoZSBub2RlLCB5b3UgY2FuIHBhc3MgYW4gYXJyYXkgdG8gc2V0IHRoZSB0ZXh0IG9uIG11bHRpcGxlIG5vZGVzXFxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHZhbCB0aGUgbmV3IHRleHQgdmFsdWVcXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XFxuICAgKiBAdHJpZ2dlciBzZXRfdGV4dC5qc3RyZWVcXG4gICAqL1xcblxcdFxcdHNldF90ZXh0OiBmdW5jdGlvbiBzZXRfdGV4dChvYmosIHZhbCkge1xcblxcdFxcdFxcdHZhciB0MSwgdDI7XFxuXFx0XFx0XFx0aWYgKCQuaXNBcnJheShvYmopKSB7XFxuXFx0XFx0XFx0XFx0b2JqID0gb2JqLnNsaWNlKCk7XFxuXFx0XFx0XFx0XFx0Zm9yICh0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuc2V0X3RleHQob2JqW3QxXSwgdmFsKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXHRcXHRcXHRpZiAoIW9iaiB8fCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdG9iai50ZXh0ID0gdmFsO1xcblxcdFxcdFxcdGlmICh0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSkubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5yZWRyYXdfbm9kZShvYmouaWQpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHQvKipcXG4gICAgKiB0cmlnZ2VyZWQgd2hlbiBhIG5vZGUgdGV4dCB2YWx1ZSBpcyBjaGFuZ2VkXFxuICAgICogQGV2ZW50XFxuICAgICogQG5hbWUgc2V0X3RleHQuanN0cmVlXFxuICAgICogQHBhcmFtIHtPYmplY3R9IG9ialxcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IHRoZSBuZXcgdmFsdWVcXG4gICAgKi9cXG5cXHRcXHRcXHR0aGlzLnRyaWdnZXIoJ3NldF90ZXh0JywgeyBcXFwib2JqXFxcIjogb2JqLCBcXFwidGV4dFxcXCI6IHZhbCB9KTtcXG5cXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogZ2V0cyBhIEpTT04gcmVwcmVzZW50YXRpb24gb2YgYSBub2RlIChvciB0aGUgd2hvbGUgdHJlZSlcXG4gICAqIEBuYW1lIGdldF9qc29uKFtvYmosIG9wdGlvbnNdKVxcbiAgICogQHBhcmFtICB7bWl4ZWR9IG9ialxcbiAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXFxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBvcHRpb25zLm5vX3N0YXRlIGRvIG5vdCByZXR1cm4gc3RhdGUgaW5mb3JtYXRpb25cXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IG9wdGlvbnMubm9faWQgZG8gbm90IHJldHVybiBJRFxcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gb3B0aW9ucy5ub19jaGlsZHJlbiBkbyBub3QgaW5jbHVkZSBjaGlsZHJlblxcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gb3B0aW9ucy5ub19kYXRhIGRvIG5vdCBpbmNsdWRlIG5vZGUgZGF0YVxcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gb3B0aW9ucy5ub19saV9hdHRyIGRvIG5vdCBpbmNsdWRlIExJIGF0dHJpYnV0ZXNcXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IG9wdGlvbnMubm9fYV9hdHRyIGRvIG5vdCBpbmNsdWRlIEEgYXR0cmlidXRlc1xcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gb3B0aW9ucy5mbGF0IHJldHVybiBmbGF0IEpTT04gaW5zdGVhZCBvZiBuZXN0ZWRcXG4gICAqIEByZXR1cm4ge09iamVjdH1cXG4gICAqL1xcblxcdFxcdGdldF9qc29uOiBmdW5jdGlvbiBnZXRfanNvbihvYmosIG9wdGlvbnMsIGZsYXQpIHtcXG5cXHRcXHRcXHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaiB8fCAkLmpzdHJlZS5yb290KTtcXG5cXHRcXHRcXHRpZiAoIW9iaikge1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5mbGF0ICYmICFmbGF0KSB7XFxuXFx0XFx0XFx0XFx0ZmxhdCA9IFtdO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR2YXIgdG1wID0ge1xcblxcdFxcdFxcdFxcdCdpZCc6IG9iai5pZCxcXG5cXHRcXHRcXHRcXHQndGV4dCc6IG9iai50ZXh0LFxcblxcdFxcdFxcdFxcdCdpY29uJzogdGhpcy5nZXRfaWNvbihvYmopLFxcblxcdFxcdFxcdFxcdCdsaV9hdHRyJzogJC5leHRlbmQodHJ1ZSwge30sIG9iai5saV9hdHRyKSxcXG5cXHRcXHRcXHRcXHQnYV9hdHRyJzogJC5leHRlbmQodHJ1ZSwge30sIG9iai5hX2F0dHIpLFxcblxcdFxcdFxcdFxcdCdzdGF0ZSc6IHt9LFxcblxcdFxcdFxcdFxcdCdkYXRhJzogb3B0aW9ucyAmJiBvcHRpb25zLm5vX2RhdGEgPyBmYWxzZSA6ICQuZXh0ZW5kKHRydWUsIHt9LCBvYmouZGF0YSlcXG5cXHRcXHRcXHRcXHQvLyggdGhpcy5nZXRfbm9kZShvYmosIHRydWUpLmxlbmd0aCA/IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKS5kYXRhKCkgOiBvYmouZGF0YSApLFxcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0ICAgIGksXFxuXFx0XFx0XFx0ICAgIGo7XFxuXFx0XFx0XFx0aWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5mbGF0KSB7XFxuXFx0XFx0XFx0XFx0dG1wLnBhcmVudCA9IG9iai5wYXJlbnQ7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHR0bXAuY2hpbGRyZW4gPSBbXTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKCFvcHRpb25zIHx8ICFvcHRpb25zLm5vX3N0YXRlKSB7XFxuXFx0XFx0XFx0XFx0Zm9yIChpIGluIG9iai5zdGF0ZSkge1xcblxcdFxcdFxcdFxcdFxcdGlmIChvYmouc3RhdGUuaGFzT3duUHJvcGVydHkoaSkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0bXAuc3RhdGVbaV0gPSBvYmouc3RhdGVbaV07XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdGRlbGV0ZSB0bXAuc3RhdGU7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmIChvcHRpb25zICYmIG9wdGlvbnMubm9fbGlfYXR0cikge1xcblxcdFxcdFxcdFxcdGRlbGV0ZSB0bXAubGlfYXR0cjtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5ub19hX2F0dHIpIHtcXG5cXHRcXHRcXHRcXHRkZWxldGUgdG1wLmFfYXR0cjtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5ub19pZCkge1xcblxcdFxcdFxcdFxcdGRlbGV0ZSB0bXAuaWQ7XFxuXFx0XFx0XFx0XFx0aWYgKHRtcC5saV9hdHRyICYmIHRtcC5saV9hdHRyLmlkKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZGVsZXRlIHRtcC5saV9hdHRyLmlkO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRpZiAodG1wLmFfYXR0ciAmJiB0bXAuYV9hdHRyLmlkKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZGVsZXRlIHRtcC5hX2F0dHIuaWQ7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAob3B0aW9ucyAmJiBvcHRpb25zLmZsYXQgJiYgb2JqLmlkICE9PSAkLmpzdHJlZS5yb290KSB7XFxuXFx0XFx0XFx0XFx0ZmxhdC5wdXNoKHRtcCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICghb3B0aW9ucyB8fCAhb3B0aW9ucy5ub19jaGlsZHJlbikge1xcblxcdFxcdFxcdFxcdGZvciAoaSA9IDAsIGogPSBvYmouY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5mbGF0KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5nZXRfanNvbihvYmouY2hpbGRyZW5baV0sIG9wdGlvbnMsIGZsYXQpO1xcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dG1wLmNoaWxkcmVuLnB1c2godGhpcy5nZXRfanNvbihvYmouY2hpbGRyZW5baV0sIG9wdGlvbnMpKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gb3B0aW9ucyAmJiBvcHRpb25zLmZsYXQgPyBmbGF0IDogb2JqLmlkID09PSAkLmpzdHJlZS5yb290ID8gdG1wLmNoaWxkcmVuIDogdG1wO1xcblxcdFxcdH0sXFxuXFx0XFx0LyoqXFxuICAgKiBjcmVhdGUgYSBuZXcgbm9kZSAoZG8gbm90IGNvbmZ1c2Ugd2l0aCBsb2FkX25vZGUpXFxuICAgKiBAbmFtZSBjcmVhdGVfbm9kZShbcGFyLCBub2RlLCBwb3MsIGNhbGxiYWNrLCBpc19sb2FkZWRdKVxcbiAgICogQHBhcmFtICB7bWl4ZWR9ICAgcGFyICAgICAgIHRoZSBwYXJlbnQgbm9kZSAodG8gY3JlYXRlIGEgcm9vdCBub2RlIHVzZSBlaXRoZXIgXFxcIiNcXFwiIChzdHJpbmcpIG9yIGBudWxsYClcXG4gICAqIEBwYXJhbSAge21peGVkfSAgIG5vZGUgICAgICB0aGUgZGF0YSBmb3IgdGhlIG5ldyBub2RlIChhIHZhbGlkIEpTT04gb2JqZWN0LCBvciBhIHNpbXBsZSBzdHJpbmcgd2l0aCB0aGUgbmFtZSlcXG4gICAqIEBwYXJhbSAge21peGVkfSAgIHBvcyAgICAgICB0aGUgaW5kZXggYXQgd2hpY2ggdG8gaW5zZXJ0IHRoZSBub2RlLCBcXFwiZmlyc3RcXFwiIGFuZCBcXFwibGFzdFxcXCIgYXJlIGFsc28gc3VwcG9ydGVkLCBkZWZhdWx0IGlzIFxcXCJsYXN0XFxcIlxcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrIGEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uY2UgdGhlIG5vZGUgaXMgY3JlYXRlZFxcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gaXNfbG9hZGVkIGludGVybmFsIGFyZ3VtZW50IGluZGljYXRpbmcgaWYgdGhlIHBhcmVudCBub2RlIHdhcyBzdWNjZXNmdWxseSBsb2FkZWRcXG4gICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICAgICB0aGUgSUQgb2YgdGhlIG5ld2x5IGNyZWF0ZSBub2RlXFxuICAgKiBAdHJpZ2dlciBtb2RlbC5qc3RyZWUsIGNyZWF0ZV9ub2RlLmpzdHJlZVxcbiAgICovXFxuXFx0XFx0Y3JlYXRlX25vZGU6IGZ1bmN0aW9uIGNyZWF0ZV9ub2RlKHBhciwgbm9kZSwgcG9zLCBjYWxsYmFjaywgaXNfbG9hZGVkKSB7XFxuXFx0XFx0XFx0aWYgKHBhciA9PT0gbnVsbCkge1xcblxcdFxcdFxcdFxcdHBhciA9ICQuanN0cmVlLnJvb3Q7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHBhciA9IHRoaXMuZ2V0X25vZGUocGFyKTtcXG5cXHRcXHRcXHRpZiAoIXBhcikge1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cG9zID0gcG9zID09PSB1bmRlZmluZWQgPyBcXFwibGFzdFxcXCIgOiBwb3M7XFxuXFx0XFx0XFx0aWYgKCFwb3MudG9TdHJpbmcoKS5tYXRjaCgvXihiZWZvcmV8YWZ0ZXIpJC8pICYmICFpc19sb2FkZWQgJiYgIXRoaXMuaXNfbG9hZGVkKHBhcikpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5sb2FkX25vZGUocGFyLCBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5jcmVhdGVfbm9kZShwYXIsIG5vZGUsIHBvcywgY2FsbGJhY2ssIHRydWUpO1xcblxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoIW5vZGUpIHtcXG5cXHRcXHRcXHRcXHRub2RlID0geyBcXFwidGV4dFxcXCI6IHRoaXMuZ2V0X3N0cmluZygnTmV3IG5vZGUnKSB9O1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAodHlwZW9mIG5vZGUgPT09IFxcXCJzdHJpbmdcXFwiKSB7XFxuXFx0XFx0XFx0XFx0bm9kZSA9IHsgXFxcInRleHRcXFwiOiBub2RlIH07XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmIChub2RlLnRleHQgPT09IHVuZGVmaW5lZCkge1xcblxcdFxcdFxcdFxcdG5vZGUudGV4dCA9IHRoaXMuZ2V0X3N0cmluZygnTmV3IG5vZGUnKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0dmFyIHRtcCwgZHBjLCBpLCBqO1xcblxcblxcdFxcdFxcdGlmIChwYXIuaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcXG5cXHRcXHRcXHRcXHRpZiAocG9zID09PSBcXFwiYmVmb3JlXFxcIikge1xcblxcdFxcdFxcdFxcdFxcdHBvcyA9IFxcXCJmaXJzdFxcXCI7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGlmIChwb3MgPT09IFxcXCJhZnRlclxcXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRwb3MgPSBcXFwibGFzdFxcXCI7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRzd2l0Y2ggKHBvcykge1xcblxcdFxcdFxcdFxcdGNhc2UgXFxcImJlZm9yZVxcXCI6XFxuXFx0XFx0XFx0XFx0XFx0dG1wID0gdGhpcy5nZXRfbm9kZShwYXIucGFyZW50KTtcXG5cXHRcXHRcXHRcXHRcXHRwb3MgPSAkLmluQXJyYXkocGFyLmlkLCB0bXAuY2hpbGRyZW4pO1xcblxcdFxcdFxcdFxcdFxcdHBhciA9IHRtcDtcXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRjYXNlIFxcXCJhZnRlclxcXCI6XFxuXFx0XFx0XFx0XFx0XFx0dG1wID0gdGhpcy5nZXRfbm9kZShwYXIucGFyZW50KTtcXG5cXHRcXHRcXHRcXHRcXHRwb3MgPSAkLmluQXJyYXkocGFyLmlkLCB0bXAuY2hpbGRyZW4pICsgMTtcXG5cXHRcXHRcXHRcXHRcXHRwYXIgPSB0bXA7XFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0Y2FzZSBcXFwiaW5zaWRlXFxcIjpcXG5cXHRcXHRcXHRcXHRjYXNlIFxcXCJmaXJzdFxcXCI6XFxuXFx0XFx0XFx0XFx0XFx0cG9zID0gMDtcXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRjYXNlIFxcXCJsYXN0XFxcIjpcXG5cXHRcXHRcXHRcXHRcXHRwb3MgPSBwYXIuY2hpbGRyZW4ubGVuZ3RoO1xcblxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdGRlZmF1bHQ6XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCFwb3MpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRwb3MgPSAwO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKHBvcyA+IHBhci5jaGlsZHJlbi5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRwb3MgPSBwYXIuY2hpbGRyZW4ubGVuZ3RoO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoIW5vZGUuaWQpIHtcXG5cXHRcXHRcXHRcXHRub2RlLmlkID0gdHJ1ZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKCF0aGlzLmNoZWNrKFxcXCJjcmVhdGVfbm9kZVxcXCIsIG5vZGUsIHBhciwgcG9zKSkge1xcblxcdFxcdFxcdFxcdHRoaXMuc2V0dGluZ3MuY29yZS5lcnJvci5jYWxsKHRoaXMsIHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmIChub2RlLmlkID09PSB0cnVlKSB7XFxuXFx0XFx0XFx0XFx0ZGVsZXRlIG5vZGUuaWQ7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdG5vZGUgPSB0aGlzLl9wYXJzZV9tb2RlbF9mcm9tX2pzb24obm9kZSwgcGFyLmlkLCBwYXIucGFyZW50cy5jb25jYXQoKSk7XFxuXFx0XFx0XFx0aWYgKCFub2RlKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR0bXAgPSB0aGlzLmdldF9ub2RlKG5vZGUpO1xcblxcdFxcdFxcdGRwYyA9IFtdO1xcblxcdFxcdFxcdGRwYy5wdXNoKG5vZGUpO1xcblxcdFxcdFxcdGRwYyA9IGRwYy5jb25jYXQodG1wLmNoaWxkcmVuX2QpO1xcblxcdFxcdFxcdHRoaXMudHJpZ2dlcignbW9kZWwnLCB7IFxcXCJub2Rlc1xcXCI6IGRwYywgXFxcInBhcmVudFxcXCI6IHBhci5pZCB9KTtcXG5cXG5cXHRcXHRcXHRwYXIuY2hpbGRyZW5fZCA9IHBhci5jaGlsZHJlbl9kLmNvbmNhdChkcGMpO1xcblxcdFxcdFxcdGZvciAoaSA9IDAsIGogPSBwYXIucGFyZW50cy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9tb2RlbC5kYXRhW3Bhci5wYXJlbnRzW2ldXS5jaGlsZHJlbl9kID0gdGhpcy5fbW9kZWwuZGF0YVtwYXIucGFyZW50c1tpXV0uY2hpbGRyZW5fZC5jb25jYXQoZHBjKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0bm9kZSA9IHRtcDtcXG5cXHRcXHRcXHR0bXAgPSBbXTtcXG5cXHRcXHRcXHRmb3IgKGkgPSAwLCBqID0gcGFyLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcblxcdFxcdFxcdFxcdHRtcFtpID49IHBvcyA/IGkgKyAxIDogaV0gPSBwYXIuY2hpbGRyZW5baV07XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHRtcFtwb3NdID0gbm9kZS5pZDtcXG5cXHRcXHRcXHRwYXIuY2hpbGRyZW4gPSB0bXA7XFxuXFxuXFx0XFx0XFx0dGhpcy5yZWRyYXdfbm9kZShwYXIsIHRydWUpO1xcblxcdFxcdFxcdGlmIChjYWxsYmFjaykge1xcblxcdFxcdFxcdFxcdGNhbGxiYWNrLmNhbGwodGhpcywgdGhpcy5nZXRfbm9kZShub2RlKSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdC8qKlxcbiAgICAqIHRyaWdnZXJlZCB3aGVuIGEgbm9kZSBpcyBjcmVhdGVkXFxuICAgICogQGV2ZW50XFxuICAgICogQG5hbWUgY3JlYXRlX25vZGUuanN0cmVlXFxuICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGVcXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyZW50IHRoZSBwYXJlbnQncyBJRFxcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSBwb3NpdGlvbiB0aGUgcG9zaXRpb24gb2YgdGhlIG5ldyBub2RlIGFtb25nIHRoZSBwYXJlbnQncyBjaGlsZHJlblxcbiAgICAqL1xcblxcdFxcdFxcdHRoaXMudHJpZ2dlcignY3JlYXRlX25vZGUnLCB7IFxcXCJub2RlXFxcIjogdGhpcy5nZXRfbm9kZShub2RlKSwgXFxcInBhcmVudFxcXCI6IHBhci5pZCwgXFxcInBvc2l0aW9uXFxcIjogcG9zIH0pO1xcblxcdFxcdFxcdHJldHVybiBub2RlLmlkO1xcblxcdFxcdH0sXFxuXFx0XFx0LyoqXFxuICAgKiBzZXQgdGhlIHRleHQgdmFsdWUgb2YgYSBub2RlXFxuICAgKiBAbmFtZSByZW5hbWVfbm9kZShvYmosIHZhbClcXG4gICAqIEBwYXJhbSAge21peGVkfSBvYmogdGhlIG5vZGUsIHlvdSBjYW4gcGFzcyBhbiBhcnJheSB0byByZW5hbWUgbXVsdGlwbGUgbm9kZXMgdG8gdGhlIHNhbWUgbmFtZVxcbiAgICogQHBhcmFtICB7U3RyaW5nfSB2YWwgdGhlIG5ldyB0ZXh0IHZhbHVlXFxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxcbiAgICogQHRyaWdnZXIgcmVuYW1lX25vZGUuanN0cmVlXFxuICAgKi9cXG5cXHRcXHRyZW5hbWVfbm9kZTogZnVuY3Rpb24gcmVuYW1lX25vZGUob2JqLCB2YWwpIHtcXG5cXHRcXHRcXHR2YXIgdDEsIHQyLCBvbGQ7XFxuXFx0XFx0XFx0aWYgKCQuaXNBcnJheShvYmopKSB7XFxuXFx0XFx0XFx0XFx0b2JqID0gb2JqLnNsaWNlKCk7XFxuXFx0XFx0XFx0XFx0Zm9yICh0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMucmVuYW1lX25vZGUob2JqW3QxXSwgdmFsKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXHRcXHRcXHRpZiAoIW9iaiB8fCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdG9sZCA9IG9iai50ZXh0O1xcblxcdFxcdFxcdGlmICghdGhpcy5jaGVjayhcXFwicmVuYW1lX25vZGVcXFwiLCBvYmosIHRoaXMuZ2V0X3BhcmVudChvYmopLCB2YWwpKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5zZXR0aW5ncy5jb3JlLmVycm9yLmNhbGwodGhpcywgdGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IpO1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0dGhpcy5zZXRfdGV4dChvYmosIHZhbCk7IC8vIC5hcHBseSh0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKVxcblxcdFxcdFxcdC8qKlxcbiAgICAqIHRyaWdnZXJlZCB3aGVuIGEgbm9kZSBpcyByZW5hbWVkXFxuICAgICogQGV2ZW50XFxuICAgICogQG5hbWUgcmVuYW1lX25vZGUuanN0cmVlXFxuICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGVcXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCB0aGUgbmV3IHZhbHVlXFxuICAgICogQHBhcmFtIHtTdHJpbmd9IG9sZCB0aGUgb2xkIHZhbHVlXFxuICAgICovXFxuXFx0XFx0XFx0dGhpcy50cmlnZ2VyKCdyZW5hbWVfbm9kZScsIHsgXFxcIm5vZGVcXFwiOiBvYmosIFxcXCJ0ZXh0XFxcIjogdmFsLCBcXFwib2xkXFxcIjogb2xkIH0pO1xcblxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdH0sXFxuXFx0XFx0LyoqXFxuICAgKiByZW1vdmUgYSBub2RlXFxuICAgKiBAbmFtZSBkZWxldGVfbm9kZShvYmopXFxuICAgKiBAcGFyYW0gIHttaXhlZH0gb2JqIHRoZSBub2RlLCB5b3UgY2FuIHBhc3MgYW4gYXJyYXkgdG8gZGVsZXRlIG11bHRpcGxlIG5vZGVzXFxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxcbiAgICogQHRyaWdnZXIgZGVsZXRlX25vZGUuanN0cmVlLCBjaGFuZ2VkLmpzdHJlZVxcbiAgICovXFxuXFx0XFx0ZGVsZXRlX25vZGU6IGZ1bmN0aW9uIGRlbGV0ZV9ub2RlKG9iaikge1xcblxcdFxcdFxcdHZhciB0MSwgdDIsIHBhciwgcG9zLCB0bXAsIGksIGosIGssIGwsIGMsIHRvcCwgbGZ0O1xcblxcdFxcdFxcdGlmICgkLmlzQXJyYXkob2JqKSkge1xcblxcdFxcdFxcdFxcdG9iaiA9IG9iai5zbGljZSgpO1xcblxcdFxcdFxcdFxcdGZvciAodDEgPSAwLCB0MiA9IG9iai5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmRlbGV0ZV9ub2RlKG9ialt0MV0pO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xcblxcdFxcdFxcdGlmICghb2JqIHx8IG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCkge1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cGFyID0gdGhpcy5nZXRfbm9kZShvYmoucGFyZW50KTtcXG5cXHRcXHRcXHRwb3MgPSAkLmluQXJyYXkob2JqLmlkLCBwYXIuY2hpbGRyZW4pO1xcblxcdFxcdFxcdGMgPSBmYWxzZTtcXG5cXHRcXHRcXHRpZiAoIXRoaXMuY2hlY2soXFxcImRlbGV0ZV9ub2RlXFxcIiwgb2JqLCBwYXIsIHBvcykpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLnNldHRpbmdzLmNvcmUuZXJyb3IuY2FsbCh0aGlzLCB0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvcik7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAocG9zICE9PSAtMSkge1xcblxcdFxcdFxcdFxcdHBhci5jaGlsZHJlbiA9ICQudmFrYXRhLmFycmF5X3JlbW92ZShwYXIuY2hpbGRyZW4sIHBvcyk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHRtcCA9IG9iai5jaGlsZHJlbl9kLmNvbmNhdChbXSk7XFxuXFx0XFx0XFx0dG1wLnB1c2gob2JqLmlkKTtcXG5cXHRcXHRcXHRmb3IgKGkgPSAwLCBqID0gb2JqLnBhcmVudHMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5fbW9kZWwuZGF0YVtvYmoucGFyZW50c1tpXV0uY2hpbGRyZW5fZCA9ICQudmFrYXRhLmFycmF5X2ZpbHRlcih0aGlzLl9tb2RlbC5kYXRhW29iai5wYXJlbnRzW2ldXS5jaGlsZHJlbl9kLCBmdW5jdGlvbiAodikge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiAkLmluQXJyYXkodiwgdG1wKSA9PT0gLTE7XFxuXFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGZvciAoayA9IDAsIGwgPSB0bXAubGVuZ3RoOyBrIDwgbDsgaysrKSB7XFxuXFx0XFx0XFx0XFx0aWYgKHRoaXMuX21vZGVsLmRhdGFbdG1wW2tdXS5zdGF0ZS5zZWxlY3RlZCkge1xcblxcdFxcdFxcdFxcdFxcdGMgPSB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKGMpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQgPSAkLnZha2F0YS5hcnJheV9maWx0ZXIodGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLCBmdW5jdGlvbiAodikge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiAkLmluQXJyYXkodiwgdG1wKSA9PT0gLTE7XFxuXFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdC8qKlxcbiAgICAqIHRyaWdnZXJlZCB3aGVuIGEgbm9kZSBpcyBkZWxldGVkXFxuICAgICogQGV2ZW50XFxuICAgICogQG5hbWUgZGVsZXRlX25vZGUuanN0cmVlXFxuICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGVcXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyZW50IHRoZSBwYXJlbnQncyBJRFxcbiAgICAqL1xcblxcdFxcdFxcdHRoaXMudHJpZ2dlcignZGVsZXRlX25vZGUnLCB7IFxcXCJub2RlXFxcIjogb2JqLCBcXFwicGFyZW50XFxcIjogcGFyLmlkIH0pO1xcblxcdFxcdFxcdGlmIChjKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy50cmlnZ2VyKCdjaGFuZ2VkJywgeyAnYWN0aW9uJzogJ2RlbGV0ZV9ub2RlJywgJ25vZGUnOiBvYmosICdzZWxlY3RlZCc6IHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZCwgJ3BhcmVudCc6IHBhci5pZCB9KTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0Zm9yIChrID0gMCwgbCA9IHRtcC5sZW5ndGg7IGsgPCBsOyBrKyspIHtcXG5cXHRcXHRcXHRcXHRkZWxldGUgdGhpcy5fbW9kZWwuZGF0YVt0bXBba11dO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoJC5pbkFycmF5KHRoaXMuX2RhdGEuY29yZS5mb2N1c2VkLCB0bXApICE9PSAtMSkge1xcblxcdFxcdFxcdFxcdHRoaXMuX2RhdGEuY29yZS5mb2N1c2VkID0gbnVsbDtcXG5cXHRcXHRcXHRcXHR0b3AgPSB0aGlzLmVsZW1lbnRbMF0uc2Nyb2xsVG9wO1xcblxcdFxcdFxcdFxcdGxmdCA9IHRoaXMuZWxlbWVudFswXS5zY3JvbGxMZWZ0O1xcblxcdFxcdFxcdFxcdGlmIChwYXIuaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAodGhpcy5fbW9kZWwuZGF0YVskLmpzdHJlZS5yb290XS5jaGlsZHJlblswXSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuZ2V0X25vZGUodGhpcy5fbW9kZWwuZGF0YVskLmpzdHJlZS5yb290XS5jaGlsZHJlblswXSwgdHJ1ZSkuY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuZm9jdXMoKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmdldF9ub2RlKHBhciwgdHJ1ZSkuY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuZm9jdXMoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0dGhpcy5lbGVtZW50WzBdLnNjcm9sbFRvcCA9IHRvcDtcXG5cXHRcXHRcXHRcXHR0aGlzLmVsZW1lbnRbMF0uc2Nyb2xsTGVmdCA9IGxmdDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0dGhpcy5yZWRyYXdfbm9kZShwYXIsIHRydWUpO1xcblxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdH0sXFxuXFx0XFx0LyoqXFxuICAgKiBjaGVjayBpZiBhbiBvcGVyYXRpb24gaXMgcHJlbWl0dGVkIG9uIHRoZSB0cmVlLiBVc2VkIGludGVybmFsbHkuXFxuICAgKiBAcHJpdmF0ZVxcbiAgICogQG5hbWUgY2hlY2soY2hrLCBvYmosIHBhciwgcG9zKVxcbiAgICogQHBhcmFtICB7U3RyaW5nfSBjaGsgdGhlIG9wZXJhdGlvbiB0byBjaGVjaywgY2FuIGJlIFxcXCJjcmVhdGVfbm9kZVxcXCIsIFxcXCJyZW5hbWVfbm9kZVxcXCIsIFxcXCJkZWxldGVfbm9kZVxcXCIsIFxcXCJjb3B5X25vZGVcXFwiIG9yIFxcXCJtb3ZlX25vZGVcXFwiXFxuICAgKiBAcGFyYW0gIHttaXhlZH0gb2JqIHRoZSBub2RlXFxuICAgKiBAcGFyYW0gIHttaXhlZH0gcGFyIHRoZSBwYXJlbnRcXG4gICAqIEBwYXJhbSAge21peGVkfSBwb3MgdGhlIHBvc2l0aW9uIHRvIGluc2VydCBhdCwgb3IgaWYgXFxcInJlbmFtZV9ub2RlXFxcIiAtIHRoZSBuZXcgbmFtZVxcbiAgICogQHBhcmFtICB7bWl4ZWR9IG1vcmUgc29tZSB2YXJpb3VzIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24sIGZvciBleGFtcGxlIGlmIGEgXFxcIm1vdmVfbm9kZVxcXCIgb3BlcmF0aW9ucyBpcyB0cmlnZ2VyZWQgYnkgRE5EIHRoaXMgd2lsbCBiZSB0aGUgaG92ZXJlZCBub2RlXFxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxcbiAgICovXFxuXFx0XFx0Y2hlY2s6IGZ1bmN0aW9uIGNoZWNrKGNoaywgb2JqLCBwYXIsIHBvcywgbW9yZSkge1xcblxcdFxcdFxcdG9iaiA9IG9iaiAmJiBvYmouaWQgPyBvYmogOiB0aGlzLmdldF9ub2RlKG9iaik7XFxuXFx0XFx0XFx0cGFyID0gcGFyICYmIHBhci5pZCA/IHBhciA6IHRoaXMuZ2V0X25vZGUocGFyKTtcXG5cXHRcXHRcXHR2YXIgdG1wID0gY2hrLm1hdGNoKC9ebW92ZV9ub2RlfGNvcHlfbm9kZXxjcmVhdGVfbm9kZSQvaSkgPyBwYXIgOiBvYmosXFxuXFx0XFx0XFx0ICAgIGNoYyA9IHRoaXMuc2V0dGluZ3MuY29yZS5jaGVja19jYWxsYmFjaztcXG5cXHRcXHRcXHRpZiAoY2hrID09PSBcXFwibW92ZV9ub2RlXFxcIiB8fCBjaGsgPT09IFxcXCJjb3B5X25vZGVcXFwiKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCghbW9yZSB8fCAhbW9yZS5pc19tdWx0aSkgJiYgKG9iai5pZCA9PT0gcGFyLmlkIHx8IGNoayA9PT0gXFxcIm1vdmVfbm9kZVxcXCIgJiYgJC5pbkFycmF5KG9iai5pZCwgcGFyLmNoaWxkcmVuKSA9PT0gcG9zIHx8ICQuaW5BcnJheShwYXIuaWQsIG9iai5jaGlsZHJlbl9kKSAhPT0gLTEpKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IgPSB7ICdlcnJvcic6ICdjaGVjaycsICdwbHVnaW4nOiAnY29yZScsICdpZCc6ICdjb3JlXzAxJywgJ3JlYXNvbic6ICdNb3ZpbmcgcGFyZW50IGluc2lkZSBjaGlsZCcsICdkYXRhJzogSlNPTi5zdHJpbmdpZnkoeyAnY2hrJzogY2hrLCAncG9zJzogcG9zLCAnb2JqJzogb2JqICYmIG9iai5pZCA/IG9iai5pZCA6IGZhbHNlLCAncGFyJzogcGFyICYmIHBhci5pZCA/IHBhci5pZCA6IGZhbHNlIH0pIH07XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKHRtcCAmJiB0bXAuZGF0YSkge1xcblxcdFxcdFxcdFxcdHRtcCA9IHRtcC5kYXRhO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAodG1wICYmIHRtcC5mdW5jdGlvbnMgJiYgKHRtcC5mdW5jdGlvbnNbY2hrXSA9PT0gZmFsc2UgfHwgdG1wLmZ1bmN0aW9uc1tjaGtdID09PSB0cnVlKSkge1xcblxcdFxcdFxcdFxcdGlmICh0bXAuZnVuY3Rpb25zW2Noa10gPT09IGZhbHNlKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IgPSB7ICdlcnJvcic6ICdjaGVjaycsICdwbHVnaW4nOiAnY29yZScsICdpZCc6ICdjb3JlXzAyJywgJ3JlYXNvbic6ICdOb2RlIGRhdGEgcHJldmVudHMgZnVuY3Rpb246ICcgKyBjaGssICdkYXRhJzogSlNPTi5zdHJpbmdpZnkoeyAnY2hrJzogY2hrLCAncG9zJzogcG9zLCAnb2JqJzogb2JqICYmIG9iai5pZCA/IG9iai5pZCA6IGZhbHNlLCAncGFyJzogcGFyICYmIHBhci5pZCA/IHBhci5pZCA6IGZhbHNlIH0pIH07XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHJldHVybiB0bXAuZnVuY3Rpb25zW2Noa107XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmIChjaGMgPT09IGZhbHNlIHx8ICQuaXNGdW5jdGlvbihjaGMpICYmIGNoYy5jYWxsKHRoaXMsIGNoaywgb2JqLCBwYXIsIHBvcywgbW9yZSkgPT09IGZhbHNlIHx8IGNoYyAmJiBjaGNbY2hrXSA9PT0gZmFsc2UpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvciA9IHsgJ2Vycm9yJzogJ2NoZWNrJywgJ3BsdWdpbic6ICdjb3JlJywgJ2lkJzogJ2NvcmVfMDMnLCAncmVhc29uJzogJ1VzZXIgY29uZmlnIGZvciBjb3JlLmNoZWNrX2NhbGxiYWNrIHByZXZlbnRzIGZ1bmN0aW9uOiAnICsgY2hrLCAnZGF0YSc6IEpTT04uc3RyaW5naWZ5KHsgJ2Noayc6IGNoaywgJ3Bvcyc6IHBvcywgJ29iaic6IG9iaiAmJiBvYmouaWQgPyBvYmouaWQgOiBmYWxzZSwgJ3Bhcic6IHBhciAmJiBwYXIuaWQgPyBwYXIuaWQgOiBmYWxzZSB9KSB9O1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIGdldCB0aGUgbGFzdCBlcnJvclxcbiAgICogQG5hbWUgbGFzdF9lcnJvcigpXFxuICAgKiBAcmV0dXJuIHtPYmplY3R9XFxuICAgKi9cXG5cXHRcXHRsYXN0X2Vycm9yOiBmdW5jdGlvbiBsYXN0X2Vycm9yKCkge1xcblxcdFxcdFxcdHJldHVybiB0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvcjtcXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogbW92ZSBhIG5vZGUgdG8gYSBuZXcgcGFyZW50XFxuICAgKiBAbmFtZSBtb3ZlX25vZGUob2JqLCBwYXIgWywgcG9zLCBjYWxsYmFjaywgaXNfbG9hZGVkXSlcXG4gICAqIEBwYXJhbSAge21peGVkfSBvYmogdGhlIG5vZGUgdG8gbW92ZSwgcGFzcyBhbiBhcnJheSB0byBtb3ZlIG11bHRpcGxlIG5vZGVzXFxuICAgKiBAcGFyYW0gIHttaXhlZH0gcGFyIHRoZSBuZXcgcGFyZW50XFxuICAgKiBAcGFyYW0gIHttaXhlZH0gcG9zIHRoZSBwb3NpdGlvbiB0byBpbnNlcnQgYXQgKGJlc2lkZXMgaW50ZWdlciB2YWx1ZXMsIFxcXCJmaXJzdFxcXCIgYW5kIFxcXCJsYXN0XFxcIiBhcmUgc3VwcG9ydGVkLCBhcyB3ZWxsIGFzIFxcXCJiZWZvcmVcXFwiIGFuZCBcXFwiYWZ0ZXJcXFwiKSwgZGVmYXVsdHMgdG8gaW50ZWdlciBgMGBcXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSBjYWxsYmFjayBhIGZ1bmN0aW9uIHRvIGNhbGwgb25jZSB0aGUgbW92ZSBpcyBjb21wbGV0ZWQsIHJlY2VpdmVzIDMgYXJndW1lbnRzIC0gdGhlIG5vZGUsIHRoZSBuZXcgcGFyZW50IGFuZCB0aGUgcG9zaXRpb25cXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IGlzX2xvYWRlZCBpbnRlcm5hbCBwYXJhbWV0ZXIgaW5kaWNhdGluZyBpZiB0aGUgcGFyZW50IG5vZGUgaGFzIGJlZW4gbG9hZGVkXFxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBza2lwX3JlZHJhdyBpbnRlcm5hbCBwYXJhbWV0ZXIgaW5kaWNhdGluZyBpZiB0aGUgdHJlZSBzaG91bGQgYmUgcmVkcmF3blxcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gaW5zdGFuY2UgaW50ZXJuYWwgcGFyYW1ldGVyIGluZGljYXRpbmcgaWYgdGhlIG5vZGUgY29tZXMgZnJvbSBhbm90aGVyIGluc3RhbmNlXFxuICAgKiBAdHJpZ2dlciBtb3ZlX25vZGUuanN0cmVlXFxuICAgKi9cXG5cXHRcXHRtb3ZlX25vZGU6IGZ1bmN0aW9uIG1vdmVfbm9kZShvYmosIHBhciwgcG9zLCBjYWxsYmFjaywgaXNfbG9hZGVkLCBza2lwX3JlZHJhdywgb3JpZ2luKSB7XFxuXFx0XFx0XFx0dmFyIHQxLCB0Miwgb2xkX3Bhciwgb2xkX3BvcywgbmV3X3Bhciwgb2xkX2lucywgaXNfbXVsdGksIGRwYywgdG1wLCBpLCBqLCBrLCBsLCBwO1xcblxcblxcdFxcdFxcdHBhciA9IHRoaXMuZ2V0X25vZGUocGFyKTtcXG5cXHRcXHRcXHRwb3MgPSBwb3MgPT09IHVuZGVmaW5lZCA/IDAgOiBwb3M7XFxuXFx0XFx0XFx0aWYgKCFwYXIpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICghcG9zLnRvU3RyaW5nKCkubWF0Y2goL14oYmVmb3JlfGFmdGVyKSQvKSAmJiAhaXNfbG9hZGVkICYmICF0aGlzLmlzX2xvYWRlZChwYXIpKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMubG9hZF9ub2RlKHBhciwgZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMubW92ZV9ub2RlKG9iaiwgcGFyLCBwb3MsIGNhbGxiYWNrLCB0cnVlLCBmYWxzZSwgb3JpZ2luKTtcXG5cXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCQuaXNBcnJheShvYmopKSB7XFxuXFx0XFx0XFx0XFx0aWYgKG9iai5sZW5ndGggPT09IDEpIHtcXG5cXHRcXHRcXHRcXHRcXHRvYmogPSBvYmpbMF07XFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHQvL29iaiA9IG9iai5zbGljZSgpO1xcblxcdFxcdFxcdFxcdFxcdGZvciAodDEgPSAwLCB0MiA9IG9iai5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAodG1wID0gdGhpcy5tb3ZlX25vZGUob2JqW3QxXSwgcGFyLCBwb3MsIGNhbGxiYWNrLCBpc19sb2FkZWQsIGZhbHNlLCBvcmlnaW4pKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cGFyID0gdG1wO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHBvcyA9IFxcXCJhZnRlclxcXCI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnJlZHJhdygpO1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0b2JqID0gb2JqICYmIG9iai5pZCA/IG9iaiA6IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXG5cXHRcXHRcXHRpZiAoIW9iaiB8fCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdG9sZF9wYXIgPSAob2JqLnBhcmVudCB8fCAkLmpzdHJlZS5yb290KS50b1N0cmluZygpO1xcblxcdFxcdFxcdG5ld19wYXIgPSAhcG9zLnRvU3RyaW5nKCkubWF0Y2goL14oYmVmb3JlfGFmdGVyKSQvKSB8fCBwYXIuaWQgPT09ICQuanN0cmVlLnJvb3QgPyBwYXIgOiB0aGlzLmdldF9ub2RlKHBhci5wYXJlbnQpO1xcblxcdFxcdFxcdG9sZF9pbnMgPSBvcmlnaW4gPyBvcmlnaW4gOiB0aGlzLl9tb2RlbC5kYXRhW29iai5pZF0gPyB0aGlzIDogJC5qc3RyZWUucmVmZXJlbmNlKG9iai5pZCk7XFxuXFx0XFx0XFx0aXNfbXVsdGkgPSAhb2xkX2lucyB8fCAhb2xkX2lucy5faWQgfHwgdGhpcy5faWQgIT09IG9sZF9pbnMuX2lkO1xcblxcdFxcdFxcdG9sZF9wb3MgPSBvbGRfaW5zICYmIG9sZF9pbnMuX2lkICYmIG9sZF9wYXIgJiYgb2xkX2lucy5fbW9kZWwuZGF0YVtvbGRfcGFyXSAmJiBvbGRfaW5zLl9tb2RlbC5kYXRhW29sZF9wYXJdLmNoaWxkcmVuID8gJC5pbkFycmF5KG9iai5pZCwgb2xkX2lucy5fbW9kZWwuZGF0YVtvbGRfcGFyXS5jaGlsZHJlbikgOiAtMTtcXG5cXHRcXHRcXHRpZiAob2xkX2lucyAmJiBvbGRfaW5zLl9pZCkge1xcblxcdFxcdFxcdFxcdG9iaiA9IG9sZF9pbnMuX21vZGVsLmRhdGFbb2JqLmlkXTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKGlzX211bHRpKSB7XFxuXFx0XFx0XFx0XFx0aWYgKHRtcCA9IHRoaXMuY29weV9ub2RlKG9iaiwgcGFyLCBwb3MsIGNhbGxiYWNrLCBpc19sb2FkZWQsIGZhbHNlLCBvcmlnaW4pKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKG9sZF9pbnMpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRvbGRfaW5zLmRlbGV0ZV9ub2RlKG9iaik7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdHJldHVybiB0bXA7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0Ly92YXIgbSA9IHRoaXMuX21vZGVsLmRhdGE7XFxuXFx0XFx0XFx0aWYgKHBhci5pZCA9PT0gJC5qc3RyZWUucm9vdCkge1xcblxcdFxcdFxcdFxcdGlmIChwb3MgPT09IFxcXCJiZWZvcmVcXFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0cG9zID0gXFxcImZpcnN0XFxcIjtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aWYgKHBvcyA9PT0gXFxcImFmdGVyXFxcIikge1xcblxcdFxcdFxcdFxcdFxcdHBvcyA9IFxcXCJsYXN0XFxcIjtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHN3aXRjaCAocG9zKSB7XFxuXFx0XFx0XFx0XFx0Y2FzZSBcXFwiYmVmb3JlXFxcIjpcXG5cXHRcXHRcXHRcXHRcXHRwb3MgPSAkLmluQXJyYXkocGFyLmlkLCBuZXdfcGFyLmNoaWxkcmVuKTtcXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRjYXNlIFxcXCJhZnRlclxcXCI6XFxuXFx0XFx0XFx0XFx0XFx0cG9zID0gJC5pbkFycmF5KHBhci5pZCwgbmV3X3Bhci5jaGlsZHJlbikgKyAxO1xcblxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdGNhc2UgXFxcImluc2lkZVxcXCI6XFxuXFx0XFx0XFx0XFx0Y2FzZSBcXFwiZmlyc3RcXFwiOlxcblxcdFxcdFxcdFxcdFxcdHBvcyA9IDA7XFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0Y2FzZSBcXFwibGFzdFxcXCI6XFxuXFx0XFx0XFx0XFx0XFx0cG9zID0gbmV3X3Bhci5jaGlsZHJlbi5sZW5ndGg7XFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0ZGVmYXVsdDpcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIXBvcykge1xcblxcdFxcdFxcdFxcdFxcdFxcdHBvcyA9IDA7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAocG9zID4gbmV3X3Bhci5jaGlsZHJlbi5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRwb3MgPSBuZXdfcGFyLmNoaWxkcmVuLmxlbmd0aDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKCF0aGlzLmNoZWNrKFxcXCJtb3ZlX25vZGVcXFwiLCBvYmosIG5ld19wYXIsIHBvcywgeyAnY29yZSc6IHRydWUsICdvcmlnaW4nOiBvcmlnaW4sICdpc19tdWx0aSc6IG9sZF9pbnMgJiYgb2xkX2lucy5faWQgJiYgb2xkX2lucy5faWQgIT09IHRoaXMuX2lkLCAnaXNfZm9yZWlnbic6ICFvbGRfaW5zIHx8ICFvbGRfaW5zLl9pZCB9KSkge1xcblxcdFxcdFxcdFxcdHRoaXMuc2V0dGluZ3MuY29yZS5lcnJvci5jYWxsKHRoaXMsIHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmIChvYmoucGFyZW50ID09PSBuZXdfcGFyLmlkKSB7XFxuXFx0XFx0XFx0XFx0ZHBjID0gbmV3X3Bhci5jaGlsZHJlbi5jb25jYXQoKTtcXG5cXHRcXHRcXHRcXHR0bXAgPSAkLmluQXJyYXkob2JqLmlkLCBkcGMpO1xcblxcdFxcdFxcdFxcdGlmICh0bXAgIT09IC0xKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZHBjID0gJC52YWthdGEuYXJyYXlfcmVtb3ZlKGRwYywgdG1wKTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAocG9zID4gdG1wKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cG9zLS07XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR0bXAgPSBbXTtcXG5cXHRcXHRcXHRcXHRmb3IgKGkgPSAwLCBqID0gZHBjLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdHRtcFtpID49IHBvcyA/IGkgKyAxIDogaV0gPSBkcGNbaV07XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHRtcFtwb3NdID0gb2JqLmlkO1xcblxcdFxcdFxcdFxcdG5ld19wYXIuY2hpbGRyZW4gPSB0bXA7XFxuXFx0XFx0XFx0XFx0dGhpcy5fbm9kZV9jaGFuZ2VkKG5ld19wYXIuaWQpO1xcblxcdFxcdFxcdFxcdHRoaXMucmVkcmF3KG5ld19wYXIuaWQgPT09ICQuanN0cmVlLnJvb3QpO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0Ly8gY2xlYW4gb2xkIHBhcmVudCBhbmQgdXBcXG5cXHRcXHRcXHRcXHR0bXAgPSBvYmouY2hpbGRyZW5fZC5jb25jYXQoKTtcXG5cXHRcXHRcXHRcXHR0bXAucHVzaChvYmouaWQpO1xcblxcdFxcdFxcdFxcdGZvciAoaSA9IDAsIGogPSBvYmoucGFyZW50cy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRkcGMgPSBbXTtcXG5cXHRcXHRcXHRcXHRcXHRwID0gb2xkX2lucy5fbW9kZWwuZGF0YVtvYmoucGFyZW50c1tpXV0uY2hpbGRyZW5fZDtcXG5cXHRcXHRcXHRcXHRcXHRmb3IgKGsgPSAwLCBsID0gcC5sZW5ndGg7IGsgPCBsOyBrKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoJC5pbkFycmF5KHBba10sIHRtcCkgPT09IC0xKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZHBjLnB1c2gocFtrXSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRvbGRfaW5zLl9tb2RlbC5kYXRhW29iai5wYXJlbnRzW2ldXS5jaGlsZHJlbl9kID0gZHBjO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRvbGRfaW5zLl9tb2RlbC5kYXRhW29sZF9wYXJdLmNoaWxkcmVuID0gJC52YWthdGEuYXJyYXlfcmVtb3ZlX2l0ZW0ob2xkX2lucy5fbW9kZWwuZGF0YVtvbGRfcGFyXS5jaGlsZHJlbiwgb2JqLmlkKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBpbnNlcnQgaW50byBuZXcgcGFyZW50IGFuZCB1cFxcblxcdFxcdFxcdFxcdGZvciAoaSA9IDAsIGogPSBuZXdfcGFyLnBhcmVudHMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fbW9kZWwuZGF0YVtuZXdfcGFyLnBhcmVudHNbaV1dLmNoaWxkcmVuX2QgPSB0aGlzLl9tb2RlbC5kYXRhW25ld19wYXIucGFyZW50c1tpXV0uY2hpbGRyZW5fZC5jb25jYXQodG1wKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0ZHBjID0gW107XFxuXFx0XFx0XFx0XFx0Zm9yIChpID0gMCwgaiA9IG5ld19wYXIuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZHBjW2kgPj0gcG9zID8gaSArIDEgOiBpXSA9IG5ld19wYXIuY2hpbGRyZW5baV07XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGRwY1twb3NdID0gb2JqLmlkO1xcblxcdFxcdFxcdFxcdG5ld19wYXIuY2hpbGRyZW4gPSBkcGM7XFxuXFx0XFx0XFx0XFx0bmV3X3Bhci5jaGlsZHJlbl9kLnB1c2gob2JqLmlkKTtcXG5cXHRcXHRcXHRcXHRuZXdfcGFyLmNoaWxkcmVuX2QgPSBuZXdfcGFyLmNoaWxkcmVuX2QuY29uY2F0KG9iai5jaGlsZHJlbl9kKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyB1cGRhdGUgb2JqZWN0XFxuXFx0XFx0XFx0XFx0b2JqLnBhcmVudCA9IG5ld19wYXIuaWQ7XFxuXFx0XFx0XFx0XFx0dG1wID0gbmV3X3Bhci5wYXJlbnRzLmNvbmNhdCgpO1xcblxcdFxcdFxcdFxcdHRtcC51bnNoaWZ0KG5ld19wYXIuaWQpO1xcblxcdFxcdFxcdFxcdHAgPSBvYmoucGFyZW50cy5sZW5ndGg7XFxuXFx0XFx0XFx0XFx0b2JqLnBhcmVudHMgPSB0bXA7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gdXBkYXRlIG9iamVjdCBjaGlsZHJlblxcblxcdFxcdFxcdFxcdHRtcCA9IHRtcC5jb25jYXQoKTtcXG5cXHRcXHRcXHRcXHRmb3IgKGkgPSAwLCBqID0gb2JqLmNoaWxkcmVuX2QubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fbW9kZWwuZGF0YVtvYmouY2hpbGRyZW5fZFtpXV0ucGFyZW50cyA9IHRoaXMuX21vZGVsLmRhdGFbb2JqLmNoaWxkcmVuX2RbaV1dLnBhcmVudHMuc2xpY2UoMCwgcCAqIC0xKTtcXG5cXHRcXHRcXHRcXHRcXHRBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSh0aGlzLl9tb2RlbC5kYXRhW29iai5jaGlsZHJlbl9kW2ldXS5wYXJlbnRzLCB0bXApO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAob2xkX3BhciA9PT0gJC5qc3RyZWUucm9vdCB8fCBuZXdfcGFyLmlkID09PSAkLmpzdHJlZS5yb290KSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fbW9kZWwuZm9yY2VfZnVsbF9yZWRyYXcgPSB0cnVlO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRpZiAoIXRoaXMuX21vZGVsLmZvcmNlX2Z1bGxfcmVkcmF3KSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fbm9kZV9jaGFuZ2VkKG9sZF9wYXIpO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX25vZGVfY2hhbmdlZChuZXdfcGFyLmlkKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aWYgKCFza2lwX3JlZHJhdykge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMucmVkcmF3KCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoY2FsbGJhY2spIHtcXG5cXHRcXHRcXHRcXHRjYWxsYmFjay5jYWxsKHRoaXMsIG9iaiwgbmV3X3BhciwgcG9zKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0LyoqXFxuICAgICogdHJpZ2dlcmVkIHdoZW4gYSBub2RlIGlzIG1vdmVkXFxuICAgICogQGV2ZW50XFxuICAgICogQG5hbWUgbW92ZV9ub2RlLmpzdHJlZVxcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlXFxuICAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmVudCB0aGUgcGFyZW50J3MgSURcXG4gICAgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb24gdGhlIHBvc2l0aW9uIG9mIHRoZSBub2RlIGFtb25nIHRoZSBwYXJlbnQncyBjaGlsZHJlblxcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRfcGFyZW50IHRoZSBvbGQgcGFyZW50IG9mIHRoZSBub2RlXFxuICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZF9wb3NpdGlvbiB0aGUgb2xkIHBvc2l0aW9uIG9mIHRoZSBub2RlXFxuICAgICogQHBhcmFtIHtCb29sZWFufSBpc19tdWx0aSBkbyB0aGUgbm9kZSBhbmQgbmV3IHBhcmVudCBiZWxvbmcgdG8gZGlmZmVyZW50IGluc3RhbmNlc1xcbiAgICAqIEBwYXJhbSB7anNUcmVlfSBvbGRfaW5zdGFuY2UgdGhlIGluc3RhbmNlIHRoZSBub2RlIGNhbWUgZnJvbVxcbiAgICAqIEBwYXJhbSB7anNUcmVlfSBuZXdfaW5zdGFuY2UgdGhlIGluc3RhbmNlIG9mIHRoZSBuZXcgcGFyZW50XFxuICAgICovXFxuXFx0XFx0XFx0dGhpcy50cmlnZ2VyKCdtb3ZlX25vZGUnLCB7IFxcXCJub2RlXFxcIjogb2JqLCBcXFwicGFyZW50XFxcIjogbmV3X3Bhci5pZCwgXFxcInBvc2l0aW9uXFxcIjogcG9zLCBcXFwib2xkX3BhcmVudFxcXCI6IG9sZF9wYXIsIFxcXCJvbGRfcG9zaXRpb25cXFwiOiBvbGRfcG9zLCAnaXNfbXVsdGknOiBvbGRfaW5zICYmIG9sZF9pbnMuX2lkICYmIG9sZF9pbnMuX2lkICE9PSB0aGlzLl9pZCwgJ2lzX2ZvcmVpZ24nOiAhb2xkX2lucyB8fCAhb2xkX2lucy5faWQsICdvbGRfaW5zdGFuY2UnOiBvbGRfaW5zLCAnbmV3X2luc3RhbmNlJzogdGhpcyB9KTtcXG5cXHRcXHRcXHRyZXR1cm4gb2JqLmlkO1xcblxcdFxcdH0sXFxuXFx0XFx0LyoqXFxuICAgKiBjb3B5IGEgbm9kZSB0byBhIG5ldyBwYXJlbnRcXG4gICAqIEBuYW1lIGNvcHlfbm9kZShvYmosIHBhciBbLCBwb3MsIGNhbGxiYWNrLCBpc19sb2FkZWRdKVxcbiAgICogQHBhcmFtICB7bWl4ZWR9IG9iaiB0aGUgbm9kZSB0byBjb3B5LCBwYXNzIGFuIGFycmF5IHRvIGNvcHkgbXVsdGlwbGUgbm9kZXNcXG4gICAqIEBwYXJhbSAge21peGVkfSBwYXIgdGhlIG5ldyBwYXJlbnRcXG4gICAqIEBwYXJhbSAge21peGVkfSBwb3MgdGhlIHBvc2l0aW9uIHRvIGluc2VydCBhdCAoYmVzaWRlcyBpbnRlZ2VyIHZhbHVlcywgXFxcImZpcnN0XFxcIiBhbmQgXFxcImxhc3RcXFwiIGFyZSBzdXBwb3J0ZWQsIGFzIHdlbGwgYXMgXFxcImJlZm9yZVxcXCIgYW5kIFxcXCJhZnRlclxcXCIpLCBkZWZhdWx0cyB0byBpbnRlZ2VyIGAwYFxcbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IGNhbGxiYWNrIGEgZnVuY3Rpb24gdG8gY2FsbCBvbmNlIHRoZSBtb3ZlIGlzIGNvbXBsZXRlZCwgcmVjZWl2ZXMgMyBhcmd1bWVudHMgLSB0aGUgbm9kZSwgdGhlIG5ldyBwYXJlbnQgYW5kIHRoZSBwb3NpdGlvblxcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gaXNfbG9hZGVkIGludGVybmFsIHBhcmFtZXRlciBpbmRpY2F0aW5nIGlmIHRoZSBwYXJlbnQgbm9kZSBoYXMgYmVlbiBsb2FkZWRcXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IHNraXBfcmVkcmF3IGludGVybmFsIHBhcmFtZXRlciBpbmRpY2F0aW5nIGlmIHRoZSB0cmVlIHNob3VsZCBiZSByZWRyYXduXFxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBpbnN0YW5jZSBpbnRlcm5hbCBwYXJhbWV0ZXIgaW5kaWNhdGluZyBpZiB0aGUgbm9kZSBjb21lcyBmcm9tIGFub3RoZXIgaW5zdGFuY2VcXG4gICAqIEB0cmlnZ2VyIG1vZGVsLmpzdHJlZSBjb3B5X25vZGUuanN0cmVlXFxuICAgKi9cXG5cXHRcXHRjb3B5X25vZGU6IGZ1bmN0aW9uIGNvcHlfbm9kZShvYmosIHBhciwgcG9zLCBjYWxsYmFjaywgaXNfbG9hZGVkLCBza2lwX3JlZHJhdywgb3JpZ2luKSB7XFxuXFx0XFx0XFx0dmFyIHQxLCB0MiwgZHBjLCB0bXAsIGksIGosIG5vZGUsIG9sZF9wYXIsIG5ld19wYXIsIG9sZF9pbnMsIGlzX211bHRpO1xcblxcblxcdFxcdFxcdHBhciA9IHRoaXMuZ2V0X25vZGUocGFyKTtcXG5cXHRcXHRcXHRwb3MgPSBwb3MgPT09IHVuZGVmaW5lZCA/IDAgOiBwb3M7XFxuXFx0XFx0XFx0aWYgKCFwYXIpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICghcG9zLnRvU3RyaW5nKCkubWF0Y2goL14oYmVmb3JlfGFmdGVyKSQvKSAmJiAhaXNfbG9hZGVkICYmICF0aGlzLmlzX2xvYWRlZChwYXIpKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMubG9hZF9ub2RlKHBhciwgZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuY29weV9ub2RlKG9iaiwgcGFyLCBwb3MsIGNhbGxiYWNrLCB0cnVlLCBmYWxzZSwgb3JpZ2luKTtcXG5cXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCQuaXNBcnJheShvYmopKSB7XFxuXFx0XFx0XFx0XFx0aWYgKG9iai5sZW5ndGggPT09IDEpIHtcXG5cXHRcXHRcXHRcXHRcXHRvYmogPSBvYmpbMF07XFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHQvL29iaiA9IG9iai5zbGljZSgpO1xcblxcdFxcdFxcdFxcdFxcdGZvciAodDEgPSAwLCB0MiA9IG9iai5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAodG1wID0gdGhpcy5jb3B5X25vZGUob2JqW3QxXSwgcGFyLCBwb3MsIGNhbGxiYWNrLCBpc19sb2FkZWQsIHRydWUsIG9yaWdpbikpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRwYXIgPSB0bXA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cG9zID0gXFxcImFmdGVyXFxcIjtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdHRoaXMucmVkcmF3KCk7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRvYmogPSBvYmogJiYgb2JqLmlkID8gb2JqIDogdGhpcy5nZXRfbm9kZShvYmopO1xcblxcdFxcdFxcdGlmICghb2JqIHx8IG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCkge1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0b2xkX3BhciA9IChvYmoucGFyZW50IHx8ICQuanN0cmVlLnJvb3QpLnRvU3RyaW5nKCk7XFxuXFx0XFx0XFx0bmV3X3BhciA9ICFwb3MudG9TdHJpbmcoKS5tYXRjaCgvXihiZWZvcmV8YWZ0ZXIpJC8pIHx8IHBhci5pZCA9PT0gJC5qc3RyZWUucm9vdCA/IHBhciA6IHRoaXMuZ2V0X25vZGUocGFyLnBhcmVudCk7XFxuXFx0XFx0XFx0b2xkX2lucyA9IG9yaWdpbiA/IG9yaWdpbiA6IHRoaXMuX21vZGVsLmRhdGFbb2JqLmlkXSA/IHRoaXMgOiAkLmpzdHJlZS5yZWZlcmVuY2Uob2JqLmlkKTtcXG5cXHRcXHRcXHRpc19tdWx0aSA9ICFvbGRfaW5zIHx8ICFvbGRfaW5zLl9pZCB8fCB0aGlzLl9pZCAhPT0gb2xkX2lucy5faWQ7XFxuXFxuXFx0XFx0XFx0aWYgKG9sZF9pbnMgJiYgb2xkX2lucy5faWQpIHtcXG5cXHRcXHRcXHRcXHRvYmogPSBvbGRfaW5zLl9tb2RlbC5kYXRhW29iai5pZF07XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmIChwYXIuaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcXG5cXHRcXHRcXHRcXHRpZiAocG9zID09PSBcXFwiYmVmb3JlXFxcIikge1xcblxcdFxcdFxcdFxcdFxcdHBvcyA9IFxcXCJmaXJzdFxcXCI7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGlmIChwb3MgPT09IFxcXCJhZnRlclxcXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRwb3MgPSBcXFwibGFzdFxcXCI7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRzd2l0Y2ggKHBvcykge1xcblxcdFxcdFxcdFxcdGNhc2UgXFxcImJlZm9yZVxcXCI6XFxuXFx0XFx0XFx0XFx0XFx0cG9zID0gJC5pbkFycmF5KHBhci5pZCwgbmV3X3Bhci5jaGlsZHJlbik7XFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0Y2FzZSBcXFwiYWZ0ZXJcXFwiOlxcblxcdFxcdFxcdFxcdFxcdHBvcyA9ICQuaW5BcnJheShwYXIuaWQsIG5ld19wYXIuY2hpbGRyZW4pICsgMTtcXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRjYXNlIFxcXCJpbnNpZGVcXFwiOlxcblxcdFxcdFxcdFxcdGNhc2UgXFxcImZpcnN0XFxcIjpcXG5cXHRcXHRcXHRcXHRcXHRwb3MgPSAwO1xcblxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdGNhc2UgXFxcImxhc3RcXFwiOlxcblxcdFxcdFxcdFxcdFxcdHBvcyA9IG5ld19wYXIuY2hpbGRyZW4ubGVuZ3RoO1xcblxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdGRlZmF1bHQ6XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCFwb3MpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRwb3MgPSAwO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKHBvcyA+IG5ld19wYXIuY2hpbGRyZW4ubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0cG9zID0gbmV3X3Bhci5jaGlsZHJlbi5sZW5ndGg7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICghdGhpcy5jaGVjayhcXFwiY29weV9ub2RlXFxcIiwgb2JqLCBuZXdfcGFyLCBwb3MsIHsgJ2NvcmUnOiB0cnVlLCAnb3JpZ2luJzogb3JpZ2luLCAnaXNfbXVsdGknOiBvbGRfaW5zICYmIG9sZF9pbnMuX2lkICYmIG9sZF9pbnMuX2lkICE9PSB0aGlzLl9pZCwgJ2lzX2ZvcmVpZ24nOiAhb2xkX2lucyB8fCAhb2xkX2lucy5faWQgfSkpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLnNldHRpbmdzLmNvcmUuZXJyb3IuY2FsbCh0aGlzLCB0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvcik7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRub2RlID0gb2xkX2lucyA/IG9sZF9pbnMuZ2V0X2pzb24ob2JqLCB7IG5vX2lkOiB0cnVlLCBub19kYXRhOiB0cnVlLCBub19zdGF0ZTogdHJ1ZSB9KSA6IG9iajtcXG5cXHRcXHRcXHRpZiAoIW5vZGUpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmIChub2RlLmlkID09PSB0cnVlKSB7XFxuXFx0XFx0XFx0XFx0ZGVsZXRlIG5vZGUuaWQ7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdG5vZGUgPSB0aGlzLl9wYXJzZV9tb2RlbF9mcm9tX2pzb24obm9kZSwgbmV3X3Bhci5pZCwgbmV3X3Bhci5wYXJlbnRzLmNvbmNhdCgpKTtcXG5cXHRcXHRcXHRpZiAoIW5vZGUpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHRtcCA9IHRoaXMuZ2V0X25vZGUobm9kZSk7XFxuXFx0XFx0XFx0aWYgKG9iaiAmJiBvYmouc3RhdGUgJiYgb2JqLnN0YXRlLmxvYWRlZCA9PT0gZmFsc2UpIHtcXG5cXHRcXHRcXHRcXHR0bXAuc3RhdGUubG9hZGVkID0gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGRwYyA9IFtdO1xcblxcdFxcdFxcdGRwYy5wdXNoKG5vZGUpO1xcblxcdFxcdFxcdGRwYyA9IGRwYy5jb25jYXQodG1wLmNoaWxkcmVuX2QpO1xcblxcdFxcdFxcdHRoaXMudHJpZ2dlcignbW9kZWwnLCB7IFxcXCJub2Rlc1xcXCI6IGRwYywgXFxcInBhcmVudFxcXCI6IG5ld19wYXIuaWQgfSk7XFxuXFxuXFx0XFx0XFx0Ly8gaW5zZXJ0IGludG8gbmV3IHBhcmVudCBhbmQgdXBcXG5cXHRcXHRcXHRmb3IgKGkgPSAwLCBqID0gbmV3X3Bhci5wYXJlbnRzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcblxcdFxcdFxcdFxcdHRoaXMuX21vZGVsLmRhdGFbbmV3X3Bhci5wYXJlbnRzW2ldXS5jaGlsZHJlbl9kID0gdGhpcy5fbW9kZWwuZGF0YVtuZXdfcGFyLnBhcmVudHNbaV1dLmNoaWxkcmVuX2QuY29uY2F0KGRwYyk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGRwYyA9IFtdO1xcblxcdFxcdFxcdGZvciAoaSA9IDAsIGogPSBuZXdfcGFyLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcblxcdFxcdFxcdFxcdGRwY1tpID49IHBvcyA/IGkgKyAxIDogaV0gPSBuZXdfcGFyLmNoaWxkcmVuW2ldO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRkcGNbcG9zXSA9IHRtcC5pZDtcXG5cXHRcXHRcXHRuZXdfcGFyLmNoaWxkcmVuID0gZHBjO1xcblxcdFxcdFxcdG5ld19wYXIuY2hpbGRyZW5fZC5wdXNoKHRtcC5pZCk7XFxuXFx0XFx0XFx0bmV3X3Bhci5jaGlsZHJlbl9kID0gbmV3X3Bhci5jaGlsZHJlbl9kLmNvbmNhdCh0bXAuY2hpbGRyZW5fZCk7XFxuXFxuXFx0XFx0XFx0aWYgKG5ld19wYXIuaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9tb2RlbC5mb3JjZV9mdWxsX3JlZHJhdyA9IHRydWU7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICghdGhpcy5fbW9kZWwuZm9yY2VfZnVsbF9yZWRyYXcpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9ub2RlX2NoYW5nZWQobmV3X3Bhci5pZCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICghc2tpcF9yZWRyYXcpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLnJlZHJhdyhuZXdfcGFyLmlkID09PSAkLmpzdHJlZS5yb290KTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKGNhbGxiYWNrKSB7XFxuXFx0XFx0XFx0XFx0Y2FsbGJhY2suY2FsbCh0aGlzLCB0bXAsIG5ld19wYXIsIHBvcyk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdC8qKlxcbiAgICAqIHRyaWdnZXJlZCB3aGVuIGEgbm9kZSBpcyBjb3BpZWRcXG4gICAgKiBAZXZlbnRcXG4gICAgKiBAbmFtZSBjb3B5X25vZGUuanN0cmVlXFxuICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGUgdGhlIGNvcGllZCBub2RlXFxuICAgICogQHBhcmFtIHtPYmplY3R9IG9yaWdpbmFsIHRoZSBvcmlnaW5hbCBub2RlXFxuICAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmVudCB0aGUgcGFyZW50J3MgSURcXG4gICAgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb24gdGhlIHBvc2l0aW9uIG9mIHRoZSBub2RlIGFtb25nIHRoZSBwYXJlbnQncyBjaGlsZHJlblxcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRfcGFyZW50IHRoZSBvbGQgcGFyZW50IG9mIHRoZSBub2RlXFxuICAgICogQHBhcmFtIHtOdW1iZXJ9IG9sZF9wb3NpdGlvbiB0aGUgcG9zaXRpb24gb2YgdGhlIG9yaWdpbmFsIG5vZGVcXG4gICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzX211bHRpIGRvIHRoZSBub2RlIGFuZCBuZXcgcGFyZW50IGJlbG9uZyB0byBkaWZmZXJlbnQgaW5zdGFuY2VzXFxuICAgICogQHBhcmFtIHtqc1RyZWV9IG9sZF9pbnN0YW5jZSB0aGUgaW5zdGFuY2UgdGhlIG5vZGUgY2FtZSBmcm9tXFxuICAgICogQHBhcmFtIHtqc1RyZWV9IG5ld19pbnN0YW5jZSB0aGUgaW5zdGFuY2Ugb2YgdGhlIG5ldyBwYXJlbnRcXG4gICAgKi9cXG5cXHRcXHRcXHR0aGlzLnRyaWdnZXIoJ2NvcHlfbm9kZScsIHsgXFxcIm5vZGVcXFwiOiB0bXAsIFxcXCJvcmlnaW5hbFxcXCI6IG9iaiwgXFxcInBhcmVudFxcXCI6IG5ld19wYXIuaWQsIFxcXCJwb3NpdGlvblxcXCI6IHBvcywgXFxcIm9sZF9wYXJlbnRcXFwiOiBvbGRfcGFyLCBcXFwib2xkX3Bvc2l0aW9uXFxcIjogb2xkX2lucyAmJiBvbGRfaW5zLl9pZCAmJiBvbGRfcGFyICYmIG9sZF9pbnMuX21vZGVsLmRhdGFbb2xkX3Bhcl0gJiYgb2xkX2lucy5fbW9kZWwuZGF0YVtvbGRfcGFyXS5jaGlsZHJlbiA/ICQuaW5BcnJheShvYmouaWQsIG9sZF9pbnMuX21vZGVsLmRhdGFbb2xkX3Bhcl0uY2hpbGRyZW4pIDogLTEsICdpc19tdWx0aSc6IG9sZF9pbnMgJiYgb2xkX2lucy5faWQgJiYgb2xkX2lucy5faWQgIT09IHRoaXMuX2lkLCAnaXNfZm9yZWlnbic6ICFvbGRfaW5zIHx8ICFvbGRfaW5zLl9pZCwgJ29sZF9pbnN0YW5jZSc6IG9sZF9pbnMsICduZXdfaW5zdGFuY2UnOiB0aGlzIH0pO1xcblxcdFxcdFxcdHJldHVybiB0bXAuaWQ7XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIGN1dCBhIG5vZGUgKGEgbGF0ZXIgY2FsbCB0byBgcGFzdGUob2JqKWAgd291bGQgbW92ZSB0aGUgbm9kZSlcXG4gICAqIEBuYW1lIGN1dChvYmopXFxuICAgKiBAcGFyYW0gIHttaXhlZH0gb2JqIG11bHRpcGxlIG9iamVjdHMgY2FuIGJlIHBhc3NlZCB1c2luZyBhbiBhcnJheVxcbiAgICogQHRyaWdnZXIgY3V0LmpzdHJlZVxcbiAgICovXFxuXFx0XFx0Y3V0OiBmdW5jdGlvbiBjdXQob2JqKSB7XFxuXFx0XFx0XFx0aWYgKCFvYmopIHtcXG5cXHRcXHRcXHRcXHRvYmogPSB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQuY29uY2F0KCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICghJC5pc0FycmF5KG9iaikpIHtcXG5cXHRcXHRcXHRcXHRvYmogPSBbb2JqXTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKCFvYmoubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR2YXIgdG1wID0gW10sXFxuXFx0XFx0XFx0ICAgIG8sXFxuXFx0XFx0XFx0ICAgIHQxLFxcblxcdFxcdFxcdCAgICB0MjtcXG5cXHRcXHRcXHRmb3IgKHQxID0gMCwgdDIgPSBvYmoubGVuZ3RoOyB0MSA8IHQyOyB0MSsrKSB7XFxuXFx0XFx0XFx0XFx0byA9IHRoaXMuZ2V0X25vZGUob2JqW3QxXSk7XFxuXFx0XFx0XFx0XFx0aWYgKG8gJiYgby5pZCAmJiBvLmlkICE9PSAkLmpzdHJlZS5yb290KSB7XFxuXFx0XFx0XFx0XFx0XFx0dG1wLnB1c2gobyk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoIXRtcC5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGNjcF9ub2RlID0gdG1wO1xcblxcdFxcdFxcdGNjcF9pbnN0ID0gdGhpcztcXG5cXHRcXHRcXHRjY3BfbW9kZSA9ICdtb3ZlX25vZGUnO1xcblxcdFxcdFxcdC8qKlxcbiAgICAqIHRyaWdnZXJlZCB3aGVuIG5vZGVzIGFyZSBhZGRlZCB0byB0aGUgYnVmZmVyIGZvciBtb3ZpbmdcXG4gICAgKiBAZXZlbnRcXG4gICAgKiBAbmFtZSBjdXQuanN0cmVlXFxuICAgICogQHBhcmFtIHtBcnJheX0gbm9kZVxcbiAgICAqL1xcblxcdFxcdFxcdHRoaXMudHJpZ2dlcignY3V0JywgeyBcXFwibm9kZVxcXCI6IG9iaiB9KTtcXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogY29weSBhIG5vZGUgKGEgbGF0ZXIgY2FsbCB0byBgcGFzdGUob2JqKWAgd291bGQgY29weSB0aGUgbm9kZSlcXG4gICAqIEBuYW1lIGNvcHkob2JqKVxcbiAgICogQHBhcmFtICB7bWl4ZWR9IG9iaiBtdWx0aXBsZSBvYmplY3RzIGNhbiBiZSBwYXNzZWQgdXNpbmcgYW4gYXJyYXlcXG4gICAqIEB0cmlnZ2VyIGNvcHkuanN0cmVlXFxuICAgKi9cXG5cXHRcXHRjb3B5OiBmdW5jdGlvbiBjb3B5KG9iaikge1xcblxcdFxcdFxcdGlmICghb2JqKSB7XFxuXFx0XFx0XFx0XFx0b2JqID0gdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLmNvbmNhdCgpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoISQuaXNBcnJheShvYmopKSB7XFxuXFx0XFx0XFx0XFx0b2JqID0gW29ial07XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICghb2JqLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0dmFyIHRtcCA9IFtdLFxcblxcdFxcdFxcdCAgICBvLFxcblxcdFxcdFxcdCAgICB0MSxcXG5cXHRcXHRcXHQgICAgdDI7XFxuXFx0XFx0XFx0Zm9yICh0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xcblxcdFxcdFxcdFxcdG8gPSB0aGlzLmdldF9ub2RlKG9ialt0MV0pO1xcblxcdFxcdFxcdFxcdGlmIChvICYmIG8uaWQgJiYgby5pZCAhPT0gJC5qc3RyZWUucm9vdCkge1xcblxcdFxcdFxcdFxcdFxcdHRtcC5wdXNoKG8pO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKCF0bXAubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRjY3Bfbm9kZSA9IHRtcDtcXG5cXHRcXHRcXHRjY3BfaW5zdCA9IHRoaXM7XFxuXFx0XFx0XFx0Y2NwX21vZGUgPSAnY29weV9ub2RlJztcXG5cXHRcXHRcXHQvKipcXG4gICAgKiB0cmlnZ2VyZWQgd2hlbiBub2RlcyBhcmUgYWRkZWQgdG8gdGhlIGJ1ZmZlciBmb3IgY29weWluZ1xcbiAgICAqIEBldmVudFxcbiAgICAqIEBuYW1lIGNvcHkuanN0cmVlXFxuICAgICogQHBhcmFtIHtBcnJheX0gbm9kZVxcbiAgICAqL1xcblxcdFxcdFxcdHRoaXMudHJpZ2dlcignY29weScsIHsgXFxcIm5vZGVcXFwiOiBvYmogfSk7XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIGdldCB0aGUgY3VycmVudCBidWZmZXIgKGFueSBub2RlcyB0aGF0IGFyZSB3YWl0aW5nIGZvciBhIHBhc3RlIG9wZXJhdGlvbilcXG4gICAqIEBuYW1lIGdldF9idWZmZXIoKVxcbiAgICogQHJldHVybiB7T2JqZWN0fSBhbiBvYmplY3QgY29uc2lzdGluZyBvZiBgbW9kZWAgKFxcXCJjb3B5X25vZGVcXFwiIG9yIFxcXCJtb3ZlX25vZGVcXFwiKSwgYG5vZGVgIChhbiBhcnJheSBvZiBvYmplY3RzKSBhbmQgYGluc3RgICh0aGUgaW5zdGFuY2UpXFxuICAgKi9cXG5cXHRcXHRnZXRfYnVmZmVyOiBmdW5jdGlvbiBnZXRfYnVmZmVyKCkge1xcblxcdFxcdFxcdHJldHVybiB7ICdtb2RlJzogY2NwX21vZGUsICdub2RlJzogY2NwX25vZGUsICdpbnN0JzogY2NwX2luc3QgfTtcXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogY2hlY2sgaWYgdGhlcmUgaXMgc29tZXRoaW5nIGluIHRoZSBidWZmZXIgdG8gcGFzdGVcXG4gICAqIEBuYW1lIGNhbl9wYXN0ZSgpXFxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxcbiAgICovXFxuXFx0XFx0Y2FuX3Bhc3RlOiBmdW5jdGlvbiBjYW5fcGFzdGUoKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGNjcF9tb2RlICE9PSBmYWxzZSAmJiBjY3Bfbm9kZSAhPT0gZmFsc2U7IC8vICYmIGNjcF9pbnN0Ll9tb2RlbC5kYXRhW2NjcF9ub2RlXTtcXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogY29weSBvciBtb3ZlIHRoZSBwcmV2aW91c2x5IGN1dCBvciBjb3BpZWQgbm9kZXMgdG8gYSBuZXcgcGFyZW50XFxuICAgKiBAbmFtZSBwYXN0ZShvYmogWywgcG9zXSlcXG4gICAqIEBwYXJhbSAge21peGVkfSBvYmogdGhlIG5ldyBwYXJlbnRcXG4gICAqIEBwYXJhbSAge21peGVkfSBwb3MgdGhlIHBvc2l0aW9uIHRvIGluc2VydCBhdCAoYmVzaWRlcyBpbnRlZ2VyLCBcXFwiZmlyc3RcXFwiIGFuZCBcXFwibGFzdFxcXCIgYXJlIHN1cHBvcnRlZCksIGRlZmF1bHRzIHRvIGludGVnZXIgYDBgXFxuICAgKiBAdHJpZ2dlciBwYXN0ZS5qc3RyZWVcXG4gICAqL1xcblxcdFxcdHBhc3RlOiBmdW5jdGlvbiBwYXN0ZShvYmosIHBvcykge1xcblxcdFxcdFxcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXHRcXHRcXHRpZiAoIW9iaiB8fCAhY2NwX21vZGUgfHwgIWNjcF9tb2RlLm1hdGNoKC9eKGNvcHlfbm9kZXxtb3ZlX25vZGUpJC8pIHx8ICFjY3Bfbm9kZSkge1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKHRoaXNbY2NwX21vZGVdKGNjcF9ub2RlLCBvYmosIHBvcywgZmFsc2UsIGZhbHNlLCBmYWxzZSwgY2NwX2luc3QpKSB7XFxuXFx0XFx0XFx0XFx0LyoqXFxuICAgICAqIHRyaWdnZXJlZCB3aGVuIHBhc3RlIGlzIGludm9rZWRcXG4gICAgICogQGV2ZW50XFxuICAgICAqIEBuYW1lIHBhc3RlLmpzdHJlZVxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyZW50IHRoZSBJRCBvZiB0aGUgcmVjZWl2aW5nIG5vZGVcXG4gICAgICogQHBhcmFtIHtBcnJheX0gbm9kZSB0aGUgbm9kZXMgaW4gdGhlIGJ1ZmZlclxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbW9kZSB0aGUgcGVyZm9ybWVkIG9wZXJhdGlvbiAtIFxcXCJjb3B5X25vZGVcXFwiIG9yIFxcXCJtb3ZlX25vZGVcXFwiXFxuICAgICAqL1xcblxcdFxcdFxcdFxcdHRoaXMudHJpZ2dlcigncGFzdGUnLCB7IFxcXCJwYXJlbnRcXFwiOiBvYmouaWQsIFxcXCJub2RlXFxcIjogY2NwX25vZGUsIFxcXCJtb2RlXFxcIjogY2NwX21vZGUgfSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGNjcF9ub2RlID0gZmFsc2U7XFxuXFx0XFx0XFx0Y2NwX21vZGUgPSBmYWxzZTtcXG5cXHRcXHRcXHRjY3BfaW5zdCA9IGZhbHNlO1xcblxcdFxcdH0sXFxuXFx0XFx0LyoqXFxuICAgKiBjbGVhciB0aGUgYnVmZmVyIG9mIHByZXZpb3VzbHkgY29waWVkIG9yIGN1dCBub2Rlc1xcbiAgICogQG5hbWUgY2xlYXJfYnVmZmVyKClcXG4gICAqIEB0cmlnZ2VyIGNsZWFyX2J1ZmZlci5qc3RyZWVcXG4gICAqL1xcblxcdFxcdGNsZWFyX2J1ZmZlcjogZnVuY3Rpb24gY2xlYXJfYnVmZmVyKCkge1xcblxcdFxcdFxcdGNjcF9ub2RlID0gZmFsc2U7XFxuXFx0XFx0XFx0Y2NwX21vZGUgPSBmYWxzZTtcXG5cXHRcXHRcXHRjY3BfaW5zdCA9IGZhbHNlO1xcblxcdFxcdFxcdC8qKlxcbiAgICAqIHRyaWdnZXJlZCB3aGVuIHRoZSBjb3B5IC8gY3V0IGJ1ZmZlciBpcyBjbGVhcmVkXFxuICAgICogQGV2ZW50XFxuICAgICogQG5hbWUgY2xlYXJfYnVmZmVyLmpzdHJlZVxcbiAgICAqL1xcblxcdFxcdFxcdHRoaXMudHJpZ2dlcignY2xlYXJfYnVmZmVyJyk7XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIHB1dCBhIG5vZGUgaW4gZWRpdCBtb2RlIChpbnB1dCBmaWVsZCB0byByZW5hbWUgdGhlIG5vZGUpXFxuICAgKiBAbmFtZSBlZGl0KG9iaiBbLCBkZWZhdWx0X3RleHQsIGNhbGxiYWNrXSlcXG4gICAqIEBwYXJhbSAge21peGVkfSBvYmpcXG4gICAqIEBwYXJhbSAge1N0cmluZ30gZGVmYXVsdF90ZXh0IHRoZSB0ZXh0IHRvIHBvcHVsYXRlIHRoZSBpbnB1dCB3aXRoIChpZiBvbWl0dGVkIG9yIHNldCB0byBhIG5vbi1zdHJpbmcgdmFsdWUgdGhlIG5vZGUncyB0ZXh0IHZhbHVlIGlzIHVzZWQpXFxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2sgYSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb25jZSB0aGUgdGV4dCBib3ggaXMgYmx1cnJlZCwgaXQgaXMgY2FsbGVkIGluIHRoZSBpbnN0YW5jZSdzIHNjb3BlIGFuZCByZWNlaXZlcyB0aGUgbm9kZSwgYSBzdGF0dXMgcGFyYW1ldGVyICh0cnVlIGlmIHRoZSByZW5hbWUgaXMgc3VjY2Vzc2Z1bCwgZmFsc2Ugb3RoZXJ3aXNlKSBhbmQgYSBib29sZWFuIGluZGljYXRpbmcgaWYgdGhlIHVzZXIgY2FuY2VsbGVkIHRoZSBlZGl0LiBZb3UgY2FuIGFjY2VzcyB0aGUgbm9kZSdzIHRpdGxlIHVzaW5nIC50ZXh0XFxuICAgKi9cXG5cXHRcXHRlZGl0OiBmdW5jdGlvbiBlZGl0KG9iaiwgZGVmYXVsdF90ZXh0LCBjYWxsYmFjaykge1xcblxcdFxcdFxcdHZhciBydGwsXFxuXFx0XFx0XFx0ICAgIHcsXFxuXFx0XFx0XFx0ICAgIGEsXFxuXFx0XFx0XFx0ICAgIHMsXFxuXFx0XFx0XFx0ICAgIHQsXFxuXFx0XFx0XFx0ICAgIGgxLFxcblxcdFxcdFxcdCAgICBoMixcXG5cXHRcXHRcXHQgICAgZm4sXFxuXFx0XFx0XFx0ICAgIHRtcCxcXG5cXHRcXHRcXHQgICAgY2FuY2VsID0gZmFsc2U7XFxuXFx0XFx0XFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xcblxcdFxcdFxcdGlmICghb2JqKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAodGhpcy5zZXR0aW5ncy5jb3JlLmNoZWNrX2NhbGxiYWNrID09PSBmYWxzZSkge1xcblxcdFxcdFxcdFxcdHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yID0geyAnZXJyb3InOiAnY2hlY2snLCAncGx1Z2luJzogJ2NvcmUnLCAnaWQnOiAnY29yZV8wNycsICdyZWFzb24nOiAnQ291bGQgbm90IGVkaXQgbm9kZSBiZWNhdXNlIG9mIGNoZWNrX2NhbGxiYWNrJyB9O1xcblxcdFxcdFxcdFxcdHRoaXMuc2V0dGluZ3MuY29yZS5lcnJvci5jYWxsKHRoaXMsIHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHRtcCA9IG9iajtcXG5cXHRcXHRcXHRkZWZhdWx0X3RleHQgPSB0eXBlb2YgZGVmYXVsdF90ZXh0ID09PSAnc3RyaW5nJyA/IGRlZmF1bHRfdGV4dCA6IG9iai50ZXh0O1xcblxcdFxcdFxcdHRoaXMuc2V0X3RleHQob2JqLCBcXFwiXFxcIik7XFxuXFx0XFx0XFx0b2JqID0gdGhpcy5fb3Blbl90byhvYmopO1xcblxcdFxcdFxcdHRtcC50ZXh0ID0gZGVmYXVsdF90ZXh0O1xcblxcblxcdFxcdFxcdHJ0bCA9IHRoaXMuX2RhdGEuY29yZS5ydGw7XFxuXFx0XFx0XFx0dyA9IHRoaXMuZWxlbWVudC53aWR0aCgpO1xcblxcdFxcdFxcdHRoaXMuX2RhdGEuY29yZS5mb2N1c2VkID0gdG1wLmlkO1xcblxcdFxcdFxcdGEgPSBvYmouY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuZm9jdXMoKTtcXG5cXHRcXHRcXHRzID0gJCgnPHNwYW4+Jyk7XFxuXFx0XFx0XFx0LyohXFxuICAgb2kgPSBvYmouY2hpbGRyZW4oXFxcImk6dmlzaWJsZVxcXCIpLFxcbiAgIGFpID0gYS5jaGlsZHJlbihcXFwiaTp2aXNpYmxlXFxcIiksXFxuICAgdzEgPSBvaS53aWR0aCgpICogb2kubGVuZ3RoLFxcbiAgIHcyID0gYWkud2lkdGgoKSAqIGFpLmxlbmd0aCxcXG4gICAqL1xcblxcdFxcdFxcdHQgPSBkZWZhdWx0X3RleHQ7XFxuXFx0XFx0XFx0aDEgPSAkKFxcXCI8XFxcIiArIFxcXCJkaXYgLz5cXFwiLCB7IGNzczogeyBcXFwicG9zaXRpb25cXFwiOiBcXFwiYWJzb2x1dGVcXFwiLCBcXFwidG9wXFxcIjogXFxcIi0yMDBweFxcXCIsIFxcXCJsZWZ0XFxcIjogcnRsID8gXFxcIjBweFxcXCIgOiBcXFwiLTEwMDBweFxcXCIsIFxcXCJ2aXNpYmlsaXR5XFxcIjogXFxcImhpZGRlblxcXCIgfSB9KS5hcHBlbmRUbyhcXFwiYm9keVxcXCIpO1xcblxcdFxcdFxcdGgyID0gJChcXFwiPFxcXCIgKyBcXFwiaW5wdXQgLz5cXFwiLCB7XFxuXFx0XFx0XFx0XFx0XFxcInZhbHVlXFxcIjogdCxcXG5cXHRcXHRcXHRcXHRcXFwiY2xhc3NcXFwiOiBcXFwianN0cmVlLXJlbmFtZS1pbnB1dFxcXCIsXFxuXFx0XFx0XFx0XFx0Ly8gXFxcInNpemVcXFwiIDogdC5sZW5ndGgsXFxuXFx0XFx0XFx0XFx0XFxcImNzc1xcXCI6IHtcXG5cXHRcXHRcXHRcXHRcXHRcXFwicGFkZGluZ1xcXCI6IFxcXCIwXFxcIixcXG5cXHRcXHRcXHRcXHRcXHRcXFwiYm9yZGVyXFxcIjogXFxcIjFweCBzb2xpZCBzaWx2ZXJcXFwiLFxcblxcdFxcdFxcdFxcdFxcdFxcXCJib3gtc2l6aW5nXFxcIjogXFxcImJvcmRlci1ib3hcXFwiLFxcblxcdFxcdFxcdFxcdFxcdFxcXCJkaXNwbGF5XFxcIjogXFxcImlubGluZS1ibG9ja1xcXCIsXFxuXFx0XFx0XFx0XFx0XFx0XFxcImhlaWdodFxcXCI6IHRoaXMuX2RhdGEuY29yZS5saV9oZWlnaHQgKyBcXFwicHhcXFwiLFxcblxcdFxcdFxcdFxcdFxcdFxcXCJsaW5lSGVpZ2h0XFxcIjogdGhpcy5fZGF0YS5jb3JlLmxpX2hlaWdodCArIFxcXCJweFxcXCIsXFxuXFx0XFx0XFx0XFx0XFx0XFxcIndpZHRoXFxcIjogXFxcIjE1MHB4XFxcIiAvLyB3aWxsIGJlIHNldCBhIGJpdCBmdXJ0aGVyIGRvd25cXG5cXHRcXHRcXHRcXHR9LFxcblxcdFxcdFxcdFxcdFxcXCJibHVyXFxcIjogJC5wcm94eShmdW5jdGlvbiAoZSkge1xcblxcdFxcdFxcdFxcdFxcdGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XFxuXFx0XFx0XFx0XFx0XFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdFxcdFxcdFxcdFxcdHZhciBpID0gcy5jaGlsZHJlbihcXFwiLmpzdHJlZS1yZW5hbWUtaW5wdXRcXFwiKSxcXG5cXHRcXHRcXHRcXHRcXHQgICAgdiA9IGkudmFsKCksXFxuXFx0XFx0XFx0XFx0XFx0ICAgIGYgPSB0aGlzLnNldHRpbmdzLmNvcmUuZm9yY2VfdGV4dCxcXG5cXHRcXHRcXHRcXHRcXHQgICAgbnY7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHYgPT09IFxcXCJcXFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0diA9IHQ7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGgxLnJlbW92ZSgpO1xcblxcdFxcdFxcdFxcdFxcdHMucmVwbGFjZVdpdGgoYSk7XFxuXFx0XFx0XFx0XFx0XFx0cy5yZW1vdmUoKTtcXG5cXHRcXHRcXHRcXHRcXHR0ID0gZiA/IHQgOiAkKCc8ZGl2PjwvZGl2PicpLmFwcGVuZCgkLnBhcnNlSFRNTCh0KSkuaHRtbCgpO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuc2V0X3RleHQob2JqLCB0KTtcXG5cXHRcXHRcXHRcXHRcXHRudiA9ICEhdGhpcy5yZW5hbWVfbm9kZShvYmosIGYgPyAkKCc8ZGl2PjwvZGl2PicpLnRleHQodikudGV4dCgpIDogJCgnPGRpdj48L2Rpdj4nKS5hcHBlbmQoJC5wYXJzZUhUTUwodikpLmh0bWwoKSk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCFudikge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuc2V0X3RleHQob2JqLCB0KTsgLy8gbW92ZSB0aGlzIHVwPyBhbmQgZml4ICM0ODNcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fZGF0YS5jb3JlLmZvY3VzZWQgPSB0bXAuaWQ7XFxuXFx0XFx0XFx0XFx0XFx0c2V0VGltZW91dCgkLnByb3h5KGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgbm9kZSA9IHRoaXMuZ2V0X25vZGUodG1wLmlkLCB0cnVlKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAobm9kZS5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl9kYXRhLmNvcmUuZm9jdXNlZCA9IHRtcC5pZDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRub2RlLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLmZvY3VzKCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH0sIHRoaXMpLCAwKTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoY2FsbGJhY2spIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYWxsYmFjay5jYWxsKHRoaXMsIHRtcCwgbnYsIGNhbmNlbCk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGgyID0gbnVsbDtcXG5cXHRcXHRcXHRcXHR9LCB0aGlzKSxcXG5cXHRcXHRcXHRcXHRcXFwia2V5ZG93blxcXCI6IGZ1bmN0aW9uIGtleWRvd24oZSkge1xcblxcdFxcdFxcdFxcdFxcdHZhciBrZXkgPSBlLndoaWNoO1xcblxcdFxcdFxcdFxcdFxcdGlmIChrZXkgPT09IDI3KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FuY2VsID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLnZhbHVlID0gdDtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGtleSA9PT0gMjcgfHwga2V5ID09PSAxMyB8fCBrZXkgPT09IDM3IHx8IGtleSA9PT0gMzggfHwga2V5ID09PSAzOSB8fCBrZXkgPT09IDQwIHx8IGtleSA9PT0gMzIpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRpZiAoa2V5ID09PSAyNyB8fCBrZXkgPT09IDEzKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuYmx1cigpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9LFxcblxcdFxcdFxcdFxcdFxcXCJjbGlja1xcXCI6IGZ1bmN0aW9uIGNsaWNrKGUpIHtcXG5cXHRcXHRcXHRcXHRcXHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xcblxcdFxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0XFx0XFxcIm1vdXNlZG93blxcXCI6IGZ1bmN0aW9uIG1vdXNlZG93bihlKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcXG5cXHRcXHRcXHRcXHR9LFxcblxcdFxcdFxcdFxcdFxcXCJrZXl1cFxcXCI6IGZ1bmN0aW9uIGtleXVwKGUpIHtcXG5cXHRcXHRcXHRcXHRcXHRoMi53aWR0aChNYXRoLm1pbihoMS50ZXh0KFxcXCJwV1xcXCIgKyB0aGlzLnZhbHVlKS53aWR0aCgpLCB3KSk7XFxuXFx0XFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRcXHRcXFwia2V5cHJlc3NcXFwiOiBmdW5jdGlvbiBrZXlwcmVzcyhlKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGUud2hpY2ggPT09IDEzKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0Zm4gPSB7XFxuXFx0XFx0XFx0XFx0Zm9udEZhbWlseTogYS5jc3MoJ2ZvbnRGYW1pbHknKSB8fCAnJyxcXG5cXHRcXHRcXHRcXHRmb250U2l6ZTogYS5jc3MoJ2ZvbnRTaXplJykgfHwgJycsXFxuXFx0XFx0XFx0XFx0Zm9udFdlaWdodDogYS5jc3MoJ2ZvbnRXZWlnaHQnKSB8fCAnJyxcXG5cXHRcXHRcXHRcXHRmb250U3R5bGU6IGEuY3NzKCdmb250U3R5bGUnKSB8fCAnJyxcXG5cXHRcXHRcXHRcXHRmb250U3RyZXRjaDogYS5jc3MoJ2ZvbnRTdHJldGNoJykgfHwgJycsXFxuXFx0XFx0XFx0XFx0Zm9udFZhcmlhbnQ6IGEuY3NzKCdmb250VmFyaWFudCcpIHx8ICcnLFxcblxcdFxcdFxcdFxcdGxldHRlclNwYWNpbmc6IGEuY3NzKCdsZXR0ZXJTcGFjaW5nJykgfHwgJycsXFxuXFx0XFx0XFx0XFx0d29yZFNwYWNpbmc6IGEuY3NzKCd3b3JkU3BhY2luZycpIHx8ICcnXFxuXFx0XFx0XFx0fTtcXG5cXHRcXHRcXHRzLmF0dHIoJ2NsYXNzJywgYS5hdHRyKCdjbGFzcycpKS5hcHBlbmQoYS5jb250ZW50cygpLmNsb25lKCkpLmFwcGVuZChoMik7XFxuXFx0XFx0XFx0YS5yZXBsYWNlV2l0aChzKTtcXG5cXHRcXHRcXHRoMS5jc3MoZm4pO1xcblxcdFxcdFxcdGgyLmNzcyhmbikud2lkdGgoTWF0aC5taW4oaDEudGV4dChcXFwicFdcXFwiICsgaDJbMF0udmFsdWUpLndpZHRoKCksIHcpKVswXS5zZWxlY3QoKTtcXG5cXHRcXHRcXHQkKGRvY3VtZW50KS5vbmUoJ21vdXNlZG93bi5qc3RyZWUgdG91Y2hzdGFydC5qc3RyZWUgZG5kX3N0YXJ0LnZha2F0YScsIGZ1bmN0aW9uIChlKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGgyICYmIGUudGFyZ2V0ICE9PSBoMikge1xcblxcdFxcdFxcdFxcdFxcdCQoaDIpLmJsdXIoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvKipcXG4gICAqIGNoYW5nZXMgdGhlIHRoZW1lXFxuICAgKiBAbmFtZSBzZXRfdGhlbWUodGhlbWVfbmFtZSBbLCB0aGVtZV91cmxdKVxcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRoZW1lX25hbWUgdGhlIG5hbWUgb2YgdGhlIG5ldyB0aGVtZSB0byBhcHBseVxcbiAgICogQHBhcmFtIHttaXhlZH0gdGhlbWVfdXJsICB0aGUgbG9jYXRpb24gb2YgdGhlIENTUyBmaWxlIGZvciB0aGlzIHRoZW1lLiBPbWl0IG9yIHNldCB0byBgZmFsc2VgIGlmIHlvdSBtYW51YWxseSBpbmNsdWRlZCB0aGUgZmlsZS4gU2V0IHRvIGB0cnVlYCB0byBhdXRvbG9hZCBmcm9tIHRoZSBgY29yZS50aGVtZXMuZGlyYCBkaXJlY3RvcnkuXFxuICAgKiBAdHJpZ2dlciBzZXRfdGhlbWUuanN0cmVlXFxuICAgKi9cXG5cXHRcXHRzZXRfdGhlbWU6IGZ1bmN0aW9uIHNldF90aGVtZSh0aGVtZV9uYW1lLCB0aGVtZV91cmwpIHtcXG5cXHRcXHRcXHRpZiAoIXRoZW1lX25hbWUpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICh0aGVtZV91cmwgPT09IHRydWUpIHtcXG5cXHRcXHRcXHRcXHR2YXIgZGlyID0gdGhpcy5zZXR0aW5ncy5jb3JlLnRoZW1lcy5kaXI7XFxuXFx0XFx0XFx0XFx0aWYgKCFkaXIpIHtcXG5cXHRcXHRcXHRcXHRcXHRkaXIgPSAkLmpzdHJlZS5wYXRoICsgJy90aGVtZXMnO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR0aGVtZV91cmwgPSBkaXIgKyAnLycgKyB0aGVtZV9uYW1lICsgJy9zdHlsZS5jc3MnO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAodGhlbWVfdXJsICYmICQuaW5BcnJheSh0aGVtZV91cmwsIHRoZW1lc19sb2FkZWQpID09PSAtMSkge1xcblxcdFxcdFxcdFxcdCQoJ2hlYWQnKS5hcHBlbmQoJzwnICsgJ2xpbmsgcmVsPVxcXCJzdHlsZXNoZWV0XFxcIiBocmVmPVxcXCInICsgdGhlbWVfdXJsICsgJ1xcXCIgdHlwZT1cXFwidGV4dC9jc3NcXFwiIC8+Jyk7XFxuXFx0XFx0XFx0XFx0dGhlbWVzX2xvYWRlZC5wdXNoKHRoZW1lX3VybCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICh0aGlzLl9kYXRhLmNvcmUudGhlbWVzLm5hbWUpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLmVsZW1lbnQucmVtb3ZlQ2xhc3MoJ2pzdHJlZS0nICsgdGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5uYW1lKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0dGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5uYW1lID0gdGhlbWVfbmFtZTtcXG5cXHRcXHRcXHR0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoJ2pzdHJlZS0nICsgdGhlbWVfbmFtZSk7XFxuXFx0XFx0XFx0dGhpcy5lbGVtZW50W3RoaXMuc2V0dGluZ3MuY29yZS50aGVtZXMucmVzcG9uc2l2ZSA/ICdhZGRDbGFzcycgOiAncmVtb3ZlQ2xhc3MnXSgnanN0cmVlLScgKyB0aGVtZV9uYW1lICsgJy1yZXNwb25zaXZlJyk7XFxuXFx0XFx0XFx0LyoqXFxuICAgICogdHJpZ2dlcmVkIHdoZW4gYSB0aGVtZSBpcyBzZXRcXG4gICAgKiBAZXZlbnRcXG4gICAgKiBAbmFtZSBzZXRfdGhlbWUuanN0cmVlXFxuICAgICogQHBhcmFtIHtTdHJpbmd9IHRoZW1lIHRoZSBuZXcgdGhlbWVcXG4gICAgKi9cXG5cXHRcXHRcXHR0aGlzLnRyaWdnZXIoJ3NldF90aGVtZScsIHsgJ3RoZW1lJzogdGhlbWVfbmFtZSB9KTtcXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogZ2V0cyB0aGUgbmFtZSBvZiB0aGUgY3VycmVudGx5IGFwcGxpZWQgdGhlbWUgbmFtZVxcbiAgICogQG5hbWUgZ2V0X3RoZW1lKClcXG4gICAqIEByZXR1cm4ge1N0cmluZ31cXG4gICAqL1xcblxcdFxcdGdldF90aGVtZTogZnVuY3Rpb24gZ2V0X3RoZW1lKCkge1xcblxcdFxcdFxcdHJldHVybiB0aGlzLl9kYXRhLmNvcmUudGhlbWVzLm5hbWU7XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIGNoYW5nZXMgdGhlIHRoZW1lIHZhcmlhbnQgKGlmIHRoZSB0aGVtZSBoYXMgdmFyaWFudHMpXFxuICAgKiBAbmFtZSBzZXRfdGhlbWVfdmFyaWFudCh2YXJpYW50X25hbWUpXFxuICAgKiBAcGFyYW0ge1N0cmluZ3xCb29sZWFufSB2YXJpYW50X25hbWUgdGhlIHZhcmlhbnQgdG8gYXBwbHkgKGlmIGBmYWxzZWAgaXMgdXNlZCB0aGUgY3VycmVudCB2YXJpYW50IGlzIHJlbW92ZWQpXFxuICAgKi9cXG5cXHRcXHRzZXRfdGhlbWVfdmFyaWFudDogZnVuY3Rpb24gc2V0X3RoZW1lX3ZhcmlhbnQodmFyaWFudF9uYW1lKSB7XFxuXFx0XFx0XFx0aWYgKHRoaXMuX2RhdGEuY29yZS50aGVtZXMudmFyaWFudCkge1xcblxcdFxcdFxcdFxcdHRoaXMuZWxlbWVudC5yZW1vdmVDbGFzcygnanN0cmVlLScgKyB0aGlzLl9kYXRhLmNvcmUudGhlbWVzLm5hbWUgKyAnLScgKyB0aGlzLl9kYXRhLmNvcmUudGhlbWVzLnZhcmlhbnQpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR0aGlzLl9kYXRhLmNvcmUudGhlbWVzLnZhcmlhbnQgPSB2YXJpYW50X25hbWU7XFxuXFx0XFx0XFx0aWYgKHZhcmlhbnRfbmFtZSkge1xcblxcdFxcdFxcdFxcdHRoaXMuZWxlbWVudC5hZGRDbGFzcygnanN0cmVlLScgKyB0aGlzLl9kYXRhLmNvcmUudGhlbWVzLm5hbWUgKyAnLScgKyB0aGlzLl9kYXRhLmNvcmUudGhlbWVzLnZhcmlhbnQpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogZ2V0cyB0aGUgbmFtZSBvZiB0aGUgY3VycmVudGx5IGFwcGxpZWQgdGhlbWUgdmFyaWFudFxcbiAgICogQG5hbWUgZ2V0X3RoZW1lKClcXG4gICAqIEByZXR1cm4ge1N0cmluZ31cXG4gICAqL1xcblxcdFxcdGdldF90aGVtZV92YXJpYW50OiBmdW5jdGlvbiBnZXRfdGhlbWVfdmFyaWFudCgpIHtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5fZGF0YS5jb3JlLnRoZW1lcy52YXJpYW50O1xcblxcdFxcdH0sXFxuXFx0XFx0LyoqXFxuICAgKiBzaG93cyBhIHN0cmlwZWQgYmFja2dyb3VuZCBvbiB0aGUgY29udGFpbmVyIChpZiB0aGUgdGhlbWUgc3VwcG9ydHMgaXQpXFxuICAgKiBAbmFtZSBzaG93X3N0cmlwZXMoKVxcbiAgICovXFxuXFx0XFx0c2hvd19zdHJpcGVzOiBmdW5jdGlvbiBzaG93X3N0cmlwZXMoKSB7XFxuXFx0XFx0XFx0dGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5zdHJpcGVzID0gdHJ1ZTtcXG5cXHRcXHRcXHR0aGlzLmdldF9jb250YWluZXJfdWwoKS5hZGRDbGFzcyhcXFwianN0cmVlLXN0cmlwZWRcXFwiKTtcXG5cXHRcXHRcXHQvKipcXG4gICAgKiB0cmlnZ2VyZWQgd2hlbiBzdHJpcGVzIGFyZSBzaG93blxcbiAgICAqIEBldmVudFxcbiAgICAqIEBuYW1lIHNob3dfc3RyaXBlcy5qc3RyZWVcXG4gICAgKi9cXG5cXHRcXHRcXHR0aGlzLnRyaWdnZXIoJ3Nob3dfc3RyaXBlcycpO1xcblxcdFxcdH0sXFxuXFx0XFx0LyoqXFxuICAgKiBoaWRlcyB0aGUgc3RyaXBlZCBiYWNrZ3JvdW5kIG9uIHRoZSBjb250YWluZXJcXG4gICAqIEBuYW1lIGhpZGVfc3RyaXBlcygpXFxuICAgKi9cXG5cXHRcXHRoaWRlX3N0cmlwZXM6IGZ1bmN0aW9uIGhpZGVfc3RyaXBlcygpIHtcXG5cXHRcXHRcXHR0aGlzLl9kYXRhLmNvcmUudGhlbWVzLnN0cmlwZXMgPSBmYWxzZTtcXG5cXHRcXHRcXHR0aGlzLmdldF9jb250YWluZXJfdWwoKS5yZW1vdmVDbGFzcyhcXFwianN0cmVlLXN0cmlwZWRcXFwiKTtcXG5cXHRcXHRcXHQvKipcXG4gICAgKiB0cmlnZ2VyZWQgd2hlbiBzdHJpcGVzIGFyZSBoaWRkZW5cXG4gICAgKiBAZXZlbnRcXG4gICAgKiBAbmFtZSBoaWRlX3N0cmlwZXMuanN0cmVlXFxuICAgICovXFxuXFx0XFx0XFx0dGhpcy50cmlnZ2VyKCdoaWRlX3N0cmlwZXMnKTtcXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogdG9nZ2xlcyB0aGUgc3RyaXBlZCBiYWNrZ3JvdW5kIG9uIHRoZSBjb250YWluZXJcXG4gICAqIEBuYW1lIHRvZ2dsZV9zdHJpcGVzKClcXG4gICAqL1xcblxcdFxcdHRvZ2dsZV9zdHJpcGVzOiBmdW5jdGlvbiB0b2dnbGVfc3RyaXBlcygpIHtcXG5cXHRcXHRcXHRpZiAodGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5zdHJpcGVzKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5oaWRlX3N0cmlwZXMoKTtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdHRoaXMuc2hvd19zdHJpcGVzKCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFx0XFx0LyoqXFxuICAgKiBzaG93cyB0aGUgY29ubmVjdGluZyBkb3RzIChpZiB0aGUgdGhlbWUgc3VwcG9ydHMgaXQpXFxuICAgKiBAbmFtZSBzaG93X2RvdHMoKVxcbiAgICovXFxuXFx0XFx0c2hvd19kb3RzOiBmdW5jdGlvbiBzaG93X2RvdHMoKSB7XFxuXFx0XFx0XFx0dGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5kb3RzID0gdHJ1ZTtcXG5cXHRcXHRcXHR0aGlzLmdldF9jb250YWluZXJfdWwoKS5yZW1vdmVDbGFzcyhcXFwianN0cmVlLW5vLWRvdHNcXFwiKTtcXG5cXHRcXHRcXHQvKipcXG4gICAgKiB0cmlnZ2VyZWQgd2hlbiBkb3RzIGFyZSBzaG93blxcbiAgICAqIEBldmVudFxcbiAgICAqIEBuYW1lIHNob3dfZG90cy5qc3RyZWVcXG4gICAgKi9cXG5cXHRcXHRcXHR0aGlzLnRyaWdnZXIoJ3Nob3dfZG90cycpO1xcblxcdFxcdH0sXFxuXFx0XFx0LyoqXFxuICAgKiBoaWRlcyB0aGUgY29ubmVjdGluZyBkb3RzXFxuICAgKiBAbmFtZSBoaWRlX2RvdHMoKVxcbiAgICovXFxuXFx0XFx0aGlkZV9kb3RzOiBmdW5jdGlvbiBoaWRlX2RvdHMoKSB7XFxuXFx0XFx0XFx0dGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5kb3RzID0gZmFsc2U7XFxuXFx0XFx0XFx0dGhpcy5nZXRfY29udGFpbmVyX3VsKCkuYWRkQ2xhc3MoXFxcImpzdHJlZS1uby1kb3RzXFxcIik7XFxuXFx0XFx0XFx0LyoqXFxuICAgICogdHJpZ2dlcmVkIHdoZW4gZG90cyBhcmUgaGlkZGVuXFxuICAgICogQGV2ZW50XFxuICAgICogQG5hbWUgaGlkZV9kb3RzLmpzdHJlZVxcbiAgICAqL1xcblxcdFxcdFxcdHRoaXMudHJpZ2dlcignaGlkZV9kb3RzJyk7XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIHRvZ2dsZXMgdGhlIGNvbm5lY3RpbmcgZG90c1xcbiAgICogQG5hbWUgdG9nZ2xlX2RvdHMoKVxcbiAgICovXFxuXFx0XFx0dG9nZ2xlX2RvdHM6IGZ1bmN0aW9uIHRvZ2dsZV9kb3RzKCkge1xcblxcdFxcdFxcdGlmICh0aGlzLl9kYXRhLmNvcmUudGhlbWVzLmRvdHMpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLmhpZGVfZG90cygpO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5zaG93X2RvdHMoKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIHNob3cgdGhlIG5vZGUgaWNvbnNcXG4gICAqIEBuYW1lIHNob3dfaWNvbnMoKVxcbiAgICovXFxuXFx0XFx0c2hvd19pY29uczogZnVuY3Rpb24gc2hvd19pY29ucygpIHtcXG5cXHRcXHRcXHR0aGlzLl9kYXRhLmNvcmUudGhlbWVzLmljb25zID0gdHJ1ZTtcXG5cXHRcXHRcXHR0aGlzLmdldF9jb250YWluZXJfdWwoKS5yZW1vdmVDbGFzcyhcXFwianN0cmVlLW5vLWljb25zXFxcIik7XFxuXFx0XFx0XFx0LyoqXFxuICAgICogdHJpZ2dlcmVkIHdoZW4gaWNvbnMgYXJlIHNob3duXFxuICAgICogQGV2ZW50XFxuICAgICogQG5hbWUgc2hvd19pY29ucy5qc3RyZWVcXG4gICAgKi9cXG5cXHRcXHRcXHR0aGlzLnRyaWdnZXIoJ3Nob3dfaWNvbnMnKTtcXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogaGlkZSB0aGUgbm9kZSBpY29uc1xcbiAgICogQG5hbWUgaGlkZV9pY29ucygpXFxuICAgKi9cXG5cXHRcXHRoaWRlX2ljb25zOiBmdW5jdGlvbiBoaWRlX2ljb25zKCkge1xcblxcdFxcdFxcdHRoaXMuX2RhdGEuY29yZS50aGVtZXMuaWNvbnMgPSBmYWxzZTtcXG5cXHRcXHRcXHR0aGlzLmdldF9jb250YWluZXJfdWwoKS5hZGRDbGFzcyhcXFwianN0cmVlLW5vLWljb25zXFxcIik7XFxuXFx0XFx0XFx0LyoqXFxuICAgICogdHJpZ2dlcmVkIHdoZW4gaWNvbnMgYXJlIGhpZGRlblxcbiAgICAqIEBldmVudFxcbiAgICAqIEBuYW1lIGhpZGVfaWNvbnMuanN0cmVlXFxuICAgICovXFxuXFx0XFx0XFx0dGhpcy50cmlnZ2VyKCdoaWRlX2ljb25zJyk7XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIHRvZ2dsZSB0aGUgbm9kZSBpY29uc1xcbiAgICogQG5hbWUgdG9nZ2xlX2ljb25zKClcXG4gICAqL1xcblxcdFxcdHRvZ2dsZV9pY29uczogZnVuY3Rpb24gdG9nZ2xlX2ljb25zKCkge1xcblxcdFxcdFxcdGlmICh0aGlzLl9kYXRhLmNvcmUudGhlbWVzLmljb25zKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5oaWRlX2ljb25zKCk7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHR0aGlzLnNob3dfaWNvbnMoKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIHNob3cgdGhlIG5vZGUgZWxsaXBzaXNcXG4gICAqIEBuYW1lIHNob3dfaWNvbnMoKVxcbiAgICovXFxuXFx0XFx0c2hvd19lbGxpcHNpczogZnVuY3Rpb24gc2hvd19lbGxpcHNpcygpIHtcXG5cXHRcXHRcXHR0aGlzLl9kYXRhLmNvcmUudGhlbWVzLmVsbGlwc2lzID0gdHJ1ZTtcXG5cXHRcXHRcXHR0aGlzLmdldF9jb250YWluZXJfdWwoKS5hZGRDbGFzcyhcXFwianN0cmVlLWVsbGlwc2lzXFxcIik7XFxuXFx0XFx0XFx0LyoqXFxuICAgICogdHJpZ2dlcmVkIHdoZW4gZWxsaXNpcyBpcyBzaG93blxcbiAgICAqIEBldmVudFxcbiAgICAqIEBuYW1lIHNob3dfZWxsaXBzaXMuanN0cmVlXFxuICAgICovXFxuXFx0XFx0XFx0dGhpcy50cmlnZ2VyKCdzaG93X2VsbGlwc2lzJyk7XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIGhpZGUgdGhlIG5vZGUgZWxsaXBzaXNcXG4gICAqIEBuYW1lIGhpZGVfZWxsaXBzaXMoKVxcbiAgICovXFxuXFx0XFx0aGlkZV9lbGxpcHNpczogZnVuY3Rpb24gaGlkZV9lbGxpcHNpcygpIHtcXG5cXHRcXHRcXHR0aGlzLl9kYXRhLmNvcmUudGhlbWVzLmVsbGlwc2lzID0gZmFsc2U7XFxuXFx0XFx0XFx0dGhpcy5nZXRfY29udGFpbmVyX3VsKCkucmVtb3ZlQ2xhc3MoXFxcImpzdHJlZS1lbGxpcHNpc1xcXCIpO1xcblxcdFxcdFxcdC8qKlxcbiAgICAqIHRyaWdnZXJlZCB3aGVuIGVsbGlzaXMgaXMgaGlkZGVuXFxuICAgICogQGV2ZW50XFxuICAgICogQG5hbWUgaGlkZV9lbGxpcHNpcy5qc3RyZWVcXG4gICAgKi9cXG5cXHRcXHRcXHR0aGlzLnRyaWdnZXIoJ2hpZGVfZWxsaXBzaXMnKTtcXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogdG9nZ2xlIHRoZSBub2RlIGVsbGlwc2lzXFxuICAgKiBAbmFtZSB0b2dnbGVfaWNvbnMoKVxcbiAgICovXFxuXFx0XFx0dG9nZ2xlX2VsbGlwc2lzOiBmdW5jdGlvbiB0b2dnbGVfZWxsaXBzaXMoKSB7XFxuXFx0XFx0XFx0aWYgKHRoaXMuX2RhdGEuY29yZS50aGVtZXMuZWxsaXBzaXMpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLmhpZGVfZWxsaXBzaXMoKTtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdHRoaXMuc2hvd19lbGxpcHNpcygpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogc2V0IHRoZSBub2RlIGljb24gZm9yIGEgbm9kZVxcbiAgICogQG5hbWUgc2V0X2ljb24ob2JqLCBpY29uKVxcbiAgICogQHBhcmFtIHttaXhlZH0gb2JqXFxuICAgKiBAcGFyYW0ge1N0cmluZ30gaWNvbiB0aGUgbmV3IGljb24gLSBjYW4gYmUgYSBwYXRoIHRvIGFuIGljb24gb3IgYSBjbGFzc05hbWUsIGlmIHVzaW5nIGFuIGltYWdlIHRoYXQgaXMgaW4gdGhlIGN1cnJlbnQgZGlyZWN0b3J5IHVzZSBhIGAuL2AgcHJlZml4LCBvdGhlcndpc2UgaXQgd2lsbCBiZSBkZXRlY3RlZCBhcyBhIGNsYXNzXFxuICAgKi9cXG5cXHRcXHRzZXRfaWNvbjogZnVuY3Rpb24gc2V0X2ljb24ob2JqLCBpY29uKSB7XFxuXFx0XFx0XFx0dmFyIHQxLCB0MiwgZG9tLCBvbGQ7XFxuXFx0XFx0XFx0aWYgKCQuaXNBcnJheShvYmopKSB7XFxuXFx0XFx0XFx0XFx0b2JqID0gb2JqLnNsaWNlKCk7XFxuXFx0XFx0XFx0XFx0Zm9yICh0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuc2V0X2ljb24ob2JqW3QxXSwgaWNvbik7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XFxuXFx0XFx0XFx0aWYgKCFvYmogfHwgb2JqLmlkID09PSAkLmpzdHJlZS5yb290KSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRvbGQgPSBvYmouaWNvbjtcXG5cXHRcXHRcXHRvYmouaWNvbiA9IGljb24gPT09IHRydWUgfHwgaWNvbiA9PT0gbnVsbCB8fCBpY29uID09PSB1bmRlZmluZWQgfHwgaWNvbiA9PT0gJycgPyB0cnVlIDogaWNvbjtcXG5cXHRcXHRcXHRkb20gPSB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSkuY2hpbGRyZW4oXFxcIi5qc3RyZWUtYW5jaG9yXFxcIikuY2hpbGRyZW4oXFxcIi5qc3RyZWUtdGhlbWVpY29uXFxcIik7XFxuXFx0XFx0XFx0aWYgKGljb24gPT09IGZhbHNlKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5oaWRlX2ljb24ob2JqKTtcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKGljb24gPT09IHRydWUgfHwgaWNvbiA9PT0gbnVsbCB8fCBpY29uID09PSB1bmRlZmluZWQgfHwgaWNvbiA9PT0gJycpIHtcXG5cXHRcXHRcXHRcXHRkb20ucmVtb3ZlQ2xhc3MoJ2pzdHJlZS10aGVtZWljb24tY3VzdG9tICcgKyBvbGQpLmNzcyhcXFwiYmFja2dyb3VuZFxcXCIsIFxcXCJcXFwiKS5yZW1vdmVBdHRyKFxcXCJyZWxcXFwiKTtcXG5cXHRcXHRcXHRcXHRpZiAob2xkID09PSBmYWxzZSkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuc2hvd19pY29uKG9iaik7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0gZWxzZSBpZiAoaWNvbi5pbmRleE9mKFxcXCIvXFxcIikgPT09IC0xICYmIGljb24uaW5kZXhPZihcXFwiLlxcXCIpID09PSAtMSkge1xcblxcdFxcdFxcdFxcdGRvbS5yZW1vdmVDbGFzcyhvbGQpLmNzcyhcXFwiYmFja2dyb3VuZFxcXCIsIFxcXCJcXFwiKTtcXG5cXHRcXHRcXHRcXHRkb20uYWRkQ2xhc3MoaWNvbiArICcganN0cmVlLXRoZW1laWNvbi1jdXN0b20nKS5hdHRyKFxcXCJyZWxcXFwiLCBpY29uKTtcXG5cXHRcXHRcXHRcXHRpZiAob2xkID09PSBmYWxzZSkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuc2hvd19pY29uKG9iaik7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0ZG9tLnJlbW92ZUNsYXNzKG9sZCkuY3NzKFxcXCJiYWNrZ3JvdW5kXFxcIiwgXFxcIlxcXCIpO1xcblxcdFxcdFxcdFxcdGRvbS5hZGRDbGFzcygnanN0cmVlLXRoZW1laWNvbi1jdXN0b20nKS5jc3MoXFxcImJhY2tncm91bmRcXFwiLCBcXFwidXJsKCdcXFwiICsgaWNvbiArIFxcXCInKSBjZW50ZXIgY2VudGVyIG5vLXJlcGVhdFxcXCIpLmF0dHIoXFxcInJlbFxcXCIsIGljb24pO1xcblxcdFxcdFxcdFxcdGlmIChvbGQgPT09IGZhbHNlKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5zaG93X2ljb24ob2JqKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdH0sXFxuXFx0XFx0LyoqXFxuICAgKiBnZXQgdGhlIG5vZGUgaWNvbiBmb3IgYSBub2RlXFxuICAgKiBAbmFtZSBnZXRfaWNvbihvYmopXFxuICAgKiBAcGFyYW0ge21peGVkfSBvYmpcXG4gICAqIEByZXR1cm4ge1N0cmluZ31cXG4gICAqL1xcblxcdFxcdGdldF9pY29uOiBmdW5jdGlvbiBnZXRfaWNvbihvYmopIHtcXG5cXHRcXHRcXHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XFxuXFx0XFx0XFx0cmV0dXJuICFvYmogfHwgb2JqLmlkID09PSAkLmpzdHJlZS5yb290ID8gZmFsc2UgOiBvYmouaWNvbjtcXG5cXHRcXHR9LFxcblxcdFxcdC8qKlxcbiAgICogaGlkZSB0aGUgaWNvbiBvbiBhbiBpbmRpdmlkdWFsIG5vZGVcXG4gICAqIEBuYW1lIGhpZGVfaWNvbihvYmopXFxuICAgKiBAcGFyYW0ge21peGVkfSBvYmpcXG4gICAqL1xcblxcdFxcdGhpZGVfaWNvbjogZnVuY3Rpb24gaGlkZV9pY29uKG9iaikge1xcblxcdFxcdFxcdHZhciB0MSwgdDI7XFxuXFx0XFx0XFx0aWYgKCQuaXNBcnJheShvYmopKSB7XFxuXFx0XFx0XFx0XFx0b2JqID0gb2JqLnNsaWNlKCk7XFxuXFx0XFx0XFx0XFx0Zm9yICh0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuaGlkZV9pY29uKG9ialt0MV0pO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xcblxcdFxcdFxcdGlmICghb2JqIHx8IG9iaiA9PT0gJC5qc3RyZWUucm9vdCkge1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0b2JqLmljb24gPSBmYWxzZTtcXG5cXHRcXHRcXHR0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSkuY2hpbGRyZW4oXFxcIi5qc3RyZWUtYW5jaG9yXFxcIikuY2hpbGRyZW4oXFxcIi5qc3RyZWUtdGhlbWVpY29uXFxcIikuYWRkQ2xhc3MoJ2pzdHJlZS10aGVtZWljb24taGlkZGVuJyk7XFxuXFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0fSxcXG5cXHRcXHQvKipcXG4gICAqIHNob3cgdGhlIGljb24gb24gYW4gaW5kaXZpZHVhbCBub2RlXFxuICAgKiBAbmFtZSBzaG93X2ljb24ob2JqKVxcbiAgICogQHBhcmFtIHttaXhlZH0gb2JqXFxuICAgKi9cXG5cXHRcXHRzaG93X2ljb246IGZ1bmN0aW9uIHNob3dfaWNvbihvYmopIHtcXG5cXHRcXHRcXHR2YXIgdDEsIHQyLCBkb207XFxuXFx0XFx0XFx0aWYgKCQuaXNBcnJheShvYmopKSB7XFxuXFx0XFx0XFx0XFx0b2JqID0gb2JqLnNsaWNlKCk7XFxuXFx0XFx0XFx0XFx0Zm9yICh0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuc2hvd19pY29uKG9ialt0MV0pO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xcblxcdFxcdFxcdGlmICghb2JqIHx8IG9iaiA9PT0gJC5qc3RyZWUucm9vdCkge1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0ZG9tID0gdGhpcy5nZXRfbm9kZShvYmosIHRydWUpO1xcblxcdFxcdFxcdG9iai5pY29uID0gZG9tLmxlbmd0aCA/IGRvbS5jaGlsZHJlbihcXFwiLmpzdHJlZS1hbmNob3JcXFwiKS5jaGlsZHJlbihcXFwiLmpzdHJlZS10aGVtZWljb25cXFwiKS5hdHRyKCdyZWwnKSA6IHRydWU7XFxuXFx0XFx0XFx0aWYgKCFvYmouaWNvbikge1xcblxcdFxcdFxcdFxcdG9iai5pY29uID0gdHJ1ZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0ZG9tLmNoaWxkcmVuKFxcXCIuanN0cmVlLWFuY2hvclxcXCIpLmNoaWxkcmVuKFxcXCIuanN0cmVlLXRoZW1laWNvblxcXCIpLnJlbW92ZUNsYXNzKCdqc3RyZWUtdGhlbWVpY29uLWhpZGRlbicpO1xcblxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdH1cXG5cXHR9O1xcblxcblxcdC8vIGhlbHBlcnNcXG5cXHQkLnZha2F0YSA9IHt9O1xcblxcdC8vIGNvbGxlY3QgYXR0cmlidXRlc1xcblxcdCQudmFrYXRhLmF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAobm9kZSwgd2l0aF92YWx1ZXMpIHtcXG5cXHRcXHRub2RlID0gJChub2RlKVswXTtcXG5cXHRcXHR2YXIgYXR0ciA9IHdpdGhfdmFsdWVzID8ge30gOiBbXTtcXG5cXHRcXHRpZiAobm9kZSAmJiBub2RlLmF0dHJpYnV0ZXMpIHtcXG5cXHRcXHRcXHQkLmVhY2gobm9kZS5hdHRyaWJ1dGVzLCBmdW5jdGlvbiAoaSwgdikge1xcblxcdFxcdFxcdFxcdGlmICgkLmluQXJyYXkodi5uYW1lLnRvTG93ZXJDYXNlKCksIFsnc3R5bGUnLCAnY29udGVudGVkaXRhYmxlJywgJ2hhc2ZvY3VzJywgJ3RhYmluZGV4J10pICE9PSAtMSkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aWYgKHYudmFsdWUgIT09IG51bGwgJiYgJC50cmltKHYudmFsdWUpICE9PSAnJykge1xcblxcdFxcdFxcdFxcdFxcdGlmICh3aXRoX3ZhbHVlcykge1xcblxcdFxcdFxcdFxcdFxcdFxcdGF0dHJbdi5uYW1lXSA9IHYudmFsdWU7XFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRhdHRyLnB1c2godi5uYW1lKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0pO1xcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gYXR0cjtcXG5cXHR9O1xcblxcdCQudmFrYXRhLmFycmF5X3VuaXF1ZSA9IGZ1bmN0aW9uIChhcnJheSkge1xcblxcdFxcdHZhciBhID0gW10sXFxuXFx0XFx0ICAgIGksXFxuXFx0XFx0ICAgIGosXFxuXFx0XFx0ICAgIGwsXFxuXFx0XFx0ICAgIG8gPSB7fTtcXG5cXHRcXHRmb3IgKGkgPSAwLCBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XFxuXFx0XFx0XFx0aWYgKG9bYXJyYXlbaV1dID09PSB1bmRlZmluZWQpIHtcXG5cXHRcXHRcXHRcXHRhLnB1c2goYXJyYXlbaV0pO1xcblxcdFxcdFxcdFxcdG9bYXJyYXlbaV1dID0gdHJ1ZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiBhO1xcblxcdH07XFxuXFx0Ly8gcmVtb3ZlIGl0ZW0gZnJvbSBhcnJheVxcblxcdCQudmFrYXRhLmFycmF5X3JlbW92ZSA9IGZ1bmN0aW9uIChhcnJheSwgZnJvbSkge1xcblxcdFxcdGFycmF5LnNwbGljZShmcm9tLCAxKTtcXG5cXHRcXHRyZXR1cm4gYXJyYXk7XFxuXFx0XFx0Ly92YXIgcmVzdCA9IGFycmF5LnNsaWNlKCh0byB8fCBmcm9tKSArIDEgfHwgYXJyYXkubGVuZ3RoKTtcXG5cXHRcXHQvL2FycmF5Lmxlbmd0aCA9IGZyb20gPCAwID8gYXJyYXkubGVuZ3RoICsgZnJvbSA6IGZyb207XFxuXFx0XFx0Ly9hcnJheS5wdXNoLmFwcGx5KGFycmF5LCByZXN0KTtcXG5cXHRcXHQvL3JldHVybiBhcnJheTtcXG5cXHR9O1xcblxcdC8vIHJlbW92ZSBpdGVtIGZyb20gYXJyYXlcXG5cXHQkLnZha2F0YS5hcnJheV9yZW1vdmVfaXRlbSA9IGZ1bmN0aW9uIChhcnJheSwgaXRlbSkge1xcblxcdFxcdHZhciB0bXAgPSAkLmluQXJyYXkoaXRlbSwgYXJyYXkpO1xcblxcdFxcdHJldHVybiB0bXAgIT09IC0xID8gJC52YWthdGEuYXJyYXlfcmVtb3ZlKGFycmF5LCB0bXApIDogYXJyYXk7XFxuXFx0fTtcXG5cXHQkLnZha2F0YS5hcnJheV9maWx0ZXIgPSBmdW5jdGlvbiAoYywgYSwgYiwgZCwgZSkge1xcblxcdFxcdGlmIChjLmZpbHRlcikge1xcblxcdFxcdFxcdHJldHVybiBjLmZpbHRlcihhLCBiKTtcXG5cXHRcXHR9XFxuXFx0XFx0ZCA9IFtdO1xcblxcdFxcdGZvciAoZSBpbiBjKSB7XFxuXFx0XFx0XFx0aWYgKH5+ZSArICcnID09PSBlICsgJycgJiYgZSA+PSAwICYmIGEuY2FsbChiLCBjW2VdLCArZSwgYykpIHtcXG5cXHRcXHRcXHRcXHRkLnB1c2goY1tlXSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gZDtcXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiAjIyMgQ2hhbmdlZCBwbHVnaW5cXG4gICpcXG4gICogVGhpcyBwbHVnaW4gYWRkcyBtb3JlIGluZm9ybWF0aW9uIHRvIHRoZSBgY2hhbmdlZC5qc3RyZWVgIGV2ZW50LiBUaGUgbmV3IGRhdGEgaXMgY29udGFpbmVkIGluIHRoZSBgY2hhbmdlZGAgZXZlbnQgZGF0YSBwcm9wZXJ0eSwgYW5kIGNvbnRhaW5zIGEgbGlzdHMgb2YgYHNlbGVjdGVkYCBhbmQgYGRlc2VsZWN0ZWRgIG5vZGVzLlxcbiAgKi9cXG5cXG5cXHQkLmpzdHJlZS5wbHVnaW5zLmNoYW5nZWQgPSBmdW5jdGlvbiAob3B0aW9ucywgcGFyZW50KSB7XFxuXFx0XFx0dmFyIGxhc3QgPSBbXTtcXG5cXHRcXHR0aGlzLnRyaWdnZXIgPSBmdW5jdGlvbiAoZXYsIGRhdGEpIHtcXG5cXHRcXHRcXHR2YXIgaSwgajtcXG5cXHRcXHRcXHRpZiAoIWRhdGEpIHtcXG5cXHRcXHRcXHRcXHRkYXRhID0ge307XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmIChldi5yZXBsYWNlKCcuanN0cmVlJywgJycpID09PSAnY2hhbmdlZCcpIHtcXG5cXHRcXHRcXHRcXHRkYXRhLmNoYW5nZWQgPSB7IHNlbGVjdGVkOiBbXSwgZGVzZWxlY3RlZDogW10gfTtcXG5cXHRcXHRcXHRcXHR2YXIgdG1wID0ge307XFxuXFx0XFx0XFx0XFx0Zm9yIChpID0gMCwgaiA9IGxhc3QubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0dG1wW2xhc3RbaV1dID0gMTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0Zm9yIChpID0gMCwgaiA9IGRhdGEuc2VsZWN0ZWQubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCF0bXBbZGF0YS5zZWxlY3RlZFtpXV0pIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRkYXRhLmNoYW5nZWQuc2VsZWN0ZWQucHVzaChkYXRhLnNlbGVjdGVkW2ldKTtcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRtcFtkYXRhLnNlbGVjdGVkW2ldXSA9IDI7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRmb3IgKGkgPSAwLCBqID0gbGFzdC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAodG1wW2xhc3RbaV1dID09PSAxKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS5jaGFuZ2VkLmRlc2VsZWN0ZWQucHVzaChsYXN0W2ldKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGxhc3QgPSBkYXRhLnNlbGVjdGVkLnNsaWNlKCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdC8qKlxcbiAgICAqIHRyaWdnZXJlZCB3aGVuIHNlbGVjdGlvbiBjaGFuZ2VzICh0aGUgXFxcImNoYW5nZWRcXFwiIHBsdWdpbiBlbmhhbmNlcyB0aGUgb3JpZ2luYWwgZXZlbnQgd2l0aCBtb3JlIGRhdGEpXFxuICAgICogQGV2ZW50XFxuICAgICogQG5hbWUgY2hhbmdlZC5qc3RyZWVcXG4gICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZVxcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24gdGhlIGFjdGlvbiB0aGF0IGNhdXNlZCB0aGUgc2VsZWN0aW9uIHRvIGNoYW5nZVxcbiAgICAqIEBwYXJhbSB7QXJyYXl9IHNlbGVjdGVkIHRoZSBjdXJyZW50IHNlbGVjdGlvblxcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBjaGFuZ2VkIGFuIG9iamVjdCBjb250YWluaW5nIHR3byBwcm9wZXJ0aWVzIGBzZWxlY3RlZGAgYW5kIGBkZXNlbGVjdGVkYCAtIGJvdGggYXJyYXlzIG9mIG5vZGUgSURzLCB3aGljaCB3ZXJlIHNlbGVjdGVkIG9yIGRlc2VsZWN0ZWQgc2luY2UgdGhlIGxhc3QgY2hhbmdlZCBldmVudFxcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCB0aGUgZXZlbnQgKGlmIGFueSkgdGhhdCB0cmlnZ2VyZWQgdGhpcyBjaGFuZ2VkIGV2ZW50XFxuICAgICogQHBsdWdpbiBjaGFuZ2VkXFxuICAgICovXFxuXFx0XFx0XFx0cGFyZW50LnRyaWdnZXIuY2FsbCh0aGlzLCBldiwgZGF0YSk7XFxuXFx0XFx0fTtcXG5cXHRcXHR0aGlzLnJlZnJlc2ggPSBmdW5jdGlvbiAoc2tpcF9sb2FkaW5nLCBmb3JnZXRfc3RhdGUpIHtcXG5cXHRcXHRcXHRsYXN0ID0gW107XFxuXFx0XFx0XFx0cmV0dXJuIHBhcmVudC5yZWZyZXNoLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuXFx0XFx0fTtcXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiAjIyMgQ2hlY2tib3ggcGx1Z2luXFxuICAqXFxuICAqIFRoaXMgcGx1Z2luIHJlbmRlcnMgY2hlY2tib3ggaWNvbnMgaW4gZnJvbnQgb2YgZWFjaCBub2RlLCBtYWtpbmcgbXVsdGlwbGUgc2VsZWN0aW9uIG11Y2ggZWFzaWVyLlxcbiAgKiBJdCBhbHNvIHN1cHBvcnRzIHRyaS1zdGF0ZSBiZWhhdmlvciwgbWVhbmluZyB0aGF0IGlmIGEgbm9kZSBoYXMgYSBmZXcgb2YgaXRzIGNoaWxkcmVuIGNoZWNrZWQgaXQgd2lsbCBiZSByZW5kZXJlZCBhcyB1bmRldGVybWluZWQsIGFuZCBzdGF0ZSB3aWxsIGJlIHByb3BhZ2F0ZWQgdXAuXFxuICAqL1xcblxcblxcdHZhciBfaSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0knKTtcXG5cXHRfaS5jbGFzc05hbWUgPSAnanN0cmVlLWljb24ganN0cmVlLWNoZWNrYm94JztcXG5cXHRfaS5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAncHJlc2VudGF0aW9uJyk7XFxuXFx0LyoqXFxuICAqIHN0b3JlcyBhbGwgZGVmYXVsdHMgZm9yIHRoZSBjaGVja2JveCBwbHVnaW5cXG4gICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY2hlY2tib3hcXG4gICogQHBsdWdpbiBjaGVja2JveFxcbiAgKi9cXG5cXHQkLmpzdHJlZS5kZWZhdWx0cy5jaGVja2JveCA9IHtcXG5cXHRcXHQvKipcXG4gICAqIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIGNoZWNrYm94ZXMgc2hvdWxkIGJlIHZpc2libGUgKGNhbiBiZSBjaGFuZ2VkIGF0IGEgbGF0ZXIgdGltZSB1c2luZyBgc2hvd19jaGVja2JveGVzKClgIGFuZCBgaGlkZV9jaGVja2JveGVzYCkuIERlZmF1bHRzIHRvIGB0cnVlYC5cXG4gICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNoZWNrYm94LnZpc2libGVcXG4gICAqIEBwbHVnaW4gY2hlY2tib3hcXG4gICAqL1xcblxcdFxcdHZpc2libGU6IHRydWUsXFxuXFx0XFx0LyoqXFxuICAgKiBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiBjaGVja2JveGVzIHNob3VsZCBjYXNjYWRlIGRvd24gYW5kIGhhdmUgYW4gdW5kZXRlcm1pbmVkIHN0YXRlLiBEZWZhdWx0cyB0byBgdHJ1ZWAuXFxuICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jaGVja2JveC50aHJlZV9zdGF0ZVxcbiAgICogQHBsdWdpbiBjaGVja2JveFxcbiAgICovXFxuXFx0XFx0dGhyZWVfc3RhdGU6IHRydWUsXFxuXFx0XFx0LyoqXFxuICAgKiBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiBjbGlja2luZyBhbnl3aGVyZSBvbiB0aGUgbm9kZSBzaG91bGQgYWN0IGFzIGNsaWNraW5nIG9uIHRoZSBjaGVja2JveC4gRGVmYXVsdHMgdG8gYHRydWVgLlxcbiAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY2hlY2tib3gud2hvbGVfbm9kZVxcbiAgICogQHBsdWdpbiBjaGVja2JveFxcbiAgICovXFxuXFx0XFx0d2hvbGVfbm9kZTogdHJ1ZSxcXG5cXHRcXHQvKipcXG4gICAqIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoZSBzZWxlY3RlZCBzdHlsZSBvZiBhIG5vZGUgc2hvdWxkIGJlIGtlcHQsIG9yIHJlbW92ZWQuIERlZmF1bHRzIHRvIGB0cnVlYC5cXG4gICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNoZWNrYm94LmtlZXBfc2VsZWN0ZWRfc3R5bGVcXG4gICAqIEBwbHVnaW4gY2hlY2tib3hcXG4gICAqL1xcblxcdFxcdGtlZXBfc2VsZWN0ZWRfc3R5bGU6IHRydWUsXFxuXFx0XFx0LyoqXFxuICAgKiBUaGlzIHNldHRpbmcgY29udHJvbHMgaG93IGNhc2NhZGluZyBhbmQgdW5kZXRlcm1pbmVkIG5vZGVzIGFyZSBhcHBsaWVkLlxcbiAgICogSWYgJ3VwJyBpcyBpbiB0aGUgc3RyaW5nIC0gY2FzY2FkaW5nIHVwIGlzIGVuYWJsZWQsIGlmICdkb3duJyBpcyBpbiB0aGUgc3RyaW5nIC0gY2FzY2FkaW5nIGRvd24gaXMgZW5hYmxlZCwgaWYgJ3VuZGV0ZXJtaW5lZCcgaXMgaW4gdGhlIHN0cmluZyAtIHVuZGV0ZXJtaW5lZCBub2RlcyB3aWxsIGJlIHVzZWQuXFxuICAgKiBJZiBgdGhyZWVfc3RhdGVgIGlzIHNldCB0byBgdHJ1ZWAgdGhpcyBzZXR0aW5nIGlzIGF1dG9tYXRpY2FsbHkgc2V0IHRvICd1cCtkb3duK3VuZGV0ZXJtaW5lZCcuIERlZmF1bHRzIHRvICcnLlxcbiAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY2hlY2tib3guY2FzY2FkZVxcbiAgICogQHBsdWdpbiBjaGVja2JveFxcbiAgICovXFxuXFx0XFx0Y2FzY2FkZTogJycsXFxuXFx0XFx0LyoqXFxuICAgKiBUaGlzIHNldHRpbmcgY29udHJvbHMgaWYgY2hlY2tib3ggYXJlIGJvdW5kIHRvIHRoZSBnZW5lcmFsIHRyZWUgc2VsZWN0aW9uIG9yIHRvIGFuIGludGVybmFsIGFycmF5IG1haW50YWluZWQgYnkgdGhlIGNoZWNrYm94IHBsdWdpbi4gRGVmYXVsdHMgdG8gYHRydWVgLCBvbmx5IHNldCB0byBgZmFsc2VgIGlmIHlvdSBrbm93IGV4YWN0bHkgd2hhdCB5b3UgYXJlIGRvaW5nLlxcbiAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY2hlY2tib3gudGllX3NlbGVjdGlvblxcbiAgICogQHBsdWdpbiBjaGVja2JveFxcbiAgICovXFxuXFx0XFx0dGllX3NlbGVjdGlvbjogdHJ1ZVxcblxcdH07XFxuXFx0JC5qc3RyZWUucGx1Z2lucy5jaGVja2JveCA9IGZ1bmN0aW9uIChvcHRpb25zLCBwYXJlbnQpIHtcXG5cXHRcXHR0aGlzLmJpbmQgPSBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0cGFyZW50LmJpbmQuY2FsbCh0aGlzKTtcXG5cXHRcXHRcXHR0aGlzLl9kYXRhLmNoZWNrYm94LnV0byA9IGZhbHNlO1xcblxcdFxcdFxcdHRoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWQgPSBbXTtcXG5cXHRcXHRcXHRpZiAodGhpcy5zZXR0aW5ncy5jaGVja2JveC50aHJlZV9zdGF0ZSkge1xcblxcdFxcdFxcdFxcdHRoaXMuc2V0dGluZ3MuY2hlY2tib3guY2FzY2FkZSA9ICd1cCtkb3duK3VuZGV0ZXJtaW5lZCc7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHRoaXMuZWxlbWVudC5vbihcXFwiaW5pdC5qc3RyZWVcXFwiLCAkLnByb3h5KGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9kYXRhLmNoZWNrYm94LnZpc2libGUgPSB0aGlzLnNldHRpbmdzLmNoZWNrYm94LnZpc2libGU7XFxuXFx0XFx0XFx0XFx0aWYgKCF0aGlzLnNldHRpbmdzLmNoZWNrYm94LmtlZXBfc2VsZWN0ZWRfc3R5bGUpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoJ2pzdHJlZS1jaGVja2JveC1uby1jbGlja2VkJyk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGlmICh0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb24pIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoJ2pzdHJlZS1jaGVja2JveC1zZWxlY3Rpb24nKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSwgdGhpcykpLm9uKFxcXCJsb2FkaW5nLmpzdHJlZVxcXCIsICQucHJveHkoZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdHRoaXNbdGhpcy5fZGF0YS5jaGVja2JveC52aXNpYmxlID8gJ3Nob3dfY2hlY2tib3hlcycgOiAnaGlkZV9jaGVja2JveGVzJ10oKTtcXG5cXHRcXHRcXHR9LCB0aGlzKSk7XFxuXFx0XFx0XFx0aWYgKHRoaXMuc2V0dGluZ3MuY2hlY2tib3guY2FzY2FkZS5pbmRleE9mKCd1bmRldGVybWluZWQnKSAhPT0gLTEpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLmVsZW1lbnQub24oJ2NoYW5nZWQuanN0cmVlIHVuY2hlY2tfbm9kZS5qc3RyZWUgY2hlY2tfbm9kZS5qc3RyZWUgdW5jaGVja19hbGwuanN0cmVlIGNoZWNrX2FsbC5qc3RyZWUgbW92ZV9ub2RlLmpzdHJlZSBjb3B5X25vZGUuanN0cmVlIHJlZHJhdy5qc3RyZWUgb3Blbl9ub2RlLmpzdHJlZScsICQucHJveHkoZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdC8vIG9ubHkgaWYgdW5kZXRlcm1pbmVkIGlzIGluIHNldHRpbmdcXG5cXHRcXHRcXHRcXHRcXHRpZiAodGhpcy5fZGF0YS5jaGVja2JveC51dG8pIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRjbGVhclRpbWVvdXQodGhpcy5fZGF0YS5jaGVja2JveC51dG8pO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9kYXRhLmNoZWNrYm94LnV0byA9IHNldFRpbWVvdXQoJC5wcm94eSh0aGlzLl91bmRldGVybWluZWQsIHRoaXMpLCA1MCk7XFxuXFx0XFx0XFx0XFx0fSwgdGhpcykpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoIXRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbikge1xcblxcdFxcdFxcdFxcdHRoaXMuZWxlbWVudC5vbignbW9kZWwuanN0cmVlJywgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xcblxcdFxcdFxcdFxcdFxcdHZhciBtID0gdGhpcy5fbW9kZWwuZGF0YSxcXG5cXHRcXHRcXHRcXHRcXHQgICAgcCA9IG1bZGF0YS5wYXJlbnRdLFxcblxcdFxcdFxcdFxcdFxcdCAgICBkcGMgPSBkYXRhLm5vZGVzLFxcblxcdFxcdFxcdFxcdFxcdCAgICBpLFxcblxcdFxcdFxcdFxcdFxcdCAgICBqO1xcblxcdFxcdFxcdFxcdFxcdGZvciAoaSA9IDAsIGogPSBkcGMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0bVtkcGNbaV1dLnN0YXRlLmNoZWNrZWQgPSBtW2RwY1tpXV0uc3RhdGUuY2hlY2tlZCB8fCBtW2RwY1tpXV0ub3JpZ2luYWwgJiYgbVtkcGNbaV1dLm9yaWdpbmFsLnN0YXRlICYmIG1bZHBjW2ldXS5vcmlnaW5hbC5zdGF0ZS5jaGVja2VkO1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChtW2RwY1tpXV0uc3RhdGUuY2hlY2tlZCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWQucHVzaChkcGNbaV0pO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fSwgdGhpcykpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAodGhpcy5zZXR0aW5ncy5jaGVja2JveC5jYXNjYWRlLmluZGV4T2YoJ3VwJykgIT09IC0xIHx8IHRoaXMuc2V0dGluZ3MuY2hlY2tib3guY2FzY2FkZS5pbmRleE9mKCdkb3duJykgIT09IC0xKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5lbGVtZW50Lm9uKCdtb2RlbC5qc3RyZWUnLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIG0gPSB0aGlzLl9tb2RlbC5kYXRhLFxcblxcdFxcdFxcdFxcdFxcdCAgICBwID0gbVtkYXRhLnBhcmVudF0sXFxuXFx0XFx0XFx0XFx0XFx0ICAgIGRwYyA9IGRhdGEubm9kZXMsXFxuXFx0XFx0XFx0XFx0XFx0ICAgIGNoZCA9IFtdLFxcblxcdFxcdFxcdFxcdFxcdCAgICBjLFxcblxcdFxcdFxcdFxcdFxcdCAgICBpLFxcblxcdFxcdFxcdFxcdFxcdCAgICBqLFxcblxcdFxcdFxcdFxcdFxcdCAgICBrLFxcblxcdFxcdFxcdFxcdFxcdCAgICBsLFxcblxcdFxcdFxcdFxcdFxcdCAgICB0bXAsXFxuXFx0XFx0XFx0XFx0XFx0ICAgIHMgPSB0aGlzLnNldHRpbmdzLmNoZWNrYm94LmNhc2NhZGUsXFxuXFx0XFx0XFx0XFx0XFx0ICAgIHQgPSB0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb247XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKHMuaW5kZXhPZignZG93bicpICE9PSAtMSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdC8vIGFwcGx5IGRvd25cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAocC5zdGF0ZVt0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJ10pIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRmb3IgKGkgPSAwLCBqID0gZHBjLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG1bZHBjW2ldXS5zdGF0ZVt0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJ10gPSB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl9kYXRhW3QgPyAnY29yZScgOiAnY2hlY2tib3gnXS5zZWxlY3RlZCA9IHRoaXMuX2RhdGFbdCA/ICdjb3JlJyA6ICdjaGVja2JveCddLnNlbGVjdGVkLmNvbmNhdChkcGMpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Zm9yIChpID0gMCwgaiA9IGRwYy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAobVtkcGNbaV1dLnN0YXRlW3QgPyAnc2VsZWN0ZWQnIDogJ2NoZWNrZWQnXSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGZvciAoayA9IDAsIGwgPSBtW2RwY1tpXV0uY2hpbGRyZW5fZC5sZW5ndGg7IGsgPCBsOyBrKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRtW21bZHBjW2ldXS5jaGlsZHJlbl9kW2tdXS5zdGF0ZVt0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJ10gPSB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl9kYXRhW3QgPyAnY29yZScgOiAnY2hlY2tib3gnXS5zZWxlY3RlZCA9IHRoaXMuX2RhdGFbdCA/ICdjb3JlJyA6ICdjaGVja2JveCddLnNlbGVjdGVkLmNvbmNhdChtW2RwY1tpXV0uY2hpbGRyZW5fZCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdGlmIChzLmluZGV4T2YoJ3VwJykgIT09IC0xKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gYXBwbHkgdXBcXG5cXHRcXHRcXHRcXHRcXHRcXHRmb3IgKGkgPSAwLCBqID0gcC5jaGlsZHJlbl9kLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICghbVtwLmNoaWxkcmVuX2RbaV1dLmNoaWxkcmVuLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGNoZC5wdXNoKG1bcC5jaGlsZHJlbl9kW2ldXS5wYXJlbnQpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2hkID0gJC52YWthdGEuYXJyYXlfdW5pcXVlKGNoZCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Zm9yIChrID0gMCwgbCA9IGNoZC5sZW5ndGg7IGsgPCBsOyBrKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRwID0gbVtjaGRba11dO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHdoaWxlIChwICYmIHAuaWQgIT09ICQuanN0cmVlLnJvb3QpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjID0gMDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRmb3IgKGkgPSAwLCBqID0gcC5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjICs9IG1bcC5jaGlsZHJlbltpXV0uc3RhdGVbdCA/ICdzZWxlY3RlZCcgOiAnY2hlY2tlZCddO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoYyA9PT0gaikge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHAuc3RhdGVbdCA/ICdzZWxlY3RlZCcgOiAnY2hlY2tlZCddID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl9kYXRhW3QgPyAnY29yZScgOiAnY2hlY2tib3gnXS5zZWxlY3RlZC5wdXNoKHAuaWQpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRtcCA9IHRoaXMuZ2V0X25vZGUocCwgdHJ1ZSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKHRtcCAmJiB0bXAubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dG1wLmF0dHIoJ2FyaWEtc2VsZWN0ZWQnLCB0cnVlKS5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5hZGRDbGFzcyh0ID8gJ2pzdHJlZS1jbGlja2VkJyA6ICdqc3RyZWUtY2hlY2tlZCcpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRwID0gdGhpcy5nZXRfbm9kZShwLnBhcmVudCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fZGF0YVt0ID8gJ2NvcmUnIDogJ2NoZWNrYm94J10uc2VsZWN0ZWQgPSAkLnZha2F0YS5hcnJheV91bmlxdWUodGhpcy5fZGF0YVt0ID8gJ2NvcmUnIDogJ2NoZWNrYm94J10uc2VsZWN0ZWQpO1xcblxcdFxcdFxcdFxcdH0sIHRoaXMpKS5vbih0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb24gPyAnc2VsZWN0X25vZGUuanN0cmVlJyA6ICdjaGVja19ub2RlLmpzdHJlZScsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgb2JqID0gZGF0YS5ub2RlLFxcblxcdFxcdFxcdFxcdFxcdCAgICBtID0gdGhpcy5fbW9kZWwuZGF0YSxcXG5cXHRcXHRcXHRcXHRcXHQgICAgcGFyID0gdGhpcy5nZXRfbm9kZShvYmoucGFyZW50KSxcXG5cXHRcXHRcXHRcXHRcXHQgICAgZG9tID0gdGhpcy5nZXRfbm9kZShvYmosIHRydWUpLFxcblxcdFxcdFxcdFxcdFxcdCAgICBpLFxcblxcdFxcdFxcdFxcdFxcdCAgICBqLFxcblxcdFxcdFxcdFxcdFxcdCAgICBjLFxcblxcdFxcdFxcdFxcdFxcdCAgICB0bXAsXFxuXFx0XFx0XFx0XFx0XFx0ICAgIHMgPSB0aGlzLnNldHRpbmdzLmNoZWNrYm94LmNhc2NhZGUsXFxuXFx0XFx0XFx0XFx0XFx0ICAgIHQgPSB0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb24sXFxuXFx0XFx0XFx0XFx0XFx0ICAgIHNlbCA9IHt9LFxcblxcdFxcdFxcdFxcdFxcdCAgICBjdXIgPSB0aGlzLl9kYXRhW3QgPyAnY29yZScgOiAnY2hlY2tib3gnXS5zZWxlY3RlZDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRmb3IgKGkgPSAwLCBqID0gY3VyLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdFxcdHNlbFtjdXJbaV1dID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0Ly8gYXBwbHkgZG93blxcblxcdFxcdFxcdFxcdFxcdGlmIChzLmluZGV4T2YoJ2Rvd24nKSAhPT0gLTEpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHQvL3RoaXMuX2RhdGFbIHQgPyAnY29yZScgOiAnY2hlY2tib3gnIF0uc2VsZWN0ZWQgPSAkLnZha2F0YS5hcnJheV91bmlxdWUodGhpcy5fZGF0YVsgdCA/ICdjb3JlJyA6ICdjaGVja2JveCcgXS5zZWxlY3RlZC5jb25jYXQob2JqLmNoaWxkcmVuX2QpKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRmb3IgKGkgPSAwLCBqID0gb2JqLmNoaWxkcmVuX2QubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c2VsW29iai5jaGlsZHJlbl9kW2ldXSA9IHRydWU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dG1wID0gbVtvYmouY2hpbGRyZW5fZFtpXV07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dG1wLnN0YXRlW3QgPyAnc2VsZWN0ZWQnIDogJ2NoZWNrZWQnXSA9IHRydWU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKHRtcCAmJiB0bXAub3JpZ2luYWwgJiYgdG1wLm9yaWdpbmFsLnN0YXRlICYmIHRtcC5vcmlnaW5hbC5zdGF0ZS51bmRldGVybWluZWQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0bXAub3JpZ2luYWwuc3RhdGUudW5kZXRlcm1pbmVkID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gYXBwbHkgdXBcXG5cXHRcXHRcXHRcXHRcXHRpZiAocy5pbmRleE9mKCd1cCcpICE9PSAtMSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHdoaWxlIChwYXIgJiYgcGFyLmlkICE9PSAkLmpzdHJlZS5yb290KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YyA9IDA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Zm9yIChpID0gMCwgaiA9IHBhci5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjICs9IG1bcGFyLmNoaWxkcmVuW2ldXS5zdGF0ZVt0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJ107XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChjID09PSBqKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cGFyLnN0YXRlW3QgPyAnc2VsZWN0ZWQnIDogJ2NoZWNrZWQnXSA9IHRydWU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0c2VsW3Bhci5pZF0gPSB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vdGhpcy5fZGF0YVsgdCA/ICdjb3JlJyA6ICdjaGVja2JveCcgXS5zZWxlY3RlZC5wdXNoKHBhci5pZCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dG1wID0gdGhpcy5nZXRfbm9kZShwYXIsIHRydWUpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICh0bXAgJiYgdG1wLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRtcC5hdHRyKCdhcmlhLXNlbGVjdGVkJywgdHJ1ZSkuY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuYWRkQ2xhc3ModCA/ICdqc3RyZWUtY2xpY2tlZCcgOiAnanN0cmVlLWNoZWNrZWQnKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cGFyID0gdGhpcy5nZXRfbm9kZShwYXIucGFyZW50KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdGN1ciA9IFtdO1xcblxcdFxcdFxcdFxcdFxcdGZvciAoaSBpbiBzZWwpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoc2VsLmhhc093blByb3BlcnR5KGkpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y3VyLnB1c2goaSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9kYXRhW3QgPyAnY29yZScgOiAnY2hlY2tib3gnXS5zZWxlY3RlZCA9IGN1cjtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBhcHBseSBkb3duIChwcm9jZXNzIC5jaGlsZHJlbiBzZXBhcmF0ZWx5PylcXG5cXHRcXHRcXHRcXHRcXHRpZiAocy5pbmRleE9mKCdkb3duJykgIT09IC0xICYmIGRvbS5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRkb20uZmluZCgnLmpzdHJlZS1hbmNob3InKS5hZGRDbGFzcyh0ID8gJ2pzdHJlZS1jbGlja2VkJyA6ICdqc3RyZWUtY2hlY2tlZCcpLnBhcmVudCgpLmF0dHIoJ2FyaWEtc2VsZWN0ZWQnLCB0cnVlKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fSwgdGhpcykpLm9uKHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbiA/ICdkZXNlbGVjdF9hbGwuanN0cmVlJyA6ICd1bmNoZWNrX2FsbC5qc3RyZWUnLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIG9iaiA9IHRoaXMuZ2V0X25vZGUoJC5qc3RyZWUucm9vdCksXFxuXFx0XFx0XFx0XFx0XFx0ICAgIG0gPSB0aGlzLl9tb2RlbC5kYXRhLFxcblxcdFxcdFxcdFxcdFxcdCAgICBpLFxcblxcdFxcdFxcdFxcdFxcdCAgICBqLFxcblxcdFxcdFxcdFxcdFxcdCAgICB0bXA7XFxuXFx0XFx0XFx0XFx0XFx0Zm9yIChpID0gMCwgaiA9IG9iai5jaGlsZHJlbl9kLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRtcCA9IG1bb2JqLmNoaWxkcmVuX2RbaV1dO1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICh0bXAgJiYgdG1wLm9yaWdpbmFsICYmIHRtcC5vcmlnaW5hbC5zdGF0ZSAmJiB0bXAub3JpZ2luYWwuc3RhdGUudW5kZXRlcm1pbmVkKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dG1wLm9yaWdpbmFsLnN0YXRlLnVuZGV0ZXJtaW5lZCA9IGZhbHNlO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fSwgdGhpcykpLm9uKHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbiA/ICdkZXNlbGVjdF9ub2RlLmpzdHJlZScgOiAndW5jaGVja19ub2RlLmpzdHJlZScsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgb2JqID0gZGF0YS5ub2RlLFxcblxcdFxcdFxcdFxcdFxcdCAgICBkb20gPSB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSksXFxuXFx0XFx0XFx0XFx0XFx0ICAgIGksXFxuXFx0XFx0XFx0XFx0XFx0ICAgIGosXFxuXFx0XFx0XFx0XFx0XFx0ICAgIHRtcCxcXG5cXHRcXHRcXHRcXHRcXHQgICAgcyA9IHRoaXMuc2V0dGluZ3MuY2hlY2tib3guY2FzY2FkZSxcXG5cXHRcXHRcXHRcXHRcXHQgICAgdCA9IHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbixcXG5cXHRcXHRcXHRcXHRcXHQgICAgY3VyID0gdGhpcy5fZGF0YVt0ID8gJ2NvcmUnIDogJ2NoZWNrYm94J10uc2VsZWN0ZWQsXFxuXFx0XFx0XFx0XFx0XFx0ICAgIHNlbCA9IHt9O1xcblxcdFxcdFxcdFxcdFxcdGlmIChvYmogJiYgb2JqLm9yaWdpbmFsICYmIG9iai5vcmlnaW5hbC5zdGF0ZSAmJiBvYmoub3JpZ2luYWwuc3RhdGUudW5kZXRlcm1pbmVkKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0b2JqLm9yaWdpbmFsLnN0YXRlLnVuZGV0ZXJtaW5lZCA9IGZhbHNlO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBhcHBseSBkb3duXFxuXFx0XFx0XFx0XFx0XFx0aWYgKHMuaW5kZXhPZignZG93bicpICE9PSAtMSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGZvciAoaSA9IDAsIGogPSBvYmouY2hpbGRyZW5fZC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0bXAgPSB0aGlzLl9tb2RlbC5kYXRhW29iai5jaGlsZHJlbl9kW2ldXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0bXAuc3RhdGVbdCA/ICdzZWxlY3RlZCcgOiAnY2hlY2tlZCddID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKHRtcCAmJiB0bXAub3JpZ2luYWwgJiYgdG1wLm9yaWdpbmFsLnN0YXRlICYmIHRtcC5vcmlnaW5hbC5zdGF0ZS51bmRldGVybWluZWQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0bXAub3JpZ2luYWwuc3RhdGUudW5kZXRlcm1pbmVkID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gYXBwbHkgdXBcXG5cXHRcXHRcXHRcXHRcXHRpZiAocy5pbmRleE9mKCd1cCcpICE9PSAtMSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGZvciAoaSA9IDAsIGogPSBvYmoucGFyZW50cy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0bXAgPSB0aGlzLl9tb2RlbC5kYXRhW29iai5wYXJlbnRzW2ldXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0bXAuc3RhdGVbdCA/ICdzZWxlY3RlZCcgOiAnY2hlY2tlZCddID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKHRtcCAmJiB0bXAub3JpZ2luYWwgJiYgdG1wLm9yaWdpbmFsLnN0YXRlICYmIHRtcC5vcmlnaW5hbC5zdGF0ZS51bmRldGVybWluZWQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0bXAub3JpZ2luYWwuc3RhdGUudW5kZXRlcm1pbmVkID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRtcCA9IHRoaXMuZ2V0X25vZGUob2JqLnBhcmVudHNbaV0sIHRydWUpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICh0bXAgJiYgdG1wLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRtcC5hdHRyKCdhcmlhLXNlbGVjdGVkJywgZmFsc2UpLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLnJlbW92ZUNsYXNzKHQgPyAnanN0cmVlLWNsaWNrZWQnIDogJ2pzdHJlZS1jaGVja2VkJyk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0c2VsID0ge307XFxuXFx0XFx0XFx0XFx0XFx0Zm9yIChpID0gMCwgaiA9IGN1ci5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBhcHBseSBkb3duICsgYXBwbHkgdXBcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoKHMuaW5kZXhPZignZG93bicpID09PSAtMSB8fCAkLmluQXJyYXkoY3VyW2ldLCBvYmouY2hpbGRyZW5fZCkgPT09IC0xKSAmJiAocy5pbmRleE9mKCd1cCcpID09PSAtMSB8fCAkLmluQXJyYXkoY3VyW2ldLCBvYmoucGFyZW50cykgPT09IC0xKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHNlbFtjdXJbaV1dID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGN1ciA9IFtdO1xcblxcdFxcdFxcdFxcdFxcdGZvciAoaSBpbiBzZWwpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoc2VsLmhhc093blByb3BlcnR5KGkpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y3VyLnB1c2goaSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9kYXRhW3QgPyAnY29yZScgOiAnY2hlY2tib3gnXS5zZWxlY3RlZCA9IGN1cjtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBhcHBseSBkb3duIChwcm9jZXNzIC5jaGlsZHJlbiBzZXBhcmF0ZWx5PylcXG5cXHRcXHRcXHRcXHRcXHRpZiAocy5pbmRleE9mKCdkb3duJykgIT09IC0xICYmIGRvbS5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRkb20uZmluZCgnLmpzdHJlZS1hbmNob3InKS5yZW1vdmVDbGFzcyh0ID8gJ2pzdHJlZS1jbGlja2VkJyA6ICdqc3RyZWUtY2hlY2tlZCcpLnBhcmVudCgpLmF0dHIoJ2FyaWEtc2VsZWN0ZWQnLCBmYWxzZSk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH0sIHRoaXMpKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKHRoaXMuc2V0dGluZ3MuY2hlY2tib3guY2FzY2FkZS5pbmRleE9mKCd1cCcpICE9PSAtMSkge1xcblxcdFxcdFxcdFxcdHRoaXMuZWxlbWVudC5vbignZGVsZXRlX25vZGUuanN0cmVlJywgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xcblxcdFxcdFxcdFxcdFxcdC8vIGFwcGx5IHVwICh3aG9sZSBoYW5kbGVyKVxcblxcdFxcdFxcdFxcdFxcdHZhciBwID0gdGhpcy5nZXRfbm9kZShkYXRhLnBhcmVudCksXFxuXFx0XFx0XFx0XFx0XFx0ICAgIG0gPSB0aGlzLl9tb2RlbC5kYXRhLFxcblxcdFxcdFxcdFxcdFxcdCAgICBpLFxcblxcdFxcdFxcdFxcdFxcdCAgICBqLFxcblxcdFxcdFxcdFxcdFxcdCAgICBjLFxcblxcdFxcdFxcdFxcdFxcdCAgICB0bXAsXFxuXFx0XFx0XFx0XFx0XFx0ICAgIHQgPSB0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb247XFxuXFx0XFx0XFx0XFx0XFx0d2hpbGUgKHAgJiYgcC5pZCAhPT0gJC5qc3RyZWUucm9vdCAmJiAhcC5zdGF0ZVt0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJ10pIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRjID0gMDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRmb3IgKGkgPSAwLCBqID0gcC5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjICs9IG1bcC5jaGlsZHJlbltpXV0uc3RhdGVbdCA/ICdzZWxlY3RlZCcgOiAnY2hlY2tlZCddO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoaiA+IDAgJiYgYyA9PT0gaikge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHAuc3RhdGVbdCA/ICdzZWxlY3RlZCcgOiAnY2hlY2tlZCddID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl9kYXRhW3QgPyAnY29yZScgOiAnY2hlY2tib3gnXS5zZWxlY3RlZC5wdXNoKHAuaWQpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRtcCA9IHRoaXMuZ2V0X25vZGUocCwgdHJ1ZSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKHRtcCAmJiB0bXAubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dG1wLmF0dHIoJ2FyaWEtc2VsZWN0ZWQnLCB0cnVlKS5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5hZGRDbGFzcyh0ID8gJ2pzdHJlZS1jbGlja2VkJyA6ICdqc3RyZWUtY2hlY2tlZCcpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRwID0gdGhpcy5nZXRfbm9kZShwLnBhcmVudCk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH0sIHRoaXMpKS5vbignbW92ZV9ub2RlLmpzdHJlZScsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcXG5cXHRcXHRcXHRcXHRcXHQvLyBhcHBseSB1cCAod2hvbGUgaGFuZGxlcilcXG5cXHRcXHRcXHRcXHRcXHR2YXIgaXNfbXVsdGkgPSBkYXRhLmlzX211bHRpLFxcblxcdFxcdFxcdFxcdFxcdCAgICBvbGRfcGFyID0gZGF0YS5vbGRfcGFyZW50LFxcblxcdFxcdFxcdFxcdFxcdCAgICBuZXdfcGFyID0gdGhpcy5nZXRfbm9kZShkYXRhLnBhcmVudCksXFxuXFx0XFx0XFx0XFx0XFx0ICAgIG0gPSB0aGlzLl9tb2RlbC5kYXRhLFxcblxcdFxcdFxcdFxcdFxcdCAgICBwLFxcblxcdFxcdFxcdFxcdFxcdCAgICBjLFxcblxcdFxcdFxcdFxcdFxcdCAgICBpLFxcblxcdFxcdFxcdFxcdFxcdCAgICBqLFxcblxcdFxcdFxcdFxcdFxcdCAgICB0bXAsXFxuXFx0XFx0XFx0XFx0XFx0ICAgIHQgPSB0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb247XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCFpc19tdWx0aSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHAgPSB0aGlzLmdldF9ub2RlKG9sZF9wYXIpO1xcblxcdFxcdFxcdFxcdFxcdFxcdHdoaWxlIChwICYmIHAuaWQgIT09ICQuanN0cmVlLnJvb3QgJiYgIXAuc3RhdGVbdCA/ICdzZWxlY3RlZCcgOiAnY2hlY2tlZCddKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YyA9IDA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Zm9yIChpID0gMCwgaiA9IHAuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YyArPSBtW3AuY2hpbGRyZW5baV1dLnN0YXRlW3QgPyAnc2VsZWN0ZWQnIDogJ2NoZWNrZWQnXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKGogPiAwICYmIGMgPT09IGopIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRwLnN0YXRlW3QgPyAnc2VsZWN0ZWQnIDogJ2NoZWNrZWQnXSA9IHRydWU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5fZGF0YVt0ID8gJ2NvcmUnIDogJ2NoZWNrYm94J10uc2VsZWN0ZWQucHVzaChwLmlkKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0bXAgPSB0aGlzLmdldF9ub2RlKHAsIHRydWUpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICh0bXAgJiYgdG1wLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRtcC5hdHRyKCdhcmlhLXNlbGVjdGVkJywgdHJ1ZSkuY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuYWRkQ2xhc3ModCA/ICdqc3RyZWUtY2xpY2tlZCcgOiAnanN0cmVlLWNoZWNrZWQnKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cCA9IHRoaXMuZ2V0X25vZGUocC5wYXJlbnQpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0cCA9IG5ld19wYXI7XFxuXFx0XFx0XFx0XFx0XFx0d2hpbGUgKHAgJiYgcC5pZCAhPT0gJC5qc3RyZWUucm9vdCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGMgPSAwO1xcblxcdFxcdFxcdFxcdFxcdFxcdGZvciAoaSA9IDAsIGogPSBwLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGMgKz0gbVtwLmNoaWxkcmVuW2ldXS5zdGF0ZVt0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJ107XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChjID09PSBqKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCFwLnN0YXRlW3QgPyAnc2VsZWN0ZWQnIDogJ2NoZWNrZWQnXSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHAuc3RhdGVbdCA/ICdzZWxlY3RlZCcgOiAnY2hlY2tlZCddID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl9kYXRhW3QgPyAnY29yZScgOiAnY2hlY2tib3gnXS5zZWxlY3RlZC5wdXNoKHAuaWQpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRtcCA9IHRoaXMuZ2V0X25vZGUocCwgdHJ1ZSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKHRtcCAmJiB0bXAubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dG1wLmF0dHIoJ2FyaWEtc2VsZWN0ZWQnLCB0cnVlKS5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5hZGRDbGFzcyh0ID8gJ2pzdHJlZS1jbGlja2VkJyA6ICdqc3RyZWUtY2hlY2tlZCcpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAocC5zdGF0ZVt0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJ10pIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRwLnN0YXRlW3QgPyAnc2VsZWN0ZWQnIDogJ2NoZWNrZWQnXSA9IGZhbHNlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuX2RhdGFbdCA/ICdjb3JlJyA6ICdjaGVja2JveCddLnNlbGVjdGVkID0gJC52YWthdGEuYXJyYXlfcmVtb3ZlX2l0ZW0odGhpcy5fZGF0YVt0ID8gJ2NvcmUnIDogJ2NoZWNrYm94J10uc2VsZWN0ZWQsIHAuaWQpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRtcCA9IHRoaXMuZ2V0X25vZGUocCwgdHJ1ZSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKHRtcCAmJiB0bXAubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dG1wLmF0dHIoJ2FyaWEtc2VsZWN0ZWQnLCBmYWxzZSkuY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykucmVtb3ZlQ2xhc3ModCA/ICdqc3RyZWUtY2xpY2tlZCcgOiAnanN0cmVlLWNoZWNrZWQnKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdHAgPSB0aGlzLmdldF9ub2RlKHAucGFyZW50KTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fSwgdGhpcykpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9O1xcblxcdFxcdC8qKlxcbiAgICogc2V0IHRoZSB1bmRldGVybWluZWQgc3RhdGUgd2hlcmUgYW5kIGlmIG5lY2Vzc2FyeS4gVXNlZCBpbnRlcm5hbGx5LlxcbiAgICogQHByaXZhdGVcXG4gICAqIEBuYW1lIF91bmRldGVybWluZWQoKVxcbiAgICogQHBsdWdpbiBjaGVja2JveFxcbiAgICovXFxuXFx0XFx0dGhpcy5fdW5kZXRlcm1pbmVkID0gZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdGlmICh0aGlzLmVsZW1lbnQgPT09IG51bGwpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHZhciBpLFxcblxcdFxcdFxcdCAgICBqLFxcblxcdFxcdFxcdCAgICBrLFxcblxcdFxcdFxcdCAgICBsLFxcblxcdFxcdFxcdCAgICBvID0ge30sXFxuXFx0XFx0XFx0ICAgIG0gPSB0aGlzLl9tb2RlbC5kYXRhLFxcblxcdFxcdFxcdCAgICB0ID0gdGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uLFxcblxcdFxcdFxcdCAgICBzID0gdGhpcy5fZGF0YVt0ID8gJ2NvcmUnIDogJ2NoZWNrYm94J10uc2VsZWN0ZWQsXFxuXFx0XFx0XFx0ICAgIHAgPSBbXSxcXG5cXHRcXHRcXHQgICAgdHQgPSB0aGlzO1xcblxcdFxcdFxcdGZvciAoaSA9IDAsIGogPSBzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcblxcdFxcdFxcdFxcdGlmIChtW3NbaV1dICYmIG1bc1tpXV0ucGFyZW50cykge1xcblxcdFxcdFxcdFxcdFxcdGZvciAoayA9IDAsIGwgPSBtW3NbaV1dLnBhcmVudHMubGVuZ3RoOyBrIDwgbDsgaysrKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKG9bbVtzW2ldXS5wYXJlbnRzW2tdXSAhPT0gdW5kZWZpbmVkKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChtW3NbaV1dLnBhcmVudHNba10gIT09ICQuanN0cmVlLnJvb3QpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRvW21bc1tpXV0ucGFyZW50c1trXV0gPSB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHAucHVzaChtW3NbaV1dLnBhcmVudHNba10pO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHQvLyBhdHRlbXB0IGZvciBzZXJ2ZXIgc2lkZSB1bmRldGVybWluZWQgc3RhdGVcXG5cXHRcXHRcXHR0aGlzLmVsZW1lbnQuZmluZCgnLmpzdHJlZS1jbG9zZWQnKS5ub3QoJzpoYXMoLmpzdHJlZS1jaGlsZHJlbiknKS5lYWNoKGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHR2YXIgdG1wID0gdHQuZ2V0X25vZGUodGhpcyksXFxuXFx0XFx0XFx0XFx0ICAgIHRtcDI7XFxuXFx0XFx0XFx0XFx0aWYgKCF0bXAuc3RhdGUubG9hZGVkKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHRtcC5vcmlnaW5hbCAmJiB0bXAub3JpZ2luYWwuc3RhdGUgJiYgdG1wLm9yaWdpbmFsLnN0YXRlLnVuZGV0ZXJtaW5lZCAmJiB0bXAub3JpZ2luYWwuc3RhdGUudW5kZXRlcm1pbmVkID09PSB0cnVlKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKG9bdG1wLmlkXSA9PT0gdW5kZWZpbmVkICYmIHRtcC5pZCAhPT0gJC5qc3RyZWUucm9vdCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG9bdG1wLmlkXSA9IHRydWU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cC5wdXNoKHRtcC5pZCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdGZvciAoayA9IDAsIGwgPSB0bXAucGFyZW50cy5sZW5ndGg7IGsgPCBsOyBrKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAob1t0bXAucGFyZW50c1trXV0gPT09IHVuZGVmaW5lZCAmJiB0bXAucGFyZW50c1trXSAhPT0gJC5qc3RyZWUucm9vdCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG9bdG1wLnBhcmVudHNba11dID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRwLnB1c2godG1wLnBhcmVudHNba10pO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0Zm9yIChpID0gMCwgaiA9IHRtcC5jaGlsZHJlbl9kLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRtcDIgPSBtW3RtcC5jaGlsZHJlbl9kW2ldXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIXRtcDIuc3RhdGUubG9hZGVkICYmIHRtcDIub3JpZ2luYWwgJiYgdG1wMi5vcmlnaW5hbC5zdGF0ZSAmJiB0bXAyLm9yaWdpbmFsLnN0YXRlLnVuZGV0ZXJtaW5lZCAmJiB0bXAyLm9yaWdpbmFsLnN0YXRlLnVuZGV0ZXJtaW5lZCA9PT0gdHJ1ZSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChvW3RtcDIuaWRdID09PSB1bmRlZmluZWQgJiYgdG1wMi5pZCAhPT0gJC5qc3RyZWUucm9vdCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG9bdG1wMi5pZF0gPSB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHAucHVzaCh0bXAyLmlkKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Zm9yIChrID0gMCwgbCA9IHRtcDIucGFyZW50cy5sZW5ndGg7IGsgPCBsOyBrKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAob1t0bXAyLnBhcmVudHNba11dID09PSB1bmRlZmluZWQgJiYgdG1wMi5wYXJlbnRzW2tdICE9PSAkLmpzdHJlZS5yb290KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0b1t0bXAyLnBhcmVudHNba11dID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRwLnB1c2godG1wMi5wYXJlbnRzW2tdKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0pO1xcblxcblxcdFxcdFxcdHRoaXMuZWxlbWVudC5maW5kKCcuanN0cmVlLXVuZGV0ZXJtaW5lZCcpLnJlbW92ZUNsYXNzKCdqc3RyZWUtdW5kZXRlcm1pbmVkJyk7XFxuXFx0XFx0XFx0Zm9yIChpID0gMCwgaiA9IHAubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCFtW3BbaV1dLnN0YXRlW3QgPyAnc2VsZWN0ZWQnIDogJ2NoZWNrZWQnXSkge1xcblxcdFxcdFxcdFxcdFxcdHMgPSB0aGlzLmdldF9ub2RlKHBbaV0sIHRydWUpO1xcblxcdFxcdFxcdFxcdFxcdGlmIChzICYmIHMubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cy5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5jaGlsZHJlbignLmpzdHJlZS1jaGVja2JveCcpLmFkZENsYXNzKCdqc3RyZWUtdW5kZXRlcm1pbmVkJyk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fTtcXG5cXHRcXHR0aGlzLnJlZHJhd19ub2RlID0gZnVuY3Rpb24gKG9iaiwgZGVlcCwgaXNfY2FsbGJhY2ssIGZvcmNlX3JlbmRlcikge1xcblxcdFxcdFxcdG9iaiA9IHBhcmVudC5yZWRyYXdfbm9kZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcblxcdFxcdFxcdGlmIChvYmopIHtcXG5cXHRcXHRcXHRcXHR2YXIgaSxcXG5cXHRcXHRcXHRcXHQgICAgaixcXG5cXHRcXHRcXHRcXHQgICAgdG1wID0gbnVsbCxcXG5cXHRcXHRcXHRcXHQgICAgaWNvbiA9IG51bGw7XFxuXFx0XFx0XFx0XFx0Zm9yIChpID0gMCwgaiA9IG9iai5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdGlmIChvYmouY2hpbGROb2Rlc1tpXSAmJiBvYmouY2hpbGROb2Rlc1tpXS5jbGFzc05hbWUgJiYgb2JqLmNoaWxkTm9kZXNbaV0uY2xhc3NOYW1lLmluZGV4T2YoXFxcImpzdHJlZS1hbmNob3JcXFwiKSAhPT0gLTEpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0bXAgPSBvYmouY2hpbGROb2Rlc1tpXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGlmICh0bXApIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIXRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbiAmJiB0aGlzLl9tb2RlbC5kYXRhW29iai5pZF0uc3RhdGUuY2hlY2tlZCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRtcC5jbGFzc05hbWUgKz0gJyBqc3RyZWUtY2hlY2tlZCc7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGljb24gPSBfaS5jbG9uZU5vZGUoZmFsc2UpO1xcblxcdFxcdFxcdFxcdFxcdGlmICh0aGlzLl9tb2RlbC5kYXRhW29iai5pZF0uc3RhdGUuY2hlY2tib3hfZGlzYWJsZWQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpY29uLmNsYXNzTmFtZSArPSAnIGpzdHJlZS1jaGVja2JveC1kaXNhYmxlZCc7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdHRtcC5pbnNlcnRCZWZvcmUoaWNvbiwgdG1wLmNoaWxkTm9kZXNbMF0pO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKCFpc19jYWxsYmFjayAmJiB0aGlzLnNldHRpbmdzLmNoZWNrYm94LmNhc2NhZGUuaW5kZXhPZigndW5kZXRlcm1pbmVkJykgIT09IC0xKSB7XFxuXFx0XFx0XFx0XFx0aWYgKHRoaXMuX2RhdGEuY2hlY2tib3gudXRvKSB7XFxuXFx0XFx0XFx0XFx0XFx0Y2xlYXJUaW1lb3V0KHRoaXMuX2RhdGEuY2hlY2tib3gudXRvKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0dGhpcy5fZGF0YS5jaGVja2JveC51dG8gPSBzZXRUaW1lb3V0KCQucHJveHkodGhpcy5fdW5kZXRlcm1pbmVkLCB0aGlzKSwgNTApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gb2JqO1xcblxcdFxcdH07XFxuXFx0XFx0LyoqXFxuICAgKiBzaG93IHRoZSBub2RlIGNoZWNrYm94IGljb25zXFxuICAgKiBAbmFtZSBzaG93X2NoZWNrYm94ZXMoKVxcbiAgICogQHBsdWdpbiBjaGVja2JveFxcbiAgICovXFxuXFx0XFx0dGhpcy5zaG93X2NoZWNrYm94ZXMgPSBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0dGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5jaGVja2JveGVzID0gdHJ1ZTt0aGlzLmdldF9jb250YWluZXJfdWwoKS5yZW1vdmVDbGFzcyhcXFwianN0cmVlLW5vLWNoZWNrYm94ZXNcXFwiKTtcXG5cXHRcXHR9O1xcblxcdFxcdC8qKlxcbiAgICogaGlkZSB0aGUgbm9kZSBjaGVja2JveCBpY29uc1xcbiAgICogQG5hbWUgaGlkZV9jaGVja2JveGVzKClcXG4gICAqIEBwbHVnaW4gY2hlY2tib3hcXG4gICAqL1xcblxcdFxcdHRoaXMuaGlkZV9jaGVja2JveGVzID0gZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdHRoaXMuX2RhdGEuY29yZS50aGVtZXMuY2hlY2tib3hlcyA9IGZhbHNlO3RoaXMuZ2V0X2NvbnRhaW5lcl91bCgpLmFkZENsYXNzKFxcXCJqc3RyZWUtbm8tY2hlY2tib3hlc1xcXCIpO1xcblxcdFxcdH07XFxuXFx0XFx0LyoqXFxuICAgKiB0b2dnbGUgdGhlIG5vZGUgaWNvbnNcXG4gICAqIEBuYW1lIHRvZ2dsZV9jaGVja2JveGVzKClcXG4gICAqIEBwbHVnaW4gY2hlY2tib3hcXG4gICAqL1xcblxcdFxcdHRoaXMudG9nZ2xlX2NoZWNrYm94ZXMgPSBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0aWYgKHRoaXMuX2RhdGEuY29yZS50aGVtZXMuY2hlY2tib3hlcykge1xcblxcdFxcdFxcdFxcdHRoaXMuaGlkZV9jaGVja2JveGVzKCk7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHR0aGlzLnNob3dfY2hlY2tib3hlcygpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9O1xcblxcdFxcdC8qKlxcbiAgICogY2hlY2tzIGlmIGEgbm9kZSBpcyBpbiBhbiB1bmRldGVybWluZWQgc3RhdGVcXG4gICAqIEBuYW1lIGlzX3VuZGV0ZXJtaW5lZChvYmopXFxuICAgKiBAcGFyYW0gIHttaXhlZH0gb2JqXFxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxcbiAgICovXFxuXFx0XFx0dGhpcy5pc191bmRldGVybWluZWQgPSBmdW5jdGlvbiAob2JqKSB7XFxuXFx0XFx0XFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xcblxcdFxcdFxcdHZhciBzID0gdGhpcy5zZXR0aW5ncy5jaGVja2JveC5jYXNjYWRlLFxcblxcdFxcdFxcdCAgICBpLFxcblxcdFxcdFxcdCAgICBqLFxcblxcdFxcdFxcdCAgICB0ID0gdGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uLFxcblxcdFxcdFxcdCAgICBkID0gdGhpcy5fZGF0YVt0ID8gJ2NvcmUnIDogJ2NoZWNrYm94J10uc2VsZWN0ZWQsXFxuXFx0XFx0XFx0ICAgIG0gPSB0aGlzLl9tb2RlbC5kYXRhO1xcblxcdFxcdFxcdGlmICghb2JqIHx8IG9iai5zdGF0ZVt0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJ10gPT09IHRydWUgfHwgcy5pbmRleE9mKCd1bmRldGVybWluZWQnKSA9PT0gLTEgfHwgcy5pbmRleE9mKCdkb3duJykgPT09IC0xICYmIHMuaW5kZXhPZigndXAnKSA9PT0gLTEpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICghb2JqLnN0YXRlLmxvYWRlZCAmJiBvYmoub3JpZ2luYWwuc3RhdGUudW5kZXRlcm1pbmVkID09PSB0cnVlKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGZvciAoaSA9IDAsIGogPSBvYmouY2hpbGRyZW5fZC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRpZiAoJC5pbkFycmF5KG9iai5jaGlsZHJlbl9kW2ldLCBkKSAhPT0gLTEgfHwgIW1bb2JqLmNoaWxkcmVuX2RbaV1dLnN0YXRlLmxvYWRlZCAmJiBtW29iai5jaGlsZHJlbl9kW2ldXS5vcmlnaW5hbC5zdGF0ZS51bmRldGVybWluZWQpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHR9O1xcblxcdFxcdC8qKlxcbiAgICogZGlzYWJsZSBhIG5vZGUncyBjaGVja2JveFxcbiAgICogQG5hbWUgZGlzYWJsZV9jaGVja2JveChvYmopXFxuICAgKiBAcGFyYW0ge21peGVkfSBvYmogYW4gYXJyYXkgY2FuIGJlIHVzZWQgdG9vXFxuICAgKiBAdHJpZ2dlciBkaXNhYmxlX2NoZWNrYm94LmpzdHJlZVxcbiAgICogQHBsdWdpbiBjaGVja2JveFxcbiAgICovXFxuXFx0XFx0dGhpcy5kaXNhYmxlX2NoZWNrYm94ID0gZnVuY3Rpb24gKG9iaikge1xcblxcdFxcdFxcdHZhciB0MSwgdDIsIGRvbTtcXG5cXHRcXHRcXHRpZiAoJC5pc0FycmF5KG9iaikpIHtcXG5cXHRcXHRcXHRcXHRvYmogPSBvYmouc2xpY2UoKTtcXG5cXHRcXHRcXHRcXHRmb3IgKHQxID0gMCwgdDIgPSBvYmoubGVuZ3RoOyB0MSA8IHQyOyB0MSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5kaXNhYmxlX2NoZWNrYm94KG9ialt0MV0pO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xcblxcdFxcdFxcdGlmICghb2JqIHx8IG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCkge1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0ZG9tID0gdGhpcy5nZXRfbm9kZShvYmosIHRydWUpO1xcblxcdFxcdFxcdGlmICghb2JqLnN0YXRlLmNoZWNrYm94X2Rpc2FibGVkKSB7XFxuXFx0XFx0XFx0XFx0b2JqLnN0YXRlLmNoZWNrYm94X2Rpc2FibGVkID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRpZiAoZG9tICYmIGRvbS5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRcXHRkb20uY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuY2hpbGRyZW4oJy5qc3RyZWUtY2hlY2tib3gnKS5hZGRDbGFzcygnanN0cmVlLWNoZWNrYm94LWRpc2FibGVkJyk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdC8qKlxcbiAgICAgKiB0cmlnZ2VyZWQgd2hlbiBhbiBub2RlJ3MgY2hlY2tib3ggaXMgZGlzYWJsZWRcXG4gICAgICogQGV2ZW50XFxuICAgICAqIEBuYW1lIGRpc2FibGVfY2hlY2tib3guanN0cmVlXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlXFxuICAgICAqIEBwbHVnaW4gY2hlY2tib3hcXG4gICAgICovXFxuXFx0XFx0XFx0XFx0dGhpcy50cmlnZ2VyKCdkaXNhYmxlX2NoZWNrYm94JywgeyAnbm9kZSc6IG9iaiB9KTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fTtcXG5cXHRcXHQvKipcXG4gICAqIGVuYWJsZSBhIG5vZGUncyBjaGVja2JveFxcbiAgICogQG5hbWUgZGlzYWJsZV9jaGVja2JveChvYmopXFxuICAgKiBAcGFyYW0ge21peGVkfSBvYmogYW4gYXJyYXkgY2FuIGJlIHVzZWQgdG9vXFxuICAgKiBAdHJpZ2dlciBlbmFibGVfY2hlY2tib3guanN0cmVlXFxuICAgKiBAcGx1Z2luIGNoZWNrYm94XFxuICAgKi9cXG5cXHRcXHR0aGlzLmVuYWJsZV9jaGVja2JveCA9IGZ1bmN0aW9uIChvYmopIHtcXG5cXHRcXHRcXHR2YXIgdDEsIHQyLCBkb207XFxuXFx0XFx0XFx0aWYgKCQuaXNBcnJheShvYmopKSB7XFxuXFx0XFx0XFx0XFx0b2JqID0gb2JqLnNsaWNlKCk7XFxuXFx0XFx0XFx0XFx0Zm9yICh0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuZW5hYmxlX2NoZWNrYm94KG9ialt0MV0pO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xcblxcdFxcdFxcdGlmICghb2JqIHx8IG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCkge1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0ZG9tID0gdGhpcy5nZXRfbm9kZShvYmosIHRydWUpO1xcblxcdFxcdFxcdGlmIChvYmouc3RhdGUuY2hlY2tib3hfZGlzYWJsZWQpIHtcXG5cXHRcXHRcXHRcXHRvYmouc3RhdGUuY2hlY2tib3hfZGlzYWJsZWQgPSBmYWxzZTtcXG5cXHRcXHRcXHRcXHRpZiAoZG9tICYmIGRvbS5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRcXHRkb20uY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuY2hpbGRyZW4oJy5qc3RyZWUtY2hlY2tib3gnKS5yZW1vdmVDbGFzcygnanN0cmVlLWNoZWNrYm94LWRpc2FibGVkJyk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdC8qKlxcbiAgICAgKiB0cmlnZ2VyZWQgd2hlbiBhbiBub2RlJ3MgY2hlY2tib3ggaXMgZW5hYmxlZFxcbiAgICAgKiBAZXZlbnRcXG4gICAgICogQG5hbWUgZW5hYmxlX2NoZWNrYm94LmpzdHJlZVxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZVxcbiAgICAgKiBAcGx1Z2luIGNoZWNrYm94XFxuICAgICAqL1xcblxcdFxcdFxcdFxcdHRoaXMudHJpZ2dlcignZW5hYmxlX2NoZWNrYm94JywgeyAnbm9kZSc6IG9iaiB9KTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fTtcXG5cXG5cXHRcXHR0aGlzLmFjdGl2YXRlX25vZGUgPSBmdW5jdGlvbiAob2JqLCBlKSB7XFxuXFx0XFx0XFx0aWYgKCQoZS50YXJnZXQpLmhhc0NsYXNzKCdqc3RyZWUtY2hlY2tib3gtZGlzYWJsZWQnKSkge1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbiAmJiAodGhpcy5zZXR0aW5ncy5jaGVja2JveC53aG9sZV9ub2RlIHx8ICQoZS50YXJnZXQpLmhhc0NsYXNzKCdqc3RyZWUtY2hlY2tib3gnKSkpIHtcXG5cXHRcXHRcXHRcXHRlLmN0cmxLZXkgPSB0cnVlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAodGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uIHx8ICF0aGlzLnNldHRpbmdzLmNoZWNrYm94Lndob2xlX25vZGUgJiYgISQoZS50YXJnZXQpLmhhc0NsYXNzKCdqc3RyZWUtY2hlY2tib3gnKSkge1xcblxcdFxcdFxcdFxcdHJldHVybiBwYXJlbnQuYWN0aXZhdGVfbm9kZS5jYWxsKHRoaXMsIG9iaiwgZSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICh0aGlzLmlzX2Rpc2FibGVkKG9iaikpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICh0aGlzLmlzX2NoZWNrZWQob2JqKSkge1xcblxcdFxcdFxcdFxcdHRoaXMudW5jaGVja19ub2RlKG9iaiwgZSk7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHR0aGlzLmNoZWNrX25vZGUob2JqLCBlKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0dGhpcy50cmlnZ2VyKCdhY3RpdmF0ZV9ub2RlJywgeyAnbm9kZSc6IHRoaXMuZ2V0X25vZGUob2JqKSB9KTtcXG5cXHRcXHR9O1xcblxcblxcdFxcdC8qKlxcbiAgICogY2hlY2sgYSBub2RlIChvbmx5IGlmIHRpZV9zZWxlY3Rpb24gaW4gY2hlY2tib3ggc2V0dGluZ3MgaXMgZmFsc2UsIG90aGVyd2lzZSBzZWxlY3Rfbm9kZSB3aWxsIGJlIGNhbGxlZCBpbnRlcm5hbGx5KVxcbiAgICogQG5hbWUgY2hlY2tfbm9kZShvYmopXFxuICAgKiBAcGFyYW0ge21peGVkfSBvYmogYW4gYXJyYXkgY2FuIGJlIHVzZWQgdG8gY2hlY2sgbXVsdGlwbGUgbm9kZXNcXG4gICAqIEB0cmlnZ2VyIGNoZWNrX25vZGUuanN0cmVlXFxuICAgKiBAcGx1Z2luIGNoZWNrYm94XFxuICAgKi9cXG5cXHRcXHR0aGlzLmNoZWNrX25vZGUgPSBmdW5jdGlvbiAob2JqLCBlKSB7XFxuXFx0XFx0XFx0aWYgKHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbikge1xcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLnNlbGVjdF9ub2RlKG9iaiwgZmFsc2UsIHRydWUsIGUpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR2YXIgZG9tLCB0MSwgdDIsIHRoO1xcblxcdFxcdFxcdGlmICgkLmlzQXJyYXkob2JqKSkge1xcblxcdFxcdFxcdFxcdG9iaiA9IG9iai5zbGljZSgpO1xcblxcdFxcdFxcdFxcdGZvciAodDEgPSAwLCB0MiA9IG9iai5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmNoZWNrX25vZGUob2JqW3QxXSwgZSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XFxuXFx0XFx0XFx0aWYgKCFvYmogfHwgb2JqLmlkID09PSAkLmpzdHJlZS5yb290KSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRkb20gPSB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSk7XFxuXFx0XFx0XFx0aWYgKCFvYmouc3RhdGUuY2hlY2tlZCkge1xcblxcdFxcdFxcdFxcdG9iai5zdGF0ZS5jaGVja2VkID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHR0aGlzLl9kYXRhLmNoZWNrYm94LnNlbGVjdGVkLnB1c2gob2JqLmlkKTtcXG5cXHRcXHRcXHRcXHRpZiAoZG9tICYmIGRvbS5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRcXHRkb20uY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuYWRkQ2xhc3MoJ2pzdHJlZS1jaGVja2VkJyk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdC8qKlxcbiAgICAgKiB0cmlnZ2VyZWQgd2hlbiBhbiBub2RlIGlzIGNoZWNrZWQgKG9ubHkgaWYgdGllX3NlbGVjdGlvbiBpbiBjaGVja2JveCBzZXR0aW5ncyBpcyBmYWxzZSlcXG4gICAgICogQGV2ZW50XFxuICAgICAqIEBuYW1lIGNoZWNrX25vZGUuanN0cmVlXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlXFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHNlbGVjdGVkIHRoZSBjdXJyZW50IHNlbGVjdGlvblxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgdGhlIGV2ZW50IChpZiBhbnkpIHRoYXQgdHJpZ2dlcmVkIHRoaXMgY2hlY2tfbm9kZVxcbiAgICAgKiBAcGx1Z2luIGNoZWNrYm94XFxuICAgICAqL1xcblxcdFxcdFxcdFxcdHRoaXMudHJpZ2dlcignY2hlY2tfbm9kZScsIHsgJ25vZGUnOiBvYmosICdzZWxlY3RlZCc6IHRoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWQsICdldmVudCc6IGUgfSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH07XFxuXFx0XFx0LyoqXFxuICAgKiB1bmNoZWNrIGEgbm9kZSAob25seSBpZiB0aWVfc2VsZWN0aW9uIGluIGNoZWNrYm94IHNldHRpbmdzIGlzIGZhbHNlLCBvdGhlcndpc2UgZGVzZWxlY3Rfbm9kZSB3aWxsIGJlIGNhbGxlZCBpbnRlcm5hbGx5KVxcbiAgICogQG5hbWUgdW5jaGVja19ub2RlKG9iailcXG4gICAqIEBwYXJhbSB7bWl4ZWR9IG9iaiBhbiBhcnJheSBjYW4gYmUgdXNlZCB0byB1bmNoZWNrIG11bHRpcGxlIG5vZGVzXFxuICAgKiBAdHJpZ2dlciB1bmNoZWNrX25vZGUuanN0cmVlXFxuICAgKiBAcGx1Z2luIGNoZWNrYm94XFxuICAgKi9cXG5cXHRcXHR0aGlzLnVuY2hlY2tfbm9kZSA9IGZ1bmN0aW9uIChvYmosIGUpIHtcXG5cXHRcXHRcXHRpZiAodGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuZGVzZWxlY3Rfbm9kZShvYmosIGZhbHNlLCBlKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0dmFyIHQxLCB0MiwgZG9tO1xcblxcdFxcdFxcdGlmICgkLmlzQXJyYXkob2JqKSkge1xcblxcdFxcdFxcdFxcdG9iaiA9IG9iai5zbGljZSgpO1xcblxcdFxcdFxcdFxcdGZvciAodDEgPSAwLCB0MiA9IG9iai5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnVuY2hlY2tfbm9kZShvYmpbdDFdLCBlKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXHRcXHRcXHRpZiAoIW9iaiB8fCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGRvbSA9IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKTtcXG5cXHRcXHRcXHRpZiAob2JqLnN0YXRlLmNoZWNrZWQpIHtcXG5cXHRcXHRcXHRcXHRvYmouc3RhdGUuY2hlY2tlZCA9IGZhbHNlO1xcblxcdFxcdFxcdFxcdHRoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWQgPSAkLnZha2F0YS5hcnJheV9yZW1vdmVfaXRlbSh0aGlzLl9kYXRhLmNoZWNrYm94LnNlbGVjdGVkLCBvYmouaWQpO1xcblxcdFxcdFxcdFxcdGlmIChkb20ubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZG9tLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLnJlbW92ZUNsYXNzKCdqc3RyZWUtY2hlY2tlZCcpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHQvKipcXG4gICAgICogdHJpZ2dlcmVkIHdoZW4gYW4gbm9kZSBpcyB1bmNoZWNrZWQgKG9ubHkgaWYgdGllX3NlbGVjdGlvbiBpbiBjaGVja2JveCBzZXR0aW5ncyBpcyBmYWxzZSlcXG4gICAgICogQGV2ZW50XFxuICAgICAqIEBuYW1lIHVuY2hlY2tfbm9kZS5qc3RyZWVcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGVcXG4gICAgICogQHBhcmFtIHtBcnJheX0gc2VsZWN0ZWQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCB0aGUgZXZlbnQgKGlmIGFueSkgdGhhdCB0cmlnZ2VyZWQgdGhpcyB1bmNoZWNrX25vZGVcXG4gICAgICogQHBsdWdpbiBjaGVja2JveFxcbiAgICAgKi9cXG5cXHRcXHRcXHRcXHR0aGlzLnRyaWdnZXIoJ3VuY2hlY2tfbm9kZScsIHsgJ25vZGUnOiBvYmosICdzZWxlY3RlZCc6IHRoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWQsICdldmVudCc6IGUgfSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH07XFxuXFx0XFx0LyoqXFxuICAgKiBjaGVja3MgYWxsIG5vZGVzIGluIHRoZSB0cmVlIChvbmx5IGlmIHRpZV9zZWxlY3Rpb24gaW4gY2hlY2tib3ggc2V0dGluZ3MgaXMgZmFsc2UsIG90aGVyd2lzZSBzZWxlY3RfYWxsIHdpbGwgYmUgY2FsbGVkIGludGVybmFsbHkpXFxuICAgKiBAbmFtZSBjaGVja19hbGwoKVxcbiAgICogQHRyaWdnZXIgY2hlY2tfYWxsLmpzdHJlZSwgY2hhbmdlZC5qc3RyZWVcXG4gICAqIEBwbHVnaW4gY2hlY2tib3hcXG4gICAqL1xcblxcdFxcdHRoaXMuY2hlY2tfYWxsID0gZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdGlmICh0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb24pIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5zZWxlY3RfYWxsKCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHZhciB0bXAgPSB0aGlzLl9kYXRhLmNoZWNrYm94LnNlbGVjdGVkLmNvbmNhdChbXSksXFxuXFx0XFx0XFx0ICAgIGksXFxuXFx0XFx0XFx0ICAgIGo7XFxuXFx0XFx0XFx0dGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZCA9IHRoaXMuX21vZGVsLmRhdGFbJC5qc3RyZWUucm9vdF0uY2hpbGRyZW5fZC5jb25jYXQoKTtcXG5cXHRcXHRcXHRmb3IgKGkgPSAwLCBqID0gdGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRpZiAodGhpcy5fbW9kZWwuZGF0YVt0aGlzLl9kYXRhLmNoZWNrYm94LnNlbGVjdGVkW2ldXSkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX21vZGVsLmRhdGFbdGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZFtpXV0uc3RhdGUuY2hlY2tlZCA9IHRydWU7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR0aGlzLnJlZHJhdyh0cnVlKTtcXG5cXHRcXHRcXHQvKipcXG4gICAgKiB0cmlnZ2VyZWQgd2hlbiBhbGwgbm9kZXMgYXJlIGNoZWNrZWQgKG9ubHkgaWYgdGllX3NlbGVjdGlvbiBpbiBjaGVja2JveCBzZXR0aW5ncyBpcyBmYWxzZSlcXG4gICAgKiBAZXZlbnRcXG4gICAgKiBAbmFtZSBjaGVja19hbGwuanN0cmVlXFxuICAgICogQHBhcmFtIHtBcnJheX0gc2VsZWN0ZWQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uXFxuICAgICogQHBsdWdpbiBjaGVja2JveFxcbiAgICAqL1xcblxcdFxcdFxcdHRoaXMudHJpZ2dlcignY2hlY2tfYWxsJywgeyAnc2VsZWN0ZWQnOiB0aGlzLl9kYXRhLmNoZWNrYm94LnNlbGVjdGVkIH0pO1xcblxcdFxcdH07XFxuXFx0XFx0LyoqXFxuICAgKiB1bmNoZWNrIGFsbCBjaGVja2VkIG5vZGVzIChvbmx5IGlmIHRpZV9zZWxlY3Rpb24gaW4gY2hlY2tib3ggc2V0dGluZ3MgaXMgZmFsc2UsIG90aGVyd2lzZSBkZXNlbGVjdF9hbGwgd2lsbCBiZSBjYWxsZWQgaW50ZXJuYWxseSlcXG4gICAqIEBuYW1lIHVuY2hlY2tfYWxsKClcXG4gICAqIEB0cmlnZ2VyIHVuY2hlY2tfYWxsLmpzdHJlZVxcbiAgICogQHBsdWdpbiBjaGVja2JveFxcbiAgICovXFxuXFx0XFx0dGhpcy51bmNoZWNrX2FsbCA9IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRpZiAodGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuZGVzZWxlY3RfYWxsKCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHZhciB0bXAgPSB0aGlzLl9kYXRhLmNoZWNrYm94LnNlbGVjdGVkLmNvbmNhdChbXSksXFxuXFx0XFx0XFx0ICAgIGksXFxuXFx0XFx0XFx0ICAgIGo7XFxuXFx0XFx0XFx0Zm9yIChpID0gMCwgaiA9IHRoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWQubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0aWYgKHRoaXMuX21vZGVsLmRhdGFbdGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZFtpXV0pIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9tb2RlbC5kYXRhW3RoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWRbaV1dLnN0YXRlLmNoZWNrZWQgPSBmYWxzZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHRoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWQgPSBbXTtcXG5cXHRcXHRcXHR0aGlzLmVsZW1lbnQuZmluZCgnLmpzdHJlZS1jaGVja2VkJykucmVtb3ZlQ2xhc3MoJ2pzdHJlZS1jaGVja2VkJyk7XFxuXFx0XFx0XFx0LyoqXFxuICAgICogdHJpZ2dlcmVkIHdoZW4gYWxsIG5vZGVzIGFyZSB1bmNoZWNrZWQgKG9ubHkgaWYgdGllX3NlbGVjdGlvbiBpbiBjaGVja2JveCBzZXR0aW5ncyBpcyBmYWxzZSlcXG4gICAgKiBAZXZlbnRcXG4gICAgKiBAbmFtZSB1bmNoZWNrX2FsbC5qc3RyZWVcXG4gICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZSB0aGUgcHJldmlvdXMgc2VsZWN0aW9uXFxuICAgICogQHBhcmFtIHtBcnJheX0gc2VsZWN0ZWQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uXFxuICAgICogQHBsdWdpbiBjaGVja2JveFxcbiAgICAqL1xcblxcdFxcdFxcdHRoaXMudHJpZ2dlcigndW5jaGVja19hbGwnLCB7ICdzZWxlY3RlZCc6IHRoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWQsICdub2RlJzogdG1wIH0pO1xcblxcdFxcdH07XFxuXFx0XFx0LyoqXFxuICAgKiBjaGVja3MgaWYgYSBub2RlIGlzIGNoZWNrZWQgKGlmIHRpZV9zZWxlY3Rpb24gaXMgb24gaW4gdGhlIHNldHRpbmdzIHRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gdGhlIHNhbWUgYXMgaXNfc2VsZWN0ZWQpXFxuICAgKiBAbmFtZSBpc19jaGVja2VkKG9iailcXG4gICAqIEBwYXJhbSAge21peGVkfSAgb2JqXFxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxcbiAgICogQHBsdWdpbiBjaGVja2JveFxcbiAgICovXFxuXFx0XFx0dGhpcy5pc19jaGVja2VkID0gZnVuY3Rpb24gKG9iaikge1xcblxcdFxcdFxcdGlmICh0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb24pIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5pc19zZWxlY3RlZChvYmopO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XFxuXFx0XFx0XFx0aWYgKCFvYmogfHwgb2JqLmlkID09PSAkLmpzdHJlZS5yb290KSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gb2JqLnN0YXRlLmNoZWNrZWQ7XFxuXFx0XFx0fTtcXG5cXHRcXHQvKipcXG4gICAqIGdldCBhbiBhcnJheSBvZiBhbGwgY2hlY2tlZCBub2RlcyAoaWYgdGllX3NlbGVjdGlvbiBpcyBvbiBpbiB0aGUgc2V0dGluZ3MgdGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgc2FtZSBhcyBnZXRfc2VsZWN0ZWQpXFxuICAgKiBAbmFtZSBnZXRfY2hlY2tlZChbZnVsbF0pXFxuICAgKiBAcGFyYW0gIHttaXhlZH0gIGZ1bGwgaWYgc2V0IHRvIGB0cnVlYCB0aGUgcmV0dXJuZWQgYXJyYXkgd2lsbCBjb25zaXN0IG9mIHRoZSBmdWxsIG5vZGUgb2JqZWN0cywgb3RoZXJ3aXNlIC0gb25seSBJRHMgd2lsbCBiZSByZXR1cm5lZFxcbiAgICogQHJldHVybiB7QXJyYXl9XFxuICAgKiBAcGx1Z2luIGNoZWNrYm94XFxuICAgKi9cXG5cXHRcXHR0aGlzLmdldF9jaGVja2VkID0gZnVuY3Rpb24gKGZ1bGwpIHtcXG5cXHRcXHRcXHRpZiAodGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuZ2V0X3NlbGVjdGVkKGZ1bGwpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gZnVsbCA/ICQubWFwKHRoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWQsICQucHJveHkoZnVuY3Rpb24gKGkpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5nZXRfbm9kZShpKTtcXG5cXHRcXHRcXHR9LCB0aGlzKSkgOiB0aGlzLl9kYXRhLmNoZWNrYm94LnNlbGVjdGVkO1xcblxcdFxcdH07XFxuXFx0XFx0LyoqXFxuICAgKiBnZXQgYW4gYXJyYXkgb2YgYWxsIHRvcCBsZXZlbCBjaGVja2VkIG5vZGVzIChpZ25vcmluZyBjaGlsZHJlbiBvZiBjaGVja2VkIG5vZGVzKSAoaWYgdGllX3NlbGVjdGlvbiBpcyBvbiBpbiB0aGUgc2V0dGluZ3MgdGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgc2FtZSBhcyBnZXRfdG9wX3NlbGVjdGVkKVxcbiAgICogQG5hbWUgZ2V0X3RvcF9jaGVja2VkKFtmdWxsXSlcXG4gICAqIEBwYXJhbSAge21peGVkfSAgZnVsbCBpZiBzZXQgdG8gYHRydWVgIHRoZSByZXR1cm5lZCBhcnJheSB3aWxsIGNvbnNpc3Qgb2YgdGhlIGZ1bGwgbm9kZSBvYmplY3RzLCBvdGhlcndpc2UgLSBvbmx5IElEcyB3aWxsIGJlIHJldHVybmVkXFxuICAgKiBAcmV0dXJuIHtBcnJheX1cXG4gICAqIEBwbHVnaW4gY2hlY2tib3hcXG4gICAqL1xcblxcdFxcdHRoaXMuZ2V0X3RvcF9jaGVja2VkID0gZnVuY3Rpb24gKGZ1bGwpIHtcXG5cXHRcXHRcXHRpZiAodGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuZ2V0X3RvcF9zZWxlY3RlZChmdWxsKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0dmFyIHRtcCA9IHRoaXMuZ2V0X2NoZWNrZWQodHJ1ZSksXFxuXFx0XFx0XFx0ICAgIG9iaiA9IHt9LFxcblxcdFxcdFxcdCAgICBpLFxcblxcdFxcdFxcdCAgICBqLFxcblxcdFxcdFxcdCAgICBrLFxcblxcdFxcdFxcdCAgICBsO1xcblxcdFxcdFxcdGZvciAoaSA9IDAsIGogPSB0bXAubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0b2JqW3RtcFtpXS5pZF0gPSB0bXBbaV07XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGZvciAoaSA9IDAsIGogPSB0bXAubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0Zm9yIChrID0gMCwgbCA9IHRtcFtpXS5jaGlsZHJlbl9kLmxlbmd0aDsgayA8IGw7IGsrKykge1xcblxcdFxcdFxcdFxcdFxcdGlmIChvYmpbdG1wW2ldLmNoaWxkcmVuX2Rba11dKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZGVsZXRlIG9ialt0bXBbaV0uY2hpbGRyZW5fZFtrXV07XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0dG1wID0gW107XFxuXFx0XFx0XFx0Zm9yIChpIGluIG9iaikge1xcblxcdFxcdFxcdFxcdGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcXG5cXHRcXHRcXHRcXHRcXHR0bXAucHVzaChpKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiBmdWxsID8gJC5tYXAodG1wLCAkLnByb3h5KGZ1bmN0aW9uIChpKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuZ2V0X25vZGUoaSk7XFxuXFx0XFx0XFx0fSwgdGhpcykpIDogdG1wO1xcblxcdFxcdH07XFxuXFx0XFx0LyoqXFxuICAgKiBnZXQgYW4gYXJyYXkgb2YgYWxsIGJvdHRvbSBsZXZlbCBjaGVja2VkIG5vZGVzIChpZ25vcmluZyBzZWxlY3RlZCBwYXJlbnRzKSAoaWYgdGllX3NlbGVjdGlvbiBpcyBvbiBpbiB0aGUgc2V0dGluZ3MgdGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgc2FtZSBhcyBnZXRfYm90dG9tX3NlbGVjdGVkKVxcbiAgICogQG5hbWUgZ2V0X2JvdHRvbV9jaGVja2VkKFtmdWxsXSlcXG4gICAqIEBwYXJhbSAge21peGVkfSAgZnVsbCBpZiBzZXQgdG8gYHRydWVgIHRoZSByZXR1cm5lZCBhcnJheSB3aWxsIGNvbnNpc3Qgb2YgdGhlIGZ1bGwgbm9kZSBvYmplY3RzLCBvdGhlcndpc2UgLSBvbmx5IElEcyB3aWxsIGJlIHJldHVybmVkXFxuICAgKiBAcmV0dXJuIHtBcnJheX1cXG4gICAqIEBwbHVnaW4gY2hlY2tib3hcXG4gICAqL1xcblxcdFxcdHRoaXMuZ2V0X2JvdHRvbV9jaGVja2VkID0gZnVuY3Rpb24gKGZ1bGwpIHtcXG5cXHRcXHRcXHRpZiAodGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuZ2V0X2JvdHRvbV9zZWxlY3RlZChmdWxsKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0dmFyIHRtcCA9IHRoaXMuZ2V0X2NoZWNrZWQodHJ1ZSksXFxuXFx0XFx0XFx0ICAgIG9iaiA9IFtdLFxcblxcdFxcdFxcdCAgICBpLFxcblxcdFxcdFxcdCAgICBqO1xcblxcdFxcdFxcdGZvciAoaSA9IDAsIGogPSB0bXAubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCF0bXBbaV0uY2hpbGRyZW4ubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0b2JqLnB1c2godG1wW2ldLmlkKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiBmdWxsID8gJC5tYXAob2JqLCAkLnByb3h5KGZ1bmN0aW9uIChpKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuZ2V0X25vZGUoaSk7XFxuXFx0XFx0XFx0fSwgdGhpcykpIDogb2JqO1xcblxcdFxcdH07XFxuXFx0XFx0dGhpcy5sb2FkX25vZGUgPSBmdW5jdGlvbiAob2JqLCBjYWxsYmFjaykge1xcblxcdFxcdFxcdHZhciBrLCBsLCBpLCBqLCBjLCB0bXA7XFxuXFx0XFx0XFx0aWYgKCEkLmlzQXJyYXkob2JqKSAmJiAhdGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uKSB7XFxuXFx0XFx0XFx0XFx0dG1wID0gdGhpcy5nZXRfbm9kZShvYmopO1xcblxcdFxcdFxcdFxcdGlmICh0bXAgJiYgdG1wLnN0YXRlLmxvYWRlZCkge1xcblxcdFxcdFxcdFxcdFxcdGZvciAoayA9IDAsIGwgPSB0bXAuY2hpbGRyZW5fZC5sZW5ndGg7IGsgPCBsOyBrKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAodGhpcy5fbW9kZWwuZGF0YVt0bXAuY2hpbGRyZW5fZFtrXV0uc3RhdGUuY2hlY2tlZCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGMgPSB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWQgPSAkLnZha2F0YS5hcnJheV9yZW1vdmVfaXRlbSh0aGlzLl9kYXRhLmNoZWNrYm94LnNlbGVjdGVkLCB0bXAuY2hpbGRyZW5fZFtrXSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiBwYXJlbnQubG9hZF9ub2RlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuXFx0XFx0fTtcXG5cXHRcXHR0aGlzLmdldF9zdGF0ZSA9IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHR2YXIgc3RhdGUgPSBwYXJlbnQuZ2V0X3N0YXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuXFx0XFx0XFx0aWYgKHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbikge1xcblxcdFxcdFxcdFxcdHJldHVybiBzdGF0ZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0c3RhdGUuY2hlY2tib3ggPSB0aGlzLl9kYXRhLmNoZWNrYm94LnNlbGVjdGVkLnNsaWNlKCk7XFxuXFx0XFx0XFx0cmV0dXJuIHN0YXRlO1xcblxcdFxcdH07XFxuXFx0XFx0dGhpcy5zZXRfc3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUsIGNhbGxiYWNrKSB7XFxuXFx0XFx0XFx0dmFyIHJlcyA9IHBhcmVudC5zZXRfc3RhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG5cXHRcXHRcXHRpZiAocmVzICYmIHN0YXRlLmNoZWNrYm94KSB7XFxuXFx0XFx0XFx0XFx0aWYgKCF0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb24pIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnVuY2hlY2tfYWxsKCk7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIF90aGlzID0gdGhpcztcXG5cXHRcXHRcXHRcXHRcXHQkLmVhY2goc3RhdGUuY2hlY2tib3gsIGZ1bmN0aW9uIChpLCB2KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0X3RoaXMuY2hlY2tfbm9kZSh2KTtcXG5cXHRcXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0ZGVsZXRlIHN0YXRlLmNoZWNrYm94O1xcblxcdFxcdFxcdFxcdHRoaXMuc2V0X3N0YXRlKHN0YXRlLCBjYWxsYmFjayk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gcmVzO1xcblxcdFxcdH07XFxuXFx0XFx0dGhpcy5yZWZyZXNoID0gZnVuY3Rpb24gKHNraXBfbG9hZGluZywgZm9yZ2V0X3N0YXRlKSB7XFxuXFx0XFx0XFx0aWYgKCF0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb24pIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9kYXRhLmNoZWNrYm94LnNlbGVjdGVkID0gW107XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiBwYXJlbnQucmVmcmVzaC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcblxcdFxcdH07XFxuXFx0fTtcXG5cXG5cXHQvLyBpbmNsdWRlIHRoZSBjaGVja2JveCBwbHVnaW4gYnkgZGVmYXVsdFxcblxcdC8vICQuanN0cmVlLmRlZmF1bHRzLnBsdWdpbnMucHVzaChcXFwiY2hlY2tib3hcXFwiKTtcXG5cXG5cXHQvKipcXG4gICogIyMjIENvbmRpdGlvbmFsc2VsZWN0IHBsdWdpblxcbiAgKlxcbiAgKiBUaGlzIHBsdWdpbiBhbGxvd3MgZGVmaW5pbmcgYSBjYWxsYmFjayB0byBhbGxvdyBvciBkZW55IG5vZGUgc2VsZWN0aW9uIGJ5IHVzZXIgaW5wdXQgKGFjdGl2YXRlIG5vZGUgbWV0aG9kKS5cXG4gICovXFxuXFxuXFx0LyoqXFxuICAqIGEgY2FsbGJhY2sgKGZ1bmN0aW9uKSB3aGljaCBpcyBpbnZva2VkIGluIHRoZSBpbnN0YW5jZSdzIHNjb3BlIGFuZCByZWNlaXZlcyB0d28gYXJndW1lbnRzIC0gdGhlIG5vZGUgYW5kIHRoZSBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGUgYGFjdGl2YXRlX25vZGVgIGNhbGwuIFJldHVybmluZyBmYWxzZSBwcmV2ZW50cyB3b3JraW5nIHdpdGggdGhlIG5vZGUsIHJldHVybmluZyB0cnVlIGFsbG93cyBpbnZva2luZyBhY3RpdmF0ZV9ub2RlLiBEZWZhdWx0cyB0byByZXR1cm5pbmcgYHRydWVgLlxcbiAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jaGVja2JveC52aXNpYmxlXFxuICAqIEBwbHVnaW4gY2hlY2tib3hcXG4gICovXFxuXFx0JC5qc3RyZWUuZGVmYXVsdHMuY29uZGl0aW9uYWxzZWxlY3QgPSBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0fTtcXG5cXHQkLmpzdHJlZS5wbHVnaW5zLmNvbmRpdGlvbmFsc2VsZWN0ID0gZnVuY3Rpb24gKG9wdGlvbnMsIHBhcmVudCkge1xcblxcdFxcdC8vIG93biBmdW5jdGlvblxcblxcdFxcdHRoaXMuYWN0aXZhdGVfbm9kZSA9IGZ1bmN0aW9uIChvYmosIGUpIHtcXG5cXHRcXHRcXHRpZiAodGhpcy5zZXR0aW5ncy5jb25kaXRpb25hbHNlbGVjdC5jYWxsKHRoaXMsIHRoaXMuZ2V0X25vZGUob2JqKSwgZSkpIHtcXG5cXHRcXHRcXHRcXHRwYXJlbnQuYWN0aXZhdGVfbm9kZS5jYWxsKHRoaXMsIG9iaiwgZSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH07XFxuXFx0fTtcXG5cXG5cXHQvKipcXG4gICogIyMjIENvbnRleHRtZW51IHBsdWdpblxcbiAgKlxcbiAgKiBTaG93cyBhIGNvbnRleHQgbWVudSB3aGVuIGEgbm9kZSBpcyByaWdodC1jbGlja2VkLlxcbiAgKi9cXG5cXG5cXHQvKipcXG4gICogc3RvcmVzIGFsbCBkZWZhdWx0cyBmb3IgdGhlIGNvbnRleHRtZW51IHBsdWdpblxcbiAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb250ZXh0bWVudVxcbiAgKiBAcGx1Z2luIGNvbnRleHRtZW51XFxuICAqL1xcblxcdCQuanN0cmVlLmRlZmF1bHRzLmNvbnRleHRtZW51ID0ge1xcblxcdFxcdC8qKlxcbiAgICogYSBib29sZWFuIGluZGljYXRpbmcgaWYgdGhlIG5vZGUgc2hvdWxkIGJlIHNlbGVjdGVkIHdoZW4gdGhlIGNvbnRleHQgbWVudSBpcyBpbnZva2VkIG9uIGl0LiBEZWZhdWx0cyB0byBgdHJ1ZWAuXFxuICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb250ZXh0bWVudS5zZWxlY3Rfbm9kZVxcbiAgICogQHBsdWdpbiBjb250ZXh0bWVudVxcbiAgICovXFxuXFx0XFx0c2VsZWN0X25vZGU6IHRydWUsXFxuXFx0XFx0LyoqXFxuICAgKiBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiB0aGUgbWVudSBzaG91bGQgYmUgc2hvd24gYWxpZ25lZCB3aXRoIHRoZSBub2RlLiBEZWZhdWx0cyB0byBgdHJ1ZWAsIG90aGVyd2lzZSB0aGUgbW91c2UgY29vcmRpbmF0ZXMgYXJlIHVzZWQuXFxuICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb250ZXh0bWVudS5zaG93X2F0X25vZGVcXG4gICAqIEBwbHVnaW4gY29udGV4dG1lbnVcXG4gICAqL1xcblxcdFxcdHNob3dfYXRfbm9kZTogdHJ1ZSxcXG5cXHRcXHQvKipcXG4gICAqIGFuIG9iamVjdCBvZiBhY3Rpb25zLCBvciBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBhIG5vZGUgYW5kIGEgY2FsbGJhY2sgZnVuY3Rpb24gYW5kIGNhbGxzIHRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aXRoIGFuIG9iamVjdCBvZiBhY3Rpb25zIGF2YWlsYWJsZSBmb3IgdGhhdCBub2RlICh5b3UgY2FuIGFsc28gcmV0dXJuIHRoZSBpdGVtcyB0b28pLlxcbiAgICpcXG4gICAqIEVhY2ggYWN0aW9uIGNvbnNpc3RzIG9mIGEga2V5IChhIHVuaXF1ZSBuYW1lKSBhbmQgYSB2YWx1ZSB3aGljaCBpcyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXMgKG9ubHkgbGFiZWwgYW5kIGFjdGlvbiBhcmUgcmVxdWlyZWQpLiBPbmNlIGEgbWVudSBpdGVtIGlzIGFjdGl2YXRlZCB0aGUgYGFjdGlvbmAgZnVuY3Rpb24gd2lsbCBiZSBpbnZva2VkIHdpdGggYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGZvbGxvd2luZyBrZXlzOiBpdGVtIC0gdGhlIGNvbnRleHRtZW51IGl0ZW0gZGVmaW5pdGlvbiBhcyBzZWVuIGJlbG93LCByZWZlcmVuY2UgLSB0aGUgRE9NIG5vZGUgdGhhdCB3YXMgdXNlZCAodGhlIHRyZWUgbm9kZSksIGVsZW1lbnQgLSB0aGUgY29udGV4dG1lbnUgRE9NIGVsZW1lbnQsIHBvc2l0aW9uIC0gYW4gb2JqZWN0IHdpdGggeC95IHByb3BlcnRpZXMgaW5kaWNhdGluZyB0aGUgcG9zaXRpb24gb2YgdGhlIG1lbnUuXFxuICAgKlxcbiAgICogKiBgc2VwYXJhdG9yX2JlZm9yZWAgLSBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiB0aGVyZSBzaG91bGQgYmUgYSBzZXBhcmF0b3IgYmVmb3JlIHRoaXMgaXRlbVxcbiAgICogKiBgc2VwYXJhdG9yX2FmdGVyYCAtIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoZXJlIHNob3VsZCBiZSBhIHNlcGFyYXRvciBhZnRlciB0aGlzIGl0ZW1cXG4gICAqICogYF9kaXNhYmxlZGAgLSBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiB0aGlzIGFjdGlvbiBzaG91bGQgYmUgZGlzYWJsZWRcXG4gICAqICogYGxhYmVsYCAtIGEgc3RyaW5nIC0gdGhlIG5hbWUgb2YgdGhlIGFjdGlvbiAoY291bGQgYmUgYSBmdW5jdGlvbiByZXR1cm5pbmcgYSBzdHJpbmcpXFxuICAgKiAqIGB0aXRsZWAgLSBhIHN0cmluZyAtIGFuIG9wdGlvbmFsIHRvb2x0aXAgZm9yIHRoZSBpdGVtXFxuICAgKiAqIGBhY3Rpb25gIC0gYSBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCBpZiB0aGlzIGl0ZW0gaXMgY2hvc2VuLCB0aGUgZnVuY3Rpb24gd2lsbCByZWNlaXZlIFxcbiAgICogKiBgaWNvbmAgLSBhIHN0cmluZywgY2FuIGJlIGEgcGF0aCB0byBhbiBpY29uIG9yIGEgY2xhc3NOYW1lLCBpZiB1c2luZyBhbiBpbWFnZSB0aGF0IGlzIGluIHRoZSBjdXJyZW50IGRpcmVjdG9yeSB1c2UgYSBgLi9gIHByZWZpeCwgb3RoZXJ3aXNlIGl0IHdpbGwgYmUgZGV0ZWN0ZWQgYXMgYSBjbGFzc1xcbiAgICogKiBgc2hvcnRjdXRgIC0ga2V5Q29kZSB3aGljaCB3aWxsIHRyaWdnZXIgdGhlIGFjdGlvbiBpZiB0aGUgbWVudSBpcyBvcGVuIChmb3IgZXhhbXBsZSBgMTEzYCBmb3IgcmVuYW1lLCB3aGljaCBlcXVhbHMgRjIpXFxuICAgKiAqIGBzaG9ydGN1dF9sYWJlbGAgLSBzaG9ydGN1dCBsYWJlbCAobGlrZSBmb3IgZXhhbXBsZSBgRjJgIGZvciByZW5hbWUpXFxuICAgKiAqIGBzdWJtZW51YCAtIGFuIG9iamVjdCB3aXRoIHRoZSBzYW1lIHN0cnVjdHVyZSBhcyAkLmpzdHJlZS5kZWZhdWx0cy5jb250ZXh0bWVudS5pdGVtcyB3aGljaCBjYW4gYmUgdXNlZCB0byBjcmVhdGUgYSBzdWJtZW51IC0gZWFjaCBrZXkgd2lsbCBiZSByZW5kZXJlZCBhcyBhIHNlcGFyYXRlIG9wdGlvbiBpbiBhIHN1Ym1lbnUgdGhhdCB3aWxsIGFwcGVhciBvbmNlIHRoZSBjdXJyZW50IGl0ZW0gaXMgaG92ZXJlZFxcbiAgICpcXG4gICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvbnRleHRtZW51Lml0ZW1zXFxuICAgKiBAcGx1Z2luIGNvbnRleHRtZW51XFxuICAgKi9cXG5cXHRcXHRpdGVtczogZnVuY3Rpb24gaXRlbXMobywgY2IpIHtcXG5cXHRcXHRcXHQvLyBDb3VsZCBiZSBhbiBvYmplY3QgZGlyZWN0bHlcXG5cXHRcXHRcXHRyZXR1cm4ge1xcblxcdFxcdFxcdFxcdFxcXCJjcmVhdGVcXFwiOiB7XFxuXFx0XFx0XFx0XFx0XFx0XFxcInNlcGFyYXRvcl9iZWZvcmVcXFwiOiBmYWxzZSxcXG5cXHRcXHRcXHRcXHRcXHRcXFwic2VwYXJhdG9yX2FmdGVyXFxcIjogdHJ1ZSxcXG5cXHRcXHRcXHRcXHRcXHRcXFwiX2Rpc2FibGVkXFxcIjogZmFsc2UsIC8vKHRoaXMuY2hlY2soXFxcImNyZWF0ZV9ub2RlXFxcIiwgZGF0YS5yZWZlcmVuY2UsIHt9LCBcXFwibGFzdFxcXCIpKSxcXG5cXHRcXHRcXHRcXHRcXHRcXFwibGFiZWxcXFwiOiBcXFwiQ3JlYXRlXFxcIixcXG5cXHRcXHRcXHRcXHRcXHRcXFwiYWN0aW9uXFxcIjogZnVuY3Rpb24gYWN0aW9uKGRhdGEpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgaW5zdCA9ICQuanN0cmVlLnJlZmVyZW5jZShkYXRhLnJlZmVyZW5jZSksXFxuXFx0XFx0XFx0XFx0XFx0XFx0ICAgIG9iaiA9IGluc3QuZ2V0X25vZGUoZGF0YS5yZWZlcmVuY2UpO1xcblxcdFxcdFxcdFxcdFxcdFxcdGluc3QuY3JlYXRlX25vZGUob2JqLCB7fSwgXFxcImxhc3RcXFwiLCBmdW5jdGlvbiAobmV3X25vZGUpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpbnN0LmVkaXQobmV3X25vZGUpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH0sIDApO1xcblxcdFxcdFxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9LFxcblxcdFxcdFxcdFxcdFxcXCJyZW5hbWVcXFwiOiB7XFxuXFx0XFx0XFx0XFx0XFx0XFxcInNlcGFyYXRvcl9iZWZvcmVcXFwiOiBmYWxzZSxcXG5cXHRcXHRcXHRcXHRcXHRcXFwic2VwYXJhdG9yX2FmdGVyXFxcIjogZmFsc2UsXFxuXFx0XFx0XFx0XFx0XFx0XFxcIl9kaXNhYmxlZFxcXCI6IGZhbHNlLCAvLyh0aGlzLmNoZWNrKFxcXCJyZW5hbWVfbm9kZVxcXCIsIGRhdGEucmVmZXJlbmNlLCB0aGlzLmdldF9wYXJlbnQoZGF0YS5yZWZlcmVuY2UpLCBcXFwiXFxcIikpLFxcblxcdFxcdFxcdFxcdFxcdFxcXCJsYWJlbFxcXCI6IFxcXCJSZW5hbWVcXFwiLFxcblxcdFxcdFxcdFxcdFxcdC8qIVxcbiAgICAgXFxcInNob3J0Y3V0XFxcIlxcdFxcdFxcdDogMTEzLFxcbiAgICAgXFxcInNob3J0Y3V0X2xhYmVsXFxcIlxcdDogJ0YyJyxcXG4gICAgIFxcXCJpY29uXFxcIlxcdFxcdFxcdFxcdDogXFxcImdseXBoaWNvbiBnbHlwaGljb24tbGVhZlxcXCIsXFxuICAgICAqL1xcblxcdFxcdFxcdFxcdFxcdFxcXCJhY3Rpb25cXFwiOiBmdW5jdGlvbiBhY3Rpb24oZGF0YSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBpbnN0ID0gJC5qc3RyZWUucmVmZXJlbmNlKGRhdGEucmVmZXJlbmNlKSxcXG5cXHRcXHRcXHRcXHRcXHRcXHQgICAgb2JqID0gaW5zdC5nZXRfbm9kZShkYXRhLnJlZmVyZW5jZSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aW5zdC5lZGl0KG9iaik7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0XFx0XFxcInJlbW92ZVxcXCI6IHtcXG5cXHRcXHRcXHRcXHRcXHRcXFwic2VwYXJhdG9yX2JlZm9yZVxcXCI6IGZhbHNlLFxcblxcdFxcdFxcdFxcdFxcdFxcXCJpY29uXFxcIjogZmFsc2UsXFxuXFx0XFx0XFx0XFx0XFx0XFxcInNlcGFyYXRvcl9hZnRlclxcXCI6IGZhbHNlLFxcblxcdFxcdFxcdFxcdFxcdFxcXCJfZGlzYWJsZWRcXFwiOiBmYWxzZSwgLy8odGhpcy5jaGVjayhcXFwiZGVsZXRlX25vZGVcXFwiLCBkYXRhLnJlZmVyZW5jZSwgdGhpcy5nZXRfcGFyZW50KGRhdGEucmVmZXJlbmNlKSwgXFxcIlxcXCIpKSxcXG5cXHRcXHRcXHRcXHRcXHRcXFwibGFiZWxcXFwiOiBcXFwiRGVsZXRlXFxcIixcXG5cXHRcXHRcXHRcXHRcXHRcXFwiYWN0aW9uXFxcIjogZnVuY3Rpb24gYWN0aW9uKGRhdGEpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgaW5zdCA9ICQuanN0cmVlLnJlZmVyZW5jZShkYXRhLnJlZmVyZW5jZSksXFxuXFx0XFx0XFx0XFx0XFx0XFx0ICAgIG9iaiA9IGluc3QuZ2V0X25vZGUoZGF0YS5yZWZlcmVuY2UpO1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChpbnN0LmlzX3NlbGVjdGVkKG9iaikpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpbnN0LmRlbGV0ZV9ub2RlKGluc3QuZ2V0X3NlbGVjdGVkKCkpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aW5zdC5kZWxldGVfbm9kZShvYmopO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRcXHRcXFwiY2NwXFxcIjoge1xcblxcdFxcdFxcdFxcdFxcdFxcXCJzZXBhcmF0b3JfYmVmb3JlXFxcIjogdHJ1ZSxcXG5cXHRcXHRcXHRcXHRcXHRcXFwiaWNvblxcXCI6IGZhbHNlLFxcblxcdFxcdFxcdFxcdFxcdFxcXCJzZXBhcmF0b3JfYWZ0ZXJcXFwiOiBmYWxzZSxcXG5cXHRcXHRcXHRcXHRcXHRcXFwibGFiZWxcXFwiOiBcXFwiRWRpdFxcXCIsXFxuXFx0XFx0XFx0XFx0XFx0XFxcImFjdGlvblxcXCI6IGZhbHNlLFxcblxcdFxcdFxcdFxcdFxcdFxcXCJzdWJtZW51XFxcIjoge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcXCJjdXRcXFwiOiB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFxcInNlcGFyYXRvcl9iZWZvcmVcXFwiOiBmYWxzZSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXFwic2VwYXJhdG9yX2FmdGVyXFxcIjogZmFsc2UsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFxcImxhYmVsXFxcIjogXFxcIkN1dFxcXCIsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFxcImFjdGlvblxcXCI6IGZ1bmN0aW9uIGFjdGlvbihkYXRhKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIGluc3QgPSAkLmpzdHJlZS5yZWZlcmVuY2UoZGF0YS5yZWZlcmVuY2UpLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdCAgICBvYmogPSBpbnN0LmdldF9ub2RlKGRhdGEucmVmZXJlbmNlKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoaW5zdC5pc19zZWxlY3RlZChvYmopKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aW5zdC5jdXQoaW5zdC5nZXRfdG9wX3NlbGVjdGVkKCkpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aW5zdC5jdXQob2JqKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFxcImNvcHlcXFwiOiB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFxcInNlcGFyYXRvcl9iZWZvcmVcXFwiOiBmYWxzZSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXFwiaWNvblxcXCI6IGZhbHNlLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcXCJzZXBhcmF0b3JfYWZ0ZXJcXFwiOiBmYWxzZSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXFwibGFiZWxcXFwiOiBcXFwiQ29weVxcXCIsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFxcImFjdGlvblxcXCI6IGZ1bmN0aW9uIGFjdGlvbihkYXRhKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIGluc3QgPSAkLmpzdHJlZS5yZWZlcmVuY2UoZGF0YS5yZWZlcmVuY2UpLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdCAgICBvYmogPSBpbnN0LmdldF9ub2RlKGRhdGEucmVmZXJlbmNlKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoaW5zdC5pc19zZWxlY3RlZChvYmopKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aW5zdC5jb3B5KGluc3QuZ2V0X3RvcF9zZWxlY3RlZCgpKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGluc3QuY29weShvYmopO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXFwicGFzdGVcXFwiOiB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFxcInNlcGFyYXRvcl9iZWZvcmVcXFwiOiBmYWxzZSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXFwiaWNvblxcXCI6IGZhbHNlLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcXCJfZGlzYWJsZWRcXFwiOiBmdW5jdGlvbiBfZGlzYWJsZWQoZGF0YSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiAhJC5qc3RyZWUucmVmZXJlbmNlKGRhdGEucmVmZXJlbmNlKS5jYW5fcGFzdGUoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9LFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcXCJzZXBhcmF0b3JfYWZ0ZXJcXFwiOiBmYWxzZSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXFwibGFiZWxcXFwiOiBcXFwiUGFzdGVcXFwiLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcXCJhY3Rpb25cXFwiOiBmdW5jdGlvbiBhY3Rpb24oZGF0YSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciBpbnN0ID0gJC5qc3RyZWUucmVmZXJlbmNlKGRhdGEucmVmZXJlbmNlKSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQgICAgb2JqID0gaW5zdC5nZXRfbm9kZShkYXRhLnJlZmVyZW5jZSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aW5zdC5wYXN0ZShvYmopO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9O1xcblxcdFxcdH1cXG5cXHR9O1xcblxcblxcdCQuanN0cmVlLnBsdWdpbnMuY29udGV4dG1lbnUgPSBmdW5jdGlvbiAob3B0aW9ucywgcGFyZW50KSB7XFxuXFx0XFx0dGhpcy5iaW5kID0gZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdHBhcmVudC5iaW5kLmNhbGwodGhpcyk7XFxuXFxuXFx0XFx0XFx0dmFyIGxhc3RfdHMgPSAwLFxcblxcdFxcdFxcdCAgICBjdG8gPSBudWxsLFxcblxcdFxcdFxcdCAgICBleCxcXG5cXHRcXHRcXHQgICAgZXk7XFxuXFx0XFx0XFx0dGhpcy5lbGVtZW50Lm9uKFxcXCJjb250ZXh0bWVudS5qc3RyZWVcXFwiLCBcXFwiLmpzdHJlZS1hbmNob3JcXFwiLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGUudGFyZ2V0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0Jykge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdFxcdFxcdFxcdGxhc3RfdHMgPSBlLmN0cmxLZXkgPyArbmV3IERhdGUoKSA6IDA7XFxuXFx0XFx0XFx0XFx0aWYgKGRhdGEgfHwgY3RvKSB7XFxuXFx0XFx0XFx0XFx0XFx0bGFzdF90cyA9ICtuZXcgRGF0ZSgpICsgMTAwMDA7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGlmIChjdG8pIHtcXG5cXHRcXHRcXHRcXHRcXHRjbGVhclRpbWVvdXQoY3RvKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aWYgKCF0aGlzLmlzX2xvYWRpbmcoZS5jdXJyZW50VGFyZ2V0KSkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuc2hvd19jb250ZXh0bWVudShlLmN1cnJlbnRUYXJnZXQsIGUucGFnZVgsIGUucGFnZVksIGUpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LCB0aGlzKSkub24oXFxcImNsaWNrLmpzdHJlZVxcXCIsIFxcXCIuanN0cmVlLWFuY2hvclxcXCIsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAodGhpcy5fZGF0YS5jb250ZXh0bWVudS52aXNpYmxlICYmICghbGFzdF90cyB8fCArbmV3IERhdGUoKSAtIGxhc3RfdHMgPiAyNTApKSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gd29yayBhcm91bmQgc2FmYXJpICYgbWFjT1MgY3RybCtjbGlja1xcblxcdFxcdFxcdFxcdFxcdCQudmFrYXRhLmNvbnRleHQuaGlkZSgpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRsYXN0X3RzID0gMDtcXG5cXHRcXHRcXHR9LCB0aGlzKSkub24oXFxcInRvdWNoc3RhcnQuanN0cmVlXFxcIiwgXFxcIi5qc3RyZWUtYW5jaG9yXFxcIiwgZnVuY3Rpb24gKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoIWUub3JpZ2luYWxFdmVudCB8fCAhZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzIHx8ICFlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0pIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGV4ID0gZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFg7XFxuXFx0XFx0XFx0XFx0ZXkgPSBlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WTtcXG5cXHRcXHRcXHRcXHRjdG8gPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHQkKGUuY3VycmVudFRhcmdldCkudHJpZ2dlcignY29udGV4dG1lbnUnLCB0cnVlKTtcXG5cXHRcXHRcXHRcXHR9LCA3NTApO1xcblxcdFxcdFxcdH0pLm9uKCd0b3VjaG1vdmUudmFrYXRhLmpzdHJlZScsIGZ1bmN0aW9uIChlKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGN0byAmJiBlLm9yaWdpbmFsRXZlbnQgJiYgZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzICYmIGUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXSAmJiAoTWF0aC5hYnMoZXggLSBlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WCkgPiA1MCB8fCBNYXRoLmFicyhleSAtIGUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRZKSA+IDUwKSkge1xcblxcdFxcdFxcdFxcdFxcdGNsZWFyVGltZW91dChjdG8pO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9KS5vbigndG91Y2hlbmQudmFrYXRhLmpzdHJlZScsIGZ1bmN0aW9uIChlKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGN0bykge1xcblxcdFxcdFxcdFxcdFxcdGNsZWFyVGltZW91dChjdG8pO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9KTtcXG5cXG5cXHRcXHRcXHQvKiFcXG4gICBpZighKCdvbmNvbnRleHRtZW51JyBpbiBkb2N1bWVudC5ib2R5KSAmJiAoJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuYm9keSkpIHtcXG4gICBcXHR2YXIgZWwgPSBudWxsLCB0bSA9IG51bGw7XFxuICAgXFx0dGhpcy5lbGVtZW50XFxuICAgXFx0XFx0Lm9uKFxcXCJ0b3VjaHN0YXJ0XFxcIiwgXFxcIi5qc3RyZWUtYW5jaG9yXFxcIiwgZnVuY3Rpb24gKGUpIHtcXG4gICBcXHRcXHRcXHRlbCA9IGUuY3VycmVudFRhcmdldDtcXG4gICBcXHRcXHRcXHR0bSA9ICtuZXcgRGF0ZSgpO1xcbiAgIFxcdFxcdFxcdCQoZG9jdW1lbnQpLm9uZShcXFwidG91Y2hlbmRcXFwiLCBmdW5jdGlvbiAoZSkge1xcbiAgIFxcdFxcdFxcdFxcdGUudGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChlLm9yaWdpbmFsRXZlbnQudGFyZ2V0VG91Y2hlc1swXS5wYWdlWCAtIHdpbmRvdy5wYWdlWE9mZnNldCwgZS5vcmlnaW5hbEV2ZW50LnRhcmdldFRvdWNoZXNbMF0ucGFnZVkgLSB3aW5kb3cucGFnZVlPZmZzZXQpO1xcbiAgIFxcdFxcdFxcdFxcdGUuY3VycmVudFRhcmdldCA9IGUudGFyZ2V0O1xcbiAgIFxcdFxcdFxcdFxcdHRtID0gKCgrKG5ldyBEYXRlKCkpKSAtIHRtKTtcXG4gICBcXHRcXHRcXHRcXHRpZihlLnRhcmdldCA9PT0gZWwgJiYgdG0gPiA2MDAgJiYgdG0gPCAxMDAwKSB7XFxuICAgXFx0XFx0XFx0XFx0XFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgIFxcdFxcdFxcdFxcdFxcdCQoZWwpLnRyaWdnZXIoJ2NvbnRleHRtZW51JywgZSk7XFxuICAgXFx0XFx0XFx0XFx0fVxcbiAgIFxcdFxcdFxcdFxcdGVsID0gbnVsbDtcXG4gICBcXHRcXHRcXHRcXHR0bSA9IG51bGw7XFxuICAgXFx0XFx0XFx0fSk7XFxuICAgXFx0XFx0fSk7XFxuICAgfVxcbiAgICovXFxuXFx0XFx0XFx0JChkb2N1bWVudCkub24oXFxcImNvbnRleHRfaGlkZS52YWthdGEuanN0cmVlXFxcIiwgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xcblxcdFxcdFxcdFxcdHRoaXMuX2RhdGEuY29udGV4dG1lbnUudmlzaWJsZSA9IGZhbHNlO1xcblxcdFxcdFxcdFxcdCQoZGF0YS5yZWZlcmVuY2UpLnJlbW92ZUNsYXNzKCdqc3RyZWUtY29udGV4dCcpO1xcblxcdFxcdFxcdH0sIHRoaXMpKTtcXG5cXHRcXHR9O1xcblxcdFxcdHRoaXMudGVhcmRvd24gPSBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0aWYgKHRoaXMuX2RhdGEuY29udGV4dG1lbnUudmlzaWJsZSkge1xcblxcdFxcdFxcdFxcdCQudmFrYXRhLmNvbnRleHQuaGlkZSgpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRwYXJlbnQudGVhcmRvd24uY2FsbCh0aGlzKTtcXG5cXHRcXHR9O1xcblxcblxcdFxcdC8qKlxcbiAgICogcHJlcGFyZSBhbmQgc2hvdyB0aGUgY29udGV4dCBtZW51IGZvciBhIG5vZGVcXG4gICAqIEBuYW1lIHNob3dfY29udGV4dG1lbnUob2JqIFssIHgsIHldKVxcbiAgICogQHBhcmFtIHttaXhlZH0gb2JqIHRoZSBub2RlXFxuICAgKiBAcGFyYW0ge051bWJlcn0geCB0aGUgeC1jb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBkb2N1bWVudCB0byBzaG93IHRoZSBtZW51IGF0XFxuICAgKiBAcGFyYW0ge051bWJlcn0geSB0aGUgeS1jb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBkb2N1bWVudCB0byBzaG93IHRoZSBtZW51IGF0XFxuICAgKiBAcGFyYW0ge09iamVjdH0gZSB0aGUgZXZlbnQgaWYgYXZhaWxhYmxlIHRoYXQgdHJpZ2dlcmVkIHRoZSBjb250ZXh0bWVudVxcbiAgICogQHBsdWdpbiBjb250ZXh0bWVudVxcbiAgICogQHRyaWdnZXIgc2hvd19jb250ZXh0bWVudS5qc3RyZWVcXG4gICAqL1xcblxcdFxcdHRoaXMuc2hvd19jb250ZXh0bWVudSA9IGZ1bmN0aW9uIChvYmosIHgsIHksIGUpIHtcXG5cXHRcXHRcXHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XFxuXFx0XFx0XFx0aWYgKCFvYmogfHwgb2JqLmlkID09PSAkLmpzdHJlZS5yb290KSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR2YXIgcyA9IHRoaXMuc2V0dGluZ3MuY29udGV4dG1lbnUsXFxuXFx0XFx0XFx0ICAgIGQgPSB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSksXFxuXFx0XFx0XFx0ICAgIGEgPSBkLmNoaWxkcmVuKFxcXCIuanN0cmVlLWFuY2hvclxcXCIpLFxcblxcdFxcdFxcdCAgICBvID0gZmFsc2UsXFxuXFx0XFx0XFx0ICAgIGkgPSBmYWxzZTtcXG5cXHRcXHRcXHRpZiAocy5zaG93X2F0X25vZGUgfHwgeCA9PT0gdW5kZWZpbmVkIHx8IHkgPT09IHVuZGVmaW5lZCkge1xcblxcdFxcdFxcdFxcdG8gPSBhLm9mZnNldCgpO1xcblxcdFxcdFxcdFxcdHggPSBvLmxlZnQ7XFxuXFx0XFx0XFx0XFx0eSA9IG8udG9wICsgdGhpcy5fZGF0YS5jb3JlLmxpX2hlaWdodDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKHRoaXMuc2V0dGluZ3MuY29udGV4dG1lbnUuc2VsZWN0X25vZGUgJiYgIXRoaXMuaXNfc2VsZWN0ZWQob2JqKSkge1xcblxcdFxcdFxcdFxcdHRoaXMuYWN0aXZhdGVfbm9kZShvYmosIGUpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpID0gcy5pdGVtcztcXG5cXHRcXHRcXHRpZiAoJC5pc0Z1bmN0aW9uKGkpKSB7XFxuXFx0XFx0XFx0XFx0aSA9IGkuY2FsbCh0aGlzLCBvYmosICQucHJveHkoZnVuY3Rpb24gKGkpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9zaG93X2NvbnRleHRtZW51KG9iaiwgeCwgeSwgaSk7XFxuXFx0XFx0XFx0XFx0fSwgdGhpcykpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoJC5pc1BsYWluT2JqZWN0KGkpKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5fc2hvd19jb250ZXh0bWVudShvYmosIHgsIHksIGkpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9O1xcblxcdFxcdC8qKlxcbiAgICogc2hvdyB0aGUgcHJlcGFyZWQgY29udGV4dCBtZW51IGZvciBhIG5vZGVcXG4gICAqIEBuYW1lIF9zaG93X2NvbnRleHRtZW51KG9iaiwgeCwgeSwgaSlcXG4gICAqIEBwYXJhbSB7bWl4ZWR9IG9iaiB0aGUgbm9kZVxcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHggdGhlIHgtY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgZG9jdW1lbnQgdG8gc2hvdyB0aGUgbWVudSBhdFxcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHkgdGhlIHktY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgZG9jdW1lbnQgdG8gc2hvdyB0aGUgbWVudSBhdFxcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGkgdGhlIG9iamVjdCBvZiBpdGVtcyB0byBzaG93XFxuICAgKiBAcGx1Z2luIGNvbnRleHRtZW51XFxuICAgKiBAdHJpZ2dlciBzaG93X2NvbnRleHRtZW51LmpzdHJlZVxcbiAgICogQHByaXZhdGVcXG4gICAqL1xcblxcdFxcdHRoaXMuX3Nob3dfY29udGV4dG1lbnUgPSBmdW5jdGlvbiAob2JqLCB4LCB5LCBpKSB7XFxuXFx0XFx0XFx0dmFyIGQgPSB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSksXFxuXFx0XFx0XFx0ICAgIGEgPSBkLmNoaWxkcmVuKFxcXCIuanN0cmVlLWFuY2hvclxcXCIpO1xcblxcdFxcdFxcdCQoZG9jdW1lbnQpLm9uZShcXFwiY29udGV4dF9zaG93LnZha2F0YS5qc3RyZWVcXFwiLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XFxuXFx0XFx0XFx0XFx0dmFyIGNscyA9ICdqc3RyZWUtY29udGV4dG1lbnUganN0cmVlLScgKyB0aGlzLmdldF90aGVtZSgpICsgJy1jb250ZXh0bWVudSc7XFxuXFx0XFx0XFx0XFx0JChkYXRhLmVsZW1lbnQpLmFkZENsYXNzKGNscyk7XFxuXFx0XFx0XFx0XFx0YS5hZGRDbGFzcygnanN0cmVlLWNvbnRleHQnKTtcXG5cXHRcXHRcXHR9LCB0aGlzKSk7XFxuXFx0XFx0XFx0dGhpcy5fZGF0YS5jb250ZXh0bWVudS52aXNpYmxlID0gdHJ1ZTtcXG5cXHRcXHRcXHQkLnZha2F0YS5jb250ZXh0LnNob3coYSwgeyAneCc6IHgsICd5JzogeSB9LCBpKTtcXG5cXHRcXHRcXHQvKipcXG4gICAgKiB0cmlnZ2VyZWQgd2hlbiB0aGUgY29udGV4dG1lbnUgaXMgc2hvd24gZm9yIGEgbm9kZVxcbiAgICAqIEBldmVudFxcbiAgICAqIEBuYW1lIHNob3dfY29udGV4dG1lbnUuanN0cmVlXFxuICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGUgdGhlIG5vZGVcXG4gICAgKiBAcGFyYW0ge051bWJlcn0geCB0aGUgeC1jb29yZGluYXRlIG9mIHRoZSBtZW51IHJlbGF0aXZlIHRvIHRoZSBkb2N1bWVudFxcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IHRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIG1lbnUgcmVsYXRpdmUgdG8gdGhlIGRvY3VtZW50XFxuICAgICogQHBsdWdpbiBjb250ZXh0bWVudVxcbiAgICAqL1xcblxcdFxcdFxcdHRoaXMudHJpZ2dlcignc2hvd19jb250ZXh0bWVudScsIHsgXFxcIm5vZGVcXFwiOiBvYmosIFxcXCJ4XFxcIjogeCwgXFxcInlcXFwiOiB5IH0pO1xcblxcdFxcdH07XFxuXFx0fTtcXG5cXG5cXHQvLyBjb250ZXh0bWVudSBoZWxwZXJcXG5cXHQoZnVuY3Rpb24gKCQpIHtcXG5cXHRcXHR2YXIgcmlnaHRfdG9fbGVmdCA9IGZhbHNlLFxcblxcdFxcdCAgICB2YWthdGFfY29udGV4dCA9IHtcXG5cXHRcXHRcXHRlbGVtZW50OiBmYWxzZSxcXG5cXHRcXHRcXHRyZWZlcmVuY2U6IGZhbHNlLFxcblxcdFxcdFxcdHBvc2l0aW9uX3g6IDAsXFxuXFx0XFx0XFx0cG9zaXRpb25feTogMCxcXG5cXHRcXHRcXHRpdGVtczogW10sXFxuXFx0XFx0XFx0aHRtbDogXFxcIlxcXCIsXFxuXFx0XFx0XFx0aXNfdmlzaWJsZTogZmFsc2VcXG5cXHRcXHR9O1xcblxcblxcdFxcdCQudmFrYXRhLmNvbnRleHQgPSB7XFxuXFx0XFx0XFx0c2V0dGluZ3M6IHtcXG5cXHRcXHRcXHRcXHRoaWRlX29ubW91c2VsZWF2ZTogMCxcXG5cXHRcXHRcXHRcXHRpY29uczogdHJ1ZVxcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0X3RyaWdnZXI6IGZ1bmN0aW9uIF90cmlnZ2VyKGV2ZW50X25hbWUpIHtcXG5cXHRcXHRcXHRcXHQkKGRvY3VtZW50KS50cmlnZ2VySGFuZGxlcihcXFwiY29udGV4dF9cXFwiICsgZXZlbnRfbmFtZSArIFxcXCIudmFrYXRhXFxcIiwge1xcblxcdFxcdFxcdFxcdFxcdFxcXCJyZWZlcmVuY2VcXFwiOiB2YWthdGFfY29udGV4dC5yZWZlcmVuY2UsXFxuXFx0XFx0XFx0XFx0XFx0XFxcImVsZW1lbnRcXFwiOiB2YWthdGFfY29udGV4dC5lbGVtZW50LFxcblxcdFxcdFxcdFxcdFxcdFxcXCJwb3NpdGlvblxcXCI6IHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXFwieFxcXCI6IHZha2F0YV9jb250ZXh0LnBvc2l0aW9uX3gsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFxcInlcXFwiOiB2YWthdGFfY29udGV4dC5wb3NpdGlvbl95XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0X2V4ZWN1dGU6IGZ1bmN0aW9uIF9leGVjdXRlKGkpIHtcXG5cXHRcXHRcXHRcXHRpID0gdmFrYXRhX2NvbnRleHQuaXRlbXNbaV07XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGkgJiYgKCFpLl9kaXNhYmxlZCB8fCAkLmlzRnVuY3Rpb24oaS5fZGlzYWJsZWQpICYmICFpLl9kaXNhYmxlZCh7IFxcXCJpdGVtXFxcIjogaSwgXFxcInJlZmVyZW5jZVxcXCI6IHZha2F0YV9jb250ZXh0LnJlZmVyZW5jZSwgXFxcImVsZW1lbnRcXFwiOiB2YWthdGFfY29udGV4dC5lbGVtZW50IH0pKSAmJiBpLmFjdGlvbiA/IGkuYWN0aW9uLmNhbGwobnVsbCwge1xcblxcdFxcdFxcdFxcdFxcdFxcXCJpdGVtXFxcIjogaSxcXG5cXHRcXHRcXHRcXHRcXHRcXFwicmVmZXJlbmNlXFxcIjogdmFrYXRhX2NvbnRleHQucmVmZXJlbmNlLFxcblxcdFxcdFxcdFxcdFxcdFxcXCJlbGVtZW50XFxcIjogdmFrYXRhX2NvbnRleHQuZWxlbWVudCxcXG5cXHRcXHRcXHRcXHRcXHRcXFwicG9zaXRpb25cXFwiOiB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFxcInhcXFwiOiB2YWthdGFfY29udGV4dC5wb3NpdGlvbl94LFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcXCJ5XFxcIjogdmFrYXRhX2NvbnRleHQucG9zaXRpb25feVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9KSA6IGZhbHNlO1xcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0X3BhcnNlOiBmdW5jdGlvbiBfcGFyc2UobywgaXNfY2FsbGJhY2spIHtcXG5cXHRcXHRcXHRcXHRpZiAoIW8pIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGlmICghaXNfY2FsbGJhY2spIHtcXG5cXHRcXHRcXHRcXHRcXHR2YWthdGFfY29udGV4dC5odG1sID0gXFxcIlxcXCI7XFxuXFx0XFx0XFx0XFx0XFx0dmFrYXRhX2NvbnRleHQuaXRlbXMgPSBbXTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0dmFyIHN0ciA9IFxcXCJcXFwiLFxcblxcdFxcdFxcdFxcdCAgICBzZXAgPSBmYWxzZSxcXG5cXHRcXHRcXHRcXHQgICAgdG1wO1xcblxcblxcdFxcdFxcdFxcdGlmIChpc19jYWxsYmFjaykge1xcblxcdFxcdFxcdFxcdFxcdHN0ciArPSBcXFwiPFxcXCIgKyBcXFwidWw+XFxcIjtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0JC5lYWNoKG8sIGZ1bmN0aW9uIChpLCB2YWwpIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIXZhbCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR2YWthdGFfY29udGV4dC5pdGVtcy5wdXNoKHZhbCk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCFzZXAgJiYgdmFsLnNlcGFyYXRvcl9iZWZvcmUpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzdHIgKz0gXFxcIjxcXFwiICsgXFxcImxpIGNsYXNzPSd2YWthdGEtY29udGV4dC1zZXBhcmF0b3InPjxcXFwiICsgXFxcImEgaHJlZj0nIycgXFxcIiArICgkLnZha2F0YS5jb250ZXh0LnNldHRpbmdzLmljb25zID8gJycgOiAnc3R5bGU9XFxcIm1hcmdpbi1sZWZ0OjBweDtcXFwiJykgKyBcXFwiPiYjMTYwOzxcXFwiICsgXFxcIi9hPjxcXFwiICsgXFxcIi9saT5cXFwiO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRzZXAgPSBmYWxzZTtcXG5cXHRcXHRcXHRcXHRcXHRzdHIgKz0gXFxcIjxcXFwiICsgXFxcImxpIGNsYXNzPSdcXFwiICsgKHZhbC5fY2xhc3MgfHwgXFxcIlxcXCIpICsgKHZhbC5fZGlzYWJsZWQgPT09IHRydWUgfHwgJC5pc0Z1bmN0aW9uKHZhbC5fZGlzYWJsZWQpICYmIHZhbC5fZGlzYWJsZWQoeyBcXFwiaXRlbVxcXCI6IHZhbCwgXFxcInJlZmVyZW5jZVxcXCI6IHZha2F0YV9jb250ZXh0LnJlZmVyZW5jZSwgXFxcImVsZW1lbnRcXFwiOiB2YWthdGFfY29udGV4dC5lbGVtZW50IH0pID8gXFxcIiB2YWthdGEtY29udGV4dG1lbnUtZGlzYWJsZWQgXFxcIiA6IFxcXCJcXFwiKSArIFxcXCInIFxcXCIgKyAodmFsLnNob3J0Y3V0ID8gXFxcIiBkYXRhLXNob3J0Y3V0PSdcXFwiICsgdmFsLnNob3J0Y3V0ICsgXFxcIicgXFxcIiA6ICcnKSArIFxcXCI+XFxcIjtcXG5cXHRcXHRcXHRcXHRcXHRzdHIgKz0gXFxcIjxcXFwiICsgXFxcImEgaHJlZj0nIycgcmVsPSdcXFwiICsgKHZha2F0YV9jb250ZXh0Lml0ZW1zLmxlbmd0aCAtIDEpICsgXFxcIicgXFxcIiArICh2YWwudGl0bGUgPyBcXFwidGl0bGU9J1xcXCIgKyB2YWwudGl0bGUgKyBcXFwiJ1xcXCIgOiBcXFwiXFxcIikgKyBcXFwiPlxcXCI7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCQudmFrYXRhLmNvbnRleHQuc2V0dGluZ3MuaWNvbnMpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzdHIgKz0gXFxcIjxcXFwiICsgXFxcImkgXFxcIjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAodmFsLmljb24pIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAodmFsLmljb24uaW5kZXhPZihcXFwiL1xcXCIpICE9PSAtMSB8fCB2YWwuaWNvbi5pbmRleE9mKFxcXCIuXFxcIikgIT09IC0xKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0c3RyICs9IFxcXCIgc3R5bGU9J2JhY2tncm91bmQ6dXJsKFxcXFxcXFwiXFxcIiArIHZhbC5pY29uICsgXFxcIlxcXFxcXFwiKSBjZW50ZXIgY2VudGVyIG5vLXJlcGVhdCcgXFxcIjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHN0ciArPSBcXFwiIGNsYXNzPSdcXFwiICsgdmFsLmljb24gKyBcXFwiJyBcXFwiO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0c3RyICs9IFxcXCI+PFxcXCIgKyBcXFwiL2k+PFxcXCIgKyBcXFwic3BhbiBjbGFzcz0ndmFrYXRhLWNvbnRleHRtZW51LXNlcCc+JiMxNjA7PFxcXCIgKyBcXFwiL3NwYW4+XFxcIjtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0c3RyICs9ICgkLmlzRnVuY3Rpb24odmFsLmxhYmVsKSA/IHZhbC5sYWJlbCh7IFxcXCJpdGVtXFxcIjogaSwgXFxcInJlZmVyZW5jZVxcXCI6IHZha2F0YV9jb250ZXh0LnJlZmVyZW5jZSwgXFxcImVsZW1lbnRcXFwiOiB2YWthdGFfY29udGV4dC5lbGVtZW50IH0pIDogdmFsLmxhYmVsKSArICh2YWwuc2hvcnRjdXQgPyAnIDxzcGFuIGNsYXNzPVxcXCJ2YWthdGEtY29udGV4dG1lbnUtc2hvcnRjdXQgdmFrYXRhLWNvbnRleHRtZW51LXNob3J0Y3V0LScgKyB2YWwuc2hvcnRjdXQgKyAnXFxcIj4nICsgKHZhbC5zaG9ydGN1dF9sYWJlbCB8fCAnJykgKyAnPC9zcGFuPicgOiAnJykgKyBcXFwiPFxcXCIgKyBcXFwiL2E+XFxcIjtcXG5cXHRcXHRcXHRcXHRcXHRpZiAodmFsLnN1Ym1lbnUpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0bXAgPSAkLnZha2F0YS5jb250ZXh0Ll9wYXJzZSh2YWwuc3VibWVudSwgdHJ1ZSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKHRtcCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHN0ciArPSB0bXA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRzdHIgKz0gXFxcIjxcXFwiICsgXFxcIi9saT5cXFwiO1xcblxcdFxcdFxcdFxcdFxcdGlmICh2YWwuc2VwYXJhdG9yX2FmdGVyKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0c3RyICs9IFxcXCI8XFxcIiArIFxcXCJsaSBjbGFzcz0ndmFrYXRhLWNvbnRleHQtc2VwYXJhdG9yJz48XFxcIiArIFxcXCJhIGhyZWY9JyMnIFxcXCIgKyAoJC52YWthdGEuY29udGV4dC5zZXR0aW5ncy5pY29ucyA/ICcnIDogJ3N0eWxlPVxcXCJtYXJnaW4tbGVmdDowcHg7XFxcIicpICsgXFxcIj4mIzE2MDs8XFxcIiArIFxcXCIvYT48XFxcIiArIFxcXCIvbGk+XFxcIjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzZXAgPSB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcXHRzdHIgPSBzdHIucmVwbGFjZSgvPGxpIGNsYXNzXFxcXD0ndmFrYXRhLWNvbnRleHQtc2VwYXJhdG9yJ1xcXFw+PFxcXFwvbGlcXFxcPiQvLCBcXFwiXFxcIik7XFxuXFx0XFx0XFx0XFx0aWYgKGlzX2NhbGxiYWNrKSB7XFxuXFx0XFx0XFx0XFx0XFx0c3RyICs9IFxcXCI8L3VsPlxcXCI7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdC8qKlxcbiAgICAgKiB0cmlnZ2VyZWQgb24gdGhlIGRvY3VtZW50IHdoZW4gdGhlIGNvbnRleHRtZW51IGlzIHBhcnNlZCAoSFRNTCBpcyBidWlsdClcXG4gICAgICogQGV2ZW50XFxuICAgICAqIEBwbHVnaW4gY29udGV4dG1lbnVcXG4gICAgICogQG5hbWUgY29udGV4dF9wYXJzZS52YWthdGFcXG4gICAgICogQHBhcmFtIHtqUXVlcnl9IHJlZmVyZW5jZSB0aGUgZWxlbWVudCB0aGF0IHdhcyByaWdodCBjbGlja2VkXFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IHRoZSBET00gZWxlbWVudCBvZiB0aGUgbWVudSBpdHNlbGZcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvc2l0aW9uIHRoZSB4ICYgeSBjb29yZGluYXRlcyBvZiB0aGUgbWVudVxcbiAgICAgKi9cXG5cXHRcXHRcXHRcXHRpZiAoIWlzX2NhbGxiYWNrKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFrYXRhX2NvbnRleHQuaHRtbCA9IHN0cjskLnZha2F0YS5jb250ZXh0Ll90cmlnZ2VyKFxcXCJwYXJzZVxcXCIpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRyZXR1cm4gc3RyLmxlbmd0aCA+IDEwID8gc3RyIDogZmFsc2U7XFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRfc2hvd19zdWJtZW51OiBmdW5jdGlvbiBfc2hvd19zdWJtZW51KG8pIHtcXG5cXHRcXHRcXHRcXHRvID0gJChvKTtcXG5cXHRcXHRcXHRcXHRpZiAoIW8ubGVuZ3RoIHx8ICFvLmNoaWxkcmVuKFxcXCJ1bFxcXCIpLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0dmFyIGUgPSBvLmNoaWxkcmVuKFxcXCJ1bFxcXCIpLFxcblxcdFxcdFxcdFxcdCAgICB4bCA9IG8ub2Zmc2V0KCkubGVmdCxcXG5cXHRcXHRcXHRcXHQgICAgeCA9IHhsICsgby5vdXRlcldpZHRoKCksXFxuXFx0XFx0XFx0XFx0ICAgIHkgPSBvLm9mZnNldCgpLnRvcCxcXG5cXHRcXHRcXHRcXHQgICAgdyA9IGUud2lkdGgoKSxcXG5cXHRcXHRcXHRcXHQgICAgaCA9IGUuaGVpZ2h0KCksXFxuXFx0XFx0XFx0XFx0ICAgIGR3ID0gJCh3aW5kb3cpLndpZHRoKCkgKyAkKHdpbmRvdykuc2Nyb2xsTGVmdCgpLFxcblxcdFxcdFxcdFxcdCAgICBkaCA9ICQod2luZG93KS5oZWlnaHQoKSArICQod2luZG93KS5zY3JvbGxUb3AoKTtcXG5cXHRcXHRcXHRcXHQvLyDQvNC+0LbQtSDQtNCwINGB0LUg0YHQv9C10YHRgtC4INC1INC10LTQvdCwINC/0YDQvtCy0LXRgNC60LAgLSDQtNCw0LvQuCDQvdGP0LzQsCDQvdGP0LrQvtC5INC+0YIg0LrQu9Cw0YHQvtCy0LXRgtC1INCy0LXRh9C1INC90LDQs9C+0YDQtVxcblxcdFxcdFxcdFxcdGlmIChyaWdodF90b19sZWZ0KSB7XFxuXFx0XFx0XFx0XFx0XFx0b1t4IC0gKHcgKyAxMCArIG8ub3V0ZXJXaWR0aCgpKSA8IDAgPyBcXFwiYWRkQ2xhc3NcXFwiIDogXFxcInJlbW92ZUNsYXNzXFxcIl0oXFxcInZha2F0YS1jb250ZXh0LWxlZnRcXFwiKTtcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdG9beCArIHcgPiBkdyAmJiB4bCA+IGR3IC0geCA/IFxcXCJhZGRDbGFzc1xcXCIgOiBcXFwicmVtb3ZlQ2xhc3NcXFwiXShcXFwidmFrYXRhLWNvbnRleHQtcmlnaHRcXFwiKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aWYgKHkgKyBoICsgMTAgPiBkaCkge1xcblxcdFxcdFxcdFxcdFxcdGUuY3NzKFxcXCJib3R0b21cXFwiLCBcXFwiLTFweFxcXCIpO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvL2lmIGRvZXMgbm90IGZpdCAtIHN0aWNrIGl0IHRvIHRoZSBzaWRlXFxuXFx0XFx0XFx0XFx0aWYgKG8uaGFzQ2xhc3MoJ3Zha2F0YS1jb250ZXh0LXJpZ2h0JykpIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoeGwgPCB3KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZS5jc3MoXFxcIm1hcmdpbi1yaWdodFxcXCIsIHhsIC0gdyk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGR3IC0geCA8IHcpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRlLmNzcyhcXFwibWFyZ2luLWxlZnRcXFwiLCBkdyAtIHggLSB3KTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGUuc2hvdygpO1xcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0c2hvdzogZnVuY3Rpb24gc2hvdyhyZWZlcmVuY2UsIHBvc2l0aW9uLCBkYXRhKSB7XFxuXFx0XFx0XFx0XFx0dmFyIG8sXFxuXFx0XFx0XFx0XFx0ICAgIGUsXFxuXFx0XFx0XFx0XFx0ICAgIHgsXFxuXFx0XFx0XFx0XFx0ICAgIHksXFxuXFx0XFx0XFx0XFx0ICAgIHcsXFxuXFx0XFx0XFx0XFx0ICAgIGgsXFxuXFx0XFx0XFx0XFx0ICAgIGR3LFxcblxcdFxcdFxcdFxcdCAgICBkaCxcXG5cXHRcXHRcXHRcXHQgICAgY29uZCA9IHRydWU7XFxuXFx0XFx0XFx0XFx0aWYgKHZha2F0YV9jb250ZXh0LmVsZW1lbnQgJiYgdmFrYXRhX2NvbnRleHQuZWxlbWVudC5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRcXHR2YWthdGFfY29udGV4dC5lbGVtZW50LndpZHRoKCcnKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0c3dpdGNoIChjb25kKSB7XFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAhcG9zaXRpb24gJiYgIXJlZmVyZW5jZTpcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAhIXBvc2l0aW9uICYmICEhcmVmZXJlbmNlOlxcblxcdFxcdFxcdFxcdFxcdFxcdHZha2F0YV9jb250ZXh0LnJlZmVyZW5jZSA9IHJlZmVyZW5jZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YWthdGFfY29udGV4dC5wb3NpdGlvbl94ID0gcG9zaXRpb24ueDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YWthdGFfY29udGV4dC5wb3NpdGlvbl95ID0gcG9zaXRpb24ueTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRjYXNlICFwb3NpdGlvbiAmJiAhIXJlZmVyZW5jZTpcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YWthdGFfY29udGV4dC5yZWZlcmVuY2UgPSByZWZlcmVuY2U7XFxuXFx0XFx0XFx0XFx0XFx0XFx0byA9IHJlZmVyZW5jZS5vZmZzZXQoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YWthdGFfY29udGV4dC5wb3NpdGlvbl94ID0gby5sZWZ0ICsgcmVmZXJlbmNlLm91dGVySGVpZ2h0KCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFrYXRhX2NvbnRleHQucG9zaXRpb25feSA9IG8udG9wO1xcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdGNhc2UgISFwb3NpdGlvbiAmJiAhcmVmZXJlbmNlOlxcblxcdFxcdFxcdFxcdFxcdFxcdHZha2F0YV9jb250ZXh0LnBvc2l0aW9uX3ggPSBwb3NpdGlvbi54O1xcblxcdFxcdFxcdFxcdFxcdFxcdHZha2F0YV9jb250ZXh0LnBvc2l0aW9uX3kgPSBwb3NpdGlvbi55O1xcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRpZiAoISFyZWZlcmVuY2UgJiYgIWRhdGEgJiYgJChyZWZlcmVuY2UpLmRhdGEoJ3Zha2F0YV9jb250ZXh0bWVudScpKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZGF0YSA9ICQocmVmZXJlbmNlKS5kYXRhKCd2YWthdGFfY29udGV4dG1lbnUnKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aWYgKCQudmFrYXRhLmNvbnRleHQuX3BhcnNlKGRhdGEpKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFrYXRhX2NvbnRleHQuZWxlbWVudC5odG1sKHZha2F0YV9jb250ZXh0Lmh0bWwpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRpZiAodmFrYXRhX2NvbnRleHQuaXRlbXMubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFrYXRhX2NvbnRleHQuZWxlbWVudC5hcHBlbmRUbyhcXFwiYm9keVxcXCIpO1xcblxcdFxcdFxcdFxcdFxcdGUgPSB2YWthdGFfY29udGV4dC5lbGVtZW50O1xcblxcdFxcdFxcdFxcdFxcdHggPSB2YWthdGFfY29udGV4dC5wb3NpdGlvbl94O1xcblxcdFxcdFxcdFxcdFxcdHkgPSB2YWthdGFfY29udGV4dC5wb3NpdGlvbl95O1xcblxcdFxcdFxcdFxcdFxcdHcgPSBlLndpZHRoKCk7XFxuXFx0XFx0XFx0XFx0XFx0aCA9IGUuaGVpZ2h0KCk7XFxuXFx0XFx0XFx0XFx0XFx0ZHcgPSAkKHdpbmRvdykud2lkdGgoKSArICQod2luZG93KS5zY3JvbGxMZWZ0KCk7XFxuXFx0XFx0XFx0XFx0XFx0ZGggPSAkKHdpbmRvdykuaGVpZ2h0KCkgKyAkKHdpbmRvdykuc2Nyb2xsVG9wKCk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHJpZ2h0X3RvX2xlZnQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR4IC09IGUub3V0ZXJXaWR0aCgpIC0gJChyZWZlcmVuY2UpLm91dGVyV2lkdGgoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoeCA8ICQod2luZG93KS5zY3JvbGxMZWZ0KCkgKyAyMCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHggPSAkKHdpbmRvdykuc2Nyb2xsTGVmdCgpICsgMjA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRpZiAoeCArIHcgKyAyMCA+IGR3KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0eCA9IGR3IC0gKHcgKyAyMCk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmICh5ICsgaCArIDIwID4gZGgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR5ID0gZGggLSAoaCArIDIwKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFrYXRhX2NvbnRleHQuZWxlbWVudC5jc3MoeyBcXFwibGVmdFxcXCI6IHgsIFxcXCJ0b3BcXFwiOiB5IH0pLnNob3coKS5maW5kKCdhJykuZmlyc3QoKS5mb2N1cygpLnBhcmVudCgpLmFkZENsYXNzKFxcXCJ2YWthdGEtY29udGV4dC1ob3ZlclxcXCIpO1xcblxcdFxcdFxcdFxcdFxcdHZha2F0YV9jb250ZXh0LmlzX3Zpc2libGUgPSB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdC8qKlxcbiAgICAgICogdHJpZ2dlcmVkIG9uIHRoZSBkb2N1bWVudCB3aGVuIHRoZSBjb250ZXh0bWVudSBpcyBzaG93blxcbiAgICAgICogQGV2ZW50XFxuICAgICAgKiBAcGx1Z2luIGNvbnRleHRtZW51XFxuICAgICAgKiBAbmFtZSBjb250ZXh0X3Nob3cudmFrYXRhXFxuICAgICAgKiBAcGFyYW0ge2pRdWVyeX0gcmVmZXJlbmNlIHRoZSBlbGVtZW50IHRoYXQgd2FzIHJpZ2h0IGNsaWNrZWRcXG4gICAgICAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IHRoZSBET00gZWxlbWVudCBvZiB0aGUgbWVudSBpdHNlbGZcXG4gICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb3NpdGlvbiB0aGUgeCAmIHkgY29vcmRpbmF0ZXMgb2YgdGhlIG1lbnVcXG4gICAgICAqL1xcblxcdFxcdFxcdFxcdFxcdCQudmFrYXRhLmNvbnRleHQuX3RyaWdnZXIoXFxcInNob3dcXFwiKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRoaWRlOiBmdW5jdGlvbiBoaWRlKCkge1xcblxcdFxcdFxcdFxcdGlmICh2YWthdGFfY29udGV4dC5pc192aXNpYmxlKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFrYXRhX2NvbnRleHQuZWxlbWVudC5oaWRlKCkuZmluZChcXFwidWxcXFwiKS5oaWRlKCkuZW5kKCkuZmluZCgnOmZvY3VzJykuYmx1cigpLmVuZCgpLmRldGFjaCgpO1xcblxcdFxcdFxcdFxcdFxcdHZha2F0YV9jb250ZXh0LmlzX3Zpc2libGUgPSBmYWxzZTtcXG5cXHRcXHRcXHRcXHRcXHQvKipcXG4gICAgICAqIHRyaWdnZXJlZCBvbiB0aGUgZG9jdW1lbnQgd2hlbiB0aGUgY29udGV4dG1lbnUgaXMgaGlkZGVuXFxuICAgICAgKiBAZXZlbnRcXG4gICAgICAqIEBwbHVnaW4gY29udGV4dG1lbnVcXG4gICAgICAqIEBuYW1lIGNvbnRleHRfaGlkZS52YWthdGFcXG4gICAgICAqIEBwYXJhbSB7alF1ZXJ5fSByZWZlcmVuY2UgdGhlIGVsZW1lbnQgdGhhdCB3YXMgcmlnaHQgY2xpY2tlZFxcbiAgICAgICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgdGhlIERPTSBlbGVtZW50IG9mIHRoZSBtZW51IGl0c2VsZlxcbiAgICAgICogQHBhcmFtIHtPYmplY3R9IHBvc2l0aW9uIHRoZSB4ICYgeSBjb29yZGluYXRlcyBvZiB0aGUgbWVudVxcbiAgICAgICovXFxuXFx0XFx0XFx0XFx0XFx0JC52YWthdGEuY29udGV4dC5fdHJpZ2dlcihcXFwiaGlkZVxcXCIpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fTtcXG5cXHRcXHQkKGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRyaWdodF90b19sZWZ0ID0gJChcXFwiYm9keVxcXCIpLmNzcyhcXFwiZGlyZWN0aW9uXFxcIikgPT09IFxcXCJydGxcXFwiO1xcblxcdFxcdFxcdHZhciB0byA9IGZhbHNlO1xcblxcblxcdFxcdFxcdHZha2F0YV9jb250ZXh0LmVsZW1lbnQgPSAkKFxcXCI8dWwgY2xhc3M9J3Zha2F0YS1jb250ZXh0Jz48L3VsPlxcXCIpO1xcblxcdFxcdFxcdHZha2F0YV9jb250ZXh0LmVsZW1lbnQub24oXFxcIm1vdXNlZW50ZXJcXFwiLCBcXFwibGlcXFwiLCBmdW5jdGlvbiAoZSkge1xcblxcdFxcdFxcdFxcdGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCQuY29udGFpbnModGhpcywgZS5yZWxhdGVkVGFyZ2V0KSkge1xcblxcdFxcdFxcdFxcdFxcdC8vINC/0YDQtdC80LDRhdC90LDRgtC+INC30LDRgNCw0LTQuCBkZWxlZ2F0ZSBtb3VzZWxlYXZlINC/0L4t0LTQvtC70YNcXG5cXHRcXHRcXHRcXHRcXHQvLyAkKHRoaXMpLmZpbmQoXFxcIi52YWthdGEtY29udGV4dC1ob3ZlclxcXCIpLnJlbW92ZUNsYXNzKFxcXCJ2YWthdGEtY29udGV4dC1ob3ZlclxcXCIpO1xcblxcdFxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKHRvKSB7XFxuXFx0XFx0XFx0XFx0XFx0Y2xlYXJUaW1lb3V0KHRvKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0dmFrYXRhX2NvbnRleHQuZWxlbWVudC5maW5kKFxcXCIudmFrYXRhLWNvbnRleHQtaG92ZXJcXFwiKS5yZW1vdmVDbGFzcyhcXFwidmFrYXRhLWNvbnRleHQtaG92ZXJcXFwiKS5lbmQoKTtcXG5cXG5cXHRcXHRcXHRcXHQkKHRoaXMpLnNpYmxpbmdzKCkuZmluZChcXFwidWxcXFwiKS5oaWRlKCkuZW5kKCkuZW5kKCkucGFyZW50c1VudGlsKFxcXCIudmFrYXRhLWNvbnRleHRcXFwiLCBcXFwibGlcXFwiKS5hZGRCYWNrKCkuYWRkQ2xhc3MoXFxcInZha2F0YS1jb250ZXh0LWhvdmVyXFxcIik7XFxuXFx0XFx0XFx0XFx0JC52YWthdGEuY29udGV4dC5fc2hvd19zdWJtZW51KHRoaXMpO1xcblxcdFxcdFxcdH0pXFxuXFx0XFx0XFx0Ly8g0YLQtdGB0YLQvtCy0L4gLSDQtNCw0LvQuCDQvdC1INC90LDRgtC+0LLQsNGA0LLQsD9cXG5cXHRcXHRcXHQub24oXFxcIm1vdXNlbGVhdmVcXFwiLCBcXFwibGlcXFwiLCBmdW5jdGlvbiAoZSkge1xcblxcdFxcdFxcdFxcdGlmICgkLmNvbnRhaW5zKHRoaXMsIGUucmVsYXRlZFRhcmdldCkpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdCQodGhpcykuZmluZChcXFwiLnZha2F0YS1jb250ZXh0LWhvdmVyXFxcIikuYWRkQmFjaygpLnJlbW92ZUNsYXNzKFxcXCJ2YWthdGEtY29udGV4dC1ob3ZlclxcXCIpO1xcblxcdFxcdFxcdH0pLm9uKFxcXCJtb3VzZWxlYXZlXFxcIiwgZnVuY3Rpb24gKGUpIHtcXG5cXHRcXHRcXHRcXHQkKHRoaXMpLmZpbmQoXFxcIi52YWthdGEtY29udGV4dC1ob3ZlclxcXCIpLnJlbW92ZUNsYXNzKFxcXCJ2YWthdGEtY29udGV4dC1ob3ZlclxcXCIpO1xcblxcdFxcdFxcdFxcdGlmICgkLnZha2F0YS5jb250ZXh0LnNldHRpbmdzLmhpZGVfb25tb3VzZWxlYXZlKSB7XFxuXFx0XFx0XFx0XFx0XFx0dG8gPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICh0KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQkLnZha2F0YS5jb250ZXh0LmhpZGUoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdFxcdFxcdH0odGhpcyksICQudmFrYXRhLmNvbnRleHQuc2V0dGluZ3MuaGlkZV9vbm1vdXNlbGVhdmUpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9KS5vbihcXFwiY2xpY2tcXFwiLCBcXFwiYVxcXCIsIGZ1bmN0aW9uIChlKSB7XFxuXFx0XFx0XFx0XFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdFxcdFxcdFxcdC8vfSlcXG5cXHRcXHRcXHRcXHQvLy5vbihcXFwibW91c2V1cFxcXCIsIFxcXCJhXFxcIiwgZnVuY3Rpb24gKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoISQodGhpcykuYmx1cigpLnBhcmVudCgpLmhhc0NsYXNzKFxcXCJ2YWthdGEtY29udGV4dC1kaXNhYmxlZFxcXCIpICYmICQudmFrYXRhLmNvbnRleHQuX2V4ZWN1dGUoJCh0aGlzKS5hdHRyKFxcXCJyZWxcXFwiKSkgIT09IGZhbHNlKSB7XFxuXFx0XFx0XFx0XFx0XFx0JC52YWthdGEuY29udGV4dC5oaWRlKCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0pLm9uKCdrZXlkb3duJywgJ2EnLCBmdW5jdGlvbiAoZSkge1xcblxcdFxcdFxcdFxcdHZhciBvID0gbnVsbDtcXG5cXHRcXHRcXHRcXHRzd2l0Y2ggKGUud2hpY2gpIHtcXG5cXHRcXHRcXHRcXHRcXHRjYXNlIDEzOlxcblxcdFxcdFxcdFxcdFxcdGNhc2UgMzI6XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZS50eXBlID0gXFxcImNsaWNrXFxcIjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRlLnByZXZlbnREZWZhdWx0KCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0JChlLmN1cnJlbnRUYXJnZXQpLnRyaWdnZXIoZSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAzNzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAodmFrYXRhX2NvbnRleHQuaXNfdmlzaWJsZSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZha2F0YV9jb250ZXh0LmVsZW1lbnQuZmluZChcXFwiLnZha2F0YS1jb250ZXh0LWhvdmVyXFxcIikubGFzdCgpLmNsb3Nlc3QoXFxcImxpXFxcIikuZmlyc3QoKS5maW5kKFxcXCJ1bFxcXCIpLmhpZGUoKS5maW5kKFxcXCIudmFrYXRhLWNvbnRleHQtaG92ZXJcXFwiKS5yZW1vdmVDbGFzcyhcXFwidmFrYXRhLWNvbnRleHQtaG92ZXJcXFwiKS5lbmQoKS5lbmQoKS5jaGlsZHJlbignYScpLmZvY3VzKCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRlLnByZXZlbnREZWZhdWx0KCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdGNhc2UgMzg6XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKHZha2F0YV9jb250ZXh0LmlzX3Zpc2libGUpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRvID0gdmFrYXRhX2NvbnRleHQuZWxlbWVudC5maW5kKFxcXCJ1bDp2aXNpYmxlXFxcIikuYWRkQmFjaygpLmxhc3QoKS5jaGlsZHJlbihcXFwiLnZha2F0YS1jb250ZXh0LWhvdmVyXFxcIikucmVtb3ZlQ2xhc3MoXFxcInZha2F0YS1jb250ZXh0LWhvdmVyXFxcIikucHJldkFsbChcXFwibGk6bm90KC52YWthdGEtY29udGV4dC1zZXBhcmF0b3IpXFxcIikuZmlyc3QoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIW8ubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0byA9IHZha2F0YV9jb250ZXh0LmVsZW1lbnQuZmluZChcXFwidWw6dmlzaWJsZVxcXCIpLmFkZEJhY2soKS5sYXN0KCkuY2hpbGRyZW4oXFxcImxpOm5vdCgudmFrYXRhLWNvbnRleHQtc2VwYXJhdG9yKVxcXCIpLmxhc3QoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0by5hZGRDbGFzcyhcXFwidmFrYXRhLWNvbnRleHQtaG92ZXJcXFwiKS5jaGlsZHJlbignYScpLmZvY3VzKCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRlLnByZXZlbnREZWZhdWx0KCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdGNhc2UgMzk6XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKHZha2F0YV9jb250ZXh0LmlzX3Zpc2libGUpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YWthdGFfY29udGV4dC5lbGVtZW50LmZpbmQoXFxcIi52YWthdGEtY29udGV4dC1ob3ZlclxcXCIpLmxhc3QoKS5jaGlsZHJlbihcXFwidWxcXFwiKS5zaG93KCkuY2hpbGRyZW4oXFxcImxpOm5vdCgudmFrYXRhLWNvbnRleHQtc2VwYXJhdG9yKVxcXCIpLnJlbW92ZUNsYXNzKFxcXCJ2YWthdGEtY29udGV4dC1ob3ZlclxcXCIpLmZpcnN0KCkuYWRkQ2xhc3MoXFxcInZha2F0YS1jb250ZXh0LWhvdmVyXFxcIikuY2hpbGRyZW4oJ2EnKS5mb2N1cygpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRjYXNlIDQwOlxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICh2YWthdGFfY29udGV4dC5pc192aXNpYmxlKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0byA9IHZha2F0YV9jb250ZXh0LmVsZW1lbnQuZmluZChcXFwidWw6dmlzaWJsZVxcXCIpLmFkZEJhY2soKS5sYXN0KCkuY2hpbGRyZW4oXFxcIi52YWthdGEtY29udGV4dC1ob3ZlclxcXCIpLnJlbW92ZUNsYXNzKFxcXCJ2YWthdGEtY29udGV4dC1ob3ZlclxcXCIpLm5leHRBbGwoXFxcImxpOm5vdCgudmFrYXRhLWNvbnRleHQtc2VwYXJhdG9yKVxcXCIpLmZpcnN0KCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCFvLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG8gPSB2YWthdGFfY29udGV4dC5lbGVtZW50LmZpbmQoXFxcInVsOnZpc2libGVcXFwiKS5hZGRCYWNrKCkubGFzdCgpLmNoaWxkcmVuKFxcXCJsaTpub3QoLnZha2F0YS1jb250ZXh0LXNlcGFyYXRvcilcXFwiKS5maXJzdCgpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRvLmFkZENsYXNzKFxcXCJ2YWthdGEtY29udGV4dC1ob3ZlclxcXCIpLmNoaWxkcmVuKCdhJykuZm9jdXMoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGUucHJldmVudERlZmF1bHQoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAyNzpcXG5cXHRcXHRcXHRcXHRcXHRcXHQkLnZha2F0YS5jb250ZXh0LmhpZGUoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRlLnByZXZlbnREZWZhdWx0KCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0ZGVmYXVsdDpcXG5cXHRcXHRcXHRcXHRcXHRcXHQvL2NvbnNvbGUubG9nKGUud2hpY2gpO1xcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9KS5vbigna2V5ZG93bicsIGZ1bmN0aW9uIChlKSB7XFxuXFx0XFx0XFx0XFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdFxcdFxcdFxcdHZhciBhID0gdmFrYXRhX2NvbnRleHQuZWxlbWVudC5maW5kKCcudmFrYXRhLWNvbnRleHRtZW51LXNob3J0Y3V0LScgKyBlLndoaWNoKS5wYXJlbnQoKTtcXG5cXHRcXHRcXHRcXHRpZiAoYS5wYXJlbnQoKS5ub3QoJy52YWthdGEtY29udGV4dC1kaXNhYmxlZCcpKSB7XFxuXFx0XFx0XFx0XFx0XFx0YS5jbGljaygpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9KTtcXG5cXG5cXHRcXHRcXHQkKGRvY3VtZW50KS5vbihcXFwibW91c2Vkb3duLnZha2F0YS5qc3RyZWVcXFwiLCBmdW5jdGlvbiAoZSkge1xcblxcdFxcdFxcdFxcdGlmICh2YWthdGFfY29udGV4dC5pc192aXNpYmxlICYmICEkLmNvbnRhaW5zKHZha2F0YV9jb250ZXh0LmVsZW1lbnRbMF0sIGUudGFyZ2V0KSkge1xcblxcdFxcdFxcdFxcdFxcdCQudmFrYXRhLmNvbnRleHQuaGlkZSgpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9KS5vbihcXFwiY29udGV4dF9zaG93LnZha2F0YS5qc3RyZWVcXFwiLCBmdW5jdGlvbiAoZSwgZGF0YSkge1xcblxcdFxcdFxcdFxcdHZha2F0YV9jb250ZXh0LmVsZW1lbnQuZmluZChcXFwibGk6aGFzKHVsKVxcXCIpLmNoaWxkcmVuKFxcXCJhXFxcIikuYWRkQ2xhc3MoXFxcInZha2F0YS1jb250ZXh0LXBhcmVudFxcXCIpO1xcblxcdFxcdFxcdFxcdGlmIChyaWdodF90b19sZWZ0KSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFrYXRhX2NvbnRleHQuZWxlbWVudC5hZGRDbGFzcyhcXFwidmFrYXRhLWNvbnRleHQtcnRsXFxcIikuY3NzKFxcXCJkaXJlY3Rpb25cXFwiLCBcXFwicnRsXFxcIik7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdC8vIGFsc28gYXBwbHkgYSBSVEwgY2xhc3M/XFxuXFx0XFx0XFx0XFx0dmFrYXRhX2NvbnRleHQuZWxlbWVudC5maW5kKFxcXCJ1bFxcXCIpLmhpZGUoKS5lbmQoKTtcXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHR9KTtcXG5cXHR9KSgkKTtcXG5cXHQvLyAkLmpzdHJlZS5kZWZhdWx0cy5wbHVnaW5zLnB1c2goXFxcImNvbnRleHRtZW51XFxcIik7XFxuXFxuXFxuXFx0LyoqXFxuICAqICMjIyBEcmFnJ24nZHJvcCBwbHVnaW5cXG4gICpcXG4gICogRW5hYmxlcyBkcmFnZ2luZyBhbmQgZHJvcHBpbmcgb2Ygbm9kZXMgaW4gdGhlIHRyZWUsIHJlc3VsdGluZyBpbiBhIG1vdmUgb3IgY29weSBvcGVyYXRpb25zLlxcbiAgKi9cXG5cXG5cXHQvKipcXG4gICogc3RvcmVzIGFsbCBkZWZhdWx0cyBmb3IgdGhlIGRyYWcnbidkcm9wIHBsdWdpblxcbiAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5kbmRcXG4gICogQHBsdWdpbiBkbmRcXG4gICovXFxuXFx0JC5qc3RyZWUuZGVmYXVsdHMuZG5kID0ge1xcblxcdFxcdC8qKlxcbiAgICogYSBib29sZWFuIGluZGljYXRpbmcgaWYgYSBjb3B5IHNob3VsZCBiZSBwb3NzaWJsZSB3aGlsZSBkcmFnZ2luZyAoYnkgcHJlc3NpbnQgdGhlIG1ldGEga2V5IG9yIEN0cmwpLiBEZWZhdWx0cyB0byBgdHJ1ZWAuXFxuICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5kbmQuY29weVxcbiAgICogQHBsdWdpbiBkbmRcXG4gICAqL1xcblxcdFxcdGNvcHk6IHRydWUsXFxuXFx0XFx0LyoqXFxuICAgKiBhIG51bWJlciBpbmRpY2F0aW5nIGhvdyBsb25nIGEgbm9kZSBzaG91bGQgcmVtYWluIGhvdmVyZWQgd2hpbGUgZHJhZ2dpbmcgdG8gYmUgb3BlbmVkLiBEZWZhdWx0cyB0byBgNTAwYC5cXG4gICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmRuZC5vcGVuX3RpbWVvdXRcXG4gICAqIEBwbHVnaW4gZG5kXFxuICAgKi9cXG5cXHRcXHRvcGVuX3RpbWVvdXQ6IDUwMCxcXG5cXHRcXHQvKipcXG4gICAqIGEgZnVuY3Rpb24gaW52b2tlZCBlYWNoIHRpbWUgYSBub2RlIGlzIGFib3V0IHRvIGJlIGRyYWdnZWQsIGludm9rZWQgaW4gdGhlIHRyZWUncyBzY29wZSBhbmQgcmVjZWl2ZXMgdGhlIG5vZGVzIGFib3V0IHRvIGJlIGRyYWdnZWQgYXMgYW4gYXJndW1lbnQgKGFycmF5KSBhbmQgdGhlIGV2ZW50IHRoYXQgc3RhcnRlZCB0aGUgZHJhZyAtIHJldHVybiBgZmFsc2VgIHRvIHByZXZlbnQgZHJhZ2dpbmdcXG4gICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmRuZC5pc19kcmFnZ2FibGVcXG4gICAqIEBwbHVnaW4gZG5kXFxuICAgKi9cXG5cXHRcXHRpc19kcmFnZ2FibGU6IHRydWUsXFxuXFx0XFx0LyoqXFxuICAgKiBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiBjaGVja3Mgc2hvdWxkIGNvbnN0YW50bHkgYmUgbWFkZSB3aGlsZSB0aGUgdXNlciBpcyBkcmFnZ2luZyB0aGUgbm9kZSAoYXMgb3Bwb3NlZCB0byBjaGVja2luZyBvbmx5IG9uIGRyb3ApLCBkZWZhdWx0IGlzIGB0cnVlYFxcbiAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuZG5kLmNoZWNrX3doaWxlX2RyYWdnaW5nXFxuICAgKiBAcGx1Z2luIGRuZFxcbiAgICovXFxuXFx0XFx0Y2hlY2tfd2hpbGVfZHJhZ2dpbmc6IHRydWUsXFxuXFx0XFx0LyoqXFxuICAgKiBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiBub2RlcyBmcm9tIHRoaXMgdHJlZSBzaG91bGQgb25seSBiZSBjb3BpZWQgd2l0aCBkbmQgKGFzIG9wcG9zZWQgdG8gbW92ZWQpLCBkZWZhdWx0IGlzIGBmYWxzZWBcXG4gICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmRuZC5hbHdheXNfY29weVxcbiAgICogQHBsdWdpbiBkbmRcXG4gICAqL1xcblxcdFxcdGFsd2F5c19jb3B5OiBmYWxzZSxcXG5cXHRcXHQvKipcXG4gICAqIHdoZW4gZHJvcHBpbmcgYSBub2RlIFxcXCJpbnNpZGVcXFwiLCB0aGlzIHNldHRpbmcgaW5kaWNhdGVzIHRoZSBwb3NpdGlvbiB0aGUgbm9kZSBzaG91bGQgZ28gdG8gLSBpdCBjYW4gYmUgYW4gaW50ZWdlciBvciBhIHN0cmluZzogXFxcImZpcnN0XFxcIiAoc2FtZSBhcyAwKSBvciBcXFwibGFzdFxcXCIsIGRlZmF1bHQgaXMgYDBgXFxuICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5kbmQuaW5zaWRlX3Bvc1xcbiAgICogQHBsdWdpbiBkbmRcXG4gICAqL1xcblxcdFxcdGluc2lkZV9wb3M6IDAsXFxuXFx0XFx0LyoqXFxuICAgKiB3aGVuIHN0YXJ0aW5nIHRoZSBkcmFnIG9uIGEgbm9kZSB0aGF0IGlzIHNlbGVjdGVkIHRoaXMgc2V0dGluZyBjb250cm9scyBpZiBhbGwgc2VsZWN0ZWQgbm9kZXMgYXJlIGRyYWdnZWQgb3Igb25seSB0aGUgc2luZ2xlIG5vZGUsIGRlZmF1bHQgaXMgYHRydWVgLCB3aGljaCBtZWFucyBhbGwgc2VsZWN0ZWQgbm9kZXMgYXJlIGRyYWdnZWQgd2hlbiB0aGUgZHJhZyBpcyBzdGFydGVkIG9uIGEgc2VsZWN0ZWQgbm9kZVxcbiAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuZG5kLmRyYWdfc2VsZWN0aW9uXFxuICAgKiBAcGx1Z2luIGRuZFxcbiAgICovXFxuXFx0XFx0ZHJhZ19zZWxlY3Rpb246IHRydWUsXFxuXFx0XFx0LyoqXFxuICAgKiBjb250cm9scyB3aGV0aGVyIGRuZCB3b3JrcyBvbiB0b3VjaCBkZXZpY2VzLiBJZiBsZWZ0IGFzIGJvb2xlYW4gdHJ1ZSBkbmQgd2lsbCB3b3JrIHRoZSBzYW1lIGFzIGluIGRlc2t0b3AgYnJvd3NlcnMsIHdoaWNoIGluIHNvbWUgY2FzZXMgbWF5IGltcGFpciBzY3JvbGxpbmcuIElmIHNldCB0byBib29sZWFuIGZhbHNlIGRuZCB3aWxsIG5vdCB3b3JrIG9uIHRvdWNoIGRldmljZXMuIFRoZXJlIGlzIGEgc3BlY2lhbCB0aGlyZCBvcHRpb24gLSBzdHJpbmcgXFxcInNlbGVjdGVkXFxcIiB3aGljaCBtZWFucyBvbmx5IHNlbGVjdGVkIG5vZGVzIGNhbiBiZSBkcmFnZ2VkIG9uIHRvdWNoIGRldmljZXMuXFxuICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5kbmQudG91Y2hcXG4gICAqIEBwbHVnaW4gZG5kXFxuICAgKi9cXG5cXHRcXHR0b3VjaDogdHJ1ZSxcXG5cXHRcXHQvKipcXG4gICAqIGNvbnRyb2xzIHdoZXRoZXIgaXRlbXMgY2FuIGJlIGRyb3BwZWQgYW55d2hlcmUgb24gdGhlIG5vZGUsIG5vdCBqdXN0IG9uIHRoZSBhbmNob3IsIGJ5IGRlZmF1bHQgb25seSB0aGUgbm9kZSBhbmNob3IgaXMgYSB2YWxpZCBkcm9wIHRhcmdldC4gV29ya3MgYmVzdCB3aXRoIHRoZSB3aG9sZXJvdyBwbHVnaW4uIElmIGVuYWJsZWQgb24gbW9iaWxlIGRlcGVuZGluZyBvbiB0aGUgaW50ZXJmYWNlIGl0IG1pZ2h0IGJlIGhhcmQgZm9yIHRoZSB1c2VyIHRvIGNhbmNlbCB0aGUgZHJvcCwgc2luY2UgdGhlIHdob2xlIHRyZWUgY29udGFpbmVyIHdpbGwgYmUgYSB2YWxpZCBkcm9wIHRhcmdldC5cXG4gICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmRuZC5sYXJnZV9kcm9wX3RhcmdldFxcbiAgICogQHBsdWdpbiBkbmRcXG4gICAqL1xcblxcdFxcdGxhcmdlX2Ryb3BfdGFyZ2V0OiBmYWxzZSxcXG5cXHRcXHQvKipcXG4gICAqIGNvbnRyb2xzIHdoZXRoZXIgYSBkcmFnIGNhbiBiZSBpbml0aWF0ZWQgZnJvbSBhbnkgcGFydCBvZiB0aGUgbm9kZSBhbmQgbm90IGp1c3QgdGhlIHRleHQvaWNvbiBwYXJ0LCB3b3JrcyBiZXN0IHdpdGggdGhlIHdob2xlcm93IHBsdWdpbi4gS2VlcCBpbiBtaW5kIGl0IGNhbiBjYXVzZSBwcm9ibGVtcyB3aXRoIHRyZWUgc2Nyb2xsaW5nIG9uIG1vYmlsZSBkZXBlbmRpbmcgb24gdGhlIGludGVyZmFjZSAtIGluIHRoYXQgY2FzZSBzZXQgdGhlIHRvdWNoIG9wdGlvbiB0byBcXFwic2VsZWN0ZWRcXFwiLlxcbiAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuZG5kLmxhcmdlX2RyYWdfdGFyZ2V0XFxuICAgKiBAcGx1Z2luIGRuZFxcbiAgICovXFxuXFx0XFx0bGFyZ2VfZHJhZ190YXJnZXQ6IGZhbHNlLFxcblxcdFxcdC8qKlxcbiAgICogY29udHJvbHMgd2hldGhlciB1c2UgSFRNTDUgZG5kIGFwaSBpbnN0ZWFkIG9mIGNsYXNzaWNhbC4gVGhhdCB3aWxsIGFsbG93IGJldHRlciBpbnRlZ3JhdGlvbiBvZiBkbmQgZXZlbnRzIHdpdGggb3RoZXIgSFRNTDUgY29udHJvbHMuXFxuICAgKiBAcmVmZXJlbmNlIGh0dHA6Ly9jYW5pdXNlLmNvbS8jZmVhdD1kcmFnbmRyb3BcXG4gICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmRuZC51c2VfaHRtbDVcXG4gICAqIEBwbHVnaW4gZG5kXFxuICAgKi9cXG5cXHRcXHR1c2VfaHRtbDU6IGZhbHNlXFxuXFx0fTtcXG5cXHR2YXIgZHJnLCBlbG07XFxuXFx0Ly8gVE9ETzogbm93IGNoZWNrIHdvcmtzIGJ5IGNoZWNraW5nIGZvciBlYWNoIG5vZGUgaW5kaXZpZHVhbGx5LCBob3cgYWJvdXQgbWF4X2NoaWxkcmVuLCB1bmlxdWUsIGV0Yz9cXG5cXHQkLmpzdHJlZS5wbHVnaW5zLmRuZCA9IGZ1bmN0aW9uIChvcHRpb25zLCBwYXJlbnQpIHtcXG5cXHRcXHR0aGlzLmluaXQgPSBmdW5jdGlvbiAoZWwsIG9wdGlvbnMpIHtcXG5cXHRcXHRcXHRwYXJlbnQuaW5pdC5jYWxsKHRoaXMsIGVsLCBvcHRpb25zKTtcXG5cXHRcXHRcXHR0aGlzLnNldHRpbmdzLmRuZC51c2VfaHRtbDUgPSB0aGlzLnNldHRpbmdzLmRuZC51c2VfaHRtbDUgJiYgJ2RyYWdnYWJsZScgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xcblxcdFxcdH07XFxuXFx0XFx0dGhpcy5iaW5kID0gZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdHBhcmVudC5iaW5kLmNhbGwodGhpcyk7XFxuXFxuXFx0XFx0XFx0dGhpcy5lbGVtZW50Lm9uKHRoaXMuc2V0dGluZ3MuZG5kLnVzZV9odG1sNSA/ICdkcmFnc3RhcnQuanN0cmVlJyA6ICdtb3VzZWRvd24uanN0cmVlIHRvdWNoc3RhcnQuanN0cmVlJywgdGhpcy5zZXR0aW5ncy5kbmQubGFyZ2VfZHJhZ190YXJnZXQgPyAnLmpzdHJlZS1ub2RlJyA6ICcuanN0cmVlLWFuY2hvcicsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAodGhpcy5zZXR0aW5ncy5kbmQubGFyZ2VfZHJhZ190YXJnZXQgJiYgJChlLnRhcmdldCkuY2xvc2VzdCgnLmpzdHJlZS1ub2RlJylbMF0gIT09IGUuY3VycmVudFRhcmdldCkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRpZiAoZS50eXBlID09PSBcXFwidG91Y2hzdGFydFxcXCIgJiYgKCF0aGlzLnNldHRpbmdzLmRuZC50b3VjaCB8fCB0aGlzLnNldHRpbmdzLmRuZC50b3VjaCA9PT0gJ3NlbGVjdGVkJyAmJiAhJChlLmN1cnJlbnRUYXJnZXQpLmNsb3Nlc3QoJy5qc3RyZWUtbm9kZScpLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLmhhc0NsYXNzKCdqc3RyZWUtY2xpY2tlZCcpKSkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR2YXIgb2JqID0gdGhpcy5nZXRfbm9kZShlLnRhcmdldCksXFxuXFx0XFx0XFx0XFx0ICAgIG1sdCA9IHRoaXMuaXNfc2VsZWN0ZWQob2JqKSAmJiB0aGlzLnNldHRpbmdzLmRuZC5kcmFnX3NlbGVjdGlvbiA/IHRoaXMuZ2V0X3RvcF9zZWxlY3RlZCgpLmxlbmd0aCA6IDEsXFxuXFx0XFx0XFx0XFx0ICAgIHR4dCA9IG1sdCA+IDEgPyBtbHQgKyAnICcgKyB0aGlzLmdldF9zdHJpbmcoJ25vZGVzJykgOiB0aGlzLmdldF90ZXh0KGUuY3VycmVudFRhcmdldCk7XFxuXFx0XFx0XFx0XFx0aWYgKHRoaXMuc2V0dGluZ3MuY29yZS5mb3JjZV90ZXh0KSB7XFxuXFx0XFx0XFx0XFx0XFx0dHh0ID0gJC52YWthdGEuaHRtbC5lc2NhcGUodHh0KTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aWYgKG9iaiAmJiBvYmouaWQgJiYgb2JqLmlkICE9PSAkLmpzdHJlZS5yb290ICYmIChlLndoaWNoID09PSAxIHx8IGUudHlwZSA9PT0gXFxcInRvdWNoc3RhcnRcXFwiIHx8IGUudHlwZSA9PT0gXFxcImRyYWdzdGFydFxcXCIpICYmICh0aGlzLnNldHRpbmdzLmRuZC5pc19kcmFnZ2FibGUgPT09IHRydWUgfHwgJC5pc0Z1bmN0aW9uKHRoaXMuc2V0dGluZ3MuZG5kLmlzX2RyYWdnYWJsZSkgJiYgdGhpcy5zZXR0aW5ncy5kbmQuaXNfZHJhZ2dhYmxlLmNhbGwodGhpcywgbWx0ID4gMSA/IHRoaXMuZ2V0X3RvcF9zZWxlY3RlZCh0cnVlKSA6IFtvYmpdLCBlKSkpIHtcXG5cXHRcXHRcXHRcXHRcXHRkcmcgPSB7ICdqc3RyZWUnOiB0cnVlLCAnb3JpZ2luJzogdGhpcywgJ29iaic6IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKSwgJ25vZGVzJzogbWx0ID4gMSA/IHRoaXMuZ2V0X3RvcF9zZWxlY3RlZCgpIDogW29iai5pZF0gfTtcXG5cXHRcXHRcXHRcXHRcXHRlbG0gPSBlLmN1cnJlbnRUYXJnZXQ7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHRoaXMuc2V0dGluZ3MuZG5kLnVzZV9odG1sNSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdCQudmFrYXRhLmRuZC5fdHJpZ2dlcignc3RhcnQnLCBlLCB7ICdoZWxwZXInOiAkKCksICdlbGVtZW50JzogZWxtLCAnZGF0YSc6IGRyZyB9KTtcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuZWxlbWVudC50cmlnZ2VyKCdtb3VzZWRvd24uanN0cmVlJyk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuICQudmFrYXRhLmRuZC5zdGFydChlLCBkcmcsICc8ZGl2IGlkPVxcXCJqc3RyZWUtZG5kXFxcIiBjbGFzcz1cXFwianN0cmVlLScgKyB0aGlzLmdldF90aGVtZSgpICsgJyBqc3RyZWUtJyArIHRoaXMuZ2V0X3RoZW1lKCkgKyAnLScgKyB0aGlzLmdldF90aGVtZV92YXJpYW50KCkgKyAnICcgKyAodGhpcy5zZXR0aW5ncy5jb3JlLnRoZW1lcy5yZXNwb25zaXZlID8gJyBqc3RyZWUtZG5kLXJlc3BvbnNpdmUnIDogJycpICsgJ1xcXCI+PGkgY2xhc3M9XFxcImpzdHJlZS1pY29uIGpzdHJlZS1lclxcXCI+PC9pPicgKyB0eHQgKyAnPGlucyBjbGFzcz1cXFwianN0cmVlLWNvcHlcXFwiIHN0eWxlPVxcXCJkaXNwbGF5Om5vbmU7XFxcIj4rPC9pbnM+PC9kaXY+Jyk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LCB0aGlzKSk7XFxuXFx0XFx0XFx0aWYgKHRoaXMuc2V0dGluZ3MuZG5kLnVzZV9odG1sNSkge1xcblxcdFxcdFxcdFxcdHRoaXMuZWxlbWVudC5vbignZHJhZ292ZXIuanN0cmVlJywgZnVuY3Rpb24gKGUpIHtcXG5cXHRcXHRcXHRcXHRcXHRlLnByZXZlbnREZWZhdWx0KCk7XFxuXFx0XFx0XFx0XFx0XFx0JC52YWthdGEuZG5kLl90cmlnZ2VyKCdtb3ZlJywgZSwgeyAnaGVscGVyJzogJCgpLCAnZWxlbWVudCc6IGVsbSwgJ2RhdGEnOiBkcmcgfSk7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdFxcdH0pXFxuXFx0XFx0XFx0XFx0Ly8ub24oJ2RyYWdlbnRlci5qc3RyZWUnLCB0aGlzLnNldHRpbmdzLmRuZC5sYXJnZV9kcm9wX3RhcmdldCA/ICcuanN0cmVlLW5vZGUnIDogJy5qc3RyZWUtYW5jaG9yJywgJC5wcm94eShmdW5jdGlvbiAoZSkge1xcblxcdFxcdFxcdFxcdC8vXFx0XFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdFxcdFxcdFxcdC8vXFx0XFx0JC52YWthdGEuZG5kLl90cmlnZ2VyKCdtb3ZlJywgZSwgeyAnaGVscGVyJzogJCgpLCAnZWxlbWVudCc6IGVsbSwgJ2RhdGEnOiBkcmcgfSk7XFxuXFx0XFx0XFx0XFx0Ly9cXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0XFx0Ly9cXHR9LCB0aGlzKSlcXG5cXHRcXHRcXHRcXHQub24oJ2Ryb3AuanN0cmVlJywgJC5wcm94eShmdW5jdGlvbiAoZSkge1xcblxcdFxcdFxcdFxcdFxcdGUucHJldmVudERlZmF1bHQoKTtcXG5cXHRcXHRcXHRcXHRcXHQkLnZha2F0YS5kbmQuX3RyaWdnZXIoJ3N0b3AnLCBlLCB7ICdoZWxwZXInOiAkKCksICdlbGVtZW50JzogZWxtLCAnZGF0YSc6IGRyZyB9KTtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0XFx0fSwgdGhpcykpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9O1xcblxcdFxcdHRoaXMucmVkcmF3X25vZGUgPSBmdW5jdGlvbiAob2JqLCBkZWVwLCBjYWxsYmFjaywgZm9yY2VfcmVuZGVyKSB7XFxuXFx0XFx0XFx0b2JqID0gcGFyZW50LnJlZHJhd19ub2RlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuXFx0XFx0XFx0aWYgKG9iaiAmJiB0aGlzLnNldHRpbmdzLmRuZC51c2VfaHRtbDUpIHtcXG5cXHRcXHRcXHRcXHRpZiAodGhpcy5zZXR0aW5ncy5kbmQubGFyZ2VfZHJhZ190YXJnZXQpIHtcXG5cXHRcXHRcXHRcXHRcXHRvYmouc2V0QXR0cmlidXRlKCdkcmFnZ2FibGUnLCB0cnVlKTtcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdHZhciBpLFxcblxcdFxcdFxcdFxcdFxcdCAgICBqLFxcblxcdFxcdFxcdFxcdFxcdCAgICB0bXAgPSBudWxsO1xcblxcdFxcdFxcdFxcdFxcdGZvciAoaSA9IDAsIGogPSBvYmouY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAob2JqLmNoaWxkTm9kZXNbaV0gJiYgb2JqLmNoaWxkTm9kZXNbaV0uY2xhc3NOYW1lICYmIG9iai5jaGlsZE5vZGVzW2ldLmNsYXNzTmFtZS5pbmRleE9mKFxcXCJqc3RyZWUtYW5jaG9yXFxcIikgIT09IC0xKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dG1wID0gb2JqLmNoaWxkTm9kZXNbaV07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRpZiAodG1wKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dG1wLnNldEF0dHJpYnV0ZSgnZHJhZ2dhYmxlJywgdHJ1ZSk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIG9iajtcXG5cXHRcXHR9O1xcblxcdH07XFxuXFxuXFx0JChmdW5jdGlvbiAoKSB7XFxuXFx0XFx0Ly8gYmluZCBvbmx5IG9uY2UgZm9yIGFsbCBpbnN0YW5jZXNcXG5cXHRcXHR2YXIgbGFzdG12ID0gZmFsc2UsXFxuXFx0XFx0ICAgIGxhc3RlciA9IGZhbHNlLFxcblxcdFxcdCAgICBsYXN0ZXYgPSBmYWxzZSxcXG5cXHRcXHQgICAgb3BlbnRvID0gZmFsc2UsXFxuXFx0XFx0ICAgIG1hcmtlciA9ICQoJzxkaXYgaWQ9XFxcImpzdHJlZS1tYXJrZXJcXFwiPiYjMTYwOzwvZGl2PicpLmhpZGUoKTsgLy8uYXBwZW5kVG8oJ2JvZHknKTtcXG5cXG5cXHRcXHQkKGRvY3VtZW50KS5vbignZG5kX3N0YXJ0LnZha2F0YS5qc3RyZWUnLCBmdW5jdGlvbiAoZSwgZGF0YSkge1xcblxcdFxcdFxcdGxhc3RtdiA9IGZhbHNlO1xcblxcdFxcdFxcdGxhc3RldiA9IGZhbHNlO1xcblxcdFxcdFxcdGlmICghZGF0YSB8fCAhZGF0YS5kYXRhIHx8ICFkYXRhLmRhdGEuanN0cmVlKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRtYXJrZXIuYXBwZW5kVG8oJ2JvZHknKTsgLy8uc2hvdygpO1xcblxcdFxcdH0pLm9uKCdkbmRfbW92ZS52YWthdGEuanN0cmVlJywgZnVuY3Rpb24gKGUsIGRhdGEpIHtcXG5cXHRcXHRcXHRpZiAob3BlbnRvKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCFkYXRhLmV2ZW50IHx8IGRhdGEuZXZlbnQudHlwZSAhPT0gJ2RyYWdvdmVyJyB8fCBkYXRhLmV2ZW50LnRhcmdldCAhPT0gbGFzdGV2LnRhcmdldCkge1xcblxcdFxcdFxcdFxcdFxcdGNsZWFyVGltZW91dChvcGVudG8pO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKCFkYXRhIHx8ICFkYXRhLmRhdGEgfHwgIWRhdGEuZGF0YS5qc3RyZWUpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIGlmIHdlIGFyZSBob3ZlcmluZyB0aGUgbWFya2VyIGltYWdlIGRvIG5vdGhpbmcgKGNhbiBoYXBwZW4gb24gXFxcImluc2lkZVxcXCIgZHJhZ3MpXFxuXFx0XFx0XFx0aWYgKGRhdGEuZXZlbnQudGFyZ2V0LmlkICYmIGRhdGEuZXZlbnQudGFyZ2V0LmlkID09PSAnanN0cmVlLW1hcmtlcicpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGxhc3RldiA9IGRhdGEuZXZlbnQ7XFxuXFxuXFx0XFx0XFx0dmFyIGlucyA9ICQuanN0cmVlLnJlZmVyZW5jZShkYXRhLmV2ZW50LnRhcmdldCksXFxuXFx0XFx0XFx0ICAgIHJlZiA9IGZhbHNlLFxcblxcdFxcdFxcdCAgICBvZmYgPSBmYWxzZSxcXG5cXHRcXHRcXHQgICAgcmVsID0gZmFsc2UsXFxuXFx0XFx0XFx0ICAgIHRtcCxcXG5cXHRcXHRcXHQgICAgbCxcXG5cXHRcXHRcXHQgICAgdCxcXG5cXHRcXHRcXHQgICAgaCxcXG5cXHRcXHRcXHQgICAgcCxcXG5cXHRcXHRcXHQgICAgaSxcXG5cXHRcXHRcXHQgICAgbyxcXG5cXHRcXHRcXHQgICAgb2ssXFxuXFx0XFx0XFx0ICAgIHQxLFxcblxcdFxcdFxcdCAgICB0MixcXG5cXHRcXHRcXHQgICAgb3AsXFxuXFx0XFx0XFx0ICAgIHBzLFxcblxcdFxcdFxcdCAgICBwcixcXG5cXHRcXHRcXHQgICAgaXAsXFxuXFx0XFx0XFx0ICAgIHRtLFxcblxcdFxcdFxcdCAgICBpc19jb3B5LFxcblxcdFxcdFxcdCAgICBwbjtcXG5cXHRcXHRcXHQvLyBpZiB3ZSBhcmUgb3ZlciBhbiBpbnN0YW5jZVxcblxcdFxcdFxcdGlmIChpbnMgJiYgaW5zLl9kYXRhICYmIGlucy5fZGF0YS5kbmQpIHtcXG5cXHRcXHRcXHRcXHRtYXJrZXIuYXR0cignY2xhc3MnLCAnanN0cmVlLScgKyBpbnMuZ2V0X3RoZW1lKCkgKyAoaW5zLnNldHRpbmdzLmNvcmUudGhlbWVzLnJlc3BvbnNpdmUgPyAnIGpzdHJlZS1kbmQtcmVzcG9uc2l2ZScgOiAnJykpO1xcblxcdFxcdFxcdFxcdGlzX2NvcHkgPSBkYXRhLmRhdGEub3JpZ2luICYmIChkYXRhLmRhdGEub3JpZ2luLnNldHRpbmdzLmRuZC5hbHdheXNfY29weSB8fCBkYXRhLmRhdGEub3JpZ2luLnNldHRpbmdzLmRuZC5jb3B5ICYmIChkYXRhLmV2ZW50Lm1ldGFLZXkgfHwgZGF0YS5ldmVudC5jdHJsS2V5KSk7XFxuXFx0XFx0XFx0XFx0ZGF0YS5oZWxwZXIuY2hpbGRyZW4oKS5hdHRyKCdjbGFzcycsICdqc3RyZWUtJyArIGlucy5nZXRfdGhlbWUoKSArICcganN0cmVlLScgKyBpbnMuZ2V0X3RoZW1lKCkgKyAnLScgKyBpbnMuZ2V0X3RoZW1lX3ZhcmlhbnQoKSArICcgJyArIChpbnMuc2V0dGluZ3MuY29yZS50aGVtZXMucmVzcG9uc2l2ZSA/ICcganN0cmVlLWRuZC1yZXNwb25zaXZlJyA6ICcnKSkuZmluZCgnLmpzdHJlZS1jb3B5JykuZmlyc3QoKVtpc19jb3B5ID8gJ3Nob3cnIDogJ2hpZGUnXSgpO1xcblxcblxcdFxcdFxcdFxcdC8vIGlmIGFyZSBob3ZlcmluZyB0aGUgY29udGFpbmVyIGl0c2VsZiBhZGQgYSBuZXcgcm9vdCBub2RlXFxuXFx0XFx0XFx0XFx0Ly9jb25zb2xlLmxvZyhkYXRhLmV2ZW50KTtcXG5cXHRcXHRcXHRcXHRpZiAoKGRhdGEuZXZlbnQudGFyZ2V0ID09PSBpbnMuZWxlbWVudFswXSB8fCBkYXRhLmV2ZW50LnRhcmdldCA9PT0gaW5zLmdldF9jb250YWluZXJfdWwoKVswXSkgJiYgaW5zLmdldF9jb250YWluZXJfdWwoKS5jaGlsZHJlbigpLmxlbmd0aCA9PT0gMCkge1xcblxcdFxcdFxcdFxcdFxcdG9rID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHRmb3IgKHQxID0gMCwgdDIgPSBkYXRhLmRhdGEubm9kZXMubGVuZ3RoOyB0MSA8IHQyOyB0MSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0b2sgPSBvayAmJiBpbnMuY2hlY2soZGF0YS5kYXRhLm9yaWdpbiAmJiAoZGF0YS5kYXRhLm9yaWdpbi5zZXR0aW5ncy5kbmQuYWx3YXlzX2NvcHkgfHwgZGF0YS5kYXRhLm9yaWdpbi5zZXR0aW5ncy5kbmQuY29weSAmJiAoZGF0YS5ldmVudC5tZXRhS2V5IHx8IGRhdGEuZXZlbnQuY3RybEtleSkpID8gXFxcImNvcHlfbm9kZVxcXCIgOiBcXFwibW92ZV9ub2RlXFxcIiwgZGF0YS5kYXRhLm9yaWdpbiAmJiBkYXRhLmRhdGEub3JpZ2luICE9PSBpbnMgPyBkYXRhLmRhdGEub3JpZ2luLmdldF9ub2RlKGRhdGEuZGF0YS5ub2Rlc1t0MV0pIDogZGF0YS5kYXRhLm5vZGVzW3QxXSwgJC5qc3RyZWUucm9vdCwgJ2xhc3QnLCB7ICdkbmQnOiB0cnVlLCAncmVmJzogaW5zLmdldF9ub2RlKCQuanN0cmVlLnJvb3QpLCAncG9zJzogJ2knLCAnb3JpZ2luJzogZGF0YS5kYXRhLm9yaWdpbiwgJ2lzX211bHRpJzogZGF0YS5kYXRhLm9yaWdpbiAmJiBkYXRhLmRhdGEub3JpZ2luICE9PSBpbnMsICdpc19mb3JlaWduJzogIWRhdGEuZGF0YS5vcmlnaW4gfSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCFvaykge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aWYgKG9rKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0bGFzdG12ID0geyAnaW5zJzogaW5zLCAncGFyJzogJC5qc3RyZWUucm9vdCwgJ3Bvcyc6ICdsYXN0JyB9O1xcblxcdFxcdFxcdFxcdFxcdFxcdG1hcmtlci5oaWRlKCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS5oZWxwZXIuZmluZCgnLmpzdHJlZS1pY29uJykuZmlyc3QoKS5yZW1vdmVDbGFzcygnanN0cmVlLWVyJykuYWRkQ2xhc3MoJ2pzdHJlZS1vaycpO1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChkYXRhLmV2ZW50Lm9yaWdpbmFsRXZlbnQgJiYgZGF0YS5ldmVudC5vcmlnaW5hbEV2ZW50LmRhdGFUcmFuc2Zlcikge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEuZXZlbnQub3JpZ2luYWxFdmVudC5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9IGlzX2NvcHkgPyAnY29weScgOiAnbW92ZSc7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHQvLyBpZiB3ZSBhcmUgaG92ZXJpbmcgYSB0cmVlIG5vZGVcXG5cXHRcXHRcXHRcXHRcXHRyZWYgPSBpbnMuc2V0dGluZ3MuZG5kLmxhcmdlX2Ryb3BfdGFyZ2V0ID8gJChkYXRhLmV2ZW50LnRhcmdldCkuY2xvc2VzdCgnLmpzdHJlZS1ub2RlJykuY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykgOiAkKGRhdGEuZXZlbnQudGFyZ2V0KS5jbG9zZXN0KCcuanN0cmVlLWFuY2hvcicpO1xcblxcdFxcdFxcdFxcdFxcdGlmIChyZWYgJiYgcmVmLmxlbmd0aCAmJiByZWYucGFyZW50KCkuaXMoJy5qc3RyZWUtY2xvc2VkLCAuanN0cmVlLW9wZW4sIC5qc3RyZWUtbGVhZicpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0b2ZmID0gcmVmLm9mZnNldCgpO1xcblxcdFxcdFxcdFxcdFxcdFxcdHJlbCA9IChkYXRhLmV2ZW50LnBhZ2VZICE9PSB1bmRlZmluZWQgPyBkYXRhLmV2ZW50LnBhZ2VZIDogZGF0YS5ldmVudC5vcmlnaW5hbEV2ZW50LnBhZ2VZKSAtIG9mZi50b3A7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aCA9IHJlZi5vdXRlckhlaWdodCgpO1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChyZWwgPCBoIC8gMykge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG8gPSBbJ2InLCAnaScsICdhJ107XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIGlmIChyZWwgPiBoIC0gaCAvIDMpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRvID0gWydhJywgJ2knLCAnYiddO1xcblxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0byA9IHJlbCA+IGggLyAyID8gWydpJywgJ2EnLCAnYiddIDogWydpJywgJ2InLCAnYSddO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHQkLmVhY2gobywgZnVuY3Rpb24gKGosIHYpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzd2l0Y2ggKHYpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdiJzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRsID0gb2ZmLmxlZnQgLSA2O1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHQgPSBvZmYudG9wO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHAgPSBpbnMuZ2V0X3BhcmVudChyZWYpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGkgPSByZWYucGFyZW50KCkuaW5kZXgoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdpJzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpcCA9IGlucy5zZXR0aW5ncy5kbmQuaW5zaWRlX3BvcztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0bSA9IGlucy5nZXRfbm9kZShyZWYucGFyZW50KCkpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGwgPSBvZmYubGVmdCAtIDI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dCA9IG9mZi50b3AgKyBoIC8gMiArIDE7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cCA9IHRtLmlkO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGkgPSBpcCA9PT0gJ2ZpcnN0JyA/IDAgOiBpcCA9PT0gJ2xhc3QnID8gdG0uY2hpbGRyZW4ubGVuZ3RoIDogTWF0aC5taW4oaXAsIHRtLmNoaWxkcmVuLmxlbmd0aCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnYSc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bCA9IG9mZi5sZWZ0IC0gNjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0ID0gb2ZmLnRvcCArIGg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cCA9IGlucy5nZXRfcGFyZW50KHJlZik7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aSA9IHJlZi5wYXJlbnQoKS5pbmRleCgpICsgMTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0b2sgPSB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGZvciAodDEgPSAwLCB0MiA9IGRhdGEuZGF0YS5ub2Rlcy5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRvcCA9IGRhdGEuZGF0YS5vcmlnaW4gJiYgKGRhdGEuZGF0YS5vcmlnaW4uc2V0dGluZ3MuZG5kLmFsd2F5c19jb3B5IHx8IGRhdGEuZGF0YS5vcmlnaW4uc2V0dGluZ3MuZG5kLmNvcHkgJiYgKGRhdGEuZXZlbnQubWV0YUtleSB8fCBkYXRhLmV2ZW50LmN0cmxLZXkpKSA/IFxcXCJjb3B5X25vZGVcXFwiIDogXFxcIm1vdmVfbm9kZVxcXCI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cHMgPSBpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChvcCA9PT0gXFxcIm1vdmVfbm9kZVxcXCIgJiYgdiA9PT0gJ2EnICYmIGRhdGEuZGF0YS5vcmlnaW4gJiYgZGF0YS5kYXRhLm9yaWdpbiA9PT0gaW5zICYmIHAgPT09IGlucy5nZXRfcGFyZW50KGRhdGEuZGF0YS5ub2Rlc1t0MV0pKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cHIgPSBpbnMuZ2V0X25vZGUocCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKHBzID4gJC5pbkFycmF5KGRhdGEuZGF0YS5ub2Rlc1t0MV0sIHByLmNoaWxkcmVuKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHBzIC09IDE7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRvayA9IG9rICYmIChpbnMgJiYgaW5zLnNldHRpbmdzICYmIGlucy5zZXR0aW5ncy5kbmQgJiYgaW5zLnNldHRpbmdzLmRuZC5jaGVja193aGlsZV9kcmFnZ2luZyA9PT0gZmFsc2UgfHwgaW5zLmNoZWNrKG9wLCBkYXRhLmRhdGEub3JpZ2luICYmIGRhdGEuZGF0YS5vcmlnaW4gIT09IGlucyA/IGRhdGEuZGF0YS5vcmlnaW4uZ2V0X25vZGUoZGF0YS5kYXRhLm5vZGVzW3QxXSkgOiBkYXRhLmRhdGEubm9kZXNbdDFdLCBwLCBwcywgeyAnZG5kJzogdHJ1ZSwgJ3JlZic6IGlucy5nZXRfbm9kZShyZWYucGFyZW50KCkpLCAncG9zJzogdiwgJ29yaWdpbic6IGRhdGEuZGF0YS5vcmlnaW4sICdpc19tdWx0aSc6IGRhdGEuZGF0YS5vcmlnaW4gJiYgZGF0YS5kYXRhLm9yaWdpbiAhPT0gaW5zLCAnaXNfZm9yZWlnbic6ICFkYXRhLmRhdGEub3JpZ2luIH0pKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIW9rKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKGlucyAmJiBpbnMubGFzdF9lcnJvcikge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGxhc3RlciA9IGlucy5sYXN0X2Vycm9yKCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKHYgPT09ICdpJyAmJiByZWYucGFyZW50KCkuaXMoJy5qc3RyZWUtY2xvc2VkJykgJiYgaW5zLnNldHRpbmdzLmRuZC5vcGVuX3RpbWVvdXQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRvcGVudG8gPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICh4LCB6KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR4Lm9wZW5fbm9kZSh6KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH0oaW5zLCByZWYpLCBpbnMuc2V0dGluZ3MuZG5kLm9wZW5fdGltZW91dCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChvaykge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHBuID0gaW5zLmdldF9ub2RlKHAsIHRydWUpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICghcG4uaGFzQ2xhc3MoJy5qc3RyZWUtZG5kLXBhcmVudCcpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0JCgnLmpzdHJlZS1kbmQtcGFyZW50JykucmVtb3ZlQ2xhc3MoJ2pzdHJlZS1kbmQtcGFyZW50Jyk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cG4uYWRkQ2xhc3MoJ2pzdHJlZS1kbmQtcGFyZW50Jyk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGxhc3RtdiA9IHsgJ2lucyc6IGlucywgJ3Bhcic6IHAsICdwb3MnOiB2ID09PSAnaScgJiYgaXAgPT09ICdsYXN0JyAmJiBpID09PSAwICYmICFpbnMuaXNfbG9hZGVkKHRtKSA/ICdsYXN0JyA6IGkgfTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRtYXJrZXIuY3NzKHsgJ2xlZnQnOiBsICsgJ3B4JywgJ3RvcCc6IHQgKyAncHgnIH0pLnNob3coKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLmhlbHBlci5maW5kKCcuanN0cmVlLWljb24nKS5maXJzdCgpLnJlbW92ZUNsYXNzKCdqc3RyZWUtZXInKS5hZGRDbGFzcygnanN0cmVlLW9rJyk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKGRhdGEuZXZlbnQub3JpZ2luYWxFdmVudCAmJiBkYXRhLmV2ZW50Lm9yaWdpbmFsRXZlbnQuZGF0YVRyYW5zZmVyKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS5ldmVudC5vcmlnaW5hbEV2ZW50LmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gaXNfY29weSA/ICdjb3B5JyA6ICdtb3ZlJztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bGFzdGVyID0ge307XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0byA9IHRydWU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAobyA9PT0gdHJ1ZSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0JCgnLmpzdHJlZS1kbmQtcGFyZW50JykucmVtb3ZlQ2xhc3MoJ2pzdHJlZS1kbmQtcGFyZW50Jyk7XFxuXFx0XFx0XFx0bGFzdG12ID0gZmFsc2U7XFxuXFx0XFx0XFx0ZGF0YS5oZWxwZXIuZmluZCgnLmpzdHJlZS1pY29uJykucmVtb3ZlQ2xhc3MoJ2pzdHJlZS1vaycpLmFkZENsYXNzKCdqc3RyZWUtZXInKTtcXG5cXHRcXHRcXHRpZiAoZGF0YS5ldmVudC5vcmlnaW5hbEV2ZW50ICYmIGRhdGEuZXZlbnQub3JpZ2luYWxFdmVudC5kYXRhVHJhbnNmZXIpIHtcXG5cXHRcXHRcXHRcXHRkYXRhLmV2ZW50Lm9yaWdpbmFsRXZlbnQuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSAnbm9uZSc7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdG1hcmtlci5oaWRlKCk7XFxuXFx0XFx0fSkub24oJ2RuZF9zY3JvbGwudmFrYXRhLmpzdHJlZScsIGZ1bmN0aW9uIChlLCBkYXRhKSB7XFxuXFx0XFx0XFx0aWYgKCFkYXRhIHx8ICFkYXRhLmRhdGEgfHwgIWRhdGEuZGF0YS5qc3RyZWUpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdG1hcmtlci5oaWRlKCk7XFxuXFx0XFx0XFx0bGFzdG12ID0gZmFsc2U7XFxuXFx0XFx0XFx0bGFzdGV2ID0gZmFsc2U7XFxuXFx0XFx0XFx0ZGF0YS5oZWxwZXIuZmluZCgnLmpzdHJlZS1pY29uJykuZmlyc3QoKS5yZW1vdmVDbGFzcygnanN0cmVlLW9rJykuYWRkQ2xhc3MoJ2pzdHJlZS1lcicpO1xcblxcdFxcdH0pLm9uKCdkbmRfc3RvcC52YWthdGEuanN0cmVlJywgZnVuY3Rpb24gKGUsIGRhdGEpIHtcXG5cXHRcXHRcXHQkKCcuanN0cmVlLWRuZC1wYXJlbnQnKS5yZW1vdmVDbGFzcygnanN0cmVlLWRuZC1wYXJlbnQnKTtcXG5cXHRcXHRcXHRpZiAob3BlbnRvKSB7XFxuXFx0XFx0XFx0XFx0Y2xlYXJUaW1lb3V0KG9wZW50byk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICghZGF0YSB8fCAhZGF0YS5kYXRhIHx8ICFkYXRhLmRhdGEuanN0cmVlKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRtYXJrZXIuaGlkZSgpLmRldGFjaCgpO1xcblxcdFxcdFxcdHZhciBpLFxcblxcdFxcdFxcdCAgICBqLFxcblxcdFxcdFxcdCAgICBub2RlcyA9IFtdO1xcblxcdFxcdFxcdGlmIChsYXN0bXYpIHtcXG5cXHRcXHRcXHRcXHRmb3IgKGkgPSAwLCBqID0gZGF0YS5kYXRhLm5vZGVzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdG5vZGVzW2ldID0gZGF0YS5kYXRhLm9yaWdpbiA/IGRhdGEuZGF0YS5vcmlnaW4uZ2V0X25vZGUoZGF0YS5kYXRhLm5vZGVzW2ldKSA6IGRhdGEuZGF0YS5ub2Rlc1tpXTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0bGFzdG12Lmluc1tkYXRhLmRhdGEub3JpZ2luICYmIChkYXRhLmRhdGEub3JpZ2luLnNldHRpbmdzLmRuZC5hbHdheXNfY29weSB8fCBkYXRhLmRhdGEub3JpZ2luLnNldHRpbmdzLmRuZC5jb3B5ICYmIChkYXRhLmV2ZW50Lm1ldGFLZXkgfHwgZGF0YS5ldmVudC5jdHJsS2V5KSkgPyAnY29weV9ub2RlJyA6ICdtb3ZlX25vZGUnXShub2RlcywgbGFzdG12LnBhciwgbGFzdG12LnBvcywgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZGF0YS5kYXRhLm9yaWdpbik7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRpID0gJChkYXRhLmV2ZW50LnRhcmdldCkuY2xvc2VzdCgnLmpzdHJlZScpO1xcblxcdFxcdFxcdFxcdGlmIChpLmxlbmd0aCAmJiBsYXN0ZXIgJiYgbGFzdGVyLmVycm9yICYmIGxhc3Rlci5lcnJvciA9PT0gJ2NoZWNrJykge1xcblxcdFxcdFxcdFxcdFxcdGkgPSBpLmpzdHJlZSh0cnVlKTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoaSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGkuc2V0dGluZ3MuY29yZS5lcnJvci5jYWxsKHRoaXMsIGxhc3Rlcik7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0bGFzdGV2ID0gZmFsc2U7XFxuXFx0XFx0XFx0bGFzdG12ID0gZmFsc2U7XFxuXFx0XFx0fSkub24oJ2tleXVwLmpzdHJlZSBrZXlkb3duLmpzdHJlZScsIGZ1bmN0aW9uIChlLCBkYXRhKSB7XFxuXFx0XFx0XFx0ZGF0YSA9ICQudmFrYXRhLmRuZC5fZ2V0KCk7XFxuXFx0XFx0XFx0aWYgKGRhdGEgJiYgZGF0YS5kYXRhICYmIGRhdGEuZGF0YS5qc3RyZWUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZS50eXBlID09PSBcXFwia2V5dXBcXFwiICYmIGUud2hpY2ggPT09IDI3KSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKG9wZW50bykge1xcblxcdFxcdFxcdFxcdFxcdFxcdGNsZWFyVGltZW91dChvcGVudG8pO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRsYXN0bXYgPSBmYWxzZTtcXG5cXHRcXHRcXHRcXHRcXHRsYXN0ZXIgPSBmYWxzZTtcXG5cXHRcXHRcXHRcXHRcXHRsYXN0ZXYgPSBmYWxzZTtcXG5cXHRcXHRcXHRcXHRcXHRvcGVudG8gPSBmYWxzZTtcXG5cXHRcXHRcXHRcXHRcXHRtYXJrZXIuaGlkZSgpLmRldGFjaCgpO1xcblxcdFxcdFxcdFxcdFxcdCQudmFrYXRhLmRuZC5fY2xlYW4oKTtcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdGRhdGEuaGVscGVyLmZpbmQoJy5qc3RyZWUtY29weScpLmZpcnN0KClbZGF0YS5kYXRhLm9yaWdpbiAmJiAoZGF0YS5kYXRhLm9yaWdpbi5zZXR0aW5ncy5kbmQuYWx3YXlzX2NvcHkgfHwgZGF0YS5kYXRhLm9yaWdpbi5zZXR0aW5ncy5kbmQuY29weSAmJiAoZS5tZXRhS2V5IHx8IGUuY3RybEtleSkpID8gJ3Nob3cnIDogJ2hpZGUnXSgpO1xcblxcdFxcdFxcdFxcdFxcdGlmIChsYXN0ZXYpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRsYXN0ZXYubWV0YUtleSA9IGUubWV0YUtleTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRsYXN0ZXYuY3RybEtleSA9IGUuY3RybEtleTtcXG5cXHRcXHRcXHRcXHRcXHRcXHQkLnZha2F0YS5kbmQuX3RyaWdnZXIoJ21vdmUnLCBsYXN0ZXYpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0pO1xcblxcdH0pO1xcblxcblxcdC8vIGhlbHBlcnNcXG5cXHQoZnVuY3Rpb24gKCQpIHtcXG5cXHRcXHQkLnZha2F0YS5odG1sID0ge1xcblxcdFxcdFxcdGRpdjogJCgnPGRpdiAvPicpLFxcblxcdFxcdFxcdGVzY2FwZTogZnVuY3Rpb24gZXNjYXBlKHN0cikge1xcblxcdFxcdFxcdFxcdHJldHVybiAkLnZha2F0YS5odG1sLmRpdi50ZXh0KHN0cikuaHRtbCgpO1xcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0c3RyaXA6IGZ1bmN0aW9uIHN0cmlwKHN0cikge1xcblxcdFxcdFxcdFxcdHJldHVybiAkLnZha2F0YS5odG1sLmRpdi5lbXB0eSgpLmFwcGVuZCgkLnBhcnNlSFRNTChzdHIpKS50ZXh0KCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH07XFxuXFx0XFx0Ly8gcHJpdmF0ZSB2YXJpYWJsZVxcblxcdFxcdHZhciB2YWthdGFfZG5kID0ge1xcblxcdFxcdFxcdGVsZW1lbnQ6IGZhbHNlLFxcblxcdFxcdFxcdHRhcmdldDogZmFsc2UsXFxuXFx0XFx0XFx0aXNfZG93bjogZmFsc2UsXFxuXFx0XFx0XFx0aXNfZHJhZzogZmFsc2UsXFxuXFx0XFx0XFx0aGVscGVyOiBmYWxzZSxcXG5cXHRcXHRcXHRoZWxwZXJfdzogMCxcXG5cXHRcXHRcXHRkYXRhOiBmYWxzZSxcXG5cXHRcXHRcXHRpbml0X3g6IDAsXFxuXFx0XFx0XFx0aW5pdF95OiAwLFxcblxcdFxcdFxcdHNjcm9sbF9sOiAwLFxcblxcdFxcdFxcdHNjcm9sbF90OiAwLFxcblxcdFxcdFxcdHNjcm9sbF9lOiBmYWxzZSxcXG5cXHRcXHRcXHRzY3JvbGxfaTogZmFsc2UsXFxuXFx0XFx0XFx0aXNfdG91Y2g6IGZhbHNlXFxuXFx0XFx0fTtcXG5cXHRcXHQkLnZha2F0YS5kbmQgPSB7XFxuXFx0XFx0XFx0c2V0dGluZ3M6IHtcXG5cXHRcXHRcXHRcXHRzY3JvbGxfc3BlZWQ6IDEwLFxcblxcdFxcdFxcdFxcdHNjcm9sbF9wcm94aW1pdHk6IDIwLFxcblxcdFxcdFxcdFxcdGhlbHBlcl9sZWZ0OiA1LFxcblxcdFxcdFxcdFxcdGhlbHBlcl90b3A6IDEwLFxcblxcdFxcdFxcdFxcdHRocmVzaG9sZDogNSxcXG5cXHRcXHRcXHRcXHR0aHJlc2hvbGRfdG91Y2g6IDUwXFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRfdHJpZ2dlcjogZnVuY3Rpb24gX3RyaWdnZXIoZXZlbnRfbmFtZSwgZSwgZGF0YSkge1xcblxcdFxcdFxcdFxcdGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcXG5cXHRcXHRcXHRcXHRcXHRkYXRhID0gJC52YWthdGEuZG5kLl9nZXQoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0ZGF0YS5ldmVudCA9IGU7XFxuXFx0XFx0XFx0XFx0JChkb2N1bWVudCkudHJpZ2dlckhhbmRsZXIoXFxcImRuZF9cXFwiICsgZXZlbnRfbmFtZSArIFxcXCIudmFrYXRhXFxcIiwgZGF0YSk7XFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRfZ2V0OiBmdW5jdGlvbiBfZ2V0KCkge1xcblxcdFxcdFxcdFxcdHJldHVybiB7XFxuXFx0XFx0XFx0XFx0XFx0XFxcImRhdGFcXFwiOiB2YWthdGFfZG5kLmRhdGEsXFxuXFx0XFx0XFx0XFx0XFx0XFxcImVsZW1lbnRcXFwiOiB2YWthdGFfZG5kLmVsZW1lbnQsXFxuXFx0XFx0XFx0XFx0XFx0XFxcImhlbHBlclxcXCI6IHZha2F0YV9kbmQuaGVscGVyXFxuXFx0XFx0XFx0XFx0fTtcXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdF9jbGVhbjogZnVuY3Rpb24gX2NsZWFuKCkge1xcblxcdFxcdFxcdFxcdGlmICh2YWthdGFfZG5kLmhlbHBlcikge1xcblxcdFxcdFxcdFxcdFxcdHZha2F0YV9kbmQuaGVscGVyLnJlbW92ZSgpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRpZiAodmFrYXRhX2RuZC5zY3JvbGxfaSkge1xcblxcdFxcdFxcdFxcdFxcdGNsZWFySW50ZXJ2YWwodmFrYXRhX2RuZC5zY3JvbGxfaSk7dmFrYXRhX2RuZC5zY3JvbGxfaSA9IGZhbHNlO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR2YWthdGFfZG5kID0ge1xcblxcdFxcdFxcdFxcdFxcdGVsZW1lbnQ6IGZhbHNlLFxcblxcdFxcdFxcdFxcdFxcdHRhcmdldDogZmFsc2UsXFxuXFx0XFx0XFx0XFx0XFx0aXNfZG93bjogZmFsc2UsXFxuXFx0XFx0XFx0XFx0XFx0aXNfZHJhZzogZmFsc2UsXFxuXFx0XFx0XFx0XFx0XFx0aGVscGVyOiBmYWxzZSxcXG5cXHRcXHRcXHRcXHRcXHRoZWxwZXJfdzogMCxcXG5cXHRcXHRcXHRcXHRcXHRkYXRhOiBmYWxzZSxcXG5cXHRcXHRcXHRcXHRcXHRpbml0X3g6IDAsXFxuXFx0XFx0XFx0XFx0XFx0aW5pdF95OiAwLFxcblxcdFxcdFxcdFxcdFxcdHNjcm9sbF9sOiAwLFxcblxcdFxcdFxcdFxcdFxcdHNjcm9sbF90OiAwLFxcblxcdFxcdFxcdFxcdFxcdHNjcm9sbF9lOiBmYWxzZSxcXG5cXHRcXHRcXHRcXHRcXHRzY3JvbGxfaTogZmFsc2UsXFxuXFx0XFx0XFx0XFx0XFx0aXNfdG91Y2g6IGZhbHNlXFxuXFx0XFx0XFx0XFx0fTtcXG5cXHRcXHRcXHRcXHQkKGRvY3VtZW50KS5vZmYoXFxcIm1vdXNlbW92ZS52YWthdGEuanN0cmVlIHRvdWNobW92ZS52YWthdGEuanN0cmVlXFxcIiwgJC52YWthdGEuZG5kLmRyYWcpO1xcblxcdFxcdFxcdFxcdCQoZG9jdW1lbnQpLm9mZihcXFwibW91c2V1cC52YWthdGEuanN0cmVlIHRvdWNoZW5kLnZha2F0YS5qc3RyZWVcXFwiLCAkLnZha2F0YS5kbmQuc3RvcCk7XFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRfc2Nyb2xsOiBmdW5jdGlvbiBfc2Nyb2xsKGluaXRfb25seSkge1xcblxcdFxcdFxcdFxcdGlmICghdmFrYXRhX2RuZC5zY3JvbGxfZSB8fCAhdmFrYXRhX2RuZC5zY3JvbGxfbCAmJiAhdmFrYXRhX2RuZC5zY3JvbGxfdCkge1xcblxcdFxcdFxcdFxcdFxcdGlmICh2YWthdGFfZG5kLnNjcm9sbF9pKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2xlYXJJbnRlcnZhbCh2YWthdGFfZG5kLnNjcm9sbF9pKTt2YWthdGFfZG5kLnNjcm9sbF9pID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aWYgKCF2YWthdGFfZG5kLnNjcm9sbF9pKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFrYXRhX2RuZC5zY3JvbGxfaSA9IHNldEludGVydmFsKCQudmFrYXRhLmRuZC5fc2Nyb2xsLCAxMDApO1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aWYgKGluaXRfb25seSA9PT0gdHJ1ZSkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGkgPSB2YWthdGFfZG5kLnNjcm9sbF9lLnNjcm9sbFRvcCgpLFxcblxcdFxcdFxcdFxcdCAgICBqID0gdmFrYXRhX2RuZC5zY3JvbGxfZS5zY3JvbGxMZWZ0KCk7XFxuXFx0XFx0XFx0XFx0dmFrYXRhX2RuZC5zY3JvbGxfZS5zY3JvbGxUb3AoaSArIHZha2F0YV9kbmQuc2Nyb2xsX3QgKiAkLnZha2F0YS5kbmQuc2V0dGluZ3Muc2Nyb2xsX3NwZWVkKTtcXG5cXHRcXHRcXHRcXHR2YWthdGFfZG5kLnNjcm9sbF9lLnNjcm9sbExlZnQoaiArIHZha2F0YV9kbmQuc2Nyb2xsX2wgKiAkLnZha2F0YS5kbmQuc2V0dGluZ3Muc2Nyb2xsX3NwZWVkKTtcXG5cXHRcXHRcXHRcXHRpZiAoaSAhPT0gdmFrYXRhX2RuZC5zY3JvbGxfZS5zY3JvbGxUb3AoKSB8fCBqICE9PSB2YWthdGFfZG5kLnNjcm9sbF9lLnNjcm9sbExlZnQoKSkge1xcblxcdFxcdFxcdFxcdFxcdC8qKlxcbiAgICAgICogdHJpZ2dlcmVkIG9uIHRoZSBkb2N1bWVudCB3aGVuIGEgZHJhZyBjYXVzZXMgYW4gZWxlbWVudCB0byBzY3JvbGxcXG4gICAgICAqIEBldmVudFxcbiAgICAgICogQHBsdWdpbiBkbmRcXG4gICAgICAqIEBuYW1lIGRuZF9zY3JvbGwudmFrYXRhXFxuICAgICAgKiBAcGFyYW0ge01peGVkfSBkYXRhIGFueSBkYXRhIHN1cHBsaWVkIHdpdGggdGhlIGNhbGwgdG8gJC52YWthdGEuZG5kLnN0YXJ0XFxuICAgICAgKiBAcGFyYW0ge0RPTX0gZWxlbWVudCB0aGUgRE9NIGVsZW1lbnQgYmVpbmcgZHJhZ2dlZFxcbiAgICAgICogQHBhcmFtIHtqUXVlcnl9IGhlbHBlciB0aGUgaGVscGVyIHNob3duIG5leHQgdG8gdGhlIG1vdXNlXFxuICAgICAgKiBAcGFyYW0ge2pRdWVyeX0gZXZlbnQgdGhlIGVsZW1lbnQgdGhhdCBpcyBzY3JvbGxpbmdcXG4gICAgICAqL1xcblxcdFxcdFxcdFxcdFxcdCQudmFrYXRhLmRuZC5fdHJpZ2dlcihcXFwic2Nyb2xsXFxcIiwgdmFrYXRhX2RuZC5zY3JvbGxfZSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0c3RhcnQ6IGZ1bmN0aW9uIHN0YXJ0KGUsIGRhdGEsIGh0bWwpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZS50eXBlID09PSBcXFwidG91Y2hzdGFydFxcXCIgJiYgZS5vcmlnaW5hbEV2ZW50ICYmIGUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlcyAmJiBlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0pIHtcXG5cXHRcXHRcXHRcXHRcXHRlLnBhZ2VYID0gZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VYO1xcblxcdFxcdFxcdFxcdFxcdGUucGFnZVkgPSBlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVk7XFxuXFx0XFx0XFx0XFx0XFx0ZS50YXJnZXQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KGUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWCAtIHdpbmRvdy5wYWdlWE9mZnNldCwgZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VZIC0gd2luZG93LnBhZ2VZT2Zmc2V0KTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aWYgKHZha2F0YV9kbmQuaXNfZHJhZykge1xcblxcdFxcdFxcdFxcdFxcdCQudmFrYXRhLmRuZC5zdG9wKHt9KTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0dHJ5IHtcXG5cXHRcXHRcXHRcXHRcXHRlLmN1cnJlbnRUYXJnZXQudW5zZWxlY3RhYmxlID0gXFxcIm9uXFxcIjtcXG5cXHRcXHRcXHRcXHRcXHRlLmN1cnJlbnRUYXJnZXQub25zZWxlY3RzdGFydCA9IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0XFx0XFx0fTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoZS5jdXJyZW50VGFyZ2V0LnN0eWxlKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZS5jdXJyZW50VGFyZ2V0LnN0eWxlLnRvdWNoQWN0aW9uID0gXFxcIm5vbmVcXFwiO1xcblxcdFxcdFxcdFxcdFxcdFxcdGUuY3VycmVudFRhcmdldC5zdHlsZS5tc1RvdWNoQWN0aW9uID0gXFxcIm5vbmVcXFwiO1xcblxcdFxcdFxcdFxcdFxcdFxcdGUuY3VycmVudFRhcmdldC5zdHlsZS5Nb3pVc2VyU2VsZWN0ID0gXFxcIm5vbmVcXFwiO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9IGNhdGNoIChpZ25vcmUpIHt9XFxuXFx0XFx0XFx0XFx0dmFrYXRhX2RuZC5pbml0X3ggPSBlLnBhZ2VYO1xcblxcdFxcdFxcdFxcdHZha2F0YV9kbmQuaW5pdF95ID0gZS5wYWdlWTtcXG5cXHRcXHRcXHRcXHR2YWthdGFfZG5kLmRhdGEgPSBkYXRhO1xcblxcdFxcdFxcdFxcdHZha2F0YV9kbmQuaXNfZG93biA9IHRydWU7XFxuXFx0XFx0XFx0XFx0dmFrYXRhX2RuZC5lbGVtZW50ID0gZS5jdXJyZW50VGFyZ2V0O1xcblxcdFxcdFxcdFxcdHZha2F0YV9kbmQudGFyZ2V0ID0gZS50YXJnZXQ7XFxuXFx0XFx0XFx0XFx0dmFrYXRhX2RuZC5pc190b3VjaCA9IGUudHlwZSA9PT0gXFxcInRvdWNoc3RhcnRcXFwiO1xcblxcdFxcdFxcdFxcdGlmIChodG1sICE9PSBmYWxzZSkge1xcblxcdFxcdFxcdFxcdFxcdHZha2F0YV9kbmQuaGVscGVyID0gJChcXFwiPGRpdiBpZD0ndmFrYXRhLWRuZCc+PC9kaXY+XFxcIikuaHRtbChodG1sKS5jc3Moe1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcXCJkaXNwbGF5XFxcIjogXFxcImJsb2NrXFxcIixcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXFwibWFyZ2luXFxcIjogXFxcIjBcXFwiLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcXCJwYWRkaW5nXFxcIjogXFxcIjBcXFwiLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcXCJwb3NpdGlvblxcXCI6IFxcXCJhYnNvbHV0ZVxcXCIsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFxcInRvcFxcXCI6IFxcXCItMjAwMHB4XFxcIixcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXFwibGluZUhlaWdodFxcXCI6IFxcXCIxNnB4XFxcIixcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXFwiekluZGV4XFxcIjogXFxcIjEwMDAwXFxcIlxcblxcdFxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHQkKGRvY3VtZW50KS5vbihcXFwibW91c2Vtb3ZlLnZha2F0YS5qc3RyZWUgdG91Y2htb3ZlLnZha2F0YS5qc3RyZWVcXFwiLCAkLnZha2F0YS5kbmQuZHJhZyk7XFxuXFx0XFx0XFx0XFx0JChkb2N1bWVudCkub24oXFxcIm1vdXNldXAudmFrYXRhLmpzdHJlZSB0b3VjaGVuZC52YWthdGEuanN0cmVlXFxcIiwgJC52YWthdGEuZG5kLnN0b3ApO1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdGRyYWc6IGZ1bmN0aW9uIGRyYWcoZSkge1xcblxcdFxcdFxcdFxcdGlmIChlLnR5cGUgPT09IFxcXCJ0b3VjaG1vdmVcXFwiICYmIGUub3JpZ2luYWxFdmVudCAmJiBlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXMgJiYgZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZS5wYWdlWCA9IGUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWDtcXG5cXHRcXHRcXHRcXHRcXHRlLnBhZ2VZID0gZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VZO1xcblxcdFxcdFxcdFxcdFxcdGUudGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVggLSB3aW5kb3cucGFnZVhPZmZzZXQsIGUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWSAtIHdpbmRvdy5wYWdlWU9mZnNldCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGlmICghdmFrYXRhX2RuZC5pc19kb3duKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRpZiAoIXZha2F0YV9kbmQuaXNfZHJhZykge1xcblxcdFxcdFxcdFxcdFxcdGlmIChNYXRoLmFicyhlLnBhZ2VYIC0gdmFrYXRhX2RuZC5pbml0X3gpID4gKHZha2F0YV9kbmQuaXNfdG91Y2ggPyAkLnZha2F0YS5kbmQuc2V0dGluZ3MudGhyZXNob2xkX3RvdWNoIDogJC52YWthdGEuZG5kLnNldHRpbmdzLnRocmVzaG9sZCkgfHwgTWF0aC5hYnMoZS5wYWdlWSAtIHZha2F0YV9kbmQuaW5pdF95KSA+ICh2YWthdGFfZG5kLmlzX3RvdWNoID8gJC52YWthdGEuZG5kLnNldHRpbmdzLnRocmVzaG9sZF90b3VjaCA6ICQudmFrYXRhLmRuZC5zZXR0aW5ncy50aHJlc2hvbGQpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKHZha2F0YV9kbmQuaGVscGVyKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFrYXRhX2RuZC5oZWxwZXIuYXBwZW5kVG8oXFxcImJvZHlcXFwiKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YWthdGFfZG5kLmhlbHBlcl93ID0gdmFrYXRhX2RuZC5oZWxwZXIub3V0ZXJXaWR0aCgpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR2YWthdGFfZG5kLmlzX2RyYWcgPSB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdFxcdCQodmFrYXRhX2RuZC50YXJnZXQpLm9uZSgnY2xpY2sudmFrYXRhJywgZmFsc2UpO1xcblxcdFxcdFxcdFxcdFxcdFxcdC8qKlxcbiAgICAgICAqIHRyaWdnZXJlZCBvbiB0aGUgZG9jdW1lbnQgd2hlbiBhIGRyYWcgc3RhcnRzXFxuICAgICAgICogQGV2ZW50XFxuICAgICAgICogQHBsdWdpbiBkbmRcXG4gICAgICAgKiBAbmFtZSBkbmRfc3RhcnQudmFrYXRhXFxuICAgICAgICogQHBhcmFtIHtNaXhlZH0gZGF0YSBhbnkgZGF0YSBzdXBwbGllZCB3aXRoIHRoZSBjYWxsIHRvICQudmFrYXRhLmRuZC5zdGFydFxcbiAgICAgICAqIEBwYXJhbSB7RE9NfSBlbGVtZW50IHRoZSBET00gZWxlbWVudCBiZWluZyBkcmFnZ2VkXFxuICAgICAgICogQHBhcmFtIHtqUXVlcnl9IGhlbHBlciB0aGUgaGVscGVyIHNob3duIG5leHQgdG8gdGhlIG1vdXNlXFxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IHRoZSBldmVudCB0aGF0IGNhdXNlZCB0aGUgc3RhcnQgKHByb2JhYmx5IG1vdXNlbW92ZSlcXG4gICAgICAgKi9cXG5cXHRcXHRcXHRcXHRcXHRcXHQkLnZha2F0YS5kbmQuX3RyaWdnZXIoXFxcInN0YXJ0XFxcIiwgZSk7XFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR2YXIgZCA9IGZhbHNlLFxcblxcdFxcdFxcdFxcdCAgICB3ID0gZmFsc2UsXFxuXFx0XFx0XFx0XFx0ICAgIGRoID0gZmFsc2UsXFxuXFx0XFx0XFx0XFx0ICAgIHdoID0gZmFsc2UsXFxuXFx0XFx0XFx0XFx0ICAgIGR3ID0gZmFsc2UsXFxuXFx0XFx0XFx0XFx0ICAgIHd3ID0gZmFsc2UsXFxuXFx0XFx0XFx0XFx0ICAgIGR0ID0gZmFsc2UsXFxuXFx0XFx0XFx0XFx0ICAgIGRsID0gZmFsc2UsXFxuXFx0XFx0XFx0XFx0ICAgIGh0ID0gZmFsc2UsXFxuXFx0XFx0XFx0XFx0ICAgIGhsID0gZmFsc2U7XFxuXFxuXFx0XFx0XFx0XFx0dmFrYXRhX2RuZC5zY3JvbGxfdCA9IDA7XFxuXFx0XFx0XFx0XFx0dmFrYXRhX2RuZC5zY3JvbGxfbCA9IDA7XFxuXFx0XFx0XFx0XFx0dmFrYXRhX2RuZC5zY3JvbGxfZSA9IGZhbHNlO1xcblxcdFxcdFxcdFxcdCQoJChlLnRhcmdldCkucGFyZW50c1VudGlsKFxcXCJib2R5XFxcIikuYWRkQmFjaygpLmdldCgpLnJldmVyc2UoKSkuZmlsdGVyKGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gKC9eYXV0b3xzY3JvbGwkLy50ZXN0KCQodGhpcykuY3NzKFxcXCJvdmVyZmxvd1xcXCIpKSAmJiAodGhpcy5zY3JvbGxIZWlnaHQgPiB0aGlzLm9mZnNldEhlaWdodCB8fCB0aGlzLnNjcm9sbFdpZHRoID4gdGhpcy5vZmZzZXRXaWR0aClcXG5cXHRcXHRcXHRcXHRcXHQpO1xcblxcdFxcdFxcdFxcdH0pLmVhY2goZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdHZhciB0ID0gJCh0aGlzKSxcXG5cXHRcXHRcXHRcXHRcXHQgICAgbyA9IHQub2Zmc2V0KCk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHRoaXMuc2Nyb2xsSGVpZ2h0ID4gdGhpcy5vZmZzZXRIZWlnaHQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoby50b3AgKyB0LmhlaWdodCgpIC0gZS5wYWdlWSA8ICQudmFrYXRhLmRuZC5zZXR0aW5ncy5zY3JvbGxfcHJveGltaXR5KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFrYXRhX2RuZC5zY3JvbGxfdCA9IDE7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChlLnBhZ2VZIC0gby50b3AgPCAkLnZha2F0YS5kbmQuc2V0dGluZ3Muc2Nyb2xsX3Byb3hpbWl0eSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZha2F0YV9kbmQuc2Nyb2xsX3QgPSAtMTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmICh0aGlzLnNjcm9sbFdpZHRoID4gdGhpcy5vZmZzZXRXaWR0aCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChvLmxlZnQgKyB0LndpZHRoKCkgLSBlLnBhZ2VYIDwgJC52YWthdGEuZG5kLnNldHRpbmdzLnNjcm9sbF9wcm94aW1pdHkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YWthdGFfZG5kLnNjcm9sbF9sID0gMTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKGUucGFnZVggLSBvLmxlZnQgPCAkLnZha2F0YS5kbmQuc2V0dGluZ3Muc2Nyb2xsX3Byb3hpbWl0eSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZha2F0YV9kbmQuc2Nyb2xsX2wgPSAtMTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmICh2YWthdGFfZG5kLnNjcm9sbF90IHx8IHZha2F0YV9kbmQuc2Nyb2xsX2wpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YWthdGFfZG5kLnNjcm9sbF9lID0gJCh0aGlzKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH0pO1xcblxcblxcdFxcdFxcdFxcdGlmICghdmFrYXRhX2RuZC5zY3JvbGxfZSkge1xcblxcdFxcdFxcdFxcdFxcdGQgPSAkKGRvY3VtZW50KTt3ID0gJCh3aW5kb3cpO1xcblxcdFxcdFxcdFxcdFxcdGRoID0gZC5oZWlnaHQoKTt3aCA9IHcuaGVpZ2h0KCk7XFxuXFx0XFx0XFx0XFx0XFx0ZHcgPSBkLndpZHRoKCk7d3cgPSB3LndpZHRoKCk7XFxuXFx0XFx0XFx0XFx0XFx0ZHQgPSBkLnNjcm9sbFRvcCgpO2RsID0gZC5zY3JvbGxMZWZ0KCk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGRoID4gd2ggJiYgZS5wYWdlWSAtIGR0IDwgJC52YWthdGEuZG5kLnNldHRpbmdzLnNjcm9sbF9wcm94aW1pdHkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YWthdGFfZG5kLnNjcm9sbF90ID0gLTE7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmIChkaCA+IHdoICYmIHdoIC0gKGUucGFnZVkgLSBkdCkgPCAkLnZha2F0YS5kbmQuc2V0dGluZ3Muc2Nyb2xsX3Byb3hpbWl0eSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHZha2F0YV9kbmQuc2Nyb2xsX3QgPSAxO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRpZiAoZHcgPiB3dyAmJiBlLnBhZ2VYIC0gZGwgPCAkLnZha2F0YS5kbmQuc2V0dGluZ3Muc2Nyb2xsX3Byb3hpbWl0eSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHZha2F0YV9kbmQuc2Nyb2xsX2wgPSAtMTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGR3ID4gd3cgJiYgd3cgLSAoZS5wYWdlWCAtIGRsKSA8ICQudmFrYXRhLmRuZC5zZXR0aW5ncy5zY3JvbGxfcHJveGltaXR5KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFrYXRhX2RuZC5zY3JvbGxfbCA9IDE7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmICh2YWthdGFfZG5kLnNjcm9sbF90IHx8IHZha2F0YV9kbmQuc2Nyb2xsX2wpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YWthdGFfZG5kLnNjcm9sbF9lID0gZDtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGlmICh2YWthdGFfZG5kLnNjcm9sbF9lKSB7XFxuXFx0XFx0XFx0XFx0XFx0JC52YWthdGEuZG5kLl9zY3JvbGwodHJ1ZSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmICh2YWthdGFfZG5kLmhlbHBlcikge1xcblxcdFxcdFxcdFxcdFxcdGh0ID0gcGFyc2VJbnQoZS5wYWdlWSArICQudmFrYXRhLmRuZC5zZXR0aW5ncy5oZWxwZXJfdG9wLCAxMCk7XFxuXFx0XFx0XFx0XFx0XFx0aGwgPSBwYXJzZUludChlLnBhZ2VYICsgJC52YWthdGEuZG5kLnNldHRpbmdzLmhlbHBlcl9sZWZ0LCAxMCk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGRoICYmIGh0ICsgMjUgPiBkaCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGh0ID0gZGggLSA1MDtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGR3ICYmIGhsICsgdmFrYXRhX2RuZC5oZWxwZXJfdyA+IGR3KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aGwgPSBkdyAtICh2YWthdGFfZG5kLmhlbHBlcl93ICsgMik7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdHZha2F0YV9kbmQuaGVscGVyLmNzcyh7XFxuXFx0XFx0XFx0XFx0XFx0XFx0bGVmdDogaGwgKyBcXFwicHhcXFwiLFxcblxcdFxcdFxcdFxcdFxcdFxcdHRvcDogaHQgKyBcXFwicHhcXFwiXFxuXFx0XFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdC8qKlxcbiAgICAgKiB0cmlnZ2VyZWQgb24gdGhlIGRvY3VtZW50IHdoZW4gYSBkcmFnIGlzIGluIHByb2dyZXNzXFxuICAgICAqIEBldmVudFxcbiAgICAgKiBAcGx1Z2luIGRuZFxcbiAgICAgKiBAbmFtZSBkbmRfbW92ZS52YWthdGFcXG4gICAgICogQHBhcmFtIHtNaXhlZH0gZGF0YSBhbnkgZGF0YSBzdXBwbGllZCB3aXRoIHRoZSBjYWxsIHRvICQudmFrYXRhLmRuZC5zdGFydFxcbiAgICAgKiBAcGFyYW0ge0RPTX0gZWxlbWVudCB0aGUgRE9NIGVsZW1lbnQgYmVpbmcgZHJhZ2dlZFxcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gaGVscGVyIHRoZSBoZWxwZXIgc2hvd24gbmV4dCB0byB0aGUgbW91c2VcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IHRoZSBldmVudCB0aGF0IGNhdXNlZCB0aGlzIHRvIHRyaWdnZXIgKG1vc3QgbGlrZWx5IG1vdXNlbW92ZSlcXG4gICAgICovXFxuXFx0XFx0XFx0XFx0JC52YWthdGEuZG5kLl90cmlnZ2VyKFxcXCJtb3ZlXFxcIiwgZSk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0c3RvcDogZnVuY3Rpb24gc3RvcChlKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGUudHlwZSA9PT0gXFxcInRvdWNoZW5kXFxcIiAmJiBlLm9yaWdpbmFsRXZlbnQgJiYgZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzICYmIGUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXSkge1xcblxcdFxcdFxcdFxcdFxcdGUucGFnZVggPSBlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVg7XFxuXFx0XFx0XFx0XFx0XFx0ZS5wYWdlWSA9IGUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWTtcXG5cXHRcXHRcXHRcXHRcXHRlLnRhcmdldCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VYIC0gd2luZG93LnBhZ2VYT2Zmc2V0LCBlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVkgLSB3aW5kb3cucGFnZVlPZmZzZXQpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRpZiAodmFrYXRhX2RuZC5pc19kcmFnKSB7XFxuXFx0XFx0XFx0XFx0XFx0LyoqXFxuICAgICAgKiB0cmlnZ2VyZWQgb24gdGhlIGRvY3VtZW50IHdoZW4gYSBkcmFnIHN0b3BzICh0aGUgZHJhZ2dlZCBlbGVtZW50IGlzIGRyb3BwZWQpXFxuICAgICAgKiBAZXZlbnRcXG4gICAgICAqIEBwbHVnaW4gZG5kXFxuICAgICAgKiBAbmFtZSBkbmRfc3RvcC52YWthdGFcXG4gICAgICAqIEBwYXJhbSB7TWl4ZWR9IGRhdGEgYW55IGRhdGEgc3VwcGxpZWQgd2l0aCB0aGUgY2FsbCB0byAkLnZha2F0YS5kbmQuc3RhcnRcXG4gICAgICAqIEBwYXJhbSB7RE9NfSBlbGVtZW50IHRoZSBET00gZWxlbWVudCBiZWluZyBkcmFnZ2VkXFxuICAgICAgKiBAcGFyYW0ge2pRdWVyeX0gaGVscGVyIHRoZSBoZWxwZXIgc2hvd24gbmV4dCB0byB0aGUgbW91c2VcXG4gICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCB0aGUgZXZlbnQgdGhhdCBjYXVzZWQgdGhlIHN0b3BcXG4gICAgICAqL1xcblxcdFxcdFxcdFxcdFxcdGlmIChlLnRhcmdldCAhPT0gdmFrYXRhX2RuZC50YXJnZXQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHQkKHZha2F0YV9kbmQudGFyZ2V0KS5vZmYoJ2NsaWNrLnZha2F0YScpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHQkLnZha2F0YS5kbmQuX3RyaWdnZXIoXFxcInN0b3BcXFwiLCBlKTtcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdGlmIChlLnR5cGUgPT09IFxcXCJ0b3VjaGVuZFxcXCIgJiYgZS50YXJnZXQgPT09IHZha2F0YV9kbmQudGFyZ2V0KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIHRvID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0JChlLnRhcmdldCkuY2xpY2soKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9LCAxMDApO1xcblxcdFxcdFxcdFxcdFxcdFxcdCQoZS50YXJnZXQpLm9uZSgnY2xpY2snLCBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKHRvKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Y2xlYXJUaW1lb3V0KHRvKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHQkLnZha2F0YS5kbmQuX2NsZWFuKCk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9O1xcblxcdH0pKCQpO1xcblxcblxcdC8vIGluY2x1ZGUgdGhlIGRuZCBwbHVnaW4gYnkgZGVmYXVsdFxcblxcdC8vICQuanN0cmVlLmRlZmF1bHRzLnBsdWdpbnMucHVzaChcXFwiZG5kXFxcIik7XFxuXFxuXFxuXFx0LyoqXFxuICAqICMjIyBNYXNzbG9hZCBwbHVnaW5cXG4gICpcXG4gICogQWRkcyBtYXNzbG9hZCBmdW5jdGlvbmFsaXR5IHRvIGpzVHJlZSwgc28gdGhhdCBtdWx0aXBsZSBub2RlcyBjYW4gYmUgbG9hZGVkIGluIGEgc2luZ2xlIHJlcXVlc3QgKG9ubHkgdXNlZnVsIHdpdGggbGF6eSBsb2FkaW5nKS5cXG4gICovXFxuXFxuXFx0LyoqXFxuICAqIG1hc3Nsb2FkIGNvbmZpZ3VyYXRpb25cXG4gICpcXG4gICogSXQgaXMgcG9zc2libGUgdG8gc2V0IHRoaXMgdG8gYSBzdGFuZGFyZCBqUXVlcnktbGlrZSBBSkFYIGNvbmZpZy5cXG4gICogSW4gYWRkaXRpb24gdG8gdGhlIHN0YW5kYXJkIGpRdWVyeSBhamF4IG9wdGlvbnMgaGVyZSB5b3UgY2FuIHN1cHBseSBmdW5jdGlvbnMgZm9yIGBkYXRhYCBhbmQgYHVybGAsIHRoZSBmdW5jdGlvbnMgd2lsbCBiZSBydW4gaW4gdGhlIGN1cnJlbnQgaW5zdGFuY2UncyBzY29wZSBhbmQgYSBwYXJhbSB3aWxsIGJlIHBhc3NlZCBpbmRpY2F0aW5nIHdoaWNoIG5vZGUgSURzIG5lZWQgdG8gYmUgbG9hZGVkLCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRob3NlIGZ1bmN0aW9ucyB3aWxsIGJlIHVzZWQuXFxuICAqXFxuICAqIFlvdSBjYW4gYWxzbyBzZXQgdGhpcyB0byBhIGZ1bmN0aW9uLCB0aGF0IGZ1bmN0aW9uIHdpbGwgcmVjZWl2ZSB0aGUgbm9kZSBJRHMgYmVpbmcgbG9hZGVkIGFzIGFyZ3VtZW50IGFuZCBhIHNlY29uZCBwYXJhbSB3aGljaCBpcyBhIGZ1bmN0aW9uIChjYWxsYmFjaykgd2hpY2ggc2hvdWxkIGJlIGNhbGxlZCB3aXRoIHRoZSByZXN1bHQuXFxuICAqXFxuICAqIEJvdGggdGhlIEFKQVggYW5kIHRoZSBmdW5jdGlvbiBhcHByb2FjaCByZWx5IG9uIHRoZSBzYW1lIHJldHVybiB2YWx1ZSAtIGFuIG9iamVjdCB3aGVyZSB0aGUga2V5cyBhcmUgdGhlIG5vZGUgSURzLCBhbmQgdGhlIHZhbHVlIGlzIHRoZSBjaGlsZHJlbiBvZiB0aGF0IG5vZGUgYXMgYW4gYXJyYXkuXFxuICAqXFxuICAqXFx0e1xcbiAgKlxcdFxcdFxcXCJpZDFcXFwiIDogW3sgXFxcInRleHRcXFwiIDogXFxcIkNoaWxkIG9mIElEMVxcXCIsIFxcXCJpZFxcXCIgOiBcXFwiYzFcXFwiIH0sIHsgXFxcInRleHRcXFwiIDogXFxcIkFub3RoZXIgY2hpbGQgb2YgSUQxXFxcIiwgXFxcImlkXFxcIiA6IFxcXCJjMlxcXCIgfV0sXFxuICAqXFx0XFx0XFxcImlkMlxcXCIgOiBbeyBcXFwidGV4dFxcXCIgOiBcXFwiQ2hpbGQgb2YgSUQyXFxcIiwgXFxcImlkXFxcIiA6IFxcXCJjM1xcXCIgfV1cXG4gICpcXHR9XFxuICAqIFxcbiAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5tYXNzbG9hZFxcbiAgKiBAcGx1Z2luIG1hc3Nsb2FkXFxuICAqL1xcblxcdCQuanN0cmVlLmRlZmF1bHRzLm1hc3Nsb2FkID0gbnVsbDtcXG5cXHQkLmpzdHJlZS5wbHVnaW5zLm1hc3Nsb2FkID0gZnVuY3Rpb24gKG9wdGlvbnMsIHBhcmVudCkge1xcblxcdFxcdHRoaXMuaW5pdCA9IGZ1bmN0aW9uIChlbCwgb3B0aW9ucykge1xcblxcdFxcdFxcdHRoaXMuX2RhdGEubWFzc2xvYWQgPSB7fTtcXG5cXHRcXHRcXHRwYXJlbnQuaW5pdC5jYWxsKHRoaXMsIGVsLCBvcHRpb25zKTtcXG5cXHRcXHR9O1xcblxcdFxcdHRoaXMuX2xvYWRfbm9kZXMgPSBmdW5jdGlvbiAobm9kZXMsIGNhbGxiYWNrLCBpc19jYWxsYmFjaywgZm9yY2VfcmVsb2FkKSB7XFxuXFx0XFx0XFx0dmFyIHMgPSB0aGlzLnNldHRpbmdzLm1hc3Nsb2FkLFxcblxcdFxcdFxcdCAgICBub2Rlc1N0cmluZyA9IEpTT04uc3RyaW5naWZ5KG5vZGVzKSxcXG5cXHRcXHRcXHQgICAgdG9Mb2FkID0gW10sXFxuXFx0XFx0XFx0ICAgIG0gPSB0aGlzLl9tb2RlbC5kYXRhLFxcblxcdFxcdFxcdCAgICBpLFxcblxcdFxcdFxcdCAgICBqLFxcblxcdFxcdFxcdCAgICBkb207XFxuXFx0XFx0XFx0aWYgKCFpc19jYWxsYmFjaykge1xcblxcdFxcdFxcdFxcdGZvciAoaSA9IDAsIGogPSBub2Rlcy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIW1bbm9kZXNbaV1dIHx8ICFtW25vZGVzW2ldXS5zdGF0ZS5sb2FkZWQgJiYgIW1bbm9kZXNbaV1dLnN0YXRlLmZhaWxlZCB8fCBmb3JjZV9yZWxvYWQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0b0xvYWQucHVzaChub2Rlc1tpXSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZG9tID0gdGhpcy5nZXRfbm9kZShub2Rlc1tpXSwgdHJ1ZSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKGRvbSAmJiBkb20ubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZG9tLmFkZENsYXNzKFxcXCJqc3RyZWUtbG9hZGluZ1xcXCIpLmF0dHIoJ2FyaWEtYnVzeScsIHRydWUpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHRoaXMuX2RhdGEubWFzc2xvYWQgPSB7fTtcXG5cXHRcXHRcXHRcXHRpZiAodG9Mb2FkLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdFxcdGlmICgkLmlzRnVuY3Rpb24ocykpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gcy5jYWxsKHRoaXMsIHRvTG9hZCwgJC5wcm94eShmdW5jdGlvbiAoZGF0YSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciBpLCBqO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChkYXRhKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Zm9yIChpIGluIGRhdGEpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoZGF0YS5oYXNPd25Qcm9wZXJ0eShpKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuX2RhdGEubWFzc2xvYWRbaV0gPSBkYXRhW2ldO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGZvciAoaSA9IDAsIGogPSBub2Rlcy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkb20gPSB0aGlzLmdldF9ub2RlKG5vZGVzW2ldLCB0cnVlKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoZG9tICYmIGRvbS5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkb20ucmVtb3ZlQ2xhc3MoXFxcImpzdHJlZS1sb2FkaW5nXFxcIikuYXR0cignYXJpYS1idXN5JywgZmFsc2UpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cGFyZW50Ll9sb2FkX25vZGVzLmNhbGwodGhpcywgbm9kZXMsIGNhbGxiYWNrLCBpc19jYWxsYmFjaywgZm9yY2VfcmVsb2FkKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9LCB0aGlzKSk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmICgodHlwZW9mIHMgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHMpKSA9PT0gJ29iamVjdCcgJiYgcyAmJiBzLnVybCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHMgPSAkLmV4dGVuZCh0cnVlLCB7fSwgcyk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCQuaXNGdW5jdGlvbihzLnVybCkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzLnVybCA9IHMudXJsLmNhbGwodGhpcywgdG9Mb2FkKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCQuaXNGdW5jdGlvbihzLmRhdGEpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cy5kYXRhID0gcy5kYXRhLmNhbGwodGhpcywgdG9Mb2FkKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuICQuYWpheChzKS5kb25lKCQucHJveHkoZnVuY3Rpb24gKGRhdGEsIHQsIHgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgaSwgajtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoZGF0YSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGZvciAoaSBpbiBkYXRhKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKGRhdGEuaGFzT3duUHJvcGVydHkoaSkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl9kYXRhLm1hc3Nsb2FkW2ldID0gZGF0YVtpXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRmb3IgKGkgPSAwLCBqID0gbm9kZXMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZG9tID0gdGhpcy5nZXRfbm9kZShub2Rlc1tpXSwgdHJ1ZSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKGRvbSAmJiBkb20ubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZG9tLnJlbW92ZUNsYXNzKFxcXCJqc3RyZWUtbG9hZGluZ1xcXCIpLmF0dHIoJ2FyaWEtYnVzeScsIGZhbHNlKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHBhcmVudC5fbG9hZF9ub2Rlcy5jYWxsKHRoaXMsIG5vZGVzLCBjYWxsYmFjaywgaXNfY2FsbGJhY2ssIGZvcmNlX3JlbG9hZCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSwgdGhpcykpLmZhaWwoJC5wcm94eShmdW5jdGlvbiAoZikge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHBhcmVudC5fbG9hZF9ub2Rlcy5jYWxsKHRoaXMsIG5vZGVzLCBjYWxsYmFjaywgaXNfY2FsbGJhY2ssIGZvcmNlX3JlbG9hZCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSwgdGhpcykpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiBwYXJlbnQuX2xvYWRfbm9kZXMuY2FsbCh0aGlzLCBub2RlcywgY2FsbGJhY2ssIGlzX2NhbGxiYWNrLCBmb3JjZV9yZWxvYWQpO1xcblxcdFxcdH07XFxuXFx0XFx0dGhpcy5fbG9hZF9ub2RlID0gZnVuY3Rpb24gKG9iaiwgY2FsbGJhY2spIHtcXG5cXHRcXHRcXHR2YXIgZGF0YSA9IHRoaXMuX2RhdGEubWFzc2xvYWRbb2JqLmlkXSxcXG5cXHRcXHRcXHQgICAgcnNsdCA9IG51bGwsXFxuXFx0XFx0XFx0ICAgIGRvbTtcXG5cXHRcXHRcXHRpZiAoZGF0YSkge1xcblxcdFxcdFxcdFxcdHJzbHQgPSB0aGlzW3R5cGVvZiBkYXRhID09PSAnc3RyaW5nJyA/ICdfYXBwZW5kX2h0bWxfZGF0YScgOiAnX2FwcGVuZF9qc29uX2RhdGEnXShvYmosIHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyA/ICQoJC5wYXJzZUhUTUwoZGF0YSkpLmZpbHRlcihmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMubm9kZVR5cGUgIT09IDM7XFxuXFx0XFx0XFx0XFx0fSkgOiBkYXRhLCBmdW5jdGlvbiAoc3RhdHVzKSB7XFxuXFx0XFx0XFx0XFx0XFx0Y2FsbGJhY2suY2FsbCh0aGlzLCBzdGF0dXMpO1xcblxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdFxcdGRvbSA9IHRoaXMuZ2V0X25vZGUob2JqLmlkLCB0cnVlKTtcXG5cXHRcXHRcXHRcXHRpZiAoZG9tICYmIGRvbS5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRcXHRkb20ucmVtb3ZlQ2xhc3MoXFxcImpzdHJlZS1sb2FkaW5nXFxcIikuYXR0cignYXJpYS1idXN5JywgZmFsc2UpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRkZWxldGUgdGhpcy5fZGF0YS5tYXNzbG9hZFtvYmouaWRdO1xcblxcdFxcdFxcdFxcdHJldHVybiByc2x0O1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gcGFyZW50Ll9sb2FkX25vZGUuY2FsbCh0aGlzLCBvYmosIGNhbGxiYWNrKTtcXG5cXHRcXHR9O1xcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqICMjIyBTZWFyY2ggcGx1Z2luXFxuICAqXFxuICAqIEFkZHMgc2VhcmNoIGZ1bmN0aW9uYWxpdHkgdG8ganNUcmVlLlxcbiAgKi9cXG5cXG5cXHQvKipcXG4gICogc3RvcmVzIGFsbCBkZWZhdWx0cyBmb3IgdGhlIHNlYXJjaCBwbHVnaW5cXG4gICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuc2VhcmNoXFxuICAqIEBwbHVnaW4gc2VhcmNoXFxuICAqL1xcblxcdCQuanN0cmVlLmRlZmF1bHRzLnNlYXJjaCA9IHtcXG5cXHRcXHQvKipcXG4gICAqIGEgalF1ZXJ5LWxpa2UgQUpBWCBjb25maWcsIHdoaWNoIGpzdHJlZSB1c2VzIGlmIGEgc2VydmVyIHNob3VsZCBiZSBxdWVyaWVkIGZvciByZXN1bHRzLlxcbiAgICpcXG4gICAqIEEgYHN0cmAgKHdoaWNoIGlzIHRoZSBzZWFyY2ggc3RyaW5nKSBwYXJhbWV0ZXIgd2lsbCBiZSBhZGRlZCB3aXRoIHRoZSByZXF1ZXN0LCBhbiBvcHRpb25hbCBgaW5zaWRlYCBwYXJhbWV0ZXIgd2lsbCBiZSBhZGRlZCBpZiB0aGUgc2VhcmNoIGlzIGxpbWl0ZWQgdG8gYSBub2RlIGlkLiBUaGUgZXhwZWN0ZWQgcmVzdWx0IGlzIGEgSlNPTiBhcnJheSB3aXRoIG5vZGVzIHRoYXQgbmVlZCB0byBiZSBvcGVuZWQgc28gdGhhdCBtYXRjaGluZyBub2RlcyB3aWxsIGJlIHJldmVhbGVkLlxcbiAgICogTGVhdmUgdGhpcyBzZXR0aW5nIGFzIGBmYWxzZWAgdG8gbm90IHF1ZXJ5IHRoZSBzZXJ2ZXIuIFlvdSBjYW4gYWxzbyBzZXQgdGhpcyB0byBhIGZ1bmN0aW9uLCB3aGljaCB3aWxsIGJlIGludm9rZWQgaW4gdGhlIGluc3RhbmNlJ3Mgc2NvcGUgYW5kIHJlY2VpdmUgMyBwYXJhbWV0ZXJzIC0gdGhlIHNlYXJjaCBzdHJpbmcsIHRoZSBjYWxsYmFjayB0byBjYWxsIHdpdGggdGhlIGFycmF5IG9mIG5vZGVzIHRvIGxvYWQsIGFuZCB0aGUgb3B0aW9uYWwgbm9kZSBJRCB0byBsaW1pdCB0aGUgc2VhcmNoIHRvXFxuICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5zZWFyY2guYWpheFxcbiAgICogQHBsdWdpbiBzZWFyY2hcXG4gICAqL1xcblxcdFxcdGFqYXg6IGZhbHNlLFxcblxcdFxcdC8qKlxcbiAgICogSW5kaWNhdGVzIGlmIHRoZSBzZWFyY2ggc2hvdWxkIGJlIGZ1enp5IG9yIG5vdCAoc2hvdWxkIGBjaG5kM2AgbWF0Y2ggYGNoaWxkIG5vZGUgM2ApLiBEZWZhdWx0IGlzIGBmYWxzZWAuXFxuICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5zZWFyY2guZnV6enlcXG4gICAqIEBwbHVnaW4gc2VhcmNoXFxuICAgKi9cXG5cXHRcXHRmdXp6eTogZmFsc2UsXFxuXFx0XFx0LyoqXFxuICAgKiBJbmRpY2F0ZXMgaWYgdGhlIHNlYXJjaCBzaG91bGQgYmUgY2FzZSBzZW5zaXRpdmUuIERlZmF1bHQgaXMgYGZhbHNlYC5cXG4gICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLnNlYXJjaC5jYXNlX3NlbnNpdGl2ZVxcbiAgICogQHBsdWdpbiBzZWFyY2hcXG4gICAqL1xcblxcdFxcdGNhc2Vfc2Vuc2l0aXZlOiBmYWxzZSxcXG5cXHRcXHQvKipcXG4gICAqIEluZGljYXRlcyBpZiB0aGUgdHJlZSBzaG91bGQgYmUgZmlsdGVyZWQgKGJ5IGRlZmF1bHQpIHRvIHNob3cgb25seSBtYXRjaGluZyBub2RlcyAoa2VlcCBpbiBtaW5kIHRoaXMgY2FuIGJlIGEgaGVhdnkgb24gbGFyZ2UgdHJlZXMgaW4gb2xkIGJyb3dzZXJzKS5cXG4gICAqIFRoaXMgc2V0dGluZyBjYW4gYmUgY2hhbmdlZCBhdCBydW50aW1lIHdoZW4gY2FsbGluZyB0aGUgc2VhcmNoIG1ldGhvZC4gRGVmYXVsdCBpcyBgZmFsc2VgLlxcbiAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuc2VhcmNoLnNob3dfb25seV9tYXRjaGVzXFxuICAgKiBAcGx1Z2luIHNlYXJjaFxcbiAgICovXFxuXFx0XFx0c2hvd19vbmx5X21hdGNoZXM6IGZhbHNlLFxcblxcdFxcdC8qKlxcbiAgICogSW5kaWNhdGVzIGlmIHRoZSBjaGlsZHJlbiBvZiBtYXRjaGVkIGVsZW1lbnQgYXJlIHNob3duICh3aGVuIHNob3dfb25seV9tYXRjaGVzIGlzIHRydWUpXFxuICAgKiBUaGlzIHNldHRpbmcgY2FuIGJlIGNoYW5nZWQgYXQgcnVudGltZSB3aGVuIGNhbGxpbmcgdGhlIHNlYXJjaCBtZXRob2QuIERlZmF1bHQgaXMgYGZhbHNlYC5cXG4gICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLnNlYXJjaC5zaG93X29ubHlfbWF0Y2hlc19jaGlsZHJlblxcbiAgICogQHBsdWdpbiBzZWFyY2hcXG4gICAqL1xcblxcdFxcdHNob3dfb25seV9tYXRjaGVzX2NoaWxkcmVuOiBmYWxzZSxcXG5cXHRcXHQvKipcXG4gICAqIEluZGljYXRlcyBpZiBhbGwgbm9kZXMgb3BlbmVkIHRvIHJldmVhbCB0aGUgc2VhcmNoIHJlc3VsdCwgc2hvdWxkIGJlIGNsb3NlZCB3aGVuIHRoZSBzZWFyY2ggaXMgY2xlYXJlZCBvciBhIG5ldyBzZWFyY2ggaXMgcGVyZm9ybWVkLiBEZWZhdWx0IGlzIGB0cnVlYC5cXG4gICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLnNlYXJjaC5jbG9zZV9vcGVuZWRfb25jbGVhclxcbiAgICogQHBsdWdpbiBzZWFyY2hcXG4gICAqL1xcblxcdFxcdGNsb3NlX29wZW5lZF9vbmNsZWFyOiB0cnVlLFxcblxcdFxcdC8qKlxcbiAgICogSW5kaWNhdGVzIGlmIG9ubHkgbGVhZiBub2RlcyBzaG91bGQgYmUgaW5jbHVkZWQgaW4gc2VhcmNoIHJlc3VsdHMuIERlZmF1bHQgaXMgYGZhbHNlYC5cXG4gICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLnNlYXJjaC5zZWFyY2hfbGVhdmVzX29ubHlcXG4gICAqIEBwbHVnaW4gc2VhcmNoXFxuICAgKi9cXG5cXHRcXHRzZWFyY2hfbGVhdmVzX29ubHk6IGZhbHNlLFxcblxcdFxcdC8qKlxcbiAgICogSWYgc2V0IHRvIGEgZnVuY3Rpb24gaXQgd2lsIGJlIGNhbGxlZCBpbiB0aGUgaW5zdGFuY2UncyBzY29wZSB3aXRoIHR3byBhcmd1bWVudHMgLSBzZWFyY2ggc3RyaW5nIGFuZCBub2RlICh3aGVyZSBub2RlIHdpbGwgYmUgZXZlcnkgbm9kZSBpbiB0aGUgc3RydWN0dXJlLCBzbyB1c2Ugd2l0aCBjYXV0aW9uKS5cXG4gICAqIElmIHRoZSBmdW5jdGlvbiByZXR1cm5zIGEgdHJ1dGh5IHZhbHVlIHRoZSBub2RlIHdpbGwgYmUgY29uc2lkZXJlZCBhIG1hdGNoIChpdCBtaWdodCBub3QgYmUgZGlzcGxheWVkIGlmIHNlYXJjaF9vbmx5X2xlYXZlcyBpcyBzZXQgdG8gdHJ1ZSBhbmQgdGhlIG5vZGUgaXMgbm90IGEgbGVhZikuIERlZmF1bHQgaXMgYGZhbHNlYC5cXG4gICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLnNlYXJjaC5zZWFyY2hfY2FsbGJhY2tcXG4gICAqIEBwbHVnaW4gc2VhcmNoXFxuICAgKi9cXG5cXHRcXHRzZWFyY2hfY2FsbGJhY2s6IGZhbHNlXFxuXFx0fTtcXG5cXG5cXHQkLmpzdHJlZS5wbHVnaW5zLnNlYXJjaCA9IGZ1bmN0aW9uIChvcHRpb25zLCBwYXJlbnQpIHtcXG5cXHRcXHR0aGlzLmJpbmQgPSBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0cGFyZW50LmJpbmQuY2FsbCh0aGlzKTtcXG5cXG5cXHRcXHRcXHR0aGlzLl9kYXRhLnNlYXJjaC5zdHIgPSBcXFwiXFxcIjtcXG5cXHRcXHRcXHR0aGlzLl9kYXRhLnNlYXJjaC5kb20gPSAkKCk7XFxuXFx0XFx0XFx0dGhpcy5fZGF0YS5zZWFyY2gucmVzID0gW107XFxuXFx0XFx0XFx0dGhpcy5fZGF0YS5zZWFyY2gub3BuID0gW107XFxuXFx0XFx0XFx0dGhpcy5fZGF0YS5zZWFyY2guc29tID0gZmFsc2U7XFxuXFx0XFx0XFx0dGhpcy5fZGF0YS5zZWFyY2guc21jID0gZmFsc2U7XFxuXFx0XFx0XFx0dGhpcy5fZGF0YS5zZWFyY2guaGRuID0gW107XFxuXFxuXFx0XFx0XFx0dGhpcy5lbGVtZW50Lm9uKFxcXCJzZWFyY2guanN0cmVlXFxcIiwgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xcblxcdFxcdFxcdFxcdGlmICh0aGlzLl9kYXRhLnNlYXJjaC5zb20gJiYgZGF0YS5yZXMubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIG0gPSB0aGlzLl9tb2RlbC5kYXRhLFxcblxcdFxcdFxcdFxcdFxcdCAgICBpLFxcblxcdFxcdFxcdFxcdFxcdCAgICBqLFxcblxcdFxcdFxcdFxcdFxcdCAgICBwID0gW10sXFxuXFx0XFx0XFx0XFx0XFx0ICAgIGssXFxuXFx0XFx0XFx0XFx0XFx0ICAgIGw7XFxuXFx0XFx0XFx0XFx0XFx0Zm9yIChpID0gMCwgaiA9IGRhdGEucmVzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChtW2RhdGEucmVzW2ldXSAmJiAhbVtkYXRhLnJlc1tpXV0uc3RhdGUuaGlkZGVuKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cC5wdXNoKGRhdGEucmVzW2ldKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRwID0gcC5jb25jYXQobVtkYXRhLnJlc1tpXV0ucGFyZW50cyk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKHRoaXMuX2RhdGEuc2VhcmNoLnNtYykge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGZvciAoayA9IDAsIGwgPSBtW2RhdGEucmVzW2ldXS5jaGlsZHJlbl9kLmxlbmd0aDsgayA8IGw7IGsrKykge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChtW21bZGF0YS5yZXNbaV1dLmNoaWxkcmVuX2Rba11dICYmICFtW21bZGF0YS5yZXNbaV1dLmNoaWxkcmVuX2Rba11dLnN0YXRlLmhpZGRlbikge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHAucHVzaChtW2RhdGEucmVzW2ldXS5jaGlsZHJlbl9kW2tdKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdHAgPSAkLnZha2F0YS5hcnJheV9yZW1vdmVfaXRlbSgkLnZha2F0YS5hcnJheV91bmlxdWUocCksICQuanN0cmVlLnJvb3QpO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX2RhdGEuc2VhcmNoLmhkbiA9IHRoaXMuaGlkZV9hbGwodHJ1ZSk7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5zaG93X25vZGUocCwgdHJ1ZSk7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5yZWRyYXcodHJ1ZSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sIHRoaXMpKS5vbihcXFwiY2xlYXJfc2VhcmNoLmpzdHJlZVxcXCIsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcXG5cXHRcXHRcXHRcXHRpZiAodGhpcy5fZGF0YS5zZWFyY2guc29tICYmIGRhdGEucmVzLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuc2hvd19ub2RlKHRoaXMuX2RhdGEuc2VhcmNoLmhkbiwgdHJ1ZSk7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5yZWRyYXcodHJ1ZSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sIHRoaXMpKTtcXG5cXHRcXHR9O1xcblxcdFxcdC8qKlxcbiAgICogdXNlZCB0byBzZWFyY2ggdGhlIHRyZWUgbm9kZXMgZm9yIGEgZ2l2ZW4gc3RyaW5nXFxuICAgKiBAbmFtZSBzZWFyY2goc3RyIFssIHNraXBfYXN5bmNdKVxcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciB0aGUgc2VhcmNoIHN0cmluZ1xcbiAgICogQHBhcmFtIHtCb29sZWFufSBza2lwX2FzeW5jIGlmIHNldCB0byB0cnVlIHNlcnZlciB3aWxsIG5vdCBiZSBxdWVyaWVkIGV2ZW4gaWYgY29uZmlndXJlZFxcbiAgICogQHBhcmFtIHtCb29sZWFufSBzaG93X29ubHlfbWF0Y2hlcyBpZiBzZXQgdG8gdHJ1ZSBvbmx5IG1hdGNoaW5nIG5vZGVzIHdpbGwgYmUgc2hvd24gKGtlZXAgaW4gbWluZCB0aGlzIGNhbiBiZSB2ZXJ5IHNsb3cgb24gbGFyZ2UgdHJlZXMgb3Igb2xkIGJyb3dzZXJzKVxcbiAgICogQHBhcmFtIHttaXhlZH0gaW5zaWRlIGFuIG9wdGlvbmFsIG5vZGUgdG8gd2hvc2UgY2hpbGRyZW4gdG8gbGltaXQgdGhlIHNlYXJjaFxcbiAgICogQHBhcmFtIHtCb29sZWFufSBhcHBlbmQgaWYgc2V0IHRvIHRydWUgdGhlIHJlc3VsdHMgb2YgdGhpcyBzZWFyY2ggYXJlIGFwcGVuZGVkIHRvIHRoZSBwcmV2aW91cyBzZWFyY2hcXG4gICAqIEBwbHVnaW4gc2VhcmNoXFxuICAgKiBAdHJpZ2dlciBzZWFyY2guanN0cmVlXFxuICAgKi9cXG5cXHRcXHR0aGlzLnNlYXJjaCA9IGZ1bmN0aW9uIChzdHIsIHNraXBfYXN5bmMsIHNob3dfb25seV9tYXRjaGVzLCBpbnNpZGUsIGFwcGVuZCwgc2hvd19vbmx5X21hdGNoZXNfY2hpbGRyZW4pIHtcXG5cXHRcXHRcXHRpZiAoc3RyID09PSBmYWxzZSB8fCAkLnRyaW0oc3RyLnRvU3RyaW5nKCkpID09PSBcXFwiXFxcIikge1xcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLmNsZWFyX3NlYXJjaCgpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpbnNpZGUgPSB0aGlzLmdldF9ub2RlKGluc2lkZSk7XFxuXFx0XFx0XFx0aW5zaWRlID0gaW5zaWRlICYmIGluc2lkZS5pZCA/IGluc2lkZS5pZCA6IG51bGw7XFxuXFx0XFx0XFx0c3RyID0gc3RyLnRvU3RyaW5nKCk7XFxuXFx0XFx0XFx0dmFyIHMgPSB0aGlzLnNldHRpbmdzLnNlYXJjaCxcXG5cXHRcXHRcXHQgICAgYSA9IHMuYWpheCA/IHMuYWpheCA6IGZhbHNlLFxcblxcdFxcdFxcdCAgICBtID0gdGhpcy5fbW9kZWwuZGF0YSxcXG5cXHRcXHRcXHQgICAgZiA9IG51bGwsXFxuXFx0XFx0XFx0ICAgIHIgPSBbXSxcXG5cXHRcXHRcXHQgICAgcCA9IFtdLFxcblxcdFxcdFxcdCAgICBpLFxcblxcdFxcdFxcdCAgICBqO1xcblxcdFxcdFxcdGlmICh0aGlzLl9kYXRhLnNlYXJjaC5yZXMubGVuZ3RoICYmICFhcHBlbmQpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLmNsZWFyX3NlYXJjaCgpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoc2hvd19vbmx5X21hdGNoZXMgPT09IHVuZGVmaW5lZCkge1xcblxcdFxcdFxcdFxcdHNob3dfb25seV9tYXRjaGVzID0gcy5zaG93X29ubHlfbWF0Y2hlcztcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKHNob3dfb25seV9tYXRjaGVzX2NoaWxkcmVuID09PSB1bmRlZmluZWQpIHtcXG5cXHRcXHRcXHRcXHRzaG93X29ubHlfbWF0Y2hlc19jaGlsZHJlbiA9IHMuc2hvd19vbmx5X21hdGNoZXNfY2hpbGRyZW47XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICghc2tpcF9hc3luYyAmJiBhICE9PSBmYWxzZSkge1xcblxcdFxcdFxcdFxcdGlmICgkLmlzRnVuY3Rpb24oYSkpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gYS5jYWxsKHRoaXMsIHN0ciwgJC5wcm94eShmdW5jdGlvbiAoZCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChkICYmIGQuZCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGQgPSBkLmQ7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuX2xvYWRfbm9kZXMoISQuaXNBcnJheShkKSA/IFtdIDogJC52YWthdGEuYXJyYXlfdW5pcXVlKGQpLCBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5zZWFyY2goc3RyLCB0cnVlLCBzaG93X29ubHlfbWF0Y2hlcywgaW5zaWRlLCBhcHBlbmQsIHNob3dfb25seV9tYXRjaGVzX2NoaWxkcmVuKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcXHRcXHR9LCB0aGlzKSwgaW5zaWRlKTtcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdGEgPSAkLmV4dGVuZCh7fSwgYSk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCFhLmRhdGEpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRhLmRhdGEgPSB7fTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0YS5kYXRhLnN0ciA9IHN0cjtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoaW5zaWRlKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YS5kYXRhLmluc2lkZSA9IGluc2lkZTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHRoaXMuX2RhdGEuc2VhcmNoLmxhc3RSZXF1ZXN0KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5fZGF0YS5zZWFyY2gubGFzdFJlcXVlc3QuYWJvcnQoKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fZGF0YS5zZWFyY2gubGFzdFJlcXVlc3QgPSAkLmFqYXgoYSkuZmFpbCgkLnByb3h5KGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvciA9IHsgJ2Vycm9yJzogJ2FqYXgnLCAncGx1Z2luJzogJ3NlYXJjaCcsICdpZCc6ICdzZWFyY2hfMDEnLCAncmVhc29uJzogJ0NvdWxkIG5vdCBsb2FkIHNlYXJjaCBwYXJlbnRzJywgJ2RhdGEnOiBKU09OLnN0cmluZ2lmeShhKSB9O1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuc2V0dGluZ3MuY29yZS5lcnJvci5jYWxsKHRoaXMsIHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yKTtcXG5cXHRcXHRcXHRcXHRcXHR9LCB0aGlzKSkuZG9uZSgkLnByb3h5KGZ1bmN0aW9uIChkKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKGQgJiYgZC5kKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZCA9IGQuZDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5fbG9hZF9ub2RlcyghJC5pc0FycmF5KGQpID8gW10gOiAkLnZha2F0YS5hcnJheV91bmlxdWUoZCksIGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLnNlYXJjaChzdHIsIHRydWUsIHNob3dfb25seV9tYXRjaGVzLCBpbnNpZGUsIGFwcGVuZCwgc2hvd19vbmx5X21hdGNoZXNfY2hpbGRyZW4pO1xcblxcdFxcdFxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdFxcdFxcdH0sIHRoaXMpKTtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5fZGF0YS5zZWFyY2gubGFzdFJlcXVlc3Q7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoIWFwcGVuZCkge1xcblxcdFxcdFxcdFxcdHRoaXMuX2RhdGEuc2VhcmNoLnN0ciA9IHN0cjtcXG5cXHRcXHRcXHRcXHR0aGlzLl9kYXRhLnNlYXJjaC5kb20gPSAkKCk7XFxuXFx0XFx0XFx0XFx0dGhpcy5fZGF0YS5zZWFyY2gucmVzID0gW107XFxuXFx0XFx0XFx0XFx0dGhpcy5fZGF0YS5zZWFyY2gub3BuID0gW107XFxuXFx0XFx0XFx0XFx0dGhpcy5fZGF0YS5zZWFyY2guc29tID0gc2hvd19vbmx5X21hdGNoZXM7XFxuXFx0XFx0XFx0XFx0dGhpcy5fZGF0YS5zZWFyY2guc21jID0gc2hvd19vbmx5X21hdGNoZXNfY2hpbGRyZW47XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGYgPSBuZXcgJC52YWthdGEuc2VhcmNoKHN0ciwgdHJ1ZSwgeyBjYXNlU2Vuc2l0aXZlOiBzLmNhc2Vfc2Vuc2l0aXZlLCBmdXp6eTogcy5mdXp6eSB9KTtcXG5cXHRcXHRcXHQkLmVhY2gobVtpbnNpZGUgPyBpbnNpZGUgOiAkLmpzdHJlZS5yb290XS5jaGlsZHJlbl9kLCBmdW5jdGlvbiAoaWksIGkpIHtcXG5cXHRcXHRcXHRcXHR2YXIgdiA9IG1baV07XFxuXFx0XFx0XFx0XFx0aWYgKHYudGV4dCAmJiAhdi5zdGF0ZS5oaWRkZW4gJiYgKCFzLnNlYXJjaF9sZWF2ZXNfb25seSB8fCB2LnN0YXRlLmxvYWRlZCAmJiB2LmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkgJiYgKHMuc2VhcmNoX2NhbGxiYWNrICYmIHMuc2VhcmNoX2NhbGxiYWNrLmNhbGwodGhpcywgc3RyLCB2KSB8fCAhcy5zZWFyY2hfY2FsbGJhY2sgJiYgZi5zZWFyY2godi50ZXh0KS5pc01hdGNoKSkge1xcblxcdFxcdFxcdFxcdFxcdHIucHVzaChpKTtcXG5cXHRcXHRcXHRcXHRcXHRwID0gcC5jb25jYXQodi5wYXJlbnRzKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0aWYgKHIubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0cCA9ICQudmFrYXRhLmFycmF5X3VuaXF1ZShwKTtcXG5cXHRcXHRcXHRcXHRmb3IgKGkgPSAwLCBqID0gcC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAocFtpXSAhPT0gJC5qc3RyZWUucm9vdCAmJiBtW3BbaV1dICYmIHRoaXMub3Blbl9ub2RlKHBbaV0sIG51bGwsIDApID09PSB0cnVlKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5fZGF0YS5zZWFyY2gub3BuLnB1c2gocFtpXSk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRpZiAoIWFwcGVuZCkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX2RhdGEuc2VhcmNoLmRvbSA9ICQodGhpcy5lbGVtZW50WzBdLnF1ZXJ5U2VsZWN0b3JBbGwoJyMnICsgJC5tYXAociwgZnVuY3Rpb24gKHYpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gXFxcIjAxMjM0NTY3ODlcXFwiLmluZGV4T2YodlswXSkgIT09IC0xID8gJ1xcXFxcXFxcMycgKyB2WzBdICsgJyAnICsgdi5zdWJzdHIoMSkucmVwbGFjZSgkLmpzdHJlZS5pZHJlZ2V4LCAnXFxcXFxcXFwkJicpIDogdi5yZXBsYWNlKCQuanN0cmVlLmlkcmVnZXgsICdcXFxcXFxcXCQmJyk7XFxuXFx0XFx0XFx0XFx0XFx0fSkuam9pbignLCAjJykpKTtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9kYXRhLnNlYXJjaC5yZXMgPSByO1xcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fZGF0YS5zZWFyY2guZG9tID0gdGhpcy5fZGF0YS5zZWFyY2guZG9tLmFkZCgkKHRoaXMuZWxlbWVudFswXS5xdWVyeVNlbGVjdG9yQWxsKCcjJyArICQubWFwKHIsIGZ1bmN0aW9uICh2KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIFxcXCIwMTIzNDU2Nzg5XFxcIi5pbmRleE9mKHZbMF0pICE9PSAtMSA/ICdcXFxcXFxcXDMnICsgdlswXSArICcgJyArIHYuc3Vic3RyKDEpLnJlcGxhY2UoJC5qc3RyZWUuaWRyZWdleCwgJ1xcXFxcXFxcJCYnKSA6IHYucmVwbGFjZSgkLmpzdHJlZS5pZHJlZ2V4LCAnXFxcXFxcXFwkJicpO1xcblxcdFxcdFxcdFxcdFxcdH0pLmpvaW4oJywgIycpKSkpO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX2RhdGEuc2VhcmNoLnJlcyA9ICQudmFrYXRhLmFycmF5X3VuaXF1ZSh0aGlzLl9kYXRhLnNlYXJjaC5yZXMuY29uY2F0KHIpKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0dGhpcy5fZGF0YS5zZWFyY2guZG9tLmNoaWxkcmVuKFxcXCIuanN0cmVlLWFuY2hvclxcXCIpLmFkZENsYXNzKCdqc3RyZWUtc2VhcmNoJyk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdC8qKlxcbiAgICAqIHRyaWdnZXJlZCBhZnRlciBzZWFyY2ggaXMgY29tcGxldGVcXG4gICAgKiBAZXZlbnRcXG4gICAgKiBAbmFtZSBzZWFyY2guanN0cmVlXFxuICAgICogQHBhcmFtIHtqUXVlcnl9IG5vZGVzIGEgalF1ZXJ5IGNvbGxlY3Rpb24gb2YgbWF0Y2hpbmcgbm9kZXNcXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIHRoZSBzZWFyY2ggc3RyaW5nXFxuICAgICogQHBhcmFtIHtBcnJheX0gcmVzIGEgY29sbGVjdGlvbiBvZiBvYmplY3RzIHJlcHJlc2VpbmcgdGhlIG1hdGNoaW5nIG5vZGVzXFxuICAgICogQHBsdWdpbiBzZWFyY2hcXG4gICAgKi9cXG5cXHRcXHRcXHR0aGlzLnRyaWdnZXIoJ3NlYXJjaCcsIHsgbm9kZXM6IHRoaXMuX2RhdGEuc2VhcmNoLmRvbSwgc3RyOiBzdHIsIHJlczogdGhpcy5fZGF0YS5zZWFyY2gucmVzLCBzaG93X29ubHlfbWF0Y2hlczogc2hvd19vbmx5X21hdGNoZXMgfSk7XFxuXFx0XFx0fTtcXG5cXHRcXHQvKipcXG4gICAqIHVzZWQgdG8gY2xlYXIgdGhlIGxhc3Qgc2VhcmNoIChyZW1vdmVzIGNsYXNzZXMgYW5kIHNob3dzIGFsbCBub2RlcyBpZiBmaWx0ZXJpbmcgaXMgb24pXFxuICAgKiBAbmFtZSBjbGVhcl9zZWFyY2goKVxcbiAgICogQHBsdWdpbiBzZWFyY2hcXG4gICAqIEB0cmlnZ2VyIGNsZWFyX3NlYXJjaC5qc3RyZWVcXG4gICAqL1xcblxcdFxcdHRoaXMuY2xlYXJfc2VhcmNoID0gZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdGlmICh0aGlzLnNldHRpbmdzLnNlYXJjaC5jbG9zZV9vcGVuZWRfb25jbGVhcikge1xcblxcdFxcdFxcdFxcdHRoaXMuY2xvc2Vfbm9kZSh0aGlzLl9kYXRhLnNlYXJjaC5vcG4sIDApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHQvKipcXG4gICAgKiB0cmlnZ2VyZWQgYWZ0ZXIgc2VhcmNoIGlzIGNvbXBsZXRlXFxuICAgICogQGV2ZW50XFxuICAgICogQG5hbWUgY2xlYXJfc2VhcmNoLmpzdHJlZVxcbiAgICAqIEBwYXJhbSB7alF1ZXJ5fSBub2RlcyBhIGpRdWVyeSBjb2xsZWN0aW9uIG9mIG1hdGNoaW5nIG5vZGVzICh0aGUgcmVzdWx0IGZyb20gdGhlIGxhc3Qgc2VhcmNoKVxcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgdGhlIHNlYXJjaCBzdHJpbmcgKHRoZSBsYXN0IHNlYXJjaCBzdHJpbmcpXFxuICAgICogQHBhcmFtIHtBcnJheX0gcmVzIGEgY29sbGVjdGlvbiBvZiBvYmplY3RzIHJlcHJlc2VpbmcgdGhlIG1hdGNoaW5nIG5vZGVzICh0aGUgcmVzdWx0IGZyb20gdGhlIGxhc3Qgc2VhcmNoKVxcbiAgICAqIEBwbHVnaW4gc2VhcmNoXFxuICAgICovXFxuXFx0XFx0XFx0dGhpcy50cmlnZ2VyKCdjbGVhcl9zZWFyY2gnLCB7ICdub2Rlcyc6IHRoaXMuX2RhdGEuc2VhcmNoLmRvbSwgc3RyOiB0aGlzLl9kYXRhLnNlYXJjaC5zdHIsIHJlczogdGhpcy5fZGF0YS5zZWFyY2gucmVzIH0pO1xcblxcdFxcdFxcdGlmICh0aGlzLl9kYXRhLnNlYXJjaC5yZXMubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5fZGF0YS5zZWFyY2guZG9tID0gJCh0aGlzLmVsZW1lbnRbMF0ucXVlcnlTZWxlY3RvckFsbCgnIycgKyAkLm1hcCh0aGlzLl9kYXRhLnNlYXJjaC5yZXMsIGZ1bmN0aW9uICh2KSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIFxcXCIwMTIzNDU2Nzg5XFxcIi5pbmRleE9mKHZbMF0pICE9PSAtMSA/ICdcXFxcXFxcXDMnICsgdlswXSArICcgJyArIHYuc3Vic3RyKDEpLnJlcGxhY2UoJC5qc3RyZWUuaWRyZWdleCwgJ1xcXFxcXFxcJCYnKSA6IHYucmVwbGFjZSgkLmpzdHJlZS5pZHJlZ2V4LCAnXFxcXFxcXFwkJicpO1xcblxcdFxcdFxcdFxcdH0pLmpvaW4oJywgIycpKSk7XFxuXFx0XFx0XFx0XFx0dGhpcy5fZGF0YS5zZWFyY2guZG9tLmNoaWxkcmVuKFxcXCIuanN0cmVlLWFuY2hvclxcXCIpLnJlbW92ZUNsYXNzKFxcXCJqc3RyZWUtc2VhcmNoXFxcIik7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHRoaXMuX2RhdGEuc2VhcmNoLnN0ciA9IFxcXCJcXFwiO1xcblxcdFxcdFxcdHRoaXMuX2RhdGEuc2VhcmNoLnJlcyA9IFtdO1xcblxcdFxcdFxcdHRoaXMuX2RhdGEuc2VhcmNoLm9wbiA9IFtdO1xcblxcdFxcdFxcdHRoaXMuX2RhdGEuc2VhcmNoLmRvbSA9ICQoKTtcXG5cXHRcXHR9O1xcblxcblxcdFxcdHRoaXMucmVkcmF3X25vZGUgPSBmdW5jdGlvbiAob2JqLCBkZWVwLCBjYWxsYmFjaywgZm9yY2VfcmVuZGVyKSB7XFxuXFx0XFx0XFx0b2JqID0gcGFyZW50LnJlZHJhd19ub2RlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuXFx0XFx0XFx0aWYgKG9iaikge1xcblxcdFxcdFxcdFxcdGlmICgkLmluQXJyYXkob2JqLmlkLCB0aGlzLl9kYXRhLnNlYXJjaC5yZXMpICE9PSAtMSkge1xcblxcdFxcdFxcdFxcdFxcdHZhciBpLFxcblxcdFxcdFxcdFxcdFxcdCAgICBqLFxcblxcdFxcdFxcdFxcdFxcdCAgICB0bXAgPSBudWxsO1xcblxcdFxcdFxcdFxcdFxcdGZvciAoaSA9IDAsIGogPSBvYmouY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAob2JqLmNoaWxkTm9kZXNbaV0gJiYgb2JqLmNoaWxkTm9kZXNbaV0uY2xhc3NOYW1lICYmIG9iai5jaGlsZE5vZGVzW2ldLmNsYXNzTmFtZS5pbmRleE9mKFxcXCJqc3RyZWUtYW5jaG9yXFxcIikgIT09IC0xKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dG1wID0gb2JqLmNoaWxkTm9kZXNbaV07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRpZiAodG1wKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dG1wLmNsYXNzTmFtZSArPSAnIGpzdHJlZS1zZWFyY2gnO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiBvYmo7XFxuXFx0XFx0fTtcXG5cXHR9O1xcblxcblxcdC8vIGhlbHBlcnNcXG5cXHQoZnVuY3Rpb24gKCQpIHtcXG5cXHRcXHQvLyBmcm9tIGh0dHA6Ly9raXJvLm1lL3Byb2plY3RzL2Z1c2UuaHRtbFxcblxcdFxcdCQudmFrYXRhLnNlYXJjaCA9IGZ1bmN0aW9uIChwYXR0ZXJuLCB0eHQsIG9wdGlvbnMpIHtcXG5cXHRcXHRcXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcXG5cXHRcXHRcXHRvcHRpb25zID0gJC5leHRlbmQoe30sICQudmFrYXRhLnNlYXJjaC5kZWZhdWx0cywgb3B0aW9ucyk7XFxuXFx0XFx0XFx0aWYgKG9wdGlvbnMuZnV6enkgIT09IGZhbHNlKSB7XFxuXFx0XFx0XFx0XFx0b3B0aW9ucy5mdXp6eSA9IHRydWU7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHBhdHRlcm4gPSBvcHRpb25zLmNhc2VTZW5zaXRpdmUgPyBwYXR0ZXJuIDogcGF0dGVybi50b0xvd2VyQ2FzZSgpO1xcblxcdFxcdFxcdHZhciBNQVRDSF9MT0NBVElPTiA9IG9wdGlvbnMubG9jYXRpb24sXFxuXFx0XFx0XFx0ICAgIE1BVENIX0RJU1RBTkNFID0gb3B0aW9ucy5kaXN0YW5jZSxcXG5cXHRcXHRcXHQgICAgTUFUQ0hfVEhSRVNIT0xEID0gb3B0aW9ucy50aHJlc2hvbGQsXFxuXFx0XFx0XFx0ICAgIHBhdHRlcm5MZW4gPSBwYXR0ZXJuLmxlbmd0aCxcXG5cXHRcXHRcXHQgICAgbWF0Y2htYXNrLFxcblxcdFxcdFxcdCAgICBwYXR0ZXJuX2FscGhhYmV0LFxcblxcdFxcdFxcdCAgICBtYXRjaF9iaXRhcFNjb3JlLFxcblxcdFxcdFxcdCAgICBzZWFyY2g7XFxuXFx0XFx0XFx0aWYgKHBhdHRlcm5MZW4gPiAzMikge1xcblxcdFxcdFxcdFxcdG9wdGlvbnMuZnV6enkgPSBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKG9wdGlvbnMuZnV6enkpIHtcXG5cXHRcXHRcXHRcXHRtYXRjaG1hc2sgPSAxIDw8IHBhdHRlcm5MZW4gLSAxO1xcblxcdFxcdFxcdFxcdHBhdHRlcm5fYWxwaGFiZXQgPSBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIG1hc2sgPSB7fSxcXG5cXHRcXHRcXHRcXHRcXHQgICAgaSA9IDA7XFxuXFx0XFx0XFx0XFx0XFx0Zm9yIChpID0gMDsgaSA8IHBhdHRlcm5MZW47IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdFxcdG1hc2tbcGF0dGVybi5jaGFyQXQoaSldID0gMDtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0Zm9yIChpID0gMDsgaSA8IHBhdHRlcm5MZW47IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdFxcdG1hc2tbcGF0dGVybi5jaGFyQXQoaSldIHw9IDEgPDwgcGF0dGVybkxlbiAtIGkgLSAxO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gbWFzaztcXG5cXHRcXHRcXHRcXHR9KCk7XFxuXFx0XFx0XFx0XFx0bWF0Y2hfYml0YXBTY29yZSA9IGZ1bmN0aW9uIG1hdGNoX2JpdGFwU2NvcmUoZSwgeCkge1xcblxcdFxcdFxcdFxcdFxcdHZhciBhY2N1cmFjeSA9IGUgLyBwYXR0ZXJuTGVuLFxcblxcdFxcdFxcdFxcdFxcdCAgICBwcm94aW1pdHkgPSBNYXRoLmFicyhNQVRDSF9MT0NBVElPTiAtIHgpO1xcblxcdFxcdFxcdFxcdFxcdGlmICghTUFUQ0hfRElTVEFOQ0UpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gcHJveGltaXR5ID8gMS4wIDogYWNjdXJhY3k7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBhY2N1cmFjeSArIHByb3hpbWl0eSAvIE1BVENIX0RJU1RBTkNFO1xcblxcdFxcdFxcdFxcdH07XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHNlYXJjaCA9IGZ1bmN0aW9uIHNlYXJjaCh0ZXh0KSB7XFxuXFx0XFx0XFx0XFx0dGV4dCA9IG9wdGlvbnMuY2FzZVNlbnNpdGl2ZSA/IHRleHQgOiB0ZXh0LnRvTG93ZXJDYXNlKCk7XFxuXFx0XFx0XFx0XFx0aWYgKHBhdHRlcm4gPT09IHRleHQgfHwgdGV4dC5pbmRleE9mKHBhdHRlcm4pICE9PSAtMSkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aXNNYXRjaDogdHJ1ZSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRzY29yZTogMFxcblxcdFxcdFxcdFxcdFxcdH07XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGlmICghb3B0aW9ucy5mdXp6eSkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aXNNYXRjaDogZmFsc2UsXFxuXFx0XFx0XFx0XFx0XFx0XFx0c2NvcmU6IDFcXG5cXHRcXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR2YXIgaSxcXG5cXHRcXHRcXHRcXHQgICAgaixcXG5cXHRcXHRcXHRcXHQgICAgdGV4dExlbiA9IHRleHQubGVuZ3RoLFxcblxcdFxcdFxcdFxcdCAgICBzY29yZVRocmVzaG9sZCA9IE1BVENIX1RIUkVTSE9MRCxcXG5cXHRcXHRcXHRcXHQgICAgYmVzdExvYyA9IHRleHQuaW5kZXhPZihwYXR0ZXJuLCBNQVRDSF9MT0NBVElPTiksXFxuXFx0XFx0XFx0XFx0ICAgIGJpbk1pbixcXG5cXHRcXHRcXHRcXHQgICAgYmluTWlkLFxcblxcdFxcdFxcdFxcdCAgICBiaW5NYXggPSBwYXR0ZXJuTGVuICsgdGV4dExlbixcXG5cXHRcXHRcXHRcXHQgICAgbGFzdFJkLFxcblxcdFxcdFxcdFxcdCAgICBzdGFydCxcXG5cXHRcXHRcXHRcXHQgICAgZmluaXNoLFxcblxcdFxcdFxcdFxcdCAgICByZCxcXG5cXHRcXHRcXHRcXHQgICAgY2hhck1hdGNoLFxcblxcdFxcdFxcdFxcdCAgICBzY29yZSA9IDEsXFxuXFx0XFx0XFx0XFx0ICAgIGxvY2F0aW9ucyA9IFtdO1xcblxcdFxcdFxcdFxcdGlmIChiZXN0TG9jICE9PSAtMSkge1xcblxcdFxcdFxcdFxcdFxcdHNjb3JlVGhyZXNob2xkID0gTWF0aC5taW4obWF0Y2hfYml0YXBTY29yZSgwLCBiZXN0TG9jKSwgc2NvcmVUaHJlc2hvbGQpO1xcblxcdFxcdFxcdFxcdFxcdGJlc3RMb2MgPSB0ZXh0Lmxhc3RJbmRleE9mKHBhdHRlcm4sIE1BVENIX0xPQ0FUSU9OICsgcGF0dGVybkxlbik7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGJlc3RMb2MgIT09IC0xKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0c2NvcmVUaHJlc2hvbGQgPSBNYXRoLm1pbihtYXRjaF9iaXRhcFNjb3JlKDAsIGJlc3RMb2MpLCBzY29yZVRocmVzaG9sZCk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRiZXN0TG9jID0gLTE7XFxuXFx0XFx0XFx0XFx0Zm9yIChpID0gMDsgaSA8IHBhdHRlcm5MZW47IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdGJpbk1pbiA9IDA7XFxuXFx0XFx0XFx0XFx0XFx0YmluTWlkID0gYmluTWF4O1xcblxcdFxcdFxcdFxcdFxcdHdoaWxlIChiaW5NaW4gPCBiaW5NaWQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAobWF0Y2hfYml0YXBTY29yZShpLCBNQVRDSF9MT0NBVElPTiArIGJpbk1pZCkgPD0gc2NvcmVUaHJlc2hvbGQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRiaW5NaW4gPSBiaW5NaWQ7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRiaW5NYXggPSBiaW5NaWQ7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdGJpbk1pZCA9IE1hdGguZmxvb3IoKGJpbk1heCAtIGJpbk1pbikgLyAyICsgYmluTWluKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0YmluTWF4ID0gYmluTWlkO1xcblxcdFxcdFxcdFxcdFxcdHN0YXJ0ID0gTWF0aC5tYXgoMSwgTUFUQ0hfTE9DQVRJT04gLSBiaW5NaWQgKyAxKTtcXG5cXHRcXHRcXHRcXHRcXHRmaW5pc2ggPSBNYXRoLm1pbihNQVRDSF9MT0NBVElPTiArIGJpbk1pZCwgdGV4dExlbikgKyBwYXR0ZXJuTGVuO1xcblxcdFxcdFxcdFxcdFxcdHJkID0gbmV3IEFycmF5KGZpbmlzaCArIDIpO1xcblxcdFxcdFxcdFxcdFxcdHJkW2ZpbmlzaCArIDFdID0gKDEgPDwgaSkgLSAxO1xcblxcdFxcdFxcdFxcdFxcdGZvciAoaiA9IGZpbmlzaDsgaiA+PSBzdGFydDsgai0tKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2hhck1hdGNoID0gcGF0dGVybl9hbHBoYWJldFt0ZXh0LmNoYXJBdChqIC0gMSldO1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChpID09PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmRbal0gPSAocmRbaiArIDFdIDw8IDEgfCAxKSAmIGNoYXJNYXRjaDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJkW2pdID0gKHJkW2ogKyAxXSA8PCAxIHwgMSkgJiBjaGFyTWF0Y2ggfCAoKGxhc3RSZFtqICsgMV0gfCBsYXN0UmRbal0pIDw8IDEgfCAxKSB8IGxhc3RSZFtqICsgMV07XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChyZFtqXSAmIG1hdGNobWFzaykge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHNjb3JlID0gbWF0Y2hfYml0YXBTY29yZShpLCBqIC0gMSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKHNjb3JlIDw9IHNjb3JlVGhyZXNob2xkKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0c2NvcmVUaHJlc2hvbGQgPSBzY29yZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRiZXN0TG9jID0gaiAtIDE7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bG9jYXRpb25zLnB1c2goYmVzdExvYyk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKGJlc3RMb2MgPiBNQVRDSF9MT0NBVElPTikge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHN0YXJ0ID0gTWF0aC5tYXgoMSwgMiAqIE1BVENIX0xPQ0FUSU9OIC0gYmVzdExvYyk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aWYgKG1hdGNoX2JpdGFwU2NvcmUoaSArIDEsIE1BVENIX0xPQ0FUSU9OKSA+IHNjb3JlVGhyZXNob2xkKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGxhc3RSZCA9IHJkO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRyZXR1cm4ge1xcblxcdFxcdFxcdFxcdFxcdGlzTWF0Y2g6IGJlc3RMb2MgPj0gMCxcXG5cXHRcXHRcXHRcXHRcXHRzY29yZTogc2NvcmVcXG5cXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdH07XFxuXFx0XFx0XFx0cmV0dXJuIHR4dCA9PT0gdHJ1ZSA/IHsgJ3NlYXJjaCc6IHNlYXJjaCB9IDogc2VhcmNoKHR4dCk7XFxuXFx0XFx0fTtcXG5cXHRcXHQkLnZha2F0YS5zZWFyY2guZGVmYXVsdHMgPSB7XFxuXFx0XFx0XFx0bG9jYXRpb246IDAsXFxuXFx0XFx0XFx0ZGlzdGFuY2U6IDEwMCxcXG5cXHRcXHRcXHR0aHJlc2hvbGQ6IDAuNixcXG5cXHRcXHRcXHRmdXp6eTogZmFsc2UsXFxuXFx0XFx0XFx0Y2FzZVNlbnNpdGl2ZTogZmFsc2VcXG5cXHRcXHR9O1xcblxcdH0pKCQpO1xcblxcblxcdC8vIGluY2x1ZGUgdGhlIHNlYXJjaCBwbHVnaW4gYnkgZGVmYXVsdFxcblxcdC8vICQuanN0cmVlLmRlZmF1bHRzLnBsdWdpbnMucHVzaChcXFwic2VhcmNoXFxcIik7XFxuXFxuXFxuXFx0LyoqXFxuICAqICMjIyBTb3J0IHBsdWdpblxcbiAgKlxcbiAgKiBBdXRvbWF0aWNhbGx5IHNvcnRzIGFsbCBzaWJsaW5ncyBpbiB0aGUgdHJlZSBhY2NvcmRpbmcgdG8gYSBzb3J0aW5nIGZ1bmN0aW9uLlxcbiAgKi9cXG5cXG5cXHQvKipcXG4gICogdGhlIHNldHRpbmdzIGZ1bmN0aW9uIHVzZWQgdG8gc29ydCB0aGUgbm9kZXMuXFxuICAqIEl0IGlzIGV4ZWN1dGVkIGluIHRoZSB0cmVlJ3MgY29udGV4dCwgYWNjZXB0cyB0d28gbm9kZXMgYXMgYXJndW1lbnRzIGFuZCBzaG91bGQgcmV0dXJuIGAxYCBvciBgLTFgLlxcbiAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5zb3J0XFxuICAqIEBwbHVnaW4gc29ydFxcbiAgKi9cXG5cXHQkLmpzdHJlZS5kZWZhdWx0cy5zb3J0ID0gZnVuY3Rpb24gKGEsIGIpIHtcXG5cXHRcXHQvL3JldHVybiB0aGlzLmdldF90eXBlKGEpID09PSB0aGlzLmdldF90eXBlKGIpID8gKHRoaXMuZ2V0X3RleHQoYSkgPiB0aGlzLmdldF90ZXh0KGIpID8gMSA6IC0xKSA6IHRoaXMuZ2V0X3R5cGUoYSkgPj0gdGhpcy5nZXRfdHlwZShiKTtcXG5cXHRcXHRyZXR1cm4gdGhpcy5nZXRfdGV4dChhKSA+IHRoaXMuZ2V0X3RleHQoYikgPyAxIDogLTE7XFxuXFx0fTtcXG5cXHQkLmpzdHJlZS5wbHVnaW5zLnNvcnQgPSBmdW5jdGlvbiAob3B0aW9ucywgcGFyZW50KSB7XFxuXFx0XFx0dGhpcy5iaW5kID0gZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdHBhcmVudC5iaW5kLmNhbGwodGhpcyk7XFxuXFx0XFx0XFx0dGhpcy5lbGVtZW50Lm9uKFxcXCJtb2RlbC5qc3RyZWVcXFwiLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5zb3J0KGRhdGEucGFyZW50LCB0cnVlKTtcXG5cXHRcXHRcXHR9LCB0aGlzKSkub24oXFxcInJlbmFtZV9ub2RlLmpzdHJlZSBjcmVhdGVfbm9kZS5qc3RyZWVcXFwiLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5zb3J0KGRhdGEucGFyZW50IHx8IGRhdGEubm9kZS5wYXJlbnQsIGZhbHNlKTtcXG5cXHRcXHRcXHRcXHR0aGlzLnJlZHJhd19ub2RlKGRhdGEucGFyZW50IHx8IGRhdGEubm9kZS5wYXJlbnQsIHRydWUpO1xcblxcdFxcdFxcdH0sIHRoaXMpKS5vbihcXFwibW92ZV9ub2RlLmpzdHJlZSBjb3B5X25vZGUuanN0cmVlXFxcIiwgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xcblxcdFxcdFxcdFxcdHRoaXMuc29ydChkYXRhLnBhcmVudCwgZmFsc2UpO1xcblxcdFxcdFxcdFxcdHRoaXMucmVkcmF3X25vZGUoZGF0YS5wYXJlbnQsIHRydWUpO1xcblxcdFxcdFxcdH0sIHRoaXMpKTtcXG5cXHRcXHR9O1xcblxcdFxcdC8qKlxcbiAgICogdXNlZCB0byBzb3J0IGEgbm9kZSdzIGNoaWxkcmVuXFxuICAgKiBAcHJpdmF0ZVxcbiAgICogQG5hbWUgc29ydChvYmogWywgZGVlcF0pXFxuICAgKiBAcGFyYW0gIHttaXhlZH0gb2JqIHRoZSBub2RlXFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRlZXAgaWYgc2V0IHRvIGB0cnVlYCBub2RlcyBhcmUgc29ydGVkIHJlY3Vyc2l2ZWx5LlxcbiAgICogQHBsdWdpbiBzb3J0XFxuICAgKiBAdHJpZ2dlciBzZWFyY2guanN0cmVlXFxuICAgKi9cXG5cXHRcXHR0aGlzLnNvcnQgPSBmdW5jdGlvbiAob2JqLCBkZWVwKSB7XFxuXFx0XFx0XFx0dmFyIGksIGo7XFxuXFx0XFx0XFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xcblxcdFxcdFxcdGlmIChvYmogJiYgb2JqLmNoaWxkcmVuICYmIG9iai5jaGlsZHJlbi5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRvYmouY2hpbGRyZW4uc29ydCgkLnByb3h5KHRoaXMuc2V0dGluZ3Muc29ydCwgdGhpcykpO1xcblxcdFxcdFxcdFxcdGlmIChkZWVwKSB7XFxuXFx0XFx0XFx0XFx0XFx0Zm9yIChpID0gMCwgaiA9IG9iai5jaGlsZHJlbl9kLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuc29ydChvYmouY2hpbGRyZW5fZFtpXSwgZmFsc2UpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH07XFxuXFx0fTtcXG5cXG5cXHQvLyBpbmNsdWRlIHRoZSBzb3J0IHBsdWdpbiBieSBkZWZhdWx0XFxuXFx0Ly8gJC5qc3RyZWUuZGVmYXVsdHMucGx1Z2lucy5wdXNoKFxcXCJzb3J0XFxcIik7XFxuXFxuXFx0LyoqXFxuICAqICMjIyBTdGF0ZSBwbHVnaW5cXG4gICpcXG4gICogU2F2ZXMgdGhlIHN0YXRlIG9mIHRoZSB0cmVlIChzZWxlY3RlZCBub2Rlcywgb3BlbmVkIG5vZGVzKSBvbiB0aGUgdXNlcidzIGNvbXB1dGVyIHVzaW5nIGF2YWlsYWJsZSBvcHRpb25zIChsb2NhbFN0b3JhZ2UsIGNvb2tpZXMsIGV0YylcXG4gICovXFxuXFxuXFx0dmFyIHRvID0gZmFsc2U7XFxuXFx0LyoqXFxuICAqIHN0b3JlcyBhbGwgZGVmYXVsdHMgZm9yIHRoZSBzdGF0ZSBwbHVnaW5cXG4gICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuc3RhdGVcXG4gICogQHBsdWdpbiBzdGF0ZVxcbiAgKi9cXG5cXHQkLmpzdHJlZS5kZWZhdWx0cy5zdGF0ZSA9IHtcXG5cXHRcXHQvKipcXG4gICAqIEEgc3RyaW5nIGZvciB0aGUga2V5IHRvIHVzZSB3aGVuIHNhdmluZyB0aGUgY3VycmVudCB0cmVlIChjaGFuZ2UgaWYgdXNpbmcgbXVsdGlwbGUgdHJlZXMgaW4geW91ciBwcm9qZWN0KS4gRGVmYXVsdHMgdG8gYGpzdHJlZWAuXFxuICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5zdGF0ZS5rZXlcXG4gICAqIEBwbHVnaW4gc3RhdGVcXG4gICAqL1xcblxcdFxcdGtleTogJ2pzdHJlZScsXFxuXFx0XFx0LyoqXFxuICAgKiBBIHNwYWNlIHNlcGFyYXRlZCBsaXN0IG9mIGV2ZW50cyB0aGF0IHRyaWdnZXIgYSBzdGF0ZSBzYXZlLiBEZWZhdWx0cyB0byBgY2hhbmdlZC5qc3RyZWUgb3Blbl9ub2RlLmpzdHJlZSBjbG9zZV9ub2RlLmpzdHJlZWAuXFxuICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5zdGF0ZS5ldmVudHNcXG4gICAqIEBwbHVnaW4gc3RhdGVcXG4gICAqL1xcblxcdFxcdGV2ZW50czogJ2NoYW5nZWQuanN0cmVlIG9wZW5fbm9kZS5qc3RyZWUgY2xvc2Vfbm9kZS5qc3RyZWUgY2hlY2tfbm9kZS5qc3RyZWUgdW5jaGVja19ub2RlLmpzdHJlZScsXFxuXFx0XFx0LyoqXFxuICAgKiBUaW1lIGluIG1pbGxpc2Vjb25kcyBhZnRlciB3aGljaCB0aGUgc3RhdGUgd2lsbCBleHBpcmUuIERlZmF1bHRzIHRvICdmYWxzZScgbWVhbmluZyAtIG5vIGV4cGlyZS5cXG4gICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLnN0YXRlLnR0bFxcbiAgICogQHBsdWdpbiBzdGF0ZVxcbiAgICovXFxuXFx0XFx0dHRsOiBmYWxzZSxcXG5cXHRcXHQvKipcXG4gICAqIEEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHByaW9yIHRvIHJlc3RvcmluZyBzdGF0ZSB3aXRoIG9uZSBhcmd1bWVudCAtIHRoZSBzdGF0ZSBvYmplY3QuIENhbiBiZSB1c2VkIHRvIGNsZWFyIHVud2FudGVkIHBhcnRzIG9mIHRoZSBzdGF0ZS5cXG4gICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLnN0YXRlLmZpbHRlclxcbiAgICogQHBsdWdpbiBzdGF0ZVxcbiAgICovXFxuXFx0XFx0ZmlsdGVyOiBmYWxzZVxcblxcdH07XFxuXFx0JC5qc3RyZWUucGx1Z2lucy5zdGF0ZSA9IGZ1bmN0aW9uIChvcHRpb25zLCBwYXJlbnQpIHtcXG5cXHRcXHR0aGlzLmJpbmQgPSBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0cGFyZW50LmJpbmQuY2FsbCh0aGlzKTtcXG5cXHRcXHRcXHR2YXIgYmluZCA9ICQucHJveHkoZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdHRoaXMuZWxlbWVudC5vbih0aGlzLnNldHRpbmdzLnN0YXRlLmV2ZW50cywgJC5wcm94eShmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHRvKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2xlYXJUaW1lb3V0KHRvKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0dG8gPSBzZXRUaW1lb3V0KCQucHJveHkoZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuc2F2ZV9zdGF0ZSgpO1xcblxcdFxcdFxcdFxcdFxcdH0sIHRoaXMpLCAxMDApO1xcblxcdFxcdFxcdFxcdH0sIHRoaXMpKTtcXG5cXHRcXHRcXHRcXHQvKipcXG4gICAgICogdHJpZ2dlcmVkIHdoZW4gdGhlIHN0YXRlIHBsdWdpbiBpcyBmaW5pc2hlZCByZXN0b3JpbmcgdGhlIHN0YXRlIChhbmQgaW1tZWRpYXRlbHkgYWZ0ZXIgcmVhZHkgaWYgdGhlcmUgaXMgbm8gc3RhdGUgdG8gcmVzdG9yZSkuXFxuICAgICAqIEBldmVudFxcbiAgICAgKiBAbmFtZSBzdGF0ZV9yZWFkeS5qc3RyZWVcXG4gICAgICogQHBsdWdpbiBzdGF0ZVxcbiAgICAgKi9cXG5cXHRcXHRcXHRcXHR0aGlzLnRyaWdnZXIoJ3N0YXRlX3JlYWR5Jyk7XFxuXFx0XFx0XFx0fSwgdGhpcyk7XFxuXFx0XFx0XFx0dGhpcy5lbGVtZW50Lm9uKFxcXCJyZWFkeS5qc3RyZWVcXFwiLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5lbGVtZW50Lm9uZShcXFwicmVzdG9yZV9zdGF0ZS5qc3RyZWVcXFwiLCBiaW5kKTtcXG5cXHRcXHRcXHRcXHRpZiAoIXRoaXMucmVzdG9yZV9zdGF0ZSgpKSB7XFxuXFx0XFx0XFx0XFx0XFx0YmluZCgpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LCB0aGlzKSk7XFxuXFx0XFx0fTtcXG5cXHRcXHQvKipcXG4gICAqIHNhdmUgdGhlIHN0YXRlXFxuICAgKiBAbmFtZSBzYXZlX3N0YXRlKClcXG4gICAqIEBwbHVnaW4gc3RhdGVcXG4gICAqL1xcblxcdFxcdHRoaXMuc2F2ZV9zdGF0ZSA9IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHR2YXIgc3QgPSB7ICdzdGF0ZSc6IHRoaXMuZ2V0X3N0YXRlKCksICd0dGwnOiB0aGlzLnNldHRpbmdzLnN0YXRlLnR0bCwgJ3NlYyc6ICtuZXcgRGF0ZSgpIH07XFxuXFx0XFx0XFx0JC52YWthdGEuc3RvcmFnZS5zZXQodGhpcy5zZXR0aW5ncy5zdGF0ZS5rZXksIEpTT04uc3RyaW5naWZ5KHN0KSk7XFxuXFx0XFx0fTtcXG5cXHRcXHQvKipcXG4gICAqIHJlc3RvcmUgdGhlIHN0YXRlIGZyb20gdGhlIHVzZXIncyBjb21wdXRlclxcbiAgICogQG5hbWUgcmVzdG9yZV9zdGF0ZSgpXFxuICAgKiBAcGx1Z2luIHN0YXRlXFxuICAgKi9cXG5cXHRcXHR0aGlzLnJlc3RvcmVfc3RhdGUgPSBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0dmFyIGsgPSAkLnZha2F0YS5zdG9yYWdlLmdldCh0aGlzLnNldHRpbmdzLnN0YXRlLmtleSk7XFxuXFx0XFx0XFx0aWYgKCEhaykge1xcblxcdFxcdFxcdFxcdHRyeSB7XFxuXFx0XFx0XFx0XFx0XFx0ayA9IEpTT04ucGFyc2Uoayk7XFxuXFx0XFx0XFx0XFx0fSBjYXRjaCAoZXgpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoISFrICYmIGsudHRsICYmIGsuc2VjICYmICtuZXcgRGF0ZSgpIC0gay5zZWMgPiBrLnR0bCkge1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKCEhayAmJiBrLnN0YXRlKSB7XFxuXFx0XFx0XFx0XFx0ayA9IGsuc3RhdGU7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICghIWsgJiYgJC5pc0Z1bmN0aW9uKHRoaXMuc2V0dGluZ3Muc3RhdGUuZmlsdGVyKSkge1xcblxcdFxcdFxcdFxcdGsgPSB0aGlzLnNldHRpbmdzLnN0YXRlLmZpbHRlci5jYWxsKHRoaXMsIGspO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoISFrKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5lbGVtZW50Lm9uZShcXFwic2V0X3N0YXRlLmpzdHJlZVxcXCIsIGZ1bmN0aW9uIChlLCBkYXRhKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZGF0YS5pbnN0YW5jZS50cmlnZ2VyKCdyZXN0b3JlX3N0YXRlJywgeyAnc3RhdGUnOiAkLmV4dGVuZCh0cnVlLCB7fSwgaykgfSk7XFxuXFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0XFx0dGhpcy5zZXRfc3RhdGUoayk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHR9O1xcblxcdFxcdC8qKlxcbiAgICogY2xlYXIgdGhlIHN0YXRlIG9uIHRoZSB1c2VyJ3MgY29tcHV0ZXJcXG4gICAqIEBuYW1lIGNsZWFyX3N0YXRlKClcXG4gICAqIEBwbHVnaW4gc3RhdGVcXG4gICAqL1xcblxcdFxcdHRoaXMuY2xlYXJfc3RhdGUgPSBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0cmV0dXJuICQudmFrYXRhLnN0b3JhZ2UuZGVsKHRoaXMuc2V0dGluZ3Muc3RhdGUua2V5KTtcXG5cXHRcXHR9O1xcblxcdH07XFxuXFxuXFx0KGZ1bmN0aW9uICgkLCB1bmRlZmluZWQpIHtcXG5cXHRcXHQkLnZha2F0YS5zdG9yYWdlID0ge1xcblxcdFxcdFxcdC8vIHNpbXBseSBzcGVjaWZ5aW5nIHRoZSBmdW5jdGlvbnMgaW4gRkYgdGhyb3dzIGFuIGVycm9yXFxuXFx0XFx0XFx0c2V0OiBmdW5jdGlvbiBzZXQoa2V5LCB2YWwpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gd2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKGtleSwgdmFsKTtcXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdGdldDogZnVuY3Rpb24gZ2V0KGtleSkge1xcblxcdFxcdFxcdFxcdHJldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KTtcXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdGRlbDogZnVuY3Rpb24gZGVsKGtleSkge1xcblxcdFxcdFxcdFxcdHJldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fTtcXG5cXHR9KSgkKTtcXG5cXG5cXHQvLyBpbmNsdWRlIHRoZSBzdGF0ZSBwbHVnaW4gYnkgZGVmYXVsdFxcblxcdC8vICQuanN0cmVlLmRlZmF1bHRzLnBsdWdpbnMucHVzaChcXFwic3RhdGVcXFwiKTtcXG5cXG5cXHQvKipcXG4gICogIyMjIFR5cGVzIHBsdWdpblxcbiAgKlxcbiAgKiBNYWtlcyBpdCBwb3NzaWJsZSB0byBhZGQgcHJlZGVmaW5lZCB0eXBlcyBmb3IgZ3JvdXBzIG9mIG5vZGVzLCB3aGljaCBtYWtlIGl0IHBvc3NpYmxlIHRvIGVhc2lseSBjb250cm9sIG5lc3RpbmcgcnVsZXMgYW5kIGljb24gZm9yIGVhY2ggZ3JvdXAuXFxuICAqL1xcblxcblxcdC8qKlxcbiAgKiBBbiBvYmplY3Qgc3RvcmluZyBhbGwgdHlwZXMgYXMga2V5IHZhbHVlIHBhaXJzLCB3aGVyZSB0aGUga2V5IGlzIHRoZSB0eXBlIG5hbWUgYW5kIHRoZSB2YWx1ZSBpcyBhbiBvYmplY3QgdGhhdCBjb3VsZCBjb250YWluIGZvbGxvd2luZyBrZXlzIChhbGwgb3B0aW9uYWwpLlxcbiAgKlxcbiAgKiAqIGBtYXhfY2hpbGRyZW5gIHRoZSBtYXhpbXVtIG51bWJlciBvZiBpbW1lZGlhdGUgY2hpbGRyZW4gdGhpcyBub2RlIHR5cGUgY2FuIGhhdmUuIERvIG5vdCBzcGVjaWZ5IG9yIHNldCB0byBgLTFgIGZvciB1bmxpbWl0ZWQuXFxuICAqICogYG1heF9kZXB0aGAgdGhlIG1heGltdW0gbnVtYmVyIG9mIG5lc3RpbmcgdGhpcyBub2RlIHR5cGUgY2FuIGhhdmUuIEEgdmFsdWUgb2YgYDFgIHdvdWxkIG1lYW4gdGhhdCB0aGUgbm9kZSBjYW4gaGF2ZSBjaGlsZHJlbiwgYnV0IG5vIGdyYW5kY2hpbGRyZW4uIERvIG5vdCBzcGVjaWZ5IG9yIHNldCB0byBgLTFgIGZvciB1bmxpbWl0ZWQuXFxuICAqICogYHZhbGlkX2NoaWxkcmVuYCBhbiBhcnJheSBvZiBub2RlIHR5cGUgc3RyaW5ncywgdGhhdCBub2RlcyBvZiB0aGlzIHR5cGUgY2FuIGhhdmUgYXMgY2hpbGRyZW4uIERvIG5vdCBzcGVjaWZ5IG9yIHNldCB0byBgLTFgIGZvciBubyBsaW1pdHMuXFxuICAqICogYGljb25gIGEgc3RyaW5nIC0gY2FuIGJlIGEgcGF0aCB0byBhbiBpY29uIG9yIGEgY2xhc3NOYW1lLCBpZiB1c2luZyBhbiBpbWFnZSB0aGF0IGlzIGluIHRoZSBjdXJyZW50IGRpcmVjdG9yeSB1c2UgYSBgLi9gIHByZWZpeCwgb3RoZXJ3aXNlIGl0IHdpbGwgYmUgZGV0ZWN0ZWQgYXMgYSBjbGFzcy4gT21pdCB0byB1c2UgdGhlIGRlZmF1bHQgaWNvbiBmcm9tIHlvdXIgdGhlbWUuXFxuICAqICogYGxpX2F0dHJgIGFuIG9iamVjdCBvZiB2YWx1ZXMgd2hpY2ggd2lsbCBiZSB1c2VkIHRvIGFkZCBIVE1MIGF0dHJpYnV0ZXMgb24gdGhlIHJlc3VsdGluZyBMSSBET00gbm9kZSAobWVyZ2VkIHdpdGggdGhlIG5vZGUncyBvd24gZGF0YSlcXG4gICogKiBgYV9hdHRyYCBhbiBvYmplY3Qgb2YgdmFsdWVzIHdoaWNoIHdpbGwgYmUgdXNlZCB0byBhZGQgSFRNTCBhdHRyaWJ1dGVzIG9uIHRoZSByZXN1bHRpbmcgQSBET00gbm9kZSAobWVyZ2VkIHdpdGggdGhlIG5vZGUncyBvd24gZGF0YSlcXG4gICpcXG4gICogVGhlcmUgYXJlIHR3byBwcmVkZWZpbmVkIHR5cGVzOlxcbiAgKlxcbiAgKiAqIGAjYCByZXByZXNlbnRzIHRoZSByb290IG9mIHRoZSB0cmVlLCBmb3IgZXhhbXBsZSBgbWF4X2NoaWxkcmVuYCB3b3VsZCBjb250cm9sIHRoZSBtYXhpbXVtIG51bWJlciBvZiByb290IG5vZGVzLlxcbiAgKiAqIGBkZWZhdWx0YCByZXByZXNlbnRzIHRoZSBkZWZhdWx0IG5vZGUgLSBhbnkgc2V0dGluZ3MgaGVyZSB3aWxsIGJlIGFwcGxpZWQgdG8gYWxsIG5vZGVzIHRoYXQgZG8gbm90IGhhdmUgYSB0eXBlIHNwZWNpZmllZC5cXG4gICpcXG4gICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMudHlwZXNcXG4gICogQHBsdWdpbiB0eXBlc1xcbiAgKi9cXG5cXHQkLmpzdHJlZS5kZWZhdWx0cy50eXBlcyA9IHtcXG5cXHRcXHQnZGVmYXVsdCc6IHt9XFxuXFx0fTtcXG5cXHQkLmpzdHJlZS5kZWZhdWx0cy50eXBlc1skLmpzdHJlZS5yb290XSA9IHt9O1xcblxcblxcdCQuanN0cmVlLnBsdWdpbnMudHlwZXMgPSBmdW5jdGlvbiAob3B0aW9ucywgcGFyZW50KSB7XFxuXFx0XFx0dGhpcy5pbml0ID0gZnVuY3Rpb24gKGVsLCBvcHRpb25zKSB7XFxuXFx0XFx0XFx0dmFyIGksIGo7XFxuXFx0XFx0XFx0aWYgKG9wdGlvbnMgJiYgb3B0aW9ucy50eXBlcyAmJiBvcHRpb25zLnR5cGVzWydkZWZhdWx0J10pIHtcXG5cXHRcXHRcXHRcXHRmb3IgKGkgaW4gb3B0aW9ucy50eXBlcykge1xcblxcdFxcdFxcdFxcdFxcdGlmIChpICE9PSBcXFwiZGVmYXVsdFxcXCIgJiYgaSAhPT0gJC5qc3RyZWUucm9vdCAmJiBvcHRpb25zLnR5cGVzLmhhc093blByb3BlcnR5KGkpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Zm9yIChqIGluIG9wdGlvbnMudHlwZXNbJ2RlZmF1bHQnXSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChvcHRpb25zLnR5cGVzWydkZWZhdWx0J10uaGFzT3duUHJvcGVydHkoaikgJiYgb3B0aW9ucy50eXBlc1tpXVtqXSA9PT0gdW5kZWZpbmVkKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0b3B0aW9ucy50eXBlc1tpXVtqXSA9IG9wdGlvbnMudHlwZXNbJ2RlZmF1bHQnXVtqXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHBhcmVudC5pbml0LmNhbGwodGhpcywgZWwsIG9wdGlvbnMpO1xcblxcdFxcdFxcdHRoaXMuX21vZGVsLmRhdGFbJC5qc3RyZWUucm9vdF0udHlwZSA9ICQuanN0cmVlLnJvb3Q7XFxuXFx0XFx0fTtcXG5cXHRcXHR0aGlzLnJlZnJlc2ggPSBmdW5jdGlvbiAoc2tpcF9sb2FkaW5nLCBmb3JnZXRfc3RhdGUpIHtcXG5cXHRcXHRcXHRwYXJlbnQucmVmcmVzaC5jYWxsKHRoaXMsIHNraXBfbG9hZGluZywgZm9yZ2V0X3N0YXRlKTtcXG5cXHRcXHRcXHR0aGlzLl9tb2RlbC5kYXRhWyQuanN0cmVlLnJvb3RdLnR5cGUgPSAkLmpzdHJlZS5yb290O1xcblxcdFxcdH07XFxuXFx0XFx0dGhpcy5iaW5kID0gZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdHRoaXMuZWxlbWVudC5vbignbW9kZWwuanN0cmVlJywgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xcblxcdFxcdFxcdFxcdHZhciBtID0gdGhpcy5fbW9kZWwuZGF0YSxcXG5cXHRcXHRcXHRcXHQgICAgZHBjID0gZGF0YS5ub2RlcyxcXG5cXHRcXHRcXHRcXHQgICAgdCA9IHRoaXMuc2V0dGluZ3MudHlwZXMsXFxuXFx0XFx0XFx0XFx0ICAgIGksXFxuXFx0XFx0XFx0XFx0ICAgIGosXFxuXFx0XFx0XFx0XFx0ICAgIGMgPSAnZGVmYXVsdCcsXFxuXFx0XFx0XFx0XFx0ICAgIGs7XFxuXFx0XFx0XFx0XFx0Zm9yIChpID0gMCwgaiA9IGRwYy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRjID0gJ2RlZmF1bHQnO1xcblxcdFxcdFxcdFxcdFxcdGlmIChtW2RwY1tpXV0ub3JpZ2luYWwgJiYgbVtkcGNbaV1dLm9yaWdpbmFsLnR5cGUgJiYgdFttW2RwY1tpXV0ub3JpZ2luYWwudHlwZV0pIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRjID0gbVtkcGNbaV1dLm9yaWdpbmFsLnR5cGU7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmIChtW2RwY1tpXV0uZGF0YSAmJiBtW2RwY1tpXV0uZGF0YS5qc3RyZWUgJiYgbVtkcGNbaV1dLmRhdGEuanN0cmVlLnR5cGUgJiYgdFttW2RwY1tpXV0uZGF0YS5qc3RyZWUudHlwZV0pIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRjID0gbVtkcGNbaV1dLmRhdGEuanN0cmVlLnR5cGU7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdG1bZHBjW2ldXS50eXBlID0gYztcXG5cXHRcXHRcXHRcXHRcXHRpZiAobVtkcGNbaV1dLmljb24gPT09IHRydWUgJiYgdFtjXS5pY29uICE9PSB1bmRlZmluZWQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRtW2RwY1tpXV0uaWNvbiA9IHRbY10uaWNvbjtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHRbY10ubGlfYXR0ciAhPT0gdW5kZWZpbmVkICYmIF90eXBlb2YodFtjXS5saV9hdHRyKSA9PT0gJ29iamVjdCcpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRmb3IgKGsgaW4gdFtjXS5saV9hdHRyKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKHRbY10ubGlfYXR0ci5oYXNPd25Qcm9wZXJ0eShrKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChrID09PSAnaWQnKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Y29udGludWU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIGlmIChtW2RwY1tpXV0ubGlfYXR0cltrXSA9PT0gdW5kZWZpbmVkKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bVtkcGNbaV1dLmxpX2F0dHJba10gPSB0W2NdLmxpX2F0dHJba107XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIGlmIChrID09PSAnY2xhc3MnKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bVtkcGNbaV1dLmxpX2F0dHJbJ2NsYXNzJ10gPSB0W2NdLmxpX2F0dHJbJ2NsYXNzJ10gKyAnICcgKyBtW2RwY1tpXV0ubGlfYXR0clsnY2xhc3MnXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHRbY10uYV9hdHRyICE9PSB1bmRlZmluZWQgJiYgX3R5cGVvZih0W2NdLmFfYXR0cikgPT09ICdvYmplY3QnKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Zm9yIChrIGluIHRbY10uYV9hdHRyKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKHRbY10uYV9hdHRyLmhhc093blByb3BlcnR5KGspKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKGsgPT09ICdpZCcpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjb250aW51ZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2UgaWYgKG1bZHBjW2ldXS5hX2F0dHJba10gPT09IHVuZGVmaW5lZCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG1bZHBjW2ldXS5hX2F0dHJba10gPSB0W2NdLmFfYXR0cltrXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2UgaWYgKGsgPT09ICdocmVmJyAmJiBtW2RwY1tpXV0uYV9hdHRyW2tdID09PSAnIycpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRtW2RwY1tpXV0uYV9hdHRyWydocmVmJ10gPSB0W2NdLmFfYXR0clsnaHJlZiddO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoayA9PT0gJ2NsYXNzJykge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG1bZHBjW2ldXS5hX2F0dHJbJ2NsYXNzJ10gPSB0W2NdLmFfYXR0clsnY2xhc3MnXSArICcgJyArIG1bZHBjW2ldXS5hX2F0dHJbJ2NsYXNzJ107XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRtWyQuanN0cmVlLnJvb3RdLnR5cGUgPSAkLmpzdHJlZS5yb290O1xcblxcdFxcdFxcdH0sIHRoaXMpKTtcXG5cXHRcXHRcXHRwYXJlbnQuYmluZC5jYWxsKHRoaXMpO1xcblxcdFxcdH07XFxuXFx0XFx0dGhpcy5nZXRfanNvbiA9IGZ1bmN0aW9uIChvYmosIG9wdGlvbnMsIGZsYXQpIHtcXG5cXHRcXHRcXHR2YXIgaSxcXG5cXHRcXHRcXHQgICAgaixcXG5cXHRcXHRcXHQgICAgbSA9IHRoaXMuX21vZGVsLmRhdGEsXFxuXFx0XFx0XFx0ICAgIG9wdCA9IG9wdGlvbnMgPyAkLmV4dGVuZCh0cnVlLCB7fSwgb3B0aW9ucywgeyBub19pZDogZmFsc2UgfSkgOiB7fSxcXG5cXHRcXHRcXHQgICAgdG1wID0gcGFyZW50LmdldF9qc29uLmNhbGwodGhpcywgb2JqLCBvcHQsIGZsYXQpO1xcblxcdFxcdFxcdGlmICh0bXAgPT09IGZhbHNlKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoJC5pc0FycmF5KHRtcCkpIHtcXG5cXHRcXHRcXHRcXHRmb3IgKGkgPSAwLCBqID0gdG1wLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdHRtcFtpXS50eXBlID0gdG1wW2ldLmlkICYmIG1bdG1wW2ldLmlkXSAmJiBtW3RtcFtpXS5pZF0udHlwZSA/IG1bdG1wW2ldLmlkXS50eXBlIDogXFxcImRlZmF1bHRcXFwiO1xcblxcdFxcdFxcdFxcdFxcdGlmIChvcHRpb25zICYmIG9wdGlvbnMubm9faWQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRkZWxldGUgdG1wW2ldLmlkO1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICh0bXBbaV0ubGlfYXR0ciAmJiB0bXBbaV0ubGlfYXR0ci5pZCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGRlbGV0ZSB0bXBbaV0ubGlfYXR0ci5pZDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKHRtcFtpXS5hX2F0dHIgJiYgdG1wW2ldLmFfYXR0ci5pZCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGRlbGV0ZSB0bXBbaV0uYV9hdHRyLmlkO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0dG1wLnR5cGUgPSB0bXAuaWQgJiYgbVt0bXAuaWRdICYmIG1bdG1wLmlkXS50eXBlID8gbVt0bXAuaWRdLnR5cGUgOiBcXFwiZGVmYXVsdFxcXCI7XFxuXFx0XFx0XFx0XFx0aWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5ub19pZCkge1xcblxcdFxcdFxcdFxcdFxcdHRtcCA9IHRoaXMuX2RlbGV0ZV9pZHModG1wKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiB0bXA7XFxuXFx0XFx0fTtcXG5cXHRcXHR0aGlzLl9kZWxldGVfaWRzID0gZnVuY3Rpb24gKHRtcCkge1xcblxcdFxcdFxcdGlmICgkLmlzQXJyYXkodG1wKSkge1xcblxcdFxcdFxcdFxcdGZvciAodmFyIGkgPSAwLCBqID0gdG1wLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdHRtcFtpXSA9IHRoaXMuX2RlbGV0ZV9pZHModG1wW2ldKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRtcDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0ZGVsZXRlIHRtcC5pZDtcXG5cXHRcXHRcXHRpZiAodG1wLmxpX2F0dHIgJiYgdG1wLmxpX2F0dHIuaWQpIHtcXG5cXHRcXHRcXHRcXHRkZWxldGUgdG1wLmxpX2F0dHIuaWQ7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICh0bXAuYV9hdHRyICYmIHRtcC5hX2F0dHIuaWQpIHtcXG5cXHRcXHRcXHRcXHRkZWxldGUgdG1wLmFfYXR0ci5pZDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKHRtcC5jaGlsZHJlbiAmJiAkLmlzQXJyYXkodG1wLmNoaWxkcmVuKSkge1xcblxcdFxcdFxcdFxcdHRtcC5jaGlsZHJlbiA9IHRoaXMuX2RlbGV0ZV9pZHModG1wLmNoaWxkcmVuKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIHRtcDtcXG5cXHRcXHR9O1xcblxcdFxcdHRoaXMuY2hlY2sgPSBmdW5jdGlvbiAoY2hrLCBvYmosIHBhciwgcG9zLCBtb3JlKSB7XFxuXFx0XFx0XFx0aWYgKHBhcmVudC5jaGVjay5jYWxsKHRoaXMsIGNoaywgb2JqLCBwYXIsIHBvcywgbW9yZSkgPT09IGZhbHNlKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRvYmogPSBvYmogJiYgb2JqLmlkID8gb2JqIDogdGhpcy5nZXRfbm9kZShvYmopO1xcblxcdFxcdFxcdHBhciA9IHBhciAmJiBwYXIuaWQgPyBwYXIgOiB0aGlzLmdldF9ub2RlKHBhcik7XFxuXFx0XFx0XFx0dmFyIG0gPSBvYmogJiYgb2JqLmlkID8gbW9yZSAmJiBtb3JlLm9yaWdpbiA/IG1vcmUub3JpZ2luIDogJC5qc3RyZWUucmVmZXJlbmNlKG9iai5pZCkgOiBudWxsLFxcblxcdFxcdFxcdCAgICB0bXAsXFxuXFx0XFx0XFx0ICAgIGQsXFxuXFx0XFx0XFx0ICAgIGksXFxuXFx0XFx0XFx0ICAgIGo7XFxuXFx0XFx0XFx0bSA9IG0gJiYgbS5fbW9kZWwgJiYgbS5fbW9kZWwuZGF0YSA/IG0uX21vZGVsLmRhdGEgOiBudWxsO1xcblxcdFxcdFxcdHN3aXRjaCAoY2hrKSB7XFxuXFx0XFx0XFx0XFx0Y2FzZSBcXFwiY3JlYXRlX25vZGVcXFwiOlxcblxcdFxcdFxcdFxcdGNhc2UgXFxcIm1vdmVfbm9kZVxcXCI6XFxuXFx0XFx0XFx0XFx0Y2FzZSBcXFwiY29weV9ub2RlXFxcIjpcXG5cXHRcXHRcXHRcXHRcXHRpZiAoY2hrICE9PSAnbW92ZV9ub2RlJyB8fCAkLmluQXJyYXkob2JqLmlkLCBwYXIuY2hpbGRyZW4pID09PSAtMSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRtcCA9IHRoaXMuZ2V0X3J1bGVzKHBhcik7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKHRtcC5tYXhfY2hpbGRyZW4gIT09IHVuZGVmaW5lZCAmJiB0bXAubWF4X2NoaWxkcmVuICE9PSAtMSAmJiB0bXAubWF4X2NoaWxkcmVuID09PSBwYXIuY2hpbGRyZW4ubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IgPSB7ICdlcnJvcic6ICdjaGVjaycsICdwbHVnaW4nOiAndHlwZXMnLCAnaWQnOiAndHlwZXNfMDEnLCAncmVhc29uJzogJ21heF9jaGlsZHJlbiBwcmV2ZW50cyBmdW5jdGlvbjogJyArIGNoaywgJ2RhdGEnOiBKU09OLnN0cmluZ2lmeSh7ICdjaGsnOiBjaGssICdwb3MnOiBwb3MsICdvYmonOiBvYmogJiYgb2JqLmlkID8gb2JqLmlkIDogZmFsc2UsICdwYXInOiBwYXIgJiYgcGFyLmlkID8gcGFyLmlkIDogZmFsc2UgfSkgfTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICh0bXAudmFsaWRfY2hpbGRyZW4gIT09IHVuZGVmaW5lZCAmJiB0bXAudmFsaWRfY2hpbGRyZW4gIT09IC0xICYmICQuaW5BcnJheShvYmoudHlwZSB8fCAnZGVmYXVsdCcsIHRtcC52YWxpZF9jaGlsZHJlbikgPT09IC0xKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IgPSB7ICdlcnJvcic6ICdjaGVjaycsICdwbHVnaW4nOiAndHlwZXMnLCAnaWQnOiAndHlwZXNfMDInLCAncmVhc29uJzogJ3ZhbGlkX2NoaWxkcmVuIHByZXZlbnRzIGZ1bmN0aW9uOiAnICsgY2hrLCAnZGF0YSc6IEpTT04uc3RyaW5naWZ5KHsgJ2Noayc6IGNoaywgJ3Bvcyc6IHBvcywgJ29iaic6IG9iaiAmJiBvYmouaWQgPyBvYmouaWQgOiBmYWxzZSwgJ3Bhcic6IHBhciAmJiBwYXIuaWQgPyBwYXIuaWQgOiBmYWxzZSB9KSB9O1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKG0gJiYgb2JqLmNoaWxkcmVuX2QgJiYgb2JqLnBhcmVudHMpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRkID0gMDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRmb3IgKGkgPSAwLCBqID0gb2JqLmNoaWxkcmVuX2QubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZCA9IE1hdGgubWF4KGQsIG1bb2JqLmNoaWxkcmVuX2RbaV1dLnBhcmVudHMubGVuZ3RoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZCA9IGQgLSBvYmoucGFyZW50cy5sZW5ndGggKyAxO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoZCA8PSAwIHx8IGQgPT09IHVuZGVmaW5lZCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGQgPSAxO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRkbyB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKHRtcC5tYXhfZGVwdGggIT09IHVuZGVmaW5lZCAmJiB0bXAubWF4X2RlcHRoICE9PSAtMSAmJiB0bXAubWF4X2RlcHRoIDwgZCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yID0geyAnZXJyb3InOiAnY2hlY2snLCAncGx1Z2luJzogJ3R5cGVzJywgJ2lkJzogJ3R5cGVzXzAzJywgJ3JlYXNvbic6ICdtYXhfZGVwdGggcHJldmVudHMgZnVuY3Rpb246ICcgKyBjaGssICdkYXRhJzogSlNPTi5zdHJpbmdpZnkoeyAnY2hrJzogY2hrLCAncG9zJzogcG9zLCAnb2JqJzogb2JqICYmIG9iai5pZCA/IG9iai5pZCA6IGZhbHNlLCAncGFyJzogcGFyICYmIHBhci5pZCA/IHBhci5pZCA6IGZhbHNlIH0pIH07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRwYXIgPSB0aGlzLmdldF9ub2RlKHBhci5wYXJlbnQpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRtcCA9IHRoaXMuZ2V0X3J1bGVzKHBhcik7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZCsrO1xcblxcdFxcdFxcdFxcdFxcdFxcdH0gd2hpbGUgKHBhcik7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHR9O1xcblxcdFxcdC8qKlxcbiAgICogdXNlZCB0byByZXRyaWV2ZSB0aGUgdHlwZSBzZXR0aW5ncyBvYmplY3QgZm9yIGEgbm9kZVxcbiAgICogQG5hbWUgZ2V0X3J1bGVzKG9iailcXG4gICAqIEBwYXJhbSB7bWl4ZWR9IG9iaiB0aGUgbm9kZSB0byBmaW5kIHRoZSBydWxlcyBmb3JcXG4gICAqIEByZXR1cm4ge09iamVjdH1cXG4gICAqIEBwbHVnaW4gdHlwZXNcXG4gICAqL1xcblxcdFxcdHRoaXMuZ2V0X3J1bGVzID0gZnVuY3Rpb24gKG9iaikge1xcblxcdFxcdFxcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXHRcXHRcXHRpZiAoIW9iaikge1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0dmFyIHRtcCA9IHRoaXMuZ2V0X3R5cGUob2JqLCB0cnVlKTtcXG5cXHRcXHRcXHRpZiAodG1wLm1heF9kZXB0aCA9PT0gdW5kZWZpbmVkKSB7XFxuXFx0XFx0XFx0XFx0dG1wLm1heF9kZXB0aCA9IC0xO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAodG1wLm1heF9jaGlsZHJlbiA9PT0gdW5kZWZpbmVkKSB7XFxuXFx0XFx0XFx0XFx0dG1wLm1heF9jaGlsZHJlbiA9IC0xO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAodG1wLnZhbGlkX2NoaWxkcmVuID09PSB1bmRlZmluZWQpIHtcXG5cXHRcXHRcXHRcXHR0bXAudmFsaWRfY2hpbGRyZW4gPSAtMTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIHRtcDtcXG5cXHRcXHR9O1xcblxcdFxcdC8qKlxcbiAgICogdXNlZCB0byByZXRyaWV2ZSB0aGUgdHlwZSBzdHJpbmcgb3Igc2V0dGluZ3Mgb2JqZWN0IGZvciBhIG5vZGVcXG4gICAqIEBuYW1lIGdldF90eXBlKG9iaiBbLCBydWxlc10pXFxuICAgKiBAcGFyYW0ge21peGVkfSBvYmogdGhlIG5vZGUgdG8gZmluZCB0aGUgcnVsZXMgZm9yXFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJ1bGVzIGlmIHNldCB0byBgdHJ1ZWAgaW5zdGVhZCBvZiBhIHN0cmluZyB0aGUgc2V0dGluZ3Mgb2JqZWN0IHdpbGwgYmUgcmV0dXJuZWRcXG4gICAqIEByZXR1cm4ge1N0cmluZ3xPYmplY3R9XFxuICAgKiBAcGx1Z2luIHR5cGVzXFxuICAgKi9cXG5cXHRcXHR0aGlzLmdldF90eXBlID0gZnVuY3Rpb24gKG9iaiwgcnVsZXMpIHtcXG5cXHRcXHRcXHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XFxuXFx0XFx0XFx0cmV0dXJuICFvYmogPyBmYWxzZSA6IHJ1bGVzID8gJC5leHRlbmQoeyAndHlwZSc6IG9iai50eXBlIH0sIHRoaXMuc2V0dGluZ3MudHlwZXNbb2JqLnR5cGVdKSA6IG9iai50eXBlO1xcblxcdFxcdH07XFxuXFx0XFx0LyoqXFxuICAgKiB1c2VkIHRvIGNoYW5nZSBhIG5vZGUncyB0eXBlXFxuICAgKiBAbmFtZSBzZXRfdHlwZShvYmosIHR5cGUpXFxuICAgKiBAcGFyYW0ge21peGVkfSBvYmogdGhlIG5vZGUgdG8gY2hhbmdlXFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSB0aGUgbmV3IHR5cGVcXG4gICAqIEBwbHVnaW4gdHlwZXNcXG4gICAqL1xcblxcdFxcdHRoaXMuc2V0X3R5cGUgPSBmdW5jdGlvbiAob2JqLCB0eXBlKSB7XFxuXFx0XFx0XFx0dmFyIG0gPSB0aGlzLl9tb2RlbC5kYXRhLFxcblxcdFxcdFxcdCAgICB0LFxcblxcdFxcdFxcdCAgICB0MSxcXG5cXHRcXHRcXHQgICAgdDIsXFxuXFx0XFx0XFx0ICAgIG9sZF90eXBlLFxcblxcdFxcdFxcdCAgICBvbGRfaWNvbixcXG5cXHRcXHRcXHQgICAgayxcXG5cXHRcXHRcXHQgICAgZCxcXG5cXHRcXHRcXHQgICAgYTtcXG5cXHRcXHRcXHRpZiAoJC5pc0FycmF5KG9iaikpIHtcXG5cXHRcXHRcXHRcXHRvYmogPSBvYmouc2xpY2UoKTtcXG5cXHRcXHRcXHRcXHRmb3IgKHQxID0gMCwgdDIgPSBvYmoubGVuZ3RoOyB0MSA8IHQyOyB0MSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5zZXRfdHlwZShvYmpbdDFdLCB0eXBlKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHQgPSB0aGlzLnNldHRpbmdzLnR5cGVzO1xcblxcdFxcdFxcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXHRcXHRcXHRpZiAoIXRbdHlwZV0gfHwgIW9iaikge1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0ZCA9IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKTtcXG5cXHRcXHRcXHRpZiAoZCAmJiBkLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdGEgPSBkLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRvbGRfdHlwZSA9IG9iai50eXBlO1xcblxcdFxcdFxcdG9sZF9pY29uID0gdGhpcy5nZXRfaWNvbihvYmopO1xcblxcdFxcdFxcdG9iai50eXBlID0gdHlwZTtcXG5cXHRcXHRcXHRpZiAob2xkX2ljb24gPT09IHRydWUgfHwgIXRbb2xkX3R5cGVdIHx8IHRbb2xkX3R5cGVdLmljb24gIT09IHVuZGVmaW5lZCAmJiBvbGRfaWNvbiA9PT0gdFtvbGRfdHlwZV0uaWNvbikge1xcblxcdFxcdFxcdFxcdHRoaXMuc2V0X2ljb24ob2JqLCB0W3R5cGVdLmljb24gIT09IHVuZGVmaW5lZCA/IHRbdHlwZV0uaWNvbiA6IHRydWUpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyByZW1vdmUgb2xkIHR5cGUgcHJvcHNcXG5cXHRcXHRcXHRpZiAodFtvbGRfdHlwZV0gJiYgdFtvbGRfdHlwZV0ubGlfYXR0ciAhPT0gdW5kZWZpbmVkICYmIF90eXBlb2YodFtvbGRfdHlwZV0ubGlfYXR0cikgPT09ICdvYmplY3QnKSB7XFxuXFx0XFx0XFx0XFx0Zm9yIChrIGluIHRbb2xkX3R5cGVdLmxpX2F0dHIpIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAodFtvbGRfdHlwZV0ubGlfYXR0ci5oYXNPd25Qcm9wZXJ0eShrKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChrID09PSAnaWQnKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y29udGludWU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIGlmIChrID09PSAnY2xhc3MnKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bVtvYmouaWRdLmxpX2F0dHJbJ2NsYXNzJ10gPSAobVtvYmouaWRdLmxpX2F0dHJbJ2NsYXNzJ10gfHwgJycpLnJlcGxhY2UodFtvbGRfdHlwZV0ubGlfYXR0cltrXSwgJycpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChkKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZC5yZW1vdmVDbGFzcyh0W29sZF90eXBlXS5saV9hdHRyW2tdKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIGlmIChtW29iai5pZF0ubGlfYXR0cltrXSA9PT0gdFtvbGRfdHlwZV0ubGlfYXR0cltrXSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG1bb2JqLmlkXS5saV9hdHRyW2tdID0gbnVsbDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoZCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGQucmVtb3ZlQXR0cihrKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICh0W29sZF90eXBlXSAmJiB0W29sZF90eXBlXS5hX2F0dHIgIT09IHVuZGVmaW5lZCAmJiBfdHlwZW9mKHRbb2xkX3R5cGVdLmFfYXR0cikgPT09ICdvYmplY3QnKSB7XFxuXFx0XFx0XFx0XFx0Zm9yIChrIGluIHRbb2xkX3R5cGVdLmFfYXR0cikge1xcblxcdFxcdFxcdFxcdFxcdGlmICh0W29sZF90eXBlXS5hX2F0dHIuaGFzT3duUHJvcGVydHkoaykpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoayA9PT0gJ2lkJykge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGNvbnRpbnVlO1xcblxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoayA9PT0gJ2NsYXNzJykge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG1bb2JqLmlkXS5hX2F0dHJbJ2NsYXNzJ10gPSAobVtvYmouaWRdLmFfYXR0clsnY2xhc3MnXSB8fCAnJykucmVwbGFjZSh0W29sZF90eXBlXS5hX2F0dHJba10sICcnKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoYSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGEucmVtb3ZlQ2xhc3ModFtvbGRfdHlwZV0uYV9hdHRyW2tdKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIGlmIChtW29iai5pZF0uYV9hdHRyW2tdID09PSB0W29sZF90eXBlXS5hX2F0dHJba10pIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoayA9PT0gJ2hyZWYnKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bVtvYmouaWRdLmFfYXR0cltrXSA9ICcjJztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoYSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGEuYXR0cignaHJlZicsICcjJyk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGVsZXRlIG1bb2JqLmlkXS5hX2F0dHJba107XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKGEpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRhLnJlbW92ZUF0dHIoayk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gYWRkIG5ldyBwcm9wc1xcblxcdFxcdFxcdGlmICh0W3R5cGVdLmxpX2F0dHIgIT09IHVuZGVmaW5lZCAmJiBfdHlwZW9mKHRbdHlwZV0ubGlfYXR0cikgPT09ICdvYmplY3QnKSB7XFxuXFx0XFx0XFx0XFx0Zm9yIChrIGluIHRbdHlwZV0ubGlfYXR0cikge1xcblxcdFxcdFxcdFxcdFxcdGlmICh0W3R5cGVdLmxpX2F0dHIuaGFzT3duUHJvcGVydHkoaykpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoayA9PT0gJ2lkJykge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGNvbnRpbnVlO1xcblxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSBpZiAobVtvYmouaWRdLmxpX2F0dHJba10gPT09IHVuZGVmaW5lZCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG1bb2JqLmlkXS5saV9hdHRyW2tdID0gdFt0eXBlXS5saV9hdHRyW2tdO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChkKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKGsgPT09ICdjbGFzcycpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkLmFkZENsYXNzKHRbdHlwZV0ubGlfYXR0cltrXSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkLmF0dHIoaywgdFt0eXBlXS5saV9hdHRyW2tdKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoayA9PT0gJ2NsYXNzJykge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG1bb2JqLmlkXS5saV9hdHRyWydjbGFzcyddID0gdFt0eXBlXS5saV9hdHRyW2tdICsgJyAnICsgbVtvYmouaWRdLmxpX2F0dHJbJ2NsYXNzJ107XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKGQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkLmFkZENsYXNzKHRbdHlwZV0ubGlfYXR0cltrXSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAodFt0eXBlXS5hX2F0dHIgIT09IHVuZGVmaW5lZCAmJiBfdHlwZW9mKHRbdHlwZV0uYV9hdHRyKSA9PT0gJ29iamVjdCcpIHtcXG5cXHRcXHRcXHRcXHRmb3IgKGsgaW4gdFt0eXBlXS5hX2F0dHIpIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAodFt0eXBlXS5hX2F0dHIuaGFzT3duUHJvcGVydHkoaykpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoayA9PT0gJ2lkJykge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGNvbnRpbnVlO1xcblxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSBpZiAobVtvYmouaWRdLmFfYXR0cltrXSA9PT0gdW5kZWZpbmVkKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bVtvYmouaWRdLmFfYXR0cltrXSA9IHRbdHlwZV0uYV9hdHRyW2tdO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChhKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKGsgPT09ICdjbGFzcycpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRhLmFkZENsYXNzKHRbdHlwZV0uYV9hdHRyW2tdKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGEuYXR0cihrLCB0W3R5cGVdLmFfYXR0cltrXSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2UgaWYgKGsgPT09ICdocmVmJyAmJiBtW29iai5pZF0uYV9hdHRyW2tdID09PSAnIycpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRtW29iai5pZF0uYV9hdHRyWydocmVmJ10gPSB0W3R5cGVdLmFfYXR0clsnaHJlZiddO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChhKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YS5hdHRyKCdocmVmJywgdFt0eXBlXS5hX2F0dHJbJ2hyZWYnXSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoayA9PT0gJ2NsYXNzJykge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG1bb2JqLmlkXS5hX2F0dHJbJ2NsYXNzJ10gPSB0W3R5cGVdLmFfYXR0clsnY2xhc3MnXSArICcgJyArIG1bb2JqLmlkXS5hX2F0dHJbJ2NsYXNzJ107XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKGEpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRhLmFkZENsYXNzKHRbdHlwZV0uYV9hdHRyW2tdKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdH07XFxuXFx0fTtcXG5cXHQvLyBpbmNsdWRlIHRoZSB0eXBlcyBwbHVnaW4gYnkgZGVmYXVsdFxcblxcdC8vICQuanN0cmVlLmRlZmF1bHRzLnBsdWdpbnMucHVzaChcXFwidHlwZXNcXFwiKTtcXG5cXG5cXG5cXHQvKipcXG4gICogIyMjIFVuaXF1ZSBwbHVnaW5cXG4gICpcXG4gICogRW5mb3JjZXMgdGhhdCBubyBub2RlcyB3aXRoIHRoZSBzYW1lIG5hbWUgY2FuIGNvZXhpc3QgYXMgc2libGluZ3MuXFxuICAqL1xcblxcblxcdC8qKlxcbiAgKiBzdG9yZXMgYWxsIGRlZmF1bHRzIGZvciB0aGUgdW5pcXVlIHBsdWdpblxcbiAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy51bmlxdWVcXG4gICogQHBsdWdpbiB1bmlxdWVcXG4gICovXFxuXFx0JC5qc3RyZWUuZGVmYXVsdHMudW5pcXVlID0ge1xcblxcdFxcdC8qKlxcbiAgICogSW5kaWNhdGVzIGlmIHRoZSBjb21wYXJpc29uIHNob3VsZCBiZSBjYXNlIHNlbnNpdGl2ZS4gRGVmYXVsdCBpcyBgZmFsc2VgLlxcbiAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMudW5pcXVlLmNhc2Vfc2Vuc2l0aXZlXFxuICAgKiBAcGx1Z2luIHVuaXF1ZVxcbiAgICovXFxuXFx0XFx0Y2FzZV9zZW5zaXRpdmU6IGZhbHNlLFxcblxcdFxcdC8qKlxcbiAgICogQSBjYWxsYmFjayBleGVjdXRlZCBpbiB0aGUgaW5zdGFuY2UncyBzY29wZSB3aGVuIGEgbmV3IG5vZGUgaXMgY3JlYXRlZCBhbmQgdGhlIG5hbWUgaXMgYWxyZWFkeSB0YWtlbiwgdGhlIHR3byBhcmd1bWVudHMgYXJlIHRoZSBjb25mbGljdGluZyBuYW1lIGFuZCB0aGUgY291bnRlci4gVGhlIGRlZmF1bHQgd2lsbCBwcm9kdWNlIHJlc3VsdHMgbGlrZSBgTmV3IG5vZGUgKDIpYC5cXG4gICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLnVuaXF1ZS5kdXBsaWNhdGVcXG4gICAqIEBwbHVnaW4gdW5pcXVlXFxuICAgKi9cXG5cXHRcXHRkdXBsaWNhdGU6IGZ1bmN0aW9uIGR1cGxpY2F0ZShuYW1lLCBjb3VudGVyKSB7XFxuXFx0XFx0XFx0cmV0dXJuIG5hbWUgKyAnICgnICsgY291bnRlciArICcpJztcXG5cXHRcXHR9XFxuXFx0fTtcXG5cXG5cXHQkLmpzdHJlZS5wbHVnaW5zLnVuaXF1ZSA9IGZ1bmN0aW9uIChvcHRpb25zLCBwYXJlbnQpIHtcXG5cXHRcXHR0aGlzLmNoZWNrID0gZnVuY3Rpb24gKGNoaywgb2JqLCBwYXIsIHBvcywgbW9yZSkge1xcblxcdFxcdFxcdGlmIChwYXJlbnQuY2hlY2suY2FsbCh0aGlzLCBjaGssIG9iaiwgcGFyLCBwb3MsIG1vcmUpID09PSBmYWxzZSkge1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0b2JqID0gb2JqICYmIG9iai5pZCA/IG9iaiA6IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXHRcXHRcXHRwYXIgPSBwYXIgJiYgcGFyLmlkID8gcGFyIDogdGhpcy5nZXRfbm9kZShwYXIpO1xcblxcdFxcdFxcdGlmICghcGFyIHx8ICFwYXIuY2hpbGRyZW4pIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0dmFyIG4gPSBjaGsgPT09IFxcXCJyZW5hbWVfbm9kZVxcXCIgPyBwb3MgOiBvYmoudGV4dCxcXG5cXHRcXHRcXHQgICAgYyA9IFtdLFxcblxcdFxcdFxcdCAgICBzID0gdGhpcy5zZXR0aW5ncy51bmlxdWUuY2FzZV9zZW5zaXRpdmUsXFxuXFx0XFx0XFx0ICAgIG0gPSB0aGlzLl9tb2RlbC5kYXRhLFxcblxcdFxcdFxcdCAgICBpLFxcblxcdFxcdFxcdCAgICBqO1xcblxcdFxcdFxcdGZvciAoaSA9IDAsIGogPSBwYXIuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0Yy5wdXNoKHMgPyBtW3Bhci5jaGlsZHJlbltpXV0udGV4dCA6IG1bcGFyLmNoaWxkcmVuW2ldXS50ZXh0LnRvTG93ZXJDYXNlKCkpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoIXMpIHtcXG5cXHRcXHRcXHRcXHRuID0gbi50b0xvd2VyQ2FzZSgpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRzd2l0Y2ggKGNoaykge1xcblxcdFxcdFxcdFxcdGNhc2UgXFxcImRlbGV0ZV9ub2RlXFxcIjpcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRjYXNlIFxcXCJyZW5hbWVfbm9kZVxcXCI6XFxuXFx0XFx0XFx0XFx0XFx0aSA9ICQuaW5BcnJheShuLCBjKSA9PT0gLTEgfHwgb2JqLnRleHQgJiYgb2JqLnRleHRbcyA/ICd0b1N0cmluZycgOiAndG9Mb3dlckNhc2UnXSgpID09PSBuO1xcblxcdFxcdFxcdFxcdFxcdGlmICghaSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yID0geyAnZXJyb3InOiAnY2hlY2snLCAncGx1Z2luJzogJ3VuaXF1ZScsICdpZCc6ICd1bmlxdWVfMDEnLCAncmVhc29uJzogJ0NoaWxkIHdpdGggbmFtZSAnICsgbiArICcgYWxyZWFkeSBleGlzdHMuIFByZXZlbnRpbmc6ICcgKyBjaGssICdkYXRhJzogSlNPTi5zdHJpbmdpZnkoeyAnY2hrJzogY2hrLCAncG9zJzogcG9zLCAnb2JqJzogb2JqICYmIG9iai5pZCA/IG9iai5pZCA6IGZhbHNlLCAncGFyJzogcGFyICYmIHBhci5pZCA/IHBhci5pZCA6IGZhbHNlIH0pIH07XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBpO1xcblxcdFxcdFxcdFxcdGNhc2UgXFxcImNyZWF0ZV9ub2RlXFxcIjpcXG5cXHRcXHRcXHRcXHRcXHRpID0gJC5pbkFycmF5KG4sIGMpID09PSAtMTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIWkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvciA9IHsgJ2Vycm9yJzogJ2NoZWNrJywgJ3BsdWdpbic6ICd1bmlxdWUnLCAnaWQnOiAndW5pcXVlXzA0JywgJ3JlYXNvbic6ICdDaGlsZCB3aXRoIG5hbWUgJyArIG4gKyAnIGFscmVhZHkgZXhpc3RzLiBQcmV2ZW50aW5nOiAnICsgY2hrLCAnZGF0YSc6IEpTT04uc3RyaW5naWZ5KHsgJ2Noayc6IGNoaywgJ3Bvcyc6IHBvcywgJ29iaic6IG9iaiAmJiBvYmouaWQgPyBvYmouaWQgOiBmYWxzZSwgJ3Bhcic6IHBhciAmJiBwYXIuaWQgPyBwYXIuaWQgOiBmYWxzZSB9KSB9O1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gaTtcXG5cXHRcXHRcXHRcXHRjYXNlIFxcXCJjb3B5X25vZGVcXFwiOlxcblxcdFxcdFxcdFxcdFxcdGkgPSAkLmluQXJyYXkobiwgYykgPT09IC0xO1xcblxcdFxcdFxcdFxcdFxcdGlmICghaSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yID0geyAnZXJyb3InOiAnY2hlY2snLCAncGx1Z2luJzogJ3VuaXF1ZScsICdpZCc6ICd1bmlxdWVfMDInLCAncmVhc29uJzogJ0NoaWxkIHdpdGggbmFtZSAnICsgbiArICcgYWxyZWFkeSBleGlzdHMuIFByZXZlbnRpbmc6ICcgKyBjaGssICdkYXRhJzogSlNPTi5zdHJpbmdpZnkoeyAnY2hrJzogY2hrLCAncG9zJzogcG9zLCAnb2JqJzogb2JqICYmIG9iai5pZCA/IG9iai5pZCA6IGZhbHNlLCAncGFyJzogcGFyICYmIHBhci5pZCA/IHBhci5pZCA6IGZhbHNlIH0pIH07XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBpO1xcblxcdFxcdFxcdFxcdGNhc2UgXFxcIm1vdmVfbm9kZVxcXCI6XFxuXFx0XFx0XFx0XFx0XFx0aSA9IG9iai5wYXJlbnQgPT09IHBhci5pZCAmJiAoIW1vcmUgfHwgIW1vcmUuaXNfbXVsdGkpIHx8ICQuaW5BcnJheShuLCBjKSA9PT0gLTE7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCFpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IgPSB7ICdlcnJvcic6ICdjaGVjaycsICdwbHVnaW4nOiAndW5pcXVlJywgJ2lkJzogJ3VuaXF1ZV8wMycsICdyZWFzb24nOiAnQ2hpbGQgd2l0aCBuYW1lICcgKyBuICsgJyBhbHJlYWR5IGV4aXN0cy4gUHJldmVudGluZzogJyArIGNoaywgJ2RhdGEnOiBKU09OLnN0cmluZ2lmeSh7ICdjaGsnOiBjaGssICdwb3MnOiBwb3MsICdvYmonOiBvYmogJiYgb2JqLmlkID8gb2JqLmlkIDogZmFsc2UsICdwYXInOiBwYXIgJiYgcGFyLmlkID8gcGFyLmlkIDogZmFsc2UgfSkgfTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdH07XFxuXFx0XFx0dGhpcy5jcmVhdGVfbm9kZSA9IGZ1bmN0aW9uIChwYXIsIG5vZGUsIHBvcywgY2FsbGJhY2ssIGlzX2xvYWRlZCkge1xcblxcdFxcdFxcdGlmICghbm9kZSB8fCBub2RlLnRleHQgPT09IHVuZGVmaW5lZCkge1xcblxcdFxcdFxcdFxcdGlmIChwYXIgPT09IG51bGwpIHtcXG5cXHRcXHRcXHRcXHRcXHRwYXIgPSAkLmpzdHJlZS5yb290O1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRwYXIgPSB0aGlzLmdldF9ub2RlKHBhcik7XFxuXFx0XFx0XFx0XFx0aWYgKCFwYXIpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gcGFyZW50LmNyZWF0ZV9ub2RlLmNhbGwodGhpcywgcGFyLCBub2RlLCBwb3MsIGNhbGxiYWNrLCBpc19sb2FkZWQpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRwb3MgPSBwb3MgPT09IHVuZGVmaW5lZCA/IFxcXCJsYXN0XFxcIiA6IHBvcztcXG5cXHRcXHRcXHRcXHRpZiAoIXBvcy50b1N0cmluZygpLm1hdGNoKC9eKGJlZm9yZXxhZnRlcikkLykgJiYgIWlzX2xvYWRlZCAmJiAhdGhpcy5pc19sb2FkZWQocGFyKSkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBwYXJlbnQuY3JlYXRlX25vZGUuY2FsbCh0aGlzLCBwYXIsIG5vZGUsIHBvcywgY2FsbGJhY2ssIGlzX2xvYWRlZCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGlmICghbm9kZSkge1xcblxcdFxcdFxcdFxcdFxcdG5vZGUgPSB7fTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0dmFyIHRtcCxcXG5cXHRcXHRcXHRcXHQgICAgbixcXG5cXHRcXHRcXHRcXHQgICAgZHBjLFxcblxcdFxcdFxcdFxcdCAgICBpLFxcblxcdFxcdFxcdFxcdCAgICBqLFxcblxcdFxcdFxcdFxcdCAgICBtID0gdGhpcy5fbW9kZWwuZGF0YSxcXG5cXHRcXHRcXHRcXHQgICAgcyA9IHRoaXMuc2V0dGluZ3MudW5pcXVlLmNhc2Vfc2Vuc2l0aXZlLFxcblxcdFxcdFxcdFxcdCAgICBjYiA9IHRoaXMuc2V0dGluZ3MudW5pcXVlLmR1cGxpY2F0ZTtcXG5cXHRcXHRcXHRcXHRuID0gdG1wID0gdGhpcy5nZXRfc3RyaW5nKCdOZXcgbm9kZScpO1xcblxcdFxcdFxcdFxcdGRwYyA9IFtdO1xcblxcdFxcdFxcdFxcdGZvciAoaSA9IDAsIGogPSBwYXIuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZHBjLnB1c2gocyA/IG1bcGFyLmNoaWxkcmVuW2ldXS50ZXh0IDogbVtwYXIuY2hpbGRyZW5baV1dLnRleHQudG9Mb3dlckNhc2UoKSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGkgPSAxO1xcblxcdFxcdFxcdFxcdHdoaWxlICgkLmluQXJyYXkocyA/IG4gOiBuLnRvTG93ZXJDYXNlKCksIGRwYykgIT09IC0xKSB7XFxuXFx0XFx0XFx0XFx0XFx0biA9IGNiLmNhbGwodGhpcywgdG1wLCArK2kpLnRvU3RyaW5nKCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdG5vZGUudGV4dCA9IG47XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiBwYXJlbnQuY3JlYXRlX25vZGUuY2FsbCh0aGlzLCBwYXIsIG5vZGUsIHBvcywgY2FsbGJhY2ssIGlzX2xvYWRlZCk7XFxuXFx0XFx0fTtcXG5cXHR9O1xcblxcblxcdC8vIGluY2x1ZGUgdGhlIHVuaXF1ZSBwbHVnaW4gYnkgZGVmYXVsdFxcblxcdC8vICQuanN0cmVlLmRlZmF1bHRzLnBsdWdpbnMucHVzaChcXFwidW5pcXVlXFxcIik7XFxuXFxuXFxuXFx0LyoqXFxuICAqICMjIyBXaG9sZXJvdyBwbHVnaW5cXG4gICpcXG4gICogTWFrZXMgZWFjaCBub2RlIGFwcGVhciBibG9jayBsZXZlbC4gTWFraW5nIHNlbGVjdGlvbiBlYXNpZXIuIE1heSBjYXVzZSBzbG93IGRvd24gZm9yIGxhcmdlIHRyZWVzIGluIG9sZCBicm93c2Vycy5cXG4gICovXFxuXFxuXFx0dmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xcblxcdGRpdi5zZXRBdHRyaWJ1dGUoJ3Vuc2VsZWN0YWJsZScsICdvbicpO1xcblxcdGRpdi5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAncHJlc2VudGF0aW9uJyk7XFxuXFx0ZGl2LmNsYXNzTmFtZSA9ICdqc3RyZWUtd2hvbGVyb3cnO1xcblxcdGRpdi5pbm5lckhUTUwgPSAnJiMxNjA7JztcXG5cXHQkLmpzdHJlZS5wbHVnaW5zLndob2xlcm93ID0gZnVuY3Rpb24gKG9wdGlvbnMsIHBhcmVudCkge1xcblxcdFxcdHRoaXMuYmluZCA9IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRwYXJlbnQuYmluZC5jYWxsKHRoaXMpO1xcblxcblxcdFxcdFxcdHRoaXMuZWxlbWVudC5vbigncmVhZHkuanN0cmVlIHNldF9zdGF0ZS5qc3RyZWUnLCAkLnByb3h5KGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLmhpZGVfZG90cygpO1xcblxcdFxcdFxcdH0sIHRoaXMpKS5vbihcXFwiaW5pdC5qc3RyZWUgbG9hZGluZy5qc3RyZWUgcmVhZHkuanN0cmVlXFxcIiwgJC5wcm94eShmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0Ly9kaXYuc3R5bGUuaGVpZ2h0ID0gdGhpcy5fZGF0YS5jb3JlLmxpX2hlaWdodCArICdweCc7XFxuXFx0XFx0XFx0XFx0dGhpcy5nZXRfY29udGFpbmVyX3VsKCkuYWRkQ2xhc3MoJ2pzdHJlZS13aG9sZXJvdy11bCcpO1xcblxcdFxcdFxcdH0sIHRoaXMpKS5vbihcXFwiZGVzZWxlY3RfYWxsLmpzdHJlZVxcXCIsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLmVsZW1lbnQuZmluZCgnLmpzdHJlZS13aG9sZXJvdy1jbGlja2VkJykucmVtb3ZlQ2xhc3MoJ2pzdHJlZS13aG9sZXJvdy1jbGlja2VkJyk7XFxuXFx0XFx0XFx0fSwgdGhpcykpLm9uKFxcXCJjaGFuZ2VkLmpzdHJlZVxcXCIsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLmVsZW1lbnQuZmluZCgnLmpzdHJlZS13aG9sZXJvdy1jbGlja2VkJykucmVtb3ZlQ2xhc3MoJ2pzdHJlZS13aG9sZXJvdy1jbGlja2VkJyk7XFxuXFx0XFx0XFx0XFx0dmFyIHRtcCA9IGZhbHNlLFxcblxcdFxcdFxcdFxcdCAgICBpLFxcblxcdFxcdFxcdFxcdCAgICBqO1xcblxcdFxcdFxcdFxcdGZvciAoaSA9IDAsIGogPSBkYXRhLnNlbGVjdGVkLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdHRtcCA9IHRoaXMuZ2V0X25vZGUoZGF0YS5zZWxlY3RlZFtpXSwgdHJ1ZSk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHRtcCAmJiB0bXAubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dG1wLmNoaWxkcmVuKCcuanN0cmVlLXdob2xlcm93JykuYWRkQ2xhc3MoJ2pzdHJlZS13aG9sZXJvdy1jbGlja2VkJyk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LCB0aGlzKSkub24oXFxcIm9wZW5fbm9kZS5qc3RyZWVcXFwiLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5nZXRfbm9kZShkYXRhLm5vZGUsIHRydWUpLmZpbmQoJy5qc3RyZWUtY2xpY2tlZCcpLnBhcmVudCgpLmNoaWxkcmVuKCcuanN0cmVlLXdob2xlcm93JykuYWRkQ2xhc3MoJ2pzdHJlZS13aG9sZXJvdy1jbGlja2VkJyk7XFxuXFx0XFx0XFx0fSwgdGhpcykpLm9uKFxcXCJob3Zlcl9ub2RlLmpzdHJlZSBkZWhvdmVyX25vZGUuanN0cmVlXFxcIiwgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xcblxcdFxcdFxcdFxcdGlmIChlLnR5cGUgPT09IFxcXCJob3Zlcl9ub2RlXFxcIiAmJiB0aGlzLmlzX2Rpc2FibGVkKGRhdGEubm9kZSkpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHRoaXMuZ2V0X25vZGUoZGF0YS5ub2RlLCB0cnVlKS5jaGlsZHJlbignLmpzdHJlZS13aG9sZXJvdycpW2UudHlwZSA9PT0gXFxcImhvdmVyX25vZGVcXFwiID8gXFxcImFkZENsYXNzXFxcIiA6IFxcXCJyZW1vdmVDbGFzc1xcXCJdKCdqc3RyZWUtd2hvbGVyb3ctaG92ZXJlZCcpO1xcblxcdFxcdFxcdH0sIHRoaXMpKS5vbihcXFwiY29udGV4dG1lbnUuanN0cmVlXFxcIiwgXFxcIi5qc3RyZWUtd2hvbGVyb3dcXFwiLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XFxuXFx0XFx0XFx0XFx0aWYgKHRoaXMuX2RhdGEuY29udGV4dG1lbnUpIHtcXG5cXHRcXHRcXHRcXHRcXHRlLnByZXZlbnREZWZhdWx0KCk7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIHRtcCA9ICQuRXZlbnQoJ2NvbnRleHRtZW51JywgeyBtZXRhS2V5OiBlLm1ldGFLZXksIGN0cmxLZXk6IGUuY3RybEtleSwgYWx0S2V5OiBlLmFsdEtleSwgc2hpZnRLZXk6IGUuc2hpZnRLZXksIHBhZ2VYOiBlLnBhZ2VYLCBwYWdlWTogZS5wYWdlWSB9KTtcXG5cXHRcXHRcXHRcXHRcXHQkKGUuY3VycmVudFRhcmdldCkuY2xvc2VzdChcXFwiLmpzdHJlZS1ub2RlXFxcIikuY2hpbGRyZW4oXFxcIi5qc3RyZWUtYW5jaG9yXFxcIikuZmlyc3QoKS50cmlnZ2VyKHRtcCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sIHRoaXMpKVxcblxcdFxcdFxcdC8qIVxcbiAgIC5vbihcXFwibW91c2Vkb3duLmpzdHJlZSB0b3VjaHN0YXJ0LmpzdHJlZVxcXCIsIFxcXCIuanN0cmVlLXdob2xlcm93XFxcIiwgZnVuY3Rpb24gKGUpIHtcXG4gICBcXHRcXHRpZihlLnRhcmdldCA9PT0gZS5jdXJyZW50VGFyZ2V0KSB7XFxuICAgXFx0XFx0XFx0dmFyIGEgPSAkKGUuY3VycmVudFRhcmdldCkuY2xvc2VzdChcXFwiLmpzdHJlZS1ub2RlXFxcIikuY2hpbGRyZW4oXFxcIi5qc3RyZWUtYW5jaG9yXFxcIik7XFxuICAgXFx0XFx0XFx0ZS50YXJnZXQgPSBhWzBdO1xcbiAgIFxcdFxcdFxcdGEudHJpZ2dlcihlKTtcXG4gICBcXHRcXHR9XFxuICAgXFx0fSlcXG4gICAqL1xcblxcdFxcdFxcdC5vbihcXFwiY2xpY2suanN0cmVlXFxcIiwgXFxcIi5qc3RyZWUtd2hvbGVyb3dcXFwiLCBmdW5jdGlvbiAoZSkge1xcblxcdFxcdFxcdFxcdGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XFxuXFx0XFx0XFx0XFx0dmFyIHRtcCA9ICQuRXZlbnQoJ2NsaWNrJywgeyBtZXRhS2V5OiBlLm1ldGFLZXksIGN0cmxLZXk6IGUuY3RybEtleSwgYWx0S2V5OiBlLmFsdEtleSwgc2hpZnRLZXk6IGUuc2hpZnRLZXkgfSk7XFxuXFx0XFx0XFx0XFx0JChlLmN1cnJlbnRUYXJnZXQpLmNsb3Nlc3QoXFxcIi5qc3RyZWUtbm9kZVxcXCIpLmNoaWxkcmVuKFxcXCIuanN0cmVlLWFuY2hvclxcXCIpLmZpcnN0KCkudHJpZ2dlcih0bXApLmZvY3VzKCk7XFxuXFx0XFx0XFx0fSkub24oXFxcImRibGNsaWNrLmpzdHJlZVxcXCIsIFxcXCIuanN0cmVlLXdob2xlcm93XFxcIiwgZnVuY3Rpb24gKGUpIHtcXG5cXHRcXHRcXHRcXHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xcblxcdFxcdFxcdFxcdHZhciB0bXAgPSAkLkV2ZW50KCdkYmxjbGljaycsIHsgbWV0YUtleTogZS5tZXRhS2V5LCBjdHJsS2V5OiBlLmN0cmxLZXksIGFsdEtleTogZS5hbHRLZXksIHNoaWZ0S2V5OiBlLnNoaWZ0S2V5IH0pO1xcblxcdFxcdFxcdFxcdCQoZS5jdXJyZW50VGFyZ2V0KS5jbG9zZXN0KFxcXCIuanN0cmVlLW5vZGVcXFwiKS5jaGlsZHJlbihcXFwiLmpzdHJlZS1hbmNob3JcXFwiKS5maXJzdCgpLnRyaWdnZXIodG1wKS5mb2N1cygpO1xcblxcdFxcdFxcdH0pLm9uKFxcXCJjbGljay5qc3RyZWVcXFwiLCBcXFwiLmpzdHJlZS1sZWFmID4gLmpzdHJlZS1vY2xcXFwiLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XFxuXFx0XFx0XFx0XFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcXG5cXHRcXHRcXHRcXHR2YXIgdG1wID0gJC5FdmVudCgnY2xpY2snLCB7IG1ldGFLZXk6IGUubWV0YUtleSwgY3RybEtleTogZS5jdHJsS2V5LCBhbHRLZXk6IGUuYWx0S2V5LCBzaGlmdEtleTogZS5zaGlmdEtleSB9KTtcXG5cXHRcXHRcXHRcXHQkKGUuY3VycmVudFRhcmdldCkuY2xvc2VzdChcXFwiLmpzdHJlZS1ub2RlXFxcIikuY2hpbGRyZW4oXFxcIi5qc3RyZWUtYW5jaG9yXFxcIikuZmlyc3QoKS50cmlnZ2VyKHRtcCkuZm9jdXMoKTtcXG5cXHRcXHRcXHR9LCB0aGlzKSkub24oXFxcIm1vdXNlb3Zlci5qc3RyZWVcXFwiLCBcXFwiLmpzdHJlZS13aG9sZXJvdywgLmpzdHJlZS1pY29uXFxcIiwgJC5wcm94eShmdW5jdGlvbiAoZSkge1xcblxcdFxcdFxcdFxcdGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XFxuXFx0XFx0XFx0XFx0aWYgKCF0aGlzLmlzX2Rpc2FibGVkKGUuY3VycmVudFRhcmdldCkpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmhvdmVyX25vZGUoZS5jdXJyZW50VGFyZ2V0KTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH0sIHRoaXMpKS5vbihcXFwibW91c2VsZWF2ZS5qc3RyZWVcXFwiLCBcXFwiLmpzdHJlZS1ub2RlXFxcIiwgJC5wcm94eShmdW5jdGlvbiAoZSkge1xcblxcdFxcdFxcdFxcdHRoaXMuZGVob3Zlcl9ub2RlKGUuY3VycmVudFRhcmdldCk7XFxuXFx0XFx0XFx0fSwgdGhpcykpO1xcblxcdFxcdH07XFxuXFx0XFx0dGhpcy50ZWFyZG93biA9IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRpZiAodGhpcy5zZXR0aW5ncy53aG9sZXJvdykge1xcblxcdFxcdFxcdFxcdHRoaXMuZWxlbWVudC5maW5kKFxcXCIuanN0cmVlLXdob2xlcm93XFxcIikucmVtb3ZlKCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHBhcmVudC50ZWFyZG93bi5jYWxsKHRoaXMpO1xcblxcdFxcdH07XFxuXFx0XFx0dGhpcy5yZWRyYXdfbm9kZSA9IGZ1bmN0aW9uIChvYmosIGRlZXAsIGNhbGxiYWNrLCBmb3JjZV9yZW5kZXIpIHtcXG5cXHRcXHRcXHRvYmogPSBwYXJlbnQucmVkcmF3X25vZGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG5cXHRcXHRcXHRpZiAob2JqKSB7XFxuXFx0XFx0XFx0XFx0dmFyIHRtcCA9IGRpdi5jbG9uZU5vZGUodHJ1ZSk7XFxuXFx0XFx0XFx0XFx0Ly90bXAuc3R5bGUuaGVpZ2h0ID0gdGhpcy5fZGF0YS5jb3JlLmxpX2hlaWdodCArICdweCc7XFxuXFx0XFx0XFx0XFx0aWYgKCQuaW5BcnJheShvYmouaWQsIHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZCkgIT09IC0xKSB7XFxuXFx0XFx0XFx0XFx0XFx0dG1wLmNsYXNzTmFtZSArPSAnIGpzdHJlZS13aG9sZXJvdy1jbGlja2VkJztcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aWYgKHRoaXMuX2RhdGEuY29yZS5mb2N1c2VkICYmIHRoaXMuX2RhdGEuY29yZS5mb2N1c2VkID09PSBvYmouaWQpIHtcXG5cXHRcXHRcXHRcXHRcXHR0bXAuY2xhc3NOYW1lICs9ICcganN0cmVlLXdob2xlcm93LWhvdmVyZWQnO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRvYmouaW5zZXJ0QmVmb3JlKHRtcCwgb2JqLmNoaWxkTm9kZXNbMF0pO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gb2JqO1xcblxcdFxcdH07XFxuXFx0fTtcXG5cXHQvLyBpbmNsdWRlIHRoZSB3aG9sZXJvdyBwbHVnaW4gYnkgZGVmYXVsdFxcblxcdC8vICQuanN0cmVlLmRlZmF1bHRzLnBsdWdpbnMucHVzaChcXFwid2hvbGVyb3dcXFwiKTtcXG5cXHRpZiAoZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50ICYmIE9iamVjdCAmJiBPYmplY3QuY3JlYXRlKSB7XFxuXFx0XFx0dmFyIHByb3RvID0gT2JqZWN0LmNyZWF0ZShIVE1MRWxlbWVudC5wcm90b3R5cGUpO1xcblxcdFxcdHByb3RvLmNyZWF0ZWRDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHR2YXIgYyA9IHsgY29yZToge30sIHBsdWdpbnM6IFtdIH0sXFxuXFx0XFx0XFx0ICAgIGk7XFxuXFx0XFx0XFx0Zm9yIChpIGluICQuanN0cmVlLnBsdWdpbnMpIHtcXG5cXHRcXHRcXHRcXHRpZiAoJC5qc3RyZWUucGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShpKSAmJiB0aGlzLmF0dHJpYnV0ZXNbaV0pIHtcXG5cXHRcXHRcXHRcXHRcXHRjLnBsdWdpbnMucHVzaChpKTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAodGhpcy5nZXRBdHRyaWJ1dGUoaSkgJiYgSlNPTi5wYXJzZSh0aGlzLmdldEF0dHJpYnV0ZShpKSkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRjW2ldID0gSlNPTi5wYXJzZSh0aGlzLmdldEF0dHJpYnV0ZShpKSk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0Zm9yIChpIGluICQuanN0cmVlLmRlZmF1bHRzLmNvcmUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoJC5qc3RyZWUuZGVmYXVsdHMuY29yZS5oYXNPd25Qcm9wZXJ0eShpKSAmJiB0aGlzLmF0dHJpYnV0ZXNbaV0pIHtcXG5cXHRcXHRcXHRcXHRcXHRjLmNvcmVbaV0gPSBKU09OLnBhcnNlKHRoaXMuZ2V0QXR0cmlidXRlKGkpKSB8fCB0aGlzLmdldEF0dHJpYnV0ZShpKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdCQodGhpcykuanN0cmVlKGMpO1xcblxcdFxcdH07XFxuXFx0XFx0Ly8gcHJvdG8uYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrID0gZnVuY3Rpb24gKG5hbWUsIHByZXZpb3VzLCB2YWx1ZSkgeyB9O1xcblxcdFxcdHRyeSB7XFxuXFx0XFx0XFx0ZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KFxcXCJ2YWthdGEtanN0cmVlXFxcIiwgeyBwcm90b3R5cGU6IHByb3RvIH0pO1xcblxcdFxcdH0gY2F0Y2ggKGlnbm9yZSkge31cXG5cXHR9XFxufSk7XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yYXctbG9hZGVyIS4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWI/P3JlZi0tMC0wIS4vYXNzZXRzL2pzL2pzdHJlZS0zLjMuMy5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvcmF3LWxvYWRlci9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTAtMCEuL2Fzc2V0cy9qcy9qc3RyZWUtMy4zLjMuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAzIiwiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc3JjKSB7XG5cdGZ1bmN0aW9uIGxvZyhlcnJvcikge1xuXHRcdCh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIilcblx0XHQmJiAoY29uc29sZS5lcnJvciB8fCBjb25zb2xlLmxvZykoXCJbU2NyaXB0IExvYWRlcl1cIiwgZXJyb3IpO1xuXHR9XG5cblx0Ly8gQ2hlY2sgZm9yIElFID08IDhcblx0ZnVuY3Rpb24gaXNJRSgpIHtcblx0XHRyZXR1cm4gdHlwZW9mIGF0dGFjaEV2ZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBhZGRFdmVudExpc3RlbmVyID09PSBcInVuZGVmaW5lZFwiO1xuXHR9XG5cblx0dHJ5IHtcblx0XHRpZiAodHlwZW9mIGV4ZWNTY3JpcHQgIT09IFwidW5kZWZpbmVkXCIgJiYgaXNJRSgpKSB7XG5cdFx0XHRleGVjU2NyaXB0KHNyYyk7XG5cdFx0fSBlbHNlIGlmICh0eXBlb2YgZXZhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0ZXZhbC5jYWxsKG51bGwsIHNyYyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxvZyhcIkV2YWxFcnJvcjogTm8gZXZhbCBmdW5jdGlvbiBhdmFpbGFibGVcIik7XG5cdFx0fVxuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdGxvZyhlcnJvcik7XG5cdH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMiLCJyZXF1aXJlKFwiISEvaG9tZS9vc2JveGVzL3dvcmtzcGFjZS9tbGFiLmxvY2FsLnRlc3Qvbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzXCIpKHJlcXVpcmUoXCIhIS9ob21lL29zYm94ZXMvd29ya3NwYWNlL21sYWIubG9jYWwudGVzdC9ub2RlX21vZHVsZXMvcmF3LWxvYWRlci9pbmRleC5qcyEvaG9tZS9vc2JveGVzL3dvcmtzcGFjZS9tbGFiLmxvY2FsLnRlc3Qvbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMC0wIS9ob21lL29zYm94ZXMvd29ya3NwYWNlL21sYWIubG9jYWwudGVzdC9hc3NldHMvanMvanN0cmVlLTMuMy4zLmpzXCIpK1wiXFxuXFxuLy8gU0NSSVBULUxPQURFUiBGT09URVJcXG4vLyMgc291cmNlVVJMPXNjcmlwdDovLy9ob21lL29zYm94ZXMvd29ya3NwYWNlL21sYWIubG9jYWwudGVzdC9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyUzRj9yZWYtLTAtMCEvaG9tZS9vc2JveGVzL3dvcmtzcGFjZS9tbGFiLmxvY2FsLnRlc3QvYXNzZXRzL2pzL2pzdHJlZS0zLjMuMy5qc1wiKVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIhLi9hc3NldHMvanMvanN0cmVlLTMuMy4zLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyL2luZGV4LmpzIS4vYXNzZXRzL2pzL2pzdHJlZS0zLjMuMy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDMiXSwic291cmNlUm9vdCI6IiJ9
=======
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vYXNzZXRzL2pzL2FkbWluLmpzIiwid2VicGFjazovLy8uL2Fzc2V0cy9qcy9qc3RyZWUtMy4zLjMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzIiwid2VicGFjazovLy8uL2Fzc2V0cy9qcy9qc3RyZWUtMy4zLjMuanM/OTI2MyJdLCJuYW1lcyI6WyJyZXF1aXJlIl0sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrREFBMEMsZ0NBQWdDO0FBQzFFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0VBQXdELGtCQUFrQjtBQUMxRTtBQUNBLHlEQUFpRCxjQUFjO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBeUMsaUNBQWlDO0FBQzFFLHdIQUFnSCxtQkFBbUIsRUFBRTtBQUNySTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUEyQiwwQkFBMEIsRUFBRTtBQUN2RCx5Q0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBc0QsK0RBQStEOztBQUVySDtBQUNBOzs7QUFHQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNsRkE7Ozs7O0FBS0FBLG1CQUFPLENBQUMsMEdBQUQsQ0FBUCxDOzs7Ozs7Ozs7OztBQ0xBLHlDQUF5QywrRUFBK0Usa0NBQWtDLG1CQUFtQixHQUFHLEVBQUUsT0FBTyxrQ0FBa0Msa0lBQWtJLEdBQUcsRUFBRSxxQkFBcUIsRUFBRSwrR0FBK0csbUJBQW1C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QVMsNkVBQTZFLHVDQUF1QyxzQ0FBc0Msc0lBQXNJLEVBQUUsaUhBQWlILFNBQVMsNEZBQTRGLHVDQUF1QyxxREFBcUQsNkNBQTZDLFdBQVcseUJBQXlCLFNBQVMsMkVBQTJFLDZDQUE2QyxTQUFTLFNBQVMsUUFBUSxxQ0FBcUMscUNBQXFDLDJEQUEyRCxTQUFTLHFDQUFxQyxRQUFRLHlFQUF5RSx3REFBd0Qsb0JBQW9CLHdDQUF3Qyx1REFBdUQscUVBQXFFLHdEQUF3RCxXQUFXLGdGQUFnRix3REFBd0QsV0FBVyxxREFBcUQsU0FBUyxxQkFBcUIsUUFBUSxNQUFNLDhGQUE4RixrRUFBa0UsdURBQXVELDZDQUE2QyxpQkFBaUIsa0JBQWtCLCtCQUErQixlQUFlLHVDQUF1Qyx5RUFBeUUsOEJBQThCLDZFQUE2RSxzREFBc0QsYUFBYSxXQUFXLFNBQVMsNkNBQTZDLCtFQUErRSxpRkFBaUYsV0FBVyxTQUFTLDRCQUE0QixRQUFRLHVFQUF1RSxHQUFHLGVBQWUscURBQXFELG1DQUFtQyxFQUFFLE9BQU8sa0JBQWtCLEtBQUssR0FBRyxFQUFFLEM7Ozs7Ozs7Ozs7O0FDQTU1cVY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDMUJBLG1CQUFPLENBQUMsNkZBQW1GLEVBQUUsbUJBQU8sQ0FBQyxrTkFBdU8scU4iLCJmaWxlIjoiYWRtaW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIi9idWlsZC9cIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9hc3NldHMvanMvYWRtaW4uanNcIik7XG4iLCIvKiBcbiAqIFRvIGNoYW5nZSB0aGlzIGxpY2Vuc2UgaGVhZGVyLCBjaG9vc2UgTGljZW5zZSBIZWFkZXJzIGluIFByb2plY3QgUHJvcGVydGllcy5cbiAqIFRvIGNoYW5nZSB0aGlzIHRlbXBsYXRlIGZpbGUsIGNob29zZSBUb29scyB8IFRlbXBsYXRlc1xuICogYW5kIG9wZW4gdGhlIHRlbXBsYXRlIGluIHRoZSBlZGl0b3IuXG4gKi9cbnJlcXVpcmUoJ3NjcmlwdC1sb2FkZXIhLi9qc3RyZWUtMy4zLjMuanMnKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gXCJmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcXFwic3ltYm9sXFxcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXFxcInN5bWJvbFxcXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cXG5cXG4vKmdsb2JhbHMgalF1ZXJ5LCBkZWZpbmUsIG1vZHVsZSwgZXhwb3J0cywgcmVxdWlyZSwgd2luZG93LCBkb2N1bWVudCwgcG9zdE1lc3NhZ2UgKi9cXG4oZnVuY3Rpb24gKGZhY3RvcnkpIHtcXG4gIFxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcXG4gICAgZGVmaW5lKFsnanF1ZXJ5J10sIGZhY3RvcnkpO1xcbiAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSgnanF1ZXJ5JykpO1xcbiAgfSBlbHNlIHtcXG4gICAgZmFjdG9yeShqUXVlcnkpO1xcbiAgfVxcbn0pKGZ1bmN0aW9uICgkLCB1bmRlZmluZWQpIHtcXG4gIFxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG4gIC8qIVxcbiAgICoganNUcmVlIDMuMy4zXFxuICAgKiBodHRwOi8vanN0cmVlLmNvbS9cXG4gICAqXFxuICAgKiBDb3B5cmlnaHQgKGMpIDIwMTQgSXZhbiBCb3poYW5vdiAoaHR0cDovL3Zha2F0YS5jb20pXFxuICAgKlxcbiAgICogTGljZW5zZWQgc2FtZSBhcyBqcXVlcnkgLSB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlXFxuICAgKiAgIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXFxuICAgKi9cXG5cXG4gIC8qIVxcbiAgICogaWYgdXNpbmcganNsaW50IHBsZWFzZSBhbGxvdyBmb3IgdGhlIGpRdWVyeSBnbG9iYWwgYW5kIHVzZSBmb2xsb3dpbmcgb3B0aW9uczpcXG4gICAqIGpzbGludDogbG9vcGZ1bmM6IHRydWUsIGJyb3dzZXI6IHRydWUsIGFzczogdHJ1ZSwgYml0d2lzZTogdHJ1ZSwgY29udGludWU6IHRydWUsIG5vbWVuOiB0cnVlLCBwbHVzcGx1czogdHJ1ZSwgcmVnZXhwOiB0cnVlLCB1bnBhcmFtOiB0cnVlLCB0b2RvOiB0cnVlLCB3aGl0ZTogdHJ1ZVxcbiAgICovXFxuXFxuICAvKmpzaGludCAtVzA4MyAqL1xcbiAgLy8gcHJldmVudCBhbm90aGVyIGxvYWQ/IG1heWJlIHRoZXJlIGlzIGEgYmV0dGVyIHdheT9cXG5cXG4gIGlmICgkLmpzdHJlZSkge1xcbiAgICByZXR1cm47XFxuICB9XFxuICAvKipcXG4gICAqICMjIyBqc1RyZWUgY29yZSBmdW5jdGlvbmFsaXR5XFxuICAgKi9cXG4gIC8vIGludGVybmFsIHZhcmlhYmxlc1xcblxcblxcbiAgdmFyIGluc3RhbmNlX2NvdW50ZXIgPSAwLFxcbiAgICAgIGNjcF9ub2RlID0gZmFsc2UsXFxuICAgICAgY2NwX21vZGUgPSBmYWxzZSxcXG4gICAgICBjY3BfaW5zdCA9IGZhbHNlLFxcbiAgICAgIHRoZW1lc19sb2FkZWQgPSBbXSxcXG4gICAgICBzcmMgPSAkKCdzY3JpcHQ6bGFzdCcpLmF0dHIoJ3NyYycpLFxcbiAgICAgIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50OyAvLyBsb2NhbCB2YXJpYWJsZSBpcyBhbHdheXMgZmFzdGVyIHRvIGFjY2VzcyB0aGVuIGEgZ2xvYmFsXFxuXFxuICAvKipcXG4gICAqIGhvbGRzIGFsbCBqc3RyZWUgcmVsYXRlZCBmdW5jdGlvbnMgYW5kIHZhcmlhYmxlcywgaW5jbHVkaW5nIHRoZSBhY3R1YWwgY2xhc3MgYW5kIG1ldGhvZHMgdG8gY3JlYXRlLCBhY2Nlc3MgYW5kIG1hbmlwdWxhdGUgaW5zdGFuY2VzLlxcbiAgICogQG5hbWUgJC5qc3RyZWVcXG4gICAqL1xcblxcbiAgJC5qc3RyZWUgPSB7XFxuICAgIC8qKlxcbiAgICAgKiBzcGVjaWZpZXMgdGhlIGpzdHJlZSB2ZXJzaW9uIGluIHVzZVxcbiAgICAgKiBAbmFtZSAkLmpzdHJlZS52ZXJzaW9uXFxuICAgICAqL1xcbiAgICB2ZXJzaW9uOiAnMy4zLjMnLFxcblxcbiAgICAvKipcXG4gICAgICogaG9sZHMgYWxsIHRoZSBkZWZhdWx0IG9wdGlvbnMgdXNlZCB3aGVuIGNyZWF0aW5nIG5ldyBpbnN0YW5jZXNcXG4gICAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHNcXG4gICAgICovXFxuICAgIGRlZmF1bHRzOiB7XFxuICAgICAgLyoqXFxuICAgICAgICogY29uZmlndXJlIHdoaWNoIHBsdWdpbnMgd2lsbCBiZSBhY3RpdmUgb24gYW4gaW5zdGFuY2UuIFNob3VsZCBiZSBhbiBhcnJheSBvZiBzdHJpbmdzLCB3aGVyZSBlYWNoIGVsZW1lbnQgaXMgYSBwbHVnaW4gbmFtZS4gVGhlIGRlZmF1bHQgaXMgYFtdYFxcbiAgICAgICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLnBsdWdpbnNcXG4gICAgICAgKi9cXG4gICAgICBwbHVnaW5zOiBbXVxcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogc3RvcmVzIGFsbCBsb2FkZWQganN0cmVlIHBsdWdpbnMgKHVzZWQgaW50ZXJuYWxseSlcXG4gICAgICogQG5hbWUgJC5qc3RyZWUucGx1Z2luc1xcbiAgICAgKi9cXG4gICAgcGx1Z2luczoge30sXFxuICAgIHBhdGg6IHNyYyAmJiBzcmMuaW5kZXhPZignLycpICE9PSAtMSA/IHNyYy5yZXBsYWNlKC9cXFxcL1teXFxcXC9dKyQvLCAnJykgOiAnJyxcXG4gICAgaWRyZWdleDogL1tcXFxcXFxcXDomIV58KClcXFxcW1xcXFxdPD5AKicrfiNcXFwiOy4sPVxcXFwtIFxcXFwvJHt9JT9gXS9nLFxcbiAgICByb290OiAnIydcXG4gIH07XFxuICAvKipcXG4gICAqIGNyZWF0ZXMgYSBqc3RyZWUgaW5zdGFuY2VcXG4gICAqIEBuYW1lICQuanN0cmVlLmNyZWF0ZShlbCBbLCBvcHRpb25zXSlcXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudHxqUXVlcnl8U3RyaW5nfSBlbCB0aGUgZWxlbWVudCB0byBjcmVhdGUgdGhlIGluc3RhbmNlIG9uLCBjYW4gYmUgalF1ZXJ5IGV4dGVuZGVkIG9yIGEgc2VsZWN0b3JcXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIG9wdGlvbnMgZm9yIHRoaXMgaW5zdGFuY2UgKGV4dGVuZHMgYCQuanN0cmVlLmRlZmF1bHRzYClcXG4gICAqIEByZXR1cm4ge2pzVHJlZX0gdGhlIG5ldyBpbnN0YW5jZVxcbiAgICovXFxuXFxuICAkLmpzdHJlZS5jcmVhdGUgPSBmdW5jdGlvbiAoZWwsIG9wdGlvbnMpIHtcXG4gICAgdmFyIHRtcCA9IG5ldyAkLmpzdHJlZS5jb3JlKCsraW5zdGFuY2VfY291bnRlciksXFxuICAgICAgICBvcHQgPSBvcHRpb25zO1xcbiAgICBvcHRpb25zID0gJC5leHRlbmQodHJ1ZSwge30sICQuanN0cmVlLmRlZmF1bHRzLCBvcHRpb25zKTtcXG5cXG4gICAgaWYgKG9wdCAmJiBvcHQucGx1Z2lucykge1xcbiAgICAgIG9wdGlvbnMucGx1Z2lucyA9IG9wdC5wbHVnaW5zO1xcbiAgICB9XFxuXFxuICAgICQuZWFjaChvcHRpb25zLnBsdWdpbnMsIGZ1bmN0aW9uIChpLCBrKSB7XFxuICAgICAgaWYgKGkgIT09ICdjb3JlJykge1xcbiAgICAgICAgdG1wID0gdG1wLnBsdWdpbihrLCBvcHRpb25zW2tdKTtcXG4gICAgICB9XFxuICAgIH0pO1xcbiAgICAkKGVsKS5kYXRhKCdqc3RyZWUnLCB0bXApO1xcbiAgICB0bXAuaW5pdChlbCwgb3B0aW9ucyk7XFxuICAgIHJldHVybiB0bXA7XFxuICB9O1xcbiAgLyoqXFxuICAgKiByZW1vdmUgYWxsIHRyYWNlcyBvZiBqc3RyZWUgZnJvbSB0aGUgRE9NIGFuZCBkZXN0cm95IGFsbCBpbnN0YW5jZXNcXG4gICAqIEBuYW1lICQuanN0cmVlLmRlc3Ryb3koKVxcbiAgICovXFxuXFxuXFxuICAkLmpzdHJlZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xcbiAgICAkKCcuanN0cmVlOmpzdHJlZScpLmpzdHJlZSgnZGVzdHJveScpO1xcbiAgICAkKGRvY3VtZW50KS5vZmYoJy5qc3RyZWUnKTtcXG4gIH07XFxuICAvKipcXG4gICAqIHRoZSBqc3RyZWUgY2xhc3MgY29uc3RydWN0b3IsIHVzZWQgb25seSBpbnRlcm5hbGx5XFxuICAgKiBAcHJpdmF0ZVxcbiAgICogQG5hbWUgJC5qc3RyZWUuY29yZShpZClcXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpZCB0aGlzIGluc3RhbmNlJ3MgaW5kZXhcXG4gICAqL1xcblxcblxcbiAgJC5qc3RyZWUuY29yZSA9IGZ1bmN0aW9uIChpZCkge1xcbiAgICB0aGlzLl9pZCA9IGlkO1xcbiAgICB0aGlzLl9jbnQgPSAwO1xcbiAgICB0aGlzLl93cmsgPSBudWxsO1xcbiAgICB0aGlzLl9kYXRhID0ge1xcbiAgICAgIGNvcmU6IHtcXG4gICAgICAgIHRoZW1lczoge1xcbiAgICAgICAgICBuYW1lOiBmYWxzZSxcXG4gICAgICAgICAgZG90czogZmFsc2UsXFxuICAgICAgICAgIGljb25zOiBmYWxzZSxcXG4gICAgICAgICAgZWxsaXBzaXM6IGZhbHNlXFxuICAgICAgICB9LFxcbiAgICAgICAgc2VsZWN0ZWQ6IFtdLFxcbiAgICAgICAgbGFzdF9lcnJvcjoge30sXFxuICAgICAgICB3b3JraW5nOiBmYWxzZSxcXG4gICAgICAgIHdvcmtlcl9xdWV1ZTogW10sXFxuICAgICAgICBmb2N1c2VkOiBudWxsXFxuICAgICAgfVxcbiAgICB9O1xcbiAgfTtcXG4gIC8qKlxcbiAgICogZ2V0IGEgcmVmZXJlbmNlIHRvIGFuIGV4aXN0aW5nIGluc3RhbmNlXFxuICAgKlxcbiAgICogX19FeGFtcGxlc19fXFxuICAgKlxcbiAgICpcXHQvLyBwcm92aWRlZCBhIGNvbnRhaW5lciB3aXRoIGFuIElEIG9mIFxcXCJ0cmVlXFxcIiwgYW5kIGEgbmVzdGVkIG5vZGUgd2l0aCBhbiBJRCBvZiBcXFwiYnJhbmNoXFxcIlxcbiAgICpcXHQvLyBhbGwgb2YgdGhlcmUgd2lsbCByZXR1cm4gdGhlIHNhbWUgaW5zdGFuY2VcXG4gICAqXFx0JC5qc3RyZWUucmVmZXJlbmNlKCd0cmVlJyk7XFxuICAgKlxcdCQuanN0cmVlLnJlZmVyZW5jZSgnI3RyZWUnKTtcXG4gICAqXFx0JC5qc3RyZWUucmVmZXJlbmNlKCQoJyN0cmVlJykpO1xcbiAgICpcXHQkLmpzdHJlZS5yZWZlcmVuY2UoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SUQoJ3RyZWUnKSk7XFxuICAgKlxcdCQuanN0cmVlLnJlZmVyZW5jZSgnYnJhbmNoJyk7XFxuICAgKlxcdCQuanN0cmVlLnJlZmVyZW5jZSgnI2JyYW5jaCcpO1xcbiAgICpcXHQkLmpzdHJlZS5yZWZlcmVuY2UoJCgnI2JyYW5jaCcpKTtcXG4gICAqXFx0JC5qc3RyZWUucmVmZXJlbmNlKGRvY3VtZW50LmdldEVsZW1lbnRCeUlEKCdicmFuY2gnKSk7XFxuICAgKlxcbiAgICogQG5hbWUgJC5qc3RyZWUucmVmZXJlbmNlKG5lZWRsZSlcXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudHxqUXVlcnl8U3RyaW5nfSBuZWVkbGVcXG4gICAqIEByZXR1cm4ge2pzVHJlZXxudWxsfSB0aGUgaW5zdGFuY2Ugb3IgYG51bGxgIGlmIG5vdCBmb3VuZFxcbiAgICovXFxuXFxuXFxuICAkLmpzdHJlZS5yZWZlcmVuY2UgPSBmdW5jdGlvbiAobmVlZGxlKSB7XFxuICAgIHZhciB0bXAgPSBudWxsLFxcbiAgICAgICAgb2JqID0gbnVsbDtcXG5cXG4gICAgaWYgKG5lZWRsZSAmJiBuZWVkbGUuaWQgJiYgKCFuZWVkbGUudGFnTmFtZSB8fCAhbmVlZGxlLm5vZGVUeXBlKSkge1xcbiAgICAgIG5lZWRsZSA9IG5lZWRsZS5pZDtcXG4gICAgfVxcblxcbiAgICBpZiAoIW9iaiB8fCAhb2JqLmxlbmd0aCkge1xcbiAgICAgIHRyeSB7XFxuICAgICAgICBvYmogPSAkKG5lZWRsZSk7XFxuICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxcbiAgICB9XFxuXFxuICAgIGlmICghb2JqIHx8ICFvYmoubGVuZ3RoKSB7XFxuICAgICAgdHJ5IHtcXG4gICAgICAgIG9iaiA9ICQoJyMnICsgbmVlZGxlLnJlcGxhY2UoJC5qc3RyZWUuaWRyZWdleCwgJ1xcXFxcXFxcJCYnKSk7XFxuICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxcbiAgICB9XFxuXFxuICAgIGlmIChvYmogJiYgb2JqLmxlbmd0aCAmJiAob2JqID0gb2JqLmNsb3Nlc3QoJy5qc3RyZWUnKSkubGVuZ3RoICYmIChvYmogPSBvYmouZGF0YSgnanN0cmVlJykpKSB7XFxuICAgICAgdG1wID0gb2JqO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICQoJy5qc3RyZWUnKS5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciBpbnN0ID0gJCh0aGlzKS5kYXRhKCdqc3RyZWUnKTtcXG5cXG4gICAgICAgIGlmIChpbnN0ICYmIGluc3QuX21vZGVsLmRhdGFbbmVlZGxlXSkge1xcbiAgICAgICAgICB0bXAgPSBpbnN0O1xcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHRtcDtcXG4gIH07XFxuICAvKipcXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZSwgZ2V0IGFuIGluc3RhbmNlIG9yIGludm9rZSBhIGNvbW1hbmQgb24gYSBpbnN0YW5jZS5cXG4gICAqXFxuICAgKiBJZiB0aGVyZSBpcyBubyBpbnN0YW5jZSBhc3NvY2lhdGVkIHdpdGggdGhlIGN1cnJlbnQgbm9kZSBhIG5ldyBvbmUgaXMgY3JlYXRlZCBhbmQgYGFyZ2AgaXMgdXNlZCB0byBleHRlbmQgYCQuanN0cmVlLmRlZmF1bHRzYCBmb3IgdGhpcyBuZXcgaW5zdGFuY2UuIFRoZXJlIHdvdWxkIGJlIG5vIHJldHVybiB2YWx1ZSAoY2hhaW5pbmcgaXMgbm90IGJyb2tlbikuXFxuICAgKlxcbiAgICogSWYgdGhlcmUgaXMgYW4gZXhpc3RpbmcgaW5zdGFuY2UgYW5kIGBhcmdgIGlzIGEgc3RyaW5nIHRoZSBjb21tYW5kIHNwZWNpZmllZCBieSBgYXJnYCBpcyBleGVjdXRlZCBvbiB0aGUgaW5zdGFuY2UsIHdpdGggYW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgZnVuY3Rpb24uIElmIHRoZSBmdW5jdGlvbiByZXR1cm5zIGEgdmFsdWUgaXQgd2lsbCBiZSByZXR1cm5lZCAoY2hhaW5pbmcgY291bGQgYnJlYWsgZGVwZW5kaW5nIG9uIGZ1bmN0aW9uKS5cXG4gICAqXFxuICAgKiBJZiB0aGVyZSBpcyBhbiBleGlzdGluZyBpbnN0YW5jZSBhbmQgYGFyZ2AgaXMgbm90IGEgc3RyaW5nIHRoZSBpbnN0YW5jZSBpdHNlbGYgaXMgcmV0dXJuZWQgKHNpbWlsYXIgdG8gYCQuanN0cmVlLnJlZmVyZW5jZWApLlxcbiAgICpcXG4gICAqIEluIGFueSBvdGhlciBjYXNlIC0gbm90aGluZyBpcyByZXR1cm5lZCBhbmQgY2hhaW5pbmcgaXMgbm90IGJyb2tlbi5cXG4gICAqXFxuICAgKiBfX0V4YW1wbGVzX19cXG4gICAqXFxuICAgKlxcdCQoJyN0cmVlMScpLmpzdHJlZSgpOyAvLyBjcmVhdGVzIGFuIGluc3RhbmNlXFxuICAgKlxcdCQoJyN0cmVlMicpLmpzdHJlZSh7IHBsdWdpbnMgOiBbXSB9KTsgLy8gY3JlYXRlIGFuIGluc3RhbmNlIHdpdGggc29tZSBvcHRpb25zXFxuICAgKlxcdCQoJyN0cmVlMScpLmpzdHJlZSgnb3Blbl9ub2RlJywgJyNicmFuY2hfMScpOyAvLyBjYWxsIGEgbWV0aG9kIG9uIGFuIGV4aXN0aW5nIGluc3RhbmNlLCBwYXNzaW5nIGFkZGl0aW9uYWwgYXJndW1lbnRzXFxuICAgKlxcdCQoJyN0cmVlMicpLmpzdHJlZSgpOyAvLyBnZXQgYW4gZXhpc3RpbmcgaW5zdGFuY2UgKG9yIGNyZWF0ZSBhbiBpbnN0YW5jZSlcXG4gICAqXFx0JCgnI3RyZWUyJykuanN0cmVlKHRydWUpOyAvLyBnZXQgYW4gZXhpc3RpbmcgaW5zdGFuY2UgKHdpbGwgbm90IGNyZWF0ZSBuZXcgaW5zdGFuY2UpXFxuICAgKlxcdCQoJyNicmFuY2hfMScpLmpzdHJlZSgpLnNlbGVjdF9ub2RlKCcjYnJhbmNoXzEnKTsgLy8gZ2V0IGFuIGluc3RhbmNlICh1c2luZyBhIG5lc3RlZCBlbGVtZW50IGFuZCBjYWxsIGEgbWV0aG9kKVxcbiAgICpcXG4gICAqIEBuYW1lICQoKS5qc3RyZWUoW2FyZ10pXFxuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGFyZ1xcbiAgICogQHJldHVybiB7TWl4ZWR9XFxuICAgKi9cXG5cXG5cXG4gICQuZm4uanN0cmVlID0gZnVuY3Rpb24gKGFyZykge1xcbiAgICAvLyBjaGVjayBmb3Igc3RyaW5nIGFyZ3VtZW50XFxuICAgIHZhciBpc19tZXRob2QgPSB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyxcXG4gICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLFxcbiAgICAgICAgcmVzdWx0ID0gbnVsbDtcXG5cXG4gICAgaWYgKGFyZyA9PT0gdHJ1ZSAmJiAhdGhpcy5sZW5ndGgpIHtcXG4gICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG5cXG4gICAgdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAvLyBnZXQgdGhlIGluc3RhbmNlIChpZiB0aGVyZSBpcyBvbmUpIGFuZCBtZXRob2QgKGlmIGl0IGV4aXN0cylcXG4gICAgICB2YXIgaW5zdGFuY2UgPSAkLmpzdHJlZS5yZWZlcmVuY2UodGhpcyksXFxuICAgICAgICAgIG1ldGhvZCA9IGlzX21ldGhvZCAmJiBpbnN0YW5jZSA/IGluc3RhbmNlW2FyZ10gOiBudWxsOyAvLyBpZiBjYWxsaW5nIGEgbWV0aG9kLCBhbmQgbWV0aG9kIGlzIGF2YWlsYWJsZSAtIGV4ZWN1dGUgb24gdGhlIGluc3RhbmNlXFxuXFxuICAgICAgcmVzdWx0ID0gaXNfbWV0aG9kICYmIG1ldGhvZCA/IG1ldGhvZC5hcHBseShpbnN0YW5jZSwgYXJncykgOiBudWxsOyAvLyBpZiB0aGVyZSBpcyBubyBpbnN0YW5jZSBhbmQgbm8gbWV0aG9kIGlzIGJlaW5nIGNhbGxlZCAtIGNyZWF0ZSBvbmVcXG5cXG4gICAgICBpZiAoIWluc3RhbmNlICYmICFpc19tZXRob2QgJiYgKGFyZyA9PT0gdW5kZWZpbmVkIHx8ICQuaXNQbGFpbk9iamVjdChhcmcpKSkge1xcbiAgICAgICAgJC5qc3RyZWUuY3JlYXRlKHRoaXMsIGFyZyk7XFxuICAgICAgfSAvLyBpZiB0aGVyZSBpcyBhbiBpbnN0YW5jZSBhbmQgbm8gbWV0aG9kIGlzIGNhbGxlZCAtIHJldHVybiB0aGUgaW5zdGFuY2VcXG5cXG5cXG4gICAgICBpZiAoaW5zdGFuY2UgJiYgIWlzX21ldGhvZCB8fCBhcmcgPT09IHRydWUpIHtcXG4gICAgICAgIHJlc3VsdCA9IGluc3RhbmNlIHx8IGZhbHNlO1xcbiAgICAgIH0gLy8gaWYgdGhlcmUgd2FzIGEgbWV0aG9kIGNhbGwgd2hpY2ggcmV0dXJuZWQgYSByZXN1bHQgLSBicmVhayBhbmQgcmV0dXJuIHRoZSB2YWx1ZVxcblxcblxcbiAgICAgIGlmIChyZXN1bHQgIT09IG51bGwgJiYgcmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuICAgIH0pOyAvLyBpZiB0aGVyZSB3YXMgYSBtZXRob2QgY2FsbCB3aXRoIGEgdmFsaWQgcmV0dXJuIHZhbHVlIC0gcmV0dXJuIHRoYXQsIG90aGVyd2lzZSBjb250aW51ZSB0aGUgY2hhaW5cXG5cXG4gICAgcmV0dXJuIHJlc3VsdCAhPT0gbnVsbCAmJiByZXN1bHQgIT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IHRoaXM7XFxuICB9O1xcbiAgLyoqXFxuICAgKiB1c2VkIHRvIGZpbmQgZWxlbWVudHMgY29udGFpbmluZyBhbiBpbnN0YW5jZVxcbiAgICpcXG4gICAqIF9fRXhhbXBsZXNfX1xcbiAgICpcXG4gICAqXFx0JCgnZGl2OmpzdHJlZScpLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICpcXHRcXHQkKHRoaXMpLmpzdHJlZSgnZGVzdHJveScpO1xcbiAgICpcXHR9KTtcXG4gICAqXFxuICAgKiBAbmFtZSAkKCc6anN0cmVlJylcXG4gICAqIEByZXR1cm4ge2pRdWVyeX1cXG4gICAqL1xcblxcblxcbiAgJC5leHByLnBzZXVkb3MuanN0cmVlID0gJC5leHByLmNyZWF0ZVBzZXVkbyhmdW5jdGlvbiAoc2VhcmNoKSB7XFxuICAgIHJldHVybiBmdW5jdGlvbiAoYSkge1xcbiAgICAgIHJldHVybiAkKGEpLmhhc0NsYXNzKCdqc3RyZWUnKSAmJiAkKGEpLmRhdGEoJ2pzdHJlZScpICE9PSB1bmRlZmluZWQ7XFxuICAgIH07XFxuICB9KTtcXG4gIC8qKlxcbiAgICogc3RvcmVzIGFsbCBkZWZhdWx0cyBmb3IgdGhlIGNvcmVcXG4gICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvcmVcXG4gICAqL1xcblxcbiAgJC5qc3RyZWUuZGVmYXVsdHMuY29yZSA9IHtcXG4gICAgLyoqXFxuICAgICAqIGRhdGEgY29uZmlndXJhdGlvblxcbiAgICAgKlxcbiAgICAgKiBJZiBsZWZ0IGFzIGBmYWxzZWAgdGhlIEhUTUwgaW5zaWRlIHRoZSBqc3RyZWUgY29udGFpbmVyIGVsZW1lbnQgaXMgdXNlZCB0byBwb3B1bGF0ZSB0aGUgdHJlZSAodGhhdCBzaG91bGQgYmUgYW4gdW5vcmRlcmVkIGxpc3Qgd2l0aCBsaXN0IGl0ZW1zKS5cXG4gICAgICpcXG4gICAgICogWW91IGNhbiBhbHNvIHBhc3MgaW4gYSBIVE1MIHN0cmluZyBvciBhIEpTT04gYXJyYXkgaGVyZS5cXG4gICAgICpcXG4gICAgICogSXQgaXMgcG9zc2libGUgdG8gcGFzcyBpbiBhIHN0YW5kYXJkIGpRdWVyeS1saWtlIEFKQVggY29uZmlnIGFuZCBqc3RyZWUgd2lsbCBhdXRvbWF0aWNhbGx5IGRldGVybWluZSBpZiB0aGUgcmVzcG9uc2UgaXMgSlNPTiBvciBIVE1MIGFuZCB1c2UgdGhhdCB0byBwb3B1bGF0ZSB0aGUgdHJlZS5cXG4gICAgICogSW4gYWRkaXRpb24gdG8gdGhlIHN0YW5kYXJkIGpRdWVyeSBhamF4IG9wdGlvbnMgaGVyZSB5b3UgY2FuIHN1cHB5IGZ1bmN0aW9ucyBmb3IgYGRhdGFgIGFuZCBgdXJsYCwgdGhlIGZ1bmN0aW9ucyB3aWxsIGJlIHJ1biBpbiB0aGUgY3VycmVudCBpbnN0YW5jZSdzIHNjb3BlIGFuZCBhIHBhcmFtIHdpbGwgYmUgcGFzc2VkIGluZGljYXRpbmcgd2hpY2ggbm9kZSBpcyBiZWluZyBsb2FkZWQsIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhvc2UgZnVuY3Rpb25zIHdpbGwgYmUgdXNlZC5cXG4gICAgICpcXG4gICAgICogVGhlIGxhc3Qgb3B0aW9uIGlzIHRvIHNwZWNpZnkgYSBmdW5jdGlvbiwgdGhhdCBmdW5jdGlvbiB3aWxsIHJlY2VpdmUgdGhlIG5vZGUgYmVpbmcgbG9hZGVkIGFzIGFyZ3VtZW50IGFuZCBhIHNlY29uZCBwYXJhbSB3aGljaCBpcyBhIGZ1bmN0aW9uIHdoaWNoIHNob3VsZCBiZSBjYWxsZWQgd2l0aCB0aGUgcmVzdWx0LlxcbiAgICAgKlxcbiAgICAgKiBfX0V4YW1wbGVzX19cXG4gICAgICpcXG4gICAgICpcXHQvLyBBSkFYXFxuICAgICAqXFx0JCgnI3RyZWUnKS5qc3RyZWUoe1xcbiAgICAgKlxcdFxcdCdjb3JlJyA6IHtcXG4gICAgICpcXHRcXHRcXHQnZGF0YScgOiB7XFxuICAgICAqXFx0XFx0XFx0XFx0J3VybCcgOiAnL2dldC9jaGlsZHJlbi8nLFxcbiAgICAgKlxcdFxcdFxcdFxcdCdkYXRhJyA6IGZ1bmN0aW9uIChub2RlKSB7XFxuICAgICAqXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHsgJ2lkJyA6IG5vZGUuaWQgfTtcXG4gICAgICpcXHRcXHRcXHRcXHR9XFxuICAgICAqXFx0XFx0XFx0fVxcbiAgICAgKlxcdFxcdH0pO1xcbiAgICAgKlxcbiAgICAgKlxcdC8vIGRpcmVjdCBkYXRhXFxuICAgICAqXFx0JCgnI3RyZWUnKS5qc3RyZWUoe1xcbiAgICAgKlxcdFxcdCdjb3JlJyA6IHtcXG4gICAgICpcXHRcXHRcXHQnZGF0YScgOiBbXFxuICAgICAqXFx0XFx0XFx0XFx0J1NpbXBsZSByb290IG5vZGUnLFxcbiAgICAgKlxcdFxcdFxcdFxcdHtcXG4gICAgICpcXHRcXHRcXHRcXHRcXHQnaWQnIDogJ25vZGVfMicsXFxuICAgICAqXFx0XFx0XFx0XFx0XFx0J3RleHQnIDogJ1Jvb3Qgbm9kZSB3aXRoIG9wdGlvbnMnLFxcbiAgICAgKlxcdFxcdFxcdFxcdFxcdCdzdGF0ZScgOiB7ICdvcGVuZWQnIDogdHJ1ZSwgJ3NlbGVjdGVkJyA6IHRydWUgfSxcXG4gICAgICpcXHRcXHRcXHRcXHRcXHQnY2hpbGRyZW4nIDogWyB7ICd0ZXh0JyA6ICdDaGlsZCAxJyB9LCAnQ2hpbGQgMiddXFxuICAgICAqXFx0XFx0XFx0XFx0fVxcbiAgICAgKlxcdFxcdFxcdF1cXG4gICAgICpcXHRcXHR9XFxuICAgICAqXFx0fSk7XFxuICAgICAqXFxuICAgICAqXFx0Ly8gZnVuY3Rpb25cXG4gICAgICpcXHQkKCcjdHJlZScpLmpzdHJlZSh7XFxuICAgICAqXFx0XFx0J2NvcmUnIDoge1xcbiAgICAgKlxcdFxcdFxcdCdkYXRhJyA6IGZ1bmN0aW9uIChvYmosIGNhbGxiYWNrKSB7XFxuICAgICAqXFx0XFx0XFx0XFx0Y2FsbGJhY2suY2FsbCh0aGlzLCBbJ1Jvb3QgMScsICdSb290IDInXSk7XFxuICAgICAqXFx0XFx0XFx0fVxcbiAgICAgKlxcdFxcdH0pO1xcbiAgICAgKlxcbiAgICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb3JlLmRhdGFcXG4gICAgICovXFxuICAgIGRhdGE6IGZhbHNlLFxcblxcbiAgICAvKipcXG4gICAgICogY29uZmlndXJlIHRoZSB2YXJpb3VzIHN0cmluZ3MgdXNlZCB0aHJvdWdob3V0IHRoZSB0cmVlXFxuICAgICAqXFxuICAgICAqIFlvdSBjYW4gdXNlIGFuIG9iamVjdCB3aGVyZSB0aGUga2V5IGlzIHRoZSBzdHJpbmcgeW91IG5lZWQgdG8gcmVwbGFjZSBhbmQgdGhlIHZhbHVlIGlzIHlvdXIgcmVwbGFjZW1lbnQuXFxuICAgICAqIEFub3RoZXIgb3B0aW9uIGlzIHRvIHNwZWNpZnkgYSBmdW5jdGlvbiB3aGljaCB3aWxsIGJlIGNhbGxlZCB3aXRoIGFuIGFyZ3VtZW50IG9mIHRoZSBuZWVkZWQgc3RyaW5nIGFuZCBzaG91bGQgcmV0dXJuIHRoZSByZXBsYWNlbWVudC5cXG4gICAgICogSWYgbGVmdCBhcyBgZmFsc2VgIG5vIHJlcGxhY2VtZW50IGlzIG1hZGUuXFxuICAgICAqXFxuICAgICAqIF9fRXhhbXBsZXNfX1xcbiAgICAgKlxcbiAgICAgKlxcdCQoJyN0cmVlJykuanN0cmVlKHtcXG4gICAgICpcXHRcXHQnY29yZScgOiB7XFxuICAgICAqXFx0XFx0XFx0J3N0cmluZ3MnIDoge1xcbiAgICAgKlxcdFxcdFxcdFxcdCdMb2FkaW5nIC4uLicgOiAnUGxlYXNlIHdhaXQgLi4uJ1xcbiAgICAgKlxcdFxcdFxcdH1cXG4gICAgICpcXHRcXHR9XFxuICAgICAqXFx0fSk7XFxuICAgICAqXFxuICAgICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvcmUuc3RyaW5nc1xcbiAgICAgKi9cXG4gICAgc3RyaW5nczogZmFsc2UsXFxuXFxuICAgIC8qKlxcbiAgICAgKiBkZXRlcm1pbmVzIHdoYXQgaGFwcGVucyB3aGVuIGEgdXNlciB0cmllcyB0byBtb2RpZnkgdGhlIHN0cnVjdHVyZSBvZiB0aGUgdHJlZVxcbiAgICAgKiBJZiBsZWZ0IGFzIGBmYWxzZWAgYWxsIG9wZXJhdGlvbnMgbGlrZSBjcmVhdGUsIHJlbmFtZSwgZGVsZXRlLCBtb3ZlIG9yIGNvcHkgYXJlIHByZXZlbnRlZC5cXG4gICAgICogWW91IGNhbiBzZXQgdGhpcyB0byBgdHJ1ZWAgdG8gYWxsb3cgYWxsIGludGVyYWN0aW9ucyBvciB1c2UgYSBmdW5jdGlvbiB0byBoYXZlIGJldHRlciBjb250cm9sLlxcbiAgICAgKlxcbiAgICAgKiBfX0V4YW1wbGVzX19cXG4gICAgICpcXG4gICAgICpcXHQkKCcjdHJlZScpLmpzdHJlZSh7XFxuICAgICAqXFx0XFx0J2NvcmUnIDoge1xcbiAgICAgKlxcdFxcdFxcdCdjaGVja19jYWxsYmFjaycgOiBmdW5jdGlvbiAob3BlcmF0aW9uLCBub2RlLCBub2RlX3BhcmVudCwgbm9kZV9wb3NpdGlvbiwgbW9yZSkge1xcbiAgICAgKlxcdFxcdFxcdFxcdC8vIG9wZXJhdGlvbiBjYW4gYmUgJ2NyZWF0ZV9ub2RlJywgJ3JlbmFtZV9ub2RlJywgJ2RlbGV0ZV9ub2RlJywgJ21vdmVfbm9kZScgb3IgJ2NvcHlfbm9kZSdcXG4gICAgICpcXHRcXHRcXHRcXHQvLyBpbiBjYXNlIG9mICdyZW5hbWVfbm9kZScgbm9kZV9wb3NpdGlvbiBpcyBmaWxsZWQgd2l0aCB0aGUgbmV3IG5vZGUgbmFtZVxcbiAgICAgKlxcdFxcdFxcdFxcdHJldHVybiBvcGVyYXRpb24gPT09ICdyZW5hbWVfbm9kZScgPyB0cnVlIDogZmFsc2U7XFxuICAgICAqXFx0XFx0XFx0fVxcbiAgICAgKlxcdFxcdH1cXG4gICAgICpcXHR9KTtcXG4gICAgICpcXG4gICAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY29yZS5jaGVja19jYWxsYmFja1xcbiAgICAgKi9cXG4gICAgY2hlY2tfY2FsbGJhY2s6IGZhbHNlLFxcblxcbiAgICAvKipcXG4gICAgICogYSBjYWxsYmFjayBjYWxsZWQgd2l0aCBhIHNpbmdsZSBvYmplY3QgcGFyYW1ldGVyIGluIHRoZSBpbnN0YW5jZSdzIHNjb3BlIHdoZW4gc29tZXRoaW5nIGdvZXMgd3JvbmcgKG9wZXJhdGlvbiBwcmV2ZW50ZWQsIGFqYXggZmFpbGVkLCBldGMpXFxuICAgICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvcmUuZXJyb3JcXG4gICAgICovXFxuICAgIGVycm9yOiAkLm5vb3AsXFxuXFxuICAgIC8qKlxcbiAgICAgKiB0aGUgb3BlbiAvIGNsb3NlIGFuaW1hdGlvbiBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMgLSBzZXQgdGhpcyB0byBgZmFsc2VgIHRvIGRpc2FibGUgdGhlIGFuaW1hdGlvbiAoZGVmYXVsdCBpcyBgMjAwYClcXG4gICAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY29yZS5hbmltYXRpb25cXG4gICAgICovXFxuICAgIGFuaW1hdGlvbjogMjAwLFxcblxcbiAgICAvKipcXG4gICAgICogYSBib29sZWFuIGluZGljYXRpbmcgaWYgbXVsdGlwbGUgbm9kZXMgY2FuIGJlIHNlbGVjdGVkXFxuICAgICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvcmUubXVsdGlwbGVcXG4gICAgICovXFxuICAgIG11bHRpcGxlOiB0cnVlLFxcblxcbiAgICAvKipcXG4gICAgICogdGhlbWUgY29uZmlndXJhdGlvbiBvYmplY3RcXG4gICAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY29yZS50aGVtZXNcXG4gICAgICovXFxuICAgIHRoZW1lczoge1xcbiAgICAgIC8qKlxcbiAgICAgICAqIHRoZSBuYW1lIG9mIHRoZSB0aGVtZSB0byB1c2UgKGlmIGxlZnQgYXMgYGZhbHNlYCB0aGUgZGVmYXVsdCB0aGVtZSBpcyB1c2VkKVxcbiAgICAgICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvcmUudGhlbWVzLm5hbWVcXG4gICAgICAgKi9cXG4gICAgICBuYW1lOiBmYWxzZSxcXG5cXG4gICAgICAvKipcXG4gICAgICAgKiB0aGUgVVJMIG9mIHRoZSB0aGVtZSdzIENTUyBmaWxlLCBsZWF2ZSB0aGlzIGFzIGBmYWxzZWAgaWYgeW91IGhhdmUgbWFudWFsbHkgaW5jbHVkZWQgdGhlIHRoZW1lIENTUyAocmVjb21tZW5kZWQpLiBZb3UgY2FuIHNldCB0aGlzIHRvIGB0cnVlYCB0b28gd2hpY2ggd2lsbCB0cnkgdG8gYXV0b2xvYWQgdGhlIHRoZW1lLlxcbiAgICAgICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvcmUudGhlbWVzLnVybFxcbiAgICAgICAqL1xcbiAgICAgIHVybDogZmFsc2UsXFxuXFxuICAgICAgLyoqXFxuICAgICAgICogdGhlIGxvY2F0aW9uIG9mIGFsbCBqc3RyZWUgdGhlbWVzIC0gb25seSB1c2VkIGlmIGB1cmxgIGlzIHNldCB0byBgdHJ1ZWBcXG4gICAgICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb3JlLnRoZW1lcy5kaXJcXG4gICAgICAgKi9cXG4gICAgICBkaXI6IGZhbHNlLFxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIGNvbm5lY3RpbmcgZG90cyBhcmUgc2hvd25cXG4gICAgICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb3JlLnRoZW1lcy5kb3RzXFxuICAgICAgICovXFxuICAgICAgZG90czogdHJ1ZSxcXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiBub2RlIGljb25zIGFyZSBzaG93blxcbiAgICAgICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvcmUudGhlbWVzLmljb25zXFxuICAgICAgICovXFxuICAgICAgaWNvbnM6IHRydWUsXFxuXFxuICAgICAgLyoqXFxuICAgICAgICogYSBib29sZWFuIGluZGljYXRpbmcgaWYgbm9kZSBlbGxpcHNpcyBzaG91bGQgYmUgc2hvd24gLSB0aGlzIG9ubHkgd29ya3Mgd2l0aCBhIGZpeGVkIHdpdGggb24gdGhlIGNvbnRhaW5lclxcbiAgICAgICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvcmUudGhlbWVzLmVsbGlwc2lzXFxuICAgICAgICovXFxuICAgICAgZWxsaXBzaXM6IGZhbHNlLFxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoZSB0cmVlIGJhY2tncm91bmQgaXMgc3RyaXBlZFxcbiAgICAgICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvcmUudGhlbWVzLnN0cmlwZXNcXG4gICAgICAgKi9cXG4gICAgICBzdHJpcGVzOiBmYWxzZSxcXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBhIHN0cmluZyAob3IgYm9vbGVhbiBgZmFsc2VgKSBzcGVjaWZ5aW5nIHRoZSB0aGVtZSB2YXJpYW50IHRvIHVzZSAoaWYgdGhlIHRoZW1lIHN1cHBvcnRzIHZhcmlhbnRzKVxcbiAgICAgICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvcmUudGhlbWVzLnZhcmlhbnRcXG4gICAgICAgKi9cXG4gICAgICB2YXJpYW50OiBmYWxzZSxcXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBhIGJvb2xlYW4gc3BlY2lmeWluZyBpZiBhIHJlcG9uc2l2ZSB2ZXJzaW9uIG9mIHRoZSB0aGVtZSBzaG91bGQga2ljayBpbiBvbiBzbWFsbGVyIHNjcmVlbnMgKGlmIHRoZSB0aGVtZSBzdXBwb3J0cyBpdCkuIERlZmF1bHRzIHRvIGBmYWxzZWAuXFxuICAgICAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY29yZS50aGVtZXMucmVzcG9uc2l2ZVxcbiAgICAgICAqL1xcbiAgICAgIHJlc3BvbnNpdmU6IGZhbHNlXFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBpZiBsZWZ0IGFzIGB0cnVlYCBhbGwgcGFyZW50cyBvZiBhbGwgc2VsZWN0ZWQgbm9kZXMgd2lsbCBiZSBvcGVuZWQgb25jZSB0aGUgdHJlZSBsb2FkcyAoc28gdGhhdCBhbGwgc2VsZWN0ZWQgbm9kZXMgYXJlIHZpc2libGUgdG8gdGhlIHVzZXIpXFxuICAgICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvcmUuZXhwYW5kX3NlbGVjdGVkX29ubG9hZFxcbiAgICAgKi9cXG4gICAgZXhwYW5kX3NlbGVjdGVkX29ubG9hZDogdHJ1ZSxcXG5cXG4gICAgLyoqXFxuICAgICAqIGlmIGxlZnQgYXMgYHRydWVgIHdlYiB3b3JrZXJzIHdpbGwgYmUgdXNlZCB0byBwYXJzZSBpbmNvbWluZyBKU09OIGRhdGEgd2hlcmUgcG9zc2libGUsIHNvIHRoYXQgdGhlIFVJIHdpbGwgbm90IGJlIGJsb2NrZWQgYnkgbGFyZ2UgcmVxdWVzdHMuIFdvcmtlcnMgYXJlIGhvd2V2ZXIgYWJvdXQgMzAlIHNsb3dlci4gRGVmYXVsdHMgdG8gYHRydWVgXFxuICAgICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvcmUud29ya2VyXFxuICAgICAqL1xcbiAgICB3b3JrZXI6IHRydWUsXFxuXFxuICAgIC8qKlxcbiAgICAgKiBGb3JjZSBub2RlIHRleHQgdG8gcGxhaW4gdGV4dCAoYW5kIGVzY2FwZSBIVE1MKS4gRGVmYXVsdHMgdG8gYGZhbHNlYFxcbiAgICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb3JlLmZvcmNlX3RleHRcXG4gICAgICovXFxuICAgIGZvcmNlX3RleHQ6IGZhbHNlLFxcblxcbiAgICAvKipcXG4gICAgICogU2hvdWxkIHRoZSBub2RlIHNob3VsZCBiZSB0b2dnbGVkIGlmIHRoZSB0ZXh0IGlzIGRvdWJsZSBjbGlja2VkIC4gRGVmYXVsdHMgdG8gYHRydWVgXFxuICAgICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvcmUuZGJsY2xpY2tfdG9nZ2xlXFxuICAgICAqL1xcbiAgICBkYmxjbGlja190b2dnbGU6IHRydWVcXG4gIH07XFxuICAkLmpzdHJlZS5jb3JlLnByb3RvdHlwZSA9IHtcXG4gICAgLyoqXFxuICAgICAqIHVzZWQgdG8gZGVjb3JhdGUgYW4gaW5zdGFuY2Ugd2l0aCBhIHBsdWdpbi4gVXNlZCBpbnRlcm5hbGx5LlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAbmFtZSBwbHVnaW4oZGVjbyBbLCBvcHRzXSlcXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBkZWNvIHRoZSBwbHVnaW4gdG8gZGVjb3JhdGUgd2l0aFxcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdHMgb3B0aW9ucyBmb3IgdGhlIHBsdWdpblxcbiAgICAgKiBAcmV0dXJuIHtqc1RyZWV9XFxuICAgICAqL1xcbiAgICBwbHVnaW46IGZ1bmN0aW9uIHBsdWdpbihkZWNvLCBvcHRzKSB7XFxuICAgICAgdmFyIENoaWxkID0gJC5qc3RyZWUucGx1Z2luc1tkZWNvXTtcXG5cXG4gICAgICBpZiAoQ2hpbGQpIHtcXG4gICAgICAgIHRoaXMuX2RhdGFbZGVjb10gPSB7fTtcXG4gICAgICAgIENoaWxkLnByb3RvdHlwZSA9IHRoaXM7XFxuICAgICAgICByZXR1cm4gbmV3IENoaWxkKG9wdHMsIHRoaXMpO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gdGhpcztcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIGluaXRpYWxpemUgdGhlIGluc3RhbmNlLiBVc2VkIGludGVybmFsbHkuXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBuYW1lIGluaXQoZWwsIG9wdG9ucylcXG4gICAgICogQHBhcmFtIHtET01FbGVtZW50fGpRdWVyeXxTdHJpbmd9IGVsIHRoZSBlbGVtZW50IHdlIGFyZSB0cmFuc2Zvcm1pbmdcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgb3B0aW9ucyBmb3IgdGhpcyBpbnN0YW5jZVxcbiAgICAgKiBAdHJpZ2dlciBpbml0LmpzdHJlZSwgbG9hZGluZy5qc3RyZWUsIGxvYWRlZC5qc3RyZWUsIHJlYWR5LmpzdHJlZSwgY2hhbmdlZC5qc3RyZWVcXG4gICAgICovXFxuICAgIGluaXQ6IGZ1bmN0aW9uIGluaXQoZWwsIG9wdGlvbnMpIHtcXG4gICAgICB0aGlzLl9tb2RlbCA9IHtcXG4gICAgICAgIGRhdGE6IHt9LFxcbiAgICAgICAgY2hhbmdlZDogW10sXFxuICAgICAgICBmb3JjZV9mdWxsX3JlZHJhdzogZmFsc2UsXFxuICAgICAgICByZWRyYXdfdGltZW91dDogZmFsc2UsXFxuICAgICAgICBkZWZhdWx0X3N0YXRlOiB7XFxuICAgICAgICAgIGxvYWRlZDogdHJ1ZSxcXG4gICAgICAgICAgb3BlbmVkOiBmYWxzZSxcXG4gICAgICAgICAgc2VsZWN0ZWQ6IGZhbHNlLFxcbiAgICAgICAgICBkaXNhYmxlZDogZmFsc2VcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIHRoaXMuX21vZGVsLmRhdGFbJC5qc3RyZWUucm9vdF0gPSB7XFxuICAgICAgICBpZDogJC5qc3RyZWUucm9vdCxcXG4gICAgICAgIHBhcmVudDogbnVsbCxcXG4gICAgICAgIHBhcmVudHM6IFtdLFxcbiAgICAgICAgY2hpbGRyZW46IFtdLFxcbiAgICAgICAgY2hpbGRyZW5fZDogW10sXFxuICAgICAgICBzdGF0ZToge1xcbiAgICAgICAgICBsb2FkZWQ6IGZhbHNlXFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICB0aGlzLmVsZW1lbnQgPSAkKGVsKS5hZGRDbGFzcygnanN0cmVlIGpzdHJlZS0nICsgdGhpcy5faWQpO1xcbiAgICAgIHRoaXMuc2V0dGluZ3MgPSBvcHRpb25zO1xcbiAgICAgIHRoaXMuX2RhdGEuY29yZS5yZWFkeSA9IGZhbHNlO1xcbiAgICAgIHRoaXMuX2RhdGEuY29yZS5sb2FkZWQgPSBmYWxzZTtcXG4gICAgICB0aGlzLl9kYXRhLmNvcmUucnRsID0gdGhpcy5lbGVtZW50LmNzcyhcXFwiZGlyZWN0aW9uXFxcIikgPT09IFxcXCJydGxcXFwiO1xcbiAgICAgIHRoaXMuZWxlbWVudFt0aGlzLl9kYXRhLmNvcmUucnRsID8gJ2FkZENsYXNzJyA6ICdyZW1vdmVDbGFzcyddKFxcXCJqc3RyZWUtcnRsXFxcIik7XFxuICAgICAgdGhpcy5lbGVtZW50LmF0dHIoJ3JvbGUnLCAndHJlZScpO1xcblxcbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLmNvcmUubXVsdGlwbGUpIHtcXG4gICAgICAgIHRoaXMuZWxlbWVudC5hdHRyKCdhcmlhLW11bHRpc2VsZWN0YWJsZScsIHRydWUpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIXRoaXMuZWxlbWVudC5hdHRyKCd0YWJpbmRleCcpKSB7XFxuICAgICAgICB0aGlzLmVsZW1lbnQuYXR0cigndGFiaW5kZXgnLCAnMCcpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLmJpbmQoKTtcXG4gICAgICAvKipcXG4gICAgICAgKiB0cmlnZ2VyZWQgYWZ0ZXIgYWxsIGV2ZW50cyBhcmUgYm91bmRcXG4gICAgICAgKiBAZXZlbnRcXG4gICAgICAgKiBAbmFtZSBpbml0LmpzdHJlZVxcbiAgICAgICAqL1xcblxcbiAgICAgIHRoaXMudHJpZ2dlcihcXFwiaW5pdFxcXCIpO1xcbiAgICAgIHRoaXMuX2RhdGEuY29yZS5vcmlnaW5hbF9jb250YWluZXJfaHRtbCA9IHRoaXMuZWxlbWVudC5maW5kKFxcXCIgPiB1bCA+IGxpXFxcIikuY2xvbmUodHJ1ZSk7XFxuXFxuICAgICAgdGhpcy5fZGF0YS5jb3JlLm9yaWdpbmFsX2NvbnRhaW5lcl9odG1sLmZpbmQoXFxcImxpXFxcIikuYWRkQmFjaygpLmNvbnRlbnRzKCkuZmlsdGVyKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVUeXBlID09PSAzICYmICghdGhpcy5ub2RlVmFsdWUgfHwgL15cXFxccyskLy50ZXN0KHRoaXMubm9kZVZhbHVlKSk7XFxuICAgICAgfSkucmVtb3ZlKCk7XFxuXFxuICAgICAgdGhpcy5lbGVtZW50Lmh0bWwoXFxcIjxcXFwiICsgXFxcInVsIGNsYXNzPSdqc3RyZWUtY29udGFpbmVyLXVsIGpzdHJlZS1jaGlsZHJlbicgcm9sZT0nZ3JvdXAnPjxcXFwiICsgXFxcImxpIGlkPSdqXFxcIiArIHRoaXMuX2lkICsgXFxcIl9sb2FkaW5nJyBjbGFzcz0nanN0cmVlLWluaXRpYWwtbm9kZSBqc3RyZWUtbG9hZGluZyBqc3RyZWUtbGVhZiBqc3RyZWUtbGFzdCcgcm9sZT0ndHJlZS1pdGVtJz48aSBjbGFzcz0nanN0cmVlLWljb24ganN0cmVlLW9jbCc+PC9pPjxcXFwiICsgXFxcImEgY2xhc3M9J2pzdHJlZS1hbmNob3InIGhyZWY9JyMnPjxpIGNsYXNzPSdqc3RyZWUtaWNvbiBqc3RyZWUtdGhlbWVpY29uLWhpZGRlbic+PC9pPlxcXCIgKyB0aGlzLmdldF9zdHJpbmcoXFxcIkxvYWRpbmcgLi4uXFxcIikgKyBcXFwiPC9hPjwvbGk+PC91bD5cXFwiKTtcXG4gICAgICB0aGlzLmVsZW1lbnQuYXR0cignYXJpYS1hY3RpdmVkZXNjZW5kYW50JywgJ2onICsgdGhpcy5faWQgKyAnX2xvYWRpbmcnKTtcXG4gICAgICB0aGlzLl9kYXRhLmNvcmUubGlfaGVpZ2h0ID0gdGhpcy5nZXRfY29udGFpbmVyX3VsKCkuY2hpbGRyZW4oXFxcImxpXFxcIikuZmlyc3QoKS5oZWlnaHQoKSB8fCAyNDtcXG4gICAgICB0aGlzLl9kYXRhLmNvcmUubm9kZSA9IHRoaXMuX2NyZWF0ZV9wcm90b3R5cGVfbm9kZSgpO1xcbiAgICAgIC8qKlxcbiAgICAgICAqIHRyaWdnZXJlZCBhZnRlciB0aGUgbG9hZGluZyB0ZXh0IGlzIHNob3duIGFuZCBiZWZvcmUgbG9hZGluZyBzdGFydHNcXG4gICAgICAgKiBAZXZlbnRcXG4gICAgICAgKiBAbmFtZSBsb2FkaW5nLmpzdHJlZVxcbiAgICAgICAqL1xcblxcbiAgICAgIHRoaXMudHJpZ2dlcihcXFwibG9hZGluZ1xcXCIpO1xcbiAgICAgIHRoaXMubG9hZF9ub2RlKCQuanN0cmVlLnJvb3QpO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogZGVzdHJveSBhbiBpbnN0YW5jZVxcbiAgICAgKiBAbmFtZSBkZXN0cm95KClcXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0ga2VlcF9odG1sIGlmIG5vdCBzZXQgdG8gYHRydWVgIHRoZSBjb250YWluZXIgd2lsbCBiZSBlbXB0aWVkLCBvdGhlcndpc2UgdGhlIGN1cnJlbnQgRE9NIGVsZW1lbnRzIHdpbGwgYmUga2VwdCBpbnRhY3RcXG4gICAgICovXFxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koa2VlcF9odG1sKSB7XFxuICAgICAgaWYgKHRoaXMuX3dyaykge1xcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgd2luZG93LlVSTC5yZXZva2VPYmplY3RVUkwodGhpcy5fd3JrKTtcXG4gICAgICAgICAgdGhpcy5fd3JrID0gbnVsbDtcXG4gICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCFrZWVwX2h0bWwpIHtcXG4gICAgICAgIHRoaXMuZWxlbWVudC5lbXB0eSgpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLnRlYXJkb3duKCk7XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGUgcHJvdG90eXBlIG5vZGVcXG4gICAgICovXFxuICAgIF9jcmVhdGVfcHJvdG90eXBlX25vZGU6IGZ1bmN0aW9uIF9jcmVhdGVfcHJvdG90eXBlX25vZGUoKSB7XFxuICAgICAgdmFyIF9ub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnTEknKSxcXG4gICAgICAgICAgX3RlbXAxLFxcbiAgICAgICAgICBfdGVtcDI7XFxuXFxuICAgICAgX25vZGUuc2V0QXR0cmlidXRlKCdyb2xlJywgJ3RyZWVpdGVtJyk7XFxuXFxuICAgICAgX3RlbXAxID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnSScpO1xcbiAgICAgIF90ZW1wMS5jbGFzc05hbWUgPSAnanN0cmVlLWljb24ganN0cmVlLW9jbCc7XFxuXFxuICAgICAgX3RlbXAxLnNldEF0dHJpYnV0ZSgncm9sZScsICdwcmVzZW50YXRpb24nKTtcXG5cXG4gICAgICBfbm9kZS5hcHBlbmRDaGlsZChfdGVtcDEpO1xcblxcbiAgICAgIF90ZW1wMSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0EnKTtcXG4gICAgICBfdGVtcDEuY2xhc3NOYW1lID0gJ2pzdHJlZS1hbmNob3InO1xcblxcbiAgICAgIF90ZW1wMS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCAnIycpO1xcblxcbiAgICAgIF90ZW1wMS5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJy0xJyk7XFxuXFxuICAgICAgX3RlbXAyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnSScpO1xcbiAgICAgIF90ZW1wMi5jbGFzc05hbWUgPSAnanN0cmVlLWljb24ganN0cmVlLXRoZW1laWNvbic7XFxuXFxuICAgICAgX3RlbXAyLnNldEF0dHJpYnV0ZSgncm9sZScsICdwcmVzZW50YXRpb24nKTtcXG5cXG4gICAgICBfdGVtcDEuYXBwZW5kQ2hpbGQoX3RlbXAyKTtcXG5cXG4gICAgICBfbm9kZS5hcHBlbmRDaGlsZChfdGVtcDEpO1xcblxcbiAgICAgIF90ZW1wMSA9IF90ZW1wMiA9IG51bGw7XFxuICAgICAgcmV0dXJuIF9ub2RlO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogcGFydCBvZiB0aGUgZGVzdHJveWluZyBvZiBhbiBpbnN0YW5jZS4gVXNlZCBpbnRlcm5hbGx5LlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAbmFtZSB0ZWFyZG93bigpXFxuICAgICAqL1xcbiAgICB0ZWFyZG93bjogZnVuY3Rpb24gdGVhcmRvd24oKSB7XFxuICAgICAgdGhpcy51bmJpbmQoKTtcXG4gICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlQ2xhc3MoJ2pzdHJlZScpLnJlbW92ZURhdGEoJ2pzdHJlZScpLmZpbmQoXFxcIltjbGFzc149J2pzdHJlZSddXFxcIikuYWRkQmFjaygpLmF0dHIoXFxcImNsYXNzXFxcIiwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xhc3NOYW1lLnJlcGxhY2UoL2pzdHJlZVteIF0qfCQvaWcsICcnKTtcXG4gICAgICB9KTtcXG4gICAgICB0aGlzLmVsZW1lbnQgPSBudWxsO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogYmluZCBhbGwgZXZlbnRzLiBVc2VkIGludGVybmFsbHkuXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBuYW1lIGJpbmQoKVxcbiAgICAgKi9cXG4gICAgYmluZDogZnVuY3Rpb24gYmluZCgpIHtcXG4gICAgICB2YXIgd29yZCA9ICcnLFxcbiAgICAgICAgICB0b3V0ID0gbnVsbCxcXG4gICAgICAgICAgd2FzX2NsaWNrID0gMDtcXG4gICAgICB0aGlzLmVsZW1lbnQub24oXFxcImRibGNsaWNrLmpzdHJlZVxcXCIsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICBpZiAoZS50YXJnZXQudGFnTmFtZSAmJiBlLnRhcmdldC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFxcXCJpbnB1dFxcXCIpIHtcXG4gICAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoZG9jdW1lbnQuc2VsZWN0aW9uICYmIGRvY3VtZW50LnNlbGVjdGlvbi5lbXB0eSkge1xcbiAgICAgICAgICBkb2N1bWVudC5zZWxlY3Rpb24uZW1wdHkoKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGlmICh3aW5kb3cuZ2V0U2VsZWN0aW9uKSB7XFxuICAgICAgICAgICAgdmFyIHNlbCA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcXG5cXG4gICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgc2VsLnJlbW92ZUFsbFJhbmdlcygpO1xcbiAgICAgICAgICAgICAgc2VsLmNvbGxhcHNlKCk7XFxuICAgICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfSkub24oXFxcIm1vdXNlZG93bi5qc3RyZWVcXFwiLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICBpZiAoZS50YXJnZXQgPT09IHRoaXMuZWxlbWVudFswXSkge1xcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7IC8vIHByZXZlbnQgbG9zaW5nIGZvY3VzIHdoZW4gY2xpY2tpbmcgc2Nyb2xsIGFycm93cyAoRkYsIENocm9tZSlcXG5cXG4gICAgICAgICAgd2FzX2NsaWNrID0gK25ldyBEYXRlKCk7IC8vIGllIGRvZXMgbm90IGFsbG93IHRvIHByZXZlbnQgbG9zaW5nIGZvY3VzXFxuICAgICAgICB9XFxuICAgICAgfSwgdGhpcykpLm9uKFxcXCJtb3VzZWRvd24uanN0cmVlXFxcIiwgXFxcIi5qc3RyZWUtb2NsXFxcIiwgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTsgLy8gcHJldmVudCBhbnkgbm9kZSBpbnNpZGUgZnJvbSBsb3NpbmcgZm9jdXMgd2hlbiBjbGlja2luZyB0aGUgb3Blbi9jbG9zZSBpY29uXFxuICAgICAgfSkub24oXFxcImNsaWNrLmpzdHJlZVxcXCIsIFxcXCIuanN0cmVlLW9jbFxcXCIsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgIHRoaXMudG9nZ2xlX25vZGUoZS50YXJnZXQpO1xcbiAgICAgIH0sIHRoaXMpKS5vbihcXFwiZGJsY2xpY2suanN0cmVlXFxcIiwgXFxcIi5qc3RyZWUtYW5jaG9yXFxcIiwgJC5wcm94eShmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgaWYgKGUudGFyZ2V0LnRhZ05hbWUgJiYgZS50YXJnZXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcXFwiaW5wdXRcXFwiKSB7XFxuICAgICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuY29yZS5kYmxjbGlja190b2dnbGUpIHtcXG4gICAgICAgICAgdGhpcy50b2dnbGVfbm9kZShlLnRhcmdldCk7XFxuICAgICAgICB9XFxuICAgICAgfSwgdGhpcykpLm9uKFxcXCJjbGljay5qc3RyZWVcXFwiLCBcXFwiLmpzdHJlZS1hbmNob3JcXFwiLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuXFxuICAgICAgICBpZiAoZS5jdXJyZW50VGFyZ2V0ICE9PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50KSB7XFxuICAgICAgICAgICQoZS5jdXJyZW50VGFyZ2V0KS5mb2N1cygpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdGhpcy5hY3RpdmF0ZV9ub2RlKGUuY3VycmVudFRhcmdldCwgZSk7XFxuICAgICAgfSwgdGhpcykpLm9uKCdrZXlkb3duLmpzdHJlZScsICcuanN0cmVlLWFuY2hvcicsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgIGlmIChlLnRhcmdldC50YWdOYW1lICYmIGUudGFyZ2V0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXFxcImlucHV0XFxcIikge1xcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChlLndoaWNoICE9PSAzMiAmJiBlLndoaWNoICE9PSAxMyAmJiAoZS5zaGlmdEtleSB8fCBlLmN0cmxLZXkgfHwgZS5hbHRLZXkgfHwgZS5tZXRhS2V5KSkge1xcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHZhciBvID0gbnVsbDtcXG5cXG4gICAgICAgIGlmICh0aGlzLl9kYXRhLmNvcmUucnRsKSB7XFxuICAgICAgICAgIGlmIChlLndoaWNoID09PSAzNykge1xcbiAgICAgICAgICAgIGUud2hpY2ggPSAzOTtcXG4gICAgICAgICAgfSBlbHNlIGlmIChlLndoaWNoID09PSAzOSkge1xcbiAgICAgICAgICAgIGUud2hpY2ggPSAzNztcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgc3dpdGNoIChlLndoaWNoKSB7XFxuICAgICAgICAgIGNhc2UgMzI6XFxuICAgICAgICAgICAgLy8gYXJpYSBkZWZpbmVzIHNwYWNlIG9ubHkgd2l0aCBDdHJsXFxuICAgICAgICAgICAgaWYgKGUuY3RybEtleSkge1xcbiAgICAgICAgICAgICAgZS50eXBlID0gXFxcImNsaWNrXFxcIjtcXG4gICAgICAgICAgICAgICQoZS5jdXJyZW50VGFyZ2V0KS50cmlnZ2VyKGUpO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgICAgY2FzZSAxMzpcXG4gICAgICAgICAgICAvLyBlbnRlclxcbiAgICAgICAgICAgIGUudHlwZSA9IFxcXCJjbGlja1xcXCI7XFxuICAgICAgICAgICAgJChlLmN1cnJlbnRUYXJnZXQpLnRyaWdnZXIoZSk7XFxuICAgICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICAgIGNhc2UgMzc6XFxuICAgICAgICAgICAgLy8gbGVmdFxcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXG5cXG4gICAgICAgICAgICBpZiAodGhpcy5pc19vcGVuKGUuY3VycmVudFRhcmdldCkpIHtcXG4gICAgICAgICAgICAgIHRoaXMuY2xvc2Vfbm9kZShlLmN1cnJlbnRUYXJnZXQpO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICBvID0gdGhpcy5nZXRfcGFyZW50KGUuY3VycmVudFRhcmdldCk7XFxuXFxuICAgICAgICAgICAgICBpZiAobyAmJiBvLmlkICE9PSAkLmpzdHJlZS5yb290KSB7XFxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0X25vZGUobywgdHJ1ZSkuY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuZm9jdXMoKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICAgIGNhc2UgMzg6XFxuICAgICAgICAgICAgLy8gdXBcXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICAgICAgbyA9IHRoaXMuZ2V0X3ByZXZfZG9tKGUuY3VycmVudFRhcmdldCk7XFxuXFxuICAgICAgICAgICAgaWYgKG8gJiYgby5sZW5ndGgpIHtcXG4gICAgICAgICAgICAgIG8uY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuZm9jdXMoKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICAgIGNhc2UgMzk6XFxuICAgICAgICAgICAgLy8gcmlnaHRcXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuXFxuICAgICAgICAgICAgaWYgKHRoaXMuaXNfY2xvc2VkKGUuY3VycmVudFRhcmdldCkpIHtcXG4gICAgICAgICAgICAgIHRoaXMub3Blbl9ub2RlKGUuY3VycmVudFRhcmdldCwgZnVuY3Rpb24gKG8pIHtcXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRfbm9kZShvLCB0cnVlKS5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5mb2N1cygpO1xcbiAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzX29wZW4oZS5jdXJyZW50VGFyZ2V0KSkge1xcbiAgICAgICAgICAgICAgbyA9IHRoaXMuZ2V0X25vZGUoZS5jdXJyZW50VGFyZ2V0LCB0cnVlKS5jaGlsZHJlbignLmpzdHJlZS1jaGlsZHJlbicpWzBdO1xcblxcbiAgICAgICAgICAgICAgaWYgKG8pIHtcXG4gICAgICAgICAgICAgICAgJCh0aGlzLl9maXJzdENoaWxkKG8pKS5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5mb2N1cygpO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgICAgY2FzZSA0MDpcXG4gICAgICAgICAgICAvLyBkb3duXFxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgICAgIG8gPSB0aGlzLmdldF9uZXh0X2RvbShlLmN1cnJlbnRUYXJnZXQpO1xcblxcbiAgICAgICAgICAgIGlmIChvICYmIG8ubGVuZ3RoKSB7XFxuICAgICAgICAgICAgICBvLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLmZvY3VzKCk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICBjYXNlIDEwNjpcXG4gICAgICAgICAgICAvLyBhcmlhIGRlZmluZXMgKiBvbiBudW1wYWQgYXMgb3Blbl9hbGwgLSBub3QgdmVyeSBjb21tb25cXG4gICAgICAgICAgICB0aGlzLm9wZW5fYWxsKCk7XFxuICAgICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICAgIGNhc2UgMzY6XFxuICAgICAgICAgICAgLy8gaG9tZVxcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgICAgICBvID0gdGhpcy5fZmlyc3RDaGlsZCh0aGlzLmdldF9jb250YWluZXJfdWwoKVswXSk7XFxuXFxuICAgICAgICAgICAgaWYgKG8pIHtcXG4gICAgICAgICAgICAgICQobykuY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuZmlsdGVyKCc6dmlzaWJsZScpLmZvY3VzKCk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICBjYXNlIDM1OlxcbiAgICAgICAgICAgIC8vIGVuZFxcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuZmluZCgnLmpzdHJlZS1hbmNob3InKS5maWx0ZXIoJzp2aXNpYmxlJykubGFzdCgpLmZvY3VzKCk7XFxuICAgICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICAgIGNhc2UgMTEzOlxcbiAgICAgICAgICAgIC8vIGYyIC0gc2FmZSB0byBpbmNsdWRlIC0gaWYgY2hlY2tfY2FsbGJhY2sgaXMgZmFsc2UgaXQgd2lsbCBmYWlsXFxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgICAgIHRoaXMuZWRpdChlLmN1cnJlbnRUYXJnZXQpO1xcbiAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICBkZWZhdWx0OlxcbiAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICAvKiFcXG4gICAgICAgICAgLy8gZGVsZXRlXFxuICAgICAgICAgIGNhc2UgNDY6XFxuICAgICAgICAgIFxcdGUucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgICAgXFx0byA9IHRoaXMuZ2V0X25vZGUoZS5jdXJyZW50VGFyZ2V0KTtcXG4gICAgICAgICAgXFx0aWYobyAmJiBvLmlkICYmIG8uaWQgIT09ICQuanN0cmVlLnJvb3QpIHtcXG4gICAgICAgICAgXFx0XFx0byA9IHRoaXMuaXNfc2VsZWN0ZWQobykgPyB0aGlzLmdldF9zZWxlY3RlZCgpIDogbztcXG4gICAgICAgICAgXFx0XFx0dGhpcy5kZWxldGVfbm9kZShvKTtcXG4gICAgICAgICAgXFx0fVxcbiAgICAgICAgICBcXHRicmVhaztcXG4gICAgICAgICAgXFx0Ki9cXG4gICAgICAgIH1cXG4gICAgICB9LCB0aGlzKSkub24oXFxcImxvYWRfbm9kZS5qc3RyZWVcXFwiLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XFxuICAgICAgICBpZiAoZGF0YS5zdGF0dXMpIHtcXG4gICAgICAgICAgaWYgKGRhdGEubm9kZS5pZCA9PT0gJC5qc3RyZWUucm9vdCAmJiAhdGhpcy5fZGF0YS5jb3JlLmxvYWRlZCkge1xcbiAgICAgICAgICAgIHRoaXMuX2RhdGEuY29yZS5sb2FkZWQgPSB0cnVlO1xcblxcbiAgICAgICAgICAgIGlmICh0aGlzLl9maXJzdENoaWxkKHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpWzBdKSkge1xcbiAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LmF0dHIoJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCcsIHRoaXMuX2ZpcnN0Q2hpbGQodGhpcy5nZXRfY29udGFpbmVyX3VsKClbMF0pLmlkKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgLyoqXFxuICAgICAgICAgICAgICogdHJpZ2dlcmVkIGFmdGVyIHRoZSByb290IG5vZGUgaXMgbG9hZGVkIGZvciB0aGUgZmlyc3QgdGltZVxcbiAgICAgICAgICAgICAqIEBldmVudFxcbiAgICAgICAgICAgICAqIEBuYW1lIGxvYWRlZC5qc3RyZWVcXG4gICAgICAgICAgICAgKi9cXG5cXG5cXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoXFxcImxvYWRlZFxcXCIpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmICghdGhpcy5fZGF0YS5jb3JlLnJlYWR5KSB7XFxuICAgICAgICAgICAgc2V0VGltZW91dCgkLnByb3h5KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgIGlmICh0aGlzLmVsZW1lbnQgJiYgIXRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpLmZpbmQoJy5qc3RyZWUtbG9hZGluZycpLmxlbmd0aCkge1xcbiAgICAgICAgICAgICAgICB0aGlzLl9kYXRhLmNvcmUucmVhZHkgPSB0cnVlO1xcblxcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLmxlbmd0aCkge1xcbiAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmNvcmUuZXhwYW5kX3NlbGVjdGVkX29ubG9hZCkge1xcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRtcCA9IFtdLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGksXFxuICAgICAgICAgICAgICAgICAgICAgICAgajtcXG5cXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGogPSB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICAgICAgICAgICAgICAgIHRtcCA9IHRtcC5jb25jYXQodGhpcy5fbW9kZWwuZGF0YVt0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWRbaV1dLnBhcmVudHMpO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICAgICAgdG1wID0gJC52YWthdGEuYXJyYXlfdW5pcXVlKHRtcCk7XFxuXFxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBqID0gdG1wLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wZW5fbm9kZSh0bXBbaV0sIGZhbHNlLCAwKTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdjaGFuZ2VkJywge1xcbiAgICAgICAgICAgICAgICAgICAgJ2FjdGlvbic6ICdyZWFkeScsXFxuICAgICAgICAgICAgICAgICAgICAnc2VsZWN0ZWQnOiB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWRcXG4gICAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAvKipcXG4gICAgICAgICAgICAgICAgICogdHJpZ2dlcmVkIGFmdGVyIGFsbCBub2RlcyBhcmUgZmluaXNoZWQgbG9hZGluZ1xcbiAgICAgICAgICAgICAgICAgKiBAZXZlbnRcXG4gICAgICAgICAgICAgICAgICogQG5hbWUgcmVhZHkuanN0cmVlXFxuICAgICAgICAgICAgICAgICAqL1xcblxcblxcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoXFxcInJlYWR5XFxcIik7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSwgdGhpcyksIDApO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfSwgdGhpcykpIC8vIHF1aWNrIHNlYXJjaGluZyB3aGVuIHRoZSB0cmVlIGlzIGZvY3VzZWRcXG4gICAgICAub24oJ2tleXByZXNzLmpzdHJlZScsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgIGlmIChlLnRhcmdldC50YWdOYW1lICYmIGUudGFyZ2V0LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXFxcImlucHV0XFxcIikge1xcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICh0b3V0KSB7XFxuICAgICAgICAgIGNsZWFyVGltZW91dCh0b3V0KTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHRvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgd29yZCA9ICcnO1xcbiAgICAgICAgfSwgNTAwKTtcXG4gICAgICAgIHZhciBjaHIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGUud2hpY2gpLnRvTG93ZXJDYXNlKCksXFxuICAgICAgICAgICAgY29sID0gdGhpcy5lbGVtZW50LmZpbmQoJy5qc3RyZWUtYW5jaG9yJykuZmlsdGVyKCc6dmlzaWJsZScpLFxcbiAgICAgICAgICAgIGluZCA9IGNvbC5pbmRleChkb2N1bWVudC5hY3RpdmVFbGVtZW50KSB8fCAwLFxcbiAgICAgICAgICAgIGVuZCA9IGZhbHNlO1xcbiAgICAgICAgd29yZCArPSBjaHI7IC8vIG1hdGNoIGZvciB3aG9sZSB3b3JkIGZyb20gY3VycmVudCBub2RlIGRvd24gKGluY2x1ZGluZyB0aGUgY3VycmVudCBub2RlKVxcblxcbiAgICAgICAgaWYgKHdvcmQubGVuZ3RoID4gMSkge1xcbiAgICAgICAgICBjb2wuc2xpY2UoaW5kKS5lYWNoKCQucHJveHkoZnVuY3Rpb24gKGksIHYpIHtcXG4gICAgICAgICAgICBpZiAoJCh2KS50ZXh0KCkudG9Mb3dlckNhc2UoKS5pbmRleE9mKHdvcmQpID09PSAwKSB7XFxuICAgICAgICAgICAgICAkKHYpLmZvY3VzKCk7XFxuICAgICAgICAgICAgICBlbmQgPSB0cnVlO1xcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSwgdGhpcykpO1xcblxcbiAgICAgICAgICBpZiAoZW5kKSB7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICB9IC8vIG1hdGNoIGZvciB3aG9sZSB3b3JkIGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgdHJlZVxcblxcblxcbiAgICAgICAgICBjb2wuc2xpY2UoMCwgaW5kKS5lYWNoKCQucHJveHkoZnVuY3Rpb24gKGksIHYpIHtcXG4gICAgICAgICAgICBpZiAoJCh2KS50ZXh0KCkudG9Mb3dlckNhc2UoKS5pbmRleE9mKHdvcmQpID09PSAwKSB7XFxuICAgICAgICAgICAgICAkKHYpLmZvY3VzKCk7XFxuICAgICAgICAgICAgICBlbmQgPSB0cnVlO1xcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSwgdGhpcykpO1xcblxcbiAgICAgICAgICBpZiAoZW5kKSB7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IC8vIGxpc3Qgbm9kZXMgdGhhdCBzdGFydCB3aXRoIHRoYXQgbGV0dGVyIChvbmx5IGlmIHdvcmQgY29uc2lzdHMgb2YgYSBzaW5nbGUgY2hhcilcXG5cXG5cXG4gICAgICAgIGlmIChuZXcgUmVnRXhwKCdeJyArIGNoci5yZXBsYWNlKC9bLVxcXFwvXFxcXFxcXFxeJCorPy4oKXxbXFxcXF17fV0vZywgJ1xcXFxcXFxcJCYnKSArICcrJCcpLnRlc3Qod29yZCkpIHtcXG4gICAgICAgICAgLy8gc2VhcmNoIGZvciB0aGUgbmV4dCBub2RlIHN0YXJ0aW5nIHdpdGggdGhhdCBsZXR0ZXJcXG4gICAgICAgICAgY29sLnNsaWNlKGluZCArIDEpLmVhY2goJC5wcm94eShmdW5jdGlvbiAoaSwgdikge1xcbiAgICAgICAgICAgIGlmICgkKHYpLnRleHQoKS50b0xvd2VyQ2FzZSgpLmNoYXJBdCgwKSA9PT0gY2hyKSB7XFxuICAgICAgICAgICAgICAkKHYpLmZvY3VzKCk7XFxuICAgICAgICAgICAgICBlbmQgPSB0cnVlO1xcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSwgdGhpcykpO1xcblxcbiAgICAgICAgICBpZiAoZW5kKSB7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICB9IC8vIHNlYXJjaCBmcm9tIHRoZSBiZWdpbm5pbmdcXG5cXG5cXG4gICAgICAgICAgY29sLnNsaWNlKDAsIGluZCArIDEpLmVhY2goJC5wcm94eShmdW5jdGlvbiAoaSwgdikge1xcbiAgICAgICAgICAgIGlmICgkKHYpLnRleHQoKS50b0xvd2VyQ2FzZSgpLmNoYXJBdCgwKSA9PT0gY2hyKSB7XFxuICAgICAgICAgICAgICAkKHYpLmZvY3VzKCk7XFxuICAgICAgICAgICAgICBlbmQgPSB0cnVlO1xcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSwgdGhpcykpO1xcblxcbiAgICAgICAgICBpZiAoZW5kKSB7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfSwgdGhpcykpIC8vIFRIRU1FIFJFTEFURURcXG4gICAgICAub24oXFxcImluaXQuanN0cmVlXFxcIiwgJC5wcm94eShmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgcyA9IHRoaXMuc2V0dGluZ3MuY29yZS50aGVtZXM7XFxuICAgICAgICB0aGlzLl9kYXRhLmNvcmUudGhlbWVzLmRvdHMgPSBzLmRvdHM7XFxuICAgICAgICB0aGlzLl9kYXRhLmNvcmUudGhlbWVzLnN0cmlwZXMgPSBzLnN0cmlwZXM7XFxuICAgICAgICB0aGlzLl9kYXRhLmNvcmUudGhlbWVzLmljb25zID0gcy5pY29ucztcXG4gICAgICAgIHRoaXMuX2RhdGEuY29yZS50aGVtZXMuZWxsaXBzaXMgPSBzLmVsbGlwc2lzO1xcbiAgICAgICAgdGhpcy5zZXRfdGhlbWUocy5uYW1lIHx8IFxcXCJkZWZhdWx0XFxcIiwgcy51cmwpO1xcbiAgICAgICAgdGhpcy5zZXRfdGhlbWVfdmFyaWFudChzLnZhcmlhbnQpO1xcbiAgICAgIH0sIHRoaXMpKS5vbihcXFwibG9hZGluZy5qc3RyZWVcXFwiLCAkLnByb3h5KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHRoaXNbdGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5kb3RzID8gXFxcInNob3dfZG90c1xcXCIgOiBcXFwiaGlkZV9kb3RzXFxcIl0oKTtcXG4gICAgICAgIHRoaXNbdGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5pY29ucyA/IFxcXCJzaG93X2ljb25zXFxcIiA6IFxcXCJoaWRlX2ljb25zXFxcIl0oKTtcXG4gICAgICAgIHRoaXNbdGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5zdHJpcGVzID8gXFxcInNob3dfc3RyaXBlc1xcXCIgOiBcXFwiaGlkZV9zdHJpcGVzXFxcIl0oKTtcXG4gICAgICAgIHRoaXNbdGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5lbGxpcHNpcyA/IFxcXCJzaG93X2VsbGlwc2lzXFxcIiA6IFxcXCJoaWRlX2VsbGlwc2lzXFxcIl0oKTtcXG4gICAgICB9LCB0aGlzKSkub24oJ2JsdXIuanN0cmVlJywgJy5qc3RyZWUtYW5jaG9yJywgJC5wcm94eShmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgdGhpcy5fZGF0YS5jb3JlLmZvY3VzZWQgPSBudWxsO1xcbiAgICAgICAgJChlLmN1cnJlbnRUYXJnZXQpLmZpbHRlcignLmpzdHJlZS1ob3ZlcmVkJykubW91c2VsZWF2ZSgpO1xcbiAgICAgICAgdGhpcy5lbGVtZW50LmF0dHIoJ3RhYmluZGV4JywgJzAnKTtcXG4gICAgICB9LCB0aGlzKSkub24oJ2ZvY3VzLmpzdHJlZScsICcuanN0cmVlLWFuY2hvcicsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgIHZhciB0bXAgPSB0aGlzLmdldF9ub2RlKGUuY3VycmVudFRhcmdldCk7XFxuXFxuICAgICAgICBpZiAodG1wICYmIHRtcC5pZCkge1xcbiAgICAgICAgICB0aGlzLl9kYXRhLmNvcmUuZm9jdXNlZCA9IHRtcC5pZDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHRoaXMuZWxlbWVudC5maW5kKCcuanN0cmVlLWhvdmVyZWQnKS5ub3QoZS5jdXJyZW50VGFyZ2V0KS5tb3VzZWxlYXZlKCk7XFxuICAgICAgICAkKGUuY3VycmVudFRhcmdldCkubW91c2VlbnRlcigpO1xcbiAgICAgICAgdGhpcy5lbGVtZW50LmF0dHIoJ3RhYmluZGV4JywgJy0xJyk7XFxuICAgICAgfSwgdGhpcykpLm9uKCdmb2N1cy5qc3RyZWUnLCAkLnByb3h5KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGlmICgrbmV3IERhdGUoKSAtIHdhc19jbGljayA+IDUwMCAmJiAhdGhpcy5fZGF0YS5jb3JlLmZvY3VzZWQpIHtcXG4gICAgICAgICAgd2FzX2NsaWNrID0gMDtcXG4gICAgICAgICAgdmFyIGFjdCA9IHRoaXMuZ2V0X25vZGUodGhpcy5lbGVtZW50LmF0dHIoJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCcpLCB0cnVlKTtcXG5cXG4gICAgICAgICAgaWYgKGFjdCkge1xcbiAgICAgICAgICAgIGFjdC5maW5kKCc+IC5qc3RyZWUtYW5jaG9yJykuZm9jdXMoKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH0sIHRoaXMpKS5vbignbW91c2VlbnRlci5qc3RyZWUnLCAnLmpzdHJlZS1hbmNob3InLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICB0aGlzLmhvdmVyX25vZGUoZS5jdXJyZW50VGFyZ2V0KTtcXG4gICAgICB9LCB0aGlzKSkub24oJ21vdXNlbGVhdmUuanN0cmVlJywgJy5qc3RyZWUtYW5jaG9yJywgJC5wcm94eShmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgdGhpcy5kZWhvdmVyX25vZGUoZS5jdXJyZW50VGFyZ2V0KTtcXG4gICAgICB9LCB0aGlzKSk7XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBwYXJ0IG9mIHRoZSBkZXN0cm95aW5nIG9mIGFuIGluc3RhbmNlLiBVc2VkIGludGVybmFsbHkuXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBuYW1lIHVuYmluZCgpXFxuICAgICAqL1xcbiAgICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCgpIHtcXG4gICAgICB0aGlzLmVsZW1lbnQub2ZmKCcuanN0cmVlJyk7XFxuICAgICAgJChkb2N1bWVudCkub2ZmKCcuanN0cmVlLScgKyB0aGlzLl9pZCk7XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiB0cmlnZ2VyIGFuIGV2ZW50LiBVc2VkIGludGVybmFsbHkuXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBuYW1lIHRyaWdnZXIoZXYgWywgZGF0YV0pXFxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gZXYgdGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHRyaWdnZXJcXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBkYXRhIGFkZGl0aW9uYWwgZGF0YSB0byBwYXNzIHdpdGggdGhlIGV2ZW50XFxuICAgICAqL1xcbiAgICB0cmlnZ2VyOiBmdW5jdGlvbiB0cmlnZ2VyKGV2LCBkYXRhKSB7XFxuICAgICAgaWYgKCFkYXRhKSB7XFxuICAgICAgICBkYXRhID0ge307XFxuICAgICAgfVxcblxcbiAgICAgIGRhdGEuaW5zdGFuY2UgPSB0aGlzO1xcbiAgICAgIHRoaXMuZWxlbWVudC50cmlnZ2VySGFuZGxlcihldi5yZXBsYWNlKCcuanN0cmVlJywgJycpICsgJy5qc3RyZWUnLCBkYXRhKTtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIHJldHVybnMgdGhlIGpRdWVyeSBleHRlbmRlZCBpbnN0YW5jZSBjb250YWluZXJcXG4gICAgICogQG5hbWUgZ2V0X2NvbnRhaW5lcigpXFxuICAgICAqIEByZXR1cm4ge2pRdWVyeX1cXG4gICAgICovXFxuICAgIGdldF9jb250YWluZXI6IGZ1bmN0aW9uIGdldF9jb250YWluZXIoKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudDtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIHJldHVybnMgdGhlIGpRdWVyeSBleHRlbmRlZCBtYWluIFVMIG5vZGUgaW5zaWRlIHRoZSBpbnN0YW5jZSBjb250YWluZXIuIFVzZWQgaW50ZXJuYWxseS5cXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQG5hbWUgZ2V0X2NvbnRhaW5lcl91bCgpXFxuICAgICAqIEByZXR1cm4ge2pRdWVyeX1cXG4gICAgICovXFxuICAgIGdldF9jb250YWluZXJfdWw6IGZ1bmN0aW9uIGdldF9jb250YWluZXJfdWwoKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC5jaGlsZHJlbihcXFwiLmpzdHJlZS1jaGlsZHJlblxcXCIpLmZpcnN0KCk7XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBnZXRzIHN0cmluZyByZXBsYWNlbWVudHMgKGxvY2FsaXphdGlvbikuIFVzZWQgaW50ZXJuYWxseS5cXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQG5hbWUgZ2V0X3N0cmluZyhrZXkpXFxuICAgICAqIEBwYXJhbSAge1N0cmluZ30ga2V5XFxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cXG4gICAgICovXFxuICAgIGdldF9zdHJpbmc6IGZ1bmN0aW9uIGdldF9zdHJpbmcoa2V5KSB7XFxuICAgICAgdmFyIGEgPSB0aGlzLnNldHRpbmdzLmNvcmUuc3RyaW5ncztcXG5cXG4gICAgICBpZiAoJC5pc0Z1bmN0aW9uKGEpKSB7XFxuICAgICAgICByZXR1cm4gYS5jYWxsKHRoaXMsIGtleSk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChhICYmIGFba2V5XSkge1xcbiAgICAgICAgcmV0dXJuIGFba2V5XTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIGtleTtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIGdldHMgdGhlIGZpcnN0IGNoaWxkIG9mIGEgRE9NIG5vZGUuIFVzZWQgaW50ZXJuYWxseS5cXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQG5hbWUgX2ZpcnN0Q2hpbGQoZG9tKVxcbiAgICAgKiBAcGFyYW0gIHtET01FbGVtZW50fSBkb21cXG4gICAgICogQHJldHVybiB7RE9NRWxlbWVudH1cXG4gICAgICovXFxuICAgIF9maXJzdENoaWxkOiBmdW5jdGlvbiBfZmlyc3RDaGlsZChkb20pIHtcXG4gICAgICBkb20gPSBkb20gPyBkb20uZmlyc3RDaGlsZCA6IG51bGw7XFxuXFxuICAgICAgd2hpbGUgKGRvbSAhPT0gbnVsbCAmJiBkb20ubm9kZVR5cGUgIT09IDEpIHtcXG4gICAgICAgIGRvbSA9IGRvbS5uZXh0U2libGluZztcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIGRvbTtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIGdldHMgdGhlIG5leHQgc2libGluZyBvZiBhIERPTSBub2RlLiBVc2VkIGludGVybmFsbHkuXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBuYW1lIF9uZXh0U2libGluZyhkb20pXFxuICAgICAqIEBwYXJhbSAge0RPTUVsZW1lbnR9IGRvbVxcbiAgICAgKiBAcmV0dXJuIHtET01FbGVtZW50fVxcbiAgICAgKi9cXG4gICAgX25leHRTaWJsaW5nOiBmdW5jdGlvbiBfbmV4dFNpYmxpbmcoZG9tKSB7XFxuICAgICAgZG9tID0gZG9tID8gZG9tLm5leHRTaWJsaW5nIDogbnVsbDtcXG5cXG4gICAgICB3aGlsZSAoZG9tICE9PSBudWxsICYmIGRvbS5ub2RlVHlwZSAhPT0gMSkge1xcbiAgICAgICAgZG9tID0gZG9tLm5leHRTaWJsaW5nO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gZG9tO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogZ2V0cyB0aGUgcHJldmlvdXMgc2libGluZyBvZiBhIERPTSBub2RlLiBVc2VkIGludGVybmFsbHkuXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBuYW1lIF9wcmV2aW91c1NpYmxpbmcoZG9tKVxcbiAgICAgKiBAcGFyYW0gIHtET01FbGVtZW50fSBkb21cXG4gICAgICogQHJldHVybiB7RE9NRWxlbWVudH1cXG4gICAgICovXFxuICAgIF9wcmV2aW91c1NpYmxpbmc6IGZ1bmN0aW9uIF9wcmV2aW91c1NpYmxpbmcoZG9tKSB7XFxuICAgICAgZG9tID0gZG9tID8gZG9tLnByZXZpb3VzU2libGluZyA6IG51bGw7XFxuXFxuICAgICAgd2hpbGUgKGRvbSAhPT0gbnVsbCAmJiBkb20ubm9kZVR5cGUgIT09IDEpIHtcXG4gICAgICAgIGRvbSA9IGRvbS5wcmV2aW91c1NpYmxpbmc7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBkb207XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBnZXQgdGhlIEpTT04gcmVwcmVzZW50YXRpb24gb2YgYSBub2RlIChvciB0aGUgYWN0dWFsIGpRdWVyeSBleHRlbmRlZCBET00gbm9kZSkgYnkgdXNpbmcgYW55IGlucHV0IChjaGlsZCBET00gZWxlbWVudCwgSUQgc3RyaW5nLCBzZWxlY3RvciwgZXRjKVxcbiAgICAgKiBAbmFtZSBnZXRfbm9kZShvYmogWywgYXNfZG9tXSlcXG4gICAgICogQHBhcmFtICB7bWl4ZWR9IG9ialxcbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBhc19kb21cXG4gICAgICogQHJldHVybiB7T2JqZWN0fGpRdWVyeX1cXG4gICAgICovXFxuICAgIGdldF9ub2RlOiBmdW5jdGlvbiBnZXRfbm9kZShvYmosIGFzX2RvbSkge1xcbiAgICAgIGlmIChvYmogJiYgb2JqLmlkKSB7XFxuICAgICAgICBvYmogPSBvYmouaWQ7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBkb207XFxuXFxuICAgICAgdHJ5IHtcXG4gICAgICAgIGlmICh0aGlzLl9tb2RlbC5kYXRhW29ial0pIHtcXG4gICAgICAgICAgb2JqID0gdGhpcy5fbW9kZWwuZGF0YVtvYmpdO1xcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSBcXFwic3RyaW5nXFxcIiAmJiB0aGlzLl9tb2RlbC5kYXRhW29iai5yZXBsYWNlKC9eIy8sICcnKV0pIHtcXG4gICAgICAgICAgb2JqID0gdGhpcy5fbW9kZWwuZGF0YVtvYmoucmVwbGFjZSgvXiMvLCAnJyldO1xcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSBcXFwic3RyaW5nXFxcIiAmJiAoZG9tID0gJCgnIycgKyBvYmoucmVwbGFjZSgkLmpzdHJlZS5pZHJlZ2V4LCAnXFxcXFxcXFwkJicpLCB0aGlzLmVsZW1lbnQpKS5sZW5ndGggJiYgdGhpcy5fbW9kZWwuZGF0YVtkb20uY2xvc2VzdCgnLmpzdHJlZS1ub2RlJykuYXR0cignaWQnKV0pIHtcXG4gICAgICAgICAgb2JqID0gdGhpcy5fbW9kZWwuZGF0YVtkb20uY2xvc2VzdCgnLmpzdHJlZS1ub2RlJykuYXR0cignaWQnKV07XFxuICAgICAgICB9IGVsc2UgaWYgKChkb20gPSAkKG9iaiwgdGhpcy5lbGVtZW50KSkubGVuZ3RoICYmIHRoaXMuX21vZGVsLmRhdGFbZG9tLmNsb3Nlc3QoJy5qc3RyZWUtbm9kZScpLmF0dHIoJ2lkJyldKSB7XFxuICAgICAgICAgIG9iaiA9IHRoaXMuX21vZGVsLmRhdGFbZG9tLmNsb3Nlc3QoJy5qc3RyZWUtbm9kZScpLmF0dHIoJ2lkJyldO1xcbiAgICAgICAgfSBlbHNlIGlmICgoZG9tID0gJChvYmosIHRoaXMuZWxlbWVudCkpLmxlbmd0aCAmJiBkb20uaGFzQ2xhc3MoJ2pzdHJlZScpKSB7XFxuICAgICAgICAgIG9iaiA9IHRoaXMuX21vZGVsLmRhdGFbJC5qc3RyZWUucm9vdF07XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoYXNfZG9tKSB7XFxuICAgICAgICAgIG9iaiA9IG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCA/IHRoaXMuZWxlbWVudCA6ICQoJyMnICsgb2JqLmlkLnJlcGxhY2UoJC5qc3RyZWUuaWRyZWdleCwgJ1xcXFxcXFxcJCYnKSwgdGhpcy5lbGVtZW50KTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiBvYmo7XFxuICAgICAgfSBjYXRjaCAoZXgpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBnZXQgdGhlIHBhdGggdG8gYSBub2RlLCBlaXRoZXIgY29uc2lzdGluZyBvZiBub2RlIHRleHRzLCBvciBvZiBub2RlIElEcywgb3B0aW9uYWxseSBnbHVlZCB0b2dldGhlciAob3RoZXJ3aXNlIGFuIGFycmF5KVxcbiAgICAgKiBAbmFtZSBnZXRfcGF0aChvYmogWywgZ2x1ZSwgaWRzXSlcXG4gICAgICogQHBhcmFtICB7bWl4ZWR9IG9iaiB0aGUgbm9kZVxcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGdsdWUgaWYgeW91IHdhbnQgdGhlIHBhdGggYXMgYSBzdHJpbmcgLSBwYXNzIHRoZSBnbHVlIGhlcmUgKGZvciBleGFtcGxlICcvJyksIGlmIGEgZmFsc3kgdmFsdWUgaXMgc3VwcGxpZWQgaGVyZSwgYW4gYXJyYXkgaXMgcmV0dXJuZWRcXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gaWRzIGlmIHNldCB0byB0cnVlIGJ1aWxkIHRoZSBwYXRoIHVzaW5nIElELCBvdGhlcndpc2Ugbm9kZSB0ZXh0IGlzIHVzZWRcXG4gICAgICogQHJldHVybiB7bWl4ZWR9XFxuICAgICAqL1xcbiAgICBnZXRfcGF0aDogZnVuY3Rpb24gZ2V0X3BhdGgob2JqLCBnbHVlLCBpZHMpIHtcXG4gICAgICBvYmogPSBvYmoucGFyZW50cyA/IG9iaiA6IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXG4gICAgICBpZiAoIW9iaiB8fCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QgfHwgIW9iai5wYXJlbnRzKSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBpLFxcbiAgICAgICAgICBqLFxcbiAgICAgICAgICBwID0gW107XFxuICAgICAgcC5wdXNoKGlkcyA/IG9iai5pZCA6IG9iai50ZXh0KTtcXG5cXG4gICAgICBmb3IgKGkgPSAwLCBqID0gb2JqLnBhcmVudHMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICBwLnB1c2goaWRzID8gb2JqLnBhcmVudHNbaV0gOiB0aGlzLmdldF90ZXh0KG9iai5wYXJlbnRzW2ldKSk7XFxuICAgICAgfVxcblxcbiAgICAgIHAgPSBwLnJldmVyc2UoKS5zbGljZSgxKTtcXG4gICAgICByZXR1cm4gZ2x1ZSA/IHAuam9pbihnbHVlKSA6IHA7XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBnZXQgdGhlIG5leHQgdmlzaWJsZSBub2RlIHRoYXQgaXMgYmVsb3cgdGhlIGBvYmpgIG5vZGUuIElmIGBzdHJpY3RgIGlzIHNldCB0byBgdHJ1ZWAgb25seSBzaWJsaW5nIG5vZGVzIGFyZSByZXR1cm5lZC5cXG4gICAgICogQG5hbWUgZ2V0X25leHRfZG9tKG9iaiBbLCBzdHJpY3RdKVxcbiAgICAgKiBAcGFyYW0gIHttaXhlZH0gb2JqXFxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IHN0cmljdFxcbiAgICAgKiBAcmV0dXJuIHtqUXVlcnl9XFxuICAgICAqL1xcbiAgICBnZXRfbmV4dF9kb206IGZ1bmN0aW9uIGdldF9uZXh0X2RvbShvYmosIHN0cmljdCkge1xcbiAgICAgIHZhciB0bXA7XFxuICAgICAgb2JqID0gdGhpcy5nZXRfbm9kZShvYmosIHRydWUpO1xcblxcbiAgICAgIGlmIChvYmpbMF0gPT09IHRoaXMuZWxlbWVudFswXSkge1xcbiAgICAgICAgdG1wID0gdGhpcy5fZmlyc3RDaGlsZCh0aGlzLmdldF9jb250YWluZXJfdWwoKVswXSk7XFxuXFxuICAgICAgICB3aGlsZSAodG1wICYmIHRtcC5vZmZzZXRIZWlnaHQgPT09IDApIHtcXG4gICAgICAgICAgdG1wID0gdGhpcy5fbmV4dFNpYmxpbmcodG1wKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiB0bXAgPyAkKHRtcCkgOiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCFvYmogfHwgIW9iai5sZW5ndGgpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHN0cmljdCkge1xcbiAgICAgICAgdG1wID0gb2JqWzBdO1xcblxcbiAgICAgICAgZG8ge1xcbiAgICAgICAgICB0bXAgPSB0aGlzLl9uZXh0U2libGluZyh0bXApO1xcbiAgICAgICAgfSB3aGlsZSAodG1wICYmIHRtcC5vZmZzZXRIZWlnaHQgPT09IDApO1xcblxcbiAgICAgICAgcmV0dXJuIHRtcCA/ICQodG1wKSA6IGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAob2JqLmhhc0NsYXNzKFxcXCJqc3RyZWUtb3BlblxcXCIpKSB7XFxuICAgICAgICB0bXAgPSB0aGlzLl9maXJzdENoaWxkKG9iai5jaGlsZHJlbignLmpzdHJlZS1jaGlsZHJlbicpWzBdKTtcXG5cXG4gICAgICAgIHdoaWxlICh0bXAgJiYgdG1wLm9mZnNldEhlaWdodCA9PT0gMCkge1xcbiAgICAgICAgICB0bXAgPSB0aGlzLl9uZXh0U2libGluZyh0bXApO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKHRtcCAhPT0gbnVsbCkge1xcbiAgICAgICAgICByZXR1cm4gJCh0bXApO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICB0bXAgPSBvYmpbMF07XFxuXFxuICAgICAgZG8ge1xcbiAgICAgICAgdG1wID0gdGhpcy5fbmV4dFNpYmxpbmcodG1wKTtcXG4gICAgICB9IHdoaWxlICh0bXAgJiYgdG1wLm9mZnNldEhlaWdodCA9PT0gMCk7XFxuXFxuICAgICAgaWYgKHRtcCAhPT0gbnVsbCkge1xcbiAgICAgICAgcmV0dXJuICQodG1wKTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIG9iai5wYXJlbnRzVW50aWwoXFxcIi5qc3RyZWVcXFwiLCBcXFwiLmpzdHJlZS1ub2RlXFxcIikubmV4dEFsbChcXFwiLmpzdHJlZS1ub2RlOnZpc2libGVcXFwiKS5maXJzdCgpO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogZ2V0IHRoZSBwcmV2aW91cyB2aXNpYmxlIG5vZGUgdGhhdCBpcyBhYm92ZSB0aGUgYG9iamAgbm9kZS4gSWYgYHN0cmljdGAgaXMgc2V0IHRvIGB0cnVlYCBvbmx5IHNpYmxpbmcgbm9kZXMgYXJlIHJldHVybmVkLlxcbiAgICAgKiBAbmFtZSBnZXRfcHJldl9kb20ob2JqIFssIHN0cmljdF0pXFxuICAgICAqIEBwYXJhbSAge21peGVkfSBvYmpcXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gc3RyaWN0XFxuICAgICAqIEByZXR1cm4ge2pRdWVyeX1cXG4gICAgICovXFxuICAgIGdldF9wcmV2X2RvbTogZnVuY3Rpb24gZ2V0X3ByZXZfZG9tKG9iaiwgc3RyaWN0KSB7XFxuICAgICAgdmFyIHRtcDtcXG4gICAgICBvYmogPSB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSk7XFxuXFxuICAgICAgaWYgKG9ialswXSA9PT0gdGhpcy5lbGVtZW50WzBdKSB7XFxuICAgICAgICB0bXAgPSB0aGlzLmdldF9jb250YWluZXJfdWwoKVswXS5sYXN0Q2hpbGQ7XFxuXFxuICAgICAgICB3aGlsZSAodG1wICYmIHRtcC5vZmZzZXRIZWlnaHQgPT09IDApIHtcXG4gICAgICAgICAgdG1wID0gdGhpcy5fcHJldmlvdXNTaWJsaW5nKHRtcCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gdG1wID8gJCh0bXApIDogZmFsc2U7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghb2JqIHx8ICFvYmoubGVuZ3RoKSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChzdHJpY3QpIHtcXG4gICAgICAgIHRtcCA9IG9ialswXTtcXG5cXG4gICAgICAgIGRvIHtcXG4gICAgICAgICAgdG1wID0gdGhpcy5fcHJldmlvdXNTaWJsaW5nKHRtcCk7XFxuICAgICAgICB9IHdoaWxlICh0bXAgJiYgdG1wLm9mZnNldEhlaWdodCA9PT0gMCk7XFxuXFxuICAgICAgICByZXR1cm4gdG1wID8gJCh0bXApIDogZmFsc2U7XFxuICAgICAgfVxcblxcbiAgICAgIHRtcCA9IG9ialswXTtcXG5cXG4gICAgICBkbyB7XFxuICAgICAgICB0bXAgPSB0aGlzLl9wcmV2aW91c1NpYmxpbmcodG1wKTtcXG4gICAgICB9IHdoaWxlICh0bXAgJiYgdG1wLm9mZnNldEhlaWdodCA9PT0gMCk7XFxuXFxuICAgICAgaWYgKHRtcCAhPT0gbnVsbCkge1xcbiAgICAgICAgb2JqID0gJCh0bXApO1xcblxcbiAgICAgICAgd2hpbGUgKG9iai5oYXNDbGFzcyhcXFwianN0cmVlLW9wZW5cXFwiKSkge1xcbiAgICAgICAgICBvYmogPSBvYmouY2hpbGRyZW4oXFxcIi5qc3RyZWUtY2hpbGRyZW5cXFwiKS5maXJzdCgpLmNoaWxkcmVuKFxcXCIuanN0cmVlLW5vZGU6dmlzaWJsZTpsYXN0XFxcIik7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gb2JqO1xcbiAgICAgIH1cXG5cXG4gICAgICB0bXAgPSBvYmpbMF0ucGFyZW50Tm9kZS5wYXJlbnROb2RlO1xcbiAgICAgIHJldHVybiB0bXAgJiYgdG1wLmNsYXNzTmFtZSAmJiB0bXAuY2xhc3NOYW1lLmluZGV4T2YoJ2pzdHJlZS1ub2RlJykgIT09IC0xID8gJCh0bXApIDogZmFsc2U7XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBnZXQgdGhlIHBhcmVudCBJRCBvZiBhIG5vZGVcXG4gICAgICogQG5hbWUgZ2V0X3BhcmVudChvYmopXFxuICAgICAqIEBwYXJhbSAge21peGVkfSBvYmpcXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxcbiAgICAgKi9cXG4gICAgZ2V0X3BhcmVudDogZnVuY3Rpb24gZ2V0X3BhcmVudChvYmopIHtcXG4gICAgICBvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XFxuXFxuICAgICAgaWYgKCFvYmogfHwgb2JqLmlkID09PSAkLmpzdHJlZS5yb290KSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBvYmoucGFyZW50O1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogZ2V0IGEgalF1ZXJ5IGNvbGxlY3Rpb24gb2YgYWxsIHRoZSBjaGlsZHJlbiBvZiBhIG5vZGUgKG5vZGUgbXVzdCBiZSByZW5kZXJlZClcXG4gICAgICogQG5hbWUgZ2V0X2NoaWxkcmVuX2RvbShvYmopXFxuICAgICAqIEBwYXJhbSAge21peGVkfSBvYmpcXG4gICAgICogQHJldHVybiB7alF1ZXJ5fVxcbiAgICAgKi9cXG4gICAgZ2V0X2NoaWxkcmVuX2RvbTogZnVuY3Rpb24gZ2V0X2NoaWxkcmVuX2RvbShvYmopIHtcXG4gICAgICBvYmogPSB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSk7XFxuXFxuICAgICAgaWYgKG9ialswXSA9PT0gdGhpcy5lbGVtZW50WzBdKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5nZXRfY29udGFpbmVyX3VsKCkuY2hpbGRyZW4oXFxcIi5qc3RyZWUtbm9kZVxcXCIpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIW9iaiB8fCAhb2JqLmxlbmd0aCkge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gb2JqLmNoaWxkcmVuKFxcXCIuanN0cmVlLWNoaWxkcmVuXFxcIikuY2hpbGRyZW4oXFxcIi5qc3RyZWUtbm9kZVxcXCIpO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogY2hlY2tzIGlmIGEgbm9kZSBoYXMgY2hpbGRyZW5cXG4gICAgICogQG5hbWUgaXNfcGFyZW50KG9iailcXG4gICAgICogQHBhcmFtICB7bWl4ZWR9IG9ialxcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxcbiAgICAgKi9cXG4gICAgaXNfcGFyZW50OiBmdW5jdGlvbiBpc19wYXJlbnQob2JqKSB7XFxuICAgICAgb2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xcbiAgICAgIHJldHVybiBvYmogJiYgKG9iai5zdGF0ZS5sb2FkZWQgPT09IGZhbHNlIHx8IG9iai5jaGlsZHJlbi5sZW5ndGggPiAwKTtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIGNoZWNrcyBpZiBhIG5vZGUgaXMgbG9hZGVkIChpdHMgY2hpbGRyZW4gYXJlIGF2YWlsYWJsZSlcXG4gICAgICogQG5hbWUgaXNfbG9hZGVkKG9iailcXG4gICAgICogQHBhcmFtICB7bWl4ZWR9IG9ialxcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxcbiAgICAgKi9cXG4gICAgaXNfbG9hZGVkOiBmdW5jdGlvbiBpc19sb2FkZWQob2JqKSB7XFxuICAgICAgb2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xcbiAgICAgIHJldHVybiBvYmogJiYgb2JqLnN0YXRlLmxvYWRlZDtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIGNoZWNrIGlmIGEgbm9kZSBpcyBjdXJyZW50bHkgbG9hZGluZyAoZmV0Y2hpbmcgY2hpbGRyZW4pXFxuICAgICAqIEBuYW1lIGlzX2xvYWRpbmcob2JqKVxcbiAgICAgKiBAcGFyYW0gIHttaXhlZH0gb2JqXFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XFxuICAgICAqL1xcbiAgICBpc19sb2FkaW5nOiBmdW5jdGlvbiBpc19sb2FkaW5nKG9iaikge1xcbiAgICAgIG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcXG4gICAgICByZXR1cm4gb2JqICYmIG9iai5zdGF0ZSAmJiBvYmouc3RhdGUubG9hZGluZztcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIGNoZWNrIGlmIGEgbm9kZSBpcyBvcGVuZWRcXG4gICAgICogQG5hbWUgaXNfb3BlbihvYmopXFxuICAgICAqIEBwYXJhbSAge21peGVkfSBvYmpcXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cXG4gICAgICovXFxuICAgIGlzX29wZW46IGZ1bmN0aW9uIGlzX29wZW4ob2JqKSB7XFxuICAgICAgb2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xcbiAgICAgIHJldHVybiBvYmogJiYgb2JqLnN0YXRlLm9wZW5lZDtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIGNoZWNrIGlmIGEgbm9kZSBpcyBpbiBhIGNsb3NlZCBzdGF0ZVxcbiAgICAgKiBAbmFtZSBpc19jbG9zZWQob2JqKVxcbiAgICAgKiBAcGFyYW0gIHttaXhlZH0gb2JqXFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XFxuICAgICAqL1xcbiAgICBpc19jbG9zZWQ6IGZ1bmN0aW9uIGlzX2Nsb3NlZChvYmopIHtcXG4gICAgICBvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XFxuICAgICAgcmV0dXJuIG9iaiAmJiB0aGlzLmlzX3BhcmVudChvYmopICYmICFvYmouc3RhdGUub3BlbmVkO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogY2hlY2sgaWYgYSBub2RlIGhhcyBubyBjaGlsZHJlblxcbiAgICAgKiBAbmFtZSBpc19sZWFmKG9iailcXG4gICAgICogQHBhcmFtICB7bWl4ZWR9IG9ialxcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxcbiAgICAgKi9cXG4gICAgaXNfbGVhZjogZnVuY3Rpb24gaXNfbGVhZihvYmopIHtcXG4gICAgICByZXR1cm4gIXRoaXMuaXNfcGFyZW50KG9iaik7XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBsb2FkcyBhIG5vZGUgKGZldGNoZXMgaXRzIGNoaWxkcmVuIHVzaW5nIHRoZSBgY29yZS5kYXRhYCBzZXR0aW5nKS4gTXVsdGlwbGUgbm9kZXMgY2FuIGJlIHBhc3NlZCB0byBieSB1c2luZyBhbiBhcnJheS5cXG4gICAgICogQG5hbWUgbG9hZF9ub2RlKG9iaiBbLCBjYWxsYmFja10pXFxuICAgICAqIEBwYXJhbSAge21peGVkfSBvYmpcXG4gICAgICogQHBhcmFtICB7ZnVuY3Rpb259IGNhbGxiYWNrIGEgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgb25jZSBsb2FkaW5nIGlzIGNvbXBsZXRlLCB0aGUgZnVuY3Rpb24gaXMgZXhlY3V0ZWQgaW4gdGhlIGluc3RhbmNlJ3Mgc2NvcGUgYW5kIHJlY2VpdmVzIHR3byBhcmd1bWVudHMgLSB0aGUgbm9kZSBhbmQgYSBib29sZWFuIHN0YXR1c1xcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxcbiAgICAgKiBAdHJpZ2dlciBsb2FkX25vZGUuanN0cmVlXFxuICAgICAqL1xcbiAgICBsb2FkX25vZGU6IGZ1bmN0aW9uIGxvYWRfbm9kZShvYmosIGNhbGxiYWNrKSB7XFxuICAgICAgdmFyIGssIGwsIGksIGosIGM7XFxuXFxuICAgICAgaWYgKCQuaXNBcnJheShvYmopKSB7XFxuICAgICAgICB0aGlzLl9sb2FkX25vZGVzKG9iai5zbGljZSgpLCBjYWxsYmFjayk7XFxuXFxuICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICB9XFxuXFxuICAgICAgb2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xcblxcbiAgICAgIGlmICghb2JqKSB7XFxuICAgICAgICBpZiAoY2FsbGJhY2spIHtcXG4gICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCBvYmosIGZhbHNlKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9IC8vIGlmKG9iai5zdGF0ZS5sb2FkaW5nKSB7IH0gLy8gdGhlIG5vZGUgaXMgYWxyZWFkeSBsb2FkaW5nIC0ganVzdCB3YWl0IGZvciBpdCB0byBsb2FkIGFuZCBpbnZva2UgY2FsbGJhY2s/IGJ1dCBpZiBjYWxsZWQgaW1wbGljaXRseSBpdCBzaG91bGQgYmUgbG9hZGVkIGFnYWluP1xcblxcblxcbiAgICAgIGlmIChvYmouc3RhdGUubG9hZGVkKSB7XFxuICAgICAgICBvYmouc3RhdGUubG9hZGVkID0gZmFsc2U7XFxuXFxuICAgICAgICBmb3IgKGkgPSAwLCBqID0gb2JqLnBhcmVudHMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICAgIHRoaXMuX21vZGVsLmRhdGFbb2JqLnBhcmVudHNbaV1dLmNoaWxkcmVuX2QgPSAkLnZha2F0YS5hcnJheV9maWx0ZXIodGhpcy5fbW9kZWwuZGF0YVtvYmoucGFyZW50c1tpXV0uY2hpbGRyZW5fZCwgZnVuY3Rpb24gKHYpIHtcXG4gICAgICAgICAgICByZXR1cm4gJC5pbkFycmF5KHYsIG9iai5jaGlsZHJlbl9kKSA9PT0gLTE7XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZm9yIChrID0gMCwgbCA9IG9iai5jaGlsZHJlbl9kLmxlbmd0aDsgayA8IGw7IGsrKykge1xcbiAgICAgICAgICBpZiAodGhpcy5fbW9kZWwuZGF0YVtvYmouY2hpbGRyZW5fZFtrXV0uc3RhdGUuc2VsZWN0ZWQpIHtcXG4gICAgICAgICAgICBjID0gdHJ1ZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBkZWxldGUgdGhpcy5fbW9kZWwuZGF0YVtvYmouY2hpbGRyZW5fZFtrXV07XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoYykge1xcbiAgICAgICAgICB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQgPSAkLnZha2F0YS5hcnJheV9maWx0ZXIodGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLCBmdW5jdGlvbiAodikge1xcbiAgICAgICAgICAgIHJldHVybiAkLmluQXJyYXkodiwgb2JqLmNoaWxkcmVuX2QpID09PSAtMTtcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBvYmouY2hpbGRyZW4gPSBbXTtcXG4gICAgICAgIG9iai5jaGlsZHJlbl9kID0gW107XFxuXFxuICAgICAgICBpZiAoYykge1xcbiAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZWQnLCB7XFxuICAgICAgICAgICAgJ2FjdGlvbic6ICdsb2FkX25vZGUnLFxcbiAgICAgICAgICAgICdub2RlJzogb2JqLFxcbiAgICAgICAgICAgICdzZWxlY3RlZCc6IHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZFxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgb2JqLnN0YXRlLmZhaWxlZCA9IGZhbHNlO1xcbiAgICAgIG9iai5zdGF0ZS5sb2FkaW5nID0gdHJ1ZTtcXG4gICAgICB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSkuYWRkQ2xhc3MoXFxcImpzdHJlZS1sb2FkaW5nXFxcIikuYXR0cignYXJpYS1idXN5JywgdHJ1ZSk7XFxuXFxuICAgICAgdGhpcy5fbG9hZF9ub2RlKG9iaiwgJC5wcm94eShmdW5jdGlvbiAoc3RhdHVzKSB7XFxuICAgICAgICBvYmogPSB0aGlzLl9tb2RlbC5kYXRhW29iai5pZF07XFxuICAgICAgICBvYmouc3RhdGUubG9hZGluZyA9IGZhbHNlO1xcbiAgICAgICAgb2JqLnN0YXRlLmxvYWRlZCA9IHN0YXR1cztcXG4gICAgICAgIG9iai5zdGF0ZS5mYWlsZWQgPSAhb2JqLnN0YXRlLmxvYWRlZDtcXG4gICAgICAgIHZhciBkb20gPSB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSksXFxuICAgICAgICAgICAgaSA9IDAsXFxuICAgICAgICAgICAgaiA9IDAsXFxuICAgICAgICAgICAgbSA9IHRoaXMuX21vZGVsLmRhdGEsXFxuICAgICAgICAgICAgaGFzX2NoaWxkcmVuID0gZmFsc2U7XFxuXFxuICAgICAgICBmb3IgKGkgPSAwLCBqID0gb2JqLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcbiAgICAgICAgICBpZiAobVtvYmouY2hpbGRyZW5baV1dICYmICFtW29iai5jaGlsZHJlbltpXV0uc3RhdGUuaGlkZGVuKSB7XFxuICAgICAgICAgICAgaGFzX2NoaWxkcmVuID0gdHJ1ZTtcXG4gICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKG9iai5zdGF0ZS5sb2FkZWQgJiYgZG9tICYmIGRvbS5sZW5ndGgpIHtcXG4gICAgICAgICAgZG9tLnJlbW92ZUNsYXNzKCdqc3RyZWUtY2xvc2VkIGpzdHJlZS1vcGVuIGpzdHJlZS1sZWFmJyk7XFxuXFxuICAgICAgICAgIGlmICghaGFzX2NoaWxkcmVuKSB7XFxuICAgICAgICAgICAgZG9tLmFkZENsYXNzKCdqc3RyZWUtbGVhZicpO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGlmIChvYmouaWQgIT09ICcjJykge1xcbiAgICAgICAgICAgICAgZG9tLmFkZENsYXNzKG9iai5zdGF0ZS5vcGVuZWQgPyAnanN0cmVlLW9wZW4nIDogJ2pzdHJlZS1jbG9zZWQnKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGRvbS5yZW1vdmVDbGFzcyhcXFwianN0cmVlLWxvYWRpbmdcXFwiKS5hdHRyKCdhcmlhLWJ1c3knLCBmYWxzZSk7XFxuICAgICAgICAvKipcXG4gICAgICAgICAqIHRyaWdnZXJlZCBhZnRlciBhIG5vZGUgaXMgbG9hZGVkXFxuICAgICAgICAgKiBAZXZlbnRcXG4gICAgICAgICAqIEBuYW1lIGxvYWRfbm9kZS5qc3RyZWVcXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIHRoZSBub2RlIHRoYXQgd2FzIGxvYWRpbmdcXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc3RhdHVzIHdhcyB0aGUgbm9kZSBsb2FkZWQgc3VjY2Vzc2Z1bGx5XFxuICAgICAgICAgKi9cXG5cXG4gICAgICAgIHRoaXMudHJpZ2dlcignbG9hZF9ub2RlJywge1xcbiAgICAgICAgICBcXFwibm9kZVxcXCI6IG9iaixcXG4gICAgICAgICAgXFxcInN0YXR1c1xcXCI6IHN0YXR1c1xcbiAgICAgICAgfSk7XFxuXFxuICAgICAgICBpZiAoY2FsbGJhY2spIHtcXG4gICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCBvYmosIHN0YXR1cyk7XFxuICAgICAgICB9XFxuICAgICAgfSwgdGhpcykpO1xcblxcbiAgICAgIHJldHVybiB0cnVlO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogbG9hZCBhbiBhcnJheSBvZiBub2RlcyAod2lsbCBhbHNvIGxvYWQgdW5hdmFpbGFibGUgbm9kZXMgYXMgc29vbiBhcyB0aGUgYXBwZWFyIGluIHRoZSBzdHJ1Y3R1cmUpLiBVc2VkIGludGVybmFsbHkuXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBuYW1lIF9sb2FkX25vZGVzKG5vZGVzIFssIGNhbGxiYWNrXSlcXG4gICAgICogQHBhcmFtICB7YXJyYXl9IG5vZGVzXFxuICAgICAqIEBwYXJhbSAge2Z1bmN0aW9ufSBjYWxsYmFjayBhIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIG9uY2UgbG9hZGluZyBpcyBjb21wbGV0ZSwgdGhlIGZ1bmN0aW9uIGlzIGV4ZWN1dGVkIGluIHRoZSBpbnN0YW5jZSdzIHNjb3BlIGFuZCByZWNlaXZlcyBvbmUgYXJndW1lbnQgLSB0aGUgYXJyYXkgcGFzc2VkIHRvIF9sb2FkX25vZGVzXFxuICAgICAqL1xcbiAgICBfbG9hZF9ub2RlczogZnVuY3Rpb24gX2xvYWRfbm9kZXMobm9kZXMsIGNhbGxiYWNrLCBpc19jYWxsYmFjaywgZm9yY2VfcmVsb2FkKSB7XFxuICAgICAgdmFyIHIgPSB0cnVlLFxcbiAgICAgICAgICBjID0gZnVuY3Rpb24gYygpIHtcXG4gICAgICAgIHRoaXMuX2xvYWRfbm9kZXMobm9kZXMsIGNhbGxiYWNrLCB0cnVlKTtcXG4gICAgICB9LFxcbiAgICAgICAgICBtID0gdGhpcy5fbW9kZWwuZGF0YSxcXG4gICAgICAgICAgaSxcXG4gICAgICAgICAgaixcXG4gICAgICAgICAgdG1wID0gW107XFxuXFxuICAgICAgZm9yIChpID0gMCwgaiA9IG5vZGVzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcbiAgICAgICAgaWYgKG1bbm9kZXNbaV1dICYmICghbVtub2Rlc1tpXV0uc3RhdGUubG9hZGVkICYmICFtW25vZGVzW2ldXS5zdGF0ZS5mYWlsZWQgfHwgIWlzX2NhbGxiYWNrICYmIGZvcmNlX3JlbG9hZCkpIHtcXG4gICAgICAgICAgaWYgKCF0aGlzLmlzX2xvYWRpbmcobm9kZXNbaV0pKSB7XFxuICAgICAgICAgICAgdGhpcy5sb2FkX25vZGUobm9kZXNbaV0sIGMpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHIgPSBmYWxzZTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHIpIHtcXG4gICAgICAgIGZvciAoaSA9IDAsIGogPSBub2Rlcy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG4gICAgICAgICAgaWYgKG1bbm9kZXNbaV1dICYmIG1bbm9kZXNbaV1dLnN0YXRlLmxvYWRlZCkge1xcbiAgICAgICAgICAgIHRtcC5wdXNoKG5vZGVzW2ldKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKGNhbGxiYWNrICYmICFjYWxsYmFjay5kb25lKSB7XFxuICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgdG1wKTtcXG4gICAgICAgICAgY2FsbGJhY2suZG9uZSA9IHRydWU7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogbG9hZHMgYWxsIHVubG9hZGVkIG5vZGVzXFxuICAgICAqIEBuYW1lIGxvYWRfYWxsKFtvYmosIGNhbGxiYWNrXSlcXG4gICAgICogQHBhcmFtIHttaXhlZH0gb2JqIHRoZSBub2RlIHRvIGxvYWQgcmVjdXJzaXZlbHksIG9taXQgdG8gbG9hZCBhbGwgbm9kZXMgaW4gdGhlIHRyZWVcXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgYSBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCBvbmNlIGxvYWRpbmcgYWxsIHRoZSBub2RlcyBpcyBjb21wbGV0ZSxcXG4gICAgICogQHRyaWdnZXIgbG9hZF9hbGwuanN0cmVlXFxuICAgICAqL1xcbiAgICBsb2FkX2FsbDogZnVuY3Rpb24gbG9hZF9hbGwob2JqLCBjYWxsYmFjaykge1xcbiAgICAgIGlmICghb2JqKSB7XFxuICAgICAgICBvYmogPSAkLmpzdHJlZS5yb290O1xcbiAgICAgIH1cXG5cXG4gICAgICBvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XFxuXFxuICAgICAgaWYgKCFvYmopIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIHRvX2xvYWQgPSBbXSxcXG4gICAgICAgICAgbSA9IHRoaXMuX21vZGVsLmRhdGEsXFxuICAgICAgICAgIGMgPSBtW29iai5pZF0uY2hpbGRyZW5fZCxcXG4gICAgICAgICAgaSxcXG4gICAgICAgICAgajtcXG5cXG4gICAgICBpZiAob2JqLnN0YXRlICYmICFvYmouc3RhdGUubG9hZGVkKSB7XFxuICAgICAgICB0b19sb2FkLnB1c2gob2JqLmlkKTtcXG4gICAgICB9XFxuXFxuICAgICAgZm9yIChpID0gMCwgaiA9IGMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICBpZiAobVtjW2ldXSAmJiBtW2NbaV1dLnN0YXRlICYmICFtW2NbaV1dLnN0YXRlLmxvYWRlZCkge1xcbiAgICAgICAgICB0b19sb2FkLnB1c2goY1tpXSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0b19sb2FkLmxlbmd0aCkge1xcbiAgICAgICAgdGhpcy5fbG9hZF9ub2Rlcyh0b19sb2FkLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHRoaXMubG9hZF9hbGwob2JqLCBjYWxsYmFjayk7XFxuICAgICAgICB9KTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgLyoqXFxuICAgICAgICAgKiB0cmlnZ2VyZWQgYWZ0ZXIgYSBsb2FkX2FsbCBjYWxsIGNvbXBsZXRlc1xcbiAgICAgICAgICogQGV2ZW50XFxuICAgICAgICAgKiBAbmFtZSBsb2FkX2FsbC5qc3RyZWVcXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIHRoZSByZWN1cnNpdmVseSBsb2FkZWQgbm9kZVxcbiAgICAgICAgICovXFxuICAgICAgICBpZiAoY2FsbGJhY2spIHtcXG4gICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCBvYmopO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdsb2FkX2FsbCcsIHtcXG4gICAgICAgICAgXFxcIm5vZGVcXFwiOiBvYmpcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIGhhbmRsZXMgdGhlIGFjdHVhbCBsb2FkaW5nIG9mIGEgbm9kZS4gVXNlZCBvbmx5IGludGVybmFsbHkuXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBuYW1lIF9sb2FkX25vZGUob2JqIFssIGNhbGxiYWNrXSlcXG4gICAgICogQHBhcmFtICB7bWl4ZWR9IG9ialxcbiAgICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gY2FsbGJhY2sgYSBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCBvbmNlIGxvYWRpbmcgaXMgY29tcGxldGUsIHRoZSBmdW5jdGlvbiBpcyBleGVjdXRlZCBpbiB0aGUgaW5zdGFuY2UncyBzY29wZSBhbmQgcmVjZWl2ZXMgb25lIGFyZ3VtZW50IC0gYSBib29sZWFuIHN0YXR1c1xcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxcbiAgICAgKi9cXG4gICAgX2xvYWRfbm9kZTogZnVuY3Rpb24gX2xvYWRfbm9kZShvYmosIGNhbGxiYWNrKSB7XFxuICAgICAgdmFyIHMgPSB0aGlzLnNldHRpbmdzLmNvcmUuZGF0YSxcXG4gICAgICAgICAgdDtcXG5cXG4gICAgICB2YXIgbm90VGV4dE9yQ29tbWVudE5vZGUgPSBmdW5jdGlvbiBub3RUZXh0T3JDb21tZW50Tm9kZSgpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVUeXBlICE9PSAzICYmIHRoaXMubm9kZVR5cGUgIT09IDg7XFxuICAgICAgfTsgLy8gdXNlIG9yaWdpbmFsIEhUTUxcXG5cXG5cXG4gICAgICBpZiAoIXMpIHtcXG4gICAgICAgIGlmIChvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcXG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGVuZF9odG1sX2RhdGEob2JqLCB0aGlzLl9kYXRhLmNvcmUub3JpZ2luYWxfY29udGFpbmVyX2h0bWwuY2xvbmUodHJ1ZSksIGZ1bmN0aW9uIChzdGF0dXMpIHtcXG4gICAgICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXMsIHN0YXR1cyk7XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwodGhpcywgZmFsc2UpO1xcbiAgICAgICAgfSAvLyByZXR1cm4gY2FsbGJhY2suY2FsbCh0aGlzLCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QgPyB0aGlzLl9hcHBlbmRfaHRtbF9kYXRhKG9iaiwgdGhpcy5fZGF0YS5jb3JlLm9yaWdpbmFsX2NvbnRhaW5lcl9odG1sLmNsb25lKHRydWUpKSA6IGZhbHNlKTtcXG5cXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCQuaXNGdW5jdGlvbihzKSkge1xcbiAgICAgICAgcmV0dXJuIHMuY2FsbCh0aGlzLCBvYmosICQucHJveHkoZnVuY3Rpb24gKGQpIHtcXG4gICAgICAgICAgaWYgKGQgPT09IGZhbHNlKSB7XFxuICAgICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCBmYWxzZSk7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgdGhpc1t0eXBlb2YgZCA9PT0gJ3N0cmluZycgPyAnX2FwcGVuZF9odG1sX2RhdGEnIDogJ19hcHBlbmRfanNvbl9kYXRhJ10ob2JqLCB0eXBlb2YgZCA9PT0gJ3N0cmluZycgPyAkKCQucGFyc2VIVE1MKGQpKS5maWx0ZXIobm90VGV4dE9yQ29tbWVudE5vZGUpIDogZCwgZnVuY3Rpb24gKHN0YXR1cykge1xcbiAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCBzdGF0dXMpO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICB9IC8vIHJldHVybiBkID09PSBmYWxzZSA/IGNhbGxiYWNrLmNhbGwodGhpcywgZmFsc2UpIDogY2FsbGJhY2suY2FsbCh0aGlzLCB0aGlzW3R5cGVvZiBkID09PSAnc3RyaW5nJyA/ICdfYXBwZW5kX2h0bWxfZGF0YScgOiAnX2FwcGVuZF9qc29uX2RhdGEnXShvYmosIHR5cGVvZiBkID09PSAnc3RyaW5nJyA/ICQoZCkgOiBkKSk7XFxuXFxuICAgICAgICB9LCB0aGlzKSk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChfdHlwZW9mKHMpID09PSAnb2JqZWN0Jykge1xcbiAgICAgICAgaWYgKHMudXJsKSB7XFxuICAgICAgICAgIHMgPSAkLmV4dGVuZCh0cnVlLCB7fSwgcyk7XFxuXFxuICAgICAgICAgIGlmICgkLmlzRnVuY3Rpb24ocy51cmwpKSB7XFxuICAgICAgICAgICAgcy51cmwgPSBzLnVybC5jYWxsKHRoaXMsIG9iaik7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaWYgKCQuaXNGdW5jdGlvbihzLmRhdGEpKSB7XFxuICAgICAgICAgICAgcy5kYXRhID0gcy5kYXRhLmNhbGwodGhpcywgb2JqKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICByZXR1cm4gJC5hamF4KHMpLmRvbmUoJC5wcm94eShmdW5jdGlvbiAoZCwgdCwgeCkge1xcbiAgICAgICAgICAgIHZhciB0eXBlID0geC5nZXRSZXNwb25zZUhlYWRlcignQ29udGVudC1UeXBlJyk7XFxuXFxuICAgICAgICAgICAgaWYgKHR5cGUgJiYgdHlwZS5pbmRleE9mKCdqc29uJykgIT09IC0xIHx8IF90eXBlb2YoZCkgPT09IFxcXCJvYmplY3RcXFwiKSB7XFxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYXBwZW5kX2pzb25fZGF0YShvYmosIGQsIGZ1bmN0aW9uIChzdGF0dXMpIHtcXG4gICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCBzdGF0dXMpO1xcbiAgICAgICAgICAgICAgfSk7IC8vcmV0dXJuIGNhbGxiYWNrLmNhbGwodGhpcywgdGhpcy5fYXBwZW5kX2pzb25fZGF0YShvYmosIGQpKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaWYgKHR5cGUgJiYgdHlwZS5pbmRleE9mKCdodG1sJykgIT09IC0xIHx8IHR5cGVvZiBkID09PSBcXFwic3RyaW5nXFxcIikge1xcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGVuZF9odG1sX2RhdGEob2JqLCAkKCQucGFyc2VIVE1MKGQpKS5maWx0ZXIobm90VGV4dE9yQ29tbWVudE5vZGUpLCBmdW5jdGlvbiAoc3RhdHVzKSB7XFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgc3RhdHVzKTtcXG4gICAgICAgICAgICAgIH0pOyAvLyByZXR1cm4gY2FsbGJhY2suY2FsbCh0aGlzLCB0aGlzLl9hcHBlbmRfaHRtbF9kYXRhKG9iaiwgJChkKSkpO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICB0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvciA9IHtcXG4gICAgICAgICAgICAgICdlcnJvcic6ICdhamF4JyxcXG4gICAgICAgICAgICAgICdwbHVnaW4nOiAnY29yZScsXFxuICAgICAgICAgICAgICAnaWQnOiAnY29yZV8wNCcsXFxuICAgICAgICAgICAgICAncmVhc29uJzogJ0NvdWxkIG5vdCBsb2FkIG5vZGUnLFxcbiAgICAgICAgICAgICAgJ2RhdGEnOiBKU09OLnN0cmluZ2lmeSh7XFxuICAgICAgICAgICAgICAgICdpZCc6IG9iai5pZCxcXG4gICAgICAgICAgICAgICAgJ3hocic6IHhcXG4gICAgICAgICAgICAgIH0pXFxuICAgICAgICAgICAgfTtcXG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzLmNvcmUuZXJyb3IuY2FsbCh0aGlzLCB0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvcik7XFxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwodGhpcywgZmFsc2UpO1xcbiAgICAgICAgICB9LCB0aGlzKSkuZmFpbCgkLnByb3h5KGZ1bmN0aW9uIChmKSB7XFxuICAgICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCBmYWxzZSk7XFxuICAgICAgICAgICAgdGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IgPSB7XFxuICAgICAgICAgICAgICAnZXJyb3InOiAnYWpheCcsXFxuICAgICAgICAgICAgICAncGx1Z2luJzogJ2NvcmUnLFxcbiAgICAgICAgICAgICAgJ2lkJzogJ2NvcmVfMDQnLFxcbiAgICAgICAgICAgICAgJ3JlYXNvbic6ICdDb3VsZCBub3QgbG9hZCBub2RlJyxcXG4gICAgICAgICAgICAgICdkYXRhJzogSlNPTi5zdHJpbmdpZnkoe1xcbiAgICAgICAgICAgICAgICAnaWQnOiBvYmouaWQsXFxuICAgICAgICAgICAgICAgICd4aHInOiBmXFxuICAgICAgICAgICAgICB9KVxcbiAgICAgICAgICAgIH07XFxuICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5jb3JlLmVycm9yLmNhbGwodGhpcywgdGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IpO1xcbiAgICAgICAgICB9LCB0aGlzKSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0ID0gJC5pc0FycmF5KHMpIHx8ICQuaXNQbGFpbk9iamVjdChzKSA/IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocykpIDogcztcXG5cXG4gICAgICAgIGlmIChvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcXG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGVuZF9qc29uX2RhdGEob2JqLCB0LCBmdW5jdGlvbiAoc3RhdHVzKSB7XFxuICAgICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCBzdGF0dXMpO1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yID0ge1xcbiAgICAgICAgICAgICdlcnJvcic6ICdub2RhdGEnLFxcbiAgICAgICAgICAgICdwbHVnaW4nOiAnY29yZScsXFxuICAgICAgICAgICAgJ2lkJzogJ2NvcmVfMDUnLFxcbiAgICAgICAgICAgICdyZWFzb24nOiAnQ291bGQgbm90IGxvYWQgbm9kZScsXFxuICAgICAgICAgICAgJ2RhdGEnOiBKU09OLnN0cmluZ2lmeSh7XFxuICAgICAgICAgICAgICAnaWQnOiBvYmouaWRcXG4gICAgICAgICAgICB9KVxcbiAgICAgICAgICB9O1xcbiAgICAgICAgICB0aGlzLnNldHRpbmdzLmNvcmUuZXJyb3IuY2FsbCh0aGlzLCB0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvcik7XFxuICAgICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHRoaXMsIGZhbHNlKTtcXG4gICAgICAgIH0gLy9yZXR1cm4gY2FsbGJhY2suY2FsbCh0aGlzLCAob2JqLmlkID09PSAkLmpzdHJlZS5yb290ID8gdGhpcy5fYXBwZW5kX2pzb25fZGF0YShvYmosIHQpIDogZmFsc2UpICk7XFxuXFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0eXBlb2YgcyA9PT0gJ3N0cmluZycpIHtcXG4gICAgICAgIGlmIChvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcXG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGVuZF9odG1sX2RhdGEob2JqLCAkKCQucGFyc2VIVE1MKHMpKS5maWx0ZXIobm90VGV4dE9yQ29tbWVudE5vZGUpLCBmdW5jdGlvbiAoc3RhdHVzKSB7XFxuICAgICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCBzdGF0dXMpO1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yID0ge1xcbiAgICAgICAgICAgICdlcnJvcic6ICdub2RhdGEnLFxcbiAgICAgICAgICAgICdwbHVnaW4nOiAnY29yZScsXFxuICAgICAgICAgICAgJ2lkJzogJ2NvcmVfMDYnLFxcbiAgICAgICAgICAgICdyZWFzb24nOiAnQ291bGQgbm90IGxvYWQgbm9kZScsXFxuICAgICAgICAgICAgJ2RhdGEnOiBKU09OLnN0cmluZ2lmeSh7XFxuICAgICAgICAgICAgICAnaWQnOiBvYmouaWRcXG4gICAgICAgICAgICB9KVxcbiAgICAgICAgICB9O1xcbiAgICAgICAgICB0aGlzLnNldHRpbmdzLmNvcmUuZXJyb3IuY2FsbCh0aGlzLCB0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvcik7XFxuICAgICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHRoaXMsIGZhbHNlKTtcXG4gICAgICAgIH0gLy9yZXR1cm4gY2FsbGJhY2suY2FsbCh0aGlzLCAob2JqLmlkID09PSAkLmpzdHJlZS5yb290ID8gdGhpcy5fYXBwZW5kX2h0bWxfZGF0YShvYmosICQocykpIDogZmFsc2UpICk7XFxuXFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHRoaXMsIGZhbHNlKTtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIGFkZHMgYSBub2RlIHRvIHRoZSBsaXN0IG9mIG5vZGVzIHRvIHJlZHJhdy4gVXNlZCBvbmx5IGludGVybmFsbHkuXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBuYW1lIF9ub2RlX2NoYW5nZWQob2JqIFssIGNhbGxiYWNrXSlcXG4gICAgICogQHBhcmFtICB7bWl4ZWR9IG9ialxcbiAgICAgKi9cXG4gICAgX25vZGVfY2hhbmdlZDogZnVuY3Rpb24gX25vZGVfY2hhbmdlZChvYmopIHtcXG4gICAgICBvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XFxuXFxuICAgICAgaWYgKG9iaikge1xcbiAgICAgICAgdGhpcy5fbW9kZWwuY2hhbmdlZC5wdXNoKG9iai5pZCk7XFxuICAgICAgfVxcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogYXBwZW5kcyBIVE1MIGNvbnRlbnQgdG8gdGhlIHRyZWUuIFVzZWQgaW50ZXJuYWxseS5cXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQG5hbWUgX2FwcGVuZF9odG1sX2RhdGEob2JqLCBkYXRhKVxcbiAgICAgKiBAcGFyYW0gIHttaXhlZH0gb2JqIHRoZSBub2RlIHRvIGFwcGVuZCB0b1xcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGRhdGEgdGhlIEhUTUwgc3RyaW5nIHRvIHBhcnNlIGFuZCBhcHBlbmRcXG4gICAgICogQHRyaWdnZXIgbW9kZWwuanN0cmVlLCBjaGFuZ2VkLmpzdHJlZVxcbiAgICAgKi9cXG4gICAgX2FwcGVuZF9odG1sX2RhdGE6IGZ1bmN0aW9uIF9hcHBlbmRfaHRtbF9kYXRhKGRvbSwgZGF0YSwgY2IpIHtcXG4gICAgICBkb20gPSB0aGlzLmdldF9ub2RlKGRvbSk7XFxuICAgICAgZG9tLmNoaWxkcmVuID0gW107XFxuICAgICAgZG9tLmNoaWxkcmVuX2QgPSBbXTtcXG4gICAgICB2YXIgZGF0ID0gZGF0YS5pcygndWwnKSA/IGRhdGEuY2hpbGRyZW4oKSA6IGRhdGEsXFxuICAgICAgICAgIHBhciA9IGRvbS5pZCxcXG4gICAgICAgICAgY2hkID0gW10sXFxuICAgICAgICAgIGRwYyA9IFtdLFxcbiAgICAgICAgICBtID0gdGhpcy5fbW9kZWwuZGF0YSxcXG4gICAgICAgICAgcCA9IG1bcGFyXSxcXG4gICAgICAgICAgcyA9IHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZC5sZW5ndGgsXFxuICAgICAgICAgIHRtcCxcXG4gICAgICAgICAgaSxcXG4gICAgICAgICAgajtcXG4gICAgICBkYXQuZWFjaCgkLnByb3h5KGZ1bmN0aW9uIChpLCB2KSB7XFxuICAgICAgICB0bXAgPSB0aGlzLl9wYXJzZV9tb2RlbF9mcm9tX2h0bWwoJCh2KSwgcGFyLCBwLnBhcmVudHMuY29uY2F0KCkpO1xcblxcbiAgICAgICAgaWYgKHRtcCkge1xcbiAgICAgICAgICBjaGQucHVzaCh0bXApO1xcbiAgICAgICAgICBkcGMucHVzaCh0bXApO1xcblxcbiAgICAgICAgICBpZiAobVt0bXBdLmNoaWxkcmVuX2QubGVuZ3RoKSB7XFxuICAgICAgICAgICAgZHBjID0gZHBjLmNvbmNhdChtW3RtcF0uY2hpbGRyZW5fZCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9LCB0aGlzKSk7XFxuICAgICAgcC5jaGlsZHJlbiA9IGNoZDtcXG4gICAgICBwLmNoaWxkcmVuX2QgPSBkcGM7XFxuXFxuICAgICAgZm9yIChpID0gMCwgaiA9IHAucGFyZW50cy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG4gICAgICAgIG1bcC5wYXJlbnRzW2ldXS5jaGlsZHJlbl9kID0gbVtwLnBhcmVudHNbaV1dLmNoaWxkcmVuX2QuY29uY2F0KGRwYyk7XFxuICAgICAgfVxcbiAgICAgIC8qKlxcbiAgICAgICAqIHRyaWdnZXJlZCB3aGVuIG5ldyBkYXRhIGlzIGluc2VydGVkIHRvIHRoZSB0cmVlIG1vZGVsXFxuICAgICAgICogQGV2ZW50XFxuICAgICAgICogQG5hbWUgbW9kZWwuanN0cmVlXFxuICAgICAgICogQHBhcmFtIHtBcnJheX0gbm9kZXMgYW4gYXJyYXkgb2Ygbm9kZSBJRHNcXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyZW50IHRoZSBwYXJlbnQgSUQgb2YgdGhlIG5vZGVzXFxuICAgICAgICovXFxuXFxuXFxuICAgICAgdGhpcy50cmlnZ2VyKCdtb2RlbCcsIHtcXG4gICAgICAgIFxcXCJub2Rlc1xcXCI6IGRwYyxcXG4gICAgICAgICdwYXJlbnQnOiBwYXJcXG4gICAgICB9KTtcXG5cXG4gICAgICBpZiAocGFyICE9PSAkLmpzdHJlZS5yb290KSB7XFxuICAgICAgICB0aGlzLl9ub2RlX2NoYW5nZWQocGFyKTtcXG5cXG4gICAgICAgIHRoaXMucmVkcmF3KCk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpLmNoaWxkcmVuKCcuanN0cmVlLWluaXRpYWwtbm9kZScpLnJlbW92ZSgpO1xcbiAgICAgICAgdGhpcy5yZWRyYXcodHJ1ZSk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQubGVuZ3RoICE9PSBzKSB7XFxuICAgICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZWQnLCB7XFxuICAgICAgICAgICdhY3Rpb24nOiAnbW9kZWwnLFxcbiAgICAgICAgICAnc2VsZWN0ZWQnOiB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWRcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG5cXG4gICAgICBjYi5jYWxsKHRoaXMsIHRydWUpO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogYXBwZW5kcyBKU09OIGNvbnRlbnQgdG8gdGhlIHRyZWUuIFVzZWQgaW50ZXJuYWxseS5cXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQG5hbWUgX2FwcGVuZF9qc29uX2RhdGEob2JqLCBkYXRhKVxcbiAgICAgKiBAcGFyYW0gIHttaXhlZH0gb2JqIHRoZSBub2RlIHRvIGFwcGVuZCB0b1xcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGRhdGEgdGhlIEpTT04gb2JqZWN0IHRvIHBhcnNlIGFuZCBhcHBlbmRcXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gZm9yY2VfcHJvY2Vzc2luZyBpbnRlcm5hbCBwYXJhbSAtIGRvIG5vdCBzZXRcXG4gICAgICogQHRyaWdnZXIgbW9kZWwuanN0cmVlLCBjaGFuZ2VkLmpzdHJlZVxcbiAgICAgKi9cXG4gICAgX2FwcGVuZF9qc29uX2RhdGE6IGZ1bmN0aW9uIF9hcHBlbmRfanNvbl9kYXRhKGRvbSwgZGF0YSwgY2IsIGZvcmNlX3Byb2Nlc3NpbmcpIHtcXG4gICAgICBpZiAodGhpcy5lbGVtZW50ID09PSBudWxsKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGRvbSA9IHRoaXMuZ2V0X25vZGUoZG9tKTtcXG4gICAgICBkb20uY2hpbGRyZW4gPSBbXTtcXG4gICAgICBkb20uY2hpbGRyZW5fZCA9IFtdOyAvLyAqJSRAISEhXFxuXFxuICAgICAgaWYgKGRhdGEuZCkge1xcbiAgICAgICAgZGF0YSA9IGRhdGEuZDtcXG5cXG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXFxcInN0cmluZ1xcXCIpIHtcXG4gICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghJC5pc0FycmF5KGRhdGEpKSB7XFxuICAgICAgICBkYXRhID0gW2RhdGFdO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgdyA9IG51bGwsXFxuICAgICAgICAgIGFyZ3MgPSB7XFxuICAgICAgICAnZGYnOiB0aGlzLl9tb2RlbC5kZWZhdWx0X3N0YXRlLFxcbiAgICAgICAgJ2RhdCc6IGRhdGEsXFxuICAgICAgICAncGFyJzogZG9tLmlkLFxcbiAgICAgICAgJ20nOiB0aGlzLl9tb2RlbC5kYXRhLFxcbiAgICAgICAgJ3RfaWQnOiB0aGlzLl9pZCxcXG4gICAgICAgICd0X2NudCc6IHRoaXMuX2NudCxcXG4gICAgICAgICdzZWwnOiB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWRcXG4gICAgICB9LFxcbiAgICAgICAgICBmdW5jID0gZnVuY3Rpb24gZnVuYyhkYXRhLCB1bmRlZmluZWQpIHtcXG4gICAgICAgIGlmIChkYXRhLmRhdGEpIHtcXG4gICAgICAgICAgZGF0YSA9IGRhdGEuZGF0YTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHZhciBkYXQgPSBkYXRhLmRhdCxcXG4gICAgICAgICAgICBwYXIgPSBkYXRhLnBhcixcXG4gICAgICAgICAgICBjaGQgPSBbXSxcXG4gICAgICAgICAgICBkcGMgPSBbXSxcXG4gICAgICAgICAgICBhZGQgPSBbXSxcXG4gICAgICAgICAgICBkZiA9IGRhdGEuZGYsXFxuICAgICAgICAgICAgdF9pZCA9IGRhdGEudF9pZCxcXG4gICAgICAgICAgICB0X2NudCA9IGRhdGEudF9jbnQsXFxuICAgICAgICAgICAgbSA9IGRhdGEubSxcXG4gICAgICAgICAgICBwID0gbVtwYXJdLFxcbiAgICAgICAgICAgIHNlbCA9IGRhdGEuc2VsLFxcbiAgICAgICAgICAgIHRtcCxcXG4gICAgICAgICAgICBpLFxcbiAgICAgICAgICAgIGosXFxuICAgICAgICAgICAgcnNsdCxcXG4gICAgICAgICAgICBwYXJzZV9mbGF0ID0gZnVuY3Rpb24gcGFyc2VfZmxhdChkLCBwLCBwcykge1xcbiAgICAgICAgICBpZiAoIXBzKSB7XFxuICAgICAgICAgICAgcHMgPSBbXTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBwcyA9IHBzLmNvbmNhdCgpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmIChwKSB7XFxuICAgICAgICAgICAgcHMudW5zaGlmdChwKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICB2YXIgdGlkID0gZC5pZC50b1N0cmluZygpLFxcbiAgICAgICAgICAgICAgaSxcXG4gICAgICAgICAgICAgIGosXFxuICAgICAgICAgICAgICBjLFxcbiAgICAgICAgICAgICAgZSxcXG4gICAgICAgICAgICAgIHRtcCA9IHtcXG4gICAgICAgICAgICBpZDogdGlkLFxcbiAgICAgICAgICAgIHRleHQ6IGQudGV4dCB8fCAnJyxcXG4gICAgICAgICAgICBpY29uOiBkLmljb24gIT09IHVuZGVmaW5lZCA/IGQuaWNvbiA6IHRydWUsXFxuICAgICAgICAgICAgcGFyZW50OiBwLFxcbiAgICAgICAgICAgIHBhcmVudHM6IHBzLFxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBkLmNoaWxkcmVuIHx8IFtdLFxcbiAgICAgICAgICAgIGNoaWxkcmVuX2Q6IGQuY2hpbGRyZW5fZCB8fCBbXSxcXG4gICAgICAgICAgICBkYXRhOiBkLmRhdGEsXFxuICAgICAgICAgICAgc3RhdGU6IHt9LFxcbiAgICAgICAgICAgIGxpX2F0dHI6IHtcXG4gICAgICAgICAgICAgIGlkOiBmYWxzZVxcbiAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgYV9hdHRyOiB7XFxuICAgICAgICAgICAgICBocmVmOiAnIydcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIG9yaWdpbmFsOiBmYWxzZVxcbiAgICAgICAgICB9O1xcblxcbiAgICAgICAgICBmb3IgKGkgaW4gZGYpIHtcXG4gICAgICAgICAgICBpZiAoZGYuaGFzT3duUHJvcGVydHkoaSkpIHtcXG4gICAgICAgICAgICAgIHRtcC5zdGF0ZVtpXSA9IGRmW2ldO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAoZCAmJiBkLmRhdGEgJiYgZC5kYXRhLmpzdHJlZSAmJiBkLmRhdGEuanN0cmVlLmljb24pIHtcXG4gICAgICAgICAgICB0bXAuaWNvbiA9IGQuZGF0YS5qc3RyZWUuaWNvbjtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAodG1wLmljb24gPT09IHVuZGVmaW5lZCB8fCB0bXAuaWNvbiA9PT0gbnVsbCB8fCB0bXAuaWNvbiA9PT0gXFxcIlxcXCIpIHtcXG4gICAgICAgICAgICB0bXAuaWNvbiA9IHRydWU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaWYgKGQgJiYgZC5kYXRhKSB7XFxuICAgICAgICAgICAgdG1wLmRhdGEgPSBkLmRhdGE7XFxuXFxuICAgICAgICAgICAgaWYgKGQuZGF0YS5qc3RyZWUpIHtcXG4gICAgICAgICAgICAgIGZvciAoaSBpbiBkLmRhdGEuanN0cmVlKSB7XFxuICAgICAgICAgICAgICAgIGlmIChkLmRhdGEuanN0cmVlLmhhc093blByb3BlcnR5KGkpKSB7XFxuICAgICAgICAgICAgICAgICAgdG1wLnN0YXRlW2ldID0gZC5kYXRhLmpzdHJlZVtpXTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAoZCAmJiBfdHlwZW9mKGQuc3RhdGUpID09PSAnb2JqZWN0Jykge1xcbiAgICAgICAgICAgIGZvciAoaSBpbiBkLnN0YXRlKSB7XFxuICAgICAgICAgICAgICBpZiAoZC5zdGF0ZS5oYXNPd25Qcm9wZXJ0eShpKSkge1xcbiAgICAgICAgICAgICAgICB0bXAuc3RhdGVbaV0gPSBkLnN0YXRlW2ldO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAoZCAmJiBfdHlwZW9mKGQubGlfYXR0cikgPT09ICdvYmplY3QnKSB7XFxuICAgICAgICAgICAgZm9yIChpIGluIGQubGlfYXR0cikge1xcbiAgICAgICAgICAgICAgaWYgKGQubGlfYXR0ci5oYXNPd25Qcm9wZXJ0eShpKSkge1xcbiAgICAgICAgICAgICAgICB0bXAubGlfYXR0cltpXSA9IGQubGlfYXR0cltpXTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaWYgKCF0bXAubGlfYXR0ci5pZCkge1xcbiAgICAgICAgICAgIHRtcC5saV9hdHRyLmlkID0gdGlkO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmIChkICYmIF90eXBlb2YoZC5hX2F0dHIpID09PSAnb2JqZWN0Jykge1xcbiAgICAgICAgICAgIGZvciAoaSBpbiBkLmFfYXR0cikge1xcbiAgICAgICAgICAgICAgaWYgKGQuYV9hdHRyLmhhc093blByb3BlcnR5KGkpKSB7XFxuICAgICAgICAgICAgICAgIHRtcC5hX2F0dHJbaV0gPSBkLmFfYXR0cltpXTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaWYgKGQgJiYgZC5jaGlsZHJlbiAmJiBkLmNoaWxkcmVuID09PSB0cnVlKSB7XFxuICAgICAgICAgICAgdG1wLnN0YXRlLmxvYWRlZCA9IGZhbHNlO1xcbiAgICAgICAgICAgIHRtcC5jaGlsZHJlbiA9IFtdO1xcbiAgICAgICAgICAgIHRtcC5jaGlsZHJlbl9kID0gW107XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgbVt0bXAuaWRdID0gdG1wO1xcblxcbiAgICAgICAgICBmb3IgKGkgPSAwLCBqID0gdG1wLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcbiAgICAgICAgICAgIGMgPSBwYXJzZV9mbGF0KG1bdG1wLmNoaWxkcmVuW2ldXSwgdG1wLmlkLCBwcyk7XFxuICAgICAgICAgICAgZSA9IG1bY107XFxuICAgICAgICAgICAgdG1wLmNoaWxkcmVuX2QucHVzaChjKTtcXG5cXG4gICAgICAgICAgICBpZiAoZS5jaGlsZHJlbl9kLmxlbmd0aCkge1xcbiAgICAgICAgICAgICAgdG1wLmNoaWxkcmVuX2QgPSB0bXAuY2hpbGRyZW5fZC5jb25jYXQoZS5jaGlsZHJlbl9kKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZGVsZXRlIGQuZGF0YTtcXG4gICAgICAgICAgZGVsZXRlIGQuY2hpbGRyZW47XFxuICAgICAgICAgIG1bdG1wLmlkXS5vcmlnaW5hbCA9IGQ7XFxuXFxuICAgICAgICAgIGlmICh0bXAuc3RhdGUuc2VsZWN0ZWQpIHtcXG4gICAgICAgICAgICBhZGQucHVzaCh0bXAuaWQpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHJldHVybiB0bXAuaWQ7XFxuICAgICAgICB9LFxcbiAgICAgICAgICAgIHBhcnNlX25lc3QgPSBmdW5jdGlvbiBwYXJzZV9uZXN0KGQsIHAsIHBzKSB7XFxuICAgICAgICAgIGlmICghcHMpIHtcXG4gICAgICAgICAgICBwcyA9IFtdO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHBzID0gcHMuY29uY2F0KCk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaWYgKHApIHtcXG4gICAgICAgICAgICBwcy51bnNoaWZ0KHApO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHZhciB0aWQgPSBmYWxzZSxcXG4gICAgICAgICAgICAgIGksXFxuICAgICAgICAgICAgICBqLFxcbiAgICAgICAgICAgICAgYyxcXG4gICAgICAgICAgICAgIGUsXFxuICAgICAgICAgICAgICB0bXA7XFxuXFxuICAgICAgICAgIGRvIHtcXG4gICAgICAgICAgICB0aWQgPSAnaicgKyB0X2lkICsgJ18nICsgKyt0X2NudDtcXG4gICAgICAgICAgfSB3aGlsZSAobVt0aWRdKTtcXG5cXG4gICAgICAgICAgdG1wID0ge1xcbiAgICAgICAgICAgIGlkOiBmYWxzZSxcXG4gICAgICAgICAgICB0ZXh0OiB0eXBlb2YgZCA9PT0gJ3N0cmluZycgPyBkIDogJycsXFxuICAgICAgICAgICAgaWNvbjogX3R5cGVvZihkKSA9PT0gJ29iamVjdCcgJiYgZC5pY29uICE9PSB1bmRlZmluZWQgPyBkLmljb24gOiB0cnVlLFxcbiAgICAgICAgICAgIHBhcmVudDogcCxcXG4gICAgICAgICAgICBwYXJlbnRzOiBwcyxcXG4gICAgICAgICAgICBjaGlsZHJlbjogW10sXFxuICAgICAgICAgICAgY2hpbGRyZW5fZDogW10sXFxuICAgICAgICAgICAgZGF0YTogbnVsbCxcXG4gICAgICAgICAgICBzdGF0ZToge30sXFxuICAgICAgICAgICAgbGlfYXR0cjoge1xcbiAgICAgICAgICAgICAgaWQ6IGZhbHNlXFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICBhX2F0dHI6IHtcXG4gICAgICAgICAgICAgIGhyZWY6ICcjJ1xcbiAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgb3JpZ2luYWw6IGZhbHNlXFxuICAgICAgICAgIH07XFxuXFxuICAgICAgICAgIGZvciAoaSBpbiBkZikge1xcbiAgICAgICAgICAgIGlmIChkZi5oYXNPd25Qcm9wZXJ0eShpKSkge1xcbiAgICAgICAgICAgICAgdG1wLnN0YXRlW2ldID0gZGZbaV07XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmIChkICYmIGQuaWQpIHtcXG4gICAgICAgICAgICB0bXAuaWQgPSBkLmlkLnRvU3RyaW5nKCk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaWYgKGQgJiYgZC50ZXh0KSB7XFxuICAgICAgICAgICAgdG1wLnRleHQgPSBkLnRleHQ7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaWYgKGQgJiYgZC5kYXRhICYmIGQuZGF0YS5qc3RyZWUgJiYgZC5kYXRhLmpzdHJlZS5pY29uKSB7XFxuICAgICAgICAgICAgdG1wLmljb24gPSBkLmRhdGEuanN0cmVlLmljb247XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaWYgKHRtcC5pY29uID09PSB1bmRlZmluZWQgfHwgdG1wLmljb24gPT09IG51bGwgfHwgdG1wLmljb24gPT09IFxcXCJcXFwiKSB7XFxuICAgICAgICAgICAgdG1wLmljb24gPSB0cnVlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmIChkICYmIGQuZGF0YSkge1xcbiAgICAgICAgICAgIHRtcC5kYXRhID0gZC5kYXRhO1xcblxcbiAgICAgICAgICAgIGlmIChkLmRhdGEuanN0cmVlKSB7XFxuICAgICAgICAgICAgICBmb3IgKGkgaW4gZC5kYXRhLmpzdHJlZSkge1xcbiAgICAgICAgICAgICAgICBpZiAoZC5kYXRhLmpzdHJlZS5oYXNPd25Qcm9wZXJ0eShpKSkge1xcbiAgICAgICAgICAgICAgICAgIHRtcC5zdGF0ZVtpXSA9IGQuZGF0YS5qc3RyZWVbaV07XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaWYgKGQgJiYgX3R5cGVvZihkLnN0YXRlKSA9PT0gJ29iamVjdCcpIHtcXG4gICAgICAgICAgICBmb3IgKGkgaW4gZC5zdGF0ZSkge1xcbiAgICAgICAgICAgICAgaWYgKGQuc3RhdGUuaGFzT3duUHJvcGVydHkoaSkpIHtcXG4gICAgICAgICAgICAgICAgdG1wLnN0YXRlW2ldID0gZC5zdGF0ZVtpXTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaWYgKGQgJiYgX3R5cGVvZihkLmxpX2F0dHIpID09PSAnb2JqZWN0Jykge1xcbiAgICAgICAgICAgIGZvciAoaSBpbiBkLmxpX2F0dHIpIHtcXG4gICAgICAgICAgICAgIGlmIChkLmxpX2F0dHIuaGFzT3duUHJvcGVydHkoaSkpIHtcXG4gICAgICAgICAgICAgICAgdG1wLmxpX2F0dHJbaV0gPSBkLmxpX2F0dHJbaV07XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmICh0bXAubGlfYXR0ci5pZCAmJiAhdG1wLmlkKSB7XFxuICAgICAgICAgICAgdG1wLmlkID0gdG1wLmxpX2F0dHIuaWQudG9TdHJpbmcoKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAoIXRtcC5pZCkge1xcbiAgICAgICAgICAgIHRtcC5pZCA9IHRpZDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAoIXRtcC5saV9hdHRyLmlkKSB7XFxuICAgICAgICAgICAgdG1wLmxpX2F0dHIuaWQgPSB0bXAuaWQ7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaWYgKGQgJiYgX3R5cGVvZihkLmFfYXR0cikgPT09ICdvYmplY3QnKSB7XFxuICAgICAgICAgICAgZm9yIChpIGluIGQuYV9hdHRyKSB7XFxuICAgICAgICAgICAgICBpZiAoZC5hX2F0dHIuaGFzT3duUHJvcGVydHkoaSkpIHtcXG4gICAgICAgICAgICAgICAgdG1wLmFfYXR0cltpXSA9IGQuYV9hdHRyW2ldO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAoZCAmJiBkLmNoaWxkcmVuICYmIGQuY2hpbGRyZW4ubGVuZ3RoKSB7XFxuICAgICAgICAgICAgZm9yIChpID0gMCwgaiA9IGQuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICAgICAgICBjID0gcGFyc2VfbmVzdChkLmNoaWxkcmVuW2ldLCB0bXAuaWQsIHBzKTtcXG4gICAgICAgICAgICAgIGUgPSBtW2NdO1xcbiAgICAgICAgICAgICAgdG1wLmNoaWxkcmVuLnB1c2goYyk7XFxuXFxuICAgICAgICAgICAgICBpZiAoZS5jaGlsZHJlbl9kLmxlbmd0aCkge1xcbiAgICAgICAgICAgICAgICB0bXAuY2hpbGRyZW5fZCA9IHRtcC5jaGlsZHJlbl9kLmNvbmNhdChlLmNoaWxkcmVuX2QpO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICB0bXAuY2hpbGRyZW5fZCA9IHRtcC5jaGlsZHJlbl9kLmNvbmNhdCh0bXAuY2hpbGRyZW4pO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmIChkICYmIGQuY2hpbGRyZW4gJiYgZC5jaGlsZHJlbiA9PT0gdHJ1ZSkge1xcbiAgICAgICAgICAgIHRtcC5zdGF0ZS5sb2FkZWQgPSBmYWxzZTtcXG4gICAgICAgICAgICB0bXAuY2hpbGRyZW4gPSBbXTtcXG4gICAgICAgICAgICB0bXAuY2hpbGRyZW5fZCA9IFtdO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGRlbGV0ZSBkLmRhdGE7XFxuICAgICAgICAgIGRlbGV0ZSBkLmNoaWxkcmVuO1xcbiAgICAgICAgICB0bXAub3JpZ2luYWwgPSBkO1xcbiAgICAgICAgICBtW3RtcC5pZF0gPSB0bXA7XFxuXFxuICAgICAgICAgIGlmICh0bXAuc3RhdGUuc2VsZWN0ZWQpIHtcXG4gICAgICAgICAgICBhZGQucHVzaCh0bXAuaWQpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHJldHVybiB0bXAuaWQ7XFxuICAgICAgICB9O1xcblxcbiAgICAgICAgaWYgKGRhdC5sZW5ndGggJiYgZGF0WzBdLmlkICE9PSB1bmRlZmluZWQgJiYgZGF0WzBdLnBhcmVudCAhPT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgIC8vIEZsYXQgSlNPTiBzdXBwb3J0IChmb3IgZWFzeSBpbXBvcnQgZnJvbSBEQik6XFxuICAgICAgICAgIC8vIDEpIGNvbnZlcnQgdG8gb2JqZWN0IChmb3JlYWNoKVxcbiAgICAgICAgICBmb3IgKGkgPSAwLCBqID0gZGF0Lmxlbmd0aDsgaSA8IGo7IGkrKykge1xcbiAgICAgICAgICAgIGlmICghZGF0W2ldLmNoaWxkcmVuKSB7XFxuICAgICAgICAgICAgICBkYXRbaV0uY2hpbGRyZW4gPSBbXTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgbVtkYXRbaV0uaWQudG9TdHJpbmcoKV0gPSBkYXRbaV07XFxuICAgICAgICAgIH0gLy8gMikgcG9wdWxhdGUgY2hpbGRyZW4gKGZvcmVhY2gpXFxuXFxuXFxuICAgICAgICAgIGZvciAoaSA9IDAsIGogPSBkYXQubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICAgICAgbVtkYXRbaV0ucGFyZW50LnRvU3RyaW5nKCldLmNoaWxkcmVuLnB1c2goZGF0W2ldLmlkLnRvU3RyaW5nKCkpOyAvLyBwb3B1bGF0ZSBwYXJlbnQuY2hpbGRyZW5fZFxcblxcbiAgICAgICAgICAgIHAuY2hpbGRyZW5fZC5wdXNoKGRhdFtpXS5pZC50b1N0cmluZygpKTtcXG4gICAgICAgICAgfSAvLyAzKSBub3JtYWxpemUgJiYgcG9wdWxhdGUgcGFyZW50cyBhbmQgY2hpbGRyZW5fZCB3aXRoIHJlY3Vyc2lvblxcblxcblxcbiAgICAgICAgICBmb3IgKGkgPSAwLCBqID0gcC5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG4gICAgICAgICAgICB0bXAgPSBwYXJzZV9mbGF0KG1bcC5jaGlsZHJlbltpXV0sIHBhciwgcC5wYXJlbnRzLmNvbmNhdCgpKTtcXG4gICAgICAgICAgICBkcGMucHVzaCh0bXApO1xcblxcbiAgICAgICAgICAgIGlmIChtW3RtcF0uY2hpbGRyZW5fZC5sZW5ndGgpIHtcXG4gICAgICAgICAgICAgIGRwYyA9IGRwYy5jb25jYXQobVt0bXBdLmNoaWxkcmVuX2QpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBmb3IgKGkgPSAwLCBqID0gcC5wYXJlbnRzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcbiAgICAgICAgICAgIG1bcC5wYXJlbnRzW2ldXS5jaGlsZHJlbl9kID0gbVtwLnBhcmVudHNbaV1dLmNoaWxkcmVuX2QuY29uY2F0KGRwYyk7XFxuICAgICAgICAgIH0gLy8gPykgdGhyZWVfc3RhdGUgc2VsZWN0aW9uIC0gcC5zdGF0ZS5zZWxlY3RlZCAmJiB0IC0gKGlmIHRocmVlX3N0YXRlIGZvcmVhY2goZGF0ID0+IGNoKSAtPiBmb3JlYWNoKHBhcmVudHMpIGlmKHBhcmVudC5zZWxlY3RlZCkgY2hpbGQuc2VsZWN0ZWQgPSB0cnVlO1xcblxcblxcbiAgICAgICAgICByc2x0ID0ge1xcbiAgICAgICAgICAgICdjbnQnOiB0X2NudCxcXG4gICAgICAgICAgICAnbW9kJzogbSxcXG4gICAgICAgICAgICAnc2VsJzogc2VsLFxcbiAgICAgICAgICAgICdwYXInOiBwYXIsXFxuICAgICAgICAgICAgJ2RwYyc6IGRwYyxcXG4gICAgICAgICAgICAnYWRkJzogYWRkXFxuICAgICAgICAgIH07XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBmb3IgKGkgPSAwLCBqID0gZGF0Lmxlbmd0aDsgaSA8IGo7IGkrKykge1xcbiAgICAgICAgICAgIHRtcCA9IHBhcnNlX25lc3QoZGF0W2ldLCBwYXIsIHAucGFyZW50cy5jb25jYXQoKSk7XFxuXFxuICAgICAgICAgICAgaWYgKHRtcCkge1xcbiAgICAgICAgICAgICAgY2hkLnB1c2godG1wKTtcXG4gICAgICAgICAgICAgIGRwYy5wdXNoKHRtcCk7XFxuXFxuICAgICAgICAgICAgICBpZiAobVt0bXBdLmNoaWxkcmVuX2QubGVuZ3RoKSB7XFxuICAgICAgICAgICAgICAgIGRwYyA9IGRwYy5jb25jYXQobVt0bXBdLmNoaWxkcmVuX2QpO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBwLmNoaWxkcmVuID0gY2hkO1xcbiAgICAgICAgICBwLmNoaWxkcmVuX2QgPSBkcGM7XFxuXFxuICAgICAgICAgIGZvciAoaSA9IDAsIGogPSBwLnBhcmVudHMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICAgICAgbVtwLnBhcmVudHNbaV1dLmNoaWxkcmVuX2QgPSBtW3AucGFyZW50c1tpXV0uY2hpbGRyZW5fZC5jb25jYXQoZHBjKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICByc2x0ID0ge1xcbiAgICAgICAgICAgICdjbnQnOiB0X2NudCxcXG4gICAgICAgICAgICAnbW9kJzogbSxcXG4gICAgICAgICAgICAnc2VsJzogc2VsLFxcbiAgICAgICAgICAgICdwYXInOiBwYXIsXFxuICAgICAgICAgICAgJ2RwYyc6IGRwYyxcXG4gICAgICAgICAgICAnYWRkJzogYWRkXFxuICAgICAgICAgIH07XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAgICAgcG9zdE1lc3NhZ2UocnNsdCk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICByZXR1cm4gcnNsdDtcXG4gICAgICAgIH1cXG4gICAgICB9LFxcbiAgICAgICAgICByc2x0ID0gZnVuY3Rpb24gcnNsdChfcnNsdCwgd29ya2VyKSB7XFxuICAgICAgICBpZiAodGhpcy5lbGVtZW50ID09PSBudWxsKSB7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHRoaXMuX2NudCA9IF9yc2x0LmNudDtcXG4gICAgICAgIHZhciBpLFxcbiAgICAgICAgICAgIG0gPSB0aGlzLl9tb2RlbC5kYXRhO1xcblxcbiAgICAgICAgZm9yIChpIGluIG0pIHtcXG4gICAgICAgICAgaWYgKG0uaGFzT3duUHJvcGVydHkoaSkgJiYgbVtpXS5zdGF0ZSAmJiBtW2ldLnN0YXRlLmxvYWRpbmcgJiYgX3JzbHQubW9kW2ldKSB7XFxuICAgICAgICAgICAgX3JzbHQubW9kW2ldLnN0YXRlLmxvYWRpbmcgPSB0cnVlO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0aGlzLl9tb2RlbC5kYXRhID0gX3JzbHQubW9kOyAvLyBicmVha3MgdGhlIHJlZmVyZW5jZSBpbiBsb2FkX25vZGUgLSBjYXJlZnVsXFxuXFxuICAgICAgICBpZiAod29ya2VyKSB7XFxuICAgICAgICAgIHZhciBqLFxcbiAgICAgICAgICAgICAgYSA9IF9yc2x0LmFkZCxcXG4gICAgICAgICAgICAgIHIgPSBfcnNsdC5zZWwsXFxuICAgICAgICAgICAgICBzID0gdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLnNsaWNlKCk7XFxuXFxuICAgICAgICAgIG0gPSB0aGlzLl9tb2RlbC5kYXRhOyAvLyBpZiBzZWxlY3Rpb24gd2FzIGNoYW5nZWQgd2hpbGUgY2FsY3VsYXRpbmcgaW4gd29ya2VyXFxuXFxuICAgICAgICAgIGlmIChyLmxlbmd0aCAhPT0gcy5sZW5ndGggfHwgJC52YWthdGEuYXJyYXlfdW5pcXVlKHIuY29uY2F0KHMpKS5sZW5ndGggIT09IHIubGVuZ3RoKSB7XFxuICAgICAgICAgICAgLy8gZGVzZWxlY3Qgbm9kZXMgdGhhdCBhcmUgbm8gbG9uZ2VyIHNlbGVjdGVkXFxuICAgICAgICAgICAgZm9yIChpID0gMCwgaiA9IHIubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICAgICAgICBpZiAoJC5pbkFycmF5KHJbaV0sIGEpID09PSAtMSAmJiAkLmluQXJyYXkocltpXSwgcykgPT09IC0xKSB7XFxuICAgICAgICAgICAgICAgIG1bcltpXV0uc3RhdGUuc2VsZWN0ZWQgPSBmYWxzZTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9IC8vIHNlbGVjdCBub2RlcyB0aGF0IHdlcmUgc2VsZWN0ZWQgaW4gdGhlIG1lYW4gdGltZVxcblxcblxcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGogPSBzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcbiAgICAgICAgICAgICAgaWYgKCQuaW5BcnJheShzW2ldLCByKSA9PT0gLTEpIHtcXG4gICAgICAgICAgICAgICAgbVtzW2ldXS5zdGF0ZS5zZWxlY3RlZCA9IHRydWU7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoX3JzbHQuYWRkLmxlbmd0aCkge1xcbiAgICAgICAgICB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQgPSB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQuY29uY2F0KF9yc2x0LmFkZCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0aGlzLnRyaWdnZXIoJ21vZGVsJywge1xcbiAgICAgICAgICBcXFwibm9kZXNcXFwiOiBfcnNsdC5kcGMsXFxuICAgICAgICAgICdwYXJlbnQnOiBfcnNsdC5wYXJcXG4gICAgICAgIH0pO1xcblxcbiAgICAgICAgaWYgKF9yc2x0LnBhciAhPT0gJC5qc3RyZWUucm9vdCkge1xcbiAgICAgICAgICB0aGlzLl9ub2RlX2NoYW5nZWQoX3JzbHQucGFyKTtcXG5cXG4gICAgICAgICAgdGhpcy5yZWRyYXcoKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIC8vIHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpLmNoaWxkcmVuKCcuanN0cmVlLWluaXRpYWwtbm9kZScpLnJlbW92ZSgpO1xcbiAgICAgICAgICB0aGlzLnJlZHJhdyh0cnVlKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChfcnNsdC5hZGQubGVuZ3RoKSB7XFxuICAgICAgICAgIHRoaXMudHJpZ2dlcignY2hhbmdlZCcsIHtcXG4gICAgICAgICAgICAnYWN0aW9uJzogJ21vZGVsJyxcXG4gICAgICAgICAgICAnc2VsZWN0ZWQnOiB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWRcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBjYi5jYWxsKHRoaXMsIHRydWUpO1xcbiAgICAgIH07XFxuXFxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuY29yZS53b3JrZXIgJiYgd2luZG93LkJsb2IgJiYgd2luZG93LlVSTCAmJiB3aW5kb3cuV29ya2VyKSB7XFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICBpZiAodGhpcy5fd3JrID09PSBudWxsKSB7XFxuICAgICAgICAgICAgdGhpcy5fd3JrID0gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwobmV3IHdpbmRvdy5CbG9iKFsnc2VsZi5vbm1lc3NhZ2UgPSAnICsgZnVuYy50b1N0cmluZygpXSwge1xcbiAgICAgICAgICAgICAgdHlwZTogXFxcInRleHQvamF2YXNjcmlwdFxcXCJcXG4gICAgICAgICAgICB9KSk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaWYgKCF0aGlzLl9kYXRhLmNvcmUud29ya2luZyB8fCBmb3JjZV9wcm9jZXNzaW5nKSB7XFxuICAgICAgICAgICAgdGhpcy5fZGF0YS5jb3JlLndvcmtpbmcgPSB0cnVlO1xcbiAgICAgICAgICAgIHcgPSBuZXcgd2luZG93Lldvcmtlcih0aGlzLl93cmspO1xcbiAgICAgICAgICAgIHcub25tZXNzYWdlID0gJC5wcm94eShmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICAgICAgcnNsdC5jYWxsKHRoaXMsIGUuZGF0YSwgdHJ1ZSk7XFxuXFxuICAgICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgICB3LnRlcm1pbmF0ZSgpO1xcbiAgICAgICAgICAgICAgICB3ID0gbnVsbDtcXG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cXG5cXG4gICAgICAgICAgICAgIGlmICh0aGlzLl9kYXRhLmNvcmUud29ya2VyX3F1ZXVlLmxlbmd0aCkge1xcbiAgICAgICAgICAgICAgICB0aGlzLl9hcHBlbmRfanNvbl9kYXRhLmFwcGx5KHRoaXMsIHRoaXMuX2RhdGEuY29yZS53b3JrZXJfcXVldWUuc2hpZnQoKSk7XFxuICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICB0aGlzLl9kYXRhLmNvcmUud29ya2luZyA9IGZhbHNlO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0sIHRoaXMpO1xcblxcbiAgICAgICAgICAgIGlmICghYXJncy5wYXIpIHtcXG4gICAgICAgICAgICAgIGlmICh0aGlzLl9kYXRhLmNvcmUud29ya2VyX3F1ZXVlLmxlbmd0aCkge1xcbiAgICAgICAgICAgICAgICB0aGlzLl9hcHBlbmRfanNvbl9kYXRhLmFwcGx5KHRoaXMsIHRoaXMuX2RhdGEuY29yZS53b3JrZXJfcXVldWUuc2hpZnQoKSk7XFxuICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICB0aGlzLl9kYXRhLmNvcmUud29ya2luZyA9IGZhbHNlO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICB3LnBvc3RNZXNzYWdlKGFyZ3MpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICB0aGlzLl9kYXRhLmNvcmUud29ya2VyX3F1ZXVlLnB1c2goW2RvbSwgZGF0YSwgY2IsIHRydWVdKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgICByc2x0LmNhbGwodGhpcywgZnVuYyhhcmdzKSwgZmFsc2UpO1xcblxcbiAgICAgICAgICBpZiAodGhpcy5fZGF0YS5jb3JlLndvcmtlcl9xdWV1ZS5sZW5ndGgpIHtcXG4gICAgICAgICAgICB0aGlzLl9hcHBlbmRfanNvbl9kYXRhLmFwcGx5KHRoaXMsIHRoaXMuX2RhdGEuY29yZS53b3JrZXJfcXVldWUuc2hpZnQoKSk7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgdGhpcy5fZGF0YS5jb3JlLndvcmtpbmcgPSBmYWxzZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICByc2x0LmNhbGwodGhpcywgZnVuYyhhcmdzKSwgZmFsc2UpO1xcbiAgICAgIH1cXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIHBhcnNlcyBhIG5vZGUgZnJvbSBhIGpRdWVyeSBvYmplY3QgYW5kIGFwcGVuZHMgdGhlbSB0byB0aGUgaW4gbWVtb3J5IHRyZWUgbW9kZWwuIFVzZWQgaW50ZXJuYWxseS5cXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQG5hbWUgX3BhcnNlX21vZGVsX2Zyb21faHRtbChkIFssIHAsIHBzXSlcXG4gICAgICogQHBhcmFtICB7alF1ZXJ5fSBkIHRoZSBqUXVlcnkgb2JqZWN0IHRvIHBhcnNlXFxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gcCB0aGUgcGFyZW50IElEXFxuICAgICAqIEBwYXJhbSAge0FycmF5fSBwcyBsaXN0IG9mIGFsbCBwYXJlbnRzXFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gdGhlIElEIG9mIHRoZSBvYmplY3QgYWRkZWQgdG8gdGhlIG1vZGVsXFxuICAgICAqL1xcbiAgICBfcGFyc2VfbW9kZWxfZnJvbV9odG1sOiBmdW5jdGlvbiBfcGFyc2VfbW9kZWxfZnJvbV9odG1sKGQsIHAsIHBzKSB7XFxuICAgICAgaWYgKCFwcykge1xcbiAgICAgICAgcHMgPSBbXTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgcHMgPSBbXS5jb25jYXQocHMpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAocCkge1xcbiAgICAgICAgcHMudW5zaGlmdChwKTtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIGMsXFxuICAgICAgICAgIGUsXFxuICAgICAgICAgIG0gPSB0aGlzLl9tb2RlbC5kYXRhLFxcbiAgICAgICAgICBkYXRhID0ge1xcbiAgICAgICAgaWQ6IGZhbHNlLFxcbiAgICAgICAgdGV4dDogZmFsc2UsXFxuICAgICAgICBpY29uOiB0cnVlLFxcbiAgICAgICAgcGFyZW50OiBwLFxcbiAgICAgICAgcGFyZW50czogcHMsXFxuICAgICAgICBjaGlsZHJlbjogW10sXFxuICAgICAgICBjaGlsZHJlbl9kOiBbXSxcXG4gICAgICAgIGRhdGE6IG51bGwsXFxuICAgICAgICBzdGF0ZToge30sXFxuICAgICAgICBsaV9hdHRyOiB7XFxuICAgICAgICAgIGlkOiBmYWxzZVxcbiAgICAgICAgfSxcXG4gICAgICAgIGFfYXR0cjoge1xcbiAgICAgICAgICBocmVmOiAnIydcXG4gICAgICAgIH0sXFxuICAgICAgICBvcmlnaW5hbDogZmFsc2VcXG4gICAgICB9LFxcbiAgICAgICAgICBpLFxcbiAgICAgICAgICB0bXAsXFxuICAgICAgICAgIHRpZDtcXG5cXG4gICAgICBmb3IgKGkgaW4gdGhpcy5fbW9kZWwuZGVmYXVsdF9zdGF0ZSkge1xcbiAgICAgICAgaWYgKHRoaXMuX21vZGVsLmRlZmF1bHRfc3RhdGUuaGFzT3duUHJvcGVydHkoaSkpIHtcXG4gICAgICAgICAgZGF0YS5zdGF0ZVtpXSA9IHRoaXMuX21vZGVsLmRlZmF1bHRfc3RhdGVbaV07XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHRtcCA9ICQudmFrYXRhLmF0dHJpYnV0ZXMoZCwgdHJ1ZSk7XFxuICAgICAgJC5lYWNoKHRtcCwgZnVuY3Rpb24gKGksIHYpIHtcXG4gICAgICAgIHYgPSAkLnRyaW0odik7XFxuXFxuICAgICAgICBpZiAoIXYubGVuZ3RoKSB7XFxuICAgICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZGF0YS5saV9hdHRyW2ldID0gdjtcXG5cXG4gICAgICAgIGlmIChpID09PSAnaWQnKSB7XFxuICAgICAgICAgIGRhdGEuaWQgPSB2LnRvU3RyaW5nKCk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgICAgdG1wID0gZC5jaGlsZHJlbignYScpLmZpcnN0KCk7XFxuXFxuICAgICAgaWYgKHRtcC5sZW5ndGgpIHtcXG4gICAgICAgIHRtcCA9ICQudmFrYXRhLmF0dHJpYnV0ZXModG1wLCB0cnVlKTtcXG4gICAgICAgICQuZWFjaCh0bXAsIGZ1bmN0aW9uIChpLCB2KSB7XFxuICAgICAgICAgIHYgPSAkLnRyaW0odik7XFxuXFxuICAgICAgICAgIGlmICh2Lmxlbmd0aCkge1xcbiAgICAgICAgICAgIGRhdGEuYV9hdHRyW2ldID0gdjtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIHRtcCA9IGQuY2hpbGRyZW4oXFxcImFcXFwiKS5maXJzdCgpLmxlbmd0aCA/IGQuY2hpbGRyZW4oXFxcImFcXFwiKS5maXJzdCgpLmNsb25lKCkgOiBkLmNsb25lKCk7XFxuICAgICAgdG1wLmNoaWxkcmVuKFxcXCJpbnMsIGksIHVsXFxcIikucmVtb3ZlKCk7XFxuICAgICAgdG1wID0gdG1wLmh0bWwoKTtcXG4gICAgICB0bXAgPSAkKCc8ZGl2IC8+JykuaHRtbCh0bXApO1xcbiAgICAgIGRhdGEudGV4dCA9IHRoaXMuc2V0dGluZ3MuY29yZS5mb3JjZV90ZXh0ID8gdG1wLnRleHQoKSA6IHRtcC5odG1sKCk7XFxuICAgICAgdG1wID0gZC5kYXRhKCk7XFxuICAgICAgZGF0YS5kYXRhID0gdG1wID8gJC5leHRlbmQodHJ1ZSwge30sIHRtcCkgOiBudWxsO1xcbiAgICAgIGRhdGEuc3RhdGUub3BlbmVkID0gZC5oYXNDbGFzcygnanN0cmVlLW9wZW4nKTtcXG4gICAgICBkYXRhLnN0YXRlLnNlbGVjdGVkID0gZC5jaGlsZHJlbignYScpLmhhc0NsYXNzKCdqc3RyZWUtY2xpY2tlZCcpO1xcbiAgICAgIGRhdGEuc3RhdGUuZGlzYWJsZWQgPSBkLmNoaWxkcmVuKCdhJykuaGFzQ2xhc3MoJ2pzdHJlZS1kaXNhYmxlZCcpO1xcblxcbiAgICAgIGlmIChkYXRhLmRhdGEgJiYgZGF0YS5kYXRhLmpzdHJlZSkge1xcbiAgICAgICAgZm9yIChpIGluIGRhdGEuZGF0YS5qc3RyZWUpIHtcXG4gICAgICAgICAgaWYgKGRhdGEuZGF0YS5qc3RyZWUuaGFzT3duUHJvcGVydHkoaSkpIHtcXG4gICAgICAgICAgICBkYXRhLnN0YXRlW2ldID0gZGF0YS5kYXRhLmpzdHJlZVtpXTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICB0bXAgPSBkLmNoaWxkcmVuKFxcXCJhXFxcIikuY2hpbGRyZW4oXFxcIi5qc3RyZWUtdGhlbWVpY29uXFxcIik7XFxuXFxuICAgICAgaWYgKHRtcC5sZW5ndGgpIHtcXG4gICAgICAgIGRhdGEuaWNvbiA9IHRtcC5oYXNDbGFzcygnanN0cmVlLXRoZW1laWNvbi1oaWRkZW4nKSA/IGZhbHNlIDogdG1wLmF0dHIoJ3JlbCcpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoZGF0YS5zdGF0ZS5pY29uICE9PSB1bmRlZmluZWQpIHtcXG4gICAgICAgIGRhdGEuaWNvbiA9IGRhdGEuc3RhdGUuaWNvbjtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGRhdGEuaWNvbiA9PT0gdW5kZWZpbmVkIHx8IGRhdGEuaWNvbiA9PT0gbnVsbCB8fCBkYXRhLmljb24gPT09IFxcXCJcXFwiKSB7XFxuICAgICAgICBkYXRhLmljb24gPSB0cnVlO1xcbiAgICAgIH1cXG5cXG4gICAgICB0bXAgPSBkLmNoaWxkcmVuKFxcXCJ1bFxcXCIpLmNoaWxkcmVuKFxcXCJsaVxcXCIpO1xcblxcbiAgICAgIGRvIHtcXG4gICAgICAgIHRpZCA9ICdqJyArIHRoaXMuX2lkICsgJ18nICsgKyt0aGlzLl9jbnQ7XFxuICAgICAgfSB3aGlsZSAobVt0aWRdKTtcXG5cXG4gICAgICBkYXRhLmlkID0gZGF0YS5saV9hdHRyLmlkID8gZGF0YS5saV9hdHRyLmlkLnRvU3RyaW5nKCkgOiB0aWQ7XFxuXFxuICAgICAgaWYgKHRtcC5sZW5ndGgpIHtcXG4gICAgICAgIHRtcC5lYWNoKCQucHJveHkoZnVuY3Rpb24gKGksIHYpIHtcXG4gICAgICAgICAgYyA9IHRoaXMuX3BhcnNlX21vZGVsX2Zyb21faHRtbCgkKHYpLCBkYXRhLmlkLCBwcyk7XFxuICAgICAgICAgIGUgPSB0aGlzLl9tb2RlbC5kYXRhW2NdO1xcbiAgICAgICAgICBkYXRhLmNoaWxkcmVuLnB1c2goYyk7XFxuXFxuICAgICAgICAgIGlmIChlLmNoaWxkcmVuX2QubGVuZ3RoKSB7XFxuICAgICAgICAgICAgZGF0YS5jaGlsZHJlbl9kID0gZGF0YS5jaGlsZHJlbl9kLmNvbmNhdChlLmNoaWxkcmVuX2QpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9LCB0aGlzKSk7XFxuICAgICAgICBkYXRhLmNoaWxkcmVuX2QgPSBkYXRhLmNoaWxkcmVuX2QuY29uY2F0KGRhdGEuY2hpbGRyZW4pO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBpZiAoZC5oYXNDbGFzcygnanN0cmVlLWNsb3NlZCcpKSB7XFxuICAgICAgICAgIGRhdGEuc3RhdGUubG9hZGVkID0gZmFsc2U7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChkYXRhLmxpX2F0dHJbJ2NsYXNzJ10pIHtcXG4gICAgICAgIGRhdGEubGlfYXR0clsnY2xhc3MnXSA9IGRhdGEubGlfYXR0clsnY2xhc3MnXS5yZXBsYWNlKCdqc3RyZWUtY2xvc2VkJywgJycpLnJlcGxhY2UoJ2pzdHJlZS1vcGVuJywgJycpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoZGF0YS5hX2F0dHJbJ2NsYXNzJ10pIHtcXG4gICAgICAgIGRhdGEuYV9hdHRyWydjbGFzcyddID0gZGF0YS5hX2F0dHJbJ2NsYXNzJ10ucmVwbGFjZSgnanN0cmVlLWNsaWNrZWQnLCAnJykucmVwbGFjZSgnanN0cmVlLWRpc2FibGVkJywgJycpO1xcbiAgICAgIH1cXG5cXG4gICAgICBtW2RhdGEuaWRdID0gZGF0YTtcXG5cXG4gICAgICBpZiAoZGF0YS5zdGF0ZS5zZWxlY3RlZCkge1xcbiAgICAgICAgdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLnB1c2goZGF0YS5pZCk7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBkYXRhLmlkO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogcGFyc2VzIGEgbm9kZSBmcm9tIGEgSlNPTiBvYmplY3QgKHVzZWQgd2hlbiBkZWFsaW5nIHdpdGggZmxhdCBkYXRhLCB3aGljaCBoYXMgbm8gbmVzdGluZyBvZiBjaGlsZHJlbiwgYnV0IGhhcyBpZCBhbmQgcGFyZW50IHByb3BlcnRpZXMpIGFuZCBhcHBlbmRzIGl0IHRvIHRoZSBpbiBtZW1vcnkgdHJlZSBtb2RlbC4gVXNlZCBpbnRlcm5hbGx5LlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAbmFtZSBfcGFyc2VfbW9kZWxfZnJvbV9mbGF0X2pzb24oZCBbLCBwLCBwc10pXFxuICAgICAqIEBwYXJhbSAge09iamVjdH0gZCB0aGUgSlNPTiBvYmplY3QgdG8gcGFyc2VcXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBwIHRoZSBwYXJlbnQgSURcXG4gICAgICogQHBhcmFtICB7QXJyYXl9IHBzIGxpc3Qgb2YgYWxsIHBhcmVudHNcXG4gICAgICogQHJldHVybiB7U3RyaW5nfSB0aGUgSUQgb2YgdGhlIG9iamVjdCBhZGRlZCB0byB0aGUgbW9kZWxcXG4gICAgICovXFxuICAgIF9wYXJzZV9tb2RlbF9mcm9tX2ZsYXRfanNvbjogZnVuY3Rpb24gX3BhcnNlX21vZGVsX2Zyb21fZmxhdF9qc29uKGQsIHAsIHBzKSB7XFxuICAgICAgaWYgKCFwcykge1xcbiAgICAgICAgcHMgPSBbXTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgcHMgPSBwcy5jb25jYXQoKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHApIHtcXG4gICAgICAgIHBzLnVuc2hpZnQocCk7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciB0aWQgPSBkLmlkLnRvU3RyaW5nKCksXFxuICAgICAgICAgIG0gPSB0aGlzLl9tb2RlbC5kYXRhLFxcbiAgICAgICAgICBkZiA9IHRoaXMuX21vZGVsLmRlZmF1bHRfc3RhdGUsXFxuICAgICAgICAgIGksXFxuICAgICAgICAgIGosXFxuICAgICAgICAgIGMsXFxuICAgICAgICAgIGUsXFxuICAgICAgICAgIHRtcCA9IHtcXG4gICAgICAgIGlkOiB0aWQsXFxuICAgICAgICB0ZXh0OiBkLnRleHQgfHwgJycsXFxuICAgICAgICBpY29uOiBkLmljb24gIT09IHVuZGVmaW5lZCA/IGQuaWNvbiA6IHRydWUsXFxuICAgICAgICBwYXJlbnQ6IHAsXFxuICAgICAgICBwYXJlbnRzOiBwcyxcXG4gICAgICAgIGNoaWxkcmVuOiBkLmNoaWxkcmVuIHx8IFtdLFxcbiAgICAgICAgY2hpbGRyZW5fZDogZC5jaGlsZHJlbl9kIHx8IFtdLFxcbiAgICAgICAgZGF0YTogZC5kYXRhLFxcbiAgICAgICAgc3RhdGU6IHt9LFxcbiAgICAgICAgbGlfYXR0cjoge1xcbiAgICAgICAgICBpZDogZmFsc2VcXG4gICAgICAgIH0sXFxuICAgICAgICBhX2F0dHI6IHtcXG4gICAgICAgICAgaHJlZjogJyMnXFxuICAgICAgICB9LFxcbiAgICAgICAgb3JpZ2luYWw6IGZhbHNlXFxuICAgICAgfTtcXG5cXG4gICAgICBmb3IgKGkgaW4gZGYpIHtcXG4gICAgICAgIGlmIChkZi5oYXNPd25Qcm9wZXJ0eShpKSkge1xcbiAgICAgICAgICB0bXAuc3RhdGVbaV0gPSBkZltpXTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGQgJiYgZC5kYXRhICYmIGQuZGF0YS5qc3RyZWUgJiYgZC5kYXRhLmpzdHJlZS5pY29uKSB7XFxuICAgICAgICB0bXAuaWNvbiA9IGQuZGF0YS5qc3RyZWUuaWNvbjtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRtcC5pY29uID09PSB1bmRlZmluZWQgfHwgdG1wLmljb24gPT09IG51bGwgfHwgdG1wLmljb24gPT09IFxcXCJcXFwiKSB7XFxuICAgICAgICB0bXAuaWNvbiA9IHRydWU7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChkICYmIGQuZGF0YSkge1xcbiAgICAgICAgdG1wLmRhdGEgPSBkLmRhdGE7XFxuXFxuICAgICAgICBpZiAoZC5kYXRhLmpzdHJlZSkge1xcbiAgICAgICAgICBmb3IgKGkgaW4gZC5kYXRhLmpzdHJlZSkge1xcbiAgICAgICAgICAgIGlmIChkLmRhdGEuanN0cmVlLmhhc093blByb3BlcnR5KGkpKSB7XFxuICAgICAgICAgICAgICB0bXAuc3RhdGVbaV0gPSBkLmRhdGEuanN0cmVlW2ldO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoZCAmJiBfdHlwZW9mKGQuc3RhdGUpID09PSAnb2JqZWN0Jykge1xcbiAgICAgICAgZm9yIChpIGluIGQuc3RhdGUpIHtcXG4gICAgICAgICAgaWYgKGQuc3RhdGUuaGFzT3duUHJvcGVydHkoaSkpIHtcXG4gICAgICAgICAgICB0bXAuc3RhdGVbaV0gPSBkLnN0YXRlW2ldO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChkICYmIF90eXBlb2YoZC5saV9hdHRyKSA9PT0gJ29iamVjdCcpIHtcXG4gICAgICAgIGZvciAoaSBpbiBkLmxpX2F0dHIpIHtcXG4gICAgICAgICAgaWYgKGQubGlfYXR0ci5oYXNPd25Qcm9wZXJ0eShpKSkge1xcbiAgICAgICAgICAgIHRtcC5saV9hdHRyW2ldID0gZC5saV9hdHRyW2ldO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghdG1wLmxpX2F0dHIuaWQpIHtcXG4gICAgICAgIHRtcC5saV9hdHRyLmlkID0gdGlkO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoZCAmJiBfdHlwZW9mKGQuYV9hdHRyKSA9PT0gJ29iamVjdCcpIHtcXG4gICAgICAgIGZvciAoaSBpbiBkLmFfYXR0cikge1xcbiAgICAgICAgICBpZiAoZC5hX2F0dHIuaGFzT3duUHJvcGVydHkoaSkpIHtcXG4gICAgICAgICAgICB0bXAuYV9hdHRyW2ldID0gZC5hX2F0dHJbaV07XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGQgJiYgZC5jaGlsZHJlbiAmJiBkLmNoaWxkcmVuID09PSB0cnVlKSB7XFxuICAgICAgICB0bXAuc3RhdGUubG9hZGVkID0gZmFsc2U7XFxuICAgICAgICB0bXAuY2hpbGRyZW4gPSBbXTtcXG4gICAgICAgIHRtcC5jaGlsZHJlbl9kID0gW107XFxuICAgICAgfVxcblxcbiAgICAgIG1bdG1wLmlkXSA9IHRtcDtcXG5cXG4gICAgICBmb3IgKGkgPSAwLCBqID0gdG1wLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcbiAgICAgICAgYyA9IHRoaXMuX3BhcnNlX21vZGVsX2Zyb21fZmxhdF9qc29uKG1bdG1wLmNoaWxkcmVuW2ldXSwgdG1wLmlkLCBwcyk7XFxuICAgICAgICBlID0gbVtjXTtcXG4gICAgICAgIHRtcC5jaGlsZHJlbl9kLnB1c2goYyk7XFxuXFxuICAgICAgICBpZiAoZS5jaGlsZHJlbl9kLmxlbmd0aCkge1xcbiAgICAgICAgICB0bXAuY2hpbGRyZW5fZCA9IHRtcC5jaGlsZHJlbl9kLmNvbmNhdChlLmNoaWxkcmVuX2QpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBkZWxldGUgZC5kYXRhO1xcbiAgICAgIGRlbGV0ZSBkLmNoaWxkcmVuO1xcbiAgICAgIG1bdG1wLmlkXS5vcmlnaW5hbCA9IGQ7XFxuXFxuICAgICAgaWYgKHRtcC5zdGF0ZS5zZWxlY3RlZCkge1xcbiAgICAgICAgdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLnB1c2godG1wLmlkKTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHRtcC5pZDtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIHBhcnNlcyBhIG5vZGUgZnJvbSBhIEpTT04gb2JqZWN0IGFuZCBhcHBlbmRzIGl0IHRvIHRoZSBpbiBtZW1vcnkgdHJlZSBtb2RlbC4gVXNlZCBpbnRlcm5hbGx5LlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAbmFtZSBfcGFyc2VfbW9kZWxfZnJvbV9qc29uKGQgWywgcCwgcHNdKVxcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGQgdGhlIEpTT04gb2JqZWN0IHRvIHBhcnNlXFxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gcCB0aGUgcGFyZW50IElEXFxuICAgICAqIEBwYXJhbSAge0FycmF5fSBwcyBsaXN0IG9mIGFsbCBwYXJlbnRzXFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gdGhlIElEIG9mIHRoZSBvYmplY3QgYWRkZWQgdG8gdGhlIG1vZGVsXFxuICAgICAqL1xcbiAgICBfcGFyc2VfbW9kZWxfZnJvbV9qc29uOiBmdW5jdGlvbiBfcGFyc2VfbW9kZWxfZnJvbV9qc29uKGQsIHAsIHBzKSB7XFxuICAgICAgaWYgKCFwcykge1xcbiAgICAgICAgcHMgPSBbXTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgcHMgPSBwcy5jb25jYXQoKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHApIHtcXG4gICAgICAgIHBzLnVuc2hpZnQocCk7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciB0aWQgPSBmYWxzZSxcXG4gICAgICAgICAgaSxcXG4gICAgICAgICAgaixcXG4gICAgICAgICAgYyxcXG4gICAgICAgICAgZSxcXG4gICAgICAgICAgbSA9IHRoaXMuX21vZGVsLmRhdGEsXFxuICAgICAgICAgIGRmID0gdGhpcy5fbW9kZWwuZGVmYXVsdF9zdGF0ZSxcXG4gICAgICAgICAgdG1wO1xcblxcbiAgICAgIGRvIHtcXG4gICAgICAgIHRpZCA9ICdqJyArIHRoaXMuX2lkICsgJ18nICsgKyt0aGlzLl9jbnQ7XFxuICAgICAgfSB3aGlsZSAobVt0aWRdKTtcXG5cXG4gICAgICB0bXAgPSB7XFxuICAgICAgICBpZDogZmFsc2UsXFxuICAgICAgICB0ZXh0OiB0eXBlb2YgZCA9PT0gJ3N0cmluZycgPyBkIDogJycsXFxuICAgICAgICBpY29uOiBfdHlwZW9mKGQpID09PSAnb2JqZWN0JyAmJiBkLmljb24gIT09IHVuZGVmaW5lZCA/IGQuaWNvbiA6IHRydWUsXFxuICAgICAgICBwYXJlbnQ6IHAsXFxuICAgICAgICBwYXJlbnRzOiBwcyxcXG4gICAgICAgIGNoaWxkcmVuOiBbXSxcXG4gICAgICAgIGNoaWxkcmVuX2Q6IFtdLFxcbiAgICAgICAgZGF0YTogbnVsbCxcXG4gICAgICAgIHN0YXRlOiB7fSxcXG4gICAgICAgIGxpX2F0dHI6IHtcXG4gICAgICAgICAgaWQ6IGZhbHNlXFxuICAgICAgICB9LFxcbiAgICAgICAgYV9hdHRyOiB7XFxuICAgICAgICAgIGhyZWY6ICcjJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIG9yaWdpbmFsOiBmYWxzZVxcbiAgICAgIH07XFxuXFxuICAgICAgZm9yIChpIGluIGRmKSB7XFxuICAgICAgICBpZiAoZGYuaGFzT3duUHJvcGVydHkoaSkpIHtcXG4gICAgICAgICAgdG1wLnN0YXRlW2ldID0gZGZbaV07XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChkICYmIGQuaWQpIHtcXG4gICAgICAgIHRtcC5pZCA9IGQuaWQudG9TdHJpbmcoKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGQgJiYgZC50ZXh0KSB7XFxuICAgICAgICB0bXAudGV4dCA9IGQudGV4dDtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGQgJiYgZC5kYXRhICYmIGQuZGF0YS5qc3RyZWUgJiYgZC5kYXRhLmpzdHJlZS5pY29uKSB7XFxuICAgICAgICB0bXAuaWNvbiA9IGQuZGF0YS5qc3RyZWUuaWNvbjtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRtcC5pY29uID09PSB1bmRlZmluZWQgfHwgdG1wLmljb24gPT09IG51bGwgfHwgdG1wLmljb24gPT09IFxcXCJcXFwiKSB7XFxuICAgICAgICB0bXAuaWNvbiA9IHRydWU7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChkICYmIGQuZGF0YSkge1xcbiAgICAgICAgdG1wLmRhdGEgPSBkLmRhdGE7XFxuXFxuICAgICAgICBpZiAoZC5kYXRhLmpzdHJlZSkge1xcbiAgICAgICAgICBmb3IgKGkgaW4gZC5kYXRhLmpzdHJlZSkge1xcbiAgICAgICAgICAgIGlmIChkLmRhdGEuanN0cmVlLmhhc093blByb3BlcnR5KGkpKSB7XFxuICAgICAgICAgICAgICB0bXAuc3RhdGVbaV0gPSBkLmRhdGEuanN0cmVlW2ldO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoZCAmJiBfdHlwZW9mKGQuc3RhdGUpID09PSAnb2JqZWN0Jykge1xcbiAgICAgICAgZm9yIChpIGluIGQuc3RhdGUpIHtcXG4gICAgICAgICAgaWYgKGQuc3RhdGUuaGFzT3duUHJvcGVydHkoaSkpIHtcXG4gICAgICAgICAgICB0bXAuc3RhdGVbaV0gPSBkLnN0YXRlW2ldO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChkICYmIF90eXBlb2YoZC5saV9hdHRyKSA9PT0gJ29iamVjdCcpIHtcXG4gICAgICAgIGZvciAoaSBpbiBkLmxpX2F0dHIpIHtcXG4gICAgICAgICAgaWYgKGQubGlfYXR0ci5oYXNPd25Qcm9wZXJ0eShpKSkge1xcbiAgICAgICAgICAgIHRtcC5saV9hdHRyW2ldID0gZC5saV9hdHRyW2ldO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0bXAubGlfYXR0ci5pZCAmJiAhdG1wLmlkKSB7XFxuICAgICAgICB0bXAuaWQgPSB0bXAubGlfYXR0ci5pZC50b1N0cmluZygpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIXRtcC5pZCkge1xcbiAgICAgICAgdG1wLmlkID0gdGlkO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIXRtcC5saV9hdHRyLmlkKSB7XFxuICAgICAgICB0bXAubGlfYXR0ci5pZCA9IHRtcC5pZDtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGQgJiYgX3R5cGVvZihkLmFfYXR0cikgPT09ICdvYmplY3QnKSB7XFxuICAgICAgICBmb3IgKGkgaW4gZC5hX2F0dHIpIHtcXG4gICAgICAgICAgaWYgKGQuYV9hdHRyLmhhc093blByb3BlcnR5KGkpKSB7XFxuICAgICAgICAgICAgdG1wLmFfYXR0cltpXSA9IGQuYV9hdHRyW2ldO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChkICYmIGQuY2hpbGRyZW4gJiYgZC5jaGlsZHJlbi5sZW5ndGgpIHtcXG4gICAgICAgIGZvciAoaSA9IDAsIGogPSBkLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcbiAgICAgICAgICBjID0gdGhpcy5fcGFyc2VfbW9kZWxfZnJvbV9qc29uKGQuY2hpbGRyZW5baV0sIHRtcC5pZCwgcHMpO1xcbiAgICAgICAgICBlID0gbVtjXTtcXG4gICAgICAgICAgdG1wLmNoaWxkcmVuLnB1c2goYyk7XFxuXFxuICAgICAgICAgIGlmIChlLmNoaWxkcmVuX2QubGVuZ3RoKSB7XFxuICAgICAgICAgICAgdG1wLmNoaWxkcmVuX2QgPSB0bXAuY2hpbGRyZW5fZC5jb25jYXQoZS5jaGlsZHJlbl9kKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgdG1wLmNoaWxkcmVuX2QgPSB0bXAuY2hpbGRyZW5fZC5jb25jYXQodG1wLmNoaWxkcmVuKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGQgJiYgZC5jaGlsZHJlbiAmJiBkLmNoaWxkcmVuID09PSB0cnVlKSB7XFxuICAgICAgICB0bXAuc3RhdGUubG9hZGVkID0gZmFsc2U7XFxuICAgICAgICB0bXAuY2hpbGRyZW4gPSBbXTtcXG4gICAgICAgIHRtcC5jaGlsZHJlbl9kID0gW107XFxuICAgICAgfVxcblxcbiAgICAgIGRlbGV0ZSBkLmRhdGE7XFxuICAgICAgZGVsZXRlIGQuY2hpbGRyZW47XFxuICAgICAgdG1wLm9yaWdpbmFsID0gZDtcXG4gICAgICBtW3RtcC5pZF0gPSB0bXA7XFxuXFxuICAgICAgaWYgKHRtcC5zdGF0ZS5zZWxlY3RlZCkge1xcbiAgICAgICAgdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLnB1c2godG1wLmlkKTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHRtcC5pZDtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIHJlZHJhd3MgYWxsIG5vZGVzIHRoYXQgbmVlZCB0byBiZSByZWRyYXduLiBVc2VkIGludGVybmFsbHkuXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBuYW1lIF9yZWRyYXcoKVxcbiAgICAgKiBAdHJpZ2dlciByZWRyYXcuanN0cmVlXFxuICAgICAqL1xcbiAgICBfcmVkcmF3OiBmdW5jdGlvbiBfcmVkcmF3KCkge1xcbiAgICAgIHZhciBub2RlcyA9IHRoaXMuX21vZGVsLmZvcmNlX2Z1bGxfcmVkcmF3ID8gdGhpcy5fbW9kZWwuZGF0YVskLmpzdHJlZS5yb290XS5jaGlsZHJlbi5jb25jYXQoW10pIDogdGhpcy5fbW9kZWwuY2hhbmdlZC5jb25jYXQoW10pLFxcbiAgICAgICAgICBmID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnVUwnKSxcXG4gICAgICAgICAgdG1wLFxcbiAgICAgICAgICBpLFxcbiAgICAgICAgICBqLFxcbiAgICAgICAgICBmZSA9IHRoaXMuX2RhdGEuY29yZS5mb2N1c2VkO1xcblxcbiAgICAgIGZvciAoaSA9IDAsIGogPSBub2Rlcy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG4gICAgICAgIHRtcCA9IHRoaXMucmVkcmF3X25vZGUobm9kZXNbaV0sIHRydWUsIHRoaXMuX21vZGVsLmZvcmNlX2Z1bGxfcmVkcmF3KTtcXG5cXG4gICAgICAgIGlmICh0bXAgJiYgdGhpcy5fbW9kZWwuZm9yY2VfZnVsbF9yZWRyYXcpIHtcXG4gICAgICAgICAgZi5hcHBlbmRDaGlsZCh0bXApO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5fbW9kZWwuZm9yY2VfZnVsbF9yZWRyYXcpIHtcXG4gICAgICAgIGYuY2xhc3NOYW1lID0gdGhpcy5nZXRfY29udGFpbmVyX3VsKClbMF0uY2xhc3NOYW1lO1xcbiAgICAgICAgZi5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnZ3JvdXAnKTtcXG4gICAgICAgIHRoaXMuZWxlbWVudC5lbXB0eSgpLmFwcGVuZChmKTsgLy90aGlzLmdldF9jb250YWluZXJfdWwoKVswXS5hcHBlbmRDaGlsZChmKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGZlICE9PSBudWxsKSB7XFxuICAgICAgICB0bXAgPSB0aGlzLmdldF9ub2RlKGZlLCB0cnVlKTtcXG5cXG4gICAgICAgIGlmICh0bXAgJiYgdG1wLmxlbmd0aCAmJiB0bXAuY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJylbMF0gIT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIHtcXG4gICAgICAgICAgdG1wLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLmZvY3VzKCk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICB0aGlzLl9kYXRhLmNvcmUuZm9jdXNlZCA9IG51bGw7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX21vZGVsLmZvcmNlX2Z1bGxfcmVkcmF3ID0gZmFsc2U7XFxuICAgICAgdGhpcy5fbW9kZWwuY2hhbmdlZCA9IFtdO1xcbiAgICAgIC8qKlxcbiAgICAgICAqIHRyaWdnZXJlZCBhZnRlciBub2RlcyBhcmUgcmVkcmF3blxcbiAgICAgICAqIEBldmVudFxcbiAgICAgICAqIEBuYW1lIHJlZHJhdy5qc3RyZWVcXG4gICAgICAgKiBAcGFyYW0ge2FycmF5fSBub2RlcyB0aGUgcmVkcmF3biBub2Rlc1xcbiAgICAgICAqL1xcblxcbiAgICAgIHRoaXMudHJpZ2dlcigncmVkcmF3Jywge1xcbiAgICAgICAgXFxcIm5vZGVzXFxcIjogbm9kZXNcXG4gICAgICB9KTtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIHJlZHJhd3MgYWxsIG5vZGVzIHRoYXQgbmVlZCB0byBiZSByZWRyYXduIG9yIG9wdGlvbmFsbHkgLSB0aGUgd2hvbGUgdHJlZVxcbiAgICAgKiBAbmFtZSByZWRyYXcoW2Z1bGxdKVxcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZ1bGwgaWYgc2V0IHRvIGB0cnVlYCBhbGwgbm9kZXMgYXJlIHJlZHJhd24uXFxuICAgICAqL1xcbiAgICByZWRyYXc6IGZ1bmN0aW9uIHJlZHJhdyhmdWxsKSB7XFxuICAgICAgaWYgKGZ1bGwpIHtcXG4gICAgICAgIHRoaXMuX21vZGVsLmZvcmNlX2Z1bGxfcmVkcmF3ID0gdHJ1ZTtcXG4gICAgICB9IC8vaWYodGhpcy5fbW9kZWwucmVkcmF3X3RpbWVvdXQpIHtcXG4gICAgICAvL1xcdGNsZWFyVGltZW91dCh0aGlzLl9tb2RlbC5yZWRyYXdfdGltZW91dCk7XFxuICAgICAgLy99XFxuICAgICAgLy90aGlzLl9tb2RlbC5yZWRyYXdfdGltZW91dCA9IHNldFRpbWVvdXQoJC5wcm94eSh0aGlzLl9yZWRyYXcsIHRoaXMpLDApO1xcblxcblxcbiAgICAgIHRoaXMuX3JlZHJhdygpO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogcmVkcmF3cyBhIHNpbmdsZSBub2RlJ3MgY2hpbGRyZW4uIFVzZWQgaW50ZXJuYWxseS5cXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQG5hbWUgZHJhd19jaGlsZHJlbihub2RlKVxcbiAgICAgKiBAcGFyYW0ge21peGVkfSBub2RlIHRoZSBub2RlIHdob3NlIGNoaWxkcmVuIHdpbGwgYmUgcmVkcmF3blxcbiAgICAgKi9cXG4gICAgZHJhd19jaGlsZHJlbjogZnVuY3Rpb24gZHJhd19jaGlsZHJlbihub2RlKSB7XFxuICAgICAgdmFyIG9iaiA9IHRoaXMuZ2V0X25vZGUobm9kZSksXFxuICAgICAgICAgIGkgPSBmYWxzZSxcXG4gICAgICAgICAgaiA9IGZhbHNlLFxcbiAgICAgICAgICBrID0gZmFsc2UsXFxuICAgICAgICAgIGQgPSBkb2N1bWVudDtcXG5cXG4gICAgICBpZiAoIW9iaikge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAob2JqLmlkID09PSAkLmpzdHJlZS5yb290KSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5yZWRyYXcodHJ1ZSk7XFxuICAgICAgfVxcblxcbiAgICAgIG5vZGUgPSB0aGlzLmdldF9ub2RlKG5vZGUsIHRydWUpO1xcblxcbiAgICAgIGlmICghbm9kZSB8fCAhbm9kZS5sZW5ndGgpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9IC8vIFRPRE86IHF1aWNrIHRvZ2dsZVxcblxcblxcbiAgICAgIG5vZGUuY2hpbGRyZW4oJy5qc3RyZWUtY2hpbGRyZW4nKS5yZW1vdmUoKTtcXG4gICAgICBub2RlID0gbm9kZVswXTtcXG5cXG4gICAgICBpZiAob2JqLmNoaWxkcmVuLmxlbmd0aCAmJiBvYmouc3RhdGUubG9hZGVkKSB7XFxuICAgICAgICBrID0gZC5jcmVhdGVFbGVtZW50KCdVTCcpO1xcbiAgICAgICAgay5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnZ3JvdXAnKTtcXG4gICAgICAgIGsuY2xhc3NOYW1lID0gJ2pzdHJlZS1jaGlsZHJlbic7XFxuXFxuICAgICAgICBmb3IgKGkgPSAwLCBqID0gb2JqLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcbiAgICAgICAgICBrLmFwcGVuZENoaWxkKHRoaXMucmVkcmF3X25vZGUob2JqLmNoaWxkcmVuW2ldLCB0cnVlLCB0cnVlKSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBub2RlLmFwcGVuZENoaWxkKGspO1xcbiAgICAgIH1cXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIHJlZHJhd3MgYSBzaW5nbGUgbm9kZS4gVXNlZCBpbnRlcm5hbGx5LlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAbmFtZSByZWRyYXdfbm9kZShub2RlLCBkZWVwLCBpc19jYWxsYmFjaywgZm9yY2VfcmVuZGVyKVxcbiAgICAgKiBAcGFyYW0ge21peGVkfSBub2RlIHRoZSBub2RlIHRvIHJlZHJhd1xcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRlZXAgc2hvdWxkIGNoaWxkIG5vZGVzIGJlIHJlZHJhd24gdG9vXFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNfY2FsbGJhY2sgaXMgdGhpcyBhIHJlY3Vyc2lvbiBjYWxsXFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZm9yY2VfcmVuZGVyIHNob3VsZCBjaGlsZHJlbiBvZiBjbG9zZWQgcGFyZW50cyBiZSBkcmF3biBhbnl3YXlcXG4gICAgICovXFxuICAgIHJlZHJhd19ub2RlOiBmdW5jdGlvbiByZWRyYXdfbm9kZShub2RlLCBkZWVwLCBpc19jYWxsYmFjaywgZm9yY2VfcmVuZGVyKSB7XFxuICAgICAgdmFyIG9iaiA9IHRoaXMuZ2V0X25vZGUobm9kZSksXFxuICAgICAgICAgIHBhciA9IGZhbHNlLFxcbiAgICAgICAgICBpbmQgPSBmYWxzZSxcXG4gICAgICAgICAgb2xkID0gZmFsc2UsXFxuICAgICAgICAgIGkgPSBmYWxzZSxcXG4gICAgICAgICAgaiA9IGZhbHNlLFxcbiAgICAgICAgICBrID0gZmFsc2UsXFxuICAgICAgICAgIGMgPSAnJyxcXG4gICAgICAgICAgZCA9IGRvY3VtZW50LFxcbiAgICAgICAgICBtID0gdGhpcy5fbW9kZWwuZGF0YSxcXG4gICAgICAgICAgZiA9IGZhbHNlLFxcbiAgICAgICAgICBzID0gZmFsc2UsXFxuICAgICAgICAgIHRtcCA9IG51bGwsXFxuICAgICAgICAgIHQgPSAwLFxcbiAgICAgICAgICBsID0gMCxcXG4gICAgICAgICAgaGFzX2NoaWxkcmVuID0gZmFsc2UsXFxuICAgICAgICAgIGxhc3Rfc2libGluZyA9IGZhbHNlO1xcblxcbiAgICAgIGlmICghb2JqKSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLnJlZHJhdyh0cnVlKTtcXG4gICAgICB9XFxuXFxuICAgICAgZGVlcCA9IGRlZXAgfHwgb2JqLmNoaWxkcmVuLmxlbmd0aCA9PT0gMDtcXG4gICAgICBub2RlID0gIWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IgPyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChvYmouaWQpIDogdGhpcy5lbGVtZW50WzBdLnF1ZXJ5U2VsZWN0b3IoJyMnICsgKFxcXCIwMTIzNDU2Nzg5XFxcIi5pbmRleE9mKG9iai5pZFswXSkgIT09IC0xID8gJ1xcXFxcXFxcMycgKyBvYmouaWRbMF0gKyAnICcgKyBvYmouaWQuc3Vic3RyKDEpLnJlcGxhY2UoJC5qc3RyZWUuaWRyZWdleCwgJ1xcXFxcXFxcJCYnKSA6IG9iai5pZC5yZXBsYWNlKCQuanN0cmVlLmlkcmVnZXgsICdcXFxcXFxcXCQmJykpKTsgLy8sIHRoaXMuZWxlbWVudCk7XFxuXFxuICAgICAgaWYgKCFub2RlKSB7XFxuICAgICAgICBkZWVwID0gdHJ1ZTsgLy9ub2RlID0gZC5jcmVhdGVFbGVtZW50KCdMSScpO1xcblxcbiAgICAgICAgaWYgKCFpc19jYWxsYmFjaykge1xcbiAgICAgICAgICBwYXIgPSBvYmoucGFyZW50ICE9PSAkLmpzdHJlZS5yb290ID8gJCgnIycgKyBvYmoucGFyZW50LnJlcGxhY2UoJC5qc3RyZWUuaWRyZWdleCwgJ1xcXFxcXFxcJCYnKSwgdGhpcy5lbGVtZW50KVswXSA6IG51bGw7XFxuXFxuICAgICAgICAgIGlmIChwYXIgIT09IG51bGwgJiYgKCFwYXIgfHwgIW1bb2JqLnBhcmVudF0uc3RhdGUub3BlbmVkKSkge1xcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpbmQgPSAkLmluQXJyYXkob2JqLmlkLCBwYXIgPT09IG51bGwgPyBtWyQuanN0cmVlLnJvb3RdLmNoaWxkcmVuIDogbVtvYmoucGFyZW50XS5jaGlsZHJlbik7XFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIG5vZGUgPSAkKG5vZGUpO1xcblxcbiAgICAgICAgaWYgKCFpc19jYWxsYmFjaykge1xcbiAgICAgICAgICBwYXIgPSBub2RlLnBhcmVudCgpLnBhcmVudCgpWzBdO1xcblxcbiAgICAgICAgICBpZiAocGFyID09PSB0aGlzLmVsZW1lbnRbMF0pIHtcXG4gICAgICAgICAgICBwYXIgPSBudWxsO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGluZCA9IG5vZGUuaW5kZXgoKTtcXG4gICAgICAgIH0gLy8gbVtvYmouaWRdLmRhdGEgPSBub2RlLmRhdGEoKTsgLy8gdXNlIG9ubHkgbm9kZSdzIGRhdGEsIG5vIG5lZWQgdG8gdG91Y2gganF1ZXJ5IHN0b3JhZ2VcXG5cXG5cXG4gICAgICAgIGlmICghZGVlcCAmJiBvYmouY2hpbGRyZW4ubGVuZ3RoICYmICFub2RlLmNoaWxkcmVuKCcuanN0cmVlLWNoaWxkcmVuJykubGVuZ3RoKSB7XFxuICAgICAgICAgIGRlZXAgPSB0cnVlO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKCFkZWVwKSB7XFxuICAgICAgICAgIG9sZCA9IG5vZGUuY2hpbGRyZW4oJy5qc3RyZWUtY2hpbGRyZW4nKVswXTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGYgPSBub2RlLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpWzBdID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xcbiAgICAgICAgbm9kZS5yZW1vdmUoKTsgLy9ub2RlID0gZC5jcmVhdGVFbGVtZW50KCdMSScpO1xcbiAgICAgICAgLy9ub2RlID0gbm9kZVswXTtcXG4gICAgICB9XFxuXFxuICAgICAgbm9kZSA9IHRoaXMuX2RhdGEuY29yZS5ub2RlLmNsb25lTm9kZSh0cnVlKTsgLy8gbm9kZSBpcyBET00sIGRlZXAgaXMgYm9vbGVhblxcblxcbiAgICAgIGMgPSAnanN0cmVlLW5vZGUgJztcXG5cXG4gICAgICBmb3IgKGkgaW4gb2JqLmxpX2F0dHIpIHtcXG4gICAgICAgIGlmIChvYmoubGlfYXR0ci5oYXNPd25Qcm9wZXJ0eShpKSkge1xcbiAgICAgICAgICBpZiAoaSA9PT0gJ2lkJykge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmIChpICE9PSAnY2xhc3MnKSB7XFxuICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoaSwgb2JqLmxpX2F0dHJbaV0pO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGMgKz0gb2JqLmxpX2F0dHJbaV07XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCFvYmouYV9hdHRyLmlkKSB7XFxuICAgICAgICBvYmouYV9hdHRyLmlkID0gb2JqLmlkICsgJ19hbmNob3InO1xcbiAgICAgIH1cXG5cXG4gICAgICBub2RlLnNldEF0dHJpYnV0ZSgnYXJpYS1zZWxlY3RlZCcsICEhb2JqLnN0YXRlLnNlbGVjdGVkKTtcXG4gICAgICBub2RlLnNldEF0dHJpYnV0ZSgnYXJpYS1sZXZlbCcsIG9iai5wYXJlbnRzLmxlbmd0aCk7XFxuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWxsZWRieScsIG9iai5hX2F0dHIuaWQpO1xcblxcbiAgICAgIGlmIChvYmouc3RhdGUuZGlzYWJsZWQpIHtcXG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCdhcmlhLWRpc2FibGVkJywgdHJ1ZSk7XFxuICAgICAgfVxcblxcbiAgICAgIGZvciAoaSA9IDAsIGogPSBvYmouY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICBpZiAoIW1bb2JqLmNoaWxkcmVuW2ldXS5zdGF0ZS5oaWRkZW4pIHtcXG4gICAgICAgICAgaGFzX2NoaWxkcmVuID0gdHJ1ZTtcXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChvYmoucGFyZW50ICE9PSBudWxsICYmIG1bb2JqLnBhcmVudF0gJiYgIW9iai5zdGF0ZS5oaWRkZW4pIHtcXG4gICAgICAgIGkgPSAkLmluQXJyYXkob2JqLmlkLCBtW29iai5wYXJlbnRdLmNoaWxkcmVuKTtcXG4gICAgICAgIGxhc3Rfc2libGluZyA9IG9iai5pZDtcXG5cXG4gICAgICAgIGlmIChpICE9PSAtMSkge1xcbiAgICAgICAgICBpKys7XFxuXFxuICAgICAgICAgIGZvciAoaiA9IG1bb2JqLnBhcmVudF0uY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICAgICAgaWYgKCFtW21bb2JqLnBhcmVudF0uY2hpbGRyZW5baV1dLnN0YXRlLmhpZGRlbikge1xcbiAgICAgICAgICAgICAgbGFzdF9zaWJsaW5nID0gbVtvYmoucGFyZW50XS5jaGlsZHJlbltpXTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaWYgKGxhc3Rfc2libGluZyAhPT0gb2JqLmlkKSB7XFxuICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgaWYgKG9iai5zdGF0ZS5oaWRkZW4pIHtcXG4gICAgICAgIGMgKz0gJyBqc3RyZWUtaGlkZGVuJztcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKG9iai5zdGF0ZS5sb2FkZWQgJiYgIWhhc19jaGlsZHJlbikge1xcbiAgICAgICAgYyArPSAnIGpzdHJlZS1sZWFmJztcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgYyArPSBvYmouc3RhdGUub3BlbmVkICYmIG9iai5zdGF0ZS5sb2FkZWQgPyAnIGpzdHJlZS1vcGVuJyA6ICcganN0cmVlLWNsb3NlZCc7XFxuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsIG9iai5zdGF0ZS5vcGVuZWQgJiYgb2JqLnN0YXRlLmxvYWRlZCk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChsYXN0X3NpYmxpbmcgPT09IG9iai5pZCkge1xcbiAgICAgICAgYyArPSAnIGpzdHJlZS1sYXN0JztcXG4gICAgICB9XFxuXFxuICAgICAgbm9kZS5pZCA9IG9iai5pZDtcXG4gICAgICBub2RlLmNsYXNzTmFtZSA9IGM7XFxuICAgICAgYyA9IChvYmouc3RhdGUuc2VsZWN0ZWQgPyAnIGpzdHJlZS1jbGlja2VkJyA6ICcnKSArIChvYmouc3RhdGUuZGlzYWJsZWQgPyAnIGpzdHJlZS1kaXNhYmxlZCcgOiAnJyk7XFxuXFxuICAgICAgZm9yIChqIGluIG9iai5hX2F0dHIpIHtcXG4gICAgICAgIGlmIChvYmouYV9hdHRyLmhhc093blByb3BlcnR5KGopKSB7XFxuICAgICAgICAgIGlmIChqID09PSAnaHJlZicgJiYgb2JqLmFfYXR0cltqXSA9PT0gJyMnKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaWYgKGogIT09ICdjbGFzcycpIHtcXG4gICAgICAgICAgICBub2RlLmNoaWxkTm9kZXNbMV0uc2V0QXR0cmlidXRlKGosIG9iai5hX2F0dHJbal0pO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGMgKz0gJyAnICsgb2JqLmFfYXR0cltqXTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoYy5sZW5ndGgpIHtcXG4gICAgICAgIG5vZGUuY2hpbGROb2Rlc1sxXS5jbGFzc05hbWUgPSAnanN0cmVlLWFuY2hvciAnICsgYztcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKG9iai5pY29uICYmIG9iai5pY29uICE9PSB0cnVlIHx8IG9iai5pY29uID09PSBmYWxzZSkge1xcbiAgICAgICAgaWYgKG9iai5pY29uID09PSBmYWxzZSkge1xcbiAgICAgICAgICBub2RlLmNoaWxkTm9kZXNbMV0uY2hpbGROb2Rlc1swXS5jbGFzc05hbWUgKz0gJyBqc3RyZWUtdGhlbWVpY29uLWhpZGRlbic7XFxuICAgICAgICB9IGVsc2UgaWYgKG9iai5pY29uLmluZGV4T2YoJy8nKSA9PT0gLTEgJiYgb2JqLmljb24uaW5kZXhPZignLicpID09PSAtMSkge1xcbiAgICAgICAgICBub2RlLmNoaWxkTm9kZXNbMV0uY2hpbGROb2Rlc1swXS5jbGFzc05hbWUgKz0gJyAnICsgb2JqLmljb24gKyAnIGpzdHJlZS10aGVtZWljb24tY3VzdG9tJztcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIG5vZGUuY2hpbGROb2Rlc1sxXS5jaGlsZE5vZGVzWzBdLnN0eWxlLmJhY2tncm91bmRJbWFnZSA9ICd1cmwoXFxcIicgKyBvYmouaWNvbiArICdcXFwiKSc7XFxuICAgICAgICAgIG5vZGUuY2hpbGROb2Rlc1sxXS5jaGlsZE5vZGVzWzBdLnN0eWxlLmJhY2tncm91bmRQb3NpdGlvbiA9ICdjZW50ZXIgY2VudGVyJztcXG4gICAgICAgICAgbm9kZS5jaGlsZE5vZGVzWzFdLmNoaWxkTm9kZXNbMF0uc3R5bGUuYmFja2dyb3VuZFNpemUgPSAnYXV0byc7XFxuICAgICAgICAgIG5vZGUuY2hpbGROb2Rlc1sxXS5jaGlsZE5vZGVzWzBdLmNsYXNzTmFtZSArPSAnIGpzdHJlZS10aGVtZWljb24tY3VzdG9tJztcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuY29yZS5mb3JjZV90ZXh0KSB7XFxuICAgICAgICBub2RlLmNoaWxkTm9kZXNbMV0uYXBwZW5kQ2hpbGQoZC5jcmVhdGVUZXh0Tm9kZShvYmoudGV4dCkpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBub2RlLmNoaWxkTm9kZXNbMV0uaW5uZXJIVE1MICs9IG9iai50ZXh0O1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoZGVlcCAmJiBvYmouY2hpbGRyZW4ubGVuZ3RoICYmIChvYmouc3RhdGUub3BlbmVkIHx8IGZvcmNlX3JlbmRlcikgJiYgb2JqLnN0YXRlLmxvYWRlZCkge1xcbiAgICAgICAgayA9IGQuY3JlYXRlRWxlbWVudCgnVUwnKTtcXG4gICAgICAgIGsuc2V0QXR0cmlidXRlKCdyb2xlJywgJ2dyb3VwJyk7XFxuICAgICAgICBrLmNsYXNzTmFtZSA9ICdqc3RyZWUtY2hpbGRyZW4nO1xcblxcbiAgICAgICAgZm9yIChpID0gMCwgaiA9IG9iai5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG4gICAgICAgICAgay5hcHBlbmRDaGlsZCh0aGlzLnJlZHJhd19ub2RlKG9iai5jaGlsZHJlbltpXSwgZGVlcCwgdHJ1ZSkpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgbm9kZS5hcHBlbmRDaGlsZChrKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKG9sZCkge1xcbiAgICAgICAgbm9kZS5hcHBlbmRDaGlsZChvbGQpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIWlzX2NhbGxiYWNrKSB7XFxuICAgICAgICAvLyBhcHBlbmQgYmFjayB1c2luZyBwYXIgLyBpbmRcXG4gICAgICAgIGlmICghcGFyKSB7XFxuICAgICAgICAgIHBhciA9IHRoaXMuZWxlbWVudFswXTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGZvciAoaSA9IDAsIGogPSBwYXIuY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG4gICAgICAgICAgaWYgKHBhci5jaGlsZE5vZGVzW2ldICYmIHBhci5jaGlsZE5vZGVzW2ldLmNsYXNzTmFtZSAmJiBwYXIuY2hpbGROb2Rlc1tpXS5jbGFzc05hbWUuaW5kZXhPZignanN0cmVlLWNoaWxkcmVuJykgIT09IC0xKSB7XFxuICAgICAgICAgICAgdG1wID0gcGFyLmNoaWxkTm9kZXNbaV07XFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICghdG1wKSB7XFxuICAgICAgICAgIHRtcCA9IGQuY3JlYXRlRWxlbWVudCgnVUwnKTtcXG4gICAgICAgICAgdG1wLnNldEF0dHJpYnV0ZSgncm9sZScsICdncm91cCcpO1xcbiAgICAgICAgICB0bXAuY2xhc3NOYW1lID0gJ2pzdHJlZS1jaGlsZHJlbic7XFxuICAgICAgICAgIHBhci5hcHBlbmRDaGlsZCh0bXApO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcGFyID0gdG1wO1xcblxcbiAgICAgICAgaWYgKGluZCA8IHBhci5jaGlsZE5vZGVzLmxlbmd0aCkge1xcbiAgICAgICAgICBwYXIuaW5zZXJ0QmVmb3JlKG5vZGUsIHBhci5jaGlsZE5vZGVzW2luZF0pO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgcGFyLmFwcGVuZENoaWxkKG5vZGUpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKGYpIHtcXG4gICAgICAgICAgdCA9IHRoaXMuZWxlbWVudFswXS5zY3JvbGxUb3A7XFxuICAgICAgICAgIGwgPSB0aGlzLmVsZW1lbnRbMF0uc2Nyb2xsTGVmdDtcXG4gICAgICAgICAgbm9kZS5jaGlsZE5vZGVzWzFdLmZvY3VzKCk7XFxuICAgICAgICAgIHRoaXMuZWxlbWVudFswXS5zY3JvbGxUb3AgPSB0O1xcbiAgICAgICAgICB0aGlzLmVsZW1lbnRbMF0uc2Nyb2xsTGVmdCA9IGw7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChvYmouc3RhdGUub3BlbmVkICYmICFvYmouc3RhdGUubG9hZGVkKSB7XFxuICAgICAgICBvYmouc3RhdGUub3BlbmVkID0gZmFsc2U7XFxuICAgICAgICBzZXRUaW1lb3V0KCQucHJveHkoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICB0aGlzLm9wZW5fbm9kZShvYmouaWQsIGZhbHNlLCAwKTtcXG4gICAgICAgIH0sIHRoaXMpLCAwKTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIG5vZGU7XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBvcGVucyBhIG5vZGUsIHJldmFsaW5nIGl0cyBjaGlsZHJlbi4gSWYgdGhlIG5vZGUgaXMgbm90IGxvYWRlZCBpdCB3aWxsIGJlIGxvYWRlZCBhbmQgb3BlbmVkIG9uY2UgcmVhZHkuXFxuICAgICAqIEBuYW1lIG9wZW5fbm9kZShvYmogWywgY2FsbGJhY2ssIGFuaW1hdGlvbl0pXFxuICAgICAqIEBwYXJhbSB7bWl4ZWR9IG9iaiB0aGUgbm9kZSB0byBvcGVuXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGEgZnVuY3Rpb24gdG8gZXhlY3V0ZSBvbmNlIHRoZSBub2RlIGlzIG9wZW5lZFxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYW5pbWF0aW9uIHRoZSBhbmltYXRpb24gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzIHdoZW4gb3BlbmluZyB0aGUgbm9kZSAob3ZlcnJpZGVzIHRoZSBgY29yZS5hbmltYXRpb25gIHNldHRpbmcpLiBVc2UgYGZhbHNlYCBmb3Igbm8gYW5pbWF0aW9uLlxcbiAgICAgKiBAdHJpZ2dlciBvcGVuX25vZGUuanN0cmVlLCBhZnRlcl9vcGVuLmpzdHJlZSwgYmVmb3JlX29wZW4uanN0cmVlXFxuICAgICAqL1xcbiAgICBvcGVuX25vZGU6IGZ1bmN0aW9uIG9wZW5fbm9kZShvYmosIGNhbGxiYWNrLCBhbmltYXRpb24pIHtcXG4gICAgICB2YXIgdDEsIHQyLCBkLCB0O1xcblxcbiAgICAgIGlmICgkLmlzQXJyYXkob2JqKSkge1xcbiAgICAgICAgb2JqID0gb2JqLnNsaWNlKCk7XFxuXFxuICAgICAgICBmb3IgKHQxID0gMCwgdDIgPSBvYmoubGVuZ3RoOyB0MSA8IHQyOyB0MSsrKSB7XFxuICAgICAgICAgIHRoaXMub3Blbl9ub2RlKG9ialt0MV0sIGNhbGxiYWNrLCBhbmltYXRpb24pO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgfVxcblxcbiAgICAgIG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXG4gICAgICBpZiAoIW9iaiB8fCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgYW5pbWF0aW9uID0gYW5pbWF0aW9uID09PSB1bmRlZmluZWQgPyB0aGlzLnNldHRpbmdzLmNvcmUuYW5pbWF0aW9uIDogYW5pbWF0aW9uO1xcblxcbiAgICAgIGlmICghdGhpcy5pc19jbG9zZWQob2JqKSkge1xcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XFxuICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgb2JqLCBmYWxzZSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghdGhpcy5pc19sb2FkZWQob2JqKSkge1xcbiAgICAgICAgaWYgKHRoaXMuaXNfbG9hZGluZyhvYmopKSB7XFxuICAgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KCQucHJveHkoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIHRoaXMub3Blbl9ub2RlKG9iaiwgY2FsbGJhY2ssIGFuaW1hdGlvbik7XFxuICAgICAgICAgIH0sIHRoaXMpLCA1MDApO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdGhpcy5sb2FkX25vZGUob2JqLCBmdW5jdGlvbiAobywgb2spIHtcXG4gICAgICAgICAgcmV0dXJuIG9rID8gdGhpcy5vcGVuX25vZGUobywgY2FsbGJhY2ssIGFuaW1hdGlvbikgOiBjYWxsYmFjayA/IGNhbGxiYWNrLmNhbGwodGhpcywgbywgZmFsc2UpIDogZmFsc2U7XFxuICAgICAgICB9KTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgZCA9IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKTtcXG4gICAgICAgIHQgPSB0aGlzO1xcblxcbiAgICAgICAgaWYgKGQubGVuZ3RoKSB7XFxuICAgICAgICAgIGlmIChhbmltYXRpb24gJiYgZC5jaGlsZHJlbihcXFwiLmpzdHJlZS1jaGlsZHJlblxcXCIpLmxlbmd0aCkge1xcbiAgICAgICAgICAgIGQuY2hpbGRyZW4oXFxcIi5qc3RyZWUtY2hpbGRyZW5cXFwiKS5zdG9wKHRydWUsIHRydWUpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmIChvYmouY2hpbGRyZW4ubGVuZ3RoICYmICF0aGlzLl9maXJzdENoaWxkKGQuY2hpbGRyZW4oJy5qc3RyZWUtY2hpbGRyZW4nKVswXSkpIHtcXG4gICAgICAgICAgICB0aGlzLmRyYXdfY2hpbGRyZW4ob2JqKTsgLy9kID0gdGhpcy5nZXRfbm9kZShvYmosIHRydWUpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmICghYW5pbWF0aW9uKSB7XFxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdiZWZvcmVfb3BlbicsIHtcXG4gICAgICAgICAgICAgIFxcXCJub2RlXFxcIjogb2JqXFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgZFswXS5jbGFzc05hbWUgPSBkWzBdLmNsYXNzTmFtZS5yZXBsYWNlKCdqc3RyZWUtY2xvc2VkJywgJ2pzdHJlZS1vcGVuJyk7XFxuICAgICAgICAgICAgZFswXS5zZXRBdHRyaWJ1dGUoXFxcImFyaWEtZXhwYW5kZWRcXFwiLCB0cnVlKTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2JlZm9yZV9vcGVuJywge1xcbiAgICAgICAgICAgICAgXFxcIm5vZGVcXFwiOiBvYmpcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICBkLmNoaWxkcmVuKFxcXCIuanN0cmVlLWNoaWxkcmVuXFxcIikuY3NzKFxcXCJkaXNwbGF5XFxcIiwgXFxcIm5vbmVcXFwiKS5lbmQoKS5yZW1vdmVDbGFzcyhcXFwianN0cmVlLWNsb3NlZFxcXCIpLmFkZENsYXNzKFxcXCJqc3RyZWUtb3BlblxcXCIpLmF0dHIoXFxcImFyaWEtZXhwYW5kZWRcXFwiLCB0cnVlKS5jaGlsZHJlbihcXFwiLmpzdHJlZS1jaGlsZHJlblxcXCIpLnN0b3AodHJ1ZSwgdHJ1ZSkuc2xpZGVEb3duKGFuaW1hdGlvbiwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gXFxcIlxcXCI7XFxuXFxuICAgICAgICAgICAgICBpZiAodC5lbGVtZW50KSB7XFxuICAgICAgICAgICAgICAgIHQudHJpZ2dlcihcXFwiYWZ0ZXJfb3BlblxcXCIsIHtcXG4gICAgICAgICAgICAgICAgICBcXFwibm9kZVxcXCI6IG9ialxcbiAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgb2JqLnN0YXRlLm9wZW5lZCA9IHRydWU7XFxuXFxuICAgICAgICBpZiAoY2FsbGJhY2spIHtcXG4gICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCBvYmosIHRydWUpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKCFkLmxlbmd0aCkge1xcbiAgICAgICAgICAvKipcXG4gICAgICAgICAgICogdHJpZ2dlcmVkIHdoZW4gYSBub2RlIGlzIGFib3V0IHRvIGJlIG9wZW5lZCAoaWYgdGhlIG5vZGUgaXMgc3VwcG9zZWQgdG8gYmUgaW4gdGhlIERPTSwgaXQgd2lsbCBiZSwgYnV0IGl0IHdvbid0IGJlIHZpc2libGUgeWV0KVxcbiAgICAgICAgICAgKiBAZXZlbnRcXG4gICAgICAgICAgICogQG5hbWUgYmVmb3JlX29wZW4uanN0cmVlXFxuICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIHRoZSBvcGVuZWQgbm9kZVxcbiAgICAgICAgICAgKi9cXG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCdiZWZvcmVfb3BlbicsIHtcXG4gICAgICAgICAgICBcXFwibm9kZVxcXCI6IG9ialxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogdHJpZ2dlcmVkIHdoZW4gYSBub2RlIGlzIG9wZW5lZCAoaWYgdGhlcmUgaXMgYW4gYW5pbWF0aW9uIGl0IHdpbGwgbm90IGJlIGNvbXBsZXRlZCB5ZXQpXFxuICAgICAgICAgKiBAZXZlbnRcXG4gICAgICAgICAqIEBuYW1lIG9wZW5fbm9kZS5qc3RyZWVcXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIHRoZSBvcGVuZWQgbm9kZVxcbiAgICAgICAgICovXFxuXFxuXFxuICAgICAgICB0aGlzLnRyaWdnZXIoJ29wZW5fbm9kZScsIHtcXG4gICAgICAgICAgXFxcIm5vZGVcXFwiOiBvYmpcXG4gICAgICAgIH0pO1xcblxcbiAgICAgICAgaWYgKCFhbmltYXRpb24gfHwgIWQubGVuZ3RoKSB7XFxuICAgICAgICAgIC8qKlxcbiAgICAgICAgICAgKiB0cmlnZ2VyZWQgd2hlbiBhIG5vZGUgaXMgb3BlbmVkIGFuZCB0aGUgYW5pbWF0aW9uIGlzIGNvbXBsZXRlXFxuICAgICAgICAgICAqIEBldmVudFxcbiAgICAgICAgICAgKiBAbmFtZSBhZnRlcl9vcGVuLmpzdHJlZVxcbiAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZSB0aGUgb3BlbmVkIG5vZGVcXG4gICAgICAgICAgICovXFxuICAgICAgICAgIHRoaXMudHJpZ2dlcihcXFwiYWZ0ZXJfb3BlblxcXCIsIHtcXG4gICAgICAgICAgICBcXFwibm9kZVxcXCI6IG9ialxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgIH1cXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIG9wZW5zIGV2ZXJ5IHBhcmVudCBvZiBhIG5vZGUgKG5vZGUgc2hvdWxkIGJlIGxvYWRlZClcXG4gICAgICogQG5hbWUgX29wZW5fdG8ob2JqKVxcbiAgICAgKiBAcGFyYW0ge21peGVkfSBvYmogdGhlIG5vZGUgdG8gcmV2ZWFsXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcbiAgICBfb3Blbl90bzogZnVuY3Rpb24gX29wZW5fdG8ob2JqKSB7XFxuICAgICAgb2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xcblxcbiAgICAgIGlmICghb2JqIHx8IG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCkge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgaSxcXG4gICAgICAgICAgaixcXG4gICAgICAgICAgcCA9IG9iai5wYXJlbnRzO1xcblxcbiAgICAgIGZvciAoaSA9IDAsIGogPSBwLmxlbmd0aDsgaSA8IGo7IGkgKz0gMSkge1xcbiAgICAgICAgaWYgKGkgIT09ICQuanN0cmVlLnJvb3QpIHtcXG4gICAgICAgICAgdGhpcy5vcGVuX25vZGUocFtpXSwgZmFsc2UsIDApO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gJCgnIycgKyBvYmouaWQucmVwbGFjZSgkLmpzdHJlZS5pZHJlZ2V4LCAnXFxcXFxcXFwkJicpLCB0aGlzLmVsZW1lbnQpO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogY2xvc2VzIGEgbm9kZSwgaGlkaW5nIGl0cyBjaGlsZHJlblxcbiAgICAgKiBAbmFtZSBjbG9zZV9ub2RlKG9iaiBbLCBhbmltYXRpb25dKVxcbiAgICAgKiBAcGFyYW0ge21peGVkfSBvYmogdGhlIG5vZGUgdG8gY2xvc2VcXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFuaW1hdGlvbiB0aGUgYW5pbWF0aW9uIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcyB3aGVuIGNsb3NpbmcgdGhlIG5vZGUgKG92ZXJyaWRlcyB0aGUgYGNvcmUuYW5pbWF0aW9uYCBzZXR0aW5nKS4gVXNlIGBmYWxzZWAgZm9yIG5vIGFuaW1hdGlvbi5cXG4gICAgICogQHRyaWdnZXIgY2xvc2Vfbm9kZS5qc3RyZWUsIGFmdGVyX2Nsb3NlLmpzdHJlZVxcbiAgICAgKi9cXG4gICAgY2xvc2Vfbm9kZTogZnVuY3Rpb24gY2xvc2Vfbm9kZShvYmosIGFuaW1hdGlvbikge1xcbiAgICAgIHZhciB0MSwgdDIsIHQsIGQ7XFxuXFxuICAgICAgaWYgKCQuaXNBcnJheShvYmopKSB7XFxuICAgICAgICBvYmogPSBvYmouc2xpY2UoKTtcXG5cXG4gICAgICAgIGZvciAodDEgPSAwLCB0MiA9IG9iai5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcXG4gICAgICAgICAgdGhpcy5jbG9zZV9ub2RlKG9ialt0MV0sIGFuaW1hdGlvbik7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICB9XFxuXFxuICAgICAgb2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xcblxcbiAgICAgIGlmICghb2JqIHx8IG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCkge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5pc19jbG9zZWQob2JqKSkge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICBhbmltYXRpb24gPSBhbmltYXRpb24gPT09IHVuZGVmaW5lZCA/IHRoaXMuc2V0dGluZ3MuY29yZS5hbmltYXRpb24gOiBhbmltYXRpb247XFxuICAgICAgdCA9IHRoaXM7XFxuICAgICAgZCA9IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKTtcXG4gICAgICBvYmouc3RhdGUub3BlbmVkID0gZmFsc2U7XFxuICAgICAgLyoqXFxuICAgICAgICogdHJpZ2dlcmVkIHdoZW4gYSBub2RlIGlzIGNsb3NlZCAoaWYgdGhlcmUgaXMgYW4gYW5pbWF0aW9uIGl0IHdpbGwgbm90IGJlIGNvbXBsZXRlIHlldClcXG4gICAgICAgKiBAZXZlbnRcXG4gICAgICAgKiBAbmFtZSBjbG9zZV9ub2RlLmpzdHJlZVxcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIHRoZSBjbG9zZWQgbm9kZVxcbiAgICAgICAqL1xcblxcbiAgICAgIHRoaXMudHJpZ2dlcignY2xvc2Vfbm9kZScsIHtcXG4gICAgICAgIFxcXCJub2RlXFxcIjogb2JqXFxuICAgICAgfSk7XFxuXFxuICAgICAgaWYgKCFkLmxlbmd0aCkge1xcbiAgICAgICAgLyoqXFxuICAgICAgICAgKiB0cmlnZ2VyZWQgd2hlbiBhIG5vZGUgaXMgY2xvc2VkIGFuZCB0aGUgYW5pbWF0aW9uIGlzIGNvbXBsZXRlXFxuICAgICAgICAgKiBAZXZlbnRcXG4gICAgICAgICAqIEBuYW1lIGFmdGVyX2Nsb3NlLmpzdHJlZVxcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGUgdGhlIGNsb3NlZCBub2RlXFxuICAgICAgICAgKi9cXG4gICAgICAgIHRoaXMudHJpZ2dlcihcXFwiYWZ0ZXJfY2xvc2VcXFwiLCB7XFxuICAgICAgICAgIFxcXCJub2RlXFxcIjogb2JqXFxuICAgICAgICB9KTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgaWYgKCFhbmltYXRpb24pIHtcXG4gICAgICAgICAgZFswXS5jbGFzc05hbWUgPSBkWzBdLmNsYXNzTmFtZS5yZXBsYWNlKCdqc3RyZWUtb3BlbicsICdqc3RyZWUtY2xvc2VkJyk7XFxuICAgICAgICAgIGQuYXR0cihcXFwiYXJpYS1leHBhbmRlZFxcXCIsIGZhbHNlKS5jaGlsZHJlbignLmpzdHJlZS1jaGlsZHJlbicpLnJlbW92ZSgpO1xcbiAgICAgICAgICB0aGlzLnRyaWdnZXIoXFxcImFmdGVyX2Nsb3NlXFxcIiwge1xcbiAgICAgICAgICAgIFxcXCJub2RlXFxcIjogb2JqXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgZC5jaGlsZHJlbihcXFwiLmpzdHJlZS1jaGlsZHJlblxcXCIpLmF0dHIoXFxcInN0eWxlXFxcIiwgXFxcImRpc3BsYXk6YmxvY2sgIWltcG9ydGFudFxcXCIpLmVuZCgpLnJlbW92ZUNsYXNzKFxcXCJqc3RyZWUtb3BlblxcXCIpLmFkZENsYXNzKFxcXCJqc3RyZWUtY2xvc2VkXFxcIikuYXR0cihcXFwiYXJpYS1leHBhbmRlZFxcXCIsIGZhbHNlKS5jaGlsZHJlbihcXFwiLmpzdHJlZS1jaGlsZHJlblxcXCIpLnN0b3AodHJ1ZSwgdHJ1ZSkuc2xpZGVVcChhbmltYXRpb24sIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSBcXFwiXFxcIjtcXG4gICAgICAgICAgICBkLmNoaWxkcmVuKCcuanN0cmVlLWNoaWxkcmVuJykucmVtb3ZlKCk7XFxuXFxuICAgICAgICAgICAgaWYgKHQuZWxlbWVudCkge1xcbiAgICAgICAgICAgICAgdC50cmlnZ2VyKFxcXCJhZnRlcl9jbG9zZVxcXCIsIHtcXG4gICAgICAgICAgICAgICAgXFxcIm5vZGVcXFwiOiBvYmpcXG4gICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogdG9nZ2xlcyBhIG5vZGUgLSBjbG9zaW5nIGl0IGlmIGl0IGlzIG9wZW4sIG9wZW5pbmcgaXQgaWYgaXQgaXMgY2xvc2VkXFxuICAgICAqIEBuYW1lIHRvZ2dsZV9ub2RlKG9iailcXG4gICAgICogQHBhcmFtIHttaXhlZH0gb2JqIHRoZSBub2RlIHRvIHRvZ2dsZVxcbiAgICAgKi9cXG4gICAgdG9nZ2xlX25vZGU6IGZ1bmN0aW9uIHRvZ2dsZV9ub2RlKG9iaikge1xcbiAgICAgIHZhciB0MSwgdDI7XFxuXFxuICAgICAgaWYgKCQuaXNBcnJheShvYmopKSB7XFxuICAgICAgICBvYmogPSBvYmouc2xpY2UoKTtcXG5cXG4gICAgICAgIGZvciAodDEgPSAwLCB0MiA9IG9iai5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcXG4gICAgICAgICAgdGhpcy50b2dnbGVfbm9kZShvYmpbdDFdKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5pc19jbG9zZWQob2JqKSkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMub3Blbl9ub2RlKG9iaik7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLmlzX29wZW4ob2JqKSkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvc2Vfbm9kZShvYmopO1xcbiAgICAgIH1cXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIG9wZW5zIGFsbCBub2RlcyB3aXRoaW4gYSBub2RlIChvciB0aGUgdHJlZSksIHJldmFsaW5nIHRoZWlyIGNoaWxkcmVuLiBJZiB0aGUgbm9kZSBpcyBub3QgbG9hZGVkIGl0IHdpbGwgYmUgbG9hZGVkIGFuZCBvcGVuZWQgb25jZSByZWFkeS5cXG4gICAgICogQG5hbWUgb3Blbl9hbGwoW29iaiwgYW5pbWF0aW9uLCBvcmlnaW5hbF9vYmpdKVxcbiAgICAgKiBAcGFyYW0ge21peGVkfSBvYmogdGhlIG5vZGUgdG8gb3BlbiByZWN1cnNpdmVseSwgb21pdCB0byBvcGVuIGFsbCBub2RlcyBpbiB0aGUgdHJlZVxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYW5pbWF0aW9uIHRoZSBhbmltYXRpb24gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzIHdoZW4gb3BlbmluZyB0aGUgbm9kZXMsIHRoZSBkZWZhdWx0IGlzIG5vIGFuaW1hdGlvblxcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gcmVmZXJlbmNlIHRvIHRoZSBub2RlIHRoYXQgc3RhcnRlZCB0aGUgcHJvY2VzcyAoaW50ZXJuYWwgdXNlKVxcbiAgICAgKiBAdHJpZ2dlciBvcGVuX2FsbC5qc3RyZWVcXG4gICAgICovXFxuICAgIG9wZW5fYWxsOiBmdW5jdGlvbiBvcGVuX2FsbChvYmosIGFuaW1hdGlvbiwgb3JpZ2luYWxfb2JqKSB7XFxuICAgICAgaWYgKCFvYmopIHtcXG4gICAgICAgIG9iaiA9ICQuanN0cmVlLnJvb3Q7XFxuICAgICAgfVxcblxcbiAgICAgIG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXG4gICAgICBpZiAoIW9iaikge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgZG9tID0gb2JqLmlkID09PSAkLmpzdHJlZS5yb290ID8gdGhpcy5nZXRfY29udGFpbmVyX3VsKCkgOiB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSksXFxuICAgICAgICAgIGksXFxuICAgICAgICAgIGosXFxuICAgICAgICAgIF90aGlzO1xcblxcbiAgICAgIGlmICghZG9tLmxlbmd0aCkge1xcbiAgICAgICAgZm9yIChpID0gMCwgaiA9IG9iai5jaGlsZHJlbl9kLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcbiAgICAgICAgICBpZiAodGhpcy5pc19jbG9zZWQodGhpcy5fbW9kZWwuZGF0YVtvYmouY2hpbGRyZW5fZFtpXV0pKSB7XFxuICAgICAgICAgICAgdGhpcy5fbW9kZWwuZGF0YVtvYmouY2hpbGRyZW5fZFtpXV0uc3RhdGUub3BlbmVkID0gdHJ1ZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlcignb3Blbl9hbGwnLCB7XFxuICAgICAgICAgIFxcXCJub2RlXFxcIjogb2JqXFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuXFxuICAgICAgb3JpZ2luYWxfb2JqID0gb3JpZ2luYWxfb2JqIHx8IGRvbTtcXG4gICAgICBfdGhpcyA9IHRoaXM7XFxuICAgICAgZG9tID0gdGhpcy5pc19jbG9zZWQob2JqKSA/IGRvbS5maW5kKCcuanN0cmVlLWNsb3NlZCcpLmFkZEJhY2soKSA6IGRvbS5maW5kKCcuanN0cmVlLWNsb3NlZCcpO1xcbiAgICAgIGRvbS5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIF90aGlzLm9wZW5fbm9kZSh0aGlzLCBmdW5jdGlvbiAobm9kZSwgc3RhdHVzKSB7XFxuICAgICAgICAgIGlmIChzdGF0dXMgJiYgdGhpcy5pc19wYXJlbnQobm9kZSkpIHtcXG4gICAgICAgICAgICB0aGlzLm9wZW5fYWxsKG5vZGUsIGFuaW1hdGlvbiwgb3JpZ2luYWxfb2JqKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSwgYW5pbWF0aW9uIHx8IDApO1xcbiAgICAgIH0pO1xcblxcbiAgICAgIGlmIChvcmlnaW5hbF9vYmouZmluZCgnLmpzdHJlZS1jbG9zZWQnKS5sZW5ndGggPT09IDApIHtcXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogdHJpZ2dlcmVkIHdoZW4gYW4gYG9wZW5fYWxsYCBjYWxsIGNvbXBsZXRlc1xcbiAgICAgICAgICogQGV2ZW50XFxuICAgICAgICAgKiBAbmFtZSBvcGVuX2FsbC5qc3RyZWVcXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIHRoZSBvcGVuZWQgbm9kZVxcbiAgICAgICAgICovXFxuICAgICAgICB0aGlzLnRyaWdnZXIoJ29wZW5fYWxsJywge1xcbiAgICAgICAgICBcXFwibm9kZVxcXCI6IHRoaXMuZ2V0X25vZGUob3JpZ2luYWxfb2JqKVxcbiAgICAgICAgfSk7XFxuICAgICAgfVxcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogY2xvc2VzIGFsbCBub2RlcyB3aXRoaW4gYSBub2RlIChvciB0aGUgdHJlZSksIHJldmFsaW5nIHRoZWlyIGNoaWxkcmVuXFxuICAgICAqIEBuYW1lIGNsb3NlX2FsbChbb2JqLCBhbmltYXRpb25dKVxcbiAgICAgKiBAcGFyYW0ge21peGVkfSBvYmogdGhlIG5vZGUgdG8gY2xvc2UgcmVjdXJzaXZlbHksIG9taXQgdG8gY2xvc2UgYWxsIG5vZGVzIGluIHRoZSB0cmVlXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhbmltYXRpb24gdGhlIGFuaW1hdGlvbiBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMgd2hlbiBjbG9zaW5nIHRoZSBub2RlcywgdGhlIGRlZmF1bHQgaXMgbm8gYW5pbWF0aW9uXFxuICAgICAqIEB0cmlnZ2VyIGNsb3NlX2FsbC5qc3RyZWVcXG4gICAgICovXFxuICAgIGNsb3NlX2FsbDogZnVuY3Rpb24gY2xvc2VfYWxsKG9iaiwgYW5pbWF0aW9uKSB7XFxuICAgICAgaWYgKCFvYmopIHtcXG4gICAgICAgIG9iaiA9ICQuanN0cmVlLnJvb3Q7XFxuICAgICAgfVxcblxcbiAgICAgIG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXG4gICAgICBpZiAoIW9iaikge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgZG9tID0gb2JqLmlkID09PSAkLmpzdHJlZS5yb290ID8gdGhpcy5nZXRfY29udGFpbmVyX3VsKCkgOiB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSksXFxuICAgICAgICAgIF90aGlzID0gdGhpcyxcXG4gICAgICAgICAgaSxcXG4gICAgICAgICAgajtcXG5cXG4gICAgICBpZiAoZG9tLmxlbmd0aCkge1xcbiAgICAgICAgZG9tID0gdGhpcy5pc19vcGVuKG9iaikgPyBkb20uZmluZCgnLmpzdHJlZS1vcGVuJykuYWRkQmFjaygpIDogZG9tLmZpbmQoJy5qc3RyZWUtb3BlbicpO1xcbiAgICAgICAgJChkb20uZ2V0KCkucmV2ZXJzZSgpKS5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgX3RoaXMuY2xvc2Vfbm9kZSh0aGlzLCBhbmltYXRpb24gfHwgMCk7XFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuXFxuICAgICAgZm9yIChpID0gMCwgaiA9IG9iai5jaGlsZHJlbl9kLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcbiAgICAgICAgdGhpcy5fbW9kZWwuZGF0YVtvYmouY2hpbGRyZW5fZFtpXV0uc3RhdGUub3BlbmVkID0gZmFsc2U7XFxuICAgICAgfVxcbiAgICAgIC8qKlxcbiAgICAgICAqIHRyaWdnZXJlZCB3aGVuIGFuIGBjbG9zZV9hbGxgIGNhbGwgY29tcGxldGVzXFxuICAgICAgICogQGV2ZW50XFxuICAgICAgICogQG5hbWUgY2xvc2VfYWxsLmpzdHJlZVxcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIHRoZSBjbG9zZWQgbm9kZVxcbiAgICAgICAqL1xcblxcblxcbiAgICAgIHRoaXMudHJpZ2dlcignY2xvc2VfYWxsJywge1xcbiAgICAgICAgXFxcIm5vZGVcXFwiOiBvYmpcXG4gICAgICB9KTtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIGNoZWNrcyBpZiBhIG5vZGUgaXMgZGlzYWJsZWQgKG5vdCBzZWxlY3RhYmxlKVxcbiAgICAgKiBAbmFtZSBpc19kaXNhYmxlZChvYmopXFxuICAgICAqIEBwYXJhbSAge21peGVkfSBvYmpcXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cXG4gICAgICovXFxuICAgIGlzX2Rpc2FibGVkOiBmdW5jdGlvbiBpc19kaXNhYmxlZChvYmopIHtcXG4gICAgICBvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XFxuICAgICAgcmV0dXJuIG9iaiAmJiBvYmouc3RhdGUgJiYgb2JqLnN0YXRlLmRpc2FibGVkO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogZW5hYmxlcyBhIG5vZGUgLSBzbyB0aGF0IGl0IGNhbiBiZSBzZWxlY3RlZFxcbiAgICAgKiBAbmFtZSBlbmFibGVfbm9kZShvYmopXFxuICAgICAqIEBwYXJhbSB7bWl4ZWR9IG9iaiB0aGUgbm9kZSB0byBlbmFibGVcXG4gICAgICogQHRyaWdnZXIgZW5hYmxlX25vZGUuanN0cmVlXFxuICAgICAqL1xcbiAgICBlbmFibGVfbm9kZTogZnVuY3Rpb24gZW5hYmxlX25vZGUob2JqKSB7XFxuICAgICAgdmFyIHQxLCB0MjtcXG5cXG4gICAgICBpZiAoJC5pc0FycmF5KG9iaikpIHtcXG4gICAgICAgIG9iaiA9IG9iai5zbGljZSgpO1xcblxcbiAgICAgICAgZm9yICh0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xcbiAgICAgICAgICB0aGlzLmVuYWJsZV9ub2RlKG9ialt0MV0pO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgfVxcblxcbiAgICAgIG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXG4gICAgICBpZiAoIW9iaiB8fCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgb2JqLnN0YXRlLmRpc2FibGVkID0gZmFsc2U7XFxuICAgICAgdGhpcy5nZXRfbm9kZShvYmosIHRydWUpLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLnJlbW92ZUNsYXNzKCdqc3RyZWUtZGlzYWJsZWQnKS5hdHRyKCdhcmlhLWRpc2FibGVkJywgZmFsc2UpO1xcbiAgICAgIC8qKlxcbiAgICAgICAqIHRyaWdnZXJlZCB3aGVuIGFuIG5vZGUgaXMgZW5hYmxlZFxcbiAgICAgICAqIEBldmVudFxcbiAgICAgICAqIEBuYW1lIGVuYWJsZV9ub2RlLmpzdHJlZVxcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIHRoZSBlbmFibGVkIG5vZGVcXG4gICAgICAgKi9cXG5cXG4gICAgICB0aGlzLnRyaWdnZXIoJ2VuYWJsZV9ub2RlJywge1xcbiAgICAgICAgJ25vZGUnOiBvYmpcXG4gICAgICB9KTtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIGRpc2FibGVzIGEgbm9kZSAtIHNvIHRoYXQgaXQgY2FuIG5vdCBiZSBzZWxlY3RlZFxcbiAgICAgKiBAbmFtZSBkaXNhYmxlX25vZGUob2JqKVxcbiAgICAgKiBAcGFyYW0ge21peGVkfSBvYmogdGhlIG5vZGUgdG8gZGlzYWJsZVxcbiAgICAgKiBAdHJpZ2dlciBkaXNhYmxlX25vZGUuanN0cmVlXFxuICAgICAqL1xcbiAgICBkaXNhYmxlX25vZGU6IGZ1bmN0aW9uIGRpc2FibGVfbm9kZShvYmopIHtcXG4gICAgICB2YXIgdDEsIHQyO1xcblxcbiAgICAgIGlmICgkLmlzQXJyYXkob2JqKSkge1xcbiAgICAgICAgb2JqID0gb2JqLnNsaWNlKCk7XFxuXFxuICAgICAgICBmb3IgKHQxID0gMCwgdDIgPSBvYmoubGVuZ3RoOyB0MSA8IHQyOyB0MSsrKSB7XFxuICAgICAgICAgIHRoaXMuZGlzYWJsZV9ub2RlKG9ialt0MV0pO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgfVxcblxcbiAgICAgIG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXG4gICAgICBpZiAoIW9iaiB8fCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgb2JqLnN0YXRlLmRpc2FibGVkID0gdHJ1ZTtcXG4gICAgICB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSkuY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuYWRkQ2xhc3MoJ2pzdHJlZS1kaXNhYmxlZCcpLmF0dHIoJ2FyaWEtZGlzYWJsZWQnLCB0cnVlKTtcXG4gICAgICAvKipcXG4gICAgICAgKiB0cmlnZ2VyZWQgd2hlbiBhbiBub2RlIGlzIGRpc2FibGVkXFxuICAgICAgICogQGV2ZW50XFxuICAgICAgICogQG5hbWUgZGlzYWJsZV9ub2RlLmpzdHJlZVxcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIHRoZSBkaXNhYmxlZCBub2RlXFxuICAgICAgICovXFxuXFxuICAgICAgdGhpcy50cmlnZ2VyKCdkaXNhYmxlX25vZGUnLCB7XFxuICAgICAgICAnbm9kZSc6IG9ialxcbiAgICAgIH0pO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogZGV0ZXJtaW5lcyBpZiBhIG5vZGUgaXMgaGlkZGVuXFxuICAgICAqIEBuYW1lIGlzX2hpZGRlbihvYmopXFxuICAgICAqIEBwYXJhbSB7bWl4ZWR9IG9iaiB0aGUgbm9kZVxcbiAgICAgKi9cXG4gICAgaXNfaGlkZGVuOiBmdW5jdGlvbiBpc19oaWRkZW4ob2JqKSB7XFxuICAgICAgb2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xcbiAgICAgIHJldHVybiBvYmouc3RhdGUuaGlkZGVuID09PSB0cnVlO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogaGlkZXMgYSBub2RlIC0gaXQgaXMgc3RpbGwgaW4gdGhlIHN0cnVjdHVyZSBidXQgd2lsbCBub3QgYmUgdmlzaWJsZVxcbiAgICAgKiBAbmFtZSBoaWRlX25vZGUob2JqKVxcbiAgICAgKiBAcGFyYW0ge21peGVkfSBvYmogdGhlIG5vZGUgdG8gaGlkZVxcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNraXBfcmVkcmF3IGludGVybmFsIHBhcmFtZXRlciBjb250cm9sbGluZyBpZiByZWRyYXcgaXMgY2FsbGVkXFxuICAgICAqIEB0cmlnZ2VyIGhpZGVfbm9kZS5qc3RyZWVcXG4gICAgICovXFxuICAgIGhpZGVfbm9kZTogZnVuY3Rpb24gaGlkZV9ub2RlKG9iaiwgc2tpcF9yZWRyYXcpIHtcXG4gICAgICB2YXIgdDEsIHQyO1xcblxcbiAgICAgIGlmICgkLmlzQXJyYXkob2JqKSkge1xcbiAgICAgICAgb2JqID0gb2JqLnNsaWNlKCk7XFxuXFxuICAgICAgICBmb3IgKHQxID0gMCwgdDIgPSBvYmoubGVuZ3RoOyB0MSA8IHQyOyB0MSsrKSB7XFxuICAgICAgICAgIHRoaXMuaGlkZV9ub2RlKG9ialt0MV0sIHRydWUpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKCFza2lwX3JlZHJhdykge1xcbiAgICAgICAgICB0aGlzLnJlZHJhdygpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgfVxcblxcbiAgICAgIG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXG4gICAgICBpZiAoIW9iaiB8fCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCFvYmouc3RhdGUuaGlkZGVuKSB7XFxuICAgICAgICBvYmouc3RhdGUuaGlkZGVuID0gdHJ1ZTtcXG5cXG4gICAgICAgIHRoaXMuX25vZGVfY2hhbmdlZChvYmoucGFyZW50KTtcXG5cXG4gICAgICAgIGlmICghc2tpcF9yZWRyYXcpIHtcXG4gICAgICAgICAgdGhpcy5yZWRyYXcoKTtcXG4gICAgICAgIH1cXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogdHJpZ2dlcmVkIHdoZW4gYW4gbm9kZSBpcyBoaWRkZW5cXG4gICAgICAgICAqIEBldmVudFxcbiAgICAgICAgICogQG5hbWUgaGlkZV9ub2RlLmpzdHJlZVxcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGUgdGhlIGhpZGRlbiBub2RlXFxuICAgICAgICAgKi9cXG5cXG5cXG4gICAgICAgIHRoaXMudHJpZ2dlcignaGlkZV9ub2RlJywge1xcbiAgICAgICAgICAnbm9kZSc6IG9ialxcbiAgICAgICAgfSk7XFxuICAgICAgfVxcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogc2hvd3MgYSBub2RlXFxuICAgICAqIEBuYW1lIHNob3dfbm9kZShvYmopXFxuICAgICAqIEBwYXJhbSB7bWl4ZWR9IG9iaiB0aGUgbm9kZSB0byBzaG93XFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2tpcF9yZWRyYXcgaW50ZXJuYWwgcGFyYW1ldGVyIGNvbnRyb2xsaW5nIGlmIHJlZHJhdyBpcyBjYWxsZWRcXG4gICAgICogQHRyaWdnZXIgc2hvd19ub2RlLmpzdHJlZVxcbiAgICAgKi9cXG4gICAgc2hvd19ub2RlOiBmdW5jdGlvbiBzaG93X25vZGUob2JqLCBza2lwX3JlZHJhdykge1xcbiAgICAgIHZhciB0MSwgdDI7XFxuXFxuICAgICAgaWYgKCQuaXNBcnJheShvYmopKSB7XFxuICAgICAgICBvYmogPSBvYmouc2xpY2UoKTtcXG5cXG4gICAgICAgIGZvciAodDEgPSAwLCB0MiA9IG9iai5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcXG4gICAgICAgICAgdGhpcy5zaG93X25vZGUob2JqW3QxXSwgdHJ1ZSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoIXNraXBfcmVkcmF3KSB7XFxuICAgICAgICAgIHRoaXMucmVkcmF3KCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICB9XFxuXFxuICAgICAgb2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xcblxcbiAgICAgIGlmICghb2JqIHx8IG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCkge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAob2JqLnN0YXRlLmhpZGRlbikge1xcbiAgICAgICAgb2JqLnN0YXRlLmhpZGRlbiA9IGZhbHNlO1xcblxcbiAgICAgICAgdGhpcy5fbm9kZV9jaGFuZ2VkKG9iai5wYXJlbnQpO1xcblxcbiAgICAgICAgaWYgKCFza2lwX3JlZHJhdykge1xcbiAgICAgICAgICB0aGlzLnJlZHJhdygpO1xcbiAgICAgICAgfVxcbiAgICAgICAgLyoqXFxuICAgICAgICAgKiB0cmlnZ2VyZWQgd2hlbiBhbiBub2RlIGlzIHNob3duXFxuICAgICAgICAgKiBAZXZlbnRcXG4gICAgICAgICAqIEBuYW1lIHNob3dfbm9kZS5qc3RyZWVcXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIHRoZSBzaG93biBub2RlXFxuICAgICAgICAgKi9cXG5cXG5cXG4gICAgICAgIHRoaXMudHJpZ2dlcignc2hvd19ub2RlJywge1xcbiAgICAgICAgICAnbm9kZSc6IG9ialxcbiAgICAgICAgfSk7XFxuICAgICAgfVxcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogaGlkZXMgYWxsIG5vZGVzXFxuICAgICAqIEBuYW1lIGhpZGVfYWxsKClcXG4gICAgICogQHRyaWdnZXIgaGlkZV9hbGwuanN0cmVlXFxuICAgICAqL1xcbiAgICBoaWRlX2FsbDogZnVuY3Rpb24gaGlkZV9hbGwoc2tpcF9yZWRyYXcpIHtcXG4gICAgICB2YXIgaSxcXG4gICAgICAgICAgbSA9IHRoaXMuX21vZGVsLmRhdGEsXFxuICAgICAgICAgIGlkcyA9IFtdO1xcblxcbiAgICAgIGZvciAoaSBpbiBtKSB7XFxuICAgICAgICBpZiAobS5oYXNPd25Qcm9wZXJ0eShpKSAmJiBpICE9PSAkLmpzdHJlZS5yb290ICYmICFtW2ldLnN0YXRlLmhpZGRlbikge1xcbiAgICAgICAgICBtW2ldLnN0YXRlLmhpZGRlbiA9IHRydWU7XFxuICAgICAgICAgIGlkcy5wdXNoKGkpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9tb2RlbC5mb3JjZV9mdWxsX3JlZHJhdyA9IHRydWU7XFxuXFxuICAgICAgaWYgKCFza2lwX3JlZHJhdykge1xcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcXG4gICAgICB9XFxuICAgICAgLyoqXFxuICAgICAgICogdHJpZ2dlcmVkIHdoZW4gYWxsIG5vZGVzIGFyZSBoaWRkZW5cXG4gICAgICAgKiBAZXZlbnRcXG4gICAgICAgKiBAbmFtZSBoaWRlX2FsbC5qc3RyZWVcXG4gICAgICAgKiBAcGFyYW0ge0FycmF5fSBub2RlcyB0aGUgSURzIG9mIGFsbCBoaWRkZW4gbm9kZXNcXG4gICAgICAgKi9cXG5cXG5cXG4gICAgICB0aGlzLnRyaWdnZXIoJ2hpZGVfYWxsJywge1xcbiAgICAgICAgJ25vZGVzJzogaWRzXFxuICAgICAgfSk7XFxuICAgICAgcmV0dXJuIGlkcztcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIHNob3dzIGFsbCBub2Rlc1xcbiAgICAgKiBAbmFtZSBzaG93X2FsbCgpXFxuICAgICAqIEB0cmlnZ2VyIHNob3dfYWxsLmpzdHJlZVxcbiAgICAgKi9cXG4gICAgc2hvd19hbGw6IGZ1bmN0aW9uIHNob3dfYWxsKHNraXBfcmVkcmF3KSB7XFxuICAgICAgdmFyIGksXFxuICAgICAgICAgIG0gPSB0aGlzLl9tb2RlbC5kYXRhLFxcbiAgICAgICAgICBpZHMgPSBbXTtcXG5cXG4gICAgICBmb3IgKGkgaW4gbSkge1xcbiAgICAgICAgaWYgKG0uaGFzT3duUHJvcGVydHkoaSkgJiYgaSAhPT0gJC5qc3RyZWUucm9vdCAmJiBtW2ldLnN0YXRlLmhpZGRlbikge1xcbiAgICAgICAgICBtW2ldLnN0YXRlLmhpZGRlbiA9IGZhbHNlO1xcbiAgICAgICAgICBpZHMucHVzaChpKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fbW9kZWwuZm9yY2VfZnVsbF9yZWRyYXcgPSB0cnVlO1xcblxcbiAgICAgIGlmICghc2tpcF9yZWRyYXcpIHtcXG4gICAgICAgIHRoaXMucmVkcmF3KCk7XFxuICAgICAgfVxcbiAgICAgIC8qKlxcbiAgICAgICAqIHRyaWdnZXJlZCB3aGVuIGFsbCBub2RlcyBhcmUgc2hvd25cXG4gICAgICAgKiBAZXZlbnRcXG4gICAgICAgKiBAbmFtZSBzaG93X2FsbC5qc3RyZWVcXG4gICAgICAgKiBAcGFyYW0ge0FycmF5fSBub2RlcyB0aGUgSURzIG9mIGFsbCBzaG93biBub2Rlc1xcbiAgICAgICAqL1xcblxcblxcbiAgICAgIHRoaXMudHJpZ2dlcignc2hvd19hbGwnLCB7XFxuICAgICAgICAnbm9kZXMnOiBpZHNcXG4gICAgICB9KTtcXG4gICAgICByZXR1cm4gaWRzO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogY2FsbGVkIHdoZW4gYSBub2RlIGlzIHNlbGVjdGVkIGJ5IHRoZSB1c2VyLiBVc2VkIGludGVybmFsbHkuXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBuYW1lIGFjdGl2YXRlX25vZGUob2JqLCBlKVxcbiAgICAgKiBAcGFyYW0ge21peGVkfSBvYmogdGhlIG5vZGVcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGUgdGhlIHJlbGF0ZWQgZXZlbnRcXG4gICAgICogQHRyaWdnZXIgYWN0aXZhdGVfbm9kZS5qc3RyZWUsIGNoYW5nZWQuanN0cmVlXFxuICAgICAqL1xcbiAgICBhY3RpdmF0ZV9ub2RlOiBmdW5jdGlvbiBhY3RpdmF0ZV9ub2RlKG9iaiwgZSkge1xcbiAgICAgIGlmICh0aGlzLmlzX2Rpc2FibGVkKG9iaikpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCFlIHx8IF90eXBlb2YoZSkgIT09ICdvYmplY3QnKSB7XFxuICAgICAgICBlID0ge307XFxuICAgICAgfSAvLyBlbnN1cmUgbGFzdF9jbGlja2VkIGlzIHN0aWxsIGluIHRoZSBET00sIG1ha2UgaXQgZnJlc2ggKG1heWJlIGl0IHdhcyBtb3ZlZD8pIGFuZCBtYWtlIHN1cmUgaXQgaXMgc3RpbGwgc2VsZWN0ZWQsIGlmIG5vdCAtIG1ha2UgbGFzdF9jbGlja2VkIHRoZSBsYXN0IHNlbGVjdGVkIG5vZGVcXG5cXG5cXG4gICAgICB0aGlzLl9kYXRhLmNvcmUubGFzdF9jbGlja2VkID0gdGhpcy5fZGF0YS5jb3JlLmxhc3RfY2xpY2tlZCAmJiB0aGlzLl9kYXRhLmNvcmUubGFzdF9jbGlja2VkLmlkICE9PSB1bmRlZmluZWQgPyB0aGlzLmdldF9ub2RlKHRoaXMuX2RhdGEuY29yZS5sYXN0X2NsaWNrZWQuaWQpIDogbnVsbDtcXG5cXG4gICAgICBpZiAodGhpcy5fZGF0YS5jb3JlLmxhc3RfY2xpY2tlZCAmJiAhdGhpcy5fZGF0YS5jb3JlLmxhc3RfY2xpY2tlZC5zdGF0ZS5zZWxlY3RlZCkge1xcbiAgICAgICAgdGhpcy5fZGF0YS5jb3JlLmxhc3RfY2xpY2tlZCA9IG51bGw7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghdGhpcy5fZGF0YS5jb3JlLmxhc3RfY2xpY2tlZCAmJiB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQubGVuZ3RoKSB7XFxuICAgICAgICB0aGlzLl9kYXRhLmNvcmUubGFzdF9jbGlja2VkID0gdGhpcy5nZXRfbm9kZSh0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWRbdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLmxlbmd0aCAtIDFdKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCF0aGlzLnNldHRpbmdzLmNvcmUubXVsdGlwbGUgfHwgIWUubWV0YUtleSAmJiAhZS5jdHJsS2V5ICYmICFlLnNoaWZ0S2V5IHx8IGUuc2hpZnRLZXkgJiYgKCF0aGlzLl9kYXRhLmNvcmUubGFzdF9jbGlja2VkIHx8ICF0aGlzLmdldF9wYXJlbnQob2JqKSB8fCB0aGlzLmdldF9wYXJlbnQob2JqKSAhPT0gdGhpcy5fZGF0YS5jb3JlLmxhc3RfY2xpY2tlZC5wYXJlbnQpKSB7XFxuICAgICAgICBpZiAoIXRoaXMuc2V0dGluZ3MuY29yZS5tdWx0aXBsZSAmJiAoZS5tZXRhS2V5IHx8IGUuY3RybEtleSB8fCBlLnNoaWZ0S2V5KSAmJiB0aGlzLmlzX3NlbGVjdGVkKG9iaikpIHtcXG4gICAgICAgICAgdGhpcy5kZXNlbGVjdF9ub2RlKG9iaiwgZmFsc2UsIGUpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgdGhpcy5kZXNlbGVjdF9hbGwodHJ1ZSk7XFxuICAgICAgICAgIHRoaXMuc2VsZWN0X25vZGUob2JqLCBmYWxzZSwgZmFsc2UsIGUpO1xcbiAgICAgICAgICB0aGlzLl9kYXRhLmNvcmUubGFzdF9jbGlja2VkID0gdGhpcy5nZXRfbm9kZShvYmopO1xcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBpZiAoZS5zaGlmdEtleSkge1xcbiAgICAgICAgICB2YXIgbyA9IHRoaXMuZ2V0X25vZGUob2JqKS5pZCxcXG4gICAgICAgICAgICAgIGwgPSB0aGlzLl9kYXRhLmNvcmUubGFzdF9jbGlja2VkLmlkLFxcbiAgICAgICAgICAgICAgcCA9IHRoaXMuZ2V0X25vZGUodGhpcy5fZGF0YS5jb3JlLmxhc3RfY2xpY2tlZC5wYXJlbnQpLmNoaWxkcmVuLFxcbiAgICAgICAgICAgICAgYyA9IGZhbHNlLFxcbiAgICAgICAgICAgICAgaSxcXG4gICAgICAgICAgICAgIGo7XFxuXFxuICAgICAgICAgIGZvciAoaSA9IDAsIGogPSBwLmxlbmd0aDsgaSA8IGo7IGkgKz0gMSkge1xcbiAgICAgICAgICAgIC8vIHNlcGFyYXRlIElGcyB3b3JrIHdoZW0gbyBhbmQgbCBhcmUgdGhlIHNhbWVcXG4gICAgICAgICAgICBpZiAocFtpXSA9PT0gbykge1xcbiAgICAgICAgICAgICAgYyA9ICFjO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpZiAocFtpXSA9PT0gbCkge1xcbiAgICAgICAgICAgICAgYyA9ICFjO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNfZGlzYWJsZWQocFtpXSkgJiYgKGMgfHwgcFtpXSA9PT0gbyB8fCBwW2ldID09PSBsKSkge1xcbiAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzX2hpZGRlbihwW2ldKSkge1xcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdF9ub2RlKHBbaV0sIHRydWUsIGZhbHNlLCBlKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgdGhpcy5kZXNlbGVjdF9ub2RlKHBbaV0sIHRydWUsIGUpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZWQnLCB7XFxuICAgICAgICAgICAgJ2FjdGlvbic6ICdzZWxlY3Rfbm9kZScsXFxuICAgICAgICAgICAgJ25vZGUnOiB0aGlzLmdldF9ub2RlKG9iaiksXFxuICAgICAgICAgICAgJ3NlbGVjdGVkJzogdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLFxcbiAgICAgICAgICAgICdldmVudCc6IGVcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBpZiAoIXRoaXMuaXNfc2VsZWN0ZWQob2JqKSkge1xcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0X25vZGUob2JqLCBmYWxzZSwgZmFsc2UsIGUpO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHRoaXMuZGVzZWxlY3Rfbm9kZShvYmosIGZhbHNlLCBlKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICAvKipcXG4gICAgICAgKiB0cmlnZ2VyZWQgd2hlbiBhbiBub2RlIGlzIGNsaWNrZWQgb3IgaW50ZXJjYXRlZCB3aXRoIGJ5IHRoZSB1c2VyXFxuICAgICAgICogQGV2ZW50XFxuICAgICAgICogQG5hbWUgYWN0aXZhdGVfbm9kZS5qc3RyZWVcXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZVxcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCB0aGUgb29yaWdpbmFsIGV2ZW50IChpZiBhbnkpIHdoaWNoIHRyaWdnZXJlZCB0aGUgY2FsbCAobWF5IGJlIGFuIGVtcHR5IG9iamVjdClcXG4gICAgICAgKi9cXG5cXG5cXG4gICAgICB0aGlzLnRyaWdnZXIoJ2FjdGl2YXRlX25vZGUnLCB7XFxuICAgICAgICAnbm9kZSc6IHRoaXMuZ2V0X25vZGUob2JqKSxcXG4gICAgICAgICdldmVudCc6IGVcXG4gICAgICB9KTtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIGFwcGxpZXMgdGhlIGhvdmVyIHN0YXRlIG9uIGEgbm9kZSwgY2FsbGVkIHdoZW4gYSBub2RlIGlzIGhvdmVyZWQgYnkgdGhlIHVzZXIuIFVzZWQgaW50ZXJuYWxseS5cXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQG5hbWUgaG92ZXJfbm9kZShvYmopXFxuICAgICAqIEBwYXJhbSB7bWl4ZWR9IG9ialxcbiAgICAgKiBAdHJpZ2dlciBob3Zlcl9ub2RlLmpzdHJlZVxcbiAgICAgKi9cXG4gICAgaG92ZXJfbm9kZTogZnVuY3Rpb24gaG92ZXJfbm9kZShvYmopIHtcXG4gICAgICBvYmogPSB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSk7XFxuXFxuICAgICAgaWYgKCFvYmogfHwgIW9iai5sZW5ndGggfHwgb2JqLmNoaWxkcmVuKCcuanN0cmVlLWhvdmVyZWQnKS5sZW5ndGgpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIG8gPSB0aGlzLmVsZW1lbnQuZmluZCgnLmpzdHJlZS1ob3ZlcmVkJyksXFxuICAgICAgICAgIHQgPSB0aGlzLmVsZW1lbnQ7XFxuXFxuICAgICAgaWYgKG8gJiYgby5sZW5ndGgpIHtcXG4gICAgICAgIHRoaXMuZGVob3Zlcl9ub2RlKG8pO1xcbiAgICAgIH1cXG5cXG4gICAgICBvYmouY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuYWRkQ2xhc3MoJ2pzdHJlZS1ob3ZlcmVkJyk7XFxuICAgICAgLyoqXFxuICAgICAgICogdHJpZ2dlcmVkIHdoZW4gYW4gbm9kZSBpcyBob3ZlcmVkXFxuICAgICAgICogQGV2ZW50XFxuICAgICAgICogQG5hbWUgaG92ZXJfbm9kZS5qc3RyZWVcXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZVxcbiAgICAgICAqL1xcblxcbiAgICAgIHRoaXMudHJpZ2dlcignaG92ZXJfbm9kZScsIHtcXG4gICAgICAgICdub2RlJzogdGhpcy5nZXRfbm9kZShvYmopXFxuICAgICAgfSk7XFxuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgICB0LmF0dHIoJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCcsIG9ialswXS5pZCk7XFxuICAgICAgfSwgMCk7XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiByZW1vdmVzIHRoZSBob3ZlciBzdGF0ZSBmcm9tIGEgbm9kZWNhbGxlZCB3aGVuIGEgbm9kZSBpcyBubyBsb25nZXIgaG92ZXJlZCBieSB0aGUgdXNlci4gVXNlZCBpbnRlcm5hbGx5LlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAbmFtZSBkZWhvdmVyX25vZGUob2JqKVxcbiAgICAgKiBAcGFyYW0ge21peGVkfSBvYmpcXG4gICAgICogQHRyaWdnZXIgZGVob3Zlcl9ub2RlLmpzdHJlZVxcbiAgICAgKi9cXG4gICAgZGVob3Zlcl9ub2RlOiBmdW5jdGlvbiBkZWhvdmVyX25vZGUob2JqKSB7XFxuICAgICAgb2JqID0gdGhpcy5nZXRfbm9kZShvYmosIHRydWUpO1xcblxcbiAgICAgIGlmICghb2JqIHx8ICFvYmoubGVuZ3RoIHx8ICFvYmouY2hpbGRyZW4oJy5qc3RyZWUtaG92ZXJlZCcpLmxlbmd0aCkge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICBvYmouY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykucmVtb3ZlQ2xhc3MoJ2pzdHJlZS1ob3ZlcmVkJyk7XFxuICAgICAgLyoqXFxuICAgICAgICogdHJpZ2dlcmVkIHdoZW4gYW4gbm9kZSBpcyBubyBsb25nZXIgaG92ZXJlZFxcbiAgICAgICAqIEBldmVudFxcbiAgICAgICAqIEBuYW1lIGRlaG92ZXJfbm9kZS5qc3RyZWVcXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZVxcbiAgICAgICAqL1xcblxcbiAgICAgIHRoaXMudHJpZ2dlcignZGVob3Zlcl9ub2RlJywge1xcbiAgICAgICAgJ25vZGUnOiB0aGlzLmdldF9ub2RlKG9iailcXG4gICAgICB9KTtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIHNlbGVjdCBhIG5vZGVcXG4gICAgICogQG5hbWUgc2VsZWN0X25vZGUob2JqIFssIHN1cHJlc3NfZXZlbnQsIHByZXZlbnRfb3Blbl0pXFxuICAgICAqIEBwYXJhbSB7bWl4ZWR9IG9iaiBhbiBhcnJheSBjYW4gYmUgdXNlZCB0byBzZWxlY3QgbXVsdGlwbGUgbm9kZXNcXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzdXByZXNzX2V2ZW50IGlmIHNldCB0byBgdHJ1ZWAgdGhlIGBjaGFuZ2VkLmpzdHJlZWAgZXZlbnQgd29uJ3QgYmUgdHJpZ2dlcmVkXFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcHJldmVudF9vcGVuIGlmIHNldCB0byBgdHJ1ZWAgcGFyZW50cyBvZiB0aGUgc2VsZWN0ZWQgbm9kZSB3b24ndCBiZSBvcGVuZWRcXG4gICAgICogQHRyaWdnZXIgc2VsZWN0X25vZGUuanN0cmVlLCBjaGFuZ2VkLmpzdHJlZVxcbiAgICAgKi9cXG4gICAgc2VsZWN0X25vZGU6IGZ1bmN0aW9uIHNlbGVjdF9ub2RlKG9iaiwgc3VwcmVzc19ldmVudCwgcHJldmVudF9vcGVuLCBlKSB7XFxuICAgICAgdmFyIGRvbSwgdDEsIHQyLCB0aDtcXG5cXG4gICAgICBpZiAoJC5pc0FycmF5KG9iaikpIHtcXG4gICAgICAgIG9iaiA9IG9iai5zbGljZSgpO1xcblxcbiAgICAgICAgZm9yICh0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xcbiAgICAgICAgICB0aGlzLnNlbGVjdF9ub2RlKG9ialt0MV0sIHN1cHJlc3NfZXZlbnQsIHByZXZlbnRfb3BlbiwgZSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICB9XFxuXFxuICAgICAgb2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xcblxcbiAgICAgIGlmICghb2JqIHx8IG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCkge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICBkb20gPSB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSk7XFxuXFxuICAgICAgaWYgKCFvYmouc3RhdGUuc2VsZWN0ZWQpIHtcXG4gICAgICAgIG9iai5zdGF0ZS5zZWxlY3RlZCA9IHRydWU7XFxuXFxuICAgICAgICB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQucHVzaChvYmouaWQpO1xcblxcbiAgICAgICAgaWYgKCFwcmV2ZW50X29wZW4pIHtcXG4gICAgICAgICAgZG9tID0gdGhpcy5fb3Blbl90byhvYmopO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKGRvbSAmJiBkb20ubGVuZ3RoKSB7XFxuICAgICAgICAgIGRvbS5hdHRyKCdhcmlhLXNlbGVjdGVkJywgdHJ1ZSkuY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuYWRkQ2xhc3MoJ2pzdHJlZS1jbGlja2VkJyk7XFxuICAgICAgICB9XFxuICAgICAgICAvKipcXG4gICAgICAgICAqIHRyaWdnZXJlZCB3aGVuIGFuIG5vZGUgaXMgc2VsZWN0ZWRcXG4gICAgICAgICAqIEBldmVudFxcbiAgICAgICAgICogQG5hbWUgc2VsZWN0X25vZGUuanN0cmVlXFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZVxcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gc2VsZWN0ZWQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uXFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgdGhlIGV2ZW50IChpZiBhbnkpIHRoYXQgdHJpZ2dlcmVkIHRoaXMgc2VsZWN0X25vZGVcXG4gICAgICAgICAqL1xcblxcblxcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdzZWxlY3Rfbm9kZScsIHtcXG4gICAgICAgICAgJ25vZGUnOiBvYmosXFxuICAgICAgICAgICdzZWxlY3RlZCc6IHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZCxcXG4gICAgICAgICAgJ2V2ZW50JzogZVxcbiAgICAgICAgfSk7XFxuXFxuICAgICAgICBpZiAoIXN1cHJlc3NfZXZlbnQpIHtcXG4gICAgICAgICAgLyoqXFxuICAgICAgICAgICAqIHRyaWdnZXJlZCB3aGVuIHNlbGVjdGlvbiBjaGFuZ2VzXFxuICAgICAgICAgICAqIEBldmVudFxcbiAgICAgICAgICAgKiBAbmFtZSBjaGFuZ2VkLmpzdHJlZVxcbiAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZVxcbiAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gYWN0aW9uIHRoZSBhY3Rpb24gdGhhdCBjYXVzZWQgdGhlIHNlbGVjdGlvbiB0byBjaGFuZ2VcXG4gICAgICAgICAgICogQHBhcmFtIHtBcnJheX0gc2VsZWN0ZWQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uXFxuICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCB0aGUgZXZlbnQgKGlmIGFueSkgdGhhdCB0cmlnZ2VyZWQgdGhpcyBjaGFuZ2VkIGV2ZW50XFxuICAgICAgICAgICAqL1xcbiAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZWQnLCB7XFxuICAgICAgICAgICAgJ2FjdGlvbic6ICdzZWxlY3Rfbm9kZScsXFxuICAgICAgICAgICAgJ25vZGUnOiBvYmosXFxuICAgICAgICAgICAgJ3NlbGVjdGVkJzogdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLFxcbiAgICAgICAgICAgICdldmVudCc6IGVcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogZGVzZWxlY3QgYSBub2RlXFxuICAgICAqIEBuYW1lIGRlc2VsZWN0X25vZGUob2JqIFssIHN1cHJlc3NfZXZlbnRdKVxcbiAgICAgKiBAcGFyYW0ge21peGVkfSBvYmogYW4gYXJyYXkgY2FuIGJlIHVzZWQgdG8gZGVzZWxlY3QgbXVsdGlwbGUgbm9kZXNcXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzdXByZXNzX2V2ZW50IGlmIHNldCB0byBgdHJ1ZWAgdGhlIGBjaGFuZ2VkLmpzdHJlZWAgZXZlbnQgd29uJ3QgYmUgdHJpZ2dlcmVkXFxuICAgICAqIEB0cmlnZ2VyIGRlc2VsZWN0X25vZGUuanN0cmVlLCBjaGFuZ2VkLmpzdHJlZVxcbiAgICAgKi9cXG4gICAgZGVzZWxlY3Rfbm9kZTogZnVuY3Rpb24gZGVzZWxlY3Rfbm9kZShvYmosIHN1cHJlc3NfZXZlbnQsIGUpIHtcXG4gICAgICB2YXIgdDEsIHQyLCBkb207XFxuXFxuICAgICAgaWYgKCQuaXNBcnJheShvYmopKSB7XFxuICAgICAgICBvYmogPSBvYmouc2xpY2UoKTtcXG5cXG4gICAgICAgIGZvciAodDEgPSAwLCB0MiA9IG9iai5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcXG4gICAgICAgICAgdGhpcy5kZXNlbGVjdF9ub2RlKG9ialt0MV0sIHN1cHJlc3NfZXZlbnQsIGUpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgfVxcblxcbiAgICAgIG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXG4gICAgICBpZiAoIW9iaiB8fCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgZG9tID0gdGhpcy5nZXRfbm9kZShvYmosIHRydWUpO1xcblxcbiAgICAgIGlmIChvYmouc3RhdGUuc2VsZWN0ZWQpIHtcXG4gICAgICAgIG9iai5zdGF0ZS5zZWxlY3RlZCA9IGZhbHNlO1xcbiAgICAgICAgdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkID0gJC52YWthdGEuYXJyYXlfcmVtb3ZlX2l0ZW0odGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLCBvYmouaWQpO1xcblxcbiAgICAgICAgaWYgKGRvbS5sZW5ndGgpIHtcXG4gICAgICAgICAgZG9tLmF0dHIoJ2FyaWEtc2VsZWN0ZWQnLCBmYWxzZSkuY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykucmVtb3ZlQ2xhc3MoJ2pzdHJlZS1jbGlja2VkJyk7XFxuICAgICAgICB9XFxuICAgICAgICAvKipcXG4gICAgICAgICAqIHRyaWdnZXJlZCB3aGVuIGFuIG5vZGUgaXMgZGVzZWxlY3RlZFxcbiAgICAgICAgICogQGV2ZW50XFxuICAgICAgICAgKiBAbmFtZSBkZXNlbGVjdF9ub2RlLmpzdHJlZVxcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGVcXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IHNlbGVjdGVkIHRoZSBjdXJyZW50IHNlbGVjdGlvblxcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IHRoZSBldmVudCAoaWYgYW55KSB0aGF0IHRyaWdnZXJlZCB0aGlzIGRlc2VsZWN0X25vZGVcXG4gICAgICAgICAqL1xcblxcblxcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdkZXNlbGVjdF9ub2RlJywge1xcbiAgICAgICAgICAnbm9kZSc6IG9iaixcXG4gICAgICAgICAgJ3NlbGVjdGVkJzogdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLFxcbiAgICAgICAgICAnZXZlbnQnOiBlXFxuICAgICAgICB9KTtcXG5cXG4gICAgICAgIGlmICghc3VwcmVzc19ldmVudCkge1xcbiAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZWQnLCB7XFxuICAgICAgICAgICAgJ2FjdGlvbic6ICdkZXNlbGVjdF9ub2RlJyxcXG4gICAgICAgICAgICAnbm9kZSc6IG9iaixcXG4gICAgICAgICAgICAnc2VsZWN0ZWQnOiB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQsXFxuICAgICAgICAgICAgJ2V2ZW50JzogZVxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBzZWxlY3QgYWxsIG5vZGVzIGluIHRoZSB0cmVlXFxuICAgICAqIEBuYW1lIHNlbGVjdF9hbGwoW3N1cHJlc3NfZXZlbnRdKVxcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHN1cHJlc3NfZXZlbnQgaWYgc2V0IHRvIGB0cnVlYCB0aGUgYGNoYW5nZWQuanN0cmVlYCBldmVudCB3b24ndCBiZSB0cmlnZ2VyZWRcXG4gICAgICogQHRyaWdnZXIgc2VsZWN0X2FsbC5qc3RyZWUsIGNoYW5nZWQuanN0cmVlXFxuICAgICAqL1xcbiAgICBzZWxlY3RfYWxsOiBmdW5jdGlvbiBzZWxlY3RfYWxsKHN1cHJlc3NfZXZlbnQpIHtcXG4gICAgICB2YXIgdG1wID0gdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLmNvbmNhdChbXSksXFxuICAgICAgICAgIGksXFxuICAgICAgICAgIGo7XFxuXFxuICAgICAgdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkID0gdGhpcy5fbW9kZWwuZGF0YVskLmpzdHJlZS5yb290XS5jaGlsZHJlbl9kLmNvbmNhdCgpO1xcblxcbiAgICAgIGZvciAoaSA9IDAsIGogPSB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICBpZiAodGhpcy5fbW9kZWwuZGF0YVt0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWRbaV1dKSB7XFxuICAgICAgICAgIHRoaXMuX21vZGVsLmRhdGFbdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkW2ldXS5zdGF0ZS5zZWxlY3RlZCA9IHRydWU7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMucmVkcmF3KHRydWUpO1xcbiAgICAgIC8qKlxcbiAgICAgICAqIHRyaWdnZXJlZCB3aGVuIGFsbCBub2RlcyBhcmUgc2VsZWN0ZWRcXG4gICAgICAgKiBAZXZlbnRcXG4gICAgICAgKiBAbmFtZSBzZWxlY3RfYWxsLmpzdHJlZVxcbiAgICAgICAqIEBwYXJhbSB7QXJyYXl9IHNlbGVjdGVkIHRoZSBjdXJyZW50IHNlbGVjdGlvblxcbiAgICAgICAqL1xcblxcbiAgICAgIHRoaXMudHJpZ2dlcignc2VsZWN0X2FsbCcsIHtcXG4gICAgICAgICdzZWxlY3RlZCc6IHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZFxcbiAgICAgIH0pO1xcblxcbiAgICAgIGlmICghc3VwcmVzc19ldmVudCkge1xcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdjaGFuZ2VkJywge1xcbiAgICAgICAgICAnYWN0aW9uJzogJ3NlbGVjdF9hbGwnLFxcbiAgICAgICAgICAnc2VsZWN0ZWQnOiB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQsXFxuICAgICAgICAgICdvbGRfc2VsZWN0aW9uJzogdG1wXFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBkZXNlbGVjdCBhbGwgc2VsZWN0ZWQgbm9kZXNcXG4gICAgICogQG5hbWUgZGVzZWxlY3RfYWxsKFtzdXByZXNzX2V2ZW50XSlcXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzdXByZXNzX2V2ZW50IGlmIHNldCB0byBgdHJ1ZWAgdGhlIGBjaGFuZ2VkLmpzdHJlZWAgZXZlbnQgd29uJ3QgYmUgdHJpZ2dlcmVkXFxuICAgICAqIEB0cmlnZ2VyIGRlc2VsZWN0X2FsbC5qc3RyZWUsIGNoYW5nZWQuanN0cmVlXFxuICAgICAqL1xcbiAgICBkZXNlbGVjdF9hbGw6IGZ1bmN0aW9uIGRlc2VsZWN0X2FsbChzdXByZXNzX2V2ZW50KSB7XFxuICAgICAgdmFyIHRtcCA9IHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZC5jb25jYXQoW10pLFxcbiAgICAgICAgICBpLFxcbiAgICAgICAgICBqO1xcblxcbiAgICAgIGZvciAoaSA9IDAsIGogPSB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICBpZiAodGhpcy5fbW9kZWwuZGF0YVt0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWRbaV1dKSB7XFxuICAgICAgICAgIHRoaXMuX21vZGVsLmRhdGFbdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkW2ldXS5zdGF0ZS5zZWxlY3RlZCA9IGZhbHNlO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQgPSBbXTtcXG4gICAgICB0aGlzLmVsZW1lbnQuZmluZCgnLmpzdHJlZS1jbGlja2VkJykucmVtb3ZlQ2xhc3MoJ2pzdHJlZS1jbGlja2VkJykucGFyZW50KCkuYXR0cignYXJpYS1zZWxlY3RlZCcsIGZhbHNlKTtcXG4gICAgICAvKipcXG4gICAgICAgKiB0cmlnZ2VyZWQgd2hlbiBhbGwgbm9kZXMgYXJlIGRlc2VsZWN0ZWRcXG4gICAgICAgKiBAZXZlbnRcXG4gICAgICAgKiBAbmFtZSBkZXNlbGVjdF9hbGwuanN0cmVlXFxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGUgdGhlIHByZXZpb3VzIHNlbGVjdGlvblxcbiAgICAgICAqIEBwYXJhbSB7QXJyYXl9IHNlbGVjdGVkIHRoZSBjdXJyZW50IHNlbGVjdGlvblxcbiAgICAgICAqL1xcblxcbiAgICAgIHRoaXMudHJpZ2dlcignZGVzZWxlY3RfYWxsJywge1xcbiAgICAgICAgJ3NlbGVjdGVkJzogdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLFxcbiAgICAgICAgJ25vZGUnOiB0bXBcXG4gICAgICB9KTtcXG5cXG4gICAgICBpZiAoIXN1cHJlc3NfZXZlbnQpIHtcXG4gICAgICAgIHRoaXMudHJpZ2dlcignY2hhbmdlZCcsIHtcXG4gICAgICAgICAgJ2FjdGlvbic6ICdkZXNlbGVjdF9hbGwnLFxcbiAgICAgICAgICAnc2VsZWN0ZWQnOiB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQsXFxuICAgICAgICAgICdvbGRfc2VsZWN0aW9uJzogdG1wXFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBjaGVja3MgaWYgYSBub2RlIGlzIHNlbGVjdGVkXFxuICAgICAqIEBuYW1lIGlzX3NlbGVjdGVkKG9iailcXG4gICAgICogQHBhcmFtICB7bWl4ZWR9ICBvYmpcXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cXG4gICAgICovXFxuICAgIGlzX3NlbGVjdGVkOiBmdW5jdGlvbiBpc19zZWxlY3RlZChvYmopIHtcXG4gICAgICBvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XFxuXFxuICAgICAgaWYgKCFvYmogfHwgb2JqLmlkID09PSAkLmpzdHJlZS5yb290KSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBvYmouc3RhdGUuc2VsZWN0ZWQ7XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBnZXQgYW4gYXJyYXkgb2YgYWxsIHNlbGVjdGVkIG5vZGVzXFxuICAgICAqIEBuYW1lIGdldF9zZWxlY3RlZChbZnVsbF0pXFxuICAgICAqIEBwYXJhbSAge21peGVkfSAgZnVsbCBpZiBzZXQgdG8gYHRydWVgIHRoZSByZXR1cm5lZCBhcnJheSB3aWxsIGNvbnNpc3Qgb2YgdGhlIGZ1bGwgbm9kZSBvYmplY3RzLCBvdGhlcndpc2UgLSBvbmx5IElEcyB3aWxsIGJlIHJldHVybmVkXFxuICAgICAqIEByZXR1cm4ge0FycmF5fVxcbiAgICAgKi9cXG4gICAgZ2V0X3NlbGVjdGVkOiBmdW5jdGlvbiBnZXRfc2VsZWN0ZWQoZnVsbCkge1xcbiAgICAgIHJldHVybiBmdWxsID8gJC5tYXAodGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLCAkLnByb3h5KGZ1bmN0aW9uIChpKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5nZXRfbm9kZShpKTtcXG4gICAgICB9LCB0aGlzKSkgOiB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQuc2xpY2UoKTtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIGdldCBhbiBhcnJheSBvZiBhbGwgdG9wIGxldmVsIHNlbGVjdGVkIG5vZGVzIChpZ25vcmluZyBjaGlsZHJlbiBvZiBzZWxlY3RlZCBub2RlcylcXG4gICAgICogQG5hbWUgZ2V0X3RvcF9zZWxlY3RlZChbZnVsbF0pXFxuICAgICAqIEBwYXJhbSAge21peGVkfSAgZnVsbCBpZiBzZXQgdG8gYHRydWVgIHRoZSByZXR1cm5lZCBhcnJheSB3aWxsIGNvbnNpc3Qgb2YgdGhlIGZ1bGwgbm9kZSBvYmplY3RzLCBvdGhlcndpc2UgLSBvbmx5IElEcyB3aWxsIGJlIHJldHVybmVkXFxuICAgICAqIEByZXR1cm4ge0FycmF5fVxcbiAgICAgKi9cXG4gICAgZ2V0X3RvcF9zZWxlY3RlZDogZnVuY3Rpb24gZ2V0X3RvcF9zZWxlY3RlZChmdWxsKSB7XFxuICAgICAgdmFyIHRtcCA9IHRoaXMuZ2V0X3NlbGVjdGVkKHRydWUpLFxcbiAgICAgICAgICBvYmogPSB7fSxcXG4gICAgICAgICAgaSxcXG4gICAgICAgICAgaixcXG4gICAgICAgICAgayxcXG4gICAgICAgICAgbDtcXG5cXG4gICAgICBmb3IgKGkgPSAwLCBqID0gdG1wLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcbiAgICAgICAgb2JqW3RtcFtpXS5pZF0gPSB0bXBbaV07XFxuICAgICAgfVxcblxcbiAgICAgIGZvciAoaSA9IDAsIGogPSB0bXAubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICBmb3IgKGsgPSAwLCBsID0gdG1wW2ldLmNoaWxkcmVuX2QubGVuZ3RoOyBrIDwgbDsgaysrKSB7XFxuICAgICAgICAgIGlmIChvYmpbdG1wW2ldLmNoaWxkcmVuX2Rba11dKSB7XFxuICAgICAgICAgICAgZGVsZXRlIG9ialt0bXBbaV0uY2hpbGRyZW5fZFtrXV07XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgdG1wID0gW107XFxuXFxuICAgICAgZm9yIChpIGluIG9iaikge1xcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShpKSkge1xcbiAgICAgICAgICB0bXAucHVzaChpKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIGZ1bGwgPyAkLm1hcCh0bXAsICQucHJveHkoZnVuY3Rpb24gKGkpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLmdldF9ub2RlKGkpO1xcbiAgICAgIH0sIHRoaXMpKSA6IHRtcDtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIGdldCBhbiBhcnJheSBvZiBhbGwgYm90dG9tIGxldmVsIHNlbGVjdGVkIG5vZGVzIChpZ25vcmluZyBzZWxlY3RlZCBwYXJlbnRzKVxcbiAgICAgKiBAbmFtZSBnZXRfYm90dG9tX3NlbGVjdGVkKFtmdWxsXSlcXG4gICAgICogQHBhcmFtICB7bWl4ZWR9ICBmdWxsIGlmIHNldCB0byBgdHJ1ZWAgdGhlIHJldHVybmVkIGFycmF5IHdpbGwgY29uc2lzdCBvZiB0aGUgZnVsbCBub2RlIG9iamVjdHMsIG90aGVyd2lzZSAtIG9ubHkgSURzIHdpbGwgYmUgcmV0dXJuZWRcXG4gICAgICogQHJldHVybiB7QXJyYXl9XFxuICAgICAqL1xcbiAgICBnZXRfYm90dG9tX3NlbGVjdGVkOiBmdW5jdGlvbiBnZXRfYm90dG9tX3NlbGVjdGVkKGZ1bGwpIHtcXG4gICAgICB2YXIgdG1wID0gdGhpcy5nZXRfc2VsZWN0ZWQodHJ1ZSksXFxuICAgICAgICAgIG9iaiA9IFtdLFxcbiAgICAgICAgICBpLFxcbiAgICAgICAgICBqO1xcblxcbiAgICAgIGZvciAoaSA9IDAsIGogPSB0bXAubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICBpZiAoIXRtcFtpXS5jaGlsZHJlbi5sZW5ndGgpIHtcXG4gICAgICAgICAgb2JqLnB1c2godG1wW2ldLmlkKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIGZ1bGwgPyAkLm1hcChvYmosICQucHJveHkoZnVuY3Rpb24gKGkpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLmdldF9ub2RlKGkpO1xcbiAgICAgIH0sIHRoaXMpKSA6IG9iajtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIGdldHMgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHRyZWUgc28gdGhhdCBpdCBjYW4gYmUgcmVzdG9yZWQgbGF0ZXIgd2l0aCBgc2V0X3N0YXRlKHN0YXRlKWAuIFVzZWQgaW50ZXJuYWxseS5cXG4gICAgICogQG5hbWUgZ2V0X3N0YXRlKClcXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxcbiAgICAgKi9cXG4gICAgZ2V0X3N0YXRlOiBmdW5jdGlvbiBnZXRfc3RhdGUoKSB7XFxuICAgICAgdmFyIHN0YXRlID0ge1xcbiAgICAgICAgJ2NvcmUnOiB7XFxuICAgICAgICAgICdvcGVuJzogW10sXFxuICAgICAgICAgICdzY3JvbGwnOiB7XFxuICAgICAgICAgICAgJ2xlZnQnOiB0aGlzLmVsZW1lbnQuc2Nyb2xsTGVmdCgpLFxcbiAgICAgICAgICAgICd0b3AnOiB0aGlzLmVsZW1lbnQuc2Nyb2xsVG9wKClcXG4gICAgICAgICAgfSxcXG5cXG4gICAgICAgICAgLyohXFxuICAgICAgICAgICd0aGVtZXMnIDoge1xcbiAgICAgICAgICBcXHQnbmFtZScgOiB0aGlzLmdldF90aGVtZSgpLFxcbiAgICAgICAgICBcXHQnaWNvbnMnIDogdGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5pY29ucyxcXG4gICAgICAgICAgXFx0J2RvdHMnIDogdGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5kb3RzXFxuICAgICAgICAgIH0sXFxuICAgICAgICAgICovXFxuICAgICAgICAgICdzZWxlY3RlZCc6IFtdXFxuICAgICAgICB9XFxuICAgICAgfSxcXG4gICAgICAgICAgaTtcXG5cXG4gICAgICBmb3IgKGkgaW4gdGhpcy5fbW9kZWwuZGF0YSkge1xcbiAgICAgICAgaWYgKHRoaXMuX21vZGVsLmRhdGEuaGFzT3duUHJvcGVydHkoaSkpIHtcXG4gICAgICAgICAgaWYgKGkgIT09ICQuanN0cmVlLnJvb3QpIHtcXG4gICAgICAgICAgICBpZiAodGhpcy5fbW9kZWwuZGF0YVtpXS5zdGF0ZS5vcGVuZWQpIHtcXG4gICAgICAgICAgICAgIHN0YXRlLmNvcmUub3Blbi5wdXNoKGkpO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpZiAodGhpcy5fbW9kZWwuZGF0YVtpXS5zdGF0ZS5zZWxlY3RlZCkge1xcbiAgICAgICAgICAgICAgc3RhdGUuY29yZS5zZWxlY3RlZC5wdXNoKGkpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gc3RhdGU7XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBzZXRzIHRoZSBzdGF0ZSBvZiB0aGUgdHJlZS4gVXNlZCBpbnRlcm5hbGx5LlxcbiAgICAgKiBAbmFtZSBzZXRfc3RhdGUoc3RhdGUgWywgY2FsbGJhY2tdKVxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3RhdGUgdGhlIHN0YXRlIHRvIHJlc3RvcmUuIEtlZXAgaW4gbWluZCB0aGlzIG9iamVjdCBpcyBwYXNzZWQgYnkgcmVmZXJlbmNlIGFuZCBqc3RyZWUgd2lsbCBtb2RpZnkgaXQuXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGFuIG9wdGlvbmFsIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgb25jZSB0aGUgc3RhdGUgaXMgcmVzdG9yZWQuXFxuICAgICAqIEB0cmlnZ2VyIHNldF9zdGF0ZS5qc3RyZWVcXG4gICAgICovXFxuICAgIHNldF9zdGF0ZTogZnVuY3Rpb24gc2V0X3N0YXRlKHN0YXRlLCBjYWxsYmFjaykge1xcbiAgICAgIGlmIChzdGF0ZSkge1xcbiAgICAgICAgaWYgKHN0YXRlLmNvcmUpIHtcXG4gICAgICAgICAgdmFyIHJlcywgbiwgdCwgX3RoaXMsIGk7XFxuXFxuICAgICAgICAgIGlmIChzdGF0ZS5jb3JlLm9wZW4pIHtcXG4gICAgICAgICAgICBpZiAoISQuaXNBcnJheShzdGF0ZS5jb3JlLm9wZW4pIHx8ICFzdGF0ZS5jb3JlLm9wZW4ubGVuZ3RoKSB7XFxuICAgICAgICAgICAgICBkZWxldGUgc3RhdGUuY29yZS5vcGVuO1xcbiAgICAgICAgICAgICAgdGhpcy5zZXRfc3RhdGUoc3RhdGUsIGNhbGxiYWNrKTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgdGhpcy5fbG9hZF9ub2RlcyhzdGF0ZS5jb3JlLm9wZW4sIGZ1bmN0aW9uIChub2Rlcykge1xcbiAgICAgICAgICAgICAgICB0aGlzLm9wZW5fbm9kZShub2RlcywgZmFsc2UsIDApO1xcbiAgICAgICAgICAgICAgICBkZWxldGUgc3RhdGUuY29yZS5vcGVuO1xcbiAgICAgICAgICAgICAgICB0aGlzLnNldF9zdGF0ZShzdGF0ZSwgY2FsbGJhY2spO1xcbiAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAoc3RhdGUuY29yZS5zY3JvbGwpIHtcXG4gICAgICAgICAgICBpZiAoc3RhdGUuY29yZS5zY3JvbGwgJiYgc3RhdGUuY29yZS5zY3JvbGwubGVmdCAhPT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuc2Nyb2xsTGVmdChzdGF0ZS5jb3JlLnNjcm9sbC5sZWZ0KTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaWYgKHN0YXRlLmNvcmUuc2Nyb2xsICYmIHN0YXRlLmNvcmUuc2Nyb2xsLnRvcCAhPT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuc2Nyb2xsVG9wKHN0YXRlLmNvcmUuc2Nyb2xsLnRvcCk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGRlbGV0ZSBzdGF0ZS5jb3JlLnNjcm9sbDtcXG4gICAgICAgICAgICB0aGlzLnNldF9zdGF0ZShzdGF0ZSwgY2FsbGJhY2spO1xcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAoc3RhdGUuY29yZS5zZWxlY3RlZCkge1xcbiAgICAgICAgICAgIF90aGlzID0gdGhpcztcXG4gICAgICAgICAgICB0aGlzLmRlc2VsZWN0X2FsbCgpO1xcbiAgICAgICAgICAgICQuZWFjaChzdGF0ZS5jb3JlLnNlbGVjdGVkLCBmdW5jdGlvbiAoaSwgdikge1xcbiAgICAgICAgICAgICAgX3RoaXMuc2VsZWN0X25vZGUodiwgZmFsc2UsIHRydWUpO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIGRlbGV0ZSBzdGF0ZS5jb3JlLnNlbGVjdGVkO1xcbiAgICAgICAgICAgIHRoaXMuc2V0X3N0YXRlKHN0YXRlLCBjYWxsYmFjayk7XFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGZvciAoaSBpbiBzdGF0ZSkge1xcbiAgICAgICAgICAgIGlmIChzdGF0ZS5oYXNPd25Qcm9wZXJ0eShpKSAmJiBpICE9PSBcXFwiY29yZVxcXCIgJiYgJC5pbkFycmF5KGksIHRoaXMuc2V0dGluZ3MucGx1Z2lucykgPT09IC0xKSB7XFxuICAgICAgICAgICAgICBkZWxldGUgc3RhdGVbaV07XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmICgkLmlzRW1wdHlPYmplY3Qoc3RhdGUuY29yZSkpIHtcXG4gICAgICAgICAgICBkZWxldGUgc3RhdGUuY29yZTtcXG4gICAgICAgICAgICB0aGlzLnNldF9zdGF0ZShzdGF0ZSwgY2FsbGJhY2spO1xcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKCQuaXNFbXB0eU9iamVjdChzdGF0ZSkpIHtcXG4gICAgICAgICAgc3RhdGUgPSBudWxsO1xcblxcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcXG4gICAgICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXMpO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIC8qKlxcbiAgICAgICAgICAgKiB0cmlnZ2VyZWQgd2hlbiBhIGBzZXRfc3RhdGVgIGNhbGwgY29tcGxldGVzXFxuICAgICAgICAgICAqIEBldmVudFxcbiAgICAgICAgICAgKiBAbmFtZSBzZXRfc3RhdGUuanN0cmVlXFxuICAgICAgICAgICAqL1xcblxcblxcbiAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3NldF9zdGF0ZScpO1xcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogcmVmcmVzaGVzIHRoZSB0cmVlIC0gYWxsIG5vZGVzIGFyZSByZWxvYWRlZCB3aXRoIGNhbGxzIHRvIGBsb2FkX25vZGVgLlxcbiAgICAgKiBAbmFtZSByZWZyZXNoKClcXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBza2lwX2xvYWRpbmcgYW4gb3B0aW9uIHRvIHNraXAgc2hvd2luZyB0aGUgbG9hZGluZyBpbmRpY2F0b3JcXG4gICAgICogQHBhcmFtIHtNaXhlZH0gZm9yZ2V0X3N0YXRlIGlmIHNldCB0byBgdHJ1ZWAgc3RhdGUgd2lsbCBub3QgYmUgcmVhcHBsaWVkLCBpZiBzZXQgdG8gYSBmdW5jdGlvbiAocmVjZWl2aW5nIHRoZSBjdXJyZW50IHN0YXRlIGFzIGFyZ3VtZW50KSB0aGUgcmVzdWx0IG9mIHRoYXQgZnVuY3Rpb24gd2lsbCBiZSB1c2VkIGFzIHN0YXRlXFxuICAgICAqIEB0cmlnZ2VyIHJlZnJlc2guanN0cmVlXFxuICAgICAqL1xcbiAgICByZWZyZXNoOiBmdW5jdGlvbiByZWZyZXNoKHNraXBfbG9hZGluZywgZm9yZ2V0X3N0YXRlKSB7XFxuICAgICAgdGhpcy5fZGF0YS5jb3JlLnN0YXRlID0gZm9yZ2V0X3N0YXRlID09PSB0cnVlID8ge30gOiB0aGlzLmdldF9zdGF0ZSgpO1xcblxcbiAgICAgIGlmIChmb3JnZXRfc3RhdGUgJiYgJC5pc0Z1bmN0aW9uKGZvcmdldF9zdGF0ZSkpIHtcXG4gICAgICAgIHRoaXMuX2RhdGEuY29yZS5zdGF0ZSA9IGZvcmdldF9zdGF0ZS5jYWxsKHRoaXMsIHRoaXMuX2RhdGEuY29yZS5zdGF0ZSk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX2NudCA9IDA7XFxuICAgICAgdGhpcy5fbW9kZWwuZGF0YSA9IHt9O1xcbiAgICAgIHRoaXMuX21vZGVsLmRhdGFbJC5qc3RyZWUucm9vdF0gPSB7XFxuICAgICAgICBpZDogJC5qc3RyZWUucm9vdCxcXG4gICAgICAgIHBhcmVudDogbnVsbCxcXG4gICAgICAgIHBhcmVudHM6IFtdLFxcbiAgICAgICAgY2hpbGRyZW46IFtdLFxcbiAgICAgICAgY2hpbGRyZW5fZDogW10sXFxuICAgICAgICBzdGF0ZToge1xcbiAgICAgICAgICBsb2FkZWQ6IGZhbHNlXFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQgPSBbXTtcXG4gICAgICB0aGlzLl9kYXRhLmNvcmUubGFzdF9jbGlja2VkID0gbnVsbDtcXG4gICAgICB0aGlzLl9kYXRhLmNvcmUuZm9jdXNlZCA9IG51bGw7XFxuICAgICAgdmFyIGMgPSB0aGlzLmdldF9jb250YWluZXJfdWwoKVswXS5jbGFzc05hbWU7XFxuXFxuICAgICAgaWYgKCFza2lwX2xvYWRpbmcpIHtcXG4gICAgICAgIHRoaXMuZWxlbWVudC5odG1sKFxcXCI8XFxcIiArIFxcXCJ1bCBjbGFzcz0nXFxcIiArIGMgKyBcXFwiJyByb2xlPSdncm91cCc+PFxcXCIgKyBcXFwibGkgY2xhc3M9J2pzdHJlZS1pbml0aWFsLW5vZGUganN0cmVlLWxvYWRpbmcganN0cmVlLWxlYWYganN0cmVlLWxhc3QnIHJvbGU9J3RyZWVpdGVtJyBpZD0nalxcXCIgKyB0aGlzLl9pZCArIFxcXCJfbG9hZGluZyc+PGkgY2xhc3M9J2pzdHJlZS1pY29uIGpzdHJlZS1vY2wnPjwvaT48XFxcIiArIFxcXCJhIGNsYXNzPSdqc3RyZWUtYW5jaG9yJyBocmVmPScjJz48aSBjbGFzcz0nanN0cmVlLWljb24ganN0cmVlLXRoZW1laWNvbi1oaWRkZW4nPjwvaT5cXFwiICsgdGhpcy5nZXRfc3RyaW5nKFxcXCJMb2FkaW5nIC4uLlxcXCIpICsgXFxcIjwvYT48L2xpPjwvdWw+XFxcIik7XFxuICAgICAgICB0aGlzLmVsZW1lbnQuYXR0cignYXJpYS1hY3RpdmVkZXNjZW5kYW50JywgJ2onICsgdGhpcy5faWQgKyAnX2xvYWRpbmcnKTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5sb2FkX25vZGUoJC5qc3RyZWUucm9vdCwgZnVuY3Rpb24gKG8sIHMpIHtcXG4gICAgICAgIGlmIChzKSB7XFxuICAgICAgICAgIHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpWzBdLmNsYXNzTmFtZSA9IGM7XFxuXFxuICAgICAgICAgIGlmICh0aGlzLl9maXJzdENoaWxkKHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpWzBdKSkge1xcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5hdHRyKCdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnLCB0aGlzLl9maXJzdENoaWxkKHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpWzBdKS5pZCk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgdGhpcy5zZXRfc3RhdGUoJC5leHRlbmQodHJ1ZSwge30sIHRoaXMuX2RhdGEuY29yZS5zdGF0ZSksIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAvKipcXG4gICAgICAgICAgICAgKiB0cmlnZ2VyZWQgd2hlbiBhIGByZWZyZXNoYCBjYWxsIGNvbXBsZXRlc1xcbiAgICAgICAgICAgICAqIEBldmVudFxcbiAgICAgICAgICAgICAqIEBuYW1lIHJlZnJlc2guanN0cmVlXFxuICAgICAgICAgICAgICovXFxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdyZWZyZXNoJyk7XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdGhpcy5fZGF0YS5jb3JlLnN0YXRlID0gbnVsbDtcXG4gICAgICB9KTtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIHJlZnJlc2hlcyBhIG5vZGUgaW4gdGhlIHRyZWUgKHJlbG9hZCBpdHMgY2hpbGRyZW4pIGFsbCBvcGVuZWQgbm9kZXMgaW5zaWRlIHRoYXQgbm9kZSBhcmUgcmVsb2FkZWQgd2l0aCBjYWxscyB0byBgbG9hZF9ub2RlYC5cXG4gICAgICogQG5hbWUgcmVmcmVzaF9ub2RlKG9iailcXG4gICAgICogQHBhcmFtICB7bWl4ZWR9IG9iaiB0aGUgbm9kZVxcbiAgICAgKiBAdHJpZ2dlciByZWZyZXNoX25vZGUuanN0cmVlXFxuICAgICAqL1xcbiAgICByZWZyZXNoX25vZGU6IGZ1bmN0aW9uIHJlZnJlc2hfbm9kZShvYmopIHtcXG4gICAgICBvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XFxuXFxuICAgICAgaWYgKCFvYmogfHwgb2JqLmlkID09PSAkLmpzdHJlZS5yb290KSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBvcGVuZWQgPSBbXSxcXG4gICAgICAgICAgdG9fbG9hZCA9IFtdLFxcbiAgICAgICAgICBzID0gdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLmNvbmNhdChbXSk7XFxuXFxuICAgICAgdG9fbG9hZC5wdXNoKG9iai5pZCk7XFxuXFxuICAgICAgaWYgKG9iai5zdGF0ZS5vcGVuZWQgPT09IHRydWUpIHtcXG4gICAgICAgIG9wZW5lZC5wdXNoKG9iai5pZCk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKS5maW5kKCcuanN0cmVlLW9wZW4nKS5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHRvX2xvYWQucHVzaCh0aGlzLmlkKTtcXG4gICAgICAgIG9wZW5lZC5wdXNoKHRoaXMuaWQpO1xcbiAgICAgIH0pO1xcblxcbiAgICAgIHRoaXMuX2xvYWRfbm9kZXModG9fbG9hZCwgJC5wcm94eShmdW5jdGlvbiAobm9kZXMpIHtcXG4gICAgICAgIHRoaXMub3Blbl9ub2RlKG9wZW5lZCwgZmFsc2UsIDApO1xcbiAgICAgICAgdGhpcy5zZWxlY3Rfbm9kZShzKTtcXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogdHJpZ2dlcmVkIHdoZW4gYSBub2RlIGlzIHJlZnJlc2hlZFxcbiAgICAgICAgICogQGV2ZW50XFxuICAgICAgICAgKiBAbmFtZSByZWZyZXNoX25vZGUuanN0cmVlXFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZSAtIHRoZSByZWZyZXNoZWQgbm9kZVxcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gbm9kZXMgLSBhbiBhcnJheSBvZiB0aGUgSURzIG9mIHRoZSBub2RlcyB0aGF0IHdlcmUgcmVsb2FkZWRcXG4gICAgICAgICAqL1xcblxcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdyZWZyZXNoX25vZGUnLCB7XFxuICAgICAgICAgICdub2RlJzogb2JqLFxcbiAgICAgICAgICAnbm9kZXMnOiBub2Rlc1xcbiAgICAgICAgfSk7XFxuICAgICAgfSwgdGhpcyksIGZhbHNlLCB0cnVlKTtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIHNldCAoY2hhbmdlKSB0aGUgSUQgb2YgYSBub2RlXFxuICAgICAqIEBuYW1lIHNldF9pZChvYmosIGlkKVxcbiAgICAgKiBAcGFyYW0gIHttaXhlZH0gb2JqIHRoZSBub2RlXFxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gaWQgdGhlIG5ldyBJRFxcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxcbiAgICAgKiBAdHJpZ2dlciBzZXRfaWQuanN0cmVlXFxuICAgICAqL1xcbiAgICBzZXRfaWQ6IGZ1bmN0aW9uIHNldF9pZChvYmosIGlkKSB7XFxuICAgICAgb2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xcblxcbiAgICAgIGlmICghb2JqIHx8IG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCkge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgaSxcXG4gICAgICAgICAgaixcXG4gICAgICAgICAgbSA9IHRoaXMuX21vZGVsLmRhdGEsXFxuICAgICAgICAgIG9sZCA9IG9iai5pZDtcXG4gICAgICBpZCA9IGlkLnRvU3RyaW5nKCk7IC8vIHVwZGF0ZSBwYXJlbnRzIChyZXBsYWNlIGN1cnJlbnQgSUQgd2l0aCBuZXcgb25lIGluIGNoaWxkcmVuIGFuZCBjaGlsZHJlbl9kKVxcblxcbiAgICAgIG1bb2JqLnBhcmVudF0uY2hpbGRyZW5bJC5pbkFycmF5KG9iai5pZCwgbVtvYmoucGFyZW50XS5jaGlsZHJlbildID0gaWQ7XFxuXFxuICAgICAgZm9yIChpID0gMCwgaiA9IG9iai5wYXJlbnRzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcbiAgICAgICAgbVtvYmoucGFyZW50c1tpXV0uY2hpbGRyZW5fZFskLmluQXJyYXkob2JqLmlkLCBtW29iai5wYXJlbnRzW2ldXS5jaGlsZHJlbl9kKV0gPSBpZDtcXG4gICAgICB9IC8vIHVwZGF0ZSBjaGlsZHJlbiAocmVwbGFjZSBjdXJyZW50IElEIHdpdGggbmV3IG9uZSBpbiBwYXJlbnQgYW5kIHBhcmVudHMpXFxuXFxuXFxuICAgICAgZm9yIChpID0gMCwgaiA9IG9iai5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG4gICAgICAgIG1bb2JqLmNoaWxkcmVuW2ldXS5wYXJlbnQgPSBpZDtcXG4gICAgICB9XFxuXFxuICAgICAgZm9yIChpID0gMCwgaiA9IG9iai5jaGlsZHJlbl9kLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcbiAgICAgICAgbVtvYmouY2hpbGRyZW5fZFtpXV0ucGFyZW50c1skLmluQXJyYXkob2JqLmlkLCBtW29iai5jaGlsZHJlbl9kW2ldXS5wYXJlbnRzKV0gPSBpZDtcXG4gICAgICB9XFxuXFxuICAgICAgaSA9ICQuaW5BcnJheShvYmouaWQsIHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZCk7XFxuXFxuICAgICAgaWYgKGkgIT09IC0xKSB7XFxuICAgICAgICB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWRbaV0gPSBpZDtcXG4gICAgICB9IC8vIHVwZGF0ZSBtb2RlbCBhbmQgb2JqIGl0c2VsZiAob2JqLmlkLCB0aGlzLl9tb2RlbC5kYXRhW0tFWV0pXFxuXFxuXFxuICAgICAgaSA9IHRoaXMuZ2V0X25vZGUob2JqLmlkLCB0cnVlKTtcXG5cXG4gICAgICBpZiAoaSkge1xcbiAgICAgICAgaS5hdHRyKCdpZCcsIGlkKTsgLy8uY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuYXR0cignaWQnLCBpZCArICdfYW5jaG9yJykuZW5kKCkuYXR0cignYXJpYS1sYWJlbGxlZGJ5JywgaWQgKyAnX2FuY2hvcicpO1xcblxcbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudC5hdHRyKCdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnKSA9PT0gb2JqLmlkKSB7XFxuICAgICAgICAgIHRoaXMuZWxlbWVudC5hdHRyKCdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnLCBpZCk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGRlbGV0ZSBtW29iai5pZF07XFxuICAgICAgb2JqLmlkID0gaWQ7XFxuICAgICAgb2JqLmxpX2F0dHIuaWQgPSBpZDtcXG4gICAgICBtW2lkXSA9IG9iajtcXG4gICAgICAvKipcXG4gICAgICAgKiB0cmlnZ2VyZWQgd2hlbiBhIG5vZGUgaWQgdmFsdWUgaXMgY2hhbmdlZFxcbiAgICAgICAqIEBldmVudFxcbiAgICAgICAqIEBuYW1lIHNldF9pZC5qc3RyZWVcXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZVxcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGQgdGhlIG9sZCBpZFxcbiAgICAgICAqL1xcblxcbiAgICAgIHRoaXMudHJpZ2dlcignc2V0X2lkJywge1xcbiAgICAgICAgXFxcIm5vZGVcXFwiOiBvYmosXFxuICAgICAgICBcXFwibmV3XFxcIjogb2JqLmlkLFxcbiAgICAgICAgXFxcIm9sZFxcXCI6IG9sZFxcbiAgICAgIH0pO1xcbiAgICAgIHJldHVybiB0cnVlO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogZ2V0IHRoZSB0ZXh0IHZhbHVlIG9mIGEgbm9kZVxcbiAgICAgKiBAbmFtZSBnZXRfdGV4dChvYmopXFxuICAgICAqIEBwYXJhbSAge21peGVkfSBvYmogdGhlIG5vZGVcXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxcbiAgICAgKi9cXG4gICAgZ2V0X3RleHQ6IGZ1bmN0aW9uIGdldF90ZXh0KG9iaikge1xcbiAgICAgIG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcXG4gICAgICByZXR1cm4gIW9iaiB8fCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QgPyBmYWxzZSA6IG9iai50ZXh0O1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogc2V0IHRoZSB0ZXh0IHZhbHVlIG9mIGEgbm9kZS4gVXNlZCBpbnRlcm5hbGx5LCBwbGVhc2UgdXNlIGByZW5hbWVfbm9kZShvYmosIHZhbClgLlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAbmFtZSBzZXRfdGV4dChvYmosIHZhbClcXG4gICAgICogQHBhcmFtICB7bWl4ZWR9IG9iaiB0aGUgbm9kZSwgeW91IGNhbiBwYXNzIGFuIGFycmF5IHRvIHNldCB0aGUgdGV4dCBvbiBtdWx0aXBsZSBub2Rlc1xcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHZhbCB0aGUgbmV3IHRleHQgdmFsdWVcXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cXG4gICAgICogQHRyaWdnZXIgc2V0X3RleHQuanN0cmVlXFxuICAgICAqL1xcbiAgICBzZXRfdGV4dDogZnVuY3Rpb24gc2V0X3RleHQob2JqLCB2YWwpIHtcXG4gICAgICB2YXIgdDEsIHQyO1xcblxcbiAgICAgIGlmICgkLmlzQXJyYXkob2JqKSkge1xcbiAgICAgICAgb2JqID0gb2JqLnNsaWNlKCk7XFxuXFxuICAgICAgICBmb3IgKHQxID0gMCwgdDIgPSBvYmoubGVuZ3RoOyB0MSA8IHQyOyB0MSsrKSB7XFxuICAgICAgICAgIHRoaXMuc2V0X3RleHQob2JqW3QxXSwgdmFsKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgIH1cXG5cXG4gICAgICBvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XFxuXFxuICAgICAgaWYgKCFvYmogfHwgb2JqLmlkID09PSAkLmpzdHJlZS5yb290KSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcblxcbiAgICAgIG9iai50ZXh0ID0gdmFsO1xcblxcbiAgICAgIGlmICh0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSkubGVuZ3RoKSB7XFxuICAgICAgICB0aGlzLnJlZHJhd19ub2RlKG9iai5pZCk7XFxuICAgICAgfVxcbiAgICAgIC8qKlxcbiAgICAgICAqIHRyaWdnZXJlZCB3aGVuIGEgbm9kZSB0ZXh0IHZhbHVlIGlzIGNoYW5nZWRcXG4gICAgICAgKiBAZXZlbnRcXG4gICAgICAgKiBAbmFtZSBzZXRfdGV4dC5qc3RyZWVcXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqXFxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHRleHQgdGhlIG5ldyB2YWx1ZVxcbiAgICAgICAqL1xcblxcblxcbiAgICAgIHRoaXMudHJpZ2dlcignc2V0X3RleHQnLCB7XFxuICAgICAgICBcXFwib2JqXFxcIjogb2JqLFxcbiAgICAgICAgXFxcInRleHRcXFwiOiB2YWxcXG4gICAgICB9KTtcXG4gICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIGdldHMgYSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGEgbm9kZSAob3IgdGhlIHdob2xlIHRyZWUpXFxuICAgICAqIEBuYW1lIGdldF9qc29uKFtvYmosIG9wdGlvbnNdKVxcbiAgICAgKiBAcGFyYW0gIHttaXhlZH0gb2JqXFxuICAgICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xcbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBvcHRpb25zLm5vX3N0YXRlIGRvIG5vdCByZXR1cm4gc3RhdGUgaW5mb3JtYXRpb25cXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gb3B0aW9ucy5ub19pZCBkbyBub3QgcmV0dXJuIElEXFxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IG9wdGlvbnMubm9fY2hpbGRyZW4gZG8gbm90IGluY2x1ZGUgY2hpbGRyZW5cXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gb3B0aW9ucy5ub19kYXRhIGRvIG5vdCBpbmNsdWRlIG5vZGUgZGF0YVxcbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBvcHRpb25zLm5vX2xpX2F0dHIgZG8gbm90IGluY2x1ZGUgTEkgYXR0cmlidXRlc1xcbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBvcHRpb25zLm5vX2FfYXR0ciBkbyBub3QgaW5jbHVkZSBBIGF0dHJpYnV0ZXNcXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gb3B0aW9ucy5mbGF0IHJldHVybiBmbGF0IEpTT04gaW5zdGVhZCBvZiBuZXN0ZWRcXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxcbiAgICAgKi9cXG4gICAgZ2V0X2pzb246IGZ1bmN0aW9uIGdldF9qc29uKG9iaiwgb3B0aW9ucywgZmxhdCkge1xcbiAgICAgIG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqIHx8ICQuanN0cmVlLnJvb3QpO1xcblxcbiAgICAgIGlmICghb2JqKSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZmxhdCAmJiAhZmxhdCkge1xcbiAgICAgICAgZmxhdCA9IFtdO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgdG1wID0ge1xcbiAgICAgICAgJ2lkJzogb2JqLmlkLFxcbiAgICAgICAgJ3RleHQnOiBvYmoudGV4dCxcXG4gICAgICAgICdpY29uJzogdGhpcy5nZXRfaWNvbihvYmopLFxcbiAgICAgICAgJ2xpX2F0dHInOiAkLmV4dGVuZCh0cnVlLCB7fSwgb2JqLmxpX2F0dHIpLFxcbiAgICAgICAgJ2FfYXR0cic6ICQuZXh0ZW5kKHRydWUsIHt9LCBvYmouYV9hdHRyKSxcXG4gICAgICAgICdzdGF0ZSc6IHt9LFxcbiAgICAgICAgJ2RhdGEnOiBvcHRpb25zICYmIG9wdGlvbnMubm9fZGF0YSA/IGZhbHNlIDogJC5leHRlbmQodHJ1ZSwge30sIG9iai5kYXRhKSAvLyggdGhpcy5nZXRfbm9kZShvYmosIHRydWUpLmxlbmd0aCA/IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKS5kYXRhKCkgOiBvYmouZGF0YSApLFxcblxcbiAgICAgIH0sXFxuICAgICAgICAgIGksXFxuICAgICAgICAgIGo7XFxuXFxuICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5mbGF0KSB7XFxuICAgICAgICB0bXAucGFyZW50ID0gb2JqLnBhcmVudDtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdG1wLmNoaWxkcmVuID0gW107XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghb3B0aW9ucyB8fCAhb3B0aW9ucy5ub19zdGF0ZSkge1xcbiAgICAgICAgZm9yIChpIGluIG9iai5zdGF0ZSkge1xcbiAgICAgICAgICBpZiAob2JqLnN0YXRlLmhhc093blByb3BlcnR5KGkpKSB7XFxuICAgICAgICAgICAgdG1wLnN0YXRlW2ldID0gb2JqLnN0YXRlW2ldO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGRlbGV0ZSB0bXAuc3RhdGU7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMubm9fbGlfYXR0cikge1xcbiAgICAgICAgZGVsZXRlIHRtcC5saV9hdHRyO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLm5vX2FfYXR0cikge1xcbiAgICAgICAgZGVsZXRlIHRtcC5hX2F0dHI7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMubm9faWQpIHtcXG4gICAgICAgIGRlbGV0ZSB0bXAuaWQ7XFxuXFxuICAgICAgICBpZiAodG1wLmxpX2F0dHIgJiYgdG1wLmxpX2F0dHIuaWQpIHtcXG4gICAgICAgICAgZGVsZXRlIHRtcC5saV9hdHRyLmlkO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKHRtcC5hX2F0dHIgJiYgdG1wLmFfYXR0ci5pZCkge1xcbiAgICAgICAgICBkZWxldGUgdG1wLmFfYXR0ci5pZDtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5mbGF0ICYmIG9iai5pZCAhPT0gJC5qc3RyZWUucm9vdCkge1xcbiAgICAgICAgZmxhdC5wdXNoKHRtcCk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghb3B0aW9ucyB8fCAhb3B0aW9ucy5ub19jaGlsZHJlbikge1xcbiAgICAgICAgZm9yIChpID0gMCwgaiA9IG9iai5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG4gICAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5mbGF0KSB7XFxuICAgICAgICAgICAgdGhpcy5nZXRfanNvbihvYmouY2hpbGRyZW5baV0sIG9wdGlvbnMsIGZsYXQpO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHRtcC5jaGlsZHJlbi5wdXNoKHRoaXMuZ2V0X2pzb24ob2JqLmNoaWxkcmVuW2ldLCBvcHRpb25zKSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIG9wdGlvbnMgJiYgb3B0aW9ucy5mbGF0ID8gZmxhdCA6IG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCA/IHRtcC5jaGlsZHJlbiA6IHRtcDtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIGNyZWF0ZSBhIG5ldyBub2RlIChkbyBub3QgY29uZnVzZSB3aXRoIGxvYWRfbm9kZSlcXG4gICAgICogQG5hbWUgY3JlYXRlX25vZGUoW3Bhciwgbm9kZSwgcG9zLCBjYWxsYmFjaywgaXNfbG9hZGVkXSlcXG4gICAgICogQHBhcmFtICB7bWl4ZWR9ICAgcGFyICAgICAgIHRoZSBwYXJlbnQgbm9kZSAodG8gY3JlYXRlIGEgcm9vdCBub2RlIHVzZSBlaXRoZXIgXFxcIiNcXFwiIChzdHJpbmcpIG9yIGBudWxsYClcXG4gICAgICogQHBhcmFtICB7bWl4ZWR9ICAgbm9kZSAgICAgIHRoZSBkYXRhIGZvciB0aGUgbmV3IG5vZGUgKGEgdmFsaWQgSlNPTiBvYmplY3QsIG9yIGEgc2ltcGxlIHN0cmluZyB3aXRoIHRoZSBuYW1lKVxcbiAgICAgKiBAcGFyYW0gIHttaXhlZH0gICBwb3MgICAgICAgdGhlIGluZGV4IGF0IHdoaWNoIHRvIGluc2VydCB0aGUgbm9kZSwgXFxcImZpcnN0XFxcIiBhbmQgXFxcImxhc3RcXFwiIGFyZSBhbHNvIHN1cHBvcnRlZCwgZGVmYXVsdCBpcyBcXFwibGFzdFxcXCJcXG4gICAgICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrIGEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uY2UgdGhlIG5vZGUgaXMgY3JlYXRlZFxcbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBpc19sb2FkZWQgaW50ZXJuYWwgYXJndW1lbnQgaW5kaWNhdGluZyBpZiB0aGUgcGFyZW50IG5vZGUgd2FzIHN1Y2Nlc2Z1bGx5IGxvYWRlZFxcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgICAgdGhlIElEIG9mIHRoZSBuZXdseSBjcmVhdGUgbm9kZVxcbiAgICAgKiBAdHJpZ2dlciBtb2RlbC5qc3RyZWUsIGNyZWF0ZV9ub2RlLmpzdHJlZVxcbiAgICAgKi9cXG4gICAgY3JlYXRlX25vZGU6IGZ1bmN0aW9uIGNyZWF0ZV9ub2RlKHBhciwgbm9kZSwgcG9zLCBjYWxsYmFjaywgaXNfbG9hZGVkKSB7XFxuICAgICAgaWYgKHBhciA9PT0gbnVsbCkge1xcbiAgICAgICAgcGFyID0gJC5qc3RyZWUucm9vdDtcXG4gICAgICB9XFxuXFxuICAgICAgcGFyID0gdGhpcy5nZXRfbm9kZShwYXIpO1xcblxcbiAgICAgIGlmICghcGFyKSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcblxcbiAgICAgIHBvcyA9IHBvcyA9PT0gdW5kZWZpbmVkID8gXFxcImxhc3RcXFwiIDogcG9zO1xcblxcbiAgICAgIGlmICghcG9zLnRvU3RyaW5nKCkubWF0Y2goL14oYmVmb3JlfGFmdGVyKSQvKSAmJiAhaXNfbG9hZGVkICYmICF0aGlzLmlzX2xvYWRlZChwYXIpKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5sb2FkX25vZGUocGFyLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHRoaXMuY3JlYXRlX25vZGUocGFyLCBub2RlLCBwb3MsIGNhbGxiYWNrLCB0cnVlKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIW5vZGUpIHtcXG4gICAgICAgIG5vZGUgPSB7XFxuICAgICAgICAgIFxcXCJ0ZXh0XFxcIjogdGhpcy5nZXRfc3RyaW5nKCdOZXcgbm9kZScpXFxuICAgICAgICB9O1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodHlwZW9mIG5vZGUgPT09IFxcXCJzdHJpbmdcXFwiKSB7XFxuICAgICAgICBub2RlID0ge1xcbiAgICAgICAgICBcXFwidGV4dFxcXCI6IG5vZGVcXG4gICAgICAgIH07XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChub2RlLnRleHQgPT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgbm9kZS50ZXh0ID0gdGhpcy5nZXRfc3RyaW5nKCdOZXcgbm9kZScpO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgdG1wLCBkcGMsIGksIGo7XFxuXFxuICAgICAgaWYgKHBhci5pZCA9PT0gJC5qc3RyZWUucm9vdCkge1xcbiAgICAgICAgaWYgKHBvcyA9PT0gXFxcImJlZm9yZVxcXCIpIHtcXG4gICAgICAgICAgcG9zID0gXFxcImZpcnN0XFxcIjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChwb3MgPT09IFxcXCJhZnRlclxcXCIpIHtcXG4gICAgICAgICAgcG9zID0gXFxcImxhc3RcXFwiO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBzd2l0Y2ggKHBvcykge1xcbiAgICAgICAgY2FzZSBcXFwiYmVmb3JlXFxcIjpcXG4gICAgICAgICAgdG1wID0gdGhpcy5nZXRfbm9kZShwYXIucGFyZW50KTtcXG4gICAgICAgICAgcG9zID0gJC5pbkFycmF5KHBhci5pZCwgdG1wLmNoaWxkcmVuKTtcXG4gICAgICAgICAgcGFyID0gdG1wO1xcbiAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgIGNhc2UgXFxcImFmdGVyXFxcIjpcXG4gICAgICAgICAgdG1wID0gdGhpcy5nZXRfbm9kZShwYXIucGFyZW50KTtcXG4gICAgICAgICAgcG9zID0gJC5pbkFycmF5KHBhci5pZCwgdG1wLmNoaWxkcmVuKSArIDE7XFxuICAgICAgICAgIHBhciA9IHRtcDtcXG4gICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICBjYXNlIFxcXCJpbnNpZGVcXFwiOlxcbiAgICAgICAgY2FzZSBcXFwiZmlyc3RcXFwiOlxcbiAgICAgICAgICBwb3MgPSAwO1xcbiAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgIGNhc2UgXFxcImxhc3RcXFwiOlxcbiAgICAgICAgICBwb3MgPSBwYXIuY2hpbGRyZW4ubGVuZ3RoO1xcbiAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgIGRlZmF1bHQ6XFxuICAgICAgICAgIGlmICghcG9zKSB7XFxuICAgICAgICAgICAgcG9zID0gMDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBicmVhaztcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHBvcyA+IHBhci5jaGlsZHJlbi5sZW5ndGgpIHtcXG4gICAgICAgIHBvcyA9IHBhci5jaGlsZHJlbi5sZW5ndGg7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghbm9kZS5pZCkge1xcbiAgICAgICAgbm9kZS5pZCA9IHRydWU7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghdGhpcy5jaGVjayhcXFwiY3JlYXRlX25vZGVcXFwiLCBub2RlLCBwYXIsIHBvcykpIHtcXG4gICAgICAgIHRoaXMuc2V0dGluZ3MuY29yZS5lcnJvci5jYWxsKHRoaXMsIHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yKTtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKG5vZGUuaWQgPT09IHRydWUpIHtcXG4gICAgICAgIGRlbGV0ZSBub2RlLmlkO1xcbiAgICAgIH1cXG5cXG4gICAgICBub2RlID0gdGhpcy5fcGFyc2VfbW9kZWxfZnJvbV9qc29uKG5vZGUsIHBhci5pZCwgcGFyLnBhcmVudHMuY29uY2F0KCkpO1xcblxcbiAgICAgIGlmICghbm9kZSkge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICB0bXAgPSB0aGlzLmdldF9ub2RlKG5vZGUpO1xcbiAgICAgIGRwYyA9IFtdO1xcbiAgICAgIGRwYy5wdXNoKG5vZGUpO1xcbiAgICAgIGRwYyA9IGRwYy5jb25jYXQodG1wLmNoaWxkcmVuX2QpO1xcbiAgICAgIHRoaXMudHJpZ2dlcignbW9kZWwnLCB7XFxuICAgICAgICBcXFwibm9kZXNcXFwiOiBkcGMsXFxuICAgICAgICBcXFwicGFyZW50XFxcIjogcGFyLmlkXFxuICAgICAgfSk7XFxuICAgICAgcGFyLmNoaWxkcmVuX2QgPSBwYXIuY2hpbGRyZW5fZC5jb25jYXQoZHBjKTtcXG5cXG4gICAgICBmb3IgKGkgPSAwLCBqID0gcGFyLnBhcmVudHMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICB0aGlzLl9tb2RlbC5kYXRhW3Bhci5wYXJlbnRzW2ldXS5jaGlsZHJlbl9kID0gdGhpcy5fbW9kZWwuZGF0YVtwYXIucGFyZW50c1tpXV0uY2hpbGRyZW5fZC5jb25jYXQoZHBjKTtcXG4gICAgICB9XFxuXFxuICAgICAgbm9kZSA9IHRtcDtcXG4gICAgICB0bXAgPSBbXTtcXG5cXG4gICAgICBmb3IgKGkgPSAwLCBqID0gcGFyLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcbiAgICAgICAgdG1wW2kgPj0gcG9zID8gaSArIDEgOiBpXSA9IHBhci5jaGlsZHJlbltpXTtcXG4gICAgICB9XFxuXFxuICAgICAgdG1wW3Bvc10gPSBub2RlLmlkO1xcbiAgICAgIHBhci5jaGlsZHJlbiA9IHRtcDtcXG4gICAgICB0aGlzLnJlZHJhd19ub2RlKHBhciwgdHJ1ZSk7XFxuXFxuICAgICAgaWYgKGNhbGxiYWNrKSB7XFxuICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXMsIHRoaXMuZ2V0X25vZGUobm9kZSkpO1xcbiAgICAgIH1cXG4gICAgICAvKipcXG4gICAgICAgKiB0cmlnZ2VyZWQgd2hlbiBhIG5vZGUgaXMgY3JlYXRlZFxcbiAgICAgICAqIEBldmVudFxcbiAgICAgICAqIEBuYW1lIGNyZWF0ZV9ub2RlLmpzdHJlZVxcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlXFxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmVudCB0aGUgcGFyZW50J3MgSURcXG4gICAgICAgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb24gdGhlIHBvc2l0aW9uIG9mIHRoZSBuZXcgbm9kZSBhbW9uZyB0aGUgcGFyZW50J3MgY2hpbGRyZW5cXG4gICAgICAgKi9cXG5cXG5cXG4gICAgICB0aGlzLnRyaWdnZXIoJ2NyZWF0ZV9ub2RlJywge1xcbiAgICAgICAgXFxcIm5vZGVcXFwiOiB0aGlzLmdldF9ub2RlKG5vZGUpLFxcbiAgICAgICAgXFxcInBhcmVudFxcXCI6IHBhci5pZCxcXG4gICAgICAgIFxcXCJwb3NpdGlvblxcXCI6IHBvc1xcbiAgICAgIH0pO1xcbiAgICAgIHJldHVybiBub2RlLmlkO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogc2V0IHRoZSB0ZXh0IHZhbHVlIG9mIGEgbm9kZVxcbiAgICAgKiBAbmFtZSByZW5hbWVfbm9kZShvYmosIHZhbClcXG4gICAgICogQHBhcmFtICB7bWl4ZWR9IG9iaiB0aGUgbm9kZSwgeW91IGNhbiBwYXNzIGFuIGFycmF5IHRvIHJlbmFtZSBtdWx0aXBsZSBub2RlcyB0byB0aGUgc2FtZSBuYW1lXFxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gdmFsIHRoZSBuZXcgdGV4dCB2YWx1ZVxcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxcbiAgICAgKiBAdHJpZ2dlciByZW5hbWVfbm9kZS5qc3RyZWVcXG4gICAgICovXFxuICAgIHJlbmFtZV9ub2RlOiBmdW5jdGlvbiByZW5hbWVfbm9kZShvYmosIHZhbCkge1xcbiAgICAgIHZhciB0MSwgdDIsIG9sZDtcXG5cXG4gICAgICBpZiAoJC5pc0FycmF5KG9iaikpIHtcXG4gICAgICAgIG9iaiA9IG9iai5zbGljZSgpO1xcblxcbiAgICAgICAgZm9yICh0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xcbiAgICAgICAgICB0aGlzLnJlbmFtZV9ub2RlKG9ialt0MV0sIHZhbCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICB9XFxuXFxuICAgICAgb2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xcblxcbiAgICAgIGlmICghb2JqIHx8IG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCkge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICBvbGQgPSBvYmoudGV4dDtcXG5cXG4gICAgICBpZiAoIXRoaXMuY2hlY2soXFxcInJlbmFtZV9ub2RlXFxcIiwgb2JqLCB0aGlzLmdldF9wYXJlbnQob2JqKSwgdmFsKSkge1xcbiAgICAgICAgdGhpcy5zZXR0aW5ncy5jb3JlLmVycm9yLmNhbGwodGhpcywgdGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IpO1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLnNldF90ZXh0KG9iaiwgdmFsKTsgLy8gLmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpXFxuXFxuICAgICAgLyoqXFxuICAgICAgICogdHJpZ2dlcmVkIHdoZW4gYSBub2RlIGlzIHJlbmFtZWRcXG4gICAgICAgKiBAZXZlbnRcXG4gICAgICAgKiBAbmFtZSByZW5hbWVfbm9kZS5qc3RyZWVcXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZVxcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IHRoZSBuZXcgdmFsdWVcXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkIHRoZSBvbGQgdmFsdWVcXG4gICAgICAgKi9cXG5cXG4gICAgICB0aGlzLnRyaWdnZXIoJ3JlbmFtZV9ub2RlJywge1xcbiAgICAgICAgXFxcIm5vZGVcXFwiOiBvYmosXFxuICAgICAgICBcXFwidGV4dFxcXCI6IHZhbCxcXG4gICAgICAgIFxcXCJvbGRcXFwiOiBvbGRcXG4gICAgICB9KTtcXG4gICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIHJlbW92ZSBhIG5vZGVcXG4gICAgICogQG5hbWUgZGVsZXRlX25vZGUob2JqKVxcbiAgICAgKiBAcGFyYW0gIHttaXhlZH0gb2JqIHRoZSBub2RlLCB5b3UgY2FuIHBhc3MgYW4gYXJyYXkgdG8gZGVsZXRlIG11bHRpcGxlIG5vZGVzXFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XFxuICAgICAqIEB0cmlnZ2VyIGRlbGV0ZV9ub2RlLmpzdHJlZSwgY2hhbmdlZC5qc3RyZWVcXG4gICAgICovXFxuICAgIGRlbGV0ZV9ub2RlOiBmdW5jdGlvbiBkZWxldGVfbm9kZShvYmopIHtcXG4gICAgICB2YXIgdDEsIHQyLCBwYXIsIHBvcywgdG1wLCBpLCBqLCBrLCBsLCBjLCB0b3AsIGxmdDtcXG5cXG4gICAgICBpZiAoJC5pc0FycmF5KG9iaikpIHtcXG4gICAgICAgIG9iaiA9IG9iai5zbGljZSgpO1xcblxcbiAgICAgICAgZm9yICh0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xcbiAgICAgICAgICB0aGlzLmRlbGV0ZV9ub2RlKG9ialt0MV0pO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgfVxcblxcbiAgICAgIG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXG4gICAgICBpZiAoIW9iaiB8fCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgcGFyID0gdGhpcy5nZXRfbm9kZShvYmoucGFyZW50KTtcXG4gICAgICBwb3MgPSAkLmluQXJyYXkob2JqLmlkLCBwYXIuY2hpbGRyZW4pO1xcbiAgICAgIGMgPSBmYWxzZTtcXG5cXG4gICAgICBpZiAoIXRoaXMuY2hlY2soXFxcImRlbGV0ZV9ub2RlXFxcIiwgb2JqLCBwYXIsIHBvcykpIHtcXG4gICAgICAgIHRoaXMuc2V0dGluZ3MuY29yZS5lcnJvci5jYWxsKHRoaXMsIHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yKTtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHBvcyAhPT0gLTEpIHtcXG4gICAgICAgIHBhci5jaGlsZHJlbiA9ICQudmFrYXRhLmFycmF5X3JlbW92ZShwYXIuY2hpbGRyZW4sIHBvcyk7XFxuICAgICAgfVxcblxcbiAgICAgIHRtcCA9IG9iai5jaGlsZHJlbl9kLmNvbmNhdChbXSk7XFxuICAgICAgdG1wLnB1c2gob2JqLmlkKTtcXG5cXG4gICAgICBmb3IgKGkgPSAwLCBqID0gb2JqLnBhcmVudHMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICB0aGlzLl9tb2RlbC5kYXRhW29iai5wYXJlbnRzW2ldXS5jaGlsZHJlbl9kID0gJC52YWthdGEuYXJyYXlfZmlsdGVyKHRoaXMuX21vZGVsLmRhdGFbb2JqLnBhcmVudHNbaV1dLmNoaWxkcmVuX2QsIGZ1bmN0aW9uICh2KSB7XFxuICAgICAgICAgIHJldHVybiAkLmluQXJyYXkodiwgdG1wKSA9PT0gLTE7XFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuXFxuICAgICAgZm9yIChrID0gMCwgbCA9IHRtcC5sZW5ndGg7IGsgPCBsOyBrKyspIHtcXG4gICAgICAgIGlmICh0aGlzLl9tb2RlbC5kYXRhW3RtcFtrXV0uc3RhdGUuc2VsZWN0ZWQpIHtcXG4gICAgICAgICAgYyA9IHRydWU7XFxuICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoYykge1xcbiAgICAgICAgdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkID0gJC52YWthdGEuYXJyYXlfZmlsdGVyKHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZCwgZnVuY3Rpb24gKHYpIHtcXG4gICAgICAgICAgcmV0dXJuICQuaW5BcnJheSh2LCB0bXApID09PSAtMTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG4gICAgICAvKipcXG4gICAgICAgKiB0cmlnZ2VyZWQgd2hlbiBhIG5vZGUgaXMgZGVsZXRlZFxcbiAgICAgICAqIEBldmVudFxcbiAgICAgICAqIEBuYW1lIGRlbGV0ZV9ub2RlLmpzdHJlZVxcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlXFxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmVudCB0aGUgcGFyZW50J3MgSURcXG4gICAgICAgKi9cXG5cXG5cXG4gICAgICB0aGlzLnRyaWdnZXIoJ2RlbGV0ZV9ub2RlJywge1xcbiAgICAgICAgXFxcIm5vZGVcXFwiOiBvYmosXFxuICAgICAgICBcXFwicGFyZW50XFxcIjogcGFyLmlkXFxuICAgICAgfSk7XFxuXFxuICAgICAgaWYgKGMpIHtcXG4gICAgICAgIHRoaXMudHJpZ2dlcignY2hhbmdlZCcsIHtcXG4gICAgICAgICAgJ2FjdGlvbic6ICdkZWxldGVfbm9kZScsXFxuICAgICAgICAgICdub2RlJzogb2JqLFxcbiAgICAgICAgICAnc2VsZWN0ZWQnOiB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQsXFxuICAgICAgICAgICdwYXJlbnQnOiBwYXIuaWRcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG5cXG4gICAgICBmb3IgKGsgPSAwLCBsID0gdG1wLmxlbmd0aDsgayA8IGw7IGsrKykge1xcbiAgICAgICAgZGVsZXRlIHRoaXMuX21vZGVsLmRhdGFbdG1wW2tdXTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCQuaW5BcnJheSh0aGlzLl9kYXRhLmNvcmUuZm9jdXNlZCwgdG1wKSAhPT0gLTEpIHtcXG4gICAgICAgIHRoaXMuX2RhdGEuY29yZS5mb2N1c2VkID0gbnVsbDtcXG4gICAgICAgIHRvcCA9IHRoaXMuZWxlbWVudFswXS5zY3JvbGxUb3A7XFxuICAgICAgICBsZnQgPSB0aGlzLmVsZW1lbnRbMF0uc2Nyb2xsTGVmdDtcXG5cXG4gICAgICAgIGlmIChwYXIuaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcXG4gICAgICAgICAgaWYgKHRoaXMuX21vZGVsLmRhdGFbJC5qc3RyZWUucm9vdF0uY2hpbGRyZW5bMF0pIHtcXG4gICAgICAgICAgICB0aGlzLmdldF9ub2RlKHRoaXMuX21vZGVsLmRhdGFbJC5qc3RyZWUucm9vdF0uY2hpbGRyZW5bMF0sIHRydWUpLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLmZvY3VzKCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHRoaXMuZ2V0X25vZGUocGFyLCB0cnVlKS5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5mb2N1cygpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdGhpcy5lbGVtZW50WzBdLnNjcm9sbFRvcCA9IHRvcDtcXG4gICAgICAgIHRoaXMuZWxlbWVudFswXS5zY3JvbGxMZWZ0ID0gbGZ0O1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLnJlZHJhd19ub2RlKHBhciwgdHJ1ZSk7XFxuICAgICAgcmV0dXJuIHRydWU7XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBjaGVjayBpZiBhbiBvcGVyYXRpb24gaXMgcHJlbWl0dGVkIG9uIHRoZSB0cmVlLiBVc2VkIGludGVybmFsbHkuXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBuYW1lIGNoZWNrKGNoaywgb2JqLCBwYXIsIHBvcylcXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBjaGsgdGhlIG9wZXJhdGlvbiB0byBjaGVjaywgY2FuIGJlIFxcXCJjcmVhdGVfbm9kZVxcXCIsIFxcXCJyZW5hbWVfbm9kZVxcXCIsIFxcXCJkZWxldGVfbm9kZVxcXCIsIFxcXCJjb3B5X25vZGVcXFwiIG9yIFxcXCJtb3ZlX25vZGVcXFwiXFxuICAgICAqIEBwYXJhbSAge21peGVkfSBvYmogdGhlIG5vZGVcXG4gICAgICogQHBhcmFtICB7bWl4ZWR9IHBhciB0aGUgcGFyZW50XFxuICAgICAqIEBwYXJhbSAge21peGVkfSBwb3MgdGhlIHBvc2l0aW9uIHRvIGluc2VydCBhdCwgb3IgaWYgXFxcInJlbmFtZV9ub2RlXFxcIiAtIHRoZSBuZXcgbmFtZVxcbiAgICAgKiBAcGFyYW0gIHttaXhlZH0gbW9yZSBzb21lIHZhcmlvdXMgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiwgZm9yIGV4YW1wbGUgaWYgYSBcXFwibW92ZV9ub2RlXFxcIiBvcGVyYXRpb25zIGlzIHRyaWdnZXJlZCBieSBETkQgdGhpcyB3aWxsIGJlIHRoZSBob3ZlcmVkIG5vZGVcXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cXG4gICAgICovXFxuICAgIGNoZWNrOiBmdW5jdGlvbiBjaGVjayhjaGssIG9iaiwgcGFyLCBwb3MsIG1vcmUpIHtcXG4gICAgICBvYmogPSBvYmogJiYgb2JqLmlkID8gb2JqIDogdGhpcy5nZXRfbm9kZShvYmopO1xcbiAgICAgIHBhciA9IHBhciAmJiBwYXIuaWQgPyBwYXIgOiB0aGlzLmdldF9ub2RlKHBhcik7XFxuICAgICAgdmFyIHRtcCA9IGNoay5tYXRjaCgvXm1vdmVfbm9kZXxjb3B5X25vZGV8Y3JlYXRlX25vZGUkL2kpID8gcGFyIDogb2JqLFxcbiAgICAgICAgICBjaGMgPSB0aGlzLnNldHRpbmdzLmNvcmUuY2hlY2tfY2FsbGJhY2s7XFxuXFxuICAgICAgaWYgKGNoayA9PT0gXFxcIm1vdmVfbm9kZVxcXCIgfHwgY2hrID09PSBcXFwiY29weV9ub2RlXFxcIikge1xcbiAgICAgICAgaWYgKCghbW9yZSB8fCAhbW9yZS5pc19tdWx0aSkgJiYgKG9iai5pZCA9PT0gcGFyLmlkIHx8IGNoayA9PT0gXFxcIm1vdmVfbm9kZVxcXCIgJiYgJC5pbkFycmF5KG9iai5pZCwgcGFyLmNoaWxkcmVuKSA9PT0gcG9zIHx8ICQuaW5BcnJheShwYXIuaWQsIG9iai5jaGlsZHJlbl9kKSAhPT0gLTEpKSB7XFxuICAgICAgICAgIHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yID0ge1xcbiAgICAgICAgICAgICdlcnJvcic6ICdjaGVjaycsXFxuICAgICAgICAgICAgJ3BsdWdpbic6ICdjb3JlJyxcXG4gICAgICAgICAgICAnaWQnOiAnY29yZV8wMScsXFxuICAgICAgICAgICAgJ3JlYXNvbic6ICdNb3ZpbmcgcGFyZW50IGluc2lkZSBjaGlsZCcsXFxuICAgICAgICAgICAgJ2RhdGEnOiBKU09OLnN0cmluZ2lmeSh7XFxuICAgICAgICAgICAgICAnY2hrJzogY2hrLFxcbiAgICAgICAgICAgICAgJ3Bvcyc6IHBvcyxcXG4gICAgICAgICAgICAgICdvYmonOiBvYmogJiYgb2JqLmlkID8gb2JqLmlkIDogZmFsc2UsXFxuICAgICAgICAgICAgICAncGFyJzogcGFyICYmIHBhci5pZCA/IHBhci5pZCA6IGZhbHNlXFxuICAgICAgICAgICAgfSlcXG4gICAgICAgICAgfTtcXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodG1wICYmIHRtcC5kYXRhKSB7XFxuICAgICAgICB0bXAgPSB0bXAuZGF0YTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRtcCAmJiB0bXAuZnVuY3Rpb25zICYmICh0bXAuZnVuY3Rpb25zW2Noa10gPT09IGZhbHNlIHx8IHRtcC5mdW5jdGlvbnNbY2hrXSA9PT0gdHJ1ZSkpIHtcXG4gICAgICAgIGlmICh0bXAuZnVuY3Rpb25zW2Noa10gPT09IGZhbHNlKSB7XFxuICAgICAgICAgIHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yID0ge1xcbiAgICAgICAgICAgICdlcnJvcic6ICdjaGVjaycsXFxuICAgICAgICAgICAgJ3BsdWdpbic6ICdjb3JlJyxcXG4gICAgICAgICAgICAnaWQnOiAnY29yZV8wMicsXFxuICAgICAgICAgICAgJ3JlYXNvbic6ICdOb2RlIGRhdGEgcHJldmVudHMgZnVuY3Rpb246ICcgKyBjaGssXFxuICAgICAgICAgICAgJ2RhdGEnOiBKU09OLnN0cmluZ2lmeSh7XFxuICAgICAgICAgICAgICAnY2hrJzogY2hrLFxcbiAgICAgICAgICAgICAgJ3Bvcyc6IHBvcyxcXG4gICAgICAgICAgICAgICdvYmonOiBvYmogJiYgb2JqLmlkID8gb2JqLmlkIDogZmFsc2UsXFxuICAgICAgICAgICAgICAncGFyJzogcGFyICYmIHBhci5pZCA/IHBhci5pZCA6IGZhbHNlXFxuICAgICAgICAgICAgfSlcXG4gICAgICAgICAgfTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiB0bXAuZnVuY3Rpb25zW2Noa107XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChjaGMgPT09IGZhbHNlIHx8ICQuaXNGdW5jdGlvbihjaGMpICYmIGNoYy5jYWxsKHRoaXMsIGNoaywgb2JqLCBwYXIsIHBvcywgbW9yZSkgPT09IGZhbHNlIHx8IGNoYyAmJiBjaGNbY2hrXSA9PT0gZmFsc2UpIHtcXG4gICAgICAgIHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yID0ge1xcbiAgICAgICAgICAnZXJyb3InOiAnY2hlY2snLFxcbiAgICAgICAgICAncGx1Z2luJzogJ2NvcmUnLFxcbiAgICAgICAgICAnaWQnOiAnY29yZV8wMycsXFxuICAgICAgICAgICdyZWFzb24nOiAnVXNlciBjb25maWcgZm9yIGNvcmUuY2hlY2tfY2FsbGJhY2sgcHJldmVudHMgZnVuY3Rpb246ICcgKyBjaGssXFxuICAgICAgICAgICdkYXRhJzogSlNPTi5zdHJpbmdpZnkoe1xcbiAgICAgICAgICAgICdjaGsnOiBjaGssXFxuICAgICAgICAgICAgJ3Bvcyc6IHBvcyxcXG4gICAgICAgICAgICAnb2JqJzogb2JqICYmIG9iai5pZCA/IG9iai5pZCA6IGZhbHNlLFxcbiAgICAgICAgICAgICdwYXInOiBwYXIgJiYgcGFyLmlkID8gcGFyLmlkIDogZmFsc2VcXG4gICAgICAgICAgfSlcXG4gICAgICAgIH07XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiB0cnVlO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogZ2V0IHRoZSBsYXN0IGVycm9yXFxuICAgICAqIEBuYW1lIGxhc3RfZXJyb3IoKVxcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XFxuICAgICAqL1xcbiAgICBsYXN0X2Vycm9yOiBmdW5jdGlvbiBsYXN0X2Vycm9yKCkge1xcbiAgICAgIHJldHVybiB0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvcjtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIG1vdmUgYSBub2RlIHRvIGEgbmV3IHBhcmVudFxcbiAgICAgKiBAbmFtZSBtb3ZlX25vZGUob2JqLCBwYXIgWywgcG9zLCBjYWxsYmFjaywgaXNfbG9hZGVkXSlcXG4gICAgICogQHBhcmFtICB7bWl4ZWR9IG9iaiB0aGUgbm9kZSB0byBtb3ZlLCBwYXNzIGFuIGFycmF5IHRvIG1vdmUgbXVsdGlwbGUgbm9kZXNcXG4gICAgICogQHBhcmFtICB7bWl4ZWR9IHBhciB0aGUgbmV3IHBhcmVudFxcbiAgICAgKiBAcGFyYW0gIHttaXhlZH0gcG9zIHRoZSBwb3NpdGlvbiB0byBpbnNlcnQgYXQgKGJlc2lkZXMgaW50ZWdlciB2YWx1ZXMsIFxcXCJmaXJzdFxcXCIgYW5kIFxcXCJsYXN0XFxcIiBhcmUgc3VwcG9ydGVkLCBhcyB3ZWxsIGFzIFxcXCJiZWZvcmVcXFwiIGFuZCBcXFwiYWZ0ZXJcXFwiKSwgZGVmYXVsdHMgdG8gaW50ZWdlciBgMGBcXG4gICAgICogQHBhcmFtICB7ZnVuY3Rpb259IGNhbGxiYWNrIGEgZnVuY3Rpb24gdG8gY2FsbCBvbmNlIHRoZSBtb3ZlIGlzIGNvbXBsZXRlZCwgcmVjZWl2ZXMgMyBhcmd1bWVudHMgLSB0aGUgbm9kZSwgdGhlIG5ldyBwYXJlbnQgYW5kIHRoZSBwb3NpdGlvblxcbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBpc19sb2FkZWQgaW50ZXJuYWwgcGFyYW1ldGVyIGluZGljYXRpbmcgaWYgdGhlIHBhcmVudCBub2RlIGhhcyBiZWVuIGxvYWRlZFxcbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBza2lwX3JlZHJhdyBpbnRlcm5hbCBwYXJhbWV0ZXIgaW5kaWNhdGluZyBpZiB0aGUgdHJlZSBzaG91bGQgYmUgcmVkcmF3blxcbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBpbnN0YW5jZSBpbnRlcm5hbCBwYXJhbWV0ZXIgaW5kaWNhdGluZyBpZiB0aGUgbm9kZSBjb21lcyBmcm9tIGFub3RoZXIgaW5zdGFuY2VcXG4gICAgICogQHRyaWdnZXIgbW92ZV9ub2RlLmpzdHJlZVxcbiAgICAgKi9cXG4gICAgbW92ZV9ub2RlOiBmdW5jdGlvbiBtb3ZlX25vZGUob2JqLCBwYXIsIHBvcywgY2FsbGJhY2ssIGlzX2xvYWRlZCwgc2tpcF9yZWRyYXcsIG9yaWdpbikge1xcbiAgICAgIHZhciB0MSwgdDIsIG9sZF9wYXIsIG9sZF9wb3MsIG5ld19wYXIsIG9sZF9pbnMsIGlzX211bHRpLCBkcGMsIHRtcCwgaSwgaiwgaywgbCwgcDtcXG4gICAgICBwYXIgPSB0aGlzLmdldF9ub2RlKHBhcik7XFxuICAgICAgcG9zID0gcG9zID09PSB1bmRlZmluZWQgPyAwIDogcG9zO1xcblxcbiAgICAgIGlmICghcGFyKSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghcG9zLnRvU3RyaW5nKCkubWF0Y2goL14oYmVmb3JlfGFmdGVyKSQvKSAmJiAhaXNfbG9hZGVkICYmICF0aGlzLmlzX2xvYWRlZChwYXIpKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5sb2FkX25vZGUocGFyLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHRoaXMubW92ZV9ub2RlKG9iaiwgcGFyLCBwb3MsIGNhbGxiYWNrLCB0cnVlLCBmYWxzZSwgb3JpZ2luKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoJC5pc0FycmF5KG9iaikpIHtcXG4gICAgICAgIGlmIChvYmoubGVuZ3RoID09PSAxKSB7XFxuICAgICAgICAgIG9iaiA9IG9ialswXTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIC8vb2JqID0gb2JqLnNsaWNlKCk7XFxuICAgICAgICAgIGZvciAodDEgPSAwLCB0MiA9IG9iai5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcXG4gICAgICAgICAgICBpZiAodG1wID0gdGhpcy5tb3ZlX25vZGUob2JqW3QxXSwgcGFyLCBwb3MsIGNhbGxiYWNrLCBpc19sb2FkZWQsIGZhbHNlLCBvcmlnaW4pKSB7XFxuICAgICAgICAgICAgICBwYXIgPSB0bXA7XFxuICAgICAgICAgICAgICBwb3MgPSBcXFwiYWZ0ZXJcXFwiO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICB0aGlzLnJlZHJhdygpO1xcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgb2JqID0gb2JqICYmIG9iai5pZCA/IG9iaiA6IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXG4gICAgICBpZiAoIW9iaiB8fCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgb2xkX3BhciA9IChvYmoucGFyZW50IHx8ICQuanN0cmVlLnJvb3QpLnRvU3RyaW5nKCk7XFxuICAgICAgbmV3X3BhciA9ICFwb3MudG9TdHJpbmcoKS5tYXRjaCgvXihiZWZvcmV8YWZ0ZXIpJC8pIHx8IHBhci5pZCA9PT0gJC5qc3RyZWUucm9vdCA/IHBhciA6IHRoaXMuZ2V0X25vZGUocGFyLnBhcmVudCk7XFxuICAgICAgb2xkX2lucyA9IG9yaWdpbiA/IG9yaWdpbiA6IHRoaXMuX21vZGVsLmRhdGFbb2JqLmlkXSA/IHRoaXMgOiAkLmpzdHJlZS5yZWZlcmVuY2Uob2JqLmlkKTtcXG4gICAgICBpc19tdWx0aSA9ICFvbGRfaW5zIHx8ICFvbGRfaW5zLl9pZCB8fCB0aGlzLl9pZCAhPT0gb2xkX2lucy5faWQ7XFxuICAgICAgb2xkX3BvcyA9IG9sZF9pbnMgJiYgb2xkX2lucy5faWQgJiYgb2xkX3BhciAmJiBvbGRfaW5zLl9tb2RlbC5kYXRhW29sZF9wYXJdICYmIG9sZF9pbnMuX21vZGVsLmRhdGFbb2xkX3Bhcl0uY2hpbGRyZW4gPyAkLmluQXJyYXkob2JqLmlkLCBvbGRfaW5zLl9tb2RlbC5kYXRhW29sZF9wYXJdLmNoaWxkcmVuKSA6IC0xO1xcblxcbiAgICAgIGlmIChvbGRfaW5zICYmIG9sZF9pbnMuX2lkKSB7XFxuICAgICAgICBvYmogPSBvbGRfaW5zLl9tb2RlbC5kYXRhW29iai5pZF07XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChpc19tdWx0aSkge1xcbiAgICAgICAgaWYgKHRtcCA9IHRoaXMuY29weV9ub2RlKG9iaiwgcGFyLCBwb3MsIGNhbGxiYWNrLCBpc19sb2FkZWQsIGZhbHNlLCBvcmlnaW4pKSB7XFxuICAgICAgICAgIGlmIChvbGRfaW5zKSB7XFxuICAgICAgICAgICAgb2xkX2lucy5kZWxldGVfbm9kZShvYmopO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHJldHVybiB0bXA7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfSAvL3ZhciBtID0gdGhpcy5fbW9kZWwuZGF0YTtcXG5cXG5cXG4gICAgICBpZiAocGFyLmlkID09PSAkLmpzdHJlZS5yb290KSB7XFxuICAgICAgICBpZiAocG9zID09PSBcXFwiYmVmb3JlXFxcIikge1xcbiAgICAgICAgICBwb3MgPSBcXFwiZmlyc3RcXFwiO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKHBvcyA9PT0gXFxcImFmdGVyXFxcIikge1xcbiAgICAgICAgICBwb3MgPSBcXFwibGFzdFxcXCI7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHN3aXRjaCAocG9zKSB7XFxuICAgICAgICBjYXNlIFxcXCJiZWZvcmVcXFwiOlxcbiAgICAgICAgICBwb3MgPSAkLmluQXJyYXkocGFyLmlkLCBuZXdfcGFyLmNoaWxkcmVuKTtcXG4gICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICBjYXNlIFxcXCJhZnRlclxcXCI6XFxuICAgICAgICAgIHBvcyA9ICQuaW5BcnJheShwYXIuaWQsIG5ld19wYXIuY2hpbGRyZW4pICsgMTtcXG4gICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICBjYXNlIFxcXCJpbnNpZGVcXFwiOlxcbiAgICAgICAgY2FzZSBcXFwiZmlyc3RcXFwiOlxcbiAgICAgICAgICBwb3MgPSAwO1xcbiAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgIGNhc2UgXFxcImxhc3RcXFwiOlxcbiAgICAgICAgICBwb3MgPSBuZXdfcGFyLmNoaWxkcmVuLmxlbmd0aDtcXG4gICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICBkZWZhdWx0OlxcbiAgICAgICAgICBpZiAoIXBvcykge1xcbiAgICAgICAgICAgIHBvcyA9IDA7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChwb3MgPiBuZXdfcGFyLmNoaWxkcmVuLmxlbmd0aCkge1xcbiAgICAgICAgcG9zID0gbmV3X3Bhci5jaGlsZHJlbi5sZW5ndGg7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghdGhpcy5jaGVjayhcXFwibW92ZV9ub2RlXFxcIiwgb2JqLCBuZXdfcGFyLCBwb3MsIHtcXG4gICAgICAgICdjb3JlJzogdHJ1ZSxcXG4gICAgICAgICdvcmlnaW4nOiBvcmlnaW4sXFxuICAgICAgICAnaXNfbXVsdGknOiBvbGRfaW5zICYmIG9sZF9pbnMuX2lkICYmIG9sZF9pbnMuX2lkICE9PSB0aGlzLl9pZCxcXG4gICAgICAgICdpc19mb3JlaWduJzogIW9sZF9pbnMgfHwgIW9sZF9pbnMuX2lkXFxuICAgICAgfSkpIHtcXG4gICAgICAgIHRoaXMuc2V0dGluZ3MuY29yZS5lcnJvci5jYWxsKHRoaXMsIHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yKTtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKG9iai5wYXJlbnQgPT09IG5ld19wYXIuaWQpIHtcXG4gICAgICAgIGRwYyA9IG5ld19wYXIuY2hpbGRyZW4uY29uY2F0KCk7XFxuICAgICAgICB0bXAgPSAkLmluQXJyYXkob2JqLmlkLCBkcGMpO1xcblxcbiAgICAgICAgaWYgKHRtcCAhPT0gLTEpIHtcXG4gICAgICAgICAgZHBjID0gJC52YWthdGEuYXJyYXlfcmVtb3ZlKGRwYywgdG1wKTtcXG5cXG4gICAgICAgICAgaWYgKHBvcyA+IHRtcCkge1xcbiAgICAgICAgICAgIHBvcy0tO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0bXAgPSBbXTtcXG5cXG4gICAgICAgIGZvciAoaSA9IDAsIGogPSBkcGMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICAgIHRtcFtpID49IHBvcyA/IGkgKyAxIDogaV0gPSBkcGNbaV07XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0bXBbcG9zXSA9IG9iai5pZDtcXG4gICAgICAgIG5ld19wYXIuY2hpbGRyZW4gPSB0bXA7XFxuXFxuICAgICAgICB0aGlzLl9ub2RlX2NoYW5nZWQobmV3X3Bhci5pZCk7XFxuXFxuICAgICAgICB0aGlzLnJlZHJhdyhuZXdfcGFyLmlkID09PSAkLmpzdHJlZS5yb290KTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgLy8gY2xlYW4gb2xkIHBhcmVudCBhbmQgdXBcXG4gICAgICAgIHRtcCA9IG9iai5jaGlsZHJlbl9kLmNvbmNhdCgpO1xcbiAgICAgICAgdG1wLnB1c2gob2JqLmlkKTtcXG5cXG4gICAgICAgIGZvciAoaSA9IDAsIGogPSBvYmoucGFyZW50cy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG4gICAgICAgICAgZHBjID0gW107XFxuICAgICAgICAgIHAgPSBvbGRfaW5zLl9tb2RlbC5kYXRhW29iai5wYXJlbnRzW2ldXS5jaGlsZHJlbl9kO1xcblxcbiAgICAgICAgICBmb3IgKGsgPSAwLCBsID0gcC5sZW5ndGg7IGsgPCBsOyBrKyspIHtcXG4gICAgICAgICAgICBpZiAoJC5pbkFycmF5KHBba10sIHRtcCkgPT09IC0xKSB7XFxuICAgICAgICAgICAgICBkcGMucHVzaChwW2tdKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgb2xkX2lucy5fbW9kZWwuZGF0YVtvYmoucGFyZW50c1tpXV0uY2hpbGRyZW5fZCA9IGRwYztcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIG9sZF9pbnMuX21vZGVsLmRhdGFbb2xkX3Bhcl0uY2hpbGRyZW4gPSAkLnZha2F0YS5hcnJheV9yZW1vdmVfaXRlbShvbGRfaW5zLl9tb2RlbC5kYXRhW29sZF9wYXJdLmNoaWxkcmVuLCBvYmouaWQpOyAvLyBpbnNlcnQgaW50byBuZXcgcGFyZW50IGFuZCB1cFxcblxcbiAgICAgICAgZm9yIChpID0gMCwgaiA9IG5ld19wYXIucGFyZW50cy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG4gICAgICAgICAgdGhpcy5fbW9kZWwuZGF0YVtuZXdfcGFyLnBhcmVudHNbaV1dLmNoaWxkcmVuX2QgPSB0aGlzLl9tb2RlbC5kYXRhW25ld19wYXIucGFyZW50c1tpXV0uY2hpbGRyZW5fZC5jb25jYXQodG1wKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGRwYyA9IFtdO1xcblxcbiAgICAgICAgZm9yIChpID0gMCwgaiA9IG5ld19wYXIuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICAgIGRwY1tpID49IHBvcyA/IGkgKyAxIDogaV0gPSBuZXdfcGFyLmNoaWxkcmVuW2ldO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZHBjW3Bvc10gPSBvYmouaWQ7XFxuICAgICAgICBuZXdfcGFyLmNoaWxkcmVuID0gZHBjO1xcbiAgICAgICAgbmV3X3Bhci5jaGlsZHJlbl9kLnB1c2gob2JqLmlkKTtcXG4gICAgICAgIG5ld19wYXIuY2hpbGRyZW5fZCA9IG5ld19wYXIuY2hpbGRyZW5fZC5jb25jYXQob2JqLmNoaWxkcmVuX2QpOyAvLyB1cGRhdGUgb2JqZWN0XFxuXFxuICAgICAgICBvYmoucGFyZW50ID0gbmV3X3Bhci5pZDtcXG4gICAgICAgIHRtcCA9IG5ld19wYXIucGFyZW50cy5jb25jYXQoKTtcXG4gICAgICAgIHRtcC51bnNoaWZ0KG5ld19wYXIuaWQpO1xcbiAgICAgICAgcCA9IG9iai5wYXJlbnRzLmxlbmd0aDtcXG4gICAgICAgIG9iai5wYXJlbnRzID0gdG1wOyAvLyB1cGRhdGUgb2JqZWN0IGNoaWxkcmVuXFxuXFxuICAgICAgICB0bXAgPSB0bXAuY29uY2F0KCk7XFxuXFxuICAgICAgICBmb3IgKGkgPSAwLCBqID0gb2JqLmNoaWxkcmVuX2QubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICAgIHRoaXMuX21vZGVsLmRhdGFbb2JqLmNoaWxkcmVuX2RbaV1dLnBhcmVudHMgPSB0aGlzLl9tb2RlbC5kYXRhW29iai5jaGlsZHJlbl9kW2ldXS5wYXJlbnRzLnNsaWNlKDAsIHAgKiAtMSk7XFxuICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHRoaXMuX21vZGVsLmRhdGFbb2JqLmNoaWxkcmVuX2RbaV1dLnBhcmVudHMsIHRtcCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAob2xkX3BhciA9PT0gJC5qc3RyZWUucm9vdCB8fCBuZXdfcGFyLmlkID09PSAkLmpzdHJlZS5yb290KSB7XFxuICAgICAgICAgIHRoaXMuX21vZGVsLmZvcmNlX2Z1bGxfcmVkcmF3ID0gdHJ1ZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICghdGhpcy5fbW9kZWwuZm9yY2VfZnVsbF9yZWRyYXcpIHtcXG4gICAgICAgICAgdGhpcy5fbm9kZV9jaGFuZ2VkKG9sZF9wYXIpO1xcblxcbiAgICAgICAgICB0aGlzLl9ub2RlX2NoYW5nZWQobmV3X3Bhci5pZCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoIXNraXBfcmVkcmF3KSB7XFxuICAgICAgICAgIHRoaXMucmVkcmF3KCk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChjYWxsYmFjaykge1xcbiAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCBvYmosIG5ld19wYXIsIHBvcyk7XFxuICAgICAgfVxcbiAgICAgIC8qKlxcbiAgICAgICAqIHRyaWdnZXJlZCB3aGVuIGEgbm9kZSBpcyBtb3ZlZFxcbiAgICAgICAqIEBldmVudFxcbiAgICAgICAqIEBuYW1lIG1vdmVfbm9kZS5qc3RyZWVcXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZVxcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJlbnQgdGhlIHBhcmVudCdzIElEXFxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uIHRoZSBwb3NpdGlvbiBvZiB0aGUgbm9kZSBhbW9uZyB0aGUgcGFyZW50J3MgY2hpbGRyZW5cXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkX3BhcmVudCB0aGUgb2xkIHBhcmVudCBvZiB0aGUgbm9kZVxcbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRfcG9zaXRpb24gdGhlIG9sZCBwb3NpdGlvbiBvZiB0aGUgbm9kZVxcbiAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNfbXVsdGkgZG8gdGhlIG5vZGUgYW5kIG5ldyBwYXJlbnQgYmVsb25nIHRvIGRpZmZlcmVudCBpbnN0YW5jZXNcXG4gICAgICAgKiBAcGFyYW0ge2pzVHJlZX0gb2xkX2luc3RhbmNlIHRoZSBpbnN0YW5jZSB0aGUgbm9kZSBjYW1lIGZyb21cXG4gICAgICAgKiBAcGFyYW0ge2pzVHJlZX0gbmV3X2luc3RhbmNlIHRoZSBpbnN0YW5jZSBvZiB0aGUgbmV3IHBhcmVudFxcbiAgICAgICAqL1xcblxcblxcbiAgICAgIHRoaXMudHJpZ2dlcignbW92ZV9ub2RlJywge1xcbiAgICAgICAgXFxcIm5vZGVcXFwiOiBvYmosXFxuICAgICAgICBcXFwicGFyZW50XFxcIjogbmV3X3Bhci5pZCxcXG4gICAgICAgIFxcXCJwb3NpdGlvblxcXCI6IHBvcyxcXG4gICAgICAgIFxcXCJvbGRfcGFyZW50XFxcIjogb2xkX3BhcixcXG4gICAgICAgIFxcXCJvbGRfcG9zaXRpb25cXFwiOiBvbGRfcG9zLFxcbiAgICAgICAgJ2lzX211bHRpJzogb2xkX2lucyAmJiBvbGRfaW5zLl9pZCAmJiBvbGRfaW5zLl9pZCAhPT0gdGhpcy5faWQsXFxuICAgICAgICAnaXNfZm9yZWlnbic6ICFvbGRfaW5zIHx8ICFvbGRfaW5zLl9pZCxcXG4gICAgICAgICdvbGRfaW5zdGFuY2UnOiBvbGRfaW5zLFxcbiAgICAgICAgJ25ld19pbnN0YW5jZSc6IHRoaXNcXG4gICAgICB9KTtcXG4gICAgICByZXR1cm4gb2JqLmlkO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogY29weSBhIG5vZGUgdG8gYSBuZXcgcGFyZW50XFxuICAgICAqIEBuYW1lIGNvcHlfbm9kZShvYmosIHBhciBbLCBwb3MsIGNhbGxiYWNrLCBpc19sb2FkZWRdKVxcbiAgICAgKiBAcGFyYW0gIHttaXhlZH0gb2JqIHRoZSBub2RlIHRvIGNvcHksIHBhc3MgYW4gYXJyYXkgdG8gY29weSBtdWx0aXBsZSBub2Rlc1xcbiAgICAgKiBAcGFyYW0gIHttaXhlZH0gcGFyIHRoZSBuZXcgcGFyZW50XFxuICAgICAqIEBwYXJhbSAge21peGVkfSBwb3MgdGhlIHBvc2l0aW9uIHRvIGluc2VydCBhdCAoYmVzaWRlcyBpbnRlZ2VyIHZhbHVlcywgXFxcImZpcnN0XFxcIiBhbmQgXFxcImxhc3RcXFwiIGFyZSBzdXBwb3J0ZWQsIGFzIHdlbGwgYXMgXFxcImJlZm9yZVxcXCIgYW5kIFxcXCJhZnRlclxcXCIpLCBkZWZhdWx0cyB0byBpbnRlZ2VyIGAwYFxcbiAgICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gY2FsbGJhY2sgYSBmdW5jdGlvbiB0byBjYWxsIG9uY2UgdGhlIG1vdmUgaXMgY29tcGxldGVkLCByZWNlaXZlcyAzIGFyZ3VtZW50cyAtIHRoZSBub2RlLCB0aGUgbmV3IHBhcmVudCBhbmQgdGhlIHBvc2l0aW9uXFxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IGlzX2xvYWRlZCBpbnRlcm5hbCBwYXJhbWV0ZXIgaW5kaWNhdGluZyBpZiB0aGUgcGFyZW50IG5vZGUgaGFzIGJlZW4gbG9hZGVkXFxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IHNraXBfcmVkcmF3IGludGVybmFsIHBhcmFtZXRlciBpbmRpY2F0aW5nIGlmIHRoZSB0cmVlIHNob3VsZCBiZSByZWRyYXduXFxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IGluc3RhbmNlIGludGVybmFsIHBhcmFtZXRlciBpbmRpY2F0aW5nIGlmIHRoZSBub2RlIGNvbWVzIGZyb20gYW5vdGhlciBpbnN0YW5jZVxcbiAgICAgKiBAdHJpZ2dlciBtb2RlbC5qc3RyZWUgY29weV9ub2RlLmpzdHJlZVxcbiAgICAgKi9cXG4gICAgY29weV9ub2RlOiBmdW5jdGlvbiBjb3B5X25vZGUob2JqLCBwYXIsIHBvcywgY2FsbGJhY2ssIGlzX2xvYWRlZCwgc2tpcF9yZWRyYXcsIG9yaWdpbikge1xcbiAgICAgIHZhciB0MSwgdDIsIGRwYywgdG1wLCBpLCBqLCBub2RlLCBvbGRfcGFyLCBuZXdfcGFyLCBvbGRfaW5zLCBpc19tdWx0aTtcXG4gICAgICBwYXIgPSB0aGlzLmdldF9ub2RlKHBhcik7XFxuICAgICAgcG9zID0gcG9zID09PSB1bmRlZmluZWQgPyAwIDogcG9zO1xcblxcbiAgICAgIGlmICghcGFyKSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghcG9zLnRvU3RyaW5nKCkubWF0Y2goL14oYmVmb3JlfGFmdGVyKSQvKSAmJiAhaXNfbG9hZGVkICYmICF0aGlzLmlzX2xvYWRlZChwYXIpKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5sb2FkX25vZGUocGFyLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHRoaXMuY29weV9ub2RlKG9iaiwgcGFyLCBwb3MsIGNhbGxiYWNrLCB0cnVlLCBmYWxzZSwgb3JpZ2luKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoJC5pc0FycmF5KG9iaikpIHtcXG4gICAgICAgIGlmIChvYmoubGVuZ3RoID09PSAxKSB7XFxuICAgICAgICAgIG9iaiA9IG9ialswXTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIC8vb2JqID0gb2JqLnNsaWNlKCk7XFxuICAgICAgICAgIGZvciAodDEgPSAwLCB0MiA9IG9iai5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcXG4gICAgICAgICAgICBpZiAodG1wID0gdGhpcy5jb3B5X25vZGUob2JqW3QxXSwgcGFyLCBwb3MsIGNhbGxiYWNrLCBpc19sb2FkZWQsIHRydWUsIG9yaWdpbikpIHtcXG4gICAgICAgICAgICAgIHBhciA9IHRtcDtcXG4gICAgICAgICAgICAgIHBvcyA9IFxcXCJhZnRlclxcXCI7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHRoaXMucmVkcmF3KCk7XFxuICAgICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBvYmogPSBvYmogJiYgb2JqLmlkID8gb2JqIDogdGhpcy5nZXRfbm9kZShvYmopO1xcblxcbiAgICAgIGlmICghb2JqIHx8IG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCkge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICBvbGRfcGFyID0gKG9iai5wYXJlbnQgfHwgJC5qc3RyZWUucm9vdCkudG9TdHJpbmcoKTtcXG4gICAgICBuZXdfcGFyID0gIXBvcy50b1N0cmluZygpLm1hdGNoKC9eKGJlZm9yZXxhZnRlcikkLykgfHwgcGFyLmlkID09PSAkLmpzdHJlZS5yb290ID8gcGFyIDogdGhpcy5nZXRfbm9kZShwYXIucGFyZW50KTtcXG4gICAgICBvbGRfaW5zID0gb3JpZ2luID8gb3JpZ2luIDogdGhpcy5fbW9kZWwuZGF0YVtvYmouaWRdID8gdGhpcyA6ICQuanN0cmVlLnJlZmVyZW5jZShvYmouaWQpO1xcbiAgICAgIGlzX211bHRpID0gIW9sZF9pbnMgfHwgIW9sZF9pbnMuX2lkIHx8IHRoaXMuX2lkICE9PSBvbGRfaW5zLl9pZDtcXG5cXG4gICAgICBpZiAob2xkX2lucyAmJiBvbGRfaW5zLl9pZCkge1xcbiAgICAgICAgb2JqID0gb2xkX2lucy5fbW9kZWwuZGF0YVtvYmouaWRdO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAocGFyLmlkID09PSAkLmpzdHJlZS5yb290KSB7XFxuICAgICAgICBpZiAocG9zID09PSBcXFwiYmVmb3JlXFxcIikge1xcbiAgICAgICAgICBwb3MgPSBcXFwiZmlyc3RcXFwiO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKHBvcyA9PT0gXFxcImFmdGVyXFxcIikge1xcbiAgICAgICAgICBwb3MgPSBcXFwibGFzdFxcXCI7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHN3aXRjaCAocG9zKSB7XFxuICAgICAgICBjYXNlIFxcXCJiZWZvcmVcXFwiOlxcbiAgICAgICAgICBwb3MgPSAkLmluQXJyYXkocGFyLmlkLCBuZXdfcGFyLmNoaWxkcmVuKTtcXG4gICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICBjYXNlIFxcXCJhZnRlclxcXCI6XFxuICAgICAgICAgIHBvcyA9ICQuaW5BcnJheShwYXIuaWQsIG5ld19wYXIuY2hpbGRyZW4pICsgMTtcXG4gICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICBjYXNlIFxcXCJpbnNpZGVcXFwiOlxcbiAgICAgICAgY2FzZSBcXFwiZmlyc3RcXFwiOlxcbiAgICAgICAgICBwb3MgPSAwO1xcbiAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgIGNhc2UgXFxcImxhc3RcXFwiOlxcbiAgICAgICAgICBwb3MgPSBuZXdfcGFyLmNoaWxkcmVuLmxlbmd0aDtcXG4gICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICBkZWZhdWx0OlxcbiAgICAgICAgICBpZiAoIXBvcykge1xcbiAgICAgICAgICAgIHBvcyA9IDA7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChwb3MgPiBuZXdfcGFyLmNoaWxkcmVuLmxlbmd0aCkge1xcbiAgICAgICAgcG9zID0gbmV3X3Bhci5jaGlsZHJlbi5sZW5ndGg7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghdGhpcy5jaGVjayhcXFwiY29weV9ub2RlXFxcIiwgb2JqLCBuZXdfcGFyLCBwb3MsIHtcXG4gICAgICAgICdjb3JlJzogdHJ1ZSxcXG4gICAgICAgICdvcmlnaW4nOiBvcmlnaW4sXFxuICAgICAgICAnaXNfbXVsdGknOiBvbGRfaW5zICYmIG9sZF9pbnMuX2lkICYmIG9sZF9pbnMuX2lkICE9PSB0aGlzLl9pZCxcXG4gICAgICAgICdpc19mb3JlaWduJzogIW9sZF9pbnMgfHwgIW9sZF9pbnMuX2lkXFxuICAgICAgfSkpIHtcXG4gICAgICAgIHRoaXMuc2V0dGluZ3MuY29yZS5lcnJvci5jYWxsKHRoaXMsIHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yKTtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgbm9kZSA9IG9sZF9pbnMgPyBvbGRfaW5zLmdldF9qc29uKG9iaiwge1xcbiAgICAgICAgbm9faWQ6IHRydWUsXFxuICAgICAgICBub19kYXRhOiB0cnVlLFxcbiAgICAgICAgbm9fc3RhdGU6IHRydWVcXG4gICAgICB9KSA6IG9iajtcXG5cXG4gICAgICBpZiAoIW5vZGUpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKG5vZGUuaWQgPT09IHRydWUpIHtcXG4gICAgICAgIGRlbGV0ZSBub2RlLmlkO1xcbiAgICAgIH1cXG5cXG4gICAgICBub2RlID0gdGhpcy5fcGFyc2VfbW9kZWxfZnJvbV9qc29uKG5vZGUsIG5ld19wYXIuaWQsIG5ld19wYXIucGFyZW50cy5jb25jYXQoKSk7XFxuXFxuICAgICAgaWYgKCFub2RlKSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcblxcbiAgICAgIHRtcCA9IHRoaXMuZ2V0X25vZGUobm9kZSk7XFxuXFxuICAgICAgaWYgKG9iaiAmJiBvYmouc3RhdGUgJiYgb2JqLnN0YXRlLmxvYWRlZCA9PT0gZmFsc2UpIHtcXG4gICAgICAgIHRtcC5zdGF0ZS5sb2FkZWQgPSBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgZHBjID0gW107XFxuICAgICAgZHBjLnB1c2gobm9kZSk7XFxuICAgICAgZHBjID0gZHBjLmNvbmNhdCh0bXAuY2hpbGRyZW5fZCk7XFxuICAgICAgdGhpcy50cmlnZ2VyKCdtb2RlbCcsIHtcXG4gICAgICAgIFxcXCJub2Rlc1xcXCI6IGRwYyxcXG4gICAgICAgIFxcXCJwYXJlbnRcXFwiOiBuZXdfcGFyLmlkXFxuICAgICAgfSk7IC8vIGluc2VydCBpbnRvIG5ldyBwYXJlbnQgYW5kIHVwXFxuXFxuICAgICAgZm9yIChpID0gMCwgaiA9IG5ld19wYXIucGFyZW50cy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG4gICAgICAgIHRoaXMuX21vZGVsLmRhdGFbbmV3X3Bhci5wYXJlbnRzW2ldXS5jaGlsZHJlbl9kID0gdGhpcy5fbW9kZWwuZGF0YVtuZXdfcGFyLnBhcmVudHNbaV1dLmNoaWxkcmVuX2QuY29uY2F0KGRwYyk7XFxuICAgICAgfVxcblxcbiAgICAgIGRwYyA9IFtdO1xcblxcbiAgICAgIGZvciAoaSA9IDAsIGogPSBuZXdfcGFyLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcbiAgICAgICAgZHBjW2kgPj0gcG9zID8gaSArIDEgOiBpXSA9IG5ld19wYXIuY2hpbGRyZW5baV07XFxuICAgICAgfVxcblxcbiAgICAgIGRwY1twb3NdID0gdG1wLmlkO1xcbiAgICAgIG5ld19wYXIuY2hpbGRyZW4gPSBkcGM7XFxuICAgICAgbmV3X3Bhci5jaGlsZHJlbl9kLnB1c2godG1wLmlkKTtcXG4gICAgICBuZXdfcGFyLmNoaWxkcmVuX2QgPSBuZXdfcGFyLmNoaWxkcmVuX2QuY29uY2F0KHRtcC5jaGlsZHJlbl9kKTtcXG5cXG4gICAgICBpZiAobmV3X3Bhci5pZCA9PT0gJC5qc3RyZWUucm9vdCkge1xcbiAgICAgICAgdGhpcy5fbW9kZWwuZm9yY2VfZnVsbF9yZWRyYXcgPSB0cnVlO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIXRoaXMuX21vZGVsLmZvcmNlX2Z1bGxfcmVkcmF3KSB7XFxuICAgICAgICB0aGlzLl9ub2RlX2NoYW5nZWQobmV3X3Bhci5pZCk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghc2tpcF9yZWRyYXcpIHtcXG4gICAgICAgIHRoaXMucmVkcmF3KG5ld19wYXIuaWQgPT09ICQuanN0cmVlLnJvb3QpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoY2FsbGJhY2spIHtcXG4gICAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgdG1wLCBuZXdfcGFyLCBwb3MpO1xcbiAgICAgIH1cXG4gICAgICAvKipcXG4gICAgICAgKiB0cmlnZ2VyZWQgd2hlbiBhIG5vZGUgaXMgY29waWVkXFxuICAgICAgICogQGV2ZW50XFxuICAgICAgICogQG5hbWUgY29weV9ub2RlLmpzdHJlZVxcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIHRoZSBjb3BpZWQgbm9kZVxcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcmlnaW5hbCB0aGUgb3JpZ2luYWwgbm9kZVxcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJlbnQgdGhlIHBhcmVudCdzIElEXFxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uIHRoZSBwb3NpdGlvbiBvZiB0aGUgbm9kZSBhbW9uZyB0aGUgcGFyZW50J3MgY2hpbGRyZW5cXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkX3BhcmVudCB0aGUgb2xkIHBhcmVudCBvZiB0aGUgbm9kZVxcbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvbGRfcG9zaXRpb24gdGhlIHBvc2l0aW9uIG9mIHRoZSBvcmlnaW5hbCBub2RlXFxuICAgICAgICogQHBhcmFtIHtCb29sZWFufSBpc19tdWx0aSBkbyB0aGUgbm9kZSBhbmQgbmV3IHBhcmVudCBiZWxvbmcgdG8gZGlmZmVyZW50IGluc3RhbmNlc1xcbiAgICAgICAqIEBwYXJhbSB7anNUcmVlfSBvbGRfaW5zdGFuY2UgdGhlIGluc3RhbmNlIHRoZSBub2RlIGNhbWUgZnJvbVxcbiAgICAgICAqIEBwYXJhbSB7anNUcmVlfSBuZXdfaW5zdGFuY2UgdGhlIGluc3RhbmNlIG9mIHRoZSBuZXcgcGFyZW50XFxuICAgICAgICovXFxuXFxuXFxuICAgICAgdGhpcy50cmlnZ2VyKCdjb3B5X25vZGUnLCB7XFxuICAgICAgICBcXFwibm9kZVxcXCI6IHRtcCxcXG4gICAgICAgIFxcXCJvcmlnaW5hbFxcXCI6IG9iaixcXG4gICAgICAgIFxcXCJwYXJlbnRcXFwiOiBuZXdfcGFyLmlkLFxcbiAgICAgICAgXFxcInBvc2l0aW9uXFxcIjogcG9zLFxcbiAgICAgICAgXFxcIm9sZF9wYXJlbnRcXFwiOiBvbGRfcGFyLFxcbiAgICAgICAgXFxcIm9sZF9wb3NpdGlvblxcXCI6IG9sZF9pbnMgJiYgb2xkX2lucy5faWQgJiYgb2xkX3BhciAmJiBvbGRfaW5zLl9tb2RlbC5kYXRhW29sZF9wYXJdICYmIG9sZF9pbnMuX21vZGVsLmRhdGFbb2xkX3Bhcl0uY2hpbGRyZW4gPyAkLmluQXJyYXkob2JqLmlkLCBvbGRfaW5zLl9tb2RlbC5kYXRhW29sZF9wYXJdLmNoaWxkcmVuKSA6IC0xLFxcbiAgICAgICAgJ2lzX211bHRpJzogb2xkX2lucyAmJiBvbGRfaW5zLl9pZCAmJiBvbGRfaW5zLl9pZCAhPT0gdGhpcy5faWQsXFxuICAgICAgICAnaXNfZm9yZWlnbic6ICFvbGRfaW5zIHx8ICFvbGRfaW5zLl9pZCxcXG4gICAgICAgICdvbGRfaW5zdGFuY2UnOiBvbGRfaW5zLFxcbiAgICAgICAgJ25ld19pbnN0YW5jZSc6IHRoaXNcXG4gICAgICB9KTtcXG4gICAgICByZXR1cm4gdG1wLmlkO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogY3V0IGEgbm9kZSAoYSBsYXRlciBjYWxsIHRvIGBwYXN0ZShvYmopYCB3b3VsZCBtb3ZlIHRoZSBub2RlKVxcbiAgICAgKiBAbmFtZSBjdXQob2JqKVxcbiAgICAgKiBAcGFyYW0gIHttaXhlZH0gb2JqIG11bHRpcGxlIG9iamVjdHMgY2FuIGJlIHBhc3NlZCB1c2luZyBhbiBhcnJheVxcbiAgICAgKiBAdHJpZ2dlciBjdXQuanN0cmVlXFxuICAgICAqL1xcbiAgICBjdXQ6IGZ1bmN0aW9uIGN1dChvYmopIHtcXG4gICAgICBpZiAoIW9iaikge1xcbiAgICAgICAgb2JqID0gdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLmNvbmNhdCgpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoISQuaXNBcnJheShvYmopKSB7XFxuICAgICAgICBvYmogPSBbb2JqXTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCFvYmoubGVuZ3RoKSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciB0bXAgPSBbXSxcXG4gICAgICAgICAgbyxcXG4gICAgICAgICAgdDEsXFxuICAgICAgICAgIHQyO1xcblxcbiAgICAgIGZvciAodDEgPSAwLCB0MiA9IG9iai5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcXG4gICAgICAgIG8gPSB0aGlzLmdldF9ub2RlKG9ialt0MV0pO1xcblxcbiAgICAgICAgaWYgKG8gJiYgby5pZCAmJiBvLmlkICE9PSAkLmpzdHJlZS5yb290KSB7XFxuICAgICAgICAgIHRtcC5wdXNoKG8pO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIXRtcC5sZW5ndGgpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgY2NwX25vZGUgPSB0bXA7XFxuICAgICAgY2NwX2luc3QgPSB0aGlzO1xcbiAgICAgIGNjcF9tb2RlID0gJ21vdmVfbm9kZSc7XFxuICAgICAgLyoqXFxuICAgICAgICogdHJpZ2dlcmVkIHdoZW4gbm9kZXMgYXJlIGFkZGVkIHRvIHRoZSBidWZmZXIgZm9yIG1vdmluZ1xcbiAgICAgICAqIEBldmVudFxcbiAgICAgICAqIEBuYW1lIGN1dC5qc3RyZWVcXG4gICAgICAgKiBAcGFyYW0ge0FycmF5fSBub2RlXFxuICAgICAgICovXFxuXFxuICAgICAgdGhpcy50cmlnZ2VyKCdjdXQnLCB7XFxuICAgICAgICBcXFwibm9kZVxcXCI6IG9ialxcbiAgICAgIH0pO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogY29weSBhIG5vZGUgKGEgbGF0ZXIgY2FsbCB0byBgcGFzdGUob2JqKWAgd291bGQgY29weSB0aGUgbm9kZSlcXG4gICAgICogQG5hbWUgY29weShvYmopXFxuICAgICAqIEBwYXJhbSAge21peGVkfSBvYmogbXVsdGlwbGUgb2JqZWN0cyBjYW4gYmUgcGFzc2VkIHVzaW5nIGFuIGFycmF5XFxuICAgICAqIEB0cmlnZ2VyIGNvcHkuanN0cmVlXFxuICAgICAqL1xcbiAgICBjb3B5OiBmdW5jdGlvbiBjb3B5KG9iaikge1xcbiAgICAgIGlmICghb2JqKSB7XFxuICAgICAgICBvYmogPSB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQuY29uY2F0KCk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghJC5pc0FycmF5KG9iaikpIHtcXG4gICAgICAgIG9iaiA9IFtvYmpdO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIW9iai5sZW5ndGgpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIHRtcCA9IFtdLFxcbiAgICAgICAgICBvLFxcbiAgICAgICAgICB0MSxcXG4gICAgICAgICAgdDI7XFxuXFxuICAgICAgZm9yICh0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xcbiAgICAgICAgbyA9IHRoaXMuZ2V0X25vZGUob2JqW3QxXSk7XFxuXFxuICAgICAgICBpZiAobyAmJiBvLmlkICYmIG8uaWQgIT09ICQuanN0cmVlLnJvb3QpIHtcXG4gICAgICAgICAgdG1wLnB1c2gobyk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghdG1wLmxlbmd0aCkge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICBjY3Bfbm9kZSA9IHRtcDtcXG4gICAgICBjY3BfaW5zdCA9IHRoaXM7XFxuICAgICAgY2NwX21vZGUgPSAnY29weV9ub2RlJztcXG4gICAgICAvKipcXG4gICAgICAgKiB0cmlnZ2VyZWQgd2hlbiBub2RlcyBhcmUgYWRkZWQgdG8gdGhlIGJ1ZmZlciBmb3IgY29weWluZ1xcbiAgICAgICAqIEBldmVudFxcbiAgICAgICAqIEBuYW1lIGNvcHkuanN0cmVlXFxuICAgICAgICogQHBhcmFtIHtBcnJheX0gbm9kZVxcbiAgICAgICAqL1xcblxcbiAgICAgIHRoaXMudHJpZ2dlcignY29weScsIHtcXG4gICAgICAgIFxcXCJub2RlXFxcIjogb2JqXFxuICAgICAgfSk7XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBnZXQgdGhlIGN1cnJlbnQgYnVmZmVyIChhbnkgbm9kZXMgdGhhdCBhcmUgd2FpdGluZyBmb3IgYSBwYXN0ZSBvcGVyYXRpb24pXFxuICAgICAqIEBuYW1lIGdldF9idWZmZXIoKVxcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGFuIG9iamVjdCBjb25zaXN0aW5nIG9mIGBtb2RlYCAoXFxcImNvcHlfbm9kZVxcXCIgb3IgXFxcIm1vdmVfbm9kZVxcXCIpLCBgbm9kZWAgKGFuIGFycmF5IG9mIG9iamVjdHMpIGFuZCBgaW5zdGAgKHRoZSBpbnN0YW5jZSlcXG4gICAgICovXFxuICAgIGdldF9idWZmZXI6IGZ1bmN0aW9uIGdldF9idWZmZXIoKSB7XFxuICAgICAgcmV0dXJuIHtcXG4gICAgICAgICdtb2RlJzogY2NwX21vZGUsXFxuICAgICAgICAnbm9kZSc6IGNjcF9ub2RlLFxcbiAgICAgICAgJ2luc3QnOiBjY3BfaW5zdFxcbiAgICAgIH07XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBjaGVjayBpZiB0aGVyZSBpcyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB0byBwYXN0ZVxcbiAgICAgKiBAbmFtZSBjYW5fcGFzdGUoKVxcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxcbiAgICAgKi9cXG4gICAgY2FuX3Bhc3RlOiBmdW5jdGlvbiBjYW5fcGFzdGUoKSB7XFxuICAgICAgcmV0dXJuIGNjcF9tb2RlICE9PSBmYWxzZSAmJiBjY3Bfbm9kZSAhPT0gZmFsc2U7IC8vICYmIGNjcF9pbnN0Ll9tb2RlbC5kYXRhW2NjcF9ub2RlXTtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIGNvcHkgb3IgbW92ZSB0aGUgcHJldmlvdXNseSBjdXQgb3IgY29waWVkIG5vZGVzIHRvIGEgbmV3IHBhcmVudFxcbiAgICAgKiBAbmFtZSBwYXN0ZShvYmogWywgcG9zXSlcXG4gICAgICogQHBhcmFtICB7bWl4ZWR9IG9iaiB0aGUgbmV3IHBhcmVudFxcbiAgICAgKiBAcGFyYW0gIHttaXhlZH0gcG9zIHRoZSBwb3NpdGlvbiB0byBpbnNlcnQgYXQgKGJlc2lkZXMgaW50ZWdlciwgXFxcImZpcnN0XFxcIiBhbmQgXFxcImxhc3RcXFwiIGFyZSBzdXBwb3J0ZWQpLCBkZWZhdWx0cyB0byBpbnRlZ2VyIGAwYFxcbiAgICAgKiBAdHJpZ2dlciBwYXN0ZS5qc3RyZWVcXG4gICAgICovXFxuICAgIHBhc3RlOiBmdW5jdGlvbiBwYXN0ZShvYmosIHBvcykge1xcbiAgICAgIG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXG4gICAgICBpZiAoIW9iaiB8fCAhY2NwX21vZGUgfHwgIWNjcF9tb2RlLm1hdGNoKC9eKGNvcHlfbm9kZXxtb3ZlX25vZGUpJC8pIHx8ICFjY3Bfbm9kZSkge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpc1tjY3BfbW9kZV0oY2NwX25vZGUsIG9iaiwgcG9zLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBjY3BfaW5zdCkpIHtcXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogdHJpZ2dlcmVkIHdoZW4gcGFzdGUgaXMgaW52b2tlZFxcbiAgICAgICAgICogQGV2ZW50XFxuICAgICAgICAgKiBAbmFtZSBwYXN0ZS5qc3RyZWVcXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJlbnQgdGhlIElEIG9mIHRoZSByZWNlaXZpbmcgbm9kZVxcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gbm9kZSB0aGUgbm9kZXMgaW4gdGhlIGJ1ZmZlclxcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG1vZGUgdGhlIHBlcmZvcm1lZCBvcGVyYXRpb24gLSBcXFwiY29weV9ub2RlXFxcIiBvciBcXFwibW92ZV9ub2RlXFxcIlxcbiAgICAgICAgICovXFxuICAgICAgICB0aGlzLnRyaWdnZXIoJ3Bhc3RlJywge1xcbiAgICAgICAgICBcXFwicGFyZW50XFxcIjogb2JqLmlkLFxcbiAgICAgICAgICBcXFwibm9kZVxcXCI6IGNjcF9ub2RlLFxcbiAgICAgICAgICBcXFwibW9kZVxcXCI6IGNjcF9tb2RlXFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuXFxuICAgICAgY2NwX25vZGUgPSBmYWxzZTtcXG4gICAgICBjY3BfbW9kZSA9IGZhbHNlO1xcbiAgICAgIGNjcF9pbnN0ID0gZmFsc2U7XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBjbGVhciB0aGUgYnVmZmVyIG9mIHByZXZpb3VzbHkgY29waWVkIG9yIGN1dCBub2Rlc1xcbiAgICAgKiBAbmFtZSBjbGVhcl9idWZmZXIoKVxcbiAgICAgKiBAdHJpZ2dlciBjbGVhcl9idWZmZXIuanN0cmVlXFxuICAgICAqL1xcbiAgICBjbGVhcl9idWZmZXI6IGZ1bmN0aW9uIGNsZWFyX2J1ZmZlcigpIHtcXG4gICAgICBjY3Bfbm9kZSA9IGZhbHNlO1xcbiAgICAgIGNjcF9tb2RlID0gZmFsc2U7XFxuICAgICAgY2NwX2luc3QgPSBmYWxzZTtcXG4gICAgICAvKipcXG4gICAgICAgKiB0cmlnZ2VyZWQgd2hlbiB0aGUgY29weSAvIGN1dCBidWZmZXIgaXMgY2xlYXJlZFxcbiAgICAgICAqIEBldmVudFxcbiAgICAgICAqIEBuYW1lIGNsZWFyX2J1ZmZlci5qc3RyZWVcXG4gICAgICAgKi9cXG5cXG4gICAgICB0aGlzLnRyaWdnZXIoJ2NsZWFyX2J1ZmZlcicpO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogcHV0IGEgbm9kZSBpbiBlZGl0IG1vZGUgKGlucHV0IGZpZWxkIHRvIHJlbmFtZSB0aGUgbm9kZSlcXG4gICAgICogQG5hbWUgZWRpdChvYmogWywgZGVmYXVsdF90ZXh0LCBjYWxsYmFja10pXFxuICAgICAqIEBwYXJhbSAge21peGVkfSBvYmpcXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBkZWZhdWx0X3RleHQgdGhlIHRleHQgdG8gcG9wdWxhdGUgdGhlIGlucHV0IHdpdGggKGlmIG9taXR0ZWQgb3Igc2V0IHRvIGEgbm9uLXN0cmluZyB2YWx1ZSB0aGUgbm9kZSdzIHRleHQgdmFsdWUgaXMgdXNlZClcXG4gICAgICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrIGEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uY2UgdGhlIHRleHQgYm94IGlzIGJsdXJyZWQsIGl0IGlzIGNhbGxlZCBpbiB0aGUgaW5zdGFuY2UncyBzY29wZSBhbmQgcmVjZWl2ZXMgdGhlIG5vZGUsIGEgc3RhdHVzIHBhcmFtZXRlciAodHJ1ZSBpZiB0aGUgcmVuYW1lIGlzIHN1Y2Nlc3NmdWwsIGZhbHNlIG90aGVyd2lzZSkgYW5kIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoZSB1c2VyIGNhbmNlbGxlZCB0aGUgZWRpdC4gWW91IGNhbiBhY2Nlc3MgdGhlIG5vZGUncyB0aXRsZSB1c2luZyAudGV4dFxcbiAgICAgKi9cXG4gICAgZWRpdDogZnVuY3Rpb24gZWRpdChvYmosIGRlZmF1bHRfdGV4dCwgY2FsbGJhY2spIHtcXG4gICAgICB2YXIgcnRsLFxcbiAgICAgICAgICB3LFxcbiAgICAgICAgICBhLFxcbiAgICAgICAgICBzLFxcbiAgICAgICAgICB0LFxcbiAgICAgICAgICBoMSxcXG4gICAgICAgICAgaDIsXFxuICAgICAgICAgIGZuLFxcbiAgICAgICAgICB0bXAsXFxuICAgICAgICAgIGNhbmNlbCA9IGZhbHNlO1xcbiAgICAgIG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXG4gICAgICBpZiAoIW9iaikge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5jb3JlLmNoZWNrX2NhbGxiYWNrID09PSBmYWxzZSkge1xcbiAgICAgICAgdGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IgPSB7XFxuICAgICAgICAgICdlcnJvcic6ICdjaGVjaycsXFxuICAgICAgICAgICdwbHVnaW4nOiAnY29yZScsXFxuICAgICAgICAgICdpZCc6ICdjb3JlXzA3JyxcXG4gICAgICAgICAgJ3JlYXNvbic6ICdDb3VsZCBub3QgZWRpdCBub2RlIGJlY2F1c2Ugb2YgY2hlY2tfY2FsbGJhY2snXFxuICAgICAgICB9O1xcbiAgICAgICAgdGhpcy5zZXR0aW5ncy5jb3JlLmVycm9yLmNhbGwodGhpcywgdGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IpO1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICB0bXAgPSBvYmo7XFxuICAgICAgZGVmYXVsdF90ZXh0ID0gdHlwZW9mIGRlZmF1bHRfdGV4dCA9PT0gJ3N0cmluZycgPyBkZWZhdWx0X3RleHQgOiBvYmoudGV4dDtcXG4gICAgICB0aGlzLnNldF90ZXh0KG9iaiwgXFxcIlxcXCIpO1xcbiAgICAgIG9iaiA9IHRoaXMuX29wZW5fdG8ob2JqKTtcXG4gICAgICB0bXAudGV4dCA9IGRlZmF1bHRfdGV4dDtcXG4gICAgICBydGwgPSB0aGlzLl9kYXRhLmNvcmUucnRsO1xcbiAgICAgIHcgPSB0aGlzLmVsZW1lbnQud2lkdGgoKTtcXG4gICAgICB0aGlzLl9kYXRhLmNvcmUuZm9jdXNlZCA9IHRtcC5pZDtcXG4gICAgICBhID0gb2JqLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLmZvY3VzKCk7XFxuICAgICAgcyA9ICQoJzxzcGFuPicpO1xcbiAgICAgIC8qIVxcbiAgICAgIG9pID0gb2JqLmNoaWxkcmVuKFxcXCJpOnZpc2libGVcXFwiKSxcXG4gICAgICBhaSA9IGEuY2hpbGRyZW4oXFxcImk6dmlzaWJsZVxcXCIpLFxcbiAgICAgIHcxID0gb2kud2lkdGgoKSAqIG9pLmxlbmd0aCxcXG4gICAgICB3MiA9IGFpLndpZHRoKCkgKiBhaS5sZW5ndGgsXFxuICAgICAgKi9cXG5cXG4gICAgICB0ID0gZGVmYXVsdF90ZXh0O1xcbiAgICAgIGgxID0gJChcXFwiPFxcXCIgKyBcXFwiZGl2IC8+XFxcIiwge1xcbiAgICAgICAgY3NzOiB7XFxuICAgICAgICAgIFxcXCJwb3NpdGlvblxcXCI6IFxcXCJhYnNvbHV0ZVxcXCIsXFxuICAgICAgICAgIFxcXCJ0b3BcXFwiOiBcXFwiLTIwMHB4XFxcIixcXG4gICAgICAgICAgXFxcImxlZnRcXFwiOiBydGwgPyBcXFwiMHB4XFxcIiA6IFxcXCItMTAwMHB4XFxcIixcXG4gICAgICAgICAgXFxcInZpc2liaWxpdHlcXFwiOiBcXFwiaGlkZGVuXFxcIlxcbiAgICAgICAgfVxcbiAgICAgIH0pLmFwcGVuZFRvKFxcXCJib2R5XFxcIik7XFxuICAgICAgaDIgPSAkKFxcXCI8XFxcIiArIFxcXCJpbnB1dCAvPlxcXCIsIHtcXG4gICAgICAgIFxcXCJ2YWx1ZVxcXCI6IHQsXFxuICAgICAgICBcXFwiY2xhc3NcXFwiOiBcXFwianN0cmVlLXJlbmFtZS1pbnB1dFxcXCIsXFxuICAgICAgICAvLyBcXFwic2l6ZVxcXCIgOiB0Lmxlbmd0aCxcXG4gICAgICAgIFxcXCJjc3NcXFwiOiB7XFxuICAgICAgICAgIFxcXCJwYWRkaW5nXFxcIjogXFxcIjBcXFwiLFxcbiAgICAgICAgICBcXFwiYm9yZGVyXFxcIjogXFxcIjFweCBzb2xpZCBzaWx2ZXJcXFwiLFxcbiAgICAgICAgICBcXFwiYm94LXNpemluZ1xcXCI6IFxcXCJib3JkZXItYm94XFxcIixcXG4gICAgICAgICAgXFxcImRpc3BsYXlcXFwiOiBcXFwiaW5saW5lLWJsb2NrXFxcIixcXG4gICAgICAgICAgXFxcImhlaWdodFxcXCI6IHRoaXMuX2RhdGEuY29yZS5saV9oZWlnaHQgKyBcXFwicHhcXFwiLFxcbiAgICAgICAgICBcXFwibGluZUhlaWdodFxcXCI6IHRoaXMuX2RhdGEuY29yZS5saV9oZWlnaHQgKyBcXFwicHhcXFwiLFxcbiAgICAgICAgICBcXFwid2lkdGhcXFwiOiBcXFwiMTUwcHhcXFwiIC8vIHdpbGwgYmUgc2V0IGEgYml0IGZ1cnRoZXIgZG93blxcblxcbiAgICAgICAgfSxcXG4gICAgICAgIFxcXCJibHVyXFxcIjogJC5wcm94eShmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICAgIHZhciBpID0gcy5jaGlsZHJlbihcXFwiLmpzdHJlZS1yZW5hbWUtaW5wdXRcXFwiKSxcXG4gICAgICAgICAgICAgIHYgPSBpLnZhbCgpLFxcbiAgICAgICAgICAgICAgZiA9IHRoaXMuc2V0dGluZ3MuY29yZS5mb3JjZV90ZXh0LFxcbiAgICAgICAgICAgICAgbnY7XFxuXFxuICAgICAgICAgIGlmICh2ID09PSBcXFwiXFxcIikge1xcbiAgICAgICAgICAgIHYgPSB0O1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGgxLnJlbW92ZSgpO1xcbiAgICAgICAgICBzLnJlcGxhY2VXaXRoKGEpO1xcbiAgICAgICAgICBzLnJlbW92ZSgpO1xcbiAgICAgICAgICB0ID0gZiA/IHQgOiAkKCc8ZGl2PjwvZGl2PicpLmFwcGVuZCgkLnBhcnNlSFRNTCh0KSkuaHRtbCgpO1xcbiAgICAgICAgICB0aGlzLnNldF90ZXh0KG9iaiwgdCk7XFxuICAgICAgICAgIG52ID0gISF0aGlzLnJlbmFtZV9ub2RlKG9iaiwgZiA/ICQoJzxkaXY+PC9kaXY+JykudGV4dCh2KS50ZXh0KCkgOiAkKCc8ZGl2PjwvZGl2PicpLmFwcGVuZCgkLnBhcnNlSFRNTCh2KSkuaHRtbCgpKTtcXG5cXG4gICAgICAgICAgaWYgKCFudikge1xcbiAgICAgICAgICAgIHRoaXMuc2V0X3RleHQob2JqLCB0KTsgLy8gbW92ZSB0aGlzIHVwPyBhbmQgZml4ICM0ODNcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICB0aGlzLl9kYXRhLmNvcmUuZm9jdXNlZCA9IHRtcC5pZDtcXG4gICAgICAgICAgc2V0VGltZW91dCgkLnByb3h5KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuZ2V0X25vZGUodG1wLmlkLCB0cnVlKTtcXG5cXG4gICAgICAgICAgICBpZiAobm9kZS5sZW5ndGgpIHtcXG4gICAgICAgICAgICAgIHRoaXMuX2RhdGEuY29yZS5mb2N1c2VkID0gdG1wLmlkO1xcbiAgICAgICAgICAgICAgbm9kZS5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5mb2N1cygpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSwgdGhpcyksIDApO1xcblxcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcXG4gICAgICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXMsIHRtcCwgbnYsIGNhbmNlbCk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaDIgPSBudWxsO1xcbiAgICAgICAgfSwgdGhpcyksXFxuICAgICAgICBcXFwia2V5ZG93blxcXCI6IGZ1bmN0aW9uIGtleWRvd24oZSkge1xcbiAgICAgICAgICB2YXIga2V5ID0gZS53aGljaDtcXG5cXG4gICAgICAgICAgaWYgKGtleSA9PT0gMjcpIHtcXG4gICAgICAgICAgICBjYW5jZWwgPSB0cnVlO1xcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0O1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmIChrZXkgPT09IDI3IHx8IGtleSA9PT0gMTMgfHwga2V5ID09PSAzNyB8fCBrZXkgPT09IDM4IHx8IGtleSA9PT0gMzkgfHwga2V5ID09PSA0MCB8fCBrZXkgPT09IDMyKSB7XFxuICAgICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAoa2V5ID09PSAyNyB8fCBrZXkgPT09IDEzKSB7XFxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgICAgIHRoaXMuYmx1cigpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgXFxcImNsaWNrXFxcIjogZnVuY3Rpb24gY2xpY2soZSkge1xcbiAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xcbiAgICAgICAgfSxcXG4gICAgICAgIFxcXCJtb3VzZWRvd25cXFwiOiBmdW5jdGlvbiBtb3VzZWRvd24oZSkge1xcbiAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xcbiAgICAgICAgfSxcXG4gICAgICAgIFxcXCJrZXl1cFxcXCI6IGZ1bmN0aW9uIGtleXVwKGUpIHtcXG4gICAgICAgICAgaDIud2lkdGgoTWF0aC5taW4oaDEudGV4dChcXFwicFdcXFwiICsgdGhpcy52YWx1ZSkud2lkdGgoKSwgdykpO1xcbiAgICAgICAgfSxcXG4gICAgICAgIFxcXCJrZXlwcmVzc1xcXCI6IGZ1bmN0aW9uIGtleXByZXNzKGUpIHtcXG4gICAgICAgICAgaWYgKGUud2hpY2ggPT09IDEzKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgICAgZm4gPSB7XFxuICAgICAgICBmb250RmFtaWx5OiBhLmNzcygnZm9udEZhbWlseScpIHx8ICcnLFxcbiAgICAgICAgZm9udFNpemU6IGEuY3NzKCdmb250U2l6ZScpIHx8ICcnLFxcbiAgICAgICAgZm9udFdlaWdodDogYS5jc3MoJ2ZvbnRXZWlnaHQnKSB8fCAnJyxcXG4gICAgICAgIGZvbnRTdHlsZTogYS5jc3MoJ2ZvbnRTdHlsZScpIHx8ICcnLFxcbiAgICAgICAgZm9udFN0cmV0Y2g6IGEuY3NzKCdmb250U3RyZXRjaCcpIHx8ICcnLFxcbiAgICAgICAgZm9udFZhcmlhbnQ6IGEuY3NzKCdmb250VmFyaWFudCcpIHx8ICcnLFxcbiAgICAgICAgbGV0dGVyU3BhY2luZzogYS5jc3MoJ2xldHRlclNwYWNpbmcnKSB8fCAnJyxcXG4gICAgICAgIHdvcmRTcGFjaW5nOiBhLmNzcygnd29yZFNwYWNpbmcnKSB8fCAnJ1xcbiAgICAgIH07XFxuICAgICAgcy5hdHRyKCdjbGFzcycsIGEuYXR0cignY2xhc3MnKSkuYXBwZW5kKGEuY29udGVudHMoKS5jbG9uZSgpKS5hcHBlbmQoaDIpO1xcbiAgICAgIGEucmVwbGFjZVdpdGgocyk7XFxuICAgICAgaDEuY3NzKGZuKTtcXG4gICAgICBoMi5jc3MoZm4pLndpZHRoKE1hdGgubWluKGgxLnRleHQoXFxcInBXXFxcIiArIGgyWzBdLnZhbHVlKS53aWR0aCgpLCB3KSlbMF0uc2VsZWN0KCk7XFxuICAgICAgJChkb2N1bWVudCkub25lKCdtb3VzZWRvd24uanN0cmVlIHRvdWNoc3RhcnQuanN0cmVlIGRuZF9zdGFydC52YWthdGEnLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgaWYgKGgyICYmIGUudGFyZ2V0ICE9PSBoMikge1xcbiAgICAgICAgICAkKGgyKS5ibHVyKCk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBjaGFuZ2VzIHRoZSB0aGVtZVxcbiAgICAgKiBAbmFtZSBzZXRfdGhlbWUodGhlbWVfbmFtZSBbLCB0aGVtZV91cmxdKVxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGhlbWVfbmFtZSB0aGUgbmFtZSBvZiB0aGUgbmV3IHRoZW1lIHRvIGFwcGx5XFxuICAgICAqIEBwYXJhbSB7bWl4ZWR9IHRoZW1lX3VybCAgdGhlIGxvY2F0aW9uIG9mIHRoZSBDU1MgZmlsZSBmb3IgdGhpcyB0aGVtZS4gT21pdCBvciBzZXQgdG8gYGZhbHNlYCBpZiB5b3UgbWFudWFsbHkgaW5jbHVkZWQgdGhlIGZpbGUuIFNldCB0byBgdHJ1ZWAgdG8gYXV0b2xvYWQgZnJvbSB0aGUgYGNvcmUudGhlbWVzLmRpcmAgZGlyZWN0b3J5LlxcbiAgICAgKiBAdHJpZ2dlciBzZXRfdGhlbWUuanN0cmVlXFxuICAgICAqL1xcbiAgICBzZXRfdGhlbWU6IGZ1bmN0aW9uIHNldF90aGVtZSh0aGVtZV9uYW1lLCB0aGVtZV91cmwpIHtcXG4gICAgICBpZiAoIXRoZW1lX25hbWUpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoZW1lX3VybCA9PT0gdHJ1ZSkge1xcbiAgICAgICAgdmFyIGRpciA9IHRoaXMuc2V0dGluZ3MuY29yZS50aGVtZXMuZGlyO1xcblxcbiAgICAgICAgaWYgKCFkaXIpIHtcXG4gICAgICAgICAgZGlyID0gJC5qc3RyZWUucGF0aCArICcvdGhlbWVzJztcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHRoZW1lX3VybCA9IGRpciArICcvJyArIHRoZW1lX25hbWUgKyAnL3N0eWxlLmNzcyc7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGVtZV91cmwgJiYgJC5pbkFycmF5KHRoZW1lX3VybCwgdGhlbWVzX2xvYWRlZCkgPT09IC0xKSB7XFxuICAgICAgICAkKCdoZWFkJykuYXBwZW5kKCc8JyArICdsaW5rIHJlbD1cXFwic3R5bGVzaGVldFxcXCIgaHJlZj1cXFwiJyArIHRoZW1lX3VybCArICdcXFwiIHR5cGU9XFxcInRleHQvY3NzXFxcIiAvPicpO1xcbiAgICAgICAgdGhlbWVzX2xvYWRlZC5wdXNoKHRoZW1lX3VybCk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLl9kYXRhLmNvcmUudGhlbWVzLm5hbWUpIHtcXG4gICAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVDbGFzcygnanN0cmVlLScgKyB0aGlzLl9kYXRhLmNvcmUudGhlbWVzLm5hbWUpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9kYXRhLmNvcmUudGhlbWVzLm5hbWUgPSB0aGVtZV9uYW1lO1xcbiAgICAgIHRoaXMuZWxlbWVudC5hZGRDbGFzcygnanN0cmVlLScgKyB0aGVtZV9uYW1lKTtcXG4gICAgICB0aGlzLmVsZW1lbnRbdGhpcy5zZXR0aW5ncy5jb3JlLnRoZW1lcy5yZXNwb25zaXZlID8gJ2FkZENsYXNzJyA6ICdyZW1vdmVDbGFzcyddKCdqc3RyZWUtJyArIHRoZW1lX25hbWUgKyAnLXJlc3BvbnNpdmUnKTtcXG4gICAgICAvKipcXG4gICAgICAgKiB0cmlnZ2VyZWQgd2hlbiBhIHRoZW1lIGlzIHNldFxcbiAgICAgICAqIEBldmVudFxcbiAgICAgICAqIEBuYW1lIHNldF90aGVtZS5qc3RyZWVcXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGhlbWUgdGhlIG5ldyB0aGVtZVxcbiAgICAgICAqL1xcblxcbiAgICAgIHRoaXMudHJpZ2dlcignc2V0X3RoZW1lJywge1xcbiAgICAgICAgJ3RoZW1lJzogdGhlbWVfbmFtZVxcbiAgICAgIH0pO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogZ2V0cyB0aGUgbmFtZSBvZiB0aGUgY3VycmVudGx5IGFwcGxpZWQgdGhlbWUgbmFtZVxcbiAgICAgKiBAbmFtZSBnZXRfdGhlbWUoKVxcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XFxuICAgICAqL1xcbiAgICBnZXRfdGhlbWU6IGZ1bmN0aW9uIGdldF90aGVtZSgpIHtcXG4gICAgICByZXR1cm4gdGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5uYW1lO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogY2hhbmdlcyB0aGUgdGhlbWUgdmFyaWFudCAoaWYgdGhlIHRoZW1lIGhhcyB2YXJpYW50cylcXG4gICAgICogQG5hbWUgc2V0X3RoZW1lX3ZhcmlhbnQodmFyaWFudF9uYW1lKVxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xCb29sZWFufSB2YXJpYW50X25hbWUgdGhlIHZhcmlhbnQgdG8gYXBwbHkgKGlmIGBmYWxzZWAgaXMgdXNlZCB0aGUgY3VycmVudCB2YXJpYW50IGlzIHJlbW92ZWQpXFxuICAgICAqL1xcbiAgICBzZXRfdGhlbWVfdmFyaWFudDogZnVuY3Rpb24gc2V0X3RoZW1lX3ZhcmlhbnQodmFyaWFudF9uYW1lKSB7XFxuICAgICAgaWYgKHRoaXMuX2RhdGEuY29yZS50aGVtZXMudmFyaWFudCkge1xcbiAgICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZUNsYXNzKCdqc3RyZWUtJyArIHRoaXMuX2RhdGEuY29yZS50aGVtZXMubmFtZSArICctJyArIHRoaXMuX2RhdGEuY29yZS50aGVtZXMudmFyaWFudCk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX2RhdGEuY29yZS50aGVtZXMudmFyaWFudCA9IHZhcmlhbnRfbmFtZTtcXG5cXG4gICAgICBpZiAodmFyaWFudF9uYW1lKSB7XFxuICAgICAgICB0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoJ2pzdHJlZS0nICsgdGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5uYW1lICsgJy0nICsgdGhpcy5fZGF0YS5jb3JlLnRoZW1lcy52YXJpYW50KTtcXG4gICAgICB9XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBnZXRzIHRoZSBuYW1lIG9mIHRoZSBjdXJyZW50bHkgYXBwbGllZCB0aGVtZSB2YXJpYW50XFxuICAgICAqIEBuYW1lIGdldF90aGVtZSgpXFxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cXG4gICAgICovXFxuICAgIGdldF90aGVtZV92YXJpYW50OiBmdW5jdGlvbiBnZXRfdGhlbWVfdmFyaWFudCgpIHtcXG4gICAgICByZXR1cm4gdGhpcy5fZGF0YS5jb3JlLnRoZW1lcy52YXJpYW50O1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogc2hvd3MgYSBzdHJpcGVkIGJhY2tncm91bmQgb24gdGhlIGNvbnRhaW5lciAoaWYgdGhlIHRoZW1lIHN1cHBvcnRzIGl0KVxcbiAgICAgKiBAbmFtZSBzaG93X3N0cmlwZXMoKVxcbiAgICAgKi9cXG4gICAgc2hvd19zdHJpcGVzOiBmdW5jdGlvbiBzaG93X3N0cmlwZXMoKSB7XFxuICAgICAgdGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5zdHJpcGVzID0gdHJ1ZTtcXG4gICAgICB0aGlzLmdldF9jb250YWluZXJfdWwoKS5hZGRDbGFzcyhcXFwianN0cmVlLXN0cmlwZWRcXFwiKTtcXG4gICAgICAvKipcXG4gICAgICAgKiB0cmlnZ2VyZWQgd2hlbiBzdHJpcGVzIGFyZSBzaG93blxcbiAgICAgICAqIEBldmVudFxcbiAgICAgICAqIEBuYW1lIHNob3dfc3RyaXBlcy5qc3RyZWVcXG4gICAgICAgKi9cXG5cXG4gICAgICB0aGlzLnRyaWdnZXIoJ3Nob3dfc3RyaXBlcycpO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogaGlkZXMgdGhlIHN0cmlwZWQgYmFja2dyb3VuZCBvbiB0aGUgY29udGFpbmVyXFxuICAgICAqIEBuYW1lIGhpZGVfc3RyaXBlcygpXFxuICAgICAqL1xcbiAgICBoaWRlX3N0cmlwZXM6IGZ1bmN0aW9uIGhpZGVfc3RyaXBlcygpIHtcXG4gICAgICB0aGlzLl9kYXRhLmNvcmUudGhlbWVzLnN0cmlwZXMgPSBmYWxzZTtcXG4gICAgICB0aGlzLmdldF9jb250YWluZXJfdWwoKS5yZW1vdmVDbGFzcyhcXFwianN0cmVlLXN0cmlwZWRcXFwiKTtcXG4gICAgICAvKipcXG4gICAgICAgKiB0cmlnZ2VyZWQgd2hlbiBzdHJpcGVzIGFyZSBoaWRkZW5cXG4gICAgICAgKiBAZXZlbnRcXG4gICAgICAgKiBAbmFtZSBoaWRlX3N0cmlwZXMuanN0cmVlXFxuICAgICAgICovXFxuXFxuICAgICAgdGhpcy50cmlnZ2VyKCdoaWRlX3N0cmlwZXMnKTtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIHRvZ2dsZXMgdGhlIHN0cmlwZWQgYmFja2dyb3VuZCBvbiB0aGUgY29udGFpbmVyXFxuICAgICAqIEBuYW1lIHRvZ2dsZV9zdHJpcGVzKClcXG4gICAgICovXFxuICAgIHRvZ2dsZV9zdHJpcGVzOiBmdW5jdGlvbiB0b2dnbGVfc3RyaXBlcygpIHtcXG4gICAgICBpZiAodGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5zdHJpcGVzKSB7XFxuICAgICAgICB0aGlzLmhpZGVfc3RyaXBlcygpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB0aGlzLnNob3dfc3RyaXBlcygpO1xcbiAgICAgIH1cXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIHNob3dzIHRoZSBjb25uZWN0aW5nIGRvdHMgKGlmIHRoZSB0aGVtZSBzdXBwb3J0cyBpdClcXG4gICAgICogQG5hbWUgc2hvd19kb3RzKClcXG4gICAgICovXFxuICAgIHNob3dfZG90czogZnVuY3Rpb24gc2hvd19kb3RzKCkge1xcbiAgICAgIHRoaXMuX2RhdGEuY29yZS50aGVtZXMuZG90cyA9IHRydWU7XFxuICAgICAgdGhpcy5nZXRfY29udGFpbmVyX3VsKCkucmVtb3ZlQ2xhc3MoXFxcImpzdHJlZS1uby1kb3RzXFxcIik7XFxuICAgICAgLyoqXFxuICAgICAgICogdHJpZ2dlcmVkIHdoZW4gZG90cyBhcmUgc2hvd25cXG4gICAgICAgKiBAZXZlbnRcXG4gICAgICAgKiBAbmFtZSBzaG93X2RvdHMuanN0cmVlXFxuICAgICAgICovXFxuXFxuICAgICAgdGhpcy50cmlnZ2VyKCdzaG93X2RvdHMnKTtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIGhpZGVzIHRoZSBjb25uZWN0aW5nIGRvdHNcXG4gICAgICogQG5hbWUgaGlkZV9kb3RzKClcXG4gICAgICovXFxuICAgIGhpZGVfZG90czogZnVuY3Rpb24gaGlkZV9kb3RzKCkge1xcbiAgICAgIHRoaXMuX2RhdGEuY29yZS50aGVtZXMuZG90cyA9IGZhbHNlO1xcbiAgICAgIHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpLmFkZENsYXNzKFxcXCJqc3RyZWUtbm8tZG90c1xcXCIpO1xcbiAgICAgIC8qKlxcbiAgICAgICAqIHRyaWdnZXJlZCB3aGVuIGRvdHMgYXJlIGhpZGRlblxcbiAgICAgICAqIEBldmVudFxcbiAgICAgICAqIEBuYW1lIGhpZGVfZG90cy5qc3RyZWVcXG4gICAgICAgKi9cXG5cXG4gICAgICB0aGlzLnRyaWdnZXIoJ2hpZGVfZG90cycpO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogdG9nZ2xlcyB0aGUgY29ubmVjdGluZyBkb3RzXFxuICAgICAqIEBuYW1lIHRvZ2dsZV9kb3RzKClcXG4gICAgICovXFxuICAgIHRvZ2dsZV9kb3RzOiBmdW5jdGlvbiB0b2dnbGVfZG90cygpIHtcXG4gICAgICBpZiAodGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5kb3RzKSB7XFxuICAgICAgICB0aGlzLmhpZGVfZG90cygpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB0aGlzLnNob3dfZG90cygpO1xcbiAgICAgIH1cXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIHNob3cgdGhlIG5vZGUgaWNvbnNcXG4gICAgICogQG5hbWUgc2hvd19pY29ucygpXFxuICAgICAqL1xcbiAgICBzaG93X2ljb25zOiBmdW5jdGlvbiBzaG93X2ljb25zKCkge1xcbiAgICAgIHRoaXMuX2RhdGEuY29yZS50aGVtZXMuaWNvbnMgPSB0cnVlO1xcbiAgICAgIHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpLnJlbW92ZUNsYXNzKFxcXCJqc3RyZWUtbm8taWNvbnNcXFwiKTtcXG4gICAgICAvKipcXG4gICAgICAgKiB0cmlnZ2VyZWQgd2hlbiBpY29ucyBhcmUgc2hvd25cXG4gICAgICAgKiBAZXZlbnRcXG4gICAgICAgKiBAbmFtZSBzaG93X2ljb25zLmpzdHJlZVxcbiAgICAgICAqL1xcblxcbiAgICAgIHRoaXMudHJpZ2dlcignc2hvd19pY29ucycpO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogaGlkZSB0aGUgbm9kZSBpY29uc1xcbiAgICAgKiBAbmFtZSBoaWRlX2ljb25zKClcXG4gICAgICovXFxuICAgIGhpZGVfaWNvbnM6IGZ1bmN0aW9uIGhpZGVfaWNvbnMoKSB7XFxuICAgICAgdGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5pY29ucyA9IGZhbHNlO1xcbiAgICAgIHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpLmFkZENsYXNzKFxcXCJqc3RyZWUtbm8taWNvbnNcXFwiKTtcXG4gICAgICAvKipcXG4gICAgICAgKiB0cmlnZ2VyZWQgd2hlbiBpY29ucyBhcmUgaGlkZGVuXFxuICAgICAgICogQGV2ZW50XFxuICAgICAgICogQG5hbWUgaGlkZV9pY29ucy5qc3RyZWVcXG4gICAgICAgKi9cXG5cXG4gICAgICB0aGlzLnRyaWdnZXIoJ2hpZGVfaWNvbnMnKTtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIHRvZ2dsZSB0aGUgbm9kZSBpY29uc1xcbiAgICAgKiBAbmFtZSB0b2dnbGVfaWNvbnMoKVxcbiAgICAgKi9cXG4gICAgdG9nZ2xlX2ljb25zOiBmdW5jdGlvbiB0b2dnbGVfaWNvbnMoKSB7XFxuICAgICAgaWYgKHRoaXMuX2RhdGEuY29yZS50aGVtZXMuaWNvbnMpIHtcXG4gICAgICAgIHRoaXMuaGlkZV9pY29ucygpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB0aGlzLnNob3dfaWNvbnMoKTtcXG4gICAgICB9XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBzaG93IHRoZSBub2RlIGVsbGlwc2lzXFxuICAgICAqIEBuYW1lIHNob3dfaWNvbnMoKVxcbiAgICAgKi9cXG4gICAgc2hvd19lbGxpcHNpczogZnVuY3Rpb24gc2hvd19lbGxpcHNpcygpIHtcXG4gICAgICB0aGlzLl9kYXRhLmNvcmUudGhlbWVzLmVsbGlwc2lzID0gdHJ1ZTtcXG4gICAgICB0aGlzLmdldF9jb250YWluZXJfdWwoKS5hZGRDbGFzcyhcXFwianN0cmVlLWVsbGlwc2lzXFxcIik7XFxuICAgICAgLyoqXFxuICAgICAgICogdHJpZ2dlcmVkIHdoZW4gZWxsaXNpcyBpcyBzaG93blxcbiAgICAgICAqIEBldmVudFxcbiAgICAgICAqIEBuYW1lIHNob3dfZWxsaXBzaXMuanN0cmVlXFxuICAgICAgICovXFxuXFxuICAgICAgdGhpcy50cmlnZ2VyKCdzaG93X2VsbGlwc2lzJyk7XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBoaWRlIHRoZSBub2RlIGVsbGlwc2lzXFxuICAgICAqIEBuYW1lIGhpZGVfZWxsaXBzaXMoKVxcbiAgICAgKi9cXG4gICAgaGlkZV9lbGxpcHNpczogZnVuY3Rpb24gaGlkZV9lbGxpcHNpcygpIHtcXG4gICAgICB0aGlzLl9kYXRhLmNvcmUudGhlbWVzLmVsbGlwc2lzID0gZmFsc2U7XFxuICAgICAgdGhpcy5nZXRfY29udGFpbmVyX3VsKCkucmVtb3ZlQ2xhc3MoXFxcImpzdHJlZS1lbGxpcHNpc1xcXCIpO1xcbiAgICAgIC8qKlxcbiAgICAgICAqIHRyaWdnZXJlZCB3aGVuIGVsbGlzaXMgaXMgaGlkZGVuXFxuICAgICAgICogQGV2ZW50XFxuICAgICAgICogQG5hbWUgaGlkZV9lbGxpcHNpcy5qc3RyZWVcXG4gICAgICAgKi9cXG5cXG4gICAgICB0aGlzLnRyaWdnZXIoJ2hpZGVfZWxsaXBzaXMnKTtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIHRvZ2dsZSB0aGUgbm9kZSBlbGxpcHNpc1xcbiAgICAgKiBAbmFtZSB0b2dnbGVfaWNvbnMoKVxcbiAgICAgKi9cXG4gICAgdG9nZ2xlX2VsbGlwc2lzOiBmdW5jdGlvbiB0b2dnbGVfZWxsaXBzaXMoKSB7XFxuICAgICAgaWYgKHRoaXMuX2RhdGEuY29yZS50aGVtZXMuZWxsaXBzaXMpIHtcXG4gICAgICAgIHRoaXMuaGlkZV9lbGxpcHNpcygpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB0aGlzLnNob3dfZWxsaXBzaXMoKTtcXG4gICAgICB9XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBzZXQgdGhlIG5vZGUgaWNvbiBmb3IgYSBub2RlXFxuICAgICAqIEBuYW1lIHNldF9pY29uKG9iaiwgaWNvbilcXG4gICAgICogQHBhcmFtIHttaXhlZH0gb2JqXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpY29uIHRoZSBuZXcgaWNvbiAtIGNhbiBiZSBhIHBhdGggdG8gYW4gaWNvbiBvciBhIGNsYXNzTmFtZSwgaWYgdXNpbmcgYW4gaW1hZ2UgdGhhdCBpcyBpbiB0aGUgY3VycmVudCBkaXJlY3RvcnkgdXNlIGEgYC4vYCBwcmVmaXgsIG90aGVyd2lzZSBpdCB3aWxsIGJlIGRldGVjdGVkIGFzIGEgY2xhc3NcXG4gICAgICovXFxuICAgIHNldF9pY29uOiBmdW5jdGlvbiBzZXRfaWNvbihvYmosIGljb24pIHtcXG4gICAgICB2YXIgdDEsIHQyLCBkb20sIG9sZDtcXG5cXG4gICAgICBpZiAoJC5pc0FycmF5KG9iaikpIHtcXG4gICAgICAgIG9iaiA9IG9iai5zbGljZSgpO1xcblxcbiAgICAgICAgZm9yICh0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xcbiAgICAgICAgICB0aGlzLnNldF9pY29uKG9ialt0MV0sIGljb24pO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgfVxcblxcbiAgICAgIG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXG4gICAgICBpZiAoIW9iaiB8fCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgb2xkID0gb2JqLmljb247XFxuICAgICAgb2JqLmljb24gPSBpY29uID09PSB0cnVlIHx8IGljb24gPT09IG51bGwgfHwgaWNvbiA9PT0gdW5kZWZpbmVkIHx8IGljb24gPT09ICcnID8gdHJ1ZSA6IGljb247XFxuICAgICAgZG9tID0gdGhpcy5nZXRfbm9kZShvYmosIHRydWUpLmNoaWxkcmVuKFxcXCIuanN0cmVlLWFuY2hvclxcXCIpLmNoaWxkcmVuKFxcXCIuanN0cmVlLXRoZW1laWNvblxcXCIpO1xcblxcbiAgICAgIGlmIChpY29uID09PSBmYWxzZSkge1xcbiAgICAgICAgdGhpcy5oaWRlX2ljb24ob2JqKTtcXG4gICAgICB9IGVsc2UgaWYgKGljb24gPT09IHRydWUgfHwgaWNvbiA9PT0gbnVsbCB8fCBpY29uID09PSB1bmRlZmluZWQgfHwgaWNvbiA9PT0gJycpIHtcXG4gICAgICAgIGRvbS5yZW1vdmVDbGFzcygnanN0cmVlLXRoZW1laWNvbi1jdXN0b20gJyArIG9sZCkuY3NzKFxcXCJiYWNrZ3JvdW5kXFxcIiwgXFxcIlxcXCIpLnJlbW92ZUF0dHIoXFxcInJlbFxcXCIpO1xcblxcbiAgICAgICAgaWYgKG9sZCA9PT0gZmFsc2UpIHtcXG4gICAgICAgICAgdGhpcy5zaG93X2ljb24ob2JqKTtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2UgaWYgKGljb24uaW5kZXhPZihcXFwiL1xcXCIpID09PSAtMSAmJiBpY29uLmluZGV4T2YoXFxcIi5cXFwiKSA9PT0gLTEpIHtcXG4gICAgICAgIGRvbS5yZW1vdmVDbGFzcyhvbGQpLmNzcyhcXFwiYmFja2dyb3VuZFxcXCIsIFxcXCJcXFwiKTtcXG4gICAgICAgIGRvbS5hZGRDbGFzcyhpY29uICsgJyBqc3RyZWUtdGhlbWVpY29uLWN1c3RvbScpLmF0dHIoXFxcInJlbFxcXCIsIGljb24pO1xcblxcbiAgICAgICAgaWYgKG9sZCA9PT0gZmFsc2UpIHtcXG4gICAgICAgICAgdGhpcy5zaG93X2ljb24ob2JqKTtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgZG9tLnJlbW92ZUNsYXNzKG9sZCkuY3NzKFxcXCJiYWNrZ3JvdW5kXFxcIiwgXFxcIlxcXCIpO1xcbiAgICAgICAgZG9tLmFkZENsYXNzKCdqc3RyZWUtdGhlbWVpY29uLWN1c3RvbScpLmNzcyhcXFwiYmFja2dyb3VuZFxcXCIsIFxcXCJ1cmwoJ1xcXCIgKyBpY29uICsgXFxcIicpIGNlbnRlciBjZW50ZXIgbm8tcmVwZWF0XFxcIikuYXR0cihcXFwicmVsXFxcIiwgaWNvbik7XFxuXFxuICAgICAgICBpZiAob2xkID09PSBmYWxzZSkge1xcbiAgICAgICAgICB0aGlzLnNob3dfaWNvbihvYmopO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIGdldCB0aGUgbm9kZSBpY29uIGZvciBhIG5vZGVcXG4gICAgICogQG5hbWUgZ2V0X2ljb24ob2JqKVxcbiAgICAgKiBAcGFyYW0ge21peGVkfSBvYmpcXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxcbiAgICAgKi9cXG4gICAgZ2V0X2ljb246IGZ1bmN0aW9uIGdldF9pY29uKG9iaikge1xcbiAgICAgIG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcXG4gICAgICByZXR1cm4gIW9iaiB8fCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QgPyBmYWxzZSA6IG9iai5pY29uO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogaGlkZSB0aGUgaWNvbiBvbiBhbiBpbmRpdmlkdWFsIG5vZGVcXG4gICAgICogQG5hbWUgaGlkZV9pY29uKG9iailcXG4gICAgICogQHBhcmFtIHttaXhlZH0gb2JqXFxuICAgICAqL1xcbiAgICBoaWRlX2ljb246IGZ1bmN0aW9uIGhpZGVfaWNvbihvYmopIHtcXG4gICAgICB2YXIgdDEsIHQyO1xcblxcbiAgICAgIGlmICgkLmlzQXJyYXkob2JqKSkge1xcbiAgICAgICAgb2JqID0gb2JqLnNsaWNlKCk7XFxuXFxuICAgICAgICBmb3IgKHQxID0gMCwgdDIgPSBvYmoubGVuZ3RoOyB0MSA8IHQyOyB0MSsrKSB7XFxuICAgICAgICAgIHRoaXMuaGlkZV9pY29uKG9ialt0MV0pO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgfVxcblxcbiAgICAgIG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXG4gICAgICBpZiAoIW9iaiB8fCBvYmogPT09ICQuanN0cmVlLnJvb3QpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgb2JqLmljb24gPSBmYWxzZTtcXG4gICAgICB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSkuY2hpbGRyZW4oXFxcIi5qc3RyZWUtYW5jaG9yXFxcIikuY2hpbGRyZW4oXFxcIi5qc3RyZWUtdGhlbWVpY29uXFxcIikuYWRkQ2xhc3MoJ2pzdHJlZS10aGVtZWljb24taGlkZGVuJyk7XFxuICAgICAgcmV0dXJuIHRydWU7XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBzaG93IHRoZSBpY29uIG9uIGFuIGluZGl2aWR1YWwgbm9kZVxcbiAgICAgKiBAbmFtZSBzaG93X2ljb24ob2JqKVxcbiAgICAgKiBAcGFyYW0ge21peGVkfSBvYmpcXG4gICAgICovXFxuICAgIHNob3dfaWNvbjogZnVuY3Rpb24gc2hvd19pY29uKG9iaikge1xcbiAgICAgIHZhciB0MSwgdDIsIGRvbTtcXG5cXG4gICAgICBpZiAoJC5pc0FycmF5KG9iaikpIHtcXG4gICAgICAgIG9iaiA9IG9iai5zbGljZSgpO1xcblxcbiAgICAgICAgZm9yICh0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xcbiAgICAgICAgICB0aGlzLnNob3dfaWNvbihvYmpbdDFdKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgIH1cXG5cXG4gICAgICBvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XFxuXFxuICAgICAgaWYgKCFvYmogfHwgb2JqID09PSAkLmpzdHJlZS5yb290KSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcblxcbiAgICAgIGRvbSA9IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKTtcXG4gICAgICBvYmouaWNvbiA9IGRvbS5sZW5ndGggPyBkb20uY2hpbGRyZW4oXFxcIi5qc3RyZWUtYW5jaG9yXFxcIikuY2hpbGRyZW4oXFxcIi5qc3RyZWUtdGhlbWVpY29uXFxcIikuYXR0cigncmVsJykgOiB0cnVlO1xcblxcbiAgICAgIGlmICghb2JqLmljb24pIHtcXG4gICAgICAgIG9iai5pY29uID0gdHJ1ZTtcXG4gICAgICB9XFxuXFxuICAgICAgZG9tLmNoaWxkcmVuKFxcXCIuanN0cmVlLWFuY2hvclxcXCIpLmNoaWxkcmVuKFxcXCIuanN0cmVlLXRoZW1laWNvblxcXCIpLnJlbW92ZUNsYXNzKCdqc3RyZWUtdGhlbWVpY29uLWhpZGRlbicpO1xcbiAgICAgIHJldHVybiB0cnVlO1xcbiAgICB9XFxuICB9OyAvLyBoZWxwZXJzXFxuXFxuICAkLnZha2F0YSA9IHt9OyAvLyBjb2xsZWN0IGF0dHJpYnV0ZXNcXG5cXG4gICQudmFrYXRhLmF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAobm9kZSwgd2l0aF92YWx1ZXMpIHtcXG4gICAgbm9kZSA9ICQobm9kZSlbMF07XFxuICAgIHZhciBhdHRyID0gd2l0aF92YWx1ZXMgPyB7fSA6IFtdO1xcblxcbiAgICBpZiAobm9kZSAmJiBub2RlLmF0dHJpYnV0ZXMpIHtcXG4gICAgICAkLmVhY2gobm9kZS5hdHRyaWJ1dGVzLCBmdW5jdGlvbiAoaSwgdikge1xcbiAgICAgICAgaWYgKCQuaW5BcnJheSh2Lm5hbWUudG9Mb3dlckNhc2UoKSwgWydzdHlsZScsICdjb250ZW50ZWRpdGFibGUnLCAnaGFzZm9jdXMnLCAndGFiaW5kZXgnXSkgIT09IC0xKSB7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICh2LnZhbHVlICE9PSBudWxsICYmICQudHJpbSh2LnZhbHVlKSAhPT0gJycpIHtcXG4gICAgICAgICAgaWYgKHdpdGhfdmFsdWVzKSB7XFxuICAgICAgICAgICAgYXR0clt2Lm5hbWVdID0gdi52YWx1ZTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBhdHRyLnB1c2godi5uYW1lKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBhdHRyO1xcbiAgfTtcXG5cXG4gICQudmFrYXRhLmFycmF5X3VuaXF1ZSA9IGZ1bmN0aW9uIChhcnJheSkge1xcbiAgICB2YXIgYSA9IFtdLFxcbiAgICAgICAgaSxcXG4gICAgICAgIGosXFxuICAgICAgICBsLFxcbiAgICAgICAgbyA9IHt9O1xcblxcbiAgICBmb3IgKGkgPSAwLCBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XFxuICAgICAgaWYgKG9bYXJyYXlbaV1dID09PSB1bmRlZmluZWQpIHtcXG4gICAgICAgIGEucHVzaChhcnJheVtpXSk7XFxuICAgICAgICBvW2FycmF5W2ldXSA9IHRydWU7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHJldHVybiBhO1xcbiAgfTsgLy8gcmVtb3ZlIGl0ZW0gZnJvbSBhcnJheVxcblxcblxcbiAgJC52YWthdGEuYXJyYXlfcmVtb3ZlID0gZnVuY3Rpb24gKGFycmF5LCBmcm9tKSB7XFxuICAgIGFycmF5LnNwbGljZShmcm9tLCAxKTtcXG4gICAgcmV0dXJuIGFycmF5OyAvL3ZhciByZXN0ID0gYXJyYXkuc2xpY2UoKHRvIHx8IGZyb20pICsgMSB8fCBhcnJheS5sZW5ndGgpO1xcbiAgICAvL2FycmF5Lmxlbmd0aCA9IGZyb20gPCAwID8gYXJyYXkubGVuZ3RoICsgZnJvbSA6IGZyb207XFxuICAgIC8vYXJyYXkucHVzaC5hcHBseShhcnJheSwgcmVzdCk7XFxuICAgIC8vcmV0dXJuIGFycmF5O1xcbiAgfTsgLy8gcmVtb3ZlIGl0ZW0gZnJvbSBhcnJheVxcblxcblxcbiAgJC52YWthdGEuYXJyYXlfcmVtb3ZlX2l0ZW0gPSBmdW5jdGlvbiAoYXJyYXksIGl0ZW0pIHtcXG4gICAgdmFyIHRtcCA9ICQuaW5BcnJheShpdGVtLCBhcnJheSk7XFxuICAgIHJldHVybiB0bXAgIT09IC0xID8gJC52YWthdGEuYXJyYXlfcmVtb3ZlKGFycmF5LCB0bXApIDogYXJyYXk7XFxuICB9O1xcblxcbiAgJC52YWthdGEuYXJyYXlfZmlsdGVyID0gZnVuY3Rpb24gKGMsIGEsIGIsIGQsIGUpIHtcXG4gICAgaWYgKGMuZmlsdGVyKSB7XFxuICAgICAgcmV0dXJuIGMuZmlsdGVyKGEsIGIpO1xcbiAgICB9XFxuXFxuICAgIGQgPSBbXTtcXG5cXG4gICAgZm9yIChlIGluIGMpIHtcXG4gICAgICBpZiAofn5lICsgJycgPT09IGUgKyAnJyAmJiBlID49IDAgJiYgYS5jYWxsKGIsIGNbZV0sICtlLCBjKSkge1xcbiAgICAgICAgZC5wdXNoKGNbZV0pO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICByZXR1cm4gZDtcXG4gIH07XFxuICAvKipcXG4gICAqICMjIyBDaGFuZ2VkIHBsdWdpblxcbiAgICpcXG4gICAqIFRoaXMgcGx1Z2luIGFkZHMgbW9yZSBpbmZvcm1hdGlvbiB0byB0aGUgYGNoYW5nZWQuanN0cmVlYCBldmVudC4gVGhlIG5ldyBkYXRhIGlzIGNvbnRhaW5lZCBpbiB0aGUgYGNoYW5nZWRgIGV2ZW50IGRhdGEgcHJvcGVydHksIGFuZCBjb250YWlucyBhIGxpc3RzIG9mIGBzZWxlY3RlZGAgYW5kIGBkZXNlbGVjdGVkYCBub2Rlcy5cXG4gICAqL1xcblxcblxcbiAgJC5qc3RyZWUucGx1Z2lucy5jaGFuZ2VkID0gZnVuY3Rpb24gKG9wdGlvbnMsIHBhcmVudCkge1xcbiAgICB2YXIgbGFzdCA9IFtdO1xcblxcbiAgICB0aGlzLnRyaWdnZXIgPSBmdW5jdGlvbiAoZXYsIGRhdGEpIHtcXG4gICAgICB2YXIgaSwgajtcXG5cXG4gICAgICBpZiAoIWRhdGEpIHtcXG4gICAgICAgIGRhdGEgPSB7fTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGV2LnJlcGxhY2UoJy5qc3RyZWUnLCAnJykgPT09ICdjaGFuZ2VkJykge1xcbiAgICAgICAgZGF0YS5jaGFuZ2VkID0ge1xcbiAgICAgICAgICBzZWxlY3RlZDogW10sXFxuICAgICAgICAgIGRlc2VsZWN0ZWQ6IFtdXFxuICAgICAgICB9O1xcbiAgICAgICAgdmFyIHRtcCA9IHt9O1xcblxcbiAgICAgICAgZm9yIChpID0gMCwgaiA9IGxhc3QubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICAgIHRtcFtsYXN0W2ldXSA9IDE7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBmb3IgKGkgPSAwLCBqID0gZGF0YS5zZWxlY3RlZC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG4gICAgICAgICAgaWYgKCF0bXBbZGF0YS5zZWxlY3RlZFtpXV0pIHtcXG4gICAgICAgICAgICBkYXRhLmNoYW5nZWQuc2VsZWN0ZWQucHVzaChkYXRhLnNlbGVjdGVkW2ldKTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICB0bXBbZGF0YS5zZWxlY3RlZFtpXV0gPSAyO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICBmb3IgKGkgPSAwLCBqID0gbGFzdC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG4gICAgICAgICAgaWYgKHRtcFtsYXN0W2ldXSA9PT0gMSkge1xcbiAgICAgICAgICAgIGRhdGEuY2hhbmdlZC5kZXNlbGVjdGVkLnB1c2gobGFzdFtpXSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGxhc3QgPSBkYXRhLnNlbGVjdGVkLnNsaWNlKCk7XFxuICAgICAgfVxcbiAgICAgIC8qKlxcbiAgICAgICAqIHRyaWdnZXJlZCB3aGVuIHNlbGVjdGlvbiBjaGFuZ2VzICh0aGUgXFxcImNoYW5nZWRcXFwiIHBsdWdpbiBlbmhhbmNlcyB0aGUgb3JpZ2luYWwgZXZlbnQgd2l0aCBtb3JlIGRhdGEpXFxuICAgICAgICogQGV2ZW50XFxuICAgICAgICogQG5hbWUgY2hhbmdlZC5qc3RyZWVcXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZVxcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24gdGhlIGFjdGlvbiB0aGF0IGNhdXNlZCB0aGUgc2VsZWN0aW9uIHRvIGNoYW5nZVxcbiAgICAgICAqIEBwYXJhbSB7QXJyYXl9IHNlbGVjdGVkIHRoZSBjdXJyZW50IHNlbGVjdGlvblxcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjaGFuZ2VkIGFuIG9iamVjdCBjb250YWluaW5nIHR3byBwcm9wZXJ0aWVzIGBzZWxlY3RlZGAgYW5kIGBkZXNlbGVjdGVkYCAtIGJvdGggYXJyYXlzIG9mIG5vZGUgSURzLCB3aGljaCB3ZXJlIHNlbGVjdGVkIG9yIGRlc2VsZWN0ZWQgc2luY2UgdGhlIGxhc3QgY2hhbmdlZCBldmVudFxcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCB0aGUgZXZlbnQgKGlmIGFueSkgdGhhdCB0cmlnZ2VyZWQgdGhpcyBjaGFuZ2VkIGV2ZW50XFxuICAgICAgICogQHBsdWdpbiBjaGFuZ2VkXFxuICAgICAgICovXFxuXFxuXFxuICAgICAgcGFyZW50LnRyaWdnZXIuY2FsbCh0aGlzLCBldiwgZGF0YSk7XFxuICAgIH07XFxuXFxuICAgIHRoaXMucmVmcmVzaCA9IGZ1bmN0aW9uIChza2lwX2xvYWRpbmcsIGZvcmdldF9zdGF0ZSkge1xcbiAgICAgIGxhc3QgPSBbXTtcXG4gICAgICByZXR1cm4gcGFyZW50LnJlZnJlc2guYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gICAgfTtcXG4gIH07XFxuICAvKipcXG4gICAqICMjIyBDaGVja2JveCBwbHVnaW5cXG4gICAqXFxuICAgKiBUaGlzIHBsdWdpbiByZW5kZXJzIGNoZWNrYm94IGljb25zIGluIGZyb250IG9mIGVhY2ggbm9kZSwgbWFraW5nIG11bHRpcGxlIHNlbGVjdGlvbiBtdWNoIGVhc2llci5cXG4gICAqIEl0IGFsc28gc3VwcG9ydHMgdHJpLXN0YXRlIGJlaGF2aW9yLCBtZWFuaW5nIHRoYXQgaWYgYSBub2RlIGhhcyBhIGZldyBvZiBpdHMgY2hpbGRyZW4gY2hlY2tlZCBpdCB3aWxsIGJlIHJlbmRlcmVkIGFzIHVuZGV0ZXJtaW5lZCwgYW5kIHN0YXRlIHdpbGwgYmUgcHJvcGFnYXRlZCB1cC5cXG4gICAqL1xcblxcblxcbiAgdmFyIF9pID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnSScpO1xcblxcbiAgX2kuY2xhc3NOYW1lID0gJ2pzdHJlZS1pY29uIGpzdHJlZS1jaGVja2JveCc7XFxuXFxuICBfaS5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAncHJlc2VudGF0aW9uJyk7XFxuICAvKipcXG4gICAqIHN0b3JlcyBhbGwgZGVmYXVsdHMgZm9yIHRoZSBjaGVja2JveCBwbHVnaW5cXG4gICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNoZWNrYm94XFxuICAgKiBAcGx1Z2luIGNoZWNrYm94XFxuICAgKi9cXG5cXG5cXG4gICQuanN0cmVlLmRlZmF1bHRzLmNoZWNrYm94ID0ge1xcbiAgICAvKipcXG4gICAgICogYSBib29sZWFuIGluZGljYXRpbmcgaWYgY2hlY2tib3hlcyBzaG91bGQgYmUgdmlzaWJsZSAoY2FuIGJlIGNoYW5nZWQgYXQgYSBsYXRlciB0aW1lIHVzaW5nIGBzaG93X2NoZWNrYm94ZXMoKWAgYW5kIGBoaWRlX2NoZWNrYm94ZXNgKS4gRGVmYXVsdHMgdG8gYHRydWVgLlxcbiAgICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jaGVja2JveC52aXNpYmxlXFxuICAgICAqIEBwbHVnaW4gY2hlY2tib3hcXG4gICAgICovXFxuICAgIHZpc2libGU6IHRydWUsXFxuXFxuICAgIC8qKlxcbiAgICAgKiBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiBjaGVja2JveGVzIHNob3VsZCBjYXNjYWRlIGRvd24gYW5kIGhhdmUgYW4gdW5kZXRlcm1pbmVkIHN0YXRlLiBEZWZhdWx0cyB0byBgdHJ1ZWAuXFxuICAgICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNoZWNrYm94LnRocmVlX3N0YXRlXFxuICAgICAqIEBwbHVnaW4gY2hlY2tib3hcXG4gICAgICovXFxuICAgIHRocmVlX3N0YXRlOiB0cnVlLFxcblxcbiAgICAvKipcXG4gICAgICogYSBib29sZWFuIGluZGljYXRpbmcgaWYgY2xpY2tpbmcgYW55d2hlcmUgb24gdGhlIG5vZGUgc2hvdWxkIGFjdCBhcyBjbGlja2luZyBvbiB0aGUgY2hlY2tib3guIERlZmF1bHRzIHRvIGB0cnVlYC5cXG4gICAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY2hlY2tib3gud2hvbGVfbm9kZVxcbiAgICAgKiBAcGx1Z2luIGNoZWNrYm94XFxuICAgICAqL1xcbiAgICB3aG9sZV9ub2RlOiB0cnVlLFxcblxcbiAgICAvKipcXG4gICAgICogYSBib29sZWFuIGluZGljYXRpbmcgaWYgdGhlIHNlbGVjdGVkIHN0eWxlIG9mIGEgbm9kZSBzaG91bGQgYmUga2VwdCwgb3IgcmVtb3ZlZC4gRGVmYXVsdHMgdG8gYHRydWVgLlxcbiAgICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jaGVja2JveC5rZWVwX3NlbGVjdGVkX3N0eWxlXFxuICAgICAqIEBwbHVnaW4gY2hlY2tib3hcXG4gICAgICovXFxuICAgIGtlZXBfc2VsZWN0ZWRfc3R5bGU6IHRydWUsXFxuXFxuICAgIC8qKlxcbiAgICAgKiBUaGlzIHNldHRpbmcgY29udHJvbHMgaG93IGNhc2NhZGluZyBhbmQgdW5kZXRlcm1pbmVkIG5vZGVzIGFyZSBhcHBsaWVkLlxcbiAgICAgKiBJZiAndXAnIGlzIGluIHRoZSBzdHJpbmcgLSBjYXNjYWRpbmcgdXAgaXMgZW5hYmxlZCwgaWYgJ2Rvd24nIGlzIGluIHRoZSBzdHJpbmcgLSBjYXNjYWRpbmcgZG93biBpcyBlbmFibGVkLCBpZiAndW5kZXRlcm1pbmVkJyBpcyBpbiB0aGUgc3RyaW5nIC0gdW5kZXRlcm1pbmVkIG5vZGVzIHdpbGwgYmUgdXNlZC5cXG4gICAgICogSWYgYHRocmVlX3N0YXRlYCBpcyBzZXQgdG8gYHRydWVgIHRoaXMgc2V0dGluZyBpcyBhdXRvbWF0aWNhbGx5IHNldCB0byAndXArZG93bit1bmRldGVybWluZWQnLiBEZWZhdWx0cyB0byAnJy5cXG4gICAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY2hlY2tib3guY2FzY2FkZVxcbiAgICAgKiBAcGx1Z2luIGNoZWNrYm94XFxuICAgICAqL1xcbiAgICBjYXNjYWRlOiAnJyxcXG5cXG4gICAgLyoqXFxuICAgICAqIFRoaXMgc2V0dGluZyBjb250cm9scyBpZiBjaGVja2JveCBhcmUgYm91bmQgdG8gdGhlIGdlbmVyYWwgdHJlZSBzZWxlY3Rpb24gb3IgdG8gYW4gaW50ZXJuYWwgYXJyYXkgbWFpbnRhaW5lZCBieSB0aGUgY2hlY2tib3ggcGx1Z2luLiBEZWZhdWx0cyB0byBgdHJ1ZWAsIG9ubHkgc2V0IHRvIGBmYWxzZWAgaWYgeW91IGtub3cgZXhhY3RseSB3aGF0IHlvdSBhcmUgZG9pbmcuXFxuICAgICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb25cXG4gICAgICogQHBsdWdpbiBjaGVja2JveFxcbiAgICAgKi9cXG4gICAgdGllX3NlbGVjdGlvbjogdHJ1ZVxcbiAgfTtcXG5cXG4gICQuanN0cmVlLnBsdWdpbnMuY2hlY2tib3ggPSBmdW5jdGlvbiAob3B0aW9ucywgcGFyZW50KSB7XFxuICAgIHRoaXMuYmluZCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICBwYXJlbnQuYmluZC5jYWxsKHRoaXMpO1xcbiAgICAgIHRoaXMuX2RhdGEuY2hlY2tib3gudXRvID0gZmFsc2U7XFxuICAgICAgdGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZCA9IFtdO1xcblxcbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRocmVlX3N0YXRlKSB7XFxuICAgICAgICB0aGlzLnNldHRpbmdzLmNoZWNrYm94LmNhc2NhZGUgPSAndXArZG93bit1bmRldGVybWluZWQnO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLmVsZW1lbnQub24oXFxcImluaXQuanN0cmVlXFxcIiwgJC5wcm94eShmdW5jdGlvbiAoKSB7XFxuICAgICAgICB0aGlzLl9kYXRhLmNoZWNrYm94LnZpc2libGUgPSB0aGlzLnNldHRpbmdzLmNoZWNrYm94LnZpc2libGU7XFxuXFxuICAgICAgICBpZiAoIXRoaXMuc2V0dGluZ3MuY2hlY2tib3gua2VlcF9zZWxlY3RlZF9zdHlsZSkge1xcbiAgICAgICAgICB0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoJ2pzdHJlZS1jaGVja2JveC1uby1jbGlja2VkJyk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uKSB7XFxuICAgICAgICAgIHRoaXMuZWxlbWVudC5hZGRDbGFzcygnanN0cmVlLWNoZWNrYm94LXNlbGVjdGlvbicpO1xcbiAgICAgICAgfVxcbiAgICAgIH0sIHRoaXMpKS5vbihcXFwibG9hZGluZy5qc3RyZWVcXFwiLCAkLnByb3h5KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHRoaXNbdGhpcy5fZGF0YS5jaGVja2JveC52aXNpYmxlID8gJ3Nob3dfY2hlY2tib3hlcycgOiAnaGlkZV9jaGVja2JveGVzJ10oKTtcXG4gICAgICB9LCB0aGlzKSk7XFxuXFxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuY2hlY2tib3guY2FzY2FkZS5pbmRleE9mKCd1bmRldGVybWluZWQnKSAhPT0gLTEpIHtcXG4gICAgICAgIHRoaXMuZWxlbWVudC5vbignY2hhbmdlZC5qc3RyZWUgdW5jaGVja19ub2RlLmpzdHJlZSBjaGVja19ub2RlLmpzdHJlZSB1bmNoZWNrX2FsbC5qc3RyZWUgY2hlY2tfYWxsLmpzdHJlZSBtb3ZlX25vZGUuanN0cmVlIGNvcHlfbm9kZS5qc3RyZWUgcmVkcmF3LmpzdHJlZSBvcGVuX25vZGUuanN0cmVlJywgJC5wcm94eShmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIC8vIG9ubHkgaWYgdW5kZXRlcm1pbmVkIGlzIGluIHNldHRpbmdcXG4gICAgICAgICAgaWYgKHRoaXMuX2RhdGEuY2hlY2tib3gudXRvKSB7XFxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2RhdGEuY2hlY2tib3gudXRvKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICB0aGlzLl9kYXRhLmNoZWNrYm94LnV0byA9IHNldFRpbWVvdXQoJC5wcm94eSh0aGlzLl91bmRldGVybWluZWQsIHRoaXMpLCA1MCk7XFxuICAgICAgICB9LCB0aGlzKSk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghdGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uKSB7XFxuICAgICAgICB0aGlzLmVsZW1lbnQub24oJ21vZGVsLmpzdHJlZScsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcXG4gICAgICAgICAgdmFyIG0gPSB0aGlzLl9tb2RlbC5kYXRhLFxcbiAgICAgICAgICAgICAgcCA9IG1bZGF0YS5wYXJlbnRdLFxcbiAgICAgICAgICAgICAgZHBjID0gZGF0YS5ub2RlcyxcXG4gICAgICAgICAgICAgIGksXFxuICAgICAgICAgICAgICBqO1xcblxcbiAgICAgICAgICBmb3IgKGkgPSAwLCBqID0gZHBjLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcbiAgICAgICAgICAgIG1bZHBjW2ldXS5zdGF0ZS5jaGVja2VkID0gbVtkcGNbaV1dLnN0YXRlLmNoZWNrZWQgfHwgbVtkcGNbaV1dLm9yaWdpbmFsICYmIG1bZHBjW2ldXS5vcmlnaW5hbC5zdGF0ZSAmJiBtW2RwY1tpXV0ub3JpZ2luYWwuc3RhdGUuY2hlY2tlZDtcXG5cXG4gICAgICAgICAgICBpZiAobVtkcGNbaV1dLnN0YXRlLmNoZWNrZWQpIHtcXG4gICAgICAgICAgICAgIHRoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWQucHVzaChkcGNbaV0pO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfSwgdGhpcykpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5jaGVja2JveC5jYXNjYWRlLmluZGV4T2YoJ3VwJykgIT09IC0xIHx8IHRoaXMuc2V0dGluZ3MuY2hlY2tib3guY2FzY2FkZS5pbmRleE9mKCdkb3duJykgIT09IC0xKSB7XFxuICAgICAgICB0aGlzLmVsZW1lbnQub24oJ21vZGVsLmpzdHJlZScsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcXG4gICAgICAgICAgdmFyIG0gPSB0aGlzLl9tb2RlbC5kYXRhLFxcbiAgICAgICAgICAgICAgcCA9IG1bZGF0YS5wYXJlbnRdLFxcbiAgICAgICAgICAgICAgZHBjID0gZGF0YS5ub2RlcyxcXG4gICAgICAgICAgICAgIGNoZCA9IFtdLFxcbiAgICAgICAgICAgICAgYyxcXG4gICAgICAgICAgICAgIGksXFxuICAgICAgICAgICAgICBqLFxcbiAgICAgICAgICAgICAgayxcXG4gICAgICAgICAgICAgIGwsXFxuICAgICAgICAgICAgICB0bXAsXFxuICAgICAgICAgICAgICBzID0gdGhpcy5zZXR0aW5ncy5jaGVja2JveC5jYXNjYWRlLFxcbiAgICAgICAgICAgICAgdCA9IHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbjtcXG5cXG4gICAgICAgICAgaWYgKHMuaW5kZXhPZignZG93bicpICE9PSAtMSkge1xcbiAgICAgICAgICAgIC8vIGFwcGx5IGRvd25cXG4gICAgICAgICAgICBpZiAocC5zdGF0ZVt0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJ10pIHtcXG4gICAgICAgICAgICAgIGZvciAoaSA9IDAsIGogPSBkcGMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICAgICAgICAgIG1bZHBjW2ldXS5zdGF0ZVt0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJ10gPSB0cnVlO1xcbiAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgdGhpcy5fZGF0YVt0ID8gJ2NvcmUnIDogJ2NoZWNrYm94J10uc2VsZWN0ZWQgPSB0aGlzLl9kYXRhW3QgPyAnY29yZScgOiAnY2hlY2tib3gnXS5zZWxlY3RlZC5jb25jYXQoZHBjKTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgZm9yIChpID0gMCwgaiA9IGRwYy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG4gICAgICAgICAgICAgICAgaWYgKG1bZHBjW2ldXS5zdGF0ZVt0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJ10pIHtcXG4gICAgICAgICAgICAgICAgICBmb3IgKGsgPSAwLCBsID0gbVtkcGNbaV1dLmNoaWxkcmVuX2QubGVuZ3RoOyBrIDwgbDsgaysrKSB7XFxuICAgICAgICAgICAgICAgICAgICBtW21bZHBjW2ldXS5jaGlsZHJlbl9kW2tdXS5zdGF0ZVt0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJ10gPSB0cnVlO1xcbiAgICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgICB0aGlzLl9kYXRhW3QgPyAnY29yZScgOiAnY2hlY2tib3gnXS5zZWxlY3RlZCA9IHRoaXMuX2RhdGFbdCA/ICdjb3JlJyA6ICdjaGVja2JveCddLnNlbGVjdGVkLmNvbmNhdChtW2RwY1tpXV0uY2hpbGRyZW5fZCk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaWYgKHMuaW5kZXhPZigndXAnKSAhPT0gLTEpIHtcXG4gICAgICAgICAgICAvLyBhcHBseSB1cFxcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGogPSBwLmNoaWxkcmVuX2QubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICAgICAgICBpZiAoIW1bcC5jaGlsZHJlbl9kW2ldXS5jaGlsZHJlbi5sZW5ndGgpIHtcXG4gICAgICAgICAgICAgICAgY2hkLnB1c2gobVtwLmNoaWxkcmVuX2RbaV1dLnBhcmVudCk7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGNoZCA9ICQudmFrYXRhLmFycmF5X3VuaXF1ZShjaGQpO1xcblxcbiAgICAgICAgICAgIGZvciAoayA9IDAsIGwgPSBjaGQubGVuZ3RoOyBrIDwgbDsgaysrKSB7XFxuICAgICAgICAgICAgICBwID0gbVtjaGRba11dO1xcblxcbiAgICAgICAgICAgICAgd2hpbGUgKHAgJiYgcC5pZCAhPT0gJC5qc3RyZWUucm9vdCkge1xcbiAgICAgICAgICAgICAgICBjID0gMDtcXG5cXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaiA9IHAuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICAgICAgICAgICAgYyArPSBtW3AuY2hpbGRyZW5baV1dLnN0YXRlW3QgPyAnc2VsZWN0ZWQnIDogJ2NoZWNrZWQnXTtcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICBpZiAoYyA9PT0gaikge1xcbiAgICAgICAgICAgICAgICAgIHAuc3RhdGVbdCA/ICdzZWxlY3RlZCcgOiAnY2hlY2tlZCddID0gdHJ1ZTtcXG5cXG4gICAgICAgICAgICAgICAgICB0aGlzLl9kYXRhW3QgPyAnY29yZScgOiAnY2hlY2tib3gnXS5zZWxlY3RlZC5wdXNoKHAuaWQpO1xcblxcbiAgICAgICAgICAgICAgICAgIHRtcCA9IHRoaXMuZ2V0X25vZGUocCwgdHJ1ZSk7XFxuXFxuICAgICAgICAgICAgICAgICAgaWYgKHRtcCAmJiB0bXAubGVuZ3RoKSB7XFxuICAgICAgICAgICAgICAgICAgICB0bXAuYXR0cignYXJpYS1zZWxlY3RlZCcsIHRydWUpLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLmFkZENsYXNzKHQgPyAnanN0cmVlLWNsaWNrZWQnIDogJ2pzdHJlZS1jaGVja2VkJyk7XFxuICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIHAgPSB0aGlzLmdldF9ub2RlKHAucGFyZW50KTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgdGhpcy5fZGF0YVt0ID8gJ2NvcmUnIDogJ2NoZWNrYm94J10uc2VsZWN0ZWQgPSAkLnZha2F0YS5hcnJheV91bmlxdWUodGhpcy5fZGF0YVt0ID8gJ2NvcmUnIDogJ2NoZWNrYm94J10uc2VsZWN0ZWQpO1xcbiAgICAgICAgfSwgdGhpcykpLm9uKHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbiA/ICdzZWxlY3Rfbm9kZS5qc3RyZWUnIDogJ2NoZWNrX25vZGUuanN0cmVlJywgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xcbiAgICAgICAgICB2YXIgb2JqID0gZGF0YS5ub2RlLFxcbiAgICAgICAgICAgICAgbSA9IHRoaXMuX21vZGVsLmRhdGEsXFxuICAgICAgICAgICAgICBwYXIgPSB0aGlzLmdldF9ub2RlKG9iai5wYXJlbnQpLFxcbiAgICAgICAgICAgICAgZG9tID0gdGhpcy5nZXRfbm9kZShvYmosIHRydWUpLFxcbiAgICAgICAgICAgICAgaSxcXG4gICAgICAgICAgICAgIGosXFxuICAgICAgICAgICAgICBjLFxcbiAgICAgICAgICAgICAgdG1wLFxcbiAgICAgICAgICAgICAgcyA9IHRoaXMuc2V0dGluZ3MuY2hlY2tib3guY2FzY2FkZSxcXG4gICAgICAgICAgICAgIHQgPSB0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb24sXFxuICAgICAgICAgICAgICBzZWwgPSB7fSxcXG4gICAgICAgICAgICAgIGN1ciA9IHRoaXMuX2RhdGFbdCA/ICdjb3JlJyA6ICdjaGVja2JveCddLnNlbGVjdGVkO1xcblxcbiAgICAgICAgICBmb3IgKGkgPSAwLCBqID0gY3VyLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcbiAgICAgICAgICAgIHNlbFtjdXJbaV1dID0gdHJ1ZTtcXG4gICAgICAgICAgfSAvLyBhcHBseSBkb3duXFxuXFxuXFxuICAgICAgICAgIGlmIChzLmluZGV4T2YoJ2Rvd24nKSAhPT0gLTEpIHtcXG4gICAgICAgICAgICAvL3RoaXMuX2RhdGFbIHQgPyAnY29yZScgOiAnY2hlY2tib3gnIF0uc2VsZWN0ZWQgPSAkLnZha2F0YS5hcnJheV91bmlxdWUodGhpcy5fZGF0YVsgdCA/ICdjb3JlJyA6ICdjaGVja2JveCcgXS5zZWxlY3RlZC5jb25jYXQob2JqLmNoaWxkcmVuX2QpKTtcXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBqID0gb2JqLmNoaWxkcmVuX2QubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICAgICAgICBzZWxbb2JqLmNoaWxkcmVuX2RbaV1dID0gdHJ1ZTtcXG4gICAgICAgICAgICAgIHRtcCA9IG1bb2JqLmNoaWxkcmVuX2RbaV1dO1xcbiAgICAgICAgICAgICAgdG1wLnN0YXRlW3QgPyAnc2VsZWN0ZWQnIDogJ2NoZWNrZWQnXSA9IHRydWU7XFxuXFxuICAgICAgICAgICAgICBpZiAodG1wICYmIHRtcC5vcmlnaW5hbCAmJiB0bXAub3JpZ2luYWwuc3RhdGUgJiYgdG1wLm9yaWdpbmFsLnN0YXRlLnVuZGV0ZXJtaW5lZCkge1xcbiAgICAgICAgICAgICAgICB0bXAub3JpZ2luYWwuc3RhdGUudW5kZXRlcm1pbmVkID0gZmFsc2U7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9IC8vIGFwcGx5IHVwXFxuXFxuXFxuICAgICAgICAgIGlmIChzLmluZGV4T2YoJ3VwJykgIT09IC0xKSB7XFxuICAgICAgICAgICAgd2hpbGUgKHBhciAmJiBwYXIuaWQgIT09ICQuanN0cmVlLnJvb3QpIHtcXG4gICAgICAgICAgICAgIGMgPSAwO1xcblxcbiAgICAgICAgICAgICAgZm9yIChpID0gMCwgaiA9IHBhci5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG4gICAgICAgICAgICAgICAgYyArPSBtW3Bhci5jaGlsZHJlbltpXV0uc3RhdGVbdCA/ICdzZWxlY3RlZCcgOiAnY2hlY2tlZCddO1xcbiAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgaWYgKGMgPT09IGopIHtcXG4gICAgICAgICAgICAgICAgcGFyLnN0YXRlW3QgPyAnc2VsZWN0ZWQnIDogJ2NoZWNrZWQnXSA9IHRydWU7XFxuICAgICAgICAgICAgICAgIHNlbFtwYXIuaWRdID0gdHJ1ZTsgLy90aGlzLl9kYXRhWyB0ID8gJ2NvcmUnIDogJ2NoZWNrYm94JyBdLnNlbGVjdGVkLnB1c2gocGFyLmlkKTtcXG5cXG4gICAgICAgICAgICAgICAgdG1wID0gdGhpcy5nZXRfbm9kZShwYXIsIHRydWUpO1xcblxcbiAgICAgICAgICAgICAgICBpZiAodG1wICYmIHRtcC5sZW5ndGgpIHtcXG4gICAgICAgICAgICAgICAgICB0bXAuYXR0cignYXJpYS1zZWxlY3RlZCcsIHRydWUpLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLmFkZENsYXNzKHQgPyAnanN0cmVlLWNsaWNrZWQnIDogJ2pzdHJlZS1jaGVja2VkJyk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgcGFyID0gdGhpcy5nZXRfbm9kZShwYXIucGFyZW50KTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgY3VyID0gW107XFxuXFxuICAgICAgICAgIGZvciAoaSBpbiBzZWwpIHtcXG4gICAgICAgICAgICBpZiAoc2VsLmhhc093blByb3BlcnR5KGkpKSB7XFxuICAgICAgICAgICAgICBjdXIucHVzaChpKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgdGhpcy5fZGF0YVt0ID8gJ2NvcmUnIDogJ2NoZWNrYm94J10uc2VsZWN0ZWQgPSBjdXI7IC8vIGFwcGx5IGRvd24gKHByb2Nlc3MgLmNoaWxkcmVuIHNlcGFyYXRlbHk/KVxcblxcbiAgICAgICAgICBpZiAocy5pbmRleE9mKCdkb3duJykgIT09IC0xICYmIGRvbS5sZW5ndGgpIHtcXG4gICAgICAgICAgICBkb20uZmluZCgnLmpzdHJlZS1hbmNob3InKS5hZGRDbGFzcyh0ID8gJ2pzdHJlZS1jbGlja2VkJyA6ICdqc3RyZWUtY2hlY2tlZCcpLnBhcmVudCgpLmF0dHIoJ2FyaWEtc2VsZWN0ZWQnLCB0cnVlKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSwgdGhpcykpLm9uKHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbiA/ICdkZXNlbGVjdF9hbGwuanN0cmVlJyA6ICd1bmNoZWNrX2FsbC5qc3RyZWUnLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XFxuICAgICAgICAgIHZhciBvYmogPSB0aGlzLmdldF9ub2RlKCQuanN0cmVlLnJvb3QpLFxcbiAgICAgICAgICAgICAgbSA9IHRoaXMuX21vZGVsLmRhdGEsXFxuICAgICAgICAgICAgICBpLFxcbiAgICAgICAgICAgICAgaixcXG4gICAgICAgICAgICAgIHRtcDtcXG5cXG4gICAgICAgICAgZm9yIChpID0gMCwgaiA9IG9iai5jaGlsZHJlbl9kLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcbiAgICAgICAgICAgIHRtcCA9IG1bb2JqLmNoaWxkcmVuX2RbaV1dO1xcblxcbiAgICAgICAgICAgIGlmICh0bXAgJiYgdG1wLm9yaWdpbmFsICYmIHRtcC5vcmlnaW5hbC5zdGF0ZSAmJiB0bXAub3JpZ2luYWwuc3RhdGUudW5kZXRlcm1pbmVkKSB7XFxuICAgICAgICAgICAgICB0bXAub3JpZ2luYWwuc3RhdGUudW5kZXRlcm1pbmVkID0gZmFsc2U7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9LCB0aGlzKSkub24odGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uID8gJ2Rlc2VsZWN0X25vZGUuanN0cmVlJyA6ICd1bmNoZWNrX25vZGUuanN0cmVlJywgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xcbiAgICAgICAgICB2YXIgb2JqID0gZGF0YS5ub2RlLFxcbiAgICAgICAgICAgICAgZG9tID0gdGhpcy5nZXRfbm9kZShvYmosIHRydWUpLFxcbiAgICAgICAgICAgICAgaSxcXG4gICAgICAgICAgICAgIGosXFxuICAgICAgICAgICAgICB0bXAsXFxuICAgICAgICAgICAgICBzID0gdGhpcy5zZXR0aW5ncy5jaGVja2JveC5jYXNjYWRlLFxcbiAgICAgICAgICAgICAgdCA9IHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbixcXG4gICAgICAgICAgICAgIGN1ciA9IHRoaXMuX2RhdGFbdCA/ICdjb3JlJyA6ICdjaGVja2JveCddLnNlbGVjdGVkLFxcbiAgICAgICAgICAgICAgc2VsID0ge307XFxuXFxuICAgICAgICAgIGlmIChvYmogJiYgb2JqLm9yaWdpbmFsICYmIG9iai5vcmlnaW5hbC5zdGF0ZSAmJiBvYmoub3JpZ2luYWwuc3RhdGUudW5kZXRlcm1pbmVkKSB7XFxuICAgICAgICAgICAgb2JqLm9yaWdpbmFsLnN0YXRlLnVuZGV0ZXJtaW5lZCA9IGZhbHNlO1xcbiAgICAgICAgICB9IC8vIGFwcGx5IGRvd25cXG5cXG5cXG4gICAgICAgICAgaWYgKHMuaW5kZXhPZignZG93bicpICE9PSAtMSkge1xcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGogPSBvYmouY2hpbGRyZW5fZC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG4gICAgICAgICAgICAgIHRtcCA9IHRoaXMuX21vZGVsLmRhdGFbb2JqLmNoaWxkcmVuX2RbaV1dO1xcbiAgICAgICAgICAgICAgdG1wLnN0YXRlW3QgPyAnc2VsZWN0ZWQnIDogJ2NoZWNrZWQnXSA9IGZhbHNlO1xcblxcbiAgICAgICAgICAgICAgaWYgKHRtcCAmJiB0bXAub3JpZ2luYWwgJiYgdG1wLm9yaWdpbmFsLnN0YXRlICYmIHRtcC5vcmlnaW5hbC5zdGF0ZS51bmRldGVybWluZWQpIHtcXG4gICAgICAgICAgICAgICAgdG1wLm9yaWdpbmFsLnN0YXRlLnVuZGV0ZXJtaW5lZCA9IGZhbHNlO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSAvLyBhcHBseSB1cFxcblxcblxcbiAgICAgICAgICBpZiAocy5pbmRleE9mKCd1cCcpICE9PSAtMSkge1xcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGogPSBvYmoucGFyZW50cy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG4gICAgICAgICAgICAgIHRtcCA9IHRoaXMuX21vZGVsLmRhdGFbb2JqLnBhcmVudHNbaV1dO1xcbiAgICAgICAgICAgICAgdG1wLnN0YXRlW3QgPyAnc2VsZWN0ZWQnIDogJ2NoZWNrZWQnXSA9IGZhbHNlO1xcblxcbiAgICAgICAgICAgICAgaWYgKHRtcCAmJiB0bXAub3JpZ2luYWwgJiYgdG1wLm9yaWdpbmFsLnN0YXRlICYmIHRtcC5vcmlnaW5hbC5zdGF0ZS51bmRldGVybWluZWQpIHtcXG4gICAgICAgICAgICAgICAgdG1wLm9yaWdpbmFsLnN0YXRlLnVuZGV0ZXJtaW5lZCA9IGZhbHNlO1xcbiAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgdG1wID0gdGhpcy5nZXRfbm9kZShvYmoucGFyZW50c1tpXSwgdHJ1ZSk7XFxuXFxuICAgICAgICAgICAgICBpZiAodG1wICYmIHRtcC5sZW5ndGgpIHtcXG4gICAgICAgICAgICAgICAgdG1wLmF0dHIoJ2FyaWEtc2VsZWN0ZWQnLCBmYWxzZSkuY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykucmVtb3ZlQ2xhc3ModCA/ICdqc3RyZWUtY2xpY2tlZCcgOiAnanN0cmVlLWNoZWNrZWQnKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgc2VsID0ge307XFxuXFxuICAgICAgICAgIGZvciAoaSA9IDAsIGogPSBjdXIubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICAgICAgLy8gYXBwbHkgZG93biArIGFwcGx5IHVwXFxuICAgICAgICAgICAgaWYgKChzLmluZGV4T2YoJ2Rvd24nKSA9PT0gLTEgfHwgJC5pbkFycmF5KGN1cltpXSwgb2JqLmNoaWxkcmVuX2QpID09PSAtMSkgJiYgKHMuaW5kZXhPZigndXAnKSA9PT0gLTEgfHwgJC5pbkFycmF5KGN1cltpXSwgb2JqLnBhcmVudHMpID09PSAtMSkpIHtcXG4gICAgICAgICAgICAgIHNlbFtjdXJbaV1dID0gdHJ1ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgY3VyID0gW107XFxuXFxuICAgICAgICAgIGZvciAoaSBpbiBzZWwpIHtcXG4gICAgICAgICAgICBpZiAoc2VsLmhhc093blByb3BlcnR5KGkpKSB7XFxuICAgICAgICAgICAgICBjdXIucHVzaChpKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgdGhpcy5fZGF0YVt0ID8gJ2NvcmUnIDogJ2NoZWNrYm94J10uc2VsZWN0ZWQgPSBjdXI7IC8vIGFwcGx5IGRvd24gKHByb2Nlc3MgLmNoaWxkcmVuIHNlcGFyYXRlbHk/KVxcblxcbiAgICAgICAgICBpZiAocy5pbmRleE9mKCdkb3duJykgIT09IC0xICYmIGRvbS5sZW5ndGgpIHtcXG4gICAgICAgICAgICBkb20uZmluZCgnLmpzdHJlZS1hbmNob3InKS5yZW1vdmVDbGFzcyh0ID8gJ2pzdHJlZS1jbGlja2VkJyA6ICdqc3RyZWUtY2hlY2tlZCcpLnBhcmVudCgpLmF0dHIoJ2FyaWEtc2VsZWN0ZWQnLCBmYWxzZSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0sIHRoaXMpKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuY2hlY2tib3guY2FzY2FkZS5pbmRleE9mKCd1cCcpICE9PSAtMSkge1xcbiAgICAgICAgdGhpcy5lbGVtZW50Lm9uKCdkZWxldGVfbm9kZS5qc3RyZWUnLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XFxuICAgICAgICAgIC8vIGFwcGx5IHVwICh3aG9sZSBoYW5kbGVyKVxcbiAgICAgICAgICB2YXIgcCA9IHRoaXMuZ2V0X25vZGUoZGF0YS5wYXJlbnQpLFxcbiAgICAgICAgICAgICAgbSA9IHRoaXMuX21vZGVsLmRhdGEsXFxuICAgICAgICAgICAgICBpLFxcbiAgICAgICAgICAgICAgaixcXG4gICAgICAgICAgICAgIGMsXFxuICAgICAgICAgICAgICB0bXAsXFxuICAgICAgICAgICAgICB0ID0gdGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uO1xcblxcbiAgICAgICAgICB3aGlsZSAocCAmJiBwLmlkICE9PSAkLmpzdHJlZS5yb290ICYmICFwLnN0YXRlW3QgPyAnc2VsZWN0ZWQnIDogJ2NoZWNrZWQnXSkge1xcbiAgICAgICAgICAgIGMgPSAwO1xcblxcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGogPSBwLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcbiAgICAgICAgICAgICAgYyArPSBtW3AuY2hpbGRyZW5baV1dLnN0YXRlW3QgPyAnc2VsZWN0ZWQnIDogJ2NoZWNrZWQnXTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaWYgKGogPiAwICYmIGMgPT09IGopIHtcXG4gICAgICAgICAgICAgIHAuc3RhdGVbdCA/ICdzZWxlY3RlZCcgOiAnY2hlY2tlZCddID0gdHJ1ZTtcXG5cXG4gICAgICAgICAgICAgIHRoaXMuX2RhdGFbdCA/ICdjb3JlJyA6ICdjaGVja2JveCddLnNlbGVjdGVkLnB1c2gocC5pZCk7XFxuXFxuICAgICAgICAgICAgICB0bXAgPSB0aGlzLmdldF9ub2RlKHAsIHRydWUpO1xcblxcbiAgICAgICAgICAgICAgaWYgKHRtcCAmJiB0bXAubGVuZ3RoKSB7XFxuICAgICAgICAgICAgICAgIHRtcC5hdHRyKCdhcmlhLXNlbGVjdGVkJywgdHJ1ZSkuY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuYWRkQ2xhc3ModCA/ICdqc3RyZWUtY2xpY2tlZCcgOiAnanN0cmVlLWNoZWNrZWQnKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIHAgPSB0aGlzLmdldF9ub2RlKHAucGFyZW50KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSwgdGhpcykpLm9uKCdtb3ZlX25vZGUuanN0cmVlJywgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xcbiAgICAgICAgICAvLyBhcHBseSB1cCAod2hvbGUgaGFuZGxlcilcXG4gICAgICAgICAgdmFyIGlzX211bHRpID0gZGF0YS5pc19tdWx0aSxcXG4gICAgICAgICAgICAgIG9sZF9wYXIgPSBkYXRhLm9sZF9wYXJlbnQsXFxuICAgICAgICAgICAgICBuZXdfcGFyID0gdGhpcy5nZXRfbm9kZShkYXRhLnBhcmVudCksXFxuICAgICAgICAgICAgICBtID0gdGhpcy5fbW9kZWwuZGF0YSxcXG4gICAgICAgICAgICAgIHAsXFxuICAgICAgICAgICAgICBjLFxcbiAgICAgICAgICAgICAgaSxcXG4gICAgICAgICAgICAgIGosXFxuICAgICAgICAgICAgICB0bXAsXFxuICAgICAgICAgICAgICB0ID0gdGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uO1xcblxcbiAgICAgICAgICBpZiAoIWlzX211bHRpKSB7XFxuICAgICAgICAgICAgcCA9IHRoaXMuZ2V0X25vZGUob2xkX3Bhcik7XFxuXFxuICAgICAgICAgICAgd2hpbGUgKHAgJiYgcC5pZCAhPT0gJC5qc3RyZWUucm9vdCAmJiAhcC5zdGF0ZVt0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJ10pIHtcXG4gICAgICAgICAgICAgIGMgPSAwO1xcblxcbiAgICAgICAgICAgICAgZm9yIChpID0gMCwgaiA9IHAuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICAgICAgICAgIGMgKz0gbVtwLmNoaWxkcmVuW2ldXS5zdGF0ZVt0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJ107XFxuICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICBpZiAoaiA+IDAgJiYgYyA9PT0gaikge1xcbiAgICAgICAgICAgICAgICBwLnN0YXRlW3QgPyAnc2VsZWN0ZWQnIDogJ2NoZWNrZWQnXSA9IHRydWU7XFxuXFxuICAgICAgICAgICAgICAgIHRoaXMuX2RhdGFbdCA/ICdjb3JlJyA6ICdjaGVja2JveCddLnNlbGVjdGVkLnB1c2gocC5pZCk7XFxuXFxuICAgICAgICAgICAgICAgIHRtcCA9IHRoaXMuZ2V0X25vZGUocCwgdHJ1ZSk7XFxuXFxuICAgICAgICAgICAgICAgIGlmICh0bXAgJiYgdG1wLmxlbmd0aCkge1xcbiAgICAgICAgICAgICAgICAgIHRtcC5hdHRyKCdhcmlhLXNlbGVjdGVkJywgdHJ1ZSkuY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuYWRkQ2xhc3ModCA/ICdqc3RyZWUtY2xpY2tlZCcgOiAnanN0cmVlLWNoZWNrZWQnKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICBwID0gdGhpcy5nZXRfbm9kZShwLnBhcmVudCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHAgPSBuZXdfcGFyO1xcblxcbiAgICAgICAgICB3aGlsZSAocCAmJiBwLmlkICE9PSAkLmpzdHJlZS5yb290KSB7XFxuICAgICAgICAgICAgYyA9IDA7XFxuXFxuICAgICAgICAgICAgZm9yIChpID0gMCwgaiA9IHAuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICAgICAgICBjICs9IG1bcC5jaGlsZHJlbltpXV0uc3RhdGVbdCA/ICdzZWxlY3RlZCcgOiAnY2hlY2tlZCddO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpZiAoYyA9PT0gaikge1xcbiAgICAgICAgICAgICAgaWYgKCFwLnN0YXRlW3QgPyAnc2VsZWN0ZWQnIDogJ2NoZWNrZWQnXSkge1xcbiAgICAgICAgICAgICAgICBwLnN0YXRlW3QgPyAnc2VsZWN0ZWQnIDogJ2NoZWNrZWQnXSA9IHRydWU7XFxuXFxuICAgICAgICAgICAgICAgIHRoaXMuX2RhdGFbdCA/ICdjb3JlJyA6ICdjaGVja2JveCddLnNlbGVjdGVkLnB1c2gocC5pZCk7XFxuXFxuICAgICAgICAgICAgICAgIHRtcCA9IHRoaXMuZ2V0X25vZGUocCwgdHJ1ZSk7XFxuXFxuICAgICAgICAgICAgICAgIGlmICh0bXAgJiYgdG1wLmxlbmd0aCkge1xcbiAgICAgICAgICAgICAgICAgIHRtcC5hdHRyKCdhcmlhLXNlbGVjdGVkJywgdHJ1ZSkuY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuYWRkQ2xhc3ModCA/ICdqc3RyZWUtY2xpY2tlZCcgOiAnanN0cmVlLWNoZWNrZWQnKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICBpZiAocC5zdGF0ZVt0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJ10pIHtcXG4gICAgICAgICAgICAgICAgcC5zdGF0ZVt0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJ10gPSBmYWxzZTtcXG4gICAgICAgICAgICAgICAgdGhpcy5fZGF0YVt0ID8gJ2NvcmUnIDogJ2NoZWNrYm94J10uc2VsZWN0ZWQgPSAkLnZha2F0YS5hcnJheV9yZW1vdmVfaXRlbSh0aGlzLl9kYXRhW3QgPyAnY29yZScgOiAnY2hlY2tib3gnXS5zZWxlY3RlZCwgcC5pZCk7XFxuICAgICAgICAgICAgICAgIHRtcCA9IHRoaXMuZ2V0X25vZGUocCwgdHJ1ZSk7XFxuXFxuICAgICAgICAgICAgICAgIGlmICh0bXAgJiYgdG1wLmxlbmd0aCkge1xcbiAgICAgICAgICAgICAgICAgIHRtcC5hdHRyKCdhcmlhLXNlbGVjdGVkJywgZmFsc2UpLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLnJlbW92ZUNsYXNzKHQgPyAnanN0cmVlLWNsaWNrZWQnIDogJ2pzdHJlZS1jaGVja2VkJyk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBwID0gdGhpcy5nZXRfbm9kZShwLnBhcmVudCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0sIHRoaXMpKTtcXG4gICAgICB9XFxuICAgIH07XFxuICAgIC8qKlxcbiAgICAgKiBzZXQgdGhlIHVuZGV0ZXJtaW5lZCBzdGF0ZSB3aGVyZSBhbmQgaWYgbmVjZXNzYXJ5LiBVc2VkIGludGVybmFsbHkuXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqIEBuYW1lIF91bmRldGVybWluZWQoKVxcbiAgICAgKiBAcGx1Z2luIGNoZWNrYm94XFxuICAgICAqL1xcblxcblxcbiAgICB0aGlzLl91bmRldGVybWluZWQgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgaWYgKHRoaXMuZWxlbWVudCA9PT0gbnVsbCkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgaSxcXG4gICAgICAgICAgaixcXG4gICAgICAgICAgayxcXG4gICAgICAgICAgbCxcXG4gICAgICAgICAgbyA9IHt9LFxcbiAgICAgICAgICBtID0gdGhpcy5fbW9kZWwuZGF0YSxcXG4gICAgICAgICAgdCA9IHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbixcXG4gICAgICAgICAgcyA9IHRoaXMuX2RhdGFbdCA/ICdjb3JlJyA6ICdjaGVja2JveCddLnNlbGVjdGVkLFxcbiAgICAgICAgICBwID0gW10sXFxuICAgICAgICAgIHR0ID0gdGhpcztcXG5cXG4gICAgICBmb3IgKGkgPSAwLCBqID0gcy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG4gICAgICAgIGlmIChtW3NbaV1dICYmIG1bc1tpXV0ucGFyZW50cykge1xcbiAgICAgICAgICBmb3IgKGsgPSAwLCBsID0gbVtzW2ldXS5wYXJlbnRzLmxlbmd0aDsgayA8IGw7IGsrKykge1xcbiAgICAgICAgICAgIGlmIChvW21bc1tpXV0ucGFyZW50c1trXV0gIT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmIChtW3NbaV1dLnBhcmVudHNba10gIT09ICQuanN0cmVlLnJvb3QpIHtcXG4gICAgICAgICAgICAgIG9bbVtzW2ldXS5wYXJlbnRzW2tdXSA9IHRydWU7XFxuICAgICAgICAgICAgICBwLnB1c2gobVtzW2ldXS5wYXJlbnRzW2tdKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9IC8vIGF0dGVtcHQgZm9yIHNlcnZlciBzaWRlIHVuZGV0ZXJtaW5lZCBzdGF0ZVxcblxcblxcbiAgICAgIHRoaXMuZWxlbWVudC5maW5kKCcuanN0cmVlLWNsb3NlZCcpLm5vdCgnOmhhcyguanN0cmVlLWNoaWxkcmVuKScpLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIHRtcCA9IHR0LmdldF9ub2RlKHRoaXMpLFxcbiAgICAgICAgICAgIHRtcDI7XFxuXFxuICAgICAgICBpZiAoIXRtcC5zdGF0ZS5sb2FkZWQpIHtcXG4gICAgICAgICAgaWYgKHRtcC5vcmlnaW5hbCAmJiB0bXAub3JpZ2luYWwuc3RhdGUgJiYgdG1wLm9yaWdpbmFsLnN0YXRlLnVuZGV0ZXJtaW5lZCAmJiB0bXAub3JpZ2luYWwuc3RhdGUudW5kZXRlcm1pbmVkID09PSB0cnVlKSB7XFxuICAgICAgICAgICAgaWYgKG9bdG1wLmlkXSA9PT0gdW5kZWZpbmVkICYmIHRtcC5pZCAhPT0gJC5qc3RyZWUucm9vdCkge1xcbiAgICAgICAgICAgICAgb1t0bXAuaWRdID0gdHJ1ZTtcXG4gICAgICAgICAgICAgIHAucHVzaCh0bXAuaWQpO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBmb3IgKGsgPSAwLCBsID0gdG1wLnBhcmVudHMubGVuZ3RoOyBrIDwgbDsgaysrKSB7XFxuICAgICAgICAgICAgICBpZiAob1t0bXAucGFyZW50c1trXV0gPT09IHVuZGVmaW5lZCAmJiB0bXAucGFyZW50c1trXSAhPT0gJC5qc3RyZWUucm9vdCkge1xcbiAgICAgICAgICAgICAgICBvW3RtcC5wYXJlbnRzW2tdXSA9IHRydWU7XFxuICAgICAgICAgICAgICAgIHAucHVzaCh0bXAucGFyZW50c1trXSk7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBmb3IgKGkgPSAwLCBqID0gdG1wLmNoaWxkcmVuX2QubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICAgICAgdG1wMiA9IG1bdG1wLmNoaWxkcmVuX2RbaV1dO1xcblxcbiAgICAgICAgICAgIGlmICghdG1wMi5zdGF0ZS5sb2FkZWQgJiYgdG1wMi5vcmlnaW5hbCAmJiB0bXAyLm9yaWdpbmFsLnN0YXRlICYmIHRtcDIub3JpZ2luYWwuc3RhdGUudW5kZXRlcm1pbmVkICYmIHRtcDIub3JpZ2luYWwuc3RhdGUudW5kZXRlcm1pbmVkID09PSB0cnVlKSB7XFxuICAgICAgICAgICAgICBpZiAob1t0bXAyLmlkXSA9PT0gdW5kZWZpbmVkICYmIHRtcDIuaWQgIT09ICQuanN0cmVlLnJvb3QpIHtcXG4gICAgICAgICAgICAgICAgb1t0bXAyLmlkXSA9IHRydWU7XFxuICAgICAgICAgICAgICAgIHAucHVzaCh0bXAyLmlkKTtcXG4gICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgIGZvciAoayA9IDAsIGwgPSB0bXAyLnBhcmVudHMubGVuZ3RoOyBrIDwgbDsgaysrKSB7XFxuICAgICAgICAgICAgICAgIGlmIChvW3RtcDIucGFyZW50c1trXV0gPT09IHVuZGVmaW5lZCAmJiB0bXAyLnBhcmVudHNba10gIT09ICQuanN0cmVlLnJvb3QpIHtcXG4gICAgICAgICAgICAgICAgICBvW3RtcDIucGFyZW50c1trXV0gPSB0cnVlO1xcbiAgICAgICAgICAgICAgICAgIHAucHVzaCh0bXAyLnBhcmVudHNba10pO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgICAgdGhpcy5lbGVtZW50LmZpbmQoJy5qc3RyZWUtdW5kZXRlcm1pbmVkJykucmVtb3ZlQ2xhc3MoJ2pzdHJlZS11bmRldGVybWluZWQnKTtcXG5cXG4gICAgICBmb3IgKGkgPSAwLCBqID0gcC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG4gICAgICAgIGlmICghbVtwW2ldXS5zdGF0ZVt0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJ10pIHtcXG4gICAgICAgICAgcyA9IHRoaXMuZ2V0X25vZGUocFtpXSwgdHJ1ZSk7XFxuXFxuICAgICAgICAgIGlmIChzICYmIHMubGVuZ3RoKSB7XFxuICAgICAgICAgICAgcy5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5jaGlsZHJlbignLmpzdHJlZS1jaGVja2JveCcpLmFkZENsYXNzKCdqc3RyZWUtdW5kZXRlcm1pbmVkJyk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH07XFxuXFxuICAgIHRoaXMucmVkcmF3X25vZGUgPSBmdW5jdGlvbiAob2JqLCBkZWVwLCBpc19jYWxsYmFjaywgZm9yY2VfcmVuZGVyKSB7XFxuICAgICAgb2JqID0gcGFyZW50LnJlZHJhd19ub2RlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuXFxuICAgICAgaWYgKG9iaikge1xcbiAgICAgICAgdmFyIGksXFxuICAgICAgICAgICAgaixcXG4gICAgICAgICAgICB0bXAgPSBudWxsLFxcbiAgICAgICAgICAgIGljb24gPSBudWxsO1xcblxcbiAgICAgICAgZm9yIChpID0gMCwgaiA9IG9iai5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcbiAgICAgICAgICBpZiAob2JqLmNoaWxkTm9kZXNbaV0gJiYgb2JqLmNoaWxkTm9kZXNbaV0uY2xhc3NOYW1lICYmIG9iai5jaGlsZE5vZGVzW2ldLmNsYXNzTmFtZS5pbmRleE9mKFxcXCJqc3RyZWUtYW5jaG9yXFxcIikgIT09IC0xKSB7XFxuICAgICAgICAgICAgdG1wID0gb2JqLmNoaWxkTm9kZXNbaV07XFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICh0bXApIHtcXG4gICAgICAgICAgaWYgKCF0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb24gJiYgdGhpcy5fbW9kZWwuZGF0YVtvYmouaWRdLnN0YXRlLmNoZWNrZWQpIHtcXG4gICAgICAgICAgICB0bXAuY2xhc3NOYW1lICs9ICcganN0cmVlLWNoZWNrZWQnO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGljb24gPSBfaS5jbG9uZU5vZGUoZmFsc2UpO1xcblxcbiAgICAgICAgICBpZiAodGhpcy5fbW9kZWwuZGF0YVtvYmouaWRdLnN0YXRlLmNoZWNrYm94X2Rpc2FibGVkKSB7XFxuICAgICAgICAgICAgaWNvbi5jbGFzc05hbWUgKz0gJyBqc3RyZWUtY2hlY2tib3gtZGlzYWJsZWQnO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHRtcC5pbnNlcnRCZWZvcmUoaWNvbiwgdG1wLmNoaWxkTm9kZXNbMF0pO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIWlzX2NhbGxiYWNrICYmIHRoaXMuc2V0dGluZ3MuY2hlY2tib3guY2FzY2FkZS5pbmRleE9mKCd1bmRldGVybWluZWQnKSAhPT0gLTEpIHtcXG4gICAgICAgIGlmICh0aGlzLl9kYXRhLmNoZWNrYm94LnV0bykge1xcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fZGF0YS5jaGVja2JveC51dG8pO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdGhpcy5fZGF0YS5jaGVja2JveC51dG8gPSBzZXRUaW1lb3V0KCQucHJveHkodGhpcy5fdW5kZXRlcm1pbmVkLCB0aGlzKSwgNTApO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gb2JqO1xcbiAgICB9O1xcbiAgICAvKipcXG4gICAgICogc2hvdyB0aGUgbm9kZSBjaGVja2JveCBpY29uc1xcbiAgICAgKiBAbmFtZSBzaG93X2NoZWNrYm94ZXMoKVxcbiAgICAgKiBAcGx1Z2luIGNoZWNrYm94XFxuICAgICAqL1xcblxcblxcbiAgICB0aGlzLnNob3dfY2hlY2tib3hlcyA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICB0aGlzLl9kYXRhLmNvcmUudGhlbWVzLmNoZWNrYm94ZXMgPSB0cnVlO1xcbiAgICAgIHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpLnJlbW92ZUNsYXNzKFxcXCJqc3RyZWUtbm8tY2hlY2tib3hlc1xcXCIpO1xcbiAgICB9O1xcbiAgICAvKipcXG4gICAgICogaGlkZSB0aGUgbm9kZSBjaGVja2JveCBpY29uc1xcbiAgICAgKiBAbmFtZSBoaWRlX2NoZWNrYm94ZXMoKVxcbiAgICAgKiBAcGx1Z2luIGNoZWNrYm94XFxuICAgICAqL1xcblxcblxcbiAgICB0aGlzLmhpZGVfY2hlY2tib3hlcyA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICB0aGlzLl9kYXRhLmNvcmUudGhlbWVzLmNoZWNrYm94ZXMgPSBmYWxzZTtcXG4gICAgICB0aGlzLmdldF9jb250YWluZXJfdWwoKS5hZGRDbGFzcyhcXFwianN0cmVlLW5vLWNoZWNrYm94ZXNcXFwiKTtcXG4gICAgfTtcXG4gICAgLyoqXFxuICAgICAqIHRvZ2dsZSB0aGUgbm9kZSBpY29uc1xcbiAgICAgKiBAbmFtZSB0b2dnbGVfY2hlY2tib3hlcygpXFxuICAgICAqIEBwbHVnaW4gY2hlY2tib3hcXG4gICAgICovXFxuXFxuXFxuICAgIHRoaXMudG9nZ2xlX2NoZWNrYm94ZXMgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgaWYgKHRoaXMuX2RhdGEuY29yZS50aGVtZXMuY2hlY2tib3hlcykge1xcbiAgICAgICAgdGhpcy5oaWRlX2NoZWNrYm94ZXMoKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdGhpcy5zaG93X2NoZWNrYm94ZXMoKTtcXG4gICAgICB9XFxuICAgIH07XFxuICAgIC8qKlxcbiAgICAgKiBjaGVja3MgaWYgYSBub2RlIGlzIGluIGFuIHVuZGV0ZXJtaW5lZCBzdGF0ZVxcbiAgICAgKiBAbmFtZSBpc191bmRldGVybWluZWQob2JqKVxcbiAgICAgKiBAcGFyYW0gIHttaXhlZH0gb2JqXFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XFxuICAgICAqL1xcblxcblxcbiAgICB0aGlzLmlzX3VuZGV0ZXJtaW5lZCA9IGZ1bmN0aW9uIChvYmopIHtcXG4gICAgICBvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XFxuICAgICAgdmFyIHMgPSB0aGlzLnNldHRpbmdzLmNoZWNrYm94LmNhc2NhZGUsXFxuICAgICAgICAgIGksXFxuICAgICAgICAgIGosXFxuICAgICAgICAgIHQgPSB0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb24sXFxuICAgICAgICAgIGQgPSB0aGlzLl9kYXRhW3QgPyAnY29yZScgOiAnY2hlY2tib3gnXS5zZWxlY3RlZCxcXG4gICAgICAgICAgbSA9IHRoaXMuX21vZGVsLmRhdGE7XFxuXFxuICAgICAgaWYgKCFvYmogfHwgb2JqLnN0YXRlW3QgPyAnc2VsZWN0ZWQnIDogJ2NoZWNrZWQnXSA9PT0gdHJ1ZSB8fCBzLmluZGV4T2YoJ3VuZGV0ZXJtaW5lZCcpID09PSAtMSB8fCBzLmluZGV4T2YoJ2Rvd24nKSA9PT0gLTEgJiYgcy5pbmRleE9mKCd1cCcpID09PSAtMSkge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIW9iai5zdGF0ZS5sb2FkZWQgJiYgb2JqLm9yaWdpbmFsLnN0YXRlLnVuZGV0ZXJtaW5lZCA9PT0gdHJ1ZSkge1xcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgfVxcblxcbiAgICAgIGZvciAoaSA9IDAsIGogPSBvYmouY2hpbGRyZW5fZC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG4gICAgICAgIGlmICgkLmluQXJyYXkob2JqLmNoaWxkcmVuX2RbaV0sIGQpICE9PSAtMSB8fCAhbVtvYmouY2hpbGRyZW5fZFtpXV0uc3RhdGUubG9hZGVkICYmIG1bb2JqLmNoaWxkcmVuX2RbaV1dLm9yaWdpbmFsLnN0YXRlLnVuZGV0ZXJtaW5lZCkge1xcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9O1xcbiAgICAvKipcXG4gICAgICogZGlzYWJsZSBhIG5vZGUncyBjaGVja2JveFxcbiAgICAgKiBAbmFtZSBkaXNhYmxlX2NoZWNrYm94KG9iailcXG4gICAgICogQHBhcmFtIHttaXhlZH0gb2JqIGFuIGFycmF5IGNhbiBiZSB1c2VkIHRvb1xcbiAgICAgKiBAdHJpZ2dlciBkaXNhYmxlX2NoZWNrYm94LmpzdHJlZVxcbiAgICAgKiBAcGx1Z2luIGNoZWNrYm94XFxuICAgICAqL1xcblxcblxcbiAgICB0aGlzLmRpc2FibGVfY2hlY2tib3ggPSBmdW5jdGlvbiAob2JqKSB7XFxuICAgICAgdmFyIHQxLCB0MiwgZG9tO1xcblxcbiAgICAgIGlmICgkLmlzQXJyYXkob2JqKSkge1xcbiAgICAgICAgb2JqID0gb2JqLnNsaWNlKCk7XFxuXFxuICAgICAgICBmb3IgKHQxID0gMCwgdDIgPSBvYmoubGVuZ3RoOyB0MSA8IHQyOyB0MSsrKSB7XFxuICAgICAgICAgIHRoaXMuZGlzYWJsZV9jaGVja2JveChvYmpbdDFdKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgIH1cXG5cXG4gICAgICBvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XFxuXFxuICAgICAgaWYgKCFvYmogfHwgb2JqLmlkID09PSAkLmpzdHJlZS5yb290KSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcblxcbiAgICAgIGRvbSA9IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKTtcXG5cXG4gICAgICBpZiAoIW9iai5zdGF0ZS5jaGVja2JveF9kaXNhYmxlZCkge1xcbiAgICAgICAgb2JqLnN0YXRlLmNoZWNrYm94X2Rpc2FibGVkID0gdHJ1ZTtcXG5cXG4gICAgICAgIGlmIChkb20gJiYgZG9tLmxlbmd0aCkge1xcbiAgICAgICAgICBkb20uY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuY2hpbGRyZW4oJy5qc3RyZWUtY2hlY2tib3gnKS5hZGRDbGFzcygnanN0cmVlLWNoZWNrYm94LWRpc2FibGVkJyk7XFxuICAgICAgICB9XFxuICAgICAgICAvKipcXG4gICAgICAgICAqIHRyaWdnZXJlZCB3aGVuIGFuIG5vZGUncyBjaGVja2JveCBpcyBkaXNhYmxlZFxcbiAgICAgICAgICogQGV2ZW50XFxuICAgICAgICAgKiBAbmFtZSBkaXNhYmxlX2NoZWNrYm94LmpzdHJlZVxcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGVcXG4gICAgICAgICAqIEBwbHVnaW4gY2hlY2tib3hcXG4gICAgICAgICAqL1xcblxcblxcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdkaXNhYmxlX2NoZWNrYm94Jywge1xcbiAgICAgICAgICAnbm9kZSc6IG9ialxcbiAgICAgICAgfSk7XFxuICAgICAgfVxcbiAgICB9O1xcbiAgICAvKipcXG4gICAgICogZW5hYmxlIGEgbm9kZSdzIGNoZWNrYm94XFxuICAgICAqIEBuYW1lIGRpc2FibGVfY2hlY2tib3gob2JqKVxcbiAgICAgKiBAcGFyYW0ge21peGVkfSBvYmogYW4gYXJyYXkgY2FuIGJlIHVzZWQgdG9vXFxuICAgICAqIEB0cmlnZ2VyIGVuYWJsZV9jaGVja2JveC5qc3RyZWVcXG4gICAgICogQHBsdWdpbiBjaGVja2JveFxcbiAgICAgKi9cXG5cXG5cXG4gICAgdGhpcy5lbmFibGVfY2hlY2tib3ggPSBmdW5jdGlvbiAob2JqKSB7XFxuICAgICAgdmFyIHQxLCB0MiwgZG9tO1xcblxcbiAgICAgIGlmICgkLmlzQXJyYXkob2JqKSkge1xcbiAgICAgICAgb2JqID0gb2JqLnNsaWNlKCk7XFxuXFxuICAgICAgICBmb3IgKHQxID0gMCwgdDIgPSBvYmoubGVuZ3RoOyB0MSA8IHQyOyB0MSsrKSB7XFxuICAgICAgICAgIHRoaXMuZW5hYmxlX2NoZWNrYm94KG9ialt0MV0pO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgfVxcblxcbiAgICAgIG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXG4gICAgICBpZiAoIW9iaiB8fCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgZG9tID0gdGhpcy5nZXRfbm9kZShvYmosIHRydWUpO1xcblxcbiAgICAgIGlmIChvYmouc3RhdGUuY2hlY2tib3hfZGlzYWJsZWQpIHtcXG4gICAgICAgIG9iai5zdGF0ZS5jaGVja2JveF9kaXNhYmxlZCA9IGZhbHNlO1xcblxcbiAgICAgICAgaWYgKGRvbSAmJiBkb20ubGVuZ3RoKSB7XFxuICAgICAgICAgIGRvbS5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5jaGlsZHJlbignLmpzdHJlZS1jaGVja2JveCcpLnJlbW92ZUNsYXNzKCdqc3RyZWUtY2hlY2tib3gtZGlzYWJsZWQnKTtcXG4gICAgICAgIH1cXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogdHJpZ2dlcmVkIHdoZW4gYW4gbm9kZSdzIGNoZWNrYm94IGlzIGVuYWJsZWRcXG4gICAgICAgICAqIEBldmVudFxcbiAgICAgICAgICogQG5hbWUgZW5hYmxlX2NoZWNrYm94LmpzdHJlZVxcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGVcXG4gICAgICAgICAqIEBwbHVnaW4gY2hlY2tib3hcXG4gICAgICAgICAqL1xcblxcblxcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdlbmFibGVfY2hlY2tib3gnLCB7XFxuICAgICAgICAgICdub2RlJzogb2JqXFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuICAgIH07XFxuXFxuICAgIHRoaXMuYWN0aXZhdGVfbm9kZSA9IGZ1bmN0aW9uIChvYmosIGUpIHtcXG4gICAgICBpZiAoJChlLnRhcmdldCkuaGFzQ2xhc3MoJ2pzdHJlZS1jaGVja2JveC1kaXNhYmxlZCcpKSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb24gJiYgKHRoaXMuc2V0dGluZ3MuY2hlY2tib3gud2hvbGVfbm9kZSB8fCAkKGUudGFyZ2V0KS5oYXNDbGFzcygnanN0cmVlLWNoZWNrYm94JykpKSB7XFxuICAgICAgICBlLmN0cmxLZXkgPSB0cnVlO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uIHx8ICF0aGlzLnNldHRpbmdzLmNoZWNrYm94Lndob2xlX25vZGUgJiYgISQoZS50YXJnZXQpLmhhc0NsYXNzKCdqc3RyZWUtY2hlY2tib3gnKSkge1xcbiAgICAgICAgcmV0dXJuIHBhcmVudC5hY3RpdmF0ZV9ub2RlLmNhbGwodGhpcywgb2JqLCBlKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMuaXNfZGlzYWJsZWQob2JqKSkge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5pc19jaGVja2VkKG9iaikpIHtcXG4gICAgICAgIHRoaXMudW5jaGVja19ub2RlKG9iaiwgZSk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRoaXMuY2hlY2tfbm9kZShvYmosIGUpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLnRyaWdnZXIoJ2FjdGl2YXRlX25vZGUnLCB7XFxuICAgICAgICAnbm9kZSc6IHRoaXMuZ2V0X25vZGUob2JqKVxcbiAgICAgIH0pO1xcbiAgICB9O1xcbiAgICAvKipcXG4gICAgICogY2hlY2sgYSBub2RlIChvbmx5IGlmIHRpZV9zZWxlY3Rpb24gaW4gY2hlY2tib3ggc2V0dGluZ3MgaXMgZmFsc2UsIG90aGVyd2lzZSBzZWxlY3Rfbm9kZSB3aWxsIGJlIGNhbGxlZCBpbnRlcm5hbGx5KVxcbiAgICAgKiBAbmFtZSBjaGVja19ub2RlKG9iailcXG4gICAgICogQHBhcmFtIHttaXhlZH0gb2JqIGFuIGFycmF5IGNhbiBiZSB1c2VkIHRvIGNoZWNrIG11bHRpcGxlIG5vZGVzXFxuICAgICAqIEB0cmlnZ2VyIGNoZWNrX25vZGUuanN0cmVlXFxuICAgICAqIEBwbHVnaW4gY2hlY2tib3hcXG4gICAgICovXFxuXFxuXFxuICAgIHRoaXMuY2hlY2tfbm9kZSA9IGZ1bmN0aW9uIChvYmosIGUpIHtcXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rfbm9kZShvYmosIGZhbHNlLCB0cnVlLCBlKTtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIGRvbSwgdDEsIHQyLCB0aDtcXG5cXG4gICAgICBpZiAoJC5pc0FycmF5KG9iaikpIHtcXG4gICAgICAgIG9iaiA9IG9iai5zbGljZSgpO1xcblxcbiAgICAgICAgZm9yICh0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xcbiAgICAgICAgICB0aGlzLmNoZWNrX25vZGUob2JqW3QxXSwgZSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICB9XFxuXFxuICAgICAgb2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xcblxcbiAgICAgIGlmICghb2JqIHx8IG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCkge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICBkb20gPSB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSk7XFxuXFxuICAgICAgaWYgKCFvYmouc3RhdGUuY2hlY2tlZCkge1xcbiAgICAgICAgb2JqLnN0YXRlLmNoZWNrZWQgPSB0cnVlO1xcblxcbiAgICAgICAgdGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZC5wdXNoKG9iai5pZCk7XFxuXFxuICAgICAgICBpZiAoZG9tICYmIGRvbS5sZW5ndGgpIHtcXG4gICAgICAgICAgZG9tLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLmFkZENsYXNzKCdqc3RyZWUtY2hlY2tlZCcpO1xcbiAgICAgICAgfVxcbiAgICAgICAgLyoqXFxuICAgICAgICAgKiB0cmlnZ2VyZWQgd2hlbiBhbiBub2RlIGlzIGNoZWNrZWQgKG9ubHkgaWYgdGllX3NlbGVjdGlvbiBpbiBjaGVja2JveCBzZXR0aW5ncyBpcyBmYWxzZSlcXG4gICAgICAgICAqIEBldmVudFxcbiAgICAgICAgICogQG5hbWUgY2hlY2tfbm9kZS5qc3RyZWVcXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlXFxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBzZWxlY3RlZCB0aGUgY3VycmVudCBzZWxlY3Rpb25cXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCB0aGUgZXZlbnQgKGlmIGFueSkgdGhhdCB0cmlnZ2VyZWQgdGhpcyBjaGVja19ub2RlXFxuICAgICAgICAgKiBAcGx1Z2luIGNoZWNrYm94XFxuICAgICAgICAgKi9cXG5cXG5cXG4gICAgICAgIHRoaXMudHJpZ2dlcignY2hlY2tfbm9kZScsIHtcXG4gICAgICAgICAgJ25vZGUnOiBvYmosXFxuICAgICAgICAgICdzZWxlY3RlZCc6IHRoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWQsXFxuICAgICAgICAgICdldmVudCc6IGVcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG4gICAgfTtcXG4gICAgLyoqXFxuICAgICAqIHVuY2hlY2sgYSBub2RlIChvbmx5IGlmIHRpZV9zZWxlY3Rpb24gaW4gY2hlY2tib3ggc2V0dGluZ3MgaXMgZmFsc2UsIG90aGVyd2lzZSBkZXNlbGVjdF9ub2RlIHdpbGwgYmUgY2FsbGVkIGludGVybmFsbHkpXFxuICAgICAqIEBuYW1lIHVuY2hlY2tfbm9kZShvYmopXFxuICAgICAqIEBwYXJhbSB7bWl4ZWR9IG9iaiBhbiBhcnJheSBjYW4gYmUgdXNlZCB0byB1bmNoZWNrIG11bHRpcGxlIG5vZGVzXFxuICAgICAqIEB0cmlnZ2VyIHVuY2hlY2tfbm9kZS5qc3RyZWVcXG4gICAgICogQHBsdWdpbiBjaGVja2JveFxcbiAgICAgKi9cXG5cXG5cXG4gICAgdGhpcy51bmNoZWNrX25vZGUgPSBmdW5jdGlvbiAob2JqLCBlKSB7XFxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbikge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVzZWxlY3Rfbm9kZShvYmosIGZhbHNlLCBlKTtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIHQxLCB0MiwgZG9tO1xcblxcbiAgICAgIGlmICgkLmlzQXJyYXkob2JqKSkge1xcbiAgICAgICAgb2JqID0gb2JqLnNsaWNlKCk7XFxuXFxuICAgICAgICBmb3IgKHQxID0gMCwgdDIgPSBvYmoubGVuZ3RoOyB0MSA8IHQyOyB0MSsrKSB7XFxuICAgICAgICAgIHRoaXMudW5jaGVja19ub2RlKG9ialt0MV0sIGUpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgfVxcblxcbiAgICAgIG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXG4gICAgICBpZiAoIW9iaiB8fCBvYmouaWQgPT09ICQuanN0cmVlLnJvb3QpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgZG9tID0gdGhpcy5nZXRfbm9kZShvYmosIHRydWUpO1xcblxcbiAgICAgIGlmIChvYmouc3RhdGUuY2hlY2tlZCkge1xcbiAgICAgICAgb2JqLnN0YXRlLmNoZWNrZWQgPSBmYWxzZTtcXG4gICAgICAgIHRoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWQgPSAkLnZha2F0YS5hcnJheV9yZW1vdmVfaXRlbSh0aGlzLl9kYXRhLmNoZWNrYm94LnNlbGVjdGVkLCBvYmouaWQpO1xcblxcbiAgICAgICAgaWYgKGRvbS5sZW5ndGgpIHtcXG4gICAgICAgICAgZG9tLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLnJlbW92ZUNsYXNzKCdqc3RyZWUtY2hlY2tlZCcpO1xcbiAgICAgICAgfVxcbiAgICAgICAgLyoqXFxuICAgICAgICAgKiB0cmlnZ2VyZWQgd2hlbiBhbiBub2RlIGlzIHVuY2hlY2tlZCAob25seSBpZiB0aWVfc2VsZWN0aW9uIGluIGNoZWNrYm94IHNldHRpbmdzIGlzIGZhbHNlKVxcbiAgICAgICAgICogQGV2ZW50XFxuICAgICAgICAgKiBAbmFtZSB1bmNoZWNrX25vZGUuanN0cmVlXFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZVxcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gc2VsZWN0ZWQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uXFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgdGhlIGV2ZW50IChpZiBhbnkpIHRoYXQgdHJpZ2dlcmVkIHRoaXMgdW5jaGVja19ub2RlXFxuICAgICAgICAgKiBAcGx1Z2luIGNoZWNrYm94XFxuICAgICAgICAgKi9cXG5cXG5cXG4gICAgICAgIHRoaXMudHJpZ2dlcigndW5jaGVja19ub2RlJywge1xcbiAgICAgICAgICAnbm9kZSc6IG9iaixcXG4gICAgICAgICAgJ3NlbGVjdGVkJzogdGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZCxcXG4gICAgICAgICAgJ2V2ZW50JzogZVxcbiAgICAgICAgfSk7XFxuICAgICAgfVxcbiAgICB9O1xcbiAgICAvKipcXG4gICAgICogY2hlY2tzIGFsbCBub2RlcyBpbiB0aGUgdHJlZSAob25seSBpZiB0aWVfc2VsZWN0aW9uIGluIGNoZWNrYm94IHNldHRpbmdzIGlzIGZhbHNlLCBvdGhlcndpc2Ugc2VsZWN0X2FsbCB3aWxsIGJlIGNhbGxlZCBpbnRlcm5hbGx5KVxcbiAgICAgKiBAbmFtZSBjaGVja19hbGwoKVxcbiAgICAgKiBAdHJpZ2dlciBjaGVja19hbGwuanN0cmVlLCBjaGFuZ2VkLmpzdHJlZVxcbiAgICAgKiBAcGx1Z2luIGNoZWNrYm94XFxuICAgICAqL1xcblxcblxcbiAgICB0aGlzLmNoZWNrX2FsbCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RfYWxsKCk7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciB0bXAgPSB0aGlzLl9kYXRhLmNoZWNrYm94LnNlbGVjdGVkLmNvbmNhdChbXSksXFxuICAgICAgICAgIGksXFxuICAgICAgICAgIGo7XFxuXFxuICAgICAgdGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZCA9IHRoaXMuX21vZGVsLmRhdGFbJC5qc3RyZWUucm9vdF0uY2hpbGRyZW5fZC5jb25jYXQoKTtcXG5cXG4gICAgICBmb3IgKGkgPSAwLCBqID0gdGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG4gICAgICAgIGlmICh0aGlzLl9tb2RlbC5kYXRhW3RoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWRbaV1dKSB7XFxuICAgICAgICAgIHRoaXMuX21vZGVsLmRhdGFbdGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZFtpXV0uc3RhdGUuY2hlY2tlZCA9IHRydWU7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMucmVkcmF3KHRydWUpO1xcbiAgICAgIC8qKlxcbiAgICAgICAqIHRyaWdnZXJlZCB3aGVuIGFsbCBub2RlcyBhcmUgY2hlY2tlZCAob25seSBpZiB0aWVfc2VsZWN0aW9uIGluIGNoZWNrYm94IHNldHRpbmdzIGlzIGZhbHNlKVxcbiAgICAgICAqIEBldmVudFxcbiAgICAgICAqIEBuYW1lIGNoZWNrX2FsbC5qc3RyZWVcXG4gICAgICAgKiBAcGFyYW0ge0FycmF5fSBzZWxlY3RlZCB0aGUgY3VycmVudCBzZWxlY3Rpb25cXG4gICAgICAgKiBAcGx1Z2luIGNoZWNrYm94XFxuICAgICAgICovXFxuXFxuICAgICAgdGhpcy50cmlnZ2VyKCdjaGVja19hbGwnLCB7XFxuICAgICAgICAnc2VsZWN0ZWQnOiB0aGlzLl9kYXRhLmNoZWNrYm94LnNlbGVjdGVkXFxuICAgICAgfSk7XFxuICAgIH07XFxuICAgIC8qKlxcbiAgICAgKiB1bmNoZWNrIGFsbCBjaGVja2VkIG5vZGVzIChvbmx5IGlmIHRpZV9zZWxlY3Rpb24gaW4gY2hlY2tib3ggc2V0dGluZ3MgaXMgZmFsc2UsIG90aGVyd2lzZSBkZXNlbGVjdF9hbGwgd2lsbCBiZSBjYWxsZWQgaW50ZXJuYWxseSlcXG4gICAgICogQG5hbWUgdW5jaGVja19hbGwoKVxcbiAgICAgKiBAdHJpZ2dlciB1bmNoZWNrX2FsbC5qc3RyZWVcXG4gICAgICogQHBsdWdpbiBjaGVja2JveFxcbiAgICAgKi9cXG5cXG5cXG4gICAgdGhpcy51bmNoZWNrX2FsbCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5kZXNlbGVjdF9hbGwoKTtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIHRtcCA9IHRoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWQuY29uY2F0KFtdKSxcXG4gICAgICAgICAgaSxcXG4gICAgICAgICAgajtcXG5cXG4gICAgICBmb3IgKGkgPSAwLCBqID0gdGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG4gICAgICAgIGlmICh0aGlzLl9tb2RlbC5kYXRhW3RoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWRbaV1dKSB7XFxuICAgICAgICAgIHRoaXMuX21vZGVsLmRhdGFbdGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZFtpXV0uc3RhdGUuY2hlY2tlZCA9IGZhbHNlO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9kYXRhLmNoZWNrYm94LnNlbGVjdGVkID0gW107XFxuICAgICAgdGhpcy5lbGVtZW50LmZpbmQoJy5qc3RyZWUtY2hlY2tlZCcpLnJlbW92ZUNsYXNzKCdqc3RyZWUtY2hlY2tlZCcpO1xcbiAgICAgIC8qKlxcbiAgICAgICAqIHRyaWdnZXJlZCB3aGVuIGFsbCBub2RlcyBhcmUgdW5jaGVja2VkIChvbmx5IGlmIHRpZV9zZWxlY3Rpb24gaW4gY2hlY2tib3ggc2V0dGluZ3MgaXMgZmFsc2UpXFxuICAgICAgICogQGV2ZW50XFxuICAgICAgICogQG5hbWUgdW5jaGVja19hbGwuanN0cmVlXFxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGUgdGhlIHByZXZpb3VzIHNlbGVjdGlvblxcbiAgICAgICAqIEBwYXJhbSB7QXJyYXl9IHNlbGVjdGVkIHRoZSBjdXJyZW50IHNlbGVjdGlvblxcbiAgICAgICAqIEBwbHVnaW4gY2hlY2tib3hcXG4gICAgICAgKi9cXG5cXG4gICAgICB0aGlzLnRyaWdnZXIoJ3VuY2hlY2tfYWxsJywge1xcbiAgICAgICAgJ3NlbGVjdGVkJzogdGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZCxcXG4gICAgICAgICdub2RlJzogdG1wXFxuICAgICAgfSk7XFxuICAgIH07XFxuICAgIC8qKlxcbiAgICAgKiBjaGVja3MgaWYgYSBub2RlIGlzIGNoZWNrZWQgKGlmIHRpZV9zZWxlY3Rpb24gaXMgb24gaW4gdGhlIHNldHRpbmdzIHRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gdGhlIHNhbWUgYXMgaXNfc2VsZWN0ZWQpXFxuICAgICAqIEBuYW1lIGlzX2NoZWNrZWQob2JqKVxcbiAgICAgKiBAcGFyYW0gIHttaXhlZH0gIG9ialxcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxcbiAgICAgKiBAcGx1Z2luIGNoZWNrYm94XFxuICAgICAqL1xcblxcblxcbiAgICB0aGlzLmlzX2NoZWNrZWQgPSBmdW5jdGlvbiAob2JqKSB7XFxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbikge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNfc2VsZWN0ZWQob2JqKTtcXG4gICAgICB9XFxuXFxuICAgICAgb2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xcblxcbiAgICAgIGlmICghb2JqIHx8IG9iai5pZCA9PT0gJC5qc3RyZWUucm9vdCkge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gb2JqLnN0YXRlLmNoZWNrZWQ7XFxuICAgIH07XFxuICAgIC8qKlxcbiAgICAgKiBnZXQgYW4gYXJyYXkgb2YgYWxsIGNoZWNrZWQgbm9kZXMgKGlmIHRpZV9zZWxlY3Rpb24gaXMgb24gaW4gdGhlIHNldHRpbmdzIHRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gdGhlIHNhbWUgYXMgZ2V0X3NlbGVjdGVkKVxcbiAgICAgKiBAbmFtZSBnZXRfY2hlY2tlZChbZnVsbF0pXFxuICAgICAqIEBwYXJhbSAge21peGVkfSAgZnVsbCBpZiBzZXQgdG8gYHRydWVgIHRoZSByZXR1cm5lZCBhcnJheSB3aWxsIGNvbnNpc3Qgb2YgdGhlIGZ1bGwgbm9kZSBvYmplY3RzLCBvdGhlcndpc2UgLSBvbmx5IElEcyB3aWxsIGJlIHJldHVybmVkXFxuICAgICAqIEByZXR1cm4ge0FycmF5fVxcbiAgICAgKiBAcGx1Z2luIGNoZWNrYm94XFxuICAgICAqL1xcblxcblxcbiAgICB0aGlzLmdldF9jaGVja2VkID0gZnVuY3Rpb24gKGZ1bGwpIHtcXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5nZXRfc2VsZWN0ZWQoZnVsbCk7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBmdWxsID8gJC5tYXAodGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZCwgJC5wcm94eShmdW5jdGlvbiAoaSkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0X25vZGUoaSk7XFxuICAgICAgfSwgdGhpcykpIDogdGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZDtcXG4gICAgfTtcXG4gICAgLyoqXFxuICAgICAqIGdldCBhbiBhcnJheSBvZiBhbGwgdG9wIGxldmVsIGNoZWNrZWQgbm9kZXMgKGlnbm9yaW5nIGNoaWxkcmVuIG9mIGNoZWNrZWQgbm9kZXMpIChpZiB0aWVfc2VsZWN0aW9uIGlzIG9uIGluIHRoZSBzZXR0aW5ncyB0aGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSBzYW1lIGFzIGdldF90b3Bfc2VsZWN0ZWQpXFxuICAgICAqIEBuYW1lIGdldF90b3BfY2hlY2tlZChbZnVsbF0pXFxuICAgICAqIEBwYXJhbSAge21peGVkfSAgZnVsbCBpZiBzZXQgdG8gYHRydWVgIHRoZSByZXR1cm5lZCBhcnJheSB3aWxsIGNvbnNpc3Qgb2YgdGhlIGZ1bGwgbm9kZSBvYmplY3RzLCBvdGhlcndpc2UgLSBvbmx5IElEcyB3aWxsIGJlIHJldHVybmVkXFxuICAgICAqIEByZXR1cm4ge0FycmF5fVxcbiAgICAgKiBAcGx1Z2luIGNoZWNrYm94XFxuICAgICAqL1xcblxcblxcbiAgICB0aGlzLmdldF90b3BfY2hlY2tlZCA9IGZ1bmN0aW9uIChmdWxsKSB7XFxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbikge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0X3RvcF9zZWxlY3RlZChmdWxsKTtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIHRtcCA9IHRoaXMuZ2V0X2NoZWNrZWQodHJ1ZSksXFxuICAgICAgICAgIG9iaiA9IHt9LFxcbiAgICAgICAgICBpLFxcbiAgICAgICAgICBqLFxcbiAgICAgICAgICBrLFxcbiAgICAgICAgICBsO1xcblxcbiAgICAgIGZvciAoaSA9IDAsIGogPSB0bXAubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICBvYmpbdG1wW2ldLmlkXSA9IHRtcFtpXTtcXG4gICAgICB9XFxuXFxuICAgICAgZm9yIChpID0gMCwgaiA9IHRtcC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG4gICAgICAgIGZvciAoayA9IDAsIGwgPSB0bXBbaV0uY2hpbGRyZW5fZC5sZW5ndGg7IGsgPCBsOyBrKyspIHtcXG4gICAgICAgICAgaWYgKG9ialt0bXBbaV0uY2hpbGRyZW5fZFtrXV0pIHtcXG4gICAgICAgICAgICBkZWxldGUgb2JqW3RtcFtpXS5jaGlsZHJlbl9kW2tdXTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICB0bXAgPSBbXTtcXG5cXG4gICAgICBmb3IgKGkgaW4gb2JqKSB7XFxuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGkpKSB7XFxuICAgICAgICAgIHRtcC5wdXNoKGkpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gZnVsbCA/ICQubWFwKHRtcCwgJC5wcm94eShmdW5jdGlvbiAoaSkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0X25vZGUoaSk7XFxuICAgICAgfSwgdGhpcykpIDogdG1wO1xcbiAgICB9O1xcbiAgICAvKipcXG4gICAgICogZ2V0IGFuIGFycmF5IG9mIGFsbCBib3R0b20gbGV2ZWwgY2hlY2tlZCBub2RlcyAoaWdub3Jpbmcgc2VsZWN0ZWQgcGFyZW50cykgKGlmIHRpZV9zZWxlY3Rpb24gaXMgb24gaW4gdGhlIHNldHRpbmdzIHRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gdGhlIHNhbWUgYXMgZ2V0X2JvdHRvbV9zZWxlY3RlZClcXG4gICAgICogQG5hbWUgZ2V0X2JvdHRvbV9jaGVja2VkKFtmdWxsXSlcXG4gICAgICogQHBhcmFtICB7bWl4ZWR9ICBmdWxsIGlmIHNldCB0byBgdHJ1ZWAgdGhlIHJldHVybmVkIGFycmF5IHdpbGwgY29uc2lzdCBvZiB0aGUgZnVsbCBub2RlIG9iamVjdHMsIG90aGVyd2lzZSAtIG9ubHkgSURzIHdpbGwgYmUgcmV0dXJuZWRcXG4gICAgICogQHJldHVybiB7QXJyYXl9XFxuICAgICAqIEBwbHVnaW4gY2hlY2tib3hcXG4gICAgICovXFxuXFxuXFxuICAgIHRoaXMuZ2V0X2JvdHRvbV9jaGVja2VkID0gZnVuY3Rpb24gKGZ1bGwpIHtcXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5nZXRfYm90dG9tX3NlbGVjdGVkKGZ1bGwpO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgdG1wID0gdGhpcy5nZXRfY2hlY2tlZCh0cnVlKSxcXG4gICAgICAgICAgb2JqID0gW10sXFxuICAgICAgICAgIGksXFxuICAgICAgICAgIGo7XFxuXFxuICAgICAgZm9yIChpID0gMCwgaiA9IHRtcC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG4gICAgICAgIGlmICghdG1wW2ldLmNoaWxkcmVuLmxlbmd0aCkge1xcbiAgICAgICAgICBvYmoucHVzaCh0bXBbaV0uaWQpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gZnVsbCA/ICQubWFwKG9iaiwgJC5wcm94eShmdW5jdGlvbiAoaSkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0X25vZGUoaSk7XFxuICAgICAgfSwgdGhpcykpIDogb2JqO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLmxvYWRfbm9kZSA9IGZ1bmN0aW9uIChvYmosIGNhbGxiYWNrKSB7XFxuICAgICAgdmFyIGssIGwsIGksIGosIGMsIHRtcDtcXG5cXG4gICAgICBpZiAoISQuaXNBcnJheShvYmopICYmICF0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb24pIHtcXG4gICAgICAgIHRtcCA9IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXG4gICAgICAgIGlmICh0bXAgJiYgdG1wLnN0YXRlLmxvYWRlZCkge1xcbiAgICAgICAgICBmb3IgKGsgPSAwLCBsID0gdG1wLmNoaWxkcmVuX2QubGVuZ3RoOyBrIDwgbDsgaysrKSB7XFxuICAgICAgICAgICAgaWYgKHRoaXMuX21vZGVsLmRhdGFbdG1wLmNoaWxkcmVuX2Rba11dLnN0YXRlLmNoZWNrZWQpIHtcXG4gICAgICAgICAgICAgIGMgPSB0cnVlO1xcbiAgICAgICAgICAgICAgdGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZCA9ICQudmFrYXRhLmFycmF5X3JlbW92ZV9pdGVtKHRoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWQsIHRtcC5jaGlsZHJlbl9kW2tdKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHBhcmVudC5sb2FkX25vZGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5nZXRfc3RhdGUgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgdmFyIHN0YXRlID0gcGFyZW50LmdldF9zdGF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcblxcbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb24pIHtcXG4gICAgICAgIHJldHVybiBzdGF0ZTtcXG4gICAgICB9XFxuXFxuICAgICAgc3RhdGUuY2hlY2tib3ggPSB0aGlzLl9kYXRhLmNoZWNrYm94LnNlbGVjdGVkLnNsaWNlKCk7XFxuICAgICAgcmV0dXJuIHN0YXRlO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLnNldF9zdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgY2FsbGJhY2spIHtcXG4gICAgICB2YXIgcmVzID0gcGFyZW50LnNldF9zdGF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcblxcbiAgICAgIGlmIChyZXMgJiYgc3RhdGUuY2hlY2tib3gpIHtcXG4gICAgICAgIGlmICghdGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uKSB7XFxuICAgICAgICAgIHRoaXMudW5jaGVja19hbGwoKTtcXG5cXG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcXG5cXG4gICAgICAgICAgJC5lYWNoKHN0YXRlLmNoZWNrYm94LCBmdW5jdGlvbiAoaSwgdikge1xcbiAgICAgICAgICAgIF90aGlzLmNoZWNrX25vZGUodik7XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZGVsZXRlIHN0YXRlLmNoZWNrYm94O1xcbiAgICAgICAgdGhpcy5zZXRfc3RhdGUoc3RhdGUsIGNhbGxiYWNrKTtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHJlcztcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5yZWZyZXNoID0gZnVuY3Rpb24gKHNraXBfbG9hZGluZywgZm9yZ2V0X3N0YXRlKSB7XFxuICAgICAgaWYgKCF0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb24pIHtcXG4gICAgICAgIHRoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWQgPSBbXTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHBhcmVudC5yZWZyZXNoLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICAgIH07XFxuICB9OyAvLyBpbmNsdWRlIHRoZSBjaGVja2JveCBwbHVnaW4gYnkgZGVmYXVsdFxcbiAgLy8gJC5qc3RyZWUuZGVmYXVsdHMucGx1Z2lucy5wdXNoKFxcXCJjaGVja2JveFxcXCIpO1xcblxcbiAgLyoqXFxuICAgKiAjIyMgQ29uZGl0aW9uYWxzZWxlY3QgcGx1Z2luXFxuICAgKlxcbiAgICogVGhpcyBwbHVnaW4gYWxsb3dzIGRlZmluaW5nIGEgY2FsbGJhY2sgdG8gYWxsb3cgb3IgZGVueSBub2RlIHNlbGVjdGlvbiBieSB1c2VyIGlucHV0IChhY3RpdmF0ZSBub2RlIG1ldGhvZCkuXFxuICAgKi9cXG5cXG4gIC8qKlxcbiAgICogYSBjYWxsYmFjayAoZnVuY3Rpb24pIHdoaWNoIGlzIGludm9rZWQgaW4gdGhlIGluc3RhbmNlJ3Mgc2NvcGUgYW5kIHJlY2VpdmVzIHR3byBhcmd1bWVudHMgLSB0aGUgbm9kZSBhbmQgdGhlIGV2ZW50IHRoYXQgdHJpZ2dlcmVkIHRoZSBgYWN0aXZhdGVfbm9kZWAgY2FsbC4gUmV0dXJuaW5nIGZhbHNlIHByZXZlbnRzIHdvcmtpbmcgd2l0aCB0aGUgbm9kZSwgcmV0dXJuaW5nIHRydWUgYWxsb3dzIGludm9raW5nIGFjdGl2YXRlX25vZGUuIERlZmF1bHRzIHRvIHJldHVybmluZyBgdHJ1ZWAuXFxuICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jaGVja2JveC52aXNpYmxlXFxuICAgKiBAcGx1Z2luIGNoZWNrYm94XFxuICAgKi9cXG5cXG5cXG4gICQuanN0cmVlLmRlZmF1bHRzLmNvbmRpdGlvbmFsc2VsZWN0ID0gZnVuY3Rpb24gKCkge1xcbiAgICByZXR1cm4gdHJ1ZTtcXG4gIH07XFxuXFxuICAkLmpzdHJlZS5wbHVnaW5zLmNvbmRpdGlvbmFsc2VsZWN0ID0gZnVuY3Rpb24gKG9wdGlvbnMsIHBhcmVudCkge1xcbiAgICAvLyBvd24gZnVuY3Rpb25cXG4gICAgdGhpcy5hY3RpdmF0ZV9ub2RlID0gZnVuY3Rpb24gKG9iaiwgZSkge1xcbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLmNvbmRpdGlvbmFsc2VsZWN0LmNhbGwodGhpcywgdGhpcy5nZXRfbm9kZShvYmopLCBlKSkge1xcbiAgICAgICAgcGFyZW50LmFjdGl2YXRlX25vZGUuY2FsbCh0aGlzLCBvYmosIGUpO1xcbiAgICAgIH1cXG4gICAgfTtcXG4gIH07XFxuICAvKipcXG4gICAqICMjIyBDb250ZXh0bWVudSBwbHVnaW5cXG4gICAqXFxuICAgKiBTaG93cyBhIGNvbnRleHQgbWVudSB3aGVuIGEgbm9kZSBpcyByaWdodC1jbGlja2VkLlxcbiAgICovXFxuXFxuICAvKipcXG4gICAqIHN0b3JlcyBhbGwgZGVmYXVsdHMgZm9yIHRoZSBjb250ZXh0bWVudSBwbHVnaW5cXG4gICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvbnRleHRtZW51XFxuICAgKiBAcGx1Z2luIGNvbnRleHRtZW51XFxuICAgKi9cXG5cXG5cXG4gICQuanN0cmVlLmRlZmF1bHRzLmNvbnRleHRtZW51ID0ge1xcbiAgICAvKipcXG4gICAgICogYSBib29sZWFuIGluZGljYXRpbmcgaWYgdGhlIG5vZGUgc2hvdWxkIGJlIHNlbGVjdGVkIHdoZW4gdGhlIGNvbnRleHQgbWVudSBpcyBpbnZva2VkIG9uIGl0LiBEZWZhdWx0cyB0byBgdHJ1ZWAuXFxuICAgICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvbnRleHRtZW51LnNlbGVjdF9ub2RlXFxuICAgICAqIEBwbHVnaW4gY29udGV4dG1lbnVcXG4gICAgICovXFxuICAgIHNlbGVjdF9ub2RlOiB0cnVlLFxcblxcbiAgICAvKipcXG4gICAgICogYSBib29sZWFuIGluZGljYXRpbmcgaWYgdGhlIG1lbnUgc2hvdWxkIGJlIHNob3duIGFsaWduZWQgd2l0aCB0aGUgbm9kZS4gRGVmYXVsdHMgdG8gYHRydWVgLCBvdGhlcndpc2UgdGhlIG1vdXNlIGNvb3JkaW5hdGVzIGFyZSB1c2VkLlxcbiAgICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb250ZXh0bWVudS5zaG93X2F0X25vZGVcXG4gICAgICogQHBsdWdpbiBjb250ZXh0bWVudVxcbiAgICAgKi9cXG4gICAgc2hvd19hdF9ub2RlOiB0cnVlLFxcblxcbiAgICAvKipcXG4gICAgICogYW4gb2JqZWN0IG9mIGFjdGlvbnMsIG9yIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIGEgbm9kZSBhbmQgYSBjYWxsYmFjayBmdW5jdGlvbiBhbmQgY2FsbHMgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdpdGggYW4gb2JqZWN0IG9mIGFjdGlvbnMgYXZhaWxhYmxlIGZvciB0aGF0IG5vZGUgKHlvdSBjYW4gYWxzbyByZXR1cm4gdGhlIGl0ZW1zIHRvbykuXFxuICAgICAqXFxuICAgICAqIEVhY2ggYWN0aW9uIGNvbnNpc3RzIG9mIGEga2V5IChhIHVuaXF1ZSBuYW1lKSBhbmQgYSB2YWx1ZSB3aGljaCBpcyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXMgKG9ubHkgbGFiZWwgYW5kIGFjdGlvbiBhcmUgcmVxdWlyZWQpLiBPbmNlIGEgbWVudSBpdGVtIGlzIGFjdGl2YXRlZCB0aGUgYGFjdGlvbmAgZnVuY3Rpb24gd2lsbCBiZSBpbnZva2VkIHdpdGggYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGZvbGxvd2luZyBrZXlzOiBpdGVtIC0gdGhlIGNvbnRleHRtZW51IGl0ZW0gZGVmaW5pdGlvbiBhcyBzZWVuIGJlbG93LCByZWZlcmVuY2UgLSB0aGUgRE9NIG5vZGUgdGhhdCB3YXMgdXNlZCAodGhlIHRyZWUgbm9kZSksIGVsZW1lbnQgLSB0aGUgY29udGV4dG1lbnUgRE9NIGVsZW1lbnQsIHBvc2l0aW9uIC0gYW4gb2JqZWN0IHdpdGggeC95IHByb3BlcnRpZXMgaW5kaWNhdGluZyB0aGUgcG9zaXRpb24gb2YgdGhlIG1lbnUuXFxuICAgICAqXFxuICAgICAqICogYHNlcGFyYXRvcl9iZWZvcmVgIC0gYSBib29sZWFuIGluZGljYXRpbmcgaWYgdGhlcmUgc2hvdWxkIGJlIGEgc2VwYXJhdG9yIGJlZm9yZSB0aGlzIGl0ZW1cXG4gICAgICogKiBgc2VwYXJhdG9yX2FmdGVyYCAtIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoZXJlIHNob3VsZCBiZSBhIHNlcGFyYXRvciBhZnRlciB0aGlzIGl0ZW1cXG4gICAgICogKiBgX2Rpc2FibGVkYCAtIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoaXMgYWN0aW9uIHNob3VsZCBiZSBkaXNhYmxlZFxcbiAgICAgKiAqIGBsYWJlbGAgLSBhIHN0cmluZyAtIHRoZSBuYW1lIG9mIHRoZSBhY3Rpb24gKGNvdWxkIGJlIGEgZnVuY3Rpb24gcmV0dXJuaW5nIGEgc3RyaW5nKVxcbiAgICAgKiAqIGB0aXRsZWAgLSBhIHN0cmluZyAtIGFuIG9wdGlvbmFsIHRvb2x0aXAgZm9yIHRoZSBpdGVtXFxuICAgICAqICogYGFjdGlvbmAgLSBhIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIGlmIHRoaXMgaXRlbSBpcyBjaG9zZW4sIHRoZSBmdW5jdGlvbiB3aWxsIHJlY2VpdmUgXFxuICAgICAqICogYGljb25gIC0gYSBzdHJpbmcsIGNhbiBiZSBhIHBhdGggdG8gYW4gaWNvbiBvciBhIGNsYXNzTmFtZSwgaWYgdXNpbmcgYW4gaW1hZ2UgdGhhdCBpcyBpbiB0aGUgY3VycmVudCBkaXJlY3RvcnkgdXNlIGEgYC4vYCBwcmVmaXgsIG90aGVyd2lzZSBpdCB3aWxsIGJlIGRldGVjdGVkIGFzIGEgY2xhc3NcXG4gICAgICogKiBgc2hvcnRjdXRgIC0ga2V5Q29kZSB3aGljaCB3aWxsIHRyaWdnZXIgdGhlIGFjdGlvbiBpZiB0aGUgbWVudSBpcyBvcGVuIChmb3IgZXhhbXBsZSBgMTEzYCBmb3IgcmVuYW1lLCB3aGljaCBlcXVhbHMgRjIpXFxuICAgICAqICogYHNob3J0Y3V0X2xhYmVsYCAtIHNob3J0Y3V0IGxhYmVsIChsaWtlIGZvciBleGFtcGxlIGBGMmAgZm9yIHJlbmFtZSlcXG4gICAgICogKiBgc3VibWVudWAgLSBhbiBvYmplY3Qgd2l0aCB0aGUgc2FtZSBzdHJ1Y3R1cmUgYXMgJC5qc3RyZWUuZGVmYXVsdHMuY29udGV4dG1lbnUuaXRlbXMgd2hpY2ggY2FuIGJlIHVzZWQgdG8gY3JlYXRlIGEgc3VibWVudSAtIGVhY2gga2V5IHdpbGwgYmUgcmVuZGVyZWQgYXMgYSBzZXBhcmF0ZSBvcHRpb24gaW4gYSBzdWJtZW51IHRoYXQgd2lsbCBhcHBlYXIgb25jZSB0aGUgY3VycmVudCBpdGVtIGlzIGhvdmVyZWRcXG4gICAgICpcXG4gICAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY29udGV4dG1lbnUuaXRlbXNcXG4gICAgICogQHBsdWdpbiBjb250ZXh0bWVudVxcbiAgICAgKi9cXG4gICAgaXRlbXM6IGZ1bmN0aW9uIGl0ZW1zKG8sIGNiKSB7XFxuICAgICAgLy8gQ291bGQgYmUgYW4gb2JqZWN0IGRpcmVjdGx5XFxuICAgICAgcmV0dXJuIHtcXG4gICAgICAgIFxcXCJjcmVhdGVcXFwiOiB7XFxuICAgICAgICAgIFxcXCJzZXBhcmF0b3JfYmVmb3JlXFxcIjogZmFsc2UsXFxuICAgICAgICAgIFxcXCJzZXBhcmF0b3JfYWZ0ZXJcXFwiOiB0cnVlLFxcbiAgICAgICAgICBcXFwiX2Rpc2FibGVkXFxcIjogZmFsc2UsXFxuICAgICAgICAgIC8vKHRoaXMuY2hlY2soXFxcImNyZWF0ZV9ub2RlXFxcIiwgZGF0YS5yZWZlcmVuY2UsIHt9LCBcXFwibGFzdFxcXCIpKSxcXG4gICAgICAgICAgXFxcImxhYmVsXFxcIjogXFxcIkNyZWF0ZVxcXCIsXFxuICAgICAgICAgIFxcXCJhY3Rpb25cXFwiOiBmdW5jdGlvbiBhY3Rpb24oZGF0YSkge1xcbiAgICAgICAgICAgIHZhciBpbnN0ID0gJC5qc3RyZWUucmVmZXJlbmNlKGRhdGEucmVmZXJlbmNlKSxcXG4gICAgICAgICAgICAgICAgb2JqID0gaW5zdC5nZXRfbm9kZShkYXRhLnJlZmVyZW5jZSk7XFxuICAgICAgICAgICAgaW5zdC5jcmVhdGVfbm9kZShvYmosIHt9LCBcXFwibGFzdFxcXCIsIGZ1bmN0aW9uIChuZXdfbm9kZSkge1xcbiAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgIGluc3QuZWRpdChuZXdfbm9kZSk7XFxuICAgICAgICAgICAgICB9LCAwKTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSxcXG4gICAgICAgIFxcXCJyZW5hbWVcXFwiOiB7XFxuICAgICAgICAgIFxcXCJzZXBhcmF0b3JfYmVmb3JlXFxcIjogZmFsc2UsXFxuICAgICAgICAgIFxcXCJzZXBhcmF0b3JfYWZ0ZXJcXFwiOiBmYWxzZSxcXG4gICAgICAgICAgXFxcIl9kaXNhYmxlZFxcXCI6IGZhbHNlLFxcbiAgICAgICAgICAvLyh0aGlzLmNoZWNrKFxcXCJyZW5hbWVfbm9kZVxcXCIsIGRhdGEucmVmZXJlbmNlLCB0aGlzLmdldF9wYXJlbnQoZGF0YS5yZWZlcmVuY2UpLCBcXFwiXFxcIikpLFxcbiAgICAgICAgICBcXFwibGFiZWxcXFwiOiBcXFwiUmVuYW1lXFxcIixcXG5cXG4gICAgICAgICAgLyohXFxuICAgICAgICAgIFxcXCJzaG9ydGN1dFxcXCJcXHRcXHRcXHQ6IDExMyxcXG4gICAgICAgICAgXFxcInNob3J0Y3V0X2xhYmVsXFxcIlxcdDogJ0YyJyxcXG4gICAgICAgICAgXFxcImljb25cXFwiXFx0XFx0XFx0XFx0OiBcXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1sZWFmXFxcIixcXG4gICAgICAgICAgKi9cXG4gICAgICAgICAgXFxcImFjdGlvblxcXCI6IGZ1bmN0aW9uIGFjdGlvbihkYXRhKSB7XFxuICAgICAgICAgICAgdmFyIGluc3QgPSAkLmpzdHJlZS5yZWZlcmVuY2UoZGF0YS5yZWZlcmVuY2UpLFxcbiAgICAgICAgICAgICAgICBvYmogPSBpbnN0LmdldF9ub2RlKGRhdGEucmVmZXJlbmNlKTtcXG4gICAgICAgICAgICBpbnN0LmVkaXQob2JqKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSxcXG4gICAgICAgIFxcXCJyZW1vdmVcXFwiOiB7XFxuICAgICAgICAgIFxcXCJzZXBhcmF0b3JfYmVmb3JlXFxcIjogZmFsc2UsXFxuICAgICAgICAgIFxcXCJpY29uXFxcIjogZmFsc2UsXFxuICAgICAgICAgIFxcXCJzZXBhcmF0b3JfYWZ0ZXJcXFwiOiBmYWxzZSxcXG4gICAgICAgICAgXFxcIl9kaXNhYmxlZFxcXCI6IGZhbHNlLFxcbiAgICAgICAgICAvLyh0aGlzLmNoZWNrKFxcXCJkZWxldGVfbm9kZVxcXCIsIGRhdGEucmVmZXJlbmNlLCB0aGlzLmdldF9wYXJlbnQoZGF0YS5yZWZlcmVuY2UpLCBcXFwiXFxcIikpLFxcbiAgICAgICAgICBcXFwibGFiZWxcXFwiOiBcXFwiRGVsZXRlXFxcIixcXG4gICAgICAgICAgXFxcImFjdGlvblxcXCI6IGZ1bmN0aW9uIGFjdGlvbihkYXRhKSB7XFxuICAgICAgICAgICAgdmFyIGluc3QgPSAkLmpzdHJlZS5yZWZlcmVuY2UoZGF0YS5yZWZlcmVuY2UpLFxcbiAgICAgICAgICAgICAgICBvYmogPSBpbnN0LmdldF9ub2RlKGRhdGEucmVmZXJlbmNlKTtcXG5cXG4gICAgICAgICAgICBpZiAoaW5zdC5pc19zZWxlY3RlZChvYmopKSB7XFxuICAgICAgICAgICAgICBpbnN0LmRlbGV0ZV9ub2RlKGluc3QuZ2V0X3NlbGVjdGVkKCkpO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICBpbnN0LmRlbGV0ZV9ub2RlKG9iaik7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgXFxcImNjcFxcXCI6IHtcXG4gICAgICAgICAgXFxcInNlcGFyYXRvcl9iZWZvcmVcXFwiOiB0cnVlLFxcbiAgICAgICAgICBcXFwiaWNvblxcXCI6IGZhbHNlLFxcbiAgICAgICAgICBcXFwic2VwYXJhdG9yX2FmdGVyXFxcIjogZmFsc2UsXFxuICAgICAgICAgIFxcXCJsYWJlbFxcXCI6IFxcXCJFZGl0XFxcIixcXG4gICAgICAgICAgXFxcImFjdGlvblxcXCI6IGZhbHNlLFxcbiAgICAgICAgICBcXFwic3VibWVudVxcXCI6IHtcXG4gICAgICAgICAgICBcXFwiY3V0XFxcIjoge1xcbiAgICAgICAgICAgICAgXFxcInNlcGFyYXRvcl9iZWZvcmVcXFwiOiBmYWxzZSxcXG4gICAgICAgICAgICAgIFxcXCJzZXBhcmF0b3JfYWZ0ZXJcXFwiOiBmYWxzZSxcXG4gICAgICAgICAgICAgIFxcXCJsYWJlbFxcXCI6IFxcXCJDdXRcXFwiLFxcbiAgICAgICAgICAgICAgXFxcImFjdGlvblxcXCI6IGZ1bmN0aW9uIGFjdGlvbihkYXRhKSB7XFxuICAgICAgICAgICAgICAgIHZhciBpbnN0ID0gJC5qc3RyZWUucmVmZXJlbmNlKGRhdGEucmVmZXJlbmNlKSxcXG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IGluc3QuZ2V0X25vZGUoZGF0YS5yZWZlcmVuY2UpO1xcblxcbiAgICAgICAgICAgICAgICBpZiAoaW5zdC5pc19zZWxlY3RlZChvYmopKSB7XFxuICAgICAgICAgICAgICAgICAgaW5zdC5jdXQoaW5zdC5nZXRfdG9wX3NlbGVjdGVkKCkpO1xcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgIGluc3QuY3V0KG9iaik7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIFxcXCJjb3B5XFxcIjoge1xcbiAgICAgICAgICAgICAgXFxcInNlcGFyYXRvcl9iZWZvcmVcXFwiOiBmYWxzZSxcXG4gICAgICAgICAgICAgIFxcXCJpY29uXFxcIjogZmFsc2UsXFxuICAgICAgICAgICAgICBcXFwic2VwYXJhdG9yX2FmdGVyXFxcIjogZmFsc2UsXFxuICAgICAgICAgICAgICBcXFwibGFiZWxcXFwiOiBcXFwiQ29weVxcXCIsXFxuICAgICAgICAgICAgICBcXFwiYWN0aW9uXFxcIjogZnVuY3Rpb24gYWN0aW9uKGRhdGEpIHtcXG4gICAgICAgICAgICAgICAgdmFyIGluc3QgPSAkLmpzdHJlZS5yZWZlcmVuY2UoZGF0YS5yZWZlcmVuY2UpLFxcbiAgICAgICAgICAgICAgICAgICAgb2JqID0gaW5zdC5nZXRfbm9kZShkYXRhLnJlZmVyZW5jZSk7XFxuXFxuICAgICAgICAgICAgICAgIGlmIChpbnN0LmlzX3NlbGVjdGVkKG9iaikpIHtcXG4gICAgICAgICAgICAgICAgICBpbnN0LmNvcHkoaW5zdC5nZXRfdG9wX3NlbGVjdGVkKCkpO1xcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgIGluc3QuY29weShvYmopO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICBcXFwicGFzdGVcXFwiOiB7XFxuICAgICAgICAgICAgICBcXFwic2VwYXJhdG9yX2JlZm9yZVxcXCI6IGZhbHNlLFxcbiAgICAgICAgICAgICAgXFxcImljb25cXFwiOiBmYWxzZSxcXG4gICAgICAgICAgICAgIFxcXCJfZGlzYWJsZWRcXFwiOiBmdW5jdGlvbiBfZGlzYWJsZWQoZGF0YSkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gISQuanN0cmVlLnJlZmVyZW5jZShkYXRhLnJlZmVyZW5jZSkuY2FuX3Bhc3RlKCk7XFxuICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgXFxcInNlcGFyYXRvcl9hZnRlclxcXCI6IGZhbHNlLFxcbiAgICAgICAgICAgICAgXFxcImxhYmVsXFxcIjogXFxcIlBhc3RlXFxcIixcXG4gICAgICAgICAgICAgIFxcXCJhY3Rpb25cXFwiOiBmdW5jdGlvbiBhY3Rpb24oZGF0YSkge1xcbiAgICAgICAgICAgICAgICB2YXIgaW5zdCA9ICQuanN0cmVlLnJlZmVyZW5jZShkYXRhLnJlZmVyZW5jZSksXFxuICAgICAgICAgICAgICAgICAgICBvYmogPSBpbnN0LmdldF9ub2RlKGRhdGEucmVmZXJlbmNlKTtcXG4gICAgICAgICAgICAgICAgaW5zdC5wYXN0ZShvYmopO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgIH1cXG4gIH07XFxuXFxuICAkLmpzdHJlZS5wbHVnaW5zLmNvbnRleHRtZW51ID0gZnVuY3Rpb24gKG9wdGlvbnMsIHBhcmVudCkge1xcbiAgICB0aGlzLmJpbmQgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgcGFyZW50LmJpbmQuY2FsbCh0aGlzKTtcXG4gICAgICB2YXIgbGFzdF90cyA9IDAsXFxuICAgICAgICAgIGN0byA9IG51bGwsXFxuICAgICAgICAgIGV4LFxcbiAgICAgICAgICBleTtcXG4gICAgICB0aGlzLmVsZW1lbnQub24oXFxcImNvbnRleHRtZW51LmpzdHJlZVxcXCIsIFxcXCIuanN0cmVlLWFuY2hvclxcXCIsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcXG4gICAgICAgIGlmIChlLnRhcmdldC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcpIHtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgbGFzdF90cyA9IGUuY3RybEtleSA/ICtuZXcgRGF0ZSgpIDogMDtcXG5cXG4gICAgICAgIGlmIChkYXRhIHx8IGN0bykge1xcbiAgICAgICAgICBsYXN0X3RzID0gK25ldyBEYXRlKCkgKyAxMDAwMDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChjdG8pIHtcXG4gICAgICAgICAgY2xlYXJUaW1lb3V0KGN0byk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoIXRoaXMuaXNfbG9hZGluZyhlLmN1cnJlbnRUYXJnZXQpKSB7XFxuICAgICAgICAgIHRoaXMuc2hvd19jb250ZXh0bWVudShlLmN1cnJlbnRUYXJnZXQsIGUucGFnZVgsIGUucGFnZVksIGUpO1xcbiAgICAgICAgfVxcbiAgICAgIH0sIHRoaXMpKS5vbihcXFwiY2xpY2suanN0cmVlXFxcIiwgXFxcIi5qc3RyZWUtYW5jaG9yXFxcIiwgJC5wcm94eShmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgaWYgKHRoaXMuX2RhdGEuY29udGV4dG1lbnUudmlzaWJsZSAmJiAoIWxhc3RfdHMgfHwgK25ldyBEYXRlKCkgLSBsYXN0X3RzID4gMjUwKSkge1xcbiAgICAgICAgICAvLyB3b3JrIGFyb3VuZCBzYWZhcmkgJiBtYWNPUyBjdHJsK2NsaWNrXFxuICAgICAgICAgICQudmFrYXRhLmNvbnRleHQuaGlkZSgpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgbGFzdF90cyA9IDA7XFxuICAgICAgfSwgdGhpcykpLm9uKFxcXCJ0b3VjaHN0YXJ0LmpzdHJlZVxcXCIsIFxcXCIuanN0cmVlLWFuY2hvclxcXCIsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICBpZiAoIWUub3JpZ2luYWxFdmVudCB8fCAhZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzIHx8ICFlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0pIHtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZXggPSBlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WDtcXG4gICAgICAgIGV5ID0gZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFk7XFxuICAgICAgICBjdG8gPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgJChlLmN1cnJlbnRUYXJnZXQpLnRyaWdnZXIoJ2NvbnRleHRtZW51JywgdHJ1ZSk7XFxuICAgICAgICB9LCA3NTApO1xcbiAgICAgIH0pLm9uKCd0b3VjaG1vdmUudmFrYXRhLmpzdHJlZScsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICBpZiAoY3RvICYmIGUub3JpZ2luYWxFdmVudCAmJiBlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXMgJiYgZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdICYmIChNYXRoLmFicyhleCAtIGUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRYKSA+IDUwIHx8IE1hdGguYWJzKGV5IC0gZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFkpID4gNTApKSB7XFxuICAgICAgICAgIGNsZWFyVGltZW91dChjdG8pO1xcbiAgICAgICAgfVxcbiAgICAgIH0pLm9uKCd0b3VjaGVuZC52YWthdGEuanN0cmVlJywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgIGlmIChjdG8pIHtcXG4gICAgICAgICAgY2xlYXJUaW1lb3V0KGN0byk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgICAgLyohXFxuICAgICAgaWYoISgnb25jb250ZXh0bWVudScgaW4gZG9jdW1lbnQuYm9keSkgJiYgKCdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmJvZHkpKSB7XFxuICAgICAgXFx0dmFyIGVsID0gbnVsbCwgdG0gPSBudWxsO1xcbiAgICAgIFxcdHRoaXMuZWxlbWVudFxcbiAgICAgIFxcdFxcdC5vbihcXFwidG91Y2hzdGFydFxcXCIsIFxcXCIuanN0cmVlLWFuY2hvclxcXCIsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgXFx0XFx0XFx0ZWwgPSBlLmN1cnJlbnRUYXJnZXQ7XFxuICAgICAgXFx0XFx0XFx0dG0gPSArbmV3IERhdGUoKTtcXG4gICAgICBcXHRcXHRcXHQkKGRvY3VtZW50KS5vbmUoXFxcInRvdWNoZW5kXFxcIiwgZnVuY3Rpb24gKGUpIHtcXG4gICAgICBcXHRcXHRcXHRcXHRlLnRhcmdldCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoZS5vcmlnaW5hbEV2ZW50LnRhcmdldFRvdWNoZXNbMF0ucGFnZVggLSB3aW5kb3cucGFnZVhPZmZzZXQsIGUub3JpZ2luYWxFdmVudC50YXJnZXRUb3VjaGVzWzBdLnBhZ2VZIC0gd2luZG93LnBhZ2VZT2Zmc2V0KTtcXG4gICAgICBcXHRcXHRcXHRcXHRlLmN1cnJlbnRUYXJnZXQgPSBlLnRhcmdldDtcXG4gICAgICBcXHRcXHRcXHRcXHR0bSA9ICgoKyhuZXcgRGF0ZSgpKSkgLSB0bSk7XFxuICAgICAgXFx0XFx0XFx0XFx0aWYoZS50YXJnZXQgPT09IGVsICYmIHRtID4gNjAwICYmIHRtIDwgMTAwMCkge1xcbiAgICAgIFxcdFxcdFxcdFxcdFxcdGUucHJldmVudERlZmF1bHQoKTtcXG4gICAgICBcXHRcXHRcXHRcXHRcXHQkKGVsKS50cmlnZ2VyKCdjb250ZXh0bWVudScsIGUpO1xcbiAgICAgIFxcdFxcdFxcdFxcdH1cXG4gICAgICBcXHRcXHRcXHRcXHRlbCA9IG51bGw7XFxuICAgICAgXFx0XFx0XFx0XFx0dG0gPSBudWxsO1xcbiAgICAgIFxcdFxcdFxcdH0pO1xcbiAgICAgIFxcdFxcdH0pO1xcbiAgICAgIH1cXG4gICAgICAqL1xcblxcbiAgICAgICQoZG9jdW1lbnQpLm9uKFxcXCJjb250ZXh0X2hpZGUudmFrYXRhLmpzdHJlZVxcXCIsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcXG4gICAgICAgIHRoaXMuX2RhdGEuY29udGV4dG1lbnUudmlzaWJsZSA9IGZhbHNlO1xcbiAgICAgICAgJChkYXRhLnJlZmVyZW5jZSkucmVtb3ZlQ2xhc3MoJ2pzdHJlZS1jb250ZXh0Jyk7XFxuICAgICAgfSwgdGhpcykpO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLnRlYXJkb3duID0gZnVuY3Rpb24gKCkge1xcbiAgICAgIGlmICh0aGlzLl9kYXRhLmNvbnRleHRtZW51LnZpc2libGUpIHtcXG4gICAgICAgICQudmFrYXRhLmNvbnRleHQuaGlkZSgpO1xcbiAgICAgIH1cXG5cXG4gICAgICBwYXJlbnQudGVhcmRvd24uY2FsbCh0aGlzKTtcXG4gICAgfTtcXG4gICAgLyoqXFxuICAgICAqIHByZXBhcmUgYW5kIHNob3cgdGhlIGNvbnRleHQgbWVudSBmb3IgYSBub2RlXFxuICAgICAqIEBuYW1lIHNob3dfY29udGV4dG1lbnUob2JqIFssIHgsIHldKVxcbiAgICAgKiBAcGFyYW0ge21peGVkfSBvYmogdGhlIG5vZGVcXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggdGhlIHgtY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgZG9jdW1lbnQgdG8gc2hvdyB0aGUgbWVudSBhdFxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSB0aGUgeS1jb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBkb2N1bWVudCB0byBzaG93IHRoZSBtZW51IGF0XFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlIHRoZSBldmVudCBpZiBhdmFpbGFibGUgdGhhdCB0cmlnZ2VyZWQgdGhlIGNvbnRleHRtZW51XFxuICAgICAqIEBwbHVnaW4gY29udGV4dG1lbnVcXG4gICAgICogQHRyaWdnZXIgc2hvd19jb250ZXh0bWVudS5qc3RyZWVcXG4gICAgICovXFxuXFxuXFxuICAgIHRoaXMuc2hvd19jb250ZXh0bWVudSA9IGZ1bmN0aW9uIChvYmosIHgsIHksIGUpIHtcXG4gICAgICBvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XFxuXFxuICAgICAgaWYgKCFvYmogfHwgb2JqLmlkID09PSAkLmpzdHJlZS5yb290KSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBzID0gdGhpcy5zZXR0aW5ncy5jb250ZXh0bWVudSxcXG4gICAgICAgICAgZCA9IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKSxcXG4gICAgICAgICAgYSA9IGQuY2hpbGRyZW4oXFxcIi5qc3RyZWUtYW5jaG9yXFxcIiksXFxuICAgICAgICAgIG8gPSBmYWxzZSxcXG4gICAgICAgICAgaSA9IGZhbHNlO1xcblxcbiAgICAgIGlmIChzLnNob3dfYXRfbm9kZSB8fCB4ID09PSB1bmRlZmluZWQgfHwgeSA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICBvID0gYS5vZmZzZXQoKTtcXG4gICAgICAgIHggPSBvLmxlZnQ7XFxuICAgICAgICB5ID0gby50b3AgKyB0aGlzLl9kYXRhLmNvcmUubGlfaGVpZ2h0O1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5jb250ZXh0bWVudS5zZWxlY3Rfbm9kZSAmJiAhdGhpcy5pc19zZWxlY3RlZChvYmopKSB7XFxuICAgICAgICB0aGlzLmFjdGl2YXRlX25vZGUob2JqLCBlKTtcXG4gICAgICB9XFxuXFxuICAgICAgaSA9IHMuaXRlbXM7XFxuXFxuICAgICAgaWYgKCQuaXNGdW5jdGlvbihpKSkge1xcbiAgICAgICAgaSA9IGkuY2FsbCh0aGlzLCBvYmosICQucHJveHkoZnVuY3Rpb24gKGkpIHtcXG4gICAgICAgICAgdGhpcy5fc2hvd19jb250ZXh0bWVudShvYmosIHgsIHksIGkpO1xcbiAgICAgICAgfSwgdGhpcykpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoJC5pc1BsYWluT2JqZWN0KGkpKSB7XFxuICAgICAgICB0aGlzLl9zaG93X2NvbnRleHRtZW51KG9iaiwgeCwgeSwgaSk7XFxuICAgICAgfVxcbiAgICB9O1xcbiAgICAvKipcXG4gICAgICogc2hvdyB0aGUgcHJlcGFyZWQgY29udGV4dCBtZW51IGZvciBhIG5vZGVcXG4gICAgICogQG5hbWUgX3Nob3dfY29udGV4dG1lbnUob2JqLCB4LCB5LCBpKVxcbiAgICAgKiBAcGFyYW0ge21peGVkfSBvYmogdGhlIG5vZGVcXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggdGhlIHgtY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgZG9jdW1lbnQgdG8gc2hvdyB0aGUgbWVudSBhdFxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSB0aGUgeS1jb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBkb2N1bWVudCB0byBzaG93IHRoZSBtZW51IGF0XFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpIHRoZSBvYmplY3Qgb2YgaXRlbXMgdG8gc2hvd1xcbiAgICAgKiBAcGx1Z2luIGNvbnRleHRtZW51XFxuICAgICAqIEB0cmlnZ2VyIHNob3dfY29udGV4dG1lbnUuanN0cmVlXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcblxcbiAgICB0aGlzLl9zaG93X2NvbnRleHRtZW51ID0gZnVuY3Rpb24gKG9iaiwgeCwgeSwgaSkge1xcbiAgICAgIHZhciBkID0gdGhpcy5nZXRfbm9kZShvYmosIHRydWUpLFxcbiAgICAgICAgICBhID0gZC5jaGlsZHJlbihcXFwiLmpzdHJlZS1hbmNob3JcXFwiKTtcXG4gICAgICAkKGRvY3VtZW50KS5vbmUoXFxcImNvbnRleHRfc2hvdy52YWthdGEuanN0cmVlXFxcIiwgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xcbiAgICAgICAgdmFyIGNscyA9ICdqc3RyZWUtY29udGV4dG1lbnUganN0cmVlLScgKyB0aGlzLmdldF90aGVtZSgpICsgJy1jb250ZXh0bWVudSc7XFxuICAgICAgICAkKGRhdGEuZWxlbWVudCkuYWRkQ2xhc3MoY2xzKTtcXG4gICAgICAgIGEuYWRkQ2xhc3MoJ2pzdHJlZS1jb250ZXh0Jyk7XFxuICAgICAgfSwgdGhpcykpO1xcbiAgICAgIHRoaXMuX2RhdGEuY29udGV4dG1lbnUudmlzaWJsZSA9IHRydWU7XFxuICAgICAgJC52YWthdGEuY29udGV4dC5zaG93KGEsIHtcXG4gICAgICAgICd4JzogeCxcXG4gICAgICAgICd5JzogeVxcbiAgICAgIH0sIGkpO1xcbiAgICAgIC8qKlxcbiAgICAgICAqIHRyaWdnZXJlZCB3aGVuIHRoZSBjb250ZXh0bWVudSBpcyBzaG93biBmb3IgYSBub2RlXFxuICAgICAgICogQGV2ZW50XFxuICAgICAgICogQG5hbWUgc2hvd19jb250ZXh0bWVudS5qc3RyZWVcXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZSB0aGUgbm9kZVxcbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IHRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIG1lbnUgcmVsYXRpdmUgdG8gdGhlIGRvY3VtZW50XFxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgdGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgbWVudSByZWxhdGl2ZSB0byB0aGUgZG9jdW1lbnRcXG4gICAgICAgKiBAcGx1Z2luIGNvbnRleHRtZW51XFxuICAgICAgICovXFxuXFxuICAgICAgdGhpcy50cmlnZ2VyKCdzaG93X2NvbnRleHRtZW51Jywge1xcbiAgICAgICAgXFxcIm5vZGVcXFwiOiBvYmosXFxuICAgICAgICBcXFwieFxcXCI6IHgsXFxuICAgICAgICBcXFwieVxcXCI6IHlcXG4gICAgICB9KTtcXG4gICAgfTtcXG4gIH07IC8vIGNvbnRleHRtZW51IGhlbHBlclxcblxcblxcbiAgKGZ1bmN0aW9uICgkKSB7XFxuICAgIHZhciByaWdodF90b19sZWZ0ID0gZmFsc2UsXFxuICAgICAgICB2YWthdGFfY29udGV4dCA9IHtcXG4gICAgICBlbGVtZW50OiBmYWxzZSxcXG4gICAgICByZWZlcmVuY2U6IGZhbHNlLFxcbiAgICAgIHBvc2l0aW9uX3g6IDAsXFxuICAgICAgcG9zaXRpb25feTogMCxcXG4gICAgICBpdGVtczogW10sXFxuICAgICAgaHRtbDogXFxcIlxcXCIsXFxuICAgICAgaXNfdmlzaWJsZTogZmFsc2VcXG4gICAgfTtcXG4gICAgJC52YWthdGEuY29udGV4dCA9IHtcXG4gICAgICBzZXR0aW5nczoge1xcbiAgICAgICAgaGlkZV9vbm1vdXNlbGVhdmU6IDAsXFxuICAgICAgICBpY29uczogdHJ1ZVxcbiAgICAgIH0sXFxuICAgICAgX3RyaWdnZXI6IGZ1bmN0aW9uIF90cmlnZ2VyKGV2ZW50X25hbWUpIHtcXG4gICAgICAgICQoZG9jdW1lbnQpLnRyaWdnZXJIYW5kbGVyKFxcXCJjb250ZXh0X1xcXCIgKyBldmVudF9uYW1lICsgXFxcIi52YWthdGFcXFwiLCB7XFxuICAgICAgICAgIFxcXCJyZWZlcmVuY2VcXFwiOiB2YWthdGFfY29udGV4dC5yZWZlcmVuY2UsXFxuICAgICAgICAgIFxcXCJlbGVtZW50XFxcIjogdmFrYXRhX2NvbnRleHQuZWxlbWVudCxcXG4gICAgICAgICAgXFxcInBvc2l0aW9uXFxcIjoge1xcbiAgICAgICAgICAgIFxcXCJ4XFxcIjogdmFrYXRhX2NvbnRleHQucG9zaXRpb25feCxcXG4gICAgICAgICAgICBcXFwieVxcXCI6IHZha2F0YV9jb250ZXh0LnBvc2l0aW9uX3lcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgICAgfSxcXG4gICAgICBfZXhlY3V0ZTogZnVuY3Rpb24gX2V4ZWN1dGUoaSkge1xcbiAgICAgICAgaSA9IHZha2F0YV9jb250ZXh0Lml0ZW1zW2ldO1xcbiAgICAgICAgcmV0dXJuIGkgJiYgKCFpLl9kaXNhYmxlZCB8fCAkLmlzRnVuY3Rpb24oaS5fZGlzYWJsZWQpICYmICFpLl9kaXNhYmxlZCh7XFxuICAgICAgICAgIFxcXCJpdGVtXFxcIjogaSxcXG4gICAgICAgICAgXFxcInJlZmVyZW5jZVxcXCI6IHZha2F0YV9jb250ZXh0LnJlZmVyZW5jZSxcXG4gICAgICAgICAgXFxcImVsZW1lbnRcXFwiOiB2YWthdGFfY29udGV4dC5lbGVtZW50XFxuICAgICAgICB9KSkgJiYgaS5hY3Rpb24gPyBpLmFjdGlvbi5jYWxsKG51bGwsIHtcXG4gICAgICAgICAgXFxcIml0ZW1cXFwiOiBpLFxcbiAgICAgICAgICBcXFwicmVmZXJlbmNlXFxcIjogdmFrYXRhX2NvbnRleHQucmVmZXJlbmNlLFxcbiAgICAgICAgICBcXFwiZWxlbWVudFxcXCI6IHZha2F0YV9jb250ZXh0LmVsZW1lbnQsXFxuICAgICAgICAgIFxcXCJwb3NpdGlvblxcXCI6IHtcXG4gICAgICAgICAgICBcXFwieFxcXCI6IHZha2F0YV9jb250ZXh0LnBvc2l0aW9uX3gsXFxuICAgICAgICAgICAgXFxcInlcXFwiOiB2YWthdGFfY29udGV4dC5wb3NpdGlvbl95XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0pIDogZmFsc2U7XFxuICAgICAgfSxcXG4gICAgICBfcGFyc2U6IGZ1bmN0aW9uIF9wYXJzZShvLCBpc19jYWxsYmFjaykge1xcbiAgICAgICAgaWYgKCFvKSB7XFxuICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICghaXNfY2FsbGJhY2spIHtcXG4gICAgICAgICAgdmFrYXRhX2NvbnRleHQuaHRtbCA9IFxcXCJcXFwiO1xcbiAgICAgICAgICB2YWthdGFfY29udGV4dC5pdGVtcyA9IFtdO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdmFyIHN0ciA9IFxcXCJcXFwiLFxcbiAgICAgICAgICAgIHNlcCA9IGZhbHNlLFxcbiAgICAgICAgICAgIHRtcDtcXG5cXG4gICAgICAgIGlmIChpc19jYWxsYmFjaykge1xcbiAgICAgICAgICBzdHIgKz0gXFxcIjxcXFwiICsgXFxcInVsPlxcXCI7XFxuICAgICAgICB9XFxuXFxuICAgICAgICAkLmVhY2gobywgZnVuY3Rpb24gKGksIHZhbCkge1xcbiAgICAgICAgICBpZiAoIXZhbCkge1xcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHZha2F0YV9jb250ZXh0Lml0ZW1zLnB1c2godmFsKTtcXG5cXG4gICAgICAgICAgaWYgKCFzZXAgJiYgdmFsLnNlcGFyYXRvcl9iZWZvcmUpIHtcXG4gICAgICAgICAgICBzdHIgKz0gXFxcIjxcXFwiICsgXFxcImxpIGNsYXNzPSd2YWthdGEtY29udGV4dC1zZXBhcmF0b3InPjxcXFwiICsgXFxcImEgaHJlZj0nIycgXFxcIiArICgkLnZha2F0YS5jb250ZXh0LnNldHRpbmdzLmljb25zID8gJycgOiAnc3R5bGU9XFxcIm1hcmdpbi1sZWZ0OjBweDtcXFwiJykgKyBcXFwiPiYjMTYwOzxcXFwiICsgXFxcIi9hPjxcXFwiICsgXFxcIi9saT5cXFwiO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHNlcCA9IGZhbHNlO1xcbiAgICAgICAgICBzdHIgKz0gXFxcIjxcXFwiICsgXFxcImxpIGNsYXNzPSdcXFwiICsgKHZhbC5fY2xhc3MgfHwgXFxcIlxcXCIpICsgKHZhbC5fZGlzYWJsZWQgPT09IHRydWUgfHwgJC5pc0Z1bmN0aW9uKHZhbC5fZGlzYWJsZWQpICYmIHZhbC5fZGlzYWJsZWQoe1xcbiAgICAgICAgICAgIFxcXCJpdGVtXFxcIjogdmFsLFxcbiAgICAgICAgICAgIFxcXCJyZWZlcmVuY2VcXFwiOiB2YWthdGFfY29udGV4dC5yZWZlcmVuY2UsXFxuICAgICAgICAgICAgXFxcImVsZW1lbnRcXFwiOiB2YWthdGFfY29udGV4dC5lbGVtZW50XFxuICAgICAgICAgIH0pID8gXFxcIiB2YWthdGEtY29udGV4dG1lbnUtZGlzYWJsZWQgXFxcIiA6IFxcXCJcXFwiKSArIFxcXCInIFxcXCIgKyAodmFsLnNob3J0Y3V0ID8gXFxcIiBkYXRhLXNob3J0Y3V0PSdcXFwiICsgdmFsLnNob3J0Y3V0ICsgXFxcIicgXFxcIiA6ICcnKSArIFxcXCI+XFxcIjtcXG4gICAgICAgICAgc3RyICs9IFxcXCI8XFxcIiArIFxcXCJhIGhyZWY9JyMnIHJlbD0nXFxcIiArICh2YWthdGFfY29udGV4dC5pdGVtcy5sZW5ndGggLSAxKSArIFxcXCInIFxcXCIgKyAodmFsLnRpdGxlID8gXFxcInRpdGxlPSdcXFwiICsgdmFsLnRpdGxlICsgXFxcIidcXFwiIDogXFxcIlxcXCIpICsgXFxcIj5cXFwiO1xcblxcbiAgICAgICAgICBpZiAoJC52YWthdGEuY29udGV4dC5zZXR0aW5ncy5pY29ucykge1xcbiAgICAgICAgICAgIHN0ciArPSBcXFwiPFxcXCIgKyBcXFwiaSBcXFwiO1xcblxcbiAgICAgICAgICAgIGlmICh2YWwuaWNvbikge1xcbiAgICAgICAgICAgICAgaWYgKHZhbC5pY29uLmluZGV4T2YoXFxcIi9cXFwiKSAhPT0gLTEgfHwgdmFsLmljb24uaW5kZXhPZihcXFwiLlxcXCIpICE9PSAtMSkge1xcbiAgICAgICAgICAgICAgICBzdHIgKz0gXFxcIiBzdHlsZT0nYmFja2dyb3VuZDp1cmwoXFxcXFxcXCJcXFwiICsgdmFsLmljb24gKyBcXFwiXFxcXFxcXCIpIGNlbnRlciBjZW50ZXIgbm8tcmVwZWF0JyBcXFwiO1xcbiAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgc3RyICs9IFxcXCIgY2xhc3M9J1xcXCIgKyB2YWwuaWNvbiArIFxcXCInIFxcXCI7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIHN0ciArPSBcXFwiPjxcXFwiICsgXFxcIi9pPjxcXFwiICsgXFxcInNwYW4gY2xhc3M9J3Zha2F0YS1jb250ZXh0bWVudS1zZXAnPiYjMTYwOzxcXFwiICsgXFxcIi9zcGFuPlxcXCI7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgc3RyICs9ICgkLmlzRnVuY3Rpb24odmFsLmxhYmVsKSA/IHZhbC5sYWJlbCh7XFxuICAgICAgICAgICAgXFxcIml0ZW1cXFwiOiBpLFxcbiAgICAgICAgICAgIFxcXCJyZWZlcmVuY2VcXFwiOiB2YWthdGFfY29udGV4dC5yZWZlcmVuY2UsXFxuICAgICAgICAgICAgXFxcImVsZW1lbnRcXFwiOiB2YWthdGFfY29udGV4dC5lbGVtZW50XFxuICAgICAgICAgIH0pIDogdmFsLmxhYmVsKSArICh2YWwuc2hvcnRjdXQgPyAnIDxzcGFuIGNsYXNzPVxcXCJ2YWthdGEtY29udGV4dG1lbnUtc2hvcnRjdXQgdmFrYXRhLWNvbnRleHRtZW51LXNob3J0Y3V0LScgKyB2YWwuc2hvcnRjdXQgKyAnXFxcIj4nICsgKHZhbC5zaG9ydGN1dF9sYWJlbCB8fCAnJykgKyAnPC9zcGFuPicgOiAnJykgKyBcXFwiPFxcXCIgKyBcXFwiL2E+XFxcIjtcXG5cXG4gICAgICAgICAgaWYgKHZhbC5zdWJtZW51KSB7XFxuICAgICAgICAgICAgdG1wID0gJC52YWthdGEuY29udGV4dC5fcGFyc2UodmFsLnN1Ym1lbnUsIHRydWUpO1xcblxcbiAgICAgICAgICAgIGlmICh0bXApIHtcXG4gICAgICAgICAgICAgIHN0ciArPSB0bXA7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHN0ciArPSBcXFwiPFxcXCIgKyBcXFwiL2xpPlxcXCI7XFxuXFxuICAgICAgICAgIGlmICh2YWwuc2VwYXJhdG9yX2FmdGVyKSB7XFxuICAgICAgICAgICAgc3RyICs9IFxcXCI8XFxcIiArIFxcXCJsaSBjbGFzcz0ndmFrYXRhLWNvbnRleHQtc2VwYXJhdG9yJz48XFxcIiArIFxcXCJhIGhyZWY9JyMnIFxcXCIgKyAoJC52YWthdGEuY29udGV4dC5zZXR0aW5ncy5pY29ucyA/ICcnIDogJ3N0eWxlPVxcXCJtYXJnaW4tbGVmdDowcHg7XFxcIicpICsgXFxcIj4mIzE2MDs8XFxcIiArIFxcXCIvYT48XFxcIiArIFxcXCIvbGk+XFxcIjtcXG4gICAgICAgICAgICBzZXAgPSB0cnVlO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKC88bGkgY2xhc3NcXFxcPSd2YWthdGEtY29udGV4dC1zZXBhcmF0b3InXFxcXD48XFxcXC9saVxcXFw+JC8sIFxcXCJcXFwiKTtcXG5cXG4gICAgICAgIGlmIChpc19jYWxsYmFjaykge1xcbiAgICAgICAgICBzdHIgKz0gXFxcIjwvdWw+XFxcIjtcXG4gICAgICAgIH1cXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogdHJpZ2dlcmVkIG9uIHRoZSBkb2N1bWVudCB3aGVuIHRoZSBjb250ZXh0bWVudSBpcyBwYXJzZWQgKEhUTUwgaXMgYnVpbHQpXFxuICAgICAgICAgKiBAZXZlbnRcXG4gICAgICAgICAqIEBwbHVnaW4gY29udGV4dG1lbnVcXG4gICAgICAgICAqIEBuYW1lIGNvbnRleHRfcGFyc2UudmFrYXRhXFxuICAgICAgICAgKiBAcGFyYW0ge2pRdWVyeX0gcmVmZXJlbmNlIHRoZSBlbGVtZW50IHRoYXQgd2FzIHJpZ2h0IGNsaWNrZWRcXG4gICAgICAgICAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IHRoZSBET00gZWxlbWVudCBvZiB0aGUgbWVudSBpdHNlbGZcXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb3NpdGlvbiB0aGUgeCAmIHkgY29vcmRpbmF0ZXMgb2YgdGhlIG1lbnVcXG4gICAgICAgICAqL1xcblxcblxcbiAgICAgICAgaWYgKCFpc19jYWxsYmFjaykge1xcbiAgICAgICAgICB2YWthdGFfY29udGV4dC5odG1sID0gc3RyO1xcblxcbiAgICAgICAgICAkLnZha2F0YS5jb250ZXh0Ll90cmlnZ2VyKFxcXCJwYXJzZVxcXCIpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIHN0ci5sZW5ndGggPiAxMCA/IHN0ciA6IGZhbHNlO1xcbiAgICAgIH0sXFxuICAgICAgX3Nob3dfc3VibWVudTogZnVuY3Rpb24gX3Nob3dfc3VibWVudShvKSB7XFxuICAgICAgICBvID0gJChvKTtcXG5cXG4gICAgICAgIGlmICghby5sZW5ndGggfHwgIW8uY2hpbGRyZW4oXFxcInVsXFxcIikubGVuZ3RoKSB7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHZhciBlID0gby5jaGlsZHJlbihcXFwidWxcXFwiKSxcXG4gICAgICAgICAgICB4bCA9IG8ub2Zmc2V0KCkubGVmdCxcXG4gICAgICAgICAgICB4ID0geGwgKyBvLm91dGVyV2lkdGgoKSxcXG4gICAgICAgICAgICB5ID0gby5vZmZzZXQoKS50b3AsXFxuICAgICAgICAgICAgdyA9IGUud2lkdGgoKSxcXG4gICAgICAgICAgICBoID0gZS5oZWlnaHQoKSxcXG4gICAgICAgICAgICBkdyA9ICQod2luZG93KS53aWR0aCgpICsgJCh3aW5kb3cpLnNjcm9sbExlZnQoKSxcXG4gICAgICAgICAgICBkaCA9ICQod2luZG93KS5oZWlnaHQoKSArICQod2luZG93KS5zY3JvbGxUb3AoKTsgLy8g0LzQvtC20LUg0LTQsCDRgdC1INGB0L/QtdGB0YLQuCDQtSDQtdC00L3QsCDQv9GA0L7QstC10YDQutCwIC0g0LTQsNC70Lgg0L3Rj9C80LAg0L3Rj9C60L7QuSDQvtGCINC60LvQsNGB0L7QstC10YLQtSDQstC10YfQtSDQvdCw0LPQvtGA0LVcXG5cXG4gICAgICAgIGlmIChyaWdodF90b19sZWZ0KSB7XFxuICAgICAgICAgIG9beCAtICh3ICsgMTAgKyBvLm91dGVyV2lkdGgoKSkgPCAwID8gXFxcImFkZENsYXNzXFxcIiA6IFxcXCJyZW1vdmVDbGFzc1xcXCJdKFxcXCJ2YWthdGEtY29udGV4dC1sZWZ0XFxcIik7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBvW3ggKyB3ID4gZHcgJiYgeGwgPiBkdyAtIHggPyBcXFwiYWRkQ2xhc3NcXFwiIDogXFxcInJlbW92ZUNsYXNzXFxcIl0oXFxcInZha2F0YS1jb250ZXh0LXJpZ2h0XFxcIik7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoeSArIGggKyAxMCA+IGRoKSB7XFxuICAgICAgICAgIGUuY3NzKFxcXCJib3R0b21cXFwiLCBcXFwiLTFweFxcXCIpO1xcbiAgICAgICAgfSAvL2lmIGRvZXMgbm90IGZpdCAtIHN0aWNrIGl0IHRvIHRoZSBzaWRlXFxuXFxuXFxuICAgICAgICBpZiAoby5oYXNDbGFzcygndmFrYXRhLWNvbnRleHQtcmlnaHQnKSkge1xcbiAgICAgICAgICBpZiAoeGwgPCB3KSB7XFxuICAgICAgICAgICAgZS5jc3MoXFxcIm1hcmdpbi1yaWdodFxcXCIsIHhsIC0gdyk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGlmIChkdyAtIHggPCB3KSB7XFxuICAgICAgICAgICAgZS5jc3MoXFxcIm1hcmdpbi1sZWZ0XFxcIiwgZHcgLSB4IC0gdyk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGUuc2hvdygpO1xcbiAgICAgIH0sXFxuICAgICAgc2hvdzogZnVuY3Rpb24gc2hvdyhyZWZlcmVuY2UsIHBvc2l0aW9uLCBkYXRhKSB7XFxuICAgICAgICB2YXIgbyxcXG4gICAgICAgICAgICBlLFxcbiAgICAgICAgICAgIHgsXFxuICAgICAgICAgICAgeSxcXG4gICAgICAgICAgICB3LFxcbiAgICAgICAgICAgIGgsXFxuICAgICAgICAgICAgZHcsXFxuICAgICAgICAgICAgZGgsXFxuICAgICAgICAgICAgY29uZCA9IHRydWU7XFxuXFxuICAgICAgICBpZiAodmFrYXRhX2NvbnRleHQuZWxlbWVudCAmJiB2YWthdGFfY29udGV4dC5lbGVtZW50Lmxlbmd0aCkge1xcbiAgICAgICAgICB2YWthdGFfY29udGV4dC5lbGVtZW50LndpZHRoKCcnKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHN3aXRjaCAoY29uZCkge1xcbiAgICAgICAgICBjYXNlICFwb3NpdGlvbiAmJiAhcmVmZXJlbmNlOlxcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG5cXG4gICAgICAgICAgY2FzZSAhIXBvc2l0aW9uICYmICEhcmVmZXJlbmNlOlxcbiAgICAgICAgICAgIHZha2F0YV9jb250ZXh0LnJlZmVyZW5jZSA9IHJlZmVyZW5jZTtcXG4gICAgICAgICAgICB2YWthdGFfY29udGV4dC5wb3NpdGlvbl94ID0gcG9zaXRpb24ueDtcXG4gICAgICAgICAgICB2YWthdGFfY29udGV4dC5wb3NpdGlvbl95ID0gcG9zaXRpb24ueTtcXG4gICAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgICAgY2FzZSAhcG9zaXRpb24gJiYgISFyZWZlcmVuY2U6XFxuICAgICAgICAgICAgdmFrYXRhX2NvbnRleHQucmVmZXJlbmNlID0gcmVmZXJlbmNlO1xcbiAgICAgICAgICAgIG8gPSByZWZlcmVuY2Uub2Zmc2V0KCk7XFxuICAgICAgICAgICAgdmFrYXRhX2NvbnRleHQucG9zaXRpb25feCA9IG8ubGVmdCArIHJlZmVyZW5jZS5vdXRlckhlaWdodCgpO1xcbiAgICAgICAgICAgIHZha2F0YV9jb250ZXh0LnBvc2l0aW9uX3kgPSBvLnRvcDtcXG4gICAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgICAgY2FzZSAhIXBvc2l0aW9uICYmICFyZWZlcmVuY2U6XFxuICAgICAgICAgICAgdmFrYXRhX2NvbnRleHQucG9zaXRpb25feCA9IHBvc2l0aW9uLng7XFxuICAgICAgICAgICAgdmFrYXRhX2NvbnRleHQucG9zaXRpb25feSA9IHBvc2l0aW9uLnk7XFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoISFyZWZlcmVuY2UgJiYgIWRhdGEgJiYgJChyZWZlcmVuY2UpLmRhdGEoJ3Zha2F0YV9jb250ZXh0bWVudScpKSB7XFxuICAgICAgICAgIGRhdGEgPSAkKHJlZmVyZW5jZSkuZGF0YSgndmFrYXRhX2NvbnRleHRtZW51Jyk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoJC52YWthdGEuY29udGV4dC5fcGFyc2UoZGF0YSkpIHtcXG4gICAgICAgICAgdmFrYXRhX2NvbnRleHQuZWxlbWVudC5odG1sKHZha2F0YV9jb250ZXh0Lmh0bWwpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKHZha2F0YV9jb250ZXh0Lml0ZW1zLmxlbmd0aCkge1xcbiAgICAgICAgICB2YWthdGFfY29udGV4dC5lbGVtZW50LmFwcGVuZFRvKFxcXCJib2R5XFxcIik7XFxuICAgICAgICAgIGUgPSB2YWthdGFfY29udGV4dC5lbGVtZW50O1xcbiAgICAgICAgICB4ID0gdmFrYXRhX2NvbnRleHQucG9zaXRpb25feDtcXG4gICAgICAgICAgeSA9IHZha2F0YV9jb250ZXh0LnBvc2l0aW9uX3k7XFxuICAgICAgICAgIHcgPSBlLndpZHRoKCk7XFxuICAgICAgICAgIGggPSBlLmhlaWdodCgpO1xcbiAgICAgICAgICBkdyA9ICQod2luZG93KS53aWR0aCgpICsgJCh3aW5kb3cpLnNjcm9sbExlZnQoKTtcXG4gICAgICAgICAgZGggPSAkKHdpbmRvdykuaGVpZ2h0KCkgKyAkKHdpbmRvdykuc2Nyb2xsVG9wKCk7XFxuXFxuICAgICAgICAgIGlmIChyaWdodF90b19sZWZ0KSB7XFxuICAgICAgICAgICAgeCAtPSBlLm91dGVyV2lkdGgoKSAtICQocmVmZXJlbmNlKS5vdXRlcldpZHRoKCk7XFxuXFxuICAgICAgICAgICAgaWYgKHggPCAkKHdpbmRvdykuc2Nyb2xsTGVmdCgpICsgMjApIHtcXG4gICAgICAgICAgICAgIHggPSAkKHdpbmRvdykuc2Nyb2xsTGVmdCgpICsgMjA7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmICh4ICsgdyArIDIwID4gZHcpIHtcXG4gICAgICAgICAgICB4ID0gZHcgLSAodyArIDIwKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAoeSArIGggKyAyMCA+IGRoKSB7XFxuICAgICAgICAgICAgeSA9IGRoIC0gKGggKyAyMCk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgdmFrYXRhX2NvbnRleHQuZWxlbWVudC5jc3Moe1xcbiAgICAgICAgICAgIFxcXCJsZWZ0XFxcIjogeCxcXG4gICAgICAgICAgICBcXFwidG9wXFxcIjogeVxcbiAgICAgICAgICB9KS5zaG93KCkuZmluZCgnYScpLmZpcnN0KCkuZm9jdXMoKS5wYXJlbnQoKS5hZGRDbGFzcyhcXFwidmFrYXRhLWNvbnRleHQtaG92ZXJcXFwiKTtcXG4gICAgICAgICAgdmFrYXRhX2NvbnRleHQuaXNfdmlzaWJsZSA9IHRydWU7XFxuICAgICAgICAgIC8qKlxcbiAgICAgICAgICAgKiB0cmlnZ2VyZWQgb24gdGhlIGRvY3VtZW50IHdoZW4gdGhlIGNvbnRleHRtZW51IGlzIHNob3duXFxuICAgICAgICAgICAqIEBldmVudFxcbiAgICAgICAgICAgKiBAcGx1Z2luIGNvbnRleHRtZW51XFxuICAgICAgICAgICAqIEBuYW1lIGNvbnRleHRfc2hvdy52YWthdGFcXG4gICAgICAgICAgICogQHBhcmFtIHtqUXVlcnl9IHJlZmVyZW5jZSB0aGUgZWxlbWVudCB0aGF0IHdhcyByaWdodCBjbGlja2VkXFxuICAgICAgICAgICAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IHRoZSBET00gZWxlbWVudCBvZiB0aGUgbWVudSBpdHNlbGZcXG4gICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHBvc2l0aW9uIHRoZSB4ICYgeSBjb29yZGluYXRlcyBvZiB0aGUgbWVudVxcbiAgICAgICAgICAgKi9cXG5cXG4gICAgICAgICAgJC52YWthdGEuY29udGV4dC5fdHJpZ2dlcihcXFwic2hvd1xcXCIpO1xcbiAgICAgICAgfVxcbiAgICAgIH0sXFxuICAgICAgaGlkZTogZnVuY3Rpb24gaGlkZSgpIHtcXG4gICAgICAgIGlmICh2YWthdGFfY29udGV4dC5pc192aXNpYmxlKSB7XFxuICAgICAgICAgIHZha2F0YV9jb250ZXh0LmVsZW1lbnQuaGlkZSgpLmZpbmQoXFxcInVsXFxcIikuaGlkZSgpLmVuZCgpLmZpbmQoJzpmb2N1cycpLmJsdXIoKS5lbmQoKS5kZXRhY2goKTtcXG4gICAgICAgICAgdmFrYXRhX2NvbnRleHQuaXNfdmlzaWJsZSA9IGZhbHNlO1xcbiAgICAgICAgICAvKipcXG4gICAgICAgICAgICogdHJpZ2dlcmVkIG9uIHRoZSBkb2N1bWVudCB3aGVuIHRoZSBjb250ZXh0bWVudSBpcyBoaWRkZW5cXG4gICAgICAgICAgICogQGV2ZW50XFxuICAgICAgICAgICAqIEBwbHVnaW4gY29udGV4dG1lbnVcXG4gICAgICAgICAgICogQG5hbWUgY29udGV4dF9oaWRlLnZha2F0YVxcbiAgICAgICAgICAgKiBAcGFyYW0ge2pRdWVyeX0gcmVmZXJlbmNlIHRoZSBlbGVtZW50IHRoYXQgd2FzIHJpZ2h0IGNsaWNrZWRcXG4gICAgICAgICAgICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgdGhlIERPTSBlbGVtZW50IG9mIHRoZSBtZW51IGl0c2VsZlxcbiAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9zaXRpb24gdGhlIHggJiB5IGNvb3JkaW5hdGVzIG9mIHRoZSBtZW51XFxuICAgICAgICAgICAqL1xcblxcbiAgICAgICAgICAkLnZha2F0YS5jb250ZXh0Ll90cmlnZ2VyKFxcXCJoaWRlXFxcIik7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9O1xcbiAgICAkKGZ1bmN0aW9uICgpIHtcXG4gICAgICByaWdodF90b19sZWZ0ID0gJChcXFwiYm9keVxcXCIpLmNzcyhcXFwiZGlyZWN0aW9uXFxcIikgPT09IFxcXCJydGxcXFwiO1xcbiAgICAgIHZhciB0byA9IGZhbHNlO1xcbiAgICAgIHZha2F0YV9jb250ZXh0LmVsZW1lbnQgPSAkKFxcXCI8dWwgY2xhc3M9J3Zha2F0YS1jb250ZXh0Jz48L3VsPlxcXCIpO1xcbiAgICAgIHZha2F0YV9jb250ZXh0LmVsZW1lbnQub24oXFxcIm1vdXNlZW50ZXJcXFwiLCBcXFwibGlcXFwiLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcXG5cXG4gICAgICAgIGlmICgkLmNvbnRhaW5zKHRoaXMsIGUucmVsYXRlZFRhcmdldCkpIHtcXG4gICAgICAgICAgLy8g0L/RgNC10LzQsNGF0L3QsNGC0L4g0LfQsNGA0LDQtNC4IGRlbGVnYXRlIG1vdXNlbGVhdmUg0L/Qvi3QtNC+0LvRg1xcbiAgICAgICAgICAvLyAkKHRoaXMpLmZpbmQoXFxcIi52YWthdGEtY29udGV4dC1ob3ZlclxcXCIpLnJlbW92ZUNsYXNzKFxcXCJ2YWthdGEtY29udGV4dC1ob3ZlclxcXCIpO1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAodG8pIHtcXG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRvKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHZha2F0YV9jb250ZXh0LmVsZW1lbnQuZmluZChcXFwiLnZha2F0YS1jb250ZXh0LWhvdmVyXFxcIikucmVtb3ZlQ2xhc3MoXFxcInZha2F0YS1jb250ZXh0LWhvdmVyXFxcIikuZW5kKCk7XFxuICAgICAgICAkKHRoaXMpLnNpYmxpbmdzKCkuZmluZChcXFwidWxcXFwiKS5oaWRlKCkuZW5kKCkuZW5kKCkucGFyZW50c1VudGlsKFxcXCIudmFrYXRhLWNvbnRleHRcXFwiLCBcXFwibGlcXFwiKS5hZGRCYWNrKCkuYWRkQ2xhc3MoXFxcInZha2F0YS1jb250ZXh0LWhvdmVyXFxcIik7XFxuXFxuICAgICAgICAkLnZha2F0YS5jb250ZXh0Ll9zaG93X3N1Ym1lbnUodGhpcyk7XFxuICAgICAgfSkgLy8g0YLQtdGB0YLQvtCy0L4gLSDQtNCw0LvQuCDQvdC1INC90LDRgtC+0LLQsNGA0LLQsD9cXG4gICAgICAub24oXFxcIm1vdXNlbGVhdmVcXFwiLCBcXFwibGlcXFwiLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgaWYgKCQuY29udGFpbnModGhpcywgZS5yZWxhdGVkVGFyZ2V0KSkge1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICAkKHRoaXMpLmZpbmQoXFxcIi52YWthdGEtY29udGV4dC1ob3ZlclxcXCIpLmFkZEJhY2soKS5yZW1vdmVDbGFzcyhcXFwidmFrYXRhLWNvbnRleHQtaG92ZXJcXFwiKTtcXG4gICAgICB9KS5vbihcXFwibW91c2VsZWF2ZVxcXCIsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICAkKHRoaXMpLmZpbmQoXFxcIi52YWthdGEtY29udGV4dC1ob3ZlclxcXCIpLnJlbW92ZUNsYXNzKFxcXCJ2YWthdGEtY29udGV4dC1ob3ZlclxcXCIpO1xcblxcbiAgICAgICAgaWYgKCQudmFrYXRhLmNvbnRleHQuc2V0dGluZ3MuaGlkZV9vbm1vdXNlbGVhdmUpIHtcXG4gICAgICAgICAgdG8gPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICh0KSB7XFxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICQudmFrYXRhLmNvbnRleHQuaGlkZSgpO1xcbiAgICAgICAgICAgIH07XFxuICAgICAgICAgIH0odGhpcyksICQudmFrYXRhLmNvbnRleHQuc2V0dGluZ3MuaGlkZV9vbm1vdXNlbGVhdmUpO1xcbiAgICAgICAgfVxcbiAgICAgIH0pLm9uKFxcXCJjbGlja1xcXCIsIFxcXCJhXFxcIiwgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTsgLy99KVxcbiAgICAgICAgLy8ub24oXFxcIm1vdXNldXBcXFwiLCBcXFwiYVxcXCIsIGZ1bmN0aW9uIChlKSB7XFxuXFxuICAgICAgICBpZiAoISQodGhpcykuYmx1cigpLnBhcmVudCgpLmhhc0NsYXNzKFxcXCJ2YWthdGEtY29udGV4dC1kaXNhYmxlZFxcXCIpICYmICQudmFrYXRhLmNvbnRleHQuX2V4ZWN1dGUoJCh0aGlzKS5hdHRyKFxcXCJyZWxcXFwiKSkgIT09IGZhbHNlKSB7XFxuICAgICAgICAgICQudmFrYXRhLmNvbnRleHQuaGlkZSgpO1xcbiAgICAgICAgfVxcbiAgICAgIH0pLm9uKCdrZXlkb3duJywgJ2EnLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgdmFyIG8gPSBudWxsO1xcblxcbiAgICAgICAgc3dpdGNoIChlLndoaWNoKSB7XFxuICAgICAgICAgIGNhc2UgMTM6XFxuICAgICAgICAgIGNhc2UgMzI6XFxuICAgICAgICAgICAgZS50eXBlID0gXFxcImNsaWNrXFxcIjtcXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICAgICAgJChlLmN1cnJlbnRUYXJnZXQpLnRyaWdnZXIoZSk7XFxuICAgICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICAgIGNhc2UgMzc6XFxuICAgICAgICAgICAgaWYgKHZha2F0YV9jb250ZXh0LmlzX3Zpc2libGUpIHtcXG4gICAgICAgICAgICAgIHZha2F0YV9jb250ZXh0LmVsZW1lbnQuZmluZChcXFwiLnZha2F0YS1jb250ZXh0LWhvdmVyXFxcIikubGFzdCgpLmNsb3Nlc3QoXFxcImxpXFxcIikuZmlyc3QoKS5maW5kKFxcXCJ1bFxcXCIpLmhpZGUoKS5maW5kKFxcXCIudmFrYXRhLWNvbnRleHQtaG92ZXJcXFwiKS5yZW1vdmVDbGFzcyhcXFwidmFrYXRhLWNvbnRleHQtaG92ZXJcXFwiKS5lbmQoKS5lbmQoKS5jaGlsZHJlbignYScpLmZvY3VzKCk7XFxuICAgICAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xcbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgICAgY2FzZSAzODpcXG4gICAgICAgICAgICBpZiAodmFrYXRhX2NvbnRleHQuaXNfdmlzaWJsZSkge1xcbiAgICAgICAgICAgICAgbyA9IHZha2F0YV9jb250ZXh0LmVsZW1lbnQuZmluZChcXFwidWw6dmlzaWJsZVxcXCIpLmFkZEJhY2soKS5sYXN0KCkuY2hpbGRyZW4oXFxcIi52YWthdGEtY29udGV4dC1ob3ZlclxcXCIpLnJlbW92ZUNsYXNzKFxcXCJ2YWthdGEtY29udGV4dC1ob3ZlclxcXCIpLnByZXZBbGwoXFxcImxpOm5vdCgudmFrYXRhLWNvbnRleHQtc2VwYXJhdG9yKVxcXCIpLmZpcnN0KCk7XFxuXFxuICAgICAgICAgICAgICBpZiAoIW8ubGVuZ3RoKSB7XFxuICAgICAgICAgICAgICAgIG8gPSB2YWthdGFfY29udGV4dC5lbGVtZW50LmZpbmQoXFxcInVsOnZpc2libGVcXFwiKS5hZGRCYWNrKCkubGFzdCgpLmNoaWxkcmVuKFxcXCJsaTpub3QoLnZha2F0YS1jb250ZXh0LXNlcGFyYXRvcilcXFwiKS5sYXN0KCk7XFxuICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICBvLmFkZENsYXNzKFxcXCJ2YWthdGEtY29udGV4dC1ob3ZlclxcXCIpLmNoaWxkcmVuKCdhJykuZm9jdXMoKTtcXG4gICAgICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XFxuICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICBjYXNlIDM5OlxcbiAgICAgICAgICAgIGlmICh2YWthdGFfY29udGV4dC5pc192aXNpYmxlKSB7XFxuICAgICAgICAgICAgICB2YWthdGFfY29udGV4dC5lbGVtZW50LmZpbmQoXFxcIi52YWthdGEtY29udGV4dC1ob3ZlclxcXCIpLmxhc3QoKS5jaGlsZHJlbihcXFwidWxcXFwiKS5zaG93KCkuY2hpbGRyZW4oXFxcImxpOm5vdCgudmFrYXRhLWNvbnRleHQtc2VwYXJhdG9yKVxcXCIpLnJlbW92ZUNsYXNzKFxcXCJ2YWthdGEtY29udGV4dC1ob3ZlclxcXCIpLmZpcnN0KCkuYWRkQ2xhc3MoXFxcInZha2F0YS1jb250ZXh0LWhvdmVyXFxcIikuY2hpbGRyZW4oJ2EnKS5mb2N1cygpO1xcbiAgICAgICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcXG4gICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICAgIGNhc2UgNDA6XFxuICAgICAgICAgICAgaWYgKHZha2F0YV9jb250ZXh0LmlzX3Zpc2libGUpIHtcXG4gICAgICAgICAgICAgIG8gPSB2YWthdGFfY29udGV4dC5lbGVtZW50LmZpbmQoXFxcInVsOnZpc2libGVcXFwiKS5hZGRCYWNrKCkubGFzdCgpLmNoaWxkcmVuKFxcXCIudmFrYXRhLWNvbnRleHQtaG92ZXJcXFwiKS5yZW1vdmVDbGFzcyhcXFwidmFrYXRhLWNvbnRleHQtaG92ZXJcXFwiKS5uZXh0QWxsKFxcXCJsaTpub3QoLnZha2F0YS1jb250ZXh0LXNlcGFyYXRvcilcXFwiKS5maXJzdCgpO1xcblxcbiAgICAgICAgICAgICAgaWYgKCFvLmxlbmd0aCkge1xcbiAgICAgICAgICAgICAgICBvID0gdmFrYXRhX2NvbnRleHQuZWxlbWVudC5maW5kKFxcXCJ1bDp2aXNpYmxlXFxcIikuYWRkQmFjaygpLmxhc3QoKS5jaGlsZHJlbihcXFwibGk6bm90KC52YWthdGEtY29udGV4dC1zZXBhcmF0b3IpXFxcIikuZmlyc3QoKTtcXG4gICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgIG8uYWRkQ2xhc3MoXFxcInZha2F0YS1jb250ZXh0LWhvdmVyXFxcIikuY2hpbGRyZW4oJ2EnKS5mb2N1cygpO1xcbiAgICAgICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcXG4gICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICAgIGNhc2UgMjc6XFxuICAgICAgICAgICAgJC52YWthdGEuY29udGV4dC5oaWRlKCk7XFxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICBkZWZhdWx0OlxcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coZS53aGljaCk7XFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICB9XFxuICAgICAgfSkub24oJ2tleWRvd24nLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgdmFyIGEgPSB2YWthdGFfY29udGV4dC5lbGVtZW50LmZpbmQoJy52YWthdGEtY29udGV4dG1lbnUtc2hvcnRjdXQtJyArIGUud2hpY2gpLnBhcmVudCgpO1xcblxcbiAgICAgICAgaWYgKGEucGFyZW50KCkubm90KCcudmFrYXRhLWNvbnRleHQtZGlzYWJsZWQnKSkge1xcbiAgICAgICAgICBhLmNsaWNrKCk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgICAgJChkb2N1bWVudCkub24oXFxcIm1vdXNlZG93bi52YWthdGEuanN0cmVlXFxcIiwgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgIGlmICh2YWthdGFfY29udGV4dC5pc192aXNpYmxlICYmICEkLmNvbnRhaW5zKHZha2F0YV9jb250ZXh0LmVsZW1lbnRbMF0sIGUudGFyZ2V0KSkge1xcbiAgICAgICAgICAkLnZha2F0YS5jb250ZXh0LmhpZGUoKTtcXG4gICAgICAgIH1cXG4gICAgICB9KS5vbihcXFwiY29udGV4dF9zaG93LnZha2F0YS5qc3RyZWVcXFwiLCBmdW5jdGlvbiAoZSwgZGF0YSkge1xcbiAgICAgICAgdmFrYXRhX2NvbnRleHQuZWxlbWVudC5maW5kKFxcXCJsaTpoYXModWwpXFxcIikuY2hpbGRyZW4oXFxcImFcXFwiKS5hZGRDbGFzcyhcXFwidmFrYXRhLWNvbnRleHQtcGFyZW50XFxcIik7XFxuXFxuICAgICAgICBpZiAocmlnaHRfdG9fbGVmdCkge1xcbiAgICAgICAgICB2YWthdGFfY29udGV4dC5lbGVtZW50LmFkZENsYXNzKFxcXCJ2YWthdGEtY29udGV4dC1ydGxcXFwiKS5jc3MoXFxcImRpcmVjdGlvblxcXCIsIFxcXCJydGxcXFwiKTtcXG4gICAgICAgIH0gLy8gYWxzbyBhcHBseSBhIFJUTCBjbGFzcz9cXG5cXG5cXG4gICAgICAgIHZha2F0YV9jb250ZXh0LmVsZW1lbnQuZmluZChcXFwidWxcXFwiKS5oaWRlKCkuZW5kKCk7XFxuICAgICAgfSk7XFxuICAgIH0pO1xcbiAgfSkoJCk7IC8vICQuanN0cmVlLmRlZmF1bHRzLnBsdWdpbnMucHVzaChcXFwiY29udGV4dG1lbnVcXFwiKTtcXG5cXG4gIC8qKlxcbiAgICogIyMjIERyYWcnbidkcm9wIHBsdWdpblxcbiAgICpcXG4gICAqIEVuYWJsZXMgZHJhZ2dpbmcgYW5kIGRyb3BwaW5nIG9mIG5vZGVzIGluIHRoZSB0cmVlLCByZXN1bHRpbmcgaW4gYSBtb3ZlIG9yIGNvcHkgb3BlcmF0aW9ucy5cXG4gICAqL1xcblxcbiAgLyoqXFxuICAgKiBzdG9yZXMgYWxsIGRlZmF1bHRzIGZvciB0aGUgZHJhZyduJ2Ryb3AgcGx1Z2luXFxuICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5kbmRcXG4gICAqIEBwbHVnaW4gZG5kXFxuICAgKi9cXG5cXG5cXG4gICQuanN0cmVlLmRlZmF1bHRzLmRuZCA9IHtcXG4gICAgLyoqXFxuICAgICAqIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIGEgY29weSBzaG91bGQgYmUgcG9zc2libGUgd2hpbGUgZHJhZ2dpbmcgKGJ5IHByZXNzaW50IHRoZSBtZXRhIGtleSBvciBDdHJsKS4gRGVmYXVsdHMgdG8gYHRydWVgLlxcbiAgICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5kbmQuY29weVxcbiAgICAgKiBAcGx1Z2luIGRuZFxcbiAgICAgKi9cXG4gICAgY29weTogdHJ1ZSxcXG5cXG4gICAgLyoqXFxuICAgICAqIGEgbnVtYmVyIGluZGljYXRpbmcgaG93IGxvbmcgYSBub2RlIHNob3VsZCByZW1haW4gaG92ZXJlZCB3aGlsZSBkcmFnZ2luZyB0byBiZSBvcGVuZWQuIERlZmF1bHRzIHRvIGA1MDBgLlxcbiAgICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5kbmQub3Blbl90aW1lb3V0XFxuICAgICAqIEBwbHVnaW4gZG5kXFxuICAgICAqL1xcbiAgICBvcGVuX3RpbWVvdXQ6IDUwMCxcXG5cXG4gICAgLyoqXFxuICAgICAqIGEgZnVuY3Rpb24gaW52b2tlZCBlYWNoIHRpbWUgYSBub2RlIGlzIGFib3V0IHRvIGJlIGRyYWdnZWQsIGludm9rZWQgaW4gdGhlIHRyZWUncyBzY29wZSBhbmQgcmVjZWl2ZXMgdGhlIG5vZGVzIGFib3V0IHRvIGJlIGRyYWdnZWQgYXMgYW4gYXJndW1lbnQgKGFycmF5KSBhbmQgdGhlIGV2ZW50IHRoYXQgc3RhcnRlZCB0aGUgZHJhZyAtIHJldHVybiBgZmFsc2VgIHRvIHByZXZlbnQgZHJhZ2dpbmdcXG4gICAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuZG5kLmlzX2RyYWdnYWJsZVxcbiAgICAgKiBAcGx1Z2luIGRuZFxcbiAgICAgKi9cXG4gICAgaXNfZHJhZ2dhYmxlOiB0cnVlLFxcblxcbiAgICAvKipcXG4gICAgICogYSBib29sZWFuIGluZGljYXRpbmcgaWYgY2hlY2tzIHNob3VsZCBjb25zdGFudGx5IGJlIG1hZGUgd2hpbGUgdGhlIHVzZXIgaXMgZHJhZ2dpbmcgdGhlIG5vZGUgKGFzIG9wcG9zZWQgdG8gY2hlY2tpbmcgb25seSBvbiBkcm9wKSwgZGVmYXVsdCBpcyBgdHJ1ZWBcXG4gICAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuZG5kLmNoZWNrX3doaWxlX2RyYWdnaW5nXFxuICAgICAqIEBwbHVnaW4gZG5kXFxuICAgICAqL1xcbiAgICBjaGVja193aGlsZV9kcmFnZ2luZzogdHJ1ZSxcXG5cXG4gICAgLyoqXFxuICAgICAqIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIG5vZGVzIGZyb20gdGhpcyB0cmVlIHNob3VsZCBvbmx5IGJlIGNvcGllZCB3aXRoIGRuZCAoYXMgb3Bwb3NlZCB0byBtb3ZlZCksIGRlZmF1bHQgaXMgYGZhbHNlYFxcbiAgICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5kbmQuYWx3YXlzX2NvcHlcXG4gICAgICogQHBsdWdpbiBkbmRcXG4gICAgICovXFxuICAgIGFsd2F5c19jb3B5OiBmYWxzZSxcXG5cXG4gICAgLyoqXFxuICAgICAqIHdoZW4gZHJvcHBpbmcgYSBub2RlIFxcXCJpbnNpZGVcXFwiLCB0aGlzIHNldHRpbmcgaW5kaWNhdGVzIHRoZSBwb3NpdGlvbiB0aGUgbm9kZSBzaG91bGQgZ28gdG8gLSBpdCBjYW4gYmUgYW4gaW50ZWdlciBvciBhIHN0cmluZzogXFxcImZpcnN0XFxcIiAoc2FtZSBhcyAwKSBvciBcXFwibGFzdFxcXCIsIGRlZmF1bHQgaXMgYDBgXFxuICAgICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmRuZC5pbnNpZGVfcG9zXFxuICAgICAqIEBwbHVnaW4gZG5kXFxuICAgICAqL1xcbiAgICBpbnNpZGVfcG9zOiAwLFxcblxcbiAgICAvKipcXG4gICAgICogd2hlbiBzdGFydGluZyB0aGUgZHJhZyBvbiBhIG5vZGUgdGhhdCBpcyBzZWxlY3RlZCB0aGlzIHNldHRpbmcgY29udHJvbHMgaWYgYWxsIHNlbGVjdGVkIG5vZGVzIGFyZSBkcmFnZ2VkIG9yIG9ubHkgdGhlIHNpbmdsZSBub2RlLCBkZWZhdWx0IGlzIGB0cnVlYCwgd2hpY2ggbWVhbnMgYWxsIHNlbGVjdGVkIG5vZGVzIGFyZSBkcmFnZ2VkIHdoZW4gdGhlIGRyYWcgaXMgc3RhcnRlZCBvbiBhIHNlbGVjdGVkIG5vZGVcXG4gICAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuZG5kLmRyYWdfc2VsZWN0aW9uXFxuICAgICAqIEBwbHVnaW4gZG5kXFxuICAgICAqL1xcbiAgICBkcmFnX3NlbGVjdGlvbjogdHJ1ZSxcXG5cXG4gICAgLyoqXFxuICAgICAqIGNvbnRyb2xzIHdoZXRoZXIgZG5kIHdvcmtzIG9uIHRvdWNoIGRldmljZXMuIElmIGxlZnQgYXMgYm9vbGVhbiB0cnVlIGRuZCB3aWxsIHdvcmsgdGhlIHNhbWUgYXMgaW4gZGVza3RvcCBicm93c2Vycywgd2hpY2ggaW4gc29tZSBjYXNlcyBtYXkgaW1wYWlyIHNjcm9sbGluZy4gSWYgc2V0IHRvIGJvb2xlYW4gZmFsc2UgZG5kIHdpbGwgbm90IHdvcmsgb24gdG91Y2ggZGV2aWNlcy4gVGhlcmUgaXMgYSBzcGVjaWFsIHRoaXJkIG9wdGlvbiAtIHN0cmluZyBcXFwic2VsZWN0ZWRcXFwiIHdoaWNoIG1lYW5zIG9ubHkgc2VsZWN0ZWQgbm9kZXMgY2FuIGJlIGRyYWdnZWQgb24gdG91Y2ggZGV2aWNlcy5cXG4gICAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuZG5kLnRvdWNoXFxuICAgICAqIEBwbHVnaW4gZG5kXFxuICAgICAqL1xcbiAgICB0b3VjaDogdHJ1ZSxcXG5cXG4gICAgLyoqXFxuICAgICAqIGNvbnRyb2xzIHdoZXRoZXIgaXRlbXMgY2FuIGJlIGRyb3BwZWQgYW55d2hlcmUgb24gdGhlIG5vZGUsIG5vdCBqdXN0IG9uIHRoZSBhbmNob3IsIGJ5IGRlZmF1bHQgb25seSB0aGUgbm9kZSBhbmNob3IgaXMgYSB2YWxpZCBkcm9wIHRhcmdldC4gV29ya3MgYmVzdCB3aXRoIHRoZSB3aG9sZXJvdyBwbHVnaW4uIElmIGVuYWJsZWQgb24gbW9iaWxlIGRlcGVuZGluZyBvbiB0aGUgaW50ZXJmYWNlIGl0IG1pZ2h0IGJlIGhhcmQgZm9yIHRoZSB1c2VyIHRvIGNhbmNlbCB0aGUgZHJvcCwgc2luY2UgdGhlIHdob2xlIHRyZWUgY29udGFpbmVyIHdpbGwgYmUgYSB2YWxpZCBkcm9wIHRhcmdldC5cXG4gICAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuZG5kLmxhcmdlX2Ryb3BfdGFyZ2V0XFxuICAgICAqIEBwbHVnaW4gZG5kXFxuICAgICAqL1xcbiAgICBsYXJnZV9kcm9wX3RhcmdldDogZmFsc2UsXFxuXFxuICAgIC8qKlxcbiAgICAgKiBjb250cm9scyB3aGV0aGVyIGEgZHJhZyBjYW4gYmUgaW5pdGlhdGVkIGZyb20gYW55IHBhcnQgb2YgdGhlIG5vZGUgYW5kIG5vdCBqdXN0IHRoZSB0ZXh0L2ljb24gcGFydCwgd29ya3MgYmVzdCB3aXRoIHRoZSB3aG9sZXJvdyBwbHVnaW4uIEtlZXAgaW4gbWluZCBpdCBjYW4gY2F1c2UgcHJvYmxlbXMgd2l0aCB0cmVlIHNjcm9sbGluZyBvbiBtb2JpbGUgZGVwZW5kaW5nIG9uIHRoZSBpbnRlcmZhY2UgLSBpbiB0aGF0IGNhc2Ugc2V0IHRoZSB0b3VjaCBvcHRpb24gdG8gXFxcInNlbGVjdGVkXFxcIi5cXG4gICAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuZG5kLmxhcmdlX2RyYWdfdGFyZ2V0XFxuICAgICAqIEBwbHVnaW4gZG5kXFxuICAgICAqL1xcbiAgICBsYXJnZV9kcmFnX3RhcmdldDogZmFsc2UsXFxuXFxuICAgIC8qKlxcbiAgICAgKiBjb250cm9scyB3aGV0aGVyIHVzZSBIVE1MNSBkbmQgYXBpIGluc3RlYWQgb2YgY2xhc3NpY2FsLiBUaGF0IHdpbGwgYWxsb3cgYmV0dGVyIGludGVncmF0aW9uIG9mIGRuZCBldmVudHMgd2l0aCBvdGhlciBIVE1MNSBjb250cm9scy5cXG4gICAgICogQHJlZmVyZW5jZSBodHRwOi8vY2FuaXVzZS5jb20vI2ZlYXQ9ZHJhZ25kcm9wXFxuICAgICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmRuZC51c2VfaHRtbDVcXG4gICAgICogQHBsdWdpbiBkbmRcXG4gICAgICovXFxuICAgIHVzZV9odG1sNTogZmFsc2VcXG4gIH07XFxuICB2YXIgZHJnLCBlbG07IC8vIFRPRE86IG5vdyBjaGVjayB3b3JrcyBieSBjaGVja2luZyBmb3IgZWFjaCBub2RlIGluZGl2aWR1YWxseSwgaG93IGFib3V0IG1heF9jaGlsZHJlbiwgdW5pcXVlLCBldGM/XFxuXFxuICAkLmpzdHJlZS5wbHVnaW5zLmRuZCA9IGZ1bmN0aW9uIChvcHRpb25zLCBwYXJlbnQpIHtcXG4gICAgdGhpcy5pbml0ID0gZnVuY3Rpb24gKGVsLCBvcHRpb25zKSB7XFxuICAgICAgcGFyZW50LmluaXQuY2FsbCh0aGlzLCBlbCwgb3B0aW9ucyk7XFxuICAgICAgdGhpcy5zZXR0aW5ncy5kbmQudXNlX2h0bWw1ID0gdGhpcy5zZXR0aW5ncy5kbmQudXNlX2h0bWw1ICYmICdkcmFnZ2FibGUnIGluIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5iaW5kID0gZnVuY3Rpb24gKCkge1xcbiAgICAgIHBhcmVudC5iaW5kLmNhbGwodGhpcyk7XFxuICAgICAgdGhpcy5lbGVtZW50Lm9uKHRoaXMuc2V0dGluZ3MuZG5kLnVzZV9odG1sNSA/ICdkcmFnc3RhcnQuanN0cmVlJyA6ICdtb3VzZWRvd24uanN0cmVlIHRvdWNoc3RhcnQuanN0cmVlJywgdGhpcy5zZXR0aW5ncy5kbmQubGFyZ2VfZHJhZ190YXJnZXQgPyAnLmpzdHJlZS1ub2RlJyA6ICcuanN0cmVlLWFuY2hvcicsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmRuZC5sYXJnZV9kcmFnX3RhcmdldCAmJiAkKGUudGFyZ2V0KS5jbG9zZXN0KCcuanN0cmVlLW5vZGUnKVswXSAhPT0gZS5jdXJyZW50VGFyZ2V0KSB7XFxuICAgICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKGUudHlwZSA9PT0gXFxcInRvdWNoc3RhcnRcXFwiICYmICghdGhpcy5zZXR0aW5ncy5kbmQudG91Y2ggfHwgdGhpcy5zZXR0aW5ncy5kbmQudG91Y2ggPT09ICdzZWxlY3RlZCcgJiYgISQoZS5jdXJyZW50VGFyZ2V0KS5jbG9zZXN0KCcuanN0cmVlLW5vZGUnKS5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5oYXNDbGFzcygnanN0cmVlLWNsaWNrZWQnKSkpIHtcXG4gICAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB2YXIgb2JqID0gdGhpcy5nZXRfbm9kZShlLnRhcmdldCksXFxuICAgICAgICAgICAgbWx0ID0gdGhpcy5pc19zZWxlY3RlZChvYmopICYmIHRoaXMuc2V0dGluZ3MuZG5kLmRyYWdfc2VsZWN0aW9uID8gdGhpcy5nZXRfdG9wX3NlbGVjdGVkKCkubGVuZ3RoIDogMSxcXG4gICAgICAgICAgICB0eHQgPSBtbHQgPiAxID8gbWx0ICsgJyAnICsgdGhpcy5nZXRfc3RyaW5nKCdub2RlcycpIDogdGhpcy5nZXRfdGV4dChlLmN1cnJlbnRUYXJnZXQpO1xcblxcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuY29yZS5mb3JjZV90ZXh0KSB7XFxuICAgICAgICAgIHR4dCA9ICQudmFrYXRhLmh0bWwuZXNjYXBlKHR4dCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAob2JqICYmIG9iai5pZCAmJiBvYmouaWQgIT09ICQuanN0cmVlLnJvb3QgJiYgKGUud2hpY2ggPT09IDEgfHwgZS50eXBlID09PSBcXFwidG91Y2hzdGFydFxcXCIgfHwgZS50eXBlID09PSBcXFwiZHJhZ3N0YXJ0XFxcIikgJiYgKHRoaXMuc2V0dGluZ3MuZG5kLmlzX2RyYWdnYWJsZSA9PT0gdHJ1ZSB8fCAkLmlzRnVuY3Rpb24odGhpcy5zZXR0aW5ncy5kbmQuaXNfZHJhZ2dhYmxlKSAmJiB0aGlzLnNldHRpbmdzLmRuZC5pc19kcmFnZ2FibGUuY2FsbCh0aGlzLCBtbHQgPiAxID8gdGhpcy5nZXRfdG9wX3NlbGVjdGVkKHRydWUpIDogW29ial0sIGUpKSkge1xcbiAgICAgICAgICBkcmcgPSB7XFxuICAgICAgICAgICAgJ2pzdHJlZSc6IHRydWUsXFxuICAgICAgICAgICAgJ29yaWdpbic6IHRoaXMsXFxuICAgICAgICAgICAgJ29iaic6IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKSxcXG4gICAgICAgICAgICAnbm9kZXMnOiBtbHQgPiAxID8gdGhpcy5nZXRfdG9wX3NlbGVjdGVkKCkgOiBbb2JqLmlkXVxcbiAgICAgICAgICB9O1xcbiAgICAgICAgICBlbG0gPSBlLmN1cnJlbnRUYXJnZXQ7XFxuXFxuICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmRuZC51c2VfaHRtbDUpIHtcXG4gICAgICAgICAgICAkLnZha2F0YS5kbmQuX3RyaWdnZXIoJ3N0YXJ0JywgZSwge1xcbiAgICAgICAgICAgICAgJ2hlbHBlcic6ICQoKSxcXG4gICAgICAgICAgICAgICdlbGVtZW50JzogZWxtLFxcbiAgICAgICAgICAgICAgJ2RhdGEnOiBkcmdcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQudHJpZ2dlcignbW91c2Vkb3duLmpzdHJlZScpO1xcbiAgICAgICAgICAgIHJldHVybiAkLnZha2F0YS5kbmQuc3RhcnQoZSwgZHJnLCAnPGRpdiBpZD1cXFwianN0cmVlLWRuZFxcXCIgY2xhc3M9XFxcImpzdHJlZS0nICsgdGhpcy5nZXRfdGhlbWUoKSArICcganN0cmVlLScgKyB0aGlzLmdldF90aGVtZSgpICsgJy0nICsgdGhpcy5nZXRfdGhlbWVfdmFyaWFudCgpICsgJyAnICsgKHRoaXMuc2V0dGluZ3MuY29yZS50aGVtZXMucmVzcG9uc2l2ZSA/ICcganN0cmVlLWRuZC1yZXNwb25zaXZlJyA6ICcnKSArICdcXFwiPjxpIGNsYXNzPVxcXCJqc3RyZWUtaWNvbiBqc3RyZWUtZXJcXFwiPjwvaT4nICsgdHh0ICsgJzxpbnMgY2xhc3M9XFxcImpzdHJlZS1jb3B5XFxcIiBzdHlsZT1cXFwiZGlzcGxheTpub25lO1xcXCI+KzwvaW5zPjwvZGl2PicpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfSwgdGhpcykpO1xcblxcbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLmRuZC51c2VfaHRtbDUpIHtcXG4gICAgICAgIHRoaXMuZWxlbWVudC5vbignZHJhZ292ZXIuanN0cmVlJywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcblxcbiAgICAgICAgICAkLnZha2F0YS5kbmQuX3RyaWdnZXIoJ21vdmUnLCBlLCB7XFxuICAgICAgICAgICAgJ2hlbHBlcic6ICQoKSxcXG4gICAgICAgICAgICAnZWxlbWVudCc6IGVsbSxcXG4gICAgICAgICAgICAnZGF0YSc6IGRyZ1xcbiAgICAgICAgICB9KTtcXG5cXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgfSkgLy8ub24oJ2RyYWdlbnRlci5qc3RyZWUnLCB0aGlzLnNldHRpbmdzLmRuZC5sYXJnZV9kcm9wX3RhcmdldCA/ICcuanN0cmVlLW5vZGUnIDogJy5qc3RyZWUtYW5jaG9yJywgJC5wcm94eShmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgLy9cXHRcXHRlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICAvL1xcdFxcdCQudmFrYXRhLmRuZC5fdHJpZ2dlcignbW92ZScsIGUsIHsgJ2hlbHBlcic6ICQoKSwgJ2VsZW1lbnQnOiBlbG0sICdkYXRhJzogZHJnIH0pO1xcbiAgICAgICAgLy9cXHRcXHRyZXR1cm4gZmFsc2U7XFxuICAgICAgICAvL1xcdH0sIHRoaXMpKVxcbiAgICAgICAgLm9uKCdkcm9wLmpzdHJlZScsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcblxcbiAgICAgICAgICAkLnZha2F0YS5kbmQuX3RyaWdnZXIoJ3N0b3AnLCBlLCB7XFxuICAgICAgICAgICAgJ2hlbHBlcic6ICQoKSxcXG4gICAgICAgICAgICAnZWxlbWVudCc6IGVsbSxcXG4gICAgICAgICAgICAnZGF0YSc6IGRyZ1xcbiAgICAgICAgICB9KTtcXG5cXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgfSwgdGhpcykpO1xcbiAgICAgIH1cXG4gICAgfTtcXG5cXG4gICAgdGhpcy5yZWRyYXdfbm9kZSA9IGZ1bmN0aW9uIChvYmosIGRlZXAsIGNhbGxiYWNrLCBmb3JjZV9yZW5kZXIpIHtcXG4gICAgICBvYmogPSBwYXJlbnQucmVkcmF3X25vZGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG5cXG4gICAgICBpZiAob2JqICYmIHRoaXMuc2V0dGluZ3MuZG5kLnVzZV9odG1sNSkge1xcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuZG5kLmxhcmdlX2RyYWdfdGFyZ2V0KSB7XFxuICAgICAgICAgIG9iai5zZXRBdHRyaWJ1dGUoJ2RyYWdnYWJsZScsIHRydWUpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgdmFyIGksXFxuICAgICAgICAgICAgICBqLFxcbiAgICAgICAgICAgICAgdG1wID0gbnVsbDtcXG5cXG4gICAgICAgICAgZm9yIChpID0gMCwgaiA9IG9iai5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcbiAgICAgICAgICAgIGlmIChvYmouY2hpbGROb2Rlc1tpXSAmJiBvYmouY2hpbGROb2Rlc1tpXS5jbGFzc05hbWUgJiYgb2JqLmNoaWxkTm9kZXNbaV0uY2xhc3NOYW1lLmluZGV4T2YoXFxcImpzdHJlZS1hbmNob3JcXFwiKSAhPT0gLTEpIHtcXG4gICAgICAgICAgICAgIHRtcCA9IG9iai5jaGlsZE5vZGVzW2ldO1xcbiAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmICh0bXApIHtcXG4gICAgICAgICAgICB0bXAuc2V0QXR0cmlidXRlKCdkcmFnZ2FibGUnLCB0cnVlKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gb2JqO1xcbiAgICB9O1xcbiAgfTtcXG5cXG4gICQoZnVuY3Rpb24gKCkge1xcbiAgICAvLyBiaW5kIG9ubHkgb25jZSBmb3IgYWxsIGluc3RhbmNlc1xcbiAgICB2YXIgbGFzdG12ID0gZmFsc2UsXFxuICAgICAgICBsYXN0ZXIgPSBmYWxzZSxcXG4gICAgICAgIGxhc3RldiA9IGZhbHNlLFxcbiAgICAgICAgb3BlbnRvID0gZmFsc2UsXFxuICAgICAgICBtYXJrZXIgPSAkKCc8ZGl2IGlkPVxcXCJqc3RyZWUtbWFya2VyXFxcIj4mIzE2MDs8L2Rpdj4nKS5oaWRlKCk7IC8vLmFwcGVuZFRvKCdib2R5Jyk7XFxuXFxuICAgICQoZG9jdW1lbnQpLm9uKCdkbmRfc3RhcnQudmFrYXRhLmpzdHJlZScsIGZ1bmN0aW9uIChlLCBkYXRhKSB7XFxuICAgICAgbGFzdG12ID0gZmFsc2U7XFxuICAgICAgbGFzdGV2ID0gZmFsc2U7XFxuXFxuICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmRhdGEgfHwgIWRhdGEuZGF0YS5qc3RyZWUpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgbWFya2VyLmFwcGVuZFRvKCdib2R5Jyk7IC8vLnNob3coKTtcXG4gICAgfSkub24oJ2RuZF9tb3ZlLnZha2F0YS5qc3RyZWUnLCBmdW5jdGlvbiAoZSwgZGF0YSkge1xcbiAgICAgIGlmIChvcGVudG8pIHtcXG4gICAgICAgIGlmICghZGF0YS5ldmVudCB8fCBkYXRhLmV2ZW50LnR5cGUgIT09ICdkcmFnb3ZlcicgfHwgZGF0YS5ldmVudC50YXJnZXQgIT09IGxhc3Rldi50YXJnZXQpIHtcXG4gICAgICAgICAgY2xlYXJUaW1lb3V0KG9wZW50byk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghZGF0YSB8fCAhZGF0YS5kYXRhIHx8ICFkYXRhLmRhdGEuanN0cmVlKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfSAvLyBpZiB3ZSBhcmUgaG92ZXJpbmcgdGhlIG1hcmtlciBpbWFnZSBkbyBub3RoaW5nIChjYW4gaGFwcGVuIG9uIFxcXCJpbnNpZGVcXFwiIGRyYWdzKVxcblxcblxcbiAgICAgIGlmIChkYXRhLmV2ZW50LnRhcmdldC5pZCAmJiBkYXRhLmV2ZW50LnRhcmdldC5pZCA9PT0gJ2pzdHJlZS1tYXJrZXInKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGxhc3RldiA9IGRhdGEuZXZlbnQ7XFxuICAgICAgdmFyIGlucyA9ICQuanN0cmVlLnJlZmVyZW5jZShkYXRhLmV2ZW50LnRhcmdldCksXFxuICAgICAgICAgIHJlZiA9IGZhbHNlLFxcbiAgICAgICAgICBvZmYgPSBmYWxzZSxcXG4gICAgICAgICAgcmVsID0gZmFsc2UsXFxuICAgICAgICAgIHRtcCxcXG4gICAgICAgICAgbCxcXG4gICAgICAgICAgdCxcXG4gICAgICAgICAgaCxcXG4gICAgICAgICAgcCxcXG4gICAgICAgICAgaSxcXG4gICAgICAgICAgbyxcXG4gICAgICAgICAgb2ssXFxuICAgICAgICAgIHQxLFxcbiAgICAgICAgICB0MixcXG4gICAgICAgICAgb3AsXFxuICAgICAgICAgIHBzLFxcbiAgICAgICAgICBwcixcXG4gICAgICAgICAgaXAsXFxuICAgICAgICAgIHRtLFxcbiAgICAgICAgICBpc19jb3B5LFxcbiAgICAgICAgICBwbjsgLy8gaWYgd2UgYXJlIG92ZXIgYW4gaW5zdGFuY2VcXG5cXG4gICAgICBpZiAoaW5zICYmIGlucy5fZGF0YSAmJiBpbnMuX2RhdGEuZG5kKSB7XFxuICAgICAgICBtYXJrZXIuYXR0cignY2xhc3MnLCAnanN0cmVlLScgKyBpbnMuZ2V0X3RoZW1lKCkgKyAoaW5zLnNldHRpbmdzLmNvcmUudGhlbWVzLnJlc3BvbnNpdmUgPyAnIGpzdHJlZS1kbmQtcmVzcG9uc2l2ZScgOiAnJykpO1xcbiAgICAgICAgaXNfY29weSA9IGRhdGEuZGF0YS5vcmlnaW4gJiYgKGRhdGEuZGF0YS5vcmlnaW4uc2V0dGluZ3MuZG5kLmFsd2F5c19jb3B5IHx8IGRhdGEuZGF0YS5vcmlnaW4uc2V0dGluZ3MuZG5kLmNvcHkgJiYgKGRhdGEuZXZlbnQubWV0YUtleSB8fCBkYXRhLmV2ZW50LmN0cmxLZXkpKTtcXG4gICAgICAgIGRhdGEuaGVscGVyLmNoaWxkcmVuKCkuYXR0cignY2xhc3MnLCAnanN0cmVlLScgKyBpbnMuZ2V0X3RoZW1lKCkgKyAnIGpzdHJlZS0nICsgaW5zLmdldF90aGVtZSgpICsgJy0nICsgaW5zLmdldF90aGVtZV92YXJpYW50KCkgKyAnICcgKyAoaW5zLnNldHRpbmdzLmNvcmUudGhlbWVzLnJlc3BvbnNpdmUgPyAnIGpzdHJlZS1kbmQtcmVzcG9uc2l2ZScgOiAnJykpLmZpbmQoJy5qc3RyZWUtY29weScpLmZpcnN0KClbaXNfY29weSA/ICdzaG93JyA6ICdoaWRlJ10oKTsgLy8gaWYgYXJlIGhvdmVyaW5nIHRoZSBjb250YWluZXIgaXRzZWxmIGFkZCBhIG5ldyByb290IG5vZGVcXG4gICAgICAgIC8vY29uc29sZS5sb2coZGF0YS5ldmVudCk7XFxuXFxuICAgICAgICBpZiAoKGRhdGEuZXZlbnQudGFyZ2V0ID09PSBpbnMuZWxlbWVudFswXSB8fCBkYXRhLmV2ZW50LnRhcmdldCA9PT0gaW5zLmdldF9jb250YWluZXJfdWwoKVswXSkgJiYgaW5zLmdldF9jb250YWluZXJfdWwoKS5jaGlsZHJlbigpLmxlbmd0aCA9PT0gMCkge1xcbiAgICAgICAgICBvayA9IHRydWU7XFxuXFxuICAgICAgICAgIGZvciAodDEgPSAwLCB0MiA9IGRhdGEuZGF0YS5ub2Rlcy5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcXG4gICAgICAgICAgICBvayA9IG9rICYmIGlucy5jaGVjayhkYXRhLmRhdGEub3JpZ2luICYmIChkYXRhLmRhdGEub3JpZ2luLnNldHRpbmdzLmRuZC5hbHdheXNfY29weSB8fCBkYXRhLmRhdGEub3JpZ2luLnNldHRpbmdzLmRuZC5jb3B5ICYmIChkYXRhLmV2ZW50Lm1ldGFLZXkgfHwgZGF0YS5ldmVudC5jdHJsS2V5KSkgPyBcXFwiY29weV9ub2RlXFxcIiA6IFxcXCJtb3ZlX25vZGVcXFwiLCBkYXRhLmRhdGEub3JpZ2luICYmIGRhdGEuZGF0YS5vcmlnaW4gIT09IGlucyA/IGRhdGEuZGF0YS5vcmlnaW4uZ2V0X25vZGUoZGF0YS5kYXRhLm5vZGVzW3QxXSkgOiBkYXRhLmRhdGEubm9kZXNbdDFdLCAkLmpzdHJlZS5yb290LCAnbGFzdCcsIHtcXG4gICAgICAgICAgICAgICdkbmQnOiB0cnVlLFxcbiAgICAgICAgICAgICAgJ3JlZic6IGlucy5nZXRfbm9kZSgkLmpzdHJlZS5yb290KSxcXG4gICAgICAgICAgICAgICdwb3MnOiAnaScsXFxuICAgICAgICAgICAgICAnb3JpZ2luJzogZGF0YS5kYXRhLm9yaWdpbixcXG4gICAgICAgICAgICAgICdpc19tdWx0aSc6IGRhdGEuZGF0YS5vcmlnaW4gJiYgZGF0YS5kYXRhLm9yaWdpbiAhPT0gaW5zLFxcbiAgICAgICAgICAgICAgJ2lzX2ZvcmVpZ24nOiAhZGF0YS5kYXRhLm9yaWdpblxcbiAgICAgICAgICAgIH0pO1xcblxcbiAgICAgICAgICAgIGlmICghb2spIHtcXG4gICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAob2spIHtcXG4gICAgICAgICAgICBsYXN0bXYgPSB7XFxuICAgICAgICAgICAgICAnaW5zJzogaW5zLFxcbiAgICAgICAgICAgICAgJ3Bhcic6ICQuanN0cmVlLnJvb3QsXFxuICAgICAgICAgICAgICAncG9zJzogJ2xhc3QnXFxuICAgICAgICAgICAgfTtcXG4gICAgICAgICAgICBtYXJrZXIuaGlkZSgpO1xcbiAgICAgICAgICAgIGRhdGEuaGVscGVyLmZpbmQoJy5qc3RyZWUtaWNvbicpLmZpcnN0KCkucmVtb3ZlQ2xhc3MoJ2pzdHJlZS1lcicpLmFkZENsYXNzKCdqc3RyZWUtb2snKTtcXG5cXG4gICAgICAgICAgICBpZiAoZGF0YS5ldmVudC5vcmlnaW5hbEV2ZW50ICYmIGRhdGEuZXZlbnQub3JpZ2luYWxFdmVudC5kYXRhVHJhbnNmZXIpIHtcXG4gICAgICAgICAgICAgIGRhdGEuZXZlbnQub3JpZ2luYWxFdmVudC5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9IGlzX2NvcHkgPyAnY29weScgOiAnbW92ZSc7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgLy8gaWYgd2UgYXJlIGhvdmVyaW5nIGEgdHJlZSBub2RlXFxuICAgICAgICAgIHJlZiA9IGlucy5zZXR0aW5ncy5kbmQubGFyZ2VfZHJvcF90YXJnZXQgPyAkKGRhdGEuZXZlbnQudGFyZ2V0KS5jbG9zZXN0KCcuanN0cmVlLW5vZGUnKS5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKSA6ICQoZGF0YS5ldmVudC50YXJnZXQpLmNsb3Nlc3QoJy5qc3RyZWUtYW5jaG9yJyk7XFxuXFxuICAgICAgICAgIGlmIChyZWYgJiYgcmVmLmxlbmd0aCAmJiByZWYucGFyZW50KCkuaXMoJy5qc3RyZWUtY2xvc2VkLCAuanN0cmVlLW9wZW4sIC5qc3RyZWUtbGVhZicpKSB7XFxuICAgICAgICAgICAgb2ZmID0gcmVmLm9mZnNldCgpO1xcbiAgICAgICAgICAgIHJlbCA9IChkYXRhLmV2ZW50LnBhZ2VZICE9PSB1bmRlZmluZWQgPyBkYXRhLmV2ZW50LnBhZ2VZIDogZGF0YS5ldmVudC5vcmlnaW5hbEV2ZW50LnBhZ2VZKSAtIG9mZi50b3A7XFxuICAgICAgICAgICAgaCA9IHJlZi5vdXRlckhlaWdodCgpO1xcblxcbiAgICAgICAgICAgIGlmIChyZWwgPCBoIC8gMykge1xcbiAgICAgICAgICAgICAgbyA9IFsnYicsICdpJywgJ2EnXTtcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlbCA+IGggLSBoIC8gMykge1xcbiAgICAgICAgICAgICAgbyA9IFsnYScsICdpJywgJ2InXTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgbyA9IHJlbCA+IGggLyAyID8gWydpJywgJ2EnLCAnYiddIDogWydpJywgJ2InLCAnYSddO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAkLmVhY2gobywgZnVuY3Rpb24gKGosIHYpIHtcXG4gICAgICAgICAgICAgIHN3aXRjaCAodikge1xcbiAgICAgICAgICAgICAgICBjYXNlICdiJzpcXG4gICAgICAgICAgICAgICAgICBsID0gb2ZmLmxlZnQgLSA2O1xcbiAgICAgICAgICAgICAgICAgIHQgPSBvZmYudG9wO1xcbiAgICAgICAgICAgICAgICAgIHAgPSBpbnMuZ2V0X3BhcmVudChyZWYpO1xcbiAgICAgICAgICAgICAgICAgIGkgPSByZWYucGFyZW50KCkuaW5kZXgoKTtcXG4gICAgICAgICAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgICAgICAgICAgY2FzZSAnaSc6XFxuICAgICAgICAgICAgICAgICAgaXAgPSBpbnMuc2V0dGluZ3MuZG5kLmluc2lkZV9wb3M7XFxuICAgICAgICAgICAgICAgICAgdG0gPSBpbnMuZ2V0X25vZGUocmVmLnBhcmVudCgpKTtcXG4gICAgICAgICAgICAgICAgICBsID0gb2ZmLmxlZnQgLSAyO1xcbiAgICAgICAgICAgICAgICAgIHQgPSBvZmYudG9wICsgaCAvIDIgKyAxO1xcbiAgICAgICAgICAgICAgICAgIHAgPSB0bS5pZDtcXG4gICAgICAgICAgICAgICAgICBpID0gaXAgPT09ICdmaXJzdCcgPyAwIDogaXAgPT09ICdsYXN0JyA/IHRtLmNoaWxkcmVuLmxlbmd0aCA6IE1hdGgubWluKGlwLCB0bS5jaGlsZHJlbi5sZW5ndGgpO1xcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICAgICAgICBjYXNlICdhJzpcXG4gICAgICAgICAgICAgICAgICBsID0gb2ZmLmxlZnQgLSA2O1xcbiAgICAgICAgICAgICAgICAgIHQgPSBvZmYudG9wICsgaDtcXG4gICAgICAgICAgICAgICAgICBwID0gaW5zLmdldF9wYXJlbnQocmVmKTtcXG4gICAgICAgICAgICAgICAgICBpID0gcmVmLnBhcmVudCgpLmluZGV4KCkgKyAxO1xcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgb2sgPSB0cnVlO1xcblxcbiAgICAgICAgICAgICAgZm9yICh0MSA9IDAsIHQyID0gZGF0YS5kYXRhLm5vZGVzLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xcbiAgICAgICAgICAgICAgICBvcCA9IGRhdGEuZGF0YS5vcmlnaW4gJiYgKGRhdGEuZGF0YS5vcmlnaW4uc2V0dGluZ3MuZG5kLmFsd2F5c19jb3B5IHx8IGRhdGEuZGF0YS5vcmlnaW4uc2V0dGluZ3MuZG5kLmNvcHkgJiYgKGRhdGEuZXZlbnQubWV0YUtleSB8fCBkYXRhLmV2ZW50LmN0cmxLZXkpKSA/IFxcXCJjb3B5X25vZGVcXFwiIDogXFxcIm1vdmVfbm9kZVxcXCI7XFxuICAgICAgICAgICAgICAgIHBzID0gaTtcXG5cXG4gICAgICAgICAgICAgICAgaWYgKG9wID09PSBcXFwibW92ZV9ub2RlXFxcIiAmJiB2ID09PSAnYScgJiYgZGF0YS5kYXRhLm9yaWdpbiAmJiBkYXRhLmRhdGEub3JpZ2luID09PSBpbnMgJiYgcCA9PT0gaW5zLmdldF9wYXJlbnQoZGF0YS5kYXRhLm5vZGVzW3QxXSkpIHtcXG4gICAgICAgICAgICAgICAgICBwciA9IGlucy5nZXRfbm9kZShwKTtcXG5cXG4gICAgICAgICAgICAgICAgICBpZiAocHMgPiAkLmluQXJyYXkoZGF0YS5kYXRhLm5vZGVzW3QxXSwgcHIuY2hpbGRyZW4pKSB7XFxuICAgICAgICAgICAgICAgICAgICBwcyAtPSAxO1xcbiAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICBvayA9IG9rICYmIChpbnMgJiYgaW5zLnNldHRpbmdzICYmIGlucy5zZXR0aW5ncy5kbmQgJiYgaW5zLnNldHRpbmdzLmRuZC5jaGVja193aGlsZV9kcmFnZ2luZyA9PT0gZmFsc2UgfHwgaW5zLmNoZWNrKG9wLCBkYXRhLmRhdGEub3JpZ2luICYmIGRhdGEuZGF0YS5vcmlnaW4gIT09IGlucyA/IGRhdGEuZGF0YS5vcmlnaW4uZ2V0X25vZGUoZGF0YS5kYXRhLm5vZGVzW3QxXSkgOiBkYXRhLmRhdGEubm9kZXNbdDFdLCBwLCBwcywge1xcbiAgICAgICAgICAgICAgICAgICdkbmQnOiB0cnVlLFxcbiAgICAgICAgICAgICAgICAgICdyZWYnOiBpbnMuZ2V0X25vZGUocmVmLnBhcmVudCgpKSxcXG4gICAgICAgICAgICAgICAgICAncG9zJzogdixcXG4gICAgICAgICAgICAgICAgICAnb3JpZ2luJzogZGF0YS5kYXRhLm9yaWdpbixcXG4gICAgICAgICAgICAgICAgICAnaXNfbXVsdGknOiBkYXRhLmRhdGEub3JpZ2luICYmIGRhdGEuZGF0YS5vcmlnaW4gIT09IGlucyxcXG4gICAgICAgICAgICAgICAgICAnaXNfZm9yZWlnbic6ICFkYXRhLmRhdGEub3JpZ2luXFxuICAgICAgICAgICAgICAgIH0pKTtcXG5cXG4gICAgICAgICAgICAgICAgaWYgKCFvaykge1xcbiAgICAgICAgICAgICAgICAgIGlmIChpbnMgJiYgaW5zLmxhc3RfZXJyb3IpIHtcXG4gICAgICAgICAgICAgICAgICAgIGxhc3RlciA9IGlucy5sYXN0X2Vycm9yKCk7XFxuICAgICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICBpZiAodiA9PT0gJ2knICYmIHJlZi5wYXJlbnQoKS5pcygnLmpzdHJlZS1jbG9zZWQnKSAmJiBpbnMuc2V0dGluZ3MuZG5kLm9wZW5fdGltZW91dCkge1xcbiAgICAgICAgICAgICAgICBvcGVudG8gPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICh4LCB6KSB7XFxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgICAgIHgub3Blbl9ub2RlKHopO1xcbiAgICAgICAgICAgICAgICAgIH07XFxuICAgICAgICAgICAgICAgIH0oaW5zLCByZWYpLCBpbnMuc2V0dGluZ3MuZG5kLm9wZW5fdGltZW91dCk7XFxuICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICBpZiAob2spIHtcXG4gICAgICAgICAgICAgICAgcG4gPSBpbnMuZ2V0X25vZGUocCwgdHJ1ZSk7XFxuXFxuICAgICAgICAgICAgICAgIGlmICghcG4uaGFzQ2xhc3MoJy5qc3RyZWUtZG5kLXBhcmVudCcpKSB7XFxuICAgICAgICAgICAgICAgICAgJCgnLmpzdHJlZS1kbmQtcGFyZW50JykucmVtb3ZlQ2xhc3MoJ2pzdHJlZS1kbmQtcGFyZW50Jyk7XFxuICAgICAgICAgICAgICAgICAgcG4uYWRkQ2xhc3MoJ2pzdHJlZS1kbmQtcGFyZW50Jyk7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgbGFzdG12ID0ge1xcbiAgICAgICAgICAgICAgICAgICdpbnMnOiBpbnMsXFxuICAgICAgICAgICAgICAgICAgJ3Bhcic6IHAsXFxuICAgICAgICAgICAgICAgICAgJ3Bvcyc6IHYgPT09ICdpJyAmJiBpcCA9PT0gJ2xhc3QnICYmIGkgPT09IDAgJiYgIWlucy5pc19sb2FkZWQodG0pID8gJ2xhc3QnIDogaVxcbiAgICAgICAgICAgICAgICB9O1xcbiAgICAgICAgICAgICAgICBtYXJrZXIuY3NzKHtcXG4gICAgICAgICAgICAgICAgICAnbGVmdCc6IGwgKyAncHgnLFxcbiAgICAgICAgICAgICAgICAgICd0b3AnOiB0ICsgJ3B4J1xcbiAgICAgICAgICAgICAgICB9KS5zaG93KCk7XFxuICAgICAgICAgICAgICAgIGRhdGEuaGVscGVyLmZpbmQoJy5qc3RyZWUtaWNvbicpLmZpcnN0KCkucmVtb3ZlQ2xhc3MoJ2pzdHJlZS1lcicpLmFkZENsYXNzKCdqc3RyZWUtb2snKTtcXG5cXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuZXZlbnQub3JpZ2luYWxFdmVudCAmJiBkYXRhLmV2ZW50Lm9yaWdpbmFsRXZlbnQuZGF0YVRyYW5zZmVyKSB7XFxuICAgICAgICAgICAgICAgICAgZGF0YS5ldmVudC5vcmlnaW5hbEV2ZW50LmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gaXNfY29weSA/ICdjb3B5JyA6ICdtb3ZlJztcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICBsYXN0ZXIgPSB7fTtcXG4gICAgICAgICAgICAgICAgbyA9IHRydWU7XFxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KTtcXG5cXG4gICAgICAgICAgICBpZiAobyA9PT0gdHJ1ZSkge1xcbiAgICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICAkKCcuanN0cmVlLWRuZC1wYXJlbnQnKS5yZW1vdmVDbGFzcygnanN0cmVlLWRuZC1wYXJlbnQnKTtcXG4gICAgICBsYXN0bXYgPSBmYWxzZTtcXG4gICAgICBkYXRhLmhlbHBlci5maW5kKCcuanN0cmVlLWljb24nKS5yZW1vdmVDbGFzcygnanN0cmVlLW9rJykuYWRkQ2xhc3MoJ2pzdHJlZS1lcicpO1xcblxcbiAgICAgIGlmIChkYXRhLmV2ZW50Lm9yaWdpbmFsRXZlbnQgJiYgZGF0YS5ldmVudC5vcmlnaW5hbEV2ZW50LmRhdGFUcmFuc2Zlcikge1xcbiAgICAgICAgZGF0YS5ldmVudC5vcmlnaW5hbEV2ZW50LmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gJ25vbmUnO1xcbiAgICAgIH1cXG5cXG4gICAgICBtYXJrZXIuaGlkZSgpO1xcbiAgICB9KS5vbignZG5kX3Njcm9sbC52YWthdGEuanN0cmVlJywgZnVuY3Rpb24gKGUsIGRhdGEpIHtcXG4gICAgICBpZiAoIWRhdGEgfHwgIWRhdGEuZGF0YSB8fCAhZGF0YS5kYXRhLmpzdHJlZSkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBtYXJrZXIuaGlkZSgpO1xcbiAgICAgIGxhc3RtdiA9IGZhbHNlO1xcbiAgICAgIGxhc3RldiA9IGZhbHNlO1xcbiAgICAgIGRhdGEuaGVscGVyLmZpbmQoJy5qc3RyZWUtaWNvbicpLmZpcnN0KCkucmVtb3ZlQ2xhc3MoJ2pzdHJlZS1vaycpLmFkZENsYXNzKCdqc3RyZWUtZXInKTtcXG4gICAgfSkub24oJ2RuZF9zdG9wLnZha2F0YS5qc3RyZWUnLCBmdW5jdGlvbiAoZSwgZGF0YSkge1xcbiAgICAgICQoJy5qc3RyZWUtZG5kLXBhcmVudCcpLnJlbW92ZUNsYXNzKCdqc3RyZWUtZG5kLXBhcmVudCcpO1xcblxcbiAgICAgIGlmIChvcGVudG8pIHtcXG4gICAgICAgIGNsZWFyVGltZW91dChvcGVudG8pO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIWRhdGEgfHwgIWRhdGEuZGF0YSB8fCAhZGF0YS5kYXRhLmpzdHJlZSkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBtYXJrZXIuaGlkZSgpLmRldGFjaCgpO1xcbiAgICAgIHZhciBpLFxcbiAgICAgICAgICBqLFxcbiAgICAgICAgICBub2RlcyA9IFtdO1xcblxcbiAgICAgIGlmIChsYXN0bXYpIHtcXG4gICAgICAgIGZvciAoaSA9IDAsIGogPSBkYXRhLmRhdGEubm9kZXMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICAgIG5vZGVzW2ldID0gZGF0YS5kYXRhLm9yaWdpbiA/IGRhdGEuZGF0YS5vcmlnaW4uZ2V0X25vZGUoZGF0YS5kYXRhLm5vZGVzW2ldKSA6IGRhdGEuZGF0YS5ub2Rlc1tpXTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGxhc3Rtdi5pbnNbZGF0YS5kYXRhLm9yaWdpbiAmJiAoZGF0YS5kYXRhLm9yaWdpbi5zZXR0aW5ncy5kbmQuYWx3YXlzX2NvcHkgfHwgZGF0YS5kYXRhLm9yaWdpbi5zZXR0aW5ncy5kbmQuY29weSAmJiAoZGF0YS5ldmVudC5tZXRhS2V5IHx8IGRhdGEuZXZlbnQuY3RybEtleSkpID8gJ2NvcHlfbm9kZScgOiAnbW92ZV9ub2RlJ10obm9kZXMsIGxhc3Rtdi5wYXIsIGxhc3Rtdi5wb3MsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGRhdGEuZGF0YS5vcmlnaW4pO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBpID0gJChkYXRhLmV2ZW50LnRhcmdldCkuY2xvc2VzdCgnLmpzdHJlZScpO1xcblxcbiAgICAgICAgaWYgKGkubGVuZ3RoICYmIGxhc3RlciAmJiBsYXN0ZXIuZXJyb3IgJiYgbGFzdGVyLmVycm9yID09PSAnY2hlY2snKSB7XFxuICAgICAgICAgIGkgPSBpLmpzdHJlZSh0cnVlKTtcXG5cXG4gICAgICAgICAgaWYgKGkpIHtcXG4gICAgICAgICAgICBpLnNldHRpbmdzLmNvcmUuZXJyb3IuY2FsbCh0aGlzLCBsYXN0ZXIpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGxhc3RldiA9IGZhbHNlO1xcbiAgICAgIGxhc3RtdiA9IGZhbHNlO1xcbiAgICB9KS5vbigna2V5dXAuanN0cmVlIGtleWRvd24uanN0cmVlJywgZnVuY3Rpb24gKGUsIGRhdGEpIHtcXG4gICAgICBkYXRhID0gJC52YWthdGEuZG5kLl9nZXQoKTtcXG5cXG4gICAgICBpZiAoZGF0YSAmJiBkYXRhLmRhdGEgJiYgZGF0YS5kYXRhLmpzdHJlZSkge1xcbiAgICAgICAgaWYgKGUudHlwZSA9PT0gXFxcImtleXVwXFxcIiAmJiBlLndoaWNoID09PSAyNykge1xcbiAgICAgICAgICBpZiAob3BlbnRvKSB7XFxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KG9wZW50byk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgbGFzdG12ID0gZmFsc2U7XFxuICAgICAgICAgIGxhc3RlciA9IGZhbHNlO1xcbiAgICAgICAgICBsYXN0ZXYgPSBmYWxzZTtcXG4gICAgICAgICAgb3BlbnRvID0gZmFsc2U7XFxuICAgICAgICAgIG1hcmtlci5oaWRlKCkuZGV0YWNoKCk7XFxuXFxuICAgICAgICAgICQudmFrYXRhLmRuZC5fY2xlYW4oKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGRhdGEuaGVscGVyLmZpbmQoJy5qc3RyZWUtY29weScpLmZpcnN0KClbZGF0YS5kYXRhLm9yaWdpbiAmJiAoZGF0YS5kYXRhLm9yaWdpbi5zZXR0aW5ncy5kbmQuYWx3YXlzX2NvcHkgfHwgZGF0YS5kYXRhLm9yaWdpbi5zZXR0aW5ncy5kbmQuY29weSAmJiAoZS5tZXRhS2V5IHx8IGUuY3RybEtleSkpID8gJ3Nob3cnIDogJ2hpZGUnXSgpO1xcblxcbiAgICAgICAgICBpZiAobGFzdGV2KSB7XFxuICAgICAgICAgICAgbGFzdGV2Lm1ldGFLZXkgPSBlLm1ldGFLZXk7XFxuICAgICAgICAgICAgbGFzdGV2LmN0cmxLZXkgPSBlLmN0cmxLZXk7XFxuXFxuICAgICAgICAgICAgJC52YWthdGEuZG5kLl90cmlnZ2VyKCdtb3ZlJywgbGFzdGV2KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfSk7XFxuICB9KTsgLy8gaGVscGVyc1xcblxcbiAgKGZ1bmN0aW9uICgkKSB7XFxuICAgICQudmFrYXRhLmh0bWwgPSB7XFxuICAgICAgZGl2OiAkKCc8ZGl2IC8+JyksXFxuICAgICAgZXNjYXBlOiBmdW5jdGlvbiBlc2NhcGUoc3RyKSB7XFxuICAgICAgICByZXR1cm4gJC52YWthdGEuaHRtbC5kaXYudGV4dChzdHIpLmh0bWwoKTtcXG4gICAgICB9LFxcbiAgICAgIHN0cmlwOiBmdW5jdGlvbiBzdHJpcChzdHIpIHtcXG4gICAgICAgIHJldHVybiAkLnZha2F0YS5odG1sLmRpdi5lbXB0eSgpLmFwcGVuZCgkLnBhcnNlSFRNTChzdHIpKS50ZXh0KCk7XFxuICAgICAgfVxcbiAgICB9OyAvLyBwcml2YXRlIHZhcmlhYmxlXFxuXFxuICAgIHZhciB2YWthdGFfZG5kID0ge1xcbiAgICAgIGVsZW1lbnQ6IGZhbHNlLFxcbiAgICAgIHRhcmdldDogZmFsc2UsXFxuICAgICAgaXNfZG93bjogZmFsc2UsXFxuICAgICAgaXNfZHJhZzogZmFsc2UsXFxuICAgICAgaGVscGVyOiBmYWxzZSxcXG4gICAgICBoZWxwZXJfdzogMCxcXG4gICAgICBkYXRhOiBmYWxzZSxcXG4gICAgICBpbml0X3g6IDAsXFxuICAgICAgaW5pdF95OiAwLFxcbiAgICAgIHNjcm9sbF9sOiAwLFxcbiAgICAgIHNjcm9sbF90OiAwLFxcbiAgICAgIHNjcm9sbF9lOiBmYWxzZSxcXG4gICAgICBzY3JvbGxfaTogZmFsc2UsXFxuICAgICAgaXNfdG91Y2g6IGZhbHNlXFxuICAgIH07XFxuICAgICQudmFrYXRhLmRuZCA9IHtcXG4gICAgICBzZXR0aW5nczoge1xcbiAgICAgICAgc2Nyb2xsX3NwZWVkOiAxMCxcXG4gICAgICAgIHNjcm9sbF9wcm94aW1pdHk6IDIwLFxcbiAgICAgICAgaGVscGVyX2xlZnQ6IDUsXFxuICAgICAgICBoZWxwZXJfdG9wOiAxMCxcXG4gICAgICAgIHRocmVzaG9sZDogNSxcXG4gICAgICAgIHRocmVzaG9sZF90b3VjaDogNTBcXG4gICAgICB9LFxcbiAgICAgIF90cmlnZ2VyOiBmdW5jdGlvbiBfdHJpZ2dlcihldmVudF9uYW1lLCBlLCBkYXRhKSB7XFxuICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgIGRhdGEgPSAkLnZha2F0YS5kbmQuX2dldCgpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZGF0YS5ldmVudCA9IGU7XFxuICAgICAgICAkKGRvY3VtZW50KS50cmlnZ2VySGFuZGxlcihcXFwiZG5kX1xcXCIgKyBldmVudF9uYW1lICsgXFxcIi52YWthdGFcXFwiLCBkYXRhKTtcXG4gICAgICB9LFxcbiAgICAgIF9nZXQ6IGZ1bmN0aW9uIF9nZXQoKSB7XFxuICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICBcXFwiZGF0YVxcXCI6IHZha2F0YV9kbmQuZGF0YSxcXG4gICAgICAgICAgXFxcImVsZW1lbnRcXFwiOiB2YWthdGFfZG5kLmVsZW1lbnQsXFxuICAgICAgICAgIFxcXCJoZWxwZXJcXFwiOiB2YWthdGFfZG5kLmhlbHBlclxcbiAgICAgICAgfTtcXG4gICAgICB9LFxcbiAgICAgIF9jbGVhbjogZnVuY3Rpb24gX2NsZWFuKCkge1xcbiAgICAgICAgaWYgKHZha2F0YV9kbmQuaGVscGVyKSB7XFxuICAgICAgICAgIHZha2F0YV9kbmQuaGVscGVyLnJlbW92ZSgpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKHZha2F0YV9kbmQuc2Nyb2xsX2kpIHtcXG4gICAgICAgICAgY2xlYXJJbnRlcnZhbCh2YWthdGFfZG5kLnNjcm9sbF9pKTtcXG4gICAgICAgICAgdmFrYXRhX2RuZC5zY3JvbGxfaSA9IGZhbHNlO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdmFrYXRhX2RuZCA9IHtcXG4gICAgICAgICAgZWxlbWVudDogZmFsc2UsXFxuICAgICAgICAgIHRhcmdldDogZmFsc2UsXFxuICAgICAgICAgIGlzX2Rvd246IGZhbHNlLFxcbiAgICAgICAgICBpc19kcmFnOiBmYWxzZSxcXG4gICAgICAgICAgaGVscGVyOiBmYWxzZSxcXG4gICAgICAgICAgaGVscGVyX3c6IDAsXFxuICAgICAgICAgIGRhdGE6IGZhbHNlLFxcbiAgICAgICAgICBpbml0X3g6IDAsXFxuICAgICAgICAgIGluaXRfeTogMCxcXG4gICAgICAgICAgc2Nyb2xsX2w6IDAsXFxuICAgICAgICAgIHNjcm9sbF90OiAwLFxcbiAgICAgICAgICBzY3JvbGxfZTogZmFsc2UsXFxuICAgICAgICAgIHNjcm9sbF9pOiBmYWxzZSxcXG4gICAgICAgICAgaXNfdG91Y2g6IGZhbHNlXFxuICAgICAgICB9O1xcbiAgICAgICAgJChkb2N1bWVudCkub2ZmKFxcXCJtb3VzZW1vdmUudmFrYXRhLmpzdHJlZSB0b3VjaG1vdmUudmFrYXRhLmpzdHJlZVxcXCIsICQudmFrYXRhLmRuZC5kcmFnKTtcXG4gICAgICAgICQoZG9jdW1lbnQpLm9mZihcXFwibW91c2V1cC52YWthdGEuanN0cmVlIHRvdWNoZW5kLnZha2F0YS5qc3RyZWVcXFwiLCAkLnZha2F0YS5kbmQuc3RvcCk7XFxuICAgICAgfSxcXG4gICAgICBfc2Nyb2xsOiBmdW5jdGlvbiBfc2Nyb2xsKGluaXRfb25seSkge1xcbiAgICAgICAgaWYgKCF2YWthdGFfZG5kLnNjcm9sbF9lIHx8ICF2YWthdGFfZG5kLnNjcm9sbF9sICYmICF2YWthdGFfZG5kLnNjcm9sbF90KSB7XFxuICAgICAgICAgIGlmICh2YWthdGFfZG5kLnNjcm9sbF9pKSB7XFxuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh2YWthdGFfZG5kLnNjcm9sbF9pKTtcXG4gICAgICAgICAgICB2YWthdGFfZG5kLnNjcm9sbF9pID0gZmFsc2U7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKCF2YWthdGFfZG5kLnNjcm9sbF9pKSB7XFxuICAgICAgICAgIHZha2F0YV9kbmQuc2Nyb2xsX2kgPSBzZXRJbnRlcnZhbCgkLnZha2F0YS5kbmQuX3Njcm9sbCwgMTAwKTtcXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKGluaXRfb25seSA9PT0gdHJ1ZSkge1xcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB2YXIgaSA9IHZha2F0YV9kbmQuc2Nyb2xsX2Uuc2Nyb2xsVG9wKCksXFxuICAgICAgICAgICAgaiA9IHZha2F0YV9kbmQuc2Nyb2xsX2Uuc2Nyb2xsTGVmdCgpO1xcbiAgICAgICAgdmFrYXRhX2RuZC5zY3JvbGxfZS5zY3JvbGxUb3AoaSArIHZha2F0YV9kbmQuc2Nyb2xsX3QgKiAkLnZha2F0YS5kbmQuc2V0dGluZ3Muc2Nyb2xsX3NwZWVkKTtcXG4gICAgICAgIHZha2F0YV9kbmQuc2Nyb2xsX2Uuc2Nyb2xsTGVmdChqICsgdmFrYXRhX2RuZC5zY3JvbGxfbCAqICQudmFrYXRhLmRuZC5zZXR0aW5ncy5zY3JvbGxfc3BlZWQpO1xcblxcbiAgICAgICAgaWYgKGkgIT09IHZha2F0YV9kbmQuc2Nyb2xsX2Uuc2Nyb2xsVG9wKCkgfHwgaiAhPT0gdmFrYXRhX2RuZC5zY3JvbGxfZS5zY3JvbGxMZWZ0KCkpIHtcXG4gICAgICAgICAgLyoqXFxuICAgICAgICAgICAqIHRyaWdnZXJlZCBvbiB0aGUgZG9jdW1lbnQgd2hlbiBhIGRyYWcgY2F1c2VzIGFuIGVsZW1lbnQgdG8gc2Nyb2xsXFxuICAgICAgICAgICAqIEBldmVudFxcbiAgICAgICAgICAgKiBAcGx1Z2luIGRuZFxcbiAgICAgICAgICAgKiBAbmFtZSBkbmRfc2Nyb2xsLnZha2F0YVxcbiAgICAgICAgICAgKiBAcGFyYW0ge01peGVkfSBkYXRhIGFueSBkYXRhIHN1cHBsaWVkIHdpdGggdGhlIGNhbGwgdG8gJC52YWthdGEuZG5kLnN0YXJ0XFxuICAgICAgICAgICAqIEBwYXJhbSB7RE9NfSBlbGVtZW50IHRoZSBET00gZWxlbWVudCBiZWluZyBkcmFnZ2VkXFxuICAgICAgICAgICAqIEBwYXJhbSB7alF1ZXJ5fSBoZWxwZXIgdGhlIGhlbHBlciBzaG93biBuZXh0IHRvIHRoZSBtb3VzZVxcbiAgICAgICAgICAgKiBAcGFyYW0ge2pRdWVyeX0gZXZlbnQgdGhlIGVsZW1lbnQgdGhhdCBpcyBzY3JvbGxpbmdcXG4gICAgICAgICAgICovXFxuICAgICAgICAgICQudmFrYXRhLmRuZC5fdHJpZ2dlcihcXFwic2Nyb2xsXFxcIiwgdmFrYXRhX2RuZC5zY3JvbGxfZSk7XFxuICAgICAgICB9XFxuICAgICAgfSxcXG4gICAgICBzdGFydDogZnVuY3Rpb24gc3RhcnQoZSwgZGF0YSwgaHRtbCkge1xcbiAgICAgICAgaWYgKGUudHlwZSA9PT0gXFxcInRvdWNoc3RhcnRcXFwiICYmIGUub3JpZ2luYWxFdmVudCAmJiBlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXMgJiYgZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdKSB7XFxuICAgICAgICAgIGUucGFnZVggPSBlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVg7XFxuICAgICAgICAgIGUucGFnZVkgPSBlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVk7XFxuICAgICAgICAgIGUudGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVggLSB3aW5kb3cucGFnZVhPZmZzZXQsIGUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWSAtIHdpbmRvdy5wYWdlWU9mZnNldCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAodmFrYXRhX2RuZC5pc19kcmFnKSB7XFxuICAgICAgICAgICQudmFrYXRhLmRuZC5zdG9wKHt9KTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgIGUuY3VycmVudFRhcmdldC51bnNlbGVjdGFibGUgPSBcXFwib25cXFwiO1xcblxcbiAgICAgICAgICBlLmN1cnJlbnRUYXJnZXQub25zZWxlY3RzdGFydCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICAgIH07XFxuXFxuICAgICAgICAgIGlmIChlLmN1cnJlbnRUYXJnZXQuc3R5bGUpIHtcXG4gICAgICAgICAgICBlLmN1cnJlbnRUYXJnZXQuc3R5bGUudG91Y2hBY3Rpb24gPSBcXFwibm9uZVxcXCI7XFxuICAgICAgICAgICAgZS5jdXJyZW50VGFyZ2V0LnN0eWxlLm1zVG91Y2hBY3Rpb24gPSBcXFwibm9uZVxcXCI7XFxuICAgICAgICAgICAgZS5jdXJyZW50VGFyZ2V0LnN0eWxlLk1velVzZXJTZWxlY3QgPSBcXFwibm9uZVxcXCI7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cXG5cXG4gICAgICAgIHZha2F0YV9kbmQuaW5pdF94ID0gZS5wYWdlWDtcXG4gICAgICAgIHZha2F0YV9kbmQuaW5pdF95ID0gZS5wYWdlWTtcXG4gICAgICAgIHZha2F0YV9kbmQuZGF0YSA9IGRhdGE7XFxuICAgICAgICB2YWthdGFfZG5kLmlzX2Rvd24gPSB0cnVlO1xcbiAgICAgICAgdmFrYXRhX2RuZC5lbGVtZW50ID0gZS5jdXJyZW50VGFyZ2V0O1xcbiAgICAgICAgdmFrYXRhX2RuZC50YXJnZXQgPSBlLnRhcmdldDtcXG4gICAgICAgIHZha2F0YV9kbmQuaXNfdG91Y2ggPSBlLnR5cGUgPT09IFxcXCJ0b3VjaHN0YXJ0XFxcIjtcXG5cXG4gICAgICAgIGlmIChodG1sICE9PSBmYWxzZSkge1xcbiAgICAgICAgICB2YWthdGFfZG5kLmhlbHBlciA9ICQoXFxcIjxkaXYgaWQ9J3Zha2F0YS1kbmQnPjwvZGl2PlxcXCIpLmh0bWwoaHRtbCkuY3NzKHtcXG4gICAgICAgICAgICBcXFwiZGlzcGxheVxcXCI6IFxcXCJibG9ja1xcXCIsXFxuICAgICAgICAgICAgXFxcIm1hcmdpblxcXCI6IFxcXCIwXFxcIixcXG4gICAgICAgICAgICBcXFwicGFkZGluZ1xcXCI6IFxcXCIwXFxcIixcXG4gICAgICAgICAgICBcXFwicG9zaXRpb25cXFwiOiBcXFwiYWJzb2x1dGVcXFwiLFxcbiAgICAgICAgICAgIFxcXCJ0b3BcXFwiOiBcXFwiLTIwMDBweFxcXCIsXFxuICAgICAgICAgICAgXFxcImxpbmVIZWlnaHRcXFwiOiBcXFwiMTZweFxcXCIsXFxuICAgICAgICAgICAgXFxcInpJbmRleFxcXCI6IFxcXCIxMDAwMFxcXCJcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICAkKGRvY3VtZW50KS5vbihcXFwibW91c2Vtb3ZlLnZha2F0YS5qc3RyZWUgdG91Y2htb3ZlLnZha2F0YS5qc3RyZWVcXFwiLCAkLnZha2F0YS5kbmQuZHJhZyk7XFxuICAgICAgICAkKGRvY3VtZW50KS5vbihcXFwibW91c2V1cC52YWthdGEuanN0cmVlIHRvdWNoZW5kLnZha2F0YS5qc3RyZWVcXFwiLCAkLnZha2F0YS5kbmQuc3RvcCk7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfSxcXG4gICAgICBkcmFnOiBmdW5jdGlvbiBkcmFnKGUpIHtcXG4gICAgICAgIGlmIChlLnR5cGUgPT09IFxcXCJ0b3VjaG1vdmVcXFwiICYmIGUub3JpZ2luYWxFdmVudCAmJiBlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXMgJiYgZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdKSB7XFxuICAgICAgICAgIGUucGFnZVggPSBlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVg7XFxuICAgICAgICAgIGUucGFnZVkgPSBlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVk7XFxuICAgICAgICAgIGUudGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVggLSB3aW5kb3cucGFnZVhPZmZzZXQsIGUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWSAtIHdpbmRvdy5wYWdlWU9mZnNldCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoIXZha2F0YV9kbmQuaXNfZG93bikge1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoIXZha2F0YV9kbmQuaXNfZHJhZykge1xcbiAgICAgICAgICBpZiAoTWF0aC5hYnMoZS5wYWdlWCAtIHZha2F0YV9kbmQuaW5pdF94KSA+ICh2YWthdGFfZG5kLmlzX3RvdWNoID8gJC52YWthdGEuZG5kLnNldHRpbmdzLnRocmVzaG9sZF90b3VjaCA6ICQudmFrYXRhLmRuZC5zZXR0aW5ncy50aHJlc2hvbGQpIHx8IE1hdGguYWJzKGUucGFnZVkgLSB2YWthdGFfZG5kLmluaXRfeSkgPiAodmFrYXRhX2RuZC5pc190b3VjaCA/ICQudmFrYXRhLmRuZC5zZXR0aW5ncy50aHJlc2hvbGRfdG91Y2ggOiAkLnZha2F0YS5kbmQuc2V0dGluZ3MudGhyZXNob2xkKSkge1xcbiAgICAgICAgICAgIGlmICh2YWthdGFfZG5kLmhlbHBlcikge1xcbiAgICAgICAgICAgICAgdmFrYXRhX2RuZC5oZWxwZXIuYXBwZW5kVG8oXFxcImJvZHlcXFwiKTtcXG4gICAgICAgICAgICAgIHZha2F0YV9kbmQuaGVscGVyX3cgPSB2YWthdGFfZG5kLmhlbHBlci5vdXRlcldpZHRoKCk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIHZha2F0YV9kbmQuaXNfZHJhZyA9IHRydWU7XFxuICAgICAgICAgICAgJCh2YWthdGFfZG5kLnRhcmdldCkub25lKCdjbGljay52YWthdGEnLCBmYWxzZSk7XFxuICAgICAgICAgICAgLyoqXFxuICAgICAgICAgICAgICogdHJpZ2dlcmVkIG9uIHRoZSBkb2N1bWVudCB3aGVuIGEgZHJhZyBzdGFydHNcXG4gICAgICAgICAgICAgKiBAZXZlbnRcXG4gICAgICAgICAgICAgKiBAcGx1Z2luIGRuZFxcbiAgICAgICAgICAgICAqIEBuYW1lIGRuZF9zdGFydC52YWthdGFcXG4gICAgICAgICAgICAgKiBAcGFyYW0ge01peGVkfSBkYXRhIGFueSBkYXRhIHN1cHBsaWVkIHdpdGggdGhlIGNhbGwgdG8gJC52YWthdGEuZG5kLnN0YXJ0XFxuICAgICAgICAgICAgICogQHBhcmFtIHtET019IGVsZW1lbnQgdGhlIERPTSBlbGVtZW50IGJlaW5nIGRyYWdnZWRcXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2pRdWVyeX0gaGVscGVyIHRoZSBoZWxwZXIgc2hvd24gbmV4dCB0byB0aGUgbW91c2VcXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgdGhlIGV2ZW50IHRoYXQgY2F1c2VkIHRoZSBzdGFydCAocHJvYmFibHkgbW91c2Vtb3ZlKVxcbiAgICAgICAgICAgICAqL1xcblxcbiAgICAgICAgICAgICQudmFrYXRhLmRuZC5fdHJpZ2dlcihcXFwic3RhcnRcXFwiLCBlKTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHZhciBkID0gZmFsc2UsXFxuICAgICAgICAgICAgdyA9IGZhbHNlLFxcbiAgICAgICAgICAgIGRoID0gZmFsc2UsXFxuICAgICAgICAgICAgd2ggPSBmYWxzZSxcXG4gICAgICAgICAgICBkdyA9IGZhbHNlLFxcbiAgICAgICAgICAgIHd3ID0gZmFsc2UsXFxuICAgICAgICAgICAgZHQgPSBmYWxzZSxcXG4gICAgICAgICAgICBkbCA9IGZhbHNlLFxcbiAgICAgICAgICAgIGh0ID0gZmFsc2UsXFxuICAgICAgICAgICAgaGwgPSBmYWxzZTtcXG4gICAgICAgIHZha2F0YV9kbmQuc2Nyb2xsX3QgPSAwO1xcbiAgICAgICAgdmFrYXRhX2RuZC5zY3JvbGxfbCA9IDA7XFxuICAgICAgICB2YWthdGFfZG5kLnNjcm9sbF9lID0gZmFsc2U7XFxuICAgICAgICAkKCQoZS50YXJnZXQpLnBhcmVudHNVbnRpbChcXFwiYm9keVxcXCIpLmFkZEJhY2soKS5nZXQoKS5yZXZlcnNlKCkpLmZpbHRlcihmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHJldHVybiAvXmF1dG98c2Nyb2xsJC8udGVzdCgkKHRoaXMpLmNzcyhcXFwib3ZlcmZsb3dcXFwiKSkgJiYgKHRoaXMuc2Nyb2xsSGVpZ2h0ID4gdGhpcy5vZmZzZXRIZWlnaHQgfHwgdGhpcy5zY3JvbGxXaWR0aCA+IHRoaXMub2Zmc2V0V2lkdGgpO1xcbiAgICAgICAgfSkuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHZhciB0ID0gJCh0aGlzKSxcXG4gICAgICAgICAgICAgIG8gPSB0Lm9mZnNldCgpO1xcblxcbiAgICAgICAgICBpZiAodGhpcy5zY3JvbGxIZWlnaHQgPiB0aGlzLm9mZnNldEhlaWdodCkge1xcbiAgICAgICAgICAgIGlmIChvLnRvcCArIHQuaGVpZ2h0KCkgLSBlLnBhZ2VZIDwgJC52YWthdGEuZG5kLnNldHRpbmdzLnNjcm9sbF9wcm94aW1pdHkpIHtcXG4gICAgICAgICAgICAgIHZha2F0YV9kbmQuc2Nyb2xsX3QgPSAxO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpZiAoZS5wYWdlWSAtIG8udG9wIDwgJC52YWthdGEuZG5kLnNldHRpbmdzLnNjcm9sbF9wcm94aW1pdHkpIHtcXG4gICAgICAgICAgICAgIHZha2F0YV9kbmQuc2Nyb2xsX3QgPSAtMTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaWYgKHRoaXMuc2Nyb2xsV2lkdGggPiB0aGlzLm9mZnNldFdpZHRoKSB7XFxuICAgICAgICAgICAgaWYgKG8ubGVmdCArIHQud2lkdGgoKSAtIGUucGFnZVggPCAkLnZha2F0YS5kbmQuc2V0dGluZ3Muc2Nyb2xsX3Byb3hpbWl0eSkge1xcbiAgICAgICAgICAgICAgdmFrYXRhX2RuZC5zY3JvbGxfbCA9IDE7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmIChlLnBhZ2VYIC0gby5sZWZ0IDwgJC52YWthdGEuZG5kLnNldHRpbmdzLnNjcm9sbF9wcm94aW1pdHkpIHtcXG4gICAgICAgICAgICAgIHZha2F0YV9kbmQuc2Nyb2xsX2wgPSAtMTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaWYgKHZha2F0YV9kbmQuc2Nyb2xsX3QgfHwgdmFrYXRhX2RuZC5zY3JvbGxfbCkge1xcbiAgICAgICAgICAgIHZha2F0YV9kbmQuc2Nyb2xsX2UgPSAkKHRoaXMpO1xcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuXFxuICAgICAgICBpZiAoIXZha2F0YV9kbmQuc2Nyb2xsX2UpIHtcXG4gICAgICAgICAgZCA9ICQoZG9jdW1lbnQpO1xcbiAgICAgICAgICB3ID0gJCh3aW5kb3cpO1xcbiAgICAgICAgICBkaCA9IGQuaGVpZ2h0KCk7XFxuICAgICAgICAgIHdoID0gdy5oZWlnaHQoKTtcXG4gICAgICAgICAgZHcgPSBkLndpZHRoKCk7XFxuICAgICAgICAgIHd3ID0gdy53aWR0aCgpO1xcbiAgICAgICAgICBkdCA9IGQuc2Nyb2xsVG9wKCk7XFxuICAgICAgICAgIGRsID0gZC5zY3JvbGxMZWZ0KCk7XFxuXFxuICAgICAgICAgIGlmIChkaCA+IHdoICYmIGUucGFnZVkgLSBkdCA8ICQudmFrYXRhLmRuZC5zZXR0aW5ncy5zY3JvbGxfcHJveGltaXR5KSB7XFxuICAgICAgICAgICAgdmFrYXRhX2RuZC5zY3JvbGxfdCA9IC0xO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmIChkaCA+IHdoICYmIHdoIC0gKGUucGFnZVkgLSBkdCkgPCAkLnZha2F0YS5kbmQuc2V0dGluZ3Muc2Nyb2xsX3Byb3hpbWl0eSkge1xcbiAgICAgICAgICAgIHZha2F0YV9kbmQuc2Nyb2xsX3QgPSAxO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmIChkdyA+IHd3ICYmIGUucGFnZVggLSBkbCA8ICQudmFrYXRhLmRuZC5zZXR0aW5ncy5zY3JvbGxfcHJveGltaXR5KSB7XFxuICAgICAgICAgICAgdmFrYXRhX2RuZC5zY3JvbGxfbCA9IC0xO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmIChkdyA+IHd3ICYmIHd3IC0gKGUucGFnZVggLSBkbCkgPCAkLnZha2F0YS5kbmQuc2V0dGluZ3Muc2Nyb2xsX3Byb3hpbWl0eSkge1xcbiAgICAgICAgICAgIHZha2F0YV9kbmQuc2Nyb2xsX2wgPSAxO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmICh2YWthdGFfZG5kLnNjcm9sbF90IHx8IHZha2F0YV9kbmQuc2Nyb2xsX2wpIHtcXG4gICAgICAgICAgICB2YWthdGFfZG5kLnNjcm9sbF9lID0gZDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKHZha2F0YV9kbmQuc2Nyb2xsX2UpIHtcXG4gICAgICAgICAgJC52YWthdGEuZG5kLl9zY3JvbGwodHJ1ZSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAodmFrYXRhX2RuZC5oZWxwZXIpIHtcXG4gICAgICAgICAgaHQgPSBwYXJzZUludChlLnBhZ2VZICsgJC52YWthdGEuZG5kLnNldHRpbmdzLmhlbHBlcl90b3AsIDEwKTtcXG4gICAgICAgICAgaGwgPSBwYXJzZUludChlLnBhZ2VYICsgJC52YWthdGEuZG5kLnNldHRpbmdzLmhlbHBlcl9sZWZ0LCAxMCk7XFxuXFxuICAgICAgICAgIGlmIChkaCAmJiBodCArIDI1ID4gZGgpIHtcXG4gICAgICAgICAgICBodCA9IGRoIC0gNTA7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaWYgKGR3ICYmIGhsICsgdmFrYXRhX2RuZC5oZWxwZXJfdyA+IGR3KSB7XFxuICAgICAgICAgICAgaGwgPSBkdyAtICh2YWthdGFfZG5kLmhlbHBlcl93ICsgMik7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgdmFrYXRhX2RuZC5oZWxwZXIuY3NzKHtcXG4gICAgICAgICAgICBsZWZ0OiBobCArIFxcXCJweFxcXCIsXFxuICAgICAgICAgICAgdG9wOiBodCArIFxcXCJweFxcXCJcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgICAvKipcXG4gICAgICAgICAqIHRyaWdnZXJlZCBvbiB0aGUgZG9jdW1lbnQgd2hlbiBhIGRyYWcgaXMgaW4gcHJvZ3Jlc3NcXG4gICAgICAgICAqIEBldmVudFxcbiAgICAgICAgICogQHBsdWdpbiBkbmRcXG4gICAgICAgICAqIEBuYW1lIGRuZF9tb3ZlLnZha2F0YVxcbiAgICAgICAgICogQHBhcmFtIHtNaXhlZH0gZGF0YSBhbnkgZGF0YSBzdXBwbGllZCB3aXRoIHRoZSBjYWxsIHRvICQudmFrYXRhLmRuZC5zdGFydFxcbiAgICAgICAgICogQHBhcmFtIHtET019IGVsZW1lbnQgdGhlIERPTSBlbGVtZW50IGJlaW5nIGRyYWdnZWRcXG4gICAgICAgICAqIEBwYXJhbSB7alF1ZXJ5fSBoZWxwZXIgdGhlIGhlbHBlciBzaG93biBuZXh0IHRvIHRoZSBtb3VzZVxcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IHRoZSBldmVudCB0aGF0IGNhdXNlZCB0aGlzIHRvIHRyaWdnZXIgKG1vc3QgbGlrZWx5IG1vdXNlbW92ZSlcXG4gICAgICAgICAqL1xcblxcblxcbiAgICAgICAgJC52YWthdGEuZG5kLl90cmlnZ2VyKFxcXCJtb3ZlXFxcIiwgZSk7XFxuXFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfSxcXG4gICAgICBzdG9wOiBmdW5jdGlvbiBzdG9wKGUpIHtcXG4gICAgICAgIGlmIChlLnR5cGUgPT09IFxcXCJ0b3VjaGVuZFxcXCIgJiYgZS5vcmlnaW5hbEV2ZW50ICYmIGUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlcyAmJiBlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0pIHtcXG4gICAgICAgICAgZS5wYWdlWCA9IGUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWDtcXG4gICAgICAgICAgZS5wYWdlWSA9IGUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWTtcXG4gICAgICAgICAgZS50YXJnZXQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KGUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWCAtIHdpbmRvdy5wYWdlWE9mZnNldCwgZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VZIC0gd2luZG93LnBhZ2VZT2Zmc2V0KTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICh2YWthdGFfZG5kLmlzX2RyYWcpIHtcXG4gICAgICAgICAgLyoqXFxuICAgICAgICAgICAqIHRyaWdnZXJlZCBvbiB0aGUgZG9jdW1lbnQgd2hlbiBhIGRyYWcgc3RvcHMgKHRoZSBkcmFnZ2VkIGVsZW1lbnQgaXMgZHJvcHBlZClcXG4gICAgICAgICAgICogQGV2ZW50XFxuICAgICAgICAgICAqIEBwbHVnaW4gZG5kXFxuICAgICAgICAgICAqIEBuYW1lIGRuZF9zdG9wLnZha2F0YVxcbiAgICAgICAgICAgKiBAcGFyYW0ge01peGVkfSBkYXRhIGFueSBkYXRhIHN1cHBsaWVkIHdpdGggdGhlIGNhbGwgdG8gJC52YWthdGEuZG5kLnN0YXJ0XFxuICAgICAgICAgICAqIEBwYXJhbSB7RE9NfSBlbGVtZW50IHRoZSBET00gZWxlbWVudCBiZWluZyBkcmFnZ2VkXFxuICAgICAgICAgICAqIEBwYXJhbSB7alF1ZXJ5fSBoZWxwZXIgdGhlIGhlbHBlciBzaG93biBuZXh0IHRvIHRoZSBtb3VzZVxcbiAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgdGhlIGV2ZW50IHRoYXQgY2F1c2VkIHRoZSBzdG9wXFxuICAgICAgICAgICAqL1xcbiAgICAgICAgICBpZiAoZS50YXJnZXQgIT09IHZha2F0YV9kbmQudGFyZ2V0KSB7XFxuICAgICAgICAgICAgJCh2YWthdGFfZG5kLnRhcmdldCkub2ZmKCdjbGljay52YWthdGEnKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICAkLnZha2F0YS5kbmQuX3RyaWdnZXIoXFxcInN0b3BcXFwiLCBlKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGlmIChlLnR5cGUgPT09IFxcXCJ0b3VjaGVuZFxcXCIgJiYgZS50YXJnZXQgPT09IHZha2F0YV9kbmQudGFyZ2V0KSB7XFxuICAgICAgICAgICAgdmFyIHRvID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAkKGUudGFyZ2V0KS5jbGljaygpO1xcbiAgICAgICAgICAgIH0sIDEwMCk7XFxuICAgICAgICAgICAgJChlLnRhcmdldCkub25lKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgIGlmICh0bykge1xcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodG8pO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICAkLnZha2F0YS5kbmQuX2NsZWFuKCk7XFxuXFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcbiAgICB9O1xcbiAgfSkoJCk7IC8vIGluY2x1ZGUgdGhlIGRuZCBwbHVnaW4gYnkgZGVmYXVsdFxcbiAgLy8gJC5qc3RyZWUuZGVmYXVsdHMucGx1Z2lucy5wdXNoKFxcXCJkbmRcXFwiKTtcXG5cXG4gIC8qKlxcbiAgICogIyMjIE1hc3Nsb2FkIHBsdWdpblxcbiAgICpcXG4gICAqIEFkZHMgbWFzc2xvYWQgZnVuY3Rpb25hbGl0eSB0byBqc1RyZWUsIHNvIHRoYXQgbXVsdGlwbGUgbm9kZXMgY2FuIGJlIGxvYWRlZCBpbiBhIHNpbmdsZSByZXF1ZXN0IChvbmx5IHVzZWZ1bCB3aXRoIGxhenkgbG9hZGluZykuXFxuICAgKi9cXG5cXG4gIC8qKlxcbiAgICogbWFzc2xvYWQgY29uZmlndXJhdGlvblxcbiAgICpcXG4gICAqIEl0IGlzIHBvc3NpYmxlIHRvIHNldCB0aGlzIHRvIGEgc3RhbmRhcmQgalF1ZXJ5LWxpa2UgQUpBWCBjb25maWcuXFxuICAgKiBJbiBhZGRpdGlvbiB0byB0aGUgc3RhbmRhcmQgalF1ZXJ5IGFqYXggb3B0aW9ucyBoZXJlIHlvdSBjYW4gc3VwcGx5IGZ1bmN0aW9ucyBmb3IgYGRhdGFgIGFuZCBgdXJsYCwgdGhlIGZ1bmN0aW9ucyB3aWxsIGJlIHJ1biBpbiB0aGUgY3VycmVudCBpbnN0YW5jZSdzIHNjb3BlIGFuZCBhIHBhcmFtIHdpbGwgYmUgcGFzc2VkIGluZGljYXRpbmcgd2hpY2ggbm9kZSBJRHMgbmVlZCB0byBiZSBsb2FkZWQsIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhvc2UgZnVuY3Rpb25zIHdpbGwgYmUgdXNlZC5cXG4gICAqXFxuICAgKiBZb3UgY2FuIGFsc28gc2V0IHRoaXMgdG8gYSBmdW5jdGlvbiwgdGhhdCBmdW5jdGlvbiB3aWxsIHJlY2VpdmUgdGhlIG5vZGUgSURzIGJlaW5nIGxvYWRlZCBhcyBhcmd1bWVudCBhbmQgYSBzZWNvbmQgcGFyYW0gd2hpY2ggaXMgYSBmdW5jdGlvbiAoY2FsbGJhY2spIHdoaWNoIHNob3VsZCBiZSBjYWxsZWQgd2l0aCB0aGUgcmVzdWx0LlxcbiAgICpcXG4gICAqIEJvdGggdGhlIEFKQVggYW5kIHRoZSBmdW5jdGlvbiBhcHByb2FjaCByZWx5IG9uIHRoZSBzYW1lIHJldHVybiB2YWx1ZSAtIGFuIG9iamVjdCB3aGVyZSB0aGUga2V5cyBhcmUgdGhlIG5vZGUgSURzLCBhbmQgdGhlIHZhbHVlIGlzIHRoZSBjaGlsZHJlbiBvZiB0aGF0IG5vZGUgYXMgYW4gYXJyYXkuXFxuICAgKlxcbiAgICpcXHR7XFxuICAgKlxcdFxcdFxcXCJpZDFcXFwiIDogW3sgXFxcInRleHRcXFwiIDogXFxcIkNoaWxkIG9mIElEMVxcXCIsIFxcXCJpZFxcXCIgOiBcXFwiYzFcXFwiIH0sIHsgXFxcInRleHRcXFwiIDogXFxcIkFub3RoZXIgY2hpbGQgb2YgSUQxXFxcIiwgXFxcImlkXFxcIiA6IFxcXCJjMlxcXCIgfV0sXFxuICAgKlxcdFxcdFxcXCJpZDJcXFwiIDogW3sgXFxcInRleHRcXFwiIDogXFxcIkNoaWxkIG9mIElEMlxcXCIsIFxcXCJpZFxcXCIgOiBcXFwiYzNcXFwiIH1dXFxuICAgKlxcdH1cXG4gICAqIFxcbiAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMubWFzc2xvYWRcXG4gICAqIEBwbHVnaW4gbWFzc2xvYWRcXG4gICAqL1xcblxcblxcbiAgJC5qc3RyZWUuZGVmYXVsdHMubWFzc2xvYWQgPSBudWxsO1xcblxcbiAgJC5qc3RyZWUucGx1Z2lucy5tYXNzbG9hZCA9IGZ1bmN0aW9uIChvcHRpb25zLCBwYXJlbnQpIHtcXG4gICAgdGhpcy5pbml0ID0gZnVuY3Rpb24gKGVsLCBvcHRpb25zKSB7XFxuICAgICAgdGhpcy5fZGF0YS5tYXNzbG9hZCA9IHt9O1xcbiAgICAgIHBhcmVudC5pbml0LmNhbGwodGhpcywgZWwsIG9wdGlvbnMpO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLl9sb2FkX25vZGVzID0gZnVuY3Rpb24gKG5vZGVzLCBjYWxsYmFjaywgaXNfY2FsbGJhY2ssIGZvcmNlX3JlbG9hZCkge1xcbiAgICAgIHZhciBzID0gdGhpcy5zZXR0aW5ncy5tYXNzbG9hZCxcXG4gICAgICAgICAgbm9kZXNTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShub2RlcyksXFxuICAgICAgICAgIHRvTG9hZCA9IFtdLFxcbiAgICAgICAgICBtID0gdGhpcy5fbW9kZWwuZGF0YSxcXG4gICAgICAgICAgaSxcXG4gICAgICAgICAgaixcXG4gICAgICAgICAgZG9tO1xcblxcbiAgICAgIGlmICghaXNfY2FsbGJhY2spIHtcXG4gICAgICAgIGZvciAoaSA9IDAsIGogPSBub2Rlcy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG4gICAgICAgICAgaWYgKCFtW25vZGVzW2ldXSB8fCAhbVtub2Rlc1tpXV0uc3RhdGUubG9hZGVkICYmICFtW25vZGVzW2ldXS5zdGF0ZS5mYWlsZWQgfHwgZm9yY2VfcmVsb2FkKSB7XFxuICAgICAgICAgICAgdG9Mb2FkLnB1c2gobm9kZXNbaV0pO1xcbiAgICAgICAgICAgIGRvbSA9IHRoaXMuZ2V0X25vZGUobm9kZXNbaV0sIHRydWUpO1xcblxcbiAgICAgICAgICAgIGlmIChkb20gJiYgZG9tLmxlbmd0aCkge1xcbiAgICAgICAgICAgICAgZG9tLmFkZENsYXNzKFxcXCJqc3RyZWUtbG9hZGluZ1xcXCIpLmF0dHIoJ2FyaWEtYnVzeScsIHRydWUpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgdGhpcy5fZGF0YS5tYXNzbG9hZCA9IHt9O1xcblxcbiAgICAgICAgaWYgKHRvTG9hZC5sZW5ndGgpIHtcXG4gICAgICAgICAgaWYgKCQuaXNGdW5jdGlvbihzKSkge1xcbiAgICAgICAgICAgIHJldHVybiBzLmNhbGwodGhpcywgdG9Mb2FkLCAkLnByb3h5KGZ1bmN0aW9uIChkYXRhKSB7XFxuICAgICAgICAgICAgICB2YXIgaSwgajtcXG5cXG4gICAgICAgICAgICAgIGlmIChkYXRhKSB7XFxuICAgICAgICAgICAgICAgIGZvciAoaSBpbiBkYXRhKSB7XFxuICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkoaSkpIHtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RhdGEubWFzc2xvYWRbaV0gPSBkYXRhW2ldO1xcbiAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgZm9yIChpID0gMCwgaiA9IG5vZGVzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcbiAgICAgICAgICAgICAgICBkb20gPSB0aGlzLmdldF9ub2RlKG5vZGVzW2ldLCB0cnVlKTtcXG5cXG4gICAgICAgICAgICAgICAgaWYgKGRvbSAmJiBkb20ubGVuZ3RoKSB7XFxuICAgICAgICAgICAgICAgICAgZG9tLnJlbW92ZUNsYXNzKFxcXCJqc3RyZWUtbG9hZGluZ1xcXCIpLmF0dHIoJ2FyaWEtYnVzeScsIGZhbHNlKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgcGFyZW50Ll9sb2FkX25vZGVzLmNhbGwodGhpcywgbm9kZXMsIGNhbGxiYWNrLCBpc19jYWxsYmFjaywgZm9yY2VfcmVsb2FkKTtcXG4gICAgICAgICAgICB9LCB0aGlzKSk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaWYgKF90eXBlb2YocykgPT09ICdvYmplY3QnICYmIHMgJiYgcy51cmwpIHtcXG4gICAgICAgICAgICBzID0gJC5leHRlbmQodHJ1ZSwge30sIHMpO1xcblxcbiAgICAgICAgICAgIGlmICgkLmlzRnVuY3Rpb24ocy51cmwpKSB7XFxuICAgICAgICAgICAgICBzLnVybCA9IHMudXJsLmNhbGwodGhpcywgdG9Mb2FkKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaWYgKCQuaXNGdW5jdGlvbihzLmRhdGEpKSB7XFxuICAgICAgICAgICAgICBzLmRhdGEgPSBzLmRhdGEuY2FsbCh0aGlzLCB0b0xvYWQpO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICByZXR1cm4gJC5hamF4KHMpLmRvbmUoJC5wcm94eShmdW5jdGlvbiAoZGF0YSwgdCwgeCkge1xcbiAgICAgICAgICAgICAgdmFyIGksIGo7XFxuXFxuICAgICAgICAgICAgICBpZiAoZGF0YSkge1xcbiAgICAgICAgICAgICAgICBmb3IgKGkgaW4gZGF0YSkge1xcbiAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KGkpKSB7XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kYXRhLm1hc3Nsb2FkW2ldID0gZGF0YVtpXTtcXG4gICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgIGZvciAoaSA9IDAsIGogPSBub2Rlcy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG4gICAgICAgICAgICAgICAgZG9tID0gdGhpcy5nZXRfbm9kZShub2Rlc1tpXSwgdHJ1ZSk7XFxuXFxuICAgICAgICAgICAgICAgIGlmIChkb20gJiYgZG9tLmxlbmd0aCkge1xcbiAgICAgICAgICAgICAgICAgIGRvbS5yZW1vdmVDbGFzcyhcXFwianN0cmVlLWxvYWRpbmdcXFwiKS5hdHRyKCdhcmlhLWJ1c3knLCBmYWxzZSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgIHBhcmVudC5fbG9hZF9ub2Rlcy5jYWxsKHRoaXMsIG5vZGVzLCBjYWxsYmFjaywgaXNfY2FsbGJhY2ssIGZvcmNlX3JlbG9hZCk7XFxuICAgICAgICAgICAgfSwgdGhpcykpLmZhaWwoJC5wcm94eShmdW5jdGlvbiAoZikge1xcbiAgICAgICAgICAgICAgcGFyZW50Ll9sb2FkX25vZGVzLmNhbGwodGhpcywgbm9kZXMsIGNhbGxiYWNrLCBpc19jYWxsYmFjaywgZm9yY2VfcmVsb2FkKTtcXG4gICAgICAgICAgICB9LCB0aGlzKSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHBhcmVudC5fbG9hZF9ub2Rlcy5jYWxsKHRoaXMsIG5vZGVzLCBjYWxsYmFjaywgaXNfY2FsbGJhY2ssIGZvcmNlX3JlbG9hZCk7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuX2xvYWRfbm9kZSA9IGZ1bmN0aW9uIChvYmosIGNhbGxiYWNrKSB7XFxuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhLm1hc3Nsb2FkW29iai5pZF0sXFxuICAgICAgICAgIHJzbHQgPSBudWxsLFxcbiAgICAgICAgICBkb207XFxuXFxuICAgICAgaWYgKGRhdGEpIHtcXG4gICAgICAgIHJzbHQgPSB0aGlzW3R5cGVvZiBkYXRhID09PSAnc3RyaW5nJyA/ICdfYXBwZW5kX2h0bWxfZGF0YScgOiAnX2FwcGVuZF9qc29uX2RhdGEnXShvYmosIHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyA/ICQoJC5wYXJzZUhUTUwoZGF0YSkpLmZpbHRlcihmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHJldHVybiB0aGlzLm5vZGVUeXBlICE9PSAzO1xcbiAgICAgICAgfSkgOiBkYXRhLCBmdW5jdGlvbiAoc3RhdHVzKSB7XFxuICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgc3RhdHVzKTtcXG4gICAgICAgIH0pO1xcbiAgICAgICAgZG9tID0gdGhpcy5nZXRfbm9kZShvYmouaWQsIHRydWUpO1xcblxcbiAgICAgICAgaWYgKGRvbSAmJiBkb20ubGVuZ3RoKSB7XFxuICAgICAgICAgIGRvbS5yZW1vdmVDbGFzcyhcXFwianN0cmVlLWxvYWRpbmdcXFwiKS5hdHRyKCdhcmlhLWJ1c3knLCBmYWxzZSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBkZWxldGUgdGhpcy5fZGF0YS5tYXNzbG9hZFtvYmouaWRdO1xcbiAgICAgICAgcmV0dXJuIHJzbHQ7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBwYXJlbnQuX2xvYWRfbm9kZS5jYWxsKHRoaXMsIG9iaiwgY2FsbGJhY2spO1xcbiAgICB9O1xcbiAgfTtcXG4gIC8qKlxcbiAgICogIyMjIFNlYXJjaCBwbHVnaW5cXG4gICAqXFxuICAgKiBBZGRzIHNlYXJjaCBmdW5jdGlvbmFsaXR5IHRvIGpzVHJlZS5cXG4gICAqL1xcblxcbiAgLyoqXFxuICAgKiBzdG9yZXMgYWxsIGRlZmF1bHRzIGZvciB0aGUgc2VhcmNoIHBsdWdpblxcbiAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuc2VhcmNoXFxuICAgKiBAcGx1Z2luIHNlYXJjaFxcbiAgICovXFxuXFxuXFxuICAkLmpzdHJlZS5kZWZhdWx0cy5zZWFyY2ggPSB7XFxuICAgIC8qKlxcbiAgICAgKiBhIGpRdWVyeS1saWtlIEFKQVggY29uZmlnLCB3aGljaCBqc3RyZWUgdXNlcyBpZiBhIHNlcnZlciBzaG91bGQgYmUgcXVlcmllZCBmb3IgcmVzdWx0cy5cXG4gICAgICpcXG4gICAgICogQSBgc3RyYCAod2hpY2ggaXMgdGhlIHNlYXJjaCBzdHJpbmcpIHBhcmFtZXRlciB3aWxsIGJlIGFkZGVkIHdpdGggdGhlIHJlcXVlc3QsIGFuIG9wdGlvbmFsIGBpbnNpZGVgIHBhcmFtZXRlciB3aWxsIGJlIGFkZGVkIGlmIHRoZSBzZWFyY2ggaXMgbGltaXRlZCB0byBhIG5vZGUgaWQuIFRoZSBleHBlY3RlZCByZXN1bHQgaXMgYSBKU09OIGFycmF5IHdpdGggbm9kZXMgdGhhdCBuZWVkIHRvIGJlIG9wZW5lZCBzbyB0aGF0IG1hdGNoaW5nIG5vZGVzIHdpbGwgYmUgcmV2ZWFsZWQuXFxuICAgICAqIExlYXZlIHRoaXMgc2V0dGluZyBhcyBgZmFsc2VgIHRvIG5vdCBxdWVyeSB0aGUgc2VydmVyLiBZb3UgY2FuIGFsc28gc2V0IHRoaXMgdG8gYSBmdW5jdGlvbiwgd2hpY2ggd2lsbCBiZSBpbnZva2VkIGluIHRoZSBpbnN0YW5jZSdzIHNjb3BlIGFuZCByZWNlaXZlIDMgcGFyYW1ldGVycyAtIHRoZSBzZWFyY2ggc3RyaW5nLCB0aGUgY2FsbGJhY2sgdG8gY2FsbCB3aXRoIHRoZSBhcnJheSBvZiBub2RlcyB0byBsb2FkLCBhbmQgdGhlIG9wdGlvbmFsIG5vZGUgSUQgdG8gbGltaXQgdGhlIHNlYXJjaCB0b1xcbiAgICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5zZWFyY2guYWpheFxcbiAgICAgKiBAcGx1Z2luIHNlYXJjaFxcbiAgICAgKi9cXG4gICAgYWpheDogZmFsc2UsXFxuXFxuICAgIC8qKlxcbiAgICAgKiBJbmRpY2F0ZXMgaWYgdGhlIHNlYXJjaCBzaG91bGQgYmUgZnV6enkgb3Igbm90IChzaG91bGQgYGNobmQzYCBtYXRjaCBgY2hpbGQgbm9kZSAzYCkuIERlZmF1bHQgaXMgYGZhbHNlYC5cXG4gICAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuc2VhcmNoLmZ1enp5XFxuICAgICAqIEBwbHVnaW4gc2VhcmNoXFxuICAgICAqL1xcbiAgICBmdXp6eTogZmFsc2UsXFxuXFxuICAgIC8qKlxcbiAgICAgKiBJbmRpY2F0ZXMgaWYgdGhlIHNlYXJjaCBzaG91bGQgYmUgY2FzZSBzZW5zaXRpdmUuIERlZmF1bHQgaXMgYGZhbHNlYC5cXG4gICAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuc2VhcmNoLmNhc2Vfc2Vuc2l0aXZlXFxuICAgICAqIEBwbHVnaW4gc2VhcmNoXFxuICAgICAqL1xcbiAgICBjYXNlX3NlbnNpdGl2ZTogZmFsc2UsXFxuXFxuICAgIC8qKlxcbiAgICAgKiBJbmRpY2F0ZXMgaWYgdGhlIHRyZWUgc2hvdWxkIGJlIGZpbHRlcmVkIChieSBkZWZhdWx0KSB0byBzaG93IG9ubHkgbWF0Y2hpbmcgbm9kZXMgKGtlZXAgaW4gbWluZCB0aGlzIGNhbiBiZSBhIGhlYXZ5IG9uIGxhcmdlIHRyZWVzIGluIG9sZCBicm93c2VycykuXFxuICAgICAqIFRoaXMgc2V0dGluZyBjYW4gYmUgY2hhbmdlZCBhdCBydW50aW1lIHdoZW4gY2FsbGluZyB0aGUgc2VhcmNoIG1ldGhvZC4gRGVmYXVsdCBpcyBgZmFsc2VgLlxcbiAgICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5zZWFyY2guc2hvd19vbmx5X21hdGNoZXNcXG4gICAgICogQHBsdWdpbiBzZWFyY2hcXG4gICAgICovXFxuICAgIHNob3dfb25seV9tYXRjaGVzOiBmYWxzZSxcXG5cXG4gICAgLyoqXFxuICAgICAqIEluZGljYXRlcyBpZiB0aGUgY2hpbGRyZW4gb2YgbWF0Y2hlZCBlbGVtZW50IGFyZSBzaG93biAod2hlbiBzaG93X29ubHlfbWF0Y2hlcyBpcyB0cnVlKVxcbiAgICAgKiBUaGlzIHNldHRpbmcgY2FuIGJlIGNoYW5nZWQgYXQgcnVudGltZSB3aGVuIGNhbGxpbmcgdGhlIHNlYXJjaCBtZXRob2QuIERlZmF1bHQgaXMgYGZhbHNlYC5cXG4gICAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuc2VhcmNoLnNob3dfb25seV9tYXRjaGVzX2NoaWxkcmVuXFxuICAgICAqIEBwbHVnaW4gc2VhcmNoXFxuICAgICAqL1xcbiAgICBzaG93X29ubHlfbWF0Y2hlc19jaGlsZHJlbjogZmFsc2UsXFxuXFxuICAgIC8qKlxcbiAgICAgKiBJbmRpY2F0ZXMgaWYgYWxsIG5vZGVzIG9wZW5lZCB0byByZXZlYWwgdGhlIHNlYXJjaCByZXN1bHQsIHNob3VsZCBiZSBjbG9zZWQgd2hlbiB0aGUgc2VhcmNoIGlzIGNsZWFyZWQgb3IgYSBuZXcgc2VhcmNoIGlzIHBlcmZvcm1lZC4gRGVmYXVsdCBpcyBgdHJ1ZWAuXFxuICAgICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLnNlYXJjaC5jbG9zZV9vcGVuZWRfb25jbGVhclxcbiAgICAgKiBAcGx1Z2luIHNlYXJjaFxcbiAgICAgKi9cXG4gICAgY2xvc2Vfb3BlbmVkX29uY2xlYXI6IHRydWUsXFxuXFxuICAgIC8qKlxcbiAgICAgKiBJbmRpY2F0ZXMgaWYgb25seSBsZWFmIG5vZGVzIHNob3VsZCBiZSBpbmNsdWRlZCBpbiBzZWFyY2ggcmVzdWx0cy4gRGVmYXVsdCBpcyBgZmFsc2VgLlxcbiAgICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5zZWFyY2guc2VhcmNoX2xlYXZlc19vbmx5XFxuICAgICAqIEBwbHVnaW4gc2VhcmNoXFxuICAgICAqL1xcbiAgICBzZWFyY2hfbGVhdmVzX29ubHk6IGZhbHNlLFxcblxcbiAgICAvKipcXG4gICAgICogSWYgc2V0IHRvIGEgZnVuY3Rpb24gaXQgd2lsIGJlIGNhbGxlZCBpbiB0aGUgaW5zdGFuY2UncyBzY29wZSB3aXRoIHR3byBhcmd1bWVudHMgLSBzZWFyY2ggc3RyaW5nIGFuZCBub2RlICh3aGVyZSBub2RlIHdpbGwgYmUgZXZlcnkgbm9kZSBpbiB0aGUgc3RydWN0dXJlLCBzbyB1c2Ugd2l0aCBjYXV0aW9uKS5cXG4gICAgICogSWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgYSB0cnV0aHkgdmFsdWUgdGhlIG5vZGUgd2lsbCBiZSBjb25zaWRlcmVkIGEgbWF0Y2ggKGl0IG1pZ2h0IG5vdCBiZSBkaXNwbGF5ZWQgaWYgc2VhcmNoX29ubHlfbGVhdmVzIGlzIHNldCB0byB0cnVlIGFuZCB0aGUgbm9kZSBpcyBub3QgYSBsZWFmKS4gRGVmYXVsdCBpcyBgZmFsc2VgLlxcbiAgICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5zZWFyY2guc2VhcmNoX2NhbGxiYWNrXFxuICAgICAqIEBwbHVnaW4gc2VhcmNoXFxuICAgICAqL1xcbiAgICBzZWFyY2hfY2FsbGJhY2s6IGZhbHNlXFxuICB9O1xcblxcbiAgJC5qc3RyZWUucGx1Z2lucy5zZWFyY2ggPSBmdW5jdGlvbiAob3B0aW9ucywgcGFyZW50KSB7XFxuICAgIHRoaXMuYmluZCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICBwYXJlbnQuYmluZC5jYWxsKHRoaXMpO1xcbiAgICAgIHRoaXMuX2RhdGEuc2VhcmNoLnN0ciA9IFxcXCJcXFwiO1xcbiAgICAgIHRoaXMuX2RhdGEuc2VhcmNoLmRvbSA9ICQoKTtcXG4gICAgICB0aGlzLl9kYXRhLnNlYXJjaC5yZXMgPSBbXTtcXG4gICAgICB0aGlzLl9kYXRhLnNlYXJjaC5vcG4gPSBbXTtcXG4gICAgICB0aGlzLl9kYXRhLnNlYXJjaC5zb20gPSBmYWxzZTtcXG4gICAgICB0aGlzLl9kYXRhLnNlYXJjaC5zbWMgPSBmYWxzZTtcXG4gICAgICB0aGlzLl9kYXRhLnNlYXJjaC5oZG4gPSBbXTtcXG4gICAgICB0aGlzLmVsZW1lbnQub24oXFxcInNlYXJjaC5qc3RyZWVcXFwiLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XFxuICAgICAgICBpZiAodGhpcy5fZGF0YS5zZWFyY2guc29tICYmIGRhdGEucmVzLmxlbmd0aCkge1xcbiAgICAgICAgICB2YXIgbSA9IHRoaXMuX21vZGVsLmRhdGEsXFxuICAgICAgICAgICAgICBpLFxcbiAgICAgICAgICAgICAgaixcXG4gICAgICAgICAgICAgIHAgPSBbXSxcXG4gICAgICAgICAgICAgIGssXFxuICAgICAgICAgICAgICBsO1xcblxcbiAgICAgICAgICBmb3IgKGkgPSAwLCBqID0gZGF0YS5yZXMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICAgICAgaWYgKG1bZGF0YS5yZXNbaV1dICYmICFtW2RhdGEucmVzW2ldXS5zdGF0ZS5oaWRkZW4pIHtcXG4gICAgICAgICAgICAgIHAucHVzaChkYXRhLnJlc1tpXSk7XFxuICAgICAgICAgICAgICBwID0gcC5jb25jYXQobVtkYXRhLnJlc1tpXV0ucGFyZW50cyk7XFxuXFxuICAgICAgICAgICAgICBpZiAodGhpcy5fZGF0YS5zZWFyY2guc21jKSB7XFxuICAgICAgICAgICAgICAgIGZvciAoayA9IDAsIGwgPSBtW2RhdGEucmVzW2ldXS5jaGlsZHJlbl9kLmxlbmd0aDsgayA8IGw7IGsrKykge1xcbiAgICAgICAgICAgICAgICAgIGlmIChtW21bZGF0YS5yZXNbaV1dLmNoaWxkcmVuX2Rba11dICYmICFtW21bZGF0YS5yZXNbaV1dLmNoaWxkcmVuX2Rba11dLnN0YXRlLmhpZGRlbikge1xcbiAgICAgICAgICAgICAgICAgICAgcC5wdXNoKG1bZGF0YS5yZXNbaV1dLmNoaWxkcmVuX2Rba10pO1xcbiAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBwID0gJC52YWthdGEuYXJyYXlfcmVtb3ZlX2l0ZW0oJC52YWthdGEuYXJyYXlfdW5pcXVlKHApLCAkLmpzdHJlZS5yb290KTtcXG4gICAgICAgICAgdGhpcy5fZGF0YS5zZWFyY2guaGRuID0gdGhpcy5oaWRlX2FsbCh0cnVlKTtcXG4gICAgICAgICAgdGhpcy5zaG93X25vZGUocCwgdHJ1ZSk7XFxuICAgICAgICAgIHRoaXMucmVkcmF3KHRydWUpO1xcbiAgICAgICAgfVxcbiAgICAgIH0sIHRoaXMpKS5vbihcXFwiY2xlYXJfc2VhcmNoLmpzdHJlZVxcXCIsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcXG4gICAgICAgIGlmICh0aGlzLl9kYXRhLnNlYXJjaC5zb20gJiYgZGF0YS5yZXMubGVuZ3RoKSB7XFxuICAgICAgICAgIHRoaXMuc2hvd19ub2RlKHRoaXMuX2RhdGEuc2VhcmNoLmhkbiwgdHJ1ZSk7XFxuICAgICAgICAgIHRoaXMucmVkcmF3KHRydWUpO1xcbiAgICAgICAgfVxcbiAgICAgIH0sIHRoaXMpKTtcXG4gICAgfTtcXG4gICAgLyoqXFxuICAgICAqIHVzZWQgdG8gc2VhcmNoIHRoZSB0cmVlIG5vZGVzIGZvciBhIGdpdmVuIHN0cmluZ1xcbiAgICAgKiBAbmFtZSBzZWFyY2goc3RyIFssIHNraXBfYXN5bmNdKVxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIHRoZSBzZWFyY2ggc3RyaW5nXFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2tpcF9hc3luYyBpZiBzZXQgdG8gdHJ1ZSBzZXJ2ZXIgd2lsbCBub3QgYmUgcXVlcmllZCBldmVuIGlmIGNvbmZpZ3VyZWRcXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzaG93X29ubHlfbWF0Y2hlcyBpZiBzZXQgdG8gdHJ1ZSBvbmx5IG1hdGNoaW5nIG5vZGVzIHdpbGwgYmUgc2hvd24gKGtlZXAgaW4gbWluZCB0aGlzIGNhbiBiZSB2ZXJ5IHNsb3cgb24gbGFyZ2UgdHJlZXMgb3Igb2xkIGJyb3dzZXJzKVxcbiAgICAgKiBAcGFyYW0ge21peGVkfSBpbnNpZGUgYW4gb3B0aW9uYWwgbm9kZSB0byB3aG9zZSBjaGlsZHJlbiB0byBsaW1pdCB0aGUgc2VhcmNoXFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gYXBwZW5kIGlmIHNldCB0byB0cnVlIHRoZSByZXN1bHRzIG9mIHRoaXMgc2VhcmNoIGFyZSBhcHBlbmRlZCB0byB0aGUgcHJldmlvdXMgc2VhcmNoXFxuICAgICAqIEBwbHVnaW4gc2VhcmNoXFxuICAgICAqIEB0cmlnZ2VyIHNlYXJjaC5qc3RyZWVcXG4gICAgICovXFxuXFxuXFxuICAgIHRoaXMuc2VhcmNoID0gZnVuY3Rpb24gKHN0ciwgc2tpcF9hc3luYywgc2hvd19vbmx5X21hdGNoZXMsIGluc2lkZSwgYXBwZW5kLCBzaG93X29ubHlfbWF0Y2hlc19jaGlsZHJlbikge1xcbiAgICAgIGlmIChzdHIgPT09IGZhbHNlIHx8ICQudHJpbShzdHIudG9TdHJpbmcoKSkgPT09IFxcXCJcXFwiKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5jbGVhcl9zZWFyY2goKTtcXG4gICAgICB9XFxuXFxuICAgICAgaW5zaWRlID0gdGhpcy5nZXRfbm9kZShpbnNpZGUpO1xcbiAgICAgIGluc2lkZSA9IGluc2lkZSAmJiBpbnNpZGUuaWQgPyBpbnNpZGUuaWQgOiBudWxsO1xcbiAgICAgIHN0ciA9IHN0ci50b1N0cmluZygpO1xcbiAgICAgIHZhciBzID0gdGhpcy5zZXR0aW5ncy5zZWFyY2gsXFxuICAgICAgICAgIGEgPSBzLmFqYXggPyBzLmFqYXggOiBmYWxzZSxcXG4gICAgICAgICAgbSA9IHRoaXMuX21vZGVsLmRhdGEsXFxuICAgICAgICAgIGYgPSBudWxsLFxcbiAgICAgICAgICByID0gW10sXFxuICAgICAgICAgIHAgPSBbXSxcXG4gICAgICAgICAgaSxcXG4gICAgICAgICAgajtcXG5cXG4gICAgICBpZiAodGhpcy5fZGF0YS5zZWFyY2gucmVzLmxlbmd0aCAmJiAhYXBwZW5kKSB7XFxuICAgICAgICB0aGlzLmNsZWFyX3NlYXJjaCgpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoc2hvd19vbmx5X21hdGNoZXMgPT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgc2hvd19vbmx5X21hdGNoZXMgPSBzLnNob3dfb25seV9tYXRjaGVzO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoc2hvd19vbmx5X21hdGNoZXNfY2hpbGRyZW4gPT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgc2hvd19vbmx5X21hdGNoZXNfY2hpbGRyZW4gPSBzLnNob3dfb25seV9tYXRjaGVzX2NoaWxkcmVuO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIXNraXBfYXN5bmMgJiYgYSAhPT0gZmFsc2UpIHtcXG4gICAgICAgIGlmICgkLmlzRnVuY3Rpb24oYSkpIHtcXG4gICAgICAgICAgcmV0dXJuIGEuY2FsbCh0aGlzLCBzdHIsICQucHJveHkoZnVuY3Rpb24gKGQpIHtcXG4gICAgICAgICAgICBpZiAoZCAmJiBkLmQpIHtcXG4gICAgICAgICAgICAgIGQgPSBkLmQ7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIHRoaXMuX2xvYWRfbm9kZXMoISQuaXNBcnJheShkKSA/IFtdIDogJC52YWthdGEuYXJyYXlfdW5pcXVlKGQpLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICB0aGlzLnNlYXJjaChzdHIsIHRydWUsIHNob3dfb25seV9tYXRjaGVzLCBpbnNpZGUsIGFwcGVuZCwgc2hvd19vbmx5X21hdGNoZXNfY2hpbGRyZW4pO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICB9LCB0aGlzKSwgaW5zaWRlKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGEgPSAkLmV4dGVuZCh7fSwgYSk7XFxuXFxuICAgICAgICAgIGlmICghYS5kYXRhKSB7XFxuICAgICAgICAgICAgYS5kYXRhID0ge307XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgYS5kYXRhLnN0ciA9IHN0cjtcXG5cXG4gICAgICAgICAgaWYgKGluc2lkZSkge1xcbiAgICAgICAgICAgIGEuZGF0YS5pbnNpZGUgPSBpbnNpZGU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaWYgKHRoaXMuX2RhdGEuc2VhcmNoLmxhc3RSZXF1ZXN0KSB7XFxuICAgICAgICAgICAgdGhpcy5fZGF0YS5zZWFyY2gubGFzdFJlcXVlc3QuYWJvcnQoKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICB0aGlzLl9kYXRhLnNlYXJjaC5sYXN0UmVxdWVzdCA9ICQuYWpheChhKS5mYWlsKCQucHJveHkoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yID0ge1xcbiAgICAgICAgICAgICAgJ2Vycm9yJzogJ2FqYXgnLFxcbiAgICAgICAgICAgICAgJ3BsdWdpbic6ICdzZWFyY2gnLFxcbiAgICAgICAgICAgICAgJ2lkJzogJ3NlYXJjaF8wMScsXFxuICAgICAgICAgICAgICAncmVhc29uJzogJ0NvdWxkIG5vdCBsb2FkIHNlYXJjaCBwYXJlbnRzJyxcXG4gICAgICAgICAgICAgICdkYXRhJzogSlNPTi5zdHJpbmdpZnkoYSlcXG4gICAgICAgICAgICB9O1xcbiAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MuY29yZS5lcnJvci5jYWxsKHRoaXMsIHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yKTtcXG4gICAgICAgICAgfSwgdGhpcykpLmRvbmUoJC5wcm94eShmdW5jdGlvbiAoZCkge1xcbiAgICAgICAgICAgIGlmIChkICYmIGQuZCkge1xcbiAgICAgICAgICAgICAgZCA9IGQuZDtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgdGhpcy5fbG9hZF9ub2RlcyghJC5pc0FycmF5KGQpID8gW10gOiAkLnZha2F0YS5hcnJheV91bmlxdWUoZCksIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgIHRoaXMuc2VhcmNoKHN0ciwgdHJ1ZSwgc2hvd19vbmx5X21hdGNoZXMsIGluc2lkZSwgYXBwZW5kLCBzaG93X29ubHlfbWF0Y2hlc19jaGlsZHJlbik7XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgIH0sIHRoaXMpKTtcXG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuc2VhcmNoLmxhc3RSZXF1ZXN0O1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIWFwcGVuZCkge1xcbiAgICAgICAgdGhpcy5fZGF0YS5zZWFyY2guc3RyID0gc3RyO1xcbiAgICAgICAgdGhpcy5fZGF0YS5zZWFyY2guZG9tID0gJCgpO1xcbiAgICAgICAgdGhpcy5fZGF0YS5zZWFyY2gucmVzID0gW107XFxuICAgICAgICB0aGlzLl9kYXRhLnNlYXJjaC5vcG4gPSBbXTtcXG4gICAgICAgIHRoaXMuX2RhdGEuc2VhcmNoLnNvbSA9IHNob3dfb25seV9tYXRjaGVzO1xcbiAgICAgICAgdGhpcy5fZGF0YS5zZWFyY2guc21jID0gc2hvd19vbmx5X21hdGNoZXNfY2hpbGRyZW47XFxuICAgICAgfVxcblxcbiAgICAgIGYgPSBuZXcgJC52YWthdGEuc2VhcmNoKHN0ciwgdHJ1ZSwge1xcbiAgICAgICAgY2FzZVNlbnNpdGl2ZTogcy5jYXNlX3NlbnNpdGl2ZSxcXG4gICAgICAgIGZ1enp5OiBzLmZ1enp5XFxuICAgICAgfSk7XFxuICAgICAgJC5lYWNoKG1baW5zaWRlID8gaW5zaWRlIDogJC5qc3RyZWUucm9vdF0uY2hpbGRyZW5fZCwgZnVuY3Rpb24gKGlpLCBpKSB7XFxuICAgICAgICB2YXIgdiA9IG1baV07XFxuXFxuICAgICAgICBpZiAodi50ZXh0ICYmICF2LnN0YXRlLmhpZGRlbiAmJiAoIXMuc2VhcmNoX2xlYXZlc19vbmx5IHx8IHYuc3RhdGUubG9hZGVkICYmIHYuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSAmJiAocy5zZWFyY2hfY2FsbGJhY2sgJiYgcy5zZWFyY2hfY2FsbGJhY2suY2FsbCh0aGlzLCBzdHIsIHYpIHx8ICFzLnNlYXJjaF9jYWxsYmFjayAmJiBmLnNlYXJjaCh2LnRleHQpLmlzTWF0Y2gpKSB7XFxuICAgICAgICAgIHIucHVzaChpKTtcXG4gICAgICAgICAgcCA9IHAuY29uY2F0KHYucGFyZW50cyk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuXFxuICAgICAgaWYgKHIubGVuZ3RoKSB7XFxuICAgICAgICBwID0gJC52YWthdGEuYXJyYXlfdW5pcXVlKHApO1xcblxcbiAgICAgICAgZm9yIChpID0gMCwgaiA9IHAubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICAgIGlmIChwW2ldICE9PSAkLmpzdHJlZS5yb290ICYmIG1bcFtpXV0gJiYgdGhpcy5vcGVuX25vZGUocFtpXSwgbnVsbCwgMCkgPT09IHRydWUpIHtcXG4gICAgICAgICAgICB0aGlzLl9kYXRhLnNlYXJjaC5vcG4ucHVzaChwW2ldKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKCFhcHBlbmQpIHtcXG4gICAgICAgICAgdGhpcy5fZGF0YS5zZWFyY2guZG9tID0gJCh0aGlzLmVsZW1lbnRbMF0ucXVlcnlTZWxlY3RvckFsbCgnIycgKyAkLm1hcChyLCBmdW5jdGlvbiAodikge1xcbiAgICAgICAgICAgIHJldHVybiBcXFwiMDEyMzQ1Njc4OVxcXCIuaW5kZXhPZih2WzBdKSAhPT0gLTEgPyAnXFxcXFxcXFwzJyArIHZbMF0gKyAnICcgKyB2LnN1YnN0cigxKS5yZXBsYWNlKCQuanN0cmVlLmlkcmVnZXgsICdcXFxcXFxcXCQmJykgOiB2LnJlcGxhY2UoJC5qc3RyZWUuaWRyZWdleCwgJ1xcXFxcXFxcJCYnKTtcXG4gICAgICAgICAgfSkuam9pbignLCAjJykpKTtcXG4gICAgICAgICAgdGhpcy5fZGF0YS5zZWFyY2gucmVzID0gcjtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHRoaXMuX2RhdGEuc2VhcmNoLmRvbSA9IHRoaXMuX2RhdGEuc2VhcmNoLmRvbS5hZGQoJCh0aGlzLmVsZW1lbnRbMF0ucXVlcnlTZWxlY3RvckFsbCgnIycgKyAkLm1hcChyLCBmdW5jdGlvbiAodikge1xcbiAgICAgICAgICAgIHJldHVybiBcXFwiMDEyMzQ1Njc4OVxcXCIuaW5kZXhPZih2WzBdKSAhPT0gLTEgPyAnXFxcXFxcXFwzJyArIHZbMF0gKyAnICcgKyB2LnN1YnN0cigxKS5yZXBsYWNlKCQuanN0cmVlLmlkcmVnZXgsICdcXFxcXFxcXCQmJykgOiB2LnJlcGxhY2UoJC5qc3RyZWUuaWRyZWdleCwgJ1xcXFxcXFxcJCYnKTtcXG4gICAgICAgICAgfSkuam9pbignLCAjJykpKSk7XFxuICAgICAgICAgIHRoaXMuX2RhdGEuc2VhcmNoLnJlcyA9ICQudmFrYXRhLmFycmF5X3VuaXF1ZSh0aGlzLl9kYXRhLnNlYXJjaC5yZXMuY29uY2F0KHIpKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHRoaXMuX2RhdGEuc2VhcmNoLmRvbS5jaGlsZHJlbihcXFwiLmpzdHJlZS1hbmNob3JcXFwiKS5hZGRDbGFzcygnanN0cmVlLXNlYXJjaCcpO1xcbiAgICAgIH1cXG4gICAgICAvKipcXG4gICAgICAgKiB0cmlnZ2VyZWQgYWZ0ZXIgc2VhcmNoIGlzIGNvbXBsZXRlXFxuICAgICAgICogQGV2ZW50XFxuICAgICAgICogQG5hbWUgc2VhcmNoLmpzdHJlZVxcbiAgICAgICAqIEBwYXJhbSB7alF1ZXJ5fSBub2RlcyBhIGpRdWVyeSBjb2xsZWN0aW9uIG9mIG1hdGNoaW5nIG5vZGVzXFxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciB0aGUgc2VhcmNoIHN0cmluZ1xcbiAgICAgICAqIEBwYXJhbSB7QXJyYXl9IHJlcyBhIGNvbGxlY3Rpb24gb2Ygb2JqZWN0cyByZXByZXNlaW5nIHRoZSBtYXRjaGluZyBub2Rlc1xcbiAgICAgICAqIEBwbHVnaW4gc2VhcmNoXFxuICAgICAgICovXFxuXFxuXFxuICAgICAgdGhpcy50cmlnZ2VyKCdzZWFyY2gnLCB7XFxuICAgICAgICBub2RlczogdGhpcy5fZGF0YS5zZWFyY2guZG9tLFxcbiAgICAgICAgc3RyOiBzdHIsXFxuICAgICAgICByZXM6IHRoaXMuX2RhdGEuc2VhcmNoLnJlcyxcXG4gICAgICAgIHNob3dfb25seV9tYXRjaGVzOiBzaG93X29ubHlfbWF0Y2hlc1xcbiAgICAgIH0pO1xcbiAgICB9O1xcbiAgICAvKipcXG4gICAgICogdXNlZCB0byBjbGVhciB0aGUgbGFzdCBzZWFyY2ggKHJlbW92ZXMgY2xhc3NlcyBhbmQgc2hvd3MgYWxsIG5vZGVzIGlmIGZpbHRlcmluZyBpcyBvbilcXG4gICAgICogQG5hbWUgY2xlYXJfc2VhcmNoKClcXG4gICAgICogQHBsdWdpbiBzZWFyY2hcXG4gICAgICogQHRyaWdnZXIgY2xlYXJfc2VhcmNoLmpzdHJlZVxcbiAgICAgKi9cXG5cXG5cXG4gICAgdGhpcy5jbGVhcl9zZWFyY2ggPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3Muc2VhcmNoLmNsb3NlX29wZW5lZF9vbmNsZWFyKSB7XFxuICAgICAgICB0aGlzLmNsb3NlX25vZGUodGhpcy5fZGF0YS5zZWFyY2gub3BuLCAwKTtcXG4gICAgICB9XFxuICAgICAgLyoqXFxuICAgICAgICogdHJpZ2dlcmVkIGFmdGVyIHNlYXJjaCBpcyBjb21wbGV0ZVxcbiAgICAgICAqIEBldmVudFxcbiAgICAgICAqIEBuYW1lIGNsZWFyX3NlYXJjaC5qc3RyZWVcXG4gICAgICAgKiBAcGFyYW0ge2pRdWVyeX0gbm9kZXMgYSBqUXVlcnkgY29sbGVjdGlvbiBvZiBtYXRjaGluZyBub2RlcyAodGhlIHJlc3VsdCBmcm9tIHRoZSBsYXN0IHNlYXJjaClcXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIHRoZSBzZWFyY2ggc3RyaW5nICh0aGUgbGFzdCBzZWFyY2ggc3RyaW5nKVxcbiAgICAgICAqIEBwYXJhbSB7QXJyYXl9IHJlcyBhIGNvbGxlY3Rpb24gb2Ygb2JqZWN0cyByZXByZXNlaW5nIHRoZSBtYXRjaGluZyBub2RlcyAodGhlIHJlc3VsdCBmcm9tIHRoZSBsYXN0IHNlYXJjaClcXG4gICAgICAgKiBAcGx1Z2luIHNlYXJjaFxcbiAgICAgICAqL1xcblxcblxcbiAgICAgIHRoaXMudHJpZ2dlcignY2xlYXJfc2VhcmNoJywge1xcbiAgICAgICAgJ25vZGVzJzogdGhpcy5fZGF0YS5zZWFyY2guZG9tLFxcbiAgICAgICAgc3RyOiB0aGlzLl9kYXRhLnNlYXJjaC5zdHIsXFxuICAgICAgICByZXM6IHRoaXMuX2RhdGEuc2VhcmNoLnJlc1xcbiAgICAgIH0pO1xcblxcbiAgICAgIGlmICh0aGlzLl9kYXRhLnNlYXJjaC5yZXMubGVuZ3RoKSB7XFxuICAgICAgICB0aGlzLl9kYXRhLnNlYXJjaC5kb20gPSAkKHRoaXMuZWxlbWVudFswXS5xdWVyeVNlbGVjdG9yQWxsKCcjJyArICQubWFwKHRoaXMuX2RhdGEuc2VhcmNoLnJlcywgZnVuY3Rpb24gKHYpIHtcXG4gICAgICAgICAgcmV0dXJuIFxcXCIwMTIzNDU2Nzg5XFxcIi5pbmRleE9mKHZbMF0pICE9PSAtMSA/ICdcXFxcXFxcXDMnICsgdlswXSArICcgJyArIHYuc3Vic3RyKDEpLnJlcGxhY2UoJC5qc3RyZWUuaWRyZWdleCwgJ1xcXFxcXFxcJCYnKSA6IHYucmVwbGFjZSgkLmpzdHJlZS5pZHJlZ2V4LCAnXFxcXFxcXFwkJicpO1xcbiAgICAgICAgfSkuam9pbignLCAjJykpKTtcXG5cXG4gICAgICAgIHRoaXMuX2RhdGEuc2VhcmNoLmRvbS5jaGlsZHJlbihcXFwiLmpzdHJlZS1hbmNob3JcXFwiKS5yZW1vdmVDbGFzcyhcXFwianN0cmVlLXNlYXJjaFxcXCIpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9kYXRhLnNlYXJjaC5zdHIgPSBcXFwiXFxcIjtcXG4gICAgICB0aGlzLl9kYXRhLnNlYXJjaC5yZXMgPSBbXTtcXG4gICAgICB0aGlzLl9kYXRhLnNlYXJjaC5vcG4gPSBbXTtcXG4gICAgICB0aGlzLl9kYXRhLnNlYXJjaC5kb20gPSAkKCk7XFxuICAgIH07XFxuXFxuICAgIHRoaXMucmVkcmF3X25vZGUgPSBmdW5jdGlvbiAob2JqLCBkZWVwLCBjYWxsYmFjaywgZm9yY2VfcmVuZGVyKSB7XFxuICAgICAgb2JqID0gcGFyZW50LnJlZHJhd19ub2RlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuXFxuICAgICAgaWYgKG9iaikge1xcbiAgICAgICAgaWYgKCQuaW5BcnJheShvYmouaWQsIHRoaXMuX2RhdGEuc2VhcmNoLnJlcykgIT09IC0xKSB7XFxuICAgICAgICAgIHZhciBpLFxcbiAgICAgICAgICAgICAgaixcXG4gICAgICAgICAgICAgIHRtcCA9IG51bGw7XFxuXFxuICAgICAgICAgIGZvciAoaSA9IDAsIGogPSBvYmouY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG4gICAgICAgICAgICBpZiAob2JqLmNoaWxkTm9kZXNbaV0gJiYgb2JqLmNoaWxkTm9kZXNbaV0uY2xhc3NOYW1lICYmIG9iai5jaGlsZE5vZGVzW2ldLmNsYXNzTmFtZS5pbmRleE9mKFxcXCJqc3RyZWUtYW5jaG9yXFxcIikgIT09IC0xKSB7XFxuICAgICAgICAgICAgICB0bXAgPSBvYmouY2hpbGROb2Rlc1tpXTtcXG4gICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAodG1wKSB7XFxuICAgICAgICAgICAgdG1wLmNsYXNzTmFtZSArPSAnIGpzdHJlZS1zZWFyY2gnO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBvYmo7XFxuICAgIH07XFxuICB9OyAvLyBoZWxwZXJzXFxuXFxuXFxuICAoZnVuY3Rpb24gKCQpIHtcXG4gICAgLy8gZnJvbSBodHRwOi8va2lyby5tZS9wcm9qZWN0cy9mdXNlLmh0bWxcXG4gICAgJC52YWthdGEuc2VhcmNoID0gZnVuY3Rpb24gKHBhdHRlcm4sIHR4dCwgb3B0aW9ucykge1xcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xcbiAgICAgIG9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgJC52YWthdGEuc2VhcmNoLmRlZmF1bHRzLCBvcHRpb25zKTtcXG5cXG4gICAgICBpZiAob3B0aW9ucy5mdXp6eSAhPT0gZmFsc2UpIHtcXG4gICAgICAgIG9wdGlvbnMuZnV6enkgPSB0cnVlO1xcbiAgICAgIH1cXG5cXG4gICAgICBwYXR0ZXJuID0gb3B0aW9ucy5jYXNlU2Vuc2l0aXZlID8gcGF0dGVybiA6IHBhdHRlcm4udG9Mb3dlckNhc2UoKTtcXG4gICAgICB2YXIgTUFUQ0hfTE9DQVRJT04gPSBvcHRpb25zLmxvY2F0aW9uLFxcbiAgICAgICAgICBNQVRDSF9ESVNUQU5DRSA9IG9wdGlvbnMuZGlzdGFuY2UsXFxuICAgICAgICAgIE1BVENIX1RIUkVTSE9MRCA9IG9wdGlvbnMudGhyZXNob2xkLFxcbiAgICAgICAgICBwYXR0ZXJuTGVuID0gcGF0dGVybi5sZW5ndGgsXFxuICAgICAgICAgIG1hdGNobWFzayxcXG4gICAgICAgICAgcGF0dGVybl9hbHBoYWJldCxcXG4gICAgICAgICAgbWF0Y2hfYml0YXBTY29yZSxcXG4gICAgICAgICAgc2VhcmNoO1xcblxcbiAgICAgIGlmIChwYXR0ZXJuTGVuID4gMzIpIHtcXG4gICAgICAgIG9wdGlvbnMuZnV6enkgPSBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKG9wdGlvbnMuZnV6enkpIHtcXG4gICAgICAgIG1hdGNobWFzayA9IDEgPDwgcGF0dGVybkxlbiAtIDE7XFxuXFxuICAgICAgICBwYXR0ZXJuX2FscGhhYmV0ID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICB2YXIgbWFzayA9IHt9LFxcbiAgICAgICAgICAgICAgaSA9IDA7XFxuXFxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYXR0ZXJuTGVuOyBpKyspIHtcXG4gICAgICAgICAgICBtYXNrW3BhdHRlcm4uY2hhckF0KGkpXSA9IDA7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhdHRlcm5MZW47IGkrKykge1xcbiAgICAgICAgICAgIG1hc2tbcGF0dGVybi5jaGFyQXQoaSldIHw9IDEgPDwgcGF0dGVybkxlbiAtIGkgLSAxO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHJldHVybiBtYXNrO1xcbiAgICAgICAgfSgpO1xcblxcbiAgICAgICAgbWF0Y2hfYml0YXBTY29yZSA9IGZ1bmN0aW9uIG1hdGNoX2JpdGFwU2NvcmUoZSwgeCkge1xcbiAgICAgICAgICB2YXIgYWNjdXJhY3kgPSBlIC8gcGF0dGVybkxlbixcXG4gICAgICAgICAgICAgIHByb3hpbWl0eSA9IE1hdGguYWJzKE1BVENIX0xPQ0FUSU9OIC0geCk7XFxuXFxuICAgICAgICAgIGlmICghTUFUQ0hfRElTVEFOQ0UpIHtcXG4gICAgICAgICAgICByZXR1cm4gcHJveGltaXR5ID8gMS4wIDogYWNjdXJhY3k7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgcmV0dXJuIGFjY3VyYWN5ICsgcHJveGltaXR5IC8gTUFUQ0hfRElTVEFOQ0U7XFxuICAgICAgICB9O1xcbiAgICAgIH1cXG5cXG4gICAgICBzZWFyY2ggPSBmdW5jdGlvbiBzZWFyY2godGV4dCkge1xcbiAgICAgICAgdGV4dCA9IG9wdGlvbnMuY2FzZVNlbnNpdGl2ZSA/IHRleHQgOiB0ZXh0LnRvTG93ZXJDYXNlKCk7XFxuXFxuICAgICAgICBpZiAocGF0dGVybiA9PT0gdGV4dCB8fCB0ZXh0LmluZGV4T2YocGF0dGVybikgIT09IC0xKSB7XFxuICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgaXNNYXRjaDogdHJ1ZSxcXG4gICAgICAgICAgICBzY29yZTogMFxcbiAgICAgICAgICB9O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKCFvcHRpb25zLmZ1enp5KSB7XFxuICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgaXNNYXRjaDogZmFsc2UsXFxuICAgICAgICAgICAgc2NvcmU6IDFcXG4gICAgICAgICAgfTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHZhciBpLFxcbiAgICAgICAgICAgIGosXFxuICAgICAgICAgICAgdGV4dExlbiA9IHRleHQubGVuZ3RoLFxcbiAgICAgICAgICAgIHNjb3JlVGhyZXNob2xkID0gTUFUQ0hfVEhSRVNIT0xELFxcbiAgICAgICAgICAgIGJlc3RMb2MgPSB0ZXh0LmluZGV4T2YocGF0dGVybiwgTUFUQ0hfTE9DQVRJT04pLFxcbiAgICAgICAgICAgIGJpbk1pbixcXG4gICAgICAgICAgICBiaW5NaWQsXFxuICAgICAgICAgICAgYmluTWF4ID0gcGF0dGVybkxlbiArIHRleHRMZW4sXFxuICAgICAgICAgICAgbGFzdFJkLFxcbiAgICAgICAgICAgIHN0YXJ0LFxcbiAgICAgICAgICAgIGZpbmlzaCxcXG4gICAgICAgICAgICByZCxcXG4gICAgICAgICAgICBjaGFyTWF0Y2gsXFxuICAgICAgICAgICAgc2NvcmUgPSAxLFxcbiAgICAgICAgICAgIGxvY2F0aW9ucyA9IFtdO1xcblxcbiAgICAgICAgaWYgKGJlc3RMb2MgIT09IC0xKSB7XFxuICAgICAgICAgIHNjb3JlVGhyZXNob2xkID0gTWF0aC5taW4obWF0Y2hfYml0YXBTY29yZSgwLCBiZXN0TG9jKSwgc2NvcmVUaHJlc2hvbGQpO1xcbiAgICAgICAgICBiZXN0TG9jID0gdGV4dC5sYXN0SW5kZXhPZihwYXR0ZXJuLCBNQVRDSF9MT0NBVElPTiArIHBhdHRlcm5MZW4pO1xcblxcbiAgICAgICAgICBpZiAoYmVzdExvYyAhPT0gLTEpIHtcXG4gICAgICAgICAgICBzY29yZVRocmVzaG9sZCA9IE1hdGgubWluKG1hdGNoX2JpdGFwU2NvcmUoMCwgYmVzdExvYyksIHNjb3JlVGhyZXNob2xkKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgYmVzdExvYyA9IC0xO1xcblxcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhdHRlcm5MZW47IGkrKykge1xcbiAgICAgICAgICBiaW5NaW4gPSAwO1xcbiAgICAgICAgICBiaW5NaWQgPSBiaW5NYXg7XFxuXFxuICAgICAgICAgIHdoaWxlIChiaW5NaW4gPCBiaW5NaWQpIHtcXG4gICAgICAgICAgICBpZiAobWF0Y2hfYml0YXBTY29yZShpLCBNQVRDSF9MT0NBVElPTiArIGJpbk1pZCkgPD0gc2NvcmVUaHJlc2hvbGQpIHtcXG4gICAgICAgICAgICAgIGJpbk1pbiA9IGJpbk1pZDtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgYmluTWF4ID0gYmluTWlkO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBiaW5NaWQgPSBNYXRoLmZsb29yKChiaW5NYXggLSBiaW5NaW4pIC8gMiArIGJpbk1pbik7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgYmluTWF4ID0gYmluTWlkO1xcbiAgICAgICAgICBzdGFydCA9IE1hdGgubWF4KDEsIE1BVENIX0xPQ0FUSU9OIC0gYmluTWlkICsgMSk7XFxuICAgICAgICAgIGZpbmlzaCA9IE1hdGgubWluKE1BVENIX0xPQ0FUSU9OICsgYmluTWlkLCB0ZXh0TGVuKSArIHBhdHRlcm5MZW47XFxuICAgICAgICAgIHJkID0gbmV3IEFycmF5KGZpbmlzaCArIDIpO1xcbiAgICAgICAgICByZFtmaW5pc2ggKyAxXSA9ICgxIDw8IGkpIC0gMTtcXG5cXG4gICAgICAgICAgZm9yIChqID0gZmluaXNoOyBqID49IHN0YXJ0OyBqLS0pIHtcXG4gICAgICAgICAgICBjaGFyTWF0Y2ggPSBwYXR0ZXJuX2FscGhhYmV0W3RleHQuY2hhckF0KGogLSAxKV07XFxuXFxuICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcXG4gICAgICAgICAgICAgIHJkW2pdID0gKHJkW2ogKyAxXSA8PCAxIHwgMSkgJiBjaGFyTWF0Y2g7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgIHJkW2pdID0gKHJkW2ogKyAxXSA8PCAxIHwgMSkgJiBjaGFyTWF0Y2ggfCAoKGxhc3RSZFtqICsgMV0gfCBsYXN0UmRbal0pIDw8IDEgfCAxKSB8IGxhc3RSZFtqICsgMV07XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmIChyZFtqXSAmIG1hdGNobWFzaykge1xcbiAgICAgICAgICAgICAgc2NvcmUgPSBtYXRjaF9iaXRhcFNjb3JlKGksIGogLSAxKTtcXG5cXG4gICAgICAgICAgICAgIGlmIChzY29yZSA8PSBzY29yZVRocmVzaG9sZCkge1xcbiAgICAgICAgICAgICAgICBzY29yZVRocmVzaG9sZCA9IHNjb3JlO1xcbiAgICAgICAgICAgICAgICBiZXN0TG9jID0gaiAtIDE7XFxuICAgICAgICAgICAgICAgIGxvY2F0aW9ucy5wdXNoKGJlc3RMb2MpO1xcblxcbiAgICAgICAgICAgICAgICBpZiAoYmVzdExvYyA+IE1BVENIX0xPQ0FUSU9OKSB7XFxuICAgICAgICAgICAgICAgICAgc3RhcnQgPSBNYXRoLm1heCgxLCAyICogTUFUQ0hfTE9DQVRJT04gLSBiZXN0TG9jKTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAobWF0Y2hfYml0YXBTY29yZShpICsgMSwgTUFUQ0hfTE9DQVRJT04pID4gc2NvcmVUaHJlc2hvbGQpIHtcXG4gICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBsYXN0UmQgPSByZDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgIGlzTWF0Y2g6IGJlc3RMb2MgPj0gMCxcXG4gICAgICAgICAgc2NvcmU6IHNjb3JlXFxuICAgICAgICB9O1xcbiAgICAgIH07XFxuXFxuICAgICAgcmV0dXJuIHR4dCA9PT0gdHJ1ZSA/IHtcXG4gICAgICAgICdzZWFyY2gnOiBzZWFyY2hcXG4gICAgICB9IDogc2VhcmNoKHR4dCk7XFxuICAgIH07XFxuXFxuICAgICQudmFrYXRhLnNlYXJjaC5kZWZhdWx0cyA9IHtcXG4gICAgICBsb2NhdGlvbjogMCxcXG4gICAgICBkaXN0YW5jZTogMTAwLFxcbiAgICAgIHRocmVzaG9sZDogMC42LFxcbiAgICAgIGZ1enp5OiBmYWxzZSxcXG4gICAgICBjYXNlU2Vuc2l0aXZlOiBmYWxzZVxcbiAgICB9O1xcbiAgfSkoJCk7IC8vIGluY2x1ZGUgdGhlIHNlYXJjaCBwbHVnaW4gYnkgZGVmYXVsdFxcbiAgLy8gJC5qc3RyZWUuZGVmYXVsdHMucGx1Z2lucy5wdXNoKFxcXCJzZWFyY2hcXFwiKTtcXG5cXG4gIC8qKlxcbiAgICogIyMjIFNvcnQgcGx1Z2luXFxuICAgKlxcbiAgICogQXV0b21hdGljYWxseSBzb3J0cyBhbGwgc2libGluZ3MgaW4gdGhlIHRyZWUgYWNjb3JkaW5nIHRvIGEgc29ydGluZyBmdW5jdGlvbi5cXG4gICAqL1xcblxcbiAgLyoqXFxuICAgKiB0aGUgc2V0dGluZ3MgZnVuY3Rpb24gdXNlZCB0byBzb3J0IHRoZSBub2Rlcy5cXG4gICAqIEl0IGlzIGV4ZWN1dGVkIGluIHRoZSB0cmVlJ3MgY29udGV4dCwgYWNjZXB0cyB0d28gbm9kZXMgYXMgYXJndW1lbnRzIGFuZCBzaG91bGQgcmV0dXJuIGAxYCBvciBgLTFgLlxcbiAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuc29ydFxcbiAgICogQHBsdWdpbiBzb3J0XFxuICAgKi9cXG5cXG5cXG4gICQuanN0cmVlLmRlZmF1bHRzLnNvcnQgPSBmdW5jdGlvbiAoYSwgYikge1xcbiAgICAvL3JldHVybiB0aGlzLmdldF90eXBlKGEpID09PSB0aGlzLmdldF90eXBlKGIpID8gKHRoaXMuZ2V0X3RleHQoYSkgPiB0aGlzLmdldF90ZXh0KGIpID8gMSA6IC0xKSA6IHRoaXMuZ2V0X3R5cGUoYSkgPj0gdGhpcy5nZXRfdHlwZShiKTtcXG4gICAgcmV0dXJuIHRoaXMuZ2V0X3RleHQoYSkgPiB0aGlzLmdldF90ZXh0KGIpID8gMSA6IC0xO1xcbiAgfTtcXG5cXG4gICQuanN0cmVlLnBsdWdpbnMuc29ydCA9IGZ1bmN0aW9uIChvcHRpb25zLCBwYXJlbnQpIHtcXG4gICAgdGhpcy5iaW5kID0gZnVuY3Rpb24gKCkge1xcbiAgICAgIHBhcmVudC5iaW5kLmNhbGwodGhpcyk7XFxuICAgICAgdGhpcy5lbGVtZW50Lm9uKFxcXCJtb2RlbC5qc3RyZWVcXFwiLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XFxuICAgICAgICB0aGlzLnNvcnQoZGF0YS5wYXJlbnQsIHRydWUpO1xcbiAgICAgIH0sIHRoaXMpKS5vbihcXFwicmVuYW1lX25vZGUuanN0cmVlIGNyZWF0ZV9ub2RlLmpzdHJlZVxcXCIsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcXG4gICAgICAgIHRoaXMuc29ydChkYXRhLnBhcmVudCB8fCBkYXRhLm5vZGUucGFyZW50LCBmYWxzZSk7XFxuICAgICAgICB0aGlzLnJlZHJhd19ub2RlKGRhdGEucGFyZW50IHx8IGRhdGEubm9kZS5wYXJlbnQsIHRydWUpO1xcbiAgICAgIH0sIHRoaXMpKS5vbihcXFwibW92ZV9ub2RlLmpzdHJlZSBjb3B5X25vZGUuanN0cmVlXFxcIiwgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xcbiAgICAgICAgdGhpcy5zb3J0KGRhdGEucGFyZW50LCBmYWxzZSk7XFxuICAgICAgICB0aGlzLnJlZHJhd19ub2RlKGRhdGEucGFyZW50LCB0cnVlKTtcXG4gICAgICB9LCB0aGlzKSk7XFxuICAgIH07XFxuICAgIC8qKlxcbiAgICAgKiB1c2VkIHRvIHNvcnQgYSBub2RlJ3MgY2hpbGRyZW5cXG4gICAgICogQHByaXZhdGVcXG4gICAgICogQG5hbWUgc29ydChvYmogWywgZGVlcF0pXFxuICAgICAqIEBwYXJhbSAge21peGVkfSBvYmogdGhlIG5vZGVcXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBkZWVwIGlmIHNldCB0byBgdHJ1ZWAgbm9kZXMgYXJlIHNvcnRlZCByZWN1cnNpdmVseS5cXG4gICAgICogQHBsdWdpbiBzb3J0XFxuICAgICAqIEB0cmlnZ2VyIHNlYXJjaC5qc3RyZWVcXG4gICAgICovXFxuXFxuXFxuICAgIHRoaXMuc29ydCA9IGZ1bmN0aW9uIChvYmosIGRlZXApIHtcXG4gICAgICB2YXIgaSwgajtcXG4gICAgICBvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XFxuXFxuICAgICAgaWYgKG9iaiAmJiBvYmouY2hpbGRyZW4gJiYgb2JqLmNoaWxkcmVuLmxlbmd0aCkge1xcbiAgICAgICAgb2JqLmNoaWxkcmVuLnNvcnQoJC5wcm94eSh0aGlzLnNldHRpbmdzLnNvcnQsIHRoaXMpKTtcXG5cXG4gICAgICAgIGlmIChkZWVwKSB7XFxuICAgICAgICAgIGZvciAoaSA9IDAsIGogPSBvYmouY2hpbGRyZW5fZC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG4gICAgICAgICAgICB0aGlzLnNvcnQob2JqLmNoaWxkcmVuX2RbaV0sIGZhbHNlKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfTtcXG4gIH07IC8vIGluY2x1ZGUgdGhlIHNvcnQgcGx1Z2luIGJ5IGRlZmF1bHRcXG4gIC8vICQuanN0cmVlLmRlZmF1bHRzLnBsdWdpbnMucHVzaChcXFwic29ydFxcXCIpO1xcblxcbiAgLyoqXFxuICAgKiAjIyMgU3RhdGUgcGx1Z2luXFxuICAgKlxcbiAgICogU2F2ZXMgdGhlIHN0YXRlIG9mIHRoZSB0cmVlIChzZWxlY3RlZCBub2Rlcywgb3BlbmVkIG5vZGVzKSBvbiB0aGUgdXNlcidzIGNvbXB1dGVyIHVzaW5nIGF2YWlsYWJsZSBvcHRpb25zIChsb2NhbFN0b3JhZ2UsIGNvb2tpZXMsIGV0YylcXG4gICAqL1xcblxcblxcbiAgdmFyIHRvID0gZmFsc2U7XFxuICAvKipcXG4gICAqIHN0b3JlcyBhbGwgZGVmYXVsdHMgZm9yIHRoZSBzdGF0ZSBwbHVnaW5cXG4gICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLnN0YXRlXFxuICAgKiBAcGx1Z2luIHN0YXRlXFxuICAgKi9cXG5cXG4gICQuanN0cmVlLmRlZmF1bHRzLnN0YXRlID0ge1xcbiAgICAvKipcXG4gICAgICogQSBzdHJpbmcgZm9yIHRoZSBrZXkgdG8gdXNlIHdoZW4gc2F2aW5nIHRoZSBjdXJyZW50IHRyZWUgKGNoYW5nZSBpZiB1c2luZyBtdWx0aXBsZSB0cmVlcyBpbiB5b3VyIHByb2plY3QpLiBEZWZhdWx0cyB0byBganN0cmVlYC5cXG4gICAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuc3RhdGUua2V5XFxuICAgICAqIEBwbHVnaW4gc3RhdGVcXG4gICAgICovXFxuICAgIGtleTogJ2pzdHJlZScsXFxuXFxuICAgIC8qKlxcbiAgICAgKiBBIHNwYWNlIHNlcGFyYXRlZCBsaXN0IG9mIGV2ZW50cyB0aGF0IHRyaWdnZXIgYSBzdGF0ZSBzYXZlLiBEZWZhdWx0cyB0byBgY2hhbmdlZC5qc3RyZWUgb3Blbl9ub2RlLmpzdHJlZSBjbG9zZV9ub2RlLmpzdHJlZWAuXFxuICAgICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLnN0YXRlLmV2ZW50c1xcbiAgICAgKiBAcGx1Z2luIHN0YXRlXFxuICAgICAqL1xcbiAgICBldmVudHM6ICdjaGFuZ2VkLmpzdHJlZSBvcGVuX25vZGUuanN0cmVlIGNsb3NlX25vZGUuanN0cmVlIGNoZWNrX25vZGUuanN0cmVlIHVuY2hlY2tfbm9kZS5qc3RyZWUnLFxcblxcbiAgICAvKipcXG4gICAgICogVGltZSBpbiBtaWxsaXNlY29uZHMgYWZ0ZXIgd2hpY2ggdGhlIHN0YXRlIHdpbGwgZXhwaXJlLiBEZWZhdWx0cyB0byAnZmFsc2UnIG1lYW5pbmcgLSBubyBleHBpcmUuXFxuICAgICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLnN0YXRlLnR0bFxcbiAgICAgKiBAcGx1Z2luIHN0YXRlXFxuICAgICAqL1xcbiAgICB0dGw6IGZhbHNlLFxcblxcbiAgICAvKipcXG4gICAgICogQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgcHJpb3IgdG8gcmVzdG9yaW5nIHN0YXRlIHdpdGggb25lIGFyZ3VtZW50IC0gdGhlIHN0YXRlIG9iamVjdC4gQ2FuIGJlIHVzZWQgdG8gY2xlYXIgdW53YW50ZWQgcGFydHMgb2YgdGhlIHN0YXRlLlxcbiAgICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5zdGF0ZS5maWx0ZXJcXG4gICAgICogQHBsdWdpbiBzdGF0ZVxcbiAgICAgKi9cXG4gICAgZmlsdGVyOiBmYWxzZVxcbiAgfTtcXG5cXG4gICQuanN0cmVlLnBsdWdpbnMuc3RhdGUgPSBmdW5jdGlvbiAob3B0aW9ucywgcGFyZW50KSB7XFxuICAgIHRoaXMuYmluZCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICBwYXJlbnQuYmluZC5jYWxsKHRoaXMpO1xcbiAgICAgIHZhciBiaW5kID0gJC5wcm94eShmdW5jdGlvbiAoKSB7XFxuICAgICAgICB0aGlzLmVsZW1lbnQub24odGhpcy5zZXR0aW5ncy5zdGF0ZS5ldmVudHMsICQucHJveHkoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBpZiAodG8pIHtcXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodG8pO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHRvID0gc2V0VGltZW91dCgkLnByb3h5KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICB0aGlzLnNhdmVfc3RhdGUoKTtcXG4gICAgICAgICAgfSwgdGhpcyksIDEwMCk7XFxuICAgICAgICB9LCB0aGlzKSk7XFxuICAgICAgICAvKipcXG4gICAgICAgICAqIHRyaWdnZXJlZCB3aGVuIHRoZSBzdGF0ZSBwbHVnaW4gaXMgZmluaXNoZWQgcmVzdG9yaW5nIHRoZSBzdGF0ZSAoYW5kIGltbWVkaWF0ZWx5IGFmdGVyIHJlYWR5IGlmIHRoZXJlIGlzIG5vIHN0YXRlIHRvIHJlc3RvcmUpLlxcbiAgICAgICAgICogQGV2ZW50XFxuICAgICAgICAgKiBAbmFtZSBzdGF0ZV9yZWFkeS5qc3RyZWVcXG4gICAgICAgICAqIEBwbHVnaW4gc3RhdGVcXG4gICAgICAgICAqL1xcblxcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdzdGF0ZV9yZWFkeScpO1xcbiAgICAgIH0sIHRoaXMpO1xcbiAgICAgIHRoaXMuZWxlbWVudC5vbihcXFwicmVhZHkuanN0cmVlXFxcIiwgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xcbiAgICAgICAgdGhpcy5lbGVtZW50Lm9uZShcXFwicmVzdG9yZV9zdGF0ZS5qc3RyZWVcXFwiLCBiaW5kKTtcXG5cXG4gICAgICAgIGlmICghdGhpcy5yZXN0b3JlX3N0YXRlKCkpIHtcXG4gICAgICAgICAgYmluZCgpO1xcbiAgICAgICAgfVxcbiAgICAgIH0sIHRoaXMpKTtcXG4gICAgfTtcXG4gICAgLyoqXFxuICAgICAqIHNhdmUgdGhlIHN0YXRlXFxuICAgICAqIEBuYW1lIHNhdmVfc3RhdGUoKVxcbiAgICAgKiBAcGx1Z2luIHN0YXRlXFxuICAgICAqL1xcblxcblxcbiAgICB0aGlzLnNhdmVfc3RhdGUgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgdmFyIHN0ID0ge1xcbiAgICAgICAgJ3N0YXRlJzogdGhpcy5nZXRfc3RhdGUoKSxcXG4gICAgICAgICd0dGwnOiB0aGlzLnNldHRpbmdzLnN0YXRlLnR0bCxcXG4gICAgICAgICdzZWMnOiArbmV3IERhdGUoKVxcbiAgICAgIH07XFxuICAgICAgJC52YWthdGEuc3RvcmFnZS5zZXQodGhpcy5zZXR0aW5ncy5zdGF0ZS5rZXksIEpTT04uc3RyaW5naWZ5KHN0KSk7XFxuICAgIH07XFxuICAgIC8qKlxcbiAgICAgKiByZXN0b3JlIHRoZSBzdGF0ZSBmcm9tIHRoZSB1c2VyJ3MgY29tcHV0ZXJcXG4gICAgICogQG5hbWUgcmVzdG9yZV9zdGF0ZSgpXFxuICAgICAqIEBwbHVnaW4gc3RhdGVcXG4gICAgICovXFxuXFxuXFxuICAgIHRoaXMucmVzdG9yZV9zdGF0ZSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICB2YXIgayA9ICQudmFrYXRhLnN0b3JhZ2UuZ2V0KHRoaXMuc2V0dGluZ3Muc3RhdGUua2V5KTtcXG5cXG4gICAgICBpZiAoISFrKSB7XFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICBrID0gSlNPTi5wYXJzZShrKTtcXG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XFxuICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCEhayAmJiBrLnR0bCAmJiBrLnNlYyAmJiArbmV3IERhdGUoKSAtIGsuc2VjID4gay50dGwpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCEhayAmJiBrLnN0YXRlKSB7XFxuICAgICAgICBrID0gay5zdGF0ZTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCEhayAmJiAkLmlzRnVuY3Rpb24odGhpcy5zZXR0aW5ncy5zdGF0ZS5maWx0ZXIpKSB7XFxuICAgICAgICBrID0gdGhpcy5zZXR0aW5ncy5zdGF0ZS5maWx0ZXIuY2FsbCh0aGlzLCBrKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCEhaykge1xcbiAgICAgICAgdGhpcy5lbGVtZW50Lm9uZShcXFwic2V0X3N0YXRlLmpzdHJlZVxcXCIsIGZ1bmN0aW9uIChlLCBkYXRhKSB7XFxuICAgICAgICAgIGRhdGEuaW5zdGFuY2UudHJpZ2dlcigncmVzdG9yZV9zdGF0ZScsIHtcXG4gICAgICAgICAgICAnc3RhdGUnOiAkLmV4dGVuZCh0cnVlLCB7fSwgaylcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9KTtcXG4gICAgICAgIHRoaXMuc2V0X3N0YXRlKGspO1xcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfTtcXG4gICAgLyoqXFxuICAgICAqIGNsZWFyIHRoZSBzdGF0ZSBvbiB0aGUgdXNlcidzIGNvbXB1dGVyXFxuICAgICAqIEBuYW1lIGNsZWFyX3N0YXRlKClcXG4gICAgICogQHBsdWdpbiBzdGF0ZVxcbiAgICAgKi9cXG5cXG5cXG4gICAgdGhpcy5jbGVhcl9zdGF0ZSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICByZXR1cm4gJC52YWthdGEuc3RvcmFnZS5kZWwodGhpcy5zZXR0aW5ncy5zdGF0ZS5rZXkpO1xcbiAgICB9O1xcbiAgfTtcXG5cXG4gIChmdW5jdGlvbiAoJCwgdW5kZWZpbmVkKSB7XFxuICAgICQudmFrYXRhLnN0b3JhZ2UgPSB7XFxuICAgICAgLy8gc2ltcGx5IHNwZWNpZnlpbmcgdGhlIGZ1bmN0aW9ucyBpbiBGRiB0aHJvd3MgYW4gZXJyb3JcXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldChrZXksIHZhbCkge1xcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIHZhbCk7XFxuICAgICAgfSxcXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldChrZXkpIHtcXG4gICAgICAgIHJldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KTtcXG4gICAgICB9LFxcbiAgICAgIGRlbDogZnVuY3Rpb24gZGVsKGtleSkge1xcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xcbiAgICAgIH1cXG4gICAgfTtcXG4gIH0pKCQpOyAvLyBpbmNsdWRlIHRoZSBzdGF0ZSBwbHVnaW4gYnkgZGVmYXVsdFxcbiAgLy8gJC5qc3RyZWUuZGVmYXVsdHMucGx1Z2lucy5wdXNoKFxcXCJzdGF0ZVxcXCIpO1xcblxcbiAgLyoqXFxuICAgKiAjIyMgVHlwZXMgcGx1Z2luXFxuICAgKlxcbiAgICogTWFrZXMgaXQgcG9zc2libGUgdG8gYWRkIHByZWRlZmluZWQgdHlwZXMgZm9yIGdyb3VwcyBvZiBub2Rlcywgd2hpY2ggbWFrZSBpdCBwb3NzaWJsZSB0byBlYXNpbHkgY29udHJvbCBuZXN0aW5nIHJ1bGVzIGFuZCBpY29uIGZvciBlYWNoIGdyb3VwLlxcbiAgICovXFxuXFxuICAvKipcXG4gICAqIEFuIG9iamVjdCBzdG9yaW5nIGFsbCB0eXBlcyBhcyBrZXkgdmFsdWUgcGFpcnMsIHdoZXJlIHRoZSBrZXkgaXMgdGhlIHR5cGUgbmFtZSBhbmQgdGhlIHZhbHVlIGlzIGFuIG9iamVjdCB0aGF0IGNvdWxkIGNvbnRhaW4gZm9sbG93aW5nIGtleXMgKGFsbCBvcHRpb25hbCkuXFxuICAgKlxcbiAgICogKiBgbWF4X2NoaWxkcmVuYCB0aGUgbWF4aW11bSBudW1iZXIgb2YgaW1tZWRpYXRlIGNoaWxkcmVuIHRoaXMgbm9kZSB0eXBlIGNhbiBoYXZlLiBEbyBub3Qgc3BlY2lmeSBvciBzZXQgdG8gYC0xYCBmb3IgdW5saW1pdGVkLlxcbiAgICogKiBgbWF4X2RlcHRoYCB0aGUgbWF4aW11bSBudW1iZXIgb2YgbmVzdGluZyB0aGlzIG5vZGUgdHlwZSBjYW4gaGF2ZS4gQSB2YWx1ZSBvZiBgMWAgd291bGQgbWVhbiB0aGF0IHRoZSBub2RlIGNhbiBoYXZlIGNoaWxkcmVuLCBidXQgbm8gZ3JhbmRjaGlsZHJlbi4gRG8gbm90IHNwZWNpZnkgb3Igc2V0IHRvIGAtMWAgZm9yIHVubGltaXRlZC5cXG4gICAqICogYHZhbGlkX2NoaWxkcmVuYCBhbiBhcnJheSBvZiBub2RlIHR5cGUgc3RyaW5ncywgdGhhdCBub2RlcyBvZiB0aGlzIHR5cGUgY2FuIGhhdmUgYXMgY2hpbGRyZW4uIERvIG5vdCBzcGVjaWZ5IG9yIHNldCB0byBgLTFgIGZvciBubyBsaW1pdHMuXFxuICAgKiAqIGBpY29uYCBhIHN0cmluZyAtIGNhbiBiZSBhIHBhdGggdG8gYW4gaWNvbiBvciBhIGNsYXNzTmFtZSwgaWYgdXNpbmcgYW4gaW1hZ2UgdGhhdCBpcyBpbiB0aGUgY3VycmVudCBkaXJlY3RvcnkgdXNlIGEgYC4vYCBwcmVmaXgsIG90aGVyd2lzZSBpdCB3aWxsIGJlIGRldGVjdGVkIGFzIGEgY2xhc3MuIE9taXQgdG8gdXNlIHRoZSBkZWZhdWx0IGljb24gZnJvbSB5b3VyIHRoZW1lLlxcbiAgICogKiBgbGlfYXR0cmAgYW4gb2JqZWN0IG9mIHZhbHVlcyB3aGljaCB3aWxsIGJlIHVzZWQgdG8gYWRkIEhUTUwgYXR0cmlidXRlcyBvbiB0aGUgcmVzdWx0aW5nIExJIERPTSBub2RlIChtZXJnZWQgd2l0aCB0aGUgbm9kZSdzIG93biBkYXRhKVxcbiAgICogKiBgYV9hdHRyYCBhbiBvYmplY3Qgb2YgdmFsdWVzIHdoaWNoIHdpbGwgYmUgdXNlZCB0byBhZGQgSFRNTCBhdHRyaWJ1dGVzIG9uIHRoZSByZXN1bHRpbmcgQSBET00gbm9kZSAobWVyZ2VkIHdpdGggdGhlIG5vZGUncyBvd24gZGF0YSlcXG4gICAqXFxuICAgKiBUaGVyZSBhcmUgdHdvIHByZWRlZmluZWQgdHlwZXM6XFxuICAgKlxcbiAgICogKiBgI2AgcmVwcmVzZW50cyB0aGUgcm9vdCBvZiB0aGUgdHJlZSwgZm9yIGV4YW1wbGUgYG1heF9jaGlsZHJlbmAgd291bGQgY29udHJvbCB0aGUgbWF4aW11bSBudW1iZXIgb2Ygcm9vdCBub2Rlcy5cXG4gICAqICogYGRlZmF1bHRgIHJlcHJlc2VudHMgdGhlIGRlZmF1bHQgbm9kZSAtIGFueSBzZXR0aW5ncyBoZXJlIHdpbGwgYmUgYXBwbGllZCB0byBhbGwgbm9kZXMgdGhhdCBkbyBub3QgaGF2ZSBhIHR5cGUgc3BlY2lmaWVkLlxcbiAgICpcXG4gICAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLnR5cGVzXFxuICAgKiBAcGx1Z2luIHR5cGVzXFxuICAgKi9cXG5cXG5cXG4gICQuanN0cmVlLmRlZmF1bHRzLnR5cGVzID0ge1xcbiAgICAnZGVmYXVsdCc6IHt9XFxuICB9O1xcbiAgJC5qc3RyZWUuZGVmYXVsdHMudHlwZXNbJC5qc3RyZWUucm9vdF0gPSB7fTtcXG5cXG4gICQuanN0cmVlLnBsdWdpbnMudHlwZXMgPSBmdW5jdGlvbiAob3B0aW9ucywgcGFyZW50KSB7XFxuICAgIHRoaXMuaW5pdCA9IGZ1bmN0aW9uIChlbCwgb3B0aW9ucykge1xcbiAgICAgIHZhciBpLCBqO1xcblxcbiAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMudHlwZXMgJiYgb3B0aW9ucy50eXBlc1snZGVmYXVsdCddKSB7XFxuICAgICAgICBmb3IgKGkgaW4gb3B0aW9ucy50eXBlcykge1xcbiAgICAgICAgICBpZiAoaSAhPT0gXFxcImRlZmF1bHRcXFwiICYmIGkgIT09ICQuanN0cmVlLnJvb3QgJiYgb3B0aW9ucy50eXBlcy5oYXNPd25Qcm9wZXJ0eShpKSkge1xcbiAgICAgICAgICAgIGZvciAoaiBpbiBvcHRpb25zLnR5cGVzWydkZWZhdWx0J10pIHtcXG4gICAgICAgICAgICAgIGlmIChvcHRpb25zLnR5cGVzWydkZWZhdWx0J10uaGFzT3duUHJvcGVydHkoaikgJiYgb3B0aW9ucy50eXBlc1tpXVtqXSA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgICAgICAgIG9wdGlvbnMudHlwZXNbaV1bal0gPSBvcHRpb25zLnR5cGVzWydkZWZhdWx0J11bal07XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHBhcmVudC5pbml0LmNhbGwodGhpcywgZWwsIG9wdGlvbnMpO1xcbiAgICAgIHRoaXMuX21vZGVsLmRhdGFbJC5qc3RyZWUucm9vdF0udHlwZSA9ICQuanN0cmVlLnJvb3Q7XFxuICAgIH07XFxuXFxuICAgIHRoaXMucmVmcmVzaCA9IGZ1bmN0aW9uIChza2lwX2xvYWRpbmcsIGZvcmdldF9zdGF0ZSkge1xcbiAgICAgIHBhcmVudC5yZWZyZXNoLmNhbGwodGhpcywgc2tpcF9sb2FkaW5nLCBmb3JnZXRfc3RhdGUpO1xcbiAgICAgIHRoaXMuX21vZGVsLmRhdGFbJC5qc3RyZWUucm9vdF0udHlwZSA9ICQuanN0cmVlLnJvb3Q7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuYmluZCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICB0aGlzLmVsZW1lbnQub24oJ21vZGVsLmpzdHJlZScsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcXG4gICAgICAgIHZhciBtID0gdGhpcy5fbW9kZWwuZGF0YSxcXG4gICAgICAgICAgICBkcGMgPSBkYXRhLm5vZGVzLFxcbiAgICAgICAgICAgIHQgPSB0aGlzLnNldHRpbmdzLnR5cGVzLFxcbiAgICAgICAgICAgIGksXFxuICAgICAgICAgICAgaixcXG4gICAgICAgICAgICBjID0gJ2RlZmF1bHQnLFxcbiAgICAgICAgICAgIGs7XFxuXFxuICAgICAgICBmb3IgKGkgPSAwLCBqID0gZHBjLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcbiAgICAgICAgICBjID0gJ2RlZmF1bHQnO1xcblxcbiAgICAgICAgICBpZiAobVtkcGNbaV1dLm9yaWdpbmFsICYmIG1bZHBjW2ldXS5vcmlnaW5hbC50eXBlICYmIHRbbVtkcGNbaV1dLm9yaWdpbmFsLnR5cGVdKSB7XFxuICAgICAgICAgICAgYyA9IG1bZHBjW2ldXS5vcmlnaW5hbC50eXBlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmIChtW2RwY1tpXV0uZGF0YSAmJiBtW2RwY1tpXV0uZGF0YS5qc3RyZWUgJiYgbVtkcGNbaV1dLmRhdGEuanN0cmVlLnR5cGUgJiYgdFttW2RwY1tpXV0uZGF0YS5qc3RyZWUudHlwZV0pIHtcXG4gICAgICAgICAgICBjID0gbVtkcGNbaV1dLmRhdGEuanN0cmVlLnR5cGU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgbVtkcGNbaV1dLnR5cGUgPSBjO1xcblxcbiAgICAgICAgICBpZiAobVtkcGNbaV1dLmljb24gPT09IHRydWUgJiYgdFtjXS5pY29uICE9PSB1bmRlZmluZWQpIHtcXG4gICAgICAgICAgICBtW2RwY1tpXV0uaWNvbiA9IHRbY10uaWNvbjtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAodFtjXS5saV9hdHRyICE9PSB1bmRlZmluZWQgJiYgX3R5cGVvZih0W2NdLmxpX2F0dHIpID09PSAnb2JqZWN0Jykge1xcbiAgICAgICAgICAgIGZvciAoayBpbiB0W2NdLmxpX2F0dHIpIHtcXG4gICAgICAgICAgICAgIGlmICh0W2NdLmxpX2F0dHIuaGFzT3duUHJvcGVydHkoaykpIHtcXG4gICAgICAgICAgICAgICAgaWYgKGsgPT09ICdpZCcpIHtcXG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtW2RwY1tpXV0ubGlfYXR0cltrXSA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgICAgICAgICAgbVtkcGNbaV1dLmxpX2F0dHJba10gPSB0W2NdLmxpX2F0dHJba107XFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoayA9PT0gJ2NsYXNzJykge1xcbiAgICAgICAgICAgICAgICAgIG1bZHBjW2ldXS5saV9hdHRyWydjbGFzcyddID0gdFtjXS5saV9hdHRyWydjbGFzcyddICsgJyAnICsgbVtkcGNbaV1dLmxpX2F0dHJbJ2NsYXNzJ107XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaWYgKHRbY10uYV9hdHRyICE9PSB1bmRlZmluZWQgJiYgX3R5cGVvZih0W2NdLmFfYXR0cikgPT09ICdvYmplY3QnKSB7XFxuICAgICAgICAgICAgZm9yIChrIGluIHRbY10uYV9hdHRyKSB7XFxuICAgICAgICAgICAgICBpZiAodFtjXS5hX2F0dHIuaGFzT3duUHJvcGVydHkoaykpIHtcXG4gICAgICAgICAgICAgICAgaWYgKGsgPT09ICdpZCcpIHtcXG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtW2RwY1tpXV0uYV9hdHRyW2tdID09PSB1bmRlZmluZWQpIHtcXG4gICAgICAgICAgICAgICAgICBtW2RwY1tpXV0uYV9hdHRyW2tdID0gdFtjXS5hX2F0dHJba107XFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoayA9PT0gJ2hyZWYnICYmIG1bZHBjW2ldXS5hX2F0dHJba10gPT09ICcjJykge1xcbiAgICAgICAgICAgICAgICAgIG1bZHBjW2ldXS5hX2F0dHJbJ2hyZWYnXSA9IHRbY10uYV9hdHRyWydocmVmJ107XFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoayA9PT0gJ2NsYXNzJykge1xcbiAgICAgICAgICAgICAgICAgIG1bZHBjW2ldXS5hX2F0dHJbJ2NsYXNzJ10gPSB0W2NdLmFfYXR0clsnY2xhc3MnXSArICcgJyArIG1bZHBjW2ldXS5hX2F0dHJbJ2NsYXNzJ107XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIG1bJC5qc3RyZWUucm9vdF0udHlwZSA9ICQuanN0cmVlLnJvb3Q7XFxuICAgICAgfSwgdGhpcykpO1xcbiAgICAgIHBhcmVudC5iaW5kLmNhbGwodGhpcyk7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuZ2V0X2pzb24gPSBmdW5jdGlvbiAob2JqLCBvcHRpb25zLCBmbGF0KSB7XFxuICAgICAgdmFyIGksXFxuICAgICAgICAgIGosXFxuICAgICAgICAgIG0gPSB0aGlzLl9tb2RlbC5kYXRhLFxcbiAgICAgICAgICBvcHQgPSBvcHRpb25zID8gJC5leHRlbmQodHJ1ZSwge30sIG9wdGlvbnMsIHtcXG4gICAgICAgIG5vX2lkOiBmYWxzZVxcbiAgICAgIH0pIDoge30sXFxuICAgICAgICAgIHRtcCA9IHBhcmVudC5nZXRfanNvbi5jYWxsKHRoaXMsIG9iaiwgb3B0LCBmbGF0KTtcXG5cXG4gICAgICBpZiAodG1wID09PSBmYWxzZSkge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoJC5pc0FycmF5KHRtcCkpIHtcXG4gICAgICAgIGZvciAoaSA9IDAsIGogPSB0bXAubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICAgIHRtcFtpXS50eXBlID0gdG1wW2ldLmlkICYmIG1bdG1wW2ldLmlkXSAmJiBtW3RtcFtpXS5pZF0udHlwZSA/IG1bdG1wW2ldLmlkXS50eXBlIDogXFxcImRlZmF1bHRcXFwiO1xcblxcbiAgICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLm5vX2lkKSB7XFxuICAgICAgICAgICAgZGVsZXRlIHRtcFtpXS5pZDtcXG5cXG4gICAgICAgICAgICBpZiAodG1wW2ldLmxpX2F0dHIgJiYgdG1wW2ldLmxpX2F0dHIuaWQpIHtcXG4gICAgICAgICAgICAgIGRlbGV0ZSB0bXBbaV0ubGlfYXR0ci5pZDtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaWYgKHRtcFtpXS5hX2F0dHIgJiYgdG1wW2ldLmFfYXR0ci5pZCkge1xcbiAgICAgICAgICAgICAgZGVsZXRlIHRtcFtpXS5hX2F0dHIuaWQ7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRtcC50eXBlID0gdG1wLmlkICYmIG1bdG1wLmlkXSAmJiBtW3RtcC5pZF0udHlwZSA/IG1bdG1wLmlkXS50eXBlIDogXFxcImRlZmF1bHRcXFwiO1xcblxcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5ub19pZCkge1xcbiAgICAgICAgICB0bXAgPSB0aGlzLl9kZWxldGVfaWRzKHRtcCk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiB0bXA7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuX2RlbGV0ZV9pZHMgPSBmdW5jdGlvbiAodG1wKSB7XFxuICAgICAgaWYgKCQuaXNBcnJheSh0bXApKSB7XFxuICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IHRtcC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG4gICAgICAgICAgdG1wW2ldID0gdGhpcy5fZGVsZXRlX2lkcyh0bXBbaV0pO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIHRtcDtcXG4gICAgICB9XFxuXFxuICAgICAgZGVsZXRlIHRtcC5pZDtcXG5cXG4gICAgICBpZiAodG1wLmxpX2F0dHIgJiYgdG1wLmxpX2F0dHIuaWQpIHtcXG4gICAgICAgIGRlbGV0ZSB0bXAubGlfYXR0ci5pZDtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRtcC5hX2F0dHIgJiYgdG1wLmFfYXR0ci5pZCkge1xcbiAgICAgICAgZGVsZXRlIHRtcC5hX2F0dHIuaWQ7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0bXAuY2hpbGRyZW4gJiYgJC5pc0FycmF5KHRtcC5jaGlsZHJlbikpIHtcXG4gICAgICAgIHRtcC5jaGlsZHJlbiA9IHRoaXMuX2RlbGV0ZV9pZHModG1wLmNoaWxkcmVuKTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHRtcDtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5jaGVjayA9IGZ1bmN0aW9uIChjaGssIG9iaiwgcGFyLCBwb3MsIG1vcmUpIHtcXG4gICAgICBpZiAocGFyZW50LmNoZWNrLmNhbGwodGhpcywgY2hrLCBvYmosIHBhciwgcG9zLCBtb3JlKSA9PT0gZmFsc2UpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgb2JqID0gb2JqICYmIG9iai5pZCA/IG9iaiA6IHRoaXMuZ2V0X25vZGUob2JqKTtcXG4gICAgICBwYXIgPSBwYXIgJiYgcGFyLmlkID8gcGFyIDogdGhpcy5nZXRfbm9kZShwYXIpO1xcbiAgICAgIHZhciBtID0gb2JqICYmIG9iai5pZCA/IG1vcmUgJiYgbW9yZS5vcmlnaW4gPyBtb3JlLm9yaWdpbiA6ICQuanN0cmVlLnJlZmVyZW5jZShvYmouaWQpIDogbnVsbCxcXG4gICAgICAgICAgdG1wLFxcbiAgICAgICAgICBkLFxcbiAgICAgICAgICBpLFxcbiAgICAgICAgICBqO1xcbiAgICAgIG0gPSBtICYmIG0uX21vZGVsICYmIG0uX21vZGVsLmRhdGEgPyBtLl9tb2RlbC5kYXRhIDogbnVsbDtcXG5cXG4gICAgICBzd2l0Y2ggKGNoaykge1xcbiAgICAgICAgY2FzZSBcXFwiY3JlYXRlX25vZGVcXFwiOlxcbiAgICAgICAgY2FzZSBcXFwibW92ZV9ub2RlXFxcIjpcXG4gICAgICAgIGNhc2UgXFxcImNvcHlfbm9kZVxcXCI6XFxuICAgICAgICAgIGlmIChjaGsgIT09ICdtb3ZlX25vZGUnIHx8ICQuaW5BcnJheShvYmouaWQsIHBhci5jaGlsZHJlbikgPT09IC0xKSB7XFxuICAgICAgICAgICAgdG1wID0gdGhpcy5nZXRfcnVsZXMocGFyKTtcXG5cXG4gICAgICAgICAgICBpZiAodG1wLm1heF9jaGlsZHJlbiAhPT0gdW5kZWZpbmVkICYmIHRtcC5tYXhfY2hpbGRyZW4gIT09IC0xICYmIHRtcC5tYXhfY2hpbGRyZW4gPT09IHBhci5jaGlsZHJlbi5sZW5ndGgpIHtcXG4gICAgICAgICAgICAgIHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yID0ge1xcbiAgICAgICAgICAgICAgICAnZXJyb3InOiAnY2hlY2snLFxcbiAgICAgICAgICAgICAgICAncGx1Z2luJzogJ3R5cGVzJyxcXG4gICAgICAgICAgICAgICAgJ2lkJzogJ3R5cGVzXzAxJyxcXG4gICAgICAgICAgICAgICAgJ3JlYXNvbic6ICdtYXhfY2hpbGRyZW4gcHJldmVudHMgZnVuY3Rpb246ICcgKyBjaGssXFxuICAgICAgICAgICAgICAgICdkYXRhJzogSlNPTi5zdHJpbmdpZnkoe1xcbiAgICAgICAgICAgICAgICAgICdjaGsnOiBjaGssXFxuICAgICAgICAgICAgICAgICAgJ3Bvcyc6IHBvcyxcXG4gICAgICAgICAgICAgICAgICAnb2JqJzogb2JqICYmIG9iai5pZCA/IG9iai5pZCA6IGZhbHNlLFxcbiAgICAgICAgICAgICAgICAgICdwYXInOiBwYXIgJiYgcGFyLmlkID8gcGFyLmlkIDogZmFsc2VcXG4gICAgICAgICAgICAgICAgfSlcXG4gICAgICAgICAgICAgIH07XFxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmICh0bXAudmFsaWRfY2hpbGRyZW4gIT09IHVuZGVmaW5lZCAmJiB0bXAudmFsaWRfY2hpbGRyZW4gIT09IC0xICYmICQuaW5BcnJheShvYmoudHlwZSB8fCAnZGVmYXVsdCcsIHRtcC52YWxpZF9jaGlsZHJlbikgPT09IC0xKSB7XFxuICAgICAgICAgICAgICB0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvciA9IHtcXG4gICAgICAgICAgICAgICAgJ2Vycm9yJzogJ2NoZWNrJyxcXG4gICAgICAgICAgICAgICAgJ3BsdWdpbic6ICd0eXBlcycsXFxuICAgICAgICAgICAgICAgICdpZCc6ICd0eXBlc18wMicsXFxuICAgICAgICAgICAgICAgICdyZWFzb24nOiAndmFsaWRfY2hpbGRyZW4gcHJldmVudHMgZnVuY3Rpb246ICcgKyBjaGssXFxuICAgICAgICAgICAgICAgICdkYXRhJzogSlNPTi5zdHJpbmdpZnkoe1xcbiAgICAgICAgICAgICAgICAgICdjaGsnOiBjaGssXFxuICAgICAgICAgICAgICAgICAgJ3Bvcyc6IHBvcyxcXG4gICAgICAgICAgICAgICAgICAnb2JqJzogb2JqICYmIG9iai5pZCA/IG9iai5pZCA6IGZhbHNlLFxcbiAgICAgICAgICAgICAgICAgICdwYXInOiBwYXIgJiYgcGFyLmlkID8gcGFyLmlkIDogZmFsc2VcXG4gICAgICAgICAgICAgICAgfSlcXG4gICAgICAgICAgICAgIH07XFxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmIChtICYmIG9iai5jaGlsZHJlbl9kICYmIG9iai5wYXJlbnRzKSB7XFxuICAgICAgICAgICAgICBkID0gMDtcXG5cXG4gICAgICAgICAgICAgIGZvciAoaSA9IDAsIGogPSBvYmouY2hpbGRyZW5fZC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcXG4gICAgICAgICAgICAgICAgZCA9IE1hdGgubWF4KGQsIG1bb2JqLmNoaWxkcmVuX2RbaV1dLnBhcmVudHMubGVuZ3RoKTtcXG4gICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgIGQgPSBkIC0gb2JqLnBhcmVudHMubGVuZ3RoICsgMTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaWYgKGQgPD0gMCB8fCBkID09PSB1bmRlZmluZWQpIHtcXG4gICAgICAgICAgICAgIGQgPSAxO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBkbyB7XFxuICAgICAgICAgICAgICBpZiAodG1wLm1heF9kZXB0aCAhPT0gdW5kZWZpbmVkICYmIHRtcC5tYXhfZGVwdGggIT09IC0xICYmIHRtcC5tYXhfZGVwdGggPCBkKSB7XFxuICAgICAgICAgICAgICAgIHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yID0ge1xcbiAgICAgICAgICAgICAgICAgICdlcnJvcic6ICdjaGVjaycsXFxuICAgICAgICAgICAgICAgICAgJ3BsdWdpbic6ICd0eXBlcycsXFxuICAgICAgICAgICAgICAgICAgJ2lkJzogJ3R5cGVzXzAzJyxcXG4gICAgICAgICAgICAgICAgICAncmVhc29uJzogJ21heF9kZXB0aCBwcmV2ZW50cyBmdW5jdGlvbjogJyArIGNoayxcXG4gICAgICAgICAgICAgICAgICAnZGF0YSc6IEpTT04uc3RyaW5naWZ5KHtcXG4gICAgICAgICAgICAgICAgICAgICdjaGsnOiBjaGssXFxuICAgICAgICAgICAgICAgICAgICAncG9zJzogcG9zLFxcbiAgICAgICAgICAgICAgICAgICAgJ29iaic6IG9iaiAmJiBvYmouaWQgPyBvYmouaWQgOiBmYWxzZSxcXG4gICAgICAgICAgICAgICAgICAgICdwYXInOiBwYXIgJiYgcGFyLmlkID8gcGFyLmlkIDogZmFsc2VcXG4gICAgICAgICAgICAgICAgICB9KVxcbiAgICAgICAgICAgICAgICB9O1xcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICBwYXIgPSB0aGlzLmdldF9ub2RlKHBhci5wYXJlbnQpO1xcbiAgICAgICAgICAgICAgdG1wID0gdGhpcy5nZXRfcnVsZXMocGFyKTtcXG4gICAgICAgICAgICAgIGQrKztcXG4gICAgICAgICAgICB9IHdoaWxlIChwYXIpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGJyZWFrO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgfTtcXG4gICAgLyoqXFxuICAgICAqIHVzZWQgdG8gcmV0cmlldmUgdGhlIHR5cGUgc2V0dGluZ3Mgb2JqZWN0IGZvciBhIG5vZGVcXG4gICAgICogQG5hbWUgZ2V0X3J1bGVzKG9iailcXG4gICAgICogQHBhcmFtIHttaXhlZH0gb2JqIHRoZSBub2RlIHRvIGZpbmQgdGhlIHJ1bGVzIGZvclxcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XFxuICAgICAqIEBwbHVnaW4gdHlwZXNcXG4gICAgICovXFxuXFxuXFxuICAgIHRoaXMuZ2V0X3J1bGVzID0gZnVuY3Rpb24gKG9iaikge1xcbiAgICAgIG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcXG5cXG4gICAgICBpZiAoIW9iaikge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgdG1wID0gdGhpcy5nZXRfdHlwZShvYmosIHRydWUpO1xcblxcbiAgICAgIGlmICh0bXAubWF4X2RlcHRoID09PSB1bmRlZmluZWQpIHtcXG4gICAgICAgIHRtcC5tYXhfZGVwdGggPSAtMTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRtcC5tYXhfY2hpbGRyZW4gPT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgdG1wLm1heF9jaGlsZHJlbiA9IC0xO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodG1wLnZhbGlkX2NoaWxkcmVuID09PSB1bmRlZmluZWQpIHtcXG4gICAgICAgIHRtcC52YWxpZF9jaGlsZHJlbiA9IC0xO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gdG1wO1xcbiAgICB9O1xcbiAgICAvKipcXG4gICAgICogdXNlZCB0byByZXRyaWV2ZSB0aGUgdHlwZSBzdHJpbmcgb3Igc2V0dGluZ3Mgb2JqZWN0IGZvciBhIG5vZGVcXG4gICAgICogQG5hbWUgZ2V0X3R5cGUob2JqIFssIHJ1bGVzXSlcXG4gICAgICogQHBhcmFtIHttaXhlZH0gb2JqIHRoZSBub2RlIHRvIGZpbmQgdGhlIHJ1bGVzIGZvclxcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJ1bGVzIGlmIHNldCB0byBgdHJ1ZWAgaW5zdGVhZCBvZiBhIHN0cmluZyB0aGUgc2V0dGluZ3Mgb2JqZWN0IHdpbGwgYmUgcmV0dXJuZWRcXG4gICAgICogQHJldHVybiB7U3RyaW5nfE9iamVjdH1cXG4gICAgICogQHBsdWdpbiB0eXBlc1xcbiAgICAgKi9cXG5cXG5cXG4gICAgdGhpcy5nZXRfdHlwZSA9IGZ1bmN0aW9uIChvYmosIHJ1bGVzKSB7XFxuICAgICAgb2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xcbiAgICAgIHJldHVybiAhb2JqID8gZmFsc2UgOiBydWxlcyA/ICQuZXh0ZW5kKHtcXG4gICAgICAgICd0eXBlJzogb2JqLnR5cGVcXG4gICAgICB9LCB0aGlzLnNldHRpbmdzLnR5cGVzW29iai50eXBlXSkgOiBvYmoudHlwZTtcXG4gICAgfTtcXG4gICAgLyoqXFxuICAgICAqIHVzZWQgdG8gY2hhbmdlIGEgbm9kZSdzIHR5cGVcXG4gICAgICogQG5hbWUgc2V0X3R5cGUob2JqLCB0eXBlKVxcbiAgICAgKiBAcGFyYW0ge21peGVkfSBvYmogdGhlIG5vZGUgdG8gY2hhbmdlXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIHRoZSBuZXcgdHlwZVxcbiAgICAgKiBAcGx1Z2luIHR5cGVzXFxuICAgICAqL1xcblxcblxcbiAgICB0aGlzLnNldF90eXBlID0gZnVuY3Rpb24gKG9iaiwgdHlwZSkge1xcbiAgICAgIHZhciBtID0gdGhpcy5fbW9kZWwuZGF0YSxcXG4gICAgICAgICAgdCxcXG4gICAgICAgICAgdDEsXFxuICAgICAgICAgIHQyLFxcbiAgICAgICAgICBvbGRfdHlwZSxcXG4gICAgICAgICAgb2xkX2ljb24sXFxuICAgICAgICAgIGssXFxuICAgICAgICAgIGQsXFxuICAgICAgICAgIGE7XFxuXFxuICAgICAgaWYgKCQuaXNBcnJheShvYmopKSB7XFxuICAgICAgICBvYmogPSBvYmouc2xpY2UoKTtcXG5cXG4gICAgICAgIGZvciAodDEgPSAwLCB0MiA9IG9iai5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcXG4gICAgICAgICAgdGhpcy5zZXRfdHlwZShvYmpbdDFdLCB0eXBlKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgIH1cXG5cXG4gICAgICB0ID0gdGhpcy5zZXR0aW5ncy50eXBlcztcXG4gICAgICBvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XFxuXFxuICAgICAgaWYgKCF0W3R5cGVdIHx8ICFvYmopIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgZCA9IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKTtcXG5cXG4gICAgICBpZiAoZCAmJiBkLmxlbmd0aCkge1xcbiAgICAgICAgYSA9IGQuY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJyk7XFxuICAgICAgfVxcblxcbiAgICAgIG9sZF90eXBlID0gb2JqLnR5cGU7XFxuICAgICAgb2xkX2ljb24gPSB0aGlzLmdldF9pY29uKG9iaik7XFxuICAgICAgb2JqLnR5cGUgPSB0eXBlO1xcblxcbiAgICAgIGlmIChvbGRfaWNvbiA9PT0gdHJ1ZSB8fCAhdFtvbGRfdHlwZV0gfHwgdFtvbGRfdHlwZV0uaWNvbiAhPT0gdW5kZWZpbmVkICYmIG9sZF9pY29uID09PSB0W29sZF90eXBlXS5pY29uKSB7XFxuICAgICAgICB0aGlzLnNldF9pY29uKG9iaiwgdFt0eXBlXS5pY29uICE9PSB1bmRlZmluZWQgPyB0W3R5cGVdLmljb24gOiB0cnVlKTtcXG4gICAgICB9IC8vIHJlbW92ZSBvbGQgdHlwZSBwcm9wc1xcblxcblxcbiAgICAgIGlmICh0W29sZF90eXBlXSAmJiB0W29sZF90eXBlXS5saV9hdHRyICE9PSB1bmRlZmluZWQgJiYgX3R5cGVvZih0W29sZF90eXBlXS5saV9hdHRyKSA9PT0gJ29iamVjdCcpIHtcXG4gICAgICAgIGZvciAoayBpbiB0W29sZF90eXBlXS5saV9hdHRyKSB7XFxuICAgICAgICAgIGlmICh0W29sZF90eXBlXS5saV9hdHRyLmhhc093blByb3BlcnR5KGspKSB7XFxuICAgICAgICAgICAgaWYgKGsgPT09ICdpZCcpIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoayA9PT0gJ2NsYXNzJykge1xcbiAgICAgICAgICAgICAgbVtvYmouaWRdLmxpX2F0dHJbJ2NsYXNzJ10gPSAobVtvYmouaWRdLmxpX2F0dHJbJ2NsYXNzJ10gfHwgJycpLnJlcGxhY2UodFtvbGRfdHlwZV0ubGlfYXR0cltrXSwgJycpO1xcblxcbiAgICAgICAgICAgICAgaWYgKGQpIHtcXG4gICAgICAgICAgICAgICAgZC5yZW1vdmVDbGFzcyh0W29sZF90eXBlXS5saV9hdHRyW2tdKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1bb2JqLmlkXS5saV9hdHRyW2tdID09PSB0W29sZF90eXBlXS5saV9hdHRyW2tdKSB7XFxuICAgICAgICAgICAgICBtW29iai5pZF0ubGlfYXR0cltrXSA9IG51bGw7XFxuXFxuICAgICAgICAgICAgICBpZiAoZCkge1xcbiAgICAgICAgICAgICAgICBkLnJlbW92ZUF0dHIoayk7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0W29sZF90eXBlXSAmJiB0W29sZF90eXBlXS5hX2F0dHIgIT09IHVuZGVmaW5lZCAmJiBfdHlwZW9mKHRbb2xkX3R5cGVdLmFfYXR0cikgPT09ICdvYmplY3QnKSB7XFxuICAgICAgICBmb3IgKGsgaW4gdFtvbGRfdHlwZV0uYV9hdHRyKSB7XFxuICAgICAgICAgIGlmICh0W29sZF90eXBlXS5hX2F0dHIuaGFzT3duUHJvcGVydHkoaykpIHtcXG4gICAgICAgICAgICBpZiAoayA9PT0gJ2lkJykge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfSBlbHNlIGlmIChrID09PSAnY2xhc3MnKSB7XFxuICAgICAgICAgICAgICBtW29iai5pZF0uYV9hdHRyWydjbGFzcyddID0gKG1bb2JqLmlkXS5hX2F0dHJbJ2NsYXNzJ10gfHwgJycpLnJlcGxhY2UodFtvbGRfdHlwZV0uYV9hdHRyW2tdLCAnJyk7XFxuXFxuICAgICAgICAgICAgICBpZiAoYSkge1xcbiAgICAgICAgICAgICAgICBhLnJlbW92ZUNsYXNzKHRbb2xkX3R5cGVdLmFfYXR0cltrXSk7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSBlbHNlIGlmIChtW29iai5pZF0uYV9hdHRyW2tdID09PSB0W29sZF90eXBlXS5hX2F0dHJba10pIHtcXG4gICAgICAgICAgICAgIGlmIChrID09PSAnaHJlZicpIHtcXG4gICAgICAgICAgICAgICAgbVtvYmouaWRdLmFfYXR0cltrXSA9ICcjJztcXG5cXG4gICAgICAgICAgICAgICAgaWYgKGEpIHtcXG4gICAgICAgICAgICAgICAgICBhLmF0dHIoJ2hyZWYnLCAnIycpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICBkZWxldGUgbVtvYmouaWRdLmFfYXR0cltrXTtcXG5cXG4gICAgICAgICAgICAgICAgaWYgKGEpIHtcXG4gICAgICAgICAgICAgICAgICBhLnJlbW92ZUF0dHIoayk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9IC8vIGFkZCBuZXcgcHJvcHNcXG5cXG5cXG4gICAgICBpZiAodFt0eXBlXS5saV9hdHRyICE9PSB1bmRlZmluZWQgJiYgX3R5cGVvZih0W3R5cGVdLmxpX2F0dHIpID09PSAnb2JqZWN0Jykge1xcbiAgICAgICAgZm9yIChrIGluIHRbdHlwZV0ubGlfYXR0cikge1xcbiAgICAgICAgICBpZiAodFt0eXBlXS5saV9hdHRyLmhhc093blByb3BlcnR5KGspKSB7XFxuICAgICAgICAgICAgaWYgKGsgPT09ICdpZCcpIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobVtvYmouaWRdLmxpX2F0dHJba10gPT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgICAgICAgbVtvYmouaWRdLmxpX2F0dHJba10gPSB0W3R5cGVdLmxpX2F0dHJba107XFxuXFxuICAgICAgICAgICAgICBpZiAoZCkge1xcbiAgICAgICAgICAgICAgICBpZiAoayA9PT0gJ2NsYXNzJykge1xcbiAgICAgICAgICAgICAgICAgIGQuYWRkQ2xhc3ModFt0eXBlXS5saV9hdHRyW2tdKTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICBkLmF0dHIoaywgdFt0eXBlXS5saV9hdHRyW2tdKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoayA9PT0gJ2NsYXNzJykge1xcbiAgICAgICAgICAgICAgbVtvYmouaWRdLmxpX2F0dHJbJ2NsYXNzJ10gPSB0W3R5cGVdLmxpX2F0dHJba10gKyAnICcgKyBtW29iai5pZF0ubGlfYXR0clsnY2xhc3MnXTtcXG5cXG4gICAgICAgICAgICAgIGlmIChkKSB7XFxuICAgICAgICAgICAgICAgIGQuYWRkQ2xhc3ModFt0eXBlXS5saV9hdHRyW2tdKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRbdHlwZV0uYV9hdHRyICE9PSB1bmRlZmluZWQgJiYgX3R5cGVvZih0W3R5cGVdLmFfYXR0cikgPT09ICdvYmplY3QnKSB7XFxuICAgICAgICBmb3IgKGsgaW4gdFt0eXBlXS5hX2F0dHIpIHtcXG4gICAgICAgICAgaWYgKHRbdHlwZV0uYV9hdHRyLmhhc093blByb3BlcnR5KGspKSB7XFxuICAgICAgICAgICAgaWYgKGsgPT09ICdpZCcpIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobVtvYmouaWRdLmFfYXR0cltrXSA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgICAgICBtW29iai5pZF0uYV9hdHRyW2tdID0gdFt0eXBlXS5hX2F0dHJba107XFxuXFxuICAgICAgICAgICAgICBpZiAoYSkge1xcbiAgICAgICAgICAgICAgICBpZiAoayA9PT0gJ2NsYXNzJykge1xcbiAgICAgICAgICAgICAgICAgIGEuYWRkQ2xhc3ModFt0eXBlXS5hX2F0dHJba10pO1xcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgIGEuYXR0cihrLCB0W3R5cGVdLmFfYXR0cltrXSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGsgPT09ICdocmVmJyAmJiBtW29iai5pZF0uYV9hdHRyW2tdID09PSAnIycpIHtcXG4gICAgICAgICAgICAgIG1bb2JqLmlkXS5hX2F0dHJbJ2hyZWYnXSA9IHRbdHlwZV0uYV9hdHRyWydocmVmJ107XFxuXFxuICAgICAgICAgICAgICBpZiAoYSkge1xcbiAgICAgICAgICAgICAgICBhLmF0dHIoJ2hyZWYnLCB0W3R5cGVdLmFfYXR0clsnaHJlZiddKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGsgPT09ICdjbGFzcycpIHtcXG4gICAgICAgICAgICAgIG1bb2JqLmlkXS5hX2F0dHJbJ2NsYXNzJ10gPSB0W3R5cGVdLmFfYXR0clsnY2xhc3MnXSArICcgJyArIG1bb2JqLmlkXS5hX2F0dHJbJ2NsYXNzJ107XFxuXFxuICAgICAgICAgICAgICBpZiAoYSkge1xcbiAgICAgICAgICAgICAgICBhLmFkZENsYXNzKHRbdHlwZV0uYV9hdHRyW2tdKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHRydWU7XFxuICAgIH07XFxuICB9OyAvLyBpbmNsdWRlIHRoZSB0eXBlcyBwbHVnaW4gYnkgZGVmYXVsdFxcbiAgLy8gJC5qc3RyZWUuZGVmYXVsdHMucGx1Z2lucy5wdXNoKFxcXCJ0eXBlc1xcXCIpO1xcblxcbiAgLyoqXFxuICAgKiAjIyMgVW5pcXVlIHBsdWdpblxcbiAgICpcXG4gICAqIEVuZm9yY2VzIHRoYXQgbm8gbm9kZXMgd2l0aCB0aGUgc2FtZSBuYW1lIGNhbiBjb2V4aXN0IGFzIHNpYmxpbmdzLlxcbiAgICovXFxuXFxuICAvKipcXG4gICAqIHN0b3JlcyBhbGwgZGVmYXVsdHMgZm9yIHRoZSB1bmlxdWUgcGx1Z2luXFxuICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy51bmlxdWVcXG4gICAqIEBwbHVnaW4gdW5pcXVlXFxuICAgKi9cXG5cXG5cXG4gICQuanN0cmVlLmRlZmF1bHRzLnVuaXF1ZSA9IHtcXG4gICAgLyoqXFxuICAgICAqIEluZGljYXRlcyBpZiB0aGUgY29tcGFyaXNvbiBzaG91bGQgYmUgY2FzZSBzZW5zaXRpdmUuIERlZmF1bHQgaXMgYGZhbHNlYC5cXG4gICAgICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMudW5pcXVlLmNhc2Vfc2Vuc2l0aXZlXFxuICAgICAqIEBwbHVnaW4gdW5pcXVlXFxuICAgICAqL1xcbiAgICBjYXNlX3NlbnNpdGl2ZTogZmFsc2UsXFxuXFxuICAgIC8qKlxcbiAgICAgKiBBIGNhbGxiYWNrIGV4ZWN1dGVkIGluIHRoZSBpbnN0YW5jZSdzIHNjb3BlIHdoZW4gYSBuZXcgbm9kZSBpcyBjcmVhdGVkIGFuZCB0aGUgbmFtZSBpcyBhbHJlYWR5IHRha2VuLCB0aGUgdHdvIGFyZ3VtZW50cyBhcmUgdGhlIGNvbmZsaWN0aW5nIG5hbWUgYW5kIHRoZSBjb3VudGVyLiBUaGUgZGVmYXVsdCB3aWxsIHByb2R1Y2UgcmVzdWx0cyBsaWtlIGBOZXcgbm9kZSAoMilgLlxcbiAgICAgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy51bmlxdWUuZHVwbGljYXRlXFxuICAgICAqIEBwbHVnaW4gdW5pcXVlXFxuICAgICAqL1xcbiAgICBkdXBsaWNhdGU6IGZ1bmN0aW9uIGR1cGxpY2F0ZShuYW1lLCBjb3VudGVyKSB7XFxuICAgICAgcmV0dXJuIG5hbWUgKyAnICgnICsgY291bnRlciArICcpJztcXG4gICAgfVxcbiAgfTtcXG5cXG4gICQuanN0cmVlLnBsdWdpbnMudW5pcXVlID0gZnVuY3Rpb24gKG9wdGlvbnMsIHBhcmVudCkge1xcbiAgICB0aGlzLmNoZWNrID0gZnVuY3Rpb24gKGNoaywgb2JqLCBwYXIsIHBvcywgbW9yZSkge1xcbiAgICAgIGlmIChwYXJlbnQuY2hlY2suY2FsbCh0aGlzLCBjaGssIG9iaiwgcGFyLCBwb3MsIG1vcmUpID09PSBmYWxzZSkge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICBvYmogPSBvYmogJiYgb2JqLmlkID8gb2JqIDogdGhpcy5nZXRfbm9kZShvYmopO1xcbiAgICAgIHBhciA9IHBhciAmJiBwYXIuaWQgPyBwYXIgOiB0aGlzLmdldF9ub2RlKHBhcik7XFxuXFxuICAgICAgaWYgKCFwYXIgfHwgIXBhci5jaGlsZHJlbikge1xcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBuID0gY2hrID09PSBcXFwicmVuYW1lX25vZGVcXFwiID8gcG9zIDogb2JqLnRleHQsXFxuICAgICAgICAgIGMgPSBbXSxcXG4gICAgICAgICAgcyA9IHRoaXMuc2V0dGluZ3MudW5pcXVlLmNhc2Vfc2Vuc2l0aXZlLFxcbiAgICAgICAgICBtID0gdGhpcy5fbW9kZWwuZGF0YSxcXG4gICAgICAgICAgaSxcXG4gICAgICAgICAgajtcXG5cXG4gICAgICBmb3IgKGkgPSAwLCBqID0gcGFyLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcbiAgICAgICAgYy5wdXNoKHMgPyBtW3Bhci5jaGlsZHJlbltpXV0udGV4dCA6IG1bcGFyLmNoaWxkcmVuW2ldXS50ZXh0LnRvTG93ZXJDYXNlKCkpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIXMpIHtcXG4gICAgICAgIG4gPSBuLnRvTG93ZXJDYXNlKCk7XFxuICAgICAgfVxcblxcbiAgICAgIHN3aXRjaCAoY2hrKSB7XFxuICAgICAgICBjYXNlIFxcXCJkZWxldGVfbm9kZVxcXCI6XFxuICAgICAgICAgIHJldHVybiB0cnVlO1xcblxcbiAgICAgICAgY2FzZSBcXFwicmVuYW1lX25vZGVcXFwiOlxcbiAgICAgICAgICBpID0gJC5pbkFycmF5KG4sIGMpID09PSAtMSB8fCBvYmoudGV4dCAmJiBvYmoudGV4dFtzID8gJ3RvU3RyaW5nJyA6ICd0b0xvd2VyQ2FzZSddKCkgPT09IG47XFxuXFxuICAgICAgICAgIGlmICghaSkge1xcbiAgICAgICAgICAgIHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yID0ge1xcbiAgICAgICAgICAgICAgJ2Vycm9yJzogJ2NoZWNrJyxcXG4gICAgICAgICAgICAgICdwbHVnaW4nOiAndW5pcXVlJyxcXG4gICAgICAgICAgICAgICdpZCc6ICd1bmlxdWVfMDEnLFxcbiAgICAgICAgICAgICAgJ3JlYXNvbic6ICdDaGlsZCB3aXRoIG5hbWUgJyArIG4gKyAnIGFscmVhZHkgZXhpc3RzLiBQcmV2ZW50aW5nOiAnICsgY2hrLFxcbiAgICAgICAgICAgICAgJ2RhdGEnOiBKU09OLnN0cmluZ2lmeSh7XFxuICAgICAgICAgICAgICAgICdjaGsnOiBjaGssXFxuICAgICAgICAgICAgICAgICdwb3MnOiBwb3MsXFxuICAgICAgICAgICAgICAgICdvYmonOiBvYmogJiYgb2JqLmlkID8gb2JqLmlkIDogZmFsc2UsXFxuICAgICAgICAgICAgICAgICdwYXInOiBwYXIgJiYgcGFyLmlkID8gcGFyLmlkIDogZmFsc2VcXG4gICAgICAgICAgICAgIH0pXFxuICAgICAgICAgICAgfTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICByZXR1cm4gaTtcXG5cXG4gICAgICAgIGNhc2UgXFxcImNyZWF0ZV9ub2RlXFxcIjpcXG4gICAgICAgICAgaSA9ICQuaW5BcnJheShuLCBjKSA9PT0gLTE7XFxuXFxuICAgICAgICAgIGlmICghaSkge1xcbiAgICAgICAgICAgIHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yID0ge1xcbiAgICAgICAgICAgICAgJ2Vycm9yJzogJ2NoZWNrJyxcXG4gICAgICAgICAgICAgICdwbHVnaW4nOiAndW5pcXVlJyxcXG4gICAgICAgICAgICAgICdpZCc6ICd1bmlxdWVfMDQnLFxcbiAgICAgICAgICAgICAgJ3JlYXNvbic6ICdDaGlsZCB3aXRoIG5hbWUgJyArIG4gKyAnIGFscmVhZHkgZXhpc3RzLiBQcmV2ZW50aW5nOiAnICsgY2hrLFxcbiAgICAgICAgICAgICAgJ2RhdGEnOiBKU09OLnN0cmluZ2lmeSh7XFxuICAgICAgICAgICAgICAgICdjaGsnOiBjaGssXFxuICAgICAgICAgICAgICAgICdwb3MnOiBwb3MsXFxuICAgICAgICAgICAgICAgICdvYmonOiBvYmogJiYgb2JqLmlkID8gb2JqLmlkIDogZmFsc2UsXFxuICAgICAgICAgICAgICAgICdwYXInOiBwYXIgJiYgcGFyLmlkID8gcGFyLmlkIDogZmFsc2VcXG4gICAgICAgICAgICAgIH0pXFxuICAgICAgICAgICAgfTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICByZXR1cm4gaTtcXG5cXG4gICAgICAgIGNhc2UgXFxcImNvcHlfbm9kZVxcXCI6XFxuICAgICAgICAgIGkgPSAkLmluQXJyYXkobiwgYykgPT09IC0xO1xcblxcbiAgICAgICAgICBpZiAoIWkpIHtcXG4gICAgICAgICAgICB0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvciA9IHtcXG4gICAgICAgICAgICAgICdlcnJvcic6ICdjaGVjaycsXFxuICAgICAgICAgICAgICAncGx1Z2luJzogJ3VuaXF1ZScsXFxuICAgICAgICAgICAgICAnaWQnOiAndW5pcXVlXzAyJyxcXG4gICAgICAgICAgICAgICdyZWFzb24nOiAnQ2hpbGQgd2l0aCBuYW1lICcgKyBuICsgJyBhbHJlYWR5IGV4aXN0cy4gUHJldmVudGluZzogJyArIGNoayxcXG4gICAgICAgICAgICAgICdkYXRhJzogSlNPTi5zdHJpbmdpZnkoe1xcbiAgICAgICAgICAgICAgICAnY2hrJzogY2hrLFxcbiAgICAgICAgICAgICAgICAncG9zJzogcG9zLFxcbiAgICAgICAgICAgICAgICAnb2JqJzogb2JqICYmIG9iai5pZCA/IG9iai5pZCA6IGZhbHNlLFxcbiAgICAgICAgICAgICAgICAncGFyJzogcGFyICYmIHBhci5pZCA/IHBhci5pZCA6IGZhbHNlXFxuICAgICAgICAgICAgICB9KVxcbiAgICAgICAgICAgIH07XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgcmV0dXJuIGk7XFxuXFxuICAgICAgICBjYXNlIFxcXCJtb3ZlX25vZGVcXFwiOlxcbiAgICAgICAgICBpID0gb2JqLnBhcmVudCA9PT0gcGFyLmlkICYmICghbW9yZSB8fCAhbW9yZS5pc19tdWx0aSkgfHwgJC5pbkFycmF5KG4sIGMpID09PSAtMTtcXG5cXG4gICAgICAgICAgaWYgKCFpKSB7XFxuICAgICAgICAgICAgdGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IgPSB7XFxuICAgICAgICAgICAgICAnZXJyb3InOiAnY2hlY2snLFxcbiAgICAgICAgICAgICAgJ3BsdWdpbic6ICd1bmlxdWUnLFxcbiAgICAgICAgICAgICAgJ2lkJzogJ3VuaXF1ZV8wMycsXFxuICAgICAgICAgICAgICAncmVhc29uJzogJ0NoaWxkIHdpdGggbmFtZSAnICsgbiArICcgYWxyZWFkeSBleGlzdHMuIFByZXZlbnRpbmc6ICcgKyBjaGssXFxuICAgICAgICAgICAgICAnZGF0YSc6IEpTT04uc3RyaW5naWZ5KHtcXG4gICAgICAgICAgICAgICAgJ2Noayc6IGNoayxcXG4gICAgICAgICAgICAgICAgJ3Bvcyc6IHBvcyxcXG4gICAgICAgICAgICAgICAgJ29iaic6IG9iaiAmJiBvYmouaWQgPyBvYmouaWQgOiBmYWxzZSxcXG4gICAgICAgICAgICAgICAgJ3Bhcic6IHBhciAmJiBwYXIuaWQgPyBwYXIuaWQgOiBmYWxzZVxcbiAgICAgICAgICAgICAgfSlcXG4gICAgICAgICAgICB9O1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHJldHVybiBpO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5jcmVhdGVfbm9kZSA9IGZ1bmN0aW9uIChwYXIsIG5vZGUsIHBvcywgY2FsbGJhY2ssIGlzX2xvYWRlZCkge1xcbiAgICAgIGlmICghbm9kZSB8fCBub2RlLnRleHQgPT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgaWYgKHBhciA9PT0gbnVsbCkge1xcbiAgICAgICAgICBwYXIgPSAkLmpzdHJlZS5yb290O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcGFyID0gdGhpcy5nZXRfbm9kZShwYXIpO1xcblxcbiAgICAgICAgaWYgKCFwYXIpIHtcXG4gICAgICAgICAgcmV0dXJuIHBhcmVudC5jcmVhdGVfbm9kZS5jYWxsKHRoaXMsIHBhciwgbm9kZSwgcG9zLCBjYWxsYmFjaywgaXNfbG9hZGVkKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHBvcyA9IHBvcyA9PT0gdW5kZWZpbmVkID8gXFxcImxhc3RcXFwiIDogcG9zO1xcblxcbiAgICAgICAgaWYgKCFwb3MudG9TdHJpbmcoKS5tYXRjaCgvXihiZWZvcmV8YWZ0ZXIpJC8pICYmICFpc19sb2FkZWQgJiYgIXRoaXMuaXNfbG9hZGVkKHBhcikpIHtcXG4gICAgICAgICAgcmV0dXJuIHBhcmVudC5jcmVhdGVfbm9kZS5jYWxsKHRoaXMsIHBhciwgbm9kZSwgcG9zLCBjYWxsYmFjaywgaXNfbG9hZGVkKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICghbm9kZSkge1xcbiAgICAgICAgICBub2RlID0ge307XFxuICAgICAgICB9XFxuXFxuICAgICAgICB2YXIgdG1wLFxcbiAgICAgICAgICAgIG4sXFxuICAgICAgICAgICAgZHBjLFxcbiAgICAgICAgICAgIGksXFxuICAgICAgICAgICAgaixcXG4gICAgICAgICAgICBtID0gdGhpcy5fbW9kZWwuZGF0YSxcXG4gICAgICAgICAgICBzID0gdGhpcy5zZXR0aW5ncy51bmlxdWUuY2FzZV9zZW5zaXRpdmUsXFxuICAgICAgICAgICAgY2IgPSB0aGlzLnNldHRpbmdzLnVuaXF1ZS5kdXBsaWNhdGU7XFxuICAgICAgICBuID0gdG1wID0gdGhpcy5nZXRfc3RyaW5nKCdOZXcgbm9kZScpO1xcbiAgICAgICAgZHBjID0gW107XFxuXFxuICAgICAgICBmb3IgKGkgPSAwLCBqID0gcGFyLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xcbiAgICAgICAgICBkcGMucHVzaChzID8gbVtwYXIuY2hpbGRyZW5baV1dLnRleHQgOiBtW3Bhci5jaGlsZHJlbltpXV0udGV4dC50b0xvd2VyQ2FzZSgpKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGkgPSAxO1xcblxcbiAgICAgICAgd2hpbGUgKCQuaW5BcnJheShzID8gbiA6IG4udG9Mb3dlckNhc2UoKSwgZHBjKSAhPT0gLTEpIHtcXG4gICAgICAgICAgbiA9IGNiLmNhbGwodGhpcywgdG1wLCArK2kpLnRvU3RyaW5nKCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBub2RlLnRleHQgPSBuO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gcGFyZW50LmNyZWF0ZV9ub2RlLmNhbGwodGhpcywgcGFyLCBub2RlLCBwb3MsIGNhbGxiYWNrLCBpc19sb2FkZWQpO1xcbiAgICB9O1xcbiAgfTsgLy8gaW5jbHVkZSB0aGUgdW5pcXVlIHBsdWdpbiBieSBkZWZhdWx0XFxuICAvLyAkLmpzdHJlZS5kZWZhdWx0cy5wbHVnaW5zLnB1c2goXFxcInVuaXF1ZVxcXCIpO1xcblxcbiAgLyoqXFxuICAgKiAjIyMgV2hvbGVyb3cgcGx1Z2luXFxuICAgKlxcbiAgICogTWFrZXMgZWFjaCBub2RlIGFwcGVhciBibG9jayBsZXZlbC4gTWFraW5nIHNlbGVjdGlvbiBlYXNpZXIuIE1heSBjYXVzZSBzbG93IGRvd24gZm9yIGxhcmdlIHRyZWVzIGluIG9sZCBicm93c2Vycy5cXG4gICAqL1xcblxcblxcbiAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xcbiAgZGl2LnNldEF0dHJpYnV0ZSgndW5zZWxlY3RhYmxlJywgJ29uJyk7XFxuICBkaXYuc2V0QXR0cmlidXRlKCdyb2xlJywgJ3ByZXNlbnRhdGlvbicpO1xcbiAgZGl2LmNsYXNzTmFtZSA9ICdqc3RyZWUtd2hvbGVyb3cnO1xcbiAgZGl2LmlubmVySFRNTCA9ICcmIzE2MDsnO1xcblxcbiAgJC5qc3RyZWUucGx1Z2lucy53aG9sZXJvdyA9IGZ1bmN0aW9uIChvcHRpb25zLCBwYXJlbnQpIHtcXG4gICAgdGhpcy5iaW5kID0gZnVuY3Rpb24gKCkge1xcbiAgICAgIHBhcmVudC5iaW5kLmNhbGwodGhpcyk7XFxuICAgICAgdGhpcy5lbGVtZW50Lm9uKCdyZWFkeS5qc3RyZWUgc2V0X3N0YXRlLmpzdHJlZScsICQucHJveHkoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdGhpcy5oaWRlX2RvdHMoKTtcXG4gICAgICB9LCB0aGlzKSkub24oXFxcImluaXQuanN0cmVlIGxvYWRpbmcuanN0cmVlIHJlYWR5LmpzdHJlZVxcXCIsICQucHJveHkoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgLy9kaXYuc3R5bGUuaGVpZ2h0ID0gdGhpcy5fZGF0YS5jb3JlLmxpX2hlaWdodCArICdweCc7XFxuICAgICAgICB0aGlzLmdldF9jb250YWluZXJfdWwoKS5hZGRDbGFzcygnanN0cmVlLXdob2xlcm93LXVsJyk7XFxuICAgICAgfSwgdGhpcykpLm9uKFxcXCJkZXNlbGVjdF9hbGwuanN0cmVlXFxcIiwgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xcbiAgICAgICAgdGhpcy5lbGVtZW50LmZpbmQoJy5qc3RyZWUtd2hvbGVyb3ctY2xpY2tlZCcpLnJlbW92ZUNsYXNzKCdqc3RyZWUtd2hvbGVyb3ctY2xpY2tlZCcpO1xcbiAgICAgIH0sIHRoaXMpKS5vbihcXFwiY2hhbmdlZC5qc3RyZWVcXFwiLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XFxuICAgICAgICB0aGlzLmVsZW1lbnQuZmluZCgnLmpzdHJlZS13aG9sZXJvdy1jbGlja2VkJykucmVtb3ZlQ2xhc3MoJ2pzdHJlZS13aG9sZXJvdy1jbGlja2VkJyk7XFxuICAgICAgICB2YXIgdG1wID0gZmFsc2UsXFxuICAgICAgICAgICAgaSxcXG4gICAgICAgICAgICBqO1xcblxcbiAgICAgICAgZm9yIChpID0gMCwgaiA9IGRhdGEuc2VsZWN0ZWQubGVuZ3RoOyBpIDwgajsgaSsrKSB7XFxuICAgICAgICAgIHRtcCA9IHRoaXMuZ2V0X25vZGUoZGF0YS5zZWxlY3RlZFtpXSwgdHJ1ZSk7XFxuXFxuICAgICAgICAgIGlmICh0bXAgJiYgdG1wLmxlbmd0aCkge1xcbiAgICAgICAgICAgIHRtcC5jaGlsZHJlbignLmpzdHJlZS13aG9sZXJvdycpLmFkZENsYXNzKCdqc3RyZWUtd2hvbGVyb3ctY2xpY2tlZCcpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfSwgdGhpcykpLm9uKFxcXCJvcGVuX25vZGUuanN0cmVlXFxcIiwgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xcbiAgICAgICAgdGhpcy5nZXRfbm9kZShkYXRhLm5vZGUsIHRydWUpLmZpbmQoJy5qc3RyZWUtY2xpY2tlZCcpLnBhcmVudCgpLmNoaWxkcmVuKCcuanN0cmVlLXdob2xlcm93JykuYWRkQ2xhc3MoJ2pzdHJlZS13aG9sZXJvdy1jbGlja2VkJyk7XFxuICAgICAgfSwgdGhpcykpLm9uKFxcXCJob3Zlcl9ub2RlLmpzdHJlZSBkZWhvdmVyX25vZGUuanN0cmVlXFxcIiwgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xcbiAgICAgICAgaWYgKGUudHlwZSA9PT0gXFxcImhvdmVyX25vZGVcXFwiICYmIHRoaXMuaXNfZGlzYWJsZWQoZGF0YS5ub2RlKSkge1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0aGlzLmdldF9ub2RlKGRhdGEubm9kZSwgdHJ1ZSkuY2hpbGRyZW4oJy5qc3RyZWUtd2hvbGVyb3cnKVtlLnR5cGUgPT09IFxcXCJob3Zlcl9ub2RlXFxcIiA/IFxcXCJhZGRDbGFzc1xcXCIgOiBcXFwicmVtb3ZlQ2xhc3NcXFwiXSgnanN0cmVlLXdob2xlcm93LWhvdmVyZWQnKTtcXG4gICAgICB9LCB0aGlzKSkub24oXFxcImNvbnRleHRtZW51LmpzdHJlZVxcXCIsIFxcXCIuanN0cmVlLXdob2xlcm93XFxcIiwgJC5wcm94eShmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgaWYgKHRoaXMuX2RhdGEuY29udGV4dG1lbnUpIHtcXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgICB2YXIgdG1wID0gJC5FdmVudCgnY29udGV4dG1lbnUnLCB7XFxuICAgICAgICAgICAgbWV0YUtleTogZS5tZXRhS2V5LFxcbiAgICAgICAgICAgIGN0cmxLZXk6IGUuY3RybEtleSxcXG4gICAgICAgICAgICBhbHRLZXk6IGUuYWx0S2V5LFxcbiAgICAgICAgICAgIHNoaWZ0S2V5OiBlLnNoaWZ0S2V5LFxcbiAgICAgICAgICAgIHBhZ2VYOiBlLnBhZ2VYLFxcbiAgICAgICAgICAgIHBhZ2VZOiBlLnBhZ2VZXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgICAkKGUuY3VycmVudFRhcmdldCkuY2xvc2VzdChcXFwiLmpzdHJlZS1ub2RlXFxcIikuY2hpbGRyZW4oXFxcIi5qc3RyZWUtYW5jaG9yXFxcIikuZmlyc3QoKS50cmlnZ2VyKHRtcCk7XFxuICAgICAgICB9XFxuICAgICAgfSwgdGhpcykpXFxuICAgICAgLyohXFxuICAgICAgLm9uKFxcXCJtb3VzZWRvd24uanN0cmVlIHRvdWNoc3RhcnQuanN0cmVlXFxcIiwgXFxcIi5qc3RyZWUtd2hvbGVyb3dcXFwiLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgIFxcdFxcdGlmKGUudGFyZ2V0ID09PSBlLmN1cnJlbnRUYXJnZXQpIHtcXG4gICAgICBcXHRcXHRcXHR2YXIgYSA9ICQoZS5jdXJyZW50VGFyZ2V0KS5jbG9zZXN0KFxcXCIuanN0cmVlLW5vZGVcXFwiKS5jaGlsZHJlbihcXFwiLmpzdHJlZS1hbmNob3JcXFwiKTtcXG4gICAgICBcXHRcXHRcXHRlLnRhcmdldCA9IGFbMF07XFxuICAgICAgXFx0XFx0XFx0YS50cmlnZ2VyKGUpO1xcbiAgICAgIFxcdFxcdH1cXG4gICAgICBcXHR9KVxcbiAgICAgICovXFxuICAgICAgLm9uKFxcXCJjbGljay5qc3RyZWVcXFwiLCBcXFwiLmpzdHJlZS13aG9sZXJvd1xcXCIsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xcbiAgICAgICAgdmFyIHRtcCA9ICQuRXZlbnQoJ2NsaWNrJywge1xcbiAgICAgICAgICBtZXRhS2V5OiBlLm1ldGFLZXksXFxuICAgICAgICAgIGN0cmxLZXk6IGUuY3RybEtleSxcXG4gICAgICAgICAgYWx0S2V5OiBlLmFsdEtleSxcXG4gICAgICAgICAgc2hpZnRLZXk6IGUuc2hpZnRLZXlcXG4gICAgICAgIH0pO1xcbiAgICAgICAgJChlLmN1cnJlbnRUYXJnZXQpLmNsb3Nlc3QoXFxcIi5qc3RyZWUtbm9kZVxcXCIpLmNoaWxkcmVuKFxcXCIuanN0cmVlLWFuY2hvclxcXCIpLmZpcnN0KCkudHJpZ2dlcih0bXApLmZvY3VzKCk7XFxuICAgICAgfSkub24oXFxcImRibGNsaWNrLmpzdHJlZVxcXCIsIFxcXCIuanN0cmVlLXdob2xlcm93XFxcIiwgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XFxuICAgICAgICB2YXIgdG1wID0gJC5FdmVudCgnZGJsY2xpY2snLCB7XFxuICAgICAgICAgIG1ldGFLZXk6IGUubWV0YUtleSxcXG4gICAgICAgICAgY3RybEtleTogZS5jdHJsS2V5LFxcbiAgICAgICAgICBhbHRLZXk6IGUuYWx0S2V5LFxcbiAgICAgICAgICBzaGlmdEtleTogZS5zaGlmdEtleVxcbiAgICAgICAgfSk7XFxuICAgICAgICAkKGUuY3VycmVudFRhcmdldCkuY2xvc2VzdChcXFwiLmpzdHJlZS1ub2RlXFxcIikuY2hpbGRyZW4oXFxcIi5qc3RyZWUtYW5jaG9yXFxcIikuZmlyc3QoKS50cmlnZ2VyKHRtcCkuZm9jdXMoKTtcXG4gICAgICB9KS5vbihcXFwiY2xpY2suanN0cmVlXFxcIiwgXFxcIi5qc3RyZWUtbGVhZiA+IC5qc3RyZWUtb2NsXFxcIiwgJC5wcm94eShmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcXG4gICAgICAgIHZhciB0bXAgPSAkLkV2ZW50KCdjbGljaycsIHtcXG4gICAgICAgICAgbWV0YUtleTogZS5tZXRhS2V5LFxcbiAgICAgICAgICBjdHJsS2V5OiBlLmN0cmxLZXksXFxuICAgICAgICAgIGFsdEtleTogZS5hbHRLZXksXFxuICAgICAgICAgIHNoaWZ0S2V5OiBlLnNoaWZ0S2V5XFxuICAgICAgICB9KTtcXG4gICAgICAgICQoZS5jdXJyZW50VGFyZ2V0KS5jbG9zZXN0KFxcXCIuanN0cmVlLW5vZGVcXFwiKS5jaGlsZHJlbihcXFwiLmpzdHJlZS1hbmNob3JcXFwiKS5maXJzdCgpLnRyaWdnZXIodG1wKS5mb2N1cygpO1xcbiAgICAgIH0sIHRoaXMpKS5vbihcXFwibW91c2VvdmVyLmpzdHJlZVxcXCIsIFxcXCIuanN0cmVlLXdob2xlcm93LCAuanN0cmVlLWljb25cXFwiLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xcblxcbiAgICAgICAgaWYgKCF0aGlzLmlzX2Rpc2FibGVkKGUuY3VycmVudFRhcmdldCkpIHtcXG4gICAgICAgICAgdGhpcy5ob3Zlcl9ub2RlKGUuY3VycmVudFRhcmdldCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfSwgdGhpcykpLm9uKFxcXCJtb3VzZWxlYXZlLmpzdHJlZVxcXCIsIFxcXCIuanN0cmVlLW5vZGVcXFwiLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICB0aGlzLmRlaG92ZXJfbm9kZShlLmN1cnJlbnRUYXJnZXQpO1xcbiAgICAgIH0sIHRoaXMpKTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy50ZWFyZG93biA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy53aG9sZXJvdykge1xcbiAgICAgICAgdGhpcy5lbGVtZW50LmZpbmQoXFxcIi5qc3RyZWUtd2hvbGVyb3dcXFwiKS5yZW1vdmUoKTtcXG4gICAgICB9XFxuXFxuICAgICAgcGFyZW50LnRlYXJkb3duLmNhbGwodGhpcyk7XFxuICAgIH07XFxuXFxuICAgIHRoaXMucmVkcmF3X25vZGUgPSBmdW5jdGlvbiAob2JqLCBkZWVwLCBjYWxsYmFjaywgZm9yY2VfcmVuZGVyKSB7XFxuICAgICAgb2JqID0gcGFyZW50LnJlZHJhd19ub2RlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuXFxuICAgICAgaWYgKG9iaikge1xcbiAgICAgICAgdmFyIHRtcCA9IGRpdi5jbG9uZU5vZGUodHJ1ZSk7IC8vdG1wLnN0eWxlLmhlaWdodCA9IHRoaXMuX2RhdGEuY29yZS5saV9oZWlnaHQgKyAncHgnO1xcblxcbiAgICAgICAgaWYgKCQuaW5BcnJheShvYmouaWQsIHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZCkgIT09IC0xKSB7XFxuICAgICAgICAgIHRtcC5jbGFzc05hbWUgKz0gJyBqc3RyZWUtd2hvbGVyb3ctY2xpY2tlZCc7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAodGhpcy5fZGF0YS5jb3JlLmZvY3VzZWQgJiYgdGhpcy5fZGF0YS5jb3JlLmZvY3VzZWQgPT09IG9iai5pZCkge1xcbiAgICAgICAgICB0bXAuY2xhc3NOYW1lICs9ICcganN0cmVlLXdob2xlcm93LWhvdmVyZWQnO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgb2JqLmluc2VydEJlZm9yZSh0bXAsIG9iai5jaGlsZE5vZGVzWzBdKTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIG9iajtcXG4gICAgfTtcXG4gIH07IC8vIGluY2x1ZGUgdGhlIHdob2xlcm93IHBsdWdpbiBieSBkZWZhdWx0XFxuICAvLyAkLmpzdHJlZS5kZWZhdWx0cy5wbHVnaW5zLnB1c2goXFxcIndob2xlcm93XFxcIik7XFxuXFxuXFxuICBpZiAoZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50ICYmIE9iamVjdCAmJiBPYmplY3QuY3JlYXRlKSB7XFxuICAgIHZhciBwcm90byA9IE9iamVjdC5jcmVhdGUoSFRNTEVsZW1lbnQucHJvdG90eXBlKTtcXG5cXG4gICAgcHJvdG8uY3JlYXRlZENhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xcbiAgICAgIHZhciBjID0ge1xcbiAgICAgICAgY29yZToge30sXFxuICAgICAgICBwbHVnaW5zOiBbXVxcbiAgICAgIH0sXFxuICAgICAgICAgIGk7XFxuXFxuICAgICAgZm9yIChpIGluICQuanN0cmVlLnBsdWdpbnMpIHtcXG4gICAgICAgIGlmICgkLmpzdHJlZS5wbHVnaW5zLmhhc093blByb3BlcnR5KGkpICYmIHRoaXMuYXR0cmlidXRlc1tpXSkge1xcbiAgICAgICAgICBjLnBsdWdpbnMucHVzaChpKTtcXG5cXG4gICAgICAgICAgaWYgKHRoaXMuZ2V0QXR0cmlidXRlKGkpICYmIEpTT04ucGFyc2UodGhpcy5nZXRBdHRyaWJ1dGUoaSkpKSB7XFxuICAgICAgICAgICAgY1tpXSA9IEpTT04ucGFyc2UodGhpcy5nZXRBdHRyaWJ1dGUoaSkpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGZvciAoaSBpbiAkLmpzdHJlZS5kZWZhdWx0cy5jb3JlKSB7XFxuICAgICAgICBpZiAoJC5qc3RyZWUuZGVmYXVsdHMuY29yZS5oYXNPd25Qcm9wZXJ0eShpKSAmJiB0aGlzLmF0dHJpYnV0ZXNbaV0pIHtcXG4gICAgICAgICAgYy5jb3JlW2ldID0gSlNPTi5wYXJzZSh0aGlzLmdldEF0dHJpYnV0ZShpKSkgfHwgdGhpcy5nZXRBdHRyaWJ1dGUoaSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgICQodGhpcykuanN0cmVlKGMpO1xcbiAgICB9OyAvLyBwcm90by5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sgPSBmdW5jdGlvbiAobmFtZSwgcHJldmlvdXMsIHZhbHVlKSB7IH07XFxuXFxuXFxuICAgIHRyeSB7XFxuICAgICAgZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KFxcXCJ2YWthdGEtanN0cmVlXFxcIiwge1xcbiAgICAgICAgcHJvdG90eXBlOiBwcm90b1xcbiAgICAgIH0pO1xcbiAgICB9IGNhdGNoIChpZ25vcmUpIHt9XFxuICB9XFxufSk7XCIiLCIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzcmMpIHtcblx0ZnVuY3Rpb24gbG9nKGVycm9yKSB7XG5cdFx0KHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiKVxuXHRcdCYmIChjb25zb2xlLmVycm9yIHx8IGNvbnNvbGUubG9nKShcIltTY3JpcHQgTG9hZGVyXVwiLCBlcnJvcik7XG5cdH1cblxuXHQvLyBDaGVjayBmb3IgSUUgPTwgOFxuXHRmdW5jdGlvbiBpc0lFKCkge1xuXHRcdHJldHVybiB0eXBlb2YgYXR0YWNoRXZlbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGFkZEV2ZW50TGlzdGVuZXIgPT09IFwidW5kZWZpbmVkXCI7XG5cdH1cblxuXHR0cnkge1xuXHRcdGlmICh0eXBlb2YgZXhlY1NjcmlwdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpc0lFKCkpIHtcblx0XHRcdGV4ZWNTY3JpcHQoc3JjKTtcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiBldmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHRldmFsLmNhbGwobnVsbCwgc3JjKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bG9nKFwiRXZhbEVycm9yOiBObyBldmFsIGZ1bmN0aW9uIGF2YWlsYWJsZVwiKTtcblx0XHR9XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0bG9nKGVycm9yKTtcblx0fVxufVxuIiwicmVxdWlyZShcIiEhL2hvbWUvb3Nib3hlcy93b3Jrc3BhY2UvbWxhYi5sb2NhbC50ZXN0L25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qc1wiKShyZXF1aXJlKFwiISEvaG9tZS9vc2JveGVzL3dvcmtzcGFjZS9tbGFiLmxvY2FsLnRlc3Qvbm9kZV9tb2R1bGVzL3Jhdy1sb2FkZXIvaW5kZXguanMhL2hvbWUvb3Nib3hlcy93b3Jrc3BhY2UvbWxhYi5sb2NhbC50ZXN0L25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTQtMCEvaG9tZS9vc2JveGVzL3dvcmtzcGFjZS9tbGFiLmxvY2FsLnRlc3QvYXNzZXRzL2pzL2pzdHJlZS0zLjMuMy5qc1wiKStcIlxcblxcbi8vIFNDUklQVC1MT0FERVIgRk9PVEVSXFxuLy8jIHNvdXJjZVVSTD1zY3JpcHQ6Ly8vaG9tZS9vc2JveGVzL3dvcmtzcGFjZS9tbGFiLmxvY2FsLnRlc3Qvbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMlM0Y/cmVmLS00LTAhL2hvbWUvb3Nib3hlcy93b3Jrc3BhY2UvbWxhYi5sb2NhbC50ZXN0L2Fzc2V0cy9qcy9qc3RyZWUtMy4zLjMuanNcIikiXSwic291cmNlUm9vdCI6IiJ9
>>>>>>> develop
