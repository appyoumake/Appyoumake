/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/build/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./assets/js/mlab.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./assets/js/mlab.js":
/*!***************************!*\
  !*** ./assets/js/mlab.js ***!
  \***************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

// require jQuery normally
var $ = __webpack_require__(/*! script-loader!./jquery-2.1.4.js */ "./node_modules/script-loader/index.js!./assets/js/jquery-2.1.4.js");

// if/when use NPM version, need to create global $ and jQuery variables
// global.$ = global.jQuery = $;

__webpack_require__(/*! script-loader!./jquery.ui-1.11.4.js */ "./node_modules/script-loader/index.js!./assets/js/jquery.ui-1.11.4.js");
__webpack_require__(/*! script-loader!./jquery.form.js */ "./node_modules/script-loader/index.js!./assets/js/jquery.form.js");
__webpack_require__(/*! script-loader!./jquery.uploadfile-4.0.11.js */ "./node_modules/script-loader/index.js!./assets/js/jquery.uploadfile-4.0.11.js");
// require('script-loader!./jquery.qtip-3.0.3.js');
__webpack_require__(/*! script-loader!./jquery.qtip.nightly.js */ "./node_modules/script-loader/index.js!./assets/js/jquery.qtip.nightly.js");
__webpack_require__(/*! script-loader!./bowser.js */ "./node_modules/script-loader/index.js!./assets/js/bowser.js");

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./node_modules/babel-loader/lib/index.js??ref--0-0!./assets/js/bowser.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/raw-loader!./node_modules/babel-loader/lib??ref--0-0!./assets/js/bowser.js ***!
  \*************************************************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports) {

module.exports = "/*!\n  * Bowser - a browser detector\n  * https://github.com/ded/bowser\n  * MIT License | (c) Dustin Diaz 2014\n  */\n\n!function (name, definition) {\n  if (typeof module != 'undefined' && module.exports) module.exports['browser'] = definition();else if (typeof define == 'function' && define.amd) define(definition);else this[name] = definition();\n}('bowser', function () {\n  /**\n    * See useragents.js for examples of navigator.userAgent\n    */\n\n  var t = true;\n\n  function detect(ua) {\n\n    function getFirstMatch(regex) {\n      var match = ua.match(regex);\n      return match && match.length > 1 && match[1] || '';\n    }\n\n    function getSecondMatch(regex) {\n      var match = ua.match(regex);\n      return match && match.length > 1 && match[2] || '';\n    }\n\n    var iosdevice = getFirstMatch(/(ipod|iphone|ipad)/i).toLowerCase(),\n        likeAndroid = /like android/i.test(ua),\n        android = !likeAndroid && /android/i.test(ua),\n        edgeVersion = getFirstMatch(/edge\\/(\\d+(\\.\\d+)?)/i),\n        versionIdentifier = getFirstMatch(/version\\/(\\d+(\\.\\d+)?)/i),\n        tablet = /tablet/i.test(ua),\n        mobile = !tablet && /[^-]mobi/i.test(ua),\n        result;\n\n    if (/opera|opr/i.test(ua)) {\n      result = {\n        name: 'Opera',\n        opera: t,\n        version: versionIdentifier || getFirstMatch(/(?:opera|opr)[\\s\\/](\\d+(\\.\\d+)?)/i)\n      };\n    } else if (/windows phone/i.test(ua)) {\n      result = {\n        name: 'Windows Phone',\n        windowsphone: t\n      };\n      if (edgeVersion) {\n        result.msedge = t;\n        result.version = edgeVersion;\n      } else {\n        result.msie = t;\n        result.version = getFirstMatch(/iemobile\\/(\\d+(\\.\\d+)?)/i);\n      }\n    } else if (/msie|trident/i.test(ua)) {\n      result = {\n        name: 'Internet Explorer',\n        msie: t,\n        version: getFirstMatch(/(?:msie |rv:)(\\d+(\\.\\d+)?)/i)\n      };\n    } else if (/chrome.+? edge/i.test(ua)) {\n      result = {\n        name: 'Microsoft Edge',\n        msedge: t,\n        version: edgeVersion\n      };\n    } else if (/chrome|crios|crmo/i.test(ua)) {\n      result = {\n        name: 'Chrome',\n        chrome: t,\n        version: getFirstMatch(/(?:chrome|crios|crmo)\\/(\\d+(\\.\\d+)?)/i)\n      };\n    } else if (iosdevice) {\n      result = {\n        name: iosdevice == 'iphone' ? 'iPhone' : iosdevice == 'ipad' ? 'iPad' : 'iPod'\n        // WTF: version is not part of user agent in web apps\n      };if (versionIdentifier) {\n        result.version = versionIdentifier;\n      }\n    } else if (/sailfish/i.test(ua)) {\n      result = {\n        name: 'Sailfish',\n        sailfish: t,\n        version: getFirstMatch(/sailfish\\s?browser\\/(\\d+(\\.\\d+)?)/i)\n      };\n    } else if (/seamonkey\\//i.test(ua)) {\n      result = {\n        name: 'SeaMonkey',\n        seamonkey: t,\n        version: getFirstMatch(/seamonkey\\/(\\d+(\\.\\d+)?)/i)\n      };\n    } else if (/firefox|iceweasel/i.test(ua)) {\n      result = {\n        name: 'Firefox',\n        firefox: t,\n        version: getFirstMatch(/(?:firefox|iceweasel)[ \\/](\\d+(\\.\\d+)?)/i)\n      };\n      if (/\\((mobile|tablet);[^\\)]*rv:[\\d\\.]+\\)/i.test(ua)) {\n        result.firefoxos = t;\n      }\n    } else if (/silk/i.test(ua)) {\n      result = {\n        name: 'Amazon Silk',\n        silk: t,\n        version: getFirstMatch(/silk\\/(\\d+(\\.\\d+)?)/i)\n      };\n    } else if (android) {\n      result = {\n        name: 'Android',\n        version: versionIdentifier\n      };\n    } else if (/phantom/i.test(ua)) {\n      result = {\n        name: 'PhantomJS',\n        phantom: t,\n        version: getFirstMatch(/phantomjs\\/(\\d+(\\.\\d+)?)/i)\n      };\n    } else if (/blackberry|\\bbb\\d+/i.test(ua) || /rim\\stablet/i.test(ua)) {\n      result = {\n        name: 'BlackBerry',\n        blackberry: t,\n        version: versionIdentifier || getFirstMatch(/blackberry[\\d]+\\/(\\d+(\\.\\d+)?)/i)\n      };\n    } else if (/(web|hpw)os/i.test(ua)) {\n      result = {\n        name: 'WebOS',\n        webos: t,\n        version: versionIdentifier || getFirstMatch(/w(?:eb)?osbrowser\\/(\\d+(\\.\\d+)?)/i)\n      };\n      /touchpad\\//i.test(ua) && (result.touchpad = t);\n    } else if (/bada/i.test(ua)) {\n      result = {\n        name: 'Bada',\n        bada: t,\n        version: getFirstMatch(/dolfin\\/(\\d+(\\.\\d+)?)/i)\n      };\n    } else if (/tizen/i.test(ua)) {\n      result = {\n        name: 'Tizen',\n        tizen: t,\n        version: getFirstMatch(/(?:tizen\\s?)?browser\\/(\\d+(\\.\\d+)?)/i) || versionIdentifier\n      };\n    } else if (/safari/i.test(ua)) {\n      result = {\n        name: 'Safari',\n        safari: t,\n        version: versionIdentifier\n      };\n    } else {\n      result = {\n        name: getFirstMatch(/^(.*)\\/(.*) /),\n        version: getSecondMatch(/^(.*)\\/(.*) /)\n      };\n    }\n\n    // set webkit or gecko flag for browsers based on these engines\n    if (!result.msedge && /(apple)?webkit/i.test(ua)) {\n      result.name = result.name || \"Webkit\";\n      result.webkit = t;\n      if (!result.version && versionIdentifier) {\n        result.version = versionIdentifier;\n      }\n    } else if (!result.opera && /gecko\\//i.test(ua)) {\n      result.name = result.name || \"Gecko\";\n      result.gecko = t;\n      result.version = result.version || getFirstMatch(/gecko\\/(\\d+(\\.\\d+)?)/i);\n    }\n\n    // set OS flags for platforms that have multiple browsers\n    if (!result.msedge && (android || result.silk)) {\n      result.android = t;\n    } else if (iosdevice) {\n      result[iosdevice] = t;\n      result.ios = t;\n    }\n\n    // OS version extraction\n    var osVersion = '';\n    if (result.windowsphone) {\n      osVersion = getFirstMatch(/windows phone (?:os)?\\s?(\\d+(\\.\\d+)*)/i);\n    } else if (iosdevice) {\n      osVersion = getFirstMatch(/os (\\d+([_\\s]\\d+)*) like mac os x/i);\n      osVersion = osVersion.replace(/[_\\s]/g, '.');\n    } else if (android) {\n      osVersion = getFirstMatch(/android[ \\/-](\\d+(\\.\\d+)*)/i);\n    } else if (result.webos) {\n      osVersion = getFirstMatch(/(?:web|hpw)os\\/(\\d+(\\.\\d+)*)/i);\n    } else if (result.blackberry) {\n      osVersion = getFirstMatch(/rim\\stablet\\sos\\s(\\d+(\\.\\d+)*)/i);\n    } else if (result.bada) {\n      osVersion = getFirstMatch(/bada\\/(\\d+(\\.\\d+)*)/i);\n    } else if (result.tizen) {\n      osVersion = getFirstMatch(/tizen[\\/\\s](\\d+(\\.\\d+)*)/i);\n    }\n    if (osVersion) {\n      result.osversion = osVersion;\n    }\n\n    // device type extraction\n    var osMajorVersion = osVersion.split('.')[0];\n    if (tablet || iosdevice == 'ipad' || android && (osMajorVersion == 3 || osMajorVersion == 4 && !mobile) || result.silk) {\n      result.tablet = t;\n    } else if (mobile || iosdevice == 'iphone' || iosdevice == 'ipod' || android || result.blackberry || result.webos || result.bada) {\n      result.mobile = t;\n    }\n\n    // Graded Browser Support\n    // http://developer.yahoo.com/yui/articles/gbs\n    if (result.msedge || result.msie && result.version >= 10 || result.chrome && result.version >= 20 || result.firefox && result.version >= 20.0 || result.safari && result.version >= 6 || result.opera && result.version >= 10.0 || result.ios && result.osversion && result.osversion.split(\".\")[0] >= 6 || result.blackberry && result.version >= 10.1) {\n      result.a = t;\n    } else if (result.msie && result.version < 10 || result.chrome && result.version < 20 || result.firefox && result.version < 20.0 || result.safari && result.version < 6 || result.opera && result.version < 10.0 || result.ios && result.osversion && result.osversion.split(\".\")[0] < 6) {\n      result.c = t;\n    } else result.x = t;\n\n    return result;\n  }\n\n  var bowser = detect(typeof navigator !== 'undefined' ? navigator.userAgent : '');\n\n  bowser.test = function (browserList) {\n    for (var i = 0; i < browserList.length; ++i) {\n      var browserItem = browserList[i];\n      if (typeof browserItem === 'string') {\n        if (browserItem in bowser) {\n          return true;\n        }\n      }\n    }\n    return false;\n  };\n\n  /*\n   * Set our detect method to the main bowser object so we can\n   * reuse it to test other user agents.\n   * This is needed to implement future tests.\n   */\n  bowser._detect = detect;\n\n  return bowser;\n});"

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./node_modules/babel-loader/lib/index.js??ref--0-0!./assets/js/jquery-2.1.4.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/raw-loader!./node_modules/babel-loader/lib??ref--0-0!./assets/js/jquery-2.1.4.js ***!
  \*******************************************************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports) {

module.exports = "var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/*!\n * jQuery JavaScript Library v2.1.4\n * http://jquery.com/\n *\n * Includes Sizzle.js\n * http://sizzlejs.com/\n *\n * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2015-04-28T16:01Z\n */\n\n(function (global, factory) {\n\n\tif ((typeof module === \"undefined\" ? \"undefined\" : _typeof(module)) === \"object\" && _typeof(module.exports) === \"object\") {\n\t\t// For CommonJS and CommonJS-like environments where a proper `window`\n\t\t// is present, execute the factory and get jQuery.\n\t\t// For environments that do not have a `window` with a `document`\n\t\t// (such as Node.js), expose a factory as module.exports.\n\t\t// This accentuates the need for the creation of a real `window`.\n\t\t// e.g. var jQuery = require(\"jquery\")(window);\n\t\t// See ticket #14549 for more info.\n\t\tmodule.exports = global.document ? factory(global, true) : function (w) {\n\t\t\tif (!w.document) {\n\t\t\t\tthrow new Error(\"jQuery requires a window with a document\");\n\t\t\t}\n\t\t\treturn factory(w);\n\t\t};\n\t} else {\n\t\tfactory(global);\n\t}\n\n\t// Pass this if window is not defined yet\n})(typeof window !== \"undefined\" ? window : this, function (window, noGlobal) {\n\n\t// Support: Firefox 18+\n\t// Can't be in strict mode, several libs including ASP.NET trace\n\t// the stack via arguments.caller.callee and Firefox dies if\n\t// you try to trace through \"use strict\" call chains. (#13335)\n\t//\n\n\tvar arr = [];\n\n\tvar _slice = arr.slice;\n\n\tvar concat = arr.concat;\n\n\tvar push = arr.push;\n\n\tvar indexOf = arr.indexOf;\n\n\tvar class2type = {};\n\n\tvar toString = class2type.toString;\n\n\tvar hasOwn = class2type.hasOwnProperty;\n\n\tvar support = {};\n\n\tvar\n\t// Use the correct document accordingly with window argument (sandbox)\n\tdocument = window.document,\n\t    version = \"2.1.4\",\n\n\n\t// Define a local copy of jQuery\n\tjQuery = function jQuery(selector, context) {\n\t\t// The jQuery object is actually just the init constructor 'enhanced'\n\t\t// Need init if jQuery is called (just allow error to be thrown if not included)\n\t\treturn new jQuery.fn.init(selector, context);\n\t},\n\n\n\t// Support: Android<4.1\n\t// Make sure we trim BOM and NBSP\n\trtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,\n\n\n\t// Matches dashed string for camelizing\n\trmsPrefix = /^-ms-/,\n\t    rdashAlpha = /-([\\da-z])/gi,\n\n\n\t// Used by jQuery.camelCase as callback to replace()\n\tfcamelCase = function fcamelCase(all, letter) {\n\t\treturn letter.toUpperCase();\n\t};\n\n\tjQuery.fn = jQuery.prototype = {\n\t\t// The current version of jQuery being used\n\t\tjquery: version,\n\n\t\tconstructor: jQuery,\n\n\t\t// Start with an empty selector\n\t\tselector: \"\",\n\n\t\t// The default length of a jQuery object is 0\n\t\tlength: 0,\n\n\t\ttoArray: function toArray() {\n\t\t\treturn _slice.call(this);\n\t\t},\n\n\t\t// Get the Nth element in the matched element set OR\n\t\t// Get the whole matched element set as a clean array\n\t\tget: function get(num) {\n\t\t\treturn num != null ?\n\n\t\t\t// Return just the one element from the set\n\t\t\tnum < 0 ? this[num + this.length] : this[num] :\n\n\t\t\t// Return all the elements in a clean array\n\t\t\t_slice.call(this);\n\t\t},\n\n\t\t// Take an array of elements and push it onto the stack\n\t\t// (returning the new matched element set)\n\t\tpushStack: function pushStack(elems) {\n\n\t\t\t// Build a new jQuery matched element set\n\t\t\tvar ret = jQuery.merge(this.constructor(), elems);\n\n\t\t\t// Add the old object onto the stack (as a reference)\n\t\t\tret.prevObject = this;\n\t\t\tret.context = this.context;\n\n\t\t\t// Return the newly-formed element set\n\t\t\treturn ret;\n\t\t},\n\n\t\t// Execute a callback for every element in the matched set.\n\t\t// (You can seed the arguments with an array of args, but this is\n\t\t// only used internally.)\n\t\teach: function each(callback, args) {\n\t\t\treturn jQuery.each(this, callback, args);\n\t\t},\n\n\t\tmap: function map(callback) {\n\t\t\treturn this.pushStack(jQuery.map(this, function (elem, i) {\n\t\t\t\treturn callback.call(elem, i, elem);\n\t\t\t}));\n\t\t},\n\n\t\tslice: function slice() {\n\t\t\treturn this.pushStack(_slice.apply(this, arguments));\n\t\t},\n\n\t\tfirst: function first() {\n\t\t\treturn this.eq(0);\n\t\t},\n\n\t\tlast: function last() {\n\t\t\treturn this.eq(-1);\n\t\t},\n\n\t\teq: function eq(i) {\n\t\t\tvar len = this.length,\n\t\t\t    j = +i + (i < 0 ? len : 0);\n\t\t\treturn this.pushStack(j >= 0 && j < len ? [this[j]] : []);\n\t\t},\n\n\t\tend: function end() {\n\t\t\treturn this.prevObject || this.constructor(null);\n\t\t},\n\n\t\t// For internal use only.\n\t\t// Behaves like an Array's method, not like a jQuery method.\n\t\tpush: push,\n\t\tsort: arr.sort,\n\t\tsplice: arr.splice\n\t};\n\n\tjQuery.extend = jQuery.fn.extend = function () {\n\t\tvar options,\n\t\t    name,\n\t\t    src,\n\t\t    copy,\n\t\t    copyIsArray,\n\t\t    clone,\n\t\t    target = arguments[0] || {},\n\t\t    i = 1,\n\t\t    length = arguments.length,\n\t\t    deep = false;\n\n\t\t// Handle a deep copy situation\n\t\tif (typeof target === \"boolean\") {\n\t\t\tdeep = target;\n\n\t\t\t// Skip the boolean and the target\n\t\t\ttarget = arguments[i] || {};\n\t\t\ti++;\n\t\t}\n\n\t\t// Handle case when target is a string or something (possible in deep copy)\n\t\tif ((typeof target === \"undefined\" ? \"undefined\" : _typeof(target)) !== \"object\" && !jQuery.isFunction(target)) {\n\t\t\ttarget = {};\n\t\t}\n\n\t\t// Extend jQuery itself if only one argument is passed\n\t\tif (i === length) {\n\t\t\ttarget = this;\n\t\t\ti--;\n\t\t}\n\n\t\tfor (; i < length; i++) {\n\t\t\t// Only deal with non-null/undefined values\n\t\t\tif ((options = arguments[i]) != null) {\n\t\t\t\t// Extend the base object\n\t\t\t\tfor (name in options) {\n\t\t\t\t\tsrc = target[name];\n\t\t\t\t\tcopy = options[name];\n\n\t\t\t\t\t// Prevent never-ending loop\n\t\t\t\t\tif (target === copy) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\t\tif (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {\n\t\t\t\t\t\tif (copyIsArray) {\n\t\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\t\tclone = src && jQuery.isArray(src) ? src : [];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tclone = src && jQuery.isPlainObject(src) ? src : {};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\ttarget[name] = jQuery.extend(deep, clone, copy);\n\n\t\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t\t} else if (copy !== undefined) {\n\t\t\t\t\t\ttarget[name] = copy;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Return the modified object\n\t\treturn target;\n\t};\n\n\tjQuery.extend({\n\t\t// Unique for each copy of jQuery on the page\n\t\texpando: \"jQuery\" + (version + Math.random()).replace(/\\D/g, \"\"),\n\n\t\t// Assume jQuery is ready without the ready module\n\t\tisReady: true,\n\n\t\terror: function error(msg) {\n\t\t\tthrow new Error(msg);\n\t\t},\n\n\t\tnoop: function noop() {},\n\n\t\tisFunction: function isFunction(obj) {\n\t\t\treturn jQuery.type(obj) === \"function\";\n\t\t},\n\n\t\tisArray: Array.isArray,\n\n\t\tisWindow: function isWindow(obj) {\n\t\t\treturn obj != null && obj === obj.window;\n\t\t},\n\n\t\tisNumeric: function isNumeric(obj) {\n\t\t\t// parseFloat NaNs numeric-cast false positives (null|true|false|\"\")\n\t\t\t// ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n\t\t\t// subtraction forces infinities to NaN\n\t\t\t// adding 1 corrects loss of precision from parseFloat (#15100)\n\t\t\treturn !jQuery.isArray(obj) && obj - parseFloat(obj) + 1 >= 0;\n\t\t},\n\n\t\tisPlainObject: function isPlainObject(obj) {\n\t\t\t// Not plain objects:\n\t\t\t// - Any object or value whose internal [[Class]] property is not \"[object Object]\"\n\t\t\t// - DOM nodes\n\t\t\t// - window\n\t\t\tif (jQuery.type(obj) !== \"object\" || obj.nodeType || jQuery.isWindow(obj)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (obj.constructor && !hasOwn.call(obj.constructor.prototype, \"isPrototypeOf\")) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// If the function hasn't returned already, we're confident that\n\t\t\t// |obj| is a plain object, created by {} or constructed with new Object\n\t\t\treturn true;\n\t\t},\n\n\t\tisEmptyObject: function isEmptyObject(obj) {\n\t\t\tvar name;\n\t\t\tfor (name in obj) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\ttype: function type(obj) {\n\t\t\tif (obj == null) {\n\t\t\t\treturn obj + \"\";\n\t\t\t}\n\t\t\t// Support: Android<4.0, iOS<6 (functionish RegExp)\n\t\t\treturn (typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj)) === \"object\" || typeof obj === \"function\" ? class2type[toString.call(obj)] || \"object\" : typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj);\n\t\t},\n\n\t\t// Evaluates a script in a global context\n\t\tglobalEval: function globalEval(code) {\n\t\t\tvar script,\n\t\t\t    indirect = eval;\n\n\t\t\tcode = jQuery.trim(code);\n\n\t\t\tif (code) {\n\t\t\t\t// If the code includes a valid, prologue position\n\t\t\t\t// strict mode pragma, execute code by injecting a\n\t\t\t\t// script tag into the document.\n\t\t\t\tif (code.indexOf(\"use strict\") === 1) {\n\t\t\t\t\tscript = document.createElement(\"script\");\n\t\t\t\t\tscript.text = code;\n\t\t\t\t\tdocument.head.appendChild(script).parentNode.removeChild(script);\n\t\t\t\t} else {\n\t\t\t\t\t// Otherwise, avoid the DOM node creation, insertion\n\t\t\t\t\t// and removal by using an indirect global eval\n\t\t\t\t\tindirect(code);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// Convert dashed to camelCase; used by the css and data modules\n\t\t// Support: IE9-11+\n\t\t// Microsoft forgot to hump their vendor prefix (#9572)\n\t\tcamelCase: function camelCase(string) {\n\t\t\treturn string.replace(rmsPrefix, \"ms-\").replace(rdashAlpha, fcamelCase);\n\t\t},\n\n\t\tnodeName: function nodeName(elem, name) {\n\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n\t\t},\n\n\t\t// args is for internal usage only\n\t\teach: function each(obj, callback, args) {\n\t\t\tvar value,\n\t\t\t    i = 0,\n\t\t\t    length = obj.length,\n\t\t\t    isArray = isArraylike(obj);\n\n\t\t\tif (args) {\n\t\t\t\tif (isArray) {\n\t\t\t\t\tfor (; i < length; i++) {\n\t\t\t\t\t\tvalue = callback.apply(obj[i], args);\n\n\t\t\t\t\t\tif (value === false) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (i in obj) {\n\t\t\t\t\t\tvalue = callback.apply(obj[i], args);\n\n\t\t\t\t\t\tif (value === false) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// A special, fast, case for the most common use of each\n\t\t\t} else {\n\t\t\t\tif (isArray) {\n\t\t\t\t\tfor (; i < length; i++) {\n\t\t\t\t\t\tvalue = callback.call(obj[i], i, obj[i]);\n\n\t\t\t\t\t\tif (value === false) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (i in obj) {\n\t\t\t\t\t\tvalue = callback.call(obj[i], i, obj[i]);\n\n\t\t\t\t\t\tif (value === false) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn obj;\n\t\t},\n\n\t\t// Support: Android<4.1\n\t\ttrim: function trim(text) {\n\t\t\treturn text == null ? \"\" : (text + \"\").replace(rtrim, \"\");\n\t\t},\n\n\t\t// results is for internal usage only\n\t\tmakeArray: function makeArray(arr, results) {\n\t\t\tvar ret = results || [];\n\n\t\t\tif (arr != null) {\n\t\t\t\tif (isArraylike(Object(arr))) {\n\t\t\t\t\tjQuery.merge(ret, typeof arr === \"string\" ? [arr] : arr);\n\t\t\t\t} else {\n\t\t\t\t\tpush.call(ret, arr);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn ret;\n\t\t},\n\n\t\tinArray: function inArray(elem, arr, i) {\n\t\t\treturn arr == null ? -1 : indexOf.call(arr, elem, i);\n\t\t},\n\n\t\tmerge: function merge(first, second) {\n\t\t\tvar len = +second.length,\n\t\t\t    j = 0,\n\t\t\t    i = first.length;\n\n\t\t\tfor (; j < len; j++) {\n\t\t\t\tfirst[i++] = second[j];\n\t\t\t}\n\n\t\t\tfirst.length = i;\n\n\t\t\treturn first;\n\t\t},\n\n\t\tgrep: function grep(elems, callback, invert) {\n\t\t\tvar callbackInverse,\n\t\t\t    matches = [],\n\t\t\t    i = 0,\n\t\t\t    length = elems.length,\n\t\t\t    callbackExpect = !invert;\n\n\t\t\t// Go through the array, only saving the items\n\t\t\t// that pass the validator function\n\t\t\tfor (; i < length; i++) {\n\t\t\t\tcallbackInverse = !callback(elems[i], i);\n\t\t\t\tif (callbackInverse !== callbackExpect) {\n\t\t\t\t\tmatches.push(elems[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn matches;\n\t\t},\n\n\t\t// arg is for internal usage only\n\t\tmap: function map(elems, callback, arg) {\n\t\t\tvar value,\n\t\t\t    i = 0,\n\t\t\t    length = elems.length,\n\t\t\t    isArray = isArraylike(elems),\n\t\t\t    ret = [];\n\n\t\t\t// Go through the array, translating each of the items to their new values\n\t\t\tif (isArray) {\n\t\t\t\tfor (; i < length; i++) {\n\t\t\t\t\tvalue = callback(elems[i], i, arg);\n\n\t\t\t\t\tif (value != null) {\n\t\t\t\t\t\tret.push(value);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Go through every key on the object,\n\t\t\t} else {\n\t\t\t\tfor (i in elems) {\n\t\t\t\t\tvalue = callback(elems[i], i, arg);\n\n\t\t\t\t\tif (value != null) {\n\t\t\t\t\t\tret.push(value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Flatten any nested arrays\n\t\t\treturn concat.apply([], ret);\n\t\t},\n\n\t\t// A global GUID counter for objects\n\t\tguid: 1,\n\n\t\t// Bind a function to a context, optionally partially applying any\n\t\t// arguments.\n\t\tproxy: function proxy(fn, context) {\n\t\t\tvar tmp, args, proxy;\n\n\t\t\tif (typeof context === \"string\") {\n\t\t\t\ttmp = fn[context];\n\t\t\t\tcontext = fn;\n\t\t\t\tfn = tmp;\n\t\t\t}\n\n\t\t\t// Quick check to determine if target is callable, in the spec\n\t\t\t// this throws a TypeError, but we will just return undefined.\n\t\t\tif (!jQuery.isFunction(fn)) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\t// Simulated bind\n\t\t\targs = _slice.call(arguments, 2);\n\t\t\tproxy = function proxy() {\n\t\t\t\treturn fn.apply(context || this, args.concat(_slice.call(arguments)));\n\t\t\t};\n\n\t\t\t// Set the guid of unique handler to the same of original handler, so it can be removed\n\t\t\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\n\n\t\t\treturn proxy;\n\t\t},\n\n\t\tnow: Date.now,\n\n\t\t// jQuery.support is not used in Core but other projects attach their\n\t\t// properties to it so it needs to exist.\n\t\tsupport: support\n\t});\n\n\t// Populate the class2type map\n\tjQuery.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"), function (i, name) {\n\t\tclass2type[\"[object \" + name + \"]\"] = name.toLowerCase();\n\t});\n\n\tfunction isArraylike(obj) {\n\n\t\t// Support: iOS 8.2 (not reproducible in simulator)\n\t\t// `in` check used to prevent JIT error (gh-2145)\n\t\t// hasOwn isn't used here due to false negatives\n\t\t// regarding Nodelist length in IE\n\t\tvar length = \"length\" in obj && obj.length,\n\t\t    type = jQuery.type(obj);\n\n\t\tif (type === \"function\" || jQuery.isWindow(obj)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (obj.nodeType === 1 && length) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn type === \"array\" || length === 0 || typeof length === \"number\" && length > 0 && length - 1 in obj;\n\t}\n\tvar Sizzle =\n\t/*!\n  * Sizzle CSS Selector Engine v2.2.0-pre\n  * http://sizzlejs.com/\n  *\n  * Copyright 2008, 2014 jQuery Foundation, Inc. and other contributors\n  * Released under the MIT license\n  * http://jquery.org/license\n  *\n  * Date: 2014-12-16\n  */\n\tfunction (window) {\n\n\t\tvar i,\n\t\t    support,\n\t\t    Expr,\n\t\t    getText,\n\t\t    isXML,\n\t\t    tokenize,\n\t\t    compile,\n\t\t    select,\n\t\t    outermostContext,\n\t\t    sortInput,\n\t\t    hasDuplicate,\n\n\n\t\t// Local document vars\n\t\tsetDocument,\n\t\t    document,\n\t\t    docElem,\n\t\t    documentIsHTML,\n\t\t    rbuggyQSA,\n\t\t    rbuggyMatches,\n\t\t    matches,\n\t\t    contains,\n\n\n\t\t// Instance-specific data\n\t\texpando = \"sizzle\" + 1 * new Date(),\n\t\t    preferredDoc = window.document,\n\t\t    dirruns = 0,\n\t\t    done = 0,\n\t\t    classCache = createCache(),\n\t\t    tokenCache = createCache(),\n\t\t    compilerCache = createCache(),\n\t\t    sortOrder = function sortOrder(a, b) {\n\t\t\tif (a === b) {\n\t\t\t\thasDuplicate = true;\n\t\t\t}\n\t\t\treturn 0;\n\t\t},\n\n\n\t\t// General-purpose constants\n\t\tMAX_NEGATIVE = 1 << 31,\n\n\n\t\t// Instance methods\n\t\thasOwn = {}.hasOwnProperty,\n\t\t    arr = [],\n\t\t    pop = arr.pop,\n\t\t    push_native = arr.push,\n\t\t    push = arr.push,\n\t\t    slice = arr.slice,\n\n\t\t// Use a stripped-down indexOf as it's faster than native\n\t\t// http://jsperf.com/thor-indexof-vs-for/5\n\t\tindexOf = function indexOf(list, elem) {\n\t\t\tvar i = 0,\n\t\t\t    len = list.length;\n\t\t\tfor (; i < len; i++) {\n\t\t\t\tif (list[i] === elem) {\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1;\n\t\t},\n\t\t    booleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n\n\n\t\t// Regular expressions\n\n\t\t// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace\n\t\twhitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n\n\t\t// http://www.w3.org/TR/css3-syntax/#characters\n\t\tcharacterEncoding = \"(?:\\\\\\\\.|[\\\\w-]|[^\\\\x00-\\\\xa0])+\",\n\n\n\t\t// Loosely modeled on CSS identifier characters\n\t\t// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors\n\t\t// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n\t\tidentifier = characterEncoding.replace(\"w\", \"w#\"),\n\n\n\t\t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n\t\tattributes = \"\\\\[\" + whitespace + \"*(\" + characterEncoding + \")(?:\" + whitespace +\n\t\t// Operator (capture 2)\n\t\t\"*([*^$|!~]?=)\" + whitespace +\n\t\t// \"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\"\n\t\t\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" + whitespace + \"*\\\\]\",\n\t\t    pseudos = \":(\" + characterEncoding + \")(?:\\\\((\" +\n\t\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n\t\t// 1. quoted (capture 3; capture 4 or capture 5)\n\t\t\"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" +\n\t\t// 2. simple (capture 6)\n\t\t\"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" +\n\t\t// 3. anything else (capture 2)\n\t\t\".*\" + \")\\\\)|)\",\n\n\n\t\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n\t\trwhitespace = new RegExp(whitespace + \"+\", \"g\"),\n\t\t    rtrim = new RegExp(\"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\"),\n\t\t    rcomma = new RegExp(\"^\" + whitespace + \"*,\" + whitespace + \"*\"),\n\t\t    rcombinators = new RegExp(\"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\"),\n\t\t    rattributeQuotes = new RegExp(\"=\" + whitespace + \"*([^\\\\]'\\\"]*?)\" + whitespace + \"*\\\\]\", \"g\"),\n\t\t    rpseudo = new RegExp(pseudos),\n\t\t    ridentifier = new RegExp(\"^\" + identifier + \"$\"),\n\t\t    matchExpr = {\n\t\t\t\"ID\": new RegExp(\"^#(\" + characterEncoding + \")\"),\n\t\t\t\"CLASS\": new RegExp(\"^\\\\.(\" + characterEncoding + \")\"),\n\t\t\t\"TAG\": new RegExp(\"^(\" + characterEncoding.replace(\"w\", \"w*\") + \")\"),\n\t\t\t\"ATTR\": new RegExp(\"^\" + attributes),\n\t\t\t\"PSEUDO\": new RegExp(\"^\" + pseudos),\n\t\t\t\"CHILD\": new RegExp(\"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace + \"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace + \"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\"),\n\t\t\t\"bool\": new RegExp(\"^(?:\" + booleans + \")$\", \"i\"),\n\t\t\t// For use in libraries implementing .is()\n\t\t\t// We use this for POS matching in `select`\n\t\t\t\"needsContext\": new RegExp(\"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" + whitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\")\n\t\t},\n\t\t    rinputs = /^(?:input|select|textarea|button)$/i,\n\t\t    rheader = /^h\\d$/i,\n\t\t    rnative = /^[^{]+\\{\\s*\\[native \\w/,\n\n\n\t\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n\t\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\t\t    rsibling = /[+~]/,\n\t\t    rescape = /'|\\\\/g,\n\n\n\t\t// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\t\trunescape = new RegExp(\"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\"),\n\t\t    funescape = function funescape(_, escaped, escapedWhitespace) {\n\t\t\tvar high = \"0x\" + escaped - 0x10000;\n\t\t\t// NaN means non-codepoint\n\t\t\t// Support: Firefox<24\n\t\t\t// Workaround erroneous numeric interpretation of +\"0x\"\n\t\t\treturn high !== high || escapedWhitespace ? escaped : high < 0 ?\n\t\t\t// BMP codepoint\n\t\t\tString.fromCharCode(high + 0x10000) :\n\t\t\t// Supplemental Plane codepoint (surrogate pair)\n\t\t\tString.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);\n\t\t},\n\n\n\t\t// Used for iframes\n\t\t// See setDocument()\n\t\t// Removing the function wrapper causes a \"Permission Denied\"\n\t\t// error in IE\n\t\tunloadHandler = function unloadHandler() {\n\t\t\tsetDocument();\n\t\t};\n\n\t\t// Optimize for push.apply( _, NodeList )\n\t\ttry {\n\t\t\tpush.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);\n\t\t\t// Support: Android<4.0\n\t\t\t// Detect silently failing push.apply\n\t\t\tarr[preferredDoc.childNodes.length].nodeType;\n\t\t} catch (e) {\n\t\t\tpush = { apply: arr.length ?\n\n\t\t\t\t// Leverage slice if possible\n\t\t\t\tfunction (target, els) {\n\t\t\t\t\tpush_native.apply(target, slice.call(els));\n\t\t\t\t} :\n\n\t\t\t\t// Support: IE<9\n\t\t\t\t// Otherwise append directly\n\t\t\t\tfunction (target, els) {\n\t\t\t\t\tvar j = target.length,\n\t\t\t\t\t    i = 0;\n\t\t\t\t\t// Can't trust NodeList.length\n\t\t\t\t\twhile (target[j++] = els[i++]) {}\n\t\t\t\t\ttarget.length = j - 1;\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tfunction Sizzle(selector, context, results, seed) {\n\t\t\tvar match, elem, m, nodeType,\n\t\t\t// QSA vars\n\t\t\ti, groups, old, nid, newContext, newSelector;\n\n\t\t\tif ((context ? context.ownerDocument || context : preferredDoc) !== document) {\n\t\t\t\tsetDocument(context);\n\t\t\t}\n\n\t\t\tcontext = context || document;\n\t\t\tresults = results || [];\n\t\t\tnodeType = context.nodeType;\n\n\t\t\tif (typeof selector !== \"string\" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {\n\n\t\t\t\treturn results;\n\t\t\t}\n\n\t\t\tif (!seed && documentIsHTML) {\n\n\t\t\t\t// Try to shortcut find operations when possible (e.g., not under DocumentFragment)\n\t\t\t\tif (nodeType !== 11 && (match = rquickExpr.exec(selector))) {\n\t\t\t\t\t// Speed-up: Sizzle(\"#ID\")\n\t\t\t\t\tif (m = match[1]) {\n\t\t\t\t\t\tif (nodeType === 9) {\n\t\t\t\t\t\t\telem = context.getElementById(m);\n\t\t\t\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\n\t\t\t\t\t\t\t// nodes that are no longer in the document (jQuery #6963)\n\t\t\t\t\t\t\tif (elem && elem.parentNode) {\n\t\t\t\t\t\t\t\t// Handle the case where IE, Opera, and Webkit return items\n\t\t\t\t\t\t\t\t// by name instead of ID\n\t\t\t\t\t\t\t\tif (elem.id === m) {\n\t\t\t\t\t\t\t\t\tresults.push(elem);\n\t\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Context is not a document\n\t\t\t\t\t\t\tif (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) && contains(context, elem) && elem.id === m) {\n\t\t\t\t\t\t\t\tresults.push(elem);\n\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Speed-up: Sizzle(\"TAG\")\n\t\t\t\t\t} else if (match[2]) {\n\t\t\t\t\t\tpush.apply(results, context.getElementsByTagName(selector));\n\t\t\t\t\t\treturn results;\n\n\t\t\t\t\t\t// Speed-up: Sizzle(\".CLASS\")\n\t\t\t\t\t} else if ((m = match[3]) && support.getElementsByClassName) {\n\t\t\t\t\t\tpush.apply(results, context.getElementsByClassName(m));\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// QSA path\n\t\t\t\tif (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {\n\t\t\t\t\tnid = old = expando;\n\t\t\t\t\tnewContext = context;\n\t\t\t\t\tnewSelector = nodeType !== 1 && selector;\n\n\t\t\t\t\t// qSA works strangely on Element-rooted queries\n\t\t\t\t\t// We can work around this by specifying an extra ID on the root\n\t\t\t\t\t// and working up from there (Thanks to Andrew Dupont for the technique)\n\t\t\t\t\t// IE 8 doesn't work on object elements\n\t\t\t\t\tif (nodeType === 1 && context.nodeName.toLowerCase() !== \"object\") {\n\t\t\t\t\t\tgroups = tokenize(selector);\n\n\t\t\t\t\t\tif (old = context.getAttribute(\"id\")) {\n\t\t\t\t\t\t\tnid = old.replace(rescape, \"\\\\$&\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontext.setAttribute(\"id\", nid);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnid = \"[id='\" + nid + \"'] \";\n\n\t\t\t\t\t\ti = groups.length;\n\t\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\t\tgroups[i] = nid + toSelector(groups[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnewContext = rsibling.test(selector) && testContext(context.parentNode) || context;\n\t\t\t\t\t\tnewSelector = groups.join(\",\");\n\t\t\t\t\t}\n\n\t\t\t\t\tif (newSelector) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tpush.apply(results, newContext.querySelectorAll(newSelector));\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t} catch (qsaError) {} finally {\n\t\t\t\t\t\t\tif (!old) {\n\t\t\t\t\t\t\t\tcontext.removeAttribute(\"id\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// All others\n\t\t\treturn select(selector.replace(rtrim, \"$1\"), context, results, seed);\n\t\t}\n\n\t\t/**\n   * Create key-value caches of limited size\n   * @returns {Function(string, Object)} Returns the Object data after storing it on itself with\n   *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n   *\tdeleting the oldest entry\n   */\n\t\tfunction createCache() {\n\t\t\tvar keys = [];\n\n\t\t\tfunction cache(key, value) {\n\t\t\t\t// Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n\t\t\t\tif (keys.push(key + \" \") > Expr.cacheLength) {\n\t\t\t\t\t// Only keep the most recent entries\n\t\t\t\t\tdelete cache[keys.shift()];\n\t\t\t\t}\n\t\t\t\treturn cache[key + \" \"] = value;\n\t\t\t}\n\t\t\treturn cache;\n\t\t}\n\n\t\t/**\n   * Mark a function for special use by Sizzle\n   * @param {Function} fn The function to mark\n   */\n\t\tfunction markFunction(fn) {\n\t\t\tfn[expando] = true;\n\t\t\treturn fn;\n\t\t}\n\n\t\t/**\n   * Support testing using an element\n   * @param {Function} fn Passed the created div and expects a boolean result\n   */\n\t\tfunction assert(fn) {\n\t\t\tvar div = document.createElement(\"div\");\n\n\t\t\ttry {\n\t\t\t\treturn !!fn(div);\n\t\t\t} catch (e) {\n\t\t\t\treturn false;\n\t\t\t} finally {\n\t\t\t\t// Remove from its parent by default\n\t\t\t\tif (div.parentNode) {\n\t\t\t\t\tdiv.parentNode.removeChild(div);\n\t\t\t\t}\n\t\t\t\t// release memory in IE\n\t\t\t\tdiv = null;\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * Adds the same handler for all of the specified attrs\n   * @param {String} attrs Pipe-separated list of attributes\n   * @param {Function} handler The method that will be applied\n   */\n\t\tfunction addHandle(attrs, handler) {\n\t\t\tvar arr = attrs.split(\"|\"),\n\t\t\t    i = attrs.length;\n\n\t\t\twhile (i--) {\n\t\t\t\tExpr.attrHandle[arr[i]] = handler;\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * Checks document order of two siblings\n   * @param {Element} a\n   * @param {Element} b\n   * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n   */\n\t\tfunction siblingCheck(a, b) {\n\t\t\tvar cur = b && a,\n\t\t\t    diff = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);\n\n\t\t\t// Use IE sourceIndex if available on both nodes\n\t\t\tif (diff) {\n\t\t\t\treturn diff;\n\t\t\t}\n\n\t\t\t// Check if b follows a\n\t\t\tif (cur) {\n\t\t\t\twhile (cur = cur.nextSibling) {\n\t\t\t\t\tif (cur === b) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn a ? 1 : -1;\n\t\t}\n\n\t\t/**\n   * Returns a function to use in pseudos for input types\n   * @param {String} type\n   */\n\t\tfunction createInputPseudo(type) {\n\t\t\treturn function (elem) {\n\t\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\t\treturn name === \"input\" && elem.type === type;\n\t\t\t};\n\t\t}\n\n\t\t/**\n   * Returns a function to use in pseudos for buttons\n   * @param {String} type\n   */\n\t\tfunction createButtonPseudo(type) {\n\t\t\treturn function (elem) {\n\t\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\t\treturn (name === \"input\" || name === \"button\") && elem.type === type;\n\t\t\t};\n\t\t}\n\n\t\t/**\n   * Returns a function to use in pseudos for positionals\n   * @param {Function} fn\n   */\n\t\tfunction createPositionalPseudo(fn) {\n\t\t\treturn markFunction(function (argument) {\n\t\t\t\targument = +argument;\n\t\t\t\treturn markFunction(function (seed, matches) {\n\t\t\t\t\tvar j,\n\t\t\t\t\t    matchIndexes = fn([], seed.length, argument),\n\t\t\t\t\t    i = matchIndexes.length;\n\n\t\t\t\t\t// Match elements found at the specified indexes\n\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\tif (seed[j = matchIndexes[i]]) {\n\t\t\t\t\t\t\tseed[j] = !(matches[j] = seed[j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\t/**\n   * Checks a node for validity as a Sizzle context\n   * @param {Element|Object=} context\n   * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n   */\n\t\tfunction testContext(context) {\n\t\t\treturn context && typeof context.getElementsByTagName !== \"undefined\" && context;\n\t\t}\n\n\t\t// Expose support vars for convenience\n\t\tsupport = Sizzle.support = {};\n\n\t\t/**\n   * Detects XML nodes\n   * @param {Element|Object} elem An element or a document\n   * @returns {Boolean} True iff elem is a non-HTML XML node\n   */\n\t\tisXML = Sizzle.isXML = function (elem) {\n\t\t\t// documentElement is verified for cases where it doesn't yet exist\n\t\t\t// (such as loading iframes in IE - #4833)\n\t\t\tvar documentElement = elem && (elem.ownerDocument || elem).documentElement;\n\t\t\treturn documentElement ? documentElement.nodeName !== \"HTML\" : false;\n\t\t};\n\n\t\t/**\n   * Sets document-related variables once based on the current document\n   * @param {Element|Object} [doc] An element or document object to use to set the document\n   * @returns {Object} Returns the current document\n   */\n\t\tsetDocument = Sizzle.setDocument = function (node) {\n\t\t\tvar hasCompare,\n\t\t\t    parent,\n\t\t\t    doc = node ? node.ownerDocument || node : preferredDoc;\n\n\t\t\t// If no document and documentElement is available, return\n\t\t\tif (doc === document || doc.nodeType !== 9 || !doc.documentElement) {\n\t\t\t\treturn document;\n\t\t\t}\n\n\t\t\t// Set our document\n\t\t\tdocument = doc;\n\t\t\tdocElem = doc.documentElement;\n\t\t\tparent = doc.defaultView;\n\n\t\t\t// Support: IE>8\n\t\t\t// If iframe document is assigned to \"document\" variable and if iframe has been reloaded,\n\t\t\t// IE will throw \"permission denied\" error when accessing \"document\" variable, see jQuery #13936\n\t\t\t// IE6-8 do not support the defaultView property so parent will be undefined\n\t\t\tif (parent && parent !== parent.top) {\n\t\t\t\t// IE11 does not have attachEvent, so all must suffer\n\t\t\t\tif (parent.addEventListener) {\n\t\t\t\t\tparent.addEventListener(\"unload\", unloadHandler, false);\n\t\t\t\t} else if (parent.attachEvent) {\n\t\t\t\t\tparent.attachEvent(\"onunload\", unloadHandler);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Support tests\n   ---------------------------------------------------------------------- */\n\t\t\tdocumentIsHTML = !isXML(doc);\n\n\t\t\t/* Attributes\n   ---------------------------------------------------------------------- */\n\n\t\t\t// Support: IE<8\n\t\t\t// Verify that getAttribute really returns attributes and not properties\n\t\t\t// (excepting IE8 booleans)\n\t\t\tsupport.attributes = assert(function (div) {\n\t\t\t\tdiv.className = \"i\";\n\t\t\t\treturn !div.getAttribute(\"className\");\n\t\t\t});\n\n\t\t\t/* getElement(s)By*\n   ---------------------------------------------------------------------- */\n\n\t\t\t// Check if getElementsByTagName(\"*\") returns only elements\n\t\t\tsupport.getElementsByTagName = assert(function (div) {\n\t\t\t\tdiv.appendChild(doc.createComment(\"\"));\n\t\t\t\treturn !div.getElementsByTagName(\"*\").length;\n\t\t\t});\n\n\t\t\t// Support: IE<9\n\t\t\tsupport.getElementsByClassName = rnative.test(doc.getElementsByClassName);\n\n\t\t\t// Support: IE<10\n\t\t\t// Check if getElementById returns elements by name\n\t\t\t// The broken getElementById methods don't pick up programatically-set names,\n\t\t\t// so use a roundabout getElementsByName test\n\t\t\tsupport.getById = assert(function (div) {\n\t\t\t\tdocElem.appendChild(div).id = expando;\n\t\t\t\treturn !doc.getElementsByName || !doc.getElementsByName(expando).length;\n\t\t\t});\n\n\t\t\t// ID find and filter\n\t\t\tif (support.getById) {\n\t\t\t\tExpr.find[\"ID\"] = function (id, context) {\n\t\t\t\t\tif (typeof context.getElementById !== \"undefined\" && documentIsHTML) {\n\t\t\t\t\t\tvar m = context.getElementById(id);\n\t\t\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\n\t\t\t\t\t\t// nodes that are no longer in the document #6963\n\t\t\t\t\t\treturn m && m.parentNode ? [m] : [];\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tExpr.filter[\"ID\"] = function (id) {\n\t\t\t\t\tvar attrId = id.replace(runescape, funescape);\n\t\t\t\t\treturn function (elem) {\n\t\t\t\t\t\treturn elem.getAttribute(\"id\") === attrId;\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\t// Support: IE6/7\n\t\t\t\t// getElementById is not reliable as a find shortcut\n\t\t\t\tdelete Expr.find[\"ID\"];\n\n\t\t\t\tExpr.filter[\"ID\"] = function (id) {\n\t\t\t\t\tvar attrId = id.replace(runescape, funescape);\n\t\t\t\t\treturn function (elem) {\n\t\t\t\t\t\tvar node = typeof elem.getAttributeNode !== \"undefined\" && elem.getAttributeNode(\"id\");\n\t\t\t\t\t\treturn node && node.value === attrId;\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Tag\n\t\t\tExpr.find[\"TAG\"] = support.getElementsByTagName ? function (tag, context) {\n\t\t\t\tif (typeof context.getElementsByTagName !== \"undefined\") {\n\t\t\t\t\treturn context.getElementsByTagName(tag);\n\n\t\t\t\t\t// DocumentFragment nodes don't have gEBTN\n\t\t\t\t} else if (support.qsa) {\n\t\t\t\t\treturn context.querySelectorAll(tag);\n\t\t\t\t}\n\t\t\t} : function (tag, context) {\n\t\t\t\tvar elem,\n\t\t\t\t    tmp = [],\n\t\t\t\t    i = 0,\n\n\t\t\t\t// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n\t\t\t\tresults = context.getElementsByTagName(tag);\n\n\t\t\t\t// Filter out possible comments\n\t\t\t\tif (tag === \"*\") {\n\t\t\t\t\twhile (elem = results[i++]) {\n\t\t\t\t\t\tif (elem.nodeType === 1) {\n\t\t\t\t\t\t\ttmp.push(elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn tmp;\n\t\t\t\t}\n\t\t\t\treturn results;\n\t\t\t};\n\n\t\t\t// Class\n\t\t\tExpr.find[\"CLASS\"] = support.getElementsByClassName && function (className, context) {\n\t\t\t\tif (documentIsHTML) {\n\t\t\t\t\treturn context.getElementsByClassName(className);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t/* QSA/matchesSelector\n   ---------------------------------------------------------------------- */\n\n\t\t\t// QSA and matchesSelector support\n\n\t\t\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\t\t\trbuggyMatches = [];\n\n\t\t\t// qSa(:focus) reports false when true (Chrome 21)\n\t\t\t// We allow this because of a bug in IE8/9 that throws an error\n\t\t\t// whenever `document.activeElement` is accessed on an iframe\n\t\t\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\n\t\t\t// See http://bugs.jquery.com/ticket/13378\n\t\t\trbuggyQSA = [];\n\n\t\t\tif (support.qsa = rnative.test(doc.querySelectorAll)) {\n\t\t\t\t// Build QSA regex\n\t\t\t\t// Regex strategy adopted from Diego Perini\n\t\t\t\tassert(function (div) {\n\t\t\t\t\t// Select is set to empty string on purpose\n\t\t\t\t\t// This is to test IE's treatment of not explicitly\n\t\t\t\t\t// setting a boolean content attribute,\n\t\t\t\t\t// since its presence should be enough\n\t\t\t\t\t// http://bugs.jquery.com/ticket/12359\n\t\t\t\t\tdocElem.appendChild(div).innerHTML = \"<a id='\" + expando + \"'></a>\" + \"<select id='\" + expando + \"-\\f]' msallowcapture=''>\" + \"<option selected=''></option></select>\";\n\n\t\t\t\t\t// Support: IE8, Opera 11-12.16\n\t\t\t\t\t// Nothing should be selected when empty strings follow ^= or $= or *=\n\t\t\t\t\t// The test attribute must be unknown in Opera but \"safe\" for WinRT\n\t\t\t\t\t// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n\t\t\t\t\tif (div.querySelectorAll(\"[msallowcapture^='']\").length) {\n\t\t\t\t\t\trbuggyQSA.push(\"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\");\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support: IE8\n\t\t\t\t\t// Boolean attributes and \"value\" are not treated correctly\n\t\t\t\t\tif (!div.querySelectorAll(\"[selected]\").length) {\n\t\t\t\t\t\trbuggyQSA.push(\"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\");\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support: Chrome<29, Android<4.2+, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.7+\n\t\t\t\t\tif (!div.querySelectorAll(\"[id~=\" + expando + \"-]\").length) {\n\t\t\t\t\t\trbuggyQSA.push(\"~=\");\n\t\t\t\t\t}\n\n\t\t\t\t\t// Webkit/Opera - :checked should return selected option elements\n\t\t\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t\t\t// IE8 throws error here and will not see later tests\n\t\t\t\t\tif (!div.querySelectorAll(\":checked\").length) {\n\t\t\t\t\t\trbuggyQSA.push(\":checked\");\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support: Safari 8+, iOS 8+\n\t\t\t\t\t// https://bugs.webkit.org/show_bug.cgi?id=136851\n\t\t\t\t\t// In-page `selector#id sibing-combinator selector` fails\n\t\t\t\t\tif (!div.querySelectorAll(\"a#\" + expando + \"+*\").length) {\n\t\t\t\t\t\trbuggyQSA.push(\".#.+[+~]\");\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tassert(function (div) {\n\t\t\t\t\t// Support: Windows 8 Native Apps\n\t\t\t\t\t// The type and name attributes are restricted during .innerHTML assignment\n\t\t\t\t\tvar input = doc.createElement(\"input\");\n\t\t\t\t\tinput.setAttribute(\"type\", \"hidden\");\n\t\t\t\t\tdiv.appendChild(input).setAttribute(\"name\", \"D\");\n\n\t\t\t\t\t// Support: IE8\n\t\t\t\t\t// Enforce case-sensitivity of name attribute\n\t\t\t\t\tif (div.querySelectorAll(\"[name=d]\").length) {\n\t\t\t\t\t\trbuggyQSA.push(\"name\" + whitespace + \"*[*^$|!~]?=\");\n\t\t\t\t\t}\n\n\t\t\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n\t\t\t\t\t// IE8 throws error here and will not see later tests\n\t\t\t\t\tif (!div.querySelectorAll(\":enabled\").length) {\n\t\t\t\t\t\trbuggyQSA.push(\":enabled\", \":disabled\");\n\t\t\t\t\t}\n\n\t\t\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n\t\t\t\t\tdiv.querySelectorAll(\"*,:x\");\n\t\t\t\t\trbuggyQSA.push(\",.*:\");\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {\n\n\t\t\t\tassert(function (div) {\n\t\t\t\t\t// Check to see if it's possible to do matchesSelector\n\t\t\t\t\t// on a disconnected node (IE 9)\n\t\t\t\t\tsupport.disconnectedMatch = matches.call(div, \"div\");\n\n\t\t\t\t\t// This should fail with an exception\n\t\t\t\t\t// Gecko does not error, returns false instead\n\t\t\t\t\tmatches.call(div, \"[s!='']:x\");\n\t\t\t\t\trbuggyMatches.push(\"!=\", pseudos);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\trbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join(\"|\"));\n\t\t\trbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join(\"|\"));\n\n\t\t\t/* Contains\n   ---------------------------------------------------------------------- */\n\t\t\thasCompare = rnative.test(docElem.compareDocumentPosition);\n\n\t\t\t// Element contains another\n\t\t\t// Purposefully does not implement inclusive descendent\n\t\t\t// As in, an element does not contain itself\n\t\t\tcontains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {\n\t\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n\t\t\t\t    bup = b && b.parentNode;\n\t\t\t\treturn a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));\n\t\t\t} : function (a, b) {\n\t\t\t\tif (b) {\n\t\t\t\t\twhile (b = b.parentNode) {\n\t\t\t\t\t\tif (b === a) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t};\n\n\t\t\t/* Sorting\n   ---------------------------------------------------------------------- */\n\n\t\t\t// Document order sorting\n\t\t\tsortOrder = hasCompare ? function (a, b) {\n\n\t\t\t\t// Flag for duplicate removal\n\t\t\t\tif (a === b) {\n\t\t\t\t\thasDuplicate = true;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\t// Sort on method existence if only one input has compareDocumentPosition\n\t\t\t\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\t\t\t\tif (compare) {\n\t\t\t\t\treturn compare;\n\t\t\t\t}\n\n\t\t\t\t// Calculate position if both inputs belong to the same document\n\t\t\t\tcompare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) :\n\n\t\t\t\t// Otherwise we know they are disconnected\n\t\t\t\t1;\n\n\t\t\t\t// Disconnected nodes\n\t\t\t\tif (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {\n\n\t\t\t\t\t// Choose the first element that is related to our preferred document\n\t\t\t\t\tif (a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\tif (b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Maintain original order\n\t\t\t\t\treturn sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;\n\t\t\t\t}\n\n\t\t\t\treturn compare & 4 ? -1 : 1;\n\t\t\t} : function (a, b) {\n\t\t\t\t// Exit early if the nodes are identical\n\t\t\t\tif (a === b) {\n\t\t\t\t\thasDuplicate = true;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\tvar cur,\n\t\t\t\t    i = 0,\n\t\t\t\t    aup = a.parentNode,\n\t\t\t\t    bup = b.parentNode,\n\t\t\t\t    ap = [a],\n\t\t\t\t    bp = [b];\n\n\t\t\t\t// Parentless nodes are either documents or disconnected\n\t\t\t\tif (!aup || !bup) {\n\t\t\t\t\treturn a === doc ? -1 : b === doc ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;\n\n\t\t\t\t\t// If the nodes are siblings, we can do a quick check\n\t\t\t\t} else if (aup === bup) {\n\t\t\t\t\treturn siblingCheck(a, b);\n\t\t\t\t}\n\n\t\t\t\t// Otherwise we need full lists of their ancestors for comparison\n\t\t\t\tcur = a;\n\t\t\t\twhile (cur = cur.parentNode) {\n\t\t\t\t\tap.unshift(cur);\n\t\t\t\t}\n\t\t\t\tcur = b;\n\t\t\t\twhile (cur = cur.parentNode) {\n\t\t\t\t\tbp.unshift(cur);\n\t\t\t\t}\n\n\t\t\t\t// Walk down the tree looking for a discrepancy\n\t\t\t\twhile (ap[i] === bp[i]) {\n\t\t\t\t\ti++;\n\t\t\t\t}\n\n\t\t\t\treturn i ?\n\t\t\t\t// Do a sibling check if the nodes have a common ancestor\n\t\t\t\tsiblingCheck(ap[i], bp[i]) :\n\n\t\t\t\t// Otherwise nodes in our document sort first\n\t\t\t\tap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;\n\t\t\t};\n\n\t\t\treturn doc;\n\t\t};\n\n\t\tSizzle.matches = function (expr, elements) {\n\t\t\treturn Sizzle(expr, null, null, elements);\n\t\t};\n\n\t\tSizzle.matchesSelector = function (elem, expr) {\n\t\t\t// Set document vars if needed\n\t\t\tif ((elem.ownerDocument || elem) !== document) {\n\t\t\t\tsetDocument(elem);\n\t\t\t}\n\n\t\t\t// Make sure that attribute selectors are quoted\n\t\t\texpr = expr.replace(rattributeQuotes, \"='$1']\");\n\n\t\t\tif (support.matchesSelector && documentIsHTML && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {\n\n\t\t\t\ttry {\n\t\t\t\t\tvar ret = matches.call(elem, expr);\n\n\t\t\t\t\t// IE 9's matchesSelector returns false on disconnected nodes\n\t\t\t\t\tif (ret || support.disconnectedMatch ||\n\t\t\t\t\t// As well, disconnected nodes are said to be in a document\n\t\t\t\t\t// fragment in IE 9\n\t\t\t\t\telem.document && elem.document.nodeType !== 11) {\n\t\t\t\t\t\treturn ret;\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {}\n\t\t\t}\n\n\t\t\treturn Sizzle(expr, document, null, [elem]).length > 0;\n\t\t};\n\n\t\tSizzle.contains = function (context, elem) {\n\t\t\t// Set document vars if needed\n\t\t\tif ((context.ownerDocument || context) !== document) {\n\t\t\t\tsetDocument(context);\n\t\t\t}\n\t\t\treturn contains(context, elem);\n\t\t};\n\n\t\tSizzle.attr = function (elem, name) {\n\t\t\t// Set document vars if needed\n\t\t\tif ((elem.ownerDocument || elem) !== document) {\n\t\t\t\tsetDocument(elem);\n\t\t\t}\n\n\t\t\tvar fn = Expr.attrHandle[name.toLowerCase()],\n\n\t\t\t// Don't get fooled by Object.prototype properties (jQuery #13807)\n\t\t\tval = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;\n\n\t\t\treturn val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;\n\t\t};\n\n\t\tSizzle.error = function (msg) {\n\t\t\tthrow new Error(\"Syntax error, unrecognized expression: \" + msg);\n\t\t};\n\n\t\t/**\n   * Document sorting and removing duplicates\n   * @param {ArrayLike} results\n   */\n\t\tSizzle.uniqueSort = function (results) {\n\t\t\tvar elem,\n\t\t\t    duplicates = [],\n\t\t\t    j = 0,\n\t\t\t    i = 0;\n\n\t\t\t// Unless we *know* we can detect duplicates, assume their presence\n\t\t\thasDuplicate = !support.detectDuplicates;\n\t\t\tsortInput = !support.sortStable && results.slice(0);\n\t\t\tresults.sort(sortOrder);\n\n\t\t\tif (hasDuplicate) {\n\t\t\t\twhile (elem = results[i++]) {\n\t\t\t\t\tif (elem === results[i]) {\n\t\t\t\t\t\tj = duplicates.push(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile (j--) {\n\t\t\t\t\tresults.splice(duplicates[j], 1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Clear input after sorting to release objects\n\t\t\t// See https://github.com/jquery/sizzle/pull/225\n\t\t\tsortInput = null;\n\n\t\t\treturn results;\n\t\t};\n\n\t\t/**\n   * Utility function for retrieving the text value of an array of DOM nodes\n   * @param {Array|Element} elem\n   */\n\t\tgetText = Sizzle.getText = function (elem) {\n\t\t\tvar node,\n\t\t\t    ret = \"\",\n\t\t\t    i = 0,\n\t\t\t    nodeType = elem.nodeType;\n\n\t\t\tif (!nodeType) {\n\t\t\t\t// If no nodeType, this is expected to be an array\n\t\t\t\twhile (node = elem[i++]) {\n\t\t\t\t\t// Do not traverse comment nodes\n\t\t\t\t\tret += getText(node);\n\t\t\t\t}\n\t\t\t} else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {\n\t\t\t\t// Use textContent for elements\n\t\t\t\t// innerText usage removed for consistency of new lines (jQuery #11153)\n\t\t\t\tif (typeof elem.textContent === \"string\") {\n\t\t\t\t\treturn elem.textContent;\n\t\t\t\t} else {\n\t\t\t\t\t// Traverse its children\n\t\t\t\t\tfor (elem = elem.firstChild; elem; elem = elem.nextSibling) {\n\t\t\t\t\t\tret += getText(elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (nodeType === 3 || nodeType === 4) {\n\t\t\t\treturn elem.nodeValue;\n\t\t\t}\n\t\t\t// Do not include comment or processing instruction nodes\n\n\t\t\treturn ret;\n\t\t};\n\n\t\tExpr = Sizzle.selectors = {\n\n\t\t\t// Can be adjusted by the user\n\t\t\tcacheLength: 50,\n\n\t\t\tcreatePseudo: markFunction,\n\n\t\t\tmatch: matchExpr,\n\n\t\t\tattrHandle: {},\n\n\t\t\tfind: {},\n\n\t\t\trelative: {\n\t\t\t\t\">\": { dir: \"parentNode\", first: true },\n\t\t\t\t\" \": { dir: \"parentNode\" },\n\t\t\t\t\"+\": { dir: \"previousSibling\", first: true },\n\t\t\t\t\"~\": { dir: \"previousSibling\" }\n\t\t\t},\n\n\t\t\tpreFilter: {\n\t\t\t\t\"ATTR\": function ATTR(match) {\n\t\t\t\t\tmatch[1] = match[1].replace(runescape, funescape);\n\n\t\t\t\t\t// Move the given value to match[3] whether quoted or unquoted\n\t\t\t\t\tmatch[3] = (match[3] || match[4] || match[5] || \"\").replace(runescape, funescape);\n\n\t\t\t\t\tif (match[2] === \"~=\") {\n\t\t\t\t\t\tmatch[3] = \" \" + match[3] + \" \";\n\t\t\t\t\t}\n\n\t\t\t\t\treturn match.slice(0, 4);\n\t\t\t\t},\n\n\t\t\t\t\"CHILD\": function CHILD(match) {\n\t\t\t\t\t/* matches from matchExpr[\"CHILD\"]\n     \t1 type (only|nth|...)\n     \t2 what (child|of-type)\n     \t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n     \t4 xn-component of xn+y argument ([+-]?\\d*n|)\n     \t5 sign of xn-component\n     \t6 x of xn-component\n     \t7 sign of y-component\n     \t8 y of y-component\n     */\n\t\t\t\t\tmatch[1] = match[1].toLowerCase();\n\n\t\t\t\t\tif (match[1].slice(0, 3) === \"nth\") {\n\t\t\t\t\t\t// nth-* requires argument\n\t\t\t\t\t\tif (!match[3]) {\n\t\t\t\t\t\t\tSizzle.error(match[0]);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n\t\t\t\t\t\t// remember that false/true cast respectively to 0/1\n\t\t\t\t\t\tmatch[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === \"even\" || match[3] === \"odd\"));\n\t\t\t\t\t\tmatch[5] = +(match[7] + match[8] || match[3] === \"odd\");\n\n\t\t\t\t\t\t// other types prohibit arguments\n\t\t\t\t\t} else if (match[3]) {\n\t\t\t\t\t\tSizzle.error(match[0]);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn match;\n\t\t\t\t},\n\n\t\t\t\t\"PSEUDO\": function PSEUDO(match) {\n\t\t\t\t\tvar excess,\n\t\t\t\t\t    unquoted = !match[6] && match[2];\n\n\t\t\t\t\tif (matchExpr[\"CHILD\"].test(match[0])) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Accept quoted arguments as-is\n\t\t\t\t\tif (match[3]) {\n\t\t\t\t\t\tmatch[2] = match[4] || match[5] || \"\";\n\n\t\t\t\t\t\t// Strip excess characters from unquoted arguments\n\t\t\t\t\t} else if (unquoted && rpseudo.test(unquoted) && (\n\t\t\t\t\t// Get excess from tokenize (recursively)\n\t\t\t\t\texcess = tokenize(unquoted, true)) && (\n\t\t\t\t\t// advance to the next closing parenthesis\n\t\t\t\t\texcess = unquoted.indexOf(\")\", unquoted.length - excess) - unquoted.length)) {\n\n\t\t\t\t\t\t// excess is a negative index\n\t\t\t\t\t\tmatch[0] = match[0].slice(0, excess);\n\t\t\t\t\t\tmatch[2] = unquoted.slice(0, excess);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n\t\t\t\t\treturn match.slice(0, 3);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tfilter: {\n\n\t\t\t\t\"TAG\": function TAG(nodeNameSelector) {\n\t\t\t\t\tvar nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();\n\t\t\t\t\treturn nodeNameSelector === \"*\" ? function () {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t} : function (elem) {\n\t\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n\t\t\t\t\t};\n\t\t\t\t},\n\n\t\t\t\t\"CLASS\": function CLASS(className) {\n\t\t\t\t\tvar pattern = classCache[className + \" \"];\n\n\t\t\t\t\treturn pattern || (pattern = new RegExp(\"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\")) && classCache(className, function (elem) {\n\t\t\t\t\t\treturn pattern.test(typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== \"undefined\" && elem.getAttribute(\"class\") || \"\");\n\t\t\t\t\t});\n\t\t\t\t},\n\n\t\t\t\t\"ATTR\": function ATTR(name, operator, check) {\n\t\t\t\t\treturn function (elem) {\n\t\t\t\t\t\tvar result = Sizzle.attr(elem, name);\n\n\t\t\t\t\t\tif (result == null) {\n\t\t\t\t\t\t\treturn operator === \"!=\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!operator) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tresult += \"\";\n\n\t\t\t\t\t\treturn operator === \"=\" ? result === check : operator === \"!=\" ? result !== check : operator === \"^=\" ? check && result.indexOf(check) === 0 : operator === \"*=\" ? check && result.indexOf(check) > -1 : operator === \"$=\" ? check && result.slice(-check.length) === check : operator === \"~=\" ? (\" \" + result.replace(rwhitespace, \" \") + \" \").indexOf(check) > -1 : operator === \"|=\" ? result === check || result.slice(0, check.length + 1) === check + \"-\" : false;\n\t\t\t\t\t};\n\t\t\t\t},\n\n\t\t\t\t\"CHILD\": function CHILD(type, what, argument, first, last) {\n\t\t\t\t\tvar simple = type.slice(0, 3) !== \"nth\",\n\t\t\t\t\t    forward = type.slice(-4) !== \"last\",\n\t\t\t\t\t    ofType = what === \"of-type\";\n\n\t\t\t\t\treturn first === 1 && last === 0 ?\n\n\t\t\t\t\t// Shortcut for :nth-*(n)\n\t\t\t\t\tfunction (elem) {\n\t\t\t\t\t\treturn !!elem.parentNode;\n\t\t\t\t\t} : function (elem, context, xml) {\n\t\t\t\t\t\tvar cache,\n\t\t\t\t\t\t    outerCache,\n\t\t\t\t\t\t    node,\n\t\t\t\t\t\t    diff,\n\t\t\t\t\t\t    nodeIndex,\n\t\t\t\t\t\t    start,\n\t\t\t\t\t\t    dir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n\t\t\t\t\t\t    parent = elem.parentNode,\n\t\t\t\t\t\t    name = ofType && elem.nodeName.toLowerCase(),\n\t\t\t\t\t\t    useCache = !xml && !ofType;\n\n\t\t\t\t\t\tif (parent) {\n\n\t\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n\t\t\t\t\t\t\tif (simple) {\n\t\t\t\t\t\t\t\twhile (dir) {\n\t\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\t\twhile (node = node[dir]) {\n\t\t\t\t\t\t\t\t\t\tif (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {\n\t\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven't yet done so)\n\t\t\t\t\t\t\t\t\tstart = dir = type === \"only\" && !start && \"nextSibling\";\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tstart = [forward ? parent.firstChild : parent.lastChild];\n\n\t\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n\t\t\t\t\t\t\tif (forward && useCache) {\n\t\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n\t\t\t\t\t\t\t\touterCache = parent[expando] || (parent[expando] = {});\n\t\t\t\t\t\t\t\tcache = outerCache[type] || [];\n\t\t\t\t\t\t\t\tnodeIndex = cache[0] === dirruns && cache[1];\n\t\t\t\t\t\t\t\tdiff = cache[0] === dirruns && cache[2];\n\t\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[nodeIndex];\n\n\t\t\t\t\t\t\t\twhile (node = ++nodeIndex && node && node[dir] || (\n\n\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n\t\t\t\t\t\t\t\tdiff = nodeIndex = 0) || start.pop()) {\n\n\t\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n\t\t\t\t\t\t\t\t\tif (node.nodeType === 1 && ++diff && node === elem) {\n\t\t\t\t\t\t\t\t\t\touterCache[type] = [dirruns, nodeIndex, diff];\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Use previously-cached element index if available\n\t\t\t\t\t\t\t} else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type]) && cache[0] === dirruns) {\n\t\t\t\t\t\t\t\tdiff = cache[1];\n\n\t\t\t\t\t\t\t\t// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n\t\t\t\t\t\t\t\twhile (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {\n\n\t\t\t\t\t\t\t\t\tif ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {\n\t\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n\t\t\t\t\t\t\t\t\t\tif (useCache) {\n\t\t\t\t\t\t\t\t\t\t\t(node[expando] || (node[expando] = {}))[type] = [dirruns, diff];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif (node === elem) {\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n\t\t\t\t\t\t\tdiff -= last;\n\t\t\t\t\t\t\treturn diff === first || diff % first === 0 && diff / first >= 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t},\n\n\t\t\t\t\"PSEUDO\": function PSEUDO(pseudo, argument) {\n\t\t\t\t\t// pseudo-class names are case-insensitive\n\t\t\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n\t\t\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n\t\t\t\t\t// Remember that setFilters inherits from pseudos\n\t\t\t\t\tvar args,\n\t\t\t\t\t    fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error(\"unsupported pseudo: \" + pseudo);\n\n\t\t\t\t\t// The user may use createPseudo to indicate that\n\t\t\t\t\t// arguments are needed to create the filter function\n\t\t\t\t\t// just as Sizzle does\n\t\t\t\t\tif (fn[expando]) {\n\t\t\t\t\t\treturn fn(argument);\n\t\t\t\t\t}\n\n\t\t\t\t\t// But maintain support for old signatures\n\t\t\t\t\tif (fn.length > 1) {\n\t\t\t\t\t\targs = [pseudo, pseudo, \"\", argument];\n\t\t\t\t\t\treturn Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {\n\t\t\t\t\t\t\tvar idx,\n\t\t\t\t\t\t\t    matched = fn(seed, argument),\n\t\t\t\t\t\t\t    i = matched.length;\n\t\t\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\t\t\tidx = indexOf(seed, matched[i]);\n\t\t\t\t\t\t\t\tseed[idx] = !(matches[idx] = matched[i]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}) : function (elem) {\n\t\t\t\t\t\t\treturn fn(elem, 0, args);\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\treturn fn;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tpseudos: {\n\t\t\t\t// Potentially complex pseudos\n\t\t\t\t\"not\": markFunction(function (selector) {\n\t\t\t\t\t// Trim the selector passed to compile\n\t\t\t\t\t// to avoid treating leading and trailing\n\t\t\t\t\t// spaces as combinators\n\t\t\t\t\tvar input = [],\n\t\t\t\t\t    results = [],\n\t\t\t\t\t    matcher = compile(selector.replace(rtrim, \"$1\"));\n\n\t\t\t\t\treturn matcher[expando] ? markFunction(function (seed, matches, context, xml) {\n\t\t\t\t\t\tvar elem,\n\t\t\t\t\t\t    unmatched = matcher(seed, null, xml, []),\n\t\t\t\t\t\t    i = seed.length;\n\n\t\t\t\t\t\t// Match elements unmatched by `matcher`\n\t\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\t\tif (elem = unmatched[i]) {\n\t\t\t\t\t\t\t\tseed[i] = !(matches[i] = elem);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}) : function (elem, context, xml) {\n\t\t\t\t\t\tinput[0] = elem;\n\t\t\t\t\t\tmatcher(input, null, xml, results);\n\t\t\t\t\t\t// Don't keep the element (issue #299)\n\t\t\t\t\t\tinput[0] = null;\n\t\t\t\t\t\treturn !results.pop();\n\t\t\t\t\t};\n\t\t\t\t}),\n\n\t\t\t\t\"has\": markFunction(function (selector) {\n\t\t\t\t\treturn function (elem) {\n\t\t\t\t\t\treturn Sizzle(selector, elem).length > 0;\n\t\t\t\t\t};\n\t\t\t\t}),\n\n\t\t\t\t\"contains\": markFunction(function (text) {\n\t\t\t\t\ttext = text.replace(runescape, funescape);\n\t\t\t\t\treturn function (elem) {\n\t\t\t\t\t\treturn (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;\n\t\t\t\t\t};\n\t\t\t\t}),\n\n\t\t\t\t// \"Whether an element is represented by a :lang() selector\n\t\t\t\t// is based solely on the element's language value\n\t\t\t\t// being equal to the identifier C,\n\t\t\t\t// or beginning with the identifier C immediately followed by \"-\".\n\t\t\t\t// The matching of C against the element's language value is performed case-insensitively.\n\t\t\t\t// The identifier C does not have to be a valid language name.\"\n\t\t\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n\t\t\t\t\"lang\": markFunction(function (lang) {\n\t\t\t\t\t// lang value must be a valid identifier\n\t\t\t\t\tif (!ridentifier.test(lang || \"\")) {\n\t\t\t\t\t\tSizzle.error(\"unsupported lang: \" + lang);\n\t\t\t\t\t}\n\t\t\t\t\tlang = lang.replace(runescape, funescape).toLowerCase();\n\t\t\t\t\treturn function (elem) {\n\t\t\t\t\t\tvar elemLang;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tif (elemLang = documentIsHTML ? elem.lang : elem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) {\n\n\t\t\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n\t\t\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf(lang + \"-\") === 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} while ((elem = elem.parentNode) && elem.nodeType === 1);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t};\n\t\t\t\t}),\n\n\t\t\t\t// Miscellaneous\n\t\t\t\t\"target\": function target(elem) {\n\t\t\t\t\tvar hash = window.location && window.location.hash;\n\t\t\t\t\treturn hash && hash.slice(1) === elem.id;\n\t\t\t\t},\n\n\t\t\t\t\"root\": function root(elem) {\n\t\t\t\t\treturn elem === docElem;\n\t\t\t\t},\n\n\t\t\t\t\"focus\": function focus(elem) {\n\t\t\t\t\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n\t\t\t\t},\n\n\t\t\t\t// Boolean properties\n\t\t\t\t\"enabled\": function enabled(elem) {\n\t\t\t\t\treturn elem.disabled === false;\n\t\t\t\t},\n\n\t\t\t\t\"disabled\": function disabled(elem) {\n\t\t\t\t\treturn elem.disabled === true;\n\t\t\t\t},\n\n\t\t\t\t\"checked\": function checked(elem) {\n\t\t\t\t\t// In CSS3, :checked should return both checked and selected elements\n\t\t\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n\t\t\t\t\treturn nodeName === \"input\" && !!elem.checked || nodeName === \"option\" && !!elem.selected;\n\t\t\t\t},\n\n\t\t\t\t\"selected\": function selected(elem) {\n\t\t\t\t\t// Accessing this property makes selected-by-default\n\t\t\t\t\t// options in Safari work properly\n\t\t\t\t\tif (elem.parentNode) {\n\t\t\t\t\t\telem.parentNode.selectedIndex;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn elem.selected === true;\n\t\t\t\t},\n\n\t\t\t\t// Contents\n\t\t\t\t\"empty\": function empty(elem) {\n\t\t\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n\t\t\t\t\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n\t\t\t\t\t//   but not by others (comment: 8; processing instruction: 7; etc.)\n\t\t\t\t\t// nodeType < 6 works because attributes (2) do not appear as children\n\t\t\t\t\tfor (elem = elem.firstChild; elem; elem = elem.nextSibling) {\n\t\t\t\t\t\tif (elem.nodeType < 6) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\n\t\t\t\t\"parent\": function parent(elem) {\n\t\t\t\t\treturn !Expr.pseudos[\"empty\"](elem);\n\t\t\t\t},\n\n\t\t\t\t// Element/input types\n\t\t\t\t\"header\": function header(elem) {\n\t\t\t\t\treturn rheader.test(elem.nodeName);\n\t\t\t\t},\n\n\t\t\t\t\"input\": function input(elem) {\n\t\t\t\t\treturn rinputs.test(elem.nodeName);\n\t\t\t\t},\n\n\t\t\t\t\"button\": function button(elem) {\n\t\t\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\t\t\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\n\t\t\t\t},\n\n\t\t\t\t\"text\": function text(elem) {\n\t\t\t\t\tvar attr;\n\t\t\t\t\treturn elem.nodeName.toLowerCase() === \"input\" && elem.type === \"text\" && (\n\n\t\t\t\t\t// Support: IE<8\n\t\t\t\t\t// New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n\t\t\t\t\t(attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === \"text\");\n\t\t\t\t},\n\n\t\t\t\t// Position-in-collection\n\t\t\t\t\"first\": createPositionalPseudo(function () {\n\t\t\t\t\treturn [0];\n\t\t\t\t}),\n\n\t\t\t\t\"last\": createPositionalPseudo(function (matchIndexes, length) {\n\t\t\t\t\treturn [length - 1];\n\t\t\t\t}),\n\n\t\t\t\t\"eq\": createPositionalPseudo(function (matchIndexes, length, argument) {\n\t\t\t\t\treturn [argument < 0 ? argument + length : argument];\n\t\t\t\t}),\n\n\t\t\t\t\"even\": createPositionalPseudo(function (matchIndexes, length) {\n\t\t\t\t\tvar i = 0;\n\t\t\t\t\tfor (; i < length; i += 2) {\n\t\t\t\t\t\tmatchIndexes.push(i);\n\t\t\t\t\t}\n\t\t\t\t\treturn matchIndexes;\n\t\t\t\t}),\n\n\t\t\t\t\"odd\": createPositionalPseudo(function (matchIndexes, length) {\n\t\t\t\t\tvar i = 1;\n\t\t\t\t\tfor (; i < length; i += 2) {\n\t\t\t\t\t\tmatchIndexes.push(i);\n\t\t\t\t\t}\n\t\t\t\t\treturn matchIndexes;\n\t\t\t\t}),\n\n\t\t\t\t\"lt\": createPositionalPseudo(function (matchIndexes, length, argument) {\n\t\t\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\t\t\tfor (; --i >= 0;) {\n\t\t\t\t\t\tmatchIndexes.push(i);\n\t\t\t\t\t}\n\t\t\t\t\treturn matchIndexes;\n\t\t\t\t}),\n\n\t\t\t\t\"gt\": createPositionalPseudo(function (matchIndexes, length, argument) {\n\t\t\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\t\t\tfor (; ++i < length;) {\n\t\t\t\t\t\tmatchIndexes.push(i);\n\t\t\t\t\t}\n\t\t\t\t\treturn matchIndexes;\n\t\t\t\t})\n\t\t\t}\n\t\t};\n\n\t\tExpr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"];\n\n\t\t// Add button/input type pseudos\n\t\tfor (i in { radio: true, checkbox: true, file: true, password: true, image: true }) {\n\t\t\tExpr.pseudos[i] = createInputPseudo(i);\n\t\t}\n\t\tfor (i in { submit: true, reset: true }) {\n\t\t\tExpr.pseudos[i] = createButtonPseudo(i);\n\t\t}\n\n\t\t// Easy API for creating new setFilters\n\t\tfunction setFilters() {}\n\t\tsetFilters.prototype = Expr.filters = Expr.pseudos;\n\t\tExpr.setFilters = new setFilters();\n\n\t\ttokenize = Sizzle.tokenize = function (selector, parseOnly) {\n\t\t\tvar matched,\n\t\t\t    match,\n\t\t\t    tokens,\n\t\t\t    type,\n\t\t\t    soFar,\n\t\t\t    groups,\n\t\t\t    preFilters,\n\t\t\t    cached = tokenCache[selector + \" \"];\n\n\t\t\tif (cached) {\n\t\t\t\treturn parseOnly ? 0 : cached.slice(0);\n\t\t\t}\n\n\t\t\tsoFar = selector;\n\t\t\tgroups = [];\n\t\t\tpreFilters = Expr.preFilter;\n\n\t\t\twhile (soFar) {\n\n\t\t\t\t// Comma and first run\n\t\t\t\tif (!matched || (match = rcomma.exec(soFar))) {\n\t\t\t\t\tif (match) {\n\t\t\t\t\t\t// Don't consume trailing commas as valid\n\t\t\t\t\t\tsoFar = soFar.slice(match[0].length) || soFar;\n\t\t\t\t\t}\n\t\t\t\t\tgroups.push(tokens = []);\n\t\t\t\t}\n\n\t\t\t\tmatched = false;\n\n\t\t\t\t// Combinators\n\t\t\t\tif (match = rcombinators.exec(soFar)) {\n\t\t\t\t\tmatched = match.shift();\n\t\t\t\t\ttokens.push({\n\t\t\t\t\t\tvalue: matched,\n\t\t\t\t\t\t// Cast descendant combinators to space\n\t\t\t\t\t\ttype: match[0].replace(rtrim, \" \")\n\t\t\t\t\t});\n\t\t\t\t\tsoFar = soFar.slice(matched.length);\n\t\t\t\t}\n\n\t\t\t\t// Filters\n\t\t\t\tfor (type in Expr.filter) {\n\t\t\t\t\tif ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {\n\t\t\t\t\t\tmatched = match.shift();\n\t\t\t\t\t\ttokens.push({\n\t\t\t\t\t\t\tvalue: matched,\n\t\t\t\t\t\t\ttype: type,\n\t\t\t\t\t\t\tmatches: match\n\t\t\t\t\t\t});\n\t\t\t\t\t\tsoFar = soFar.slice(matched.length);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!matched) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Return the length of the invalid excess\n\t\t\t// if we're just parsing\n\t\t\t// Otherwise, throw an error or return tokens\n\t\t\treturn parseOnly ? soFar.length : soFar ? Sizzle.error(selector) :\n\t\t\t// Cache the tokens\n\t\t\ttokenCache(selector, groups).slice(0);\n\t\t};\n\n\t\tfunction toSelector(tokens) {\n\t\t\tvar i = 0,\n\t\t\t    len = tokens.length,\n\t\t\t    selector = \"\";\n\t\t\tfor (; i < len; i++) {\n\t\t\t\tselector += tokens[i].value;\n\t\t\t}\n\t\t\treturn selector;\n\t\t}\n\n\t\tfunction addCombinator(matcher, combinator, base) {\n\t\t\tvar dir = combinator.dir,\n\t\t\t    checkNonElements = base && dir === \"parentNode\",\n\t\t\t    doneName = done++;\n\n\t\t\treturn combinator.first ?\n\t\t\t// Check against closest ancestor/preceding element\n\t\t\tfunction (elem, context, xml) {\n\t\t\t\twhile (elem = elem[dir]) {\n\t\t\t\t\tif (elem.nodeType === 1 || checkNonElements) {\n\t\t\t\t\t\treturn matcher(elem, context, xml);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} :\n\n\t\t\t// Check against all ancestor/preceding elements\n\t\t\tfunction (elem, context, xml) {\n\t\t\t\tvar oldCache,\n\t\t\t\t    outerCache,\n\t\t\t\t    newCache = [dirruns, doneName];\n\n\t\t\t\t// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching\n\t\t\t\tif (xml) {\n\t\t\t\t\twhile (elem = elem[dir]) {\n\t\t\t\t\t\tif (elem.nodeType === 1 || checkNonElements) {\n\t\t\t\t\t\t\tif (matcher(elem, context, xml)) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\twhile (elem = elem[dir]) {\n\t\t\t\t\t\tif (elem.nodeType === 1 || checkNonElements) {\n\t\t\t\t\t\t\touterCache = elem[expando] || (elem[expando] = {});\n\t\t\t\t\t\t\tif ((oldCache = outerCache[dir]) && oldCache[0] === dirruns && oldCache[1] === doneName) {\n\n\t\t\t\t\t\t\t\t// Assign to newCache so results back-propagate to previous elements\n\t\t\t\t\t\t\t\treturn newCache[2] = oldCache[2];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// Reuse newcache so results back-propagate to previous elements\n\t\t\t\t\t\t\t\touterCache[dir] = newCache;\n\n\t\t\t\t\t\t\t\t// A match means we're done; a fail means we have to keep checking\n\t\t\t\t\t\t\t\tif (newCache[2] = matcher(elem, context, xml)) {\n\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tfunction elementMatcher(matchers) {\n\t\t\treturn matchers.length > 1 ? function (elem, context, xml) {\n\t\t\t\tvar i = matchers.length;\n\t\t\t\twhile (i--) {\n\t\t\t\t\tif (!matchers[i](elem, context, xml)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t} : matchers[0];\n\t\t}\n\n\t\tfunction multipleContexts(selector, contexts, results) {\n\t\t\tvar i = 0,\n\t\t\t    len = contexts.length;\n\t\t\tfor (; i < len; i++) {\n\t\t\t\tSizzle(selector, contexts[i], results);\n\t\t\t}\n\t\t\treturn results;\n\t\t}\n\n\t\tfunction condense(unmatched, map, filter, context, xml) {\n\t\t\tvar elem,\n\t\t\t    newUnmatched = [],\n\t\t\t    i = 0,\n\t\t\t    len = unmatched.length,\n\t\t\t    mapped = map != null;\n\n\t\t\tfor (; i < len; i++) {\n\t\t\t\tif (elem = unmatched[i]) {\n\t\t\t\t\tif (!filter || filter(elem, context, xml)) {\n\t\t\t\t\t\tnewUnmatched.push(elem);\n\t\t\t\t\t\tif (mapped) {\n\t\t\t\t\t\t\tmap.push(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn newUnmatched;\n\t\t}\n\n\t\tfunction setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {\n\t\t\tif (postFilter && !postFilter[expando]) {\n\t\t\t\tpostFilter = setMatcher(postFilter);\n\t\t\t}\n\t\t\tif (postFinder && !postFinder[expando]) {\n\t\t\t\tpostFinder = setMatcher(postFinder, postSelector);\n\t\t\t}\n\t\t\treturn markFunction(function (seed, results, context, xml) {\n\t\t\t\tvar temp,\n\t\t\t\t    i,\n\t\t\t\t    elem,\n\t\t\t\t    preMap = [],\n\t\t\t\t    postMap = [],\n\t\t\t\t    preexisting = results.length,\n\n\n\t\t\t\t// Get initial elements from seed or context\n\t\t\t\telems = seed || multipleContexts(selector || \"*\", context.nodeType ? [context] : context, []),\n\n\n\t\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n\t\t\t\tmatcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,\n\t\t\t\t    matcherOut = matcher ?\n\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n\t\t\t\tpostFinder || (seed ? preFilter : preexisting || postFilter) ?\n\n\t\t\t\t// ...intermediate processing is necessary\n\t\t\t\t[] :\n\n\t\t\t\t// ...otherwise use results directly\n\t\t\t\tresults : matcherIn;\n\n\t\t\t\t// Find primary matches\n\t\t\t\tif (matcher) {\n\t\t\t\t\tmatcher(matcherIn, matcherOut, context, xml);\n\t\t\t\t}\n\n\t\t\t\t// Apply postFilter\n\t\t\t\tif (postFilter) {\n\t\t\t\t\ttemp = condense(matcherOut, postMap);\n\t\t\t\t\tpostFilter(temp, [], context, xml);\n\n\t\t\t\t\t// Un-match failing elements by moving them back to matcherIn\n\t\t\t\t\ti = temp.length;\n\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\tif (elem = temp[i]) {\n\t\t\t\t\t\t\tmatcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (seed) {\n\t\t\t\t\tif (postFinder || preFilter) {\n\t\t\t\t\t\tif (postFinder) {\n\t\t\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n\t\t\t\t\t\t\ttemp = [];\n\t\t\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\t\t\tif (elem = matcherOut[i]) {\n\t\t\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n\t\t\t\t\t\t\t\t\ttemp.push(matcherIn[i] = elem);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpostFinder(null, matcherOut = [], temp, xml);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n\t\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\t\tif ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {\n\n\t\t\t\t\t\t\t\tseed[temp] = !(results[temp] = elem);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Add elements to results, through postFinder if defined\n\t\t\t\t} else {\n\t\t\t\t\tmatcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);\n\t\t\t\t\tif (postFinder) {\n\t\t\t\t\t\tpostFinder(null, results, matcherOut, xml);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpush.apply(results, matcherOut);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tfunction matcherFromTokens(tokens) {\n\t\t\tvar checkContext,\n\t\t\t    matcher,\n\t\t\t    j,\n\t\t\t    len = tokens.length,\n\t\t\t    leadingRelative = Expr.relative[tokens[0].type],\n\t\t\t    implicitRelative = leadingRelative || Expr.relative[\" \"],\n\t\t\t    i = leadingRelative ? 1 : 0,\n\n\n\t\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n\t\t\tmatchContext = addCombinator(function (elem) {\n\t\t\t\treturn elem === checkContext;\n\t\t\t}, implicitRelative, true),\n\t\t\t    matchAnyContext = addCombinator(function (elem) {\n\t\t\t\treturn indexOf(checkContext, elem) > -1;\n\t\t\t}, implicitRelative, true),\n\t\t\t    matchers = [function (elem, context, xml) {\n\t\t\t\tvar ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));\n\t\t\t\t// Avoid hanging onto element (issue #299)\n\t\t\t\tcheckContext = null;\n\t\t\t\treturn ret;\n\t\t\t}];\n\n\t\t\tfor (; i < len; i++) {\n\t\t\t\tif (matcher = Expr.relative[tokens[i].type]) {\n\t\t\t\t\tmatchers = [addCombinator(elementMatcher(matchers), matcher)];\n\t\t\t\t} else {\n\t\t\t\t\tmatcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);\n\n\t\t\t\t\t// Return special upon seeing a positional matcher\n\t\t\t\t\tif (matcher[expando]) {\n\t\t\t\t\t\t// Find the next relative operator (if any) for proper handling\n\t\t\t\t\t\tj = ++i;\n\t\t\t\t\t\tfor (; j < len; j++) {\n\t\t\t\t\t\t\tif (Expr.relative[tokens[j].type]) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(\n\t\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n\t\t\t\t\t\ttokens.slice(0, i - 1).concat({ value: tokens[i - 2].type === \" \" ? \"*\" : \"\" })).replace(rtrim, \"$1\"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));\n\t\t\t\t\t}\n\t\t\t\t\tmatchers.push(matcher);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn elementMatcher(matchers);\n\t\t}\n\n\t\tfunction matcherFromGroupMatchers(elementMatchers, setMatchers) {\n\t\t\tvar bySet = setMatchers.length > 0,\n\t\t\t    byElement = elementMatchers.length > 0,\n\t\t\t    superMatcher = function superMatcher(seed, context, xml, results, outermost) {\n\t\t\t\tvar elem,\n\t\t\t\t    j,\n\t\t\t\t    matcher,\n\t\t\t\t    matchedCount = 0,\n\t\t\t\t    i = \"0\",\n\t\t\t\t    unmatched = seed && [],\n\t\t\t\t    setMatched = [],\n\t\t\t\t    contextBackup = outermostContext,\n\n\t\t\t\t// We must always have either seed elements or outermost context\n\t\t\t\telems = seed || byElement && Expr.find[\"TAG\"](\"*\", outermost),\n\n\t\t\t\t// Use integer dirruns iff this is the outermost matcher\n\t\t\t\tdirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1,\n\t\t\t\t    len = elems.length;\n\n\t\t\t\tif (outermost) {\n\t\t\t\t\toutermostContext = context !== document && context;\n\t\t\t\t}\n\n\t\t\t\t// Add elements passing elementMatchers directly to results\n\t\t\t\t// Keep `i` a string if there are no elements so `matchedCount` will be \"00\" below\n\t\t\t\t// Support: IE<9, Safari\n\t\t\t\t// Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n\t\t\t\tfor (; i !== len && (elem = elems[i]) != null; i++) {\n\t\t\t\t\tif (byElement && elem) {\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\t\twhile (matcher = elementMatchers[j++]) {\n\t\t\t\t\t\t\tif (matcher(elem, context, xml)) {\n\t\t\t\t\t\t\t\tresults.push(elem);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (outermost) {\n\t\t\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Track unmatched elements for set filters\n\t\t\t\t\tif (bySet) {\n\t\t\t\t\t\t// They will have gone through all possible matchers\n\t\t\t\t\t\tif (elem = !matcher && elem) {\n\t\t\t\t\t\t\tmatchedCount--;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Lengthen the array for every element, matched or not\n\t\t\t\t\t\tif (seed) {\n\t\t\t\t\t\t\tunmatched.push(elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Apply set filters to unmatched elements\n\t\t\t\tmatchedCount += i;\n\t\t\t\tif (bySet && i !== matchedCount) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile (matcher = setMatchers[j++]) {\n\t\t\t\t\t\tmatcher(unmatched, setMatched, context, xml);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (seed) {\n\t\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n\t\t\t\t\t\tif (matchedCount > 0) {\n\t\t\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\t\t\tif (!(unmatched[i] || setMatched[i])) {\n\t\t\t\t\t\t\t\t\tsetMatched[i] = pop.call(results);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Discard index placeholder values to get only actual matches\n\t\t\t\t\t\tsetMatched = condense(setMatched);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Add matches to results\n\t\t\t\t\tpush.apply(results, setMatched);\n\n\t\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n\t\t\t\t\tif (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {\n\n\t\t\t\t\t\tSizzle.uniqueSort(results);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Override manipulation of globals by nested matchers\n\t\t\t\tif (outermost) {\n\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\toutermostContext = contextBackup;\n\t\t\t\t}\n\n\t\t\t\treturn unmatched;\n\t\t\t};\n\n\t\t\treturn bySet ? markFunction(superMatcher) : superMatcher;\n\t\t}\n\n\t\tcompile = Sizzle.compile = function (selector, match /* Internal Use Only */) {\n\t\t\tvar i,\n\t\t\t    setMatchers = [],\n\t\t\t    elementMatchers = [],\n\t\t\t    cached = compilerCache[selector + \" \"];\n\n\t\t\tif (!cached) {\n\t\t\t\t// Generate a function of recursive functions that can be used to check each element\n\t\t\t\tif (!match) {\n\t\t\t\t\tmatch = tokenize(selector);\n\t\t\t\t}\n\t\t\t\ti = match.length;\n\t\t\t\twhile (i--) {\n\t\t\t\t\tcached = matcherFromTokens(match[i]);\n\t\t\t\t\tif (cached[expando]) {\n\t\t\t\t\t\tsetMatchers.push(cached);\n\t\t\t\t\t} else {\n\t\t\t\t\t\telementMatchers.push(cached);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Cache the compiled function\n\t\t\t\tcached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));\n\n\t\t\t\t// Save selector and tokenization\n\t\t\t\tcached.selector = selector;\n\t\t\t}\n\t\t\treturn cached;\n\t\t};\n\n\t\t/**\n   * A low-level selection function that works with Sizzle's compiled\n   *  selector functions\n   * @param {String|Function} selector A selector or a pre-compiled\n   *  selector function built with Sizzle.compile\n   * @param {Element} context\n   * @param {Array} [results]\n   * @param {Array} [seed] A set of elements to match against\n   */\n\t\tselect = Sizzle.select = function (selector, context, results, seed) {\n\t\t\tvar i,\n\t\t\t    tokens,\n\t\t\t    token,\n\t\t\t    type,\n\t\t\t    find,\n\t\t\t    compiled = typeof selector === \"function\" && selector,\n\t\t\t    match = !seed && tokenize(selector = compiled.selector || selector);\n\n\t\t\tresults = results || [];\n\n\t\t\t// Try to minimize operations if there is no seed and only one group\n\t\t\tif (match.length === 1) {\n\n\t\t\t\t// Take a shortcut and set the context if the root selector is an ID\n\t\t\t\ttokens = match[0] = match[0].slice(0);\n\t\t\t\tif (tokens.length > 2 && (token = tokens[0]).type === \"ID\" && support.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {\n\n\t\t\t\t\tcontext = (Expr.find[\"ID\"](token.matches[0].replace(runescape, funescape), context) || [])[0];\n\t\t\t\t\tif (!context) {\n\t\t\t\t\t\treturn results;\n\n\t\t\t\t\t\t// Precompiled matchers will still verify ancestry, so step up a level\n\t\t\t\t\t} else if (compiled) {\n\t\t\t\t\t\tcontext = context.parentNode;\n\t\t\t\t\t}\n\n\t\t\t\t\tselector = selector.slice(tokens.shift().value.length);\n\t\t\t\t}\n\n\t\t\t\t// Fetch a seed set for right-to-left matching\n\t\t\t\ti = matchExpr[\"needsContext\"].test(selector) ? 0 : tokens.length;\n\t\t\t\twhile (i--) {\n\t\t\t\t\ttoken = tokens[i];\n\n\t\t\t\t\t// Abort if we hit a combinator\n\t\t\t\t\tif (Expr.relative[type = token.type]) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (find = Expr.find[type]) {\n\t\t\t\t\t\t// Search, expanding context for leading sibling combinators\n\t\t\t\t\t\tif (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {\n\n\t\t\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n\t\t\t\t\t\t\ttokens.splice(i, 1);\n\t\t\t\t\t\t\tselector = seed.length && toSelector(tokens);\n\t\t\t\t\t\t\tif (!selector) {\n\t\t\t\t\t\t\t\tpush.apply(results, seed);\n\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Compile and execute a filtering function if one is not provided\n\t\t\t// Provide `match` to avoid retokenization if we modified the selector above\n\t\t\t(compiled || compile(selector, match))(seed, context, !documentIsHTML, results, rsibling.test(selector) && testContext(context.parentNode) || context);\n\t\t\treturn results;\n\t\t};\n\n\t\t// One-time assignments\n\n\t\t// Sort stability\n\t\tsupport.sortStable = expando.split(\"\").sort(sortOrder).join(\"\") === expando;\n\n\t\t// Support: Chrome 14-35+\n\t\t// Always assume duplicates if they aren't passed to the comparison function\n\t\tsupport.detectDuplicates = !!hasDuplicate;\n\n\t\t// Initialize against the default document\n\t\tsetDocument();\n\n\t\t// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n\t\t// Detached nodes confoundingly follow *each other*\n\t\tsupport.sortDetached = assert(function (div1) {\n\t\t\t// Should return 1, but returns 4 (following)\n\t\t\treturn div1.compareDocumentPosition(document.createElement(\"div\")) & 1;\n\t\t});\n\n\t\t// Support: IE<8\n\t\t// Prevent attribute/property \"interpolation\"\n\t\t// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\n\t\tif (!assert(function (div) {\n\t\t\tdiv.innerHTML = \"<a href='#'></a>\";\n\t\t\treturn div.firstChild.getAttribute(\"href\") === \"#\";\n\t\t})) {\n\t\t\taddHandle(\"type|href|height|width\", function (elem, name, isXML) {\n\t\t\t\tif (!isXML) {\n\t\t\t\t\treturn elem.getAttribute(name, name.toLowerCase() === \"type\" ? 1 : 2);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// Support: IE<9\n\t\t// Use defaultValue in place of getAttribute(\"value\")\n\t\tif (!support.attributes || !assert(function (div) {\n\t\t\tdiv.innerHTML = \"<input/>\";\n\t\t\tdiv.firstChild.setAttribute(\"value\", \"\");\n\t\t\treturn div.firstChild.getAttribute(\"value\") === \"\";\n\t\t})) {\n\t\t\taddHandle(\"value\", function (elem, name, isXML) {\n\t\t\t\tif (!isXML && elem.nodeName.toLowerCase() === \"input\") {\n\t\t\t\t\treturn elem.defaultValue;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// Support: IE<9\n\t\t// Use getAttributeNode to fetch booleans when getAttribute lies\n\t\tif (!assert(function (div) {\n\t\t\treturn div.getAttribute(\"disabled\") == null;\n\t\t})) {\n\t\t\taddHandle(booleans, function (elem, name, isXML) {\n\t\t\t\tvar val;\n\t\t\t\tif (!isXML) {\n\t\t\t\t\treturn elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn Sizzle;\n\t}(window);\n\n\tjQuery.find = Sizzle;\n\tjQuery.expr = Sizzle.selectors;\n\tjQuery.expr[\":\"] = jQuery.expr.pseudos;\n\tjQuery.unique = Sizzle.uniqueSort;\n\tjQuery.text = Sizzle.getText;\n\tjQuery.isXMLDoc = Sizzle.isXML;\n\tjQuery.contains = Sizzle.contains;\n\n\tvar rneedsContext = jQuery.expr.match.needsContext;\n\n\tvar rsingleTag = /^<(\\w+)\\s*\\/?>(?:<\\/\\1>|)$/;\n\n\tvar risSimple = /^.[^:#\\[\\.,]*$/;\n\n\t// Implement the identical functionality for filter and not\n\tfunction winnow(elements, qualifier, not) {\n\t\tif (jQuery.isFunction(qualifier)) {\n\t\t\treturn jQuery.grep(elements, function (elem, i) {\n\t\t\t\t/* jshint -W018 */\n\t\t\t\treturn !!qualifier.call(elem, i, elem) !== not;\n\t\t\t});\n\t\t}\n\n\t\tif (qualifier.nodeType) {\n\t\t\treturn jQuery.grep(elements, function (elem) {\n\t\t\t\treturn elem === qualifier !== not;\n\t\t\t});\n\t\t}\n\n\t\tif (typeof qualifier === \"string\") {\n\t\t\tif (risSimple.test(qualifier)) {\n\t\t\t\treturn jQuery.filter(qualifier, elements, not);\n\t\t\t}\n\n\t\t\tqualifier = jQuery.filter(qualifier, elements);\n\t\t}\n\n\t\treturn jQuery.grep(elements, function (elem) {\n\t\t\treturn indexOf.call(qualifier, elem) >= 0 !== not;\n\t\t});\n\t}\n\n\tjQuery.filter = function (expr, elems, not) {\n\t\tvar elem = elems[0];\n\n\t\tif (not) {\n\t\t\texpr = \":not(\" + expr + \")\";\n\t\t}\n\n\t\treturn elems.length === 1 && elem.nodeType === 1 ? jQuery.find.matchesSelector(elem, expr) ? [elem] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {\n\t\t\treturn elem.nodeType === 1;\n\t\t}));\n\t};\n\n\tjQuery.fn.extend({\n\t\tfind: function find(selector) {\n\t\t\tvar i,\n\t\t\t    len = this.length,\n\t\t\t    ret = [],\n\t\t\t    self = this;\n\n\t\t\tif (typeof selector !== \"string\") {\n\t\t\t\treturn this.pushStack(jQuery(selector).filter(function () {\n\t\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\t\tif (jQuery.contains(self[i], this)) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}));\n\t\t\t}\n\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tjQuery.find(selector, self[i], ret);\n\t\t\t}\n\n\t\t\t// Needed because $( selector, context ) becomes $( context ).find( selector )\n\t\t\tret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);\n\t\t\tret.selector = this.selector ? this.selector + \" \" + selector : selector;\n\t\t\treturn ret;\n\t\t},\n\t\tfilter: function filter(selector) {\n\t\t\treturn this.pushStack(winnow(this, selector || [], false));\n\t\t},\n\t\tnot: function not(selector) {\n\t\t\treturn this.pushStack(winnow(this, selector || [], true));\n\t\t},\n\t\tis: function is(selector) {\n\t\t\treturn !!winnow(this,\n\n\t\t\t// If this is a positional/relative selector, check membership in the returned set\n\t\t\t// so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n\t\t\ttypeof selector === \"string\" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;\n\t\t}\n\t});\n\n\t// Initialize a jQuery object\n\n\n\t// A central reference to the root jQuery(document)\n\tvar rootjQuery,\n\n\n\t// A simple way to check for HTML strings\n\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n\t// Strict HTML recognition (#11290: must start with <)\n\trquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]*))$/,\n\t    init = jQuery.fn.init = function (selector, context) {\n\t\tvar match, elem;\n\n\t\t// HANDLE: $(\"\"), $(null), $(undefined), $(false)\n\t\tif (!selector) {\n\t\t\treturn this;\n\t\t}\n\n\t\t// Handle HTML strings\n\t\tif (typeof selector === \"string\") {\n\t\t\tif (selector[0] === \"<\" && selector[selector.length - 1] === \">\" && selector.length >= 3) {\n\t\t\t\t// Assume that strings that start and end with <> are HTML and skip the regex check\n\t\t\t\tmatch = [null, selector, null];\n\t\t\t} else {\n\t\t\t\tmatch = rquickExpr.exec(selector);\n\t\t\t}\n\n\t\t\t// Match html or make sure no context is specified for #id\n\t\t\tif (match && (match[1] || !context)) {\n\n\t\t\t\t// HANDLE: $(html) -> $(array)\n\t\t\t\tif (match[1]) {\n\t\t\t\t\tcontext = context instanceof jQuery ? context[0] : context;\n\n\t\t\t\t\t// Option to run scripts is true for back-compat\n\t\t\t\t\t// Intentionally let the error be thrown if parseHTML is not present\n\t\t\t\t\tjQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));\n\n\t\t\t\t\t// HANDLE: $(html, props)\n\t\t\t\t\tif (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {\n\t\t\t\t\t\tfor (match in context) {\n\t\t\t\t\t\t\t// Properties of context are called as methods if possible\n\t\t\t\t\t\t\tif (jQuery.isFunction(this[match])) {\n\t\t\t\t\t\t\t\tthis[match](context[match]);\n\n\t\t\t\t\t\t\t\t// ...and otherwise set as attributes\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.attr(match, context[match]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this;\n\n\t\t\t\t\t// HANDLE: $(#id)\n\t\t\t\t} else {\n\t\t\t\t\telem = document.getElementById(match[2]);\n\n\t\t\t\t\t// Support: Blackberry 4.6\n\t\t\t\t\t// gEBID returns nodes no longer in the document (#6963)\n\t\t\t\t\tif (elem && elem.parentNode) {\n\t\t\t\t\t\t// Inject the element directly into the jQuery object\n\t\t\t\t\t\tthis.length = 1;\n\t\t\t\t\t\tthis[0] = elem;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.context = document;\n\t\t\t\t\tthis.selector = selector;\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t\t// HANDLE: $(expr, $(...))\n\t\t\t} else if (!context || context.jquery) {\n\t\t\t\treturn (context || rootjQuery).find(selector);\n\n\t\t\t\t// HANDLE: $(expr, context)\n\t\t\t\t// (which is just equivalent to: $(context).find(expr)\n\t\t\t} else {\n\t\t\t\treturn this.constructor(context).find(selector);\n\t\t\t}\n\n\t\t\t// HANDLE: $(DOMElement)\n\t\t} else if (selector.nodeType) {\n\t\t\tthis.context = this[0] = selector;\n\t\t\tthis.length = 1;\n\t\t\treturn this;\n\n\t\t\t// HANDLE: $(function)\n\t\t\t// Shortcut for document ready\n\t\t} else if (jQuery.isFunction(selector)) {\n\t\t\treturn typeof rootjQuery.ready !== \"undefined\" ? rootjQuery.ready(selector) :\n\t\t\t// Execute immediately if ready is not present\n\t\t\tselector(jQuery);\n\t\t}\n\n\t\tif (selector.selector !== undefined) {\n\t\t\tthis.selector = selector.selector;\n\t\t\tthis.context = selector.context;\n\t\t}\n\n\t\treturn jQuery.makeArray(selector, this);\n\t};\n\n\t// Give the init function the jQuery prototype for later instantiation\n\tinit.prototype = jQuery.fn;\n\n\t// Initialize central reference\n\trootjQuery = jQuery(document);\n\n\tvar rparentsprev = /^(?:parents|prev(?:Until|All))/,\n\n\t// Methods guaranteed to produce a unique set when starting from a unique set\n\tguaranteedUnique = {\n\t\tchildren: true,\n\t\tcontents: true,\n\t\tnext: true,\n\t\tprev: true\n\t};\n\n\tjQuery.extend({\n\t\tdir: function dir(elem, _dir, until) {\n\t\t\tvar matched = [],\n\t\t\t    truncate = until !== undefined;\n\n\t\t\twhile ((elem = elem[_dir]) && elem.nodeType !== 9) {\n\t\t\t\tif (elem.nodeType === 1) {\n\t\t\t\t\tif (truncate && jQuery(elem).is(until)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tmatched.push(elem);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn matched;\n\t\t},\n\n\t\tsibling: function sibling(n, elem) {\n\t\t\tvar matched = [];\n\n\t\t\tfor (; n; n = n.nextSibling) {\n\t\t\t\tif (n.nodeType === 1 && n !== elem) {\n\t\t\t\t\tmatched.push(n);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn matched;\n\t\t}\n\t});\n\n\tjQuery.fn.extend({\n\t\thas: function has(target) {\n\t\t\tvar targets = jQuery(target, this),\n\t\t\t    l = targets.length;\n\n\t\t\treturn this.filter(function () {\n\t\t\t\tvar i = 0;\n\t\t\t\tfor (; i < l; i++) {\n\t\t\t\t\tif (jQuery.contains(this, targets[i])) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\tclosest: function closest(selectors, context) {\n\t\t\tvar cur,\n\t\t\t    i = 0,\n\t\t\t    l = this.length,\n\t\t\t    matched = [],\n\t\t\t    pos = rneedsContext.test(selectors) || typeof selectors !== \"string\" ? jQuery(selectors, context || this.context) : 0;\n\n\t\t\tfor (; i < l; i++) {\n\t\t\t\tfor (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {\n\t\t\t\t\t// Always skip document fragments\n\t\t\t\t\tif (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 :\n\n\t\t\t\t\t// Don't pass non-elements to Sizzle\n\t\t\t\t\tcur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {\n\n\t\t\t\t\t\tmatched.push(cur);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this.pushStack(matched.length > 1 ? jQuery.unique(matched) : matched);\n\t\t},\n\n\t\t// Determine the position of an element within the set\n\t\tindex: function index(elem) {\n\n\t\t\t// No argument, return index in parent\n\t\t\tif (!elem) {\n\t\t\t\treturn this[0] && this[0].parentNode ? this.first().prevAll().length : -1;\n\t\t\t}\n\n\t\t\t// Index in selector\n\t\t\tif (typeof elem === \"string\") {\n\t\t\t\treturn indexOf.call(jQuery(elem), this[0]);\n\t\t\t}\n\n\t\t\t// Locate the position of the desired element\n\t\t\treturn indexOf.call(this,\n\n\t\t\t// If it receives a jQuery object, the first element is used\n\t\t\telem.jquery ? elem[0] : elem);\n\t\t},\n\n\t\tadd: function add(selector, context) {\n\t\t\treturn this.pushStack(jQuery.unique(jQuery.merge(this.get(), jQuery(selector, context))));\n\t\t},\n\n\t\taddBack: function addBack(selector) {\n\t\t\treturn this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));\n\t\t}\n\t});\n\n\tfunction sibling(cur, dir) {\n\t\twhile ((cur = cur[dir]) && cur.nodeType !== 1) {}\n\t\treturn cur;\n\t}\n\n\tjQuery.each({\n\t\tparent: function parent(elem) {\n\t\t\tvar parent = elem.parentNode;\n\t\t\treturn parent && parent.nodeType !== 11 ? parent : null;\n\t\t},\n\t\tparents: function parents(elem) {\n\t\t\treturn jQuery.dir(elem, \"parentNode\");\n\t\t},\n\t\tparentsUntil: function parentsUntil(elem, i, until) {\n\t\t\treturn jQuery.dir(elem, \"parentNode\", until);\n\t\t},\n\t\tnext: function next(elem) {\n\t\t\treturn sibling(elem, \"nextSibling\");\n\t\t},\n\t\tprev: function prev(elem) {\n\t\t\treturn sibling(elem, \"previousSibling\");\n\t\t},\n\t\tnextAll: function nextAll(elem) {\n\t\t\treturn jQuery.dir(elem, \"nextSibling\");\n\t\t},\n\t\tprevAll: function prevAll(elem) {\n\t\t\treturn jQuery.dir(elem, \"previousSibling\");\n\t\t},\n\t\tnextUntil: function nextUntil(elem, i, until) {\n\t\t\treturn jQuery.dir(elem, \"nextSibling\", until);\n\t\t},\n\t\tprevUntil: function prevUntil(elem, i, until) {\n\t\t\treturn jQuery.dir(elem, \"previousSibling\", until);\n\t\t},\n\t\tsiblings: function siblings(elem) {\n\t\t\treturn jQuery.sibling((elem.parentNode || {}).firstChild, elem);\n\t\t},\n\t\tchildren: function children(elem) {\n\t\t\treturn jQuery.sibling(elem.firstChild);\n\t\t},\n\t\tcontents: function contents(elem) {\n\t\t\treturn elem.contentDocument || jQuery.merge([], elem.childNodes);\n\t\t}\n\t}, function (name, fn) {\n\t\tjQuery.fn[name] = function (until, selector) {\n\t\t\tvar matched = jQuery.map(this, fn, until);\n\n\t\t\tif (name.slice(-5) !== \"Until\") {\n\t\t\t\tselector = until;\n\t\t\t}\n\n\t\t\tif (selector && typeof selector === \"string\") {\n\t\t\t\tmatched = jQuery.filter(selector, matched);\n\t\t\t}\n\n\t\t\tif (this.length > 1) {\n\t\t\t\t// Remove duplicates\n\t\t\t\tif (!guaranteedUnique[name]) {\n\t\t\t\t\tjQuery.unique(matched);\n\t\t\t\t}\n\n\t\t\t\t// Reverse order for parents* and prev-derivatives\n\t\t\t\tif (rparentsprev.test(name)) {\n\t\t\t\t\tmatched.reverse();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this.pushStack(matched);\n\t\t};\n\t});\n\tvar rnotwhite = /\\S+/g;\n\n\t// String to Object options format cache\n\tvar optionsCache = {};\n\n\t// Convert String-formatted options into Object-formatted ones and store in cache\n\tfunction createOptions(options) {\n\t\tvar object = optionsCache[options] = {};\n\t\tjQuery.each(options.match(rnotwhite) || [], function (_, flag) {\n\t\t\tobject[flag] = true;\n\t\t});\n\t\treturn object;\n\t}\n\n\t/*\n  * Create a callback list using the following parameters:\n  *\n  *\toptions: an optional list of space-separated options that will change how\n  *\t\t\tthe callback list behaves or a more traditional option object\n  *\n  * By default a callback list will act like an event callback list and can be\n  * \"fired\" multiple times.\n  *\n  * Possible options:\n  *\n  *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n  *\n  *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n  *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n  *\t\t\t\t\tvalues (like a Deferred)\n  *\n  *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n  *\n  *\tstopOnFalse:\tinterrupt callings when a callback returns false\n  *\n  */\n\tjQuery.Callbacks = function (options) {\n\n\t\t// Convert options from String-formatted to Object-formatted if needed\n\t\t// (we check in cache first)\n\t\toptions = typeof options === \"string\" ? optionsCache[options] || createOptions(options) : jQuery.extend({}, options);\n\n\t\tvar // Last fire value (for non-forgettable lists)\n\t\tmemory,\n\n\t\t// Flag to know if list was already fired\n\t\t_fired,\n\n\t\t// Flag to know if list is currently firing\n\t\tfiring,\n\n\t\t// First callback to fire (used internally by add and fireWith)\n\t\tfiringStart,\n\n\t\t// End of the loop when firing\n\t\tfiringLength,\n\n\t\t// Index of currently firing callback (modified by remove if needed)\n\t\tfiringIndex,\n\n\t\t// Actual callback list\n\t\tlist = [],\n\n\t\t// Stack of fire calls for repeatable lists\n\t\tstack = !options.once && [],\n\n\t\t// Fire callbacks\n\t\tfire = function fire(data) {\n\t\t\tmemory = options.memory && data;\n\t\t\t_fired = true;\n\t\t\tfiringIndex = firingStart || 0;\n\t\t\tfiringStart = 0;\n\t\t\tfiringLength = list.length;\n\t\t\tfiring = true;\n\t\t\tfor (; list && firingIndex < firingLength; firingIndex++) {\n\t\t\t\tif (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {\n\t\t\t\t\tmemory = false; // To prevent further calls using add\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfiring = false;\n\t\t\tif (list) {\n\t\t\t\tif (stack) {\n\t\t\t\t\tif (stack.length) {\n\t\t\t\t\t\tfire(stack.shift());\n\t\t\t\t\t}\n\t\t\t\t} else if (memory) {\n\t\t\t\t\tlist = [];\n\t\t\t\t} else {\n\t\t\t\t\tself.disable();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// Actual Callbacks object\n\t\tself = {\n\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\tadd: function add() {\n\t\t\t\tif (list) {\n\t\t\t\t\t// First, we save the current length\n\t\t\t\t\tvar start = list.length;\n\t\t\t\t\t(function add(args) {\n\t\t\t\t\t\tjQuery.each(args, function (_, arg) {\n\t\t\t\t\t\t\tvar type = jQuery.type(arg);\n\t\t\t\t\t\t\tif (type === \"function\") {\n\t\t\t\t\t\t\t\tif (!options.unique || !self.has(arg)) {\n\t\t\t\t\t\t\t\t\tlist.push(arg);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (arg && arg.length && type !== \"string\") {\n\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\tadd(arg);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t})(arguments);\n\t\t\t\t\t// Do we need to add the callbacks to the\n\t\t\t\t\t// current firing batch?\n\t\t\t\t\tif (firing) {\n\t\t\t\t\t\tfiringLength = list.length;\n\t\t\t\t\t\t// With memory, if we're not firing then\n\t\t\t\t\t\t// we should call right away\n\t\t\t\t\t} else if (memory) {\n\t\t\t\t\t\tfiringStart = start;\n\t\t\t\t\t\tfire(memory);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Remove a callback from the list\n\t\t\tremove: function remove() {\n\t\t\t\tif (list) {\n\t\t\t\t\tjQuery.each(arguments, function (_, arg) {\n\t\t\t\t\t\tvar index;\n\t\t\t\t\t\twhile ((index = jQuery.inArray(arg, list, index)) > -1) {\n\t\t\t\t\t\t\tlist.splice(index, 1);\n\t\t\t\t\t\t\t// Handle firing indexes\n\t\t\t\t\t\t\tif (firing) {\n\t\t\t\t\t\t\t\tif (index <= firingLength) {\n\t\t\t\t\t\t\t\t\tfiringLength--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (index <= firingIndex) {\n\t\t\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Check if a given callback is in the list.\n\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n\t\t\thas: function has(fn) {\n\t\t\t\treturn fn ? jQuery.inArray(fn, list) > -1 : !!(list && list.length);\n\t\t\t},\n\t\t\t// Remove all callbacks from the list\n\t\t\tempty: function empty() {\n\t\t\t\tlist = [];\n\t\t\t\tfiringLength = 0;\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Have the list do nothing anymore\n\t\t\tdisable: function disable() {\n\t\t\t\tlist = stack = memory = undefined;\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Is it disabled?\n\t\t\tdisabled: function disabled() {\n\t\t\t\treturn !list;\n\t\t\t},\n\t\t\t// Lock the list in its current state\n\t\t\tlock: function lock() {\n\t\t\t\tstack = undefined;\n\t\t\t\tif (!memory) {\n\t\t\t\t\tself.disable();\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Is it locked?\n\t\t\tlocked: function locked() {\n\t\t\t\treturn !stack;\n\t\t\t},\n\t\t\t// Call all callbacks with the given context and arguments\n\t\t\tfireWith: function fireWith(context, args) {\n\t\t\t\tif (list && (!_fired || stack)) {\n\t\t\t\t\targs = args || [];\n\t\t\t\t\targs = [context, args.slice ? args.slice() : args];\n\t\t\t\t\tif (firing) {\n\t\t\t\t\t\tstack.push(args);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfire(args);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Call all the callbacks with the given arguments\n\t\t\tfire: function fire() {\n\t\t\t\tself.fireWith(this, arguments);\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// To know if the callbacks have already been called at least once\n\t\t\tfired: function fired() {\n\t\t\t\treturn !!_fired;\n\t\t\t}\n\t\t};\n\n\t\treturn self;\n\t};\n\n\tjQuery.extend({\n\n\t\tDeferred: function Deferred(func) {\n\t\t\tvar tuples = [\n\t\t\t// action, add listener, listener list, final state\n\t\t\t[\"resolve\", \"done\", jQuery.Callbacks(\"once memory\"), \"resolved\"], [\"reject\", \"fail\", jQuery.Callbacks(\"once memory\"), \"rejected\"], [\"notify\", \"progress\", jQuery.Callbacks(\"memory\")]],\n\t\t\t    _state = \"pending\",\n\t\t\t    _promise = {\n\t\t\t\tstate: function state() {\n\t\t\t\t\treturn _state;\n\t\t\t\t},\n\t\t\t\talways: function always() {\n\t\t\t\t\tdeferred.done(arguments).fail(arguments);\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\tthen: function then() /* fnDone, fnFail, fnProgress */{\n\t\t\t\t\tvar fns = arguments;\n\t\t\t\t\treturn jQuery.Deferred(function (newDefer) {\n\t\t\t\t\t\tjQuery.each(tuples, function (i, tuple) {\n\t\t\t\t\t\t\tvar fn = jQuery.isFunction(fns[i]) && fns[i];\n\t\t\t\t\t\t\t// deferred[ done | fail | progress ] for forwarding actions to newDefer\n\t\t\t\t\t\t\tdeferred[tuple[1]](function () {\n\t\t\t\t\t\t\t\tvar returned = fn && fn.apply(this, arguments);\n\t\t\t\t\t\t\t\tif (returned && jQuery.isFunction(returned.promise)) {\n\t\t\t\t\t\t\t\t\treturned.promise().done(newDefer.resolve).fail(newDefer.reject).progress(newDefer.notify);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnewDefer[tuple[0] + \"With\"](this === _promise ? newDefer.promise() : this, fn ? [returned] : arguments);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t\tfns = null;\n\t\t\t\t\t}).promise();\n\t\t\t\t},\n\t\t\t\t// Get a promise for this deferred\n\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\t\tpromise: function promise(obj) {\n\t\t\t\t\treturn obj != null ? jQuery.extend(obj, _promise) : _promise;\n\t\t\t\t}\n\t\t\t},\n\t\t\t    deferred = {};\n\n\t\t\t// Keep pipe for back-compat\n\t\t\t_promise.pipe = _promise.then;\n\n\t\t\t// Add list-specific methods\n\t\t\tjQuery.each(tuples, function (i, tuple) {\n\t\t\t\tvar list = tuple[2],\n\t\t\t\t    stateString = tuple[3];\n\n\t\t\t\t// promise[ done | fail | progress ] = list.add\n\t\t\t\t_promise[tuple[1]] = list.add;\n\n\t\t\t\t// Handle state\n\t\t\t\tif (stateString) {\n\t\t\t\t\tlist.add(function () {\n\t\t\t\t\t\t// state = [ resolved | rejected ]\n\t\t\t\t\t\t_state = stateString;\n\n\t\t\t\t\t\t// [ reject_list | resolve_list ].disable; progress_list.lock\n\t\t\t\t\t}, tuples[i ^ 1][2].disable, tuples[2][2].lock);\n\t\t\t\t}\n\n\t\t\t\t// deferred[ resolve | reject | notify ]\n\t\t\t\tdeferred[tuple[0]] = function () {\n\t\t\t\t\tdeferred[tuple[0] + \"With\"](this === deferred ? _promise : this, arguments);\n\t\t\t\t\treturn this;\n\t\t\t\t};\n\t\t\t\tdeferred[tuple[0] + \"With\"] = list.fireWith;\n\t\t\t});\n\n\t\t\t// Make the deferred a promise\n\t\t\t_promise.promise(deferred);\n\n\t\t\t// Call given func if any\n\t\t\tif (func) {\n\t\t\t\tfunc.call(deferred, deferred);\n\t\t\t}\n\n\t\t\t// All done!\n\t\t\treturn deferred;\n\t\t},\n\n\t\t// Deferred helper\n\t\twhen: function when(subordinate /* , ..., subordinateN */) {\n\t\t\tvar i = 0,\n\t\t\t    resolveValues = _slice.call(arguments),\n\t\t\t    length = resolveValues.length,\n\n\n\t\t\t// the count of uncompleted subordinates\n\t\t\tremaining = length !== 1 || subordinate && jQuery.isFunction(subordinate.promise) ? length : 0,\n\n\n\t\t\t// the master Deferred. If resolveValues consist of only a single Deferred, just use that.\n\t\t\tdeferred = remaining === 1 ? subordinate : jQuery.Deferred(),\n\n\n\t\t\t// Update function for both resolve and progress values\n\t\t\tupdateFunc = function updateFunc(i, contexts, values) {\n\t\t\t\treturn function (value) {\n\t\t\t\t\tcontexts[i] = this;\n\t\t\t\t\tvalues[i] = arguments.length > 1 ? _slice.call(arguments) : value;\n\t\t\t\t\tif (values === progressValues) {\n\t\t\t\t\t\tdeferred.notifyWith(contexts, values);\n\t\t\t\t\t} else if (! --remaining) {\n\t\t\t\t\t\tdeferred.resolveWith(contexts, values);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t},\n\t\t\t    progressValues,\n\t\t\t    progressContexts,\n\t\t\t    resolveContexts;\n\n\t\t\t// Add listeners to Deferred subordinates; treat others as resolved\n\t\t\tif (length > 1) {\n\t\t\t\tprogressValues = new Array(length);\n\t\t\t\tprogressContexts = new Array(length);\n\t\t\t\tresolveContexts = new Array(length);\n\t\t\t\tfor (; i < length; i++) {\n\t\t\t\t\tif (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {\n\t\t\t\t\t\tresolveValues[i].promise().done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject).progress(updateFunc(i, progressContexts, progressValues));\n\t\t\t\t\t} else {\n\t\t\t\t\t\t--remaining;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If we're not waiting on anything, resolve the master\n\t\t\tif (!remaining) {\n\t\t\t\tdeferred.resolveWith(resolveContexts, resolveValues);\n\t\t\t}\n\n\t\t\treturn deferred.promise();\n\t\t}\n\t});\n\n\t// The deferred used on DOM ready\n\tvar readyList;\n\n\tjQuery.fn.ready = function (fn) {\n\t\t// Add the callback\n\t\tjQuery.ready.promise().done(fn);\n\n\t\treturn this;\n\t};\n\n\tjQuery.extend({\n\t\t// Is the DOM ready to be used? Set to true once it occurs.\n\t\tisReady: false,\n\n\t\t// A counter to track how many items to wait for before\n\t\t// the ready event fires. See #6781\n\t\treadyWait: 1,\n\n\t\t// Hold (or release) the ready event\n\t\tholdReady: function holdReady(hold) {\n\t\t\tif (hold) {\n\t\t\t\tjQuery.readyWait++;\n\t\t\t} else {\n\t\t\t\tjQuery.ready(true);\n\t\t\t}\n\t\t},\n\n\t\t// Handle when the DOM is ready\n\t\tready: function ready(wait) {\n\n\t\t\t// Abort if there are pending holds or we're already ready\n\t\t\tif (wait === true ? --jQuery.readyWait : jQuery.isReady) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Remember that the DOM is ready\n\t\t\tjQuery.isReady = true;\n\n\t\t\t// If a normal DOM Ready event fired, decrement, and wait if need be\n\t\t\tif (wait !== true && --jQuery.readyWait > 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If there are functions bound, to execute\n\t\t\treadyList.resolveWith(document, [jQuery]);\n\n\t\t\t// Trigger any bound ready events\n\t\t\tif (jQuery.fn.triggerHandler) {\n\t\t\t\tjQuery(document).triggerHandler(\"ready\");\n\t\t\t\tjQuery(document).off(\"ready\");\n\t\t\t}\n\t\t}\n\t});\n\n\t/**\n  * The ready event handler and self cleanup method\n  */\n\tfunction completed() {\n\t\tdocument.removeEventListener(\"DOMContentLoaded\", completed, false);\n\t\twindow.removeEventListener(\"load\", completed, false);\n\t\tjQuery.ready();\n\t}\n\n\tjQuery.ready.promise = function (obj) {\n\t\tif (!readyList) {\n\n\t\t\treadyList = jQuery.Deferred();\n\n\t\t\t// Catch cases where $(document).ready() is called after the browser event has already occurred.\n\t\t\t// We once tried to use readyState \"interactive\" here, but it caused issues like the one\n\t\t\t// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15\n\t\t\tif (document.readyState === \"complete\") {\n\t\t\t\t// Handle it asynchronously to allow scripts the opportunity to delay ready\n\t\t\t\tsetTimeout(jQuery.ready);\n\t\t\t} else {\n\n\t\t\t\t// Use the handy event callback\n\t\t\t\tdocument.addEventListener(\"DOMContentLoaded\", completed, false);\n\n\t\t\t\t// A fallback to window.onload, that will always work\n\t\t\t\twindow.addEventListener(\"load\", completed, false);\n\t\t\t}\n\t\t}\n\t\treturn readyList.promise(obj);\n\t};\n\n\t// Kick off the DOM ready check even if the user does not\n\tjQuery.ready.promise();\n\n\t// Multifunctional method to get and set values of a collection\n\t// The value/s can optionally be executed if it's a function\n\tvar access = jQuery.access = function (elems, fn, key, value, chainable, emptyGet, raw) {\n\t\tvar i = 0,\n\t\t    len = elems.length,\n\t\t    bulk = key == null;\n\n\t\t// Sets many values\n\t\tif (jQuery.type(key) === \"object\") {\n\t\t\tchainable = true;\n\t\t\tfor (i in key) {\n\t\t\t\tjQuery.access(elems, fn, i, key[i], true, emptyGet, raw);\n\t\t\t}\n\n\t\t\t// Sets one value\n\t\t} else if (value !== undefined) {\n\t\t\tchainable = true;\n\n\t\t\tif (!jQuery.isFunction(value)) {\n\t\t\t\traw = true;\n\t\t\t}\n\n\t\t\tif (bulk) {\n\t\t\t\t// Bulk operations run against the entire set\n\t\t\t\tif (raw) {\n\t\t\t\t\tfn.call(elems, value);\n\t\t\t\t\tfn = null;\n\n\t\t\t\t\t// ...except when executing function values\n\t\t\t\t} else {\n\t\t\t\t\tbulk = fn;\n\t\t\t\t\tfn = function fn(elem, key, value) {\n\t\t\t\t\t\treturn bulk.call(jQuery(elem), value);\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (fn) {\n\t\t\t\tfor (; i < len; i++) {\n\t\t\t\t\tfn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn chainable ? elems :\n\n\t\t// Gets\n\t\tbulk ? fn.call(elems) : len ? fn(elems[0], key) : emptyGet;\n\t};\n\n\t/**\n  * Determines whether an object can have data\n  */\n\tjQuery.acceptData = function (owner) {\n\t\t// Accepts only:\n\t\t//  - Node\n\t\t//    - Node.ELEMENT_NODE\n\t\t//    - Node.DOCUMENT_NODE\n\t\t//  - Object\n\t\t//    - Any\n\t\t/* jshint -W018 */\n\t\treturn owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;\n\t};\n\n\tfunction Data() {\n\t\t// Support: Android<4,\n\t\t// Old WebKit does not have Object.preventExtensions/freeze method,\n\t\t// return new empty object instead with no [[set]] accessor\n\t\tObject.defineProperty(this.cache = {}, 0, {\n\t\t\tget: function get() {\n\t\t\t\treturn {};\n\t\t\t}\n\t\t});\n\n\t\tthis.expando = jQuery.expando + Data.uid++;\n\t}\n\n\tData.uid = 1;\n\tData.accepts = jQuery.acceptData;\n\n\tData.prototype = {\n\t\tkey: function key(owner) {\n\t\t\t// We can accept data for non-element nodes in modern browsers,\n\t\t\t// but we should not, see #8335.\n\t\t\t// Always return the key for a frozen object.\n\t\t\tif (!Data.accepts(owner)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tvar descriptor = {},\n\n\t\t\t// Check if the owner object already has a cache key\n\t\t\tunlock = owner[this.expando];\n\n\t\t\t// If not, create one\n\t\t\tif (!unlock) {\n\t\t\t\tunlock = Data.uid++;\n\n\t\t\t\t// Secure it in a non-enumerable, non-writable property\n\t\t\t\ttry {\n\t\t\t\t\tdescriptor[this.expando] = { value: unlock };\n\t\t\t\t\tObject.defineProperties(owner, descriptor);\n\n\t\t\t\t\t// Support: Android<4\n\t\t\t\t\t// Fallback to a less secure definition\n\t\t\t\t} catch (e) {\n\t\t\t\t\tdescriptor[this.expando] = unlock;\n\t\t\t\t\tjQuery.extend(owner, descriptor);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Ensure the cache object\n\t\t\tif (!this.cache[unlock]) {\n\t\t\t\tthis.cache[unlock] = {};\n\t\t\t}\n\n\t\t\treturn unlock;\n\t\t},\n\t\tset: function set(owner, data, value) {\n\t\t\tvar prop,\n\n\t\t\t// There may be an unlock assigned to this node,\n\t\t\t// if there is no entry for this \"owner\", create one inline\n\t\t\t// and set the unlock as though an owner entry had always existed\n\t\t\tunlock = this.key(owner),\n\t\t\t    cache = this.cache[unlock];\n\n\t\t\t// Handle: [ owner, key, value ] args\n\t\t\tif (typeof data === \"string\") {\n\t\t\t\tcache[data] = value;\n\n\t\t\t\t// Handle: [ owner, { properties } ] args\n\t\t\t} else {\n\t\t\t\t// Fresh assignments by object are shallow copied\n\t\t\t\tif (jQuery.isEmptyObject(cache)) {\n\t\t\t\t\tjQuery.extend(this.cache[unlock], data);\n\t\t\t\t\t// Otherwise, copy the properties one-by-one to the cache object\n\t\t\t\t} else {\n\t\t\t\t\tfor (prop in data) {\n\t\t\t\t\t\tcache[prop] = data[prop];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn cache;\n\t\t},\n\t\tget: function get(owner, key) {\n\t\t\t// Either a valid cache is found, or will be created.\n\t\t\t// New caches will be created and the unlock returned,\n\t\t\t// allowing direct access to the newly created\n\t\t\t// empty data object. A valid owner object must be provided.\n\t\t\tvar cache = this.cache[this.key(owner)];\n\n\t\t\treturn key === undefined ? cache : cache[key];\n\t\t},\n\t\taccess: function access(owner, key, value) {\n\t\t\tvar stored;\n\t\t\t// In cases where either:\n\t\t\t//\n\t\t\t//   1. No key was specified\n\t\t\t//   2. A string key was specified, but no value provided\n\t\t\t//\n\t\t\t// Take the \"read\" path and allow the get method to determine\n\t\t\t// which value to return, respectively either:\n\t\t\t//\n\t\t\t//   1. The entire cache object\n\t\t\t//   2. The data stored at the key\n\t\t\t//\n\t\t\tif (key === undefined || key && typeof key === \"string\" && value === undefined) {\n\n\t\t\t\tstored = this.get(owner, key);\n\n\t\t\t\treturn stored !== undefined ? stored : this.get(owner, jQuery.camelCase(key));\n\t\t\t}\n\n\t\t\t// [*]When the key is not a string, or both a key and value\n\t\t\t// are specified, set or extend (existing objects) with either:\n\t\t\t//\n\t\t\t//   1. An object of properties\n\t\t\t//   2. A key and value\n\t\t\t//\n\t\t\tthis.set(owner, key, value);\n\n\t\t\t// Since the \"set\" path can have two possible entry points\n\t\t\t// return the expected data based on which path was taken[*]\n\t\t\treturn value !== undefined ? value : key;\n\t\t},\n\t\tremove: function remove(owner, key) {\n\t\t\tvar i,\n\t\t\t    name,\n\t\t\t    camel,\n\t\t\t    unlock = this.key(owner),\n\t\t\t    cache = this.cache[unlock];\n\n\t\t\tif (key === undefined) {\n\t\t\t\tthis.cache[unlock] = {};\n\t\t\t} else {\n\t\t\t\t// Support array or space separated string of keys\n\t\t\t\tif (jQuery.isArray(key)) {\n\t\t\t\t\t// If \"name\" is an array of keys...\n\t\t\t\t\t// When data is initially created, via (\"key\", \"val\") signature,\n\t\t\t\t\t// keys will be converted to camelCase.\n\t\t\t\t\t// Since there is no way to tell _how_ a key was added, remove\n\t\t\t\t\t// both plain key and camelCase key. #12786\n\t\t\t\t\t// This will only penalize the array argument path.\n\t\t\t\t\tname = key.concat(key.map(jQuery.camelCase));\n\t\t\t\t} else {\n\t\t\t\t\tcamel = jQuery.camelCase(key);\n\t\t\t\t\t// Try the string as a key before any manipulation\n\t\t\t\t\tif (key in cache) {\n\t\t\t\t\t\tname = [key, camel];\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// If a key with the spaces exists, use it.\n\t\t\t\t\t\t// Otherwise, create an array by matching non-whitespace\n\t\t\t\t\t\tname = camel;\n\t\t\t\t\t\tname = name in cache ? [name] : name.match(rnotwhite) || [];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\ti = name.length;\n\t\t\t\twhile (i--) {\n\t\t\t\t\tdelete cache[name[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\thasData: function hasData(owner) {\n\t\t\treturn !jQuery.isEmptyObject(this.cache[owner[this.expando]] || {});\n\t\t},\n\t\tdiscard: function discard(owner) {\n\t\t\tif (owner[this.expando]) {\n\t\t\t\tdelete this.cache[owner[this.expando]];\n\t\t\t}\n\t\t}\n\t};\n\tvar data_priv = new Data();\n\n\tvar data_user = new Data();\n\n\t//\tImplementation Summary\n\t//\n\t//\t1. Enforce API surface and semantic compatibility with 1.9.x branch\n\t//\t2. Improve the module's maintainability by reducing the storage\n\t//\t\tpaths to a single mechanism.\n\t//\t3. Use the same single mechanism to support \"private\" and \"user\" data.\n\t//\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\n\t//\t5. Avoid exposing implementation details on user objects (eg. expando properties)\n\t//\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\n\n\tvar rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n\t    rmultiDash = /([A-Z])/g;\n\n\tfunction dataAttr(elem, key, data) {\n\t\tvar name;\n\n\t\t// If nothing was found internally, try to fetch any\n\t\t// data from the HTML5 data-* attribute\n\t\tif (data === undefined && elem.nodeType === 1) {\n\t\t\tname = \"data-\" + key.replace(rmultiDash, \"-$1\").toLowerCase();\n\t\t\tdata = elem.getAttribute(name);\n\n\t\t\tif (typeof data === \"string\") {\n\t\t\t\ttry {\n\t\t\t\t\tdata = data === \"true\" ? true : data === \"false\" ? false : data === \"null\" ? null :\n\t\t\t\t\t// Only convert to a number if it doesn't change the string\n\t\t\t\t\t+data + \"\" === data ? +data : rbrace.test(data) ? jQuery.parseJSON(data) : data;\n\t\t\t\t} catch (e) {}\n\n\t\t\t\t// Make sure we set the data so it isn't changed later\n\t\t\t\tdata_user.set(elem, key, data);\n\t\t\t} else {\n\t\t\t\tdata = undefined;\n\t\t\t}\n\t\t}\n\t\treturn data;\n\t}\n\n\tjQuery.extend({\n\t\thasData: function hasData(elem) {\n\t\t\treturn data_user.hasData(elem) || data_priv.hasData(elem);\n\t\t},\n\n\t\tdata: function data(elem, name, _data) {\n\t\t\treturn data_user.access(elem, name, _data);\n\t\t},\n\n\t\tremoveData: function removeData(elem, name) {\n\t\t\tdata_user.remove(elem, name);\n\t\t},\n\n\t\t// TODO: Now that all calls to _data and _removeData have been replaced\n\t\t// with direct calls to data_priv methods, these can be deprecated.\n\t\t_data: function _data(elem, name, data) {\n\t\t\treturn data_priv.access(elem, name, data);\n\t\t},\n\n\t\t_removeData: function _removeData(elem, name) {\n\t\t\tdata_priv.remove(elem, name);\n\t\t}\n\t});\n\n\tjQuery.fn.extend({\n\t\tdata: function data(key, value) {\n\t\t\tvar i,\n\t\t\t    name,\n\t\t\t    data,\n\t\t\t    elem = this[0],\n\t\t\t    attrs = elem && elem.attributes;\n\n\t\t\t// Gets all values\n\t\t\tif (key === undefined) {\n\t\t\t\tif (this.length) {\n\t\t\t\t\tdata = data_user.get(elem);\n\n\t\t\t\t\tif (elem.nodeType === 1 && !data_priv.get(elem, \"hasDataAttrs\")) {\n\t\t\t\t\t\ti = attrs.length;\n\t\t\t\t\t\twhile (i--) {\n\n\t\t\t\t\t\t\t// Support: IE11+\n\t\t\t\t\t\t\t// The attrs elements can be null (#14894)\n\t\t\t\t\t\t\tif (attrs[i]) {\n\t\t\t\t\t\t\t\tname = attrs[i].name;\n\t\t\t\t\t\t\t\tif (name.indexOf(\"data-\") === 0) {\n\t\t\t\t\t\t\t\t\tname = jQuery.camelCase(name.slice(5));\n\t\t\t\t\t\t\t\t\tdataAttr(elem, name, data[name]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdata_priv.set(elem, \"hasDataAttrs\", true);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\t\t\t}\n\n\t\t\t// Sets multiple values\n\t\t\tif ((typeof key === \"undefined\" ? \"undefined\" : _typeof(key)) === \"object\") {\n\t\t\t\treturn this.each(function () {\n\t\t\t\t\tdata_user.set(this, key);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn access(this, function (value) {\n\t\t\t\tvar data,\n\t\t\t\t    camelKey = jQuery.camelCase(key);\n\n\t\t\t\t// The calling jQuery object (element matches) is not empty\n\t\t\t\t// (and therefore has an element appears at this[ 0 ]) and the\n\t\t\t\t// `value` parameter was not undefined. An empty jQuery object\n\t\t\t\t// will result in `undefined` for elem = this[ 0 ] which will\n\t\t\t\t// throw an exception if an attempt to read a data cache is made.\n\t\t\t\tif (elem && value === undefined) {\n\t\t\t\t\t// Attempt to get data from the cache\n\t\t\t\t\t// with the key as-is\n\t\t\t\t\tdata = data_user.get(elem, key);\n\t\t\t\t\tif (data !== undefined) {\n\t\t\t\t\t\treturn data;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Attempt to get data from the cache\n\t\t\t\t\t// with the key camelized\n\t\t\t\t\tdata = data_user.get(elem, camelKey);\n\t\t\t\t\tif (data !== undefined) {\n\t\t\t\t\t\treturn data;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Attempt to \"discover\" the data in\n\t\t\t\t\t// HTML5 custom data-* attrs\n\t\t\t\t\tdata = dataAttr(elem, camelKey, undefined);\n\t\t\t\t\tif (data !== undefined) {\n\t\t\t\t\t\treturn data;\n\t\t\t\t\t}\n\n\t\t\t\t\t// We tried really hard, but the data doesn't exist.\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Set the data...\n\t\t\t\tthis.each(function () {\n\t\t\t\t\t// First, attempt to store a copy or reference of any\n\t\t\t\t\t// data that might've been store with a camelCased key.\n\t\t\t\t\tvar data = data_user.get(this, camelKey);\n\n\t\t\t\t\t// For HTML5 data-* attribute interop, we have to\n\t\t\t\t\t// store property names with dashes in a camelCase form.\n\t\t\t\t\t// This might not apply to all properties...*\n\t\t\t\t\tdata_user.set(this, camelKey, value);\n\n\t\t\t\t\t// *... In the case of properties that might _actually_\n\t\t\t\t\t// have dashes, we need to also store a copy of that\n\t\t\t\t\t// unchanged property.\n\t\t\t\t\tif (key.indexOf(\"-\") !== -1 && data !== undefined) {\n\t\t\t\t\t\tdata_user.set(this, key, value);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}, null, value, arguments.length > 1, null, true);\n\t\t},\n\n\t\tremoveData: function removeData(key) {\n\t\t\treturn this.each(function () {\n\t\t\t\tdata_user.remove(this, key);\n\t\t\t});\n\t\t}\n\t});\n\n\tjQuery.extend({\n\t\tqueue: function queue(elem, type, data) {\n\t\t\tvar queue;\n\n\t\t\tif (elem) {\n\t\t\t\ttype = (type || \"fx\") + \"queue\";\n\t\t\t\tqueue = data_priv.get(elem, type);\n\n\t\t\t\t// Speed up dequeue by getting out quickly if this is just a lookup\n\t\t\t\tif (data) {\n\t\t\t\t\tif (!queue || jQuery.isArray(data)) {\n\t\t\t\t\t\tqueue = data_priv.access(elem, type, jQuery.makeArray(data));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tqueue.push(data);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn queue || [];\n\t\t\t}\n\t\t},\n\n\t\tdequeue: function dequeue(elem, type) {\n\t\t\ttype = type || \"fx\";\n\n\t\t\tvar queue = jQuery.queue(elem, type),\n\t\t\t    startLength = queue.length,\n\t\t\t    fn = queue.shift(),\n\t\t\t    hooks = jQuery._queueHooks(elem, type),\n\t\t\t    next = function next() {\n\t\t\t\tjQuery.dequeue(elem, type);\n\t\t\t};\n\n\t\t\t// If the fx queue is dequeued, always remove the progress sentinel\n\t\t\tif (fn === \"inprogress\") {\n\t\t\t\tfn = queue.shift();\n\t\t\t\tstartLength--;\n\t\t\t}\n\n\t\t\tif (fn) {\n\n\t\t\t\t// Add a progress sentinel to prevent the fx queue from being\n\t\t\t\t// automatically dequeued\n\t\t\t\tif (type === \"fx\") {\n\t\t\t\t\tqueue.unshift(\"inprogress\");\n\t\t\t\t}\n\n\t\t\t\t// Clear up the last queue stop function\n\t\t\t\tdelete hooks.stop;\n\t\t\t\tfn.call(elem, next, hooks);\n\t\t\t}\n\n\t\t\tif (!startLength && hooks) {\n\t\t\t\thooks.empty.fire();\n\t\t\t}\n\t\t},\n\n\t\t// Not public - generate a queueHooks object, or return the current one\n\t\t_queueHooks: function _queueHooks(elem, type) {\n\t\t\tvar key = type + \"queueHooks\";\n\t\t\treturn data_priv.get(elem, key) || data_priv.access(elem, key, {\n\t\t\t\tempty: jQuery.Callbacks(\"once memory\").add(function () {\n\t\t\t\t\tdata_priv.remove(elem, [type + \"queue\", key]);\n\t\t\t\t})\n\t\t\t});\n\t\t}\n\t});\n\n\tjQuery.fn.extend({\n\t\tqueue: function queue(type, data) {\n\t\t\tvar setter = 2;\n\n\t\t\tif (typeof type !== \"string\") {\n\t\t\t\tdata = type;\n\t\t\t\ttype = \"fx\";\n\t\t\t\tsetter--;\n\t\t\t}\n\n\t\t\tif (arguments.length < setter) {\n\t\t\t\treturn jQuery.queue(this[0], type);\n\t\t\t}\n\n\t\t\treturn data === undefined ? this : this.each(function () {\n\t\t\t\tvar queue = jQuery.queue(this, type, data);\n\n\t\t\t\t// Ensure a hooks for this queue\n\t\t\t\tjQuery._queueHooks(this, type);\n\n\t\t\t\tif (type === \"fx\" && queue[0] !== \"inprogress\") {\n\t\t\t\t\tjQuery.dequeue(this, type);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\tdequeue: function dequeue(type) {\n\t\t\treturn this.each(function () {\n\t\t\t\tjQuery.dequeue(this, type);\n\t\t\t});\n\t\t},\n\t\tclearQueue: function clearQueue(type) {\n\t\t\treturn this.queue(type || \"fx\", []);\n\t\t},\n\t\t// Get a promise resolved when queues of a certain type\n\t\t// are emptied (fx is the type by default)\n\t\tpromise: function promise(type, obj) {\n\t\t\tvar tmp,\n\t\t\t    count = 1,\n\t\t\t    defer = jQuery.Deferred(),\n\t\t\t    elements = this,\n\t\t\t    i = this.length,\n\t\t\t    resolve = function resolve() {\n\t\t\t\tif (! --count) {\n\t\t\t\t\tdefer.resolveWith(elements, [elements]);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tif (typeof type !== \"string\") {\n\t\t\t\tobj = type;\n\t\t\t\ttype = undefined;\n\t\t\t}\n\t\t\ttype = type || \"fx\";\n\n\t\t\twhile (i--) {\n\t\t\t\ttmp = data_priv.get(elements[i], type + \"queueHooks\");\n\t\t\t\tif (tmp && tmp.empty) {\n\t\t\t\t\tcount++;\n\t\t\t\t\ttmp.empty.add(resolve);\n\t\t\t\t}\n\t\t\t}\n\t\t\tresolve();\n\t\t\treturn defer.promise(obj);\n\t\t}\n\t});\n\tvar pnum = /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source;\n\n\tvar cssExpand = [\"Top\", \"Right\", \"Bottom\", \"Left\"];\n\n\tvar isHidden = function isHidden(elem, el) {\n\t\t// isHidden might be called from jQuery#filter function;\n\t\t// in that case, element will be second argument\n\t\telem = el || elem;\n\t\treturn jQuery.css(elem, \"display\") === \"none\" || !jQuery.contains(elem.ownerDocument, elem);\n\t};\n\n\tvar rcheckableType = /^(?:checkbox|radio)$/i;\n\n\t(function () {\n\t\tvar fragment = document.createDocumentFragment(),\n\t\t    div = fragment.appendChild(document.createElement(\"div\")),\n\t\t    input = document.createElement(\"input\");\n\n\t\t// Support: Safari<=5.1\n\t\t// Check state lost if the name is set (#11217)\n\t\t// Support: Windows Web Apps (WWA)\n\t\t// `name` and `type` must use .setAttribute for WWA (#14901)\n\t\tinput.setAttribute(\"type\", \"radio\");\n\t\tinput.setAttribute(\"checked\", \"checked\");\n\t\tinput.setAttribute(\"name\", \"t\");\n\n\t\tdiv.appendChild(input);\n\n\t\t// Support: Safari<=5.1, Android<4.2\n\t\t// Older WebKit doesn't clone checked state correctly in fragments\n\t\tsupport.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;\n\n\t\t// Support: IE<=11+\n\t\t// Make sure textarea (and checkbox) defaultValue is properly cloned\n\t\tdiv.innerHTML = \"<textarea>x</textarea>\";\n\t\tsupport.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;\n\t})();\n\tvar strundefined = typeof undefined === \"undefined\" ? \"undefined\" : _typeof(undefined);\n\n\tsupport.focusinBubbles = \"onfocusin\" in window;\n\n\tvar rkeyEvent = /^key/,\n\t    rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,\n\t    rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\n\t    rtypenamespace = /^([^.]*)(?:\\.(.+)|)$/;\n\n\tfunction returnTrue() {\n\t\treturn true;\n\t}\n\n\tfunction returnFalse() {\n\t\treturn false;\n\t}\n\n\tfunction safeActiveElement() {\n\t\ttry {\n\t\t\treturn document.activeElement;\n\t\t} catch (err) {}\n\t}\n\n\t/*\n  * Helper functions for managing events -- not part of the public interface.\n  * Props to Dean Edwards' addEvent library for many of the ideas.\n  */\n\tjQuery.event = {\n\n\t\tglobal: {},\n\n\t\tadd: function add(elem, types, handler, data, selector) {\n\n\t\t\tvar handleObjIn,\n\t\t\t    eventHandle,\n\t\t\t    tmp,\n\t\t\t    events,\n\t\t\t    t,\n\t\t\t    handleObj,\n\t\t\t    special,\n\t\t\t    handlers,\n\t\t\t    type,\n\t\t\t    namespaces,\n\t\t\t    origType,\n\t\t\t    elemData = data_priv.get(elem);\n\n\t\t\t// Don't attach events to noData or text/comment nodes (but allow plain objects)\n\t\t\tif (!elemData) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Caller can pass in an object of custom data in lieu of the handler\n\t\t\tif (handler.handler) {\n\t\t\t\thandleObjIn = handler;\n\t\t\t\thandler = handleObjIn.handler;\n\t\t\t\tselector = handleObjIn.selector;\n\t\t\t}\n\n\t\t\t// Make sure that the handler has a unique ID, used to find/remove it later\n\t\t\tif (!handler.guid) {\n\t\t\t\thandler.guid = jQuery.guid++;\n\t\t\t}\n\n\t\t\t// Init the element's event structure and main handler, if this is the first\n\t\t\tif (!(events = elemData.events)) {\n\t\t\t\tevents = elemData.events = {};\n\t\t\t}\n\t\t\tif (!(eventHandle = elemData.handle)) {\n\t\t\t\teventHandle = elemData.handle = function (e) {\n\t\t\t\t\t// Discard the second event of a jQuery.event.trigger() and\n\t\t\t\t\t// when an event is called after a page has unloaded\n\t\t\t\t\treturn (typeof jQuery === \"undefined\" ? \"undefined\" : _typeof(jQuery)) !== strundefined && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Handle multiple events separated by a space\n\t\t\ttypes = (types || \"\").match(rnotwhite) || [\"\"];\n\t\t\tt = types.length;\n\t\t\twhile (t--) {\n\t\t\t\ttmp = rtypenamespace.exec(types[t]) || [];\n\t\t\t\ttype = origType = tmp[1];\n\t\t\t\tnamespaces = (tmp[2] || \"\").split(\".\").sort();\n\n\t\t\t\t// There *must* be a type, no attaching namespace-only handlers\n\t\t\t\tif (!type) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// If event changes its type, use the special event handlers for the changed type\n\t\t\t\tspecial = jQuery.event.special[type] || {};\n\n\t\t\t\t// If selector defined, determine special event api type, otherwise given type\n\t\t\t\ttype = (selector ? special.delegateType : special.bindType) || type;\n\n\t\t\t\t// Update special based on newly reset type\n\t\t\t\tspecial = jQuery.event.special[type] || {};\n\n\t\t\t\t// handleObj is passed to all event handlers\n\t\t\t\thandleObj = jQuery.extend({\n\t\t\t\t\ttype: type,\n\t\t\t\t\torigType: origType,\n\t\t\t\t\tdata: data,\n\t\t\t\t\thandler: handler,\n\t\t\t\t\tguid: handler.guid,\n\t\t\t\t\tselector: selector,\n\t\t\t\t\tneedsContext: selector && jQuery.expr.match.needsContext.test(selector),\n\t\t\t\t\tnamespace: namespaces.join(\".\")\n\t\t\t\t}, handleObjIn);\n\n\t\t\t\t// Init the event handler queue if we're the first\n\t\t\t\tif (!(handlers = events[type])) {\n\t\t\t\t\thandlers = events[type] = [];\n\t\t\t\t\thandlers.delegateCount = 0;\n\n\t\t\t\t\t// Only use addEventListener if the special events handler returns false\n\t\t\t\t\tif (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {\n\t\t\t\t\t\tif (elem.addEventListener) {\n\t\t\t\t\t\t\telem.addEventListener(type, eventHandle, false);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (special.add) {\n\t\t\t\t\tspecial.add.call(elem, handleObj);\n\n\t\t\t\t\tif (!handleObj.handler.guid) {\n\t\t\t\t\t\thandleObj.handler.guid = handler.guid;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Add to the element's handler list, delegates in front\n\t\t\t\tif (selector) {\n\t\t\t\t\thandlers.splice(handlers.delegateCount++, 0, handleObj);\n\t\t\t\t} else {\n\t\t\t\t\thandlers.push(handleObj);\n\t\t\t\t}\n\n\t\t\t\t// Keep track of which events have ever been used, for event optimization\n\t\t\t\tjQuery.event.global[type] = true;\n\t\t\t}\n\t\t},\n\n\t\t// Detach an event or set of events from an element\n\t\tremove: function remove(elem, types, handler, selector, mappedTypes) {\n\n\t\t\tvar j,\n\t\t\t    origCount,\n\t\t\t    tmp,\n\t\t\t    events,\n\t\t\t    t,\n\t\t\t    handleObj,\n\t\t\t    special,\n\t\t\t    handlers,\n\t\t\t    type,\n\t\t\t    namespaces,\n\t\t\t    origType,\n\t\t\t    elemData = data_priv.hasData(elem) && data_priv.get(elem);\n\n\t\t\tif (!elemData || !(events = elemData.events)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Once for each type.namespace in types; type may be omitted\n\t\t\ttypes = (types || \"\").match(rnotwhite) || [\"\"];\n\t\t\tt = types.length;\n\t\t\twhile (t--) {\n\t\t\t\ttmp = rtypenamespace.exec(types[t]) || [];\n\t\t\t\ttype = origType = tmp[1];\n\t\t\t\tnamespaces = (tmp[2] || \"\").split(\".\").sort();\n\n\t\t\t\t// Unbind all events (on this namespace, if provided) for the element\n\t\t\t\tif (!type) {\n\t\t\t\t\tfor (type in events) {\n\t\t\t\t\t\tjQuery.event.remove(elem, type + types[t], handler, selector, true);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tspecial = jQuery.event.special[type] || {};\n\t\t\t\ttype = (selector ? special.delegateType : special.bindType) || type;\n\t\t\t\thandlers = events[type] || [];\n\t\t\t\ttmp = tmp[2] && new RegExp(\"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\");\n\n\t\t\t\t// Remove matching events\n\t\t\t\torigCount = j = handlers.length;\n\t\t\t\twhile (j--) {\n\t\t\t\t\thandleObj = handlers[j];\n\n\t\t\t\t\tif ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === \"**\" && handleObj.selector)) {\n\t\t\t\t\t\thandlers.splice(j, 1);\n\n\t\t\t\t\t\tif (handleObj.selector) {\n\t\t\t\t\t\t\thandlers.delegateCount--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (special.remove) {\n\t\t\t\t\t\t\tspecial.remove.call(elem, handleObj);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Remove generic event handler if we removed something and no more handlers exist\n\t\t\t\t// (avoids potential for endless recursion during removal of special event handlers)\n\t\t\t\tif (origCount && !handlers.length) {\n\t\t\t\t\tif (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {\n\t\t\t\t\t\tjQuery.removeEvent(elem, type, elemData.handle);\n\t\t\t\t\t}\n\n\t\t\t\t\tdelete events[type];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove the expando if it's no longer used\n\t\t\tif (jQuery.isEmptyObject(events)) {\n\t\t\t\tdelete elemData.handle;\n\t\t\t\tdata_priv.remove(elem, \"events\");\n\t\t\t}\n\t\t},\n\n\t\ttrigger: function trigger(event, data, elem, onlyHandlers) {\n\n\t\t\tvar i,\n\t\t\t    cur,\n\t\t\t    tmp,\n\t\t\t    bubbleType,\n\t\t\t    ontype,\n\t\t\t    handle,\n\t\t\t    special,\n\t\t\t    eventPath = [elem || document],\n\t\t\t    type = hasOwn.call(event, \"type\") ? event.type : event,\n\t\t\t    namespaces = hasOwn.call(event, \"namespace\") ? event.namespace.split(\".\") : [];\n\n\t\t\tcur = tmp = elem = elem || document;\n\n\t\t\t// Don't do events on text and comment nodes\n\t\t\tif (elem.nodeType === 3 || elem.nodeType === 8) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// focus/blur morphs to focusin/out; ensure we're not firing them right now\n\t\t\tif (rfocusMorph.test(type + jQuery.event.triggered)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (type.indexOf(\".\") >= 0) {\n\t\t\t\t// Namespaced trigger; create a regexp to match event type in handle()\n\t\t\t\tnamespaces = type.split(\".\");\n\t\t\t\ttype = namespaces.shift();\n\t\t\t\tnamespaces.sort();\n\t\t\t}\n\t\t\tontype = type.indexOf(\":\") < 0 && \"on\" + type;\n\n\t\t\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\n\t\t\tevent = event[jQuery.expando] ? event : new jQuery.Event(type, (typeof event === \"undefined\" ? \"undefined\" : _typeof(event)) === \"object\" && event);\n\n\t\t\t// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n\t\t\tevent.isTrigger = onlyHandlers ? 2 : 3;\n\t\t\tevent.namespace = namespaces.join(\".\");\n\t\t\tevent.namespace_re = event.namespace ? new RegExp(\"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\") : null;\n\n\t\t\t// Clean up the event in case it is being reused\n\t\t\tevent.result = undefined;\n\t\t\tif (!event.target) {\n\t\t\t\tevent.target = elem;\n\t\t\t}\n\n\t\t\t// Clone any incoming data and prepend the event, creating the handler arg list\n\t\t\tdata = data == null ? [event] : jQuery.makeArray(data, [event]);\n\n\t\t\t// Allow special events to draw outside the lines\n\t\t\tspecial = jQuery.event.special[type] || {};\n\t\t\tif (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Determine event propagation path in advance, per W3C events spec (#9951)\n\t\t\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n\t\t\tif (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {\n\n\t\t\t\tbubbleType = special.delegateType || type;\n\t\t\t\tif (!rfocusMorph.test(bubbleType + type)) {\n\t\t\t\t\tcur = cur.parentNode;\n\t\t\t\t}\n\t\t\t\tfor (; cur; cur = cur.parentNode) {\n\t\t\t\t\teventPath.push(cur);\n\t\t\t\t\ttmp = cur;\n\t\t\t\t}\n\n\t\t\t\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\n\t\t\t\tif (tmp === (elem.ownerDocument || document)) {\n\t\t\t\t\teventPath.push(tmp.defaultView || tmp.parentWindow || window);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Fire handlers on the event path\n\t\t\ti = 0;\n\t\t\twhile ((cur = eventPath[i++]) && !event.isPropagationStopped()) {\n\n\t\t\t\tevent.type = i > 1 ? bubbleType : special.bindType || type;\n\n\t\t\t\t// jQuery handler\n\t\t\t\thandle = (data_priv.get(cur, \"events\") || {})[event.type] && data_priv.get(cur, \"handle\");\n\t\t\t\tif (handle) {\n\t\t\t\t\thandle.apply(cur, data);\n\t\t\t\t}\n\n\t\t\t\t// Native handler\n\t\t\t\thandle = ontype && cur[ontype];\n\t\t\t\tif (handle && handle.apply && jQuery.acceptData(cur)) {\n\t\t\t\t\tevent.result = handle.apply(cur, data);\n\t\t\t\t\tif (event.result === false) {\n\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tevent.type = type;\n\n\t\t\t// If nobody prevented the default action, do it now\n\t\t\tif (!onlyHandlers && !event.isDefaultPrevented()) {\n\n\t\t\t\tif ((!special._default || special._default.apply(eventPath.pop(), data) === false) && jQuery.acceptData(elem)) {\n\n\t\t\t\t\t// Call a native DOM method on the target with the same name name as the event.\n\t\t\t\t\t// Don't do default actions on window, that's where global variables be (#6170)\n\t\t\t\t\tif (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {\n\n\t\t\t\t\t\t// Don't re-trigger an onFOO event when we call its FOO() method\n\t\t\t\t\t\ttmp = elem[ontype];\n\n\t\t\t\t\t\tif (tmp) {\n\t\t\t\t\t\t\telem[ontype] = null;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Prevent re-triggering of the same event, since we already bubbled it above\n\t\t\t\t\t\tjQuery.event.triggered = type;\n\t\t\t\t\t\telem[type]();\n\t\t\t\t\t\tjQuery.event.triggered = undefined;\n\n\t\t\t\t\t\tif (tmp) {\n\t\t\t\t\t\t\telem[ontype] = tmp;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn event.result;\n\t\t},\n\n\t\tdispatch: function dispatch(event) {\n\n\t\t\t// Make a writable jQuery.Event from the native event object\n\t\t\tevent = jQuery.event.fix(event);\n\n\t\t\tvar i,\n\t\t\t    j,\n\t\t\t    ret,\n\t\t\t    matched,\n\t\t\t    handleObj,\n\t\t\t    handlerQueue = [],\n\t\t\t    args = _slice.call(arguments),\n\t\t\t    handlers = (data_priv.get(this, \"events\") || {})[event.type] || [],\n\t\t\t    special = jQuery.event.special[event.type] || {};\n\n\t\t\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\n\t\t\targs[0] = event;\n\t\t\tevent.delegateTarget = this;\n\n\t\t\t// Call the preDispatch hook for the mapped type, and let it bail if desired\n\t\t\tif (special.preDispatch && special.preDispatch.call(this, event) === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Determine handlers\n\t\t\thandlerQueue = jQuery.event.handlers.call(this, event, handlers);\n\n\t\t\t// Run delegates first; they may want to stop propagation beneath us\n\t\t\ti = 0;\n\t\t\twhile ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {\n\t\t\t\tevent.currentTarget = matched.elem;\n\n\t\t\t\tj = 0;\n\t\t\t\twhile ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {\n\n\t\t\t\t\t// Triggered event must either 1) have no namespace, or 2) have namespace(s)\n\t\t\t\t\t// a subset or equal to those in the bound event (both can have no namespace).\n\t\t\t\t\tif (!event.namespace_re || event.namespace_re.test(handleObj.namespace)) {\n\n\t\t\t\t\t\tevent.handleObj = handleObj;\n\t\t\t\t\t\tevent.data = handleObj.data;\n\n\t\t\t\t\t\tret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);\n\n\t\t\t\t\t\tif (ret !== undefined) {\n\t\t\t\t\t\t\tif ((event.result = ret) === false) {\n\t\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Call the postDispatch hook for the mapped type\n\t\t\tif (special.postDispatch) {\n\t\t\t\tspecial.postDispatch.call(this, event);\n\t\t\t}\n\n\t\t\treturn event.result;\n\t\t},\n\n\t\thandlers: function handlers(event, _handlers) {\n\t\t\tvar i,\n\t\t\t    matches,\n\t\t\t    sel,\n\t\t\t    handleObj,\n\t\t\t    handlerQueue = [],\n\t\t\t    delegateCount = _handlers.delegateCount,\n\t\t\t    cur = event.target;\n\n\t\t\t// Find delegate handlers\n\t\t\t// Black-hole SVG <use> instance trees (#13180)\n\t\t\t// Avoid non-left-click bubbling in Firefox (#3861)\n\t\t\tif (delegateCount && cur.nodeType && (!event.button || event.type !== \"click\")) {\n\n\t\t\t\tfor (; cur !== this; cur = cur.parentNode || this) {\n\n\t\t\t\t\t// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\n\t\t\t\t\tif (cur.disabled !== true || event.type !== \"click\") {\n\t\t\t\t\t\tmatches = [];\n\t\t\t\t\t\tfor (i = 0; i < delegateCount; i++) {\n\t\t\t\t\t\t\thandleObj = _handlers[i];\n\n\t\t\t\t\t\t\t// Don't conflict with Object.prototype properties (#13203)\n\t\t\t\t\t\t\tsel = handleObj.selector + \" \";\n\n\t\t\t\t\t\t\tif (matches[sel] === undefined) {\n\t\t\t\t\t\t\t\tmatches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) >= 0 : jQuery.find(sel, this, null, [cur]).length;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (matches[sel]) {\n\t\t\t\t\t\t\t\tmatches.push(handleObj);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (matches.length) {\n\t\t\t\t\t\t\thandlerQueue.push({ elem: cur, handlers: matches });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add the remaining (directly-bound) handlers\n\t\t\tif (delegateCount < _handlers.length) {\n\t\t\t\thandlerQueue.push({ elem: this, handlers: _handlers.slice(delegateCount) });\n\t\t\t}\n\n\t\t\treturn handlerQueue;\n\t\t},\n\n\t\t// Includes some event props shared by KeyEvent and MouseEvent\n\t\tprops: \"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which\".split(\" \"),\n\n\t\tfixHooks: {},\n\n\t\tkeyHooks: {\n\t\t\tprops: \"char charCode key keyCode\".split(\" \"),\n\t\t\tfilter: function filter(event, original) {\n\n\t\t\t\t// Add which for key events\n\t\t\t\tif (event.which == null) {\n\t\t\t\t\tevent.which = original.charCode != null ? original.charCode : original.keyCode;\n\t\t\t\t}\n\n\t\t\t\treturn event;\n\t\t\t}\n\t\t},\n\n\t\tmouseHooks: {\n\t\t\tprops: \"button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement\".split(\" \"),\n\t\t\tfilter: function filter(event, original) {\n\t\t\t\tvar eventDoc,\n\t\t\t\t    doc,\n\t\t\t\t    body,\n\t\t\t\t    button = original.button;\n\n\t\t\t\t// Calculate pageX/Y if missing and clientX/Y available\n\t\t\t\tif (event.pageX == null && original.clientX != null) {\n\t\t\t\t\teventDoc = event.target.ownerDocument || document;\n\t\t\t\t\tdoc = eventDoc.documentElement;\n\t\t\t\t\tbody = eventDoc.body;\n\n\t\t\t\t\tevent.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);\n\t\t\t\t\tevent.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);\n\t\t\t\t}\n\n\t\t\t\t// Add which for click: 1 === left; 2 === middle; 3 === right\n\t\t\t\t// Note: button is not normalized, so don't use it\n\t\t\t\tif (!event.which && button !== undefined) {\n\t\t\t\t\tevent.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;\n\t\t\t\t}\n\n\t\t\t\treturn event;\n\t\t\t}\n\t\t},\n\n\t\tfix: function fix(event) {\n\t\t\tif (event[jQuery.expando]) {\n\t\t\t\treturn event;\n\t\t\t}\n\n\t\t\t// Create a writable copy of the event object and normalize some properties\n\t\t\tvar i,\n\t\t\t    prop,\n\t\t\t    copy,\n\t\t\t    type = event.type,\n\t\t\t    originalEvent = event,\n\t\t\t    fixHook = this.fixHooks[type];\n\n\t\t\tif (!fixHook) {\n\t\t\t\tthis.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {};\n\t\t\t}\n\t\t\tcopy = fixHook.props ? this.props.concat(fixHook.props) : this.props;\n\n\t\t\tevent = new jQuery.Event(originalEvent);\n\n\t\t\ti = copy.length;\n\t\t\twhile (i--) {\n\t\t\t\tprop = copy[i];\n\t\t\t\tevent[prop] = originalEvent[prop];\n\t\t\t}\n\n\t\t\t// Support: Cordova 2.5 (WebKit) (#13255)\n\t\t\t// All events should have a target; Cordova deviceready doesn't\n\t\t\tif (!event.target) {\n\t\t\t\tevent.target = document;\n\t\t\t}\n\n\t\t\t// Support: Safari 6.0+, Chrome<28\n\t\t\t// Target should not be a text node (#504, #13143)\n\t\t\tif (event.target.nodeType === 3) {\n\t\t\t\tevent.target = event.target.parentNode;\n\t\t\t}\n\n\t\t\treturn fixHook.filter ? fixHook.filter(event, originalEvent) : event;\n\t\t},\n\n\t\tspecial: {\n\t\t\tload: {\n\t\t\t\t// Prevent triggered image.load events from bubbling to window.load\n\t\t\t\tnoBubble: true\n\t\t\t},\n\t\t\tfocus: {\n\t\t\t\t// Fire native event if possible so blur/focus sequence is correct\n\t\t\t\ttrigger: function trigger() {\n\t\t\t\t\tif (this !== safeActiveElement() && this.focus) {\n\t\t\t\t\t\tthis.focus();\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tdelegateType: \"focusin\"\n\t\t\t},\n\t\t\tblur: {\n\t\t\t\ttrigger: function trigger() {\n\t\t\t\t\tif (this === safeActiveElement() && this.blur) {\n\t\t\t\t\t\tthis.blur();\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tdelegateType: \"focusout\"\n\t\t\t},\n\t\t\tclick: {\n\t\t\t\t// For checkbox, fire native event so checked state will be right\n\t\t\t\ttrigger: function trigger() {\n\t\t\t\t\tif (this.type === \"checkbox\" && this.click && jQuery.nodeName(this, \"input\")) {\n\t\t\t\t\t\tthis.click();\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// For cross-browser consistency, don't fire native .click() on links\n\t\t\t\t_default: function _default(event) {\n\t\t\t\t\treturn jQuery.nodeName(event.target, \"a\");\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tbeforeunload: {\n\t\t\t\tpostDispatch: function postDispatch(event) {\n\n\t\t\t\t\t// Support: Firefox 20+\n\t\t\t\t\t// Firefox doesn't alert if the returnValue field is not set.\n\t\t\t\t\tif (event.result !== undefined && event.originalEvent) {\n\t\t\t\t\t\tevent.originalEvent.returnValue = event.result;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tsimulate: function simulate(type, elem, event, bubble) {\n\t\t\t// Piggyback on a donor event to simulate a different one.\n\t\t\t// Fake originalEvent to avoid donor's stopPropagation, but if the\n\t\t\t// simulated event prevents default then we do the same on the donor.\n\t\t\tvar e = jQuery.extend(new jQuery.Event(), event, {\n\t\t\t\ttype: type,\n\t\t\t\tisSimulated: true,\n\t\t\t\toriginalEvent: {}\n\t\t\t});\n\t\t\tif (bubble) {\n\t\t\t\tjQuery.event.trigger(e, null, elem);\n\t\t\t} else {\n\t\t\t\tjQuery.event.dispatch.call(elem, e);\n\t\t\t}\n\t\t\tif (e.isDefaultPrevented()) {\n\t\t\t\tevent.preventDefault();\n\t\t\t}\n\t\t}\n\t};\n\n\tjQuery.removeEvent = function (elem, type, handle) {\n\t\tif (elem.removeEventListener) {\n\t\t\telem.removeEventListener(type, handle, false);\n\t\t}\n\t};\n\n\tjQuery.Event = function (src, props) {\n\t\t// Allow instantiation without the 'new' keyword\n\t\tif (!(this instanceof jQuery.Event)) {\n\t\t\treturn new jQuery.Event(src, props);\n\t\t}\n\n\t\t// Event object\n\t\tif (src && src.type) {\n\t\t\tthis.originalEvent = src;\n\t\t\tthis.type = src.type;\n\n\t\t\t// Events bubbling up the document may have been marked as prevented\n\t\t\t// by a handler lower down the tree; reflect the correct value.\n\t\t\tthis.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined &&\n\t\t\t// Support: Android<4.0\n\t\t\tsrc.returnValue === false ? returnTrue : returnFalse;\n\n\t\t\t// Event type\n\t\t} else {\n\t\t\tthis.type = src;\n\t\t}\n\n\t\t// Put explicitly provided properties onto the event object\n\t\tif (props) {\n\t\t\tjQuery.extend(this, props);\n\t\t}\n\n\t\t// Create a timestamp if incoming event doesn't have one\n\t\tthis.timeStamp = src && src.timeStamp || jQuery.now();\n\n\t\t// Mark it as fixed\n\t\tthis[jQuery.expando] = true;\n\t};\n\n\t// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n\t// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\n\tjQuery.Event.prototype = {\n\t\tisDefaultPrevented: returnFalse,\n\t\tisPropagationStopped: returnFalse,\n\t\tisImmediatePropagationStopped: returnFalse,\n\n\t\tpreventDefault: function preventDefault() {\n\t\t\tvar e = this.originalEvent;\n\n\t\t\tthis.isDefaultPrevented = returnTrue;\n\n\t\t\tif (e && e.preventDefault) {\n\t\t\t\te.preventDefault();\n\t\t\t}\n\t\t},\n\t\tstopPropagation: function stopPropagation() {\n\t\t\tvar e = this.originalEvent;\n\n\t\t\tthis.isPropagationStopped = returnTrue;\n\n\t\t\tif (e && e.stopPropagation) {\n\t\t\t\te.stopPropagation();\n\t\t\t}\n\t\t},\n\t\tstopImmediatePropagation: function stopImmediatePropagation() {\n\t\t\tvar e = this.originalEvent;\n\n\t\t\tthis.isImmediatePropagationStopped = returnTrue;\n\n\t\t\tif (e && e.stopImmediatePropagation) {\n\t\t\t\te.stopImmediatePropagation();\n\t\t\t}\n\n\t\t\tthis.stopPropagation();\n\t\t}\n\t};\n\n\t// Create mouseenter/leave events using mouseover/out and event-time checks\n\t// Support: Chrome 15+\n\tjQuery.each({\n\t\tmouseenter: \"mouseover\",\n\t\tmouseleave: \"mouseout\",\n\t\tpointerenter: \"pointerover\",\n\t\tpointerleave: \"pointerout\"\n\t}, function (orig, fix) {\n\t\tjQuery.event.special[orig] = {\n\t\t\tdelegateType: fix,\n\t\t\tbindType: fix,\n\n\t\t\thandle: function handle(event) {\n\t\t\t\tvar ret,\n\t\t\t\t    target = this,\n\t\t\t\t    related = event.relatedTarget,\n\t\t\t\t    handleObj = event.handleObj;\n\n\t\t\t\t// For mousenter/leave call the handler if related is outside the target.\n\t\t\t\t// NB: No relatedTarget if the mouse left/entered the browser window\n\t\t\t\tif (!related || related !== target && !jQuery.contains(target, related)) {\n\t\t\t\t\tevent.type = handleObj.origType;\n\t\t\t\t\tret = handleObj.handler.apply(this, arguments);\n\t\t\t\t\tevent.type = fix;\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t};\n\t});\n\n\t// Support: Firefox, Chrome, Safari\n\t// Create \"bubbling\" focus and blur events\n\tif (!support.focusinBubbles) {\n\t\tjQuery.each({ focus: \"focusin\", blur: \"focusout\" }, function (orig, fix) {\n\n\t\t\t// Attach a single capturing handler on the document while someone wants focusin/focusout\n\t\t\tvar handler = function handler(event) {\n\t\t\t\tjQuery.event.simulate(fix, event.target, jQuery.event.fix(event), true);\n\t\t\t};\n\n\t\t\tjQuery.event.special[fix] = {\n\t\t\t\tsetup: function setup() {\n\t\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\t    attaches = data_priv.access(doc, fix);\n\n\t\t\t\t\tif (!attaches) {\n\t\t\t\t\t\tdoc.addEventListener(orig, handler, true);\n\t\t\t\t\t}\n\t\t\t\t\tdata_priv.access(doc, fix, (attaches || 0) + 1);\n\t\t\t\t},\n\t\t\t\tteardown: function teardown() {\n\t\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\t    attaches = data_priv.access(doc, fix) - 1;\n\n\t\t\t\t\tif (!attaches) {\n\t\t\t\t\t\tdoc.removeEventListener(orig, handler, true);\n\t\t\t\t\t\tdata_priv.remove(doc, fix);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdata_priv.access(doc, fix, attaches);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t});\n\t}\n\n\tjQuery.fn.extend({\n\n\t\ton: function on(types, selector, data, fn, /*INTERNAL*/one) {\n\t\t\tvar origFn, type;\n\n\t\t\t// Types can be a map of types/handlers\n\t\t\tif ((typeof types === \"undefined\" ? \"undefined\" : _typeof(types)) === \"object\") {\n\t\t\t\t// ( types-Object, selector, data )\n\t\t\t\tif (typeof selector !== \"string\") {\n\t\t\t\t\t// ( types-Object, data )\n\t\t\t\t\tdata = data || selector;\n\t\t\t\t\tselector = undefined;\n\t\t\t\t}\n\t\t\t\tfor (type in types) {\n\t\t\t\t\tthis.on(type, selector, data, types[type], one);\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tif (data == null && fn == null) {\n\t\t\t\t// ( types, fn )\n\t\t\t\tfn = selector;\n\t\t\t\tdata = selector = undefined;\n\t\t\t} else if (fn == null) {\n\t\t\t\tif (typeof selector === \"string\") {\n\t\t\t\t\t// ( types, selector, fn )\n\t\t\t\t\tfn = data;\n\t\t\t\t\tdata = undefined;\n\t\t\t\t} else {\n\t\t\t\t\t// ( types, data, fn )\n\t\t\t\t\tfn = data;\n\t\t\t\t\tdata = selector;\n\t\t\t\t\tselector = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (fn === false) {\n\t\t\t\tfn = returnFalse;\n\t\t\t} else if (!fn) {\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tif (one === 1) {\n\t\t\t\torigFn = fn;\n\t\t\t\tfn = function fn(event) {\n\t\t\t\t\t// Can use an empty set, since event contains the info\n\t\t\t\t\tjQuery().off(event);\n\t\t\t\t\treturn origFn.apply(this, arguments);\n\t\t\t\t};\n\t\t\t\t// Use same guid so caller can remove using origFn\n\t\t\t\tfn.guid = origFn.guid || (origFn.guid = jQuery.guid++);\n\t\t\t}\n\t\t\treturn this.each(function () {\n\t\t\t\tjQuery.event.add(this, types, fn, data, selector);\n\t\t\t});\n\t\t},\n\t\tone: function one(types, selector, data, fn) {\n\t\t\treturn this.on(types, selector, data, fn, 1);\n\t\t},\n\t\toff: function off(types, selector, fn) {\n\t\t\tvar handleObj, type;\n\t\t\tif (types && types.preventDefault && types.handleObj) {\n\t\t\t\t// ( event )  dispatched jQuery.Event\n\t\t\t\thandleObj = types.handleObj;\n\t\t\t\tjQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + \".\" + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tif ((typeof types === \"undefined\" ? \"undefined\" : _typeof(types)) === \"object\") {\n\t\t\t\t// ( types-object [, selector] )\n\t\t\t\tfor (type in types) {\n\t\t\t\t\tthis.off(type, selector, types[type]);\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tif (selector === false || typeof selector === \"function\") {\n\t\t\t\t// ( types [, fn] )\n\t\t\t\tfn = selector;\n\t\t\t\tselector = undefined;\n\t\t\t}\n\t\t\tif (fn === false) {\n\t\t\t\tfn = returnFalse;\n\t\t\t}\n\t\t\treturn this.each(function () {\n\t\t\t\tjQuery.event.remove(this, types, fn, selector);\n\t\t\t});\n\t\t},\n\n\t\ttrigger: function trigger(type, data) {\n\t\t\treturn this.each(function () {\n\t\t\t\tjQuery.event.trigger(type, data, this);\n\t\t\t});\n\t\t},\n\t\ttriggerHandler: function triggerHandler(type, data) {\n\t\t\tvar elem = this[0];\n\t\t\tif (elem) {\n\t\t\t\treturn jQuery.event.trigger(type, data, elem, true);\n\t\t\t}\n\t\t}\n\t});\n\n\tvar rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/gi,\n\t    rtagName = /<([\\w:]+)/,\n\t    rhtml = /<|&#?\\w+;/,\n\t    rnoInnerhtml = /<(?:script|style|link)/i,\n\n\t// checked=\"checked\" or checked\n\trchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n\t    rscriptType = /^$|\\/(?:java|ecma)script/i,\n\t    rscriptTypeMasked = /^true\\/(.*)/,\n\t    rcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g,\n\n\n\t// We have to close these tags to support XHTML (#13200)\n\twrapMap = {\n\n\t\t// Support: IE9\n\t\toption: [1, \"<select multiple='multiple'>\", \"</select>\"],\n\n\t\tthead: [1, \"<table>\", \"</table>\"],\n\t\tcol: [2, \"<table><colgroup>\", \"</colgroup></table>\"],\n\t\ttr: [2, \"<table><tbody>\", \"</tbody></table>\"],\n\t\ttd: [3, \"<table><tbody><tr>\", \"</tr></tbody></table>\"],\n\n\t\t_default: [0, \"\", \"\"]\n\t};\n\n\t// Support: IE9\n\twrapMap.optgroup = wrapMap.option;\n\n\twrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\n\twrapMap.th = wrapMap.td;\n\n\t// Support: 1.x compatibility\n\t// Manipulating tables requires a tbody\n\tfunction manipulationTarget(elem, content) {\n\t\treturn jQuery.nodeName(elem, \"table\") && jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, \"tr\") ? elem.getElementsByTagName(\"tbody\")[0] || elem.appendChild(elem.ownerDocument.createElement(\"tbody\")) : elem;\n\t}\n\n\t// Replace/restore the type attribute of script elements for safe DOM manipulation\n\tfunction disableScript(elem) {\n\t\telem.type = (elem.getAttribute(\"type\") !== null) + \"/\" + elem.type;\n\t\treturn elem;\n\t}\n\tfunction restoreScript(elem) {\n\t\tvar match = rscriptTypeMasked.exec(elem.type);\n\n\t\tif (match) {\n\t\t\telem.type = match[1];\n\t\t} else {\n\t\t\telem.removeAttribute(\"type\");\n\t\t}\n\n\t\treturn elem;\n\t}\n\n\t// Mark scripts as having already been evaluated\n\tfunction setGlobalEval(elems, refElements) {\n\t\tvar i = 0,\n\t\t    l = elems.length;\n\n\t\tfor (; i < l; i++) {\n\t\t\tdata_priv.set(elems[i], \"globalEval\", !refElements || data_priv.get(refElements[i], \"globalEval\"));\n\t\t}\n\t}\n\n\tfunction cloneCopyEvent(src, dest) {\n\t\tvar i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;\n\n\t\tif (dest.nodeType !== 1) {\n\t\t\treturn;\n\t\t}\n\n\t\t// 1. Copy private data: events, handlers, etc.\n\t\tif (data_priv.hasData(src)) {\n\t\t\tpdataOld = data_priv.access(src);\n\t\t\tpdataCur = data_priv.set(dest, pdataOld);\n\t\t\tevents = pdataOld.events;\n\n\t\t\tif (events) {\n\t\t\t\tdelete pdataCur.handle;\n\t\t\t\tpdataCur.events = {};\n\n\t\t\t\tfor (type in events) {\n\t\t\t\t\tfor (i = 0, l = events[type].length; i < l; i++) {\n\t\t\t\t\t\tjQuery.event.add(dest, type, events[type][i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 2. Copy user data\n\t\tif (data_user.hasData(src)) {\n\t\t\tudataOld = data_user.access(src);\n\t\t\tudataCur = jQuery.extend({}, udataOld);\n\n\t\t\tdata_user.set(dest, udataCur);\n\t\t}\n\t}\n\n\tfunction getAll(context, tag) {\n\t\tvar ret = context.getElementsByTagName ? context.getElementsByTagName(tag || \"*\") : context.querySelectorAll ? context.querySelectorAll(tag || \"*\") : [];\n\n\t\treturn tag === undefined || tag && jQuery.nodeName(context, tag) ? jQuery.merge([context], ret) : ret;\n\t}\n\n\t// Fix IE bugs, see support tests\n\tfunction fixInput(src, dest) {\n\t\tvar nodeName = dest.nodeName.toLowerCase();\n\n\t\t// Fails to persist the checked state of a cloned checkbox or radio button.\n\t\tif (nodeName === \"input\" && rcheckableType.test(src.type)) {\n\t\t\tdest.checked = src.checked;\n\n\t\t\t// Fails to return the selected option to the default selected state when cloning options\n\t\t} else if (nodeName === \"input\" || nodeName === \"textarea\") {\n\t\t\tdest.defaultValue = src.defaultValue;\n\t\t}\n\t}\n\n\tjQuery.extend({\n\t\tclone: function clone(elem, dataAndEvents, deepDataAndEvents) {\n\t\t\tvar i,\n\t\t\t    l,\n\t\t\t    srcElements,\n\t\t\t    destElements,\n\t\t\t    clone = elem.cloneNode(true),\n\t\t\t    inPage = jQuery.contains(elem.ownerDocument, elem);\n\n\t\t\t// Fix IE cloning issues\n\t\t\tif (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {\n\n\t\t\t\t// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2\n\t\t\t\tdestElements = getAll(clone);\n\t\t\t\tsrcElements = getAll(elem);\n\n\t\t\t\tfor (i = 0, l = srcElements.length; i < l; i++) {\n\t\t\t\t\tfixInput(srcElements[i], destElements[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Copy the events from the original to the clone\n\t\t\tif (dataAndEvents) {\n\t\t\t\tif (deepDataAndEvents) {\n\t\t\t\t\tsrcElements = srcElements || getAll(elem);\n\t\t\t\t\tdestElements = destElements || getAll(clone);\n\n\t\t\t\t\tfor (i = 0, l = srcElements.length; i < l; i++) {\n\t\t\t\t\t\tcloneCopyEvent(srcElements[i], destElements[i]);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcloneCopyEvent(elem, clone);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Preserve script evaluation history\n\t\t\tdestElements = getAll(clone, \"script\");\n\t\t\tif (destElements.length > 0) {\n\t\t\t\tsetGlobalEval(destElements, !inPage && getAll(elem, \"script\"));\n\t\t\t}\n\n\t\t\t// Return the cloned set\n\t\t\treturn clone;\n\t\t},\n\n\t\tbuildFragment: function buildFragment(elems, context, scripts, selection) {\n\t\t\tvar elem,\n\t\t\t    tmp,\n\t\t\t    tag,\n\t\t\t    wrap,\n\t\t\t    contains,\n\t\t\t    j,\n\t\t\t    fragment = context.createDocumentFragment(),\n\t\t\t    nodes = [],\n\t\t\t    i = 0,\n\t\t\t    l = elems.length;\n\n\t\t\tfor (; i < l; i++) {\n\t\t\t\telem = elems[i];\n\n\t\t\t\tif (elem || elem === 0) {\n\n\t\t\t\t\t// Add nodes directly\n\t\t\t\t\tif (jQuery.type(elem) === \"object\") {\n\t\t\t\t\t\t// Support: QtWebKit, PhantomJS\n\t\t\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\t\t\tjQuery.merge(nodes, elem.nodeType ? [elem] : elem);\n\n\t\t\t\t\t\t// Convert non-html into a text node\n\t\t\t\t\t} else if (!rhtml.test(elem)) {\n\t\t\t\t\t\tnodes.push(context.createTextNode(elem));\n\n\t\t\t\t\t\t// Convert html into DOM nodes\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttmp = tmp || fragment.appendChild(context.createElement(\"div\"));\n\n\t\t\t\t\t\t// Deserialize a standard representation\n\t\t\t\t\t\ttag = (rtagName.exec(elem) || [\"\", \"\"])[1].toLowerCase();\n\t\t\t\t\t\twrap = wrapMap[tag] || wrapMap._default;\n\t\t\t\t\t\ttmp.innerHTML = wrap[1] + elem.replace(rxhtmlTag, \"<$1></$2>\") + wrap[2];\n\n\t\t\t\t\t\t// Descend through wrappers to the right content\n\t\t\t\t\t\tj = wrap[0];\n\t\t\t\t\t\twhile (j--) {\n\t\t\t\t\t\t\ttmp = tmp.lastChild;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Support: QtWebKit, PhantomJS\n\t\t\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\t\t\tjQuery.merge(nodes, tmp.childNodes);\n\n\t\t\t\t\t\t// Remember the top-level container\n\t\t\t\t\t\ttmp = fragment.firstChild;\n\n\t\t\t\t\t\t// Ensure the created nodes are orphaned (#12392)\n\t\t\t\t\t\ttmp.textContent = \"\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove wrapper from fragment\n\t\t\tfragment.textContent = \"\";\n\n\t\t\ti = 0;\n\t\t\twhile (elem = nodes[i++]) {\n\n\t\t\t\t// #4087 - If origin and destination elements are the same, and this is\n\t\t\t\t// that element, do not do anything\n\t\t\t\tif (selection && jQuery.inArray(elem, selection) !== -1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tcontains = jQuery.contains(elem.ownerDocument, elem);\n\n\t\t\t\t// Append to fragment\n\t\t\t\ttmp = getAll(fragment.appendChild(elem), \"script\");\n\n\t\t\t\t// Preserve script evaluation history\n\t\t\t\tif (contains) {\n\t\t\t\t\tsetGlobalEval(tmp);\n\t\t\t\t}\n\n\t\t\t\t// Capture executables\n\t\t\t\tif (scripts) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile (elem = tmp[j++]) {\n\t\t\t\t\t\tif (rscriptType.test(elem.type || \"\")) {\n\t\t\t\t\t\t\tscripts.push(elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn fragment;\n\t\t},\n\n\t\tcleanData: function cleanData(elems) {\n\t\t\tvar data,\n\t\t\t    elem,\n\t\t\t    type,\n\t\t\t    key,\n\t\t\t    special = jQuery.event.special,\n\t\t\t    i = 0;\n\n\t\t\tfor (; (elem = elems[i]) !== undefined; i++) {\n\t\t\t\tif (jQuery.acceptData(elem)) {\n\t\t\t\t\tkey = elem[data_priv.expando];\n\n\t\t\t\t\tif (key && (data = data_priv.cache[key])) {\n\t\t\t\t\t\tif (data.events) {\n\t\t\t\t\t\t\tfor (type in data.events) {\n\t\t\t\t\t\t\t\tif (special[type]) {\n\t\t\t\t\t\t\t\t\tjQuery.event.remove(elem, type);\n\n\t\t\t\t\t\t\t\t\t// This is a shortcut to avoid jQuery.event.remove's overhead\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tjQuery.removeEvent(elem, type, data.handle);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (data_priv.cache[key]) {\n\t\t\t\t\t\t\t// Discard any remaining `private` data\n\t\t\t\t\t\t\tdelete data_priv.cache[key];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Discard any remaining `user` data\n\t\t\t\tdelete data_user.cache[elem[data_user.expando]];\n\t\t\t}\n\t\t}\n\t});\n\n\tjQuery.fn.extend({\n\t\ttext: function text(value) {\n\t\t\treturn access(this, function (value) {\n\t\t\t\treturn value === undefined ? jQuery.text(this) : this.empty().each(function () {\n\t\t\t\t\tif (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {\n\t\t\t\t\t\tthis.textContent = value;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}, null, value, arguments.length);\n\t\t},\n\n\t\tappend: function append() {\n\t\t\treturn this.domManip(arguments, function (elem) {\n\t\t\t\tif (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {\n\t\t\t\t\tvar target = manipulationTarget(this, elem);\n\t\t\t\t\ttarget.appendChild(elem);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\tprepend: function prepend() {\n\t\t\treturn this.domManip(arguments, function (elem) {\n\t\t\t\tif (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {\n\t\t\t\t\tvar target = manipulationTarget(this, elem);\n\t\t\t\t\ttarget.insertBefore(elem, target.firstChild);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\tbefore: function before() {\n\t\t\treturn this.domManip(arguments, function (elem) {\n\t\t\t\tif (this.parentNode) {\n\t\t\t\t\tthis.parentNode.insertBefore(elem, this);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\tafter: function after() {\n\t\t\treturn this.domManip(arguments, function (elem) {\n\t\t\t\tif (this.parentNode) {\n\t\t\t\t\tthis.parentNode.insertBefore(elem, this.nextSibling);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\tremove: function remove(selector, keepData /* Internal Use Only */) {\n\t\t\tvar elem,\n\t\t\t    elems = selector ? jQuery.filter(selector, this) : this,\n\t\t\t    i = 0;\n\n\t\t\tfor (; (elem = elems[i]) != null; i++) {\n\t\t\t\tif (!keepData && elem.nodeType === 1) {\n\t\t\t\t\tjQuery.cleanData(getAll(elem));\n\t\t\t\t}\n\n\t\t\t\tif (elem.parentNode) {\n\t\t\t\t\tif (keepData && jQuery.contains(elem.ownerDocument, elem)) {\n\t\t\t\t\t\tsetGlobalEval(getAll(elem, \"script\"));\n\t\t\t\t\t}\n\t\t\t\t\telem.parentNode.removeChild(elem);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\tempty: function empty() {\n\t\t\tvar elem,\n\t\t\t    i = 0;\n\n\t\t\tfor (; (elem = this[i]) != null; i++) {\n\t\t\t\tif (elem.nodeType === 1) {\n\n\t\t\t\t\t// Prevent memory leaks\n\t\t\t\t\tjQuery.cleanData(getAll(elem, false));\n\n\t\t\t\t\t// Remove any remaining nodes\n\t\t\t\t\telem.textContent = \"\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\tclone: function clone(dataAndEvents, deepDataAndEvents) {\n\t\t\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n\t\t\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n\n\t\t\treturn this.map(function () {\n\t\t\t\treturn jQuery.clone(this, dataAndEvents, deepDataAndEvents);\n\t\t\t});\n\t\t},\n\n\t\thtml: function html(value) {\n\t\t\treturn access(this, function (value) {\n\t\t\t\tvar elem = this[0] || {},\n\t\t\t\t    i = 0,\n\t\t\t\t    l = this.length;\n\n\t\t\t\tif (value === undefined && elem.nodeType === 1) {\n\t\t\t\t\treturn elem.innerHTML;\n\t\t\t\t}\n\n\t\t\t\t// See if we can take a shortcut and just use innerHTML\n\t\t\t\tif (typeof value === \"string\" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || [\"\", \"\"])[1].toLowerCase()]) {\n\n\t\t\t\t\tvalue = value.replace(rxhtmlTag, \"<$1></$2>\");\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfor (; i < l; i++) {\n\t\t\t\t\t\t\telem = this[i] || {};\n\n\t\t\t\t\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\t\t\t\t\tif (elem.nodeType === 1) {\n\t\t\t\t\t\t\t\tjQuery.cleanData(getAll(elem, false));\n\t\t\t\t\t\t\t\telem.innerHTML = value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\telem = 0;\n\n\t\t\t\t\t\t// If using innerHTML throws an exception, use the fallback method\n\t\t\t\t\t} catch (e) {}\n\t\t\t\t}\n\n\t\t\t\tif (elem) {\n\t\t\t\t\tthis.empty().append(value);\n\t\t\t\t}\n\t\t\t}, null, value, arguments.length);\n\t\t},\n\n\t\treplaceWith: function replaceWith() {\n\t\t\tvar arg = arguments[0];\n\n\t\t\t// Make the changes, replacing each context element with the new content\n\t\t\tthis.domManip(arguments, function (elem) {\n\t\t\t\targ = this.parentNode;\n\n\t\t\t\tjQuery.cleanData(getAll(this));\n\n\t\t\t\tif (arg) {\n\t\t\t\t\targ.replaceChild(elem, this);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Force removal if there was no new content (e.g., from empty arguments)\n\t\t\treturn arg && (arg.length || arg.nodeType) ? this : this.remove();\n\t\t},\n\n\t\tdetach: function detach(selector) {\n\t\t\treturn this.remove(selector, true);\n\t\t},\n\n\t\tdomManip: function domManip(args, callback) {\n\n\t\t\t// Flatten any nested arrays\n\t\t\targs = concat.apply([], args);\n\n\t\t\tvar fragment,\n\t\t\t    first,\n\t\t\t    scripts,\n\t\t\t    hasScripts,\n\t\t\t    node,\n\t\t\t    doc,\n\t\t\t    i = 0,\n\t\t\t    l = this.length,\n\t\t\t    set = this,\n\t\t\t    iNoClone = l - 1,\n\t\t\t    value = args[0],\n\t\t\t    isFunction = jQuery.isFunction(value);\n\n\t\t\t// We can't cloneNode fragments that contain checked, in WebKit\n\t\t\tif (isFunction || l > 1 && typeof value === \"string\" && !support.checkClone && rchecked.test(value)) {\n\t\t\t\treturn this.each(function (index) {\n\t\t\t\t\tvar self = set.eq(index);\n\t\t\t\t\tif (isFunction) {\n\t\t\t\t\t\targs[0] = value.call(this, index, self.html());\n\t\t\t\t\t}\n\t\t\t\t\tself.domManip(args, callback);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (l) {\n\t\t\t\tfragment = jQuery.buildFragment(args, this[0].ownerDocument, false, this);\n\t\t\t\tfirst = fragment.firstChild;\n\n\t\t\t\tif (fragment.childNodes.length === 1) {\n\t\t\t\t\tfragment = first;\n\t\t\t\t}\n\n\t\t\t\tif (first) {\n\t\t\t\t\tscripts = jQuery.map(getAll(fragment, \"script\"), disableScript);\n\t\t\t\t\thasScripts = scripts.length;\n\n\t\t\t\t\t// Use the original fragment for the last item instead of the first because it can end up\n\t\t\t\t\t// being emptied incorrectly in certain situations (#8070).\n\t\t\t\t\tfor (; i < l; i++) {\n\t\t\t\t\t\tnode = fragment;\n\n\t\t\t\t\t\tif (i !== iNoClone) {\n\t\t\t\t\t\t\tnode = jQuery.clone(node, true, true);\n\n\t\t\t\t\t\t\t// Keep references to cloned scripts for later restoration\n\t\t\t\t\t\t\tif (hasScripts) {\n\t\t\t\t\t\t\t\t// Support: QtWebKit\n\t\t\t\t\t\t\t\t// jQuery.merge because push.apply(_, arraylike) throws\n\t\t\t\t\t\t\t\tjQuery.merge(scripts, getAll(node, \"script\"));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcallback.call(this[i], node, i);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (hasScripts) {\n\t\t\t\t\t\tdoc = scripts[scripts.length - 1].ownerDocument;\n\n\t\t\t\t\t\t// Reenable scripts\n\t\t\t\t\t\tjQuery.map(scripts, restoreScript);\n\n\t\t\t\t\t\t// Evaluate executable scripts on first document insertion\n\t\t\t\t\t\tfor (i = 0; i < hasScripts; i++) {\n\t\t\t\t\t\t\tnode = scripts[i];\n\t\t\t\t\t\t\tif (rscriptType.test(node.type || \"\") && !data_priv.access(node, \"globalEval\") && jQuery.contains(doc, node)) {\n\n\t\t\t\t\t\t\t\tif (node.src) {\n\t\t\t\t\t\t\t\t\t// Optional AJAX dependency, but won't run scripts if not present\n\t\t\t\t\t\t\t\t\tif (jQuery._evalUrl) {\n\t\t\t\t\t\t\t\t\t\tjQuery._evalUrl(node.src);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tjQuery.globalEval(node.textContent.replace(rcleanScript, \"\"));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\t});\n\n\tjQuery.each({\n\t\tappendTo: \"append\",\n\t\tprependTo: \"prepend\",\n\t\tinsertBefore: \"before\",\n\t\tinsertAfter: \"after\",\n\t\treplaceAll: \"replaceWith\"\n\t}, function (name, original) {\n\t\tjQuery.fn[name] = function (selector) {\n\t\t\tvar elems,\n\t\t\t    ret = [],\n\t\t\t    insert = jQuery(selector),\n\t\t\t    last = insert.length - 1,\n\t\t\t    i = 0;\n\n\t\t\tfor (; i <= last; i++) {\n\t\t\t\telems = i === last ? this : this.clone(true);\n\t\t\t\tjQuery(insert[i])[original](elems);\n\n\t\t\t\t// Support: QtWebKit\n\t\t\t\t// .get() because push.apply(_, arraylike) throws\n\t\t\t\tpush.apply(ret, elems.get());\n\t\t\t}\n\n\t\t\treturn this.pushStack(ret);\n\t\t};\n\t});\n\n\tvar iframe,\n\t    elemdisplay = {};\n\n\t/**\n  * Retrieve the actual display of a element\n  * @param {String} name nodeName of the element\n  * @param {Object} doc Document object\n  */\n\t// Called only from within defaultDisplay\n\tfunction actualDisplay(name, doc) {\n\t\tvar style,\n\t\t    elem = jQuery(doc.createElement(name)).appendTo(doc.body),\n\n\n\t\t// getDefaultComputedStyle might be reliably used only on attached element\n\t\tdisplay = window.getDefaultComputedStyle && (style = window.getDefaultComputedStyle(elem[0])) ?\n\n\t\t// Use of this method is a temporary fix (more like optimization) until something better comes along,\n\t\t// since it was removed from specification and supported only in FF\n\t\tstyle.display : jQuery.css(elem[0], \"display\");\n\n\t\t// We don't have any data stored on the element,\n\t\t// so use \"detach\" method as fast way to get rid of the element\n\t\telem.detach();\n\n\t\treturn display;\n\t}\n\n\t/**\n  * Try to determine the default display value of an element\n  * @param {String} nodeName\n  */\n\tfunction defaultDisplay(nodeName) {\n\t\tvar doc = document,\n\t\t    display = elemdisplay[nodeName];\n\n\t\tif (!display) {\n\t\t\tdisplay = actualDisplay(nodeName, doc);\n\n\t\t\t// If the simple way fails, read from inside an iframe\n\t\t\tif (display === \"none\" || !display) {\n\n\t\t\t\t// Use the already-created iframe if possible\n\t\t\t\tiframe = (iframe || jQuery(\"<iframe frameborder='0' width='0' height='0'/>\")).appendTo(doc.documentElement);\n\n\t\t\t\t// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse\n\t\t\t\tdoc = iframe[0].contentDocument;\n\n\t\t\t\t// Support: IE\n\t\t\t\tdoc.write();\n\t\t\t\tdoc.close();\n\n\t\t\t\tdisplay = actualDisplay(nodeName, doc);\n\t\t\t\tiframe.detach();\n\t\t\t}\n\n\t\t\t// Store the correct default display\n\t\t\telemdisplay[nodeName] = display;\n\t\t}\n\n\t\treturn display;\n\t}\n\tvar rmargin = /^margin/;\n\n\tvar rnumnonpx = new RegExp(\"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\");\n\n\tvar getStyles = function getStyles(elem) {\n\t\t// Support: IE<=11+, Firefox<=30+ (#15098, #14150)\n\t\t// IE throws on elements created in popups\n\t\t// FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\n\t\tif (elem.ownerDocument.defaultView.opener) {\n\t\t\treturn elem.ownerDocument.defaultView.getComputedStyle(elem, null);\n\t\t}\n\n\t\treturn window.getComputedStyle(elem, null);\n\t};\n\n\tfunction curCSS(elem, name, computed) {\n\t\tvar width,\n\t\t    minWidth,\n\t\t    maxWidth,\n\t\t    ret,\n\t\t    style = elem.style;\n\n\t\tcomputed = computed || getStyles(elem);\n\n\t\t// Support: IE9\n\t\t// getPropertyValue is only needed for .css('filter') (#12537)\n\t\tif (computed) {\n\t\t\tret = computed.getPropertyValue(name) || computed[name];\n\t\t}\n\n\t\tif (computed) {\n\n\t\t\tif (ret === \"\" && !jQuery.contains(elem.ownerDocument, elem)) {\n\t\t\t\tret = jQuery.style(elem, name);\n\t\t\t}\n\n\t\t\t// Support: iOS < 6\n\t\t\t// A tribute to the \"awesome hack by Dean Edwards\"\n\t\t\t// iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels\n\t\t\t// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values\n\t\t\tif (rnumnonpx.test(ret) && rmargin.test(name)) {\n\n\t\t\t\t// Remember the original values\n\t\t\t\twidth = style.width;\n\t\t\t\tminWidth = style.minWidth;\n\t\t\t\tmaxWidth = style.maxWidth;\n\n\t\t\t\t// Put in the new values to get a computed value out\n\t\t\t\tstyle.minWidth = style.maxWidth = style.width = ret;\n\t\t\t\tret = computed.width;\n\n\t\t\t\t// Revert the changed values\n\t\t\t\tstyle.width = width;\n\t\t\t\tstyle.minWidth = minWidth;\n\t\t\t\tstyle.maxWidth = maxWidth;\n\t\t\t}\n\t\t}\n\n\t\treturn ret !== undefined ?\n\t\t// Support: IE\n\t\t// IE returns zIndex value as an integer.\n\t\tret + \"\" : ret;\n\t}\n\n\tfunction addGetHookIf(conditionFn, hookFn) {\n\t\t// Define the hook, we'll check on the first run if it's really needed.\n\t\treturn {\n\t\t\tget: function get() {\n\t\t\t\tif (conditionFn()) {\n\t\t\t\t\t// Hook not needed (or it's not possible to use it due\n\t\t\t\t\t// to missing dependency), remove it.\n\t\t\t\t\tdelete this.get;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Hook needed; redefine it so that the support test is not executed again.\n\t\t\t\treturn (this.get = hookFn).apply(this, arguments);\n\t\t\t}\n\t\t};\n\t}\n\n\t(function () {\n\t\tvar pixelPositionVal,\n\t\t    boxSizingReliableVal,\n\t\t    docElem = document.documentElement,\n\t\t    container = document.createElement(\"div\"),\n\t\t    div = document.createElement(\"div\");\n\n\t\tif (!div.style) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Support: IE9-11+\n\t\t// Style of cloned element affects source element cloned (#8908)\n\t\tdiv.style.backgroundClip = \"content-box\";\n\t\tdiv.cloneNode(true).style.backgroundClip = \"\";\n\t\tsupport.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n\n\t\tcontainer.style.cssText = \"border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;\" + \"position:absolute\";\n\t\tcontainer.appendChild(div);\n\n\t\t// Executing both pixelPosition & boxSizingReliable tests require only one layout\n\t\t// so they're executed at the same time to save the second computation.\n\t\tfunction computePixelPositionAndBoxSizingReliable() {\n\t\t\tdiv.style.cssText =\n\t\t\t// Support: Firefox<29, Android 2.3\n\t\t\t// Vendor-prefix box-sizing\n\t\t\t\"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;\" + \"box-sizing:border-box;display:block;margin-top:1%;top:1%;\" + \"border:1px;padding:1px;width:4px;position:absolute\";\n\t\t\tdiv.innerHTML = \"\";\n\t\t\tdocElem.appendChild(container);\n\n\t\t\tvar divStyle = window.getComputedStyle(div, null);\n\t\t\tpixelPositionVal = divStyle.top !== \"1%\";\n\t\t\tboxSizingReliableVal = divStyle.width === \"4px\";\n\n\t\t\tdocElem.removeChild(container);\n\t\t}\n\n\t\t// Support: node.js jsdom\n\t\t// Don't assume that getComputedStyle is a property of the global object\n\t\tif (window.getComputedStyle) {\n\t\t\tjQuery.extend(support, {\n\t\t\t\tpixelPosition: function pixelPosition() {\n\n\t\t\t\t\t// This test is executed only once but we still do memoizing\n\t\t\t\t\t// since we can use the boxSizingReliable pre-computing.\n\t\t\t\t\t// No need to check if the test was already performed, though.\n\t\t\t\t\tcomputePixelPositionAndBoxSizingReliable();\n\t\t\t\t\treturn pixelPositionVal;\n\t\t\t\t},\n\t\t\t\tboxSizingReliable: function boxSizingReliable() {\n\t\t\t\t\tif (boxSizingReliableVal == null) {\n\t\t\t\t\t\tcomputePixelPositionAndBoxSizingReliable();\n\t\t\t\t\t}\n\t\t\t\t\treturn boxSizingReliableVal;\n\t\t\t\t},\n\t\t\t\treliableMarginRight: function reliableMarginRight() {\n\n\t\t\t\t\t// Support: Android 2.3\n\t\t\t\t\t// Check if div with explicit width and no margin-right incorrectly\n\t\t\t\t\t// gets computed margin-right based on width of container. (#3333)\n\t\t\t\t\t// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\n\t\t\t\t\t// This support function is only executed once so no memoizing is needed.\n\t\t\t\t\tvar ret,\n\t\t\t\t\t    marginDiv = div.appendChild(document.createElement(\"div\"));\n\n\t\t\t\t\t// Reset CSS: box-sizing; display; margin; border; padding\n\t\t\t\t\tmarginDiv.style.cssText = div.style.cssText =\n\t\t\t\t\t// Support: Firefox<29, Android 2.3\n\t\t\t\t\t// Vendor-prefix box-sizing\n\t\t\t\t\t\"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;\" + \"box-sizing:content-box;display:block;margin:0;border:0;padding:0\";\n\t\t\t\t\tmarginDiv.style.marginRight = marginDiv.style.width = \"0\";\n\t\t\t\t\tdiv.style.width = \"1px\";\n\t\t\t\t\tdocElem.appendChild(container);\n\n\t\t\t\t\tret = !parseFloat(window.getComputedStyle(marginDiv, null).marginRight);\n\n\t\t\t\t\tdocElem.removeChild(container);\n\t\t\t\t\tdiv.removeChild(marginDiv);\n\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t})();\n\n\t// A method for quickly swapping in/out CSS properties to get correct calculations.\n\tjQuery.swap = function (elem, options, callback, args) {\n\t\tvar ret,\n\t\t    name,\n\t\t    old = {};\n\n\t\t// Remember the old values, and insert the new ones\n\t\tfor (name in options) {\n\t\t\told[name] = elem.style[name];\n\t\t\telem.style[name] = options[name];\n\t\t}\n\n\t\tret = callback.apply(elem, args || []);\n\n\t\t// Revert the old values\n\t\tfor (name in options) {\n\t\t\telem.style[name] = old[name];\n\t\t}\n\n\t\treturn ret;\n\t};\n\n\tvar\n\t// Swappable if display is none or starts with table except \"table\", \"table-cell\", or \"table-caption\"\n\t// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\n\t    rnumsplit = new RegExp(\"^(\" + pnum + \")(.*)$\", \"i\"),\n\t    rrelNum = new RegExp(\"^([+-])=(\" + pnum + \")\", \"i\"),\n\t    cssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\n\t    cssNormalTransform = {\n\t\tletterSpacing: \"0\",\n\t\tfontWeight: \"400\"\n\t},\n\t    cssPrefixes = [\"Webkit\", \"O\", \"Moz\", \"ms\"];\n\n\t// Return a css property mapped to a potentially vendor prefixed property\n\tfunction vendorPropName(style, name) {\n\n\t\t// Shortcut for names that are not vendor prefixed\n\t\tif (name in style) {\n\t\t\treturn name;\n\t\t}\n\n\t\t// Check for vendor prefixed names\n\t\tvar capName = name[0].toUpperCase() + name.slice(1),\n\t\t    origName = name,\n\t\t    i = cssPrefixes.length;\n\n\t\twhile (i--) {\n\t\t\tname = cssPrefixes[i] + capName;\n\t\t\tif (name in style) {\n\t\t\t\treturn name;\n\t\t\t}\n\t\t}\n\n\t\treturn origName;\n\t}\n\n\tfunction setPositiveNumber(elem, value, subtract) {\n\t\tvar matches = rnumsplit.exec(value);\n\t\treturn matches ?\n\t\t// Guard against undefined \"subtract\", e.g., when used as in cssHooks\n\t\tMath.max(0, matches[1] - (subtract || 0)) + (matches[2] || \"px\") : value;\n\t}\n\n\tfunction augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {\n\t\tvar i = extra === (isBorderBox ? \"border\" : \"content\") ?\n\t\t// If we already have the right measurement, avoid augmentation\n\t\t4 :\n\t\t// Otherwise initialize for horizontal or vertical properties\n\t\tname === \"width\" ? 1 : 0,\n\t\t    val = 0;\n\n\t\tfor (; i < 4; i += 2) {\n\t\t\t// Both box models exclude margin, so add it if we want it\n\t\t\tif (extra === \"margin\") {\n\t\t\t\tval += jQuery.css(elem, extra + cssExpand[i], true, styles);\n\t\t\t}\n\n\t\t\tif (isBorderBox) {\n\t\t\t\t// border-box includes padding, so remove it if we want content\n\t\t\t\tif (extra === \"content\") {\n\t\t\t\t\tval -= jQuery.css(elem, \"padding\" + cssExpand[i], true, styles);\n\t\t\t\t}\n\n\t\t\t\t// At this point, extra isn't border nor margin, so remove border\n\t\t\t\tif (extra !== \"margin\") {\n\t\t\t\t\tval -= jQuery.css(elem, \"border\" + cssExpand[i] + \"Width\", true, styles);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// At this point, extra isn't content, so add padding\n\t\t\t\tval += jQuery.css(elem, \"padding\" + cssExpand[i], true, styles);\n\n\t\t\t\t// At this point, extra isn't content nor padding, so add border\n\t\t\t\tif (extra !== \"padding\") {\n\t\t\t\t\tval += jQuery.css(elem, \"border\" + cssExpand[i] + \"Width\", true, styles);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn val;\n\t}\n\n\tfunction getWidthOrHeight(elem, name, extra) {\n\n\t\t// Start with offset property, which is equivalent to the border-box value\n\t\tvar valueIsBorderBox = true,\n\t\t    val = name === \"width\" ? elem.offsetWidth : elem.offsetHeight,\n\t\t    styles = getStyles(elem),\n\t\t    isBorderBox = jQuery.css(elem, \"boxSizing\", false, styles) === \"border-box\";\n\n\t\t// Some non-html elements return undefined for offsetWidth, so check for null/undefined\n\t\t// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285\n\t\t// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668\n\t\tif (val <= 0 || val == null) {\n\t\t\t// Fall back to computed then uncomputed css if necessary\n\t\t\tval = curCSS(elem, name, styles);\n\t\t\tif (val < 0 || val == null) {\n\t\t\t\tval = elem.style[name];\n\t\t\t}\n\n\t\t\t// Computed unit is not pixels. Stop here and return.\n\t\t\tif (rnumnonpx.test(val)) {\n\t\t\t\treturn val;\n\t\t\t}\n\n\t\t\t// Check for style in case a browser which returns unreliable values\n\t\t\t// for getComputedStyle silently falls back to the reliable elem.style\n\t\t\tvalueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]);\n\n\t\t\t// Normalize \"\", auto, and prepare for extra\n\t\t\tval = parseFloat(val) || 0;\n\t\t}\n\n\t\t// Use the active box-sizing model to add/subtract irrelevant styles\n\t\treturn val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? \"border\" : \"content\"), valueIsBorderBox, styles) + \"px\";\n\t}\n\n\tfunction showHide(elements, show) {\n\t\tvar display,\n\t\t    elem,\n\t\t    hidden,\n\t\t    values = [],\n\t\t    index = 0,\n\t\t    length = elements.length;\n\n\t\tfor (; index < length; index++) {\n\t\t\telem = elements[index];\n\t\t\tif (!elem.style) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvalues[index] = data_priv.get(elem, \"olddisplay\");\n\t\t\tdisplay = elem.style.display;\n\t\t\tif (show) {\n\t\t\t\t// Reset the inline display of this element to learn if it is\n\t\t\t\t// being hidden by cascaded rules or not\n\t\t\t\tif (!values[index] && display === \"none\") {\n\t\t\t\t\telem.style.display = \"\";\n\t\t\t\t}\n\n\t\t\t\t// Set elements which have been overridden with display: none\n\t\t\t\t// in a stylesheet to whatever the default browser style is\n\t\t\t\t// for such an element\n\t\t\t\tif (elem.style.display === \"\" && isHidden(elem)) {\n\t\t\t\t\tvalues[index] = data_priv.access(elem, \"olddisplay\", defaultDisplay(elem.nodeName));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\thidden = isHidden(elem);\n\n\t\t\t\tif (display !== \"none\" || !hidden) {\n\t\t\t\t\tdata_priv.set(elem, \"olddisplay\", hidden ? display : jQuery.css(elem, \"display\"));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Set the display of most of the elements in a second loop\n\t\t// to avoid the constant reflow\n\t\tfor (index = 0; index < length; index++) {\n\t\t\telem = elements[index];\n\t\t\tif (!elem.style) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!show || elem.style.display === \"none\" || elem.style.display === \"\") {\n\t\t\t\telem.style.display = show ? values[index] || \"\" : \"none\";\n\t\t\t}\n\t\t}\n\n\t\treturn elements;\n\t}\n\n\tjQuery.extend({\n\n\t\t// Add in style property hooks for overriding the default\n\t\t// behavior of getting and setting a style property\n\t\tcssHooks: {\n\t\t\topacity: {\n\t\t\t\tget: function get(elem, computed) {\n\t\t\t\t\tif (computed) {\n\n\t\t\t\t\t\t// We should always get a number back from opacity\n\t\t\t\t\t\tvar ret = curCSS(elem, \"opacity\");\n\t\t\t\t\t\treturn ret === \"\" ? \"1\" : ret;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// Don't automatically add \"px\" to these possibly-unitless properties\n\t\tcssNumber: {\n\t\t\t\"columnCount\": true,\n\t\t\t\"fillOpacity\": true,\n\t\t\t\"flexGrow\": true,\n\t\t\t\"flexShrink\": true,\n\t\t\t\"fontWeight\": true,\n\t\t\t\"lineHeight\": true,\n\t\t\t\"opacity\": true,\n\t\t\t\"order\": true,\n\t\t\t\"orphans\": true,\n\t\t\t\"widows\": true,\n\t\t\t\"zIndex\": true,\n\t\t\t\"zoom\": true\n\t\t},\n\n\t\t// Add in properties whose names you wish to fix before\n\t\t// setting or getting the value\n\t\tcssProps: {\n\t\t\t\"float\": \"cssFloat\"\n\t\t},\n\n\t\t// Get and set the style property on a DOM Node\n\t\tstyle: function style(elem, name, value, extra) {\n\n\t\t\t// Don't set styles on text and comment nodes\n\t\t\tif (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Make sure that we're working with the right name\n\t\t\tvar ret,\n\t\t\t    type,\n\t\t\t    hooks,\n\t\t\t    origName = jQuery.camelCase(name),\n\t\t\t    style = elem.style;\n\n\t\t\tname = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(style, origName));\n\n\t\t\t// Gets hook for the prefixed version, then unprefixed version\n\t\t\thooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];\n\n\t\t\t// Check if we're setting a value\n\t\t\tif (value !== undefined) {\n\t\t\t\ttype = typeof value === \"undefined\" ? \"undefined\" : _typeof(value);\n\n\t\t\t\t// Convert \"+=\" or \"-=\" to relative numbers (#7345)\n\t\t\t\tif (type === \"string\" && (ret = rrelNum.exec(value))) {\n\t\t\t\t\tvalue = (ret[1] + 1) * ret[2] + parseFloat(jQuery.css(elem, name));\n\t\t\t\t\t// Fixes bug #9237\n\t\t\t\t\ttype = \"number\";\n\t\t\t\t}\n\n\t\t\t\t// Make sure that null and NaN values aren't set (#7116)\n\t\t\t\tif (value == null || value !== value) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// If a number, add 'px' to the (except for certain CSS properties)\n\t\t\t\tif (type === \"number\" && !jQuery.cssNumber[origName]) {\n\t\t\t\t\tvalue += \"px\";\n\t\t\t\t}\n\n\t\t\t\t// Support: IE9-11+\n\t\t\t\t// background-* props affect original clone's values\n\t\t\t\tif (!support.clearCloneStyle && value === \"\" && name.indexOf(\"background\") === 0) {\n\t\t\t\t\tstyle[name] = \"inherit\";\n\t\t\t\t}\n\n\t\t\t\t// If a hook was provided, use that value, otherwise just set the specified value\n\t\t\t\tif (!hooks || !(\"set\" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {\n\t\t\t\t\tstyle[name] = value;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// If a hook was provided get the non-computed value from there\n\t\t\t\tif (hooks && \"get\" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\t// Otherwise just get the value from the style object\n\t\t\t\treturn style[name];\n\t\t\t}\n\t\t},\n\n\t\tcss: function css(elem, name, extra, styles) {\n\t\t\tvar val,\n\t\t\t    num,\n\t\t\t    hooks,\n\t\t\t    origName = jQuery.camelCase(name);\n\n\t\t\t// Make sure that we're working with the right name\n\t\t\tname = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(elem.style, origName));\n\n\t\t\t// Try prefixed name followed by the unprefixed name\n\t\t\thooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];\n\n\t\t\t// If a hook was provided get the computed value from there\n\t\t\tif (hooks && \"get\" in hooks) {\n\t\t\t\tval = hooks.get(elem, true, extra);\n\t\t\t}\n\n\t\t\t// Otherwise, if a way to get the computed value exists, use that\n\t\t\tif (val === undefined) {\n\t\t\t\tval = curCSS(elem, name, styles);\n\t\t\t}\n\n\t\t\t// Convert \"normal\" to computed value\n\t\t\tif (val === \"normal\" && name in cssNormalTransform) {\n\t\t\t\tval = cssNormalTransform[name];\n\t\t\t}\n\n\t\t\t// Make numeric if forced or a qualifier was provided and val looks numeric\n\t\t\tif (extra === \"\" || extra) {\n\t\t\t\tnum = parseFloat(val);\n\t\t\t\treturn extra === true || jQuery.isNumeric(num) ? num || 0 : val;\n\t\t\t}\n\t\t\treturn val;\n\t\t}\n\t});\n\n\tjQuery.each([\"height\", \"width\"], function (i, name) {\n\t\tjQuery.cssHooks[name] = {\n\t\t\tget: function get(elem, computed, extra) {\n\t\t\t\tif (computed) {\n\n\t\t\t\t\t// Certain elements can have dimension info if we invisibly show them\n\t\t\t\t\t// but it must have a current display style that would benefit\n\t\t\t\t\treturn rdisplayswap.test(jQuery.css(elem, \"display\")) && elem.offsetWidth === 0 ? jQuery.swap(elem, cssShow, function () {\n\t\t\t\t\t\treturn getWidthOrHeight(elem, name, extra);\n\t\t\t\t\t}) : getWidthOrHeight(elem, name, extra);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tset: function set(elem, value, extra) {\n\t\t\t\tvar styles = extra && getStyles(elem);\n\t\t\t\treturn setPositiveNumber(elem, value, extra ? augmentWidthOrHeight(elem, name, extra, jQuery.css(elem, \"boxSizing\", false, styles) === \"border-box\", styles) : 0);\n\t\t\t}\n\t\t};\n\t});\n\n\t// Support: Android 2.3\n\tjQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight, function (elem, computed) {\n\t\tif (computed) {\n\t\t\treturn jQuery.swap(elem, { \"display\": \"inline-block\" }, curCSS, [elem, \"marginRight\"]);\n\t\t}\n\t});\n\n\t// These hooks are used by animate to expand properties\n\tjQuery.each({\n\t\tmargin: \"\",\n\t\tpadding: \"\",\n\t\tborder: \"Width\"\n\t}, function (prefix, suffix) {\n\t\tjQuery.cssHooks[prefix + suffix] = {\n\t\t\texpand: function expand(value) {\n\t\t\t\tvar i = 0,\n\t\t\t\t    expanded = {},\n\n\n\t\t\t\t// Assumes a single number if not a string\n\t\t\t\tparts = typeof value === \"string\" ? value.split(\" \") : [value];\n\n\t\t\t\tfor (; i < 4; i++) {\n\t\t\t\t\texpanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];\n\t\t\t\t}\n\n\t\t\t\treturn expanded;\n\t\t\t}\n\t\t};\n\n\t\tif (!rmargin.test(prefix)) {\n\t\t\tjQuery.cssHooks[prefix + suffix].set = setPositiveNumber;\n\t\t}\n\t});\n\n\tjQuery.fn.extend({\n\t\tcss: function css(name, value) {\n\t\t\treturn access(this, function (elem, name, value) {\n\t\t\t\tvar styles,\n\t\t\t\t    len,\n\t\t\t\t    map = {},\n\t\t\t\t    i = 0;\n\n\t\t\t\tif (jQuery.isArray(name)) {\n\t\t\t\t\tstyles = getStyles(elem);\n\t\t\t\t\tlen = name.length;\n\n\t\t\t\t\tfor (; i < len; i++) {\n\t\t\t\t\t\tmap[name[i]] = jQuery.css(elem, name[i], false, styles);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn map;\n\t\t\t\t}\n\n\t\t\t\treturn value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);\n\t\t\t}, name, value, arguments.length > 1);\n\t\t},\n\t\tshow: function show() {\n\t\t\treturn showHide(this, true);\n\t\t},\n\t\thide: function hide() {\n\t\t\treturn showHide(this);\n\t\t},\n\t\ttoggle: function toggle(state) {\n\t\t\tif (typeof state === \"boolean\") {\n\t\t\t\treturn state ? this.show() : this.hide();\n\t\t\t}\n\n\t\t\treturn this.each(function () {\n\t\t\t\tif (isHidden(this)) {\n\t\t\t\t\tjQuery(this).show();\n\t\t\t\t} else {\n\t\t\t\t\tjQuery(this).hide();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t});\n\n\tfunction Tween(elem, options, prop, end, easing) {\n\t\treturn new Tween.prototype.init(elem, options, prop, end, easing);\n\t}\n\tjQuery.Tween = Tween;\n\n\tTween.prototype = {\n\t\tconstructor: Tween,\n\t\tinit: function init(elem, options, prop, end, easing, unit) {\n\t\t\tthis.elem = elem;\n\t\t\tthis.prop = prop;\n\t\t\tthis.easing = easing || \"swing\";\n\t\t\tthis.options = options;\n\t\t\tthis.start = this.now = this.cur();\n\t\t\tthis.end = end;\n\t\t\tthis.unit = unit || (jQuery.cssNumber[prop] ? \"\" : \"px\");\n\t\t},\n\t\tcur: function cur() {\n\t\t\tvar hooks = Tween.propHooks[this.prop];\n\n\t\t\treturn hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);\n\t\t},\n\t\trun: function run(percent) {\n\t\t\tvar eased,\n\t\t\t    hooks = Tween.propHooks[this.prop];\n\n\t\t\tif (this.options.duration) {\n\t\t\t\tthis.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);\n\t\t\t} else {\n\t\t\t\tthis.pos = eased = percent;\n\t\t\t}\n\t\t\tthis.now = (this.end - this.start) * eased + this.start;\n\n\t\t\tif (this.options.step) {\n\t\t\t\tthis.options.step.call(this.elem, this.now, this);\n\t\t\t}\n\n\t\t\tif (hooks && hooks.set) {\n\t\t\t\thooks.set(this);\n\t\t\t} else {\n\t\t\t\tTween.propHooks._default.set(this);\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t};\n\n\tTween.prototype.init.prototype = Tween.prototype;\n\n\tTween.propHooks = {\n\t\t_default: {\n\t\t\tget: function get(tween) {\n\t\t\t\tvar result;\n\n\t\t\t\tif (tween.elem[tween.prop] != null && (!tween.elem.style || tween.elem.style[tween.prop] == null)) {\n\t\t\t\t\treturn tween.elem[tween.prop];\n\t\t\t\t}\n\n\t\t\t\t// Passing an empty string as a 3rd parameter to .css will automatically\n\t\t\t\t// attempt a parseFloat and fallback to a string if the parse fails.\n\t\t\t\t// Simple values such as \"10px\" are parsed to Float;\n\t\t\t\t// complex values such as \"rotate(1rad)\" are returned as-is.\n\t\t\t\tresult = jQuery.css(tween.elem, tween.prop, \"\");\n\t\t\t\t// Empty strings, null, undefined and \"auto\" are converted to 0.\n\t\t\t\treturn !result || result === \"auto\" ? 0 : result;\n\t\t\t},\n\t\t\tset: function set(tween) {\n\t\t\t\t// Use step hook for back compat.\n\t\t\t\t// Use cssHook if its there.\n\t\t\t\t// Use .style if available and use plain properties where available.\n\t\t\t\tif (jQuery.fx.step[tween.prop]) {\n\t\t\t\t\tjQuery.fx.step[tween.prop](tween);\n\t\t\t\t} else if (tween.elem.style && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {\n\t\t\t\t\tjQuery.style(tween.elem, tween.prop, tween.now + tween.unit);\n\t\t\t\t} else {\n\t\t\t\t\ttween.elem[tween.prop] = tween.now;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t// Support: IE9\n\t// Panic based approach to setting things on disconnected nodes\n\tTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n\t\tset: function set(tween) {\n\t\t\tif (tween.elem.nodeType && tween.elem.parentNode) {\n\t\t\t\ttween.elem[tween.prop] = tween.now;\n\t\t\t}\n\t\t}\n\t};\n\n\tjQuery.easing = {\n\t\tlinear: function linear(p) {\n\t\t\treturn p;\n\t\t},\n\t\tswing: function swing(p) {\n\t\t\treturn 0.5 - Math.cos(p * Math.PI) / 2;\n\t\t}\n\t};\n\n\tjQuery.fx = Tween.prototype.init;\n\n\t// Back Compat <1.8 extension point\n\tjQuery.fx.step = {};\n\n\tvar fxNow,\n\t    timerId,\n\t    rfxtypes = /^(?:toggle|show|hide)$/,\n\t    rfxnum = new RegExp(\"^(?:([+-])=|)(\" + pnum + \")([a-z%]*)$\", \"i\"),\n\t    rrun = /queueHooks$/,\n\t    animationPrefilters = [defaultPrefilter],\n\t    tweeners = {\n\t\t\"*\": [function (prop, value) {\n\t\t\tvar tween = this.createTween(prop, value),\n\t\t\t    target = tween.cur(),\n\t\t\t    parts = rfxnum.exec(value),\n\t\t\t    unit = parts && parts[3] || (jQuery.cssNumber[prop] ? \"\" : \"px\"),\n\n\n\t\t\t// Starting value computation is required for potential unit mismatches\n\t\t\tstart = (jQuery.cssNumber[prop] || unit !== \"px\" && +target) && rfxnum.exec(jQuery.css(tween.elem, prop)),\n\t\t\t    scale = 1,\n\t\t\t    maxIterations = 20;\n\n\t\t\tif (start && start[3] !== unit) {\n\t\t\t\t// Trust units reported by jQuery.css\n\t\t\t\tunit = unit || start[3];\n\n\t\t\t\t// Make sure we update the tween properties later on\n\t\t\t\tparts = parts || [];\n\n\t\t\t\t// Iteratively approximate from a nonzero starting point\n\t\t\t\tstart = +target || 1;\n\n\t\t\t\tdo {\n\t\t\t\t\t// If previous iteration zeroed out, double until we get *something*.\n\t\t\t\t\t// Use string for doubling so we don't accidentally see scale as unchanged below\n\t\t\t\t\tscale = scale || \".5\";\n\n\t\t\t\t\t// Adjust and apply\n\t\t\t\t\tstart = start / scale;\n\t\t\t\t\tjQuery.style(tween.elem, prop, start + unit);\n\n\t\t\t\t\t// Update scale, tolerating zero or NaN from tween.cur(),\n\t\t\t\t\t// break the loop if scale is unchanged or perfect, or if we've just had enough\n\t\t\t\t} while (scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations);\n\t\t\t}\n\n\t\t\t// Update tween properties\n\t\t\tif (parts) {\n\t\t\t\tstart = tween.start = +start || +target || 0;\n\t\t\t\ttween.unit = unit;\n\t\t\t\t// If a +=/-= token was provided, we're doing a relative animation\n\t\t\t\ttween.end = parts[1] ? start + (parts[1] + 1) * parts[2] : +parts[2];\n\t\t\t}\n\n\t\t\treturn tween;\n\t\t}]\n\t};\n\n\t// Animations created synchronously will run synchronously\n\tfunction createFxNow() {\n\t\tsetTimeout(function () {\n\t\t\tfxNow = undefined;\n\t\t});\n\t\treturn fxNow = jQuery.now();\n\t}\n\n\t// Generate parameters to create a standard animation\n\tfunction genFx(type, includeWidth) {\n\t\tvar which,\n\t\t    i = 0,\n\t\t    attrs = { height: type };\n\n\t\t// If we include width, step value is 1 to do all cssExpand values,\n\t\t// otherwise step value is 2 to skip over Left and Right\n\t\tincludeWidth = includeWidth ? 1 : 0;\n\t\tfor (; i < 4; i += 2 - includeWidth) {\n\t\t\twhich = cssExpand[i];\n\t\t\tattrs[\"margin\" + which] = attrs[\"padding\" + which] = type;\n\t\t}\n\n\t\tif (includeWidth) {\n\t\t\tattrs.opacity = attrs.width = type;\n\t\t}\n\n\t\treturn attrs;\n\t}\n\n\tfunction createTween(value, prop, animation) {\n\t\tvar tween,\n\t\t    collection = (tweeners[prop] || []).concat(tweeners[\"*\"]),\n\t\t    index = 0,\n\t\t    length = collection.length;\n\t\tfor (; index < length; index++) {\n\t\t\tif (tween = collection[index].call(animation, prop, value)) {\n\n\t\t\t\t// We're done with this property\n\t\t\t\treturn tween;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction defaultPrefilter(elem, props, opts) {\n\t\t/* jshint validthis: true */\n\t\tvar prop,\n\t\t    value,\n\t\t    toggle,\n\t\t    tween,\n\t\t    hooks,\n\t\t    oldfire,\n\t\t    display,\n\t\t    checkDisplay,\n\t\t    anim = this,\n\t\t    orig = {},\n\t\t    style = elem.style,\n\t\t    hidden = elem.nodeType && isHidden(elem),\n\t\t    dataShow = data_priv.get(elem, \"fxshow\");\n\n\t\t// Handle queue: false promises\n\t\tif (!opts.queue) {\n\t\t\thooks = jQuery._queueHooks(elem, \"fx\");\n\t\t\tif (hooks.unqueued == null) {\n\t\t\t\thooks.unqueued = 0;\n\t\t\t\toldfire = hooks.empty.fire;\n\t\t\t\thooks.empty.fire = function () {\n\t\t\t\t\tif (!hooks.unqueued) {\n\t\t\t\t\t\toldfire();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t\thooks.unqueued++;\n\n\t\t\tanim.always(function () {\n\t\t\t\t// Ensure the complete handler is called before this completes\n\t\t\t\tanim.always(function () {\n\t\t\t\t\thooks.unqueued--;\n\t\t\t\t\tif (!jQuery.queue(elem, \"fx\").length) {\n\t\t\t\t\t\thooks.empty.fire();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\t// Height/width overflow pass\n\t\tif (elem.nodeType === 1 && (\"height\" in props || \"width\" in props)) {\n\t\t\t// Make sure that nothing sneaks out\n\t\t\t// Record all 3 overflow attributes because IE9-10 do not\n\t\t\t// change the overflow attribute when overflowX and\n\t\t\t// overflowY are set to the same value\n\t\t\topts.overflow = [style.overflow, style.overflowX, style.overflowY];\n\n\t\t\t// Set display property to inline-block for height/width\n\t\t\t// animations on inline elements that are having width/height animated\n\t\t\tdisplay = jQuery.css(elem, \"display\");\n\n\t\t\t// Test default display if display is currently \"none\"\n\t\t\tcheckDisplay = display === \"none\" ? data_priv.get(elem, \"olddisplay\") || defaultDisplay(elem.nodeName) : display;\n\n\t\t\tif (checkDisplay === \"inline\" && jQuery.css(elem, \"float\") === \"none\") {\n\t\t\t\tstyle.display = \"inline-block\";\n\t\t\t}\n\t\t}\n\n\t\tif (opts.overflow) {\n\t\t\tstyle.overflow = \"hidden\";\n\t\t\tanim.always(function () {\n\t\t\t\tstyle.overflow = opts.overflow[0];\n\t\t\t\tstyle.overflowX = opts.overflow[1];\n\t\t\t\tstyle.overflowY = opts.overflow[2];\n\t\t\t});\n\t\t}\n\n\t\t// show/hide pass\n\t\tfor (prop in props) {\n\t\t\tvalue = props[prop];\n\t\t\tif (rfxtypes.exec(value)) {\n\t\t\t\tdelete props[prop];\n\t\t\t\ttoggle = toggle || value === \"toggle\";\n\t\t\t\tif (value === (hidden ? \"hide\" : \"show\")) {\n\n\t\t\t\t\t// If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden\n\t\t\t\t\tif (value === \"show\" && dataShow && dataShow[prop] !== undefined) {\n\t\t\t\t\t\thidden = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\torig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);\n\n\t\t\t\t// Any non-fx value stops us from restoring the original display value\n\t\t\t} else {\n\t\t\t\tdisplay = undefined;\n\t\t\t}\n\t\t}\n\n\t\tif (!jQuery.isEmptyObject(orig)) {\n\t\t\tif (dataShow) {\n\t\t\t\tif (\"hidden\" in dataShow) {\n\t\t\t\t\thidden = dataShow.hidden;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdataShow = data_priv.access(elem, \"fxshow\", {});\n\t\t\t}\n\n\t\t\t// Store state if its toggle - enables .stop().toggle() to \"reverse\"\n\t\t\tif (toggle) {\n\t\t\t\tdataShow.hidden = !hidden;\n\t\t\t}\n\t\t\tif (hidden) {\n\t\t\t\tjQuery(elem).show();\n\t\t\t} else {\n\t\t\t\tanim.done(function () {\n\t\t\t\t\tjQuery(elem).hide();\n\t\t\t\t});\n\t\t\t}\n\t\t\tanim.done(function () {\n\t\t\t\tvar prop;\n\n\t\t\t\tdata_priv.remove(elem, \"fxshow\");\n\t\t\t\tfor (prop in orig) {\n\t\t\t\t\tjQuery.style(elem, prop, orig[prop]);\n\t\t\t\t}\n\t\t\t});\n\t\t\tfor (prop in orig) {\n\t\t\t\ttween = createTween(hidden ? dataShow[prop] : 0, prop, anim);\n\n\t\t\t\tif (!(prop in dataShow)) {\n\t\t\t\t\tdataShow[prop] = tween.start;\n\t\t\t\t\tif (hidden) {\n\t\t\t\t\t\ttween.end = tween.start;\n\t\t\t\t\t\ttween.start = prop === \"width\" || prop === \"height\" ? 1 : 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If this is a noop like .hide().hide(), restore an overwritten display value\n\t\t} else if ((display === \"none\" ? defaultDisplay(elem.nodeName) : display) === \"inline\") {\n\t\t\tstyle.display = display;\n\t\t}\n\t}\n\n\tfunction propFilter(props, specialEasing) {\n\t\tvar index, name, easing, value, hooks;\n\n\t\t// camelCase, specialEasing and expand cssHook pass\n\t\tfor (index in props) {\n\t\t\tname = jQuery.camelCase(index);\n\t\t\teasing = specialEasing[name];\n\t\t\tvalue = props[index];\n\t\t\tif (jQuery.isArray(value)) {\n\t\t\t\teasing = value[1];\n\t\t\t\tvalue = props[index] = value[0];\n\t\t\t}\n\n\t\t\tif (index !== name) {\n\t\t\t\tprops[name] = value;\n\t\t\t\tdelete props[index];\n\t\t\t}\n\n\t\t\thooks = jQuery.cssHooks[name];\n\t\t\tif (hooks && \"expand\" in hooks) {\n\t\t\t\tvalue = hooks.expand(value);\n\t\t\t\tdelete props[name];\n\n\t\t\t\t// Not quite $.extend, this won't overwrite existing keys.\n\t\t\t\t// Reusing 'index' because we have the correct \"name\"\n\t\t\t\tfor (index in value) {\n\t\t\t\t\tif (!(index in props)) {\n\t\t\t\t\t\tprops[index] = value[index];\n\t\t\t\t\t\tspecialEasing[index] = easing;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tspecialEasing[name] = easing;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction Animation(elem, properties, options) {\n\t\tvar result,\n\t\t    stopped,\n\t\t    index = 0,\n\t\t    length = animationPrefilters.length,\n\t\t    deferred = jQuery.Deferred().always(function () {\n\t\t\t// Don't match elem in the :animated selector\n\t\t\tdelete tick.elem;\n\t\t}),\n\t\t    tick = function tick() {\n\t\t\tif (stopped) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar currentTime = fxNow || createFxNow(),\n\t\t\t    remaining = Math.max(0, animation.startTime + animation.duration - currentTime),\n\n\t\t\t// Support: Android 2.3\n\t\t\t// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)\n\t\t\ttemp = remaining / animation.duration || 0,\n\t\t\t    percent = 1 - temp,\n\t\t\t    index = 0,\n\t\t\t    length = animation.tweens.length;\n\n\t\t\tfor (; index < length; index++) {\n\t\t\t\tanimation.tweens[index].run(percent);\n\t\t\t}\n\n\t\t\tdeferred.notifyWith(elem, [animation, percent, remaining]);\n\n\t\t\tif (percent < 1 && length) {\n\t\t\t\treturn remaining;\n\t\t\t} else {\n\t\t\t\tdeferred.resolveWith(elem, [animation]);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\t    animation = deferred.promise({\n\t\t\telem: elem,\n\t\t\tprops: jQuery.extend({}, properties),\n\t\t\topts: jQuery.extend(true, { specialEasing: {} }, options),\n\t\t\toriginalProperties: properties,\n\t\t\toriginalOptions: options,\n\t\t\tstartTime: fxNow || createFxNow(),\n\t\t\tduration: options.duration,\n\t\t\ttweens: [],\n\t\t\tcreateTween: function createTween(prop, end) {\n\t\t\t\tvar tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);\n\t\t\t\tanimation.tweens.push(tween);\n\t\t\t\treturn tween;\n\t\t\t},\n\t\t\tstop: function stop(gotoEnd) {\n\t\t\t\tvar index = 0,\n\n\t\t\t\t// If we are going to the end, we want to run all the tweens\n\t\t\t\t// otherwise we skip this part\n\t\t\t\tlength = gotoEnd ? animation.tweens.length : 0;\n\t\t\t\tif (stopped) {\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\tstopped = true;\n\t\t\t\tfor (; index < length; index++) {\n\t\t\t\t\tanimation.tweens[index].run(1);\n\t\t\t\t}\n\n\t\t\t\t// Resolve when we played the last frame; otherwise, reject\n\t\t\t\tif (gotoEnd) {\n\t\t\t\t\tdeferred.resolveWith(elem, [animation, gotoEnd]);\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.rejectWith(elem, [animation, gotoEnd]);\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}),\n\t\t    props = animation.props;\n\n\t\tpropFilter(props, animation.opts.specialEasing);\n\n\t\tfor (; index < length; index++) {\n\t\t\tresult = animationPrefilters[index].call(animation, elem, props, animation.opts);\n\t\t\tif (result) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\tjQuery.map(props, createTween, animation);\n\n\t\tif (jQuery.isFunction(animation.opts.start)) {\n\t\t\tanimation.opts.start.call(elem, animation);\n\t\t}\n\n\t\tjQuery.fx.timer(jQuery.extend(tick, {\n\t\t\telem: elem,\n\t\t\tanim: animation,\n\t\t\tqueue: animation.opts.queue\n\t\t}));\n\n\t\t// attach callbacks from options\n\t\treturn animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);\n\t}\n\n\tjQuery.Animation = jQuery.extend(Animation, {\n\n\t\ttweener: function tweener(props, callback) {\n\t\t\tif (jQuery.isFunction(props)) {\n\t\t\t\tcallback = props;\n\t\t\t\tprops = [\"*\"];\n\t\t\t} else {\n\t\t\t\tprops = props.split(\" \");\n\t\t\t}\n\n\t\t\tvar prop,\n\t\t\t    index = 0,\n\t\t\t    length = props.length;\n\n\t\t\tfor (; index < length; index++) {\n\t\t\t\tprop = props[index];\n\t\t\t\ttweeners[prop] = tweeners[prop] || [];\n\t\t\t\ttweeners[prop].unshift(callback);\n\t\t\t}\n\t\t},\n\n\t\tprefilter: function prefilter(callback, prepend) {\n\t\t\tif (prepend) {\n\t\t\t\tanimationPrefilters.unshift(callback);\n\t\t\t} else {\n\t\t\t\tanimationPrefilters.push(callback);\n\t\t\t}\n\t\t}\n\t});\n\n\tjQuery.speed = function (speed, easing, fn) {\n\t\tvar opt = speed && (typeof speed === \"undefined\" ? \"undefined\" : _typeof(speed)) === \"object\" ? jQuery.extend({}, speed) : {\n\t\t\tcomplete: fn || !fn && easing || jQuery.isFunction(speed) && speed,\n\t\t\tduration: speed,\n\t\t\teasing: fn && easing || easing && !jQuery.isFunction(easing) && easing\n\t\t};\n\n\t\topt.duration = jQuery.fx.off ? 0 : typeof opt.duration === \"number\" ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;\n\n\t\t// Normalize opt.queue - true/undefined/null -> \"fx\"\n\t\tif (opt.queue == null || opt.queue === true) {\n\t\t\topt.queue = \"fx\";\n\t\t}\n\n\t\t// Queueing\n\t\topt.old = opt.complete;\n\n\t\topt.complete = function () {\n\t\t\tif (jQuery.isFunction(opt.old)) {\n\t\t\t\topt.old.call(this);\n\t\t\t}\n\n\t\t\tif (opt.queue) {\n\t\t\t\tjQuery.dequeue(this, opt.queue);\n\t\t\t}\n\t\t};\n\n\t\treturn opt;\n\t};\n\n\tjQuery.fn.extend({\n\t\tfadeTo: function fadeTo(speed, to, easing, callback) {\n\n\t\t\t// Show any hidden elements after setting opacity to 0\n\t\t\treturn this.filter(isHidden).css(\"opacity\", 0).show()\n\n\t\t\t// Animate to the value specified\n\t\t\t.end().animate({ opacity: to }, speed, easing, callback);\n\t\t},\n\t\tanimate: function animate(prop, speed, easing, callback) {\n\t\t\tvar empty = jQuery.isEmptyObject(prop),\n\t\t\t    optall = jQuery.speed(speed, easing, callback),\n\t\t\t    doAnimation = function doAnimation() {\n\t\t\t\t// Operate on a copy of prop so per-property easing won't be lost\n\t\t\t\tvar anim = Animation(this, jQuery.extend({}, prop), optall);\n\n\t\t\t\t// Empty animations, or finishing resolves immediately\n\t\t\t\tif (empty || data_priv.get(this, \"finish\")) {\n\t\t\t\t\tanim.stop(true);\n\t\t\t\t}\n\t\t\t};\n\t\t\tdoAnimation.finish = doAnimation;\n\n\t\t\treturn empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);\n\t\t},\n\t\tstop: function stop(type, clearQueue, gotoEnd) {\n\t\t\tvar stopQueue = function stopQueue(hooks) {\n\t\t\t\tvar stop = hooks.stop;\n\t\t\t\tdelete hooks.stop;\n\t\t\t\tstop(gotoEnd);\n\t\t\t};\n\n\t\t\tif (typeof type !== \"string\") {\n\t\t\t\tgotoEnd = clearQueue;\n\t\t\t\tclearQueue = type;\n\t\t\t\ttype = undefined;\n\t\t\t}\n\t\t\tif (clearQueue && type !== false) {\n\t\t\t\tthis.queue(type || \"fx\", []);\n\t\t\t}\n\n\t\t\treturn this.each(function () {\n\t\t\t\tvar dequeue = true,\n\t\t\t\t    index = type != null && type + \"queueHooks\",\n\t\t\t\t    timers = jQuery.timers,\n\t\t\t\t    data = data_priv.get(this);\n\n\t\t\t\tif (index) {\n\t\t\t\t\tif (data[index] && data[index].stop) {\n\t\t\t\t\t\tstopQueue(data[index]);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (index in data) {\n\t\t\t\t\t\tif (data[index] && data[index].stop && rrun.test(index)) {\n\t\t\t\t\t\t\tstopQueue(data[index]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (index = timers.length; index--;) {\n\t\t\t\t\tif (timers[index].elem === this && (type == null || timers[index].queue === type)) {\n\t\t\t\t\t\ttimers[index].anim.stop(gotoEnd);\n\t\t\t\t\t\tdequeue = false;\n\t\t\t\t\t\ttimers.splice(index, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Start the next in the queue if the last step wasn't forced.\n\t\t\t\t// Timers currently will call their complete callbacks, which\n\t\t\t\t// will dequeue but only if they were gotoEnd.\n\t\t\t\tif (dequeue || !gotoEnd) {\n\t\t\t\t\tjQuery.dequeue(this, type);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\tfinish: function finish(type) {\n\t\t\tif (type !== false) {\n\t\t\t\ttype = type || \"fx\";\n\t\t\t}\n\t\t\treturn this.each(function () {\n\t\t\t\tvar index,\n\t\t\t\t    data = data_priv.get(this),\n\t\t\t\t    queue = data[type + \"queue\"],\n\t\t\t\t    hooks = data[type + \"queueHooks\"],\n\t\t\t\t    timers = jQuery.timers,\n\t\t\t\t    length = queue ? queue.length : 0;\n\n\t\t\t\t// Enable finishing flag on private data\n\t\t\t\tdata.finish = true;\n\n\t\t\t\t// Empty the queue first\n\t\t\t\tjQuery.queue(this, type, []);\n\n\t\t\t\tif (hooks && hooks.stop) {\n\t\t\t\t\thooks.stop.call(this, true);\n\t\t\t\t}\n\n\t\t\t\t// Look for any active animations, and finish them\n\t\t\t\tfor (index = timers.length; index--;) {\n\t\t\t\t\tif (timers[index].elem === this && timers[index].queue === type) {\n\t\t\t\t\t\ttimers[index].anim.stop(true);\n\t\t\t\t\t\ttimers.splice(index, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Look for any animations in the old queue and finish them\n\t\t\t\tfor (index = 0; index < length; index++) {\n\t\t\t\t\tif (queue[index] && queue[index].finish) {\n\t\t\t\t\t\tqueue[index].finish.call(this);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Turn off finishing flag\n\t\t\t\tdelete data.finish;\n\t\t\t});\n\t\t}\n\t});\n\n\tjQuery.each([\"toggle\", \"show\", \"hide\"], function (i, name) {\n\t\tvar cssFn = jQuery.fn[name];\n\t\tjQuery.fn[name] = function (speed, easing, callback) {\n\t\t\treturn speed == null || typeof speed === \"boolean\" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);\n\t\t};\n\t});\n\n\t// Generate shortcuts for custom animations\n\tjQuery.each({\n\t\tslideDown: genFx(\"show\"),\n\t\tslideUp: genFx(\"hide\"),\n\t\tslideToggle: genFx(\"toggle\"),\n\t\tfadeIn: { opacity: \"show\" },\n\t\tfadeOut: { opacity: \"hide\" },\n\t\tfadeToggle: { opacity: \"toggle\" }\n\t}, function (name, props) {\n\t\tjQuery.fn[name] = function (speed, easing, callback) {\n\t\t\treturn this.animate(props, speed, easing, callback);\n\t\t};\n\t});\n\n\tjQuery.timers = [];\n\tjQuery.fx.tick = function () {\n\t\tvar timer,\n\t\t    i = 0,\n\t\t    timers = jQuery.timers;\n\n\t\tfxNow = jQuery.now();\n\n\t\tfor (; i < timers.length; i++) {\n\t\t\ttimer = timers[i];\n\t\t\t// Checks the timer has not already been removed\n\t\t\tif (!timer() && timers[i] === timer) {\n\t\t\t\ttimers.splice(i--, 1);\n\t\t\t}\n\t\t}\n\n\t\tif (!timers.length) {\n\t\t\tjQuery.fx.stop();\n\t\t}\n\t\tfxNow = undefined;\n\t};\n\n\tjQuery.fx.timer = function (timer) {\n\t\tjQuery.timers.push(timer);\n\t\tif (timer()) {\n\t\t\tjQuery.fx.start();\n\t\t} else {\n\t\t\tjQuery.timers.pop();\n\t\t}\n\t};\n\n\tjQuery.fx.interval = 13;\n\n\tjQuery.fx.start = function () {\n\t\tif (!timerId) {\n\t\t\ttimerId = setInterval(jQuery.fx.tick, jQuery.fx.interval);\n\t\t}\n\t};\n\n\tjQuery.fx.stop = function () {\n\t\tclearInterval(timerId);\n\t\ttimerId = null;\n\t};\n\n\tjQuery.fx.speeds = {\n\t\tslow: 600,\n\t\tfast: 200,\n\t\t// Default speed\n\t\t_default: 400\n\t};\n\n\t// Based off of the plugin by Clint Helfers, with permission.\n\t// http://blindsignals.com/index.php/2009/07/jquery-delay/\n\tjQuery.fn.delay = function (time, type) {\n\t\ttime = jQuery.fx ? jQuery.fx.speeds[time] || time : time;\n\t\ttype = type || \"fx\";\n\n\t\treturn this.queue(type, function (next, hooks) {\n\t\t\tvar timeout = setTimeout(next, time);\n\t\t\thooks.stop = function () {\n\t\t\t\tclearTimeout(timeout);\n\t\t\t};\n\t\t});\n\t};\n\n\t(function () {\n\t\tvar input = document.createElement(\"input\"),\n\t\t    select = document.createElement(\"select\"),\n\t\t    opt = select.appendChild(document.createElement(\"option\"));\n\n\t\tinput.type = \"checkbox\";\n\n\t\t// Support: iOS<=5.1, Android<=4.2+\n\t\t// Default value for a checkbox should be \"on\"\n\t\tsupport.checkOn = input.value !== \"\";\n\n\t\t// Support: IE<=11+\n\t\t// Must access selectedIndex to make default options select\n\t\tsupport.optSelected = opt.selected;\n\n\t\t// Support: Android<=2.3\n\t\t// Options inside disabled selects are incorrectly marked as disabled\n\t\tselect.disabled = true;\n\t\tsupport.optDisabled = !opt.disabled;\n\n\t\t// Support: IE<=11+\n\t\t// An input loses its value after becoming a radio\n\t\tinput = document.createElement(\"input\");\n\t\tinput.value = \"t\";\n\t\tinput.type = \"radio\";\n\t\tsupport.radioValue = input.value === \"t\";\n\t})();\n\n\tvar nodeHook,\n\t    boolHook,\n\t    attrHandle = jQuery.expr.attrHandle;\n\n\tjQuery.fn.extend({\n\t\tattr: function attr(name, value) {\n\t\t\treturn access(this, jQuery.attr, name, value, arguments.length > 1);\n\t\t},\n\n\t\tremoveAttr: function removeAttr(name) {\n\t\t\treturn this.each(function () {\n\t\t\t\tjQuery.removeAttr(this, name);\n\t\t\t});\n\t\t}\n\t});\n\n\tjQuery.extend({\n\t\tattr: function attr(elem, name, value) {\n\t\t\tvar hooks,\n\t\t\t    ret,\n\t\t\t    nType = elem.nodeType;\n\n\t\t\t// don't get/set attributes on text, comment and attribute nodes\n\t\t\tif (!elem || nType === 3 || nType === 8 || nType === 2) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Fallback to prop when attributes are not supported\n\t\t\tif (_typeof(elem.getAttribute) === strundefined) {\n\t\t\t\treturn jQuery.prop(elem, name, value);\n\t\t\t}\n\n\t\t\t// All attributes are lowercase\n\t\t\t// Grab necessary hook if one is defined\n\t\t\tif (nType !== 1 || !jQuery.isXMLDoc(elem)) {\n\t\t\t\tname = name.toLowerCase();\n\t\t\t\thooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : nodeHook);\n\t\t\t}\n\n\t\t\tif (value !== undefined) {\n\n\t\t\t\tif (value === null) {\n\t\t\t\t\tjQuery.removeAttr(elem, name);\n\t\t\t\t} else if (hooks && \"set\" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {\n\t\t\t\t\treturn ret;\n\t\t\t\t} else {\n\t\t\t\t\telem.setAttribute(name, value + \"\");\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t} else if (hooks && \"get\" in hooks && (ret = hooks.get(elem, name)) !== null) {\n\t\t\t\treturn ret;\n\t\t\t} else {\n\t\t\t\tret = jQuery.find.attr(elem, name);\n\n\t\t\t\t// Non-existent attributes return null, we normalize to undefined\n\t\t\t\treturn ret == null ? undefined : ret;\n\t\t\t}\n\t\t},\n\n\t\tremoveAttr: function removeAttr(elem, value) {\n\t\t\tvar name,\n\t\t\t    propName,\n\t\t\t    i = 0,\n\t\t\t    attrNames = value && value.match(rnotwhite);\n\n\t\t\tif (attrNames && elem.nodeType === 1) {\n\t\t\t\twhile (name = attrNames[i++]) {\n\t\t\t\t\tpropName = jQuery.propFix[name] || name;\n\n\t\t\t\t\t// Boolean attributes get special treatment (#10870)\n\t\t\t\t\tif (jQuery.expr.match.bool.test(name)) {\n\t\t\t\t\t\t// Set corresponding property to false\n\t\t\t\t\t\telem[propName] = false;\n\t\t\t\t\t}\n\n\t\t\t\t\telem.removeAttribute(name);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tattrHooks: {\n\t\t\ttype: {\n\t\t\t\tset: function set(elem, value) {\n\t\t\t\t\tif (!support.radioValue && value === \"radio\" && jQuery.nodeName(elem, \"input\")) {\n\t\t\t\t\t\tvar val = elem.value;\n\t\t\t\t\t\telem.setAttribute(\"type\", value);\n\t\t\t\t\t\tif (val) {\n\t\t\t\t\t\t\telem.value = val;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\t// Hooks for boolean attributes\n\tboolHook = {\n\t\tset: function set(elem, value, name) {\n\t\t\tif (value === false) {\n\t\t\t\t// Remove boolean attributes when set to false\n\t\t\t\tjQuery.removeAttr(elem, name);\n\t\t\t} else {\n\t\t\t\telem.setAttribute(name, name);\n\t\t\t}\n\t\t\treturn name;\n\t\t}\n\t};\n\tjQuery.each(jQuery.expr.match.bool.source.match(/\\w+/g), function (i, name) {\n\t\tvar getter = attrHandle[name] || jQuery.find.attr;\n\n\t\tattrHandle[name] = function (elem, name, isXML) {\n\t\t\tvar ret, handle;\n\t\t\tif (!isXML) {\n\t\t\t\t// Avoid an infinite loop by temporarily removing this function from the getter\n\t\t\t\thandle = attrHandle[name];\n\t\t\t\tattrHandle[name] = ret;\n\t\t\t\tret = getter(elem, name, isXML) != null ? name.toLowerCase() : null;\n\t\t\t\tattrHandle[name] = handle;\n\t\t\t}\n\t\t\treturn ret;\n\t\t};\n\t});\n\n\tvar rfocusable = /^(?:input|select|textarea|button)$/i;\n\n\tjQuery.fn.extend({\n\t\tprop: function prop(name, value) {\n\t\t\treturn access(this, jQuery.prop, name, value, arguments.length > 1);\n\t\t},\n\n\t\tremoveProp: function removeProp(name) {\n\t\t\treturn this.each(function () {\n\t\t\t\tdelete this[jQuery.propFix[name] || name];\n\t\t\t});\n\t\t}\n\t});\n\n\tjQuery.extend({\n\t\tpropFix: {\n\t\t\t\"for\": \"htmlFor\",\n\t\t\t\"class\": \"className\"\n\t\t},\n\n\t\tprop: function prop(elem, name, value) {\n\t\t\tvar ret,\n\t\t\t    hooks,\n\t\t\t    notxml,\n\t\t\t    nType = elem.nodeType;\n\n\t\t\t// Don't get/set properties on text, comment and attribute nodes\n\t\t\tif (!elem || nType === 3 || nType === 8 || nType === 2) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tnotxml = nType !== 1 || !jQuery.isXMLDoc(elem);\n\n\t\t\tif (notxml) {\n\t\t\t\t// Fix name and attach hooks\n\t\t\t\tname = jQuery.propFix[name] || name;\n\t\t\t\thooks = jQuery.propHooks[name];\n\t\t\t}\n\n\t\t\tif (value !== undefined) {\n\t\t\t\treturn hooks && \"set\" in hooks && (ret = hooks.set(elem, value, name)) !== undefined ? ret : elem[name] = value;\n\t\t\t} else {\n\t\t\t\treturn hooks && \"get\" in hooks && (ret = hooks.get(elem, name)) !== null ? ret : elem[name];\n\t\t\t}\n\t\t},\n\n\t\tpropHooks: {\n\t\t\ttabIndex: {\n\t\t\t\tget: function get(elem) {\n\t\t\t\t\treturn elem.hasAttribute(\"tabindex\") || rfocusable.test(elem.nodeName) || elem.href ? elem.tabIndex : -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\tif (!support.optSelected) {\n\t\tjQuery.propHooks.selected = {\n\t\t\tget: function get(elem) {\n\t\t\t\tvar parent = elem.parentNode;\n\t\t\t\tif (parent && parent.parentNode) {\n\t\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t};\n\t}\n\n\tjQuery.each([\"tabIndex\", \"readOnly\", \"maxLength\", \"cellSpacing\", \"cellPadding\", \"rowSpan\", \"colSpan\", \"useMap\", \"frameBorder\", \"contentEditable\"], function () {\n\t\tjQuery.propFix[this.toLowerCase()] = this;\n\t});\n\n\tvar rclass = /[\\t\\r\\n\\f]/g;\n\n\tjQuery.fn.extend({\n\t\taddClass: function addClass(value) {\n\t\t\tvar classes,\n\t\t\t    elem,\n\t\t\t    cur,\n\t\t\t    clazz,\n\t\t\t    j,\n\t\t\t    finalValue,\n\t\t\t    proceed = typeof value === \"string\" && value,\n\t\t\t    i = 0,\n\t\t\t    len = this.length;\n\n\t\t\tif (jQuery.isFunction(value)) {\n\t\t\t\treturn this.each(function (j) {\n\t\t\t\t\tjQuery(this).addClass(value.call(this, j, this.className));\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (proceed) {\n\t\t\t\t// The disjunction here is for better compressibility (see removeClass)\n\t\t\t\tclasses = (value || \"\").match(rnotwhite) || [];\n\n\t\t\t\tfor (; i < len; i++) {\n\t\t\t\t\telem = this[i];\n\t\t\t\t\tcur = elem.nodeType === 1 && (elem.className ? (\" \" + elem.className + \" \").replace(rclass, \" \") : \" \");\n\n\t\t\t\t\tif (cur) {\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\t\twhile (clazz = classes[j++]) {\n\t\t\t\t\t\t\tif (cur.indexOf(\" \" + clazz + \" \") < 0) {\n\t\t\t\t\t\t\t\tcur += clazz + \" \";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// only assign if different to avoid unneeded rendering.\n\t\t\t\t\t\tfinalValue = jQuery.trim(cur);\n\t\t\t\t\t\tif (elem.className !== finalValue) {\n\t\t\t\t\t\t\telem.className = finalValue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\tremoveClass: function removeClass(value) {\n\t\t\tvar classes,\n\t\t\t    elem,\n\t\t\t    cur,\n\t\t\t    clazz,\n\t\t\t    j,\n\t\t\t    finalValue,\n\t\t\t    proceed = arguments.length === 0 || typeof value === \"string\" && value,\n\t\t\t    i = 0,\n\t\t\t    len = this.length;\n\n\t\t\tif (jQuery.isFunction(value)) {\n\t\t\t\treturn this.each(function (j) {\n\t\t\t\t\tjQuery(this).removeClass(value.call(this, j, this.className));\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (proceed) {\n\t\t\t\tclasses = (value || \"\").match(rnotwhite) || [];\n\n\t\t\t\tfor (; i < len; i++) {\n\t\t\t\t\telem = this[i];\n\t\t\t\t\t// This expression is here for better compressibility (see addClass)\n\t\t\t\t\tcur = elem.nodeType === 1 && (elem.className ? (\" \" + elem.className + \" \").replace(rclass, \" \") : \"\");\n\n\t\t\t\t\tif (cur) {\n\t\t\t\t\t\tj = 0;\n\t\t\t\t\t\twhile (clazz = classes[j++]) {\n\t\t\t\t\t\t\t// Remove *all* instances\n\t\t\t\t\t\t\twhile (cur.indexOf(\" \" + clazz + \" \") >= 0) {\n\t\t\t\t\t\t\t\tcur = cur.replace(\" \" + clazz + \" \", \" \");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\t\tfinalValue = value ? jQuery.trim(cur) : \"\";\n\t\t\t\t\t\tif (elem.className !== finalValue) {\n\t\t\t\t\t\t\telem.className = finalValue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\ttoggleClass: function toggleClass(value, stateVal) {\n\t\t\tvar type = typeof value === \"undefined\" ? \"undefined\" : _typeof(value);\n\n\t\t\tif (typeof stateVal === \"boolean\" && type === \"string\") {\n\t\t\t\treturn stateVal ? this.addClass(value) : this.removeClass(value);\n\t\t\t}\n\n\t\t\tif (jQuery.isFunction(value)) {\n\t\t\t\treturn this.each(function (i) {\n\t\t\t\t\tjQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn this.each(function () {\n\t\t\t\tif (type === \"string\") {\n\t\t\t\t\t// Toggle individual class names\n\t\t\t\t\tvar className,\n\t\t\t\t\t    i = 0,\n\t\t\t\t\t    self = jQuery(this),\n\t\t\t\t\t    classNames = value.match(rnotwhite) || [];\n\n\t\t\t\t\twhile (className = classNames[i++]) {\n\t\t\t\t\t\t// Check each className given, space separated list\n\t\t\t\t\t\tif (self.hasClass(className)) {\n\t\t\t\t\t\t\tself.removeClass(className);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tself.addClass(className);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Toggle whole class name\n\t\t\t\t} else if (type === strundefined || type === \"boolean\") {\n\t\t\t\t\tif (this.className) {\n\t\t\t\t\t\t// store className if set\n\t\t\t\t\t\tdata_priv.set(this, \"__className__\", this.className);\n\t\t\t\t\t}\n\n\t\t\t\t\t// If the element has a class name or if we're passed `false`,\n\t\t\t\t\t// then remove the whole classname (if there was one, the above saved it).\n\t\t\t\t\t// Otherwise bring back whatever was previously saved (if anything),\n\t\t\t\t\t// falling back to the empty string if nothing was stored.\n\t\t\t\t\tthis.className = this.className || value === false ? \"\" : data_priv.get(this, \"__className__\") || \"\";\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\thasClass: function hasClass(selector) {\n\t\t\tvar className = \" \" + selector + \" \",\n\t\t\t    i = 0,\n\t\t\t    l = this.length;\n\t\t\tfor (; i < l; i++) {\n\t\t\t\tif (this[i].nodeType === 1 && (\" \" + this[i].className + \" \").replace(rclass, \" \").indexOf(className) >= 0) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\t});\n\n\tvar rreturn = /\\r/g;\n\n\tjQuery.fn.extend({\n\t\tval: function val(value) {\n\t\t\tvar hooks,\n\t\t\t    ret,\n\t\t\t    isFunction,\n\t\t\t    elem = this[0];\n\n\t\t\tif (!arguments.length) {\n\t\t\t\tif (elem) {\n\t\t\t\t\thooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];\n\n\t\t\t\t\tif (hooks && \"get\" in hooks && (ret = hooks.get(elem, \"value\")) !== undefined) {\n\t\t\t\t\t\treturn ret;\n\t\t\t\t\t}\n\n\t\t\t\t\tret = elem.value;\n\n\t\t\t\t\treturn typeof ret === \"string\" ?\n\t\t\t\t\t// Handle most common string cases\n\t\t\t\t\tret.replace(rreturn, \"\") :\n\t\t\t\t\t// Handle cases where value is null/undef or number\n\t\t\t\t\tret == null ? \"\" : ret;\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tisFunction = jQuery.isFunction(value);\n\n\t\t\treturn this.each(function (i) {\n\t\t\t\tvar val;\n\n\t\t\t\tif (this.nodeType !== 1) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (isFunction) {\n\t\t\t\t\tval = value.call(this, i, jQuery(this).val());\n\t\t\t\t} else {\n\t\t\t\t\tval = value;\n\t\t\t\t}\n\n\t\t\t\t// Treat null/undefined as \"\"; convert numbers to string\n\t\t\t\tif (val == null) {\n\t\t\t\t\tval = \"\";\n\t\t\t\t} else if (typeof val === \"number\") {\n\t\t\t\t\tval += \"\";\n\t\t\t\t} else if (jQuery.isArray(val)) {\n\t\t\t\t\tval = jQuery.map(val, function (value) {\n\t\t\t\t\t\treturn value == null ? \"\" : value + \"\";\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\thooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];\n\n\t\t\t\t// If set returns undefined, fall back to normal setting\n\t\t\t\tif (!hooks || !(\"set\" in hooks) || hooks.set(this, val, \"value\") === undefined) {\n\t\t\t\t\tthis.value = val;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t});\n\n\tjQuery.extend({\n\t\tvalHooks: {\n\t\t\toption: {\n\t\t\t\tget: function get(elem) {\n\t\t\t\t\tvar val = jQuery.find.attr(elem, \"value\");\n\t\t\t\t\treturn val != null ? val :\n\t\t\t\t\t// Support: IE10-11+\n\t\t\t\t\t// option.text throws exceptions (#14686, #14858)\n\t\t\t\t\tjQuery.trim(jQuery.text(elem));\n\t\t\t\t}\n\t\t\t},\n\t\t\tselect: {\n\t\t\t\tget: function get(elem) {\n\t\t\t\t\tvar value,\n\t\t\t\t\t    option,\n\t\t\t\t\t    options = elem.options,\n\t\t\t\t\t    index = elem.selectedIndex,\n\t\t\t\t\t    one = elem.type === \"select-one\" || index < 0,\n\t\t\t\t\t    values = one ? null : [],\n\t\t\t\t\t    max = one ? index + 1 : options.length,\n\t\t\t\t\t    i = index < 0 ? max : one ? index : 0;\n\n\t\t\t\t\t// Loop through all the selected options\n\t\t\t\t\tfor (; i < max; i++) {\n\t\t\t\t\t\toption = options[i];\n\n\t\t\t\t\t\t// IE6-9 doesn't update selected after form reset (#2551)\n\t\t\t\t\t\tif ((option.selected || i === index) && (\n\t\t\t\t\t\t// Don't return options that are disabled or in a disabled optgroup\n\t\t\t\t\t\tsupport.optDisabled ? !option.disabled : option.getAttribute(\"disabled\") === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, \"optgroup\"))) {\n\n\t\t\t\t\t\t\t// Get the specific value for the option\n\t\t\t\t\t\t\tvalue = jQuery(option).val();\n\n\t\t\t\t\t\t\t// We don't need an array for one selects\n\t\t\t\t\t\t\tif (one) {\n\t\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Multi-Selects return an array\n\t\t\t\t\t\t\tvalues.push(value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn values;\n\t\t\t\t},\n\n\t\t\t\tset: function set(elem, value) {\n\t\t\t\t\tvar optionSet,\n\t\t\t\t\t    option,\n\t\t\t\t\t    options = elem.options,\n\t\t\t\t\t    values = jQuery.makeArray(value),\n\t\t\t\t\t    i = options.length;\n\n\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\toption = options[i];\n\t\t\t\t\t\tif (option.selected = jQuery.inArray(option.value, values) >= 0) {\n\t\t\t\t\t\t\toptionSet = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Force browsers to behave consistently when non-matching value is set\n\t\t\t\t\tif (!optionSet) {\n\t\t\t\t\t\telem.selectedIndex = -1;\n\t\t\t\t\t}\n\t\t\t\t\treturn values;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\t// Radios and checkboxes getter/setter\n\tjQuery.each([\"radio\", \"checkbox\"], function () {\n\t\tjQuery.valHooks[this] = {\n\t\t\tset: function set(elem, value) {\n\t\t\t\tif (jQuery.isArray(value)) {\n\t\t\t\t\treturn elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tif (!support.checkOn) {\n\t\t\tjQuery.valHooks[this].get = function (elem) {\n\t\t\t\treturn elem.getAttribute(\"value\") === null ? \"on\" : elem.value;\n\t\t\t};\n\t\t}\n\t});\n\n\t// Return jQuery for attributes-only inclusion\n\n\n\tjQuery.each((\"blur focus focusin focusout load resize scroll unload click dblclick \" + \"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" + \"change select submit keydown keypress keyup error contextmenu\").split(\" \"), function (i, name) {\n\n\t\t// Handle event binding\n\t\tjQuery.fn[name] = function (data, fn) {\n\t\t\treturn arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);\n\t\t};\n\t});\n\n\tjQuery.fn.extend({\n\t\thover: function hover(fnOver, fnOut) {\n\t\t\treturn this.mouseenter(fnOver).mouseleave(fnOut || fnOver);\n\t\t},\n\n\t\tbind: function bind(types, data, fn) {\n\t\t\treturn this.on(types, null, data, fn);\n\t\t},\n\t\tunbind: function unbind(types, fn) {\n\t\t\treturn this.off(types, null, fn);\n\t\t},\n\n\t\tdelegate: function delegate(selector, types, data, fn) {\n\t\t\treturn this.on(types, selector, data, fn);\n\t\t},\n\t\tundelegate: function undelegate(selector, types, fn) {\n\t\t\t// ( namespace ) or ( selector, types [, fn] )\n\t\t\treturn arguments.length === 1 ? this.off(selector, \"**\") : this.off(types, selector || \"**\", fn);\n\t\t}\n\t});\n\n\tvar nonce = jQuery.now();\n\n\tvar rquery = /\\?/;\n\n\t// Support: Android 2.3\n\t// Workaround failure to string-cast null input\n\tjQuery.parseJSON = function (data) {\n\t\treturn JSON.parse(data + \"\");\n\t};\n\n\t// Cross-browser xml parsing\n\tjQuery.parseXML = function (data) {\n\t\tvar xml, tmp;\n\t\tif (!data || typeof data !== \"string\") {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Support: IE9\n\t\ttry {\n\t\t\ttmp = new DOMParser();\n\t\t\txml = tmp.parseFromString(data, \"text/xml\");\n\t\t} catch (e) {\n\t\t\txml = undefined;\n\t\t}\n\n\t\tif (!xml || xml.getElementsByTagName(\"parsererror\").length) {\n\t\t\tjQuery.error(\"Invalid XML: \" + data);\n\t\t}\n\t\treturn xml;\n\t};\n\n\tvar rhash = /#.*$/,\n\t    rts = /([?&])_=[^&]*/,\n\t    rheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\n\n\t// #7653, #8125, #8152: local protocol detection\n\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n\t    rnoContent = /^(?:GET|HEAD)$/,\n\t    rprotocol = /^\\/\\//,\n\t    rurl = /^([\\w.+-]+:)(?:\\/\\/(?:[^\\/?#]*@|)([^\\/?#:]*)(?::(\\d+)|)|)/,\n\n\n\t/* Prefilters\n  * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n  * 2) These are called:\n  *    - BEFORE asking for a transport\n  *    - AFTER param serialization (s.data is a string if s.processData is true)\n  * 3) key is the dataType\n  * 4) the catchall symbol \"*\" can be used\n  * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n  */\n\tprefilters = {},\n\n\n\t/* Transports bindings\n  * 1) key is the dataType\n  * 2) the catchall symbol \"*\" can be used\n  * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n  */\n\ttransports = {},\n\n\n\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n\tallTypes = \"*/\".concat(\"*\"),\n\n\n\t// Document location\n\tajaxLocation = window.location.href,\n\n\n\t// Segment location into parts\n\tajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];\n\n\t// Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\n\tfunction addToPrefiltersOrTransports(structure) {\n\n\t\t// dataTypeExpression is optional and defaults to \"*\"\n\t\treturn function (dataTypeExpression, func) {\n\n\t\t\tif (typeof dataTypeExpression !== \"string\") {\n\t\t\t\tfunc = dataTypeExpression;\n\t\t\t\tdataTypeExpression = \"*\";\n\t\t\t}\n\n\t\t\tvar dataType,\n\t\t\t    i = 0,\n\t\t\t    dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];\n\n\t\t\tif (jQuery.isFunction(func)) {\n\t\t\t\t// For each dataType in the dataTypeExpression\n\t\t\t\twhile (dataType = dataTypes[i++]) {\n\t\t\t\t\t// Prepend if requested\n\t\t\t\t\tif (dataType[0] === \"+\") {\n\t\t\t\t\t\tdataType = dataType.slice(1) || \"*\";\n\t\t\t\t\t\t(structure[dataType] = structure[dataType] || []).unshift(func);\n\n\t\t\t\t\t\t// Otherwise append\n\t\t\t\t\t} else {\n\t\t\t\t\t\t(structure[dataType] = structure[dataType] || []).push(func);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\t// Base inspection function for prefilters and transports\n\tfunction inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {\n\n\t\tvar inspected = {},\n\t\t    seekingTransport = structure === transports;\n\n\t\tfunction inspect(dataType) {\n\t\t\tvar selected;\n\t\t\tinspected[dataType] = true;\n\t\t\tjQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {\n\t\t\t\tvar dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);\n\t\t\t\tif (typeof dataTypeOrTransport === \"string\" && !seekingTransport && !inspected[dataTypeOrTransport]) {\n\t\t\t\t\toptions.dataTypes.unshift(dataTypeOrTransport);\n\t\t\t\t\tinspect(dataTypeOrTransport);\n\t\t\t\t\treturn false;\n\t\t\t\t} else if (seekingTransport) {\n\t\t\t\t\treturn !(selected = dataTypeOrTransport);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn selected;\n\t\t}\n\n\t\treturn inspect(options.dataTypes[0]) || !inspected[\"*\"] && inspect(\"*\");\n\t}\n\n\t// A special extend for ajax options\n\t// that takes \"flat\" options (not to be deep extended)\n\t// Fixes #9887\n\tfunction ajaxExtend(target, src) {\n\t\tvar key,\n\t\t    deep,\n\t\t    flatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n\t\tfor (key in src) {\n\t\t\tif (src[key] !== undefined) {\n\t\t\t\t(flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];\n\t\t\t}\n\t\t}\n\t\tif (deep) {\n\t\t\tjQuery.extend(true, target, deep);\n\t\t}\n\n\t\treturn target;\n\t}\n\n\t/* Handles responses to an ajax request:\n  * - finds the right dataType (mediates between content-type and expected dataType)\n  * - returns the corresponding response\n  */\n\tfunction ajaxHandleResponses(s, jqXHR, responses) {\n\n\t\tvar ct,\n\t\t    type,\n\t\t    finalDataType,\n\t\t    firstDataType,\n\t\t    contents = s.contents,\n\t\t    dataTypes = s.dataTypes;\n\n\t\t// Remove auto dataType and get content-type in the process\n\t\twhile (dataTypes[0] === \"*\") {\n\t\t\tdataTypes.shift();\n\t\t\tif (ct === undefined) {\n\t\t\t\tct = s.mimeType || jqXHR.getResponseHeader(\"Content-Type\");\n\t\t\t}\n\t\t}\n\n\t\t// Check if we're dealing with a known content-type\n\t\tif (ct) {\n\t\t\tfor (type in contents) {\n\t\t\t\tif (contents[type] && contents[type].test(ct)) {\n\t\t\t\t\tdataTypes.unshift(type);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Check to see if we have a response for the expected dataType\n\t\tif (dataTypes[0] in responses) {\n\t\t\tfinalDataType = dataTypes[0];\n\t\t} else {\n\t\t\t// Try convertible dataTypes\n\t\t\tfor (type in responses) {\n\t\t\t\tif (!dataTypes[0] || s.converters[type + \" \" + dataTypes[0]]) {\n\t\t\t\t\tfinalDataType = type;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!firstDataType) {\n\t\t\t\t\tfirstDataType = type;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Or just use first one\n\t\t\tfinalDataType = finalDataType || firstDataType;\n\t\t}\n\n\t\t// If we found a dataType\n\t\t// We add the dataType to the list if needed\n\t\t// and return the corresponding response\n\t\tif (finalDataType) {\n\t\t\tif (finalDataType !== dataTypes[0]) {\n\t\t\t\tdataTypes.unshift(finalDataType);\n\t\t\t}\n\t\t\treturn responses[finalDataType];\n\t\t}\n\t}\n\n\t/* Chain conversions given the request and the original response\n  * Also sets the responseXXX fields on the jqXHR instance\n  */\n\tfunction ajaxConvert(s, response, jqXHR, isSuccess) {\n\t\tvar conv2,\n\t\t    current,\n\t\t    conv,\n\t\t    tmp,\n\t\t    prev,\n\t\t    converters = {},\n\n\t\t// Work with a copy of dataTypes in case we need to modify it for conversion\n\t\tdataTypes = s.dataTypes.slice();\n\n\t\t// Create converters map with lowercased keys\n\t\tif (dataTypes[1]) {\n\t\t\tfor (conv in s.converters) {\n\t\t\t\tconverters[conv.toLowerCase()] = s.converters[conv];\n\t\t\t}\n\t\t}\n\n\t\tcurrent = dataTypes.shift();\n\n\t\t// Convert to each sequential dataType\n\t\twhile (current) {\n\n\t\t\tif (s.responseFields[current]) {\n\t\t\t\tjqXHR[s.responseFields[current]] = response;\n\t\t\t}\n\n\t\t\t// Apply the dataFilter if provided\n\t\t\tif (!prev && isSuccess && s.dataFilter) {\n\t\t\t\tresponse = s.dataFilter(response, s.dataType);\n\t\t\t}\n\n\t\t\tprev = current;\n\t\t\tcurrent = dataTypes.shift();\n\n\t\t\tif (current) {\n\n\t\t\t\t// There's only work to do if current dataType is non-auto\n\t\t\t\tif (current === \"*\") {\n\n\t\t\t\t\tcurrent = prev;\n\n\t\t\t\t\t// Convert response if prev dataType is non-auto and differs from current\n\t\t\t\t} else if (prev !== \"*\" && prev !== current) {\n\n\t\t\t\t\t// Seek a direct converter\n\t\t\t\t\tconv = converters[prev + \" \" + current] || converters[\"* \" + current];\n\n\t\t\t\t\t// If none found, seek a pair\n\t\t\t\t\tif (!conv) {\n\t\t\t\t\t\tfor (conv2 in converters) {\n\n\t\t\t\t\t\t\t// If conv2 outputs current\n\t\t\t\t\t\t\ttmp = conv2.split(\" \");\n\t\t\t\t\t\t\tif (tmp[1] === current) {\n\n\t\t\t\t\t\t\t\t// If prev can be converted to accepted input\n\t\t\t\t\t\t\t\tconv = converters[prev + \" \" + tmp[0]] || converters[\"* \" + tmp[0]];\n\t\t\t\t\t\t\t\tif (conv) {\n\t\t\t\t\t\t\t\t\t// Condense equivalence converters\n\t\t\t\t\t\t\t\t\tif (conv === true) {\n\t\t\t\t\t\t\t\t\t\tconv = converters[conv2];\n\n\t\t\t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\n\t\t\t\t\t\t\t\t\t} else if (converters[conv2] !== true) {\n\t\t\t\t\t\t\t\t\t\tcurrent = tmp[0];\n\t\t\t\t\t\t\t\t\t\tdataTypes.unshift(tmp[1]);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Apply converter (if not an equivalence)\n\t\t\t\t\tif (conv !== true) {\n\n\t\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\n\t\t\t\t\t\tif (conv && s[\"throws\"]) {\n\t\t\t\t\t\t\tresponse = conv(response);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tresponse = conv(response);\n\t\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t\treturn { state: \"parsererror\", error: conv ? e : \"No conversion from \" + prev + \" to \" + current };\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn { state: \"success\", data: response };\n\t}\n\n\tjQuery.extend({\n\n\t\t// Counter for holding the number of active queries\n\t\tactive: 0,\n\n\t\t// Last-Modified header cache for next request\n\t\tlastModified: {},\n\t\tetag: {},\n\n\t\tajaxSettings: {\n\t\t\turl: ajaxLocation,\n\t\t\ttype: \"GET\",\n\t\t\tisLocal: rlocalProtocol.test(ajaxLocParts[1]),\n\t\t\tglobal: true,\n\t\t\tprocessData: true,\n\t\t\tasync: true,\n\t\t\tcontentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n\t\t\t/*\n   timeout: 0,\n   data: null,\n   dataType: null,\n   username: null,\n   password: null,\n   cache: null,\n   throws: false,\n   traditional: false,\n   headers: {},\n   */\n\n\t\t\taccepts: {\n\t\t\t\t\"*\": allTypes,\n\t\t\t\ttext: \"text/plain\",\n\t\t\t\thtml: \"text/html\",\n\t\t\t\txml: \"application/xml, text/xml\",\n\t\t\t\tjson: \"application/json, text/javascript\"\n\t\t\t},\n\n\t\t\tcontents: {\n\t\t\t\txml: /xml/,\n\t\t\t\thtml: /html/,\n\t\t\t\tjson: /json/\n\t\t\t},\n\n\t\t\tresponseFields: {\n\t\t\t\txml: \"responseXML\",\n\t\t\t\ttext: \"responseText\",\n\t\t\t\tjson: \"responseJSON\"\n\t\t\t},\n\n\t\t\t// Data converters\n\t\t\t// Keys separate source (or catchall \"*\") and destination types with a single space\n\t\t\tconverters: {\n\n\t\t\t\t// Convert anything to text\n\t\t\t\t\"* text\": String,\n\n\t\t\t\t// Text to html (true = no transformation)\n\t\t\t\t\"text html\": true,\n\n\t\t\t\t// Evaluate text as a json expression\n\t\t\t\t\"text json\": jQuery.parseJSON,\n\n\t\t\t\t// Parse text as xml\n\t\t\t\t\"text xml\": jQuery.parseXML\n\t\t\t},\n\n\t\t\t// For options that shouldn't be deep extended:\n\t\t\t// you can add your own custom options here if\n\t\t\t// and when you create one that shouldn't be\n\t\t\t// deep extended (see ajaxExtend)\n\t\t\tflatOptions: {\n\t\t\t\turl: true,\n\t\t\t\tcontext: true\n\t\t\t}\n\t\t},\n\n\t\t// Creates a full fledged settings object into target\n\t\t// with both ajaxSettings and settings fields.\n\t\t// If target is omitted, writes into ajaxSettings.\n\t\tajaxSetup: function ajaxSetup(target, settings) {\n\t\t\treturn settings ?\n\n\t\t\t// Building a settings object\n\t\t\tajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) :\n\n\t\t\t// Extending ajaxSettings\n\t\t\tajaxExtend(jQuery.ajaxSettings, target);\n\t\t},\n\n\t\tajaxPrefilter: addToPrefiltersOrTransports(prefilters),\n\t\tajaxTransport: addToPrefiltersOrTransports(transports),\n\n\t\t// Main method\n\t\tajax: function ajax(url, options) {\n\n\t\t\t// If url is an object, simulate pre-1.5 signature\n\t\t\tif ((typeof url === \"undefined\" ? \"undefined\" : _typeof(url)) === \"object\") {\n\t\t\t\toptions = url;\n\t\t\t\turl = undefined;\n\t\t\t}\n\n\t\t\t// Force options to be an object\n\t\t\toptions = options || {};\n\n\t\t\tvar transport,\n\n\t\t\t// URL without anti-cache param\n\t\t\tcacheURL,\n\n\t\t\t// Response headers\n\t\t\tresponseHeadersString,\n\t\t\t    responseHeaders,\n\n\t\t\t// timeout handle\n\t\t\ttimeoutTimer,\n\n\t\t\t// Cross-domain detection vars\n\t\t\tparts,\n\n\t\t\t// To know if global events are to be dispatched\n\t\t\tfireGlobals,\n\n\t\t\t// Loop variable\n\t\t\ti,\n\n\t\t\t// Create the final options object\n\t\t\ts = jQuery.ajaxSetup({}, options),\n\n\t\t\t// Callbacks context\n\t\t\tcallbackContext = s.context || s,\n\n\t\t\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\n\t\t\tglobalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,\n\n\t\t\t// Deferreds\n\t\t\tdeferred = jQuery.Deferred(),\n\t\t\t    completeDeferred = jQuery.Callbacks(\"once memory\"),\n\n\t\t\t// Status-dependent callbacks\n\t\t\t_statusCode = s.statusCode || {},\n\n\t\t\t// Headers (they are sent all at once)\n\t\t\trequestHeaders = {},\n\t\t\t    requestHeadersNames = {},\n\n\t\t\t// The jqXHR state\n\t\t\tstate = 0,\n\n\t\t\t// Default abort message\n\t\t\tstrAbort = \"canceled\",\n\n\t\t\t// Fake xhr\n\t\t\tjqXHR = {\n\t\t\t\treadyState: 0,\n\n\t\t\t\t// Builds headers hashtable if needed\n\t\t\t\tgetResponseHeader: function getResponseHeader(key) {\n\t\t\t\t\tvar match;\n\t\t\t\t\tif (state === 2) {\n\t\t\t\t\t\tif (!responseHeaders) {\n\t\t\t\t\t\t\tresponseHeaders = {};\n\t\t\t\t\t\t\twhile (match = rheaders.exec(responseHeadersString)) {\n\t\t\t\t\t\t\t\tresponseHeaders[match[1].toLowerCase()] = match[2];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmatch = responseHeaders[key.toLowerCase()];\n\t\t\t\t\t}\n\t\t\t\t\treturn match == null ? null : match;\n\t\t\t\t},\n\n\t\t\t\t// Raw string\n\t\t\t\tgetAllResponseHeaders: function getAllResponseHeaders() {\n\t\t\t\t\treturn state === 2 ? responseHeadersString : null;\n\t\t\t\t},\n\n\t\t\t\t// Caches the header\n\t\t\t\tsetRequestHeader: function setRequestHeader(name, value) {\n\t\t\t\t\tvar lname = name.toLowerCase();\n\t\t\t\t\tif (!state) {\n\t\t\t\t\t\tname = requestHeadersNames[lname] = requestHeadersNames[lname] || name;\n\t\t\t\t\t\trequestHeaders[name] = value;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Overrides response content-type header\n\t\t\t\toverrideMimeType: function overrideMimeType(type) {\n\t\t\t\t\tif (!state) {\n\t\t\t\t\t\ts.mimeType = type;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tstatusCode: function statusCode(map) {\n\t\t\t\t\tvar code;\n\t\t\t\t\tif (map) {\n\t\t\t\t\t\tif (state < 2) {\n\t\t\t\t\t\t\tfor (code in map) {\n\t\t\t\t\t\t\t\t// Lazy-add the new callback in a way that preserves old ones\n\t\t\t\t\t\t\t\t_statusCode[code] = [_statusCode[code], map[code]];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Execute the appropriate callbacks\n\t\t\t\t\t\t\tjqXHR.always(map[jqXHR.status]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Cancel the request\n\t\t\t\tabort: function abort(statusText) {\n\t\t\t\t\tvar finalText = statusText || strAbort;\n\t\t\t\t\tif (transport) {\n\t\t\t\t\t\ttransport.abort(finalText);\n\t\t\t\t\t}\n\t\t\t\t\tdone(0, finalText);\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// Attach deferreds\n\t\t\tdeferred.promise(jqXHR).complete = completeDeferred.add;\n\t\t\tjqXHR.success = jqXHR.done;\n\t\t\tjqXHR.error = jqXHR.fail;\n\n\t\t\t// Remove hash character (#7531: and string promotion)\n\t\t\t// Add protocol if not provided (prefilters might expect it)\n\t\t\t// Handle falsy url in the settings object (#10093: consistency with old signature)\n\t\t\t// We also use the url parameter if available\n\t\t\ts.url = ((url || s.url || ajaxLocation) + \"\").replace(rhash, \"\").replace(rprotocol, ajaxLocParts[1] + \"//\");\n\n\t\t\t// Alias method option to type as per ticket #12004\n\t\t\ts.type = options.method || options.type || s.method || s.type;\n\n\t\t\t// Extract dataTypes list\n\t\t\ts.dataTypes = jQuery.trim(s.dataType || \"*\").toLowerCase().match(rnotwhite) || [\"\"];\n\n\t\t\t// A cross-domain request is in order when we have a protocol:host:port mismatch\n\t\t\tif (s.crossDomain == null) {\n\t\t\t\tparts = rurl.exec(s.url.toLowerCase());\n\t\t\t\ts.crossDomain = !!(parts && (parts[1] !== ajaxLocParts[1] || parts[2] !== ajaxLocParts[2] || (parts[3] || (parts[1] === \"http:\" ? \"80\" : \"443\")) !== (ajaxLocParts[3] || (ajaxLocParts[1] === \"http:\" ? \"80\" : \"443\"))));\n\t\t\t}\n\n\t\t\t// Convert data if not already a string\n\t\t\tif (s.data && s.processData && typeof s.data !== \"string\") {\n\t\t\t\ts.data = jQuery.param(s.data, s.traditional);\n\t\t\t}\n\n\t\t\t// Apply prefilters\n\t\t\tinspectPrefiltersOrTransports(prefilters, s, options, jqXHR);\n\n\t\t\t// If request was aborted inside a prefilter, stop there\n\t\t\tif (state === 2) {\n\t\t\t\treturn jqXHR;\n\t\t\t}\n\n\t\t\t// We can fire global events as of now if asked to\n\t\t\t// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\n\t\t\tfireGlobals = jQuery.event && s.global;\n\n\t\t\t// Watch for a new set of requests\n\t\t\tif (fireGlobals && jQuery.active++ === 0) {\n\t\t\t\tjQuery.event.trigger(\"ajaxStart\");\n\t\t\t}\n\n\t\t\t// Uppercase the type\n\t\t\ts.type = s.type.toUpperCase();\n\n\t\t\t// Determine if request has content\n\t\t\ts.hasContent = !rnoContent.test(s.type);\n\n\t\t\t// Save the URL in case we're toying with the If-Modified-Since\n\t\t\t// and/or If-None-Match header later on\n\t\t\tcacheURL = s.url;\n\n\t\t\t// More options handling for requests with no content\n\t\t\tif (!s.hasContent) {\n\n\t\t\t\t// If data is available, append data to url\n\t\t\t\tif (s.data) {\n\t\t\t\t\tcacheURL = s.url += (rquery.test(cacheURL) ? \"&\" : \"?\") + s.data;\n\t\t\t\t\t// #9682: remove data so that it's not used in an eventual retry\n\t\t\t\t\tdelete s.data;\n\t\t\t\t}\n\n\t\t\t\t// Add anti-cache in url if needed\n\t\t\t\tif (s.cache === false) {\n\t\t\t\t\ts.url = rts.test(cacheURL) ?\n\n\t\t\t\t\t// If there is already a '_' parameter, set its value\n\t\t\t\t\tcacheURL.replace(rts, \"$1_=\" + nonce++) :\n\n\t\t\t\t\t// Otherwise add one to the end\n\t\t\t\t\tcacheURL + (rquery.test(cacheURL) ? \"&\" : \"?\") + \"_=\" + nonce++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\tif (s.ifModified) {\n\t\t\t\tif (jQuery.lastModified[cacheURL]) {\n\t\t\t\t\tjqXHR.setRequestHeader(\"If-Modified-Since\", jQuery.lastModified[cacheURL]);\n\t\t\t\t}\n\t\t\t\tif (jQuery.etag[cacheURL]) {\n\t\t\t\t\tjqXHR.setRequestHeader(\"If-None-Match\", jQuery.etag[cacheURL]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set the correct header, if data is being sent\n\t\t\tif (s.data && s.hasContent && s.contentType !== false || options.contentType) {\n\t\t\t\tjqXHR.setRequestHeader(\"Content-Type\", s.contentType);\n\t\t\t}\n\n\t\t\t// Set the Accepts header for the server, depending on the dataType\n\t\t\tjqXHR.setRequestHeader(\"Accept\", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\") : s.accepts[\"*\"]);\n\n\t\t\t// Check for headers option\n\t\t\tfor (i in s.headers) {\n\t\t\t\tjqXHR.setRequestHeader(i, s.headers[i]);\n\t\t\t}\n\n\t\t\t// Allow custom headers/mimetypes and early abort\n\t\t\tif (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {\n\t\t\t\t// Abort if not done already and return\n\t\t\t\treturn jqXHR.abort();\n\t\t\t}\n\n\t\t\t// Aborting is no longer a cancellation\n\t\t\tstrAbort = \"abort\";\n\n\t\t\t// Install callbacks on deferreds\n\t\t\tfor (i in { success: 1, error: 1, complete: 1 }) {\n\t\t\t\tjqXHR[i](s[i]);\n\t\t\t}\n\n\t\t\t// Get transport\n\t\t\ttransport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);\n\n\t\t\t// If no transport, we auto-abort\n\t\t\tif (!transport) {\n\t\t\t\tdone(-1, \"No Transport\");\n\t\t\t} else {\n\t\t\t\tjqXHR.readyState = 1;\n\n\t\t\t\t// Send global event\n\t\t\t\tif (fireGlobals) {\n\t\t\t\t\tglobalEventContext.trigger(\"ajaxSend\", [jqXHR, s]);\n\t\t\t\t}\n\t\t\t\t// Timeout\n\t\t\t\tif (s.async && s.timeout > 0) {\n\t\t\t\t\ttimeoutTimer = setTimeout(function () {\n\t\t\t\t\t\tjqXHR.abort(\"timeout\");\n\t\t\t\t\t}, s.timeout);\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tstate = 1;\n\t\t\t\t\ttransport.send(requestHeaders, done);\n\t\t\t\t} catch (e) {\n\t\t\t\t\t// Propagate exception as error if not done\n\t\t\t\t\tif (state < 2) {\n\t\t\t\t\t\tdone(-1, e);\n\t\t\t\t\t\t// Simply rethrow otherwise\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Callback for when everything is done\n\t\t\tfunction done(status, nativeStatusText, responses, headers) {\n\t\t\t\tvar isSuccess,\n\t\t\t\t    success,\n\t\t\t\t    error,\n\t\t\t\t    response,\n\t\t\t\t    modified,\n\t\t\t\t    statusText = nativeStatusText;\n\n\t\t\t\t// Called once\n\t\t\t\tif (state === 2) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// State is \"done\" now\n\t\t\t\tstate = 2;\n\n\t\t\t\t// Clear timeout if it exists\n\t\t\t\tif (timeoutTimer) {\n\t\t\t\t\tclearTimeout(timeoutTimer);\n\t\t\t\t}\n\n\t\t\t\t// Dereference transport for early garbage collection\n\t\t\t\t// (no matter how long the jqXHR object will be used)\n\t\t\t\ttransport = undefined;\n\n\t\t\t\t// Cache response headers\n\t\t\t\tresponseHeadersString = headers || \"\";\n\n\t\t\t\t// Set readyState\n\t\t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\n\n\t\t\t\t// Determine if successful\n\t\t\t\tisSuccess = status >= 200 && status < 300 || status === 304;\n\n\t\t\t\t// Get response data\n\t\t\t\tif (responses) {\n\t\t\t\t\tresponse = ajaxHandleResponses(s, jqXHR, responses);\n\t\t\t\t}\n\n\t\t\t\t// Convert no matter what (that way responseXXX fields are always set)\n\t\t\t\tresponse = ajaxConvert(s, response, jqXHR, isSuccess);\n\n\t\t\t\t// If successful, handle type chaining\n\t\t\t\tif (isSuccess) {\n\n\t\t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\t\t\tif (s.ifModified) {\n\t\t\t\t\t\tmodified = jqXHR.getResponseHeader(\"Last-Modified\");\n\t\t\t\t\t\tif (modified) {\n\t\t\t\t\t\t\tjQuery.lastModified[cacheURL] = modified;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmodified = jqXHR.getResponseHeader(\"etag\");\n\t\t\t\t\t\tif (modified) {\n\t\t\t\t\t\t\tjQuery.etag[cacheURL] = modified;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// if no content\n\t\t\t\t\tif (status === 204 || s.type === \"HEAD\") {\n\t\t\t\t\t\tstatusText = \"nocontent\";\n\n\t\t\t\t\t\t// if not modified\n\t\t\t\t\t} else if (status === 304) {\n\t\t\t\t\t\tstatusText = \"notmodified\";\n\n\t\t\t\t\t\t// If we have data, let's convert it\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstatusText = response.state;\n\t\t\t\t\t\tsuccess = response.data;\n\t\t\t\t\t\terror = response.error;\n\t\t\t\t\t\tisSuccess = !error;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Extract error from statusText and normalize for non-aborts\n\t\t\t\t\terror = statusText;\n\t\t\t\t\tif (status || !statusText) {\n\t\t\t\t\t\tstatusText = \"error\";\n\t\t\t\t\t\tif (status < 0) {\n\t\t\t\t\t\t\tstatus = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Set data for the fake xhr object\n\t\t\t\tjqXHR.status = status;\n\t\t\t\tjqXHR.statusText = (nativeStatusText || statusText) + \"\";\n\n\t\t\t\t// Success/Error\n\t\t\t\tif (isSuccess) {\n\t\t\t\t\tdeferred.resolveWith(callbackContext, [success, statusText, jqXHR]);\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.rejectWith(callbackContext, [jqXHR, statusText, error]);\n\t\t\t\t}\n\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tjqXHR.statusCode(_statusCode);\n\t\t\t\t_statusCode = undefined;\n\n\t\t\t\tif (fireGlobals) {\n\t\t\t\t\tglobalEventContext.trigger(isSuccess ? \"ajaxSuccess\" : \"ajaxError\", [jqXHR, s, isSuccess ? success : error]);\n\t\t\t\t}\n\n\t\t\t\t// Complete\n\t\t\t\tcompleteDeferred.fireWith(callbackContext, [jqXHR, statusText]);\n\n\t\t\t\tif (fireGlobals) {\n\t\t\t\t\tglobalEventContext.trigger(\"ajaxComplete\", [jqXHR, s]);\n\t\t\t\t\t// Handle the global AJAX counter\n\t\t\t\t\tif (! --jQuery.active) {\n\t\t\t\t\t\tjQuery.event.trigger(\"ajaxStop\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn jqXHR;\n\t\t},\n\n\t\tgetJSON: function getJSON(url, data, callback) {\n\t\t\treturn jQuery.get(url, data, callback, \"json\");\n\t\t},\n\n\t\tgetScript: function getScript(url, callback) {\n\t\t\treturn jQuery.get(url, undefined, callback, \"script\");\n\t\t}\n\t});\n\n\tjQuery.each([\"get\", \"post\"], function (i, method) {\n\t\tjQuery[method] = function (url, data, callback, type) {\n\t\t\t// Shift arguments if data argument was omitted\n\t\t\tif (jQuery.isFunction(data)) {\n\t\t\t\ttype = type || callback;\n\t\t\t\tcallback = data;\n\t\t\t\tdata = undefined;\n\t\t\t}\n\n\t\t\treturn jQuery.ajax({\n\t\t\t\turl: url,\n\t\t\t\ttype: method,\n\t\t\t\tdataType: type,\n\t\t\t\tdata: data,\n\t\t\t\tsuccess: callback\n\t\t\t});\n\t\t};\n\t});\n\n\tjQuery._evalUrl = function (url) {\n\t\treturn jQuery.ajax({\n\t\t\turl: url,\n\t\t\ttype: \"GET\",\n\t\t\tdataType: \"script\",\n\t\t\tasync: false,\n\t\t\tglobal: false,\n\t\t\t\"throws\": true\n\t\t});\n\t};\n\n\tjQuery.fn.extend({\n\t\twrapAll: function wrapAll(html) {\n\t\t\tvar wrap;\n\n\t\t\tif (jQuery.isFunction(html)) {\n\t\t\t\treturn this.each(function (i) {\n\t\t\t\t\tjQuery(this).wrapAll(html.call(this, i));\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (this[0]) {\n\n\t\t\t\t// The elements to wrap the target around\n\t\t\t\twrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);\n\n\t\t\t\tif (this[0].parentNode) {\n\t\t\t\t\twrap.insertBefore(this[0]);\n\t\t\t\t}\n\n\t\t\t\twrap.map(function () {\n\t\t\t\t\tvar elem = this;\n\n\t\t\t\t\twhile (elem.firstElementChild) {\n\t\t\t\t\t\telem = elem.firstElementChild;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn elem;\n\t\t\t\t}).append(this);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\twrapInner: function wrapInner(html) {\n\t\t\tif (jQuery.isFunction(html)) {\n\t\t\t\treturn this.each(function (i) {\n\t\t\t\t\tjQuery(this).wrapInner(html.call(this, i));\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn this.each(function () {\n\t\t\t\tvar self = jQuery(this),\n\t\t\t\t    contents = self.contents();\n\n\t\t\t\tif (contents.length) {\n\t\t\t\t\tcontents.wrapAll(html);\n\t\t\t\t} else {\n\t\t\t\t\tself.append(html);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\twrap: function wrap(html) {\n\t\t\tvar isFunction = jQuery.isFunction(html);\n\n\t\t\treturn this.each(function (i) {\n\t\t\t\tjQuery(this).wrapAll(isFunction ? html.call(this, i) : html);\n\t\t\t});\n\t\t},\n\n\t\tunwrap: function unwrap() {\n\t\t\treturn this.parent().each(function () {\n\t\t\t\tif (!jQuery.nodeName(this, \"body\")) {\n\t\t\t\t\tjQuery(this).replaceWith(this.childNodes);\n\t\t\t\t}\n\t\t\t}).end();\n\t\t}\n\t});\n\n\tjQuery.expr.filters.hidden = function (elem) {\n\t\t// Support: Opera <= 12.12\n\t\t// Opera reports offsetWidths and offsetHeights less than zero on some elements\n\t\treturn elem.offsetWidth <= 0 && elem.offsetHeight <= 0;\n\t};\n\tjQuery.expr.filters.visible = function (elem) {\n\t\treturn !jQuery.expr.filters.hidden(elem);\n\t};\n\n\tvar r20 = /%20/g,\n\t    rbracket = /\\[\\]$/,\n\t    rCRLF = /\\r?\\n/g,\n\t    rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n\t    rsubmittable = /^(?:input|select|textarea|keygen)/i;\n\n\tfunction buildParams(prefix, obj, traditional, add) {\n\t\tvar name;\n\n\t\tif (jQuery.isArray(obj)) {\n\t\t\t// Serialize array item.\n\t\t\tjQuery.each(obj, function (i, v) {\n\t\t\t\tif (traditional || rbracket.test(prefix)) {\n\t\t\t\t\t// Treat each array item as a scalar.\n\t\t\t\t\tadd(prefix, v);\n\t\t\t\t} else {\n\t\t\t\t\t// Item is non-scalar (array or object), encode its numeric index.\n\t\t\t\t\tbuildParams(prefix + \"[\" + ((typeof v === \"undefined\" ? \"undefined\" : _typeof(v)) === \"object\" ? i : \"\") + \"]\", v, traditional, add);\n\t\t\t\t}\n\t\t\t});\n\t\t} else if (!traditional && jQuery.type(obj) === \"object\") {\n\t\t\t// Serialize object item.\n\t\t\tfor (name in obj) {\n\t\t\t\tbuildParams(prefix + \"[\" + name + \"]\", obj[name], traditional, add);\n\t\t\t}\n\t\t} else {\n\t\t\t// Serialize scalar item.\n\t\t\tadd(prefix, obj);\n\t\t}\n\t}\n\n\t// Serialize an array of form elements or a set of\n\t// key/values into a query string\n\tjQuery.param = function (a, traditional) {\n\t\tvar prefix,\n\t\t    s = [],\n\t\t    add = function add(key, value) {\n\t\t\t// If value is a function, invoke it and return its value\n\t\t\tvalue = jQuery.isFunction(value) ? value() : value == null ? \"\" : value;\n\t\t\ts[s.length] = encodeURIComponent(key) + \"=\" + encodeURIComponent(value);\n\t\t};\n\n\t\t// Set traditional to true for jQuery <= 1.3.2 behavior.\n\t\tif (traditional === undefined) {\n\t\t\ttraditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;\n\t\t}\n\n\t\t// If an array was passed in, assume that it is an array of form elements.\n\t\tif (jQuery.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {\n\t\t\t// Serialize the form elements\n\t\t\tjQuery.each(a, function () {\n\t\t\t\tadd(this.name, this.value);\n\t\t\t});\n\t\t} else {\n\t\t\t// If traditional, encode the \"old\" way (the way 1.3.2 or older\n\t\t\t// did it), otherwise encode params recursively.\n\t\t\tfor (prefix in a) {\n\t\t\t\tbuildParams(prefix, a[prefix], traditional, add);\n\t\t\t}\n\t\t}\n\n\t\t// Return the resulting serialization\n\t\treturn s.join(\"&\").replace(r20, \"+\");\n\t};\n\n\tjQuery.fn.extend({\n\t\tserialize: function serialize() {\n\t\t\treturn jQuery.param(this.serializeArray());\n\t\t},\n\t\tserializeArray: function serializeArray() {\n\t\t\treturn this.map(function () {\n\t\t\t\t// Can add propHook for \"elements\" to filter or add form elements\n\t\t\t\tvar elements = jQuery.prop(this, \"elements\");\n\t\t\t\treturn elements ? jQuery.makeArray(elements) : this;\n\t\t\t}).filter(function () {\n\t\t\t\tvar type = this.type;\n\n\t\t\t\t// Use .is( \":disabled\" ) so that fieldset[disabled] works\n\t\t\t\treturn this.name && !jQuery(this).is(\":disabled\") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));\n\t\t\t}).map(function (i, elem) {\n\t\t\t\tvar val = jQuery(this).val();\n\n\t\t\t\treturn val == null ? null : jQuery.isArray(val) ? jQuery.map(val, function (val) {\n\t\t\t\t\treturn { name: elem.name, value: val.replace(rCRLF, \"\\r\\n\") };\n\t\t\t\t}) : { name: elem.name, value: val.replace(rCRLF, \"\\r\\n\") };\n\t\t\t}).get();\n\t\t}\n\t});\n\n\tjQuery.ajaxSettings.xhr = function () {\n\t\ttry {\n\t\t\treturn new XMLHttpRequest();\n\t\t} catch (e) {}\n\t};\n\n\tvar xhrId = 0,\n\t    xhrCallbacks = {},\n\t    xhrSuccessStatus = {\n\t\t// file protocol always yields status code 0, assume 200\n\t\t0: 200,\n\t\t// Support: IE9\n\t\t// #1450: sometimes IE returns 1223 when it should be 204\n\t\t1223: 204\n\t},\n\t    xhrSupported = jQuery.ajaxSettings.xhr();\n\n\t// Support: IE9\n\t// Open requests must be manually aborted on unload (#5280)\n\t// See https://support.microsoft.com/kb/2856746 for more info\n\tif (window.attachEvent) {\n\t\twindow.attachEvent(\"onunload\", function () {\n\t\t\tfor (var key in xhrCallbacks) {\n\t\t\t\txhrCallbacks[key]();\n\t\t\t}\n\t\t});\n\t}\n\n\tsupport.cors = !!xhrSupported && \"withCredentials\" in xhrSupported;\n\tsupport.ajax = xhrSupported = !!xhrSupported;\n\n\tjQuery.ajaxTransport(function (options) {\n\t\tvar _callback;\n\n\t\t// Cross domain only allowed if supported through XMLHttpRequest\n\t\tif (support.cors || xhrSupported && !options.crossDomain) {\n\t\t\treturn {\n\t\t\t\tsend: function send(headers, complete) {\n\t\t\t\t\tvar i,\n\t\t\t\t\t    xhr = options.xhr(),\n\t\t\t\t\t    id = ++xhrId;\n\n\t\t\t\t\txhr.open(options.type, options.url, options.async, options.username, options.password);\n\n\t\t\t\t\t// Apply custom fields if provided\n\t\t\t\t\tif (options.xhrFields) {\n\t\t\t\t\t\tfor (i in options.xhrFields) {\n\t\t\t\t\t\t\txhr[i] = options.xhrFields[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Override mime type if needed\n\t\t\t\t\tif (options.mimeType && xhr.overrideMimeType) {\n\t\t\t\t\t\txhr.overrideMimeType(options.mimeType);\n\t\t\t\t\t}\n\n\t\t\t\t\t// X-Requested-With header\n\t\t\t\t\t// For cross-domain requests, seeing as conditions for a preflight are\n\t\t\t\t\t// akin to a jigsaw puzzle, we simply never set it to be sure.\n\t\t\t\t\t// (it can always be set on a per-request basis or even using ajaxSetup)\n\t\t\t\t\t// For same-domain requests, won't change header if already provided.\n\t\t\t\t\tif (!options.crossDomain && !headers[\"X-Requested-With\"]) {\n\t\t\t\t\t\theaders[\"X-Requested-With\"] = \"XMLHttpRequest\";\n\t\t\t\t\t}\n\n\t\t\t\t\t// Set headers\n\t\t\t\t\tfor (i in headers) {\n\t\t\t\t\t\txhr.setRequestHeader(i, headers[i]);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Callback\n\t\t\t\t\t_callback = function callback(type) {\n\t\t\t\t\t\treturn function () {\n\t\t\t\t\t\t\tif (_callback) {\n\t\t\t\t\t\t\t\tdelete xhrCallbacks[id];\n\t\t\t\t\t\t\t\t_callback = xhr.onload = xhr.onerror = null;\n\n\t\t\t\t\t\t\t\tif (type === \"abort\") {\n\t\t\t\t\t\t\t\t\txhr.abort();\n\t\t\t\t\t\t\t\t} else if (type === \"error\") {\n\t\t\t\t\t\t\t\t\tcomplete(\n\t\t\t\t\t\t\t\t\t// file: protocol always yields status 0; see #8605, #14207\n\t\t\t\t\t\t\t\t\txhr.status, xhr.statusText);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcomplete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText,\n\t\t\t\t\t\t\t\t\t// Support: IE9\n\t\t\t\t\t\t\t\t\t// Accessing binary-data responseText throws an exception\n\t\t\t\t\t\t\t\t\t// (#11426)\n\t\t\t\t\t\t\t\t\ttypeof xhr.responseText === \"string\" ? {\n\t\t\t\t\t\t\t\t\t\ttext: xhr.responseText\n\t\t\t\t\t\t\t\t\t} : undefined, xhr.getAllResponseHeaders());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t};\n\n\t\t\t\t\t// Listen to events\n\t\t\t\t\txhr.onload = _callback();\n\t\t\t\t\txhr.onerror = _callback(\"error\");\n\n\t\t\t\t\t// Create the abort callback\n\t\t\t\t\t_callback = xhrCallbacks[id] = _callback(\"abort\");\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// Do send the request (this may raise an exception)\n\t\t\t\t\t\txhr.send(options.hasContent && options.data || null);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t// #14683: Only rethrow if this hasn't been notified as an error yet\n\t\t\t\t\t\tif (_callback) {\n\t\t\t\t\t\t\tthrow e;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tabort: function abort() {\n\t\t\t\t\tif (_callback) {\n\t\t\t\t\t\t_callback();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t});\n\n\t// Install script dataType\n\tjQuery.ajaxSetup({\n\t\taccepts: {\n\t\t\tscript: \"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript\"\n\t\t},\n\t\tcontents: {\n\t\t\tscript: /(?:java|ecma)script/\n\t\t},\n\t\tconverters: {\n\t\t\t\"text script\": function textScript(text) {\n\t\t\t\tjQuery.globalEval(text);\n\t\t\t\treturn text;\n\t\t\t}\n\t\t}\n\t});\n\n\t// Handle cache's special case and crossDomain\n\tjQuery.ajaxPrefilter(\"script\", function (s) {\n\t\tif (s.cache === undefined) {\n\t\t\ts.cache = false;\n\t\t}\n\t\tif (s.crossDomain) {\n\t\t\ts.type = \"GET\";\n\t\t}\n\t});\n\n\t// Bind script tag hack transport\n\tjQuery.ajaxTransport(\"script\", function (s) {\n\t\t// This transport only deals with cross domain requests\n\t\tif (s.crossDomain) {\n\t\t\tvar script, _callback2;\n\t\t\treturn {\n\t\t\t\tsend: function send(_, complete) {\n\t\t\t\t\tscript = jQuery(\"<script>\").prop({\n\t\t\t\t\t\tasync: true,\n\t\t\t\t\t\tcharset: s.scriptCharset,\n\t\t\t\t\t\tsrc: s.url\n\t\t\t\t\t}).on(\"load error\", _callback2 = function callback(evt) {\n\t\t\t\t\t\tscript.remove();\n\t\t\t\t\t\t_callback2 = null;\n\t\t\t\t\t\tif (evt) {\n\t\t\t\t\t\t\tcomplete(evt.type === \"error\" ? 404 : 200, evt.type);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tdocument.head.appendChild(script[0]);\n\t\t\t\t},\n\t\t\t\tabort: function abort() {\n\t\t\t\t\tif (_callback2) {\n\t\t\t\t\t\t_callback2();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t});\n\n\tvar oldCallbacks = [],\n\t    rjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n\n\t// Default jsonp settings\n\tjQuery.ajaxSetup({\n\t\tjsonp: \"callback\",\n\t\tjsonpCallback: function jsonpCallback() {\n\t\t\tvar callback = oldCallbacks.pop() || jQuery.expando + \"_\" + nonce++;\n\t\t\tthis[callback] = true;\n\t\t\treturn callback;\n\t\t}\n\t});\n\n\t// Detect, normalize options and install callbacks for jsonp requests\n\tjQuery.ajaxPrefilter(\"json jsonp\", function (s, originalSettings, jqXHR) {\n\n\t\tvar callbackName,\n\t\t    overwritten,\n\t\t    responseContainer,\n\t\t    jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? \"url\" : typeof s.data === \"string\" && !(s.contentType || \"\").indexOf(\"application/x-www-form-urlencoded\") && rjsonp.test(s.data) && \"data\");\n\n\t\t// Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n\t\tif (jsonProp || s.dataTypes[0] === \"jsonp\") {\n\n\t\t\t// Get callback name, remembering preexisting value associated with it\n\t\t\tcallbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;\n\n\t\t\t// Insert callback into url or form data\n\t\t\tif (jsonProp) {\n\t\t\t\ts[jsonProp] = s[jsonProp].replace(rjsonp, \"$1\" + callbackName);\n\t\t\t} else if (s.jsonp !== false) {\n\t\t\t\ts.url += (rquery.test(s.url) ? \"&\" : \"?\") + s.jsonp + \"=\" + callbackName;\n\t\t\t}\n\n\t\t\t// Use data converter to retrieve json after script execution\n\t\t\ts.converters[\"script json\"] = function () {\n\t\t\t\tif (!responseContainer) {\n\t\t\t\t\tjQuery.error(callbackName + \" was not called\");\n\t\t\t\t}\n\t\t\t\treturn responseContainer[0];\n\t\t\t};\n\n\t\t\t// force json dataType\n\t\t\ts.dataTypes[0] = \"json\";\n\n\t\t\t// Install callback\n\t\t\toverwritten = window[callbackName];\n\t\t\twindow[callbackName] = function () {\n\t\t\t\tresponseContainer = arguments;\n\t\t\t};\n\n\t\t\t// Clean-up function (fires after converters)\n\t\t\tjqXHR.always(function () {\n\t\t\t\t// Restore preexisting value\n\t\t\t\twindow[callbackName] = overwritten;\n\n\t\t\t\t// Save back as free\n\t\t\t\tif (s[callbackName]) {\n\t\t\t\t\t// make sure that re-using the options doesn't screw things around\n\t\t\t\t\ts.jsonpCallback = originalSettings.jsonpCallback;\n\n\t\t\t\t\t// save the callback name for future use\n\t\t\t\t\toldCallbacks.push(callbackName);\n\t\t\t\t}\n\n\t\t\t\t// Call if it was a function and we have a response\n\t\t\t\tif (responseContainer && jQuery.isFunction(overwritten)) {\n\t\t\t\t\toverwritten(responseContainer[0]);\n\t\t\t\t}\n\n\t\t\t\tresponseContainer = overwritten = undefined;\n\t\t\t});\n\n\t\t\t// Delegate to script\n\t\t\treturn \"script\";\n\t\t}\n\t});\n\n\t// data: string of html\n\t// context (optional): If specified, the fragment will be created in this context, defaults to document\n\t// keepScripts (optional): If true, will include scripts passed in the html string\n\tjQuery.parseHTML = function (data, context, keepScripts) {\n\t\tif (!data || typeof data !== \"string\") {\n\t\t\treturn null;\n\t\t}\n\t\tif (typeof context === \"boolean\") {\n\t\t\tkeepScripts = context;\n\t\t\tcontext = false;\n\t\t}\n\t\tcontext = context || document;\n\n\t\tvar parsed = rsingleTag.exec(data),\n\t\t    scripts = !keepScripts && [];\n\n\t\t// Single tag\n\t\tif (parsed) {\n\t\t\treturn [context.createElement(parsed[1])];\n\t\t}\n\n\t\tparsed = jQuery.buildFragment([data], context, scripts);\n\n\t\tif (scripts && scripts.length) {\n\t\t\tjQuery(scripts).remove();\n\t\t}\n\n\t\treturn jQuery.merge([], parsed.childNodes);\n\t};\n\n\t// Keep a copy of the old load method\n\tvar _load = jQuery.fn.load;\n\n\t/**\n  * Load a url into a page\n  */\n\tjQuery.fn.load = function (url, params, callback) {\n\t\tif (typeof url !== \"string\" && _load) {\n\t\t\treturn _load.apply(this, arguments);\n\t\t}\n\n\t\tvar selector,\n\t\t    type,\n\t\t    response,\n\t\t    self = this,\n\t\t    off = url.indexOf(\" \");\n\n\t\tif (off >= 0) {\n\t\t\tselector = jQuery.trim(url.slice(off));\n\t\t\turl = url.slice(0, off);\n\t\t}\n\n\t\t// If it's a function\n\t\tif (jQuery.isFunction(params)) {\n\n\t\t\t// We assume that it's the callback\n\t\t\tcallback = params;\n\t\t\tparams = undefined;\n\n\t\t\t// Otherwise, build a param string\n\t\t} else if (params && (typeof params === \"undefined\" ? \"undefined\" : _typeof(params)) === \"object\") {\n\t\t\ttype = \"POST\";\n\t\t}\n\n\t\t// If we have elements to modify, make the request\n\t\tif (self.length > 0) {\n\t\t\tjQuery.ajax({\n\t\t\t\turl: url,\n\n\t\t\t\t// if \"type\" variable is undefined, then \"GET\" method will be used\n\t\t\t\ttype: type,\n\t\t\t\tdataType: \"html\",\n\t\t\t\tdata: params\n\t\t\t}).done(function (responseText) {\n\n\t\t\t\t// Save response for use in complete callback\n\t\t\t\tresponse = arguments;\n\n\t\t\t\tself.html(selector ?\n\n\t\t\t\t// If a selector was specified, locate the right elements in a dummy div\n\t\t\t\t// Exclude scripts to avoid IE 'Permission Denied' errors\n\t\t\t\tjQuery(\"<div>\").append(jQuery.parseHTML(responseText)).find(selector) :\n\n\t\t\t\t// Otherwise use the full result\n\t\t\t\tresponseText);\n\t\t\t}).complete(callback && function (jqXHR, status) {\n\t\t\t\tself.each(callback, response || [jqXHR.responseText, status, jqXHR]);\n\t\t\t});\n\t\t}\n\n\t\treturn this;\n\t};\n\n\t// Attach a bunch of functions for handling common AJAX events\n\tjQuery.each([\"ajaxStart\", \"ajaxStop\", \"ajaxComplete\", \"ajaxError\", \"ajaxSuccess\", \"ajaxSend\"], function (i, type) {\n\t\tjQuery.fn[type] = function (fn) {\n\t\t\treturn this.on(type, fn);\n\t\t};\n\t});\n\n\tjQuery.expr.filters.animated = function (elem) {\n\t\treturn jQuery.grep(jQuery.timers, function (fn) {\n\t\t\treturn elem === fn.elem;\n\t\t}).length;\n\t};\n\n\tvar docElem = window.document.documentElement;\n\n\t/**\n  * Gets a window from an element\n  */\n\tfunction getWindow(elem) {\n\t\treturn jQuery.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;\n\t}\n\n\tjQuery.offset = {\n\t\tsetOffset: function setOffset(elem, options, i) {\n\t\t\tvar curPosition,\n\t\t\t    curLeft,\n\t\t\t    curCSSTop,\n\t\t\t    curTop,\n\t\t\t    curOffset,\n\t\t\t    curCSSLeft,\n\t\t\t    calculatePosition,\n\t\t\t    position = jQuery.css(elem, \"position\"),\n\t\t\t    curElem = jQuery(elem),\n\t\t\t    props = {};\n\n\t\t\t// Set position first, in-case top/left are set even on static elem\n\t\t\tif (position === \"static\") {\n\t\t\t\telem.style.position = \"relative\";\n\t\t\t}\n\n\t\t\tcurOffset = curElem.offset();\n\t\t\tcurCSSTop = jQuery.css(elem, \"top\");\n\t\t\tcurCSSLeft = jQuery.css(elem, \"left\");\n\t\t\tcalculatePosition = (position === \"absolute\" || position === \"fixed\") && (curCSSTop + curCSSLeft).indexOf(\"auto\") > -1;\n\n\t\t\t// Need to be able to calculate position if either\n\t\t\t// top or left is auto and position is either absolute or fixed\n\t\t\tif (calculatePosition) {\n\t\t\t\tcurPosition = curElem.position();\n\t\t\t\tcurTop = curPosition.top;\n\t\t\t\tcurLeft = curPosition.left;\n\t\t\t} else {\n\t\t\t\tcurTop = parseFloat(curCSSTop) || 0;\n\t\t\t\tcurLeft = parseFloat(curCSSLeft) || 0;\n\t\t\t}\n\n\t\t\tif (jQuery.isFunction(options)) {\n\t\t\t\toptions = options.call(elem, i, curOffset);\n\t\t\t}\n\n\t\t\tif (options.top != null) {\n\t\t\t\tprops.top = options.top - curOffset.top + curTop;\n\t\t\t}\n\t\t\tif (options.left != null) {\n\t\t\t\tprops.left = options.left - curOffset.left + curLeft;\n\t\t\t}\n\n\t\t\tif (\"using\" in options) {\n\t\t\t\toptions.using.call(elem, props);\n\t\t\t} else {\n\t\t\t\tcurElem.css(props);\n\t\t\t}\n\t\t}\n\t};\n\n\tjQuery.fn.extend({\n\t\toffset: function offset(options) {\n\t\t\tif (arguments.length) {\n\t\t\t\treturn options === undefined ? this : this.each(function (i) {\n\t\t\t\t\tjQuery.offset.setOffset(this, options, i);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tvar docElem,\n\t\t\t    win,\n\t\t\t    elem = this[0],\n\t\t\t    box = { top: 0, left: 0 },\n\t\t\t    doc = elem && elem.ownerDocument;\n\n\t\t\tif (!doc) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tdocElem = doc.documentElement;\n\n\t\t\t// Make sure it's not a disconnected DOM node\n\t\t\tif (!jQuery.contains(docElem, elem)) {\n\t\t\t\treturn box;\n\t\t\t}\n\n\t\t\t// Support: BlackBerry 5, iOS 3 (original iPhone)\n\t\t\t// If we don't have gBCR, just use 0,0 rather than error\n\t\t\tif (_typeof(elem.getBoundingClientRect) !== strundefined) {\n\t\t\t\tbox = elem.getBoundingClientRect();\n\t\t\t}\n\t\t\twin = getWindow(doc);\n\t\t\treturn {\n\t\t\t\ttop: box.top + win.pageYOffset - docElem.clientTop,\n\t\t\t\tleft: box.left + win.pageXOffset - docElem.clientLeft\n\t\t\t};\n\t\t},\n\n\t\tposition: function position() {\n\t\t\tif (!this[0]) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar offsetParent,\n\t\t\t    offset,\n\t\t\t    elem = this[0],\n\t\t\t    parentOffset = { top: 0, left: 0 };\n\n\t\t\t// Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent\n\t\t\tif (jQuery.css(elem, \"position\") === \"fixed\") {\n\t\t\t\t// Assume getBoundingClientRect is there when computed position is fixed\n\t\t\t\toffset = elem.getBoundingClientRect();\n\t\t\t} else {\n\t\t\t\t// Get *real* offsetParent\n\t\t\t\toffsetParent = this.offsetParent();\n\n\t\t\t\t// Get correct offsets\n\t\t\t\toffset = this.offset();\n\t\t\t\tif (!jQuery.nodeName(offsetParent[0], \"html\")) {\n\t\t\t\t\tparentOffset = offsetParent.offset();\n\t\t\t\t}\n\n\t\t\t\t// Add offsetParent borders\n\t\t\t\tparentOffset.top += jQuery.css(offsetParent[0], \"borderTopWidth\", true);\n\t\t\t\tparentOffset.left += jQuery.css(offsetParent[0], \"borderLeftWidth\", true);\n\t\t\t}\n\n\t\t\t// Subtract parent offsets and element margins\n\t\t\treturn {\n\t\t\t\ttop: offset.top - parentOffset.top - jQuery.css(elem, \"marginTop\", true),\n\t\t\t\tleft: offset.left - parentOffset.left - jQuery.css(elem, \"marginLeft\", true)\n\t\t\t};\n\t\t},\n\n\t\toffsetParent: function offsetParent() {\n\t\t\treturn this.map(function () {\n\t\t\t\tvar offsetParent = this.offsetParent || docElem;\n\n\t\t\t\twhile (offsetParent && !jQuery.nodeName(offsetParent, \"html\") && jQuery.css(offsetParent, \"position\") === \"static\") {\n\t\t\t\t\toffsetParent = offsetParent.offsetParent;\n\t\t\t\t}\n\n\t\t\t\treturn offsetParent || docElem;\n\t\t\t});\n\t\t}\n\t});\n\n\t// Create scrollLeft and scrollTop methods\n\tjQuery.each({ scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\" }, function (method, prop) {\n\t\tvar top = \"pageYOffset\" === prop;\n\n\t\tjQuery.fn[method] = function (val) {\n\t\t\treturn access(this, function (elem, method, val) {\n\t\t\t\tvar win = getWindow(elem);\n\n\t\t\t\tif (val === undefined) {\n\t\t\t\t\treturn win ? win[prop] : elem[method];\n\t\t\t\t}\n\n\t\t\t\tif (win) {\n\t\t\t\t\twin.scrollTo(!top ? val : window.pageXOffset, top ? val : window.pageYOffset);\n\t\t\t\t} else {\n\t\t\t\t\telem[method] = val;\n\t\t\t\t}\n\t\t\t}, method, val, arguments.length, null);\n\t\t};\n\t});\n\n\t// Support: Safari<7+, Chrome<37+\n\t// Add the top/left cssHooks using jQuery.fn.position\n\t// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n\t// Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280\n\t// getComputedStyle returns percent when specified for top/left/bottom/right;\n\t// rather than make the css module depend on the offset module, just check for it here\n\tjQuery.each([\"top\", \"left\"], function (i, prop) {\n\t\tjQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {\n\t\t\tif (computed) {\n\t\t\t\tcomputed = curCSS(elem, prop);\n\t\t\t\t// If curCSS returns percentage, fallback to offset\n\t\t\t\treturn rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + \"px\" : computed;\n\t\t\t}\n\t\t});\n\t});\n\n\t// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\n\tjQuery.each({ Height: \"height\", Width: \"width\" }, function (name, type) {\n\t\tjQuery.each({ padding: \"inner\" + name, content: type, \"\": \"outer\" + name }, function (defaultExtra, funcName) {\n\t\t\t// Margin is only for outerHeight, outerWidth\n\t\t\tjQuery.fn[funcName] = function (margin, value) {\n\t\t\t\tvar chainable = arguments.length && (defaultExtra || typeof margin !== \"boolean\"),\n\t\t\t\t    extra = defaultExtra || (margin === true || value === true ? \"margin\" : \"border\");\n\n\t\t\t\treturn access(this, function (elem, type, value) {\n\t\t\t\t\tvar doc;\n\n\t\t\t\t\tif (jQuery.isWindow(elem)) {\n\t\t\t\t\t\t// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there\n\t\t\t\t\t\t// isn't a whole lot we can do. See pull request at this URL for discussion:\n\t\t\t\t\t\t// https://github.com/jquery/jquery/pull/764\n\t\t\t\t\t\treturn elem.document.documentElement[\"client\" + name];\n\t\t\t\t\t}\n\n\t\t\t\t\t// Get document width or height\n\t\t\t\t\tif (elem.nodeType === 9) {\n\t\t\t\t\t\tdoc = elem.documentElement;\n\n\t\t\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n\t\t\t\t\t\t// whichever is greatest\n\t\t\t\t\t\treturn Math.max(elem.body[\"scroll\" + name], doc[\"scroll\" + name], elem.body[\"offset\" + name], doc[\"offset\" + name], doc[\"client\" + name]);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn value === undefined ?\n\t\t\t\t\t// Get width or height on the element, requesting but not forcing parseFloat\n\t\t\t\t\tjQuery.css(elem, type, extra) :\n\n\t\t\t\t\t// Set width or height on the element\n\t\t\t\t\tjQuery.style(elem, type, value, extra);\n\t\t\t\t}, type, chainable ? margin : undefined, chainable, null);\n\t\t\t};\n\t\t});\n\t});\n\n\t// The number of elements contained in the matched element set\n\tjQuery.fn.size = function () {\n\t\treturn this.length;\n\t};\n\n\tjQuery.fn.andSelf = jQuery.fn.addBack;\n\n\t// Register as a named AMD module, since jQuery can be concatenated with other\n\t// files that may use define, but not via a proper concatenation script that\n\t// understands anonymous AMD modules. A named AMD is safest and most robust\n\t// way to register. Lowercase jquery is used because AMD module names are\n\t// derived from file names, and jQuery is normally delivered in a lowercase\n\t// file name. Do this after creating the global so that if an AMD module wants\n\t// to call noConflict to hide this version of jQuery, it will work.\n\n\t// Note that for maximum portability, libraries that are not jQuery should\n\t// declare themselves as anonymous modules, and avoid setting a global if an\n\t// AMD loader is present. jQuery is a special case. For more information, see\n\t// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n\n\tif (typeof define === \"function\" && define.amd) {\n\t\tdefine(\"jquery\", [], function () {\n\t\t\treturn jQuery;\n\t\t});\n\t}\n\n\tvar\n\t// Map over jQuery in case of overwrite\n\t_jQuery = window.jQuery,\n\n\n\t// Map over the $ in case of overwrite\n\t_$ = window.$;\n\n\tjQuery.noConflict = function (deep) {\n\t\tif (window.$ === jQuery) {\n\t\t\twindow.$ = _$;\n\t\t}\n\n\t\tif (deep && window.jQuery === jQuery) {\n\t\t\twindow.jQuery = _jQuery;\n\t\t}\n\n\t\treturn jQuery;\n\t};\n\n\t// Expose jQuery and $ identifiers, even in AMD\n\t// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n\t// and CommonJS for browser emulators (#13566)\n\tif ((typeof noGlobal === \"undefined\" ? \"undefined\" : _typeof(noGlobal)) === strundefined) {\n\t\twindow.jQuery = window.$ = jQuery;\n\t}\n\n\treturn jQuery;\n});"

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./node_modules/babel-loader/lib/index.js??ref--0-0!./assets/js/jquery.form.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/raw-loader!./node_modules/babel-loader/lib??ref--0-0!./assets/js/jquery.form.js ***!
  \******************************************************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports) {

module.exports = "var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/*!\n * jQuery Form Plugin\n * version: 3.51.0-2014.06.20\n * Requires jQuery v1.5 or later\n * Copyright (c) 2014 M. Alsup\n * Examples and documentation at: http://malsup.com/jquery/form/\n * Project repository: https://github.com/malsup/form\n * Dual licensed under the MIT and GPL licenses.\n * https://github.com/malsup/form#copyright-and-license\n */\n/*global ActiveXObject */\n\n// AMD support\n(function (factory) {\n    \"use strict\";\n\n    if (typeof define === 'function' && define.amd) {\n        // using AMD; register as anon module\n        define(['jquery'], factory);\n    } else {\n        // no AMD; invoke directly\n        factory(typeof jQuery != 'undefined' ? jQuery : window.Zepto);\n    }\n})(function ($) {\n    \"use strict\";\n\n    /*\n        Usage Note:\n        -----------\n        Do not use both ajaxSubmit and ajaxForm on the same form.  These\n        functions are mutually exclusive.  Use ajaxSubmit if you want\n        to bind your own submit handler to the form.  For example,\n    \n        $(document).ready(function() {\n            $('#myForm').on('submit', function(e) {\n                e.preventDefault(); // <-- important\n                $(this).ajaxSubmit({\n                    target: '#output'\n                });\n            });\n        });\n    \n        Use ajaxForm when you want the plugin to manage all the event binding\n        for you.  For example,\n    \n        $(document).ready(function() {\n            $('#myForm').ajaxForm({\n                target: '#output'\n            });\n        });\n    \n        You can also use ajaxForm with delegation (requires jQuery v1.7+), so the\n        form does not have to exist when you invoke ajaxForm:\n    \n        $('#myForm').ajaxForm({\n            delegation: true,\n            target: '#output'\n        });\n    \n        When using ajaxForm, the ajaxSubmit function will be invoked for you\n        at the appropriate time.\n    */\n\n    /**\n     * Feature detection\n     */\n\n    var feature = {};\n    feature.fileapi = $(\"<input type='file'/>\").get(0).files !== undefined;\n    feature.formdata = window.FormData !== undefined;\n\n    var hasProp = !!$.fn.prop;\n\n    // attr2 uses prop when it can but checks the return type for\n    // an expected string.  this accounts for the case where a form \n    // contains inputs with names like \"action\" or \"method\"; in those\n    // cases \"prop\" returns the element\n    $.fn.attr2 = function () {\n        if (!hasProp) {\n            return this.attr.apply(this, arguments);\n        }\n        var val = this.prop.apply(this, arguments);\n        if (val && val.jquery || typeof val === 'string') {\n            return val;\n        }\n        return this.attr.apply(this, arguments);\n    };\n\n    /**\n     * ajaxSubmit() provides a mechanism for immediately submitting\n     * an HTML form using AJAX.\n     */\n    $.fn.ajaxSubmit = function (options) {\n        /*jshint scripturl:true */\n\n        // fast fail if nothing selected (http://dev.jquery.com/ticket/2752)\n        if (!this.length) {\n            log('ajaxSubmit: skipping submit process - no element selected');\n            return this;\n        }\n\n        var method,\n            action,\n            url,\n            $form = this;\n\n        if (typeof options == 'function') {\n            options = { success: options };\n        } else if (options === undefined) {\n            options = {};\n        }\n\n        method = options.type || this.attr2('method');\n        action = options.url || this.attr2('action');\n\n        url = typeof action === 'string' ? $.trim(action) : '';\n        url = url || window.location.href || '';\n        if (url) {\n            // clean url (don't include hash vaue)\n            url = (url.match(/^([^#]+)/) || [])[1];\n        }\n\n        options = $.extend(true, {\n            url: url,\n            success: $.ajaxSettings.success,\n            type: method || $.ajaxSettings.type,\n            iframeSrc: /^https/i.test(window.location.href || '') ? 'javascript:false' : 'about:blank'\n        }, options);\n\n        // hook for manipulating the form data before it is extracted;\n        // convenient for use with rich editors like tinyMCE or FCKEditor\n        var veto = {};\n        this.trigger('form-pre-serialize', [this, options, veto]);\n        if (veto.veto) {\n            log('ajaxSubmit: submit vetoed via form-pre-serialize trigger');\n            return this;\n        }\n\n        // provide opportunity to alter form data before it is serialized\n        if (options.beforeSerialize && options.beforeSerialize(this, options) === false) {\n            log('ajaxSubmit: submit aborted via beforeSerialize callback');\n            return this;\n        }\n\n        var traditional = options.traditional;\n        if (traditional === undefined) {\n            traditional = $.ajaxSettings.traditional;\n        }\n\n        var elements = [];\n        var qx,\n            a = this.formToArray(options.semantic, elements);\n        if (options.data) {\n            options.extraData = options.data;\n            qx = $.param(options.data, traditional);\n        }\n\n        // give pre-submit callback an opportunity to abort the submit\n        if (options.beforeSubmit && options.beforeSubmit(a, this, options) === false) {\n            log('ajaxSubmit: submit aborted via beforeSubmit callback');\n            return this;\n        }\n\n        // fire vetoable 'validate' event\n        this.trigger('form-submit-validate', [a, this, options, veto]);\n        if (veto.veto) {\n            log('ajaxSubmit: submit vetoed via form-submit-validate trigger');\n            return this;\n        }\n\n        var q = $.param(a, traditional);\n        if (qx) {\n            q = q ? q + '&' + qx : qx;\n        }\n        if (options.type.toUpperCase() == 'GET') {\n            options.url += (options.url.indexOf('?') >= 0 ? '&' : '?') + q;\n            options.data = null; // data is null for 'get'\n        } else {\n            options.data = q; // data is the query string for 'post'\n        }\n\n        var callbacks = [];\n        if (options.resetForm) {\n            callbacks.push(function () {\n                $form.resetForm();\n            });\n        }\n        if (options.clearForm) {\n            callbacks.push(function () {\n                $form.clearForm(options.includeHidden);\n            });\n        }\n\n        // perform a load on the target only if dataType is not provided\n        if (!options.dataType && options.target) {\n            var oldSuccess = options.success || function () {};\n            callbacks.push(function (data) {\n                var fn = options.replaceTarget ? 'replaceWith' : 'html';\n                $(options.target)[fn](data).each(oldSuccess, arguments);\n            });\n        } else if (options.success) {\n            callbacks.push(options.success);\n        }\n\n        options.success = function (data, status, xhr) {\n            // jQuery 1.4+ passes xhr as 3rd arg\n            var context = options.context || this; // jQuery 1.4+ supports scope context\n            for (var i = 0, max = callbacks.length; i < max; i++) {\n                callbacks[i].apply(context, [data, status, xhr || $form, $form]);\n            }\n        };\n\n        if (options.error) {\n            var oldError = options.error;\n            options.error = function (xhr, status, error) {\n                var context = options.context || this;\n                oldError.apply(context, [xhr, status, error, $form]);\n            };\n        }\n\n        if (options.complete) {\n            var oldComplete = options.complete;\n            options.complete = function (xhr, status) {\n                var context = options.context || this;\n                oldComplete.apply(context, [xhr, status, $form]);\n            };\n        }\n\n        // are there files to upload?\n\n        // [value] (issue #113), also see comment:\n        // https://github.com/malsup/form/commit/588306aedba1de01388032d5f42a60159eea9228#commitcomment-2180219\n        var fileInputs = $('input[type=file]:enabled', this).filter(function () {\n            return $(this).val() !== '';\n        });\n\n        var hasFileInputs = fileInputs.length > 0;\n        var mp = 'multipart/form-data';\n        var multipart = $form.attr('enctype') == mp || $form.attr('encoding') == mp;\n\n        var fileAPI = feature.fileapi && feature.formdata;\n        log(\"fileAPI :\" + fileAPI);\n        var shouldUseFrame = (hasFileInputs || multipart) && !fileAPI;\n\n        var jqxhr;\n\n        // options.iframe allows user to force iframe mode\n        // 06-NOV-09: now defaulting to iframe mode if file input is detected\n        if (options.iframe !== false && (options.iframe || shouldUseFrame)) {\n            // hack to fix Safari hang (thanks to Tim Molendijk for this)\n            // see:  http://groups.google.com/group/jquery-dev/browse_thread/thread/36395b7ab510dd5d\n            if (options.closeKeepAlive) {\n                $.get(options.closeKeepAlive, function () {\n                    jqxhr = fileUploadIframe(a);\n                });\n            } else {\n                jqxhr = fileUploadIframe(a);\n            }\n        } else if ((hasFileInputs || multipart) && fileAPI) {\n            jqxhr = fileUploadXhr(a);\n        } else {\n            jqxhr = $.ajax(options);\n        }\n\n        $form.removeData('jqxhr').data('jqxhr', jqxhr);\n\n        // clear element array\n        for (var k = 0; k < elements.length; k++) {\n            elements[k] = null;\n        }\n\n        // fire 'notify' event\n        this.trigger('form-submit-notify', [this, options]);\n        return this;\n\n        // utility fn for deep serialization\n        function deepSerialize(extraData) {\n            var serialized = $.param(extraData, options.traditional).split('&');\n            var len = serialized.length;\n            var result = [];\n            var i, part;\n            for (i = 0; i < len; i++) {\n                // #252; undo param space replacement\n                serialized[i] = serialized[i].replace(/\\+/g, ' ');\n                part = serialized[i].split('=');\n                // #278; use array instead of object storage, favoring array serializations\n                result.push([decodeURIComponent(part[0]), decodeURIComponent(part[1])]);\n            }\n            return result;\n        }\n\n        // XMLHttpRequest Level 2 file uploads (big hat tip to francois2metz)\n        function fileUploadXhr(a) {\n            var formdata = new FormData();\n\n            for (var i = 0; i < a.length; i++) {\n                formdata.append(a[i].name, a[i].value);\n            }\n\n            if (options.extraData) {\n                var serializedData = deepSerialize(options.extraData);\n                for (i = 0; i < serializedData.length; i++) {\n                    if (serializedData[i]) {\n                        formdata.append(serializedData[i][0], serializedData[i][1]);\n                    }\n                }\n            }\n\n            options.data = null;\n\n            var s = $.extend(true, {}, $.ajaxSettings, options, {\n                contentType: false,\n                processData: false,\n                cache: false,\n                type: method || 'POST'\n            });\n\n            if (options.uploadProgress) {\n                // workaround because jqXHR does not expose upload property\n                s.xhr = function () {\n                    var xhr = $.ajaxSettings.xhr();\n                    if (xhr.upload) {\n                        xhr.upload.addEventListener('progress', function (event) {\n                            var percent = 0;\n                            var position = event.loaded || event.position; /*event.position is deprecated*/\n                            var total = event.total;\n                            if (event.lengthComputable) {\n                                percent = Math.ceil(position / total * 100);\n                            }\n                            options.uploadProgress(event, position, total, percent);\n                        }, false);\n                    }\n                    return xhr;\n                };\n            }\n\n            s.data = null;\n            var beforeSend = s.beforeSend;\n            s.beforeSend = function (xhr, o) {\n                //Send FormData() provided by user\n                if (options.formData) {\n                    o.data = options.formData;\n                } else {\n                    o.data = formdata;\n                }\n                if (beforeSend) {\n                    beforeSend.call(this, xhr, o);\n                }\n            };\n            return $.ajax(s);\n        }\n\n        // private function for handling file uploads (hat tip to YAHOO!)\n        function fileUploadIframe(a) {\n            var form = $form[0],\n                el,\n                i,\n                s,\n                g,\n                id,\n                $io,\n                io,\n                xhr,\n                sub,\n                n,\n                timedOut,\n                timeoutHandle;\n            var deferred = $.Deferred();\n\n            // #341\n            deferred.abort = function (status) {\n                xhr.abort(status);\n            };\n\n            if (a) {\n                // ensure that every serialized input is still enabled\n                for (i = 0; i < elements.length; i++) {\n                    el = $(elements[i]);\n                    if (hasProp) {\n                        el.prop('disabled', false);\n                    } else {\n                        el.removeAttr('disabled');\n                    }\n                }\n            }\n\n            s = $.extend(true, {}, $.ajaxSettings, options);\n            s.context = s.context || s;\n            id = 'jqFormIO' + new Date().getTime();\n            if (s.iframeTarget) {\n                $io = $(s.iframeTarget);\n                n = $io.attr2('name');\n                if (!n) {\n                    $io.attr2('name', id);\n                } else {\n                    id = n;\n                }\n            } else {\n                $io = $('<iframe name=\"' + id + '\" src=\"' + s.iframeSrc + '\" />');\n                $io.css({ position: 'absolute', top: '-1000px', left: '-1000px' });\n            }\n            io = $io[0];\n\n            xhr = { // mock object\n                aborted: 0,\n                responseText: null,\n                responseXML: null,\n                status: 0,\n                statusText: 'n/a',\n                getAllResponseHeaders: function getAllResponseHeaders() {},\n                getResponseHeader: function getResponseHeader() {},\n                setRequestHeader: function setRequestHeader() {},\n                abort: function abort(status) {\n                    var e = status === 'timeout' ? 'timeout' : 'aborted';\n                    log('aborting upload... ' + e);\n                    this.aborted = 1;\n\n                    try {\n                        // #214, #257\n                        if (io.contentWindow.document.execCommand) {\n                            io.contentWindow.document.execCommand('Stop');\n                        }\n                    } catch (ignore) {}\n\n                    $io.attr('src', s.iframeSrc); // abort op in progress\n                    xhr.error = e;\n                    if (s.error) {\n                        s.error.call(s.context, xhr, e, status);\n                    }\n                    if (g) {\n                        $.event.trigger(\"ajaxError\", [xhr, s, e]);\n                    }\n                    if (s.complete) {\n                        s.complete.call(s.context, xhr, e);\n                    }\n                }\n            };\n\n            g = s.global;\n            // trigger ajax global events so that activity/block indicators work like normal\n            if (g && 0 === $.active++) {\n                $.event.trigger(\"ajaxStart\");\n            }\n            if (g) {\n                $.event.trigger(\"ajaxSend\", [xhr, s]);\n            }\n\n            if (s.beforeSend && s.beforeSend.call(s.context, xhr, s) === false) {\n                if (s.global) {\n                    $.active--;\n                }\n                deferred.reject();\n                return deferred;\n            }\n            if (xhr.aborted) {\n                deferred.reject();\n                return deferred;\n            }\n\n            // add submitting element to data if we know it\n            sub = form.clk;\n            if (sub) {\n                n = sub.name;\n                if (n && !sub.disabled) {\n                    s.extraData = s.extraData || {};\n                    s.extraData[n] = sub.value;\n                    if (sub.type == \"image\") {\n                        s.extraData[n + '.x'] = form.clk_x;\n                        s.extraData[n + '.y'] = form.clk_y;\n                    }\n                }\n            }\n\n            var CLIENT_TIMEOUT_ABORT = 1;\n            var SERVER_ABORT = 2;\n\n            function getDoc(frame) {\n                /* it looks like contentWindow or contentDocument do not\n                 * carry the protocol property in ie8, when running under ssl\n                 * frame.document is the only valid response document, since\n                 * the protocol is know but not on the other two objects. strange?\n                 * \"Same origin policy\" http://en.wikipedia.org/wiki/Same_origin_policy\n                 */\n\n                var doc = null;\n\n                // IE8 cascading access check\n                try {\n                    if (frame.contentWindow) {\n                        doc = frame.contentWindow.document;\n                    }\n                } catch (err) {\n                    // IE8 access denied under ssl & missing protocol\n                    log('cannot get iframe.contentWindow document: ' + err);\n                }\n\n                if (doc) {\n                    // successful getting content\n                    return doc;\n                }\n\n                try {\n                    // simply checking may throw in ie8 under ssl or mismatched protocol\n                    doc = frame.contentDocument ? frame.contentDocument : frame.document;\n                } catch (err) {\n                    // last attempt\n                    log('cannot get iframe.contentDocument: ' + err);\n                    doc = frame.document;\n                }\n                return doc;\n            }\n\n            // Rails CSRF hack (thanks to Yvan Barthelemy)\n            var csrf_token = $('meta[name=csrf-token]').attr('content');\n            var csrf_param = $('meta[name=csrf-param]').attr('content');\n            if (csrf_param && csrf_token) {\n                s.extraData = s.extraData || {};\n                s.extraData[csrf_param] = csrf_token;\n            }\n\n            // take a breath so that pending repaints get some cpu time before the upload starts\n            function doSubmit() {\n                // make sure form attrs are set\n                var t = $form.attr2('target'),\n                    a = $form.attr2('action'),\n                    mp = 'multipart/form-data',\n                    et = $form.attr('enctype') || $form.attr('encoding') || mp;\n\n                // update form attrs in IE friendly way\n                form.setAttribute('target', id);\n                if (!method || /post/i.test(method)) {\n                    form.setAttribute('method', 'POST');\n                }\n                if (a != s.url) {\n                    form.setAttribute('action', s.url);\n                }\n\n                // ie borks in some cases when setting encoding\n                if (!s.skipEncodingOverride && (!method || /post/i.test(method))) {\n                    $form.attr({\n                        encoding: 'multipart/form-data',\n                        enctype: 'multipart/form-data'\n                    });\n                }\n\n                // support timout\n                if (s.timeout) {\n                    timeoutHandle = setTimeout(function () {\n                        timedOut = true;cb(CLIENT_TIMEOUT_ABORT);\n                    }, s.timeout);\n                }\n\n                // look for server aborts\n                function checkState() {\n                    try {\n                        var state = getDoc(io).readyState;\n                        log('state = ' + state);\n                        if (state && state.toLowerCase() == 'uninitialized') {\n                            setTimeout(checkState, 50);\n                        }\n                    } catch (e) {\n                        log('Server abort: ', e, ' (', e.name, ')');\n                        cb(SERVER_ABORT);\n                        if (timeoutHandle) {\n                            clearTimeout(timeoutHandle);\n                        }\n                        timeoutHandle = undefined;\n                    }\n                }\n\n                // add \"extra\" data to form if provided in options\n                var extraInputs = [];\n                try {\n                    if (s.extraData) {\n                        for (var n in s.extraData) {\n                            if (s.extraData.hasOwnProperty(n)) {\n                                // if using the $.param format that allows for multiple values with the same name\n                                if ($.isPlainObject(s.extraData[n]) && s.extraData[n].hasOwnProperty('name') && s.extraData[n].hasOwnProperty('value')) {\n                                    extraInputs.push($('<input type=\"hidden\" name=\"' + s.extraData[n].name + '\">').val(s.extraData[n].value).appendTo(form)[0]);\n                                } else {\n                                    extraInputs.push($('<input type=\"hidden\" name=\"' + n + '\">').val(s.extraData[n]).appendTo(form)[0]);\n                                }\n                            }\n                        }\n                    }\n\n                    if (!s.iframeTarget) {\n                        // add iframe to doc and submit the form\n                        $io.appendTo('body');\n                    }\n                    if (io.attachEvent) {\n                        io.attachEvent('onload', cb);\n                    } else {\n                        io.addEventListener('load', cb, false);\n                    }\n                    setTimeout(checkState, 15);\n\n                    try {\n                        form.submit();\n                    } catch (err) {\n                        // just in case form has element with name/id of 'submit'\n                        var submitFn = document.createElement('form').submit;\n                        submitFn.apply(form);\n                    }\n                } finally {\n                    // reset attrs and remove \"extra\" input elements\n                    form.setAttribute('action', a);\n                    form.setAttribute('enctype', et); // #380\n                    if (t) {\n                        form.setAttribute('target', t);\n                    } else {\n                        $form.removeAttr('target');\n                    }\n                    $(extraInputs).remove();\n                }\n            }\n\n            if (s.forceSync) {\n                doSubmit();\n            } else {\n                setTimeout(doSubmit, 10); // this lets dom updates render\n            }\n\n            var data,\n                doc,\n                domCheckCount = 50,\n                callbackProcessed;\n\n            function cb(e) {\n                if (xhr.aborted || callbackProcessed) {\n                    return;\n                }\n\n                doc = getDoc(io);\n                if (!doc) {\n                    log('cannot access response document');\n                    e = SERVER_ABORT;\n                }\n                if (e === CLIENT_TIMEOUT_ABORT && xhr) {\n                    xhr.abort('timeout');\n                    deferred.reject(xhr, 'timeout');\n                    return;\n                } else if (e == SERVER_ABORT && xhr) {\n                    xhr.abort('server abort');\n                    deferred.reject(xhr, 'error', 'server abort');\n                    return;\n                }\n\n                if (!doc || doc.location.href == s.iframeSrc) {\n                    // response not received yet\n                    if (!timedOut) {\n                        return;\n                    }\n                }\n                if (io.detachEvent) {\n                    io.detachEvent('onload', cb);\n                } else {\n                    io.removeEventListener('load', cb, false);\n                }\n\n                var status = 'success',\n                    errMsg;\n                try {\n                    if (timedOut) {\n                        throw 'timeout';\n                    }\n\n                    var isXml = s.dataType == 'xml' || doc.XMLDocument || $.isXMLDoc(doc);\n                    log('isXml=' + isXml);\n                    if (!isXml && window.opera && (doc.body === null || !doc.body.innerHTML)) {\n                        if (--domCheckCount) {\n                            // in some browsers (Opera) the iframe DOM is not always traversable when\n                            // the onload callback fires, so we loop a bit to accommodate\n                            log('requeing onLoad callback, DOM not available');\n                            setTimeout(cb, 250);\n                            return;\n                        }\n                        // let this fall through because server response could be an empty document\n                        //log('Could not access iframe DOM after mutiple tries.');\n                        //throw 'DOMException: not available';\n                    }\n\n                    //log('response detected');\n                    var docRoot = doc.body ? doc.body : doc.documentElement;\n                    xhr.responseText = docRoot ? docRoot.innerHTML : null;\n                    xhr.responseXML = doc.XMLDocument ? doc.XMLDocument : doc;\n                    if (isXml) {\n                        s.dataType = 'xml';\n                    }\n                    xhr.getResponseHeader = function (header) {\n                        var headers = { 'content-type': s.dataType };\n                        return headers[header.toLowerCase()];\n                    };\n                    // support for XHR 'status' & 'statusText' emulation :\n                    if (docRoot) {\n                        xhr.status = Number(docRoot.getAttribute('status')) || xhr.status;\n                        xhr.statusText = docRoot.getAttribute('statusText') || xhr.statusText;\n                    }\n\n                    var dt = (s.dataType || '').toLowerCase();\n                    var scr = /(json|script|text)/.test(dt);\n                    if (scr || s.textarea) {\n                        // see if user embedded response in textarea\n                        var ta = doc.getElementsByTagName('textarea')[0];\n                        if (ta) {\n                            xhr.responseText = ta.value;\n                            // support for XHR 'status' & 'statusText' emulation :\n                            xhr.status = Number(ta.getAttribute('status')) || xhr.status;\n                            xhr.statusText = ta.getAttribute('statusText') || xhr.statusText;\n                        } else if (scr) {\n                            // account for browsers injecting pre around json response\n                            var pre = doc.getElementsByTagName('pre')[0];\n                            var b = doc.getElementsByTagName('body')[0];\n                            if (pre) {\n                                xhr.responseText = pre.textContent ? pre.textContent : pre.innerText;\n                            } else if (b) {\n                                xhr.responseText = b.textContent ? b.textContent : b.innerText;\n                            }\n                        }\n                    } else if (dt == 'xml' && !xhr.responseXML && xhr.responseText) {\n                        xhr.responseXML = toXml(xhr.responseText);\n                    }\n\n                    try {\n                        data = httpData(xhr, dt, s);\n                    } catch (err) {\n                        status = 'parsererror';\n                        xhr.error = errMsg = err || status;\n                    }\n                } catch (err) {\n                    log('error caught: ', err);\n                    status = 'error';\n                    xhr.error = errMsg = err || status;\n                }\n\n                if (xhr.aborted) {\n                    log('upload aborted');\n                    status = null;\n                }\n\n                if (xhr.status) {\n                    // we've set xhr.status\n                    status = xhr.status >= 200 && xhr.status < 300 || xhr.status === 304 ? 'success' : 'error';\n                }\n\n                // ordering of these callbacks/triggers is odd, but that's how $.ajax does it\n                if (status === 'success') {\n                    if (s.success) {\n                        s.success.call(s.context, data, 'success', xhr);\n                    }\n                    deferred.resolve(xhr.responseText, 'success', xhr);\n                    if (g) {\n                        $.event.trigger(\"ajaxSuccess\", [xhr, s]);\n                    }\n                } else if (status) {\n                    if (errMsg === undefined) {\n                        errMsg = xhr.statusText;\n                    }\n                    if (s.error) {\n                        s.error.call(s.context, xhr, status, errMsg);\n                    }\n                    deferred.reject(xhr, 'error', errMsg);\n                    if (g) {\n                        $.event.trigger(\"ajaxError\", [xhr, s, errMsg]);\n                    }\n                }\n\n                if (g) {\n                    $.event.trigger(\"ajaxComplete\", [xhr, s]);\n                }\n\n                if (g && ! --$.active) {\n                    $.event.trigger(\"ajaxStop\");\n                }\n\n                if (s.complete) {\n                    s.complete.call(s.context, xhr, status);\n                }\n\n                callbackProcessed = true;\n                if (s.timeout) {\n                    clearTimeout(timeoutHandle);\n                }\n\n                // clean up\n                setTimeout(function () {\n                    if (!s.iframeTarget) {\n                        $io.remove();\n                    } else {\n                        //adding else to clean up existing iframe response.\n                        $io.attr('src', s.iframeSrc);\n                    }\n                    xhr.responseXML = null;\n                }, 100);\n            }\n\n            var toXml = $.parseXML || function (s, doc) {\n                // use parseXML if available (jQuery 1.5+)\n                if (window.ActiveXObject) {\n                    doc = new ActiveXObject('Microsoft.XMLDOM');\n                    doc.async = 'false';\n                    doc.loadXML(s);\n                } else {\n                    doc = new DOMParser().parseFromString(s, 'text/xml');\n                }\n                return doc && doc.documentElement && doc.documentElement.nodeName != 'parsererror' ? doc : null;\n            };\n            var parseJSON = $.parseJSON || function (s) {\n                /*jslint evil:true */\n                return window['eval']('(' + s + ')');\n            };\n\n            var httpData = function httpData(xhr, type, s) {\n                // mostly lifted from jq1.4.4\n\n                var ct = xhr.getResponseHeader('content-type') || '',\n                    xml = type === 'xml' || !type && ct.indexOf('xml') >= 0,\n                    data = xml ? xhr.responseXML : xhr.responseText;\n\n                if (xml && data.documentElement.nodeName === 'parsererror') {\n                    if ($.error) {\n                        $.error('parsererror');\n                    }\n                }\n                if (s && s.dataFilter) {\n                    data = s.dataFilter(data, type);\n                }\n                if (typeof data === 'string') {\n                    if (type === 'json' || !type && ct.indexOf('json') >= 0) {\n                        data = parseJSON(data);\n                    } else if (type === \"script\" || !type && ct.indexOf(\"javascript\") >= 0) {\n                        $.globalEval(data);\n                    }\n                }\n                return data;\n            };\n\n            return deferred;\n        }\n    };\n\n    /**\n     * ajaxForm() provides a mechanism for fully automating form submission.\n     *\n     * The advantages of using this method instead of ajaxSubmit() are:\n     *\n     * 1: This method will include coordinates for <input type=\"image\" /> elements (if the element\n     *    is used to submit the form).\n     * 2. This method will include the submit element's name/value data (for the element that was\n     *    used to submit the form).\n     * 3. This method binds the submit() method to the form for you.\n     *\n     * The options argument for ajaxForm works exactly as it does for ajaxSubmit.  ajaxForm merely\n     * passes the options argument along after properly binding events for submit elements and\n     * the form itself.\n     */\n    $.fn.ajaxForm = function (options) {\n        options = options || {};\n        options.delegation = options.delegation && $.isFunction($.fn.on);\n\n        // in jQuery 1.3+ we can fix mistakes with the ready state\n        if (!options.delegation && this.length === 0) {\n            var o = { s: this.selector, c: this.context };\n            if (!$.isReady && o.s) {\n                log('DOM not ready, queuing ajaxForm');\n                $(function () {\n                    $(o.s, o.c).ajaxForm(options);\n                });\n                return this;\n            }\n            // is your DOM ready?  http://docs.jquery.com/Tutorials:Introducing_$(document).ready()\n            log('terminating; zero elements found by selector' + ($.isReady ? '' : ' (DOM not ready)'));\n            return this;\n        }\n\n        if (options.delegation) {\n            $(document).off('submit.form-plugin', this.selector, doAjaxSubmit).off('click.form-plugin', this.selector, captureSubmittingElement).on('submit.form-plugin', this.selector, options, doAjaxSubmit).on('click.form-plugin', this.selector, options, captureSubmittingElement);\n            return this;\n        }\n\n        return this.ajaxFormUnbind().bind('submit.form-plugin', options, doAjaxSubmit).bind('click.form-plugin', options, captureSubmittingElement);\n    };\n\n    // private event handlers\n    function doAjaxSubmit(e) {\n        /*jshint validthis:true */\n        var options = e.data;\n        if (!e.isDefaultPrevented()) {\n            // if event has been canceled, don't proceed\n            e.preventDefault();\n            $(e.target).ajaxSubmit(options); // #365\n        }\n    }\n\n    function captureSubmittingElement(e) {\n        /*jshint validthis:true */\n        var target = e.target;\n        var $el = $(target);\n        if (!$el.is(\"[type=submit],[type=image]\")) {\n            // is this a child element of the submit el?  (ex: a span within a button)\n            var t = $el.closest('[type=submit]');\n            if (t.length === 0) {\n                return;\n            }\n            target = t[0];\n        }\n        var form = this;\n        form.clk = target;\n        if (target.type == 'image') {\n            if (e.offsetX !== undefined) {\n                form.clk_x = e.offsetX;\n                form.clk_y = e.offsetY;\n            } else if (typeof $.fn.offset == 'function') {\n                var offset = $el.offset();\n                form.clk_x = e.pageX - offset.left;\n                form.clk_y = e.pageY - offset.top;\n            } else {\n                form.clk_x = e.pageX - target.offsetLeft;\n                form.clk_y = e.pageY - target.offsetTop;\n            }\n        }\n        // clear form vars\n        setTimeout(function () {\n            form.clk = form.clk_x = form.clk_y = null;\n        }, 100);\n    }\n\n    // ajaxFormUnbind unbinds the event handlers that were bound by ajaxForm\n    $.fn.ajaxFormUnbind = function () {\n        return this.unbind('submit.form-plugin click.form-plugin');\n    };\n\n    /**\n     * formToArray() gathers form element data into an array of objects that can\n     * be passed to any of the following ajax functions: $.get, $.post, or load.\n     * Each object in the array has both a 'name' and 'value' property.  An example of\n     * an array for a simple login form might be:\n     *\n     * [ { name: 'username', value: 'jresig' }, { name: 'password', value: 'secret' } ]\n     *\n     * It is this array that is passed to pre-submit callback functions provided to the\n     * ajaxSubmit() and ajaxForm() methods.\n     */\n    $.fn.formToArray = function (semantic, elements) {\n        var a = [];\n        if (this.length === 0) {\n            return a;\n        }\n\n        var form = this[0];\n        var formId = this.attr('id');\n        var els = semantic ? form.getElementsByTagName('*') : form.elements;\n        var els2;\n\n        if (els && !/MSIE [678]/.test(navigator.userAgent)) {\n            // #390\n            els = $(els).get(); // convert to standard array\n        }\n\n        // #386; account for inputs outside the form which use the 'form' attribute\n        if (formId) {\n            els2 = $(':input[form=\"' + formId + '\"]').get(); // hat tip @thet\n            if (els2.length) {\n                els = (els || []).concat(els2);\n            }\n        }\n\n        if (!els || !els.length) {\n            return a;\n        }\n\n        var i, j, n, v, el, max, jmax;\n        for (i = 0, max = els.length; i < max; i++) {\n            el = els[i];\n            n = el.name;\n            if (!n || el.disabled) {\n                continue;\n            }\n\n            if (semantic && form.clk && el.type == \"image\") {\n                // handle image inputs on the fly when semantic == true\n                if (form.clk == el) {\n                    a.push({ name: n, value: $(el).val(), type: el.type });\n                    a.push({ name: n + '.x', value: form.clk_x }, { name: n + '.y', value: form.clk_y });\n                }\n                continue;\n            }\n\n            v = $.fieldValue(el, true);\n            if (v && v.constructor == Array) {\n                if (elements) {\n                    elements.push(el);\n                }\n                for (j = 0, jmax = v.length; j < jmax; j++) {\n                    a.push({ name: n, value: v[j] });\n                }\n            } else if (feature.fileapi && el.type == 'file') {\n                if (elements) {\n                    elements.push(el);\n                }\n                var files = el.files;\n                if (files.length) {\n                    for (j = 0; j < files.length; j++) {\n                        a.push({ name: n, value: files[j], type: el.type });\n                    }\n                } else {\n                    // #180\n                    a.push({ name: n, value: '', type: el.type });\n                }\n            } else if (v !== null && typeof v != 'undefined') {\n                if (elements) {\n                    elements.push(el);\n                }\n                a.push({ name: n, value: v, type: el.type, required: el.required });\n            }\n        }\n\n        if (!semantic && form.clk) {\n            // input type=='image' are not found in elements array! handle it here\n            var $input = $(form.clk),\n                input = $input[0];\n            n = input.name;\n            if (n && !input.disabled && input.type == 'image') {\n                a.push({ name: n, value: $input.val() });\n                a.push({ name: n + '.x', value: form.clk_x }, { name: n + '.y', value: form.clk_y });\n            }\n        }\n        return a;\n    };\n\n    /**\n     * Serializes form data into a 'submittable' string. This method will return a string\n     * in the format: name1=value1&amp;name2=value2\n     */\n    $.fn.formSerialize = function (semantic) {\n        //hand off to jQuery.param for proper encoding\n        return $.param(this.formToArray(semantic));\n    };\n\n    /**\n     * Serializes all field elements in the jQuery object into a query string.\n     * This method will return a string in the format: name1=value1&amp;name2=value2\n     */\n    $.fn.fieldSerialize = function (successful) {\n        var a = [];\n        this.each(function () {\n            var n = this.name;\n            if (!n) {\n                return;\n            }\n            var v = $.fieldValue(this, successful);\n            if (v && v.constructor == Array) {\n                for (var i = 0, max = v.length; i < max; i++) {\n                    a.push({ name: n, value: v[i] });\n                }\n            } else if (v !== null && typeof v != 'undefined') {\n                a.push({ name: this.name, value: v });\n            }\n        });\n        //hand off to jQuery.param for proper encoding\n        return $.param(a);\n    };\n\n    /**\n     * Returns the value(s) of the element in the matched set.  For example, consider the following form:\n     *\n     *  <form><fieldset>\n     *      <input name=\"A\" type=\"text\" />\n     *      <input name=\"A\" type=\"text\" />\n     *      <input name=\"B\" type=\"checkbox\" value=\"B1\" />\n     *      <input name=\"B\" type=\"checkbox\" value=\"B2\"/>\n     *      <input name=\"C\" type=\"radio\" value=\"C1\" />\n     *      <input name=\"C\" type=\"radio\" value=\"C2\" />\n     *  </fieldset></form>\n     *\n     *  var v = $('input[type=text]').fieldValue();\n     *  // if no values are entered into the text inputs\n     *  v == ['','']\n     *  // if values entered into the text inputs are 'foo' and 'bar'\n     *  v == ['foo','bar']\n     *\n     *  var v = $('input[type=checkbox]').fieldValue();\n     *  // if neither checkbox is checked\n     *  v === undefined\n     *  // if both checkboxes are checked\n     *  v == ['B1', 'B2']\n     *\n     *  var v = $('input[type=radio]').fieldValue();\n     *  // if neither radio is checked\n     *  v === undefined\n     *  // if first radio is checked\n     *  v == ['C1']\n     *\n     * The successful argument controls whether or not the field element must be 'successful'\n     * (per http://www.w3.org/TR/html4/interact/forms.html#successful-controls).\n     * The default value of the successful argument is true.  If this value is false the value(s)\n     * for each element is returned.\n     *\n     * Note: This method *always* returns an array.  If no valid value can be determined the\n     *    array will be empty, otherwise it will contain one or more values.\n     */\n    $.fn.fieldValue = function (successful) {\n        for (var val = [], i = 0, max = this.length; i < max; i++) {\n            var el = this[i];\n            var v = $.fieldValue(el, successful);\n            if (v === null || typeof v == 'undefined' || v.constructor == Array && !v.length) {\n                continue;\n            }\n            if (v.constructor == Array) {\n                $.merge(val, v);\n            } else {\n                val.push(v);\n            }\n        }\n        return val;\n    };\n\n    /**\n     * Returns the value of the field element.\n     */\n    $.fieldValue = function (el, successful) {\n        var n = el.name,\n            t = el.type,\n            tag = el.tagName.toLowerCase();\n        if (successful === undefined) {\n            successful = true;\n        }\n\n        if (successful && (!n || el.disabled || t == 'reset' || t == 'button' || (t == 'checkbox' || t == 'radio') && !el.checked || (t == 'submit' || t == 'image') && el.form && el.form.clk != el || tag == 'select' && el.selectedIndex == -1)) {\n            return null;\n        }\n\n        if (tag == 'select') {\n            var index = el.selectedIndex;\n            if (index < 0) {\n                return null;\n            }\n            var a = [],\n                ops = el.options;\n            var one = t == 'select-one';\n            var max = one ? index + 1 : ops.length;\n            for (var i = one ? index : 0; i < max; i++) {\n                var op = ops[i];\n                if (op.selected) {\n                    var v = op.value;\n                    if (!v) {\n                        // extra pain for IE...\n                        v = op.attributes && op.attributes.value && !op.attributes.value.specified ? op.text : op.value;\n                    }\n                    if (one) {\n                        return v;\n                    }\n                    a.push(v);\n                }\n            }\n            return a;\n        }\n        return $(el).val();\n    };\n\n    /**\n     * Clears the form data.  Takes the following actions on the form's input fields:\n     *  - input text fields will have their 'value' property set to the empty string\n     *  - select elements will have their 'selectedIndex' property set to -1\n     *  - checkbox and radio inputs will have their 'checked' property set to false\n     *  - inputs of type submit, button, reset, and hidden will *not* be effected\n     *  - button elements will *not* be effected\n     */\n    $.fn.clearForm = function (includeHidden) {\n        return this.each(function () {\n            $('input,select,textarea', this).clearFields(includeHidden);\n        });\n    };\n\n    /**\n     * Clears the selected form elements.\n     */\n    $.fn.clearFields = $.fn.clearInputs = function (includeHidden) {\n        var re = /^(?:color|date|datetime|email|month|number|password|range|search|tel|text|time|url|week)$/i; // 'hidden' is not in this list\n        return this.each(function () {\n            var t = this.type,\n                tag = this.tagName.toLowerCase();\n            if (re.test(t) || tag == 'textarea') {\n                this.value = '';\n            } else if (t == 'checkbox' || t == 'radio') {\n                this.checked = false;\n            } else if (tag == 'select') {\n                this.selectedIndex = -1;\n            } else if (t == \"file\") {\n                if (/MSIE/.test(navigator.userAgent)) {\n                    $(this).replaceWith($(this).clone(true));\n                } else {\n                    $(this).val('');\n                }\n            } else if (includeHidden) {\n                // includeHidden can be the value true, or it can be a selector string\n                // indicating a special test; for example:\n                //  $('#myForm').clearForm('.special:hidden')\n                // the above would clean hidden inputs that have the class of 'special'\n                if (includeHidden === true && /hidden/.test(t) || typeof includeHidden == 'string' && $(this).is(includeHidden)) {\n                    this.value = '';\n                }\n            }\n        });\n    };\n\n    /**\n     * Resets the form data.  Causes all form elements to be reset to their original value.\n     */\n    $.fn.resetForm = function () {\n        return this.each(function () {\n            // guard against an input with the name of 'reset'\n            // note that IE reports the reset function as an 'object'\n            if (typeof this.reset == 'function' || _typeof(this.reset) == 'object' && !this.reset.nodeType) {\n                this.reset();\n            }\n        });\n    };\n\n    /**\n     * Enables or disables any matching elements.\n     */\n    $.fn.enable = function (b) {\n        if (b === undefined) {\n            b = true;\n        }\n        return this.each(function () {\n            this.disabled = !b;\n        });\n    };\n\n    /**\n     * Checks/unchecks any matching checkboxes or radio buttons and\n     * selects/deselects and matching option elements.\n     */\n    $.fn.selected = function (select) {\n        if (select === undefined) {\n            select = true;\n        }\n        return this.each(function () {\n            var t = this.type;\n            if (t == 'checkbox' || t == 'radio') {\n                this.checked = select;\n            } else if (this.tagName.toLowerCase() == 'option') {\n                var $sel = $(this).parent('select');\n                if (select && $sel[0] && $sel[0].type == 'select-one') {\n                    // deselect all other options\n                    $sel.find('option').selected(false);\n                }\n                this.selected = select;\n            }\n        });\n    };\n\n    // expose debug var\n    $.fn.ajaxSubmit.debug = false;\n\n    // helper fn for console logging\n    function log() {\n        if (!$.fn.ajaxSubmit.debug) {\n            return;\n        }\n        var msg = '[jquery.form] ' + Array.prototype.join.call(arguments, '');\n        if (window.console && window.console.log) {\n            window.console.log(msg);\n        } else if (window.opera && window.opera.postError) {\n            window.opera.postError(msg);\n        }\n    }\n});"

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./node_modules/babel-loader/lib/index.js??ref--0-0!./assets/js/jquery.qtip.nightly.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/raw-loader!./node_modules/babel-loader/lib??ref--0-0!./assets/js/jquery.qtip.nightly.js ***!
  \**************************************************************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports) {

module.exports = "var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/*\n * qTip2 - Pretty powerful tooltips - v2.2.1-29-\n * http://qtip2.com\n *\n * Copyright (c) 2015 \n * Released under the MIT licenses\n * http://jquery.org/license\n *\n * Date: Tue Dec 8 2015 05:50 EST-0500\n * Plugins: tips modal viewport svg imagemap ie6\n * Styles: core basic css3\n */\n/*global window: false, jQuery: false, console: false, define: false */\n\n/* Cache window, document, undefined */\n(function (window, document, undefined) {\n\n\t// Uses AMD or browser globals to create a jQuery plugin.\n\t(function (factory) {\n\t\t\"use strict\";\n\n\t\tif (typeof define === 'function' && define.amd) {\n\t\t\tdefine(['jquery'], factory);\n\t\t} else if (jQuery && !jQuery.fn.qtip) {\n\t\t\tfactory(jQuery);\n\t\t}\n\t})(function ($) {\n\t\t\"use strict\"; // Enable ECMAScript \"strict\" operation for this function. See more: http://ejohn.org/blog/ecmascript-5-strict-mode-json-and-more/\n\n\t\t; // Munge the primitives - Paul Irish tip\n\t\tvar TRUE = true,\n\t\t    FALSE = false,\n\t\t    NULL = null,\n\n\n\t\t// Common variables\n\t\tX = 'x',\n\t\t    Y = 'y',\n\t\t    WIDTH = 'width',\n\t\t    HEIGHT = 'height',\n\n\n\t\t// Positioning sides\n\t\tTOP = 'top',\n\t\t    LEFT = 'left',\n\t\t    BOTTOM = 'bottom',\n\t\t    RIGHT = 'right',\n\t\t    CENTER = 'center',\n\n\n\t\t// Position adjustment types\n\t\tFLIP = 'flip',\n\t\t    FLIPINVERT = 'flipinvert',\n\t\t    SHIFT = 'shift',\n\n\n\t\t// Shortcut vars\n\t\tQTIP,\n\t\t    PROTOTYPE,\n\t\t    CORNER,\n\t\t    CHECKS,\n\t\t    PLUGINS = {},\n\t\t    NAMESPACE = 'qtip',\n\t\t    ATTR_HAS = 'data-hasqtip',\n\t\t    ATTR_ID = 'data-qtip-id',\n\t\t    WIDGET = ['ui-widget', 'ui-tooltip'],\n\t\t    SELECTOR = '.' + NAMESPACE,\n\t\t    INACTIVE_EVENTS = 'click dblclick mousedown mouseup mousemove mouseleave mouseenter'.split(' '),\n\t\t    CLASS_FIXED = NAMESPACE + '-fixed',\n\t\t    CLASS_DEFAULT = NAMESPACE + '-default',\n\t\t    CLASS_FOCUS = NAMESPACE + '-focus',\n\t\t    CLASS_HOVER = NAMESPACE + '-hover',\n\t\t    CLASS_DISABLED = NAMESPACE + '-disabled',\n\t\t    replaceSuffix = '_replacedByqTip',\n\t\t    oldtitle = 'oldtitle',\n\t\t    trackingBound,\n\n\n\t\t// Browser detection\n\t\tBROWSER = {\n\t\t\t/*\n    * IE version detection\n    *\n    * Adapted from: http://ajaxian.com/archives/attack-of-the-ie-conditional-comment\n    * Credit to James Padolsey for the original implemntation!\n    */\n\t\t\tie: function () {\n\t\t\t\tfor (var v = 4, i = document.createElement(\"div\"); (i.innerHTML = \"<!--[if gt IE \" + v + \"]><i></i><![endif]-->\") && i.getElementsByTagName(\"i\")[0]; v += 1) {}\n\t\t\t\treturn v > 4 ? v : NaN;\n\t\t\t}(),\n\n\t\t\t/*\n    * iOS version detection\n    */\n\t\t\tiOS: parseFloat(('' + (/CPU.*OS ([0-9_]{1,5})|(CPU like).*AppleWebKit.*Mobile/i.exec(navigator.userAgent) || [0, ''])[1]).replace('undefined', '3_2').replace('_', '.').replace('_', '')) || FALSE\n\t\t};\n\t\t;function QTip(target, options, id, attr) {\n\t\t\t// Elements and ID\n\t\t\tthis.id = id;\n\t\t\tthis.target = target;\n\t\t\tthis.tooltip = NULL;\n\t\t\tthis.elements = { target: target };\n\n\t\t\t// Internal constructs\n\t\t\tthis._id = NAMESPACE + '-' + id;\n\t\t\tthis.timers = { img: {} };\n\t\t\tthis.options = options;\n\t\t\tthis.plugins = {};\n\n\t\t\t// Cache object\n\t\t\tthis.cache = {\n\t\t\t\tevent: {},\n\t\t\t\ttarget: $(),\n\t\t\t\tdisabled: FALSE,\n\t\t\t\tattr: attr,\n\t\t\t\tonTooltip: FALSE,\n\t\t\t\tlastClass: ''\n\t\t\t};\n\n\t\t\t// Set the initial flags\n\t\t\tthis.rendered = this.destroyed = this.disabled = this.waiting = this.hiddenDuringWait = this.positioning = this.triggering = FALSE;\n\t\t}\n\t\tPROTOTYPE = QTip.prototype;\n\n\t\tPROTOTYPE._when = function (deferreds) {\n\t\t\treturn $.when.apply($, deferreds);\n\t\t};\n\n\t\tPROTOTYPE.render = function (show) {\n\t\t\tif (this.rendered || this.destroyed) {\n\t\t\t\treturn this;\n\t\t\t} // If tooltip has already been rendered, exit\n\n\t\t\tvar self = this,\n\t\t\t    options = this.options,\n\t\t\t    cache = this.cache,\n\t\t\t    elements = this.elements,\n\t\t\t    text = options.content.text,\n\t\t\t    title = options.content.title,\n\t\t\t    button = options.content.button,\n\t\t\t    posOptions = options.position,\n\t\t\t    namespace = '.' + this._id + ' ',\n\t\t\t    deferreds = [],\n\t\t\t    tooltip;\n\n\t\t\t// Add ARIA attributes to target\n\t\t\t$.attr(this.target[0], 'aria-describedby', this._id);\n\n\t\t\t// Create public position object that tracks current position corners\n\t\t\tcache.posClass = this._createPosClass((this.position = { my: posOptions.my, at: posOptions.at }).my);\n\n\t\t\t// Create tooltip element\n\t\t\tthis.tooltip = elements.tooltip = tooltip = $('<div/>', {\n\t\t\t\t'id': this._id,\n\t\t\t\t'class': [NAMESPACE, CLASS_DEFAULT, options.style.classes, cache.posClass].join(' '),\n\t\t\t\t'width': options.style.width || '',\n\t\t\t\t'height': options.style.height || '',\n\t\t\t\t'tracking': posOptions.target === 'mouse' && posOptions.adjust.mouse,\n\n\t\t\t\t/* ARIA specific attributes */\n\t\t\t\t'role': 'alert',\n\t\t\t\t'aria-live': 'polite',\n\t\t\t\t'aria-atomic': FALSE,\n\t\t\t\t'aria-describedby': this._id + '-content',\n\t\t\t\t'aria-hidden': TRUE\n\t\t\t}).toggleClass(CLASS_DISABLED, this.disabled).attr(ATTR_ID, this.id).data(NAMESPACE, this).appendTo(posOptions.container).append(\n\t\t\t// Create content element\n\t\t\telements.content = $('<div />', {\n\t\t\t\t'class': NAMESPACE + '-content',\n\t\t\t\t'id': this._id + '-content',\n\t\t\t\t'aria-atomic': TRUE\n\t\t\t}));\n\n\t\t\t// Set rendered flag and prevent redundant reposition calls for now\n\t\t\tthis.rendered = -1;\n\t\t\tthis.positioning = TRUE;\n\n\t\t\t// Create title...\n\t\t\tif (title) {\n\t\t\t\tthis._createTitle();\n\n\t\t\t\t// Update title only if its not a callback (called in toggle if so)\n\t\t\t\tif (!$.isFunction(title)) {\n\t\t\t\t\tdeferreds.push(this._updateTitle(title, FALSE));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Create button\n\t\t\tif (button) {\n\t\t\t\tthis._createButton();\n\t\t\t}\n\n\t\t\t// Set proper rendered flag and update content if not a callback function (called in toggle)\n\t\t\tif (!$.isFunction(text)) {\n\t\t\t\tdeferreds.push(this._updateContent(text, FALSE));\n\t\t\t}\n\t\t\tthis.rendered = TRUE;\n\n\t\t\t// Setup widget classes\n\t\t\tthis._setWidget();\n\n\t\t\t// Initialize 'render' plugins\n\t\t\t$.each(PLUGINS, function (name) {\n\t\t\t\tvar instance;\n\t\t\t\tif (this.initialize === 'render' && (instance = this(self))) {\n\t\t\t\t\tself.plugins[name] = instance;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Unassign initial events and assign proper events\n\t\t\tthis._unassignEvents();\n\t\t\tthis._assignEvents();\n\n\t\t\t// When deferreds have completed\n\t\t\tthis._when(deferreds).then(function () {\n\t\t\t\t// tooltiprender event\n\t\t\t\tself._trigger('render');\n\n\t\t\t\t// Reset flags\n\t\t\t\tself.positioning = FALSE;\n\n\t\t\t\t// Show tooltip if not hidden during wait period\n\t\t\t\tif (!self.hiddenDuringWait && (options.show.ready || show)) {\n\t\t\t\t\tself.toggle(TRUE, cache.event, FALSE);\n\t\t\t\t}\n\t\t\t\tself.hiddenDuringWait = FALSE;\n\t\t\t});\n\n\t\t\t// Expose API\n\t\t\tQTIP.api[this.id] = this;\n\n\t\t\treturn this;\n\t\t};\n\n\t\tPROTOTYPE.destroy = function (immediate) {\n\t\t\t// Set flag the signify destroy is taking place to plugins\n\t\t\t// and ensure it only gets destroyed once!\n\t\t\tif (this.destroyed) {\n\t\t\t\treturn this.target;\n\t\t\t}\n\n\t\t\tfunction process() {\n\t\t\t\tif (this.destroyed) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.destroyed = TRUE;\n\n\t\t\t\tvar target = this.target,\n\t\t\t\t    title = target.attr(oldtitle),\n\t\t\t\t    timer;\n\n\t\t\t\t// Destroy tooltip if rendered\n\t\t\t\tif (this.rendered) {\n\t\t\t\t\tthis.tooltip.stop(1, 0).find('*').remove().end().remove();\n\t\t\t\t}\n\n\t\t\t\t// Destroy all plugins\n\t\t\t\t$.each(this.plugins, function (name) {\n\t\t\t\t\tthis.destroy && this.destroy();\n\t\t\t\t});\n\n\t\t\t\t// Clear timers\n\t\t\t\tfor (timer in this.timers) {\n\t\t\t\t\tclearTimeout(this.timers[timer]);\n\t\t\t\t}\n\n\t\t\t\t// Remove api object and ARIA attributes\n\t\t\t\ttarget.removeData(NAMESPACE).removeAttr(ATTR_ID).removeAttr(ATTR_HAS).removeAttr('aria-describedby');\n\n\t\t\t\t// Reset old title attribute if removed\n\t\t\t\tif (this.options.suppress && title) {\n\t\t\t\t\ttarget.attr('title', title).removeAttr(oldtitle);\n\t\t\t\t}\n\n\t\t\t\t// Remove qTip events associated with this API\n\t\t\t\tthis._unassignEvents();\n\n\t\t\t\t// Remove ID from used id objects, and delete object references\n\t\t\t\t// for better garbage collection and leak protection\n\t\t\t\tthis.options = this.elements = this.cache = this.timers = this.plugins = this.mouse = NULL;\n\n\t\t\t\t// Delete epoxsed API object\n\t\t\t\tdelete QTIP.api[this.id];\n\t\t\t}\n\n\t\t\t// If an immediate destroy is needed\n\t\t\tif ((immediate !== TRUE || this.triggering === 'hide') && this.rendered) {\n\t\t\t\tthis.tooltip.one('tooltiphidden', $.proxy(process, this));\n\t\t\t\t!this.triggering && this.hide();\n\t\t\t}\n\n\t\t\t// If we're not in the process of hiding... process\n\t\t\telse {\n\t\t\t\t\tprocess.call(this);\n\t\t\t\t}\n\n\t\t\treturn this.target;\n\t\t};\n\t\t;function invalidOpt(a) {\n\t\t\treturn a === NULL || $.type(a) !== 'object';\n\t\t}\n\n\t\tfunction invalidContent(c) {\n\t\t\treturn !($.isFunction(c) || c && c.attr || c.length || $.type(c) === 'object' && (c.jquery || c.then));\n\t\t}\n\n\t\t// Option object sanitizer\n\t\tfunction sanitizeOptions(opts) {\n\t\t\tvar content, text, ajax, once;\n\n\t\t\tif (invalidOpt(opts)) {\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\tif (invalidOpt(opts.metadata)) {\n\t\t\t\topts.metadata = { type: opts.metadata };\n\t\t\t}\n\n\t\t\tif ('content' in opts) {\n\t\t\t\tcontent = opts.content;\n\n\t\t\t\tif (invalidOpt(content) || content.jquery || content.done) {\n\t\t\t\t\tcontent = opts.content = {\n\t\t\t\t\t\ttext: text = invalidContent(content) ? FALSE : content\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\ttext = content.text;\n\t\t\t\t}\n\n\t\t\t\t// DEPRECATED - Old content.ajax plugin functionality\n\t\t\t\t// Converts it into the proper Deferred syntax\n\t\t\t\tif ('ajax' in content) {\n\t\t\t\t\tajax = content.ajax;\n\t\t\t\t\tonce = ajax && ajax.once !== FALSE;\n\t\t\t\t\tdelete content.ajax;\n\n\t\t\t\t\tcontent.text = function (event, api) {\n\t\t\t\t\t\tvar loading = text || $(this).attr(api.options.content.attr) || 'Loading...',\n\t\t\t\t\t\t    deferred = $.ajax($.extend({}, ajax, { context: api })).then(ajax.success, NULL, ajax.error).then(function (content) {\n\t\t\t\t\t\t\tif (content && once) {\n\t\t\t\t\t\t\t\tapi.set('content.text', content);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn content;\n\t\t\t\t\t\t}, function (xhr, status, error) {\n\t\t\t\t\t\t\tif (api.destroyed || xhr.status === 0) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tapi.set('content.text', status + ': ' + error);\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\treturn !once ? (api.set('content.text', loading), deferred) : loading;\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tif ('title' in content) {\n\t\t\t\t\tif ($.isPlainObject(content.title)) {\n\t\t\t\t\t\tcontent.button = content.title.button;\n\t\t\t\t\t\tcontent.title = content.title.text;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (invalidContent(content.title || FALSE)) {\n\t\t\t\t\t\tcontent.title = FALSE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ('position' in opts && invalidOpt(opts.position)) {\n\t\t\t\topts.position = { my: opts.position, at: opts.position };\n\t\t\t}\n\n\t\t\tif ('show' in opts && invalidOpt(opts.show)) {\n\t\t\t\topts.show = opts.show.jquery ? { target: opts.show } : opts.show === TRUE ? { ready: TRUE } : { event: opts.show };\n\t\t\t}\n\n\t\t\tif ('hide' in opts && invalidOpt(opts.hide)) {\n\t\t\t\topts.hide = opts.hide.jquery ? { target: opts.hide } : { event: opts.hide };\n\t\t\t}\n\n\t\t\tif ('style' in opts && invalidOpt(opts.style)) {\n\t\t\t\topts.style = { classes: opts.style };\n\t\t\t}\n\n\t\t\t// Sanitize plugin options\n\t\t\t$.each(PLUGINS, function () {\n\t\t\t\tthis.sanitize && this.sanitize(opts);\n\t\t\t});\n\n\t\t\treturn opts;\n\t\t}\n\n\t\t// Setup builtin .set() option checks\n\t\tCHECKS = PROTOTYPE.checks = {\n\t\t\tbuiltin: {\n\t\t\t\t// Core checks\n\t\t\t\t'^id$': function id$(obj, o, v, prev) {\n\t\t\t\t\tvar id = v === TRUE ? QTIP.nextid : v,\n\t\t\t\t\t    new_id = NAMESPACE + '-' + id;\n\n\t\t\t\t\tif (id !== FALSE && id.length > 0 && !$('#' + new_id).length) {\n\t\t\t\t\t\tthis._id = new_id;\n\n\t\t\t\t\t\tif (this.rendered) {\n\t\t\t\t\t\t\tthis.tooltip[0].id = this._id;\n\t\t\t\t\t\t\tthis.elements.content[0].id = this._id + '-content';\n\t\t\t\t\t\t\tthis.elements.title[0].id = this._id + '-title';\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tobj[o] = prev;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t'^prerender': function prerender(obj, o, v) {\n\t\t\t\t\tv && !this.rendered && this.render(this.options.show.ready);\n\t\t\t\t},\n\n\t\t\t\t// Content checks\n\t\t\t\t'^content.text$': function contentText$(obj, o, v) {\n\t\t\t\t\tthis._updateContent(v);\n\t\t\t\t},\n\t\t\t\t'^content.attr$': function contentAttr$(obj, o, v, prev) {\n\t\t\t\t\tif (this.options.content.text === this.target.attr(prev)) {\n\t\t\t\t\t\tthis._updateContent(this.target.attr(v));\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t'^content.title$': function contentTitle$(obj, o, v) {\n\t\t\t\t\t// Remove title if content is null\n\t\t\t\t\tif (!v) {\n\t\t\t\t\t\treturn this._removeTitle();\n\t\t\t\t\t}\n\n\t\t\t\t\t// If title isn't already created, create it now and update\n\t\t\t\t\tv && !this.elements.title && this._createTitle();\n\t\t\t\t\tthis._updateTitle(v);\n\t\t\t\t},\n\t\t\t\t'^content.button$': function contentButton$(obj, o, v) {\n\t\t\t\t\tthis._updateButton(v);\n\t\t\t\t},\n\t\t\t\t'^content.title.(text|button)$': function contentTitleTextButton$(obj, o, v) {\n\t\t\t\t\tthis.set('content.' + o, v); // Backwards title.text/button compat\n\t\t\t\t},\n\n\t\t\t\t// Position checks\n\t\t\t\t'^position.(my|at)$': function positionMyAt$(obj, o, v) {\n\t\t\t\t\tif ('string' === typeof v) {\n\t\t\t\t\t\tthis.position[o] = obj[o] = new CORNER(v, o === 'at');\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t'^position.container$': function positionContainer$(obj, o, v) {\n\t\t\t\t\tthis.rendered && this.tooltip.appendTo(v);\n\t\t\t\t},\n\n\t\t\t\t// Show checks\n\t\t\t\t'^show.ready$': function showReady$(obj, o, v) {\n\t\t\t\t\tv && (!this.rendered && this.render(TRUE) || this.toggle(TRUE));\n\t\t\t\t},\n\n\t\t\t\t// Style checks\n\t\t\t\t'^style.classes$': function styleClasses$(obj, o, v, p) {\n\t\t\t\t\tthis.rendered && this.tooltip.removeClass(p).addClass(v);\n\t\t\t\t},\n\t\t\t\t'^style.(width|height)': function styleWidthHeight(obj, o, v) {\n\t\t\t\t\tthis.rendered && this.tooltip.css(o, v);\n\t\t\t\t},\n\t\t\t\t'^style.widget|content.title': function styleWidgetContentTitle() {\n\t\t\t\t\tthis.rendered && this._setWidget();\n\t\t\t\t},\n\t\t\t\t'^style.def': function styleDef(obj, o, v) {\n\t\t\t\t\tthis.rendered && this.tooltip.toggleClass(CLASS_DEFAULT, !!v);\n\t\t\t\t},\n\n\t\t\t\t// Events check\n\t\t\t\t'^events.(render|show|move|hide|focus|blur)$': function eventsRenderShowMoveHideFocusBlur$(obj, o, v) {\n\t\t\t\t\tthis.rendered && this.tooltip[($.isFunction(v) ? '' : 'un') + 'bind']('tooltip' + o, v);\n\t\t\t\t},\n\n\t\t\t\t// Properties which require event reassignment\n\t\t\t\t'^(show|hide|position).(event|target|fixed|inactive|leave|distance|viewport|adjust)': function showHidePositionEventTargetFixedInactiveLeaveDistanceViewportAdjust() {\n\t\t\t\t\tif (!this.rendered) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Set tracking flag\n\t\t\t\t\tvar posOptions = this.options.position;\n\t\t\t\t\tthis.tooltip.attr('tracking', posOptions.target === 'mouse' && posOptions.adjust.mouse);\n\n\t\t\t\t\t// Reassign events\n\t\t\t\t\tthis._unassignEvents();\n\t\t\t\t\tthis._assignEvents();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t// Dot notation converter\n\t\tfunction convertNotation(options, notation) {\n\t\t\tvar i = 0,\n\t\t\t    obj,\n\t\t\t    option = options,\n\n\n\t\t\t// Split notation into array\n\t\t\tlevels = notation.split('.');\n\n\t\t\t// Loop through\n\t\t\twhile (option = option[levels[i++]]) {\n\t\t\t\tif (i < levels.length) {\n\t\t\t\t\tobj = option;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn [obj || options, levels.pop()];\n\t\t}\n\n\t\tPROTOTYPE.get = function (notation) {\n\t\t\tif (this.destroyed) {\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tvar o = convertNotation(this.options, notation.toLowerCase()),\n\t\t\t    result = o[0][o[1]];\n\n\t\t\treturn result.precedance ? result.string() : result;\n\t\t};\n\n\t\tfunction setCallback(notation, args) {\n\t\t\tvar category, rule, match;\n\n\t\t\tfor (category in this.checks) {\n\t\t\t\tfor (rule in this.checks[category]) {\n\t\t\t\t\tif (match = new RegExp(rule, 'i').exec(notation)) {\n\t\t\t\t\t\targs.push(match);\n\n\t\t\t\t\t\tif (category === 'builtin' || this.plugins[category]) {\n\t\t\t\t\t\t\tthis.checks[category][rule].apply(this.plugins[category] || this, args);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar rmove = /^position\\.(my|at|adjust|target|container|viewport)|style|content|show\\.ready/i,\n\t\t    rrender = /^prerender|show\\.ready/i;\n\n\t\tPROTOTYPE.set = function (option, value) {\n\t\t\tif (this.destroyed) {\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tvar rendered = this.rendered,\n\t\t\t    reposition = FALSE,\n\t\t\t    options = this.options,\n\t\t\t    checks = this.checks,\n\t\t\t    name;\n\n\t\t\t// Convert singular option/value pair into object form\n\t\t\tif ('string' === typeof option) {\n\t\t\t\tname = option;option = {};option[name] = value;\n\t\t\t} else {\n\t\t\t\toption = $.extend({}, option);\n\t\t\t}\n\n\t\t\t// Set all of the defined options to their new values\n\t\t\t$.each(option, function (notation, value) {\n\t\t\t\tif (rendered && rrender.test(notation)) {\n\t\t\t\t\tdelete option[notation];return;\n\t\t\t\t}\n\n\t\t\t\t// Set new obj value\n\t\t\t\tvar obj = convertNotation(options, notation.toLowerCase()),\n\t\t\t\t    previous;\n\t\t\t\tprevious = obj[0][obj[1]];\n\t\t\t\tobj[0][obj[1]] = value && value.nodeType ? $(value) : value;\n\n\t\t\t\t// Also check if we need to reposition\n\t\t\t\treposition = rmove.test(notation) || reposition;\n\n\t\t\t\t// Set the new params for the callback\n\t\t\t\toption[notation] = [obj[0], obj[1], value, previous];\n\t\t\t});\n\n\t\t\t// Re-sanitize options\n\t\t\tsanitizeOptions(options);\n\n\t\t\t/*\n    * Execute any valid callbacks for the set options\n    * Also set positioning flag so we don't get loads of redundant repositioning calls.\n    */\n\t\t\tthis.positioning = TRUE;\n\t\t\t$.each(option, $.proxy(setCallback, this));\n\t\t\tthis.positioning = FALSE;\n\n\t\t\t// Update position if needed\n\t\t\tif (this.rendered && this.tooltip[0].offsetWidth > 0 && reposition) {\n\t\t\t\tthis.reposition(options.position.target === 'mouse' ? NULL : this.cache.event);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t};\n\t\t;PROTOTYPE._update = function (content, element, reposition) {\n\t\t\tvar self = this,\n\t\t\t    cache = this.cache;\n\n\t\t\t// Make sure tooltip is rendered and content is defined. If not return\n\t\t\tif (!this.rendered || !content) {\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\t// Use function to parse content\n\t\t\tif ($.isFunction(content)) {\n\t\t\t\tcontent = content.call(this.elements.target, cache.event, this) || '';\n\t\t\t}\n\n\t\t\t// Handle deferred content\n\t\t\tif ($.isFunction(content.then)) {\n\t\t\t\tcache.waiting = TRUE;\n\t\t\t\treturn content.then(function (c) {\n\t\t\t\t\tcache.waiting = FALSE;\n\t\t\t\t\treturn self._update(c, element);\n\t\t\t\t}, NULL, function (e) {\n\t\t\t\t\treturn self._update(e, element);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// If content is null... return false\n\t\t\tif (content === FALSE || !content && content !== '') {\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\t// Append new content if its a DOM array and show it if hidden\n\t\t\tif (content.jquery && content.length > 0) {\n\t\t\t\telement.empty().append(content.css({ display: 'block', visibility: 'visible' }));\n\t\t\t}\n\n\t\t\t// Content is a regular string, insert the new content\n\t\t\telse {\n\t\t\t\t\telement.html(content);\n\t\t\t\t}\n\n\t\t\t// Wait for content to be loaded, and reposition\n\t\t\treturn this._waitForContent(element).then(function (images) {\n\t\t\t\tif (self.rendered && self.tooltip[0].offsetWidth > 0) {\n\t\t\t\t\tself.reposition(cache.event, !images.length);\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\n\t\tPROTOTYPE._waitForContent = function (element) {\n\t\t\tvar cache = this.cache;\n\n\t\t\t// Set flag\n\t\t\tcache.waiting = TRUE;\n\n\t\t\t// If imagesLoaded is included, ensure images have loaded and return promise\n\t\t\treturn ($.fn.imagesLoaded ? element.imagesLoaded() : $.Deferred().resolve([])).done(function () {\n\t\t\t\tcache.waiting = FALSE;\n\t\t\t}).promise();\n\t\t};\n\n\t\tPROTOTYPE._updateContent = function (content, reposition) {\n\t\t\tthis._update(content, this.elements.content, reposition);\n\t\t};\n\n\t\tPROTOTYPE._updateTitle = function (content, reposition) {\n\t\t\tif (this._update(content, this.elements.title, reposition) === FALSE) {\n\t\t\t\tthis._removeTitle(FALSE);\n\t\t\t}\n\t\t};\n\n\t\tPROTOTYPE._createTitle = function () {\n\t\t\tvar elements = this.elements,\n\t\t\t    id = this._id + '-title';\n\n\t\t\t// Destroy previous title element, if present\n\t\t\tif (elements.titlebar) {\n\t\t\t\tthis._removeTitle();\n\t\t\t}\n\n\t\t\t// Create title bar and title elements\n\t\t\telements.titlebar = $('<div />', {\n\t\t\t\t'class': NAMESPACE + '-titlebar ' + (this.options.style.widget ? createWidgetClass('header') : '')\n\t\t\t}).append(elements.title = $('<div />', {\n\t\t\t\t'id': id,\n\t\t\t\t'class': NAMESPACE + '-title',\n\t\t\t\t'aria-atomic': TRUE\n\t\t\t})).insertBefore(elements.content)\n\n\t\t\t// Button-specific events\n\t\t\t.delegate('.qtip-close', 'mousedown keydown mouseup keyup mouseout', function (event) {\n\t\t\t\t$(this).toggleClass('ui-state-active ui-state-focus', event.type.substr(-4) === 'down');\n\t\t\t}).delegate('.qtip-close', 'mouseover mouseout', function (event) {\n\t\t\t\t$(this).toggleClass('ui-state-hover', event.type === 'mouseover');\n\t\t\t});\n\n\t\t\t// Create button if enabled\n\t\t\tif (this.options.content.button) {\n\t\t\t\tthis._createButton();\n\t\t\t}\n\t\t};\n\n\t\tPROTOTYPE._removeTitle = function (reposition) {\n\t\t\tvar elements = this.elements;\n\n\t\t\tif (elements.title) {\n\t\t\t\telements.titlebar.remove();\n\t\t\t\telements.titlebar = elements.title = elements.button = NULL;\n\n\t\t\t\t// Reposition if enabled\n\t\t\t\tif (reposition !== FALSE) {\n\t\t\t\t\tthis.reposition();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\t;PROTOTYPE._createPosClass = function (my) {\n\t\t\treturn NAMESPACE + '-pos-' + (my || this.options.position.my).abbrev();\n\t\t};\n\n\t\tPROTOTYPE.reposition = function (event, effect) {\n\t\t\tif (!this.rendered || this.positioning || this.destroyed) {\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\t// Set positioning flag\n\t\t\tthis.positioning = TRUE;\n\n\t\t\tvar cache = this.cache,\n\t\t\t    tooltip = this.tooltip,\n\t\t\t    posOptions = this.options.position,\n\t\t\t    target = posOptions.target,\n\t\t\t    my = posOptions.my,\n\t\t\t    at = posOptions.at,\n\t\t\t    viewport = posOptions.viewport,\n\t\t\t    container = posOptions.container,\n\t\t\t    adjust = posOptions.adjust,\n\t\t\t    method = adjust.method.split(' '),\n\t\t\t    tooltipWidth = tooltip.outerWidth(FALSE),\n\t\t\t    tooltipHeight = tooltip.outerHeight(FALSE),\n\t\t\t    targetWidth = 0,\n\t\t\t    targetHeight = 0,\n\t\t\t    type = tooltip.css('position'),\n\t\t\t    position = { left: 0, top: 0 },\n\t\t\t    visible = tooltip[0].offsetWidth > 0,\n\t\t\t    isScroll = event && event.type === 'scroll',\n\t\t\t    win = $(window),\n\t\t\t    doc = container[0].ownerDocument,\n\t\t\t    mouse = this.mouse,\n\t\t\t    pluginCalculations,\n\t\t\t    offset,\n\t\t\t    adjusted,\n\t\t\t    newClass;\n\n\t\t\t// Check if absolute position was passed\n\t\t\tif ($.isArray(target) && target.length === 2) {\n\t\t\t\t// Force left top and set position\n\t\t\t\tat = { x: LEFT, y: TOP };\n\t\t\t\tposition = { left: target[0], top: target[1] };\n\t\t\t}\n\n\t\t\t// Check if mouse was the target\n\t\t\telse if (target === 'mouse') {\n\t\t\t\t\t// Force left top to allow flipping\n\t\t\t\t\tat = { x: LEFT, y: TOP };\n\n\t\t\t\t\t// Use the mouse origin that caused the show event, if distance hiding is enabled\n\t\t\t\t\tif ((!adjust.mouse || this.options.hide.distance) && cache.origin && cache.origin.pageX) {\n\t\t\t\t\t\tevent = cache.origin;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Use cached event for resize/scroll events\n\t\t\t\t\telse if (!event || event && (event.type === 'resize' || event.type === 'scroll')) {\n\t\t\t\t\t\t\tevent = cache.event;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Otherwise, use the cached mouse coordinates if available\n\t\t\t\t\t\telse if (mouse && mouse.pageX) {\n\t\t\t\t\t\t\t\tevent = mouse;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t// Calculate body and container offset and take them into account below\n\t\t\t\t\tif (type !== 'static') {\n\t\t\t\t\t\tposition = container.offset();\n\t\t\t\t\t}\n\t\t\t\t\tif (doc.body.offsetWidth !== (window.innerWidth || doc.documentElement.clientWidth)) {\n\t\t\t\t\t\toffset = $(document.body).offset();\n\t\t\t\t\t}\n\n\t\t\t\t\t// Use event coordinates for position\n\t\t\t\t\tposition = {\n\t\t\t\t\t\tleft: event.pageX - position.left + (offset && offset.left || 0),\n\t\t\t\t\t\ttop: event.pageY - position.top + (offset && offset.top || 0)\n\t\t\t\t\t};\n\n\t\t\t\t\t// Scroll events are a pain, some browsers\n\t\t\t\t\tif (adjust.mouse && isScroll && mouse) {\n\t\t\t\t\t\tposition.left -= (mouse.scrollX || 0) - win.scrollLeft();\n\t\t\t\t\t\tposition.top -= (mouse.scrollY || 0) - win.scrollTop();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Target wasn't mouse or absolute...\n\t\t\t\telse {\n\t\t\t\t\t\t// Check if event targetting is being used\n\t\t\t\t\t\tif (target === 'event') {\n\t\t\t\t\t\t\tif (event && event.target && event.type !== 'scroll' && event.type !== 'resize') {\n\t\t\t\t\t\t\t\tcache.target = $(event.target);\n\t\t\t\t\t\t\t} else if (!event.target) {\n\t\t\t\t\t\t\t\tcache.target = this.elements.target;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (target !== 'event') {\n\t\t\t\t\t\t\tcache.target = $(target.jquery ? target : this.elements.target);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttarget = cache.target;\n\n\t\t\t\t\t\t// Parse the target into a jQuery object and make sure there's an element present\n\t\t\t\t\t\ttarget = $(target).eq(0);\n\t\t\t\t\t\tif (target.length === 0) {\n\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Check if window or document is the target\n\t\t\t\t\t\telse if (target[0] === document || target[0] === window) {\n\t\t\t\t\t\t\t\ttargetWidth = BROWSER.iOS ? window.innerWidth : target.width();\n\t\t\t\t\t\t\t\ttargetHeight = BROWSER.iOS ? window.innerHeight : target.height();\n\n\t\t\t\t\t\t\t\tif (target[0] === window) {\n\t\t\t\t\t\t\t\t\tposition = {\n\t\t\t\t\t\t\t\t\t\ttop: (viewport || target).scrollTop(),\n\t\t\t\t\t\t\t\t\t\tleft: (viewport || target).scrollLeft()\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Check if the target is an <AREA> element\n\t\t\t\t\t\t\telse if (PLUGINS.imagemap && target.is('area')) {\n\t\t\t\t\t\t\t\t\tpluginCalculations = PLUGINS.imagemap(this, target, at, PLUGINS.viewport ? method : FALSE);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Check if the target is an SVG element\n\t\t\t\t\t\t\t\telse if (PLUGINS.svg && target && target[0].ownerSVGElement) {\n\t\t\t\t\t\t\t\t\t\tpluginCalculations = PLUGINS.svg(this, target, at, PLUGINS.viewport ? method : FALSE);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Otherwise use regular jQuery methods\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\ttargetWidth = target.outerWidth(FALSE);\n\t\t\t\t\t\t\t\t\t\t\ttargetHeight = target.outerHeight(FALSE);\n\t\t\t\t\t\t\t\t\t\t\tposition = target.offset();\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Parse returned plugin values into proper variables\n\t\t\t\t\t\tif (pluginCalculations) {\n\t\t\t\t\t\t\ttargetWidth = pluginCalculations.width;\n\t\t\t\t\t\t\ttargetHeight = pluginCalculations.height;\n\t\t\t\t\t\t\toffset = pluginCalculations.offset;\n\t\t\t\t\t\t\tposition = pluginCalculations.position;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Adjust position to take into account offset parents\n\t\t\t\t\t\tposition = this.reposition.offset(target, position, container);\n\n\t\t\t\t\t\t// Adjust for position.fixed tooltips (and also iOS scroll bug in v3.2-4.0 & v4.3-4.3.2)\n\t\t\t\t\t\tif (BROWSER.iOS > 3.1 && BROWSER.iOS < 4.1 || BROWSER.iOS >= 4.3 && BROWSER.iOS < 4.33 || !BROWSER.iOS && type === 'fixed') {\n\t\t\t\t\t\t\tposition.left -= win.scrollLeft();\n\t\t\t\t\t\t\tposition.top -= win.scrollTop();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Adjust position relative to target\n\t\t\t\t\t\tif (!pluginCalculations || pluginCalculations && pluginCalculations.adjustable !== FALSE) {\n\t\t\t\t\t\t\tposition.left += at.x === RIGHT ? targetWidth : at.x === CENTER ? targetWidth / 2 : 0;\n\t\t\t\t\t\t\tposition.top += at.y === BOTTOM ? targetHeight : at.y === CENTER ? targetHeight / 2 : 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t// Adjust position relative to tooltip\n\t\t\tposition.left += adjust.x + (my.x === RIGHT ? -tooltipWidth : my.x === CENTER ? -tooltipWidth / 2 : 0);\n\t\t\tposition.top += adjust.y + (my.y === BOTTOM ? -tooltipHeight : my.y === CENTER ? -tooltipHeight / 2 : 0);\n\n\t\t\t// Use viewport adjustment plugin if enabled\n\t\t\tif (PLUGINS.viewport) {\n\t\t\t\tadjusted = position.adjusted = PLUGINS.viewport(this, position, posOptions, targetWidth, targetHeight, tooltipWidth, tooltipHeight);\n\n\t\t\t\t// Apply offsets supplied by positioning plugin (if used)\n\t\t\t\tif (offset && adjusted.left) {\n\t\t\t\t\tposition.left += offset.left;\n\t\t\t\t}\n\t\t\t\tif (offset && adjusted.top) {\n\t\t\t\t\tposition.top += offset.top;\n\t\t\t\t}\n\n\t\t\t\t// Apply any new 'my' position\n\t\t\t\tif (adjusted.my) {\n\t\t\t\t\tthis.position.my = adjusted.my;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Viewport adjustment is disabled, set values to zero\n\t\t\telse {\n\t\t\t\t\tposition.adjusted = { left: 0, top: 0 };\n\t\t\t\t}\n\n\t\t\t// Set tooltip position class if it's changed\n\t\t\tif (cache.posClass !== (newClass = this._createPosClass(this.position.my))) {\n\t\t\t\ttooltip.removeClass(cache.posClass).addClass(cache.posClass = newClass);\n\t\t\t}\n\n\t\t\t// tooltipmove event\n\t\t\tif (!this._trigger('move', [position, viewport.elem || viewport], event)) {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tdelete position.adjusted;\n\n\t\t\t// If effect is disabled, target it mouse, no animation is defined or positioning gives NaN out, set CSS directly\n\t\t\tif (effect === FALSE || !visible || isNaN(position.left) || isNaN(position.top) || target === 'mouse' || !$.isFunction(posOptions.effect)) {\n\t\t\t\ttooltip.css(position);\n\t\t\t}\n\n\t\t\t// Use custom function if provided\n\t\t\telse if ($.isFunction(posOptions.effect)) {\n\t\t\t\t\tposOptions.effect.call(tooltip, this, $.extend({}, position));\n\t\t\t\t\ttooltip.queue(function (next) {\n\t\t\t\t\t\t// Reset attributes to avoid cross-browser rendering bugs\n\t\t\t\t\t\t$(this).css({ opacity: '', height: '' });\n\t\t\t\t\t\tif (BROWSER.ie) {\n\t\t\t\t\t\t\tthis.style.removeAttribute('filter');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnext();\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t// Set positioning flag\n\t\t\tthis.positioning = FALSE;\n\n\t\t\treturn this;\n\t\t};\n\n\t\t// Custom (more correct for qTip!) offset calculator\n\t\tPROTOTYPE.reposition.offset = function (elem, pos, container) {\n\t\t\tif (!container[0]) {\n\t\t\t\treturn pos;\n\t\t\t}\n\n\t\t\tvar ownerDocument = $(elem[0].ownerDocument),\n\t\t\t    quirks = !!BROWSER.ie && document.compatMode !== 'CSS1Compat',\n\t\t\t    parent = container[0],\n\t\t\t    scrolled,\n\t\t\t    position,\n\t\t\t    parentOffset,\n\t\t\t    overflow;\n\n\t\t\tfunction scroll(e, i) {\n\t\t\t\tpos.left += i * e.scrollLeft();\n\t\t\t\tpos.top += i * e.scrollTop();\n\t\t\t}\n\n\t\t\t// Compensate for non-static containers offset\n\t\t\tdo {\n\t\t\t\tif ((position = $.css(parent, 'position')) !== 'static') {\n\t\t\t\t\tif (position === 'fixed') {\n\t\t\t\t\t\tparentOffset = parent.getBoundingClientRect();\n\t\t\t\t\t\tscroll(ownerDocument, -1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tparentOffset = $(parent).position();\n\t\t\t\t\t\tparentOffset.left += parseFloat($.css(parent, 'borderLeftWidth')) || 0;\n\t\t\t\t\t\tparentOffset.top += parseFloat($.css(parent, 'borderTopWidth')) || 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tpos.left -= parentOffset.left + (parseFloat($.css(parent, 'marginLeft')) || 0);\n\t\t\t\t\tpos.top -= parentOffset.top + (parseFloat($.css(parent, 'marginTop')) || 0);\n\n\t\t\t\t\t// If this is the first parent element with an overflow of \"scroll\" or \"auto\", store it\n\t\t\t\t\tif (!scrolled && (overflow = $.css(parent, 'overflow')) !== 'hidden' && overflow !== 'visible') {\n\t\t\t\t\t\tscrolled = $(parent);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} while (parent = parent.offsetParent);\n\n\t\t\t// Compensate for containers scroll if it also has an offsetParent (or in IE quirks mode)\n\t\t\tif (scrolled && (scrolled[0] !== ownerDocument[0] || quirks)) {\n\t\t\t\tscroll(scrolled, 1);\n\t\t\t}\n\n\t\t\treturn pos;\n\t\t};\n\n\t\t// Corner class\n\t\tvar C = (CORNER = PROTOTYPE.reposition.Corner = function (corner, forceY) {\n\t\t\tcorner = ('' + corner).replace(/([A-Z])/, ' $1').replace(/middle/gi, CENTER).toLowerCase();\n\t\t\tthis.x = (corner.match(/left|right/i) || corner.match(/center/) || ['inherit'])[0].toLowerCase();\n\t\t\tthis.y = (corner.match(/top|bottom|center/i) || ['inherit'])[0].toLowerCase();\n\t\t\tthis.forceY = !!forceY;\n\n\t\t\tvar f = corner.charAt(0);\n\t\t\tthis.precedance = f === 't' || f === 'b' ? Y : X;\n\t\t}).prototype;\n\n\t\tC.invert = function (z, center) {\n\t\t\tthis[z] = this[z] === LEFT ? RIGHT : this[z] === RIGHT ? LEFT : center || this[z];\n\t\t};\n\n\t\tC.string = function (join) {\n\t\t\tvar x = this.x,\n\t\t\t    y = this.y;\n\n\t\t\tvar result = x !== y ? x === 'center' || y !== 'center' && (this.precedance === Y || this.forceY) ? [y, x] : [x, y] : [x];\n\n\t\t\treturn join !== false ? result.join(' ') : result;\n\t\t};\n\n\t\tC.abbrev = function () {\n\t\t\tvar result = this.string(false);\n\t\t\treturn result[0].charAt(0) + (result[1] && result[1].charAt(0) || '');\n\t\t};\n\n\t\tC.clone = function () {\n\t\t\treturn new CORNER(this.string(), this.forceY);\n\t\t};\n\n\t\t;\n\t\tPROTOTYPE.toggle = function (state, event) {\n\t\t\tvar cache = this.cache,\n\t\t\t    options = this.options,\n\t\t\t    tooltip = this.tooltip;\n\n\t\t\t// Try to prevent flickering when tooltip overlaps show element\n\t\t\tif (event) {\n\t\t\t\tif (/over|enter/.test(event.type) && cache.event && /out|leave/.test(cache.event.type) && options.show.target.add(event.target).length === options.show.target.length && tooltip.has(event.relatedTarget).length) {\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t\t// Cache event\n\t\t\t\tcache.event = $.event.fix(event);\n\t\t\t}\n\n\t\t\t// If we're currently waiting and we've just hidden... stop it\n\t\t\tthis.waiting && !state && (this.hiddenDuringWait = TRUE);\n\n\t\t\t// Render the tooltip if showing and it isn't already\n\t\t\tif (!this.rendered) {\n\t\t\t\treturn state ? this.render(1) : this;\n\t\t\t} else if (this.destroyed || this.disabled) {\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tvar type = state ? 'show' : 'hide',\n\t\t\t    opts = this.options[type],\n\t\t\t    otherOpts = this.options[!state ? 'show' : 'hide'],\n\t\t\t    posOptions = this.options.position,\n\t\t\t    contentOptions = this.options.content,\n\t\t\t    width = this.tooltip.css('width'),\n\t\t\t    visible = this.tooltip.is(':visible'),\n\t\t\t    animate = state || opts.target.length === 1,\n\t\t\t    sameTarget = !event || opts.target.length < 2 || cache.target[0] === event.target,\n\t\t\t    identicalState,\n\t\t\t    allow,\n\t\t\t    showEvent,\n\t\t\t    delay,\n\t\t\t    after;\n\n\t\t\t// Detect state if valid one isn't provided\n\t\t\tif ((typeof state === 'undefined' ? 'undefined' : _typeof(state)).search('boolean|number')) {\n\t\t\t\tstate = !visible;\n\t\t\t}\n\n\t\t\t// Check if the tooltip is in an identical state to the new would-be state\n\t\t\tidenticalState = !tooltip.is(':animated') && visible === state && sameTarget;\n\n\t\t\t// Fire tooltip(show/hide) event and check if destroyed\n\t\t\tallow = !identicalState ? !!this._trigger(type, [90]) : NULL;\n\n\t\t\t// Check to make sure the tooltip wasn't destroyed in the callback\n\t\t\tif (this.destroyed) {\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\t// If the user didn't stop the method prematurely and we're showing the tooltip, focus it\n\t\t\tif (allow !== FALSE && state) {\n\t\t\t\tthis.focus(event);\n\t\t\t}\n\n\t\t\t// If the state hasn't changed or the user stopped it, return early\n\t\t\tif (!allow || identicalState) {\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\t// Set ARIA hidden attribute\n\t\t\t$.attr(tooltip[0], 'aria-hidden', !!!state);\n\n\t\t\t// Execute state specific properties\n\t\t\tif (state) {\n\t\t\t\t// Store show origin coordinates\n\t\t\t\tthis.mouse && (cache.origin = $.event.fix(this.mouse));\n\n\t\t\t\t// Update tooltip content & title if it's a dynamic function\n\t\t\t\tif ($.isFunction(contentOptions.text)) {\n\t\t\t\t\tthis._updateContent(contentOptions.text, FALSE);\n\t\t\t\t}\n\t\t\t\tif ($.isFunction(contentOptions.title)) {\n\t\t\t\t\tthis._updateTitle(contentOptions.title, FALSE);\n\t\t\t\t}\n\n\t\t\t\t// Cache mousemove events for positioning purposes (if not already tracking)\n\t\t\t\tif (!trackingBound && posOptions.target === 'mouse' && posOptions.adjust.mouse) {\n\t\t\t\t\t$(document).bind('mousemove.' + NAMESPACE, this._storeMouse);\n\t\t\t\t\ttrackingBound = TRUE;\n\t\t\t\t}\n\n\t\t\t\t// Update the tooltip position (set width first to prevent viewport/max-width issues)\n\t\t\t\tif (!width) {\n\t\t\t\t\ttooltip.css('width', tooltip.outerWidth(FALSE));\n\t\t\t\t}\n\t\t\t\tthis.reposition(event, arguments[2]);\n\t\t\t\tif (!width) {\n\t\t\t\t\ttooltip.css('width', '');\n\t\t\t\t}\n\n\t\t\t\t// Hide other tooltips if tooltip is solo\n\t\t\t\tif (!!opts.solo) {\n\t\t\t\t\t(typeof opts.solo === 'string' ? $(opts.solo) : $(SELECTOR, opts.solo)).not(tooltip).not(opts.target).qtip('hide', $.Event('tooltipsolo'));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Clear show timer if we're hiding\n\t\t\t\tclearTimeout(this.timers.show);\n\n\t\t\t\t// Remove cached origin on hide\n\t\t\t\tdelete cache.origin;\n\n\t\t\t\t// Remove mouse tracking event if not needed (all tracking qTips are hidden)\n\t\t\t\tif (trackingBound && !$(SELECTOR + '[tracking=\"true\"]:visible', opts.solo).not(tooltip).length) {\n\t\t\t\t\t$(document).unbind('mousemove.' + NAMESPACE);\n\t\t\t\t\ttrackingBound = FALSE;\n\t\t\t\t}\n\n\t\t\t\t// Blur the tooltip\n\t\t\t\tthis.blur(event);\n\t\t\t}\n\n\t\t\t// Define post-animation, state specific properties\n\t\t\tafter = $.proxy(function () {\n\t\t\t\tif (state) {\n\t\t\t\t\t// Prevent antialias from disappearing in IE by removing filter\n\t\t\t\t\tif (BROWSER.ie) {\n\t\t\t\t\t\ttooltip[0].style.removeAttribute('filter');\n\t\t\t\t\t}\n\n\t\t\t\t\t// Remove overflow setting to prevent tip bugs\n\t\t\t\t\ttooltip.css('overflow', '');\n\n\t\t\t\t\t// Autofocus elements if enabled\n\t\t\t\t\tif ('string' === typeof opts.autofocus) {\n\t\t\t\t\t\t$(this.options.show.autofocus, tooltip).focus();\n\t\t\t\t\t}\n\n\t\t\t\t\t// If set, hide tooltip when inactive for delay period\n\t\t\t\t\tthis.options.show.target.trigger('qtip-' + this.id + '-inactive');\n\t\t\t\t} else {\n\t\t\t\t\t// Reset CSS states\n\t\t\t\t\ttooltip.css({\n\t\t\t\t\t\tdisplay: '',\n\t\t\t\t\t\tvisibility: '',\n\t\t\t\t\t\topacity: '',\n\t\t\t\t\t\tleft: '',\n\t\t\t\t\t\ttop: ''\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// tooltipvisible/tooltiphidden events\n\t\t\t\tthis._trigger(state ? 'visible' : 'hidden');\n\t\t\t}, this);\n\n\t\t\t// If no effect type is supplied, use a simple toggle\n\t\t\tif (opts.effect === FALSE || animate === FALSE) {\n\t\t\t\ttooltip[type]();\n\t\t\t\tafter();\n\t\t\t}\n\n\t\t\t// Use custom function if provided\n\t\t\telse if ($.isFunction(opts.effect)) {\n\t\t\t\t\ttooltip.stop(1, 1);\n\t\t\t\t\topts.effect.call(tooltip, this);\n\t\t\t\t\ttooltip.queue('fx', function (n) {\n\t\t\t\t\t\tafter();n();\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Use basic fade function by default\n\t\t\t\telse {\n\t\t\t\t\t\ttooltip.fadeTo(90, state ? 1 : 0, after);\n\t\t\t\t\t}\n\n\t\t\t// If inactive hide method is set, active it\n\t\t\tif (state) {\n\t\t\t\topts.target.trigger('qtip-' + this.id + '-inactive');\n\t\t\t}\n\n\t\t\treturn this;\n\t\t};\n\n\t\tPROTOTYPE.show = function (event) {\n\t\t\treturn this.toggle(TRUE, event);\n\t\t};\n\n\t\tPROTOTYPE.hide = function (event) {\n\t\t\treturn this.toggle(FALSE, event);\n\t\t};\n\t\t;PROTOTYPE.focus = function (event) {\n\t\t\tif (!this.rendered || this.destroyed) {\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tvar qtips = $(SELECTOR),\n\t\t\t    tooltip = this.tooltip,\n\t\t\t    curIndex = parseInt(tooltip[0].style.zIndex, 10),\n\t\t\t    newIndex = QTIP.zindex + qtips.length,\n\t\t\t    focusedElem;\n\n\t\t\t// Only update the z-index if it has changed and tooltip is not already focused\n\t\t\tif (!tooltip.hasClass(CLASS_FOCUS)) {\n\t\t\t\t// tooltipfocus event\n\t\t\t\tif (this._trigger('focus', [newIndex], event)) {\n\t\t\t\t\t// Only update z-index's if they've changed\n\t\t\t\t\tif (curIndex !== newIndex) {\n\t\t\t\t\t\t// Reduce our z-index's and keep them properly ordered\n\t\t\t\t\t\tqtips.each(function () {\n\t\t\t\t\t\t\tif (this.style.zIndex > curIndex) {\n\t\t\t\t\t\t\t\tthis.style.zIndex = this.style.zIndex - 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\t// Fire blur event for focused tooltip\n\t\t\t\t\t\tqtips.filter('.' + CLASS_FOCUS).qtip('blur', event);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Set the new z-index\n\t\t\t\t\ttooltip.addClass(CLASS_FOCUS)[0].style.zIndex = newIndex;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this;\n\t\t};\n\n\t\tPROTOTYPE.blur = function (event) {\n\t\t\tif (!this.rendered || this.destroyed) {\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\t// Set focused status to FALSE\n\t\t\tthis.tooltip.removeClass(CLASS_FOCUS);\n\n\t\t\t// tooltipblur event\n\t\t\tthis._trigger('blur', [this.tooltip.css('zIndex')], event);\n\n\t\t\treturn this;\n\t\t};\n\t\t;PROTOTYPE.disable = function (state) {\n\t\t\tif (this.destroyed) {\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\t// If 'toggle' is passed, toggle the current state\n\t\t\tif (state === 'toggle') {\n\t\t\t\tstate = !(this.rendered ? this.tooltip.hasClass(CLASS_DISABLED) : this.disabled);\n\t\t\t}\n\n\t\t\t// Disable if no state passed\n\t\t\telse if ('boolean' !== typeof state) {\n\t\t\t\t\tstate = TRUE;\n\t\t\t\t}\n\n\t\t\tif (this.rendered) {\n\t\t\t\tthis.tooltip.toggleClass(CLASS_DISABLED, state).attr('aria-disabled', state);\n\t\t\t}\n\n\t\t\tthis.disabled = !!state;\n\n\t\t\treturn this;\n\t\t};\n\n\t\tPROTOTYPE.enable = function () {\n\t\t\treturn this.disable(FALSE);\n\t\t};\n\t\t;PROTOTYPE._createButton = function () {\n\t\t\tvar self = this,\n\t\t\t    elements = this.elements,\n\t\t\t    tooltip = elements.tooltip,\n\t\t\t    button = this.options.content.button,\n\t\t\t    isString = typeof button === 'string',\n\t\t\t    close = isString ? button : 'Close tooltip';\n\n\t\t\tif (elements.button) {\n\t\t\t\telements.button.remove();\n\t\t\t}\n\n\t\t\t// Use custom button if one was supplied by user, else use default\n\t\t\tif (button.jquery) {\n\t\t\t\telements.button = button;\n\t\t\t} else {\n\t\t\t\telements.button = $('<a />', {\n\t\t\t\t\t'class': 'qtip-close ' + (this.options.style.widget ? '' : NAMESPACE + '-icon'),\n\t\t\t\t\t'title': close,\n\t\t\t\t\t'aria-label': close\n\t\t\t\t}).prepend($('<span />', {\n\t\t\t\t\t'class': 'ui-icon ui-icon-close',\n\t\t\t\t\t'html': '&times;'\n\t\t\t\t}));\n\t\t\t}\n\n\t\t\t// Create button and setup attributes\n\t\t\telements.button.appendTo(elements.titlebar || tooltip).attr('role', 'button').click(function (event) {\n\t\t\t\tif (!tooltip.hasClass(CLASS_DISABLED)) {\n\t\t\t\t\tself.hide(event);\n\t\t\t\t}\n\t\t\t\treturn FALSE;\n\t\t\t});\n\t\t};\n\n\t\tPROTOTYPE._updateButton = function (button) {\n\t\t\t// Make sure tooltip is rendered and if not, return\n\t\t\tif (!this.rendered) {\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\tvar elem = this.elements.button;\n\t\t\tif (button) {\n\t\t\t\tthis._createButton();\n\t\t\t} else {\n\t\t\t\telem.remove();\n\t\t\t}\n\t\t};\n\t\t; // Widget class creator\n\t\tfunction createWidgetClass(cls) {\n\t\t\treturn WIDGET.concat('').join(cls ? '-' + cls + ' ' : ' ');\n\t\t}\n\n\t\t// Widget class setter method\n\t\tPROTOTYPE._setWidget = function () {\n\t\t\tvar on = this.options.style.widget,\n\t\t\t    elements = this.elements,\n\t\t\t    tooltip = elements.tooltip,\n\t\t\t    disabled = tooltip.hasClass(CLASS_DISABLED);\n\n\t\t\ttooltip.removeClass(CLASS_DISABLED);\n\t\t\tCLASS_DISABLED = on ? 'ui-state-disabled' : 'qtip-disabled';\n\t\t\ttooltip.toggleClass(CLASS_DISABLED, disabled);\n\n\t\t\ttooltip.toggleClass('ui-helper-reset ' + createWidgetClass(), on).toggleClass(CLASS_DEFAULT, this.options.style.def && !on);\n\n\t\t\tif (elements.content) {\n\t\t\t\telements.content.toggleClass(createWidgetClass('content'), on);\n\t\t\t}\n\t\t\tif (elements.titlebar) {\n\t\t\t\telements.titlebar.toggleClass(createWidgetClass('header'), on);\n\t\t\t}\n\t\t\tif (elements.button) {\n\t\t\t\telements.button.toggleClass(NAMESPACE + '-icon', !on);\n\t\t\t}\n\t\t};\n\t\t;function delay(callback, duration) {\n\t\t\t// If tooltip has displayed, start hide timer\n\t\t\tif (duration > 0) {\n\t\t\t\treturn setTimeout($.proxy(callback, this), duration);\n\t\t\t} else {\n\t\t\t\tcallback.call(this);\n\t\t\t}\n\t\t}\n\n\t\tfunction showMethod(event) {\n\t\t\tif (this.tooltip.hasClass(CLASS_DISABLED)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Clear hide timers\n\t\t\tclearTimeout(this.timers.show);\n\t\t\tclearTimeout(this.timers.hide);\n\n\t\t\t// Start show timer\n\t\t\tthis.timers.show = delay.call(this, function () {\n\t\t\t\tthis.toggle(TRUE, event);\n\t\t\t}, this.options.show.delay);\n\t\t}\n\n\t\tfunction hideMethod(event) {\n\t\t\tif (this.tooltip.hasClass(CLASS_DISABLED) || this.destroyed) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Check if new target was actually the tooltip element\n\t\t\tvar relatedTarget = $(event.relatedTarget),\n\t\t\t    ontoTooltip = relatedTarget.closest(SELECTOR)[0] === this.tooltip[0],\n\t\t\t    ontoTarget = relatedTarget[0] === this.options.show.target[0];\n\n\t\t\t// Clear timers and stop animation queue\n\t\t\tclearTimeout(this.timers.show);\n\t\t\tclearTimeout(this.timers.hide);\n\n\t\t\t// Prevent hiding if tooltip is fixed and event target is the tooltip.\n\t\t\t// Or if mouse positioning is enabled and cursor momentarily overlaps\n\t\t\tif (this !== relatedTarget[0] && this.options.position.target === 'mouse' && ontoTooltip || this.options.hide.fixed && /mouse(out|leave|move)/.test(event.type) && (ontoTooltip || ontoTarget)) {\n\t\t\t\ttry {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\tevent.stopImmediatePropagation();\n\t\t\t\t} catch (e) {}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If tooltip has displayed, start hide timer\n\t\t\tthis.timers.hide = delay.call(this, function () {\n\t\t\t\tthis.toggle(FALSE, event);\n\t\t\t}, this.options.hide.delay, this);\n\t\t}\n\n\t\tfunction inactiveMethod(event) {\n\t\t\tif (this.tooltip.hasClass(CLASS_DISABLED) || !this.options.hide.inactive) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Clear timer\n\t\t\tclearTimeout(this.timers.inactive);\n\n\t\t\tthis.timers.inactive = delay.call(this, function () {\n\t\t\t\tthis.hide(event);\n\t\t\t}, this.options.hide.inactive);\n\t\t}\n\n\t\tfunction repositionMethod(event) {\n\t\t\tif (this.rendered && this.tooltip[0].offsetWidth > 0) {\n\t\t\t\tthis.reposition(event);\n\t\t\t}\n\t\t}\n\n\t\t// Store mouse coordinates\n\t\tPROTOTYPE._storeMouse = function (event) {\n\t\t\t(this.mouse = $.event.fix(event)).type = 'mousemove';\n\t\t\treturn this;\n\t\t};\n\n\t\t// Bind events\n\t\tPROTOTYPE._bind = function (targets, events, method, suffix, context) {\n\t\t\tif (!targets || !method || !events.length) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar ns = '.' + this._id + (suffix ? '-' + suffix : '');\n\t\t\t$(targets).bind((events.split ? events : events.join(ns + ' ')) + ns, $.proxy(method, context || this));\n\t\t\treturn this;\n\t\t};\n\t\tPROTOTYPE._unbind = function (targets, suffix) {\n\t\t\ttargets && $(targets).unbind('.' + this._id + (suffix ? '-' + suffix : ''));\n\t\t\treturn this;\n\t\t};\n\n\t\t// Global delegation helper\n\t\tfunction delegate(selector, events, method) {\n\t\t\t$(document.body).delegate(selector, (events.split ? events : events.join('.' + NAMESPACE + ' ')) + '.' + NAMESPACE, function () {\n\t\t\t\tvar api = QTIP.api[$.attr(this, ATTR_ID)];\n\t\t\t\tapi && !api.disabled && method.apply(api, arguments);\n\t\t\t});\n\t\t}\n\t\t// Event trigger\n\t\tPROTOTYPE._trigger = function (type, args, event) {\n\t\t\tvar callback = $.Event('tooltip' + type);\n\t\t\tcallback.originalEvent = event && $.extend({}, event) || this.cache.event || NULL;\n\n\t\t\tthis.triggering = type;\n\t\t\tthis.tooltip.trigger(callback, [this].concat(args || []));\n\t\t\tthis.triggering = FALSE;\n\n\t\t\treturn !callback.isDefaultPrevented();\n\t\t};\n\n\t\tPROTOTYPE._bindEvents = function (showEvents, hideEvents, showTargets, hideTargets, showMethod, hideMethod) {\n\t\t\t// Get tasrgets that lye within both\n\t\t\tvar similarTargets = showTargets.filter(hideTargets).add(hideTargets.filter(showTargets)),\n\t\t\t    toggleEvents = [];\n\n\t\t\t// If hide and show targets are the same...\n\t\t\tif (similarTargets.length) {\n\n\t\t\t\t// Filter identical show/hide events\n\t\t\t\t$.each(hideEvents, function (i, type) {\n\t\t\t\t\tvar showIndex = $.inArray(type, showEvents);\n\n\t\t\t\t\t// Both events are identical, remove from both hide and show events\n\t\t\t\t\t// and append to toggleEvents\n\t\t\t\t\tshowIndex > -1 && toggleEvents.push(showEvents.splice(showIndex, 1)[0]);\n\t\t\t\t});\n\n\t\t\t\t// Toggle events are special case of identical show/hide events, which happen in sequence\n\t\t\t\tif (toggleEvents.length) {\n\t\t\t\t\t// Bind toggle events to the similar targets\n\t\t\t\t\tthis._bind(similarTargets, toggleEvents, function (event) {\n\t\t\t\t\t\tvar state = this.rendered ? this.tooltip[0].offsetWidth > 0 : false;\n\t\t\t\t\t\t(state ? hideMethod : showMethod).call(this, event);\n\t\t\t\t\t});\n\n\t\t\t\t\t// Remove the similar targets from the regular show/hide bindings\n\t\t\t\t\tshowTargets = showTargets.not(similarTargets);\n\t\t\t\t\thideTargets = hideTargets.not(similarTargets);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Apply show/hide/toggle events\n\t\t\tthis._bind(showTargets, showEvents, showMethod);\n\t\t\tthis._bind(hideTargets, hideEvents, hideMethod);\n\t\t};\n\n\t\tPROTOTYPE._assignInitialEvents = function (event) {\n\t\t\tvar options = this.options,\n\t\t\t    showTarget = options.show.target,\n\t\t\t    hideTarget = options.hide.target,\n\t\t\t    showEvents = options.show.event ? $.trim('' + options.show.event).split(' ') : [],\n\t\t\t    hideEvents = options.hide.event ? $.trim('' + options.hide.event).split(' ') : [];\n\n\t\t\t// Catch remove/removeqtip events on target element to destroy redundant tooltips\n\t\t\tthis._bind(this.elements.target, ['remove', 'removeqtip'], function (event) {\n\t\t\t\tthis.destroy(true);\n\t\t\t}, 'destroy');\n\n\t\t\t/*\n    * Make sure hoverIntent functions properly by using mouseleave as a hide event if\n    * mouseenter/mouseout is used for show.event, even if it isn't in the users options.\n    */\n\t\t\tif (/mouse(over|enter)/i.test(options.show.event) && !/mouse(out|leave)/i.test(options.hide.event)) {\n\t\t\t\thideEvents.push('mouseleave');\n\t\t\t}\n\n\t\t\t/*\n    * Also make sure initial mouse targetting works correctly by caching mousemove coords\n    * on show targets before the tooltip has rendered. Also set onTarget when triggered to\n    * keep mouse tracking working.\n    */\n\t\t\tthis._bind(showTarget, 'mousemove', function (event) {\n\t\t\t\tthis._storeMouse(event);\n\t\t\t\tthis.cache.onTarget = TRUE;\n\t\t\t});\n\n\t\t\t// Define hoverIntent function\n\t\t\tfunction hoverIntent(event) {\n\t\t\t\t// Only continue if tooltip isn't disabled\n\t\t\t\tif (this.disabled || this.destroyed) {\n\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\n\t\t\t\t// Cache the event data\n\t\t\t\tthis.cache.event = event && $.event.fix(event);\n\t\t\t\tthis.cache.target = event && $(event.target);\n\n\t\t\t\t// Start the event sequence\n\t\t\t\tclearTimeout(this.timers.show);\n\t\t\t\tthis.timers.show = delay.call(this, function () {\n\t\t\t\t\tthis.render((typeof event === 'undefined' ? 'undefined' : _typeof(event)) === 'object' || options.show.ready);\n\t\t\t\t}, options.prerender ? 0 : options.show.delay);\n\t\t\t}\n\n\t\t\t// Filter and bind events\n\t\t\tthis._bindEvents(showEvents, hideEvents, showTarget, hideTarget, hoverIntent, function () {\n\t\t\t\tif (!this.timers) {\n\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\t\t\t\tclearTimeout(this.timers.show);\n\t\t\t});\n\n\t\t\t// Prerendering is enabled, create tooltip now\n\t\t\tif (options.show.ready || options.prerender) {\n\t\t\t\thoverIntent.call(this, event);\n\t\t\t}\n\t\t};\n\n\t\t// Event assignment method\n\t\tPROTOTYPE._assignEvents = function () {\n\t\t\tvar self = this,\n\t\t\t    options = this.options,\n\t\t\t    posOptions = options.position,\n\t\t\t    tooltip = this.tooltip,\n\t\t\t    showTarget = options.show.target,\n\t\t\t    hideTarget = options.hide.target,\n\t\t\t    containerTarget = posOptions.container,\n\t\t\t    viewportTarget = posOptions.viewport,\n\t\t\t    documentTarget = $(document),\n\t\t\t    bodyTarget = $(document.body),\n\t\t\t    windowTarget = $(window),\n\t\t\t    showEvents = options.show.event ? $.trim('' + options.show.event).split(' ') : [],\n\t\t\t    hideEvents = options.hide.event ? $.trim('' + options.hide.event).split(' ') : [];\n\n\t\t\t// Assign passed event callbacks\n\t\t\t$.each(options.events, function (name, callback) {\n\t\t\t\tself._bind(tooltip, name === 'toggle' ? ['tooltipshow', 'tooltiphide'] : ['tooltip' + name], callback, null, tooltip);\n\t\t\t});\n\n\t\t\t// Hide tooltips when leaving current window/frame (but not select/option elements)\n\t\t\tif (/mouse(out|leave)/i.test(options.hide.event) && options.hide.leave === 'window') {\n\t\t\t\tthis._bind(documentTarget, ['mouseout', 'blur'], function (event) {\n\t\t\t\t\tif (!/select|option/.test(event.target.nodeName) && !event.relatedTarget) {\n\t\t\t\t\t\tthis.hide(event);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Enable hide.fixed by adding appropriate class\n\t\t\tif (options.hide.fixed) {\n\t\t\t\thideTarget = hideTarget.add(tooltip.addClass(CLASS_FIXED));\n\t\t\t}\n\n\t\t\t/*\n    * Make sure hoverIntent functions properly by using mouseleave to clear show timer if\n    * mouseenter/mouseout is used for show.event, even if it isn't in the users options.\n    */\n\t\t\telse if (/mouse(over|enter)/i.test(options.show.event)) {\n\t\t\t\t\tthis._bind(hideTarget, 'mouseleave', function () {\n\t\t\t\t\t\tclearTimeout(this.timers.show);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t// Hide tooltip on document mousedown if unfocus events are enabled\n\t\t\tif (('' + options.hide.event).indexOf('unfocus') > -1) {\n\t\t\t\tthis._bind(containerTarget.closest('html'), ['mousedown', 'touchstart'], function (event) {\n\t\t\t\t\tvar elem = $(event.target),\n\t\t\t\t\t    enabled = this.rendered && !this.tooltip.hasClass(CLASS_DISABLED) && this.tooltip[0].offsetWidth > 0,\n\t\t\t\t\t    isAncestor = elem.parents(SELECTOR).filter(this.tooltip[0]).length > 0;\n\n\t\t\t\t\tif (elem[0] !== this.target[0] && elem[0] !== this.tooltip[0] && !isAncestor && !this.target.has(elem[0]).length && enabled) {\n\t\t\t\t\t\tthis.hide(event);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Check if the tooltip hides when inactive\n\t\t\tif ('number' === typeof options.hide.inactive) {\n\t\t\t\t// Bind inactive method to show target(s) as a custom event\n\t\t\t\tthis._bind(showTarget, 'qtip-' + this.id + '-inactive', inactiveMethod, 'inactive');\n\n\t\t\t\t// Define events which reset the 'inactive' event handler\n\t\t\t\tthis._bind(hideTarget.add(tooltip), QTIP.inactiveEvents, inactiveMethod);\n\t\t\t}\n\n\t\t\t// Filter and bind events\n\t\t\tthis._bindEvents(showEvents, hideEvents, showTarget, hideTarget, showMethod, hideMethod);\n\n\t\t\t// Mouse movement bindings\n\t\t\tthis._bind(showTarget.add(tooltip), 'mousemove', function (event) {\n\t\t\t\t// Check if the tooltip hides when mouse is moved a certain distance\n\t\t\t\tif ('number' === typeof options.hide.distance) {\n\t\t\t\t\tvar origin = this.cache.origin || {},\n\t\t\t\t\t    limit = this.options.hide.distance,\n\t\t\t\t\t    abs = Math.abs;\n\n\t\t\t\t\t// Check if the movement has gone beyond the limit, and hide it if so\n\t\t\t\t\tif (abs(event.pageX - origin.pageX) >= limit || abs(event.pageY - origin.pageY) >= limit) {\n\t\t\t\t\t\tthis.hide(event);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Cache mousemove coords on show targets\n\t\t\t\tthis._storeMouse(event);\n\t\t\t});\n\n\t\t\t// Mouse positioning events\n\t\t\tif (posOptions.target === 'mouse') {\n\t\t\t\t// If mouse adjustment is on...\n\t\t\t\tif (posOptions.adjust.mouse) {\n\t\t\t\t\t// Apply a mouseleave event so we don't get problems with overlapping\n\t\t\t\t\tif (options.hide.event) {\n\t\t\t\t\t\t// Track if we're on the target or not\n\t\t\t\t\t\tthis._bind(showTarget, ['mouseenter', 'mouseleave'], function (event) {\n\t\t\t\t\t\t\tif (!this.cache) {\n\t\t\t\t\t\t\t\treturn FALSE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.cache.onTarget = event.type === 'mouseenter';\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\t// Update tooltip position on mousemove\n\t\t\t\t\tthis._bind(documentTarget, 'mousemove', function (event) {\n\t\t\t\t\t\t// Update the tooltip position only if the tooltip is visible and adjustment is enabled\n\t\t\t\t\t\tif (this.rendered && this.cache.onTarget && !this.tooltip.hasClass(CLASS_DISABLED) && this.tooltip[0].offsetWidth > 0) {\n\t\t\t\t\t\t\tthis.reposition(event);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Adjust positions of the tooltip on window resize if enabled\n\t\t\tif (posOptions.adjust.resize || viewportTarget.length) {\n\t\t\t\tthis._bind($.event.special.resize ? viewportTarget : windowTarget, 'resize', repositionMethod);\n\t\t\t}\n\n\t\t\t// Adjust tooltip position on scroll of the window or viewport element if present\n\t\t\tif (posOptions.adjust.scroll) {\n\t\t\t\tthis._bind(windowTarget.add(posOptions.container), 'scroll', repositionMethod);\n\t\t\t}\n\t\t};\n\n\t\t// Un-assignment method\n\t\tPROTOTYPE._unassignEvents = function () {\n\t\t\tvar options = this.options,\n\t\t\t    showTargets = options.show.target,\n\t\t\t    hideTargets = options.hide.target,\n\t\t\t    targets = $.grep([this.elements.target[0], this.rendered && this.tooltip[0], options.position.container[0], options.position.viewport[0], options.position.container.closest('html')[0], // unfocus\n\t\t\twindow, document], function (i) {\n\t\t\t\treturn (typeof i === 'undefined' ? 'undefined' : _typeof(i)) === 'object';\n\t\t\t});\n\n\t\t\t// Add show and hide targets if they're valid\n\t\t\tif (showTargets && showTargets.toArray) {\n\t\t\t\ttargets = targets.concat(showTargets.toArray());\n\t\t\t}\n\t\t\tif (hideTargets && hideTargets.toArray) {\n\t\t\t\ttargets = targets.concat(hideTargets.toArray());\n\t\t\t}\n\n\t\t\t// Unbind the events\n\t\t\tthis._unbind(targets)._unbind(targets, 'destroy')._unbind(targets, 'inactive');\n\t\t};\n\n\t\t// Apply common event handlers using delegate (avoids excessive .bind calls!)\n\t\t$(function () {\n\t\t\tdelegate(SELECTOR, ['mouseenter', 'mouseleave'], function (event) {\n\t\t\t\tvar state = event.type === 'mouseenter',\n\t\t\t\t    tooltip = $(event.currentTarget),\n\t\t\t\t    target = $(event.relatedTarget || event.target),\n\t\t\t\t    options = this.options;\n\n\t\t\t\t// On mouseenter...\n\t\t\t\tif (state) {\n\t\t\t\t\t// Focus the tooltip on mouseenter (z-index stacking)\n\t\t\t\t\tthis.focus(event);\n\n\t\t\t\t\t// Clear hide timer on tooltip hover to prevent it from closing\n\t\t\t\t\ttooltip.hasClass(CLASS_FIXED) && !tooltip.hasClass(CLASS_DISABLED) && clearTimeout(this.timers.hide);\n\t\t\t\t}\n\n\t\t\t\t// On mouseleave...\n\t\t\t\telse {\n\t\t\t\t\t\t// When mouse tracking is enabled, hide when we leave the tooltip and not onto the show target (if a hide event is set)\n\t\t\t\t\t\tif (options.position.target === 'mouse' && options.position.adjust.mouse && options.hide.event && options.show.target && !target.closest(options.show.target[0]).length) {\n\t\t\t\t\t\t\tthis.hide(event);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t// Add hover class\n\t\t\t\ttooltip.toggleClass(CLASS_HOVER, state);\n\t\t\t});\n\n\t\t\t// Define events which reset the 'inactive' event handler\n\t\t\tdelegate('[' + ATTR_ID + ']', INACTIVE_EVENTS, inactiveMethod);\n\t\t});\n\t\t; // Initialization method\n\t\tfunction init(elem, id, opts) {\n\t\t\tvar obj,\n\t\t\t    posOptions,\n\t\t\t    attr,\n\t\t\t    config,\n\t\t\t    title,\n\n\n\t\t\t// Setup element references\n\t\t\tdocBody = $(document.body),\n\n\n\t\t\t// Use document body instead of document element if needed\n\t\t\tnewTarget = elem[0] === document ? docBody : elem,\n\n\n\t\t\t// Grab metadata from element if plugin is present\n\t\t\tmetadata = elem.metadata ? elem.metadata(opts.metadata) : NULL,\n\n\n\t\t\t// If metadata type if HTML5, grab 'name' from the object instead, or use the regular data object otherwise\n\t\t\tmetadata5 = opts.metadata.type === 'html5' && metadata ? metadata[opts.metadata.name] : NULL,\n\n\n\t\t\t// Grab data from metadata.name (or data-qtipopts as fallback) using .data() method,\n\t\t\thtml5 = elem.data(opts.metadata.name || 'qtipopts');\n\n\t\t\t// If we don't get an object returned attempt to parse it manualyl without parseJSON\n\t\t\ttry {\n\t\t\t\thtml5 = typeof html5 === 'string' ? $.parseJSON(html5) : html5;\n\t\t\t} catch (e) {}\n\n\t\t\t// Merge in and sanitize metadata\n\t\t\tconfig = $.extend(TRUE, {}, QTIP.defaults, opts, (typeof html5 === 'undefined' ? 'undefined' : _typeof(html5)) === 'object' ? sanitizeOptions(html5) : NULL, sanitizeOptions(metadata5 || metadata));\n\n\t\t\t// Re-grab our positioning options now we've merged our metadata and set id to passed value\n\t\t\tposOptions = config.position;\n\t\t\tconfig.id = id;\n\n\t\t\t// Setup missing content if none is detected\n\t\t\tif ('boolean' === typeof config.content.text) {\n\t\t\t\tattr = elem.attr(config.content.attr);\n\n\t\t\t\t// Grab from supplied attribute if available\n\t\t\t\tif (config.content.attr !== FALSE && attr) {\n\t\t\t\t\tconfig.content.text = attr;\n\t\t\t\t}\n\n\t\t\t\t// No valid content was found, abort render\n\t\t\t\telse {\n\t\t\t\t\t\treturn FALSE;\n\t\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Setup target options\n\t\t\tif (!posOptions.container.length) {\n\t\t\t\tposOptions.container = docBody;\n\t\t\t}\n\t\t\tif (posOptions.target === FALSE) {\n\t\t\t\tposOptions.target = newTarget;\n\t\t\t}\n\t\t\tif (config.show.target === FALSE) {\n\t\t\t\tconfig.show.target = newTarget;\n\t\t\t}\n\t\t\tif (config.show.solo === TRUE) {\n\t\t\t\tconfig.show.solo = posOptions.container.closest('body');\n\t\t\t}\n\t\t\tif (config.hide.target === FALSE) {\n\t\t\t\tconfig.hide.target = newTarget;\n\t\t\t}\n\t\t\tif (config.position.viewport === TRUE) {\n\t\t\t\tconfig.position.viewport = posOptions.container;\n\t\t\t}\n\n\t\t\t// Ensure we only use a single container\n\t\t\tposOptions.container = posOptions.container.eq(0);\n\n\t\t\t// Convert position corner values into x and y strings\n\t\t\tposOptions.at = new CORNER(posOptions.at, TRUE);\n\t\t\tposOptions.my = new CORNER(posOptions.my);\n\n\t\t\t// Destroy previous tooltip if overwrite is enabled, or skip element if not\n\t\t\tif (elem.data(NAMESPACE)) {\n\t\t\t\tif (config.overwrite) {\n\t\t\t\t\telem.qtip('destroy', true);\n\t\t\t\t} else if (config.overwrite === FALSE) {\n\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add has-qtip attribute\n\t\t\telem.attr(ATTR_HAS, id);\n\n\t\t\t// Remove title attribute and store it if present\n\t\t\tif (config.suppress && (title = elem.attr('title'))) {\n\t\t\t\t// Final attr call fixes event delegatiom and IE default tooltip showing problem\n\t\t\t\telem.removeAttr('title').attr(oldtitle, title).attr('title', '');\n\t\t\t}\n\n\t\t\t// Initialize the tooltip and add API reference\n\t\t\tobj = new QTip(elem, config, id, !!attr);\n\t\t\telem.data(NAMESPACE, obj);\n\n\t\t\treturn obj;\n\t\t}\n\n\t\t// jQuery $.fn extension method\n\t\tQTIP = $.fn.qtip = function (options, notation, newValue) {\n\t\t\tvar command = ('' + options).toLowerCase(),\n\t\t\t    // Parse command\n\t\t\treturned = NULL,\n\t\t\t    args = $.makeArray(arguments).slice(1),\n\t\t\t    event = args[args.length - 1],\n\t\t\t    opts = this[0] ? $.data(this[0], NAMESPACE) : NULL;\n\n\t\t\t// Check for API request\n\t\t\tif (!arguments.length && opts || command === 'api') {\n\t\t\t\treturn opts;\n\t\t\t}\n\n\t\t\t// Execute API command if present\n\t\t\telse if ('string' === typeof options) {\n\t\t\t\t\tthis.each(function () {\n\t\t\t\t\t\tvar api = $.data(this, NAMESPACE);\n\t\t\t\t\t\tif (!api) {\n\t\t\t\t\t\t\treturn TRUE;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Cache the event if possible\n\t\t\t\t\t\tif (event && event.timeStamp) {\n\t\t\t\t\t\t\tapi.cache.event = event;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Check for specific API commands\n\t\t\t\t\t\tif (notation && (command === 'option' || command === 'options')) {\n\t\t\t\t\t\t\tif (newValue !== undefined || $.isPlainObject(notation)) {\n\t\t\t\t\t\t\t\tapi.set(notation, newValue);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturned = api.get(notation);\n\t\t\t\t\t\t\t\treturn FALSE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Execute API command\n\t\t\t\t\t\telse if (api[command]) {\n\t\t\t\t\t\t\t\tapi[command].apply(api, args);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\treturn returned !== NULL ? returned : this;\n\t\t\t\t}\n\n\t\t\t\t// No API commands. validate provided options and setup qTips\n\t\t\t\telse if ('object' === (typeof options === 'undefined' ? 'undefined' : _typeof(options)) || !arguments.length) {\n\t\t\t\t\t\t// Sanitize options first\n\t\t\t\t\t\topts = sanitizeOptions($.extend(TRUE, {}, options));\n\n\t\t\t\t\t\treturn this.each(function (i) {\n\t\t\t\t\t\t\tvar api, id;\n\n\t\t\t\t\t\t\t// Find next available ID, or use custom ID if provided\n\t\t\t\t\t\t\tid = $.isArray(opts.id) ? opts.id[i] : opts.id;\n\t\t\t\t\t\t\tid = !id || id === FALSE || id.length < 1 || QTIP.api[id] ? QTIP.nextid++ : id;\n\n\t\t\t\t\t\t\t// Initialize the qTip and re-grab newly sanitized options\n\t\t\t\t\t\t\tapi = init($(this), id, opts);\n\t\t\t\t\t\t\tif (api === FALSE) {\n\t\t\t\t\t\t\t\treturn TRUE;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tQTIP.api[id] = api;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Initialize plugins\n\t\t\t\t\t\t\t$.each(PLUGINS, function () {\n\t\t\t\t\t\t\t\tif (this.initialize === 'initialize') {\n\t\t\t\t\t\t\t\t\tthis(api);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t// Assign initial pre-render events\n\t\t\t\t\t\t\tapi._assignInitialEvents(event);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t};\n\n\t\t// Expose class\n\t\t$.qtip = QTip;\n\n\t\t// Populated in render method\n\t\tQTIP.api = {};\n\t\t;$.each({\n\t\t\t/* Allow other plugins to successfully retrieve the title of an element with a qTip applied */\n\t\t\tattr: function attr(_attr, val) {\n\t\t\t\tif (this.length) {\n\t\t\t\t\tvar self = this[0],\n\t\t\t\t\t    title = 'title',\n\t\t\t\t\t    api = $.data(self, 'qtip');\n\n\t\t\t\t\tif (_attr === title && api && 'object' === (typeof api === 'undefined' ? 'undefined' : _typeof(api)) && api.options.suppress) {\n\t\t\t\t\t\tif (arguments.length < 2) {\n\t\t\t\t\t\t\treturn $.attr(self, oldtitle);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// If qTip is rendered and title was originally used as content, update it\n\t\t\t\t\t\tif (api && api.options.content.attr === title && api.cache.attr) {\n\t\t\t\t\t\t\tapi.set('content.text', val);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Use the regular attr method to set, then cache the result\n\t\t\t\t\t\treturn this.attr(oldtitle, val);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn $.fn['attr' + replaceSuffix].apply(this, arguments);\n\t\t\t},\n\n\t\t\t/* Allow clone to correctly retrieve cached title attributes */\n\t\t\tclone: function clone(keepData) {\n\t\t\t\tvar titles = $([]),\n\t\t\t\t    title = 'title',\n\n\n\t\t\t\t// Clone our element using the real clone method\n\t\t\t\telems = $.fn['clone' + replaceSuffix].apply(this, arguments);\n\n\t\t\t\t// Grab all elements with an oldtitle set, and change it to regular title attribute, if keepData is false\n\t\t\t\tif (!keepData) {\n\t\t\t\t\telems.filter('[' + oldtitle + ']').attr('title', function () {\n\t\t\t\t\t\treturn $.attr(this, oldtitle);\n\t\t\t\t\t}).removeAttr(oldtitle);\n\t\t\t\t}\n\n\t\t\t\treturn elems;\n\t\t\t}\n\t\t}, function (name, func) {\n\t\t\tif (!func || $.fn[name + replaceSuffix]) {\n\t\t\t\treturn TRUE;\n\t\t\t}\n\n\t\t\tvar old = $.fn[name + replaceSuffix] = $.fn[name];\n\t\t\t$.fn[name] = function () {\n\t\t\t\treturn func.apply(this, arguments) || old.apply(this, arguments);\n\t\t\t};\n\t\t});\n\n\t\t/* Fire off 'removeqtip' handler in $.cleanData if jQuery UI not present (it already does similar).\n   * This snippet is taken directly from jQuery UI source code found here:\n   *     http://code.jquery.com/ui/jquery-ui-git.js\n   */\n\t\tif (!$.ui) {\n\t\t\t$['cleanData' + replaceSuffix] = $.cleanData;\n\t\t\t$.cleanData = function (elems) {\n\t\t\t\tfor (var i = 0, elem; (elem = $(elems[i])).length; i++) {\n\t\t\t\t\tif (elem.attr(ATTR_HAS)) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\telem.triggerHandler('removeqtip');\n\t\t\t\t\t\t} catch (e) {}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t$['cleanData' + replaceSuffix].apply(this, arguments);\n\t\t\t};\n\t\t}\n\t\t; // qTip version\n\t\tQTIP.version = '2.2.1-29-';\n\n\t\t// Base ID for all qTips\n\t\tQTIP.nextid = 0;\n\n\t\t// Inactive events array\n\t\tQTIP.inactiveEvents = INACTIVE_EVENTS;\n\n\t\t// Base z-index for all qTips\n\t\tQTIP.zindex = 15000;\n\n\t\t// Define configuration defaults\n\t\tQTIP.defaults = {\n\t\t\tprerender: FALSE,\n\t\t\tid: FALSE,\n\t\t\toverwrite: TRUE,\n\t\t\tsuppress: TRUE,\n\t\t\tcontent: {\n\t\t\t\ttext: TRUE,\n\t\t\t\tattr: 'title',\n\t\t\t\ttitle: FALSE,\n\t\t\t\tbutton: FALSE\n\t\t\t},\n\t\t\tposition: {\n\t\t\t\tmy: 'top left',\n\t\t\t\tat: 'bottom right',\n\t\t\t\ttarget: FALSE,\n\t\t\t\tcontainer: FALSE,\n\t\t\t\tviewport: FALSE,\n\t\t\t\tadjust: {\n\t\t\t\t\tx: 0, y: 0,\n\t\t\t\t\tmouse: TRUE,\n\t\t\t\t\tscroll: TRUE,\n\t\t\t\t\tresize: TRUE,\n\t\t\t\t\tmethod: 'flipinvert flipinvert'\n\t\t\t\t},\n\t\t\t\teffect: function effect(api, pos, viewport) {\n\t\t\t\t\t$(this).animate(pos, {\n\t\t\t\t\t\tduration: 200,\n\t\t\t\t\t\tqueue: FALSE\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t},\n\t\t\tshow: {\n\t\t\t\ttarget: FALSE,\n\t\t\t\tevent: 'mouseenter',\n\t\t\t\teffect: TRUE,\n\t\t\t\tdelay: 90,\n\t\t\t\tsolo: FALSE,\n\t\t\t\tready: FALSE,\n\t\t\t\tautofocus: FALSE\n\t\t\t},\n\t\t\thide: {\n\t\t\t\ttarget: FALSE,\n\t\t\t\tevent: 'mouseleave',\n\t\t\t\teffect: TRUE,\n\t\t\t\tdelay: 0,\n\t\t\t\tfixed: FALSE,\n\t\t\t\tinactive: FALSE,\n\t\t\t\tleave: 'window',\n\t\t\t\tdistance: FALSE\n\t\t\t},\n\t\t\tstyle: {\n\t\t\t\tclasses: '',\n\t\t\t\twidget: FALSE,\n\t\t\t\twidth: FALSE,\n\t\t\t\theight: FALSE,\n\t\t\t\tdef: TRUE\n\t\t\t},\n\t\t\tevents: {\n\t\t\t\trender: NULL,\n\t\t\t\tmove: NULL,\n\t\t\t\tshow: NULL,\n\t\t\t\thide: NULL,\n\t\t\t\ttoggle: NULL,\n\t\t\t\tvisible: NULL,\n\t\t\t\thidden: NULL,\n\t\t\t\tfocus: NULL,\n\t\t\t\tblur: NULL\n\t\t\t}\n\t\t};\n\t\t;var TIP,\n\n\n\t\t// .bind()/.on() namespace\n\t\tTIPNS = '.qtip-tip',\n\n\n\t\t// Common CSS strings\n\t\tMARGIN = 'margin',\n\t\t    BORDER = 'border',\n\t\t    COLOR = 'color',\n\t\t    BG_COLOR = 'background-color',\n\t\t    TRANSPARENT = 'transparent',\n\t\t    IMPORTANT = ' !important',\n\n\n\t\t// Check if the browser supports <canvas/> elements\n\t\tHASCANVAS = !!document.createElement('canvas').getContext,\n\n\n\t\t// Invalid colour values used in parseColours()\n\t\tINVALID = /rgba?\\(0, 0, 0(, 0)?\\)|transparent|#123456/i;\n\n\t\t// Camel-case method, taken from jQuery source\n\t\t// http://code.jquery.com/jquery-1.8.0.js\n\t\tfunction camel(s) {\n\t\t\treturn s.charAt(0).toUpperCase() + s.slice(1);\n\t\t}\n\n\t\t/*\n   * Modified from Modernizr's testPropsAll()\n   * http://modernizr.com/downloads/modernizr-latest.js\n   */\n\t\tvar cssProps = {},\n\t\t    cssPrefixes = [\"Webkit\", \"O\", \"Moz\", \"ms\"];\n\t\tfunction vendorCss(elem, prop) {\n\t\t\tvar ucProp = prop.charAt(0).toUpperCase() + prop.slice(1),\n\t\t\t    props = (prop + ' ' + cssPrefixes.join(ucProp + ' ') + ucProp).split(' '),\n\t\t\t    cur,\n\t\t\t    val,\n\t\t\t    i = 0;\n\n\t\t\t// If the property has already been mapped...\n\t\t\tif (cssProps[prop]) {\n\t\t\t\treturn elem.css(cssProps[prop]);\n\t\t\t}\n\n\t\t\twhile (cur = props[i++]) {\n\t\t\t\tif ((val = elem.css(cur)) !== undefined) {\n\t\t\t\t\treturn cssProps[prop] = cur, val;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Parse a given elements CSS property into an int\n\t\tfunction intCss(elem, prop) {\n\t\t\treturn Math.ceil(parseFloat(vendorCss(elem, prop)));\n\t\t}\n\n\t\t// VML creation (for IE only)\n\t\tif (!HASCANVAS) {\n\t\t\tvar createVML = function createVML(tag, props, style) {\n\t\t\t\treturn '<qtipvml:' + tag + ' xmlns=\"urn:schemas-microsoft.com:vml\" class=\"qtip-vml\" ' + (props || '') + ' style=\"behavior: url(#default#VML); ' + (style || '') + '\" />';\n\t\t\t};\n\t\t}\n\n\t\t// Canvas only definitions\n\t\telse {\n\t\t\t\tvar PIXEL_RATIO = window.devicePixelRatio || 1,\n\t\t\t\t    BACKING_STORE_RATIO = function () {\n\t\t\t\t\tvar context = document.createElement('canvas').getContext('2d');\n\t\t\t\t\treturn context.backingStorePixelRatio || context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || 1;\n\t\t\t\t}(),\n\t\t\t\t    SCALE = PIXEL_RATIO / BACKING_STORE_RATIO;\n\t\t\t}\n\n\t\tfunction Tip(qtip, options) {\n\t\t\tthis._ns = 'tip';\n\t\t\tthis.options = options;\n\t\t\tthis.offset = options.offset;\n\t\t\tthis.size = [options.width, options.height];\n\n\t\t\t// Initialize\n\t\t\tthis.init(this.qtip = qtip);\n\t\t}\n\n\t\t$.extend(Tip.prototype, {\n\t\t\tinit: function init(qtip) {\n\t\t\t\tvar context, tip;\n\n\t\t\t\t// Create tip element and prepend to the tooltip\n\t\t\t\ttip = this.element = qtip.elements.tip = $('<div />', { 'class': NAMESPACE + '-tip' }).prependTo(qtip.tooltip);\n\n\t\t\t\t// Create tip drawing element(s)\n\t\t\t\tif (HASCANVAS) {\n\t\t\t\t\t// save() as soon as we create the canvas element so FF2 doesn't bork on our first restore()!\n\t\t\t\t\tcontext = $('<canvas />').appendTo(this.element)[0].getContext('2d');\n\n\t\t\t\t\t// Setup constant parameters\n\t\t\t\t\tcontext.lineJoin = 'miter';\n\t\t\t\t\tcontext.miterLimit = 100000;\n\t\t\t\t\tcontext.save();\n\t\t\t\t} else {\n\t\t\t\t\tcontext = createVML('shape', 'coordorigin=\"0,0\"', 'position:absolute;');\n\t\t\t\t\tthis.element.html(context + context);\n\n\t\t\t\t\t// Prevent mousing down on the tip since it causes problems with .live() handling in IE due to VML\n\t\t\t\t\tqtip._bind($('*', tip).add(tip), ['click', 'mousedown'], function (event) {\n\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t}, this._ns);\n\t\t\t\t}\n\n\t\t\t\t// Bind update events\n\t\t\t\tqtip._bind(qtip.tooltip, 'tooltipmove', this.reposition, this._ns, this);\n\n\t\t\t\t// Create it\n\t\t\t\tthis.create();\n\t\t\t},\n\n\t\t\t_swapDimensions: function _swapDimensions() {\n\t\t\t\tthis.size[0] = this.options.height;\n\t\t\t\tthis.size[1] = this.options.width;\n\t\t\t},\n\t\t\t_resetDimensions: function _resetDimensions() {\n\t\t\t\tthis.size[0] = this.options.width;\n\t\t\t\tthis.size[1] = this.options.height;\n\t\t\t},\n\n\t\t\t_useTitle: function _useTitle(corner) {\n\t\t\t\tvar titlebar = this.qtip.elements.titlebar;\n\t\t\t\treturn titlebar && (corner.y === TOP || corner.y === CENTER && this.element.position().top + this.size[1] / 2 + this.options.offset < titlebar.outerHeight(TRUE));\n\t\t\t},\n\n\t\t\t_parseCorner: function _parseCorner(corner) {\n\t\t\t\tvar my = this.qtip.options.position.my;\n\n\t\t\t\t// Detect corner and mimic properties\n\t\t\t\tif (corner === FALSE || my === FALSE) {\n\t\t\t\t\tcorner = FALSE;\n\t\t\t\t} else if (corner === TRUE) {\n\t\t\t\t\tcorner = new CORNER(my.string());\n\t\t\t\t} else if (!corner.string) {\n\t\t\t\t\tcorner = new CORNER(corner);\n\t\t\t\t\tcorner.fixed = TRUE;\n\t\t\t\t}\n\n\t\t\t\treturn corner;\n\t\t\t},\n\n\t\t\t_parseWidth: function _parseWidth(corner, side, use) {\n\t\t\t\tvar elements = this.qtip.elements,\n\t\t\t\t    prop = BORDER + camel(side) + 'Width';\n\n\t\t\t\treturn (use ? intCss(use, prop) : intCss(elements.content, prop) || intCss(this._useTitle(corner) && elements.titlebar || elements.content, prop) || intCss(elements.tooltip, prop)) || 0;\n\t\t\t},\n\n\t\t\t_parseRadius: function _parseRadius(corner) {\n\t\t\t\tvar elements = this.qtip.elements,\n\t\t\t\t    prop = BORDER + camel(corner.y) + camel(corner.x) + 'Radius';\n\n\t\t\t\treturn BROWSER.ie < 9 ? 0 : intCss(this._useTitle(corner) && elements.titlebar || elements.content, prop) || intCss(elements.tooltip, prop) || 0;\n\t\t\t},\n\n\t\t\t_invalidColour: function _invalidColour(elem, prop, compare) {\n\t\t\t\tvar val = elem.css(prop);\n\t\t\t\treturn !val || compare && val === elem.css(compare) || INVALID.test(val) ? FALSE : val;\n\t\t\t},\n\n\t\t\t_parseColours: function _parseColours(corner) {\n\t\t\t\tvar elements = this.qtip.elements,\n\t\t\t\t    tip = this.element.css('cssText', ''),\n\t\t\t\t    borderSide = BORDER + camel(corner[corner.precedance]) + camel(COLOR),\n\t\t\t\t    colorElem = this._useTitle(corner) && elements.titlebar || elements.content,\n\t\t\t\t    css = this._invalidColour,\n\t\t\t\t    color = [];\n\n\t\t\t\t// Attempt to detect the background colour from various elements, left-to-right precedance\n\t\t\t\tcolor[0] = css(tip, BG_COLOR) || css(colorElem, BG_COLOR) || css(elements.content, BG_COLOR) || css(elements.tooltip, BG_COLOR) || tip.css(BG_COLOR);\n\n\t\t\t\t// Attempt to detect the correct border side colour from various elements, left-to-right precedance\n\t\t\t\tcolor[1] = css(tip, borderSide, COLOR) || css(colorElem, borderSide, COLOR) || css(elements.content, borderSide, COLOR) || css(elements.tooltip, borderSide, COLOR) || elements.tooltip.css(borderSide);\n\n\t\t\t\t// Reset background and border colours\n\t\t\t\t$('*', tip).add(tip).css('cssText', BG_COLOR + ':' + TRANSPARENT + IMPORTANT + ';' + BORDER + ':0' + IMPORTANT + ';');\n\n\t\t\t\treturn color;\n\t\t\t},\n\n\t\t\t_calculateSize: function _calculateSize(corner) {\n\t\t\t\tvar y = corner.precedance === Y,\n\t\t\t\t    width = this.options['width'],\n\t\t\t\t    height = this.options['height'],\n\t\t\t\t    isCenter = corner.abbrev() === 'c',\n\t\t\t\t    base = (y ? width : height) * (isCenter ? 0.5 : 1),\n\t\t\t\t    pow = Math.pow,\n\t\t\t\t    round = Math.round,\n\t\t\t\t    bigHyp,\n\t\t\t\t    ratio,\n\t\t\t\t    result,\n\t\t\t\t    smallHyp = Math.sqrt(pow(base, 2) + pow(height, 2)),\n\t\t\t\t    hyp = [this.border / base * smallHyp, this.border / height * smallHyp];\n\n\t\t\t\thyp[2] = Math.sqrt(pow(hyp[0], 2) - pow(this.border, 2));\n\t\t\t\thyp[3] = Math.sqrt(pow(hyp[1], 2) - pow(this.border, 2));\n\n\t\t\t\tbigHyp = smallHyp + hyp[2] + hyp[3] + (isCenter ? 0 : hyp[0]);\n\t\t\t\tratio = bigHyp / smallHyp;\n\n\t\t\t\tresult = [round(ratio * width), round(ratio * height)];\n\t\t\t\treturn y ? result : result.reverse();\n\t\t\t},\n\n\t\t\t// Tip coordinates calculator\n\t\t\t_calculateTip: function _calculateTip(corner, size, scale) {\n\t\t\t\tscale = scale || 1;\n\t\t\t\tsize = size || this.size;\n\n\t\t\t\tvar width = size[0] * scale,\n\t\t\t\t    height = size[1] * scale,\n\t\t\t\t    width2 = Math.ceil(width / 2),\n\t\t\t\t    height2 = Math.ceil(height / 2),\n\n\n\t\t\t\t// Define tip coordinates in terms of height and width values\n\t\t\t\ttips = {\n\t\t\t\t\tbr: [0, 0, width, height, width, 0],\n\t\t\t\t\tbl: [0, 0, width, 0, 0, height],\n\t\t\t\t\ttr: [0, height, width, 0, width, height],\n\t\t\t\t\ttl: [0, 0, 0, height, width, height],\n\t\t\t\t\ttc: [0, height, width2, 0, width, height],\n\t\t\t\t\tbc: [0, 0, width, 0, width2, height],\n\t\t\t\t\trc: [0, 0, width, height2, 0, height],\n\t\t\t\t\tlc: [width, 0, width, height, 0, height2]\n\t\t\t\t};\n\n\t\t\t\t// Set common side shapes\n\t\t\t\ttips.lt = tips.br;tips.rt = tips.bl;\n\t\t\t\ttips.lb = tips.tr;tips.rb = tips.tl;\n\n\t\t\t\treturn tips[corner.abbrev()];\n\t\t\t},\n\n\t\t\t// Tip coordinates drawer (canvas)\n\t\t\t_drawCoords: function _drawCoords(context, coords) {\n\t\t\t\tcontext.beginPath();\n\t\t\t\tcontext.moveTo(coords[0], coords[1]);\n\t\t\t\tcontext.lineTo(coords[2], coords[3]);\n\t\t\t\tcontext.lineTo(coords[4], coords[5]);\n\t\t\t\tcontext.closePath();\n\t\t\t},\n\n\t\t\tcreate: function create() {\n\t\t\t\t// Determine tip corner\n\t\t\t\tvar c = this.corner = (HASCANVAS || BROWSER.ie) && this._parseCorner(this.options.corner);\n\n\t\t\t\t// If we have a tip corner...\n\t\t\t\tif (this.enabled = !!this.corner && this.corner.abbrev() !== 'c') {\n\t\t\t\t\t// Cache it\n\t\t\t\t\tthis.qtip.cache.corner = c.clone();\n\n\t\t\t\t\t// Create it\n\t\t\t\t\tthis.update();\n\t\t\t\t}\n\n\t\t\t\t// Toggle tip element\n\t\t\t\tthis.element.toggle(this.enabled);\n\n\t\t\t\treturn this.corner;\n\t\t\t},\n\n\t\t\tupdate: function update(corner, position) {\n\t\t\t\tif (!this.enabled) {\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t\tvar elements = this.qtip.elements,\n\t\t\t\t    tip = this.element,\n\t\t\t\t    inner = tip.children(),\n\t\t\t\t    options = this.options,\n\t\t\t\t    curSize = this.size,\n\t\t\t\t    mimic = options.mimic,\n\t\t\t\t    round = Math.round,\n\t\t\t\t    color,\n\t\t\t\t    precedance,\n\t\t\t\t    context,\n\t\t\t\t    coords,\n\t\t\t\t    bigCoords,\n\t\t\t\t    translate,\n\t\t\t\t    newSize,\n\t\t\t\t    border,\n\t\t\t\t    BACKING_STORE_RATIO;\n\n\t\t\t\t// Re-determine tip if not already set\n\t\t\t\tif (!corner) {\n\t\t\t\t\tcorner = this.qtip.cache.corner || this.corner;\n\t\t\t\t}\n\n\t\t\t\t// Use corner property if we detect an invalid mimic value\n\t\t\t\tif (mimic === FALSE) {\n\t\t\t\t\tmimic = corner;\n\t\t\t\t}\n\n\t\t\t\t// Otherwise inherit mimic properties from the corner object as necessary\n\t\t\t\telse {\n\t\t\t\t\t\tmimic = new CORNER(mimic);\n\t\t\t\t\t\tmimic.precedance = corner.precedance;\n\n\t\t\t\t\t\tif (mimic.x === 'inherit') {\n\t\t\t\t\t\t\tmimic.x = corner.x;\n\t\t\t\t\t\t} else if (mimic.y === 'inherit') {\n\t\t\t\t\t\t\tmimic.y = corner.y;\n\t\t\t\t\t\t} else if (mimic.x === mimic.y) {\n\t\t\t\t\t\t\tmimic[corner.precedance] = corner[corner.precedance];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tprecedance = mimic.precedance;\n\n\t\t\t\t// Ensure the tip width.height are relative to the tip position\n\t\t\t\tif (corner.precedance === X) {\n\t\t\t\t\tthis._swapDimensions();\n\t\t\t\t} else {\n\t\t\t\t\tthis._resetDimensions();\n\t\t\t\t}\n\n\t\t\t\t// Update our colours\n\t\t\t\tcolor = this.color = this._parseColours(corner);\n\n\t\t\t\t// Detect border width, taking into account colours\n\t\t\t\tif (color[1] !== TRANSPARENT) {\n\t\t\t\t\t// Grab border width\n\t\t\t\t\tborder = this.border = this._parseWidth(corner, corner[corner.precedance]);\n\n\t\t\t\t\t// If border width isn't zero, use border color as fill if it's not invalid (1.0 style tips)\n\t\t\t\t\tif (options.border && border < 1 && !INVALID.test(color[1])) {\n\t\t\t\t\t\tcolor[0] = color[1];\n\t\t\t\t\t}\n\n\t\t\t\t\t// Set border width (use detected border width if options.border is true)\n\t\t\t\t\tthis.border = border = options.border !== TRUE ? options.border : border;\n\t\t\t\t}\n\n\t\t\t\t// Border colour was invalid, set border to zero\n\t\t\t\telse {\n\t\t\t\t\t\tthis.border = border = 0;\n\t\t\t\t\t}\n\n\t\t\t\t// Determine tip size\n\t\t\t\tnewSize = this.size = this._calculateSize(corner);\n\t\t\t\ttip.css({\n\t\t\t\t\twidth: newSize[0],\n\t\t\t\t\theight: newSize[1],\n\t\t\t\t\tlineHeight: newSize[1] + 'px'\n\t\t\t\t});\n\n\t\t\t\t// Calculate tip translation\n\t\t\t\tif (corner.precedance === Y) {\n\t\t\t\t\ttranslate = [round(mimic.x === LEFT ? border : mimic.x === RIGHT ? newSize[0] - curSize[0] - border : (newSize[0] - curSize[0]) / 2), round(mimic.y === TOP ? newSize[1] - curSize[1] : 0)];\n\t\t\t\t} else {\n\t\t\t\t\ttranslate = [round(mimic.x === LEFT ? newSize[0] - curSize[0] : 0), round(mimic.y === TOP ? border : mimic.y === BOTTOM ? newSize[1] - curSize[1] - border : (newSize[1] - curSize[1]) / 2)];\n\t\t\t\t}\n\n\t\t\t\t// Canvas drawing implementation\n\t\t\t\tif (HASCANVAS) {\n\t\t\t\t\t// Grab canvas context and clear/save it\n\t\t\t\t\tcontext = inner[0].getContext('2d');\n\t\t\t\t\tcontext.restore();context.save();\n\t\t\t\t\tcontext.clearRect(0, 0, 6000, 6000);\n\n\t\t\t\t\t// Calculate coordinates\n\t\t\t\t\tcoords = this._calculateTip(mimic, curSize, SCALE);\n\t\t\t\t\tbigCoords = this._calculateTip(mimic, this.size, SCALE);\n\n\t\t\t\t\t// Set the canvas size using calculated size\n\t\t\t\t\tinner.attr(WIDTH, newSize[0] * SCALE).attr(HEIGHT, newSize[1] * SCALE);\n\t\t\t\t\tinner.css(WIDTH, newSize[0]).css(HEIGHT, newSize[1]);\n\n\t\t\t\t\t// Draw the outer-stroke tip\n\t\t\t\t\tthis._drawCoords(context, bigCoords);\n\t\t\t\t\tcontext.fillStyle = color[1];\n\t\t\t\t\tcontext.fill();\n\n\t\t\t\t\t// Draw the actual tip\n\t\t\t\t\tcontext.translate(translate[0] * SCALE, translate[1] * SCALE);\n\t\t\t\t\tthis._drawCoords(context, coords);\n\t\t\t\t\tcontext.fillStyle = color[0];\n\t\t\t\t\tcontext.fill();\n\t\t\t\t}\n\n\t\t\t\t// VML (IE Proprietary implementation)\n\t\t\t\telse {\n\t\t\t\t\t\t// Calculate coordinates\n\t\t\t\t\t\tcoords = this._calculateTip(mimic);\n\n\t\t\t\t\t\t// Setup coordinates string\n\t\t\t\t\t\tcoords = 'm' + coords[0] + ',' + coords[1] + ' l' + coords[2] + ',' + coords[3] + ' ' + coords[4] + ',' + coords[5] + ' xe';\n\n\t\t\t\t\t\t// Setup VML-specific offset for pixel-perfection\n\t\t\t\t\t\ttranslate[2] = border && /^(r|b)/i.test(corner.string()) ? BROWSER.ie === 8 ? 2 : 1 : 0;\n\n\t\t\t\t\t\t// Set initial CSS\n\t\t\t\t\t\tinner.css({\n\t\t\t\t\t\t\tcoordsize: newSize[0] + border + ' ' + (newSize[1] + border),\n\t\t\t\t\t\t\tantialias: '' + (mimic.string().indexOf(CENTER) > -1),\n\t\t\t\t\t\t\tleft: translate[0] - translate[2] * Number(precedance === X),\n\t\t\t\t\t\t\ttop: translate[1] - translate[2] * Number(precedance === Y),\n\t\t\t\t\t\t\twidth: newSize[0] + border,\n\t\t\t\t\t\t\theight: newSize[1] + border\n\t\t\t\t\t\t}).each(function (i) {\n\t\t\t\t\t\t\tvar $this = $(this);\n\n\t\t\t\t\t\t\t// Set shape specific attributes\n\t\t\t\t\t\t\t$this[$this.prop ? 'prop' : 'attr']({\n\t\t\t\t\t\t\t\tcoordsize: newSize[0] + border + ' ' + (newSize[1] + border),\n\t\t\t\t\t\t\t\tpath: coords,\n\t\t\t\t\t\t\t\tfillcolor: color[0],\n\t\t\t\t\t\t\t\tfilled: !!i,\n\t\t\t\t\t\t\t\tstroked: !i\n\t\t\t\t\t\t\t}).toggle(!!(border || i));\n\n\t\t\t\t\t\t\t// Check if border is enabled and add stroke element\n\t\t\t\t\t\t\t!i && $this.html(createVML('stroke', 'weight=\"' + border * 2 + 'px\" color=\"' + color[1] + '\" miterlimit=\"1000\" joinstyle=\"miter\"'));\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t// Opera bug #357 - Incorrect tip position\n\t\t\t\t// https://github.com/Craga89/qTip2/issues/367\n\t\t\t\twindow.opera && setTimeout(function () {\n\t\t\t\t\telements.tip.css({\n\t\t\t\t\t\tdisplay: 'inline-block',\n\t\t\t\t\t\tvisibility: 'visible'\n\t\t\t\t\t});\n\t\t\t\t}, 1);\n\n\t\t\t\t// Position if needed\n\t\t\t\tif (position !== FALSE) {\n\t\t\t\t\tthis.calculate(corner, newSize);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tcalculate: function calculate(corner, size) {\n\t\t\t\tif (!this.enabled) {\n\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\n\t\t\t\tvar self = this,\n\t\t\t\t    elements = this.qtip.elements,\n\t\t\t\t    tip = this.element,\n\t\t\t\t    userOffset = this.options.offset,\n\t\t\t\t    isWidget = elements.tooltip.hasClass('ui-widget'),\n\t\t\t\t    position = {},\n\t\t\t\t    precedance,\n\t\t\t\t    corners;\n\n\t\t\t\t// Inherit corner if not provided\n\t\t\t\tcorner = corner || this.corner;\n\t\t\t\tprecedance = corner.precedance;\n\n\t\t\t\t// Determine which tip dimension to use for adjustment\n\t\t\t\tsize = size || this._calculateSize(corner);\n\n\t\t\t\t// Setup corners and offset array\n\t\t\t\tcorners = [corner.x, corner.y];\n\t\t\t\tif (precedance === X) {\n\t\t\t\t\tcorners.reverse();\n\t\t\t\t}\n\n\t\t\t\t// Calculate tip position\n\t\t\t\t$.each(corners, function (i, side) {\n\t\t\t\t\tvar b, bc, br;\n\n\t\t\t\t\tif (side === CENTER) {\n\t\t\t\t\t\tb = precedance === Y ? LEFT : TOP;\n\t\t\t\t\t\tposition[b] = '50%';\n\t\t\t\t\t\tposition[MARGIN + '-' + b] = -Math.round(size[precedance === Y ? 0 : 1] / 2) + userOffset;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tb = self._parseWidth(corner, side, elements.tooltip);\n\t\t\t\t\t\tbc = self._parseWidth(corner, side, elements.content);\n\t\t\t\t\t\tbr = self._parseRadius(corner);\n\n\t\t\t\t\t\tposition[side] = Math.max(-self.border, i ? bc : userOffset + (br > b ? br : -b));\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// Adjust for tip size\n\t\t\t\tposition[corner[precedance]] -= size[precedance === X ? 0 : 1];\n\n\t\t\t\t// Set and return new position\n\t\t\t\ttip.css({ margin: '', top: '', bottom: '', left: '', right: '' }).css(position);\n\t\t\t\treturn position;\n\t\t\t},\n\n\t\t\treposition: function reposition(event, api, pos, viewport) {\n\t\t\t\tif (!this.enabled) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar cache = api.cache,\n\t\t\t\t    newCorner = this.corner.clone(),\n\t\t\t\t    adjust = pos.adjusted,\n\t\t\t\t    method = api.options.position.adjust.method.split(' '),\n\t\t\t\t    horizontal = method[0],\n\t\t\t\t    vertical = method[1] || method[0],\n\t\t\t\t    shift = { left: FALSE, top: FALSE, x: 0, y: 0 },\n\t\t\t\t    offset,\n\t\t\t\t    css = {},\n\t\t\t\t    props;\n\n\t\t\t\tfunction shiftflip(direction, precedance, popposite, side, opposite) {\n\t\t\t\t\t// Horizontal - Shift or flip method\n\t\t\t\t\tif (direction === SHIFT && newCorner.precedance === precedance && adjust[side] && newCorner[popposite] !== CENTER) {\n\t\t\t\t\t\tnewCorner.precedance = newCorner.precedance === X ? Y : X;\n\t\t\t\t\t} else if (direction !== SHIFT && adjust[side]) {\n\t\t\t\t\t\tnewCorner[precedance] = newCorner[precedance] === CENTER ? adjust[side] > 0 ? side : opposite : newCorner[precedance] === side ? opposite : side;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfunction shiftonly(xy, side, opposite) {\n\t\t\t\t\tif (newCorner[xy] === CENTER) {\n\t\t\t\t\t\tcss[MARGIN + '-' + side] = shift[xy] = offset[MARGIN + '-' + side] - adjust[side];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprops = offset[opposite] !== undefined ? [adjust[side], -offset[side]] : [-adjust[side], offset[side]];\n\n\t\t\t\t\t\tif ((shift[xy] = Math.max(props[0], props[1])) > props[0]) {\n\t\t\t\t\t\t\tpos[side] -= adjust[side];\n\t\t\t\t\t\t\tshift[side] = FALSE;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcss[offset[opposite] !== undefined ? opposite : side] = shift[xy];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// If our tip position isn't fixed e.g. doesn't adjust with viewport...\n\t\t\t\tif (this.corner.fixed !== TRUE) {\n\t\t\t\t\t// Perform shift/flip adjustments\n\t\t\t\t\tshiftflip(horizontal, X, Y, LEFT, RIGHT);\n\t\t\t\t\tshiftflip(vertical, Y, X, TOP, BOTTOM);\n\n\t\t\t\t\t// Update and redraw the tip if needed (check cached details of last drawn tip)\n\t\t\t\t\tif (newCorner.string() !== cache.corner.string() || cache.cornerTop !== adjust.top || cache.cornerLeft !== adjust.left) {\n\t\t\t\t\t\tthis.update(newCorner, FALSE);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Setup tip offset properties\n\t\t\t\toffset = this.calculate(newCorner);\n\n\t\t\t\t// Readjust offset object to make it left/top\n\t\t\t\tif (offset.right !== undefined) {\n\t\t\t\t\toffset.left = -offset.right;\n\t\t\t\t}\n\t\t\t\tif (offset.bottom !== undefined) {\n\t\t\t\t\toffset.top = -offset.bottom;\n\t\t\t\t}\n\t\t\t\toffset.user = this.offset;\n\n\t\t\t\t// Perform shift adjustments\n\t\t\t\tif (shift.left = horizontal === SHIFT && !!adjust.left) {\n\t\t\t\t\tshiftonly(X, LEFT, RIGHT);\n\t\t\t\t}\n\t\t\t\tif (shift.top = vertical === SHIFT && !!adjust.top) {\n\t\t\t\t\tshiftonly(Y, TOP, BOTTOM);\n\t\t\t\t}\n\n\t\t\t\t/*\n    * If the tip is adjusted in both dimensions, or in a\n    * direction that would cause it to be anywhere but the\n    * outer border, hide it!\n    */\n\t\t\t\tthis.element.css(css).toggle(!(shift.x && shift.y || newCorner.x === CENTER && shift.y || newCorner.y === CENTER && shift.x));\n\n\t\t\t\t// Adjust position to accomodate tip dimensions\n\t\t\t\tpos.left -= offset.left.charAt ? offset.user : horizontal !== SHIFT || shift.top || !shift.left && !shift.top ? offset.left + this.border : 0;\n\t\t\t\tpos.top -= offset.top.charAt ? offset.user : vertical !== SHIFT || shift.left || !shift.left && !shift.top ? offset.top + this.border : 0;\n\n\t\t\t\t// Cache details\n\t\t\t\tcache.cornerLeft = adjust.left;cache.cornerTop = adjust.top;\n\t\t\t\tcache.corner = newCorner.clone();\n\t\t\t},\n\n\t\t\tdestroy: function destroy() {\n\t\t\t\t// Unbind events\n\t\t\t\tthis.qtip._unbind(this.qtip.tooltip, this._ns);\n\n\t\t\t\t// Remove the tip element(s)\n\t\t\t\tif (this.qtip.elements.tip) {\n\t\t\t\t\tthis.qtip.elements.tip.find('*').remove().end().remove();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tTIP = PLUGINS.tip = function (api) {\n\t\t\treturn new Tip(api, api.options.style.tip);\n\t\t};\n\n\t\t// Initialize tip on render\n\t\tTIP.initialize = 'render';\n\n\t\t// Setup plugin sanitization options\n\t\tTIP.sanitize = function (options) {\n\t\t\tif (options.style && 'tip' in options.style) {\n\t\t\t\tvar opts = options.style.tip;\n\t\t\t\tif ((typeof opts === 'undefined' ? 'undefined' : _typeof(opts)) !== 'object') {\n\t\t\t\t\topts = options.style.tip = { corner: opts };\n\t\t\t\t}\n\t\t\t\tif (!/string|boolean/i.test(_typeof(opts.corner))) {\n\t\t\t\t\topts.corner = TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t// Add new option checks for the plugin\n\t\tCHECKS.tip = {\n\t\t\t'^position.my|style.tip.(corner|mimic|border)$': function positionMyStyleTipCornerMimicBorder$() {\n\t\t\t\t// Make sure a tip can be drawn\n\t\t\t\tthis.create();\n\n\t\t\t\t// Reposition the tooltip\n\t\t\t\tthis.qtip.reposition();\n\t\t\t},\n\t\t\t'^style.tip.(height|width)$': function styleTipHeightWidth$(obj) {\n\t\t\t\t// Re-set dimensions and redraw the tip\n\t\t\t\tthis.size = [obj.width, obj.height];\n\t\t\t\tthis.update();\n\n\t\t\t\t// Reposition the tooltip\n\t\t\t\tthis.qtip.reposition();\n\t\t\t},\n\t\t\t'^content.title|style.(classes|widget)$': function contentTitleStyleClassesWidget$() {\n\t\t\t\tthis.update();\n\t\t\t}\n\t\t};\n\n\t\t// Extend original qTip defaults\n\t\t$.extend(TRUE, QTIP.defaults, {\n\t\t\tstyle: {\n\t\t\t\ttip: {\n\t\t\t\t\tcorner: TRUE,\n\t\t\t\t\tmimic: FALSE,\n\t\t\t\t\twidth: 6,\n\t\t\t\t\theight: 6,\n\t\t\t\t\tborder: TRUE,\n\t\t\t\t\toffset: 0\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t;var MODAL,\n\t\t    OVERLAY,\n\t\t    MODALCLASS = 'qtip-modal',\n\t\t    MODALSELECTOR = '.' + MODALCLASS;\n\n\t\tOVERLAY = function OVERLAY() {\n\t\t\tvar self = this,\n\t\t\t    focusableElems = {},\n\t\t\t    current,\n\t\t\t    onLast,\n\t\t\t    prevState,\n\t\t\t    elem;\n\n\t\t\t// Modified code from jQuery UI 1.10.0 source\n\t\t\t// http://code.jquery.com/ui/1.10.0/jquery-ui.js\n\t\t\tfunction focusable(element) {\n\t\t\t\t// Use the defined focusable checker when possible\n\t\t\t\tif ($.expr[':'].focusable) {\n\t\t\t\t\treturn $.expr[':'].focusable;\n\t\t\t\t}\n\n\t\t\t\tvar isTabIndexNotNaN = !isNaN($.attr(element, 'tabindex')),\n\t\t\t\t    nodeName = element.nodeName && element.nodeName.toLowerCase(),\n\t\t\t\t    map,\n\t\t\t\t    mapName,\n\t\t\t\t    img;\n\n\t\t\t\tif ('area' === nodeName) {\n\t\t\t\t\tmap = element.parentNode;\n\t\t\t\t\tmapName = map.name;\n\t\t\t\t\tif (!element.href || !mapName || map.nodeName.toLowerCase() !== 'map') {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\timg = $('img[usemap=#' + mapName + ']')[0];\n\t\t\t\t\treturn !!img && img.is(':visible');\n\t\t\t\t}\n\t\t\t\treturn (/input|select|textarea|button|object/.test(nodeName) ? !element.disabled : 'a' === nodeName ? element.href || isTabIndexNotNaN : isTabIndexNotNaN\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Focus inputs using cached focusable elements (see update())\n\t\t\tfunction focusInputs(blurElems) {\n\t\t\t\t// Blurring body element in IE causes window.open windows to unfocus!\n\t\t\t\tif (focusableElems.length < 1 && blurElems.length) {\n\t\t\t\t\tblurElems.not('body').blur();\n\t\t\t\t}\n\n\t\t\t\t// Focus the inputs\n\t\t\t\telse {\n\t\t\t\t\t\tfocusableElems.first().focus();\n\t\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Steal focus from elements outside tooltip\n\t\t\tfunction stealFocus(event) {\n\t\t\t\tif (!elem.is(':visible')) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar target = $(event.target),\n\t\t\t\t    tooltip = current.tooltip,\n\t\t\t\t    container = target.closest(SELECTOR),\n\t\t\t\t    targetOnTop;\n\n\t\t\t\t// Determine if input container target is above this\n\t\t\t\ttargetOnTop = container.length < 1 ? FALSE : parseInt(container[0].style.zIndex, 10) > parseInt(tooltip[0].style.zIndex, 10);\n\n\t\t\t\t// If we're showing a modal, but focus has landed on an input below\n\t\t\t\t// this modal, divert focus to the first visible input in this modal\n\t\t\t\t// or if we can't find one... the tooltip itself\n\t\t\t\tif (!targetOnTop && target.closest(SELECTOR)[0] !== tooltip[0]) {\n\t\t\t\t\tfocusInputs(target);\n\t\t\t\t}\n\n\t\t\t\t// Detect when we leave the last focusable element...\n\t\t\t\tonLast = event.target === focusableElems[focusableElems.length - 1];\n\t\t\t}\n\n\t\t\t$.extend(self, {\n\t\t\t\tinit: function init() {\n\t\t\t\t\t// Create document overlay\n\t\t\t\t\telem = self.elem = $('<div />', {\n\t\t\t\t\t\tid: 'qtip-overlay',\n\t\t\t\t\t\thtml: '<div></div>',\n\t\t\t\t\t\tmousedown: function mousedown() {\n\t\t\t\t\t\t\treturn FALSE;\n\t\t\t\t\t\t}\n\t\t\t\t\t}).hide();\n\n\t\t\t\t\t// Make sure we can't focus anything outside the tooltip\n\t\t\t\t\t$(document.body).bind('focusin' + MODALSELECTOR, stealFocus);\n\n\t\t\t\t\t// Apply keyboard \"Escape key\" close handler\n\t\t\t\t\t$(document).bind('keydown' + MODALSELECTOR, function (event) {\n\t\t\t\t\t\tif (current && current.options.show.modal.escape && event.keyCode === 27) {\n\t\t\t\t\t\t\tcurrent.hide(event);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\t// Apply click handler for blur option\n\t\t\t\t\telem.bind('click' + MODALSELECTOR, function (event) {\n\t\t\t\t\t\tif (current && current.options.show.modal.blur) {\n\t\t\t\t\t\t\tcurrent.hide(event);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\treturn self;\n\t\t\t\t},\n\n\t\t\t\tupdate: function update(api) {\n\t\t\t\t\t// Update current API reference\n\t\t\t\t\tcurrent = api;\n\n\t\t\t\t\t// Update focusable elements if enabled\n\t\t\t\t\tif (api.options.show.modal.stealfocus !== FALSE) {\n\t\t\t\t\t\tfocusableElems = api.tooltip.find('*').filter(function () {\n\t\t\t\t\t\t\treturn focusable(this);\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfocusableElems = [];\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\ttoggle: function toggle(api, state, duration) {\n\t\t\t\t\tvar docBody = $(document.body),\n\t\t\t\t\t    tooltip = api.tooltip,\n\t\t\t\t\t    options = api.options.show.modal,\n\t\t\t\t\t    effect = options.effect,\n\t\t\t\t\t    type = state ? 'show' : 'hide',\n\t\t\t\t\t    visible = elem.is(':visible'),\n\t\t\t\t\t    visibleModals = $(MODALSELECTOR).filter(':visible:not(:animated)').not(tooltip),\n\t\t\t\t\t    zindex;\n\n\t\t\t\t\t// Set active tooltip API reference\n\t\t\t\t\tself.update(api);\n\n\t\t\t\t\t// If the modal can steal the focus...\n\t\t\t\t\t// Blur the current item and focus anything in the modal we an\n\t\t\t\t\tif (state && options.stealfocus !== FALSE) {\n\t\t\t\t\t\tfocusInputs($(':focus'));\n\t\t\t\t\t}\n\n\t\t\t\t\t// Toggle backdrop cursor style on show\n\t\t\t\t\telem.toggleClass('blurs', options.blur);\n\n\t\t\t\t\t// Append to body on show\n\t\t\t\t\tif (state) {\n\t\t\t\t\t\telem.appendTo(document.body);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prevent modal from conflicting with show.solo, and don't hide backdrop is other modals are visible\n\t\t\t\t\tif (elem.is(':animated') && visible === state && prevState !== FALSE || !state && visibleModals.length) {\n\t\t\t\t\t\treturn self;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Stop all animations\n\t\t\t\t\telem.stop(TRUE, FALSE);\n\n\t\t\t\t\t// Use custom function if provided\n\t\t\t\t\tif ($.isFunction(effect)) {\n\t\t\t\t\t\teffect.call(elem, state);\n\t\t\t\t\t}\n\n\t\t\t\t\t// If no effect type is supplied, use a simple toggle\n\t\t\t\t\telse if (effect === FALSE) {\n\t\t\t\t\t\t\telem[type]();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Use basic fade function\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\telem.fadeTo(parseInt(duration, 10) || 90, state ? 1 : 0, function () {\n\t\t\t\t\t\t\t\t\tif (!state) {\n\t\t\t\t\t\t\t\t\t\telem.hide();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t// Reset position and detach from body on hide\n\t\t\t\t\tif (!state) {\n\t\t\t\t\t\telem.queue(function (next) {\n\t\t\t\t\t\t\telem.css({ left: '', top: '' });\n\t\t\t\t\t\t\tif (!$(MODALSELECTOR).length) {\n\t\t\t\t\t\t\t\telem.detach();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnext();\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\t// Cache the state\n\t\t\t\t\tprevState = state;\n\n\t\t\t\t\t// If the tooltip is destroyed, set reference to null\n\t\t\t\t\tif (current.destroyed) {\n\t\t\t\t\t\tcurrent = NULL;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn self;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tself.init();\n\t\t};\n\t\tOVERLAY = new OVERLAY();\n\n\t\tfunction Modal(api, options) {\n\t\t\tthis.options = options;\n\t\t\tthis._ns = '-modal';\n\n\t\t\tthis.init(this.qtip = api);\n\t\t}\n\n\t\t$.extend(Modal.prototype, {\n\t\t\tinit: function init(qtip) {\n\t\t\t\tvar tooltip = qtip.tooltip;\n\n\t\t\t\t// If modal is disabled... return\n\t\t\t\tif (!this.options.on) {\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t\t// Set overlay reference\n\t\t\t\tqtip.elements.overlay = OVERLAY.elem;\n\n\t\t\t\t// Add unique attribute so we can grab modal tooltips easily via a SELECTOR, and set z-index\n\t\t\t\ttooltip.addClass(MODALCLASS).css('z-index', QTIP.modal_zindex + $(MODALSELECTOR).length);\n\n\t\t\t\t// Apply our show/hide/focus modal events\n\t\t\t\tqtip._bind(tooltip, ['tooltipshow', 'tooltiphide'], function (event, api, duration) {\n\t\t\t\t\tvar oEvent = event.originalEvent;\n\n\t\t\t\t\t// Make sure mouseout doesn't trigger a hide when showing the modal and mousing onto backdrop\n\t\t\t\t\tif (event.target === tooltip[0]) {\n\t\t\t\t\t\tif (oEvent && event.type === 'tooltiphide' && /mouse(leave|enter)/.test(oEvent.type) && $(oEvent.relatedTarget).closest(OVERLAY.elem[0]).length) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\t} catch (e) {}\n\t\t\t\t\t\t} else if (!oEvent || oEvent && oEvent.type !== 'tooltipsolo') {\n\t\t\t\t\t\t\tthis.toggle(event, event.type === 'tooltipshow', duration);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}, this._ns, this);\n\n\t\t\t\t// Adjust modal z-index on tooltip focus\n\t\t\t\tqtip._bind(tooltip, 'tooltipfocus', function (event, api) {\n\t\t\t\t\t// If focus was cancelled before it reached us, don't do anything\n\t\t\t\t\tif (event.isDefaultPrevented() || event.target !== tooltip[0]) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar qtips = $(MODALSELECTOR),\n\n\n\t\t\t\t\t// Keep the modal's lower than other, regular qtips\n\t\t\t\t\tnewIndex = QTIP.modal_zindex + qtips.length,\n\t\t\t\t\t    curIndex = parseInt(tooltip[0].style.zIndex, 10);\n\n\t\t\t\t\t// Set overlay z-index\n\t\t\t\t\tOVERLAY.elem[0].style.zIndex = newIndex - 1;\n\n\t\t\t\t\t// Reduce modal z-index's and keep them properly ordered\n\t\t\t\t\tqtips.each(function () {\n\t\t\t\t\t\tif (this.style.zIndex > curIndex) {\n\t\t\t\t\t\t\tthis.style.zIndex -= 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\t// Fire blur event for focused tooltip\n\t\t\t\t\tqtips.filter('.' + CLASS_FOCUS).qtip('blur', event.originalEvent);\n\n\t\t\t\t\t// Set the new z-index\n\t\t\t\t\ttooltip.addClass(CLASS_FOCUS)[0].style.zIndex = newIndex;\n\n\t\t\t\t\t// Set current\n\t\t\t\t\tOVERLAY.update(api);\n\n\t\t\t\t\t// Prevent default handling\n\t\t\t\t\ttry {\n\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t} catch (e) {}\n\t\t\t\t}, this._ns, this);\n\n\t\t\t\t// Focus any other visible modals when this one hides\n\t\t\t\tqtip._bind(tooltip, 'tooltiphide', function (event) {\n\t\t\t\t\tif (event.target === tooltip[0]) {\n\t\t\t\t\t\t$(MODALSELECTOR).filter(':visible').not(tooltip).last().qtip('focus', event);\n\t\t\t\t\t}\n\t\t\t\t}, this._ns, this);\n\t\t\t},\n\n\t\t\ttoggle: function toggle(event, state, duration) {\n\t\t\t\t// Make sure default event hasn't been prevented\n\t\t\t\tif (event && event.isDefaultPrevented()) {\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t\t// Toggle it\n\t\t\t\tOVERLAY.toggle(this.qtip, !!state, duration);\n\t\t\t},\n\n\t\t\tdestroy: function destroy() {\n\t\t\t\t// Remove modal class\n\t\t\t\tthis.qtip.tooltip.removeClass(MODALCLASS);\n\n\t\t\t\t// Remove bound events\n\t\t\t\tthis.qtip._unbind(this.qtip.tooltip, this._ns);\n\n\t\t\t\t// Delete element reference\n\t\t\t\tOVERLAY.toggle(this.qtip, FALSE);\n\t\t\t\tdelete this.qtip.elements.overlay;\n\t\t\t}\n\t\t});\n\n\t\tMODAL = PLUGINS.modal = function (api) {\n\t\t\treturn new Modal(api, api.options.show.modal);\n\t\t};\n\n\t\t// Setup sanitiztion rules\n\t\tMODAL.sanitize = function (opts) {\n\t\t\tif (opts.show) {\n\t\t\t\tif (_typeof(opts.show.modal) !== 'object') {\n\t\t\t\t\topts.show.modal = { on: !!opts.show.modal };\n\t\t\t\t} else if (typeof opts.show.modal.on === 'undefined') {\n\t\t\t\t\topts.show.modal.on = TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t// Base z-index for all modal tooltips (use qTip core z-index as a base)\n\t\tQTIP.modal_zindex = QTIP.zindex - 200;\n\n\t\t// Plugin needs to be initialized on render\n\t\tMODAL.initialize = 'render';\n\n\t\t// Setup option set checks\n\t\tCHECKS.modal = {\n\t\t\t'^show.modal.(on|blur)$': function showModalOnBlur$() {\n\t\t\t\t// Initialise\n\t\t\t\tthis.destroy();\n\t\t\t\tthis.init();\n\n\t\t\t\t// Show the modal if not visible already and tooltip is visible\n\t\t\t\tthis.qtip.elems.overlay.toggle(this.qtip.tooltip[0].offsetWidth > 0);\n\t\t\t}\n\t\t};\n\n\t\t// Extend original api defaults\n\t\t$.extend(TRUE, QTIP.defaults, {\n\t\t\tshow: {\n\t\t\t\tmodal: {\n\t\t\t\t\ton: FALSE,\n\t\t\t\t\teffect: TRUE,\n\t\t\t\t\tblur: TRUE,\n\t\t\t\t\tstealfocus: TRUE,\n\t\t\t\t\tescape: TRUE\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t;PLUGINS.viewport = function (api, position, posOptions, targetWidth, targetHeight, elemWidth, elemHeight) {\n\t\t\tvar target = posOptions.target,\n\t\t\t    tooltip = api.elements.tooltip,\n\t\t\t    my = posOptions.my,\n\t\t\t    at = posOptions.at,\n\t\t\t    adjust = posOptions.adjust,\n\t\t\t    method = adjust.method.split(' '),\n\t\t\t    methodX = method[0],\n\t\t\t    methodY = method[1] || method[0],\n\t\t\t    viewport = posOptions.viewport,\n\t\t\t    container = posOptions.container,\n\t\t\t    cache = api.cache,\n\t\t\t    adjusted = { left: 0, top: 0 },\n\t\t\t    fixed,\n\t\t\t    newMy,\n\t\t\t    containerOffset,\n\t\t\t    containerStatic,\n\t\t\t    viewportWidth,\n\t\t\t    viewportHeight,\n\t\t\t    viewportScroll,\n\t\t\t    viewportOffset;\n\n\t\t\t// If viewport is not a jQuery element, or it's the window/document, or no adjustment method is used... return\n\t\t\tif (!viewport.jquery || target[0] === window || target[0] === document.body || adjust.method === 'none') {\n\t\t\t\treturn adjusted;\n\t\t\t}\n\n\t\t\t// Cach container details\n\t\t\tcontainerOffset = container.offset() || adjusted;\n\t\t\tcontainerStatic = container.css('position') === 'static';\n\n\t\t\t// Cache our viewport details\n\t\t\tfixed = tooltip.css('position') === 'fixed';\n\t\t\tviewportWidth = viewport[0] === window ? viewport.width() : viewport.outerWidth(FALSE);\n\t\t\tviewportHeight = viewport[0] === window ? viewport.height() : viewport.outerHeight(FALSE);\n\t\t\tviewportScroll = { left: fixed ? 0 : viewport.scrollLeft(), top: fixed ? 0 : viewport.scrollTop() };\n\t\t\tviewportOffset = viewport.offset() || adjusted;\n\n\t\t\t// Generic calculation method\n\t\t\tfunction calculate(side, otherSide, type, adjust, side1, side2, lengthName, targetLength, elemLength) {\n\t\t\t\tvar initialPos = position[side1],\n\t\t\t\t    mySide = my[side],\n\t\t\t\t    atSide = at[side],\n\t\t\t\t    isShift = type === SHIFT,\n\t\t\t\t    myLength = mySide === side1 ? elemLength : mySide === side2 ? -elemLength : -elemLength / 2,\n\t\t\t\t    atLength = atSide === side1 ? targetLength : atSide === side2 ? -targetLength : -targetLength / 2,\n\t\t\t\t    sideOffset = viewportScroll[side1] + viewportOffset[side1] - (containerStatic ? 0 : containerOffset[side1]),\n\t\t\t\t    overflow1 = sideOffset - initialPos,\n\t\t\t\t    overflow2 = initialPos + elemLength - (lengthName === WIDTH ? viewportWidth : viewportHeight) - sideOffset,\n\t\t\t\t    offset = myLength - (my.precedance === side || mySide === my[otherSide] ? atLength : 0) - (atSide === CENTER ? targetLength / 2 : 0);\n\n\t\t\t\t// shift\n\t\t\t\tif (isShift) {\n\t\t\t\t\toffset = (mySide === side1 ? 1 : -1) * myLength;\n\n\t\t\t\t\t// Adjust position but keep it within viewport dimensions\n\t\t\t\t\tposition[side1] += overflow1 > 0 ? overflow1 : overflow2 > 0 ? -overflow2 : 0;\n\t\t\t\t\tposition[side1] = Math.max(-containerOffset[side1] + viewportOffset[side1], initialPos - offset, Math.min(Math.max(-containerOffset[side1] + viewportOffset[side1] + (lengthName === WIDTH ? viewportWidth : viewportHeight), initialPos + offset), position[side1],\n\n\t\t\t\t\t// Make sure we don't adjust complete off the element when using 'center'\n\t\t\t\t\tmySide === 'center' ? initialPos - myLength : 1E9));\n\t\t\t\t}\n\n\t\t\t\t// flip/flipinvert\n\t\t\t\telse {\n\t\t\t\t\t\t// Update adjustment amount depending on if using flipinvert or flip\n\t\t\t\t\t\tadjust *= type === FLIPINVERT ? 2 : 0;\n\n\t\t\t\t\t\t// Check for overflow on the left/top\n\t\t\t\t\t\tif (overflow1 > 0 && (mySide !== side1 || overflow2 > 0)) {\n\t\t\t\t\t\t\tposition[side1] -= offset + adjust;\n\t\t\t\t\t\t\tnewMy.invert(side, side1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Check for overflow on the bottom/right\n\t\t\t\t\t\telse if (overflow2 > 0 && (mySide !== side2 || overflow1 > 0)) {\n\t\t\t\t\t\t\t\tposition[side1] -= (mySide === CENTER ? -offset : offset) + adjust;\n\t\t\t\t\t\t\t\tnewMy.invert(side, side2);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Make sure we haven't made things worse with the adjustment and reset if so\n\t\t\t\t\t\tif (position[side1] < viewportScroll && -position[side1] > overflow2) {\n\t\t\t\t\t\t\tposition[side1] = initialPos;newMy = my.clone();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\treturn position[side1] - initialPos;\n\t\t\t}\n\n\t\t\t// Set newMy if using flip or flipinvert methods\n\t\t\tif (methodX !== 'shift' || methodY !== 'shift') {\n\t\t\t\tnewMy = my.clone();\n\t\t\t}\n\n\t\t\t// Adjust position based onviewport and adjustment options\n\t\t\tadjusted = {\n\t\t\t\tleft: methodX !== 'none' ? calculate(X, Y, methodX, adjust.x, LEFT, RIGHT, WIDTH, targetWidth, elemWidth) : 0,\n\t\t\t\ttop: methodY !== 'none' ? calculate(Y, X, methodY, adjust.y, TOP, BOTTOM, HEIGHT, targetHeight, elemHeight) : 0,\n\t\t\t\tmy: newMy\n\t\t\t};\n\n\t\t\treturn adjusted;\n\t\t};\n\t\t;PLUGINS.polys = {\n\t\t\t// POLY area coordinate calculator\n\t\t\t//\tSpecial thanks to Ed Cradock for helping out with this.\n\t\t\t//\tUses a binary search algorithm to find suitable coordinates.\n\t\t\tpolygon: function polygon(baseCoords, corner) {\n\t\t\t\tvar result = {\n\t\t\t\t\twidth: 0, height: 0,\n\t\t\t\t\tposition: {\n\t\t\t\t\t\ttop: 1e10, right: 0,\n\t\t\t\t\t\tbottom: 0, left: 1e10\n\t\t\t\t\t},\n\t\t\t\t\tadjustable: FALSE\n\t\t\t\t},\n\t\t\t\t    i = 0,\n\t\t\t\t    next,\n\t\t\t\t    coords = [],\n\t\t\t\t    compareX = 1,\n\t\t\t\t    compareY = 1,\n\t\t\t\t    realX = 0,\n\t\t\t\t    realY = 0,\n\t\t\t\t    newWidth,\n\t\t\t\t    newHeight;\n\n\t\t\t\t// First pass, sanitize coords and determine outer edges\n\t\t\t\ti = baseCoords.length;while (i--) {\n\t\t\t\t\tnext = [parseInt(baseCoords[--i], 10), parseInt(baseCoords[i + 1], 10)];\n\n\t\t\t\t\tif (next[0] > result.position.right) {\n\t\t\t\t\t\tresult.position.right = next[0];\n\t\t\t\t\t}\n\t\t\t\t\tif (next[0] < result.position.left) {\n\t\t\t\t\t\tresult.position.left = next[0];\n\t\t\t\t\t}\n\t\t\t\t\tif (next[1] > result.position.bottom) {\n\t\t\t\t\t\tresult.position.bottom = next[1];\n\t\t\t\t\t}\n\t\t\t\t\tif (next[1] < result.position.top) {\n\t\t\t\t\t\tresult.position.top = next[1];\n\t\t\t\t\t}\n\n\t\t\t\t\tcoords.push(next);\n\t\t\t\t}\n\n\t\t\t\t// Calculate height and width from outer edges\n\t\t\t\tnewWidth = result.width = Math.abs(result.position.right - result.position.left);\n\t\t\t\tnewHeight = result.height = Math.abs(result.position.bottom - result.position.top);\n\n\t\t\t\t// If it's the center corner...\n\t\t\t\tif (corner.abbrev() === 'c') {\n\t\t\t\t\tresult.position = {\n\t\t\t\t\t\tleft: result.position.left + result.width / 2,\n\t\t\t\t\t\ttop: result.position.top + result.height / 2\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\t// Second pass, use a binary search algorithm to locate most suitable coordinate\n\t\t\t\t\twhile (newWidth > 0 && newHeight > 0 && compareX > 0 && compareY > 0) {\n\t\t\t\t\t\tnewWidth = Math.floor(newWidth / 2);\n\t\t\t\t\t\tnewHeight = Math.floor(newHeight / 2);\n\n\t\t\t\t\t\tif (corner.x === LEFT) {\n\t\t\t\t\t\t\tcompareX = newWidth;\n\t\t\t\t\t\t} else if (corner.x === RIGHT) {\n\t\t\t\t\t\t\tcompareX = result.width - newWidth;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcompareX += Math.floor(newWidth / 2);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (corner.y === TOP) {\n\t\t\t\t\t\t\tcompareY = newHeight;\n\t\t\t\t\t\t} else if (corner.y === BOTTOM) {\n\t\t\t\t\t\t\tcompareY = result.height - newHeight;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcompareY += Math.floor(newHeight / 2);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ti = coords.length;while (i--) {\n\t\t\t\t\t\t\tif (coords.length < 2) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\trealX = coords[i][0] - result.position.left;\n\t\t\t\t\t\t\trealY = coords[i][1] - result.position.top;\n\n\t\t\t\t\t\t\tif (corner.x === LEFT && realX >= compareX || corner.x === RIGHT && realX <= compareX || corner.x === CENTER && (realX < compareX || realX > result.width - compareX) || corner.y === TOP && realY >= compareY || corner.y === BOTTOM && realY <= compareY || corner.y === CENTER && (realY < compareY || realY > result.height - compareY)) {\n\t\t\t\t\t\t\t\tcoords.splice(i, 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tresult.position = { left: coords[0][0], top: coords[0][1] };\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t},\n\n\t\t\trect: function rect(ax, ay, bx, by) {\n\t\t\t\treturn {\n\t\t\t\t\twidth: Math.abs(bx - ax),\n\t\t\t\t\theight: Math.abs(by - ay),\n\t\t\t\t\tposition: {\n\t\t\t\t\t\tleft: Math.min(ax, bx),\n\t\t\t\t\t\ttop: Math.min(ay, by)\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t},\n\n\t\t\t_angles: {\n\t\t\t\ttc: 3 / 2, tr: 7 / 4, tl: 5 / 4,\n\t\t\t\tbc: 1 / 2, br: 1 / 4, bl: 3 / 4,\n\t\t\t\trc: 2, lc: 1, c: 0\n\t\t\t},\n\t\t\tellipse: function ellipse(cx, cy, rx, ry, corner) {\n\t\t\t\tvar c = PLUGINS.polys._angles[corner.abbrev()],\n\t\t\t\t    rxc = c === 0 ? 0 : rx * Math.cos(c * Math.PI),\n\t\t\t\t    rys = ry * Math.sin(c * Math.PI);\n\n\t\t\t\treturn {\n\t\t\t\t\twidth: rx * 2 - Math.abs(rxc),\n\t\t\t\t\theight: ry * 2 - Math.abs(rys),\n\t\t\t\t\tposition: {\n\t\t\t\t\t\tleft: cx + rxc,\n\t\t\t\t\t\ttop: cy + rys\n\t\t\t\t\t},\n\t\t\t\t\tadjustable: FALSE\n\t\t\t\t};\n\t\t\t},\n\t\t\tcircle: function circle(cx, cy, r, corner) {\n\t\t\t\treturn PLUGINS.polys.ellipse(cx, cy, r, r, corner);\n\t\t\t}\n\t\t};\n\t\t;PLUGINS.svg = function (api, svg, corner) {\n\t\t\tvar doc = $(document),\n\t\t\t    elem = svg[0],\n\t\t\t    root = $(elem.ownerSVGElement),\n\t\t\t    ownerDocument = elem.ownerDocument,\n\t\t\t    strokeWidth2 = (parseInt(svg.css('stroke-width'), 10) || 0) / 2,\n\t\t\t    frameOffset,\n\t\t\t    mtx,\n\t\t\t    transformed,\n\t\t\t    viewBox,\n\t\t\t    len,\n\t\t\t    next,\n\t\t\t    i,\n\t\t\t    points,\n\t\t\t    result,\n\t\t\t    position,\n\t\t\t    dimensions;\n\n\t\t\t// Ascend the parentNode chain until we find an element with getBBox()\n\t\t\twhile (!elem.getBBox) {\n\t\t\t\telem = elem.parentNode;\n\t\t\t}\n\t\t\tif (!elem.getBBox || !elem.parentNode) {\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\t// Determine which shape calculation to use\n\t\t\tswitch (elem.nodeName) {\n\t\t\t\tcase 'ellipse':\n\t\t\t\tcase 'circle':\n\t\t\t\t\tresult = PLUGINS.polys.ellipse(elem.cx.baseVal.value, elem.cy.baseVal.value, (elem.rx || elem.r).baseVal.value + strokeWidth2, (elem.ry || elem.r).baseVal.value + strokeWidth2, corner);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'line':\n\t\t\t\tcase 'polygon':\n\t\t\t\tcase 'polyline':\n\t\t\t\t\t// Determine points object (line has none, so mimic using array)\n\t\t\t\t\tpoints = elem.points || [{ x: elem.x1.baseVal.value, y: elem.y1.baseVal.value }, { x: elem.x2.baseVal.value, y: elem.y2.baseVal.value }];\n\n\t\t\t\t\tfor (result = [], i = -1, len = points.numberOfItems || points.length; ++i < len;) {\n\t\t\t\t\t\tnext = points.getItem ? points.getItem(i) : points[i];\n\t\t\t\t\t\tresult.push.apply(result, [next.x, next.y]);\n\t\t\t\t\t}\n\n\t\t\t\t\tresult = PLUGINS.polys.polygon(result, corner);\n\t\t\t\t\tbreak;\n\n\t\t\t\t// Unknown shape or rectangle? Use bounding box\n\t\t\t\tdefault:\n\t\t\t\t\tresult = elem.getBBox();\n\t\t\t\t\tresult = {\n\t\t\t\t\t\twidth: result.width,\n\t\t\t\t\t\theight: result.height,\n\t\t\t\t\t\tposition: {\n\t\t\t\t\t\t\tleft: result.x,\n\t\t\t\t\t\t\ttop: result.y\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Shortcut assignments\n\t\t\tposition = result.position;\n\t\t\troot = root[0];\n\n\t\t\t// Convert position into a pixel value\n\t\t\tif (root.createSVGPoint) {\n\t\t\t\tmtx = elem.getScreenCTM();\n\t\t\t\tpoints = root.createSVGPoint();\n\n\t\t\t\tpoints.x = position.left;\n\t\t\t\tpoints.y = position.top;\n\t\t\t\ttransformed = points.matrixTransform(mtx);\n\t\t\t\tposition.left = transformed.x;\n\t\t\t\tposition.top = transformed.y;\n\t\t\t}\n\n\t\t\t// Check the element is not in a child document, and if so, adjust for frame elements offset\n\t\t\tif (ownerDocument !== document && api.position.target !== 'mouse') {\n\t\t\t\tframeOffset = $((ownerDocument.defaultView || ownerDocument.parentWindow).frameElement).offset();\n\t\t\t\tif (frameOffset) {\n\t\t\t\t\tposition.left += frameOffset.left;\n\t\t\t\t\tposition.top += frameOffset.top;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Adjust by scroll offset of owner document\n\t\t\townerDocument = $(ownerDocument);\n\t\t\tposition.left += ownerDocument.scrollLeft();\n\t\t\tposition.top += ownerDocument.scrollTop();\n\n\t\t\treturn result;\n\t\t};\n\t\t;PLUGINS.imagemap = function (api, area, corner, adjustMethod) {\n\t\t\tif (!area.jquery) {\n\t\t\t\tarea = $(area);\n\t\t\t}\n\n\t\t\tvar shape = (area.attr('shape') || 'rect').toLowerCase().replace('poly', 'polygon'),\n\t\t\t    image = $('img[usemap=\"#' + area.parent('map').attr('name') + '\"]'),\n\t\t\t    coordsString = $.trim(area.attr('coords')),\n\t\t\t    coordsArray = coordsString.replace(/,$/, '').split(','),\n\t\t\t    imageOffset,\n\t\t\t    coords,\n\t\t\t    i,\n\t\t\t    next,\n\t\t\t    result,\n\t\t\t    len;\n\n\t\t\t// If we can't find the image using the map...\n\t\t\tif (!image.length) {\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\t// Pass coordinates string if polygon\n\t\t\tif (shape === 'polygon') {\n\t\t\t\tresult = PLUGINS.polys.polygon(coordsArray, corner);\n\t\t\t}\n\n\t\t\t// Otherwise parse the coordinates and pass them as arguments\n\t\t\telse if (PLUGINS.polys[shape]) {\n\t\t\t\t\tfor (i = -1, len = coordsArray.length, coords = []; ++i < len;) {\n\t\t\t\t\t\tcoords.push(parseInt(coordsArray[i], 10));\n\t\t\t\t\t}\n\n\t\t\t\t\tresult = PLUGINS.polys[shape].apply(this, coords.concat(corner));\n\t\t\t\t}\n\n\t\t\t\t// If no shapre calculation method was found, return false\n\t\t\t\telse {\n\t\t\t\t\t\treturn FALSE;\n\t\t\t\t\t}\n\n\t\t\t// Make sure we account for padding and borders on the image\n\t\t\timageOffset = image.offset();\n\t\t\timageOffset.left += Math.ceil((image.outerWidth(FALSE) - image.width()) / 2);\n\t\t\timageOffset.top += Math.ceil((image.outerHeight(FALSE) - image.height()) / 2);\n\n\t\t\t// Add image position to offset coordinates\n\t\t\tresult.position.left += imageOffset.left;\n\t\t\tresult.position.top += imageOffset.top;\n\n\t\t\treturn result;\n\t\t};\n\t\t;var IE6,\n\n\n\t\t/*\n   * BGIFrame adaption (http://plugins.jquery.com/project/bgiframe)\n   * Special thanks to Brandon Aaron\n   */\n\t\tBGIFRAME = '<iframe class=\"qtip-bgiframe\" frameborder=\"0\" tabindex=\"-1\" src=\"javascript:\\'\\';\" ' + ' style=\"display:block; position:absolute; z-index:-1; filter:alpha(opacity=0); ' + '-ms-filter:\"progid:DXImageTransform.Microsoft.Alpha(Opacity=0)\";\"></iframe>';\n\n\t\tfunction Ie6(api, qtip) {\n\t\t\tthis._ns = 'ie6';\n\t\t\tthis.init(this.qtip = api);\n\t\t}\n\n\t\t$.extend(Ie6.prototype, {\n\t\t\t_scroll: function _scroll() {\n\t\t\t\tvar overlay = this.qtip.elements.overlay;\n\t\t\t\toverlay && (overlay[0].style.top = $(window).scrollTop() + 'px');\n\t\t\t},\n\n\t\t\tinit: function init(qtip) {\n\t\t\t\tvar tooltip = qtip.tooltip,\n\t\t\t\t    scroll;\n\n\t\t\t\t// Create the BGIFrame element if needed\n\t\t\t\tif ($('select, object').length < 1) {\n\t\t\t\t\tthis.bgiframe = qtip.elements.bgiframe = $(BGIFRAME).appendTo(tooltip);\n\n\t\t\t\t\t// Update BGIFrame on tooltip move\n\t\t\t\t\tqtip._bind(tooltip, 'tooltipmove', this.adjustBGIFrame, this._ns, this);\n\t\t\t\t}\n\n\t\t\t\t// redraw() container for width/height calculations\n\t\t\t\tthis.redrawContainer = $('<div/>', { id: NAMESPACE + '-rcontainer' }).appendTo(document.body);\n\n\t\t\t\t// Fixup modal plugin if present too\n\t\t\t\tif (qtip.elements.overlay && qtip.elements.overlay.addClass('qtipmodal-ie6fix')) {\n\t\t\t\t\tqtip._bind(window, ['scroll', 'resize'], this._scroll, this._ns, this);\n\t\t\t\t\tqtip._bind(tooltip, ['tooltipshow'], this._scroll, this._ns, this);\n\t\t\t\t}\n\n\t\t\t\t// Set dimensions\n\t\t\t\tthis.redraw();\n\t\t\t},\n\n\t\t\tadjustBGIFrame: function adjustBGIFrame() {\n\t\t\t\tvar tooltip = this.qtip.tooltip,\n\t\t\t\t    dimensions = {\n\t\t\t\t\theight: tooltip.outerHeight(FALSE),\n\t\t\t\t\twidth: tooltip.outerWidth(FALSE)\n\t\t\t\t},\n\t\t\t\t    plugin = this.qtip.plugins.tip,\n\t\t\t\t    tip = this.qtip.elements.tip,\n\t\t\t\t    tipAdjust,\n\t\t\t\t    offset;\n\n\t\t\t\t// Adjust border offset\n\t\t\t\toffset = parseInt(tooltip.css('borderLeftWidth'), 10) || 0;\n\t\t\t\toffset = { left: -offset, top: -offset };\n\n\t\t\t\t// Adjust for tips plugin\n\t\t\t\tif (plugin && tip) {\n\t\t\t\t\ttipAdjust = plugin.corner.precedance === 'x' ? [WIDTH, LEFT] : [HEIGHT, TOP];\n\t\t\t\t\toffset[tipAdjust[1]] -= tip[tipAdjust[0]]();\n\t\t\t\t}\n\n\t\t\t\t// Update bgiframe\n\t\t\t\tthis.bgiframe.css(offset).css(dimensions);\n\t\t\t},\n\n\t\t\t// Max/min width simulator function\n\t\t\tredraw: function redraw() {\n\t\t\t\tif (this.qtip.rendered < 1 || this.drawing) {\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t\tvar tooltip = this.qtip.tooltip,\n\t\t\t\t    style = this.qtip.options.style,\n\t\t\t\t    container = this.qtip.options.position.container,\n\t\t\t\t    perc,\n\t\t\t\t    width,\n\t\t\t\t    max,\n\t\t\t\t    min;\n\n\t\t\t\t// Set drawing flag\n\t\t\t\tthis.qtip.drawing = 1;\n\n\t\t\t\t// If tooltip has a set height/width, just set it... like a boss!\n\t\t\t\tif (style.height) {\n\t\t\t\t\ttooltip.css(HEIGHT, style.height);\n\t\t\t\t}\n\t\t\t\tif (style.width) {\n\t\t\t\t\ttooltip.css(WIDTH, style.width);\n\t\t\t\t}\n\n\t\t\t\t// Simulate max/min width if not set width present...\n\t\t\t\telse {\n\t\t\t\t\t\t// Reset width and add fluid class\n\t\t\t\t\t\ttooltip.css(WIDTH, '').appendTo(this.redrawContainer);\n\n\t\t\t\t\t\t// Grab our tooltip width (add 1 if odd so we don't get wrapping problems.. huzzah!)\n\t\t\t\t\t\twidth = tooltip.width();\n\t\t\t\t\t\tif (width % 2 < 1) {\n\t\t\t\t\t\t\twidth += 1;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Grab our max/min properties\n\t\t\t\t\t\tmax = tooltip.css('maxWidth') || '';\n\t\t\t\t\t\tmin = tooltip.css('minWidth') || '';\n\n\t\t\t\t\t\t// Parse into proper pixel values\n\t\t\t\t\t\tperc = (max + min).indexOf('%') > -1 ? container.width() / 100 : 0;\n\t\t\t\t\t\tmax = (max.indexOf('%') > -1 ? perc : 1) * parseInt(max, 10) || width;\n\t\t\t\t\t\tmin = (min.indexOf('%') > -1 ? perc : 1) * parseInt(min, 10) || 0;\n\n\t\t\t\t\t\t// Determine new dimension size based on max/min/current values\n\t\t\t\t\t\twidth = max + min ? Math.min(Math.max(width, min), max) : width;\n\n\t\t\t\t\t\t// Set the newly calculated width and remvoe fluid class\n\t\t\t\t\t\ttooltip.css(WIDTH, Math.round(width)).appendTo(container);\n\t\t\t\t\t}\n\n\t\t\t\t// Set drawing flag\n\t\t\t\tthis.drawing = 0;\n\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\tdestroy: function destroy() {\n\t\t\t\t// Remove iframe\n\t\t\t\tthis.bgiframe && this.bgiframe.remove();\n\n\t\t\t\t// Remove bound events\n\t\t\t\tthis.qtip._unbind([window, this.qtip.tooltip], this._ns);\n\t\t\t}\n\t\t});\n\n\t\tIE6 = PLUGINS.ie6 = function (api) {\n\t\t\t// Proceed only if the browser is IE6\n\t\t\treturn BROWSER.ie === 6 ? new Ie6(api) : FALSE;\n\t\t};\n\n\t\tIE6.initialize = 'render';\n\n\t\tCHECKS.ie6 = {\n\t\t\t'^content|style$': function contentStyle$() {\n\t\t\t\tthis.redraw();\n\t\t\t}\n\t\t};\n\t\t;\n\t});\n})(window, document);"

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./node_modules/babel-loader/lib/index.js??ref--0-0!./assets/js/jquery.ui-1.11.4.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/raw-loader!./node_modules/babel-loader/lib??ref--0-0!./assets/js/jquery.ui-1.11.4.js ***!
  \***********************************************************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports) {

module.exports = "var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/*! jQuery UI - v1.11.4 - 2015-03-11\n* http://jqueryui.com\n* Includes: core.js, widget.js, mouse.js, position.js, accordion.js, autocomplete.js, button.js, datepicker.js, dialog.js, draggable.js, droppable.js, effect.js, effect-blind.js, effect-bounce.js, effect-clip.js, effect-drop.js, effect-explode.js, effect-fade.js, effect-fold.js, effect-highlight.js, effect-puff.js, effect-pulsate.js, effect-scale.js, effect-shake.js, effect-size.js, effect-slide.js, effect-transfer.js, menu.js, progressbar.js, resizable.js, selectable.js, selectmenu.js, slider.js, sortable.js, spinner.js, tabs.js, tooltip.js\n* Copyright 2015 jQuery Foundation and other contributors; Licensed MIT */\n\n(function (factory) {\n\tif (typeof define === \"function\" && define.amd) {\n\n\t\t// AMD. Register as an anonymous module.\n\t\tdefine([\"jquery\"], factory);\n\t} else {\n\n\t\t// Browser globals\n\t\tfactory(jQuery);\n\t}\n})(function ($) {\n\t/*!\n  * jQuery UI Core 1.11.4\n  * http://jqueryui.com\n  *\n  * Copyright jQuery Foundation and other contributors\n  * Released under the MIT license.\n  * http://jquery.org/license\n  *\n  * http://api.jqueryui.com/category/ui-core/\n  */\n\n\t// $.ui might exist from components with no dependencies, e.g., $.ui.position\n\t$.ui = $.ui || {};\n\n\t$.extend($.ui, {\n\t\tversion: \"1.11.4\",\n\n\t\tkeyCode: {\n\t\t\tBACKSPACE: 8,\n\t\t\tCOMMA: 188,\n\t\t\tDELETE: 46,\n\t\t\tDOWN: 40,\n\t\t\tEND: 35,\n\t\t\tENTER: 13,\n\t\t\tESCAPE: 27,\n\t\t\tHOME: 36,\n\t\t\tLEFT: 37,\n\t\t\tPAGE_DOWN: 34,\n\t\t\tPAGE_UP: 33,\n\t\t\tPERIOD: 190,\n\t\t\tRIGHT: 39,\n\t\t\tSPACE: 32,\n\t\t\tTAB: 9,\n\t\t\tUP: 38\n\t\t}\n\t});\n\n\t// plugins\n\t$.fn.extend({\n\t\tscrollParent: function scrollParent(includeHidden) {\n\t\t\tvar position = this.css(\"position\"),\n\t\t\t    excludeStaticParent = position === \"absolute\",\n\t\t\t    overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/,\n\t\t\t    scrollParent = this.parents().filter(function () {\n\t\t\t\tvar parent = $(this);\n\t\t\t\tif (excludeStaticParent && parent.css(\"position\") === \"static\") {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn overflowRegex.test(parent.css(\"overflow\") + parent.css(\"overflow-y\") + parent.css(\"overflow-x\"));\n\t\t\t}).eq(0);\n\n\t\t\treturn position === \"fixed\" || !scrollParent.length ? $(this[0].ownerDocument || document) : scrollParent;\n\t\t},\n\n\t\tuniqueId: function () {\n\t\t\tvar uuid = 0;\n\n\t\t\treturn function () {\n\t\t\t\treturn this.each(function () {\n\t\t\t\t\tif (!this.id) {\n\t\t\t\t\t\tthis.id = \"ui-id-\" + ++uuid;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t};\n\t\t}(),\n\n\t\tremoveUniqueId: function removeUniqueId() {\n\t\t\treturn this.each(function () {\n\t\t\t\tif (/^ui-id-\\d+$/.test(this.id)) {\n\t\t\t\t\t$(this).removeAttr(\"id\");\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t});\n\n\t// selectors\n\tfunction _focusable(element, isTabIndexNotNaN) {\n\t\tvar map,\n\t\t    mapName,\n\t\t    img,\n\t\t    nodeName = element.nodeName.toLowerCase();\n\t\tif (\"area\" === nodeName) {\n\t\t\tmap = element.parentNode;\n\t\t\tmapName = map.name;\n\t\t\tif (!element.href || !mapName || map.nodeName.toLowerCase() !== \"map\") {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\timg = $(\"img[usemap='#\" + mapName + \"']\")[0];\n\t\t\treturn !!img && visible(img);\n\t\t}\n\t\treturn (/^(input|select|textarea|button|object)$/.test(nodeName) ? !element.disabled : \"a\" === nodeName ? element.href || isTabIndexNotNaN : isTabIndexNotNaN) &&\n\t\t// the element and all of its ancestors must be visible\n\t\tvisible(element);\n\t}\n\n\tfunction visible(element) {\n\t\treturn $.expr.filters.visible(element) && !$(element).parents().addBack().filter(function () {\n\t\t\treturn $.css(this, \"visibility\") === \"hidden\";\n\t\t}).length;\n\t}\n\n\t$.extend($.expr[\":\"], {\n\t\tdata: $.expr.createPseudo ? $.expr.createPseudo(function (dataName) {\n\t\t\treturn function (elem) {\n\t\t\t\treturn !!$.data(elem, dataName);\n\t\t\t};\n\t\t}) :\n\t\t// support: jQuery <1.8\n\t\tfunction (elem, i, match) {\n\t\t\treturn !!$.data(elem, match[3]);\n\t\t},\n\n\t\tfocusable: function focusable(element) {\n\t\t\treturn _focusable(element, !isNaN($.attr(element, \"tabindex\")));\n\t\t},\n\n\t\ttabbable: function tabbable(element) {\n\t\t\tvar tabIndex = $.attr(element, \"tabindex\"),\n\t\t\t    isTabIndexNaN = isNaN(tabIndex);\n\t\t\treturn (isTabIndexNaN || tabIndex >= 0) && _focusable(element, !isTabIndexNaN);\n\t\t}\n\t});\n\n\t// support: jQuery <1.8\n\tif (!$(\"<a>\").outerWidth(1).jquery) {\n\t\t$.each([\"Width\", \"Height\"], function (i, name) {\n\t\t\tvar side = name === \"Width\" ? [\"Left\", \"Right\"] : [\"Top\", \"Bottom\"],\n\t\t\t    type = name.toLowerCase(),\n\t\t\t    orig = {\n\t\t\t\tinnerWidth: $.fn.innerWidth,\n\t\t\t\tinnerHeight: $.fn.innerHeight,\n\t\t\t\touterWidth: $.fn.outerWidth,\n\t\t\t\touterHeight: $.fn.outerHeight\n\t\t\t};\n\n\t\t\tfunction reduce(elem, size, border, margin) {\n\t\t\t\t$.each(side, function () {\n\t\t\t\t\tsize -= parseFloat($.css(elem, \"padding\" + this)) || 0;\n\t\t\t\t\tif (border) {\n\t\t\t\t\t\tsize -= parseFloat($.css(elem, \"border\" + this + \"Width\")) || 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (margin) {\n\t\t\t\t\t\tsize -= parseFloat($.css(elem, \"margin\" + this)) || 0;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn size;\n\t\t\t}\n\n\t\t\t$.fn[\"inner\" + name] = function (size) {\n\t\t\t\tif (size === undefined) {\n\t\t\t\t\treturn orig[\"inner\" + name].call(this);\n\t\t\t\t}\n\n\t\t\t\treturn this.each(function () {\n\t\t\t\t\t$(this).css(type, reduce(this, size) + \"px\");\n\t\t\t\t});\n\t\t\t};\n\n\t\t\t$.fn[\"outer\" + name] = function (size, margin) {\n\t\t\t\tif (typeof size !== \"number\") {\n\t\t\t\t\treturn orig[\"outer\" + name].call(this, size);\n\t\t\t\t}\n\n\t\t\t\treturn this.each(function () {\n\t\t\t\t\t$(this).css(type, reduce(this, size, true, margin) + \"px\");\n\t\t\t\t});\n\t\t\t};\n\t\t});\n\t}\n\n\t// support: jQuery <1.8\n\tif (!$.fn.addBack) {\n\t\t$.fn.addBack = function (selector) {\n\t\t\treturn this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));\n\t\t};\n\t}\n\n\t// support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)\n\tif ($(\"<a>\").data(\"a-b\", \"a\").removeData(\"a-b\").data(\"a-b\")) {\n\t\t$.fn.removeData = function (removeData) {\n\t\t\treturn function (key) {\n\t\t\t\tif (arguments.length) {\n\t\t\t\t\treturn removeData.call(this, $.camelCase(key));\n\t\t\t\t} else {\n\t\t\t\t\treturn removeData.call(this);\n\t\t\t\t}\n\t\t\t};\n\t\t}($.fn.removeData);\n\t}\n\n\t// deprecated\n\t$.ui.ie = !!/msie [\\w.]+/.exec(navigator.userAgent.toLowerCase());\n\n\t$.fn.extend({\n\t\tfocus: function (orig) {\n\t\t\treturn function (delay, fn) {\n\t\t\t\treturn typeof delay === \"number\" ? this.each(function () {\n\t\t\t\t\tvar elem = this;\n\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\t$(elem).focus();\n\t\t\t\t\t\tif (fn) {\n\t\t\t\t\t\t\tfn.call(elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, delay);\n\t\t\t\t}) : orig.apply(this, arguments);\n\t\t\t};\n\t\t}($.fn.focus),\n\n\t\tdisableSelection: function () {\n\t\t\tvar eventType = \"onselectstart\" in document.createElement(\"div\") ? \"selectstart\" : \"mousedown\";\n\n\t\t\treturn function () {\n\t\t\t\treturn this.bind(eventType + \".ui-disableSelection\", function (event) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t});\n\t\t\t};\n\t\t}(),\n\n\t\tenableSelection: function enableSelection() {\n\t\t\treturn this.unbind(\".ui-disableSelection\");\n\t\t},\n\n\t\tzIndex: function zIndex(_zIndex) {\n\t\t\tif (_zIndex !== undefined) {\n\t\t\t\treturn this.css(\"zIndex\", _zIndex);\n\t\t\t}\n\n\t\t\tif (this.length) {\n\t\t\t\tvar elem = $(this[0]),\n\t\t\t\t    position,\n\t\t\t\t    value;\n\t\t\t\twhile (elem.length && elem[0] !== document) {\n\t\t\t\t\t// Ignore z-index if position is set to a value where z-index is ignored by the browser\n\t\t\t\t\t// This makes behavior of this function consistent across browsers\n\t\t\t\t\t// WebKit always returns auto if the element is positioned\n\t\t\t\t\tposition = elem.css(\"position\");\n\t\t\t\t\tif (position === \"absolute\" || position === \"relative\" || position === \"fixed\") {\n\t\t\t\t\t\t// IE returns 0 when zIndex is not specified\n\t\t\t\t\t\t// other browsers return a string\n\t\t\t\t\t\t// we ignore the case of nested elements with an explicit value of 0\n\t\t\t\t\t\t// <div style=\"z-index: -10;\"><div style=\"z-index: 0;\"></div></div>\n\t\t\t\t\t\tvalue = parseInt(elem.css(\"zIndex\"), 10);\n\t\t\t\t\t\tif (!isNaN(value) && value !== 0) {\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telem = elem.parent();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t}\n\t});\n\n\t// $.ui.plugin is deprecated. Use $.widget() extensions instead.\n\t$.ui.plugin = {\n\t\tadd: function add(module, option, set) {\n\t\t\tvar i,\n\t\t\t    proto = $.ui[module].prototype;\n\t\t\tfor (i in set) {\n\t\t\t\tproto.plugins[i] = proto.plugins[i] || [];\n\t\t\t\tproto.plugins[i].push([option, set[i]]);\n\t\t\t}\n\t\t},\n\t\tcall: function call(instance, name, args, allowDisconnected) {\n\t\t\tvar i,\n\t\t\t    set = instance.plugins[name];\n\n\t\t\tif (!set) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!allowDisconnected && (!instance.element[0].parentNode || instance.element[0].parentNode.nodeType === 11)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < set.length; i++) {\n\t\t\t\tif (instance.options[set[i][0]]) {\n\t\t\t\t\tset[i][1].apply(instance.element, args);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t/*!\n  * jQuery UI Widget 1.11.4\n  * http://jqueryui.com\n  *\n  * Copyright jQuery Foundation and other contributors\n  * Released under the MIT license.\n  * http://jquery.org/license\n  *\n  * http://api.jqueryui.com/jQuery.widget/\n  */\n\n\tvar widget_uuid = 0,\n\t    widget_slice = Array.prototype.slice;\n\n\t$.cleanData = function (orig) {\n\t\treturn function (elems) {\n\t\t\tvar events, elem, i;\n\t\t\tfor (i = 0; (elem = elems[i]) != null; i++) {\n\t\t\t\ttry {\n\n\t\t\t\t\t// Only trigger remove when necessary to save time\n\t\t\t\t\tevents = $._data(elem, \"events\");\n\t\t\t\t\tif (events && events.remove) {\n\t\t\t\t\t\t$(elem).triggerHandler(\"remove\");\n\t\t\t\t\t}\n\n\t\t\t\t\t// http://bugs.jquery.com/ticket/8235\n\t\t\t\t} catch (e) {}\n\t\t\t}\n\t\t\torig(elems);\n\t\t};\n\t}($.cleanData);\n\n\t$.widget = function (name, base, prototype) {\n\t\tvar fullName,\n\t\t    existingConstructor,\n\t\t    constructor,\n\t\t    basePrototype,\n\n\t\t// proxiedPrototype allows the provided prototype to remain unmodified\n\t\t// so that it can be used as a mixin for multiple widgets (#8876)\n\t\tproxiedPrototype = {},\n\t\t    namespace = name.split(\".\")[0];\n\n\t\tname = name.split(\".\")[1];\n\t\tfullName = namespace + \"-\" + name;\n\n\t\tif (!prototype) {\n\t\t\tprototype = base;\n\t\t\tbase = $.Widget;\n\t\t}\n\n\t\t// create selector for plugin\n\t\t$.expr[\":\"][fullName.toLowerCase()] = function (elem) {\n\t\t\treturn !!$.data(elem, fullName);\n\t\t};\n\n\t\t$[namespace] = $[namespace] || {};\n\t\texistingConstructor = $[namespace][name];\n\t\tconstructor = $[namespace][name] = function (options, element) {\n\t\t\t// allow instantiation without \"new\" keyword\n\t\t\tif (!this._createWidget) {\n\t\t\t\treturn new constructor(options, element);\n\t\t\t}\n\n\t\t\t// allow instantiation without initializing for simple inheritance\n\t\t\t// must use \"new\" keyword (the code above always passes args)\n\t\t\tif (arguments.length) {\n\t\t\t\tthis._createWidget(options, element);\n\t\t\t}\n\t\t};\n\t\t// extend with the existing constructor to carry over any static properties\n\t\t$.extend(constructor, existingConstructor, {\n\t\t\tversion: prototype.version,\n\t\t\t// copy the object used to create the prototype in case we need to\n\t\t\t// redefine the widget later\n\t\t\t_proto: $.extend({}, prototype),\n\t\t\t// track widgets that inherit from this widget in case this widget is\n\t\t\t// redefined after a widget inherits from it\n\t\t\t_childConstructors: []\n\t\t});\n\n\t\tbasePrototype = new base();\n\t\t// we need to make the options hash a property directly on the new instance\n\t\t// otherwise we'll modify the options hash on the prototype that we're\n\t\t// inheriting from\n\t\tbasePrototype.options = $.widget.extend({}, basePrototype.options);\n\t\t$.each(prototype, function (prop, value) {\n\t\t\tif (!$.isFunction(value)) {\n\t\t\t\tproxiedPrototype[prop] = value;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tproxiedPrototype[prop] = function () {\n\t\t\t\tvar _super = function _super() {\n\t\t\t\t\treturn base.prototype[prop].apply(this, arguments);\n\t\t\t\t},\n\t\t\t\t    _superApply = function _superApply(args) {\n\t\t\t\t\treturn base.prototype[prop].apply(this, args);\n\t\t\t\t};\n\t\t\t\treturn function () {\n\t\t\t\t\tvar __super = this._super,\n\t\t\t\t\t    __superApply = this._superApply,\n\t\t\t\t\t    returnValue;\n\n\t\t\t\t\tthis._super = _super;\n\t\t\t\t\tthis._superApply = _superApply;\n\n\t\t\t\t\treturnValue = value.apply(this, arguments);\n\n\t\t\t\t\tthis._super = __super;\n\t\t\t\t\tthis._superApply = __superApply;\n\n\t\t\t\t\treturn returnValue;\n\t\t\t\t};\n\t\t\t}();\n\t\t});\n\t\tconstructor.prototype = $.widget.extend(basePrototype, {\n\t\t\t// TODO: remove support for widgetEventPrefix\n\t\t\t// always use the name + a colon as the prefix, e.g., draggable:start\n\t\t\t// don't prefix for widgets that aren't DOM-based\n\t\t\twidgetEventPrefix: existingConstructor ? basePrototype.widgetEventPrefix || name : name\n\t\t}, proxiedPrototype, {\n\t\t\tconstructor: constructor,\n\t\t\tnamespace: namespace,\n\t\t\twidgetName: name,\n\t\t\twidgetFullName: fullName\n\t\t});\n\n\t\t// If this widget is being redefined then we need to find all widgets that\n\t\t// are inheriting from it and redefine all of them so that they inherit from\n\t\t// the new version of this widget. We're essentially trying to replace one\n\t\t// level in the prototype chain.\n\t\tif (existingConstructor) {\n\t\t\t$.each(existingConstructor._childConstructors, function (i, child) {\n\t\t\t\tvar childPrototype = child.prototype;\n\n\t\t\t\t// redefine the child widget using the same prototype that was\n\t\t\t\t// originally used, but inherit from the new version of the base\n\t\t\t\t$.widget(childPrototype.namespace + \".\" + childPrototype.widgetName, constructor, child._proto);\n\t\t\t});\n\t\t\t// remove the list of existing child constructors from the old constructor\n\t\t\t// so the old child constructors can be garbage collected\n\t\t\tdelete existingConstructor._childConstructors;\n\t\t} else {\n\t\t\tbase._childConstructors.push(constructor);\n\t\t}\n\n\t\t$.widget.bridge(name, constructor);\n\n\t\treturn constructor;\n\t};\n\n\t$.widget.extend = function (target) {\n\t\tvar input = widget_slice.call(arguments, 1),\n\t\t    inputIndex = 0,\n\t\t    inputLength = input.length,\n\t\t    key,\n\t\t    value;\n\t\tfor (; inputIndex < inputLength; inputIndex++) {\n\t\t\tfor (key in input[inputIndex]) {\n\t\t\t\tvalue = input[inputIndex][key];\n\t\t\t\tif (input[inputIndex].hasOwnProperty(key) && value !== undefined) {\n\t\t\t\t\t// Clone objects\n\t\t\t\t\tif ($.isPlainObject(value)) {\n\t\t\t\t\t\ttarget[key] = $.isPlainObject(target[key]) ? $.widget.extend({}, target[key], value) :\n\t\t\t\t\t\t// Don't extend strings, arrays, etc. with objects\n\t\t\t\t\t\t$.widget.extend({}, value);\n\t\t\t\t\t\t// Copy everything else by reference\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[key] = value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn target;\n\t};\n\n\t$.widget.bridge = function (name, object) {\n\t\tvar fullName = object.prototype.widgetFullName || name;\n\t\t$.fn[name] = function (options) {\n\t\t\tvar isMethodCall = typeof options === \"string\",\n\t\t\t    args = widget_slice.call(arguments, 1),\n\t\t\t    returnValue = this;\n\n\t\t\tif (isMethodCall) {\n\t\t\t\tthis.each(function () {\n\t\t\t\t\tvar methodValue,\n\t\t\t\t\t    instance = $.data(this, fullName);\n\t\t\t\t\tif (options === \"instance\") {\n\t\t\t\t\t\treturnValue = instance;\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tif (!instance) {\n\t\t\t\t\t\treturn $.error(\"cannot call methods on \" + name + \" prior to initialization; \" + \"attempted to call method '\" + options + \"'\");\n\t\t\t\t\t}\n\t\t\t\t\tif (!$.isFunction(instance[options]) || options.charAt(0) === \"_\") {\n\t\t\t\t\t\treturn $.error(\"no such method '\" + options + \"' for \" + name + \" widget instance\");\n\t\t\t\t\t}\n\t\t\t\t\tmethodValue = instance[options].apply(instance, args);\n\t\t\t\t\tif (methodValue !== instance && methodValue !== undefined) {\n\t\t\t\t\t\treturnValue = methodValue && methodValue.jquery ? returnValue.pushStack(methodValue.get()) : methodValue;\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\n\t\t\t\t// Allow multiple hashes to be passed on init\n\t\t\t\tif (args.length) {\n\t\t\t\t\toptions = $.widget.extend.apply(null, [options].concat(args));\n\t\t\t\t}\n\n\t\t\t\tthis.each(function () {\n\t\t\t\t\tvar instance = $.data(this, fullName);\n\t\t\t\t\tif (instance) {\n\t\t\t\t\t\tinstance.option(options || {});\n\t\t\t\t\t\tif (instance._init) {\n\t\t\t\t\t\t\tinstance._init();\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$.data(this, fullName, new object(options, this));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn returnValue;\n\t\t};\n\t};\n\n\t$.Widget = function () /* options, element */{};\n\t$.Widget._childConstructors = [];\n\n\t$.Widget.prototype = {\n\t\twidgetName: \"widget\",\n\t\twidgetEventPrefix: \"\",\n\t\tdefaultElement: \"<div>\",\n\t\toptions: {\n\t\t\tdisabled: false,\n\n\t\t\t// callbacks\n\t\t\tcreate: null\n\t\t},\n\t\t_createWidget: function _createWidget(options, element) {\n\t\t\telement = $(element || this.defaultElement || this)[0];\n\t\t\tthis.element = $(element);\n\t\t\tthis.uuid = widget_uuid++;\n\t\t\tthis.eventNamespace = \".\" + this.widgetName + this.uuid;\n\n\t\t\tthis.bindings = $();\n\t\t\tthis.hoverable = $();\n\t\t\tthis.focusable = $();\n\n\t\t\tif (element !== this) {\n\t\t\t\t$.data(element, this.widgetFullName, this);\n\t\t\t\tthis._on(true, this.element, {\n\t\t\t\t\tremove: function remove(event) {\n\t\t\t\t\t\tif (event.target === element) {\n\t\t\t\t\t\t\tthis.destroy();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tthis.document = $(element.style ?\n\t\t\t\t// element within the document\n\t\t\t\telement.ownerDocument :\n\t\t\t\t// element is window or document\n\t\t\t\telement.document || element);\n\t\t\t\tthis.window = $(this.document[0].defaultView || this.document[0].parentWindow);\n\t\t\t}\n\n\t\t\tthis.options = $.widget.extend({}, this.options, this._getCreateOptions(), options);\n\n\t\t\tthis._create();\n\t\t\tthis._trigger(\"create\", null, this._getCreateEventData());\n\t\t\tthis._init();\n\t\t},\n\t\t_getCreateOptions: $.noop,\n\t\t_getCreateEventData: $.noop,\n\t\t_create: $.noop,\n\t\t_init: $.noop,\n\n\t\tdestroy: function destroy() {\n\t\t\tthis._destroy();\n\t\t\t// we can probably remove the unbind calls in 2.0\n\t\t\t// all event bindings should go through this._on()\n\t\t\tthis.element.unbind(this.eventNamespace).removeData(this.widgetFullName)\n\t\t\t// support: jquery <1.6.3\n\t\t\t// http://bugs.jquery.com/ticket/9413\n\t\t\t.removeData($.camelCase(this.widgetFullName));\n\t\t\tthis.widget().unbind(this.eventNamespace).removeAttr(\"aria-disabled\").removeClass(this.widgetFullName + \"-disabled \" + \"ui-state-disabled\");\n\n\t\t\t// clean up events and states\n\t\t\tthis.bindings.unbind(this.eventNamespace);\n\t\t\tthis.hoverable.removeClass(\"ui-state-hover\");\n\t\t\tthis.focusable.removeClass(\"ui-state-focus\");\n\t\t},\n\t\t_destroy: $.noop,\n\n\t\twidget: function widget() {\n\t\t\treturn this.element;\n\t\t},\n\n\t\toption: function option(key, value) {\n\t\t\tvar options = key,\n\t\t\t    parts,\n\t\t\t    curOption,\n\t\t\t    i;\n\n\t\t\tif (arguments.length === 0) {\n\t\t\t\t// don't return a reference to the internal hash\n\t\t\t\treturn $.widget.extend({}, this.options);\n\t\t\t}\n\n\t\t\tif (typeof key === \"string\") {\n\t\t\t\t// handle nested keys, e.g., \"foo.bar\" => { foo: { bar: ___ } }\n\t\t\t\toptions = {};\n\t\t\t\tparts = key.split(\".\");\n\t\t\t\tkey = parts.shift();\n\t\t\t\tif (parts.length) {\n\t\t\t\t\tcurOption = options[key] = $.widget.extend({}, this.options[key]);\n\t\t\t\t\tfor (i = 0; i < parts.length - 1; i++) {\n\t\t\t\t\t\tcurOption[parts[i]] = curOption[parts[i]] || {};\n\t\t\t\t\t\tcurOption = curOption[parts[i]];\n\t\t\t\t\t}\n\t\t\t\t\tkey = parts.pop();\n\t\t\t\t\tif (arguments.length === 1) {\n\t\t\t\t\t\treturn curOption[key] === undefined ? null : curOption[key];\n\t\t\t\t\t}\n\t\t\t\t\tcurOption[key] = value;\n\t\t\t\t} else {\n\t\t\t\t\tif (arguments.length === 1) {\n\t\t\t\t\t\treturn this.options[key] === undefined ? null : this.options[key];\n\t\t\t\t\t}\n\t\t\t\t\toptions[key] = value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._setOptions(options);\n\n\t\t\treturn this;\n\t\t},\n\t\t_setOptions: function _setOptions(options) {\n\t\t\tvar key;\n\n\t\t\tfor (key in options) {\n\t\t\t\tthis._setOption(key, options[key]);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\t\t_setOption: function _setOption(key, value) {\n\t\t\tthis.options[key] = value;\n\n\t\t\tif (key === \"disabled\") {\n\t\t\t\tthis.widget().toggleClass(this.widgetFullName + \"-disabled\", !!value);\n\n\t\t\t\t// If the widget is becoming disabled, then nothing is interactive\n\t\t\t\tif (value) {\n\t\t\t\t\tthis.hoverable.removeClass(\"ui-state-hover\");\n\t\t\t\t\tthis.focusable.removeClass(\"ui-state-focus\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\tenable: function enable() {\n\t\t\treturn this._setOptions({ disabled: false });\n\t\t},\n\t\tdisable: function disable() {\n\t\t\treturn this._setOptions({ disabled: true });\n\t\t},\n\n\t\t_on: function _on(suppressDisabledCheck, element, handlers) {\n\t\t\tvar delegateElement,\n\t\t\t    instance = this;\n\n\t\t\t// no suppressDisabledCheck flag, shuffle arguments\n\t\t\tif (typeof suppressDisabledCheck !== \"boolean\") {\n\t\t\t\thandlers = element;\n\t\t\t\telement = suppressDisabledCheck;\n\t\t\t\tsuppressDisabledCheck = false;\n\t\t\t}\n\n\t\t\t// no element argument, shuffle and use this.element\n\t\t\tif (!handlers) {\n\t\t\t\thandlers = element;\n\t\t\t\telement = this.element;\n\t\t\t\tdelegateElement = this.widget();\n\t\t\t} else {\n\t\t\t\telement = delegateElement = $(element);\n\t\t\t\tthis.bindings = this.bindings.add(element);\n\t\t\t}\n\n\t\t\t$.each(handlers, function (event, handler) {\n\t\t\t\tfunction handlerProxy() {\n\t\t\t\t\t// allow widgets to customize the disabled handling\n\t\t\t\t\t// - disabled as an array instead of boolean\n\t\t\t\t\t// - disabled class as method for disabling individual parts\n\t\t\t\t\tif (!suppressDisabledCheck && (instance.options.disabled === true || $(this).hasClass(\"ui-state-disabled\"))) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\treturn (typeof handler === \"string\" ? instance[handler] : handler).apply(instance, arguments);\n\t\t\t\t}\n\n\t\t\t\t// copy the guid so direct unbinding works\n\t\t\t\tif (typeof handler !== \"string\") {\n\t\t\t\t\thandlerProxy.guid = handler.guid = handler.guid || handlerProxy.guid || $.guid++;\n\t\t\t\t}\n\n\t\t\t\tvar match = event.match(/^([\\w:-]*)\\s*(.*)$/),\n\t\t\t\t    eventName = match[1] + instance.eventNamespace,\n\t\t\t\t    selector = match[2];\n\t\t\t\tif (selector) {\n\t\t\t\t\tdelegateElement.delegate(selector, eventName, handlerProxy);\n\t\t\t\t} else {\n\t\t\t\t\telement.bind(eventName, handlerProxy);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\t_off: function _off(element, eventName) {\n\t\t\teventName = (eventName || \"\").split(\" \").join(this.eventNamespace + \" \") + this.eventNamespace;\n\t\t\telement.unbind(eventName).undelegate(eventName);\n\n\t\t\t// Clear the stack to avoid memory leaks (#10056)\n\t\t\tthis.bindings = $(this.bindings.not(element).get());\n\t\t\tthis.focusable = $(this.focusable.not(element).get());\n\t\t\tthis.hoverable = $(this.hoverable.not(element).get());\n\t\t},\n\n\t\t_delay: function _delay(handler, delay) {\n\t\t\tfunction handlerProxy() {\n\t\t\t\treturn (typeof handler === \"string\" ? instance[handler] : handler).apply(instance, arguments);\n\t\t\t}\n\t\t\tvar instance = this;\n\t\t\treturn setTimeout(handlerProxy, delay || 0);\n\t\t},\n\n\t\t_hoverable: function _hoverable(element) {\n\t\t\tthis.hoverable = this.hoverable.add(element);\n\t\t\tthis._on(element, {\n\t\t\t\tmouseenter: function mouseenter(event) {\n\t\t\t\t\t$(event.currentTarget).addClass(\"ui-state-hover\");\n\t\t\t\t},\n\t\t\t\tmouseleave: function mouseleave(event) {\n\t\t\t\t\t$(event.currentTarget).removeClass(\"ui-state-hover\");\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\t_focusable: function _focusable(element) {\n\t\t\tthis.focusable = this.focusable.add(element);\n\t\t\tthis._on(element, {\n\t\t\t\tfocusin: function focusin(event) {\n\t\t\t\t\t$(event.currentTarget).addClass(\"ui-state-focus\");\n\t\t\t\t},\n\t\t\t\tfocusout: function focusout(event) {\n\t\t\t\t\t$(event.currentTarget).removeClass(\"ui-state-focus\");\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\t_trigger: function _trigger(type, event, data) {\n\t\t\tvar prop,\n\t\t\t    orig,\n\t\t\t    callback = this.options[type];\n\n\t\t\tdata = data || {};\n\t\t\tevent = $.Event(event);\n\t\t\tevent.type = (type === this.widgetEventPrefix ? type : this.widgetEventPrefix + type).toLowerCase();\n\t\t\t// the original event may come from any element\n\t\t\t// so we need to reset the target on the new event\n\t\t\tevent.target = this.element[0];\n\n\t\t\t// copy original event properties over to the new event\n\t\t\torig = event.originalEvent;\n\t\t\tif (orig) {\n\t\t\t\tfor (prop in orig) {\n\t\t\t\t\tif (!(prop in event)) {\n\t\t\t\t\t\tevent[prop] = orig[prop];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.element.trigger(event, data);\n\t\t\treturn !($.isFunction(callback) && callback.apply(this.element[0], [event].concat(data)) === false || event.isDefaultPrevented());\n\t\t}\n\t};\n\n\t$.each({ show: \"fadeIn\", hide: \"fadeOut\" }, function (method, defaultEffect) {\n\t\t$.Widget.prototype[\"_\" + method] = function (element, options, callback) {\n\t\t\tif (typeof options === \"string\") {\n\t\t\t\toptions = { effect: options };\n\t\t\t}\n\t\t\tvar hasOptions,\n\t\t\t    effectName = !options ? method : options === true || typeof options === \"number\" ? defaultEffect : options.effect || defaultEffect;\n\t\t\toptions = options || {};\n\t\t\tif (typeof options === \"number\") {\n\t\t\t\toptions = { duration: options };\n\t\t\t}\n\t\t\thasOptions = !$.isEmptyObject(options);\n\t\t\toptions.complete = callback;\n\t\t\tif (options.delay) {\n\t\t\t\telement.delay(options.delay);\n\t\t\t}\n\t\t\tif (hasOptions && $.effects && $.effects.effect[effectName]) {\n\t\t\t\telement[method](options);\n\t\t\t} else if (effectName !== method && element[effectName]) {\n\t\t\t\telement[effectName](options.duration, options.easing, callback);\n\t\t\t} else {\n\t\t\t\telement.queue(function (next) {\n\t\t\t\t\t$(this)[method]();\n\t\t\t\t\tif (callback) {\n\t\t\t\t\t\tcallback.call(element[0]);\n\t\t\t\t\t}\n\t\t\t\t\tnext();\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\t});\n\n\tvar widget = $.widget;\n\n\t/*!\n  * jQuery UI Mouse 1.11.4\n  * http://jqueryui.com\n  *\n  * Copyright jQuery Foundation and other contributors\n  * Released under the MIT license.\n  * http://jquery.org/license\n  *\n  * http://api.jqueryui.com/mouse/\n  */\n\n\tvar mouseHandled = false;\n\t$(document).mouseup(function () {\n\t\tmouseHandled = false;\n\t});\n\n\tvar mouse = $.widget(\"ui.mouse\", {\n\t\tversion: \"1.11.4\",\n\t\toptions: {\n\t\t\tcancel: \"input,textarea,button,select,option\",\n\t\t\tdistance: 1,\n\t\t\tdelay: 0\n\t\t},\n\t\t_mouseInit: function _mouseInit() {\n\t\t\tvar that = this;\n\n\t\t\tthis.element.bind(\"mousedown.\" + this.widgetName, function (event) {\n\t\t\t\treturn that._mouseDown(event);\n\t\t\t}).bind(\"click.\" + this.widgetName, function (event) {\n\t\t\t\tif (true === $.data(event.target, that.widgetName + \".preventClickEvent\")) {\n\t\t\t\t\t$.removeData(event.target, that.widgetName + \".preventClickEvent\");\n\t\t\t\t\tevent.stopImmediatePropagation();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tthis.started = false;\n\t\t},\n\n\t\t// TODO: make sure destroying one instance of mouse doesn't mess with\n\t\t// other instances of mouse\n\t\t_mouseDestroy: function _mouseDestroy() {\n\t\t\tthis.element.unbind(\".\" + this.widgetName);\n\t\t\tif (this._mouseMoveDelegate) {\n\t\t\t\tthis.document.unbind(\"mousemove.\" + this.widgetName, this._mouseMoveDelegate).unbind(\"mouseup.\" + this.widgetName, this._mouseUpDelegate);\n\t\t\t}\n\t\t},\n\n\t\t_mouseDown: function _mouseDown(event) {\n\t\t\t// don't let more than one widget handle mouseStart\n\t\t\tif (mouseHandled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._mouseMoved = false;\n\n\t\t\t// we may have missed mouseup (out of window)\n\t\t\tthis._mouseStarted && this._mouseUp(event);\n\n\t\t\tthis._mouseDownEvent = event;\n\n\t\t\tvar that = this,\n\t\t\t    btnIsLeft = event.which === 1,\n\n\t\t\t// event.target.nodeName works around a bug in IE 8 with\n\t\t\t// disabled inputs (#7620)\n\t\t\telIsCancel = typeof this.options.cancel === \"string\" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false;\n\t\t\tif (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tthis.mouseDelayMet = !this.options.delay;\n\t\t\tif (!this.mouseDelayMet) {\n\t\t\t\tthis._mouseDelayTimer = setTimeout(function () {\n\t\t\t\t\tthat.mouseDelayMet = true;\n\t\t\t\t}, this.options.delay);\n\t\t\t}\n\n\t\t\tif (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {\n\t\t\t\tthis._mouseStarted = this._mouseStart(event) !== false;\n\t\t\t\tif (!this._mouseStarted) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Click event may never have fired (Gecko & Opera)\n\t\t\tif (true === $.data(event.target, this.widgetName + \".preventClickEvent\")) {\n\t\t\t\t$.removeData(event.target, this.widgetName + \".preventClickEvent\");\n\t\t\t}\n\n\t\t\t// these delegates are required to keep context\n\t\t\tthis._mouseMoveDelegate = function (event) {\n\t\t\t\treturn that._mouseMove(event);\n\t\t\t};\n\t\t\tthis._mouseUpDelegate = function (event) {\n\t\t\t\treturn that._mouseUp(event);\n\t\t\t};\n\n\t\t\tthis.document.bind(\"mousemove.\" + this.widgetName, this._mouseMoveDelegate).bind(\"mouseup.\" + this.widgetName, this._mouseUpDelegate);\n\n\t\t\tevent.preventDefault();\n\n\t\t\tmouseHandled = true;\n\t\t\treturn true;\n\t\t},\n\n\t\t_mouseMove: function _mouseMove(event) {\n\t\t\t// Only check for mouseups outside the document if you've moved inside the document\n\t\t\t// at least once. This prevents the firing of mouseup in the case of IE<9, which will\n\t\t\t// fire a mousemove event if content is placed under the cursor. See #7778\n\t\t\t// Support: IE <9\n\t\t\tif (this._mouseMoved) {\n\t\t\t\t// IE mouseup check - mouseup happened when mouse was out of window\n\t\t\t\tif ($.ui.ie && (!document.documentMode || document.documentMode < 9) && !event.button) {\n\t\t\t\t\treturn this._mouseUp(event);\n\n\t\t\t\t\t// Iframe mouseup check - mouseup occurred in another document\n\t\t\t\t} else if (!event.which) {\n\t\t\t\t\treturn this._mouseUp(event);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (event.which || event.button) {\n\t\t\t\tthis._mouseMoved = true;\n\t\t\t}\n\n\t\t\tif (this._mouseStarted) {\n\t\t\t\tthis._mouseDrag(event);\n\t\t\t\treturn event.preventDefault();\n\t\t\t}\n\n\t\t\tif (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {\n\t\t\t\tthis._mouseStarted = this._mouseStart(this._mouseDownEvent, event) !== false;\n\t\t\t\tthis._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event);\n\t\t\t}\n\n\t\t\treturn !this._mouseStarted;\n\t\t},\n\n\t\t_mouseUp: function _mouseUp(event) {\n\t\t\tthis.document.unbind(\"mousemove.\" + this.widgetName, this._mouseMoveDelegate).unbind(\"mouseup.\" + this.widgetName, this._mouseUpDelegate);\n\n\t\t\tif (this._mouseStarted) {\n\t\t\t\tthis._mouseStarted = false;\n\n\t\t\t\tif (event.target === this._mouseDownEvent.target) {\n\t\t\t\t\t$.data(event.target, this.widgetName + \".preventClickEvent\", true);\n\t\t\t\t}\n\n\t\t\t\tthis._mouseStop(event);\n\t\t\t}\n\n\t\t\tmouseHandled = false;\n\t\t\treturn false;\n\t\t},\n\n\t\t_mouseDistanceMet: function _mouseDistanceMet(event) {\n\t\t\treturn Math.max(Math.abs(this._mouseDownEvent.pageX - event.pageX), Math.abs(this._mouseDownEvent.pageY - event.pageY)) >= this.options.distance;\n\t\t},\n\n\t\t_mouseDelayMet: function _mouseDelayMet() /* event */{\n\t\t\treturn this.mouseDelayMet;\n\t\t},\n\n\t\t// These are placeholder methods, to be overriden by extending plugin\n\t\t_mouseStart: function _mouseStart() /* event */{},\n\t\t_mouseDrag: function _mouseDrag() /* event */{},\n\t\t_mouseStop: function _mouseStop() /* event */{},\n\t\t_mouseCapture: function _mouseCapture() /* event */{\n\t\t\treturn true;\n\t\t}\n\t});\n\n\t/*!\n  * jQuery UI Position 1.11.4\n  * http://jqueryui.com\n  *\n  * Copyright jQuery Foundation and other contributors\n  * Released under the MIT license.\n  * http://jquery.org/license\n  *\n  * http://api.jqueryui.com/position/\n  */\n\n\t(function () {\n\n\t\t$.ui = $.ui || {};\n\n\t\tvar cachedScrollbarWidth,\n\t\t    supportsOffsetFractions,\n\t\t    max = Math.max,\n\t\t    abs = Math.abs,\n\t\t    round = Math.round,\n\t\t    rhorizontal = /left|center|right/,\n\t\t    rvertical = /top|center|bottom/,\n\t\t    roffset = /[\\+\\-]\\d+(\\.[\\d]+)?%?/,\n\t\t    rposition = /^\\w+/,\n\t\t    rpercent = /%$/,\n\t\t    _position = $.fn.position;\n\n\t\tfunction getOffsets(offsets, width, height) {\n\t\t\treturn [parseFloat(offsets[0]) * (rpercent.test(offsets[0]) ? width / 100 : 1), parseFloat(offsets[1]) * (rpercent.test(offsets[1]) ? height / 100 : 1)];\n\t\t}\n\n\t\tfunction parseCss(element, property) {\n\t\t\treturn parseInt($.css(element, property), 10) || 0;\n\t\t}\n\n\t\tfunction getDimensions(elem) {\n\t\t\tvar raw = elem[0];\n\t\t\tif (raw.nodeType === 9) {\n\t\t\t\treturn {\n\t\t\t\t\twidth: elem.width(),\n\t\t\t\t\theight: elem.height(),\n\t\t\t\t\toffset: { top: 0, left: 0 }\n\t\t\t\t};\n\t\t\t}\n\t\t\tif ($.isWindow(raw)) {\n\t\t\t\treturn {\n\t\t\t\t\twidth: elem.width(),\n\t\t\t\t\theight: elem.height(),\n\t\t\t\t\toffset: { top: elem.scrollTop(), left: elem.scrollLeft() }\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (raw.preventDefault) {\n\t\t\t\treturn {\n\t\t\t\t\twidth: 0,\n\t\t\t\t\theight: 0,\n\t\t\t\t\toffset: { top: raw.pageY, left: raw.pageX }\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn {\n\t\t\t\twidth: elem.outerWidth(),\n\t\t\t\theight: elem.outerHeight(),\n\t\t\t\toffset: elem.offset()\n\t\t\t};\n\t\t}\n\n\t\t$.position = {\n\t\t\tscrollbarWidth: function scrollbarWidth() {\n\t\t\t\tif (cachedScrollbarWidth !== undefined) {\n\t\t\t\t\treturn cachedScrollbarWidth;\n\t\t\t\t}\n\t\t\t\tvar w1,\n\t\t\t\t    w2,\n\t\t\t\t    div = $(\"<div style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>\"),\n\t\t\t\t    innerDiv = div.children()[0];\n\n\t\t\t\t$(\"body\").append(div);\n\t\t\t\tw1 = innerDiv.offsetWidth;\n\t\t\t\tdiv.css(\"overflow\", \"scroll\");\n\n\t\t\t\tw2 = innerDiv.offsetWidth;\n\n\t\t\t\tif (w1 === w2) {\n\t\t\t\t\tw2 = div[0].clientWidth;\n\t\t\t\t}\n\n\t\t\t\tdiv.remove();\n\n\t\t\t\treturn cachedScrollbarWidth = w1 - w2;\n\t\t\t},\n\t\t\tgetScrollInfo: function getScrollInfo(within) {\n\t\t\t\tvar overflowX = within.isWindow || within.isDocument ? \"\" : within.element.css(\"overflow-x\"),\n\t\t\t\t    overflowY = within.isWindow || within.isDocument ? \"\" : within.element.css(\"overflow-y\"),\n\t\t\t\t    hasOverflowX = overflowX === \"scroll\" || overflowX === \"auto\" && within.width < within.element[0].scrollWidth,\n\t\t\t\t    hasOverflowY = overflowY === \"scroll\" || overflowY === \"auto\" && within.height < within.element[0].scrollHeight;\n\t\t\t\treturn {\n\t\t\t\t\twidth: hasOverflowY ? $.position.scrollbarWidth() : 0,\n\t\t\t\t\theight: hasOverflowX ? $.position.scrollbarWidth() : 0\n\t\t\t\t};\n\t\t\t},\n\t\t\tgetWithinInfo: function getWithinInfo(element) {\n\t\t\t\tvar withinElement = $(element || window),\n\t\t\t\t    isWindow = $.isWindow(withinElement[0]),\n\t\t\t\t    isDocument = !!withinElement[0] && withinElement[0].nodeType === 9;\n\t\t\t\treturn {\n\t\t\t\t\telement: withinElement,\n\t\t\t\t\tisWindow: isWindow,\n\t\t\t\t\tisDocument: isDocument,\n\t\t\t\t\toffset: withinElement.offset() || { left: 0, top: 0 },\n\t\t\t\t\tscrollLeft: withinElement.scrollLeft(),\n\t\t\t\t\tscrollTop: withinElement.scrollTop(),\n\n\t\t\t\t\t// support: jQuery 1.6.x\n\t\t\t\t\t// jQuery 1.6 doesn't support .outerWidth/Height() on documents or windows\n\t\t\t\t\twidth: isWindow || isDocument ? withinElement.width() : withinElement.outerWidth(),\n\t\t\t\t\theight: isWindow || isDocument ? withinElement.height() : withinElement.outerHeight()\n\t\t\t\t};\n\t\t\t}\n\t\t};\n\n\t\t$.fn.position = function (options) {\n\t\t\tif (!options || !options.of) {\n\t\t\t\treturn _position.apply(this, arguments);\n\t\t\t}\n\n\t\t\t// make a copy, we don't want to modify arguments\n\t\t\toptions = $.extend({}, options);\n\n\t\t\tvar atOffset,\n\t\t\t    targetWidth,\n\t\t\t    targetHeight,\n\t\t\t    targetOffset,\n\t\t\t    basePosition,\n\t\t\t    dimensions,\n\t\t\t    target = $(options.of),\n\t\t\t    within = $.position.getWithinInfo(options.within),\n\t\t\t    scrollInfo = $.position.getScrollInfo(within),\n\t\t\t    collision = (options.collision || \"flip\").split(\" \"),\n\t\t\t    offsets = {};\n\n\t\t\tdimensions = getDimensions(target);\n\t\t\tif (target[0].preventDefault) {\n\t\t\t\t// force left top to allow flipping\n\t\t\t\toptions.at = \"left top\";\n\t\t\t}\n\t\t\ttargetWidth = dimensions.width;\n\t\t\ttargetHeight = dimensions.height;\n\t\t\ttargetOffset = dimensions.offset;\n\t\t\t// clone to reuse original targetOffset later\n\t\t\tbasePosition = $.extend({}, targetOffset);\n\n\t\t\t// force my and at to have valid horizontal and vertical positions\n\t\t\t// if a value is missing or invalid, it will be converted to center\n\t\t\t$.each([\"my\", \"at\"], function () {\n\t\t\t\tvar pos = (options[this] || \"\").split(\" \"),\n\t\t\t\t    horizontalOffset,\n\t\t\t\t    verticalOffset;\n\n\t\t\t\tif (pos.length === 1) {\n\t\t\t\t\tpos = rhorizontal.test(pos[0]) ? pos.concat([\"center\"]) : rvertical.test(pos[0]) ? [\"center\"].concat(pos) : [\"center\", \"center\"];\n\t\t\t\t}\n\t\t\t\tpos[0] = rhorizontal.test(pos[0]) ? pos[0] : \"center\";\n\t\t\t\tpos[1] = rvertical.test(pos[1]) ? pos[1] : \"center\";\n\n\t\t\t\t// calculate offsets\n\t\t\t\thorizontalOffset = roffset.exec(pos[0]);\n\t\t\t\tverticalOffset = roffset.exec(pos[1]);\n\t\t\t\toffsets[this] = [horizontalOffset ? horizontalOffset[0] : 0, verticalOffset ? verticalOffset[0] : 0];\n\n\t\t\t\t// reduce to just the positions without the offsets\n\t\t\t\toptions[this] = [rposition.exec(pos[0])[0], rposition.exec(pos[1])[0]];\n\t\t\t});\n\n\t\t\t// normalize collision option\n\t\t\tif (collision.length === 1) {\n\t\t\t\tcollision[1] = collision[0];\n\t\t\t}\n\n\t\t\tif (options.at[0] === \"right\") {\n\t\t\t\tbasePosition.left += targetWidth;\n\t\t\t} else if (options.at[0] === \"center\") {\n\t\t\t\tbasePosition.left += targetWidth / 2;\n\t\t\t}\n\n\t\t\tif (options.at[1] === \"bottom\") {\n\t\t\t\tbasePosition.top += targetHeight;\n\t\t\t} else if (options.at[1] === \"center\") {\n\t\t\t\tbasePosition.top += targetHeight / 2;\n\t\t\t}\n\n\t\t\tatOffset = getOffsets(offsets.at, targetWidth, targetHeight);\n\t\t\tbasePosition.left += atOffset[0];\n\t\t\tbasePosition.top += atOffset[1];\n\n\t\t\treturn this.each(function () {\n\t\t\t\tvar collisionPosition,\n\t\t\t\t    using,\n\t\t\t\t    elem = $(this),\n\t\t\t\t    elemWidth = elem.outerWidth(),\n\t\t\t\t    elemHeight = elem.outerHeight(),\n\t\t\t\t    marginLeft = parseCss(this, \"marginLeft\"),\n\t\t\t\t    marginTop = parseCss(this, \"marginTop\"),\n\t\t\t\t    collisionWidth = elemWidth + marginLeft + parseCss(this, \"marginRight\") + scrollInfo.width,\n\t\t\t\t    collisionHeight = elemHeight + marginTop + parseCss(this, \"marginBottom\") + scrollInfo.height,\n\t\t\t\t    position = $.extend({}, basePosition),\n\t\t\t\t    myOffset = getOffsets(offsets.my, elem.outerWidth(), elem.outerHeight());\n\n\t\t\t\tif (options.my[0] === \"right\") {\n\t\t\t\t\tposition.left -= elemWidth;\n\t\t\t\t} else if (options.my[0] === \"center\") {\n\t\t\t\t\tposition.left -= elemWidth / 2;\n\t\t\t\t}\n\n\t\t\t\tif (options.my[1] === \"bottom\") {\n\t\t\t\t\tposition.top -= elemHeight;\n\t\t\t\t} else if (options.my[1] === \"center\") {\n\t\t\t\t\tposition.top -= elemHeight / 2;\n\t\t\t\t}\n\n\t\t\t\tposition.left += myOffset[0];\n\t\t\t\tposition.top += myOffset[1];\n\n\t\t\t\t// if the browser doesn't support fractions, then round for consistent results\n\t\t\t\tif (!supportsOffsetFractions) {\n\t\t\t\t\tposition.left = round(position.left);\n\t\t\t\t\tposition.top = round(position.top);\n\t\t\t\t}\n\n\t\t\t\tcollisionPosition = {\n\t\t\t\t\tmarginLeft: marginLeft,\n\t\t\t\t\tmarginTop: marginTop\n\t\t\t\t};\n\n\t\t\t\t$.each([\"left\", \"top\"], function (i, dir) {\n\t\t\t\t\tif ($.ui.position[collision[i]]) {\n\t\t\t\t\t\t$.ui.position[collision[i]][dir](position, {\n\t\t\t\t\t\t\ttargetWidth: targetWidth,\n\t\t\t\t\t\t\ttargetHeight: targetHeight,\n\t\t\t\t\t\t\telemWidth: elemWidth,\n\t\t\t\t\t\t\telemHeight: elemHeight,\n\t\t\t\t\t\t\tcollisionPosition: collisionPosition,\n\t\t\t\t\t\t\tcollisionWidth: collisionWidth,\n\t\t\t\t\t\t\tcollisionHeight: collisionHeight,\n\t\t\t\t\t\t\toffset: [atOffset[0] + myOffset[0], atOffset[1] + myOffset[1]],\n\t\t\t\t\t\t\tmy: options.my,\n\t\t\t\t\t\t\tat: options.at,\n\t\t\t\t\t\t\twithin: within,\n\t\t\t\t\t\t\telem: elem\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tif (options.using) {\n\t\t\t\t\t// adds feedback as second argument to using callback, if present\n\t\t\t\t\tusing = function using(props) {\n\t\t\t\t\t\tvar left = targetOffset.left - position.left,\n\t\t\t\t\t\t    right = left + targetWidth - elemWidth,\n\t\t\t\t\t\t    top = targetOffset.top - position.top,\n\t\t\t\t\t\t    bottom = top + targetHeight - elemHeight,\n\t\t\t\t\t\t    feedback = {\n\t\t\t\t\t\t\ttarget: {\n\t\t\t\t\t\t\t\telement: target,\n\t\t\t\t\t\t\t\tleft: targetOffset.left,\n\t\t\t\t\t\t\t\ttop: targetOffset.top,\n\t\t\t\t\t\t\t\twidth: targetWidth,\n\t\t\t\t\t\t\t\theight: targetHeight\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\telement: {\n\t\t\t\t\t\t\t\telement: elem,\n\t\t\t\t\t\t\t\tleft: position.left,\n\t\t\t\t\t\t\t\ttop: position.top,\n\t\t\t\t\t\t\t\twidth: elemWidth,\n\t\t\t\t\t\t\t\theight: elemHeight\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\thorizontal: right < 0 ? \"left\" : left > 0 ? \"right\" : \"center\",\n\t\t\t\t\t\t\tvertical: bottom < 0 ? \"top\" : top > 0 ? \"bottom\" : \"middle\"\n\t\t\t\t\t\t};\n\t\t\t\t\t\tif (targetWidth < elemWidth && abs(left + right) < targetWidth) {\n\t\t\t\t\t\t\tfeedback.horizontal = \"center\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (targetHeight < elemHeight && abs(top + bottom) < targetHeight) {\n\t\t\t\t\t\t\tfeedback.vertical = \"middle\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (max(abs(left), abs(right)) > max(abs(top), abs(bottom))) {\n\t\t\t\t\t\t\tfeedback.important = \"horizontal\";\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfeedback.important = \"vertical\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\toptions.using.call(this, props, feedback);\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\telem.offset($.extend(position, { using: using }));\n\t\t\t});\n\t\t};\n\n\t\t$.ui.position = {\n\t\t\tfit: {\n\t\t\t\tleft: function left(position, data) {\n\t\t\t\t\tvar within = data.within,\n\t\t\t\t\t    withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,\n\t\t\t\t\t    outerWidth = within.width,\n\t\t\t\t\t    collisionPosLeft = position.left - data.collisionPosition.marginLeft,\n\t\t\t\t\t    overLeft = withinOffset - collisionPosLeft,\n\t\t\t\t\t    overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,\n\t\t\t\t\t    newOverRight;\n\n\t\t\t\t\t// element is wider than within\n\t\t\t\t\tif (data.collisionWidth > outerWidth) {\n\t\t\t\t\t\t// element is initially over the left side of within\n\t\t\t\t\t\tif (overLeft > 0 && overRight <= 0) {\n\t\t\t\t\t\t\tnewOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;\n\t\t\t\t\t\t\tposition.left += overLeft - newOverRight;\n\t\t\t\t\t\t\t// element is initially over right side of within\n\t\t\t\t\t\t} else if (overRight > 0 && overLeft <= 0) {\n\t\t\t\t\t\t\tposition.left = withinOffset;\n\t\t\t\t\t\t\t// element is initially over both left and right sides of within\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (overLeft > overRight) {\n\t\t\t\t\t\t\t\tposition.left = withinOffset + outerWidth - data.collisionWidth;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tposition.left = withinOffset;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// too far left -> align with left edge\n\t\t\t\t\t} else if (overLeft > 0) {\n\t\t\t\t\t\tposition.left += overLeft;\n\t\t\t\t\t\t// too far right -> align with right edge\n\t\t\t\t\t} else if (overRight > 0) {\n\t\t\t\t\t\tposition.left -= overRight;\n\t\t\t\t\t\t// adjust based on position and margin\n\t\t\t\t\t} else {\n\t\t\t\t\t\tposition.left = max(position.left - collisionPosLeft, position.left);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\ttop: function top(position, data) {\n\t\t\t\t\tvar within = data.within,\n\t\t\t\t\t    withinOffset = within.isWindow ? within.scrollTop : within.offset.top,\n\t\t\t\t\t    outerHeight = data.within.height,\n\t\t\t\t\t    collisionPosTop = position.top - data.collisionPosition.marginTop,\n\t\t\t\t\t    overTop = withinOffset - collisionPosTop,\n\t\t\t\t\t    overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,\n\t\t\t\t\t    newOverBottom;\n\n\t\t\t\t\t// element is taller than within\n\t\t\t\t\tif (data.collisionHeight > outerHeight) {\n\t\t\t\t\t\t// element is initially over the top of within\n\t\t\t\t\t\tif (overTop > 0 && overBottom <= 0) {\n\t\t\t\t\t\t\tnewOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset;\n\t\t\t\t\t\t\tposition.top += overTop - newOverBottom;\n\t\t\t\t\t\t\t// element is initially over bottom of within\n\t\t\t\t\t\t} else if (overBottom > 0 && overTop <= 0) {\n\t\t\t\t\t\t\tposition.top = withinOffset;\n\t\t\t\t\t\t\t// element is initially over both top and bottom of within\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (overTop > overBottom) {\n\t\t\t\t\t\t\t\tposition.top = withinOffset + outerHeight - data.collisionHeight;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tposition.top = withinOffset;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// too far up -> align with top\n\t\t\t\t\t} else if (overTop > 0) {\n\t\t\t\t\t\tposition.top += overTop;\n\t\t\t\t\t\t// too far down -> align with bottom edge\n\t\t\t\t\t} else if (overBottom > 0) {\n\t\t\t\t\t\tposition.top -= overBottom;\n\t\t\t\t\t\t// adjust based on position and margin\n\t\t\t\t\t} else {\n\t\t\t\t\t\tposition.top = max(position.top - collisionPosTop, position.top);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tflip: {\n\t\t\t\tleft: function left(position, data) {\n\t\t\t\t\tvar within = data.within,\n\t\t\t\t\t    withinOffset = within.offset.left + within.scrollLeft,\n\t\t\t\t\t    outerWidth = within.width,\n\t\t\t\t\t    offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,\n\t\t\t\t\t    collisionPosLeft = position.left - data.collisionPosition.marginLeft,\n\t\t\t\t\t    overLeft = collisionPosLeft - offsetLeft,\n\t\t\t\t\t    overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,\n\t\t\t\t\t    myOffset = data.my[0] === \"left\" ? -data.elemWidth : data.my[0] === \"right\" ? data.elemWidth : 0,\n\t\t\t\t\t    atOffset = data.at[0] === \"left\" ? data.targetWidth : data.at[0] === \"right\" ? -data.targetWidth : 0,\n\t\t\t\t\t    offset = -2 * data.offset[0],\n\t\t\t\t\t    newOverRight,\n\t\t\t\t\t    newOverLeft;\n\n\t\t\t\t\tif (overLeft < 0) {\n\t\t\t\t\t\tnewOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset;\n\t\t\t\t\t\tif (newOverRight < 0 || newOverRight < abs(overLeft)) {\n\t\t\t\t\t\t\tposition.left += myOffset + atOffset + offset;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (overRight > 0) {\n\t\t\t\t\t\tnewOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft;\n\t\t\t\t\t\tif (newOverLeft > 0 || abs(newOverLeft) < overRight) {\n\t\t\t\t\t\t\tposition.left += myOffset + atOffset + offset;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\ttop: function top(position, data) {\n\t\t\t\t\tvar within = data.within,\n\t\t\t\t\t    withinOffset = within.offset.top + within.scrollTop,\n\t\t\t\t\t    outerHeight = within.height,\n\t\t\t\t\t    offsetTop = within.isWindow ? within.scrollTop : within.offset.top,\n\t\t\t\t\t    collisionPosTop = position.top - data.collisionPosition.marginTop,\n\t\t\t\t\t    overTop = collisionPosTop - offsetTop,\n\t\t\t\t\t    overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,\n\t\t\t\t\t    top = data.my[1] === \"top\",\n\t\t\t\t\t    myOffset = top ? -data.elemHeight : data.my[1] === \"bottom\" ? data.elemHeight : 0,\n\t\t\t\t\t    atOffset = data.at[1] === \"top\" ? data.targetHeight : data.at[1] === \"bottom\" ? -data.targetHeight : 0,\n\t\t\t\t\t    offset = -2 * data.offset[1],\n\t\t\t\t\t    newOverTop,\n\t\t\t\t\t    newOverBottom;\n\t\t\t\t\tif (overTop < 0) {\n\t\t\t\t\t\tnewOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;\n\t\t\t\t\t\tif (newOverBottom < 0 || newOverBottom < abs(overTop)) {\n\t\t\t\t\t\t\tposition.top += myOffset + atOffset + offset;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (overBottom > 0) {\n\t\t\t\t\t\tnewOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;\n\t\t\t\t\t\tif (newOverTop > 0 || abs(newOverTop) < overBottom) {\n\t\t\t\t\t\t\tposition.top += myOffset + atOffset + offset;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tflipfit: {\n\t\t\t\tleft: function left() {\n\t\t\t\t\t$.ui.position.flip.left.apply(this, arguments);\n\t\t\t\t\t$.ui.position.fit.left.apply(this, arguments);\n\t\t\t\t},\n\t\t\t\ttop: function top() {\n\t\t\t\t\t$.ui.position.flip.top.apply(this, arguments);\n\t\t\t\t\t$.ui.position.fit.top.apply(this, arguments);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t// fraction support test\n\t\t(function () {\n\t\t\tvar testElement,\n\t\t\t    testElementParent,\n\t\t\t    testElementStyle,\n\t\t\t    offsetLeft,\n\t\t\t    i,\n\t\t\t    body = document.getElementsByTagName(\"body\")[0],\n\t\t\t    div = document.createElement(\"div\");\n\n\t\t\t//Create a \"fake body\" for testing based on method used in jQuery.support\n\t\t\ttestElement = document.createElement(body ? \"div\" : \"body\");\n\t\t\ttestElementStyle = {\n\t\t\t\tvisibility: \"hidden\",\n\t\t\t\twidth: 0,\n\t\t\t\theight: 0,\n\t\t\t\tborder: 0,\n\t\t\t\tmargin: 0,\n\t\t\t\tbackground: \"none\"\n\t\t\t};\n\t\t\tif (body) {\n\t\t\t\t$.extend(testElementStyle, {\n\t\t\t\t\tposition: \"absolute\",\n\t\t\t\t\tleft: \"-1000px\",\n\t\t\t\t\ttop: \"-1000px\"\n\t\t\t\t});\n\t\t\t}\n\t\t\tfor (i in testElementStyle) {\n\t\t\t\ttestElement.style[i] = testElementStyle[i];\n\t\t\t}\n\t\t\ttestElement.appendChild(div);\n\t\t\ttestElementParent = body || document.documentElement;\n\t\t\ttestElementParent.insertBefore(testElement, testElementParent.firstChild);\n\n\t\t\tdiv.style.cssText = \"position: absolute; left: 10.7432222px;\";\n\n\t\t\toffsetLeft = $(div).offset().left;\n\t\t\tsupportsOffsetFractions = offsetLeft > 10 && offsetLeft < 11;\n\n\t\t\ttestElement.innerHTML = \"\";\n\t\t\ttestElementParent.removeChild(testElement);\n\t\t})();\n\t})();\n\n\tvar position = $.ui.position;\n\n\t/*!\n  * jQuery UI Accordion 1.11.4\n  * http://jqueryui.com\n  *\n  * Copyright jQuery Foundation and other contributors\n  * Released under the MIT license.\n  * http://jquery.org/license\n  *\n  * http://api.jqueryui.com/accordion/\n  */\n\n\tvar accordion = $.widget(\"ui.accordion\", {\n\t\tversion: \"1.11.4\",\n\t\toptions: {\n\t\t\tactive: 0,\n\t\t\tanimate: {},\n\t\t\tcollapsible: false,\n\t\t\tevent: \"click\",\n\t\t\theader: \"> li > :first-child,> :not(li):even\",\n\t\t\theightStyle: \"auto\",\n\t\t\ticons: {\n\t\t\t\tactiveHeader: \"ui-icon-triangle-1-s\",\n\t\t\t\theader: \"ui-icon-triangle-1-e\"\n\t\t\t},\n\n\t\t\t// callbacks\n\t\t\tactivate: null,\n\t\t\tbeforeActivate: null\n\t\t},\n\n\t\thideProps: {\n\t\t\tborderTopWidth: \"hide\",\n\t\t\tborderBottomWidth: \"hide\",\n\t\t\tpaddingTop: \"hide\",\n\t\t\tpaddingBottom: \"hide\",\n\t\t\theight: \"hide\"\n\t\t},\n\n\t\tshowProps: {\n\t\t\tborderTopWidth: \"show\",\n\t\t\tborderBottomWidth: \"show\",\n\t\t\tpaddingTop: \"show\",\n\t\t\tpaddingBottom: \"show\",\n\t\t\theight: \"show\"\n\t\t},\n\n\t\t_create: function _create() {\n\t\t\tvar options = this.options;\n\t\t\tthis.prevShow = this.prevHide = $();\n\t\t\tthis.element.addClass(\"ui-accordion ui-widget ui-helper-reset\")\n\t\t\t// ARIA\n\t\t\t.attr(\"role\", \"tablist\");\n\n\t\t\t// don't allow collapsible: false and active: false / null\n\t\t\tif (!options.collapsible && (options.active === false || options.active == null)) {\n\t\t\t\toptions.active = 0;\n\t\t\t}\n\n\t\t\tthis._processPanels();\n\t\t\t// handle negative values\n\t\t\tif (options.active < 0) {\n\t\t\t\toptions.active += this.headers.length;\n\t\t\t}\n\t\t\tthis._refresh();\n\t\t},\n\n\t\t_getCreateEventData: function _getCreateEventData() {\n\t\t\treturn {\n\t\t\t\theader: this.active,\n\t\t\t\tpanel: !this.active.length ? $() : this.active.next()\n\t\t\t};\n\t\t},\n\n\t\t_createIcons: function _createIcons() {\n\t\t\tvar icons = this.options.icons;\n\t\t\tif (icons) {\n\t\t\t\t$(\"<span>\").addClass(\"ui-accordion-header-icon ui-icon \" + icons.header).prependTo(this.headers);\n\t\t\t\tthis.active.children(\".ui-accordion-header-icon\").removeClass(icons.header).addClass(icons.activeHeader);\n\t\t\t\tthis.headers.addClass(\"ui-accordion-icons\");\n\t\t\t}\n\t\t},\n\n\t\t_destroyIcons: function _destroyIcons() {\n\t\t\tthis.headers.removeClass(\"ui-accordion-icons\").children(\".ui-accordion-header-icon\").remove();\n\t\t},\n\n\t\t_destroy: function _destroy() {\n\t\t\tvar contents;\n\n\t\t\t// clean up main element\n\t\t\tthis.element.removeClass(\"ui-accordion ui-widget ui-helper-reset\").removeAttr(\"role\");\n\n\t\t\t// clean up headers\n\t\t\tthis.headers.removeClass(\"ui-accordion-header ui-accordion-header-active ui-state-default \" + \"ui-corner-all ui-state-active ui-state-disabled ui-corner-top\").removeAttr(\"role\").removeAttr(\"aria-expanded\").removeAttr(\"aria-selected\").removeAttr(\"aria-controls\").removeAttr(\"tabIndex\").removeUniqueId();\n\n\t\t\tthis._destroyIcons();\n\n\t\t\t// clean up content panels\n\t\t\tcontents = this.headers.next().removeClass(\"ui-helper-reset ui-widget-content ui-corner-bottom \" + \"ui-accordion-content ui-accordion-content-active ui-state-disabled\").css(\"display\", \"\").removeAttr(\"role\").removeAttr(\"aria-hidden\").removeAttr(\"aria-labelledby\").removeUniqueId();\n\n\t\t\tif (this.options.heightStyle !== \"content\") {\n\t\t\t\tcontents.css(\"height\", \"\");\n\t\t\t}\n\t\t},\n\n\t\t_setOption: function _setOption(key, value) {\n\t\t\tif (key === \"active\") {\n\t\t\t\t// _activate() will handle invalid values and update this.options\n\t\t\t\tthis._activate(value);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (key === \"event\") {\n\t\t\t\tif (this.options.event) {\n\t\t\t\t\tthis._off(this.headers, this.options.event);\n\t\t\t\t}\n\t\t\t\tthis._setupEvents(value);\n\t\t\t}\n\n\t\t\tthis._super(key, value);\n\n\t\t\t// setting collapsible: false while collapsed; open first panel\n\t\t\tif (key === \"collapsible\" && !value && this.options.active === false) {\n\t\t\t\tthis._activate(0);\n\t\t\t}\n\n\t\t\tif (key === \"icons\") {\n\t\t\t\tthis._destroyIcons();\n\t\t\t\tif (value) {\n\t\t\t\t\tthis._createIcons();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// #5332 - opacity doesn't cascade to positioned elements in IE\n\t\t\t// so we need to add the disabled class to the headers and panels\n\t\t\tif (key === \"disabled\") {\n\t\t\t\tthis.element.toggleClass(\"ui-state-disabled\", !!value).attr(\"aria-disabled\", value);\n\t\t\t\tthis.headers.add(this.headers.next()).toggleClass(\"ui-state-disabled\", !!value);\n\t\t\t}\n\t\t},\n\n\t\t_keydown: function _keydown(event) {\n\t\t\tif (event.altKey || event.ctrlKey) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar keyCode = $.ui.keyCode,\n\t\t\t    length = this.headers.length,\n\t\t\t    currentIndex = this.headers.index(event.target),\n\t\t\t    toFocus = false;\n\n\t\t\tswitch (event.keyCode) {\n\t\t\t\tcase keyCode.RIGHT:\n\t\t\t\tcase keyCode.DOWN:\n\t\t\t\t\ttoFocus = this.headers[(currentIndex + 1) % length];\n\t\t\t\t\tbreak;\n\t\t\t\tcase keyCode.LEFT:\n\t\t\t\tcase keyCode.UP:\n\t\t\t\t\ttoFocus = this.headers[(currentIndex - 1 + length) % length];\n\t\t\t\t\tbreak;\n\t\t\t\tcase keyCode.SPACE:\n\t\t\t\tcase keyCode.ENTER:\n\t\t\t\t\tthis._eventHandler(event);\n\t\t\t\t\tbreak;\n\t\t\t\tcase keyCode.HOME:\n\t\t\t\t\ttoFocus = this.headers[0];\n\t\t\t\t\tbreak;\n\t\t\t\tcase keyCode.END:\n\t\t\t\t\ttoFocus = this.headers[length - 1];\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (toFocus) {\n\t\t\t\t$(event.target).attr(\"tabIndex\", -1);\n\t\t\t\t$(toFocus).attr(\"tabIndex\", 0);\n\t\t\t\ttoFocus.focus();\n\t\t\t\tevent.preventDefault();\n\t\t\t}\n\t\t},\n\n\t\t_panelKeyDown: function _panelKeyDown(event) {\n\t\t\tif (event.keyCode === $.ui.keyCode.UP && event.ctrlKey) {\n\t\t\t\t$(event.currentTarget).prev().focus();\n\t\t\t}\n\t\t},\n\n\t\trefresh: function refresh() {\n\t\t\tvar options = this.options;\n\t\t\tthis._processPanels();\n\n\t\t\t// was collapsed or no panel\n\t\t\tif (options.active === false && options.collapsible === true || !this.headers.length) {\n\t\t\t\toptions.active = false;\n\t\t\t\tthis.active = $();\n\t\t\t\t// active false only when collapsible is true\n\t\t\t} else if (options.active === false) {\n\t\t\t\tthis._activate(0);\n\t\t\t\t// was active, but active panel is gone\n\t\t\t} else if (this.active.length && !$.contains(this.element[0], this.active[0])) {\n\t\t\t\t// all remaining panel are disabled\n\t\t\t\tif (this.headers.length === this.headers.find(\".ui-state-disabled\").length) {\n\t\t\t\t\toptions.active = false;\n\t\t\t\t\tthis.active = $();\n\t\t\t\t\t// activate previous panel\n\t\t\t\t} else {\n\t\t\t\t\tthis._activate(Math.max(0, options.active - 1));\n\t\t\t\t}\n\t\t\t\t// was active, active panel still exists\n\t\t\t} else {\n\t\t\t\t// make sure active index is correct\n\t\t\t\toptions.active = this.headers.index(this.active);\n\t\t\t}\n\n\t\t\tthis._destroyIcons();\n\n\t\t\tthis._refresh();\n\t\t},\n\n\t\t_processPanels: function _processPanels() {\n\t\t\tvar prevHeaders = this.headers,\n\t\t\t    prevPanels = this.panels;\n\n\t\t\tthis.headers = this.element.find(this.options.header).addClass(\"ui-accordion-header ui-state-default ui-corner-all\");\n\n\t\t\tthis.panels = this.headers.next().addClass(\"ui-accordion-content ui-helper-reset ui-widget-content ui-corner-bottom\").filter(\":not(.ui-accordion-content-active)\").hide();\n\n\t\t\t// Avoid memory leaks (#10056)\n\t\t\tif (prevPanels) {\n\t\t\t\tthis._off(prevHeaders.not(this.headers));\n\t\t\t\tthis._off(prevPanels.not(this.panels));\n\t\t\t}\n\t\t},\n\n\t\t_refresh: function _refresh() {\n\t\t\tvar maxHeight,\n\t\t\t    options = this.options,\n\t\t\t    heightStyle = options.heightStyle,\n\t\t\t    parent = this.element.parent();\n\n\t\t\tthis.active = this._findActive(options.active).addClass(\"ui-accordion-header-active ui-state-active ui-corner-top\").removeClass(\"ui-corner-all\");\n\t\t\tthis.active.next().addClass(\"ui-accordion-content-active\").show();\n\n\t\t\tthis.headers.attr(\"role\", \"tab\").each(function () {\n\t\t\t\tvar header = $(this),\n\t\t\t\t    headerId = header.uniqueId().attr(\"id\"),\n\t\t\t\t    panel = header.next(),\n\t\t\t\t    panelId = panel.uniqueId().attr(\"id\");\n\t\t\t\theader.attr(\"aria-controls\", panelId);\n\t\t\t\tpanel.attr(\"aria-labelledby\", headerId);\n\t\t\t}).next().attr(\"role\", \"tabpanel\");\n\n\t\t\tthis.headers.not(this.active).attr({\n\t\t\t\t\"aria-selected\": \"false\",\n\t\t\t\t\"aria-expanded\": \"false\",\n\t\t\t\ttabIndex: -1\n\t\t\t}).next().attr({\n\t\t\t\t\"aria-hidden\": \"true\"\n\t\t\t}).hide();\n\n\t\t\t// make sure at least one header is in the tab order\n\t\t\tif (!this.active.length) {\n\t\t\t\tthis.headers.eq(0).attr(\"tabIndex\", 0);\n\t\t\t} else {\n\t\t\t\tthis.active.attr({\n\t\t\t\t\t\"aria-selected\": \"true\",\n\t\t\t\t\t\"aria-expanded\": \"true\",\n\t\t\t\t\ttabIndex: 0\n\t\t\t\t}).next().attr({\n\t\t\t\t\t\"aria-hidden\": \"false\"\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tthis._createIcons();\n\n\t\t\tthis._setupEvents(options.event);\n\n\t\t\tif (heightStyle === \"fill\") {\n\t\t\t\tmaxHeight = parent.height();\n\t\t\t\tthis.element.siblings(\":visible\").each(function () {\n\t\t\t\t\tvar elem = $(this),\n\t\t\t\t\t    position = elem.css(\"position\");\n\n\t\t\t\t\tif (position === \"absolute\" || position === \"fixed\") {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tmaxHeight -= elem.outerHeight(true);\n\t\t\t\t});\n\n\t\t\t\tthis.headers.each(function () {\n\t\t\t\t\tmaxHeight -= $(this).outerHeight(true);\n\t\t\t\t});\n\n\t\t\t\tthis.headers.next().each(function () {\n\t\t\t\t\t$(this).height(Math.max(0, maxHeight - $(this).innerHeight() + $(this).height()));\n\t\t\t\t}).css(\"overflow\", \"auto\");\n\t\t\t} else if (heightStyle === \"auto\") {\n\t\t\t\tmaxHeight = 0;\n\t\t\t\tthis.headers.next().each(function () {\n\t\t\t\t\tmaxHeight = Math.max(maxHeight, $(this).css(\"height\", \"\").height());\n\t\t\t\t}).height(maxHeight);\n\t\t\t}\n\t\t},\n\n\t\t_activate: function _activate(index) {\n\t\t\tvar active = this._findActive(index)[0];\n\n\t\t\t// trying to activate the already active panel\n\t\t\tif (active === this.active[0]) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// trying to collapse, simulate a click on the currently active header\n\t\t\tactive = active || this.active[0];\n\n\t\t\tthis._eventHandler({\n\t\t\t\ttarget: active,\n\t\t\t\tcurrentTarget: active,\n\t\t\t\tpreventDefault: $.noop\n\t\t\t});\n\t\t},\n\n\t\t_findActive: function _findActive(selector) {\n\t\t\treturn typeof selector === \"number\" ? this.headers.eq(selector) : $();\n\t\t},\n\n\t\t_setupEvents: function _setupEvents(event) {\n\t\t\tvar events = {\n\t\t\t\tkeydown: \"_keydown\"\n\t\t\t};\n\t\t\tif (event) {\n\t\t\t\t$.each(event.split(\" \"), function (index, eventName) {\n\t\t\t\t\tevents[eventName] = \"_eventHandler\";\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tthis._off(this.headers.add(this.headers.next()));\n\t\t\tthis._on(this.headers, events);\n\t\t\tthis._on(this.headers.next(), { keydown: \"_panelKeyDown\" });\n\t\t\tthis._hoverable(this.headers);\n\t\t\tthis._focusable(this.headers);\n\t\t},\n\n\t\t_eventHandler: function _eventHandler(event) {\n\t\t\tvar options = this.options,\n\t\t\t    active = this.active,\n\t\t\t    clicked = $(event.currentTarget),\n\t\t\t    clickedIsActive = clicked[0] === active[0],\n\t\t\t    collapsing = clickedIsActive && options.collapsible,\n\t\t\t    toShow = collapsing ? $() : clicked.next(),\n\t\t\t    toHide = active.next(),\n\t\t\t    eventData = {\n\t\t\t\toldHeader: active,\n\t\t\t\toldPanel: toHide,\n\t\t\t\tnewHeader: collapsing ? $() : clicked,\n\t\t\t\tnewPanel: toShow\n\t\t\t};\n\n\t\t\tevent.preventDefault();\n\n\t\t\tif (\n\t\t\t// click on active header, but not collapsible\n\t\t\tclickedIsActive && !options.collapsible ||\n\t\t\t// allow canceling activation\n\t\t\tthis._trigger(\"beforeActivate\", event, eventData) === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\toptions.active = collapsing ? false : this.headers.index(clicked);\n\n\t\t\t// when the call to ._toggle() comes after the class changes\n\t\t\t// it causes a very odd bug in IE 8 (see #6720)\n\t\t\tthis.active = clickedIsActive ? $() : clicked;\n\t\t\tthis._toggle(eventData);\n\n\t\t\t// switch classes\n\t\t\t// corner classes on the previously active header stay after the animation\n\t\t\tactive.removeClass(\"ui-accordion-header-active ui-state-active\");\n\t\t\tif (options.icons) {\n\t\t\t\tactive.children(\".ui-accordion-header-icon\").removeClass(options.icons.activeHeader).addClass(options.icons.header);\n\t\t\t}\n\n\t\t\tif (!clickedIsActive) {\n\t\t\t\tclicked.removeClass(\"ui-corner-all\").addClass(\"ui-accordion-header-active ui-state-active ui-corner-top\");\n\t\t\t\tif (options.icons) {\n\t\t\t\t\tclicked.children(\".ui-accordion-header-icon\").removeClass(options.icons.header).addClass(options.icons.activeHeader);\n\t\t\t\t}\n\n\t\t\t\tclicked.next().addClass(\"ui-accordion-content-active\");\n\t\t\t}\n\t\t},\n\n\t\t_toggle: function _toggle(data) {\n\t\t\tvar toShow = data.newPanel,\n\t\t\t    toHide = this.prevShow.length ? this.prevShow : data.oldPanel;\n\n\t\t\t// handle activating a panel during the animation for another activation\n\t\t\tthis.prevShow.add(this.prevHide).stop(true, true);\n\t\t\tthis.prevShow = toShow;\n\t\t\tthis.prevHide = toHide;\n\n\t\t\tif (this.options.animate) {\n\t\t\t\tthis._animate(toShow, toHide, data);\n\t\t\t} else {\n\t\t\t\ttoHide.hide();\n\t\t\t\ttoShow.show();\n\t\t\t\tthis._toggleComplete(data);\n\t\t\t}\n\n\t\t\ttoHide.attr({\n\t\t\t\t\"aria-hidden\": \"true\"\n\t\t\t});\n\t\t\ttoHide.prev().attr({\n\t\t\t\t\"aria-selected\": \"false\",\n\t\t\t\t\"aria-expanded\": \"false\"\n\t\t\t});\n\t\t\t// if we're switching panels, remove the old header from the tab order\n\t\t\t// if we're opening from collapsed state, remove the previous header from the tab order\n\t\t\t// if we're collapsing, then keep the collapsing header in the tab order\n\t\t\tif (toShow.length && toHide.length) {\n\t\t\t\ttoHide.prev().attr({\n\t\t\t\t\t\"tabIndex\": -1,\n\t\t\t\t\t\"aria-expanded\": \"false\"\n\t\t\t\t});\n\t\t\t} else if (toShow.length) {\n\t\t\t\tthis.headers.filter(function () {\n\t\t\t\t\treturn parseInt($(this).attr(\"tabIndex\"), 10) === 0;\n\t\t\t\t}).attr(\"tabIndex\", -1);\n\t\t\t}\n\n\t\t\ttoShow.attr(\"aria-hidden\", \"false\").prev().attr({\n\t\t\t\t\"aria-selected\": \"true\",\n\t\t\t\t\"aria-expanded\": \"true\",\n\t\t\t\ttabIndex: 0\n\t\t\t});\n\t\t},\n\n\t\t_animate: function _animate(toShow, toHide, data) {\n\t\t\tvar total,\n\t\t\t    easing,\n\t\t\t    duration,\n\t\t\t    that = this,\n\t\t\t    adjust = 0,\n\t\t\t    boxSizing = toShow.css(\"box-sizing\"),\n\t\t\t    down = toShow.length && (!toHide.length || toShow.index() < toHide.index()),\n\t\t\t    animate = this.options.animate || {},\n\t\t\t    options = down && animate.down || animate,\n\t\t\t    complete = function complete() {\n\t\t\t\tthat._toggleComplete(data);\n\t\t\t};\n\n\t\t\tif (typeof options === \"number\") {\n\t\t\t\tduration = options;\n\t\t\t}\n\t\t\tif (typeof options === \"string\") {\n\t\t\t\teasing = options;\n\t\t\t}\n\t\t\t// fall back from options to animation in case of partial down settings\n\t\t\teasing = easing || options.easing || animate.easing;\n\t\t\tduration = duration || options.duration || animate.duration;\n\n\t\t\tif (!toHide.length) {\n\t\t\t\treturn toShow.animate(this.showProps, duration, easing, complete);\n\t\t\t}\n\t\t\tif (!toShow.length) {\n\t\t\t\treturn toHide.animate(this.hideProps, duration, easing, complete);\n\t\t\t}\n\n\t\t\ttotal = toShow.show().outerHeight();\n\t\t\ttoHide.animate(this.hideProps, {\n\t\t\t\tduration: duration,\n\t\t\t\teasing: easing,\n\t\t\t\tstep: function step(now, fx) {\n\t\t\t\t\tfx.now = Math.round(now);\n\t\t\t\t}\n\t\t\t});\n\t\t\ttoShow.hide().animate(this.showProps, {\n\t\t\t\tduration: duration,\n\t\t\t\teasing: easing,\n\t\t\t\tcomplete: complete,\n\t\t\t\tstep: function step(now, fx) {\n\t\t\t\t\tfx.now = Math.round(now);\n\t\t\t\t\tif (fx.prop !== \"height\") {\n\t\t\t\t\t\tif (boxSizing === \"content-box\") {\n\t\t\t\t\t\t\tadjust += fx.now;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (that.options.heightStyle !== \"content\") {\n\t\t\t\t\t\tfx.now = Math.round(total - toHide.outerHeight() - adjust);\n\t\t\t\t\t\tadjust = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\t_toggleComplete: function _toggleComplete(data) {\n\t\t\tvar toHide = data.oldPanel;\n\n\t\t\ttoHide.removeClass(\"ui-accordion-content-active\").prev().removeClass(\"ui-corner-top\").addClass(\"ui-corner-all\");\n\n\t\t\t// Work around for rendering bug in IE (#5421)\n\t\t\tif (toHide.length) {\n\t\t\t\ttoHide.parent()[0].className = toHide.parent()[0].className;\n\t\t\t}\n\t\t\tthis._trigger(\"activate\", null, data);\n\t\t}\n\t});\n\n\t/*!\n  * jQuery UI Menu 1.11.4\n  * http://jqueryui.com\n  *\n  * Copyright jQuery Foundation and other contributors\n  * Released under the MIT license.\n  * http://jquery.org/license\n  *\n  * http://api.jqueryui.com/menu/\n  */\n\n\tvar menu = $.widget(\"ui.menu\", {\n\t\tversion: \"1.11.4\",\n\t\tdefaultElement: \"<ul>\",\n\t\tdelay: 300,\n\t\toptions: {\n\t\t\ticons: {\n\t\t\t\tsubmenu: \"ui-icon-carat-1-e\"\n\t\t\t},\n\t\t\titems: \"> *\",\n\t\t\tmenus: \"ul\",\n\t\t\tposition: {\n\t\t\t\tmy: \"left-1 top\",\n\t\t\t\tat: \"right top\"\n\t\t\t},\n\t\t\trole: \"menu\",\n\n\t\t\t// callbacks\n\t\t\tblur: null,\n\t\t\tfocus: null,\n\t\t\tselect: null\n\t\t},\n\n\t\t_create: function _create() {\n\t\t\tthis.activeMenu = this.element;\n\n\t\t\t// Flag used to prevent firing of the click handler\n\t\t\t// as the event bubbles up through nested menus\n\t\t\tthis.mouseHandled = false;\n\t\t\tthis.element.uniqueId().addClass(\"ui-menu ui-widget ui-widget-content\").toggleClass(\"ui-menu-icons\", !!this.element.find(\".ui-icon\").length).attr({\n\t\t\t\trole: this.options.role,\n\t\t\t\ttabIndex: 0\n\t\t\t});\n\n\t\t\tif (this.options.disabled) {\n\t\t\t\tthis.element.addClass(\"ui-state-disabled\").attr(\"aria-disabled\", \"true\");\n\t\t\t}\n\n\t\t\tthis._on({\n\t\t\t\t// Prevent focus from sticking to links inside menu after clicking\n\t\t\t\t// them (focus should always stay on UL during navigation).\n\t\t\t\t\"mousedown .ui-menu-item\": function mousedownUiMenuItem(event) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t},\n\t\t\t\t\"click .ui-menu-item\": function clickUiMenuItem(event) {\n\t\t\t\t\tvar target = $(event.target);\n\t\t\t\t\tif (!this.mouseHandled && target.not(\".ui-state-disabled\").length) {\n\t\t\t\t\t\tthis.select(event);\n\n\t\t\t\t\t\t// Only set the mouseHandled flag if the event will bubble, see #9469.\n\t\t\t\t\t\tif (!event.isPropagationStopped()) {\n\t\t\t\t\t\t\tthis.mouseHandled = true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Open submenu on click\n\t\t\t\t\t\tif (target.has(\".ui-menu\").length) {\n\t\t\t\t\t\t\tthis.expand(event);\n\t\t\t\t\t\t} else if (!this.element.is(\":focus\") && $(this.document[0].activeElement).closest(\".ui-menu\").length) {\n\n\t\t\t\t\t\t\t// Redirect focus to the menu\n\t\t\t\t\t\t\tthis.element.trigger(\"focus\", [true]);\n\n\t\t\t\t\t\t\t// If the active item is on the top level, let it stay active.\n\t\t\t\t\t\t\t// Otherwise, blur the active item since it is no longer visible.\n\t\t\t\t\t\t\tif (this.active && this.active.parents(\".ui-menu\").length === 1) {\n\t\t\t\t\t\t\t\tclearTimeout(this.timer);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"mouseenter .ui-menu-item\": function mouseenterUiMenuItem(event) {\n\t\t\t\t\t// Ignore mouse events while typeahead is active, see #10458.\n\t\t\t\t\t// Prevents focusing the wrong item when typeahead causes a scroll while the mouse\n\t\t\t\t\t// is over an item in the menu\n\t\t\t\t\tif (this.previousFilter) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tvar target = $(event.currentTarget);\n\t\t\t\t\t// Remove ui-state-active class from siblings of the newly focused menu item\n\t\t\t\t\t// to avoid a jump caused by adjacent elements both having a class with a border\n\t\t\t\t\ttarget.siblings(\".ui-state-active\").removeClass(\"ui-state-active\");\n\t\t\t\t\tthis.focus(event, target);\n\t\t\t\t},\n\t\t\t\tmouseleave: \"collapseAll\",\n\t\t\t\t\"mouseleave .ui-menu\": \"collapseAll\",\n\t\t\t\tfocus: function focus(event, keepActiveItem) {\n\t\t\t\t\t// If there's already an active item, keep it active\n\t\t\t\t\t// If not, activate the first item\n\t\t\t\t\tvar item = this.active || this.element.find(this.options.items).eq(0);\n\n\t\t\t\t\tif (!keepActiveItem) {\n\t\t\t\t\t\tthis.focus(event, item);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tblur: function blur(event) {\n\t\t\t\t\tthis._delay(function () {\n\t\t\t\t\t\tif (!$.contains(this.element[0], this.document[0].activeElement)) {\n\t\t\t\t\t\t\tthis.collapseAll(event);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\tkeydown: \"_keydown\"\n\t\t\t});\n\n\t\t\tthis.refresh();\n\n\t\t\t// Clicks outside of a menu collapse any open menus\n\t\t\tthis._on(this.document, {\n\t\t\t\tclick: function click(event) {\n\t\t\t\t\tif (this._closeOnDocumentClick(event)) {\n\t\t\t\t\t\tthis.collapseAll(event);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Reset the mouseHandled flag\n\t\t\t\t\tthis.mouseHandled = false;\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\t_destroy: function _destroy() {\n\t\t\t// Destroy (sub)menus\n\t\t\tthis.element.removeAttr(\"aria-activedescendant\").find(\".ui-menu\").addBack().removeClass(\"ui-menu ui-widget ui-widget-content ui-menu-icons ui-front\").removeAttr(\"role\").removeAttr(\"tabIndex\").removeAttr(\"aria-labelledby\").removeAttr(\"aria-expanded\").removeAttr(\"aria-hidden\").removeAttr(\"aria-disabled\").removeUniqueId().show();\n\n\t\t\t// Destroy menu items\n\t\t\tthis.element.find(\".ui-menu-item\").removeClass(\"ui-menu-item\").removeAttr(\"role\").removeAttr(\"aria-disabled\").removeUniqueId().removeClass(\"ui-state-hover\").removeAttr(\"tabIndex\").removeAttr(\"role\").removeAttr(\"aria-haspopup\").children().each(function () {\n\t\t\t\tvar elem = $(this);\n\t\t\t\tif (elem.data(\"ui-menu-submenu-carat\")) {\n\t\t\t\t\telem.remove();\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Destroy menu dividers\n\t\t\tthis.element.find(\".ui-menu-divider\").removeClass(\"ui-menu-divider ui-widget-content\");\n\t\t},\n\n\t\t_keydown: function _keydown(event) {\n\t\t\tvar match,\n\t\t\t    prev,\n\t\t\t    character,\n\t\t\t    skip,\n\t\t\t    preventDefault = true;\n\n\t\t\tswitch (event.keyCode) {\n\t\t\t\tcase $.ui.keyCode.PAGE_UP:\n\t\t\t\t\tthis.previousPage(event);\n\t\t\t\t\tbreak;\n\t\t\t\tcase $.ui.keyCode.PAGE_DOWN:\n\t\t\t\t\tthis.nextPage(event);\n\t\t\t\t\tbreak;\n\t\t\t\tcase $.ui.keyCode.HOME:\n\t\t\t\t\tthis._move(\"first\", \"first\", event);\n\t\t\t\t\tbreak;\n\t\t\t\tcase $.ui.keyCode.END:\n\t\t\t\t\tthis._move(\"last\", \"last\", event);\n\t\t\t\t\tbreak;\n\t\t\t\tcase $.ui.keyCode.UP:\n\t\t\t\t\tthis.previous(event);\n\t\t\t\t\tbreak;\n\t\t\t\tcase $.ui.keyCode.DOWN:\n\t\t\t\t\tthis.next(event);\n\t\t\t\t\tbreak;\n\t\t\t\tcase $.ui.keyCode.LEFT:\n\t\t\t\t\tthis.collapse(event);\n\t\t\t\t\tbreak;\n\t\t\t\tcase $.ui.keyCode.RIGHT:\n\t\t\t\t\tif (this.active && !this.active.is(\".ui-state-disabled\")) {\n\t\t\t\t\t\tthis.expand(event);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase $.ui.keyCode.ENTER:\n\t\t\t\tcase $.ui.keyCode.SPACE:\n\t\t\t\t\tthis._activate(event);\n\t\t\t\t\tbreak;\n\t\t\t\tcase $.ui.keyCode.ESCAPE:\n\t\t\t\t\tthis.collapse(event);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tpreventDefault = false;\n\t\t\t\t\tprev = this.previousFilter || \"\";\n\t\t\t\t\tcharacter = String.fromCharCode(event.keyCode);\n\t\t\t\t\tskip = false;\n\n\t\t\t\t\tclearTimeout(this.filterTimer);\n\n\t\t\t\t\tif (character === prev) {\n\t\t\t\t\t\tskip = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcharacter = prev + character;\n\t\t\t\t\t}\n\n\t\t\t\t\tmatch = this._filterMenuItems(character);\n\t\t\t\t\tmatch = skip && match.index(this.active.next()) !== -1 ? this.active.nextAll(\".ui-menu-item\") : match;\n\n\t\t\t\t\t// If no matches on the current filter, reset to the last character pressed\n\t\t\t\t\t// to move down the menu to the first item that starts with that character\n\t\t\t\t\tif (!match.length) {\n\t\t\t\t\t\tcharacter = String.fromCharCode(event.keyCode);\n\t\t\t\t\t\tmatch = this._filterMenuItems(character);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (match.length) {\n\t\t\t\t\t\tthis.focus(event, match);\n\t\t\t\t\t\tthis.previousFilter = character;\n\t\t\t\t\t\tthis.filterTimer = this._delay(function () {\n\t\t\t\t\t\t\tdelete this.previousFilter;\n\t\t\t\t\t\t}, 1000);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdelete this.previousFilter;\n\t\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (preventDefault) {\n\t\t\t\tevent.preventDefault();\n\t\t\t}\n\t\t},\n\n\t\t_activate: function _activate(event) {\n\t\t\tif (!this.active.is(\".ui-state-disabled\")) {\n\t\t\t\tif (this.active.is(\"[aria-haspopup='true']\")) {\n\t\t\t\t\tthis.expand(event);\n\t\t\t\t} else {\n\t\t\t\t\tthis.select(event);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\trefresh: function refresh() {\n\t\t\tvar menus,\n\t\t\t    items,\n\t\t\t    that = this,\n\t\t\t    icon = this.options.icons.submenu,\n\t\t\t    submenus = this.element.find(this.options.menus);\n\n\t\t\tthis.element.toggleClass(\"ui-menu-icons\", !!this.element.find(\".ui-icon\").length);\n\n\t\t\t// Initialize nested menus\n\t\t\tsubmenus.filter(\":not(.ui-menu)\").addClass(\"ui-menu ui-widget ui-widget-content ui-front\").hide().attr({\n\t\t\t\trole: this.options.role,\n\t\t\t\t\"aria-hidden\": \"true\",\n\t\t\t\t\"aria-expanded\": \"false\"\n\t\t\t}).each(function () {\n\t\t\t\tvar menu = $(this),\n\t\t\t\t    item = menu.parent(),\n\t\t\t\t    submenuCarat = $(\"<span>\").addClass(\"ui-menu-icon ui-icon \" + icon).data(\"ui-menu-submenu-carat\", true);\n\n\t\t\t\titem.attr(\"aria-haspopup\", \"true\").prepend(submenuCarat);\n\t\t\t\tmenu.attr(\"aria-labelledby\", item.attr(\"id\"));\n\t\t\t});\n\n\t\t\tmenus = submenus.add(this.element);\n\t\t\titems = menus.find(this.options.items);\n\n\t\t\t// Initialize menu-items containing spaces and/or dashes only as dividers\n\t\t\titems.not(\".ui-menu-item\").each(function () {\n\t\t\t\tvar item = $(this);\n\t\t\t\tif (that._isDivider(item)) {\n\t\t\t\t\titem.addClass(\"ui-widget-content ui-menu-divider\");\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Don't refresh list items that are already adapted\n\t\t\titems.not(\".ui-menu-item, .ui-menu-divider\").addClass(\"ui-menu-item\").uniqueId().attr({\n\t\t\t\ttabIndex: -1,\n\t\t\t\trole: this._itemRole()\n\t\t\t});\n\n\t\t\t// Add aria-disabled attribute to any disabled menu item\n\t\t\titems.filter(\".ui-state-disabled\").attr(\"aria-disabled\", \"true\");\n\n\t\t\t// If the active item has been removed, blur the menu\n\t\t\tif (this.active && !$.contains(this.element[0], this.active[0])) {\n\t\t\t\tthis.blur();\n\t\t\t}\n\t\t},\n\n\t\t_itemRole: function _itemRole() {\n\t\t\treturn {\n\t\t\t\tmenu: \"menuitem\",\n\t\t\t\tlistbox: \"option\"\n\t\t\t}[this.options.role];\n\t\t},\n\n\t\t_setOption: function _setOption(key, value) {\n\t\t\tif (key === \"icons\") {\n\t\t\t\tthis.element.find(\".ui-menu-icon\").removeClass(this.options.icons.submenu).addClass(value.submenu);\n\t\t\t}\n\t\t\tif (key === \"disabled\") {\n\t\t\t\tthis.element.toggleClass(\"ui-state-disabled\", !!value).attr(\"aria-disabled\", value);\n\t\t\t}\n\t\t\tthis._super(key, value);\n\t\t},\n\n\t\tfocus: function focus(event, item) {\n\t\t\tvar nested, focused;\n\t\t\tthis.blur(event, event && event.type === \"focus\");\n\n\t\t\tthis._scrollIntoView(item);\n\n\t\t\tthis.active = item.first();\n\t\t\tfocused = this.active.addClass(\"ui-state-focus\").removeClass(\"ui-state-active\");\n\t\t\t// Only update aria-activedescendant if there's a role\n\t\t\t// otherwise we assume focus is managed elsewhere\n\t\t\tif (this.options.role) {\n\t\t\t\tthis.element.attr(\"aria-activedescendant\", focused.attr(\"id\"));\n\t\t\t}\n\n\t\t\t// Highlight active parent menu item, if any\n\t\t\tthis.active.parent().closest(\".ui-menu-item\").addClass(\"ui-state-active\");\n\n\t\t\tif (event && event.type === \"keydown\") {\n\t\t\t\tthis._close();\n\t\t\t} else {\n\t\t\t\tthis.timer = this._delay(function () {\n\t\t\t\t\tthis._close();\n\t\t\t\t}, this.delay);\n\t\t\t}\n\n\t\t\tnested = item.children(\".ui-menu\");\n\t\t\tif (nested.length && event && /^mouse/.test(event.type)) {\n\t\t\t\tthis._startOpening(nested);\n\t\t\t}\n\t\t\tthis.activeMenu = item.parent();\n\n\t\t\tthis._trigger(\"focus\", event, { item: item });\n\t\t},\n\n\t\t_scrollIntoView: function _scrollIntoView(item) {\n\t\t\tvar borderTop, paddingTop, offset, scroll, elementHeight, itemHeight;\n\t\t\tif (this._hasScroll()) {\n\t\t\t\tborderTop = parseFloat($.css(this.activeMenu[0], \"borderTopWidth\")) || 0;\n\t\t\t\tpaddingTop = parseFloat($.css(this.activeMenu[0], \"paddingTop\")) || 0;\n\t\t\t\toffset = item.offset().top - this.activeMenu.offset().top - borderTop - paddingTop;\n\t\t\t\tscroll = this.activeMenu.scrollTop();\n\t\t\t\telementHeight = this.activeMenu.height();\n\t\t\t\titemHeight = item.outerHeight();\n\n\t\t\t\tif (offset < 0) {\n\t\t\t\t\tthis.activeMenu.scrollTop(scroll + offset);\n\t\t\t\t} else if (offset + itemHeight > elementHeight) {\n\t\t\t\t\tthis.activeMenu.scrollTop(scroll + offset - elementHeight + itemHeight);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tblur: function blur(event, fromFocus) {\n\t\t\tif (!fromFocus) {\n\t\t\t\tclearTimeout(this.timer);\n\t\t\t}\n\n\t\t\tif (!this.active) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.active.removeClass(\"ui-state-focus\");\n\t\t\tthis.active = null;\n\n\t\t\tthis._trigger(\"blur\", event, { item: this.active });\n\t\t},\n\n\t\t_startOpening: function _startOpening(submenu) {\n\t\t\tclearTimeout(this.timer);\n\n\t\t\t// Don't open if already open fixes a Firefox bug that caused a .5 pixel\n\t\t\t// shift in the submenu position when mousing over the carat icon\n\t\t\tif (submenu.attr(\"aria-hidden\") !== \"true\") {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.timer = this._delay(function () {\n\t\t\t\tthis._close();\n\t\t\t\tthis._open(submenu);\n\t\t\t}, this.delay);\n\t\t},\n\n\t\t_open: function _open(submenu) {\n\t\t\tvar position = $.extend({\n\t\t\t\tof: this.active\n\t\t\t}, this.options.position);\n\n\t\t\tclearTimeout(this.timer);\n\t\t\tthis.element.find(\".ui-menu\").not(submenu.parents(\".ui-menu\")).hide().attr(\"aria-hidden\", \"true\");\n\n\t\t\tsubmenu.show().removeAttr(\"aria-hidden\").attr(\"aria-expanded\", \"true\").position(position);\n\t\t},\n\n\t\tcollapseAll: function collapseAll(event, all) {\n\t\t\tclearTimeout(this.timer);\n\t\t\tthis.timer = this._delay(function () {\n\t\t\t\t// If we were passed an event, look for the submenu that contains the event\n\t\t\t\tvar currentMenu = all ? this.element : $(event && event.target).closest(this.element.find(\".ui-menu\"));\n\n\t\t\t\t// If we found no valid submenu ancestor, use the main menu to close all sub menus anyway\n\t\t\t\tif (!currentMenu.length) {\n\t\t\t\t\tcurrentMenu = this.element;\n\t\t\t\t}\n\n\t\t\t\tthis._close(currentMenu);\n\n\t\t\t\tthis.blur(event);\n\t\t\t\tthis.activeMenu = currentMenu;\n\t\t\t}, this.delay);\n\t\t},\n\n\t\t// With no arguments, closes the currently active menu - if nothing is active\n\t\t// it closes all menus.  If passed an argument, it will search for menus BELOW\n\t\t_close: function _close(startMenu) {\n\t\t\tif (!startMenu) {\n\t\t\t\tstartMenu = this.active ? this.active.parent() : this.element;\n\t\t\t}\n\n\t\t\tstartMenu.find(\".ui-menu\").hide().attr(\"aria-hidden\", \"true\").attr(\"aria-expanded\", \"false\").end().find(\".ui-state-active\").not(\".ui-state-focus\").removeClass(\"ui-state-active\");\n\t\t},\n\n\t\t_closeOnDocumentClick: function _closeOnDocumentClick(event) {\n\t\t\treturn !$(event.target).closest(\".ui-menu\").length;\n\t\t},\n\n\t\t_isDivider: function _isDivider(item) {\n\n\t\t\t// Match hyphen, em dash, en dash\n\t\t\treturn !/[^\\-\\u2014\\u2013\\s]/.test(item.text());\n\t\t},\n\n\t\tcollapse: function collapse(event) {\n\t\t\tvar newItem = this.active && this.active.parent().closest(\".ui-menu-item\", this.element);\n\t\t\tif (newItem && newItem.length) {\n\t\t\t\tthis._close();\n\t\t\t\tthis.focus(event, newItem);\n\t\t\t}\n\t\t},\n\n\t\texpand: function expand(event) {\n\t\t\tvar newItem = this.active && this.active.children(\".ui-menu \").find(this.options.items).first();\n\n\t\t\tif (newItem && newItem.length) {\n\t\t\t\tthis._open(newItem.parent());\n\n\t\t\t\t// Delay so Firefox will not hide activedescendant change in expanding submenu from AT\n\t\t\t\tthis._delay(function () {\n\t\t\t\t\tthis.focus(event, newItem);\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\n\t\tnext: function next(event) {\n\t\t\tthis._move(\"next\", \"first\", event);\n\t\t},\n\n\t\tprevious: function previous(event) {\n\t\t\tthis._move(\"prev\", \"last\", event);\n\t\t},\n\n\t\tisFirstItem: function isFirstItem() {\n\t\t\treturn this.active && !this.active.prevAll(\".ui-menu-item\").length;\n\t\t},\n\n\t\tisLastItem: function isLastItem() {\n\t\t\treturn this.active && !this.active.nextAll(\".ui-menu-item\").length;\n\t\t},\n\n\t\t_move: function _move(direction, filter, event) {\n\t\t\tvar next;\n\t\t\tif (this.active) {\n\t\t\t\tif (direction === \"first\" || direction === \"last\") {\n\t\t\t\t\tnext = this.active[direction === \"first\" ? \"prevAll\" : \"nextAll\"](\".ui-menu-item\").eq(-1);\n\t\t\t\t} else {\n\t\t\t\t\tnext = this.active[direction + \"All\"](\".ui-menu-item\").eq(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!next || !next.length || !this.active) {\n\t\t\t\tnext = this.activeMenu.find(this.options.items)[filter]();\n\t\t\t}\n\n\t\t\tthis.focus(event, next);\n\t\t},\n\n\t\tnextPage: function nextPage(event) {\n\t\t\tvar item, base, height;\n\n\t\t\tif (!this.active) {\n\t\t\t\tthis.next(event);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (this.isLastItem()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (this._hasScroll()) {\n\t\t\t\tbase = this.active.offset().top;\n\t\t\t\theight = this.element.height();\n\t\t\t\tthis.active.nextAll(\".ui-menu-item\").each(function () {\n\t\t\t\t\titem = $(this);\n\t\t\t\t\treturn item.offset().top - base - height < 0;\n\t\t\t\t});\n\n\t\t\t\tthis.focus(event, item);\n\t\t\t} else {\n\t\t\t\tthis.focus(event, this.activeMenu.find(this.options.items)[!this.active ? \"first\" : \"last\"]());\n\t\t\t}\n\t\t},\n\n\t\tpreviousPage: function previousPage(event) {\n\t\t\tvar item, base, height;\n\t\t\tif (!this.active) {\n\t\t\t\tthis.next(event);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (this.isFirstItem()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (this._hasScroll()) {\n\t\t\t\tbase = this.active.offset().top;\n\t\t\t\theight = this.element.height();\n\t\t\t\tthis.active.prevAll(\".ui-menu-item\").each(function () {\n\t\t\t\t\titem = $(this);\n\t\t\t\t\treturn item.offset().top - base + height > 0;\n\t\t\t\t});\n\n\t\t\t\tthis.focus(event, item);\n\t\t\t} else {\n\t\t\t\tthis.focus(event, this.activeMenu.find(this.options.items).first());\n\t\t\t}\n\t\t},\n\n\t\t_hasScroll: function _hasScroll() {\n\t\t\treturn this.element.outerHeight() < this.element.prop(\"scrollHeight\");\n\t\t},\n\n\t\tselect: function select(event) {\n\t\t\t// TODO: It should never be possible to not have an active item at this\n\t\t\t// point, but the tests don't trigger mouseenter before click.\n\t\t\tthis.active = this.active || $(event.target).closest(\".ui-menu-item\");\n\t\t\tvar ui = { item: this.active };\n\t\t\tif (!this.active.has(\".ui-menu\").length) {\n\t\t\t\tthis.collapseAll(event, true);\n\t\t\t}\n\t\t\tthis._trigger(\"select\", event, ui);\n\t\t},\n\n\t\t_filterMenuItems: function _filterMenuItems(character) {\n\t\t\tvar escapedCharacter = character.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g, \"\\\\$&\"),\n\t\t\t    regex = new RegExp(\"^\" + escapedCharacter, \"i\");\n\n\t\t\treturn this.activeMenu.find(this.options.items)\n\n\t\t\t// Only match on items, not dividers or other content (#10571)\n\t\t\t.filter(\".ui-menu-item\").filter(function () {\n\t\t\t\treturn regex.test($.trim($(this).text()));\n\t\t\t});\n\t\t}\n\t});\n\n\t/*!\n  * jQuery UI Autocomplete 1.11.4\n  * http://jqueryui.com\n  *\n  * Copyright jQuery Foundation and other contributors\n  * Released under the MIT license.\n  * http://jquery.org/license\n  *\n  * http://api.jqueryui.com/autocomplete/\n  */\n\n\t$.widget(\"ui.autocomplete\", {\n\t\tversion: \"1.11.4\",\n\t\tdefaultElement: \"<input>\",\n\t\toptions: {\n\t\t\tappendTo: null,\n\t\t\tautoFocus: false,\n\t\t\tdelay: 300,\n\t\t\tminLength: 1,\n\t\t\tposition: {\n\t\t\t\tmy: \"left top\",\n\t\t\t\tat: \"left bottom\",\n\t\t\t\tcollision: \"none\"\n\t\t\t},\n\t\t\tsource: null,\n\n\t\t\t// callbacks\n\t\t\tchange: null,\n\t\t\tclose: null,\n\t\t\tfocus: null,\n\t\t\topen: null,\n\t\t\tresponse: null,\n\t\t\tsearch: null,\n\t\t\tselect: null\n\t\t},\n\n\t\trequestIndex: 0,\n\t\tpending: 0,\n\n\t\t_create: function _create() {\n\t\t\t// Some browsers only repeat keydown events, not keypress events,\n\t\t\t// so we use the suppressKeyPress flag to determine if we've already\n\t\t\t// handled the keydown event. #7269\n\t\t\t// Unfortunately the code for & in keypress is the same as the up arrow,\n\t\t\t// so we use the suppressKeyPressRepeat flag to avoid handling keypress\n\t\t\t// events when we know the keydown event was used to modify the\n\t\t\t// search term. #7799\n\t\t\tvar suppressKeyPress,\n\t\t\t    suppressKeyPressRepeat,\n\t\t\t    suppressInput,\n\t\t\t    nodeName = this.element[0].nodeName.toLowerCase(),\n\t\t\t    isTextarea = nodeName === \"textarea\",\n\t\t\t    isInput = nodeName === \"input\";\n\n\t\t\tthis.isMultiLine =\n\t\t\t// Textareas are always multi-line\n\t\t\tisTextarea ? true :\n\t\t\t// Inputs are always single-line, even if inside a contentEditable element\n\t\t\t// IE also treats inputs as contentEditable\n\t\t\tisInput ? false :\n\t\t\t// All other element types are determined by whether or not they're contentEditable\n\t\t\tthis.element.prop(\"isContentEditable\");\n\n\t\t\tthis.valueMethod = this.element[isTextarea || isInput ? \"val\" : \"text\"];\n\t\t\tthis.isNewMenu = true;\n\n\t\t\tthis.element.addClass(\"ui-autocomplete-input\").attr(\"autocomplete\", \"off\");\n\n\t\t\tthis._on(this.element, {\n\t\t\t\tkeydown: function keydown(event) {\n\t\t\t\t\tif (this.element.prop(\"readOnly\")) {\n\t\t\t\t\t\tsuppressKeyPress = true;\n\t\t\t\t\t\tsuppressInput = true;\n\t\t\t\t\t\tsuppressKeyPressRepeat = true;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tsuppressKeyPress = false;\n\t\t\t\t\tsuppressInput = false;\n\t\t\t\t\tsuppressKeyPressRepeat = false;\n\t\t\t\t\tvar keyCode = $.ui.keyCode;\n\t\t\t\t\tswitch (event.keyCode) {\n\t\t\t\t\t\tcase keyCode.PAGE_UP:\n\t\t\t\t\t\t\tsuppressKeyPress = true;\n\t\t\t\t\t\t\tthis._move(\"previousPage\", event);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase keyCode.PAGE_DOWN:\n\t\t\t\t\t\t\tsuppressKeyPress = true;\n\t\t\t\t\t\t\tthis._move(\"nextPage\", event);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase keyCode.UP:\n\t\t\t\t\t\t\tsuppressKeyPress = true;\n\t\t\t\t\t\t\tthis._keyEvent(\"previous\", event);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase keyCode.DOWN:\n\t\t\t\t\t\t\tsuppressKeyPress = true;\n\t\t\t\t\t\t\tthis._keyEvent(\"next\", event);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase keyCode.ENTER:\n\t\t\t\t\t\t\t// when menu is open and has focus\n\t\t\t\t\t\t\tif (this.menu.active) {\n\t\t\t\t\t\t\t\t// #6055 - Opera still allows the keypress to occur\n\t\t\t\t\t\t\t\t// which causes forms to submit\n\t\t\t\t\t\t\t\tsuppressKeyPress = true;\n\t\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\t\tthis.menu.select(event);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase keyCode.TAB:\n\t\t\t\t\t\t\tif (this.menu.active) {\n\t\t\t\t\t\t\t\tthis.menu.select(event);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase keyCode.ESCAPE:\n\t\t\t\t\t\t\tif (this.menu.element.is(\":visible\")) {\n\t\t\t\t\t\t\t\tif (!this.isMultiLine) {\n\t\t\t\t\t\t\t\t\tthis._value(this.term);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthis.close(event);\n\t\t\t\t\t\t\t\t// Different browsers have different default behavior for escape\n\t\t\t\t\t\t\t\t// Single press can mean undo or clear\n\t\t\t\t\t\t\t\t// Double press in IE means clear the whole form\n\t\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tsuppressKeyPressRepeat = true;\n\t\t\t\t\t\t\t// search timeout should be triggered before the input value is changed\n\t\t\t\t\t\t\tthis._searchTimeout(event);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tkeypress: function keypress(event) {\n\t\t\t\t\tif (suppressKeyPress) {\n\t\t\t\t\t\tsuppressKeyPress = false;\n\t\t\t\t\t\tif (!this.isMultiLine || this.menu.element.is(\":visible\")) {\n\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (suppressKeyPressRepeat) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// replicate some key handlers to allow them to repeat in Firefox and Opera\n\t\t\t\t\tvar keyCode = $.ui.keyCode;\n\t\t\t\t\tswitch (event.keyCode) {\n\t\t\t\t\t\tcase keyCode.PAGE_UP:\n\t\t\t\t\t\t\tthis._move(\"previousPage\", event);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase keyCode.PAGE_DOWN:\n\t\t\t\t\t\t\tthis._move(\"nextPage\", event);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase keyCode.UP:\n\t\t\t\t\t\t\tthis._keyEvent(\"previous\", event);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase keyCode.DOWN:\n\t\t\t\t\t\t\tthis._keyEvent(\"next\", event);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tinput: function input(event) {\n\t\t\t\t\tif (suppressInput) {\n\t\t\t\t\t\tsuppressInput = false;\n\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tthis._searchTimeout(event);\n\t\t\t\t},\n\t\t\t\tfocus: function focus() {\n\t\t\t\t\tthis.selectedItem = null;\n\t\t\t\t\tthis.previous = this._value();\n\t\t\t\t},\n\t\t\t\tblur: function blur(event) {\n\t\t\t\t\tif (this.cancelBlur) {\n\t\t\t\t\t\tdelete this.cancelBlur;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tclearTimeout(this.searching);\n\t\t\t\t\tthis.close(event);\n\t\t\t\t\tthis._change(event);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tthis._initSource();\n\t\t\tthis.menu = $(\"<ul>\").addClass(\"ui-autocomplete ui-front\").appendTo(this._appendTo()).menu({\n\t\t\t\t// disable ARIA support, the live region takes care of that\n\t\t\t\trole: null\n\t\t\t}).hide().menu(\"instance\");\n\n\t\t\tthis._on(this.menu.element, {\n\t\t\t\tmousedown: function mousedown(event) {\n\t\t\t\t\t// prevent moving focus out of the text field\n\t\t\t\t\tevent.preventDefault();\n\n\t\t\t\t\t// IE doesn't prevent moving focus even with event.preventDefault()\n\t\t\t\t\t// so we set a flag to know when we should ignore the blur event\n\t\t\t\t\tthis.cancelBlur = true;\n\t\t\t\t\tthis._delay(function () {\n\t\t\t\t\t\tdelete this.cancelBlur;\n\t\t\t\t\t});\n\n\t\t\t\t\t// clicking on the scrollbar causes focus to shift to the body\n\t\t\t\t\t// but we can't detect a mouseup or a click immediately afterward\n\t\t\t\t\t// so we have to track the next mousedown and close the menu if\n\t\t\t\t\t// the user clicks somewhere outside of the autocomplete\n\t\t\t\t\tvar menuElement = this.menu.element[0];\n\t\t\t\t\tif (!$(event.target).closest(\".ui-menu-item\").length) {\n\t\t\t\t\t\tthis._delay(function () {\n\t\t\t\t\t\t\tvar that = this;\n\t\t\t\t\t\t\tthis.document.one(\"mousedown\", function (event) {\n\t\t\t\t\t\t\t\tif (event.target !== that.element[0] && event.target !== menuElement && !$.contains(menuElement, event.target)) {\n\t\t\t\t\t\t\t\t\tthat.close();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tmenufocus: function menufocus(event, ui) {\n\t\t\t\t\tvar label, item;\n\t\t\t\t\t// support: Firefox\n\t\t\t\t\t// Prevent accidental activation of menu items in Firefox (#7024 #9118)\n\t\t\t\t\tif (this.isNewMenu) {\n\t\t\t\t\t\tthis.isNewMenu = false;\n\t\t\t\t\t\tif (event.originalEvent && /^mouse/.test(event.originalEvent.type)) {\n\t\t\t\t\t\t\tthis.menu.blur();\n\n\t\t\t\t\t\t\tthis.document.one(\"mousemove\", function () {\n\t\t\t\t\t\t\t\t$(event.target).trigger(event.originalEvent);\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\titem = ui.item.data(\"ui-autocomplete-item\");\n\t\t\t\t\tif (false !== this._trigger(\"focus\", event, { item: item })) {\n\t\t\t\t\t\t// use value to match what will end up in the input, if it was a key event\n\t\t\t\t\t\tif (event.originalEvent && /^key/.test(event.originalEvent.type)) {\n\t\t\t\t\t\t\tthis._value(item.value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Announce the value in the liveRegion\n\t\t\t\t\tlabel = ui.item.attr(\"aria-label\") || item.value;\n\t\t\t\t\tif (label && $.trim(label).length) {\n\t\t\t\t\t\tthis.liveRegion.children().hide();\n\t\t\t\t\t\t$(\"<div>\").text(label).appendTo(this.liveRegion);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tmenuselect: function menuselect(event, ui) {\n\t\t\t\t\tvar item = ui.item.data(\"ui-autocomplete-item\"),\n\t\t\t\t\t    previous = this.previous;\n\n\t\t\t\t\t// only trigger when focus was lost (click on menu)\n\t\t\t\t\tif (this.element[0] !== this.document[0].activeElement) {\n\t\t\t\t\t\tthis.element.focus();\n\t\t\t\t\t\tthis.previous = previous;\n\t\t\t\t\t\t// #6109 - IE triggers two focus events and the second\n\t\t\t\t\t\t// is asynchronous, so we need to reset the previous\n\t\t\t\t\t\t// term synchronously and asynchronously :-(\n\t\t\t\t\t\tthis._delay(function () {\n\t\t\t\t\t\t\tthis.previous = previous;\n\t\t\t\t\t\t\tthis.selectedItem = item;\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\tif (false !== this._trigger(\"select\", event, { item: item })) {\n\t\t\t\t\t\tthis._value(item.value);\n\t\t\t\t\t}\n\t\t\t\t\t// reset the term after the select event\n\t\t\t\t\t// this allows custom select handling to work properly\n\t\t\t\t\tthis.term = this._value();\n\n\t\t\t\t\tthis.close(event);\n\t\t\t\t\tthis.selectedItem = item;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tthis.liveRegion = $(\"<span>\", {\n\t\t\t\trole: \"status\",\n\t\t\t\t\"aria-live\": \"assertive\",\n\t\t\t\t\"aria-relevant\": \"additions\"\n\t\t\t}).addClass(\"ui-helper-hidden-accessible\").appendTo(this.document[0].body);\n\n\t\t\t// turning off autocomplete prevents the browser from remembering the\n\t\t\t// value when navigating through history, so we re-enable autocomplete\n\t\t\t// if the page is unloaded before the widget is destroyed. #7790\n\t\t\tthis._on(this.window, {\n\t\t\t\tbeforeunload: function beforeunload() {\n\t\t\t\t\tthis.element.removeAttr(\"autocomplete\");\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\t_destroy: function _destroy() {\n\t\t\tclearTimeout(this.searching);\n\t\t\tthis.element.removeClass(\"ui-autocomplete-input\").removeAttr(\"autocomplete\");\n\t\t\tthis.menu.element.remove();\n\t\t\tthis.liveRegion.remove();\n\t\t},\n\n\t\t_setOption: function _setOption(key, value) {\n\t\t\tthis._super(key, value);\n\t\t\tif (key === \"source\") {\n\t\t\t\tthis._initSource();\n\t\t\t}\n\t\t\tif (key === \"appendTo\") {\n\t\t\t\tthis.menu.element.appendTo(this._appendTo());\n\t\t\t}\n\t\t\tif (key === \"disabled\" && value && this.xhr) {\n\t\t\t\tthis.xhr.abort();\n\t\t\t}\n\t\t},\n\n\t\t_appendTo: function _appendTo() {\n\t\t\tvar element = this.options.appendTo;\n\n\t\t\tif (element) {\n\t\t\t\telement = element.jquery || element.nodeType ? $(element) : this.document.find(element).eq(0);\n\t\t\t}\n\n\t\t\tif (!element || !element[0]) {\n\t\t\t\telement = this.element.closest(\".ui-front\");\n\t\t\t}\n\n\t\t\tif (!element.length) {\n\t\t\t\telement = this.document[0].body;\n\t\t\t}\n\n\t\t\treturn element;\n\t\t},\n\n\t\t_initSource: function _initSource() {\n\t\t\tvar array,\n\t\t\t    url,\n\t\t\t    that = this;\n\t\t\tif ($.isArray(this.options.source)) {\n\t\t\t\tarray = this.options.source;\n\t\t\t\tthis.source = function (request, response) {\n\t\t\t\t\tresponse($.ui.autocomplete.filter(array, request.term));\n\t\t\t\t};\n\t\t\t} else if (typeof this.options.source === \"string\") {\n\t\t\t\turl = this.options.source;\n\t\t\t\tthis.source = function (request, response) {\n\t\t\t\t\tif (that.xhr) {\n\t\t\t\t\t\tthat.xhr.abort();\n\t\t\t\t\t}\n\t\t\t\t\tthat.xhr = $.ajax({\n\t\t\t\t\t\turl: url,\n\t\t\t\t\t\tdata: request,\n\t\t\t\t\t\tdataType: \"json\",\n\t\t\t\t\t\tsuccess: function success(data) {\n\t\t\t\t\t\t\tresponse(data);\n\t\t\t\t\t\t},\n\t\t\t\t\t\terror: function error() {\n\t\t\t\t\t\t\tresponse([]);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tthis.source = this.options.source;\n\t\t\t}\n\t\t},\n\n\t\t_searchTimeout: function _searchTimeout(event) {\n\t\t\tclearTimeout(this.searching);\n\t\t\tthis.searching = this._delay(function () {\n\n\t\t\t\t// Search if the value has changed, or if the user retypes the same value (see #7434)\n\t\t\t\tvar equalValues = this.term === this._value(),\n\t\t\t\t    menuVisible = this.menu.element.is(\":visible\"),\n\t\t\t\t    modifierKey = event.altKey || event.ctrlKey || event.metaKey || event.shiftKey;\n\n\t\t\t\tif (!equalValues || equalValues && !menuVisible && !modifierKey) {\n\t\t\t\t\tthis.selectedItem = null;\n\t\t\t\t\tthis.search(null, event);\n\t\t\t\t}\n\t\t\t}, this.options.delay);\n\t\t},\n\n\t\tsearch: function search(value, event) {\n\t\t\tvalue = value != null ? value : this._value();\n\n\t\t\t// always save the actual value, not the one passed as an argument\n\t\t\tthis.term = this._value();\n\n\t\t\tif (value.length < this.options.minLength) {\n\t\t\t\treturn this.close(event);\n\t\t\t}\n\n\t\t\tif (this._trigger(\"search\", event) === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\treturn this._search(value);\n\t\t},\n\n\t\t_search: function _search(value) {\n\t\t\tthis.pending++;\n\t\t\tthis.element.addClass(\"ui-autocomplete-loading\");\n\t\t\tthis.cancelSearch = false;\n\n\t\t\tthis.source({ term: value }, this._response());\n\t\t},\n\n\t\t_response: function _response() {\n\t\t\tvar index = ++this.requestIndex;\n\n\t\t\treturn $.proxy(function (content) {\n\t\t\t\tif (index === this.requestIndex) {\n\t\t\t\t\tthis.__response(content);\n\t\t\t\t}\n\n\t\t\t\tthis.pending--;\n\t\t\t\tif (!this.pending) {\n\t\t\t\t\tthis.element.removeClass(\"ui-autocomplete-loading\");\n\t\t\t\t}\n\t\t\t}, this);\n\t\t},\n\n\t\t__response: function __response(content) {\n\t\t\tif (content) {\n\t\t\t\tcontent = this._normalize(content);\n\t\t\t}\n\t\t\tthis._trigger(\"response\", null, { content: content });\n\t\t\tif (!this.options.disabled && content && content.length && !this.cancelSearch) {\n\t\t\t\tthis._suggest(content);\n\t\t\t\tthis._trigger(\"open\");\n\t\t\t} else {\n\t\t\t\t// use ._close() instead of .close() so we don't cancel future searches\n\t\t\t\tthis._close();\n\t\t\t}\n\t\t},\n\n\t\tclose: function close(event) {\n\t\t\tthis.cancelSearch = true;\n\t\t\tthis._close(event);\n\t\t},\n\n\t\t_close: function _close(event) {\n\t\t\tif (this.menu.element.is(\":visible\")) {\n\t\t\t\tthis.menu.element.hide();\n\t\t\t\tthis.menu.blur();\n\t\t\t\tthis.isNewMenu = true;\n\t\t\t\tthis._trigger(\"close\", event);\n\t\t\t}\n\t\t},\n\n\t\t_change: function _change(event) {\n\t\t\tif (this.previous !== this._value()) {\n\t\t\t\tthis._trigger(\"change\", event, { item: this.selectedItem });\n\t\t\t}\n\t\t},\n\n\t\t_normalize: function _normalize(items) {\n\t\t\t// assume all items have the right format when the first item is complete\n\t\t\tif (items.length && items[0].label && items[0].value) {\n\t\t\t\treturn items;\n\t\t\t}\n\t\t\treturn $.map(items, function (item) {\n\t\t\t\tif (typeof item === \"string\") {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tlabel: item,\n\t\t\t\t\t\tvalue: item\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\treturn $.extend({}, item, {\n\t\t\t\t\tlabel: item.label || item.value,\n\t\t\t\t\tvalue: item.value || item.label\n\t\t\t\t});\n\t\t\t});\n\t\t},\n\n\t\t_suggest: function _suggest(items) {\n\t\t\tvar ul = this.menu.element.empty();\n\t\t\tthis._renderMenu(ul, items);\n\t\t\tthis.isNewMenu = true;\n\t\t\tthis.menu.refresh();\n\n\t\t\t// size and position menu\n\t\t\tul.show();\n\t\t\tthis._resizeMenu();\n\t\t\tul.position($.extend({\n\t\t\t\tof: this.element\n\t\t\t}, this.options.position));\n\n\t\t\tif (this.options.autoFocus) {\n\t\t\t\tthis.menu.next();\n\t\t\t}\n\t\t},\n\n\t\t_resizeMenu: function _resizeMenu() {\n\t\t\tvar ul = this.menu.element;\n\t\t\tul.outerWidth(Math.max(\n\t\t\t// Firefox wraps long text (possibly a rounding bug)\n\t\t\t// so we add 1px to avoid the wrapping (#7513)\n\t\t\tul.width(\"\").outerWidth() + 1, this.element.outerWidth()));\n\t\t},\n\n\t\t_renderMenu: function _renderMenu(ul, items) {\n\t\t\tvar that = this;\n\t\t\t$.each(items, function (index, item) {\n\t\t\t\tthat._renderItemData(ul, item);\n\t\t\t});\n\t\t},\n\n\t\t_renderItemData: function _renderItemData(ul, item) {\n\t\t\treturn this._renderItem(ul, item).data(\"ui-autocomplete-item\", item);\n\t\t},\n\n\t\t_renderItem: function _renderItem(ul, item) {\n\t\t\treturn $(\"<li>\").text(item.label).appendTo(ul);\n\t\t},\n\n\t\t_move: function _move(direction, event) {\n\t\t\tif (!this.menu.element.is(\":visible\")) {\n\t\t\t\tthis.search(null, event);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (this.menu.isFirstItem() && /^previous/.test(direction) || this.menu.isLastItem() && /^next/.test(direction)) {\n\n\t\t\t\tif (!this.isMultiLine) {\n\t\t\t\t\tthis._value(this.term);\n\t\t\t\t}\n\n\t\t\t\tthis.menu.blur();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.menu[direction](event);\n\t\t},\n\n\t\twidget: function widget() {\n\t\t\treturn this.menu.element;\n\t\t},\n\n\t\t_value: function _value() {\n\t\t\treturn this.valueMethod.apply(this.element, arguments);\n\t\t},\n\n\t\t_keyEvent: function _keyEvent(keyEvent, event) {\n\t\t\tif (!this.isMultiLine || this.menu.element.is(\":visible\")) {\n\t\t\t\tthis._move(keyEvent, event);\n\n\t\t\t\t// prevents moving cursor to beginning/end of the text field in some browsers\n\t\t\t\tevent.preventDefault();\n\t\t\t}\n\t\t}\n\t});\n\n\t$.extend($.ui.autocomplete, {\n\t\tescapeRegex: function escapeRegex(value) {\n\t\t\treturn value.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g, \"\\\\$&\");\n\t\t},\n\t\tfilter: function filter(array, term) {\n\t\t\tvar matcher = new RegExp($.ui.autocomplete.escapeRegex(term), \"i\");\n\t\t\treturn $.grep(array, function (value) {\n\t\t\t\treturn matcher.test(value.label || value.value || value);\n\t\t\t});\n\t\t}\n\t});\n\n\t// live region extension, adding a `messages` option\n\t// NOTE: This is an experimental API. We are still investigating\n\t// a full solution for string manipulation and internationalization.\n\t$.widget(\"ui.autocomplete\", $.ui.autocomplete, {\n\t\toptions: {\n\t\t\tmessages: {\n\t\t\t\tnoResults: \"No search results.\",\n\t\t\t\tresults: function results(amount) {\n\t\t\t\t\treturn amount + (amount > 1 ? \" results are\" : \" result is\") + \" available, use up and down arrow keys to navigate.\";\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t__response: function __response(content) {\n\t\t\tvar message;\n\t\t\tthis._superApply(arguments);\n\t\t\tif (this.options.disabled || this.cancelSearch) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (content && content.length) {\n\t\t\t\tmessage = this.options.messages.results(content.length);\n\t\t\t} else {\n\t\t\t\tmessage = this.options.messages.noResults;\n\t\t\t}\n\t\t\tthis.liveRegion.children().hide();\n\t\t\t$(\"<div>\").text(message).appendTo(this.liveRegion);\n\t\t}\n\t});\n\n\tvar autocomplete = $.ui.autocomplete;\n\n\t/*!\n  * jQuery UI Button 1.11.4\n  * http://jqueryui.com\n  *\n  * Copyright jQuery Foundation and other contributors\n  * Released under the MIT license.\n  * http://jquery.org/license\n  *\n  * http://api.jqueryui.com/button/\n  */\n\n\tvar lastActive,\n\t    baseClasses = \"ui-button ui-widget ui-state-default ui-corner-all\",\n\t    typeClasses = \"ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only\",\n\t    formResetHandler = function formResetHandler() {\n\t\tvar form = $(this);\n\t\tsetTimeout(function () {\n\t\t\tform.find(\":ui-button\").button(\"refresh\");\n\t\t}, 1);\n\t},\n\t    radioGroup = function radioGroup(radio) {\n\t\tvar name = radio.name,\n\t\t    form = radio.form,\n\t\t    radios = $([]);\n\t\tif (name) {\n\t\t\tname = name.replace(/'/g, \"\\\\'\");\n\t\t\tif (form) {\n\t\t\t\tradios = $(form).find(\"[name='\" + name + \"'][type=radio]\");\n\t\t\t} else {\n\t\t\t\tradios = $(\"[name='\" + name + \"'][type=radio]\", radio.ownerDocument).filter(function () {\n\t\t\t\t\treturn !this.form;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn radios;\n\t};\n\n\t$.widget(\"ui.button\", {\n\t\tversion: \"1.11.4\",\n\t\tdefaultElement: \"<button>\",\n\t\toptions: {\n\t\t\tdisabled: null,\n\t\t\ttext: true,\n\t\t\tlabel: null,\n\t\t\ticons: {\n\t\t\t\tprimary: null,\n\t\t\t\tsecondary: null\n\t\t\t}\n\t\t},\n\t\t_create: function _create() {\n\t\t\tthis.element.closest(\"form\").unbind(\"reset\" + this.eventNamespace).bind(\"reset\" + this.eventNamespace, formResetHandler);\n\n\t\t\tif (typeof this.options.disabled !== \"boolean\") {\n\t\t\t\tthis.options.disabled = !!this.element.prop(\"disabled\");\n\t\t\t} else {\n\t\t\t\tthis.element.prop(\"disabled\", this.options.disabled);\n\t\t\t}\n\n\t\t\tthis._determineButtonType();\n\t\t\tthis.hasTitle = !!this.buttonElement.attr(\"title\");\n\n\t\t\tvar that = this,\n\t\t\t    options = this.options,\n\t\t\t    toggleButton = this.type === \"checkbox\" || this.type === \"radio\",\n\t\t\t    activeClass = !toggleButton ? \"ui-state-active\" : \"\";\n\n\t\t\tif (options.label === null) {\n\t\t\t\toptions.label = this.type === \"input\" ? this.buttonElement.val() : this.buttonElement.html();\n\t\t\t}\n\n\t\t\tthis._hoverable(this.buttonElement);\n\n\t\t\tthis.buttonElement.addClass(baseClasses).attr(\"role\", \"button\").bind(\"mouseenter\" + this.eventNamespace, function () {\n\t\t\t\tif (options.disabled) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (this === lastActive) {\n\t\t\t\t\t$(this).addClass(\"ui-state-active\");\n\t\t\t\t}\n\t\t\t}).bind(\"mouseleave\" + this.eventNamespace, function () {\n\t\t\t\tif (options.disabled) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t$(this).removeClass(activeClass);\n\t\t\t}).bind(\"click\" + this.eventNamespace, function (event) {\n\t\t\t\tif (options.disabled) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\tevent.stopImmediatePropagation();\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Can't use _focusable() because the element that receives focus\n\t\t\t// and the element that gets the ui-state-focus class are different\n\t\t\tthis._on({\n\t\t\t\tfocus: function focus() {\n\t\t\t\t\tthis.buttonElement.addClass(\"ui-state-focus\");\n\t\t\t\t},\n\t\t\t\tblur: function blur() {\n\t\t\t\t\tthis.buttonElement.removeClass(\"ui-state-focus\");\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (toggleButton) {\n\t\t\t\tthis.element.bind(\"change\" + this.eventNamespace, function () {\n\t\t\t\t\tthat.refresh();\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (this.type === \"checkbox\") {\n\t\t\t\tthis.buttonElement.bind(\"click\" + this.eventNamespace, function () {\n\t\t\t\t\tif (options.disabled) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else if (this.type === \"radio\") {\n\t\t\t\tthis.buttonElement.bind(\"click\" + this.eventNamespace, function () {\n\t\t\t\t\tif (options.disabled) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\t$(this).addClass(\"ui-state-active\");\n\t\t\t\t\tthat.buttonElement.attr(\"aria-pressed\", \"true\");\n\n\t\t\t\t\tvar radio = that.element[0];\n\t\t\t\t\tradioGroup(radio).not(radio).map(function () {\n\t\t\t\t\t\treturn $(this).button(\"widget\")[0];\n\t\t\t\t\t}).removeClass(\"ui-state-active\").attr(\"aria-pressed\", \"false\");\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthis.buttonElement.bind(\"mousedown\" + this.eventNamespace, function () {\n\t\t\t\t\tif (options.disabled) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\t$(this).addClass(\"ui-state-active\");\n\t\t\t\t\tlastActive = this;\n\t\t\t\t\tthat.document.one(\"mouseup\", function () {\n\t\t\t\t\t\tlastActive = null;\n\t\t\t\t\t});\n\t\t\t\t}).bind(\"mouseup\" + this.eventNamespace, function () {\n\t\t\t\t\tif (options.disabled) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\t$(this).removeClass(\"ui-state-active\");\n\t\t\t\t}).bind(\"keydown\" + this.eventNamespace, function (event) {\n\t\t\t\t\tif (options.disabled) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tif (event.keyCode === $.ui.keyCode.SPACE || event.keyCode === $.ui.keyCode.ENTER) {\n\t\t\t\t\t\t$(this).addClass(\"ui-state-active\");\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t// see #8559, we bind to blur here in case the button element loses\n\t\t\t\t// focus between keydown and keyup, it would be left in an \"active\" state\n\t\t\t\t.bind(\"keyup\" + this.eventNamespace + \" blur\" + this.eventNamespace, function () {\n\t\t\t\t\t$(this).removeClass(\"ui-state-active\");\n\t\t\t\t});\n\n\t\t\t\tif (this.buttonElement.is(\"a\")) {\n\t\t\t\t\tthis.buttonElement.keyup(function (event) {\n\t\t\t\t\t\tif (event.keyCode === $.ui.keyCode.SPACE) {\n\t\t\t\t\t\t\t// TODO pass through original event correctly (just as 2nd argument doesn't work)\n\t\t\t\t\t\t\t$(this).click();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._setOption(\"disabled\", options.disabled);\n\t\t\tthis._resetButton();\n\t\t},\n\n\t\t_determineButtonType: function _determineButtonType() {\n\t\t\tvar ancestor, labelSelector, checked;\n\n\t\t\tif (this.element.is(\"[type=checkbox]\")) {\n\t\t\t\tthis.type = \"checkbox\";\n\t\t\t} else if (this.element.is(\"[type=radio]\")) {\n\t\t\t\tthis.type = \"radio\";\n\t\t\t} else if (this.element.is(\"input\")) {\n\t\t\t\tthis.type = \"input\";\n\t\t\t} else {\n\t\t\t\tthis.type = \"button\";\n\t\t\t}\n\n\t\t\tif (this.type === \"checkbox\" || this.type === \"radio\") {\n\t\t\t\t// we don't search against the document in case the element\n\t\t\t\t// is disconnected from the DOM\n\t\t\t\tancestor = this.element.parents().last();\n\t\t\t\tlabelSelector = \"label[for='\" + this.element.attr(\"id\") + \"']\";\n\t\t\t\tthis.buttonElement = ancestor.find(labelSelector);\n\t\t\t\tif (!this.buttonElement.length) {\n\t\t\t\t\tancestor = ancestor.length ? ancestor.siblings() : this.element.siblings();\n\t\t\t\t\tthis.buttonElement = ancestor.filter(labelSelector);\n\t\t\t\t\tif (!this.buttonElement.length) {\n\t\t\t\t\t\tthis.buttonElement = ancestor.find(labelSelector);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.element.addClass(\"ui-helper-hidden-accessible\");\n\n\t\t\t\tchecked = this.element.is(\":checked\");\n\t\t\t\tif (checked) {\n\t\t\t\t\tthis.buttonElement.addClass(\"ui-state-active\");\n\t\t\t\t}\n\t\t\t\tthis.buttonElement.prop(\"aria-pressed\", checked);\n\t\t\t} else {\n\t\t\t\tthis.buttonElement = this.element;\n\t\t\t}\n\t\t},\n\n\t\twidget: function widget() {\n\t\t\treturn this.buttonElement;\n\t\t},\n\n\t\t_destroy: function _destroy() {\n\t\t\tthis.element.removeClass(\"ui-helper-hidden-accessible\");\n\t\t\tthis.buttonElement.removeClass(baseClasses + \" ui-state-active \" + typeClasses).removeAttr(\"role\").removeAttr(\"aria-pressed\").html(this.buttonElement.find(\".ui-button-text\").html());\n\n\t\t\tif (!this.hasTitle) {\n\t\t\t\tthis.buttonElement.removeAttr(\"title\");\n\t\t\t}\n\t\t},\n\n\t\t_setOption: function _setOption(key, value) {\n\t\t\tthis._super(key, value);\n\t\t\tif (key === \"disabled\") {\n\t\t\t\tthis.widget().toggleClass(\"ui-state-disabled\", !!value);\n\t\t\t\tthis.element.prop(\"disabled\", !!value);\n\t\t\t\tif (value) {\n\t\t\t\t\tif (this.type === \"checkbox\" || this.type === \"radio\") {\n\t\t\t\t\t\tthis.buttonElement.removeClass(\"ui-state-focus\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.buttonElement.removeClass(\"ui-state-focus ui-state-active\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis._resetButton();\n\t\t},\n\n\t\trefresh: function refresh() {\n\t\t\t//See #8237 & #8828\n\t\t\tvar isDisabled = this.element.is(\"input, button\") ? this.element.is(\":disabled\") : this.element.hasClass(\"ui-button-disabled\");\n\n\t\t\tif (isDisabled !== this.options.disabled) {\n\t\t\t\tthis._setOption(\"disabled\", isDisabled);\n\t\t\t}\n\t\t\tif (this.type === \"radio\") {\n\t\t\t\tradioGroup(this.element[0]).each(function () {\n\t\t\t\t\tif ($(this).is(\":checked\")) {\n\t\t\t\t\t\t$(this).button(\"widget\").addClass(\"ui-state-active\").attr(\"aria-pressed\", \"true\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$(this).button(\"widget\").removeClass(\"ui-state-active\").attr(\"aria-pressed\", \"false\");\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else if (this.type === \"checkbox\") {\n\t\t\t\tif (this.element.is(\":checked\")) {\n\t\t\t\t\tthis.buttonElement.addClass(\"ui-state-active\").attr(\"aria-pressed\", \"true\");\n\t\t\t\t} else {\n\t\t\t\t\tthis.buttonElement.removeClass(\"ui-state-active\").attr(\"aria-pressed\", \"false\");\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t_resetButton: function _resetButton() {\n\t\t\tif (this.type === \"input\") {\n\t\t\t\tif (this.options.label) {\n\t\t\t\t\tthis.element.val(this.options.label);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar buttonElement = this.buttonElement.removeClass(typeClasses),\n\t\t\t    buttonText = $(\"<span></span>\", this.document[0]).addClass(\"ui-button-text\").html(this.options.label).appendTo(buttonElement.empty()).text(),\n\t\t\t    icons = this.options.icons,\n\t\t\t    multipleIcons = icons.primary && icons.secondary,\n\t\t\t    buttonClasses = [];\n\n\t\t\tif (icons.primary || icons.secondary) {\n\t\t\t\tif (this.options.text) {\n\t\t\t\t\tbuttonClasses.push(\"ui-button-text-icon\" + (multipleIcons ? \"s\" : icons.primary ? \"-primary\" : \"-secondary\"));\n\t\t\t\t}\n\n\t\t\t\tif (icons.primary) {\n\t\t\t\t\tbuttonElement.prepend(\"<span class='ui-button-icon-primary ui-icon \" + icons.primary + \"'></span>\");\n\t\t\t\t}\n\n\t\t\t\tif (icons.secondary) {\n\t\t\t\t\tbuttonElement.append(\"<span class='ui-button-icon-secondary ui-icon \" + icons.secondary + \"'></span>\");\n\t\t\t\t}\n\n\t\t\t\tif (!this.options.text) {\n\t\t\t\t\tbuttonClasses.push(multipleIcons ? \"ui-button-icons-only\" : \"ui-button-icon-only\");\n\n\t\t\t\t\tif (!this.hasTitle) {\n\t\t\t\t\t\tbuttonElement.attr(\"title\", $.trim(buttonText));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbuttonClasses.push(\"ui-button-text-only\");\n\t\t\t}\n\t\t\tbuttonElement.addClass(buttonClasses.join(\" \"));\n\t\t}\n\t});\n\n\t$.widget(\"ui.buttonset\", {\n\t\tversion: \"1.11.4\",\n\t\toptions: {\n\t\t\titems: \"button, input[type=button], input[type=submit], input[type=reset], input[type=checkbox], input[type=radio], a, :data(ui-button)\"\n\t\t},\n\n\t\t_create: function _create() {\n\t\t\tthis.element.addClass(\"ui-buttonset\");\n\t\t},\n\n\t\t_init: function _init() {\n\t\t\tthis.refresh();\n\t\t},\n\n\t\t_setOption: function _setOption(key, value) {\n\t\t\tif (key === \"disabled\") {\n\t\t\t\tthis.buttons.button(\"option\", key, value);\n\t\t\t}\n\n\t\t\tthis._super(key, value);\n\t\t},\n\n\t\trefresh: function refresh() {\n\t\t\tvar rtl = this.element.css(\"direction\") === \"rtl\",\n\t\t\t    allButtons = this.element.find(this.options.items),\n\t\t\t    existingButtons = allButtons.filter(\":ui-button\");\n\n\t\t\t// Initialize new buttons\n\t\t\tallButtons.not(\":ui-button\").button();\n\n\t\t\t// Refresh existing buttons\n\t\t\texistingButtons.button(\"refresh\");\n\n\t\t\tthis.buttons = allButtons.map(function () {\n\t\t\t\treturn $(this).button(\"widget\")[0];\n\t\t\t}).removeClass(\"ui-corner-all ui-corner-left ui-corner-right\").filter(\":first\").addClass(rtl ? \"ui-corner-right\" : \"ui-corner-left\").end().filter(\":last\").addClass(rtl ? \"ui-corner-left\" : \"ui-corner-right\").end().end();\n\t\t},\n\n\t\t_destroy: function _destroy() {\n\t\t\tthis.element.removeClass(\"ui-buttonset\");\n\t\t\tthis.buttons.map(function () {\n\t\t\t\treturn $(this).button(\"widget\")[0];\n\t\t\t}).removeClass(\"ui-corner-left ui-corner-right\").end().button(\"destroy\");\n\t\t}\n\t});\n\n\tvar button = $.ui.button;\n\n\t/*!\n  * jQuery UI Datepicker 1.11.4\n  * http://jqueryui.com\n  *\n  * Copyright jQuery Foundation and other contributors\n  * Released under the MIT license.\n  * http://jquery.org/license\n  *\n  * http://api.jqueryui.com/datepicker/\n  */\n\n\t$.extend($.ui, { datepicker: { version: \"1.11.4\" } });\n\n\tvar datepicker_instActive;\n\n\tfunction datepicker_getZindex(elem) {\n\t\tvar position, value;\n\t\twhile (elem.length && elem[0] !== document) {\n\t\t\t// Ignore z-index if position is set to a value where z-index is ignored by the browser\n\t\t\t// This makes behavior of this function consistent across browsers\n\t\t\t// WebKit always returns auto if the element is positioned\n\t\t\tposition = elem.css(\"position\");\n\t\t\tif (position === \"absolute\" || position === \"relative\" || position === \"fixed\") {\n\t\t\t\t// IE returns 0 when zIndex is not specified\n\t\t\t\t// other browsers return a string\n\t\t\t\t// we ignore the case of nested elements with an explicit value of 0\n\t\t\t\t// <div style=\"z-index: -10;\"><div style=\"z-index: 0;\"></div></div>\n\t\t\t\tvalue = parseInt(elem.css(\"zIndex\"), 10);\n\t\t\t\tif (!isNaN(value) && value !== 0) {\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t}\n\t\t\telem = elem.parent();\n\t\t}\n\n\t\treturn 0;\n\t}\n\t/* Date picker manager.\n    Use the singleton instance of this class, $.datepicker, to interact with the date picker.\n    Settings for (groups of) date pickers are maintained in an instance object,\n    allowing multiple different settings on the same page. */\n\n\tfunction Datepicker() {\n\t\tthis._curInst = null; // The current instance in use\n\t\tthis._keyEvent = false; // If the last event was a key event\n\t\tthis._disabledInputs = []; // List of date picker inputs that have been disabled\n\t\tthis._datepickerShowing = false; // True if the popup picker is showing , false if not\n\t\tthis._inDialog = false; // True if showing within a \"dialog\", false if not\n\t\tthis._mainDivId = \"ui-datepicker-div\"; // The ID of the main datepicker division\n\t\tthis._inlineClass = \"ui-datepicker-inline\"; // The name of the inline marker class\n\t\tthis._appendClass = \"ui-datepicker-append\"; // The name of the append marker class\n\t\tthis._triggerClass = \"ui-datepicker-trigger\"; // The name of the trigger marker class\n\t\tthis._dialogClass = \"ui-datepicker-dialog\"; // The name of the dialog marker class\n\t\tthis._disableClass = \"ui-datepicker-disabled\"; // The name of the disabled covering marker class\n\t\tthis._unselectableClass = \"ui-datepicker-unselectable\"; // The name of the unselectable cell marker class\n\t\tthis._currentClass = \"ui-datepicker-current-day\"; // The name of the current day marker class\n\t\tthis._dayOverClass = \"ui-datepicker-days-cell-over\"; // The name of the day hover marker class\n\t\tthis.regional = []; // Available regional settings, indexed by language code\n\t\tthis.regional[\"\"] = { // Default regional settings\n\t\t\tcloseText: \"Done\", // Display text for close link\n\t\t\tprevText: \"Prev\", // Display text for previous month link\n\t\t\tnextText: \"Next\", // Display text for next month link\n\t\t\tcurrentText: \"Today\", // Display text for current month link\n\t\t\tmonthNames: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"], // Names of months for drop-down and formatting\n\t\t\tmonthNamesShort: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"], // For formatting\n\t\t\tdayNames: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"], // For formatting\n\t\t\tdayNamesShort: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"], // For formatting\n\t\t\tdayNamesMin: [\"Su\", \"Mo\", \"Tu\", \"We\", \"Th\", \"Fr\", \"Sa\"], // Column headings for days starting at Sunday\n\t\t\tweekHeader: \"Wk\", // Column header for week of the year\n\t\t\tdateFormat: \"mm/dd/yy\", // See format options on parseDate\n\t\t\tfirstDay: 0, // The first day of the week, Sun = 0, Mon = 1, ...\n\t\t\tisRTL: false, // True if right-to-left language, false if left-to-right\n\t\t\tshowMonthAfterYear: false, // True if the year select precedes month, false for month then year\n\t\t\tyearSuffix: \"\" // Additional text to append to the year in the month headers\n\t\t};\n\t\tthis._defaults = { // Global defaults for all the date picker instances\n\t\t\tshowOn: \"focus\", // \"focus\" for popup on focus,\n\t\t\t// \"button\" for trigger button, or \"both\" for either\n\t\t\tshowAnim: \"fadeIn\", // Name of jQuery animation for popup\n\t\t\tshowOptions: {}, // Options for enhanced animations\n\t\t\tdefaultDate: null, // Used when field is blank: actual date,\n\t\t\t// +/-number for offset from today, null for today\n\t\t\tappendText: \"\", // Display text following the input box, e.g. showing the format\n\t\t\tbuttonText: \"...\", // Text for trigger button\n\t\t\tbuttonImage: \"\", // URL for trigger button image\n\t\t\tbuttonImageOnly: false, // True if the image appears alone, false if it appears on a button\n\t\t\thideIfNoPrevNext: false, // True to hide next/previous month links\n\t\t\t// if not applicable, false to just disable them\n\t\t\tnavigationAsDateFormat: false, // True if date formatting applied to prev/today/next links\n\t\t\tgotoCurrent: false, // True if today link goes back to current selection instead\n\t\t\tchangeMonth: false, // True if month can be selected directly, false if only prev/next\n\t\t\tchangeYear: false, // True if year can be selected directly, false if only prev/next\n\t\t\tyearRange: \"c-10:c+10\", // Range of years to display in drop-down,\n\t\t\t// either relative to today's year (-nn:+nn), relative to currently displayed year\n\t\t\t// (c-nn:c+nn), absolute (nnnn:nnnn), or a combination of the above (nnnn:-n)\n\t\t\tshowOtherMonths: false, // True to show dates in other months, false to leave blank\n\t\t\tselectOtherMonths: false, // True to allow selection of dates in other months, false for unselectable\n\t\t\tshowWeek: false, // True to show week of the year, false to not show it\n\t\t\tcalculateWeek: this.iso8601Week, // How to calculate the week of the year,\n\t\t\t// takes a Date and returns the number of the week for it\n\t\t\tshortYearCutoff: \"+10\", // Short year values < this are in the current century,\n\t\t\t// > this are in the previous century,\n\t\t\t// string value starting with \"+\" for current year + value\n\t\t\tminDate: null, // The earliest selectable date, or null for no limit\n\t\t\tmaxDate: null, // The latest selectable date, or null for no limit\n\t\t\tduration: \"fast\", // Duration of display/closure\n\t\t\tbeforeShowDay: null, // Function that takes a date and returns an array with\n\t\t\t// [0] = true if selectable, false if not, [1] = custom CSS class name(s) or \"\",\n\t\t\t// [2] = cell title (optional), e.g. $.datepicker.noWeekends\n\t\t\tbeforeShow: null, // Function that takes an input field and\n\t\t\t// returns a set of custom settings for the date picker\n\t\t\tonSelect: null, // Define a callback function when a date is selected\n\t\t\tonChangeMonthYear: null, // Define a callback function when the month or year is changed\n\t\t\tonClose: null, // Define a callback function when the datepicker is closed\n\t\t\tnumberOfMonths: 1, // Number of months to show at a time\n\t\t\tshowCurrentAtPos: 0, // The position in multipe months at which to show the current month (starting at 0)\n\t\t\tstepMonths: 1, // Number of months to step back/forward\n\t\t\tstepBigMonths: 12, // Number of months to step back/forward for the big links\n\t\t\taltField: \"\", // Selector for an alternate field to store selected dates into\n\t\t\taltFormat: \"\", // The date format to use for the alternate field\n\t\t\tconstrainInput: true, // The input is constrained by the current date format\n\t\t\tshowButtonPanel: false, // True to show button panel, false to not show it\n\t\t\tautoSize: false, // True to size the input for the date format, false to leave as is\n\t\t\tdisabled: false // The initial disabled state\n\t\t};\n\t\t$.extend(this._defaults, this.regional[\"\"]);\n\t\tthis.regional.en = $.extend(true, {}, this.regional[\"\"]);\n\t\tthis.regional[\"en-US\"] = $.extend(true, {}, this.regional.en);\n\t\tthis.dpDiv = datepicker_bindHover($(\"<div id='\" + this._mainDivId + \"' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>\"));\n\t}\n\n\t$.extend(Datepicker.prototype, {\n\t\t/* Class name added to elements to indicate already configured with a date picker. */\n\t\tmarkerClassName: \"hasDatepicker\",\n\n\t\t//Keep track of the maximum number of rows displayed (see #7043)\n\t\tmaxRows: 4,\n\n\t\t// TODO rename to \"widget\" when switching to widget factory\n\t\t_widgetDatepicker: function _widgetDatepicker() {\n\t\t\treturn this.dpDiv;\n\t\t},\n\n\t\t/* Override the default settings for all instances of the date picker.\n   * @param  settings  object - the new settings to use as defaults (anonymous object)\n   * @return the manager object\n   */\n\t\tsetDefaults: function setDefaults(settings) {\n\t\t\tdatepicker_extendRemove(this._defaults, settings || {});\n\t\t\treturn this;\n\t\t},\n\n\t\t/* Attach the date picker to a jQuery selection.\n   * @param  target\telement - the target input field or division or span\n   * @param  settings  object - the new settings to use for this date picker instance (anonymous)\n   */\n\t\t_attachDatepicker: function _attachDatepicker(target, settings) {\n\t\t\tvar nodeName, inline, inst;\n\t\t\tnodeName = target.nodeName.toLowerCase();\n\t\t\tinline = nodeName === \"div\" || nodeName === \"span\";\n\t\t\tif (!target.id) {\n\t\t\t\tthis.uuid += 1;\n\t\t\t\ttarget.id = \"dp\" + this.uuid;\n\t\t\t}\n\t\t\tinst = this._newInst($(target), inline);\n\t\t\tinst.settings = $.extend({}, settings || {});\n\t\t\tif (nodeName === \"input\") {\n\t\t\t\tthis._connectDatepicker(target, inst);\n\t\t\t} else if (inline) {\n\t\t\t\tthis._inlineDatepicker(target, inst);\n\t\t\t}\n\t\t},\n\n\t\t/* Create a new instance object. */\n\t\t_newInst: function _newInst(target, inline) {\n\t\t\tvar id = target[0].id.replace(/([^A-Za-z0-9_\\-])/g, \"\\\\\\\\$1\"); // escape jQuery meta chars\n\t\t\treturn { id: id, input: target, // associated target\n\t\t\t\tselectedDay: 0, selectedMonth: 0, selectedYear: 0, // current selection\n\t\t\t\tdrawMonth: 0, drawYear: 0, // month being drawn\n\t\t\t\tinline: inline, // is datepicker inline or not\n\t\t\t\tdpDiv: !inline ? this.dpDiv : // presentation div\n\t\t\t\tdatepicker_bindHover($(\"<div class='\" + this._inlineClass + \" ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>\")) };\n\t\t},\n\n\t\t/* Attach the date picker to an input field. */\n\t\t_connectDatepicker: function _connectDatepicker(target, inst) {\n\t\t\tvar input = $(target);\n\t\t\tinst.append = $([]);\n\t\t\tinst.trigger = $([]);\n\t\t\tif (input.hasClass(this.markerClassName)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis._attachments(input, inst);\n\t\t\tinput.addClass(this.markerClassName).keydown(this._doKeyDown).keypress(this._doKeyPress).keyup(this._doKeyUp);\n\t\t\tthis._autoSize(inst);\n\t\t\t$.data(target, \"datepicker\", inst);\n\t\t\t//If disabled option is true, disable the datepicker once it has been attached to the input (see ticket #5665)\n\t\t\tif (inst.settings.disabled) {\n\t\t\t\tthis._disableDatepicker(target);\n\t\t\t}\n\t\t},\n\n\t\t/* Make attachments based on settings. */\n\t\t_attachments: function _attachments(input, inst) {\n\t\t\tvar showOn,\n\t\t\t    buttonText,\n\t\t\t    buttonImage,\n\t\t\t    appendText = this._get(inst, \"appendText\"),\n\t\t\t    isRTL = this._get(inst, \"isRTL\");\n\n\t\t\tif (inst.append) {\n\t\t\t\tinst.append.remove();\n\t\t\t}\n\t\t\tif (appendText) {\n\t\t\t\tinst.append = $(\"<span class='\" + this._appendClass + \"'>\" + appendText + \"</span>\");\n\t\t\t\tinput[isRTL ? \"before\" : \"after\"](inst.append);\n\t\t\t}\n\n\t\t\tinput.unbind(\"focus\", this._showDatepicker);\n\n\t\t\tif (inst.trigger) {\n\t\t\t\tinst.trigger.remove();\n\t\t\t}\n\n\t\t\tshowOn = this._get(inst, \"showOn\");\n\t\t\tif (showOn === \"focus\" || showOn === \"both\") {\n\t\t\t\t// pop-up date picker when in the marked field\n\t\t\t\tinput.focus(this._showDatepicker);\n\t\t\t}\n\t\t\tif (showOn === \"button\" || showOn === \"both\") {\n\t\t\t\t// pop-up date picker when button clicked\n\t\t\t\tbuttonText = this._get(inst, \"buttonText\");\n\t\t\t\tbuttonImage = this._get(inst, \"buttonImage\");\n\t\t\t\tinst.trigger = $(this._get(inst, \"buttonImageOnly\") ? $(\"<img/>\").addClass(this._triggerClass).attr({ src: buttonImage, alt: buttonText, title: buttonText }) : $(\"<button type='button'></button>\").addClass(this._triggerClass).html(!buttonImage ? buttonText : $(\"<img/>\").attr({ src: buttonImage, alt: buttonText, title: buttonText })));\n\t\t\t\tinput[isRTL ? \"before\" : \"after\"](inst.trigger);\n\t\t\t\tinst.trigger.click(function () {\n\t\t\t\t\tif ($.datepicker._datepickerShowing && $.datepicker._lastInput === input[0]) {\n\t\t\t\t\t\t$.datepicker._hideDatepicker();\n\t\t\t\t\t} else if ($.datepicker._datepickerShowing && $.datepicker._lastInput !== input[0]) {\n\t\t\t\t\t\t$.datepicker._hideDatepicker();\n\t\t\t\t\t\t$.datepicker._showDatepicker(input[0]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$.datepicker._showDatepicker(input[0]);\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\n\t\t/* Apply the maximum length for the date format. */\n\t\t_autoSize: function _autoSize(inst) {\n\t\t\tif (this._get(inst, \"autoSize\") && !inst.inline) {\n\t\t\t\tvar findMax,\n\t\t\t\t    max,\n\t\t\t\t    maxI,\n\t\t\t\t    i,\n\t\t\t\t    date = new Date(2009, 12 - 1, 20),\n\t\t\t\t    // Ensure double digits\n\t\t\t\tdateFormat = this._get(inst, \"dateFormat\");\n\n\t\t\t\tif (dateFormat.match(/[DM]/)) {\n\t\t\t\t\tfindMax = function findMax(names) {\n\t\t\t\t\t\tmax = 0;\n\t\t\t\t\t\tmaxI = 0;\n\t\t\t\t\t\tfor (i = 0; i < names.length; i++) {\n\t\t\t\t\t\t\tif (names[i].length > max) {\n\t\t\t\t\t\t\t\tmax = names[i].length;\n\t\t\t\t\t\t\t\tmaxI = i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn maxI;\n\t\t\t\t\t};\n\t\t\t\t\tdate.setMonth(findMax(this._get(inst, dateFormat.match(/MM/) ? \"monthNames\" : \"monthNamesShort\")));\n\t\t\t\t\tdate.setDate(findMax(this._get(inst, dateFormat.match(/DD/) ? \"dayNames\" : \"dayNamesShort\")) + 20 - date.getDay());\n\t\t\t\t}\n\t\t\t\tinst.input.attr(\"size\", this._formatDate(inst, date).length);\n\t\t\t}\n\t\t},\n\n\t\t/* Attach an inline date picker to a div. */\n\t\t_inlineDatepicker: function _inlineDatepicker(target, inst) {\n\t\t\tvar divSpan = $(target);\n\t\t\tif (divSpan.hasClass(this.markerClassName)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tdivSpan.addClass(this.markerClassName).append(inst.dpDiv);\n\t\t\t$.data(target, \"datepicker\", inst);\n\t\t\tthis._setDate(inst, this._getDefaultDate(inst), true);\n\t\t\tthis._updateDatepicker(inst);\n\t\t\tthis._updateAlternate(inst);\n\t\t\t//If disabled option is true, disable the datepicker before showing it (see ticket #5665)\n\t\t\tif (inst.settings.disabled) {\n\t\t\t\tthis._disableDatepicker(target);\n\t\t\t}\n\t\t\t// Set display:block in place of inst.dpDiv.show() which won't work on disconnected elements\n\t\t\t// http://bugs.jqueryui.com/ticket/7552 - A Datepicker created on a detached div has zero height\n\t\t\tinst.dpDiv.css(\"display\", \"block\");\n\t\t},\n\n\t\t/* Pop-up the date picker in a \"dialog\" box.\n   * @param  input element - ignored\n   * @param  date\tstring or Date - the initial date to display\n   * @param  onSelect  function - the function to call when a date is selected\n   * @param  settings  object - update the dialog date picker instance's settings (anonymous object)\n   * @param  pos int[2] - coordinates for the dialog's position within the screen or\n   *\t\t\t\t\tevent - with x/y coordinates or\n   *\t\t\t\t\tleave empty for default (screen centre)\n   * @return the manager object\n   */\n\t\t_dialogDatepicker: function _dialogDatepicker(input, date, onSelect, settings, pos) {\n\t\t\tvar id,\n\t\t\t    browserWidth,\n\t\t\t    browserHeight,\n\t\t\t    scrollX,\n\t\t\t    scrollY,\n\t\t\t    inst = this._dialogInst; // internal instance\n\n\t\t\tif (!inst) {\n\t\t\t\tthis.uuid += 1;\n\t\t\t\tid = \"dp\" + this.uuid;\n\t\t\t\tthis._dialogInput = $(\"<input type='text' id='\" + id + \"' style='position: absolute; top: -100px; width: 0px;'/>\");\n\t\t\t\tthis._dialogInput.keydown(this._doKeyDown);\n\t\t\t\t$(\"body\").append(this._dialogInput);\n\t\t\t\tinst = this._dialogInst = this._newInst(this._dialogInput, false);\n\t\t\t\tinst.settings = {};\n\t\t\t\t$.data(this._dialogInput[0], \"datepicker\", inst);\n\t\t\t}\n\t\t\tdatepicker_extendRemove(inst.settings, settings || {});\n\t\t\tdate = date && date.constructor === Date ? this._formatDate(inst, date) : date;\n\t\t\tthis._dialogInput.val(date);\n\n\t\t\tthis._pos = pos ? pos.length ? pos : [pos.pageX, pos.pageY] : null;\n\t\t\tif (!this._pos) {\n\t\t\t\tbrowserWidth = document.documentElement.clientWidth;\n\t\t\t\tbrowserHeight = document.documentElement.clientHeight;\n\t\t\t\tscrollX = document.documentElement.scrollLeft || document.body.scrollLeft;\n\t\t\t\tscrollY = document.documentElement.scrollTop || document.body.scrollTop;\n\t\t\t\tthis._pos = // should use actual width/height below\n\t\t\t\t[browserWidth / 2 - 100 + scrollX, browserHeight / 2 - 150 + scrollY];\n\t\t\t}\n\n\t\t\t// move input on screen for focus, but hidden behind dialog\n\t\t\tthis._dialogInput.css(\"left\", this._pos[0] + 20 + \"px\").css(\"top\", this._pos[1] + \"px\");\n\t\t\tinst.settings.onSelect = onSelect;\n\t\t\tthis._inDialog = true;\n\t\t\tthis.dpDiv.addClass(this._dialogClass);\n\t\t\tthis._showDatepicker(this._dialogInput[0]);\n\t\t\tif ($.blockUI) {\n\t\t\t\t$.blockUI(this.dpDiv);\n\t\t\t}\n\t\t\t$.data(this._dialogInput[0], \"datepicker\", inst);\n\t\t\treturn this;\n\t\t},\n\n\t\t/* Detach a datepicker from its control.\n   * @param  target\telement - the target input field or division or span\n   */\n\t\t_destroyDatepicker: function _destroyDatepicker(target) {\n\t\t\tvar nodeName,\n\t\t\t    $target = $(target),\n\t\t\t    inst = $.data(target, \"datepicker\");\n\n\t\t\tif (!$target.hasClass(this.markerClassName)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tnodeName = target.nodeName.toLowerCase();\n\t\t\t$.removeData(target, \"datepicker\");\n\t\t\tif (nodeName === \"input\") {\n\t\t\t\tinst.append.remove();\n\t\t\t\tinst.trigger.remove();\n\t\t\t\t$target.removeClass(this.markerClassName).unbind(\"focus\", this._showDatepicker).unbind(\"keydown\", this._doKeyDown).unbind(\"keypress\", this._doKeyPress).unbind(\"keyup\", this._doKeyUp);\n\t\t\t} else if (nodeName === \"div\" || nodeName === \"span\") {\n\t\t\t\t$target.removeClass(this.markerClassName).empty();\n\t\t\t}\n\n\t\t\tif (datepicker_instActive === inst) {\n\t\t\t\tdatepicker_instActive = null;\n\t\t\t}\n\t\t},\n\n\t\t/* Enable the date picker to a jQuery selection.\n   * @param  target\telement - the target input field or division or span\n   */\n\t\t_enableDatepicker: function _enableDatepicker(target) {\n\t\t\tvar nodeName,\n\t\t\t    inline,\n\t\t\t    $target = $(target),\n\t\t\t    inst = $.data(target, \"datepicker\");\n\n\t\t\tif (!$target.hasClass(this.markerClassName)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tnodeName = target.nodeName.toLowerCase();\n\t\t\tif (nodeName === \"input\") {\n\t\t\t\ttarget.disabled = false;\n\t\t\t\tinst.trigger.filter(\"button\").each(function () {\n\t\t\t\t\tthis.disabled = false;\n\t\t\t\t}).end().filter(\"img\").css({ opacity: \"1.0\", cursor: \"\" });\n\t\t\t} else if (nodeName === \"div\" || nodeName === \"span\") {\n\t\t\t\tinline = $target.children(\".\" + this._inlineClass);\n\t\t\t\tinline.children().removeClass(\"ui-state-disabled\");\n\t\t\t\tinline.find(\"select.ui-datepicker-month, select.ui-datepicker-year\").prop(\"disabled\", false);\n\t\t\t}\n\t\t\tthis._disabledInputs = $.map(this._disabledInputs, function (value) {\n\t\t\t\treturn value === target ? null : value;\n\t\t\t}); // delete entry\n\t\t},\n\n\t\t/* Disable the date picker to a jQuery selection.\n   * @param  target\telement - the target input field or division or span\n   */\n\t\t_disableDatepicker: function _disableDatepicker(target) {\n\t\t\tvar nodeName,\n\t\t\t    inline,\n\t\t\t    $target = $(target),\n\t\t\t    inst = $.data(target, \"datepicker\");\n\n\t\t\tif (!$target.hasClass(this.markerClassName)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tnodeName = target.nodeName.toLowerCase();\n\t\t\tif (nodeName === \"input\") {\n\t\t\t\ttarget.disabled = true;\n\t\t\t\tinst.trigger.filter(\"button\").each(function () {\n\t\t\t\t\tthis.disabled = true;\n\t\t\t\t}).end().filter(\"img\").css({ opacity: \"0.5\", cursor: \"default\" });\n\t\t\t} else if (nodeName === \"div\" || nodeName === \"span\") {\n\t\t\t\tinline = $target.children(\".\" + this._inlineClass);\n\t\t\t\tinline.children().addClass(\"ui-state-disabled\");\n\t\t\t\tinline.find(\"select.ui-datepicker-month, select.ui-datepicker-year\").prop(\"disabled\", true);\n\t\t\t}\n\t\t\tthis._disabledInputs = $.map(this._disabledInputs, function (value) {\n\t\t\t\treturn value === target ? null : value;\n\t\t\t}); // delete entry\n\t\t\tthis._disabledInputs[this._disabledInputs.length] = target;\n\t\t},\n\n\t\t/* Is the first field in a jQuery collection disabled as a datepicker?\n   * @param  target\telement - the target input field or division or span\n   * @return boolean - true if disabled, false if enabled\n   */\n\t\t_isDisabledDatepicker: function _isDisabledDatepicker(target) {\n\t\t\tif (!target) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (var i = 0; i < this._disabledInputs.length; i++) {\n\t\t\t\tif (this._disabledInputs[i] === target) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\n\t\t/* Retrieve the instance data for the target control.\n   * @param  target  element - the target input field or division or span\n   * @return  object - the associated instance data\n   * @throws  error if a jQuery problem getting data\n   */\n\t\t_getInst: function _getInst(target) {\n\t\t\ttry {\n\t\t\t\treturn $.data(target, \"datepicker\");\n\t\t\t} catch (err) {\n\t\t\t\tthrow \"Missing instance data for this datepicker\";\n\t\t\t}\n\t\t},\n\n\t\t/* Update or retrieve the settings for a date picker attached to an input field or division.\n   * @param  target  element - the target input field or division or span\n   * @param  name\tobject - the new settings to update or\n   *\t\t\t\tstring - the name of the setting to change or retrieve,\n   *\t\t\t\twhen retrieving also \"all\" for all instance settings or\n   *\t\t\t\t\"defaults\" for all global defaults\n   * @param  value   any - the new value for the setting\n   *\t\t\t\t(omit if above is an object or to retrieve a value)\n   */\n\t\t_optionDatepicker: function _optionDatepicker(target, name, value) {\n\t\t\tvar settings,\n\t\t\t    date,\n\t\t\t    minDate,\n\t\t\t    maxDate,\n\t\t\t    inst = this._getInst(target);\n\n\t\t\tif (arguments.length === 2 && typeof name === \"string\") {\n\t\t\t\treturn name === \"defaults\" ? $.extend({}, $.datepicker._defaults) : inst ? name === \"all\" ? $.extend({}, inst.settings) : this._get(inst, name) : null;\n\t\t\t}\n\n\t\t\tsettings = name || {};\n\t\t\tif (typeof name === \"string\") {\n\t\t\t\tsettings = {};\n\t\t\t\tsettings[name] = value;\n\t\t\t}\n\n\t\t\tif (inst) {\n\t\t\t\tif (this._curInst === inst) {\n\t\t\t\t\tthis._hideDatepicker();\n\t\t\t\t}\n\n\t\t\t\tdate = this._getDateDatepicker(target, true);\n\t\t\t\tminDate = this._getMinMaxDate(inst, \"min\");\n\t\t\t\tmaxDate = this._getMinMaxDate(inst, \"max\");\n\t\t\t\tdatepicker_extendRemove(inst.settings, settings);\n\t\t\t\t// reformat the old minDate/maxDate values if dateFormat changes and a new minDate/maxDate isn't provided\n\t\t\t\tif (minDate !== null && settings.dateFormat !== undefined && settings.minDate === undefined) {\n\t\t\t\t\tinst.settings.minDate = this._formatDate(inst, minDate);\n\t\t\t\t}\n\t\t\t\tif (maxDate !== null && settings.dateFormat !== undefined && settings.maxDate === undefined) {\n\t\t\t\t\tinst.settings.maxDate = this._formatDate(inst, maxDate);\n\t\t\t\t}\n\t\t\t\tif (\"disabled\" in settings) {\n\t\t\t\t\tif (settings.disabled) {\n\t\t\t\t\t\tthis._disableDatepicker(target);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._enableDatepicker(target);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis._attachments($(target), inst);\n\t\t\t\tthis._autoSize(inst);\n\t\t\t\tthis._setDate(inst, date);\n\t\t\t\tthis._updateAlternate(inst);\n\t\t\t\tthis._updateDatepicker(inst);\n\t\t\t}\n\t\t},\n\n\t\t// change method deprecated\n\t\t_changeDatepicker: function _changeDatepicker(target, name, value) {\n\t\t\tthis._optionDatepicker(target, name, value);\n\t\t},\n\n\t\t/* Redraw the date picker attached to an input field or division.\n   * @param  target  element - the target input field or division or span\n   */\n\t\t_refreshDatepicker: function _refreshDatepicker(target) {\n\t\t\tvar inst = this._getInst(target);\n\t\t\tif (inst) {\n\t\t\t\tthis._updateDatepicker(inst);\n\t\t\t}\n\t\t},\n\n\t\t/* Set the dates for a jQuery selection.\n   * @param  target element - the target input field or division or span\n   * @param  date\tDate - the new date\n   */\n\t\t_setDateDatepicker: function _setDateDatepicker(target, date) {\n\t\t\tvar inst = this._getInst(target);\n\t\t\tif (inst) {\n\t\t\t\tthis._setDate(inst, date);\n\t\t\t\tthis._updateDatepicker(inst);\n\t\t\t\tthis._updateAlternate(inst);\n\t\t\t}\n\t\t},\n\n\t\t/* Get the date(s) for the first entry in a jQuery selection.\n   * @param  target element - the target input field or division or span\n   * @param  noDefault boolean - true if no default date is to be used\n   * @return Date - the current date\n   */\n\t\t_getDateDatepicker: function _getDateDatepicker(target, noDefault) {\n\t\t\tvar inst = this._getInst(target);\n\t\t\tif (inst && !inst.inline) {\n\t\t\t\tthis._setDateFromField(inst, noDefault);\n\t\t\t}\n\t\t\treturn inst ? this._getDate(inst) : null;\n\t\t},\n\n\t\t/* Handle keystrokes. */\n\t\t_doKeyDown: function _doKeyDown(event) {\n\t\t\tvar onSelect,\n\t\t\t    dateStr,\n\t\t\t    sel,\n\t\t\t    inst = $.datepicker._getInst(event.target),\n\t\t\t    handled = true,\n\t\t\t    isRTL = inst.dpDiv.is(\".ui-datepicker-rtl\");\n\n\t\t\tinst._keyEvent = true;\n\t\t\tif ($.datepicker._datepickerShowing) {\n\t\t\t\tswitch (event.keyCode) {\n\t\t\t\t\tcase 9:\n\t\t\t\t\t\t$.datepicker._hideDatepicker();\n\t\t\t\t\t\thandled = false;\n\t\t\t\t\t\tbreak; // hide on tab out\n\t\t\t\t\tcase 13:\n\t\t\t\t\t\tsel = $(\"td.\" + $.datepicker._dayOverClass + \":not(.\" + $.datepicker._currentClass + \")\", inst.dpDiv);\n\t\t\t\t\t\tif (sel[0]) {\n\t\t\t\t\t\t\t$.datepicker._selectDay(event.target, inst.selectedMonth, inst.selectedYear, sel[0]);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tonSelect = $.datepicker._get(inst, \"onSelect\");\n\t\t\t\t\t\tif (onSelect) {\n\t\t\t\t\t\t\tdateStr = $.datepicker._formatDate(inst);\n\n\t\t\t\t\t\t\t// trigger custom callback\n\t\t\t\t\t\t\tonSelect.apply(inst.input ? inst.input[0] : null, [dateStr, inst]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$.datepicker._hideDatepicker();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn false; // don't submit the form\n\t\t\t\t\tcase 27:\n\t\t\t\t\t\t$.datepicker._hideDatepicker();\n\t\t\t\t\t\tbreak; // hide on escape\n\t\t\t\t\tcase 33:\n\t\t\t\t\t\t$.datepicker._adjustDate(event.target, event.ctrlKey ? -$.datepicker._get(inst, \"stepBigMonths\") : -$.datepicker._get(inst, \"stepMonths\"), \"M\");\n\t\t\t\t\t\tbreak; // previous month/year on page up/+ ctrl\n\t\t\t\t\tcase 34:\n\t\t\t\t\t\t$.datepicker._adjustDate(event.target, event.ctrlKey ? +$.datepicker._get(inst, \"stepBigMonths\") : +$.datepicker._get(inst, \"stepMonths\"), \"M\");\n\t\t\t\t\t\tbreak; // next month/year on page down/+ ctrl\n\t\t\t\t\tcase 35:\n\t\t\t\t\t\tif (event.ctrlKey || event.metaKey) {\n\t\t\t\t\t\t\t$.datepicker._clearDate(event.target);\n\t\t\t\t\t\t}\n\t\t\t\t\t\thandled = event.ctrlKey || event.metaKey;\n\t\t\t\t\t\tbreak; // clear on ctrl or command +end\n\t\t\t\t\tcase 36:\n\t\t\t\t\t\tif (event.ctrlKey || event.metaKey) {\n\t\t\t\t\t\t\t$.datepicker._gotoToday(event.target);\n\t\t\t\t\t\t}\n\t\t\t\t\t\thandled = event.ctrlKey || event.metaKey;\n\t\t\t\t\t\tbreak; // current on ctrl or command +home\n\t\t\t\t\tcase 37:\n\t\t\t\t\t\tif (event.ctrlKey || event.metaKey) {\n\t\t\t\t\t\t\t$.datepicker._adjustDate(event.target, isRTL ? +1 : -1, \"D\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\thandled = event.ctrlKey || event.metaKey;\n\t\t\t\t\t\t// -1 day on ctrl or command +left\n\t\t\t\t\t\tif (event.originalEvent.altKey) {\n\t\t\t\t\t\t\t$.datepicker._adjustDate(event.target, event.ctrlKey ? -$.datepicker._get(inst, \"stepBigMonths\") : -$.datepicker._get(inst, \"stepMonths\"), \"M\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// next month/year on alt +left on Mac\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 38:\n\t\t\t\t\t\tif (event.ctrlKey || event.metaKey) {\n\t\t\t\t\t\t\t$.datepicker._adjustDate(event.target, -7, \"D\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\thandled = event.ctrlKey || event.metaKey;\n\t\t\t\t\t\tbreak; // -1 week on ctrl or command +up\n\t\t\t\t\tcase 39:\n\t\t\t\t\t\tif (event.ctrlKey || event.metaKey) {\n\t\t\t\t\t\t\t$.datepicker._adjustDate(event.target, isRTL ? -1 : +1, \"D\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\thandled = event.ctrlKey || event.metaKey;\n\t\t\t\t\t\t// +1 day on ctrl or command +right\n\t\t\t\t\t\tif (event.originalEvent.altKey) {\n\t\t\t\t\t\t\t$.datepicker._adjustDate(event.target, event.ctrlKey ? +$.datepicker._get(inst, \"stepBigMonths\") : +$.datepicker._get(inst, \"stepMonths\"), \"M\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// next month/year on alt +right\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 40:\n\t\t\t\t\t\tif (event.ctrlKey || event.metaKey) {\n\t\t\t\t\t\t\t$.datepicker._adjustDate(event.target, +7, \"D\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\thandled = event.ctrlKey || event.metaKey;\n\t\t\t\t\t\tbreak; // +1 week on ctrl or command +down\n\t\t\t\t\tdefault:\n\t\t\t\t\t\thandled = false;\n\t\t\t\t}\n\t\t\t} else if (event.keyCode === 36 && event.ctrlKey) {\n\t\t\t\t// display the date picker on ctrl+home\n\t\t\t\t$.datepicker._showDatepicker(this);\n\t\t\t} else {\n\t\t\t\thandled = false;\n\t\t\t}\n\n\t\t\tif (handled) {\n\t\t\t\tevent.preventDefault();\n\t\t\t\tevent.stopPropagation();\n\t\t\t}\n\t\t},\n\n\t\t/* Filter entered characters - based on date format. */\n\t\t_doKeyPress: function _doKeyPress(event) {\n\t\t\tvar chars,\n\t\t\t    chr,\n\t\t\t    inst = $.datepicker._getInst(event.target);\n\n\t\t\tif ($.datepicker._get(inst, \"constrainInput\")) {\n\t\t\t\tchars = $.datepicker._possibleChars($.datepicker._get(inst, \"dateFormat\"));\n\t\t\t\tchr = String.fromCharCode(event.charCode == null ? event.keyCode : event.charCode);\n\t\t\t\treturn event.ctrlKey || event.metaKey || chr < \" \" || !chars || chars.indexOf(chr) > -1;\n\t\t\t}\n\t\t},\n\n\t\t/* Synchronise manual entry and field/alternate field. */\n\t\t_doKeyUp: function _doKeyUp(event) {\n\t\t\tvar date,\n\t\t\t    inst = $.datepicker._getInst(event.target);\n\n\t\t\tif (inst.input.val() !== inst.lastVal) {\n\t\t\t\ttry {\n\t\t\t\t\tdate = $.datepicker.parseDate($.datepicker._get(inst, \"dateFormat\"), inst.input ? inst.input.val() : null, $.datepicker._getFormatConfig(inst));\n\n\t\t\t\t\tif (date) {\n\t\t\t\t\t\t// only if valid\n\t\t\t\t\t\t$.datepicker._setDateFromField(inst);\n\t\t\t\t\t\t$.datepicker._updateAlternate(inst);\n\t\t\t\t\t\t$.datepicker._updateDatepicker(inst);\n\t\t\t\t\t}\n\t\t\t\t} catch (err) {}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\t/* Pop-up the date picker for a given input field.\n   * If false returned from beforeShow event handler do not show.\n   * @param  input  element - the input field attached to the date picker or\n   *\t\t\t\t\tevent - if triggered by focus\n   */\n\t\t_showDatepicker: function _showDatepicker(input) {\n\t\t\tinput = input.target || input;\n\t\t\tif (input.nodeName.toLowerCase() !== \"input\") {\n\t\t\t\t// find from button/image trigger\n\t\t\t\tinput = $(\"input\", input.parentNode)[0];\n\t\t\t}\n\n\t\t\tif ($.datepicker._isDisabledDatepicker(input) || $.datepicker._lastInput === input) {\n\t\t\t\t// already here\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar inst, beforeShow, beforeShowSettings, isFixed, offset, showAnim, duration;\n\n\t\t\tinst = $.datepicker._getInst(input);\n\t\t\tif ($.datepicker._curInst && $.datepicker._curInst !== inst) {\n\t\t\t\t$.datepicker._curInst.dpDiv.stop(true, true);\n\t\t\t\tif (inst && $.datepicker._datepickerShowing) {\n\t\t\t\t\t$.datepicker._hideDatepicker($.datepicker._curInst.input[0]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbeforeShow = $.datepicker._get(inst, \"beforeShow\");\n\t\t\tbeforeShowSettings = beforeShow ? beforeShow.apply(input, [input, inst]) : {};\n\t\t\tif (beforeShowSettings === false) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tdatepicker_extendRemove(inst.settings, beforeShowSettings);\n\n\t\t\tinst.lastVal = null;\n\t\t\t$.datepicker._lastInput = input;\n\t\t\t$.datepicker._setDateFromField(inst);\n\n\t\t\tif ($.datepicker._inDialog) {\n\t\t\t\t// hide cursor\n\t\t\t\tinput.value = \"\";\n\t\t\t}\n\t\t\tif (!$.datepicker._pos) {\n\t\t\t\t// position below input\n\t\t\t\t$.datepicker._pos = $.datepicker._findPos(input);\n\t\t\t\t$.datepicker._pos[1] += input.offsetHeight; // add the height\n\t\t\t}\n\n\t\t\tisFixed = false;\n\t\t\t$(input).parents().each(function () {\n\t\t\t\tisFixed |= $(this).css(\"position\") === \"fixed\";\n\t\t\t\treturn !isFixed;\n\t\t\t});\n\n\t\t\toffset = { left: $.datepicker._pos[0], top: $.datepicker._pos[1] };\n\t\t\t$.datepicker._pos = null;\n\t\t\t//to avoid flashes on Firefox\n\t\t\tinst.dpDiv.empty();\n\t\t\t// determine sizing offscreen\n\t\t\tinst.dpDiv.css({ position: \"absolute\", display: \"block\", top: \"-1000px\" });\n\t\t\t$.datepicker._updateDatepicker(inst);\n\t\t\t// fix width for dynamic number of date pickers\n\t\t\t// and adjust position before showing\n\t\t\toffset = $.datepicker._checkOffset(inst, offset, isFixed);\n\t\t\tinst.dpDiv.css({ position: $.datepicker._inDialog && $.blockUI ? \"static\" : isFixed ? \"fixed\" : \"absolute\", display: \"none\",\n\t\t\t\tleft: offset.left + \"px\", top: offset.top + \"px\" });\n\n\t\t\tif (!inst.inline) {\n\t\t\t\tshowAnim = $.datepicker._get(inst, \"showAnim\");\n\t\t\t\tduration = $.datepicker._get(inst, \"duration\");\n\t\t\t\tinst.dpDiv.css(\"z-index\", datepicker_getZindex($(input)) + 1);\n\t\t\t\t$.datepicker._datepickerShowing = true;\n\n\t\t\t\tif ($.effects && $.effects.effect[showAnim]) {\n\t\t\t\t\tinst.dpDiv.show(showAnim, $.datepicker._get(inst, \"showOptions\"), duration);\n\t\t\t\t} else {\n\t\t\t\t\tinst.dpDiv[showAnim || \"show\"](showAnim ? duration : null);\n\t\t\t\t}\n\n\t\t\t\tif ($.datepicker._shouldFocusInput(inst)) {\n\t\t\t\t\tinst.input.focus();\n\t\t\t\t}\n\n\t\t\t\t$.datepicker._curInst = inst;\n\t\t\t}\n\t\t},\n\n\t\t/* Generate the date picker content. */\n\t\t_updateDatepicker: function _updateDatepicker(inst) {\n\t\t\tthis.maxRows = 4; //Reset the max number of rows being displayed (see #7043)\n\t\t\tdatepicker_instActive = inst; // for delegate hover events\n\t\t\tinst.dpDiv.empty().append(this._generateHTML(inst));\n\t\t\tthis._attachHandlers(inst);\n\n\t\t\tvar origyearshtml,\n\t\t\t    numMonths = this._getNumberOfMonths(inst),\n\t\t\t    cols = numMonths[1],\n\t\t\t    width = 17,\n\t\t\t    activeCell = inst.dpDiv.find(\".\" + this._dayOverClass + \" a\");\n\n\t\t\tif (activeCell.length > 0) {\n\t\t\t\tdatepicker_handleMouseover.apply(activeCell.get(0));\n\t\t\t}\n\n\t\t\tinst.dpDiv.removeClass(\"ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4\").width(\"\");\n\t\t\tif (cols > 1) {\n\t\t\t\tinst.dpDiv.addClass(\"ui-datepicker-multi-\" + cols).css(\"width\", width * cols + \"em\");\n\t\t\t}\n\t\t\tinst.dpDiv[(numMonths[0] !== 1 || numMonths[1] !== 1 ? \"add\" : \"remove\") + \"Class\"](\"ui-datepicker-multi\");\n\t\t\tinst.dpDiv[(this._get(inst, \"isRTL\") ? \"add\" : \"remove\") + \"Class\"](\"ui-datepicker-rtl\");\n\n\t\t\tif (inst === $.datepicker._curInst && $.datepicker._datepickerShowing && $.datepicker._shouldFocusInput(inst)) {\n\t\t\t\tinst.input.focus();\n\t\t\t}\n\n\t\t\t// deffered render of the years select (to avoid flashes on Firefox)\n\t\t\tif (inst.yearshtml) {\n\t\t\t\torigyearshtml = inst.yearshtml;\n\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t//assure that inst.yearshtml didn't change.\n\t\t\t\t\tif (origyearshtml === inst.yearshtml && inst.yearshtml) {\n\t\t\t\t\t\tinst.dpDiv.find(\"select.ui-datepicker-year:first\").replaceWith(inst.yearshtml);\n\t\t\t\t\t}\n\t\t\t\t\torigyearshtml = inst.yearshtml = null;\n\t\t\t\t}, 0);\n\t\t\t}\n\t\t},\n\n\t\t// #6694 - don't focus the input if it's already focused\n\t\t// this breaks the change event in IE\n\t\t// Support: IE and jQuery <1.9\n\t\t_shouldFocusInput: function _shouldFocusInput(inst) {\n\t\t\treturn inst.input && inst.input.is(\":visible\") && !inst.input.is(\":disabled\") && !inst.input.is(\":focus\");\n\t\t},\n\n\t\t/* Check positioning to remain on screen. */\n\t\t_checkOffset: function _checkOffset(inst, offset, isFixed) {\n\t\t\tvar dpWidth = inst.dpDiv.outerWidth(),\n\t\t\t    dpHeight = inst.dpDiv.outerHeight(),\n\t\t\t    inputWidth = inst.input ? inst.input.outerWidth() : 0,\n\t\t\t    inputHeight = inst.input ? inst.input.outerHeight() : 0,\n\t\t\t    viewWidth = document.documentElement.clientWidth + (isFixed ? 0 : $(document).scrollLeft()),\n\t\t\t    viewHeight = document.documentElement.clientHeight + (isFixed ? 0 : $(document).scrollTop());\n\n\t\t\toffset.left -= this._get(inst, \"isRTL\") ? dpWidth - inputWidth : 0;\n\t\t\toffset.left -= isFixed && offset.left === inst.input.offset().left ? $(document).scrollLeft() : 0;\n\t\t\toffset.top -= isFixed && offset.top === inst.input.offset().top + inputHeight ? $(document).scrollTop() : 0;\n\n\t\t\t// now check if datepicker is showing outside window viewport - move to a better place if so.\n\t\t\toffset.left -= Math.min(offset.left, offset.left + dpWidth > viewWidth && viewWidth > dpWidth ? Math.abs(offset.left + dpWidth - viewWidth) : 0);\n\t\t\toffset.top -= Math.min(offset.top, offset.top + dpHeight > viewHeight && viewHeight > dpHeight ? Math.abs(dpHeight + inputHeight) : 0);\n\n\t\t\treturn offset;\n\t\t},\n\n\t\t/* Find an object's position on the screen. */\n\t\t_findPos: function _findPos(obj) {\n\t\t\tvar position,\n\t\t\t    inst = this._getInst(obj),\n\t\t\t    isRTL = this._get(inst, \"isRTL\");\n\n\t\t\twhile (obj && (obj.type === \"hidden\" || obj.nodeType !== 1 || $.expr.filters.hidden(obj))) {\n\t\t\t\tobj = obj[isRTL ? \"previousSibling\" : \"nextSibling\"];\n\t\t\t}\n\n\t\t\tposition = $(obj).offset();\n\t\t\treturn [position.left, position.top];\n\t\t},\n\n\t\t/* Hide the date picker from view.\n   * @param  input  element - the input field attached to the date picker\n   */\n\t\t_hideDatepicker: function _hideDatepicker(input) {\n\t\t\tvar showAnim,\n\t\t\t    duration,\n\t\t\t    postProcess,\n\t\t\t    onClose,\n\t\t\t    inst = this._curInst;\n\n\t\t\tif (!inst || input && inst !== $.data(input, \"datepicker\")) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (this._datepickerShowing) {\n\t\t\t\tshowAnim = this._get(inst, \"showAnim\");\n\t\t\t\tduration = this._get(inst, \"duration\");\n\t\t\t\tpostProcess = function postProcess() {\n\t\t\t\t\t$.datepicker._tidyDialog(inst);\n\t\t\t\t};\n\n\t\t\t\t// DEPRECATED: after BC for 1.8.x $.effects[ showAnim ] is not needed\n\t\t\t\tif ($.effects && ($.effects.effect[showAnim] || $.effects[showAnim])) {\n\t\t\t\t\tinst.dpDiv.hide(showAnim, $.datepicker._get(inst, \"showOptions\"), duration, postProcess);\n\t\t\t\t} else {\n\t\t\t\t\tinst.dpDiv[showAnim === \"slideDown\" ? \"slideUp\" : showAnim === \"fadeIn\" ? \"fadeOut\" : \"hide\"](showAnim ? duration : null, postProcess);\n\t\t\t\t}\n\n\t\t\t\tif (!showAnim) {\n\t\t\t\t\tpostProcess();\n\t\t\t\t}\n\t\t\t\tthis._datepickerShowing = false;\n\n\t\t\t\tonClose = this._get(inst, \"onClose\");\n\t\t\t\tif (onClose) {\n\t\t\t\t\tonClose.apply(inst.input ? inst.input[0] : null, [inst.input ? inst.input.val() : \"\", inst]);\n\t\t\t\t}\n\n\t\t\t\tthis._lastInput = null;\n\t\t\t\tif (this._inDialog) {\n\t\t\t\t\tthis._dialogInput.css({ position: \"absolute\", left: \"0\", top: \"-100px\" });\n\t\t\t\t\tif ($.blockUI) {\n\t\t\t\t\t\t$.unblockUI();\n\t\t\t\t\t\t$(\"body\").append(this.dpDiv);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis._inDialog = false;\n\t\t\t}\n\t\t},\n\n\t\t/* Tidy up after a dialog display. */\n\t\t_tidyDialog: function _tidyDialog(inst) {\n\t\t\tinst.dpDiv.removeClass(this._dialogClass).unbind(\".ui-datepicker-calendar\");\n\t\t},\n\n\t\t/* Close date picker if clicked elsewhere. */\n\t\t_checkExternalClick: function _checkExternalClick(event) {\n\t\t\tif (!$.datepicker._curInst) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar $target = $(event.target),\n\t\t\t    inst = $.datepicker._getInst($target[0]);\n\n\t\t\tif ($target[0].id !== $.datepicker._mainDivId && $target.parents(\"#\" + $.datepicker._mainDivId).length === 0 && !$target.hasClass($.datepicker.markerClassName) && !$target.closest(\".\" + $.datepicker._triggerClass).length && $.datepicker._datepickerShowing && !($.datepicker._inDialog && $.blockUI) || $target.hasClass($.datepicker.markerClassName) && $.datepicker._curInst !== inst) {\n\t\t\t\t$.datepicker._hideDatepicker();\n\t\t\t}\n\t\t},\n\n\t\t/* Adjust one of the date sub-fields. */\n\t\t_adjustDate: function _adjustDate(id, offset, period) {\n\t\t\tvar target = $(id),\n\t\t\t    inst = this._getInst(target[0]);\n\n\t\t\tif (this._isDisabledDatepicker(target[0])) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis._adjustInstDate(inst, offset + (period === \"M\" ? this._get(inst, \"showCurrentAtPos\") : 0), // undo positioning\n\t\t\tperiod);\n\t\t\tthis._updateDatepicker(inst);\n\t\t},\n\n\t\t/* Action for current link. */\n\t\t_gotoToday: function _gotoToday(id) {\n\t\t\tvar date,\n\t\t\t    target = $(id),\n\t\t\t    inst = this._getInst(target[0]);\n\n\t\t\tif (this._get(inst, \"gotoCurrent\") && inst.currentDay) {\n\t\t\t\tinst.selectedDay = inst.currentDay;\n\t\t\t\tinst.drawMonth = inst.selectedMonth = inst.currentMonth;\n\t\t\t\tinst.drawYear = inst.selectedYear = inst.currentYear;\n\t\t\t} else {\n\t\t\t\tdate = new Date();\n\t\t\t\tinst.selectedDay = date.getDate();\n\t\t\t\tinst.drawMonth = inst.selectedMonth = date.getMonth();\n\t\t\t\tinst.drawYear = inst.selectedYear = date.getFullYear();\n\t\t\t}\n\t\t\tthis._notifyChange(inst);\n\t\t\tthis._adjustDate(target);\n\t\t},\n\n\t\t/* Action for selecting a new month/year. */\n\t\t_selectMonthYear: function _selectMonthYear(id, select, period) {\n\t\t\tvar target = $(id),\n\t\t\t    inst = this._getInst(target[0]);\n\n\t\t\tinst[\"selected\" + (period === \"M\" ? \"Month\" : \"Year\")] = inst[\"draw\" + (period === \"M\" ? \"Month\" : \"Year\")] = parseInt(select.options[select.selectedIndex].value, 10);\n\n\t\t\tthis._notifyChange(inst);\n\t\t\tthis._adjustDate(target);\n\t\t},\n\n\t\t/* Action for selecting a day. */\n\t\t_selectDay: function _selectDay(id, month, year, td) {\n\t\t\tvar inst,\n\t\t\t    target = $(id);\n\n\t\t\tif ($(td).hasClass(this._unselectableClass) || this._isDisabledDatepicker(target[0])) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tinst = this._getInst(target[0]);\n\t\t\tinst.selectedDay = inst.currentDay = $(\"a\", td).html();\n\t\t\tinst.selectedMonth = inst.currentMonth = month;\n\t\t\tinst.selectedYear = inst.currentYear = year;\n\t\t\tthis._selectDate(id, this._formatDate(inst, inst.currentDay, inst.currentMonth, inst.currentYear));\n\t\t},\n\n\t\t/* Erase the input field and hide the date picker. */\n\t\t_clearDate: function _clearDate(id) {\n\t\t\tvar target = $(id);\n\t\t\tthis._selectDate(target, \"\");\n\t\t},\n\n\t\t/* Update the input field with the selected date. */\n\t\t_selectDate: function _selectDate(id, dateStr) {\n\t\t\tvar onSelect,\n\t\t\t    target = $(id),\n\t\t\t    inst = this._getInst(target[0]);\n\n\t\t\tdateStr = dateStr != null ? dateStr : this._formatDate(inst);\n\t\t\tif (inst.input) {\n\t\t\t\tinst.input.val(dateStr);\n\t\t\t}\n\t\t\tthis._updateAlternate(inst);\n\n\t\t\tonSelect = this._get(inst, \"onSelect\");\n\t\t\tif (onSelect) {\n\t\t\t\tonSelect.apply(inst.input ? inst.input[0] : null, [dateStr, inst]); // trigger custom callback\n\t\t\t} else if (inst.input) {\n\t\t\t\tinst.input.trigger(\"change\"); // fire the change event\n\t\t\t}\n\n\t\t\tif (inst.inline) {\n\t\t\t\tthis._updateDatepicker(inst);\n\t\t\t} else {\n\t\t\t\tthis._hideDatepicker();\n\t\t\t\tthis._lastInput = inst.input[0];\n\t\t\t\tif (_typeof(inst.input[0]) !== \"object\") {\n\t\t\t\t\tinst.input.focus(); // restore focus\n\t\t\t\t}\n\t\t\t\tthis._lastInput = null;\n\t\t\t}\n\t\t},\n\n\t\t/* Update any alternate field to synchronise with the main field. */\n\t\t_updateAlternate: function _updateAlternate(inst) {\n\t\t\tvar altFormat,\n\t\t\t    date,\n\t\t\t    dateStr,\n\t\t\t    altField = this._get(inst, \"altField\");\n\n\t\t\tif (altField) {\n\t\t\t\t// update alternate field too\n\t\t\t\taltFormat = this._get(inst, \"altFormat\") || this._get(inst, \"dateFormat\");\n\t\t\t\tdate = this._getDate(inst);\n\t\t\t\tdateStr = this.formatDate(altFormat, date, this._getFormatConfig(inst));\n\t\t\t\t$(altField).each(function () {\n\t\t\t\t\t$(this).val(dateStr);\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\n\t\t/* Set as beforeShowDay function to prevent selection of weekends.\n   * @param  date  Date - the date to customise\n   * @return [boolean, string] - is this date selectable?, what is its CSS class?\n   */\n\t\tnoWeekends: function noWeekends(date) {\n\t\t\tvar day = date.getDay();\n\t\t\treturn [day > 0 && day < 6, \"\"];\n\t\t},\n\n\t\t/* Set as calculateWeek to determine the week of the year based on the ISO 8601 definition.\n   * @param  date  Date - the date to get the week for\n   * @return  number - the number of the week within the year that contains this date\n   */\n\t\tiso8601Week: function iso8601Week(date) {\n\t\t\tvar time,\n\t\t\t    checkDate = new Date(date.getTime());\n\n\t\t\t// Find Thursday of this week starting on Monday\n\t\t\tcheckDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));\n\n\t\t\ttime = checkDate.getTime();\n\t\t\tcheckDate.setMonth(0); // Compare with Jan 1\n\t\t\tcheckDate.setDate(1);\n\t\t\treturn Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;\n\t\t},\n\n\t\t/* Parse a string value into a date object.\n   * See formatDate below for the possible formats.\n   *\n   * @param  format string - the expected format of the date\n   * @param  value string - the date in the above format\n   * @param  settings Object - attributes include:\n   *\t\t\t\t\tshortYearCutoff  number - the cutoff year for determining the century (optional)\n   *\t\t\t\t\tdayNamesShort\tstring[7] - abbreviated names of the days from Sunday (optional)\n   *\t\t\t\t\tdayNames\t\tstring[7] - names of the days from Sunday (optional)\n   *\t\t\t\t\tmonthNamesShort string[12] - abbreviated names of the months (optional)\n   *\t\t\t\t\tmonthNames\t\tstring[12] - names of the months (optional)\n   * @return  Date - the extracted date value or null if value is blank\n   */\n\t\tparseDate: function parseDate(format, value, settings) {\n\t\t\tif (format == null || value == null) {\n\t\t\t\tthrow \"Invalid arguments\";\n\t\t\t}\n\n\t\t\tvalue = (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) === \"object\" ? value.toString() : value + \"\";\n\t\t\tif (value === \"\") {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tvar iFormat,\n\t\t\t    dim,\n\t\t\t    extra,\n\t\t\t    iValue = 0,\n\t\t\t    shortYearCutoffTemp = (settings ? settings.shortYearCutoff : null) || this._defaults.shortYearCutoff,\n\t\t\t    shortYearCutoff = typeof shortYearCutoffTemp !== \"string\" ? shortYearCutoffTemp : new Date().getFullYear() % 100 + parseInt(shortYearCutoffTemp, 10),\n\t\t\t    dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,\n\t\t\t    dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,\n\t\t\t    monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,\n\t\t\t    monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,\n\t\t\t    year = -1,\n\t\t\t    month = -1,\n\t\t\t    day = -1,\n\t\t\t    doy = -1,\n\t\t\t    literal = false,\n\t\t\t    date,\n\n\t\t\t// Check whether a format character is doubled\n\t\t\tlookAhead = function lookAhead(match) {\n\t\t\t\tvar matches = iFormat + 1 < format.length && format.charAt(iFormat + 1) === match;\n\t\t\t\tif (matches) {\n\t\t\t\t\tiFormat++;\n\t\t\t\t}\n\t\t\t\treturn matches;\n\t\t\t},\n\n\t\t\t// Extract a number from the string value\n\t\t\tgetNumber = function getNumber(match) {\n\t\t\t\tvar isDoubled = lookAhead(match),\n\t\t\t\t    size = match === \"@\" ? 14 : match === \"!\" ? 20 : match === \"y\" && isDoubled ? 4 : match === \"o\" ? 3 : 2,\n\t\t\t\t    minSize = match === \"y\" ? size : 1,\n\t\t\t\t    digits = new RegExp(\"^\\\\d{\" + minSize + \",\" + size + \"}\"),\n\t\t\t\t    num = value.substring(iValue).match(digits);\n\t\t\t\tif (!num) {\n\t\t\t\t\tthrow \"Missing number at position \" + iValue;\n\t\t\t\t}\n\t\t\t\tiValue += num[0].length;\n\t\t\t\treturn parseInt(num[0], 10);\n\t\t\t},\n\n\t\t\t// Extract a name from the string value and convert to an index\n\t\t\tgetName = function getName(match, shortNames, longNames) {\n\t\t\t\tvar index = -1,\n\t\t\t\t    names = $.map(lookAhead(match) ? longNames : shortNames, function (v, k) {\n\t\t\t\t\treturn [[k, v]];\n\t\t\t\t}).sort(function (a, b) {\n\t\t\t\t\treturn -(a[1].length - b[1].length);\n\t\t\t\t});\n\n\t\t\t\t$.each(names, function (i, pair) {\n\t\t\t\t\tvar name = pair[1];\n\t\t\t\t\tif (value.substr(iValue, name.length).toLowerCase() === name.toLowerCase()) {\n\t\t\t\t\t\tindex = pair[0];\n\t\t\t\t\t\tiValue += name.length;\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tif (index !== -1) {\n\t\t\t\t\treturn index + 1;\n\t\t\t\t} else {\n\t\t\t\t\tthrow \"Unknown name at position \" + iValue;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// Confirm that a literal character matches the string value\n\t\t\tcheckLiteral = function checkLiteral() {\n\t\t\t\tif (value.charAt(iValue) !== format.charAt(iFormat)) {\n\t\t\t\t\tthrow \"Unexpected literal at position \" + iValue;\n\t\t\t\t}\n\t\t\t\tiValue++;\n\t\t\t};\n\n\t\t\tfor (iFormat = 0; iFormat < format.length; iFormat++) {\n\t\t\t\tif (literal) {\n\t\t\t\t\tif (format.charAt(iFormat) === \"'\" && !lookAhead(\"'\")) {\n\t\t\t\t\t\tliteral = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcheckLiteral();\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tswitch (format.charAt(iFormat)) {\n\t\t\t\t\t\tcase \"d\":\n\t\t\t\t\t\t\tday = getNumber(\"d\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"D\":\n\t\t\t\t\t\t\tgetName(\"D\", dayNamesShort, dayNames);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"o\":\n\t\t\t\t\t\t\tdoy = getNumber(\"o\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"m\":\n\t\t\t\t\t\t\tmonth = getNumber(\"m\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"M\":\n\t\t\t\t\t\t\tmonth = getName(\"M\", monthNamesShort, monthNames);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"y\":\n\t\t\t\t\t\t\tyear = getNumber(\"y\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"@\":\n\t\t\t\t\t\t\tdate = new Date(getNumber(\"@\"));\n\t\t\t\t\t\t\tyear = date.getFullYear();\n\t\t\t\t\t\t\tmonth = date.getMonth() + 1;\n\t\t\t\t\t\t\tday = date.getDate();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"!\":\n\t\t\t\t\t\t\tdate = new Date((getNumber(\"!\") - this._ticksTo1970) / 10000);\n\t\t\t\t\t\t\tyear = date.getFullYear();\n\t\t\t\t\t\t\tmonth = date.getMonth() + 1;\n\t\t\t\t\t\t\tday = date.getDate();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"'\":\n\t\t\t\t\t\t\tif (lookAhead(\"'\")) {\n\t\t\t\t\t\t\t\tcheckLiteral();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tliteral = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tcheckLiteral();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (iValue < value.length) {\n\t\t\t\textra = value.substr(iValue);\n\t\t\t\tif (!/^\\s+/.test(extra)) {\n\t\t\t\t\tthrow \"Extra/unparsed characters found in date: \" + extra;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (year === -1) {\n\t\t\t\tyear = new Date().getFullYear();\n\t\t\t} else if (year < 100) {\n\t\t\t\tyear += new Date().getFullYear() - new Date().getFullYear() % 100 + (year <= shortYearCutoff ? 0 : -100);\n\t\t\t}\n\n\t\t\tif (doy > -1) {\n\t\t\t\tmonth = 1;\n\t\t\t\tday = doy;\n\t\t\t\tdo {\n\t\t\t\t\tdim = this._getDaysInMonth(year, month - 1);\n\t\t\t\t\tif (day <= dim) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tmonth++;\n\t\t\t\t\tday -= dim;\n\t\t\t\t} while (true);\n\t\t\t}\n\n\t\t\tdate = this._daylightSavingAdjust(new Date(year, month - 1, day));\n\t\t\tif (date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day) {\n\t\t\t\tthrow \"Invalid date\"; // E.g. 31/02/00\n\t\t\t}\n\t\t\treturn date;\n\t\t},\n\n\t\t/* Standard date formats. */\n\t\tATOM: \"yy-mm-dd\", // RFC 3339 (ISO 8601)\n\t\tCOOKIE: \"D, dd M yy\",\n\t\tISO_8601: \"yy-mm-dd\",\n\t\tRFC_822: \"D, d M y\",\n\t\tRFC_850: \"DD, dd-M-y\",\n\t\tRFC_1036: \"D, d M y\",\n\t\tRFC_1123: \"D, d M yy\",\n\t\tRFC_2822: \"D, d M yy\",\n\t\tRSS: \"D, d M y\", // RFC 822\n\t\tTICKS: \"!\",\n\t\tTIMESTAMP: \"@\",\n\t\tW3C: \"yy-mm-dd\", // ISO 8601\n\n\t\t_ticksTo1970: ((1970 - 1) * 365 + Math.floor(1970 / 4) - Math.floor(1970 / 100) + Math.floor(1970 / 400)) * 24 * 60 * 60 * 10000000,\n\n\t\t/* Format a date object into a string value.\n   * The format can be combinations of the following:\n   * d  - day of month (no leading zero)\n   * dd - day of month (two digit)\n   * o  - day of year (no leading zeros)\n   * oo - day of year (three digit)\n   * D  - day name short\n   * DD - day name long\n   * m  - month of year (no leading zero)\n   * mm - month of year (two digit)\n   * M  - month name short\n   * MM - month name long\n   * y  - year (two digit)\n   * yy - year (four digit)\n   * @ - Unix timestamp (ms since 01/01/1970)\n   * ! - Windows ticks (100ns since 01/01/0001)\n   * \"...\" - literal text\n   * '' - single quote\n   *\n   * @param  format string - the desired format of the date\n   * @param  date Date - the date value to format\n   * @param  settings Object - attributes include:\n   *\t\t\t\t\tdayNamesShort\tstring[7] - abbreviated names of the days from Sunday (optional)\n   *\t\t\t\t\tdayNames\t\tstring[7] - names of the days from Sunday (optional)\n   *\t\t\t\t\tmonthNamesShort string[12] - abbreviated names of the months (optional)\n   *\t\t\t\t\tmonthNames\t\tstring[12] - names of the months (optional)\n   * @return  string - the date in the above format\n   */\n\t\tformatDate: function formatDate(format, date, settings) {\n\t\t\tif (!date) {\n\t\t\t\treturn \"\";\n\t\t\t}\n\n\t\t\tvar iFormat,\n\t\t\t    dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,\n\t\t\t    dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,\n\t\t\t    monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,\n\t\t\t    monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,\n\n\t\t\t// Check whether a format character is doubled\n\t\t\tlookAhead = function lookAhead(match) {\n\t\t\t\tvar matches = iFormat + 1 < format.length && format.charAt(iFormat + 1) === match;\n\t\t\t\tif (matches) {\n\t\t\t\t\tiFormat++;\n\t\t\t\t}\n\t\t\t\treturn matches;\n\t\t\t},\n\n\t\t\t// Format a number, with leading zero if necessary\n\t\t\tformatNumber = function formatNumber(match, value, len) {\n\t\t\t\tvar num = \"\" + value;\n\t\t\t\tif (lookAhead(match)) {\n\t\t\t\t\twhile (num.length < len) {\n\t\t\t\t\t\tnum = \"0\" + num;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn num;\n\t\t\t},\n\n\t\t\t// Format a name, short or long as requested\n\t\t\tformatName = function formatName(match, value, shortNames, longNames) {\n\t\t\t\treturn lookAhead(match) ? longNames[value] : shortNames[value];\n\t\t\t},\n\t\t\t    output = \"\",\n\t\t\t    literal = false;\n\n\t\t\tif (date) {\n\t\t\t\tfor (iFormat = 0; iFormat < format.length; iFormat++) {\n\t\t\t\t\tif (literal) {\n\t\t\t\t\t\tif (format.charAt(iFormat) === \"'\" && !lookAhead(\"'\")) {\n\t\t\t\t\t\t\tliteral = false;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\toutput += format.charAt(iFormat);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tswitch (format.charAt(iFormat)) {\n\t\t\t\t\t\t\tcase \"d\":\n\t\t\t\t\t\t\t\toutput += formatNumber(\"d\", date.getDate(), 2);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \"D\":\n\t\t\t\t\t\t\t\toutput += formatName(\"D\", date.getDay(), dayNamesShort, dayNames);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \"o\":\n\t\t\t\t\t\t\t\toutput += formatNumber(\"o\", Math.round((new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 86400000), 3);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \"m\":\n\t\t\t\t\t\t\t\toutput += formatNumber(\"m\", date.getMonth() + 1, 2);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \"M\":\n\t\t\t\t\t\t\t\toutput += formatName(\"M\", date.getMonth(), monthNamesShort, monthNames);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \"y\":\n\t\t\t\t\t\t\t\toutput += lookAhead(\"y\") ? date.getFullYear() : (date.getYear() % 100 < 10 ? \"0\" : \"\") + date.getYear() % 100;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \"@\":\n\t\t\t\t\t\t\t\toutput += date.getTime();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \"!\":\n\t\t\t\t\t\t\t\toutput += date.getTime() * 10000 + this._ticksTo1970;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase \"'\":\n\t\t\t\t\t\t\t\tif (lookAhead(\"'\")) {\n\t\t\t\t\t\t\t\t\toutput += \"'\";\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tliteral = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\toutput += format.charAt(iFormat);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn output;\n\t\t},\n\n\t\t/* Extract all possible characters from the date format. */\n\t\t_possibleChars: function _possibleChars(format) {\n\t\t\tvar iFormat,\n\t\t\t    chars = \"\",\n\t\t\t    literal = false,\n\n\t\t\t// Check whether a format character is doubled\n\t\t\tlookAhead = function lookAhead(match) {\n\t\t\t\tvar matches = iFormat + 1 < format.length && format.charAt(iFormat + 1) === match;\n\t\t\t\tif (matches) {\n\t\t\t\t\tiFormat++;\n\t\t\t\t}\n\t\t\t\treturn matches;\n\t\t\t};\n\n\t\t\tfor (iFormat = 0; iFormat < format.length; iFormat++) {\n\t\t\t\tif (literal) {\n\t\t\t\t\tif (format.charAt(iFormat) === \"'\" && !lookAhead(\"'\")) {\n\t\t\t\t\t\tliteral = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchars += format.charAt(iFormat);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tswitch (format.charAt(iFormat)) {\n\t\t\t\t\t\tcase \"d\":case \"m\":case \"y\":case \"@\":\n\t\t\t\t\t\t\tchars += \"0123456789\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"D\":case \"M\":\n\t\t\t\t\t\t\treturn null; // Accept anything\n\t\t\t\t\t\tcase \"'\":\n\t\t\t\t\t\t\tif (lookAhead(\"'\")) {\n\t\t\t\t\t\t\t\tchars += \"'\";\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tliteral = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tchars += format.charAt(iFormat);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn chars;\n\t\t},\n\n\t\t/* Get a setting value, defaulting if necessary. */\n\t\t_get: function _get(inst, name) {\n\t\t\treturn inst.settings[name] !== undefined ? inst.settings[name] : this._defaults[name];\n\t\t},\n\n\t\t/* Parse existing date and initialise date picker. */\n\t\t_setDateFromField: function _setDateFromField(inst, noDefault) {\n\t\t\tif (inst.input.val() === inst.lastVal) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar dateFormat = this._get(inst, \"dateFormat\"),\n\t\t\t    dates = inst.lastVal = inst.input ? inst.input.val() : null,\n\t\t\t    defaultDate = this._getDefaultDate(inst),\n\t\t\t    date = defaultDate,\n\t\t\t    settings = this._getFormatConfig(inst);\n\n\t\t\ttry {\n\t\t\t\tdate = this.parseDate(dateFormat, dates, settings) || defaultDate;\n\t\t\t} catch (event) {\n\t\t\t\tdates = noDefault ? \"\" : dates;\n\t\t\t}\n\t\t\tinst.selectedDay = date.getDate();\n\t\t\tinst.drawMonth = inst.selectedMonth = date.getMonth();\n\t\t\tinst.drawYear = inst.selectedYear = date.getFullYear();\n\t\t\tinst.currentDay = dates ? date.getDate() : 0;\n\t\t\tinst.currentMonth = dates ? date.getMonth() : 0;\n\t\t\tinst.currentYear = dates ? date.getFullYear() : 0;\n\t\t\tthis._adjustInstDate(inst);\n\t\t},\n\n\t\t/* Retrieve the default date shown on opening. */\n\t\t_getDefaultDate: function _getDefaultDate(inst) {\n\t\t\treturn this._restrictMinMax(inst, this._determineDate(inst, this._get(inst, \"defaultDate\"), new Date()));\n\t\t},\n\n\t\t/* A date may be specified as an exact value or a relative one. */\n\t\t_determineDate: function _determineDate(inst, date, defaultDate) {\n\t\t\tvar offsetNumeric = function offsetNumeric(offset) {\n\t\t\t\tvar date = new Date();\n\t\t\t\tdate.setDate(date.getDate() + offset);\n\t\t\t\treturn date;\n\t\t\t},\n\t\t\t    offsetString = function offsetString(offset) {\n\t\t\t\ttry {\n\t\t\t\t\treturn $.datepicker.parseDate($.datepicker._get(inst, \"dateFormat\"), offset, $.datepicker._getFormatConfig(inst));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t// Ignore\n\t\t\t\t}\n\n\t\t\t\tvar date = (offset.toLowerCase().match(/^c/) ? $.datepicker._getDate(inst) : null) || new Date(),\n\t\t\t\t    year = date.getFullYear(),\n\t\t\t\t    month = date.getMonth(),\n\t\t\t\t    day = date.getDate(),\n\t\t\t\t    pattern = /([+\\-]?[0-9]+)\\s*(d|D|w|W|m|M|y|Y)?/g,\n\t\t\t\t    matches = pattern.exec(offset);\n\n\t\t\t\twhile (matches) {\n\t\t\t\t\tswitch (matches[2] || \"d\") {\n\t\t\t\t\t\tcase \"d\":case \"D\":\n\t\t\t\t\t\t\tday += parseInt(matches[1], 10);break;\n\t\t\t\t\t\tcase \"w\":case \"W\":\n\t\t\t\t\t\t\tday += parseInt(matches[1], 10) * 7;break;\n\t\t\t\t\t\tcase \"m\":case \"M\":\n\t\t\t\t\t\t\tmonth += parseInt(matches[1], 10);\n\t\t\t\t\t\t\tday = Math.min(day, $.datepicker._getDaysInMonth(year, month));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"y\":case \"Y\":\n\t\t\t\t\t\t\tyear += parseInt(matches[1], 10);\n\t\t\t\t\t\t\tday = Math.min(day, $.datepicker._getDaysInMonth(year, month));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tmatches = pattern.exec(offset);\n\t\t\t\t}\n\t\t\t\treturn new Date(year, month, day);\n\t\t\t},\n\t\t\t    newDate = date == null || date === \"\" ? defaultDate : typeof date === \"string\" ? offsetString(date) : typeof date === \"number\" ? isNaN(date) ? defaultDate : offsetNumeric(date) : new Date(date.getTime());\n\n\t\t\tnewDate = newDate && newDate.toString() === \"Invalid Date\" ? defaultDate : newDate;\n\t\t\tif (newDate) {\n\t\t\t\tnewDate.setHours(0);\n\t\t\t\tnewDate.setMinutes(0);\n\t\t\t\tnewDate.setSeconds(0);\n\t\t\t\tnewDate.setMilliseconds(0);\n\t\t\t}\n\t\t\treturn this._daylightSavingAdjust(newDate);\n\t\t},\n\n\t\t/* Handle switch to/from daylight saving.\n   * Hours may be non-zero on daylight saving cut-over:\n   * > 12 when midnight changeover, but then cannot generate\n   * midnight datetime, so jump to 1AM, otherwise reset.\n   * @param  date  (Date) the date to check\n   * @return  (Date) the corrected date\n   */\n\t\t_daylightSavingAdjust: function _daylightSavingAdjust(date) {\n\t\t\tif (!date) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tdate.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);\n\t\t\treturn date;\n\t\t},\n\n\t\t/* Set the date(s) directly. */\n\t\t_setDate: function _setDate(inst, date, noChange) {\n\t\t\tvar clear = !date,\n\t\t\t    origMonth = inst.selectedMonth,\n\t\t\t    origYear = inst.selectedYear,\n\t\t\t    newDate = this._restrictMinMax(inst, this._determineDate(inst, date, new Date()));\n\n\t\t\tinst.selectedDay = inst.currentDay = newDate.getDate();\n\t\t\tinst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();\n\t\t\tinst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();\n\t\t\tif ((origMonth !== inst.selectedMonth || origYear !== inst.selectedYear) && !noChange) {\n\t\t\t\tthis._notifyChange(inst);\n\t\t\t}\n\t\t\tthis._adjustInstDate(inst);\n\t\t\tif (inst.input) {\n\t\t\t\tinst.input.val(clear ? \"\" : this._formatDate(inst));\n\t\t\t}\n\t\t},\n\n\t\t/* Retrieve the date(s) directly. */\n\t\t_getDate: function _getDate(inst) {\n\t\t\tvar startDate = !inst.currentYear || inst.input && inst.input.val() === \"\" ? null : this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay));\n\t\t\treturn startDate;\n\t\t},\n\n\t\t/* Attach the onxxx handlers.  These are declared statically so\n   * they work with static code transformers like Caja.\n   */\n\t\t_attachHandlers: function _attachHandlers(inst) {\n\t\t\tvar stepMonths = this._get(inst, \"stepMonths\"),\n\t\t\t    id = \"#\" + inst.id.replace(/\\\\\\\\/g, \"\\\\\");\n\t\t\tinst.dpDiv.find(\"[data-handler]\").map(function () {\n\t\t\t\tvar handler = {\n\t\t\t\t\tprev: function prev() {\n\t\t\t\t\t\t$.datepicker._adjustDate(id, -stepMonths, \"M\");\n\t\t\t\t\t},\n\t\t\t\t\tnext: function next() {\n\t\t\t\t\t\t$.datepicker._adjustDate(id, +stepMonths, \"M\");\n\t\t\t\t\t},\n\t\t\t\t\thide: function hide() {\n\t\t\t\t\t\t$.datepicker._hideDatepicker();\n\t\t\t\t\t},\n\t\t\t\t\ttoday: function today() {\n\t\t\t\t\t\t$.datepicker._gotoToday(id);\n\t\t\t\t\t},\n\t\t\t\t\tselectDay: function selectDay() {\n\t\t\t\t\t\t$.datepicker._selectDay(id, +this.getAttribute(\"data-month\"), +this.getAttribute(\"data-year\"), this);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t},\n\t\t\t\t\tselectMonth: function selectMonth() {\n\t\t\t\t\t\t$.datepicker._selectMonthYear(id, this, \"M\");\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t},\n\t\t\t\t\tselectYear: function selectYear() {\n\t\t\t\t\t\t$.datepicker._selectMonthYear(id, this, \"Y\");\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\t$(this).bind(this.getAttribute(\"data-event\"), handler[this.getAttribute(\"data-handler\")]);\n\t\t\t});\n\t\t},\n\n\t\t/* Generate the HTML for the current state of the date picker. */\n\t\t_generateHTML: function _generateHTML(inst) {\n\t\t\tvar maxDraw,\n\t\t\t    prevText,\n\t\t\t    prev,\n\t\t\t    nextText,\n\t\t\t    next,\n\t\t\t    currentText,\n\t\t\t    gotoDate,\n\t\t\t    controls,\n\t\t\t    buttonPanel,\n\t\t\t    firstDay,\n\t\t\t    showWeek,\n\t\t\t    dayNames,\n\t\t\t    dayNamesMin,\n\t\t\t    monthNames,\n\t\t\t    monthNamesShort,\n\t\t\t    beforeShowDay,\n\t\t\t    showOtherMonths,\n\t\t\t    selectOtherMonths,\n\t\t\t    defaultDate,\n\t\t\t    html,\n\t\t\t    dow,\n\t\t\t    row,\n\t\t\t    group,\n\t\t\t    col,\n\t\t\t    selectedDate,\n\t\t\t    cornerClass,\n\t\t\t    calender,\n\t\t\t    thead,\n\t\t\t    day,\n\t\t\t    daysInMonth,\n\t\t\t    leadDays,\n\t\t\t    curRows,\n\t\t\t    numRows,\n\t\t\t    printDate,\n\t\t\t    dRow,\n\t\t\t    tbody,\n\t\t\t    daySettings,\n\t\t\t    otherMonth,\n\t\t\t    unselectable,\n\t\t\t    tempDate = new Date(),\n\t\t\t    today = this._daylightSavingAdjust(new Date(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate())),\n\t\t\t    // clear time\n\t\t\tisRTL = this._get(inst, \"isRTL\"),\n\t\t\t    showButtonPanel = this._get(inst, \"showButtonPanel\"),\n\t\t\t    hideIfNoPrevNext = this._get(inst, \"hideIfNoPrevNext\"),\n\t\t\t    navigationAsDateFormat = this._get(inst, \"navigationAsDateFormat\"),\n\t\t\t    numMonths = this._getNumberOfMonths(inst),\n\t\t\t    showCurrentAtPos = this._get(inst, \"showCurrentAtPos\"),\n\t\t\t    stepMonths = this._get(inst, \"stepMonths\"),\n\t\t\t    isMultiMonth = numMonths[0] !== 1 || numMonths[1] !== 1,\n\t\t\t    currentDate = this._daylightSavingAdjust(!inst.currentDay ? new Date(9999, 9, 9) : new Date(inst.currentYear, inst.currentMonth, inst.currentDay)),\n\t\t\t    minDate = this._getMinMaxDate(inst, \"min\"),\n\t\t\t    maxDate = this._getMinMaxDate(inst, \"max\"),\n\t\t\t    drawMonth = inst.drawMonth - showCurrentAtPos,\n\t\t\t    drawYear = inst.drawYear;\n\n\t\t\tif (drawMonth < 0) {\n\t\t\t\tdrawMonth += 12;\n\t\t\t\tdrawYear--;\n\t\t\t}\n\t\t\tif (maxDate) {\n\t\t\t\tmaxDraw = this._daylightSavingAdjust(new Date(maxDate.getFullYear(), maxDate.getMonth() - numMonths[0] * numMonths[1] + 1, maxDate.getDate()));\n\t\t\t\tmaxDraw = minDate && maxDraw < minDate ? minDate : maxDraw;\n\t\t\t\twhile (this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1)) > maxDraw) {\n\t\t\t\t\tdrawMonth--;\n\t\t\t\t\tif (drawMonth < 0) {\n\t\t\t\t\t\tdrawMonth = 11;\n\t\t\t\t\t\tdrawYear--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tinst.drawMonth = drawMonth;\n\t\t\tinst.drawYear = drawYear;\n\n\t\t\tprevText = this._get(inst, \"prevText\");\n\t\t\tprevText = !navigationAsDateFormat ? prevText : this.formatDate(prevText, this._daylightSavingAdjust(new Date(drawYear, drawMonth - stepMonths, 1)), this._getFormatConfig(inst));\n\n\t\t\tprev = this._canAdjustMonth(inst, -1, drawYear, drawMonth) ? \"<a class='ui-datepicker-prev ui-corner-all' data-handler='prev' data-event='click'\" + \" title='\" + prevText + \"'><span class='ui-icon ui-icon-circle-triangle-\" + (isRTL ? \"e\" : \"w\") + \"'>\" + prevText + \"</span></a>\" : hideIfNoPrevNext ? \"\" : \"<a class='ui-datepicker-prev ui-corner-all ui-state-disabled' title='\" + prevText + \"'><span class='ui-icon ui-icon-circle-triangle-\" + (isRTL ? \"e\" : \"w\") + \"'>\" + prevText + \"</span></a>\";\n\n\t\t\tnextText = this._get(inst, \"nextText\");\n\t\t\tnextText = !navigationAsDateFormat ? nextText : this.formatDate(nextText, this._daylightSavingAdjust(new Date(drawYear, drawMonth + stepMonths, 1)), this._getFormatConfig(inst));\n\n\t\t\tnext = this._canAdjustMonth(inst, +1, drawYear, drawMonth) ? \"<a class='ui-datepicker-next ui-corner-all' data-handler='next' data-event='click'\" + \" title='\" + nextText + \"'><span class='ui-icon ui-icon-circle-triangle-\" + (isRTL ? \"w\" : \"e\") + \"'>\" + nextText + \"</span></a>\" : hideIfNoPrevNext ? \"\" : \"<a class='ui-datepicker-next ui-corner-all ui-state-disabled' title='\" + nextText + \"'><span class='ui-icon ui-icon-circle-triangle-\" + (isRTL ? \"w\" : \"e\") + \"'>\" + nextText + \"</span></a>\";\n\n\t\t\tcurrentText = this._get(inst, \"currentText\");\n\t\t\tgotoDate = this._get(inst, \"gotoCurrent\") && inst.currentDay ? currentDate : today;\n\t\t\tcurrentText = !navigationAsDateFormat ? currentText : this.formatDate(currentText, gotoDate, this._getFormatConfig(inst));\n\n\t\t\tcontrols = !inst.inline ? \"<button type='button' class='ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all' data-handler='hide' data-event='click'>\" + this._get(inst, \"closeText\") + \"</button>\" : \"\";\n\n\t\t\tbuttonPanel = showButtonPanel ? \"<div class='ui-datepicker-buttonpane ui-widget-content'>\" + (isRTL ? controls : \"\") + (this._isInRange(inst, gotoDate) ? \"<button type='button' class='ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all' data-handler='today' data-event='click'\" + \">\" + currentText + \"</button>\" : \"\") + (isRTL ? \"\" : controls) + \"</div>\" : \"\";\n\n\t\t\tfirstDay = parseInt(this._get(inst, \"firstDay\"), 10);\n\t\t\tfirstDay = isNaN(firstDay) ? 0 : firstDay;\n\n\t\t\tshowWeek = this._get(inst, \"showWeek\");\n\t\t\tdayNames = this._get(inst, \"dayNames\");\n\t\t\tdayNamesMin = this._get(inst, \"dayNamesMin\");\n\t\t\tmonthNames = this._get(inst, \"monthNames\");\n\t\t\tmonthNamesShort = this._get(inst, \"monthNamesShort\");\n\t\t\tbeforeShowDay = this._get(inst, \"beforeShowDay\");\n\t\t\tshowOtherMonths = this._get(inst, \"showOtherMonths\");\n\t\t\tselectOtherMonths = this._get(inst, \"selectOtherMonths\");\n\t\t\tdefaultDate = this._getDefaultDate(inst);\n\t\t\thtml = \"\";\n\t\t\tdow;\n\t\t\tfor (row = 0; row < numMonths[0]; row++) {\n\t\t\t\tgroup = \"\";\n\t\t\t\tthis.maxRows = 4;\n\t\t\t\tfor (col = 0; col < numMonths[1]; col++) {\n\t\t\t\t\tselectedDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, inst.selectedDay));\n\t\t\t\t\tcornerClass = \" ui-corner-all\";\n\t\t\t\t\tcalender = \"\";\n\t\t\t\t\tif (isMultiMonth) {\n\t\t\t\t\t\tcalender += \"<div class='ui-datepicker-group\";\n\t\t\t\t\t\tif (numMonths[1] > 1) {\n\t\t\t\t\t\t\tswitch (col) {\n\t\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t\tcalender += \" ui-datepicker-group-first\";\n\t\t\t\t\t\t\t\t\tcornerClass = \" ui-corner-\" + (isRTL ? \"right\" : \"left\");break;\n\t\t\t\t\t\t\t\tcase numMonths[1] - 1:\n\t\t\t\t\t\t\t\t\tcalender += \" ui-datepicker-group-last\";\n\t\t\t\t\t\t\t\t\tcornerClass = \" ui-corner-\" + (isRTL ? \"left\" : \"right\");break;\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\tcalender += \" ui-datepicker-group-middle\";cornerClass = \"\";break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcalender += \"'>\";\n\t\t\t\t\t}\n\t\t\t\t\tcalender += \"<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix\" + cornerClass + \"'>\" + (/all|left/.test(cornerClass) && row === 0 ? isRTL ? next : prev : \"\") + (/all|right/.test(cornerClass) && row === 0 ? isRTL ? prev : next : \"\") + this._generateMonthYearHeader(inst, drawMonth, drawYear, minDate, maxDate, row > 0 || col > 0, monthNames, monthNamesShort) + // draw month headers\n\t\t\t\t\t\"</div><table class='ui-datepicker-calendar'><thead>\" + \"<tr>\";\n\t\t\t\t\tthead = showWeek ? \"<th class='ui-datepicker-week-col'>\" + this._get(inst, \"weekHeader\") + \"</th>\" : \"\";\n\t\t\t\t\tfor (dow = 0; dow < 7; dow++) {\n\t\t\t\t\t\t// days of the week\n\t\t\t\t\t\tday = (dow + firstDay) % 7;\n\t\t\t\t\t\tthead += \"<th scope='col'\" + ((dow + firstDay + 6) % 7 >= 5 ? \" class='ui-datepicker-week-end'\" : \"\") + \">\" + \"<span title='\" + dayNames[day] + \"'>\" + dayNamesMin[day] + \"</span></th>\";\n\t\t\t\t\t}\n\t\t\t\t\tcalender += thead + \"</tr></thead><tbody>\";\n\t\t\t\t\tdaysInMonth = this._getDaysInMonth(drawYear, drawMonth);\n\t\t\t\t\tif (drawYear === inst.selectedYear && drawMonth === inst.selectedMonth) {\n\t\t\t\t\t\tinst.selectedDay = Math.min(inst.selectedDay, daysInMonth);\n\t\t\t\t\t}\n\t\t\t\t\tleadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7;\n\t\t\t\t\tcurRows = Math.ceil((leadDays + daysInMonth) / 7); // calculate the number of rows to generate\n\t\t\t\t\tnumRows = isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows; //If multiple months, use the higher number of rows (see #7043)\n\t\t\t\t\tthis.maxRows = numRows;\n\t\t\t\t\tprintDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1 - leadDays));\n\t\t\t\t\tfor (dRow = 0; dRow < numRows; dRow++) {\n\t\t\t\t\t\t// create date picker rows\n\t\t\t\t\t\tcalender += \"<tr>\";\n\t\t\t\t\t\ttbody = !showWeek ? \"\" : \"<td class='ui-datepicker-week-col'>\" + this._get(inst, \"calculateWeek\")(printDate) + \"</td>\";\n\t\t\t\t\t\tfor (dow = 0; dow < 7; dow++) {\n\t\t\t\t\t\t\t// create date picker days\n\t\t\t\t\t\t\tdaySettings = beforeShowDay ? beforeShowDay.apply(inst.input ? inst.input[0] : null, [printDate]) : [true, \"\"];\n\t\t\t\t\t\t\totherMonth = printDate.getMonth() !== drawMonth;\n\t\t\t\t\t\t\tunselectable = otherMonth && !selectOtherMonths || !daySettings[0] || minDate && printDate < minDate || maxDate && printDate > maxDate;\n\t\t\t\t\t\t\ttbody += \"<td class='\" + ((dow + firstDay + 6) % 7 >= 5 ? \" ui-datepicker-week-end\" : \"\") + ( // highlight weekends\n\t\t\t\t\t\t\totherMonth ? \" ui-datepicker-other-month\" : \"\") + ( // highlight days from other months\n\t\t\t\t\t\t\tprintDate.getTime() === selectedDate.getTime() && drawMonth === inst.selectedMonth && inst._keyEvent || // user pressed key\n\t\t\t\t\t\t\tdefaultDate.getTime() === printDate.getTime() && defaultDate.getTime() === selectedDate.getTime() ?\n\t\t\t\t\t\t\t// or defaultDate is current printedDate and defaultDate is selectedDate\n\t\t\t\t\t\t\t\" \" + this._dayOverClass : \"\") + ( // highlight selected day\n\t\t\t\t\t\t\tunselectable ? \" \" + this._unselectableClass + \" ui-state-disabled\" : \"\") + ( // highlight unselectable days\n\t\t\t\t\t\t\totherMonth && !showOtherMonths ? \"\" : \" \" + daySettings[1] + ( // highlight custom dates\n\t\t\t\t\t\t\tprintDate.getTime() === currentDate.getTime() ? \" \" + this._currentClass : \"\") + ( // highlight selected day\n\t\t\t\t\t\t\tprintDate.getTime() === today.getTime() ? \" ui-datepicker-today\" : \"\")) + \"'\" + ( // highlight today (if different)\n\t\t\t\t\t\t\t(!otherMonth || showOtherMonths) && daySettings[2] ? \" title='\" + daySettings[2].replace(/'/g, \"&#39;\") + \"'\" : \"\") + ( // cell title\n\t\t\t\t\t\t\tunselectable ? \"\" : \" data-handler='selectDay' data-event='click' data-month='\" + printDate.getMonth() + \"' data-year='\" + printDate.getFullYear() + \"'\") + \">\" + ( // actions\n\t\t\t\t\t\t\totherMonth && !showOtherMonths ? \"&#xa0;\" : // display for other months\n\t\t\t\t\t\t\tunselectable ? \"<span class='ui-state-default'>\" + printDate.getDate() + \"</span>\" : \"<a class='ui-state-default\" + (printDate.getTime() === today.getTime() ? \" ui-state-highlight\" : \"\") + (printDate.getTime() === currentDate.getTime() ? \" ui-state-active\" : \"\") + ( // highlight selected day\n\t\t\t\t\t\t\totherMonth ? \" ui-priority-secondary\" : \"\") + // distinguish dates from other months\n\t\t\t\t\t\t\t\"' href='#'>\" + printDate.getDate() + \"</a>\") + \"</td>\"; // display selectable date\n\t\t\t\t\t\t\tprintDate.setDate(printDate.getDate() + 1);\n\t\t\t\t\t\t\tprintDate = this._daylightSavingAdjust(printDate);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcalender += tbody + \"</tr>\";\n\t\t\t\t\t}\n\t\t\t\t\tdrawMonth++;\n\t\t\t\t\tif (drawMonth > 11) {\n\t\t\t\t\t\tdrawMonth = 0;\n\t\t\t\t\t\tdrawYear++;\n\t\t\t\t\t}\n\t\t\t\t\tcalender += \"</tbody></table>\" + (isMultiMonth ? \"</div>\" + (numMonths[0] > 0 && col === numMonths[1] - 1 ? \"<div class='ui-datepicker-row-break'></div>\" : \"\") : \"\");\n\t\t\t\t\tgroup += calender;\n\t\t\t\t}\n\t\t\t\thtml += group;\n\t\t\t}\n\t\t\thtml += buttonPanel;\n\t\t\tinst._keyEvent = false;\n\t\t\treturn html;\n\t\t},\n\n\t\t/* Generate the month and year header. */\n\t\t_generateMonthYearHeader: function _generateMonthYearHeader(inst, drawMonth, drawYear, minDate, maxDate, secondary, monthNames, monthNamesShort) {\n\n\t\t\tvar inMinYear,\n\t\t\t    inMaxYear,\n\t\t\t    month,\n\t\t\t    years,\n\t\t\t    thisYear,\n\t\t\t    determineYear,\n\t\t\t    year,\n\t\t\t    endYear,\n\t\t\t    changeMonth = this._get(inst, \"changeMonth\"),\n\t\t\t    changeYear = this._get(inst, \"changeYear\"),\n\t\t\t    showMonthAfterYear = this._get(inst, \"showMonthAfterYear\"),\n\t\t\t    html = \"<div class='ui-datepicker-title'>\",\n\t\t\t    monthHtml = \"\";\n\n\t\t\t// month selection\n\t\t\tif (secondary || !changeMonth) {\n\t\t\t\tmonthHtml += \"<span class='ui-datepicker-month'>\" + monthNames[drawMonth] + \"</span>\";\n\t\t\t} else {\n\t\t\t\tinMinYear = minDate && minDate.getFullYear() === drawYear;\n\t\t\t\tinMaxYear = maxDate && maxDate.getFullYear() === drawYear;\n\t\t\t\tmonthHtml += \"<select class='ui-datepicker-month' data-handler='selectMonth' data-event='change'>\";\n\t\t\t\tfor (month = 0; month < 12; month++) {\n\t\t\t\t\tif ((!inMinYear || month >= minDate.getMonth()) && (!inMaxYear || month <= maxDate.getMonth())) {\n\t\t\t\t\t\tmonthHtml += \"<option value='\" + month + \"'\" + (month === drawMonth ? \" selected='selected'\" : \"\") + \">\" + monthNamesShort[month] + \"</option>\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmonthHtml += \"</select>\";\n\t\t\t}\n\n\t\t\tif (!showMonthAfterYear) {\n\t\t\t\thtml += monthHtml + (secondary || !(changeMonth && changeYear) ? \"&#xa0;\" : \"\");\n\t\t\t}\n\n\t\t\t// year selection\n\t\t\tif (!inst.yearshtml) {\n\t\t\t\tinst.yearshtml = \"\";\n\t\t\t\tif (secondary || !changeYear) {\n\t\t\t\t\thtml += \"<span class='ui-datepicker-year'>\" + drawYear + \"</span>\";\n\t\t\t\t} else {\n\t\t\t\t\t// determine range of years to display\n\t\t\t\t\tyears = this._get(inst, \"yearRange\").split(\":\");\n\t\t\t\t\tthisYear = new Date().getFullYear();\n\t\t\t\t\tdetermineYear = function determineYear(value) {\n\t\t\t\t\t\tvar year = value.match(/c[+\\-].*/) ? drawYear + parseInt(value.substring(1), 10) : value.match(/[+\\-].*/) ? thisYear + parseInt(value, 10) : parseInt(value, 10);\n\t\t\t\t\t\treturn isNaN(year) ? thisYear : year;\n\t\t\t\t\t};\n\t\t\t\t\tyear = determineYear(years[0]);\n\t\t\t\t\tendYear = Math.max(year, determineYear(years[1] || \"\"));\n\t\t\t\t\tyear = minDate ? Math.max(year, minDate.getFullYear()) : year;\n\t\t\t\t\tendYear = maxDate ? Math.min(endYear, maxDate.getFullYear()) : endYear;\n\t\t\t\t\tinst.yearshtml += \"<select class='ui-datepicker-year' data-handler='selectYear' data-event='change'>\";\n\t\t\t\t\tfor (; year <= endYear; year++) {\n\t\t\t\t\t\tinst.yearshtml += \"<option value='\" + year + \"'\" + (year === drawYear ? \" selected='selected'\" : \"\") + \">\" + year + \"</option>\";\n\t\t\t\t\t}\n\t\t\t\t\tinst.yearshtml += \"</select>\";\n\n\t\t\t\t\thtml += inst.yearshtml;\n\t\t\t\t\tinst.yearshtml = null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\thtml += this._get(inst, \"yearSuffix\");\n\t\t\tif (showMonthAfterYear) {\n\t\t\t\thtml += (secondary || !(changeMonth && changeYear) ? \"&#xa0;\" : \"\") + monthHtml;\n\t\t\t}\n\t\t\thtml += \"</div>\"; // Close datepicker_header\n\t\t\treturn html;\n\t\t},\n\n\t\t/* Adjust one of the date sub-fields. */\n\t\t_adjustInstDate: function _adjustInstDate(inst, offset, period) {\n\t\t\tvar year = inst.drawYear + (period === \"Y\" ? offset : 0),\n\t\t\t    month = inst.drawMonth + (period === \"M\" ? offset : 0),\n\t\t\t    day = Math.min(inst.selectedDay, this._getDaysInMonth(year, month)) + (period === \"D\" ? offset : 0),\n\t\t\t    date = this._restrictMinMax(inst, this._daylightSavingAdjust(new Date(year, month, day)));\n\n\t\t\tinst.selectedDay = date.getDate();\n\t\t\tinst.drawMonth = inst.selectedMonth = date.getMonth();\n\t\t\tinst.drawYear = inst.selectedYear = date.getFullYear();\n\t\t\tif (period === \"M\" || period === \"Y\") {\n\t\t\t\tthis._notifyChange(inst);\n\t\t\t}\n\t\t},\n\n\t\t/* Ensure a date is within any min/max bounds. */\n\t\t_restrictMinMax: function _restrictMinMax(inst, date) {\n\t\t\tvar minDate = this._getMinMaxDate(inst, \"min\"),\n\t\t\t    maxDate = this._getMinMaxDate(inst, \"max\"),\n\t\t\t    newDate = minDate && date < minDate ? minDate : date;\n\t\t\treturn maxDate && newDate > maxDate ? maxDate : newDate;\n\t\t},\n\n\t\t/* Notify change of month/year. */\n\t\t_notifyChange: function _notifyChange(inst) {\n\t\t\tvar onChange = this._get(inst, \"onChangeMonthYear\");\n\t\t\tif (onChange) {\n\t\t\t\tonChange.apply(inst.input ? inst.input[0] : null, [inst.selectedYear, inst.selectedMonth + 1, inst]);\n\t\t\t}\n\t\t},\n\n\t\t/* Determine the number of months to show. */\n\t\t_getNumberOfMonths: function _getNumberOfMonths(inst) {\n\t\t\tvar numMonths = this._get(inst, \"numberOfMonths\");\n\t\t\treturn numMonths == null ? [1, 1] : typeof numMonths === \"number\" ? [1, numMonths] : numMonths;\n\t\t},\n\n\t\t/* Determine the current maximum date - ensure no time components are set. */\n\t\t_getMinMaxDate: function _getMinMaxDate(inst, minMax) {\n\t\t\treturn this._determineDate(inst, this._get(inst, minMax + \"Date\"), null);\n\t\t},\n\n\t\t/* Find the number of days in a given month. */\n\t\t_getDaysInMonth: function _getDaysInMonth(year, month) {\n\t\t\treturn 32 - this._daylightSavingAdjust(new Date(year, month, 32)).getDate();\n\t\t},\n\n\t\t/* Find the day of the week of the first of a month. */\n\t\t_getFirstDayOfMonth: function _getFirstDayOfMonth(year, month) {\n\t\t\treturn new Date(year, month, 1).getDay();\n\t\t},\n\n\t\t/* Determines if we should allow a \"next/prev\" month display change. */\n\t\t_canAdjustMonth: function _canAdjustMonth(inst, offset, curYear, curMonth) {\n\t\t\tvar numMonths = this._getNumberOfMonths(inst),\n\t\t\t    date = this._daylightSavingAdjust(new Date(curYear, curMonth + (offset < 0 ? offset : numMonths[0] * numMonths[1]), 1));\n\n\t\t\tif (offset < 0) {\n\t\t\t\tdate.setDate(this._getDaysInMonth(date.getFullYear(), date.getMonth()));\n\t\t\t}\n\t\t\treturn this._isInRange(inst, date);\n\t\t},\n\n\t\t/* Is the given date in the accepted range? */\n\t\t_isInRange: function _isInRange(inst, date) {\n\t\t\tvar yearSplit,\n\t\t\t    currentYear,\n\t\t\t    minDate = this._getMinMaxDate(inst, \"min\"),\n\t\t\t    maxDate = this._getMinMaxDate(inst, \"max\"),\n\t\t\t    minYear = null,\n\t\t\t    maxYear = null,\n\t\t\t    years = this._get(inst, \"yearRange\");\n\t\t\tif (years) {\n\t\t\t\tyearSplit = years.split(\":\");\n\t\t\t\tcurrentYear = new Date().getFullYear();\n\t\t\t\tminYear = parseInt(yearSplit[0], 10);\n\t\t\t\tmaxYear = parseInt(yearSplit[1], 10);\n\t\t\t\tif (yearSplit[0].match(/[+\\-].*/)) {\n\t\t\t\t\tminYear += currentYear;\n\t\t\t\t}\n\t\t\t\tif (yearSplit[1].match(/[+\\-].*/)) {\n\t\t\t\t\tmaxYear += currentYear;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn (!minDate || date.getTime() >= minDate.getTime()) && (!maxDate || date.getTime() <= maxDate.getTime()) && (!minYear || date.getFullYear() >= minYear) && (!maxYear || date.getFullYear() <= maxYear);\n\t\t},\n\n\t\t/* Provide the configuration settings for formatting/parsing. */\n\t\t_getFormatConfig: function _getFormatConfig(inst) {\n\t\t\tvar shortYearCutoff = this._get(inst, \"shortYearCutoff\");\n\t\t\tshortYearCutoff = typeof shortYearCutoff !== \"string\" ? shortYearCutoff : new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10);\n\t\t\treturn { shortYearCutoff: shortYearCutoff,\n\t\t\t\tdayNamesShort: this._get(inst, \"dayNamesShort\"), dayNames: this._get(inst, \"dayNames\"),\n\t\t\t\tmonthNamesShort: this._get(inst, \"monthNamesShort\"), monthNames: this._get(inst, \"monthNames\") };\n\t\t},\n\n\t\t/* Format the given date for display. */\n\t\t_formatDate: function _formatDate(inst, day, month, year) {\n\t\t\tif (!day) {\n\t\t\t\tinst.currentDay = inst.selectedDay;\n\t\t\t\tinst.currentMonth = inst.selectedMonth;\n\t\t\t\tinst.currentYear = inst.selectedYear;\n\t\t\t}\n\t\t\tvar date = day ? (typeof day === \"undefined\" ? \"undefined\" : _typeof(day)) === \"object\" ? day : this._daylightSavingAdjust(new Date(year, month, day)) : this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay));\n\t\t\treturn this.formatDate(this._get(inst, \"dateFormat\"), date, this._getFormatConfig(inst));\n\t\t}\n\t});\n\n\t/*\n  * Bind hover events for datepicker elements.\n  * Done via delegate so the binding only occurs once in the lifetime of the parent div.\n  * Global datepicker_instActive, set by _updateDatepicker allows the handlers to find their way back to the active picker.\n  */\n\tfunction datepicker_bindHover(dpDiv) {\n\t\tvar selector = \"button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a\";\n\t\treturn dpDiv.delegate(selector, \"mouseout\", function () {\n\t\t\t$(this).removeClass(\"ui-state-hover\");\n\t\t\tif (this.className.indexOf(\"ui-datepicker-prev\") !== -1) {\n\t\t\t\t$(this).removeClass(\"ui-datepicker-prev-hover\");\n\t\t\t}\n\t\t\tif (this.className.indexOf(\"ui-datepicker-next\") !== -1) {\n\t\t\t\t$(this).removeClass(\"ui-datepicker-next-hover\");\n\t\t\t}\n\t\t}).delegate(selector, \"mouseover\", datepicker_handleMouseover);\n\t}\n\n\tfunction datepicker_handleMouseover() {\n\t\tif (!$.datepicker._isDisabledDatepicker(datepicker_instActive.inline ? datepicker_instActive.dpDiv.parent()[0] : datepicker_instActive.input[0])) {\n\t\t\t$(this).parents(\".ui-datepicker-calendar\").find(\"a\").removeClass(\"ui-state-hover\");\n\t\t\t$(this).addClass(\"ui-state-hover\");\n\t\t\tif (this.className.indexOf(\"ui-datepicker-prev\") !== -1) {\n\t\t\t\t$(this).addClass(\"ui-datepicker-prev-hover\");\n\t\t\t}\n\t\t\tif (this.className.indexOf(\"ui-datepicker-next\") !== -1) {\n\t\t\t\t$(this).addClass(\"ui-datepicker-next-hover\");\n\t\t\t}\n\t\t}\n\t}\n\n\t/* jQuery extend now ignores nulls! */\n\tfunction datepicker_extendRemove(target, props) {\n\t\t$.extend(target, props);\n\t\tfor (var name in props) {\n\t\t\tif (props[name] == null) {\n\t\t\t\ttarget[name] = props[name];\n\t\t\t}\n\t\t}\n\t\treturn target;\n\t}\n\n\t/* Invoke the datepicker functionality.\n    @param  options  string - a command, optionally followed by additional parameters or\n \t\t\t\t\tObject - settings for attaching new datepicker functionality\n    @return  jQuery object */\n\t$.fn.datepicker = function (options) {\n\n\t\t/* Verify an empty collection wasn't passed - Fixes #6976 */\n\t\tif (!this.length) {\n\t\t\treturn this;\n\t\t}\n\n\t\t/* Initialise the date picker. */\n\t\tif (!$.datepicker.initialized) {\n\t\t\t$(document).mousedown($.datepicker._checkExternalClick);\n\t\t\t$.datepicker.initialized = true;\n\t\t}\n\n\t\t/* Append datepicker main container to body if not exist. */\n\t\tif ($(\"#\" + $.datepicker._mainDivId).length === 0) {\n\t\t\t$(\"body\").append($.datepicker.dpDiv);\n\t\t}\n\n\t\tvar otherArgs = Array.prototype.slice.call(arguments, 1);\n\t\tif (typeof options === \"string\" && (options === \"isDisabled\" || options === \"getDate\" || options === \"widget\")) {\n\t\t\treturn $.datepicker[\"_\" + options + \"Datepicker\"].apply($.datepicker, [this[0]].concat(otherArgs));\n\t\t}\n\t\tif (options === \"option\" && arguments.length === 2 && typeof arguments[1] === \"string\") {\n\t\t\treturn $.datepicker[\"_\" + options + \"Datepicker\"].apply($.datepicker, [this[0]].concat(otherArgs));\n\t\t}\n\t\treturn this.each(function () {\n\t\t\ttypeof options === \"string\" ? $.datepicker[\"_\" + options + \"Datepicker\"].apply($.datepicker, [this].concat(otherArgs)) : $.datepicker._attachDatepicker(this, options);\n\t\t});\n\t};\n\n\t$.datepicker = new Datepicker(); // singleton instance\n\t$.datepicker.initialized = false;\n\t$.datepicker.uuid = new Date().getTime();\n\t$.datepicker.version = \"1.11.4\";\n\n\tvar datepicker = $.datepicker;\n\n\t/*!\n  * jQuery UI Draggable 1.11.4\n  * http://jqueryui.com\n  *\n  * Copyright jQuery Foundation and other contributors\n  * Released under the MIT license.\n  * http://jquery.org/license\n  *\n  * http://api.jqueryui.com/draggable/\n  */\n\n\t$.widget(\"ui.draggable\", $.ui.mouse, {\n\t\tversion: \"1.11.4\",\n\t\twidgetEventPrefix: \"drag\",\n\t\toptions: {\n\t\t\taddClasses: true,\n\t\t\tappendTo: \"parent\",\n\t\t\taxis: false,\n\t\t\tconnectToSortable: false,\n\t\t\tcontainment: false,\n\t\t\tcursor: \"auto\",\n\t\t\tcursorAt: false,\n\t\t\tgrid: false,\n\t\t\thandle: false,\n\t\t\thelper: \"original\",\n\t\t\tiframeFix: false,\n\t\t\topacity: false,\n\t\t\trefreshPositions: false,\n\t\t\trevert: false,\n\t\t\trevertDuration: 500,\n\t\t\tscope: \"default\",\n\t\t\tscroll: true,\n\t\t\tscrollSensitivity: 20,\n\t\t\tscrollSpeed: 20,\n\t\t\tsnap: false,\n\t\t\tsnapMode: \"both\",\n\t\t\tsnapTolerance: 20,\n\t\t\tstack: false,\n\t\t\tzIndex: false,\n\n\t\t\t// callbacks\n\t\t\tdrag: null,\n\t\t\tstart: null,\n\t\t\tstop: null\n\t\t},\n\t\t_create: function _create() {\n\n\t\t\tif (this.options.helper === \"original\") {\n\t\t\t\tthis._setPositionRelative();\n\t\t\t}\n\t\t\tif (this.options.addClasses) {\n\t\t\t\tthis.element.addClass(\"ui-draggable\");\n\t\t\t}\n\t\t\tif (this.options.disabled) {\n\t\t\t\tthis.element.addClass(\"ui-draggable-disabled\");\n\t\t\t}\n\t\t\tthis._setHandleClassName();\n\n\t\t\tthis._mouseInit();\n\t\t},\n\n\t\t_setOption: function _setOption(key, value) {\n\t\t\tthis._super(key, value);\n\t\t\tif (key === \"handle\") {\n\t\t\t\tthis._removeHandleClassName();\n\t\t\t\tthis._setHandleClassName();\n\t\t\t}\n\t\t},\n\n\t\t_destroy: function _destroy() {\n\t\t\tif ((this.helper || this.element).is(\".ui-draggable-dragging\")) {\n\t\t\t\tthis.destroyOnClear = true;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.element.removeClass(\"ui-draggable ui-draggable-dragging ui-draggable-disabled\");\n\t\t\tthis._removeHandleClassName();\n\t\t\tthis._mouseDestroy();\n\t\t},\n\n\t\t_mouseCapture: function _mouseCapture(event) {\n\t\t\tvar o = this.options;\n\n\t\t\tthis._blurActiveElement(event);\n\n\t\t\t// among others, prevent a drag on a resizable-handle\n\t\t\tif (this.helper || o.disabled || $(event.target).closest(\".ui-resizable-handle\").length > 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t//Quit if we're not on a valid handle\n\t\t\tthis.handle = this._getHandle(event);\n\t\t\tif (!this.handle) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tthis._blockFrames(o.iframeFix === true ? \"iframe\" : o.iframeFix);\n\n\t\t\treturn true;\n\t\t},\n\n\t\t_blockFrames: function _blockFrames(selector) {\n\t\t\tthis.iframeBlocks = this.document.find(selector).map(function () {\n\t\t\t\tvar iframe = $(this);\n\n\t\t\t\treturn $(\"<div>\").css(\"position\", \"absolute\").appendTo(iframe.parent()).outerWidth(iframe.outerWidth()).outerHeight(iframe.outerHeight()).offset(iframe.offset())[0];\n\t\t\t});\n\t\t},\n\n\t\t_unblockFrames: function _unblockFrames() {\n\t\t\tif (this.iframeBlocks) {\n\t\t\t\tthis.iframeBlocks.remove();\n\t\t\t\tdelete this.iframeBlocks;\n\t\t\t}\n\t\t},\n\n\t\t_blurActiveElement: function _blurActiveElement(event) {\n\t\t\tvar document = this.document[0];\n\n\t\t\t// Only need to blur if the event occurred on the draggable itself, see #10527\n\t\t\tif (!this.handleElement.is(event.target)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// support: IE9\n\t\t\t// IE9 throws an \"Unspecified error\" accessing document.activeElement from an <iframe>\n\t\t\ttry {\n\n\t\t\t\t// Support: IE9, IE10\n\t\t\t\t// If the <body> is blurred, IE will switch windows, see #9520\n\t\t\t\tif (document.activeElement && document.activeElement.nodeName.toLowerCase() !== \"body\") {\n\n\t\t\t\t\t// Blur any element that currently has focus, see #4261\n\t\t\t\t\t$(document.activeElement).blur();\n\t\t\t\t}\n\t\t\t} catch (error) {}\n\t\t},\n\n\t\t_mouseStart: function _mouseStart(event) {\n\n\t\t\tvar o = this.options;\n\n\t\t\t//Create and append the visible helper\n\t\t\tthis.helper = this._createHelper(event);\n\n\t\t\tthis.helper.addClass(\"ui-draggable-dragging\");\n\n\t\t\t//Cache the helper size\n\t\t\tthis._cacheHelperProportions();\n\n\t\t\t//If ddmanager is used for droppables, set the global draggable\n\t\t\tif ($.ui.ddmanager) {\n\t\t\t\t$.ui.ddmanager.current = this;\n\t\t\t}\n\n\t\t\t/*\n    * - Position generation -\n    * This block generates everything position related - it's the core of draggables.\n    */\n\n\t\t\t//Cache the margins of the original element\n\t\t\tthis._cacheMargins();\n\n\t\t\t//Store the helper's css position\n\t\t\tthis.cssPosition = this.helper.css(\"position\");\n\t\t\tthis.scrollParent = this.helper.scrollParent(true);\n\t\t\tthis.offsetParent = this.helper.offsetParent();\n\t\t\tthis.hasFixedAncestor = this.helper.parents().filter(function () {\n\t\t\t\treturn $(this).css(\"position\") === \"fixed\";\n\t\t\t}).length > 0;\n\n\t\t\t//The element's absolute position on the page minus margins\n\t\t\tthis.positionAbs = this.element.offset();\n\t\t\tthis._refreshOffsets(event);\n\n\t\t\t//Generate the original position\n\t\t\tthis.originalPosition = this.position = this._generatePosition(event, false);\n\t\t\tthis.originalPageX = event.pageX;\n\t\t\tthis.originalPageY = event.pageY;\n\n\t\t\t//Adjust the mouse offset relative to the helper if \"cursorAt\" is supplied\n\t\t\to.cursorAt && this._adjustOffsetFromHelper(o.cursorAt);\n\n\t\t\t//Set a containment if given in the options\n\t\t\tthis._setContainment();\n\n\t\t\t//Trigger event + callbacks\n\t\t\tif (this._trigger(\"start\", event) === false) {\n\t\t\t\tthis._clear();\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t//Recache the helper size\n\t\t\tthis._cacheHelperProportions();\n\n\t\t\t//Prepare the droppable offsets\n\t\t\tif ($.ui.ddmanager && !o.dropBehaviour) {\n\t\t\t\t$.ui.ddmanager.prepareOffsets(this, event);\n\t\t\t}\n\n\t\t\t// Reset helper's right/bottom css if they're set and set explicit width/height instead\n\t\t\t// as this prevents resizing of elements with right/bottom set (see #7772)\n\t\t\tthis._normalizeRightBottom();\n\n\t\t\tthis._mouseDrag(event, true); //Execute the drag once - this causes the helper not to be visible before getting its correct position\n\n\t\t\t//If the ddmanager is used for droppables, inform the manager that dragging has started (see #5003)\n\t\t\tif ($.ui.ddmanager) {\n\t\t\t\t$.ui.ddmanager.dragStart(this, event);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t},\n\n\t\t_refreshOffsets: function _refreshOffsets(event) {\n\t\t\tthis.offset = {\n\t\t\t\ttop: this.positionAbs.top - this.margins.top,\n\t\t\t\tleft: this.positionAbs.left - this.margins.left,\n\t\t\t\tscroll: false,\n\t\t\t\tparent: this._getParentOffset(),\n\t\t\t\trelative: this._getRelativeOffset()\n\t\t\t};\n\n\t\t\tthis.offset.click = {\n\t\t\t\tleft: event.pageX - this.offset.left,\n\t\t\t\ttop: event.pageY - this.offset.top\n\t\t\t};\n\t\t},\n\n\t\t_mouseDrag: function _mouseDrag(event, noPropagation) {\n\t\t\t// reset any necessary cached properties (see #5009)\n\t\t\tif (this.hasFixedAncestor) {\n\t\t\t\tthis.offset.parent = this._getParentOffset();\n\t\t\t}\n\n\t\t\t//Compute the helpers position\n\t\t\tthis.position = this._generatePosition(event, true);\n\t\t\tthis.positionAbs = this._convertPositionTo(\"absolute\");\n\n\t\t\t//Call plugins and callbacks and use the resulting position if something is returned\n\t\t\tif (!noPropagation) {\n\t\t\t\tvar ui = this._uiHash();\n\t\t\t\tif (this._trigger(\"drag\", event, ui) === false) {\n\t\t\t\t\tthis._mouseUp({});\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tthis.position = ui.position;\n\t\t\t}\n\n\t\t\tthis.helper[0].style.left = this.position.left + \"px\";\n\t\t\tthis.helper[0].style.top = this.position.top + \"px\";\n\n\t\t\tif ($.ui.ddmanager) {\n\t\t\t\t$.ui.ddmanager.drag(this, event);\n\t\t\t}\n\n\t\t\treturn false;\n\t\t},\n\n\t\t_mouseStop: function _mouseStop(event) {\n\n\t\t\t//If we are using droppables, inform the manager about the drop\n\t\t\tvar that = this,\n\t\t\t    dropped = false;\n\t\t\tif ($.ui.ddmanager && !this.options.dropBehaviour) {\n\t\t\t\tdropped = $.ui.ddmanager.drop(this, event);\n\t\t\t}\n\n\t\t\t//if a drop comes from outside (a sortable)\n\t\t\tif (this.dropped) {\n\t\t\t\tdropped = this.dropped;\n\t\t\t\tthis.dropped = false;\n\t\t\t}\n\n\t\t\tif (this.options.revert === \"invalid\" && !dropped || this.options.revert === \"valid\" && dropped || this.options.revert === true || $.isFunction(this.options.revert) && this.options.revert.call(this.element, dropped)) {\n\t\t\t\t$(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function () {\n\t\t\t\t\tif (that._trigger(\"stop\", event) !== false) {\n\t\t\t\t\t\tthat._clear();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tif (this._trigger(\"stop\", event) !== false) {\n\t\t\t\t\tthis._clear();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn false;\n\t\t},\n\n\t\t_mouseUp: function _mouseUp(event) {\n\t\t\tthis._unblockFrames();\n\n\t\t\t//If the ddmanager is used for droppables, inform the manager that dragging has stopped (see #5003)\n\t\t\tif ($.ui.ddmanager) {\n\t\t\t\t$.ui.ddmanager.dragStop(this, event);\n\t\t\t}\n\n\t\t\t// Only need to focus if the event occurred on the draggable itself, see #10527\n\t\t\tif (this.handleElement.is(event.target)) {\n\t\t\t\t// The interaction is over; whether or not the click resulted in a drag, focus the element\n\t\t\t\tthis.element.focus();\n\t\t\t}\n\n\t\t\treturn $.ui.mouse.prototype._mouseUp.call(this, event);\n\t\t},\n\n\t\tcancel: function cancel() {\n\n\t\t\tif (this.helper.is(\".ui-draggable-dragging\")) {\n\t\t\t\tthis._mouseUp({});\n\t\t\t} else {\n\t\t\t\tthis._clear();\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\t_getHandle: function _getHandle(event) {\n\t\t\treturn this.options.handle ? !!$(event.target).closest(this.element.find(this.options.handle)).length : true;\n\t\t},\n\n\t\t_setHandleClassName: function _setHandleClassName() {\n\t\t\tthis.handleElement = this.options.handle ? this.element.find(this.options.handle) : this.element;\n\t\t\tthis.handleElement.addClass(\"ui-draggable-handle\");\n\t\t},\n\n\t\t_removeHandleClassName: function _removeHandleClassName() {\n\t\t\tthis.handleElement.removeClass(\"ui-draggable-handle\");\n\t\t},\n\n\t\t_createHelper: function _createHelper(event) {\n\n\t\t\tvar o = this.options,\n\t\t\t    helperIsFunction = $.isFunction(o.helper),\n\t\t\t    helper = helperIsFunction ? $(o.helper.apply(this.element[0], [event])) : o.helper === \"clone\" ? this.element.clone().removeAttr(\"id\") : this.element;\n\n\t\t\tif (!helper.parents(\"body\").length) {\n\t\t\t\thelper.appendTo(o.appendTo === \"parent\" ? this.element[0].parentNode : o.appendTo);\n\t\t\t}\n\n\t\t\t// http://bugs.jqueryui.com/ticket/9446\n\t\t\t// a helper function can return the original element\n\t\t\t// which wouldn't have been set to relative in _create\n\t\t\tif (helperIsFunction && helper[0] === this.element[0]) {\n\t\t\t\tthis._setPositionRelative();\n\t\t\t}\n\n\t\t\tif (helper[0] !== this.element[0] && !/(fixed|absolute)/.test(helper.css(\"position\"))) {\n\t\t\t\thelper.css(\"position\", \"absolute\");\n\t\t\t}\n\n\t\t\treturn helper;\n\t\t},\n\n\t\t_setPositionRelative: function _setPositionRelative() {\n\t\t\tif (!/^(?:r|a|f)/.test(this.element.css(\"position\"))) {\n\t\t\t\tthis.element[0].style.position = \"relative\";\n\t\t\t}\n\t\t},\n\n\t\t_adjustOffsetFromHelper: function _adjustOffsetFromHelper(obj) {\n\t\t\tif (typeof obj === \"string\") {\n\t\t\t\tobj = obj.split(\" \");\n\t\t\t}\n\t\t\tif ($.isArray(obj)) {\n\t\t\t\tobj = { left: +obj[0], top: +obj[1] || 0 };\n\t\t\t}\n\t\t\tif (\"left\" in obj) {\n\t\t\t\tthis.offset.click.left = obj.left + this.margins.left;\n\t\t\t}\n\t\t\tif (\"right\" in obj) {\n\t\t\t\tthis.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;\n\t\t\t}\n\t\t\tif (\"top\" in obj) {\n\t\t\t\tthis.offset.click.top = obj.top + this.margins.top;\n\t\t\t}\n\t\t\tif (\"bottom\" in obj) {\n\t\t\t\tthis.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;\n\t\t\t}\n\t\t},\n\n\t\t_isRootNode: function _isRootNode(element) {\n\t\t\treturn (/(html|body)/i.test(element.tagName) || element === this.document[0]\n\t\t\t);\n\t\t},\n\n\t\t_getParentOffset: function _getParentOffset() {\n\n\t\t\t//Get the offsetParent and cache its position\n\t\t\tvar po = this.offsetParent.offset(),\n\t\t\t    document = this.document[0];\n\n\t\t\t// This is a special case where we need to modify a offset calculated on start, since the following happened:\n\t\t\t// 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent\n\t\t\t// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that\n\t\t\t//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag\n\t\t\tif (this.cssPosition === \"absolute\" && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {\n\t\t\t\tpo.left += this.scrollParent.scrollLeft();\n\t\t\t\tpo.top += this.scrollParent.scrollTop();\n\t\t\t}\n\n\t\t\tif (this._isRootNode(this.offsetParent[0])) {\n\t\t\t\tpo = { top: 0, left: 0 };\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\ttop: po.top + (parseInt(this.offsetParent.css(\"borderTopWidth\"), 10) || 0),\n\t\t\t\tleft: po.left + (parseInt(this.offsetParent.css(\"borderLeftWidth\"), 10) || 0)\n\t\t\t};\n\t\t},\n\n\t\t_getRelativeOffset: function _getRelativeOffset() {\n\t\t\tif (this.cssPosition !== \"relative\") {\n\t\t\t\treturn { top: 0, left: 0 };\n\t\t\t}\n\n\t\t\tvar p = this.element.position(),\n\t\t\t    scrollIsRootNode = this._isRootNode(this.scrollParent[0]);\n\n\t\t\treturn {\n\t\t\t\ttop: p.top - (parseInt(this.helper.css(\"top\"), 10) || 0) + (!scrollIsRootNode ? this.scrollParent.scrollTop() : 0),\n\t\t\t\tleft: p.left - (parseInt(this.helper.css(\"left\"), 10) || 0) + (!scrollIsRootNode ? this.scrollParent.scrollLeft() : 0)\n\t\t\t};\n\t\t},\n\n\t\t_cacheMargins: function _cacheMargins() {\n\t\t\tthis.margins = {\n\t\t\t\tleft: parseInt(this.element.css(\"marginLeft\"), 10) || 0,\n\t\t\t\ttop: parseInt(this.element.css(\"marginTop\"), 10) || 0,\n\t\t\t\tright: parseInt(this.element.css(\"marginRight\"), 10) || 0,\n\t\t\t\tbottom: parseInt(this.element.css(\"marginBottom\"), 10) || 0\n\t\t\t};\n\t\t},\n\n\t\t_cacheHelperProportions: function _cacheHelperProportions() {\n\t\t\tthis.helperProportions = {\n\t\t\t\twidth: this.helper.outerWidth(),\n\t\t\t\theight: this.helper.outerHeight()\n\t\t\t};\n\t\t},\n\n\t\t_setContainment: function _setContainment() {\n\n\t\t\tvar isUserScrollable,\n\t\t\t    c,\n\t\t\t    ce,\n\t\t\t    o = this.options,\n\t\t\t    document = this.document[0];\n\n\t\t\tthis.relativeContainer = null;\n\n\t\t\tif (!o.containment) {\n\t\t\t\tthis.containment = null;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (o.containment === \"window\") {\n\t\t\t\tthis.containment = [$(window).scrollLeft() - this.offset.relative.left - this.offset.parent.left, $(window).scrollTop() - this.offset.relative.top - this.offset.parent.top, $(window).scrollLeft() + $(window).width() - this.helperProportions.width - this.margins.left, $(window).scrollTop() + ($(window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top];\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (o.containment === \"document\") {\n\t\t\t\tthis.containment = [0, 0, $(document).width() - this.helperProportions.width - this.margins.left, ($(document).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top];\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (o.containment.constructor === Array) {\n\t\t\t\tthis.containment = o.containment;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (o.containment === \"parent\") {\n\t\t\t\to.containment = this.helper[0].parentNode;\n\t\t\t}\n\n\t\t\tc = $(o.containment);\n\t\t\tce = c[0];\n\n\t\t\tif (!ce) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tisUserScrollable = /(scroll|auto)/.test(c.css(\"overflow\"));\n\n\t\t\tthis.containment = [(parseInt(c.css(\"borderLeftWidth\"), 10) || 0) + (parseInt(c.css(\"paddingLeft\"), 10) || 0), (parseInt(c.css(\"borderTopWidth\"), 10) || 0) + (parseInt(c.css(\"paddingTop\"), 10) || 0), (isUserScrollable ? Math.max(ce.scrollWidth, ce.offsetWidth) : ce.offsetWidth) - (parseInt(c.css(\"borderRightWidth\"), 10) || 0) - (parseInt(c.css(\"paddingRight\"), 10) || 0) - this.helperProportions.width - this.margins.left - this.margins.right, (isUserScrollable ? Math.max(ce.scrollHeight, ce.offsetHeight) : ce.offsetHeight) - (parseInt(c.css(\"borderBottomWidth\"), 10) || 0) - (parseInt(c.css(\"paddingBottom\"), 10) || 0) - this.helperProportions.height - this.margins.top - this.margins.bottom];\n\t\t\tthis.relativeContainer = c;\n\t\t},\n\n\t\t_convertPositionTo: function _convertPositionTo(d, pos) {\n\n\t\t\tif (!pos) {\n\t\t\t\tpos = this.position;\n\t\t\t}\n\n\t\t\tvar mod = d === \"absolute\" ? 1 : -1,\n\t\t\t    scrollIsRootNode = this._isRootNode(this.scrollParent[0]);\n\n\t\t\treturn {\n\t\t\t\ttop: pos.top + // The absolute mouse position\n\t\t\t\tthis.offset.relative.top * mod + // Only for relative positioned nodes: Relative offset from element to offset parent\n\t\t\t\tthis.offset.parent.top * mod - // The offsetParent's offset without borders (offset + border)\n\t\t\t\t(this.cssPosition === \"fixed\" ? -this.offset.scroll.top : scrollIsRootNode ? 0 : this.offset.scroll.top) * mod,\n\t\t\t\tleft: pos.left + // The absolute mouse position\n\t\t\t\tthis.offset.relative.left * mod + // Only for relative positioned nodes: Relative offset from element to offset parent\n\t\t\t\tthis.offset.parent.left * mod - // The offsetParent's offset without borders (offset + border)\n\t\t\t\t(this.cssPosition === \"fixed\" ? -this.offset.scroll.left : scrollIsRootNode ? 0 : this.offset.scroll.left) * mod\n\t\t\t};\n\t\t},\n\n\t\t_generatePosition: function _generatePosition(event, constrainPosition) {\n\n\t\t\tvar containment,\n\t\t\t    co,\n\t\t\t    top,\n\t\t\t    left,\n\t\t\t    o = this.options,\n\t\t\t    scrollIsRootNode = this._isRootNode(this.scrollParent[0]),\n\t\t\t    pageX = event.pageX,\n\t\t\t    pageY = event.pageY;\n\n\t\t\t// Cache the scroll\n\t\t\tif (!scrollIsRootNode || !this.offset.scroll) {\n\t\t\t\tthis.offset.scroll = {\n\t\t\t\t\ttop: this.scrollParent.scrollTop(),\n\t\t\t\t\tleft: this.scrollParent.scrollLeft()\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t/*\n    * - Position constraining -\n    * Constrain the position to a mix of grid, containment.\n    */\n\n\t\t\t// If we are not dragging yet, we won't check for options\n\t\t\tif (constrainPosition) {\n\t\t\t\tif (this.containment) {\n\t\t\t\t\tif (this.relativeContainer) {\n\t\t\t\t\t\tco = this.relativeContainer.offset();\n\t\t\t\t\t\tcontainment = [this.containment[0] + co.left, this.containment[1] + co.top, this.containment[2] + co.left, this.containment[3] + co.top];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontainment = this.containment;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (event.pageX - this.offset.click.left < containment[0]) {\n\t\t\t\t\t\tpageX = containment[0] + this.offset.click.left;\n\t\t\t\t\t}\n\t\t\t\t\tif (event.pageY - this.offset.click.top < containment[1]) {\n\t\t\t\t\t\tpageY = containment[1] + this.offset.click.top;\n\t\t\t\t\t}\n\t\t\t\t\tif (event.pageX - this.offset.click.left > containment[2]) {\n\t\t\t\t\t\tpageX = containment[2] + this.offset.click.left;\n\t\t\t\t\t}\n\t\t\t\t\tif (event.pageY - this.offset.click.top > containment[3]) {\n\t\t\t\t\t\tpageY = containment[3] + this.offset.click.top;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (o.grid) {\n\t\t\t\t\t//Check for grid elements set to 0 to prevent divide by 0 error causing invalid argument errors in IE (see ticket #6950)\n\t\t\t\t\ttop = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY;\n\t\t\t\t\tpageY = containment ? top - this.offset.click.top >= containment[1] || top - this.offset.click.top > containment[3] ? top : top - this.offset.click.top >= containment[1] ? top - o.grid[1] : top + o.grid[1] : top;\n\n\t\t\t\t\tleft = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX;\n\t\t\t\t\tpageX = containment ? left - this.offset.click.left >= containment[0] || left - this.offset.click.left > containment[2] ? left : left - this.offset.click.left >= containment[0] ? left - o.grid[0] : left + o.grid[0] : left;\n\t\t\t\t}\n\n\t\t\t\tif (o.axis === \"y\") {\n\t\t\t\t\tpageX = this.originalPageX;\n\t\t\t\t}\n\n\t\t\t\tif (o.axis === \"x\") {\n\t\t\t\t\tpageY = this.originalPageY;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\ttop: pageY - // The absolute mouse position\n\t\t\t\tthis.offset.click.top - // Click offset (relative to the element)\n\t\t\t\tthis.offset.relative.top - // Only for relative positioned nodes: Relative offset from element to offset parent\n\t\t\t\tthis.offset.parent.top + ( // The offsetParent's offset without borders (offset + border)\n\t\t\t\tthis.cssPosition === \"fixed\" ? -this.offset.scroll.top : scrollIsRootNode ? 0 : this.offset.scroll.top),\n\t\t\t\tleft: pageX - // The absolute mouse position\n\t\t\t\tthis.offset.click.left - // Click offset (relative to the element)\n\t\t\t\tthis.offset.relative.left - // Only for relative positioned nodes: Relative offset from element to offset parent\n\t\t\t\tthis.offset.parent.left + ( // The offsetParent's offset without borders (offset + border)\n\t\t\t\tthis.cssPosition === \"fixed\" ? -this.offset.scroll.left : scrollIsRootNode ? 0 : this.offset.scroll.left)\n\t\t\t};\n\t\t},\n\n\t\t_clear: function _clear() {\n\t\t\tthis.helper.removeClass(\"ui-draggable-dragging\");\n\t\t\tif (this.helper[0] !== this.element[0] && !this.cancelHelperRemoval) {\n\t\t\t\tthis.helper.remove();\n\t\t\t}\n\t\t\tthis.helper = null;\n\t\t\tthis.cancelHelperRemoval = false;\n\t\t\tif (this.destroyOnClear) {\n\t\t\t\tthis.destroy();\n\t\t\t}\n\t\t},\n\n\t\t_normalizeRightBottom: function _normalizeRightBottom() {\n\t\t\tif (this.options.axis !== \"y\" && this.helper.css(\"right\") !== \"auto\") {\n\t\t\t\tthis.helper.width(this.helper.width());\n\t\t\t\tthis.helper.css(\"right\", \"auto\");\n\t\t\t}\n\t\t\tif (this.options.axis !== \"x\" && this.helper.css(\"bottom\") !== \"auto\") {\n\t\t\t\tthis.helper.height(this.helper.height());\n\t\t\t\tthis.helper.css(\"bottom\", \"auto\");\n\t\t\t}\n\t\t},\n\n\t\t// From now on bulk stuff - mainly helpers\n\n\t\t_trigger: function _trigger(type, event, ui) {\n\t\t\tui = ui || this._uiHash();\n\t\t\t$.ui.plugin.call(this, type, [event, ui, this], true);\n\n\t\t\t// Absolute position and offset (see #6884 ) have to be recalculated after plugins\n\t\t\tif (/^(drag|start|stop)/.test(type)) {\n\t\t\t\tthis.positionAbs = this._convertPositionTo(\"absolute\");\n\t\t\t\tui.offset = this.positionAbs;\n\t\t\t}\n\t\t\treturn $.Widget.prototype._trigger.call(this, type, event, ui);\n\t\t},\n\n\t\tplugins: {},\n\n\t\t_uiHash: function _uiHash() {\n\t\t\treturn {\n\t\t\t\thelper: this.helper,\n\t\t\t\tposition: this.position,\n\t\t\t\toriginalPosition: this.originalPosition,\n\t\t\t\toffset: this.positionAbs\n\t\t\t};\n\t\t}\n\n\t});\n\n\t$.ui.plugin.add(\"draggable\", \"connectToSortable\", {\n\t\tstart: function start(event, ui, draggable) {\n\t\t\tvar uiSortable = $.extend({}, ui, {\n\t\t\t\titem: draggable.element\n\t\t\t});\n\n\t\t\tdraggable.sortables = [];\n\t\t\t$(draggable.options.connectToSortable).each(function () {\n\t\t\t\tvar sortable = $(this).sortable(\"instance\");\n\n\t\t\t\tif (sortable && !sortable.options.disabled) {\n\t\t\t\t\tdraggable.sortables.push(sortable);\n\n\t\t\t\t\t// refreshPositions is called at drag start to refresh the containerCache\n\t\t\t\t\t// which is used in drag. This ensures it's initialized and synchronized\n\t\t\t\t\t// with any changes that might have happened on the page since initialization.\n\t\t\t\t\tsortable.refreshPositions();\n\t\t\t\t\tsortable._trigger(\"activate\", event, uiSortable);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\tstop: function stop(event, ui, draggable) {\n\t\t\tvar uiSortable = $.extend({}, ui, {\n\t\t\t\titem: draggable.element\n\t\t\t});\n\n\t\t\tdraggable.cancelHelperRemoval = false;\n\n\t\t\t$.each(draggable.sortables, function () {\n\t\t\t\tvar sortable = this;\n\n\t\t\t\tif (sortable.isOver) {\n\t\t\t\t\tsortable.isOver = 0;\n\n\t\t\t\t\t// Allow this sortable to handle removing the helper\n\t\t\t\t\tdraggable.cancelHelperRemoval = true;\n\t\t\t\t\tsortable.cancelHelperRemoval = false;\n\n\t\t\t\t\t// Use _storedCSS To restore properties in the sortable,\n\t\t\t\t\t// as this also handles revert (#9675) since the draggable\n\t\t\t\t\t// may have modified them in unexpected ways (#8809)\n\t\t\t\t\tsortable._storedCSS = {\n\t\t\t\t\t\tposition: sortable.placeholder.css(\"position\"),\n\t\t\t\t\t\ttop: sortable.placeholder.css(\"top\"),\n\t\t\t\t\t\tleft: sortable.placeholder.css(\"left\")\n\t\t\t\t\t};\n\n\t\t\t\t\tsortable._mouseStop(event);\n\n\t\t\t\t\t// Once drag has ended, the sortable should return to using\n\t\t\t\t\t// its original helper, not the shared helper from draggable\n\t\t\t\t\tsortable.options.helper = sortable.options._helper;\n\t\t\t\t} else {\n\t\t\t\t\t// Prevent this Sortable from removing the helper.\n\t\t\t\t\t// However, don't set the draggable to remove the helper\n\t\t\t\t\t// either as another connected Sortable may yet handle the removal.\n\t\t\t\t\tsortable.cancelHelperRemoval = true;\n\n\t\t\t\t\tsortable._trigger(\"deactivate\", event, uiSortable);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\tdrag: function drag(event, ui, draggable) {\n\t\t\t$.each(draggable.sortables, function () {\n\t\t\t\tvar innermostIntersecting = false,\n\t\t\t\t    sortable = this;\n\n\t\t\t\t// Copy over variables that sortable's _intersectsWith uses\n\t\t\t\tsortable.positionAbs = draggable.positionAbs;\n\t\t\t\tsortable.helperProportions = draggable.helperProportions;\n\t\t\t\tsortable.offset.click = draggable.offset.click;\n\n\t\t\t\tif (sortable._intersectsWith(sortable.containerCache)) {\n\t\t\t\t\tinnermostIntersecting = true;\n\n\t\t\t\t\t$.each(draggable.sortables, function () {\n\t\t\t\t\t\t// Copy over variables that sortable's _intersectsWith uses\n\t\t\t\t\t\tthis.positionAbs = draggable.positionAbs;\n\t\t\t\t\t\tthis.helperProportions = draggable.helperProportions;\n\t\t\t\t\t\tthis.offset.click = draggable.offset.click;\n\n\t\t\t\t\t\tif (this !== sortable && this._intersectsWith(this.containerCache) && $.contains(sortable.element[0], this.element[0])) {\n\t\t\t\t\t\t\tinnermostIntersecting = false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn innermostIntersecting;\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tif (innermostIntersecting) {\n\t\t\t\t\t// If it intersects, we use a little isOver variable and set it once,\n\t\t\t\t\t// so that the move-in stuff gets fired only once.\n\t\t\t\t\tif (!sortable.isOver) {\n\t\t\t\t\t\tsortable.isOver = 1;\n\n\t\t\t\t\t\t// Store draggable's parent in case we need to reappend to it later.\n\t\t\t\t\t\tdraggable._parent = ui.helper.parent();\n\n\t\t\t\t\t\tsortable.currentItem = ui.helper.appendTo(sortable.element).data(\"ui-sortable-item\", true);\n\n\t\t\t\t\t\t// Store helper option to later restore it\n\t\t\t\t\t\tsortable.options._helper = sortable.options.helper;\n\n\t\t\t\t\t\tsortable.options.helper = function () {\n\t\t\t\t\t\t\treturn ui.helper[0];\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// Fire the start events of the sortable with our passed browser event,\n\t\t\t\t\t\t// and our own helper (so it doesn't create a new one)\n\t\t\t\t\t\tevent.target = sortable.currentItem[0];\n\t\t\t\t\t\tsortable._mouseCapture(event, true);\n\t\t\t\t\t\tsortable._mouseStart(event, true, true);\n\n\t\t\t\t\t\t// Because the browser event is way off the new appended portlet,\n\t\t\t\t\t\t// modify necessary variables to reflect the changes\n\t\t\t\t\t\tsortable.offset.click.top = draggable.offset.click.top;\n\t\t\t\t\t\tsortable.offset.click.left = draggable.offset.click.left;\n\t\t\t\t\t\tsortable.offset.parent.left -= draggable.offset.parent.left - sortable.offset.parent.left;\n\t\t\t\t\t\tsortable.offset.parent.top -= draggable.offset.parent.top - sortable.offset.parent.top;\n\n\t\t\t\t\t\tdraggable._trigger(\"toSortable\", event);\n\n\t\t\t\t\t\t// Inform draggable that the helper is in a valid drop zone,\n\t\t\t\t\t\t// used solely in the revert option to handle \"valid/invalid\".\n\t\t\t\t\t\tdraggable.dropped = sortable.element;\n\n\t\t\t\t\t\t// Need to refreshPositions of all sortables in the case that\n\t\t\t\t\t\t// adding to one sortable changes the location of the other sortables (#9675)\n\t\t\t\t\t\t$.each(draggable.sortables, function () {\n\t\t\t\t\t\t\tthis.refreshPositions();\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\t// hack so receive/update callbacks work (mostly)\n\t\t\t\t\t\tdraggable.currentItem = draggable.element;\n\t\t\t\t\t\tsortable.fromOutside = draggable;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (sortable.currentItem) {\n\t\t\t\t\t\tsortable._mouseDrag(event);\n\t\t\t\t\t\t// Copy the sortable's position because the draggable's can potentially reflect\n\t\t\t\t\t\t// a relative position, while sortable is always absolute, which the dragged\n\t\t\t\t\t\t// element has now become. (#8809)\n\t\t\t\t\t\tui.position = sortable.position;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// If it doesn't intersect with the sortable, and it intersected before,\n\t\t\t\t\t// we fake the drag stop of the sortable, but make sure it doesn't remove\n\t\t\t\t\t// the helper by using cancelHelperRemoval.\n\t\t\t\t\tif (sortable.isOver) {\n\n\t\t\t\t\t\tsortable.isOver = 0;\n\t\t\t\t\t\tsortable.cancelHelperRemoval = true;\n\n\t\t\t\t\t\t// Calling sortable's mouseStop would trigger a revert,\n\t\t\t\t\t\t// so revert must be temporarily false until after mouseStop is called.\n\t\t\t\t\t\tsortable.options._revert = sortable.options.revert;\n\t\t\t\t\t\tsortable.options.revert = false;\n\n\t\t\t\t\t\tsortable._trigger(\"out\", event, sortable._uiHash(sortable));\n\t\t\t\t\t\tsortable._mouseStop(event, true);\n\n\t\t\t\t\t\t// restore sortable behaviors that were modfied\n\t\t\t\t\t\t// when the draggable entered the sortable area (#9481)\n\t\t\t\t\t\tsortable.options.revert = sortable.options._revert;\n\t\t\t\t\t\tsortable.options.helper = sortable.options._helper;\n\n\t\t\t\t\t\tif (sortable.placeholder) {\n\t\t\t\t\t\t\tsortable.placeholder.remove();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Restore and recalculate the draggable's offset considering the sortable\n\t\t\t\t\t\t// may have modified them in unexpected ways. (#8809, #10669)\n\t\t\t\t\t\tui.helper.appendTo(draggable._parent);\n\t\t\t\t\t\tdraggable._refreshOffsets(event);\n\t\t\t\t\t\tui.position = draggable._generatePosition(event, true);\n\n\t\t\t\t\t\tdraggable._trigger(\"fromSortable\", event);\n\n\t\t\t\t\t\t// Inform draggable that the helper is no longer in a valid drop zone\n\t\t\t\t\t\tdraggable.dropped = false;\n\n\t\t\t\t\t\t// Need to refreshPositions of all sortables just in case removing\n\t\t\t\t\t\t// from one sortable changes the location of other sortables (#9675)\n\t\t\t\t\t\t$.each(draggable.sortables, function () {\n\t\t\t\t\t\t\tthis.refreshPositions();\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t});\n\n\t$.ui.plugin.add(\"draggable\", \"cursor\", {\n\t\tstart: function start(event, ui, instance) {\n\t\t\tvar t = $(\"body\"),\n\t\t\t    o = instance.options;\n\n\t\t\tif (t.css(\"cursor\")) {\n\t\t\t\to._cursor = t.css(\"cursor\");\n\t\t\t}\n\t\t\tt.css(\"cursor\", o.cursor);\n\t\t},\n\t\tstop: function stop(event, ui, instance) {\n\t\t\tvar o = instance.options;\n\t\t\tif (o._cursor) {\n\t\t\t\t$(\"body\").css(\"cursor\", o._cursor);\n\t\t\t}\n\t\t}\n\t});\n\n\t$.ui.plugin.add(\"draggable\", \"opacity\", {\n\t\tstart: function start(event, ui, instance) {\n\t\t\tvar t = $(ui.helper),\n\t\t\t    o = instance.options;\n\t\t\tif (t.css(\"opacity\")) {\n\t\t\t\to._opacity = t.css(\"opacity\");\n\t\t\t}\n\t\t\tt.css(\"opacity\", o.opacity);\n\t\t},\n\t\tstop: function stop(event, ui, instance) {\n\t\t\tvar o = instance.options;\n\t\t\tif (o._opacity) {\n\t\t\t\t$(ui.helper).css(\"opacity\", o._opacity);\n\t\t\t}\n\t\t}\n\t});\n\n\t$.ui.plugin.add(\"draggable\", \"scroll\", {\n\t\tstart: function start(event, ui, i) {\n\t\t\tif (!i.scrollParentNotHidden) {\n\t\t\t\ti.scrollParentNotHidden = i.helper.scrollParent(false);\n\t\t\t}\n\n\t\t\tif (i.scrollParentNotHidden[0] !== i.document[0] && i.scrollParentNotHidden[0].tagName !== \"HTML\") {\n\t\t\t\ti.overflowOffset = i.scrollParentNotHidden.offset();\n\t\t\t}\n\t\t},\n\t\tdrag: function drag(event, ui, i) {\n\n\t\t\tvar o = i.options,\n\t\t\t    scrolled = false,\n\t\t\t    scrollParent = i.scrollParentNotHidden[0],\n\t\t\t    document = i.document[0];\n\n\t\t\tif (scrollParent !== document && scrollParent.tagName !== \"HTML\") {\n\t\t\t\tif (!o.axis || o.axis !== \"x\") {\n\t\t\t\t\tif (i.overflowOffset.top + scrollParent.offsetHeight - event.pageY < o.scrollSensitivity) {\n\t\t\t\t\t\tscrollParent.scrollTop = scrolled = scrollParent.scrollTop + o.scrollSpeed;\n\t\t\t\t\t} else if (event.pageY - i.overflowOffset.top < o.scrollSensitivity) {\n\t\t\t\t\t\tscrollParent.scrollTop = scrolled = scrollParent.scrollTop - o.scrollSpeed;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!o.axis || o.axis !== \"y\") {\n\t\t\t\t\tif (i.overflowOffset.left + scrollParent.offsetWidth - event.pageX < o.scrollSensitivity) {\n\t\t\t\t\t\tscrollParent.scrollLeft = scrolled = scrollParent.scrollLeft + o.scrollSpeed;\n\t\t\t\t\t} else if (event.pageX - i.overflowOffset.left < o.scrollSensitivity) {\n\t\t\t\t\t\tscrollParent.scrollLeft = scrolled = scrollParent.scrollLeft - o.scrollSpeed;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\tif (!o.axis || o.axis !== \"x\") {\n\t\t\t\t\tif (event.pageY - $(document).scrollTop() < o.scrollSensitivity) {\n\t\t\t\t\t\tscrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);\n\t\t\t\t\t} else if ($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {\n\t\t\t\t\t\tscrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!o.axis || o.axis !== \"y\") {\n\t\t\t\t\tif (event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {\n\t\t\t\t\t\tscrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);\n\t\t\t\t\t} else if ($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {\n\t\t\t\t\t\tscrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {\n\t\t\t\t$.ui.ddmanager.prepareOffsets(i, event);\n\t\t\t}\n\t\t}\n\t});\n\n\t$.ui.plugin.add(\"draggable\", \"snap\", {\n\t\tstart: function start(event, ui, i) {\n\n\t\t\tvar o = i.options;\n\n\t\t\ti.snapElements = [];\n\n\t\t\t$(o.snap.constructor !== String ? o.snap.items || \":data(ui-draggable)\" : o.snap).each(function () {\n\t\t\t\tvar $t = $(this),\n\t\t\t\t    $o = $t.offset();\n\t\t\t\tif (this !== i.element[0]) {\n\t\t\t\t\ti.snapElements.push({\n\t\t\t\t\t\titem: this,\n\t\t\t\t\t\twidth: $t.outerWidth(), height: $t.outerHeight(),\n\t\t\t\t\t\ttop: $o.top, left: $o.left\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\tdrag: function drag(event, ui, inst) {\n\n\t\t\tvar ts,\n\t\t\t    bs,\n\t\t\t    ls,\n\t\t\t    rs,\n\t\t\t    l,\n\t\t\t    r,\n\t\t\t    t,\n\t\t\t    b,\n\t\t\t    i,\n\t\t\t    first,\n\t\t\t    o = inst.options,\n\t\t\t    d = o.snapTolerance,\n\t\t\t    x1 = ui.offset.left,\n\t\t\t    x2 = x1 + inst.helperProportions.width,\n\t\t\t    y1 = ui.offset.top,\n\t\t\t    y2 = y1 + inst.helperProportions.height;\n\n\t\t\tfor (i = inst.snapElements.length - 1; i >= 0; i--) {\n\n\t\t\t\tl = inst.snapElements[i].left - inst.margins.left;\n\t\t\t\tr = l + inst.snapElements[i].width;\n\t\t\t\tt = inst.snapElements[i].top - inst.margins.top;\n\t\t\t\tb = t + inst.snapElements[i].height;\n\n\t\t\t\tif (x2 < l - d || x1 > r + d || y2 < t - d || y1 > b + d || !$.contains(inst.snapElements[i].item.ownerDocument, inst.snapElements[i].item)) {\n\t\t\t\t\tif (inst.snapElements[i].snapping) {\n\t\t\t\t\t\tinst.options.snap.release && inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item }));\n\t\t\t\t\t}\n\t\t\t\t\tinst.snapElements[i].snapping = false;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (o.snapMode !== \"inner\") {\n\t\t\t\t\tts = Math.abs(t - y2) <= d;\n\t\t\t\t\tbs = Math.abs(b - y1) <= d;\n\t\t\t\t\tls = Math.abs(l - x2) <= d;\n\t\t\t\t\trs = Math.abs(r - x1) <= d;\n\t\t\t\t\tif (ts) {\n\t\t\t\t\t\tui.position.top = inst._convertPositionTo(\"relative\", { top: t - inst.helperProportions.height, left: 0 }).top;\n\t\t\t\t\t}\n\t\t\t\t\tif (bs) {\n\t\t\t\t\t\tui.position.top = inst._convertPositionTo(\"relative\", { top: b, left: 0 }).top;\n\t\t\t\t\t}\n\t\t\t\t\tif (ls) {\n\t\t\t\t\t\tui.position.left = inst._convertPositionTo(\"relative\", { top: 0, left: l - inst.helperProportions.width }).left;\n\t\t\t\t\t}\n\t\t\t\t\tif (rs) {\n\t\t\t\t\t\tui.position.left = inst._convertPositionTo(\"relative\", { top: 0, left: r }).left;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfirst = ts || bs || ls || rs;\n\n\t\t\t\tif (o.snapMode !== \"outer\") {\n\t\t\t\t\tts = Math.abs(t - y1) <= d;\n\t\t\t\t\tbs = Math.abs(b - y2) <= d;\n\t\t\t\t\tls = Math.abs(l - x1) <= d;\n\t\t\t\t\trs = Math.abs(r - x2) <= d;\n\t\t\t\t\tif (ts) {\n\t\t\t\t\t\tui.position.top = inst._convertPositionTo(\"relative\", { top: t, left: 0 }).top;\n\t\t\t\t\t}\n\t\t\t\t\tif (bs) {\n\t\t\t\t\t\tui.position.top = inst._convertPositionTo(\"relative\", { top: b - inst.helperProportions.height, left: 0 }).top;\n\t\t\t\t\t}\n\t\t\t\t\tif (ls) {\n\t\t\t\t\t\tui.position.left = inst._convertPositionTo(\"relative\", { top: 0, left: l }).left;\n\t\t\t\t\t}\n\t\t\t\t\tif (rs) {\n\t\t\t\t\t\tui.position.left = inst._convertPositionTo(\"relative\", { top: 0, left: r - inst.helperProportions.width }).left;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!inst.snapElements[i].snapping && (ts || bs || ls || rs || first)) {\n\t\t\t\t\tinst.options.snap.snap && inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item }));\n\t\t\t\t}\n\t\t\t\tinst.snapElements[i].snapping = ts || bs || ls || rs || first;\n\t\t\t}\n\t\t}\n\t});\n\n\t$.ui.plugin.add(\"draggable\", \"stack\", {\n\t\tstart: function start(event, ui, instance) {\n\t\t\tvar min,\n\t\t\t    o = instance.options,\n\t\t\t    group = $.makeArray($(o.stack)).sort(function (a, b) {\n\t\t\t\treturn (parseInt($(a).css(\"zIndex\"), 10) || 0) - (parseInt($(b).css(\"zIndex\"), 10) || 0);\n\t\t\t});\n\n\t\t\tif (!group.length) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tmin = parseInt($(group[0]).css(\"zIndex\"), 10) || 0;\n\t\t\t$(group).each(function (i) {\n\t\t\t\t$(this).css(\"zIndex\", min + i);\n\t\t\t});\n\t\t\tthis.css(\"zIndex\", min + group.length);\n\t\t}\n\t});\n\n\t$.ui.plugin.add(\"draggable\", \"zIndex\", {\n\t\tstart: function start(event, ui, instance) {\n\t\t\tvar t = $(ui.helper),\n\t\t\t    o = instance.options;\n\n\t\t\tif (t.css(\"zIndex\")) {\n\t\t\t\to._zIndex = t.css(\"zIndex\");\n\t\t\t}\n\t\t\tt.css(\"zIndex\", o.zIndex);\n\t\t},\n\t\tstop: function stop(event, ui, instance) {\n\t\t\tvar o = instance.options;\n\n\t\t\tif (o._zIndex) {\n\t\t\t\t$(ui.helper).css(\"zIndex\", o._zIndex);\n\t\t\t}\n\t\t}\n\t});\n\n\tvar draggable = $.ui.draggable;\n\n\t/*!\n  * jQuery UI Resizable 1.11.4\n  * http://jqueryui.com\n  *\n  * Copyright jQuery Foundation and other contributors\n  * Released under the MIT license.\n  * http://jquery.org/license\n  *\n  * http://api.jqueryui.com/resizable/\n  */\n\n\t$.widget(\"ui.resizable\", $.ui.mouse, {\n\t\tversion: \"1.11.4\",\n\t\twidgetEventPrefix: \"resize\",\n\t\toptions: {\n\t\t\talsoResize: false,\n\t\t\tanimate: false,\n\t\t\tanimateDuration: \"slow\",\n\t\t\tanimateEasing: \"swing\",\n\t\t\taspectRatio: false,\n\t\t\tautoHide: false,\n\t\t\tcontainment: false,\n\t\t\tghost: false,\n\t\t\tgrid: false,\n\t\t\thandles: \"e,s,se\",\n\t\t\thelper: false,\n\t\t\tmaxHeight: null,\n\t\t\tmaxWidth: null,\n\t\t\tminHeight: 10,\n\t\t\tminWidth: 10,\n\t\t\t// See #7960\n\t\t\tzIndex: 90,\n\n\t\t\t// callbacks\n\t\t\tresize: null,\n\t\t\tstart: null,\n\t\t\tstop: null\n\t\t},\n\n\t\t_num: function _num(value) {\n\t\t\treturn parseInt(value, 10) || 0;\n\t\t},\n\n\t\t_isNumber: function _isNumber(value) {\n\t\t\treturn !isNaN(parseInt(value, 10));\n\t\t},\n\n\t\t_hasScroll: function _hasScroll(el, a) {\n\n\t\t\tif ($(el).css(\"overflow\") === \"hidden\") {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tvar scroll = a && a === \"left\" ? \"scrollLeft\" : \"scrollTop\",\n\t\t\t    has = false;\n\n\t\t\tif (el[scroll] > 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// TODO: determine which cases actually cause this to happen\n\t\t\t// if the element doesn't have the scroll set, see if it's possible to\n\t\t\t// set the scroll\n\t\t\tel[scroll] = 1;\n\t\t\thas = el[scroll] > 0;\n\t\t\tel[scroll] = 0;\n\t\t\treturn has;\n\t\t},\n\n\t\t_create: function _create() {\n\n\t\t\tvar n,\n\t\t\t    i,\n\t\t\t    handle,\n\t\t\t    axis,\n\t\t\t    hname,\n\t\t\t    that = this,\n\t\t\t    o = this.options;\n\t\t\tthis.element.addClass(\"ui-resizable\");\n\n\t\t\t$.extend(this, {\n\t\t\t\t_aspectRatio: !!o.aspectRatio,\n\t\t\t\taspectRatio: o.aspectRatio,\n\t\t\t\toriginalElement: this.element,\n\t\t\t\t_proportionallyResizeElements: [],\n\t\t\t\t_helper: o.helper || o.ghost || o.animate ? o.helper || \"ui-resizable-helper\" : null\n\t\t\t});\n\n\t\t\t// Wrap the element if it cannot hold child nodes\n\t\t\tif (this.element[0].nodeName.match(/^(canvas|textarea|input|select|button|img)$/i)) {\n\n\t\t\t\tthis.element.wrap($(\"<div class='ui-wrapper' style='overflow: hidden;'></div>\").css({\n\t\t\t\t\tposition: this.element.css(\"position\"),\n\t\t\t\t\twidth: this.element.outerWidth(),\n\t\t\t\t\theight: this.element.outerHeight(),\n\t\t\t\t\ttop: this.element.css(\"top\"),\n\t\t\t\t\tleft: this.element.css(\"left\")\n\t\t\t\t}));\n\n\t\t\t\tthis.element = this.element.parent().data(\"ui-resizable\", this.element.resizable(\"instance\"));\n\n\t\t\t\tthis.elementIsWrapper = true;\n\n\t\t\t\tthis.element.css({\n\t\t\t\t\tmarginLeft: this.originalElement.css(\"marginLeft\"),\n\t\t\t\t\tmarginTop: this.originalElement.css(\"marginTop\"),\n\t\t\t\t\tmarginRight: this.originalElement.css(\"marginRight\"),\n\t\t\t\t\tmarginBottom: this.originalElement.css(\"marginBottom\")\n\t\t\t\t});\n\t\t\t\tthis.originalElement.css({\n\t\t\t\t\tmarginLeft: 0,\n\t\t\t\t\tmarginTop: 0,\n\t\t\t\t\tmarginRight: 0,\n\t\t\t\t\tmarginBottom: 0\n\t\t\t\t});\n\t\t\t\t// support: Safari\n\t\t\t\t// Prevent Safari textarea resize\n\t\t\t\tthis.originalResizeStyle = this.originalElement.css(\"resize\");\n\t\t\t\tthis.originalElement.css(\"resize\", \"none\");\n\n\t\t\t\tthis._proportionallyResizeElements.push(this.originalElement.css({\n\t\t\t\t\tposition: \"static\",\n\t\t\t\t\tzoom: 1,\n\t\t\t\t\tdisplay: \"block\"\n\t\t\t\t}));\n\n\t\t\t\t// support: IE9\n\t\t\t\t// avoid IE jump (hard set the margin)\n\t\t\t\tthis.originalElement.css({ margin: this.originalElement.css(\"margin\") });\n\n\t\t\t\tthis._proportionallyResize();\n\t\t\t}\n\n\t\t\tthis.handles = o.handles || (!$(\".ui-resizable-handle\", this.element).length ? \"e,s,se\" : {\n\t\t\t\tn: \".ui-resizable-n\",\n\t\t\t\te: \".ui-resizable-e\",\n\t\t\t\ts: \".ui-resizable-s\",\n\t\t\t\tw: \".ui-resizable-w\",\n\t\t\t\tse: \".ui-resizable-se\",\n\t\t\t\tsw: \".ui-resizable-sw\",\n\t\t\t\tne: \".ui-resizable-ne\",\n\t\t\t\tnw: \".ui-resizable-nw\"\n\t\t\t});\n\n\t\t\tthis._handles = $();\n\t\t\tif (this.handles.constructor === String) {\n\n\t\t\t\tif (this.handles === \"all\") {\n\t\t\t\t\tthis.handles = \"n,e,s,w,se,sw,ne,nw\";\n\t\t\t\t}\n\n\t\t\t\tn = this.handles.split(\",\");\n\t\t\t\tthis.handles = {};\n\n\t\t\t\tfor (i = 0; i < n.length; i++) {\n\n\t\t\t\t\thandle = $.trim(n[i]);\n\t\t\t\t\thname = \"ui-resizable-\" + handle;\n\t\t\t\t\taxis = $(\"<div class='ui-resizable-handle \" + hname + \"'></div>\");\n\n\t\t\t\t\taxis.css({ zIndex: o.zIndex });\n\n\t\t\t\t\t// TODO : What's going on here?\n\t\t\t\t\tif (\"se\" === handle) {\n\t\t\t\t\t\taxis.addClass(\"ui-icon ui-icon-gripsmall-diagonal-se\");\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.handles[handle] = \".ui-resizable-\" + handle;\n\t\t\t\t\tthis.element.append(axis);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._renderAxis = function (target) {\n\n\t\t\t\tvar i, axis, padPos, padWrapper;\n\n\t\t\t\ttarget = target || this.element;\n\n\t\t\t\tfor (i in this.handles) {\n\n\t\t\t\t\tif (this.handles[i].constructor === String) {\n\t\t\t\t\t\tthis.handles[i] = this.element.children(this.handles[i]).first().show();\n\t\t\t\t\t} else if (this.handles[i].jquery || this.handles[i].nodeType) {\n\t\t\t\t\t\tthis.handles[i] = $(this.handles[i]);\n\t\t\t\t\t\tthis._on(this.handles[i], { \"mousedown\": that._mouseDown });\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this.elementIsWrapper && this.originalElement[0].nodeName.match(/^(textarea|input|select|button)$/i)) {\n\n\t\t\t\t\t\taxis = $(this.handles[i], this.element);\n\n\t\t\t\t\t\tpadWrapper = /sw|ne|nw|se|n|s/.test(i) ? axis.outerHeight() : axis.outerWidth();\n\n\t\t\t\t\t\tpadPos = [\"padding\", /ne|nw|n/.test(i) ? \"Top\" : /se|sw|s/.test(i) ? \"Bottom\" : /^e$/.test(i) ? \"Right\" : \"Left\"].join(\"\");\n\n\t\t\t\t\t\ttarget.css(padPos, padWrapper);\n\n\t\t\t\t\t\tthis._proportionallyResize();\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._handles = this._handles.add(this.handles[i]);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// TODO: make renderAxis a prototype function\n\t\t\tthis._renderAxis(this.element);\n\n\t\t\tthis._handles = this._handles.add(this.element.find(\".ui-resizable-handle\"));\n\t\t\tthis._handles.disableSelection();\n\n\t\t\tthis._handles.mouseover(function () {\n\t\t\t\tif (!that.resizing) {\n\t\t\t\t\tif (this.className) {\n\t\t\t\t\t\taxis = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);\n\t\t\t\t\t}\n\t\t\t\t\tthat.axis = axis && axis[1] ? axis[1] : \"se\";\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (o.autoHide) {\n\t\t\t\tthis._handles.hide();\n\t\t\t\t$(this.element).addClass(\"ui-resizable-autohide\").mouseenter(function () {\n\t\t\t\t\tif (o.disabled) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t$(this).removeClass(\"ui-resizable-autohide\");\n\t\t\t\t\tthat._handles.show();\n\t\t\t\t}).mouseleave(function () {\n\t\t\t\t\tif (o.disabled) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (!that.resizing) {\n\t\t\t\t\t\t$(this).addClass(\"ui-resizable-autohide\");\n\t\t\t\t\t\tthat._handles.hide();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tthis._mouseInit();\n\t\t},\n\n\t\t_destroy: function _destroy() {\n\n\t\t\tthis._mouseDestroy();\n\n\t\t\tvar wrapper,\n\t\t\t    _destroy = function _destroy(exp) {\n\t\t\t\t$(exp).removeClass(\"ui-resizable ui-resizable-disabled ui-resizable-resizing\").removeData(\"resizable\").removeData(\"ui-resizable\").unbind(\".resizable\").find(\".ui-resizable-handle\").remove();\n\t\t\t};\n\n\t\t\t// TODO: Unwrap at same DOM position\n\t\t\tif (this.elementIsWrapper) {\n\t\t\t\t_destroy(this.element);\n\t\t\t\twrapper = this.element;\n\t\t\t\tthis.originalElement.css({\n\t\t\t\t\tposition: wrapper.css(\"position\"),\n\t\t\t\t\twidth: wrapper.outerWidth(),\n\t\t\t\t\theight: wrapper.outerHeight(),\n\t\t\t\t\ttop: wrapper.css(\"top\"),\n\t\t\t\t\tleft: wrapper.css(\"left\")\n\t\t\t\t}).insertAfter(wrapper);\n\t\t\t\twrapper.remove();\n\t\t\t}\n\n\t\t\tthis.originalElement.css(\"resize\", this.originalResizeStyle);\n\t\t\t_destroy(this.originalElement);\n\n\t\t\treturn this;\n\t\t},\n\n\t\t_mouseCapture: function _mouseCapture(event) {\n\t\t\tvar i,\n\t\t\t    handle,\n\t\t\t    capture = false;\n\n\t\t\tfor (i in this.handles) {\n\t\t\t\thandle = $(this.handles[i])[0];\n\t\t\t\tif (handle === event.target || $.contains(handle, event.target)) {\n\t\t\t\t\tcapture = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn !this.options.disabled && capture;\n\t\t},\n\n\t\t_mouseStart: function _mouseStart(event) {\n\n\t\t\tvar curleft,\n\t\t\t    curtop,\n\t\t\t    cursor,\n\t\t\t    o = this.options,\n\t\t\t    el = this.element;\n\n\t\t\tthis.resizing = true;\n\n\t\t\tthis._renderProxy();\n\n\t\t\tcurleft = this._num(this.helper.css(\"left\"));\n\t\t\tcurtop = this._num(this.helper.css(\"top\"));\n\n\t\t\tif (o.containment) {\n\t\t\t\tcurleft += $(o.containment).scrollLeft() || 0;\n\t\t\t\tcurtop += $(o.containment).scrollTop() || 0;\n\t\t\t}\n\n\t\t\tthis.offset = this.helper.offset();\n\t\t\tthis.position = { left: curleft, top: curtop };\n\n\t\t\tthis.size = this._helper ? {\n\t\t\t\twidth: this.helper.width(),\n\t\t\t\theight: this.helper.height()\n\t\t\t} : {\n\t\t\t\twidth: el.width(),\n\t\t\t\theight: el.height()\n\t\t\t};\n\n\t\t\tthis.originalSize = this._helper ? {\n\t\t\t\twidth: el.outerWidth(),\n\t\t\t\theight: el.outerHeight()\n\t\t\t} : {\n\t\t\t\twidth: el.width(),\n\t\t\t\theight: el.height()\n\t\t\t};\n\n\t\t\tthis.sizeDiff = {\n\t\t\t\twidth: el.outerWidth() - el.width(),\n\t\t\t\theight: el.outerHeight() - el.height()\n\t\t\t};\n\n\t\t\tthis.originalPosition = { left: curleft, top: curtop };\n\t\t\tthis.originalMousePosition = { left: event.pageX, top: event.pageY };\n\n\t\t\tthis.aspectRatio = typeof o.aspectRatio === \"number\" ? o.aspectRatio : this.originalSize.width / this.originalSize.height || 1;\n\n\t\t\tcursor = $(\".ui-resizable-\" + this.axis).css(\"cursor\");\n\t\t\t$(\"body\").css(\"cursor\", cursor === \"auto\" ? this.axis + \"-resize\" : cursor);\n\n\t\t\tel.addClass(\"ui-resizable-resizing\");\n\t\t\tthis._propagate(\"start\", event);\n\t\t\treturn true;\n\t\t},\n\n\t\t_mouseDrag: function _mouseDrag(event) {\n\n\t\t\tvar data,\n\t\t\t    props,\n\t\t\t    smp = this.originalMousePosition,\n\t\t\t    a = this.axis,\n\t\t\t    dx = event.pageX - smp.left || 0,\n\t\t\t    dy = event.pageY - smp.top || 0,\n\t\t\t    trigger = this._change[a];\n\n\t\t\tthis._updatePrevProperties();\n\n\t\t\tif (!trigger) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tdata = trigger.apply(this, [event, dx, dy]);\n\n\t\t\tthis._updateVirtualBoundaries(event.shiftKey);\n\t\t\tif (this._aspectRatio || event.shiftKey) {\n\t\t\t\tdata = this._updateRatio(data, event);\n\t\t\t}\n\n\t\t\tdata = this._respectSize(data, event);\n\n\t\t\tthis._updateCache(data);\n\n\t\t\tthis._propagate(\"resize\", event);\n\n\t\t\tprops = this._applyChanges();\n\n\t\t\tif (!this._helper && this._proportionallyResizeElements.length) {\n\t\t\t\tthis._proportionallyResize();\n\t\t\t}\n\n\t\t\tif (!$.isEmptyObject(props)) {\n\t\t\t\tthis._updatePrevProperties();\n\t\t\t\tthis._trigger(\"resize\", event, this.ui());\n\t\t\t\tthis._applyChanges();\n\t\t\t}\n\n\t\t\treturn false;\n\t\t},\n\n\t\t_mouseStop: function _mouseStop(event) {\n\n\t\t\tthis.resizing = false;\n\t\t\tvar pr,\n\t\t\t    ista,\n\t\t\t    soffseth,\n\t\t\t    soffsetw,\n\t\t\t    s,\n\t\t\t    left,\n\t\t\t    top,\n\t\t\t    o = this.options,\n\t\t\t    that = this;\n\n\t\t\tif (this._helper) {\n\n\t\t\t\tpr = this._proportionallyResizeElements;\n\t\t\t\tista = pr.length && /textarea/i.test(pr[0].nodeName);\n\t\t\t\tsoffseth = ista && this._hasScroll(pr[0], \"left\") ? 0 : that.sizeDiff.height;\n\t\t\t\tsoffsetw = ista ? 0 : that.sizeDiff.width;\n\n\t\t\t\ts = {\n\t\t\t\t\twidth: that.helper.width() - soffsetw,\n\t\t\t\t\theight: that.helper.height() - soffseth\n\t\t\t\t};\n\t\t\t\tleft = parseInt(that.element.css(\"left\"), 10) + (that.position.left - that.originalPosition.left) || null;\n\t\t\t\ttop = parseInt(that.element.css(\"top\"), 10) + (that.position.top - that.originalPosition.top) || null;\n\n\t\t\t\tif (!o.animate) {\n\t\t\t\t\tthis.element.css($.extend(s, { top: top, left: left }));\n\t\t\t\t}\n\n\t\t\t\tthat.helper.height(that.size.height);\n\t\t\t\tthat.helper.width(that.size.width);\n\n\t\t\t\tif (this._helper && !o.animate) {\n\t\t\t\t\tthis._proportionallyResize();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t$(\"body\").css(\"cursor\", \"auto\");\n\n\t\t\tthis.element.removeClass(\"ui-resizable-resizing\");\n\n\t\t\tthis._propagate(\"stop\", event);\n\n\t\t\tif (this._helper) {\n\t\t\t\tthis.helper.remove();\n\t\t\t}\n\n\t\t\treturn false;\n\t\t},\n\n\t\t_updatePrevProperties: function _updatePrevProperties() {\n\t\t\tthis.prevPosition = {\n\t\t\t\ttop: this.position.top,\n\t\t\t\tleft: this.position.left\n\t\t\t};\n\t\t\tthis.prevSize = {\n\t\t\t\twidth: this.size.width,\n\t\t\t\theight: this.size.height\n\t\t\t};\n\t\t},\n\n\t\t_applyChanges: function _applyChanges() {\n\t\t\tvar props = {};\n\n\t\t\tif (this.position.top !== this.prevPosition.top) {\n\t\t\t\tprops.top = this.position.top + \"px\";\n\t\t\t}\n\t\t\tif (this.position.left !== this.prevPosition.left) {\n\t\t\t\tprops.left = this.position.left + \"px\";\n\t\t\t}\n\t\t\tif (this.size.width !== this.prevSize.width) {\n\t\t\t\tprops.width = this.size.width + \"px\";\n\t\t\t}\n\t\t\tif (this.size.height !== this.prevSize.height) {\n\t\t\t\tprops.height = this.size.height + \"px\";\n\t\t\t}\n\n\t\t\tthis.helper.css(props);\n\n\t\t\treturn props;\n\t\t},\n\n\t\t_updateVirtualBoundaries: function _updateVirtualBoundaries(forceAspectRatio) {\n\t\t\tvar pMinWidth,\n\t\t\t    pMaxWidth,\n\t\t\t    pMinHeight,\n\t\t\t    pMaxHeight,\n\t\t\t    b,\n\t\t\t    o = this.options;\n\n\t\t\tb = {\n\t\t\t\tminWidth: this._isNumber(o.minWidth) ? o.minWidth : 0,\n\t\t\t\tmaxWidth: this._isNumber(o.maxWidth) ? o.maxWidth : Infinity,\n\t\t\t\tminHeight: this._isNumber(o.minHeight) ? o.minHeight : 0,\n\t\t\t\tmaxHeight: this._isNumber(o.maxHeight) ? o.maxHeight : Infinity\n\t\t\t};\n\n\t\t\tif (this._aspectRatio || forceAspectRatio) {\n\t\t\t\tpMinWidth = b.minHeight * this.aspectRatio;\n\t\t\t\tpMinHeight = b.minWidth / this.aspectRatio;\n\t\t\t\tpMaxWidth = b.maxHeight * this.aspectRatio;\n\t\t\t\tpMaxHeight = b.maxWidth / this.aspectRatio;\n\n\t\t\t\tif (pMinWidth > b.minWidth) {\n\t\t\t\t\tb.minWidth = pMinWidth;\n\t\t\t\t}\n\t\t\t\tif (pMinHeight > b.minHeight) {\n\t\t\t\t\tb.minHeight = pMinHeight;\n\t\t\t\t}\n\t\t\t\tif (pMaxWidth < b.maxWidth) {\n\t\t\t\t\tb.maxWidth = pMaxWidth;\n\t\t\t\t}\n\t\t\t\tif (pMaxHeight < b.maxHeight) {\n\t\t\t\t\tb.maxHeight = pMaxHeight;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._vBoundaries = b;\n\t\t},\n\n\t\t_updateCache: function _updateCache(data) {\n\t\t\tthis.offset = this.helper.offset();\n\t\t\tif (this._isNumber(data.left)) {\n\t\t\t\tthis.position.left = data.left;\n\t\t\t}\n\t\t\tif (this._isNumber(data.top)) {\n\t\t\t\tthis.position.top = data.top;\n\t\t\t}\n\t\t\tif (this._isNumber(data.height)) {\n\t\t\t\tthis.size.height = data.height;\n\t\t\t}\n\t\t\tif (this._isNumber(data.width)) {\n\t\t\t\tthis.size.width = data.width;\n\t\t\t}\n\t\t},\n\n\t\t_updateRatio: function _updateRatio(data) {\n\n\t\t\tvar cpos = this.position,\n\t\t\t    csize = this.size,\n\t\t\t    a = this.axis;\n\n\t\t\tif (this._isNumber(data.height)) {\n\t\t\t\tdata.width = data.height * this.aspectRatio;\n\t\t\t} else if (this._isNumber(data.width)) {\n\t\t\t\tdata.height = data.width / this.aspectRatio;\n\t\t\t}\n\n\t\t\tif (a === \"sw\") {\n\t\t\t\tdata.left = cpos.left + (csize.width - data.width);\n\t\t\t\tdata.top = null;\n\t\t\t}\n\t\t\tif (a === \"nw\") {\n\t\t\t\tdata.top = cpos.top + (csize.height - data.height);\n\t\t\t\tdata.left = cpos.left + (csize.width - data.width);\n\t\t\t}\n\n\t\t\treturn data;\n\t\t},\n\n\t\t_respectSize: function _respectSize(data) {\n\n\t\t\tvar o = this._vBoundaries,\n\t\t\t    a = this.axis,\n\t\t\t    ismaxw = this._isNumber(data.width) && o.maxWidth && o.maxWidth < data.width,\n\t\t\t    ismaxh = this._isNumber(data.height) && o.maxHeight && o.maxHeight < data.height,\n\t\t\t    isminw = this._isNumber(data.width) && o.minWidth && o.minWidth > data.width,\n\t\t\t    isminh = this._isNumber(data.height) && o.minHeight && o.minHeight > data.height,\n\t\t\t    dw = this.originalPosition.left + this.originalSize.width,\n\t\t\t    dh = this.position.top + this.size.height,\n\t\t\t    cw = /sw|nw|w/.test(a),\n\t\t\t    ch = /nw|ne|n/.test(a);\n\t\t\tif (isminw) {\n\t\t\t\tdata.width = o.minWidth;\n\t\t\t}\n\t\t\tif (isminh) {\n\t\t\t\tdata.height = o.minHeight;\n\t\t\t}\n\t\t\tif (ismaxw) {\n\t\t\t\tdata.width = o.maxWidth;\n\t\t\t}\n\t\t\tif (ismaxh) {\n\t\t\t\tdata.height = o.maxHeight;\n\t\t\t}\n\n\t\t\tif (isminw && cw) {\n\t\t\t\tdata.left = dw - o.minWidth;\n\t\t\t}\n\t\t\tif (ismaxw && cw) {\n\t\t\t\tdata.left = dw - o.maxWidth;\n\t\t\t}\n\t\t\tif (isminh && ch) {\n\t\t\t\tdata.top = dh - o.minHeight;\n\t\t\t}\n\t\t\tif (ismaxh && ch) {\n\t\t\t\tdata.top = dh - o.maxHeight;\n\t\t\t}\n\n\t\t\t// Fixing jump error on top/left - bug #2330\n\t\t\tif (!data.width && !data.height && !data.left && data.top) {\n\t\t\t\tdata.top = null;\n\t\t\t} else if (!data.width && !data.height && !data.top && data.left) {\n\t\t\t\tdata.left = null;\n\t\t\t}\n\n\t\t\treturn data;\n\t\t},\n\n\t\t_getPaddingPlusBorderDimensions: function _getPaddingPlusBorderDimensions(element) {\n\t\t\tvar i = 0,\n\t\t\t    widths = [],\n\t\t\t    borders = [element.css(\"borderTopWidth\"), element.css(\"borderRightWidth\"), element.css(\"borderBottomWidth\"), element.css(\"borderLeftWidth\")],\n\t\t\t    paddings = [element.css(\"paddingTop\"), element.css(\"paddingRight\"), element.css(\"paddingBottom\"), element.css(\"paddingLeft\")];\n\n\t\t\tfor (; i < 4; i++) {\n\t\t\t\twidths[i] = parseInt(borders[i], 10) || 0;\n\t\t\t\twidths[i] += parseInt(paddings[i], 10) || 0;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\theight: widths[0] + widths[2],\n\t\t\t\twidth: widths[1] + widths[3]\n\t\t\t};\n\t\t},\n\n\t\t_proportionallyResize: function _proportionallyResize() {\n\n\t\t\tif (!this._proportionallyResizeElements.length) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar prel,\n\t\t\t    i = 0,\n\t\t\t    element = this.helper || this.element;\n\n\t\t\tfor (; i < this._proportionallyResizeElements.length; i++) {\n\n\t\t\t\tprel = this._proportionallyResizeElements[i];\n\n\t\t\t\t// TODO: Seems like a bug to cache this.outerDimensions\n\t\t\t\t// considering that we are in a loop.\n\t\t\t\tif (!this.outerDimensions) {\n\t\t\t\t\tthis.outerDimensions = this._getPaddingPlusBorderDimensions(prel);\n\t\t\t\t}\n\n\t\t\t\tprel.css({\n\t\t\t\t\theight: element.height() - this.outerDimensions.height || 0,\n\t\t\t\t\twidth: element.width() - this.outerDimensions.width || 0\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\n\t\t_renderProxy: function _renderProxy() {\n\n\t\t\tvar el = this.element,\n\t\t\t    o = this.options;\n\t\t\tthis.elementOffset = el.offset();\n\n\t\t\tif (this._helper) {\n\n\t\t\t\tthis.helper = this.helper || $(\"<div style='overflow:hidden;'></div>\");\n\n\t\t\t\tthis.helper.addClass(this._helper).css({\n\t\t\t\t\twidth: this.element.outerWidth() - 1,\n\t\t\t\t\theight: this.element.outerHeight() - 1,\n\t\t\t\t\tposition: \"absolute\",\n\t\t\t\t\tleft: this.elementOffset.left + \"px\",\n\t\t\t\t\ttop: this.elementOffset.top + \"px\",\n\t\t\t\t\tzIndex: ++o.zIndex //TODO: Don't modify option\n\t\t\t\t});\n\n\t\t\t\tthis.helper.appendTo(\"body\").disableSelection();\n\t\t\t} else {\n\t\t\t\tthis.helper = this.element;\n\t\t\t}\n\t\t},\n\n\t\t_change: {\n\t\t\te: function e(event, dx) {\n\t\t\t\treturn { width: this.originalSize.width + dx };\n\t\t\t},\n\t\t\tw: function w(event, dx) {\n\t\t\t\tvar cs = this.originalSize,\n\t\t\t\t    sp = this.originalPosition;\n\t\t\t\treturn { left: sp.left + dx, width: cs.width - dx };\n\t\t\t},\n\t\t\tn: function n(event, dx, dy) {\n\t\t\t\tvar cs = this.originalSize,\n\t\t\t\t    sp = this.originalPosition;\n\t\t\t\treturn { top: sp.top + dy, height: cs.height - dy };\n\t\t\t},\n\t\t\ts: function s(event, dx, dy) {\n\t\t\t\treturn { height: this.originalSize.height + dy };\n\t\t\t},\n\t\t\tse: function se(event, dx, dy) {\n\t\t\t\treturn $.extend(this._change.s.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));\n\t\t\t},\n\t\t\tsw: function sw(event, dx, dy) {\n\t\t\t\treturn $.extend(this._change.s.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));\n\t\t\t},\n\t\t\tne: function ne(event, dx, dy) {\n\t\t\t\treturn $.extend(this._change.n.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));\n\t\t\t},\n\t\t\tnw: function nw(event, dx, dy) {\n\t\t\t\treturn $.extend(this._change.n.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));\n\t\t\t}\n\t\t},\n\n\t\t_propagate: function _propagate(n, event) {\n\t\t\t$.ui.plugin.call(this, n, [event, this.ui()]);\n\t\t\tn !== \"resize\" && this._trigger(n, event, this.ui());\n\t\t},\n\n\t\tplugins: {},\n\n\t\tui: function ui() {\n\t\t\treturn {\n\t\t\t\toriginalElement: this.originalElement,\n\t\t\t\telement: this.element,\n\t\t\t\thelper: this.helper,\n\t\t\t\tposition: this.position,\n\t\t\t\tsize: this.size,\n\t\t\t\toriginalSize: this.originalSize,\n\t\t\t\toriginalPosition: this.originalPosition\n\t\t\t};\n\t\t}\n\n\t});\n\n\t/*\n  * Resizable Extensions\n  */\n\n\t$.ui.plugin.add(\"resizable\", \"animate\", {\n\n\t\tstop: function stop(event) {\n\t\t\tvar that = $(this).resizable(\"instance\"),\n\t\t\t    o = that.options,\n\t\t\t    pr = that._proportionallyResizeElements,\n\t\t\t    ista = pr.length && /textarea/i.test(pr[0].nodeName),\n\t\t\t    soffseth = ista && that._hasScroll(pr[0], \"left\") ? 0 : that.sizeDiff.height,\n\t\t\t    soffsetw = ista ? 0 : that.sizeDiff.width,\n\t\t\t    style = { width: that.size.width - soffsetw, height: that.size.height - soffseth },\n\t\t\t    left = parseInt(that.element.css(\"left\"), 10) + (that.position.left - that.originalPosition.left) || null,\n\t\t\t    top = parseInt(that.element.css(\"top\"), 10) + (that.position.top - that.originalPosition.top) || null;\n\n\t\t\tthat.element.animate($.extend(style, top && left ? { top: top, left: left } : {}), {\n\t\t\t\tduration: o.animateDuration,\n\t\t\t\teasing: o.animateEasing,\n\t\t\t\tstep: function step() {\n\n\t\t\t\t\tvar data = {\n\t\t\t\t\t\twidth: parseInt(that.element.css(\"width\"), 10),\n\t\t\t\t\t\theight: parseInt(that.element.css(\"height\"), 10),\n\t\t\t\t\t\ttop: parseInt(that.element.css(\"top\"), 10),\n\t\t\t\t\t\tleft: parseInt(that.element.css(\"left\"), 10)\n\t\t\t\t\t};\n\n\t\t\t\t\tif (pr && pr.length) {\n\t\t\t\t\t\t$(pr[0]).css({ width: data.width, height: data.height });\n\t\t\t\t\t}\n\n\t\t\t\t\t// propagating resize, and updating values for each animation step\n\t\t\t\t\tthat._updateCache(data);\n\t\t\t\t\tthat._propagate(\"resize\", event);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t});\n\n\t$.ui.plugin.add(\"resizable\", \"containment\", {\n\n\t\tstart: function start() {\n\t\t\tvar element,\n\t\t\t    p,\n\t\t\t    co,\n\t\t\t    ch,\n\t\t\t    cw,\n\t\t\t    width,\n\t\t\t    height,\n\t\t\t    that = $(this).resizable(\"instance\"),\n\t\t\t    o = that.options,\n\t\t\t    el = that.element,\n\t\t\t    oc = o.containment,\n\t\t\t    ce = oc instanceof $ ? oc.get(0) : /parent/.test(oc) ? el.parent().get(0) : oc;\n\n\t\t\tif (!ce) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthat.containerElement = $(ce);\n\n\t\t\tif (/document/.test(oc) || oc === document) {\n\t\t\t\tthat.containerOffset = {\n\t\t\t\t\tleft: 0,\n\t\t\t\t\ttop: 0\n\t\t\t\t};\n\t\t\t\tthat.containerPosition = {\n\t\t\t\t\tleft: 0,\n\t\t\t\t\ttop: 0\n\t\t\t\t};\n\n\t\t\t\tthat.parentData = {\n\t\t\t\t\telement: $(document),\n\t\t\t\t\tleft: 0,\n\t\t\t\t\ttop: 0,\n\t\t\t\t\twidth: $(document).width(),\n\t\t\t\t\theight: $(document).height() || document.body.parentNode.scrollHeight\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\telement = $(ce);\n\t\t\t\tp = [];\n\t\t\t\t$([\"Top\", \"Right\", \"Left\", \"Bottom\"]).each(function (i, name) {\n\t\t\t\t\tp[i] = that._num(element.css(\"padding\" + name));\n\t\t\t\t});\n\n\t\t\t\tthat.containerOffset = element.offset();\n\t\t\t\tthat.containerPosition = element.position();\n\t\t\t\tthat.containerSize = {\n\t\t\t\t\theight: element.innerHeight() - p[3],\n\t\t\t\t\twidth: element.innerWidth() - p[1]\n\t\t\t\t};\n\n\t\t\t\tco = that.containerOffset;\n\t\t\t\tch = that.containerSize.height;\n\t\t\t\tcw = that.containerSize.width;\n\t\t\t\twidth = that._hasScroll(ce, \"left\") ? ce.scrollWidth : cw;\n\t\t\t\theight = that._hasScroll(ce) ? ce.scrollHeight : ch;\n\n\t\t\t\tthat.parentData = {\n\t\t\t\t\telement: ce,\n\t\t\t\t\tleft: co.left,\n\t\t\t\t\ttop: co.top,\n\t\t\t\t\twidth: width,\n\t\t\t\t\theight: height\n\t\t\t\t};\n\t\t\t}\n\t\t},\n\n\t\tresize: function resize(event) {\n\t\t\tvar woset,\n\t\t\t    hoset,\n\t\t\t    isParent,\n\t\t\t    isOffsetRelative,\n\t\t\t    that = $(this).resizable(\"instance\"),\n\t\t\t    o = that.options,\n\t\t\t    co = that.containerOffset,\n\t\t\t    cp = that.position,\n\t\t\t    pRatio = that._aspectRatio || event.shiftKey,\n\t\t\t    cop = {\n\t\t\t\ttop: 0,\n\t\t\t\tleft: 0\n\t\t\t},\n\t\t\t    ce = that.containerElement,\n\t\t\t    continueResize = true;\n\n\t\t\tif (ce[0] !== document && /static/.test(ce.css(\"position\"))) {\n\t\t\t\tcop = co;\n\t\t\t}\n\n\t\t\tif (cp.left < (that._helper ? co.left : 0)) {\n\t\t\t\tthat.size.width = that.size.width + (that._helper ? that.position.left - co.left : that.position.left - cop.left);\n\n\t\t\t\tif (pRatio) {\n\t\t\t\t\tthat.size.height = that.size.width / that.aspectRatio;\n\t\t\t\t\tcontinueResize = false;\n\t\t\t\t}\n\t\t\t\tthat.position.left = o.helper ? co.left : 0;\n\t\t\t}\n\n\t\t\tif (cp.top < (that._helper ? co.top : 0)) {\n\t\t\t\tthat.size.height = that.size.height + (that._helper ? that.position.top - co.top : that.position.top);\n\n\t\t\t\tif (pRatio) {\n\t\t\t\t\tthat.size.width = that.size.height * that.aspectRatio;\n\t\t\t\t\tcontinueResize = false;\n\t\t\t\t}\n\t\t\t\tthat.position.top = that._helper ? co.top : 0;\n\t\t\t}\n\n\t\t\tisParent = that.containerElement.get(0) === that.element.parent().get(0);\n\t\t\tisOffsetRelative = /relative|absolute/.test(that.containerElement.css(\"position\"));\n\n\t\t\tif (isParent && isOffsetRelative) {\n\t\t\t\tthat.offset.left = that.parentData.left + that.position.left;\n\t\t\t\tthat.offset.top = that.parentData.top + that.position.top;\n\t\t\t} else {\n\t\t\t\tthat.offset.left = that.element.offset().left;\n\t\t\t\tthat.offset.top = that.element.offset().top;\n\t\t\t}\n\n\t\t\twoset = Math.abs(that.sizeDiff.width + (that._helper ? that.offset.left - cop.left : that.offset.left - co.left));\n\n\t\t\thoset = Math.abs(that.sizeDiff.height + (that._helper ? that.offset.top - cop.top : that.offset.top - co.top));\n\n\t\t\tif (woset + that.size.width >= that.parentData.width) {\n\t\t\t\tthat.size.width = that.parentData.width - woset;\n\t\t\t\tif (pRatio) {\n\t\t\t\t\tthat.size.height = that.size.width / that.aspectRatio;\n\t\t\t\t\tcontinueResize = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (hoset + that.size.height >= that.parentData.height) {\n\t\t\t\tthat.size.height = that.parentData.height - hoset;\n\t\t\t\tif (pRatio) {\n\t\t\t\t\tthat.size.width = that.size.height * that.aspectRatio;\n\t\t\t\t\tcontinueResize = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!continueResize) {\n\t\t\t\tthat.position.left = that.prevPosition.left;\n\t\t\t\tthat.position.top = that.prevPosition.top;\n\t\t\t\tthat.size.width = that.prevSize.width;\n\t\t\t\tthat.size.height = that.prevSize.height;\n\t\t\t}\n\t\t},\n\n\t\tstop: function stop() {\n\t\t\tvar that = $(this).resizable(\"instance\"),\n\t\t\t    o = that.options,\n\t\t\t    co = that.containerOffset,\n\t\t\t    cop = that.containerPosition,\n\t\t\t    ce = that.containerElement,\n\t\t\t    helper = $(that.helper),\n\t\t\t    ho = helper.offset(),\n\t\t\t    w = helper.outerWidth() - that.sizeDiff.width,\n\t\t\t    h = helper.outerHeight() - that.sizeDiff.height;\n\n\t\t\tif (that._helper && !o.animate && /relative/.test(ce.css(\"position\"))) {\n\t\t\t\t$(this).css({\n\t\t\t\t\tleft: ho.left - cop.left - co.left,\n\t\t\t\t\twidth: w,\n\t\t\t\t\theight: h\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (that._helper && !o.animate && /static/.test(ce.css(\"position\"))) {\n\t\t\t\t$(this).css({\n\t\t\t\t\tleft: ho.left - cop.left - co.left,\n\t\t\t\t\twidth: w,\n\t\t\t\t\theight: h\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t});\n\n\t$.ui.plugin.add(\"resizable\", \"alsoResize\", {\n\n\t\tstart: function start() {\n\t\t\tvar that = $(this).resizable(\"instance\"),\n\t\t\t    o = that.options;\n\n\t\t\t$(o.alsoResize).each(function () {\n\t\t\t\tvar el = $(this);\n\t\t\t\tel.data(\"ui-resizable-alsoresize\", {\n\t\t\t\t\twidth: parseInt(el.width(), 10), height: parseInt(el.height(), 10),\n\t\t\t\t\tleft: parseInt(el.css(\"left\"), 10), top: parseInt(el.css(\"top\"), 10)\n\t\t\t\t});\n\t\t\t});\n\t\t},\n\n\t\tresize: function resize(event, ui) {\n\t\t\tvar that = $(this).resizable(\"instance\"),\n\t\t\t    o = that.options,\n\t\t\t    os = that.originalSize,\n\t\t\t    op = that.originalPosition,\n\t\t\t    delta = {\n\t\t\t\theight: that.size.height - os.height || 0,\n\t\t\t\twidth: that.size.width - os.width || 0,\n\t\t\t\ttop: that.position.top - op.top || 0,\n\t\t\t\tleft: that.position.left - op.left || 0\n\t\t\t};\n\n\t\t\t$(o.alsoResize).each(function () {\n\t\t\t\tvar el = $(this),\n\t\t\t\t    start = $(this).data(\"ui-resizable-alsoresize\"),\n\t\t\t\t    style = {},\n\t\t\t\t    css = el.parents(ui.originalElement[0]).length ? [\"width\", \"height\"] : [\"width\", \"height\", \"top\", \"left\"];\n\n\t\t\t\t$.each(css, function (i, prop) {\n\t\t\t\t\tvar sum = (start[prop] || 0) + (delta[prop] || 0);\n\t\t\t\t\tif (sum && sum >= 0) {\n\t\t\t\t\t\tstyle[prop] = sum || null;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tel.css(style);\n\t\t\t});\n\t\t},\n\n\t\tstop: function stop() {\n\t\t\t$(this).removeData(\"resizable-alsoresize\");\n\t\t}\n\t});\n\n\t$.ui.plugin.add(\"resizable\", \"ghost\", {\n\n\t\tstart: function start() {\n\n\t\t\tvar that = $(this).resizable(\"instance\"),\n\t\t\t    o = that.options,\n\t\t\t    cs = that.size;\n\n\t\t\tthat.ghost = that.originalElement.clone();\n\t\t\tthat.ghost.css({\n\t\t\t\topacity: 0.25,\n\t\t\t\tdisplay: \"block\",\n\t\t\t\tposition: \"relative\",\n\t\t\t\theight: cs.height,\n\t\t\t\twidth: cs.width,\n\t\t\t\tmargin: 0,\n\t\t\t\tleft: 0,\n\t\t\t\ttop: 0\n\t\t\t}).addClass(\"ui-resizable-ghost\").addClass(typeof o.ghost === \"string\" ? o.ghost : \"\");\n\n\t\t\tthat.ghost.appendTo(that.helper);\n\t\t},\n\n\t\tresize: function resize() {\n\t\t\tvar that = $(this).resizable(\"instance\");\n\t\t\tif (that.ghost) {\n\t\t\t\tthat.ghost.css({\n\t\t\t\t\tposition: \"relative\",\n\t\t\t\t\theight: that.size.height,\n\t\t\t\t\twidth: that.size.width\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\n\t\tstop: function stop() {\n\t\t\tvar that = $(this).resizable(\"instance\");\n\t\t\tif (that.ghost && that.helper) {\n\t\t\t\tthat.helper.get(0).removeChild(that.ghost.get(0));\n\t\t\t}\n\t\t}\n\n\t});\n\n\t$.ui.plugin.add(\"resizable\", \"grid\", {\n\n\t\tresize: function resize() {\n\t\t\tvar outerDimensions,\n\t\t\t    that = $(this).resizable(\"instance\"),\n\t\t\t    o = that.options,\n\t\t\t    cs = that.size,\n\t\t\t    os = that.originalSize,\n\t\t\t    op = that.originalPosition,\n\t\t\t    a = that.axis,\n\t\t\t    grid = typeof o.grid === \"number\" ? [o.grid, o.grid] : o.grid,\n\t\t\t    gridX = grid[0] || 1,\n\t\t\t    gridY = grid[1] || 1,\n\t\t\t    ox = Math.round((cs.width - os.width) / gridX) * gridX,\n\t\t\t    oy = Math.round((cs.height - os.height) / gridY) * gridY,\n\t\t\t    newWidth = os.width + ox,\n\t\t\t    newHeight = os.height + oy,\n\t\t\t    isMaxWidth = o.maxWidth && o.maxWidth < newWidth,\n\t\t\t    isMaxHeight = o.maxHeight && o.maxHeight < newHeight,\n\t\t\t    isMinWidth = o.minWidth && o.minWidth > newWidth,\n\t\t\t    isMinHeight = o.minHeight && o.minHeight > newHeight;\n\n\t\t\to.grid = grid;\n\n\t\t\tif (isMinWidth) {\n\t\t\t\tnewWidth += gridX;\n\t\t\t}\n\t\t\tif (isMinHeight) {\n\t\t\t\tnewHeight += gridY;\n\t\t\t}\n\t\t\tif (isMaxWidth) {\n\t\t\t\tnewWidth -= gridX;\n\t\t\t}\n\t\t\tif (isMaxHeight) {\n\t\t\t\tnewHeight -= gridY;\n\t\t\t}\n\n\t\t\tif (/^(se|s|e)$/.test(a)) {\n\t\t\t\tthat.size.width = newWidth;\n\t\t\t\tthat.size.height = newHeight;\n\t\t\t} else if (/^(ne)$/.test(a)) {\n\t\t\t\tthat.size.width = newWidth;\n\t\t\t\tthat.size.height = newHeight;\n\t\t\t\tthat.position.top = op.top - oy;\n\t\t\t} else if (/^(sw)$/.test(a)) {\n\t\t\t\tthat.size.width = newWidth;\n\t\t\t\tthat.size.height = newHeight;\n\t\t\t\tthat.position.left = op.left - ox;\n\t\t\t} else {\n\t\t\t\tif (newHeight - gridY <= 0 || newWidth - gridX <= 0) {\n\t\t\t\t\touterDimensions = that._getPaddingPlusBorderDimensions(this);\n\t\t\t\t}\n\n\t\t\t\tif (newHeight - gridY > 0) {\n\t\t\t\t\tthat.size.height = newHeight;\n\t\t\t\t\tthat.position.top = op.top - oy;\n\t\t\t\t} else {\n\t\t\t\t\tnewHeight = gridY - outerDimensions.height;\n\t\t\t\t\tthat.size.height = newHeight;\n\t\t\t\t\tthat.position.top = op.top + os.height - newHeight;\n\t\t\t\t}\n\t\t\t\tif (newWidth - gridX > 0) {\n\t\t\t\t\tthat.size.width = newWidth;\n\t\t\t\t\tthat.position.left = op.left - ox;\n\t\t\t\t} else {\n\t\t\t\t\tnewWidth = gridX - outerDimensions.width;\n\t\t\t\t\tthat.size.width = newWidth;\n\t\t\t\t\tthat.position.left = op.left + os.width - newWidth;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t});\n\n\tvar resizable = $.ui.resizable;\n\n\t/*!\n  * jQuery UI Dialog 1.11.4\n  * http://jqueryui.com\n  *\n  * Copyright jQuery Foundation and other contributors\n  * Released under the MIT license.\n  * http://jquery.org/license\n  *\n  * http://api.jqueryui.com/dialog/\n  */\n\n\tvar dialog = $.widget(\"ui.dialog\", {\n\t\tversion: \"1.11.4\",\n\t\toptions: {\n\t\t\tappendTo: \"body\",\n\t\t\tautoOpen: true,\n\t\t\tbuttons: [],\n\t\t\tcloseOnEscape: true,\n\t\t\tcloseText: \"Close\",\n\t\t\tdialogClass: \"\",\n\t\t\tdraggable: true,\n\t\t\thide: null,\n\t\t\theight: \"auto\",\n\t\t\tmaxHeight: null,\n\t\t\tmaxWidth: null,\n\t\t\tminHeight: 150,\n\t\t\tminWidth: 150,\n\t\t\tmodal: false,\n\t\t\tposition: {\n\t\t\t\tmy: \"center\",\n\t\t\t\tat: \"center\",\n\t\t\t\tof: window,\n\t\t\t\tcollision: \"fit\",\n\t\t\t\t// Ensure the titlebar is always visible\n\t\t\t\tusing: function using(pos) {\n\t\t\t\t\tvar topOffset = $(this).css(pos).offset().top;\n\t\t\t\t\tif (topOffset < 0) {\n\t\t\t\t\t\t$(this).css(\"top\", pos.top - topOffset);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tresizable: true,\n\t\t\tshow: null,\n\t\t\ttitle: null,\n\t\t\twidth: 300,\n\n\t\t\t// callbacks\n\t\t\tbeforeClose: null,\n\t\t\tclose: null,\n\t\t\tdrag: null,\n\t\t\tdragStart: null,\n\t\t\tdragStop: null,\n\t\t\tfocus: null,\n\t\t\topen: null,\n\t\t\tresize: null,\n\t\t\tresizeStart: null,\n\t\t\tresizeStop: null\n\t\t},\n\n\t\tsizeRelatedOptions: {\n\t\t\tbuttons: true,\n\t\t\theight: true,\n\t\t\tmaxHeight: true,\n\t\t\tmaxWidth: true,\n\t\t\tminHeight: true,\n\t\t\tminWidth: true,\n\t\t\twidth: true\n\t\t},\n\n\t\tresizableRelatedOptions: {\n\t\t\tmaxHeight: true,\n\t\t\tmaxWidth: true,\n\t\t\tminHeight: true,\n\t\t\tminWidth: true\n\t\t},\n\n\t\t_create: function _create() {\n\t\t\tthis.originalCss = {\n\t\t\t\tdisplay: this.element[0].style.display,\n\t\t\t\twidth: this.element[0].style.width,\n\t\t\t\tminHeight: this.element[0].style.minHeight,\n\t\t\t\tmaxHeight: this.element[0].style.maxHeight,\n\t\t\t\theight: this.element[0].style.height\n\t\t\t};\n\t\t\tthis.originalPosition = {\n\t\t\t\tparent: this.element.parent(),\n\t\t\t\tindex: this.element.parent().children().index(this.element)\n\t\t\t};\n\t\t\tthis.originalTitle = this.element.attr(\"title\");\n\t\t\tthis.options.title = this.options.title || this.originalTitle;\n\n\t\t\tthis._createWrapper();\n\n\t\t\tthis.element.show().removeAttr(\"title\").addClass(\"ui-dialog-content ui-widget-content\").appendTo(this.uiDialog);\n\n\t\t\tthis._createTitlebar();\n\t\t\tthis._createButtonPane();\n\n\t\t\tif (this.options.draggable && $.fn.draggable) {\n\t\t\t\tthis._makeDraggable();\n\t\t\t}\n\t\t\tif (this.options.resizable && $.fn.resizable) {\n\t\t\t\tthis._makeResizable();\n\t\t\t}\n\n\t\t\tthis._isOpen = false;\n\n\t\t\tthis._trackFocus();\n\t\t},\n\n\t\t_init: function _init() {\n\t\t\tif (this.options.autoOpen) {\n\t\t\t\tthis.open();\n\t\t\t}\n\t\t},\n\n\t\t_appendTo: function _appendTo() {\n\t\t\tvar element = this.options.appendTo;\n\t\t\tif (element && (element.jquery || element.nodeType)) {\n\t\t\t\treturn $(element);\n\t\t\t}\n\t\t\treturn this.document.find(element || \"body\").eq(0);\n\t\t},\n\n\t\t_destroy: function _destroy() {\n\t\t\tvar next,\n\t\t\t    originalPosition = this.originalPosition;\n\n\t\t\tthis._untrackInstance();\n\t\t\tthis._destroyOverlay();\n\n\t\t\tthis.element.removeUniqueId().removeClass(\"ui-dialog-content ui-widget-content\").css(this.originalCss)\n\t\t\t// Without detaching first, the following becomes really slow\n\t\t\t.detach();\n\n\t\t\tthis.uiDialog.stop(true, true).remove();\n\n\t\t\tif (this.originalTitle) {\n\t\t\t\tthis.element.attr(\"title\", this.originalTitle);\n\t\t\t}\n\n\t\t\tnext = originalPosition.parent.children().eq(originalPosition.index);\n\t\t\t// Don't try to place the dialog next to itself (#8613)\n\t\t\tif (next.length && next[0] !== this.element[0]) {\n\t\t\t\tnext.before(this.element);\n\t\t\t} else {\n\t\t\t\toriginalPosition.parent.append(this.element);\n\t\t\t}\n\t\t},\n\n\t\twidget: function widget() {\n\t\t\treturn this.uiDialog;\n\t\t},\n\n\t\tdisable: $.noop,\n\t\tenable: $.noop,\n\n\t\tclose: function close(event) {\n\t\t\tvar activeElement,\n\t\t\t    that = this;\n\n\t\t\tif (!this._isOpen || this._trigger(\"beforeClose\", event) === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._isOpen = false;\n\t\t\tthis._focusedElement = null;\n\t\t\tthis._destroyOverlay();\n\t\t\tthis._untrackInstance();\n\n\t\t\tif (!this.opener.filter(\":focusable\").focus().length) {\n\n\t\t\t\t// support: IE9\n\t\t\t\t// IE9 throws an \"Unspecified error\" accessing document.activeElement from an <iframe>\n\t\t\t\ttry {\n\t\t\t\t\tactiveElement = this.document[0].activeElement;\n\n\t\t\t\t\t// Support: IE9, IE10\n\t\t\t\t\t// If the <body> is blurred, IE will switch windows, see #4520\n\t\t\t\t\tif (activeElement && activeElement.nodeName.toLowerCase() !== \"body\") {\n\n\t\t\t\t\t\t// Hiding a focused element doesn't trigger blur in WebKit\n\t\t\t\t\t\t// so in case we have nothing to focus on, explicitly blur the active element\n\t\t\t\t\t\t// https://bugs.webkit.org/show_bug.cgi?id=47182\n\t\t\t\t\t\t$(activeElement).blur();\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {}\n\t\t\t}\n\n\t\t\tthis._hide(this.uiDialog, this.options.hide, function () {\n\t\t\t\tthat._trigger(\"close\", event);\n\t\t\t});\n\t\t},\n\n\t\tisOpen: function isOpen() {\n\t\t\treturn this._isOpen;\n\t\t},\n\n\t\tmoveToTop: function moveToTop() {\n\t\t\tthis._moveToTop();\n\t\t},\n\n\t\t_moveToTop: function _moveToTop(event, silent) {\n\t\t\tvar moved = false,\n\t\t\t    zIndices = this.uiDialog.siblings(\".ui-front:visible\").map(function () {\n\t\t\t\treturn +$(this).css(\"z-index\");\n\t\t\t}).get(),\n\t\t\t    zIndexMax = Math.max.apply(null, zIndices);\n\n\t\t\tif (zIndexMax >= +this.uiDialog.css(\"z-index\")) {\n\t\t\t\tthis.uiDialog.css(\"z-index\", zIndexMax + 1);\n\t\t\t\tmoved = true;\n\t\t\t}\n\n\t\t\tif (moved && !silent) {\n\t\t\t\tthis._trigger(\"focus\", event);\n\t\t\t}\n\t\t\treturn moved;\n\t\t},\n\n\t\topen: function open() {\n\t\t\tvar that = this;\n\t\t\tif (this._isOpen) {\n\t\t\t\tif (this._moveToTop()) {\n\t\t\t\t\tthis._focusTabbable();\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._isOpen = true;\n\t\t\tthis.opener = $(this.document[0].activeElement);\n\n\t\t\tthis._size();\n\t\t\tthis._position();\n\t\t\tthis._createOverlay();\n\t\t\tthis._moveToTop(null, true);\n\n\t\t\t// Ensure the overlay is moved to the top with the dialog, but only when\n\t\t\t// opening. The overlay shouldn't move after the dialog is open so that\n\t\t\t// modeless dialogs opened after the modal dialog stack properly.\n\t\t\tif (this.overlay) {\n\t\t\t\tthis.overlay.css(\"z-index\", this.uiDialog.css(\"z-index\") - 1);\n\t\t\t}\n\n\t\t\tthis._show(this.uiDialog, this.options.show, function () {\n\t\t\t\tthat._focusTabbable();\n\t\t\t\tthat._trigger(\"focus\");\n\t\t\t});\n\n\t\t\t// Track the dialog immediately upon openening in case a focus event\n\t\t\t// somehow occurs outside of the dialog before an element inside the\n\t\t\t// dialog is focused (#10152)\n\t\t\tthis._makeFocusTarget();\n\n\t\t\tthis._trigger(\"open\");\n\t\t},\n\n\t\t_focusTabbable: function _focusTabbable() {\n\t\t\t// Set focus to the first match:\n\t\t\t// 1. An element that was focused previously\n\t\t\t// 2. First element inside the dialog matching [autofocus]\n\t\t\t// 3. Tabbable element inside the content element\n\t\t\t// 4. Tabbable element inside the buttonpane\n\t\t\t// 5. The close button\n\t\t\t// 6. The dialog itself\n\t\t\tvar hasFocus = this._focusedElement;\n\t\t\tif (!hasFocus) {\n\t\t\t\thasFocus = this.element.find(\"[autofocus]\");\n\t\t\t}\n\t\t\tif (!hasFocus.length) {\n\t\t\t\thasFocus = this.element.find(\":tabbable\");\n\t\t\t}\n\t\t\tif (!hasFocus.length) {\n\t\t\t\thasFocus = this.uiDialogButtonPane.find(\":tabbable\");\n\t\t\t}\n\t\t\tif (!hasFocus.length) {\n\t\t\t\thasFocus = this.uiDialogTitlebarClose.filter(\":tabbable\");\n\t\t\t}\n\t\t\tif (!hasFocus.length) {\n\t\t\t\thasFocus = this.uiDialog;\n\t\t\t}\n\t\t\thasFocus.eq(0).focus();\n\t\t},\n\n\t\t_keepFocus: function _keepFocus(event) {\n\t\t\tfunction checkFocus() {\n\t\t\t\tvar activeElement = this.document[0].activeElement,\n\t\t\t\t    isActive = this.uiDialog[0] === activeElement || $.contains(this.uiDialog[0], activeElement);\n\t\t\t\tif (!isActive) {\n\t\t\t\t\tthis._focusTabbable();\n\t\t\t\t}\n\t\t\t}\n\t\t\tevent.preventDefault();\n\t\t\tcheckFocus.call(this);\n\t\t\t// support: IE\n\t\t\t// IE <= 8 doesn't prevent moving focus even with event.preventDefault()\n\t\t\t// so we check again later\n\t\t\tthis._delay(checkFocus);\n\t\t},\n\n\t\t_createWrapper: function _createWrapper() {\n\t\t\tthis.uiDialog = $(\"<div>\").addClass(\"ui-dialog ui-widget ui-widget-content ui-corner-all ui-front \" + this.options.dialogClass).hide().attr({\n\t\t\t\t// Setting tabIndex makes the div focusable\n\t\t\t\ttabIndex: -1,\n\t\t\t\trole: \"dialog\"\n\t\t\t}).appendTo(this._appendTo());\n\n\t\t\tthis._on(this.uiDialog, {\n\t\t\t\tkeydown: function keydown(event) {\n\t\t\t\t\tif (this.options.closeOnEscape && !event.isDefaultPrevented() && event.keyCode && event.keyCode === $.ui.keyCode.ESCAPE) {\n\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\tthis.close(event);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// prevent tabbing out of dialogs\n\t\t\t\t\tif (event.keyCode !== $.ui.keyCode.TAB || event.isDefaultPrevented()) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tvar tabbables = this.uiDialog.find(\":tabbable\"),\n\t\t\t\t\t    first = tabbables.filter(\":first\"),\n\t\t\t\t\t    last = tabbables.filter(\":last\");\n\n\t\t\t\t\tif ((event.target === last[0] || event.target === this.uiDialog[0]) && !event.shiftKey) {\n\t\t\t\t\t\tthis._delay(function () {\n\t\t\t\t\t\t\tfirst.focus();\n\t\t\t\t\t\t});\n\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t} else if ((event.target === first[0] || event.target === this.uiDialog[0]) && event.shiftKey) {\n\t\t\t\t\t\tthis._delay(function () {\n\t\t\t\t\t\t\tlast.focus();\n\t\t\t\t\t\t});\n\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tmousedown: function mousedown(event) {\n\t\t\t\t\tif (this._moveToTop(event)) {\n\t\t\t\t\t\tthis._focusTabbable();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// We assume that any existing aria-describedby attribute means\n\t\t\t// that the dialog content is marked up properly\n\t\t\t// otherwise we brute force the content as the description\n\t\t\tif (!this.element.find(\"[aria-describedby]\").length) {\n\t\t\t\tthis.uiDialog.attr({\n\t\t\t\t\t\"aria-describedby\": this.element.uniqueId().attr(\"id\")\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\n\t\t_createTitlebar: function _createTitlebar() {\n\t\t\tvar uiDialogTitle;\n\n\t\t\tthis.uiDialogTitlebar = $(\"<div>\").addClass(\"ui-dialog-titlebar ui-widget-header ui-corner-all ui-helper-clearfix\").prependTo(this.uiDialog);\n\t\t\tthis._on(this.uiDialogTitlebar, {\n\t\t\t\tmousedown: function mousedown(event) {\n\t\t\t\t\t// Don't prevent click on close button (#8838)\n\t\t\t\t\t// Focusing a dialog that is partially scrolled out of view\n\t\t\t\t\t// causes the browser to scroll it into view, preventing the click event\n\t\t\t\t\tif (!$(event.target).closest(\".ui-dialog-titlebar-close\")) {\n\t\t\t\t\t\t// Dialog isn't getting focus when dragging (#8063)\n\t\t\t\t\t\tthis.uiDialog.focus();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// support: IE\n\t\t\t// Use type=\"button\" to prevent enter keypresses in textboxes from closing the\n\t\t\t// dialog in IE (#9312)\n\t\t\tthis.uiDialogTitlebarClose = $(\"<button type='button'></button>\").button({\n\t\t\t\tlabel: this.options.closeText,\n\t\t\t\ticons: {\n\t\t\t\t\tprimary: \"ui-icon-closethick\"\n\t\t\t\t},\n\t\t\t\ttext: false\n\t\t\t}).addClass(\"ui-dialog-titlebar-close\").appendTo(this.uiDialogTitlebar);\n\t\t\tthis._on(this.uiDialogTitlebarClose, {\n\t\t\t\tclick: function click(event) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\tthis.close(event);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tuiDialogTitle = $(\"<span>\").uniqueId().addClass(\"ui-dialog-title\").prependTo(this.uiDialogTitlebar);\n\t\t\tthis._title(uiDialogTitle);\n\n\t\t\tthis.uiDialog.attr({\n\t\t\t\t\"aria-labelledby\": uiDialogTitle.attr(\"id\")\n\t\t\t});\n\t\t},\n\n\t\t_title: function _title(title) {\n\t\t\tif (!this.options.title) {\n\t\t\t\ttitle.html(\"&#160;\");\n\t\t\t}\n\t\t\ttitle.text(this.options.title);\n\t\t},\n\n\t\t_createButtonPane: function _createButtonPane() {\n\t\t\tthis.uiDialogButtonPane = $(\"<div>\").addClass(\"ui-dialog-buttonpane ui-widget-content ui-helper-clearfix\");\n\n\t\t\tthis.uiButtonSet = $(\"<div>\").addClass(\"ui-dialog-buttonset\").appendTo(this.uiDialogButtonPane);\n\n\t\t\tthis._createButtons();\n\t\t},\n\n\t\t_createButtons: function _createButtons() {\n\t\t\tvar that = this,\n\t\t\t    buttons = this.options.buttons;\n\n\t\t\t// if we already have a button pane, remove it\n\t\t\tthis.uiDialogButtonPane.remove();\n\t\t\tthis.uiButtonSet.empty();\n\n\t\t\tif ($.isEmptyObject(buttons) || $.isArray(buttons) && !buttons.length) {\n\t\t\t\tthis.uiDialog.removeClass(\"ui-dialog-buttons\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t$.each(buttons, function (name, props) {\n\t\t\t\tvar click, buttonOptions;\n\t\t\t\tprops = $.isFunction(props) ? { click: props, text: name } : props;\n\t\t\t\t// Default to a non-submitting button\n\t\t\t\tprops = $.extend({ type: \"button\" }, props);\n\t\t\t\t// Change the context for the click callback to be the main element\n\t\t\t\tclick = props.click;\n\t\t\t\tprops.click = function () {\n\t\t\t\t\tclick.apply(that.element[0], arguments);\n\t\t\t\t};\n\t\t\t\tbuttonOptions = {\n\t\t\t\t\ticons: props.icons,\n\t\t\t\t\ttext: props.showText\n\t\t\t\t};\n\t\t\t\tdelete props.icons;\n\t\t\t\tdelete props.showText;\n\t\t\t\t$(\"<button></button>\", props).button(buttonOptions).appendTo(that.uiButtonSet);\n\t\t\t});\n\t\t\tthis.uiDialog.addClass(\"ui-dialog-buttons\");\n\t\t\tthis.uiDialogButtonPane.appendTo(this.uiDialog);\n\t\t},\n\n\t\t_makeDraggable: function _makeDraggable() {\n\t\t\tvar that = this,\n\t\t\t    options = this.options;\n\n\t\t\tfunction filteredUi(ui) {\n\t\t\t\treturn {\n\t\t\t\t\tposition: ui.position,\n\t\t\t\t\toffset: ui.offset\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tthis.uiDialog.draggable({\n\t\t\t\tcancel: \".ui-dialog-content, .ui-dialog-titlebar-close\",\n\t\t\t\thandle: \".ui-dialog-titlebar\",\n\t\t\t\tcontainment: \"document\",\n\t\t\t\tstart: function start(event, ui) {\n\t\t\t\t\t$(this).addClass(\"ui-dialog-dragging\");\n\t\t\t\t\tthat._blockFrames();\n\t\t\t\t\tthat._trigger(\"dragStart\", event, filteredUi(ui));\n\t\t\t\t},\n\t\t\t\tdrag: function drag(event, ui) {\n\t\t\t\t\tthat._trigger(\"drag\", event, filteredUi(ui));\n\t\t\t\t},\n\t\t\t\tstop: function stop(event, ui) {\n\t\t\t\t\tvar left = ui.offset.left - that.document.scrollLeft(),\n\t\t\t\t\t    top = ui.offset.top - that.document.scrollTop();\n\n\t\t\t\t\toptions.position = {\n\t\t\t\t\t\tmy: \"left top\",\n\t\t\t\t\t\tat: \"left\" + (left >= 0 ? \"+\" : \"\") + left + \" \" + \"top\" + (top >= 0 ? \"+\" : \"\") + top,\n\t\t\t\t\t\tof: that.window\n\t\t\t\t\t};\n\t\t\t\t\t$(this).removeClass(\"ui-dialog-dragging\");\n\t\t\t\t\tthat._unblockFrames();\n\t\t\t\t\tthat._trigger(\"dragStop\", event, filteredUi(ui));\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\t_makeResizable: function _makeResizable() {\n\t\t\tvar that = this,\n\t\t\t    options = this.options,\n\t\t\t    handles = options.resizable,\n\n\t\t\t// .ui-resizable has position: relative defined in the stylesheet\n\t\t\t// but dialogs have to use absolute or fixed positioning\n\t\t\tposition = this.uiDialog.css(\"position\"),\n\t\t\t    resizeHandles = typeof handles === \"string\" ? handles : \"n,e,s,w,se,sw,ne,nw\";\n\n\t\t\tfunction filteredUi(ui) {\n\t\t\t\treturn {\n\t\t\t\t\toriginalPosition: ui.originalPosition,\n\t\t\t\t\toriginalSize: ui.originalSize,\n\t\t\t\t\tposition: ui.position,\n\t\t\t\t\tsize: ui.size\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tthis.uiDialog.resizable({\n\t\t\t\tcancel: \".ui-dialog-content\",\n\t\t\t\tcontainment: \"document\",\n\t\t\t\talsoResize: this.element,\n\t\t\t\tmaxWidth: options.maxWidth,\n\t\t\t\tmaxHeight: options.maxHeight,\n\t\t\t\tminWidth: options.minWidth,\n\t\t\t\tminHeight: this._minHeight(),\n\t\t\t\thandles: resizeHandles,\n\t\t\t\tstart: function start(event, ui) {\n\t\t\t\t\t$(this).addClass(\"ui-dialog-resizing\");\n\t\t\t\t\tthat._blockFrames();\n\t\t\t\t\tthat._trigger(\"resizeStart\", event, filteredUi(ui));\n\t\t\t\t},\n\t\t\t\tresize: function resize(event, ui) {\n\t\t\t\t\tthat._trigger(\"resize\", event, filteredUi(ui));\n\t\t\t\t},\n\t\t\t\tstop: function stop(event, ui) {\n\t\t\t\t\tvar offset = that.uiDialog.offset(),\n\t\t\t\t\t    left = offset.left - that.document.scrollLeft(),\n\t\t\t\t\t    top = offset.top - that.document.scrollTop();\n\n\t\t\t\t\toptions.height = that.uiDialog.height();\n\t\t\t\t\toptions.width = that.uiDialog.width();\n\t\t\t\t\toptions.position = {\n\t\t\t\t\t\tmy: \"left top\",\n\t\t\t\t\t\tat: \"left\" + (left >= 0 ? \"+\" : \"\") + left + \" \" + \"top\" + (top >= 0 ? \"+\" : \"\") + top,\n\t\t\t\t\t\tof: that.window\n\t\t\t\t\t};\n\t\t\t\t\t$(this).removeClass(\"ui-dialog-resizing\");\n\t\t\t\t\tthat._unblockFrames();\n\t\t\t\t\tthat._trigger(\"resizeStop\", event, filteredUi(ui));\n\t\t\t\t}\n\t\t\t}).css(\"position\", position);\n\t\t},\n\n\t\t_trackFocus: function _trackFocus() {\n\t\t\tthis._on(this.widget(), {\n\t\t\t\tfocusin: function focusin(event) {\n\t\t\t\t\tthis._makeFocusTarget();\n\t\t\t\t\tthis._focusedElement = $(event.target);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\t_makeFocusTarget: function _makeFocusTarget() {\n\t\t\tthis._untrackInstance();\n\t\t\tthis._trackingInstances().unshift(this);\n\t\t},\n\n\t\t_untrackInstance: function _untrackInstance() {\n\t\t\tvar instances = this._trackingInstances(),\n\t\t\t    exists = $.inArray(this, instances);\n\t\t\tif (exists !== -1) {\n\t\t\t\tinstances.splice(exists, 1);\n\t\t\t}\n\t\t},\n\n\t\t_trackingInstances: function _trackingInstances() {\n\t\t\tvar instances = this.document.data(\"ui-dialog-instances\");\n\t\t\tif (!instances) {\n\t\t\t\tinstances = [];\n\t\t\t\tthis.document.data(\"ui-dialog-instances\", instances);\n\t\t\t}\n\t\t\treturn instances;\n\t\t},\n\n\t\t_minHeight: function _minHeight() {\n\t\t\tvar options = this.options;\n\n\t\t\treturn options.height === \"auto\" ? options.minHeight : Math.min(options.minHeight, options.height);\n\t\t},\n\n\t\t_position: function _position() {\n\t\t\t// Need to show the dialog to get the actual offset in the position plugin\n\t\t\tvar isVisible = this.uiDialog.is(\":visible\");\n\t\t\tif (!isVisible) {\n\t\t\t\tthis.uiDialog.show();\n\t\t\t}\n\t\t\tthis.uiDialog.position(this.options.position);\n\t\t\tif (!isVisible) {\n\t\t\t\tthis.uiDialog.hide();\n\t\t\t}\n\t\t},\n\n\t\t_setOptions: function _setOptions(options) {\n\t\t\tvar that = this,\n\t\t\t    resize = false,\n\t\t\t    resizableOptions = {};\n\n\t\t\t$.each(options, function (key, value) {\n\t\t\t\tthat._setOption(key, value);\n\n\t\t\t\tif (key in that.sizeRelatedOptions) {\n\t\t\t\t\tresize = true;\n\t\t\t\t}\n\t\t\t\tif (key in that.resizableRelatedOptions) {\n\t\t\t\t\tresizableOptions[key] = value;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (resize) {\n\t\t\t\tthis._size();\n\t\t\t\tthis._position();\n\t\t\t}\n\t\t\tif (this.uiDialog.is(\":data(ui-resizable)\")) {\n\t\t\t\tthis.uiDialog.resizable(\"option\", resizableOptions);\n\t\t\t}\n\t\t},\n\n\t\t_setOption: function _setOption(key, value) {\n\t\t\tvar isDraggable,\n\t\t\t    isResizable,\n\t\t\t    uiDialog = this.uiDialog;\n\n\t\t\tif (key === \"dialogClass\") {\n\t\t\t\tuiDialog.removeClass(this.options.dialogClass).addClass(value);\n\t\t\t}\n\n\t\t\tif (key === \"disabled\") {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._super(key, value);\n\n\t\t\tif (key === \"appendTo\") {\n\t\t\t\tthis.uiDialog.appendTo(this._appendTo());\n\t\t\t}\n\n\t\t\tif (key === \"buttons\") {\n\t\t\t\tthis._createButtons();\n\t\t\t}\n\n\t\t\tif (key === \"closeText\") {\n\t\t\t\tthis.uiDialogTitlebarClose.button({\n\t\t\t\t\t// Ensure that we always pass a string\n\t\t\t\t\tlabel: \"\" + value\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (key === \"draggable\") {\n\t\t\t\tisDraggable = uiDialog.is(\":data(ui-draggable)\");\n\t\t\t\tif (isDraggable && !value) {\n\t\t\t\t\tuiDialog.draggable(\"destroy\");\n\t\t\t\t}\n\n\t\t\t\tif (!isDraggable && value) {\n\t\t\t\t\tthis._makeDraggable();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (key === \"position\") {\n\t\t\t\tthis._position();\n\t\t\t}\n\n\t\t\tif (key === \"resizable\") {\n\t\t\t\t// currently resizable, becoming non-resizable\n\t\t\t\tisResizable = uiDialog.is(\":data(ui-resizable)\");\n\t\t\t\tif (isResizable && !value) {\n\t\t\t\t\tuiDialog.resizable(\"destroy\");\n\t\t\t\t}\n\n\t\t\t\t// currently resizable, changing handles\n\t\t\t\tif (isResizable && typeof value === \"string\") {\n\t\t\t\t\tuiDialog.resizable(\"option\", \"handles\", value);\n\t\t\t\t}\n\n\t\t\t\t// currently non-resizable, becoming resizable\n\t\t\t\tif (!isResizable && value !== false) {\n\t\t\t\t\tthis._makeResizable();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (key === \"title\") {\n\t\t\t\tthis._title(this.uiDialogTitlebar.find(\".ui-dialog-title\"));\n\t\t\t}\n\t\t},\n\n\t\t_size: function _size() {\n\t\t\t// If the user has resized the dialog, the .ui-dialog and .ui-dialog-content\n\t\t\t// divs will both have width and height set, so we need to reset them\n\t\t\tvar nonContentHeight,\n\t\t\t    minContentHeight,\n\t\t\t    maxContentHeight,\n\t\t\t    options = this.options;\n\n\t\t\t// Reset content sizing\n\t\t\tthis.element.show().css({\n\t\t\t\twidth: \"auto\",\n\t\t\t\tminHeight: 0,\n\t\t\t\tmaxHeight: \"none\",\n\t\t\t\theight: 0\n\t\t\t});\n\n\t\t\tif (options.minWidth > options.width) {\n\t\t\t\toptions.width = options.minWidth;\n\t\t\t}\n\n\t\t\t// reset wrapper sizing\n\t\t\t// determine the height of all the non-content elements\n\t\t\tnonContentHeight = this.uiDialog.css({\n\t\t\t\theight: \"auto\",\n\t\t\t\twidth: options.width\n\t\t\t}).outerHeight();\n\t\t\tminContentHeight = Math.max(0, options.minHeight - nonContentHeight);\n\t\t\tmaxContentHeight = typeof options.maxHeight === \"number\" ? Math.max(0, options.maxHeight - nonContentHeight) : \"none\";\n\n\t\t\tif (options.height === \"auto\") {\n\t\t\t\tthis.element.css({\n\t\t\t\t\tminHeight: minContentHeight,\n\t\t\t\t\tmaxHeight: maxContentHeight,\n\t\t\t\t\theight: \"auto\"\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthis.element.height(Math.max(0, options.height - nonContentHeight));\n\t\t\t}\n\n\t\t\tif (this.uiDialog.is(\":data(ui-resizable)\")) {\n\t\t\t\tthis.uiDialog.resizable(\"option\", \"minHeight\", this._minHeight());\n\t\t\t}\n\t\t},\n\n\t\t_blockFrames: function _blockFrames() {\n\t\t\tthis.iframeBlocks = this.document.find(\"iframe\").map(function () {\n\t\t\t\tvar iframe = $(this);\n\n\t\t\t\treturn $(\"<div>\").css({\n\t\t\t\t\tposition: \"absolute\",\n\t\t\t\t\twidth: iframe.outerWidth(),\n\t\t\t\t\theight: iframe.outerHeight()\n\t\t\t\t}).appendTo(iframe.parent()).offset(iframe.offset())[0];\n\t\t\t});\n\t\t},\n\n\t\t_unblockFrames: function _unblockFrames() {\n\t\t\tif (this.iframeBlocks) {\n\t\t\t\tthis.iframeBlocks.remove();\n\t\t\t\tdelete this.iframeBlocks;\n\t\t\t}\n\t\t},\n\n\t\t_allowInteraction: function _allowInteraction(event) {\n\t\t\tif ($(event.target).closest(\".ui-dialog\").length) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// TODO: Remove hack when datepicker implements\n\t\t\t// the .ui-front logic (#8989)\n\t\t\treturn !!$(event.target).closest(\".ui-datepicker\").length;\n\t\t},\n\n\t\t_createOverlay: function _createOverlay() {\n\t\t\tif (!this.options.modal) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// We use a delay in case the overlay is created from an\n\t\t\t// event that we're going to be cancelling (#2804)\n\t\t\tvar isOpening = true;\n\t\t\tthis._delay(function () {\n\t\t\t\tisOpening = false;\n\t\t\t});\n\n\t\t\tif (!this.document.data(\"ui-dialog-overlays\")) {\n\n\t\t\t\t// Prevent use of anchors and inputs\n\t\t\t\t// Using _on() for an event handler shared across many instances is\n\t\t\t\t// safe because the dialogs stack and must be closed in reverse order\n\t\t\t\tthis._on(this.document, {\n\t\t\t\t\tfocusin: function focusin(event) {\n\t\t\t\t\t\tif (isOpening) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!this._allowInteraction(event)) {\n\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\tthis._trackingInstances()[0]._focusTabbable();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tthis.overlay = $(\"<div>\").addClass(\"ui-widget-overlay ui-front\").appendTo(this._appendTo());\n\t\t\tthis._on(this.overlay, {\n\t\t\t\tmousedown: \"_keepFocus\"\n\t\t\t});\n\t\t\tthis.document.data(\"ui-dialog-overlays\", (this.document.data(\"ui-dialog-overlays\") || 0) + 1);\n\t\t},\n\n\t\t_destroyOverlay: function _destroyOverlay() {\n\t\t\tif (!this.options.modal) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (this.overlay) {\n\t\t\t\tvar overlays = this.document.data(\"ui-dialog-overlays\") - 1;\n\n\t\t\t\tif (!overlays) {\n\t\t\t\t\tthis.document.unbind(\"focusin\").removeData(\"ui-dialog-overlays\");\n\t\t\t\t} else {\n\t\t\t\t\tthis.document.data(\"ui-dialog-overlays\", overlays);\n\t\t\t\t}\n\n\t\t\t\tthis.overlay.remove();\n\t\t\t\tthis.overlay = null;\n\t\t\t}\n\t\t}\n\t});\n\n\t/*!\n  * jQuery UI Droppable 1.11.4\n  * http://jqueryui.com\n  *\n  * Copyright jQuery Foundation and other contributors\n  * Released under the MIT license.\n  * http://jquery.org/license\n  *\n  * http://api.jqueryui.com/droppable/\n  */\n\n\t$.widget(\"ui.droppable\", {\n\t\tversion: \"1.11.4\",\n\t\twidgetEventPrefix: \"drop\",\n\t\toptions: {\n\t\t\taccept: \"*\",\n\t\t\tactiveClass: false,\n\t\t\taddClasses: true,\n\t\t\tgreedy: false,\n\t\t\thoverClass: false,\n\t\t\tscope: \"default\",\n\t\t\ttolerance: \"intersect\",\n\n\t\t\t// callbacks\n\t\t\tactivate: null,\n\t\t\tdeactivate: null,\n\t\t\tdrop: null,\n\t\t\tout: null,\n\t\t\tover: null\n\t\t},\n\t\t_create: function _create() {\n\n\t\t\tvar proportions,\n\t\t\t    o = this.options,\n\t\t\t    accept = o.accept;\n\n\t\t\tthis.isover = false;\n\t\t\tthis.isout = true;\n\n\t\t\tthis.accept = $.isFunction(accept) ? accept : function (d) {\n\t\t\t\treturn d.is(accept);\n\t\t\t};\n\n\t\t\tthis.proportions = function () /* valueToWrite */{\n\t\t\t\tif (arguments.length) {\n\t\t\t\t\t// Store the droppable's proportions\n\t\t\t\t\tproportions = arguments[0];\n\t\t\t\t} else {\n\t\t\t\t\t// Retrieve or derive the droppable's proportions\n\t\t\t\t\treturn proportions ? proportions : proportions = {\n\t\t\t\t\t\twidth: this.element[0].offsetWidth,\n\t\t\t\t\t\theight: this.element[0].offsetHeight\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis._addToManager(o.scope);\n\n\t\t\to.addClasses && this.element.addClass(\"ui-droppable\");\n\t\t},\n\n\t\t_addToManager: function _addToManager(scope) {\n\t\t\t// Add the reference and positions to the manager\n\t\t\t$.ui.ddmanager.droppables[scope] = $.ui.ddmanager.droppables[scope] || [];\n\t\t\t$.ui.ddmanager.droppables[scope].push(this);\n\t\t},\n\n\t\t_splice: function _splice(drop) {\n\t\t\tvar i = 0;\n\t\t\tfor (; i < drop.length; i++) {\n\t\t\t\tif (drop[i] === this) {\n\t\t\t\t\tdrop.splice(i, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t_destroy: function _destroy() {\n\t\t\tvar drop = $.ui.ddmanager.droppables[this.options.scope];\n\n\t\t\tthis._splice(drop);\n\n\t\t\tthis.element.removeClass(\"ui-droppable ui-droppable-disabled\");\n\t\t},\n\n\t\t_setOption: function _setOption(key, value) {\n\n\t\t\tif (key === \"accept\") {\n\t\t\t\tthis.accept = $.isFunction(value) ? value : function (d) {\n\t\t\t\t\treturn d.is(value);\n\t\t\t\t};\n\t\t\t} else if (key === \"scope\") {\n\t\t\t\tvar drop = $.ui.ddmanager.droppables[this.options.scope];\n\n\t\t\t\tthis._splice(drop);\n\t\t\t\tthis._addToManager(value);\n\t\t\t}\n\n\t\t\tthis._super(key, value);\n\t\t},\n\n\t\t_activate: function _activate(event) {\n\t\t\tvar draggable = $.ui.ddmanager.current;\n\t\t\tif (this.options.activeClass) {\n\t\t\t\tthis.element.addClass(this.options.activeClass);\n\t\t\t}\n\t\t\tif (draggable) {\n\t\t\t\tthis._trigger(\"activate\", event, this.ui(draggable));\n\t\t\t}\n\t\t},\n\n\t\t_deactivate: function _deactivate(event) {\n\t\t\tvar draggable = $.ui.ddmanager.current;\n\t\t\tif (this.options.activeClass) {\n\t\t\t\tthis.element.removeClass(this.options.activeClass);\n\t\t\t}\n\t\t\tif (draggable) {\n\t\t\t\tthis._trigger(\"deactivate\", event, this.ui(draggable));\n\t\t\t}\n\t\t},\n\n\t\t_over: function _over(event) {\n\n\t\t\tvar draggable = $.ui.ddmanager.current;\n\n\t\t\t// Bail if draggable and droppable are same element\n\t\t\tif (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (this.accept.call(this.element[0], draggable.currentItem || draggable.element)) {\n\t\t\t\tif (this.options.hoverClass) {\n\t\t\t\t\tthis.element.addClass(this.options.hoverClass);\n\t\t\t\t}\n\t\t\t\tthis._trigger(\"over\", event, this.ui(draggable));\n\t\t\t}\n\t\t},\n\n\t\t_out: function _out(event) {\n\n\t\t\tvar draggable = $.ui.ddmanager.current;\n\n\t\t\t// Bail if draggable and droppable are same element\n\t\t\tif (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (this.accept.call(this.element[0], draggable.currentItem || draggable.element)) {\n\t\t\t\tif (this.options.hoverClass) {\n\t\t\t\t\tthis.element.removeClass(this.options.hoverClass);\n\t\t\t\t}\n\t\t\t\tthis._trigger(\"out\", event, this.ui(draggable));\n\t\t\t}\n\t\t},\n\n\t\t_drop: function _drop(event, custom) {\n\n\t\t\tvar draggable = custom || $.ui.ddmanager.current,\n\t\t\t    childrenIntersection = false;\n\n\t\t\t// Bail if draggable and droppable are same element\n\t\t\tif (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tthis.element.find(\":data(ui-droppable)\").not(\".ui-draggable-dragging\").each(function () {\n\t\t\t\tvar inst = $(this).droppable(\"instance\");\n\t\t\t\tif (inst.options.greedy && !inst.options.disabled && inst.options.scope === draggable.options.scope && inst.accept.call(inst.element[0], draggable.currentItem || draggable.element) && $.ui.intersect(draggable, $.extend(inst, { offset: inst.element.offset() }), inst.options.tolerance, event)) {\n\t\t\t\t\tchildrenIntersection = true;return false;\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (childrenIntersection) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (this.accept.call(this.element[0], draggable.currentItem || draggable.element)) {\n\t\t\t\tif (this.options.activeClass) {\n\t\t\t\t\tthis.element.removeClass(this.options.activeClass);\n\t\t\t\t}\n\t\t\t\tif (this.options.hoverClass) {\n\t\t\t\t\tthis.element.removeClass(this.options.hoverClass);\n\t\t\t\t}\n\t\t\t\tthis._trigger(\"drop\", event, this.ui(draggable));\n\t\t\t\treturn this.element;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t},\n\n\t\tui: function ui(c) {\n\t\t\treturn {\n\t\t\t\tdraggable: c.currentItem || c.element,\n\t\t\t\thelper: c.helper,\n\t\t\t\tposition: c.position,\n\t\t\t\toffset: c.positionAbs\n\t\t\t};\n\t\t}\n\n\t});\n\n\t$.ui.intersect = function () {\n\t\tfunction isOverAxis(x, reference, size) {\n\t\t\treturn x >= reference && x < reference + size;\n\t\t}\n\n\t\treturn function (draggable, droppable, toleranceMode, event) {\n\n\t\t\tif (!droppable.offset) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tvar x1 = (draggable.positionAbs || draggable.position.absolute).left + draggable.margins.left,\n\t\t\t    y1 = (draggable.positionAbs || draggable.position.absolute).top + draggable.margins.top,\n\t\t\t    x2 = x1 + draggable.helperProportions.width,\n\t\t\t    y2 = y1 + draggable.helperProportions.height,\n\t\t\t    l = droppable.offset.left,\n\t\t\t    t = droppable.offset.top,\n\t\t\t    r = l + droppable.proportions().width,\n\t\t\t    b = t + droppable.proportions().height;\n\n\t\t\tswitch (toleranceMode) {\n\t\t\t\tcase \"fit\":\n\t\t\t\t\treturn l <= x1 && x2 <= r && t <= y1 && y2 <= b;\n\t\t\t\tcase \"intersect\":\n\t\t\t\t\treturn l < x1 + draggable.helperProportions.width / 2 && // Right Half\n\t\t\t\t\tx2 - draggable.helperProportions.width / 2 < r && // Left Half\n\t\t\t\t\tt < y1 + draggable.helperProportions.height / 2 && // Bottom Half\n\t\t\t\t\ty2 - draggable.helperProportions.height / 2 < b; // Top Half\n\t\t\t\tcase \"pointer\":\n\t\t\t\t\treturn isOverAxis(event.pageY, t, droppable.proportions().height) && isOverAxis(event.pageX, l, droppable.proportions().width);\n\t\t\t\tcase \"touch\":\n\t\t\t\t\treturn (y1 >= t && y1 <= b || // Top edge touching\n\t\t\t\t\ty2 >= t && y2 <= b || // Bottom edge touching\n\t\t\t\t\ty1 < t && y2 > b // Surrounded vertically\n\t\t\t\t\t) && (x1 >= l && x1 <= r || // Left edge touching\n\t\t\t\t\tx2 >= l && x2 <= r || // Right edge touching\n\t\t\t\t\tx1 < l && x2 > r // Surrounded horizontally\n\t\t\t\t\t);\n\t\t\t\tdefault:\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t};\n\t}();\n\n\t/*\n \tThis manager tracks offsets of draggables and droppables\n */\n\t$.ui.ddmanager = {\n\t\tcurrent: null,\n\t\tdroppables: { \"default\": [] },\n\t\tprepareOffsets: function prepareOffsets(t, event) {\n\n\t\t\tvar i,\n\t\t\t    j,\n\t\t\t    m = $.ui.ddmanager.droppables[t.options.scope] || [],\n\t\t\t    type = event ? event.type : null,\n\t\t\t    // workaround for #2317\n\t\t\tlist = (t.currentItem || t.element).find(\":data(ui-droppable)\").addBack();\n\n\t\t\tdroppablesLoop: for (i = 0; i < m.length; i++) {\n\n\t\t\t\t// No disabled and non-accepted\n\t\t\t\tif (m[i].options.disabled || t && !m[i].accept.call(m[i].element[0], t.currentItem || t.element)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Filter out elements in the current dragged item\n\t\t\t\tfor (j = 0; j < list.length; j++) {\n\t\t\t\t\tif (list[j] === m[i].element[0]) {\n\t\t\t\t\t\tm[i].proportions().height = 0;\n\t\t\t\t\t\tcontinue droppablesLoop;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tm[i].visible = m[i].element.css(\"display\") !== \"none\";\n\t\t\t\tif (!m[i].visible) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Activate the droppable if used directly from draggables\n\t\t\t\tif (type === \"mousedown\") {\n\t\t\t\t\tm[i]._activate.call(m[i], event);\n\t\t\t\t}\n\n\t\t\t\tm[i].offset = m[i].element.offset();\n\t\t\t\tm[i].proportions({ width: m[i].element[0].offsetWidth, height: m[i].element[0].offsetHeight });\n\t\t\t}\n\t\t},\n\t\tdrop: function drop(draggable, event) {\n\n\t\t\tvar dropped = false;\n\t\t\t// Create a copy of the droppables in case the list changes during the drop (#9116)\n\t\t\t$.each(($.ui.ddmanager.droppables[draggable.options.scope] || []).slice(), function () {\n\n\t\t\t\tif (!this.options) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (!this.options.disabled && this.visible && $.ui.intersect(draggable, this, this.options.tolerance, event)) {\n\t\t\t\t\tdropped = this._drop.call(this, event) || dropped;\n\t\t\t\t}\n\n\t\t\t\tif (!this.options.disabled && this.visible && this.accept.call(this.element[0], draggable.currentItem || draggable.element)) {\n\t\t\t\t\tthis.isout = true;\n\t\t\t\t\tthis.isover = false;\n\t\t\t\t\tthis._deactivate.call(this, event);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn dropped;\n\t\t},\n\t\tdragStart: function dragStart(draggable, event) {\n\t\t\t// Listen for scrolling so that if the dragging causes scrolling the position of the droppables can be recalculated (see #5003)\n\t\t\tdraggable.element.parentsUntil(\"body\").bind(\"scroll.droppable\", function () {\n\t\t\t\tif (!draggable.options.refreshPositions) {\n\t\t\t\t\t$.ui.ddmanager.prepareOffsets(draggable, event);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\tdrag: function drag(draggable, event) {\n\n\t\t\t// If you have a highly dynamic page, you might try this option. It renders positions every time you move the mouse.\n\t\t\tif (draggable.options.refreshPositions) {\n\t\t\t\t$.ui.ddmanager.prepareOffsets(draggable, event);\n\t\t\t}\n\n\t\t\t// Run through all droppables and check their positions based on specific tolerance options\n\t\t\t$.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function () {\n\n\t\t\t\tif (this.options.disabled || this.greedyChild || !this.visible) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar parentInstance,\n\t\t\t\t    scope,\n\t\t\t\t    parent,\n\t\t\t\t    intersects = $.ui.intersect(draggable, this, this.options.tolerance, event),\n\t\t\t\t    c = !intersects && this.isover ? \"isout\" : intersects && !this.isover ? \"isover\" : null;\n\t\t\t\tif (!c) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (this.options.greedy) {\n\t\t\t\t\t// find droppable parents with same scope\n\t\t\t\t\tscope = this.options.scope;\n\t\t\t\t\tparent = this.element.parents(\":data(ui-droppable)\").filter(function () {\n\t\t\t\t\t\treturn $(this).droppable(\"instance\").options.scope === scope;\n\t\t\t\t\t});\n\n\t\t\t\t\tif (parent.length) {\n\t\t\t\t\t\tparentInstance = $(parent[0]).droppable(\"instance\");\n\t\t\t\t\t\tparentInstance.greedyChild = c === \"isover\";\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// we just moved into a greedy child\n\t\t\t\tif (parentInstance && c === \"isover\") {\n\t\t\t\t\tparentInstance.isover = false;\n\t\t\t\t\tparentInstance.isout = true;\n\t\t\t\t\tparentInstance._out.call(parentInstance, event);\n\t\t\t\t}\n\n\t\t\t\tthis[c] = true;\n\t\t\t\tthis[c === \"isout\" ? \"isover\" : \"isout\"] = false;\n\t\t\t\tthis[c === \"isover\" ? \"_over\" : \"_out\"].call(this, event);\n\n\t\t\t\t// we just moved out of a greedy child\n\t\t\t\tif (parentInstance && c === \"isout\") {\n\t\t\t\t\tparentInstance.isout = false;\n\t\t\t\t\tparentInstance.isover = true;\n\t\t\t\t\tparentInstance._over.call(parentInstance, event);\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\tdragStop: function dragStop(draggable, event) {\n\t\t\tdraggable.element.parentsUntil(\"body\").unbind(\"scroll.droppable\");\n\t\t\t// Call prepareOffsets one final time since IE does not fire return scroll events when overflow was caused by drag (see #5003)\n\t\t\tif (!draggable.options.refreshPositions) {\n\t\t\t\t$.ui.ddmanager.prepareOffsets(draggable, event);\n\t\t\t}\n\t\t}\n\t};\n\n\tvar droppable = $.ui.droppable;\n\n\t/*!\n  * jQuery UI Effects 1.11.4\n  * http://jqueryui.com\n  *\n  * Copyright jQuery Foundation and other contributors\n  * Released under the MIT license.\n  * http://jquery.org/license\n  *\n  * http://api.jqueryui.com/category/effects-core/\n  */\n\n\tvar dataSpace = \"ui-effects-\",\n\n\n\t// Create a local jQuery because jQuery Color relies on it and the\n\t// global may not exist with AMD and a custom build (#10199)\n\tjQuery = $;\n\n\t$.effects = {\n\t\teffect: {}\n\t};\n\n\t/*!\n  * jQuery Color Animations v2.1.2\n  * https://github.com/jquery/jquery-color\n  *\n  * Copyright 2014 jQuery Foundation and other contributors\n  * Released under the MIT license.\n  * http://jquery.org/license\n  *\n  * Date: Wed Jan 16 08:47:09 2013 -0600\n  */\n\t(function (jQuery, undefined) {\n\n\t\tvar stepHooks = \"backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor\",\n\n\n\t\t// plusequals test for += 100 -= 100\n\t\trplusequals = /^([\\-+])=\\s*(\\d+\\.?\\d*)/,\n\n\t\t// a set of RE's that can match strings and generate color tuples.\n\t\tstringParsers = [{\n\t\t\tre: /rgba?\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*(?:,\\s*(\\d?(?:\\.\\d+)?)\\s*)?\\)/,\n\t\t\tparse: function parse(execResult) {\n\t\t\t\treturn [execResult[1], execResult[2], execResult[3], execResult[4]];\n\t\t\t}\n\t\t}, {\n\t\t\tre: /rgba?\\(\\s*(\\d+(?:\\.\\d+)?)\\%\\s*,\\s*(\\d+(?:\\.\\d+)?)\\%\\s*,\\s*(\\d+(?:\\.\\d+)?)\\%\\s*(?:,\\s*(\\d?(?:\\.\\d+)?)\\s*)?\\)/,\n\t\t\tparse: function parse(execResult) {\n\t\t\t\treturn [execResult[1] * 2.55, execResult[2] * 2.55, execResult[3] * 2.55, execResult[4]];\n\t\t\t}\n\t\t}, {\n\t\t\t// this regex ignores A-F because it's compared against an already lowercased string\n\t\t\tre: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,\n\t\t\tparse: function parse(execResult) {\n\t\t\t\treturn [parseInt(execResult[1], 16), parseInt(execResult[2], 16), parseInt(execResult[3], 16)];\n\t\t\t}\n\t\t}, {\n\t\t\t// this regex ignores A-F because it's compared against an already lowercased string\n\t\t\tre: /#([a-f0-9])([a-f0-9])([a-f0-9])/,\n\t\t\tparse: function parse(execResult) {\n\t\t\t\treturn [parseInt(execResult[1] + execResult[1], 16), parseInt(execResult[2] + execResult[2], 16), parseInt(execResult[3] + execResult[3], 16)];\n\t\t\t}\n\t\t}, {\n\t\t\tre: /hsla?\\(\\s*(\\d+(?:\\.\\d+)?)\\s*,\\s*(\\d+(?:\\.\\d+)?)\\%\\s*,\\s*(\\d+(?:\\.\\d+)?)\\%\\s*(?:,\\s*(\\d?(?:\\.\\d+)?)\\s*)?\\)/,\n\t\t\tspace: \"hsla\",\n\t\t\tparse: function parse(execResult) {\n\t\t\t\treturn [execResult[1], execResult[2] / 100, execResult[3] / 100, execResult[4]];\n\t\t\t}\n\t\t}],\n\n\n\t\t// jQuery.Color( )\n\t\tcolor = jQuery.Color = function (color, green, blue, alpha) {\n\t\t\treturn new jQuery.Color.fn.parse(color, green, blue, alpha);\n\t\t},\n\t\t    spaces = {\n\t\t\trgba: {\n\t\t\t\tprops: {\n\t\t\t\t\tred: {\n\t\t\t\t\t\tidx: 0,\n\t\t\t\t\t\ttype: \"byte\"\n\t\t\t\t\t},\n\t\t\t\t\tgreen: {\n\t\t\t\t\t\tidx: 1,\n\t\t\t\t\t\ttype: \"byte\"\n\t\t\t\t\t},\n\t\t\t\t\tblue: {\n\t\t\t\t\t\tidx: 2,\n\t\t\t\t\t\ttype: \"byte\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\thsla: {\n\t\t\t\tprops: {\n\t\t\t\t\thue: {\n\t\t\t\t\t\tidx: 0,\n\t\t\t\t\t\ttype: \"degrees\"\n\t\t\t\t\t},\n\t\t\t\t\tsaturation: {\n\t\t\t\t\t\tidx: 1,\n\t\t\t\t\t\ttype: \"percent\"\n\t\t\t\t\t},\n\t\t\t\t\tlightness: {\n\t\t\t\t\t\tidx: 2,\n\t\t\t\t\t\ttype: \"percent\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t    propTypes = {\n\t\t\t\"byte\": {\n\t\t\t\tfloor: true,\n\t\t\t\tmax: 255\n\t\t\t},\n\t\t\t\"percent\": {\n\t\t\t\tmax: 1\n\t\t\t},\n\t\t\t\"degrees\": {\n\t\t\t\tmod: 360,\n\t\t\t\tfloor: true\n\t\t\t}\n\t\t},\n\t\t    support = color.support = {},\n\n\n\t\t// element for support tests\n\t\tsupportElem = jQuery(\"<p>\")[0],\n\n\n\t\t// colors = jQuery.Color.names\n\t\tcolors,\n\n\n\t\t// local aliases of functions called often\n\t\teach = jQuery.each;\n\n\t\t// determine rgba support immediately\n\t\tsupportElem.style.cssText = \"background-color:rgba(1,1,1,.5)\";\n\t\tsupport.rgba = supportElem.style.backgroundColor.indexOf(\"rgba\") > -1;\n\n\t\t// define cache name and alpha properties\n\t\t// for rgba and hsla spaces\n\t\teach(spaces, function (spaceName, space) {\n\t\t\tspace.cache = \"_\" + spaceName;\n\t\t\tspace.props.alpha = {\n\t\t\t\tidx: 3,\n\t\t\t\ttype: \"percent\",\n\t\t\t\tdef: 1\n\t\t\t};\n\t\t});\n\n\t\tfunction clamp(value, prop, allowEmpty) {\n\t\t\tvar type = propTypes[prop.type] || {};\n\n\t\t\tif (value == null) {\n\t\t\t\treturn allowEmpty || !prop.def ? null : prop.def;\n\t\t\t}\n\n\t\t\t// ~~ is an short way of doing floor for positive numbers\n\t\t\tvalue = type.floor ? ~~value : parseFloat(value);\n\n\t\t\t// IE will pass in empty strings as value for alpha,\n\t\t\t// which will hit this case\n\t\t\tif (isNaN(value)) {\n\t\t\t\treturn prop.def;\n\t\t\t}\n\n\t\t\tif (type.mod) {\n\t\t\t\t// we add mod before modding to make sure that negatives values\n\t\t\t\t// get converted properly: -10 -> 350\n\t\t\t\treturn (value + type.mod) % type.mod;\n\t\t\t}\n\n\t\t\t// for now all property types without mod have min and max\n\t\t\treturn 0 > value ? 0 : type.max < value ? type.max : value;\n\t\t}\n\n\t\tfunction stringParse(string) {\n\t\t\tvar inst = color(),\n\t\t\t    rgba = inst._rgba = [];\n\n\t\t\tstring = string.toLowerCase();\n\n\t\t\teach(stringParsers, function (i, parser) {\n\t\t\t\tvar parsed,\n\t\t\t\t    match = parser.re.exec(string),\n\t\t\t\t    values = match && parser.parse(match),\n\t\t\t\t    spaceName = parser.space || \"rgba\";\n\n\t\t\t\tif (values) {\n\t\t\t\t\tparsed = inst[spaceName](values);\n\n\t\t\t\t\t// if this was an rgba parse the assignment might happen twice\n\t\t\t\t\t// oh well....\n\t\t\t\t\tinst[spaces[spaceName].cache] = parsed[spaces[spaceName].cache];\n\t\t\t\t\trgba = inst._rgba = parsed._rgba;\n\n\t\t\t\t\t// exit each( stringParsers ) here because we matched\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Found a stringParser that handled it\n\t\t\tif (rgba.length) {\n\n\t\t\t\t// if this came from a parsed string, force \"transparent\" when alpha is 0\n\t\t\t\t// chrome, (and maybe others) return \"transparent\" as rgba(0,0,0,0)\n\t\t\t\tif (rgba.join() === \"0,0,0,0\") {\n\t\t\t\t\tjQuery.extend(rgba, colors.transparent);\n\t\t\t\t}\n\t\t\t\treturn inst;\n\t\t\t}\n\n\t\t\t// named colors\n\t\t\treturn colors[string];\n\t\t}\n\n\t\tcolor.fn = jQuery.extend(color.prototype, {\n\t\t\tparse: function parse(red, green, blue, alpha) {\n\t\t\t\tif (red === undefined) {\n\t\t\t\t\tthis._rgba = [null, null, null, null];\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\tif (red.jquery || red.nodeType) {\n\t\t\t\t\tred = jQuery(red).css(green);\n\t\t\t\t\tgreen = undefined;\n\t\t\t\t}\n\n\t\t\t\tvar inst = this,\n\t\t\t\t    type = jQuery.type(red),\n\t\t\t\t    rgba = this._rgba = [];\n\n\t\t\t\t// more than 1 argument specified - assume ( red, green, blue, alpha )\n\t\t\t\tif (green !== undefined) {\n\t\t\t\t\tred = [red, green, blue, alpha];\n\t\t\t\t\ttype = \"array\";\n\t\t\t\t}\n\n\t\t\t\tif (type === \"string\") {\n\t\t\t\t\treturn this.parse(stringParse(red) || colors._default);\n\t\t\t\t}\n\n\t\t\t\tif (type === \"array\") {\n\t\t\t\t\teach(spaces.rgba.props, function (key, prop) {\n\t\t\t\t\t\trgba[prop.idx] = clamp(red[prop.idx], prop);\n\t\t\t\t\t});\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t\tif (type === \"object\") {\n\t\t\t\t\tif (red instanceof color) {\n\t\t\t\t\t\teach(spaces, function (spaceName, space) {\n\t\t\t\t\t\t\tif (red[space.cache]) {\n\t\t\t\t\t\t\t\tinst[space.cache] = red[space.cache].slice();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\teach(spaces, function (spaceName, space) {\n\t\t\t\t\t\t\tvar cache = space.cache;\n\t\t\t\t\t\t\teach(space.props, function (key, prop) {\n\n\t\t\t\t\t\t\t\t// if the cache doesn't exist, and we know how to convert\n\t\t\t\t\t\t\t\tif (!inst[cache] && space.to) {\n\n\t\t\t\t\t\t\t\t\t// if the value was null, we don't need to copy it\n\t\t\t\t\t\t\t\t\t// if the key was alpha, we don't need to copy it either\n\t\t\t\t\t\t\t\t\tif (key === \"alpha\" || red[key] == null) {\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tinst[cache] = space.to(inst._rgba);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// this is the only case where we allow nulls for ALL properties.\n\t\t\t\t\t\t\t\t// call clamp with alwaysAllowEmpty\n\t\t\t\t\t\t\t\tinst[cache][prop.idx] = clamp(red[key], prop, true);\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t// everything defined but alpha?\n\t\t\t\t\t\t\tif (inst[cache] && jQuery.inArray(null, inst[cache].slice(0, 3)) < 0) {\n\t\t\t\t\t\t\t\t// use the default of 1\n\t\t\t\t\t\t\t\tinst[cache][3] = 1;\n\t\t\t\t\t\t\t\tif (space.from) {\n\t\t\t\t\t\t\t\t\tinst._rgba = space.from(inst[cache]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t},\n\t\t\tis: function is(compare) {\n\t\t\t\tvar is = color(compare),\n\t\t\t\t    same = true,\n\t\t\t\t    inst = this;\n\n\t\t\t\teach(spaces, function (_, space) {\n\t\t\t\t\tvar localCache,\n\t\t\t\t\t    isCache = is[space.cache];\n\t\t\t\t\tif (isCache) {\n\t\t\t\t\t\tlocalCache = inst[space.cache] || space.to && space.to(inst._rgba) || [];\n\t\t\t\t\t\teach(space.props, function (_, prop) {\n\t\t\t\t\t\t\tif (isCache[prop.idx] != null) {\n\t\t\t\t\t\t\t\tsame = isCache[prop.idx] === localCache[prop.idx];\n\t\t\t\t\t\t\t\treturn same;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\treturn same;\n\t\t\t\t});\n\t\t\t\treturn same;\n\t\t\t},\n\t\t\t_space: function _space() {\n\t\t\t\tvar used = [],\n\t\t\t\t    inst = this;\n\t\t\t\teach(spaces, function (spaceName, space) {\n\t\t\t\t\tif (inst[space.cache]) {\n\t\t\t\t\t\tused.push(spaceName);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn used.pop();\n\t\t\t},\n\t\t\ttransition: function transition(other, distance) {\n\t\t\t\tvar end = color(other),\n\t\t\t\t    spaceName = end._space(),\n\t\t\t\t    space = spaces[spaceName],\n\t\t\t\t    startColor = this.alpha() === 0 ? color(\"transparent\") : this,\n\t\t\t\t    start = startColor[space.cache] || space.to(startColor._rgba),\n\t\t\t\t    result = start.slice();\n\n\t\t\t\tend = end[space.cache];\n\t\t\t\teach(space.props, function (key, prop) {\n\t\t\t\t\tvar index = prop.idx,\n\t\t\t\t\t    startValue = start[index],\n\t\t\t\t\t    endValue = end[index],\n\t\t\t\t\t    type = propTypes[prop.type] || {};\n\n\t\t\t\t\t// if null, don't override start value\n\t\t\t\t\tif (endValue === null) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t// if null - use end\n\t\t\t\t\tif (startValue === null) {\n\t\t\t\t\t\tresult[index] = endValue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (type.mod) {\n\t\t\t\t\t\t\tif (endValue - startValue > type.mod / 2) {\n\t\t\t\t\t\t\t\tstartValue += type.mod;\n\t\t\t\t\t\t\t} else if (startValue - endValue > type.mod / 2) {\n\t\t\t\t\t\t\t\tstartValue -= type.mod;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresult[index] = clamp((endValue - startValue) * distance + startValue, prop);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn this[spaceName](result);\n\t\t\t},\n\t\t\tblend: function blend(opaque) {\n\t\t\t\t// if we are already opaque - return ourself\n\t\t\t\tif (this._rgba[3] === 1) {\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t\tvar rgb = this._rgba.slice(),\n\t\t\t\t    a = rgb.pop(),\n\t\t\t\t    blend = color(opaque)._rgba;\n\n\t\t\t\treturn color(jQuery.map(rgb, function (v, i) {\n\t\t\t\t\treturn (1 - a) * blend[i] + a * v;\n\t\t\t\t}));\n\t\t\t},\n\t\t\ttoRgbaString: function toRgbaString() {\n\t\t\t\tvar prefix = \"rgba(\",\n\t\t\t\t    rgba = jQuery.map(this._rgba, function (v, i) {\n\t\t\t\t\treturn v == null ? i > 2 ? 1 : 0 : v;\n\t\t\t\t});\n\n\t\t\t\tif (rgba[3] === 1) {\n\t\t\t\t\trgba.pop();\n\t\t\t\t\tprefix = \"rgb(\";\n\t\t\t\t}\n\n\t\t\t\treturn prefix + rgba.join() + \")\";\n\t\t\t},\n\t\t\ttoHslaString: function toHslaString() {\n\t\t\t\tvar prefix = \"hsla(\",\n\t\t\t\t    hsla = jQuery.map(this.hsla(), function (v, i) {\n\t\t\t\t\tif (v == null) {\n\t\t\t\t\t\tv = i > 2 ? 1 : 0;\n\t\t\t\t\t}\n\n\t\t\t\t\t// catch 1 and 2\n\t\t\t\t\tif (i && i < 3) {\n\t\t\t\t\t\tv = Math.round(v * 100) + \"%\";\n\t\t\t\t\t}\n\t\t\t\t\treturn v;\n\t\t\t\t});\n\n\t\t\t\tif (hsla[3] === 1) {\n\t\t\t\t\thsla.pop();\n\t\t\t\t\tprefix = \"hsl(\";\n\t\t\t\t}\n\t\t\t\treturn prefix + hsla.join() + \")\";\n\t\t\t},\n\t\t\ttoHexString: function toHexString(includeAlpha) {\n\t\t\t\tvar rgba = this._rgba.slice(),\n\t\t\t\t    alpha = rgba.pop();\n\n\t\t\t\tif (includeAlpha) {\n\t\t\t\t\trgba.push(~~(alpha * 255));\n\t\t\t\t}\n\n\t\t\t\treturn \"#\" + jQuery.map(rgba, function (v) {\n\n\t\t\t\t\t// default to 0 when nulls exist\n\t\t\t\t\tv = (v || 0).toString(16);\n\t\t\t\t\treturn v.length === 1 ? \"0\" + v : v;\n\t\t\t\t}).join(\"\");\n\t\t\t},\n\t\t\ttoString: function toString() {\n\t\t\t\treturn this._rgba[3] === 0 ? \"transparent\" : this.toRgbaString();\n\t\t\t}\n\t\t});\n\t\tcolor.fn.parse.prototype = color.fn;\n\n\t\t// hsla conversions adapted from:\n\t\t// https://code.google.com/p/maashaack/source/browse/packages/graphics/trunk/src/graphics/colors/HUE2RGB.as?r=5021\n\n\t\tfunction hue2rgb(p, q, h) {\n\t\t\th = (h + 1) % 1;\n\t\t\tif (h * 6 < 1) {\n\t\t\t\treturn p + (q - p) * h * 6;\n\t\t\t}\n\t\t\tif (h * 2 < 1) {\n\t\t\t\treturn q;\n\t\t\t}\n\t\t\tif (h * 3 < 2) {\n\t\t\t\treturn p + (q - p) * (2 / 3 - h) * 6;\n\t\t\t}\n\t\t\treturn p;\n\t\t}\n\n\t\tspaces.hsla.to = function (rgba) {\n\t\t\tif (rgba[0] == null || rgba[1] == null || rgba[2] == null) {\n\t\t\t\treturn [null, null, null, rgba[3]];\n\t\t\t}\n\t\t\tvar r = rgba[0] / 255,\n\t\t\t    g = rgba[1] / 255,\n\t\t\t    b = rgba[2] / 255,\n\t\t\t    a = rgba[3],\n\t\t\t    max = Math.max(r, g, b),\n\t\t\t    min = Math.min(r, g, b),\n\t\t\t    diff = max - min,\n\t\t\t    add = max + min,\n\t\t\t    l = add * 0.5,\n\t\t\t    h,\n\t\t\t    s;\n\n\t\t\tif (min === max) {\n\t\t\t\th = 0;\n\t\t\t} else if (r === max) {\n\t\t\t\th = 60 * (g - b) / diff + 360;\n\t\t\t} else if (g === max) {\n\t\t\t\th = 60 * (b - r) / diff + 120;\n\t\t\t} else {\n\t\t\t\th = 60 * (r - g) / diff + 240;\n\t\t\t}\n\n\t\t\t// chroma (diff) == 0 means greyscale which, by definition, saturation = 0%\n\t\t\t// otherwise, saturation is based on the ratio of chroma (diff) to lightness (add)\n\t\t\tif (diff === 0) {\n\t\t\t\ts = 0;\n\t\t\t} else if (l <= 0.5) {\n\t\t\t\ts = diff / add;\n\t\t\t} else {\n\t\t\t\ts = diff / (2 - add);\n\t\t\t}\n\t\t\treturn [Math.round(h) % 360, s, l, a == null ? 1 : a];\n\t\t};\n\n\t\tspaces.hsla.from = function (hsla) {\n\t\t\tif (hsla[0] == null || hsla[1] == null || hsla[2] == null) {\n\t\t\t\treturn [null, null, null, hsla[3]];\n\t\t\t}\n\t\t\tvar h = hsla[0] / 360,\n\t\t\t    s = hsla[1],\n\t\t\t    l = hsla[2],\n\t\t\t    a = hsla[3],\n\t\t\t    q = l <= 0.5 ? l * (1 + s) : l + s - l * s,\n\t\t\t    p = 2 * l - q;\n\n\t\t\treturn [Math.round(hue2rgb(p, q, h + 1 / 3) * 255), Math.round(hue2rgb(p, q, h) * 255), Math.round(hue2rgb(p, q, h - 1 / 3) * 255), a];\n\t\t};\n\n\t\teach(spaces, function (spaceName, space) {\n\t\t\tvar props = space.props,\n\t\t\t    cache = space.cache,\n\t\t\t    to = space.to,\n\t\t\t    from = space.from;\n\n\t\t\t// makes rgba() and hsla()\n\t\t\tcolor.fn[spaceName] = function (value) {\n\n\t\t\t\t// generate a cache for this space if it doesn't exist\n\t\t\t\tif (to && !this[cache]) {\n\t\t\t\t\tthis[cache] = to(this._rgba);\n\t\t\t\t}\n\t\t\t\tif (value === undefined) {\n\t\t\t\t\treturn this[cache].slice();\n\t\t\t\t}\n\n\t\t\t\tvar ret,\n\t\t\t\t    type = jQuery.type(value),\n\t\t\t\t    arr = type === \"array\" || type === \"object\" ? value : arguments,\n\t\t\t\t    local = this[cache].slice();\n\n\t\t\t\teach(props, function (key, prop) {\n\t\t\t\t\tvar val = arr[type === \"object\" ? key : prop.idx];\n\t\t\t\t\tif (val == null) {\n\t\t\t\t\t\tval = local[prop.idx];\n\t\t\t\t\t}\n\t\t\t\t\tlocal[prop.idx] = clamp(val, prop);\n\t\t\t\t});\n\n\t\t\t\tif (from) {\n\t\t\t\t\tret = color(from(local));\n\t\t\t\t\tret[cache] = local;\n\t\t\t\t\treturn ret;\n\t\t\t\t} else {\n\t\t\t\t\treturn color(local);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// makes red() green() blue() alpha() hue() saturation() lightness()\n\t\t\teach(props, function (key, prop) {\n\t\t\t\t// alpha is included in more than one space\n\t\t\t\tif (color.fn[key]) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcolor.fn[key] = function (value) {\n\t\t\t\t\tvar vtype = jQuery.type(value),\n\t\t\t\t\t    fn = key === \"alpha\" ? this._hsla ? \"hsla\" : \"rgba\" : spaceName,\n\t\t\t\t\t    local = this[fn](),\n\t\t\t\t\t    cur = local[prop.idx],\n\t\t\t\t\t    match;\n\n\t\t\t\t\tif (vtype === \"undefined\") {\n\t\t\t\t\t\treturn cur;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (vtype === \"function\") {\n\t\t\t\t\t\tvalue = value.call(this, cur);\n\t\t\t\t\t\tvtype = jQuery.type(value);\n\t\t\t\t\t}\n\t\t\t\t\tif (value == null && prop.empty) {\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t}\n\t\t\t\t\tif (vtype === \"string\") {\n\t\t\t\t\t\tmatch = rplusequals.exec(value);\n\t\t\t\t\t\tif (match) {\n\t\t\t\t\t\t\tvalue = cur + parseFloat(match[2]) * (match[1] === \"+\" ? 1 : -1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlocal[prop.idx] = value;\n\t\t\t\t\treturn this[fn](local);\n\t\t\t\t};\n\t\t\t});\n\t\t});\n\n\t\t// add cssHook and .fx.step function for each named hook.\n\t\t// accept a space separated string of properties\n\t\tcolor.hook = function (hook) {\n\t\t\tvar hooks = hook.split(\" \");\n\t\t\teach(hooks, function (i, hook) {\n\t\t\t\tjQuery.cssHooks[hook] = {\n\t\t\t\t\tset: function set(elem, value) {\n\t\t\t\t\t\tvar parsed,\n\t\t\t\t\t\t    curElem,\n\t\t\t\t\t\t    backgroundColor = \"\";\n\n\t\t\t\t\t\tif (value !== \"transparent\" && (jQuery.type(value) !== \"string\" || (parsed = stringParse(value)))) {\n\t\t\t\t\t\t\tvalue = color(parsed || value);\n\t\t\t\t\t\t\tif (!support.rgba && value._rgba[3] !== 1) {\n\t\t\t\t\t\t\t\tcurElem = hook === \"backgroundColor\" ? elem.parentNode : elem;\n\t\t\t\t\t\t\t\twhile ((backgroundColor === \"\" || backgroundColor === \"transparent\") && curElem && curElem.style) {\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tbackgroundColor = jQuery.css(curElem, \"backgroundColor\");\n\t\t\t\t\t\t\t\t\t\tcurElem = curElem.parentNode;\n\t\t\t\t\t\t\t\t\t} catch (e) {}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tvalue = value.blend(backgroundColor && backgroundColor !== \"transparent\" ? backgroundColor : \"_default\");\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvalue = value.toRgbaString();\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\telem.style[hook] = value;\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t// wrapped to prevent IE from throwing errors on \"invalid\" values like 'auto' or 'inherit'\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tjQuery.fx.step[hook] = function (fx) {\n\t\t\t\t\tif (!fx.colorInit) {\n\t\t\t\t\t\tfx.start = color(fx.elem, hook);\n\t\t\t\t\t\tfx.end = color(fx.end);\n\t\t\t\t\t\tfx.colorInit = true;\n\t\t\t\t\t}\n\t\t\t\t\tjQuery.cssHooks[hook].set(fx.elem, fx.start.transition(fx.end, fx.pos));\n\t\t\t\t};\n\t\t\t});\n\t\t};\n\n\t\tcolor.hook(stepHooks);\n\n\t\tjQuery.cssHooks.borderColor = {\n\t\t\texpand: function expand(value) {\n\t\t\t\tvar expanded = {};\n\n\t\t\t\teach([\"Top\", \"Right\", \"Bottom\", \"Left\"], function (i, part) {\n\t\t\t\t\texpanded[\"border\" + part + \"Color\"] = value;\n\t\t\t\t});\n\t\t\t\treturn expanded;\n\t\t\t}\n\t\t};\n\n\t\t// Basic color names only.\n\t\t// Usage of any of the other color names requires adding yourself or including\n\t\t// jquery.color.svg-names.js.\n\t\tcolors = jQuery.Color.names = {\n\t\t\t// 4.1. Basic color keywords\n\t\t\taqua: \"#00ffff\",\n\t\t\tblack: \"#000000\",\n\t\t\tblue: \"#0000ff\",\n\t\t\tfuchsia: \"#ff00ff\",\n\t\t\tgray: \"#808080\",\n\t\t\tgreen: \"#008000\",\n\t\t\tlime: \"#00ff00\",\n\t\t\tmaroon: \"#800000\",\n\t\t\tnavy: \"#000080\",\n\t\t\tolive: \"#808000\",\n\t\t\tpurple: \"#800080\",\n\t\t\tred: \"#ff0000\",\n\t\t\tsilver: \"#c0c0c0\",\n\t\t\tteal: \"#008080\",\n\t\t\twhite: \"#ffffff\",\n\t\t\tyellow: \"#ffff00\",\n\n\t\t\t// 4.2.3. \"transparent\" color keyword\n\t\t\ttransparent: [null, null, null, 0],\n\n\t\t\t_default: \"#ffffff\"\n\t\t};\n\t})(jQuery);\n\n\t/******************************************************************************/\n\t/****************************** CLASS ANIMATIONS ******************************/\n\t/******************************************************************************/\n\t(function () {\n\n\t\tvar classAnimationActions = [\"add\", \"remove\", \"toggle\"],\n\t\t    shorthandStyles = {\n\t\t\tborder: 1,\n\t\t\tborderBottom: 1,\n\t\t\tborderColor: 1,\n\t\t\tborderLeft: 1,\n\t\t\tborderRight: 1,\n\t\t\tborderTop: 1,\n\t\t\tborderWidth: 1,\n\t\t\tmargin: 1,\n\t\t\tpadding: 1\n\t\t};\n\n\t\t$.each([\"borderLeftStyle\", \"borderRightStyle\", \"borderBottomStyle\", \"borderTopStyle\"], function (_, prop) {\n\t\t\t$.fx.step[prop] = function (fx) {\n\t\t\t\tif (fx.end !== \"none\" && !fx.setAttr || fx.pos === 1 && !fx.setAttr) {\n\t\t\t\t\tjQuery.style(fx.elem, prop, fx.end);\n\t\t\t\t\tfx.setAttr = true;\n\t\t\t\t}\n\t\t\t};\n\t\t});\n\n\t\tfunction getElementStyles(elem) {\n\t\t\tvar key,\n\t\t\t    len,\n\t\t\t    style = elem.ownerDocument.defaultView ? elem.ownerDocument.defaultView.getComputedStyle(elem, null) : elem.currentStyle,\n\t\t\t    styles = {};\n\n\t\t\tif (style && style.length && style[0] && style[style[0]]) {\n\t\t\t\tlen = style.length;\n\t\t\t\twhile (len--) {\n\t\t\t\t\tkey = style[len];\n\t\t\t\t\tif (typeof style[key] === \"string\") {\n\t\t\t\t\t\tstyles[$.camelCase(key)] = style[key];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// support: Opera, IE <9\n\t\t\t} else {\n\t\t\t\tfor (key in style) {\n\t\t\t\t\tif (typeof style[key] === \"string\") {\n\t\t\t\t\t\tstyles[key] = style[key];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn styles;\n\t\t}\n\n\t\tfunction styleDifference(oldStyle, newStyle) {\n\t\t\tvar diff = {},\n\t\t\t    name,\n\t\t\t    value;\n\n\t\t\tfor (name in newStyle) {\n\t\t\t\tvalue = newStyle[name];\n\t\t\t\tif (oldStyle[name] !== value) {\n\t\t\t\t\tif (!shorthandStyles[name]) {\n\t\t\t\t\t\tif ($.fx.step[name] || !isNaN(parseFloat(value))) {\n\t\t\t\t\t\t\tdiff[name] = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn diff;\n\t\t}\n\n\t\t// support: jQuery <1.8\n\t\tif (!$.fn.addBack) {\n\t\t\t$.fn.addBack = function (selector) {\n\t\t\t\treturn this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));\n\t\t\t};\n\t\t}\n\n\t\t$.effects.animateClass = function (value, duration, easing, callback) {\n\t\t\tvar o = $.speed(duration, easing, callback);\n\n\t\t\treturn this.queue(function () {\n\t\t\t\tvar animated = $(this),\n\t\t\t\t    baseClass = animated.attr(\"class\") || \"\",\n\t\t\t\t    applyClassChange,\n\t\t\t\t    allAnimations = o.children ? animated.find(\"*\").addBack() : animated;\n\n\t\t\t\t// map the animated objects to store the original styles.\n\t\t\t\tallAnimations = allAnimations.map(function () {\n\t\t\t\t\tvar el = $(this);\n\t\t\t\t\treturn {\n\t\t\t\t\t\tel: el,\n\t\t\t\t\t\tstart: getElementStyles(this)\n\t\t\t\t\t};\n\t\t\t\t});\n\n\t\t\t\t// apply class change\n\t\t\t\tapplyClassChange = function applyClassChange() {\n\t\t\t\t\t$.each(classAnimationActions, function (i, action) {\n\t\t\t\t\t\tif (value[action]) {\n\t\t\t\t\t\t\tanimated[action + \"Class\"](value[action]);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t};\n\t\t\t\tapplyClassChange();\n\n\t\t\t\t// map all animated objects again - calculate new styles and diff\n\t\t\t\tallAnimations = allAnimations.map(function () {\n\t\t\t\t\tthis.end = getElementStyles(this.el[0]);\n\t\t\t\t\tthis.diff = styleDifference(this.start, this.end);\n\t\t\t\t\treturn this;\n\t\t\t\t});\n\n\t\t\t\t// apply original class\n\t\t\t\tanimated.attr(\"class\", baseClass);\n\n\t\t\t\t// map all animated objects again - this time collecting a promise\n\t\t\t\tallAnimations = allAnimations.map(function () {\n\t\t\t\t\tvar styleInfo = this,\n\t\t\t\t\t    dfd = $.Deferred(),\n\t\t\t\t\t    opts = $.extend({}, o, {\n\t\t\t\t\t\tqueue: false,\n\t\t\t\t\t\tcomplete: function complete() {\n\t\t\t\t\t\t\tdfd.resolve(styleInfo);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tthis.el.animate(this.diff, opts);\n\t\t\t\t\treturn dfd.promise();\n\t\t\t\t});\n\n\t\t\t\t// once all animations have completed:\n\t\t\t\t$.when.apply($, allAnimations.get()).done(function () {\n\n\t\t\t\t\t// set the final class\n\t\t\t\t\tapplyClassChange();\n\n\t\t\t\t\t// for each animated element,\n\t\t\t\t\t// clear all css properties that were animated\n\t\t\t\t\t$.each(arguments, function () {\n\t\t\t\t\t\tvar el = this.el;\n\t\t\t\t\t\t$.each(this.diff, function (key) {\n\t\t\t\t\t\t\tel.css(key, \"\");\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\n\t\t\t\t\t// this is guarnteed to be there if you use jQuery.speed()\n\t\t\t\t\t// it also handles dequeuing the next anim...\n\t\t\t\t\to.complete.call(animated[0]);\n\t\t\t\t});\n\t\t\t});\n\t\t};\n\n\t\t$.fn.extend({\n\t\t\taddClass: function (orig) {\n\t\t\t\treturn function (classNames, speed, easing, callback) {\n\t\t\t\t\treturn speed ? $.effects.animateClass.call(this, { add: classNames }, speed, easing, callback) : orig.apply(this, arguments);\n\t\t\t\t};\n\t\t\t}($.fn.addClass),\n\n\t\t\tremoveClass: function (orig) {\n\t\t\t\treturn function (classNames, speed, easing, callback) {\n\t\t\t\t\treturn arguments.length > 1 ? $.effects.animateClass.call(this, { remove: classNames }, speed, easing, callback) : orig.apply(this, arguments);\n\t\t\t\t};\n\t\t\t}($.fn.removeClass),\n\n\t\t\ttoggleClass: function (orig) {\n\t\t\t\treturn function (classNames, force, speed, easing, callback) {\n\t\t\t\t\tif (typeof force === \"boolean\" || force === undefined) {\n\t\t\t\t\t\tif (!speed) {\n\t\t\t\t\t\t\t// without speed parameter\n\t\t\t\t\t\t\treturn orig.apply(this, arguments);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn $.effects.animateClass.call(this, force ? { add: classNames } : { remove: classNames }, speed, easing, callback);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// without force parameter\n\t\t\t\t\t\treturn $.effects.animateClass.call(this, { toggle: classNames }, force, speed, easing);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}($.fn.toggleClass),\n\n\t\t\tswitchClass: function switchClass(remove, add, speed, easing, callback) {\n\t\t\t\treturn $.effects.animateClass.call(this, {\n\t\t\t\t\tadd: add,\n\t\t\t\t\tremove: remove\n\t\t\t\t}, speed, easing, callback);\n\t\t\t}\n\t\t});\n\t})();\n\n\t/******************************************************************************/\n\t/*********************************** EFFECTS **********************************/\n\t/******************************************************************************/\n\n\t(function () {\n\n\t\t$.extend($.effects, {\n\t\t\tversion: \"1.11.4\",\n\n\t\t\t// Saves a set of properties in a data storage\n\t\t\tsave: function save(element, set) {\n\t\t\t\tfor (var i = 0; i < set.length; i++) {\n\t\t\t\t\tif (set[i] !== null) {\n\t\t\t\t\t\telement.data(dataSpace + set[i], element[0].style[set[i]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// Restores a set of previously saved properties from a data storage\n\t\t\trestore: function restore(element, set) {\n\t\t\t\tvar val, i;\n\t\t\t\tfor (i = 0; i < set.length; i++) {\n\t\t\t\t\tif (set[i] !== null) {\n\t\t\t\t\t\tval = element.data(dataSpace + set[i]);\n\t\t\t\t\t\t// support: jQuery 1.6.2\n\t\t\t\t\t\t// http://bugs.jquery.com/ticket/9917\n\t\t\t\t\t\t// jQuery 1.6.2 incorrectly returns undefined for any falsy value.\n\t\t\t\t\t\t// We can't differentiate between \"\" and 0 here, so we just assume\n\t\t\t\t\t\t// empty string since it's likely to be a more common value...\n\t\t\t\t\t\tif (val === undefined) {\n\t\t\t\t\t\t\tval = \"\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\telement.css(set[i], val);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tsetMode: function setMode(el, mode) {\n\t\t\t\tif (mode === \"toggle\") {\n\t\t\t\t\tmode = el.is(\":hidden\") ? \"show\" : \"hide\";\n\t\t\t\t}\n\t\t\t\treturn mode;\n\t\t\t},\n\n\t\t\t// Translates a [top,left] array into a baseline value\n\t\t\t// this should be a little more flexible in the future to handle a string & hash\n\t\t\tgetBaseline: function getBaseline(origin, original) {\n\t\t\t\tvar y, x;\n\t\t\t\tswitch (origin[0]) {\n\t\t\t\t\tcase \"top\":\n\t\t\t\t\t\ty = 0;break;\n\t\t\t\t\tcase \"middle\":\n\t\t\t\t\t\ty = 0.5;break;\n\t\t\t\t\tcase \"bottom\":\n\t\t\t\t\t\ty = 1;break;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\ty = origin[0] / original.height;\n\t\t\t\t}\n\t\t\t\tswitch (origin[1]) {\n\t\t\t\t\tcase \"left\":\n\t\t\t\t\t\tx = 0;break;\n\t\t\t\t\tcase \"center\":\n\t\t\t\t\t\tx = 0.5;break;\n\t\t\t\t\tcase \"right\":\n\t\t\t\t\t\tx = 1;break;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tx = origin[1] / original.width;\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tx: x,\n\t\t\t\t\ty: y\n\t\t\t\t};\n\t\t\t},\n\n\t\t\t// Wraps the element around a wrapper that copies position properties\n\t\t\tcreateWrapper: function createWrapper(element) {\n\n\t\t\t\t// if the element is already wrapped, return it\n\t\t\t\tif (element.parent().is(\".ui-effects-wrapper\")) {\n\t\t\t\t\treturn element.parent();\n\t\t\t\t}\n\n\t\t\t\t// wrap the element\n\t\t\t\tvar props = {\n\t\t\t\t\twidth: element.outerWidth(true),\n\t\t\t\t\theight: element.outerHeight(true),\n\t\t\t\t\t\"float\": element.css(\"float\")\n\t\t\t\t},\n\t\t\t\t    wrapper = $(\"<div></div>\").addClass(\"ui-effects-wrapper\").css({\n\t\t\t\t\tfontSize: \"100%\",\n\t\t\t\t\tbackground: \"transparent\",\n\t\t\t\t\tborder: \"none\",\n\t\t\t\t\tmargin: 0,\n\t\t\t\t\tpadding: 0\n\t\t\t\t}),\n\n\t\t\t\t// Store the size in case width/height are defined in % - Fixes #5245\n\t\t\t\tsize = {\n\t\t\t\t\twidth: element.width(),\n\t\t\t\t\theight: element.height()\n\t\t\t\t},\n\t\t\t\t    active = document.activeElement;\n\n\t\t\t\t// support: Firefox\n\t\t\t\t// Firefox incorrectly exposes anonymous content\n\t\t\t\t// https://bugzilla.mozilla.org/show_bug.cgi?id=561664\n\t\t\t\ttry {\n\t\t\t\t\tactive.id;\n\t\t\t\t} catch (e) {\n\t\t\t\t\tactive = document.body;\n\t\t\t\t}\n\n\t\t\t\telement.wrap(wrapper);\n\n\t\t\t\t// Fixes #7595 - Elements lose focus when wrapped.\n\t\t\t\tif (element[0] === active || $.contains(element[0], active)) {\n\t\t\t\t\t$(active).focus();\n\t\t\t\t}\n\n\t\t\t\twrapper = element.parent(); //Hotfix for jQuery 1.4 since some change in wrap() seems to actually lose the reference to the wrapped element\n\n\t\t\t\t// transfer positioning properties to the wrapper\n\t\t\t\tif (element.css(\"position\") === \"static\") {\n\t\t\t\t\twrapper.css({ position: \"relative\" });\n\t\t\t\t\telement.css({ position: \"relative\" });\n\t\t\t\t} else {\n\t\t\t\t\t$.extend(props, {\n\t\t\t\t\t\tposition: element.css(\"position\"),\n\t\t\t\t\t\tzIndex: element.css(\"z-index\")\n\t\t\t\t\t});\n\t\t\t\t\t$.each([\"top\", \"left\", \"bottom\", \"right\"], function (i, pos) {\n\t\t\t\t\t\tprops[pos] = element.css(pos);\n\t\t\t\t\t\tif (isNaN(parseInt(props[pos], 10))) {\n\t\t\t\t\t\t\tprops[pos] = \"auto\";\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\telement.css({\n\t\t\t\t\t\tposition: \"relative\",\n\t\t\t\t\t\ttop: 0,\n\t\t\t\t\t\tleft: 0,\n\t\t\t\t\t\tright: \"auto\",\n\t\t\t\t\t\tbottom: \"auto\"\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\telement.css(size);\n\n\t\t\t\treturn wrapper.css(props).show();\n\t\t\t},\n\n\t\t\tremoveWrapper: function removeWrapper(element) {\n\t\t\t\tvar active = document.activeElement;\n\n\t\t\t\tif (element.parent().is(\".ui-effects-wrapper\")) {\n\t\t\t\t\telement.parent().replaceWith(element);\n\n\t\t\t\t\t// Fixes #7595 - Elements lose focus when wrapped.\n\t\t\t\t\tif (element[0] === active || $.contains(element[0], active)) {\n\t\t\t\t\t\t$(active).focus();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn element;\n\t\t\t},\n\n\t\t\tsetTransition: function setTransition(element, list, factor, value) {\n\t\t\t\tvalue = value || {};\n\t\t\t\t$.each(list, function (i, x) {\n\t\t\t\t\tvar unit = element.cssUnit(x);\n\t\t\t\t\tif (unit[0] > 0) {\n\t\t\t\t\t\tvalue[x] = unit[0] * factor + unit[1];\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn value;\n\t\t\t}\n\t\t});\n\n\t\t// return an effect options object for the given parameters:\n\t\tfunction _normalizeArguments(effect, options, speed, callback) {\n\n\t\t\t// allow passing all options as the first parameter\n\t\t\tif ($.isPlainObject(effect)) {\n\t\t\t\toptions = effect;\n\t\t\t\teffect = effect.effect;\n\t\t\t}\n\n\t\t\t// convert to an object\n\t\t\teffect = { effect: effect };\n\n\t\t\t// catch (effect, null, ...)\n\t\t\tif (options == null) {\n\t\t\t\toptions = {};\n\t\t\t}\n\n\t\t\t// catch (effect, callback)\n\t\t\tif ($.isFunction(options)) {\n\t\t\t\tcallback = options;\n\t\t\t\tspeed = null;\n\t\t\t\toptions = {};\n\t\t\t}\n\n\t\t\t// catch (effect, speed, ?)\n\t\t\tif (typeof options === \"number\" || $.fx.speeds[options]) {\n\t\t\t\tcallback = speed;\n\t\t\t\tspeed = options;\n\t\t\t\toptions = {};\n\t\t\t}\n\n\t\t\t// catch (effect, options, callback)\n\t\t\tif ($.isFunction(speed)) {\n\t\t\t\tcallback = speed;\n\t\t\t\tspeed = null;\n\t\t\t}\n\n\t\t\t// add options to effect\n\t\t\tif (options) {\n\t\t\t\t$.extend(effect, options);\n\t\t\t}\n\n\t\t\tspeed = speed || options.duration;\n\t\t\teffect.duration = $.fx.off ? 0 : typeof speed === \"number\" ? speed : speed in $.fx.speeds ? $.fx.speeds[speed] : $.fx.speeds._default;\n\n\t\t\teffect.complete = callback || options.complete;\n\n\t\t\treturn effect;\n\t\t}\n\n\t\tfunction standardAnimationOption(option) {\n\t\t\t// Valid standard speeds (nothing, number, named speed)\n\t\t\tif (!option || typeof option === \"number\" || $.fx.speeds[option]) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// Invalid strings - treat as \"normal\" speed\n\t\t\tif (typeof option === \"string\" && !$.effects.effect[option]) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// Complete callback\n\t\t\tif ($.isFunction(option)) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// Options hash (but not naming an effect)\n\t\t\tif ((typeof option === \"undefined\" ? \"undefined\" : _typeof(option)) === \"object\" && !option.effect) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// Didn't match any standard API\n\t\t\treturn false;\n\t\t}\n\n\t\t$.fn.extend({\n\t\t\teffect: function effect() /* effect, options, speed, callback */{\n\t\t\t\tvar args = _normalizeArguments.apply(this, arguments),\n\t\t\t\t    mode = args.mode,\n\t\t\t\t    queue = args.queue,\n\t\t\t\t    effectMethod = $.effects.effect[args.effect];\n\n\t\t\t\tif ($.fx.off || !effectMethod) {\n\t\t\t\t\t// delegate to the original method (e.g., .show()) if possible\n\t\t\t\t\tif (mode) {\n\t\t\t\t\t\treturn this[mode](args.duration, args.complete);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn this.each(function () {\n\t\t\t\t\t\t\tif (args.complete) {\n\t\t\t\t\t\t\t\targs.complete.call(this);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfunction run(next) {\n\t\t\t\t\tvar elem = $(this),\n\t\t\t\t\t    complete = args.complete,\n\t\t\t\t\t    mode = args.mode;\n\n\t\t\t\t\tfunction done() {\n\t\t\t\t\t\tif ($.isFunction(complete)) {\n\t\t\t\t\t\t\tcomplete.call(elem[0]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ($.isFunction(next)) {\n\t\t\t\t\t\t\tnext();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// If the element already has the correct final state, delegate to\n\t\t\t\t\t// the core methods so the internal tracking of \"olddisplay\" works.\n\t\t\t\t\tif (elem.is(\":hidden\") ? mode === \"hide\" : mode === \"show\") {\n\t\t\t\t\t\telem[mode]();\n\t\t\t\t\t\tdone();\n\t\t\t\t\t} else {\n\t\t\t\t\t\teffectMethod.call(elem[0], args, done);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn queue === false ? this.each(run) : this.queue(queue || \"fx\", run);\n\t\t\t},\n\n\t\t\tshow: function (orig) {\n\t\t\t\treturn function (option) {\n\t\t\t\t\tif (standardAnimationOption(option)) {\n\t\t\t\t\t\treturn orig.apply(this, arguments);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar args = _normalizeArguments.apply(this, arguments);\n\t\t\t\t\t\targs.mode = \"show\";\n\t\t\t\t\t\treturn this.effect.call(this, args);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}($.fn.show),\n\n\t\t\thide: function (orig) {\n\t\t\t\treturn function (option) {\n\t\t\t\t\tif (standardAnimationOption(option)) {\n\t\t\t\t\t\treturn orig.apply(this, arguments);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar args = _normalizeArguments.apply(this, arguments);\n\t\t\t\t\t\targs.mode = \"hide\";\n\t\t\t\t\t\treturn this.effect.call(this, args);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}($.fn.hide),\n\n\t\t\ttoggle: function (orig) {\n\t\t\t\treturn function (option) {\n\t\t\t\t\tif (standardAnimationOption(option) || typeof option === \"boolean\") {\n\t\t\t\t\t\treturn orig.apply(this, arguments);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar args = _normalizeArguments.apply(this, arguments);\n\t\t\t\t\t\targs.mode = \"toggle\";\n\t\t\t\t\t\treturn this.effect.call(this, args);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}($.fn.toggle),\n\n\t\t\t// helper functions\n\t\t\tcssUnit: function cssUnit(key) {\n\t\t\t\tvar style = this.css(key),\n\t\t\t\t    val = [];\n\n\t\t\t\t$.each([\"em\", \"px\", \"%\", \"pt\"], function (i, unit) {\n\t\t\t\t\tif (style.indexOf(unit) > 0) {\n\t\t\t\t\t\tval = [parseFloat(style), unit];\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn val;\n\t\t\t}\n\t\t});\n\t})();\n\n\t/******************************************************************************/\n\t/*********************************** EASING ***********************************/\n\t/******************************************************************************/\n\n\t(function () {\n\n\t\t// based on easing equations from Robert Penner (http://www.robertpenner.com/easing)\n\n\t\tvar baseEasings = {};\n\n\t\t$.each([\"Quad\", \"Cubic\", \"Quart\", \"Quint\", \"Expo\"], function (i, name) {\n\t\t\tbaseEasings[name] = function (p) {\n\t\t\t\treturn Math.pow(p, i + 2);\n\t\t\t};\n\t\t});\n\n\t\t$.extend(baseEasings, {\n\t\t\tSine: function Sine(p) {\n\t\t\t\treturn 1 - Math.cos(p * Math.PI / 2);\n\t\t\t},\n\t\t\tCirc: function Circ(p) {\n\t\t\t\treturn 1 - Math.sqrt(1 - p * p);\n\t\t\t},\n\t\t\tElastic: function Elastic(p) {\n\t\t\t\treturn p === 0 || p === 1 ? p : -Math.pow(2, 8 * (p - 1)) * Math.sin(((p - 1) * 80 - 7.5) * Math.PI / 15);\n\t\t\t},\n\t\t\tBack: function Back(p) {\n\t\t\t\treturn p * p * (3 * p - 2);\n\t\t\t},\n\t\t\tBounce: function Bounce(p) {\n\t\t\t\tvar pow2,\n\t\t\t\t    bounce = 4;\n\n\t\t\t\twhile (p < ((pow2 = Math.pow(2, --bounce)) - 1) / 11) {}\n\t\t\t\treturn 1 / Math.pow(4, 3 - bounce) - 7.5625 * Math.pow((pow2 * 3 - 2) / 22 - p, 2);\n\t\t\t}\n\t\t});\n\n\t\t$.each(baseEasings, function (name, easeIn) {\n\t\t\t$.easing[\"easeIn\" + name] = easeIn;\n\t\t\t$.easing[\"easeOut\" + name] = function (p) {\n\t\t\t\treturn 1 - easeIn(1 - p);\n\t\t\t};\n\t\t\t$.easing[\"easeInOut\" + name] = function (p) {\n\t\t\t\treturn p < 0.5 ? easeIn(p * 2) / 2 : 1 - easeIn(p * -2 + 2) / 2;\n\t\t\t};\n\t\t});\n\t})();\n\n\tvar effect = $.effects;\n\n\t/*!\n  * jQuery UI Effects Blind 1.11.4\n  * http://jqueryui.com\n  *\n  * Copyright jQuery Foundation and other contributors\n  * Released under the MIT license.\n  * http://jquery.org/license\n  *\n  * http://api.jqueryui.com/blind-effect/\n  */\n\n\tvar effectBlind = $.effects.effect.blind = function (o, done) {\n\t\t// Create element\n\t\tvar el = $(this),\n\t\t    rvertical = /up|down|vertical/,\n\t\t    rpositivemotion = /up|left|vertical|horizontal/,\n\t\t    props = [\"position\", \"top\", \"bottom\", \"left\", \"right\", \"height\", \"width\"],\n\t\t    mode = $.effects.setMode(el, o.mode || \"hide\"),\n\t\t    direction = o.direction || \"up\",\n\t\t    vertical = rvertical.test(direction),\n\t\t    ref = vertical ? \"height\" : \"width\",\n\t\t    ref2 = vertical ? \"top\" : \"left\",\n\t\t    motion = rpositivemotion.test(direction),\n\t\t    animation = {},\n\t\t    show = mode === \"show\",\n\t\t    wrapper,\n\t\t    distance,\n\t\t    margin;\n\n\t\t// if already wrapped, the wrapper's properties are my property. #6245\n\t\tif (el.parent().is(\".ui-effects-wrapper\")) {\n\t\t\t$.effects.save(el.parent(), props);\n\t\t} else {\n\t\t\t$.effects.save(el, props);\n\t\t}\n\t\tel.show();\n\t\twrapper = $.effects.createWrapper(el).css({\n\t\t\toverflow: \"hidden\"\n\t\t});\n\n\t\tdistance = wrapper[ref]();\n\t\tmargin = parseFloat(wrapper.css(ref2)) || 0;\n\n\t\tanimation[ref] = show ? distance : 0;\n\t\tif (!motion) {\n\t\t\tel.css(vertical ? \"bottom\" : \"right\", 0).css(vertical ? \"top\" : \"left\", \"auto\").css({ position: \"absolute\" });\n\n\t\t\tanimation[ref2] = show ? margin : distance + margin;\n\t\t}\n\n\t\t// start at 0 if we are showing\n\t\tif (show) {\n\t\t\twrapper.css(ref, 0);\n\t\t\tif (!motion) {\n\t\t\t\twrapper.css(ref2, margin + distance);\n\t\t\t}\n\t\t}\n\n\t\t// Animate\n\t\twrapper.animate(animation, {\n\t\t\tduration: o.duration,\n\t\t\teasing: o.easing,\n\t\t\tqueue: false,\n\t\t\tcomplete: function complete() {\n\t\t\t\tif (mode === \"hide\") {\n\t\t\t\t\tel.hide();\n\t\t\t\t}\n\t\t\t\t$.effects.restore(el, props);\n\t\t\t\t$.effects.removeWrapper(el);\n\t\t\t\tdone();\n\t\t\t}\n\t\t});\n\t};\n\n\t/*!\n  * jQuery UI Effects Bounce 1.11.4\n  * http://jqueryui.com\n  *\n  * Copyright jQuery Foundation and other contributors\n  * Released under the MIT license.\n  * http://jquery.org/license\n  *\n  * http://api.jqueryui.com/bounce-effect/\n  */\n\n\tvar effectBounce = $.effects.effect.bounce = function (o, done) {\n\t\tvar el = $(this),\n\t\t    props = [\"position\", \"top\", \"bottom\", \"left\", \"right\", \"height\", \"width\"],\n\n\n\t\t// defaults:\n\t\tmode = $.effects.setMode(el, o.mode || \"effect\"),\n\t\t    hide = mode === \"hide\",\n\t\t    show = mode === \"show\",\n\t\t    direction = o.direction || \"up\",\n\t\t    distance = o.distance,\n\t\t    times = o.times || 5,\n\n\n\t\t// number of internal animations\n\t\tanims = times * 2 + (show || hide ? 1 : 0),\n\t\t    speed = o.duration / anims,\n\t\t    easing = o.easing,\n\n\n\t\t// utility:\n\t\tref = direction === \"up\" || direction === \"down\" ? \"top\" : \"left\",\n\t\t    motion = direction === \"up\" || direction === \"left\",\n\t\t    i,\n\t\t    upAnim,\n\t\t    downAnim,\n\n\n\t\t// we will need to re-assemble the queue to stack our animations in place\n\t\tqueue = el.queue(),\n\t\t    queuelen = queue.length;\n\n\t\t// Avoid touching opacity to prevent clearType and PNG issues in IE\n\t\tif (show || hide) {\n\t\t\tprops.push(\"opacity\");\n\t\t}\n\n\t\t$.effects.save(el, props);\n\t\tel.show();\n\t\t$.effects.createWrapper(el); // Create Wrapper\n\n\t\t// default distance for the BIGGEST bounce is the outer Distance / 3\n\t\tif (!distance) {\n\t\t\tdistance = el[ref === \"top\" ? \"outerHeight\" : \"outerWidth\"]() / 3;\n\t\t}\n\n\t\tif (show) {\n\t\t\tdownAnim = { opacity: 1 };\n\t\t\tdownAnim[ref] = 0;\n\n\t\t\t// if we are showing, force opacity 0 and set the initial position\n\t\t\t// then do the \"first\" animation\n\t\t\tel.css(\"opacity\", 0).css(ref, motion ? -distance * 2 : distance * 2).animate(downAnim, speed, easing);\n\t\t}\n\n\t\t// start at the smallest distance if we are hiding\n\t\tif (hide) {\n\t\t\tdistance = distance / Math.pow(2, times - 1);\n\t\t}\n\n\t\tdownAnim = {};\n\t\tdownAnim[ref] = 0;\n\t\t// Bounces up/down/left/right then back to 0 -- times * 2 animations happen here\n\t\tfor (i = 0; i < times; i++) {\n\t\t\tupAnim = {};\n\t\t\tupAnim[ref] = (motion ? \"-=\" : \"+=\") + distance;\n\n\t\t\tel.animate(upAnim, speed, easing).animate(downAnim, speed, easing);\n\n\t\t\tdistance = hide ? distance * 2 : distance / 2;\n\t\t}\n\n\t\t// Last Bounce when Hiding\n\t\tif (hide) {\n\t\t\tupAnim = { opacity: 0 };\n\t\t\tupAnim[ref] = (motion ? \"-=\" : \"+=\") + distance;\n\n\t\t\tel.animate(upAnim, speed, easing);\n\t\t}\n\n\t\tel.queue(function () {\n\t\t\tif (hide) {\n\t\t\t\tel.hide();\n\t\t\t}\n\t\t\t$.effects.restore(el, props);\n\t\t\t$.effects.removeWrapper(el);\n\t\t\tdone();\n\t\t});\n\n\t\t// inject all the animations we just queued to be first in line (after \"inprogress\")\n\t\tif (queuelen > 1) {\n\t\t\tqueue.splice.apply(queue, [1, 0].concat(queue.splice(queuelen, anims + 1)));\n\t\t}\n\t\tel.dequeue();\n\t};\n\n\t/*!\n  * jQuery UI Effects Clip 1.11.4\n  * http://jqueryui.com\n  *\n  * Copyright jQuery Foundation and other contributors\n  * Released under the MIT license.\n  * http://jquery.org/license\n  *\n  * http://api.jqueryui.com/clip-effect/\n  */\n\n\tvar effectClip = $.effects.effect.clip = function (o, done) {\n\t\t// Create element\n\t\tvar el = $(this),\n\t\t    props = [\"position\", \"top\", \"bottom\", \"left\", \"right\", \"height\", \"width\"],\n\t\t    mode = $.effects.setMode(el, o.mode || \"hide\"),\n\t\t    show = mode === \"show\",\n\t\t    direction = o.direction || \"vertical\",\n\t\t    vert = direction === \"vertical\",\n\t\t    size = vert ? \"height\" : \"width\",\n\t\t    position = vert ? \"top\" : \"left\",\n\t\t    animation = {},\n\t\t    wrapper,\n\t\t    animate,\n\t\t    distance;\n\n\t\t// Save & Show\n\t\t$.effects.save(el, props);\n\t\tel.show();\n\n\t\t// Create Wrapper\n\t\twrapper = $.effects.createWrapper(el).css({\n\t\t\toverflow: \"hidden\"\n\t\t});\n\t\tanimate = el[0].tagName === \"IMG\" ? wrapper : el;\n\t\tdistance = animate[size]();\n\n\t\t// Shift\n\t\tif (show) {\n\t\t\tanimate.css(size, 0);\n\t\t\tanimate.css(position, distance / 2);\n\t\t}\n\n\t\t// Create Animation Object:\n\t\tanimation[size] = show ? distance : 0;\n\t\tanimation[position] = show ? 0 : distance / 2;\n\n\t\t// Animate\n\t\tanimate.animate(animation, {\n\t\t\tqueue: false,\n\t\t\tduration: o.duration,\n\t\t\teasing: o.easing,\n\t\t\tcomplete: function complete() {\n\t\t\t\tif (!show) {\n\t\t\t\t\tel.hide();\n\t\t\t\t}\n\t\t\t\t$.effects.restore(el, props);\n\t\t\t\t$.effects.removeWrapper(el);\n\t\t\t\tdone();\n\t\t\t}\n\t\t});\n\t};\n\n\t/*!\n  * jQuery UI Effects Drop 1.11.4\n  * http://jqueryui.com\n  *\n  * Copyright jQuery Foundation and other contributors\n  * Released under the MIT license.\n  * http://jquery.org/license\n  *\n  * http://api.jqueryui.com/drop-effect/\n  */\n\n\tvar effectDrop = $.effects.effect.drop = function (o, done) {\n\n\t\tvar el = $(this),\n\t\t    props = [\"position\", \"top\", \"bottom\", \"left\", \"right\", \"opacity\", \"height\", \"width\"],\n\t\t    mode = $.effects.setMode(el, o.mode || \"hide\"),\n\t\t    show = mode === \"show\",\n\t\t    direction = o.direction || \"left\",\n\t\t    ref = direction === \"up\" || direction === \"down\" ? \"top\" : \"left\",\n\t\t    motion = direction === \"up\" || direction === \"left\" ? \"pos\" : \"neg\",\n\t\t    animation = {\n\t\t\topacity: show ? 1 : 0\n\t\t},\n\t\t    distance;\n\n\t\t// Adjust\n\t\t$.effects.save(el, props);\n\t\tel.show();\n\t\t$.effects.createWrapper(el);\n\n\t\tdistance = o.distance || el[ref === \"top\" ? \"outerHeight\" : \"outerWidth\"](true) / 2;\n\n\t\tif (show) {\n\t\t\tel.css(\"opacity\", 0).css(ref, motion === \"pos\" ? -distance : distance);\n\t\t}\n\n\t\t// Animation\n\t\tanimation[ref] = (show ? motion === \"pos\" ? \"+=\" : \"-=\" : motion === \"pos\" ? \"-=\" : \"+=\") + distance;\n\n\t\t// Animate\n\t\tel.animate(animation, {\n\t\t\tqueue: false,\n\t\t\tduration: o.duration,\n\t\t\teasing: o.easing,\n\t\t\tcomplete: function complete() {\n\t\t\t\tif (mode === \"hide\") {\n\t\t\t\t\tel.hide();\n\t\t\t\t}\n\t\t\t\t$.effects.restore(el, props);\n\t\t\t\t$.effects.removeWrapper(el);\n\t\t\t\tdone();\n\t\t\t}\n\t\t});\n\t};\n\n\t/*!\n  * jQuery UI Effects Explode 1.11.4\n  * http://jqueryui.com\n  *\n  * Copyright jQuery Foundation and other contributors\n  * Released under the MIT license.\n  * http://jquery.org/license\n  *\n  * http://api.jqueryui.com/explode-effect/\n  */\n\n\tvar effectExplode = $.effects.effect.explode = function (o, done) {\n\n\t\tvar rows = o.pieces ? Math.round(Math.sqrt(o.pieces)) : 3,\n\t\t    cells = rows,\n\t\t    el = $(this),\n\t\t    mode = $.effects.setMode(el, o.mode || \"hide\"),\n\t\t    show = mode === \"show\",\n\n\n\t\t// show and then visibility:hidden the element before calculating offset\n\t\toffset = el.show().css(\"visibility\", \"hidden\").offset(),\n\n\n\t\t// width and height of a piece\n\t\twidth = Math.ceil(el.outerWidth() / cells),\n\t\t    height = Math.ceil(el.outerHeight() / rows),\n\t\t    pieces = [],\n\n\n\t\t// loop\n\t\ti,\n\t\t    j,\n\t\t    left,\n\t\t    top,\n\t\t    mx,\n\t\t    my;\n\n\t\t// children animate complete:\n\t\tfunction childComplete() {\n\t\t\tpieces.push(this);\n\t\t\tif (pieces.length === rows * cells) {\n\t\t\t\tanimComplete();\n\t\t\t}\n\t\t}\n\n\t\t// clone the element for each row and cell.\n\t\tfor (i = 0; i < rows; i++) {\n\t\t\t// ===>\n\t\t\ttop = offset.top + i * height;\n\t\t\tmy = i - (rows - 1) / 2;\n\n\t\t\tfor (j = 0; j < cells; j++) {\n\t\t\t\t// |||\n\t\t\t\tleft = offset.left + j * width;\n\t\t\t\tmx = j - (cells - 1) / 2;\n\n\t\t\t\t// Create a clone of the now hidden main element that will be absolute positioned\n\t\t\t\t// within a wrapper div off the -left and -top equal to size of our pieces\n\t\t\t\tel.clone().appendTo(\"body\").wrap(\"<div></div>\").css({\n\t\t\t\t\tposition: \"absolute\",\n\t\t\t\t\tvisibility: \"visible\",\n\t\t\t\t\tleft: -j * width,\n\t\t\t\t\ttop: -i * height\n\t\t\t\t})\n\n\t\t\t\t// select the wrapper - make it overflow: hidden and absolute positioned based on\n\t\t\t\t// where the original was located +left and +top equal to the size of pieces\n\t\t\t\t.parent().addClass(\"ui-effects-explode\").css({\n\t\t\t\t\tposition: \"absolute\",\n\t\t\t\t\toverflow: \"hidden\",\n\t\t\t\t\twidth: width,\n\t\t\t\t\theight: height,\n\t\t\t\t\tleft: left + (show ? mx * width : 0),\n\t\t\t\t\ttop: top + (show ? my * height : 0),\n\t\t\t\t\topacity: show ? 0 : 1\n\t\t\t\t}).animate({\n\t\t\t\t\tleft: left + (show ? 0 : mx * width),\n\t\t\t\t\ttop: top + (show ? 0 : my * height),\n\t\t\t\t\topacity: show ? 1 : 0\n\t\t\t\t}, o.duration || 500, o.easing, childComplete);\n\t\t\t}\n\t\t}\n\n\t\tfunction animComplete() {\n\t\t\tel.css({\n\t\t\t\tvisibility: \"visible\"\n\t\t\t});\n\t\t\t$(pieces).remove();\n\t\t\tif (!show) {\n\t\t\t\tel.hide();\n\t\t\t}\n\t\t\tdone();\n\t\t}\n\t};\n\n\t/*!\n  * jQuery UI Effects Fade 1.11.4\n  * http://jqueryui.com\n  *\n  * Copyright jQuery Foundation and other contributors\n  * Released under the MIT license.\n  * http://jquery.org/license\n  *\n  * http://api.jqueryui.com/fade-effect/\n  */\n\n\tvar effectFade = $.effects.effect.fade = function (o, done) {\n\t\tvar el = $(this),\n\t\t    mode = $.effects.setMode(el, o.mode || \"toggle\");\n\n\t\tel.animate({\n\t\t\topacity: mode\n\t\t}, {\n\t\t\tqueue: false,\n\t\t\tduration: o.duration,\n\t\t\teasing: o.easing,\n\t\t\tcomplete: done\n\t\t});\n\t};\n\n\t/*!\n  * jQuery UI Effects Fold 1.11.4\n  * http://jqueryui.com\n  *\n  * Copyright jQuery Foundation and other contributors\n  * Released under the MIT license.\n  * http://jquery.org/license\n  *\n  * http://api.jqueryui.com/fold-effect/\n  */\n\n\tvar effectFold = $.effects.effect.fold = function (o, done) {\n\n\t\t// Create element\n\t\tvar el = $(this),\n\t\t    props = [\"position\", \"top\", \"bottom\", \"left\", \"right\", \"height\", \"width\"],\n\t\t    mode = $.effects.setMode(el, o.mode || \"hide\"),\n\t\t    show = mode === \"show\",\n\t\t    hide = mode === \"hide\",\n\t\t    size = o.size || 15,\n\t\t    percent = /([0-9]+)%/.exec(size),\n\t\t    horizFirst = !!o.horizFirst,\n\t\t    widthFirst = show !== horizFirst,\n\t\t    ref = widthFirst ? [\"width\", \"height\"] : [\"height\", \"width\"],\n\t\t    duration = o.duration / 2,\n\t\t    wrapper,\n\t\t    distance,\n\t\t    animation1 = {},\n\t\t    animation2 = {};\n\n\t\t$.effects.save(el, props);\n\t\tel.show();\n\n\t\t// Create Wrapper\n\t\twrapper = $.effects.createWrapper(el).css({\n\t\t\toverflow: \"hidden\"\n\t\t});\n\t\tdistance = widthFirst ? [wrapper.width(), wrapper.height()] : [wrapper.height(), wrapper.width()];\n\n\t\tif (percent) {\n\t\t\tsize = parseInt(percent[1], 10) / 100 * distance[hide ? 0 : 1];\n\t\t}\n\t\tif (show) {\n\t\t\twrapper.css(horizFirst ? {\n\t\t\t\theight: 0,\n\t\t\t\twidth: size\n\t\t\t} : {\n\t\t\t\theight: size,\n\t\t\t\twidth: 0\n\t\t\t});\n\t\t}\n\n\t\t// Animation\n\t\tanimation1[ref[0]] = show ? distance[0] : size;\n\t\tanimation2[ref[1]] = show ? distance[1] : 0;\n\n\t\t// Animate\n\t\twrapper.animate(animation1, duration, o.easing).animate(animation2, duration, o.easing, function () {\n\t\t\tif (hide) {\n\t\t\t\tel.hide();\n\t\t\t}\n\t\t\t$.effects.restore(el, props);\n\t\t\t$.effects.removeWrapper(el);\n\t\t\tdone();\n\t\t});\n\t};\n\n\t/*!\n  * jQuery UI Effects Highlight 1.11.4\n  * http://jqueryui.com\n  *\n  * Copyright jQuery Foundation and other contributors\n  * Released under the MIT license.\n  * http://jquery.org/license\n  *\n  * http://api.jqueryui.com/highlight-effect/\n  */\n\n\tvar effectHighlight = $.effects.effect.highlight = function (o, done) {\n\t\tvar elem = $(this),\n\t\t    props = [\"backgroundImage\", \"backgroundColor\", \"opacity\"],\n\t\t    mode = $.effects.setMode(elem, o.mode || \"show\"),\n\t\t    animation = {\n\t\t\tbackgroundColor: elem.css(\"backgroundColor\")\n\t\t};\n\n\t\tif (mode === \"hide\") {\n\t\t\tanimation.opacity = 0;\n\t\t}\n\n\t\t$.effects.save(elem, props);\n\n\t\telem.show().css({\n\t\t\tbackgroundImage: \"none\",\n\t\t\tbackgroundColor: o.color || \"#ffff99\"\n\t\t}).animate(animation, {\n\t\t\tqueue: false,\n\t\t\tduration: o.duration,\n\t\t\teasing: o.easing,\n\t\t\tcomplete: function complete() {\n\t\t\t\tif (mode === \"hide\") {\n\t\t\t\t\telem.hide();\n\t\t\t\t}\n\t\t\t\t$.effects.restore(elem, props);\n\t\t\t\tdone();\n\t\t\t}\n\t\t});\n\t};\n\n\t/*!\n  * jQuery UI Effects Size 1.11.4\n  * http://jqueryui.com\n  *\n  * Copyright jQuery Foundation and other contributors\n  * Released under the MIT license.\n  * http://jquery.org/license\n  *\n  * http://api.jqueryui.com/size-effect/\n  */\n\n\tvar effectSize = $.effects.effect.size = function (o, done) {\n\n\t\t// Create element\n\t\tvar original,\n\t\t    baseline,\n\t\t    factor,\n\t\t    el = $(this),\n\t\t    props0 = [\"position\", \"top\", \"bottom\", \"left\", \"right\", \"width\", \"height\", \"overflow\", \"opacity\"],\n\n\n\t\t// Always restore\n\t\tprops1 = [\"position\", \"top\", \"bottom\", \"left\", \"right\", \"overflow\", \"opacity\"],\n\n\n\t\t// Copy for children\n\t\tprops2 = [\"width\", \"height\", \"overflow\"],\n\t\t    cProps = [\"fontSize\"],\n\t\t    vProps = [\"borderTopWidth\", \"borderBottomWidth\", \"paddingTop\", \"paddingBottom\"],\n\t\t    hProps = [\"borderLeftWidth\", \"borderRightWidth\", \"paddingLeft\", \"paddingRight\"],\n\n\n\t\t// Set options\n\t\tmode = $.effects.setMode(el, o.mode || \"effect\"),\n\t\t    restore = o.restore || mode !== \"effect\",\n\t\t    scale = o.scale || \"both\",\n\t\t    origin = o.origin || [\"middle\", \"center\"],\n\t\t    position = el.css(\"position\"),\n\t\t    props = restore ? props0 : props1,\n\t\t    zero = {\n\t\t\theight: 0,\n\t\t\twidth: 0,\n\t\t\touterHeight: 0,\n\t\t\touterWidth: 0\n\t\t};\n\n\t\tif (mode === \"show\") {\n\t\t\tel.show();\n\t\t}\n\t\toriginal = {\n\t\t\theight: el.height(),\n\t\t\twidth: el.width(),\n\t\t\touterHeight: el.outerHeight(),\n\t\t\touterWidth: el.outerWidth()\n\t\t};\n\n\t\tif (o.mode === \"toggle\" && mode === \"show\") {\n\t\t\tel.from = o.to || zero;\n\t\t\tel.to = o.from || original;\n\t\t} else {\n\t\t\tel.from = o.from || (mode === \"show\" ? zero : original);\n\t\t\tel.to = o.to || (mode === \"hide\" ? zero : original);\n\t\t}\n\n\t\t// Set scaling factor\n\t\tfactor = {\n\t\t\tfrom: {\n\t\t\t\ty: el.from.height / original.height,\n\t\t\t\tx: el.from.width / original.width\n\t\t\t},\n\t\t\tto: {\n\t\t\t\ty: el.to.height / original.height,\n\t\t\t\tx: el.to.width / original.width\n\t\t\t}\n\t\t};\n\n\t\t// Scale the css box\n\t\tif (scale === \"box\" || scale === \"both\") {\n\n\t\t\t// Vertical props scaling\n\t\t\tif (factor.from.y !== factor.to.y) {\n\t\t\t\tprops = props.concat(vProps);\n\t\t\t\tel.from = $.effects.setTransition(el, vProps, factor.from.y, el.from);\n\t\t\t\tel.to = $.effects.setTransition(el, vProps, factor.to.y, el.to);\n\t\t\t}\n\n\t\t\t// Horizontal props scaling\n\t\t\tif (factor.from.x !== factor.to.x) {\n\t\t\t\tprops = props.concat(hProps);\n\t\t\t\tel.from = $.effects.setTransition(el, hProps, factor.from.x, el.from);\n\t\t\t\tel.to = $.effects.setTransition(el, hProps, factor.to.x, el.to);\n\t\t\t}\n\t\t}\n\n\t\t// Scale the content\n\t\tif (scale === \"content\" || scale === \"both\") {\n\n\t\t\t// Vertical props scaling\n\t\t\tif (factor.from.y !== factor.to.y) {\n\t\t\t\tprops = props.concat(cProps).concat(props2);\n\t\t\t\tel.from = $.effects.setTransition(el, cProps, factor.from.y, el.from);\n\t\t\t\tel.to = $.effects.setTransition(el, cProps, factor.to.y, el.to);\n\t\t\t}\n\t\t}\n\n\t\t$.effects.save(el, props);\n\t\tel.show();\n\t\t$.effects.createWrapper(el);\n\t\tel.css(\"overflow\", \"hidden\").css(el.from);\n\n\t\t// Adjust\n\t\tif (origin) {\n\t\t\t// Calculate baseline shifts\n\t\t\tbaseline = $.effects.getBaseline(origin, original);\n\t\t\tel.from.top = (original.outerHeight - el.outerHeight()) * baseline.y;\n\t\t\tel.from.left = (original.outerWidth - el.outerWidth()) * baseline.x;\n\t\t\tel.to.top = (original.outerHeight - el.to.outerHeight) * baseline.y;\n\t\t\tel.to.left = (original.outerWidth - el.to.outerWidth) * baseline.x;\n\t\t}\n\t\tel.css(el.from); // set top & left\n\n\t\t// Animate\n\t\tif (scale === \"content\" || scale === \"both\") {\n\t\t\t// Scale the children\n\n\t\t\t// Add margins/font-size\n\t\t\tvProps = vProps.concat([\"marginTop\", \"marginBottom\"]).concat(cProps);\n\t\t\thProps = hProps.concat([\"marginLeft\", \"marginRight\"]);\n\t\t\tprops2 = props0.concat(vProps).concat(hProps);\n\n\t\t\tel.find(\"*[width]\").each(function () {\n\t\t\t\tvar child = $(this),\n\t\t\t\t    c_original = {\n\t\t\t\t\theight: child.height(),\n\t\t\t\t\twidth: child.width(),\n\t\t\t\t\touterHeight: child.outerHeight(),\n\t\t\t\t\touterWidth: child.outerWidth()\n\t\t\t\t};\n\t\t\t\tif (restore) {\n\t\t\t\t\t$.effects.save(child, props2);\n\t\t\t\t}\n\n\t\t\t\tchild.from = {\n\t\t\t\t\theight: c_original.height * factor.from.y,\n\t\t\t\t\twidth: c_original.width * factor.from.x,\n\t\t\t\t\touterHeight: c_original.outerHeight * factor.from.y,\n\t\t\t\t\touterWidth: c_original.outerWidth * factor.from.x\n\t\t\t\t};\n\t\t\t\tchild.to = {\n\t\t\t\t\theight: c_original.height * factor.to.y,\n\t\t\t\t\twidth: c_original.width * factor.to.x,\n\t\t\t\t\touterHeight: c_original.height * factor.to.y,\n\t\t\t\t\touterWidth: c_original.width * factor.to.x\n\t\t\t\t};\n\n\t\t\t\t// Vertical props scaling\n\t\t\t\tif (factor.from.y !== factor.to.y) {\n\t\t\t\t\tchild.from = $.effects.setTransition(child, vProps, factor.from.y, child.from);\n\t\t\t\t\tchild.to = $.effects.setTransition(child, vProps, factor.to.y, child.to);\n\t\t\t\t}\n\n\t\t\t\t// Horizontal props scaling\n\t\t\t\tif (factor.from.x !== factor.to.x) {\n\t\t\t\t\tchild.from = $.effects.setTransition(child, hProps, factor.from.x, child.from);\n\t\t\t\t\tchild.to = $.effects.setTransition(child, hProps, factor.to.x, child.to);\n\t\t\t\t}\n\n\t\t\t\t// Animate children\n\t\t\t\tchild.css(child.from);\n\t\t\t\tchild.animate(child.to, o.duration, o.easing, function () {\n\n\t\t\t\t\t// Restore children\n\t\t\t\t\tif (restore) {\n\t\t\t\t\t\t$.effects.restore(child, props2);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\t// Animate\n\t\tel.animate(el.to, {\n\t\t\tqueue: false,\n\t\t\tduration: o.duration,\n\t\t\teasing: o.easing,\n\t\t\tcomplete: function complete() {\n\t\t\t\tif (el.to.opacity === 0) {\n\t\t\t\t\tel.css(\"opacity\", el.from.opacity);\n\t\t\t\t}\n\t\t\t\tif (mode === \"hide\") {\n\t\t\t\t\tel.hide();\n\t\t\t\t}\n\t\t\t\t$.effects.restore(el, props);\n\t\t\t\tif (!restore) {\n\n\t\t\t\t\t// we need to calculate our new positioning based on the scaling\n\t\t\t\t\tif (position === \"static\") {\n\t\t\t\t\t\tel.css({\n\t\t\t\t\t\t\tposition: \"relative\",\n\t\t\t\t\t\t\ttop: el.to.top,\n\t\t\t\t\t\t\tleft: el.to.left\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$.each([\"top\", \"left\"], function (idx, pos) {\n\t\t\t\t\t\t\tel.css(pos, function (_, str) {\n\t\t\t\t\t\t\t\tvar val = parseInt(str, 10),\n\t\t\t\t\t\t\t\t    toRef = idx ? el.to.left : el.to.top;\n\n\t\t\t\t\t\t\t\t// if original was \"auto\", recalculate the new value from wrapper\n\t\t\t\t\t\t\t\tif (str === \"auto\") {\n\t\t\t\t\t\t\t\t\treturn toRef + \"px\";\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\treturn val + toRef + \"px\";\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t$.effects.removeWrapper(el);\n\t\t\t\tdone();\n\t\t\t}\n\t\t});\n\t};\n\n\t/*!\n  * jQuery UI Effects Scale 1.11.4\n  * http://jqueryui.com\n  *\n  * Copyright jQuery Foundation and other contributors\n  * Released under the MIT license.\n  * http://jquery.org/license\n  *\n  * http://api.jqueryui.com/scale-effect/\n  */\n\n\tvar effectScale = $.effects.effect.scale = function (o, done) {\n\n\t\t// Create element\n\t\tvar el = $(this),\n\t\t    options = $.extend(true, {}, o),\n\t\t    mode = $.effects.setMode(el, o.mode || \"effect\"),\n\t\t    percent = parseInt(o.percent, 10) || (parseInt(o.percent, 10) === 0 ? 0 : mode === \"hide\" ? 0 : 100),\n\t\t    direction = o.direction || \"both\",\n\t\t    origin = o.origin,\n\t\t    original = {\n\t\t\theight: el.height(),\n\t\t\twidth: el.width(),\n\t\t\touterHeight: el.outerHeight(),\n\t\t\touterWidth: el.outerWidth()\n\t\t},\n\t\t    factor = {\n\t\t\ty: direction !== \"horizontal\" ? percent / 100 : 1,\n\t\t\tx: direction !== \"vertical\" ? percent / 100 : 1\n\t\t};\n\n\t\t// We are going to pass this effect to the size effect:\n\t\toptions.effect = \"size\";\n\t\toptions.queue = false;\n\t\toptions.complete = done;\n\n\t\t// Set default origin and restore for show/hide\n\t\tif (mode !== \"effect\") {\n\t\t\toptions.origin = origin || [\"middle\", \"center\"];\n\t\t\toptions.restore = true;\n\t\t}\n\n\t\toptions.from = o.from || (mode === \"show\" ? {\n\t\t\theight: 0,\n\t\t\twidth: 0,\n\t\t\touterHeight: 0,\n\t\t\touterWidth: 0\n\t\t} : original);\n\t\toptions.to = {\n\t\t\theight: original.height * factor.y,\n\t\t\twidth: original.width * factor.x,\n\t\t\touterHeight: original.outerHeight * factor.y,\n\t\t\touterWidth: original.outerWidth * factor.x\n\t\t};\n\n\t\t// Fade option to support puff\n\t\tif (options.fade) {\n\t\t\tif (mode === \"show\") {\n\t\t\t\toptions.from.opacity = 0;\n\t\t\t\toptions.to.opacity = 1;\n\t\t\t}\n\t\t\tif (mode === \"hide\") {\n\t\t\t\toptions.from.opacity = 1;\n\t\t\t\toptions.to.opacity = 0;\n\t\t\t}\n\t\t}\n\n\t\t// Animate\n\t\tel.effect(options);\n\t};\n\n\t/*!\n  * jQuery UI Effects Puff 1.11.4\n  * http://jqueryui.com\n  *\n  * Copyright jQuery Foundation and other contributors\n  * Released under the MIT license.\n  * http://jquery.org/license\n  *\n  * http://api.jqueryui.com/puff-effect/\n  */\n\n\tvar effectPuff = $.effects.effect.puff = function (o, done) {\n\t\tvar elem = $(this),\n\t\t    mode = $.effects.setMode(elem, o.mode || \"hide\"),\n\t\t    hide = mode === \"hide\",\n\t\t    percent = parseInt(o.percent, 10) || 150,\n\t\t    factor = percent / 100,\n\t\t    original = {\n\t\t\theight: elem.height(),\n\t\t\twidth: elem.width(),\n\t\t\touterHeight: elem.outerHeight(),\n\t\t\touterWidth: elem.outerWidth()\n\t\t};\n\n\t\t$.extend(o, {\n\t\t\teffect: \"scale\",\n\t\t\tqueue: false,\n\t\t\tfade: true,\n\t\t\tmode: mode,\n\t\t\tcomplete: done,\n\t\t\tpercent: hide ? percent : 100,\n\t\t\tfrom: hide ? original : {\n\t\t\t\theight: original.height * factor,\n\t\t\t\twidth: original.width * factor,\n\t\t\t\touterHeight: original.outerHeight * factor,\n\t\t\t\touterWidth: original.outerWidth * factor\n\t\t\t}\n\t\t});\n\n\t\telem.effect(o);\n\t};\n\n\t/*!\n  * jQuery UI Effects Pulsate 1.11.4\n  * http://jqueryui.com\n  *\n  * Copyright jQuery Foundation and other contributors\n  * Released under the MIT license.\n  * http://jquery.org/license\n  *\n  * http://api.jqueryui.com/pulsate-effect/\n  */\n\n\tvar effectPulsate = $.effects.effect.pulsate = function (o, done) {\n\t\tvar elem = $(this),\n\t\t    mode = $.effects.setMode(elem, o.mode || \"show\"),\n\t\t    show = mode === \"show\",\n\t\t    hide = mode === \"hide\",\n\t\t    showhide = show || mode === \"hide\",\n\n\n\t\t// showing or hiding leaves of the \"last\" animation\n\t\tanims = (o.times || 5) * 2 + (showhide ? 1 : 0),\n\t\t    duration = o.duration / anims,\n\t\t    animateTo = 0,\n\t\t    queue = elem.queue(),\n\t\t    queuelen = queue.length,\n\t\t    i;\n\n\t\tif (show || !elem.is(\":visible\")) {\n\t\t\telem.css(\"opacity\", 0).show();\n\t\t\tanimateTo = 1;\n\t\t}\n\n\t\t// anims - 1 opacity \"toggles\"\n\t\tfor (i = 1; i < anims; i++) {\n\t\t\telem.animate({\n\t\t\t\topacity: animateTo\n\t\t\t}, duration, o.easing);\n\t\t\tanimateTo = 1 - animateTo;\n\t\t}\n\n\t\telem.animate({\n\t\t\topacity: animateTo\n\t\t}, duration, o.easing);\n\n\t\telem.queue(function () {\n\t\t\tif (hide) {\n\t\t\t\telem.hide();\n\t\t\t}\n\t\t\tdone();\n\t\t});\n\n\t\t// We just queued up \"anims\" animations, we need to put them next in the queue\n\t\tif (queuelen > 1) {\n\t\t\tqueue.splice.apply(queue, [1, 0].concat(queue.splice(queuelen, anims + 1)));\n\t\t}\n\t\telem.dequeue();\n\t};\n\n\t/*!\n  * jQuery UI Effects Shake 1.11.4\n  * http://jqueryui.com\n  *\n  * Copyright jQuery Foundation and other contributors\n  * Released under the MIT license.\n  * http://jquery.org/license\n  *\n  * http://api.jqueryui.com/shake-effect/\n  */\n\n\tvar effectShake = $.effects.effect.shake = function (o, done) {\n\n\t\tvar el = $(this),\n\t\t    props = [\"position\", \"top\", \"bottom\", \"left\", \"right\", \"height\", \"width\"],\n\t\t    mode = $.effects.setMode(el, o.mode || \"effect\"),\n\t\t    direction = o.direction || \"left\",\n\t\t    distance = o.distance || 20,\n\t\t    times = o.times || 3,\n\t\t    anims = times * 2 + 1,\n\t\t    speed = Math.round(o.duration / anims),\n\t\t    ref = direction === \"up\" || direction === \"down\" ? \"top\" : \"left\",\n\t\t    positiveMotion = direction === \"up\" || direction === \"left\",\n\t\t    animation = {},\n\t\t    animation1 = {},\n\t\t    animation2 = {},\n\t\t    i,\n\n\n\t\t// we will need to re-assemble the queue to stack our animations in place\n\t\tqueue = el.queue(),\n\t\t    queuelen = queue.length;\n\n\t\t$.effects.save(el, props);\n\t\tel.show();\n\t\t$.effects.createWrapper(el);\n\n\t\t// Animation\n\t\tanimation[ref] = (positiveMotion ? \"-=\" : \"+=\") + distance;\n\t\tanimation1[ref] = (positiveMotion ? \"+=\" : \"-=\") + distance * 2;\n\t\tanimation2[ref] = (positiveMotion ? \"-=\" : \"+=\") + distance * 2;\n\n\t\t// Animate\n\t\tel.animate(animation, speed, o.easing);\n\n\t\t// Shakes\n\t\tfor (i = 1; i < times; i++) {\n\t\t\tel.animate(animation1, speed, o.easing).animate(animation2, speed, o.easing);\n\t\t}\n\t\tel.animate(animation1, speed, o.easing).animate(animation, speed / 2, o.easing).queue(function () {\n\t\t\tif (mode === \"hide\") {\n\t\t\t\tel.hide();\n\t\t\t}\n\t\t\t$.effects.restore(el, props);\n\t\t\t$.effects.removeWrapper(el);\n\t\t\tdone();\n\t\t});\n\n\t\t// inject all the animations we just queued to be first in line (after \"inprogress\")\n\t\tif (queuelen > 1) {\n\t\t\tqueue.splice.apply(queue, [1, 0].concat(queue.splice(queuelen, anims + 1)));\n\t\t}\n\t\tel.dequeue();\n\t};\n\n\t/*!\n  * jQuery UI Effects Slide 1.11.4\n  * http://jqueryui.com\n  *\n  * Copyright jQuery Foundation and other contributors\n  * Released under the MIT license.\n  * http://jquery.org/license\n  *\n  * http://api.jqueryui.com/slide-effect/\n  */\n\n\tvar effectSlide = $.effects.effect.slide = function (o, done) {\n\n\t\t// Create element\n\t\tvar el = $(this),\n\t\t    props = [\"position\", \"top\", \"bottom\", \"left\", \"right\", \"width\", \"height\"],\n\t\t    mode = $.effects.setMode(el, o.mode || \"show\"),\n\t\t    show = mode === \"show\",\n\t\t    direction = o.direction || \"left\",\n\t\t    ref = direction === \"up\" || direction === \"down\" ? \"top\" : \"left\",\n\t\t    positiveMotion = direction === \"up\" || direction === \"left\",\n\t\t    distance,\n\t\t    animation = {};\n\n\t\t// Adjust\n\t\t$.effects.save(el, props);\n\t\tel.show();\n\t\tdistance = o.distance || el[ref === \"top\" ? \"outerHeight\" : \"outerWidth\"](true);\n\n\t\t$.effects.createWrapper(el).css({\n\t\t\toverflow: \"hidden\"\n\t\t});\n\n\t\tif (show) {\n\t\t\tel.css(ref, positiveMotion ? isNaN(distance) ? \"-\" + distance : -distance : distance);\n\t\t}\n\n\t\t// Animation\n\t\tanimation[ref] = (show ? positiveMotion ? \"+=\" : \"-=\" : positiveMotion ? \"-=\" : \"+=\") + distance;\n\n\t\t// Animate\n\t\tel.animate(animation, {\n\t\t\tqueue: false,\n\t\t\tduration: o.duration,\n\t\t\teasing: o.easing,\n\t\t\tcomplete: function complete() {\n\t\t\t\tif (mode === \"hide\") {\n\t\t\t\t\tel.hide();\n\t\t\t\t}\n\t\t\t\t$.effects.restore(el, props);\n\t\t\t\t$.effects.removeWrapper(el);\n\t\t\t\tdone();\n\t\t\t}\n\t\t});\n\t};\n\n\t/*!\n  * jQuery UI Effects Transfer 1.11.4\n  * http://jqueryui.com\n  *\n  * Copyright jQuery Foundation and other contributors\n  * Released under the MIT license.\n  * http://jquery.org/license\n  *\n  * http://api.jqueryui.com/transfer-effect/\n  */\n\n\tvar effectTransfer = $.effects.effect.transfer = function (o, done) {\n\t\tvar elem = $(this),\n\t\t    target = $(o.to),\n\t\t    targetFixed = target.css(\"position\") === \"fixed\",\n\t\t    body = $(\"body\"),\n\t\t    fixTop = targetFixed ? body.scrollTop() : 0,\n\t\t    fixLeft = targetFixed ? body.scrollLeft() : 0,\n\t\t    endPosition = target.offset(),\n\t\t    animation = {\n\t\t\ttop: endPosition.top - fixTop,\n\t\t\tleft: endPosition.left - fixLeft,\n\t\t\theight: target.innerHeight(),\n\t\t\twidth: target.innerWidth()\n\t\t},\n\t\t    startPosition = elem.offset(),\n\t\t    transfer = $(\"<div class='ui-effects-transfer'></div>\").appendTo(document.body).addClass(o.className).css({\n\t\t\ttop: startPosition.top - fixTop,\n\t\t\tleft: startPosition.left - fixLeft,\n\t\t\theight: elem.innerHeight(),\n\t\t\twidth: elem.innerWidth(),\n\t\t\tposition: targetFixed ? \"fixed\" : \"absolute\"\n\t\t}).animate(animation, o.duration, o.easing, function () {\n\t\t\ttransfer.remove();\n\t\t\tdone();\n\t\t});\n\t};\n\n\t/*!\n  * jQuery UI Progressbar 1.11.4\n  * http://jqueryui.com\n  *\n  * Copyright jQuery Foundation and other contributors\n  * Released under the MIT license.\n  * http://jquery.org/license\n  *\n  * http://api.jqueryui.com/progressbar/\n  */\n\n\tvar progressbar = $.widget(\"ui.progressbar\", {\n\t\tversion: \"1.11.4\",\n\t\toptions: {\n\t\t\tmax: 100,\n\t\t\tvalue: 0,\n\n\t\t\tchange: null,\n\t\t\tcomplete: null\n\t\t},\n\n\t\tmin: 0,\n\n\t\t_create: function _create() {\n\t\t\t// Constrain initial value\n\t\t\tthis.oldValue = this.options.value = this._constrainedValue();\n\n\t\t\tthis.element.addClass(\"ui-progressbar ui-widget ui-widget-content ui-corner-all\").attr({\n\t\t\t\t// Only set static values, aria-valuenow and aria-valuemax are\n\t\t\t\t// set inside _refreshValue()\n\t\t\t\trole: \"progressbar\",\n\t\t\t\t\"aria-valuemin\": this.min\n\t\t\t});\n\n\t\t\tthis.valueDiv = $(\"<div class='ui-progressbar-value ui-widget-header ui-corner-left'></div>\").appendTo(this.element);\n\n\t\t\tthis._refreshValue();\n\t\t},\n\n\t\t_destroy: function _destroy() {\n\t\t\tthis.element.removeClass(\"ui-progressbar ui-widget ui-widget-content ui-corner-all\").removeAttr(\"role\").removeAttr(\"aria-valuemin\").removeAttr(\"aria-valuemax\").removeAttr(\"aria-valuenow\");\n\n\t\t\tthis.valueDiv.remove();\n\t\t},\n\n\t\tvalue: function value(newValue) {\n\t\t\tif (newValue === undefined) {\n\t\t\t\treturn this.options.value;\n\t\t\t}\n\n\t\t\tthis.options.value = this._constrainedValue(newValue);\n\t\t\tthis._refreshValue();\n\t\t},\n\n\t\t_constrainedValue: function _constrainedValue(newValue) {\n\t\t\tif (newValue === undefined) {\n\t\t\t\tnewValue = this.options.value;\n\t\t\t}\n\n\t\t\tthis.indeterminate = newValue === false;\n\n\t\t\t// sanitize value\n\t\t\tif (typeof newValue !== \"number\") {\n\t\t\t\tnewValue = 0;\n\t\t\t}\n\n\t\t\treturn this.indeterminate ? false : Math.min(this.options.max, Math.max(this.min, newValue));\n\t\t},\n\n\t\t_setOptions: function _setOptions(options) {\n\t\t\t// Ensure \"value\" option is set after other values (like max)\n\t\t\tvar value = options.value;\n\t\t\tdelete options.value;\n\n\t\t\tthis._super(options);\n\n\t\t\tthis.options.value = this._constrainedValue(value);\n\t\t\tthis._refreshValue();\n\t\t},\n\n\t\t_setOption: function _setOption(key, value) {\n\t\t\tif (key === \"max\") {\n\t\t\t\t// Don't allow a max less than min\n\t\t\t\tvalue = Math.max(this.min, value);\n\t\t\t}\n\t\t\tif (key === \"disabled\") {\n\t\t\t\tthis.element.toggleClass(\"ui-state-disabled\", !!value).attr(\"aria-disabled\", value);\n\t\t\t}\n\t\t\tthis._super(key, value);\n\t\t},\n\n\t\t_percentage: function _percentage() {\n\t\t\treturn this.indeterminate ? 100 : 100 * (this.options.value - this.min) / (this.options.max - this.min);\n\t\t},\n\n\t\t_refreshValue: function _refreshValue() {\n\t\t\tvar value = this.options.value,\n\t\t\t    percentage = this._percentage();\n\n\t\t\tthis.valueDiv.toggle(this.indeterminate || value > this.min).toggleClass(\"ui-corner-right\", value === this.options.max).width(percentage.toFixed(0) + \"%\");\n\n\t\t\tthis.element.toggleClass(\"ui-progressbar-indeterminate\", this.indeterminate);\n\n\t\t\tif (this.indeterminate) {\n\t\t\t\tthis.element.removeAttr(\"aria-valuenow\");\n\t\t\t\tif (!this.overlayDiv) {\n\t\t\t\t\tthis.overlayDiv = $(\"<div class='ui-progressbar-overlay'></div>\").appendTo(this.valueDiv);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.element.attr({\n\t\t\t\t\t\"aria-valuemax\": this.options.max,\n\t\t\t\t\t\"aria-valuenow\": value\n\t\t\t\t});\n\t\t\t\tif (this.overlayDiv) {\n\t\t\t\t\tthis.overlayDiv.remove();\n\t\t\t\t\tthis.overlayDiv = null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.oldValue !== value) {\n\t\t\t\tthis.oldValue = value;\n\t\t\t\tthis._trigger(\"change\");\n\t\t\t}\n\t\t\tif (value === this.options.max) {\n\t\t\t\tthis._trigger(\"complete\");\n\t\t\t}\n\t\t}\n\t});\n\n\t/*!\n  * jQuery UI Selectable 1.11.4\n  * http://jqueryui.com\n  *\n  * Copyright jQuery Foundation and other contributors\n  * Released under the MIT license.\n  * http://jquery.org/license\n  *\n  * http://api.jqueryui.com/selectable/\n  */\n\n\tvar selectable = $.widget(\"ui.selectable\", $.ui.mouse, {\n\t\tversion: \"1.11.4\",\n\t\toptions: {\n\t\t\tappendTo: \"body\",\n\t\t\tautoRefresh: true,\n\t\t\tdistance: 0,\n\t\t\tfilter: \"*\",\n\t\t\ttolerance: \"touch\",\n\n\t\t\t// callbacks\n\t\t\tselected: null,\n\t\t\tselecting: null,\n\t\t\tstart: null,\n\t\t\tstop: null,\n\t\t\tunselected: null,\n\t\t\tunselecting: null\n\t\t},\n\t\t_create: function _create() {\n\t\t\tvar selectees,\n\t\t\t    that = this;\n\n\t\t\tthis.element.addClass(\"ui-selectable\");\n\n\t\t\tthis.dragged = false;\n\n\t\t\t// cache selectee children based on filter\n\t\t\tthis.refresh = function () {\n\t\t\t\tselectees = $(that.options.filter, that.element[0]);\n\t\t\t\tselectees.addClass(\"ui-selectee\");\n\t\t\t\tselectees.each(function () {\n\t\t\t\t\tvar $this = $(this),\n\t\t\t\t\t    pos = $this.offset();\n\t\t\t\t\t$.data(this, \"selectable-item\", {\n\t\t\t\t\t\telement: this,\n\t\t\t\t\t\t$element: $this,\n\t\t\t\t\t\tleft: pos.left,\n\t\t\t\t\t\ttop: pos.top,\n\t\t\t\t\t\tright: pos.left + $this.outerWidth(),\n\t\t\t\t\t\tbottom: pos.top + $this.outerHeight(),\n\t\t\t\t\t\tstartselected: false,\n\t\t\t\t\t\tselected: $this.hasClass(\"ui-selected\"),\n\t\t\t\t\t\tselecting: $this.hasClass(\"ui-selecting\"),\n\t\t\t\t\t\tunselecting: $this.hasClass(\"ui-unselecting\")\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t};\n\t\t\tthis.refresh();\n\n\t\t\tthis.selectees = selectees.addClass(\"ui-selectee\");\n\n\t\t\tthis._mouseInit();\n\n\t\t\tthis.helper = $(\"<div class='ui-selectable-helper'></div>\");\n\t\t},\n\n\t\t_destroy: function _destroy() {\n\t\t\tthis.selectees.removeClass(\"ui-selectee\").removeData(\"selectable-item\");\n\t\t\tthis.element.removeClass(\"ui-selectable ui-selectable-disabled\");\n\t\t\tthis._mouseDestroy();\n\t\t},\n\n\t\t_mouseStart: function _mouseStart(event) {\n\t\t\tvar that = this,\n\t\t\t    options = this.options;\n\n\t\t\tthis.opos = [event.pageX, event.pageY];\n\n\t\t\tif (this.options.disabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.selectees = $(options.filter, this.element[0]);\n\n\t\t\tthis._trigger(\"start\", event);\n\n\t\t\t$(options.appendTo).append(this.helper);\n\t\t\t// position helper (lasso)\n\t\t\tthis.helper.css({\n\t\t\t\t\"left\": event.pageX,\n\t\t\t\t\"top\": event.pageY,\n\t\t\t\t\"width\": 0,\n\t\t\t\t\"height\": 0\n\t\t\t});\n\n\t\t\tif (options.autoRefresh) {\n\t\t\t\tthis.refresh();\n\t\t\t}\n\n\t\t\tthis.selectees.filter(\".ui-selected\").each(function () {\n\t\t\t\tvar selectee = $.data(this, \"selectable-item\");\n\t\t\t\tselectee.startselected = true;\n\t\t\t\tif (!event.metaKey && !event.ctrlKey) {\n\t\t\t\t\tselectee.$element.removeClass(\"ui-selected\");\n\t\t\t\t\tselectee.selected = false;\n\t\t\t\t\tselectee.$element.addClass(\"ui-unselecting\");\n\t\t\t\t\tselectee.unselecting = true;\n\t\t\t\t\t// selectable UNSELECTING callback\n\t\t\t\t\tthat._trigger(\"unselecting\", event, {\n\t\t\t\t\t\tunselecting: selectee.element\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t$(event.target).parents().addBack().each(function () {\n\t\t\t\tvar doSelect,\n\t\t\t\t    selectee = $.data(this, \"selectable-item\");\n\t\t\t\tif (selectee) {\n\t\t\t\t\tdoSelect = !event.metaKey && !event.ctrlKey || !selectee.$element.hasClass(\"ui-selected\");\n\t\t\t\t\tselectee.$element.removeClass(doSelect ? \"ui-unselecting\" : \"ui-selected\").addClass(doSelect ? \"ui-selecting\" : \"ui-unselecting\");\n\t\t\t\t\tselectee.unselecting = !doSelect;\n\t\t\t\t\tselectee.selecting = doSelect;\n\t\t\t\t\tselectee.selected = doSelect;\n\t\t\t\t\t// selectable (UN)SELECTING callback\n\t\t\t\t\tif (doSelect) {\n\t\t\t\t\t\tthat._trigger(\"selecting\", event, {\n\t\t\t\t\t\t\tselecting: selectee.element\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthat._trigger(\"unselecting\", event, {\n\t\t\t\t\t\t\tunselecting: selectee.element\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\t_mouseDrag: function _mouseDrag(event) {\n\n\t\t\tthis.dragged = true;\n\n\t\t\tif (this.options.disabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar tmp,\n\t\t\t    that = this,\n\t\t\t    options = this.options,\n\t\t\t    x1 = this.opos[0],\n\t\t\t    y1 = this.opos[1],\n\t\t\t    x2 = event.pageX,\n\t\t\t    y2 = event.pageY;\n\n\t\t\tif (x1 > x2) {\n\t\t\t\ttmp = x2;x2 = x1;x1 = tmp;\n\t\t\t}\n\t\t\tif (y1 > y2) {\n\t\t\t\ttmp = y2;y2 = y1;y1 = tmp;\n\t\t\t}\n\t\t\tthis.helper.css({ left: x1, top: y1, width: x2 - x1, height: y2 - y1 });\n\n\t\t\tthis.selectees.each(function () {\n\t\t\t\tvar selectee = $.data(this, \"selectable-item\"),\n\t\t\t\t    hit = false;\n\n\t\t\t\t//prevent helper from being selected if appendTo: selectable\n\t\t\t\tif (!selectee || selectee.element === that.element[0]) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (options.tolerance === \"touch\") {\n\t\t\t\t\thit = !(selectee.left > x2 || selectee.right < x1 || selectee.top > y2 || selectee.bottom < y1);\n\t\t\t\t} else if (options.tolerance === \"fit\") {\n\t\t\t\t\thit = selectee.left > x1 && selectee.right < x2 && selectee.top > y1 && selectee.bottom < y2;\n\t\t\t\t}\n\n\t\t\t\tif (hit) {\n\t\t\t\t\t// SELECT\n\t\t\t\t\tif (selectee.selected) {\n\t\t\t\t\t\tselectee.$element.removeClass(\"ui-selected\");\n\t\t\t\t\t\tselectee.selected = false;\n\t\t\t\t\t}\n\t\t\t\t\tif (selectee.unselecting) {\n\t\t\t\t\t\tselectee.$element.removeClass(\"ui-unselecting\");\n\t\t\t\t\t\tselectee.unselecting = false;\n\t\t\t\t\t}\n\t\t\t\t\tif (!selectee.selecting) {\n\t\t\t\t\t\tselectee.$element.addClass(\"ui-selecting\");\n\t\t\t\t\t\tselectee.selecting = true;\n\t\t\t\t\t\t// selectable SELECTING callback\n\t\t\t\t\t\tthat._trigger(\"selecting\", event, {\n\t\t\t\t\t\t\tselecting: selectee.element\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// UNSELECT\n\t\t\t\t\tif (selectee.selecting) {\n\t\t\t\t\t\tif ((event.metaKey || event.ctrlKey) && selectee.startselected) {\n\t\t\t\t\t\t\tselectee.$element.removeClass(\"ui-selecting\");\n\t\t\t\t\t\t\tselectee.selecting = false;\n\t\t\t\t\t\t\tselectee.$element.addClass(\"ui-selected\");\n\t\t\t\t\t\t\tselectee.selected = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tselectee.$element.removeClass(\"ui-selecting\");\n\t\t\t\t\t\t\tselectee.selecting = false;\n\t\t\t\t\t\t\tif (selectee.startselected) {\n\t\t\t\t\t\t\t\tselectee.$element.addClass(\"ui-unselecting\");\n\t\t\t\t\t\t\t\tselectee.unselecting = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// selectable UNSELECTING callback\n\t\t\t\t\t\t\tthat._trigger(\"unselecting\", event, {\n\t\t\t\t\t\t\t\tunselecting: selectee.element\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (selectee.selected) {\n\t\t\t\t\t\tif (!event.metaKey && !event.ctrlKey && !selectee.startselected) {\n\t\t\t\t\t\t\tselectee.$element.removeClass(\"ui-selected\");\n\t\t\t\t\t\t\tselectee.selected = false;\n\n\t\t\t\t\t\t\tselectee.$element.addClass(\"ui-unselecting\");\n\t\t\t\t\t\t\tselectee.unselecting = true;\n\t\t\t\t\t\t\t// selectable UNSELECTING callback\n\t\t\t\t\t\t\tthat._trigger(\"unselecting\", event, {\n\t\t\t\t\t\t\t\tunselecting: selectee.element\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn false;\n\t\t},\n\n\t\t_mouseStop: function _mouseStop(event) {\n\t\t\tvar that = this;\n\n\t\t\tthis.dragged = false;\n\n\t\t\t$(\".ui-unselecting\", this.element[0]).each(function () {\n\t\t\t\tvar selectee = $.data(this, \"selectable-item\");\n\t\t\t\tselectee.$element.removeClass(\"ui-unselecting\");\n\t\t\t\tselectee.unselecting = false;\n\t\t\t\tselectee.startselected = false;\n\t\t\t\tthat._trigger(\"unselected\", event, {\n\t\t\t\t\tunselected: selectee.element\n\t\t\t\t});\n\t\t\t});\n\t\t\t$(\".ui-selecting\", this.element[0]).each(function () {\n\t\t\t\tvar selectee = $.data(this, \"selectable-item\");\n\t\t\t\tselectee.$element.removeClass(\"ui-selecting\").addClass(\"ui-selected\");\n\t\t\t\tselectee.selecting = false;\n\t\t\t\tselectee.selected = true;\n\t\t\t\tselectee.startselected = true;\n\t\t\t\tthat._trigger(\"selected\", event, {\n\t\t\t\t\tselected: selectee.element\n\t\t\t\t});\n\t\t\t});\n\t\t\tthis._trigger(\"stop\", event);\n\n\t\t\tthis.helper.remove();\n\n\t\t\treturn false;\n\t\t}\n\n\t});\n\n\t/*!\n  * jQuery UI Selectmenu 1.11.4\n  * http://jqueryui.com\n  *\n  * Copyright jQuery Foundation and other contributors\n  * Released under the MIT license.\n  * http://jquery.org/license\n  *\n  * http://api.jqueryui.com/selectmenu\n  */\n\n\tvar selectmenu = $.widget(\"ui.selectmenu\", {\n\t\tversion: \"1.11.4\",\n\t\tdefaultElement: \"<select>\",\n\t\toptions: {\n\t\t\tappendTo: null,\n\t\t\tdisabled: null,\n\t\t\ticons: {\n\t\t\t\tbutton: \"ui-icon-triangle-1-s\"\n\t\t\t},\n\t\t\tposition: {\n\t\t\t\tmy: \"left top\",\n\t\t\t\tat: \"left bottom\",\n\t\t\t\tcollision: \"none\"\n\t\t\t},\n\t\t\twidth: null,\n\n\t\t\t// callbacks\n\t\t\tchange: null,\n\t\t\tclose: null,\n\t\t\tfocus: null,\n\t\t\topen: null,\n\t\t\tselect: null\n\t\t},\n\n\t\t_create: function _create() {\n\t\t\tvar selectmenuId = this.element.uniqueId().attr(\"id\");\n\t\t\tthis.ids = {\n\t\t\t\telement: selectmenuId,\n\t\t\t\tbutton: selectmenuId + \"-button\",\n\t\t\t\tmenu: selectmenuId + \"-menu\"\n\t\t\t};\n\n\t\t\tthis._drawButton();\n\t\t\tthis._drawMenu();\n\n\t\t\tif (this.options.disabled) {\n\t\t\t\tthis.disable();\n\t\t\t}\n\t\t},\n\n\t\t_drawButton: function _drawButton() {\n\t\t\tvar that = this;\n\n\t\t\t// Associate existing label with the new button\n\t\t\tthis.label = $(\"label[for='\" + this.ids.element + \"']\").attr(\"for\", this.ids.button);\n\t\t\tthis._on(this.label, {\n\t\t\t\tclick: function click(event) {\n\t\t\t\t\tthis.button.focus();\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Hide original select element\n\t\t\tthis.element.hide();\n\n\t\t\t// Create button\n\t\t\tthis.button = $(\"<span>\", {\n\t\t\t\t\"class\": \"ui-selectmenu-button ui-widget ui-state-default ui-corner-all\",\n\t\t\t\ttabindex: this.options.disabled ? -1 : 0,\n\t\t\t\tid: this.ids.button,\n\t\t\t\trole: \"combobox\",\n\t\t\t\t\"aria-expanded\": \"false\",\n\t\t\t\t\"aria-autocomplete\": \"list\",\n\t\t\t\t\"aria-owns\": this.ids.menu,\n\t\t\t\t\"aria-haspopup\": \"true\"\n\t\t\t}).insertAfter(this.element);\n\n\t\t\t$(\"<span>\", {\n\t\t\t\t\"class\": \"ui-icon \" + this.options.icons.button\n\t\t\t}).prependTo(this.button);\n\n\t\t\tthis.buttonText = $(\"<span>\", {\n\t\t\t\t\"class\": \"ui-selectmenu-text\"\n\t\t\t}).appendTo(this.button);\n\n\t\t\tthis._setText(this.buttonText, this.element.find(\"option:selected\").text());\n\t\t\tthis._resizeButton();\n\n\t\t\tthis._on(this.button, this._buttonEvents);\n\t\t\tthis.button.one(\"focusin\", function () {\n\n\t\t\t\t// Delay rendering the menu items until the button receives focus.\n\t\t\t\t// The menu may have already been rendered via a programmatic open.\n\t\t\t\tif (!that.menuItems) {\n\t\t\t\t\tthat._refreshMenu();\n\t\t\t\t}\n\t\t\t});\n\t\t\tthis._hoverable(this.button);\n\t\t\tthis._focusable(this.button);\n\t\t},\n\n\t\t_drawMenu: function _drawMenu() {\n\t\t\tvar that = this;\n\n\t\t\t// Create menu\n\t\t\tthis.menu = $(\"<ul>\", {\n\t\t\t\t\"aria-hidden\": \"true\",\n\t\t\t\t\"aria-labelledby\": this.ids.button,\n\t\t\t\tid: this.ids.menu\n\t\t\t});\n\n\t\t\t// Wrap menu\n\t\t\tthis.menuWrap = $(\"<div>\", {\n\t\t\t\t\"class\": \"ui-selectmenu-menu ui-front\"\n\t\t\t}).append(this.menu).appendTo(this._appendTo());\n\n\t\t\t// Initialize menu widget\n\t\t\tthis.menuInstance = this.menu.menu({\n\t\t\t\trole: \"listbox\",\n\t\t\t\tselect: function select(event, ui) {\n\t\t\t\t\tevent.preventDefault();\n\n\t\t\t\t\t// support: IE8\n\t\t\t\t\t// If the item was selected via a click, the text selection\n\t\t\t\t\t// will be destroyed in IE\n\t\t\t\t\tthat._setSelection();\n\n\t\t\t\t\tthat._select(ui.item.data(\"ui-selectmenu-item\"), event);\n\t\t\t\t},\n\t\t\t\tfocus: function focus(event, ui) {\n\t\t\t\t\tvar item = ui.item.data(\"ui-selectmenu-item\");\n\n\t\t\t\t\t// Prevent inital focus from firing and check if its a newly focused item\n\t\t\t\t\tif (that.focusIndex != null && item.index !== that.focusIndex) {\n\t\t\t\t\t\tthat._trigger(\"focus\", event, { item: item });\n\t\t\t\t\t\tif (!that.isOpen) {\n\t\t\t\t\t\t\tthat._select(item, event);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthat.focusIndex = item.index;\n\n\t\t\t\t\tthat.button.attr(\"aria-activedescendant\", that.menuItems.eq(item.index).attr(\"id\"));\n\t\t\t\t}\n\t\t\t}).menu(\"instance\");\n\n\t\t\t// Adjust menu styles to dropdown\n\t\t\tthis.menu.addClass(\"ui-corner-bottom\").removeClass(\"ui-corner-all\");\n\n\t\t\t// Don't close the menu on mouseleave\n\t\t\tthis.menuInstance._off(this.menu, \"mouseleave\");\n\n\t\t\t// Cancel the menu's collapseAll on document click\n\t\t\tthis.menuInstance._closeOnDocumentClick = function () {\n\t\t\t\treturn false;\n\t\t\t};\n\n\t\t\t// Selects often contain empty items, but never contain dividers\n\t\t\tthis.menuInstance._isDivider = function () {\n\t\t\t\treturn false;\n\t\t\t};\n\t\t},\n\n\t\trefresh: function refresh() {\n\t\t\tthis._refreshMenu();\n\t\t\tthis._setText(this.buttonText, this._getSelectedItem().text());\n\t\t\tif (!this.options.width) {\n\t\t\t\tthis._resizeButton();\n\t\t\t}\n\t\t},\n\n\t\t_refreshMenu: function _refreshMenu() {\n\t\t\tthis.menu.empty();\n\n\t\t\tvar item,\n\t\t\t    options = this.element.find(\"option\");\n\n\t\t\tif (!options.length) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._parseOptions(options);\n\t\t\tthis._renderMenu(this.menu, this.items);\n\n\t\t\tthis.menuInstance.refresh();\n\t\t\tthis.menuItems = this.menu.find(\"li\").not(\".ui-selectmenu-optgroup\");\n\n\t\t\titem = this._getSelectedItem();\n\n\t\t\t// Update the menu to have the correct item focused\n\t\t\tthis.menuInstance.focus(null, item);\n\t\t\tthis._setAria(item.data(\"ui-selectmenu-item\"));\n\n\t\t\t// Set disabled state\n\t\t\tthis._setOption(\"disabled\", this.element.prop(\"disabled\"));\n\t\t},\n\n\t\topen: function open(event) {\n\t\t\tif (this.options.disabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If this is the first time the menu is being opened, render the items\n\t\t\tif (!this.menuItems) {\n\t\t\t\tthis._refreshMenu();\n\t\t\t} else {\n\n\t\t\t\t// Menu clears focus on close, reset focus to selected item\n\t\t\t\tthis.menu.find(\".ui-state-focus\").removeClass(\"ui-state-focus\");\n\t\t\t\tthis.menuInstance.focus(null, this._getSelectedItem());\n\t\t\t}\n\n\t\t\tthis.isOpen = true;\n\t\t\tthis._toggleAttr();\n\t\t\tthis._resizeMenu();\n\t\t\tthis._position();\n\n\t\t\tthis._on(this.document, this._documentClick);\n\n\t\t\tthis._trigger(\"open\", event);\n\t\t},\n\n\t\t_position: function _position() {\n\t\t\tthis.menuWrap.position($.extend({ of: this.button }, this.options.position));\n\t\t},\n\n\t\tclose: function close(event) {\n\t\t\tif (!this.isOpen) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.isOpen = false;\n\t\t\tthis._toggleAttr();\n\n\t\t\tthis.range = null;\n\t\t\tthis._off(this.document);\n\n\t\t\tthis._trigger(\"close\", event);\n\t\t},\n\n\t\twidget: function widget() {\n\t\t\treturn this.button;\n\t\t},\n\n\t\tmenuWidget: function menuWidget() {\n\t\t\treturn this.menu;\n\t\t},\n\n\t\t_renderMenu: function _renderMenu(ul, items) {\n\t\t\tvar that = this,\n\t\t\t    currentOptgroup = \"\";\n\n\t\t\t$.each(items, function (index, item) {\n\t\t\t\tif (item.optgroup !== currentOptgroup) {\n\t\t\t\t\t$(\"<li>\", {\n\t\t\t\t\t\t\"class\": \"ui-selectmenu-optgroup ui-menu-divider\" + (item.element.parent(\"optgroup\").prop(\"disabled\") ? \" ui-state-disabled\" : \"\"),\n\t\t\t\t\t\ttext: item.optgroup\n\t\t\t\t\t}).appendTo(ul);\n\n\t\t\t\t\tcurrentOptgroup = item.optgroup;\n\t\t\t\t}\n\n\t\t\t\tthat._renderItemData(ul, item);\n\t\t\t});\n\t\t},\n\n\t\t_renderItemData: function _renderItemData(ul, item) {\n\t\t\treturn this._renderItem(ul, item).data(\"ui-selectmenu-item\", item);\n\t\t},\n\n\t\t_renderItem: function _renderItem(ul, item) {\n\t\t\tvar li = $(\"<li>\");\n\n\t\t\tif (item.disabled) {\n\t\t\t\tli.addClass(\"ui-state-disabled\");\n\t\t\t}\n\t\t\tthis._setText(li, item.label);\n\n\t\t\treturn li.appendTo(ul);\n\t\t},\n\n\t\t_setText: function _setText(element, value) {\n\t\t\tif (value) {\n\t\t\t\telement.text(value);\n\t\t\t} else {\n\t\t\t\telement.html(\"&#160;\");\n\t\t\t}\n\t\t},\n\n\t\t_move: function _move(direction, event) {\n\t\t\tvar item,\n\t\t\t    next,\n\t\t\t    filter = \".ui-menu-item\";\n\n\t\t\tif (this.isOpen) {\n\t\t\t\titem = this.menuItems.eq(this.focusIndex);\n\t\t\t} else {\n\t\t\t\titem = this.menuItems.eq(this.element[0].selectedIndex);\n\t\t\t\tfilter += \":not(.ui-state-disabled)\";\n\t\t\t}\n\n\t\t\tif (direction === \"first\" || direction === \"last\") {\n\t\t\t\tnext = item[direction === \"first\" ? \"prevAll\" : \"nextAll\"](filter).eq(-1);\n\t\t\t} else {\n\t\t\t\tnext = item[direction + \"All\"](filter).eq(0);\n\t\t\t}\n\n\t\t\tif (next.length) {\n\t\t\t\tthis.menuInstance.focus(event, next);\n\t\t\t}\n\t\t},\n\n\t\t_getSelectedItem: function _getSelectedItem() {\n\t\t\treturn this.menuItems.eq(this.element[0].selectedIndex);\n\t\t},\n\n\t\t_toggle: function _toggle(event) {\n\t\t\tthis[this.isOpen ? \"close\" : \"open\"](event);\n\t\t},\n\n\t\t_setSelection: function _setSelection() {\n\t\t\tvar selection;\n\n\t\t\tif (!this.range) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (window.getSelection) {\n\t\t\t\tselection = window.getSelection();\n\t\t\t\tselection.removeAllRanges();\n\t\t\t\tselection.addRange(this.range);\n\n\t\t\t\t// support: IE8\n\t\t\t} else {\n\t\t\t\tthis.range.select();\n\t\t\t}\n\n\t\t\t// support: IE\n\t\t\t// Setting the text selection kills the button focus in IE, but\n\t\t\t// restoring the focus doesn't kill the selection.\n\t\t\tthis.button.focus();\n\t\t},\n\n\t\t_documentClick: {\n\t\t\tmousedown: function mousedown(event) {\n\t\t\t\tif (!this.isOpen) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (!$(event.target).closest(\".ui-selectmenu-menu, #\" + this.ids.button).length) {\n\t\t\t\t\tthis.close(event);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t_buttonEvents: {\n\n\t\t\t// Prevent text selection from being reset when interacting with the selectmenu (#10144)\n\t\t\tmousedown: function mousedown() {\n\t\t\t\tvar selection;\n\n\t\t\t\tif (window.getSelection) {\n\t\t\t\t\tselection = window.getSelection();\n\t\t\t\t\tif (selection.rangeCount) {\n\t\t\t\t\t\tthis.range = selection.getRangeAt(0);\n\t\t\t\t\t}\n\n\t\t\t\t\t// support: IE8\n\t\t\t\t} else {\n\t\t\t\t\tthis.range = document.selection.createRange();\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tclick: function click(event) {\n\t\t\t\tthis._setSelection();\n\t\t\t\tthis._toggle(event);\n\t\t\t},\n\n\t\t\tkeydown: function keydown(event) {\n\t\t\t\tvar preventDefault = true;\n\t\t\t\tswitch (event.keyCode) {\n\t\t\t\t\tcase $.ui.keyCode.TAB:\n\t\t\t\t\tcase $.ui.keyCode.ESCAPE:\n\t\t\t\t\t\tthis.close(event);\n\t\t\t\t\t\tpreventDefault = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase $.ui.keyCode.ENTER:\n\t\t\t\t\t\tif (this.isOpen) {\n\t\t\t\t\t\t\tthis._selectFocusedItem(event);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase $.ui.keyCode.UP:\n\t\t\t\t\t\tif (event.altKey) {\n\t\t\t\t\t\t\tthis._toggle(event);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis._move(\"prev\", event);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase $.ui.keyCode.DOWN:\n\t\t\t\t\t\tif (event.altKey) {\n\t\t\t\t\t\t\tthis._toggle(event);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis._move(\"next\", event);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase $.ui.keyCode.SPACE:\n\t\t\t\t\t\tif (this.isOpen) {\n\t\t\t\t\t\t\tthis._selectFocusedItem(event);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis._toggle(event);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase $.ui.keyCode.LEFT:\n\t\t\t\t\t\tthis._move(\"prev\", event);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase $.ui.keyCode.RIGHT:\n\t\t\t\t\t\tthis._move(\"next\", event);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase $.ui.keyCode.HOME:\n\t\t\t\t\tcase $.ui.keyCode.PAGE_UP:\n\t\t\t\t\t\tthis._move(\"first\", event);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase $.ui.keyCode.END:\n\t\t\t\t\tcase $.ui.keyCode.PAGE_DOWN:\n\t\t\t\t\t\tthis._move(\"last\", event);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthis.menu.trigger(event);\n\t\t\t\t\t\tpreventDefault = false;\n\t\t\t\t}\n\n\t\t\t\tif (preventDefault) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t_selectFocusedItem: function _selectFocusedItem(event) {\n\t\t\tvar item = this.menuItems.eq(this.focusIndex);\n\t\t\tif (!item.hasClass(\"ui-state-disabled\")) {\n\t\t\t\tthis._select(item.data(\"ui-selectmenu-item\"), event);\n\t\t\t}\n\t\t},\n\n\t\t_select: function _select(item, event) {\n\t\t\tvar oldIndex = this.element[0].selectedIndex;\n\n\t\t\t// Change native select element\n\t\t\tthis.element[0].selectedIndex = item.index;\n\t\t\tthis._setText(this.buttonText, item.label);\n\t\t\tthis._setAria(item);\n\t\t\tthis._trigger(\"select\", event, { item: item });\n\n\t\t\tif (item.index !== oldIndex) {\n\t\t\t\tthis._trigger(\"change\", event, { item: item });\n\t\t\t}\n\n\t\t\tthis.close(event);\n\t\t},\n\n\t\t_setAria: function _setAria(item) {\n\t\t\tvar id = this.menuItems.eq(item.index).attr(\"id\");\n\n\t\t\tthis.button.attr({\n\t\t\t\t\"aria-labelledby\": id,\n\t\t\t\t\"aria-activedescendant\": id\n\t\t\t});\n\t\t\tthis.menu.attr(\"aria-activedescendant\", id);\n\t\t},\n\n\t\t_setOption: function _setOption(key, value) {\n\t\t\tif (key === \"icons\") {\n\t\t\t\tthis.button.find(\"span.ui-icon\").removeClass(this.options.icons.button).addClass(value.button);\n\t\t\t}\n\n\t\t\tthis._super(key, value);\n\n\t\t\tif (key === \"appendTo\") {\n\t\t\t\tthis.menuWrap.appendTo(this._appendTo());\n\t\t\t}\n\n\t\t\tif (key === \"disabled\") {\n\t\t\t\tthis.menuInstance.option(\"disabled\", value);\n\t\t\t\tthis.button.toggleClass(\"ui-state-disabled\", value).attr(\"aria-disabled\", value);\n\n\t\t\t\tthis.element.prop(\"disabled\", value);\n\t\t\t\tif (value) {\n\t\t\t\t\tthis.button.attr(\"tabindex\", -1);\n\t\t\t\t\tthis.close();\n\t\t\t\t} else {\n\t\t\t\t\tthis.button.attr(\"tabindex\", 0);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (key === \"width\") {\n\t\t\t\tthis._resizeButton();\n\t\t\t}\n\t\t},\n\n\t\t_appendTo: function _appendTo() {\n\t\t\tvar element = this.options.appendTo;\n\n\t\t\tif (element) {\n\t\t\t\telement = element.jquery || element.nodeType ? $(element) : this.document.find(element).eq(0);\n\t\t\t}\n\n\t\t\tif (!element || !element[0]) {\n\t\t\t\telement = this.element.closest(\".ui-front\");\n\t\t\t}\n\n\t\t\tif (!element.length) {\n\t\t\t\telement = this.document[0].body;\n\t\t\t}\n\n\t\t\treturn element;\n\t\t},\n\n\t\t_toggleAttr: function _toggleAttr() {\n\t\t\tthis.button.toggleClass(\"ui-corner-top\", this.isOpen).toggleClass(\"ui-corner-all\", !this.isOpen).attr(\"aria-expanded\", this.isOpen);\n\t\t\tthis.menuWrap.toggleClass(\"ui-selectmenu-open\", this.isOpen);\n\t\t\tthis.menu.attr(\"aria-hidden\", !this.isOpen);\n\t\t},\n\n\t\t_resizeButton: function _resizeButton() {\n\t\t\tvar width = this.options.width;\n\n\t\t\tif (!width) {\n\t\t\t\twidth = this.element.show().outerWidth();\n\t\t\t\tthis.element.hide();\n\t\t\t}\n\n\t\t\tthis.button.outerWidth(width);\n\t\t},\n\n\t\t_resizeMenu: function _resizeMenu() {\n\t\t\tthis.menu.outerWidth(Math.max(this.button.outerWidth(),\n\n\t\t\t// support: IE10\n\t\t\t// IE10 wraps long text (possibly a rounding bug)\n\t\t\t// so we add 1px to avoid the wrapping\n\t\t\tthis.menu.width(\"\").outerWidth() + 1));\n\t\t},\n\n\t\t_getCreateOptions: function _getCreateOptions() {\n\t\t\treturn { disabled: this.element.prop(\"disabled\") };\n\t\t},\n\n\t\t_parseOptions: function _parseOptions(options) {\n\t\t\tvar data = [];\n\t\t\toptions.each(function (index, item) {\n\t\t\t\tvar option = $(item),\n\t\t\t\t    optgroup = option.parent(\"optgroup\");\n\t\t\t\tdata.push({\n\t\t\t\t\telement: option,\n\t\t\t\t\tindex: index,\n\t\t\t\t\tvalue: option.val(),\n\t\t\t\t\tlabel: option.text(),\n\t\t\t\t\toptgroup: optgroup.attr(\"label\") || \"\",\n\t\t\t\t\tdisabled: optgroup.prop(\"disabled\") || option.prop(\"disabled\")\n\t\t\t\t});\n\t\t\t});\n\t\t\tthis.items = data;\n\t\t},\n\n\t\t_destroy: function _destroy() {\n\t\t\tthis.menuWrap.remove();\n\t\t\tthis.button.remove();\n\t\t\tthis.element.show();\n\t\t\tthis.element.removeUniqueId();\n\t\t\tthis.label.attr(\"for\", this.ids.element);\n\t\t}\n\t});\n\n\t/*!\n  * jQuery UI Slider 1.11.4\n  * http://jqueryui.com\n  *\n  * Copyright jQuery Foundation and other contributors\n  * Released under the MIT license.\n  * http://jquery.org/license\n  *\n  * http://api.jqueryui.com/slider/\n  */\n\n\tvar slider = $.widget(\"ui.slider\", $.ui.mouse, {\n\t\tversion: \"1.11.4\",\n\t\twidgetEventPrefix: \"slide\",\n\n\t\toptions: {\n\t\t\tanimate: false,\n\t\t\tdistance: 0,\n\t\t\tmax: 100,\n\t\t\tmin: 0,\n\t\t\torientation: \"horizontal\",\n\t\t\trange: false,\n\t\t\tstep: 1,\n\t\t\tvalue: 0,\n\t\t\tvalues: null,\n\n\t\t\t// callbacks\n\t\t\tchange: null,\n\t\t\tslide: null,\n\t\t\tstart: null,\n\t\t\tstop: null\n\t\t},\n\n\t\t// number of pages in a slider\n\t\t// (how many times can you page up/down to go through the whole range)\n\t\tnumPages: 5,\n\n\t\t_create: function _create() {\n\t\t\tthis._keySliding = false;\n\t\t\tthis._mouseSliding = false;\n\t\t\tthis._animateOff = true;\n\t\t\tthis._handleIndex = null;\n\t\t\tthis._detectOrientation();\n\t\t\tthis._mouseInit();\n\t\t\tthis._calculateNewMax();\n\n\t\t\tthis.element.addClass(\"ui-slider\" + \" ui-slider-\" + this.orientation + \" ui-widget\" + \" ui-widget-content\" + \" ui-corner-all\");\n\n\t\t\tthis._refresh();\n\t\t\tthis._setOption(\"disabled\", this.options.disabled);\n\n\t\t\tthis._animateOff = false;\n\t\t},\n\n\t\t_refresh: function _refresh() {\n\t\t\tthis._createRange();\n\t\t\tthis._createHandles();\n\t\t\tthis._setupEvents();\n\t\t\tthis._refreshValue();\n\t\t},\n\n\t\t_createHandles: function _createHandles() {\n\t\t\tvar i,\n\t\t\t    handleCount,\n\t\t\t    options = this.options,\n\t\t\t    existingHandles = this.element.find(\".ui-slider-handle\").addClass(\"ui-state-default ui-corner-all\"),\n\t\t\t    handle = \"<span class='ui-slider-handle ui-state-default ui-corner-all' tabindex='0'></span>\",\n\t\t\t    handles = [];\n\n\t\t\thandleCount = options.values && options.values.length || 1;\n\n\t\t\tif (existingHandles.length > handleCount) {\n\t\t\t\texistingHandles.slice(handleCount).remove();\n\t\t\t\texistingHandles = existingHandles.slice(0, handleCount);\n\t\t\t}\n\n\t\t\tfor (i = existingHandles.length; i < handleCount; i++) {\n\t\t\t\thandles.push(handle);\n\t\t\t}\n\n\t\t\tthis.handles = existingHandles.add($(handles.join(\"\")).appendTo(this.element));\n\n\t\t\tthis.handle = this.handles.eq(0);\n\n\t\t\tthis.handles.each(function (i) {\n\t\t\t\t$(this).data(\"ui-slider-handle-index\", i);\n\t\t\t});\n\t\t},\n\n\t\t_createRange: function _createRange() {\n\t\t\tvar options = this.options,\n\t\t\t    classes = \"\";\n\n\t\t\tif (options.range) {\n\t\t\t\tif (options.range === true) {\n\t\t\t\t\tif (!options.values) {\n\t\t\t\t\t\toptions.values = [this._valueMin(), this._valueMin()];\n\t\t\t\t\t} else if (options.values.length && options.values.length !== 2) {\n\t\t\t\t\t\toptions.values = [options.values[0], options.values[0]];\n\t\t\t\t\t} else if ($.isArray(options.values)) {\n\t\t\t\t\t\toptions.values = options.values.slice(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!this.range || !this.range.length) {\n\t\t\t\t\tthis.range = $(\"<div></div>\").appendTo(this.element);\n\n\t\t\t\t\tclasses = \"ui-slider-range\" +\n\t\t\t\t\t// note: this isn't the most fittingly semantic framework class for this element,\n\t\t\t\t\t// but worked best visually with a variety of themes\n\t\t\t\t\t\" ui-widget-header ui-corner-all\";\n\t\t\t\t} else {\n\t\t\t\t\tthis.range.removeClass(\"ui-slider-range-min ui-slider-range-max\")\n\t\t\t\t\t// Handle range switching from true to min/max\n\t\t\t\t\t.css({\n\t\t\t\t\t\t\"left\": \"\",\n\t\t\t\t\t\t\"bottom\": \"\"\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tthis.range.addClass(classes + (options.range === \"min\" || options.range === \"max\" ? \" ui-slider-range-\" + options.range : \"\"));\n\t\t\t} else {\n\t\t\t\tif (this.range) {\n\t\t\t\t\tthis.range.remove();\n\t\t\t\t}\n\t\t\t\tthis.range = null;\n\t\t\t}\n\t\t},\n\n\t\t_setupEvents: function _setupEvents() {\n\t\t\tthis._off(this.handles);\n\t\t\tthis._on(this.handles, this._handleEvents);\n\t\t\tthis._hoverable(this.handles);\n\t\t\tthis._focusable(this.handles);\n\t\t},\n\n\t\t_destroy: function _destroy() {\n\t\t\tthis.handles.remove();\n\t\t\tif (this.range) {\n\t\t\t\tthis.range.remove();\n\t\t\t}\n\n\t\t\tthis.element.removeClass(\"ui-slider\" + \" ui-slider-horizontal\" + \" ui-slider-vertical\" + \" ui-widget\" + \" ui-widget-content\" + \" ui-corner-all\");\n\n\t\t\tthis._mouseDestroy();\n\t\t},\n\n\t\t_mouseCapture: function _mouseCapture(event) {\n\t\t\tvar position,\n\t\t\t    normValue,\n\t\t\t    distance,\n\t\t\t    closestHandle,\n\t\t\t    index,\n\t\t\t    allowed,\n\t\t\t    offset,\n\t\t\t    mouseOverHandle,\n\t\t\t    that = this,\n\t\t\t    o = this.options;\n\n\t\t\tif (o.disabled) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tthis.elementSize = {\n\t\t\t\twidth: this.element.outerWidth(),\n\t\t\t\theight: this.element.outerHeight()\n\t\t\t};\n\t\t\tthis.elementOffset = this.element.offset();\n\n\t\t\tposition = { x: event.pageX, y: event.pageY };\n\t\t\tnormValue = this._normValueFromMouse(position);\n\t\t\tdistance = this._valueMax() - this._valueMin() + 1;\n\t\t\tthis.handles.each(function (i) {\n\t\t\t\tvar thisDistance = Math.abs(normValue - that.values(i));\n\t\t\t\tif (distance > thisDistance || distance === thisDistance && (i === that._lastChangedValue || that.values(i) === o.min)) {\n\t\t\t\t\tdistance = thisDistance;\n\t\t\t\t\tclosestHandle = $(this);\n\t\t\t\t\tindex = i;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tallowed = this._start(event, index);\n\t\t\tif (allowed === false) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tthis._mouseSliding = true;\n\n\t\t\tthis._handleIndex = index;\n\n\t\t\tclosestHandle.addClass(\"ui-state-active\").focus();\n\n\t\t\toffset = closestHandle.offset();\n\t\t\tmouseOverHandle = !$(event.target).parents().addBack().is(\".ui-slider-handle\");\n\t\t\tthis._clickOffset = mouseOverHandle ? { left: 0, top: 0 } : {\n\t\t\t\tleft: event.pageX - offset.left - closestHandle.width() / 2,\n\t\t\t\ttop: event.pageY - offset.top - closestHandle.height() / 2 - (parseInt(closestHandle.css(\"borderTopWidth\"), 10) || 0) - (parseInt(closestHandle.css(\"borderBottomWidth\"), 10) || 0) + (parseInt(closestHandle.css(\"marginTop\"), 10) || 0)\n\t\t\t};\n\n\t\t\tif (!this.handles.hasClass(\"ui-state-hover\")) {\n\t\t\t\tthis._slide(event, index, normValue);\n\t\t\t}\n\t\t\tthis._animateOff = true;\n\t\t\treturn true;\n\t\t},\n\n\t\t_mouseStart: function _mouseStart() {\n\t\t\treturn true;\n\t\t},\n\n\t\t_mouseDrag: function _mouseDrag(event) {\n\t\t\tvar position = { x: event.pageX, y: event.pageY },\n\t\t\t    normValue = this._normValueFromMouse(position);\n\n\t\t\tthis._slide(event, this._handleIndex, normValue);\n\n\t\t\treturn false;\n\t\t},\n\n\t\t_mouseStop: function _mouseStop(event) {\n\t\t\tthis.handles.removeClass(\"ui-state-active\");\n\t\t\tthis._mouseSliding = false;\n\n\t\t\tthis._stop(event, this._handleIndex);\n\t\t\tthis._change(event, this._handleIndex);\n\n\t\t\tthis._handleIndex = null;\n\t\t\tthis._clickOffset = null;\n\t\t\tthis._animateOff = false;\n\n\t\t\treturn false;\n\t\t},\n\n\t\t_detectOrientation: function _detectOrientation() {\n\t\t\tthis.orientation = this.options.orientation === \"vertical\" ? \"vertical\" : \"horizontal\";\n\t\t},\n\n\t\t_normValueFromMouse: function _normValueFromMouse(position) {\n\t\t\tvar pixelTotal, pixelMouse, percentMouse, valueTotal, valueMouse;\n\n\t\t\tif (this.orientation === \"horizontal\") {\n\t\t\t\tpixelTotal = this.elementSize.width;\n\t\t\t\tpixelMouse = position.x - this.elementOffset.left - (this._clickOffset ? this._clickOffset.left : 0);\n\t\t\t} else {\n\t\t\t\tpixelTotal = this.elementSize.height;\n\t\t\t\tpixelMouse = position.y - this.elementOffset.top - (this._clickOffset ? this._clickOffset.top : 0);\n\t\t\t}\n\n\t\t\tpercentMouse = pixelMouse / pixelTotal;\n\t\t\tif (percentMouse > 1) {\n\t\t\t\tpercentMouse = 1;\n\t\t\t}\n\t\t\tif (percentMouse < 0) {\n\t\t\t\tpercentMouse = 0;\n\t\t\t}\n\t\t\tif (this.orientation === \"vertical\") {\n\t\t\t\tpercentMouse = 1 - percentMouse;\n\t\t\t}\n\n\t\t\tvalueTotal = this._valueMax() - this._valueMin();\n\t\t\tvalueMouse = this._valueMin() + percentMouse * valueTotal;\n\n\t\t\treturn this._trimAlignValue(valueMouse);\n\t\t},\n\n\t\t_start: function _start(event, index) {\n\t\t\tvar uiHash = {\n\t\t\t\thandle: this.handles[index],\n\t\t\t\tvalue: this.value()\n\t\t\t};\n\t\t\tif (this.options.values && this.options.values.length) {\n\t\t\t\tuiHash.value = this.values(index);\n\t\t\t\tuiHash.values = this.values();\n\t\t\t}\n\t\t\treturn this._trigger(\"start\", event, uiHash);\n\t\t},\n\n\t\t_slide: function _slide(event, index, newVal) {\n\t\t\tvar otherVal, newValues, allowed;\n\n\t\t\tif (this.options.values && this.options.values.length) {\n\t\t\t\totherVal = this.values(index ? 0 : 1);\n\n\t\t\t\tif (this.options.values.length === 2 && this.options.range === true && (index === 0 && newVal > otherVal || index === 1 && newVal < otherVal)) {\n\t\t\t\t\tnewVal = otherVal;\n\t\t\t\t}\n\n\t\t\t\tif (newVal !== this.values(index)) {\n\t\t\t\t\tnewValues = this.values();\n\t\t\t\t\tnewValues[index] = newVal;\n\t\t\t\t\t// A slide can be canceled by returning false from the slide callback\n\t\t\t\t\tallowed = this._trigger(\"slide\", event, {\n\t\t\t\t\t\thandle: this.handles[index],\n\t\t\t\t\t\tvalue: newVal,\n\t\t\t\t\t\tvalues: newValues\n\t\t\t\t\t});\n\t\t\t\t\totherVal = this.values(index ? 0 : 1);\n\t\t\t\t\tif (allowed !== false) {\n\t\t\t\t\t\tthis.values(index, newVal);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (newVal !== this.value()) {\n\t\t\t\t\t// A slide can be canceled by returning false from the slide callback\n\t\t\t\t\tallowed = this._trigger(\"slide\", event, {\n\t\t\t\t\t\thandle: this.handles[index],\n\t\t\t\t\t\tvalue: newVal\n\t\t\t\t\t});\n\t\t\t\t\tif (allowed !== false) {\n\t\t\t\t\t\tthis.value(newVal);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t_stop: function _stop(event, index) {\n\t\t\tvar uiHash = {\n\t\t\t\thandle: this.handles[index],\n\t\t\t\tvalue: this.value()\n\t\t\t};\n\t\t\tif (this.options.values && this.options.values.length) {\n\t\t\t\tuiHash.value = this.values(index);\n\t\t\t\tuiHash.values = this.values();\n\t\t\t}\n\n\t\t\tthis._trigger(\"stop\", event, uiHash);\n\t\t},\n\n\t\t_change: function _change(event, index) {\n\t\t\tif (!this._keySliding && !this._mouseSliding) {\n\t\t\t\tvar uiHash = {\n\t\t\t\t\thandle: this.handles[index],\n\t\t\t\t\tvalue: this.value()\n\t\t\t\t};\n\t\t\t\tif (this.options.values && this.options.values.length) {\n\t\t\t\t\tuiHash.value = this.values(index);\n\t\t\t\t\tuiHash.values = this.values();\n\t\t\t\t}\n\n\t\t\t\t//store the last changed value index for reference when handles overlap\n\t\t\t\tthis._lastChangedValue = index;\n\n\t\t\t\tthis._trigger(\"change\", event, uiHash);\n\t\t\t}\n\t\t},\n\n\t\tvalue: function value(newValue) {\n\t\t\tif (arguments.length) {\n\t\t\t\tthis.options.value = this._trimAlignValue(newValue);\n\t\t\t\tthis._refreshValue();\n\t\t\t\tthis._change(null, 0);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\treturn this._value();\n\t\t},\n\n\t\tvalues: function values(index, newValue) {\n\t\t\tvar vals, newValues, i;\n\n\t\t\tif (arguments.length > 1) {\n\t\t\t\tthis.options.values[index] = this._trimAlignValue(newValue);\n\t\t\t\tthis._refreshValue();\n\t\t\t\tthis._change(null, index);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (arguments.length) {\n\t\t\t\tif ($.isArray(arguments[0])) {\n\t\t\t\t\tvals = this.options.values;\n\t\t\t\t\tnewValues = arguments[0];\n\t\t\t\t\tfor (i = 0; i < vals.length; i += 1) {\n\t\t\t\t\t\tvals[i] = this._trimAlignValue(newValues[i]);\n\t\t\t\t\t\tthis._change(null, i);\n\t\t\t\t\t}\n\t\t\t\t\tthis._refreshValue();\n\t\t\t\t} else {\n\t\t\t\t\tif (this.options.values && this.options.values.length) {\n\t\t\t\t\t\treturn this._values(index);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn this.value();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn this._values();\n\t\t\t}\n\t\t},\n\n\t\t_setOption: function _setOption(key, value) {\n\t\t\tvar i,\n\t\t\t    valsLength = 0;\n\n\t\t\tif (key === \"range\" && this.options.range === true) {\n\t\t\t\tif (value === \"min\") {\n\t\t\t\t\tthis.options.value = this._values(0);\n\t\t\t\t\tthis.options.values = null;\n\t\t\t\t} else if (value === \"max\") {\n\t\t\t\t\tthis.options.value = this._values(this.options.values.length - 1);\n\t\t\t\t\tthis.options.values = null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ($.isArray(this.options.values)) {\n\t\t\t\tvalsLength = this.options.values.length;\n\t\t\t}\n\n\t\t\tif (key === \"disabled\") {\n\t\t\t\tthis.element.toggleClass(\"ui-state-disabled\", !!value);\n\t\t\t}\n\n\t\t\tthis._super(key, value);\n\n\t\t\tswitch (key) {\n\t\t\t\tcase \"orientation\":\n\t\t\t\t\tthis._detectOrientation();\n\t\t\t\t\tthis.element.removeClass(\"ui-slider-horizontal ui-slider-vertical\").addClass(\"ui-slider-\" + this.orientation);\n\t\t\t\t\tthis._refreshValue();\n\n\t\t\t\t\t// Reset positioning from previous orientation\n\t\t\t\t\tthis.handles.css(value === \"horizontal\" ? \"bottom\" : \"left\", \"\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"value\":\n\t\t\t\t\tthis._animateOff = true;\n\t\t\t\t\tthis._refreshValue();\n\t\t\t\t\tthis._change(null, 0);\n\t\t\t\t\tthis._animateOff = false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"values\":\n\t\t\t\t\tthis._animateOff = true;\n\t\t\t\t\tthis._refreshValue();\n\t\t\t\t\tfor (i = 0; i < valsLength; i += 1) {\n\t\t\t\t\t\tthis._change(null, i);\n\t\t\t\t\t}\n\t\t\t\t\tthis._animateOff = false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"step\":\n\t\t\t\tcase \"min\":\n\t\t\t\tcase \"max\":\n\t\t\t\t\tthis._animateOff = true;\n\t\t\t\t\tthis._calculateNewMax();\n\t\t\t\t\tthis._refreshValue();\n\t\t\t\t\tthis._animateOff = false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"range\":\n\t\t\t\t\tthis._animateOff = true;\n\t\t\t\t\tthis._refresh();\n\t\t\t\t\tthis._animateOff = false;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t},\n\n\t\t//internal value getter\n\t\t// _value() returns value trimmed by min and max, aligned by step\n\t\t_value: function _value() {\n\t\t\tvar val = this.options.value;\n\t\t\tval = this._trimAlignValue(val);\n\n\t\t\treturn val;\n\t\t},\n\n\t\t//internal values getter\n\t\t// _values() returns array of values trimmed by min and max, aligned by step\n\t\t// _values( index ) returns single value trimmed by min and max, aligned by step\n\t\t_values: function _values(index) {\n\t\t\tvar val, vals, i;\n\n\t\t\tif (arguments.length) {\n\t\t\t\tval = this.options.values[index];\n\t\t\t\tval = this._trimAlignValue(val);\n\n\t\t\t\treturn val;\n\t\t\t} else if (this.options.values && this.options.values.length) {\n\t\t\t\t// .slice() creates a copy of the array\n\t\t\t\t// this copy gets trimmed by min and max and then returned\n\t\t\t\tvals = this.options.values.slice();\n\t\t\t\tfor (i = 0; i < vals.length; i += 1) {\n\t\t\t\t\tvals[i] = this._trimAlignValue(vals[i]);\n\t\t\t\t}\n\n\t\t\t\treturn vals;\n\t\t\t} else {\n\t\t\t\treturn [];\n\t\t\t}\n\t\t},\n\n\t\t// returns the step-aligned value that val is closest to, between (inclusive) min and max\n\t\t_trimAlignValue: function _trimAlignValue(val) {\n\t\t\tif (val <= this._valueMin()) {\n\t\t\t\treturn this._valueMin();\n\t\t\t}\n\t\t\tif (val >= this._valueMax()) {\n\t\t\t\treturn this._valueMax();\n\t\t\t}\n\t\t\tvar step = this.options.step > 0 ? this.options.step : 1,\n\t\t\t    valModStep = (val - this._valueMin()) % step,\n\t\t\t    alignValue = val - valModStep;\n\n\t\t\tif (Math.abs(valModStep) * 2 >= step) {\n\t\t\t\talignValue += valModStep > 0 ? step : -step;\n\t\t\t}\n\n\t\t\t// Since JavaScript has problems with large floats, round\n\t\t\t// the final value to 5 digits after the decimal point (see #4124)\n\t\t\treturn parseFloat(alignValue.toFixed(5));\n\t\t},\n\n\t\t_calculateNewMax: function _calculateNewMax() {\n\t\t\tvar max = this.options.max,\n\t\t\t    min = this._valueMin(),\n\t\t\t    step = this.options.step,\n\t\t\t    aboveMin = Math.floor(+(max - min).toFixed(this._precision()) / step) * step;\n\t\t\tmax = aboveMin + min;\n\t\t\tthis.max = parseFloat(max.toFixed(this._precision()));\n\t\t},\n\n\t\t_precision: function _precision() {\n\t\t\tvar precision = this._precisionOf(this.options.step);\n\t\t\tif (this.options.min !== null) {\n\t\t\t\tprecision = Math.max(precision, this._precisionOf(this.options.min));\n\t\t\t}\n\t\t\treturn precision;\n\t\t},\n\n\t\t_precisionOf: function _precisionOf(num) {\n\t\t\tvar str = num.toString(),\n\t\t\t    decimal = str.indexOf(\".\");\n\t\t\treturn decimal === -1 ? 0 : str.length - decimal - 1;\n\t\t},\n\n\t\t_valueMin: function _valueMin() {\n\t\t\treturn this.options.min;\n\t\t},\n\n\t\t_valueMax: function _valueMax() {\n\t\t\treturn this.max;\n\t\t},\n\n\t\t_refreshValue: function _refreshValue() {\n\t\t\tvar lastValPercent,\n\t\t\t    valPercent,\n\t\t\t    value,\n\t\t\t    valueMin,\n\t\t\t    valueMax,\n\t\t\t    oRange = this.options.range,\n\t\t\t    o = this.options,\n\t\t\t    that = this,\n\t\t\t    animate = !this._animateOff ? o.animate : false,\n\t\t\t    _set = {};\n\n\t\t\tif (this.options.values && this.options.values.length) {\n\t\t\t\tthis.handles.each(function (i) {\n\t\t\t\t\tvalPercent = (that.values(i) - that._valueMin()) / (that._valueMax() - that._valueMin()) * 100;\n\t\t\t\t\t_set[that.orientation === \"horizontal\" ? \"left\" : \"bottom\"] = valPercent + \"%\";\n\t\t\t\t\t$(this).stop(1, 1)[animate ? \"animate\" : \"css\"](_set, o.animate);\n\t\t\t\t\tif (that.options.range === true) {\n\t\t\t\t\t\tif (that.orientation === \"horizontal\") {\n\t\t\t\t\t\t\tif (i === 0) {\n\t\t\t\t\t\t\t\tthat.range.stop(1, 1)[animate ? \"animate\" : \"css\"]({ left: valPercent + \"%\" }, o.animate);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i === 1) {\n\t\t\t\t\t\t\t\tthat.range[animate ? \"animate\" : \"css\"]({ width: valPercent - lastValPercent + \"%\" }, { queue: false, duration: o.animate });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (i === 0) {\n\t\t\t\t\t\t\t\tthat.range.stop(1, 1)[animate ? \"animate\" : \"css\"]({ bottom: valPercent + \"%\" }, o.animate);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i === 1) {\n\t\t\t\t\t\t\t\tthat.range[animate ? \"animate\" : \"css\"]({ height: valPercent - lastValPercent + \"%\" }, { queue: false, duration: o.animate });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlastValPercent = valPercent;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tvalue = this.value();\n\t\t\t\tvalueMin = this._valueMin();\n\t\t\t\tvalueMax = this._valueMax();\n\t\t\t\tvalPercent = valueMax !== valueMin ? (value - valueMin) / (valueMax - valueMin) * 100 : 0;\n\t\t\t\t_set[this.orientation === \"horizontal\" ? \"left\" : \"bottom\"] = valPercent + \"%\";\n\t\t\t\tthis.handle.stop(1, 1)[animate ? \"animate\" : \"css\"](_set, o.animate);\n\n\t\t\t\tif (oRange === \"min\" && this.orientation === \"horizontal\") {\n\t\t\t\t\tthis.range.stop(1, 1)[animate ? \"animate\" : \"css\"]({ width: valPercent + \"%\" }, o.animate);\n\t\t\t\t}\n\t\t\t\tif (oRange === \"max\" && this.orientation === \"horizontal\") {\n\t\t\t\t\tthis.range[animate ? \"animate\" : \"css\"]({ width: 100 - valPercent + \"%\" }, { queue: false, duration: o.animate });\n\t\t\t\t}\n\t\t\t\tif (oRange === \"min\" && this.orientation === \"vertical\") {\n\t\t\t\t\tthis.range.stop(1, 1)[animate ? \"animate\" : \"css\"]({ height: valPercent + \"%\" }, o.animate);\n\t\t\t\t}\n\t\t\t\tif (oRange === \"max\" && this.orientation === \"vertical\") {\n\t\t\t\t\tthis.range[animate ? \"animate\" : \"css\"]({ height: 100 - valPercent + \"%\" }, { queue: false, duration: o.animate });\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t_handleEvents: {\n\t\t\tkeydown: function keydown(event) {\n\t\t\t\tvar allowed,\n\t\t\t\t    curVal,\n\t\t\t\t    newVal,\n\t\t\t\t    step,\n\t\t\t\t    index = $(event.target).data(\"ui-slider-handle-index\");\n\n\t\t\t\tswitch (event.keyCode) {\n\t\t\t\t\tcase $.ui.keyCode.HOME:\n\t\t\t\t\tcase $.ui.keyCode.END:\n\t\t\t\t\tcase $.ui.keyCode.PAGE_UP:\n\t\t\t\t\tcase $.ui.keyCode.PAGE_DOWN:\n\t\t\t\t\tcase $.ui.keyCode.UP:\n\t\t\t\t\tcase $.ui.keyCode.RIGHT:\n\t\t\t\t\tcase $.ui.keyCode.DOWN:\n\t\t\t\t\tcase $.ui.keyCode.LEFT:\n\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\tif (!this._keySliding) {\n\t\t\t\t\t\t\tthis._keySliding = true;\n\t\t\t\t\t\t\t$(event.target).addClass(\"ui-state-active\");\n\t\t\t\t\t\t\tallowed = this._start(event, index);\n\t\t\t\t\t\t\tif (allowed === false) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tstep = this.options.step;\n\t\t\t\tif (this.options.values && this.options.values.length) {\n\t\t\t\t\tcurVal = newVal = this.values(index);\n\t\t\t\t} else {\n\t\t\t\t\tcurVal = newVal = this.value();\n\t\t\t\t}\n\n\t\t\t\tswitch (event.keyCode) {\n\t\t\t\t\tcase $.ui.keyCode.HOME:\n\t\t\t\t\t\tnewVal = this._valueMin();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase $.ui.keyCode.END:\n\t\t\t\t\t\tnewVal = this._valueMax();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase $.ui.keyCode.PAGE_UP:\n\t\t\t\t\t\tnewVal = this._trimAlignValue(curVal + (this._valueMax() - this._valueMin()) / this.numPages);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase $.ui.keyCode.PAGE_DOWN:\n\t\t\t\t\t\tnewVal = this._trimAlignValue(curVal - (this._valueMax() - this._valueMin()) / this.numPages);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase $.ui.keyCode.UP:\n\t\t\t\t\tcase $.ui.keyCode.RIGHT:\n\t\t\t\t\t\tif (curVal === this._valueMax()) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnewVal = this._trimAlignValue(curVal + step);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase $.ui.keyCode.DOWN:\n\t\t\t\t\tcase $.ui.keyCode.LEFT:\n\t\t\t\t\t\tif (curVal === this._valueMin()) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnewVal = this._trimAlignValue(curVal - step);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tthis._slide(event, index, newVal);\n\t\t\t},\n\t\t\tkeyup: function keyup(event) {\n\t\t\t\tvar index = $(event.target).data(\"ui-slider-handle-index\");\n\n\t\t\t\tif (this._keySliding) {\n\t\t\t\t\tthis._keySliding = false;\n\t\t\t\t\tthis._stop(event, index);\n\t\t\t\t\tthis._change(event, index);\n\t\t\t\t\t$(event.target).removeClass(\"ui-state-active\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\t/*!\n  * jQuery UI Sortable 1.11.4\n  * http://jqueryui.com\n  *\n  * Copyright jQuery Foundation and other contributors\n  * Released under the MIT license.\n  * http://jquery.org/license\n  *\n  * http://api.jqueryui.com/sortable/\n  */\n\n\tvar sortable = $.widget(\"ui.sortable\", $.ui.mouse, {\n\t\tversion: \"1.11.4\",\n\t\twidgetEventPrefix: \"sort\",\n\t\tready: false,\n\t\toptions: {\n\t\t\tappendTo: \"parent\",\n\t\t\taxis: false,\n\t\t\tconnectWith: false,\n\t\t\tcontainment: false,\n\t\t\tcursor: \"auto\",\n\t\t\tcursorAt: false,\n\t\t\tdropOnEmpty: true,\n\t\t\tforcePlaceholderSize: false,\n\t\t\tforceHelperSize: false,\n\t\t\tgrid: false,\n\t\t\thandle: false,\n\t\t\thelper: \"original\",\n\t\t\titems: \"> *\",\n\t\t\topacity: false,\n\t\t\tplaceholder: false,\n\t\t\trevert: false,\n\t\t\tscroll: true,\n\t\t\tscrollSensitivity: 20,\n\t\t\tscrollSpeed: 20,\n\t\t\tscope: \"default\",\n\t\t\ttolerance: \"intersect\",\n\t\t\tzIndex: 1000,\n\n\t\t\t// callbacks\n\t\t\tactivate: null,\n\t\t\tbeforeStop: null,\n\t\t\tchange: null,\n\t\t\tdeactivate: null,\n\t\t\tout: null,\n\t\t\tover: null,\n\t\t\treceive: null,\n\t\t\tremove: null,\n\t\t\tsort: null,\n\t\t\tstart: null,\n\t\t\tstop: null,\n\t\t\tupdate: null\n\t\t},\n\n\t\t_isOverAxis: function _isOverAxis(x, reference, size) {\n\t\t\treturn x >= reference && x < reference + size;\n\t\t},\n\n\t\t_isFloating: function _isFloating(item) {\n\t\t\treturn (/left|right/.test(item.css(\"float\")) || /inline|table-cell/.test(item.css(\"display\"))\n\t\t\t);\n\t\t},\n\n\t\t_create: function _create() {\n\t\t\tthis.containerCache = {};\n\t\t\tthis.element.addClass(\"ui-sortable\");\n\n\t\t\t//Get the items\n\t\t\tthis.refresh();\n\n\t\t\t//Let's determine the parent's offset\n\t\t\tthis.offset = this.element.offset();\n\n\t\t\t//Initialize mouse events for interaction\n\t\t\tthis._mouseInit();\n\n\t\t\tthis._setHandleClassName();\n\n\t\t\t//We're ready to go\n\t\t\tthis.ready = true;\n\t\t},\n\n\t\t_setOption: function _setOption(key, value) {\n\t\t\tthis._super(key, value);\n\n\t\t\tif (key === \"handle\") {\n\t\t\t\tthis._setHandleClassName();\n\t\t\t}\n\t\t},\n\n\t\t_setHandleClassName: function _setHandleClassName() {\n\t\t\tthis.element.find(\".ui-sortable-handle\").removeClass(\"ui-sortable-handle\");\n\t\t\t$.each(this.items, function () {\n\t\t\t\t(this.instance.options.handle ? this.item.find(this.instance.options.handle) : this.item).addClass(\"ui-sortable-handle\");\n\t\t\t});\n\t\t},\n\n\t\t_destroy: function _destroy() {\n\t\t\tthis.element.removeClass(\"ui-sortable ui-sortable-disabled\").find(\".ui-sortable-handle\").removeClass(\"ui-sortable-handle\");\n\t\t\tthis._mouseDestroy();\n\n\t\t\tfor (var i = this.items.length - 1; i >= 0; i--) {\n\t\t\t\tthis.items[i].item.removeData(this.widgetName + \"-item\");\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\t_mouseCapture: function _mouseCapture(event, overrideHandle) {\n\t\t\tvar currentItem = null,\n\t\t\t    validHandle = false,\n\t\t\t    that = this;\n\n\t\t\tif (this.reverting) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (this.options.disabled || this.options.type === \"static\") {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t//We have to refresh the items data once first\n\t\t\tthis._refreshItems(event);\n\n\t\t\t//Find out if the clicked node (or one of its parents) is a actual item in this.items\n\t\t\t$(event.target).parents().each(function () {\n\t\t\t\tif ($.data(this, that.widgetName + \"-item\") === that) {\n\t\t\t\t\tcurrentItem = $(this);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t});\n\t\t\tif ($.data(event.target, that.widgetName + \"-item\") === that) {\n\t\t\t\tcurrentItem = $(event.target);\n\t\t\t}\n\n\t\t\tif (!currentItem) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (this.options.handle && !overrideHandle) {\n\t\t\t\t$(this.options.handle, currentItem).find(\"*\").addBack().each(function () {\n\t\t\t\t\tif (this === event.target) {\n\t\t\t\t\t\tvalidHandle = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tif (!validHandle) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.currentItem = currentItem;\n\t\t\tthis._removeCurrentsFromItems();\n\t\t\treturn true;\n\t\t},\n\n\t\t_mouseStart: function _mouseStart(event, overrideHandle, noActivation) {\n\n\t\t\tvar i,\n\t\t\t    body,\n\t\t\t    o = this.options;\n\n\t\t\tthis.currentContainer = this;\n\n\t\t\t//We only need to call refreshPositions, because the refreshItems call has been moved to mouseCapture\n\t\t\tthis.refreshPositions();\n\n\t\t\t//Create and append the visible helper\n\t\t\tthis.helper = this._createHelper(event);\n\n\t\t\t//Cache the helper size\n\t\t\tthis._cacheHelperProportions();\n\n\t\t\t/*\n    * - Position generation -\n    * This block generates everything position related - it's the core of draggables.\n    */\n\n\t\t\t//Cache the margins of the original element\n\t\t\tthis._cacheMargins();\n\n\t\t\t//Get the next scrolling parent\n\t\t\tthis.scrollParent = this.helper.scrollParent();\n\n\t\t\t//The element's absolute position on the page minus margins\n\t\t\tthis.offset = this.currentItem.offset();\n\t\t\tthis.offset = {\n\t\t\t\ttop: this.offset.top - this.margins.top,\n\t\t\t\tleft: this.offset.left - this.margins.left\n\t\t\t};\n\n\t\t\t$.extend(this.offset, {\n\t\t\t\tclick: { //Where the click happened, relative to the element\n\t\t\t\t\tleft: event.pageX - this.offset.left,\n\t\t\t\t\ttop: event.pageY - this.offset.top\n\t\t\t\t},\n\t\t\t\tparent: this._getParentOffset(),\n\t\t\t\trelative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper\n\t\t\t});\n\n\t\t\t// Only after we got the offset, we can change the helper's position to absolute\n\t\t\t// TODO: Still need to figure out a way to make relative sorting possible\n\t\t\tthis.helper.css(\"position\", \"absolute\");\n\t\t\tthis.cssPosition = this.helper.css(\"position\");\n\n\t\t\t//Generate the original position\n\t\t\tthis.originalPosition = this._generatePosition(event);\n\t\t\tthis.originalPageX = event.pageX;\n\t\t\tthis.originalPageY = event.pageY;\n\n\t\t\t//Adjust the mouse offset relative to the helper if \"cursorAt\" is supplied\n\t\t\to.cursorAt && this._adjustOffsetFromHelper(o.cursorAt);\n\n\t\t\t//Cache the former DOM position\n\t\t\tthis.domPosition = { prev: this.currentItem.prev()[0], parent: this.currentItem.parent()[0] };\n\n\t\t\t//If the helper is not the original, hide the original so it's not playing any role during the drag, won't cause anything bad this way\n\t\t\tif (this.helper[0] !== this.currentItem[0]) {\n\t\t\t\tthis.currentItem.hide();\n\t\t\t}\n\n\t\t\t//Create the placeholder\n\t\t\tthis._createPlaceholder();\n\n\t\t\t//Set a containment if given in the options\n\t\t\tif (o.containment) {\n\t\t\t\tthis._setContainment();\n\t\t\t}\n\n\t\t\tif (o.cursor && o.cursor !== \"auto\") {\n\t\t\t\t// cursor option\n\t\t\t\tbody = this.document.find(\"body\");\n\n\t\t\t\t// support: IE\n\t\t\t\tthis.storedCursor = body.css(\"cursor\");\n\t\t\t\tbody.css(\"cursor\", o.cursor);\n\n\t\t\t\tthis.storedStylesheet = $(\"<style>*{ cursor: \" + o.cursor + \" !important; }</style>\").appendTo(body);\n\t\t\t}\n\n\t\t\tif (o.opacity) {\n\t\t\t\t// opacity option\n\t\t\t\tif (this.helper.css(\"opacity\")) {\n\t\t\t\t\tthis._storedOpacity = this.helper.css(\"opacity\");\n\t\t\t\t}\n\t\t\t\tthis.helper.css(\"opacity\", o.opacity);\n\t\t\t}\n\n\t\t\tif (o.zIndex) {\n\t\t\t\t// zIndex option\n\t\t\t\tif (this.helper.css(\"zIndex\")) {\n\t\t\t\t\tthis._storedZIndex = this.helper.css(\"zIndex\");\n\t\t\t\t}\n\t\t\t\tthis.helper.css(\"zIndex\", o.zIndex);\n\t\t\t}\n\n\t\t\t//Prepare scrolling\n\t\t\tif (this.scrollParent[0] !== this.document[0] && this.scrollParent[0].tagName !== \"HTML\") {\n\t\t\t\tthis.overflowOffset = this.scrollParent.offset();\n\t\t\t}\n\n\t\t\t//Call callbacks\n\t\t\tthis._trigger(\"start\", event, this._uiHash());\n\n\t\t\t//Recache the helper size\n\t\t\tif (!this._preserveHelperProportions) {\n\t\t\t\tthis._cacheHelperProportions();\n\t\t\t}\n\n\t\t\t//Post \"activate\" events to possible containers\n\t\t\tif (!noActivation) {\n\t\t\t\tfor (i = this.containers.length - 1; i >= 0; i--) {\n\t\t\t\t\tthis.containers[i]._trigger(\"activate\", event, this._uiHash(this));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//Prepare possible droppables\n\t\t\tif ($.ui.ddmanager) {\n\t\t\t\t$.ui.ddmanager.current = this;\n\t\t\t}\n\n\t\t\tif ($.ui.ddmanager && !o.dropBehaviour) {\n\t\t\t\t$.ui.ddmanager.prepareOffsets(this, event);\n\t\t\t}\n\n\t\t\tthis.dragging = true;\n\n\t\t\tthis.helper.addClass(\"ui-sortable-helper\");\n\t\t\tthis._mouseDrag(event); //Execute the drag once - this causes the helper not to be visible before getting its correct position\n\t\t\treturn true;\n\t\t},\n\n\t\t_mouseDrag: function _mouseDrag(event) {\n\t\t\tvar i,\n\t\t\t    item,\n\t\t\t    itemElement,\n\t\t\t    intersection,\n\t\t\t    o = this.options,\n\t\t\t    scrolled = false;\n\n\t\t\t//Compute the helpers position\n\t\t\tthis.position = this._generatePosition(event);\n\t\t\tthis.positionAbs = this._convertPositionTo(\"absolute\");\n\n\t\t\tif (!this.lastPositionAbs) {\n\t\t\t\tthis.lastPositionAbs = this.positionAbs;\n\t\t\t}\n\n\t\t\t//Do scrolling\n\t\t\tif (this.options.scroll) {\n\t\t\t\tif (this.scrollParent[0] !== this.document[0] && this.scrollParent[0].tagName !== \"HTML\") {\n\n\t\t\t\t\tif (this.overflowOffset.top + this.scrollParent[0].offsetHeight - event.pageY < o.scrollSensitivity) {\n\t\t\t\t\t\tthis.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed;\n\t\t\t\t\t} else if (event.pageY - this.overflowOffset.top < o.scrollSensitivity) {\n\t\t\t\t\t\tthis.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this.overflowOffset.left + this.scrollParent[0].offsetWidth - event.pageX < o.scrollSensitivity) {\n\t\t\t\t\t\tthis.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed;\n\t\t\t\t\t} else if (event.pageX - this.overflowOffset.left < o.scrollSensitivity) {\n\t\t\t\t\t\tthis.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\n\t\t\t\t\tif (event.pageY - this.document.scrollTop() < o.scrollSensitivity) {\n\t\t\t\t\t\tscrolled = this.document.scrollTop(this.document.scrollTop() - o.scrollSpeed);\n\t\t\t\t\t} else if (this.window.height() - (event.pageY - this.document.scrollTop()) < o.scrollSensitivity) {\n\t\t\t\t\t\tscrolled = this.document.scrollTop(this.document.scrollTop() + o.scrollSpeed);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (event.pageX - this.document.scrollLeft() < o.scrollSensitivity) {\n\t\t\t\t\t\tscrolled = this.document.scrollLeft(this.document.scrollLeft() - o.scrollSpeed);\n\t\t\t\t\t} else if (this.window.width() - (event.pageX - this.document.scrollLeft()) < o.scrollSensitivity) {\n\t\t\t\t\t\tscrolled = this.document.scrollLeft(this.document.scrollLeft() + o.scrollSpeed);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {\n\t\t\t\t\t$.ui.ddmanager.prepareOffsets(this, event);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//Regenerate the absolute position used for position checks\n\t\t\tthis.positionAbs = this._convertPositionTo(\"absolute\");\n\n\t\t\t//Set the helper position\n\t\t\tif (!this.options.axis || this.options.axis !== \"y\") {\n\t\t\t\tthis.helper[0].style.left = this.position.left + \"px\";\n\t\t\t}\n\t\t\tif (!this.options.axis || this.options.axis !== \"x\") {\n\t\t\t\tthis.helper[0].style.top = this.position.top + \"px\";\n\t\t\t}\n\n\t\t\t//Rearrange\n\t\t\tfor (i = this.items.length - 1; i >= 0; i--) {\n\n\t\t\t\t//Cache variables and intersection, continue if no intersection\n\t\t\t\titem = this.items[i];\n\t\t\t\titemElement = item.item[0];\n\t\t\t\tintersection = this._intersectsWithPointer(item);\n\t\t\t\tif (!intersection) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Only put the placeholder inside the current Container, skip all\n\t\t\t\t// items from other containers. This works because when moving\n\t\t\t\t// an item from one container to another the\n\t\t\t\t// currentContainer is switched before the placeholder is moved.\n\t\t\t\t//\n\t\t\t\t// Without this, moving items in \"sub-sortables\" can cause\n\t\t\t\t// the placeholder to jitter between the outer and inner container.\n\t\t\t\tif (item.instance !== this.currentContainer) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// cannot intersect with itself\n\t\t\t\t// no useless actions that have been done before\n\t\t\t\t// no action if the item moved is the parent of the item checked\n\t\t\t\tif (itemElement !== this.currentItem[0] && this.placeholder[intersection === 1 ? \"next\" : \"prev\"]()[0] !== itemElement && !$.contains(this.placeholder[0], itemElement) && (this.options.type === \"semi-dynamic\" ? !$.contains(this.element[0], itemElement) : true)) {\n\n\t\t\t\t\tthis.direction = intersection === 1 ? \"down\" : \"up\";\n\n\t\t\t\t\tif (this.options.tolerance === \"pointer\" || this._intersectsWithSides(item)) {\n\t\t\t\t\t\tthis._rearrange(event, item);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._trigger(\"change\", event, this._uiHash());\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//Post events to containers\n\t\t\tthis._contactContainers(event);\n\n\t\t\t//Interconnect with droppables\n\t\t\tif ($.ui.ddmanager) {\n\t\t\t\t$.ui.ddmanager.drag(this, event);\n\t\t\t}\n\n\t\t\t//Call callbacks\n\t\t\tthis._trigger(\"sort\", event, this._uiHash());\n\n\t\t\tthis.lastPositionAbs = this.positionAbs;\n\t\t\treturn false;\n\t\t},\n\n\t\t_mouseStop: function _mouseStop(event, noPropagation) {\n\n\t\t\tif (!event) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t//If we are using droppables, inform the manager about the drop\n\t\t\tif ($.ui.ddmanager && !this.options.dropBehaviour) {\n\t\t\t\t$.ui.ddmanager.drop(this, event);\n\t\t\t}\n\n\t\t\tif (this.options.revert) {\n\t\t\t\tvar that = this,\n\t\t\t\t    cur = this.placeholder.offset(),\n\t\t\t\t    axis = this.options.axis,\n\t\t\t\t    animation = {};\n\n\t\t\t\tif (!axis || axis === \"x\") {\n\t\t\t\t\tanimation.left = cur.left - this.offset.parent.left - this.margins.left + (this.offsetParent[0] === this.document[0].body ? 0 : this.offsetParent[0].scrollLeft);\n\t\t\t\t}\n\t\t\t\tif (!axis || axis === \"y\") {\n\t\t\t\t\tanimation.top = cur.top - this.offset.parent.top - this.margins.top + (this.offsetParent[0] === this.document[0].body ? 0 : this.offsetParent[0].scrollTop);\n\t\t\t\t}\n\t\t\t\tthis.reverting = true;\n\t\t\t\t$(this.helper).animate(animation, parseInt(this.options.revert, 10) || 500, function () {\n\t\t\t\t\tthat._clear(event);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthis._clear(event, noPropagation);\n\t\t\t}\n\n\t\t\treturn false;\n\t\t},\n\n\t\tcancel: function cancel() {\n\n\t\t\tif (this.dragging) {\n\n\t\t\t\tthis._mouseUp({ target: null });\n\n\t\t\t\tif (this.options.helper === \"original\") {\n\t\t\t\t\tthis.currentItem.css(this._storedCSS).removeClass(\"ui-sortable-helper\");\n\t\t\t\t} else {\n\t\t\t\t\tthis.currentItem.show();\n\t\t\t\t}\n\n\t\t\t\t//Post deactivating events to containers\n\t\t\t\tfor (var i = this.containers.length - 1; i >= 0; i--) {\n\t\t\t\t\tthis.containers[i]._trigger(\"deactivate\", null, this._uiHash(this));\n\t\t\t\t\tif (this.containers[i].containerCache.over) {\n\t\t\t\t\t\tthis.containers[i]._trigger(\"out\", null, this._uiHash(this));\n\t\t\t\t\t\tthis.containers[i].containerCache.over = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.placeholder) {\n\t\t\t\t//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!\n\t\t\t\tif (this.placeholder[0].parentNode) {\n\t\t\t\t\tthis.placeholder[0].parentNode.removeChild(this.placeholder[0]);\n\t\t\t\t}\n\t\t\t\tif (this.options.helper !== \"original\" && this.helper && this.helper[0].parentNode) {\n\t\t\t\t\tthis.helper.remove();\n\t\t\t\t}\n\n\t\t\t\t$.extend(this, {\n\t\t\t\t\thelper: null,\n\t\t\t\t\tdragging: false,\n\t\t\t\t\treverting: false,\n\t\t\t\t\t_noFinalSort: null\n\t\t\t\t});\n\n\t\t\t\tif (this.domPosition.prev) {\n\t\t\t\t\t$(this.domPosition.prev).after(this.currentItem);\n\t\t\t\t} else {\n\t\t\t\t\t$(this.domPosition.parent).prepend(this.currentItem);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\tserialize: function serialize(o) {\n\n\t\t\tvar items = this._getItemsAsjQuery(o && o.connected),\n\t\t\t    str = [];\n\t\t\to = o || {};\n\n\t\t\t$(items).each(function () {\n\t\t\t\tvar res = ($(o.item || this).attr(o.attribute || \"id\") || \"\").match(o.expression || /(.+)[\\-=_](.+)/);\n\t\t\t\tif (res) {\n\t\t\t\t\tstr.push((o.key || res[1] + \"[]\") + \"=\" + (o.key && o.expression ? res[1] : res[2]));\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (!str.length && o.key) {\n\t\t\t\tstr.push(o.key + \"=\");\n\t\t\t}\n\n\t\t\treturn str.join(\"&\");\n\t\t},\n\n\t\ttoArray: function toArray(o) {\n\n\t\t\tvar items = this._getItemsAsjQuery(o && o.connected),\n\t\t\t    ret = [];\n\n\t\t\to = o || {};\n\n\t\t\titems.each(function () {\n\t\t\t\tret.push($(o.item || this).attr(o.attribute || \"id\") || \"\");\n\t\t\t});\n\t\t\treturn ret;\n\t\t},\n\n\t\t/* Be careful with the following core functions */\n\t\t_intersectsWith: function _intersectsWith(item) {\n\n\t\t\tvar x1 = this.positionAbs.left,\n\t\t\t    x2 = x1 + this.helperProportions.width,\n\t\t\t    y1 = this.positionAbs.top,\n\t\t\t    y2 = y1 + this.helperProportions.height,\n\t\t\t    l = item.left,\n\t\t\t    r = l + item.width,\n\t\t\t    t = item.top,\n\t\t\t    b = t + item.height,\n\t\t\t    dyClick = this.offset.click.top,\n\t\t\t    dxClick = this.offset.click.left,\n\t\t\t    isOverElementHeight = this.options.axis === \"x\" || y1 + dyClick > t && y1 + dyClick < b,\n\t\t\t    isOverElementWidth = this.options.axis === \"y\" || x1 + dxClick > l && x1 + dxClick < r,\n\t\t\t    isOverElement = isOverElementHeight && isOverElementWidth;\n\n\t\t\tif (this.options.tolerance === \"pointer\" || this.options.forcePointerForContainers || this.options.tolerance !== \"pointer\" && this.helperProportions[this.floating ? \"width\" : \"height\"] > item[this.floating ? \"width\" : \"height\"]) {\n\t\t\t\treturn isOverElement;\n\t\t\t} else {\n\n\t\t\t\treturn l < x1 + this.helperProportions.width / 2 && // Right Half\n\t\t\t\tx2 - this.helperProportions.width / 2 < r && // Left Half\n\t\t\t\tt < y1 + this.helperProportions.height / 2 && // Bottom Half\n\t\t\t\ty2 - this.helperProportions.height / 2 < b; // Top Half\n\t\t\t}\n\t\t},\n\n\t\t_intersectsWithPointer: function _intersectsWithPointer(item) {\n\n\t\t\tvar isOverElementHeight = this.options.axis === \"x\" || this._isOverAxis(this.positionAbs.top + this.offset.click.top, item.top, item.height),\n\t\t\t    isOverElementWidth = this.options.axis === \"y\" || this._isOverAxis(this.positionAbs.left + this.offset.click.left, item.left, item.width),\n\t\t\t    isOverElement = isOverElementHeight && isOverElementWidth,\n\t\t\t    verticalDirection = this._getDragVerticalDirection(),\n\t\t\t    horizontalDirection = this._getDragHorizontalDirection();\n\n\t\t\tif (!isOverElement) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn this.floating ? horizontalDirection && horizontalDirection === \"right\" || verticalDirection === \"down\" ? 2 : 1 : verticalDirection && (verticalDirection === \"down\" ? 2 : 1);\n\t\t},\n\n\t\t_intersectsWithSides: function _intersectsWithSides(item) {\n\n\t\t\tvar isOverBottomHalf = this._isOverAxis(this.positionAbs.top + this.offset.click.top, item.top + item.height / 2, item.height),\n\t\t\t    isOverRightHalf = this._isOverAxis(this.positionAbs.left + this.offset.click.left, item.left + item.width / 2, item.width),\n\t\t\t    verticalDirection = this._getDragVerticalDirection(),\n\t\t\t    horizontalDirection = this._getDragHorizontalDirection();\n\n\t\t\tif (this.floating && horizontalDirection) {\n\t\t\t\treturn horizontalDirection === \"right\" && isOverRightHalf || horizontalDirection === \"left\" && !isOverRightHalf;\n\t\t\t} else {\n\t\t\t\treturn verticalDirection && (verticalDirection === \"down\" && isOverBottomHalf || verticalDirection === \"up\" && !isOverBottomHalf);\n\t\t\t}\n\t\t},\n\n\t\t_getDragVerticalDirection: function _getDragVerticalDirection() {\n\t\t\tvar delta = this.positionAbs.top - this.lastPositionAbs.top;\n\t\t\treturn delta !== 0 && (delta > 0 ? \"down\" : \"up\");\n\t\t},\n\n\t\t_getDragHorizontalDirection: function _getDragHorizontalDirection() {\n\t\t\tvar delta = this.positionAbs.left - this.lastPositionAbs.left;\n\t\t\treturn delta !== 0 && (delta > 0 ? \"right\" : \"left\");\n\t\t},\n\n\t\trefresh: function refresh(event) {\n\t\t\tthis._refreshItems(event);\n\t\t\tthis._setHandleClassName();\n\t\t\tthis.refreshPositions();\n\t\t\treturn this;\n\t\t},\n\n\t\t_connectWith: function _connectWith() {\n\t\t\tvar options = this.options;\n\t\t\treturn options.connectWith.constructor === String ? [options.connectWith] : options.connectWith;\n\t\t},\n\n\t\t_getItemsAsjQuery: function _getItemsAsjQuery(connected) {\n\n\t\t\tvar i,\n\t\t\t    j,\n\t\t\t    cur,\n\t\t\t    inst,\n\t\t\t    items = [],\n\t\t\t    queries = [],\n\t\t\t    connectWith = this._connectWith();\n\n\t\t\tif (connectWith && connected) {\n\t\t\t\tfor (i = connectWith.length - 1; i >= 0; i--) {\n\t\t\t\t\tcur = $(connectWith[i], this.document[0]);\n\t\t\t\t\tfor (j = cur.length - 1; j >= 0; j--) {\n\t\t\t\t\t\tinst = $.data(cur[j], this.widgetFullName);\n\t\t\t\t\t\tif (inst && inst !== this && !inst.options.disabled) {\n\t\t\t\t\t\t\tqueries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element) : $(inst.options.items, inst.element).not(\".ui-sortable-helper\").not(\".ui-sortable-placeholder\"), inst]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tqueries.push([$.isFunction(this.options.items) ? this.options.items.call(this.element, null, { options: this.options, item: this.currentItem }) : $(this.options.items, this.element).not(\".ui-sortable-helper\").not(\".ui-sortable-placeholder\"), this]);\n\n\t\t\tfunction addItems() {\n\t\t\t\titems.push(this);\n\t\t\t}\n\t\t\tfor (i = queries.length - 1; i >= 0; i--) {\n\t\t\t\tqueries[i][0].each(addItems);\n\t\t\t}\n\n\t\t\treturn $(items);\n\t\t},\n\n\t\t_removeCurrentsFromItems: function _removeCurrentsFromItems() {\n\n\t\t\tvar list = this.currentItem.find(\":data(\" + this.widgetName + \"-item)\");\n\n\t\t\tthis.items = $.grep(this.items, function (item) {\n\t\t\t\tfor (var j = 0; j < list.length; j++) {\n\t\t\t\t\tif (list[j] === item.item[0]) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t});\n\t\t},\n\n\t\t_refreshItems: function _refreshItems(event) {\n\n\t\t\tthis.items = [];\n\t\t\tthis.containers = [this];\n\n\t\t\tvar i,\n\t\t\t    j,\n\t\t\t    cur,\n\t\t\t    inst,\n\t\t\t    targetData,\n\t\t\t    _queries,\n\t\t\t    item,\n\t\t\t    queriesLength,\n\t\t\t    items = this.items,\n\t\t\t    queries = [[$.isFunction(this.options.items) ? this.options.items.call(this.element[0], event, { item: this.currentItem }) : $(this.options.items, this.element), this]],\n\t\t\t    connectWith = this._connectWith();\n\n\t\t\tif (connectWith && this.ready) {\n\t\t\t\t//Shouldn't be run the first time through due to massive slow-down\n\t\t\t\tfor (i = connectWith.length - 1; i >= 0; i--) {\n\t\t\t\t\tcur = $(connectWith[i], this.document[0]);\n\t\t\t\t\tfor (j = cur.length - 1; j >= 0; j--) {\n\t\t\t\t\t\tinst = $.data(cur[j], this.widgetFullName);\n\t\t\t\t\t\tif (inst && inst !== this && !inst.options.disabled) {\n\t\t\t\t\t\t\tqueries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element[0], event, { item: this.currentItem }) : $(inst.options.items, inst.element), inst]);\n\t\t\t\t\t\t\tthis.containers.push(inst);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (i = queries.length - 1; i >= 0; i--) {\n\t\t\t\ttargetData = queries[i][1];\n\t\t\t\t_queries = queries[i][0];\n\n\t\t\t\tfor (j = 0, queriesLength = _queries.length; j < queriesLength; j++) {\n\t\t\t\t\titem = $(_queries[j]);\n\n\t\t\t\t\titem.data(this.widgetName + \"-item\", targetData); // Data for target checking (mouse manager)\n\n\t\t\t\t\titems.push({\n\t\t\t\t\t\titem: item,\n\t\t\t\t\t\tinstance: targetData,\n\t\t\t\t\t\twidth: 0, height: 0,\n\t\t\t\t\t\tleft: 0, top: 0\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\trefreshPositions: function refreshPositions(fast) {\n\n\t\t\t// Determine whether items are being displayed horizontally\n\t\t\tthis.floating = this.items.length ? this.options.axis === \"x\" || this._isFloating(this.items[0].item) : false;\n\n\t\t\t//This has to be redone because due to the item being moved out/into the offsetParent, the offsetParent's position will change\n\t\t\tif (this.offsetParent && this.helper) {\n\t\t\t\tthis.offset.parent = this._getParentOffset();\n\t\t\t}\n\n\t\t\tvar i, item, t, p;\n\n\t\t\tfor (i = this.items.length - 1; i >= 0; i--) {\n\t\t\t\titem = this.items[i];\n\n\t\t\t\t//We ignore calculating positions of all connected containers when we're not over them\n\t\t\t\tif (item.instance !== this.currentContainer && this.currentContainer && item.item[0] !== this.currentItem[0]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tt = this.options.toleranceElement ? $(this.options.toleranceElement, item.item) : item.item;\n\n\t\t\t\tif (!fast) {\n\t\t\t\t\titem.width = t.outerWidth();\n\t\t\t\t\titem.height = t.outerHeight();\n\t\t\t\t}\n\n\t\t\t\tp = t.offset();\n\t\t\t\titem.left = p.left;\n\t\t\t\titem.top = p.top;\n\t\t\t}\n\n\t\t\tif (this.options.custom && this.options.custom.refreshContainers) {\n\t\t\t\tthis.options.custom.refreshContainers.call(this);\n\t\t\t} else {\n\t\t\t\tfor (i = this.containers.length - 1; i >= 0; i--) {\n\t\t\t\t\tp = this.containers[i].element.offset();\n\t\t\t\t\tthis.containers[i].containerCache.left = p.left;\n\t\t\t\t\tthis.containers[i].containerCache.top = p.top;\n\t\t\t\t\tthis.containers[i].containerCache.width = this.containers[i].element.outerWidth();\n\t\t\t\t\tthis.containers[i].containerCache.height = this.containers[i].element.outerHeight();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\t_createPlaceholder: function _createPlaceholder(that) {\n\t\t\tthat = that || this;\n\t\t\tvar className,\n\t\t\t    o = that.options;\n\n\t\t\tif (!o.placeholder || o.placeholder.constructor === String) {\n\t\t\t\tclassName = o.placeholder;\n\t\t\t\to.placeholder = {\n\t\t\t\t\telement: function element() {\n\n\t\t\t\t\t\tvar nodeName = that.currentItem[0].nodeName.toLowerCase(),\n\t\t\t\t\t\t    element = $(\"<\" + nodeName + \">\", that.document[0]).addClass(className || that.currentItem[0].className + \" ui-sortable-placeholder\").removeClass(\"ui-sortable-helper\");\n\n\t\t\t\t\t\tif (nodeName === \"tbody\") {\n\t\t\t\t\t\t\tthat._createTrPlaceholder(that.currentItem.find(\"tr\").eq(0), $(\"<tr>\", that.document[0]).appendTo(element));\n\t\t\t\t\t\t} else if (nodeName === \"tr\") {\n\t\t\t\t\t\t\tthat._createTrPlaceholder(that.currentItem, element);\n\t\t\t\t\t\t} else if (nodeName === \"img\") {\n\t\t\t\t\t\t\telement.attr(\"src\", that.currentItem.attr(\"src\"));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!className) {\n\t\t\t\t\t\t\telement.css(\"visibility\", \"hidden\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn element;\n\t\t\t\t\t},\n\t\t\t\t\tupdate: function update(container, p) {\n\n\t\t\t\t\t\t// 1. If a className is set as 'placeholder option, we don't force sizes - the class is responsible for that\n\t\t\t\t\t\t// 2. The option 'forcePlaceholderSize can be enabled to force it even if a class name is specified\n\t\t\t\t\t\tif (className && !o.forcePlaceholderSize) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//If the element doesn't have a actual height by itself (without styles coming from a stylesheet), it receives the inline height from the dragged item\n\t\t\t\t\t\tif (!p.height()) {\n\t\t\t\t\t\t\tp.height(that.currentItem.innerHeight() - parseInt(that.currentItem.css(\"paddingTop\") || 0, 10) - parseInt(that.currentItem.css(\"paddingBottom\") || 0, 10));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!p.width()) {\n\t\t\t\t\t\t\tp.width(that.currentItem.innerWidth() - parseInt(that.currentItem.css(\"paddingLeft\") || 0, 10) - parseInt(that.currentItem.css(\"paddingRight\") || 0, 10));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t//Create the placeholder\n\t\t\tthat.placeholder = $(o.placeholder.element.call(that.element, that.currentItem));\n\n\t\t\t//Append it after the actual current item\n\t\t\tthat.currentItem.after(that.placeholder);\n\n\t\t\t//Update the size of the placeholder (TODO: Logic to fuzzy, see line 316/317)\n\t\t\to.placeholder.update(that, that.placeholder);\n\t\t},\n\n\t\t_createTrPlaceholder: function _createTrPlaceholder(sourceTr, targetTr) {\n\t\t\tvar that = this;\n\n\t\t\tsourceTr.children().each(function () {\n\t\t\t\t$(\"<td>&#160;</td>\", that.document[0]).attr(\"colspan\", $(this).attr(\"colspan\") || 1).appendTo(targetTr);\n\t\t\t});\n\t\t},\n\n\t\t_contactContainers: function _contactContainers(event) {\n\t\t\tvar i,\n\t\t\t    j,\n\t\t\t    dist,\n\t\t\t    itemWithLeastDistance,\n\t\t\t    posProperty,\n\t\t\t    sizeProperty,\n\t\t\t    cur,\n\t\t\t    nearBottom,\n\t\t\t    floating,\n\t\t\t    axis,\n\t\t\t    innermostContainer = null,\n\t\t\t    innermostIndex = null;\n\n\t\t\t// get innermost container that intersects with item\n\t\t\tfor (i = this.containers.length - 1; i >= 0; i--) {\n\n\t\t\t\t// never consider a container that's located within the item itself\n\t\t\t\tif ($.contains(this.currentItem[0], this.containers[i].element[0])) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (this._intersectsWith(this.containers[i].containerCache)) {\n\n\t\t\t\t\t// if we've already found a container and it's more \"inner\" than this, then continue\n\t\t\t\t\tif (innermostContainer && $.contains(this.containers[i].element[0], innermostContainer.element[0])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tinnermostContainer = this.containers[i];\n\t\t\t\t\tinnermostIndex = i;\n\t\t\t\t} else {\n\t\t\t\t\t// container doesn't intersect. trigger \"out\" event if necessary\n\t\t\t\t\tif (this.containers[i].containerCache.over) {\n\t\t\t\t\t\tthis.containers[i]._trigger(\"out\", event, this._uiHash(this));\n\t\t\t\t\t\tthis.containers[i].containerCache.over = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// if no intersecting containers found, return\n\t\t\tif (!innermostContainer) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// move the item into the container if it's not there already\n\t\t\tif (this.containers.length === 1) {\n\t\t\t\tif (!this.containers[innermostIndex].containerCache.over) {\n\t\t\t\t\tthis.containers[innermostIndex]._trigger(\"over\", event, this._uiHash(this));\n\t\t\t\t\tthis.containers[innermostIndex].containerCache.over = 1;\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\t//When entering a new container, we will find the item with the least distance and append our item near it\n\t\t\t\tdist = 10000;\n\t\t\t\titemWithLeastDistance = null;\n\t\t\t\tfloating = innermostContainer.floating || this._isFloating(this.currentItem);\n\t\t\t\tposProperty = floating ? \"left\" : \"top\";\n\t\t\t\tsizeProperty = floating ? \"width\" : \"height\";\n\t\t\t\taxis = floating ? \"clientX\" : \"clientY\";\n\n\t\t\t\tfor (j = this.items.length - 1; j >= 0; j--) {\n\t\t\t\t\tif (!$.contains(this.containers[innermostIndex].element[0], this.items[j].item[0])) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (this.items[j].item[0] === this.currentItem[0]) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tcur = this.items[j].item.offset()[posProperty];\n\t\t\t\t\tnearBottom = false;\n\t\t\t\t\tif (event[axis] - cur > this.items[j][sizeProperty] / 2) {\n\t\t\t\t\t\tnearBottom = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (Math.abs(event[axis] - cur) < dist) {\n\t\t\t\t\t\tdist = Math.abs(event[axis] - cur);\n\t\t\t\t\t\titemWithLeastDistance = this.items[j];\n\t\t\t\t\t\tthis.direction = nearBottom ? \"up\" : \"down\";\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//Check if dropOnEmpty is enabled\n\t\t\t\tif (!itemWithLeastDistance && !this.options.dropOnEmpty) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (this.currentContainer === this.containers[innermostIndex]) {\n\t\t\t\t\tif (!this.currentContainer.containerCache.over) {\n\t\t\t\t\t\tthis.containers[innermostIndex]._trigger(\"over\", event, this._uiHash());\n\t\t\t\t\t\tthis.currentContainer.containerCache.over = 1;\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\titemWithLeastDistance ? this._rearrange(event, itemWithLeastDistance, null, true) : this._rearrange(event, null, this.containers[innermostIndex].element, true);\n\t\t\t\tthis._trigger(\"change\", event, this._uiHash());\n\t\t\t\tthis.containers[innermostIndex]._trigger(\"change\", event, this._uiHash(this));\n\t\t\t\tthis.currentContainer = this.containers[innermostIndex];\n\n\t\t\t\t//Update the placeholder\n\t\t\t\tthis.options.placeholder.update(this.currentContainer, this.placeholder);\n\n\t\t\t\tthis.containers[innermostIndex]._trigger(\"over\", event, this._uiHash(this));\n\t\t\t\tthis.containers[innermostIndex].containerCache.over = 1;\n\t\t\t}\n\t\t},\n\n\t\t_createHelper: function _createHelper(event) {\n\n\t\t\tvar o = this.options,\n\t\t\t    helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event, this.currentItem])) : o.helper === \"clone\" ? this.currentItem.clone() : this.currentItem;\n\n\t\t\t//Add the helper to the DOM if that didn't happen already\n\t\t\tif (!helper.parents(\"body\").length) {\n\t\t\t\t$(o.appendTo !== \"parent\" ? o.appendTo : this.currentItem[0].parentNode)[0].appendChild(helper[0]);\n\t\t\t}\n\n\t\t\tif (helper[0] === this.currentItem[0]) {\n\t\t\t\tthis._storedCSS = { width: this.currentItem[0].style.width, height: this.currentItem[0].style.height, position: this.currentItem.css(\"position\"), top: this.currentItem.css(\"top\"), left: this.currentItem.css(\"left\") };\n\t\t\t}\n\n\t\t\tif (!helper[0].style.width || o.forceHelperSize) {\n\t\t\t\thelper.width(this.currentItem.width());\n\t\t\t}\n\t\t\tif (!helper[0].style.height || o.forceHelperSize) {\n\t\t\t\thelper.height(this.currentItem.height());\n\t\t\t}\n\n\t\t\treturn helper;\n\t\t},\n\n\t\t_adjustOffsetFromHelper: function _adjustOffsetFromHelper(obj) {\n\t\t\tif (typeof obj === \"string\") {\n\t\t\t\tobj = obj.split(\" \");\n\t\t\t}\n\t\t\tif ($.isArray(obj)) {\n\t\t\t\tobj = { left: +obj[0], top: +obj[1] || 0 };\n\t\t\t}\n\t\t\tif (\"left\" in obj) {\n\t\t\t\tthis.offset.click.left = obj.left + this.margins.left;\n\t\t\t}\n\t\t\tif (\"right\" in obj) {\n\t\t\t\tthis.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;\n\t\t\t}\n\t\t\tif (\"top\" in obj) {\n\t\t\t\tthis.offset.click.top = obj.top + this.margins.top;\n\t\t\t}\n\t\t\tif (\"bottom\" in obj) {\n\t\t\t\tthis.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;\n\t\t\t}\n\t\t},\n\n\t\t_getParentOffset: function _getParentOffset() {\n\n\t\t\t//Get the offsetParent and cache its position\n\t\t\tthis.offsetParent = this.helper.offsetParent();\n\t\t\tvar po = this.offsetParent.offset();\n\n\t\t\t// This is a special case where we need to modify a offset calculated on start, since the following happened:\n\t\t\t// 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent\n\t\t\t// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that\n\t\t\t//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag\n\t\t\tif (this.cssPosition === \"absolute\" && this.scrollParent[0] !== this.document[0] && $.contains(this.scrollParent[0], this.offsetParent[0])) {\n\t\t\t\tpo.left += this.scrollParent.scrollLeft();\n\t\t\t\tpo.top += this.scrollParent.scrollTop();\n\t\t\t}\n\n\t\t\t// This needs to be actually done for all browsers, since pageX/pageY includes this information\n\t\t\t// with an ugly IE fix\n\t\t\tif (this.offsetParent[0] === this.document[0].body || this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() === \"html\" && $.ui.ie) {\n\t\t\t\tpo = { top: 0, left: 0 };\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\ttop: po.top + (parseInt(this.offsetParent.css(\"borderTopWidth\"), 10) || 0),\n\t\t\t\tleft: po.left + (parseInt(this.offsetParent.css(\"borderLeftWidth\"), 10) || 0)\n\t\t\t};\n\t\t},\n\n\t\t_getRelativeOffset: function _getRelativeOffset() {\n\n\t\t\tif (this.cssPosition === \"relative\") {\n\t\t\t\tvar p = this.currentItem.position();\n\t\t\t\treturn {\n\t\t\t\t\ttop: p.top - (parseInt(this.helper.css(\"top\"), 10) || 0) + this.scrollParent.scrollTop(),\n\t\t\t\t\tleft: p.left - (parseInt(this.helper.css(\"left\"), 10) || 0) + this.scrollParent.scrollLeft()\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\treturn { top: 0, left: 0 };\n\t\t\t}\n\t\t},\n\n\t\t_cacheMargins: function _cacheMargins() {\n\t\t\tthis.margins = {\n\t\t\t\tleft: parseInt(this.currentItem.css(\"marginLeft\"), 10) || 0,\n\t\t\t\ttop: parseInt(this.currentItem.css(\"marginTop\"), 10) || 0\n\t\t\t};\n\t\t},\n\n\t\t_cacheHelperProportions: function _cacheHelperProportions() {\n\t\t\tthis.helperProportions = {\n\t\t\t\twidth: this.helper.outerWidth(),\n\t\t\t\theight: this.helper.outerHeight()\n\t\t\t};\n\t\t},\n\n\t\t_setContainment: function _setContainment() {\n\n\t\t\tvar ce,\n\t\t\t    co,\n\t\t\t    over,\n\t\t\t    o = this.options;\n\t\t\tif (o.containment === \"parent\") {\n\t\t\t\to.containment = this.helper[0].parentNode;\n\t\t\t}\n\t\t\tif (o.containment === \"document\" || o.containment === \"window\") {\n\t\t\t\tthis.containment = [0 - this.offset.relative.left - this.offset.parent.left, 0 - this.offset.relative.top - this.offset.parent.top, o.containment === \"document\" ? this.document.width() : this.window.width() - this.helperProportions.width - this.margins.left, (o.containment === \"document\" ? this.document.width() : this.window.height() || this.document[0].body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top];\n\t\t\t}\n\n\t\t\tif (!/^(document|window|parent)$/.test(o.containment)) {\n\t\t\t\tce = $(o.containment)[0];\n\t\t\t\tco = $(o.containment).offset();\n\t\t\t\tover = $(ce).css(\"overflow\") !== \"hidden\";\n\n\t\t\t\tthis.containment = [co.left + (parseInt($(ce).css(\"borderLeftWidth\"), 10) || 0) + (parseInt($(ce).css(\"paddingLeft\"), 10) || 0) - this.margins.left, co.top + (parseInt($(ce).css(\"borderTopWidth\"), 10) || 0) + (parseInt($(ce).css(\"paddingTop\"), 10) || 0) - this.margins.top, co.left + (over ? Math.max(ce.scrollWidth, ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css(\"borderLeftWidth\"), 10) || 0) - (parseInt($(ce).css(\"paddingRight\"), 10) || 0) - this.helperProportions.width - this.margins.left, co.top + (over ? Math.max(ce.scrollHeight, ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css(\"borderTopWidth\"), 10) || 0) - (parseInt($(ce).css(\"paddingBottom\"), 10) || 0) - this.helperProportions.height - this.margins.top];\n\t\t\t}\n\t\t},\n\n\t\t_convertPositionTo: function _convertPositionTo(d, pos) {\n\n\t\t\tif (!pos) {\n\t\t\t\tpos = this.position;\n\t\t\t}\n\t\t\tvar mod = d === \"absolute\" ? 1 : -1,\n\t\t\t    scroll = this.cssPosition === \"absolute\" && !(this.scrollParent[0] !== this.document[0] && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent,\n\t\t\t    scrollIsRootNode = /(html|body)/i.test(scroll[0].tagName);\n\n\t\t\treturn {\n\t\t\t\ttop: pos.top + // The absolute mouse position\n\t\t\t\tthis.offset.relative.top * mod + // Only for relative positioned nodes: Relative offset from element to offset parent\n\t\t\t\tthis.offset.parent.top * mod - // The offsetParent's offset without borders (offset + border)\n\t\t\t\t(this.cssPosition === \"fixed\" ? -this.scrollParent.scrollTop() : scrollIsRootNode ? 0 : scroll.scrollTop()) * mod,\n\t\t\t\tleft: pos.left + // The absolute mouse position\n\t\t\t\tthis.offset.relative.left * mod + // Only for relative positioned nodes: Relative offset from element to offset parent\n\t\t\t\tthis.offset.parent.left * mod - // The offsetParent's offset without borders (offset + border)\n\t\t\t\t(this.cssPosition === \"fixed\" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft()) * mod\n\t\t\t};\n\t\t},\n\n\t\t_generatePosition: function _generatePosition(event) {\n\n\t\t\tvar top,\n\t\t\t    left,\n\t\t\t    o = this.options,\n\t\t\t    pageX = event.pageX,\n\t\t\t    pageY = event.pageY,\n\t\t\t    scroll = this.cssPosition === \"absolute\" && !(this.scrollParent[0] !== this.document[0] && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent,\n\t\t\t    scrollIsRootNode = /(html|body)/i.test(scroll[0].tagName);\n\n\t\t\t// This is another very weird special case that only happens for relative elements:\n\t\t\t// 1. If the css position is relative\n\t\t\t// 2. and the scroll parent is the document or similar to the offset parent\n\t\t\t// we have to refresh the relative offset during the scroll so there are no jumps\n\t\t\tif (this.cssPosition === \"relative\" && !(this.scrollParent[0] !== this.document[0] && this.scrollParent[0] !== this.offsetParent[0])) {\n\t\t\t\tthis.offset.relative = this._getRelativeOffset();\n\t\t\t}\n\n\t\t\t/*\n    * - Position constraining -\n    * Constrain the position to a mix of grid, containment.\n    */\n\n\t\t\tif (this.originalPosition) {\n\t\t\t\t//If we are not dragging yet, we won't check for options\n\n\t\t\t\tif (this.containment) {\n\t\t\t\t\tif (event.pageX - this.offset.click.left < this.containment[0]) {\n\t\t\t\t\t\tpageX = this.containment[0] + this.offset.click.left;\n\t\t\t\t\t}\n\t\t\t\t\tif (event.pageY - this.offset.click.top < this.containment[1]) {\n\t\t\t\t\t\tpageY = this.containment[1] + this.offset.click.top;\n\t\t\t\t\t}\n\t\t\t\t\tif (event.pageX - this.offset.click.left > this.containment[2]) {\n\t\t\t\t\t\tpageX = this.containment[2] + this.offset.click.left;\n\t\t\t\t\t}\n\t\t\t\t\tif (event.pageY - this.offset.click.top > this.containment[3]) {\n\t\t\t\t\t\tpageY = this.containment[3] + this.offset.click.top;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (o.grid) {\n\t\t\t\t\ttop = this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1];\n\t\t\t\t\tpageY = this.containment ? top - this.offset.click.top >= this.containment[1] && top - this.offset.click.top <= this.containment[3] ? top : top - this.offset.click.top >= this.containment[1] ? top - o.grid[1] : top + o.grid[1] : top;\n\n\t\t\t\t\tleft = this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0];\n\t\t\t\t\tpageX = this.containment ? left - this.offset.click.left >= this.containment[0] && left - this.offset.click.left <= this.containment[2] ? left : left - this.offset.click.left >= this.containment[0] ? left - o.grid[0] : left + o.grid[0] : left;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\ttop: pageY - // The absolute mouse position\n\t\t\t\tthis.offset.click.top - // Click offset (relative to the element)\n\t\t\t\tthis.offset.relative.top - // Only for relative positioned nodes: Relative offset from element to offset parent\n\t\t\t\tthis.offset.parent.top + ( // The offsetParent's offset without borders (offset + border)\n\t\t\t\tthis.cssPosition === \"fixed\" ? -this.scrollParent.scrollTop() : scrollIsRootNode ? 0 : scroll.scrollTop()),\n\t\t\t\tleft: pageX - // The absolute mouse position\n\t\t\t\tthis.offset.click.left - // Click offset (relative to the element)\n\t\t\t\tthis.offset.relative.left - // Only for relative positioned nodes: Relative offset from element to offset parent\n\t\t\t\tthis.offset.parent.left + ( // The offsetParent's offset without borders (offset + border)\n\t\t\t\tthis.cssPosition === \"fixed\" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft())\n\t\t\t};\n\t\t},\n\n\t\t_rearrange: function _rearrange(event, i, a, hardRefresh) {\n\n\t\t\ta ? a[0].appendChild(this.placeholder[0]) : i.item[0].parentNode.insertBefore(this.placeholder[0], this.direction === \"down\" ? i.item[0] : i.item[0].nextSibling);\n\n\t\t\t//Various things done here to improve the performance:\n\t\t\t// 1. we create a setTimeout, that calls refreshPositions\n\t\t\t// 2. on the instance, we have a counter variable, that get's higher after every append\n\t\t\t// 3. on the local scope, we copy the counter variable, and check in the timeout, if it's still the same\n\t\t\t// 4. this lets only the last addition to the timeout stack through\n\t\t\tthis.counter = this.counter ? ++this.counter : 1;\n\t\t\tvar counter = this.counter;\n\n\t\t\tthis._delay(function () {\n\t\t\t\tif (counter === this.counter) {\n\t\t\t\t\tthis.refreshPositions(!hardRefresh); //Precompute after each DOM insertion, NOT on mousemove\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\t_clear: function _clear(event, noPropagation) {\n\n\t\t\tthis.reverting = false;\n\t\t\t// We delay all events that have to be triggered to after the point where the placeholder has been removed and\n\t\t\t// everything else normalized again\n\t\t\tvar i,\n\t\t\t    delayedTriggers = [];\n\n\t\t\t// We first have to update the dom position of the actual currentItem\n\t\t\t// Note: don't do it if the current item is already removed (by a user), or it gets reappended (see #4088)\n\t\t\tif (!this._noFinalSort && this.currentItem.parent().length) {\n\t\t\t\tthis.placeholder.before(this.currentItem);\n\t\t\t}\n\t\t\tthis._noFinalSort = null;\n\n\t\t\tif (this.helper[0] === this.currentItem[0]) {\n\t\t\t\tfor (i in this._storedCSS) {\n\t\t\t\t\tif (this._storedCSS[i] === \"auto\" || this._storedCSS[i] === \"static\") {\n\t\t\t\t\t\tthis._storedCSS[i] = \"\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.currentItem.css(this._storedCSS).removeClass(\"ui-sortable-helper\");\n\t\t\t} else {\n\t\t\t\tthis.currentItem.show();\n\t\t\t}\n\n\t\t\tif (this.fromOutside && !noPropagation) {\n\t\t\t\tdelayedTriggers.push(function (event) {\n\t\t\t\t\tthis._trigger(\"receive\", event, this._uiHash(this.fromOutside));\n\t\t\t\t});\n\t\t\t}\n\t\t\tif ((this.fromOutside || this.domPosition.prev !== this.currentItem.prev().not(\".ui-sortable-helper\")[0] || this.domPosition.parent !== this.currentItem.parent()[0]) && !noPropagation) {\n\t\t\t\tdelayedTriggers.push(function (event) {\n\t\t\t\t\tthis._trigger(\"update\", event, this._uiHash());\n\t\t\t\t}); //Trigger update callback if the DOM position has changed\n\t\t\t}\n\n\t\t\t// Check if the items Container has Changed and trigger appropriate\n\t\t\t// events.\n\t\t\tif (this !== this.currentContainer) {\n\t\t\t\tif (!noPropagation) {\n\t\t\t\t\tdelayedTriggers.push(function (event) {\n\t\t\t\t\t\tthis._trigger(\"remove\", event, this._uiHash());\n\t\t\t\t\t});\n\t\t\t\t\tdelayedTriggers.push(function (c) {\n\t\t\t\t\t\treturn function (event) {\n\t\t\t\t\t\t\tc._trigger(\"receive\", event, this._uiHash(this));\n\t\t\t\t\t\t};\n\t\t\t\t\t}.call(this, this.currentContainer));\n\t\t\t\t\tdelayedTriggers.push(function (c) {\n\t\t\t\t\t\treturn function (event) {\n\t\t\t\t\t\t\tc._trigger(\"update\", event, this._uiHash(this));\n\t\t\t\t\t\t};\n\t\t\t\t\t}.call(this, this.currentContainer));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//Post events to containers\n\t\t\tfunction delayEvent(type, instance, container) {\n\t\t\t\treturn function (event) {\n\t\t\t\t\tcontainer._trigger(type, event, instance._uiHash(instance));\n\t\t\t\t};\n\t\t\t}\n\t\t\tfor (i = this.containers.length - 1; i >= 0; i--) {\n\t\t\t\tif (!noPropagation) {\n\t\t\t\t\tdelayedTriggers.push(delayEvent(\"deactivate\", this, this.containers[i]));\n\t\t\t\t}\n\t\t\t\tif (this.containers[i].containerCache.over) {\n\t\t\t\t\tdelayedTriggers.push(delayEvent(\"out\", this, this.containers[i]));\n\t\t\t\t\tthis.containers[i].containerCache.over = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//Do what was originally in plugins\n\t\t\tif (this.storedCursor) {\n\t\t\t\tthis.document.find(\"body\").css(\"cursor\", this.storedCursor);\n\t\t\t\tthis.storedStylesheet.remove();\n\t\t\t}\n\t\t\tif (this._storedOpacity) {\n\t\t\t\tthis.helper.css(\"opacity\", this._storedOpacity);\n\t\t\t}\n\t\t\tif (this._storedZIndex) {\n\t\t\t\tthis.helper.css(\"zIndex\", this._storedZIndex === \"auto\" ? \"\" : this._storedZIndex);\n\t\t\t}\n\n\t\t\tthis.dragging = false;\n\n\t\t\tif (!noPropagation) {\n\t\t\t\tthis._trigger(\"beforeStop\", event, this._uiHash());\n\t\t\t}\n\n\t\t\t//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!\n\t\t\tthis.placeholder[0].parentNode.removeChild(this.placeholder[0]);\n\n\t\t\tif (!this.cancelHelperRemoval) {\n\t\t\t\tif (this.helper[0] !== this.currentItem[0]) {\n\t\t\t\t\tthis.helper.remove();\n\t\t\t\t}\n\t\t\t\tthis.helper = null;\n\t\t\t}\n\n\t\t\tif (!noPropagation) {\n\t\t\t\tfor (i = 0; i < delayedTriggers.length; i++) {\n\t\t\t\t\tdelayedTriggers[i].call(this, event);\n\t\t\t\t} //Trigger all delayed events\n\t\t\t\tthis._trigger(\"stop\", event, this._uiHash());\n\t\t\t}\n\n\t\t\tthis.fromOutside = false;\n\t\t\treturn !this.cancelHelperRemoval;\n\t\t},\n\n\t\t_trigger: function _trigger() {\n\t\t\tif ($.Widget.prototype._trigger.apply(this, arguments) === false) {\n\t\t\t\tthis.cancel();\n\t\t\t}\n\t\t},\n\n\t\t_uiHash: function _uiHash(_inst) {\n\t\t\tvar inst = _inst || this;\n\t\t\treturn {\n\t\t\t\thelper: inst.helper,\n\t\t\t\tplaceholder: inst.placeholder || $([]),\n\t\t\t\tposition: inst.position,\n\t\t\t\toriginalPosition: inst.originalPosition,\n\t\t\t\toffset: inst.positionAbs,\n\t\t\t\titem: inst.currentItem,\n\t\t\t\tsender: _inst ? _inst.element : null\n\t\t\t};\n\t\t}\n\n\t});\n\n\t/*!\n  * jQuery UI Spinner 1.11.4\n  * http://jqueryui.com\n  *\n  * Copyright jQuery Foundation and other contributors\n  * Released under the MIT license.\n  * http://jquery.org/license\n  *\n  * http://api.jqueryui.com/spinner/\n  */\n\n\tfunction spinner_modifier(fn) {\n\t\treturn function () {\n\t\t\tvar previous = this.element.val();\n\t\t\tfn.apply(this, arguments);\n\t\t\tthis._refresh();\n\t\t\tif (previous !== this.element.val()) {\n\t\t\t\tthis._trigger(\"change\");\n\t\t\t}\n\t\t};\n\t}\n\n\tvar spinner = $.widget(\"ui.spinner\", {\n\t\tversion: \"1.11.4\",\n\t\tdefaultElement: \"<input>\",\n\t\twidgetEventPrefix: \"spin\",\n\t\toptions: {\n\t\t\tculture: null,\n\t\t\ticons: {\n\t\t\t\tdown: \"ui-icon-triangle-1-s\",\n\t\t\t\tup: \"ui-icon-triangle-1-n\"\n\t\t\t},\n\t\t\tincremental: true,\n\t\t\tmax: null,\n\t\t\tmin: null,\n\t\t\tnumberFormat: null,\n\t\t\tpage: 10,\n\t\t\tstep: 1,\n\n\t\t\tchange: null,\n\t\t\tspin: null,\n\t\t\tstart: null,\n\t\t\tstop: null\n\t\t},\n\n\t\t_create: function _create() {\n\t\t\t// handle string values that need to be parsed\n\t\t\tthis._setOption(\"max\", this.options.max);\n\t\t\tthis._setOption(\"min\", this.options.min);\n\t\t\tthis._setOption(\"step\", this.options.step);\n\n\t\t\t// Only format if there is a value, prevents the field from being marked\n\t\t\t// as invalid in Firefox, see #9573.\n\t\t\tif (this.value() !== \"\") {\n\t\t\t\t// Format the value, but don't constrain.\n\t\t\t\tthis._value(this.element.val(), true);\n\t\t\t}\n\n\t\t\tthis._draw();\n\t\t\tthis._on(this._events);\n\t\t\tthis._refresh();\n\n\t\t\t// turning off autocomplete prevents the browser from remembering the\n\t\t\t// value when navigating through history, so we re-enable autocomplete\n\t\t\t// if the page is unloaded before the widget is destroyed. #7790\n\t\t\tthis._on(this.window, {\n\t\t\t\tbeforeunload: function beforeunload() {\n\t\t\t\t\tthis.element.removeAttr(\"autocomplete\");\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\t_getCreateOptions: function _getCreateOptions() {\n\t\t\tvar options = {},\n\t\t\t    element = this.element;\n\n\t\t\t$.each([\"min\", \"max\", \"step\"], function (i, option) {\n\t\t\t\tvar value = element.attr(option);\n\t\t\t\tif (value !== undefined && value.length) {\n\t\t\t\t\toptions[option] = value;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn options;\n\t\t},\n\n\t\t_events: {\n\t\t\tkeydown: function keydown(event) {\n\t\t\t\tif (this._start(event) && this._keydown(event)) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\t\t\t},\n\t\t\tkeyup: \"_stop\",\n\t\t\tfocus: function focus() {\n\t\t\t\tthis.previous = this.element.val();\n\t\t\t},\n\t\t\tblur: function blur(event) {\n\t\t\t\tif (this.cancelBlur) {\n\t\t\t\t\tdelete this.cancelBlur;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis._stop();\n\t\t\t\tthis._refresh();\n\t\t\t\tif (this.previous !== this.element.val()) {\n\t\t\t\t\tthis._trigger(\"change\", event);\n\t\t\t\t}\n\t\t\t},\n\t\t\tmousewheel: function mousewheel(event, delta) {\n\t\t\t\tif (!delta) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (!this.spinning && !this._start(event)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tthis._spin((delta > 0 ? 1 : -1) * this.options.step, event);\n\t\t\t\tclearTimeout(this.mousewheelTimer);\n\t\t\t\tthis.mousewheelTimer = this._delay(function () {\n\t\t\t\t\tif (this.spinning) {\n\t\t\t\t\t\tthis._stop(event);\n\t\t\t\t\t}\n\t\t\t\t}, 100);\n\t\t\t\tevent.preventDefault();\n\t\t\t},\n\t\t\t\"mousedown .ui-spinner-button\": function mousedownUiSpinnerButton(event) {\n\t\t\t\tvar previous;\n\n\t\t\t\t// We never want the buttons to have focus; whenever the user is\n\t\t\t\t// interacting with the spinner, the focus should be on the input.\n\t\t\t\t// If the input is focused then this.previous is properly set from\n\t\t\t\t// when the input first received focus. If the input is not focused\n\t\t\t\t// then we need to set this.previous based on the value before spinning.\n\t\t\t\tprevious = this.element[0] === this.document[0].activeElement ? this.previous : this.element.val();\n\t\t\t\tfunction checkFocus() {\n\t\t\t\t\tvar isActive = this.element[0] === this.document[0].activeElement;\n\t\t\t\t\tif (!isActive) {\n\t\t\t\t\t\tthis.element.focus();\n\t\t\t\t\t\tthis.previous = previous;\n\t\t\t\t\t\t// support: IE\n\t\t\t\t\t\t// IE sets focus asynchronously, so we need to check if focus\n\t\t\t\t\t\t// moved off of the input because the user clicked on the button.\n\t\t\t\t\t\tthis._delay(function () {\n\t\t\t\t\t\t\tthis.previous = previous;\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// ensure focus is on (or stays on) the text field\n\t\t\t\tevent.preventDefault();\n\t\t\t\tcheckFocus.call(this);\n\n\t\t\t\t// support: IE\n\t\t\t\t// IE doesn't prevent moving focus even with event.preventDefault()\n\t\t\t\t// so we set a flag to know when we should ignore the blur event\n\t\t\t\t// and check (again) if focus moved off of the input.\n\t\t\t\tthis.cancelBlur = true;\n\t\t\t\tthis._delay(function () {\n\t\t\t\t\tdelete this.cancelBlur;\n\t\t\t\t\tcheckFocus.call(this);\n\t\t\t\t});\n\n\t\t\t\tif (this._start(event) === false) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis._repeat(null, $(event.currentTarget).hasClass(\"ui-spinner-up\") ? 1 : -1, event);\n\t\t\t},\n\t\t\t\"mouseup .ui-spinner-button\": \"_stop\",\n\t\t\t\"mouseenter .ui-spinner-button\": function mouseenterUiSpinnerButton(event) {\n\t\t\t\t// button will add ui-state-active if mouse was down while mouseleave and kept down\n\t\t\t\tif (!$(event.currentTarget).hasClass(\"ui-state-active\")) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (this._start(event) === false) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tthis._repeat(null, $(event.currentTarget).hasClass(\"ui-spinner-up\") ? 1 : -1, event);\n\t\t\t},\n\t\t\t// TODO: do we really want to consider this a stop?\n\t\t\t// shouldn't we just stop the repeater and wait until mouseup before\n\t\t\t// we trigger the stop event?\n\t\t\t\"mouseleave .ui-spinner-button\": \"_stop\"\n\t\t},\n\n\t\t_draw: function _draw() {\n\t\t\tvar uiSpinner = this.uiSpinner = this.element.addClass(\"ui-spinner-input\").attr(\"autocomplete\", \"off\").wrap(this._uiSpinnerHtml()).parent()\n\t\t\t// add buttons\n\t\t\t.append(this._buttonHtml());\n\n\t\t\tthis.element.attr(\"role\", \"spinbutton\");\n\n\t\t\t// button bindings\n\t\t\tthis.buttons = uiSpinner.find(\".ui-spinner-button\").attr(\"tabIndex\", -1).button().removeClass(\"ui-corner-all\");\n\n\t\t\t// IE 6 doesn't understand height: 50% for the buttons\n\t\t\t// unless the wrapper has an explicit height\n\t\t\tif (this.buttons.height() > Math.ceil(uiSpinner.height() * 0.5) && uiSpinner.height() > 0) {\n\t\t\t\tuiSpinner.height(uiSpinner.height());\n\t\t\t}\n\n\t\t\t// disable spinner if element was already disabled\n\t\t\tif (this.options.disabled) {\n\t\t\t\tthis.disable();\n\t\t\t}\n\t\t},\n\n\t\t_keydown: function _keydown(event) {\n\t\t\tvar options = this.options,\n\t\t\t    keyCode = $.ui.keyCode;\n\n\t\t\tswitch (event.keyCode) {\n\t\t\t\tcase keyCode.UP:\n\t\t\t\t\tthis._repeat(null, 1, event);\n\t\t\t\t\treturn true;\n\t\t\t\tcase keyCode.DOWN:\n\t\t\t\t\tthis._repeat(null, -1, event);\n\t\t\t\t\treturn true;\n\t\t\t\tcase keyCode.PAGE_UP:\n\t\t\t\t\tthis._repeat(null, options.page, event);\n\t\t\t\t\treturn true;\n\t\t\t\tcase keyCode.PAGE_DOWN:\n\t\t\t\t\tthis._repeat(null, -options.page, event);\n\t\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t},\n\n\t\t_uiSpinnerHtml: function _uiSpinnerHtml() {\n\t\t\treturn \"<span class='ui-spinner ui-widget ui-widget-content ui-corner-all'></span>\";\n\t\t},\n\n\t\t_buttonHtml: function _buttonHtml() {\n\t\t\treturn \"\" + \"<a class='ui-spinner-button ui-spinner-up ui-corner-tr'>\" + \"<span class='ui-icon \" + this.options.icons.up + \"'>&#9650;</span>\" + \"</a>\" + \"<a class='ui-spinner-button ui-spinner-down ui-corner-br'>\" + \"<span class='ui-icon \" + this.options.icons.down + \"'>&#9660;</span>\" + \"</a>\";\n\t\t},\n\n\t\t_start: function _start(event) {\n\t\t\tif (!this.spinning && this._trigger(\"start\", event) === false) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (!this.counter) {\n\t\t\t\tthis.counter = 1;\n\t\t\t}\n\t\t\tthis.spinning = true;\n\t\t\treturn true;\n\t\t},\n\n\t\t_repeat: function _repeat(i, steps, event) {\n\t\t\ti = i || 500;\n\n\t\t\tclearTimeout(this.timer);\n\t\t\tthis.timer = this._delay(function () {\n\t\t\t\tthis._repeat(40, steps, event);\n\t\t\t}, i);\n\n\t\t\tthis._spin(steps * this.options.step, event);\n\t\t},\n\n\t\t_spin: function _spin(step, event) {\n\t\t\tvar value = this.value() || 0;\n\n\t\t\tif (!this.counter) {\n\t\t\t\tthis.counter = 1;\n\t\t\t}\n\n\t\t\tvalue = this._adjustValue(value + step * this._increment(this.counter));\n\n\t\t\tif (!this.spinning || this._trigger(\"spin\", event, { value: value }) !== false) {\n\t\t\t\tthis._value(value);\n\t\t\t\tthis.counter++;\n\t\t\t}\n\t\t},\n\n\t\t_increment: function _increment(i) {\n\t\t\tvar incremental = this.options.incremental;\n\n\t\t\tif (incremental) {\n\t\t\t\treturn $.isFunction(incremental) ? incremental(i) : Math.floor(i * i * i / 50000 - i * i / 500 + 17 * i / 200 + 1);\n\t\t\t}\n\n\t\t\treturn 1;\n\t\t},\n\n\t\t_precision: function _precision() {\n\t\t\tvar precision = this._precisionOf(this.options.step);\n\t\t\tif (this.options.min !== null) {\n\t\t\t\tprecision = Math.max(precision, this._precisionOf(this.options.min));\n\t\t\t}\n\t\t\treturn precision;\n\t\t},\n\n\t\t_precisionOf: function _precisionOf(num) {\n\t\t\tvar str = num.toString(),\n\t\t\t    decimal = str.indexOf(\".\");\n\t\t\treturn decimal === -1 ? 0 : str.length - decimal - 1;\n\t\t},\n\n\t\t_adjustValue: function _adjustValue(value) {\n\t\t\tvar base,\n\t\t\t    aboveMin,\n\t\t\t    options = this.options;\n\n\t\t\t// make sure we're at a valid step\n\t\t\t// - find out where we are relative to the base (min or 0)\n\t\t\tbase = options.min !== null ? options.min : 0;\n\t\t\taboveMin = value - base;\n\t\t\t// - round to the nearest step\n\t\t\taboveMin = Math.round(aboveMin / options.step) * options.step;\n\t\t\t// - rounding is based on 0, so adjust back to our base\n\t\t\tvalue = base + aboveMin;\n\n\t\t\t// fix precision from bad JS floating point math\n\t\t\tvalue = parseFloat(value.toFixed(this._precision()));\n\n\t\t\t// clamp the value\n\t\t\tif (options.max !== null && value > options.max) {\n\t\t\t\treturn options.max;\n\t\t\t}\n\t\t\tif (options.min !== null && value < options.min) {\n\t\t\t\treturn options.min;\n\t\t\t}\n\n\t\t\treturn value;\n\t\t},\n\n\t\t_stop: function _stop(event) {\n\t\t\tif (!this.spinning) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tclearTimeout(this.timer);\n\t\t\tclearTimeout(this.mousewheelTimer);\n\t\t\tthis.counter = 0;\n\t\t\tthis.spinning = false;\n\t\t\tthis._trigger(\"stop\", event);\n\t\t},\n\n\t\t_setOption: function _setOption(key, value) {\n\t\t\tif (key === \"culture\" || key === \"numberFormat\") {\n\t\t\t\tvar prevValue = this._parse(this.element.val());\n\t\t\t\tthis.options[key] = value;\n\t\t\t\tthis.element.val(this._format(prevValue));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (key === \"max\" || key === \"min\" || key === \"step\") {\n\t\t\t\tif (typeof value === \"string\") {\n\t\t\t\t\tvalue = this._parse(value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (key === \"icons\") {\n\t\t\t\tthis.buttons.first().find(\".ui-icon\").removeClass(this.options.icons.up).addClass(value.up);\n\t\t\t\tthis.buttons.last().find(\".ui-icon\").removeClass(this.options.icons.down).addClass(value.down);\n\t\t\t}\n\n\t\t\tthis._super(key, value);\n\n\t\t\tif (key === \"disabled\") {\n\t\t\t\tthis.widget().toggleClass(\"ui-state-disabled\", !!value);\n\t\t\t\tthis.element.prop(\"disabled\", !!value);\n\t\t\t\tthis.buttons.button(value ? \"disable\" : \"enable\");\n\t\t\t}\n\t\t},\n\n\t\t_setOptions: spinner_modifier(function (options) {\n\t\t\tthis._super(options);\n\t\t}),\n\n\t\t_parse: function _parse(val) {\n\t\t\tif (typeof val === \"string\" && val !== \"\") {\n\t\t\t\tval = window.Globalize && this.options.numberFormat ? Globalize.parseFloat(val, 10, this.options.culture) : +val;\n\t\t\t}\n\t\t\treturn val === \"\" || isNaN(val) ? null : val;\n\t\t},\n\n\t\t_format: function _format(value) {\n\t\t\tif (value === \"\") {\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t\treturn window.Globalize && this.options.numberFormat ? Globalize.format(value, this.options.numberFormat, this.options.culture) : value;\n\t\t},\n\n\t\t_refresh: function _refresh() {\n\t\t\tthis.element.attr({\n\t\t\t\t\"aria-valuemin\": this.options.min,\n\t\t\t\t\"aria-valuemax\": this.options.max,\n\t\t\t\t// TODO: what should we do with values that can't be parsed?\n\t\t\t\t\"aria-valuenow\": this._parse(this.element.val())\n\t\t\t});\n\t\t},\n\n\t\tisValid: function isValid() {\n\t\t\tvar value = this.value();\n\n\t\t\t// null is invalid\n\t\t\tif (value === null) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// if value gets adjusted, it's invalid\n\t\t\treturn value === this._adjustValue(value);\n\t\t},\n\n\t\t// update the value without triggering change\n\t\t_value: function _value(value, allowAny) {\n\t\t\tvar parsed;\n\t\t\tif (value !== \"\") {\n\t\t\t\tparsed = this._parse(value);\n\t\t\t\tif (parsed !== null) {\n\t\t\t\t\tif (!allowAny) {\n\t\t\t\t\t\tparsed = this._adjustValue(parsed);\n\t\t\t\t\t}\n\t\t\t\t\tvalue = this._format(parsed);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.element.val(value);\n\t\t\tthis._refresh();\n\t\t},\n\n\t\t_destroy: function _destroy() {\n\t\t\tthis.element.removeClass(\"ui-spinner-input\").prop(\"disabled\", false).removeAttr(\"autocomplete\").removeAttr(\"role\").removeAttr(\"aria-valuemin\").removeAttr(\"aria-valuemax\").removeAttr(\"aria-valuenow\");\n\t\t\tthis.uiSpinner.replaceWith(this.element);\n\t\t},\n\n\t\tstepUp: spinner_modifier(function (steps) {\n\t\t\tthis._stepUp(steps);\n\t\t}),\n\t\t_stepUp: function _stepUp(steps) {\n\t\t\tif (this._start()) {\n\t\t\t\tthis._spin((steps || 1) * this.options.step);\n\t\t\t\tthis._stop();\n\t\t\t}\n\t\t},\n\n\t\tstepDown: spinner_modifier(function (steps) {\n\t\t\tthis._stepDown(steps);\n\t\t}),\n\t\t_stepDown: function _stepDown(steps) {\n\t\t\tif (this._start()) {\n\t\t\t\tthis._spin((steps || 1) * -this.options.step);\n\t\t\t\tthis._stop();\n\t\t\t}\n\t\t},\n\n\t\tpageUp: spinner_modifier(function (pages) {\n\t\t\tthis._stepUp((pages || 1) * this.options.page);\n\t\t}),\n\n\t\tpageDown: spinner_modifier(function (pages) {\n\t\t\tthis._stepDown((pages || 1) * this.options.page);\n\t\t}),\n\n\t\tvalue: function value(newVal) {\n\t\t\tif (!arguments.length) {\n\t\t\t\treturn this._parse(this.element.val());\n\t\t\t}\n\t\t\tspinner_modifier(this._value).call(this, newVal);\n\t\t},\n\n\t\twidget: function widget() {\n\t\t\treturn this.uiSpinner;\n\t\t}\n\t});\n\n\t/*!\n  * jQuery UI Tabs 1.11.4\n  * http://jqueryui.com\n  *\n  * Copyright jQuery Foundation and other contributors\n  * Released under the MIT license.\n  * http://jquery.org/license\n  *\n  * http://api.jqueryui.com/tabs/\n  */\n\n\tvar tabs = $.widget(\"ui.tabs\", {\n\t\tversion: \"1.11.4\",\n\t\tdelay: 300,\n\t\toptions: {\n\t\t\tactive: null,\n\t\t\tcollapsible: false,\n\t\t\tevent: \"click\",\n\t\t\theightStyle: \"content\",\n\t\t\thide: null,\n\t\t\tshow: null,\n\n\t\t\t// callbacks\n\t\t\tactivate: null,\n\t\t\tbeforeActivate: null,\n\t\t\tbeforeLoad: null,\n\t\t\tload: null\n\t\t},\n\n\t\t_isLocal: function () {\n\t\t\tvar rhash = /#.*$/;\n\n\t\t\treturn function (anchor) {\n\t\t\t\tvar anchorUrl, locationUrl;\n\n\t\t\t\t// support: IE7\n\t\t\t\t// IE7 doesn't normalize the href property when set via script (#9317)\n\t\t\t\tanchor = anchor.cloneNode(false);\n\n\t\t\t\tanchorUrl = anchor.href.replace(rhash, \"\");\n\t\t\t\tlocationUrl = location.href.replace(rhash, \"\");\n\n\t\t\t\t// decoding may throw an error if the URL isn't UTF-8 (#9518)\n\t\t\t\ttry {\n\t\t\t\t\tanchorUrl = decodeURIComponent(anchorUrl);\n\t\t\t\t} catch (error) {}\n\t\t\t\ttry {\n\t\t\t\t\tlocationUrl = decodeURIComponent(locationUrl);\n\t\t\t\t} catch (error) {}\n\n\t\t\t\treturn anchor.hash.length > 1 && anchorUrl === locationUrl;\n\t\t\t};\n\t\t}(),\n\n\t\t_create: function _create() {\n\t\t\tvar that = this,\n\t\t\t    options = this.options;\n\n\t\t\tthis.running = false;\n\n\t\t\tthis.element.addClass(\"ui-tabs ui-widget ui-widget-content ui-corner-all\").toggleClass(\"ui-tabs-collapsible\", options.collapsible);\n\n\t\t\tthis._processTabs();\n\t\t\toptions.active = this._initialActive();\n\n\t\t\t// Take disabling tabs via class attribute from HTML\n\t\t\t// into account and update option properly.\n\t\t\tif ($.isArray(options.disabled)) {\n\t\t\t\toptions.disabled = $.unique(options.disabled.concat($.map(this.tabs.filter(\".ui-state-disabled\"), function (li) {\n\t\t\t\t\treturn that.tabs.index(li);\n\t\t\t\t}))).sort();\n\t\t\t}\n\n\t\t\t// check for length avoids error when initializing empty list\n\t\t\tif (this.options.active !== false && this.anchors.length) {\n\t\t\t\tthis.active = this._findActive(options.active);\n\t\t\t} else {\n\t\t\t\tthis.active = $();\n\t\t\t}\n\n\t\t\tthis._refresh();\n\n\t\t\tif (this.active.length) {\n\t\t\t\tthis.load(options.active);\n\t\t\t}\n\t\t},\n\n\t\t_initialActive: function _initialActive() {\n\t\t\tvar active = this.options.active,\n\t\t\t    collapsible = this.options.collapsible,\n\t\t\t    locationHash = location.hash.substring(1);\n\n\t\t\tif (active === null) {\n\t\t\t\t// check the fragment identifier in the URL\n\t\t\t\tif (locationHash) {\n\t\t\t\t\tthis.tabs.each(function (i, tab) {\n\t\t\t\t\t\tif ($(tab).attr(\"aria-controls\") === locationHash) {\n\t\t\t\t\t\t\tactive = i;\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// check for a tab marked active via a class\n\t\t\t\tif (active === null) {\n\t\t\t\t\tactive = this.tabs.index(this.tabs.filter(\".ui-tabs-active\"));\n\t\t\t\t}\n\n\t\t\t\t// no active tab, set to false\n\t\t\t\tif (active === null || active === -1) {\n\t\t\t\t\tactive = this.tabs.length ? 0 : false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// handle numbers: negative, out of range\n\t\t\tif (active !== false) {\n\t\t\t\tactive = this.tabs.index(this.tabs.eq(active));\n\t\t\t\tif (active === -1) {\n\t\t\t\t\tactive = collapsible ? false : 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// don't allow collapsible: false and active: false\n\t\t\tif (!collapsible && active === false && this.anchors.length) {\n\t\t\t\tactive = 0;\n\t\t\t}\n\n\t\t\treturn active;\n\t\t},\n\n\t\t_getCreateEventData: function _getCreateEventData() {\n\t\t\treturn {\n\t\t\t\ttab: this.active,\n\t\t\t\tpanel: !this.active.length ? $() : this._getPanelForTab(this.active)\n\t\t\t};\n\t\t},\n\n\t\t_tabKeydown: function _tabKeydown(event) {\n\t\t\tvar focusedTab = $(this.document[0].activeElement).closest(\"li\"),\n\t\t\t    selectedIndex = this.tabs.index(focusedTab),\n\t\t\t    goingForward = true;\n\n\t\t\tif (this._handlePageNav(event)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tswitch (event.keyCode) {\n\t\t\t\tcase $.ui.keyCode.RIGHT:\n\t\t\t\tcase $.ui.keyCode.DOWN:\n\t\t\t\t\tselectedIndex++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase $.ui.keyCode.UP:\n\t\t\t\tcase $.ui.keyCode.LEFT:\n\t\t\t\t\tgoingForward = false;\n\t\t\t\t\tselectedIndex--;\n\t\t\t\t\tbreak;\n\t\t\t\tcase $.ui.keyCode.END:\n\t\t\t\t\tselectedIndex = this.anchors.length - 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase $.ui.keyCode.HOME:\n\t\t\t\t\tselectedIndex = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase $.ui.keyCode.SPACE:\n\t\t\t\t\t// Activate only, no collapsing\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\tclearTimeout(this.activating);\n\t\t\t\t\tthis._activate(selectedIndex);\n\t\t\t\t\treturn;\n\t\t\t\tcase $.ui.keyCode.ENTER:\n\t\t\t\t\t// Toggle (cancel delayed activation, allow collapsing)\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\tclearTimeout(this.activating);\n\t\t\t\t\t// Determine if we should collapse or activate\n\t\t\t\t\tthis._activate(selectedIndex === this.options.active ? false : selectedIndex);\n\t\t\t\t\treturn;\n\t\t\t\tdefault:\n\t\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Focus the appropriate tab, based on which key was pressed\n\t\t\tevent.preventDefault();\n\t\t\tclearTimeout(this.activating);\n\t\t\tselectedIndex = this._focusNextTab(selectedIndex, goingForward);\n\n\t\t\t// Navigating with control/command key will prevent automatic activation\n\t\t\tif (!event.ctrlKey && !event.metaKey) {\n\n\t\t\t\t// Update aria-selected immediately so that AT think the tab is already selected.\n\t\t\t\t// Otherwise AT may confuse the user by stating that they need to activate the tab,\n\t\t\t\t// but the tab will already be activated by the time the announcement finishes.\n\t\t\t\tfocusedTab.attr(\"aria-selected\", \"false\");\n\t\t\t\tthis.tabs.eq(selectedIndex).attr(\"aria-selected\", \"true\");\n\n\t\t\t\tthis.activating = this._delay(function () {\n\t\t\t\t\tthis.option(\"active\", selectedIndex);\n\t\t\t\t}, this.delay);\n\t\t\t}\n\t\t},\n\n\t\t_panelKeydown: function _panelKeydown(event) {\n\t\t\tif (this._handlePageNav(event)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Ctrl+up moves focus to the current tab\n\t\t\tif (event.ctrlKey && event.keyCode === $.ui.keyCode.UP) {\n\t\t\t\tevent.preventDefault();\n\t\t\t\tthis.active.focus();\n\t\t\t}\n\t\t},\n\n\t\t// Alt+page up/down moves focus to the previous/next tab (and activates)\n\t\t_handlePageNav: function _handlePageNav(event) {\n\t\t\tif (event.altKey && event.keyCode === $.ui.keyCode.PAGE_UP) {\n\t\t\t\tthis._activate(this._focusNextTab(this.options.active - 1, false));\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (event.altKey && event.keyCode === $.ui.keyCode.PAGE_DOWN) {\n\t\t\t\tthis._activate(this._focusNextTab(this.options.active + 1, true));\n\t\t\t\treturn true;\n\t\t\t}\n\t\t},\n\n\t\t_findNextTab: function _findNextTab(index, goingForward) {\n\t\t\tvar lastTabIndex = this.tabs.length - 1;\n\n\t\t\tfunction constrain() {\n\t\t\t\tif (index > lastTabIndex) {\n\t\t\t\t\tindex = 0;\n\t\t\t\t}\n\t\t\t\tif (index < 0) {\n\t\t\t\t\tindex = lastTabIndex;\n\t\t\t\t}\n\t\t\t\treturn index;\n\t\t\t}\n\n\t\t\twhile ($.inArray(constrain(), this.options.disabled) !== -1) {\n\t\t\t\tindex = goingForward ? index + 1 : index - 1;\n\t\t\t}\n\n\t\t\treturn index;\n\t\t},\n\n\t\t_focusNextTab: function _focusNextTab(index, goingForward) {\n\t\t\tindex = this._findNextTab(index, goingForward);\n\t\t\tthis.tabs.eq(index).focus();\n\t\t\treturn index;\n\t\t},\n\n\t\t_setOption: function _setOption(key, value) {\n\t\t\tif (key === \"active\") {\n\t\t\t\t// _activate() will handle invalid values and update this.options\n\t\t\t\tthis._activate(value);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (key === \"disabled\") {\n\t\t\t\t// don't use the widget factory's disabled handling\n\t\t\t\tthis._setupDisabled(value);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._super(key, value);\n\n\t\t\tif (key === \"collapsible\") {\n\t\t\t\tthis.element.toggleClass(\"ui-tabs-collapsible\", value);\n\t\t\t\t// Setting collapsible: false while collapsed; open first panel\n\t\t\t\tif (!value && this.options.active === false) {\n\t\t\t\t\tthis._activate(0);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (key === \"event\") {\n\t\t\t\tthis._setupEvents(value);\n\t\t\t}\n\n\t\t\tif (key === \"heightStyle\") {\n\t\t\t\tthis._setupHeightStyle(value);\n\t\t\t}\n\t\t},\n\n\t\t_sanitizeSelector: function _sanitizeSelector(hash) {\n\t\t\treturn hash ? hash.replace(/[!\"$%&'()*+,.\\/:;<=>?@\\[\\]\\^`{|}~]/g, \"\\\\$&\") : \"\";\n\t\t},\n\n\t\trefresh: function refresh() {\n\t\t\tvar options = this.options,\n\t\t\t    lis = this.tablist.children(\":has(a[href])\");\n\n\t\t\t// get disabled tabs from class attribute from HTML\n\t\t\t// this will get converted to a boolean if needed in _refresh()\n\t\t\toptions.disabled = $.map(lis.filter(\".ui-state-disabled\"), function (tab) {\n\t\t\t\treturn lis.index(tab);\n\t\t\t});\n\n\t\t\tthis._processTabs();\n\n\t\t\t// was collapsed or no tabs\n\t\t\tif (options.active === false || !this.anchors.length) {\n\t\t\t\toptions.active = false;\n\t\t\t\tthis.active = $();\n\t\t\t\t// was active, but active tab is gone\n\t\t\t} else if (this.active.length && !$.contains(this.tablist[0], this.active[0])) {\n\t\t\t\t// all remaining tabs are disabled\n\t\t\t\tif (this.tabs.length === options.disabled.length) {\n\t\t\t\t\toptions.active = false;\n\t\t\t\t\tthis.active = $();\n\t\t\t\t\t// activate previous tab\n\t\t\t\t} else {\n\t\t\t\t\tthis._activate(this._findNextTab(Math.max(0, options.active - 1), false));\n\t\t\t\t}\n\t\t\t\t// was active, active tab still exists\n\t\t\t} else {\n\t\t\t\t// make sure active index is correct\n\t\t\t\toptions.active = this.tabs.index(this.active);\n\t\t\t}\n\n\t\t\tthis._refresh();\n\t\t},\n\n\t\t_refresh: function _refresh() {\n\t\t\tthis._setupDisabled(this.options.disabled);\n\t\t\tthis._setupEvents(this.options.event);\n\t\t\tthis._setupHeightStyle(this.options.heightStyle);\n\n\t\t\tthis.tabs.not(this.active).attr({\n\t\t\t\t\"aria-selected\": \"false\",\n\t\t\t\t\"aria-expanded\": \"false\",\n\t\t\t\ttabIndex: -1\n\t\t\t});\n\t\t\tthis.panels.not(this._getPanelForTab(this.active)).hide().attr({\n\t\t\t\t\"aria-hidden\": \"true\"\n\t\t\t});\n\n\t\t\t// Make sure one tab is in the tab order\n\t\t\tif (!this.active.length) {\n\t\t\t\tthis.tabs.eq(0).attr(\"tabIndex\", 0);\n\t\t\t} else {\n\t\t\t\tthis.active.addClass(\"ui-tabs-active ui-state-active\").attr({\n\t\t\t\t\t\"aria-selected\": \"true\",\n\t\t\t\t\t\"aria-expanded\": \"true\",\n\t\t\t\t\ttabIndex: 0\n\t\t\t\t});\n\t\t\t\tthis._getPanelForTab(this.active).show().attr({\n\t\t\t\t\t\"aria-hidden\": \"false\"\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\n\t\t_processTabs: function _processTabs() {\n\t\t\tvar that = this,\n\t\t\t    prevTabs = this.tabs,\n\t\t\t    prevAnchors = this.anchors,\n\t\t\t    prevPanels = this.panels;\n\n\t\t\tthis.tablist = this._getList().addClass(\"ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all\").attr(\"role\", \"tablist\")\n\n\t\t\t// Prevent users from focusing disabled tabs via click\n\t\t\t.delegate(\"> li\", \"mousedown\" + this.eventNamespace, function (event) {\n\t\t\t\tif ($(this).is(\".ui-state-disabled\")) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\t\t\t})\n\n\t\t\t// support: IE <9\n\t\t\t// Preventing the default action in mousedown doesn't prevent IE\n\t\t\t// from focusing the element, so if the anchor gets focused, blur.\n\t\t\t// We don't have to worry about focusing the previously focused\n\t\t\t// element since clicking on a non-focusable element should focus\n\t\t\t// the body anyway.\n\t\t\t.delegate(\".ui-tabs-anchor\", \"focus\" + this.eventNamespace, function () {\n\t\t\t\tif ($(this).closest(\"li\").is(\".ui-state-disabled\")) {\n\t\t\t\t\tthis.blur();\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tthis.tabs = this.tablist.find(\"> li:has(a[href])\").addClass(\"ui-state-default ui-corner-top\").attr({\n\t\t\t\trole: \"tab\",\n\t\t\t\ttabIndex: -1\n\t\t\t});\n\n\t\t\tthis.anchors = this.tabs.map(function () {\n\t\t\t\treturn $(\"a\", this)[0];\n\t\t\t}).addClass(\"ui-tabs-anchor\").attr({\n\t\t\t\trole: \"presentation\",\n\t\t\t\ttabIndex: -1\n\t\t\t});\n\n\t\t\tthis.panels = $();\n\n\t\t\tthis.anchors.each(function (i, anchor) {\n\t\t\t\tvar selector,\n\t\t\t\t    panel,\n\t\t\t\t    panelId,\n\t\t\t\t    anchorId = $(anchor).uniqueId().attr(\"id\"),\n\t\t\t\t    tab = $(anchor).closest(\"li\"),\n\t\t\t\t    originalAriaControls = tab.attr(\"aria-controls\");\n\n\t\t\t\t// inline tab\n\t\t\t\tif (that._isLocal(anchor)) {\n\t\t\t\t\tselector = anchor.hash;\n\t\t\t\t\tpanelId = selector.substring(1);\n\t\t\t\t\tpanel = that.element.find(that._sanitizeSelector(selector));\n\t\t\t\t\t// remote tab\n\t\t\t\t} else {\n\t\t\t\t\t// If the tab doesn't already have aria-controls,\n\t\t\t\t\t// generate an id by using a throw-away element\n\t\t\t\t\tpanelId = tab.attr(\"aria-controls\") || $({}).uniqueId()[0].id;\n\t\t\t\t\tselector = \"#\" + panelId;\n\t\t\t\t\tpanel = that.element.find(selector);\n\t\t\t\t\tif (!panel.length) {\n\t\t\t\t\t\tpanel = that._createPanel(panelId);\n\t\t\t\t\t\tpanel.insertAfter(that.panels[i - 1] || that.tablist);\n\t\t\t\t\t}\n\t\t\t\t\tpanel.attr(\"aria-live\", \"polite\");\n\t\t\t\t}\n\n\t\t\t\tif (panel.length) {\n\t\t\t\t\tthat.panels = that.panels.add(panel);\n\t\t\t\t}\n\t\t\t\tif (originalAriaControls) {\n\t\t\t\t\ttab.data(\"ui-tabs-aria-controls\", originalAriaControls);\n\t\t\t\t}\n\t\t\t\ttab.attr({\n\t\t\t\t\t\"aria-controls\": panelId,\n\t\t\t\t\t\"aria-labelledby\": anchorId\n\t\t\t\t});\n\t\t\t\tpanel.attr(\"aria-labelledby\", anchorId);\n\t\t\t});\n\n\t\t\tthis.panels.addClass(\"ui-tabs-panel ui-widget-content ui-corner-bottom\").attr(\"role\", \"tabpanel\");\n\n\t\t\t// Avoid memory leaks (#10056)\n\t\t\tif (prevTabs) {\n\t\t\t\tthis._off(prevTabs.not(this.tabs));\n\t\t\t\tthis._off(prevAnchors.not(this.anchors));\n\t\t\t\tthis._off(prevPanels.not(this.panels));\n\t\t\t}\n\t\t},\n\n\t\t// allow overriding how to find the list for rare usage scenarios (#7715)\n\t\t_getList: function _getList() {\n\t\t\treturn this.tablist || this.element.find(\"ol,ul\").eq(0);\n\t\t},\n\n\t\t_createPanel: function _createPanel(id) {\n\t\t\treturn $(\"<div>\").attr(\"id\", id).addClass(\"ui-tabs-panel ui-widget-content ui-corner-bottom\").data(\"ui-tabs-destroy\", true);\n\t\t},\n\n\t\t_setupDisabled: function _setupDisabled(disabled) {\n\t\t\tif ($.isArray(disabled)) {\n\t\t\t\tif (!disabled.length) {\n\t\t\t\t\tdisabled = false;\n\t\t\t\t} else if (disabled.length === this.anchors.length) {\n\t\t\t\t\tdisabled = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// disable tabs\n\t\t\tfor (var i = 0, li; li = this.tabs[i]; i++) {\n\t\t\t\tif (disabled === true || $.inArray(i, disabled) !== -1) {\n\t\t\t\t\t$(li).addClass(\"ui-state-disabled\").attr(\"aria-disabled\", \"true\");\n\t\t\t\t} else {\n\t\t\t\t\t$(li).removeClass(\"ui-state-disabled\").removeAttr(\"aria-disabled\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.options.disabled = disabled;\n\t\t},\n\n\t\t_setupEvents: function _setupEvents(event) {\n\t\t\tvar events = {};\n\t\t\tif (event) {\n\t\t\t\t$.each(event.split(\" \"), function (index, eventName) {\n\t\t\t\t\tevents[eventName] = \"_eventHandler\";\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tthis._off(this.anchors.add(this.tabs).add(this.panels));\n\t\t\t// Always prevent the default action, even when disabled\n\t\t\tthis._on(true, this.anchors, {\n\t\t\t\tclick: function click(event) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\t\t\t});\n\t\t\tthis._on(this.anchors, events);\n\t\t\tthis._on(this.tabs, { keydown: \"_tabKeydown\" });\n\t\t\tthis._on(this.panels, { keydown: \"_panelKeydown\" });\n\n\t\t\tthis._focusable(this.tabs);\n\t\t\tthis._hoverable(this.tabs);\n\t\t},\n\n\t\t_setupHeightStyle: function _setupHeightStyle(heightStyle) {\n\t\t\tvar maxHeight,\n\t\t\t    parent = this.element.parent();\n\n\t\t\tif (heightStyle === \"fill\") {\n\t\t\t\tmaxHeight = parent.height();\n\t\t\t\tmaxHeight -= this.element.outerHeight() - this.element.height();\n\n\t\t\t\tthis.element.siblings(\":visible\").each(function () {\n\t\t\t\t\tvar elem = $(this),\n\t\t\t\t\t    position = elem.css(\"position\");\n\n\t\t\t\t\tif (position === \"absolute\" || position === \"fixed\") {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tmaxHeight -= elem.outerHeight(true);\n\t\t\t\t});\n\n\t\t\t\tthis.element.children().not(this.panels).each(function () {\n\t\t\t\t\tmaxHeight -= $(this).outerHeight(true);\n\t\t\t\t});\n\n\t\t\t\tthis.panels.each(function () {\n\t\t\t\t\t$(this).height(Math.max(0, maxHeight - $(this).innerHeight() + $(this).height()));\n\t\t\t\t}).css(\"overflow\", \"auto\");\n\t\t\t} else if (heightStyle === \"auto\") {\n\t\t\t\tmaxHeight = 0;\n\t\t\t\tthis.panels.each(function () {\n\t\t\t\t\tmaxHeight = Math.max(maxHeight, $(this).height(\"\").height());\n\t\t\t\t}).height(maxHeight);\n\t\t\t}\n\t\t},\n\n\t\t_eventHandler: function _eventHandler(event) {\n\t\t\tvar options = this.options,\n\t\t\t    active = this.active,\n\t\t\t    anchor = $(event.currentTarget),\n\t\t\t    tab = anchor.closest(\"li\"),\n\t\t\t    clickedIsActive = tab[0] === active[0],\n\t\t\t    collapsing = clickedIsActive && options.collapsible,\n\t\t\t    toShow = collapsing ? $() : this._getPanelForTab(tab),\n\t\t\t    toHide = !active.length ? $() : this._getPanelForTab(active),\n\t\t\t    eventData = {\n\t\t\t\toldTab: active,\n\t\t\t\toldPanel: toHide,\n\t\t\t\tnewTab: collapsing ? $() : tab,\n\t\t\t\tnewPanel: toShow\n\t\t\t};\n\n\t\t\tevent.preventDefault();\n\n\t\t\tif (tab.hasClass(\"ui-state-disabled\") ||\n\t\t\t// tab is already loading\n\t\t\ttab.hasClass(\"ui-tabs-loading\") ||\n\t\t\t// can't switch durning an animation\n\t\t\tthis.running ||\n\t\t\t// click on active header, but not collapsible\n\t\t\tclickedIsActive && !options.collapsible ||\n\t\t\t// allow canceling activation\n\t\t\tthis._trigger(\"beforeActivate\", event, eventData) === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\toptions.active = collapsing ? false : this.tabs.index(tab);\n\n\t\t\tthis.active = clickedIsActive ? $() : tab;\n\t\t\tif (this.xhr) {\n\t\t\t\tthis.xhr.abort();\n\t\t\t}\n\n\t\t\tif (!toHide.length && !toShow.length) {\n\t\t\t\t$.error(\"jQuery UI Tabs: Mismatching fragment identifier.\");\n\t\t\t}\n\n\t\t\tif (toShow.length) {\n\t\t\t\tthis.load(this.tabs.index(tab), event);\n\t\t\t}\n\t\t\tthis._toggle(event, eventData);\n\t\t},\n\n\t\t// handles show/hide for selecting tabs\n\t\t_toggle: function _toggle(event, eventData) {\n\t\t\tvar that = this,\n\t\t\t    toShow = eventData.newPanel,\n\t\t\t    toHide = eventData.oldPanel;\n\n\t\t\tthis.running = true;\n\n\t\t\tfunction complete() {\n\t\t\t\tthat.running = false;\n\t\t\t\tthat._trigger(\"activate\", event, eventData);\n\t\t\t}\n\n\t\t\tfunction show() {\n\t\t\t\teventData.newTab.closest(\"li\").addClass(\"ui-tabs-active ui-state-active\");\n\n\t\t\t\tif (toShow.length && that.options.show) {\n\t\t\t\t\tthat._show(toShow, that.options.show, complete);\n\t\t\t\t} else {\n\t\t\t\t\ttoShow.show();\n\t\t\t\t\tcomplete();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// start out by hiding, then showing, then completing\n\t\t\tif (toHide.length && this.options.hide) {\n\t\t\t\tthis._hide(toHide, this.options.hide, function () {\n\t\t\t\t\teventData.oldTab.closest(\"li\").removeClass(\"ui-tabs-active ui-state-active\");\n\t\t\t\t\tshow();\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\teventData.oldTab.closest(\"li\").removeClass(\"ui-tabs-active ui-state-active\");\n\t\t\t\ttoHide.hide();\n\t\t\t\tshow();\n\t\t\t}\n\n\t\t\ttoHide.attr(\"aria-hidden\", \"true\");\n\t\t\teventData.oldTab.attr({\n\t\t\t\t\"aria-selected\": \"false\",\n\t\t\t\t\"aria-expanded\": \"false\"\n\t\t\t});\n\t\t\t// If we're switching tabs, remove the old tab from the tab order.\n\t\t\t// If we're opening from collapsed state, remove the previous tab from the tab order.\n\t\t\t// If we're collapsing, then keep the collapsing tab in the tab order.\n\t\t\tif (toShow.length && toHide.length) {\n\t\t\t\teventData.oldTab.attr(\"tabIndex\", -1);\n\t\t\t} else if (toShow.length) {\n\t\t\t\tthis.tabs.filter(function () {\n\t\t\t\t\treturn $(this).attr(\"tabIndex\") === 0;\n\t\t\t\t}).attr(\"tabIndex\", -1);\n\t\t\t}\n\n\t\t\ttoShow.attr(\"aria-hidden\", \"false\");\n\t\t\teventData.newTab.attr({\n\t\t\t\t\"aria-selected\": \"true\",\n\t\t\t\t\"aria-expanded\": \"true\",\n\t\t\t\ttabIndex: 0\n\t\t\t});\n\t\t},\n\n\t\t_activate: function _activate(index) {\n\t\t\tvar anchor,\n\t\t\t    active = this._findActive(index);\n\n\t\t\t// trying to activate the already active panel\n\t\t\tif (active[0] === this.active[0]) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// trying to collapse, simulate a click on the current active header\n\t\t\tif (!active.length) {\n\t\t\t\tactive = this.active;\n\t\t\t}\n\n\t\t\tanchor = active.find(\".ui-tabs-anchor\")[0];\n\t\t\tthis._eventHandler({\n\t\t\t\ttarget: anchor,\n\t\t\t\tcurrentTarget: anchor,\n\t\t\t\tpreventDefault: $.noop\n\t\t\t});\n\t\t},\n\n\t\t_findActive: function _findActive(index) {\n\t\t\treturn index === false ? $() : this.tabs.eq(index);\n\t\t},\n\n\t\t_getIndex: function _getIndex(index) {\n\t\t\t// meta-function to give users option to provide a href string instead of a numerical index.\n\t\t\tif (typeof index === \"string\") {\n\t\t\t\tindex = this.anchors.index(this.anchors.filter(\"[href$='\" + index + \"']\"));\n\t\t\t}\n\n\t\t\treturn index;\n\t\t},\n\n\t\t_destroy: function _destroy() {\n\t\t\tif (this.xhr) {\n\t\t\t\tthis.xhr.abort();\n\t\t\t}\n\n\t\t\tthis.element.removeClass(\"ui-tabs ui-widget ui-widget-content ui-corner-all ui-tabs-collapsible\");\n\n\t\t\tthis.tablist.removeClass(\"ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all\").removeAttr(\"role\");\n\n\t\t\tthis.anchors.removeClass(\"ui-tabs-anchor\").removeAttr(\"role\").removeAttr(\"tabIndex\").removeUniqueId();\n\n\t\t\tthis.tablist.unbind(this.eventNamespace);\n\n\t\t\tthis.tabs.add(this.panels).each(function () {\n\t\t\t\tif ($.data(this, \"ui-tabs-destroy\")) {\n\t\t\t\t\t$(this).remove();\n\t\t\t\t} else {\n\t\t\t\t\t$(this).removeClass(\"ui-state-default ui-state-active ui-state-disabled \" + \"ui-corner-top ui-corner-bottom ui-widget-content ui-tabs-active ui-tabs-panel\").removeAttr(\"tabIndex\").removeAttr(\"aria-live\").removeAttr(\"aria-busy\").removeAttr(\"aria-selected\").removeAttr(\"aria-labelledby\").removeAttr(\"aria-hidden\").removeAttr(\"aria-expanded\").removeAttr(\"role\");\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tthis.tabs.each(function () {\n\t\t\t\tvar li = $(this),\n\t\t\t\t    prev = li.data(\"ui-tabs-aria-controls\");\n\t\t\t\tif (prev) {\n\t\t\t\t\tli.attr(\"aria-controls\", prev).removeData(\"ui-tabs-aria-controls\");\n\t\t\t\t} else {\n\t\t\t\t\tli.removeAttr(\"aria-controls\");\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tthis.panels.show();\n\n\t\t\tif (this.options.heightStyle !== \"content\") {\n\t\t\t\tthis.panels.css(\"height\", \"\");\n\t\t\t}\n\t\t},\n\n\t\tenable: function enable(index) {\n\t\t\tvar disabled = this.options.disabled;\n\t\t\tif (disabled === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (index === undefined) {\n\t\t\t\tdisabled = false;\n\t\t\t} else {\n\t\t\t\tindex = this._getIndex(index);\n\t\t\t\tif ($.isArray(disabled)) {\n\t\t\t\t\tdisabled = $.map(disabled, function (num) {\n\t\t\t\t\t\treturn num !== index ? num : null;\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tdisabled = $.map(this.tabs, function (li, num) {\n\t\t\t\t\t\treturn num !== index ? num : null;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._setupDisabled(disabled);\n\t\t},\n\n\t\tdisable: function disable(index) {\n\t\t\tvar disabled = this.options.disabled;\n\t\t\tif (disabled === true) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (index === undefined) {\n\t\t\t\tdisabled = true;\n\t\t\t} else {\n\t\t\t\tindex = this._getIndex(index);\n\t\t\t\tif ($.inArray(index, disabled) !== -1) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif ($.isArray(disabled)) {\n\t\t\t\t\tdisabled = $.merge([index], disabled).sort();\n\t\t\t\t} else {\n\t\t\t\t\tdisabled = [index];\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._setupDisabled(disabled);\n\t\t},\n\n\t\tload: function load(index, event) {\n\t\t\tindex = this._getIndex(index);\n\t\t\tvar that = this,\n\t\t\t    tab = this.tabs.eq(index),\n\t\t\t    anchor = tab.find(\".ui-tabs-anchor\"),\n\t\t\t    panel = this._getPanelForTab(tab),\n\t\t\t    eventData = {\n\t\t\t\ttab: tab,\n\t\t\t\tpanel: panel\n\t\t\t},\n\t\t\t    complete = function complete(jqXHR, status) {\n\t\t\t\tif (status === \"abort\") {\n\t\t\t\t\tthat.panels.stop(false, true);\n\t\t\t\t}\n\n\t\t\t\ttab.removeClass(\"ui-tabs-loading\");\n\t\t\t\tpanel.removeAttr(\"aria-busy\");\n\n\t\t\t\tif (jqXHR === that.xhr) {\n\t\t\t\t\tdelete that.xhr;\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// not remote\n\t\t\tif (this._isLocal(anchor[0])) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.xhr = $.ajax(this._ajaxSettings(anchor, event, eventData));\n\n\t\t\t// support: jQuery <1.8\n\t\t\t// jQuery <1.8 returns false if the request is canceled in beforeSend,\n\t\t\t// but as of 1.8, $.ajax() always returns a jqXHR object.\n\t\t\tif (this.xhr && this.xhr.statusText !== \"canceled\") {\n\t\t\t\ttab.addClass(\"ui-tabs-loading\");\n\t\t\t\tpanel.attr(\"aria-busy\", \"true\");\n\n\t\t\t\tthis.xhr.done(function (response, status, jqXHR) {\n\t\t\t\t\t// support: jQuery <1.8\n\t\t\t\t\t// http://bugs.jquery.com/ticket/11778\n\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\tpanel.html(response);\n\t\t\t\t\t\tthat._trigger(\"load\", event, eventData);\n\n\t\t\t\t\t\tcomplete(jqXHR, status);\n\t\t\t\t\t}, 1);\n\t\t\t\t}).fail(function (jqXHR, status) {\n\t\t\t\t\t// support: jQuery <1.8\n\t\t\t\t\t// http://bugs.jquery.com/ticket/11778\n\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\tcomplete(jqXHR, status);\n\t\t\t\t\t}, 1);\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\n\t\t_ajaxSettings: function _ajaxSettings(anchor, event, eventData) {\n\t\t\tvar that = this;\n\t\t\treturn {\n\t\t\t\turl: anchor.attr(\"href\"),\n\t\t\t\tbeforeSend: function beforeSend(jqXHR, settings) {\n\t\t\t\t\treturn that._trigger(\"beforeLoad\", event, $.extend({ jqXHR: jqXHR, ajaxSettings: settings }, eventData));\n\t\t\t\t}\n\t\t\t};\n\t\t},\n\n\t\t_getPanelForTab: function _getPanelForTab(tab) {\n\t\t\tvar id = $(tab).attr(\"aria-controls\");\n\t\t\treturn this.element.find(this._sanitizeSelector(\"#\" + id));\n\t\t}\n\t});\n\n\t/*!\n  * jQuery UI Tooltip 1.11.4\n  * http://jqueryui.com\n  *\n  * Copyright jQuery Foundation and other contributors\n  * Released under the MIT license.\n  * http://jquery.org/license\n  *\n  * http://api.jqueryui.com/tooltip/\n  */\n\n\tvar tooltip = $.widget(\"ui.tooltip\", {\n\t\tversion: \"1.11.4\",\n\t\toptions: {\n\t\t\tcontent: function content() {\n\t\t\t\t// support: IE<9, Opera in jQuery <1.7\n\t\t\t\t// .text() can't accept undefined, so coerce to a string\n\t\t\t\tvar title = $(this).attr(\"title\") || \"\";\n\t\t\t\t// Escape title, since we're going from an attribute to raw HTML\n\t\t\t\treturn $(\"<a>\").text(title).html();\n\t\t\t},\n\t\t\thide: true,\n\t\t\t// Disabled elements have inconsistent behavior across browsers (#8661)\n\t\t\titems: \"[title]:not([disabled])\",\n\t\t\tposition: {\n\t\t\t\tmy: \"left top+15\",\n\t\t\t\tat: \"left bottom\",\n\t\t\t\tcollision: \"flipfit flip\"\n\t\t\t},\n\t\t\tshow: true,\n\t\t\ttooltipClass: null,\n\t\t\ttrack: false,\n\n\t\t\t// callbacks\n\t\t\tclose: null,\n\t\t\topen: null\n\t\t},\n\n\t\t_addDescribedBy: function _addDescribedBy(elem, id) {\n\t\t\tvar describedby = (elem.attr(\"aria-describedby\") || \"\").split(/\\s+/);\n\t\t\tdescribedby.push(id);\n\t\t\telem.data(\"ui-tooltip-id\", id).attr(\"aria-describedby\", $.trim(describedby.join(\" \")));\n\t\t},\n\n\t\t_removeDescribedBy: function _removeDescribedBy(elem) {\n\t\t\tvar id = elem.data(\"ui-tooltip-id\"),\n\t\t\t    describedby = (elem.attr(\"aria-describedby\") || \"\").split(/\\s+/),\n\t\t\t    index = $.inArray(id, describedby);\n\n\t\t\tif (index !== -1) {\n\t\t\t\tdescribedby.splice(index, 1);\n\t\t\t}\n\n\t\t\telem.removeData(\"ui-tooltip-id\");\n\t\t\tdescribedby = $.trim(describedby.join(\" \"));\n\t\t\tif (describedby) {\n\t\t\t\telem.attr(\"aria-describedby\", describedby);\n\t\t\t} else {\n\t\t\t\telem.removeAttr(\"aria-describedby\");\n\t\t\t}\n\t\t},\n\n\t\t_create: function _create() {\n\t\t\tthis._on({\n\t\t\t\tmouseover: \"open\",\n\t\t\t\tfocusin: \"open\"\n\t\t\t});\n\n\t\t\t// IDs of generated tooltips, needed for destroy\n\t\t\tthis.tooltips = {};\n\n\t\t\t// IDs of parent tooltips where we removed the title attribute\n\t\t\tthis.parents = {};\n\n\t\t\tif (this.options.disabled) {\n\t\t\t\tthis._disable();\n\t\t\t}\n\n\t\t\t// Append the aria-live region so tooltips announce correctly\n\t\t\tthis.liveRegion = $(\"<div>\").attr({\n\t\t\t\trole: \"log\",\n\t\t\t\t\"aria-live\": \"assertive\",\n\t\t\t\t\"aria-relevant\": \"additions\"\n\t\t\t}).addClass(\"ui-helper-hidden-accessible\").appendTo(this.document[0].body);\n\t\t},\n\n\t\t_setOption: function _setOption(key, value) {\n\t\t\tvar that = this;\n\n\t\t\tif (key === \"disabled\") {\n\t\t\t\tthis[value ? \"_disable\" : \"_enable\"]();\n\t\t\t\tthis.options[key] = value;\n\t\t\t\t// disable element style changes\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._super(key, value);\n\n\t\t\tif (key === \"content\") {\n\t\t\t\t$.each(this.tooltips, function (id, tooltipData) {\n\t\t\t\t\tthat._updateContent(tooltipData.element);\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\n\t\t_disable: function _disable() {\n\t\t\tvar that = this;\n\n\t\t\t// close open tooltips\n\t\t\t$.each(this.tooltips, function (id, tooltipData) {\n\t\t\t\tvar event = $.Event(\"blur\");\n\t\t\t\tevent.target = event.currentTarget = tooltipData.element[0];\n\t\t\t\tthat.close(event, true);\n\t\t\t});\n\n\t\t\t// remove title attributes to prevent native tooltips\n\t\t\tthis.element.find(this.options.items).addBack().each(function () {\n\t\t\t\tvar element = $(this);\n\t\t\t\tif (element.is(\"[title]\")) {\n\t\t\t\t\telement.data(\"ui-tooltip-title\", element.attr(\"title\")).removeAttr(\"title\");\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\t_enable: function _enable() {\n\t\t\t// restore title attributes\n\t\t\tthis.element.find(this.options.items).addBack().each(function () {\n\t\t\t\tvar element = $(this);\n\t\t\t\tif (element.data(\"ui-tooltip-title\")) {\n\t\t\t\t\telement.attr(\"title\", element.data(\"ui-tooltip-title\"));\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\topen: function open(event) {\n\t\t\tvar that = this,\n\t\t\t    target = $(event ? event.target : this.element)\n\t\t\t// we need closest here due to mouseover bubbling,\n\t\t\t// but always pointing at the same event target\n\t\t\t.closest(this.options.items);\n\n\t\t\t// No element to show a tooltip for or the tooltip is already open\n\t\t\tif (!target.length || target.data(\"ui-tooltip-id\")) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (target.attr(\"title\")) {\n\t\t\t\ttarget.data(\"ui-tooltip-title\", target.attr(\"title\"));\n\t\t\t}\n\n\t\t\ttarget.data(\"ui-tooltip-open\", true);\n\n\t\t\t// kill parent tooltips, custom or native, for hover\n\t\t\tif (event && event.type === \"mouseover\") {\n\t\t\t\ttarget.parents().each(function () {\n\t\t\t\t\tvar parent = $(this),\n\t\t\t\t\t    blurEvent;\n\t\t\t\t\tif (parent.data(\"ui-tooltip-open\")) {\n\t\t\t\t\t\tblurEvent = $.Event(\"blur\");\n\t\t\t\t\t\tblurEvent.target = blurEvent.currentTarget = this;\n\t\t\t\t\t\tthat.close(blurEvent, true);\n\t\t\t\t\t}\n\t\t\t\t\tif (parent.attr(\"title\")) {\n\t\t\t\t\t\tparent.uniqueId();\n\t\t\t\t\t\tthat.parents[this.id] = {\n\t\t\t\t\t\t\telement: this,\n\t\t\t\t\t\t\ttitle: parent.attr(\"title\")\n\t\t\t\t\t\t};\n\t\t\t\t\t\tparent.attr(\"title\", \"\");\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tthis._registerCloseHandlers(event, target);\n\t\t\tthis._updateContent(target, event);\n\t\t},\n\n\t\t_updateContent: function _updateContent(target, event) {\n\t\t\tvar content,\n\t\t\t    contentOption = this.options.content,\n\t\t\t    that = this,\n\t\t\t    eventType = event ? event.type : null;\n\n\t\t\tif (typeof contentOption === \"string\") {\n\t\t\t\treturn this._open(event, target, contentOption);\n\t\t\t}\n\n\t\t\tcontent = contentOption.call(target[0], function (response) {\n\n\t\t\t\t// IE may instantly serve a cached response for ajax requests\n\t\t\t\t// delay this call to _open so the other call to _open runs first\n\t\t\t\tthat._delay(function () {\n\n\t\t\t\t\t// Ignore async response if tooltip was closed already\n\t\t\t\t\tif (!target.data(\"ui-tooltip-open\")) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// jQuery creates a special event for focusin when it doesn't\n\t\t\t\t\t// exist natively. To improve performance, the native event\n\t\t\t\t\t// object is reused and the type is changed. Therefore, we can't\n\t\t\t\t\t// rely on the type being correct after the event finished\n\t\t\t\t\t// bubbling, so we set it back to the previous value. (#8740)\n\t\t\t\t\tif (event) {\n\t\t\t\t\t\tevent.type = eventType;\n\t\t\t\t\t}\n\t\t\t\t\tthis._open(event, target, response);\n\t\t\t\t});\n\t\t\t});\n\t\t\tif (content) {\n\t\t\t\tthis._open(event, target, content);\n\t\t\t}\n\t\t},\n\n\t\t_open: function _open(event, target, content) {\n\t\t\tvar tooltipData,\n\t\t\t    tooltip,\n\t\t\t    delayedShow,\n\t\t\t    a11yContent,\n\t\t\t    positionOption = $.extend({}, this.options.position);\n\n\t\t\tif (!content) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Content can be updated multiple times. If the tooltip already\n\t\t\t// exists, then just update the content and bail.\n\t\t\ttooltipData = this._find(target);\n\t\t\tif (tooltipData) {\n\t\t\t\ttooltipData.tooltip.find(\".ui-tooltip-content\").html(content);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// if we have a title, clear it to prevent the native tooltip\n\t\t\t// we have to check first to avoid defining a title if none exists\n\t\t\t// (we don't want to cause an element to start matching [title])\n\t\t\t//\n\t\t\t// We use removeAttr only for key events, to allow IE to export the correct\n\t\t\t// accessible attributes. For mouse events, set to empty string to avoid\n\t\t\t// native tooltip showing up (happens only when removing inside mouseover).\n\t\t\tif (target.is(\"[title]\")) {\n\t\t\t\tif (event && event.type === \"mouseover\") {\n\t\t\t\t\ttarget.attr(\"title\", \"\");\n\t\t\t\t} else {\n\t\t\t\t\ttarget.removeAttr(\"title\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttooltipData = this._tooltip(target);\n\t\t\ttooltip = tooltipData.tooltip;\n\t\t\tthis._addDescribedBy(target, tooltip.attr(\"id\"));\n\t\t\ttooltip.find(\".ui-tooltip-content\").html(content);\n\n\t\t\t// Support: Voiceover on OS X, JAWS on IE <= 9\n\t\t\t// JAWS announces deletions even when aria-relevant=\"additions\"\n\t\t\t// Voiceover will sometimes re-read the entire log region's contents from the beginning\n\t\t\tthis.liveRegion.children().hide();\n\t\t\tif (content.clone) {\n\t\t\t\ta11yContent = content.clone();\n\t\t\t\ta11yContent.removeAttr(\"id\").find(\"[id]\").removeAttr(\"id\");\n\t\t\t} else {\n\t\t\t\ta11yContent = content;\n\t\t\t}\n\t\t\t$(\"<div>\").html(a11yContent).appendTo(this.liveRegion);\n\n\t\t\tfunction position(event) {\n\t\t\t\tpositionOption.of = event;\n\t\t\t\tif (tooltip.is(\":hidden\")) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\ttooltip.position(positionOption);\n\t\t\t}\n\t\t\tif (this.options.track && event && /^mouse/.test(event.type)) {\n\t\t\t\tthis._on(this.document, {\n\t\t\t\t\tmousemove: position\n\t\t\t\t});\n\t\t\t\t// trigger once to override element-relative positioning\n\t\t\t\tposition(event);\n\t\t\t} else {\n\t\t\t\ttooltip.position($.extend({\n\t\t\t\t\tof: target\n\t\t\t\t}, this.options.position));\n\t\t\t}\n\n\t\t\ttooltip.hide();\n\n\t\t\tthis._show(tooltip, this.options.show);\n\t\t\t// Handle tracking tooltips that are shown with a delay (#8644). As soon\n\t\t\t// as the tooltip is visible, position the tooltip using the most recent\n\t\t\t// event.\n\t\t\tif (this.options.show && this.options.show.delay) {\n\t\t\t\tdelayedShow = this.delayedShow = setInterval(function () {\n\t\t\t\t\tif (tooltip.is(\":visible\")) {\n\t\t\t\t\t\tposition(positionOption.of);\n\t\t\t\t\t\tclearInterval(delayedShow);\n\t\t\t\t\t}\n\t\t\t\t}, $.fx.interval);\n\t\t\t}\n\n\t\t\tthis._trigger(\"open\", event, { tooltip: tooltip });\n\t\t},\n\n\t\t_registerCloseHandlers: function _registerCloseHandlers(event, target) {\n\t\t\tvar events = {\n\t\t\t\tkeyup: function keyup(event) {\n\t\t\t\t\tif (event.keyCode === $.ui.keyCode.ESCAPE) {\n\t\t\t\t\t\tvar fakeEvent = $.Event(event);\n\t\t\t\t\t\tfakeEvent.currentTarget = target[0];\n\t\t\t\t\t\tthis.close(fakeEvent, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// Only bind remove handler for delegated targets. Non-delegated\n\t\t\t// tooltips will handle this in destroy.\n\t\t\tif (target[0] !== this.element[0]) {\n\t\t\t\tevents.remove = function () {\n\t\t\t\t\tthis._removeTooltip(this._find(target).tooltip);\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (!event || event.type === \"mouseover\") {\n\t\t\t\tevents.mouseleave = \"close\";\n\t\t\t}\n\t\t\tif (!event || event.type === \"focusin\") {\n\t\t\t\tevents.focusout = \"close\";\n\t\t\t}\n\t\t\tthis._on(true, target, events);\n\t\t},\n\n\t\tclose: function close(event) {\n\t\t\tvar tooltip,\n\t\t\t    that = this,\n\t\t\t    target = $(event ? event.currentTarget : this.element),\n\t\t\t    tooltipData = this._find(target);\n\n\t\t\t// The tooltip may already be closed\n\t\t\tif (!tooltipData) {\n\n\t\t\t\t// We set ui-tooltip-open immediately upon open (in open()), but only set the\n\t\t\t\t// additional data once there's actually content to show (in _open()). So even if the\n\t\t\t\t// tooltip doesn't have full data, we always remove ui-tooltip-open in case we're in\n\t\t\t\t// the period between open() and _open().\n\t\t\t\ttarget.removeData(\"ui-tooltip-open\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttooltip = tooltipData.tooltip;\n\n\t\t\t// disabling closes the tooltip, so we need to track when we're closing\n\t\t\t// to avoid an infinite loop in case the tooltip becomes disabled on close\n\t\t\tif (tooltipData.closing) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Clear the interval for delayed tracking tooltips\n\t\t\tclearInterval(this.delayedShow);\n\n\t\t\t// only set title if we had one before (see comment in _open())\n\t\t\t// If the title attribute has changed since open(), don't restore\n\t\t\tif (target.data(\"ui-tooltip-title\") && !target.attr(\"title\")) {\n\t\t\t\ttarget.attr(\"title\", target.data(\"ui-tooltip-title\"));\n\t\t\t}\n\n\t\t\tthis._removeDescribedBy(target);\n\n\t\t\ttooltipData.hiding = true;\n\t\t\ttooltip.stop(true);\n\t\t\tthis._hide(tooltip, this.options.hide, function () {\n\t\t\t\tthat._removeTooltip($(this));\n\t\t\t});\n\n\t\t\ttarget.removeData(\"ui-tooltip-open\");\n\t\t\tthis._off(target, \"mouseleave focusout keyup\");\n\n\t\t\t// Remove 'remove' binding only on delegated targets\n\t\t\tif (target[0] !== this.element[0]) {\n\t\t\t\tthis._off(target, \"remove\");\n\t\t\t}\n\t\t\tthis._off(this.document, \"mousemove\");\n\n\t\t\tif (event && event.type === \"mouseleave\") {\n\t\t\t\t$.each(this.parents, function (id, parent) {\n\t\t\t\t\t$(parent.element).attr(\"title\", parent.title);\n\t\t\t\t\tdelete that.parents[id];\n\t\t\t\t});\n\t\t\t}\n\n\t\t\ttooltipData.closing = true;\n\t\t\tthis._trigger(\"close\", event, { tooltip: tooltip });\n\t\t\tif (!tooltipData.hiding) {\n\t\t\t\ttooltipData.closing = false;\n\t\t\t}\n\t\t},\n\n\t\t_tooltip: function _tooltip(element) {\n\t\t\tvar tooltip = $(\"<div>\").attr(\"role\", \"tooltip\").addClass(\"ui-tooltip ui-widget ui-corner-all ui-widget-content \" + (this.options.tooltipClass || \"\")),\n\t\t\t    id = tooltip.uniqueId().attr(\"id\");\n\n\t\t\t$(\"<div>\").addClass(\"ui-tooltip-content\").appendTo(tooltip);\n\n\t\t\ttooltip.appendTo(this.document[0].body);\n\n\t\t\treturn this.tooltips[id] = {\n\t\t\t\telement: element,\n\t\t\t\ttooltip: tooltip\n\t\t\t};\n\t\t},\n\n\t\t_find: function _find(target) {\n\t\t\tvar id = target.data(\"ui-tooltip-id\");\n\t\t\treturn id ? this.tooltips[id] : null;\n\t\t},\n\n\t\t_removeTooltip: function _removeTooltip(tooltip) {\n\t\t\ttooltip.remove();\n\t\t\tdelete this.tooltips[tooltip.attr(\"id\")];\n\t\t},\n\n\t\t_destroy: function _destroy() {\n\t\t\tvar that = this;\n\n\t\t\t// close open tooltips\n\t\t\t$.each(this.tooltips, function (id, tooltipData) {\n\t\t\t\t// Delegate to close method to handle common cleanup\n\t\t\t\tvar event = $.Event(\"blur\"),\n\t\t\t\t    element = tooltipData.element;\n\t\t\t\tevent.target = event.currentTarget = element[0];\n\t\t\t\tthat.close(event, true);\n\n\t\t\t\t// Remove immediately; destroying an open tooltip doesn't use the\n\t\t\t\t// hide animation\n\t\t\t\t$(\"#\" + id).remove();\n\n\t\t\t\t// Restore the title\n\t\t\t\tif (element.data(\"ui-tooltip-title\")) {\n\t\t\t\t\t// If the title attribute has changed since open(), don't restore\n\t\t\t\t\tif (!element.attr(\"title\")) {\n\t\t\t\t\t\telement.attr(\"title\", element.data(\"ui-tooltip-title\"));\n\t\t\t\t\t}\n\t\t\t\t\telement.removeData(\"ui-tooltip-title\");\n\t\t\t\t}\n\t\t\t});\n\t\t\tthis.liveRegion.remove();\n\t\t}\n\t});\n});"

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./node_modules/babel-loader/lib/index.js??ref--0-0!./assets/js/jquery.uploadfile-4.0.11.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/raw-loader!./node_modules/babel-loader/lib??ref--0-0!./assets/js/jquery.uploadfile-4.0.11.js ***!
  \*******************************************************************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports) {

module.exports = "/*!\n * jQuery Upload File Plugin\n * version: 4.0.11\n * @requires jQuery v1.5 or later & form plugin\n * Copyright (c) 2013 Ravishanker Kusuma\n * http://hayageek.com/\n */\n(function ($) {\n    if ($.fn.ajaxForm == undefined) {\n        $.getScript((\"https:\" == document.location.protocol ? \"https://\" : \"http://\") + \"malsup.github.io/jquery.form.js\");\n    }\n    var feature = {};\n    feature.fileapi = $(\"<input type='file'/>\").get(0).files !== undefined;\n    feature.formdata = window.FormData !== undefined;\n    $.fn.uploadFile = function (options) {\n        // This is the easiest way to have default options.\n        var s = $.extend({\n            // These are the defaults.\n            url: \"\",\n            method: \"POST\",\n            enctype: \"multipart/form-data\",\n            returnType: null,\n            allowDuplicates: true,\n            duplicateStrict: false,\n            allowedTypes: \"*\",\n            //For list of acceptFiles\n            // http://stackoverflow.com/questions/11832930/html-input-file-accept-attribute-file-type-csv\n            acceptFiles: \"*\",\n            fileName: \"file\",\n            formData: false,\n            dynamicFormData: false,\n            maxFileSize: -1,\n            maxFileCount: -1,\n            multiple: true,\n            dragDrop: true,\n            autoSubmit: true,\n            showCancel: true,\n            showAbort: true,\n            showDone: false,\n            showDelete: false,\n            showError: true,\n            showStatusAfterSuccess: true,\n            showStatusAfterError: true,\n            showFileCounter: true,\n            fileCounterStyle: \"). \",\n            showFileSize: true,\n            showProgress: false,\n            nestedForms: true,\n            showDownload: false,\n            onLoad: function onLoad(obj) {},\n            onSelect: function onSelect(files) {\n                return true;\n            },\n            onSubmit: function onSubmit(files, xhr) {},\n            onSuccess: function onSuccess(files, response, xhr, pd) {},\n            onError: function onError(files, status, message, pd) {},\n            onCancel: function onCancel(files, pd) {},\n            onAbort: function onAbort(files, pd) {},\n            downloadCallback: false,\n            deleteCallback: false,\n            afterUploadAll: false,\n            serialize: true,\n            sequential: false,\n            sequentialCount: 2,\n            customProgressBar: false,\n            abortButtonClass: \"ajax-file-upload-abort\",\n            cancelButtonClass: \"ajax-file-upload-cancel\",\n            dragDropContainerClass: \"ajax-upload-dragdrop\",\n            dragDropHoverClass: \"state-hover\",\n            errorClass: \"ajax-file-upload-error\",\n            uploadButtonClass: \"ajax-file-upload\",\n            dragDropStr: \"<span><b>Drag &amp; Drop Files</b></span>\",\n            uploadStr: \"Upload\",\n            abortStr: \"Abort\",\n            cancelStr: \"Cancel\",\n            deleteStr: \"Delete\",\n            doneStr: \"Done\",\n            multiDragErrorStr: \"Multiple File Drag &amp; Drop is not allowed.\",\n            extErrorStr: \"is not allowed. Allowed extensions: \",\n            duplicateErrorStr: \"is not allowed. File already exists.\",\n            sizeErrorStr: \"is not allowed. Allowed Max size: \",\n            uploadErrorStr: \"Upload is not allowed\",\n            maxFileCountErrorStr: \" is not allowed. Maximum allowed files are:\",\n            downloadStr: \"Download\",\n            customErrorKeyStr: \"jquery-upload-file-error\",\n            showQueueDiv: false,\n            statusBarWidth: 400,\n            dragdropWidth: 400,\n            showPreview: false,\n            previewHeight: \"auto\",\n            previewWidth: \"100%\",\n            extraHTML: false,\n            uploadQueueOrder: 'top',\n            headers: {}\n        }, options);\n\n        this.fileCounter = 1;\n        this.selectedFiles = 0;\n        var formGroup = \"ajax-file-upload-\" + new Date().getTime();\n        this.formGroup = formGroup;\n        this.errorLog = $(\"<div></div>\"); //Writing errors\n        this.responses = [];\n        this.existingFileNames = [];\n        if (!feature.formdata) //check drag drop enabled.\n            {\n                s.dragDrop = false;\n            }\n        if (!feature.formdata || s.maxFileCount === 1) {\n            s.multiple = false;\n        }\n\n        $(this).html(\"\");\n\n        var obj = this;\n\n        var uploadLabel = $('<div>' + s.uploadStr + '</div>');\n\n        $(uploadLabel).addClass(s.uploadButtonClass);\n\n        // wait form ajax Form plugin and initialize\n        (function checkAjaxFormLoaded() {\n            if ($.fn.ajaxForm) {\n\n                if (s.dragDrop) {\n                    var dragDrop = $('<div class=\"' + s.dragDropContainerClass + '\" style=\"vertical-align:top;\"></div>').width(s.dragdropWidth);\n                    $(obj).append(dragDrop);\n                    $(dragDrop).append(uploadLabel);\n                    $(dragDrop).append($(s.dragDropStr));\n                    setDragDropHandlers(obj, s, dragDrop);\n                } else {\n                    $(obj).append(uploadLabel);\n                }\n                $(obj).append(obj.errorLog);\n\n                if (s.showQueueDiv) obj.container = $(\"#\" + s.showQueueDiv);else obj.container = $(\"<div class='ajax-file-upload-container'></div>\").insertAfter($(obj));\n\n                s.onLoad.call(this, obj);\n                createCustomInputFile(obj, formGroup, s, uploadLabel);\n            } else window.setTimeout(checkAjaxFormLoaded, 10);\n        })();\n\n        this.startUpload = function () {\n            $(\"form\").each(function (i, items) {\n                if ($(this).hasClass(obj.formGroup)) {\n                    mainQ.push($(this));\n                }\n            });\n\n            if (mainQ.length >= 1) submitPendingUploads();\n        };\n\n        this.getFileCount = function () {\n            return obj.selectedFiles;\n        };\n        this.stopUpload = function () {\n            $(\".\" + s.abortButtonClass).each(function (i, items) {\n                if ($(this).hasClass(obj.formGroup)) $(this).click();\n            });\n            $(\".\" + s.cancelButtonClass).each(function (i, items) {\n                if ($(this).hasClass(obj.formGroup)) $(this).click();\n            });\n        };\n        this.cancelAll = function () {\n            $(\".\" + s.cancelButtonClass).each(function (i, items) {\n                if ($(this).hasClass(obj.formGroup)) $(this).click();\n            });\n        };\n        this.update = function (settings) {\n            //update new settings\n            s = $.extend(s, settings);\n\n            //We need to update action for already created Form.            \n            if (settings.hasOwnProperty('url')) {\n                $(\"form\").each(function (i, items) {\n                    $(this).attr('action', settings['url']);\n                });\n            }\n        };\n\n        this.enqueueFile = function (file) {\n            if (!(file instanceof File)) return;\n            var files = [file];\n            serializeAndUploadFiles(s, obj, files);\n        };\n\n        this.reset = function (removeStatusBars) {\n            obj.fileCounter = 1;\n            obj.selectedFiles = 0;\n            obj.errorLog.html(\"\");\n            //remove all the status bars.\n            if (removeStatusBars != false) {\n                obj.container.html(\"\");\n            }\n        };\n        this.remove = function () {\n            obj.container.html(\"\");\n            $(obj).remove();\n        };\n        //This is for showing Old files to user.\n        this.createProgress = function (filename, filepath, filesize) {\n            var pd = new createProgressDiv(this, s);\n            pd.progressDiv.show();\n            pd.progressbar.width('100%');\n\n            var fileNameStr = \"\";\n            if (s.showFileCounter) fileNameStr = obj.fileCounter + s.fileCounterStyle + filename;else fileNameStr = filename;\n\n            if (s.showFileSize) fileNameStr += \" (\" + getSizeStr(filesize) + \")\";\n\n            pd.filename.html(fileNameStr);\n            obj.fileCounter++;\n            obj.selectedFiles++;\n            if (s.showPreview) {\n                pd.preview.attr('src', filepath);\n                pd.preview.show();\n            }\n\n            if (s.showDownload) {\n                pd.download.show();\n                pd.download.click(function () {\n                    if (s.downloadCallback) s.downloadCallback.call(obj, [filename], pd);\n                });\n            }\n            if (s.showDelete) {\n                pd.del.show();\n                pd.del.click(function () {\n                    pd.statusbar.hide().remove();\n                    var arr = [filename];\n                    if (s.deleteCallback) s.deleteCallback.call(this, arr, pd);\n                    obj.selectedFiles -= 1;\n                    updateFileCounter(s, obj);\n                });\n            }\n\n            return pd;\n        };\n\n        this.getResponses = function () {\n            return this.responses;\n        };\n        var mainQ = [];\n        var progressQ = [];\n        var running = false;\n        function submitPendingUploads() {\n            if (running) return;\n            running = true;\n            (function checkPendingForms() {\n\n                //if not sequential upload all files\n                if (!s.sequential) s.sequentialCount = 99999;\n\n                if (mainQ.length == 0 && progressQ.length == 0) {\n                    if (s.afterUploadAll) s.afterUploadAll(obj);\n                    running = false;\n                } else {\n                    if (progressQ.length < s.sequentialCount) {\n                        var frm = mainQ.shift();\n                        if (frm != undefined) {\n                            progressQ.push(frm);\n                            //Remove the class group.\n                            frm.removeClass(obj.formGroup);\n                            frm.submit();\n                        }\n                    }\n                    window.setTimeout(checkPendingForms, 100);\n                }\n            })();\n        }\n\n        function setDragDropHandlers(obj, s, ddObj) {\n            ddObj.on('dragenter', function (e) {\n                e.stopPropagation();\n                e.preventDefault();\n                $(this).addClass(s.dragDropHoverClass);\n            });\n            ddObj.on('dragover', function (e) {\n                e.stopPropagation();\n                e.preventDefault();\n                var that = $(this);\n                if (that.hasClass(s.dragDropContainerClass) && !that.hasClass(s.dragDropHoverClass)) {\n                    that.addClass(s.dragDropHoverClass);\n                }\n            });\n            ddObj.on('drop', function (e) {\n                e.preventDefault();\n                $(this).removeClass(s.dragDropHoverClass);\n                obj.errorLog.html(\"\");\n                var files = e.originalEvent.dataTransfer.files;\n                if (!s.multiple && files.length > 1) {\n                    if (s.showError) $(\"<div class='\" + s.errorClass + \"'>\" + s.multiDragErrorStr + \"</div>\").appendTo(obj.errorLog);\n                    return;\n                }\n                if (s.onSelect(files) == false) return;\n                serializeAndUploadFiles(s, obj, files);\n            });\n            ddObj.on('dragleave', function (e) {\n                $(this).removeClass(s.dragDropHoverClass);\n            });\n\n            $(document).on('dragenter', function (e) {\n                e.stopPropagation();\n                e.preventDefault();\n            });\n            $(document).on('dragover', function (e) {\n                e.stopPropagation();\n                e.preventDefault();\n                var that = $(this);\n                if (!that.hasClass(s.dragDropContainerClass)) {\n                    that.removeClass(s.dragDropHoverClass);\n                }\n            });\n            $(document).on('drop', function (e) {\n                e.stopPropagation();\n                e.preventDefault();\n                $(this).removeClass(s.dragDropHoverClass);\n            });\n        }\n\n        function getSizeStr(size) {\n            var sizeStr = \"\";\n            var sizeKB = size / 1024;\n            if (parseInt(sizeKB) > 1024) {\n                var sizeMB = sizeKB / 1024;\n                sizeStr = sizeMB.toFixed(2) + \" MB\";\n            } else {\n                sizeStr = sizeKB.toFixed(2) + \" KB\";\n            }\n            return sizeStr;\n        }\n\n        function serializeData(extraData) {\n            var serialized = [];\n            if (jQuery.type(extraData) == \"string\") {\n                serialized = extraData.split('&');\n            } else {\n                serialized = $.param(extraData).split('&');\n            }\n            var len = serialized.length;\n            var result = [];\n            var i, part;\n            for (i = 0; i < len; i++) {\n                serialized[i] = serialized[i].replace(/\\+/g, ' ');\n                part = serialized[i].split('=');\n                result.push([decodeURIComponent(part[0]), decodeURIComponent(part[1])]);\n            }\n            return result;\n        }\n        function noserializeAndUploadFiles(s, obj, files) {\n            var ts = $.extend({}, s);\n            var fd = new FormData();\n            var fileArray = [];\n            var fileName = s.fileName.replace(\"[]\", \"\");\n            var fileListStr = \"\";\n\n            for (var i = 0; i < files.length; i++) {\n                if (!isFileTypeAllowed(obj, s, files[i].name)) {\n                    if (s.showError) $(\"<div><font color='red'><b>\" + files[i].name + \"</b> \" + s.extErrorStr + s.allowedTypes + \"</font></div>\").appendTo(obj.errorLog);\n                    continue;\n                }\n                if (s.maxFileSize != -1 && files[i].size > s.maxFileSize) {\n                    if (s.showError) $(\"<div><font color='red'><b>\" + files[i].name + \"</b> \" + s.sizeErrorStr + getSizeStr(s.maxFileSize) + \"</font></div>\").appendTo(obj.errorLog);\n                    continue;\n                }\n                fd.append(fileName + \"[]\", files[i]);\n                fileArray.push(files[i].name);\n                fileListStr += obj.fileCounter + \"). \" + files[i].name + \"<br>\";\n                obj.fileCounter++;\n            }\n            if (fileArray.length == 0) return;\n\n            var extraData = s.formData;\n            if (extraData) {\n                var sData = serializeData(extraData);\n                for (var j = 0; j < sData.length; j++) {\n                    if (sData[j]) {\n                        fd.append(sData[j][0], sData[j][1]);\n                    }\n                }\n            }\n\n            ts.fileData = fd;\n            var pd = new createProgressDiv(obj, s);\n            pd.filename.html(fileListStr);\n            var form = $(\"<form style='display:block; position:absolute;left: 150px;' class='\" + obj.formGroup + \"' method='\" + s.method + \"' action='\" + s.url + \"' enctype='\" + s.enctype + \"'></form>\");\n            form.appendTo('body');\n            ajaxFormSubmit(form, ts, pd, fileArray, obj);\n        }\n\n        function serializeAndUploadFiles(s, obj, files) {\n            for (var i = 0; i < files.length; i++) {\n                if (!isFileTypeAllowed(obj, s, files[i].name)) {\n                    if (s.showError) $(\"<div class='\" + s.errorClass + \"'><b>\" + files[i].name + \"</b> \" + s.extErrorStr + s.allowedTypes + \"</div>\").appendTo(obj.errorLog);\n                    continue;\n                }\n                if (!s.allowDuplicates && isFileDuplicate(obj, files[i].name)) {\n                    if (s.showError) $(\"<div class='\" + s.errorClass + \"'><b>\" + files[i].name + \"</b> \" + s.duplicateErrorStr + \"</div>\").appendTo(obj.errorLog);\n                    continue;\n                }\n                if (s.maxFileSize != -1 && files[i].size > s.maxFileSize) {\n                    if (s.showError) $(\"<div class='\" + s.errorClass + \"'><b>\" + files[i].name + \"</b> \" + s.sizeErrorStr + getSizeStr(s.maxFileSize) + \"</div>\").appendTo(obj.errorLog);\n                    continue;\n                }\n                if (s.maxFileCount != -1 && obj.selectedFiles >= s.maxFileCount) {\n                    if (s.showError) $(\"<div class='\" + s.errorClass + \"'><b>\" + files[i].name + \"</b> \" + s.maxFileCountErrorStr + s.maxFileCount + \"</div>\").appendTo(obj.errorLog);\n                    continue;\n                }\n                obj.selectedFiles++;\n                obj.existingFileNames.push(files[i].name);\n                // Make object immutable\n                var ts = $.extend({}, s);\n                var fd = new FormData();\n                var fileName = s.fileName.replace(\"[]\", \"\");\n                fd.append(fileName, files[i]);\n                var extraData = s.formData;\n                if (extraData) {\n                    var sData = serializeData(extraData);\n                    for (var j = 0; j < sData.length; j++) {\n                        if (sData[j]) {\n                            fd.append(sData[j][0], sData[j][1]);\n                        }\n                    }\n                }\n                ts.fileData = fd;\n\n                var pd = new createProgressDiv(obj, s);\n                var fileNameStr = \"\";\n                if (s.showFileCounter) fileNameStr = obj.fileCounter + s.fileCounterStyle + files[i].name;else fileNameStr = files[i].name;\n\n                if (s.showFileSize) fileNameStr += \" (\" + getSizeStr(files[i].size) + \")\";\n\n                pd.filename.html(fileNameStr);\n                var form = $(\"<form style='display:block; position:absolute;left: 150px;' class='\" + obj.formGroup + \"' method='\" + s.method + \"' action='\" + s.url + \"' enctype='\" + s.enctype + \"'></form>\");\n                form.appendTo('body');\n                var fileArray = [];\n                fileArray.push(files[i].name);\n\n                ajaxFormSubmit(form, ts, pd, fileArray, obj, files[i]);\n                obj.fileCounter++;\n            }\n        }\n\n        function isFileTypeAllowed(obj, s, fileName) {\n            var fileExtensions = s.allowedTypes.toLowerCase().split(/[\\s,]+/g);\n            var ext = fileName.split('.').pop().toLowerCase();\n            if (s.allowedTypes != \"*\" && jQuery.inArray(ext, fileExtensions) < 0) {\n                return false;\n            }\n            return true;\n        }\n\n        function isFileDuplicate(obj, filename) {\n            var duplicate = false;\n            if (obj.existingFileNames.length) {\n                for (var x = 0; x < obj.existingFileNames.length; x++) {\n                    if (obj.existingFileNames[x] == filename || s.duplicateStrict && obj.existingFileNames[x].toLowerCase() == filename.toLowerCase()) {\n                        duplicate = true;\n                    }\n                }\n            }\n            return duplicate;\n        }\n\n        function removeExistingFileName(obj, fileArr) {\n            if (obj.existingFileNames.length) {\n                for (var x = 0; x < fileArr.length; x++) {\n                    var pos = obj.existingFileNames.indexOf(fileArr[x]);\n                    if (pos != -1) {\n                        obj.existingFileNames.splice(pos, 1);\n                    }\n                }\n            }\n        }\n\n        function getSrcToPreview(file, obj) {\n            if (file) {\n                obj.show();\n                var reader = new FileReader();\n                reader.onload = function (e) {\n                    obj.attr('src', e.target.result);\n                };\n                reader.readAsDataURL(file);\n            }\n        }\n\n        function updateFileCounter(s, obj) {\n            if (s.showFileCounter) {\n                var count = $(obj.container).find(\".ajax-file-upload-filename\").length;\n                obj.fileCounter = count + 1;\n                $(obj.container).find(\".ajax-file-upload-filename\").each(function (i, items) {\n                    var arr = $(this).html().split(s.fileCounterStyle);\n                    var fileNum = parseInt(arr[0]) - 1; //decrement;\n                    var name = count + s.fileCounterStyle + arr[1];\n                    $(this).html(name);\n                    count--;\n                });\n            }\n        }\n\n        function createCustomInputFile(obj, group, s, uploadLabel) {\n\n            var fileUploadId = \"ajax-upload-id-\" + new Date().getTime();\n\n            var form = $(\"<form method='\" + s.method + \"' action='\" + s.url + \"' enctype='\" + s.enctype + \"'></form>\");\n            var fileInputStr = \"<input type='file' id='\" + fileUploadId + \"' name='\" + s.fileName + \"' accept='\" + s.acceptFiles + \"'/>\";\n            if (s.multiple) {\n                if (s.fileName.indexOf(\"[]\") != s.fileName.length - 2) // if it does not endwith\n                    {\n                        s.fileName += \"[]\";\n                    }\n                fileInputStr = \"<input type='file' id='\" + fileUploadId + \"' name='\" + s.fileName + \"' accept='\" + s.acceptFiles + \"' multiple/>\";\n            }\n            var fileInput = $(fileInputStr).appendTo(form);\n\n            fileInput.change(function () {\n\n                obj.errorLog.html(\"\");\n                var fileExtensions = s.allowedTypes.toLowerCase().split(\",\");\n                var fileArray = [];\n                if (this.files) //support reading files\n                    {\n                        for (i = 0; i < this.files.length; i++) {\n                            fileArray.push(this.files[i].name);\n                        }\n\n                        if (s.onSelect(this.files) == false) return;\n                    } else {\n                    var filenameStr = $(this).val();\n                    var flist = [];\n                    fileArray.push(filenameStr);\n                    if (!isFileTypeAllowed(obj, s, filenameStr)) {\n                        if (s.showError) $(\"<div class='\" + s.errorClass + \"'><b>\" + filenameStr + \"</b> \" + s.extErrorStr + s.allowedTypes + \"</div>\").appendTo(obj.errorLog);\n                        return;\n                    }\n                    //fallback for browser without FileAPI\n                    flist.push({\n                        name: filenameStr,\n                        size: 'NA'\n                    });\n                    if (s.onSelect(flist) == false) return;\n                }\n                updateFileCounter(s, obj);\n\n                uploadLabel.unbind(\"click\");\n                form.hide();\n                createCustomInputFile(obj, group, s, uploadLabel);\n                form.addClass(group);\n                if (s.serialize && feature.fileapi && feature.formdata) //use HTML5 support and split file submission\n                    {\n                        form.removeClass(group); //Stop Submitting when.\n                        var files = this.files;\n                        form.remove();\n                        serializeAndUploadFiles(s, obj, files);\n                    } else {\n                    var fileList = \"\";\n                    for (var i = 0; i < fileArray.length; i++) {\n                        if (s.showFileCounter) fileList += obj.fileCounter + s.fileCounterStyle + fileArray[i] + \"<br>\";else fileList += fileArray[i] + \"<br>\";;\n                        obj.fileCounter++;\n                    }\n                    if (s.maxFileCount != -1 && obj.selectedFiles + fileArray.length > s.maxFileCount) {\n                        if (s.showError) $(\"<div class='\" + s.errorClass + \"'><b>\" + fileList + \"</b> \" + s.maxFileCountErrorStr + s.maxFileCount + \"</div>\").appendTo(obj.errorLog);\n                        return;\n                    }\n                    obj.selectedFiles += fileArray.length;\n\n                    var pd = new createProgressDiv(obj, s);\n                    pd.filename.html(fileList);\n                    ajaxFormSubmit(form, s, pd, fileArray, obj, null);\n                }\n            });\n\n            if (s.nestedForms) {\n                form.css({\n                    'margin': 0,\n                    'padding': 0\n                });\n                uploadLabel.css({\n                    position: 'relative',\n                    overflow: 'hidden',\n                    cursor: 'default'\n                });\n                fileInput.css({\n                    position: 'absolute',\n                    'cursor': 'pointer',\n                    'top': '0px',\n                    'width': '100%',\n                    'height': '100%',\n                    'left': '0px',\n                    'z-index': '100',\n                    'opacity': '0.0',\n                    'filter': 'alpha(opacity=0)',\n                    '-ms-filter': \"alpha(opacity=0)\",\n                    '-khtml-opacity': '0.0',\n                    '-moz-opacity': '0.0'\n                });\n                form.appendTo(uploadLabel);\n            } else {\n                form.appendTo($('body'));\n                form.css({\n                    margin: 0,\n                    padding: 0,\n                    display: 'block',\n                    position: 'absolute',\n                    left: '-250px'\n                });\n                if (navigator.appVersion.indexOf(\"MSIE \") != -1) //IE Browser\n                    {\n                        uploadLabel.attr('for', fileUploadId);\n                    } else {\n                    uploadLabel.click(function () {\n                        fileInput.click();\n                    });\n                }\n            }\n        }\n\n        function defaultProgressBar(obj, s) {\n\n            this.statusbar = $(\"<div class='ajax-file-upload-statusbar'></div>\").width(s.statusBarWidth);\n            this.preview = $(\"<img class='ajax-file-upload-preview' />\").width(s.previewWidth).height(s.previewHeight).appendTo(this.statusbar).hide();\n            this.filename = $(\"<div class='ajax-file-upload-filename'></div>\").appendTo(this.statusbar);\n            this.progressDiv = $(\"<div class='ajax-file-upload-progress'>\").appendTo(this.statusbar).hide();\n            this.progressbar = $(\"<div class='ajax-file-upload-bar'></div>\").appendTo(this.progressDiv);\n            this.abort = $(\"<div>\" + s.abortStr + \"</div>\").appendTo(this.statusbar).hide();\n            this.cancel = $(\"<div>\" + s.cancelStr + \"</div>\").appendTo(this.statusbar).hide();\n            this.done = $(\"<div>\" + s.doneStr + \"</div>\").appendTo(this.statusbar).hide();\n            this.download = $(\"<div>\" + s.downloadStr + \"</div>\").appendTo(this.statusbar).hide();\n            this.del = $(\"<div>\" + s.deleteStr + \"</div>\").appendTo(this.statusbar).hide();\n\n            this.abort.addClass(\"ajax-file-upload-red\");\n            this.done.addClass(\"ajax-file-upload-green\");\n            this.download.addClass(\"ajax-file-upload-green\");\n            this.cancel.addClass(\"ajax-file-upload-red\");\n            this.del.addClass(\"ajax-file-upload-red\");\n\n            return this;\n        }\n        function createProgressDiv(obj, s) {\n            var bar = null;\n            if (s.customProgressBar) bar = new s.customProgressBar(obj, s);else bar = new defaultProgressBar(obj, s);\n\n            bar.abort.addClass(obj.formGroup);\n            bar.abort.addClass(s.abortButtonClass);\n\n            bar.cancel.addClass(obj.formGroup);\n            bar.cancel.addClass(s.cancelButtonClass);\n\n            if (s.extraHTML) bar.extraHTML = $(\"<div class='extrahtml'>\" + s.extraHTML() + \"</div>\").insertAfter(bar.filename);\n\n            if (s.uploadQueueOrder == 'bottom') $(obj.container).append(bar.statusbar);else $(obj.container).prepend(bar.statusbar);\n            return bar;\n        }\n\n        function ajaxFormSubmit(form, s, pd, fileArray, obj, file) {\n            var currentXHR = null;\n            var options = {\n                cache: false,\n                contentType: false,\n                processData: false,\n                forceSync: false,\n                type: s.method,\n                data: s.formData,\n                formData: s.fileData,\n                dataType: s.returnType,\n                headers: s.headers,\n                beforeSubmit: function beforeSubmit(formData, $form, options) {\n                    if (s.onSubmit.call(this, fileArray) != false) {\n                        if (s.dynamicFormData) {\n                            var sData = serializeData(s.dynamicFormData());\n                            if (sData) {\n                                for (var j = 0; j < sData.length; j++) {\n                                    if (sData[j]) {\n                                        if (s.serialize && s.fileData != undefined) options.formData.append(sData[j][0], sData[j][1]);else options.data[sData[j][0]] = sData[j][1];\n                                    }\n                                }\n                            }\n                        }\n\n                        if (s.extraHTML) {\n                            $(pd.extraHTML).find(\"input,select,textarea\").each(function (i, items) {\n                                if (s.serialize && s.fileData != undefined) options.formData.append($(this).attr('name'), $(this).val());else options.data[$(this).attr('name')] = $(this).val();\n                            });\n                        }\n                        return true;\n                    }\n                    pd.statusbar.append(\"<div class='\" + s.errorClass + \"'>\" + s.uploadErrorStr + \"</div>\");\n                    pd.cancel.show();\n                    form.remove();\n                    pd.cancel.click(function () {\n                        mainQ.splice(mainQ.indexOf(form), 1);\n                        removeExistingFileName(obj, fileArray);\n                        pd.statusbar.remove();\n                        s.onCancel.call(obj, fileArray, pd);\n                        obj.selectedFiles -= fileArray.length; //reduce selected File count\n                        updateFileCounter(s, obj);\n                    });\n                    return false;\n                },\n                beforeSend: function beforeSend(xhr, o) {\n                    for (var key in o.headers) {\n                        xhr.setRequestHeader(key, o.headers[key]);\n                    }\n\n                    pd.progressDiv.show();\n                    pd.cancel.hide();\n                    pd.done.hide();\n                    if (s.showAbort) {\n                        pd.abort.show();\n                        pd.abort.click(function () {\n                            removeExistingFileName(obj, fileArray);\n                            xhr.abort();\n                            obj.selectedFiles -= fileArray.length; //reduce selected File count\n                            s.onAbort.call(obj, fileArray, pd);\n                        });\n                    }\n                    if (!feature.formdata) //For iframe based push\n                        {\n                            pd.progressbar.width('5%');\n                        } else pd.progressbar.width('1%'); //Fix for small files\n                },\n                uploadProgress: function uploadProgress(event, position, total, percentComplete) {\n                    //Fix for smaller file uploads in MAC\n                    if (percentComplete > 98) percentComplete = 98;\n\n                    var percentVal = percentComplete + '%';\n                    if (percentComplete > 1) pd.progressbar.width(percentVal);\n                    if (s.showProgress) {\n                        pd.progressbar.html(percentVal);\n                        pd.progressbar.css('text-align', 'center');\n                    }\n                },\n                success: function success(data, message, xhr) {\n                    pd.cancel.remove();\n                    progressQ.pop();\n                    //For custom errors.\n                    if (s.returnType == \"json\" && $.type(data) == \"object\" && data.hasOwnProperty(s.customErrorKeyStr)) {\n                        pd.abort.hide();\n                        var msg = data[s.customErrorKeyStr];\n                        s.onError.call(this, fileArray, 200, msg, pd);\n                        if (s.showStatusAfterError) {\n                            pd.progressDiv.hide();\n                            pd.statusbar.append(\"<span class='\" + s.errorClass + \"'>ERROR: \" + msg + \"</span>\");\n                        } else {\n                            pd.statusbar.hide();\n                            pd.statusbar.remove();\n                        }\n                        obj.selectedFiles -= fileArray.length; //reduce selected File count\n                        form.remove();\n                        return;\n                    }\n                    obj.responses.push(data);\n                    pd.progressbar.width('100%');\n                    if (s.showProgress) {\n                        pd.progressbar.html('100%');\n                        pd.progressbar.css('text-align', 'center');\n                    }\n\n                    pd.abort.hide();\n                    s.onSuccess.call(this, fileArray, data, xhr, pd);\n                    if (s.showStatusAfterSuccess) {\n                        if (s.showDone) {\n                            pd.done.show();\n                            pd.done.click(function () {\n                                pd.statusbar.hide(\"slow\");\n                                pd.statusbar.remove();\n                            });\n                        } else {\n                            pd.done.hide();\n                        }\n                        if (s.showDelete) {\n                            pd.del.show();\n                            pd.del.click(function () {\n                                removeExistingFileName(obj, fileArray);\n                                pd.statusbar.hide().remove();\n                                if (s.deleteCallback) s.deleteCallback.call(this, data, pd);\n                                obj.selectedFiles -= fileArray.length; //reduce selected File count\n                                updateFileCounter(s, obj);\n                            });\n                        } else {\n                            pd.del.hide();\n                        }\n                    } else {\n                        pd.statusbar.hide(\"slow\");\n                        pd.statusbar.remove();\n                    }\n                    if (s.showDownload) {\n                        pd.download.show();\n                        pd.download.click(function () {\n                            if (s.downloadCallback) s.downloadCallback(data, pd);\n                        });\n                    }\n                    form.remove();\n                },\n                error: function error(xhr, status, errMsg) {\n                    pd.cancel.remove();\n                    progressQ.pop();\n                    pd.abort.hide();\n                    if (xhr.statusText == \"abort\") //we aborted it\n                        {\n                            pd.statusbar.hide(\"slow\").remove();\n                            updateFileCounter(s, obj);\n                        } else {\n                        s.onError.call(this, fileArray, status, errMsg, pd);\n                        if (s.showStatusAfterError) {\n                            pd.progressDiv.hide();\n                            pd.statusbar.append(\"<span class='\" + s.errorClass + \"'>ERROR: \" + errMsg + \"</span>\");\n                        } else {\n                            pd.statusbar.hide();\n                            pd.statusbar.remove();\n                        }\n                        obj.selectedFiles -= fileArray.length; //reduce selected File count\n                    }\n\n                    form.remove();\n                }\n            };\n\n            if (s.showPreview && file != null) {\n                if (file.type.toLowerCase().split(\"/\").shift() == \"image\") getSrcToPreview(file, pd.preview);\n            }\n\n            if (s.autoSubmit) {\n                form.ajaxForm(options);\n                mainQ.push(form);\n                submitPendingUploads();\n            } else {\n                if (s.showCancel) {\n                    pd.cancel.show();\n                    pd.cancel.click(function () {\n                        mainQ.splice(mainQ.indexOf(form), 1);\n                        removeExistingFileName(obj, fileArray);\n                        form.remove();\n                        pd.statusbar.remove();\n                        s.onCancel.call(obj, fileArray, pd);\n                        obj.selectedFiles -= fileArray.length; //reduce selected File count\n                        updateFileCounter(s, obj);\n                    });\n                }\n                form.ajaxForm(options);\n            }\n        }\n        return this;\n    };\n})(jQuery);"

/***/ }),

/***/ "./node_modules/script-loader/addScript.js":
/*!*************************************************!*\
  !*** ./node_modules/script-loader/addScript.js ***!
  \*************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
module.exports = function(src) {
	function log(error) {
		(typeof console !== "undefined")
		&& (console.error || console.log)("[Script Loader]", error);
	}

	// Check for IE =< 8
	function isIE() {
		return typeof attachEvent !== "undefined" && typeof addEventListener === "undefined";
	}

	try {
		if (typeof execScript !== "undefined" && isIE()) {
			execScript(src);
		} else if (typeof eval !== "undefined") {
			eval.call(null, src);
		} else {
			log("EvalError: No eval function available");
		}
	} catch (error) {
		log(error);
	}
}


/***/ }),

/***/ "./node_modules/script-loader/index.js!./assets/js/bowser.js":
/*!**********************************************************!*\
  !*** ./node_modules/script-loader!./assets/js/bowser.js ***!
  \**********************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! !./node_modules/script-loader/addScript.js */ "./node_modules/script-loader/addScript.js")(__webpack_require__(/*! !./node_modules/raw-loader!./node_modules/babel-loader/lib??ref--0-0!./assets/js/bowser.js */ "./node_modules/raw-loader/index.js!./node_modules/babel-loader/lib/index.js??ref--0-0!./assets/js/bowser.js")+"\n\n// SCRIPT-LOADER FOOTER\n//# sourceURL=script:///home/konstantin/workspace/mlab.local.test/node_modules/babel-loader/lib/index.js%3F?ref--0-0!/home/konstantin/workspace/mlab.local.test/assets/js/bowser.js")

/***/ }),

/***/ "./node_modules/script-loader/index.js!./assets/js/jquery-2.1.4.js":
/*!****************************************************************!*\
  !*** ./node_modules/script-loader!./assets/js/jquery-2.1.4.js ***!
  \****************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! !./node_modules/script-loader/addScript.js */ "./node_modules/script-loader/addScript.js")(__webpack_require__(/*! !./node_modules/raw-loader!./node_modules/babel-loader/lib??ref--0-0!./assets/js/jquery-2.1.4.js */ "./node_modules/raw-loader/index.js!./node_modules/babel-loader/lib/index.js??ref--0-0!./assets/js/jquery-2.1.4.js")+"\n\n// SCRIPT-LOADER FOOTER\n//# sourceURL=script:///home/konstantin/workspace/mlab.local.test/node_modules/babel-loader/lib/index.js%3F?ref--0-0!/home/konstantin/workspace/mlab.local.test/assets/js/jquery-2.1.4.js")

/***/ }),

/***/ "./node_modules/script-loader/index.js!./assets/js/jquery.form.js":
/*!***************************************************************!*\
  !*** ./node_modules/script-loader!./assets/js/jquery.form.js ***!
  \***************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! !./node_modules/script-loader/addScript.js */ "./node_modules/script-loader/addScript.js")(__webpack_require__(/*! !./node_modules/raw-loader!./node_modules/babel-loader/lib??ref--0-0!./assets/js/jquery.form.js */ "./node_modules/raw-loader/index.js!./node_modules/babel-loader/lib/index.js??ref--0-0!./assets/js/jquery.form.js")+"\n\n// SCRIPT-LOADER FOOTER\n//# sourceURL=script:///home/konstantin/workspace/mlab.local.test/node_modules/babel-loader/lib/index.js%3F?ref--0-0!/home/konstantin/workspace/mlab.local.test/assets/js/jquery.form.js")

/***/ }),

/***/ "./node_modules/script-loader/index.js!./assets/js/jquery.qtip.nightly.js":
/*!***********************************************************************!*\
  !*** ./node_modules/script-loader!./assets/js/jquery.qtip.nightly.js ***!
  \***********************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! !./node_modules/script-loader/addScript.js */ "./node_modules/script-loader/addScript.js")(__webpack_require__(/*! !./node_modules/raw-loader!./node_modules/babel-loader/lib??ref--0-0!./assets/js/jquery.qtip.nightly.js */ "./node_modules/raw-loader/index.js!./node_modules/babel-loader/lib/index.js??ref--0-0!./assets/js/jquery.qtip.nightly.js")+"\n\n// SCRIPT-LOADER FOOTER\n//# sourceURL=script:///home/konstantin/workspace/mlab.local.test/node_modules/babel-loader/lib/index.js%3F?ref--0-0!/home/konstantin/workspace/mlab.local.test/assets/js/jquery.qtip.nightly.js")

/***/ }),

/***/ "./node_modules/script-loader/index.js!./assets/js/jquery.ui-1.11.4.js":
/*!********************************************************************!*\
  !*** ./node_modules/script-loader!./assets/js/jquery.ui-1.11.4.js ***!
  \********************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! !./node_modules/script-loader/addScript.js */ "./node_modules/script-loader/addScript.js")(__webpack_require__(/*! !./node_modules/raw-loader!./node_modules/babel-loader/lib??ref--0-0!./assets/js/jquery.ui-1.11.4.js */ "./node_modules/raw-loader/index.js!./node_modules/babel-loader/lib/index.js??ref--0-0!./assets/js/jquery.ui-1.11.4.js")+"\n\n// SCRIPT-LOADER FOOTER\n//# sourceURL=script:///home/konstantin/workspace/mlab.local.test/node_modules/babel-loader/lib/index.js%3F?ref--0-0!/home/konstantin/workspace/mlab.local.test/assets/js/jquery.ui-1.11.4.js")

/***/ }),

/***/ "./node_modules/script-loader/index.js!./assets/js/jquery.uploadfile-4.0.11.js":
/*!****************************************************************************!*\
  !*** ./node_modules/script-loader!./assets/js/jquery.uploadfile-4.0.11.js ***!
  \****************************************************************************/
/*! dynamic exports provided */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! !./node_modules/script-loader/addScript.js */ "./node_modules/script-loader/addScript.js")(__webpack_require__(/*! !./node_modules/raw-loader!./node_modules/babel-loader/lib??ref--0-0!./assets/js/jquery.uploadfile-4.0.11.js */ "./node_modules/raw-loader/index.js!./node_modules/babel-loader/lib/index.js??ref--0-0!./assets/js/jquery.uploadfile-4.0.11.js")+"\n\n// SCRIPT-LOADER FOOTER\n//# sourceURL=script:///home/konstantin/workspace/mlab.local.test/node_modules/babel-loader/lib/index.js%3F?ref--0-0!/home/konstantin/workspace/mlab.local.test/assets/js/jquery.uploadfile-4.0.11.js")

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgN2FmN2NlYWVkYjc3NTBkYjkwZmQiLCJ3ZWJwYWNrOi8vLy4vYXNzZXRzL2pzL21sYWIuanMiLCJ3ZWJwYWNrOi8vLy4vYXNzZXRzL2pzL2Jvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvanF1ZXJ5LTIuMS40LmpzIiwid2VicGFjazovLy8uL2Fzc2V0cy9qcy9qcXVlcnkuZm9ybS5qcyIsIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvanF1ZXJ5LnF0aXAubmlnaHRseS5qcyIsIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvanF1ZXJ5LnVpLTEuMTEuNC5qcyIsIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvanF1ZXJ5LnVwbG9hZGZpbGUtNC4wLjExLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qcyIsIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvYm93c2VyLmpzPzJkMmUiLCJ3ZWJwYWNrOi8vLy4vYXNzZXRzL2pzL2pxdWVyeS0yLjEuNC5qcz8wY2JhIiwid2VicGFjazovLy8uL2Fzc2V0cy9qcy9qcXVlcnkuZm9ybS5qcz85ZDc2Iiwid2VicGFjazovLy8uL2Fzc2V0cy9qcy9qcXVlcnkucXRpcC5uaWdodGx5LmpzPzBlZTgiLCJ3ZWJwYWNrOi8vLy4vYXNzZXRzL2pzL2pxdWVyeS51aS0xLjExLjQuanM/Mjk2OCIsIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvanF1ZXJ5LnVwbG9hZGZpbGUtNC4wLjExLmpzP2VhODUiXSwibmFtZXMiOlsiJCIsInJlcXVpcmUiXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7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eUNBQXlDLGVBQWUsT0FBTyxxQ0FBcUMsdUNBQXVDLG1EQUFtRCwrREFBK0QsaUVBQWlFLHdDQUF3QyxnREFBZ0QsOERBQThELGdFQUFnRSxpRkFBaUYsdUJBQXVCLEVBQUUsbUJBQW1CLHlDQUF5QyxlQUFlLFdBQVcsc0JBQXNCLFFBQVEsR0FBRyxVQUFVLEM7Ozs7Ozs7Ozs7OztBQ0EveHBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMxQkEsbUJBQU8sQ0FBQyw2RkFBc0YsRUFBRSxtQkFBTyxDQUFDLCtNQUEwTyxxTjs7Ozs7Ozs7Ozs7O0FDQWxWLG1CQUFPLENBQUMsNkZBQXNGLEVBQUUsbUJBQU8sQ0FBQywyTkFBZ1AsMk47Ozs7Ozs7Ozs7OztBQ0F4VixtQkFBTyxDQUFDLDZGQUFzRixFQUFFLG1CQUFPLENBQUMseU5BQStPLDBOOzs7Ozs7Ozs7Ozs7QUNBdlYsbUJBQU8sQ0FBQyw2RkFBc0YsRUFBRSxtQkFBTyxDQUFDLHlPQUF1UCxrTzs7Ozs7Ozs7Ozs7O0FDQS9WLG1CQUFPLENBQUMsNkZBQXNGLEVBQUUsbUJBQU8sQ0FBQyxtT0FBb1AsK047Ozs7Ozs7Ozs7OztBQ0E1VixtQkFBTyxDQUFDLDZGQUFzRixFQUFFLG1CQUFPLENBQUMsbVBBQTRQLHVPIiwiZmlsZSI6Im1sYWIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCIvYnVpbGQvXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL2Fzc2V0cy9qcy9tbGFiLmpzXCIpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIDdhZjdjZWFlZGI3NzUwZGI5MGZkIiwiLy8gcmVxdWlyZSBqUXVlcnkgbm9ybWFsbHlcbmNvbnN0ICQgPSByZXF1aXJlKCdzY3JpcHQtbG9hZGVyIS4vanF1ZXJ5LTIuMS40LmpzJyk7XG5cbi8vIGlmL3doZW4gdXNlIE5QTSB2ZXJzaW9uLCBuZWVkIHRvIGNyZWF0ZSBnbG9iYWwgJCBhbmQgalF1ZXJ5IHZhcmlhYmxlc1xuLy8gZ2xvYmFsLiQgPSBnbG9iYWwualF1ZXJ5ID0gJDtcblxucmVxdWlyZSgnc2NyaXB0LWxvYWRlciEuL2pxdWVyeS51aS0xLjExLjQuanMnKTtcbnJlcXVpcmUoJ3NjcmlwdC1sb2FkZXIhLi9qcXVlcnkuZm9ybS5qcycpO1xucmVxdWlyZSgnc2NyaXB0LWxvYWRlciEuL2pxdWVyeS51cGxvYWRmaWxlLTQuMC4xMS5qcycpO1xuLy8gcmVxdWlyZSgnc2NyaXB0LWxvYWRlciEuL2pxdWVyeS5xdGlwLTMuMC4zLmpzJyk7XG5yZXF1aXJlKCdzY3JpcHQtbG9hZGVyIS4vanF1ZXJ5LnF0aXAubmlnaHRseS5qcycpO1xucmVxdWlyZSgnc2NyaXB0LWxvYWRlciEuL2Jvd3Nlci5qcycpO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2Fzc2V0cy9qcy9tbGFiLmpzIiwibW9kdWxlLmV4cG9ydHMgPSBcIi8qIVxcbiAgKiBCb3dzZXIgLSBhIGJyb3dzZXIgZGV0ZWN0b3JcXG4gICogaHR0cHM6Ly9naXRodWIuY29tL2RlZC9ib3dzZXJcXG4gICogTUlUIExpY2Vuc2UgfCAoYykgRHVzdGluIERpYXogMjAxNFxcbiAgKi9cXG5cXG4hZnVuY3Rpb24gKG5hbWUsIGRlZmluaXRpb24pIHtcXG4gIGlmICh0eXBlb2YgbW9kdWxlICE9ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSBtb2R1bGUuZXhwb3J0c1snYnJvd3NlciddID0gZGVmaW5pdGlvbigpO2Vsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSBkZWZpbmUoZGVmaW5pdGlvbik7ZWxzZSB0aGlzW25hbWVdID0gZGVmaW5pdGlvbigpO1xcbn0oJ2Jvd3NlcicsIGZ1bmN0aW9uICgpIHtcXG4gIC8qKlxcbiAgICAqIFNlZSB1c2VyYWdlbnRzLmpzIGZvciBleGFtcGxlcyBvZiBuYXZpZ2F0b3IudXNlckFnZW50XFxuICAgICovXFxuXFxuICB2YXIgdCA9IHRydWU7XFxuXFxuICBmdW5jdGlvbiBkZXRlY3QodWEpIHtcXG5cXG4gICAgZnVuY3Rpb24gZ2V0Rmlyc3RNYXRjaChyZWdleCkge1xcbiAgICAgIHZhciBtYXRjaCA9IHVhLm1hdGNoKHJlZ2V4KTtcXG4gICAgICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2gubGVuZ3RoID4gMSAmJiBtYXRjaFsxXSB8fCAnJztcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBnZXRTZWNvbmRNYXRjaChyZWdleCkge1xcbiAgICAgIHZhciBtYXRjaCA9IHVhLm1hdGNoKHJlZ2V4KTtcXG4gICAgICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2gubGVuZ3RoID4gMSAmJiBtYXRjaFsyXSB8fCAnJztcXG4gICAgfVxcblxcbiAgICB2YXIgaW9zZGV2aWNlID0gZ2V0Rmlyc3RNYXRjaCgvKGlwb2R8aXBob25lfGlwYWQpL2kpLnRvTG93ZXJDYXNlKCksXFxuICAgICAgICBsaWtlQW5kcm9pZCA9IC9saWtlIGFuZHJvaWQvaS50ZXN0KHVhKSxcXG4gICAgICAgIGFuZHJvaWQgPSAhbGlrZUFuZHJvaWQgJiYgL2FuZHJvaWQvaS50ZXN0KHVhKSxcXG4gICAgICAgIGVkZ2VWZXJzaW9uID0gZ2V0Rmlyc3RNYXRjaCgvZWRnZVxcXFwvKFxcXFxkKyhcXFxcLlxcXFxkKyk/KS9pKSxcXG4gICAgICAgIHZlcnNpb25JZGVudGlmaWVyID0gZ2V0Rmlyc3RNYXRjaCgvdmVyc2lvblxcXFwvKFxcXFxkKyhcXFxcLlxcXFxkKyk/KS9pKSxcXG4gICAgICAgIHRhYmxldCA9IC90YWJsZXQvaS50ZXN0KHVhKSxcXG4gICAgICAgIG1vYmlsZSA9ICF0YWJsZXQgJiYgL1teLV1tb2JpL2kudGVzdCh1YSksXFxuICAgICAgICByZXN1bHQ7XFxuXFxuICAgIGlmICgvb3BlcmF8b3ByL2kudGVzdCh1YSkpIHtcXG4gICAgICByZXN1bHQgPSB7XFxuICAgICAgICBuYW1lOiAnT3BlcmEnLFxcbiAgICAgICAgb3BlcmE6IHQsXFxuICAgICAgICB2ZXJzaW9uOiB2ZXJzaW9uSWRlbnRpZmllciB8fCBnZXRGaXJzdE1hdGNoKC8oPzpvcGVyYXxvcHIpW1xcXFxzXFxcXC9dKFxcXFxkKyhcXFxcLlxcXFxkKyk/KS9pKVxcbiAgICAgIH07XFxuICAgIH0gZWxzZSBpZiAoL3dpbmRvd3MgcGhvbmUvaS50ZXN0KHVhKSkge1xcbiAgICAgIHJlc3VsdCA9IHtcXG4gICAgICAgIG5hbWU6ICdXaW5kb3dzIFBob25lJyxcXG4gICAgICAgIHdpbmRvd3NwaG9uZTogdFxcbiAgICAgIH07XFxuICAgICAgaWYgKGVkZ2VWZXJzaW9uKSB7XFxuICAgICAgICByZXN1bHQubXNlZGdlID0gdDtcXG4gICAgICAgIHJlc3VsdC52ZXJzaW9uID0gZWRnZVZlcnNpb247XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHJlc3VsdC5tc2llID0gdDtcXG4gICAgICAgIHJlc3VsdC52ZXJzaW9uID0gZ2V0Rmlyc3RNYXRjaCgvaWVtb2JpbGVcXFxcLyhcXFxcZCsoXFxcXC5cXFxcZCspPykvaSk7XFxuICAgICAgfVxcbiAgICB9IGVsc2UgaWYgKC9tc2llfHRyaWRlbnQvaS50ZXN0KHVhKSkge1xcbiAgICAgIHJlc3VsdCA9IHtcXG4gICAgICAgIG5hbWU6ICdJbnRlcm5ldCBFeHBsb3JlcicsXFxuICAgICAgICBtc2llOiB0LFxcbiAgICAgICAgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvKD86bXNpZSB8cnY6KShcXFxcZCsoXFxcXC5cXFxcZCspPykvaSlcXG4gICAgICB9O1xcbiAgICB9IGVsc2UgaWYgKC9jaHJvbWUuKz8gZWRnZS9pLnRlc3QodWEpKSB7XFxuICAgICAgcmVzdWx0ID0ge1xcbiAgICAgICAgbmFtZTogJ01pY3Jvc29mdCBFZGdlJyxcXG4gICAgICAgIG1zZWRnZTogdCxcXG4gICAgICAgIHZlcnNpb246IGVkZ2VWZXJzaW9uXFxuICAgICAgfTtcXG4gICAgfSBlbHNlIGlmICgvY2hyb21lfGNyaW9zfGNybW8vaS50ZXN0KHVhKSkge1xcbiAgICAgIHJlc3VsdCA9IHtcXG4gICAgICAgIG5hbWU6ICdDaHJvbWUnLFxcbiAgICAgICAgY2hyb21lOiB0LFxcbiAgICAgICAgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvKD86Y2hyb21lfGNyaW9zfGNybW8pXFxcXC8oXFxcXGQrKFxcXFwuXFxcXGQrKT8pL2kpXFxuICAgICAgfTtcXG4gICAgfSBlbHNlIGlmIChpb3NkZXZpY2UpIHtcXG4gICAgICByZXN1bHQgPSB7XFxuICAgICAgICBuYW1lOiBpb3NkZXZpY2UgPT0gJ2lwaG9uZScgPyAnaVBob25lJyA6IGlvc2RldmljZSA9PSAnaXBhZCcgPyAnaVBhZCcgOiAnaVBvZCdcXG4gICAgICAgIC8vIFdURjogdmVyc2lvbiBpcyBub3QgcGFydCBvZiB1c2VyIGFnZW50IGluIHdlYiBhcHBzXFxuICAgICAgfTtpZiAodmVyc2lvbklkZW50aWZpZXIpIHtcXG4gICAgICAgIHJlc3VsdC52ZXJzaW9uID0gdmVyc2lvbklkZW50aWZpZXI7XFxuICAgICAgfVxcbiAgICB9IGVsc2UgaWYgKC9zYWlsZmlzaC9pLnRlc3QodWEpKSB7XFxuICAgICAgcmVzdWx0ID0ge1xcbiAgICAgICAgbmFtZTogJ1NhaWxmaXNoJyxcXG4gICAgICAgIHNhaWxmaXNoOiB0LFxcbiAgICAgICAgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvc2FpbGZpc2hcXFxccz9icm93c2VyXFxcXC8oXFxcXGQrKFxcXFwuXFxcXGQrKT8pL2kpXFxuICAgICAgfTtcXG4gICAgfSBlbHNlIGlmICgvc2VhbW9ua2V5XFxcXC8vaS50ZXN0KHVhKSkge1xcbiAgICAgIHJlc3VsdCA9IHtcXG4gICAgICAgIG5hbWU6ICdTZWFNb25rZXknLFxcbiAgICAgICAgc2VhbW9ua2V5OiB0LFxcbiAgICAgICAgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvc2VhbW9ua2V5XFxcXC8oXFxcXGQrKFxcXFwuXFxcXGQrKT8pL2kpXFxuICAgICAgfTtcXG4gICAgfSBlbHNlIGlmICgvZmlyZWZveHxpY2V3ZWFzZWwvaS50ZXN0KHVhKSkge1xcbiAgICAgIHJlc3VsdCA9IHtcXG4gICAgICAgIG5hbWU6ICdGaXJlZm94JyxcXG4gICAgICAgIGZpcmVmb3g6IHQsXFxuICAgICAgICB2ZXJzaW9uOiBnZXRGaXJzdE1hdGNoKC8oPzpmaXJlZm94fGljZXdlYXNlbClbIFxcXFwvXShcXFxcZCsoXFxcXC5cXFxcZCspPykvaSlcXG4gICAgICB9O1xcbiAgICAgIGlmICgvXFxcXCgobW9iaWxlfHRhYmxldCk7W15cXFxcKV0qcnY6W1xcXFxkXFxcXC5dK1xcXFwpL2kudGVzdCh1YSkpIHtcXG4gICAgICAgIHJlc3VsdC5maXJlZm94b3MgPSB0O1xcbiAgICAgIH1cXG4gICAgfSBlbHNlIGlmICgvc2lsay9pLnRlc3QodWEpKSB7XFxuICAgICAgcmVzdWx0ID0ge1xcbiAgICAgICAgbmFtZTogJ0FtYXpvbiBTaWxrJyxcXG4gICAgICAgIHNpbGs6IHQsXFxuICAgICAgICB2ZXJzaW9uOiBnZXRGaXJzdE1hdGNoKC9zaWxrXFxcXC8oXFxcXGQrKFxcXFwuXFxcXGQrKT8pL2kpXFxuICAgICAgfTtcXG4gICAgfSBlbHNlIGlmIChhbmRyb2lkKSB7XFxuICAgICAgcmVzdWx0ID0ge1xcbiAgICAgICAgbmFtZTogJ0FuZHJvaWQnLFxcbiAgICAgICAgdmVyc2lvbjogdmVyc2lvbklkZW50aWZpZXJcXG4gICAgICB9O1xcbiAgICB9IGVsc2UgaWYgKC9waGFudG9tL2kudGVzdCh1YSkpIHtcXG4gICAgICByZXN1bHQgPSB7XFxuICAgICAgICBuYW1lOiAnUGhhbnRvbUpTJyxcXG4gICAgICAgIHBoYW50b206IHQsXFxuICAgICAgICB2ZXJzaW9uOiBnZXRGaXJzdE1hdGNoKC9waGFudG9tanNcXFxcLyhcXFxcZCsoXFxcXC5cXFxcZCspPykvaSlcXG4gICAgICB9O1xcbiAgICB9IGVsc2UgaWYgKC9ibGFja2JlcnJ5fFxcXFxiYmJcXFxcZCsvaS50ZXN0KHVhKSB8fCAvcmltXFxcXHN0YWJsZXQvaS50ZXN0KHVhKSkge1xcbiAgICAgIHJlc3VsdCA9IHtcXG4gICAgICAgIG5hbWU6ICdCbGFja0JlcnJ5JyxcXG4gICAgICAgIGJsYWNrYmVycnk6IHQsXFxuICAgICAgICB2ZXJzaW9uOiB2ZXJzaW9uSWRlbnRpZmllciB8fCBnZXRGaXJzdE1hdGNoKC9ibGFja2JlcnJ5W1xcXFxkXStcXFxcLyhcXFxcZCsoXFxcXC5cXFxcZCspPykvaSlcXG4gICAgICB9O1xcbiAgICB9IGVsc2UgaWYgKC8od2VifGhwdylvcy9pLnRlc3QodWEpKSB7XFxuICAgICAgcmVzdWx0ID0ge1xcbiAgICAgICAgbmFtZTogJ1dlYk9TJyxcXG4gICAgICAgIHdlYm9zOiB0LFxcbiAgICAgICAgdmVyc2lvbjogdmVyc2lvbklkZW50aWZpZXIgfHwgZ2V0Rmlyc3RNYXRjaCgvdyg/OmViKT9vc2Jyb3dzZXJcXFxcLyhcXFxcZCsoXFxcXC5cXFxcZCspPykvaSlcXG4gICAgICB9O1xcbiAgICAgIC90b3VjaHBhZFxcXFwvL2kudGVzdCh1YSkgJiYgKHJlc3VsdC50b3VjaHBhZCA9IHQpO1xcbiAgICB9IGVsc2UgaWYgKC9iYWRhL2kudGVzdCh1YSkpIHtcXG4gICAgICByZXN1bHQgPSB7XFxuICAgICAgICBuYW1lOiAnQmFkYScsXFxuICAgICAgICBiYWRhOiB0LFxcbiAgICAgICAgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvZG9sZmluXFxcXC8oXFxcXGQrKFxcXFwuXFxcXGQrKT8pL2kpXFxuICAgICAgfTtcXG4gICAgfSBlbHNlIGlmICgvdGl6ZW4vaS50ZXN0KHVhKSkge1xcbiAgICAgIHJlc3VsdCA9IHtcXG4gICAgICAgIG5hbWU6ICdUaXplbicsXFxuICAgICAgICB0aXplbjogdCxcXG4gICAgICAgIHZlcnNpb246IGdldEZpcnN0TWF0Y2goLyg/OnRpemVuXFxcXHM/KT9icm93c2VyXFxcXC8oXFxcXGQrKFxcXFwuXFxcXGQrKT8pL2kpIHx8IHZlcnNpb25JZGVudGlmaWVyXFxuICAgICAgfTtcXG4gICAgfSBlbHNlIGlmICgvc2FmYXJpL2kudGVzdCh1YSkpIHtcXG4gICAgICByZXN1bHQgPSB7XFxuICAgICAgICBuYW1lOiAnU2FmYXJpJyxcXG4gICAgICAgIHNhZmFyaTogdCxcXG4gICAgICAgIHZlcnNpb246IHZlcnNpb25JZGVudGlmaWVyXFxuICAgICAgfTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICByZXN1bHQgPSB7XFxuICAgICAgICBuYW1lOiBnZXRGaXJzdE1hdGNoKC9eKC4qKVxcXFwvKC4qKSAvKSxcXG4gICAgICAgIHZlcnNpb246IGdldFNlY29uZE1hdGNoKC9eKC4qKVxcXFwvKC4qKSAvKVxcbiAgICAgIH07XFxuICAgIH1cXG5cXG4gICAgLy8gc2V0IHdlYmtpdCBvciBnZWNrbyBmbGFnIGZvciBicm93c2VycyBiYXNlZCBvbiB0aGVzZSBlbmdpbmVzXFxuICAgIGlmICghcmVzdWx0Lm1zZWRnZSAmJiAvKGFwcGxlKT93ZWJraXQvaS50ZXN0KHVhKSkge1xcbiAgICAgIHJlc3VsdC5uYW1lID0gcmVzdWx0Lm5hbWUgfHwgXFxcIldlYmtpdFxcXCI7XFxuICAgICAgcmVzdWx0LndlYmtpdCA9IHQ7XFxuICAgICAgaWYgKCFyZXN1bHQudmVyc2lvbiAmJiB2ZXJzaW9uSWRlbnRpZmllcikge1xcbiAgICAgICAgcmVzdWx0LnZlcnNpb24gPSB2ZXJzaW9uSWRlbnRpZmllcjtcXG4gICAgICB9XFxuICAgIH0gZWxzZSBpZiAoIXJlc3VsdC5vcGVyYSAmJiAvZ2Vja29cXFxcLy9pLnRlc3QodWEpKSB7XFxuICAgICAgcmVzdWx0Lm5hbWUgPSByZXN1bHQubmFtZSB8fCBcXFwiR2Vja29cXFwiO1xcbiAgICAgIHJlc3VsdC5nZWNrbyA9IHQ7XFxuICAgICAgcmVzdWx0LnZlcnNpb24gPSByZXN1bHQudmVyc2lvbiB8fCBnZXRGaXJzdE1hdGNoKC9nZWNrb1xcXFwvKFxcXFxkKyhcXFxcLlxcXFxkKyk/KS9pKTtcXG4gICAgfVxcblxcbiAgICAvLyBzZXQgT1MgZmxhZ3MgZm9yIHBsYXRmb3JtcyB0aGF0IGhhdmUgbXVsdGlwbGUgYnJvd3NlcnNcXG4gICAgaWYgKCFyZXN1bHQubXNlZGdlICYmIChhbmRyb2lkIHx8IHJlc3VsdC5zaWxrKSkge1xcbiAgICAgIHJlc3VsdC5hbmRyb2lkID0gdDtcXG4gICAgfSBlbHNlIGlmIChpb3NkZXZpY2UpIHtcXG4gICAgICByZXN1bHRbaW9zZGV2aWNlXSA9IHQ7XFxuICAgICAgcmVzdWx0LmlvcyA9IHQ7XFxuICAgIH1cXG5cXG4gICAgLy8gT1MgdmVyc2lvbiBleHRyYWN0aW9uXFxuICAgIHZhciBvc1ZlcnNpb24gPSAnJztcXG4gICAgaWYgKHJlc3VsdC53aW5kb3dzcGhvbmUpIHtcXG4gICAgICBvc1ZlcnNpb24gPSBnZXRGaXJzdE1hdGNoKC93aW5kb3dzIHBob25lICg/Om9zKT9cXFxccz8oXFxcXGQrKFxcXFwuXFxcXGQrKSopL2kpO1xcbiAgICB9IGVsc2UgaWYgKGlvc2RldmljZSkge1xcbiAgICAgIG9zVmVyc2lvbiA9IGdldEZpcnN0TWF0Y2goL29zIChcXFxcZCsoW19cXFxcc11cXFxcZCspKikgbGlrZSBtYWMgb3MgeC9pKTtcXG4gICAgICBvc1ZlcnNpb24gPSBvc1ZlcnNpb24ucmVwbGFjZSgvW19cXFxcc10vZywgJy4nKTtcXG4gICAgfSBlbHNlIGlmIChhbmRyb2lkKSB7XFxuICAgICAgb3NWZXJzaW9uID0gZ2V0Rmlyc3RNYXRjaCgvYW5kcm9pZFsgXFxcXC8tXShcXFxcZCsoXFxcXC5cXFxcZCspKikvaSk7XFxuICAgIH0gZWxzZSBpZiAocmVzdWx0LndlYm9zKSB7XFxuICAgICAgb3NWZXJzaW9uID0gZ2V0Rmlyc3RNYXRjaCgvKD86d2VifGhwdylvc1xcXFwvKFxcXFxkKyhcXFxcLlxcXFxkKykqKS9pKTtcXG4gICAgfSBlbHNlIGlmIChyZXN1bHQuYmxhY2tiZXJyeSkge1xcbiAgICAgIG9zVmVyc2lvbiA9IGdldEZpcnN0TWF0Y2goL3JpbVxcXFxzdGFibGV0XFxcXHNvc1xcXFxzKFxcXFxkKyhcXFxcLlxcXFxkKykqKS9pKTtcXG4gICAgfSBlbHNlIGlmIChyZXN1bHQuYmFkYSkge1xcbiAgICAgIG9zVmVyc2lvbiA9IGdldEZpcnN0TWF0Y2goL2JhZGFcXFxcLyhcXFxcZCsoXFxcXC5cXFxcZCspKikvaSk7XFxuICAgIH0gZWxzZSBpZiAocmVzdWx0LnRpemVuKSB7XFxuICAgICAgb3NWZXJzaW9uID0gZ2V0Rmlyc3RNYXRjaCgvdGl6ZW5bXFxcXC9cXFxcc10oXFxcXGQrKFxcXFwuXFxcXGQrKSopL2kpO1xcbiAgICB9XFxuICAgIGlmIChvc1ZlcnNpb24pIHtcXG4gICAgICByZXN1bHQub3N2ZXJzaW9uID0gb3NWZXJzaW9uO1xcbiAgICB9XFxuXFxuICAgIC8vIGRldmljZSB0eXBlIGV4dHJhY3Rpb25cXG4gICAgdmFyIG9zTWFqb3JWZXJzaW9uID0gb3NWZXJzaW9uLnNwbGl0KCcuJylbMF07XFxuICAgIGlmICh0YWJsZXQgfHwgaW9zZGV2aWNlID09ICdpcGFkJyB8fCBhbmRyb2lkICYmIChvc01ham9yVmVyc2lvbiA9PSAzIHx8IG9zTWFqb3JWZXJzaW9uID09IDQgJiYgIW1vYmlsZSkgfHwgcmVzdWx0LnNpbGspIHtcXG4gICAgICByZXN1bHQudGFibGV0ID0gdDtcXG4gICAgfSBlbHNlIGlmIChtb2JpbGUgfHwgaW9zZGV2aWNlID09ICdpcGhvbmUnIHx8IGlvc2RldmljZSA9PSAnaXBvZCcgfHwgYW5kcm9pZCB8fCByZXN1bHQuYmxhY2tiZXJyeSB8fCByZXN1bHQud2Vib3MgfHwgcmVzdWx0LmJhZGEpIHtcXG4gICAgICByZXN1bHQubW9iaWxlID0gdDtcXG4gICAgfVxcblxcbiAgICAvLyBHcmFkZWQgQnJvd3NlciBTdXBwb3J0XFxuICAgIC8vIGh0dHA6Ly9kZXZlbG9wZXIueWFob28uY29tL3l1aS9hcnRpY2xlcy9nYnNcXG4gICAgaWYgKHJlc3VsdC5tc2VkZ2UgfHwgcmVzdWx0Lm1zaWUgJiYgcmVzdWx0LnZlcnNpb24gPj0gMTAgfHwgcmVzdWx0LmNocm9tZSAmJiByZXN1bHQudmVyc2lvbiA+PSAyMCB8fCByZXN1bHQuZmlyZWZveCAmJiByZXN1bHQudmVyc2lvbiA+PSAyMC4wIHx8IHJlc3VsdC5zYWZhcmkgJiYgcmVzdWx0LnZlcnNpb24gPj0gNiB8fCByZXN1bHQub3BlcmEgJiYgcmVzdWx0LnZlcnNpb24gPj0gMTAuMCB8fCByZXN1bHQuaW9zICYmIHJlc3VsdC5vc3ZlcnNpb24gJiYgcmVzdWx0Lm9zdmVyc2lvbi5zcGxpdChcXFwiLlxcXCIpWzBdID49IDYgfHwgcmVzdWx0LmJsYWNrYmVycnkgJiYgcmVzdWx0LnZlcnNpb24gPj0gMTAuMSkge1xcbiAgICAgIHJlc3VsdC5hID0gdDtcXG4gICAgfSBlbHNlIGlmIChyZXN1bHQubXNpZSAmJiByZXN1bHQudmVyc2lvbiA8IDEwIHx8IHJlc3VsdC5jaHJvbWUgJiYgcmVzdWx0LnZlcnNpb24gPCAyMCB8fCByZXN1bHQuZmlyZWZveCAmJiByZXN1bHQudmVyc2lvbiA8IDIwLjAgfHwgcmVzdWx0LnNhZmFyaSAmJiByZXN1bHQudmVyc2lvbiA8IDYgfHwgcmVzdWx0Lm9wZXJhICYmIHJlc3VsdC52ZXJzaW9uIDwgMTAuMCB8fCByZXN1bHQuaW9zICYmIHJlc3VsdC5vc3ZlcnNpb24gJiYgcmVzdWx0Lm9zdmVyc2lvbi5zcGxpdChcXFwiLlxcXCIpWzBdIDwgNikge1xcbiAgICAgIHJlc3VsdC5jID0gdDtcXG4gICAgfSBlbHNlIHJlc3VsdC54ID0gdDtcXG5cXG4gICAgcmV0dXJuIHJlc3VsdDtcXG4gIH1cXG5cXG4gIHZhciBib3dzZXIgPSBkZXRlY3QodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgPyBuYXZpZ2F0b3IudXNlckFnZW50IDogJycpO1xcblxcbiAgYm93c2VyLnRlc3QgPSBmdW5jdGlvbiAoYnJvd3Nlckxpc3QpIHtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBicm93c2VyTGlzdC5sZW5ndGg7ICsraSkge1xcbiAgICAgIHZhciBicm93c2VySXRlbSA9IGJyb3dzZXJMaXN0W2ldO1xcbiAgICAgIGlmICh0eXBlb2YgYnJvd3Nlckl0ZW0gPT09ICdzdHJpbmcnKSB7XFxuICAgICAgICBpZiAoYnJvd3Nlckl0ZW0gaW4gYm93c2VyKSB7XFxuICAgICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcbiAgICByZXR1cm4gZmFsc2U7XFxuICB9O1xcblxcbiAgLypcXG4gICAqIFNldCBvdXIgZGV0ZWN0IG1ldGhvZCB0byB0aGUgbWFpbiBib3dzZXIgb2JqZWN0IHNvIHdlIGNhblxcbiAgICogcmV1c2UgaXQgdG8gdGVzdCBvdGhlciB1c2VyIGFnZW50cy5cXG4gICAqIFRoaXMgaXMgbmVlZGVkIHRvIGltcGxlbWVudCBmdXR1cmUgdGVzdHMuXFxuICAgKi9cXG4gIGJvd3Nlci5fZGV0ZWN0ID0gZGV0ZWN0O1xcblxcbiAgcmV0dXJuIGJvd3NlcjtcXG59KTtcIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Jhdy1sb2FkZXIhLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYj8/cmVmLS0wLTAhLi9hc3NldHMvanMvYm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9yYXctbG9hZGVyL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMC0wIS4vYXNzZXRzL2pzL2Jvd3Nlci5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIm1vZHVsZS5leHBvcnRzID0gXCJ2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXFxcInN5bWJvbFxcXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXFxcInN5bWJvbFxcXCIgOiB0eXBlb2Ygb2JqOyB9O1xcblxcbi8qIVxcbiAqIGpRdWVyeSBKYXZhU2NyaXB0IExpYnJhcnkgdjIuMS40XFxuICogaHR0cDovL2pxdWVyeS5jb20vXFxuICpcXG4gKiBJbmNsdWRlcyBTaXp6bGUuanNcXG4gKiBodHRwOi8vc2l6emxlanMuY29tL1xcbiAqXFxuICogQ29weXJpZ2h0IDIwMDUsIDIwMTQgalF1ZXJ5IEZvdW5kYXRpb24sIEluYy4gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcXG4gKlxcbiAqIERhdGU6IDIwMTUtMDQtMjhUMTY6MDFaXFxuICovXFxuXFxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcXG5cXG5cXHRpZiAoKHR5cGVvZiBtb2R1bGUgPT09IFxcXCJ1bmRlZmluZWRcXFwiID8gXFxcInVuZGVmaW5lZFxcXCIgOiBfdHlwZW9mKG1vZHVsZSkpID09PSBcXFwib2JqZWN0XFxcIiAmJiBfdHlwZW9mKG1vZHVsZS5leHBvcnRzKSA9PT0gXFxcIm9iamVjdFxcXCIpIHtcXG5cXHRcXHQvLyBGb3IgQ29tbW9uSlMgYW5kIENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHdoZXJlIGEgcHJvcGVyIGB3aW5kb3dgXFxuXFx0XFx0Ly8gaXMgcHJlc2VudCwgZXhlY3V0ZSB0aGUgZmFjdG9yeSBhbmQgZ2V0IGpRdWVyeS5cXG5cXHRcXHQvLyBGb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IGhhdmUgYSBgd2luZG93YCB3aXRoIGEgYGRvY3VtZW50YFxcblxcdFxcdC8vIChzdWNoIGFzIE5vZGUuanMpLCBleHBvc2UgYSBmYWN0b3J5IGFzIG1vZHVsZS5leHBvcnRzLlxcblxcdFxcdC8vIFRoaXMgYWNjZW50dWF0ZXMgdGhlIG5lZWQgZm9yIHRoZSBjcmVhdGlvbiBvZiBhIHJlYWwgYHdpbmRvd2AuXFxuXFx0XFx0Ly8gZS5nLiB2YXIgalF1ZXJ5ID0gcmVxdWlyZShcXFwianF1ZXJ5XFxcIikod2luZG93KTtcXG5cXHRcXHQvLyBTZWUgdGlja2V0ICMxNDU0OSBmb3IgbW9yZSBpbmZvLlxcblxcdFxcdG1vZHVsZS5leHBvcnRzID0gZ2xvYmFsLmRvY3VtZW50ID8gZmFjdG9yeShnbG9iYWwsIHRydWUpIDogZnVuY3Rpb24gKHcpIHtcXG5cXHRcXHRcXHRpZiAoIXcuZG9jdW1lbnQpIHtcXG5cXHRcXHRcXHRcXHR0aHJvdyBuZXcgRXJyb3IoXFxcImpRdWVyeSByZXF1aXJlcyBhIHdpbmRvdyB3aXRoIGEgZG9jdW1lbnRcXFwiKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIGZhY3Rvcnkodyk7XFxuXFx0XFx0fTtcXG5cXHR9IGVsc2Uge1xcblxcdFxcdGZhY3RvcnkoZ2xvYmFsKTtcXG5cXHR9XFxuXFxuXFx0Ly8gUGFzcyB0aGlzIGlmIHdpbmRvdyBpcyBub3QgZGVmaW5lZCB5ZXRcXG59KSh0eXBlb2Ygd2luZG93ICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IHdpbmRvdyA6IHRoaXMsIGZ1bmN0aW9uICh3aW5kb3csIG5vR2xvYmFsKSB7XFxuXFxuXFx0Ly8gU3VwcG9ydDogRmlyZWZveCAxOCtcXG5cXHQvLyBDYW4ndCBiZSBpbiBzdHJpY3QgbW9kZSwgc2V2ZXJhbCBsaWJzIGluY2x1ZGluZyBBU1AuTkVUIHRyYWNlXFxuXFx0Ly8gdGhlIHN0YWNrIHZpYSBhcmd1bWVudHMuY2FsbGVyLmNhbGxlZSBhbmQgRmlyZWZveCBkaWVzIGlmXFxuXFx0Ly8geW91IHRyeSB0byB0cmFjZSB0aHJvdWdoIFxcXCJ1c2Ugc3RyaWN0XFxcIiBjYWxsIGNoYWlucy4gKCMxMzMzNSlcXG5cXHQvL1xcblxcblxcdHZhciBhcnIgPSBbXTtcXG5cXG5cXHR2YXIgX3NsaWNlID0gYXJyLnNsaWNlO1xcblxcblxcdHZhciBjb25jYXQgPSBhcnIuY29uY2F0O1xcblxcblxcdHZhciBwdXNoID0gYXJyLnB1c2g7XFxuXFxuXFx0dmFyIGluZGV4T2YgPSBhcnIuaW5kZXhPZjtcXG5cXG5cXHR2YXIgY2xhc3MydHlwZSA9IHt9O1xcblxcblxcdHZhciB0b1N0cmluZyA9IGNsYXNzMnR5cGUudG9TdHJpbmc7XFxuXFxuXFx0dmFyIGhhc093biA9IGNsYXNzMnR5cGUuaGFzT3duUHJvcGVydHk7XFxuXFxuXFx0dmFyIHN1cHBvcnQgPSB7fTtcXG5cXG5cXHR2YXJcXG5cXHQvLyBVc2UgdGhlIGNvcnJlY3QgZG9jdW1lbnQgYWNjb3JkaW5nbHkgd2l0aCB3aW5kb3cgYXJndW1lbnQgKHNhbmRib3gpXFxuXFx0ZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQsXFxuXFx0ICAgIHZlcnNpb24gPSBcXFwiMi4xLjRcXFwiLFxcblxcblxcblxcdC8vIERlZmluZSBhIGxvY2FsIGNvcHkgb2YgalF1ZXJ5XFxuXFx0alF1ZXJ5ID0gZnVuY3Rpb24galF1ZXJ5KHNlbGVjdG9yLCBjb250ZXh0KSB7XFxuXFx0XFx0Ly8gVGhlIGpRdWVyeSBvYmplY3QgaXMgYWN0dWFsbHkganVzdCB0aGUgaW5pdCBjb25zdHJ1Y3RvciAnZW5oYW5jZWQnXFxuXFx0XFx0Ly8gTmVlZCBpbml0IGlmIGpRdWVyeSBpcyBjYWxsZWQgKGp1c3QgYWxsb3cgZXJyb3IgdG8gYmUgdGhyb3duIGlmIG5vdCBpbmNsdWRlZClcXG5cXHRcXHRyZXR1cm4gbmV3IGpRdWVyeS5mbi5pbml0KHNlbGVjdG9yLCBjb250ZXh0KTtcXG5cXHR9LFxcblxcblxcblxcdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4xXFxuXFx0Ly8gTWFrZSBzdXJlIHdlIHRyaW0gQk9NIGFuZCBOQlNQXFxuXFx0cnRyaW0gPSAvXltcXFxcc1xcXFx1RkVGRlxcXFx4QTBdK3xbXFxcXHNcXFxcdUZFRkZcXFxceEEwXSskL2csXFxuXFxuXFxuXFx0Ly8gTWF0Y2hlcyBkYXNoZWQgc3RyaW5nIGZvciBjYW1lbGl6aW5nXFxuXFx0cm1zUHJlZml4ID0gL14tbXMtLyxcXG5cXHQgICAgcmRhc2hBbHBoYSA9IC8tKFtcXFxcZGEtel0pL2dpLFxcblxcblxcblxcdC8vIFVzZWQgYnkgalF1ZXJ5LmNhbWVsQ2FzZSBhcyBjYWxsYmFjayB0byByZXBsYWNlKClcXG5cXHRmY2FtZWxDYXNlID0gZnVuY3Rpb24gZmNhbWVsQ2FzZShhbGwsIGxldHRlcikge1xcblxcdFxcdHJldHVybiBsZXR0ZXIudG9VcHBlckNhc2UoKTtcXG5cXHR9O1xcblxcblxcdGpRdWVyeS5mbiA9IGpRdWVyeS5wcm90b3R5cGUgPSB7XFxuXFx0XFx0Ly8gVGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBqUXVlcnkgYmVpbmcgdXNlZFxcblxcdFxcdGpxdWVyeTogdmVyc2lvbixcXG5cXG5cXHRcXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LFxcblxcblxcdFxcdC8vIFN0YXJ0IHdpdGggYW4gZW1wdHkgc2VsZWN0b3JcXG5cXHRcXHRzZWxlY3RvcjogXFxcIlxcXCIsXFxuXFxuXFx0XFx0Ly8gVGhlIGRlZmF1bHQgbGVuZ3RoIG9mIGEgalF1ZXJ5IG9iamVjdCBpcyAwXFxuXFx0XFx0bGVuZ3RoOiAwLFxcblxcblxcdFxcdHRvQXJyYXk6IGZ1bmN0aW9uIHRvQXJyYXkoKSB7XFxuXFx0XFx0XFx0cmV0dXJuIF9zbGljZS5jYWxsKHRoaXMpO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0Ly8gR2V0IHRoZSBOdGggZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBlbGVtZW50IHNldCBPUlxcblxcdFxcdC8vIEdldCB0aGUgd2hvbGUgbWF0Y2hlZCBlbGVtZW50IHNldCBhcyBhIGNsZWFuIGFycmF5XFxuXFx0XFx0Z2V0OiBmdW5jdGlvbiBnZXQobnVtKSB7XFxuXFx0XFx0XFx0cmV0dXJuIG51bSAhPSBudWxsID9cXG5cXG5cXHRcXHRcXHQvLyBSZXR1cm4ganVzdCB0aGUgb25lIGVsZW1lbnQgZnJvbSB0aGUgc2V0XFxuXFx0XFx0XFx0bnVtIDwgMCA/IHRoaXNbbnVtICsgdGhpcy5sZW5ndGhdIDogdGhpc1tudW1dIDpcXG5cXG5cXHRcXHRcXHQvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBpbiBhIGNsZWFuIGFycmF5XFxuXFx0XFx0XFx0X3NsaWNlLmNhbGwodGhpcyk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyBUYWtlIGFuIGFycmF5IG9mIGVsZW1lbnRzIGFuZCBwdXNoIGl0IG9udG8gdGhlIHN0YWNrXFxuXFx0XFx0Ly8gKHJldHVybmluZyB0aGUgbmV3IG1hdGNoZWQgZWxlbWVudCBzZXQpXFxuXFx0XFx0cHVzaFN0YWNrOiBmdW5jdGlvbiBwdXNoU3RhY2soZWxlbXMpIHtcXG5cXG5cXHRcXHRcXHQvLyBCdWlsZCBhIG5ldyBqUXVlcnkgbWF0Y2hlZCBlbGVtZW50IHNldFxcblxcdFxcdFxcdHZhciByZXQgPSBqUXVlcnkubWVyZ2UodGhpcy5jb25zdHJ1Y3RvcigpLCBlbGVtcyk7XFxuXFxuXFx0XFx0XFx0Ly8gQWRkIHRoZSBvbGQgb2JqZWN0IG9udG8gdGhlIHN0YWNrIChhcyBhIHJlZmVyZW5jZSlcXG5cXHRcXHRcXHRyZXQucHJldk9iamVjdCA9IHRoaXM7XFxuXFx0XFx0XFx0cmV0LmNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XFxuXFxuXFx0XFx0XFx0Ly8gUmV0dXJuIHRoZSBuZXdseS1mb3JtZWQgZWxlbWVudCBzZXRcXG5cXHRcXHRcXHRyZXR1cm4gcmV0O1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0Ly8gRXhlY3V0ZSBhIGNhbGxiYWNrIGZvciBldmVyeSBlbGVtZW50IGluIHRoZSBtYXRjaGVkIHNldC5cXG5cXHRcXHQvLyAoWW91IGNhbiBzZWVkIHRoZSBhcmd1bWVudHMgd2l0aCBhbiBhcnJheSBvZiBhcmdzLCBidXQgdGhpcyBpc1xcblxcdFxcdC8vIG9ubHkgdXNlZCBpbnRlcm5hbGx5LilcXG5cXHRcXHRlYWNoOiBmdW5jdGlvbiBlYWNoKGNhbGxiYWNrLCBhcmdzKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGpRdWVyeS5lYWNoKHRoaXMsIGNhbGxiYWNrLCBhcmdzKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdG1hcDogZnVuY3Rpb24gbWFwKGNhbGxiYWNrKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKGpRdWVyeS5tYXAodGhpcywgZnVuY3Rpb24gKGVsZW0sIGkpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gY2FsbGJhY2suY2FsbChlbGVtLCBpLCBlbGVtKTtcXG5cXHRcXHRcXHR9KSk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzbGljZTogZnVuY3Rpb24gc2xpY2UoKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKF9zbGljZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdGZpcnN0OiBmdW5jdGlvbiBmaXJzdCgpIHtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5lcSgwKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdGxhc3Q6IGZ1bmN0aW9uIGxhc3QoKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZXEoLTEpO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZXE6IGZ1bmN0aW9uIGVxKGkpIHtcXG5cXHRcXHRcXHR2YXIgbGVuID0gdGhpcy5sZW5ndGgsXFxuXFx0XFx0XFx0ICAgIGogPSAraSArIChpIDwgMCA/IGxlbiA6IDApO1xcblxcdFxcdFxcdHJldHVybiB0aGlzLnB1c2hTdGFjayhqID49IDAgJiYgaiA8IGxlbiA/IFt0aGlzW2pdXSA6IFtdKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdGVuZDogZnVuY3Rpb24gZW5kKCkge1xcblxcdFxcdFxcdHJldHVybiB0aGlzLnByZXZPYmplY3QgfHwgdGhpcy5jb25zdHJ1Y3RvcihudWxsKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdC8vIEZvciBpbnRlcm5hbCB1c2Ugb25seS5cXG5cXHRcXHQvLyBCZWhhdmVzIGxpa2UgYW4gQXJyYXkncyBtZXRob2QsIG5vdCBsaWtlIGEgalF1ZXJ5IG1ldGhvZC5cXG5cXHRcXHRwdXNoOiBwdXNoLFxcblxcdFxcdHNvcnQ6IGFyci5zb3J0LFxcblxcdFxcdHNwbGljZTogYXJyLnNwbGljZVxcblxcdH07XFxuXFxuXFx0alF1ZXJ5LmV4dGVuZCA9IGpRdWVyeS5mbi5leHRlbmQgPSBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0dmFyIG9wdGlvbnMsXFxuXFx0XFx0ICAgIG5hbWUsXFxuXFx0XFx0ICAgIHNyYyxcXG5cXHRcXHQgICAgY29weSxcXG5cXHRcXHQgICAgY29weUlzQXJyYXksXFxuXFx0XFx0ICAgIGNsb25lLFxcblxcdFxcdCAgICB0YXJnZXQgPSBhcmd1bWVudHNbMF0gfHwge30sXFxuXFx0XFx0ICAgIGkgPSAxLFxcblxcdFxcdCAgICBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxcblxcdFxcdCAgICBkZWVwID0gZmFsc2U7XFxuXFxuXFx0XFx0Ly8gSGFuZGxlIGEgZGVlcCBjb3B5IHNpdHVhdGlvblxcblxcdFxcdGlmICh0eXBlb2YgdGFyZ2V0ID09PSBcXFwiYm9vbGVhblxcXCIpIHtcXG5cXHRcXHRcXHRkZWVwID0gdGFyZ2V0O1xcblxcblxcdFxcdFxcdC8vIFNraXAgdGhlIGJvb2xlYW4gYW5kIHRoZSB0YXJnZXRcXG5cXHRcXHRcXHR0YXJnZXQgPSBhcmd1bWVudHNbaV0gfHwge307XFxuXFx0XFx0XFx0aSsrO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBIYW5kbGUgY2FzZSB3aGVuIHRhcmdldCBpcyBhIHN0cmluZyBvciBzb21ldGhpbmcgKHBvc3NpYmxlIGluIGRlZXAgY29weSlcXG5cXHRcXHRpZiAoKHR5cGVvZiB0YXJnZXQgPT09IFxcXCJ1bmRlZmluZWRcXFwiID8gXFxcInVuZGVmaW5lZFxcXCIgOiBfdHlwZW9mKHRhcmdldCkpICE9PSBcXFwib2JqZWN0XFxcIiAmJiAhalF1ZXJ5LmlzRnVuY3Rpb24odGFyZ2V0KSkge1xcblxcdFxcdFxcdHRhcmdldCA9IHt9O1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBFeHRlbmQgalF1ZXJ5IGl0c2VsZiBpZiBvbmx5IG9uZSBhcmd1bWVudCBpcyBwYXNzZWRcXG5cXHRcXHRpZiAoaSA9PT0gbGVuZ3RoKSB7XFxuXFx0XFx0XFx0dGFyZ2V0ID0gdGhpcztcXG5cXHRcXHRcXHRpLS07XFxuXFx0XFx0fVxcblxcblxcdFxcdGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcXG5cXHRcXHRcXHQvLyBPbmx5IGRlYWwgd2l0aCBub24tbnVsbC91bmRlZmluZWQgdmFsdWVzXFxuXFx0XFx0XFx0aWYgKChvcHRpb25zID0gYXJndW1lbnRzW2ldKSAhPSBudWxsKSB7XFxuXFx0XFx0XFx0XFx0Ly8gRXh0ZW5kIHRoZSBiYXNlIG9iamVjdFxcblxcdFxcdFxcdFxcdGZvciAobmFtZSBpbiBvcHRpb25zKSB7XFxuXFx0XFx0XFx0XFx0XFx0c3JjID0gdGFyZ2V0W25hbWVdO1xcblxcdFxcdFxcdFxcdFxcdGNvcHkgPSBvcHRpb25zW25hbWVdO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIFByZXZlbnQgbmV2ZXItZW5kaW5nIGxvb3BcXG5cXHRcXHRcXHRcXHRcXHRpZiAodGFyZ2V0ID09PSBjb3B5KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y29udGludWU7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdC8vIFJlY3Vyc2UgaWYgd2UncmUgbWVyZ2luZyBwbGFpbiBvYmplY3RzIG9yIGFycmF5c1xcblxcdFxcdFxcdFxcdFxcdGlmIChkZWVwICYmIGNvcHkgJiYgKGpRdWVyeS5pc1BsYWluT2JqZWN0KGNvcHkpIHx8IChjb3B5SXNBcnJheSA9IGpRdWVyeS5pc0FycmF5KGNvcHkpKSkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoY29weUlzQXJyYXkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjb3B5SXNBcnJheSA9IGZhbHNlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGNsb25lID0gc3JjICYmIGpRdWVyeS5pc0FycmF5KHNyYykgPyBzcmMgOiBbXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGNsb25lID0gc3JjICYmIGpRdWVyeS5pc1BsYWluT2JqZWN0KHNyYykgPyBzcmMgOiB7fTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXFxuXFx0XFx0XFx0XFx0XFx0XFx0dGFyZ2V0W25hbWVdID0galF1ZXJ5LmV4dGVuZChkZWVwLCBjbG9uZSwgY29weSk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gRG9uJ3QgYnJpbmcgaW4gdW5kZWZpbmVkIHZhbHVlc1xcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoY29weSAhPT0gdW5kZWZpbmVkKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGFyZ2V0W25hbWVdID0gY29weTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gUmV0dXJuIHRoZSBtb2RpZmllZCBvYmplY3RcXG5cXHRcXHRyZXR1cm4gdGFyZ2V0O1xcblxcdH07XFxuXFxuXFx0alF1ZXJ5LmV4dGVuZCh7XFxuXFx0XFx0Ly8gVW5pcXVlIGZvciBlYWNoIGNvcHkgb2YgalF1ZXJ5IG9uIHRoZSBwYWdlXFxuXFx0XFx0ZXhwYW5kbzogXFxcImpRdWVyeVxcXCIgKyAodmVyc2lvbiArIE1hdGgucmFuZG9tKCkpLnJlcGxhY2UoL1xcXFxEL2csIFxcXCJcXFwiKSxcXG5cXG5cXHRcXHQvLyBBc3N1bWUgalF1ZXJ5IGlzIHJlYWR5IHdpdGhvdXQgdGhlIHJlYWR5IG1vZHVsZVxcblxcdFxcdGlzUmVhZHk6IHRydWUsXFxuXFxuXFx0XFx0ZXJyb3I6IGZ1bmN0aW9uIGVycm9yKG1zZykge1xcblxcdFxcdFxcdHRocm93IG5ldyBFcnJvcihtc2cpO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0bm9vcDogZnVuY3Rpb24gbm9vcCgpIHt9LFxcblxcblxcdFxcdGlzRnVuY3Rpb246IGZ1bmN0aW9uIGlzRnVuY3Rpb24ob2JqKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGpRdWVyeS50eXBlKG9iaikgPT09IFxcXCJmdW5jdGlvblxcXCI7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRpc0FycmF5OiBBcnJheS5pc0FycmF5LFxcblxcblxcdFxcdGlzV2luZG93OiBmdW5jdGlvbiBpc1dpbmRvdyhvYmopIHtcXG5cXHRcXHRcXHRyZXR1cm4gb2JqICE9IG51bGwgJiYgb2JqID09PSBvYmoud2luZG93O1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0aXNOdW1lcmljOiBmdW5jdGlvbiBpc051bWVyaWMob2JqKSB7XFxuXFx0XFx0XFx0Ly8gcGFyc2VGbG9hdCBOYU5zIG51bWVyaWMtY2FzdCBmYWxzZSBwb3NpdGl2ZXMgKG51bGx8dHJ1ZXxmYWxzZXxcXFwiXFxcIilcXG5cXHRcXHRcXHQvLyAuLi5idXQgbWlzaW50ZXJwcmV0cyBsZWFkaW5nLW51bWJlciBzdHJpbmdzLCBwYXJ0aWN1bGFybHkgaGV4IGxpdGVyYWxzIChcXFwiMHguLi5cXFwiKVxcblxcdFxcdFxcdC8vIHN1YnRyYWN0aW9uIGZvcmNlcyBpbmZpbml0aWVzIHRvIE5hTlxcblxcdFxcdFxcdC8vIGFkZGluZyAxIGNvcnJlY3RzIGxvc3Mgb2YgcHJlY2lzaW9uIGZyb20gcGFyc2VGbG9hdCAoIzE1MTAwKVxcblxcdFxcdFxcdHJldHVybiAhalF1ZXJ5LmlzQXJyYXkob2JqKSAmJiBvYmogLSBwYXJzZUZsb2F0KG9iaikgKyAxID49IDA7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRpc1BsYWluT2JqZWN0OiBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KG9iaikge1xcblxcdFxcdFxcdC8vIE5vdCBwbGFpbiBvYmplY3RzOlxcblxcdFxcdFxcdC8vIC0gQW55IG9iamVjdCBvciB2YWx1ZSB3aG9zZSBpbnRlcm5hbCBbW0NsYXNzXV0gcHJvcGVydHkgaXMgbm90IFxcXCJbb2JqZWN0IE9iamVjdF1cXFwiXFxuXFx0XFx0XFx0Ly8gLSBET00gbm9kZXNcXG5cXHRcXHRcXHQvLyAtIHdpbmRvd1xcblxcdFxcdFxcdGlmIChqUXVlcnkudHlwZShvYmopICE9PSBcXFwib2JqZWN0XFxcIiB8fCBvYmoubm9kZVR5cGUgfHwgalF1ZXJ5LmlzV2luZG93KG9iaikpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmIChvYmouY29uc3RydWN0b3IgJiYgIWhhc093bi5jYWxsKG9iai5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsIFxcXCJpc1Byb3RvdHlwZU9mXFxcIikpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIElmIHRoZSBmdW5jdGlvbiBoYXNuJ3QgcmV0dXJuZWQgYWxyZWFkeSwgd2UncmUgY29uZmlkZW50IHRoYXRcXG5cXHRcXHRcXHQvLyB8b2JqfCBpcyBhIHBsYWluIG9iamVjdCwgY3JlYXRlZCBieSB7fSBvciBjb25zdHJ1Y3RlZCB3aXRoIG5ldyBPYmplY3RcXG5cXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdGlzRW1wdHlPYmplY3Q6IGZ1bmN0aW9uIGlzRW1wdHlPYmplY3Qob2JqKSB7XFxuXFx0XFx0XFx0dmFyIG5hbWU7XFxuXFx0XFx0XFx0Zm9yIChuYW1lIGluIG9iaikge1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHR0eXBlOiBmdW5jdGlvbiB0eXBlKG9iaikge1xcblxcdFxcdFxcdGlmIChvYmogPT0gbnVsbCkge1xcblxcdFxcdFxcdFxcdHJldHVybiBvYmogKyBcXFwiXFxcIjtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LjAsIGlPUzw2IChmdW5jdGlvbmlzaCBSZWdFeHApXFxuXFx0XFx0XFx0cmV0dXJuICh0eXBlb2Ygb2JqID09PSBcXFwidW5kZWZpbmVkXFxcIiA/IFxcXCJ1bmRlZmluZWRcXFwiIDogX3R5cGVvZihvYmopKSA9PT0gXFxcIm9iamVjdFxcXCIgfHwgdHlwZW9mIG9iaiA9PT0gXFxcImZ1bmN0aW9uXFxcIiA/IGNsYXNzMnR5cGVbdG9TdHJpbmcuY2FsbChvYmopXSB8fCBcXFwib2JqZWN0XFxcIiA6IHR5cGVvZiBvYmogPT09IFxcXCJ1bmRlZmluZWRcXFwiID8gXFxcInVuZGVmaW5lZFxcXCIgOiBfdHlwZW9mKG9iaik7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyBFdmFsdWF0ZXMgYSBzY3JpcHQgaW4gYSBnbG9iYWwgY29udGV4dFxcblxcdFxcdGdsb2JhbEV2YWw6IGZ1bmN0aW9uIGdsb2JhbEV2YWwoY29kZSkge1xcblxcdFxcdFxcdHZhciBzY3JpcHQsXFxuXFx0XFx0XFx0ICAgIGluZGlyZWN0ID0gZXZhbDtcXG5cXG5cXHRcXHRcXHRjb2RlID0galF1ZXJ5LnRyaW0oY29kZSk7XFxuXFxuXFx0XFx0XFx0aWYgKGNvZGUpIHtcXG5cXHRcXHRcXHRcXHQvLyBJZiB0aGUgY29kZSBpbmNsdWRlcyBhIHZhbGlkLCBwcm9sb2d1ZSBwb3NpdGlvblxcblxcdFxcdFxcdFxcdC8vIHN0cmljdCBtb2RlIHByYWdtYSwgZXhlY3V0ZSBjb2RlIGJ5IGluamVjdGluZyBhXFxuXFx0XFx0XFx0XFx0Ly8gc2NyaXB0IHRhZyBpbnRvIHRoZSBkb2N1bWVudC5cXG5cXHRcXHRcXHRcXHRpZiAoY29kZS5pbmRleE9mKFxcXCJ1c2Ugc3RyaWN0XFxcIikgPT09IDEpIHtcXG5cXHRcXHRcXHRcXHRcXHRzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxcXCJzY3JpcHRcXFwiKTtcXG5cXHRcXHRcXHRcXHRcXHRzY3JpcHQudGV4dCA9IGNvZGU7XFxuXFx0XFx0XFx0XFx0XFx0ZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdC8vIE90aGVyd2lzZSwgYXZvaWQgdGhlIERPTSBub2RlIGNyZWF0aW9uLCBpbnNlcnRpb25cXG5cXHRcXHRcXHRcXHRcXHQvLyBhbmQgcmVtb3ZhbCBieSB1c2luZyBhbiBpbmRpcmVjdCBnbG9iYWwgZXZhbFxcblxcdFxcdFxcdFxcdFxcdGluZGlyZWN0KGNvZGUpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyBDb252ZXJ0IGRhc2hlZCB0byBjYW1lbENhc2U7IHVzZWQgYnkgdGhlIGNzcyBhbmQgZGF0YSBtb2R1bGVzXFxuXFx0XFx0Ly8gU3VwcG9ydDogSUU5LTExK1xcblxcdFxcdC8vIE1pY3Jvc29mdCBmb3Jnb3QgdG8gaHVtcCB0aGVpciB2ZW5kb3IgcHJlZml4ICgjOTU3MilcXG5cXHRcXHRjYW1lbENhc2U6IGZ1bmN0aW9uIGNhbWVsQ2FzZShzdHJpbmcpIHtcXG5cXHRcXHRcXHRyZXR1cm4gc3RyaW5nLnJlcGxhY2Uocm1zUHJlZml4LCBcXFwibXMtXFxcIikucmVwbGFjZShyZGFzaEFscGhhLCBmY2FtZWxDYXNlKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdG5vZGVOYW1lOiBmdW5jdGlvbiBub2RlTmFtZShlbGVtLCBuYW1lKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lLnRvTG93ZXJDYXNlKCk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyBhcmdzIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XFxuXFx0XFx0ZWFjaDogZnVuY3Rpb24gZWFjaChvYmosIGNhbGxiYWNrLCBhcmdzKSB7XFxuXFx0XFx0XFx0dmFyIHZhbHVlLFxcblxcdFxcdFxcdCAgICBpID0gMCxcXG5cXHRcXHRcXHQgICAgbGVuZ3RoID0gb2JqLmxlbmd0aCxcXG5cXHRcXHRcXHQgICAgaXNBcnJheSA9IGlzQXJyYXlsaWtlKG9iaik7XFxuXFxuXFx0XFx0XFx0aWYgKGFyZ3MpIHtcXG5cXHRcXHRcXHRcXHRpZiAoaXNBcnJheSkge1xcblxcdFxcdFxcdFxcdFxcdGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YWx1ZSA9IGNhbGxiYWNrLmFwcGx5KG9ialtpXSwgYXJncyk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKHZhbHVlID09PSBmYWxzZSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRmb3IgKGkgaW4gb2JqKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFsdWUgPSBjYWxsYmFjay5hcHBseShvYmpbaV0sIGFyZ3MpO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBBIHNwZWNpYWwsIGZhc3QsIGNhc2UgZm9yIHRoZSBtb3N0IGNvbW1vbiB1c2Ugb2YgZWFjaFxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0aWYgKGlzQXJyYXkpIHtcXG5cXHRcXHRcXHRcXHRcXHRmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFsdWUgPSBjYWxsYmFjay5jYWxsKG9ialtpXSwgaSwgb2JqW2ldKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAodmFsdWUgPT09IGZhbHNlKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdGZvciAoaSBpbiBvYmopIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YWx1ZSA9IGNhbGxiYWNrLmNhbGwob2JqW2ldLCBpLCBvYmpbaV0pO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIG9iajtcXG5cXHRcXHR9LFxcblxcblxcdFxcdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4xXFxuXFx0XFx0dHJpbTogZnVuY3Rpb24gdHJpbSh0ZXh0KSB7XFxuXFx0XFx0XFx0cmV0dXJuIHRleHQgPT0gbnVsbCA/IFxcXCJcXFwiIDogKHRleHQgKyBcXFwiXFxcIikucmVwbGFjZShydHJpbSwgXFxcIlxcXCIpO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0Ly8gcmVzdWx0cyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxcblxcdFxcdG1ha2VBcnJheTogZnVuY3Rpb24gbWFrZUFycmF5KGFyciwgcmVzdWx0cykge1xcblxcdFxcdFxcdHZhciByZXQgPSByZXN1bHRzIHx8IFtdO1xcblxcblxcdFxcdFxcdGlmIChhcnIgIT0gbnVsbCkge1xcblxcdFxcdFxcdFxcdGlmIChpc0FycmF5bGlrZShPYmplY3QoYXJyKSkpIHtcXG5cXHRcXHRcXHRcXHRcXHRqUXVlcnkubWVyZ2UocmV0LCB0eXBlb2YgYXJyID09PSBcXFwic3RyaW5nXFxcIiA/IFthcnJdIDogYXJyKTtcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdHB1c2guY2FsbChyZXQsIGFycik7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gcmV0O1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0aW5BcnJheTogZnVuY3Rpb24gaW5BcnJheShlbGVtLCBhcnIsIGkpIHtcXG5cXHRcXHRcXHRyZXR1cm4gYXJyID09IG51bGwgPyAtMSA6IGluZGV4T2YuY2FsbChhcnIsIGVsZW0sIGkpO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0bWVyZ2U6IGZ1bmN0aW9uIG1lcmdlKGZpcnN0LCBzZWNvbmQpIHtcXG5cXHRcXHRcXHR2YXIgbGVuID0gK3NlY29uZC5sZW5ndGgsXFxuXFx0XFx0XFx0ICAgIGogPSAwLFxcblxcdFxcdFxcdCAgICBpID0gZmlyc3QubGVuZ3RoO1xcblxcblxcdFxcdFxcdGZvciAoOyBqIDwgbGVuOyBqKyspIHtcXG5cXHRcXHRcXHRcXHRmaXJzdFtpKytdID0gc2Vjb25kW2pdO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRmaXJzdC5sZW5ndGggPSBpO1xcblxcblxcdFxcdFxcdHJldHVybiBmaXJzdDtcXG5cXHRcXHR9LFxcblxcblxcdFxcdGdyZXA6IGZ1bmN0aW9uIGdyZXAoZWxlbXMsIGNhbGxiYWNrLCBpbnZlcnQpIHtcXG5cXHRcXHRcXHR2YXIgY2FsbGJhY2tJbnZlcnNlLFxcblxcdFxcdFxcdCAgICBtYXRjaGVzID0gW10sXFxuXFx0XFx0XFx0ICAgIGkgPSAwLFxcblxcdFxcdFxcdCAgICBsZW5ndGggPSBlbGVtcy5sZW5ndGgsXFxuXFx0XFx0XFx0ICAgIGNhbGxiYWNrRXhwZWN0ID0gIWludmVydDtcXG5cXG5cXHRcXHRcXHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgb25seSBzYXZpbmcgdGhlIGl0ZW1zXFxuXFx0XFx0XFx0Ly8gdGhhdCBwYXNzIHRoZSB2YWxpZGF0b3IgZnVuY3Rpb25cXG5cXHRcXHRcXHRmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0Y2FsbGJhY2tJbnZlcnNlID0gIWNhbGxiYWNrKGVsZW1zW2ldLCBpKTtcXG5cXHRcXHRcXHRcXHRpZiAoY2FsbGJhY2tJbnZlcnNlICE9PSBjYWxsYmFja0V4cGVjdCkge1xcblxcdFxcdFxcdFxcdFxcdG1hdGNoZXMucHVzaChlbGVtc1tpXSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gbWF0Y2hlcztcXG5cXHRcXHR9LFxcblxcblxcdFxcdC8vIGFyZyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxcblxcdFxcdG1hcDogZnVuY3Rpb24gbWFwKGVsZW1zLCBjYWxsYmFjaywgYXJnKSB7XFxuXFx0XFx0XFx0dmFyIHZhbHVlLFxcblxcdFxcdFxcdCAgICBpID0gMCxcXG5cXHRcXHRcXHQgICAgbGVuZ3RoID0gZWxlbXMubGVuZ3RoLFxcblxcdFxcdFxcdCAgICBpc0FycmF5ID0gaXNBcnJheWxpa2UoZWxlbXMpLFxcblxcdFxcdFxcdCAgICByZXQgPSBbXTtcXG5cXG5cXHRcXHRcXHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgdHJhbnNsYXRpbmcgZWFjaCBvZiB0aGUgaXRlbXMgdG8gdGhlaXIgbmV3IHZhbHVlc1xcblxcdFxcdFxcdGlmIChpc0FycmF5KSB7XFxuXFx0XFx0XFx0XFx0Zm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdHZhbHVlID0gY2FsbGJhY2soZWxlbXNbaV0sIGksIGFyZyk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKHZhbHVlICE9IG51bGwpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXQucHVzaCh2YWx1ZSk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBHbyB0aHJvdWdoIGV2ZXJ5IGtleSBvbiB0aGUgb2JqZWN0LFxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0Zm9yIChpIGluIGVsZW1zKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFsdWUgPSBjYWxsYmFjayhlbGVtc1tpXSwgaSwgYXJnKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAodmFsdWUgIT0gbnVsbCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldC5wdXNoKHZhbHVlKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXFxuXFx0XFx0XFx0cmV0dXJuIGNvbmNhdC5hcHBseShbXSwgcmV0KTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdC8vIEEgZ2xvYmFsIEdVSUQgY291bnRlciBmb3Igb2JqZWN0c1xcblxcdFxcdGd1aWQ6IDEsXFxuXFxuXFx0XFx0Ly8gQmluZCBhIGZ1bmN0aW9uIHRvIGEgY29udGV4dCwgb3B0aW9uYWxseSBwYXJ0aWFsbHkgYXBwbHlpbmcgYW55XFxuXFx0XFx0Ly8gYXJndW1lbnRzLlxcblxcdFxcdHByb3h5OiBmdW5jdGlvbiBwcm94eShmbiwgY29udGV4dCkge1xcblxcdFxcdFxcdHZhciB0bXAsIGFyZ3MsIHByb3h5O1xcblxcblxcdFxcdFxcdGlmICh0eXBlb2YgY29udGV4dCA9PT0gXFxcInN0cmluZ1xcXCIpIHtcXG5cXHRcXHRcXHRcXHR0bXAgPSBmbltjb250ZXh0XTtcXG5cXHRcXHRcXHRcXHRjb250ZXh0ID0gZm47XFxuXFx0XFx0XFx0XFx0Zm4gPSB0bXA7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFF1aWNrIGNoZWNrIHRvIGRldGVybWluZSBpZiB0YXJnZXQgaXMgY2FsbGFibGUsIGluIHRoZSBzcGVjXFxuXFx0XFx0XFx0Ly8gdGhpcyB0aHJvd3MgYSBUeXBlRXJyb3IsIGJ1dCB3ZSB3aWxsIGp1c3QgcmV0dXJuIHVuZGVmaW5lZC5cXG5cXHRcXHRcXHRpZiAoIWpRdWVyeS5pc0Z1bmN0aW9uKGZuKSkge1xcblxcdFxcdFxcdFxcdHJldHVybiB1bmRlZmluZWQ7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFNpbXVsYXRlZCBiaW5kXFxuXFx0XFx0XFx0YXJncyA9IF9zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XFxuXFx0XFx0XFx0cHJveHkgPSBmdW5jdGlvbiBwcm94eSgpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZm4uYXBwbHkoY29udGV4dCB8fCB0aGlzLCBhcmdzLmNvbmNhdChfc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHRcXHQvLyBTZXQgdGhlIGd1aWQgb2YgdW5pcXVlIGhhbmRsZXIgdG8gdGhlIHNhbWUgb2Ygb3JpZ2luYWwgaGFuZGxlciwgc28gaXQgY2FuIGJlIHJlbW92ZWRcXG5cXHRcXHRcXHRwcm94eS5ndWlkID0gZm4uZ3VpZCA9IGZuLmd1aWQgfHwgalF1ZXJ5Lmd1aWQrKztcXG5cXG5cXHRcXHRcXHRyZXR1cm4gcHJveHk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRub3c6IERhdGUubm93LFxcblxcblxcdFxcdC8vIGpRdWVyeS5zdXBwb3J0IGlzIG5vdCB1c2VkIGluIENvcmUgYnV0IG90aGVyIHByb2plY3RzIGF0dGFjaCB0aGVpclxcblxcdFxcdC8vIHByb3BlcnRpZXMgdG8gaXQgc28gaXQgbmVlZHMgdG8gZXhpc3QuXFxuXFx0XFx0c3VwcG9ydDogc3VwcG9ydFxcblxcdH0pO1xcblxcblxcdC8vIFBvcHVsYXRlIHRoZSBjbGFzczJ0eXBlIG1hcFxcblxcdGpRdWVyeS5lYWNoKFxcXCJCb29sZWFuIE51bWJlciBTdHJpbmcgRnVuY3Rpb24gQXJyYXkgRGF0ZSBSZWdFeHAgT2JqZWN0IEVycm9yXFxcIi5zcGxpdChcXFwiIFxcXCIpLCBmdW5jdGlvbiAoaSwgbmFtZSkge1xcblxcdFxcdGNsYXNzMnR5cGVbXFxcIltvYmplY3QgXFxcIiArIG5hbWUgKyBcXFwiXVxcXCJdID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xcblxcdH0pO1xcblxcblxcdGZ1bmN0aW9uIGlzQXJyYXlsaWtlKG9iaikge1xcblxcblxcdFxcdC8vIFN1cHBvcnQ6IGlPUyA4LjIgKG5vdCByZXByb2R1Y2libGUgaW4gc2ltdWxhdG9yKVxcblxcdFxcdC8vIGBpbmAgY2hlY2sgdXNlZCB0byBwcmV2ZW50IEpJVCBlcnJvciAoZ2gtMjE0NSlcXG5cXHRcXHQvLyBoYXNPd24gaXNuJ3QgdXNlZCBoZXJlIGR1ZSB0byBmYWxzZSBuZWdhdGl2ZXNcXG5cXHRcXHQvLyByZWdhcmRpbmcgTm9kZWxpc3QgbGVuZ3RoIGluIElFXFxuXFx0XFx0dmFyIGxlbmd0aCA9IFxcXCJsZW5ndGhcXFwiIGluIG9iaiAmJiBvYmoubGVuZ3RoLFxcblxcdFxcdCAgICB0eXBlID0galF1ZXJ5LnR5cGUob2JqKTtcXG5cXG5cXHRcXHRpZiAodHlwZSA9PT0gXFxcImZ1bmN0aW9uXFxcIiB8fCBqUXVlcnkuaXNXaW5kb3cob2JqKSkge1xcblxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKG9iai5ub2RlVHlwZSA9PT0gMSAmJiBsZW5ndGgpIHtcXG5cXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIHR5cGUgPT09IFxcXCJhcnJheVxcXCIgfHwgbGVuZ3RoID09PSAwIHx8IHR5cGVvZiBsZW5ndGggPT09IFxcXCJudW1iZXJcXFwiICYmIGxlbmd0aCA+IDAgJiYgbGVuZ3RoIC0gMSBpbiBvYmo7XFxuXFx0fVxcblxcdHZhciBTaXp6bGUgPVxcblxcdC8qIVxcbiAgKiBTaXp6bGUgQ1NTIFNlbGVjdG9yIEVuZ2luZSB2Mi4yLjAtcHJlXFxuICAqIGh0dHA6Ly9zaXp6bGVqcy5jb20vXFxuICAqXFxuICAqIENvcHlyaWdodCAyMDA4LCAyMDE0IGpRdWVyeSBGb3VuZGF0aW9uLCBJbmMuIGFuZCBvdGhlciBjb250cmlidXRvcnNcXG4gICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXFxuICAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcXG4gICpcXG4gICogRGF0ZTogMjAxNC0xMi0xNlxcbiAgKi9cXG5cXHRmdW5jdGlvbiAod2luZG93KSB7XFxuXFxuXFx0XFx0dmFyIGksXFxuXFx0XFx0ICAgIHN1cHBvcnQsXFxuXFx0XFx0ICAgIEV4cHIsXFxuXFx0XFx0ICAgIGdldFRleHQsXFxuXFx0XFx0ICAgIGlzWE1MLFxcblxcdFxcdCAgICB0b2tlbml6ZSxcXG5cXHRcXHQgICAgY29tcGlsZSxcXG5cXHRcXHQgICAgc2VsZWN0LFxcblxcdFxcdCAgICBvdXRlcm1vc3RDb250ZXh0LFxcblxcdFxcdCAgICBzb3J0SW5wdXQsXFxuXFx0XFx0ICAgIGhhc0R1cGxpY2F0ZSxcXG5cXG5cXG5cXHRcXHQvLyBMb2NhbCBkb2N1bWVudCB2YXJzXFxuXFx0XFx0c2V0RG9jdW1lbnQsXFxuXFx0XFx0ICAgIGRvY3VtZW50LFxcblxcdFxcdCAgICBkb2NFbGVtLFxcblxcdFxcdCAgICBkb2N1bWVudElzSFRNTCxcXG5cXHRcXHQgICAgcmJ1Z2d5UVNBLFxcblxcdFxcdCAgICByYnVnZ3lNYXRjaGVzLFxcblxcdFxcdCAgICBtYXRjaGVzLFxcblxcdFxcdCAgICBjb250YWlucyxcXG5cXG5cXG5cXHRcXHQvLyBJbnN0YW5jZS1zcGVjaWZpYyBkYXRhXFxuXFx0XFx0ZXhwYW5kbyA9IFxcXCJzaXp6bGVcXFwiICsgMSAqIG5ldyBEYXRlKCksXFxuXFx0XFx0ICAgIHByZWZlcnJlZERvYyA9IHdpbmRvdy5kb2N1bWVudCxcXG5cXHRcXHQgICAgZGlycnVucyA9IDAsXFxuXFx0XFx0ICAgIGRvbmUgPSAwLFxcblxcdFxcdCAgICBjbGFzc0NhY2hlID0gY3JlYXRlQ2FjaGUoKSxcXG5cXHRcXHQgICAgdG9rZW5DYWNoZSA9IGNyZWF0ZUNhY2hlKCksXFxuXFx0XFx0ICAgIGNvbXBpbGVyQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxcblxcdFxcdCAgICBzb3J0T3JkZXIgPSBmdW5jdGlvbiBzb3J0T3JkZXIoYSwgYikge1xcblxcdFxcdFxcdGlmIChhID09PSBiKSB7XFxuXFx0XFx0XFx0XFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIDA7XFxuXFx0XFx0fSxcXG5cXG5cXG5cXHRcXHQvLyBHZW5lcmFsLXB1cnBvc2UgY29uc3RhbnRzXFxuXFx0XFx0TUFYX05FR0FUSVZFID0gMSA8PCAzMSxcXG5cXG5cXG5cXHRcXHQvLyBJbnN0YW5jZSBtZXRob2RzXFxuXFx0XFx0aGFzT3duID0ge30uaGFzT3duUHJvcGVydHksXFxuXFx0XFx0ICAgIGFyciA9IFtdLFxcblxcdFxcdCAgICBwb3AgPSBhcnIucG9wLFxcblxcdFxcdCAgICBwdXNoX25hdGl2ZSA9IGFyci5wdXNoLFxcblxcdFxcdCAgICBwdXNoID0gYXJyLnB1c2gsXFxuXFx0XFx0ICAgIHNsaWNlID0gYXJyLnNsaWNlLFxcblxcblxcdFxcdC8vIFVzZSBhIHN0cmlwcGVkLWRvd24gaW5kZXhPZiBhcyBpdCdzIGZhc3RlciB0aGFuIG5hdGl2ZVxcblxcdFxcdC8vIGh0dHA6Ly9qc3BlcmYuY29tL3Rob3ItaW5kZXhvZi12cy1mb3IvNVxcblxcdFxcdGluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mKGxpc3QsIGVsZW0pIHtcXG5cXHRcXHRcXHR2YXIgaSA9IDAsXFxuXFx0XFx0XFx0ICAgIGxlbiA9IGxpc3QubGVuZ3RoO1xcblxcdFxcdFxcdGZvciAoOyBpIDwgbGVuOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRpZiAobGlzdFtpXSA9PT0gZWxlbSkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIC0xO1xcblxcdFxcdH0sXFxuXFx0XFx0ICAgIGJvb2xlYW5zID0gXFxcImNoZWNrZWR8c2VsZWN0ZWR8YXN5bmN8YXV0b2ZvY3VzfGF1dG9wbGF5fGNvbnRyb2xzfGRlZmVyfGRpc2FibGVkfGhpZGRlbnxpc21hcHxsb29wfG11bHRpcGxlfG9wZW58cmVhZG9ubHl8cmVxdWlyZWR8c2NvcGVkXFxcIixcXG5cXG5cXG5cXHRcXHQvLyBSZWd1bGFyIGV4cHJlc3Npb25zXFxuXFxuXFx0XFx0Ly8gV2hpdGVzcGFjZSBjaGFyYWN0ZXJzIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtc2VsZWN0b3JzLyN3aGl0ZXNwYWNlXFxuXFx0XFx0d2hpdGVzcGFjZSA9IFxcXCJbXFxcXFxcXFx4MjBcXFxcXFxcXHRcXFxcXFxcXHJcXFxcXFxcXG5cXFxcXFxcXGZdXFxcIixcXG5cXG5cXHRcXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXN5bnRheC8jY2hhcmFjdGVyc1xcblxcdFxcdGNoYXJhY3RlckVuY29kaW5nID0gXFxcIig/OlxcXFxcXFxcXFxcXFxcXFwufFtcXFxcXFxcXHctXXxbXlxcXFxcXFxceDAwLVxcXFxcXFxceGEwXSkrXFxcIixcXG5cXG5cXG5cXHRcXHQvLyBMb29zZWx5IG1vZGVsZWQgb24gQ1NTIGlkZW50aWZpZXIgY2hhcmFjdGVyc1xcblxcdFxcdC8vIEFuIHVucXVvdGVkIHZhbHVlIHNob3VsZCBiZSBhIENTUyBpZGVudGlmaWVyIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtc2VsZWN0b3JzLyNhdHRyaWJ1dGUtc2VsZWN0b3JzXFxuXFx0XFx0Ly8gUHJvcGVyIHN5bnRheDogaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI3ZhbHVlLWRlZi1pZGVudGlmaWVyXFxuXFx0XFx0aWRlbnRpZmllciA9IGNoYXJhY3RlckVuY29kaW5nLnJlcGxhY2UoXFxcIndcXFwiLCBcXFwidyNcXFwiKSxcXG5cXG5cXG5cXHRcXHQvLyBBdHRyaWJ1dGUgc2VsZWN0b3JzOiBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2F0dHJpYnV0ZS1zZWxlY3RvcnNcXG5cXHRcXHRhdHRyaWJ1dGVzID0gXFxcIlxcXFxcXFxcW1xcXCIgKyB3aGl0ZXNwYWNlICsgXFxcIiooXFxcIiArIGNoYXJhY3RlckVuY29kaW5nICsgXFxcIikoPzpcXFwiICsgd2hpdGVzcGFjZSArXFxuXFx0XFx0Ly8gT3BlcmF0b3IgKGNhcHR1cmUgMilcXG5cXHRcXHRcXFwiKihbKl4kfCF+XT89KVxcXCIgKyB3aGl0ZXNwYWNlICtcXG5cXHRcXHQvLyBcXFwiQXR0cmlidXRlIHZhbHVlcyBtdXN0IGJlIENTUyBpZGVudGlmaWVycyBbY2FwdHVyZSA1XSBvciBzdHJpbmdzIFtjYXB0dXJlIDMgb3IgY2FwdHVyZSA0XVxcXCJcXG5cXHRcXHRcXFwiKig/OicoKD86XFxcXFxcXFxcXFxcXFxcXC58W15cXFxcXFxcXFxcXFxcXFxcJ10pKiknfFxcXFxcXFwiKCg/OlxcXFxcXFxcXFxcXFxcXFwufFteXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFwiXSkqKVxcXFxcXFwifChcXFwiICsgaWRlbnRpZmllciArIFxcXCIpKXwpXFxcIiArIHdoaXRlc3BhY2UgKyBcXFwiKlxcXFxcXFxcXVxcXCIsXFxuXFx0XFx0ICAgIHBzZXVkb3MgPSBcXFwiOihcXFwiICsgY2hhcmFjdGVyRW5jb2RpbmcgKyBcXFwiKSg/OlxcXFxcXFxcKChcXFwiICtcXG5cXHRcXHQvLyBUbyByZWR1Y2UgdGhlIG51bWJlciBvZiBzZWxlY3RvcnMgbmVlZGluZyB0b2tlbml6ZSBpbiB0aGUgcHJlRmlsdGVyLCBwcmVmZXIgYXJndW1lbnRzOlxcblxcdFxcdC8vIDEuIHF1b3RlZCAoY2FwdHVyZSAzOyBjYXB0dXJlIDQgb3IgY2FwdHVyZSA1KVxcblxcdFxcdFxcXCIoJygoPzpcXFxcXFxcXFxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcXFxcXFwnXSkqKSd8XFxcXFxcXCIoKD86XFxcXFxcXFxcXFxcXFxcXC58W15cXFxcXFxcXFxcXFxcXFxcXFxcXFxcXCJdKSopXFxcXFxcXCIpfFxcXCIgK1xcblxcdFxcdC8vIDIuIHNpbXBsZSAoY2FwdHVyZSA2KVxcblxcdFxcdFxcXCIoKD86XFxcXFxcXFxcXFxcXFxcXC58W15cXFxcXFxcXFxcXFxcXFxcKClbXFxcXFxcXFxdXXxcXFwiICsgYXR0cmlidXRlcyArIFxcXCIpKil8XFxcIiArXFxuXFx0XFx0Ly8gMy4gYW55dGhpbmcgZWxzZSAoY2FwdHVyZSAyKVxcblxcdFxcdFxcXCIuKlxcXCIgKyBcXFwiKVxcXFxcXFxcKXwpXFxcIixcXG5cXG5cXG5cXHRcXHQvLyBMZWFkaW5nIGFuZCBub24tZXNjYXBlZCB0cmFpbGluZyB3aGl0ZXNwYWNlLCBjYXB0dXJpbmcgc29tZSBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXJzIHByZWNlZGluZyB0aGUgbGF0dGVyXFxuXFx0XFx0cndoaXRlc3BhY2UgPSBuZXcgUmVnRXhwKHdoaXRlc3BhY2UgKyBcXFwiK1xcXCIsIFxcXCJnXFxcIiksXFxuXFx0XFx0ICAgIHJ0cmltID0gbmV3IFJlZ0V4cChcXFwiXlxcXCIgKyB3aGl0ZXNwYWNlICsgXFxcIit8KCg/Ol58W15cXFxcXFxcXFxcXFxcXFxcXSkoPzpcXFxcXFxcXFxcXFxcXFxcLikqKVxcXCIgKyB3aGl0ZXNwYWNlICsgXFxcIiskXFxcIiwgXFxcImdcXFwiKSxcXG5cXHRcXHQgICAgcmNvbW1hID0gbmV3IFJlZ0V4cChcXFwiXlxcXCIgKyB3aGl0ZXNwYWNlICsgXFxcIiosXFxcIiArIHdoaXRlc3BhY2UgKyBcXFwiKlxcXCIpLFxcblxcdFxcdCAgICByY29tYmluYXRvcnMgPSBuZXcgUmVnRXhwKFxcXCJeXFxcIiArIHdoaXRlc3BhY2UgKyBcXFwiKihbPit+XXxcXFwiICsgd2hpdGVzcGFjZSArIFxcXCIpXFxcIiArIHdoaXRlc3BhY2UgKyBcXFwiKlxcXCIpLFxcblxcdFxcdCAgICByYXR0cmlidXRlUXVvdGVzID0gbmV3IFJlZ0V4cChcXFwiPVxcXCIgKyB3aGl0ZXNwYWNlICsgXFxcIiooW15cXFxcXFxcXF0nXFxcXFxcXCJdKj8pXFxcIiArIHdoaXRlc3BhY2UgKyBcXFwiKlxcXFxcXFxcXVxcXCIsIFxcXCJnXFxcIiksXFxuXFx0XFx0ICAgIHJwc2V1ZG8gPSBuZXcgUmVnRXhwKHBzZXVkb3MpLFxcblxcdFxcdCAgICByaWRlbnRpZmllciA9IG5ldyBSZWdFeHAoXFxcIl5cXFwiICsgaWRlbnRpZmllciArIFxcXCIkXFxcIiksXFxuXFx0XFx0ICAgIG1hdGNoRXhwciA9IHtcXG5cXHRcXHRcXHRcXFwiSURcXFwiOiBuZXcgUmVnRXhwKFxcXCJeIyhcXFwiICsgY2hhcmFjdGVyRW5jb2RpbmcgKyBcXFwiKVxcXCIpLFxcblxcdFxcdFxcdFxcXCJDTEFTU1xcXCI6IG5ldyBSZWdFeHAoXFxcIl5cXFxcXFxcXC4oXFxcIiArIGNoYXJhY3RlckVuY29kaW5nICsgXFxcIilcXFwiKSxcXG5cXHRcXHRcXHRcXFwiVEFHXFxcIjogbmV3IFJlZ0V4cChcXFwiXihcXFwiICsgY2hhcmFjdGVyRW5jb2RpbmcucmVwbGFjZShcXFwid1xcXCIsIFxcXCJ3KlxcXCIpICsgXFxcIilcXFwiKSxcXG5cXHRcXHRcXHRcXFwiQVRUUlxcXCI6IG5ldyBSZWdFeHAoXFxcIl5cXFwiICsgYXR0cmlidXRlcyksXFxuXFx0XFx0XFx0XFxcIlBTRVVET1xcXCI6IG5ldyBSZWdFeHAoXFxcIl5cXFwiICsgcHNldWRvcyksXFxuXFx0XFx0XFx0XFxcIkNISUxEXFxcIjogbmV3IFJlZ0V4cChcXFwiXjoob25seXxmaXJzdHxsYXN0fG50aHxudGgtbGFzdCktKGNoaWxkfG9mLXR5cGUpKD86XFxcXFxcXFwoXFxcIiArIHdoaXRlc3BhY2UgKyBcXFwiKihldmVufG9kZHwoKFsrLV18KShcXFxcXFxcXGQqKW58KVxcXCIgKyB3aGl0ZXNwYWNlICsgXFxcIiooPzooWystXXwpXFxcIiArIHdoaXRlc3BhY2UgKyBcXFwiKihcXFxcXFxcXGQrKXwpKVxcXCIgKyB3aGl0ZXNwYWNlICsgXFxcIipcXFxcXFxcXCl8KVxcXCIsIFxcXCJpXFxcIiksXFxuXFx0XFx0XFx0XFxcImJvb2xcXFwiOiBuZXcgUmVnRXhwKFxcXCJeKD86XFxcIiArIGJvb2xlYW5zICsgXFxcIikkXFxcIiwgXFxcImlcXFwiKSxcXG5cXHRcXHRcXHQvLyBGb3IgdXNlIGluIGxpYnJhcmllcyBpbXBsZW1lbnRpbmcgLmlzKClcXG5cXHRcXHRcXHQvLyBXZSB1c2UgdGhpcyBmb3IgUE9TIG1hdGNoaW5nIGluIGBzZWxlY3RgXFxuXFx0XFx0XFx0XFxcIm5lZWRzQ29udGV4dFxcXCI6IG5ldyBSZWdFeHAoXFxcIl5cXFwiICsgd2hpdGVzcGFjZSArIFxcXCIqWz4rfl18OihldmVufG9kZHxlcXxndHxsdHxudGh8Zmlyc3R8bGFzdCkoPzpcXFxcXFxcXChcXFwiICsgd2hpdGVzcGFjZSArIFxcXCIqKCg/Oi1cXFxcXFxcXGQpP1xcXFxcXFxcZCopXFxcIiArIHdoaXRlc3BhY2UgKyBcXFwiKlxcXFxcXFxcKXwpKD89W14tXXwkKVxcXCIsIFxcXCJpXFxcIilcXG5cXHRcXHR9LFxcblxcdFxcdCAgICByaW5wdXRzID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcXG5cXHRcXHQgICAgcmhlYWRlciA9IC9eaFxcXFxkJC9pLFxcblxcdFxcdCAgICBybmF0aXZlID0gL15bXntdK1xcXFx7XFxcXHMqXFxcXFtuYXRpdmUgXFxcXHcvLFxcblxcblxcblxcdFxcdC8vIEVhc2lseS1wYXJzZWFibGUvcmV0cmlldmFibGUgSUQgb3IgVEFHIG9yIENMQVNTIHNlbGVjdG9yc1xcblxcdFxcdHJxdWlja0V4cHIgPSAvXig/OiMoW1xcXFx3LV0rKXwoXFxcXHcrKXxcXFxcLihbXFxcXHctXSspKSQvLFxcblxcdFxcdCAgICByc2libGluZyA9IC9bK35dLyxcXG5cXHRcXHQgICAgcmVzY2FwZSA9IC8nfFxcXFxcXFxcL2csXFxuXFxuXFxuXFx0XFx0Ly8gQ1NTIGVzY2FwZXMgaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI2VzY2FwZWQtY2hhcmFjdGVyc1xcblxcdFxcdHJ1bmVzY2FwZSA9IG5ldyBSZWdFeHAoXFxcIlxcXFxcXFxcXFxcXFxcXFwoW1xcXFxcXFxcZGEtZl17MSw2fVxcXCIgKyB3aGl0ZXNwYWNlICsgXFxcIj98KFxcXCIgKyB3aGl0ZXNwYWNlICsgXFxcIil8LilcXFwiLCBcXFwiaWdcXFwiKSxcXG5cXHRcXHQgICAgZnVuZXNjYXBlID0gZnVuY3Rpb24gZnVuZXNjYXBlKF8sIGVzY2FwZWQsIGVzY2FwZWRXaGl0ZXNwYWNlKSB7XFxuXFx0XFx0XFx0dmFyIGhpZ2ggPSBcXFwiMHhcXFwiICsgZXNjYXBlZCAtIDB4MTAwMDA7XFxuXFx0XFx0XFx0Ly8gTmFOIG1lYW5zIG5vbi1jb2RlcG9pbnRcXG5cXHRcXHRcXHQvLyBTdXBwb3J0OiBGaXJlZm94PDI0XFxuXFx0XFx0XFx0Ly8gV29ya2Fyb3VuZCBlcnJvbmVvdXMgbnVtZXJpYyBpbnRlcnByZXRhdGlvbiBvZiArXFxcIjB4XFxcIlxcblxcdFxcdFxcdHJldHVybiBoaWdoICE9PSBoaWdoIHx8IGVzY2FwZWRXaGl0ZXNwYWNlID8gZXNjYXBlZCA6IGhpZ2ggPCAwID9cXG5cXHRcXHRcXHQvLyBCTVAgY29kZXBvaW50XFxuXFx0XFx0XFx0U3RyaW5nLmZyb21DaGFyQ29kZShoaWdoICsgMHgxMDAwMCkgOlxcblxcdFxcdFxcdC8vIFN1cHBsZW1lbnRhbCBQbGFuZSBjb2RlcG9pbnQgKHN1cnJvZ2F0ZSBwYWlyKVxcblxcdFxcdFxcdFN0cmluZy5mcm9tQ2hhckNvZGUoaGlnaCA+PiAxMCB8IDB4RDgwMCwgaGlnaCAmIDB4M0ZGIHwgMHhEQzAwKTtcXG5cXHRcXHR9LFxcblxcblxcblxcdFxcdC8vIFVzZWQgZm9yIGlmcmFtZXNcXG5cXHRcXHQvLyBTZWUgc2V0RG9jdW1lbnQoKVxcblxcdFxcdC8vIFJlbW92aW5nIHRoZSBmdW5jdGlvbiB3cmFwcGVyIGNhdXNlcyBhIFxcXCJQZXJtaXNzaW9uIERlbmllZFxcXCJcXG5cXHRcXHQvLyBlcnJvciBpbiBJRVxcblxcdFxcdHVubG9hZEhhbmRsZXIgPSBmdW5jdGlvbiB1bmxvYWRIYW5kbGVyKCkge1xcblxcdFxcdFxcdHNldERvY3VtZW50KCk7XFxuXFx0XFx0fTtcXG5cXG5cXHRcXHQvLyBPcHRpbWl6ZSBmb3IgcHVzaC5hcHBseSggXywgTm9kZUxpc3QgKVxcblxcdFxcdHRyeSB7XFxuXFx0XFx0XFx0cHVzaC5hcHBseShhcnIgPSBzbGljZS5jYWxsKHByZWZlcnJlZERvYy5jaGlsZE5vZGVzKSwgcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMpO1xcblxcdFxcdFxcdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4wXFxuXFx0XFx0XFx0Ly8gRGV0ZWN0IHNpbGVudGx5IGZhaWxpbmcgcHVzaC5hcHBseVxcblxcdFxcdFxcdGFycltwcmVmZXJyZWREb2MuY2hpbGROb2Rlcy5sZW5ndGhdLm5vZGVUeXBlO1xcblxcdFxcdH0gY2F0Y2ggKGUpIHtcXG5cXHRcXHRcXHRwdXNoID0geyBhcHBseTogYXJyLmxlbmd0aCA/XFxuXFxuXFx0XFx0XFx0XFx0Ly8gTGV2ZXJhZ2Ugc2xpY2UgaWYgcG9zc2libGVcXG5cXHRcXHRcXHRcXHRmdW5jdGlvbiAodGFyZ2V0LCBlbHMpIHtcXG5cXHRcXHRcXHRcXHRcXHRwdXNoX25hdGl2ZS5hcHBseSh0YXJnZXQsIHNsaWNlLmNhbGwoZWxzKSk7XFxuXFx0XFx0XFx0XFx0fSA6XFxuXFxuXFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogSUU8OVxcblxcdFxcdFxcdFxcdC8vIE90aGVyd2lzZSBhcHBlbmQgZGlyZWN0bHlcXG5cXHRcXHRcXHRcXHRmdW5jdGlvbiAodGFyZ2V0LCBlbHMpIHtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgaiA9IHRhcmdldC5sZW5ndGgsXFxuXFx0XFx0XFx0XFx0XFx0ICAgIGkgPSAwO1xcblxcdFxcdFxcdFxcdFxcdC8vIENhbid0IHRydXN0IE5vZGVMaXN0Lmxlbmd0aFxcblxcdFxcdFxcdFxcdFxcdHdoaWxlICh0YXJnZXRbaisrXSA9IGVsc1tpKytdKSB7fVxcblxcdFxcdFxcdFxcdFxcdHRhcmdldC5sZW5ndGggPSBqIC0gMTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gU2l6emxlKHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkKSB7XFxuXFx0XFx0XFx0dmFyIG1hdGNoLCBlbGVtLCBtLCBub2RlVHlwZSxcXG5cXHRcXHRcXHQvLyBRU0EgdmFyc1xcblxcdFxcdFxcdGksIGdyb3Vwcywgb2xkLCBuaWQsIG5ld0NvbnRleHQsIG5ld1NlbGVjdG9yO1xcblxcblxcdFxcdFxcdGlmICgoY29udGV4dCA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogcHJlZmVycmVkRG9jKSAhPT0gZG9jdW1lbnQpIHtcXG5cXHRcXHRcXHRcXHRzZXREb2N1bWVudChjb250ZXh0KTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Y29udGV4dCA9IGNvbnRleHQgfHwgZG9jdW1lbnQ7XFxuXFx0XFx0XFx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XFxuXFx0XFx0XFx0bm9kZVR5cGUgPSBjb250ZXh0Lm5vZGVUeXBlO1xcblxcblxcdFxcdFxcdGlmICh0eXBlb2Ygc2VsZWN0b3IgIT09IFxcXCJzdHJpbmdcXFwiIHx8ICFzZWxlY3RvciB8fCBub2RlVHlwZSAhPT0gMSAmJiBub2RlVHlwZSAhPT0gOSAmJiBub2RlVHlwZSAhPT0gMTEpIHtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gcmVzdWx0cztcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCFzZWVkICYmIGRvY3VtZW50SXNIVE1MKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gVHJ5IHRvIHNob3J0Y3V0IGZpbmQgb3BlcmF0aW9ucyB3aGVuIHBvc3NpYmxlIChlLmcuLCBub3QgdW5kZXIgRG9jdW1lbnRGcmFnbWVudClcXG5cXHRcXHRcXHRcXHRpZiAobm9kZVR5cGUgIT09IDExICYmIChtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyhzZWxlY3RvcikpKSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gU3BlZWQtdXA6IFNpenpsZShcXFwiI0lEXFxcIilcXG5cXHRcXHRcXHRcXHRcXHRpZiAobSA9IG1hdGNoWzFdKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKG5vZGVUeXBlID09PSA5KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQobSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gQ2hlY2sgcGFyZW50Tm9kZSB0byBjYXRjaCB3aGVuIEJsYWNrYmVycnkgNC42IHJldHVybnNcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBub2RlcyB0aGF0IGFyZSBubyBsb25nZXIgaW4gdGhlIGRvY3VtZW50IChqUXVlcnkgIzY5NjMpXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKGVsZW0gJiYgZWxlbS5wYXJlbnROb2RlKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gSGFuZGxlIHRoZSBjYXNlIHdoZXJlIElFLCBPcGVyYSwgYW5kIFdlYmtpdCByZXR1cm4gaXRlbXNcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBieSBuYW1lIGluc3RlYWQgb2YgSURcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoZWxlbS5pZCA9PT0gbSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHJlc3VsdHMucHVzaChlbGVtKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gcmVzdWx0cztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gcmVzdWx0cztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBDb250ZXh0IGlzIG5vdCBhIGRvY3VtZW50XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKGNvbnRleHQub3duZXJEb2N1bWVudCAmJiAoZWxlbSA9IGNvbnRleHQub3duZXJEb2N1bWVudC5nZXRFbGVtZW50QnlJZChtKSkgJiYgY29udGFpbnMoY29udGV4dCwgZWxlbSkgJiYgZWxlbS5pZCA9PT0gbSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHJlc3VsdHMucHVzaChlbGVtKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gcmVzdWx0cztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIFNwZWVkLXVwOiBTaXp6bGUoXFxcIlRBR1xcXCIpXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIGlmIChtYXRjaFsyXSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHB1c2guYXBwbHkocmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZShzZWxlY3RvcikpO1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiByZXN1bHRzO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIFNwZWVkLXVwOiBTaXp6bGUoXFxcIi5DTEFTU1xcXCIpXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIGlmICgobSA9IG1hdGNoWzNdKSAmJiBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRwdXNoLmFwcGx5KHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShtKSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHJlc3VsdHM7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBRU0EgcGF0aFxcblxcdFxcdFxcdFxcdGlmIChzdXBwb3J0LnFzYSAmJiAoIXJidWdneVFTQSB8fCAhcmJ1Z2d5UVNBLnRlc3Qoc2VsZWN0b3IpKSkge1xcblxcdFxcdFxcdFxcdFxcdG5pZCA9IG9sZCA9IGV4cGFuZG87XFxuXFx0XFx0XFx0XFx0XFx0bmV3Q29udGV4dCA9IGNvbnRleHQ7XFxuXFx0XFx0XFx0XFx0XFx0bmV3U2VsZWN0b3IgPSBub2RlVHlwZSAhPT0gMSAmJiBzZWxlY3RvcjtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBxU0Egd29ya3Mgc3RyYW5nZWx5IG9uIEVsZW1lbnQtcm9vdGVkIHF1ZXJpZXNcXG5cXHRcXHRcXHRcXHRcXHQvLyBXZSBjYW4gd29yayBhcm91bmQgdGhpcyBieSBzcGVjaWZ5aW5nIGFuIGV4dHJhIElEIG9uIHRoZSByb290XFxuXFx0XFx0XFx0XFx0XFx0Ly8gYW5kIHdvcmtpbmcgdXAgZnJvbSB0aGVyZSAoVGhhbmtzIHRvIEFuZHJldyBEdXBvbnQgZm9yIHRoZSB0ZWNobmlxdWUpXFxuXFx0XFx0XFx0XFx0XFx0Ly8gSUUgOCBkb2Vzbid0IHdvcmsgb24gb2JqZWN0IGVsZW1lbnRzXFxuXFx0XFx0XFx0XFx0XFx0aWYgKG5vZGVUeXBlID09PSAxICYmIGNvbnRleHQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gXFxcIm9iamVjdFxcXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRncm91cHMgPSB0b2tlbml6ZShzZWxlY3Rvcik7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKG9sZCA9IGNvbnRleHQuZ2V0QXR0cmlidXRlKFxcXCJpZFxcXCIpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bmlkID0gb2xkLnJlcGxhY2UocmVzY2FwZSwgXFxcIlxcXFxcXFxcJCZcXFwiKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGNvbnRleHQuc2V0QXR0cmlidXRlKFxcXCJpZFxcXCIsIG5pZCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdG5pZCA9IFxcXCJbaWQ9J1xcXCIgKyBuaWQgKyBcXFwiJ10gXFxcIjtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpID0gZ3JvdXBzLmxlbmd0aDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR3aGlsZSAoaS0tKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Z3JvdXBzW2ldID0gbmlkICsgdG9TZWxlY3Rvcihncm91cHNbaV0pO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRuZXdDb250ZXh0ID0gcnNpYmxpbmcudGVzdChzZWxlY3RvcikgJiYgdGVzdENvbnRleHQoY29udGV4dC5wYXJlbnROb2RlKSB8fCBjb250ZXh0O1xcblxcdFxcdFxcdFxcdFxcdFxcdG5ld1NlbGVjdG9yID0gZ3JvdXBzLmpvaW4oXFxcIixcXFwiKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKG5ld1NlbGVjdG9yKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dHJ5IHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRwdXNoLmFwcGx5KHJlc3VsdHMsIG5ld0NvbnRleHQucXVlcnlTZWxlY3RvckFsbChuZXdTZWxlY3RvcikpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiByZXN1bHRzO1xcblxcdFxcdFxcdFxcdFxcdFxcdH0gY2F0Y2ggKHFzYUVycm9yKSB7fSBmaW5hbGx5IHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIW9sZCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGNvbnRleHQucmVtb3ZlQXR0cmlidXRlKFxcXCJpZFxcXCIpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gQWxsIG90aGVyc1xcblxcdFxcdFxcdHJldHVybiBzZWxlY3Qoc2VsZWN0b3IucmVwbGFjZShydHJpbSwgXFxcIiQxXFxcIiksIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQpO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvKipcXG4gICAqIENyZWF0ZSBrZXktdmFsdWUgY2FjaGVzIG9mIGxpbWl0ZWQgc2l6ZVxcbiAgICogQHJldHVybnMge0Z1bmN0aW9uKHN0cmluZywgT2JqZWN0KX0gUmV0dXJucyB0aGUgT2JqZWN0IGRhdGEgYWZ0ZXIgc3RvcmluZyBpdCBvbiBpdHNlbGYgd2l0aFxcbiAgICpcXHRwcm9wZXJ0eSBuYW1lIHRoZSAoc3BhY2Utc3VmZml4ZWQpIHN0cmluZyBhbmQgKGlmIHRoZSBjYWNoZSBpcyBsYXJnZXIgdGhhbiBFeHByLmNhY2hlTGVuZ3RoKVxcbiAgICpcXHRkZWxldGluZyB0aGUgb2xkZXN0IGVudHJ5XFxuICAgKi9cXG5cXHRcXHRmdW5jdGlvbiBjcmVhdGVDYWNoZSgpIHtcXG5cXHRcXHRcXHR2YXIga2V5cyA9IFtdO1xcblxcblxcdFxcdFxcdGZ1bmN0aW9uIGNhY2hlKGtleSwgdmFsdWUpIHtcXG5cXHRcXHRcXHRcXHQvLyBVc2UgKGtleSArIFxcXCIgXFxcIikgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggbmF0aXZlIHByb3RvdHlwZSBwcm9wZXJ0aWVzIChzZWUgSXNzdWUgIzE1NylcXG5cXHRcXHRcXHRcXHRpZiAoa2V5cy5wdXNoKGtleSArIFxcXCIgXFxcIikgPiBFeHByLmNhY2hlTGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gT25seSBrZWVwIHRoZSBtb3N0IHJlY2VudCBlbnRyaWVzXFxuXFx0XFx0XFx0XFx0XFx0ZGVsZXRlIGNhY2hlW2tleXMuc2hpZnQoKV07XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHJldHVybiBjYWNoZVtrZXkgKyBcXFwiIFxcXCJdID0gdmFsdWU7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiBjYWNoZTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0LyoqXFxuICAgKiBNYXJrIGEgZnVuY3Rpb24gZm9yIHNwZWNpYWwgdXNlIGJ5IFNpenpsZVxcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIG1hcmtcXG4gICAqL1xcblxcdFxcdGZ1bmN0aW9uIG1hcmtGdW5jdGlvbihmbikge1xcblxcdFxcdFxcdGZuW2V4cGFuZG9dID0gdHJ1ZTtcXG5cXHRcXHRcXHRyZXR1cm4gZm47XFxuXFx0XFx0fVxcblxcblxcdFxcdC8qKlxcbiAgICogU3VwcG9ydCB0ZXN0aW5nIHVzaW5nIGFuIGVsZW1lbnRcXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFBhc3NlZCB0aGUgY3JlYXRlZCBkaXYgYW5kIGV4cGVjdHMgYSBib29sZWFuIHJlc3VsdFxcbiAgICovXFxuXFx0XFx0ZnVuY3Rpb24gYXNzZXJ0KGZuKSB7XFxuXFx0XFx0XFx0dmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXFxcImRpdlxcXCIpO1xcblxcblxcdFxcdFxcdHRyeSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuICEhZm4oZGl2KTtcXG5cXHRcXHRcXHR9IGNhdGNoIChlKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH0gZmluYWxseSB7XFxuXFx0XFx0XFx0XFx0Ly8gUmVtb3ZlIGZyb20gaXRzIHBhcmVudCBieSBkZWZhdWx0XFxuXFx0XFx0XFx0XFx0aWYgKGRpdi5wYXJlbnROb2RlKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZGl2LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZGl2KTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0Ly8gcmVsZWFzZSBtZW1vcnkgaW4gSUVcXG5cXHRcXHRcXHRcXHRkaXYgPSBudWxsO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0LyoqXFxuICAgKiBBZGRzIHRoZSBzYW1lIGhhbmRsZXIgZm9yIGFsbCBvZiB0aGUgc3BlY2lmaWVkIGF0dHJzXFxuICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0cnMgUGlwZS1zZXBhcmF0ZWQgbGlzdCBvZiBhdHRyaWJ1dGVzXFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIFRoZSBtZXRob2QgdGhhdCB3aWxsIGJlIGFwcGxpZWRcXG4gICAqL1xcblxcdFxcdGZ1bmN0aW9uIGFkZEhhbmRsZShhdHRycywgaGFuZGxlcikge1xcblxcdFxcdFxcdHZhciBhcnIgPSBhdHRycy5zcGxpdChcXFwifFxcXCIpLFxcblxcdFxcdFxcdCAgICBpID0gYXR0cnMubGVuZ3RoO1xcblxcblxcdFxcdFxcdHdoaWxlIChpLS0pIHtcXG5cXHRcXHRcXHRcXHRFeHByLmF0dHJIYW5kbGVbYXJyW2ldXSA9IGhhbmRsZXI7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHQvKipcXG4gICAqIENoZWNrcyBkb2N1bWVudCBvcmRlciBvZiB0d28gc2libGluZ3NcXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gYVxcbiAgICogQHBhcmFtIHtFbGVtZW50fSBiXFxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBSZXR1cm5zIGxlc3MgdGhhbiAwIGlmIGEgcHJlY2VkZXMgYiwgZ3JlYXRlciB0aGFuIDAgaWYgYSBmb2xsb3dzIGJcXG4gICAqL1xcblxcdFxcdGZ1bmN0aW9uIHNpYmxpbmdDaGVjayhhLCBiKSB7XFxuXFx0XFx0XFx0dmFyIGN1ciA9IGIgJiYgYSxcXG5cXHRcXHRcXHQgICAgZGlmZiA9IGN1ciAmJiBhLm5vZGVUeXBlID09PSAxICYmIGIubm9kZVR5cGUgPT09IDEgJiYgKH5iLnNvdXJjZUluZGV4IHx8IE1BWF9ORUdBVElWRSkgLSAofmEuc291cmNlSW5kZXggfHwgTUFYX05FR0FUSVZFKTtcXG5cXG5cXHRcXHRcXHQvLyBVc2UgSUUgc291cmNlSW5kZXggaWYgYXZhaWxhYmxlIG9uIGJvdGggbm9kZXNcXG5cXHRcXHRcXHRpZiAoZGlmZikge1xcblxcdFxcdFxcdFxcdHJldHVybiBkaWZmO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBDaGVjayBpZiBiIGZvbGxvd3MgYVxcblxcdFxcdFxcdGlmIChjdXIpIHtcXG5cXHRcXHRcXHRcXHR3aGlsZSAoY3VyID0gY3VyLm5leHRTaWJsaW5nKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGN1ciA9PT0gYikge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiAtMTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gYSA/IDEgOiAtMTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0LyoqXFxuICAgKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGlucHV0IHR5cGVzXFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxcbiAgICovXFxuXFx0XFx0ZnVuY3Rpb24gY3JlYXRlSW5wdXRQc2V1ZG8odHlwZSkge1xcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiAoZWxlbSkge1xcblxcdFxcdFxcdFxcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xcblxcdFxcdFxcdFxcdHJldHVybiBuYW1lID09PSBcXFwiaW5wdXRcXFwiICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcXG5cXHRcXHRcXHR9O1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvKipcXG4gICAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgYnV0dG9uc1xcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcXG4gICAqL1xcblxcdFxcdGZ1bmN0aW9uIGNyZWF0ZUJ1dHRvblBzZXVkbyh0eXBlKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIChlbGVtKSB7XFxuXFx0XFx0XFx0XFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIChuYW1lID09PSBcXFwiaW5wdXRcXFwiIHx8IG5hbWUgPT09IFxcXCJidXR0b25cXFwiKSAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XFxuXFx0XFx0XFx0fTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0LyoqXFxuICAgKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIHBvc2l0aW9uYWxzXFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAgICovXFxuXFx0XFx0ZnVuY3Rpb24gY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmbikge1xcblxcdFxcdFxcdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24gKGFyZ3VtZW50KSB7XFxuXFx0XFx0XFx0XFx0YXJndW1lbnQgPSArYXJndW1lbnQ7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiAoc2VlZCwgbWF0Y2hlcykge1xcblxcdFxcdFxcdFxcdFxcdHZhciBqLFxcblxcdFxcdFxcdFxcdFxcdCAgICBtYXRjaEluZGV4ZXMgPSBmbihbXSwgc2VlZC5sZW5ndGgsIGFyZ3VtZW50KSxcXG5cXHRcXHRcXHRcXHRcXHQgICAgaSA9IG1hdGNoSW5kZXhlcy5sZW5ndGg7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gTWF0Y2ggZWxlbWVudHMgZm91bmQgYXQgdGhlIHNwZWNpZmllZCBpbmRleGVzXFxuXFx0XFx0XFx0XFx0XFx0d2hpbGUgKGktLSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChzZWVkW2ogPSBtYXRjaEluZGV4ZXNbaV1dKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c2VlZFtqXSA9ICEobWF0Y2hlc1tqXSA9IHNlZWRbal0pO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8qKlxcbiAgICogQ2hlY2tzIGEgbm9kZSBmb3IgdmFsaWRpdHkgYXMgYSBTaXp6bGUgY29udGV4dFxcbiAgICogQHBhcmFtIHtFbGVtZW50fE9iamVjdD19IGNvbnRleHRcXG4gICAqIEByZXR1cm5zIHtFbGVtZW50fE9iamVjdHxCb29sZWFufSBUaGUgaW5wdXQgbm9kZSBpZiBhY2NlcHRhYmxlLCBvdGhlcndpc2UgYSBmYWxzeSB2YWx1ZVxcbiAgICovXFxuXFx0XFx0ZnVuY3Rpb24gdGVzdENvbnRleHQoY29udGV4dCkge1xcblxcdFxcdFxcdHJldHVybiBjb250ZXh0ICYmIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcXFwidW5kZWZpbmVkXFxcIiAmJiBjb250ZXh0O1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBFeHBvc2Ugc3VwcG9ydCB2YXJzIGZvciBjb252ZW5pZW5jZVxcblxcdFxcdHN1cHBvcnQgPSBTaXp6bGUuc3VwcG9ydCA9IHt9O1xcblxcblxcdFxcdC8qKlxcbiAgICogRGV0ZWN0cyBYTUwgbm9kZXNcXG4gICAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IGVsZW0gQW4gZWxlbWVudCBvciBhIGRvY3VtZW50XFxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZmYgZWxlbSBpcyBhIG5vbi1IVE1MIFhNTCBub2RlXFxuICAgKi9cXG5cXHRcXHRpc1hNTCA9IFNpenpsZS5pc1hNTCA9IGZ1bmN0aW9uIChlbGVtKSB7XFxuXFx0XFx0XFx0Ly8gZG9jdW1lbnRFbGVtZW50IGlzIHZlcmlmaWVkIGZvciBjYXNlcyB3aGVyZSBpdCBkb2Vzbid0IHlldCBleGlzdFxcblxcdFxcdFxcdC8vIChzdWNoIGFzIGxvYWRpbmcgaWZyYW1lcyBpbiBJRSAtICM0ODMzKVxcblxcdFxcdFxcdHZhciBkb2N1bWVudEVsZW1lbnQgPSBlbGVtICYmIChlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSkuZG9jdW1lbnRFbGVtZW50O1xcblxcdFxcdFxcdHJldHVybiBkb2N1bWVudEVsZW1lbnQgPyBkb2N1bWVudEVsZW1lbnQubm9kZU5hbWUgIT09IFxcXCJIVE1MXFxcIiA6IGZhbHNlO1xcblxcdFxcdH07XFxuXFxuXFx0XFx0LyoqXFxuICAgKiBTZXRzIGRvY3VtZW50LXJlbGF0ZWQgdmFyaWFibGVzIG9uY2UgYmFzZWQgb24gdGhlIGN1cnJlbnQgZG9jdW1lbnRcXG4gICAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IFtkb2NdIEFuIGVsZW1lbnQgb3IgZG9jdW1lbnQgb2JqZWN0IHRvIHVzZSB0byBzZXQgdGhlIGRvY3VtZW50XFxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjdXJyZW50IGRvY3VtZW50XFxuICAgKi9cXG5cXHRcXHRzZXREb2N1bWVudCA9IFNpenpsZS5zZXREb2N1bWVudCA9IGZ1bmN0aW9uIChub2RlKSB7XFxuXFx0XFx0XFx0dmFyIGhhc0NvbXBhcmUsXFxuXFx0XFx0XFx0ICAgIHBhcmVudCxcXG5cXHRcXHRcXHQgICAgZG9jID0gbm9kZSA/IG5vZGUub3duZXJEb2N1bWVudCB8fCBub2RlIDogcHJlZmVycmVkRG9jO1xcblxcblxcdFxcdFxcdC8vIElmIG5vIGRvY3VtZW50IGFuZCBkb2N1bWVudEVsZW1lbnQgaXMgYXZhaWxhYmxlLCByZXR1cm5cXG5cXHRcXHRcXHRpZiAoZG9jID09PSBkb2N1bWVudCB8fCBkb2Mubm9kZVR5cGUgIT09IDkgfHwgIWRvYy5kb2N1bWVudEVsZW1lbnQpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZG9jdW1lbnQ7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFNldCBvdXIgZG9jdW1lbnRcXG5cXHRcXHRcXHRkb2N1bWVudCA9IGRvYztcXG5cXHRcXHRcXHRkb2NFbGVtID0gZG9jLmRvY3VtZW50RWxlbWVudDtcXG5cXHRcXHRcXHRwYXJlbnQgPSBkb2MuZGVmYXVsdFZpZXc7XFxuXFxuXFx0XFx0XFx0Ly8gU3VwcG9ydDogSUU+OFxcblxcdFxcdFxcdC8vIElmIGlmcmFtZSBkb2N1bWVudCBpcyBhc3NpZ25lZCB0byBcXFwiZG9jdW1lbnRcXFwiIHZhcmlhYmxlIGFuZCBpZiBpZnJhbWUgaGFzIGJlZW4gcmVsb2FkZWQsXFxuXFx0XFx0XFx0Ly8gSUUgd2lsbCB0aHJvdyBcXFwicGVybWlzc2lvbiBkZW5pZWRcXFwiIGVycm9yIHdoZW4gYWNjZXNzaW5nIFxcXCJkb2N1bWVudFxcXCIgdmFyaWFibGUsIHNlZSBqUXVlcnkgIzEzOTM2XFxuXFx0XFx0XFx0Ly8gSUU2LTggZG8gbm90IHN1cHBvcnQgdGhlIGRlZmF1bHRWaWV3IHByb3BlcnR5IHNvIHBhcmVudCB3aWxsIGJlIHVuZGVmaW5lZFxcblxcdFxcdFxcdGlmIChwYXJlbnQgJiYgcGFyZW50ICE9PSBwYXJlbnQudG9wKSB7XFxuXFx0XFx0XFx0XFx0Ly8gSUUxMSBkb2VzIG5vdCBoYXZlIGF0dGFjaEV2ZW50LCBzbyBhbGwgbXVzdCBzdWZmZXJcXG5cXHRcXHRcXHRcXHRpZiAocGFyZW50LmFkZEV2ZW50TGlzdGVuZXIpIHtcXG5cXHRcXHRcXHRcXHRcXHRwYXJlbnQuYWRkRXZlbnRMaXN0ZW5lcihcXFwidW5sb2FkXFxcIiwgdW5sb2FkSGFuZGxlciwgZmFsc2UpO1xcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAocGFyZW50LmF0dGFjaEV2ZW50KSB7XFxuXFx0XFx0XFx0XFx0XFx0cGFyZW50LmF0dGFjaEV2ZW50KFxcXCJvbnVubG9hZFxcXCIsIHVubG9hZEhhbmRsZXIpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0LyogU3VwcG9ydCB0ZXN0c1xcbiAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cXG5cXHRcXHRcXHRkb2N1bWVudElzSFRNTCA9ICFpc1hNTChkb2MpO1xcblxcblxcdFxcdFxcdC8qIEF0dHJpYnV0ZXNcXG4gICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXFxuXFxuXFx0XFx0XFx0Ly8gU3VwcG9ydDogSUU8OFxcblxcdFxcdFxcdC8vIFZlcmlmeSB0aGF0IGdldEF0dHJpYnV0ZSByZWFsbHkgcmV0dXJucyBhdHRyaWJ1dGVzIGFuZCBub3QgcHJvcGVydGllc1xcblxcdFxcdFxcdC8vIChleGNlcHRpbmcgSUU4IGJvb2xlYW5zKVxcblxcdFxcdFxcdHN1cHBvcnQuYXR0cmlidXRlcyA9IGFzc2VydChmdW5jdGlvbiAoZGl2KSB7XFxuXFx0XFx0XFx0XFx0ZGl2LmNsYXNzTmFtZSA9IFxcXCJpXFxcIjtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gIWRpdi5nZXRBdHRyaWJ1dGUoXFxcImNsYXNzTmFtZVxcXCIpO1xcblxcdFxcdFxcdH0pO1xcblxcblxcdFxcdFxcdC8qIGdldEVsZW1lbnQocylCeSpcXG4gICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXFxuXFxuXFx0XFx0XFx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudHNCeVRhZ05hbWUoXFxcIipcXFwiKSByZXR1cm5zIG9ubHkgZWxlbWVudHNcXG5cXHRcXHRcXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID0gYXNzZXJ0KGZ1bmN0aW9uIChkaXYpIHtcXG5cXHRcXHRcXHRcXHRkaXYuYXBwZW5kQ2hpbGQoZG9jLmNyZWF0ZUNvbW1lbnQoXFxcIlxcXCIpKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gIWRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZShcXFwiKlxcXCIpLmxlbmd0aDtcXG5cXHRcXHRcXHR9KTtcXG5cXG5cXHRcXHRcXHQvLyBTdXBwb3J0OiBJRTw5XFxuXFx0XFx0XFx0c3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lID0gcm5hdGl2ZS50ZXN0KGRvYy5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKTtcXG5cXG5cXHRcXHRcXHQvLyBTdXBwb3J0OiBJRTwxMFxcblxcdFxcdFxcdC8vIENoZWNrIGlmIGdldEVsZW1lbnRCeUlkIHJldHVybnMgZWxlbWVudHMgYnkgbmFtZVxcblxcdFxcdFxcdC8vIFRoZSBicm9rZW4gZ2V0RWxlbWVudEJ5SWQgbWV0aG9kcyBkb24ndCBwaWNrIHVwIHByb2dyYW1hdGljYWxseS1zZXQgbmFtZXMsXFxuXFx0XFx0XFx0Ly8gc28gdXNlIGEgcm91bmRhYm91dCBnZXRFbGVtZW50c0J5TmFtZSB0ZXN0XFxuXFx0XFx0XFx0c3VwcG9ydC5nZXRCeUlkID0gYXNzZXJ0KGZ1bmN0aW9uIChkaXYpIHtcXG5cXHRcXHRcXHRcXHRkb2NFbGVtLmFwcGVuZENoaWxkKGRpdikuaWQgPSBleHBhbmRvO1xcblxcdFxcdFxcdFxcdHJldHVybiAhZG9jLmdldEVsZW1lbnRzQnlOYW1lIHx8ICFkb2MuZ2V0RWxlbWVudHNCeU5hbWUoZXhwYW5kbykubGVuZ3RoO1xcblxcdFxcdFxcdH0pO1xcblxcblxcdFxcdFxcdC8vIElEIGZpbmQgYW5kIGZpbHRlclxcblxcdFxcdFxcdGlmIChzdXBwb3J0LmdldEJ5SWQpIHtcXG5cXHRcXHRcXHRcXHRFeHByLmZpbmRbXFxcIklEXFxcIl0gPSBmdW5jdGlvbiAoaWQsIGNvbnRleHQpIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAodHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IFxcXCJ1bmRlZmluZWRcXFwiICYmIGRvY3VtZW50SXNIVE1MKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIG0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKGlkKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBDaGVjayBwYXJlbnROb2RlIHRvIGNhdGNoIHdoZW4gQmxhY2tiZXJyeSA0LjYgcmV0dXJuc1xcblxcdFxcdFxcdFxcdFxcdFxcdC8vIG5vZGVzIHRoYXQgYXJlIG5vIGxvbmdlciBpbiB0aGUgZG9jdW1lbnQgIzY5NjNcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gbSAmJiBtLnBhcmVudE5vZGUgPyBbbV0gOiBbXTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fTtcXG5cXHRcXHRcXHRcXHRFeHByLmZpbHRlcltcXFwiSURcXFwiXSA9IGZ1bmN0aW9uIChpZCkge1xcblxcdFxcdFxcdFxcdFxcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKTtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gKGVsZW0pIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoXFxcImlkXFxcIikgPT09IGF0dHJJZDtcXG5cXHRcXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdFxcdH07XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHQvLyBTdXBwb3J0OiBJRTYvN1xcblxcdFxcdFxcdFxcdC8vIGdldEVsZW1lbnRCeUlkIGlzIG5vdCByZWxpYWJsZSBhcyBhIGZpbmQgc2hvcnRjdXRcXG5cXHRcXHRcXHRcXHRkZWxldGUgRXhwci5maW5kW1xcXCJJRFxcXCJdO1xcblxcblxcdFxcdFxcdFxcdEV4cHIuZmlsdGVyW1xcXCJJRFxcXCJdID0gZnVuY3Rpb24gKGlkKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UocnVuZXNjYXBlLCBmdW5lc2NhcGUpO1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiAoZWxlbSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBub2RlID0gdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlTm9kZSAhPT0gXFxcInVuZGVmaW5lZFxcXCIgJiYgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFxcXCJpZFxcXCIpO1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBub2RlICYmIG5vZGUudmFsdWUgPT09IGF0dHJJZDtcXG5cXHRcXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdFxcdH07XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFRhZ1xcblxcdFxcdFxcdEV4cHIuZmluZFtcXFwiVEFHXFxcIl0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID8gZnVuY3Rpb24gKHRhZywgY29udGV4dCkge1xcblxcdFxcdFxcdFxcdGlmICh0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXFxcInVuZGVmaW5lZFxcXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSh0YWcpO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgZG9uJ3QgaGF2ZSBnRUJUTlxcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoc3VwcG9ydC5xc2EpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKHRhZyk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0gOiBmdW5jdGlvbiAodGFnLCBjb250ZXh0KSB7XFxuXFx0XFx0XFx0XFx0dmFyIGVsZW0sXFxuXFx0XFx0XFx0XFx0ICAgIHRtcCA9IFtdLFxcblxcdFxcdFxcdFxcdCAgICBpID0gMCxcXG5cXG5cXHRcXHRcXHRcXHQvLyBCeSBoYXBweSBjb2luY2lkZW5jZSwgYSAoYnJva2VuKSBnRUJUTiBhcHBlYXJzIG9uIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgdG9vXFxuXFx0XFx0XFx0XFx0cmVzdWx0cyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUodGFnKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBGaWx0ZXIgb3V0IHBvc3NpYmxlIGNvbW1lbnRzXFxuXFx0XFx0XFx0XFx0aWYgKHRhZyA9PT0gXFxcIipcXFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0d2hpbGUgKGVsZW0gPSByZXN1bHRzW2krK10pIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoZWxlbS5ub2RlVHlwZSA9PT0gMSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRtcC5wdXNoKGVsZW0pO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRtcDtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHJlc3VsdHM7XFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHRcXHQvLyBDbGFzc1xcblxcdFxcdFxcdEV4cHIuZmluZFtcXFwiQ0xBU1NcXFwiXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJiBmdW5jdGlvbiAoY2xhc3NOYW1lLCBjb250ZXh0KSB7XFxuXFx0XFx0XFx0XFx0aWYgKGRvY3VtZW50SXNIVE1MKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShjbGFzc05hbWUpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdFxcdC8qIFFTQS9tYXRjaGVzU2VsZWN0b3JcXG4gICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXFxuXFxuXFx0XFx0XFx0Ly8gUVNBIGFuZCBtYXRjaGVzU2VsZWN0b3Igc3VwcG9ydFxcblxcblxcdFxcdFxcdC8vIG1hdGNoZXNTZWxlY3Rvcig6YWN0aXZlKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoSUU5L09wZXJhIDExLjUpXFxuXFx0XFx0XFx0cmJ1Z2d5TWF0Y2hlcyA9IFtdO1xcblxcblxcdFxcdFxcdC8vIHFTYSg6Zm9jdXMpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChDaHJvbWUgMjEpXFxuXFx0XFx0XFx0Ly8gV2UgYWxsb3cgdGhpcyBiZWNhdXNlIG9mIGEgYnVnIGluIElFOC85IHRoYXQgdGhyb3dzIGFuIGVycm9yXFxuXFx0XFx0XFx0Ly8gd2hlbmV2ZXIgYGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRgIGlzIGFjY2Vzc2VkIG9uIGFuIGlmcmFtZVxcblxcdFxcdFxcdC8vIFNvLCB3ZSBhbGxvdyA6Zm9jdXMgdG8gcGFzcyB0aHJvdWdoIFFTQSBhbGwgdGhlIHRpbWUgdG8gYXZvaWQgdGhlIElFIGVycm9yXFxuXFx0XFx0XFx0Ly8gU2VlIGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEzMzc4XFxuXFx0XFx0XFx0cmJ1Z2d5UVNBID0gW107XFxuXFxuXFx0XFx0XFx0aWYgKHN1cHBvcnQucXNhID0gcm5hdGl2ZS50ZXN0KGRvYy5xdWVyeVNlbGVjdG9yQWxsKSkge1xcblxcdFxcdFxcdFxcdC8vIEJ1aWxkIFFTQSByZWdleFxcblxcdFxcdFxcdFxcdC8vIFJlZ2V4IHN0cmF0ZWd5IGFkb3B0ZWQgZnJvbSBEaWVnbyBQZXJpbmlcXG5cXHRcXHRcXHRcXHRhc3NlcnQoZnVuY3Rpb24gKGRpdikge1xcblxcdFxcdFxcdFxcdFxcdC8vIFNlbGVjdCBpcyBzZXQgdG8gZW1wdHkgc3RyaW5nIG9uIHB1cnBvc2VcXG5cXHRcXHRcXHRcXHRcXHQvLyBUaGlzIGlzIHRvIHRlc3QgSUUncyB0cmVhdG1lbnQgb2Ygbm90IGV4cGxpY2l0bHlcXG5cXHRcXHRcXHRcXHRcXHQvLyBzZXR0aW5nIGEgYm9vbGVhbiBjb250ZW50IGF0dHJpYnV0ZSxcXG5cXHRcXHRcXHRcXHRcXHQvLyBzaW5jZSBpdHMgcHJlc2VuY2Ugc2hvdWxkIGJlIGVub3VnaFxcblxcdFxcdFxcdFxcdFxcdC8vIGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEyMzU5XFxuXFx0XFx0XFx0XFx0XFx0ZG9jRWxlbS5hcHBlbmRDaGlsZChkaXYpLmlubmVySFRNTCA9IFxcXCI8YSBpZD0nXFxcIiArIGV4cGFuZG8gKyBcXFwiJz48L2E+XFxcIiArIFxcXCI8c2VsZWN0IGlkPSdcXFwiICsgZXhwYW5kbyArIFxcXCItXFxcXGZdJyBtc2FsbG93Y2FwdHVyZT0nJz5cXFwiICsgXFxcIjxvcHRpb24gc2VsZWN0ZWQ9Jyc+PC9vcHRpb24+PC9zZWxlY3Q+XFxcIjtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBTdXBwb3J0OiBJRTgsIE9wZXJhIDExLTEyLjE2XFxuXFx0XFx0XFx0XFx0XFx0Ly8gTm90aGluZyBzaG91bGQgYmUgc2VsZWN0ZWQgd2hlbiBlbXB0eSBzdHJpbmdzIGZvbGxvdyBePSBvciAkPSBvciAqPVxcblxcdFxcdFxcdFxcdFxcdC8vIFRoZSB0ZXN0IGF0dHJpYnV0ZSBtdXN0IGJlIHVua25vd24gaW4gT3BlcmEgYnV0IFxcXCJzYWZlXFxcIiBmb3IgV2luUlRcXG5cXHRcXHRcXHRcXHRcXHQvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvaGg0NjUzODguYXNweCNhdHRyaWJ1dGVfc2VjdGlvblxcblxcdFxcdFxcdFxcdFxcdGlmIChkaXYucXVlcnlTZWxlY3RvckFsbChcXFwiW21zYWxsb3djYXB0dXJlXj0nJ11cXFwiKS5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyYnVnZ3lRU0EucHVzaChcXFwiWypeJF09XFxcIiArIHdoaXRlc3BhY2UgKyBcXFwiKig/OicnfFxcXFxcXFwiXFxcXFxcXCIpXFxcIik7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IElFOFxcblxcdFxcdFxcdFxcdFxcdC8vIEJvb2xlYW4gYXR0cmlidXRlcyBhbmQgXFxcInZhbHVlXFxcIiBhcmUgbm90IHRyZWF0ZWQgY29ycmVjdGx5XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCFkaXYucXVlcnlTZWxlY3RvckFsbChcXFwiW3NlbGVjdGVkXVxcXCIpLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJidWdneVFTQS5wdXNoKFxcXCJcXFxcXFxcXFtcXFwiICsgd2hpdGVzcGFjZSArIFxcXCIqKD86dmFsdWV8XFxcIiArIGJvb2xlYW5zICsgXFxcIilcXFwiKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogQ2hyb21lPDI5LCBBbmRyb2lkPDQuMissIFNhZmFyaTw3LjArLCBpT1M8Ny4wKywgUGhhbnRvbUpTPDEuOS43K1xcblxcdFxcdFxcdFxcdFxcdGlmICghZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXFxcIltpZH49XFxcIiArIGV4cGFuZG8gKyBcXFwiLV1cXFwiKS5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyYnVnZ3lRU0EucHVzaChcXFwifj1cXFwiKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gV2Via2l0L09wZXJhIC0gOmNoZWNrZWQgc2hvdWxkIHJldHVybiBzZWxlY3RlZCBvcHRpb24gZWxlbWVudHNcXG5cXHRcXHRcXHRcXHRcXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxcblxcdFxcdFxcdFxcdFxcdC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCFkaXYucXVlcnlTZWxlY3RvckFsbChcXFwiOmNoZWNrZWRcXFwiKS5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyYnVnZ3lRU0EucHVzaChcXFwiOmNoZWNrZWRcXFwiKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogU2FmYXJpIDgrLCBpT1MgOCtcXG5cXHRcXHRcXHRcXHRcXHQvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM2ODUxXFxuXFx0XFx0XFx0XFx0XFx0Ly8gSW4tcGFnZSBgc2VsZWN0b3IjaWQgc2liaW5nLWNvbWJpbmF0b3Igc2VsZWN0b3JgIGZhaWxzXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCFkaXYucXVlcnlTZWxlY3RvckFsbChcXFwiYSNcXFwiICsgZXhwYW5kbyArIFxcXCIrKlxcXCIpLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJidWdneVFTQS5wdXNoKFxcXCIuIy4rWyt+XVxcXCIpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9KTtcXG5cXG5cXHRcXHRcXHRcXHRhc3NlcnQoZnVuY3Rpb24gKGRpdikge1xcblxcdFxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IFdpbmRvd3MgOCBOYXRpdmUgQXBwc1xcblxcdFxcdFxcdFxcdFxcdC8vIFRoZSB0eXBlIGFuZCBuYW1lIGF0dHJpYnV0ZXMgYXJlIHJlc3RyaWN0ZWQgZHVyaW5nIC5pbm5lckhUTUwgYXNzaWdubWVudFxcblxcdFxcdFxcdFxcdFxcdHZhciBpbnB1dCA9IGRvYy5jcmVhdGVFbGVtZW50KFxcXCJpbnB1dFxcXCIpO1xcblxcdFxcdFxcdFxcdFxcdGlucHV0LnNldEF0dHJpYnV0ZShcXFwidHlwZVxcXCIsIFxcXCJoaWRkZW5cXFwiKTtcXG5cXHRcXHRcXHRcXHRcXHRkaXYuYXBwZW5kQ2hpbGQoaW5wdXQpLnNldEF0dHJpYnV0ZShcXFwibmFtZVxcXCIsIFxcXCJEXFxcIik7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogSUU4XFxuXFx0XFx0XFx0XFx0XFx0Ly8gRW5mb3JjZSBjYXNlLXNlbnNpdGl2aXR5IG9mIG5hbWUgYXR0cmlidXRlXFxuXFx0XFx0XFx0XFx0XFx0aWYgKGRpdi5xdWVyeVNlbGVjdG9yQWxsKFxcXCJbbmFtZT1kXVxcXCIpLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJidWdneVFTQS5wdXNoKFxcXCJuYW1lXFxcIiArIHdoaXRlc3BhY2UgKyBcXFwiKlsqXiR8IX5dPz1cXFwiKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gRkYgMy41IC0gOmVuYWJsZWQvOmRpc2FibGVkIGFuZCBoaWRkZW4gZWxlbWVudHMgKGhpZGRlbiBlbGVtZW50cyBhcmUgc3RpbGwgZW5hYmxlZClcXG5cXHRcXHRcXHRcXHRcXHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xcblxcdFxcdFxcdFxcdFxcdGlmICghZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXFxcIjplbmFibGVkXFxcIikubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmJ1Z2d5UVNBLnB1c2goXFxcIjplbmFibGVkXFxcIiwgXFxcIjpkaXNhYmxlZFxcXCIpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBPcGVyYSAxMC0xMSBkb2VzIG5vdCB0aHJvdyBvbiBwb3N0LWNvbW1hIGludmFsaWQgcHNldWRvc1xcblxcdFxcdFxcdFxcdFxcdGRpdi5xdWVyeVNlbGVjdG9yQWxsKFxcXCIqLDp4XFxcIik7XFxuXFx0XFx0XFx0XFx0XFx0cmJ1Z2d5UVNBLnB1c2goXFxcIiwuKjpcXFwiKTtcXG5cXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yID0gcm5hdGl2ZS50ZXN0KG1hdGNoZXMgPSBkb2NFbGVtLm1hdGNoZXMgfHwgZG9jRWxlbS53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHwgZG9jRWxlbS5tb3pNYXRjaGVzU2VsZWN0b3IgfHwgZG9jRWxlbS5vTWF0Y2hlc1NlbGVjdG9yIHx8IGRvY0VsZW0ubXNNYXRjaGVzU2VsZWN0b3IpKSB7XFxuXFxuXFx0XFx0XFx0XFx0YXNzZXJ0KGZ1bmN0aW9uIChkaXYpIHtcXG5cXHRcXHRcXHRcXHRcXHQvLyBDaGVjayB0byBzZWUgaWYgaXQncyBwb3NzaWJsZSB0byBkbyBtYXRjaGVzU2VsZWN0b3JcXG5cXHRcXHRcXHRcXHRcXHQvLyBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlIChJRSA5KVxcblxcdFxcdFxcdFxcdFxcdHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggPSBtYXRjaGVzLmNhbGwoZGl2LCBcXFwiZGl2XFxcIik7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gVGhpcyBzaG91bGQgZmFpbCB3aXRoIGFuIGV4Y2VwdGlvblxcblxcdFxcdFxcdFxcdFxcdC8vIEdlY2tvIGRvZXMgbm90IGVycm9yLCByZXR1cm5zIGZhbHNlIGluc3RlYWRcXG5cXHRcXHRcXHRcXHRcXHRtYXRjaGVzLmNhbGwoZGl2LCBcXFwiW3MhPScnXTp4XFxcIik7XFxuXFx0XFx0XFx0XFx0XFx0cmJ1Z2d5TWF0Y2hlcy5wdXNoKFxcXCIhPVxcXCIsIHBzZXVkb3MpO1xcblxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyYnVnZ3lRU0EgPSByYnVnZ3lRU0EubGVuZ3RoICYmIG5ldyBSZWdFeHAocmJ1Z2d5UVNBLmpvaW4oXFxcInxcXFwiKSk7XFxuXFx0XFx0XFx0cmJ1Z2d5TWF0Y2hlcyA9IHJidWdneU1hdGNoZXMubGVuZ3RoICYmIG5ldyBSZWdFeHAocmJ1Z2d5TWF0Y2hlcy5qb2luKFxcXCJ8XFxcIikpO1xcblxcblxcdFxcdFxcdC8qIENvbnRhaW5zXFxuICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xcblxcdFxcdFxcdGhhc0NvbXBhcmUgPSBybmF0aXZlLnRlc3QoZG9jRWxlbS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbik7XFxuXFxuXFx0XFx0XFx0Ly8gRWxlbWVudCBjb250YWlucyBhbm90aGVyXFxuXFx0XFx0XFx0Ly8gUHVycG9zZWZ1bGx5IGRvZXMgbm90IGltcGxlbWVudCBpbmNsdXNpdmUgZGVzY2VuZGVudFxcblxcdFxcdFxcdC8vIEFzIGluLCBhbiBlbGVtZW50IGRvZXMgbm90IGNvbnRhaW4gaXRzZWxmXFxuXFx0XFx0XFx0Y29udGFpbnMgPSBoYXNDb21wYXJlIHx8IHJuYXRpdmUudGVzdChkb2NFbGVtLmNvbnRhaW5zKSA/IGZ1bmN0aW9uIChhLCBiKSB7XFxuXFx0XFx0XFx0XFx0dmFyIGFkb3duID0gYS5ub2RlVHlwZSA9PT0gOSA/IGEuZG9jdW1lbnRFbGVtZW50IDogYSxcXG5cXHRcXHRcXHRcXHQgICAgYnVwID0gYiAmJiBiLnBhcmVudE5vZGU7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGEgPT09IGJ1cCB8fCAhIShidXAgJiYgYnVwLm5vZGVUeXBlID09PSAxICYmIChhZG93bi5jb250YWlucyA/IGFkb3duLmNvbnRhaW5zKGJ1cCkgOiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICYmIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oYnVwKSAmIDE2KSk7XFxuXFx0XFx0XFx0fSA6IGZ1bmN0aW9uIChhLCBiKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGIpIHtcXG5cXHRcXHRcXHRcXHRcXHR3aGlsZSAoYiA9IGIucGFyZW50Tm9kZSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChiID09PSBhKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0XFx0LyogU29ydGluZ1xcbiAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cXG5cXG5cXHRcXHRcXHQvLyBEb2N1bWVudCBvcmRlciBzb3J0aW5nXFxuXFx0XFx0XFx0c29ydE9yZGVyID0gaGFzQ29tcGFyZSA/IGZ1bmN0aW9uIChhLCBiKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gRmxhZyBmb3IgZHVwbGljYXRlIHJlbW92YWxcXG5cXHRcXHRcXHRcXHRpZiAoYSA9PT0gYikge1xcblxcdFxcdFxcdFxcdFxcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIDA7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIFNvcnQgb24gbWV0aG9kIGV4aXN0ZW5jZSBpZiBvbmx5IG9uZSBpbnB1dCBoYXMgY29tcGFyZURvY3VtZW50UG9zaXRpb25cXG5cXHRcXHRcXHRcXHR2YXIgY29tcGFyZSA9ICFhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIC0gIWIuY29tcGFyZURvY3VtZW50UG9zaXRpb247XFxuXFx0XFx0XFx0XFx0aWYgKGNvbXBhcmUpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gY29tcGFyZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQ2FsY3VsYXRlIHBvc2l0aW9uIGlmIGJvdGggaW5wdXRzIGJlbG9uZyB0byB0aGUgc2FtZSBkb2N1bWVudFxcblxcdFxcdFxcdFxcdGNvbXBhcmUgPSAoYS5vd25lckRvY3VtZW50IHx8IGEpID09PSAoYi5vd25lckRvY3VtZW50IHx8IGIpID8gYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihiKSA6XFxuXFxuXFx0XFx0XFx0XFx0Ly8gT3RoZXJ3aXNlIHdlIGtub3cgdGhleSBhcmUgZGlzY29ubmVjdGVkXFxuXFx0XFx0XFx0XFx0MTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBEaXNjb25uZWN0ZWQgbm9kZXNcXG5cXHRcXHRcXHRcXHRpZiAoY29tcGFyZSAmIDEgfHwgIXN1cHBvcnQuc29ydERldGFjaGVkICYmIGIuY29tcGFyZURvY3VtZW50UG9zaXRpb24oYSkgPT09IGNvbXBhcmUpIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBDaG9vc2UgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBpcyByZWxhdGVkIHRvIG91ciBwcmVmZXJyZWQgZG9jdW1lbnRcXG5cXHRcXHRcXHRcXHRcXHRpZiAoYSA9PT0gZG9jIHx8IGEub3duZXJEb2N1bWVudCA9PT0gcHJlZmVycmVkRG9jICYmIGNvbnRhaW5zKHByZWZlcnJlZERvYywgYSkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gLTE7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmIChiID09PSBkb2MgfHwgYi5vd25lckRvY3VtZW50ID09PSBwcmVmZXJyZWREb2MgJiYgY29udGFpbnMocHJlZmVycmVkRG9jLCBiKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiAxO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBNYWludGFpbiBvcmlnaW5hbCBvcmRlclxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBzb3J0SW5wdXQgPyBpbmRleE9mKHNvcnRJbnB1dCwgYSkgLSBpbmRleE9mKHNvcnRJbnB1dCwgYikgOiAwO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gY29tcGFyZSAmIDQgPyAtMSA6IDE7XFxuXFx0XFx0XFx0fSA6IGZ1bmN0aW9uIChhLCBiKSB7XFxuXFx0XFx0XFx0XFx0Ly8gRXhpdCBlYXJseSBpZiB0aGUgbm9kZXMgYXJlIGlkZW50aWNhbFxcblxcdFxcdFxcdFxcdGlmIChhID09PSBiKSB7XFxuXFx0XFx0XFx0XFx0XFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gMDtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGN1cixcXG5cXHRcXHRcXHRcXHQgICAgaSA9IDAsXFxuXFx0XFx0XFx0XFx0ICAgIGF1cCA9IGEucGFyZW50Tm9kZSxcXG5cXHRcXHRcXHRcXHQgICAgYnVwID0gYi5wYXJlbnROb2RlLFxcblxcdFxcdFxcdFxcdCAgICBhcCA9IFthXSxcXG5cXHRcXHRcXHRcXHQgICAgYnAgPSBbYl07XFxuXFxuXFx0XFx0XFx0XFx0Ly8gUGFyZW50bGVzcyBub2RlcyBhcmUgZWl0aGVyIGRvY3VtZW50cyBvciBkaXNjb25uZWN0ZWRcXG5cXHRcXHRcXHRcXHRpZiAoIWF1cCB8fCAhYnVwKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGEgPT09IGRvYyA/IC0xIDogYiA9PT0gZG9jID8gMSA6IGF1cCA/IC0xIDogYnVwID8gMSA6IHNvcnRJbnB1dCA/IGluZGV4T2Yoc29ydElucHV0LCBhKSAtIGluZGV4T2Yoc29ydElucHV0LCBiKSA6IDA7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gSWYgdGhlIG5vZGVzIGFyZSBzaWJsaW5ncywgd2UgY2FuIGRvIGEgcXVpY2sgY2hlY2tcXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKGF1cCA9PT0gYnVwKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHNpYmxpbmdDaGVjayhhLCBiKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gT3RoZXJ3aXNlIHdlIG5lZWQgZnVsbCBsaXN0cyBvZiB0aGVpciBhbmNlc3RvcnMgZm9yIGNvbXBhcmlzb25cXG5cXHRcXHRcXHRcXHRjdXIgPSBhO1xcblxcdFxcdFxcdFxcdHdoaWxlIChjdXIgPSBjdXIucGFyZW50Tm9kZSkge1xcblxcdFxcdFxcdFxcdFxcdGFwLnVuc2hpZnQoY3VyKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0Y3VyID0gYjtcXG5cXHRcXHRcXHRcXHR3aGlsZSAoY3VyID0gY3VyLnBhcmVudE5vZGUpIHtcXG5cXHRcXHRcXHRcXHRcXHRicC51bnNoaWZ0KGN1cik7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIFdhbGsgZG93biB0aGUgdHJlZSBsb29raW5nIGZvciBhIGRpc2NyZXBhbmN5XFxuXFx0XFx0XFx0XFx0d2hpbGUgKGFwW2ldID09PSBicFtpXSkge1xcblxcdFxcdFxcdFxcdFxcdGkrKztcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIGkgP1xcblxcdFxcdFxcdFxcdC8vIERvIGEgc2libGluZyBjaGVjayBpZiB0aGUgbm9kZXMgaGF2ZSBhIGNvbW1vbiBhbmNlc3RvclxcblxcdFxcdFxcdFxcdHNpYmxpbmdDaGVjayhhcFtpXSwgYnBbaV0pIDpcXG5cXG5cXHRcXHRcXHRcXHQvLyBPdGhlcndpc2Ugbm9kZXMgaW4gb3VyIGRvY3VtZW50IHNvcnQgZmlyc3RcXG5cXHRcXHRcXHRcXHRhcFtpXSA9PT0gcHJlZmVycmVkRG9jID8gLTEgOiBicFtpXSA9PT0gcHJlZmVycmVkRG9jID8gMSA6IDA7XFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZG9jO1xcblxcdFxcdH07XFxuXFxuXFx0XFx0U2l6emxlLm1hdGNoZXMgPSBmdW5jdGlvbiAoZXhwciwgZWxlbWVudHMpIHtcXG5cXHRcXHRcXHRyZXR1cm4gU2l6emxlKGV4cHIsIG51bGwsIG51bGwsIGVsZW1lbnRzKTtcXG5cXHRcXHR9O1xcblxcblxcdFxcdFNpenpsZS5tYXRjaGVzU2VsZWN0b3IgPSBmdW5jdGlvbiAoZWxlbSwgZXhwcikge1xcblxcdFxcdFxcdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxcblxcdFxcdFxcdGlmICgoZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0pICE9PSBkb2N1bWVudCkge1xcblxcdFxcdFxcdFxcdHNldERvY3VtZW50KGVsZW0pO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBNYWtlIHN1cmUgdGhhdCBhdHRyaWJ1dGUgc2VsZWN0b3JzIGFyZSBxdW90ZWRcXG5cXHRcXHRcXHRleHByID0gZXhwci5yZXBsYWNlKHJhdHRyaWJ1dGVRdW90ZXMsIFxcXCI9JyQxJ11cXFwiKTtcXG5cXG5cXHRcXHRcXHRpZiAoc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgJiYgZG9jdW1lbnRJc0hUTUwgJiYgKCFyYnVnZ3lNYXRjaGVzIHx8ICFyYnVnZ3lNYXRjaGVzLnRlc3QoZXhwcikpICYmICghcmJ1Z2d5UVNBIHx8ICFyYnVnZ3lRU0EudGVzdChleHByKSkpIHtcXG5cXG5cXHRcXHRcXHRcXHR0cnkge1xcblxcdFxcdFxcdFxcdFxcdHZhciByZXQgPSBtYXRjaGVzLmNhbGwoZWxlbSwgZXhwcik7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gSUUgOSdzIG1hdGNoZXNTZWxlY3RvciByZXR1cm5zIGZhbHNlIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xcblxcdFxcdFxcdFxcdFxcdGlmIChyZXQgfHwgc3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCB8fFxcblxcdFxcdFxcdFxcdFxcdC8vIEFzIHdlbGwsIGRpc2Nvbm5lY3RlZCBub2RlcyBhcmUgc2FpZCB0byBiZSBpbiBhIGRvY3VtZW50XFxuXFx0XFx0XFx0XFx0XFx0Ly8gZnJhZ21lbnQgaW4gSUUgOVxcblxcdFxcdFxcdFxcdFxcdGVsZW0uZG9jdW1lbnQgJiYgZWxlbS5kb2N1bWVudC5ub2RlVHlwZSAhPT0gMTEpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gcmV0O1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9IGNhdGNoIChlKSB7fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gU2l6emxlKGV4cHIsIGRvY3VtZW50LCBudWxsLCBbZWxlbV0pLmxlbmd0aCA+IDA7XFxuXFx0XFx0fTtcXG5cXG5cXHRcXHRTaXp6bGUuY29udGFpbnMgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlbSkge1xcblxcdFxcdFxcdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxcblxcdFxcdFxcdGlmICgoY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQpICE9PSBkb2N1bWVudCkge1xcblxcdFxcdFxcdFxcdHNldERvY3VtZW50KGNvbnRleHQpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gY29udGFpbnMoY29udGV4dCwgZWxlbSk7XFxuXFx0XFx0fTtcXG5cXG5cXHRcXHRTaXp6bGUuYXR0ciA9IGZ1bmN0aW9uIChlbGVtLCBuYW1lKSB7XFxuXFx0XFx0XFx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXFxuXFx0XFx0XFx0aWYgKChlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSkgIT09IGRvY3VtZW50KSB7XFxuXFx0XFx0XFx0XFx0c2V0RG9jdW1lbnQoZWxlbSk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHZhciBmbiA9IEV4cHIuYXR0ckhhbmRsZVtuYW1lLnRvTG93ZXJDYXNlKCldLFxcblxcblxcdFxcdFxcdC8vIERvbid0IGdldCBmb29sZWQgYnkgT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzIChqUXVlcnkgIzEzODA3KVxcblxcdFxcdFxcdHZhbCA9IGZuICYmIGhhc093bi5jYWxsKEV4cHIuYXR0ckhhbmRsZSwgbmFtZS50b0xvd2VyQ2FzZSgpKSA/IGZuKGVsZW0sIG5hbWUsICFkb2N1bWVudElzSFRNTCkgOiB1bmRlZmluZWQ7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHZhbCAhPT0gdW5kZWZpbmVkID8gdmFsIDogc3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFkb2N1bWVudElzSFRNTCA/IGVsZW0uZ2V0QXR0cmlidXRlKG5hbWUpIDogKHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShuYW1lKSkgJiYgdmFsLnNwZWNpZmllZCA/IHZhbC52YWx1ZSA6IG51bGw7XFxuXFx0XFx0fTtcXG5cXG5cXHRcXHRTaXp6bGUuZXJyb3IgPSBmdW5jdGlvbiAobXNnKSB7XFxuXFx0XFx0XFx0dGhyb3cgbmV3IEVycm9yKFxcXCJTeW50YXggZXJyb3IsIHVucmVjb2duaXplZCBleHByZXNzaW9uOiBcXFwiICsgbXNnKTtcXG5cXHRcXHR9O1xcblxcblxcdFxcdC8qKlxcbiAgICogRG9jdW1lbnQgc29ydGluZyBhbmQgcmVtb3ZpbmcgZHVwbGljYXRlc1xcbiAgICogQHBhcmFtIHtBcnJheUxpa2V9IHJlc3VsdHNcXG4gICAqL1xcblxcdFxcdFNpenpsZS51bmlxdWVTb3J0ID0gZnVuY3Rpb24gKHJlc3VsdHMpIHtcXG5cXHRcXHRcXHR2YXIgZWxlbSxcXG5cXHRcXHRcXHQgICAgZHVwbGljYXRlcyA9IFtdLFxcblxcdFxcdFxcdCAgICBqID0gMCxcXG5cXHRcXHRcXHQgICAgaSA9IDA7XFxuXFxuXFx0XFx0XFx0Ly8gVW5sZXNzIHdlICprbm93KiB3ZSBjYW4gZGV0ZWN0IGR1cGxpY2F0ZXMsIGFzc3VtZSB0aGVpciBwcmVzZW5jZVxcblxcdFxcdFxcdGhhc0R1cGxpY2F0ZSA9ICFzdXBwb3J0LmRldGVjdER1cGxpY2F0ZXM7XFxuXFx0XFx0XFx0c29ydElucHV0ID0gIXN1cHBvcnQuc29ydFN0YWJsZSAmJiByZXN1bHRzLnNsaWNlKDApO1xcblxcdFxcdFxcdHJlc3VsdHMuc29ydChzb3J0T3JkZXIpO1xcblxcblxcdFxcdFxcdGlmIChoYXNEdXBsaWNhdGUpIHtcXG5cXHRcXHRcXHRcXHR3aGlsZSAoZWxlbSA9IHJlc3VsdHNbaSsrXSkge1xcblxcdFxcdFxcdFxcdFxcdGlmIChlbGVtID09PSByZXN1bHRzW2ldKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aiA9IGR1cGxpY2F0ZXMucHVzaChpKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHdoaWxlIChqLS0pIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXN1bHRzLnNwbGljZShkdXBsaWNhdGVzW2pdLCAxKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIENsZWFyIGlucHV0IGFmdGVyIHNvcnRpbmcgdG8gcmVsZWFzZSBvYmplY3RzXFxuXFx0XFx0XFx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvc2l6emxlL3B1bGwvMjI1XFxuXFx0XFx0XFx0c29ydElucHV0ID0gbnVsbDtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gcmVzdWx0cztcXG5cXHRcXHR9O1xcblxcblxcdFxcdC8qKlxcbiAgICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgcmV0cmlldmluZyB0aGUgdGV4dCB2YWx1ZSBvZiBhbiBhcnJheSBvZiBET00gbm9kZXNcXG4gICAqIEBwYXJhbSB7QXJyYXl8RWxlbWVudH0gZWxlbVxcbiAgICovXFxuXFx0XFx0Z2V0VGV4dCA9IFNpenpsZS5nZXRUZXh0ID0gZnVuY3Rpb24gKGVsZW0pIHtcXG5cXHRcXHRcXHR2YXIgbm9kZSxcXG5cXHRcXHRcXHQgICAgcmV0ID0gXFxcIlxcXCIsXFxuXFx0XFx0XFx0ICAgIGkgPSAwLFxcblxcdFxcdFxcdCAgICBub2RlVHlwZSA9IGVsZW0ubm9kZVR5cGU7XFxuXFxuXFx0XFx0XFx0aWYgKCFub2RlVHlwZSkge1xcblxcdFxcdFxcdFxcdC8vIElmIG5vIG5vZGVUeXBlLCB0aGlzIGlzIGV4cGVjdGVkIHRvIGJlIGFuIGFycmF5XFxuXFx0XFx0XFx0XFx0d2hpbGUgKG5vZGUgPSBlbGVtW2krK10pIHtcXG5cXHRcXHRcXHRcXHRcXHQvLyBEbyBub3QgdHJhdmVyc2UgY29tbWVudCBub2Rlc1xcblxcdFxcdFxcdFxcdFxcdHJldCArPSBnZXRUZXh0KG5vZGUpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9IGVsc2UgaWYgKG5vZGVUeXBlID09PSAxIHx8IG5vZGVUeXBlID09PSA5IHx8IG5vZGVUeXBlID09PSAxMSkge1xcblxcdFxcdFxcdFxcdC8vIFVzZSB0ZXh0Q29udGVudCBmb3IgZWxlbWVudHNcXG5cXHRcXHRcXHRcXHQvLyBpbm5lclRleHQgdXNhZ2UgcmVtb3ZlZCBmb3IgY29uc2lzdGVuY3kgb2YgbmV3IGxpbmVzIChqUXVlcnkgIzExMTUzKVxcblxcdFxcdFxcdFxcdGlmICh0eXBlb2YgZWxlbS50ZXh0Q29udGVudCA9PT0gXFxcInN0cmluZ1xcXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gZWxlbS50ZXh0Q29udGVudDtcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdC8vIFRyYXZlcnNlIGl0cyBjaGlsZHJlblxcblxcdFxcdFxcdFxcdFxcdGZvciAoZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXQgKz0gZ2V0VGV4dChlbGVtKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0gZWxzZSBpZiAobm9kZVR5cGUgPT09IDMgfHwgbm9kZVR5cGUgPT09IDQpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZWxlbS5ub2RlVmFsdWU7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdC8vIERvIG5vdCBpbmNsdWRlIGNvbW1lbnQgb3IgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbiBub2Rlc1xcblxcblxcdFxcdFxcdHJldHVybiByZXQ7XFxuXFx0XFx0fTtcXG5cXG5cXHRcXHRFeHByID0gU2l6emxlLnNlbGVjdG9ycyA9IHtcXG5cXG5cXHRcXHRcXHQvLyBDYW4gYmUgYWRqdXN0ZWQgYnkgdGhlIHVzZXJcXG5cXHRcXHRcXHRjYWNoZUxlbmd0aDogNTAsXFxuXFxuXFx0XFx0XFx0Y3JlYXRlUHNldWRvOiBtYXJrRnVuY3Rpb24sXFxuXFxuXFx0XFx0XFx0bWF0Y2g6IG1hdGNoRXhwcixcXG5cXG5cXHRcXHRcXHRhdHRySGFuZGxlOiB7fSxcXG5cXG5cXHRcXHRcXHRmaW5kOiB7fSxcXG5cXG5cXHRcXHRcXHRyZWxhdGl2ZToge1xcblxcdFxcdFxcdFxcdFxcXCI+XFxcIjogeyBkaXI6IFxcXCJwYXJlbnROb2RlXFxcIiwgZmlyc3Q6IHRydWUgfSxcXG5cXHRcXHRcXHRcXHRcXFwiIFxcXCI6IHsgZGlyOiBcXFwicGFyZW50Tm9kZVxcXCIgfSxcXG5cXHRcXHRcXHRcXHRcXFwiK1xcXCI6IHsgZGlyOiBcXFwicHJldmlvdXNTaWJsaW5nXFxcIiwgZmlyc3Q6IHRydWUgfSxcXG5cXHRcXHRcXHRcXHRcXFwiflxcXCI6IHsgZGlyOiBcXFwicHJldmlvdXNTaWJsaW5nXFxcIiB9XFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRwcmVGaWx0ZXI6IHtcXG5cXHRcXHRcXHRcXHRcXFwiQVRUUlxcXCI6IGZ1bmN0aW9uIEFUVFIobWF0Y2gpIHtcXG5cXHRcXHRcXHRcXHRcXHRtYXRjaFsxXSA9IG1hdGNoWzFdLnJlcGxhY2UocnVuZXNjYXBlLCBmdW5lc2NhcGUpO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIE1vdmUgdGhlIGdpdmVuIHZhbHVlIHRvIG1hdGNoWzNdIHdoZXRoZXIgcXVvdGVkIG9yIHVucXVvdGVkXFxuXFx0XFx0XFx0XFx0XFx0bWF0Y2hbM10gPSAobWF0Y2hbM10gfHwgbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXFxcIlxcXCIpLnJlcGxhY2UocnVuZXNjYXBlLCBmdW5lc2NhcGUpO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmIChtYXRjaFsyXSA9PT0gXFxcIn49XFxcIikge1xcblxcdFxcdFxcdFxcdFxcdFxcdG1hdGNoWzNdID0gXFxcIiBcXFwiICsgbWF0Y2hbM10gKyBcXFwiIFxcXCI7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBtYXRjaC5zbGljZSgwLCA0KTtcXG5cXHRcXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdFxcdFxcXCJDSElMRFxcXCI6IGZ1bmN0aW9uIENISUxEKG1hdGNoKSB7XFxuXFx0XFx0XFx0XFx0XFx0LyogbWF0Y2hlcyBmcm9tIG1hdGNoRXhwcltcXFwiQ0hJTERcXFwiXVxcbiAgICAgXFx0MSB0eXBlIChvbmx5fG50aHwuLi4pXFxuICAgICBcXHQyIHdoYXQgKGNoaWxkfG9mLXR5cGUpXFxuICAgICBcXHQzIGFyZ3VtZW50IChldmVufG9kZHxcXFxcZCp8XFxcXGQqbihbKy1dXFxcXGQrKT98Li4uKVxcbiAgICAgXFx0NCB4bi1jb21wb25lbnQgb2YgeG4reSBhcmd1bWVudCAoWystXT9cXFxcZCpufClcXG4gICAgIFxcdDUgc2lnbiBvZiB4bi1jb21wb25lbnRcXG4gICAgIFxcdDYgeCBvZiB4bi1jb21wb25lbnRcXG4gICAgIFxcdDcgc2lnbiBvZiB5LWNvbXBvbmVudFxcbiAgICAgXFx0OCB5IG9mIHktY29tcG9uZW50XFxuICAgICAqL1xcblxcdFxcdFxcdFxcdFxcdG1hdGNoWzFdID0gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAobWF0Y2hbMV0uc2xpY2UoMCwgMykgPT09IFxcXCJudGhcXFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gbnRoLSogcmVxdWlyZXMgYXJndW1lbnRcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIW1hdGNoWzNdKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0U2l6emxlLmVycm9yKG1hdGNoWzBdKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gbnVtZXJpYyB4IGFuZCB5IHBhcmFtZXRlcnMgZm9yIEV4cHIuZmlsdGVyLkNISUxEXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gcmVtZW1iZXIgdGhhdCBmYWxzZS90cnVlIGNhc3QgcmVzcGVjdGl2ZWx5IHRvIDAvMVxcblxcdFxcdFxcdFxcdFxcdFxcdG1hdGNoWzRdID0gKyhtYXRjaFs0XSA/IG1hdGNoWzVdICsgKG1hdGNoWzZdIHx8IDEpIDogMiAqIChtYXRjaFszXSA9PT0gXFxcImV2ZW5cXFwiIHx8IG1hdGNoWzNdID09PSBcXFwib2RkXFxcIikpO1xcblxcdFxcdFxcdFxcdFxcdFxcdG1hdGNoWzVdID0gKyhtYXRjaFs3XSArIG1hdGNoWzhdIHx8IG1hdGNoWzNdID09PSBcXFwib2RkXFxcIik7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gb3RoZXIgdHlwZXMgcHJvaGliaXQgYXJndW1lbnRzXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIGlmIChtYXRjaFszXSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFNpenpsZS5lcnJvcihtYXRjaFswXSk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBtYXRjaDtcXG5cXHRcXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdFxcdFxcXCJQU0VVRE9cXFwiOiBmdW5jdGlvbiBQU0VVRE8obWF0Y2gpIHtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgZXhjZXNzLFxcblxcdFxcdFxcdFxcdFxcdCAgICB1bnF1b3RlZCA9ICFtYXRjaFs2XSAmJiBtYXRjaFsyXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAobWF0Y2hFeHByW1xcXCJDSElMRFxcXCJdLnRlc3QobWF0Y2hbMF0pKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIG51bGw7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdC8vIEFjY2VwdCBxdW90ZWQgYXJndW1lbnRzIGFzLWlzXFxuXFx0XFx0XFx0XFx0XFx0aWYgKG1hdGNoWzNdKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0bWF0Y2hbMl0gPSBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBcXFwiXFxcIjtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBTdHJpcCBleGNlc3MgY2hhcmFjdGVycyBmcm9tIHVucXVvdGVkIGFyZ3VtZW50c1xcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSBpZiAodW5xdW90ZWQgJiYgcnBzZXVkby50ZXN0KHVucXVvdGVkKSAmJiAoXFxuXFx0XFx0XFx0XFx0XFx0Ly8gR2V0IGV4Y2VzcyBmcm9tIHRva2VuaXplIChyZWN1cnNpdmVseSlcXG5cXHRcXHRcXHRcXHRcXHRleGNlc3MgPSB0b2tlbml6ZSh1bnF1b3RlZCwgdHJ1ZSkpICYmIChcXG5cXHRcXHRcXHRcXHRcXHQvLyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNsb3NpbmcgcGFyZW50aGVzaXNcXG5cXHRcXHRcXHRcXHRcXHRleGNlc3MgPSB1bnF1b3RlZC5pbmRleE9mKFxcXCIpXFxcIiwgdW5xdW90ZWQubGVuZ3RoIC0gZXhjZXNzKSAtIHVucXVvdGVkLmxlbmd0aCkpIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBleGNlc3MgaXMgYSBuZWdhdGl2ZSBpbmRleFxcblxcdFxcdFxcdFxcdFxcdFxcdG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UoMCwgZXhjZXNzKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRtYXRjaFsyXSA9IHVucXVvdGVkLnNsaWNlKDAsIGV4Y2Vzcyk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdC8vIFJldHVybiBvbmx5IGNhcHR1cmVzIG5lZWRlZCBieSB0aGUgcHNldWRvIGZpbHRlciBtZXRob2QgKHR5cGUgYW5kIGFyZ3VtZW50KVxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBtYXRjaC5zbGljZSgwLCAzKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRmaWx0ZXI6IHtcXG5cXG5cXHRcXHRcXHRcXHRcXFwiVEFHXFxcIjogZnVuY3Rpb24gVEFHKG5vZGVOYW1lU2VsZWN0b3IpIHtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgbm9kZU5hbWUgPSBub2RlTmFtZVNlbGVjdG9yLnJlcGxhY2UocnVuZXNjYXBlLCBmdW5lc2NhcGUpLnRvTG93ZXJDYXNlKCk7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIG5vZGVOYW1lU2VsZWN0b3IgPT09IFxcXCIqXFxcIiA/IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHR9IDogZnVuY3Rpb24gKGVsZW0pIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5vZGVOYW1lO1xcblxcdFxcdFxcdFxcdFxcdH07XFxuXFx0XFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRcXHRcXFwiQ0xBU1NcXFwiOiBmdW5jdGlvbiBDTEFTUyhjbGFzc05hbWUpIHtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgcGF0dGVybiA9IGNsYXNzQ2FjaGVbY2xhc3NOYW1lICsgXFxcIiBcXFwiXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gcGF0dGVybiB8fCAocGF0dGVybiA9IG5ldyBSZWdFeHAoXFxcIihefFxcXCIgKyB3aGl0ZXNwYWNlICsgXFxcIilcXFwiICsgY2xhc3NOYW1lICsgXFxcIihcXFwiICsgd2hpdGVzcGFjZSArIFxcXCJ8JClcXFwiKSkgJiYgY2xhc3NDYWNoZShjbGFzc05hbWUsIGZ1bmN0aW9uIChlbGVtKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHBhdHRlcm4udGVzdCh0eXBlb2YgZWxlbS5jbGFzc05hbWUgPT09IFxcXCJzdHJpbmdcXFwiICYmIGVsZW0uY2xhc3NOYW1lIHx8IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSAhPT0gXFxcInVuZGVmaW5lZFxcXCIgJiYgZWxlbS5nZXRBdHRyaWJ1dGUoXFxcImNsYXNzXFxcIikgfHwgXFxcIlxcXCIpO1xcblxcdFxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0XFx0XFxcIkFUVFJcXFwiOiBmdW5jdGlvbiBBVFRSKG5hbWUsIG9wZXJhdG9yLCBjaGVjaykge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiAoZWxlbSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHZhciByZXN1bHQgPSBTaXp6bGUuYXR0cihlbGVtLCBuYW1lKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAocmVzdWx0ID09IG51bGwpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gb3BlcmF0b3IgPT09IFxcXCIhPVxcXCI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICghb3BlcmF0b3IpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0cmVzdWx0ICs9IFxcXCJcXFwiO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBvcGVyYXRvciA9PT0gXFxcIj1cXFwiID8gcmVzdWx0ID09PSBjaGVjayA6IG9wZXJhdG9yID09PSBcXFwiIT1cXFwiID8gcmVzdWx0ICE9PSBjaGVjayA6IG9wZXJhdG9yID09PSBcXFwiXj1cXFwiID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoY2hlY2spID09PSAwIDogb3BlcmF0b3IgPT09IFxcXCIqPVxcXCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZihjaGVjaykgPiAtMSA6IG9wZXJhdG9yID09PSBcXFwiJD1cXFwiID8gY2hlY2sgJiYgcmVzdWx0LnNsaWNlKC1jaGVjay5sZW5ndGgpID09PSBjaGVjayA6IG9wZXJhdG9yID09PSBcXFwifj1cXFwiID8gKFxcXCIgXFxcIiArIHJlc3VsdC5yZXBsYWNlKHJ3aGl0ZXNwYWNlLCBcXFwiIFxcXCIpICsgXFxcIiBcXFwiKS5pbmRleE9mKGNoZWNrKSA+IC0xIDogb3BlcmF0b3IgPT09IFxcXCJ8PVxcXCIgPyByZXN1bHQgPT09IGNoZWNrIHx8IHJlc3VsdC5zbGljZSgwLCBjaGVjay5sZW5ndGggKyAxKSA9PT0gY2hlY2sgKyBcXFwiLVxcXCIgOiBmYWxzZTtcXG5cXHRcXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0XFx0XFxcIkNISUxEXFxcIjogZnVuY3Rpb24gQ0hJTEQodHlwZSwgd2hhdCwgYXJndW1lbnQsIGZpcnN0LCBsYXN0KSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIHNpbXBsZSA9IHR5cGUuc2xpY2UoMCwgMykgIT09IFxcXCJudGhcXFwiLFxcblxcdFxcdFxcdFxcdFxcdCAgICBmb3J3YXJkID0gdHlwZS5zbGljZSgtNCkgIT09IFxcXCJsYXN0XFxcIixcXG5cXHRcXHRcXHRcXHRcXHQgICAgb2ZUeXBlID0gd2hhdCA9PT0gXFxcIm9mLXR5cGVcXFwiO1xcblxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBmaXJzdCA9PT0gMSAmJiBsYXN0ID09PSAwID9cXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBTaG9ydGN1dCBmb3IgOm50aC0qKG4pXFxuXFx0XFx0XFx0XFx0XFx0ZnVuY3Rpb24gKGVsZW0pIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gISFlbGVtLnBhcmVudE5vZGU7XFxuXFx0XFx0XFx0XFx0XFx0fSA6IGZ1bmN0aW9uIChlbGVtLCBjb250ZXh0LCB4bWwpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgY2FjaGUsXFxuXFx0XFx0XFx0XFx0XFx0XFx0ICAgIG91dGVyQ2FjaGUsXFxuXFx0XFx0XFx0XFx0XFx0XFx0ICAgIG5vZGUsXFxuXFx0XFx0XFx0XFx0XFx0XFx0ICAgIGRpZmYsXFxuXFx0XFx0XFx0XFx0XFx0XFx0ICAgIG5vZGVJbmRleCxcXG5cXHRcXHRcXHRcXHRcXHRcXHQgICAgc3RhcnQsXFxuXFx0XFx0XFx0XFx0XFx0XFx0ICAgIGRpciA9IHNpbXBsZSAhPT0gZm9yd2FyZCA/IFxcXCJuZXh0U2libGluZ1xcXCIgOiBcXFwicHJldmlvdXNTaWJsaW5nXFxcIixcXG5cXHRcXHRcXHRcXHRcXHRcXHQgICAgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlLFxcblxcdFxcdFxcdFxcdFxcdFxcdCAgICBuYW1lID0gb2ZUeXBlICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcXG5cXHRcXHRcXHRcXHRcXHRcXHQgICAgdXNlQ2FjaGUgPSAheG1sICYmICFvZlR5cGU7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKHBhcmVudCkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIDooZmlyc3R8bGFzdHxvbmx5KS0oY2hpbGR8b2YtdHlwZSlcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoc2ltcGxlKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0d2hpbGUgKGRpcikge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG5vZGUgPSBlbGVtO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHdoaWxlIChub2RlID0gbm9kZVtkaXJdKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKG9mVHlwZSA/IG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6IG5vZGUubm9kZVR5cGUgPT09IDEpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBSZXZlcnNlIGRpcmVjdGlvbiBmb3IgOm9ubHktKiAoaWYgd2UgaGF2ZW4ndCB5ZXQgZG9uZSBzbylcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRzdGFydCA9IGRpciA9IHR5cGUgPT09IFxcXCJvbmx5XFxcIiAmJiAhc3RhcnQgJiYgXFxcIm5leHRTaWJsaW5nXFxcIjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHN0YXJ0ID0gW2ZvcndhcmQgPyBwYXJlbnQuZmlyc3RDaGlsZCA6IHBhcmVudC5sYXN0Q2hpbGRdO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIG5vbi14bWwgOm50aC1jaGlsZCguLi4pIHN0b3JlcyBjYWNoZSBkYXRhIG9uIGBwYXJlbnRgXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKGZvcndhcmQgJiYgdXNlQ2FjaGUpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBTZWVrIGBlbGVtYCBmcm9tIGEgcHJldmlvdXNseS1jYWNoZWQgaW5kZXhcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRvdXRlckNhY2hlID0gcGFyZW50W2V4cGFuZG9dIHx8IChwYXJlbnRbZXhwYW5kb10gPSB7fSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Y2FjaGUgPSBvdXRlckNhY2hlW3R5cGVdIHx8IFtdO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG5vZGVJbmRleCA9IGNhY2hlWzBdID09PSBkaXJydW5zICYmIGNhY2hlWzFdO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRpZmYgPSBjYWNoZVswXSA9PT0gZGlycnVucyAmJiBjYWNoZVsyXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRub2RlID0gbm9kZUluZGV4ICYmIHBhcmVudC5jaGlsZE5vZGVzW25vZGVJbmRleF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0d2hpbGUgKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbZGlyXSB8fCAoXFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gRmFsbGJhY2sgdG8gc2Vla2luZyBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkaWZmID0gbm9kZUluZGV4ID0gMCkgfHwgc3RhcnQucG9wKCkpIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBXaGVuIGZvdW5kLCBjYWNoZSBpbmRleGVzIG9uIGBwYXJlbnRgIGFuZCBicmVha1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChub2RlLm5vZGVUeXBlID09PSAxICYmICsrZGlmZiAmJiBub2RlID09PSBlbGVtKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0b3V0ZXJDYWNoZVt0eXBlXSA9IFtkaXJydW5zLCBub2RlSW5kZXgsIGRpZmZdO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gVXNlIHByZXZpb3VzbHktY2FjaGVkIGVsZW1lbnQgaW5kZXggaWYgYXZhaWxhYmxlXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIGlmICh1c2VDYWNoZSAmJiAoY2FjaGUgPSAoZWxlbVtleHBhbmRvXSB8fCAoZWxlbVtleHBhbmRvXSA9IHt9KSlbdHlwZV0pICYmIGNhY2hlWzBdID09PSBkaXJydW5zKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGlmZiA9IGNhY2hlWzFdO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIHhtbCA6bnRoLWNoaWxkKC4uLikgb3IgOm50aC1sYXN0LWNoaWxkKC4uLikgb3IgOm50aCgtbGFzdCk/LW9mLXR5cGUoLi4uKVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gVXNlIHRoZSBzYW1lIGxvb3AgYXMgYWJvdmUgdG8gc2VlayBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR3aGlsZSAobm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVtkaXJdIHx8IChkaWZmID0gbm9kZUluZGV4ID0gMCkgfHwgc3RhcnQucG9wKCkpIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoKG9mVHlwZSA/IG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6IG5vZGUubm9kZVR5cGUgPT09IDEpICYmICsrZGlmZikge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIENhY2hlIHRoZSBpbmRleCBvZiBlYWNoIGVuY291bnRlcmVkIGVsZW1lbnRcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAodXNlQ2FjaGUpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQobm9kZVtleHBhbmRvXSB8fCAobm9kZVtleHBhbmRvXSA9IHt9KSlbdHlwZV0gPSBbZGlycnVucywgZGlmZl07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChub2RlID09PSBlbGVtKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIEluY29ycG9yYXRlIHRoZSBvZmZzZXQsIHRoZW4gY2hlY2sgYWdhaW5zdCBjeWNsZSBzaXplXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGlmZiAtPSBsYXN0O1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBkaWZmID09PSBmaXJzdCB8fCBkaWZmICUgZmlyc3QgPT09IDAgJiYgZGlmZiAvIGZpcnN0ID49IDA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH07XFxuXFx0XFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRcXHRcXFwiUFNFVURPXFxcIjogZnVuY3Rpb24gUFNFVURPKHBzZXVkbywgYXJndW1lbnQpIHtcXG5cXHRcXHRcXHRcXHRcXHQvLyBwc2V1ZG8tY2xhc3MgbmFtZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmVcXG5cXHRcXHRcXHRcXHRcXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI3BzZXVkby1jbGFzc2VzXFxuXFx0XFx0XFx0XFx0XFx0Ly8gUHJpb3JpdGl6ZSBieSBjYXNlIHNlbnNpdGl2aXR5IGluIGNhc2UgY3VzdG9tIHBzZXVkb3MgYXJlIGFkZGVkIHdpdGggdXBwZXJjYXNlIGxldHRlcnNcXG5cXHRcXHRcXHRcXHRcXHQvLyBSZW1lbWJlciB0aGF0IHNldEZpbHRlcnMgaW5oZXJpdHMgZnJvbSBwc2V1ZG9zXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGFyZ3MsXFxuXFx0XFx0XFx0XFx0XFx0ICAgIGZuID0gRXhwci5wc2V1ZG9zW3BzZXVkb10gfHwgRXhwci5zZXRGaWx0ZXJzW3BzZXVkby50b0xvd2VyQ2FzZSgpXSB8fCBTaXp6bGUuZXJyb3IoXFxcInVuc3VwcG9ydGVkIHBzZXVkbzogXFxcIiArIHBzZXVkbyk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gVGhlIHVzZXIgbWF5IHVzZSBjcmVhdGVQc2V1ZG8gdG8gaW5kaWNhdGUgdGhhdFxcblxcdFxcdFxcdFxcdFxcdC8vIGFyZ3VtZW50cyBhcmUgbmVlZGVkIHRvIGNyZWF0ZSB0aGUgZmlsdGVyIGZ1bmN0aW9uXFxuXFx0XFx0XFx0XFx0XFx0Ly8ganVzdCBhcyBTaXp6bGUgZG9lc1xcblxcdFxcdFxcdFxcdFxcdGlmIChmbltleHBhbmRvXSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBmbihhcmd1bWVudCk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdC8vIEJ1dCBtYWludGFpbiBzdXBwb3J0IGZvciBvbGQgc2lnbmF0dXJlc1xcblxcdFxcdFxcdFxcdFxcdGlmIChmbi5sZW5ndGggPiAxKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YXJncyA9IFtwc2V1ZG8sIHBzZXVkbywgXFxcIlxcXCIsIGFyZ3VtZW50XTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gRXhwci5zZXRGaWx0ZXJzLmhhc093blByb3BlcnR5KHBzZXVkby50b0xvd2VyQ2FzZSgpKSA/IG1hcmtGdW5jdGlvbihmdW5jdGlvbiAoc2VlZCwgbWF0Y2hlcykge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciBpZHgsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ICAgIG1hdGNoZWQgPSBmbihzZWVkLCBhcmd1bWVudCksXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ICAgIGkgPSBtYXRjaGVkLmxlbmd0aDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR3aGlsZSAoaS0tKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWR4ID0gaW5kZXhPZihzZWVkLCBtYXRjaGVkW2ldKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRzZWVkW2lkeF0gPSAhKG1hdGNoZXNbaWR4XSA9IG1hdGNoZWRbaV0pO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9KSA6IGZ1bmN0aW9uIChlbGVtKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIGZuKGVsZW0sIDAsIGFyZ3MpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH07XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBmbjtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRwc2V1ZG9zOiB7XFxuXFx0XFx0XFx0XFx0Ly8gUG90ZW50aWFsbHkgY29tcGxleCBwc2V1ZG9zXFxuXFx0XFx0XFx0XFx0XFxcIm5vdFxcXCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiAoc2VsZWN0b3IpIHtcXG5cXHRcXHRcXHRcXHRcXHQvLyBUcmltIHRoZSBzZWxlY3RvciBwYXNzZWQgdG8gY29tcGlsZVxcblxcdFxcdFxcdFxcdFxcdC8vIHRvIGF2b2lkIHRyZWF0aW5nIGxlYWRpbmcgYW5kIHRyYWlsaW5nXFxuXFx0XFx0XFx0XFx0XFx0Ly8gc3BhY2VzIGFzIGNvbWJpbmF0b3JzXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGlucHV0ID0gW10sXFxuXFx0XFx0XFx0XFx0XFx0ICAgIHJlc3VsdHMgPSBbXSxcXG5cXHRcXHRcXHRcXHRcXHQgICAgbWF0Y2hlciA9IGNvbXBpbGUoc2VsZWN0b3IucmVwbGFjZShydHJpbSwgXFxcIiQxXFxcIikpO1xcblxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBtYXRjaGVyW2V4cGFuZG9dID8gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uIChzZWVkLCBtYXRjaGVzLCBjb250ZXh0LCB4bWwpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgZWxlbSxcXG5cXHRcXHRcXHRcXHRcXHRcXHQgICAgdW5tYXRjaGVkID0gbWF0Y2hlcihzZWVkLCBudWxsLCB4bWwsIFtdKSxcXG5cXHRcXHRcXHRcXHRcXHRcXHQgICAgaSA9IHNlZWQubGVuZ3RoO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIE1hdGNoIGVsZW1lbnRzIHVubWF0Y2hlZCBieSBgbWF0Y2hlcmBcXG5cXHRcXHRcXHRcXHRcXHRcXHR3aGlsZSAoaS0tKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKGVsZW0gPSB1bm1hdGNoZWRbaV0pIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRzZWVkW2ldID0gIShtYXRjaGVzW2ldID0gZWxlbSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9KSA6IGZ1bmN0aW9uIChlbGVtLCBjb250ZXh0LCB4bWwpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpbnB1dFswXSA9IGVsZW07XFxuXFx0XFx0XFx0XFx0XFx0XFx0bWF0Y2hlcihpbnB1dCwgbnVsbCwgeG1sLCByZXN1bHRzKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBEb24ndCBrZWVwIHRoZSBlbGVtZW50IChpc3N1ZSAjMjk5KVxcblxcdFxcdFxcdFxcdFxcdFxcdGlucHV0WzBdID0gbnVsbDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gIXJlc3VsdHMucG9wKCk7XFxuXFx0XFx0XFx0XFx0XFx0fTtcXG5cXHRcXHRcXHRcXHR9KSxcXG5cXG5cXHRcXHRcXHRcXHRcXFwiaGFzXFxcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uIChzZWxlY3Rvcikge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiAoZWxlbSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBTaXp6bGUoc2VsZWN0b3IsIGVsZW0pLmxlbmd0aCA+IDA7XFxuXFx0XFx0XFx0XFx0XFx0fTtcXG5cXHRcXHRcXHRcXHR9KSxcXG5cXG5cXHRcXHRcXHRcXHRcXFwiY29udGFpbnNcXFwiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24gKHRleHQpIHtcXG5cXHRcXHRcXHRcXHRcXHR0ZXh0ID0gdGV4dC5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKTtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gKGVsZW0pIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gKGVsZW0udGV4dENvbnRlbnQgfHwgZWxlbS5pbm5lclRleHQgfHwgZ2V0VGV4dChlbGVtKSkuaW5kZXhPZih0ZXh0KSA+IC0xO1xcblxcdFxcdFxcdFxcdFxcdH07XFxuXFx0XFx0XFx0XFx0fSksXFxuXFxuXFx0XFx0XFx0XFx0Ly8gXFxcIldoZXRoZXIgYW4gZWxlbWVudCBpcyByZXByZXNlbnRlZCBieSBhIDpsYW5nKCkgc2VsZWN0b3JcXG5cXHRcXHRcXHRcXHQvLyBpcyBiYXNlZCBzb2xlbHkgb24gdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZVxcblxcdFxcdFxcdFxcdC8vIGJlaW5nIGVxdWFsIHRvIHRoZSBpZGVudGlmaWVyIEMsXFxuXFx0XFx0XFx0XFx0Ly8gb3IgYmVnaW5uaW5nIHdpdGggdGhlIGlkZW50aWZpZXIgQyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBcXFwiLVxcXCIuXFxuXFx0XFx0XFx0XFx0Ly8gVGhlIG1hdGNoaW5nIG9mIEMgYWdhaW5zdCB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlIGlzIHBlcmZvcm1lZCBjYXNlLWluc2Vuc2l0aXZlbHkuXFxuXFx0XFx0XFx0XFx0Ly8gVGhlIGlkZW50aWZpZXIgQyBkb2VzIG5vdCBoYXZlIHRvIGJlIGEgdmFsaWQgbGFuZ3VhZ2UgbmFtZS5cXFwiXFxuXFx0XFx0XFx0XFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNsYW5nLXBzZXVkb1xcblxcdFxcdFxcdFxcdFxcXCJsYW5nXFxcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uIChsYW5nKSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gbGFuZyB2YWx1ZSBtdXN0IGJlIGEgdmFsaWQgaWRlbnRpZmllclxcblxcdFxcdFxcdFxcdFxcdGlmICghcmlkZW50aWZpZXIudGVzdChsYW5nIHx8IFxcXCJcXFwiKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFNpenpsZS5lcnJvcihcXFwidW5zdXBwb3J0ZWQgbGFuZzogXFxcIiArIGxhbmcpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRsYW5nID0gbGFuZy5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKS50b0xvd2VyQ2FzZSgpO1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiAoZWxlbSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBlbGVtTGFuZztcXG5cXHRcXHRcXHRcXHRcXHRcXHRkbyB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKGVsZW1MYW5nID0gZG9jdW1lbnRJc0hUTUwgPyBlbGVtLmxhbmcgOiBlbGVtLmdldEF0dHJpYnV0ZShcXFwieG1sOmxhbmdcXFwiKSB8fCBlbGVtLmdldEF0dHJpYnV0ZShcXFwibGFuZ1xcXCIpKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZWxlbUxhbmcgPSBlbGVtTGFuZy50b0xvd2VyQ2FzZSgpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBlbGVtTGFuZyA9PT0gbGFuZyB8fCBlbGVtTGFuZy5pbmRleE9mKGxhbmcgKyBcXFwiLVxcXCIpID09PSAwO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9IHdoaWxlICgoZWxlbSA9IGVsZW0ucGFyZW50Tm9kZSkgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdFxcdFxcdH07XFxuXFx0XFx0XFx0XFx0fSksXFxuXFxuXFx0XFx0XFx0XFx0Ly8gTWlzY2VsbGFuZW91c1xcblxcdFxcdFxcdFxcdFxcXCJ0YXJnZXRcXFwiOiBmdW5jdGlvbiB0YXJnZXQoZWxlbSkge1xcblxcdFxcdFxcdFxcdFxcdHZhciBoYXNoID0gd2luZG93LmxvY2F0aW9uICYmIHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBoYXNoICYmIGhhc2guc2xpY2UoMSkgPT09IGVsZW0uaWQ7XFxuXFx0XFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRcXHRcXFwicm9vdFxcXCI6IGZ1bmN0aW9uIHJvb3QoZWxlbSkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBlbGVtID09PSBkb2NFbGVtO1xcblxcdFxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0XFx0XFxcImZvY3VzXFxcIjogZnVuY3Rpb24gZm9jdXMoZWxlbSkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBlbGVtID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmICghZG9jdW1lbnQuaGFzRm9jdXMgfHwgZG9jdW1lbnQuaGFzRm9jdXMoKSkgJiYgISEoZWxlbS50eXBlIHx8IGVsZW0uaHJlZiB8fCB+ZWxlbS50YWJJbmRleCk7XFxuXFx0XFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRcXHQvLyBCb29sZWFuIHByb3BlcnRpZXNcXG5cXHRcXHRcXHRcXHRcXFwiZW5hYmxlZFxcXCI6IGZ1bmN0aW9uIGVuYWJsZWQoZWxlbSkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBmYWxzZTtcXG5cXHRcXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdFxcdFxcXCJkaXNhYmxlZFxcXCI6IGZ1bmN0aW9uIGRpc2FibGVkKGVsZW0pIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdFxcdFxcXCJjaGVja2VkXFxcIjogZnVuY3Rpb24gY2hlY2tlZChlbGVtKSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gSW4gQ1NTMywgOmNoZWNrZWQgc2hvdWxkIHJldHVybiBib3RoIGNoZWNrZWQgYW5kIHNlbGVjdGVkIGVsZW1lbnRzXFxuXFx0XFx0XFx0XFx0XFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcXG5cXHRcXHRcXHRcXHRcXHR2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIG5vZGVOYW1lID09PSBcXFwiaW5wdXRcXFwiICYmICEhZWxlbS5jaGVja2VkIHx8IG5vZGVOYW1lID09PSBcXFwib3B0aW9uXFxcIiAmJiAhIWVsZW0uc2VsZWN0ZWQ7XFxuXFx0XFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRcXHRcXFwic2VsZWN0ZWRcXFwiOiBmdW5jdGlvbiBzZWxlY3RlZChlbGVtKSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gQWNjZXNzaW5nIHRoaXMgcHJvcGVydHkgbWFrZXMgc2VsZWN0ZWQtYnktZGVmYXVsdFxcblxcdFxcdFxcdFxcdFxcdC8vIG9wdGlvbnMgaW4gU2FmYXJpIHdvcmsgcHJvcGVybHlcXG5cXHRcXHRcXHRcXHRcXHRpZiAoZWxlbS5wYXJlbnROb2RlKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZWxlbS5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBlbGVtLnNlbGVjdGVkID09PSB0cnVlO1xcblxcdFxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0XFx0Ly8gQ29udGVudHNcXG5cXHRcXHRcXHRcXHRcXFwiZW1wdHlcXFwiOiBmdW5jdGlvbiBlbXB0eShlbGVtKSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNlbXB0eS1wc2V1ZG9cXG5cXHRcXHRcXHRcXHRcXHQvLyA6ZW1wdHkgaXMgbmVnYXRlZCBieSBlbGVtZW50ICgxKSBvciBjb250ZW50IG5vZGVzICh0ZXh0OiAzOyBjZGF0YTogNDsgZW50aXR5IHJlZjogNSksXFxuXFx0XFx0XFx0XFx0XFx0Ly8gICBidXQgbm90IGJ5IG90aGVycyAoY29tbWVudDogODsgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbjogNzsgZXRjLilcXG5cXHRcXHRcXHRcXHRcXHQvLyBub2RlVHlwZSA8IDYgd29ya3MgYmVjYXVzZSBhdHRyaWJ1dGVzICgyKSBkbyBub3QgYXBwZWFyIGFzIGNoaWxkcmVuXFxuXFx0XFx0XFx0XFx0XFx0Zm9yIChlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZykge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChlbGVtLm5vZGVUeXBlIDwgNikge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0XFx0XFxcInBhcmVudFxcXCI6IGZ1bmN0aW9uIHBhcmVudChlbGVtKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuICFFeHByLnBzZXVkb3NbXFxcImVtcHR5XFxcIl0oZWxlbSk7XFxuXFx0XFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRcXHQvLyBFbGVtZW50L2lucHV0IHR5cGVzXFxuXFx0XFx0XFx0XFx0XFxcImhlYWRlclxcXCI6IGZ1bmN0aW9uIGhlYWRlcihlbGVtKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHJoZWFkZXIudGVzdChlbGVtLm5vZGVOYW1lKTtcXG5cXHRcXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdFxcdFxcXCJpbnB1dFxcXCI6IGZ1bmN0aW9uIGlucHV0KGVsZW0pIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gcmlucHV0cy50ZXN0KGVsZW0ubm9kZU5hbWUpO1xcblxcdFxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0XFx0XFxcImJ1dHRvblxcXCI6IGZ1bmN0aW9uIGJ1dHRvbihlbGVtKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIG5hbWUgPT09IFxcXCJpbnB1dFxcXCIgJiYgZWxlbS50eXBlID09PSBcXFwiYnV0dG9uXFxcIiB8fCBuYW1lID09PSBcXFwiYnV0dG9uXFxcIjtcXG5cXHRcXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdFxcdFxcXCJ0ZXh0XFxcIjogZnVuY3Rpb24gdGV4dChlbGVtKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGF0dHI7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXFxcImlucHV0XFxcIiAmJiBlbGVtLnR5cGUgPT09IFxcXCJ0ZXh0XFxcIiAmJiAoXFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogSUU8OFxcblxcdFxcdFxcdFxcdFxcdC8vIE5ldyBIVE1MNSBhdHRyaWJ1dGUgdmFsdWVzIChlLmcuLCBcXFwic2VhcmNoXFxcIikgYXBwZWFyIHdpdGggZWxlbS50eXBlID09PSBcXFwidGV4dFxcXCJcXG5cXHRcXHRcXHRcXHRcXHQoYXR0ciA9IGVsZW0uZ2V0QXR0cmlidXRlKFxcXCJ0eXBlXFxcIikpID09IG51bGwgfHwgYXR0ci50b0xvd2VyQ2FzZSgpID09PSBcXFwidGV4dFxcXCIpO1xcblxcdFxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0XFx0Ly8gUG9zaXRpb24taW4tY29sbGVjdGlvblxcblxcdFxcdFxcdFxcdFxcXCJmaXJzdFxcXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBbMF07XFxuXFx0XFx0XFx0XFx0fSksXFxuXFxuXFx0XFx0XFx0XFx0XFxcImxhc3RcXFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uIChtYXRjaEluZGV4ZXMsIGxlbmd0aCkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBbbGVuZ3RoIC0gMV07XFxuXFx0XFx0XFx0XFx0fSksXFxuXFxuXFx0XFx0XFx0XFx0XFxcImVxXFxcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiAobWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50KSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIFthcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50XTtcXG5cXHRcXHRcXHRcXHR9KSxcXG5cXG5cXHRcXHRcXHRcXHRcXFwiZXZlblxcXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24gKG1hdGNoSW5kZXhlcywgbGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGkgPSAwO1xcblxcdFxcdFxcdFxcdFxcdGZvciAoOyBpIDwgbGVuZ3RoOyBpICs9IDIpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRtYXRjaEluZGV4ZXMucHVzaChpKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcXG5cXHRcXHRcXHRcXHR9KSxcXG5cXG5cXHRcXHRcXHRcXHRcXFwib2RkXFxcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiAobWF0Y2hJbmRleGVzLCBsZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgaSA9IDE7XFxuXFx0XFx0XFx0XFx0XFx0Zm9yICg7IGkgPCBsZW5ndGg7IGkgKz0gMikge1xcblxcdFxcdFxcdFxcdFxcdFxcdG1hdGNoSW5kZXhlcy5wdXNoKGkpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xcblxcdFxcdFxcdFxcdH0pLFxcblxcblxcdFxcdFxcdFxcdFxcXCJsdFxcXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24gKG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCkge1xcblxcdFxcdFxcdFxcdFxcdHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcXG5cXHRcXHRcXHRcXHRcXHRmb3IgKDsgLS1pID49IDA7KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0bWF0Y2hJbmRleGVzLnB1c2goaSk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBtYXRjaEluZGV4ZXM7XFxuXFx0XFx0XFx0XFx0fSksXFxuXFxuXFx0XFx0XFx0XFx0XFxcImd0XFxcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiAobWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50KSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGkgPSBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50O1xcblxcdFxcdFxcdFxcdFxcdGZvciAoOyArK2kgPCBsZW5ndGg7KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0bWF0Y2hJbmRleGVzLnB1c2goaSk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBtYXRjaEluZGV4ZXM7XFxuXFx0XFx0XFx0XFx0fSlcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fTtcXG5cXG5cXHRcXHRFeHByLnBzZXVkb3NbXFxcIm50aFxcXCJdID0gRXhwci5wc2V1ZG9zW1xcXCJlcVxcXCJdO1xcblxcblxcdFxcdC8vIEFkZCBidXR0b24vaW5wdXQgdHlwZSBwc2V1ZG9zXFxuXFx0XFx0Zm9yIChpIGluIHsgcmFkaW86IHRydWUsIGNoZWNrYm94OiB0cnVlLCBmaWxlOiB0cnVlLCBwYXNzd29yZDogdHJ1ZSwgaW1hZ2U6IHRydWUgfSkge1xcblxcdFxcdFxcdEV4cHIucHNldWRvc1tpXSA9IGNyZWF0ZUlucHV0UHNldWRvKGkpO1xcblxcdFxcdH1cXG5cXHRcXHRmb3IgKGkgaW4geyBzdWJtaXQ6IHRydWUsIHJlc2V0OiB0cnVlIH0pIHtcXG5cXHRcXHRcXHRFeHByLnBzZXVkb3NbaV0gPSBjcmVhdGVCdXR0b25Qc2V1ZG8oaSk7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIEVhc3kgQVBJIGZvciBjcmVhdGluZyBuZXcgc2V0RmlsdGVyc1xcblxcdFxcdGZ1bmN0aW9uIHNldEZpbHRlcnMoKSB7fVxcblxcdFxcdHNldEZpbHRlcnMucHJvdG90eXBlID0gRXhwci5maWx0ZXJzID0gRXhwci5wc2V1ZG9zO1xcblxcdFxcdEV4cHIuc2V0RmlsdGVycyA9IG5ldyBzZXRGaWx0ZXJzKCk7XFxuXFxuXFx0XFx0dG9rZW5pemUgPSBTaXp6bGUudG9rZW5pemUgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIHBhcnNlT25seSkge1xcblxcdFxcdFxcdHZhciBtYXRjaGVkLFxcblxcdFxcdFxcdCAgICBtYXRjaCxcXG5cXHRcXHRcXHQgICAgdG9rZW5zLFxcblxcdFxcdFxcdCAgICB0eXBlLFxcblxcdFxcdFxcdCAgICBzb0ZhcixcXG5cXHRcXHRcXHQgICAgZ3JvdXBzLFxcblxcdFxcdFxcdCAgICBwcmVGaWx0ZXJzLFxcblxcdFxcdFxcdCAgICBjYWNoZWQgPSB0b2tlbkNhY2hlW3NlbGVjdG9yICsgXFxcIiBcXFwiXTtcXG5cXG5cXHRcXHRcXHRpZiAoY2FjaGVkKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHBhcnNlT25seSA/IDAgOiBjYWNoZWQuc2xpY2UoMCk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHNvRmFyID0gc2VsZWN0b3I7XFxuXFx0XFx0XFx0Z3JvdXBzID0gW107XFxuXFx0XFx0XFx0cHJlRmlsdGVycyA9IEV4cHIucHJlRmlsdGVyO1xcblxcblxcdFxcdFxcdHdoaWxlIChzb0Zhcikge1xcblxcblxcdFxcdFxcdFxcdC8vIENvbW1hIGFuZCBmaXJzdCBydW5cXG5cXHRcXHRcXHRcXHRpZiAoIW1hdGNoZWQgfHwgKG1hdGNoID0gcmNvbW1hLmV4ZWMoc29GYXIpKSkge1xcblxcdFxcdFxcdFxcdFxcdGlmIChtYXRjaCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdC8vIERvbid0IGNvbnN1bWUgdHJhaWxpbmcgY29tbWFzIGFzIHZhbGlkXFxuXFx0XFx0XFx0XFx0XFx0XFx0c29GYXIgPSBzb0Zhci5zbGljZShtYXRjaFswXS5sZW5ndGgpIHx8IHNvRmFyO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRncm91cHMucHVzaCh0b2tlbnMgPSBbXSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdG1hdGNoZWQgPSBmYWxzZTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBDb21iaW5hdG9yc1xcblxcdFxcdFxcdFxcdGlmIChtYXRjaCA9IHJjb21iaW5hdG9ycy5leGVjKHNvRmFyKSkge1xcblxcdFxcdFxcdFxcdFxcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xcblxcdFxcdFxcdFxcdFxcdHRva2Vucy5wdXNoKHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YWx1ZTogbWF0Y2hlZCxcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBDYXN0IGRlc2NlbmRhbnQgY29tYmluYXRvcnMgdG8gc3BhY2VcXG5cXHRcXHRcXHRcXHRcXHRcXHR0eXBlOiBtYXRjaFswXS5yZXBsYWNlKHJ0cmltLCBcXFwiIFxcXCIpXFxuXFx0XFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0XFx0XFx0c29GYXIgPSBzb0Zhci5zbGljZShtYXRjaGVkLmxlbmd0aCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIEZpbHRlcnNcXG5cXHRcXHRcXHRcXHRmb3IgKHR5cGUgaW4gRXhwci5maWx0ZXIpIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoKG1hdGNoID0gbWF0Y2hFeHByW3R5cGVdLmV4ZWMoc29GYXIpKSAmJiAoIXByZUZpbHRlcnNbdHlwZV0gfHwgKG1hdGNoID0gcHJlRmlsdGVyc1t0eXBlXShtYXRjaCkpKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xcblxcdFxcdFxcdFxcdFxcdFxcdHRva2Vucy5wdXNoKHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YWx1ZTogbWF0Y2hlZCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0eXBlOiB0eXBlLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG1hdGNoZXM6IG1hdGNoXFxuXFx0XFx0XFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0c29GYXIgPSBzb0Zhci5zbGljZShtYXRjaGVkLmxlbmd0aCk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAoIW1hdGNoZWQpIHtcXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFJldHVybiB0aGUgbGVuZ3RoIG9mIHRoZSBpbnZhbGlkIGV4Y2Vzc1xcblxcdFxcdFxcdC8vIGlmIHdlJ3JlIGp1c3QgcGFyc2luZ1xcblxcdFxcdFxcdC8vIE90aGVyd2lzZSwgdGhyb3cgYW4gZXJyb3Igb3IgcmV0dXJuIHRva2Vuc1xcblxcdFxcdFxcdHJldHVybiBwYXJzZU9ubHkgPyBzb0Zhci5sZW5ndGggOiBzb0ZhciA/IFNpenpsZS5lcnJvcihzZWxlY3RvcikgOlxcblxcdFxcdFxcdC8vIENhY2hlIHRoZSB0b2tlbnNcXG5cXHRcXHRcXHR0b2tlbkNhY2hlKHNlbGVjdG9yLCBncm91cHMpLnNsaWNlKDApO1xcblxcdFxcdH07XFxuXFxuXFx0XFx0ZnVuY3Rpb24gdG9TZWxlY3Rvcih0b2tlbnMpIHtcXG5cXHRcXHRcXHR2YXIgaSA9IDAsXFxuXFx0XFx0XFx0ICAgIGxlbiA9IHRva2Vucy5sZW5ndGgsXFxuXFx0XFx0XFx0ICAgIHNlbGVjdG9yID0gXFxcIlxcXCI7XFxuXFx0XFx0XFx0Zm9yICg7IGkgPCBsZW47IGkrKykge1xcblxcdFxcdFxcdFxcdHNlbGVjdG9yICs9IHRva2Vuc1tpXS52YWx1ZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIHNlbGVjdG9yO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiBhZGRDb21iaW5hdG9yKG1hdGNoZXIsIGNvbWJpbmF0b3IsIGJhc2UpIHtcXG5cXHRcXHRcXHR2YXIgZGlyID0gY29tYmluYXRvci5kaXIsXFxuXFx0XFx0XFx0ICAgIGNoZWNrTm9uRWxlbWVudHMgPSBiYXNlICYmIGRpciA9PT0gXFxcInBhcmVudE5vZGVcXFwiLFxcblxcdFxcdFxcdCAgICBkb25lTmFtZSA9IGRvbmUrKztcXG5cXG5cXHRcXHRcXHRyZXR1cm4gY29tYmluYXRvci5maXJzdCA/XFxuXFx0XFx0XFx0Ly8gQ2hlY2sgYWdhaW5zdCBjbG9zZXN0IGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50XFxuXFx0XFx0XFx0ZnVuY3Rpb24gKGVsZW0sIGNvbnRleHQsIHhtbCkge1xcblxcdFxcdFxcdFxcdHdoaWxlIChlbGVtID0gZWxlbVtkaXJdKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cykge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBtYXRjaGVyKGVsZW0sIGNvbnRleHQsIHhtbCk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9IDpcXG5cXG5cXHRcXHRcXHQvLyBDaGVjayBhZ2FpbnN0IGFsbCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudHNcXG5cXHRcXHRcXHRmdW5jdGlvbiAoZWxlbSwgY29udGV4dCwgeG1sKSB7XFxuXFx0XFx0XFx0XFx0dmFyIG9sZENhY2hlLFxcblxcdFxcdFxcdFxcdCAgICBvdXRlckNhY2hlLFxcblxcdFxcdFxcdFxcdCAgICBuZXdDYWNoZSA9IFtkaXJydW5zLCBkb25lTmFtZV07XFxuXFxuXFx0XFx0XFx0XFx0Ly8gV2UgY2FuJ3Qgc2V0IGFyYml0cmFyeSBkYXRhIG9uIFhNTCBub2Rlcywgc28gdGhleSBkb24ndCBiZW5lZml0IGZyb20gZGlyIGNhY2hpbmdcXG5cXHRcXHRcXHRcXHRpZiAoeG1sKSB7XFxuXFx0XFx0XFx0XFx0XFx0d2hpbGUgKGVsZW0gPSBlbGVtW2Rpcl0pIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKG1hdGNoZXIoZWxlbSwgY29udGV4dCwgeG1sKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0d2hpbGUgKGVsZW0gPSBlbGVtW2Rpcl0pIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0b3V0ZXJDYWNoZSA9IGVsZW1bZXhwYW5kb10gfHwgKGVsZW1bZXhwYW5kb10gPSB7fSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKChvbGRDYWNoZSA9IG91dGVyQ2FjaGVbZGlyXSkgJiYgb2xkQ2FjaGVbMF0gPT09IGRpcnJ1bnMgJiYgb2xkQ2FjaGVbMV0gPT09IGRvbmVOYW1lKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gQXNzaWduIHRvIG5ld0NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gbmV3Q2FjaGVbMl0gPSBvbGRDYWNoZVsyXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIFJldXNlIG5ld2NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRvdXRlckNhY2hlW2Rpcl0gPSBuZXdDYWNoZTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBBIG1hdGNoIG1lYW5zIHdlJ3JlIGRvbmU7IGEgZmFpbCBtZWFucyB3ZSBoYXZlIHRvIGtlZXAgY2hlY2tpbmdcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAobmV3Q2FjaGVbMl0gPSBtYXRjaGVyKGVsZW0sIGNvbnRleHQsIHhtbCkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH07XFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIGVsZW1lbnRNYXRjaGVyKG1hdGNoZXJzKSB7XFxuXFx0XFx0XFx0cmV0dXJuIG1hdGNoZXJzLmxlbmd0aCA+IDEgPyBmdW5jdGlvbiAoZWxlbSwgY29udGV4dCwgeG1sKSB7XFxuXFx0XFx0XFx0XFx0dmFyIGkgPSBtYXRjaGVycy5sZW5ndGg7XFxuXFx0XFx0XFx0XFx0d2hpbGUgKGktLSkge1xcblxcdFxcdFxcdFxcdFxcdGlmICghbWF0Y2hlcnNbaV0oZWxlbSwgY29udGV4dCwgeG1sKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdFxcdH0gOiBtYXRjaGVyc1swXTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gbXVsdGlwbGVDb250ZXh0cyhzZWxlY3RvciwgY29udGV4dHMsIHJlc3VsdHMpIHtcXG5cXHRcXHRcXHR2YXIgaSA9IDAsXFxuXFx0XFx0XFx0ICAgIGxlbiA9IGNvbnRleHRzLmxlbmd0aDtcXG5cXHRcXHRcXHRmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0U2l6emxlKHNlbGVjdG9yLCBjb250ZXh0c1tpXSwgcmVzdWx0cyk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiByZXN1bHRzO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiBjb25kZW5zZSh1bm1hdGNoZWQsIG1hcCwgZmlsdGVyLCBjb250ZXh0LCB4bWwpIHtcXG5cXHRcXHRcXHR2YXIgZWxlbSxcXG5cXHRcXHRcXHQgICAgbmV3VW5tYXRjaGVkID0gW10sXFxuXFx0XFx0XFx0ICAgIGkgPSAwLFxcblxcdFxcdFxcdCAgICBsZW4gPSB1bm1hdGNoZWQubGVuZ3RoLFxcblxcdFxcdFxcdCAgICBtYXBwZWQgPSBtYXAgIT0gbnVsbDtcXG5cXG5cXHRcXHRcXHRmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGVsZW0gPSB1bm1hdGNoZWRbaV0pIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIWZpbHRlciB8fCBmaWx0ZXIoZWxlbSwgY29udGV4dCwgeG1sKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdG5ld1VubWF0Y2hlZC5wdXNoKGVsZW0pO1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChtYXBwZWQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRtYXAucHVzaChpKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIG5ld1VubWF0Y2hlZDtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gc2V0TWF0Y2hlcihwcmVGaWx0ZXIsIHNlbGVjdG9yLCBtYXRjaGVyLCBwb3N0RmlsdGVyLCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IpIHtcXG5cXHRcXHRcXHRpZiAocG9zdEZpbHRlciAmJiAhcG9zdEZpbHRlcltleHBhbmRvXSkge1xcblxcdFxcdFxcdFxcdHBvc3RGaWx0ZXIgPSBzZXRNYXRjaGVyKHBvc3RGaWx0ZXIpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAocG9zdEZpbmRlciAmJiAhcG9zdEZpbmRlcltleHBhbmRvXSkge1xcblxcdFxcdFxcdFxcdHBvc3RGaW5kZXIgPSBzZXRNYXRjaGVyKHBvc3RGaW5kZXIsIHBvc3RTZWxlY3Rvcik7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24gKHNlZWQsIHJlc3VsdHMsIGNvbnRleHQsIHhtbCkge1xcblxcdFxcdFxcdFxcdHZhciB0ZW1wLFxcblxcdFxcdFxcdFxcdCAgICBpLFxcblxcdFxcdFxcdFxcdCAgICBlbGVtLFxcblxcdFxcdFxcdFxcdCAgICBwcmVNYXAgPSBbXSxcXG5cXHRcXHRcXHRcXHQgICAgcG9zdE1hcCA9IFtdLFxcblxcdFxcdFxcdFxcdCAgICBwcmVleGlzdGluZyA9IHJlc3VsdHMubGVuZ3RoLFxcblxcblxcblxcdFxcdFxcdFxcdC8vIEdldCBpbml0aWFsIGVsZW1lbnRzIGZyb20gc2VlZCBvciBjb250ZXh0XFxuXFx0XFx0XFx0XFx0ZWxlbXMgPSBzZWVkIHx8IG11bHRpcGxlQ29udGV4dHMoc2VsZWN0b3IgfHwgXFxcIipcXFwiLCBjb250ZXh0Lm5vZGVUeXBlID8gW2NvbnRleHRdIDogY29udGV4dCwgW10pLFxcblxcblxcblxcdFxcdFxcdFxcdC8vIFByZWZpbHRlciB0byBnZXQgbWF0Y2hlciBpbnB1dCwgcHJlc2VydmluZyBhIG1hcCBmb3Igc2VlZC1yZXN1bHRzIHN5bmNocm9uaXphdGlvblxcblxcdFxcdFxcdFxcdG1hdGNoZXJJbiA9IHByZUZpbHRlciAmJiAoc2VlZCB8fCAhc2VsZWN0b3IpID8gY29uZGVuc2UoZWxlbXMsIHByZU1hcCwgcHJlRmlsdGVyLCBjb250ZXh0LCB4bWwpIDogZWxlbXMsXFxuXFx0XFx0XFx0XFx0ICAgIG1hdGNoZXJPdXQgPSBtYXRjaGVyID9cXG5cXHRcXHRcXHRcXHQvLyBJZiB3ZSBoYXZlIGEgcG9zdEZpbmRlciwgb3IgZmlsdGVyZWQgc2VlZCwgb3Igbm9uLXNlZWQgcG9zdEZpbHRlciBvciBwcmVleGlzdGluZyByZXN1bHRzLFxcblxcdFxcdFxcdFxcdHBvc3RGaW5kZXIgfHwgKHNlZWQgPyBwcmVGaWx0ZXIgOiBwcmVleGlzdGluZyB8fCBwb3N0RmlsdGVyKSA/XFxuXFxuXFx0XFx0XFx0XFx0Ly8gLi4uaW50ZXJtZWRpYXRlIHByb2Nlc3NpbmcgaXMgbmVjZXNzYXJ5XFxuXFx0XFx0XFx0XFx0W10gOlxcblxcblxcdFxcdFxcdFxcdC8vIC4uLm90aGVyd2lzZSB1c2UgcmVzdWx0cyBkaXJlY3RseVxcblxcdFxcdFxcdFxcdHJlc3VsdHMgOiBtYXRjaGVySW47XFxuXFxuXFx0XFx0XFx0XFx0Ly8gRmluZCBwcmltYXJ5IG1hdGNoZXNcXG5cXHRcXHRcXHRcXHRpZiAobWF0Y2hlcikge1xcblxcdFxcdFxcdFxcdFxcdG1hdGNoZXIobWF0Y2hlckluLCBtYXRjaGVyT3V0LCBjb250ZXh0LCB4bWwpO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBBcHBseSBwb3N0RmlsdGVyXFxuXFx0XFx0XFx0XFx0aWYgKHBvc3RGaWx0ZXIpIHtcXG5cXHRcXHRcXHRcXHRcXHR0ZW1wID0gY29uZGVuc2UobWF0Y2hlck91dCwgcG9zdE1hcCk7XFxuXFx0XFx0XFx0XFx0XFx0cG9zdEZpbHRlcih0ZW1wLCBbXSwgY29udGV4dCwgeG1sKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBVbi1tYXRjaCBmYWlsaW5nIGVsZW1lbnRzIGJ5IG1vdmluZyB0aGVtIGJhY2sgdG8gbWF0Y2hlckluXFxuXFx0XFx0XFx0XFx0XFx0aSA9IHRlbXAubGVuZ3RoO1xcblxcdFxcdFxcdFxcdFxcdHdoaWxlIChpLS0pIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoZWxlbSA9IHRlbXBbaV0pIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRtYXRjaGVyT3V0W3Bvc3RNYXBbaV1dID0gIShtYXRjaGVySW5bcG9zdE1hcFtpXV0gPSBlbGVtKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAoc2VlZCkge1xcblxcdFxcdFxcdFxcdFxcdGlmIChwb3N0RmluZGVyIHx8IHByZUZpbHRlcikge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChwb3N0RmluZGVyKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gR2V0IHRoZSBmaW5hbCBtYXRjaGVyT3V0IGJ5IGNvbmRlbnNpbmcgdGhpcyBpbnRlcm1lZGlhdGUgaW50byBwb3N0RmluZGVyIGNvbnRleHRzXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGVtcCA9IFtdO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR3aGlsZSAoaS0tKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKGVsZW0gPSBtYXRjaGVyT3V0W2ldKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gUmVzdG9yZSBtYXRjaGVySW4gc2luY2UgZWxlbSBpcyBub3QgeWV0IGEgZmluYWwgbWF0Y2hcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0ZW1wLnB1c2gobWF0Y2hlckluW2ldID0gZWxlbSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRwb3N0RmluZGVyKG51bGwsIG1hdGNoZXJPdXQgPSBbXSwgdGVtcCwgeG1sKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gTW92ZSBtYXRjaGVkIGVsZW1lbnRzIGZyb20gc2VlZCB0byByZXN1bHRzIHRvIGtlZXAgdGhlbSBzeW5jaHJvbml6ZWRcXG5cXHRcXHRcXHRcXHRcXHRcXHRpID0gbWF0Y2hlck91dC5sZW5ndGg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0d2hpbGUgKGktLSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICgoZWxlbSA9IG1hdGNoZXJPdXRbaV0pICYmICh0ZW1wID0gcG9zdEZpbmRlciA/IGluZGV4T2Yoc2VlZCwgZWxlbSkgOiBwcmVNYXBbaV0pID4gLTEpIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRzZWVkW3RlbXBdID0gIShyZXN1bHRzW3RlbXBdID0gZWxlbSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gQWRkIGVsZW1lbnRzIHRvIHJlc3VsdHMsIHRocm91Z2ggcG9zdEZpbmRlciBpZiBkZWZpbmVkXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRtYXRjaGVyT3V0ID0gY29uZGVuc2UobWF0Y2hlck91dCA9PT0gcmVzdWx0cyA/IG1hdGNoZXJPdXQuc3BsaWNlKHByZWV4aXN0aW5nLCBtYXRjaGVyT3V0Lmxlbmd0aCkgOiBtYXRjaGVyT3V0KTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAocG9zdEZpbmRlcikge1xcblxcdFxcdFxcdFxcdFxcdFxcdHBvc3RGaW5kZXIobnVsbCwgcmVzdWx0cywgbWF0Y2hlck91dCwgeG1sKTtcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdHB1c2guYXBwbHkocmVzdWx0cywgbWF0Y2hlck91dCk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gbWF0Y2hlckZyb21Ub2tlbnModG9rZW5zKSB7XFxuXFx0XFx0XFx0dmFyIGNoZWNrQ29udGV4dCxcXG5cXHRcXHRcXHQgICAgbWF0Y2hlcixcXG5cXHRcXHRcXHQgICAgaixcXG5cXHRcXHRcXHQgICAgbGVuID0gdG9rZW5zLmxlbmd0aCxcXG5cXHRcXHRcXHQgICAgbGVhZGluZ1JlbGF0aXZlID0gRXhwci5yZWxhdGl2ZVt0b2tlbnNbMF0udHlwZV0sXFxuXFx0XFx0XFx0ICAgIGltcGxpY2l0UmVsYXRpdmUgPSBsZWFkaW5nUmVsYXRpdmUgfHwgRXhwci5yZWxhdGl2ZVtcXFwiIFxcXCJdLFxcblxcdFxcdFxcdCAgICBpID0gbGVhZGluZ1JlbGF0aXZlID8gMSA6IDAsXFxuXFxuXFxuXFx0XFx0XFx0Ly8gVGhlIGZvdW5kYXRpb25hbCBtYXRjaGVyIGVuc3VyZXMgdGhhdCBlbGVtZW50cyBhcmUgcmVhY2hhYmxlIGZyb20gdG9wLWxldmVsIGNvbnRleHQocylcXG5cXHRcXHRcXHRtYXRjaENvbnRleHQgPSBhZGRDb21iaW5hdG9yKGZ1bmN0aW9uIChlbGVtKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGVsZW0gPT09IGNoZWNrQ29udGV4dDtcXG5cXHRcXHRcXHR9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlKSxcXG5cXHRcXHRcXHQgICAgbWF0Y2hBbnlDb250ZXh0ID0gYWRkQ29tYmluYXRvcihmdW5jdGlvbiAoZWxlbSkge1xcblxcdFxcdFxcdFxcdHJldHVybiBpbmRleE9mKGNoZWNrQ29udGV4dCwgZWxlbSkgPiAtMTtcXG5cXHRcXHRcXHR9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlKSxcXG5cXHRcXHRcXHQgICAgbWF0Y2hlcnMgPSBbZnVuY3Rpb24gKGVsZW0sIGNvbnRleHQsIHhtbCkge1xcblxcdFxcdFxcdFxcdHZhciByZXQgPSAhbGVhZGluZ1JlbGF0aXZlICYmICh4bWwgfHwgY29udGV4dCAhPT0gb3V0ZXJtb3N0Q29udGV4dCkgfHwgKChjaGVja0NvbnRleHQgPSBjb250ZXh0KS5ub2RlVHlwZSA/IG1hdGNoQ29udGV4dChlbGVtLCBjb250ZXh0LCB4bWwpIDogbWF0Y2hBbnlDb250ZXh0KGVsZW0sIGNvbnRleHQsIHhtbCkpO1xcblxcdFxcdFxcdFxcdC8vIEF2b2lkIGhhbmdpbmcgb250byBlbGVtZW50IChpc3N1ZSAjMjk5KVxcblxcdFxcdFxcdFxcdGNoZWNrQ29udGV4dCA9IG51bGw7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHJldDtcXG5cXHRcXHRcXHR9XTtcXG5cXG5cXHRcXHRcXHRmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0aWYgKG1hdGNoZXIgPSBFeHByLnJlbGF0aXZlW3Rva2Vuc1tpXS50eXBlXSkge1xcblxcdFxcdFxcdFxcdFxcdG1hdGNoZXJzID0gW2FkZENvbWJpbmF0b3IoZWxlbWVudE1hdGNoZXIobWF0Y2hlcnMpLCBtYXRjaGVyKV07XFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRtYXRjaGVyID0gRXhwci5maWx0ZXJbdG9rZW5zW2ldLnR5cGVdLmFwcGx5KG51bGwsIHRva2Vuc1tpXS5tYXRjaGVzKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBSZXR1cm4gc3BlY2lhbCB1cG9uIHNlZWluZyBhIHBvc2l0aW9uYWwgbWF0Y2hlclxcblxcdFxcdFxcdFxcdFxcdGlmIChtYXRjaGVyW2V4cGFuZG9dKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gRmluZCB0aGUgbmV4dCByZWxhdGl2ZSBvcGVyYXRvciAoaWYgYW55KSBmb3IgcHJvcGVyIGhhbmRsaW5nXFxuXFx0XFx0XFx0XFx0XFx0XFx0aiA9ICsraTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRmb3IgKDsgaiA8IGxlbjsgaisrKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKEV4cHIucmVsYXRpdmVbdG9rZW5zW2pdLnR5cGVdKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gc2V0TWF0Y2hlcihpID4gMSAmJiBlbGVtZW50TWF0Y2hlcihtYXRjaGVycyksIGkgPiAxICYmIHRvU2VsZWN0b3IoXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gSWYgdGhlIHByZWNlZGluZyB0b2tlbiB3YXMgYSBkZXNjZW5kYW50IGNvbWJpbmF0b3IsIGluc2VydCBhbiBpbXBsaWNpdCBhbnktZWxlbWVudCBgKmBcXG5cXHRcXHRcXHRcXHRcXHRcXHR0b2tlbnMuc2xpY2UoMCwgaSAtIDEpLmNvbmNhdCh7IHZhbHVlOiB0b2tlbnNbaSAtIDJdLnR5cGUgPT09IFxcXCIgXFxcIiA/IFxcXCIqXFxcIiA6IFxcXCJcXFwiIH0pKS5yZXBsYWNlKHJ0cmltLCBcXFwiJDFcXFwiKSwgbWF0Y2hlciwgaSA8IGogJiYgbWF0Y2hlckZyb21Ub2tlbnModG9rZW5zLnNsaWNlKGksIGopKSwgaiA8IGxlbiAmJiBtYXRjaGVyRnJvbVRva2Vucyh0b2tlbnMgPSB0b2tlbnMuc2xpY2UoaikpLCBqIDwgbGVuICYmIHRvU2VsZWN0b3IodG9rZW5zKSk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdG1hdGNoZXJzLnB1c2gobWF0Y2hlcik7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gZWxlbWVudE1hdGNoZXIobWF0Y2hlcnMpO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycykge1xcblxcdFxcdFxcdHZhciBieVNldCA9IHNldE1hdGNoZXJzLmxlbmd0aCA+IDAsXFxuXFx0XFx0XFx0ICAgIGJ5RWxlbWVudCA9IGVsZW1lbnRNYXRjaGVycy5sZW5ndGggPiAwLFxcblxcdFxcdFxcdCAgICBzdXBlck1hdGNoZXIgPSBmdW5jdGlvbiBzdXBlck1hdGNoZXIoc2VlZCwgY29udGV4dCwgeG1sLCByZXN1bHRzLCBvdXRlcm1vc3QpIHtcXG5cXHRcXHRcXHRcXHR2YXIgZWxlbSxcXG5cXHRcXHRcXHRcXHQgICAgaixcXG5cXHRcXHRcXHRcXHQgICAgbWF0Y2hlcixcXG5cXHRcXHRcXHRcXHQgICAgbWF0Y2hlZENvdW50ID0gMCxcXG5cXHRcXHRcXHRcXHQgICAgaSA9IFxcXCIwXFxcIixcXG5cXHRcXHRcXHRcXHQgICAgdW5tYXRjaGVkID0gc2VlZCAmJiBbXSxcXG5cXHRcXHRcXHRcXHQgICAgc2V0TWF0Y2hlZCA9IFtdLFxcblxcdFxcdFxcdFxcdCAgICBjb250ZXh0QmFja3VwID0gb3V0ZXJtb3N0Q29udGV4dCxcXG5cXG5cXHRcXHRcXHRcXHQvLyBXZSBtdXN0IGFsd2F5cyBoYXZlIGVpdGhlciBzZWVkIGVsZW1lbnRzIG9yIG91dGVybW9zdCBjb250ZXh0XFxuXFx0XFx0XFx0XFx0ZWxlbXMgPSBzZWVkIHx8IGJ5RWxlbWVudCAmJiBFeHByLmZpbmRbXFxcIlRBR1xcXCJdKFxcXCIqXFxcIiwgb3V0ZXJtb3N0KSxcXG5cXG5cXHRcXHRcXHRcXHQvLyBVc2UgaW50ZWdlciBkaXJydW5zIGlmZiB0aGlzIGlzIHRoZSBvdXRlcm1vc3QgbWF0Y2hlclxcblxcdFxcdFxcdFxcdGRpcnJ1bnNVbmlxdWUgPSBkaXJydW5zICs9IGNvbnRleHRCYWNrdXAgPT0gbnVsbCA/IDEgOiBNYXRoLnJhbmRvbSgpIHx8IDAuMSxcXG5cXHRcXHRcXHRcXHQgICAgbGVuID0gZWxlbXMubGVuZ3RoO1xcblxcblxcdFxcdFxcdFxcdGlmIChvdXRlcm1vc3QpIHtcXG5cXHRcXHRcXHRcXHRcXHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dCAhPT0gZG9jdW1lbnQgJiYgY29udGV4dDtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQWRkIGVsZW1lbnRzIHBhc3NpbmcgZWxlbWVudE1hdGNoZXJzIGRpcmVjdGx5IHRvIHJlc3VsdHNcXG5cXHRcXHRcXHRcXHQvLyBLZWVwIGBpYCBhIHN0cmluZyBpZiB0aGVyZSBhcmUgbm8gZWxlbWVudHMgc28gYG1hdGNoZWRDb3VudGAgd2lsbCBiZSBcXFwiMDBcXFwiIGJlbG93XFxuXFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogSUU8OSwgU2FmYXJpXFxuXFx0XFx0XFx0XFx0Ly8gVG9sZXJhdGUgTm9kZUxpc3QgcHJvcGVydGllcyAoSUU6IFxcXCJsZW5ndGhcXFwiOyBTYWZhcmk6IDxudW1iZXI+KSBtYXRjaGluZyBlbGVtZW50cyBieSBpZFxcblxcdFxcdFxcdFxcdGZvciAoOyBpICE9PSBsZW4gJiYgKGVsZW0gPSBlbGVtc1tpXSkgIT0gbnVsbDsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGJ5RWxlbWVudCAmJiBlbGVtKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aiA9IDA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0d2hpbGUgKG1hdGNoZXIgPSBlbGVtZW50TWF0Y2hlcnNbaisrXSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChtYXRjaGVyKGVsZW0sIGNvbnRleHQsIHhtbCkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXN1bHRzLnB1c2goZWxlbSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAob3V0ZXJtb3N0KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBUcmFjayB1bm1hdGNoZWQgZWxlbWVudHMgZm9yIHNldCBmaWx0ZXJzXFxuXFx0XFx0XFx0XFx0XFx0aWYgKGJ5U2V0KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gVGhleSB3aWxsIGhhdmUgZ29uZSB0aHJvdWdoIGFsbCBwb3NzaWJsZSBtYXRjaGVyc1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChlbGVtID0gIW1hdGNoZXIgJiYgZWxlbSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG1hdGNoZWRDb3VudC0tO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBMZW5ndGhlbiB0aGUgYXJyYXkgZm9yIGV2ZXJ5IGVsZW1lbnQsIG1hdGNoZWQgb3Igbm90XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKHNlZWQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR1bm1hdGNoZWQucHVzaChlbGVtKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBBcHBseSBzZXQgZmlsdGVycyB0byB1bm1hdGNoZWQgZWxlbWVudHNcXG5cXHRcXHRcXHRcXHRtYXRjaGVkQ291bnQgKz0gaTtcXG5cXHRcXHRcXHRcXHRpZiAoYnlTZXQgJiYgaSAhPT0gbWF0Y2hlZENvdW50KSB7XFxuXFx0XFx0XFx0XFx0XFx0aiA9IDA7XFxuXFx0XFx0XFx0XFx0XFx0d2hpbGUgKG1hdGNoZXIgPSBzZXRNYXRjaGVyc1tqKytdKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0bWF0Y2hlcih1bm1hdGNoZWQsIHNldE1hdGNoZWQsIGNvbnRleHQsIHhtbCk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdGlmIChzZWVkKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gUmVpbnRlZ3JhdGUgZWxlbWVudCBtYXRjaGVzIHRvIGVsaW1pbmF0ZSB0aGUgbmVlZCBmb3Igc29ydGluZ1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChtYXRjaGVkQ291bnQgPiAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0d2hpbGUgKGktLSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICghKHVubWF0Y2hlZFtpXSB8fCBzZXRNYXRjaGVkW2ldKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHNldE1hdGNoZWRbaV0gPSBwb3AuY2FsbChyZXN1bHRzKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBEaXNjYXJkIGluZGV4IHBsYWNlaG9sZGVyIHZhbHVlcyB0byBnZXQgb25seSBhY3R1YWwgbWF0Y2hlc1xcblxcdFxcdFxcdFxcdFxcdFxcdHNldE1hdGNoZWQgPSBjb25kZW5zZShzZXRNYXRjaGVkKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gQWRkIG1hdGNoZXMgdG8gcmVzdWx0c1xcblxcdFxcdFxcdFxcdFxcdHB1c2guYXBwbHkocmVzdWx0cywgc2V0TWF0Y2hlZCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gU2VlZGxlc3Mgc2V0IG1hdGNoZXMgc3VjY2VlZGluZyBtdWx0aXBsZSBzdWNjZXNzZnVsIG1hdGNoZXJzIHN0aXB1bGF0ZSBzb3J0aW5nXFxuXFx0XFx0XFx0XFx0XFx0aWYgKG91dGVybW9zdCAmJiAhc2VlZCAmJiBzZXRNYXRjaGVkLmxlbmd0aCA+IDAgJiYgbWF0Y2hlZENvdW50ICsgc2V0TWF0Y2hlcnMubGVuZ3RoID4gMSkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFNpenpsZS51bmlxdWVTb3J0KHJlc3VsdHMpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gT3ZlcnJpZGUgbWFuaXB1bGF0aW9uIG9mIGdsb2JhbHMgYnkgbmVzdGVkIG1hdGNoZXJzXFxuXFx0XFx0XFx0XFx0aWYgKG91dGVybW9zdCkge1xcblxcdFxcdFxcdFxcdFxcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xcblxcdFxcdFxcdFxcdFxcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0QmFja3VwO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdW5tYXRjaGVkO1xcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGJ5U2V0ID8gbWFya0Z1bmN0aW9uKHN1cGVyTWF0Y2hlcikgOiBzdXBlck1hdGNoZXI7XFxuXFx0XFx0fVxcblxcblxcdFxcdGNvbXBpbGUgPSBTaXp6bGUuY29tcGlsZSA9IGZ1bmN0aW9uIChzZWxlY3RvciwgbWF0Y2ggLyogSW50ZXJuYWwgVXNlIE9ubHkgKi8pIHtcXG5cXHRcXHRcXHR2YXIgaSxcXG5cXHRcXHRcXHQgICAgc2V0TWF0Y2hlcnMgPSBbXSxcXG5cXHRcXHRcXHQgICAgZWxlbWVudE1hdGNoZXJzID0gW10sXFxuXFx0XFx0XFx0ICAgIGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGVbc2VsZWN0b3IgKyBcXFwiIFxcXCJdO1xcblxcblxcdFxcdFxcdGlmICghY2FjaGVkKSB7XFxuXFx0XFx0XFx0XFx0Ly8gR2VuZXJhdGUgYSBmdW5jdGlvbiBvZiByZWN1cnNpdmUgZnVuY3Rpb25zIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2hlY2sgZWFjaCBlbGVtZW50XFxuXFx0XFx0XFx0XFx0aWYgKCFtYXRjaCkge1xcblxcdFxcdFxcdFxcdFxcdG1hdGNoID0gdG9rZW5pemUoc2VsZWN0b3IpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRpID0gbWF0Y2gubGVuZ3RoO1xcblxcdFxcdFxcdFxcdHdoaWxlIChpLS0pIHtcXG5cXHRcXHRcXHRcXHRcXHRjYWNoZWQgPSBtYXRjaGVyRnJvbVRva2VucyhtYXRjaFtpXSk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGNhY2hlZFtleHBhbmRvXSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHNldE1hdGNoZXJzLnB1c2goY2FjaGVkKTtcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdGVsZW1lbnRNYXRjaGVycy5wdXNoKGNhY2hlZCk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBDYWNoZSB0aGUgY29tcGlsZWQgZnVuY3Rpb25cXG5cXHRcXHRcXHRcXHRjYWNoZWQgPSBjb21waWxlckNhY2hlKHNlbGVjdG9yLCBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycykpO1xcblxcblxcdFxcdFxcdFxcdC8vIFNhdmUgc2VsZWN0b3IgYW5kIHRva2VuaXphdGlvblxcblxcdFxcdFxcdFxcdGNhY2hlZC5zZWxlY3RvciA9IHNlbGVjdG9yO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gY2FjaGVkO1xcblxcdFxcdH07XFxuXFxuXFx0XFx0LyoqXFxuICAgKiBBIGxvdy1sZXZlbCBzZWxlY3Rpb24gZnVuY3Rpb24gdGhhdCB3b3JrcyB3aXRoIFNpenpsZSdzIGNvbXBpbGVkXFxuICAgKiAgc2VsZWN0b3IgZnVuY3Rpb25zXFxuICAgKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gc2VsZWN0b3IgQSBzZWxlY3RvciBvciBhIHByZS1jb21waWxlZFxcbiAgICogIHNlbGVjdG9yIGZ1bmN0aW9uIGJ1aWx0IHdpdGggU2l6emxlLmNvbXBpbGVcXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gY29udGV4dFxcbiAgICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdHNdXFxuICAgKiBAcGFyYW0ge0FycmF5fSBbc2VlZF0gQSBzZXQgb2YgZWxlbWVudHMgdG8gbWF0Y2ggYWdhaW5zdFxcbiAgICovXFxuXFx0XFx0c2VsZWN0ID0gU2l6emxlLnNlbGVjdCA9IGZ1bmN0aW9uIChzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCkge1xcblxcdFxcdFxcdHZhciBpLFxcblxcdFxcdFxcdCAgICB0b2tlbnMsXFxuXFx0XFx0XFx0ICAgIHRva2VuLFxcblxcdFxcdFxcdCAgICB0eXBlLFxcblxcdFxcdFxcdCAgICBmaW5kLFxcblxcdFxcdFxcdCAgICBjb21waWxlZCA9IHR5cGVvZiBzZWxlY3RvciA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBzZWxlY3RvcixcXG5cXHRcXHRcXHQgICAgbWF0Y2ggPSAhc2VlZCAmJiB0b2tlbml6ZShzZWxlY3RvciA9IGNvbXBpbGVkLnNlbGVjdG9yIHx8IHNlbGVjdG9yKTtcXG5cXG5cXHRcXHRcXHRyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcXG5cXG5cXHRcXHRcXHQvLyBUcnkgdG8gbWluaW1pemUgb3BlcmF0aW9ucyBpZiB0aGVyZSBpcyBubyBzZWVkIGFuZCBvbmx5IG9uZSBncm91cFxcblxcdFxcdFxcdGlmIChtYXRjaC5sZW5ndGggPT09IDEpIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBUYWtlIGEgc2hvcnRjdXQgYW5kIHNldCB0aGUgY29udGV4dCBpZiB0aGUgcm9vdCBzZWxlY3RvciBpcyBhbiBJRFxcblxcdFxcdFxcdFxcdHRva2VucyA9IG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UoMCk7XFxuXFx0XFx0XFx0XFx0aWYgKHRva2Vucy5sZW5ndGggPiAyICYmICh0b2tlbiA9IHRva2Vuc1swXSkudHlwZSA9PT0gXFxcIklEXFxcIiAmJiBzdXBwb3J0LmdldEJ5SWQgJiYgY29udGV4dC5ub2RlVHlwZSA9PT0gOSAmJiBkb2N1bWVudElzSFRNTCAmJiBFeHByLnJlbGF0aXZlW3Rva2Vuc1sxXS50eXBlXSkge1xcblxcblxcdFxcdFxcdFxcdFxcdGNvbnRleHQgPSAoRXhwci5maW5kW1xcXCJJRFxcXCJdKHRva2VuLm1hdGNoZXNbMF0ucmVwbGFjZShydW5lc2NhcGUsIGZ1bmVzY2FwZSksIGNvbnRleHQpIHx8IFtdKVswXTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIWNvbnRleHQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gcmVzdWx0cztcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBQcmVjb21waWxlZCBtYXRjaGVycyB3aWxsIHN0aWxsIHZlcmlmeSBhbmNlc3RyeSwgc28gc3RlcCB1cCBhIGxldmVsXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIGlmIChjb21waWxlZCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGNvbnRleHQgPSBjb250ZXh0LnBhcmVudE5vZGU7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdHNlbGVjdG9yID0gc2VsZWN0b3Iuc2xpY2UodG9rZW5zLnNoaWZ0KCkudmFsdWUubGVuZ3RoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gRmV0Y2ggYSBzZWVkIHNldCBmb3IgcmlnaHQtdG8tbGVmdCBtYXRjaGluZ1xcblxcdFxcdFxcdFxcdGkgPSBtYXRjaEV4cHJbXFxcIm5lZWRzQ29udGV4dFxcXCJdLnRlc3Qoc2VsZWN0b3IpID8gMCA6IHRva2Vucy5sZW5ndGg7XFxuXFx0XFx0XFx0XFx0d2hpbGUgKGktLSkge1xcblxcdFxcdFxcdFxcdFxcdHRva2VuID0gdG9rZW5zW2ldO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIEFib3J0IGlmIHdlIGhpdCBhIGNvbWJpbmF0b3JcXG5cXHRcXHRcXHRcXHRcXHRpZiAoRXhwci5yZWxhdGl2ZVt0eXBlID0gdG9rZW4udHlwZV0pIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGZpbmQgPSBFeHByLmZpbmRbdHlwZV0pIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBTZWFyY2gsIGV4cGFuZGluZyBjb250ZXh0IGZvciBsZWFkaW5nIHNpYmxpbmcgY29tYmluYXRvcnNcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoc2VlZCA9IGZpbmQodG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKSwgcnNpYmxpbmcudGVzdCh0b2tlbnNbMF0udHlwZSkgJiYgdGVzdENvbnRleHQoY29udGV4dC5wYXJlbnROb2RlKSB8fCBjb250ZXh0KSkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIElmIHNlZWQgaXMgZW1wdHkgb3Igbm8gdG9rZW5zIHJlbWFpbiwgd2UgY2FuIHJldHVybiBlYXJseVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRva2Vucy5zcGxpY2UoaSwgMSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c2VsZWN0b3IgPSBzZWVkLmxlbmd0aCAmJiB0b1NlbGVjdG9yKHRva2Vucyk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCFzZWxlY3Rvcikge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHB1c2guYXBwbHkocmVzdWx0cywgc2VlZCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHJlc3VsdHM7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBDb21waWxlIGFuZCBleGVjdXRlIGEgZmlsdGVyaW5nIGZ1bmN0aW9uIGlmIG9uZSBpcyBub3QgcHJvdmlkZWRcXG5cXHRcXHRcXHQvLyBQcm92aWRlIGBtYXRjaGAgdG8gYXZvaWQgcmV0b2tlbml6YXRpb24gaWYgd2UgbW9kaWZpZWQgdGhlIHNlbGVjdG9yIGFib3ZlXFxuXFx0XFx0XFx0KGNvbXBpbGVkIHx8IGNvbXBpbGUoc2VsZWN0b3IsIG1hdGNoKSkoc2VlZCwgY29udGV4dCwgIWRvY3VtZW50SXNIVE1MLCByZXN1bHRzLCByc2libGluZy50ZXN0KHNlbGVjdG9yKSAmJiB0ZXN0Q29udGV4dChjb250ZXh0LnBhcmVudE5vZGUpIHx8IGNvbnRleHQpO1xcblxcdFxcdFxcdHJldHVybiByZXN1bHRzO1xcblxcdFxcdH07XFxuXFxuXFx0XFx0Ly8gT25lLXRpbWUgYXNzaWdubWVudHNcXG5cXG5cXHRcXHQvLyBTb3J0IHN0YWJpbGl0eVxcblxcdFxcdHN1cHBvcnQuc29ydFN0YWJsZSA9IGV4cGFuZG8uc3BsaXQoXFxcIlxcXCIpLnNvcnQoc29ydE9yZGVyKS5qb2luKFxcXCJcXFwiKSA9PT0gZXhwYW5kbztcXG5cXG5cXHRcXHQvLyBTdXBwb3J0OiBDaHJvbWUgMTQtMzUrXFxuXFx0XFx0Ly8gQWx3YXlzIGFzc3VtZSBkdXBsaWNhdGVzIGlmIHRoZXkgYXJlbid0IHBhc3NlZCB0byB0aGUgY29tcGFyaXNvbiBmdW5jdGlvblxcblxcdFxcdHN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcyA9ICEhaGFzRHVwbGljYXRlO1xcblxcblxcdFxcdC8vIEluaXRpYWxpemUgYWdhaW5zdCB0aGUgZGVmYXVsdCBkb2N1bWVudFxcblxcdFxcdHNldERvY3VtZW50KCk7XFxuXFxuXFx0XFx0Ly8gU3VwcG9ydDogV2Via2l0PDUzNy4zMiAtIFNhZmFyaSA2LjAuMy9DaHJvbWUgMjUgKGZpeGVkIGluIENocm9tZSAyNylcXG5cXHRcXHQvLyBEZXRhY2hlZCBub2RlcyBjb25mb3VuZGluZ2x5IGZvbGxvdyAqZWFjaCBvdGhlcipcXG5cXHRcXHRzdXBwb3J0LnNvcnREZXRhY2hlZCA9IGFzc2VydChmdW5jdGlvbiAoZGl2MSkge1xcblxcdFxcdFxcdC8vIFNob3VsZCByZXR1cm4gMSwgYnV0IHJldHVybnMgNCAoZm9sbG93aW5nKVxcblxcdFxcdFxcdHJldHVybiBkaXYxLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXFxcImRpdlxcXCIpKSAmIDE7XFxuXFx0XFx0fSk7XFxuXFxuXFx0XFx0Ly8gU3VwcG9ydDogSUU8OFxcblxcdFxcdC8vIFByZXZlbnQgYXR0cmlidXRlL3Byb3BlcnR5IFxcXCJpbnRlcnBvbGF0aW9uXFxcIlxcblxcdFxcdC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzNjQyOSUyOFZTLjg1JTI5LmFzcHhcXG5cXHRcXHRpZiAoIWFzc2VydChmdW5jdGlvbiAoZGl2KSB7XFxuXFx0XFx0XFx0ZGl2LmlubmVySFRNTCA9IFxcXCI8YSBocmVmPScjJz48L2E+XFxcIjtcXG5cXHRcXHRcXHRyZXR1cm4gZGl2LmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKFxcXCJocmVmXFxcIikgPT09IFxcXCIjXFxcIjtcXG5cXHRcXHR9KSkge1xcblxcdFxcdFxcdGFkZEhhbmRsZShcXFwidHlwZXxocmVmfGhlaWdodHx3aWR0aFxcXCIsIGZ1bmN0aW9uIChlbGVtLCBuYW1lLCBpc1hNTCkge1xcblxcdFxcdFxcdFxcdGlmICghaXNYTUwpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUobmFtZSwgbmFtZS50b0xvd2VyQ2FzZSgpID09PSBcXFwidHlwZVxcXCIgPyAxIDogMik7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0pO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBTdXBwb3J0OiBJRTw5XFxuXFx0XFx0Ly8gVXNlIGRlZmF1bHRWYWx1ZSBpbiBwbGFjZSBvZiBnZXRBdHRyaWJ1dGUoXFxcInZhbHVlXFxcIilcXG5cXHRcXHRpZiAoIXN1cHBvcnQuYXR0cmlidXRlcyB8fCAhYXNzZXJ0KGZ1bmN0aW9uIChkaXYpIHtcXG5cXHRcXHRcXHRkaXYuaW5uZXJIVE1MID0gXFxcIjxpbnB1dC8+XFxcIjtcXG5cXHRcXHRcXHRkaXYuZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoXFxcInZhbHVlXFxcIiwgXFxcIlxcXCIpO1xcblxcdFxcdFxcdHJldHVybiBkaXYuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoXFxcInZhbHVlXFxcIikgPT09IFxcXCJcXFwiO1xcblxcdFxcdH0pKSB7XFxuXFx0XFx0XFx0YWRkSGFuZGxlKFxcXCJ2YWx1ZVxcXCIsIGZ1bmN0aW9uIChlbGVtLCBuYW1lLCBpc1hNTCkge1xcblxcdFxcdFxcdFxcdGlmICghaXNYTUwgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcXFwiaW5wdXRcXFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGVsZW0uZGVmYXVsdFZhbHVlO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gU3VwcG9ydDogSUU8OVxcblxcdFxcdC8vIFVzZSBnZXRBdHRyaWJ1dGVOb2RlIHRvIGZldGNoIGJvb2xlYW5zIHdoZW4gZ2V0QXR0cmlidXRlIGxpZXNcXG5cXHRcXHRpZiAoIWFzc2VydChmdW5jdGlvbiAoZGl2KSB7XFxuXFx0XFx0XFx0cmV0dXJuIGRpdi5nZXRBdHRyaWJ1dGUoXFxcImRpc2FibGVkXFxcIikgPT0gbnVsbDtcXG5cXHRcXHR9KSkge1xcblxcdFxcdFxcdGFkZEhhbmRsZShib29sZWFucywgZnVuY3Rpb24gKGVsZW0sIG5hbWUsIGlzWE1MKSB7XFxuXFx0XFx0XFx0XFx0dmFyIHZhbDtcXG5cXHRcXHRcXHRcXHRpZiAoIWlzWE1MKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGVsZW1bbmFtZV0gPT09IHRydWUgPyBuYW1lLnRvTG93ZXJDYXNlKCkgOiAodmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKG5hbWUpKSAmJiB2YWwuc3BlY2lmaWVkID8gdmFsLnZhbHVlIDogbnVsbDtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiBTaXp6bGU7XFxuXFx0fSh3aW5kb3cpO1xcblxcblxcdGpRdWVyeS5maW5kID0gU2l6emxlO1xcblxcdGpRdWVyeS5leHByID0gU2l6emxlLnNlbGVjdG9ycztcXG5cXHRqUXVlcnkuZXhwcltcXFwiOlxcXCJdID0galF1ZXJ5LmV4cHIucHNldWRvcztcXG5cXHRqUXVlcnkudW5pcXVlID0gU2l6emxlLnVuaXF1ZVNvcnQ7XFxuXFx0alF1ZXJ5LnRleHQgPSBTaXp6bGUuZ2V0VGV4dDtcXG5cXHRqUXVlcnkuaXNYTUxEb2MgPSBTaXp6bGUuaXNYTUw7XFxuXFx0alF1ZXJ5LmNvbnRhaW5zID0gU2l6emxlLmNvbnRhaW5zO1xcblxcblxcdHZhciBybmVlZHNDb250ZXh0ID0galF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0O1xcblxcblxcdHZhciByc2luZ2xlVGFnID0gL148KFxcXFx3KylcXFxccypcXFxcLz8+KD86PFxcXFwvXFxcXDE+fCkkLztcXG5cXG5cXHR2YXIgcmlzU2ltcGxlID0gL14uW146I1xcXFxbXFxcXC4sXSokLztcXG5cXG5cXHQvLyBJbXBsZW1lbnQgdGhlIGlkZW50aWNhbCBmdW5jdGlvbmFsaXR5IGZvciBmaWx0ZXIgYW5kIG5vdFxcblxcdGZ1bmN0aW9uIHdpbm5vdyhlbGVtZW50cywgcXVhbGlmaWVyLCBub3QpIHtcXG5cXHRcXHRpZiAoalF1ZXJ5LmlzRnVuY3Rpb24ocXVhbGlmaWVyKSkge1xcblxcdFxcdFxcdHJldHVybiBqUXVlcnkuZ3JlcChlbGVtZW50cywgZnVuY3Rpb24gKGVsZW0sIGkpIHtcXG5cXHRcXHRcXHRcXHQvKiBqc2hpbnQgLVcwMTggKi9cXG5cXHRcXHRcXHRcXHRyZXR1cm4gISFxdWFsaWZpZXIuY2FsbChlbGVtLCBpLCBlbGVtKSAhPT0gbm90O1xcblxcdFxcdFxcdH0pO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAocXVhbGlmaWVyLm5vZGVUeXBlKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGpRdWVyeS5ncmVwKGVsZW1lbnRzLCBmdW5jdGlvbiAoZWxlbSkge1xcblxcdFxcdFxcdFxcdHJldHVybiBlbGVtID09PSBxdWFsaWZpZXIgIT09IG5vdDtcXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKHR5cGVvZiBxdWFsaWZpZXIgPT09IFxcXCJzdHJpbmdcXFwiKSB7XFxuXFx0XFx0XFx0aWYgKHJpc1NpbXBsZS50ZXN0KHF1YWxpZmllcikpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4galF1ZXJ5LmZpbHRlcihxdWFsaWZpZXIsIGVsZW1lbnRzLCBub3QpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRxdWFsaWZpZXIgPSBqUXVlcnkuZmlsdGVyKHF1YWxpZmllciwgZWxlbWVudHMpO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4galF1ZXJ5LmdyZXAoZWxlbWVudHMsIGZ1bmN0aW9uIChlbGVtKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGluZGV4T2YuY2FsbChxdWFsaWZpZXIsIGVsZW0pID49IDAgIT09IG5vdDtcXG5cXHRcXHR9KTtcXG5cXHR9XFxuXFxuXFx0alF1ZXJ5LmZpbHRlciA9IGZ1bmN0aW9uIChleHByLCBlbGVtcywgbm90KSB7XFxuXFx0XFx0dmFyIGVsZW0gPSBlbGVtc1swXTtcXG5cXG5cXHRcXHRpZiAobm90KSB7XFxuXFx0XFx0XFx0ZXhwciA9IFxcXCI6bm90KFxcXCIgKyBleHByICsgXFxcIilcXFwiO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gZWxlbXMubGVuZ3RoID09PSAxICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgPyBqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoZWxlbSwgZXhwcikgPyBbZWxlbV0gOiBbXSA6IGpRdWVyeS5maW5kLm1hdGNoZXMoZXhwciwgalF1ZXJ5LmdyZXAoZWxlbXMsIGZ1bmN0aW9uIChlbGVtKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGVsZW0ubm9kZVR5cGUgPT09IDE7XFxuXFx0XFx0fSkpO1xcblxcdH07XFxuXFxuXFx0alF1ZXJ5LmZuLmV4dGVuZCh7XFxuXFx0XFx0ZmluZDogZnVuY3Rpb24gZmluZChzZWxlY3Rvcikge1xcblxcdFxcdFxcdHZhciBpLFxcblxcdFxcdFxcdCAgICBsZW4gPSB0aGlzLmxlbmd0aCxcXG5cXHRcXHRcXHQgICAgcmV0ID0gW10sXFxuXFx0XFx0XFx0ICAgIHNlbGYgPSB0aGlzO1xcblxcblxcdFxcdFxcdGlmICh0eXBlb2Ygc2VsZWN0b3IgIT09IFxcXCJzdHJpbmdcXFwiKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKGpRdWVyeShzZWxlY3RvcikuZmlsdGVyKGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoalF1ZXJ5LmNvbnRhaW5zKHNlbGZbaV0sIHRoaXMpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9KSk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xcblxcdFxcdFxcdFxcdGpRdWVyeS5maW5kKHNlbGVjdG9yLCBzZWxmW2ldLCByZXQpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBOZWVkZWQgYmVjYXVzZSAkKCBzZWxlY3RvciwgY29udGV4dCApIGJlY29tZXMgJCggY29udGV4dCApLmZpbmQoIHNlbGVjdG9yIClcXG5cXHRcXHRcXHRyZXQgPSB0aGlzLnB1c2hTdGFjayhsZW4gPiAxID8galF1ZXJ5LnVuaXF1ZShyZXQpIDogcmV0KTtcXG5cXHRcXHRcXHRyZXQuc2VsZWN0b3IgPSB0aGlzLnNlbGVjdG9yID8gdGhpcy5zZWxlY3RvciArIFxcXCIgXFxcIiArIHNlbGVjdG9yIDogc2VsZWN0b3I7XFxuXFx0XFx0XFx0cmV0dXJuIHJldDtcXG5cXHRcXHR9LFxcblxcdFxcdGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKHNlbGVjdG9yKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKHdpbm5vdyh0aGlzLCBzZWxlY3RvciB8fCBbXSwgZmFsc2UpKTtcXG5cXHRcXHR9LFxcblxcdFxcdG5vdDogZnVuY3Rpb24gbm90KHNlbGVjdG9yKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKHdpbm5vdyh0aGlzLCBzZWxlY3RvciB8fCBbXSwgdHJ1ZSkpO1xcblxcdFxcdH0sXFxuXFx0XFx0aXM6IGZ1bmN0aW9uIGlzKHNlbGVjdG9yKSB7XFxuXFx0XFx0XFx0cmV0dXJuICEhd2lubm93KHRoaXMsXFxuXFxuXFx0XFx0XFx0Ly8gSWYgdGhpcyBpcyBhIHBvc2l0aW9uYWwvcmVsYXRpdmUgc2VsZWN0b3IsIGNoZWNrIG1lbWJlcnNoaXAgaW4gdGhlIHJldHVybmVkIHNldFxcblxcdFxcdFxcdC8vIHNvICQoXFxcInA6Zmlyc3RcXFwiKS5pcyhcXFwicDpsYXN0XFxcIikgd29uJ3QgcmV0dXJuIHRydWUgZm9yIGEgZG9jIHdpdGggdHdvIFxcXCJwXFxcIi5cXG5cXHRcXHRcXHR0eXBlb2Ygc2VsZWN0b3IgPT09IFxcXCJzdHJpbmdcXFwiICYmIHJuZWVkc0NvbnRleHQudGVzdChzZWxlY3RvcikgPyBqUXVlcnkoc2VsZWN0b3IpIDogc2VsZWN0b3IgfHwgW10sIGZhbHNlKS5sZW5ndGg7XFxuXFx0XFx0fVxcblxcdH0pO1xcblxcblxcdC8vIEluaXRpYWxpemUgYSBqUXVlcnkgb2JqZWN0XFxuXFxuXFxuXFx0Ly8gQSBjZW50cmFsIHJlZmVyZW5jZSB0byB0aGUgcm9vdCBqUXVlcnkoZG9jdW1lbnQpXFxuXFx0dmFyIHJvb3RqUXVlcnksXFxuXFxuXFxuXFx0Ly8gQSBzaW1wbGUgd2F5IHRvIGNoZWNrIGZvciBIVE1MIHN0cmluZ3NcXG5cXHQvLyBQcmlvcml0aXplICNpZCBvdmVyIDx0YWc+IHRvIGF2b2lkIFhTUyB2aWEgbG9jYXRpb24uaGFzaCAoIzk1MjEpXFxuXFx0Ly8gU3RyaWN0IEhUTUwgcmVjb2duaXRpb24gKCMxMTI5MDogbXVzdCBzdGFydCB3aXRoIDwpXFxuXFx0cnF1aWNrRXhwciA9IC9eKD86XFxcXHMqKDxbXFxcXHdcXFxcV10rPilbXj5dKnwjKFtcXFxcdy1dKikpJC8sXFxuXFx0ICAgIGluaXQgPSBqUXVlcnkuZm4uaW5pdCA9IGZ1bmN0aW9uIChzZWxlY3RvciwgY29udGV4dCkge1xcblxcdFxcdHZhciBtYXRjaCwgZWxlbTtcXG5cXG5cXHRcXHQvLyBIQU5ETEU6ICQoXFxcIlxcXCIpLCAkKG51bGwpLCAkKHVuZGVmaW5lZCksICQoZmFsc2UpXFxuXFx0XFx0aWYgKCFzZWxlY3Rvcikge1xcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBIYW5kbGUgSFRNTCBzdHJpbmdzXFxuXFx0XFx0aWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gXFxcInN0cmluZ1xcXCIpIHtcXG5cXHRcXHRcXHRpZiAoc2VsZWN0b3JbMF0gPT09IFxcXCI8XFxcIiAmJiBzZWxlY3RvcltzZWxlY3Rvci5sZW5ndGggLSAxXSA9PT0gXFxcIj5cXFwiICYmIHNlbGVjdG9yLmxlbmd0aCA+PSAzKSB7XFxuXFx0XFx0XFx0XFx0Ly8gQXNzdW1lIHRoYXQgc3RyaW5ncyB0aGF0IHN0YXJ0IGFuZCBlbmQgd2l0aCA8PiBhcmUgSFRNTCBhbmQgc2tpcCB0aGUgcmVnZXggY2hlY2tcXG5cXHRcXHRcXHRcXHRtYXRjaCA9IFtudWxsLCBzZWxlY3RvciwgbnVsbF07XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyhzZWxlY3Rvcik7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIE1hdGNoIGh0bWwgb3IgbWFrZSBzdXJlIG5vIGNvbnRleHQgaXMgc3BlY2lmaWVkIGZvciAjaWRcXG5cXHRcXHRcXHRpZiAobWF0Y2ggJiYgKG1hdGNoWzFdIHx8ICFjb250ZXh0KSkge1xcblxcblxcdFxcdFxcdFxcdC8vIEhBTkRMRTogJChodG1sKSAtPiAkKGFycmF5KVxcblxcdFxcdFxcdFxcdGlmIChtYXRjaFsxXSkge1xcblxcdFxcdFxcdFxcdFxcdGNvbnRleHQgPSBjb250ZXh0IGluc3RhbmNlb2YgalF1ZXJ5ID8gY29udGV4dFswXSA6IGNvbnRleHQ7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gT3B0aW9uIHRvIHJ1biBzY3JpcHRzIGlzIHRydWUgZm9yIGJhY2stY29tcGF0XFxuXFx0XFx0XFx0XFx0XFx0Ly8gSW50ZW50aW9uYWxseSBsZXQgdGhlIGVycm9yIGJlIHRocm93biBpZiBwYXJzZUhUTUwgaXMgbm90IHByZXNlbnRcXG5cXHRcXHRcXHRcXHRcXHRqUXVlcnkubWVyZ2UodGhpcywgalF1ZXJ5LnBhcnNlSFRNTChtYXRjaFsxXSwgY29udGV4dCAmJiBjb250ZXh0Lm5vZGVUeXBlID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBkb2N1bWVudCwgdHJ1ZSkpO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIEhBTkRMRTogJChodG1sLCBwcm9wcylcXG5cXHRcXHRcXHRcXHRcXHRpZiAocnNpbmdsZVRhZy50ZXN0KG1hdGNoWzFdKSAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdChjb250ZXh0KSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGZvciAobWF0Y2ggaW4gY29udGV4dCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIFByb3BlcnRpZXMgb2YgY29udGV4dCBhcmUgY2FsbGVkIGFzIG1ldGhvZHMgaWYgcG9zc2libGVcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoalF1ZXJ5LmlzRnVuY3Rpb24odGhpc1ttYXRjaF0pKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpc1ttYXRjaF0oY29udGV4dFttYXRjaF0pO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIC4uLmFuZCBvdGhlcndpc2Ugc2V0IGFzIGF0dHJpYnV0ZXNcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuYXR0cihtYXRjaCwgY29udGV4dFttYXRjaF0pO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIEhBTkRMRTogJCgjaWQpXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRlbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobWF0Y2hbMl0pO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IEJsYWNrYmVycnkgNC42XFxuXFx0XFx0XFx0XFx0XFx0Ly8gZ0VCSUQgcmV0dXJucyBub2RlcyBubyBsb25nZXIgaW4gdGhlIGRvY3VtZW50ICgjNjk2MylcXG5cXHRcXHRcXHRcXHRcXHRpZiAoZWxlbSAmJiBlbGVtLnBhcmVudE5vZGUpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBJbmplY3QgdGhlIGVsZW1lbnQgZGlyZWN0bHkgaW50byB0aGUgalF1ZXJ5IG9iamVjdFxcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMubGVuZ3RoID0gMTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzWzBdID0gZWxlbTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5jb250ZXh0ID0gZG9jdW1lbnQ7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBIQU5ETEU6ICQoZXhwciwgJCguLi4pKVxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIWNvbnRleHQgfHwgY29udGV4dC5qcXVlcnkpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gKGNvbnRleHQgfHwgcm9vdGpRdWVyeSkuZmluZChzZWxlY3Rvcik7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSEFORExFOiAkKGV4cHIsIGNvbnRleHQpXFxuXFx0XFx0XFx0XFx0Ly8gKHdoaWNoIGlzIGp1c3QgZXF1aXZhbGVudCB0bzogJChjb250ZXh0KS5maW5kKGV4cHIpXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvcihjb250ZXh0KS5maW5kKHNlbGVjdG9yKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gSEFORExFOiAkKERPTUVsZW1lbnQpXFxuXFx0XFx0fSBlbHNlIGlmIChzZWxlY3Rvci5ub2RlVHlwZSkge1xcblxcdFxcdFxcdHRoaXMuY29udGV4dCA9IHRoaXNbMF0gPSBzZWxlY3RvcjtcXG5cXHRcXHRcXHR0aGlzLmxlbmd0aCA9IDE7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0XFx0Ly8gSEFORExFOiAkKGZ1bmN0aW9uKVxcblxcdFxcdFxcdC8vIFNob3J0Y3V0IGZvciBkb2N1bWVudCByZWFkeVxcblxcdFxcdH0gZWxzZSBpZiAoalF1ZXJ5LmlzRnVuY3Rpb24oc2VsZWN0b3IpKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHR5cGVvZiByb290alF1ZXJ5LnJlYWR5ICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IHJvb3RqUXVlcnkucmVhZHkoc2VsZWN0b3IpIDpcXG5cXHRcXHRcXHQvLyBFeGVjdXRlIGltbWVkaWF0ZWx5IGlmIHJlYWR5IGlzIG5vdCBwcmVzZW50XFxuXFx0XFx0XFx0c2VsZWN0b3IoalF1ZXJ5KTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKHNlbGVjdG9yLnNlbGVjdG9yICE9PSB1bmRlZmluZWQpIHtcXG5cXHRcXHRcXHR0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3Iuc2VsZWN0b3I7XFxuXFx0XFx0XFx0dGhpcy5jb250ZXh0ID0gc2VsZWN0b3IuY29udGV4dDtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIGpRdWVyeS5tYWtlQXJyYXkoc2VsZWN0b3IsIHRoaXMpO1xcblxcdH07XFxuXFxuXFx0Ly8gR2l2ZSB0aGUgaW5pdCBmdW5jdGlvbiB0aGUgalF1ZXJ5IHByb3RvdHlwZSBmb3IgbGF0ZXIgaW5zdGFudGlhdGlvblxcblxcdGluaXQucHJvdG90eXBlID0galF1ZXJ5LmZuO1xcblxcblxcdC8vIEluaXRpYWxpemUgY2VudHJhbCByZWZlcmVuY2VcXG5cXHRyb290alF1ZXJ5ID0galF1ZXJ5KGRvY3VtZW50KTtcXG5cXG5cXHR2YXIgcnBhcmVudHNwcmV2ID0gL14oPzpwYXJlbnRzfHByZXYoPzpVbnRpbHxBbGwpKS8sXFxuXFxuXFx0Ly8gTWV0aG9kcyBndWFyYW50ZWVkIHRvIHByb2R1Y2UgYSB1bmlxdWUgc2V0IHdoZW4gc3RhcnRpbmcgZnJvbSBhIHVuaXF1ZSBzZXRcXG5cXHRndWFyYW50ZWVkVW5pcXVlID0ge1xcblxcdFxcdGNoaWxkcmVuOiB0cnVlLFxcblxcdFxcdGNvbnRlbnRzOiB0cnVlLFxcblxcdFxcdG5leHQ6IHRydWUsXFxuXFx0XFx0cHJldjogdHJ1ZVxcblxcdH07XFxuXFxuXFx0alF1ZXJ5LmV4dGVuZCh7XFxuXFx0XFx0ZGlyOiBmdW5jdGlvbiBkaXIoZWxlbSwgX2RpciwgdW50aWwpIHtcXG5cXHRcXHRcXHR2YXIgbWF0Y2hlZCA9IFtdLFxcblxcdFxcdFxcdCAgICB0cnVuY2F0ZSA9IHVudGlsICE9PSB1bmRlZmluZWQ7XFxuXFxuXFx0XFx0XFx0d2hpbGUgKChlbGVtID0gZWxlbVtfZGlyXSkgJiYgZWxlbS5ub2RlVHlwZSAhPT0gOSkge1xcblxcdFxcdFxcdFxcdGlmIChlbGVtLm5vZGVUeXBlID09PSAxKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHRydW5jYXRlICYmIGpRdWVyeShlbGVtKS5pcyh1bnRpbCkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0bWF0Y2hlZC5wdXNoKGVsZW0pO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIG1hdGNoZWQ7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzaWJsaW5nOiBmdW5jdGlvbiBzaWJsaW5nKG4sIGVsZW0pIHtcXG5cXHRcXHRcXHR2YXIgbWF0Y2hlZCA9IFtdO1xcblxcblxcdFxcdFxcdGZvciAoOyBuOyBuID0gbi5uZXh0U2libGluZykge1xcblxcdFxcdFxcdFxcdGlmIChuLm5vZGVUeXBlID09PSAxICYmIG4gIT09IGVsZW0pIHtcXG5cXHRcXHRcXHRcXHRcXHRtYXRjaGVkLnB1c2gobik7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gbWF0Y2hlZDtcXG5cXHRcXHR9XFxuXFx0fSk7XFxuXFxuXFx0alF1ZXJ5LmZuLmV4dGVuZCh7XFxuXFx0XFx0aGFzOiBmdW5jdGlvbiBoYXModGFyZ2V0KSB7XFxuXFx0XFx0XFx0dmFyIHRhcmdldHMgPSBqUXVlcnkodGFyZ2V0LCB0aGlzKSxcXG5cXHRcXHRcXHQgICAgbCA9IHRhcmdldHMubGVuZ3RoO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0dmFyIGkgPSAwO1xcblxcdFxcdFxcdFxcdGZvciAoOyBpIDwgbDsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGpRdWVyeS5jb250YWlucyh0aGlzLCB0YXJnZXRzW2ldKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjbG9zZXN0OiBmdW5jdGlvbiBjbG9zZXN0KHNlbGVjdG9ycywgY29udGV4dCkge1xcblxcdFxcdFxcdHZhciBjdXIsXFxuXFx0XFx0XFx0ICAgIGkgPSAwLFxcblxcdFxcdFxcdCAgICBsID0gdGhpcy5sZW5ndGgsXFxuXFx0XFx0XFx0ICAgIG1hdGNoZWQgPSBbXSxcXG5cXHRcXHRcXHQgICAgcG9zID0gcm5lZWRzQ29udGV4dC50ZXN0KHNlbGVjdG9ycykgfHwgdHlwZW9mIHNlbGVjdG9ycyAhPT0gXFxcInN0cmluZ1xcXCIgPyBqUXVlcnkoc2VsZWN0b3JzLCBjb250ZXh0IHx8IHRoaXMuY29udGV4dCkgOiAwO1xcblxcblxcdFxcdFxcdGZvciAoOyBpIDwgbDsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0Zm9yIChjdXIgPSB0aGlzW2ldOyBjdXIgJiYgY3VyICE9PSBjb250ZXh0OyBjdXIgPSBjdXIucGFyZW50Tm9kZSkge1xcblxcdFxcdFxcdFxcdFxcdC8vIEFsd2F5cyBza2lwIGRvY3VtZW50IGZyYWdtZW50c1xcblxcdFxcdFxcdFxcdFxcdGlmIChjdXIubm9kZVR5cGUgPCAxMSAmJiAocG9zID8gcG9zLmluZGV4KGN1cikgPiAtMSA6XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gRG9uJ3QgcGFzcyBub24tZWxlbWVudHMgdG8gU2l6emxlXFxuXFx0XFx0XFx0XFx0XFx0Y3VyLm5vZGVUeXBlID09PSAxICYmIGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvcihjdXIsIHNlbGVjdG9ycykpKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0bWF0Y2hlZC5wdXNoKGN1cik7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKG1hdGNoZWQubGVuZ3RoID4gMSA/IGpRdWVyeS51bmlxdWUobWF0Y2hlZCkgOiBtYXRjaGVkKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdC8vIERldGVybWluZSB0aGUgcG9zaXRpb24gb2YgYW4gZWxlbWVudCB3aXRoaW4gdGhlIHNldFxcblxcdFxcdGluZGV4OiBmdW5jdGlvbiBpbmRleChlbGVtKSB7XFxuXFxuXFx0XFx0XFx0Ly8gTm8gYXJndW1lbnQsIHJldHVybiBpbmRleCBpbiBwYXJlbnRcXG5cXHRcXHRcXHRpZiAoIWVsZW0pIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpc1swXSAmJiB0aGlzWzBdLnBhcmVudE5vZGUgPyB0aGlzLmZpcnN0KCkucHJldkFsbCgpLmxlbmd0aCA6IC0xO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBJbmRleCBpbiBzZWxlY3RvclxcblxcdFxcdFxcdGlmICh0eXBlb2YgZWxlbSA9PT0gXFxcInN0cmluZ1xcXCIpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gaW5kZXhPZi5jYWxsKGpRdWVyeShlbGVtKSwgdGhpc1swXSk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIExvY2F0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGRlc2lyZWQgZWxlbWVudFxcblxcdFxcdFxcdHJldHVybiBpbmRleE9mLmNhbGwodGhpcyxcXG5cXG5cXHRcXHRcXHQvLyBJZiBpdCByZWNlaXZlcyBhIGpRdWVyeSBvYmplY3QsIHRoZSBmaXJzdCBlbGVtZW50IGlzIHVzZWRcXG5cXHRcXHRcXHRlbGVtLmpxdWVyeSA/IGVsZW1bMF0gOiBlbGVtKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdGFkZDogZnVuY3Rpb24gYWRkKHNlbGVjdG9yLCBjb250ZXh0KSB7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKGpRdWVyeS51bmlxdWUoalF1ZXJ5Lm1lcmdlKHRoaXMuZ2V0KCksIGpRdWVyeShzZWxlY3RvciwgY29udGV4dCkpKSk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRhZGRCYWNrOiBmdW5jdGlvbiBhZGRCYWNrKHNlbGVjdG9yKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuYWRkKHNlbGVjdG9yID09IG51bGwgPyB0aGlzLnByZXZPYmplY3QgOiB0aGlzLnByZXZPYmplY3QuZmlsdGVyKHNlbGVjdG9yKSk7XFxuXFx0XFx0fVxcblxcdH0pO1xcblxcblxcdGZ1bmN0aW9uIHNpYmxpbmcoY3VyLCBkaXIpIHtcXG5cXHRcXHR3aGlsZSAoKGN1ciA9IGN1cltkaXJdKSAmJiBjdXIubm9kZVR5cGUgIT09IDEpIHt9XFxuXFx0XFx0cmV0dXJuIGN1cjtcXG5cXHR9XFxuXFxuXFx0alF1ZXJ5LmVhY2goe1xcblxcdFxcdHBhcmVudDogZnVuY3Rpb24gcGFyZW50KGVsZW0pIHtcXG5cXHRcXHRcXHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xcblxcdFxcdFxcdHJldHVybiBwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlICE9PSAxMSA/IHBhcmVudCA6IG51bGw7XFxuXFx0XFx0fSxcXG5cXHRcXHRwYXJlbnRzOiBmdW5jdGlvbiBwYXJlbnRzKGVsZW0pIHtcXG5cXHRcXHRcXHRyZXR1cm4galF1ZXJ5LmRpcihlbGVtLCBcXFwicGFyZW50Tm9kZVxcXCIpO1xcblxcdFxcdH0sXFxuXFx0XFx0cGFyZW50c1VudGlsOiBmdW5jdGlvbiBwYXJlbnRzVW50aWwoZWxlbSwgaSwgdW50aWwpIHtcXG5cXHRcXHRcXHRyZXR1cm4galF1ZXJ5LmRpcihlbGVtLCBcXFwicGFyZW50Tm9kZVxcXCIsIHVudGlsKTtcXG5cXHRcXHR9LFxcblxcdFxcdG5leHQ6IGZ1bmN0aW9uIG5leHQoZWxlbSkge1xcblxcdFxcdFxcdHJldHVybiBzaWJsaW5nKGVsZW0sIFxcXCJuZXh0U2libGluZ1xcXCIpO1xcblxcdFxcdH0sXFxuXFx0XFx0cHJldjogZnVuY3Rpb24gcHJldihlbGVtKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHNpYmxpbmcoZWxlbSwgXFxcInByZXZpb3VzU2libGluZ1xcXCIpO1xcblxcdFxcdH0sXFxuXFx0XFx0bmV4dEFsbDogZnVuY3Rpb24gbmV4dEFsbChlbGVtKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGpRdWVyeS5kaXIoZWxlbSwgXFxcIm5leHRTaWJsaW5nXFxcIik7XFxuXFx0XFx0fSxcXG5cXHRcXHRwcmV2QWxsOiBmdW5jdGlvbiBwcmV2QWxsKGVsZW0pIHtcXG5cXHRcXHRcXHRyZXR1cm4galF1ZXJ5LmRpcihlbGVtLCBcXFwicHJldmlvdXNTaWJsaW5nXFxcIik7XFxuXFx0XFx0fSxcXG5cXHRcXHRuZXh0VW50aWw6IGZ1bmN0aW9uIG5leHRVbnRpbChlbGVtLCBpLCB1bnRpbCkge1xcblxcdFxcdFxcdHJldHVybiBqUXVlcnkuZGlyKGVsZW0sIFxcXCJuZXh0U2libGluZ1xcXCIsIHVudGlsKTtcXG5cXHRcXHR9LFxcblxcdFxcdHByZXZVbnRpbDogZnVuY3Rpb24gcHJldlVudGlsKGVsZW0sIGksIHVudGlsKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGpRdWVyeS5kaXIoZWxlbSwgXFxcInByZXZpb3VzU2libGluZ1xcXCIsIHVudGlsKTtcXG5cXHRcXHR9LFxcblxcdFxcdHNpYmxpbmdzOiBmdW5jdGlvbiBzaWJsaW5ncyhlbGVtKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGpRdWVyeS5zaWJsaW5nKChlbGVtLnBhcmVudE5vZGUgfHwge30pLmZpcnN0Q2hpbGQsIGVsZW0pO1xcblxcdFxcdH0sXFxuXFx0XFx0Y2hpbGRyZW46IGZ1bmN0aW9uIGNoaWxkcmVuKGVsZW0pIHtcXG5cXHRcXHRcXHRyZXR1cm4galF1ZXJ5LnNpYmxpbmcoZWxlbS5maXJzdENoaWxkKTtcXG5cXHRcXHR9LFxcblxcdFxcdGNvbnRlbnRzOiBmdW5jdGlvbiBjb250ZW50cyhlbGVtKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGVsZW0uY29udGVudERvY3VtZW50IHx8IGpRdWVyeS5tZXJnZShbXSwgZWxlbS5jaGlsZE5vZGVzKTtcXG5cXHRcXHR9XFxuXFx0fSwgZnVuY3Rpb24gKG5hbWUsIGZuKSB7XFxuXFx0XFx0alF1ZXJ5LmZuW25hbWVdID0gZnVuY3Rpb24gKHVudGlsLCBzZWxlY3Rvcikge1xcblxcdFxcdFxcdHZhciBtYXRjaGVkID0galF1ZXJ5Lm1hcCh0aGlzLCBmbiwgdW50aWwpO1xcblxcblxcdFxcdFxcdGlmIChuYW1lLnNsaWNlKC01KSAhPT0gXFxcIlVudGlsXFxcIikge1xcblxcdFxcdFxcdFxcdHNlbGVjdG9yID0gdW50aWw7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmIChzZWxlY3RvciAmJiB0eXBlb2Ygc2VsZWN0b3IgPT09IFxcXCJzdHJpbmdcXFwiKSB7XFxuXFx0XFx0XFx0XFx0bWF0Y2hlZCA9IGpRdWVyeS5maWx0ZXIoc2VsZWN0b3IsIG1hdGNoZWQpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAodGhpcy5sZW5ndGggPiAxKSB7XFxuXFx0XFx0XFx0XFx0Ly8gUmVtb3ZlIGR1cGxpY2F0ZXNcXG5cXHRcXHRcXHRcXHRpZiAoIWd1YXJhbnRlZWRVbmlxdWVbbmFtZV0pIHtcXG5cXHRcXHRcXHRcXHRcXHRqUXVlcnkudW5pcXVlKG1hdGNoZWQpO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBSZXZlcnNlIG9yZGVyIGZvciBwYXJlbnRzKiBhbmQgcHJldi1kZXJpdmF0aXZlc1xcblxcdFxcdFxcdFxcdGlmIChycGFyZW50c3ByZXYudGVzdChuYW1lKSkge1xcblxcdFxcdFxcdFxcdFxcdG1hdGNoZWQucmV2ZXJzZSgpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKG1hdGNoZWQpO1xcblxcdFxcdH07XFxuXFx0fSk7XFxuXFx0dmFyIHJub3R3aGl0ZSA9IC9cXFxcUysvZztcXG5cXG5cXHQvLyBTdHJpbmcgdG8gT2JqZWN0IG9wdGlvbnMgZm9ybWF0IGNhY2hlXFxuXFx0dmFyIG9wdGlvbnNDYWNoZSA9IHt9O1xcblxcblxcdC8vIENvbnZlcnQgU3RyaW5nLWZvcm1hdHRlZCBvcHRpb25zIGludG8gT2JqZWN0LWZvcm1hdHRlZCBvbmVzIGFuZCBzdG9yZSBpbiBjYWNoZVxcblxcdGZ1bmN0aW9uIGNyZWF0ZU9wdGlvbnMob3B0aW9ucykge1xcblxcdFxcdHZhciBvYmplY3QgPSBvcHRpb25zQ2FjaGVbb3B0aW9uc10gPSB7fTtcXG5cXHRcXHRqUXVlcnkuZWFjaChvcHRpb25zLm1hdGNoKHJub3R3aGl0ZSkgfHwgW10sIGZ1bmN0aW9uIChfLCBmbGFnKSB7XFxuXFx0XFx0XFx0b2JqZWN0W2ZsYWddID0gdHJ1ZTtcXG5cXHRcXHR9KTtcXG5cXHRcXHRyZXR1cm4gb2JqZWN0O1xcblxcdH1cXG5cXG5cXHQvKlxcbiAgKiBDcmVhdGUgYSBjYWxsYmFjayBsaXN0IHVzaW5nIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVyczpcXG4gICpcXG4gICpcXHRvcHRpb25zOiBhbiBvcHRpb25hbCBsaXN0IG9mIHNwYWNlLXNlcGFyYXRlZCBvcHRpb25zIHRoYXQgd2lsbCBjaGFuZ2UgaG93XFxuICAqXFx0XFx0XFx0dGhlIGNhbGxiYWNrIGxpc3QgYmVoYXZlcyBvciBhIG1vcmUgdHJhZGl0aW9uYWwgb3B0aW9uIG9iamVjdFxcbiAgKlxcbiAgKiBCeSBkZWZhdWx0IGEgY2FsbGJhY2sgbGlzdCB3aWxsIGFjdCBsaWtlIGFuIGV2ZW50IGNhbGxiYWNrIGxpc3QgYW5kIGNhbiBiZVxcbiAgKiBcXFwiZmlyZWRcXFwiIG11bHRpcGxlIHRpbWVzLlxcbiAgKlxcbiAgKiBQb3NzaWJsZSBvcHRpb25zOlxcbiAgKlxcbiAgKlxcdG9uY2U6XFx0XFx0XFx0d2lsbCBlbnN1cmUgdGhlIGNhbGxiYWNrIGxpc3QgY2FuIG9ubHkgYmUgZmlyZWQgb25jZSAobGlrZSBhIERlZmVycmVkKVxcbiAgKlxcbiAgKlxcdG1lbW9yeTpcXHRcXHRcXHR3aWxsIGtlZXAgdHJhY2sgb2YgcHJldmlvdXMgdmFsdWVzIGFuZCB3aWxsIGNhbGwgYW55IGNhbGxiYWNrIGFkZGVkXFxuICAqXFx0XFx0XFx0XFx0XFx0YWZ0ZXIgdGhlIGxpc3QgaGFzIGJlZW4gZmlyZWQgcmlnaHQgYXdheSB3aXRoIHRoZSBsYXRlc3QgXFxcIm1lbW9yaXplZFxcXCJcXG4gICpcXHRcXHRcXHRcXHRcXHR2YWx1ZXMgKGxpa2UgYSBEZWZlcnJlZClcXG4gICpcXG4gICpcXHR1bmlxdWU6XFx0XFx0XFx0d2lsbCBlbnN1cmUgYSBjYWxsYmFjayBjYW4gb25seSBiZSBhZGRlZCBvbmNlIChubyBkdXBsaWNhdGUgaW4gdGhlIGxpc3QpXFxuICAqXFxuICAqXFx0c3RvcE9uRmFsc2U6XFx0aW50ZXJydXB0IGNhbGxpbmdzIHdoZW4gYSBjYWxsYmFjayByZXR1cm5zIGZhbHNlXFxuICAqXFxuICAqL1xcblxcdGpRdWVyeS5DYWxsYmFja3MgPSBmdW5jdGlvbiAob3B0aW9ucykge1xcblxcblxcdFxcdC8vIENvbnZlcnQgb3B0aW9ucyBmcm9tIFN0cmluZy1mb3JtYXR0ZWQgdG8gT2JqZWN0LWZvcm1hdHRlZCBpZiBuZWVkZWRcXG5cXHRcXHQvLyAod2UgY2hlY2sgaW4gY2FjaGUgZmlyc3QpXFxuXFx0XFx0b3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zID09PSBcXFwic3RyaW5nXFxcIiA/IG9wdGlvbnNDYWNoZVtvcHRpb25zXSB8fCBjcmVhdGVPcHRpb25zKG9wdGlvbnMpIDogalF1ZXJ5LmV4dGVuZCh7fSwgb3B0aW9ucyk7XFxuXFxuXFx0XFx0dmFyIC8vIExhc3QgZmlyZSB2YWx1ZSAoZm9yIG5vbi1mb3JnZXR0YWJsZSBsaXN0cylcXG5cXHRcXHRtZW1vcnksXFxuXFxuXFx0XFx0Ly8gRmxhZyB0byBrbm93IGlmIGxpc3Qgd2FzIGFscmVhZHkgZmlyZWRcXG5cXHRcXHRfZmlyZWQsXFxuXFxuXFx0XFx0Ly8gRmxhZyB0byBrbm93IGlmIGxpc3QgaXMgY3VycmVudGx5IGZpcmluZ1xcblxcdFxcdGZpcmluZyxcXG5cXG5cXHRcXHQvLyBGaXJzdCBjYWxsYmFjayB0byBmaXJlICh1c2VkIGludGVybmFsbHkgYnkgYWRkIGFuZCBmaXJlV2l0aClcXG5cXHRcXHRmaXJpbmdTdGFydCxcXG5cXG5cXHRcXHQvLyBFbmQgb2YgdGhlIGxvb3Agd2hlbiBmaXJpbmdcXG5cXHRcXHRmaXJpbmdMZW5ndGgsXFxuXFxuXFx0XFx0Ly8gSW5kZXggb2YgY3VycmVudGx5IGZpcmluZyBjYWxsYmFjayAobW9kaWZpZWQgYnkgcmVtb3ZlIGlmIG5lZWRlZClcXG5cXHRcXHRmaXJpbmdJbmRleCxcXG5cXG5cXHRcXHQvLyBBY3R1YWwgY2FsbGJhY2sgbGlzdFxcblxcdFxcdGxpc3QgPSBbXSxcXG5cXG5cXHRcXHQvLyBTdGFjayBvZiBmaXJlIGNhbGxzIGZvciByZXBlYXRhYmxlIGxpc3RzXFxuXFx0XFx0c3RhY2sgPSAhb3B0aW9ucy5vbmNlICYmIFtdLFxcblxcblxcdFxcdC8vIEZpcmUgY2FsbGJhY2tzXFxuXFx0XFx0ZmlyZSA9IGZ1bmN0aW9uIGZpcmUoZGF0YSkge1xcblxcdFxcdFxcdG1lbW9yeSA9IG9wdGlvbnMubWVtb3J5ICYmIGRhdGE7XFxuXFx0XFx0XFx0X2ZpcmVkID0gdHJ1ZTtcXG5cXHRcXHRcXHRmaXJpbmdJbmRleCA9IGZpcmluZ1N0YXJ0IHx8IDA7XFxuXFx0XFx0XFx0ZmlyaW5nU3RhcnQgPSAwO1xcblxcdFxcdFxcdGZpcmluZ0xlbmd0aCA9IGxpc3QubGVuZ3RoO1xcblxcdFxcdFxcdGZpcmluZyA9IHRydWU7XFxuXFx0XFx0XFx0Zm9yICg7IGxpc3QgJiYgZmlyaW5nSW5kZXggPCBmaXJpbmdMZW5ndGg7IGZpcmluZ0luZGV4KyspIHtcXG5cXHRcXHRcXHRcXHRpZiAobGlzdFtmaXJpbmdJbmRleF0uYXBwbHkoZGF0YVswXSwgZGF0YVsxXSkgPT09IGZhbHNlICYmIG9wdGlvbnMuc3RvcE9uRmFsc2UpIHtcXG5cXHRcXHRcXHRcXHRcXHRtZW1vcnkgPSBmYWxzZTsgLy8gVG8gcHJldmVudCBmdXJ0aGVyIGNhbGxzIHVzaW5nIGFkZFxcblxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0ZmlyaW5nID0gZmFsc2U7XFxuXFx0XFx0XFx0aWYgKGxpc3QpIHtcXG5cXHRcXHRcXHRcXHRpZiAoc3RhY2spIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoc3RhY2subGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZmlyZShzdGFjay5zaGlmdCgpKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmIChtZW1vcnkpIHtcXG5cXHRcXHRcXHRcXHRcXHRsaXN0ID0gW107XFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRzZWxmLmRpc2FibGUoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Ly8gQWN0dWFsIENhbGxiYWNrcyBvYmplY3RcXG5cXHRcXHRzZWxmID0ge1xcblxcdFxcdFxcdC8vIEFkZCBhIGNhbGxiYWNrIG9yIGEgY29sbGVjdGlvbiBvZiBjYWxsYmFja3MgdG8gdGhlIGxpc3RcXG5cXHRcXHRcXHRhZGQ6IGZ1bmN0aW9uIGFkZCgpIHtcXG5cXHRcXHRcXHRcXHRpZiAobGlzdCkge1xcblxcdFxcdFxcdFxcdFxcdC8vIEZpcnN0LCB3ZSBzYXZlIHRoZSBjdXJyZW50IGxlbmd0aFxcblxcdFxcdFxcdFxcdFxcdHZhciBzdGFydCA9IGxpc3QubGVuZ3RoO1xcblxcdFxcdFxcdFxcdFxcdChmdW5jdGlvbiBhZGQoYXJncykge1xcblxcdFxcdFxcdFxcdFxcdFxcdGpRdWVyeS5lYWNoKGFyZ3MsIGZ1bmN0aW9uIChfLCBhcmcpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgdHlwZSA9IGpRdWVyeS50eXBlKGFyZyk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKHR5cGUgPT09IFxcXCJmdW5jdGlvblxcXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIW9wdGlvbnMudW5pcXVlIHx8ICFzZWxmLmhhcyhhcmcpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bGlzdC5wdXNoKGFyZyk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoYXJnICYmIGFyZy5sZW5ndGggJiYgdHlwZSAhPT0gXFxcInN0cmluZ1xcXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBJbnNwZWN0IHJlY3Vyc2l2ZWx5XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YWRkKGFyZyk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdFxcdFxcdH0pKGFyZ3VtZW50cyk7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gRG8gd2UgbmVlZCB0byBhZGQgdGhlIGNhbGxiYWNrcyB0byB0aGVcXG5cXHRcXHRcXHRcXHRcXHQvLyBjdXJyZW50IGZpcmluZyBiYXRjaD9cXG5cXHRcXHRcXHRcXHRcXHRpZiAoZmlyaW5nKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZmlyaW5nTGVuZ3RoID0gbGlzdC5sZW5ndGg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gV2l0aCBtZW1vcnksIGlmIHdlJ3JlIG5vdCBmaXJpbmcgdGhlblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIHdlIHNob3VsZCBjYWxsIHJpZ2h0IGF3YXlcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2UgaWYgKG1lbW9yeSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGZpcmluZ1N0YXJ0ID0gc3RhcnQ7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZmlyZShtZW1vcnkpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHQvLyBSZW1vdmUgYSBjYWxsYmFjayBmcm9tIHRoZSBsaXN0XFxuXFx0XFx0XFx0cmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGxpc3QpIHtcXG5cXHRcXHRcXHRcXHRcXHRqUXVlcnkuZWFjaChhcmd1bWVudHMsIGZ1bmN0aW9uIChfLCBhcmcpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgaW5kZXg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0d2hpbGUgKChpbmRleCA9IGpRdWVyeS5pbkFycmF5KGFyZywgbGlzdCwgaW5kZXgpKSA+IC0xKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIEhhbmRsZSBmaXJpbmcgaW5kZXhlc1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChmaXJpbmcpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoaW5kZXggPD0gZmlyaW5nTGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZmlyaW5nTGVuZ3RoLS07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChpbmRleCA8PSBmaXJpbmdJbmRleCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGZpcmluZ0luZGV4LS07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0Ly8gQ2hlY2sgaWYgYSBnaXZlbiBjYWxsYmFjayBpcyBpbiB0aGUgbGlzdC5cXG5cXHRcXHRcXHQvLyBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgcmV0dXJuIHdoZXRoZXIgb3Igbm90IGxpc3QgaGFzIGNhbGxiYWNrcyBhdHRhY2hlZC5cXG5cXHRcXHRcXHRoYXM6IGZ1bmN0aW9uIGhhcyhmbikge1xcblxcdFxcdFxcdFxcdHJldHVybiBmbiA/IGpRdWVyeS5pbkFycmF5KGZuLCBsaXN0KSA+IC0xIDogISEobGlzdCAmJiBsaXN0Lmxlbmd0aCk7XFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHQvLyBSZW1vdmUgYWxsIGNhbGxiYWNrcyBmcm9tIHRoZSBsaXN0XFxuXFx0XFx0XFx0ZW1wdHk6IGZ1bmN0aW9uIGVtcHR5KCkge1xcblxcdFxcdFxcdFxcdGxpc3QgPSBbXTtcXG5cXHRcXHRcXHRcXHRmaXJpbmdMZW5ndGggPSAwO1xcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0Ly8gSGF2ZSB0aGUgbGlzdCBkbyBub3RoaW5nIGFueW1vcmVcXG5cXHRcXHRcXHRkaXNhYmxlOiBmdW5jdGlvbiBkaXNhYmxlKCkge1xcblxcdFxcdFxcdFxcdGxpc3QgPSBzdGFjayA9IG1lbW9yeSA9IHVuZGVmaW5lZDtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdC8vIElzIGl0IGRpc2FibGVkP1xcblxcdFxcdFxcdGRpc2FibGVkOiBmdW5jdGlvbiBkaXNhYmxlZCgpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gIWxpc3Q7XFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHQvLyBMb2NrIHRoZSBsaXN0IGluIGl0cyBjdXJyZW50IHN0YXRlXFxuXFx0XFx0XFx0bG9jazogZnVuY3Rpb24gbG9jaygpIHtcXG5cXHRcXHRcXHRcXHRzdGFjayA9IHVuZGVmaW5lZDtcXG5cXHRcXHRcXHRcXHRpZiAoIW1lbW9yeSkge1xcblxcdFxcdFxcdFxcdFxcdHNlbGYuZGlzYWJsZSgpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdC8vIElzIGl0IGxvY2tlZD9cXG5cXHRcXHRcXHRsb2NrZWQ6IGZ1bmN0aW9uIGxvY2tlZCgpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gIXN0YWNrO1xcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0Ly8gQ2FsbCBhbGwgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGNvbnRleHQgYW5kIGFyZ3VtZW50c1xcblxcdFxcdFxcdGZpcmVXaXRoOiBmdW5jdGlvbiBmaXJlV2l0aChjb250ZXh0LCBhcmdzKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGxpc3QgJiYgKCFfZmlyZWQgfHwgc3RhY2spKSB7XFxuXFx0XFx0XFx0XFx0XFx0YXJncyA9IGFyZ3MgfHwgW107XFxuXFx0XFx0XFx0XFx0XFx0YXJncyA9IFtjb250ZXh0LCBhcmdzLnNsaWNlID8gYXJncy5zbGljZSgpIDogYXJnc107XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGZpcmluZykge1xcblxcdFxcdFxcdFxcdFxcdFxcdHN0YWNrLnB1c2goYXJncyk7XFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRmaXJlKGFyZ3MpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHQvLyBDYWxsIGFsbCB0aGUgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGFyZ3VtZW50c1xcblxcdFxcdFxcdGZpcmU6IGZ1bmN0aW9uIGZpcmUoKSB7XFxuXFx0XFx0XFx0XFx0c2VsZi5maXJlV2l0aCh0aGlzLCBhcmd1bWVudHMpO1xcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0Ly8gVG8ga25vdyBpZiB0aGUgY2FsbGJhY2tzIGhhdmUgYWxyZWFkeSBiZWVuIGNhbGxlZCBhdCBsZWFzdCBvbmNlXFxuXFx0XFx0XFx0ZmlyZWQ6IGZ1bmN0aW9uIGZpcmVkKCkge1xcblxcdFxcdFxcdFxcdHJldHVybiAhIV9maXJlZDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fTtcXG5cXG5cXHRcXHRyZXR1cm4gc2VsZjtcXG5cXHR9O1xcblxcblxcdGpRdWVyeS5leHRlbmQoe1xcblxcblxcdFxcdERlZmVycmVkOiBmdW5jdGlvbiBEZWZlcnJlZChmdW5jKSB7XFxuXFx0XFx0XFx0dmFyIHR1cGxlcyA9IFtcXG5cXHRcXHRcXHQvLyBhY3Rpb24sIGFkZCBsaXN0ZW5lciwgbGlzdGVuZXIgbGlzdCwgZmluYWwgc3RhdGVcXG5cXHRcXHRcXHRbXFxcInJlc29sdmVcXFwiLCBcXFwiZG9uZVxcXCIsIGpRdWVyeS5DYWxsYmFja3MoXFxcIm9uY2UgbWVtb3J5XFxcIiksIFxcXCJyZXNvbHZlZFxcXCJdLCBbXFxcInJlamVjdFxcXCIsIFxcXCJmYWlsXFxcIiwgalF1ZXJ5LkNhbGxiYWNrcyhcXFwib25jZSBtZW1vcnlcXFwiKSwgXFxcInJlamVjdGVkXFxcIl0sIFtcXFwibm90aWZ5XFxcIiwgXFxcInByb2dyZXNzXFxcIiwgalF1ZXJ5LkNhbGxiYWNrcyhcXFwibWVtb3J5XFxcIildXSxcXG5cXHRcXHRcXHQgICAgX3N0YXRlID0gXFxcInBlbmRpbmdcXFwiLFxcblxcdFxcdFxcdCAgICBfcHJvbWlzZSA9IHtcXG5cXHRcXHRcXHRcXHRzdGF0ZTogZnVuY3Rpb24gc3RhdGUoKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIF9zdGF0ZTtcXG5cXHRcXHRcXHRcXHR9LFxcblxcdFxcdFxcdFxcdGFsd2F5czogZnVuY3Rpb24gYWx3YXlzKCkge1xcblxcdFxcdFxcdFxcdFxcdGRlZmVycmVkLmRvbmUoYXJndW1lbnRzKS5mYWlsKGFyZ3VtZW50cyk7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0XFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRcXHR0aGVuOiBmdW5jdGlvbiB0aGVuKCkgLyogZm5Eb25lLCBmbkZhaWwsIGZuUHJvZ3Jlc3MgKi97XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGZucyA9IGFyZ3VtZW50cztcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKGZ1bmN0aW9uIChuZXdEZWZlcikge1xcblxcdFxcdFxcdFxcdFxcdFxcdGpRdWVyeS5lYWNoKHR1cGxlcywgZnVuY3Rpb24gKGksIHR1cGxlKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIGZuID0galF1ZXJ5LmlzRnVuY3Rpb24oZm5zW2ldKSAmJiBmbnNbaV07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gZGVmZXJyZWRbIGRvbmUgfCBmYWlsIHwgcHJvZ3Jlc3MgXSBmb3IgZm9yd2FyZGluZyBhY3Rpb25zIHRvIG5ld0RlZmVyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGVmZXJyZWRbdHVwbGVbMV1dKGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgcmV0dXJuZWQgPSBmbiAmJiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChyZXR1cm5lZCAmJiBqUXVlcnkuaXNGdW5jdGlvbihyZXR1cm5lZC5wcm9taXNlKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybmVkLnByb21pc2UoKS5kb25lKG5ld0RlZmVyLnJlc29sdmUpLmZhaWwobmV3RGVmZXIucmVqZWN0KS5wcm9ncmVzcyhuZXdEZWZlci5ub3RpZnkpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bmV3RGVmZXJbdHVwbGVbMF0gKyBcXFwiV2l0aFxcXCJdKHRoaXMgPT09IF9wcm9taXNlID8gbmV3RGVmZXIucHJvbWlzZSgpIDogdGhpcywgZm4gPyBbcmV0dXJuZWRdIDogYXJndW1lbnRzKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Zm5zID0gbnVsbDtcXG5cXHRcXHRcXHRcXHRcXHR9KS5wcm9taXNlKCk7XFxuXFx0XFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRcXHQvLyBHZXQgYSBwcm9taXNlIGZvciB0aGlzIGRlZmVycmVkXFxuXFx0XFx0XFx0XFx0Ly8gSWYgb2JqIGlzIHByb3ZpZGVkLCB0aGUgcHJvbWlzZSBhc3BlY3QgaXMgYWRkZWQgdG8gdGhlIG9iamVjdFxcblxcdFxcdFxcdFxcdHByb21pc2U6IGZ1bmN0aW9uIHByb21pc2Uob2JqKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIG9iaiAhPSBudWxsID8galF1ZXJ5LmV4dGVuZChvYmosIF9wcm9taXNlKSA6IF9wcm9taXNlO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdCAgICBkZWZlcnJlZCA9IHt9O1xcblxcblxcdFxcdFxcdC8vIEtlZXAgcGlwZSBmb3IgYmFjay1jb21wYXRcXG5cXHRcXHRcXHRfcHJvbWlzZS5waXBlID0gX3Byb21pc2UudGhlbjtcXG5cXG5cXHRcXHRcXHQvLyBBZGQgbGlzdC1zcGVjaWZpYyBtZXRob2RzXFxuXFx0XFx0XFx0alF1ZXJ5LmVhY2godHVwbGVzLCBmdW5jdGlvbiAoaSwgdHVwbGUpIHtcXG5cXHRcXHRcXHRcXHR2YXIgbGlzdCA9IHR1cGxlWzJdLFxcblxcdFxcdFxcdFxcdCAgICBzdGF0ZVN0cmluZyA9IHR1cGxlWzNdO1xcblxcblxcdFxcdFxcdFxcdC8vIHByb21pc2VbIGRvbmUgfCBmYWlsIHwgcHJvZ3Jlc3MgXSA9IGxpc3QuYWRkXFxuXFx0XFx0XFx0XFx0X3Byb21pc2VbdHVwbGVbMV1dID0gbGlzdC5hZGQ7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSGFuZGxlIHN0YXRlXFxuXFx0XFx0XFx0XFx0aWYgKHN0YXRlU3RyaW5nKSB7XFxuXFx0XFx0XFx0XFx0XFx0bGlzdC5hZGQoZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdC8vIHN0YXRlID0gWyByZXNvbHZlZCB8IHJlamVjdGVkIF1cXG5cXHRcXHRcXHRcXHRcXHRcXHRfc3RhdGUgPSBzdGF0ZVN0cmluZztcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBbIHJlamVjdF9saXN0IHwgcmVzb2x2ZV9saXN0IF0uZGlzYWJsZTsgcHJvZ3Jlc3NfbGlzdC5sb2NrXFxuXFx0XFx0XFx0XFx0XFx0fSwgdHVwbGVzW2kgXiAxXVsyXS5kaXNhYmxlLCB0dXBsZXNbMl1bMl0ubG9jayk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIGRlZmVycmVkWyByZXNvbHZlIHwgcmVqZWN0IHwgbm90aWZ5IF1cXG5cXHRcXHRcXHRcXHRkZWZlcnJlZFt0dXBsZVswXV0gPSBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZGVmZXJyZWRbdHVwbGVbMF0gKyBcXFwiV2l0aFxcXCJdKHRoaXMgPT09IGRlZmVycmVkID8gX3Byb21pc2UgOiB0aGlzLCBhcmd1bWVudHMpO1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcdFxcdFxcdFxcdH07XFxuXFx0XFx0XFx0XFx0ZGVmZXJyZWRbdHVwbGVbMF0gKyBcXFwiV2l0aFxcXCJdID0gbGlzdC5maXJlV2l0aDtcXG5cXHRcXHRcXHR9KTtcXG5cXG5cXHRcXHRcXHQvLyBNYWtlIHRoZSBkZWZlcnJlZCBhIHByb21pc2VcXG5cXHRcXHRcXHRfcHJvbWlzZS5wcm9taXNlKGRlZmVycmVkKTtcXG5cXG5cXHRcXHRcXHQvLyBDYWxsIGdpdmVuIGZ1bmMgaWYgYW55XFxuXFx0XFx0XFx0aWYgKGZ1bmMpIHtcXG5cXHRcXHRcXHRcXHRmdW5jLmNhbGwoZGVmZXJyZWQsIGRlZmVycmVkKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gQWxsIGRvbmUhXFxuXFx0XFx0XFx0cmV0dXJuIGRlZmVycmVkO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0Ly8gRGVmZXJyZWQgaGVscGVyXFxuXFx0XFx0d2hlbjogZnVuY3Rpb24gd2hlbihzdWJvcmRpbmF0ZSAvKiAsIC4uLiwgc3Vib3JkaW5hdGVOICovKSB7XFxuXFx0XFx0XFx0dmFyIGkgPSAwLFxcblxcdFxcdFxcdCAgICByZXNvbHZlVmFsdWVzID0gX3NsaWNlLmNhbGwoYXJndW1lbnRzKSxcXG5cXHRcXHRcXHQgICAgbGVuZ3RoID0gcmVzb2x2ZVZhbHVlcy5sZW5ndGgsXFxuXFxuXFxuXFx0XFx0XFx0Ly8gdGhlIGNvdW50IG9mIHVuY29tcGxldGVkIHN1Ym9yZGluYXRlc1xcblxcdFxcdFxcdHJlbWFpbmluZyA9IGxlbmd0aCAhPT0gMSB8fCBzdWJvcmRpbmF0ZSAmJiBqUXVlcnkuaXNGdW5jdGlvbihzdWJvcmRpbmF0ZS5wcm9taXNlKSA/IGxlbmd0aCA6IDAsXFxuXFxuXFxuXFx0XFx0XFx0Ly8gdGhlIG1hc3RlciBEZWZlcnJlZC4gSWYgcmVzb2x2ZVZhbHVlcyBjb25zaXN0IG9mIG9ubHkgYSBzaW5nbGUgRGVmZXJyZWQsIGp1c3QgdXNlIHRoYXQuXFxuXFx0XFx0XFx0ZGVmZXJyZWQgPSByZW1haW5pbmcgPT09IDEgPyBzdWJvcmRpbmF0ZSA6IGpRdWVyeS5EZWZlcnJlZCgpLFxcblxcblxcblxcdFxcdFxcdC8vIFVwZGF0ZSBmdW5jdGlvbiBmb3IgYm90aCByZXNvbHZlIGFuZCBwcm9ncmVzcyB2YWx1ZXNcXG5cXHRcXHRcXHR1cGRhdGVGdW5jID0gZnVuY3Rpb24gdXBkYXRlRnVuYyhpLCBjb250ZXh0cywgdmFsdWVzKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xcblxcdFxcdFxcdFxcdFxcdGNvbnRleHRzW2ldID0gdGhpcztcXG5cXHRcXHRcXHRcXHRcXHR2YWx1ZXNbaV0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IF9zbGljZS5jYWxsKGFyZ3VtZW50cykgOiB2YWx1ZTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAodmFsdWVzID09PSBwcm9ncmVzc1ZhbHVlcykge1xcblxcdFxcdFxcdFxcdFxcdFxcdGRlZmVycmVkLm5vdGlmeVdpdGgoY29udGV4dHMsIHZhbHVlcyk7XFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIGlmICghIC0tcmVtYWluaW5nKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoY29udGV4dHMsIHZhbHVlcyk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH07XFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHQgICAgcHJvZ3Jlc3NWYWx1ZXMsXFxuXFx0XFx0XFx0ICAgIHByb2dyZXNzQ29udGV4dHMsXFxuXFx0XFx0XFx0ICAgIHJlc29sdmVDb250ZXh0cztcXG5cXG5cXHRcXHRcXHQvLyBBZGQgbGlzdGVuZXJzIHRvIERlZmVycmVkIHN1Ym9yZGluYXRlczsgdHJlYXQgb3RoZXJzIGFzIHJlc29sdmVkXFxuXFx0XFx0XFx0aWYgKGxlbmd0aCA+IDEpIHtcXG5cXHRcXHRcXHRcXHRwcm9ncmVzc1ZhbHVlcyA9IG5ldyBBcnJheShsZW5ndGgpO1xcblxcdFxcdFxcdFxcdHByb2dyZXNzQ29udGV4dHMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcXG5cXHRcXHRcXHRcXHRyZXNvbHZlQ29udGV4dHMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcXG5cXHRcXHRcXHRcXHRmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHJlc29sdmVWYWx1ZXNbaV0gJiYgalF1ZXJ5LmlzRnVuY3Rpb24ocmVzb2x2ZVZhbHVlc1tpXS5wcm9taXNlKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJlc29sdmVWYWx1ZXNbaV0ucHJvbWlzZSgpLmRvbmUodXBkYXRlRnVuYyhpLCByZXNvbHZlQ29udGV4dHMsIHJlc29sdmVWYWx1ZXMpKS5mYWlsKGRlZmVycmVkLnJlamVjdCkucHJvZ3Jlc3ModXBkYXRlRnVuYyhpLCBwcm9ncmVzc0NvbnRleHRzLCBwcm9ncmVzc1ZhbHVlcykpO1xcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0LS1yZW1haW5pbmc7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gSWYgd2UncmUgbm90IHdhaXRpbmcgb24gYW55dGhpbmcsIHJlc29sdmUgdGhlIG1hc3RlclxcblxcdFxcdFxcdGlmICghcmVtYWluaW5nKSB7XFxuXFx0XFx0XFx0XFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgocmVzb2x2ZUNvbnRleHRzLCByZXNvbHZlVmFsdWVzKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGRlZmVycmVkLnByb21pc2UoKTtcXG5cXHRcXHR9XFxuXFx0fSk7XFxuXFxuXFx0Ly8gVGhlIGRlZmVycmVkIHVzZWQgb24gRE9NIHJlYWR5XFxuXFx0dmFyIHJlYWR5TGlzdDtcXG5cXG5cXHRqUXVlcnkuZm4ucmVhZHkgPSBmdW5jdGlvbiAoZm4pIHtcXG5cXHRcXHQvLyBBZGQgdGhlIGNhbGxiYWNrXFxuXFx0XFx0alF1ZXJ5LnJlYWR5LnByb21pc2UoKS5kb25lKGZuKTtcXG5cXG5cXHRcXHRyZXR1cm4gdGhpcztcXG5cXHR9O1xcblxcblxcdGpRdWVyeS5leHRlbmQoe1xcblxcdFxcdC8vIElzIHRoZSBET00gcmVhZHkgdG8gYmUgdXNlZD8gU2V0IHRvIHRydWUgb25jZSBpdCBvY2N1cnMuXFxuXFx0XFx0aXNSZWFkeTogZmFsc2UsXFxuXFxuXFx0XFx0Ly8gQSBjb3VudGVyIHRvIHRyYWNrIGhvdyBtYW55IGl0ZW1zIHRvIHdhaXQgZm9yIGJlZm9yZVxcblxcdFxcdC8vIHRoZSByZWFkeSBldmVudCBmaXJlcy4gU2VlICM2NzgxXFxuXFx0XFx0cmVhZHlXYWl0OiAxLFxcblxcblxcdFxcdC8vIEhvbGQgKG9yIHJlbGVhc2UpIHRoZSByZWFkeSBldmVudFxcblxcdFxcdGhvbGRSZWFkeTogZnVuY3Rpb24gaG9sZFJlYWR5KGhvbGQpIHtcXG5cXHRcXHRcXHRpZiAoaG9sZCkge1xcblxcdFxcdFxcdFxcdGpRdWVyeS5yZWFkeVdhaXQrKztcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdGpRdWVyeS5yZWFkeSh0cnVlKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyBIYW5kbGUgd2hlbiB0aGUgRE9NIGlzIHJlYWR5XFxuXFx0XFx0cmVhZHk6IGZ1bmN0aW9uIHJlYWR5KHdhaXQpIHtcXG5cXG5cXHRcXHRcXHQvLyBBYm9ydCBpZiB0aGVyZSBhcmUgcGVuZGluZyBob2xkcyBvciB3ZSdyZSBhbHJlYWR5IHJlYWR5XFxuXFx0XFx0XFx0aWYgKHdhaXQgPT09IHRydWUgPyAtLWpRdWVyeS5yZWFkeVdhaXQgOiBqUXVlcnkuaXNSZWFkeSkge1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gUmVtZW1iZXIgdGhhdCB0aGUgRE9NIGlzIHJlYWR5XFxuXFx0XFx0XFx0alF1ZXJ5LmlzUmVhZHkgPSB0cnVlO1xcblxcblxcdFxcdFxcdC8vIElmIGEgbm9ybWFsIERPTSBSZWFkeSBldmVudCBmaXJlZCwgZGVjcmVtZW50LCBhbmQgd2FpdCBpZiBuZWVkIGJlXFxuXFx0XFx0XFx0aWYgKHdhaXQgIT09IHRydWUgJiYgLS1qUXVlcnkucmVhZHlXYWl0ID4gMCkge1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gSWYgdGhlcmUgYXJlIGZ1bmN0aW9ucyBib3VuZCwgdG8gZXhlY3V0ZVxcblxcdFxcdFxcdHJlYWR5TGlzdC5yZXNvbHZlV2l0aChkb2N1bWVudCwgW2pRdWVyeV0pO1xcblxcblxcdFxcdFxcdC8vIFRyaWdnZXIgYW55IGJvdW5kIHJlYWR5IGV2ZW50c1xcblxcdFxcdFxcdGlmIChqUXVlcnkuZm4udHJpZ2dlckhhbmRsZXIpIHtcXG5cXHRcXHRcXHRcXHRqUXVlcnkoZG9jdW1lbnQpLnRyaWdnZXJIYW5kbGVyKFxcXCJyZWFkeVxcXCIpO1xcblxcdFxcdFxcdFxcdGpRdWVyeShkb2N1bWVudCkub2ZmKFxcXCJyZWFkeVxcXCIpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fSk7XFxuXFxuXFx0LyoqXFxuICAqIFRoZSByZWFkeSBldmVudCBoYW5kbGVyIGFuZCBzZWxmIGNsZWFudXAgbWV0aG9kXFxuICAqL1xcblxcdGZ1bmN0aW9uIGNvbXBsZXRlZCgpIHtcXG5cXHRcXHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFxcXCJET01Db250ZW50TG9hZGVkXFxcIiwgY29tcGxldGVkLCBmYWxzZSk7XFxuXFx0XFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXFxcImxvYWRcXFwiLCBjb21wbGV0ZWQsIGZhbHNlKTtcXG5cXHRcXHRqUXVlcnkucmVhZHkoKTtcXG5cXHR9XFxuXFxuXFx0alF1ZXJ5LnJlYWR5LnByb21pc2UgPSBmdW5jdGlvbiAob2JqKSB7XFxuXFx0XFx0aWYgKCFyZWFkeUxpc3QpIHtcXG5cXG5cXHRcXHRcXHRyZWFkeUxpc3QgPSBqUXVlcnkuRGVmZXJyZWQoKTtcXG5cXG5cXHRcXHRcXHQvLyBDYXRjaCBjYXNlcyB3aGVyZSAkKGRvY3VtZW50KS5yZWFkeSgpIGlzIGNhbGxlZCBhZnRlciB0aGUgYnJvd3NlciBldmVudCBoYXMgYWxyZWFkeSBvY2N1cnJlZC5cXG5cXHRcXHRcXHQvLyBXZSBvbmNlIHRyaWVkIHRvIHVzZSByZWFkeVN0YXRlIFxcXCJpbnRlcmFjdGl2ZVxcXCIgaGVyZSwgYnV0IGl0IGNhdXNlZCBpc3N1ZXMgbGlrZSB0aGUgb25lXFxuXFx0XFx0XFx0Ly8gZGlzY292ZXJlZCBieSBDaHJpc1MgaGVyZTogaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIyODIjY29tbWVudDoxNVxcblxcdFxcdFxcdGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcXFwiY29tcGxldGVcXFwiKSB7XFxuXFx0XFx0XFx0XFx0Ly8gSGFuZGxlIGl0IGFzeW5jaHJvbm91c2x5IHRvIGFsbG93IHNjcmlwdHMgdGhlIG9wcG9ydHVuaXR5IHRvIGRlbGF5IHJlYWR5XFxuXFx0XFx0XFx0XFx0c2V0VGltZW91dChqUXVlcnkucmVhZHkpO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gVXNlIHRoZSBoYW5keSBldmVudCBjYWxsYmFja1xcblxcdFxcdFxcdFxcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXFxcIkRPTUNvbnRlbnRMb2FkZWRcXFwiLCBjb21wbGV0ZWQsIGZhbHNlKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBBIGZhbGxiYWNrIHRvIHdpbmRvdy5vbmxvYWQsIHRoYXQgd2lsbCBhbHdheXMgd29ya1xcblxcdFxcdFxcdFxcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFxcXCJsb2FkXFxcIiwgY29tcGxldGVkLCBmYWxzZSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gcmVhZHlMaXN0LnByb21pc2Uob2JqKTtcXG5cXHR9O1xcblxcblxcdC8vIEtpY2sgb2ZmIHRoZSBET00gcmVhZHkgY2hlY2sgZXZlbiBpZiB0aGUgdXNlciBkb2VzIG5vdFxcblxcdGpRdWVyeS5yZWFkeS5wcm9taXNlKCk7XFxuXFxuXFx0Ly8gTXVsdGlmdW5jdGlvbmFsIG1ldGhvZCB0byBnZXQgYW5kIHNldCB2YWx1ZXMgb2YgYSBjb2xsZWN0aW9uXFxuXFx0Ly8gVGhlIHZhbHVlL3MgY2FuIG9wdGlvbmFsbHkgYmUgZXhlY3V0ZWQgaWYgaXQncyBhIGZ1bmN0aW9uXFxuXFx0dmFyIGFjY2VzcyA9IGpRdWVyeS5hY2Nlc3MgPSBmdW5jdGlvbiAoZWxlbXMsIGZuLCBrZXksIHZhbHVlLCBjaGFpbmFibGUsIGVtcHR5R2V0LCByYXcpIHtcXG5cXHRcXHR2YXIgaSA9IDAsXFxuXFx0XFx0ICAgIGxlbiA9IGVsZW1zLmxlbmd0aCxcXG5cXHRcXHQgICAgYnVsayA9IGtleSA9PSBudWxsO1xcblxcblxcdFxcdC8vIFNldHMgbWFueSB2YWx1ZXNcXG5cXHRcXHRpZiAoalF1ZXJ5LnR5cGUoa2V5KSA9PT0gXFxcIm9iamVjdFxcXCIpIHtcXG5cXHRcXHRcXHRjaGFpbmFibGUgPSB0cnVlO1xcblxcdFxcdFxcdGZvciAoaSBpbiBrZXkpIHtcXG5cXHRcXHRcXHRcXHRqUXVlcnkuYWNjZXNzKGVsZW1zLCBmbiwgaSwga2V5W2ldLCB0cnVlLCBlbXB0eUdldCwgcmF3KTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gU2V0cyBvbmUgdmFsdWVcXG5cXHRcXHR9IGVsc2UgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcXG5cXHRcXHRcXHRjaGFpbmFibGUgPSB0cnVlO1xcblxcblxcdFxcdFxcdGlmICghalF1ZXJ5LmlzRnVuY3Rpb24odmFsdWUpKSB7XFxuXFx0XFx0XFx0XFx0cmF3ID0gdHJ1ZTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKGJ1bGspIHtcXG5cXHRcXHRcXHRcXHQvLyBCdWxrIG9wZXJhdGlvbnMgcnVuIGFnYWluc3QgdGhlIGVudGlyZSBzZXRcXG5cXHRcXHRcXHRcXHRpZiAocmF3KSB7XFxuXFx0XFx0XFx0XFx0XFx0Zm4uY2FsbChlbGVtcywgdmFsdWUpO1xcblxcdFxcdFxcdFxcdFxcdGZuID0gbnVsbDtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyAuLi5leGNlcHQgd2hlbiBleGVjdXRpbmcgZnVuY3Rpb24gdmFsdWVzXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRidWxrID0gZm47XFxuXFx0XFx0XFx0XFx0XFx0Zm4gPSBmdW5jdGlvbiBmbihlbGVtLCBrZXksIHZhbHVlKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIGJ1bGsuY2FsbChqUXVlcnkoZWxlbSksIHZhbHVlKTtcXG5cXHRcXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKGZuKSB7XFxuXFx0XFx0XFx0XFx0Zm9yICg7IGkgPCBsZW47IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdGZuKGVsZW1zW2ldLCBrZXksIHJhdyA/IHZhbHVlIDogdmFsdWUuY2FsbChlbGVtc1tpXSwgaSwgZm4oZWxlbXNbaV0sIGtleSkpKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gY2hhaW5hYmxlID8gZWxlbXMgOlxcblxcblxcdFxcdC8vIEdldHNcXG5cXHRcXHRidWxrID8gZm4uY2FsbChlbGVtcykgOiBsZW4gPyBmbihlbGVtc1swXSwga2V5KSA6IGVtcHR5R2V0O1xcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqIERldGVybWluZXMgd2hldGhlciBhbiBvYmplY3QgY2FuIGhhdmUgZGF0YVxcbiAgKi9cXG5cXHRqUXVlcnkuYWNjZXB0RGF0YSA9IGZ1bmN0aW9uIChvd25lcikge1xcblxcdFxcdC8vIEFjY2VwdHMgb25seTpcXG5cXHRcXHQvLyAgLSBOb2RlXFxuXFx0XFx0Ly8gICAgLSBOb2RlLkVMRU1FTlRfTk9ERVxcblxcdFxcdC8vICAgIC0gTm9kZS5ET0NVTUVOVF9OT0RFXFxuXFx0XFx0Ly8gIC0gT2JqZWN0XFxuXFx0XFx0Ly8gICAgLSBBbnlcXG5cXHRcXHQvKiBqc2hpbnQgLVcwMTggKi9cXG5cXHRcXHRyZXR1cm4gb3duZXIubm9kZVR5cGUgPT09IDEgfHwgb3duZXIubm9kZVR5cGUgPT09IDkgfHwgIStvd25lci5ub2RlVHlwZTtcXG5cXHR9O1xcblxcblxcdGZ1bmN0aW9uIERhdGEoKSB7XFxuXFx0XFx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LFxcblxcdFxcdC8vIE9sZCBXZWJLaXQgZG9lcyBub3QgaGF2ZSBPYmplY3QucHJldmVudEV4dGVuc2lvbnMvZnJlZXplIG1ldGhvZCxcXG5cXHRcXHQvLyByZXR1cm4gbmV3IGVtcHR5IG9iamVjdCBpbnN0ZWFkIHdpdGggbm8gW1tzZXRdXSBhY2Nlc3NvclxcblxcdFxcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLmNhY2hlID0ge30sIDAsIHtcXG5cXHRcXHRcXHRnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4ge307XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0pO1xcblxcblxcdFxcdHRoaXMuZXhwYW5kbyA9IGpRdWVyeS5leHBhbmRvICsgRGF0YS51aWQrKztcXG5cXHR9XFxuXFxuXFx0RGF0YS51aWQgPSAxO1xcblxcdERhdGEuYWNjZXB0cyA9IGpRdWVyeS5hY2NlcHREYXRhO1xcblxcblxcdERhdGEucHJvdG90eXBlID0ge1xcblxcdFxcdGtleTogZnVuY3Rpb24ga2V5KG93bmVyKSB7XFxuXFx0XFx0XFx0Ly8gV2UgY2FuIGFjY2VwdCBkYXRhIGZvciBub24tZWxlbWVudCBub2RlcyBpbiBtb2Rlcm4gYnJvd3NlcnMsXFxuXFx0XFx0XFx0Ly8gYnV0IHdlIHNob3VsZCBub3QsIHNlZSAjODMzNS5cXG5cXHRcXHRcXHQvLyBBbHdheXMgcmV0dXJuIHRoZSBrZXkgZm9yIGEgZnJvemVuIG9iamVjdC5cXG5cXHRcXHRcXHRpZiAoIURhdGEuYWNjZXB0cyhvd25lcikpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gMDtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dmFyIGRlc2NyaXB0b3IgPSB7fSxcXG5cXG5cXHRcXHRcXHQvLyBDaGVjayBpZiB0aGUgb3duZXIgb2JqZWN0IGFscmVhZHkgaGFzIGEgY2FjaGUga2V5XFxuXFx0XFx0XFx0dW5sb2NrID0gb3duZXJbdGhpcy5leHBhbmRvXTtcXG5cXG5cXHRcXHRcXHQvLyBJZiBub3QsIGNyZWF0ZSBvbmVcXG5cXHRcXHRcXHRpZiAoIXVubG9jaykge1xcblxcdFxcdFxcdFxcdHVubG9jayA9IERhdGEudWlkKys7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gU2VjdXJlIGl0IGluIGEgbm9uLWVudW1lcmFibGUsIG5vbi13cml0YWJsZSBwcm9wZXJ0eVxcblxcdFxcdFxcdFxcdHRyeSB7XFxuXFx0XFx0XFx0XFx0XFx0ZGVzY3JpcHRvclt0aGlzLmV4cGFuZG9dID0geyB2YWx1ZTogdW5sb2NrIH07XFxuXFx0XFx0XFx0XFx0XFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMob3duZXIsIGRlc2NyaXB0b3IpO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NFxcblxcdFxcdFxcdFxcdFxcdC8vIEZhbGxiYWNrIHRvIGEgbGVzcyBzZWN1cmUgZGVmaW5pdGlvblxcblxcdFxcdFxcdFxcdH0gY2F0Y2ggKGUpIHtcXG5cXHRcXHRcXHRcXHRcXHRkZXNjcmlwdG9yW3RoaXMuZXhwYW5kb10gPSB1bmxvY2s7XFxuXFx0XFx0XFx0XFx0XFx0alF1ZXJ5LmV4dGVuZChvd25lciwgZGVzY3JpcHRvcik7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBFbnN1cmUgdGhlIGNhY2hlIG9iamVjdFxcblxcdFxcdFxcdGlmICghdGhpcy5jYWNoZVt1bmxvY2tdKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5jYWNoZVt1bmxvY2tdID0ge307XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB1bmxvY2s7XFxuXFx0XFx0fSxcXG5cXHRcXHRzZXQ6IGZ1bmN0aW9uIHNldChvd25lciwgZGF0YSwgdmFsdWUpIHtcXG5cXHRcXHRcXHR2YXIgcHJvcCxcXG5cXG5cXHRcXHRcXHQvLyBUaGVyZSBtYXkgYmUgYW4gdW5sb2NrIGFzc2lnbmVkIHRvIHRoaXMgbm9kZSxcXG5cXHRcXHRcXHQvLyBpZiB0aGVyZSBpcyBubyBlbnRyeSBmb3IgdGhpcyBcXFwib3duZXJcXFwiLCBjcmVhdGUgb25lIGlubGluZVxcblxcdFxcdFxcdC8vIGFuZCBzZXQgdGhlIHVubG9jayBhcyB0aG91Z2ggYW4gb3duZXIgZW50cnkgaGFkIGFsd2F5cyBleGlzdGVkXFxuXFx0XFx0XFx0dW5sb2NrID0gdGhpcy5rZXkob3duZXIpLFxcblxcdFxcdFxcdCAgICBjYWNoZSA9IHRoaXMuY2FjaGVbdW5sb2NrXTtcXG5cXG5cXHRcXHRcXHQvLyBIYW5kbGU6IFsgb3duZXIsIGtleSwgdmFsdWUgXSBhcmdzXFxuXFx0XFx0XFx0aWYgKHR5cGVvZiBkYXRhID09PSBcXFwic3RyaW5nXFxcIikge1xcblxcdFxcdFxcdFxcdGNhY2hlW2RhdGFdID0gdmFsdWU7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSGFuZGxlOiBbIG93bmVyLCB7IHByb3BlcnRpZXMgfSBdIGFyZ3NcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdC8vIEZyZXNoIGFzc2lnbm1lbnRzIGJ5IG9iamVjdCBhcmUgc2hhbGxvdyBjb3BpZWRcXG5cXHRcXHRcXHRcXHRpZiAoalF1ZXJ5LmlzRW1wdHlPYmplY3QoY2FjaGUpKSB7XFxuXFx0XFx0XFx0XFx0XFx0alF1ZXJ5LmV4dGVuZCh0aGlzLmNhY2hlW3VubG9ja10sIGRhdGEpO1xcblxcdFxcdFxcdFxcdFxcdC8vIE90aGVyd2lzZSwgY29weSB0aGUgcHJvcGVydGllcyBvbmUtYnktb25lIHRvIHRoZSBjYWNoZSBvYmplY3RcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdGZvciAocHJvcCBpbiBkYXRhKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FjaGVbcHJvcF0gPSBkYXRhW3Byb3BdO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiBjYWNoZTtcXG5cXHRcXHR9LFxcblxcdFxcdGdldDogZnVuY3Rpb24gZ2V0KG93bmVyLCBrZXkpIHtcXG5cXHRcXHRcXHQvLyBFaXRoZXIgYSB2YWxpZCBjYWNoZSBpcyBmb3VuZCwgb3Igd2lsbCBiZSBjcmVhdGVkLlxcblxcdFxcdFxcdC8vIE5ldyBjYWNoZXMgd2lsbCBiZSBjcmVhdGVkIGFuZCB0aGUgdW5sb2NrIHJldHVybmVkLFxcblxcdFxcdFxcdC8vIGFsbG93aW5nIGRpcmVjdCBhY2Nlc3MgdG8gdGhlIG5ld2x5IGNyZWF0ZWRcXG5cXHRcXHRcXHQvLyBlbXB0eSBkYXRhIG9iamVjdC4gQSB2YWxpZCBvd25lciBvYmplY3QgbXVzdCBiZSBwcm92aWRlZC5cXG5cXHRcXHRcXHR2YXIgY2FjaGUgPSB0aGlzLmNhY2hlW3RoaXMua2V5KG93bmVyKV07XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGtleSA9PT0gdW5kZWZpbmVkID8gY2FjaGUgOiBjYWNoZVtrZXldO1xcblxcdFxcdH0sXFxuXFx0XFx0YWNjZXNzOiBmdW5jdGlvbiBhY2Nlc3Mob3duZXIsIGtleSwgdmFsdWUpIHtcXG5cXHRcXHRcXHR2YXIgc3RvcmVkO1xcblxcdFxcdFxcdC8vIEluIGNhc2VzIHdoZXJlIGVpdGhlcjpcXG5cXHRcXHRcXHQvL1xcblxcdFxcdFxcdC8vICAgMS4gTm8ga2V5IHdhcyBzcGVjaWZpZWRcXG5cXHRcXHRcXHQvLyAgIDIuIEEgc3RyaW5nIGtleSB3YXMgc3BlY2lmaWVkLCBidXQgbm8gdmFsdWUgcHJvdmlkZWRcXG5cXHRcXHRcXHQvL1xcblxcdFxcdFxcdC8vIFRha2UgdGhlIFxcXCJyZWFkXFxcIiBwYXRoIGFuZCBhbGxvdyB0aGUgZ2V0IG1ldGhvZCB0byBkZXRlcm1pbmVcXG5cXHRcXHRcXHQvLyB3aGljaCB2YWx1ZSB0byByZXR1cm4sIHJlc3BlY3RpdmVseSBlaXRoZXI6XFxuXFx0XFx0XFx0Ly9cXG5cXHRcXHRcXHQvLyAgIDEuIFRoZSBlbnRpcmUgY2FjaGUgb2JqZWN0XFxuXFx0XFx0XFx0Ly8gICAyLiBUaGUgZGF0YSBzdG9yZWQgYXQgdGhlIGtleVxcblxcdFxcdFxcdC8vXFxuXFx0XFx0XFx0aWYgKGtleSA9PT0gdW5kZWZpbmVkIHx8IGtleSAmJiB0eXBlb2Yga2V5ID09PSBcXFwic3RyaW5nXFxcIiAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XFxuXFxuXFx0XFx0XFx0XFx0c3RvcmVkID0gdGhpcy5nZXQob3duZXIsIGtleSk7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHN0b3JlZCAhPT0gdW5kZWZpbmVkID8gc3RvcmVkIDogdGhpcy5nZXQob3duZXIsIGpRdWVyeS5jYW1lbENhc2Uoa2V5KSk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFsqXVdoZW4gdGhlIGtleSBpcyBub3QgYSBzdHJpbmcsIG9yIGJvdGggYSBrZXkgYW5kIHZhbHVlXFxuXFx0XFx0XFx0Ly8gYXJlIHNwZWNpZmllZCwgc2V0IG9yIGV4dGVuZCAoZXhpc3Rpbmcgb2JqZWN0cykgd2l0aCBlaXRoZXI6XFxuXFx0XFx0XFx0Ly9cXG5cXHRcXHRcXHQvLyAgIDEuIEFuIG9iamVjdCBvZiBwcm9wZXJ0aWVzXFxuXFx0XFx0XFx0Ly8gICAyLiBBIGtleSBhbmQgdmFsdWVcXG5cXHRcXHRcXHQvL1xcblxcdFxcdFxcdHRoaXMuc2V0KG93bmVyLCBrZXksIHZhbHVlKTtcXG5cXG5cXHRcXHRcXHQvLyBTaW5jZSB0aGUgXFxcInNldFxcXCIgcGF0aCBjYW4gaGF2ZSB0d28gcG9zc2libGUgZW50cnkgcG9pbnRzXFxuXFx0XFx0XFx0Ly8gcmV0dXJuIHRoZSBleHBlY3RlZCBkYXRhIGJhc2VkIG9uIHdoaWNoIHBhdGggd2FzIHRha2VuWypdXFxuXFx0XFx0XFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IGtleTtcXG5cXHRcXHR9LFxcblxcdFxcdHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKG93bmVyLCBrZXkpIHtcXG5cXHRcXHRcXHR2YXIgaSxcXG5cXHRcXHRcXHQgICAgbmFtZSxcXG5cXHRcXHRcXHQgICAgY2FtZWwsXFxuXFx0XFx0XFx0ICAgIHVubG9jayA9IHRoaXMua2V5KG93bmVyKSxcXG5cXHRcXHRcXHQgICAgY2FjaGUgPSB0aGlzLmNhY2hlW3VubG9ja107XFxuXFxuXFx0XFx0XFx0aWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5jYWNoZVt1bmxvY2tdID0ge307XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHQvLyBTdXBwb3J0IGFycmF5IG9yIHNwYWNlIHNlcGFyYXRlZCBzdHJpbmcgb2Yga2V5c1xcblxcdFxcdFxcdFxcdGlmIChqUXVlcnkuaXNBcnJheShrZXkpKSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gSWYgXFxcIm5hbWVcXFwiIGlzIGFuIGFycmF5IG9mIGtleXMuLi5cXG5cXHRcXHRcXHRcXHRcXHQvLyBXaGVuIGRhdGEgaXMgaW5pdGlhbGx5IGNyZWF0ZWQsIHZpYSAoXFxcImtleVxcXCIsIFxcXCJ2YWxcXFwiKSBzaWduYXR1cmUsXFxuXFx0XFx0XFx0XFx0XFx0Ly8ga2V5cyB3aWxsIGJlIGNvbnZlcnRlZCB0byBjYW1lbENhc2UuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gU2luY2UgdGhlcmUgaXMgbm8gd2F5IHRvIHRlbGwgX2hvd18gYSBrZXkgd2FzIGFkZGVkLCByZW1vdmVcXG5cXHRcXHRcXHRcXHRcXHQvLyBib3RoIHBsYWluIGtleSBhbmQgY2FtZWxDYXNlIGtleS4gIzEyNzg2XFxuXFx0XFx0XFx0XFx0XFx0Ly8gVGhpcyB3aWxsIG9ubHkgcGVuYWxpemUgdGhlIGFycmF5IGFyZ3VtZW50IHBhdGguXFxuXFx0XFx0XFx0XFx0XFx0bmFtZSA9IGtleS5jb25jYXQoa2V5Lm1hcChqUXVlcnkuY2FtZWxDYXNlKSk7XFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRjYW1lbCA9IGpRdWVyeS5jYW1lbENhc2Uoa2V5KTtcXG5cXHRcXHRcXHRcXHRcXHQvLyBUcnkgdGhlIHN0cmluZyBhcyBhIGtleSBiZWZvcmUgYW55IG1hbmlwdWxhdGlvblxcblxcdFxcdFxcdFxcdFxcdGlmIChrZXkgaW4gY2FjaGUpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRuYW1lID0gW2tleSwgY2FtZWxdO1xcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gSWYgYSBrZXkgd2l0aCB0aGUgc3BhY2VzIGV4aXN0cywgdXNlIGl0LlxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIE90aGVyd2lzZSwgY3JlYXRlIGFuIGFycmF5IGJ5IG1hdGNoaW5nIG5vbi13aGl0ZXNwYWNlXFxuXFx0XFx0XFx0XFx0XFx0XFx0bmFtZSA9IGNhbWVsO1xcblxcdFxcdFxcdFxcdFxcdFxcdG5hbWUgPSBuYW1lIGluIGNhY2hlID8gW25hbWVdIDogbmFtZS5tYXRjaChybm90d2hpdGUpIHx8IFtdO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aSA9IG5hbWUubGVuZ3RoO1xcblxcdFxcdFxcdFxcdHdoaWxlIChpLS0pIHtcXG5cXHRcXHRcXHRcXHRcXHRkZWxldGUgY2FjaGVbbmFtZVtpXV07XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcdFxcdGhhc0RhdGE6IGZ1bmN0aW9uIGhhc0RhdGEob3duZXIpIHtcXG5cXHRcXHRcXHRyZXR1cm4gIWpRdWVyeS5pc0VtcHR5T2JqZWN0KHRoaXMuY2FjaGVbb3duZXJbdGhpcy5leHBhbmRvXV0gfHwge30pO1xcblxcdFxcdH0sXFxuXFx0XFx0ZGlzY2FyZDogZnVuY3Rpb24gZGlzY2FyZChvd25lcikge1xcblxcdFxcdFxcdGlmIChvd25lclt0aGlzLmV4cGFuZG9dKSB7XFxuXFx0XFx0XFx0XFx0ZGVsZXRlIHRoaXMuY2FjaGVbb3duZXJbdGhpcy5leHBhbmRvXV07XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9O1xcblxcdHZhciBkYXRhX3ByaXYgPSBuZXcgRGF0YSgpO1xcblxcblxcdHZhciBkYXRhX3VzZXIgPSBuZXcgRGF0YSgpO1xcblxcblxcdC8vXFx0SW1wbGVtZW50YXRpb24gU3VtbWFyeVxcblxcdC8vXFxuXFx0Ly9cXHQxLiBFbmZvcmNlIEFQSSBzdXJmYWNlIGFuZCBzZW1hbnRpYyBjb21wYXRpYmlsaXR5IHdpdGggMS45LnggYnJhbmNoXFxuXFx0Ly9cXHQyLiBJbXByb3ZlIHRoZSBtb2R1bGUncyBtYWludGFpbmFiaWxpdHkgYnkgcmVkdWNpbmcgdGhlIHN0b3JhZ2VcXG5cXHQvL1xcdFxcdHBhdGhzIHRvIGEgc2luZ2xlIG1lY2hhbmlzbS5cXG5cXHQvL1xcdDMuIFVzZSB0aGUgc2FtZSBzaW5nbGUgbWVjaGFuaXNtIHRvIHN1cHBvcnQgXFxcInByaXZhdGVcXFwiIGFuZCBcXFwidXNlclxcXCIgZGF0YS5cXG5cXHQvL1xcdDQuIF9OZXZlcl8gZXhwb3NlIFxcXCJwcml2YXRlXFxcIiBkYXRhIHRvIHVzZXIgY29kZSAoVE9ETzogRHJvcCBfZGF0YSwgX3JlbW92ZURhdGEpXFxuXFx0Ly9cXHQ1LiBBdm9pZCBleHBvc2luZyBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzIG9uIHVzZXIgb2JqZWN0cyAoZWcuIGV4cGFuZG8gcHJvcGVydGllcylcXG5cXHQvL1xcdDYuIFByb3ZpZGUgYSBjbGVhciBwYXRoIGZvciBpbXBsZW1lbnRhdGlvbiB1cGdyYWRlIHRvIFdlYWtNYXAgaW4gMjAxNFxcblxcblxcdHZhciByYnJhY2UgPSAvXig/OlxcXFx7W1xcXFx3XFxcXFddKlxcXFx9fFxcXFxbW1xcXFx3XFxcXFddKlxcXFxdKSQvLFxcblxcdCAgICBybXVsdGlEYXNoID0gLyhbQS1aXSkvZztcXG5cXG5cXHRmdW5jdGlvbiBkYXRhQXR0cihlbGVtLCBrZXksIGRhdGEpIHtcXG5cXHRcXHR2YXIgbmFtZTtcXG5cXG5cXHRcXHQvLyBJZiBub3RoaW5nIHdhcyBmb3VuZCBpbnRlcm5hbGx5LCB0cnkgdG8gZmV0Y2ggYW55XFxuXFx0XFx0Ly8gZGF0YSBmcm9tIHRoZSBIVE1MNSBkYXRhLSogYXR0cmlidXRlXFxuXFx0XFx0aWYgKGRhdGEgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxKSB7XFxuXFx0XFx0XFx0bmFtZSA9IFxcXCJkYXRhLVxcXCIgKyBrZXkucmVwbGFjZShybXVsdGlEYXNoLCBcXFwiLSQxXFxcIikudG9Mb3dlckNhc2UoKTtcXG5cXHRcXHRcXHRkYXRhID0gZWxlbS5nZXRBdHRyaWJ1dGUobmFtZSk7XFxuXFxuXFx0XFx0XFx0aWYgKHR5cGVvZiBkYXRhID09PSBcXFwic3RyaW5nXFxcIikge1xcblxcdFxcdFxcdFxcdHRyeSB7XFxuXFx0XFx0XFx0XFx0XFx0ZGF0YSA9IGRhdGEgPT09IFxcXCJ0cnVlXFxcIiA/IHRydWUgOiBkYXRhID09PSBcXFwiZmFsc2VcXFwiID8gZmFsc2UgOiBkYXRhID09PSBcXFwibnVsbFxcXCIgPyBudWxsIDpcXG5cXHRcXHRcXHRcXHRcXHQvLyBPbmx5IGNvbnZlcnQgdG8gYSBudW1iZXIgaWYgaXQgZG9lc24ndCBjaGFuZ2UgdGhlIHN0cmluZ1xcblxcdFxcdFxcdFxcdFxcdCtkYXRhICsgXFxcIlxcXCIgPT09IGRhdGEgPyArZGF0YSA6IHJicmFjZS50ZXN0KGRhdGEpID8galF1ZXJ5LnBhcnNlSlNPTihkYXRhKSA6IGRhdGE7XFxuXFx0XFx0XFx0XFx0fSBjYXRjaCAoZSkge31cXG5cXG5cXHRcXHRcXHRcXHQvLyBNYWtlIHN1cmUgd2Ugc2V0IHRoZSBkYXRhIHNvIGl0IGlzbid0IGNoYW5nZWQgbGF0ZXJcXG5cXHRcXHRcXHRcXHRkYXRhX3VzZXIuc2V0KGVsZW0sIGtleSwgZGF0YSk7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRkYXRhID0gdW5kZWZpbmVkO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0XFx0cmV0dXJuIGRhdGE7XFxuXFx0fVxcblxcblxcdGpRdWVyeS5leHRlbmQoe1xcblxcdFxcdGhhc0RhdGE6IGZ1bmN0aW9uIGhhc0RhdGEoZWxlbSkge1xcblxcdFxcdFxcdHJldHVybiBkYXRhX3VzZXIuaGFzRGF0YShlbGVtKSB8fCBkYXRhX3ByaXYuaGFzRGF0YShlbGVtKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdGRhdGE6IGZ1bmN0aW9uIGRhdGEoZWxlbSwgbmFtZSwgX2RhdGEpIHtcXG5cXHRcXHRcXHRyZXR1cm4gZGF0YV91c2VyLmFjY2VzcyhlbGVtLCBuYW1lLCBfZGF0YSk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRyZW1vdmVEYXRhOiBmdW5jdGlvbiByZW1vdmVEYXRhKGVsZW0sIG5hbWUpIHtcXG5cXHRcXHRcXHRkYXRhX3VzZXIucmVtb3ZlKGVsZW0sIG5hbWUpO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0Ly8gVE9ETzogTm93IHRoYXQgYWxsIGNhbGxzIHRvIF9kYXRhIGFuZCBfcmVtb3ZlRGF0YSBoYXZlIGJlZW4gcmVwbGFjZWRcXG5cXHRcXHQvLyB3aXRoIGRpcmVjdCBjYWxscyB0byBkYXRhX3ByaXYgbWV0aG9kcywgdGhlc2UgY2FuIGJlIGRlcHJlY2F0ZWQuXFxuXFx0XFx0X2RhdGE6IGZ1bmN0aW9uIF9kYXRhKGVsZW0sIG5hbWUsIGRhdGEpIHtcXG5cXHRcXHRcXHRyZXR1cm4gZGF0YV9wcml2LmFjY2VzcyhlbGVtLCBuYW1lLCBkYXRhKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9yZW1vdmVEYXRhOiBmdW5jdGlvbiBfcmVtb3ZlRGF0YShlbGVtLCBuYW1lKSB7XFxuXFx0XFx0XFx0ZGF0YV9wcml2LnJlbW92ZShlbGVtLCBuYW1lKTtcXG5cXHRcXHR9XFxuXFx0fSk7XFxuXFxuXFx0alF1ZXJ5LmZuLmV4dGVuZCh7XFxuXFx0XFx0ZGF0YTogZnVuY3Rpb24gZGF0YShrZXksIHZhbHVlKSB7XFxuXFx0XFx0XFx0dmFyIGksXFxuXFx0XFx0XFx0ICAgIG5hbWUsXFxuXFx0XFx0XFx0ICAgIGRhdGEsXFxuXFx0XFx0XFx0ICAgIGVsZW0gPSB0aGlzWzBdLFxcblxcdFxcdFxcdCAgICBhdHRycyA9IGVsZW0gJiYgZWxlbS5hdHRyaWJ1dGVzO1xcblxcblxcdFxcdFxcdC8vIEdldHMgYWxsIHZhbHVlc1xcblxcdFxcdFxcdGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xcblxcdFxcdFxcdFxcdGlmICh0aGlzLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdFxcdGRhdGEgPSBkYXRhX3VzZXIuZ2V0KGVsZW0pO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmIChlbGVtLm5vZGVUeXBlID09PSAxICYmICFkYXRhX3ByaXYuZ2V0KGVsZW0sIFxcXCJoYXNEYXRhQXR0cnNcXFwiKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGkgPSBhdHRycy5sZW5ndGg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0d2hpbGUgKGktLSkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IElFMTErXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gVGhlIGF0dHJzIGVsZW1lbnRzIGNhbiBiZSBudWxsICgjMTQ4OTQpXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKGF0dHJzW2ldKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bmFtZSA9IGF0dHJzW2ldLm5hbWU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKG5hbWUuaW5kZXhPZihcXFwiZGF0YS1cXFwiKSA9PT0gMCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG5hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKG5hbWUuc2xpY2UoNSkpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGFBdHRyKGVsZW0sIG5hbWUsIGRhdGFbbmFtZV0pO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdGRhdGFfcHJpdi5zZXQoZWxlbSwgXFxcImhhc0RhdGFBdHRyc1xcXCIsIHRydWUpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIGRhdGE7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFNldHMgbXVsdGlwbGUgdmFsdWVzXFxuXFx0XFx0XFx0aWYgKCh0eXBlb2Yga2V5ID09PSBcXFwidW5kZWZpbmVkXFxcIiA/IFxcXCJ1bmRlZmluZWRcXFwiIDogX3R5cGVvZihrZXkpKSA9PT0gXFxcIm9iamVjdFxcXCIpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHRkYXRhX3VzZXIuc2V0KHRoaXMsIGtleSk7XFxuXFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBhY2Nlc3ModGhpcywgZnVuY3Rpb24gKHZhbHVlKSB7XFxuXFx0XFx0XFx0XFx0dmFyIGRhdGEsXFxuXFx0XFx0XFx0XFx0ICAgIGNhbWVsS2V5ID0galF1ZXJ5LmNhbWVsQ2FzZShrZXkpO1xcblxcblxcdFxcdFxcdFxcdC8vIFRoZSBjYWxsaW5nIGpRdWVyeSBvYmplY3QgKGVsZW1lbnQgbWF0Y2hlcykgaXMgbm90IGVtcHR5XFxuXFx0XFx0XFx0XFx0Ly8gKGFuZCB0aGVyZWZvcmUgaGFzIGFuIGVsZW1lbnQgYXBwZWFycyBhdCB0aGlzWyAwIF0pIGFuZCB0aGVcXG5cXHRcXHRcXHRcXHQvLyBgdmFsdWVgIHBhcmFtZXRlciB3YXMgbm90IHVuZGVmaW5lZC4gQW4gZW1wdHkgalF1ZXJ5IG9iamVjdFxcblxcdFxcdFxcdFxcdC8vIHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGZvciBlbGVtID0gdGhpc1sgMCBdIHdoaWNoIHdpbGxcXG5cXHRcXHRcXHRcXHQvLyB0aHJvdyBhbiBleGNlcHRpb24gaWYgYW4gYXR0ZW1wdCB0byByZWFkIGEgZGF0YSBjYWNoZSBpcyBtYWRlLlxcblxcdFxcdFxcdFxcdGlmIChlbGVtICYmIHZhbHVlID09PSB1bmRlZmluZWQpIHtcXG5cXHRcXHRcXHRcXHRcXHQvLyBBdHRlbXB0IHRvIGdldCBkYXRhIGZyb20gdGhlIGNhY2hlXFxuXFx0XFx0XFx0XFx0XFx0Ly8gd2l0aCB0aGUga2V5IGFzLWlzXFxuXFx0XFx0XFx0XFx0XFx0ZGF0YSA9IGRhdGFfdXNlci5nZXQoZWxlbSwga2V5KTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoZGF0YSAhPT0gdW5kZWZpbmVkKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIGRhdGE7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdC8vIEF0dGVtcHQgdG8gZ2V0IGRhdGEgZnJvbSB0aGUgY2FjaGVcXG5cXHRcXHRcXHRcXHRcXHQvLyB3aXRoIHRoZSBrZXkgY2FtZWxpemVkXFxuXFx0XFx0XFx0XFx0XFx0ZGF0YSA9IGRhdGFfdXNlci5nZXQoZWxlbSwgY2FtZWxLZXkpO1xcblxcdFxcdFxcdFxcdFxcdGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gZGF0YTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gQXR0ZW1wdCB0byBcXFwiZGlzY292ZXJcXFwiIHRoZSBkYXRhIGluXFxuXFx0XFx0XFx0XFx0XFx0Ly8gSFRNTDUgY3VzdG9tIGRhdGEtKiBhdHRyc1xcblxcdFxcdFxcdFxcdFxcdGRhdGEgPSBkYXRhQXR0cihlbGVtLCBjYW1lbEtleSwgdW5kZWZpbmVkKTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoZGF0YSAhPT0gdW5kZWZpbmVkKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIGRhdGE7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdC8vIFdlIHRyaWVkIHJlYWxseSBoYXJkLCBidXQgdGhlIGRhdGEgZG9lc24ndCBleGlzdC5cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIFNldCB0aGUgZGF0YS4uLlxcblxcdFxcdFxcdFxcdHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gRmlyc3QsIGF0dGVtcHQgdG8gc3RvcmUgYSBjb3B5IG9yIHJlZmVyZW5jZSBvZiBhbnlcXG5cXHRcXHRcXHRcXHRcXHQvLyBkYXRhIHRoYXQgbWlnaHQndmUgYmVlbiBzdG9yZSB3aXRoIGEgY2FtZWxDYXNlZCBrZXkuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGRhdGEgPSBkYXRhX3VzZXIuZ2V0KHRoaXMsIGNhbWVsS2V5KTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBGb3IgSFRNTDUgZGF0YS0qIGF0dHJpYnV0ZSBpbnRlcm9wLCB3ZSBoYXZlIHRvXFxuXFx0XFx0XFx0XFx0XFx0Ly8gc3RvcmUgcHJvcGVydHkgbmFtZXMgd2l0aCBkYXNoZXMgaW4gYSBjYW1lbENhc2UgZm9ybS5cXG5cXHRcXHRcXHRcXHRcXHQvLyBUaGlzIG1pZ2h0IG5vdCBhcHBseSB0byBhbGwgcHJvcGVydGllcy4uLipcXG5cXHRcXHRcXHRcXHRcXHRkYXRhX3VzZXIuc2V0KHRoaXMsIGNhbWVsS2V5LCB2YWx1ZSk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gKi4uLiBJbiB0aGUgY2FzZSBvZiBwcm9wZXJ0aWVzIHRoYXQgbWlnaHQgX2FjdHVhbGx5X1xcblxcdFxcdFxcdFxcdFxcdC8vIGhhdmUgZGFzaGVzLCB3ZSBuZWVkIHRvIGFsc28gc3RvcmUgYSBjb3B5IG9mIHRoYXRcXG5cXHRcXHRcXHRcXHRcXHQvLyB1bmNoYW5nZWQgcHJvcGVydHkuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKGtleS5pbmRleE9mKFxcXCItXFxcIikgIT09IC0xICYmIGRhdGEgIT09IHVuZGVmaW5lZCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGRhdGFfdXNlci5zZXQodGhpcywga2V5LCB2YWx1ZSk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSwgbnVsbCwgdHJ1ZSk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRyZW1vdmVEYXRhOiBmdW5jdGlvbiByZW1vdmVEYXRhKGtleSkge1xcblxcdFxcdFxcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdGRhdGFfdXNlci5yZW1vdmUodGhpcywga2V5KTtcXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHR9XFxuXFx0fSk7XFxuXFxuXFx0alF1ZXJ5LmV4dGVuZCh7XFxuXFx0XFx0cXVldWU6IGZ1bmN0aW9uIHF1ZXVlKGVsZW0sIHR5cGUsIGRhdGEpIHtcXG5cXHRcXHRcXHR2YXIgcXVldWU7XFxuXFxuXFx0XFx0XFx0aWYgKGVsZW0pIHtcXG5cXHRcXHRcXHRcXHR0eXBlID0gKHR5cGUgfHwgXFxcImZ4XFxcIikgKyBcXFwicXVldWVcXFwiO1xcblxcdFxcdFxcdFxcdHF1ZXVlID0gZGF0YV9wcml2LmdldChlbGVtLCB0eXBlKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBTcGVlZCB1cCBkZXF1ZXVlIGJ5IGdldHRpbmcgb3V0IHF1aWNrbHkgaWYgdGhpcyBpcyBqdXN0IGEgbG9va3VwXFxuXFx0XFx0XFx0XFx0aWYgKGRhdGEpIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIXF1ZXVlIHx8IGpRdWVyeS5pc0FycmF5KGRhdGEpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cXVldWUgPSBkYXRhX3ByaXYuYWNjZXNzKGVsZW0sIHR5cGUsIGpRdWVyeS5tYWtlQXJyYXkoZGF0YSkpO1xcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cXVldWUucHVzaChkYXRhKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHJldHVybiBxdWV1ZSB8fCBbXTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRkZXF1ZXVlOiBmdW5jdGlvbiBkZXF1ZXVlKGVsZW0sIHR5cGUpIHtcXG5cXHRcXHRcXHR0eXBlID0gdHlwZSB8fCBcXFwiZnhcXFwiO1xcblxcblxcdFxcdFxcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZShlbGVtLCB0eXBlKSxcXG5cXHRcXHRcXHQgICAgc3RhcnRMZW5ndGggPSBxdWV1ZS5sZW5ndGgsXFxuXFx0XFx0XFx0ICAgIGZuID0gcXVldWUuc2hpZnQoKSxcXG5cXHRcXHRcXHQgICAgaG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoZWxlbSwgdHlwZSksXFxuXFx0XFx0XFx0ICAgIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xcblxcdFxcdFxcdFxcdGpRdWVyeS5kZXF1ZXVlKGVsZW0sIHR5cGUpO1xcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0XFx0Ly8gSWYgdGhlIGZ4IHF1ZXVlIGlzIGRlcXVldWVkLCBhbHdheXMgcmVtb3ZlIHRoZSBwcm9ncmVzcyBzZW50aW5lbFxcblxcdFxcdFxcdGlmIChmbiA9PT0gXFxcImlucHJvZ3Jlc3NcXFwiKSB7XFxuXFx0XFx0XFx0XFx0Zm4gPSBxdWV1ZS5zaGlmdCgpO1xcblxcdFxcdFxcdFxcdHN0YXJ0TGVuZ3RoLS07XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmIChmbikge1xcblxcblxcdFxcdFxcdFxcdC8vIEFkZCBhIHByb2dyZXNzIHNlbnRpbmVsIHRvIHByZXZlbnQgdGhlIGZ4IHF1ZXVlIGZyb20gYmVpbmdcXG5cXHRcXHRcXHRcXHQvLyBhdXRvbWF0aWNhbGx5IGRlcXVldWVkXFxuXFx0XFx0XFx0XFx0aWYgKHR5cGUgPT09IFxcXCJmeFxcXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRxdWV1ZS51bnNoaWZ0KFxcXCJpbnByb2dyZXNzXFxcIik7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIENsZWFyIHVwIHRoZSBsYXN0IHF1ZXVlIHN0b3AgZnVuY3Rpb25cXG5cXHRcXHRcXHRcXHRkZWxldGUgaG9va3Muc3RvcDtcXG5cXHRcXHRcXHRcXHRmbi5jYWxsKGVsZW0sIG5leHQsIGhvb2tzKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCFzdGFydExlbmd0aCAmJiBob29rcykge1xcblxcdFxcdFxcdFxcdGhvb2tzLmVtcHR5LmZpcmUoKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyBOb3QgcHVibGljIC0gZ2VuZXJhdGUgYSBxdWV1ZUhvb2tzIG9iamVjdCwgb3IgcmV0dXJuIHRoZSBjdXJyZW50IG9uZVxcblxcdFxcdF9xdWV1ZUhvb2tzOiBmdW5jdGlvbiBfcXVldWVIb29rcyhlbGVtLCB0eXBlKSB7XFxuXFx0XFx0XFx0dmFyIGtleSA9IHR5cGUgKyBcXFwicXVldWVIb29rc1xcXCI7XFxuXFx0XFx0XFx0cmV0dXJuIGRhdGFfcHJpdi5nZXQoZWxlbSwga2V5KSB8fCBkYXRhX3ByaXYuYWNjZXNzKGVsZW0sIGtleSwge1xcblxcdFxcdFxcdFxcdGVtcHR5OiBqUXVlcnkuQ2FsbGJhY2tzKFxcXCJvbmNlIG1lbW9yeVxcXCIpLmFkZChmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZGF0YV9wcml2LnJlbW92ZShlbGVtLCBbdHlwZSArIFxcXCJxdWV1ZVxcXCIsIGtleV0pO1xcblxcdFxcdFxcdFxcdH0pXFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0fVxcblxcdH0pO1xcblxcblxcdGpRdWVyeS5mbi5leHRlbmQoe1xcblxcdFxcdHF1ZXVlOiBmdW5jdGlvbiBxdWV1ZSh0eXBlLCBkYXRhKSB7XFxuXFx0XFx0XFx0dmFyIHNldHRlciA9IDI7XFxuXFxuXFx0XFx0XFx0aWYgKHR5cGVvZiB0eXBlICE9PSBcXFwic3RyaW5nXFxcIikge1xcblxcdFxcdFxcdFxcdGRhdGEgPSB0eXBlO1xcblxcdFxcdFxcdFxcdHR5cGUgPSBcXFwiZnhcXFwiO1xcblxcdFxcdFxcdFxcdHNldHRlci0tO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA8IHNldHRlcikge1xcblxcdFxcdFxcdFxcdHJldHVybiBqUXVlcnkucXVldWUodGhpc1swXSwgdHlwZSk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBkYXRhID09PSB1bmRlZmluZWQgPyB0aGlzIDogdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUodGhpcywgdHlwZSwgZGF0YSk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gRW5zdXJlIGEgaG9va3MgZm9yIHRoaXMgcXVldWVcXG5cXHRcXHRcXHRcXHRqUXVlcnkuX3F1ZXVlSG9va3ModGhpcywgdHlwZSk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKHR5cGUgPT09IFxcXCJmeFxcXCIgJiYgcXVldWVbMF0gIT09IFxcXCJpbnByb2dyZXNzXFxcIikge1xcblxcdFxcdFxcdFxcdFxcdGpRdWVyeS5kZXF1ZXVlKHRoaXMsIHR5cGUpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHR9LFxcblxcdFxcdGRlcXVldWU6IGZ1bmN0aW9uIGRlcXVldWUodHlwZSkge1xcblxcdFxcdFxcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdGpRdWVyeS5kZXF1ZXVlKHRoaXMsIHR5cGUpO1xcblxcdFxcdFxcdH0pO1xcblxcdFxcdH0sXFxuXFx0XFx0Y2xlYXJRdWV1ZTogZnVuY3Rpb24gY2xlYXJRdWV1ZSh0eXBlKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMucXVldWUodHlwZSB8fCBcXFwiZnhcXFwiLCBbXSk7XFxuXFx0XFx0fSxcXG5cXHRcXHQvLyBHZXQgYSBwcm9taXNlIHJlc29sdmVkIHdoZW4gcXVldWVzIG9mIGEgY2VydGFpbiB0eXBlXFxuXFx0XFx0Ly8gYXJlIGVtcHRpZWQgKGZ4IGlzIHRoZSB0eXBlIGJ5IGRlZmF1bHQpXFxuXFx0XFx0cHJvbWlzZTogZnVuY3Rpb24gcHJvbWlzZSh0eXBlLCBvYmopIHtcXG5cXHRcXHRcXHR2YXIgdG1wLFxcblxcdFxcdFxcdCAgICBjb3VudCA9IDEsXFxuXFx0XFx0XFx0ICAgIGRlZmVyID0galF1ZXJ5LkRlZmVycmVkKCksXFxuXFx0XFx0XFx0ICAgIGVsZW1lbnRzID0gdGhpcyxcXG5cXHRcXHRcXHQgICAgaSA9IHRoaXMubGVuZ3RoLFxcblxcdFxcdFxcdCAgICByZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZSgpIHtcXG5cXHRcXHRcXHRcXHRpZiAoISAtLWNvdW50KSB7XFxuXFx0XFx0XFx0XFx0XFx0ZGVmZXIucmVzb2x2ZVdpdGgoZWxlbWVudHMsIFtlbGVtZW50c10pO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdFxcdGlmICh0eXBlb2YgdHlwZSAhPT0gXFxcInN0cmluZ1xcXCIpIHtcXG5cXHRcXHRcXHRcXHRvYmogPSB0eXBlO1xcblxcdFxcdFxcdFxcdHR5cGUgPSB1bmRlZmluZWQ7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHR5cGUgPSB0eXBlIHx8IFxcXCJmeFxcXCI7XFxuXFxuXFx0XFx0XFx0d2hpbGUgKGktLSkge1xcblxcdFxcdFxcdFxcdHRtcCA9IGRhdGFfcHJpdi5nZXQoZWxlbWVudHNbaV0sIHR5cGUgKyBcXFwicXVldWVIb29rc1xcXCIpO1xcblxcdFxcdFxcdFxcdGlmICh0bXAgJiYgdG1wLmVtcHR5KSB7XFxuXFx0XFx0XFx0XFx0XFx0Y291bnQrKztcXG5cXHRcXHRcXHRcXHRcXHR0bXAuZW1wdHkuYWRkKHJlc29sdmUpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmVzb2x2ZSgpO1xcblxcdFxcdFxcdHJldHVybiBkZWZlci5wcm9taXNlKG9iaik7XFxuXFx0XFx0fVxcblxcdH0pO1xcblxcdHZhciBwbnVtID0gL1srLV0/KD86XFxcXGQqXFxcXC58KVxcXFxkKyg/OltlRV1bKy1dP1xcXFxkK3wpLy5zb3VyY2U7XFxuXFxuXFx0dmFyIGNzc0V4cGFuZCA9IFtcXFwiVG9wXFxcIiwgXFxcIlJpZ2h0XFxcIiwgXFxcIkJvdHRvbVxcXCIsIFxcXCJMZWZ0XFxcIl07XFxuXFxuXFx0dmFyIGlzSGlkZGVuID0gZnVuY3Rpb24gaXNIaWRkZW4oZWxlbSwgZWwpIHtcXG5cXHRcXHQvLyBpc0hpZGRlbiBtaWdodCBiZSBjYWxsZWQgZnJvbSBqUXVlcnkjZmlsdGVyIGZ1bmN0aW9uO1xcblxcdFxcdC8vIGluIHRoYXQgY2FzZSwgZWxlbWVudCB3aWxsIGJlIHNlY29uZCBhcmd1bWVudFxcblxcdFxcdGVsZW0gPSBlbCB8fCBlbGVtO1xcblxcdFxcdHJldHVybiBqUXVlcnkuY3NzKGVsZW0sIFxcXCJkaXNwbGF5XFxcIikgPT09IFxcXCJub25lXFxcIiB8fCAhalF1ZXJ5LmNvbnRhaW5zKGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSk7XFxuXFx0fTtcXG5cXG5cXHR2YXIgcmNoZWNrYWJsZVR5cGUgPSAvXig/OmNoZWNrYm94fHJhZGlvKSQvaTtcXG5cXG5cXHQoZnVuY3Rpb24gKCkge1xcblxcdFxcdHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcXG5cXHRcXHQgICAgZGl2ID0gZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwiZGl2XFxcIikpLFxcblxcdFxcdCAgICBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXFxcImlucHV0XFxcIik7XFxuXFxuXFx0XFx0Ly8gU3VwcG9ydDogU2FmYXJpPD01LjFcXG5cXHRcXHQvLyBDaGVjayBzdGF0ZSBsb3N0IGlmIHRoZSBuYW1lIGlzIHNldCAoIzExMjE3KVxcblxcdFxcdC8vIFN1cHBvcnQ6IFdpbmRvd3MgV2ViIEFwcHMgKFdXQSlcXG5cXHRcXHQvLyBgbmFtZWAgYW5kIGB0eXBlYCBtdXN0IHVzZSAuc2V0QXR0cmlidXRlIGZvciBXV0EgKCMxNDkwMSlcXG5cXHRcXHRpbnB1dC5zZXRBdHRyaWJ1dGUoXFxcInR5cGVcXFwiLCBcXFwicmFkaW9cXFwiKTtcXG5cXHRcXHRpbnB1dC5zZXRBdHRyaWJ1dGUoXFxcImNoZWNrZWRcXFwiLCBcXFwiY2hlY2tlZFxcXCIpO1xcblxcdFxcdGlucHV0LnNldEF0dHJpYnV0ZShcXFwibmFtZVxcXCIsIFxcXCJ0XFxcIik7XFxuXFxuXFx0XFx0ZGl2LmFwcGVuZENoaWxkKGlucHV0KTtcXG5cXG5cXHRcXHQvLyBTdXBwb3J0OiBTYWZhcmk8PTUuMSwgQW5kcm9pZDw0LjJcXG5cXHRcXHQvLyBPbGRlciBXZWJLaXQgZG9lc24ndCBjbG9uZSBjaGVja2VkIHN0YXRlIGNvcnJlY3RseSBpbiBmcmFnbWVudHNcXG5cXHRcXHRzdXBwb3J0LmNoZWNrQ2xvbmUgPSBkaXYuY2xvbmVOb2RlKHRydWUpLmNsb25lTm9kZSh0cnVlKS5sYXN0Q2hpbGQuY2hlY2tlZDtcXG5cXG5cXHRcXHQvLyBTdXBwb3J0OiBJRTw9MTErXFxuXFx0XFx0Ly8gTWFrZSBzdXJlIHRleHRhcmVhIChhbmQgY2hlY2tib3gpIGRlZmF1bHRWYWx1ZSBpcyBwcm9wZXJseSBjbG9uZWRcXG5cXHRcXHRkaXYuaW5uZXJIVE1MID0gXFxcIjx0ZXh0YXJlYT54PC90ZXh0YXJlYT5cXFwiO1xcblxcdFxcdHN1cHBvcnQubm9DbG9uZUNoZWNrZWQgPSAhIWRpdi5jbG9uZU5vZGUodHJ1ZSkubGFzdENoaWxkLmRlZmF1bHRWYWx1ZTtcXG5cXHR9KSgpO1xcblxcdHZhciBzdHJ1bmRlZmluZWQgPSB0eXBlb2YgdW5kZWZpbmVkID09PSBcXFwidW5kZWZpbmVkXFxcIiA/IFxcXCJ1bmRlZmluZWRcXFwiIDogX3R5cGVvZih1bmRlZmluZWQpO1xcblxcblxcdHN1cHBvcnQuZm9jdXNpbkJ1YmJsZXMgPSBcXFwib25mb2N1c2luXFxcIiBpbiB3aW5kb3c7XFxuXFxuXFx0dmFyIHJrZXlFdmVudCA9IC9ea2V5LyxcXG5cXHQgICAgcm1vdXNlRXZlbnQgPSAvXig/Om1vdXNlfHBvaW50ZXJ8Y29udGV4dG1lbnUpfGNsaWNrLyxcXG5cXHQgICAgcmZvY3VzTW9ycGggPSAvXig/OmZvY3VzaW5mb2N1c3xmb2N1c291dGJsdXIpJC8sXFxuXFx0ICAgIHJ0eXBlbmFtZXNwYWNlID0gL14oW14uXSopKD86XFxcXC4oLispfCkkLztcXG5cXG5cXHRmdW5jdGlvbiByZXR1cm5UcnVlKCkge1xcblxcdFxcdHJldHVybiB0cnVlO1xcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiByZXR1cm5GYWxzZSgpIHtcXG5cXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIHNhZmVBY3RpdmVFbGVtZW50KCkge1xcblxcdFxcdHRyeSB7XFxuXFx0XFx0XFx0cmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XFxuXFx0XFx0fSBjYXRjaCAoZXJyKSB7fVxcblxcdH1cXG5cXG5cXHQvKlxcbiAgKiBIZWxwZXIgZnVuY3Rpb25zIGZvciBtYW5hZ2luZyBldmVudHMgLS0gbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBpbnRlcmZhY2UuXFxuICAqIFByb3BzIHRvIERlYW4gRWR3YXJkcycgYWRkRXZlbnQgbGlicmFyeSBmb3IgbWFueSBvZiB0aGUgaWRlYXMuXFxuICAqL1xcblxcdGpRdWVyeS5ldmVudCA9IHtcXG5cXG5cXHRcXHRnbG9iYWw6IHt9LFxcblxcblxcdFxcdGFkZDogZnVuY3Rpb24gYWRkKGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBkYXRhLCBzZWxlY3Rvcikge1xcblxcblxcdFxcdFxcdHZhciBoYW5kbGVPYmpJbixcXG5cXHRcXHRcXHQgICAgZXZlbnRIYW5kbGUsXFxuXFx0XFx0XFx0ICAgIHRtcCxcXG5cXHRcXHRcXHQgICAgZXZlbnRzLFxcblxcdFxcdFxcdCAgICB0LFxcblxcdFxcdFxcdCAgICBoYW5kbGVPYmosXFxuXFx0XFx0XFx0ICAgIHNwZWNpYWwsXFxuXFx0XFx0XFx0ICAgIGhhbmRsZXJzLFxcblxcdFxcdFxcdCAgICB0eXBlLFxcblxcdFxcdFxcdCAgICBuYW1lc3BhY2VzLFxcblxcdFxcdFxcdCAgICBvcmlnVHlwZSxcXG5cXHRcXHRcXHQgICAgZWxlbURhdGEgPSBkYXRhX3ByaXYuZ2V0KGVsZW0pO1xcblxcblxcdFxcdFxcdC8vIERvbid0IGF0dGFjaCBldmVudHMgdG8gbm9EYXRhIG9yIHRleHQvY29tbWVudCBub2RlcyAoYnV0IGFsbG93IHBsYWluIG9iamVjdHMpXFxuXFx0XFx0XFx0aWYgKCFlbGVtRGF0YSkge1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGFuIG9iamVjdCBvZiBjdXN0b20gZGF0YSBpbiBsaWV1IG9mIHRoZSBoYW5kbGVyXFxuXFx0XFx0XFx0aWYgKGhhbmRsZXIuaGFuZGxlcikge1xcblxcdFxcdFxcdFxcdGhhbmRsZU9iakluID0gaGFuZGxlcjtcXG5cXHRcXHRcXHRcXHRoYW5kbGVyID0gaGFuZGxlT2JqSW4uaGFuZGxlcjtcXG5cXHRcXHRcXHRcXHRzZWxlY3RvciA9IGhhbmRsZU9iakluLnNlbGVjdG9yO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBNYWtlIHN1cmUgdGhhdCB0aGUgaGFuZGxlciBoYXMgYSB1bmlxdWUgSUQsIHVzZWQgdG8gZmluZC9yZW1vdmUgaXQgbGF0ZXJcXG5cXHRcXHRcXHRpZiAoIWhhbmRsZXIuZ3VpZCkge1xcblxcdFxcdFxcdFxcdGhhbmRsZXIuZ3VpZCA9IGpRdWVyeS5ndWlkKys7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIEluaXQgdGhlIGVsZW1lbnQncyBldmVudCBzdHJ1Y3R1cmUgYW5kIG1haW4gaGFuZGxlciwgaWYgdGhpcyBpcyB0aGUgZmlyc3RcXG5cXHRcXHRcXHRpZiAoIShldmVudHMgPSBlbGVtRGF0YS5ldmVudHMpKSB7XFxuXFx0XFx0XFx0XFx0ZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzID0ge307XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICghKGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlKSkge1xcblxcdFxcdFxcdFxcdGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlID0gZnVuY3Rpb24gKGUpIHtcXG5cXHRcXHRcXHRcXHRcXHQvLyBEaXNjYXJkIHRoZSBzZWNvbmQgZXZlbnQgb2YgYSBqUXVlcnkuZXZlbnQudHJpZ2dlcigpIGFuZFxcblxcdFxcdFxcdFxcdFxcdC8vIHdoZW4gYW4gZXZlbnQgaXMgY2FsbGVkIGFmdGVyIGEgcGFnZSBoYXMgdW5sb2FkZWRcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gKHR5cGVvZiBqUXVlcnkgPT09IFxcXCJ1bmRlZmluZWRcXFwiID8gXFxcInVuZGVmaW5lZFxcXCIgOiBfdHlwZW9mKGpRdWVyeSkpICE9PSBzdHJ1bmRlZmluZWQgJiYgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCAhPT0gZS50eXBlID8galF1ZXJ5LmV2ZW50LmRpc3BhdGNoLmFwcGx5KGVsZW0sIGFyZ3VtZW50cykgOiB1bmRlZmluZWQ7XFxuXFx0XFx0XFx0XFx0fTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gSGFuZGxlIG11bHRpcGxlIGV2ZW50cyBzZXBhcmF0ZWQgYnkgYSBzcGFjZVxcblxcdFxcdFxcdHR5cGVzID0gKHR5cGVzIHx8IFxcXCJcXFwiKS5tYXRjaChybm90d2hpdGUpIHx8IFtcXFwiXFxcIl07XFxuXFx0XFx0XFx0dCA9IHR5cGVzLmxlbmd0aDtcXG5cXHRcXHRcXHR3aGlsZSAodC0tKSB7XFxuXFx0XFx0XFx0XFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyh0eXBlc1t0XSkgfHwgW107XFxuXFx0XFx0XFx0XFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWzFdO1xcblxcdFxcdFxcdFxcdG5hbWVzcGFjZXMgPSAodG1wWzJdIHx8IFxcXCJcXFwiKS5zcGxpdChcXFwiLlxcXCIpLnNvcnQoKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBUaGVyZSAqbXVzdCogYmUgYSB0eXBlLCBubyBhdHRhY2hpbmcgbmFtZXNwYWNlLW9ubHkgaGFuZGxlcnNcXG5cXHRcXHRcXHRcXHRpZiAoIXR5cGUpIHtcXG5cXHRcXHRcXHRcXHRcXHRjb250aW51ZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSWYgZXZlbnQgY2hhbmdlcyBpdHMgdHlwZSwgdXNlIHRoZSBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzIGZvciB0aGUgY2hhbmdlZCB0eXBlXFxuXFx0XFx0XFx0XFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsW3R5cGVdIHx8IHt9O1xcblxcblxcdFxcdFxcdFxcdC8vIElmIHNlbGVjdG9yIGRlZmluZWQsIGRldGVybWluZSBzcGVjaWFsIGV2ZW50IGFwaSB0eXBlLCBvdGhlcndpc2UgZ2l2ZW4gdHlwZVxcblxcdFxcdFxcdFxcdHR5cGUgPSAoc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUpIHx8IHR5cGU7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gVXBkYXRlIHNwZWNpYWwgYmFzZWQgb24gbmV3bHkgcmVzZXQgdHlwZVxcblxcdFxcdFxcdFxcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFt0eXBlXSB8fCB7fTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBoYW5kbGVPYmogaXMgcGFzc2VkIHRvIGFsbCBldmVudCBoYW5kbGVyc1xcblxcdFxcdFxcdFxcdGhhbmRsZU9iaiA9IGpRdWVyeS5leHRlbmQoe1xcblxcdFxcdFxcdFxcdFxcdHR5cGU6IHR5cGUsXFxuXFx0XFx0XFx0XFx0XFx0b3JpZ1R5cGU6IG9yaWdUeXBlLFxcblxcdFxcdFxcdFxcdFxcdGRhdGE6IGRhdGEsXFxuXFx0XFx0XFx0XFx0XFx0aGFuZGxlcjogaGFuZGxlcixcXG5cXHRcXHRcXHRcXHRcXHRndWlkOiBoYW5kbGVyLmd1aWQsXFxuXFx0XFx0XFx0XFx0XFx0c2VsZWN0b3I6IHNlbGVjdG9yLFxcblxcdFxcdFxcdFxcdFxcdG5lZWRzQ29udGV4dDogc2VsZWN0b3IgJiYgalF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0LnRlc3Qoc2VsZWN0b3IpLFxcblxcdFxcdFxcdFxcdFxcdG5hbWVzcGFjZTogbmFtZXNwYWNlcy5qb2luKFxcXCIuXFxcIilcXG5cXHRcXHRcXHRcXHR9LCBoYW5kbGVPYmpJbik7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSW5pdCB0aGUgZXZlbnQgaGFuZGxlciBxdWV1ZSBpZiB3ZSdyZSB0aGUgZmlyc3RcXG5cXHRcXHRcXHRcXHRpZiAoIShoYW5kbGVycyA9IGV2ZW50c1t0eXBlXSkpIHtcXG5cXHRcXHRcXHRcXHRcXHRoYW5kbGVycyA9IGV2ZW50c1t0eXBlXSA9IFtdO1xcblxcdFxcdFxcdFxcdFxcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQgPSAwO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIE9ubHkgdXNlIGFkZEV2ZW50TGlzdGVuZXIgaWYgdGhlIHNwZWNpYWwgZXZlbnRzIGhhbmRsZXIgcmV0dXJucyBmYWxzZVxcblxcdFxcdFxcdFxcdFxcdGlmICghc3BlY2lhbC5zZXR1cCB8fCBzcGVjaWFsLnNldHVwLmNhbGwoZWxlbSwgZGF0YSwgbmFtZXNwYWNlcywgZXZlbnRIYW5kbGUpID09PSBmYWxzZSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChlbGVtLmFkZEV2ZW50TGlzdGVuZXIpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRlbGVtLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZXZlbnRIYW5kbGUsIGZhbHNlKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAoc3BlY2lhbC5hZGQpIHtcXG5cXHRcXHRcXHRcXHRcXHRzcGVjaWFsLmFkZC5jYWxsKGVsZW0sIGhhbmRsZU9iaik7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCFoYW5kbGVPYmouaGFuZGxlci5ndWlkKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCA9IGhhbmRsZXIuZ3VpZDtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIEFkZCB0byB0aGUgZWxlbWVudCdzIGhhbmRsZXIgbGlzdCwgZGVsZWdhdGVzIGluIGZyb250XFxuXFx0XFx0XFx0XFx0aWYgKHNlbGVjdG9yKSB7XFxuXFx0XFx0XFx0XFx0XFx0aGFuZGxlcnMuc3BsaWNlKGhhbmRsZXJzLmRlbGVnYXRlQ291bnQrKywgMCwgaGFuZGxlT2JqKTtcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdGhhbmRsZXJzLnB1c2goaGFuZGxlT2JqKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gS2VlcCB0cmFjayBvZiB3aGljaCBldmVudHMgaGF2ZSBldmVyIGJlZW4gdXNlZCwgZm9yIGV2ZW50IG9wdGltaXphdGlvblxcblxcdFxcdFxcdFxcdGpRdWVyeS5ldmVudC5nbG9iYWxbdHlwZV0gPSB0cnVlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcblxcdFxcdC8vIERldGFjaCBhbiBldmVudCBvciBzZXQgb2YgZXZlbnRzIGZyb20gYW4gZWxlbWVudFxcblxcdFxcdHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBzZWxlY3RvciwgbWFwcGVkVHlwZXMpIHtcXG5cXG5cXHRcXHRcXHR2YXIgaixcXG5cXHRcXHRcXHQgICAgb3JpZ0NvdW50LFxcblxcdFxcdFxcdCAgICB0bXAsXFxuXFx0XFx0XFx0ICAgIGV2ZW50cyxcXG5cXHRcXHRcXHQgICAgdCxcXG5cXHRcXHRcXHQgICAgaGFuZGxlT2JqLFxcblxcdFxcdFxcdCAgICBzcGVjaWFsLFxcblxcdFxcdFxcdCAgICBoYW5kbGVycyxcXG5cXHRcXHRcXHQgICAgdHlwZSxcXG5cXHRcXHRcXHQgICAgbmFtZXNwYWNlcyxcXG5cXHRcXHRcXHQgICAgb3JpZ1R5cGUsXFxuXFx0XFx0XFx0ICAgIGVsZW1EYXRhID0gZGF0YV9wcml2Lmhhc0RhdGEoZWxlbSkgJiYgZGF0YV9wcml2LmdldChlbGVtKTtcXG5cXG5cXHRcXHRcXHRpZiAoIWVsZW1EYXRhIHx8ICEoZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzKSkge1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gT25jZSBmb3IgZWFjaCB0eXBlLm5hbWVzcGFjZSBpbiB0eXBlczsgdHlwZSBtYXkgYmUgb21pdHRlZFxcblxcdFxcdFxcdHR5cGVzID0gKHR5cGVzIHx8IFxcXCJcXFwiKS5tYXRjaChybm90d2hpdGUpIHx8IFtcXFwiXFxcIl07XFxuXFx0XFx0XFx0dCA9IHR5cGVzLmxlbmd0aDtcXG5cXHRcXHRcXHR3aGlsZSAodC0tKSB7XFxuXFx0XFx0XFx0XFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyh0eXBlc1t0XSkgfHwgW107XFxuXFx0XFx0XFx0XFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWzFdO1xcblxcdFxcdFxcdFxcdG5hbWVzcGFjZXMgPSAodG1wWzJdIHx8IFxcXCJcXFwiKS5zcGxpdChcXFwiLlxcXCIpLnNvcnQoKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBVbmJpbmQgYWxsIGV2ZW50cyAob24gdGhpcyBuYW1lc3BhY2UsIGlmIHByb3ZpZGVkKSBmb3IgdGhlIGVsZW1lbnRcXG5cXHRcXHRcXHRcXHRpZiAoIXR5cGUpIHtcXG5cXHRcXHRcXHRcXHRcXHRmb3IgKHR5cGUgaW4gZXZlbnRzKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0alF1ZXJ5LmV2ZW50LnJlbW92ZShlbGVtLCB0eXBlICsgdHlwZXNbdF0sIGhhbmRsZXIsIHNlbGVjdG9yLCB0cnVlKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0Y29udGludWU7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFt0eXBlXSB8fCB7fTtcXG5cXHRcXHRcXHRcXHR0eXBlID0gKHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlKSB8fCB0eXBlO1xcblxcdFxcdFxcdFxcdGhhbmRsZXJzID0gZXZlbnRzW3R5cGVdIHx8IFtdO1xcblxcdFxcdFxcdFxcdHRtcCA9IHRtcFsyXSAmJiBuZXcgUmVnRXhwKFxcXCIoXnxcXFxcXFxcXC4pXFxcIiArIG5hbWVzcGFjZXMuam9pbihcXFwiXFxcXFxcXFwuKD86LipcXFxcXFxcXC58KVxcXCIpICsgXFxcIihcXFxcXFxcXC58JClcXFwiKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBSZW1vdmUgbWF0Y2hpbmcgZXZlbnRzXFxuXFx0XFx0XFx0XFx0b3JpZ0NvdW50ID0gaiA9IGhhbmRsZXJzLmxlbmd0aDtcXG5cXHRcXHRcXHRcXHR3aGlsZSAoai0tKSB7XFxuXFx0XFx0XFx0XFx0XFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbal07XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKChtYXBwZWRUeXBlcyB8fCBvcmlnVHlwZSA9PT0gaGFuZGxlT2JqLm9yaWdUeXBlKSAmJiAoIWhhbmRsZXIgfHwgaGFuZGxlci5ndWlkID09PSBoYW5kbGVPYmouZ3VpZCkgJiYgKCF0bXAgfHwgdG1wLnRlc3QoaGFuZGxlT2JqLm5hbWVzcGFjZSkpICYmICghc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09IGhhbmRsZU9iai5zZWxlY3RvciB8fCBzZWxlY3RvciA9PT0gXFxcIioqXFxcIiAmJiBoYW5kbGVPYmouc2VsZWN0b3IpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aGFuZGxlcnMuc3BsaWNlKGosIDEpO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChoYW5kbGVPYmouc2VsZWN0b3IpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LS07XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChzcGVjaWFsLnJlbW92ZSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHNwZWNpYWwucmVtb3ZlLmNhbGwoZWxlbSwgaGFuZGxlT2JqKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBSZW1vdmUgZ2VuZXJpYyBldmVudCBoYW5kbGVyIGlmIHdlIHJlbW92ZWQgc29tZXRoaW5nIGFuZCBubyBtb3JlIGhhbmRsZXJzIGV4aXN0XFxuXFx0XFx0XFx0XFx0Ly8gKGF2b2lkcyBwb3RlbnRpYWwgZm9yIGVuZGxlc3MgcmVjdXJzaW9uIGR1cmluZyByZW1vdmFsIG9mIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMpXFxuXFx0XFx0XFx0XFx0aWYgKG9yaWdDb3VudCAmJiAhaGFuZGxlcnMubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCFzcGVjaWFsLnRlYXJkb3duIHx8IHNwZWNpYWwudGVhcmRvd24uY2FsbChlbGVtLCBuYW1lc3BhY2VzLCBlbGVtRGF0YS5oYW5kbGUpID09PSBmYWxzZSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGpRdWVyeS5yZW1vdmVFdmVudChlbGVtLCB0eXBlLCBlbGVtRGF0YS5oYW5kbGUpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRkZWxldGUgZXZlbnRzW3R5cGVdO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gUmVtb3ZlIHRoZSBleHBhbmRvIGlmIGl0J3Mgbm8gbG9uZ2VyIHVzZWRcXG5cXHRcXHRcXHRpZiAoalF1ZXJ5LmlzRW1wdHlPYmplY3QoZXZlbnRzKSkge1xcblxcdFxcdFxcdFxcdGRlbGV0ZSBlbGVtRGF0YS5oYW5kbGU7XFxuXFx0XFx0XFx0XFx0ZGF0YV9wcml2LnJlbW92ZShlbGVtLCBcXFwiZXZlbnRzXFxcIik7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFxuXFx0XFx0dHJpZ2dlcjogZnVuY3Rpb24gdHJpZ2dlcihldmVudCwgZGF0YSwgZWxlbSwgb25seUhhbmRsZXJzKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGksXFxuXFx0XFx0XFx0ICAgIGN1cixcXG5cXHRcXHRcXHQgICAgdG1wLFxcblxcdFxcdFxcdCAgICBidWJibGVUeXBlLFxcblxcdFxcdFxcdCAgICBvbnR5cGUsXFxuXFx0XFx0XFx0ICAgIGhhbmRsZSxcXG5cXHRcXHRcXHQgICAgc3BlY2lhbCxcXG5cXHRcXHRcXHQgICAgZXZlbnRQYXRoID0gW2VsZW0gfHwgZG9jdW1lbnRdLFxcblxcdFxcdFxcdCAgICB0eXBlID0gaGFzT3duLmNhbGwoZXZlbnQsIFxcXCJ0eXBlXFxcIikgPyBldmVudC50eXBlIDogZXZlbnQsXFxuXFx0XFx0XFx0ICAgIG5hbWVzcGFjZXMgPSBoYXNPd24uY2FsbChldmVudCwgXFxcIm5hbWVzcGFjZVxcXCIpID8gZXZlbnQubmFtZXNwYWNlLnNwbGl0KFxcXCIuXFxcIikgOiBbXTtcXG5cXG5cXHRcXHRcXHRjdXIgPSB0bXAgPSBlbGVtID0gZWxlbSB8fCBkb2N1bWVudDtcXG5cXG5cXHRcXHRcXHQvLyBEb24ndCBkbyBldmVudHMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xcblxcdFxcdFxcdGlmIChlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDgpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIGZvY3VzL2JsdXIgbW9ycGhzIHRvIGZvY3VzaW4vb3V0OyBlbnN1cmUgd2UncmUgbm90IGZpcmluZyB0aGVtIHJpZ2h0IG5vd1xcblxcdFxcdFxcdGlmIChyZm9jdXNNb3JwaC50ZXN0KHR5cGUgKyBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkKSkge1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKHR5cGUuaW5kZXhPZihcXFwiLlxcXCIpID49IDApIHtcXG5cXHRcXHRcXHRcXHQvLyBOYW1lc3BhY2VkIHRyaWdnZXI7IGNyZWF0ZSBhIHJlZ2V4cCB0byBtYXRjaCBldmVudCB0eXBlIGluIGhhbmRsZSgpXFxuXFx0XFx0XFx0XFx0bmFtZXNwYWNlcyA9IHR5cGUuc3BsaXQoXFxcIi5cXFwiKTtcXG5cXHRcXHRcXHRcXHR0eXBlID0gbmFtZXNwYWNlcy5zaGlmdCgpO1xcblxcdFxcdFxcdFxcdG5hbWVzcGFjZXMuc29ydCgpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRvbnR5cGUgPSB0eXBlLmluZGV4T2YoXFxcIjpcXFwiKSA8IDAgJiYgXFxcIm9uXFxcIiArIHR5cGU7XFxuXFxuXFx0XFx0XFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGEgalF1ZXJ5LkV2ZW50IG9iamVjdCwgT2JqZWN0LCBvciBqdXN0IGFuIGV2ZW50IHR5cGUgc3RyaW5nXFxuXFx0XFx0XFx0ZXZlbnQgPSBldmVudFtqUXVlcnkuZXhwYW5kb10gPyBldmVudCA6IG5ldyBqUXVlcnkuRXZlbnQodHlwZSwgKHR5cGVvZiBldmVudCA9PT0gXFxcInVuZGVmaW5lZFxcXCIgPyBcXFwidW5kZWZpbmVkXFxcIiA6IF90eXBlb2YoZXZlbnQpKSA9PT0gXFxcIm9iamVjdFxcXCIgJiYgZXZlbnQpO1xcblxcblxcdFxcdFxcdC8vIFRyaWdnZXIgYml0bWFzazogJiAxIGZvciBuYXRpdmUgaGFuZGxlcnM7ICYgMiBmb3IgalF1ZXJ5IChhbHdheXMgdHJ1ZSlcXG5cXHRcXHRcXHRldmVudC5pc1RyaWdnZXIgPSBvbmx5SGFuZGxlcnMgPyAyIDogMztcXG5cXHRcXHRcXHRldmVudC5uYW1lc3BhY2UgPSBuYW1lc3BhY2VzLmpvaW4oXFxcIi5cXFwiKTtcXG5cXHRcXHRcXHRldmVudC5uYW1lc3BhY2VfcmUgPSBldmVudC5uYW1lc3BhY2UgPyBuZXcgUmVnRXhwKFxcXCIoXnxcXFxcXFxcXC4pXFxcIiArIG5hbWVzcGFjZXMuam9pbihcXFwiXFxcXFxcXFwuKD86LipcXFxcXFxcXC58KVxcXCIpICsgXFxcIihcXFxcXFxcXC58JClcXFwiKSA6IG51bGw7XFxuXFxuXFx0XFx0XFx0Ly8gQ2xlYW4gdXAgdGhlIGV2ZW50IGluIGNhc2UgaXQgaXMgYmVpbmcgcmV1c2VkXFxuXFx0XFx0XFx0ZXZlbnQucmVzdWx0ID0gdW5kZWZpbmVkO1xcblxcdFxcdFxcdGlmICghZXZlbnQudGFyZ2V0KSB7XFxuXFx0XFx0XFx0XFx0ZXZlbnQudGFyZ2V0ID0gZWxlbTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gQ2xvbmUgYW55IGluY29taW5nIGRhdGEgYW5kIHByZXBlbmQgdGhlIGV2ZW50LCBjcmVhdGluZyB0aGUgaGFuZGxlciBhcmcgbGlzdFxcblxcdFxcdFxcdGRhdGEgPSBkYXRhID09IG51bGwgPyBbZXZlbnRdIDogalF1ZXJ5Lm1ha2VBcnJheShkYXRhLCBbZXZlbnRdKTtcXG5cXG5cXHRcXHRcXHQvLyBBbGxvdyBzcGVjaWFsIGV2ZW50cyB0byBkcmF3IG91dHNpZGUgdGhlIGxpbmVzXFxuXFx0XFx0XFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsW3R5cGVdIHx8IHt9O1xcblxcdFxcdFxcdGlmICghb25seUhhbmRsZXJzICYmIHNwZWNpYWwudHJpZ2dlciAmJiBzcGVjaWFsLnRyaWdnZXIuYXBwbHkoZWxlbSwgZGF0YSkgPT09IGZhbHNlKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBEZXRlcm1pbmUgZXZlbnQgcHJvcGFnYXRpb24gcGF0aCBpbiBhZHZhbmNlLCBwZXIgVzNDIGV2ZW50cyBzcGVjICgjOTk1MSlcXG5cXHRcXHRcXHQvLyBCdWJibGUgdXAgdG8gZG9jdW1lbnQsIHRoZW4gdG8gd2luZG93OyB3YXRjaCBmb3IgYSBnbG9iYWwgb3duZXJEb2N1bWVudCB2YXIgKCM5NzI0KVxcblxcdFxcdFxcdGlmICghb25seUhhbmRsZXJzICYmICFzcGVjaWFsLm5vQnViYmxlICYmICFqUXVlcnkuaXNXaW5kb3coZWxlbSkpIHtcXG5cXG5cXHRcXHRcXHRcXHRidWJibGVUeXBlID0gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgfHwgdHlwZTtcXG5cXHRcXHRcXHRcXHRpZiAoIXJmb2N1c01vcnBoLnRlc3QoYnViYmxlVHlwZSArIHR5cGUpKSB7XFxuXFx0XFx0XFx0XFx0XFx0Y3VyID0gY3VyLnBhcmVudE5vZGU7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGZvciAoOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZXZlbnRQYXRoLnB1c2goY3VyKTtcXG5cXHRcXHRcXHRcXHRcXHR0bXAgPSBjdXI7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIE9ubHkgYWRkIHdpbmRvdyBpZiB3ZSBnb3QgdG8gZG9jdW1lbnQgKGUuZy4sIG5vdCBwbGFpbiBvYmogb3IgZGV0YWNoZWQgRE9NKVxcblxcdFxcdFxcdFxcdGlmICh0bXAgPT09IChlbGVtLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQpKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZXZlbnRQYXRoLnB1c2godG1wLmRlZmF1bHRWaWV3IHx8IHRtcC5wYXJlbnRXaW5kb3cgfHwgd2luZG93KTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIEZpcmUgaGFuZGxlcnMgb24gdGhlIGV2ZW50IHBhdGhcXG5cXHRcXHRcXHRpID0gMDtcXG5cXHRcXHRcXHR3aGlsZSAoKGN1ciA9IGV2ZW50UGF0aFtpKytdKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xcblxcblxcdFxcdFxcdFxcdGV2ZW50LnR5cGUgPSBpID4gMSA/IGJ1YmJsZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlIHx8IHR5cGU7XFxuXFxuXFx0XFx0XFx0XFx0Ly8galF1ZXJ5IGhhbmRsZXJcXG5cXHRcXHRcXHRcXHRoYW5kbGUgPSAoZGF0YV9wcml2LmdldChjdXIsIFxcXCJldmVudHNcXFwiKSB8fCB7fSlbZXZlbnQudHlwZV0gJiYgZGF0YV9wcml2LmdldChjdXIsIFxcXCJoYW5kbGVcXFwiKTtcXG5cXHRcXHRcXHRcXHRpZiAoaGFuZGxlKSB7XFxuXFx0XFx0XFx0XFx0XFx0aGFuZGxlLmFwcGx5KGN1ciwgZGF0YSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIE5hdGl2ZSBoYW5kbGVyXFxuXFx0XFx0XFx0XFx0aGFuZGxlID0gb250eXBlICYmIGN1cltvbnR5cGVdO1xcblxcdFxcdFxcdFxcdGlmIChoYW5kbGUgJiYgaGFuZGxlLmFwcGx5ICYmIGpRdWVyeS5hY2NlcHREYXRhKGN1cikpIHtcXG5cXHRcXHRcXHRcXHRcXHRldmVudC5yZXN1bHQgPSBoYW5kbGUuYXBwbHkoY3VyLCBkYXRhKTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoZXZlbnQucmVzdWx0ID09PSBmYWxzZSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0ZXZlbnQudHlwZSA9IHR5cGU7XFxuXFxuXFx0XFx0XFx0Ly8gSWYgbm9ib2R5IHByZXZlbnRlZCB0aGUgZGVmYXVsdCBhY3Rpb24sIGRvIGl0IG5vd1xcblxcdFxcdFxcdGlmICghb25seUhhbmRsZXJzICYmICFldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xcblxcblxcdFxcdFxcdFxcdGlmICgoIXNwZWNpYWwuX2RlZmF1bHQgfHwgc3BlY2lhbC5fZGVmYXVsdC5hcHBseShldmVudFBhdGgucG9wKCksIGRhdGEpID09PSBmYWxzZSkgJiYgalF1ZXJ5LmFjY2VwdERhdGEoZWxlbSkpIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBDYWxsIGEgbmF0aXZlIERPTSBtZXRob2Qgb24gdGhlIHRhcmdldCB3aXRoIHRoZSBzYW1lIG5hbWUgbmFtZSBhcyB0aGUgZXZlbnQuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gRG9uJ3QgZG8gZGVmYXVsdCBhY3Rpb25zIG9uIHdpbmRvdywgdGhhdCdzIHdoZXJlIGdsb2JhbCB2YXJpYWJsZXMgYmUgKCM2MTcwKVxcblxcdFxcdFxcdFxcdFxcdGlmIChvbnR5cGUgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oZWxlbVt0eXBlXSkgJiYgIWpRdWVyeS5pc1dpbmRvdyhlbGVtKSkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIERvbid0IHJlLXRyaWdnZXIgYW4gb25GT08gZXZlbnQgd2hlbiB3ZSBjYWxsIGl0cyBGT08oKSBtZXRob2RcXG5cXHRcXHRcXHRcXHRcXHRcXHR0bXAgPSBlbGVtW29udHlwZV07XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKHRtcCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGVsZW1bb250eXBlXSA9IG51bGw7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIFByZXZlbnQgcmUtdHJpZ2dlcmluZyBvZiB0aGUgc2FtZSBldmVudCwgc2luY2Ugd2UgYWxyZWFkeSBidWJibGVkIGl0IGFib3ZlXFxuXFx0XFx0XFx0XFx0XFx0XFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHR5cGU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZWxlbVt0eXBlXSgpO1xcblxcdFxcdFxcdFxcdFxcdFxcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB1bmRlZmluZWQ7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKHRtcCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGVsZW1bb250eXBlXSA9IHRtcDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGV2ZW50LnJlc3VsdDtcXG5cXHRcXHR9LFxcblxcblxcdFxcdGRpc3BhdGNoOiBmdW5jdGlvbiBkaXNwYXRjaChldmVudCkge1xcblxcblxcdFxcdFxcdC8vIE1ha2UgYSB3cml0YWJsZSBqUXVlcnkuRXZlbnQgZnJvbSB0aGUgbmF0aXZlIGV2ZW50IG9iamVjdFxcblxcdFxcdFxcdGV2ZW50ID0galF1ZXJ5LmV2ZW50LmZpeChldmVudCk7XFxuXFxuXFx0XFx0XFx0dmFyIGksXFxuXFx0XFx0XFx0ICAgIGosXFxuXFx0XFx0XFx0ICAgIHJldCxcXG5cXHRcXHRcXHQgICAgbWF0Y2hlZCxcXG5cXHRcXHRcXHQgICAgaGFuZGxlT2JqLFxcblxcdFxcdFxcdCAgICBoYW5kbGVyUXVldWUgPSBbXSxcXG5cXHRcXHRcXHQgICAgYXJncyA9IF9zbGljZS5jYWxsKGFyZ3VtZW50cyksXFxuXFx0XFx0XFx0ICAgIGhhbmRsZXJzID0gKGRhdGFfcHJpdi5nZXQodGhpcywgXFxcImV2ZW50c1xcXCIpIHx8IHt9KVtldmVudC50eXBlXSB8fCBbXSxcXG5cXHRcXHRcXHQgICAgc3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsW2V2ZW50LnR5cGVdIHx8IHt9O1xcblxcblxcdFxcdFxcdC8vIFVzZSB0aGUgZml4LWVkIGpRdWVyeS5FdmVudCByYXRoZXIgdGhhbiB0aGUgKHJlYWQtb25seSkgbmF0aXZlIGV2ZW50XFxuXFx0XFx0XFx0YXJnc1swXSA9IGV2ZW50O1xcblxcdFxcdFxcdGV2ZW50LmRlbGVnYXRlVGFyZ2V0ID0gdGhpcztcXG5cXG5cXHRcXHRcXHQvLyBDYWxsIHRoZSBwcmVEaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGUsIGFuZCBsZXQgaXQgYmFpbCBpZiBkZXNpcmVkXFxuXFx0XFx0XFx0aWYgKHNwZWNpYWwucHJlRGlzcGF0Y2ggJiYgc3BlY2lhbC5wcmVEaXNwYXRjaC5jYWxsKHRoaXMsIGV2ZW50KSA9PT0gZmFsc2UpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIERldGVybWluZSBoYW5kbGVyc1xcblxcdFxcdFxcdGhhbmRsZXJRdWV1ZSA9IGpRdWVyeS5ldmVudC5oYW5kbGVycy5jYWxsKHRoaXMsIGV2ZW50LCBoYW5kbGVycyk7XFxuXFxuXFx0XFx0XFx0Ly8gUnVuIGRlbGVnYXRlcyBmaXJzdDsgdGhleSBtYXkgd2FudCB0byBzdG9wIHByb3BhZ2F0aW9uIGJlbmVhdGggdXNcXG5cXHRcXHRcXHRpID0gMDtcXG5cXHRcXHRcXHR3aGlsZSAoKG1hdGNoZWQgPSBoYW5kbGVyUXVldWVbaSsrXSkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcXG5cXHRcXHRcXHRcXHRldmVudC5jdXJyZW50VGFyZ2V0ID0gbWF0Y2hlZC5lbGVtO1xcblxcblxcdFxcdFxcdFxcdGogPSAwO1xcblxcdFxcdFxcdFxcdHdoaWxlICgoaGFuZGxlT2JqID0gbWF0Y2hlZC5oYW5kbGVyc1tqKytdKSAmJiAhZXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIFRyaWdnZXJlZCBldmVudCBtdXN0IGVpdGhlciAxKSBoYXZlIG5vIG5hbWVzcGFjZSwgb3IgMikgaGF2ZSBuYW1lc3BhY2UocylcXG5cXHRcXHRcXHRcXHRcXHQvLyBhIHN1YnNldCBvciBlcXVhbCB0byB0aG9zZSBpbiB0aGUgYm91bmQgZXZlbnQgKGJvdGggY2FuIGhhdmUgbm8gbmFtZXNwYWNlKS5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIWV2ZW50Lm5hbWVzcGFjZV9yZSB8fCBldmVudC5uYW1lc3BhY2VfcmUudGVzdChoYW5kbGVPYmoubmFtZXNwYWNlKSkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGV2ZW50LmhhbmRsZU9iaiA9IGhhbmRsZU9iajtcXG5cXHRcXHRcXHRcXHRcXHRcXHRldmVudC5kYXRhID0gaGFuZGxlT2JqLmRhdGE7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0ID0gKChqUXVlcnkuZXZlbnQuc3BlY2lhbFtoYW5kbGVPYmoub3JpZ1R5cGVdIHx8IHt9KS5oYW5kbGUgfHwgaGFuZGxlT2JqLmhhbmRsZXIpLmFwcGx5KG1hdGNoZWQuZWxlbSwgYXJncyk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKHJldCAhPT0gdW5kZWZpbmVkKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKChldmVudC5yZXN1bHQgPSByZXQpID09PSBmYWxzZSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBDYWxsIHRoZSBwb3N0RGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlXFxuXFx0XFx0XFx0aWYgKHNwZWNpYWwucG9zdERpc3BhdGNoKSB7XFxuXFx0XFx0XFx0XFx0c3BlY2lhbC5wb3N0RGlzcGF0Y2guY2FsbCh0aGlzLCBldmVudCk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBldmVudC5yZXN1bHQ7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRoYW5kbGVyczogZnVuY3Rpb24gaGFuZGxlcnMoZXZlbnQsIF9oYW5kbGVycykge1xcblxcdFxcdFxcdHZhciBpLFxcblxcdFxcdFxcdCAgICBtYXRjaGVzLFxcblxcdFxcdFxcdCAgICBzZWwsXFxuXFx0XFx0XFx0ICAgIGhhbmRsZU9iaixcXG5cXHRcXHRcXHQgICAgaGFuZGxlclF1ZXVlID0gW10sXFxuXFx0XFx0XFx0ICAgIGRlbGVnYXRlQ291bnQgPSBfaGFuZGxlcnMuZGVsZWdhdGVDb3VudCxcXG5cXHRcXHRcXHQgICAgY3VyID0gZXZlbnQudGFyZ2V0O1xcblxcblxcdFxcdFxcdC8vIEZpbmQgZGVsZWdhdGUgaGFuZGxlcnNcXG5cXHRcXHRcXHQvLyBCbGFjay1ob2xlIFNWRyA8dXNlPiBpbnN0YW5jZSB0cmVlcyAoIzEzMTgwKVxcblxcdFxcdFxcdC8vIEF2b2lkIG5vbi1sZWZ0LWNsaWNrIGJ1YmJsaW5nIGluIEZpcmVmb3ggKCMzODYxKVxcblxcdFxcdFxcdGlmIChkZWxlZ2F0ZUNvdW50ICYmIGN1ci5ub2RlVHlwZSAmJiAoIWV2ZW50LmJ1dHRvbiB8fCBldmVudC50eXBlICE9PSBcXFwiY2xpY2tcXFwiKSkge1xcblxcblxcdFxcdFxcdFxcdGZvciAoOyBjdXIgIT09IHRoaXM7IGN1ciA9IGN1ci5wYXJlbnROb2RlIHx8IHRoaXMpIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBEb24ndCBwcm9jZXNzIGNsaWNrcyBvbiBkaXNhYmxlZCBlbGVtZW50cyAoIzY5MTEsICM4MTY1LCAjMTEzODIsICMxMTc2NClcXG5cXHRcXHRcXHRcXHRcXHRpZiAoY3VyLmRpc2FibGVkICE9PSB0cnVlIHx8IGV2ZW50LnR5cGUgIT09IFxcXCJjbGlja1xcXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRtYXRjaGVzID0gW107XFxuXFx0XFx0XFx0XFx0XFx0XFx0Zm9yIChpID0gMDsgaSA8IGRlbGVnYXRlQ291bnQ7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGhhbmRsZU9iaiA9IF9oYW5kbGVyc1tpXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBEb24ndCBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoIzEzMjAzKVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHNlbCA9IGhhbmRsZU9iai5zZWxlY3RvciArIFxcXCIgXFxcIjtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAobWF0Y2hlc1tzZWxdID09PSB1bmRlZmluZWQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRtYXRjaGVzW3NlbF0gPSBoYW5kbGVPYmoubmVlZHNDb250ZXh0ID8galF1ZXJ5KHNlbCwgdGhpcykuaW5kZXgoY3VyKSA+PSAwIDogalF1ZXJ5LmZpbmQoc2VsLCB0aGlzLCBudWxsLCBbY3VyXSkubGVuZ3RoO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAobWF0Y2hlc1tzZWxdKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bWF0Y2hlcy5wdXNoKGhhbmRsZU9iaik7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAobWF0Y2hlcy5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRoYW5kbGVyUXVldWUucHVzaCh7IGVsZW06IGN1ciwgaGFuZGxlcnM6IG1hdGNoZXMgfSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIEFkZCB0aGUgcmVtYWluaW5nIChkaXJlY3RseS1ib3VuZCkgaGFuZGxlcnNcXG5cXHRcXHRcXHRpZiAoZGVsZWdhdGVDb3VudCA8IF9oYW5kbGVycy5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRoYW5kbGVyUXVldWUucHVzaCh7IGVsZW06IHRoaXMsIGhhbmRsZXJzOiBfaGFuZGxlcnMuc2xpY2UoZGVsZWdhdGVDb3VudCkgfSk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBoYW5kbGVyUXVldWU7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyBJbmNsdWRlcyBzb21lIGV2ZW50IHByb3BzIHNoYXJlZCBieSBLZXlFdmVudCBhbmQgTW91c2VFdmVudFxcblxcdFxcdHByb3BzOiBcXFwiYWx0S2V5IGJ1YmJsZXMgY2FuY2VsYWJsZSBjdHJsS2V5IGN1cnJlbnRUYXJnZXQgZXZlbnRQaGFzZSBtZXRhS2V5IHJlbGF0ZWRUYXJnZXQgc2hpZnRLZXkgdGFyZ2V0IHRpbWVTdGFtcCB2aWV3IHdoaWNoXFxcIi5zcGxpdChcXFwiIFxcXCIpLFxcblxcblxcdFxcdGZpeEhvb2tzOiB7fSxcXG5cXG5cXHRcXHRrZXlIb29rczoge1xcblxcdFxcdFxcdHByb3BzOiBcXFwiY2hhciBjaGFyQ29kZSBrZXkga2V5Q29kZVxcXCIuc3BsaXQoXFxcIiBcXFwiKSxcXG5cXHRcXHRcXHRmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcihldmVudCwgb3JpZ2luYWwpIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBBZGQgd2hpY2ggZm9yIGtleSBldmVudHNcXG5cXHRcXHRcXHRcXHRpZiAoZXZlbnQud2hpY2ggPT0gbnVsbCkge1xcblxcdFxcdFxcdFxcdFxcdGV2ZW50LndoaWNoID0gb3JpZ2luYWwuY2hhckNvZGUgIT0gbnVsbCA/IG9yaWdpbmFsLmNoYXJDb2RlIDogb3JpZ2luYWwua2V5Q29kZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIGV2ZW50O1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcblxcdFxcdG1vdXNlSG9va3M6IHtcXG5cXHRcXHRcXHRwcm9wczogXFxcImJ1dHRvbiBidXR0b25zIGNsaWVudFggY2xpZW50WSBvZmZzZXRYIG9mZnNldFkgcGFnZVggcGFnZVkgc2NyZWVuWCBzY3JlZW5ZIHRvRWxlbWVudFxcXCIuc3BsaXQoXFxcIiBcXFwiKSxcXG5cXHRcXHRcXHRmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcihldmVudCwgb3JpZ2luYWwpIHtcXG5cXHRcXHRcXHRcXHR2YXIgZXZlbnREb2MsXFxuXFx0XFx0XFx0XFx0ICAgIGRvYyxcXG5cXHRcXHRcXHRcXHQgICAgYm9keSxcXG5cXHRcXHRcXHRcXHQgICAgYnV0dG9uID0gb3JpZ2luYWwuYnV0dG9uO1xcblxcblxcdFxcdFxcdFxcdC8vIENhbGN1bGF0ZSBwYWdlWC9ZIGlmIG1pc3NpbmcgYW5kIGNsaWVudFgvWSBhdmFpbGFibGVcXG5cXHRcXHRcXHRcXHRpZiAoZXZlbnQucGFnZVggPT0gbnVsbCAmJiBvcmlnaW5hbC5jbGllbnRYICE9IG51bGwpIHtcXG5cXHRcXHRcXHRcXHRcXHRldmVudERvYyA9IGV2ZW50LnRhcmdldC5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50O1xcblxcdFxcdFxcdFxcdFxcdGRvYyA9IGV2ZW50RG9jLmRvY3VtZW50RWxlbWVudDtcXG5cXHRcXHRcXHRcXHRcXHRib2R5ID0gZXZlbnREb2MuYm9keTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRldmVudC5wYWdlWCA9IG9yaWdpbmFsLmNsaWVudFggKyAoZG9jICYmIGRvYy5zY3JvbGxMZWZ0IHx8IGJvZHkgJiYgYm9keS5zY3JvbGxMZWZ0IHx8IDApIC0gKGRvYyAmJiBkb2MuY2xpZW50TGVmdCB8fCBib2R5ICYmIGJvZHkuY2xpZW50TGVmdCB8fCAwKTtcXG5cXHRcXHRcXHRcXHRcXHRldmVudC5wYWdlWSA9IG9yaWdpbmFsLmNsaWVudFkgKyAoZG9jICYmIGRvYy5zY3JvbGxUb3AgfHwgYm9keSAmJiBib2R5LnNjcm9sbFRvcCB8fCAwKSAtIChkb2MgJiYgZG9jLmNsaWVudFRvcCB8fCBib2R5ICYmIGJvZHkuY2xpZW50VG9wIHx8IDApO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBBZGQgd2hpY2ggZm9yIGNsaWNrOiAxID09PSBsZWZ0OyAyID09PSBtaWRkbGU7IDMgPT09IHJpZ2h0XFxuXFx0XFx0XFx0XFx0Ly8gTm90ZTogYnV0dG9uIGlzIG5vdCBub3JtYWxpemVkLCBzbyBkb24ndCB1c2UgaXRcXG5cXHRcXHRcXHRcXHRpZiAoIWV2ZW50LndoaWNoICYmIGJ1dHRvbiAhPT0gdW5kZWZpbmVkKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZXZlbnQud2hpY2ggPSBidXR0b24gJiAxID8gMSA6IGJ1dHRvbiAmIDIgPyAzIDogYnV0dG9uICYgNCA/IDIgOiAwO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gZXZlbnQ7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Zml4OiBmdW5jdGlvbiBmaXgoZXZlbnQpIHtcXG5cXHRcXHRcXHRpZiAoZXZlbnRbalF1ZXJ5LmV4cGFuZG9dKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGV2ZW50O1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBDcmVhdGUgYSB3cml0YWJsZSBjb3B5IG9mIHRoZSBldmVudCBvYmplY3QgYW5kIG5vcm1hbGl6ZSBzb21lIHByb3BlcnRpZXNcXG5cXHRcXHRcXHR2YXIgaSxcXG5cXHRcXHRcXHQgICAgcHJvcCxcXG5cXHRcXHRcXHQgICAgY29weSxcXG5cXHRcXHRcXHQgICAgdHlwZSA9IGV2ZW50LnR5cGUsXFxuXFx0XFx0XFx0ICAgIG9yaWdpbmFsRXZlbnQgPSBldmVudCxcXG5cXHRcXHRcXHQgICAgZml4SG9vayA9IHRoaXMuZml4SG9va3NbdHlwZV07XFxuXFxuXFx0XFx0XFx0aWYgKCFmaXhIb29rKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5maXhIb29rc1t0eXBlXSA9IGZpeEhvb2sgPSBybW91c2VFdmVudC50ZXN0KHR5cGUpID8gdGhpcy5tb3VzZUhvb2tzIDogcmtleUV2ZW50LnRlc3QodHlwZSkgPyB0aGlzLmtleUhvb2tzIDoge307XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGNvcHkgPSBmaXhIb29rLnByb3BzID8gdGhpcy5wcm9wcy5jb25jYXQoZml4SG9vay5wcm9wcykgOiB0aGlzLnByb3BzO1xcblxcblxcdFxcdFxcdGV2ZW50ID0gbmV3IGpRdWVyeS5FdmVudChvcmlnaW5hbEV2ZW50KTtcXG5cXG5cXHRcXHRcXHRpID0gY29weS5sZW5ndGg7XFxuXFx0XFx0XFx0d2hpbGUgKGktLSkge1xcblxcdFxcdFxcdFxcdHByb3AgPSBjb3B5W2ldO1xcblxcdFxcdFxcdFxcdGV2ZW50W3Byb3BdID0gb3JpZ2luYWxFdmVudFtwcm9wXTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gU3VwcG9ydDogQ29yZG92YSAyLjUgKFdlYktpdCkgKCMxMzI1NSlcXG5cXHRcXHRcXHQvLyBBbGwgZXZlbnRzIHNob3VsZCBoYXZlIGEgdGFyZ2V0OyBDb3Jkb3ZhIGRldmljZXJlYWR5IGRvZXNuJ3RcXG5cXHRcXHRcXHRpZiAoIWV2ZW50LnRhcmdldCkge1xcblxcdFxcdFxcdFxcdGV2ZW50LnRhcmdldCA9IGRvY3VtZW50O1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBTdXBwb3J0OiBTYWZhcmkgNi4wKywgQ2hyb21lPDI4XFxuXFx0XFx0XFx0Ly8gVGFyZ2V0IHNob3VsZCBub3QgYmUgYSB0ZXh0IG5vZGUgKCM1MDQsICMxMzE0MylcXG5cXHRcXHRcXHRpZiAoZXZlbnQudGFyZ2V0Lm5vZGVUeXBlID09PSAzKSB7XFxuXFx0XFx0XFx0XFx0ZXZlbnQudGFyZ2V0ID0gZXZlbnQudGFyZ2V0LnBhcmVudE5vZGU7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBmaXhIb29rLmZpbHRlciA/IGZpeEhvb2suZmlsdGVyKGV2ZW50LCBvcmlnaW5hbEV2ZW50KSA6IGV2ZW50O1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0c3BlY2lhbDoge1xcblxcdFxcdFxcdGxvYWQ6IHtcXG5cXHRcXHRcXHRcXHQvLyBQcmV2ZW50IHRyaWdnZXJlZCBpbWFnZS5sb2FkIGV2ZW50cyBmcm9tIGJ1YmJsaW5nIHRvIHdpbmRvdy5sb2FkXFxuXFx0XFx0XFx0XFx0bm9CdWJibGU6IHRydWVcXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdGZvY3VzOiB7XFxuXFx0XFx0XFx0XFx0Ly8gRmlyZSBuYXRpdmUgZXZlbnQgaWYgcG9zc2libGUgc28gYmx1ci9mb2N1cyBzZXF1ZW5jZSBpcyBjb3JyZWN0XFxuXFx0XFx0XFx0XFx0dHJpZ2dlcjogZnVuY3Rpb24gdHJpZ2dlcigpIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAodGhpcyAhPT0gc2FmZUFjdGl2ZUVsZW1lbnQoKSAmJiB0aGlzLmZvY3VzKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5mb2N1cygpO1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRcXHRkZWxlZ2F0ZVR5cGU6IFxcXCJmb2N1c2luXFxcIlxcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0Ymx1cjoge1xcblxcdFxcdFxcdFxcdHRyaWdnZXI6IGZ1bmN0aW9uIHRyaWdnZXIoKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHRoaXMgPT09IHNhZmVBY3RpdmVFbGVtZW50KCkgJiYgdGhpcy5ibHVyKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5ibHVyKCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9LFxcblxcdFxcdFxcdFxcdGRlbGVnYXRlVHlwZTogXFxcImZvY3Vzb3V0XFxcIlxcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0Y2xpY2s6IHtcXG5cXHRcXHRcXHRcXHQvLyBGb3IgY2hlY2tib3gsIGZpcmUgbmF0aXZlIGV2ZW50IHNvIGNoZWNrZWQgc3RhdGUgd2lsbCBiZSByaWdodFxcblxcdFxcdFxcdFxcdHRyaWdnZXI6IGZ1bmN0aW9uIHRyaWdnZXIoKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHRoaXMudHlwZSA9PT0gXFxcImNoZWNrYm94XFxcIiAmJiB0aGlzLmNsaWNrICYmIGpRdWVyeS5ub2RlTmFtZSh0aGlzLCBcXFwiaW5wdXRcXFwiKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuY2xpY2soKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0XFx0Ly8gRm9yIGNyb3NzLWJyb3dzZXIgY29uc2lzdGVuY3ksIGRvbid0IGZpcmUgbmF0aXZlIC5jbGljaygpIG9uIGxpbmtzXFxuXFx0XFx0XFx0XFx0X2RlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KGV2ZW50KSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGpRdWVyeS5ub2RlTmFtZShldmVudC50YXJnZXQsIFxcXCJhXFxcIik7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0YmVmb3JldW5sb2FkOiB7XFxuXFx0XFx0XFx0XFx0cG9zdERpc3BhdGNoOiBmdW5jdGlvbiBwb3N0RGlzcGF0Y2goZXZlbnQpIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBTdXBwb3J0OiBGaXJlZm94IDIwK1xcblxcdFxcdFxcdFxcdFxcdC8vIEZpcmVmb3ggZG9lc24ndCBhbGVydCBpZiB0aGUgcmV0dXJuVmFsdWUgZmllbGQgaXMgbm90IHNldC5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoZXZlbnQucmVzdWx0ICE9PSB1bmRlZmluZWQgJiYgZXZlbnQub3JpZ2luYWxFdmVudCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGV2ZW50Lm9yaWdpbmFsRXZlbnQucmV0dXJuVmFsdWUgPSBldmVudC5yZXN1bHQ7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzaW11bGF0ZTogZnVuY3Rpb24gc2ltdWxhdGUodHlwZSwgZWxlbSwgZXZlbnQsIGJ1YmJsZSkge1xcblxcdFxcdFxcdC8vIFBpZ2d5YmFjayBvbiBhIGRvbm9yIGV2ZW50IHRvIHNpbXVsYXRlIGEgZGlmZmVyZW50IG9uZS5cXG5cXHRcXHRcXHQvLyBGYWtlIG9yaWdpbmFsRXZlbnQgdG8gYXZvaWQgZG9ub3IncyBzdG9wUHJvcGFnYXRpb24sIGJ1dCBpZiB0aGVcXG5cXHRcXHRcXHQvLyBzaW11bGF0ZWQgZXZlbnQgcHJldmVudHMgZGVmYXVsdCB0aGVuIHdlIGRvIHRoZSBzYW1lIG9uIHRoZSBkb25vci5cXG5cXHRcXHRcXHR2YXIgZSA9IGpRdWVyeS5leHRlbmQobmV3IGpRdWVyeS5FdmVudCgpLCBldmVudCwge1xcblxcdFxcdFxcdFxcdHR5cGU6IHR5cGUsXFxuXFx0XFx0XFx0XFx0aXNTaW11bGF0ZWQ6IHRydWUsXFxuXFx0XFx0XFx0XFx0b3JpZ2luYWxFdmVudDoge31cXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRpZiAoYnViYmxlKSB7XFxuXFx0XFx0XFx0XFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoZSwgbnVsbCwgZWxlbSk7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRqUXVlcnkuZXZlbnQuZGlzcGF0Y2guY2FsbChlbGVtLCBlKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKGUuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcXG5cXHRcXHRcXHRcXHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fTtcXG5cXG5cXHRqUXVlcnkucmVtb3ZlRXZlbnQgPSBmdW5jdGlvbiAoZWxlbSwgdHlwZSwgaGFuZGxlKSB7XFxuXFx0XFx0aWYgKGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xcblxcdFxcdFxcdGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGUsIGZhbHNlKTtcXG5cXHRcXHR9XFxuXFx0fTtcXG5cXG5cXHRqUXVlcnkuRXZlbnQgPSBmdW5jdGlvbiAoc3JjLCBwcm9wcykge1xcblxcdFxcdC8vIEFsbG93IGluc3RhbnRpYXRpb24gd2l0aG91dCB0aGUgJ25ldycga2V5d29yZFxcblxcdFxcdGlmICghKHRoaXMgaW5zdGFuY2VvZiBqUXVlcnkuRXZlbnQpKSB7XFxuXFx0XFx0XFx0cmV0dXJuIG5ldyBqUXVlcnkuRXZlbnQoc3JjLCBwcm9wcyk7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIEV2ZW50IG9iamVjdFxcblxcdFxcdGlmIChzcmMgJiYgc3JjLnR5cGUpIHtcXG5cXHRcXHRcXHR0aGlzLm9yaWdpbmFsRXZlbnQgPSBzcmM7XFxuXFx0XFx0XFx0dGhpcy50eXBlID0gc3JjLnR5cGU7XFxuXFxuXFx0XFx0XFx0Ly8gRXZlbnRzIGJ1YmJsaW5nIHVwIHRoZSBkb2N1bWVudCBtYXkgaGF2ZSBiZWVuIG1hcmtlZCBhcyBwcmV2ZW50ZWRcXG5cXHRcXHRcXHQvLyBieSBhIGhhbmRsZXIgbG93ZXIgZG93biB0aGUgdHJlZTsgcmVmbGVjdCB0aGUgY29ycmVjdCB2YWx1ZS5cXG5cXHRcXHRcXHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHNyYy5kZWZhdWx0UHJldmVudGVkIHx8IHNyYy5kZWZhdWx0UHJldmVudGVkID09PSB1bmRlZmluZWQgJiZcXG5cXHRcXHRcXHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMFxcblxcdFxcdFxcdHNyYy5yZXR1cm5WYWx1ZSA9PT0gZmFsc2UgPyByZXR1cm5UcnVlIDogcmV0dXJuRmFsc2U7XFxuXFxuXFx0XFx0XFx0Ly8gRXZlbnQgdHlwZVxcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0dGhpcy50eXBlID0gc3JjO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBQdXQgZXhwbGljaXRseSBwcm92aWRlZCBwcm9wZXJ0aWVzIG9udG8gdGhlIGV2ZW50IG9iamVjdFxcblxcdFxcdGlmIChwcm9wcykge1xcblxcdFxcdFxcdGpRdWVyeS5leHRlbmQodGhpcywgcHJvcHMpO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBDcmVhdGUgYSB0aW1lc3RhbXAgaWYgaW5jb21pbmcgZXZlbnQgZG9lc24ndCBoYXZlIG9uZVxcblxcdFxcdHRoaXMudGltZVN0YW1wID0gc3JjICYmIHNyYy50aW1lU3RhbXAgfHwgalF1ZXJ5Lm5vdygpO1xcblxcblxcdFxcdC8vIE1hcmsgaXQgYXMgZml4ZWRcXG5cXHRcXHR0aGlzW2pRdWVyeS5leHBhbmRvXSA9IHRydWU7XFxuXFx0fTtcXG5cXG5cXHQvLyBqUXVlcnkuRXZlbnQgaXMgYmFzZWQgb24gRE9NMyBFdmVudHMgYXMgc3BlY2lmaWVkIGJ5IHRoZSBFQ01BU2NyaXB0IExhbmd1YWdlIEJpbmRpbmdcXG5cXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDAzMDMzMS9lY21hLXNjcmlwdC1iaW5kaW5nLmh0bWxcXG5cXHRqUXVlcnkuRXZlbnQucHJvdG90eXBlID0ge1xcblxcdFxcdGlzRGVmYXVsdFByZXZlbnRlZDogcmV0dXJuRmFsc2UsXFxuXFx0XFx0aXNQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxcblxcdFxcdGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcXG5cXG5cXHRcXHRwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gcHJldmVudERlZmF1bHQoKSB7XFxuXFx0XFx0XFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XFxuXFxuXFx0XFx0XFx0dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSByZXR1cm5UcnVlO1xcblxcblxcdFxcdFxcdGlmIChlICYmIGUucHJldmVudERlZmF1bHQpIHtcXG5cXHRcXHRcXHRcXHRlLnByZXZlbnREZWZhdWx0KCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFx0XFx0c3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbiBzdG9wUHJvcGFnYXRpb24oKSB7XFxuXFx0XFx0XFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XFxuXFxuXFx0XFx0XFx0dGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XFxuXFxuXFx0XFx0XFx0aWYgKGUgJiYgZS5zdG9wUHJvcGFnYXRpb24pIHtcXG5cXHRcXHRcXHRcXHRlLnN0b3BQcm9wYWdhdGlvbigpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcdFxcdHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjogZnVuY3Rpb24gc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCkge1xcblxcdFxcdFxcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xcblxcblxcdFxcdFxcdHRoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xcblxcblxcdFxcdFxcdGlmIChlICYmIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKSB7XFxuXFx0XFx0XFx0XFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy5zdG9wUHJvcGFnYXRpb24oKTtcXG5cXHRcXHR9XFxuXFx0fTtcXG5cXG5cXHQvLyBDcmVhdGUgbW91c2VlbnRlci9sZWF2ZSBldmVudHMgdXNpbmcgbW91c2VvdmVyL291dCBhbmQgZXZlbnQtdGltZSBjaGVja3NcXG5cXHQvLyBTdXBwb3J0OiBDaHJvbWUgMTUrXFxuXFx0alF1ZXJ5LmVhY2goe1xcblxcdFxcdG1vdXNlZW50ZXI6IFxcXCJtb3VzZW92ZXJcXFwiLFxcblxcdFxcdG1vdXNlbGVhdmU6IFxcXCJtb3VzZW91dFxcXCIsXFxuXFx0XFx0cG9pbnRlcmVudGVyOiBcXFwicG9pbnRlcm92ZXJcXFwiLFxcblxcdFxcdHBvaW50ZXJsZWF2ZTogXFxcInBvaW50ZXJvdXRcXFwiXFxuXFx0fSwgZnVuY3Rpb24gKG9yaWcsIGZpeCkge1xcblxcdFxcdGpRdWVyeS5ldmVudC5zcGVjaWFsW29yaWddID0ge1xcblxcdFxcdFxcdGRlbGVnYXRlVHlwZTogZml4LFxcblxcdFxcdFxcdGJpbmRUeXBlOiBmaXgsXFxuXFxuXFx0XFx0XFx0aGFuZGxlOiBmdW5jdGlvbiBoYW5kbGUoZXZlbnQpIHtcXG5cXHRcXHRcXHRcXHR2YXIgcmV0LFxcblxcdFxcdFxcdFxcdCAgICB0YXJnZXQgPSB0aGlzLFxcblxcdFxcdFxcdFxcdCAgICByZWxhdGVkID0gZXZlbnQucmVsYXRlZFRhcmdldCxcXG5cXHRcXHRcXHRcXHQgICAgaGFuZGxlT2JqID0gZXZlbnQuaGFuZGxlT2JqO1xcblxcblxcdFxcdFxcdFxcdC8vIEZvciBtb3VzZW50ZXIvbGVhdmUgY2FsbCB0aGUgaGFuZGxlciBpZiByZWxhdGVkIGlzIG91dHNpZGUgdGhlIHRhcmdldC5cXG5cXHRcXHRcXHRcXHQvLyBOQjogTm8gcmVsYXRlZFRhcmdldCBpZiB0aGUgbW91c2UgbGVmdC9lbnRlcmVkIHRoZSBicm93c2VyIHdpbmRvd1xcblxcdFxcdFxcdFxcdGlmICghcmVsYXRlZCB8fCByZWxhdGVkICE9PSB0YXJnZXQgJiYgIWpRdWVyeS5jb250YWlucyh0YXJnZXQsIHJlbGF0ZWQpKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZXZlbnQudHlwZSA9IGhhbmRsZU9iai5vcmlnVHlwZTtcXG5cXHRcXHRcXHRcXHRcXHRyZXQgPSBoYW5kbGVPYmouaGFuZGxlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcblxcdFxcdFxcdFxcdFxcdGV2ZW50LnR5cGUgPSBmaXg7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHJldHVybiByZXQ7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH07XFxuXFx0fSk7XFxuXFxuXFx0Ly8gU3VwcG9ydDogRmlyZWZveCwgQ2hyb21lLCBTYWZhcmlcXG5cXHQvLyBDcmVhdGUgXFxcImJ1YmJsaW5nXFxcIiBmb2N1cyBhbmQgYmx1ciBldmVudHNcXG5cXHRpZiAoIXN1cHBvcnQuZm9jdXNpbkJ1YmJsZXMpIHtcXG5cXHRcXHRqUXVlcnkuZWFjaCh7IGZvY3VzOiBcXFwiZm9jdXNpblxcXCIsIGJsdXI6IFxcXCJmb2N1c291dFxcXCIgfSwgZnVuY3Rpb24gKG9yaWcsIGZpeCkge1xcblxcblxcdFxcdFxcdC8vIEF0dGFjaCBhIHNpbmdsZSBjYXB0dXJpbmcgaGFuZGxlciBvbiB0aGUgZG9jdW1lbnQgd2hpbGUgc29tZW9uZSB3YW50cyBmb2N1c2luL2ZvY3Vzb3V0XFxuXFx0XFx0XFx0dmFyIGhhbmRsZXIgPSBmdW5jdGlvbiBoYW5kbGVyKGV2ZW50KSB7XFxuXFx0XFx0XFx0XFx0alF1ZXJ5LmV2ZW50LnNpbXVsYXRlKGZpeCwgZXZlbnQudGFyZ2V0LCBqUXVlcnkuZXZlbnQuZml4KGV2ZW50KSwgdHJ1ZSk7XFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHRcXHRqUXVlcnkuZXZlbnQuc3BlY2lhbFtmaXhdID0ge1xcblxcdFxcdFxcdFxcdHNldHVwOiBmdW5jdGlvbiBzZXR1cCgpIHtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXFxuXFx0XFx0XFx0XFx0XFx0ICAgIGF0dGFjaGVzID0gZGF0YV9wcml2LmFjY2Vzcyhkb2MsIGZpeCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCFhdHRhY2hlcykge1xcblxcdFxcdFxcdFxcdFxcdFxcdGRvYy5hZGRFdmVudExpc3RlbmVyKG9yaWcsIGhhbmRsZXIsIHRydWUpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRkYXRhX3ByaXYuYWNjZXNzKGRvYywgZml4LCAoYXR0YWNoZXMgfHwgMCkgKyAxKTtcXG5cXHRcXHRcXHRcXHR9LFxcblxcdFxcdFxcdFxcdHRlYXJkb3duOiBmdW5jdGlvbiB0ZWFyZG93bigpIHtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXFxuXFx0XFx0XFx0XFx0XFx0ICAgIGF0dGFjaGVzID0gZGF0YV9wcml2LmFjY2Vzcyhkb2MsIGZpeCkgLSAxO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICghYXR0YWNoZXMpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcihvcmlnLCBoYW5kbGVyLCB0cnVlKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRkYXRhX3ByaXYucmVtb3ZlKGRvYywgZml4KTtcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdGRhdGFfcHJpdi5hY2Nlc3MoZG9jLCBmaXgsIGF0dGFjaGVzKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH07XFxuXFx0XFx0fSk7XFxuXFx0fVxcblxcblxcdGpRdWVyeS5mbi5leHRlbmQoe1xcblxcblxcdFxcdG9uOiBmdW5jdGlvbiBvbih0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCAvKklOVEVSTkFMKi9vbmUpIHtcXG5cXHRcXHRcXHR2YXIgb3JpZ0ZuLCB0eXBlO1xcblxcblxcdFxcdFxcdC8vIFR5cGVzIGNhbiBiZSBhIG1hcCBvZiB0eXBlcy9oYW5kbGVyc1xcblxcdFxcdFxcdGlmICgodHlwZW9mIHR5cGVzID09PSBcXFwidW5kZWZpbmVkXFxcIiA/IFxcXCJ1bmRlZmluZWRcXFwiIDogX3R5cGVvZih0eXBlcykpID09PSBcXFwib2JqZWN0XFxcIikge1xcblxcdFxcdFxcdFxcdC8vICggdHlwZXMtT2JqZWN0LCBzZWxlY3RvciwgZGF0YSApXFxuXFx0XFx0XFx0XFx0aWYgKHR5cGVvZiBzZWxlY3RvciAhPT0gXFxcInN0cmluZ1xcXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHQvLyAoIHR5cGVzLU9iamVjdCwgZGF0YSApXFxuXFx0XFx0XFx0XFx0XFx0ZGF0YSA9IGRhdGEgfHwgc2VsZWN0b3I7XFxuXFx0XFx0XFx0XFx0XFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGZvciAodHlwZSBpbiB0eXBlcykge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMub24odHlwZSwgc2VsZWN0b3IsIGRhdGEsIHR5cGVzW3R5cGVdLCBvbmUpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKGRhdGEgPT0gbnVsbCAmJiBmbiA9PSBudWxsKSB7XFxuXFx0XFx0XFx0XFx0Ly8gKCB0eXBlcywgZm4gKVxcblxcdFxcdFxcdFxcdGZuID0gc2VsZWN0b3I7XFxuXFx0XFx0XFx0XFx0ZGF0YSA9IHNlbGVjdG9yID0gdW5kZWZpbmVkO1xcblxcdFxcdFxcdH0gZWxzZSBpZiAoZm4gPT0gbnVsbCkge1xcblxcdFxcdFxcdFxcdGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09IFxcXCJzdHJpbmdcXFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gKCB0eXBlcywgc2VsZWN0b3IsIGZuIClcXG5cXHRcXHRcXHRcXHRcXHRmbiA9IGRhdGE7XFxuXFx0XFx0XFx0XFx0XFx0ZGF0YSA9IHVuZGVmaW5lZDtcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdC8vICggdHlwZXMsIGRhdGEsIGZuIClcXG5cXHRcXHRcXHRcXHRcXHRmbiA9IGRhdGE7XFxuXFx0XFx0XFx0XFx0XFx0ZGF0YSA9IHNlbGVjdG9yO1xcblxcdFxcdFxcdFxcdFxcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKGZuID09PSBmYWxzZSkge1xcblxcdFxcdFxcdFxcdGZuID0gcmV0dXJuRmFsc2U7XFxuXFx0XFx0XFx0fSBlbHNlIGlmICghZm4pIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKG9uZSA9PT0gMSkge1xcblxcdFxcdFxcdFxcdG9yaWdGbiA9IGZuO1xcblxcdFxcdFxcdFxcdGZuID0gZnVuY3Rpb24gZm4oZXZlbnQpIHtcXG5cXHRcXHRcXHRcXHRcXHQvLyBDYW4gdXNlIGFuIGVtcHR5IHNldCwgc2luY2UgZXZlbnQgY29udGFpbnMgdGhlIGluZm9cXG5cXHRcXHRcXHRcXHRcXHRqUXVlcnkoKS5vZmYoZXZlbnQpO1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBvcmlnRm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG5cXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdFxcdC8vIFVzZSBzYW1lIGd1aWQgc28gY2FsbGVyIGNhbiByZW1vdmUgdXNpbmcgb3JpZ0ZuXFxuXFx0XFx0XFx0XFx0Zm4uZ3VpZCA9IG9yaWdGbi5ndWlkIHx8IChvcmlnRm4uZ3VpZCA9IGpRdWVyeS5ndWlkKyspO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRqUXVlcnkuZXZlbnQuYWRkKHRoaXMsIHR5cGVzLCBmbiwgZGF0YSwgc2VsZWN0b3IpO1xcblxcdFxcdFxcdH0pO1xcblxcdFxcdH0sXFxuXFx0XFx0b25lOiBmdW5jdGlvbiBvbmUodHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbikge1xcblxcdFxcdFxcdHJldHVybiB0aGlzLm9uKHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIDEpO1xcblxcdFxcdH0sXFxuXFx0XFx0b2ZmOiBmdW5jdGlvbiBvZmYodHlwZXMsIHNlbGVjdG9yLCBmbikge1xcblxcdFxcdFxcdHZhciBoYW5kbGVPYmosIHR5cGU7XFxuXFx0XFx0XFx0aWYgKHR5cGVzICYmIHR5cGVzLnByZXZlbnREZWZhdWx0ICYmIHR5cGVzLmhhbmRsZU9iaikge1xcblxcdFxcdFxcdFxcdC8vICggZXZlbnQgKSAgZGlzcGF0Y2hlZCBqUXVlcnkuRXZlbnRcXG5cXHRcXHRcXHRcXHRoYW5kbGVPYmogPSB0eXBlcy5oYW5kbGVPYmo7XFxuXFx0XFx0XFx0XFx0alF1ZXJ5KHR5cGVzLmRlbGVnYXRlVGFyZ2V0KS5vZmYoaGFuZGxlT2JqLm5hbWVzcGFjZSA/IGhhbmRsZU9iai5vcmlnVHlwZSArIFxcXCIuXFxcIiArIGhhbmRsZU9iai5uYW1lc3BhY2UgOiBoYW5kbGVPYmoub3JpZ1R5cGUsIGhhbmRsZU9iai5zZWxlY3RvciwgaGFuZGxlT2JqLmhhbmRsZXIpO1xcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoKHR5cGVvZiB0eXBlcyA9PT0gXFxcInVuZGVmaW5lZFxcXCIgPyBcXFwidW5kZWZpbmVkXFxcIiA6IF90eXBlb2YodHlwZXMpKSA9PT0gXFxcIm9iamVjdFxcXCIpIHtcXG5cXHRcXHRcXHRcXHQvLyAoIHR5cGVzLW9iamVjdCBbLCBzZWxlY3Rvcl0gKVxcblxcdFxcdFxcdFxcdGZvciAodHlwZSBpbiB0eXBlcykge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMub2ZmKHR5cGUsIHNlbGVjdG9yLCB0eXBlc1t0eXBlXSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoc2VsZWN0b3IgPT09IGZhbHNlIHx8IHR5cGVvZiBzZWxlY3RvciA9PT0gXFxcImZ1bmN0aW9uXFxcIikge1xcblxcdFxcdFxcdFxcdC8vICggdHlwZXMgWywgZm5dIClcXG5cXHRcXHRcXHRcXHRmbiA9IHNlbGVjdG9yO1xcblxcdFxcdFxcdFxcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoZm4gPT09IGZhbHNlKSB7XFxuXFx0XFx0XFx0XFx0Zm4gPSByZXR1cm5GYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSh0aGlzLCB0eXBlcywgZm4sIHNlbGVjdG9yKTtcXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdHRyaWdnZXI6IGZ1bmN0aW9uIHRyaWdnZXIodHlwZSwgZGF0YSkge1xcblxcdFxcdFxcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdGpRdWVyeS5ldmVudC50cmlnZ2VyKHR5cGUsIGRhdGEsIHRoaXMpO1xcblxcdFxcdFxcdH0pO1xcblxcdFxcdH0sXFxuXFx0XFx0dHJpZ2dlckhhbmRsZXI6IGZ1bmN0aW9uIHRyaWdnZXJIYW5kbGVyKHR5cGUsIGRhdGEpIHtcXG5cXHRcXHRcXHR2YXIgZWxlbSA9IHRoaXNbMF07XFxuXFx0XFx0XFx0aWYgKGVsZW0pIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4galF1ZXJ5LmV2ZW50LnRyaWdnZXIodHlwZSwgZGF0YSwgZWxlbSwgdHJ1ZSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9KTtcXG5cXG5cXHR2YXIgcnhodG1sVGFnID0gLzwoPyFhcmVhfGJyfGNvbHxlbWJlZHxocnxpbWd8aW5wdXR8bGlua3xtZXRhfHBhcmFtKSgoW1xcXFx3Ol0rKVtePl0qKVxcXFwvPi9naSxcXG5cXHQgICAgcnRhZ05hbWUgPSAvPChbXFxcXHc6XSspLyxcXG5cXHQgICAgcmh0bWwgPSAvPHwmIz9cXFxcdys7LyxcXG5cXHQgICAgcm5vSW5uZXJodG1sID0gLzwoPzpzY3JpcHR8c3R5bGV8bGluaykvaSxcXG5cXG5cXHQvLyBjaGVja2VkPVxcXCJjaGVja2VkXFxcIiBvciBjaGVja2VkXFxuXFx0cmNoZWNrZWQgPSAvY2hlY2tlZFxcXFxzKig/OltePV18PVxcXFxzKi5jaGVja2VkLikvaSxcXG5cXHQgICAgcnNjcmlwdFR5cGUgPSAvXiR8XFxcXC8oPzpqYXZhfGVjbWEpc2NyaXB0L2ksXFxuXFx0ICAgIHJzY3JpcHRUeXBlTWFza2VkID0gL150cnVlXFxcXC8oLiopLyxcXG5cXHQgICAgcmNsZWFuU2NyaXB0ID0gL15cXFxccyo8ISg/OlxcXFxbQ0RBVEFcXFxcW3wtLSl8KD86XFxcXF1cXFxcXXwtLSk+XFxcXHMqJC9nLFxcblxcblxcblxcdC8vIFdlIGhhdmUgdG8gY2xvc2UgdGhlc2UgdGFncyB0byBzdXBwb3J0IFhIVE1MICgjMTMyMDApXFxuXFx0d3JhcE1hcCA9IHtcXG5cXG5cXHRcXHQvLyBTdXBwb3J0OiBJRTlcXG5cXHRcXHRvcHRpb246IFsxLCBcXFwiPHNlbGVjdCBtdWx0aXBsZT0nbXVsdGlwbGUnPlxcXCIsIFxcXCI8L3NlbGVjdD5cXFwiXSxcXG5cXG5cXHRcXHR0aGVhZDogWzEsIFxcXCI8dGFibGU+XFxcIiwgXFxcIjwvdGFibGU+XFxcIl0sXFxuXFx0XFx0Y29sOiBbMiwgXFxcIjx0YWJsZT48Y29sZ3JvdXA+XFxcIiwgXFxcIjwvY29sZ3JvdXA+PC90YWJsZT5cXFwiXSxcXG5cXHRcXHR0cjogWzIsIFxcXCI8dGFibGU+PHRib2R5PlxcXCIsIFxcXCI8L3Rib2R5PjwvdGFibGU+XFxcIl0sXFxuXFx0XFx0dGQ6IFszLCBcXFwiPHRhYmxlPjx0Ym9keT48dHI+XFxcIiwgXFxcIjwvdHI+PC90Ym9keT48L3RhYmxlPlxcXCJdLFxcblxcblxcdFxcdF9kZWZhdWx0OiBbMCwgXFxcIlxcXCIsIFxcXCJcXFwiXVxcblxcdH07XFxuXFxuXFx0Ly8gU3VwcG9ydDogSUU5XFxuXFx0d3JhcE1hcC5vcHRncm91cCA9IHdyYXBNYXAub3B0aW9uO1xcblxcblxcdHdyYXBNYXAudGJvZHkgPSB3cmFwTWFwLnRmb290ID0gd3JhcE1hcC5jb2xncm91cCA9IHdyYXBNYXAuY2FwdGlvbiA9IHdyYXBNYXAudGhlYWQ7XFxuXFx0d3JhcE1hcC50aCA9IHdyYXBNYXAudGQ7XFxuXFxuXFx0Ly8gU3VwcG9ydDogMS54IGNvbXBhdGliaWxpdHlcXG5cXHQvLyBNYW5pcHVsYXRpbmcgdGFibGVzIHJlcXVpcmVzIGEgdGJvZHlcXG5cXHRmdW5jdGlvbiBtYW5pcHVsYXRpb25UYXJnZXQoZWxlbSwgY29udGVudCkge1xcblxcdFxcdHJldHVybiBqUXVlcnkubm9kZU5hbWUoZWxlbSwgXFxcInRhYmxlXFxcIikgJiYgalF1ZXJ5Lm5vZGVOYW1lKGNvbnRlbnQubm9kZVR5cGUgIT09IDExID8gY29udGVudCA6IGNvbnRlbnQuZmlyc3RDaGlsZCwgXFxcInRyXFxcIikgPyBlbGVtLmdldEVsZW1lbnRzQnlUYWdOYW1lKFxcXCJ0Ym9keVxcXCIpWzBdIHx8IGVsZW0uYXBwZW5kQ2hpbGQoZWxlbS5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXFxcInRib2R5XFxcIikpIDogZWxlbTtcXG5cXHR9XFxuXFxuXFx0Ly8gUmVwbGFjZS9yZXN0b3JlIHRoZSB0eXBlIGF0dHJpYnV0ZSBvZiBzY3JpcHQgZWxlbWVudHMgZm9yIHNhZmUgRE9NIG1hbmlwdWxhdGlvblxcblxcdGZ1bmN0aW9uIGRpc2FibGVTY3JpcHQoZWxlbSkge1xcblxcdFxcdGVsZW0udHlwZSA9IChlbGVtLmdldEF0dHJpYnV0ZShcXFwidHlwZVxcXCIpICE9PSBudWxsKSArIFxcXCIvXFxcIiArIGVsZW0udHlwZTtcXG5cXHRcXHRyZXR1cm4gZWxlbTtcXG5cXHR9XFxuXFx0ZnVuY3Rpb24gcmVzdG9yZVNjcmlwdChlbGVtKSB7XFxuXFx0XFx0dmFyIG1hdGNoID0gcnNjcmlwdFR5cGVNYXNrZWQuZXhlYyhlbGVtLnR5cGUpO1xcblxcblxcdFxcdGlmIChtYXRjaCkge1xcblxcdFxcdFxcdGVsZW0udHlwZSA9IG1hdGNoWzFdO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoXFxcInR5cGVcXFwiKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIGVsZW07XFxuXFx0fVxcblxcblxcdC8vIE1hcmsgc2NyaXB0cyBhcyBoYXZpbmcgYWxyZWFkeSBiZWVuIGV2YWx1YXRlZFxcblxcdGZ1bmN0aW9uIHNldEdsb2JhbEV2YWwoZWxlbXMsIHJlZkVsZW1lbnRzKSB7XFxuXFx0XFx0dmFyIGkgPSAwLFxcblxcdFxcdCAgICBsID0gZWxlbXMubGVuZ3RoO1xcblxcblxcdFxcdGZvciAoOyBpIDwgbDsgaSsrKSB7XFxuXFx0XFx0XFx0ZGF0YV9wcml2LnNldChlbGVtc1tpXSwgXFxcImdsb2JhbEV2YWxcXFwiLCAhcmVmRWxlbWVudHMgfHwgZGF0YV9wcml2LmdldChyZWZFbGVtZW50c1tpXSwgXFxcImdsb2JhbEV2YWxcXFwiKSk7XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBjbG9uZUNvcHlFdmVudChzcmMsIGRlc3QpIHtcXG5cXHRcXHR2YXIgaSwgbCwgdHlwZSwgcGRhdGFPbGQsIHBkYXRhQ3VyLCB1ZGF0YU9sZCwgdWRhdGFDdXIsIGV2ZW50cztcXG5cXG5cXHRcXHRpZiAoZGVzdC5ub2RlVHlwZSAhPT0gMSkge1xcblxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gMS4gQ29weSBwcml2YXRlIGRhdGE6IGV2ZW50cywgaGFuZGxlcnMsIGV0Yy5cXG5cXHRcXHRpZiAoZGF0YV9wcml2Lmhhc0RhdGEoc3JjKSkge1xcblxcdFxcdFxcdHBkYXRhT2xkID0gZGF0YV9wcml2LmFjY2VzcyhzcmMpO1xcblxcdFxcdFxcdHBkYXRhQ3VyID0gZGF0YV9wcml2LnNldChkZXN0LCBwZGF0YU9sZCk7XFxuXFx0XFx0XFx0ZXZlbnRzID0gcGRhdGFPbGQuZXZlbnRzO1xcblxcblxcdFxcdFxcdGlmIChldmVudHMpIHtcXG5cXHRcXHRcXHRcXHRkZWxldGUgcGRhdGFDdXIuaGFuZGxlO1xcblxcdFxcdFxcdFxcdHBkYXRhQ3VyLmV2ZW50cyA9IHt9O1xcblxcblxcdFxcdFxcdFxcdGZvciAodHlwZSBpbiBldmVudHMpIHtcXG5cXHRcXHRcXHRcXHRcXHRmb3IgKGkgPSAwLCBsID0gZXZlbnRzW3R5cGVdLmxlbmd0aDsgaSA8IGw7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdFxcdGpRdWVyeS5ldmVudC5hZGQoZGVzdCwgdHlwZSwgZXZlbnRzW3R5cGVdW2ldKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gMi4gQ29weSB1c2VyIGRhdGFcXG5cXHRcXHRpZiAoZGF0YV91c2VyLmhhc0RhdGEoc3JjKSkge1xcblxcdFxcdFxcdHVkYXRhT2xkID0gZGF0YV91c2VyLmFjY2VzcyhzcmMpO1xcblxcdFxcdFxcdHVkYXRhQ3VyID0galF1ZXJ5LmV4dGVuZCh7fSwgdWRhdGFPbGQpO1xcblxcblxcdFxcdFxcdGRhdGFfdXNlci5zZXQoZGVzdCwgdWRhdGFDdXIpO1xcblxcdFxcdH1cXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gZ2V0QWxsKGNvbnRleHQsIHRhZykge1xcblxcdFxcdHZhciByZXQgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lID8gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSh0YWcgfHwgXFxcIipcXFwiKSA6IGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCA/IGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCh0YWcgfHwgXFxcIipcXFwiKSA6IFtdO1xcblxcblxcdFxcdHJldHVybiB0YWcgPT09IHVuZGVmaW5lZCB8fCB0YWcgJiYgalF1ZXJ5Lm5vZGVOYW1lKGNvbnRleHQsIHRhZykgPyBqUXVlcnkubWVyZ2UoW2NvbnRleHRdLCByZXQpIDogcmV0O1xcblxcdH1cXG5cXG5cXHQvLyBGaXggSUUgYnVncywgc2VlIHN1cHBvcnQgdGVzdHNcXG5cXHRmdW5jdGlvbiBmaXhJbnB1dChzcmMsIGRlc3QpIHtcXG5cXHRcXHR2YXIgbm9kZU5hbWUgPSBkZXN0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XFxuXFxuXFx0XFx0Ly8gRmFpbHMgdG8gcGVyc2lzdCB0aGUgY2hlY2tlZCBzdGF0ZSBvZiBhIGNsb25lZCBjaGVja2JveCBvciByYWRpbyBidXR0b24uXFxuXFx0XFx0aWYgKG5vZGVOYW1lID09PSBcXFwiaW5wdXRcXFwiICYmIHJjaGVja2FibGVUeXBlLnRlc3Qoc3JjLnR5cGUpKSB7XFxuXFx0XFx0XFx0ZGVzdC5jaGVja2VkID0gc3JjLmNoZWNrZWQ7XFxuXFxuXFx0XFx0XFx0Ly8gRmFpbHMgdG8gcmV0dXJuIHRoZSBzZWxlY3RlZCBvcHRpb24gdG8gdGhlIGRlZmF1bHQgc2VsZWN0ZWQgc3RhdGUgd2hlbiBjbG9uaW5nIG9wdGlvbnNcXG5cXHRcXHR9IGVsc2UgaWYgKG5vZGVOYW1lID09PSBcXFwiaW5wdXRcXFwiIHx8IG5vZGVOYW1lID09PSBcXFwidGV4dGFyZWFcXFwiKSB7XFxuXFx0XFx0XFx0ZGVzdC5kZWZhdWx0VmFsdWUgPSBzcmMuZGVmYXVsdFZhbHVlO1xcblxcdFxcdH1cXG5cXHR9XFxuXFxuXFx0alF1ZXJ5LmV4dGVuZCh7XFxuXFx0XFx0Y2xvbmU6IGZ1bmN0aW9uIGNsb25lKGVsZW0sIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzKSB7XFxuXFx0XFx0XFx0dmFyIGksXFxuXFx0XFx0XFx0ICAgIGwsXFxuXFx0XFx0XFx0ICAgIHNyY0VsZW1lbnRzLFxcblxcdFxcdFxcdCAgICBkZXN0RWxlbWVudHMsXFxuXFx0XFx0XFx0ICAgIGNsb25lID0gZWxlbS5jbG9uZU5vZGUodHJ1ZSksXFxuXFx0XFx0XFx0ICAgIGluUGFnZSA9IGpRdWVyeS5jb250YWlucyhlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0pO1xcblxcblxcdFxcdFxcdC8vIEZpeCBJRSBjbG9uaW5nIGlzc3Vlc1xcblxcdFxcdFxcdGlmICghc3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCAmJiAoZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBlbGVtLm5vZGVUeXBlID09PSAxMSkgJiYgIWpRdWVyeS5pc1hNTERvYyhlbGVtKSkge1xcblxcblxcdFxcdFxcdFxcdC8vIFdlIGVzY2hldyBTaXp6bGUgaGVyZSBmb3IgcGVyZm9ybWFuY2UgcmVhc29uczogaHR0cDovL2pzcGVyZi5jb20vZ2V0YWxsLXZzLXNpenpsZS8yXFxuXFx0XFx0XFx0XFx0ZGVzdEVsZW1lbnRzID0gZ2V0QWxsKGNsb25lKTtcXG5cXHRcXHRcXHRcXHRzcmNFbGVtZW50cyA9IGdldEFsbChlbGVtKTtcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0Zml4SW5wdXQoc3JjRWxlbWVudHNbaV0sIGRlc3RFbGVtZW50c1tpXSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBDb3B5IHRoZSBldmVudHMgZnJvbSB0aGUgb3JpZ2luYWwgdG8gdGhlIGNsb25lXFxuXFx0XFx0XFx0aWYgKGRhdGFBbmRFdmVudHMpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZGVlcERhdGFBbmRFdmVudHMpIHtcXG5cXHRcXHRcXHRcXHRcXHRzcmNFbGVtZW50cyA9IHNyY0VsZW1lbnRzIHx8IGdldEFsbChlbGVtKTtcXG5cXHRcXHRcXHRcXHRcXHRkZXN0RWxlbWVudHMgPSBkZXN0RWxlbWVudHMgfHwgZ2V0QWxsKGNsb25lKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRmb3IgKGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2xvbmVDb3B5RXZlbnQoc3JjRWxlbWVudHNbaV0sIGRlc3RFbGVtZW50c1tpXSk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0Y2xvbmVDb3B5RXZlbnQoZWxlbSwgY2xvbmUpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxcblxcdFxcdFxcdGRlc3RFbGVtZW50cyA9IGdldEFsbChjbG9uZSwgXFxcInNjcmlwdFxcXCIpO1xcblxcdFxcdFxcdGlmIChkZXN0RWxlbWVudHMubGVuZ3RoID4gMCkge1xcblxcdFxcdFxcdFxcdHNldEdsb2JhbEV2YWwoZGVzdEVsZW1lbnRzLCAhaW5QYWdlICYmIGdldEFsbChlbGVtLCBcXFwic2NyaXB0XFxcIikpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBSZXR1cm4gdGhlIGNsb25lZCBzZXRcXG5cXHRcXHRcXHRyZXR1cm4gY2xvbmU7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRidWlsZEZyYWdtZW50OiBmdW5jdGlvbiBidWlsZEZyYWdtZW50KGVsZW1zLCBjb250ZXh0LCBzY3JpcHRzLCBzZWxlY3Rpb24pIHtcXG5cXHRcXHRcXHR2YXIgZWxlbSxcXG5cXHRcXHRcXHQgICAgdG1wLFxcblxcdFxcdFxcdCAgICB0YWcsXFxuXFx0XFx0XFx0ICAgIHdyYXAsXFxuXFx0XFx0XFx0ICAgIGNvbnRhaW5zLFxcblxcdFxcdFxcdCAgICBqLFxcblxcdFxcdFxcdCAgICBmcmFnbWVudCA9IGNvbnRleHQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxcblxcdFxcdFxcdCAgICBub2RlcyA9IFtdLFxcblxcdFxcdFxcdCAgICBpID0gMCxcXG5cXHRcXHRcXHQgICAgbCA9IGVsZW1zLmxlbmd0aDtcXG5cXG5cXHRcXHRcXHRmb3IgKDsgaSA8IGw7IGkrKykge1xcblxcdFxcdFxcdFxcdGVsZW0gPSBlbGVtc1tpXTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoZWxlbSB8fCBlbGVtID09PSAwKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gQWRkIG5vZGVzIGRpcmVjdGx5XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGpRdWVyeS50eXBlKGVsZW0pID09PSBcXFwib2JqZWN0XFxcIikge1xcblxcdFxcdFxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IFF0V2ViS2l0LCBQaGFudG9tSlNcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XFxuXFx0XFx0XFx0XFx0XFx0XFx0alF1ZXJ5Lm1lcmdlKG5vZGVzLCBlbGVtLm5vZGVUeXBlID8gW2VsZW1dIDogZWxlbSk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gQ29udmVydCBub24taHRtbCBpbnRvIGEgdGV4dCBub2RlXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIGlmICghcmh0bWwudGVzdChlbGVtKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdG5vZGVzLnB1c2goY29udGV4dC5jcmVhdGVUZXh0Tm9kZShlbGVtKSk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gQ29udmVydCBodG1sIGludG8gRE9NIG5vZGVzXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0bXAgPSB0bXAgfHwgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoY29udGV4dC5jcmVhdGVFbGVtZW50KFxcXCJkaXZcXFwiKSk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gRGVzZXJpYWxpemUgYSBzdGFuZGFyZCByZXByZXNlbnRhdGlvblxcblxcdFxcdFxcdFxcdFxcdFxcdHRhZyA9IChydGFnTmFtZS5leGVjKGVsZW0pIHx8IFtcXFwiXFxcIiwgXFxcIlxcXCJdKVsxXS50b0xvd2VyQ2FzZSgpO1xcblxcdFxcdFxcdFxcdFxcdFxcdHdyYXAgPSB3cmFwTWFwW3RhZ10gfHwgd3JhcE1hcC5fZGVmYXVsdDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0bXAuaW5uZXJIVE1MID0gd3JhcFsxXSArIGVsZW0ucmVwbGFjZShyeGh0bWxUYWcsIFxcXCI8JDE+PC8kMj5cXFwiKSArIHdyYXBbMl07XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gRGVzY2VuZCB0aHJvdWdoIHdyYXBwZXJzIHRvIHRoZSByaWdodCBjb250ZW50XFxuXFx0XFx0XFx0XFx0XFx0XFx0aiA9IHdyYXBbMF07XFxuXFx0XFx0XFx0XFx0XFx0XFx0d2hpbGUgKGotLSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRtcCA9IHRtcC5sYXN0Q2hpbGQ7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IFF0V2ViS2l0LCBQaGFudG9tSlNcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XFxuXFx0XFx0XFx0XFx0XFx0XFx0alF1ZXJ5Lm1lcmdlKG5vZGVzLCB0bXAuY2hpbGROb2Rlcyk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gUmVtZW1iZXIgdGhlIHRvcC1sZXZlbCBjb250YWluZXJcXG5cXHRcXHRcXHRcXHRcXHRcXHR0bXAgPSBmcmFnbWVudC5maXJzdENoaWxkO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIEVuc3VyZSB0aGUgY3JlYXRlZCBub2RlcyBhcmUgb3JwaGFuZWQgKCMxMjM5MilcXG5cXHRcXHRcXHRcXHRcXHRcXHR0bXAudGV4dENvbnRlbnQgPSBcXFwiXFxcIjtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBSZW1vdmUgd3JhcHBlciBmcm9tIGZyYWdtZW50XFxuXFx0XFx0XFx0ZnJhZ21lbnQudGV4dENvbnRlbnQgPSBcXFwiXFxcIjtcXG5cXG5cXHRcXHRcXHRpID0gMDtcXG5cXHRcXHRcXHR3aGlsZSAoZWxlbSA9IG5vZGVzW2krK10pIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyAjNDA4NyAtIElmIG9yaWdpbiBhbmQgZGVzdGluYXRpb24gZWxlbWVudHMgYXJlIHRoZSBzYW1lLCBhbmQgdGhpcyBpc1xcblxcdFxcdFxcdFxcdC8vIHRoYXQgZWxlbWVudCwgZG8gbm90IGRvIGFueXRoaW5nXFxuXFx0XFx0XFx0XFx0aWYgKHNlbGVjdGlvbiAmJiBqUXVlcnkuaW5BcnJheShlbGVtLCBzZWxlY3Rpb24pICE9PSAtMSkge1xcblxcdFxcdFxcdFxcdFxcdGNvbnRpbnVlO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRjb250YWlucyA9IGpRdWVyeS5jb250YWlucyhlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0pO1xcblxcblxcdFxcdFxcdFxcdC8vIEFwcGVuZCB0byBmcmFnbWVudFxcblxcdFxcdFxcdFxcdHRtcCA9IGdldEFsbChmcmFnbWVudC5hcHBlbmRDaGlsZChlbGVtKSwgXFxcInNjcmlwdFxcXCIpO1xcblxcblxcdFxcdFxcdFxcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3RvcnlcXG5cXHRcXHRcXHRcXHRpZiAoY29udGFpbnMpIHtcXG5cXHRcXHRcXHRcXHRcXHRzZXRHbG9iYWxFdmFsKHRtcCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIENhcHR1cmUgZXhlY3V0YWJsZXNcXG5cXHRcXHRcXHRcXHRpZiAoc2NyaXB0cykge1xcblxcdFxcdFxcdFxcdFxcdGogPSAwO1xcblxcdFxcdFxcdFxcdFxcdHdoaWxlIChlbGVtID0gdG1wW2orK10pIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAocnNjcmlwdFR5cGUudGVzdChlbGVtLnR5cGUgfHwgXFxcIlxcXCIpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c2NyaXB0cy5wdXNoKGVsZW0pO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gZnJhZ21lbnQ7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjbGVhbkRhdGE6IGZ1bmN0aW9uIGNsZWFuRGF0YShlbGVtcykge1xcblxcdFxcdFxcdHZhciBkYXRhLFxcblxcdFxcdFxcdCAgICBlbGVtLFxcblxcdFxcdFxcdCAgICB0eXBlLFxcblxcdFxcdFxcdCAgICBrZXksXFxuXFx0XFx0XFx0ICAgIHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbCxcXG5cXHRcXHRcXHQgICAgaSA9IDA7XFxuXFxuXFx0XFx0XFx0Zm9yICg7IChlbGVtID0gZWxlbXNbaV0pICE9PSB1bmRlZmluZWQ7IGkrKykge1xcblxcdFxcdFxcdFxcdGlmIChqUXVlcnkuYWNjZXB0RGF0YShlbGVtKSkge1xcblxcdFxcdFxcdFxcdFxcdGtleSA9IGVsZW1bZGF0YV9wcml2LmV4cGFuZG9dO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmIChrZXkgJiYgKGRhdGEgPSBkYXRhX3ByaXYuY2FjaGVba2V5XSkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoZGF0YS5ldmVudHMpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRmb3IgKHR5cGUgaW4gZGF0YS5ldmVudHMpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoc3BlY2lhbFt0eXBlXSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGpRdWVyeS5ldmVudC5yZW1vdmUoZWxlbSwgdHlwZSk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gVGhpcyBpcyBhIHNob3J0Y3V0IHRvIGF2b2lkIGpRdWVyeS5ldmVudC5yZW1vdmUncyBvdmVyaGVhZFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0alF1ZXJ5LnJlbW92ZUV2ZW50KGVsZW0sIHR5cGUsIGRhdGEuaGFuZGxlKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoZGF0YV9wcml2LmNhY2hlW2tleV0pIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBEaXNjYXJkIGFueSByZW1haW5pbmcgYHByaXZhdGVgIGRhdGFcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRkZWxldGUgZGF0YV9wcml2LmNhY2hlW2tleV07XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0Ly8gRGlzY2FyZCBhbnkgcmVtYWluaW5nIGB1c2VyYCBkYXRhXFxuXFx0XFx0XFx0XFx0ZGVsZXRlIGRhdGFfdXNlci5jYWNoZVtlbGVtW2RhdGFfdXNlci5leHBhbmRvXV07XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9KTtcXG5cXG5cXHRqUXVlcnkuZm4uZXh0ZW5kKHtcXG5cXHRcXHR0ZXh0OiBmdW5jdGlvbiB0ZXh0KHZhbHVlKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGFjY2Vzcyh0aGlzLCBmdW5jdGlvbiAodmFsdWUpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IGpRdWVyeS50ZXh0KHRoaXMpIDogdGhpcy5lbXB0eSgpLmVhY2goZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdGlmICh0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLnRleHRDb250ZW50ID0gdmFsdWU7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdGFwcGVuZDogZnVuY3Rpb24gYXBwZW5kKCkge1xcblxcdFxcdFxcdHJldHVybiB0aGlzLmRvbU1hbmlwKGFyZ3VtZW50cywgZnVuY3Rpb24gKGVsZW0pIHtcXG5cXHRcXHRcXHRcXHRpZiAodGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5KSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCh0aGlzLCBlbGVtKTtcXG5cXHRcXHRcXHRcXHRcXHR0YXJnZXQuYXBwZW5kQ2hpbGQoZWxlbSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0pO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0cHJlcGVuZDogZnVuY3Rpb24gcHJlcGVuZCgpIHtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5kb21NYW5pcChhcmd1bWVudHMsIGZ1bmN0aW9uIChlbGVtKSB7XFxuXFx0XFx0XFx0XFx0aWYgKHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSkge1xcblxcdFxcdFxcdFxcdFxcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQodGhpcywgZWxlbSk7XFxuXFx0XFx0XFx0XFx0XFx0dGFyZ2V0Lmluc2VydEJlZm9yZShlbGVtLCB0YXJnZXQuZmlyc3RDaGlsZCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0pO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0YmVmb3JlOiBmdW5jdGlvbiBiZWZvcmUoKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZG9tTWFuaXAoYXJndW1lbnRzLCBmdW5jdGlvbiAoZWxlbSkge1xcblxcdFxcdFxcdFxcdGlmICh0aGlzLnBhcmVudE5vZGUpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsZW0sIHRoaXMpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdGFmdGVyOiBmdW5jdGlvbiBhZnRlcigpIHtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5kb21NYW5pcChhcmd1bWVudHMsIGZ1bmN0aW9uIChlbGVtKSB7XFxuXFx0XFx0XFx0XFx0aWYgKHRoaXMucGFyZW50Tm9kZSkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWxlbSwgdGhpcy5uZXh0U2libGluZyk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0pO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0cmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoc2VsZWN0b3IsIGtlZXBEYXRhIC8qIEludGVybmFsIFVzZSBPbmx5ICovKSB7XFxuXFx0XFx0XFx0dmFyIGVsZW0sXFxuXFx0XFx0XFx0ICAgIGVsZW1zID0gc2VsZWN0b3IgPyBqUXVlcnkuZmlsdGVyKHNlbGVjdG9yLCB0aGlzKSA6IHRoaXMsXFxuXFx0XFx0XFx0ICAgIGkgPSAwO1xcblxcblxcdFxcdFxcdGZvciAoOyAoZWxlbSA9IGVsZW1zW2ldKSAhPSBudWxsOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRpZiAoIWtlZXBEYXRhICYmIGVsZW0ubm9kZVR5cGUgPT09IDEpIHtcXG5cXHRcXHRcXHRcXHRcXHRqUXVlcnkuY2xlYW5EYXRhKGdldEFsbChlbGVtKSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmIChlbGVtLnBhcmVudE5vZGUpIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoa2VlcERhdGEgJiYgalF1ZXJ5LmNvbnRhaW5zKGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzZXRHbG9iYWxFdmFsKGdldEFsbChlbGVtLCBcXFwic2NyaXB0XFxcIikpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRlbGVtLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlbSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXHRcXHR9LFxcblxcblxcdFxcdGVtcHR5OiBmdW5jdGlvbiBlbXB0eSgpIHtcXG5cXHRcXHRcXHR2YXIgZWxlbSxcXG5cXHRcXHRcXHQgICAgaSA9IDA7XFxuXFxuXFx0XFx0XFx0Zm9yICg7IChlbGVtID0gdGhpc1tpXSkgIT0gbnVsbDsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGVsZW0ubm9kZVR5cGUgPT09IDEpIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBQcmV2ZW50IG1lbW9yeSBsZWFrc1xcblxcdFxcdFxcdFxcdFxcdGpRdWVyeS5jbGVhbkRhdGEoZ2V0QWxsKGVsZW0sIGZhbHNlKSk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gUmVtb3ZlIGFueSByZW1haW5pbmcgbm9kZXNcXG5cXHRcXHRcXHRcXHRcXHRlbGVtLnRleHRDb250ZW50ID0gXFxcIlxcXCI7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXHRcXHR9LFxcblxcblxcdFxcdGNsb25lOiBmdW5jdGlvbiBjbG9uZShkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cykge1xcblxcdFxcdFxcdGRhdGFBbmRFdmVudHMgPSBkYXRhQW5kRXZlbnRzID09IG51bGwgPyBmYWxzZSA6IGRhdGFBbmRFdmVudHM7XFxuXFx0XFx0XFx0ZGVlcERhdGFBbmRFdmVudHMgPSBkZWVwRGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZGF0YUFuZEV2ZW50cyA6IGRlZXBEYXRhQW5kRXZlbnRzO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGpRdWVyeS5jbG9uZSh0aGlzLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyk7XFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRodG1sOiBmdW5jdGlvbiBodG1sKHZhbHVlKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGFjY2Vzcyh0aGlzLCBmdW5jdGlvbiAodmFsdWUpIHtcXG5cXHRcXHRcXHRcXHR2YXIgZWxlbSA9IHRoaXNbMF0gfHwge30sXFxuXFx0XFx0XFx0XFx0ICAgIGkgPSAwLFxcblxcdFxcdFxcdFxcdCAgICBsID0gdGhpcy5sZW5ndGg7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBlbGVtLmlubmVySFRNTDtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gU2VlIGlmIHdlIGNhbiB0YWtlIGEgc2hvcnRjdXQgYW5kIGp1c3QgdXNlIGlubmVySFRNTFxcblxcdFxcdFxcdFxcdGlmICh0eXBlb2YgdmFsdWUgPT09IFxcXCJzdHJpbmdcXFwiICYmICFybm9Jbm5lcmh0bWwudGVzdCh2YWx1ZSkgJiYgIXdyYXBNYXBbKHJ0YWdOYW1lLmV4ZWModmFsdWUpIHx8IFtcXFwiXFxcIiwgXFxcIlxcXCJdKVsxXS50b0xvd2VyQ2FzZSgpXSkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhbHVlID0gdmFsdWUucmVwbGFjZShyeGh0bWxUYWcsIFxcXCI8JDE+PC8kMj5cXFwiKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0cnkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGZvciAoOyBpIDwgbDsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZWxlbSA9IHRoaXNbaV0gfHwge307XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gUmVtb3ZlIGVsZW1lbnQgbm9kZXMgYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtzXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKGVsZW0ubm9kZVR5cGUgPT09IDEpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRqUXVlcnkuY2xlYW5EYXRhKGdldEFsbChlbGVtLCBmYWxzZSkpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGVsZW0uaW5uZXJIVE1MID0gdmFsdWU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRlbGVtID0gMDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBJZiB1c2luZyBpbm5lckhUTUwgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgdXNlIHRoZSBmYWxsYmFjayBtZXRob2RcXG5cXHRcXHRcXHRcXHRcXHR9IGNhdGNoIChlKSB7fVxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAoZWxlbSkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuZW1wdHkoKS5hcHBlbmQodmFsdWUpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRyZXBsYWNlV2l0aDogZnVuY3Rpb24gcmVwbGFjZVdpdGgoKSB7XFxuXFx0XFx0XFx0dmFyIGFyZyA9IGFyZ3VtZW50c1swXTtcXG5cXG5cXHRcXHRcXHQvLyBNYWtlIHRoZSBjaGFuZ2VzLCByZXBsYWNpbmcgZWFjaCBjb250ZXh0IGVsZW1lbnQgd2l0aCB0aGUgbmV3IGNvbnRlbnRcXG5cXHRcXHRcXHR0aGlzLmRvbU1hbmlwKGFyZ3VtZW50cywgZnVuY3Rpb24gKGVsZW0pIHtcXG5cXHRcXHRcXHRcXHRhcmcgPSB0aGlzLnBhcmVudE5vZGU7XFxuXFxuXFx0XFx0XFx0XFx0alF1ZXJ5LmNsZWFuRGF0YShnZXRBbGwodGhpcykpO1xcblxcblxcdFxcdFxcdFxcdGlmIChhcmcpIHtcXG5cXHRcXHRcXHRcXHRcXHRhcmcucmVwbGFjZUNoaWxkKGVsZW0sIHRoaXMpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9KTtcXG5cXG5cXHRcXHRcXHQvLyBGb3JjZSByZW1vdmFsIGlmIHRoZXJlIHdhcyBubyBuZXcgY29udGVudCAoZS5nLiwgZnJvbSBlbXB0eSBhcmd1bWVudHMpXFxuXFx0XFx0XFx0cmV0dXJuIGFyZyAmJiAoYXJnLmxlbmd0aCB8fCBhcmcubm9kZVR5cGUpID8gdGhpcyA6IHRoaXMucmVtb3ZlKCk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRkZXRhY2g6IGZ1bmN0aW9uIGRldGFjaChzZWxlY3Rvcikge1xcblxcdFxcdFxcdHJldHVybiB0aGlzLnJlbW92ZShzZWxlY3RvciwgdHJ1ZSk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRkb21NYW5pcDogZnVuY3Rpb24gZG9tTWFuaXAoYXJncywgY2FsbGJhY2spIHtcXG5cXG5cXHRcXHRcXHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXFxuXFx0XFx0XFx0YXJncyA9IGNvbmNhdC5hcHBseShbXSwgYXJncyk7XFxuXFxuXFx0XFx0XFx0dmFyIGZyYWdtZW50LFxcblxcdFxcdFxcdCAgICBmaXJzdCxcXG5cXHRcXHRcXHQgICAgc2NyaXB0cyxcXG5cXHRcXHRcXHQgICAgaGFzU2NyaXB0cyxcXG5cXHRcXHRcXHQgICAgbm9kZSxcXG5cXHRcXHRcXHQgICAgZG9jLFxcblxcdFxcdFxcdCAgICBpID0gMCxcXG5cXHRcXHRcXHQgICAgbCA9IHRoaXMubGVuZ3RoLFxcblxcdFxcdFxcdCAgICBzZXQgPSB0aGlzLFxcblxcdFxcdFxcdCAgICBpTm9DbG9uZSA9IGwgLSAxLFxcblxcdFxcdFxcdCAgICB2YWx1ZSA9IGFyZ3NbMF0sXFxuXFx0XFx0XFx0ICAgIGlzRnVuY3Rpb24gPSBqUXVlcnkuaXNGdW5jdGlvbih2YWx1ZSk7XFxuXFxuXFx0XFx0XFx0Ly8gV2UgY2FuJ3QgY2xvbmVOb2RlIGZyYWdtZW50cyB0aGF0IGNvbnRhaW4gY2hlY2tlZCwgaW4gV2ViS2l0XFxuXFx0XFx0XFx0aWYgKGlzRnVuY3Rpb24gfHwgbCA+IDEgJiYgdHlwZW9mIHZhbHVlID09PSBcXFwic3RyaW5nXFxcIiAmJiAhc3VwcG9ydC5jaGVja0Nsb25lICYmIHJjaGVja2VkLnRlc3QodmFsdWUpKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoaW5kZXgpIHtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgc2VsZiA9IHNldC5lcShpbmRleCk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGlzRnVuY3Rpb24pIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRhcmdzWzBdID0gdmFsdWUuY2FsbCh0aGlzLCBpbmRleCwgc2VsZi5odG1sKCkpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRzZWxmLmRvbU1hbmlwKGFyZ3MsIGNhbGxiYWNrKTtcXG5cXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKGwpIHtcXG5cXHRcXHRcXHRcXHRmcmFnbWVudCA9IGpRdWVyeS5idWlsZEZyYWdtZW50KGFyZ3MsIHRoaXNbMF0ub3duZXJEb2N1bWVudCwgZmFsc2UsIHRoaXMpO1xcblxcdFxcdFxcdFxcdGZpcnN0ID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoZnJhZ21lbnQuY2hpbGROb2Rlcy5sZW5ndGggPT09IDEpIHtcXG5cXHRcXHRcXHRcXHRcXHRmcmFnbWVudCA9IGZpcnN0O1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAoZmlyc3QpIHtcXG5cXHRcXHRcXHRcXHRcXHRzY3JpcHRzID0galF1ZXJ5Lm1hcChnZXRBbGwoZnJhZ21lbnQsIFxcXCJzY3JpcHRcXFwiKSwgZGlzYWJsZVNjcmlwdCk7XFxuXFx0XFx0XFx0XFx0XFx0aGFzU2NyaXB0cyA9IHNjcmlwdHMubGVuZ3RoO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIFVzZSB0aGUgb3JpZ2luYWwgZnJhZ21lbnQgZm9yIHRoZSBsYXN0IGl0ZW0gaW5zdGVhZCBvZiB0aGUgZmlyc3QgYmVjYXVzZSBpdCBjYW4gZW5kIHVwXFxuXFx0XFx0XFx0XFx0XFx0Ly8gYmVpbmcgZW1wdGllZCBpbmNvcnJlY3RseSBpbiBjZXJ0YWluIHNpdHVhdGlvbnMgKCM4MDcwKS5cXG5cXHRcXHRcXHRcXHRcXHRmb3IgKDsgaSA8IGw7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdFxcdG5vZGUgPSBmcmFnbWVudDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoaSAhPT0gaU5vQ2xvbmUpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRub2RlID0galF1ZXJ5LmNsb25lKG5vZGUsIHRydWUsIHRydWUpO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIEtlZXAgcmVmZXJlbmNlcyB0byBjbG9uZWQgc2NyaXB0cyBmb3IgbGF0ZXIgcmVzdG9yYXRpb25cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoaGFzU2NyaXB0cykge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IFF0V2ViS2l0XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8galF1ZXJ5Lm1lcmdlIGJlY2F1c2UgcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93c1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGpRdWVyeS5tZXJnZShzY3JpcHRzLCBnZXRBbGwobm9kZSwgXFxcInNjcmlwdFxcXCIpKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdGNhbGxiYWNrLmNhbGwodGhpc1tpXSwgbm9kZSwgaSk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdGlmIChoYXNTY3JpcHRzKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZG9jID0gc2NyaXB0c1tzY3JpcHRzLmxlbmd0aCAtIDFdLm93bmVyRG9jdW1lbnQ7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gUmVlbmFibGUgc2NyaXB0c1xcblxcdFxcdFxcdFxcdFxcdFxcdGpRdWVyeS5tYXAoc2NyaXB0cywgcmVzdG9yZVNjcmlwdCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gRXZhbHVhdGUgZXhlY3V0YWJsZSBzY3JpcHRzIG9uIGZpcnN0IGRvY3VtZW50IGluc2VydGlvblxcblxcdFxcdFxcdFxcdFxcdFxcdGZvciAoaSA9IDA7IGkgPCBoYXNTY3JpcHRzOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRub2RlID0gc2NyaXB0c1tpXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAocnNjcmlwdFR5cGUudGVzdChub2RlLnR5cGUgfHwgXFxcIlxcXCIpICYmICFkYXRhX3ByaXYuYWNjZXNzKG5vZGUsIFxcXCJnbG9iYWxFdmFsXFxcIikgJiYgalF1ZXJ5LmNvbnRhaW5zKGRvYywgbm9kZSkpIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAobm9kZS5zcmMpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBPcHRpb25hbCBBSkFYIGRlcGVuZGVuY3ksIGJ1dCB3b24ndCBydW4gc2NyaXB0cyBpZiBub3QgcHJlc2VudFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChqUXVlcnkuX2V2YWxVcmwpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRqUXVlcnkuX2V2YWxVcmwobm9kZS5zcmMpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGpRdWVyeS5nbG9iYWxFdmFsKG5vZGUudGV4dENvbnRlbnQucmVwbGFjZShyY2xlYW5TY3JpcHQsIFxcXCJcXFwiKSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0XFx0fVxcblxcdH0pO1xcblxcblxcdGpRdWVyeS5lYWNoKHtcXG5cXHRcXHRhcHBlbmRUbzogXFxcImFwcGVuZFxcXCIsXFxuXFx0XFx0cHJlcGVuZFRvOiBcXFwicHJlcGVuZFxcXCIsXFxuXFx0XFx0aW5zZXJ0QmVmb3JlOiBcXFwiYmVmb3JlXFxcIixcXG5cXHRcXHRpbnNlcnRBZnRlcjogXFxcImFmdGVyXFxcIixcXG5cXHRcXHRyZXBsYWNlQWxsOiBcXFwicmVwbGFjZVdpdGhcXFwiXFxuXFx0fSwgZnVuY3Rpb24gKG5hbWUsIG9yaWdpbmFsKSB7XFxuXFx0XFx0alF1ZXJ5LmZuW25hbWVdID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XFxuXFx0XFx0XFx0dmFyIGVsZW1zLFxcblxcdFxcdFxcdCAgICByZXQgPSBbXSxcXG5cXHRcXHRcXHQgICAgaW5zZXJ0ID0galF1ZXJ5KHNlbGVjdG9yKSxcXG5cXHRcXHRcXHQgICAgbGFzdCA9IGluc2VydC5sZW5ndGggLSAxLFxcblxcdFxcdFxcdCAgICBpID0gMDtcXG5cXG5cXHRcXHRcXHRmb3IgKDsgaSA8PSBsYXN0OyBpKyspIHtcXG5cXHRcXHRcXHRcXHRlbGVtcyA9IGkgPT09IGxhc3QgPyB0aGlzIDogdGhpcy5jbG9uZSh0cnVlKTtcXG5cXHRcXHRcXHRcXHRqUXVlcnkoaW5zZXJ0W2ldKVtvcmlnaW5hbF0oZWxlbXMpO1xcblxcblxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IFF0V2ViS2l0XFxuXFx0XFx0XFx0XFx0Ly8gLmdldCgpIGJlY2F1c2UgcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93c1xcblxcdFxcdFxcdFxcdHB1c2guYXBwbHkocmV0LCBlbGVtcy5nZXQoKSk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLnB1c2hTdGFjayhyZXQpO1xcblxcdFxcdH07XFxuXFx0fSk7XFxuXFxuXFx0dmFyIGlmcmFtZSxcXG5cXHQgICAgZWxlbWRpc3BsYXkgPSB7fTtcXG5cXG5cXHQvKipcXG4gICogUmV0cmlldmUgdGhlIGFjdHVhbCBkaXNwbGF5IG9mIGEgZWxlbWVudFxcbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBub2RlTmFtZSBvZiB0aGUgZWxlbWVudFxcbiAgKiBAcGFyYW0ge09iamVjdH0gZG9jIERvY3VtZW50IG9iamVjdFxcbiAgKi9cXG5cXHQvLyBDYWxsZWQgb25seSBmcm9tIHdpdGhpbiBkZWZhdWx0RGlzcGxheVxcblxcdGZ1bmN0aW9uIGFjdHVhbERpc3BsYXkobmFtZSwgZG9jKSB7XFxuXFx0XFx0dmFyIHN0eWxlLFxcblxcdFxcdCAgICBlbGVtID0galF1ZXJ5KGRvYy5jcmVhdGVFbGVtZW50KG5hbWUpKS5hcHBlbmRUbyhkb2MuYm9keSksXFxuXFxuXFxuXFx0XFx0Ly8gZ2V0RGVmYXVsdENvbXB1dGVkU3R5bGUgbWlnaHQgYmUgcmVsaWFibHkgdXNlZCBvbmx5IG9uIGF0dGFjaGVkIGVsZW1lbnRcXG5cXHRcXHRkaXNwbGF5ID0gd2luZG93LmdldERlZmF1bHRDb21wdXRlZFN0eWxlICYmIChzdHlsZSA9IHdpbmRvdy5nZXREZWZhdWx0Q29tcHV0ZWRTdHlsZShlbGVtWzBdKSkgP1xcblxcblxcdFxcdC8vIFVzZSBvZiB0aGlzIG1ldGhvZCBpcyBhIHRlbXBvcmFyeSBmaXggKG1vcmUgbGlrZSBvcHRpbWl6YXRpb24pIHVudGlsIHNvbWV0aGluZyBiZXR0ZXIgY29tZXMgYWxvbmcsXFxuXFx0XFx0Ly8gc2luY2UgaXQgd2FzIHJlbW92ZWQgZnJvbSBzcGVjaWZpY2F0aW9uIGFuZCBzdXBwb3J0ZWQgb25seSBpbiBGRlxcblxcdFxcdHN0eWxlLmRpc3BsYXkgOiBqUXVlcnkuY3NzKGVsZW1bMF0sIFxcXCJkaXNwbGF5XFxcIik7XFxuXFxuXFx0XFx0Ly8gV2UgZG9uJ3QgaGF2ZSBhbnkgZGF0YSBzdG9yZWQgb24gdGhlIGVsZW1lbnQsXFxuXFx0XFx0Ly8gc28gdXNlIFxcXCJkZXRhY2hcXFwiIG1ldGhvZCBhcyBmYXN0IHdheSB0byBnZXQgcmlkIG9mIHRoZSBlbGVtZW50XFxuXFx0XFx0ZWxlbS5kZXRhY2goKTtcXG5cXG5cXHRcXHRyZXR1cm4gZGlzcGxheTtcXG5cXHR9XFxuXFxuXFx0LyoqXFxuICAqIFRyeSB0byBkZXRlcm1pbmUgdGhlIGRlZmF1bHQgZGlzcGxheSB2YWx1ZSBvZiBhbiBlbGVtZW50XFxuICAqIEBwYXJhbSB7U3RyaW5nfSBub2RlTmFtZVxcbiAgKi9cXG5cXHRmdW5jdGlvbiBkZWZhdWx0RGlzcGxheShub2RlTmFtZSkge1xcblxcdFxcdHZhciBkb2MgPSBkb2N1bWVudCxcXG5cXHRcXHQgICAgZGlzcGxheSA9IGVsZW1kaXNwbGF5W25vZGVOYW1lXTtcXG5cXG5cXHRcXHRpZiAoIWRpc3BsYXkpIHtcXG5cXHRcXHRcXHRkaXNwbGF5ID0gYWN0dWFsRGlzcGxheShub2RlTmFtZSwgZG9jKTtcXG5cXG5cXHRcXHRcXHQvLyBJZiB0aGUgc2ltcGxlIHdheSBmYWlscywgcmVhZCBmcm9tIGluc2lkZSBhbiBpZnJhbWVcXG5cXHRcXHRcXHRpZiAoZGlzcGxheSA9PT0gXFxcIm5vbmVcXFwiIHx8ICFkaXNwbGF5KSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gVXNlIHRoZSBhbHJlYWR5LWNyZWF0ZWQgaWZyYW1lIGlmIHBvc3NpYmxlXFxuXFx0XFx0XFx0XFx0aWZyYW1lID0gKGlmcmFtZSB8fCBqUXVlcnkoXFxcIjxpZnJhbWUgZnJhbWVib3JkZXI9JzAnIHdpZHRoPScwJyBoZWlnaHQ9JzAnLz5cXFwiKSkuYXBwZW5kVG8oZG9jLmRvY3VtZW50RWxlbWVudCk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQWx3YXlzIHdyaXRlIGEgbmV3IEhUTUwgc2tlbGV0b24gc28gV2Via2l0IGFuZCBGaXJlZm94IGRvbid0IGNob2tlIG9uIHJldXNlXFxuXFx0XFx0XFx0XFx0ZG9jID0gaWZyYW1lWzBdLmNvbnRlbnREb2N1bWVudDtcXG5cXG5cXHRcXHRcXHRcXHQvLyBTdXBwb3J0OiBJRVxcblxcdFxcdFxcdFxcdGRvYy53cml0ZSgpO1xcblxcdFxcdFxcdFxcdGRvYy5jbG9zZSgpO1xcblxcblxcdFxcdFxcdFxcdGRpc3BsYXkgPSBhY3R1YWxEaXNwbGF5KG5vZGVOYW1lLCBkb2MpO1xcblxcdFxcdFxcdFxcdGlmcmFtZS5kZXRhY2goKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gU3RvcmUgdGhlIGNvcnJlY3QgZGVmYXVsdCBkaXNwbGF5XFxuXFx0XFx0XFx0ZWxlbWRpc3BsYXlbbm9kZU5hbWVdID0gZGlzcGxheTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIGRpc3BsYXk7XFxuXFx0fVxcblxcdHZhciBybWFyZ2luID0gL15tYXJnaW4vO1xcblxcblxcdHZhciBybnVtbm9ucHggPSBuZXcgUmVnRXhwKFxcXCJeKFxcXCIgKyBwbnVtICsgXFxcIikoPyFweClbYS16JV0rJFxcXCIsIFxcXCJpXFxcIik7XFxuXFxuXFx0dmFyIGdldFN0eWxlcyA9IGZ1bmN0aW9uIGdldFN0eWxlcyhlbGVtKSB7XFxuXFx0XFx0Ly8gU3VwcG9ydDogSUU8PTExKywgRmlyZWZveDw9MzArICgjMTUwOTgsICMxNDE1MClcXG5cXHRcXHQvLyBJRSB0aHJvd3Mgb24gZWxlbWVudHMgY3JlYXRlZCBpbiBwb3B1cHNcXG5cXHRcXHQvLyBGRiBtZWFud2hpbGUgdGhyb3dzIG9uIGZyYW1lIGVsZW1lbnRzIHRocm91Z2ggXFxcImRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGVcXFwiXFxuXFx0XFx0aWYgKGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5vcGVuZXIpIHtcXG5cXHRcXHRcXHRyZXR1cm4gZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoZWxlbSwgbnVsbCk7XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtLCBudWxsKTtcXG5cXHR9O1xcblxcblxcdGZ1bmN0aW9uIGN1ckNTUyhlbGVtLCBuYW1lLCBjb21wdXRlZCkge1xcblxcdFxcdHZhciB3aWR0aCxcXG5cXHRcXHQgICAgbWluV2lkdGgsXFxuXFx0XFx0ICAgIG1heFdpZHRoLFxcblxcdFxcdCAgICByZXQsXFxuXFx0XFx0ICAgIHN0eWxlID0gZWxlbS5zdHlsZTtcXG5cXG5cXHRcXHRjb21wdXRlZCA9IGNvbXB1dGVkIHx8IGdldFN0eWxlcyhlbGVtKTtcXG5cXG5cXHRcXHQvLyBTdXBwb3J0OiBJRTlcXG5cXHRcXHQvLyBnZXRQcm9wZXJ0eVZhbHVlIGlzIG9ubHkgbmVlZGVkIGZvciAuY3NzKCdmaWx0ZXInKSAoIzEyNTM3KVxcblxcdFxcdGlmIChjb21wdXRlZCkge1xcblxcdFxcdFxcdHJldCA9IGNvbXB1dGVkLmdldFByb3BlcnR5VmFsdWUobmFtZSkgfHwgY29tcHV0ZWRbbmFtZV07XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmIChjb21wdXRlZCkge1xcblxcblxcdFxcdFxcdGlmIChyZXQgPT09IFxcXCJcXFwiICYmICFqUXVlcnkuY29udGFpbnMoZWxlbS5vd25lckRvY3VtZW50LCBlbGVtKSkge1xcblxcdFxcdFxcdFxcdHJldCA9IGpRdWVyeS5zdHlsZShlbGVtLCBuYW1lKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gU3VwcG9ydDogaU9TIDwgNlxcblxcdFxcdFxcdC8vIEEgdHJpYnV0ZSB0byB0aGUgXFxcImF3ZXNvbWUgaGFjayBieSBEZWFuIEVkd2FyZHNcXFwiXFxuXFx0XFx0XFx0Ly8gaU9TIDwgNiAoYXQgbGVhc3QpIHJldHVybnMgcGVyY2VudGFnZSBmb3IgYSBsYXJnZXIgc2V0IG9mIHZhbHVlcywgYnV0IHdpZHRoIHNlZW1zIHRvIGJlIHJlbGlhYmx5IHBpeGVsc1xcblxcdFxcdFxcdC8vIHRoaXMgaXMgYWdhaW5zdCB0aGUgQ1NTT00gZHJhZnQgc3BlYzogaHR0cDovL2Rldi53My5vcmcvY3Nzd2cvY3Nzb20vI3Jlc29sdmVkLXZhbHVlc1xcblxcdFxcdFxcdGlmIChybnVtbm9ucHgudGVzdChyZXQpICYmIHJtYXJnaW4udGVzdChuYW1lKSkge1xcblxcblxcdFxcdFxcdFxcdC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCB2YWx1ZXNcXG5cXHRcXHRcXHRcXHR3aWR0aCA9IHN0eWxlLndpZHRoO1xcblxcdFxcdFxcdFxcdG1pbldpZHRoID0gc3R5bGUubWluV2lkdGg7XFxuXFx0XFx0XFx0XFx0bWF4V2lkdGggPSBzdHlsZS5tYXhXaWR0aDtcXG5cXG5cXHRcXHRcXHRcXHQvLyBQdXQgaW4gdGhlIG5ldyB2YWx1ZXMgdG8gZ2V0IGEgY29tcHV0ZWQgdmFsdWUgb3V0XFxuXFx0XFx0XFx0XFx0c3R5bGUubWluV2lkdGggPSBzdHlsZS5tYXhXaWR0aCA9IHN0eWxlLndpZHRoID0gcmV0O1xcblxcdFxcdFxcdFxcdHJldCA9IGNvbXB1dGVkLndpZHRoO1xcblxcblxcdFxcdFxcdFxcdC8vIFJldmVydCB0aGUgY2hhbmdlZCB2YWx1ZXNcXG5cXHRcXHRcXHRcXHRzdHlsZS53aWR0aCA9IHdpZHRoO1xcblxcdFxcdFxcdFxcdHN0eWxlLm1pbldpZHRoID0gbWluV2lkdGg7XFxuXFx0XFx0XFx0XFx0c3R5bGUubWF4V2lkdGggPSBtYXhXaWR0aDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiByZXQgIT09IHVuZGVmaW5lZCA/XFxuXFx0XFx0Ly8gU3VwcG9ydDogSUVcXG5cXHRcXHQvLyBJRSByZXR1cm5zIHpJbmRleCB2YWx1ZSBhcyBhbiBpbnRlZ2VyLlxcblxcdFxcdHJldCArIFxcXCJcXFwiIDogcmV0O1xcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBhZGRHZXRIb29rSWYoY29uZGl0aW9uRm4sIGhvb2tGbikge1xcblxcdFxcdC8vIERlZmluZSB0aGUgaG9vaywgd2UnbGwgY2hlY2sgb24gdGhlIGZpcnN0IHJ1biBpZiBpdCdzIHJlYWxseSBuZWVkZWQuXFxuXFx0XFx0cmV0dXJuIHtcXG5cXHRcXHRcXHRnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcXG5cXHRcXHRcXHRcXHRpZiAoY29uZGl0aW9uRm4oKSkge1xcblxcdFxcdFxcdFxcdFxcdC8vIEhvb2sgbm90IG5lZWRlZCAob3IgaXQncyBub3QgcG9zc2libGUgdG8gdXNlIGl0IGR1ZVxcblxcdFxcdFxcdFxcdFxcdC8vIHRvIG1pc3NpbmcgZGVwZW5kZW5jeSksIHJlbW92ZSBpdC5cXG5cXHRcXHRcXHRcXHRcXHRkZWxldGUgdGhpcy5nZXQ7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBIb29rIG5lZWRlZDsgcmVkZWZpbmUgaXQgc28gdGhhdCB0aGUgc3VwcG9ydCB0ZXN0IGlzIG5vdCBleGVjdXRlZCBhZ2Fpbi5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gKHRoaXMuZ2V0ID0gaG9va0ZuKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9O1xcblxcdH1cXG5cXG5cXHQoZnVuY3Rpb24gKCkge1xcblxcdFxcdHZhciBwaXhlbFBvc2l0aW9uVmFsLFxcblxcdFxcdCAgICBib3hTaXppbmdSZWxpYWJsZVZhbCxcXG5cXHRcXHQgICAgZG9jRWxlbSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcXG5cXHRcXHQgICAgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwiZGl2XFxcIiksXFxuXFx0XFx0ICAgIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXFxcImRpdlxcXCIpO1xcblxcblxcdFxcdGlmICghZGl2LnN0eWxlKSB7XFxuXFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBTdXBwb3J0OiBJRTktMTErXFxuXFx0XFx0Ly8gU3R5bGUgb2YgY2xvbmVkIGVsZW1lbnQgYWZmZWN0cyBzb3VyY2UgZWxlbWVudCBjbG9uZWQgKCM4OTA4KVxcblxcdFxcdGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFxcXCJjb250ZW50LWJveFxcXCI7XFxuXFx0XFx0ZGl2LmNsb25lTm9kZSh0cnVlKS5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFxcXCJcXFwiO1xcblxcdFxcdHN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlID0gZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID09PSBcXFwiY29udGVudC1ib3hcXFwiO1xcblxcblxcdFxcdGNvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gXFxcImJvcmRlcjowO3dpZHRoOjA7aGVpZ2h0OjA7dG9wOjA7bGVmdDotOTk5OXB4O21hcmdpbi10b3A6MXB4O1xcXCIgKyBcXFwicG9zaXRpb246YWJzb2x1dGVcXFwiO1xcblxcdFxcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChkaXYpO1xcblxcblxcdFxcdC8vIEV4ZWN1dGluZyBib3RoIHBpeGVsUG9zaXRpb24gJiBib3hTaXppbmdSZWxpYWJsZSB0ZXN0cyByZXF1aXJlIG9ubHkgb25lIGxheW91dFxcblxcdFxcdC8vIHNvIHRoZXkncmUgZXhlY3V0ZWQgYXQgdGhlIHNhbWUgdGltZSB0byBzYXZlIHRoZSBzZWNvbmQgY29tcHV0YXRpb24uXFxuXFx0XFx0ZnVuY3Rpb24gY29tcHV0ZVBpeGVsUG9zaXRpb25BbmRCb3hTaXppbmdSZWxpYWJsZSgpIHtcXG5cXHRcXHRcXHRkaXYuc3R5bGUuY3NzVGV4dCA9XFxuXFx0XFx0XFx0Ly8gU3VwcG9ydDogRmlyZWZveDwyOSwgQW5kcm9pZCAyLjNcXG5cXHRcXHRcXHQvLyBWZW5kb3ItcHJlZml4IGJveC1zaXppbmdcXG5cXHRcXHRcXHRcXFwiLXdlYmtpdC1ib3gtc2l6aW5nOmJvcmRlci1ib3g7LW1vei1ib3gtc2l6aW5nOmJvcmRlci1ib3g7XFxcIiArIFxcXCJib3gtc2l6aW5nOmJvcmRlci1ib3g7ZGlzcGxheTpibG9jazttYXJnaW4tdG9wOjElO3RvcDoxJTtcXFwiICsgXFxcImJvcmRlcjoxcHg7cGFkZGluZzoxcHg7d2lkdGg6NHB4O3Bvc2l0aW9uOmFic29sdXRlXFxcIjtcXG5cXHRcXHRcXHRkaXYuaW5uZXJIVE1MID0gXFxcIlxcXCI7XFxuXFx0XFx0XFx0ZG9jRWxlbS5hcHBlbmRDaGlsZChjb250YWluZXIpO1xcblxcblxcdFxcdFxcdHZhciBkaXZTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRpdiwgbnVsbCk7XFxuXFx0XFx0XFx0cGl4ZWxQb3NpdGlvblZhbCA9IGRpdlN0eWxlLnRvcCAhPT0gXFxcIjElXFxcIjtcXG5cXHRcXHRcXHRib3hTaXppbmdSZWxpYWJsZVZhbCA9IGRpdlN0eWxlLndpZHRoID09PSBcXFwiNHB4XFxcIjtcXG5cXG5cXHRcXHRcXHRkb2NFbGVtLnJlbW92ZUNoaWxkKGNvbnRhaW5lcik7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFN1cHBvcnQ6IG5vZGUuanMganNkb21cXG5cXHRcXHQvLyBEb24ndCBhc3N1bWUgdGhhdCBnZXRDb21wdXRlZFN0eWxlIGlzIGEgcHJvcGVydHkgb2YgdGhlIGdsb2JhbCBvYmplY3RcXG5cXHRcXHRpZiAod2luZG93LmdldENvbXB1dGVkU3R5bGUpIHtcXG5cXHRcXHRcXHRqUXVlcnkuZXh0ZW5kKHN1cHBvcnQsIHtcXG5cXHRcXHRcXHRcXHRwaXhlbFBvc2l0aW9uOiBmdW5jdGlvbiBwaXhlbFBvc2l0aW9uKCkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIFRoaXMgdGVzdCBpcyBleGVjdXRlZCBvbmx5IG9uY2UgYnV0IHdlIHN0aWxsIGRvIG1lbW9pemluZ1xcblxcdFxcdFxcdFxcdFxcdC8vIHNpbmNlIHdlIGNhbiB1c2UgdGhlIGJveFNpemluZ1JlbGlhYmxlIHByZS1jb21wdXRpbmcuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gTm8gbmVlZCB0byBjaGVjayBpZiB0aGUgdGVzdCB3YXMgYWxyZWFkeSBwZXJmb3JtZWQsIHRob3VnaC5cXG5cXHRcXHRcXHRcXHRcXHRjb21wdXRlUGl4ZWxQb3NpdGlvbkFuZEJveFNpemluZ1JlbGlhYmxlKCk7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHBpeGVsUG9zaXRpb25WYWw7XFxuXFx0XFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRcXHRib3hTaXppbmdSZWxpYWJsZTogZnVuY3Rpb24gYm94U2l6aW5nUmVsaWFibGUoKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGJveFNpemluZ1JlbGlhYmxlVmFsID09IG51bGwpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRjb21wdXRlUGl4ZWxQb3NpdGlvbkFuZEJveFNpemluZ1JlbGlhYmxlKCk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBib3hTaXppbmdSZWxpYWJsZVZhbDtcXG5cXHRcXHRcXHRcXHR9LFxcblxcdFxcdFxcdFxcdHJlbGlhYmxlTWFyZ2luUmlnaHQ6IGZ1bmN0aW9uIHJlbGlhYmxlTWFyZ2luUmlnaHQoKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogQW5kcm9pZCAyLjNcXG5cXHRcXHRcXHRcXHRcXHQvLyBDaGVjayBpZiBkaXYgd2l0aCBleHBsaWNpdCB3aWR0aCBhbmQgbm8gbWFyZ2luLXJpZ2h0IGluY29ycmVjdGx5XFxuXFx0XFx0XFx0XFx0XFx0Ly8gZ2V0cyBjb21wdXRlZCBtYXJnaW4tcmlnaHQgYmFzZWQgb24gd2lkdGggb2YgY29udGFpbmVyLiAoIzMzMzMpXFxuXFx0XFx0XFx0XFx0XFx0Ly8gV2ViS2l0IEJ1ZyAxMzM0MyAtIGdldENvbXB1dGVkU3R5bGUgcmV0dXJucyB3cm9uZyB2YWx1ZSBmb3IgbWFyZ2luLXJpZ2h0XFxuXFx0XFx0XFx0XFx0XFx0Ly8gVGhpcyBzdXBwb3J0IGZ1bmN0aW9uIGlzIG9ubHkgZXhlY3V0ZWQgb25jZSBzbyBubyBtZW1vaXppbmcgaXMgbmVlZGVkLlxcblxcdFxcdFxcdFxcdFxcdHZhciByZXQsXFxuXFx0XFx0XFx0XFx0XFx0ICAgIG1hcmdpbkRpdiA9IGRpdi5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxcXCJkaXZcXFwiKSk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gUmVzZXQgQ1NTOiBib3gtc2l6aW5nOyBkaXNwbGF5OyBtYXJnaW47IGJvcmRlcjsgcGFkZGluZ1xcblxcdFxcdFxcdFxcdFxcdG1hcmdpbkRpdi5zdHlsZS5jc3NUZXh0ID0gZGl2LnN0eWxlLmNzc1RleHQgPVxcblxcdFxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IEZpcmVmb3g8MjksIEFuZHJvaWQgMi4zXFxuXFx0XFx0XFx0XFx0XFx0Ly8gVmVuZG9yLXByZWZpeCBib3gtc2l6aW5nXFxuXFx0XFx0XFx0XFx0XFx0XFxcIi13ZWJraXQtYm94LXNpemluZzpjb250ZW50LWJveDstbW96LWJveC1zaXppbmc6Y29udGVudC1ib3g7XFxcIiArIFxcXCJib3gtc2l6aW5nOmNvbnRlbnQtYm94O2Rpc3BsYXk6YmxvY2s7bWFyZ2luOjA7Ym9yZGVyOjA7cGFkZGluZzowXFxcIjtcXG5cXHRcXHRcXHRcXHRcXHRtYXJnaW5EaXYuc3R5bGUubWFyZ2luUmlnaHQgPSBtYXJnaW5EaXYuc3R5bGUud2lkdGggPSBcXFwiMFxcXCI7XFxuXFx0XFx0XFx0XFx0XFx0ZGl2LnN0eWxlLndpZHRoID0gXFxcIjFweFxcXCI7XFxuXFx0XFx0XFx0XFx0XFx0ZG9jRWxlbS5hcHBlbmRDaGlsZChjb250YWluZXIpO1xcblxcblxcdFxcdFxcdFxcdFxcdHJldCA9ICFwYXJzZUZsb2F0KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG1hcmdpbkRpdiwgbnVsbCkubWFyZ2luUmlnaHQpO1xcblxcblxcdFxcdFxcdFxcdFxcdGRvY0VsZW0ucmVtb3ZlQ2hpbGQoY29udGFpbmVyKTtcXG5cXHRcXHRcXHRcXHRcXHRkaXYucmVtb3ZlQ2hpbGQobWFyZ2luRGl2KTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gcmV0O1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHR9XFxuXFx0fSkoKTtcXG5cXG5cXHQvLyBBIG1ldGhvZCBmb3IgcXVpY2tseSBzd2FwcGluZyBpbi9vdXQgQ1NTIHByb3BlcnRpZXMgdG8gZ2V0IGNvcnJlY3QgY2FsY3VsYXRpb25zLlxcblxcdGpRdWVyeS5zd2FwID0gZnVuY3Rpb24gKGVsZW0sIG9wdGlvbnMsIGNhbGxiYWNrLCBhcmdzKSB7XFxuXFx0XFx0dmFyIHJldCxcXG5cXHRcXHQgICAgbmFtZSxcXG5cXHRcXHQgICAgb2xkID0ge307XFxuXFxuXFx0XFx0Ly8gUmVtZW1iZXIgdGhlIG9sZCB2YWx1ZXMsIGFuZCBpbnNlcnQgdGhlIG5ldyBvbmVzXFxuXFx0XFx0Zm9yIChuYW1lIGluIG9wdGlvbnMpIHtcXG5cXHRcXHRcXHRvbGRbbmFtZV0gPSBlbGVtLnN0eWxlW25hbWVdO1xcblxcdFxcdFxcdGVsZW0uc3R5bGVbbmFtZV0gPSBvcHRpb25zW25hbWVdO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXQgPSBjYWxsYmFjay5hcHBseShlbGVtLCBhcmdzIHx8IFtdKTtcXG5cXG5cXHRcXHQvLyBSZXZlcnQgdGhlIG9sZCB2YWx1ZXNcXG5cXHRcXHRmb3IgKG5hbWUgaW4gb3B0aW9ucykge1xcblxcdFxcdFxcdGVsZW0uc3R5bGVbbmFtZV0gPSBvbGRbbmFtZV07XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiByZXQ7XFxuXFx0fTtcXG5cXG5cXHR2YXJcXG5cXHQvLyBTd2FwcGFibGUgaWYgZGlzcGxheSBpcyBub25lIG9yIHN0YXJ0cyB3aXRoIHRhYmxlIGV4Y2VwdCBcXFwidGFibGVcXFwiLCBcXFwidGFibGUtY2VsbFxcXCIsIG9yIFxcXCJ0YWJsZS1jYXB0aW9uXFxcIlxcblxcdC8vIFNlZSBoZXJlIGZvciBkaXNwbGF5IHZhbHVlczogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9DU1MvZGlzcGxheVxcblxcdHJkaXNwbGF5c3dhcCA9IC9eKG5vbmV8dGFibGUoPyEtY1tlYV0pLispLyxcXG5cXHQgICAgcm51bXNwbGl0ID0gbmV3IFJlZ0V4cChcXFwiXihcXFwiICsgcG51bSArIFxcXCIpKC4qKSRcXFwiLCBcXFwiaVxcXCIpLFxcblxcdCAgICBycmVsTnVtID0gbmV3IFJlZ0V4cChcXFwiXihbKy1dKT0oXFxcIiArIHBudW0gKyBcXFwiKVxcXCIsIFxcXCJpXFxcIiksXFxuXFx0ICAgIGNzc1Nob3cgPSB7IHBvc2l0aW9uOiBcXFwiYWJzb2x1dGVcXFwiLCB2aXNpYmlsaXR5OiBcXFwiaGlkZGVuXFxcIiwgZGlzcGxheTogXFxcImJsb2NrXFxcIiB9LFxcblxcdCAgICBjc3NOb3JtYWxUcmFuc2Zvcm0gPSB7XFxuXFx0XFx0bGV0dGVyU3BhY2luZzogXFxcIjBcXFwiLFxcblxcdFxcdGZvbnRXZWlnaHQ6IFxcXCI0MDBcXFwiXFxuXFx0fSxcXG5cXHQgICAgY3NzUHJlZml4ZXMgPSBbXFxcIldlYmtpdFxcXCIsIFxcXCJPXFxcIiwgXFxcIk1velxcXCIsIFxcXCJtc1xcXCJdO1xcblxcblxcdC8vIFJldHVybiBhIGNzcyBwcm9wZXJ0eSBtYXBwZWQgdG8gYSBwb3RlbnRpYWxseSB2ZW5kb3IgcHJlZml4ZWQgcHJvcGVydHlcXG5cXHRmdW5jdGlvbiB2ZW5kb3JQcm9wTmFtZShzdHlsZSwgbmFtZSkge1xcblxcblxcdFxcdC8vIFNob3J0Y3V0IGZvciBuYW1lcyB0aGF0IGFyZSBub3QgdmVuZG9yIHByZWZpeGVkXFxuXFx0XFx0aWYgKG5hbWUgaW4gc3R5bGUpIHtcXG5cXHRcXHRcXHRyZXR1cm4gbmFtZTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gQ2hlY2sgZm9yIHZlbmRvciBwcmVmaXhlZCBuYW1lc1xcblxcdFxcdHZhciBjYXBOYW1lID0gbmFtZVswXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKSxcXG5cXHRcXHQgICAgb3JpZ05hbWUgPSBuYW1lLFxcblxcdFxcdCAgICBpID0gY3NzUHJlZml4ZXMubGVuZ3RoO1xcblxcblxcdFxcdHdoaWxlIChpLS0pIHtcXG5cXHRcXHRcXHRuYW1lID0gY3NzUHJlZml4ZXNbaV0gKyBjYXBOYW1lO1xcblxcdFxcdFxcdGlmIChuYW1lIGluIHN0eWxlKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIG5hbWU7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gb3JpZ05hbWU7XFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIHNldFBvc2l0aXZlTnVtYmVyKGVsZW0sIHZhbHVlLCBzdWJ0cmFjdCkge1xcblxcdFxcdHZhciBtYXRjaGVzID0gcm51bXNwbGl0LmV4ZWModmFsdWUpO1xcblxcdFxcdHJldHVybiBtYXRjaGVzID9cXG5cXHRcXHQvLyBHdWFyZCBhZ2FpbnN0IHVuZGVmaW5lZCBcXFwic3VidHJhY3RcXFwiLCBlLmcuLCB3aGVuIHVzZWQgYXMgaW4gY3NzSG9va3NcXG5cXHRcXHRNYXRoLm1heCgwLCBtYXRjaGVzWzFdIC0gKHN1YnRyYWN0IHx8IDApKSArIChtYXRjaGVzWzJdIHx8IFxcXCJweFxcXCIpIDogdmFsdWU7XFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIGF1Z21lbnRXaWR0aE9ySGVpZ2h0KGVsZW0sIG5hbWUsIGV4dHJhLCBpc0JvcmRlckJveCwgc3R5bGVzKSB7XFxuXFx0XFx0dmFyIGkgPSBleHRyYSA9PT0gKGlzQm9yZGVyQm94ID8gXFxcImJvcmRlclxcXCIgOiBcXFwiY29udGVudFxcXCIpID9cXG5cXHRcXHQvLyBJZiB3ZSBhbHJlYWR5IGhhdmUgdGhlIHJpZ2h0IG1lYXN1cmVtZW50LCBhdm9pZCBhdWdtZW50YXRpb25cXG5cXHRcXHQ0IDpcXG5cXHRcXHQvLyBPdGhlcndpc2UgaW5pdGlhbGl6ZSBmb3IgaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCBwcm9wZXJ0aWVzXFxuXFx0XFx0bmFtZSA9PT0gXFxcIndpZHRoXFxcIiA/IDEgOiAwLFxcblxcdFxcdCAgICB2YWwgPSAwO1xcblxcblxcdFxcdGZvciAoOyBpIDwgNDsgaSArPSAyKSB7XFxuXFx0XFx0XFx0Ly8gQm90aCBib3ggbW9kZWxzIGV4Y2x1ZGUgbWFyZ2luLCBzbyBhZGQgaXQgaWYgd2Ugd2FudCBpdFxcblxcdFxcdFxcdGlmIChleHRyYSA9PT0gXFxcIm1hcmdpblxcXCIpIHtcXG5cXHRcXHRcXHRcXHR2YWwgKz0galF1ZXJ5LmNzcyhlbGVtLCBleHRyYSArIGNzc0V4cGFuZFtpXSwgdHJ1ZSwgc3R5bGVzKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKGlzQm9yZGVyQm94KSB7XFxuXFx0XFx0XFx0XFx0Ly8gYm9yZGVyLWJveCBpbmNsdWRlcyBwYWRkaW5nLCBzbyByZW1vdmUgaXQgaWYgd2Ugd2FudCBjb250ZW50XFxuXFx0XFx0XFx0XFx0aWYgKGV4dHJhID09PSBcXFwiY29udGVudFxcXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHR2YWwgLT0galF1ZXJ5LmNzcyhlbGVtLCBcXFwicGFkZGluZ1xcXCIgKyBjc3NFeHBhbmRbaV0sIHRydWUsIHN0eWxlcyk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIEF0IHRoaXMgcG9pbnQsIGV4dHJhIGlzbid0IGJvcmRlciBub3IgbWFyZ2luLCBzbyByZW1vdmUgYm9yZGVyXFxuXFx0XFx0XFx0XFx0aWYgKGV4dHJhICE9PSBcXFwibWFyZ2luXFxcIikge1xcblxcdFxcdFxcdFxcdFxcdHZhbCAtPSBqUXVlcnkuY3NzKGVsZW0sIFxcXCJib3JkZXJcXFwiICsgY3NzRXhwYW5kW2ldICsgXFxcIldpZHRoXFxcIiwgdHJ1ZSwgc3R5bGVzKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHQvLyBBdCB0aGlzIHBvaW50LCBleHRyYSBpc24ndCBjb250ZW50LCBzbyBhZGQgcGFkZGluZ1xcblxcdFxcdFxcdFxcdHZhbCArPSBqUXVlcnkuY3NzKGVsZW0sIFxcXCJwYWRkaW5nXFxcIiArIGNzc0V4cGFuZFtpXSwgdHJ1ZSwgc3R5bGVzKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBBdCB0aGlzIHBvaW50LCBleHRyYSBpc24ndCBjb250ZW50IG5vciBwYWRkaW5nLCBzbyBhZGQgYm9yZGVyXFxuXFx0XFx0XFx0XFx0aWYgKGV4dHJhICE9PSBcXFwicGFkZGluZ1xcXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHR2YWwgKz0galF1ZXJ5LmNzcyhlbGVtLCBcXFwiYm9yZGVyXFxcIiArIGNzc0V4cGFuZFtpXSArIFxcXCJXaWR0aFxcXCIsIHRydWUsIHN0eWxlcyk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIHZhbDtcXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gZ2V0V2lkdGhPckhlaWdodChlbGVtLCBuYW1lLCBleHRyYSkge1xcblxcblxcdFxcdC8vIFN0YXJ0IHdpdGggb2Zmc2V0IHByb3BlcnR5LCB3aGljaCBpcyBlcXVpdmFsZW50IHRvIHRoZSBib3JkZXItYm94IHZhbHVlXFxuXFx0XFx0dmFyIHZhbHVlSXNCb3JkZXJCb3ggPSB0cnVlLFxcblxcdFxcdCAgICB2YWwgPSBuYW1lID09PSBcXFwid2lkdGhcXFwiID8gZWxlbS5vZmZzZXRXaWR0aCA6IGVsZW0ub2Zmc2V0SGVpZ2h0LFxcblxcdFxcdCAgICBzdHlsZXMgPSBnZXRTdHlsZXMoZWxlbSksXFxuXFx0XFx0ICAgIGlzQm9yZGVyQm94ID0galF1ZXJ5LmNzcyhlbGVtLCBcXFwiYm94U2l6aW5nXFxcIiwgZmFsc2UsIHN0eWxlcykgPT09IFxcXCJib3JkZXItYm94XFxcIjtcXG5cXG5cXHRcXHQvLyBTb21lIG5vbi1odG1sIGVsZW1lbnRzIHJldHVybiB1bmRlZmluZWQgZm9yIG9mZnNldFdpZHRoLCBzbyBjaGVjayBmb3IgbnVsbC91bmRlZmluZWRcXG5cXHRcXHQvLyBzdmcgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02NDkyODVcXG5cXHRcXHQvLyBNYXRoTUwgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD00OTE2NjhcXG5cXHRcXHRpZiAodmFsIDw9IDAgfHwgdmFsID09IG51bGwpIHtcXG5cXHRcXHRcXHQvLyBGYWxsIGJhY2sgdG8gY29tcHV0ZWQgdGhlbiB1bmNvbXB1dGVkIGNzcyBpZiBuZWNlc3NhcnlcXG5cXHRcXHRcXHR2YWwgPSBjdXJDU1MoZWxlbSwgbmFtZSwgc3R5bGVzKTtcXG5cXHRcXHRcXHRpZiAodmFsIDwgMCB8fCB2YWwgPT0gbnVsbCkge1xcblxcdFxcdFxcdFxcdHZhbCA9IGVsZW0uc3R5bGVbbmFtZV07XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIENvbXB1dGVkIHVuaXQgaXMgbm90IHBpeGVscy4gU3RvcCBoZXJlIGFuZCByZXR1cm4uXFxuXFx0XFx0XFx0aWYgKHJudW1ub25weC50ZXN0KHZhbCkpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdmFsO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBDaGVjayBmb3Igc3R5bGUgaW4gY2FzZSBhIGJyb3dzZXIgd2hpY2ggcmV0dXJucyB1bnJlbGlhYmxlIHZhbHVlc1xcblxcdFxcdFxcdC8vIGZvciBnZXRDb21wdXRlZFN0eWxlIHNpbGVudGx5IGZhbGxzIGJhY2sgdG8gdGhlIHJlbGlhYmxlIGVsZW0uc3R5bGVcXG5cXHRcXHRcXHR2YWx1ZUlzQm9yZGVyQm94ID0gaXNCb3JkZXJCb3ggJiYgKHN1cHBvcnQuYm94U2l6aW5nUmVsaWFibGUoKSB8fCB2YWwgPT09IGVsZW0uc3R5bGVbbmFtZV0pO1xcblxcblxcdFxcdFxcdC8vIE5vcm1hbGl6ZSBcXFwiXFxcIiwgYXV0bywgYW5kIHByZXBhcmUgZm9yIGV4dHJhXFxuXFx0XFx0XFx0dmFsID0gcGFyc2VGbG9hdCh2YWwpIHx8IDA7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFVzZSB0aGUgYWN0aXZlIGJveC1zaXppbmcgbW9kZWwgdG8gYWRkL3N1YnRyYWN0IGlycmVsZXZhbnQgc3R5bGVzXFxuXFx0XFx0cmV0dXJuIHZhbCArIGF1Z21lbnRXaWR0aE9ySGVpZ2h0KGVsZW0sIG5hbWUsIGV4dHJhIHx8IChpc0JvcmRlckJveCA/IFxcXCJib3JkZXJcXFwiIDogXFxcImNvbnRlbnRcXFwiKSwgdmFsdWVJc0JvcmRlckJveCwgc3R5bGVzKSArIFxcXCJweFxcXCI7XFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIHNob3dIaWRlKGVsZW1lbnRzLCBzaG93KSB7XFxuXFx0XFx0dmFyIGRpc3BsYXksXFxuXFx0XFx0ICAgIGVsZW0sXFxuXFx0XFx0ICAgIGhpZGRlbixcXG5cXHRcXHQgICAgdmFsdWVzID0gW10sXFxuXFx0XFx0ICAgIGluZGV4ID0gMCxcXG5cXHRcXHQgICAgbGVuZ3RoID0gZWxlbWVudHMubGVuZ3RoO1xcblxcblxcdFxcdGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xcblxcdFxcdFxcdGVsZW0gPSBlbGVtZW50c1tpbmRleF07XFxuXFx0XFx0XFx0aWYgKCFlbGVtLnN0eWxlKSB7XFxuXFx0XFx0XFx0XFx0Y29udGludWU7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHZhbHVlc1tpbmRleF0gPSBkYXRhX3ByaXYuZ2V0KGVsZW0sIFxcXCJvbGRkaXNwbGF5XFxcIik7XFxuXFx0XFx0XFx0ZGlzcGxheSA9IGVsZW0uc3R5bGUuZGlzcGxheTtcXG5cXHRcXHRcXHRpZiAoc2hvdykge1xcblxcdFxcdFxcdFxcdC8vIFJlc2V0IHRoZSBpbmxpbmUgZGlzcGxheSBvZiB0aGlzIGVsZW1lbnQgdG8gbGVhcm4gaWYgaXQgaXNcXG5cXHRcXHRcXHRcXHQvLyBiZWluZyBoaWRkZW4gYnkgY2FzY2FkZWQgcnVsZXMgb3Igbm90XFxuXFx0XFx0XFx0XFx0aWYgKCF2YWx1ZXNbaW5kZXhdICYmIGRpc3BsYXkgPT09IFxcXCJub25lXFxcIikge1xcblxcdFxcdFxcdFxcdFxcdGVsZW0uc3R5bGUuZGlzcGxheSA9IFxcXCJcXFwiO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBTZXQgZWxlbWVudHMgd2hpY2ggaGF2ZSBiZWVuIG92ZXJyaWRkZW4gd2l0aCBkaXNwbGF5OiBub25lXFxuXFx0XFx0XFx0XFx0Ly8gaW4gYSBzdHlsZXNoZWV0IHRvIHdoYXRldmVyIHRoZSBkZWZhdWx0IGJyb3dzZXIgc3R5bGUgaXNcXG5cXHRcXHRcXHRcXHQvLyBmb3Igc3VjaCBhbiBlbGVtZW50XFxuXFx0XFx0XFx0XFx0aWYgKGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXFxcIlxcXCIgJiYgaXNIaWRkZW4oZWxlbSkpIHtcXG5cXHRcXHRcXHRcXHRcXHR2YWx1ZXNbaW5kZXhdID0gZGF0YV9wcml2LmFjY2VzcyhlbGVtLCBcXFwib2xkZGlzcGxheVxcXCIsIGRlZmF1bHREaXNwbGF5KGVsZW0ubm9kZU5hbWUpKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRoaWRkZW4gPSBpc0hpZGRlbihlbGVtKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoZGlzcGxheSAhPT0gXFxcIm5vbmVcXFwiIHx8ICFoaWRkZW4pIHtcXG5cXHRcXHRcXHRcXHRcXHRkYXRhX3ByaXYuc2V0KGVsZW0sIFxcXCJvbGRkaXNwbGF5XFxcIiwgaGlkZGVuID8gZGlzcGxheSA6IGpRdWVyeS5jc3MoZWxlbSwgXFxcImRpc3BsYXlcXFwiKSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gU2V0IHRoZSBkaXNwbGF5IG9mIG1vc3Qgb2YgdGhlIGVsZW1lbnRzIGluIGEgc2Vjb25kIGxvb3BcXG5cXHRcXHQvLyB0byBhdm9pZCB0aGUgY29uc3RhbnQgcmVmbG93XFxuXFx0XFx0Zm9yIChpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XFxuXFx0XFx0XFx0ZWxlbSA9IGVsZW1lbnRzW2luZGV4XTtcXG5cXHRcXHRcXHRpZiAoIWVsZW0uc3R5bGUpIHtcXG5cXHRcXHRcXHRcXHRjb250aW51ZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKCFzaG93IHx8IGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXFxcIm5vbmVcXFwiIHx8IGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXFxcIlxcXCIpIHtcXG5cXHRcXHRcXHRcXHRlbGVtLnN0eWxlLmRpc3BsYXkgPSBzaG93ID8gdmFsdWVzW2luZGV4XSB8fCBcXFwiXFxcIiA6IFxcXCJub25lXFxcIjtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiBlbGVtZW50cztcXG5cXHR9XFxuXFxuXFx0alF1ZXJ5LmV4dGVuZCh7XFxuXFxuXFx0XFx0Ly8gQWRkIGluIHN0eWxlIHByb3BlcnR5IGhvb2tzIGZvciBvdmVycmlkaW5nIHRoZSBkZWZhdWx0XFxuXFx0XFx0Ly8gYmVoYXZpb3Igb2YgZ2V0dGluZyBhbmQgc2V0dGluZyBhIHN0eWxlIHByb3BlcnR5XFxuXFx0XFx0Y3NzSG9va3M6IHtcXG5cXHRcXHRcXHRvcGFjaXR5OiB7XFxuXFx0XFx0XFx0XFx0Z2V0OiBmdW5jdGlvbiBnZXQoZWxlbSwgY29tcHV0ZWQpIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoY29tcHV0ZWQpIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBXZSBzaG91bGQgYWx3YXlzIGdldCBhIG51bWJlciBiYWNrIGZyb20gb3BhY2l0eVxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciByZXQgPSBjdXJDU1MoZWxlbSwgXFxcIm9wYWNpdHlcXFwiKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gcmV0ID09PSBcXFwiXFxcIiA/IFxcXCIxXFxcIiA6IHJldDtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcblxcdFxcdC8vIERvbid0IGF1dG9tYXRpY2FsbHkgYWRkIFxcXCJweFxcXCIgdG8gdGhlc2UgcG9zc2libHktdW5pdGxlc3MgcHJvcGVydGllc1xcblxcdFxcdGNzc051bWJlcjoge1xcblxcdFxcdFxcdFxcXCJjb2x1bW5Db3VudFxcXCI6IHRydWUsXFxuXFx0XFx0XFx0XFxcImZpbGxPcGFjaXR5XFxcIjogdHJ1ZSxcXG5cXHRcXHRcXHRcXFwiZmxleEdyb3dcXFwiOiB0cnVlLFxcblxcdFxcdFxcdFxcXCJmbGV4U2hyaW5rXFxcIjogdHJ1ZSxcXG5cXHRcXHRcXHRcXFwiZm9udFdlaWdodFxcXCI6IHRydWUsXFxuXFx0XFx0XFx0XFxcImxpbmVIZWlnaHRcXFwiOiB0cnVlLFxcblxcdFxcdFxcdFxcXCJvcGFjaXR5XFxcIjogdHJ1ZSxcXG5cXHRcXHRcXHRcXFwib3JkZXJcXFwiOiB0cnVlLFxcblxcdFxcdFxcdFxcXCJvcnBoYW5zXFxcIjogdHJ1ZSxcXG5cXHRcXHRcXHRcXFwid2lkb3dzXFxcIjogdHJ1ZSxcXG5cXHRcXHRcXHRcXFwiekluZGV4XFxcIjogdHJ1ZSxcXG5cXHRcXHRcXHRcXFwiem9vbVxcXCI6IHRydWVcXG5cXHRcXHR9LFxcblxcblxcdFxcdC8vIEFkZCBpbiBwcm9wZXJ0aWVzIHdob3NlIG5hbWVzIHlvdSB3aXNoIHRvIGZpeCBiZWZvcmVcXG5cXHRcXHQvLyBzZXR0aW5nIG9yIGdldHRpbmcgdGhlIHZhbHVlXFxuXFx0XFx0Y3NzUHJvcHM6IHtcXG5cXHRcXHRcXHRcXFwiZmxvYXRcXFwiOiBcXFwiY3NzRmxvYXRcXFwiXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyBHZXQgYW5kIHNldCB0aGUgc3R5bGUgcHJvcGVydHkgb24gYSBET00gTm9kZVxcblxcdFxcdHN0eWxlOiBmdW5jdGlvbiBzdHlsZShlbGVtLCBuYW1lLCB2YWx1ZSwgZXh0cmEpIHtcXG5cXG5cXHRcXHRcXHQvLyBEb24ndCBzZXQgc3R5bGVzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcXG5cXHRcXHRcXHRpZiAoIWVsZW0gfHwgZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4IHx8ICFlbGVtLnN0eWxlKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWVcXG5cXHRcXHRcXHR2YXIgcmV0LFxcblxcdFxcdFxcdCAgICB0eXBlLFxcblxcdFxcdFxcdCAgICBob29rcyxcXG5cXHRcXHRcXHQgICAgb3JpZ05hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKG5hbWUpLFxcblxcdFxcdFxcdCAgICBzdHlsZSA9IGVsZW0uc3R5bGU7XFxuXFxuXFx0XFx0XFx0bmFtZSA9IGpRdWVyeS5jc3NQcm9wc1tvcmlnTmFtZV0gfHwgKGpRdWVyeS5jc3NQcm9wc1tvcmlnTmFtZV0gPSB2ZW5kb3JQcm9wTmFtZShzdHlsZSwgb3JpZ05hbWUpKTtcXG5cXG5cXHRcXHRcXHQvLyBHZXRzIGhvb2sgZm9yIHRoZSBwcmVmaXhlZCB2ZXJzaW9uLCB0aGVuIHVucHJlZml4ZWQgdmVyc2lvblxcblxcdFxcdFxcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzW25hbWVdIHx8IGpRdWVyeS5jc3NIb29rc1tvcmlnTmFtZV07XFxuXFxuXFx0XFx0XFx0Ly8gQ2hlY2sgaWYgd2UncmUgc2V0dGluZyBhIHZhbHVlXFxuXFx0XFx0XFx0aWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcXG5cXHRcXHRcXHRcXHR0eXBlID0gdHlwZW9mIHZhbHVlID09PSBcXFwidW5kZWZpbmVkXFxcIiA/IFxcXCJ1bmRlZmluZWRcXFwiIDogX3R5cGVvZih2YWx1ZSk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQ29udmVydCBcXFwiKz1cXFwiIG9yIFxcXCItPVxcXCIgdG8gcmVsYXRpdmUgbnVtYmVycyAoIzczNDUpXFxuXFx0XFx0XFx0XFx0aWYgKHR5cGUgPT09IFxcXCJzdHJpbmdcXFwiICYmIChyZXQgPSBycmVsTnVtLmV4ZWModmFsdWUpKSkge1xcblxcdFxcdFxcdFxcdFxcdHZhbHVlID0gKHJldFsxXSArIDEpICogcmV0WzJdICsgcGFyc2VGbG9hdChqUXVlcnkuY3NzKGVsZW0sIG5hbWUpKTtcXG5cXHRcXHRcXHRcXHRcXHQvLyBGaXhlcyBidWcgIzkyMzdcXG5cXHRcXHRcXHRcXHRcXHR0eXBlID0gXFxcIm51bWJlclxcXCI7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIE1ha2Ugc3VyZSB0aGF0IG51bGwgYW5kIE5hTiB2YWx1ZXMgYXJlbid0IHNldCAoIzcxMTYpXFxuXFx0XFx0XFx0XFx0aWYgKHZhbHVlID09IG51bGwgfHwgdmFsdWUgIT09IHZhbHVlKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBJZiBhIG51bWJlciwgYWRkICdweCcgdG8gdGhlIChleGNlcHQgZm9yIGNlcnRhaW4gQ1NTIHByb3BlcnRpZXMpXFxuXFx0XFx0XFx0XFx0aWYgKHR5cGUgPT09IFxcXCJudW1iZXJcXFwiICYmICFqUXVlcnkuY3NzTnVtYmVyW29yaWdOYW1lXSkge1xcblxcdFxcdFxcdFxcdFxcdHZhbHVlICs9IFxcXCJweFxcXCI7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IElFOS0xMStcXG5cXHRcXHRcXHRcXHQvLyBiYWNrZ3JvdW5kLSogcHJvcHMgYWZmZWN0IG9yaWdpbmFsIGNsb25lJ3MgdmFsdWVzXFxuXFx0XFx0XFx0XFx0aWYgKCFzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSAmJiB2YWx1ZSA9PT0gXFxcIlxcXCIgJiYgbmFtZS5pbmRleE9mKFxcXCJiYWNrZ3JvdW5kXFxcIikgPT09IDApIHtcXG5cXHRcXHRcXHRcXHRcXHRzdHlsZVtuYW1lXSA9IFxcXCJpbmhlcml0XFxcIjtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCwgdXNlIHRoYXQgdmFsdWUsIG90aGVyd2lzZSBqdXN0IHNldCB0aGUgc3BlY2lmaWVkIHZhbHVlXFxuXFx0XFx0XFx0XFx0aWYgKCFob29rcyB8fCAhKFxcXCJzZXRcXFwiIGluIGhvb2tzKSB8fCAodmFsdWUgPSBob29rcy5zZXQoZWxlbSwgdmFsdWUsIGV4dHJhKSkgIT09IHVuZGVmaW5lZCkge1xcblxcdFxcdFxcdFxcdFxcdHN0eWxlW25hbWVdID0gdmFsdWU7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIG5vbi1jb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXFxuXFx0XFx0XFx0XFx0aWYgKGhvb2tzICYmIFxcXCJnZXRcXFwiIGluIGhvb2tzICYmIChyZXQgPSBob29rcy5nZXQoZWxlbSwgZmFsc2UsIGV4dHJhKSkgIT09IHVuZGVmaW5lZCkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiByZXQ7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIE90aGVyd2lzZSBqdXN0IGdldCB0aGUgdmFsdWUgZnJvbSB0aGUgc3R5bGUgb2JqZWN0XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHN0eWxlW25hbWVdO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNzczogZnVuY3Rpb24gY3NzKGVsZW0sIG5hbWUsIGV4dHJhLCBzdHlsZXMpIHtcXG5cXHRcXHRcXHR2YXIgdmFsLFxcblxcdFxcdFxcdCAgICBudW0sXFxuXFx0XFx0XFx0ICAgIGhvb2tzLFxcblxcdFxcdFxcdCAgICBvcmlnTmFtZSA9IGpRdWVyeS5jYW1lbENhc2UobmFtZSk7XFxuXFxuXFx0XFx0XFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lXFxuXFx0XFx0XFx0bmFtZSA9IGpRdWVyeS5jc3NQcm9wc1tvcmlnTmFtZV0gfHwgKGpRdWVyeS5jc3NQcm9wc1tvcmlnTmFtZV0gPSB2ZW5kb3JQcm9wTmFtZShlbGVtLnN0eWxlLCBvcmlnTmFtZSkpO1xcblxcblxcdFxcdFxcdC8vIFRyeSBwcmVmaXhlZCBuYW1lIGZvbGxvd2VkIGJ5IHRoZSB1bnByZWZpeGVkIG5hbWVcXG5cXHRcXHRcXHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1tuYW1lXSB8fCBqUXVlcnkuY3NzSG9va3Nbb3JpZ05hbWVdO1xcblxcblxcdFxcdFxcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXFxuXFx0XFx0XFx0aWYgKGhvb2tzICYmIFxcXCJnZXRcXFwiIGluIGhvb2tzKSB7XFxuXFx0XFx0XFx0XFx0dmFsID0gaG9va3MuZ2V0KGVsZW0sIHRydWUsIGV4dHJhKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gT3RoZXJ3aXNlLCBpZiBhIHdheSB0byBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGV4aXN0cywgdXNlIHRoYXRcXG5cXHRcXHRcXHRpZiAodmFsID09PSB1bmRlZmluZWQpIHtcXG5cXHRcXHRcXHRcXHR2YWwgPSBjdXJDU1MoZWxlbSwgbmFtZSwgc3R5bGVzKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gQ29udmVydCBcXFwibm9ybWFsXFxcIiB0byBjb21wdXRlZCB2YWx1ZVxcblxcdFxcdFxcdGlmICh2YWwgPT09IFxcXCJub3JtYWxcXFwiICYmIG5hbWUgaW4gY3NzTm9ybWFsVHJhbnNmb3JtKSB7XFxuXFx0XFx0XFx0XFx0dmFsID0gY3NzTm9ybWFsVHJhbnNmb3JtW25hbWVdO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBNYWtlIG51bWVyaWMgaWYgZm9yY2VkIG9yIGEgcXVhbGlmaWVyIHdhcyBwcm92aWRlZCBhbmQgdmFsIGxvb2tzIG51bWVyaWNcXG5cXHRcXHRcXHRpZiAoZXh0cmEgPT09IFxcXCJcXFwiIHx8IGV4dHJhKSB7XFxuXFx0XFx0XFx0XFx0bnVtID0gcGFyc2VGbG9hdCh2YWwpO1xcblxcdFxcdFxcdFxcdHJldHVybiBleHRyYSA9PT0gdHJ1ZSB8fCBqUXVlcnkuaXNOdW1lcmljKG51bSkgPyBudW0gfHwgMCA6IHZhbDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIHZhbDtcXG5cXHRcXHR9XFxuXFx0fSk7XFxuXFxuXFx0alF1ZXJ5LmVhY2goW1xcXCJoZWlnaHRcXFwiLCBcXFwid2lkdGhcXFwiXSwgZnVuY3Rpb24gKGksIG5hbWUpIHtcXG5cXHRcXHRqUXVlcnkuY3NzSG9va3NbbmFtZV0gPSB7XFxuXFx0XFx0XFx0Z2V0OiBmdW5jdGlvbiBnZXQoZWxlbSwgY29tcHV0ZWQsIGV4dHJhKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGNvbXB1dGVkKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gQ2VydGFpbiBlbGVtZW50cyBjYW4gaGF2ZSBkaW1lbnNpb24gaW5mbyBpZiB3ZSBpbnZpc2libHkgc2hvdyB0aGVtXFxuXFx0XFx0XFx0XFx0XFx0Ly8gYnV0IGl0IG11c3QgaGF2ZSBhIGN1cnJlbnQgZGlzcGxheSBzdHlsZSB0aGF0IHdvdWxkIGJlbmVmaXRcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gcmRpc3BsYXlzd2FwLnRlc3QoalF1ZXJ5LmNzcyhlbGVtLCBcXFwiZGlzcGxheVxcXCIpKSAmJiBlbGVtLm9mZnNldFdpZHRoID09PSAwID8galF1ZXJ5LnN3YXAoZWxlbSwgY3NzU2hvdywgZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBnZXRXaWR0aE9ySGVpZ2h0KGVsZW0sIG5hbWUsIGV4dHJhKTtcXG5cXHRcXHRcXHRcXHRcXHR9KSA6IGdldFdpZHRoT3JIZWlnaHQoZWxlbSwgbmFtZSwgZXh0cmEpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdHNldDogZnVuY3Rpb24gc2V0KGVsZW0sIHZhbHVlLCBleHRyYSkge1xcblxcdFxcdFxcdFxcdHZhciBzdHlsZXMgPSBleHRyYSAmJiBnZXRTdHlsZXMoZWxlbSk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHNldFBvc2l0aXZlTnVtYmVyKGVsZW0sIHZhbHVlLCBleHRyYSA/IGF1Z21lbnRXaWR0aE9ySGVpZ2h0KGVsZW0sIG5hbWUsIGV4dHJhLCBqUXVlcnkuY3NzKGVsZW0sIFxcXCJib3hTaXppbmdcXFwiLCBmYWxzZSwgc3R5bGVzKSA9PT0gXFxcImJvcmRlci1ib3hcXFwiLCBzdHlsZXMpIDogMCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH07XFxuXFx0fSk7XFxuXFxuXFx0Ly8gU3VwcG9ydDogQW5kcm9pZCAyLjNcXG5cXHRqUXVlcnkuY3NzSG9va3MubWFyZ2luUmlnaHQgPSBhZGRHZXRIb29rSWYoc3VwcG9ydC5yZWxpYWJsZU1hcmdpblJpZ2h0LCBmdW5jdGlvbiAoZWxlbSwgY29tcHV0ZWQpIHtcXG5cXHRcXHRpZiAoY29tcHV0ZWQpIHtcXG5cXHRcXHRcXHRyZXR1cm4galF1ZXJ5LnN3YXAoZWxlbSwgeyBcXFwiZGlzcGxheVxcXCI6IFxcXCJpbmxpbmUtYmxvY2tcXFwiIH0sIGN1ckNTUywgW2VsZW0sIFxcXCJtYXJnaW5SaWdodFxcXCJdKTtcXG5cXHRcXHR9XFxuXFx0fSk7XFxuXFxuXFx0Ly8gVGhlc2UgaG9va3MgYXJlIHVzZWQgYnkgYW5pbWF0ZSB0byBleHBhbmQgcHJvcGVydGllc1xcblxcdGpRdWVyeS5lYWNoKHtcXG5cXHRcXHRtYXJnaW46IFxcXCJcXFwiLFxcblxcdFxcdHBhZGRpbmc6IFxcXCJcXFwiLFxcblxcdFxcdGJvcmRlcjogXFxcIldpZHRoXFxcIlxcblxcdH0sIGZ1bmN0aW9uIChwcmVmaXgsIHN1ZmZpeCkge1xcblxcdFxcdGpRdWVyeS5jc3NIb29rc1twcmVmaXggKyBzdWZmaXhdID0ge1xcblxcdFxcdFxcdGV4cGFuZDogZnVuY3Rpb24gZXhwYW5kKHZhbHVlKSB7XFxuXFx0XFx0XFx0XFx0dmFyIGkgPSAwLFxcblxcdFxcdFxcdFxcdCAgICBleHBhbmRlZCA9IHt9LFxcblxcblxcblxcdFxcdFxcdFxcdC8vIEFzc3VtZXMgYSBzaW5nbGUgbnVtYmVyIGlmIG5vdCBhIHN0cmluZ1xcblxcdFxcdFxcdFxcdHBhcnRzID0gdHlwZW9mIHZhbHVlID09PSBcXFwic3RyaW5nXFxcIiA/IHZhbHVlLnNwbGl0KFxcXCIgXFxcIikgOiBbdmFsdWVdO1xcblxcblxcdFxcdFxcdFxcdGZvciAoOyBpIDwgNDsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZXhwYW5kZWRbcHJlZml4ICsgY3NzRXhwYW5kW2ldICsgc3VmZml4XSA9IHBhcnRzW2ldIHx8IHBhcnRzW2kgLSAyXSB8fCBwYXJ0c1swXTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIGV4cGFuZGVkO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9O1xcblxcblxcdFxcdGlmICghcm1hcmdpbi50ZXN0KHByZWZpeCkpIHtcXG5cXHRcXHRcXHRqUXVlcnkuY3NzSG9va3NbcHJlZml4ICsgc3VmZml4XS5zZXQgPSBzZXRQb3NpdGl2ZU51bWJlcjtcXG5cXHRcXHR9XFxuXFx0fSk7XFxuXFxuXFx0alF1ZXJ5LmZuLmV4dGVuZCh7XFxuXFx0XFx0Y3NzOiBmdW5jdGlvbiBjc3MobmFtZSwgdmFsdWUpIHtcXG5cXHRcXHRcXHRyZXR1cm4gYWNjZXNzKHRoaXMsIGZ1bmN0aW9uIChlbGVtLCBuYW1lLCB2YWx1ZSkge1xcblxcdFxcdFxcdFxcdHZhciBzdHlsZXMsXFxuXFx0XFx0XFx0XFx0ICAgIGxlbixcXG5cXHRcXHRcXHRcXHQgICAgbWFwID0ge30sXFxuXFx0XFx0XFx0XFx0ICAgIGkgPSAwO1xcblxcblxcdFxcdFxcdFxcdGlmIChqUXVlcnkuaXNBcnJheShuYW1lKSkge1xcblxcdFxcdFxcdFxcdFxcdHN0eWxlcyA9IGdldFN0eWxlcyhlbGVtKTtcXG5cXHRcXHRcXHRcXHRcXHRsZW4gPSBuYW1lLmxlbmd0aDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0bWFwW25hbWVbaV1dID0galF1ZXJ5LmNzcyhlbGVtLCBuYW1lW2ldLCBmYWxzZSwgc3R5bGVzKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIG1hcDtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgPyBqUXVlcnkuc3R5bGUoZWxlbSwgbmFtZSwgdmFsdWUpIDogalF1ZXJ5LmNzcyhlbGVtLCBuYW1lKTtcXG5cXHRcXHRcXHR9LCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEpO1xcblxcdFxcdH0sXFxuXFx0XFx0c2hvdzogZnVuY3Rpb24gc2hvdygpIHtcXG5cXHRcXHRcXHRyZXR1cm4gc2hvd0hpZGUodGhpcywgdHJ1ZSk7XFxuXFx0XFx0fSxcXG5cXHRcXHRoaWRlOiBmdW5jdGlvbiBoaWRlKCkge1xcblxcdFxcdFxcdHJldHVybiBzaG93SGlkZSh0aGlzKTtcXG5cXHRcXHR9LFxcblxcdFxcdHRvZ2dsZTogZnVuY3Rpb24gdG9nZ2xlKHN0YXRlKSB7XFxuXFx0XFx0XFx0aWYgKHR5cGVvZiBzdGF0ZSA9PT0gXFxcImJvb2xlYW5cXFwiKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHN0YXRlID8gdGhpcy5zaG93KCkgOiB0aGlzLmhpZGUoKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGlzSGlkZGVuKHRoaXMpKSB7XFxuXFx0XFx0XFx0XFx0XFx0alF1ZXJ5KHRoaXMpLnNob3coKTtcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdGpRdWVyeSh0aGlzKS5oaWRlKCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0pO1xcblxcdFxcdH1cXG5cXHR9KTtcXG5cXG5cXHRmdW5jdGlvbiBUd2VlbihlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZykge1xcblxcdFxcdHJldHVybiBuZXcgVHdlZW4ucHJvdG90eXBlLmluaXQoZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcpO1xcblxcdH1cXG5cXHRqUXVlcnkuVHdlZW4gPSBUd2VlbjtcXG5cXG5cXHRUd2Vlbi5wcm90b3R5cGUgPSB7XFxuXFx0XFx0Y29uc3RydWN0b3I6IFR3ZWVuLFxcblxcdFxcdGluaXQ6IGZ1bmN0aW9uIGluaXQoZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcsIHVuaXQpIHtcXG5cXHRcXHRcXHR0aGlzLmVsZW0gPSBlbGVtO1xcblxcdFxcdFxcdHRoaXMucHJvcCA9IHByb3A7XFxuXFx0XFx0XFx0dGhpcy5lYXNpbmcgPSBlYXNpbmcgfHwgXFxcInN3aW5nXFxcIjtcXG5cXHRcXHRcXHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xcblxcdFxcdFxcdHRoaXMuc3RhcnQgPSB0aGlzLm5vdyA9IHRoaXMuY3VyKCk7XFxuXFx0XFx0XFx0dGhpcy5lbmQgPSBlbmQ7XFxuXFx0XFx0XFx0dGhpcy51bml0ID0gdW5pdCB8fCAoalF1ZXJ5LmNzc051bWJlcltwcm9wXSA/IFxcXCJcXFwiIDogXFxcInB4XFxcIik7XFxuXFx0XFx0fSxcXG5cXHRcXHRjdXI6IGZ1bmN0aW9uIGN1cigpIHtcXG5cXHRcXHRcXHR2YXIgaG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbdGhpcy5wcm9wXTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gaG9va3MgJiYgaG9va3MuZ2V0ID8gaG9va3MuZ2V0KHRoaXMpIDogVHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LmdldCh0aGlzKTtcXG5cXHRcXHR9LFxcblxcdFxcdHJ1bjogZnVuY3Rpb24gcnVuKHBlcmNlbnQpIHtcXG5cXHRcXHRcXHR2YXIgZWFzZWQsXFxuXFx0XFx0XFx0ICAgIGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzW3RoaXMucHJvcF07XFxuXFxuXFx0XFx0XFx0aWYgKHRoaXMub3B0aW9ucy5kdXJhdGlvbikge1xcblxcdFxcdFxcdFxcdHRoaXMucG9zID0gZWFzZWQgPSBqUXVlcnkuZWFzaW5nW3RoaXMuZWFzaW5nXShwZXJjZW50LCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKiBwZXJjZW50LCAwLCAxLCB0aGlzLm9wdGlvbnMuZHVyYXRpb24pO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5wb3MgPSBlYXNlZCA9IHBlcmNlbnQ7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHRoaXMubm93ID0gKHRoaXMuZW5kIC0gdGhpcy5zdGFydCkgKiBlYXNlZCArIHRoaXMuc3RhcnQ7XFxuXFxuXFx0XFx0XFx0aWYgKHRoaXMub3B0aW9ucy5zdGVwKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5vcHRpb25zLnN0ZXAuY2FsbCh0aGlzLmVsZW0sIHRoaXMubm93LCB0aGlzKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKGhvb2tzICYmIGhvb2tzLnNldCkge1xcblxcdFxcdFxcdFxcdGhvb2tzLnNldCh0aGlzKTtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5zZXQodGhpcyk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcdFxcdH1cXG5cXHR9O1xcblxcblxcdFR3ZWVuLnByb3RvdHlwZS5pbml0LnByb3RvdHlwZSA9IFR3ZWVuLnByb3RvdHlwZTtcXG5cXG5cXHRUd2Vlbi5wcm9wSG9va3MgPSB7XFxuXFx0XFx0X2RlZmF1bHQ6IHtcXG5cXHRcXHRcXHRnZXQ6IGZ1bmN0aW9uIGdldCh0d2Vlbikge1xcblxcdFxcdFxcdFxcdHZhciByZXN1bHQ7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKHR3ZWVuLmVsZW1bdHdlZW4ucHJvcF0gIT0gbnVsbCAmJiAoIXR3ZWVuLmVsZW0uc3R5bGUgfHwgdHdlZW4uZWxlbS5zdHlsZVt0d2Vlbi5wcm9wXSA9PSBudWxsKSkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiB0d2Vlbi5lbGVtW3R3ZWVuLnByb3BdO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBQYXNzaW5nIGFuIGVtcHR5IHN0cmluZyBhcyBhIDNyZCBwYXJhbWV0ZXIgdG8gLmNzcyB3aWxsIGF1dG9tYXRpY2FsbHlcXG5cXHRcXHRcXHRcXHQvLyBhdHRlbXB0IGEgcGFyc2VGbG9hdCBhbmQgZmFsbGJhY2sgdG8gYSBzdHJpbmcgaWYgdGhlIHBhcnNlIGZhaWxzLlxcblxcdFxcdFxcdFxcdC8vIFNpbXBsZSB2YWx1ZXMgc3VjaCBhcyBcXFwiMTBweFxcXCIgYXJlIHBhcnNlZCB0byBGbG9hdDtcXG5cXHRcXHRcXHRcXHQvLyBjb21wbGV4IHZhbHVlcyBzdWNoIGFzIFxcXCJyb3RhdGUoMXJhZClcXFwiIGFyZSByZXR1cm5lZCBhcy1pcy5cXG5cXHRcXHRcXHRcXHRyZXN1bHQgPSBqUXVlcnkuY3NzKHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIFxcXCJcXFwiKTtcXG5cXHRcXHRcXHRcXHQvLyBFbXB0eSBzdHJpbmdzLCBudWxsLCB1bmRlZmluZWQgYW5kIFxcXCJhdXRvXFxcIiBhcmUgY29udmVydGVkIHRvIDAuXFxuXFx0XFx0XFx0XFx0cmV0dXJuICFyZXN1bHQgfHwgcmVzdWx0ID09PSBcXFwiYXV0b1xcXCIgPyAwIDogcmVzdWx0O1xcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0c2V0OiBmdW5jdGlvbiBzZXQodHdlZW4pIHtcXG5cXHRcXHRcXHRcXHQvLyBVc2Ugc3RlcCBob29rIGZvciBiYWNrIGNvbXBhdC5cXG5cXHRcXHRcXHRcXHQvLyBVc2UgY3NzSG9vayBpZiBpdHMgdGhlcmUuXFxuXFx0XFx0XFx0XFx0Ly8gVXNlIC5zdHlsZSBpZiBhdmFpbGFibGUgYW5kIHVzZSBwbGFpbiBwcm9wZXJ0aWVzIHdoZXJlIGF2YWlsYWJsZS5cXG5cXHRcXHRcXHRcXHRpZiAoalF1ZXJ5LmZ4LnN0ZXBbdHdlZW4ucHJvcF0pIHtcXG5cXHRcXHRcXHRcXHRcXHRqUXVlcnkuZnguc3RlcFt0d2Vlbi5wcm9wXSh0d2Vlbik7XFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmICh0d2Vlbi5lbGVtLnN0eWxlICYmICh0d2Vlbi5lbGVtLnN0eWxlW2pRdWVyeS5jc3NQcm9wc1t0d2Vlbi5wcm9wXV0gIT0gbnVsbCB8fCBqUXVlcnkuY3NzSG9va3NbdHdlZW4ucHJvcF0pKSB7XFxuXFx0XFx0XFx0XFx0XFx0alF1ZXJ5LnN0eWxlKHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIHR3ZWVuLm5vdyArIHR3ZWVuLnVuaXQpO1xcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0dHdlZW4uZWxlbVt0d2Vlbi5wcm9wXSA9IHR3ZWVuLm5vdztcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9O1xcblxcblxcdC8vIFN1cHBvcnQ6IElFOVxcblxcdC8vIFBhbmljIGJhc2VkIGFwcHJvYWNoIHRvIHNldHRpbmcgdGhpbmdzIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xcblxcdFR3ZWVuLnByb3BIb29rcy5zY3JvbGxUb3AgPSBUd2Vlbi5wcm9wSG9va3Muc2Nyb2xsTGVmdCA9IHtcXG5cXHRcXHRzZXQ6IGZ1bmN0aW9uIHNldCh0d2Vlbikge1xcblxcdFxcdFxcdGlmICh0d2Vlbi5lbGVtLm5vZGVUeXBlICYmIHR3ZWVuLmVsZW0ucGFyZW50Tm9kZSkge1xcblxcdFxcdFxcdFxcdHR3ZWVuLmVsZW1bdHdlZW4ucHJvcF0gPSB0d2Vlbi5ub3c7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9O1xcblxcblxcdGpRdWVyeS5lYXNpbmcgPSB7XFxuXFx0XFx0bGluZWFyOiBmdW5jdGlvbiBsaW5lYXIocCkge1xcblxcdFxcdFxcdHJldHVybiBwO1xcblxcdFxcdH0sXFxuXFx0XFx0c3dpbmc6IGZ1bmN0aW9uIHN3aW5nKHApIHtcXG5cXHRcXHRcXHRyZXR1cm4gMC41IC0gTWF0aC5jb3MocCAqIE1hdGguUEkpIC8gMjtcXG5cXHRcXHR9XFxuXFx0fTtcXG5cXG5cXHRqUXVlcnkuZnggPSBUd2Vlbi5wcm90b3R5cGUuaW5pdDtcXG5cXG5cXHQvLyBCYWNrIENvbXBhdCA8MS44IGV4dGVuc2lvbiBwb2ludFxcblxcdGpRdWVyeS5meC5zdGVwID0ge307XFxuXFxuXFx0dmFyIGZ4Tm93LFxcblxcdCAgICB0aW1lcklkLFxcblxcdCAgICByZnh0eXBlcyA9IC9eKD86dG9nZ2xlfHNob3d8aGlkZSkkLyxcXG5cXHQgICAgcmZ4bnVtID0gbmV3IFJlZ0V4cChcXFwiXig/OihbKy1dKT18KShcXFwiICsgcG51bSArIFxcXCIpKFthLXolXSopJFxcXCIsIFxcXCJpXFxcIiksXFxuXFx0ICAgIHJydW4gPSAvcXVldWVIb29rcyQvLFxcblxcdCAgICBhbmltYXRpb25QcmVmaWx0ZXJzID0gW2RlZmF1bHRQcmVmaWx0ZXJdLFxcblxcdCAgICB0d2VlbmVycyA9IHtcXG5cXHRcXHRcXFwiKlxcXCI6IFtmdW5jdGlvbiAocHJvcCwgdmFsdWUpIHtcXG5cXHRcXHRcXHR2YXIgdHdlZW4gPSB0aGlzLmNyZWF0ZVR3ZWVuKHByb3AsIHZhbHVlKSxcXG5cXHRcXHRcXHQgICAgdGFyZ2V0ID0gdHdlZW4uY3VyKCksXFxuXFx0XFx0XFx0ICAgIHBhcnRzID0gcmZ4bnVtLmV4ZWModmFsdWUpLFxcblxcdFxcdFxcdCAgICB1bml0ID0gcGFydHMgJiYgcGFydHNbM10gfHwgKGpRdWVyeS5jc3NOdW1iZXJbcHJvcF0gPyBcXFwiXFxcIiA6IFxcXCJweFxcXCIpLFxcblxcblxcblxcdFxcdFxcdC8vIFN0YXJ0aW5nIHZhbHVlIGNvbXB1dGF0aW9uIGlzIHJlcXVpcmVkIGZvciBwb3RlbnRpYWwgdW5pdCBtaXNtYXRjaGVzXFxuXFx0XFx0XFx0c3RhcnQgPSAoalF1ZXJ5LmNzc051bWJlcltwcm9wXSB8fCB1bml0ICE9PSBcXFwicHhcXFwiICYmICt0YXJnZXQpICYmIHJmeG51bS5leGVjKGpRdWVyeS5jc3ModHdlZW4uZWxlbSwgcHJvcCkpLFxcblxcdFxcdFxcdCAgICBzY2FsZSA9IDEsXFxuXFx0XFx0XFx0ICAgIG1heEl0ZXJhdGlvbnMgPSAyMDtcXG5cXG5cXHRcXHRcXHRpZiAoc3RhcnQgJiYgc3RhcnRbM10gIT09IHVuaXQpIHtcXG5cXHRcXHRcXHRcXHQvLyBUcnVzdCB1bml0cyByZXBvcnRlZCBieSBqUXVlcnkuY3NzXFxuXFx0XFx0XFx0XFx0dW5pdCA9IHVuaXQgfHwgc3RhcnRbM107XFxuXFxuXFx0XFx0XFx0XFx0Ly8gTWFrZSBzdXJlIHdlIHVwZGF0ZSB0aGUgdHdlZW4gcHJvcGVydGllcyBsYXRlciBvblxcblxcdFxcdFxcdFxcdHBhcnRzID0gcGFydHMgfHwgW107XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSXRlcmF0aXZlbHkgYXBwcm94aW1hdGUgZnJvbSBhIG5vbnplcm8gc3RhcnRpbmcgcG9pbnRcXG5cXHRcXHRcXHRcXHRzdGFydCA9ICt0YXJnZXQgfHwgMTtcXG5cXG5cXHRcXHRcXHRcXHRkbyB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gSWYgcHJldmlvdXMgaXRlcmF0aW9uIHplcm9lZCBvdXQsIGRvdWJsZSB1bnRpbCB3ZSBnZXQgKnNvbWV0aGluZyouXFxuXFx0XFx0XFx0XFx0XFx0Ly8gVXNlIHN0cmluZyBmb3IgZG91Ymxpbmcgc28gd2UgZG9uJ3QgYWNjaWRlbnRhbGx5IHNlZSBzY2FsZSBhcyB1bmNoYW5nZWQgYmVsb3dcXG5cXHRcXHRcXHRcXHRcXHRzY2FsZSA9IHNjYWxlIHx8IFxcXCIuNVxcXCI7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gQWRqdXN0IGFuZCBhcHBseVxcblxcdFxcdFxcdFxcdFxcdHN0YXJ0ID0gc3RhcnQgLyBzY2FsZTtcXG5cXHRcXHRcXHRcXHRcXHRqUXVlcnkuc3R5bGUodHdlZW4uZWxlbSwgcHJvcCwgc3RhcnQgKyB1bml0KTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBVcGRhdGUgc2NhbGUsIHRvbGVyYXRpbmcgemVybyBvciBOYU4gZnJvbSB0d2Vlbi5jdXIoKSxcXG5cXHRcXHRcXHRcXHRcXHQvLyBicmVhayB0aGUgbG9vcCBpZiBzY2FsZSBpcyB1bmNoYW5nZWQgb3IgcGVyZmVjdCwgb3IgaWYgd2UndmUganVzdCBoYWQgZW5vdWdoXFxuXFx0XFx0XFx0XFx0fSB3aGlsZSAoc2NhbGUgIT09IChzY2FsZSA9IHR3ZWVuLmN1cigpIC8gdGFyZ2V0KSAmJiBzY2FsZSAhPT0gMSAmJiAtLW1heEl0ZXJhdGlvbnMpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBVcGRhdGUgdHdlZW4gcHJvcGVydGllc1xcblxcdFxcdFxcdGlmIChwYXJ0cykge1xcblxcdFxcdFxcdFxcdHN0YXJ0ID0gdHdlZW4uc3RhcnQgPSArc3RhcnQgfHwgK3RhcmdldCB8fCAwO1xcblxcdFxcdFxcdFxcdHR3ZWVuLnVuaXQgPSB1bml0O1xcblxcdFxcdFxcdFxcdC8vIElmIGEgKz0vLT0gdG9rZW4gd2FzIHByb3ZpZGVkLCB3ZSdyZSBkb2luZyBhIHJlbGF0aXZlIGFuaW1hdGlvblxcblxcdFxcdFxcdFxcdHR3ZWVuLmVuZCA9IHBhcnRzWzFdID8gc3RhcnQgKyAocGFydHNbMV0gKyAxKSAqIHBhcnRzWzJdIDogK3BhcnRzWzJdO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gdHdlZW47XFxuXFx0XFx0fV1cXG5cXHR9O1xcblxcblxcdC8vIEFuaW1hdGlvbnMgY3JlYXRlZCBzeW5jaHJvbm91c2x5IHdpbGwgcnVuIHN5bmNocm9ub3VzbHlcXG5cXHRmdW5jdGlvbiBjcmVhdGVGeE5vdygpIHtcXG5cXHRcXHRzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRmeE5vdyA9IHVuZGVmaW5lZDtcXG5cXHRcXHR9KTtcXG5cXHRcXHRyZXR1cm4gZnhOb3cgPSBqUXVlcnkubm93KCk7XFxuXFx0fVxcblxcblxcdC8vIEdlbmVyYXRlIHBhcmFtZXRlcnMgdG8gY3JlYXRlIGEgc3RhbmRhcmQgYW5pbWF0aW9uXFxuXFx0ZnVuY3Rpb24gZ2VuRngodHlwZSwgaW5jbHVkZVdpZHRoKSB7XFxuXFx0XFx0dmFyIHdoaWNoLFxcblxcdFxcdCAgICBpID0gMCxcXG5cXHRcXHQgICAgYXR0cnMgPSB7IGhlaWdodDogdHlwZSB9O1xcblxcblxcdFxcdC8vIElmIHdlIGluY2x1ZGUgd2lkdGgsIHN0ZXAgdmFsdWUgaXMgMSB0byBkbyBhbGwgY3NzRXhwYW5kIHZhbHVlcyxcXG5cXHRcXHQvLyBvdGhlcndpc2Ugc3RlcCB2YWx1ZSBpcyAyIHRvIHNraXAgb3ZlciBMZWZ0IGFuZCBSaWdodFxcblxcdFxcdGluY2x1ZGVXaWR0aCA9IGluY2x1ZGVXaWR0aCA/IDEgOiAwO1xcblxcdFxcdGZvciAoOyBpIDwgNDsgaSArPSAyIC0gaW5jbHVkZVdpZHRoKSB7XFxuXFx0XFx0XFx0d2hpY2ggPSBjc3NFeHBhbmRbaV07XFxuXFx0XFx0XFx0YXR0cnNbXFxcIm1hcmdpblxcXCIgKyB3aGljaF0gPSBhdHRyc1tcXFwicGFkZGluZ1xcXCIgKyB3aGljaF0gPSB0eXBlO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoaW5jbHVkZVdpZHRoKSB7XFxuXFx0XFx0XFx0YXR0cnMub3BhY2l0eSA9IGF0dHJzLndpZHRoID0gdHlwZTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIGF0dHJzO1xcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBjcmVhdGVUd2Vlbih2YWx1ZSwgcHJvcCwgYW5pbWF0aW9uKSB7XFxuXFx0XFx0dmFyIHR3ZWVuLFxcblxcdFxcdCAgICBjb2xsZWN0aW9uID0gKHR3ZWVuZXJzW3Byb3BdIHx8IFtdKS5jb25jYXQodHdlZW5lcnNbXFxcIipcXFwiXSksXFxuXFx0XFx0ICAgIGluZGV4ID0gMCxcXG5cXHRcXHQgICAgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XFxuXFx0XFx0Zm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XFxuXFx0XFx0XFx0aWYgKHR3ZWVuID0gY29sbGVjdGlvbltpbmRleF0uY2FsbChhbmltYXRpb24sIHByb3AsIHZhbHVlKSkge1xcblxcblxcdFxcdFxcdFxcdC8vIFdlJ3JlIGRvbmUgd2l0aCB0aGlzIHByb3BlcnR5XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHR3ZWVuO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIGRlZmF1bHRQcmVmaWx0ZXIoZWxlbSwgcHJvcHMsIG9wdHMpIHtcXG5cXHRcXHQvKiBqc2hpbnQgdmFsaWR0aGlzOiB0cnVlICovXFxuXFx0XFx0dmFyIHByb3AsXFxuXFx0XFx0ICAgIHZhbHVlLFxcblxcdFxcdCAgICB0b2dnbGUsXFxuXFx0XFx0ICAgIHR3ZWVuLFxcblxcdFxcdCAgICBob29rcyxcXG5cXHRcXHQgICAgb2xkZmlyZSxcXG5cXHRcXHQgICAgZGlzcGxheSxcXG5cXHRcXHQgICAgY2hlY2tEaXNwbGF5LFxcblxcdFxcdCAgICBhbmltID0gdGhpcyxcXG5cXHRcXHQgICAgb3JpZyA9IHt9LFxcblxcdFxcdCAgICBzdHlsZSA9IGVsZW0uc3R5bGUsXFxuXFx0XFx0ICAgIGhpZGRlbiA9IGVsZW0ubm9kZVR5cGUgJiYgaXNIaWRkZW4oZWxlbSksXFxuXFx0XFx0ICAgIGRhdGFTaG93ID0gZGF0YV9wcml2LmdldChlbGVtLCBcXFwiZnhzaG93XFxcIik7XFxuXFxuXFx0XFx0Ly8gSGFuZGxlIHF1ZXVlOiBmYWxzZSBwcm9taXNlc1xcblxcdFxcdGlmICghb3B0cy5xdWV1ZSkge1xcblxcdFxcdFxcdGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKGVsZW0sIFxcXCJmeFxcXCIpO1xcblxcdFxcdFxcdGlmIChob29rcy51bnF1ZXVlZCA9PSBudWxsKSB7XFxuXFx0XFx0XFx0XFx0aG9va3MudW5xdWV1ZWQgPSAwO1xcblxcdFxcdFxcdFxcdG9sZGZpcmUgPSBob29rcy5lbXB0eS5maXJlO1xcblxcdFxcdFxcdFxcdGhvb2tzLmVtcHR5LmZpcmUgPSBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCFob29rcy51bnF1ZXVlZCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdG9sZGZpcmUoKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aG9va3MudW5xdWV1ZWQrKztcXG5cXG5cXHRcXHRcXHRhbmltLmFsd2F5cyhmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0Ly8gRW5zdXJlIHRoZSBjb21wbGV0ZSBoYW5kbGVyIGlzIGNhbGxlZCBiZWZvcmUgdGhpcyBjb21wbGV0ZXNcXG5cXHRcXHRcXHRcXHRhbmltLmFsd2F5cyhmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0XFx0aG9va3MudW5xdWV1ZWQtLTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIWpRdWVyeS5xdWV1ZShlbGVtLCBcXFwiZnhcXFwiKS5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRob29rcy5lbXB0eS5maXJlKCk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdH0pO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBIZWlnaHQvd2lkdGggb3ZlcmZsb3cgcGFzc1xcblxcdFxcdGlmIChlbGVtLm5vZGVUeXBlID09PSAxICYmIChcXFwiaGVpZ2h0XFxcIiBpbiBwcm9wcyB8fCBcXFwid2lkdGhcXFwiIGluIHByb3BzKSkge1xcblxcdFxcdFxcdC8vIE1ha2Ugc3VyZSB0aGF0IG5vdGhpbmcgc25lYWtzIG91dFxcblxcdFxcdFxcdC8vIFJlY29yZCBhbGwgMyBvdmVyZmxvdyBhdHRyaWJ1dGVzIGJlY2F1c2UgSUU5LTEwIGRvIG5vdFxcblxcdFxcdFxcdC8vIGNoYW5nZSB0aGUgb3ZlcmZsb3cgYXR0cmlidXRlIHdoZW4gb3ZlcmZsb3dYIGFuZFxcblxcdFxcdFxcdC8vIG92ZXJmbG93WSBhcmUgc2V0IHRvIHRoZSBzYW1lIHZhbHVlXFxuXFx0XFx0XFx0b3B0cy5vdmVyZmxvdyA9IFtzdHlsZS5vdmVyZmxvdywgc3R5bGUub3ZlcmZsb3dYLCBzdHlsZS5vdmVyZmxvd1ldO1xcblxcblxcdFxcdFxcdC8vIFNldCBkaXNwbGF5IHByb3BlcnR5IHRvIGlubGluZS1ibG9jayBmb3IgaGVpZ2h0L3dpZHRoXFxuXFx0XFx0XFx0Ly8gYW5pbWF0aW9ucyBvbiBpbmxpbmUgZWxlbWVudHMgdGhhdCBhcmUgaGF2aW5nIHdpZHRoL2hlaWdodCBhbmltYXRlZFxcblxcdFxcdFxcdGRpc3BsYXkgPSBqUXVlcnkuY3NzKGVsZW0sIFxcXCJkaXNwbGF5XFxcIik7XFxuXFxuXFx0XFx0XFx0Ly8gVGVzdCBkZWZhdWx0IGRpc3BsYXkgaWYgZGlzcGxheSBpcyBjdXJyZW50bHkgXFxcIm5vbmVcXFwiXFxuXFx0XFx0XFx0Y2hlY2tEaXNwbGF5ID0gZGlzcGxheSA9PT0gXFxcIm5vbmVcXFwiID8gZGF0YV9wcml2LmdldChlbGVtLCBcXFwib2xkZGlzcGxheVxcXCIpIHx8IGRlZmF1bHREaXNwbGF5KGVsZW0ubm9kZU5hbWUpIDogZGlzcGxheTtcXG5cXG5cXHRcXHRcXHRpZiAoY2hlY2tEaXNwbGF5ID09PSBcXFwiaW5saW5lXFxcIiAmJiBqUXVlcnkuY3NzKGVsZW0sIFxcXCJmbG9hdFxcXCIpID09PSBcXFwibm9uZVxcXCIpIHtcXG5cXHRcXHRcXHRcXHRzdHlsZS5kaXNwbGF5ID0gXFxcImlubGluZS1ibG9ja1xcXCI7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAob3B0cy5vdmVyZmxvdykge1xcblxcdFxcdFxcdHN0eWxlLm92ZXJmbG93ID0gXFxcImhpZGRlblxcXCI7XFxuXFx0XFx0XFx0YW5pbS5hbHdheXMoZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdHN0eWxlLm92ZXJmbG93ID0gb3B0cy5vdmVyZmxvd1swXTtcXG5cXHRcXHRcXHRcXHRzdHlsZS5vdmVyZmxvd1ggPSBvcHRzLm92ZXJmbG93WzFdO1xcblxcdFxcdFxcdFxcdHN0eWxlLm92ZXJmbG93WSA9IG9wdHMub3ZlcmZsb3dbMl07XFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIHNob3cvaGlkZSBwYXNzXFxuXFx0XFx0Zm9yIChwcm9wIGluIHByb3BzKSB7XFxuXFx0XFx0XFx0dmFsdWUgPSBwcm9wc1twcm9wXTtcXG5cXHRcXHRcXHRpZiAocmZ4dHlwZXMuZXhlYyh2YWx1ZSkpIHtcXG5cXHRcXHRcXHRcXHRkZWxldGUgcHJvcHNbcHJvcF07XFxuXFx0XFx0XFx0XFx0dG9nZ2xlID0gdG9nZ2xlIHx8IHZhbHVlID09PSBcXFwidG9nZ2xlXFxcIjtcXG5cXHRcXHRcXHRcXHRpZiAodmFsdWUgPT09IChoaWRkZW4gPyBcXFwiaGlkZVxcXCIgOiBcXFwic2hvd1xcXCIpKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gSWYgdGhlcmUgaXMgZGF0YVNob3cgbGVmdCBvdmVyIGZyb20gYSBzdG9wcGVkIGhpZGUgb3Igc2hvdyBhbmQgd2UgYXJlIGdvaW5nIHRvIHByb2NlZWQgd2l0aCBzaG93LCB3ZSBzaG91bGQgcHJldGVuZCB0byBiZSBoaWRkZW5cXG5cXHRcXHRcXHRcXHRcXHRpZiAodmFsdWUgPT09IFxcXCJzaG93XFxcIiAmJiBkYXRhU2hvdyAmJiBkYXRhU2hvd1twcm9wXSAhPT0gdW5kZWZpbmVkKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aGlkZGVuID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdGNvbnRpbnVlO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0b3JpZ1twcm9wXSA9IGRhdGFTaG93ICYmIGRhdGFTaG93W3Byb3BdIHx8IGpRdWVyeS5zdHlsZShlbGVtLCBwcm9wKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBBbnkgbm9uLWZ4IHZhbHVlIHN0b3BzIHVzIGZyb20gcmVzdG9yaW5nIHRoZSBvcmlnaW5hbCBkaXNwbGF5IHZhbHVlXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRkaXNwbGF5ID0gdW5kZWZpbmVkO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCFqUXVlcnkuaXNFbXB0eU9iamVjdChvcmlnKSkge1xcblxcdFxcdFxcdGlmIChkYXRhU2hvdykge1xcblxcdFxcdFxcdFxcdGlmIChcXFwiaGlkZGVuXFxcIiBpbiBkYXRhU2hvdykge1xcblxcdFxcdFxcdFxcdFxcdGhpZGRlbiA9IGRhdGFTaG93LmhpZGRlbjtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRkYXRhU2hvdyA9IGRhdGFfcHJpdi5hY2Nlc3MoZWxlbSwgXFxcImZ4c2hvd1xcXCIsIHt9KTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gU3RvcmUgc3RhdGUgaWYgaXRzIHRvZ2dsZSAtIGVuYWJsZXMgLnN0b3AoKS50b2dnbGUoKSB0byBcXFwicmV2ZXJzZVxcXCJcXG5cXHRcXHRcXHRpZiAodG9nZ2xlKSB7XFxuXFx0XFx0XFx0XFx0ZGF0YVNob3cuaGlkZGVuID0gIWhpZGRlbjtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKGhpZGRlbikge1xcblxcdFxcdFxcdFxcdGpRdWVyeShlbGVtKS5zaG93KCk7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRhbmltLmRvbmUoZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdGpRdWVyeShlbGVtKS5oaWRlKCk7XFxuXFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGFuaW0uZG9uZShmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0dmFyIHByb3A7XFxuXFxuXFx0XFx0XFx0XFx0ZGF0YV9wcml2LnJlbW92ZShlbGVtLCBcXFwiZnhzaG93XFxcIik7XFxuXFx0XFx0XFx0XFx0Zm9yIChwcm9wIGluIG9yaWcpIHtcXG5cXHRcXHRcXHRcXHRcXHRqUXVlcnkuc3R5bGUoZWxlbSwgcHJvcCwgb3JpZ1twcm9wXSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdGZvciAocHJvcCBpbiBvcmlnKSB7XFxuXFx0XFx0XFx0XFx0dHdlZW4gPSBjcmVhdGVUd2VlbihoaWRkZW4gPyBkYXRhU2hvd1twcm9wXSA6IDAsIHByb3AsIGFuaW0pO1xcblxcblxcdFxcdFxcdFxcdGlmICghKHByb3AgaW4gZGF0YVNob3cpKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZGF0YVNob3dbcHJvcF0gPSB0d2Vlbi5zdGFydDtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoaGlkZGVuKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dHdlZW4uZW5kID0gdHdlZW4uc3RhcnQ7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dHdlZW4uc3RhcnQgPSBwcm9wID09PSBcXFwid2lkdGhcXFwiIHx8IHByb3AgPT09IFxcXCJoZWlnaHRcXFwiID8gMSA6IDA7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gSWYgdGhpcyBpcyBhIG5vb3AgbGlrZSAuaGlkZSgpLmhpZGUoKSwgcmVzdG9yZSBhbiBvdmVyd3JpdHRlbiBkaXNwbGF5IHZhbHVlXFxuXFx0XFx0fSBlbHNlIGlmICgoZGlzcGxheSA9PT0gXFxcIm5vbmVcXFwiID8gZGVmYXVsdERpc3BsYXkoZWxlbS5ub2RlTmFtZSkgOiBkaXNwbGF5KSA9PT0gXFxcImlubGluZVxcXCIpIHtcXG5cXHRcXHRcXHRzdHlsZS5kaXNwbGF5ID0gZGlzcGxheTtcXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIHByb3BGaWx0ZXIocHJvcHMsIHNwZWNpYWxFYXNpbmcpIHtcXG5cXHRcXHR2YXIgaW5kZXgsIG5hbWUsIGVhc2luZywgdmFsdWUsIGhvb2tzO1xcblxcblxcdFxcdC8vIGNhbWVsQ2FzZSwgc3BlY2lhbEVhc2luZyBhbmQgZXhwYW5kIGNzc0hvb2sgcGFzc1xcblxcdFxcdGZvciAoaW5kZXggaW4gcHJvcHMpIHtcXG5cXHRcXHRcXHRuYW1lID0galF1ZXJ5LmNhbWVsQ2FzZShpbmRleCk7XFxuXFx0XFx0XFx0ZWFzaW5nID0gc3BlY2lhbEVhc2luZ1tuYW1lXTtcXG5cXHRcXHRcXHR2YWx1ZSA9IHByb3BzW2luZGV4XTtcXG5cXHRcXHRcXHRpZiAoalF1ZXJ5LmlzQXJyYXkodmFsdWUpKSB7XFxuXFx0XFx0XFx0XFx0ZWFzaW5nID0gdmFsdWVbMV07XFxuXFx0XFx0XFx0XFx0dmFsdWUgPSBwcm9wc1tpbmRleF0gPSB2YWx1ZVswXTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKGluZGV4ICE9PSBuYW1lKSB7XFxuXFx0XFx0XFx0XFx0cHJvcHNbbmFtZV0gPSB2YWx1ZTtcXG5cXHRcXHRcXHRcXHRkZWxldGUgcHJvcHNbaW5kZXhdO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1tuYW1lXTtcXG5cXHRcXHRcXHRpZiAoaG9va3MgJiYgXFxcImV4cGFuZFxcXCIgaW4gaG9va3MpIHtcXG5cXHRcXHRcXHRcXHR2YWx1ZSA9IGhvb2tzLmV4cGFuZCh2YWx1ZSk7XFxuXFx0XFx0XFx0XFx0ZGVsZXRlIHByb3BzW25hbWVdO1xcblxcblxcdFxcdFxcdFxcdC8vIE5vdCBxdWl0ZSAkLmV4dGVuZCwgdGhpcyB3b24ndCBvdmVyd3JpdGUgZXhpc3Rpbmcga2V5cy5cXG5cXHRcXHRcXHRcXHQvLyBSZXVzaW5nICdpbmRleCcgYmVjYXVzZSB3ZSBoYXZlIHRoZSBjb3JyZWN0IFxcXCJuYW1lXFxcIlxcblxcdFxcdFxcdFxcdGZvciAoaW5kZXggaW4gdmFsdWUpIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIShpbmRleCBpbiBwcm9wcykpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRwcm9wc1tpbmRleF0gPSB2YWx1ZVtpbmRleF07XFxuXFx0XFx0XFx0XFx0XFx0XFx0c3BlY2lhbEVhc2luZ1tpbmRleF0gPSBlYXNpbmc7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdHNwZWNpYWxFYXNpbmdbbmFtZV0gPSBlYXNpbmc7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gQW5pbWF0aW9uKGVsZW0sIHByb3BlcnRpZXMsIG9wdGlvbnMpIHtcXG5cXHRcXHR2YXIgcmVzdWx0LFxcblxcdFxcdCAgICBzdG9wcGVkLFxcblxcdFxcdCAgICBpbmRleCA9IDAsXFxuXFx0XFx0ICAgIGxlbmd0aCA9IGFuaW1hdGlvblByZWZpbHRlcnMubGVuZ3RoLFxcblxcdFxcdCAgICBkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLmFsd2F5cyhmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0Ly8gRG9uJ3QgbWF0Y2ggZWxlbSBpbiB0aGUgOmFuaW1hdGVkIHNlbGVjdG9yXFxuXFx0XFx0XFx0ZGVsZXRlIHRpY2suZWxlbTtcXG5cXHRcXHR9KSxcXG5cXHRcXHQgICAgdGljayA9IGZ1bmN0aW9uIHRpY2soKSB7XFxuXFx0XFx0XFx0aWYgKHN0b3BwZWQpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHZhciBjdXJyZW50VGltZSA9IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXFxuXFx0XFx0XFx0ICAgIHJlbWFpbmluZyA9IE1hdGgubWF4KDAsIGFuaW1hdGlvbi5zdGFydFRpbWUgKyBhbmltYXRpb24uZHVyYXRpb24gLSBjdXJyZW50VGltZSksXFxuXFxuXFx0XFx0XFx0Ly8gU3VwcG9ydDogQW5kcm9pZCAyLjNcXG5cXHRcXHRcXHQvLyBBcmNoYWljIGNyYXNoIGJ1ZyB3b24ndCBhbGxvdyB1cyB0byB1c2UgYDEgLSAoIDAuNSB8fCAwIClgICgjMTI0OTcpXFxuXFx0XFx0XFx0dGVtcCA9IHJlbWFpbmluZyAvIGFuaW1hdGlvbi5kdXJhdGlvbiB8fCAwLFxcblxcdFxcdFxcdCAgICBwZXJjZW50ID0gMSAtIHRlbXAsXFxuXFx0XFx0XFx0ICAgIGluZGV4ID0gMCxcXG5cXHRcXHRcXHQgICAgbGVuZ3RoID0gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGg7XFxuXFxuXFx0XFx0XFx0Zm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XFxuXFx0XFx0XFx0XFx0YW5pbWF0aW9uLnR3ZWVuc1tpbmRleF0ucnVuKHBlcmNlbnQpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRkZWZlcnJlZC5ub3RpZnlXaXRoKGVsZW0sIFthbmltYXRpb24sIHBlcmNlbnQsIHJlbWFpbmluZ10pO1xcblxcblxcdFxcdFxcdGlmIChwZXJjZW50IDwgMSAmJiBsZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gcmVtYWluaW5nO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoZWxlbSwgW2FuaW1hdGlvbl0pO1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXHRcXHQgICAgYW5pbWF0aW9uID0gZGVmZXJyZWQucHJvbWlzZSh7XFxuXFx0XFx0XFx0ZWxlbTogZWxlbSxcXG5cXHRcXHRcXHRwcm9wczogalF1ZXJ5LmV4dGVuZCh7fSwgcHJvcGVydGllcyksXFxuXFx0XFx0XFx0b3B0czogalF1ZXJ5LmV4dGVuZCh0cnVlLCB7IHNwZWNpYWxFYXNpbmc6IHt9IH0sIG9wdGlvbnMpLFxcblxcdFxcdFxcdG9yaWdpbmFsUHJvcGVydGllczogcHJvcGVydGllcyxcXG5cXHRcXHRcXHRvcmlnaW5hbE9wdGlvbnM6IG9wdGlvbnMsXFxuXFx0XFx0XFx0c3RhcnRUaW1lOiBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxcblxcdFxcdFxcdGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxcblxcdFxcdFxcdHR3ZWVuczogW10sXFxuXFx0XFx0XFx0Y3JlYXRlVHdlZW46IGZ1bmN0aW9uIGNyZWF0ZVR3ZWVuKHByb3AsIGVuZCkge1xcblxcdFxcdFxcdFxcdHZhciB0d2VlbiA9IGpRdWVyeS5Ud2VlbihlbGVtLCBhbmltYXRpb24ub3B0cywgcHJvcCwgZW5kLCBhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nW3Byb3BdIHx8IGFuaW1hdGlvbi5vcHRzLmVhc2luZyk7XFxuXFx0XFx0XFx0XFx0YW5pbWF0aW9uLnR3ZWVucy5wdXNoKHR3ZWVuKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdHdlZW47XFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRzdG9wOiBmdW5jdGlvbiBzdG9wKGdvdG9FbmQpIHtcXG5cXHRcXHRcXHRcXHR2YXIgaW5kZXggPSAwLFxcblxcblxcdFxcdFxcdFxcdC8vIElmIHdlIGFyZSBnb2luZyB0byB0aGUgZW5kLCB3ZSB3YW50IHRvIHJ1biBhbGwgdGhlIHR3ZWVuc1xcblxcdFxcdFxcdFxcdC8vIG90aGVyd2lzZSB3ZSBza2lwIHRoaXMgcGFydFxcblxcdFxcdFxcdFxcdGxlbmd0aCA9IGdvdG9FbmQgPyBhbmltYXRpb24udHdlZW5zLmxlbmd0aCA6IDA7XFxuXFx0XFx0XFx0XFx0aWYgKHN0b3BwZWQpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0c3RvcHBlZCA9IHRydWU7XFxuXFx0XFx0XFx0XFx0Zm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0YW5pbWF0aW9uLnR3ZWVuc1tpbmRleF0ucnVuKDEpO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBSZXNvbHZlIHdoZW4gd2UgcGxheWVkIHRoZSBsYXN0IGZyYW1lOyBvdGhlcndpc2UsIHJlamVjdFxcblxcdFxcdFxcdFxcdGlmIChnb3RvRW5kKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoZWxlbSwgW2FuaW1hdGlvbiwgZ290b0VuZF0pO1xcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0ZGVmZXJyZWQucmVqZWN0V2l0aChlbGVtLCBbYW5pbWF0aW9uLCBnb3RvRW5kXSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9KSxcXG5cXHRcXHQgICAgcHJvcHMgPSBhbmltYXRpb24ucHJvcHM7XFxuXFxuXFx0XFx0cHJvcEZpbHRlcihwcm9wcywgYW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZyk7XFxuXFxuXFx0XFx0Zm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XFxuXFx0XFx0XFx0cmVzdWx0ID0gYW5pbWF0aW9uUHJlZmlsdGVyc1tpbmRleF0uY2FsbChhbmltYXRpb24sIGVsZW0sIHByb3BzLCBhbmltYXRpb24ub3B0cyk7XFxuXFx0XFx0XFx0aWYgKHJlc3VsdCkge1xcblxcdFxcdFxcdFxcdHJldHVybiByZXN1bHQ7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHRqUXVlcnkubWFwKHByb3BzLCBjcmVhdGVUd2VlbiwgYW5pbWF0aW9uKTtcXG5cXG5cXHRcXHRpZiAoalF1ZXJ5LmlzRnVuY3Rpb24oYW5pbWF0aW9uLm9wdHMuc3RhcnQpKSB7XFxuXFx0XFx0XFx0YW5pbWF0aW9uLm9wdHMuc3RhcnQuY2FsbChlbGVtLCBhbmltYXRpb24pO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRqUXVlcnkuZngudGltZXIoalF1ZXJ5LmV4dGVuZCh0aWNrLCB7XFxuXFx0XFx0XFx0ZWxlbTogZWxlbSxcXG5cXHRcXHRcXHRhbmltOiBhbmltYXRpb24sXFxuXFx0XFx0XFx0cXVldWU6IGFuaW1hdGlvbi5vcHRzLnF1ZXVlXFxuXFx0XFx0fSkpO1xcblxcblxcdFxcdC8vIGF0dGFjaCBjYWxsYmFja3MgZnJvbSBvcHRpb25zXFxuXFx0XFx0cmV0dXJuIGFuaW1hdGlvbi5wcm9ncmVzcyhhbmltYXRpb24ub3B0cy5wcm9ncmVzcykuZG9uZShhbmltYXRpb24ub3B0cy5kb25lLCBhbmltYXRpb24ub3B0cy5jb21wbGV0ZSkuZmFpbChhbmltYXRpb24ub3B0cy5mYWlsKS5hbHdheXMoYW5pbWF0aW9uLm9wdHMuYWx3YXlzKTtcXG5cXHR9XFxuXFxuXFx0alF1ZXJ5LkFuaW1hdGlvbiA9IGpRdWVyeS5leHRlbmQoQW5pbWF0aW9uLCB7XFxuXFxuXFx0XFx0dHdlZW5lcjogZnVuY3Rpb24gdHdlZW5lcihwcm9wcywgY2FsbGJhY2spIHtcXG5cXHRcXHRcXHRpZiAoalF1ZXJ5LmlzRnVuY3Rpb24ocHJvcHMpKSB7XFxuXFx0XFx0XFx0XFx0Y2FsbGJhY2sgPSBwcm9wcztcXG5cXHRcXHRcXHRcXHRwcm9wcyA9IFtcXFwiKlxcXCJdO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0cHJvcHMgPSBwcm9wcy5zcGxpdChcXFwiIFxcXCIpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2YXIgcHJvcCxcXG5cXHRcXHRcXHQgICAgaW5kZXggPSAwLFxcblxcdFxcdFxcdCAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XFxuXFxuXFx0XFx0XFx0Zm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XFxuXFx0XFx0XFx0XFx0cHJvcCA9IHByb3BzW2luZGV4XTtcXG5cXHRcXHRcXHRcXHR0d2VlbmVyc1twcm9wXSA9IHR3ZWVuZXJzW3Byb3BdIHx8IFtdO1xcblxcdFxcdFxcdFxcdHR3ZWVuZXJzW3Byb3BdLnVuc2hpZnQoY2FsbGJhY2spO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcblxcdFxcdHByZWZpbHRlcjogZnVuY3Rpb24gcHJlZmlsdGVyKGNhbGxiYWNrLCBwcmVwZW5kKSB7XFxuXFx0XFx0XFx0aWYgKHByZXBlbmQpIHtcXG5cXHRcXHRcXHRcXHRhbmltYXRpb25QcmVmaWx0ZXJzLnVuc2hpZnQoY2FsbGJhY2spO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0YW5pbWF0aW9uUHJlZmlsdGVycy5wdXNoKGNhbGxiYWNrKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH0pO1xcblxcblxcdGpRdWVyeS5zcGVlZCA9IGZ1bmN0aW9uIChzcGVlZCwgZWFzaW5nLCBmbikge1xcblxcdFxcdHZhciBvcHQgPSBzcGVlZCAmJiAodHlwZW9mIHNwZWVkID09PSBcXFwidW5kZWZpbmVkXFxcIiA/IFxcXCJ1bmRlZmluZWRcXFwiIDogX3R5cGVvZihzcGVlZCkpID09PSBcXFwib2JqZWN0XFxcIiA/IGpRdWVyeS5leHRlbmQoe30sIHNwZWVkKSA6IHtcXG5cXHRcXHRcXHRjb21wbGV0ZTogZm4gfHwgIWZuICYmIGVhc2luZyB8fCBqUXVlcnkuaXNGdW5jdGlvbihzcGVlZCkgJiYgc3BlZWQsXFxuXFx0XFx0XFx0ZHVyYXRpb246IHNwZWVkLFxcblxcdFxcdFxcdGVhc2luZzogZm4gJiYgZWFzaW5nIHx8IGVhc2luZyAmJiAhalF1ZXJ5LmlzRnVuY3Rpb24oZWFzaW5nKSAmJiBlYXNpbmdcXG5cXHRcXHR9O1xcblxcblxcdFxcdG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5vZmYgPyAwIDogdHlwZW9mIG9wdC5kdXJhdGlvbiA9PT0gXFxcIm51bWJlclxcXCIgPyBvcHQuZHVyYXRpb24gOiBvcHQuZHVyYXRpb24gaW4galF1ZXJ5LmZ4LnNwZWVkcyA/IGpRdWVyeS5meC5zcGVlZHNbb3B0LmR1cmF0aW9uXSA6IGpRdWVyeS5meC5zcGVlZHMuX2RlZmF1bHQ7XFxuXFxuXFx0XFx0Ly8gTm9ybWFsaXplIG9wdC5xdWV1ZSAtIHRydWUvdW5kZWZpbmVkL251bGwgLT4gXFxcImZ4XFxcIlxcblxcdFxcdGlmIChvcHQucXVldWUgPT0gbnVsbCB8fCBvcHQucXVldWUgPT09IHRydWUpIHtcXG5cXHRcXHRcXHRvcHQucXVldWUgPSBcXFwiZnhcXFwiO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBRdWV1ZWluZ1xcblxcdFxcdG9wdC5vbGQgPSBvcHQuY29tcGxldGU7XFxuXFxuXFx0XFx0b3B0LmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdGlmIChqUXVlcnkuaXNGdW5jdGlvbihvcHQub2xkKSkge1xcblxcdFxcdFxcdFxcdG9wdC5vbGQuY2FsbCh0aGlzKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKG9wdC5xdWV1ZSkge1xcblxcdFxcdFxcdFxcdGpRdWVyeS5kZXF1ZXVlKHRoaXMsIG9wdC5xdWV1ZSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH07XFxuXFxuXFx0XFx0cmV0dXJuIG9wdDtcXG5cXHR9O1xcblxcblxcdGpRdWVyeS5mbi5leHRlbmQoe1xcblxcdFxcdGZhZGVUbzogZnVuY3Rpb24gZmFkZVRvKHNwZWVkLCB0bywgZWFzaW5nLCBjYWxsYmFjaykge1xcblxcblxcdFxcdFxcdC8vIFNob3cgYW55IGhpZGRlbiBlbGVtZW50cyBhZnRlciBzZXR0aW5nIG9wYWNpdHkgdG8gMFxcblxcdFxcdFxcdHJldHVybiB0aGlzLmZpbHRlcihpc0hpZGRlbikuY3NzKFxcXCJvcGFjaXR5XFxcIiwgMCkuc2hvdygpXFxuXFxuXFx0XFx0XFx0Ly8gQW5pbWF0ZSB0byB0aGUgdmFsdWUgc3BlY2lmaWVkXFxuXFx0XFx0XFx0LmVuZCgpLmFuaW1hdGUoeyBvcGFjaXR5OiB0byB9LCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayk7XFxuXFx0XFx0fSxcXG5cXHRcXHRhbmltYXRlOiBmdW5jdGlvbiBhbmltYXRlKHByb3AsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrKSB7XFxuXFx0XFx0XFx0dmFyIGVtcHR5ID0galF1ZXJ5LmlzRW1wdHlPYmplY3QocHJvcCksXFxuXFx0XFx0XFx0ICAgIG9wdGFsbCA9IGpRdWVyeS5zcGVlZChzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayksXFxuXFx0XFx0XFx0ICAgIGRvQW5pbWF0aW9uID0gZnVuY3Rpb24gZG9BbmltYXRpb24oKSB7XFxuXFx0XFx0XFx0XFx0Ly8gT3BlcmF0ZSBvbiBhIGNvcHkgb2YgcHJvcCBzbyBwZXItcHJvcGVydHkgZWFzaW5nIHdvbid0IGJlIGxvc3RcXG5cXHRcXHRcXHRcXHR2YXIgYW5pbSA9IEFuaW1hdGlvbih0aGlzLCBqUXVlcnkuZXh0ZW5kKHt9LCBwcm9wKSwgb3B0YWxsKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBFbXB0eSBhbmltYXRpb25zLCBvciBmaW5pc2hpbmcgcmVzb2x2ZXMgaW1tZWRpYXRlbHlcXG5cXHRcXHRcXHRcXHRpZiAoZW1wdHkgfHwgZGF0YV9wcml2LmdldCh0aGlzLCBcXFwiZmluaXNoXFxcIikpIHtcXG5cXHRcXHRcXHRcXHRcXHRhbmltLnN0b3AodHJ1ZSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH07XFxuXFx0XFx0XFx0ZG9BbmltYXRpb24uZmluaXNoID0gZG9BbmltYXRpb247XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGVtcHR5IHx8IG9wdGFsbC5xdWV1ZSA9PT0gZmFsc2UgPyB0aGlzLmVhY2goZG9BbmltYXRpb24pIDogdGhpcy5xdWV1ZShvcHRhbGwucXVldWUsIGRvQW5pbWF0aW9uKTtcXG5cXHRcXHR9LFxcblxcdFxcdHN0b3A6IGZ1bmN0aW9uIHN0b3AodHlwZSwgY2xlYXJRdWV1ZSwgZ290b0VuZCkge1xcblxcdFxcdFxcdHZhciBzdG9wUXVldWUgPSBmdW5jdGlvbiBzdG9wUXVldWUoaG9va3MpIHtcXG5cXHRcXHRcXHRcXHR2YXIgc3RvcCA9IGhvb2tzLnN0b3A7XFxuXFx0XFx0XFx0XFx0ZGVsZXRlIGhvb2tzLnN0b3A7XFxuXFx0XFx0XFx0XFx0c3RvcChnb3RvRW5kKTtcXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdFxcdGlmICh0eXBlb2YgdHlwZSAhPT0gXFxcInN0cmluZ1xcXCIpIHtcXG5cXHRcXHRcXHRcXHRnb3RvRW5kID0gY2xlYXJRdWV1ZTtcXG5cXHRcXHRcXHRcXHRjbGVhclF1ZXVlID0gdHlwZTtcXG5cXHRcXHRcXHRcXHR0eXBlID0gdW5kZWZpbmVkO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoY2xlYXJRdWV1ZSAmJiB0eXBlICE9PSBmYWxzZSkge1xcblxcdFxcdFxcdFxcdHRoaXMucXVldWUodHlwZSB8fCBcXFwiZnhcXFwiLCBbXSk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdHZhciBkZXF1ZXVlID0gdHJ1ZSxcXG5cXHRcXHRcXHRcXHQgICAgaW5kZXggPSB0eXBlICE9IG51bGwgJiYgdHlwZSArIFxcXCJxdWV1ZUhvb2tzXFxcIixcXG5cXHRcXHRcXHRcXHQgICAgdGltZXJzID0galF1ZXJ5LnRpbWVycyxcXG5cXHRcXHRcXHRcXHQgICAgZGF0YSA9IGRhdGFfcHJpdi5nZXQodGhpcyk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKGluZGV4KSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGRhdGFbaW5kZXhdICYmIGRhdGFbaW5kZXhdLnN0b3ApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzdG9wUXVldWUoZGF0YVtpbmRleF0pO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdGZvciAoaW5kZXggaW4gZGF0YSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChkYXRhW2luZGV4XSAmJiBkYXRhW2luZGV4XS5zdG9wICYmIHJydW4udGVzdChpbmRleCkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzdG9wUXVldWUoZGF0YVtpbmRleF0pO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGZvciAoaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOykge1xcblxcdFxcdFxcdFxcdFxcdGlmICh0aW1lcnNbaW5kZXhdLmVsZW0gPT09IHRoaXMgJiYgKHR5cGUgPT0gbnVsbCB8fCB0aW1lcnNbaW5kZXhdLnF1ZXVlID09PSB0eXBlKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRpbWVyc1tpbmRleF0uYW5pbS5zdG9wKGdvdG9FbmQpO1xcblxcdFxcdFxcdFxcdFxcdFxcdGRlcXVldWUgPSBmYWxzZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aW1lcnMuc3BsaWNlKGluZGV4LCAxKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIFN0YXJ0IHRoZSBuZXh0IGluIHRoZSBxdWV1ZSBpZiB0aGUgbGFzdCBzdGVwIHdhc24ndCBmb3JjZWQuXFxuXFx0XFx0XFx0XFx0Ly8gVGltZXJzIGN1cnJlbnRseSB3aWxsIGNhbGwgdGhlaXIgY29tcGxldGUgY2FsbGJhY2tzLCB3aGljaFxcblxcdFxcdFxcdFxcdC8vIHdpbGwgZGVxdWV1ZSBidXQgb25seSBpZiB0aGV5IHdlcmUgZ290b0VuZC5cXG5cXHRcXHRcXHRcXHRpZiAoZGVxdWV1ZSB8fCAhZ290b0VuZCkge1xcblxcdFxcdFxcdFxcdFxcdGpRdWVyeS5kZXF1ZXVlKHRoaXMsIHR5cGUpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHR9LFxcblxcdFxcdGZpbmlzaDogZnVuY3Rpb24gZmluaXNoKHR5cGUpIHtcXG5cXHRcXHRcXHRpZiAodHlwZSAhPT0gZmFsc2UpIHtcXG5cXHRcXHRcXHRcXHR0eXBlID0gdHlwZSB8fCBcXFwiZnhcXFwiO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHR2YXIgaW5kZXgsXFxuXFx0XFx0XFx0XFx0ICAgIGRhdGEgPSBkYXRhX3ByaXYuZ2V0KHRoaXMpLFxcblxcdFxcdFxcdFxcdCAgICBxdWV1ZSA9IGRhdGFbdHlwZSArIFxcXCJxdWV1ZVxcXCJdLFxcblxcdFxcdFxcdFxcdCAgICBob29rcyA9IGRhdGFbdHlwZSArIFxcXCJxdWV1ZUhvb2tzXFxcIl0sXFxuXFx0XFx0XFx0XFx0ICAgIHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXFxuXFx0XFx0XFx0XFx0ICAgIGxlbmd0aCA9IHF1ZXVlID8gcXVldWUubGVuZ3RoIDogMDtcXG5cXG5cXHRcXHRcXHRcXHQvLyBFbmFibGUgZmluaXNoaW5nIGZsYWcgb24gcHJpdmF0ZSBkYXRhXFxuXFx0XFx0XFx0XFx0ZGF0YS5maW5pc2ggPSB0cnVlO1xcblxcblxcdFxcdFxcdFxcdC8vIEVtcHR5IHRoZSBxdWV1ZSBmaXJzdFxcblxcdFxcdFxcdFxcdGpRdWVyeS5xdWV1ZSh0aGlzLCB0eXBlLCBbXSk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKGhvb2tzICYmIGhvb2tzLnN0b3ApIHtcXG5cXHRcXHRcXHRcXHRcXHRob29rcy5zdG9wLmNhbGwodGhpcywgdHJ1ZSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIExvb2sgZm9yIGFueSBhY3RpdmUgYW5pbWF0aW9ucywgYW5kIGZpbmlzaCB0aGVtXFxuXFx0XFx0XFx0XFx0Zm9yIChpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07KSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHRpbWVyc1tpbmRleF0uZWxlbSA9PT0gdGhpcyAmJiB0aW1lcnNbaW5kZXhdLnF1ZXVlID09PSB0eXBlKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGltZXJzW2luZGV4XS5hbmltLnN0b3AodHJ1ZSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGltZXJzLnNwbGljZShpbmRleCwgMSk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBMb29rIGZvciBhbnkgYW5pbWF0aW9ucyBpbiB0aGUgb2xkIHF1ZXVlIGFuZCBmaW5pc2ggdGhlbVxcblxcdFxcdFxcdFxcdGZvciAoaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xcblxcdFxcdFxcdFxcdFxcdGlmIChxdWV1ZVtpbmRleF0gJiYgcXVldWVbaW5kZXhdLmZpbmlzaCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHF1ZXVlW2luZGV4XS5maW5pc2guY2FsbCh0aGlzKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIFR1cm4gb2ZmIGZpbmlzaGluZyBmbGFnXFxuXFx0XFx0XFx0XFx0ZGVsZXRlIGRhdGEuZmluaXNoO1xcblxcdFxcdFxcdH0pO1xcblxcdFxcdH1cXG5cXHR9KTtcXG5cXG5cXHRqUXVlcnkuZWFjaChbXFxcInRvZ2dsZVxcXCIsIFxcXCJzaG93XFxcIiwgXFxcImhpZGVcXFwiXSwgZnVuY3Rpb24gKGksIG5hbWUpIHtcXG5cXHRcXHR2YXIgY3NzRm4gPSBqUXVlcnkuZm5bbmFtZV07XFxuXFx0XFx0alF1ZXJ5LmZuW25hbWVdID0gZnVuY3Rpb24gKHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHNwZWVkID09IG51bGwgfHwgdHlwZW9mIHNwZWVkID09PSBcXFwiYm9vbGVhblxcXCIgPyBjc3NGbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogdGhpcy5hbmltYXRlKGdlbkZ4KG5hbWUsIHRydWUpLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayk7XFxuXFx0XFx0fTtcXG5cXHR9KTtcXG5cXG5cXHQvLyBHZW5lcmF0ZSBzaG9ydGN1dHMgZm9yIGN1c3RvbSBhbmltYXRpb25zXFxuXFx0alF1ZXJ5LmVhY2goe1xcblxcdFxcdHNsaWRlRG93bjogZ2VuRngoXFxcInNob3dcXFwiKSxcXG5cXHRcXHRzbGlkZVVwOiBnZW5GeChcXFwiaGlkZVxcXCIpLFxcblxcdFxcdHNsaWRlVG9nZ2xlOiBnZW5GeChcXFwidG9nZ2xlXFxcIiksXFxuXFx0XFx0ZmFkZUluOiB7IG9wYWNpdHk6IFxcXCJzaG93XFxcIiB9LFxcblxcdFxcdGZhZGVPdXQ6IHsgb3BhY2l0eTogXFxcImhpZGVcXFwiIH0sXFxuXFx0XFx0ZmFkZVRvZ2dsZTogeyBvcGFjaXR5OiBcXFwidG9nZ2xlXFxcIiB9XFxuXFx0fSwgZnVuY3Rpb24gKG5hbWUsIHByb3BzKSB7XFxuXFx0XFx0alF1ZXJ5LmZuW25hbWVdID0gZnVuY3Rpb24gKHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuYW5pbWF0ZShwcm9wcywgc3BlZWQsIGVhc2luZywgY2FsbGJhY2spO1xcblxcdFxcdH07XFxuXFx0fSk7XFxuXFxuXFx0alF1ZXJ5LnRpbWVycyA9IFtdO1xcblxcdGpRdWVyeS5meC50aWNrID0gZnVuY3Rpb24gKCkge1xcblxcdFxcdHZhciB0aW1lcixcXG5cXHRcXHQgICAgaSA9IDAsXFxuXFx0XFx0ICAgIHRpbWVycyA9IGpRdWVyeS50aW1lcnM7XFxuXFxuXFx0XFx0ZnhOb3cgPSBqUXVlcnkubm93KCk7XFxuXFxuXFx0XFx0Zm9yICg7IGkgPCB0aW1lcnMubGVuZ3RoOyBpKyspIHtcXG5cXHRcXHRcXHR0aW1lciA9IHRpbWVyc1tpXTtcXG5cXHRcXHRcXHQvLyBDaGVja3MgdGhlIHRpbWVyIGhhcyBub3QgYWxyZWFkeSBiZWVuIHJlbW92ZWRcXG5cXHRcXHRcXHRpZiAoIXRpbWVyKCkgJiYgdGltZXJzW2ldID09PSB0aW1lcikge1xcblxcdFxcdFxcdFxcdHRpbWVycy5zcGxpY2UoaS0tLCAxKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICghdGltZXJzLmxlbmd0aCkge1xcblxcdFxcdFxcdGpRdWVyeS5meC5zdG9wKCk7XFxuXFx0XFx0fVxcblxcdFxcdGZ4Tm93ID0gdW5kZWZpbmVkO1xcblxcdH07XFxuXFxuXFx0alF1ZXJ5LmZ4LnRpbWVyID0gZnVuY3Rpb24gKHRpbWVyKSB7XFxuXFx0XFx0alF1ZXJ5LnRpbWVycy5wdXNoKHRpbWVyKTtcXG5cXHRcXHRpZiAodGltZXIoKSkge1xcblxcdFxcdFxcdGpRdWVyeS5meC5zdGFydCgpO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0alF1ZXJ5LnRpbWVycy5wb3AoKTtcXG5cXHRcXHR9XFxuXFx0fTtcXG5cXG5cXHRqUXVlcnkuZnguaW50ZXJ2YWwgPSAxMztcXG5cXG5cXHRqUXVlcnkuZnguc3RhcnQgPSBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0aWYgKCF0aW1lcklkKSB7XFxuXFx0XFx0XFx0dGltZXJJZCA9IHNldEludGVydmFsKGpRdWVyeS5meC50aWNrLCBqUXVlcnkuZnguaW50ZXJ2YWwpO1xcblxcdFxcdH1cXG5cXHR9O1xcblxcblxcdGpRdWVyeS5meC5zdG9wID0gZnVuY3Rpb24gKCkge1xcblxcdFxcdGNsZWFySW50ZXJ2YWwodGltZXJJZCk7XFxuXFx0XFx0dGltZXJJZCA9IG51bGw7XFxuXFx0fTtcXG5cXG5cXHRqUXVlcnkuZnguc3BlZWRzID0ge1xcblxcdFxcdHNsb3c6IDYwMCxcXG5cXHRcXHRmYXN0OiAyMDAsXFxuXFx0XFx0Ly8gRGVmYXVsdCBzcGVlZFxcblxcdFxcdF9kZWZhdWx0OiA0MDBcXG5cXHR9O1xcblxcblxcdC8vIEJhc2VkIG9mZiBvZiB0aGUgcGx1Z2luIGJ5IENsaW50IEhlbGZlcnMsIHdpdGggcGVybWlzc2lvbi5cXG5cXHQvLyBodHRwOi8vYmxpbmRzaWduYWxzLmNvbS9pbmRleC5waHAvMjAwOS8wNy9qcXVlcnktZGVsYXkvXFxuXFx0alF1ZXJ5LmZuLmRlbGF5ID0gZnVuY3Rpb24gKHRpbWUsIHR5cGUpIHtcXG5cXHRcXHR0aW1lID0galF1ZXJ5LmZ4ID8galF1ZXJ5LmZ4LnNwZWVkc1t0aW1lXSB8fCB0aW1lIDogdGltZTtcXG5cXHRcXHR0eXBlID0gdHlwZSB8fCBcXFwiZnhcXFwiO1xcblxcblxcdFxcdHJldHVybiB0aGlzLnF1ZXVlKHR5cGUsIGZ1bmN0aW9uIChuZXh0LCBob29rcykge1xcblxcdFxcdFxcdHZhciB0aW1lb3V0ID0gc2V0VGltZW91dChuZXh0LCB0aW1lKTtcXG5cXHRcXHRcXHRob29rcy5zdG9wID0gZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdGNsZWFyVGltZW91dCh0aW1lb3V0KTtcXG5cXHRcXHRcXHR9O1xcblxcdFxcdH0pO1xcblxcdH07XFxuXFxuXFx0KGZ1bmN0aW9uICgpIHtcXG5cXHRcXHR2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxcXCJpbnB1dFxcXCIpLFxcblxcdFxcdCAgICBzZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxcXCJzZWxlY3RcXFwiKSxcXG5cXHRcXHQgICAgb3B0ID0gc2VsZWN0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXFxcIm9wdGlvblxcXCIpKTtcXG5cXG5cXHRcXHRpbnB1dC50eXBlID0gXFxcImNoZWNrYm94XFxcIjtcXG5cXG5cXHRcXHQvLyBTdXBwb3J0OiBpT1M8PTUuMSwgQW5kcm9pZDw9NC4yK1xcblxcdFxcdC8vIERlZmF1bHQgdmFsdWUgZm9yIGEgY2hlY2tib3ggc2hvdWxkIGJlIFxcXCJvblxcXCJcXG5cXHRcXHRzdXBwb3J0LmNoZWNrT24gPSBpbnB1dC52YWx1ZSAhPT0gXFxcIlxcXCI7XFxuXFxuXFx0XFx0Ly8gU3VwcG9ydDogSUU8PTExK1xcblxcdFxcdC8vIE11c3QgYWNjZXNzIHNlbGVjdGVkSW5kZXggdG8gbWFrZSBkZWZhdWx0IG9wdGlvbnMgc2VsZWN0XFxuXFx0XFx0c3VwcG9ydC5vcHRTZWxlY3RlZCA9IG9wdC5zZWxlY3RlZDtcXG5cXG5cXHRcXHQvLyBTdXBwb3J0OiBBbmRyb2lkPD0yLjNcXG5cXHRcXHQvLyBPcHRpb25zIGluc2lkZSBkaXNhYmxlZCBzZWxlY3RzIGFyZSBpbmNvcnJlY3RseSBtYXJrZWQgYXMgZGlzYWJsZWRcXG5cXHRcXHRzZWxlY3QuZGlzYWJsZWQgPSB0cnVlO1xcblxcdFxcdHN1cHBvcnQub3B0RGlzYWJsZWQgPSAhb3B0LmRpc2FibGVkO1xcblxcblxcdFxcdC8vIFN1cHBvcnQ6IElFPD0xMStcXG5cXHRcXHQvLyBBbiBpbnB1dCBsb3NlcyBpdHMgdmFsdWUgYWZ0ZXIgYmVjb21pbmcgYSByYWRpb1xcblxcdFxcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwiaW5wdXRcXFwiKTtcXG5cXHRcXHRpbnB1dC52YWx1ZSA9IFxcXCJ0XFxcIjtcXG5cXHRcXHRpbnB1dC50eXBlID0gXFxcInJhZGlvXFxcIjtcXG5cXHRcXHRzdXBwb3J0LnJhZGlvVmFsdWUgPSBpbnB1dC52YWx1ZSA9PT0gXFxcInRcXFwiO1xcblxcdH0pKCk7XFxuXFxuXFx0dmFyIG5vZGVIb29rLFxcblxcdCAgICBib29sSG9vayxcXG5cXHQgICAgYXR0ckhhbmRsZSA9IGpRdWVyeS5leHByLmF0dHJIYW5kbGU7XFxuXFxuXFx0alF1ZXJ5LmZuLmV4dGVuZCh7XFxuXFx0XFx0YXR0cjogZnVuY3Rpb24gYXR0cihuYW1lLCB2YWx1ZSkge1xcblxcdFxcdFxcdHJldHVybiBhY2Nlc3ModGhpcywgalF1ZXJ5LmF0dHIsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiByZW1vdmVBdHRyKG5hbWUpIHtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRqUXVlcnkucmVtb3ZlQXR0cih0aGlzLCBuYW1lKTtcXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHR9XFxuXFx0fSk7XFxuXFxuXFx0alF1ZXJ5LmV4dGVuZCh7XFxuXFx0XFx0YXR0cjogZnVuY3Rpb24gYXR0cihlbGVtLCBuYW1lLCB2YWx1ZSkge1xcblxcdFxcdFxcdHZhciBob29rcyxcXG5cXHRcXHRcXHQgICAgcmV0LFxcblxcdFxcdFxcdCAgICBuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XFxuXFxuXFx0XFx0XFx0Ly8gZG9uJ3QgZ2V0L3NldCBhdHRyaWJ1dGVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xcblxcdFxcdFxcdGlmICghZWxlbSB8fCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMikge1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gRmFsbGJhY2sgdG8gcHJvcCB3aGVuIGF0dHJpYnV0ZXMgYXJlIG5vdCBzdXBwb3J0ZWRcXG5cXHRcXHRcXHRpZiAoX3R5cGVvZihlbGVtLmdldEF0dHJpYnV0ZSkgPT09IHN0cnVuZGVmaW5lZCkge1xcblxcdFxcdFxcdFxcdHJldHVybiBqUXVlcnkucHJvcChlbGVtLCBuYW1lLCB2YWx1ZSk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIEFsbCBhdHRyaWJ1dGVzIGFyZSBsb3dlcmNhc2VcXG5cXHRcXHRcXHQvLyBHcmFiIG5lY2Vzc2FyeSBob29rIGlmIG9uZSBpcyBkZWZpbmVkXFxuXFx0XFx0XFx0aWYgKG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoZWxlbSkpIHtcXG5cXHRcXHRcXHRcXHRuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xcblxcdFxcdFxcdFxcdGhvb2tzID0galF1ZXJ5LmF0dHJIb29rc1tuYW1lXSB8fCAoalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC50ZXN0KG5hbWUpID8gYm9vbEhvb2sgOiBub2RlSG9vayk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKHZhbHVlID09PSBudWxsKSB7XFxuXFx0XFx0XFx0XFx0XFx0alF1ZXJ5LnJlbW92ZUF0dHIoZWxlbSwgbmFtZSk7XFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmIChob29rcyAmJiBcXFwic2V0XFxcIiBpbiBob29rcyAmJiAocmV0ID0gaG9va3Muc2V0KGVsZW0sIHZhbHVlLCBuYW1lKSkgIT09IHVuZGVmaW5lZCkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiByZXQ7XFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRlbGVtLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSArIFxcXCJcXFwiKTtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdmFsdWU7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0gZWxzZSBpZiAoaG9va3MgJiYgXFxcImdldFxcXCIgaW4gaG9va3MgJiYgKHJldCA9IGhvb2tzLmdldChlbGVtLCBuYW1lKSkgIT09IG51bGwpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gcmV0O1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0cmV0ID0galF1ZXJ5LmZpbmQuYXR0cihlbGVtLCBuYW1lKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBOb24tZXhpc3RlbnQgYXR0cmlidXRlcyByZXR1cm4gbnVsbCwgd2Ugbm9ybWFsaXplIHRvIHVuZGVmaW5lZFxcblxcdFxcdFxcdFxcdHJldHVybiByZXQgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHJldDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiByZW1vdmVBdHRyKGVsZW0sIHZhbHVlKSB7XFxuXFx0XFx0XFx0dmFyIG5hbWUsXFxuXFx0XFx0XFx0ICAgIHByb3BOYW1lLFxcblxcdFxcdFxcdCAgICBpID0gMCxcXG5cXHRcXHRcXHQgICAgYXR0ck5hbWVzID0gdmFsdWUgJiYgdmFsdWUubWF0Y2gocm5vdHdoaXRlKTtcXG5cXG5cXHRcXHRcXHRpZiAoYXR0ck5hbWVzICYmIGVsZW0ubm9kZVR5cGUgPT09IDEpIHtcXG5cXHRcXHRcXHRcXHR3aGlsZSAobmFtZSA9IGF0dHJOYW1lc1tpKytdKSB7XFxuXFx0XFx0XFx0XFx0XFx0cHJvcE5hbWUgPSBqUXVlcnkucHJvcEZpeFtuYW1lXSB8fCBuYW1lO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIEJvb2xlYW4gYXR0cmlidXRlcyBnZXQgc3BlY2lhbCB0cmVhdG1lbnQgKCMxMDg3MClcXG5cXHRcXHRcXHRcXHRcXHRpZiAoalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC50ZXN0KG5hbWUpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gU2V0IGNvcnJlc3BvbmRpbmcgcHJvcGVydHkgdG8gZmFsc2VcXG5cXHRcXHRcXHRcXHRcXHRcXHRlbGVtW3Byb3BOYW1lXSA9IGZhbHNlO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRlbGVtLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFxuXFx0XFx0YXR0ckhvb2tzOiB7XFxuXFx0XFx0XFx0dHlwZToge1xcblxcdFxcdFxcdFxcdHNldDogZnVuY3Rpb24gc2V0KGVsZW0sIHZhbHVlKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCFzdXBwb3J0LnJhZGlvVmFsdWUgJiYgdmFsdWUgPT09IFxcXCJyYWRpb1xcXCIgJiYgalF1ZXJ5Lm5vZGVOYW1lKGVsZW0sIFxcXCJpbnB1dFxcXCIpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIHZhbCA9IGVsZW0udmFsdWU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZWxlbS5zZXRBdHRyaWJ1dGUoXFxcInR5cGVcXFwiLCB2YWx1ZSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKHZhbCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGVsZW0udmFsdWUgPSB2YWw7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiB2YWx1ZTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fSk7XFxuXFxuXFx0Ly8gSG9va3MgZm9yIGJvb2xlYW4gYXR0cmlidXRlc1xcblxcdGJvb2xIb29rID0ge1xcblxcdFxcdHNldDogZnVuY3Rpb24gc2V0KGVsZW0sIHZhbHVlLCBuYW1lKSB7XFxuXFx0XFx0XFx0aWYgKHZhbHVlID09PSBmYWxzZSkge1xcblxcdFxcdFxcdFxcdC8vIFJlbW92ZSBib29sZWFuIGF0dHJpYnV0ZXMgd2hlbiBzZXQgdG8gZmFsc2VcXG5cXHRcXHRcXHRcXHRqUXVlcnkucmVtb3ZlQXR0cihlbGVtLCBuYW1lKTtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdGVsZW0uc2V0QXR0cmlidXRlKG5hbWUsIG5hbWUpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gbmFtZTtcXG5cXHRcXHR9XFxuXFx0fTtcXG5cXHRqUXVlcnkuZWFjaChqUXVlcnkuZXhwci5tYXRjaC5ib29sLnNvdXJjZS5tYXRjaCgvXFxcXHcrL2cpLCBmdW5jdGlvbiAoaSwgbmFtZSkge1xcblxcdFxcdHZhciBnZXR0ZXIgPSBhdHRySGFuZGxlW25hbWVdIHx8IGpRdWVyeS5maW5kLmF0dHI7XFxuXFxuXFx0XFx0YXR0ckhhbmRsZVtuYW1lXSA9IGZ1bmN0aW9uIChlbGVtLCBuYW1lLCBpc1hNTCkge1xcblxcdFxcdFxcdHZhciByZXQsIGhhbmRsZTtcXG5cXHRcXHRcXHRpZiAoIWlzWE1MKSB7XFxuXFx0XFx0XFx0XFx0Ly8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcCBieSB0ZW1wb3JhcmlseSByZW1vdmluZyB0aGlzIGZ1bmN0aW9uIGZyb20gdGhlIGdldHRlclxcblxcdFxcdFxcdFxcdGhhbmRsZSA9IGF0dHJIYW5kbGVbbmFtZV07XFxuXFx0XFx0XFx0XFx0YXR0ckhhbmRsZVtuYW1lXSA9IHJldDtcXG5cXHRcXHRcXHRcXHRyZXQgPSBnZXR0ZXIoZWxlbSwgbmFtZSwgaXNYTUwpICE9IG51bGwgPyBuYW1lLnRvTG93ZXJDYXNlKCkgOiBudWxsO1xcblxcdFxcdFxcdFxcdGF0dHJIYW5kbGVbbmFtZV0gPSBoYW5kbGU7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiByZXQ7XFxuXFx0XFx0fTtcXG5cXHR9KTtcXG5cXG5cXHR2YXIgcmZvY3VzYWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2k7XFxuXFxuXFx0alF1ZXJ5LmZuLmV4dGVuZCh7XFxuXFx0XFx0cHJvcDogZnVuY3Rpb24gcHJvcChuYW1lLCB2YWx1ZSkge1xcblxcdFxcdFxcdHJldHVybiBhY2Nlc3ModGhpcywgalF1ZXJ5LnByb3AsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRyZW1vdmVQcm9wOiBmdW5jdGlvbiByZW1vdmVQcm9wKG5hbWUpIHtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRkZWxldGUgdGhpc1tqUXVlcnkucHJvcEZpeFtuYW1lXSB8fCBuYW1lXTtcXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHR9XFxuXFx0fSk7XFxuXFxuXFx0alF1ZXJ5LmV4dGVuZCh7XFxuXFx0XFx0cHJvcEZpeDoge1xcblxcdFxcdFxcdFxcXCJmb3JcXFwiOiBcXFwiaHRtbEZvclxcXCIsXFxuXFx0XFx0XFx0XFxcImNsYXNzXFxcIjogXFxcImNsYXNzTmFtZVxcXCJcXG5cXHRcXHR9LFxcblxcblxcdFxcdHByb3A6IGZ1bmN0aW9uIHByb3AoZWxlbSwgbmFtZSwgdmFsdWUpIHtcXG5cXHRcXHRcXHR2YXIgcmV0LFxcblxcdFxcdFxcdCAgICBob29rcyxcXG5cXHRcXHRcXHQgICAgbm90eG1sLFxcblxcdFxcdFxcdCAgICBuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XFxuXFxuXFx0XFx0XFx0Ly8gRG9uJ3QgZ2V0L3NldCBwcm9wZXJ0aWVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xcblxcdFxcdFxcdGlmICghZWxlbSB8fCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMikge1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0bm90eG1sID0gblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyhlbGVtKTtcXG5cXG5cXHRcXHRcXHRpZiAobm90eG1sKSB7XFxuXFx0XFx0XFx0XFx0Ly8gRml4IG5hbWUgYW5kIGF0dGFjaCBob29rc1xcblxcdFxcdFxcdFxcdG5hbWUgPSBqUXVlcnkucHJvcEZpeFtuYW1lXSB8fCBuYW1lO1xcblxcdFxcdFxcdFxcdGhvb2tzID0galF1ZXJ5LnByb3BIb29rc1tuYW1lXTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gaG9va3MgJiYgXFxcInNldFxcXCIgaW4gaG9va3MgJiYgKHJldCA9IGhvb2tzLnNldChlbGVtLCB2YWx1ZSwgbmFtZSkpICE9PSB1bmRlZmluZWQgPyByZXQgOiBlbGVtW25hbWVdID0gdmFsdWU7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gaG9va3MgJiYgXFxcImdldFxcXCIgaW4gaG9va3MgJiYgKHJldCA9IGhvb2tzLmdldChlbGVtLCBuYW1lKSkgIT09IG51bGwgPyByZXQgOiBlbGVtW25hbWVdO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcblxcdFxcdHByb3BIb29rczoge1xcblxcdFxcdFxcdHRhYkluZGV4OiB7XFxuXFx0XFx0XFx0XFx0Z2V0OiBmdW5jdGlvbiBnZXQoZWxlbSkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBlbGVtLmhhc0F0dHJpYnV0ZShcXFwidGFiaW5kZXhcXFwiKSB8fCByZm9jdXNhYmxlLnRlc3QoZWxlbS5ub2RlTmFtZSkgfHwgZWxlbS5ocmVmID8gZWxlbS50YWJJbmRleCA6IC0xO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH0pO1xcblxcblxcdGlmICghc3VwcG9ydC5vcHRTZWxlY3RlZCkge1xcblxcdFxcdGpRdWVyeS5wcm9wSG9va3Muc2VsZWN0ZWQgPSB7XFxuXFx0XFx0XFx0Z2V0OiBmdW5jdGlvbiBnZXQoZWxlbSkge1xcblxcdFxcdFxcdFxcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XFxuXFx0XFx0XFx0XFx0aWYgKHBhcmVudCAmJiBwYXJlbnQucGFyZW50Tm9kZSkge1xcblxcdFxcdFxcdFxcdFxcdHBhcmVudC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHJldHVybiBudWxsO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9O1xcblxcdH1cXG5cXG5cXHRqUXVlcnkuZWFjaChbXFxcInRhYkluZGV4XFxcIiwgXFxcInJlYWRPbmx5XFxcIiwgXFxcIm1heExlbmd0aFxcXCIsIFxcXCJjZWxsU3BhY2luZ1xcXCIsIFxcXCJjZWxsUGFkZGluZ1xcXCIsIFxcXCJyb3dTcGFuXFxcIiwgXFxcImNvbFNwYW5cXFwiLCBcXFwidXNlTWFwXFxcIiwgXFxcImZyYW1lQm9yZGVyXFxcIiwgXFxcImNvbnRlbnRFZGl0YWJsZVxcXCJdLCBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0alF1ZXJ5LnByb3BGaXhbdGhpcy50b0xvd2VyQ2FzZSgpXSA9IHRoaXM7XFxuXFx0fSk7XFxuXFxuXFx0dmFyIHJjbGFzcyA9IC9bXFxcXHRcXFxcclxcXFxuXFxcXGZdL2c7XFxuXFxuXFx0alF1ZXJ5LmZuLmV4dGVuZCh7XFxuXFx0XFx0YWRkQ2xhc3M6IGZ1bmN0aW9uIGFkZENsYXNzKHZhbHVlKSB7XFxuXFx0XFx0XFx0dmFyIGNsYXNzZXMsXFxuXFx0XFx0XFx0ICAgIGVsZW0sXFxuXFx0XFx0XFx0ICAgIGN1cixcXG5cXHRcXHRcXHQgICAgY2xhenosXFxuXFx0XFx0XFx0ICAgIGosXFxuXFx0XFx0XFx0ICAgIGZpbmFsVmFsdWUsXFxuXFx0XFx0XFx0ICAgIHByb2NlZWQgPSB0eXBlb2YgdmFsdWUgPT09IFxcXCJzdHJpbmdcXFwiICYmIHZhbHVlLFxcblxcdFxcdFxcdCAgICBpID0gMCxcXG5cXHRcXHRcXHQgICAgbGVuID0gdGhpcy5sZW5ndGg7XFxuXFxuXFx0XFx0XFx0aWYgKGpRdWVyeS5pc0Z1bmN0aW9uKHZhbHVlKSkge1xcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKGopIHtcXG5cXHRcXHRcXHRcXHRcXHRqUXVlcnkodGhpcykuYWRkQ2xhc3ModmFsdWUuY2FsbCh0aGlzLCBqLCB0aGlzLmNsYXNzTmFtZSkpO1xcblxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAocHJvY2VlZCkge1xcblxcdFxcdFxcdFxcdC8vIFRoZSBkaXNqdW5jdGlvbiBoZXJlIGlzIGZvciBiZXR0ZXIgY29tcHJlc3NpYmlsaXR5IChzZWUgcmVtb3ZlQ2xhc3MpXFxuXFx0XFx0XFx0XFx0Y2xhc3NlcyA9ICh2YWx1ZSB8fCBcXFwiXFxcIikubWF0Y2gocm5vdHdoaXRlKSB8fCBbXTtcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZWxlbSA9IHRoaXNbaV07XFxuXFx0XFx0XFx0XFx0XFx0Y3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoZWxlbS5jbGFzc05hbWUgPyAoXFxcIiBcXFwiICsgZWxlbS5jbGFzc05hbWUgKyBcXFwiIFxcXCIpLnJlcGxhY2UocmNsYXNzLCBcXFwiIFxcXCIpIDogXFxcIiBcXFwiKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoY3VyKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aiA9IDA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0d2hpbGUgKGNsYXp6ID0gY2xhc3Nlc1tqKytdKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKGN1ci5pbmRleE9mKFxcXCIgXFxcIiArIGNsYXp6ICsgXFxcIiBcXFwiKSA8IDApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjdXIgKz0gY2xhenogKyBcXFwiIFxcXCI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBvbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxcblxcdFxcdFxcdFxcdFxcdFxcdGZpbmFsVmFsdWUgPSBqUXVlcnkudHJpbShjdXIpO1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChlbGVtLmNsYXNzTmFtZSAhPT0gZmluYWxWYWx1ZSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGVsZW0uY2xhc3NOYW1lID0gZmluYWxWYWx1ZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRyZW1vdmVDbGFzczogZnVuY3Rpb24gcmVtb3ZlQ2xhc3ModmFsdWUpIHtcXG5cXHRcXHRcXHR2YXIgY2xhc3NlcyxcXG5cXHRcXHRcXHQgICAgZWxlbSxcXG5cXHRcXHRcXHQgICAgY3VyLFxcblxcdFxcdFxcdCAgICBjbGF6eixcXG5cXHRcXHRcXHQgICAgaixcXG5cXHRcXHRcXHQgICAgZmluYWxWYWx1ZSxcXG5cXHRcXHRcXHQgICAgcHJvY2VlZCA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDAgfHwgdHlwZW9mIHZhbHVlID09PSBcXFwic3RyaW5nXFxcIiAmJiB2YWx1ZSxcXG5cXHRcXHRcXHQgICAgaSA9IDAsXFxuXFx0XFx0XFx0ICAgIGxlbiA9IHRoaXMubGVuZ3RoO1xcblxcblxcdFxcdFxcdGlmIChqUXVlcnkuaXNGdW5jdGlvbih2YWx1ZSkpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uIChqKSB7XFxuXFx0XFx0XFx0XFx0XFx0alF1ZXJ5KHRoaXMpLnJlbW92ZUNsYXNzKHZhbHVlLmNhbGwodGhpcywgaiwgdGhpcy5jbGFzc05hbWUpKTtcXG5cXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKHByb2NlZWQpIHtcXG5cXHRcXHRcXHRcXHRjbGFzc2VzID0gKHZhbHVlIHx8IFxcXCJcXFwiKS5tYXRjaChybm90d2hpdGUpIHx8IFtdO1xcblxcblxcdFxcdFxcdFxcdGZvciAoOyBpIDwgbGVuOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRlbGVtID0gdGhpc1tpXTtcXG5cXHRcXHRcXHRcXHRcXHQvLyBUaGlzIGV4cHJlc3Npb24gaXMgaGVyZSBmb3IgYmV0dGVyIGNvbXByZXNzaWJpbGl0eSAoc2VlIGFkZENsYXNzKVxcblxcdFxcdFxcdFxcdFxcdGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKGVsZW0uY2xhc3NOYW1lID8gKFxcXCIgXFxcIiArIGVsZW0uY2xhc3NOYW1lICsgXFxcIiBcXFwiKS5yZXBsYWNlKHJjbGFzcywgXFxcIiBcXFwiKSA6IFxcXCJcXFwiKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoY3VyKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aiA9IDA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0d2hpbGUgKGNsYXp6ID0gY2xhc3Nlc1tqKytdKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gUmVtb3ZlICphbGwqIGluc3RhbmNlc1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHdoaWxlIChjdXIuaW5kZXhPZihcXFwiIFxcXCIgKyBjbGF6eiArIFxcXCIgXFxcIikgPj0gMCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGN1ciA9IGN1ci5yZXBsYWNlKFxcXCIgXFxcIiArIGNsYXp6ICsgXFxcIiBcXFwiLCBcXFwiIFxcXCIpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gT25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cXG5cXHRcXHRcXHRcXHRcXHRcXHRmaW5hbFZhbHVlID0gdmFsdWUgPyBqUXVlcnkudHJpbShjdXIpIDogXFxcIlxcXCI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKGVsZW0uY2xhc3NOYW1lICE9PSBmaW5hbFZhbHVlKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZWxlbS5jbGFzc05hbWUgPSBmaW5hbFZhbHVlO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXHRcXHR9LFxcblxcblxcdFxcdHRvZ2dsZUNsYXNzOiBmdW5jdGlvbiB0b2dnbGVDbGFzcyh2YWx1ZSwgc3RhdGVWYWwpIHtcXG5cXHRcXHRcXHR2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZSA9PT0gXFxcInVuZGVmaW5lZFxcXCIgPyBcXFwidW5kZWZpbmVkXFxcIiA6IF90eXBlb2YodmFsdWUpO1xcblxcblxcdFxcdFxcdGlmICh0eXBlb2Ygc3RhdGVWYWwgPT09IFxcXCJib29sZWFuXFxcIiAmJiB0eXBlID09PSBcXFwic3RyaW5nXFxcIikge1xcblxcdFxcdFxcdFxcdHJldHVybiBzdGF0ZVZhbCA/IHRoaXMuYWRkQ2xhc3ModmFsdWUpIDogdGhpcy5yZW1vdmVDbGFzcyh2YWx1ZSk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmIChqUXVlcnkuaXNGdW5jdGlvbih2YWx1ZSkpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uIChpKSB7XFxuXFx0XFx0XFx0XFx0XFx0alF1ZXJ5KHRoaXMpLnRvZ2dsZUNsYXNzKHZhbHVlLmNhbGwodGhpcywgaSwgdGhpcy5jbGFzc05hbWUsIHN0YXRlVmFsKSwgc3RhdGVWYWwpO1xcblxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRpZiAodHlwZSA9PT0gXFxcInN0cmluZ1xcXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHQvLyBUb2dnbGUgaW5kaXZpZHVhbCBjbGFzcyBuYW1lc1xcblxcdFxcdFxcdFxcdFxcdHZhciBjbGFzc05hbWUsXFxuXFx0XFx0XFx0XFx0XFx0ICAgIGkgPSAwLFxcblxcdFxcdFxcdFxcdFxcdCAgICBzZWxmID0galF1ZXJ5KHRoaXMpLFxcblxcdFxcdFxcdFxcdFxcdCAgICBjbGFzc05hbWVzID0gdmFsdWUubWF0Y2gocm5vdHdoaXRlKSB8fCBbXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR3aGlsZSAoY2xhc3NOYW1lID0gY2xhc3NOYW1lc1tpKytdKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gQ2hlY2sgZWFjaCBjbGFzc05hbWUgZ2l2ZW4sIHNwYWNlIHNlcGFyYXRlZCBsaXN0XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKHNlbGYuaGFzQ2xhc3MoY2xhc3NOYW1lKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHNlbGYucmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHNlbGYuYWRkQ2xhc3MoY2xhc3NOYW1lKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdC8vIFRvZ2dsZSB3aG9sZSBjbGFzcyBuYW1lXFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmICh0eXBlID09PSBzdHJ1bmRlZmluZWQgfHwgdHlwZSA9PT0gXFxcImJvb2xlYW5cXFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHRoaXMuY2xhc3NOYW1lKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gc3RvcmUgY2xhc3NOYW1lIGlmIHNldFxcblxcdFxcdFxcdFxcdFxcdFxcdGRhdGFfcHJpdi5zZXQodGhpcywgXFxcIl9fY2xhc3NOYW1lX19cXFwiLCB0aGlzLmNsYXNzTmFtZSk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdC8vIElmIHRoZSBlbGVtZW50IGhhcyBhIGNsYXNzIG5hbWUgb3IgaWYgd2UncmUgcGFzc2VkIGBmYWxzZWAsXFxuXFx0XFx0XFx0XFx0XFx0Ly8gdGhlbiByZW1vdmUgdGhlIHdob2xlIGNsYXNzbmFtZSAoaWYgdGhlcmUgd2FzIG9uZSwgdGhlIGFib3ZlIHNhdmVkIGl0KS5cXG5cXHRcXHRcXHRcXHRcXHQvLyBPdGhlcndpc2UgYnJpbmcgYmFjayB3aGF0ZXZlciB3YXMgcHJldmlvdXNseSBzYXZlZCAoaWYgYW55dGhpbmcpLFxcblxcdFxcdFxcdFxcdFxcdC8vIGZhbGxpbmcgYmFjayB0byB0aGUgZW1wdHkgc3RyaW5nIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmNsYXNzTmFtZSA9IHRoaXMuY2xhc3NOYW1lIHx8IHZhbHVlID09PSBmYWxzZSA/IFxcXCJcXFwiIDogZGF0YV9wcml2LmdldCh0aGlzLCBcXFwiX19jbGFzc05hbWVfX1xcXCIpIHx8IFxcXCJcXFwiO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdGhhc0NsYXNzOiBmdW5jdGlvbiBoYXNDbGFzcyhzZWxlY3Rvcikge1xcblxcdFxcdFxcdHZhciBjbGFzc05hbWUgPSBcXFwiIFxcXCIgKyBzZWxlY3RvciArIFxcXCIgXFxcIixcXG5cXHRcXHRcXHQgICAgaSA9IDAsXFxuXFx0XFx0XFx0ICAgIGwgPSB0aGlzLmxlbmd0aDtcXG5cXHRcXHRcXHRmb3IgKDsgaSA8IGw7IGkrKykge1xcblxcdFxcdFxcdFxcdGlmICh0aGlzW2ldLm5vZGVUeXBlID09PSAxICYmIChcXFwiIFxcXCIgKyB0aGlzW2ldLmNsYXNzTmFtZSArIFxcXCIgXFxcIikucmVwbGFjZShyY2xhc3MsIFxcXCIgXFxcIikuaW5kZXhPZihjbGFzc05hbWUpID49IDApIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHR9XFxuXFx0fSk7XFxuXFxuXFx0dmFyIHJyZXR1cm4gPSAvXFxcXHIvZztcXG5cXG5cXHRqUXVlcnkuZm4uZXh0ZW5kKHtcXG5cXHRcXHR2YWw6IGZ1bmN0aW9uIHZhbCh2YWx1ZSkge1xcblxcdFxcdFxcdHZhciBob29rcyxcXG5cXHRcXHRcXHQgICAgcmV0LFxcblxcdFxcdFxcdCAgICBpc0Z1bmN0aW9uLFxcblxcdFxcdFxcdCAgICBlbGVtID0gdGhpc1swXTtcXG5cXG5cXHRcXHRcXHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZWxlbSkge1xcblxcdFxcdFxcdFxcdFxcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzW2VsZW0udHlwZV0gfHwgalF1ZXJ5LnZhbEhvb2tzW2VsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKV07XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKGhvb2tzICYmIFxcXCJnZXRcXFwiIGluIGhvb2tzICYmIChyZXQgPSBob29rcy5nZXQoZWxlbSwgXFxcInZhbHVlXFxcIikpICE9PSB1bmRlZmluZWQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gcmV0O1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRyZXQgPSBlbGVtLnZhbHVlO1xcblxcblxcdFxcdFxcdFxcdFxcdHJldHVybiB0eXBlb2YgcmV0ID09PSBcXFwic3RyaW5nXFxcIiA/XFxuXFx0XFx0XFx0XFx0XFx0Ly8gSGFuZGxlIG1vc3QgY29tbW9uIHN0cmluZyBjYXNlc1xcblxcdFxcdFxcdFxcdFxcdHJldC5yZXBsYWNlKHJyZXR1cm4sIFxcXCJcXFwiKSA6XFxuXFx0XFx0XFx0XFx0XFx0Ly8gSGFuZGxlIGNhc2VzIHdoZXJlIHZhbHVlIGlzIG51bGwvdW5kZWYgb3IgbnVtYmVyXFxuXFx0XFx0XFx0XFx0XFx0cmV0ID09IG51bGwgPyBcXFwiXFxcIiA6IHJldDtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpc0Z1bmN0aW9uID0galF1ZXJ5LmlzRnVuY3Rpb24odmFsdWUpO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKGkpIHtcXG5cXHRcXHRcXHRcXHR2YXIgdmFsO1xcblxcblxcdFxcdFxcdFxcdGlmICh0aGlzLm5vZGVUeXBlICE9PSAxKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAoaXNGdW5jdGlvbikge1xcblxcdFxcdFxcdFxcdFxcdHZhbCA9IHZhbHVlLmNhbGwodGhpcywgaSwgalF1ZXJ5KHRoaXMpLnZhbCgpKTtcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdHZhbCA9IHZhbHVlO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBUcmVhdCBudWxsL3VuZGVmaW5lZCBhcyBcXFwiXFxcIjsgY29udmVydCBudW1iZXJzIHRvIHN0cmluZ1xcblxcdFxcdFxcdFxcdGlmICh2YWwgPT0gbnVsbCkge1xcblxcdFxcdFxcdFxcdFxcdHZhbCA9IFxcXCJcXFwiO1xcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gXFxcIm51bWJlclxcXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHR2YWwgKz0gXFxcIlxcXCI7XFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmIChqUXVlcnkuaXNBcnJheSh2YWwpKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFsID0galF1ZXJ5Lm1hcCh2YWwsIGZ1bmN0aW9uICh2YWx1ZSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiB2YWx1ZSA9PSBudWxsID8gXFxcIlxcXCIgOiB2YWx1ZSArIFxcXCJcXFwiO1xcblxcdFxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRob29rcyA9IGpRdWVyeS52YWxIb29rc1t0aGlzLnR5cGVdIHx8IGpRdWVyeS52YWxIb29rc1t0aGlzLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCldO1xcblxcblxcdFxcdFxcdFxcdC8vIElmIHNldCByZXR1cm5zIHVuZGVmaW5lZCwgZmFsbCBiYWNrIHRvIG5vcm1hbCBzZXR0aW5nXFxuXFx0XFx0XFx0XFx0aWYgKCFob29rcyB8fCAhKFxcXCJzZXRcXFwiIGluIGhvb2tzKSB8fCBob29rcy5zZXQodGhpcywgdmFsLCBcXFwidmFsdWVcXFwiKSA9PT0gdW5kZWZpbmVkKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy52YWx1ZSA9IHZhbDtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0fVxcblxcdH0pO1xcblxcblxcdGpRdWVyeS5leHRlbmQoe1xcblxcdFxcdHZhbEhvb2tzOiB7XFxuXFx0XFx0XFx0b3B0aW9uOiB7XFxuXFx0XFx0XFx0XFx0Z2V0OiBmdW5jdGlvbiBnZXQoZWxlbSkge1xcblxcdFxcdFxcdFxcdFxcdHZhciB2YWwgPSBqUXVlcnkuZmluZC5hdHRyKGVsZW0sIFxcXCJ2YWx1ZVxcXCIpO1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiB2YWwgIT0gbnVsbCA/IHZhbCA6XFxuXFx0XFx0XFx0XFx0XFx0Ly8gU3VwcG9ydDogSUUxMC0xMStcXG5cXHRcXHRcXHRcXHRcXHQvLyBvcHRpb24udGV4dCB0aHJvd3MgZXhjZXB0aW9ucyAoIzE0Njg2LCAjMTQ4NTgpXFxuXFx0XFx0XFx0XFx0XFx0alF1ZXJ5LnRyaW0oalF1ZXJ5LnRleHQoZWxlbSkpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdHNlbGVjdDoge1xcblxcdFxcdFxcdFxcdGdldDogZnVuY3Rpb24gZ2V0KGVsZW0pIHtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgdmFsdWUsXFxuXFx0XFx0XFx0XFx0XFx0ICAgIG9wdGlvbixcXG5cXHRcXHRcXHRcXHRcXHQgICAgb3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcXG5cXHRcXHRcXHRcXHRcXHQgICAgaW5kZXggPSBlbGVtLnNlbGVjdGVkSW5kZXgsXFxuXFx0XFx0XFx0XFx0XFx0ICAgIG9uZSA9IGVsZW0udHlwZSA9PT0gXFxcInNlbGVjdC1vbmVcXFwiIHx8IGluZGV4IDwgMCxcXG5cXHRcXHRcXHRcXHRcXHQgICAgdmFsdWVzID0gb25lID8gbnVsbCA6IFtdLFxcblxcdFxcdFxcdFxcdFxcdCAgICBtYXggPSBvbmUgPyBpbmRleCArIDEgOiBvcHRpb25zLmxlbmd0aCxcXG5cXHRcXHRcXHRcXHRcXHQgICAgaSA9IGluZGV4IDwgMCA/IG1heCA6IG9uZSA/IGluZGV4IDogMDtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBMb29wIHRocm91Z2ggYWxsIHRoZSBzZWxlY3RlZCBvcHRpb25zXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICg7IGkgPCBtYXg7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdFxcdG9wdGlvbiA9IG9wdGlvbnNbaV07XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gSUU2LTkgZG9lc24ndCB1cGRhdGUgc2VsZWN0ZWQgYWZ0ZXIgZm9ybSByZXNldCAoIzI1NTEpXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKChvcHRpb24uc2VsZWN0ZWQgfHwgaSA9PT0gaW5kZXgpICYmIChcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBEb24ndCByZXR1cm4gb3B0aW9ucyB0aGF0IGFyZSBkaXNhYmxlZCBvciBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXFxuXFx0XFx0XFx0XFx0XFx0XFx0c3VwcG9ydC5vcHREaXNhYmxlZCA/ICFvcHRpb24uZGlzYWJsZWQgOiBvcHRpb24uZ2V0QXR0cmlidXRlKFxcXCJkaXNhYmxlZFxcXCIpID09PSBudWxsKSAmJiAoIW9wdGlvbi5wYXJlbnROb2RlLmRpc2FibGVkIHx8ICFqUXVlcnkubm9kZU5hbWUob3B0aW9uLnBhcmVudE5vZGUsIFxcXCJvcHRncm91cFxcXCIpKSkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIEdldCB0aGUgc3BlY2lmaWMgdmFsdWUgZm9yIHRoZSBvcHRpb25cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YWx1ZSA9IGpRdWVyeShvcHRpb24pLnZhbCgpO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIFdlIGRvbid0IG5lZWQgYW4gYXJyYXkgZm9yIG9uZSBzZWxlY3RzXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKG9uZSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiB2YWx1ZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gTXVsdGktU2VsZWN0cyByZXR1cm4gYW4gYXJyYXlcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YWx1ZXMucHVzaCh2YWx1ZSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdmFsdWVzO1xcblxcdFxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0XFx0c2V0OiBmdW5jdGlvbiBzZXQoZWxlbSwgdmFsdWUpIHtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgb3B0aW9uU2V0LFxcblxcdFxcdFxcdFxcdFxcdCAgICBvcHRpb24sXFxuXFx0XFx0XFx0XFx0XFx0ICAgIG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXFxuXFx0XFx0XFx0XFx0XFx0ICAgIHZhbHVlcyA9IGpRdWVyeS5tYWtlQXJyYXkodmFsdWUpLFxcblxcdFxcdFxcdFxcdFxcdCAgICBpID0gb3B0aW9ucy5sZW5ndGg7XFxuXFxuXFx0XFx0XFx0XFx0XFx0d2hpbGUgKGktLSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdG9wdGlvbiA9IG9wdGlvbnNbaV07XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKG9wdGlvbi5zZWxlY3RlZCA9IGpRdWVyeS5pbkFycmF5KG9wdGlvbi52YWx1ZSwgdmFsdWVzKSA+PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0b3B0aW9uU2V0ID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdC8vIEZvcmNlIGJyb3dzZXJzIHRvIGJlaGF2ZSBjb25zaXN0ZW50bHkgd2hlbiBub24tbWF0Y2hpbmcgdmFsdWUgaXMgc2V0XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCFvcHRpb25TZXQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRlbGVtLnNlbGVjdGVkSW5kZXggPSAtMTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHZhbHVlcztcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9KTtcXG5cXG5cXHQvLyBSYWRpb3MgYW5kIGNoZWNrYm94ZXMgZ2V0dGVyL3NldHRlclxcblxcdGpRdWVyeS5lYWNoKFtcXFwicmFkaW9cXFwiLCBcXFwiY2hlY2tib3hcXFwiXSwgZnVuY3Rpb24gKCkge1xcblxcdFxcdGpRdWVyeS52YWxIb29rc1t0aGlzXSA9IHtcXG5cXHRcXHRcXHRzZXQ6IGZ1bmN0aW9uIHNldChlbGVtLCB2YWx1ZSkge1xcblxcdFxcdFxcdFxcdGlmIChqUXVlcnkuaXNBcnJheSh2YWx1ZSkpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gZWxlbS5jaGVja2VkID0galF1ZXJ5LmluQXJyYXkoalF1ZXJ5KGVsZW0pLnZhbCgpLCB2YWx1ZSkgPj0gMDtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH07XFxuXFx0XFx0aWYgKCFzdXBwb3J0LmNoZWNrT24pIHtcXG5cXHRcXHRcXHRqUXVlcnkudmFsSG9va3NbdGhpc10uZ2V0ID0gZnVuY3Rpb24gKGVsZW0pIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoXFxcInZhbHVlXFxcIikgPT09IG51bGwgPyBcXFwib25cXFwiIDogZWxlbS52YWx1ZTtcXG5cXHRcXHRcXHR9O1xcblxcdFxcdH1cXG5cXHR9KTtcXG5cXG5cXHQvLyBSZXR1cm4galF1ZXJ5IGZvciBhdHRyaWJ1dGVzLW9ubHkgaW5jbHVzaW9uXFxuXFxuXFxuXFx0alF1ZXJ5LmVhY2goKFxcXCJibHVyIGZvY3VzIGZvY3VzaW4gZm9jdXNvdXQgbG9hZCByZXNpemUgc2Nyb2xsIHVubG9hZCBjbGljayBkYmxjbGljayBcXFwiICsgXFxcIm1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIFxcXCIgKyBcXFwiY2hhbmdlIHNlbGVjdCBzdWJtaXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBlcnJvciBjb250ZXh0bWVudVxcXCIpLnNwbGl0KFxcXCIgXFxcIiksIGZ1bmN0aW9uIChpLCBuYW1lKSB7XFxuXFxuXFx0XFx0Ly8gSGFuZGxlIGV2ZW50IGJpbmRpbmdcXG5cXHRcXHRqUXVlcnkuZm5bbmFtZV0gPSBmdW5jdGlvbiAoZGF0YSwgZm4pIHtcXG5cXHRcXHRcXHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDAgPyB0aGlzLm9uKG5hbWUsIG51bGwsIGRhdGEsIGZuKSA6IHRoaXMudHJpZ2dlcihuYW1lKTtcXG5cXHRcXHR9O1xcblxcdH0pO1xcblxcblxcdGpRdWVyeS5mbi5leHRlbmQoe1xcblxcdFxcdGhvdmVyOiBmdW5jdGlvbiBob3Zlcihmbk92ZXIsIGZuT3V0KSB7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMubW91c2VlbnRlcihmbk92ZXIpLm1vdXNlbGVhdmUoZm5PdXQgfHwgZm5PdmVyKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdGJpbmQ6IGZ1bmN0aW9uIGJpbmQodHlwZXMsIGRhdGEsIGZuKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMub24odHlwZXMsIG51bGwsIGRhdGEsIGZuKTtcXG5cXHRcXHR9LFxcblxcdFxcdHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKHR5cGVzLCBmbikge1xcblxcdFxcdFxcdHJldHVybiB0aGlzLm9mZih0eXBlcywgbnVsbCwgZm4pO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZGVsZWdhdGU6IGZ1bmN0aW9uIGRlbGVnYXRlKHNlbGVjdG9yLCB0eXBlcywgZGF0YSwgZm4pIHtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5vbih0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuKTtcXG5cXHRcXHR9LFxcblxcdFxcdHVuZGVsZWdhdGU6IGZ1bmN0aW9uIHVuZGVsZWdhdGUoc2VsZWN0b3IsIHR5cGVzLCBmbikge1xcblxcdFxcdFxcdC8vICggbmFtZXNwYWNlICkgb3IgKCBzZWxlY3RvciwgdHlwZXMgWywgZm5dIClcXG5cXHRcXHRcXHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IHRoaXMub2ZmKHNlbGVjdG9yLCBcXFwiKipcXFwiKSA6IHRoaXMub2ZmKHR5cGVzLCBzZWxlY3RvciB8fCBcXFwiKipcXFwiLCBmbik7XFxuXFx0XFx0fVxcblxcdH0pO1xcblxcblxcdHZhciBub25jZSA9IGpRdWVyeS5ub3coKTtcXG5cXG5cXHR2YXIgcnF1ZXJ5ID0gL1xcXFw/LztcXG5cXG5cXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDIuM1xcblxcdC8vIFdvcmthcm91bmQgZmFpbHVyZSB0byBzdHJpbmctY2FzdCBudWxsIGlucHV0XFxuXFx0alF1ZXJ5LnBhcnNlSlNPTiA9IGZ1bmN0aW9uIChkYXRhKSB7XFxuXFx0XFx0cmV0dXJuIEpTT04ucGFyc2UoZGF0YSArIFxcXCJcXFwiKTtcXG5cXHR9O1xcblxcblxcdC8vIENyb3NzLWJyb3dzZXIgeG1sIHBhcnNpbmdcXG5cXHRqUXVlcnkucGFyc2VYTUwgPSBmdW5jdGlvbiAoZGF0YSkge1xcblxcdFxcdHZhciB4bWwsIHRtcDtcXG5cXHRcXHRpZiAoIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09IFxcXCJzdHJpbmdcXFwiKSB7XFxuXFx0XFx0XFx0cmV0dXJuIG51bGw7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFN1cHBvcnQ6IElFOVxcblxcdFxcdHRyeSB7XFxuXFx0XFx0XFx0dG1wID0gbmV3IERPTVBhcnNlcigpO1xcblxcdFxcdFxcdHhtbCA9IHRtcC5wYXJzZUZyb21TdHJpbmcoZGF0YSwgXFxcInRleHQveG1sXFxcIik7XFxuXFx0XFx0fSBjYXRjaCAoZSkge1xcblxcdFxcdFxcdHhtbCA9IHVuZGVmaW5lZDtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCF4bWwgfHwgeG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFxcXCJwYXJzZXJlcnJvclxcXCIpLmxlbmd0aCkge1xcblxcdFxcdFxcdGpRdWVyeS5lcnJvcihcXFwiSW52YWxpZCBYTUw6IFxcXCIgKyBkYXRhKTtcXG5cXHRcXHR9XFxuXFx0XFx0cmV0dXJuIHhtbDtcXG5cXHR9O1xcblxcblxcdHZhciByaGFzaCA9IC8jLiokLyxcXG5cXHQgICAgcnRzID0gLyhbPyZdKV89W14mXSovLFxcblxcdCAgICByaGVhZGVycyA9IC9eKC4qPyk6WyBcXFxcdF0qKFteXFxcXHJcXFxcbl0qKSQvbWcsXFxuXFxuXFx0Ly8gIzc2NTMsICM4MTI1LCAjODE1MjogbG9jYWwgcHJvdG9jb2wgZGV0ZWN0aW9uXFxuXFx0cmxvY2FsUHJvdG9jb2wgPSAvXig/OmFib3V0fGFwcHxhcHAtc3RvcmFnZXwuKy1leHRlbnNpb258ZmlsZXxyZXN8d2lkZ2V0KTokLyxcXG5cXHQgICAgcm5vQ29udGVudCA9IC9eKD86R0VUfEhFQUQpJC8sXFxuXFx0ICAgIHJwcm90b2NvbCA9IC9eXFxcXC9cXFxcLy8sXFxuXFx0ICAgIHJ1cmwgPSAvXihbXFxcXHcuKy1dKzopKD86XFxcXC9cXFxcLyg/OlteXFxcXC8/I10qQHwpKFteXFxcXC8/IzpdKikoPzo6KFxcXFxkKyl8KXwpLyxcXG5cXG5cXG5cXHQvKiBQcmVmaWx0ZXJzXFxuICAqIDEpIFRoZXkgYXJlIHVzZWZ1bCB0byBpbnRyb2R1Y2UgY3VzdG9tIGRhdGFUeXBlcyAoc2VlIGFqYXgvanNvbnAuanMgZm9yIGFuIGV4YW1wbGUpXFxuICAqIDIpIFRoZXNlIGFyZSBjYWxsZWQ6XFxuICAqICAgIC0gQkVGT1JFIGFza2luZyBmb3IgYSB0cmFuc3BvcnRcXG4gICogICAgLSBBRlRFUiBwYXJhbSBzZXJpYWxpemF0aW9uIChzLmRhdGEgaXMgYSBzdHJpbmcgaWYgcy5wcm9jZXNzRGF0YSBpcyB0cnVlKVxcbiAgKiAzKSBrZXkgaXMgdGhlIGRhdGFUeXBlXFxuICAqIDQpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXFxcIipcXFwiIGNhbiBiZSB1c2VkXFxuICAqIDUpIGV4ZWN1dGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGNvbnRpbnVlIGRvd24gdG8gXFxcIipcXFwiIGlmIG5lZWRlZFxcbiAgKi9cXG5cXHRwcmVmaWx0ZXJzID0ge30sXFxuXFxuXFxuXFx0LyogVHJhbnNwb3J0cyBiaW5kaW5nc1xcbiAgKiAxKSBrZXkgaXMgdGhlIGRhdGFUeXBlXFxuICAqIDIpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXFxcIipcXFwiIGNhbiBiZSB1c2VkXFxuICAqIDMpIHNlbGVjdGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGdvIHRvIFxcXCIqXFxcIiBpZiBuZWVkZWRcXG4gICovXFxuXFx0dHJhbnNwb3J0cyA9IHt9LFxcblxcblxcblxcdC8vIEF2b2lkIGNvbW1lbnQtcHJvbG9nIGNoYXIgc2VxdWVuY2UgKCMxMDA5OCk7IG11c3QgYXBwZWFzZSBsaW50IGFuZCBldmFkZSBjb21wcmVzc2lvblxcblxcdGFsbFR5cGVzID0gXFxcIiovXFxcIi5jb25jYXQoXFxcIipcXFwiKSxcXG5cXG5cXG5cXHQvLyBEb2N1bWVudCBsb2NhdGlvblxcblxcdGFqYXhMb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmLFxcblxcblxcblxcdC8vIFNlZ21lbnQgbG9jYXRpb24gaW50byBwYXJ0c1xcblxcdGFqYXhMb2NQYXJ0cyA9IHJ1cmwuZXhlYyhhamF4TG9jYXRpb24udG9Mb3dlckNhc2UoKSkgfHwgW107XFxuXFxuXFx0Ly8gQmFzZSBcXFwiY29uc3RydWN0b3JcXFwiIGZvciBqUXVlcnkuYWpheFByZWZpbHRlciBhbmQgalF1ZXJ5LmFqYXhUcmFuc3BvcnRcXG5cXHRmdW5jdGlvbiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoc3RydWN0dXJlKSB7XFxuXFxuXFx0XFx0Ly8gZGF0YVR5cGVFeHByZXNzaW9uIGlzIG9wdGlvbmFsIGFuZCBkZWZhdWx0cyB0byBcXFwiKlxcXCJcXG5cXHRcXHRyZXR1cm4gZnVuY3Rpb24gKGRhdGFUeXBlRXhwcmVzc2lvbiwgZnVuYykge1xcblxcblxcdFxcdFxcdGlmICh0eXBlb2YgZGF0YVR5cGVFeHByZXNzaW9uICE9PSBcXFwic3RyaW5nXFxcIikge1xcblxcdFxcdFxcdFxcdGZ1bmMgPSBkYXRhVHlwZUV4cHJlc3Npb247XFxuXFx0XFx0XFx0XFx0ZGF0YVR5cGVFeHByZXNzaW9uID0gXFxcIipcXFwiO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2YXIgZGF0YVR5cGUsXFxuXFx0XFx0XFx0ICAgIGkgPSAwLFxcblxcdFxcdFxcdCAgICBkYXRhVHlwZXMgPSBkYXRhVHlwZUV4cHJlc3Npb24udG9Mb3dlckNhc2UoKS5tYXRjaChybm90d2hpdGUpIHx8IFtdO1xcblxcblxcdFxcdFxcdGlmIChqUXVlcnkuaXNGdW5jdGlvbihmdW5jKSkge1xcblxcdFxcdFxcdFxcdC8vIEZvciBlYWNoIGRhdGFUeXBlIGluIHRoZSBkYXRhVHlwZUV4cHJlc3Npb25cXG5cXHRcXHRcXHRcXHR3aGlsZSAoZGF0YVR5cGUgPSBkYXRhVHlwZXNbaSsrXSkge1xcblxcdFxcdFxcdFxcdFxcdC8vIFByZXBlbmQgaWYgcmVxdWVzdGVkXFxuXFx0XFx0XFx0XFx0XFx0aWYgKGRhdGFUeXBlWzBdID09PSBcXFwiK1xcXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRkYXRhVHlwZSA9IGRhdGFUeXBlLnNsaWNlKDEpIHx8IFxcXCIqXFxcIjtcXG5cXHRcXHRcXHRcXHRcXHRcXHQoc3RydWN0dXJlW2RhdGFUeXBlXSA9IHN0cnVjdHVyZVtkYXRhVHlwZV0gfHwgW10pLnVuc2hpZnQoZnVuYyk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gT3RoZXJ3aXNlIGFwcGVuZFxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0KHN0cnVjdHVyZVtkYXRhVHlwZV0gPSBzdHJ1Y3R1cmVbZGF0YVR5cGVdIHx8IFtdKS5wdXNoKGZ1bmMpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH07XFxuXFx0fVxcblxcblxcdC8vIEJhc2UgaW5zcGVjdGlvbiBmdW5jdGlvbiBmb3IgcHJlZmlsdGVycyBhbmQgdHJhbnNwb3J0c1xcblxcdGZ1bmN0aW9uIGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKHN0cnVjdHVyZSwgb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUikge1xcblxcblxcdFxcdHZhciBpbnNwZWN0ZWQgPSB7fSxcXG5cXHRcXHQgICAgc2Vla2luZ1RyYW5zcG9ydCA9IHN0cnVjdHVyZSA9PT0gdHJhbnNwb3J0cztcXG5cXG5cXHRcXHRmdW5jdGlvbiBpbnNwZWN0KGRhdGFUeXBlKSB7XFxuXFx0XFx0XFx0dmFyIHNlbGVjdGVkO1xcblxcdFxcdFxcdGluc3BlY3RlZFtkYXRhVHlwZV0gPSB0cnVlO1xcblxcdFxcdFxcdGpRdWVyeS5lYWNoKHN0cnVjdHVyZVtkYXRhVHlwZV0gfHwgW10sIGZ1bmN0aW9uIChfLCBwcmVmaWx0ZXJPckZhY3RvcnkpIHtcXG5cXHRcXHRcXHRcXHR2YXIgZGF0YVR5cGVPclRyYW5zcG9ydCA9IHByZWZpbHRlck9yRmFjdG9yeShvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSKTtcXG5cXHRcXHRcXHRcXHRpZiAodHlwZW9mIGRhdGFUeXBlT3JUcmFuc3BvcnQgPT09IFxcXCJzdHJpbmdcXFwiICYmICFzZWVraW5nVHJhbnNwb3J0ICYmICFpbnNwZWN0ZWRbZGF0YVR5cGVPclRyYW5zcG9ydF0pIHtcXG5cXHRcXHRcXHRcXHRcXHRvcHRpb25zLmRhdGFUeXBlcy51bnNoaWZ0KGRhdGFUeXBlT3JUcmFuc3BvcnQpO1xcblxcdFxcdFxcdFxcdFxcdGluc3BlY3QoZGF0YVR5cGVPclRyYW5zcG9ydCk7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoc2Vla2luZ1RyYW5zcG9ydCkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiAhKHNlbGVjdGVkID0gZGF0YVR5cGVPclRyYW5zcG9ydCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdHJldHVybiBzZWxlY3RlZDtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIGluc3BlY3Qob3B0aW9ucy5kYXRhVHlwZXNbMF0pIHx8ICFpbnNwZWN0ZWRbXFxcIipcXFwiXSAmJiBpbnNwZWN0KFxcXCIqXFxcIik7XFxuXFx0fVxcblxcblxcdC8vIEEgc3BlY2lhbCBleHRlbmQgZm9yIGFqYXggb3B0aW9uc1xcblxcdC8vIHRoYXQgdGFrZXMgXFxcImZsYXRcXFwiIG9wdGlvbnMgKG5vdCB0byBiZSBkZWVwIGV4dGVuZGVkKVxcblxcdC8vIEZpeGVzICM5ODg3XFxuXFx0ZnVuY3Rpb24gYWpheEV4dGVuZCh0YXJnZXQsIHNyYykge1xcblxcdFxcdHZhciBrZXksXFxuXFx0XFx0ICAgIGRlZXAsXFxuXFx0XFx0ICAgIGZsYXRPcHRpb25zID0galF1ZXJ5LmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9ucyB8fCB7fTtcXG5cXG5cXHRcXHRmb3IgKGtleSBpbiBzcmMpIHtcXG5cXHRcXHRcXHRpZiAoc3JjW2tleV0gIT09IHVuZGVmaW5lZCkge1xcblxcdFxcdFxcdFxcdChmbGF0T3B0aW9uc1trZXldID8gdGFyZ2V0IDogZGVlcCB8fCAoZGVlcCA9IHt9KSlba2V5XSA9IHNyY1trZXldO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0XFx0aWYgKGRlZXApIHtcXG5cXHRcXHRcXHRqUXVlcnkuZXh0ZW5kKHRydWUsIHRhcmdldCwgZGVlcCk7XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiB0YXJnZXQ7XFxuXFx0fVxcblxcblxcdC8qIEhhbmRsZXMgcmVzcG9uc2VzIHRvIGFuIGFqYXggcmVxdWVzdDpcXG4gICogLSBmaW5kcyB0aGUgcmlnaHQgZGF0YVR5cGUgKG1lZGlhdGVzIGJldHdlZW4gY29udGVudC10eXBlIGFuZCBleHBlY3RlZCBkYXRhVHlwZSlcXG4gICogLSByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXFxuICAqL1xcblxcdGZ1bmN0aW9uIGFqYXhIYW5kbGVSZXNwb25zZXMocywganFYSFIsIHJlc3BvbnNlcykge1xcblxcblxcdFxcdHZhciBjdCxcXG5cXHRcXHQgICAgdHlwZSxcXG5cXHRcXHQgICAgZmluYWxEYXRhVHlwZSxcXG5cXHRcXHQgICAgZmlyc3REYXRhVHlwZSxcXG5cXHRcXHQgICAgY29udGVudHMgPSBzLmNvbnRlbnRzLFxcblxcdFxcdCAgICBkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcztcXG5cXG5cXHRcXHQvLyBSZW1vdmUgYXV0byBkYXRhVHlwZSBhbmQgZ2V0IGNvbnRlbnQtdHlwZSBpbiB0aGUgcHJvY2Vzc1xcblxcdFxcdHdoaWxlIChkYXRhVHlwZXNbMF0gPT09IFxcXCIqXFxcIikge1xcblxcdFxcdFxcdGRhdGFUeXBlcy5zaGlmdCgpO1xcblxcdFxcdFxcdGlmIChjdCA9PT0gdW5kZWZpbmVkKSB7XFxuXFx0XFx0XFx0XFx0Y3QgPSBzLm1pbWVUeXBlIHx8IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKFxcXCJDb250ZW50LVR5cGVcXFwiKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIENoZWNrIGlmIHdlJ3JlIGRlYWxpbmcgd2l0aCBhIGtub3duIGNvbnRlbnQtdHlwZVxcblxcdFxcdGlmIChjdCkge1xcblxcdFxcdFxcdGZvciAodHlwZSBpbiBjb250ZW50cykge1xcblxcdFxcdFxcdFxcdGlmIChjb250ZW50c1t0eXBlXSAmJiBjb250ZW50c1t0eXBlXS50ZXN0KGN0KSkge1xcblxcdFxcdFxcdFxcdFxcdGRhdGFUeXBlcy51bnNoaWZ0KHR5cGUpO1xcblxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGEgcmVzcG9uc2UgZm9yIHRoZSBleHBlY3RlZCBkYXRhVHlwZVxcblxcdFxcdGlmIChkYXRhVHlwZXNbMF0gaW4gcmVzcG9uc2VzKSB7XFxuXFx0XFx0XFx0ZmluYWxEYXRhVHlwZSA9IGRhdGFUeXBlc1swXTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdC8vIFRyeSBjb252ZXJ0aWJsZSBkYXRhVHlwZXNcXG5cXHRcXHRcXHRmb3IgKHR5cGUgaW4gcmVzcG9uc2VzKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCFkYXRhVHlwZXNbMF0gfHwgcy5jb252ZXJ0ZXJzW3R5cGUgKyBcXFwiIFxcXCIgKyBkYXRhVHlwZXNbMF1dKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZmluYWxEYXRhVHlwZSA9IHR5cGU7XFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGlmICghZmlyc3REYXRhVHlwZSkge1xcblxcdFxcdFxcdFxcdFxcdGZpcnN0RGF0YVR5cGUgPSB0eXBlO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0Ly8gT3IganVzdCB1c2UgZmlyc3Qgb25lXFxuXFx0XFx0XFx0ZmluYWxEYXRhVHlwZSA9IGZpbmFsRGF0YVR5cGUgfHwgZmlyc3REYXRhVHlwZTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gSWYgd2UgZm91bmQgYSBkYXRhVHlwZVxcblxcdFxcdC8vIFdlIGFkZCB0aGUgZGF0YVR5cGUgdG8gdGhlIGxpc3QgaWYgbmVlZGVkXFxuXFx0XFx0Ly8gYW5kIHJldHVybiB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxcblxcdFxcdGlmIChmaW5hbERhdGFUeXBlKSB7XFxuXFx0XFx0XFx0aWYgKGZpbmFsRGF0YVR5cGUgIT09IGRhdGFUeXBlc1swXSkge1xcblxcdFxcdFxcdFxcdGRhdGFUeXBlcy51bnNoaWZ0KGZpbmFsRGF0YVR5cGUpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gcmVzcG9uc2VzW2ZpbmFsRGF0YVR5cGVdO1xcblxcdFxcdH1cXG5cXHR9XFxuXFxuXFx0LyogQ2hhaW4gY29udmVyc2lvbnMgZ2l2ZW4gdGhlIHJlcXVlc3QgYW5kIHRoZSBvcmlnaW5hbCByZXNwb25zZVxcbiAgKiBBbHNvIHNldHMgdGhlIHJlc3BvbnNlWFhYIGZpZWxkcyBvbiB0aGUganFYSFIgaW5zdGFuY2VcXG4gICovXFxuXFx0ZnVuY3Rpb24gYWpheENvbnZlcnQocywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MpIHtcXG5cXHRcXHR2YXIgY29udjIsXFxuXFx0XFx0ICAgIGN1cnJlbnQsXFxuXFx0XFx0ICAgIGNvbnYsXFxuXFx0XFx0ICAgIHRtcCxcXG5cXHRcXHQgICAgcHJldixcXG5cXHRcXHQgICAgY29udmVydGVycyA9IHt9LFxcblxcblxcdFxcdC8vIFdvcmsgd2l0aCBhIGNvcHkgb2YgZGF0YVR5cGVzIGluIGNhc2Ugd2UgbmVlZCB0byBtb2RpZnkgaXQgZm9yIGNvbnZlcnNpb25cXG5cXHRcXHRkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcy5zbGljZSgpO1xcblxcblxcdFxcdC8vIENyZWF0ZSBjb252ZXJ0ZXJzIG1hcCB3aXRoIGxvd2VyY2FzZWQga2V5c1xcblxcdFxcdGlmIChkYXRhVHlwZXNbMV0pIHtcXG5cXHRcXHRcXHRmb3IgKGNvbnYgaW4gcy5jb252ZXJ0ZXJzKSB7XFxuXFx0XFx0XFx0XFx0Y29udmVydGVyc1tjb252LnRvTG93ZXJDYXNlKCldID0gcy5jb252ZXJ0ZXJzW2NvbnZdO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xcblxcblxcdFxcdC8vIENvbnZlcnQgdG8gZWFjaCBzZXF1ZW50aWFsIGRhdGFUeXBlXFxuXFx0XFx0d2hpbGUgKGN1cnJlbnQpIHtcXG5cXG5cXHRcXHRcXHRpZiAocy5yZXNwb25zZUZpZWxkc1tjdXJyZW50XSkge1xcblxcdFxcdFxcdFxcdGpxWEhSW3MucmVzcG9uc2VGaWVsZHNbY3VycmVudF1dID0gcmVzcG9uc2U7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIEFwcGx5IHRoZSBkYXRhRmlsdGVyIGlmIHByb3ZpZGVkXFxuXFx0XFx0XFx0aWYgKCFwcmV2ICYmIGlzU3VjY2VzcyAmJiBzLmRhdGFGaWx0ZXIpIHtcXG5cXHRcXHRcXHRcXHRyZXNwb25zZSA9IHMuZGF0YUZpbHRlcihyZXNwb25zZSwgcy5kYXRhVHlwZSk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHByZXYgPSBjdXJyZW50O1xcblxcdFxcdFxcdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcXG5cXG5cXHRcXHRcXHRpZiAoY3VycmVudCkge1xcblxcblxcdFxcdFxcdFxcdC8vIFRoZXJlJ3Mgb25seSB3b3JrIHRvIGRvIGlmIGN1cnJlbnQgZGF0YVR5cGUgaXMgbm9uLWF1dG9cXG5cXHRcXHRcXHRcXHRpZiAoY3VycmVudCA9PT0gXFxcIipcXFwiKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y3VycmVudCA9IHByZXY7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gQ29udmVydCByZXNwb25zZSBpZiBwcmV2IGRhdGFUeXBlIGlzIG5vbi1hdXRvIGFuZCBkaWZmZXJzIGZyb20gY3VycmVudFxcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAocHJldiAhPT0gXFxcIipcXFwiICYmIHByZXYgIT09IGN1cnJlbnQpIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBTZWVrIGEgZGlyZWN0IGNvbnZlcnRlclxcblxcdFxcdFxcdFxcdFxcdGNvbnYgPSBjb252ZXJ0ZXJzW3ByZXYgKyBcXFwiIFxcXCIgKyBjdXJyZW50XSB8fCBjb252ZXJ0ZXJzW1xcXCIqIFxcXCIgKyBjdXJyZW50XTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBJZiBub25lIGZvdW5kLCBzZWVrIGEgcGFpclxcblxcdFxcdFxcdFxcdFxcdGlmICghY29udikge1xcblxcdFxcdFxcdFxcdFxcdFxcdGZvciAoY29udjIgaW4gY29udmVydGVycykge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIElmIGNvbnYyIG91dHB1dHMgY3VycmVudFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRtcCA9IGNvbnYyLnNwbGl0KFxcXCIgXFxcIik7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKHRtcFsxXSA9PT0gY3VycmVudCkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIElmIHByZXYgY2FuIGJlIGNvbnZlcnRlZCB0byBhY2NlcHRlZCBpbnB1dFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGNvbnYgPSBjb252ZXJ0ZXJzW3ByZXYgKyBcXFwiIFxcXCIgKyB0bXBbMF1dIHx8IGNvbnZlcnRlcnNbXFxcIiogXFxcIiArIHRtcFswXV07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKGNvbnYpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBDb25kZW5zZSBlcXVpdmFsZW5jZSBjb252ZXJ0ZXJzXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKGNvbnYgPT09IHRydWUpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjb252ID0gY29udmVydGVyc1tjb252Ml07XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gT3RoZXJ3aXNlLCBpbnNlcnQgdGhlIGludGVybWVkaWF0ZSBkYXRhVHlwZVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoY29udmVydGVyc1tjb252Ml0gIT09IHRydWUpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjdXJyZW50ID0gdG1wWzBdO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGFUeXBlcy51bnNoaWZ0KHRtcFsxXSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBBcHBseSBjb252ZXJ0ZXIgKGlmIG5vdCBhbiBlcXVpdmFsZW5jZSlcXG5cXHRcXHRcXHRcXHRcXHRpZiAoY29udiAhPT0gdHJ1ZSkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIFVubGVzcyBlcnJvcnMgYXJlIGFsbG93ZWQgdG8gYnViYmxlLCBjYXRjaCBhbmQgcmV0dXJuIHRoZW1cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoY29udiAmJiBzW1xcXCJ0aHJvd3NcXFwiXSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJlc3BvbnNlID0gY29udihyZXNwb25zZSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0cnkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHJlc3BvbnNlID0gY29udihyZXNwb25zZSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fSBjYXRjaCAoZSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiB7IHN0YXRlOiBcXFwicGFyc2VyZXJyb3JcXFwiLCBlcnJvcjogY29udiA/IGUgOiBcXFwiTm8gY29udmVyc2lvbiBmcm9tIFxcXCIgKyBwcmV2ICsgXFxcIiB0byBcXFwiICsgY3VycmVudCB9O1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiB7IHN0YXRlOiBcXFwic3VjY2Vzc1xcXCIsIGRhdGE6IHJlc3BvbnNlIH07XFxuXFx0fVxcblxcblxcdGpRdWVyeS5leHRlbmQoe1xcblxcblxcdFxcdC8vIENvdW50ZXIgZm9yIGhvbGRpbmcgdGhlIG51bWJlciBvZiBhY3RpdmUgcXVlcmllc1xcblxcdFxcdGFjdGl2ZTogMCxcXG5cXG5cXHRcXHQvLyBMYXN0LU1vZGlmaWVkIGhlYWRlciBjYWNoZSBmb3IgbmV4dCByZXF1ZXN0XFxuXFx0XFx0bGFzdE1vZGlmaWVkOiB7fSxcXG5cXHRcXHRldGFnOiB7fSxcXG5cXG5cXHRcXHRhamF4U2V0dGluZ3M6IHtcXG5cXHRcXHRcXHR1cmw6IGFqYXhMb2NhdGlvbixcXG5cXHRcXHRcXHR0eXBlOiBcXFwiR0VUXFxcIixcXG5cXHRcXHRcXHRpc0xvY2FsOiBybG9jYWxQcm90b2NvbC50ZXN0KGFqYXhMb2NQYXJ0c1sxXSksXFxuXFx0XFx0XFx0Z2xvYmFsOiB0cnVlLFxcblxcdFxcdFxcdHByb2Nlc3NEYXRhOiB0cnVlLFxcblxcdFxcdFxcdGFzeW5jOiB0cnVlLFxcblxcdFxcdFxcdGNvbnRlbnRUeXBlOiBcXFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04XFxcIixcXG5cXHRcXHRcXHQvKlxcbiAgIHRpbWVvdXQ6IDAsXFxuICAgZGF0YTogbnVsbCxcXG4gICBkYXRhVHlwZTogbnVsbCxcXG4gICB1c2VybmFtZTogbnVsbCxcXG4gICBwYXNzd29yZDogbnVsbCxcXG4gICBjYWNoZTogbnVsbCxcXG4gICB0aHJvd3M6IGZhbHNlLFxcbiAgIHRyYWRpdGlvbmFsOiBmYWxzZSxcXG4gICBoZWFkZXJzOiB7fSxcXG4gICAqL1xcblxcblxcdFxcdFxcdGFjY2VwdHM6IHtcXG5cXHRcXHRcXHRcXHRcXFwiKlxcXCI6IGFsbFR5cGVzLFxcblxcdFxcdFxcdFxcdHRleHQ6IFxcXCJ0ZXh0L3BsYWluXFxcIixcXG5cXHRcXHRcXHRcXHRodG1sOiBcXFwidGV4dC9odG1sXFxcIixcXG5cXHRcXHRcXHRcXHR4bWw6IFxcXCJhcHBsaWNhdGlvbi94bWwsIHRleHQveG1sXFxcIixcXG5cXHRcXHRcXHRcXHRqc29uOiBcXFwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9qYXZhc2NyaXB0XFxcIlxcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0Y29udGVudHM6IHtcXG5cXHRcXHRcXHRcXHR4bWw6IC94bWwvLFxcblxcdFxcdFxcdFxcdGh0bWw6IC9odG1sLyxcXG5cXHRcXHRcXHRcXHRqc29uOiAvanNvbi9cXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdHJlc3BvbnNlRmllbGRzOiB7XFxuXFx0XFx0XFx0XFx0eG1sOiBcXFwicmVzcG9uc2VYTUxcXFwiLFxcblxcdFxcdFxcdFxcdHRleHQ6IFxcXCJyZXNwb25zZVRleHRcXFwiLFxcblxcdFxcdFxcdFxcdGpzb246IFxcXCJyZXNwb25zZUpTT05cXFwiXFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHQvLyBEYXRhIGNvbnZlcnRlcnNcXG5cXHRcXHRcXHQvLyBLZXlzIHNlcGFyYXRlIHNvdXJjZSAob3IgY2F0Y2hhbGwgXFxcIipcXFwiKSBhbmQgZGVzdGluYXRpb24gdHlwZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxcblxcdFxcdFxcdGNvbnZlcnRlcnM6IHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBDb252ZXJ0IGFueXRoaW5nIHRvIHRleHRcXG5cXHRcXHRcXHRcXHRcXFwiKiB0ZXh0XFxcIjogU3RyaW5nLFxcblxcblxcdFxcdFxcdFxcdC8vIFRleHQgdG8gaHRtbCAodHJ1ZSA9IG5vIHRyYW5zZm9ybWF0aW9uKVxcblxcdFxcdFxcdFxcdFxcXCJ0ZXh0IGh0bWxcXFwiOiB0cnVlLFxcblxcblxcdFxcdFxcdFxcdC8vIEV2YWx1YXRlIHRleHQgYXMgYSBqc29uIGV4cHJlc3Npb25cXG5cXHRcXHRcXHRcXHRcXFwidGV4dCBqc29uXFxcIjogalF1ZXJ5LnBhcnNlSlNPTixcXG5cXG5cXHRcXHRcXHRcXHQvLyBQYXJzZSB0ZXh0IGFzIHhtbFxcblxcdFxcdFxcdFxcdFxcXCJ0ZXh0IHhtbFxcXCI6IGpRdWVyeS5wYXJzZVhNTFxcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0Ly8gRm9yIG9wdGlvbnMgdGhhdCBzaG91bGRuJ3QgYmUgZGVlcCBleHRlbmRlZDpcXG5cXHRcXHRcXHQvLyB5b3UgY2FuIGFkZCB5b3VyIG93biBjdXN0b20gb3B0aW9ucyBoZXJlIGlmXFxuXFx0XFx0XFx0Ly8gYW5kIHdoZW4geW91IGNyZWF0ZSBvbmUgdGhhdCBzaG91bGRuJ3QgYmVcXG5cXHRcXHRcXHQvLyBkZWVwIGV4dGVuZGVkIChzZWUgYWpheEV4dGVuZClcXG5cXHRcXHRcXHRmbGF0T3B0aW9uczoge1xcblxcdFxcdFxcdFxcdHVybDogdHJ1ZSxcXG5cXHRcXHRcXHRcXHRjb250ZXh0OiB0cnVlXFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Ly8gQ3JlYXRlcyBhIGZ1bGwgZmxlZGdlZCBzZXR0aW5ncyBvYmplY3QgaW50byB0YXJnZXRcXG5cXHRcXHQvLyB3aXRoIGJvdGggYWpheFNldHRpbmdzIGFuZCBzZXR0aW5ncyBmaWVsZHMuXFxuXFx0XFx0Ly8gSWYgdGFyZ2V0IGlzIG9taXR0ZWQsIHdyaXRlcyBpbnRvIGFqYXhTZXR0aW5ncy5cXG5cXHRcXHRhamF4U2V0dXA6IGZ1bmN0aW9uIGFqYXhTZXR1cCh0YXJnZXQsIHNldHRpbmdzKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHNldHRpbmdzID9cXG5cXG5cXHRcXHRcXHQvLyBCdWlsZGluZyBhIHNldHRpbmdzIG9iamVjdFxcblxcdFxcdFxcdGFqYXhFeHRlbmQoYWpheEV4dGVuZCh0YXJnZXQsIGpRdWVyeS5hamF4U2V0dGluZ3MpLCBzZXR0aW5ncykgOlxcblxcblxcdFxcdFxcdC8vIEV4dGVuZGluZyBhamF4U2V0dGluZ3NcXG5cXHRcXHRcXHRhamF4RXh0ZW5kKGpRdWVyeS5hamF4U2V0dGluZ3MsIHRhcmdldCk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRhamF4UHJlZmlsdGVyOiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMocHJlZmlsdGVycyksXFxuXFx0XFx0YWpheFRyYW5zcG9ydDogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKHRyYW5zcG9ydHMpLFxcblxcblxcdFxcdC8vIE1haW4gbWV0aG9kXFxuXFx0XFx0YWpheDogZnVuY3Rpb24gYWpheCh1cmwsIG9wdGlvbnMpIHtcXG5cXG5cXHRcXHRcXHQvLyBJZiB1cmwgaXMgYW4gb2JqZWN0LCBzaW11bGF0ZSBwcmUtMS41IHNpZ25hdHVyZVxcblxcdFxcdFxcdGlmICgodHlwZW9mIHVybCA9PT0gXFxcInVuZGVmaW5lZFxcXCIgPyBcXFwidW5kZWZpbmVkXFxcIiA6IF90eXBlb2YodXJsKSkgPT09IFxcXCJvYmplY3RcXFwiKSB7XFxuXFx0XFx0XFx0XFx0b3B0aW9ucyA9IHVybDtcXG5cXHRcXHRcXHRcXHR1cmwgPSB1bmRlZmluZWQ7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIEZvcmNlIG9wdGlvbnMgdG8gYmUgYW4gb2JqZWN0XFxuXFx0XFx0XFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XFxuXFxuXFx0XFx0XFx0dmFyIHRyYW5zcG9ydCxcXG5cXG5cXHRcXHRcXHQvLyBVUkwgd2l0aG91dCBhbnRpLWNhY2hlIHBhcmFtXFxuXFx0XFx0XFx0Y2FjaGVVUkwsXFxuXFxuXFx0XFx0XFx0Ly8gUmVzcG9uc2UgaGVhZGVyc1xcblxcdFxcdFxcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyxcXG5cXHRcXHRcXHQgICAgcmVzcG9uc2VIZWFkZXJzLFxcblxcblxcdFxcdFxcdC8vIHRpbWVvdXQgaGFuZGxlXFxuXFx0XFx0XFx0dGltZW91dFRpbWVyLFxcblxcblxcdFxcdFxcdC8vIENyb3NzLWRvbWFpbiBkZXRlY3Rpb24gdmFyc1xcblxcdFxcdFxcdHBhcnRzLFxcblxcblxcdFxcdFxcdC8vIFRvIGtub3cgaWYgZ2xvYmFsIGV2ZW50cyBhcmUgdG8gYmUgZGlzcGF0Y2hlZFxcblxcdFxcdFxcdGZpcmVHbG9iYWxzLFxcblxcblxcdFxcdFxcdC8vIExvb3AgdmFyaWFibGVcXG5cXHRcXHRcXHRpLFxcblxcblxcdFxcdFxcdC8vIENyZWF0ZSB0aGUgZmluYWwgb3B0aW9ucyBvYmplY3RcXG5cXHRcXHRcXHRzID0galF1ZXJ5LmFqYXhTZXR1cCh7fSwgb3B0aW9ucyksXFxuXFxuXFx0XFx0XFx0Ly8gQ2FsbGJhY2tzIGNvbnRleHRcXG5cXHRcXHRcXHRjYWxsYmFja0NvbnRleHQgPSBzLmNvbnRleHQgfHwgcyxcXG5cXG5cXHRcXHRcXHQvLyBDb250ZXh0IGZvciBnbG9iYWwgZXZlbnRzIGlzIGNhbGxiYWNrQ29udGV4dCBpZiBpdCBpcyBhIERPTSBub2RlIG9yIGpRdWVyeSBjb2xsZWN0aW9uXFxuXFx0XFx0XFx0Z2xvYmFsRXZlbnRDb250ZXh0ID0gcy5jb250ZXh0ICYmIChjYWxsYmFja0NvbnRleHQubm9kZVR5cGUgfHwgY2FsbGJhY2tDb250ZXh0LmpxdWVyeSkgPyBqUXVlcnkoY2FsbGJhY2tDb250ZXh0KSA6IGpRdWVyeS5ldmVudCxcXG5cXG5cXHRcXHRcXHQvLyBEZWZlcnJlZHNcXG5cXHRcXHRcXHRkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLFxcblxcdFxcdFxcdCAgICBjb21wbGV0ZURlZmVycmVkID0galF1ZXJ5LkNhbGxiYWNrcyhcXFwib25jZSBtZW1vcnlcXFwiKSxcXG5cXG5cXHRcXHRcXHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xcblxcdFxcdFxcdF9zdGF0dXNDb2RlID0gcy5zdGF0dXNDb2RlIHx8IHt9LFxcblxcblxcdFxcdFxcdC8vIEhlYWRlcnMgKHRoZXkgYXJlIHNlbnQgYWxsIGF0IG9uY2UpXFxuXFx0XFx0XFx0cmVxdWVzdEhlYWRlcnMgPSB7fSxcXG5cXHRcXHRcXHQgICAgcmVxdWVzdEhlYWRlcnNOYW1lcyA9IHt9LFxcblxcblxcdFxcdFxcdC8vIFRoZSBqcVhIUiBzdGF0ZVxcblxcdFxcdFxcdHN0YXRlID0gMCxcXG5cXG5cXHRcXHRcXHQvLyBEZWZhdWx0IGFib3J0IG1lc3NhZ2VcXG5cXHRcXHRcXHRzdHJBYm9ydCA9IFxcXCJjYW5jZWxlZFxcXCIsXFxuXFxuXFx0XFx0XFx0Ly8gRmFrZSB4aHJcXG5cXHRcXHRcXHRqcVhIUiA9IHtcXG5cXHRcXHRcXHRcXHRyZWFkeVN0YXRlOiAwLFxcblxcblxcdFxcdFxcdFxcdC8vIEJ1aWxkcyBoZWFkZXJzIGhhc2h0YWJsZSBpZiBuZWVkZWRcXG5cXHRcXHRcXHRcXHRnZXRSZXNwb25zZUhlYWRlcjogZnVuY3Rpb24gZ2V0UmVzcG9uc2VIZWFkZXIoa2V5KSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIG1hdGNoO1xcblxcdFxcdFxcdFxcdFxcdGlmIChzdGF0ZSA9PT0gMikge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICghcmVzcG9uc2VIZWFkZXJzKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmVzcG9uc2VIZWFkZXJzID0ge307XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0d2hpbGUgKG1hdGNoID0gcmhlYWRlcnMuZXhlYyhyZXNwb25zZUhlYWRlcnNTdHJpbmcpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cmVzcG9uc2VIZWFkZXJzW21hdGNoWzFdLnRvTG93ZXJDYXNlKCldID0gbWF0Y2hbMl07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRtYXRjaCA9IHJlc3BvbnNlSGVhZGVyc1trZXkudG9Mb3dlckNhc2UoKV07XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBtYXRjaCA9PSBudWxsID8gbnVsbCA6IG1hdGNoO1xcblxcdFxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0XFx0Ly8gUmF3IHN0cmluZ1xcblxcdFxcdFxcdFxcdGdldEFsbFJlc3BvbnNlSGVhZGVyczogZnVuY3Rpb24gZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBzdGF0ZSA9PT0gMiA/IHJlc3BvbnNlSGVhZGVyc1N0cmluZyA6IG51bGw7XFxuXFx0XFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRcXHQvLyBDYWNoZXMgdGhlIGhlYWRlclxcblxcdFxcdFxcdFxcdHNldFJlcXVlc3RIZWFkZXI6IGZ1bmN0aW9uIHNldFJlcXVlc3RIZWFkZXIobmFtZSwgdmFsdWUpIHtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgbG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCFzdGF0ZSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdG5hbWUgPSByZXF1ZXN0SGVhZGVyc05hbWVzW2xuYW1lXSA9IHJlcXVlc3RIZWFkZXJzTmFtZXNbbG5hbWVdIHx8IG5hbWU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmVxdWVzdEhlYWRlcnNbbmFtZV0gPSB2YWx1ZTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0XFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRcXHQvLyBPdmVycmlkZXMgcmVzcG9uc2UgY29udGVudC10eXBlIGhlYWRlclxcblxcdFxcdFxcdFxcdG92ZXJyaWRlTWltZVR5cGU6IGZ1bmN0aW9uIG92ZXJyaWRlTWltZVR5cGUodHlwZSkge1xcblxcdFxcdFxcdFxcdFxcdGlmICghc3RhdGUpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzLm1pbWVUeXBlID0gdHlwZTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0XFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRcXHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xcblxcdFxcdFxcdFxcdHN0YXR1c0NvZGU6IGZ1bmN0aW9uIHN0YXR1c0NvZGUobWFwKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGNvZGU7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKG1hcCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChzdGF0ZSA8IDIpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRmb3IgKGNvZGUgaW4gbWFwKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gTGF6eS1hZGQgdGhlIG5ldyBjYWxsYmFjayBpbiBhIHdheSB0aGF0IHByZXNlcnZlcyBvbGQgb25lc1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdF9zdGF0dXNDb2RlW2NvZGVdID0gW19zdGF0dXNDb2RlW2NvZGVdLCBtYXBbY29kZV1dO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIEV4ZWN1dGUgdGhlIGFwcHJvcHJpYXRlIGNhbGxiYWNrc1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGpxWEhSLmFsd2F5cyhtYXBbanFYSFIuc3RhdHVzXSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXHRcXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdFxcdC8vIENhbmNlbCB0aGUgcmVxdWVzdFxcblxcdFxcdFxcdFxcdGFib3J0OiBmdW5jdGlvbiBhYm9ydChzdGF0dXNUZXh0KSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGZpbmFsVGV4dCA9IHN0YXR1c1RleHQgfHwgc3RyQWJvcnQ7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHRyYW5zcG9ydCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRyYW5zcG9ydC5hYm9ydChmaW5hbFRleHQpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRkb25lKDAsIGZpbmFsVGV4dCk7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0XFx0Ly8gQXR0YWNoIGRlZmVycmVkc1xcblxcdFxcdFxcdGRlZmVycmVkLnByb21pc2UoanFYSFIpLmNvbXBsZXRlID0gY29tcGxldGVEZWZlcnJlZC5hZGQ7XFxuXFx0XFx0XFx0anFYSFIuc3VjY2VzcyA9IGpxWEhSLmRvbmU7XFxuXFx0XFx0XFx0anFYSFIuZXJyb3IgPSBqcVhIUi5mYWlsO1xcblxcblxcdFxcdFxcdC8vIFJlbW92ZSBoYXNoIGNoYXJhY3RlciAoIzc1MzE6IGFuZCBzdHJpbmcgcHJvbW90aW9uKVxcblxcdFxcdFxcdC8vIEFkZCBwcm90b2NvbCBpZiBub3QgcHJvdmlkZWQgKHByZWZpbHRlcnMgbWlnaHQgZXhwZWN0IGl0KVxcblxcdFxcdFxcdC8vIEhhbmRsZSBmYWxzeSB1cmwgaW4gdGhlIHNldHRpbmdzIG9iamVjdCAoIzEwMDkzOiBjb25zaXN0ZW5jeSB3aXRoIG9sZCBzaWduYXR1cmUpXFxuXFx0XFx0XFx0Ly8gV2UgYWxzbyB1c2UgdGhlIHVybCBwYXJhbWV0ZXIgaWYgYXZhaWxhYmxlXFxuXFx0XFx0XFx0cy51cmwgPSAoKHVybCB8fCBzLnVybCB8fCBhamF4TG9jYXRpb24pICsgXFxcIlxcXCIpLnJlcGxhY2Uocmhhc2gsIFxcXCJcXFwiKS5yZXBsYWNlKHJwcm90b2NvbCwgYWpheExvY1BhcnRzWzFdICsgXFxcIi8vXFxcIik7XFxuXFxuXFx0XFx0XFx0Ly8gQWxpYXMgbWV0aG9kIG9wdGlvbiB0byB0eXBlIGFzIHBlciB0aWNrZXQgIzEyMDA0XFxuXFx0XFx0XFx0cy50eXBlID0gb3B0aW9ucy5tZXRob2QgfHwgb3B0aW9ucy50eXBlIHx8IHMubWV0aG9kIHx8IHMudHlwZTtcXG5cXG5cXHRcXHRcXHQvLyBFeHRyYWN0IGRhdGFUeXBlcyBsaXN0XFxuXFx0XFx0XFx0cy5kYXRhVHlwZXMgPSBqUXVlcnkudHJpbShzLmRhdGFUeXBlIHx8IFxcXCIqXFxcIikudG9Mb3dlckNhc2UoKS5tYXRjaChybm90d2hpdGUpIHx8IFtcXFwiXFxcIl07XFxuXFxuXFx0XFx0XFx0Ly8gQSBjcm9zcy1kb21haW4gcmVxdWVzdCBpcyBpbiBvcmRlciB3aGVuIHdlIGhhdmUgYSBwcm90b2NvbDpob3N0OnBvcnQgbWlzbWF0Y2hcXG5cXHRcXHRcXHRpZiAocy5jcm9zc0RvbWFpbiA9PSBudWxsKSB7XFxuXFx0XFx0XFx0XFx0cGFydHMgPSBydXJsLmV4ZWMocy51cmwudG9Mb3dlckNhc2UoKSk7XFxuXFx0XFx0XFx0XFx0cy5jcm9zc0RvbWFpbiA9ICEhKHBhcnRzICYmIChwYXJ0c1sxXSAhPT0gYWpheExvY1BhcnRzWzFdIHx8IHBhcnRzWzJdICE9PSBhamF4TG9jUGFydHNbMl0gfHwgKHBhcnRzWzNdIHx8IChwYXJ0c1sxXSA9PT0gXFxcImh0dHA6XFxcIiA/IFxcXCI4MFxcXCIgOiBcXFwiNDQzXFxcIikpICE9PSAoYWpheExvY1BhcnRzWzNdIHx8IChhamF4TG9jUGFydHNbMV0gPT09IFxcXCJodHRwOlxcXCIgPyBcXFwiODBcXFwiIDogXFxcIjQ0M1xcXCIpKSkpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBDb252ZXJ0IGRhdGEgaWYgbm90IGFscmVhZHkgYSBzdHJpbmdcXG5cXHRcXHRcXHRpZiAocy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiYgdHlwZW9mIHMuZGF0YSAhPT0gXFxcInN0cmluZ1xcXCIpIHtcXG5cXHRcXHRcXHRcXHRzLmRhdGEgPSBqUXVlcnkucGFyYW0ocy5kYXRhLCBzLnRyYWRpdGlvbmFsKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gQXBwbHkgcHJlZmlsdGVyc1xcblxcdFxcdFxcdGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKHByZWZpbHRlcnMsIHMsIG9wdGlvbnMsIGpxWEhSKTtcXG5cXG5cXHRcXHRcXHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhIHByZWZpbHRlciwgc3RvcCB0aGVyZVxcblxcdFxcdFxcdGlmIChzdGF0ZSA9PT0gMikge1xcblxcdFxcdFxcdFxcdHJldHVybiBqcVhIUjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gV2UgY2FuIGZpcmUgZ2xvYmFsIGV2ZW50cyBhcyBvZiBub3cgaWYgYXNrZWQgdG9cXG5cXHRcXHRcXHQvLyBEb24ndCBmaXJlIGV2ZW50cyBpZiBqUXVlcnkuZXZlbnQgaXMgdW5kZWZpbmVkIGluIGFuIEFNRC11c2FnZSBzY2VuYXJpbyAoIzE1MTE4KVxcblxcdFxcdFxcdGZpcmVHbG9iYWxzID0galF1ZXJ5LmV2ZW50ICYmIHMuZ2xvYmFsO1xcblxcblxcdFxcdFxcdC8vIFdhdGNoIGZvciBhIG5ldyBzZXQgb2YgcmVxdWVzdHNcXG5cXHRcXHRcXHRpZiAoZmlyZUdsb2JhbHMgJiYgalF1ZXJ5LmFjdGl2ZSsrID09PSAwKSB7XFxuXFx0XFx0XFx0XFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoXFxcImFqYXhTdGFydFxcXCIpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBVcHBlcmNhc2UgdGhlIHR5cGVcXG5cXHRcXHRcXHRzLnR5cGUgPSBzLnR5cGUudG9VcHBlckNhc2UoKTtcXG5cXG5cXHRcXHRcXHQvLyBEZXRlcm1pbmUgaWYgcmVxdWVzdCBoYXMgY29udGVudFxcblxcdFxcdFxcdHMuaGFzQ29udGVudCA9ICFybm9Db250ZW50LnRlc3Qocy50eXBlKTtcXG5cXG5cXHRcXHRcXHQvLyBTYXZlIHRoZSBVUkwgaW4gY2FzZSB3ZSdyZSB0b3lpbmcgd2l0aCB0aGUgSWYtTW9kaWZpZWQtU2luY2VcXG5cXHRcXHRcXHQvLyBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIgbGF0ZXIgb25cXG5cXHRcXHRcXHRjYWNoZVVSTCA9IHMudXJsO1xcblxcblxcdFxcdFxcdC8vIE1vcmUgb3B0aW9ucyBoYW5kbGluZyBmb3IgcmVxdWVzdHMgd2l0aCBubyBjb250ZW50XFxuXFx0XFx0XFx0aWYgKCFzLmhhc0NvbnRlbnQpIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBJZiBkYXRhIGlzIGF2YWlsYWJsZSwgYXBwZW5kIGRhdGEgdG8gdXJsXFxuXFx0XFx0XFx0XFx0aWYgKHMuZGF0YSkge1xcblxcdFxcdFxcdFxcdFxcdGNhY2hlVVJMID0gcy51cmwgKz0gKHJxdWVyeS50ZXN0KGNhY2hlVVJMKSA/IFxcXCImXFxcIiA6IFxcXCI/XFxcIikgKyBzLmRhdGE7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gIzk2ODI6IHJlbW92ZSBkYXRhIHNvIHRoYXQgaXQncyBub3QgdXNlZCBpbiBhbiBldmVudHVhbCByZXRyeVxcblxcdFxcdFxcdFxcdFxcdGRlbGV0ZSBzLmRhdGE7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIEFkZCBhbnRpLWNhY2hlIGluIHVybCBpZiBuZWVkZWRcXG5cXHRcXHRcXHRcXHRpZiAocy5jYWNoZSA9PT0gZmFsc2UpIHtcXG5cXHRcXHRcXHRcXHRcXHRzLnVybCA9IHJ0cy50ZXN0KGNhY2hlVVJMKSA/XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gSWYgdGhlcmUgaXMgYWxyZWFkeSBhICdfJyBwYXJhbWV0ZXIsIHNldCBpdHMgdmFsdWVcXG5cXHRcXHRcXHRcXHRcXHRjYWNoZVVSTC5yZXBsYWNlKHJ0cywgXFxcIiQxXz1cXFwiICsgbm9uY2UrKykgOlxcblxcblxcdFxcdFxcdFxcdFxcdC8vIE90aGVyd2lzZSBhZGQgb25lIHRvIHRoZSBlbmRcXG5cXHRcXHRcXHRcXHRcXHRjYWNoZVVSTCArIChycXVlcnkudGVzdChjYWNoZVVSTCkgPyBcXFwiJlxcXCIgOiBcXFwiP1xcXCIpICsgXFxcIl89XFxcIiArIG5vbmNlKys7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxcblxcdFxcdFxcdGlmIChzLmlmTW9kaWZpZWQpIHtcXG5cXHRcXHRcXHRcXHRpZiAoalF1ZXJ5Lmxhc3RNb2RpZmllZFtjYWNoZVVSTF0pIHtcXG5cXHRcXHRcXHRcXHRcXHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKFxcXCJJZi1Nb2RpZmllZC1TaW5jZVxcXCIsIGpRdWVyeS5sYXN0TW9kaWZpZWRbY2FjaGVVUkxdKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aWYgKGpRdWVyeS5ldGFnW2NhY2hlVVJMXSkge1xcblxcdFxcdFxcdFxcdFxcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoXFxcIklmLU5vbmUtTWF0Y2hcXFwiLCBqUXVlcnkuZXRhZ1tjYWNoZVVSTF0pO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gU2V0IHRoZSBjb3JyZWN0IGhlYWRlciwgaWYgZGF0YSBpcyBiZWluZyBzZW50XFxuXFx0XFx0XFx0aWYgKHMuZGF0YSAmJiBzLmhhc0NvbnRlbnQgJiYgcy5jb250ZW50VHlwZSAhPT0gZmFsc2UgfHwgb3B0aW9ucy5jb250ZW50VHlwZSkge1xcblxcdFxcdFxcdFxcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoXFxcIkNvbnRlbnQtVHlwZVxcXCIsIHMuY29udGVudFR5cGUpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBTZXQgdGhlIEFjY2VwdHMgaGVhZGVyIGZvciB0aGUgc2VydmVyLCBkZXBlbmRpbmcgb24gdGhlIGRhdGFUeXBlXFxuXFx0XFx0XFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlcihcXFwiQWNjZXB0XFxcIiwgcy5kYXRhVHlwZXNbMF0gJiYgcy5hY2NlcHRzW3MuZGF0YVR5cGVzWzBdXSA/IHMuYWNjZXB0c1tzLmRhdGFUeXBlc1swXV0gKyAocy5kYXRhVHlwZXNbMF0gIT09IFxcXCIqXFxcIiA/IFxcXCIsIFxcXCIgKyBhbGxUeXBlcyArIFxcXCI7IHE9MC4wMVxcXCIgOiBcXFwiXFxcIikgOiBzLmFjY2VwdHNbXFxcIipcXFwiXSk7XFxuXFxuXFx0XFx0XFx0Ly8gQ2hlY2sgZm9yIGhlYWRlcnMgb3B0aW9uXFxuXFx0XFx0XFx0Zm9yIChpIGluIHMuaGVhZGVycykge1xcblxcdFxcdFxcdFxcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoaSwgcy5oZWFkZXJzW2ldKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gQWxsb3cgY3VzdG9tIGhlYWRlcnMvbWltZXR5cGVzIGFuZCBlYXJseSBhYm9ydFxcblxcdFxcdFxcdGlmIChzLmJlZm9yZVNlbmQgJiYgKHMuYmVmb3JlU2VuZC5jYWxsKGNhbGxiYWNrQ29udGV4dCwganFYSFIsIHMpID09PSBmYWxzZSB8fCBzdGF0ZSA9PT0gMikpIHtcXG5cXHRcXHRcXHRcXHQvLyBBYm9ydCBpZiBub3QgZG9uZSBhbHJlYWR5IGFuZCByZXR1cm5cXG5cXHRcXHRcXHRcXHRyZXR1cm4ganFYSFIuYWJvcnQoKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gQWJvcnRpbmcgaXMgbm8gbG9uZ2VyIGEgY2FuY2VsbGF0aW9uXFxuXFx0XFx0XFx0c3RyQWJvcnQgPSBcXFwiYWJvcnRcXFwiO1xcblxcblxcdFxcdFxcdC8vIEluc3RhbGwgY2FsbGJhY2tzIG9uIGRlZmVycmVkc1xcblxcdFxcdFxcdGZvciAoaSBpbiB7IHN1Y2Nlc3M6IDEsIGVycm9yOiAxLCBjb21wbGV0ZTogMSB9KSB7XFxuXFx0XFx0XFx0XFx0anFYSFJbaV0oc1tpXSk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIEdldCB0cmFuc3BvcnRcXG5cXHRcXHRcXHR0cmFuc3BvcnQgPSBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyh0cmFuc3BvcnRzLCBzLCBvcHRpb25zLCBqcVhIUik7XFxuXFxuXFx0XFx0XFx0Ly8gSWYgbm8gdHJhbnNwb3J0LCB3ZSBhdXRvLWFib3J0XFxuXFx0XFx0XFx0aWYgKCF0cmFuc3BvcnQpIHtcXG5cXHRcXHRcXHRcXHRkb25lKC0xLCBcXFwiTm8gVHJhbnNwb3J0XFxcIik7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRqcVhIUi5yZWFkeVN0YXRlID0gMTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBTZW5kIGdsb2JhbCBldmVudFxcblxcdFxcdFxcdFxcdGlmIChmaXJlR2xvYmFscykge1xcblxcdFxcdFxcdFxcdFxcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKFxcXCJhamF4U2VuZFxcXCIsIFtqcVhIUiwgc10pO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHQvLyBUaW1lb3V0XFxuXFx0XFx0XFx0XFx0aWYgKHMuYXN5bmMgJiYgcy50aW1lb3V0ID4gMCkge1xcblxcdFxcdFxcdFxcdFxcdHRpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGpxWEhSLmFib3J0KFxcXCJ0aW1lb3V0XFxcIik7XFxuXFx0XFx0XFx0XFx0XFx0fSwgcy50aW1lb3V0KTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0dHJ5IHtcXG5cXHRcXHRcXHRcXHRcXHRzdGF0ZSA9IDE7XFxuXFx0XFx0XFx0XFx0XFx0dHJhbnNwb3J0LnNlbmQocmVxdWVzdEhlYWRlcnMsIGRvbmUpO1xcblxcdFxcdFxcdFxcdH0gY2F0Y2ggKGUpIHtcXG5cXHRcXHRcXHRcXHRcXHQvLyBQcm9wYWdhdGUgZXhjZXB0aW9uIGFzIGVycm9yIGlmIG5vdCBkb25lXFxuXFx0XFx0XFx0XFx0XFx0aWYgKHN0YXRlIDwgMikge1xcblxcdFxcdFxcdFxcdFxcdFxcdGRvbmUoLTEsIGUpO1xcblxcdFxcdFxcdFxcdFxcdFxcdC8vIFNpbXBseSByZXRocm93IG90aGVyd2lzZVxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhyb3cgZTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBDYWxsYmFjayBmb3Igd2hlbiBldmVyeXRoaW5nIGlzIGRvbmVcXG5cXHRcXHRcXHRmdW5jdGlvbiBkb25lKHN0YXR1cywgbmF0aXZlU3RhdHVzVGV4dCwgcmVzcG9uc2VzLCBoZWFkZXJzKSB7XFxuXFx0XFx0XFx0XFx0dmFyIGlzU3VjY2VzcyxcXG5cXHRcXHRcXHRcXHQgICAgc3VjY2VzcyxcXG5cXHRcXHRcXHRcXHQgICAgZXJyb3IsXFxuXFx0XFx0XFx0XFx0ICAgIHJlc3BvbnNlLFxcblxcdFxcdFxcdFxcdCAgICBtb2RpZmllZCxcXG5cXHRcXHRcXHRcXHQgICAgc3RhdHVzVGV4dCA9IG5hdGl2ZVN0YXR1c1RleHQ7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQ2FsbGVkIG9uY2VcXG5cXHRcXHRcXHRcXHRpZiAoc3RhdGUgPT09IDIpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIFN0YXRlIGlzIFxcXCJkb25lXFxcIiBub3dcXG5cXHRcXHRcXHRcXHRzdGF0ZSA9IDI7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQ2xlYXIgdGltZW91dCBpZiBpdCBleGlzdHNcXG5cXHRcXHRcXHRcXHRpZiAodGltZW91dFRpbWVyKSB7XFxuXFx0XFx0XFx0XFx0XFx0Y2xlYXJUaW1lb3V0KHRpbWVvdXRUaW1lcik7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIERlcmVmZXJlbmNlIHRyYW5zcG9ydCBmb3IgZWFybHkgZ2FyYmFnZSBjb2xsZWN0aW9uXFxuXFx0XFx0XFx0XFx0Ly8gKG5vIG1hdHRlciBob3cgbG9uZyB0aGUganFYSFIgb2JqZWN0IHdpbGwgYmUgdXNlZClcXG5cXHRcXHRcXHRcXHR0cmFuc3BvcnQgPSB1bmRlZmluZWQ7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQ2FjaGUgcmVzcG9uc2UgaGVhZGVyc1xcblxcdFxcdFxcdFxcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyA9IGhlYWRlcnMgfHwgXFxcIlxcXCI7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gU2V0IHJlYWR5U3RhdGVcXG5cXHRcXHRcXHRcXHRqcVhIUi5yZWFkeVN0YXRlID0gc3RhdHVzID4gMCA/IDQgOiAwO1xcblxcblxcdFxcdFxcdFxcdC8vIERldGVybWluZSBpZiBzdWNjZXNzZnVsXFxuXFx0XFx0XFx0XFx0aXNTdWNjZXNzID0gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDAgfHwgc3RhdHVzID09PSAzMDQ7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gR2V0IHJlc3BvbnNlIGRhdGFcXG5cXHRcXHRcXHRcXHRpZiAocmVzcG9uc2VzKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmVzcG9uc2UgPSBhamF4SGFuZGxlUmVzcG9uc2VzKHMsIGpxWEhSLCByZXNwb25zZXMpO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBDb252ZXJ0IG5vIG1hdHRlciB3aGF0ICh0aGF0IHdheSByZXNwb25zZVhYWCBmaWVsZHMgYXJlIGFsd2F5cyBzZXQpXFxuXFx0XFx0XFx0XFx0cmVzcG9uc2UgPSBhamF4Q29udmVydChzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2Vzcyk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSWYgc3VjY2Vzc2Z1bCwgaGFuZGxlIHR5cGUgY2hhaW5pbmdcXG5cXHRcXHRcXHRcXHRpZiAoaXNTdWNjZXNzKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cXG5cXHRcXHRcXHRcXHRcXHRpZiAocy5pZk1vZGlmaWVkKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlcihcXFwiTGFzdC1Nb2RpZmllZFxcXCIpO1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChtb2RpZmllZCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGpRdWVyeS5sYXN0TW9kaWZpZWRbY2FjaGVVUkxdID0gbW9kaWZpZWQ7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoXFxcImV0YWdcXFwiKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAobW9kaWZpZWQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRqUXVlcnkuZXRhZ1tjYWNoZVVSTF0gPSBtb2RpZmllZDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdC8vIGlmIG5vIGNvbnRlbnRcXG5cXHRcXHRcXHRcXHRcXHRpZiAoc3RhdHVzID09PSAyMDQgfHwgcy50eXBlID09PSBcXFwiSEVBRFxcXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzdGF0dXNUZXh0ID0gXFxcIm5vY29udGVudFxcXCI7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gaWYgbm90IG1vZGlmaWVkXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIGlmIChzdGF0dXMgPT09IDMwNCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHN0YXR1c1RleHQgPSBcXFwibm90bW9kaWZpZWRcXFwiO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIElmIHdlIGhhdmUgZGF0YSwgbGV0J3MgY29udmVydCBpdFxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0c3RhdHVzVGV4dCA9IHJlc3BvbnNlLnN0YXRlO1xcblxcdFxcdFxcdFxcdFxcdFxcdHN1Y2Nlc3MgPSByZXNwb25zZS5kYXRhO1xcblxcdFxcdFxcdFxcdFxcdFxcdGVycm9yID0gcmVzcG9uc2UuZXJyb3I7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aXNTdWNjZXNzID0gIWVycm9yO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdC8vIEV4dHJhY3QgZXJyb3IgZnJvbSBzdGF0dXNUZXh0IGFuZCBub3JtYWxpemUgZm9yIG5vbi1hYm9ydHNcXG5cXHRcXHRcXHRcXHRcXHRlcnJvciA9IHN0YXR1c1RleHQ7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHN0YXR1cyB8fCAhc3RhdHVzVGV4dCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHN0YXR1c1RleHQgPSBcXFwiZXJyb3JcXFwiO1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChzdGF0dXMgPCAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c3RhdHVzID0gMDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBTZXQgZGF0YSBmb3IgdGhlIGZha2UgeGhyIG9iamVjdFxcblxcdFxcdFxcdFxcdGpxWEhSLnN0YXR1cyA9IHN0YXR1cztcXG5cXHRcXHRcXHRcXHRqcVhIUi5zdGF0dXNUZXh0ID0gKG5hdGl2ZVN0YXR1c1RleHQgfHwgc3RhdHVzVGV4dCkgKyBcXFwiXFxcIjtcXG5cXG5cXHRcXHRcXHRcXHQvLyBTdWNjZXNzL0Vycm9yXFxuXFx0XFx0XFx0XFx0aWYgKGlzU3VjY2Vzcykge1xcblxcdFxcdFxcdFxcdFxcdGRlZmVycmVkLnJlc29sdmVXaXRoKGNhbGxiYWNrQ29udGV4dCwgW3N1Y2Nlc3MsIHN0YXR1c1RleHQsIGpxWEhSXSk7XFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRkZWZlcnJlZC5yZWplY3RXaXRoKGNhbGxiYWNrQ29udGV4dCwgW2pxWEhSLCBzdGF0dXNUZXh0LCBlcnJvcl0pO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xcblxcdFxcdFxcdFxcdGpxWEhSLnN0YXR1c0NvZGUoX3N0YXR1c0NvZGUpO1xcblxcdFxcdFxcdFxcdF9zdGF0dXNDb2RlID0gdW5kZWZpbmVkO1xcblxcblxcdFxcdFxcdFxcdGlmIChmaXJlR2xvYmFscykge1xcblxcdFxcdFxcdFxcdFxcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKGlzU3VjY2VzcyA/IFxcXCJhamF4U3VjY2Vzc1xcXCIgOiBcXFwiYWpheEVycm9yXFxcIiwgW2pxWEhSLCBzLCBpc1N1Y2Nlc3MgPyBzdWNjZXNzIDogZXJyb3JdKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQ29tcGxldGVcXG5cXHRcXHRcXHRcXHRjb21wbGV0ZURlZmVycmVkLmZpcmVXaXRoKGNhbGxiYWNrQ29udGV4dCwgW2pxWEhSLCBzdGF0dXNUZXh0XSk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKGZpcmVHbG9iYWxzKSB7XFxuXFx0XFx0XFx0XFx0XFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoXFxcImFqYXhDb21wbGV0ZVxcXCIsIFtqcVhIUiwgc10pO1xcblxcdFxcdFxcdFxcdFxcdC8vIEhhbmRsZSB0aGUgZ2xvYmFsIEFKQVggY291bnRlclxcblxcdFxcdFxcdFxcdFxcdGlmICghIC0talF1ZXJ5LmFjdGl2ZSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGpRdWVyeS5ldmVudC50cmlnZ2VyKFxcXCJhamF4U3RvcFxcXCIpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBqcVhIUjtcXG5cXHRcXHR9LFxcblxcblxcdFxcdGdldEpTT046IGZ1bmN0aW9uIGdldEpTT04odXJsLCBkYXRhLCBjYWxsYmFjaykge1xcblxcdFxcdFxcdHJldHVybiBqUXVlcnkuZ2V0KHVybCwgZGF0YSwgY2FsbGJhY2ssIFxcXCJqc29uXFxcIik7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRnZXRTY3JpcHQ6IGZ1bmN0aW9uIGdldFNjcmlwdCh1cmwsIGNhbGxiYWNrKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGpRdWVyeS5nZXQodXJsLCB1bmRlZmluZWQsIGNhbGxiYWNrLCBcXFwic2NyaXB0XFxcIik7XFxuXFx0XFx0fVxcblxcdH0pO1xcblxcblxcdGpRdWVyeS5lYWNoKFtcXFwiZ2V0XFxcIiwgXFxcInBvc3RcXFwiXSwgZnVuY3Rpb24gKGksIG1ldGhvZCkge1xcblxcdFxcdGpRdWVyeVttZXRob2RdID0gZnVuY3Rpb24gKHVybCwgZGF0YSwgY2FsbGJhY2ssIHR5cGUpIHtcXG5cXHRcXHRcXHQvLyBTaGlmdCBhcmd1bWVudHMgaWYgZGF0YSBhcmd1bWVudCB3YXMgb21pdHRlZFxcblxcdFxcdFxcdGlmIChqUXVlcnkuaXNGdW5jdGlvbihkYXRhKSkge1xcblxcdFxcdFxcdFxcdHR5cGUgPSB0eXBlIHx8IGNhbGxiYWNrO1xcblxcdFxcdFxcdFxcdGNhbGxiYWNrID0gZGF0YTtcXG5cXHRcXHRcXHRcXHRkYXRhID0gdW5kZWZpbmVkO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4galF1ZXJ5LmFqYXgoe1xcblxcdFxcdFxcdFxcdHVybDogdXJsLFxcblxcdFxcdFxcdFxcdHR5cGU6IG1ldGhvZCxcXG5cXHRcXHRcXHRcXHRkYXRhVHlwZTogdHlwZSxcXG5cXHRcXHRcXHRcXHRkYXRhOiBkYXRhLFxcblxcdFxcdFxcdFxcdHN1Y2Nlc3M6IGNhbGxiYWNrXFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0fTtcXG5cXHR9KTtcXG5cXG5cXHRqUXVlcnkuX2V2YWxVcmwgPSBmdW5jdGlvbiAodXJsKSB7XFxuXFx0XFx0cmV0dXJuIGpRdWVyeS5hamF4KHtcXG5cXHRcXHRcXHR1cmw6IHVybCxcXG5cXHRcXHRcXHR0eXBlOiBcXFwiR0VUXFxcIixcXG5cXHRcXHRcXHRkYXRhVHlwZTogXFxcInNjcmlwdFxcXCIsXFxuXFx0XFx0XFx0YXN5bmM6IGZhbHNlLFxcblxcdFxcdFxcdGdsb2JhbDogZmFsc2UsXFxuXFx0XFx0XFx0XFxcInRocm93c1xcXCI6IHRydWVcXG5cXHRcXHR9KTtcXG5cXHR9O1xcblxcblxcdGpRdWVyeS5mbi5leHRlbmQoe1xcblxcdFxcdHdyYXBBbGw6IGZ1bmN0aW9uIHdyYXBBbGwoaHRtbCkge1xcblxcdFxcdFxcdHZhciB3cmFwO1xcblxcblxcdFxcdFxcdGlmIChqUXVlcnkuaXNGdW5jdGlvbihodG1sKSkge1xcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKGkpIHtcXG5cXHRcXHRcXHRcXHRcXHRqUXVlcnkodGhpcykud3JhcEFsbChodG1sLmNhbGwodGhpcywgaSkpO1xcblxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAodGhpc1swXSkge1xcblxcblxcdFxcdFxcdFxcdC8vIFRoZSBlbGVtZW50cyB0byB3cmFwIHRoZSB0YXJnZXQgYXJvdW5kXFxuXFx0XFx0XFx0XFx0d3JhcCA9IGpRdWVyeShodG1sLCB0aGlzWzBdLm93bmVyRG9jdW1lbnQpLmVxKDApLmNsb25lKHRydWUpO1xcblxcblxcdFxcdFxcdFxcdGlmICh0aGlzWzBdLnBhcmVudE5vZGUpIHtcXG5cXHRcXHRcXHRcXHRcXHR3cmFwLmluc2VydEJlZm9yZSh0aGlzWzBdKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0d3JhcC5tYXAoZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdHZhciBlbGVtID0gdGhpcztcXG5cXG5cXHRcXHRcXHRcXHRcXHR3aGlsZSAoZWxlbS5maXJzdEVsZW1lbnRDaGlsZCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGVsZW0gPSBlbGVtLmZpcnN0RWxlbWVudENoaWxkO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gZWxlbTtcXG5cXHRcXHRcXHRcXHR9KS5hcHBlbmQodGhpcyk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0d3JhcElubmVyOiBmdW5jdGlvbiB3cmFwSW5uZXIoaHRtbCkge1xcblxcdFxcdFxcdGlmIChqUXVlcnkuaXNGdW5jdGlvbihodG1sKSkge1xcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKGkpIHtcXG5cXHRcXHRcXHRcXHRcXHRqUXVlcnkodGhpcykud3JhcElubmVyKGh0bWwuY2FsbCh0aGlzLCBpKSk7XFxuXFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdHZhciBzZWxmID0galF1ZXJ5KHRoaXMpLFxcblxcdFxcdFxcdFxcdCAgICBjb250ZW50cyA9IHNlbGYuY29udGVudHMoKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoY29udGVudHMubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0Y29udGVudHMud3JhcEFsbChodG1sKTtcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdHNlbGYuYXBwZW5kKGh0bWwpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdHdyYXA6IGZ1bmN0aW9uIHdyYXAoaHRtbCkge1xcblxcdFxcdFxcdHZhciBpc0Z1bmN0aW9uID0galF1ZXJ5LmlzRnVuY3Rpb24oaHRtbCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoaSkge1xcblxcdFxcdFxcdFxcdGpRdWVyeSh0aGlzKS53cmFwQWxsKGlzRnVuY3Rpb24gPyBodG1sLmNhbGwodGhpcywgaSkgOiBodG1sKTtcXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdHVud3JhcDogZnVuY3Rpb24gdW53cmFwKCkge1xcblxcdFxcdFxcdHJldHVybiB0aGlzLnBhcmVudCgpLmVhY2goZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdGlmICghalF1ZXJ5Lm5vZGVOYW1lKHRoaXMsIFxcXCJib2R5XFxcIikpIHtcXG5cXHRcXHRcXHRcXHRcXHRqUXVlcnkodGhpcykucmVwbGFjZVdpdGgodGhpcy5jaGlsZE5vZGVzKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSkuZW5kKCk7XFxuXFx0XFx0fVxcblxcdH0pO1xcblxcblxcdGpRdWVyeS5leHByLmZpbHRlcnMuaGlkZGVuID0gZnVuY3Rpb24gKGVsZW0pIHtcXG5cXHRcXHQvLyBTdXBwb3J0OiBPcGVyYSA8PSAxMi4xMlxcblxcdFxcdC8vIE9wZXJhIHJlcG9ydHMgb2Zmc2V0V2lkdGhzIGFuZCBvZmZzZXRIZWlnaHRzIGxlc3MgdGhhbiB6ZXJvIG9uIHNvbWUgZWxlbWVudHNcXG5cXHRcXHRyZXR1cm4gZWxlbS5vZmZzZXRXaWR0aCA8PSAwICYmIGVsZW0ub2Zmc2V0SGVpZ2h0IDw9IDA7XFxuXFx0fTtcXG5cXHRqUXVlcnkuZXhwci5maWx0ZXJzLnZpc2libGUgPSBmdW5jdGlvbiAoZWxlbSkge1xcblxcdFxcdHJldHVybiAhalF1ZXJ5LmV4cHIuZmlsdGVycy5oaWRkZW4oZWxlbSk7XFxuXFx0fTtcXG5cXG5cXHR2YXIgcjIwID0gLyUyMC9nLFxcblxcdCAgICByYnJhY2tldCA9IC9cXFxcW1xcXFxdJC8sXFxuXFx0ICAgIHJDUkxGID0gL1xcXFxyP1xcXFxuL2csXFxuXFx0ICAgIHJzdWJtaXR0ZXJUeXBlcyA9IC9eKD86c3VibWl0fGJ1dHRvbnxpbWFnZXxyZXNldHxmaWxlKSQvaSxcXG5cXHQgICAgcnN1Ym1pdHRhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8a2V5Z2VuKS9pO1xcblxcblxcdGZ1bmN0aW9uIGJ1aWxkUGFyYW1zKHByZWZpeCwgb2JqLCB0cmFkaXRpb25hbCwgYWRkKSB7XFxuXFx0XFx0dmFyIG5hbWU7XFxuXFxuXFx0XFx0aWYgKGpRdWVyeS5pc0FycmF5KG9iaikpIHtcXG5cXHRcXHRcXHQvLyBTZXJpYWxpemUgYXJyYXkgaXRlbS5cXG5cXHRcXHRcXHRqUXVlcnkuZWFjaChvYmosIGZ1bmN0aW9uIChpLCB2KSB7XFxuXFx0XFx0XFx0XFx0aWYgKHRyYWRpdGlvbmFsIHx8IHJicmFja2V0LnRlc3QocHJlZml4KSkge1xcblxcdFxcdFxcdFxcdFxcdC8vIFRyZWF0IGVhY2ggYXJyYXkgaXRlbSBhcyBhIHNjYWxhci5cXG5cXHRcXHRcXHRcXHRcXHRhZGQocHJlZml4LCB2KTtcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdC8vIEl0ZW0gaXMgbm9uLXNjYWxhciAoYXJyYXkgb3Igb2JqZWN0KSwgZW5jb2RlIGl0cyBudW1lcmljIGluZGV4LlxcblxcdFxcdFxcdFxcdFxcdGJ1aWxkUGFyYW1zKHByZWZpeCArIFxcXCJbXFxcIiArICgodHlwZW9mIHYgPT09IFxcXCJ1bmRlZmluZWRcXFwiID8gXFxcInVuZGVmaW5lZFxcXCIgOiBfdHlwZW9mKHYpKSA9PT0gXFxcIm9iamVjdFxcXCIgPyBpIDogXFxcIlxcXCIpICsgXFxcIl1cXFwiLCB2LCB0cmFkaXRpb25hbCwgYWRkKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0fSBlbHNlIGlmICghdHJhZGl0aW9uYWwgJiYgalF1ZXJ5LnR5cGUob2JqKSA9PT0gXFxcIm9iamVjdFxcXCIpIHtcXG5cXHRcXHRcXHQvLyBTZXJpYWxpemUgb2JqZWN0IGl0ZW0uXFxuXFx0XFx0XFx0Zm9yIChuYW1lIGluIG9iaikge1xcblxcdFxcdFxcdFxcdGJ1aWxkUGFyYW1zKHByZWZpeCArIFxcXCJbXFxcIiArIG5hbWUgKyBcXFwiXVxcXCIsIG9ialtuYW1lXSwgdHJhZGl0aW9uYWwsIGFkZCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0Ly8gU2VyaWFsaXplIHNjYWxhciBpdGVtLlxcblxcdFxcdFxcdGFkZChwcmVmaXgsIG9iaik7XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHQvLyBTZXJpYWxpemUgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cyBvciBhIHNldCBvZlxcblxcdC8vIGtleS92YWx1ZXMgaW50byBhIHF1ZXJ5IHN0cmluZ1xcblxcdGpRdWVyeS5wYXJhbSA9IGZ1bmN0aW9uIChhLCB0cmFkaXRpb25hbCkge1xcblxcdFxcdHZhciBwcmVmaXgsXFxuXFx0XFx0ICAgIHMgPSBbXSxcXG5cXHRcXHQgICAgYWRkID0gZnVuY3Rpb24gYWRkKGtleSwgdmFsdWUpIHtcXG5cXHRcXHRcXHQvLyBJZiB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCBpbnZva2UgaXQgYW5kIHJldHVybiBpdHMgdmFsdWVcXG5cXHRcXHRcXHR2YWx1ZSA9IGpRdWVyeS5pc0Z1bmN0aW9uKHZhbHVlKSA/IHZhbHVlKCkgOiB2YWx1ZSA9PSBudWxsID8gXFxcIlxcXCIgOiB2YWx1ZTtcXG5cXHRcXHRcXHRzW3MubGVuZ3RoXSA9IGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgXFxcIj1cXFwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcXG5cXHRcXHR9O1xcblxcblxcdFxcdC8vIFNldCB0cmFkaXRpb25hbCB0byB0cnVlIGZvciBqUXVlcnkgPD0gMS4zLjIgYmVoYXZpb3IuXFxuXFx0XFx0aWYgKHRyYWRpdGlvbmFsID09PSB1bmRlZmluZWQpIHtcXG5cXHRcXHRcXHR0cmFkaXRpb25hbCA9IGpRdWVyeS5hamF4U2V0dGluZ3MgJiYgalF1ZXJ5LmFqYXhTZXR0aW5ncy50cmFkaXRpb25hbDtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gSWYgYW4gYXJyYXkgd2FzIHBhc3NlZCBpbiwgYXNzdW1lIHRoYXQgaXQgaXMgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cy5cXG5cXHRcXHRpZiAoalF1ZXJ5LmlzQXJyYXkoYSkgfHwgYS5qcXVlcnkgJiYgIWpRdWVyeS5pc1BsYWluT2JqZWN0KGEpKSB7XFxuXFx0XFx0XFx0Ly8gU2VyaWFsaXplIHRoZSBmb3JtIGVsZW1lbnRzXFxuXFx0XFx0XFx0alF1ZXJ5LmVhY2goYSwgZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdGFkZCh0aGlzLm5hbWUsIHRoaXMudmFsdWUpO1xcblxcdFxcdFxcdH0pO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0Ly8gSWYgdHJhZGl0aW9uYWwsIGVuY29kZSB0aGUgXFxcIm9sZFxcXCIgd2F5ICh0aGUgd2F5IDEuMy4yIG9yIG9sZGVyXFxuXFx0XFx0XFx0Ly8gZGlkIGl0KSwgb3RoZXJ3aXNlIGVuY29kZSBwYXJhbXMgcmVjdXJzaXZlbHkuXFxuXFx0XFx0XFx0Zm9yIChwcmVmaXggaW4gYSkge1xcblxcdFxcdFxcdFxcdGJ1aWxkUGFyYW1zKHByZWZpeCwgYVtwcmVmaXhdLCB0cmFkaXRpb25hbCwgYWRkKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFJldHVybiB0aGUgcmVzdWx0aW5nIHNlcmlhbGl6YXRpb25cXG5cXHRcXHRyZXR1cm4gcy5qb2luKFxcXCImXFxcIikucmVwbGFjZShyMjAsIFxcXCIrXFxcIik7XFxuXFx0fTtcXG5cXG5cXHRqUXVlcnkuZm4uZXh0ZW5kKHtcXG5cXHRcXHRzZXJpYWxpemU6IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcXG5cXHRcXHRcXHRyZXR1cm4galF1ZXJ5LnBhcmFtKHRoaXMuc2VyaWFsaXplQXJyYXkoKSk7XFxuXFx0XFx0fSxcXG5cXHRcXHRzZXJpYWxpemVBcnJheTogZnVuY3Rpb24gc2VyaWFsaXplQXJyYXkoKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHQvLyBDYW4gYWRkIHByb3BIb29rIGZvciBcXFwiZWxlbWVudHNcXFwiIHRvIGZpbHRlciBvciBhZGQgZm9ybSBlbGVtZW50c1xcblxcdFxcdFxcdFxcdHZhciBlbGVtZW50cyA9IGpRdWVyeS5wcm9wKHRoaXMsIFxcXCJlbGVtZW50c1xcXCIpO1xcblxcdFxcdFxcdFxcdHJldHVybiBlbGVtZW50cyA/IGpRdWVyeS5tYWtlQXJyYXkoZWxlbWVudHMpIDogdGhpcztcXG5cXHRcXHRcXHR9KS5maWx0ZXIoZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdHZhciB0eXBlID0gdGhpcy50eXBlO1xcblxcblxcdFxcdFxcdFxcdC8vIFVzZSAuaXMoIFxcXCI6ZGlzYWJsZWRcXFwiICkgc28gdGhhdCBmaWVsZHNldFtkaXNhYmxlZF0gd29ya3NcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5uYW1lICYmICFqUXVlcnkodGhpcykuaXMoXFxcIjpkaXNhYmxlZFxcXCIpICYmIHJzdWJtaXR0YWJsZS50ZXN0KHRoaXMubm9kZU5hbWUpICYmICFyc3VibWl0dGVyVHlwZXMudGVzdCh0eXBlKSAmJiAodGhpcy5jaGVja2VkIHx8ICFyY2hlY2thYmxlVHlwZS50ZXN0KHR5cGUpKTtcXG5cXHRcXHRcXHR9KS5tYXAoZnVuY3Rpb24gKGksIGVsZW0pIHtcXG5cXHRcXHRcXHRcXHR2YXIgdmFsID0galF1ZXJ5KHRoaXMpLnZhbCgpO1xcblxcblxcdFxcdFxcdFxcdHJldHVybiB2YWwgPT0gbnVsbCA/IG51bGwgOiBqUXVlcnkuaXNBcnJheSh2YWwpID8galF1ZXJ5Lm1hcCh2YWwsIGZ1bmN0aW9uICh2YWwpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZShyQ1JMRiwgXFxcIlxcXFxyXFxcXG5cXFwiKSB9O1xcblxcdFxcdFxcdFxcdH0pIDogeyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZShyQ1JMRiwgXFxcIlxcXFxyXFxcXG5cXFwiKSB9O1xcblxcdFxcdFxcdH0pLmdldCgpO1xcblxcdFxcdH1cXG5cXHR9KTtcXG5cXG5cXHRqUXVlcnkuYWpheFNldHRpbmdzLnhociA9IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHR0cnkge1xcblxcdFxcdFxcdHJldHVybiBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcXG5cXHRcXHR9IGNhdGNoIChlKSB7fVxcblxcdH07XFxuXFxuXFx0dmFyIHhocklkID0gMCxcXG5cXHQgICAgeGhyQ2FsbGJhY2tzID0ge30sXFxuXFx0ICAgIHhoclN1Y2Nlc3NTdGF0dXMgPSB7XFxuXFx0XFx0Ly8gZmlsZSBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyBjb2RlIDAsIGFzc3VtZSAyMDBcXG5cXHRcXHQwOiAyMDAsXFxuXFx0XFx0Ly8gU3VwcG9ydDogSUU5XFxuXFx0XFx0Ly8gIzE0NTA6IHNvbWV0aW1lcyBJRSByZXR1cm5zIDEyMjMgd2hlbiBpdCBzaG91bGQgYmUgMjA0XFxuXFx0XFx0MTIyMzogMjA0XFxuXFx0fSxcXG5cXHQgICAgeGhyU3VwcG9ydGVkID0galF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIoKTtcXG5cXG5cXHQvLyBTdXBwb3J0OiBJRTlcXG5cXHQvLyBPcGVuIHJlcXVlc3RzIG11c3QgYmUgbWFudWFsbHkgYWJvcnRlZCBvbiB1bmxvYWQgKCM1MjgwKVxcblxcdC8vIFNlZSBodHRwczovL3N1cHBvcnQubWljcm9zb2Z0LmNvbS9rYi8yODU2NzQ2IGZvciBtb3JlIGluZm9cXG5cXHRpZiAod2luZG93LmF0dGFjaEV2ZW50KSB7XFxuXFx0XFx0d2luZG93LmF0dGFjaEV2ZW50KFxcXCJvbnVubG9hZFxcXCIsIGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRmb3IgKHZhciBrZXkgaW4geGhyQ2FsbGJhY2tzKSB7XFxuXFx0XFx0XFx0XFx0eGhyQ2FsbGJhY2tzW2tleV0oKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSk7XFxuXFx0fVxcblxcblxcdHN1cHBvcnQuY29ycyA9ICEheGhyU3VwcG9ydGVkICYmIFxcXCJ3aXRoQ3JlZGVudGlhbHNcXFwiIGluIHhoclN1cHBvcnRlZDtcXG5cXHRzdXBwb3J0LmFqYXggPSB4aHJTdXBwb3J0ZWQgPSAhIXhoclN1cHBvcnRlZDtcXG5cXG5cXHRqUXVlcnkuYWpheFRyYW5zcG9ydChmdW5jdGlvbiAob3B0aW9ucykge1xcblxcdFxcdHZhciBfY2FsbGJhY2s7XFxuXFxuXFx0XFx0Ly8gQ3Jvc3MgZG9tYWluIG9ubHkgYWxsb3dlZCBpZiBzdXBwb3J0ZWQgdGhyb3VnaCBYTUxIdHRwUmVxdWVzdFxcblxcdFxcdGlmIChzdXBwb3J0LmNvcnMgfHwgeGhyU3VwcG9ydGVkICYmICFvcHRpb25zLmNyb3NzRG9tYWluKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHtcXG5cXHRcXHRcXHRcXHRzZW5kOiBmdW5jdGlvbiBzZW5kKGhlYWRlcnMsIGNvbXBsZXRlKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGksXFxuXFx0XFx0XFx0XFx0XFx0ICAgIHhociA9IG9wdGlvbnMueGhyKCksXFxuXFx0XFx0XFx0XFx0XFx0ICAgIGlkID0gKyt4aHJJZDtcXG5cXG5cXHRcXHRcXHRcXHRcXHR4aHIub3BlbihvcHRpb25zLnR5cGUsIG9wdGlvbnMudXJsLCBvcHRpb25zLmFzeW5jLCBvcHRpb25zLnVzZXJuYW1lLCBvcHRpb25zLnBhc3N3b3JkKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBBcHBseSBjdXN0b20gZmllbGRzIGlmIHByb3ZpZGVkXFxuXFx0XFx0XFx0XFx0XFx0aWYgKG9wdGlvbnMueGhyRmllbGRzKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Zm9yIChpIGluIG9wdGlvbnMueGhyRmllbGRzKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0eGhyW2ldID0gb3B0aW9ucy54aHJGaWVsZHNbaV07XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBPdmVycmlkZSBtaW1lIHR5cGUgaWYgbmVlZGVkXFxuXFx0XFx0XFx0XFx0XFx0aWYgKG9wdGlvbnMubWltZVR5cGUgJiYgeGhyLm92ZXJyaWRlTWltZVR5cGUpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR4aHIub3ZlcnJpZGVNaW1lVHlwZShvcHRpb25zLm1pbWVUeXBlKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gWC1SZXF1ZXN0ZWQtV2l0aCBoZWFkZXJcXG5cXHRcXHRcXHRcXHRcXHQvLyBGb3IgY3Jvc3MtZG9tYWluIHJlcXVlc3RzLCBzZWVpbmcgYXMgY29uZGl0aW9ucyBmb3IgYSBwcmVmbGlnaHQgYXJlXFxuXFx0XFx0XFx0XFx0XFx0Ly8gYWtpbiB0byBhIGppZ3NhdyBwdXp6bGUsIHdlIHNpbXBseSBuZXZlciBzZXQgaXQgdG8gYmUgc3VyZS5cXG5cXHRcXHRcXHRcXHRcXHQvLyAoaXQgY2FuIGFsd2F5cyBiZSBzZXQgb24gYSBwZXItcmVxdWVzdCBiYXNpcyBvciBldmVuIHVzaW5nIGFqYXhTZXR1cClcXG5cXHRcXHRcXHRcXHRcXHQvLyBGb3Igc2FtZS1kb21haW4gcmVxdWVzdHMsIHdvbid0IGNoYW5nZSBoZWFkZXIgaWYgYWxyZWFkeSBwcm92aWRlZC5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIW9wdGlvbnMuY3Jvc3NEb21haW4gJiYgIWhlYWRlcnNbXFxcIlgtUmVxdWVzdGVkLVdpdGhcXFwiXSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGhlYWRlcnNbXFxcIlgtUmVxdWVzdGVkLVdpdGhcXFwiXSA9IFxcXCJYTUxIdHRwUmVxdWVzdFxcXCI7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdC8vIFNldCBoZWFkZXJzXFxuXFx0XFx0XFx0XFx0XFx0Zm9yIChpIGluIGhlYWRlcnMpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR4aHIuc2V0UmVxdWVzdEhlYWRlcihpLCBoZWFkZXJzW2ldKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gQ2FsbGJhY2tcXG5cXHRcXHRcXHRcXHRcXHRfY2FsbGJhY2sgPSBmdW5jdGlvbiBjYWxsYmFjayh0eXBlKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoX2NhbGxiYWNrKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGVsZXRlIHhockNhbGxiYWNrc1tpZF07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0X2NhbGxiYWNrID0geGhyLm9ubG9hZCA9IHhoci5vbmVycm9yID0gbnVsbDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAodHlwZSA9PT0gXFxcImFib3J0XFxcIikge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHhoci5hYm9ydCgpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSBpZiAodHlwZSA9PT0gXFxcImVycm9yXFxcIikge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGNvbXBsZXRlKFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIGZpbGU6IHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIDA7IHNlZSAjODYwNSwgIzE0MjA3XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0eGhyLnN0YXR1cywgeGhyLnN0YXR1c1RleHQpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Y29tcGxldGUoeGhyU3VjY2Vzc1N0YXR1c1t4aHIuc3RhdHVzXSB8fCB4aHIuc3RhdHVzLCB4aHIuc3RhdHVzVGV4dCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBTdXBwb3J0OiBJRTlcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBBY2Nlc3NpbmcgYmluYXJ5LWRhdGEgcmVzcG9uc2VUZXh0IHRocm93cyBhbiBleGNlcHRpb25cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyAoIzExNDI2KVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHR5cGVvZiB4aHIucmVzcG9uc2VUZXh0ID09PSBcXFwic3RyaW5nXFxcIiA/IHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0ZXh0OiB4aHIucmVzcG9uc2VUZXh0XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fSA6IHVuZGVmaW5lZCwgeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH07XFxuXFx0XFx0XFx0XFx0XFx0fTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBMaXN0ZW4gdG8gZXZlbnRzXFxuXFx0XFx0XFx0XFx0XFx0eGhyLm9ubG9hZCA9IF9jYWxsYmFjaygpO1xcblxcdFxcdFxcdFxcdFxcdHhoci5vbmVycm9yID0gX2NhbGxiYWNrKFxcXCJlcnJvclxcXCIpO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIENyZWF0ZSB0aGUgYWJvcnQgY2FsbGJhY2tcXG5cXHRcXHRcXHRcXHRcXHRfY2FsbGJhY2sgPSB4aHJDYWxsYmFja3NbaWRdID0gX2NhbGxiYWNrKFxcXCJhYm9ydFxcXCIpO1xcblxcblxcdFxcdFxcdFxcdFxcdHRyeSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gRG8gc2VuZCB0aGUgcmVxdWVzdCAodGhpcyBtYXkgcmFpc2UgYW4gZXhjZXB0aW9uKVxcblxcdFxcdFxcdFxcdFxcdFxcdHhoci5zZW5kKG9wdGlvbnMuaGFzQ29udGVudCAmJiBvcHRpb25zLmRhdGEgfHwgbnVsbCk7XFxuXFx0XFx0XFx0XFx0XFx0fSBjYXRjaCAoZSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdC8vICMxNDY4MzogT25seSByZXRocm93IGlmIHRoaXMgaGFzbid0IGJlZW4gbm90aWZpZWQgYXMgYW4gZXJyb3IgeWV0XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKF9jYWxsYmFjaykge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRocm93IGU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdFxcdGFib3J0OiBmdW5jdGlvbiBhYm9ydCgpIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoX2NhbGxiYWNrKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0X2NhbGxiYWNrKCk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9O1xcblxcdFxcdH1cXG5cXHR9KTtcXG5cXG5cXHQvLyBJbnN0YWxsIHNjcmlwdCBkYXRhVHlwZVxcblxcdGpRdWVyeS5hamF4U2V0dXAoe1xcblxcdFxcdGFjY2VwdHM6IHtcXG5cXHRcXHRcXHRzY3JpcHQ6IFxcXCJ0ZXh0L2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2VjbWFzY3JpcHQsIGFwcGxpY2F0aW9uL3gtZWNtYXNjcmlwdFxcXCJcXG5cXHRcXHR9LFxcblxcdFxcdGNvbnRlbnRzOiB7XFxuXFx0XFx0XFx0c2NyaXB0OiAvKD86amF2YXxlY21hKXNjcmlwdC9cXG5cXHRcXHR9LFxcblxcdFxcdGNvbnZlcnRlcnM6IHtcXG5cXHRcXHRcXHRcXFwidGV4dCBzY3JpcHRcXFwiOiBmdW5jdGlvbiB0ZXh0U2NyaXB0KHRleHQpIHtcXG5cXHRcXHRcXHRcXHRqUXVlcnkuZ2xvYmFsRXZhbCh0ZXh0KTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGV4dDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH0pO1xcblxcblxcdC8vIEhhbmRsZSBjYWNoZSdzIHNwZWNpYWwgY2FzZSBhbmQgY3Jvc3NEb21haW5cXG5cXHRqUXVlcnkuYWpheFByZWZpbHRlcihcXFwic2NyaXB0XFxcIiwgZnVuY3Rpb24gKHMpIHtcXG5cXHRcXHRpZiAocy5jYWNoZSA9PT0gdW5kZWZpbmVkKSB7XFxuXFx0XFx0XFx0cy5jYWNoZSA9IGZhbHNlO1xcblxcdFxcdH1cXG5cXHRcXHRpZiAocy5jcm9zc0RvbWFpbikge1xcblxcdFxcdFxcdHMudHlwZSA9IFxcXCJHRVRcXFwiO1xcblxcdFxcdH1cXG5cXHR9KTtcXG5cXG5cXHQvLyBCaW5kIHNjcmlwdCB0YWcgaGFjayB0cmFuc3BvcnRcXG5cXHRqUXVlcnkuYWpheFRyYW5zcG9ydChcXFwic2NyaXB0XFxcIiwgZnVuY3Rpb24gKHMpIHtcXG5cXHRcXHQvLyBUaGlzIHRyYW5zcG9ydCBvbmx5IGRlYWxzIHdpdGggY3Jvc3MgZG9tYWluIHJlcXVlc3RzXFxuXFx0XFx0aWYgKHMuY3Jvc3NEb21haW4pIHtcXG5cXHRcXHRcXHR2YXIgc2NyaXB0LCBfY2FsbGJhY2syO1xcblxcdFxcdFxcdHJldHVybiB7XFxuXFx0XFx0XFx0XFx0c2VuZDogZnVuY3Rpb24gc2VuZChfLCBjb21wbGV0ZSkge1xcblxcdFxcdFxcdFxcdFxcdHNjcmlwdCA9IGpRdWVyeShcXFwiPHNjcmlwdD5cXFwiKS5wcm9wKHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRhc3luYzogdHJ1ZSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRjaGFyc2V0OiBzLnNjcmlwdENoYXJzZXQsXFxuXFx0XFx0XFx0XFx0XFx0XFx0c3JjOiBzLnVybFxcblxcdFxcdFxcdFxcdFxcdH0pLm9uKFxcXCJsb2FkIGVycm9yXFxcIiwgX2NhbGxiYWNrMiA9IGZ1bmN0aW9uIGNhbGxiYWNrKGV2dCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHNjcmlwdC5yZW1vdmUoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRfY2FsbGJhY2syID0gbnVsbDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoZXZ0KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y29tcGxldGUoZXZ0LnR5cGUgPT09IFxcXCJlcnJvclxcXCIgPyA0MDQgOiAyMDAsIGV2dC50eXBlKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0XFx0XFx0ZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzY3JpcHRbMF0pO1xcblxcdFxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0XFx0YWJvcnQ6IGZ1bmN0aW9uIGFib3J0KCkge1xcblxcdFxcdFxcdFxcdFxcdGlmIChfY2FsbGJhY2syKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0X2NhbGxiYWNrMigpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fTtcXG5cXHRcXHR9XFxuXFx0fSk7XFxuXFxuXFx0dmFyIG9sZENhbGxiYWNrcyA9IFtdLFxcblxcdCAgICByanNvbnAgPSAvKD0pXFxcXD8oPz0mfCQpfFxcXFw/XFxcXD8vO1xcblxcblxcdC8vIERlZmF1bHQganNvbnAgc2V0dGluZ3NcXG5cXHRqUXVlcnkuYWpheFNldHVwKHtcXG5cXHRcXHRqc29ucDogXFxcImNhbGxiYWNrXFxcIixcXG5cXHRcXHRqc29ucENhbGxiYWNrOiBmdW5jdGlvbiBqc29ucENhbGxiYWNrKCkge1xcblxcdFxcdFxcdHZhciBjYWxsYmFjayA9IG9sZENhbGxiYWNrcy5wb3AoKSB8fCBqUXVlcnkuZXhwYW5kbyArIFxcXCJfXFxcIiArIG5vbmNlKys7XFxuXFx0XFx0XFx0dGhpc1tjYWxsYmFja10gPSB0cnVlO1xcblxcdFxcdFxcdHJldHVybiBjYWxsYmFjaztcXG5cXHRcXHR9XFxuXFx0fSk7XFxuXFxuXFx0Ly8gRGV0ZWN0LCBub3JtYWxpemUgb3B0aW9ucyBhbmQgaW5zdGFsbCBjYWxsYmFja3MgZm9yIGpzb25wIHJlcXVlc3RzXFxuXFx0alF1ZXJ5LmFqYXhQcmVmaWx0ZXIoXFxcImpzb24ganNvbnBcXFwiLCBmdW5jdGlvbiAocywgb3JpZ2luYWxTZXR0aW5ncywganFYSFIpIHtcXG5cXG5cXHRcXHR2YXIgY2FsbGJhY2tOYW1lLFxcblxcdFxcdCAgICBvdmVyd3JpdHRlbixcXG5cXHRcXHQgICAgcmVzcG9uc2VDb250YWluZXIsXFxuXFx0XFx0ICAgIGpzb25Qcm9wID0gcy5qc29ucCAhPT0gZmFsc2UgJiYgKHJqc29ucC50ZXN0KHMudXJsKSA/IFxcXCJ1cmxcXFwiIDogdHlwZW9mIHMuZGF0YSA9PT0gXFxcInN0cmluZ1xcXCIgJiYgIShzLmNvbnRlbnRUeXBlIHx8IFxcXCJcXFwiKS5pbmRleE9mKFxcXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcXFwiKSAmJiByanNvbnAudGVzdChzLmRhdGEpICYmIFxcXCJkYXRhXFxcIik7XFxuXFxuXFx0XFx0Ly8gSGFuZGxlIGlmZiB0aGUgZXhwZWN0ZWQgZGF0YSB0eXBlIGlzIFxcXCJqc29ucFxcXCIgb3Igd2UgaGF2ZSBhIHBhcmFtZXRlciB0byBzZXRcXG5cXHRcXHRpZiAoanNvblByb3AgfHwgcy5kYXRhVHlwZXNbMF0gPT09IFxcXCJqc29ucFxcXCIpIHtcXG5cXG5cXHRcXHRcXHQvLyBHZXQgY2FsbGJhY2sgbmFtZSwgcmVtZW1iZXJpbmcgcHJlZXhpc3RpbmcgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIGl0XFxuXFx0XFx0XFx0Y2FsbGJhY2tOYW1lID0gcy5qc29ucENhbGxiYWNrID0galF1ZXJ5LmlzRnVuY3Rpb24ocy5qc29ucENhbGxiYWNrKSA/IHMuanNvbnBDYWxsYmFjaygpIDogcy5qc29ucENhbGxiYWNrO1xcblxcblxcdFxcdFxcdC8vIEluc2VydCBjYWxsYmFjayBpbnRvIHVybCBvciBmb3JtIGRhdGFcXG5cXHRcXHRcXHRpZiAoanNvblByb3ApIHtcXG5cXHRcXHRcXHRcXHRzW2pzb25Qcm9wXSA9IHNbanNvblByb3BdLnJlcGxhY2Uocmpzb25wLCBcXFwiJDFcXFwiICsgY2FsbGJhY2tOYW1lKTtcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKHMuanNvbnAgIT09IGZhbHNlKSB7XFxuXFx0XFx0XFx0XFx0cy51cmwgKz0gKHJxdWVyeS50ZXN0KHMudXJsKSA/IFxcXCImXFxcIiA6IFxcXCI/XFxcIikgKyBzLmpzb25wICsgXFxcIj1cXFwiICsgY2FsbGJhY2tOYW1lO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBVc2UgZGF0YSBjb252ZXJ0ZXIgdG8gcmV0cmlldmUganNvbiBhZnRlciBzY3JpcHQgZXhlY3V0aW9uXFxuXFx0XFx0XFx0cy5jb252ZXJ0ZXJzW1xcXCJzY3JpcHQganNvblxcXCJdID0gZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdGlmICghcmVzcG9uc2VDb250YWluZXIpIHtcXG5cXHRcXHRcXHRcXHRcXHRqUXVlcnkuZXJyb3IoY2FsbGJhY2tOYW1lICsgXFxcIiB3YXMgbm90IGNhbGxlZFxcXCIpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRyZXR1cm4gcmVzcG9uc2VDb250YWluZXJbMF07XFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHRcXHQvLyBmb3JjZSBqc29uIGRhdGFUeXBlXFxuXFx0XFx0XFx0cy5kYXRhVHlwZXNbMF0gPSBcXFwianNvblxcXCI7XFxuXFxuXFx0XFx0XFx0Ly8gSW5zdGFsbCBjYWxsYmFja1xcblxcdFxcdFxcdG92ZXJ3cml0dGVuID0gd2luZG93W2NhbGxiYWNrTmFtZV07XFxuXFx0XFx0XFx0d2luZG93W2NhbGxiYWNrTmFtZV0gPSBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0cmVzcG9uc2VDb250YWluZXIgPSBhcmd1bWVudHM7XFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHRcXHQvLyBDbGVhbi11cCBmdW5jdGlvbiAoZmlyZXMgYWZ0ZXIgY29udmVydGVycylcXG5cXHRcXHRcXHRqcVhIUi5hbHdheXMoZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdC8vIFJlc3RvcmUgcHJlZXhpc3RpbmcgdmFsdWVcXG5cXHRcXHRcXHRcXHR3aW5kb3dbY2FsbGJhY2tOYW1lXSA9IG92ZXJ3cml0dGVuO1xcblxcblxcdFxcdFxcdFxcdC8vIFNhdmUgYmFjayBhcyBmcmVlXFxuXFx0XFx0XFx0XFx0aWYgKHNbY2FsbGJhY2tOYW1lXSkge1xcblxcdFxcdFxcdFxcdFxcdC8vIG1ha2Ugc3VyZSB0aGF0IHJlLXVzaW5nIHRoZSBvcHRpb25zIGRvZXNuJ3Qgc2NyZXcgdGhpbmdzIGFyb3VuZFxcblxcdFxcdFxcdFxcdFxcdHMuanNvbnBDYWxsYmFjayA9IG9yaWdpbmFsU2V0dGluZ3MuanNvbnBDYWxsYmFjaztcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBzYXZlIHRoZSBjYWxsYmFjayBuYW1lIGZvciBmdXR1cmUgdXNlXFxuXFx0XFx0XFx0XFx0XFx0b2xkQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2tOYW1lKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQ2FsbCBpZiBpdCB3YXMgYSBmdW5jdGlvbiBhbmQgd2UgaGF2ZSBhIHJlc3BvbnNlXFxuXFx0XFx0XFx0XFx0aWYgKHJlc3BvbnNlQ29udGFpbmVyICYmIGpRdWVyeS5pc0Z1bmN0aW9uKG92ZXJ3cml0dGVuKSkge1xcblxcdFxcdFxcdFxcdFxcdG92ZXJ3cml0dGVuKHJlc3BvbnNlQ29udGFpbmVyWzBdKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0cmVzcG9uc2VDb250YWluZXIgPSBvdmVyd3JpdHRlbiA9IHVuZGVmaW5lZDtcXG5cXHRcXHRcXHR9KTtcXG5cXG5cXHRcXHRcXHQvLyBEZWxlZ2F0ZSB0byBzY3JpcHRcXG5cXHRcXHRcXHRyZXR1cm4gXFxcInNjcmlwdFxcXCI7XFxuXFx0XFx0fVxcblxcdH0pO1xcblxcblxcdC8vIGRhdGE6IHN0cmluZyBvZiBodG1sXFxuXFx0Ly8gY29udGV4dCAob3B0aW9uYWwpOiBJZiBzcGVjaWZpZWQsIHRoZSBmcmFnbWVudCB3aWxsIGJlIGNyZWF0ZWQgaW4gdGhpcyBjb250ZXh0LCBkZWZhdWx0cyB0byBkb2N1bWVudFxcblxcdC8vIGtlZXBTY3JpcHRzIChvcHRpb25hbCk6IElmIHRydWUsIHdpbGwgaW5jbHVkZSBzY3JpcHRzIHBhc3NlZCBpbiB0aGUgaHRtbCBzdHJpbmdcXG5cXHRqUXVlcnkucGFyc2VIVE1MID0gZnVuY3Rpb24gKGRhdGEsIGNvbnRleHQsIGtlZXBTY3JpcHRzKSB7XFxuXFx0XFx0aWYgKCFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSBcXFwic3RyaW5nXFxcIikge1xcblxcdFxcdFxcdHJldHVybiBudWxsO1xcblxcdFxcdH1cXG5cXHRcXHRpZiAodHlwZW9mIGNvbnRleHQgPT09IFxcXCJib29sZWFuXFxcIikge1xcblxcdFxcdFxcdGtlZXBTY3JpcHRzID0gY29udGV4dDtcXG5cXHRcXHRcXHRjb250ZXh0ID0gZmFsc2U7XFxuXFx0XFx0fVxcblxcdFxcdGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xcblxcblxcdFxcdHZhciBwYXJzZWQgPSByc2luZ2xlVGFnLmV4ZWMoZGF0YSksXFxuXFx0XFx0ICAgIHNjcmlwdHMgPSAha2VlcFNjcmlwdHMgJiYgW107XFxuXFxuXFx0XFx0Ly8gU2luZ2xlIHRhZ1xcblxcdFxcdGlmIChwYXJzZWQpIHtcXG5cXHRcXHRcXHRyZXR1cm4gW2NvbnRleHQuY3JlYXRlRWxlbWVudChwYXJzZWRbMV0pXTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cGFyc2VkID0galF1ZXJ5LmJ1aWxkRnJhZ21lbnQoW2RhdGFdLCBjb250ZXh0LCBzY3JpcHRzKTtcXG5cXG5cXHRcXHRpZiAoc2NyaXB0cyAmJiBzY3JpcHRzLmxlbmd0aCkge1xcblxcdFxcdFxcdGpRdWVyeShzY3JpcHRzKS5yZW1vdmUoKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIGpRdWVyeS5tZXJnZShbXSwgcGFyc2VkLmNoaWxkTm9kZXMpO1xcblxcdH07XFxuXFxuXFx0Ly8gS2VlcCBhIGNvcHkgb2YgdGhlIG9sZCBsb2FkIG1ldGhvZFxcblxcdHZhciBfbG9hZCA9IGpRdWVyeS5mbi5sb2FkO1xcblxcblxcdC8qKlxcbiAgKiBMb2FkIGEgdXJsIGludG8gYSBwYWdlXFxuICAqL1xcblxcdGpRdWVyeS5mbi5sb2FkID0gZnVuY3Rpb24gKHVybCwgcGFyYW1zLCBjYWxsYmFjaykge1xcblxcdFxcdGlmICh0eXBlb2YgdXJsICE9PSBcXFwic3RyaW5nXFxcIiAmJiBfbG9hZCkge1xcblxcdFxcdFxcdHJldHVybiBfbG9hZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcblxcdFxcdH1cXG5cXG5cXHRcXHR2YXIgc2VsZWN0b3IsXFxuXFx0XFx0ICAgIHR5cGUsXFxuXFx0XFx0ICAgIHJlc3BvbnNlLFxcblxcdFxcdCAgICBzZWxmID0gdGhpcyxcXG5cXHRcXHQgICAgb2ZmID0gdXJsLmluZGV4T2YoXFxcIiBcXFwiKTtcXG5cXG5cXHRcXHRpZiAob2ZmID49IDApIHtcXG5cXHRcXHRcXHRzZWxlY3RvciA9IGpRdWVyeS50cmltKHVybC5zbGljZShvZmYpKTtcXG5cXHRcXHRcXHR1cmwgPSB1cmwuc2xpY2UoMCwgb2ZmKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gSWYgaXQncyBhIGZ1bmN0aW9uXFxuXFx0XFx0aWYgKGpRdWVyeS5pc0Z1bmN0aW9uKHBhcmFtcykpIHtcXG5cXG5cXHRcXHRcXHQvLyBXZSBhc3N1bWUgdGhhdCBpdCdzIHRoZSBjYWxsYmFja1xcblxcdFxcdFxcdGNhbGxiYWNrID0gcGFyYW1zO1xcblxcdFxcdFxcdHBhcmFtcyA9IHVuZGVmaW5lZDtcXG5cXG5cXHRcXHRcXHQvLyBPdGhlcndpc2UsIGJ1aWxkIGEgcGFyYW0gc3RyaW5nXFxuXFx0XFx0fSBlbHNlIGlmIChwYXJhbXMgJiYgKHR5cGVvZiBwYXJhbXMgPT09IFxcXCJ1bmRlZmluZWRcXFwiID8gXFxcInVuZGVmaW5lZFxcXCIgOiBfdHlwZW9mKHBhcmFtcykpID09PSBcXFwib2JqZWN0XFxcIikge1xcblxcdFxcdFxcdHR5cGUgPSBcXFwiUE9TVFxcXCI7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIElmIHdlIGhhdmUgZWxlbWVudHMgdG8gbW9kaWZ5LCBtYWtlIHRoZSByZXF1ZXN0XFxuXFx0XFx0aWYgKHNlbGYubGVuZ3RoID4gMCkge1xcblxcdFxcdFxcdGpRdWVyeS5hamF4KHtcXG5cXHRcXHRcXHRcXHR1cmw6IHVybCxcXG5cXG5cXHRcXHRcXHRcXHQvLyBpZiBcXFwidHlwZVxcXCIgdmFyaWFibGUgaXMgdW5kZWZpbmVkLCB0aGVuIFxcXCJHRVRcXFwiIG1ldGhvZCB3aWxsIGJlIHVzZWRcXG5cXHRcXHRcXHRcXHR0eXBlOiB0eXBlLFxcblxcdFxcdFxcdFxcdGRhdGFUeXBlOiBcXFwiaHRtbFxcXCIsXFxuXFx0XFx0XFx0XFx0ZGF0YTogcGFyYW1zXFxuXFx0XFx0XFx0fSkuZG9uZShmdW5jdGlvbiAocmVzcG9uc2VUZXh0KSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gU2F2ZSByZXNwb25zZSBmb3IgdXNlIGluIGNvbXBsZXRlIGNhbGxiYWNrXFxuXFx0XFx0XFx0XFx0cmVzcG9uc2UgPSBhcmd1bWVudHM7XFxuXFxuXFx0XFx0XFx0XFx0c2VsZi5odG1sKHNlbGVjdG9yID9cXG5cXG5cXHRcXHRcXHRcXHQvLyBJZiBhIHNlbGVjdG9yIHdhcyBzcGVjaWZpZWQsIGxvY2F0ZSB0aGUgcmlnaHQgZWxlbWVudHMgaW4gYSBkdW1teSBkaXZcXG5cXHRcXHRcXHRcXHQvLyBFeGNsdWRlIHNjcmlwdHMgdG8gYXZvaWQgSUUgJ1Blcm1pc3Npb24gRGVuaWVkJyBlcnJvcnNcXG5cXHRcXHRcXHRcXHRqUXVlcnkoXFxcIjxkaXY+XFxcIikuYXBwZW5kKGpRdWVyeS5wYXJzZUhUTUwocmVzcG9uc2VUZXh0KSkuZmluZChzZWxlY3RvcikgOlxcblxcblxcdFxcdFxcdFxcdC8vIE90aGVyd2lzZSB1c2UgdGhlIGZ1bGwgcmVzdWx0XFxuXFx0XFx0XFx0XFx0cmVzcG9uc2VUZXh0KTtcXG5cXHRcXHRcXHR9KS5jb21wbGV0ZShjYWxsYmFjayAmJiBmdW5jdGlvbiAoanFYSFIsIHN0YXR1cykge1xcblxcdFxcdFxcdFxcdHNlbGYuZWFjaChjYWxsYmFjaywgcmVzcG9uc2UgfHwgW2pxWEhSLnJlc3BvbnNlVGV4dCwgc3RhdHVzLCBqcVhIUl0pO1xcblxcdFxcdFxcdH0pO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gdGhpcztcXG5cXHR9O1xcblxcblxcdC8vIEF0dGFjaCBhIGJ1bmNoIG9mIGZ1bmN0aW9ucyBmb3IgaGFuZGxpbmcgY29tbW9uIEFKQVggZXZlbnRzXFxuXFx0alF1ZXJ5LmVhY2goW1xcXCJhamF4U3RhcnRcXFwiLCBcXFwiYWpheFN0b3BcXFwiLCBcXFwiYWpheENvbXBsZXRlXFxcIiwgXFxcImFqYXhFcnJvclxcXCIsIFxcXCJhamF4U3VjY2Vzc1xcXCIsIFxcXCJhamF4U2VuZFxcXCJdLCBmdW5jdGlvbiAoaSwgdHlwZSkge1xcblxcdFxcdGpRdWVyeS5mblt0eXBlXSA9IGZ1bmN0aW9uIChmbikge1xcblxcdFxcdFxcdHJldHVybiB0aGlzLm9uKHR5cGUsIGZuKTtcXG5cXHRcXHR9O1xcblxcdH0pO1xcblxcblxcdGpRdWVyeS5leHByLmZpbHRlcnMuYW5pbWF0ZWQgPSBmdW5jdGlvbiAoZWxlbSkge1xcblxcdFxcdHJldHVybiBqUXVlcnkuZ3JlcChqUXVlcnkudGltZXJzLCBmdW5jdGlvbiAoZm4pIHtcXG5cXHRcXHRcXHRyZXR1cm4gZWxlbSA9PT0gZm4uZWxlbTtcXG5cXHRcXHR9KS5sZW5ndGg7XFxuXFx0fTtcXG5cXG5cXHR2YXIgZG9jRWxlbSA9IHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XFxuXFxuXFx0LyoqXFxuICAqIEdldHMgYSB3aW5kb3cgZnJvbSBhbiBlbGVtZW50XFxuICAqL1xcblxcdGZ1bmN0aW9uIGdldFdpbmRvdyhlbGVtKSB7XFxuXFx0XFx0cmV0dXJuIGpRdWVyeS5pc1dpbmRvdyhlbGVtKSA/IGVsZW0gOiBlbGVtLm5vZGVUeXBlID09PSA5ICYmIGVsZW0uZGVmYXVsdFZpZXc7XFxuXFx0fVxcblxcblxcdGpRdWVyeS5vZmZzZXQgPSB7XFxuXFx0XFx0c2V0T2Zmc2V0OiBmdW5jdGlvbiBzZXRPZmZzZXQoZWxlbSwgb3B0aW9ucywgaSkge1xcblxcdFxcdFxcdHZhciBjdXJQb3NpdGlvbixcXG5cXHRcXHRcXHQgICAgY3VyTGVmdCxcXG5cXHRcXHRcXHQgICAgY3VyQ1NTVG9wLFxcblxcdFxcdFxcdCAgICBjdXJUb3AsXFxuXFx0XFx0XFx0ICAgIGN1ck9mZnNldCxcXG5cXHRcXHRcXHQgICAgY3VyQ1NTTGVmdCxcXG5cXHRcXHRcXHQgICAgY2FsY3VsYXRlUG9zaXRpb24sXFxuXFx0XFx0XFx0ICAgIHBvc2l0aW9uID0galF1ZXJ5LmNzcyhlbGVtLCBcXFwicG9zaXRpb25cXFwiKSxcXG5cXHRcXHRcXHQgICAgY3VyRWxlbSA9IGpRdWVyeShlbGVtKSxcXG5cXHRcXHRcXHQgICAgcHJvcHMgPSB7fTtcXG5cXG5cXHRcXHRcXHQvLyBTZXQgcG9zaXRpb24gZmlyc3QsIGluLWNhc2UgdG9wL2xlZnQgYXJlIHNldCBldmVuIG9uIHN0YXRpYyBlbGVtXFxuXFx0XFx0XFx0aWYgKHBvc2l0aW9uID09PSBcXFwic3RhdGljXFxcIikge1xcblxcdFxcdFxcdFxcdGVsZW0uc3R5bGUucG9zaXRpb24gPSBcXFwicmVsYXRpdmVcXFwiO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRjdXJPZmZzZXQgPSBjdXJFbGVtLm9mZnNldCgpO1xcblxcdFxcdFxcdGN1ckNTU1RvcCA9IGpRdWVyeS5jc3MoZWxlbSwgXFxcInRvcFxcXCIpO1xcblxcdFxcdFxcdGN1ckNTU0xlZnQgPSBqUXVlcnkuY3NzKGVsZW0sIFxcXCJsZWZ0XFxcIik7XFxuXFx0XFx0XFx0Y2FsY3VsYXRlUG9zaXRpb24gPSAocG9zaXRpb24gPT09IFxcXCJhYnNvbHV0ZVxcXCIgfHwgcG9zaXRpb24gPT09IFxcXCJmaXhlZFxcXCIpICYmIChjdXJDU1NUb3AgKyBjdXJDU1NMZWZ0KS5pbmRleE9mKFxcXCJhdXRvXFxcIikgPiAtMTtcXG5cXG5cXHRcXHRcXHQvLyBOZWVkIHRvIGJlIGFibGUgdG8gY2FsY3VsYXRlIHBvc2l0aW9uIGlmIGVpdGhlclxcblxcdFxcdFxcdC8vIHRvcCBvciBsZWZ0IGlzIGF1dG8gYW5kIHBvc2l0aW9uIGlzIGVpdGhlciBhYnNvbHV0ZSBvciBmaXhlZFxcblxcdFxcdFxcdGlmIChjYWxjdWxhdGVQb3NpdGlvbikge1xcblxcdFxcdFxcdFxcdGN1clBvc2l0aW9uID0gY3VyRWxlbS5wb3NpdGlvbigpO1xcblxcdFxcdFxcdFxcdGN1clRvcCA9IGN1clBvc2l0aW9uLnRvcDtcXG5cXHRcXHRcXHRcXHRjdXJMZWZ0ID0gY3VyUG9zaXRpb24ubGVmdDtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdGN1clRvcCA9IHBhcnNlRmxvYXQoY3VyQ1NTVG9wKSB8fCAwO1xcblxcdFxcdFxcdFxcdGN1ckxlZnQgPSBwYXJzZUZsb2F0KGN1ckNTU0xlZnQpIHx8IDA7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmIChqUXVlcnkuaXNGdW5jdGlvbihvcHRpb25zKSkge1xcblxcdFxcdFxcdFxcdG9wdGlvbnMgPSBvcHRpb25zLmNhbGwoZWxlbSwgaSwgY3VyT2Zmc2V0KTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKG9wdGlvbnMudG9wICE9IG51bGwpIHtcXG5cXHRcXHRcXHRcXHRwcm9wcy50b3AgPSBvcHRpb25zLnRvcCAtIGN1ck9mZnNldC50b3AgKyBjdXJUb3A7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmIChvcHRpb25zLmxlZnQgIT0gbnVsbCkge1xcblxcdFxcdFxcdFxcdHByb3BzLmxlZnQgPSBvcHRpb25zLmxlZnQgLSBjdXJPZmZzZXQubGVmdCArIGN1ckxlZnQ7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmIChcXFwidXNpbmdcXFwiIGluIG9wdGlvbnMpIHtcXG5cXHRcXHRcXHRcXHRvcHRpb25zLnVzaW5nLmNhbGwoZWxlbSwgcHJvcHMpO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0Y3VyRWxlbS5jc3MocHJvcHMpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fTtcXG5cXG5cXHRqUXVlcnkuZm4uZXh0ZW5kKHtcXG5cXHRcXHRvZmZzZXQ6IGZ1bmN0aW9uIG9mZnNldChvcHRpb25zKSB7XFxuXFx0XFx0XFx0aWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gb3B0aW9ucyA9PT0gdW5kZWZpbmVkID8gdGhpcyA6IHRoaXMuZWFjaChmdW5jdGlvbiAoaSkge1xcblxcdFxcdFxcdFxcdFxcdGpRdWVyeS5vZmZzZXQuc2V0T2Zmc2V0KHRoaXMsIG9wdGlvbnMsIGkpO1xcblxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2YXIgZG9jRWxlbSxcXG5cXHRcXHRcXHQgICAgd2luLFxcblxcdFxcdFxcdCAgICBlbGVtID0gdGhpc1swXSxcXG5cXHRcXHRcXHQgICAgYm94ID0geyB0b3A6IDAsIGxlZnQ6IDAgfSxcXG5cXHRcXHRcXHQgICAgZG9jID0gZWxlbSAmJiBlbGVtLm93bmVyRG9jdW1lbnQ7XFxuXFxuXFx0XFx0XFx0aWYgKCFkb2MpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGRvY0VsZW0gPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xcblxcblxcdFxcdFxcdC8vIE1ha2Ugc3VyZSBpdCdzIG5vdCBhIGRpc2Nvbm5lY3RlZCBET00gbm9kZVxcblxcdFxcdFxcdGlmICghalF1ZXJ5LmNvbnRhaW5zKGRvY0VsZW0sIGVsZW0pKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGJveDtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gU3VwcG9ydDogQmxhY2tCZXJyeSA1LCBpT1MgMyAob3JpZ2luYWwgaVBob25lKVxcblxcdFxcdFxcdC8vIElmIHdlIGRvbid0IGhhdmUgZ0JDUiwganVzdCB1c2UgMCwwIHJhdGhlciB0aGFuIGVycm9yXFxuXFx0XFx0XFx0aWYgKF90eXBlb2YoZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QpICE9PSBzdHJ1bmRlZmluZWQpIHtcXG5cXHRcXHRcXHRcXHRib3ggPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR3aW4gPSBnZXRXaW5kb3coZG9jKTtcXG5cXHRcXHRcXHRyZXR1cm4ge1xcblxcdFxcdFxcdFxcdHRvcDogYm94LnRvcCArIHdpbi5wYWdlWU9mZnNldCAtIGRvY0VsZW0uY2xpZW50VG9wLFxcblxcdFxcdFxcdFxcdGxlZnQ6IGJveC5sZWZ0ICsgd2luLnBhZ2VYT2Zmc2V0IC0gZG9jRWxlbS5jbGllbnRMZWZ0XFxuXFx0XFx0XFx0fTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdHBvc2l0aW9uOiBmdW5jdGlvbiBwb3NpdGlvbigpIHtcXG5cXHRcXHRcXHRpZiAoIXRoaXNbMF0pIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHZhciBvZmZzZXRQYXJlbnQsXFxuXFx0XFx0XFx0ICAgIG9mZnNldCxcXG5cXHRcXHRcXHQgICAgZWxlbSA9IHRoaXNbMF0sXFxuXFx0XFx0XFx0ICAgIHBhcmVudE9mZnNldCA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XFxuXFxuXFx0XFx0XFx0Ly8gRml4ZWQgZWxlbWVudHMgYXJlIG9mZnNldCBmcm9tIHdpbmRvdyAocGFyZW50T2Zmc2V0ID0ge3RvcDowLCBsZWZ0OiAwfSwgYmVjYXVzZSBpdCBpcyBpdHMgb25seSBvZmZzZXQgcGFyZW50XFxuXFx0XFx0XFx0aWYgKGpRdWVyeS5jc3MoZWxlbSwgXFxcInBvc2l0aW9uXFxcIikgPT09IFxcXCJmaXhlZFxcXCIpIHtcXG5cXHRcXHRcXHRcXHQvLyBBc3N1bWUgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGlzIHRoZXJlIHdoZW4gY29tcHV0ZWQgcG9zaXRpb24gaXMgZml4ZWRcXG5cXHRcXHRcXHRcXHRvZmZzZXQgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0Ly8gR2V0ICpyZWFsKiBvZmZzZXRQYXJlbnRcXG5cXHRcXHRcXHRcXHRvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudCgpO1xcblxcblxcdFxcdFxcdFxcdC8vIEdldCBjb3JyZWN0IG9mZnNldHNcXG5cXHRcXHRcXHRcXHRvZmZzZXQgPSB0aGlzLm9mZnNldCgpO1xcblxcdFxcdFxcdFxcdGlmICghalF1ZXJ5Lm5vZGVOYW1lKG9mZnNldFBhcmVudFswXSwgXFxcImh0bWxcXFwiKSkge1xcblxcdFxcdFxcdFxcdFxcdHBhcmVudE9mZnNldCA9IG9mZnNldFBhcmVudC5vZmZzZXQoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQWRkIG9mZnNldFBhcmVudCBib3JkZXJzXFxuXFx0XFx0XFx0XFx0cGFyZW50T2Zmc2V0LnRvcCArPSBqUXVlcnkuY3NzKG9mZnNldFBhcmVudFswXSwgXFxcImJvcmRlclRvcFdpZHRoXFxcIiwgdHJ1ZSk7XFxuXFx0XFx0XFx0XFx0cGFyZW50T2Zmc2V0LmxlZnQgKz0galF1ZXJ5LmNzcyhvZmZzZXRQYXJlbnRbMF0sIFxcXCJib3JkZXJMZWZ0V2lkdGhcXFwiLCB0cnVlKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gU3VidHJhY3QgcGFyZW50IG9mZnNldHMgYW5kIGVsZW1lbnQgbWFyZ2luc1xcblxcdFxcdFxcdHJldHVybiB7XFxuXFx0XFx0XFx0XFx0dG9wOiBvZmZzZXQudG9wIC0gcGFyZW50T2Zmc2V0LnRvcCAtIGpRdWVyeS5jc3MoZWxlbSwgXFxcIm1hcmdpblRvcFxcXCIsIHRydWUpLFxcblxcdFxcdFxcdFxcdGxlZnQ6IG9mZnNldC5sZWZ0IC0gcGFyZW50T2Zmc2V0LmxlZnQgLSBqUXVlcnkuY3NzKGVsZW0sIFxcXCJtYXJnaW5MZWZ0XFxcIiwgdHJ1ZSlcXG5cXHRcXHRcXHR9O1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0b2Zmc2V0UGFyZW50OiBmdW5jdGlvbiBvZmZzZXRQYXJlbnQoKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHR2YXIgb2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQgfHwgZG9jRWxlbTtcXG5cXG5cXHRcXHRcXHRcXHR3aGlsZSAob2Zmc2V0UGFyZW50ICYmICFqUXVlcnkubm9kZU5hbWUob2Zmc2V0UGFyZW50LCBcXFwiaHRtbFxcXCIpICYmIGpRdWVyeS5jc3Mob2Zmc2V0UGFyZW50LCBcXFwicG9zaXRpb25cXFwiKSA9PT0gXFxcInN0YXRpY1xcXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0UGFyZW50O1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGRvY0VsZW07XFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0fVxcblxcdH0pO1xcblxcblxcdC8vIENyZWF0ZSBzY3JvbGxMZWZ0IGFuZCBzY3JvbGxUb3AgbWV0aG9kc1xcblxcdGpRdWVyeS5lYWNoKHsgc2Nyb2xsTGVmdDogXFxcInBhZ2VYT2Zmc2V0XFxcIiwgc2Nyb2xsVG9wOiBcXFwicGFnZVlPZmZzZXRcXFwiIH0sIGZ1bmN0aW9uIChtZXRob2QsIHByb3ApIHtcXG5cXHRcXHR2YXIgdG9wID0gXFxcInBhZ2VZT2Zmc2V0XFxcIiA9PT0gcHJvcDtcXG5cXG5cXHRcXHRqUXVlcnkuZm5bbWV0aG9kXSA9IGZ1bmN0aW9uICh2YWwpIHtcXG5cXHRcXHRcXHRyZXR1cm4gYWNjZXNzKHRoaXMsIGZ1bmN0aW9uIChlbGVtLCBtZXRob2QsIHZhbCkge1xcblxcdFxcdFxcdFxcdHZhciB3aW4gPSBnZXRXaW5kb3coZWxlbSk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHdpbiA/IHdpbltwcm9wXSA6IGVsZW1bbWV0aG9kXTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKHdpbikge1xcblxcdFxcdFxcdFxcdFxcdHdpbi5zY3JvbGxUbyghdG9wID8gdmFsIDogd2luZG93LnBhZ2VYT2Zmc2V0LCB0b3AgPyB2YWwgOiB3aW5kb3cucGFnZVlPZmZzZXQpO1xcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0ZWxlbVttZXRob2RdID0gdmFsO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LCBtZXRob2QsIHZhbCwgYXJndW1lbnRzLmxlbmd0aCwgbnVsbCk7XFxuXFx0XFx0fTtcXG5cXHR9KTtcXG5cXG5cXHQvLyBTdXBwb3J0OiBTYWZhcmk8NyssIENocm9tZTwzNytcXG5cXHQvLyBBZGQgdGhlIHRvcC9sZWZ0IGNzc0hvb2tzIHVzaW5nIGpRdWVyeS5mbi5wb3NpdGlvblxcblxcdC8vIFdlYmtpdCBidWc6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yOTA4NFxcblxcdC8vIEJsaW5rIGJ1ZzogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTIyOTI4MFxcblxcdC8vIGdldENvbXB1dGVkU3R5bGUgcmV0dXJucyBwZXJjZW50IHdoZW4gc3BlY2lmaWVkIGZvciB0b3AvbGVmdC9ib3R0b20vcmlnaHQ7XFxuXFx0Ly8gcmF0aGVyIHRoYW4gbWFrZSB0aGUgY3NzIG1vZHVsZSBkZXBlbmQgb24gdGhlIG9mZnNldCBtb2R1bGUsIGp1c3QgY2hlY2sgZm9yIGl0IGhlcmVcXG5cXHRqUXVlcnkuZWFjaChbXFxcInRvcFxcXCIsIFxcXCJsZWZ0XFxcIl0sIGZ1bmN0aW9uIChpLCBwcm9wKSB7XFxuXFx0XFx0alF1ZXJ5LmNzc0hvb2tzW3Byb3BdID0gYWRkR2V0SG9va0lmKHN1cHBvcnQucGl4ZWxQb3NpdGlvbiwgZnVuY3Rpb24gKGVsZW0sIGNvbXB1dGVkKSB7XFxuXFx0XFx0XFx0aWYgKGNvbXB1dGVkKSB7XFxuXFx0XFx0XFx0XFx0Y29tcHV0ZWQgPSBjdXJDU1MoZWxlbSwgcHJvcCk7XFxuXFx0XFx0XFx0XFx0Ly8gSWYgY3VyQ1NTIHJldHVybnMgcGVyY2VudGFnZSwgZmFsbGJhY2sgdG8gb2Zmc2V0XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHJudW1ub25weC50ZXN0KGNvbXB1dGVkKSA/IGpRdWVyeShlbGVtKS5wb3NpdGlvbigpW3Byb3BdICsgXFxcInB4XFxcIiA6IGNvbXB1dGVkO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9KTtcXG5cXHR9KTtcXG5cXG5cXHQvLyBDcmVhdGUgaW5uZXJIZWlnaHQsIGlubmVyV2lkdGgsIGhlaWdodCwgd2lkdGgsIG91dGVySGVpZ2h0IGFuZCBvdXRlcldpZHRoIG1ldGhvZHNcXG5cXHRqUXVlcnkuZWFjaCh7IEhlaWdodDogXFxcImhlaWdodFxcXCIsIFdpZHRoOiBcXFwid2lkdGhcXFwiIH0sIGZ1bmN0aW9uIChuYW1lLCB0eXBlKSB7XFxuXFx0XFx0alF1ZXJ5LmVhY2goeyBwYWRkaW5nOiBcXFwiaW5uZXJcXFwiICsgbmFtZSwgY29udGVudDogdHlwZSwgXFxcIlxcXCI6IFxcXCJvdXRlclxcXCIgKyBuYW1lIH0sIGZ1bmN0aW9uIChkZWZhdWx0RXh0cmEsIGZ1bmNOYW1lKSB7XFxuXFx0XFx0XFx0Ly8gTWFyZ2luIGlzIG9ubHkgZm9yIG91dGVySGVpZ2h0LCBvdXRlcldpZHRoXFxuXFx0XFx0XFx0alF1ZXJ5LmZuW2Z1bmNOYW1lXSA9IGZ1bmN0aW9uIChtYXJnaW4sIHZhbHVlKSB7XFxuXFx0XFx0XFx0XFx0dmFyIGNoYWluYWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggJiYgKGRlZmF1bHRFeHRyYSB8fCB0eXBlb2YgbWFyZ2luICE9PSBcXFwiYm9vbGVhblxcXCIpLFxcblxcdFxcdFxcdFxcdCAgICBleHRyYSA9IGRlZmF1bHRFeHRyYSB8fCAobWFyZ2luID09PSB0cnVlIHx8IHZhbHVlID09PSB0cnVlID8gXFxcIm1hcmdpblxcXCIgOiBcXFwiYm9yZGVyXFxcIik7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIGFjY2Vzcyh0aGlzLCBmdW5jdGlvbiAoZWxlbSwgdHlwZSwgdmFsdWUpIHtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgZG9jO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmIChqUXVlcnkuaXNXaW5kb3coZWxlbSkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBBcyBvZiA1LzgvMjAxMiB0aGlzIHdpbGwgeWllbGQgaW5jb3JyZWN0IHJlc3VsdHMgZm9yIE1vYmlsZSBTYWZhcmksIGJ1dCB0aGVyZVxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIGlzbid0IGEgd2hvbGUgbG90IHdlIGNhbiBkby4gU2VlIHB1bGwgcmVxdWVzdCBhdCB0aGlzIFVSTCBmb3IgZGlzY3Vzc2lvbjpcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9wdWxsLzc2NFxcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBlbGVtLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFtcXFwiY2xpZW50XFxcIiArIG5hbWVdO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBHZXQgZG9jdW1lbnQgd2lkdGggb3IgaGVpZ2h0XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGVsZW0ubm9kZVR5cGUgPT09IDkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRkb2MgPSBlbGVtLmRvY3VtZW50RWxlbWVudDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBFaXRoZXIgc2Nyb2xsW1dpZHRoL0hlaWdodF0gb3Igb2Zmc2V0W1dpZHRoL0hlaWdodF0gb3IgY2xpZW50W1dpZHRoL0hlaWdodF0sXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gd2hpY2hldmVyIGlzIGdyZWF0ZXN0XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIE1hdGgubWF4KGVsZW0uYm9keVtcXFwic2Nyb2xsXFxcIiArIG5hbWVdLCBkb2NbXFxcInNjcm9sbFxcXCIgKyBuYW1lXSwgZWxlbS5ib2R5W1xcXCJvZmZzZXRcXFwiICsgbmFtZV0sIGRvY1tcXFwib2Zmc2V0XFxcIiArIG5hbWVdLCBkb2NbXFxcImNsaWVudFxcXCIgKyBuYW1lXSk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cXG5cXHRcXHRcXHRcXHRcXHQvLyBHZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50LCByZXF1ZXN0aW5nIGJ1dCBub3QgZm9yY2luZyBwYXJzZUZsb2F0XFxuXFx0XFx0XFx0XFx0XFx0alF1ZXJ5LmNzcyhlbGVtLCB0eXBlLCBleHRyYSkgOlxcblxcblxcdFxcdFxcdFxcdFxcdC8vIFNldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnRcXG5cXHRcXHRcXHRcXHRcXHRqUXVlcnkuc3R5bGUoZWxlbSwgdHlwZSwgdmFsdWUsIGV4dHJhKTtcXG5cXHRcXHRcXHRcXHR9LCB0eXBlLCBjaGFpbmFibGUgPyBtYXJnaW4gOiB1bmRlZmluZWQsIGNoYWluYWJsZSwgbnVsbCk7XFxuXFx0XFx0XFx0fTtcXG5cXHRcXHR9KTtcXG5cXHR9KTtcXG5cXG5cXHQvLyBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIGNvbnRhaW5lZCBpbiB0aGUgbWF0Y2hlZCBlbGVtZW50IHNldFxcblxcdGpRdWVyeS5mbi5zaXplID0gZnVuY3Rpb24gKCkge1xcblxcdFxcdHJldHVybiB0aGlzLmxlbmd0aDtcXG5cXHR9O1xcblxcblxcdGpRdWVyeS5mbi5hbmRTZWxmID0galF1ZXJ5LmZuLmFkZEJhY2s7XFxuXFxuXFx0Ly8gUmVnaXN0ZXIgYXMgYSBuYW1lZCBBTUQgbW9kdWxlLCBzaW5jZSBqUXVlcnkgY2FuIGJlIGNvbmNhdGVuYXRlZCB3aXRoIG90aGVyXFxuXFx0Ly8gZmlsZXMgdGhhdCBtYXkgdXNlIGRlZmluZSwgYnV0IG5vdCB2aWEgYSBwcm9wZXIgY29uY2F0ZW5hdGlvbiBzY3JpcHQgdGhhdFxcblxcdC8vIHVuZGVyc3RhbmRzIGFub255bW91cyBBTUQgbW9kdWxlcy4gQSBuYW1lZCBBTUQgaXMgc2FmZXN0IGFuZCBtb3N0IHJvYnVzdFxcblxcdC8vIHdheSB0byByZWdpc3Rlci4gTG93ZXJjYXNlIGpxdWVyeSBpcyB1c2VkIGJlY2F1c2UgQU1EIG1vZHVsZSBuYW1lcyBhcmVcXG5cXHQvLyBkZXJpdmVkIGZyb20gZmlsZSBuYW1lcywgYW5kIGpRdWVyeSBpcyBub3JtYWxseSBkZWxpdmVyZWQgaW4gYSBsb3dlcmNhc2VcXG5cXHQvLyBmaWxlIG5hbWUuIERvIHRoaXMgYWZ0ZXIgY3JlYXRpbmcgdGhlIGdsb2JhbCBzbyB0aGF0IGlmIGFuIEFNRCBtb2R1bGUgd2FudHNcXG5cXHQvLyB0byBjYWxsIG5vQ29uZmxpY3QgdG8gaGlkZSB0aGlzIHZlcnNpb24gb2YgalF1ZXJ5LCBpdCB3aWxsIHdvcmsuXFxuXFxuXFx0Ly8gTm90ZSB0aGF0IGZvciBtYXhpbXVtIHBvcnRhYmlsaXR5LCBsaWJyYXJpZXMgdGhhdCBhcmUgbm90IGpRdWVyeSBzaG91bGRcXG5cXHQvLyBkZWNsYXJlIHRoZW1zZWx2ZXMgYXMgYW5vbnltb3VzIG1vZHVsZXMsIGFuZCBhdm9pZCBzZXR0aW5nIGEgZ2xvYmFsIGlmIGFuXFxuXFx0Ly8gQU1EIGxvYWRlciBpcyBwcmVzZW50LiBqUXVlcnkgaXMgYSBzcGVjaWFsIGNhc2UuIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWVcXG5cXHQvLyBodHRwczovL2dpdGh1Yi5jb20vanJidXJrZS9yZXF1aXJlanMvd2lraS9VcGRhdGluZy1leGlzdGluZy1saWJyYXJpZXMjd2lraS1hbm9uXFxuXFxuXFx0aWYgKHR5cGVvZiBkZWZpbmUgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgZGVmaW5lLmFtZCkge1xcblxcdFxcdGRlZmluZShcXFwianF1ZXJ5XFxcIiwgW10sIGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRyZXR1cm4galF1ZXJ5O1xcblxcdFxcdH0pO1xcblxcdH1cXG5cXG5cXHR2YXJcXG5cXHQvLyBNYXAgb3ZlciBqUXVlcnkgaW4gY2FzZSBvZiBvdmVyd3JpdGVcXG5cXHRfalF1ZXJ5ID0gd2luZG93LmpRdWVyeSxcXG5cXG5cXG5cXHQvLyBNYXAgb3ZlciB0aGUgJCBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxcblxcdF8kID0gd2luZG93LiQ7XFxuXFxuXFx0alF1ZXJ5Lm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoZGVlcCkge1xcblxcdFxcdGlmICh3aW5kb3cuJCA9PT0galF1ZXJ5KSB7XFxuXFx0XFx0XFx0d2luZG93LiQgPSBfJDtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKGRlZXAgJiYgd2luZG93LmpRdWVyeSA9PT0galF1ZXJ5KSB7XFxuXFx0XFx0XFx0d2luZG93LmpRdWVyeSA9IF9qUXVlcnk7XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiBqUXVlcnk7XFxuXFx0fTtcXG5cXG5cXHQvLyBFeHBvc2UgalF1ZXJ5IGFuZCAkIGlkZW50aWZpZXJzLCBldmVuIGluIEFNRFxcblxcdC8vICgjNzEwMiNjb21tZW50OjEwLCBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9wdWxsLzU1NylcXG5cXHQvLyBhbmQgQ29tbW9uSlMgZm9yIGJyb3dzZXIgZW11bGF0b3JzICgjMTM1NjYpXFxuXFx0aWYgKCh0eXBlb2Ygbm9HbG9iYWwgPT09IFxcXCJ1bmRlZmluZWRcXFwiID8gXFxcInVuZGVmaW5lZFxcXCIgOiBfdHlwZW9mKG5vR2xvYmFsKSkgPT09IHN0cnVuZGVmaW5lZCkge1xcblxcdFxcdHdpbmRvdy5qUXVlcnkgPSB3aW5kb3cuJCA9IGpRdWVyeTtcXG5cXHR9XFxuXFxuXFx0cmV0dXJuIGpRdWVyeTtcXG59KTtcIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Jhdy1sb2FkZXIhLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYj8/cmVmLS0wLTAhLi9hc3NldHMvanMvanF1ZXJ5LTIuMS40LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9yYXctbG9hZGVyL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMC0wIS4vYXNzZXRzL2pzL2pxdWVyeS0yLjEuNC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIm1vZHVsZS5leHBvcnRzID0gXCJ2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXFxcInN5bWJvbFxcXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXFxcInN5bWJvbFxcXCIgOiB0eXBlb2Ygb2JqOyB9O1xcblxcbi8qIVxcbiAqIGpRdWVyeSBGb3JtIFBsdWdpblxcbiAqIHZlcnNpb246IDMuNTEuMC0yMDE0LjA2LjIwXFxuICogUmVxdWlyZXMgalF1ZXJ5IHYxLjUgb3IgbGF0ZXJcXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgTS4gQWxzdXBcXG4gKiBFeGFtcGxlcyBhbmQgZG9jdW1lbnRhdGlvbiBhdDogaHR0cDovL21hbHN1cC5jb20vanF1ZXJ5L2Zvcm0vXFxuICogUHJvamVjdCByZXBvc2l0b3J5OiBodHRwczovL2dpdGh1Yi5jb20vbWFsc3VwL2Zvcm1cXG4gKiBEdWFsIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgYW5kIEdQTCBsaWNlbnNlcy5cXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWFsc3VwL2Zvcm0jY29weXJpZ2h0LWFuZC1saWNlbnNlXFxuICovXFxuLypnbG9iYWwgQWN0aXZlWE9iamVjdCAqL1xcblxcbi8vIEFNRCBzdXBwb3J0XFxuKGZ1bmN0aW9uIChmYWN0b3J5KSB7XFxuICAgIFxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xcbiAgICAgICAgLy8gdXNpbmcgQU1EOyByZWdpc3RlciBhcyBhbm9uIG1vZHVsZVxcbiAgICAgICAgZGVmaW5lKFsnanF1ZXJ5J10sIGZhY3RvcnkpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgLy8gbm8gQU1EOyBpbnZva2UgZGlyZWN0bHlcXG4gICAgICAgIGZhY3RvcnkodHlwZW9mIGpRdWVyeSAhPSAndW5kZWZpbmVkJyA/IGpRdWVyeSA6IHdpbmRvdy5aZXB0byk7XFxuICAgIH1cXG59KShmdW5jdGlvbiAoJCkge1xcbiAgICBcXFwidXNlIHN0cmljdFxcXCI7XFxuXFxuICAgIC8qXFxuICAgICAgICBVc2FnZSBOb3RlOlxcbiAgICAgICAgLS0tLS0tLS0tLS1cXG4gICAgICAgIERvIG5vdCB1c2UgYm90aCBhamF4U3VibWl0IGFuZCBhamF4Rm9ybSBvbiB0aGUgc2FtZSBmb3JtLiAgVGhlc2VcXG4gICAgICAgIGZ1bmN0aW9ucyBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlLiAgVXNlIGFqYXhTdWJtaXQgaWYgeW91IHdhbnRcXG4gICAgICAgIHRvIGJpbmQgeW91ciBvd24gc3VibWl0IGhhbmRsZXIgdG8gdGhlIGZvcm0uICBGb3IgZXhhbXBsZSxcXG4gICAgXFxuICAgICAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcXG4gICAgICAgICAgICAkKCcjbXlGb3JtJykub24oJ3N1Ym1pdCcsIGZ1bmN0aW9uKGUpIHtcXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpOyAvLyA8LS0gaW1wb3J0YW50XFxuICAgICAgICAgICAgICAgICQodGhpcykuYWpheFN1Ym1pdCh7XFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6ICcjb3V0cHV0J1xcbiAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH0pO1xcbiAgICBcXG4gICAgICAgIFVzZSBhamF4Rm9ybSB3aGVuIHlvdSB3YW50IHRoZSBwbHVnaW4gdG8gbWFuYWdlIGFsbCB0aGUgZXZlbnQgYmluZGluZ1xcbiAgICAgICAgZm9yIHlvdS4gIEZvciBleGFtcGxlLFxcbiAgICBcXG4gICAgICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xcbiAgICAgICAgICAgICQoJyNteUZvcm0nKS5hamF4Rm9ybSh7XFxuICAgICAgICAgICAgICAgIHRhcmdldDogJyNvdXRwdXQnXFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9KTtcXG4gICAgXFxuICAgICAgICBZb3UgY2FuIGFsc28gdXNlIGFqYXhGb3JtIHdpdGggZGVsZWdhdGlvbiAocmVxdWlyZXMgalF1ZXJ5IHYxLjcrKSwgc28gdGhlXFxuICAgICAgICBmb3JtIGRvZXMgbm90IGhhdmUgdG8gZXhpc3Qgd2hlbiB5b3UgaW52b2tlIGFqYXhGb3JtOlxcbiAgICBcXG4gICAgICAgICQoJyNteUZvcm0nKS5hamF4Rm9ybSh7XFxuICAgICAgICAgICAgZGVsZWdhdGlvbjogdHJ1ZSxcXG4gICAgICAgICAgICB0YXJnZXQ6ICcjb3V0cHV0J1xcbiAgICAgICAgfSk7XFxuICAgIFxcbiAgICAgICAgV2hlbiB1c2luZyBhamF4Rm9ybSwgdGhlIGFqYXhTdWJtaXQgZnVuY3Rpb24gd2lsbCBiZSBpbnZva2VkIGZvciB5b3VcXG4gICAgICAgIGF0IHRoZSBhcHByb3ByaWF0ZSB0aW1lLlxcbiAgICAqL1xcblxcbiAgICAvKipcXG4gICAgICogRmVhdHVyZSBkZXRlY3Rpb25cXG4gICAgICovXFxuXFxuICAgIHZhciBmZWF0dXJlID0ge307XFxuICAgIGZlYXR1cmUuZmlsZWFwaSA9ICQoXFxcIjxpbnB1dCB0eXBlPSdmaWxlJy8+XFxcIikuZ2V0KDApLmZpbGVzICE9PSB1bmRlZmluZWQ7XFxuICAgIGZlYXR1cmUuZm9ybWRhdGEgPSB3aW5kb3cuRm9ybURhdGEgIT09IHVuZGVmaW5lZDtcXG5cXG4gICAgdmFyIGhhc1Byb3AgPSAhISQuZm4ucHJvcDtcXG5cXG4gICAgLy8gYXR0cjIgdXNlcyBwcm9wIHdoZW4gaXQgY2FuIGJ1dCBjaGVja3MgdGhlIHJldHVybiB0eXBlIGZvclxcbiAgICAvLyBhbiBleHBlY3RlZCBzdHJpbmcuICB0aGlzIGFjY291bnRzIGZvciB0aGUgY2FzZSB3aGVyZSBhIGZvcm0gXFxuICAgIC8vIGNvbnRhaW5zIGlucHV0cyB3aXRoIG5hbWVzIGxpa2UgXFxcImFjdGlvblxcXCIgb3IgXFxcIm1ldGhvZFxcXCI7IGluIHRob3NlXFxuICAgIC8vIGNhc2VzIFxcXCJwcm9wXFxcIiByZXR1cm5zIHRoZSBlbGVtZW50XFxuICAgICQuZm4uYXR0cjIgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICBpZiAoIWhhc1Byb3ApIHtcXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hdHRyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICAgICAgICB9XFxuICAgICAgICB2YXIgdmFsID0gdGhpcy5wcm9wLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICAgICAgICBpZiAodmFsICYmIHZhbC5qcXVlcnkgfHwgdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcXG4gICAgICAgICAgICByZXR1cm4gdmFsO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0ci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgICB9O1xcblxcbiAgICAvKipcXG4gICAgICogYWpheFN1Ym1pdCgpIHByb3ZpZGVzIGEgbWVjaGFuaXNtIGZvciBpbW1lZGlhdGVseSBzdWJtaXR0aW5nXFxuICAgICAqIGFuIEhUTUwgZm9ybSB1c2luZyBBSkFYLlxcbiAgICAgKi9cXG4gICAgJC5mbi5hamF4U3VibWl0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcXG4gICAgICAgIC8qanNoaW50IHNjcmlwdHVybDp0cnVlICovXFxuXFxuICAgICAgICAvLyBmYXN0IGZhaWwgaWYgbm90aGluZyBzZWxlY3RlZCAoaHR0cDovL2Rldi5qcXVlcnkuY29tL3RpY2tldC8yNzUyKVxcbiAgICAgICAgaWYgKCF0aGlzLmxlbmd0aCkge1xcbiAgICAgICAgICAgIGxvZygnYWpheFN1Ym1pdDogc2tpcHBpbmcgc3VibWl0IHByb2Nlc3MgLSBubyBlbGVtZW50IHNlbGVjdGVkJyk7XFxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB2YXIgbWV0aG9kLFxcbiAgICAgICAgICAgIGFjdGlvbixcXG4gICAgICAgICAgICB1cmwsXFxuICAgICAgICAgICAgJGZvcm0gPSB0aGlzO1xcblxcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09ICdmdW5jdGlvbicpIHtcXG4gICAgICAgICAgICBvcHRpb25zID0geyBzdWNjZXNzOiBvcHRpb25zIH07XFxuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIG1ldGhvZCA9IG9wdGlvbnMudHlwZSB8fCB0aGlzLmF0dHIyKCdtZXRob2QnKTtcXG4gICAgICAgIGFjdGlvbiA9IG9wdGlvbnMudXJsIHx8IHRoaXMuYXR0cjIoJ2FjdGlvbicpO1xcblxcbiAgICAgICAgdXJsID0gdHlwZW9mIGFjdGlvbiA9PT0gJ3N0cmluZycgPyAkLnRyaW0oYWN0aW9uKSA6ICcnO1xcbiAgICAgICAgdXJsID0gdXJsIHx8IHdpbmRvdy5sb2NhdGlvbi5ocmVmIHx8ICcnO1xcbiAgICAgICAgaWYgKHVybCkge1xcbiAgICAgICAgICAgIC8vIGNsZWFuIHVybCAoZG9uJ3QgaW5jbHVkZSBoYXNoIHZhdWUpXFxuICAgICAgICAgICAgdXJsID0gKHVybC5tYXRjaCgvXihbXiNdKykvKSB8fCBbXSlbMV07XFxuICAgICAgICB9XFxuXFxuICAgICAgICBvcHRpb25zID0gJC5leHRlbmQodHJ1ZSwge1xcbiAgICAgICAgICAgIHVybDogdXJsLFxcbiAgICAgICAgICAgIHN1Y2Nlc3M6ICQuYWpheFNldHRpbmdzLnN1Y2Nlc3MsXFxuICAgICAgICAgICAgdHlwZTogbWV0aG9kIHx8ICQuYWpheFNldHRpbmdzLnR5cGUsXFxuICAgICAgICAgICAgaWZyYW1lU3JjOiAvXmh0dHBzL2kudGVzdCh3aW5kb3cubG9jYXRpb24uaHJlZiB8fCAnJykgPyAnamF2YXNjcmlwdDpmYWxzZScgOiAnYWJvdXQ6YmxhbmsnXFxuICAgICAgICB9LCBvcHRpb25zKTtcXG5cXG4gICAgICAgIC8vIGhvb2sgZm9yIG1hbmlwdWxhdGluZyB0aGUgZm9ybSBkYXRhIGJlZm9yZSBpdCBpcyBleHRyYWN0ZWQ7XFxuICAgICAgICAvLyBjb252ZW5pZW50IGZvciB1c2Ugd2l0aCByaWNoIGVkaXRvcnMgbGlrZSB0aW55TUNFIG9yIEZDS0VkaXRvclxcbiAgICAgICAgdmFyIHZldG8gPSB7fTtcXG4gICAgICAgIHRoaXMudHJpZ2dlcignZm9ybS1wcmUtc2VyaWFsaXplJywgW3RoaXMsIG9wdGlvbnMsIHZldG9dKTtcXG4gICAgICAgIGlmICh2ZXRvLnZldG8pIHtcXG4gICAgICAgICAgICBsb2coJ2FqYXhTdWJtaXQ6IHN1Ym1pdCB2ZXRvZWQgdmlhIGZvcm0tcHJlLXNlcmlhbGl6ZSB0cmlnZ2VyJyk7XFxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XFxuICAgICAgICB9XFxuXFxuICAgICAgICAvLyBwcm92aWRlIG9wcG9ydHVuaXR5IHRvIGFsdGVyIGZvcm0gZGF0YSBiZWZvcmUgaXQgaXMgc2VyaWFsaXplZFxcbiAgICAgICAgaWYgKG9wdGlvbnMuYmVmb3JlU2VyaWFsaXplICYmIG9wdGlvbnMuYmVmb3JlU2VyaWFsaXplKHRoaXMsIG9wdGlvbnMpID09PSBmYWxzZSkge1xcbiAgICAgICAgICAgIGxvZygnYWpheFN1Ym1pdDogc3VibWl0IGFib3J0ZWQgdmlhIGJlZm9yZVNlcmlhbGl6ZSBjYWxsYmFjaycpO1xcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdmFyIHRyYWRpdGlvbmFsID0gb3B0aW9ucy50cmFkaXRpb25hbDtcXG4gICAgICAgIGlmICh0cmFkaXRpb25hbCA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgICAgdHJhZGl0aW9uYWwgPSAkLmFqYXhTZXR0aW5ncy50cmFkaXRpb25hbDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHZhciBlbGVtZW50cyA9IFtdO1xcbiAgICAgICAgdmFyIHF4LFxcbiAgICAgICAgICAgIGEgPSB0aGlzLmZvcm1Ub0FycmF5KG9wdGlvbnMuc2VtYW50aWMsIGVsZW1lbnRzKTtcXG4gICAgICAgIGlmIChvcHRpb25zLmRhdGEpIHtcXG4gICAgICAgICAgICBvcHRpb25zLmV4dHJhRGF0YSA9IG9wdGlvbnMuZGF0YTtcXG4gICAgICAgICAgICBxeCA9ICQucGFyYW0ob3B0aW9ucy5kYXRhLCB0cmFkaXRpb25hbCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICAvLyBnaXZlIHByZS1zdWJtaXQgY2FsbGJhY2sgYW4gb3Bwb3J0dW5pdHkgdG8gYWJvcnQgdGhlIHN1Ym1pdFxcbiAgICAgICAgaWYgKG9wdGlvbnMuYmVmb3JlU3VibWl0ICYmIG9wdGlvbnMuYmVmb3JlU3VibWl0KGEsIHRoaXMsIG9wdGlvbnMpID09PSBmYWxzZSkge1xcbiAgICAgICAgICAgIGxvZygnYWpheFN1Ym1pdDogc3VibWl0IGFib3J0ZWQgdmlhIGJlZm9yZVN1Ym1pdCBjYWxsYmFjaycpO1xcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgLy8gZmlyZSB2ZXRvYWJsZSAndmFsaWRhdGUnIGV2ZW50XFxuICAgICAgICB0aGlzLnRyaWdnZXIoJ2Zvcm0tc3VibWl0LXZhbGlkYXRlJywgW2EsIHRoaXMsIG9wdGlvbnMsIHZldG9dKTtcXG4gICAgICAgIGlmICh2ZXRvLnZldG8pIHtcXG4gICAgICAgICAgICBsb2coJ2FqYXhTdWJtaXQ6IHN1Ym1pdCB2ZXRvZWQgdmlhIGZvcm0tc3VibWl0LXZhbGlkYXRlIHRyaWdnZXInKTtcXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHZhciBxID0gJC5wYXJhbShhLCB0cmFkaXRpb25hbCk7XFxuICAgICAgICBpZiAocXgpIHtcXG4gICAgICAgICAgICBxID0gcSA/IHEgKyAnJicgKyBxeCA6IHF4O1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKG9wdGlvbnMudHlwZS50b1VwcGVyQ2FzZSgpID09ICdHRVQnKSB7XFxuICAgICAgICAgICAgb3B0aW9ucy51cmwgKz0gKG9wdGlvbnMudXJsLmluZGV4T2YoJz8nKSA+PSAwID8gJyYnIDogJz8nKSArIHE7XFxuICAgICAgICAgICAgb3B0aW9ucy5kYXRhID0gbnVsbDsgLy8gZGF0YSBpcyBudWxsIGZvciAnZ2V0J1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBvcHRpb25zLmRhdGEgPSBxOyAvLyBkYXRhIGlzIHRoZSBxdWVyeSBzdHJpbmcgZm9yICdwb3N0J1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdmFyIGNhbGxiYWNrcyA9IFtdO1xcbiAgICAgICAgaWYgKG9wdGlvbnMucmVzZXRGb3JtKSB7XFxuICAgICAgICAgICAgY2FsbGJhY2tzLnB1c2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICAkZm9ybS5yZXNldEZvcm0oKTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChvcHRpb25zLmNsZWFyRm9ybSkge1xcbiAgICAgICAgICAgIGNhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgJGZvcm0uY2xlYXJGb3JtKG9wdGlvbnMuaW5jbHVkZUhpZGRlbik7XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICAvLyBwZXJmb3JtIGEgbG9hZCBvbiB0aGUgdGFyZ2V0IG9ubHkgaWYgZGF0YVR5cGUgaXMgbm90IHByb3ZpZGVkXFxuICAgICAgICBpZiAoIW9wdGlvbnMuZGF0YVR5cGUgJiYgb3B0aW9ucy50YXJnZXQpIHtcXG4gICAgICAgICAgICB2YXIgb2xkU3VjY2VzcyA9IG9wdGlvbnMuc3VjY2VzcyB8fCBmdW5jdGlvbiAoKSB7fTtcXG4gICAgICAgICAgICBjYWxsYmFja3MucHVzaChmdW5jdGlvbiAoZGF0YSkge1xcbiAgICAgICAgICAgICAgICB2YXIgZm4gPSBvcHRpb25zLnJlcGxhY2VUYXJnZXQgPyAncmVwbGFjZVdpdGgnIDogJ2h0bWwnO1xcbiAgICAgICAgICAgICAgICAkKG9wdGlvbnMudGFyZ2V0KVtmbl0oZGF0YSkuZWFjaChvbGRTdWNjZXNzLCBhcmd1bWVudHMpO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnN1Y2Nlc3MpIHtcXG4gICAgICAgICAgICBjYWxsYmFja3MucHVzaChvcHRpb25zLnN1Y2Nlc3MpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgb3B0aW9ucy5zdWNjZXNzID0gZnVuY3Rpb24gKGRhdGEsIHN0YXR1cywgeGhyKSB7XFxuICAgICAgICAgICAgLy8galF1ZXJ5IDEuNCsgcGFzc2VzIHhociBhcyAzcmQgYXJnXFxuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBvcHRpb25zLmNvbnRleHQgfHwgdGhpczsgLy8galF1ZXJ5IDEuNCsgc3VwcG9ydHMgc2NvcGUgY29udGV4dFxcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBtYXggPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbWF4OyBpKyspIHtcXG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzW2ldLmFwcGx5KGNvbnRleHQsIFtkYXRhLCBzdGF0dXMsIHhociB8fCAkZm9ybSwgJGZvcm1dKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9O1xcblxcbiAgICAgICAgaWYgKG9wdGlvbnMuZXJyb3IpIHtcXG4gICAgICAgICAgICB2YXIgb2xkRXJyb3IgPSBvcHRpb25zLmVycm9yO1xcbiAgICAgICAgICAgIG9wdGlvbnMuZXJyb3IgPSBmdW5jdGlvbiAoeGhyLCBzdGF0dXMsIGVycm9yKSB7XFxuICAgICAgICAgICAgICAgIHZhciBjb250ZXh0ID0gb3B0aW9ucy5jb250ZXh0IHx8IHRoaXM7XFxuICAgICAgICAgICAgICAgIG9sZEVycm9yLmFwcGx5KGNvbnRleHQsIFt4aHIsIHN0YXR1cywgZXJyb3IsICRmb3JtXSk7XFxuICAgICAgICAgICAgfTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChvcHRpb25zLmNvbXBsZXRlKSB7XFxuICAgICAgICAgICAgdmFyIG9sZENvbXBsZXRlID0gb3B0aW9ucy5jb21wbGV0ZTtcXG4gICAgICAgICAgICBvcHRpb25zLmNvbXBsZXRlID0gZnVuY3Rpb24gKHhociwgc3RhdHVzKSB7XFxuICAgICAgICAgICAgICAgIHZhciBjb250ZXh0ID0gb3B0aW9ucy5jb250ZXh0IHx8IHRoaXM7XFxuICAgICAgICAgICAgICAgIG9sZENvbXBsZXRlLmFwcGx5KGNvbnRleHQsIFt4aHIsIHN0YXR1cywgJGZvcm1dKTtcXG4gICAgICAgICAgICB9O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgLy8gYXJlIHRoZXJlIGZpbGVzIHRvIHVwbG9hZD9cXG5cXG4gICAgICAgIC8vIFt2YWx1ZV0gKGlzc3VlICMxMTMpLCBhbHNvIHNlZSBjb21tZW50OlxcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21hbHN1cC9mb3JtL2NvbW1pdC81ODgzMDZhZWRiYTFkZTAxMzg4MDMyZDVmNDJhNjAxNTllZWE5MjI4I2NvbW1pdGNvbW1lbnQtMjE4MDIxOVxcbiAgICAgICAgdmFyIGZpbGVJbnB1dHMgPSAkKCdpbnB1dFt0eXBlPWZpbGVdOmVuYWJsZWQnLCB0aGlzKS5maWx0ZXIoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIHJldHVybiAkKHRoaXMpLnZhbCgpICE9PSAnJztcXG4gICAgICAgIH0pO1xcblxcbiAgICAgICAgdmFyIGhhc0ZpbGVJbnB1dHMgPSBmaWxlSW5wdXRzLmxlbmd0aCA+IDA7XFxuICAgICAgICB2YXIgbXAgPSAnbXVsdGlwYXJ0L2Zvcm0tZGF0YSc7XFxuICAgICAgICB2YXIgbXVsdGlwYXJ0ID0gJGZvcm0uYXR0cignZW5jdHlwZScpID09IG1wIHx8ICRmb3JtLmF0dHIoJ2VuY29kaW5nJykgPT0gbXA7XFxuXFxuICAgICAgICB2YXIgZmlsZUFQSSA9IGZlYXR1cmUuZmlsZWFwaSAmJiBmZWF0dXJlLmZvcm1kYXRhO1xcbiAgICAgICAgbG9nKFxcXCJmaWxlQVBJIDpcXFwiICsgZmlsZUFQSSk7XFxuICAgICAgICB2YXIgc2hvdWxkVXNlRnJhbWUgPSAoaGFzRmlsZUlucHV0cyB8fCBtdWx0aXBhcnQpICYmICFmaWxlQVBJO1xcblxcbiAgICAgICAgdmFyIGpxeGhyO1xcblxcbiAgICAgICAgLy8gb3B0aW9ucy5pZnJhbWUgYWxsb3dzIHVzZXIgdG8gZm9yY2UgaWZyYW1lIG1vZGVcXG4gICAgICAgIC8vIDA2LU5PVi0wOTogbm93IGRlZmF1bHRpbmcgdG8gaWZyYW1lIG1vZGUgaWYgZmlsZSBpbnB1dCBpcyBkZXRlY3RlZFxcbiAgICAgICAgaWYgKG9wdGlvbnMuaWZyYW1lICE9PSBmYWxzZSAmJiAob3B0aW9ucy5pZnJhbWUgfHwgc2hvdWxkVXNlRnJhbWUpKSB7XFxuICAgICAgICAgICAgLy8gaGFjayB0byBmaXggU2FmYXJpIGhhbmcgKHRoYW5rcyB0byBUaW0gTW9sZW5kaWprIGZvciB0aGlzKVxcbiAgICAgICAgICAgIC8vIHNlZTogIGh0dHA6Ly9ncm91cHMuZ29vZ2xlLmNvbS9ncm91cC9qcXVlcnktZGV2L2Jyb3dzZV90aHJlYWQvdGhyZWFkLzM2Mzk1YjdhYjUxMGRkNWRcXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jbG9zZUtlZXBBbGl2ZSkge1xcbiAgICAgICAgICAgICAgICAkLmdldChvcHRpb25zLmNsb3NlS2VlcEFsaXZlLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgICAgICBqcXhociA9IGZpbGVVcGxvYWRJZnJhbWUoYSk7XFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIGpxeGhyID0gZmlsZVVwbG9hZElmcmFtZShhKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2UgaWYgKChoYXNGaWxlSW5wdXRzIHx8IG11bHRpcGFydCkgJiYgZmlsZUFQSSkge1xcbiAgICAgICAgICAgIGpxeGhyID0gZmlsZVVwbG9hZFhocihhKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAganF4aHIgPSAkLmFqYXgob3B0aW9ucyk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICAkZm9ybS5yZW1vdmVEYXRhKCdqcXhocicpLmRhdGEoJ2pxeGhyJywganF4aHIpO1xcblxcbiAgICAgICAgLy8gY2xlYXIgZWxlbWVudCBhcnJheVxcbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBlbGVtZW50cy5sZW5ndGg7IGsrKykge1xcbiAgICAgICAgICAgIGVsZW1lbnRzW2tdID0gbnVsbDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIC8vIGZpcmUgJ25vdGlmeScgZXZlbnRcXG4gICAgICAgIHRoaXMudHJpZ2dlcignZm9ybS1zdWJtaXQtbm90aWZ5JywgW3RoaXMsIG9wdGlvbnNdKTtcXG4gICAgICAgIHJldHVybiB0aGlzO1xcblxcbiAgICAgICAgLy8gdXRpbGl0eSBmbiBmb3IgZGVlcCBzZXJpYWxpemF0aW9uXFxuICAgICAgICBmdW5jdGlvbiBkZWVwU2VyaWFsaXplKGV4dHJhRGF0YSkge1xcbiAgICAgICAgICAgIHZhciBzZXJpYWxpemVkID0gJC5wYXJhbShleHRyYURhdGEsIG9wdGlvbnMudHJhZGl0aW9uYWwpLnNwbGl0KCcmJyk7XFxuICAgICAgICAgICAgdmFyIGxlbiA9IHNlcmlhbGl6ZWQubGVuZ3RoO1xcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcXG4gICAgICAgICAgICB2YXIgaSwgcGFydDtcXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcXG4gICAgICAgICAgICAgICAgLy8gIzI1MjsgdW5kbyBwYXJhbSBzcGFjZSByZXBsYWNlbWVudFxcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkW2ldID0gc2VyaWFsaXplZFtpXS5yZXBsYWNlKC9cXFxcKy9nLCAnICcpO1xcbiAgICAgICAgICAgICAgICBwYXJ0ID0gc2VyaWFsaXplZFtpXS5zcGxpdCgnPScpO1xcbiAgICAgICAgICAgICAgICAvLyAjMjc4OyB1c2UgYXJyYXkgaW5zdGVhZCBvZiBvYmplY3Qgc3RvcmFnZSwgZmF2b3JpbmcgYXJyYXkgc2VyaWFsaXphdGlvbnNcXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goW2RlY29kZVVSSUNvbXBvbmVudChwYXJ0WzBdKSwgZGVjb2RlVVJJQ29tcG9uZW50KHBhcnRbMV0pXSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgICAgICB9XFxuXFxuICAgICAgICAvLyBYTUxIdHRwUmVxdWVzdCBMZXZlbCAyIGZpbGUgdXBsb2FkcyAoYmlnIGhhdCB0aXAgdG8gZnJhbmNvaXMybWV0eilcXG4gICAgICAgIGZ1bmN0aW9uIGZpbGVVcGxvYWRYaHIoYSkge1xcbiAgICAgICAgICAgIHZhciBmb3JtZGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xcblxcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgICAgICAgICBmb3JtZGF0YS5hcHBlbmQoYVtpXS5uYW1lLCBhW2ldLnZhbHVlKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZXh0cmFEYXRhKSB7XFxuICAgICAgICAgICAgICAgIHZhciBzZXJpYWxpemVkRGF0YSA9IGRlZXBTZXJpYWxpemUob3B0aW9ucy5leHRyYURhdGEpO1xcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2VyaWFsaXplZERhdGEubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXJpYWxpemVkRGF0YVtpXSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1kYXRhLmFwcGVuZChzZXJpYWxpemVkRGF0YVtpXVswXSwgc2VyaWFsaXplZERhdGFbaV1bMV0pO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIG9wdGlvbnMuZGF0YSA9IG51bGw7XFxuXFxuICAgICAgICAgICAgdmFyIHMgPSAkLmV4dGVuZCh0cnVlLCB7fSwgJC5hamF4U2V0dGluZ3MsIG9wdGlvbnMsIHtcXG4gICAgICAgICAgICAgICAgY29udGVudFR5cGU6IGZhbHNlLFxcbiAgICAgICAgICAgICAgICBwcm9jZXNzRGF0YTogZmFsc2UsXFxuICAgICAgICAgICAgICAgIGNhY2hlOiBmYWxzZSxcXG4gICAgICAgICAgICAgICAgdHlwZTogbWV0aG9kIHx8ICdQT1NUJ1xcbiAgICAgICAgICAgIH0pO1xcblxcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnVwbG9hZFByb2dyZXNzKSB7XFxuICAgICAgICAgICAgICAgIC8vIHdvcmthcm91bmQgYmVjYXVzZSBqcVhIUiBkb2VzIG5vdCBleHBvc2UgdXBsb2FkIHByb3BlcnR5XFxuICAgICAgICAgICAgICAgIHMueGhyID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICAgICAgdmFyIHhociA9ICQuYWpheFNldHRpbmdzLnhocigpO1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKHhoci51cGxvYWQpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIudXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgZnVuY3Rpb24gKGV2ZW50KSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwZXJjZW50ID0gMDtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gZXZlbnQubG9hZGVkIHx8IGV2ZW50LnBvc2l0aW9uOyAvKmV2ZW50LnBvc2l0aW9uIGlzIGRlcHJlY2F0ZWQqL1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG90YWwgPSBldmVudC50b3RhbDtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50Lmxlbmd0aENvbXB1dGFibGUpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlcmNlbnQgPSBNYXRoLmNlaWwocG9zaXRpb24gLyB0b3RhbCAqIDEwMCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy51cGxvYWRQcm9ncmVzcyhldmVudCwgcG9zaXRpb24sIHRvdGFsLCBwZXJjZW50KTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBmYWxzZSk7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geGhyO1xcbiAgICAgICAgICAgICAgICB9O1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBzLmRhdGEgPSBudWxsO1xcbiAgICAgICAgICAgIHZhciBiZWZvcmVTZW5kID0gcy5iZWZvcmVTZW5kO1xcbiAgICAgICAgICAgIHMuYmVmb3JlU2VuZCA9IGZ1bmN0aW9uICh4aHIsIG8pIHtcXG4gICAgICAgICAgICAgICAgLy9TZW5kIEZvcm1EYXRhKCkgcHJvdmlkZWQgYnkgdXNlclxcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5mb3JtRGF0YSkge1xcbiAgICAgICAgICAgICAgICAgICAgby5kYXRhID0gb3B0aW9ucy5mb3JtRGF0YTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIG8uZGF0YSA9IGZvcm1kYXRhO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGlmIChiZWZvcmVTZW5kKSB7XFxuICAgICAgICAgICAgICAgICAgICBiZWZvcmVTZW5kLmNhbGwodGhpcywgeGhyLCBvKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH07XFxuICAgICAgICAgICAgcmV0dXJuICQuYWpheChzKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIC8vIHByaXZhdGUgZnVuY3Rpb24gZm9yIGhhbmRsaW5nIGZpbGUgdXBsb2FkcyAoaGF0IHRpcCB0byBZQUhPTyEpXFxuICAgICAgICBmdW5jdGlvbiBmaWxlVXBsb2FkSWZyYW1lKGEpIHtcXG4gICAgICAgICAgICB2YXIgZm9ybSA9ICRmb3JtWzBdLFxcbiAgICAgICAgICAgICAgICBlbCxcXG4gICAgICAgICAgICAgICAgaSxcXG4gICAgICAgICAgICAgICAgcyxcXG4gICAgICAgICAgICAgICAgZyxcXG4gICAgICAgICAgICAgICAgaWQsXFxuICAgICAgICAgICAgICAgICRpbyxcXG4gICAgICAgICAgICAgICAgaW8sXFxuICAgICAgICAgICAgICAgIHhocixcXG4gICAgICAgICAgICAgICAgc3ViLFxcbiAgICAgICAgICAgICAgICBuLFxcbiAgICAgICAgICAgICAgICB0aW1lZE91dCxcXG4gICAgICAgICAgICAgICAgdGltZW91dEhhbmRsZTtcXG4gICAgICAgICAgICB2YXIgZGVmZXJyZWQgPSAkLkRlZmVycmVkKCk7XFxuXFxuICAgICAgICAgICAgLy8gIzM0MVxcbiAgICAgICAgICAgIGRlZmVycmVkLmFib3J0ID0gZnVuY3Rpb24gKHN0YXR1cykge1xcbiAgICAgICAgICAgICAgICB4aHIuYWJvcnQoc3RhdHVzKTtcXG4gICAgICAgICAgICB9O1xcblxcbiAgICAgICAgICAgIGlmIChhKSB7XFxuICAgICAgICAgICAgICAgIC8vIGVuc3VyZSB0aGF0IGV2ZXJ5IHNlcmlhbGl6ZWQgaW5wdXQgaXMgc3RpbGwgZW5hYmxlZFxcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgICAgICAgICAgIGVsID0gJChlbGVtZW50c1tpXSk7XFxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzUHJvcCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLnByb3AoJ2Rpc2FibGVkJywgZmFsc2UpO1xcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5yZW1vdmVBdHRyKCdkaXNhYmxlZCcpO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIHMgPSAkLmV4dGVuZCh0cnVlLCB7fSwgJC5hamF4U2V0dGluZ3MsIG9wdGlvbnMpO1xcbiAgICAgICAgICAgIHMuY29udGV4dCA9IHMuY29udGV4dCB8fCBzO1xcbiAgICAgICAgICAgIGlkID0gJ2pxRm9ybUlPJyArIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xcbiAgICAgICAgICAgIGlmIChzLmlmcmFtZVRhcmdldCkge1xcbiAgICAgICAgICAgICAgICAkaW8gPSAkKHMuaWZyYW1lVGFyZ2V0KTtcXG4gICAgICAgICAgICAgICAgbiA9ICRpby5hdHRyMignbmFtZScpO1xcbiAgICAgICAgICAgICAgICBpZiAoIW4pIHtcXG4gICAgICAgICAgICAgICAgICAgICRpby5hdHRyMignbmFtZScsIGlkKTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIGlkID0gbjtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICRpbyA9ICQoJzxpZnJhbWUgbmFtZT1cXFwiJyArIGlkICsgJ1xcXCIgc3JjPVxcXCInICsgcy5pZnJhbWVTcmMgKyAnXFxcIiAvPicpO1xcbiAgICAgICAgICAgICAgICAkaW8uY3NzKHsgcG9zaXRpb246ICdhYnNvbHV0ZScsIHRvcDogJy0xMDAwcHgnLCBsZWZ0OiAnLTEwMDBweCcgfSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlvID0gJGlvWzBdO1xcblxcbiAgICAgICAgICAgIHhociA9IHsgLy8gbW9jayBvYmplY3RcXG4gICAgICAgICAgICAgICAgYWJvcnRlZDogMCxcXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VUZXh0OiBudWxsLFxcbiAgICAgICAgICAgICAgICByZXNwb25zZVhNTDogbnVsbCxcXG4gICAgICAgICAgICAgICAgc3RhdHVzOiAwLFxcbiAgICAgICAgICAgICAgICBzdGF0dXNUZXh0OiAnbi9hJyxcXG4gICAgICAgICAgICAgICAgZ2V0QWxsUmVzcG9uc2VIZWFkZXJzOiBmdW5jdGlvbiBnZXRBbGxSZXNwb25zZUhlYWRlcnMoKSB7fSxcXG4gICAgICAgICAgICAgICAgZ2V0UmVzcG9uc2VIZWFkZXI6IGZ1bmN0aW9uIGdldFJlc3BvbnNlSGVhZGVyKCkge30sXFxuICAgICAgICAgICAgICAgIHNldFJlcXVlc3RIZWFkZXI6IGZ1bmN0aW9uIHNldFJlcXVlc3RIZWFkZXIoKSB7fSxcXG4gICAgICAgICAgICAgICAgYWJvcnQ6IGZ1bmN0aW9uIGFib3J0KHN0YXR1cykge1xcbiAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSBzdGF0dXMgPT09ICd0aW1lb3V0JyA/ICd0aW1lb3V0JyA6ICdhYm9ydGVkJztcXG4gICAgICAgICAgICAgICAgICAgIGxvZygnYWJvcnRpbmcgdXBsb2FkLi4uICcgKyBlKTtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWJvcnRlZCA9IDE7XFxuXFxuICAgICAgICAgICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICMyMTQsICMyNTdcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW8uY29udGVudFdpbmRvdy5kb2N1bWVudC5leGVjQ29tbWFuZCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpby5jb250ZW50V2luZG93LmRvY3VtZW50LmV4ZWNDb21tYW5kKCdTdG9wJyk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxcblxcbiAgICAgICAgICAgICAgICAgICAgJGlvLmF0dHIoJ3NyYycsIHMuaWZyYW1lU3JjKTsgLy8gYWJvcnQgb3AgaW4gcHJvZ3Jlc3NcXG4gICAgICAgICAgICAgICAgICAgIHhoci5lcnJvciA9IGU7XFxuICAgICAgICAgICAgICAgICAgICBpZiAocy5lcnJvcikge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHMuZXJyb3IuY2FsbChzLmNvbnRleHQsIHhociwgZSwgc3RhdHVzKTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIGlmIChnKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgJC5ldmVudC50cmlnZ2VyKFxcXCJhamF4RXJyb3JcXFwiLCBbeGhyLCBzLCBlXSk7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICBpZiAocy5jb21wbGV0ZSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHMuY29tcGxldGUuY2FsbChzLmNvbnRleHQsIHhociwgZSk7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9O1xcblxcbiAgICAgICAgICAgIGcgPSBzLmdsb2JhbDtcXG4gICAgICAgICAgICAvLyB0cmlnZ2VyIGFqYXggZ2xvYmFsIGV2ZW50cyBzbyB0aGF0IGFjdGl2aXR5L2Jsb2NrIGluZGljYXRvcnMgd29yayBsaWtlIG5vcm1hbFxcbiAgICAgICAgICAgIGlmIChnICYmIDAgPT09ICQuYWN0aXZlKyspIHtcXG4gICAgICAgICAgICAgICAgJC5ldmVudC50cmlnZ2VyKFxcXCJhamF4U3RhcnRcXFwiKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYgKGcpIHtcXG4gICAgICAgICAgICAgICAgJC5ldmVudC50cmlnZ2VyKFxcXCJhamF4U2VuZFxcXCIsIFt4aHIsIHNdKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaWYgKHMuYmVmb3JlU2VuZCAmJiBzLmJlZm9yZVNlbmQuY2FsbChzLmNvbnRleHQsIHhociwgcykgPT09IGZhbHNlKSB7XFxuICAgICAgICAgICAgICAgIGlmIChzLmdsb2JhbCkge1xcbiAgICAgICAgICAgICAgICAgICAgJC5hY3RpdmUtLTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmVycmVkO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZiAoeGhyLmFib3J0ZWQpIHtcXG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KCk7XFxuICAgICAgICAgICAgICAgIHJldHVybiBkZWZlcnJlZDtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgLy8gYWRkIHN1Ym1pdHRpbmcgZWxlbWVudCB0byBkYXRhIGlmIHdlIGtub3cgaXRcXG4gICAgICAgICAgICBzdWIgPSBmb3JtLmNsaztcXG4gICAgICAgICAgICBpZiAoc3ViKSB7XFxuICAgICAgICAgICAgICAgIG4gPSBzdWIubmFtZTtcXG4gICAgICAgICAgICAgICAgaWYgKG4gJiYgIXN1Yi5kaXNhYmxlZCkge1xcbiAgICAgICAgICAgICAgICAgICAgcy5leHRyYURhdGEgPSBzLmV4dHJhRGF0YSB8fCB7fTtcXG4gICAgICAgICAgICAgICAgICAgIHMuZXh0cmFEYXRhW25dID0gc3ViLnZhbHVlO1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1Yi50eXBlID09IFxcXCJpbWFnZVxcXCIpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBzLmV4dHJhRGF0YVtuICsgJy54J10gPSBmb3JtLmNsa194O1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHMuZXh0cmFEYXRhW24gKyAnLnknXSA9IGZvcm0uY2xrX3k7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgdmFyIENMSUVOVF9USU1FT1VUX0FCT1JUID0gMTtcXG4gICAgICAgICAgICB2YXIgU0VSVkVSX0FCT1JUID0gMjtcXG5cXG4gICAgICAgICAgICBmdW5jdGlvbiBnZXREb2MoZnJhbWUpIHtcXG4gICAgICAgICAgICAgICAgLyogaXQgbG9va3MgbGlrZSBjb250ZW50V2luZG93IG9yIGNvbnRlbnREb2N1bWVudCBkbyBub3RcXG4gICAgICAgICAgICAgICAgICogY2FycnkgdGhlIHByb3RvY29sIHByb3BlcnR5IGluIGllOCwgd2hlbiBydW5uaW5nIHVuZGVyIHNzbFxcbiAgICAgICAgICAgICAgICAgKiBmcmFtZS5kb2N1bWVudCBpcyB0aGUgb25seSB2YWxpZCByZXNwb25zZSBkb2N1bWVudCwgc2luY2VcXG4gICAgICAgICAgICAgICAgICogdGhlIHByb3RvY29sIGlzIGtub3cgYnV0IG5vdCBvbiB0aGUgb3RoZXIgdHdvIG9iamVjdHMuIHN0cmFuZ2U/XFxuICAgICAgICAgICAgICAgICAqIFxcXCJTYW1lIG9yaWdpbiBwb2xpY3lcXFwiIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2FtZV9vcmlnaW5fcG9saWN5XFxuICAgICAgICAgICAgICAgICAqL1xcblxcbiAgICAgICAgICAgICAgICB2YXIgZG9jID0gbnVsbDtcXG5cXG4gICAgICAgICAgICAgICAgLy8gSUU4IGNhc2NhZGluZyBhY2Nlc3MgY2hlY2tcXG4gICAgICAgICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChmcmFtZS5jb250ZW50V2luZG93KSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jID0gZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XFxuICAgICAgICAgICAgICAgICAgICAvLyBJRTggYWNjZXNzIGRlbmllZCB1bmRlciBzc2wgJiBtaXNzaW5nIHByb3RvY29sXFxuICAgICAgICAgICAgICAgICAgICBsb2coJ2Nhbm5vdCBnZXQgaWZyYW1lLmNvbnRlbnRXaW5kb3cgZG9jdW1lbnQ6ICcgKyBlcnIpO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIGlmIChkb2MpIHtcXG4gICAgICAgICAgICAgICAgICAgIC8vIHN1Y2Nlc3NmdWwgZ2V0dGluZyBjb250ZW50XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG9jO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICAgICAgICAvLyBzaW1wbHkgY2hlY2tpbmcgbWF5IHRocm93IGluIGllOCB1bmRlciBzc2wgb3IgbWlzbWF0Y2hlZCBwcm90b2NvbFxcbiAgICAgICAgICAgICAgICAgICAgZG9jID0gZnJhbWUuY29udGVudERvY3VtZW50ID8gZnJhbWUuY29udGVudERvY3VtZW50IDogZnJhbWUuZG9jdW1lbnQ7XFxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xcbiAgICAgICAgICAgICAgICAgICAgLy8gbGFzdCBhdHRlbXB0XFxuICAgICAgICAgICAgICAgICAgICBsb2coJ2Nhbm5vdCBnZXQgaWZyYW1lLmNvbnRlbnREb2N1bWVudDogJyArIGVycik7XFxuICAgICAgICAgICAgICAgICAgICBkb2MgPSBmcmFtZS5kb2N1bWVudDtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9jO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAvLyBSYWlscyBDU1JGIGhhY2sgKHRoYW5rcyB0byBZdmFuIEJhcnRoZWxlbXkpXFxuICAgICAgICAgICAgdmFyIGNzcmZfdG9rZW4gPSAkKCdtZXRhW25hbWU9Y3NyZi10b2tlbl0nKS5hdHRyKCdjb250ZW50Jyk7XFxuICAgICAgICAgICAgdmFyIGNzcmZfcGFyYW0gPSAkKCdtZXRhW25hbWU9Y3NyZi1wYXJhbV0nKS5hdHRyKCdjb250ZW50Jyk7XFxuICAgICAgICAgICAgaWYgKGNzcmZfcGFyYW0gJiYgY3NyZl90b2tlbikge1xcbiAgICAgICAgICAgICAgICBzLmV4dHJhRGF0YSA9IHMuZXh0cmFEYXRhIHx8IHt9O1xcbiAgICAgICAgICAgICAgICBzLmV4dHJhRGF0YVtjc3JmX3BhcmFtXSA9IGNzcmZfdG9rZW47XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIC8vIHRha2UgYSBicmVhdGggc28gdGhhdCBwZW5kaW5nIHJlcGFpbnRzIGdldCBzb21lIGNwdSB0aW1lIGJlZm9yZSB0aGUgdXBsb2FkIHN0YXJ0c1xcbiAgICAgICAgICAgIGZ1bmN0aW9uIGRvU3VibWl0KCkge1xcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgZm9ybSBhdHRycyBhcmUgc2V0XFxuICAgICAgICAgICAgICAgIHZhciB0ID0gJGZvcm0uYXR0cjIoJ3RhcmdldCcpLFxcbiAgICAgICAgICAgICAgICAgICAgYSA9ICRmb3JtLmF0dHIyKCdhY3Rpb24nKSxcXG4gICAgICAgICAgICAgICAgICAgIG1wID0gJ211bHRpcGFydC9mb3JtLWRhdGEnLFxcbiAgICAgICAgICAgICAgICAgICAgZXQgPSAkZm9ybS5hdHRyKCdlbmN0eXBlJykgfHwgJGZvcm0uYXR0cignZW5jb2RpbmcnKSB8fCBtcDtcXG5cXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIGZvcm0gYXR0cnMgaW4gSUUgZnJpZW5kbHkgd2F5XFxuICAgICAgICAgICAgICAgIGZvcm0uc2V0QXR0cmlidXRlKCd0YXJnZXQnLCBpZCk7XFxuICAgICAgICAgICAgICAgIGlmICghbWV0aG9kIHx8IC9wb3N0L2kudGVzdChtZXRob2QpKSB7XFxuICAgICAgICAgICAgICAgICAgICBmb3JtLnNldEF0dHJpYnV0ZSgnbWV0aG9kJywgJ1BPU1QnKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBpZiAoYSAhPSBzLnVybCkge1xcbiAgICAgICAgICAgICAgICAgICAgZm9ybS5zZXRBdHRyaWJ1dGUoJ2FjdGlvbicsIHMudXJsKTtcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICAvLyBpZSBib3JrcyBpbiBzb21lIGNhc2VzIHdoZW4gc2V0dGluZyBlbmNvZGluZ1xcbiAgICAgICAgICAgICAgICBpZiAoIXMuc2tpcEVuY29kaW5nT3ZlcnJpZGUgJiYgKCFtZXRob2QgfHwgL3Bvc3QvaS50ZXN0KG1ldGhvZCkpKSB7XFxuICAgICAgICAgICAgICAgICAgICAkZm9ybS5hdHRyKHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGluZzogJ211bHRpcGFydC9mb3JtLWRhdGEnLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuY3R5cGU6ICdtdWx0aXBhcnQvZm9ybS1kYXRhJ1xcbiAgICAgICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgLy8gc3VwcG9ydCB0aW1vdXRcXG4gICAgICAgICAgICAgICAgaWYgKHMudGltZW91dCkge1xcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dEhhbmRsZSA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVkT3V0ID0gdHJ1ZTtjYihDTElFTlRfVElNRU9VVF9BQk9SVCk7XFxuICAgICAgICAgICAgICAgICAgICB9LCBzLnRpbWVvdXQpO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIC8vIGxvb2sgZm9yIHNlcnZlciBhYm9ydHNcXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gY2hlY2tTdGF0ZSgpIHtcXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXRlID0gZ2V0RG9jKGlvKS5yZWFkeVN0YXRlO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZygnc3RhdGUgPSAnICsgc3RhdGUpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZSAmJiBzdGF0ZS50b0xvd2VyQ2FzZSgpID09ICd1bmluaXRpYWxpemVkJykge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGNoZWNrU3RhdGUsIDUwKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nKCdTZXJ2ZXIgYWJvcnQ6ICcsIGUsICcgKCcsIGUubmFtZSwgJyknKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBjYihTRVJWRVJfQUJPUlQpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0SGFuZGxlKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SGFuZGxlKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dEhhbmRsZSA9IHVuZGVmaW5lZDtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICAvLyBhZGQgXFxcImV4dHJhXFxcIiBkYXRhIHRvIGZvcm0gaWYgcHJvdmlkZWQgaW4gb3B0aW9uc1xcbiAgICAgICAgICAgICAgICB2YXIgZXh0cmFJbnB1dHMgPSBbXTtcXG4gICAgICAgICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChzLmV4dHJhRGF0YSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG4gaW4gcy5leHRyYURhdGEpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMuZXh0cmFEYXRhLmhhc093blByb3BlcnR5KG4pKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB1c2luZyB0aGUgJC5wYXJhbSBmb3JtYXQgdGhhdCBhbGxvd3MgZm9yIG11bHRpcGxlIHZhbHVlcyB3aXRoIHRoZSBzYW1lIG5hbWVcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkLmlzUGxhaW5PYmplY3Qocy5leHRyYURhdGFbbl0pICYmIHMuZXh0cmFEYXRhW25dLmhhc093blByb3BlcnR5KCduYW1lJykgJiYgcy5leHRyYURhdGFbbl0uaGFzT3duUHJvcGVydHkoJ3ZhbHVlJykpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRyYUlucHV0cy5wdXNoKCQoJzxpbnB1dCB0eXBlPVxcXCJoaWRkZW5cXFwiIG5hbWU9XFxcIicgKyBzLmV4dHJhRGF0YVtuXS5uYW1lICsgJ1xcXCI+JykudmFsKHMuZXh0cmFEYXRhW25dLnZhbHVlKS5hcHBlbmRUbyhmb3JtKVswXSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhSW5wdXRzLnB1c2goJCgnPGlucHV0IHR5cGU9XFxcImhpZGRlblxcXCIgbmFtZT1cXFwiJyArIG4gKyAnXFxcIj4nKS52YWwocy5leHRyYURhdGFbbl0pLmFwcGVuZFRvKGZvcm0pWzBdKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgICAgIGlmICghcy5pZnJhbWVUYXJnZXQpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGQgaWZyYW1lIHRvIGRvYyBhbmQgc3VibWl0IHRoZSBmb3JtXFxuICAgICAgICAgICAgICAgICAgICAgICAgJGlvLmFwcGVuZFRvKCdib2R5Jyk7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICBpZiAoaW8uYXR0YWNoRXZlbnQpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBpby5hdHRhY2hFdmVudCgnb25sb2FkJywgY2IpO1xcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBpby5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgY2IsIGZhbHNlKTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoY2hlY2tTdGF0ZSwgMTUpO1xcblxcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtLnN1Ym1pdCgpO1xcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8ganVzdCBpbiBjYXNlIGZvcm0gaGFzIGVsZW1lbnQgd2l0aCBuYW1lL2lkIG9mICdzdWJtaXQnXFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN1Ym1pdEZuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZm9ybScpLnN1Ym1pdDtcXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJtaXRGbi5hcHBseShmb3JtKTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlc2V0IGF0dHJzIGFuZCByZW1vdmUgXFxcImV4dHJhXFxcIiBpbnB1dCBlbGVtZW50c1xcbiAgICAgICAgICAgICAgICAgICAgZm9ybS5zZXRBdHRyaWJ1dGUoJ2FjdGlvbicsIGEpO1xcbiAgICAgICAgICAgICAgICAgICAgZm9ybS5zZXRBdHRyaWJ1dGUoJ2VuY3R5cGUnLCBldCk7IC8vICMzODBcXG4gICAgICAgICAgICAgICAgICAgIGlmICh0KSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybS5zZXRBdHRyaWJ1dGUoJ3RhcmdldCcsIHQpO1xcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAkZm9ybS5yZW1vdmVBdHRyKCd0YXJnZXQnKTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICQoZXh0cmFJbnB1dHMpLnJlbW92ZSgpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmIChzLmZvcmNlU3luYykge1xcbiAgICAgICAgICAgICAgICBkb1N1Ym1pdCgpO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZG9TdWJtaXQsIDEwKTsgLy8gdGhpcyBsZXRzIGRvbSB1cGRhdGVzIHJlbmRlclxcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICB2YXIgZGF0YSxcXG4gICAgICAgICAgICAgICAgZG9jLFxcbiAgICAgICAgICAgICAgICBkb21DaGVja0NvdW50ID0gNTAsXFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrUHJvY2Vzc2VkO1xcblxcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNiKGUpIHtcXG4gICAgICAgICAgICAgICAgaWYgKHhoci5hYm9ydGVkIHx8IGNhbGxiYWNrUHJvY2Vzc2VkKSB7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgZG9jID0gZ2V0RG9jKGlvKTtcXG4gICAgICAgICAgICAgICAgaWYgKCFkb2MpIHtcXG4gICAgICAgICAgICAgICAgICAgIGxvZygnY2Fubm90IGFjY2VzcyByZXNwb25zZSBkb2N1bWVudCcpO1xcbiAgICAgICAgICAgICAgICAgICAgZSA9IFNFUlZFUl9BQk9SVDtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBpZiAoZSA9PT0gQ0xJRU5UX1RJTUVPVVRfQUJPUlQgJiYgeGhyKSB7XFxuICAgICAgICAgICAgICAgICAgICB4aHIuYWJvcnQoJ3RpbWVvdXQnKTtcXG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdCh4aHIsICd0aW1lb3V0Jyk7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZSA9PSBTRVJWRVJfQUJPUlQgJiYgeGhyKSB7XFxuICAgICAgICAgICAgICAgICAgICB4aHIuYWJvcnQoJ3NlcnZlciBhYm9ydCcpO1xcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KHhociwgJ2Vycm9yJywgJ3NlcnZlciBhYm9ydCcpO1xcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIGlmICghZG9jIHx8IGRvYy5sb2NhdGlvbi5ocmVmID09IHMuaWZyYW1lU3JjKSB7XFxuICAgICAgICAgICAgICAgICAgICAvLyByZXNwb25zZSBub3QgcmVjZWl2ZWQgeWV0XFxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRpbWVkT3V0KSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGlmIChpby5kZXRhY2hFdmVudCkge1xcbiAgICAgICAgICAgICAgICAgICAgaW8uZGV0YWNoRXZlbnQoJ29ubG9hZCcsIGNiKTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIGlvLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBjYiwgZmFsc2UpO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIHZhciBzdGF0dXMgPSAnc3VjY2VzcycsXFxuICAgICAgICAgICAgICAgICAgICBlcnJNc2c7XFxuICAgICAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICAgICAgICBpZiAodGltZWRPdXQpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyAndGltZW91dCc7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgICAgICB2YXIgaXNYbWwgPSBzLmRhdGFUeXBlID09ICd4bWwnIHx8IGRvYy5YTUxEb2N1bWVudCB8fCAkLmlzWE1MRG9jKGRvYyk7XFxuICAgICAgICAgICAgICAgICAgICBsb2coJ2lzWG1sPScgKyBpc1htbCk7XFxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzWG1sICYmIHdpbmRvdy5vcGVyYSAmJiAoZG9jLmJvZHkgPT09IG51bGwgfHwgIWRvYy5ib2R5LmlubmVySFRNTCkpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoLS1kb21DaGVja0NvdW50KSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluIHNvbWUgYnJvd3NlcnMgKE9wZXJhKSB0aGUgaWZyYW1lIERPTSBpcyBub3QgYWx3YXlzIHRyYXZlcnNhYmxlIHdoZW5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIG9ubG9hZCBjYWxsYmFjayBmaXJlcywgc28gd2UgbG9vcCBhIGJpdCB0byBhY2NvbW1vZGF0ZVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2coJ3JlcXVlaW5nIG9uTG9hZCBjYWxsYmFjaywgRE9NIG5vdCBhdmFpbGFibGUnKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChjYiwgMjUwKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsZXQgdGhpcyBmYWxsIHRocm91Z2ggYmVjYXVzZSBzZXJ2ZXIgcmVzcG9uc2UgY291bGQgYmUgYW4gZW1wdHkgZG9jdW1lbnRcXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2xvZygnQ291bGQgbm90IGFjY2VzcyBpZnJhbWUgRE9NIGFmdGVyIG11dGlwbGUgdHJpZXMuJyk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgLy90aHJvdyAnRE9NRXhjZXB0aW9uOiBub3QgYXZhaWxhYmxlJztcXG4gICAgICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgICAgIC8vbG9nKCdyZXNwb25zZSBkZXRlY3RlZCcpO1xcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRvY1Jvb3QgPSBkb2MuYm9keSA/IGRvYy5ib2R5IDogZG9jLmRvY3VtZW50RWxlbWVudDtcXG4gICAgICAgICAgICAgICAgICAgIHhoci5yZXNwb25zZVRleHQgPSBkb2NSb290ID8gZG9jUm9vdC5pbm5lckhUTUwgOiBudWxsO1xcbiAgICAgICAgICAgICAgICAgICAgeGhyLnJlc3BvbnNlWE1MID0gZG9jLlhNTERvY3VtZW50ID8gZG9jLlhNTERvY3VtZW50IDogZG9jO1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzWG1sKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcy5kYXRhVHlwZSA9ICd4bWwnO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgeGhyLmdldFJlc3BvbnNlSGVhZGVyID0gZnVuY3Rpb24gKGhlYWRlcikge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoZWFkZXJzID0geyAnY29udGVudC10eXBlJzogcy5kYXRhVHlwZSB9O1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoZWFkZXJzW2hlYWRlci50b0xvd2VyQ2FzZSgpXTtcXG4gICAgICAgICAgICAgICAgICAgIH07XFxuICAgICAgICAgICAgICAgICAgICAvLyBzdXBwb3J0IGZvciBYSFIgJ3N0YXR1cycgJiAnc3RhdHVzVGV4dCcgZW11bGF0aW9uIDpcXG4gICAgICAgICAgICAgICAgICAgIGlmIChkb2NSb290KSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnN0YXR1cyA9IE51bWJlcihkb2NSb290LmdldEF0dHJpYnV0ZSgnc3RhdHVzJykpIHx8IHhoci5zdGF0dXM7XFxuICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnN0YXR1c1RleHQgPSBkb2NSb290LmdldEF0dHJpYnV0ZSgnc3RhdHVzVGV4dCcpIHx8IHhoci5zdGF0dXNUZXh0O1xcbiAgICAgICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICAgICAgdmFyIGR0ID0gKHMuZGF0YVR5cGUgfHwgJycpLnRvTG93ZXJDYXNlKCk7XFxuICAgICAgICAgICAgICAgICAgICB2YXIgc2NyID0gLyhqc29ufHNjcmlwdHx0ZXh0KS8udGVzdChkdCk7XFxuICAgICAgICAgICAgICAgICAgICBpZiAoc2NyIHx8IHMudGV4dGFyZWEpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzZWUgaWYgdXNlciBlbWJlZGRlZCByZXNwb25zZSBpbiB0ZXh0YXJlYVxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YSA9IGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSgndGV4dGFyZWEnKVswXTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGEpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnJlc3BvbnNlVGV4dCA9IHRhLnZhbHVlO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzdXBwb3J0IGZvciBYSFIgJ3N0YXR1cycgJiAnc3RhdHVzVGV4dCcgZW11bGF0aW9uIDpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnN0YXR1cyA9IE51bWJlcih0YS5nZXRBdHRyaWJ1dGUoJ3N0YXR1cycpKSB8fCB4aHIuc3RhdHVzO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIuc3RhdHVzVGV4dCA9IHRhLmdldEF0dHJpYnV0ZSgnc3RhdHVzVGV4dCcpIHx8IHhoci5zdGF0dXNUZXh0O1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2NyKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFjY291bnQgZm9yIGJyb3dzZXJzIGluamVjdGluZyBwcmUgYXJvdW5kIGpzb24gcmVzcG9uc2VcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByZSA9IGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSgncHJlJylbMF07XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiID0gZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdib2R5JylbMF07XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmUpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5yZXNwb25zZVRleHQgPSBwcmUudGV4dENvbnRlbnQgPyBwcmUudGV4dENvbnRlbnQgOiBwcmUuaW5uZXJUZXh0O1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGIpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5yZXNwb25zZVRleHQgPSBiLnRleHRDb250ZW50ID8gYi50ZXh0Q29udGVudCA6IGIuaW5uZXJUZXh0O1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkdCA9PSAneG1sJyAmJiAheGhyLnJlc3BvbnNlWE1MICYmIHhoci5yZXNwb25zZVRleHQpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIucmVzcG9uc2VYTUwgPSB0b1htbCh4aHIucmVzcG9uc2VUZXh0KTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGh0dHBEYXRhKHhociwgZHQsIHMpO1xcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzID0gJ3BhcnNlcmVycm9yJztcXG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIuZXJyb3IgPSBlcnJNc2cgPSBlcnIgfHwgc3RhdHVzO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcXG4gICAgICAgICAgICAgICAgICAgIGxvZygnZXJyb3IgY2F1Z2h0OiAnLCBlcnIpO1xcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzID0gJ2Vycm9yJztcXG4gICAgICAgICAgICAgICAgICAgIHhoci5lcnJvciA9IGVyck1zZyA9IGVyciB8fCBzdGF0dXM7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgaWYgKHhoci5hYm9ydGVkKSB7XFxuICAgICAgICAgICAgICAgICAgICBsb2coJ3VwbG9hZCBhYm9ydGVkJyk7XFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMgPSBudWxsO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIGlmICh4aHIuc3RhdHVzKSB7XFxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSd2ZSBzZXQgeGhyLnN0YXR1c1xcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzID0geGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8IDMwMCB8fCB4aHIuc3RhdHVzID09PSAzMDQgPyAnc3VjY2VzcycgOiAnZXJyb3InO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIC8vIG9yZGVyaW5nIG9mIHRoZXNlIGNhbGxiYWNrcy90cmlnZ2VycyBpcyBvZGQsIGJ1dCB0aGF0J3MgaG93ICQuYWpheCBkb2VzIGl0XFxuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMgPT09ICdzdWNjZXNzJykge1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKHMuc3VjY2Vzcykge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHMuc3VjY2Vzcy5jYWxsKHMuY29udGV4dCwgZGF0YSwgJ3N1Y2Nlc3MnLCB4aHIpO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSh4aHIucmVzcG9uc2VUZXh0LCAnc3VjY2VzcycsIHhocik7XFxuICAgICAgICAgICAgICAgICAgICBpZiAoZykge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICQuZXZlbnQudHJpZ2dlcihcXFwiYWpheFN1Y2Nlc3NcXFwiLCBbeGhyLCBzXSk7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdHVzKSB7XFxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyTXNnID09PSB1bmRlZmluZWQpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJNc2cgPSB4aHIuc3RhdHVzVGV4dDtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIGlmIChzLmVycm9yKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcy5lcnJvci5jYWxsKHMuY29udGV4dCwgeGhyLCBzdGF0dXMsIGVyck1zZyk7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoeGhyLCAnZXJyb3InLCBlcnJNc2cpO1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKGcpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAkLmV2ZW50LnRyaWdnZXIoXFxcImFqYXhFcnJvclxcXCIsIFt4aHIsIHMsIGVyck1zZ10pO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIGlmIChnKSB7XFxuICAgICAgICAgICAgICAgICAgICAkLmV2ZW50LnRyaWdnZXIoXFxcImFqYXhDb21wbGV0ZVxcXCIsIFt4aHIsIHNdKTtcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICBpZiAoZyAmJiAhIC0tJC5hY3RpdmUpIHtcXG4gICAgICAgICAgICAgICAgICAgICQuZXZlbnQudHJpZ2dlcihcXFwiYWpheFN0b3BcXFwiKTtcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICBpZiAocy5jb21wbGV0ZSkge1xcbiAgICAgICAgICAgICAgICAgICAgcy5jb21wbGV0ZS5jYWxsKHMuY29udGV4dCwgeGhyLCBzdGF0dXMpO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrUHJvY2Vzc2VkID0gdHJ1ZTtcXG4gICAgICAgICAgICAgICAgaWYgKHMudGltZW91dCkge1xcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRIYW5kbGUpO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIC8vIGNsZWFuIHVwXFxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzLmlmcmFtZVRhcmdldCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICRpby5yZW1vdmUoKTtcXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgLy9hZGRpbmcgZWxzZSB0byBjbGVhbiB1cCBleGlzdGluZyBpZnJhbWUgcmVzcG9uc2UuXFxuICAgICAgICAgICAgICAgICAgICAgICAgJGlvLmF0dHIoJ3NyYycsIHMuaWZyYW1lU3JjKTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIHhoci5yZXNwb25zZVhNTCA9IG51bGw7XFxuICAgICAgICAgICAgICAgIH0sIDEwMCk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIHZhciB0b1htbCA9ICQucGFyc2VYTUwgfHwgZnVuY3Rpb24gKHMsIGRvYykge1xcbiAgICAgICAgICAgICAgICAvLyB1c2UgcGFyc2VYTUwgaWYgYXZhaWxhYmxlIChqUXVlcnkgMS41KylcXG4gICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5BY3RpdmVYT2JqZWN0KSB7XFxuICAgICAgICAgICAgICAgICAgICBkb2MgPSBuZXcgQWN0aXZlWE9iamVjdCgnTWljcm9zb2Z0LlhNTERPTScpO1xcbiAgICAgICAgICAgICAgICAgICAgZG9jLmFzeW5jID0gJ2ZhbHNlJztcXG4gICAgICAgICAgICAgICAgICAgIGRvYy5sb2FkWE1MKHMpO1xcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgZG9jID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhzLCAndGV4dC94bWwnKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9jICYmIGRvYy5kb2N1bWVudEVsZW1lbnQgJiYgZG9jLmRvY3VtZW50RWxlbWVudC5ub2RlTmFtZSAhPSAncGFyc2VyZXJyb3InID8gZG9jIDogbnVsbDtcXG4gICAgICAgICAgICB9O1xcbiAgICAgICAgICAgIHZhciBwYXJzZUpTT04gPSAkLnBhcnNlSlNPTiB8fCBmdW5jdGlvbiAocykge1xcbiAgICAgICAgICAgICAgICAvKmpzbGludCBldmlsOnRydWUgKi9cXG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvd1snZXZhbCddKCcoJyArIHMgKyAnKScpO1xcbiAgICAgICAgICAgIH07XFxuXFxuICAgICAgICAgICAgdmFyIGh0dHBEYXRhID0gZnVuY3Rpb24gaHR0cERhdGEoeGhyLCB0eXBlLCBzKSB7XFxuICAgICAgICAgICAgICAgIC8vIG1vc3RseSBsaWZ0ZWQgZnJvbSBqcTEuNC40XFxuXFxuICAgICAgICAgICAgICAgIHZhciBjdCA9IHhoci5nZXRSZXNwb25zZUhlYWRlcignY29udGVudC10eXBlJykgfHwgJycsXFxuICAgICAgICAgICAgICAgICAgICB4bWwgPSB0eXBlID09PSAneG1sJyB8fCAhdHlwZSAmJiBjdC5pbmRleE9mKCd4bWwnKSA+PSAwLFxcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHhtbCA/IHhoci5yZXNwb25zZVhNTCA6IHhoci5yZXNwb25zZVRleHQ7XFxuXFxuICAgICAgICAgICAgICAgIGlmICh4bWwgJiYgZGF0YS5kb2N1bWVudEVsZW1lbnQubm9kZU5hbWUgPT09ICdwYXJzZXJlcnJvcicpIHtcXG4gICAgICAgICAgICAgICAgICAgIGlmICgkLmVycm9yKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgJC5lcnJvcigncGFyc2VyZXJyb3InKTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBpZiAocyAmJiBzLmRhdGFGaWx0ZXIpIHtcXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBzLmRhdGFGaWx0ZXIoZGF0YSwgdHlwZSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdqc29uJyB8fCAhdHlwZSAmJiBjdC5pbmRleE9mKCdqc29uJykgPj0gMCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBwYXJzZUpTT04oZGF0YSk7XFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFxcXCJzY3JpcHRcXFwiIHx8ICF0eXBlICYmIGN0LmluZGV4T2YoXFxcImphdmFzY3JpcHRcXFwiKSA+PSAwKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgJC5nbG9iYWxFdmFsKGRhdGEpO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xcbiAgICAgICAgICAgIH07XFxuXFxuICAgICAgICAgICAgcmV0dXJuIGRlZmVycmVkO1xcbiAgICAgICAgfVxcbiAgICB9O1xcblxcbiAgICAvKipcXG4gICAgICogYWpheEZvcm0oKSBwcm92aWRlcyBhIG1lY2hhbmlzbSBmb3IgZnVsbHkgYXV0b21hdGluZyBmb3JtIHN1Ym1pc3Npb24uXFxuICAgICAqXFxuICAgICAqIFRoZSBhZHZhbnRhZ2VzIG9mIHVzaW5nIHRoaXMgbWV0aG9kIGluc3RlYWQgb2YgYWpheFN1Ym1pdCgpIGFyZTpcXG4gICAgICpcXG4gICAgICogMTogVGhpcyBtZXRob2Qgd2lsbCBpbmNsdWRlIGNvb3JkaW5hdGVzIGZvciA8aW5wdXQgdHlwZT1cXFwiaW1hZ2VcXFwiIC8+IGVsZW1lbnRzIChpZiB0aGUgZWxlbWVudFxcbiAgICAgKiAgICBpcyB1c2VkIHRvIHN1Ym1pdCB0aGUgZm9ybSkuXFxuICAgICAqIDIuIFRoaXMgbWV0aG9kIHdpbGwgaW5jbHVkZSB0aGUgc3VibWl0IGVsZW1lbnQncyBuYW1lL3ZhbHVlIGRhdGEgKGZvciB0aGUgZWxlbWVudCB0aGF0IHdhc1xcbiAgICAgKiAgICB1c2VkIHRvIHN1Ym1pdCB0aGUgZm9ybSkuXFxuICAgICAqIDMuIFRoaXMgbWV0aG9kIGJpbmRzIHRoZSBzdWJtaXQoKSBtZXRob2QgdG8gdGhlIGZvcm0gZm9yIHlvdS5cXG4gICAgICpcXG4gICAgICogVGhlIG9wdGlvbnMgYXJndW1lbnQgZm9yIGFqYXhGb3JtIHdvcmtzIGV4YWN0bHkgYXMgaXQgZG9lcyBmb3IgYWpheFN1Ym1pdC4gIGFqYXhGb3JtIG1lcmVseVxcbiAgICAgKiBwYXNzZXMgdGhlIG9wdGlvbnMgYXJndW1lbnQgYWxvbmcgYWZ0ZXIgcHJvcGVybHkgYmluZGluZyBldmVudHMgZm9yIHN1Ym1pdCBlbGVtZW50cyBhbmRcXG4gICAgICogdGhlIGZvcm0gaXRzZWxmLlxcbiAgICAgKi9cXG4gICAgJC5mbi5hamF4Rm9ybSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XFxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcXG4gICAgICAgIG9wdGlvbnMuZGVsZWdhdGlvbiA9IG9wdGlvbnMuZGVsZWdhdGlvbiAmJiAkLmlzRnVuY3Rpb24oJC5mbi5vbik7XFxuXFxuICAgICAgICAvLyBpbiBqUXVlcnkgMS4zKyB3ZSBjYW4gZml4IG1pc3Rha2VzIHdpdGggdGhlIHJlYWR5IHN0YXRlXFxuICAgICAgICBpZiAoIW9wdGlvbnMuZGVsZWdhdGlvbiAmJiB0aGlzLmxlbmd0aCA9PT0gMCkge1xcbiAgICAgICAgICAgIHZhciBvID0geyBzOiB0aGlzLnNlbGVjdG9yLCBjOiB0aGlzLmNvbnRleHQgfTtcXG4gICAgICAgICAgICBpZiAoISQuaXNSZWFkeSAmJiBvLnMpIHtcXG4gICAgICAgICAgICAgICAgbG9nKCdET00gbm90IHJlYWR5LCBxdWV1aW5nIGFqYXhGb3JtJyk7XFxuICAgICAgICAgICAgICAgICQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICAgICAgJChvLnMsIG8uYykuYWpheEZvcm0ob3B0aW9ucyk7XFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgLy8gaXMgeW91ciBET00gcmVhZHk/ICBodHRwOi8vZG9jcy5qcXVlcnkuY29tL1R1dG9yaWFsczpJbnRyb2R1Y2luZ18kKGRvY3VtZW50KS5yZWFkeSgpXFxuICAgICAgICAgICAgbG9nKCd0ZXJtaW5hdGluZzsgemVybyBlbGVtZW50cyBmb3VuZCBieSBzZWxlY3RvcicgKyAoJC5pc1JlYWR5ID8gJycgOiAnIChET00gbm90IHJlYWR5KScpKTtcXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChvcHRpb25zLmRlbGVnYXRpb24pIHtcXG4gICAgICAgICAgICAkKGRvY3VtZW50KS5vZmYoJ3N1Ym1pdC5mb3JtLXBsdWdpbicsIHRoaXMuc2VsZWN0b3IsIGRvQWpheFN1Ym1pdCkub2ZmKCdjbGljay5mb3JtLXBsdWdpbicsIHRoaXMuc2VsZWN0b3IsIGNhcHR1cmVTdWJtaXR0aW5nRWxlbWVudCkub24oJ3N1Ym1pdC5mb3JtLXBsdWdpbicsIHRoaXMuc2VsZWN0b3IsIG9wdGlvbnMsIGRvQWpheFN1Ym1pdCkub24oJ2NsaWNrLmZvcm0tcGx1Z2luJywgdGhpcy5zZWxlY3Rvciwgb3B0aW9ucywgY2FwdHVyZVN1Ym1pdHRpbmdFbGVtZW50KTtcXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiB0aGlzLmFqYXhGb3JtVW5iaW5kKCkuYmluZCgnc3VibWl0LmZvcm0tcGx1Z2luJywgb3B0aW9ucywgZG9BamF4U3VibWl0KS5iaW5kKCdjbGljay5mb3JtLXBsdWdpbicsIG9wdGlvbnMsIGNhcHR1cmVTdWJtaXR0aW5nRWxlbWVudCk7XFxuICAgIH07XFxuXFxuICAgIC8vIHByaXZhdGUgZXZlbnQgaGFuZGxlcnNcXG4gICAgZnVuY3Rpb24gZG9BamF4U3VibWl0KGUpIHtcXG4gICAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXFxuICAgICAgICB2YXIgb3B0aW9ucyA9IGUuZGF0YTtcXG4gICAgICAgIGlmICghZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xcbiAgICAgICAgICAgIC8vIGlmIGV2ZW50IGhhcyBiZWVuIGNhbmNlbGVkLCBkb24ndCBwcm9jZWVkXFxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgICAgICQoZS50YXJnZXQpLmFqYXhTdWJtaXQob3B0aW9ucyk7IC8vICMzNjVcXG4gICAgICAgIH1cXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBjYXB0dXJlU3VibWl0dGluZ0VsZW1lbnQoZSkge1xcbiAgICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cXG4gICAgICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldDtcXG4gICAgICAgIHZhciAkZWwgPSAkKHRhcmdldCk7XFxuICAgICAgICBpZiAoISRlbC5pcyhcXFwiW3R5cGU9c3VibWl0XSxbdHlwZT1pbWFnZV1cXFwiKSkge1xcbiAgICAgICAgICAgIC8vIGlzIHRoaXMgYSBjaGlsZCBlbGVtZW50IG9mIHRoZSBzdWJtaXQgZWw/ICAoZXg6IGEgc3BhbiB3aXRoaW4gYSBidXR0b24pXFxuICAgICAgICAgICAgdmFyIHQgPSAkZWwuY2xvc2VzdCgnW3R5cGU9c3VibWl0XScpO1xcbiAgICAgICAgICAgIGlmICh0Lmxlbmd0aCA9PT0gMCkge1xcbiAgICAgICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHRhcmdldCA9IHRbMF07XFxuICAgICAgICB9XFxuICAgICAgICB2YXIgZm9ybSA9IHRoaXM7XFxuICAgICAgICBmb3JtLmNsayA9IHRhcmdldDtcXG4gICAgICAgIGlmICh0YXJnZXQudHlwZSA9PSAnaW1hZ2UnKSB7XFxuICAgICAgICAgICAgaWYgKGUub2Zmc2V0WCAhPT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgICAgICAgIGZvcm0uY2xrX3ggPSBlLm9mZnNldFg7XFxuICAgICAgICAgICAgICAgIGZvcm0uY2xrX3kgPSBlLm9mZnNldFk7XFxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgJC5mbi5vZmZzZXQgPT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gJGVsLm9mZnNldCgpO1xcbiAgICAgICAgICAgICAgICBmb3JtLmNsa194ID0gZS5wYWdlWCAtIG9mZnNldC5sZWZ0O1xcbiAgICAgICAgICAgICAgICBmb3JtLmNsa195ID0gZS5wYWdlWSAtIG9mZnNldC50b3A7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgZm9ybS5jbGtfeCA9IGUucGFnZVggLSB0YXJnZXQub2Zmc2V0TGVmdDtcXG4gICAgICAgICAgICAgICAgZm9ybS5jbGtfeSA9IGUucGFnZVkgLSB0YXJnZXQub2Zmc2V0VG9wO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIC8vIGNsZWFyIGZvcm0gdmFyc1xcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgZm9ybS5jbGsgPSBmb3JtLmNsa194ID0gZm9ybS5jbGtfeSA9IG51bGw7XFxuICAgICAgICB9LCAxMDApO1xcbiAgICB9XFxuXFxuICAgIC8vIGFqYXhGb3JtVW5iaW5kIHVuYmluZHMgdGhlIGV2ZW50IGhhbmRsZXJzIHRoYXQgd2VyZSBib3VuZCBieSBhamF4Rm9ybVxcbiAgICAkLmZuLmFqYXhGb3JtVW5iaW5kID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMudW5iaW5kKCdzdWJtaXQuZm9ybS1wbHVnaW4gY2xpY2suZm9ybS1wbHVnaW4nKTtcXG4gICAgfTtcXG5cXG4gICAgLyoqXFxuICAgICAqIGZvcm1Ub0FycmF5KCkgZ2F0aGVycyBmb3JtIGVsZW1lbnQgZGF0YSBpbnRvIGFuIGFycmF5IG9mIG9iamVjdHMgdGhhdCBjYW5cXG4gICAgICogYmUgcGFzc2VkIHRvIGFueSBvZiB0aGUgZm9sbG93aW5nIGFqYXggZnVuY3Rpb25zOiAkLmdldCwgJC5wb3N0LCBvciBsb2FkLlxcbiAgICAgKiBFYWNoIG9iamVjdCBpbiB0aGUgYXJyYXkgaGFzIGJvdGggYSAnbmFtZScgYW5kICd2YWx1ZScgcHJvcGVydHkuICBBbiBleGFtcGxlIG9mXFxuICAgICAqIGFuIGFycmF5IGZvciBhIHNpbXBsZSBsb2dpbiBmb3JtIG1pZ2h0IGJlOlxcbiAgICAgKlxcbiAgICAgKiBbIHsgbmFtZTogJ3VzZXJuYW1lJywgdmFsdWU6ICdqcmVzaWcnIH0sIHsgbmFtZTogJ3Bhc3N3b3JkJywgdmFsdWU6ICdzZWNyZXQnIH0gXVxcbiAgICAgKlxcbiAgICAgKiBJdCBpcyB0aGlzIGFycmF5IHRoYXQgaXMgcGFzc2VkIHRvIHByZS1zdWJtaXQgY2FsbGJhY2sgZnVuY3Rpb25zIHByb3ZpZGVkIHRvIHRoZVxcbiAgICAgKiBhamF4U3VibWl0KCkgYW5kIGFqYXhGb3JtKCkgbWV0aG9kcy5cXG4gICAgICovXFxuICAgICQuZm4uZm9ybVRvQXJyYXkgPSBmdW5jdGlvbiAoc2VtYW50aWMsIGVsZW1lbnRzKSB7XFxuICAgICAgICB2YXIgYSA9IFtdO1xcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGE7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB2YXIgZm9ybSA9IHRoaXNbMF07XFxuICAgICAgICB2YXIgZm9ybUlkID0gdGhpcy5hdHRyKCdpZCcpO1xcbiAgICAgICAgdmFyIGVscyA9IHNlbWFudGljID8gZm9ybS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnKicpIDogZm9ybS5lbGVtZW50cztcXG4gICAgICAgIHZhciBlbHMyO1xcblxcbiAgICAgICAgaWYgKGVscyAmJiAhL01TSUUgWzY3OF0vLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcXG4gICAgICAgICAgICAvLyAjMzkwXFxuICAgICAgICAgICAgZWxzID0gJChlbHMpLmdldCgpOyAvLyBjb252ZXJ0IHRvIHN0YW5kYXJkIGFycmF5XFxuICAgICAgICB9XFxuXFxuICAgICAgICAvLyAjMzg2OyBhY2NvdW50IGZvciBpbnB1dHMgb3V0c2lkZSB0aGUgZm9ybSB3aGljaCB1c2UgdGhlICdmb3JtJyBhdHRyaWJ1dGVcXG4gICAgICAgIGlmIChmb3JtSWQpIHtcXG4gICAgICAgICAgICBlbHMyID0gJCgnOmlucHV0W2Zvcm09XFxcIicgKyBmb3JtSWQgKyAnXFxcIl0nKS5nZXQoKTsgLy8gaGF0IHRpcCBAdGhldFxcbiAgICAgICAgICAgIGlmIChlbHMyLmxlbmd0aCkge1xcbiAgICAgICAgICAgICAgICBlbHMgPSAoZWxzIHx8IFtdKS5jb25jYXQoZWxzMik7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKCFlbHMgfHwgIWVscy5sZW5ndGgpIHtcXG4gICAgICAgICAgICByZXR1cm4gYTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHZhciBpLCBqLCBuLCB2LCBlbCwgbWF4LCBqbWF4O1xcbiAgICAgICAgZm9yIChpID0gMCwgbWF4ID0gZWxzLmxlbmd0aDsgaSA8IG1heDsgaSsrKSB7XFxuICAgICAgICAgICAgZWwgPSBlbHNbaV07XFxuICAgICAgICAgICAgbiA9IGVsLm5hbWU7XFxuICAgICAgICAgICAgaWYgKCFuIHx8IGVsLmRpc2FibGVkKSB7XFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpZiAoc2VtYW50aWMgJiYgZm9ybS5jbGsgJiYgZWwudHlwZSA9PSBcXFwiaW1hZ2VcXFwiKSB7XFxuICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBpbWFnZSBpbnB1dHMgb24gdGhlIGZseSB3aGVuIHNlbWFudGljID09IHRydWVcXG4gICAgICAgICAgICAgICAgaWYgKGZvcm0uY2xrID09IGVsKSB7XFxuICAgICAgICAgICAgICAgICAgICBhLnB1c2goeyBuYW1lOiBuLCB2YWx1ZTogJChlbCkudmFsKCksIHR5cGU6IGVsLnR5cGUgfSk7XFxuICAgICAgICAgICAgICAgICAgICBhLnB1c2goeyBuYW1lOiBuICsgJy54JywgdmFsdWU6IGZvcm0uY2xrX3ggfSwgeyBuYW1lOiBuICsgJy55JywgdmFsdWU6IGZvcm0uY2xrX3kgfSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIHYgPSAkLmZpZWxkVmFsdWUoZWwsIHRydWUpO1xcbiAgICAgICAgICAgIGlmICh2ICYmIHYuY29uc3RydWN0b3IgPT0gQXJyYXkpIHtcXG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRzKSB7XFxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKGVsKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwLCBqbWF4ID0gdi5sZW5ndGg7IGogPCBqbWF4OyBqKyspIHtcXG4gICAgICAgICAgICAgICAgICAgIGEucHVzaCh7IG5hbWU6IG4sIHZhbHVlOiB2W2pdIH0pO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSBlbHNlIGlmIChmZWF0dXJlLmZpbGVhcGkgJiYgZWwudHlwZSA9PSAnZmlsZScpIHtcXG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRzKSB7XFxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKGVsKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB2YXIgZmlsZXMgPSBlbC5maWxlcztcXG4gICAgICAgICAgICAgICAgaWYgKGZpbGVzLmxlbmd0aCkge1xcbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGZpbGVzLmxlbmd0aDsgaisrKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgYS5wdXNoKHsgbmFtZTogbiwgdmFsdWU6IGZpbGVzW2pdLCB0eXBlOiBlbC50eXBlIH0pO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgLy8gIzE4MFxcbiAgICAgICAgICAgICAgICAgICAgYS5wdXNoKHsgbmFtZTogbiwgdmFsdWU6ICcnLCB0eXBlOiBlbC50eXBlIH0pO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSBlbHNlIGlmICh2ICE9PSBudWxsICYmIHR5cGVvZiB2ICE9ICd1bmRlZmluZWQnKSB7XFxuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50cykge1xcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChlbCk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgYS5wdXNoKHsgbmFtZTogbiwgdmFsdWU6IHYsIHR5cGU6IGVsLnR5cGUsIHJlcXVpcmVkOiBlbC5yZXF1aXJlZCB9KTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoIXNlbWFudGljICYmIGZvcm0uY2xrKSB7XFxuICAgICAgICAgICAgLy8gaW5wdXQgdHlwZT09J2ltYWdlJyBhcmUgbm90IGZvdW5kIGluIGVsZW1lbnRzIGFycmF5ISBoYW5kbGUgaXQgaGVyZVxcbiAgICAgICAgICAgIHZhciAkaW5wdXQgPSAkKGZvcm0uY2xrKSxcXG4gICAgICAgICAgICAgICAgaW5wdXQgPSAkaW5wdXRbMF07XFxuICAgICAgICAgICAgbiA9IGlucHV0Lm5hbWU7XFxuICAgICAgICAgICAgaWYgKG4gJiYgIWlucHV0LmRpc2FibGVkICYmIGlucHV0LnR5cGUgPT0gJ2ltYWdlJykge1xcbiAgICAgICAgICAgICAgICBhLnB1c2goeyBuYW1lOiBuLCB2YWx1ZTogJGlucHV0LnZhbCgpIH0pO1xcbiAgICAgICAgICAgICAgICBhLnB1c2goeyBuYW1lOiBuICsgJy54JywgdmFsdWU6IGZvcm0uY2xrX3ggfSwgeyBuYW1lOiBuICsgJy55JywgdmFsdWU6IGZvcm0uY2xrX3kgfSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIGE7XFxuICAgIH07XFxuXFxuICAgIC8qKlxcbiAgICAgKiBTZXJpYWxpemVzIGZvcm0gZGF0YSBpbnRvIGEgJ3N1Ym1pdHRhYmxlJyBzdHJpbmcuIFRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGEgc3RyaW5nXFxuICAgICAqIGluIHRoZSBmb3JtYXQ6IG5hbWUxPXZhbHVlMSZhbXA7bmFtZTI9dmFsdWUyXFxuICAgICAqL1xcbiAgICAkLmZuLmZvcm1TZXJpYWxpemUgPSBmdW5jdGlvbiAoc2VtYW50aWMpIHtcXG4gICAgICAgIC8vaGFuZCBvZmYgdG8galF1ZXJ5LnBhcmFtIGZvciBwcm9wZXIgZW5jb2RpbmdcXG4gICAgICAgIHJldHVybiAkLnBhcmFtKHRoaXMuZm9ybVRvQXJyYXkoc2VtYW50aWMpKTtcXG4gICAgfTtcXG5cXG4gICAgLyoqXFxuICAgICAqIFNlcmlhbGl6ZXMgYWxsIGZpZWxkIGVsZW1lbnRzIGluIHRoZSBqUXVlcnkgb2JqZWN0IGludG8gYSBxdWVyeSBzdHJpbmcuXFxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGEgc3RyaW5nIGluIHRoZSBmb3JtYXQ6IG5hbWUxPXZhbHVlMSZhbXA7bmFtZTI9dmFsdWUyXFxuICAgICAqL1xcbiAgICAkLmZuLmZpZWxkU2VyaWFsaXplID0gZnVuY3Rpb24gKHN1Y2Nlc3NmdWwpIHtcXG4gICAgICAgIHZhciBhID0gW107XFxuICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIHZhciBuID0gdGhpcy5uYW1lO1xcbiAgICAgICAgICAgIGlmICghbikge1xcbiAgICAgICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHZhciB2ID0gJC5maWVsZFZhbHVlKHRoaXMsIHN1Y2Nlc3NmdWwpO1xcbiAgICAgICAgICAgIGlmICh2ICYmIHYuY29uc3RydWN0b3IgPT0gQXJyYXkpIHtcXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG1heCA9IHYubGVuZ3RoOyBpIDwgbWF4OyBpKyspIHtcXG4gICAgICAgICAgICAgICAgICAgIGEucHVzaCh7IG5hbWU6IG4sIHZhbHVlOiB2W2ldIH0pO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSBlbHNlIGlmICh2ICE9PSBudWxsICYmIHR5cGVvZiB2ICE9ICd1bmRlZmluZWQnKSB7XFxuICAgICAgICAgICAgICAgIGEucHVzaCh7IG5hbWU6IHRoaXMubmFtZSwgdmFsdWU6IHYgfSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgICAgICAvL2hhbmQgb2ZmIHRvIGpRdWVyeS5wYXJhbSBmb3IgcHJvcGVyIGVuY29kaW5nXFxuICAgICAgICByZXR1cm4gJC5wYXJhbShhKTtcXG4gICAgfTtcXG5cXG4gICAgLyoqXFxuICAgICAqIFJldHVybnMgdGhlIHZhbHVlKHMpIG9mIHRoZSBlbGVtZW50IGluIHRoZSBtYXRjaGVkIHNldC4gIEZvciBleGFtcGxlLCBjb25zaWRlciB0aGUgZm9sbG93aW5nIGZvcm06XFxuICAgICAqXFxuICAgICAqICA8Zm9ybT48ZmllbGRzZXQ+XFxuICAgICAqICAgICAgPGlucHV0IG5hbWU9XFxcIkFcXFwiIHR5cGU9XFxcInRleHRcXFwiIC8+XFxuICAgICAqICAgICAgPGlucHV0IG5hbWU9XFxcIkFcXFwiIHR5cGU9XFxcInRleHRcXFwiIC8+XFxuICAgICAqICAgICAgPGlucHV0IG5hbWU9XFxcIkJcXFwiIHR5cGU9XFxcImNoZWNrYm94XFxcIiB2YWx1ZT1cXFwiQjFcXFwiIC8+XFxuICAgICAqICAgICAgPGlucHV0IG5hbWU9XFxcIkJcXFwiIHR5cGU9XFxcImNoZWNrYm94XFxcIiB2YWx1ZT1cXFwiQjJcXFwiLz5cXG4gICAgICogICAgICA8aW5wdXQgbmFtZT1cXFwiQ1xcXCIgdHlwZT1cXFwicmFkaW9cXFwiIHZhbHVlPVxcXCJDMVxcXCIgLz5cXG4gICAgICogICAgICA8aW5wdXQgbmFtZT1cXFwiQ1xcXCIgdHlwZT1cXFwicmFkaW9cXFwiIHZhbHVlPVxcXCJDMlxcXCIgLz5cXG4gICAgICogIDwvZmllbGRzZXQ+PC9mb3JtPlxcbiAgICAgKlxcbiAgICAgKiAgdmFyIHYgPSAkKCdpbnB1dFt0eXBlPXRleHRdJykuZmllbGRWYWx1ZSgpO1xcbiAgICAgKiAgLy8gaWYgbm8gdmFsdWVzIGFyZSBlbnRlcmVkIGludG8gdGhlIHRleHQgaW5wdXRzXFxuICAgICAqICB2ID09IFsnJywnJ11cXG4gICAgICogIC8vIGlmIHZhbHVlcyBlbnRlcmVkIGludG8gdGhlIHRleHQgaW5wdXRzIGFyZSAnZm9vJyBhbmQgJ2JhcidcXG4gICAgICogIHYgPT0gWydmb28nLCdiYXInXVxcbiAgICAgKlxcbiAgICAgKiAgdmFyIHYgPSAkKCdpbnB1dFt0eXBlPWNoZWNrYm94XScpLmZpZWxkVmFsdWUoKTtcXG4gICAgICogIC8vIGlmIG5laXRoZXIgY2hlY2tib3ggaXMgY2hlY2tlZFxcbiAgICAgKiAgdiA9PT0gdW5kZWZpbmVkXFxuICAgICAqICAvLyBpZiBib3RoIGNoZWNrYm94ZXMgYXJlIGNoZWNrZWRcXG4gICAgICogIHYgPT0gWydCMScsICdCMiddXFxuICAgICAqXFxuICAgICAqICB2YXIgdiA9ICQoJ2lucHV0W3R5cGU9cmFkaW9dJykuZmllbGRWYWx1ZSgpO1xcbiAgICAgKiAgLy8gaWYgbmVpdGhlciByYWRpbyBpcyBjaGVja2VkXFxuICAgICAqICB2ID09PSB1bmRlZmluZWRcXG4gICAgICogIC8vIGlmIGZpcnN0IHJhZGlvIGlzIGNoZWNrZWRcXG4gICAgICogIHYgPT0gWydDMSddXFxuICAgICAqXFxuICAgICAqIFRoZSBzdWNjZXNzZnVsIGFyZ3VtZW50IGNvbnRyb2xzIHdoZXRoZXIgb3Igbm90IHRoZSBmaWVsZCBlbGVtZW50IG11c3QgYmUgJ3N1Y2Nlc3NmdWwnXFxuICAgICAqIChwZXIgaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDQvaW50ZXJhY3QvZm9ybXMuaHRtbCNzdWNjZXNzZnVsLWNvbnRyb2xzKS5cXG4gICAgICogVGhlIGRlZmF1bHQgdmFsdWUgb2YgdGhlIHN1Y2Nlc3NmdWwgYXJndW1lbnQgaXMgdHJ1ZS4gIElmIHRoaXMgdmFsdWUgaXMgZmFsc2UgdGhlIHZhbHVlKHMpXFxuICAgICAqIGZvciBlYWNoIGVsZW1lbnQgaXMgcmV0dXJuZWQuXFxuICAgICAqXFxuICAgICAqIE5vdGU6IFRoaXMgbWV0aG9kICphbHdheXMqIHJldHVybnMgYW4gYXJyYXkuICBJZiBubyB2YWxpZCB2YWx1ZSBjYW4gYmUgZGV0ZXJtaW5lZCB0aGVcXG4gICAgICogICAgYXJyYXkgd2lsbCBiZSBlbXB0eSwgb3RoZXJ3aXNlIGl0IHdpbGwgY29udGFpbiBvbmUgb3IgbW9yZSB2YWx1ZXMuXFxuICAgICAqL1xcbiAgICAkLmZuLmZpZWxkVmFsdWUgPSBmdW5jdGlvbiAoc3VjY2Vzc2Z1bCkge1xcbiAgICAgICAgZm9yICh2YXIgdmFsID0gW10sIGkgPSAwLCBtYXggPSB0aGlzLmxlbmd0aDsgaSA8IG1heDsgaSsrKSB7XFxuICAgICAgICAgICAgdmFyIGVsID0gdGhpc1tpXTtcXG4gICAgICAgICAgICB2YXIgdiA9ICQuZmllbGRWYWx1ZShlbCwgc3VjY2Vzc2Z1bCk7XFxuICAgICAgICAgICAgaWYgKHYgPT09IG51bGwgfHwgdHlwZW9mIHYgPT0gJ3VuZGVmaW5lZCcgfHwgdi5jb25zdHJ1Y3RvciA9PSBBcnJheSAmJiAhdi5sZW5ndGgpIHtcXG4gICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmICh2LmNvbnN0cnVjdG9yID09IEFycmF5KSB7XFxuICAgICAgICAgICAgICAgICQubWVyZ2UodmFsLCB2KTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICB2YWwucHVzaCh2KTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gdmFsO1xcbiAgICB9O1xcblxcbiAgICAvKipcXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGZpZWxkIGVsZW1lbnQuXFxuICAgICAqL1xcbiAgICAkLmZpZWxkVmFsdWUgPSBmdW5jdGlvbiAoZWwsIHN1Y2Nlc3NmdWwpIHtcXG4gICAgICAgIHZhciBuID0gZWwubmFtZSxcXG4gICAgICAgICAgICB0ID0gZWwudHlwZSxcXG4gICAgICAgICAgICB0YWcgPSBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XFxuICAgICAgICBpZiAoc3VjY2Vzc2Z1bCA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgICAgc3VjY2Vzc2Z1bCA9IHRydWU7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoc3VjY2Vzc2Z1bCAmJiAoIW4gfHwgZWwuZGlzYWJsZWQgfHwgdCA9PSAncmVzZXQnIHx8IHQgPT0gJ2J1dHRvbicgfHwgKHQgPT0gJ2NoZWNrYm94JyB8fCB0ID09ICdyYWRpbycpICYmICFlbC5jaGVja2VkIHx8ICh0ID09ICdzdWJtaXQnIHx8IHQgPT0gJ2ltYWdlJykgJiYgZWwuZm9ybSAmJiBlbC5mb3JtLmNsayAhPSBlbCB8fCB0YWcgPT0gJ3NlbGVjdCcgJiYgZWwuc2VsZWN0ZWRJbmRleCA9PSAtMSkpIHtcXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICh0YWcgPT0gJ3NlbGVjdCcpIHtcXG4gICAgICAgICAgICB2YXIgaW5kZXggPSBlbC5zZWxlY3RlZEluZGV4O1xcbiAgICAgICAgICAgIGlmIChpbmRleCA8IDApIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHZhciBhID0gW10sXFxuICAgICAgICAgICAgICAgIG9wcyA9IGVsLm9wdGlvbnM7XFxuICAgICAgICAgICAgdmFyIG9uZSA9IHQgPT0gJ3NlbGVjdC1vbmUnO1xcbiAgICAgICAgICAgIHZhciBtYXggPSBvbmUgPyBpbmRleCArIDEgOiBvcHMubGVuZ3RoO1xcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBvbmUgPyBpbmRleCA6IDA7IGkgPCBtYXg7IGkrKykge1xcbiAgICAgICAgICAgICAgICB2YXIgb3AgPSBvcHNbaV07XFxuICAgICAgICAgICAgICAgIGlmIChvcC5zZWxlY3RlZCkge1xcbiAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSBvcC52YWx1ZTtcXG4gICAgICAgICAgICAgICAgICAgIGlmICghdikge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV4dHJhIHBhaW4gZm9yIElFLi4uXFxuICAgICAgICAgICAgICAgICAgICAgICAgdiA9IG9wLmF0dHJpYnV0ZXMgJiYgb3AuYXR0cmlidXRlcy52YWx1ZSAmJiAhb3AuYXR0cmlidXRlcy52YWx1ZS5zcGVjaWZpZWQgPyBvcC50ZXh0IDogb3AudmFsdWU7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICBpZiAob25lKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHY7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICBhLnB1c2godik7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgcmV0dXJuIGE7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gJChlbCkudmFsKCk7XFxuICAgIH07XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDbGVhcnMgdGhlIGZvcm0gZGF0YS4gIFRha2VzIHRoZSBmb2xsb3dpbmcgYWN0aW9ucyBvbiB0aGUgZm9ybSdzIGlucHV0IGZpZWxkczpcXG4gICAgICogIC0gaW5wdXQgdGV4dCBmaWVsZHMgd2lsbCBoYXZlIHRoZWlyICd2YWx1ZScgcHJvcGVydHkgc2V0IHRvIHRoZSBlbXB0eSBzdHJpbmdcXG4gICAgICogIC0gc2VsZWN0IGVsZW1lbnRzIHdpbGwgaGF2ZSB0aGVpciAnc2VsZWN0ZWRJbmRleCcgcHJvcGVydHkgc2V0IHRvIC0xXFxuICAgICAqICAtIGNoZWNrYm94IGFuZCByYWRpbyBpbnB1dHMgd2lsbCBoYXZlIHRoZWlyICdjaGVja2VkJyBwcm9wZXJ0eSBzZXQgdG8gZmFsc2VcXG4gICAgICogIC0gaW5wdXRzIG9mIHR5cGUgc3VibWl0LCBidXR0b24sIHJlc2V0LCBhbmQgaGlkZGVuIHdpbGwgKm5vdCogYmUgZWZmZWN0ZWRcXG4gICAgICogIC0gYnV0dG9uIGVsZW1lbnRzIHdpbGwgKm5vdCogYmUgZWZmZWN0ZWRcXG4gICAgICovXFxuICAgICQuZm4uY2xlYXJGb3JtID0gZnVuY3Rpb24gKGluY2x1ZGVIaWRkZW4pIHtcXG4gICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICQoJ2lucHV0LHNlbGVjdCx0ZXh0YXJlYScsIHRoaXMpLmNsZWFyRmllbGRzKGluY2x1ZGVIaWRkZW4pO1xcbiAgICAgICAgfSk7XFxuICAgIH07XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDbGVhcnMgdGhlIHNlbGVjdGVkIGZvcm0gZWxlbWVudHMuXFxuICAgICAqL1xcbiAgICAkLmZuLmNsZWFyRmllbGRzID0gJC5mbi5jbGVhcklucHV0cyA9IGZ1bmN0aW9uIChpbmNsdWRlSGlkZGVuKSB7XFxuICAgICAgICB2YXIgcmUgPSAvXig/OmNvbG9yfGRhdGV8ZGF0ZXRpbWV8ZW1haWx8bW9udGh8bnVtYmVyfHBhc3N3b3JkfHJhbmdlfHNlYXJjaHx0ZWx8dGV4dHx0aW1lfHVybHx3ZWVrKSQvaTsgLy8gJ2hpZGRlbicgaXMgbm90IGluIHRoaXMgbGlzdFxcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgdmFyIHQgPSB0aGlzLnR5cGUsXFxuICAgICAgICAgICAgICAgIHRhZyA9IHRoaXMudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xcbiAgICAgICAgICAgIGlmIChyZS50ZXN0KHQpIHx8IHRhZyA9PSAndGV4dGFyZWEnKSB7XFxuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSAnJztcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHQgPT0gJ2NoZWNrYm94JyB8fCB0ID09ICdyYWRpbycpIHtcXG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja2VkID0gZmFsc2U7XFxuICAgICAgICAgICAgfSBlbHNlIGlmICh0YWcgPT0gJ3NlbGVjdCcpIHtcXG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEluZGV4ID0gLTE7XFxuICAgICAgICAgICAgfSBlbHNlIGlmICh0ID09IFxcXCJmaWxlXFxcIikge1xcbiAgICAgICAgICAgICAgICBpZiAoL01TSUUvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcXG4gICAgICAgICAgICAgICAgICAgICQodGhpcykucmVwbGFjZVdpdGgoJCh0aGlzKS5jbG9uZSh0cnVlKSk7XFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLnZhbCgnJyk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGluY2x1ZGVIaWRkZW4pIHtcXG4gICAgICAgICAgICAgICAgLy8gaW5jbHVkZUhpZGRlbiBjYW4gYmUgdGhlIHZhbHVlIHRydWUsIG9yIGl0IGNhbiBiZSBhIHNlbGVjdG9yIHN0cmluZ1xcbiAgICAgICAgICAgICAgICAvLyBpbmRpY2F0aW5nIGEgc3BlY2lhbCB0ZXN0OyBmb3IgZXhhbXBsZTpcXG4gICAgICAgICAgICAgICAgLy8gICQoJyNteUZvcm0nKS5jbGVhckZvcm0oJy5zcGVjaWFsOmhpZGRlbicpXFxuICAgICAgICAgICAgICAgIC8vIHRoZSBhYm92ZSB3b3VsZCBjbGVhbiBoaWRkZW4gaW5wdXRzIHRoYXQgaGF2ZSB0aGUgY2xhc3Mgb2YgJ3NwZWNpYWwnXFxuICAgICAgICAgICAgICAgIGlmIChpbmNsdWRlSGlkZGVuID09PSB0cnVlICYmIC9oaWRkZW4vLnRlc3QodCkgfHwgdHlwZW9mIGluY2x1ZGVIaWRkZW4gPT0gJ3N0cmluZycgJiYgJCh0aGlzKS5pcyhpbmNsdWRlSGlkZGVuKSkge1xcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9ICcnO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgIH07XFxuXFxuICAgIC8qKlxcbiAgICAgKiBSZXNldHMgdGhlIGZvcm0gZGF0YS4gIENhdXNlcyBhbGwgZm9ybSBlbGVtZW50cyB0byBiZSByZXNldCB0byB0aGVpciBvcmlnaW5hbCB2YWx1ZS5cXG4gICAgICovXFxuICAgICQuZm4ucmVzZXRGb3JtID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgLy8gZ3VhcmQgYWdhaW5zdCBhbiBpbnB1dCB3aXRoIHRoZSBuYW1lIG9mICdyZXNldCdcXG4gICAgICAgICAgICAvLyBub3RlIHRoYXQgSUUgcmVwb3J0cyB0aGUgcmVzZXQgZnVuY3Rpb24gYXMgYW4gJ29iamVjdCdcXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMucmVzZXQgPT0gJ2Z1bmN0aW9uJyB8fCBfdHlwZW9mKHRoaXMucmVzZXQpID09ICdvYmplY3QnICYmICF0aGlzLnJlc2V0Lm5vZGVUeXBlKSB7XFxuICAgICAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgfTtcXG5cXG4gICAgLyoqXFxuICAgICAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgYW55IG1hdGNoaW5nIGVsZW1lbnRzLlxcbiAgICAgKi9cXG4gICAgJC5mbi5lbmFibGUgPSBmdW5jdGlvbiAoYikge1xcbiAgICAgICAgaWYgKGIgPT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgICAgIGIgPSB0cnVlO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgdGhpcy5kaXNhYmxlZCA9ICFiO1xcbiAgICAgICAgfSk7XFxuICAgIH07XFxuXFxuICAgIC8qKlxcbiAgICAgKiBDaGVja3MvdW5jaGVja3MgYW55IG1hdGNoaW5nIGNoZWNrYm94ZXMgb3IgcmFkaW8gYnV0dG9ucyBhbmRcXG4gICAgICogc2VsZWN0cy9kZXNlbGVjdHMgYW5kIG1hdGNoaW5nIG9wdGlvbiBlbGVtZW50cy5cXG4gICAgICovXFxuICAgICQuZm4uc2VsZWN0ZWQgPSBmdW5jdGlvbiAoc2VsZWN0KSB7XFxuICAgICAgICBpZiAoc2VsZWN0ID09PSB1bmRlZmluZWQpIHtcXG4gICAgICAgICAgICBzZWxlY3QgPSB0cnVlO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgdmFyIHQgPSB0aGlzLnR5cGU7XFxuICAgICAgICAgICAgaWYgKHQgPT0gJ2NoZWNrYm94JyB8fCB0ID09ICdyYWRpbycpIHtcXG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja2VkID0gc2VsZWN0O1xcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT0gJ29wdGlvbicpIHtcXG4gICAgICAgICAgICAgICAgdmFyICRzZWwgPSAkKHRoaXMpLnBhcmVudCgnc2VsZWN0Jyk7XFxuICAgICAgICAgICAgICAgIGlmIChzZWxlY3QgJiYgJHNlbFswXSAmJiAkc2VsWzBdLnR5cGUgPT0gJ3NlbGVjdC1vbmUnKSB7XFxuICAgICAgICAgICAgICAgICAgICAvLyBkZXNlbGVjdCBhbGwgb3RoZXIgb3B0aW9uc1xcbiAgICAgICAgICAgICAgICAgICAgJHNlbC5maW5kKCdvcHRpb24nKS5zZWxlY3RlZChmYWxzZSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZCA9IHNlbGVjdDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgfTtcXG5cXG4gICAgLy8gZXhwb3NlIGRlYnVnIHZhclxcbiAgICAkLmZuLmFqYXhTdWJtaXQuZGVidWcgPSBmYWxzZTtcXG5cXG4gICAgLy8gaGVscGVyIGZuIGZvciBjb25zb2xlIGxvZ2dpbmdcXG4gICAgZnVuY3Rpb24gbG9nKCkge1xcbiAgICAgICAgaWYgKCEkLmZuLmFqYXhTdWJtaXQuZGVidWcpIHtcXG4gICAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuICAgICAgICB2YXIgbXNnID0gJ1tqcXVlcnkuZm9ybV0gJyArIEFycmF5LnByb3RvdHlwZS5qb2luLmNhbGwoYXJndW1lbnRzLCAnJyk7XFxuICAgICAgICBpZiAod2luZG93LmNvbnNvbGUgJiYgd2luZG93LmNvbnNvbGUubG9nKSB7XFxuICAgICAgICAgICAgd2luZG93LmNvbnNvbGUubG9nKG1zZyk7XFxuICAgICAgICB9IGVsc2UgaWYgKHdpbmRvdy5vcGVyYSAmJiB3aW5kb3cub3BlcmEucG9zdEVycm9yKSB7XFxuICAgICAgICAgICAgd2luZG93Lm9wZXJhLnBvc3RFcnJvcihtc2cpO1xcbiAgICAgICAgfVxcbiAgICB9XFxufSk7XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yYXctbG9hZGVyIS4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWI/P3JlZi0tMC0wIS4vYXNzZXRzL2pzL2pxdWVyeS5mb3JtLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9yYXctbG9hZGVyL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMC0wIS4vYXNzZXRzL2pzL2pxdWVyeS5mb3JtLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwibW9kdWxlLmV4cG9ydHMgPSBcInZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcXFwic3ltYm9sXFxcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcXFwic3ltYm9sXFxcIiA6IHR5cGVvZiBvYmo7IH07XFxuXFxuLypcXG4gKiBxVGlwMiAtIFByZXR0eSBwb3dlcmZ1bCB0b29sdGlwcyAtIHYyLjIuMS0yOS1cXG4gKiBodHRwOi8vcXRpcDIuY29tXFxuICpcXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgXFxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlc1xcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcXG4gKlxcbiAqIERhdGU6IFR1ZSBEZWMgOCAyMDE1IDA1OjUwIEVTVC0wNTAwXFxuICogUGx1Z2luczogdGlwcyBtb2RhbCB2aWV3cG9ydCBzdmcgaW1hZ2VtYXAgaWU2XFxuICogU3R5bGVzOiBjb3JlIGJhc2ljIGNzczNcXG4gKi9cXG4vKmdsb2JhbCB3aW5kb3c6IGZhbHNlLCBqUXVlcnk6IGZhbHNlLCBjb25zb2xlOiBmYWxzZSwgZGVmaW5lOiBmYWxzZSAqL1xcblxcbi8qIENhY2hlIHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCAqL1xcbihmdW5jdGlvbiAod2luZG93LCBkb2N1bWVudCwgdW5kZWZpbmVkKSB7XFxuXFxuXFx0Ly8gVXNlcyBBTUQgb3IgYnJvd3NlciBnbG9iYWxzIHRvIGNyZWF0ZSBhIGpRdWVyeSBwbHVnaW4uXFxuXFx0KGZ1bmN0aW9uIChmYWN0b3J5KSB7XFxuXFx0XFx0XFxcInVzZSBzdHJpY3RcXFwiO1xcblxcblxcdFxcdGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcXG5cXHRcXHRcXHRkZWZpbmUoWydqcXVlcnknXSwgZmFjdG9yeSk7XFxuXFx0XFx0fSBlbHNlIGlmIChqUXVlcnkgJiYgIWpRdWVyeS5mbi5xdGlwKSB7XFxuXFx0XFx0XFx0ZmFjdG9yeShqUXVlcnkpO1xcblxcdFxcdH1cXG5cXHR9KShmdW5jdGlvbiAoJCkge1xcblxcdFxcdFxcXCJ1c2Ugc3RyaWN0XFxcIjsgLy8gRW5hYmxlIEVDTUFTY3JpcHQgXFxcInN0cmljdFxcXCIgb3BlcmF0aW9uIGZvciB0aGlzIGZ1bmN0aW9uLiBTZWUgbW9yZTogaHR0cDovL2Vqb2huLm9yZy9ibG9nL2VjbWFzY3JpcHQtNS1zdHJpY3QtbW9kZS1qc29uLWFuZC1tb3JlL1xcblxcblxcdFxcdDsgLy8gTXVuZ2UgdGhlIHByaW1pdGl2ZXMgLSBQYXVsIElyaXNoIHRpcFxcblxcdFxcdHZhciBUUlVFID0gdHJ1ZSxcXG5cXHRcXHQgICAgRkFMU0UgPSBmYWxzZSxcXG5cXHRcXHQgICAgTlVMTCA9IG51bGwsXFxuXFxuXFxuXFx0XFx0Ly8gQ29tbW9uIHZhcmlhYmxlc1xcblxcdFxcdFggPSAneCcsXFxuXFx0XFx0ICAgIFkgPSAneScsXFxuXFx0XFx0ICAgIFdJRFRIID0gJ3dpZHRoJyxcXG5cXHRcXHQgICAgSEVJR0hUID0gJ2hlaWdodCcsXFxuXFxuXFxuXFx0XFx0Ly8gUG9zaXRpb25pbmcgc2lkZXNcXG5cXHRcXHRUT1AgPSAndG9wJyxcXG5cXHRcXHQgICAgTEVGVCA9ICdsZWZ0JyxcXG5cXHRcXHQgICAgQk9UVE9NID0gJ2JvdHRvbScsXFxuXFx0XFx0ICAgIFJJR0hUID0gJ3JpZ2h0JyxcXG5cXHRcXHQgICAgQ0VOVEVSID0gJ2NlbnRlcicsXFxuXFxuXFxuXFx0XFx0Ly8gUG9zaXRpb24gYWRqdXN0bWVudCB0eXBlc1xcblxcdFxcdEZMSVAgPSAnZmxpcCcsXFxuXFx0XFx0ICAgIEZMSVBJTlZFUlQgPSAnZmxpcGludmVydCcsXFxuXFx0XFx0ICAgIFNISUZUID0gJ3NoaWZ0JyxcXG5cXG5cXG5cXHRcXHQvLyBTaG9ydGN1dCB2YXJzXFxuXFx0XFx0UVRJUCxcXG5cXHRcXHQgICAgUFJPVE9UWVBFLFxcblxcdFxcdCAgICBDT1JORVIsXFxuXFx0XFx0ICAgIENIRUNLUyxcXG5cXHRcXHQgICAgUExVR0lOUyA9IHt9LFxcblxcdFxcdCAgICBOQU1FU1BBQ0UgPSAncXRpcCcsXFxuXFx0XFx0ICAgIEFUVFJfSEFTID0gJ2RhdGEtaGFzcXRpcCcsXFxuXFx0XFx0ICAgIEFUVFJfSUQgPSAnZGF0YS1xdGlwLWlkJyxcXG5cXHRcXHQgICAgV0lER0VUID0gWyd1aS13aWRnZXQnLCAndWktdG9vbHRpcCddLFxcblxcdFxcdCAgICBTRUxFQ1RPUiA9ICcuJyArIE5BTUVTUEFDRSxcXG5cXHRcXHQgICAgSU5BQ1RJVkVfRVZFTlRTID0gJ2NsaWNrIGRibGNsaWNrIG1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZWxlYXZlIG1vdXNlZW50ZXInLnNwbGl0KCcgJyksXFxuXFx0XFx0ICAgIENMQVNTX0ZJWEVEID0gTkFNRVNQQUNFICsgJy1maXhlZCcsXFxuXFx0XFx0ICAgIENMQVNTX0RFRkFVTFQgPSBOQU1FU1BBQ0UgKyAnLWRlZmF1bHQnLFxcblxcdFxcdCAgICBDTEFTU19GT0NVUyA9IE5BTUVTUEFDRSArICctZm9jdXMnLFxcblxcdFxcdCAgICBDTEFTU19IT1ZFUiA9IE5BTUVTUEFDRSArICctaG92ZXInLFxcblxcdFxcdCAgICBDTEFTU19ESVNBQkxFRCA9IE5BTUVTUEFDRSArICctZGlzYWJsZWQnLFxcblxcdFxcdCAgICByZXBsYWNlU3VmZml4ID0gJ19yZXBsYWNlZEJ5cVRpcCcsXFxuXFx0XFx0ICAgIG9sZHRpdGxlID0gJ29sZHRpdGxlJyxcXG5cXHRcXHQgICAgdHJhY2tpbmdCb3VuZCxcXG5cXG5cXG5cXHRcXHQvLyBCcm93c2VyIGRldGVjdGlvblxcblxcdFxcdEJST1dTRVIgPSB7XFxuXFx0XFx0XFx0LypcXG4gICAgKiBJRSB2ZXJzaW9uIGRldGVjdGlvblxcbiAgICAqXFxuICAgICogQWRhcHRlZCBmcm9tOiBodHRwOi8vYWpheGlhbi5jb20vYXJjaGl2ZXMvYXR0YWNrLW9mLXRoZS1pZS1jb25kaXRpb25hbC1jb21tZW50XFxuICAgICogQ3JlZGl0IHRvIEphbWVzIFBhZG9sc2V5IGZvciB0aGUgb3JpZ2luYWwgaW1wbGVtbnRhdGlvbiFcXG4gICAgKi9cXG5cXHRcXHRcXHRpZTogZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdGZvciAodmFyIHYgPSA0LCBpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwiZGl2XFxcIik7IChpLmlubmVySFRNTCA9IFxcXCI8IS0tW2lmIGd0IElFIFxcXCIgKyB2ICsgXFxcIl0+PGk+PC9pPjwhW2VuZGlmXS0tPlxcXCIpICYmIGkuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXFxcImlcXFwiKVswXTsgdiArPSAxKSB7fVxcblxcdFxcdFxcdFxcdHJldHVybiB2ID4gNCA/IHYgOiBOYU47XFxuXFx0XFx0XFx0fSgpLFxcblxcblxcdFxcdFxcdC8qXFxuICAgICogaU9TIHZlcnNpb24gZGV0ZWN0aW9uXFxuICAgICovXFxuXFx0XFx0XFx0aU9TOiBwYXJzZUZsb2F0KCgnJyArICgvQ1BVLipPUyAoWzAtOV9dezEsNX0pfChDUFUgbGlrZSkuKkFwcGxlV2ViS2l0LipNb2JpbGUvaS5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpIHx8IFswLCAnJ10pWzFdKS5yZXBsYWNlKCd1bmRlZmluZWQnLCAnM18yJykucmVwbGFjZSgnXycsICcuJykucmVwbGFjZSgnXycsICcnKSkgfHwgRkFMU0VcXG5cXHRcXHR9O1xcblxcdFxcdDtmdW5jdGlvbiBRVGlwKHRhcmdldCwgb3B0aW9ucywgaWQsIGF0dHIpIHtcXG5cXHRcXHRcXHQvLyBFbGVtZW50cyBhbmQgSURcXG5cXHRcXHRcXHR0aGlzLmlkID0gaWQ7XFxuXFx0XFx0XFx0dGhpcy50YXJnZXQgPSB0YXJnZXQ7XFxuXFx0XFx0XFx0dGhpcy50b29sdGlwID0gTlVMTDtcXG5cXHRcXHRcXHR0aGlzLmVsZW1lbnRzID0geyB0YXJnZXQ6IHRhcmdldCB9O1xcblxcblxcdFxcdFxcdC8vIEludGVybmFsIGNvbnN0cnVjdHNcXG5cXHRcXHRcXHR0aGlzLl9pZCA9IE5BTUVTUEFDRSArICctJyArIGlkO1xcblxcdFxcdFxcdHRoaXMudGltZXJzID0geyBpbWc6IHt9IH07XFxuXFx0XFx0XFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcXG5cXHRcXHRcXHR0aGlzLnBsdWdpbnMgPSB7fTtcXG5cXG5cXHRcXHRcXHQvLyBDYWNoZSBvYmplY3RcXG5cXHRcXHRcXHR0aGlzLmNhY2hlID0ge1xcblxcdFxcdFxcdFxcdGV2ZW50OiB7fSxcXG5cXHRcXHRcXHRcXHR0YXJnZXQ6ICQoKSxcXG5cXHRcXHRcXHRcXHRkaXNhYmxlZDogRkFMU0UsXFxuXFx0XFx0XFx0XFx0YXR0cjogYXR0cixcXG5cXHRcXHRcXHRcXHRvblRvb2x0aXA6IEZBTFNFLFxcblxcdFxcdFxcdFxcdGxhc3RDbGFzczogJydcXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdFxcdC8vIFNldCB0aGUgaW5pdGlhbCBmbGFnc1xcblxcdFxcdFxcdHRoaXMucmVuZGVyZWQgPSB0aGlzLmRlc3Ryb3llZCA9IHRoaXMuZGlzYWJsZWQgPSB0aGlzLndhaXRpbmcgPSB0aGlzLmhpZGRlbkR1cmluZ1dhaXQgPSB0aGlzLnBvc2l0aW9uaW5nID0gdGhpcy50cmlnZ2VyaW5nID0gRkFMU0U7XFxuXFx0XFx0fVxcblxcdFxcdFBST1RPVFlQRSA9IFFUaXAucHJvdG90eXBlO1xcblxcblxcdFxcdFBST1RPVFlQRS5fd2hlbiA9IGZ1bmN0aW9uIChkZWZlcnJlZHMpIHtcXG5cXHRcXHRcXHRyZXR1cm4gJC53aGVuLmFwcGx5KCQsIGRlZmVycmVkcyk7XFxuXFx0XFx0fTtcXG5cXG5cXHRcXHRQUk9UT1RZUEUucmVuZGVyID0gZnVuY3Rpb24gKHNob3cpIHtcXG5cXHRcXHRcXHRpZiAodGhpcy5yZW5kZXJlZCB8fCB0aGlzLmRlc3Ryb3llZCkge1xcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcdFxcdFxcdH0gLy8gSWYgdG9vbHRpcCBoYXMgYWxyZWFkeSBiZWVuIHJlbmRlcmVkLCBleGl0XFxuXFxuXFx0XFx0XFx0dmFyIHNlbGYgPSB0aGlzLFxcblxcdFxcdFxcdCAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxcblxcdFxcdFxcdCAgICBjYWNoZSA9IHRoaXMuY2FjaGUsXFxuXFx0XFx0XFx0ICAgIGVsZW1lbnRzID0gdGhpcy5lbGVtZW50cyxcXG5cXHRcXHRcXHQgICAgdGV4dCA9IG9wdGlvbnMuY29udGVudC50ZXh0LFxcblxcdFxcdFxcdCAgICB0aXRsZSA9IG9wdGlvbnMuY29udGVudC50aXRsZSxcXG5cXHRcXHRcXHQgICAgYnV0dG9uID0gb3B0aW9ucy5jb250ZW50LmJ1dHRvbixcXG5cXHRcXHRcXHQgICAgcG9zT3B0aW9ucyA9IG9wdGlvbnMucG9zaXRpb24sXFxuXFx0XFx0XFx0ICAgIG5hbWVzcGFjZSA9ICcuJyArIHRoaXMuX2lkICsgJyAnLFxcblxcdFxcdFxcdCAgICBkZWZlcnJlZHMgPSBbXSxcXG5cXHRcXHRcXHQgICAgdG9vbHRpcDtcXG5cXG5cXHRcXHRcXHQvLyBBZGQgQVJJQSBhdHRyaWJ1dGVzIHRvIHRhcmdldFxcblxcdFxcdFxcdCQuYXR0cih0aGlzLnRhcmdldFswXSwgJ2FyaWEtZGVzY3JpYmVkYnknLCB0aGlzLl9pZCk7XFxuXFxuXFx0XFx0XFx0Ly8gQ3JlYXRlIHB1YmxpYyBwb3NpdGlvbiBvYmplY3QgdGhhdCB0cmFja3MgY3VycmVudCBwb3NpdGlvbiBjb3JuZXJzXFxuXFx0XFx0XFx0Y2FjaGUucG9zQ2xhc3MgPSB0aGlzLl9jcmVhdGVQb3NDbGFzcygodGhpcy5wb3NpdGlvbiA9IHsgbXk6IHBvc09wdGlvbnMubXksIGF0OiBwb3NPcHRpb25zLmF0IH0pLm15KTtcXG5cXG5cXHRcXHRcXHQvLyBDcmVhdGUgdG9vbHRpcCBlbGVtZW50XFxuXFx0XFx0XFx0dGhpcy50b29sdGlwID0gZWxlbWVudHMudG9vbHRpcCA9IHRvb2x0aXAgPSAkKCc8ZGl2Lz4nLCB7XFxuXFx0XFx0XFx0XFx0J2lkJzogdGhpcy5faWQsXFxuXFx0XFx0XFx0XFx0J2NsYXNzJzogW05BTUVTUEFDRSwgQ0xBU1NfREVGQVVMVCwgb3B0aW9ucy5zdHlsZS5jbGFzc2VzLCBjYWNoZS5wb3NDbGFzc10uam9pbignICcpLFxcblxcdFxcdFxcdFxcdCd3aWR0aCc6IG9wdGlvbnMuc3R5bGUud2lkdGggfHwgJycsXFxuXFx0XFx0XFx0XFx0J2hlaWdodCc6IG9wdGlvbnMuc3R5bGUuaGVpZ2h0IHx8ICcnLFxcblxcdFxcdFxcdFxcdCd0cmFja2luZyc6IHBvc09wdGlvbnMudGFyZ2V0ID09PSAnbW91c2UnICYmIHBvc09wdGlvbnMuYWRqdXN0Lm1vdXNlLFxcblxcblxcdFxcdFxcdFxcdC8qIEFSSUEgc3BlY2lmaWMgYXR0cmlidXRlcyAqL1xcblxcdFxcdFxcdFxcdCdyb2xlJzogJ2FsZXJ0JyxcXG5cXHRcXHRcXHRcXHQnYXJpYS1saXZlJzogJ3BvbGl0ZScsXFxuXFx0XFx0XFx0XFx0J2FyaWEtYXRvbWljJzogRkFMU0UsXFxuXFx0XFx0XFx0XFx0J2FyaWEtZGVzY3JpYmVkYnknOiB0aGlzLl9pZCArICctY29udGVudCcsXFxuXFx0XFx0XFx0XFx0J2FyaWEtaGlkZGVuJzogVFJVRVxcblxcdFxcdFxcdH0pLnRvZ2dsZUNsYXNzKENMQVNTX0RJU0FCTEVELCB0aGlzLmRpc2FibGVkKS5hdHRyKEFUVFJfSUQsIHRoaXMuaWQpLmRhdGEoTkFNRVNQQUNFLCB0aGlzKS5hcHBlbmRUbyhwb3NPcHRpb25zLmNvbnRhaW5lcikuYXBwZW5kKFxcblxcdFxcdFxcdC8vIENyZWF0ZSBjb250ZW50IGVsZW1lbnRcXG5cXHRcXHRcXHRlbGVtZW50cy5jb250ZW50ID0gJCgnPGRpdiAvPicsIHtcXG5cXHRcXHRcXHRcXHQnY2xhc3MnOiBOQU1FU1BBQ0UgKyAnLWNvbnRlbnQnLFxcblxcdFxcdFxcdFxcdCdpZCc6IHRoaXMuX2lkICsgJy1jb250ZW50JyxcXG5cXHRcXHRcXHRcXHQnYXJpYS1hdG9taWMnOiBUUlVFXFxuXFx0XFx0XFx0fSkpO1xcblxcblxcdFxcdFxcdC8vIFNldCByZW5kZXJlZCBmbGFnIGFuZCBwcmV2ZW50IHJlZHVuZGFudCByZXBvc2l0aW9uIGNhbGxzIGZvciBub3dcXG5cXHRcXHRcXHR0aGlzLnJlbmRlcmVkID0gLTE7XFxuXFx0XFx0XFx0dGhpcy5wb3NpdGlvbmluZyA9IFRSVUU7XFxuXFxuXFx0XFx0XFx0Ly8gQ3JlYXRlIHRpdGxlLi4uXFxuXFx0XFx0XFx0aWYgKHRpdGxlKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5fY3JlYXRlVGl0bGUoKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBVcGRhdGUgdGl0bGUgb25seSBpZiBpdHMgbm90IGEgY2FsbGJhY2sgKGNhbGxlZCBpbiB0b2dnbGUgaWYgc28pXFxuXFx0XFx0XFx0XFx0aWYgKCEkLmlzRnVuY3Rpb24odGl0bGUpKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZGVmZXJyZWRzLnB1c2godGhpcy5fdXBkYXRlVGl0bGUodGl0bGUsIEZBTFNFKSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBDcmVhdGUgYnV0dG9uXFxuXFx0XFx0XFx0aWYgKGJ1dHRvbikge1xcblxcdFxcdFxcdFxcdHRoaXMuX2NyZWF0ZUJ1dHRvbigpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBTZXQgcHJvcGVyIHJlbmRlcmVkIGZsYWcgYW5kIHVwZGF0ZSBjb250ZW50IGlmIG5vdCBhIGNhbGxiYWNrIGZ1bmN0aW9uIChjYWxsZWQgaW4gdG9nZ2xlKVxcblxcdFxcdFxcdGlmICghJC5pc0Z1bmN0aW9uKHRleHQpKSB7XFxuXFx0XFx0XFx0XFx0ZGVmZXJyZWRzLnB1c2godGhpcy5fdXBkYXRlQ29udGVudCh0ZXh0LCBGQUxTRSkpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR0aGlzLnJlbmRlcmVkID0gVFJVRTtcXG5cXG5cXHRcXHRcXHQvLyBTZXR1cCB3aWRnZXQgY2xhc3Nlc1xcblxcdFxcdFxcdHRoaXMuX3NldFdpZGdldCgpO1xcblxcblxcdFxcdFxcdC8vIEluaXRpYWxpemUgJ3JlbmRlcicgcGx1Z2luc1xcblxcdFxcdFxcdCQuZWFjaChQTFVHSU5TLCBmdW5jdGlvbiAobmFtZSkge1xcblxcdFxcdFxcdFxcdHZhciBpbnN0YW5jZTtcXG5cXHRcXHRcXHRcXHRpZiAodGhpcy5pbml0aWFsaXplID09PSAncmVuZGVyJyAmJiAoaW5zdGFuY2UgPSB0aGlzKHNlbGYpKSkge1xcblxcdFxcdFxcdFxcdFxcdHNlbGYucGx1Z2luc1tuYW1lXSA9IGluc3RhbmNlO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9KTtcXG5cXG5cXHRcXHRcXHQvLyBVbmFzc2lnbiBpbml0aWFsIGV2ZW50cyBhbmQgYXNzaWduIHByb3BlciBldmVudHNcXG5cXHRcXHRcXHR0aGlzLl91bmFzc2lnbkV2ZW50cygpO1xcblxcdFxcdFxcdHRoaXMuX2Fzc2lnbkV2ZW50cygpO1xcblxcblxcdFxcdFxcdC8vIFdoZW4gZGVmZXJyZWRzIGhhdmUgY29tcGxldGVkXFxuXFx0XFx0XFx0dGhpcy5fd2hlbihkZWZlcnJlZHMpLnRoZW4oZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdC8vIHRvb2x0aXByZW5kZXIgZXZlbnRcXG5cXHRcXHRcXHRcXHRzZWxmLl90cmlnZ2VyKCdyZW5kZXInKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBSZXNldCBmbGFnc1xcblxcdFxcdFxcdFxcdHNlbGYucG9zaXRpb25pbmcgPSBGQUxTRTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBTaG93IHRvb2x0aXAgaWYgbm90IGhpZGRlbiBkdXJpbmcgd2FpdCBwZXJpb2RcXG5cXHRcXHRcXHRcXHRpZiAoIXNlbGYuaGlkZGVuRHVyaW5nV2FpdCAmJiAob3B0aW9ucy5zaG93LnJlYWR5IHx8IHNob3cpKSB7XFxuXFx0XFx0XFx0XFx0XFx0c2VsZi50b2dnbGUoVFJVRSwgY2FjaGUuZXZlbnQsIEZBTFNFKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0c2VsZi5oaWRkZW5EdXJpbmdXYWl0ID0gRkFMU0U7XFxuXFx0XFx0XFx0fSk7XFxuXFxuXFx0XFx0XFx0Ly8gRXhwb3NlIEFQSVxcblxcdFxcdFxcdFFUSVAuYXBpW3RoaXMuaWRdID0gdGhpcztcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXHRcXHR9O1xcblxcblxcdFxcdFBST1RPVFlQRS5kZXN0cm95ID0gZnVuY3Rpb24gKGltbWVkaWF0ZSkge1xcblxcdFxcdFxcdC8vIFNldCBmbGFnIHRoZSBzaWduaWZ5IGRlc3Ryb3kgaXMgdGFraW5nIHBsYWNlIHRvIHBsdWdpbnNcXG5cXHRcXHRcXHQvLyBhbmQgZW5zdXJlIGl0IG9ubHkgZ2V0cyBkZXN0cm95ZWQgb25jZSFcXG5cXHRcXHRcXHRpZiAodGhpcy5kZXN0cm95ZWQpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy50YXJnZXQ7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGZ1bmN0aW9uIHByb2Nlc3MoKSB7XFxuXFx0XFx0XFx0XFx0aWYgKHRoaXMuZGVzdHJveWVkKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR0aGlzLmRlc3Ryb3llZCA9IFRSVUU7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHRhcmdldCA9IHRoaXMudGFyZ2V0LFxcblxcdFxcdFxcdFxcdCAgICB0aXRsZSA9IHRhcmdldC5hdHRyKG9sZHRpdGxlKSxcXG5cXHRcXHRcXHRcXHQgICAgdGltZXI7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gRGVzdHJveSB0b29sdGlwIGlmIHJlbmRlcmVkXFxuXFx0XFx0XFx0XFx0aWYgKHRoaXMucmVuZGVyZWQpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnRvb2x0aXAuc3RvcCgxLCAwKS5maW5kKCcqJykucmVtb3ZlKCkuZW5kKCkucmVtb3ZlKCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIERlc3Ryb3kgYWxsIHBsdWdpbnNcXG5cXHRcXHRcXHRcXHQkLmVhY2godGhpcy5wbHVnaW5zLCBmdW5jdGlvbiAobmFtZSkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuZGVzdHJveSAmJiB0aGlzLmRlc3Ryb3koKTtcXG5cXHRcXHRcXHRcXHR9KTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBDbGVhciB0aW1lcnNcXG5cXHRcXHRcXHRcXHRmb3IgKHRpbWVyIGluIHRoaXMudGltZXJzKSB7XFxuXFx0XFx0XFx0XFx0XFx0Y2xlYXJUaW1lb3V0KHRoaXMudGltZXJzW3RpbWVyXSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIFJlbW92ZSBhcGkgb2JqZWN0IGFuZCBBUklBIGF0dHJpYnV0ZXNcXG5cXHRcXHRcXHRcXHR0YXJnZXQucmVtb3ZlRGF0YShOQU1FU1BBQ0UpLnJlbW92ZUF0dHIoQVRUUl9JRCkucmVtb3ZlQXR0cihBVFRSX0hBUykucmVtb3ZlQXR0cignYXJpYS1kZXNjcmliZWRieScpO1xcblxcblxcdFxcdFxcdFxcdC8vIFJlc2V0IG9sZCB0aXRsZSBhdHRyaWJ1dGUgaWYgcmVtb3ZlZFxcblxcdFxcdFxcdFxcdGlmICh0aGlzLm9wdGlvbnMuc3VwcHJlc3MgJiYgdGl0bGUpIHtcXG5cXHRcXHRcXHRcXHRcXHR0YXJnZXQuYXR0cigndGl0bGUnLCB0aXRsZSkucmVtb3ZlQXR0cihvbGR0aXRsZSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIFJlbW92ZSBxVGlwIGV2ZW50cyBhc3NvY2lhdGVkIHdpdGggdGhpcyBBUElcXG5cXHRcXHRcXHRcXHR0aGlzLl91bmFzc2lnbkV2ZW50cygpO1xcblxcblxcdFxcdFxcdFxcdC8vIFJlbW92ZSBJRCBmcm9tIHVzZWQgaWQgb2JqZWN0cywgYW5kIGRlbGV0ZSBvYmplY3QgcmVmZXJlbmNlc1xcblxcdFxcdFxcdFxcdC8vIGZvciBiZXR0ZXIgZ2FyYmFnZSBjb2xsZWN0aW9uIGFuZCBsZWFrIHByb3RlY3Rpb25cXG5cXHRcXHRcXHRcXHR0aGlzLm9wdGlvbnMgPSB0aGlzLmVsZW1lbnRzID0gdGhpcy5jYWNoZSA9IHRoaXMudGltZXJzID0gdGhpcy5wbHVnaW5zID0gdGhpcy5tb3VzZSA9IE5VTEw7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gRGVsZXRlIGVwb3hzZWQgQVBJIG9iamVjdFxcblxcdFxcdFxcdFxcdGRlbGV0ZSBRVElQLmFwaVt0aGlzLmlkXTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gSWYgYW4gaW1tZWRpYXRlIGRlc3Ryb3kgaXMgbmVlZGVkXFxuXFx0XFx0XFx0aWYgKChpbW1lZGlhdGUgIT09IFRSVUUgfHwgdGhpcy50cmlnZ2VyaW5nID09PSAnaGlkZScpICYmIHRoaXMucmVuZGVyZWQpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLnRvb2x0aXAub25lKCd0b29sdGlwaGlkZGVuJywgJC5wcm94eShwcm9jZXNzLCB0aGlzKSk7XFxuXFx0XFx0XFx0XFx0IXRoaXMudHJpZ2dlcmluZyAmJiB0aGlzLmhpZGUoKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gSWYgd2UncmUgbm90IGluIHRoZSBwcm9jZXNzIG9mIGhpZGluZy4uLiBwcm9jZXNzXFxuXFx0XFx0XFx0ZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0cHJvY2Vzcy5jYWxsKHRoaXMpO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy50YXJnZXQ7XFxuXFx0XFx0fTtcXG5cXHRcXHQ7ZnVuY3Rpb24gaW52YWxpZE9wdChhKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGEgPT09IE5VTEwgfHwgJC50eXBlKGEpICE9PSAnb2JqZWN0JztcXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gaW52YWxpZENvbnRlbnQoYykge1xcblxcdFxcdFxcdHJldHVybiAhKCQuaXNGdW5jdGlvbihjKSB8fCBjICYmIGMuYXR0ciB8fCBjLmxlbmd0aCB8fCAkLnR5cGUoYykgPT09ICdvYmplY3QnICYmIChjLmpxdWVyeSB8fCBjLnRoZW4pKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gT3B0aW9uIG9iamVjdCBzYW5pdGl6ZXJcXG5cXHRcXHRmdW5jdGlvbiBzYW5pdGl6ZU9wdGlvbnMob3B0cykge1xcblxcdFxcdFxcdHZhciBjb250ZW50LCB0ZXh0LCBhamF4LCBvbmNlO1xcblxcblxcdFxcdFxcdGlmIChpbnZhbGlkT3B0KG9wdHMpKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIEZBTFNFO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoaW52YWxpZE9wdChvcHRzLm1ldGFkYXRhKSkge1xcblxcdFxcdFxcdFxcdG9wdHMubWV0YWRhdGEgPSB7IHR5cGU6IG9wdHMubWV0YWRhdGEgfTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCdjb250ZW50JyBpbiBvcHRzKSB7XFxuXFx0XFx0XFx0XFx0Y29udGVudCA9IG9wdHMuY29udGVudDtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoaW52YWxpZE9wdChjb250ZW50KSB8fCBjb250ZW50LmpxdWVyeSB8fCBjb250ZW50LmRvbmUpIHtcXG5cXHRcXHRcXHRcXHRcXHRjb250ZW50ID0gb3B0cy5jb250ZW50ID0ge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRleHQ6IHRleHQgPSBpbnZhbGlkQ29udGVudChjb250ZW50KSA/IEZBTFNFIDogY29udGVudFxcblxcdFxcdFxcdFxcdFxcdH07XFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHR0ZXh0ID0gY29udGVudC50ZXh0O1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBERVBSRUNBVEVEIC0gT2xkIGNvbnRlbnQuYWpheCBwbHVnaW4gZnVuY3Rpb25hbGl0eVxcblxcdFxcdFxcdFxcdC8vIENvbnZlcnRzIGl0IGludG8gdGhlIHByb3BlciBEZWZlcnJlZCBzeW50YXhcXG5cXHRcXHRcXHRcXHRpZiAoJ2FqYXgnIGluIGNvbnRlbnQpIHtcXG5cXHRcXHRcXHRcXHRcXHRhamF4ID0gY29udGVudC5hamF4O1xcblxcdFxcdFxcdFxcdFxcdG9uY2UgPSBhamF4ICYmIGFqYXgub25jZSAhPT0gRkFMU0U7XFxuXFx0XFx0XFx0XFx0XFx0ZGVsZXRlIGNvbnRlbnQuYWpheDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRjb250ZW50LnRleHQgPSBmdW5jdGlvbiAoZXZlbnQsIGFwaSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBsb2FkaW5nID0gdGV4dCB8fCAkKHRoaXMpLmF0dHIoYXBpLm9wdGlvbnMuY29udGVudC5hdHRyKSB8fCAnTG9hZGluZy4uLicsXFxuXFx0XFx0XFx0XFx0XFx0XFx0ICAgIGRlZmVycmVkID0gJC5hamF4KCQuZXh0ZW5kKHt9LCBhamF4LCB7IGNvbnRleHQ6IGFwaSB9KSkudGhlbihhamF4LnN1Y2Nlc3MsIE5VTEwsIGFqYXguZXJyb3IpLnRoZW4oZnVuY3Rpb24gKGNvbnRlbnQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoY29udGVudCAmJiBvbmNlKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YXBpLnNldCgnY29udGVudC50ZXh0JywgY29udGVudCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBjb250ZW50O1xcblxcdFxcdFxcdFxcdFxcdFxcdH0sIGZ1bmN0aW9uICh4aHIsIHN0YXR1cywgZXJyb3IpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoYXBpLmRlc3Ryb3llZCB8fCB4aHIuc3RhdHVzID09PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRhcGkuc2V0KCdjb250ZW50LnRleHQnLCBzdGF0dXMgKyAnOiAnICsgZXJyb3IpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH0pO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiAhb25jZSA/IChhcGkuc2V0KCdjb250ZW50LnRleHQnLCBsb2FkaW5nKSwgZGVmZXJyZWQpIDogbG9hZGluZztcXG5cXHRcXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAoJ3RpdGxlJyBpbiBjb250ZW50KSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCQuaXNQbGFpbk9iamVjdChjb250ZW50LnRpdGxlKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGNvbnRlbnQuYnV0dG9uID0gY29udGVudC50aXRsZS5idXR0b247XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y29udGVudC50aXRsZSA9IGNvbnRlbnQudGl0bGUudGV4dDtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKGludmFsaWRDb250ZW50KGNvbnRlbnQudGl0bGUgfHwgRkFMU0UpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y29udGVudC50aXRsZSA9IEZBTFNFO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICgncG9zaXRpb24nIGluIG9wdHMgJiYgaW52YWxpZE9wdChvcHRzLnBvc2l0aW9uKSkge1xcblxcdFxcdFxcdFxcdG9wdHMucG9zaXRpb24gPSB7IG15OiBvcHRzLnBvc2l0aW9uLCBhdDogb3B0cy5wb3NpdGlvbiB9O1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoJ3Nob3cnIGluIG9wdHMgJiYgaW52YWxpZE9wdChvcHRzLnNob3cpKSB7XFxuXFx0XFx0XFx0XFx0b3B0cy5zaG93ID0gb3B0cy5zaG93LmpxdWVyeSA/IHsgdGFyZ2V0OiBvcHRzLnNob3cgfSA6IG9wdHMuc2hvdyA9PT0gVFJVRSA/IHsgcmVhZHk6IFRSVUUgfSA6IHsgZXZlbnQ6IG9wdHMuc2hvdyB9O1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoJ2hpZGUnIGluIG9wdHMgJiYgaW52YWxpZE9wdChvcHRzLmhpZGUpKSB7XFxuXFx0XFx0XFx0XFx0b3B0cy5oaWRlID0gb3B0cy5oaWRlLmpxdWVyeSA/IHsgdGFyZ2V0OiBvcHRzLmhpZGUgfSA6IHsgZXZlbnQ6IG9wdHMuaGlkZSB9O1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoJ3N0eWxlJyBpbiBvcHRzICYmIGludmFsaWRPcHQob3B0cy5zdHlsZSkpIHtcXG5cXHRcXHRcXHRcXHRvcHRzLnN0eWxlID0geyBjbGFzc2VzOiBvcHRzLnN0eWxlIH07XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFNhbml0aXplIHBsdWdpbiBvcHRpb25zXFxuXFx0XFx0XFx0JC5lYWNoKFBMVUdJTlMsIGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLnNhbml0aXplICYmIHRoaXMuc2FuaXRpemUob3B0cyk7XFxuXFx0XFx0XFx0fSk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIG9wdHM7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFNldHVwIGJ1aWx0aW4gLnNldCgpIG9wdGlvbiBjaGVja3NcXG5cXHRcXHRDSEVDS1MgPSBQUk9UT1RZUEUuY2hlY2tzID0ge1xcblxcdFxcdFxcdGJ1aWx0aW46IHtcXG5cXHRcXHRcXHRcXHQvLyBDb3JlIGNoZWNrc1xcblxcdFxcdFxcdFxcdCdeaWQkJzogZnVuY3Rpb24gaWQkKG9iaiwgbywgdiwgcHJldikge1xcblxcdFxcdFxcdFxcdFxcdHZhciBpZCA9IHYgPT09IFRSVUUgPyBRVElQLm5leHRpZCA6IHYsXFxuXFx0XFx0XFx0XFx0XFx0ICAgIG5ld19pZCA9IE5BTUVTUEFDRSArICctJyArIGlkO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmIChpZCAhPT0gRkFMU0UgJiYgaWQubGVuZ3RoID4gMCAmJiAhJCgnIycgKyBuZXdfaWQpLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuX2lkID0gbmV3X2lkO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICh0aGlzLnJlbmRlcmVkKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcy50b29sdGlwWzBdLmlkID0gdGhpcy5faWQ7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5lbGVtZW50cy5jb250ZW50WzBdLmlkID0gdGhpcy5faWQgKyAnLWNvbnRlbnQnO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuZWxlbWVudHMudGl0bGVbMF0uaWQgPSB0aGlzLl9pZCArICctdGl0bGUnO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdG9ialtvXSA9IHByZXY7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0XFx0J15wcmVyZW5kZXInOiBmdW5jdGlvbiBwcmVyZW5kZXIob2JqLCBvLCB2KSB7XFxuXFx0XFx0XFx0XFx0XFx0diAmJiAhdGhpcy5yZW5kZXJlZCAmJiB0aGlzLnJlbmRlcih0aGlzLm9wdGlvbnMuc2hvdy5yZWFkeSk7XFxuXFx0XFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRcXHQvLyBDb250ZW50IGNoZWNrc1xcblxcdFxcdFxcdFxcdCdeY29udGVudC50ZXh0JCc6IGZ1bmN0aW9uIGNvbnRlbnRUZXh0JChvYmosIG8sIHYpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl91cGRhdGVDb250ZW50KHYpO1xcblxcdFxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0XFx0J15jb250ZW50LmF0dHIkJzogZnVuY3Rpb24gY29udGVudEF0dHIkKG9iaiwgbywgdiwgcHJldikge1xcblxcdFxcdFxcdFxcdFxcdGlmICh0aGlzLm9wdGlvbnMuY29udGVudC50ZXh0ID09PSB0aGlzLnRhcmdldC5hdHRyKHByZXYpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5fdXBkYXRlQ29udGVudCh0aGlzLnRhcmdldC5hdHRyKHYpKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRcXHQnXmNvbnRlbnQudGl0bGUkJzogZnVuY3Rpb24gY29udGVudFRpdGxlJChvYmosIG8sIHYpIHtcXG5cXHRcXHRcXHRcXHRcXHQvLyBSZW1vdmUgdGl0bGUgaWYgY29udGVudCBpcyBudWxsXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCF2KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuX3JlbW92ZVRpdGxlKCk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdC8vIElmIHRpdGxlIGlzbid0IGFscmVhZHkgY3JlYXRlZCwgY3JlYXRlIGl0IG5vdyBhbmQgdXBkYXRlXFxuXFx0XFx0XFx0XFx0XFx0diAmJiAhdGhpcy5lbGVtZW50cy50aXRsZSAmJiB0aGlzLl9jcmVhdGVUaXRsZSgpO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX3VwZGF0ZVRpdGxlKHYpO1xcblxcdFxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0XFx0J15jb250ZW50LmJ1dHRvbiQnOiBmdW5jdGlvbiBjb250ZW50QnV0dG9uJChvYmosIG8sIHYpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl91cGRhdGVCdXR0b24odik7XFxuXFx0XFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRcXHQnXmNvbnRlbnQudGl0bGUuKHRleHR8YnV0dG9uKSQnOiBmdW5jdGlvbiBjb250ZW50VGl0bGVUZXh0QnV0dG9uJChvYmosIG8sIHYpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnNldCgnY29udGVudC4nICsgbywgdik7IC8vIEJhY2t3YXJkcyB0aXRsZS50ZXh0L2J1dHRvbiBjb21wYXRcXG5cXHRcXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdFxcdC8vIFBvc2l0aW9uIGNoZWNrc1xcblxcdFxcdFxcdFxcdCdecG9zaXRpb24uKG15fGF0KSQnOiBmdW5jdGlvbiBwb3NpdGlvbk15QXQkKG9iaiwgbywgdikge1xcblxcdFxcdFxcdFxcdFxcdGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHYpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLnBvc2l0aW9uW29dID0gb2JqW29dID0gbmV3IENPUk5FUih2LCBvID09PSAnYXQnKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRcXHQnXnBvc2l0aW9uLmNvbnRhaW5lciQnOiBmdW5jdGlvbiBwb3NpdGlvbkNvbnRhaW5lciQob2JqLCBvLCB2KSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5yZW5kZXJlZCAmJiB0aGlzLnRvb2x0aXAuYXBwZW5kVG8odik7XFxuXFx0XFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRcXHQvLyBTaG93IGNoZWNrc1xcblxcdFxcdFxcdFxcdCdec2hvdy5yZWFkeSQnOiBmdW5jdGlvbiBzaG93UmVhZHkkKG9iaiwgbywgdikge1xcblxcdFxcdFxcdFxcdFxcdHYgJiYgKCF0aGlzLnJlbmRlcmVkICYmIHRoaXMucmVuZGVyKFRSVUUpIHx8IHRoaXMudG9nZ2xlKFRSVUUpKTtcXG5cXHRcXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdFxcdC8vIFN0eWxlIGNoZWNrc1xcblxcdFxcdFxcdFxcdCdec3R5bGUuY2xhc3NlcyQnOiBmdW5jdGlvbiBzdHlsZUNsYXNzZXMkKG9iaiwgbywgdiwgcCkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMucmVuZGVyZWQgJiYgdGhpcy50b29sdGlwLnJlbW92ZUNsYXNzKHApLmFkZENsYXNzKHYpO1xcblxcdFxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0XFx0J15zdHlsZS4od2lkdGh8aGVpZ2h0KSc6IGZ1bmN0aW9uIHN0eWxlV2lkdGhIZWlnaHQob2JqLCBvLCB2KSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5yZW5kZXJlZCAmJiB0aGlzLnRvb2x0aXAuY3NzKG8sIHYpO1xcblxcdFxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0XFx0J15zdHlsZS53aWRnZXR8Y29udGVudC50aXRsZSc6IGZ1bmN0aW9uIHN0eWxlV2lkZ2V0Q29udGVudFRpdGxlKCkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMucmVuZGVyZWQgJiYgdGhpcy5fc2V0V2lkZ2V0KCk7XFxuXFx0XFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRcXHQnXnN0eWxlLmRlZic6IGZ1bmN0aW9uIHN0eWxlRGVmKG9iaiwgbywgdikge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMucmVuZGVyZWQgJiYgdGhpcy50b29sdGlwLnRvZ2dsZUNsYXNzKENMQVNTX0RFRkFVTFQsICEhdik7XFxuXFx0XFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRcXHQvLyBFdmVudHMgY2hlY2tcXG5cXHRcXHRcXHRcXHQnXmV2ZW50cy4ocmVuZGVyfHNob3d8bW92ZXxoaWRlfGZvY3VzfGJsdXIpJCc6IGZ1bmN0aW9uIGV2ZW50c1JlbmRlclNob3dNb3ZlSGlkZUZvY3VzQmx1ciQob2JqLCBvLCB2KSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5yZW5kZXJlZCAmJiB0aGlzLnRvb2x0aXBbKCQuaXNGdW5jdGlvbih2KSA/ICcnIDogJ3VuJykgKyAnYmluZCddKCd0b29sdGlwJyArIG8sIHYpO1xcblxcdFxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0XFx0Ly8gUHJvcGVydGllcyB3aGljaCByZXF1aXJlIGV2ZW50IHJlYXNzaWdubWVudFxcblxcdFxcdFxcdFxcdCdeKHNob3d8aGlkZXxwb3NpdGlvbikuKGV2ZW50fHRhcmdldHxmaXhlZHxpbmFjdGl2ZXxsZWF2ZXxkaXN0YW5jZXx2aWV3cG9ydHxhZGp1c3QpJzogZnVuY3Rpb24gc2hvd0hpZGVQb3NpdGlvbkV2ZW50VGFyZ2V0Rml4ZWRJbmFjdGl2ZUxlYXZlRGlzdGFuY2VWaWV3cG9ydEFkanVzdCgpIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIXRoaXMucmVuZGVyZWQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdC8vIFNldCB0cmFja2luZyBmbGFnXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHBvc09wdGlvbnMgPSB0aGlzLm9wdGlvbnMucG9zaXRpb247XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy50b29sdGlwLmF0dHIoJ3RyYWNraW5nJywgcG9zT3B0aW9ucy50YXJnZXQgPT09ICdtb3VzZScgJiYgcG9zT3B0aW9ucy5hZGp1c3QubW91c2UpO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIFJlYXNzaWduIGV2ZW50c1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX3VuYXNzaWduRXZlbnRzKCk7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fYXNzaWduRXZlbnRzKCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9O1xcblxcblxcdFxcdC8vIERvdCBub3RhdGlvbiBjb252ZXJ0ZXJcXG5cXHRcXHRmdW5jdGlvbiBjb252ZXJ0Tm90YXRpb24ob3B0aW9ucywgbm90YXRpb24pIHtcXG5cXHRcXHRcXHR2YXIgaSA9IDAsXFxuXFx0XFx0XFx0ICAgIG9iaixcXG5cXHRcXHRcXHQgICAgb3B0aW9uID0gb3B0aW9ucyxcXG5cXG5cXG5cXHRcXHRcXHQvLyBTcGxpdCBub3RhdGlvbiBpbnRvIGFycmF5XFxuXFx0XFx0XFx0bGV2ZWxzID0gbm90YXRpb24uc3BsaXQoJy4nKTtcXG5cXG5cXHRcXHRcXHQvLyBMb29wIHRocm91Z2hcXG5cXHRcXHRcXHR3aGlsZSAob3B0aW9uID0gb3B0aW9uW2xldmVsc1tpKytdXSkge1xcblxcdFxcdFxcdFxcdGlmIChpIDwgbGV2ZWxzLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdFxcdG9iaiA9IG9wdGlvbjtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBbb2JqIHx8IG9wdGlvbnMsIGxldmVscy5wb3AoKV07XFxuXFx0XFx0fVxcblxcblxcdFxcdFBST1RPVFlQRS5nZXQgPSBmdW5jdGlvbiAobm90YXRpb24pIHtcXG5cXHRcXHRcXHRpZiAodGhpcy5kZXN0cm95ZWQpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dmFyIG8gPSBjb252ZXJ0Tm90YXRpb24odGhpcy5vcHRpb25zLCBub3RhdGlvbi50b0xvd2VyQ2FzZSgpKSxcXG5cXHRcXHRcXHQgICAgcmVzdWx0ID0gb1swXVtvWzFdXTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gcmVzdWx0LnByZWNlZGFuY2UgPyByZXN1bHQuc3RyaW5nKCkgOiByZXN1bHQ7XFxuXFx0XFx0fTtcXG5cXG5cXHRcXHRmdW5jdGlvbiBzZXRDYWxsYmFjayhub3RhdGlvbiwgYXJncykge1xcblxcdFxcdFxcdHZhciBjYXRlZ29yeSwgcnVsZSwgbWF0Y2g7XFxuXFxuXFx0XFx0XFx0Zm9yIChjYXRlZ29yeSBpbiB0aGlzLmNoZWNrcykge1xcblxcdFxcdFxcdFxcdGZvciAocnVsZSBpbiB0aGlzLmNoZWNrc1tjYXRlZ29yeV0pIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAobWF0Y2ggPSBuZXcgUmVnRXhwKHJ1bGUsICdpJykuZXhlYyhub3RhdGlvbikpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRhcmdzLnB1c2gobWF0Y2gpO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChjYXRlZ29yeSA9PT0gJ2J1aWx0aW4nIHx8IHRoaXMucGx1Z2luc1tjYXRlZ29yeV0pIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLmNoZWNrc1tjYXRlZ29yeV1bcnVsZV0uYXBwbHkodGhpcy5wbHVnaW5zW2NhdGVnb3J5XSB8fCB0aGlzLCBhcmdzKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdHZhciBybW92ZSA9IC9ecG9zaXRpb25cXFxcLihteXxhdHxhZGp1c3R8dGFyZ2V0fGNvbnRhaW5lcnx2aWV3cG9ydCl8c3R5bGV8Y29udGVudHxzaG93XFxcXC5yZWFkeS9pLFxcblxcdFxcdCAgICBycmVuZGVyID0gL15wcmVyZW5kZXJ8c2hvd1xcXFwucmVhZHkvaTtcXG5cXG5cXHRcXHRQUk9UT1RZUEUuc2V0ID0gZnVuY3Rpb24gKG9wdGlvbiwgdmFsdWUpIHtcXG5cXHRcXHRcXHRpZiAodGhpcy5kZXN0cm95ZWQpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dmFyIHJlbmRlcmVkID0gdGhpcy5yZW5kZXJlZCxcXG5cXHRcXHRcXHQgICAgcmVwb3NpdGlvbiA9IEZBTFNFLFxcblxcdFxcdFxcdCAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxcblxcdFxcdFxcdCAgICBjaGVja3MgPSB0aGlzLmNoZWNrcyxcXG5cXHRcXHRcXHQgICAgbmFtZTtcXG5cXG5cXHRcXHRcXHQvLyBDb252ZXJ0IHNpbmd1bGFyIG9wdGlvbi92YWx1ZSBwYWlyIGludG8gb2JqZWN0IGZvcm1cXG5cXHRcXHRcXHRpZiAoJ3N0cmluZycgPT09IHR5cGVvZiBvcHRpb24pIHtcXG5cXHRcXHRcXHRcXHRuYW1lID0gb3B0aW9uO29wdGlvbiA9IHt9O29wdGlvbltuYW1lXSA9IHZhbHVlO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0b3B0aW9uID0gJC5leHRlbmQoe30sIG9wdGlvbik7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFNldCBhbGwgb2YgdGhlIGRlZmluZWQgb3B0aW9ucyB0byB0aGVpciBuZXcgdmFsdWVzXFxuXFx0XFx0XFx0JC5lYWNoKG9wdGlvbiwgZnVuY3Rpb24gKG5vdGF0aW9uLCB2YWx1ZSkge1xcblxcdFxcdFxcdFxcdGlmIChyZW5kZXJlZCAmJiBycmVuZGVyLnRlc3Qobm90YXRpb24pKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZGVsZXRlIG9wdGlvbltub3RhdGlvbl07cmV0dXJuO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBTZXQgbmV3IG9iaiB2YWx1ZVxcblxcdFxcdFxcdFxcdHZhciBvYmogPSBjb252ZXJ0Tm90YXRpb24ob3B0aW9ucywgbm90YXRpb24udG9Mb3dlckNhc2UoKSksXFxuXFx0XFx0XFx0XFx0ICAgIHByZXZpb3VzO1xcblxcdFxcdFxcdFxcdHByZXZpb3VzID0gb2JqWzBdW29ialsxXV07XFxuXFx0XFx0XFx0XFx0b2JqWzBdW29ialsxXV0gPSB2YWx1ZSAmJiB2YWx1ZS5ub2RlVHlwZSA/ICQodmFsdWUpIDogdmFsdWU7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQWxzbyBjaGVjayBpZiB3ZSBuZWVkIHRvIHJlcG9zaXRpb25cXG5cXHRcXHRcXHRcXHRyZXBvc2l0aW9uID0gcm1vdmUudGVzdChub3RhdGlvbikgfHwgcmVwb3NpdGlvbjtcXG5cXG5cXHRcXHRcXHRcXHQvLyBTZXQgdGhlIG5ldyBwYXJhbXMgZm9yIHRoZSBjYWxsYmFja1xcblxcdFxcdFxcdFxcdG9wdGlvbltub3RhdGlvbl0gPSBbb2JqWzBdLCBvYmpbMV0sIHZhbHVlLCBwcmV2aW91c107XFxuXFx0XFx0XFx0fSk7XFxuXFxuXFx0XFx0XFx0Ly8gUmUtc2FuaXRpemUgb3B0aW9uc1xcblxcdFxcdFxcdHNhbml0aXplT3B0aW9ucyhvcHRpb25zKTtcXG5cXG5cXHRcXHRcXHQvKlxcbiAgICAqIEV4ZWN1dGUgYW55IHZhbGlkIGNhbGxiYWNrcyBmb3IgdGhlIHNldCBvcHRpb25zXFxuICAgICogQWxzbyBzZXQgcG9zaXRpb25pbmcgZmxhZyBzbyB3ZSBkb24ndCBnZXQgbG9hZHMgb2YgcmVkdW5kYW50IHJlcG9zaXRpb25pbmcgY2FsbHMuXFxuICAgICovXFxuXFx0XFx0XFx0dGhpcy5wb3NpdGlvbmluZyA9IFRSVUU7XFxuXFx0XFx0XFx0JC5lYWNoKG9wdGlvbiwgJC5wcm94eShzZXRDYWxsYmFjaywgdGhpcykpO1xcblxcdFxcdFxcdHRoaXMucG9zaXRpb25pbmcgPSBGQUxTRTtcXG5cXG5cXHRcXHRcXHQvLyBVcGRhdGUgcG9zaXRpb24gaWYgbmVlZGVkXFxuXFx0XFx0XFx0aWYgKHRoaXMucmVuZGVyZWQgJiYgdGhpcy50b29sdGlwWzBdLm9mZnNldFdpZHRoID4gMCAmJiByZXBvc2l0aW9uKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5yZXBvc2l0aW9uKG9wdGlvbnMucG9zaXRpb24udGFyZ2V0ID09PSAnbW91c2UnID8gTlVMTCA6IHRoaXMuY2FjaGUuZXZlbnQpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXHRcXHR9O1xcblxcdFxcdDtQUk9UT1RZUEUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChjb250ZW50LCBlbGVtZW50LCByZXBvc2l0aW9uKSB7XFxuXFx0XFx0XFx0dmFyIHNlbGYgPSB0aGlzLFxcblxcdFxcdFxcdCAgICBjYWNoZSA9IHRoaXMuY2FjaGU7XFxuXFxuXFx0XFx0XFx0Ly8gTWFrZSBzdXJlIHRvb2x0aXAgaXMgcmVuZGVyZWQgYW5kIGNvbnRlbnQgaXMgZGVmaW5lZC4gSWYgbm90IHJldHVyblxcblxcdFxcdFxcdGlmICghdGhpcy5yZW5kZXJlZCB8fCAhY29udGVudCkge1xcblxcdFxcdFxcdFxcdHJldHVybiBGQUxTRTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gVXNlIGZ1bmN0aW9uIHRvIHBhcnNlIGNvbnRlbnRcXG5cXHRcXHRcXHRpZiAoJC5pc0Z1bmN0aW9uKGNvbnRlbnQpKSB7XFxuXFx0XFx0XFx0XFx0Y29udGVudCA9IGNvbnRlbnQuY2FsbCh0aGlzLmVsZW1lbnRzLnRhcmdldCwgY2FjaGUuZXZlbnQsIHRoaXMpIHx8ICcnO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBIYW5kbGUgZGVmZXJyZWQgY29udGVudFxcblxcdFxcdFxcdGlmICgkLmlzRnVuY3Rpb24oY29udGVudC50aGVuKSkge1xcblxcdFxcdFxcdFxcdGNhY2hlLndhaXRpbmcgPSBUUlVFO1xcblxcdFxcdFxcdFxcdHJldHVybiBjb250ZW50LnRoZW4oZnVuY3Rpb24gKGMpIHtcXG5cXHRcXHRcXHRcXHRcXHRjYWNoZS53YWl0aW5nID0gRkFMU0U7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHNlbGYuX3VwZGF0ZShjLCBlbGVtZW50KTtcXG5cXHRcXHRcXHRcXHR9LCBOVUxMLCBmdW5jdGlvbiAoZSkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBzZWxmLl91cGRhdGUoZSwgZWxlbWVudCk7XFxuXFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIElmIGNvbnRlbnQgaXMgbnVsbC4uLiByZXR1cm4gZmFsc2VcXG5cXHRcXHRcXHRpZiAoY29udGVudCA9PT0gRkFMU0UgfHwgIWNvbnRlbnQgJiYgY29udGVudCAhPT0gJycpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gRkFMU0U7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIEFwcGVuZCBuZXcgY29udGVudCBpZiBpdHMgYSBET00gYXJyYXkgYW5kIHNob3cgaXQgaWYgaGlkZGVuXFxuXFx0XFx0XFx0aWYgKGNvbnRlbnQuanF1ZXJ5ICYmIGNvbnRlbnQubGVuZ3RoID4gMCkge1xcblxcdFxcdFxcdFxcdGVsZW1lbnQuZW1wdHkoKS5hcHBlbmQoY29udGVudC5jc3MoeyBkaXNwbGF5OiAnYmxvY2snLCB2aXNpYmlsaXR5OiAndmlzaWJsZScgfSkpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBDb250ZW50IGlzIGEgcmVndWxhciBzdHJpbmcsIGluc2VydCB0aGUgbmV3IGNvbnRlbnRcXG5cXHRcXHRcXHRlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRlbGVtZW50Lmh0bWwoY29udGVudCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFdhaXQgZm9yIGNvbnRlbnQgdG8gYmUgbG9hZGVkLCBhbmQgcmVwb3NpdGlvblxcblxcdFxcdFxcdHJldHVybiB0aGlzLl93YWl0Rm9yQ29udGVudChlbGVtZW50KS50aGVuKGZ1bmN0aW9uIChpbWFnZXMpIHtcXG5cXHRcXHRcXHRcXHRpZiAoc2VsZi5yZW5kZXJlZCAmJiBzZWxmLnRvb2x0aXBbMF0ub2Zmc2V0V2lkdGggPiAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0c2VsZi5yZXBvc2l0aW9uKGNhY2hlLmV2ZW50LCAhaW1hZ2VzLmxlbmd0aCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0pO1xcblxcdFxcdH07XFxuXFxuXFx0XFx0UFJPVE9UWVBFLl93YWl0Rm9yQ29udGVudCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XFxuXFx0XFx0XFx0dmFyIGNhY2hlID0gdGhpcy5jYWNoZTtcXG5cXG5cXHRcXHRcXHQvLyBTZXQgZmxhZ1xcblxcdFxcdFxcdGNhY2hlLndhaXRpbmcgPSBUUlVFO1xcblxcblxcdFxcdFxcdC8vIElmIGltYWdlc0xvYWRlZCBpcyBpbmNsdWRlZCwgZW5zdXJlIGltYWdlcyBoYXZlIGxvYWRlZCBhbmQgcmV0dXJuIHByb21pc2VcXG5cXHRcXHRcXHRyZXR1cm4gKCQuZm4uaW1hZ2VzTG9hZGVkID8gZWxlbWVudC5pbWFnZXNMb2FkZWQoKSA6ICQuRGVmZXJyZWQoKS5yZXNvbHZlKFtdKSkuZG9uZShmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0Y2FjaGUud2FpdGluZyA9IEZBTFNFO1xcblxcdFxcdFxcdH0pLnByb21pc2UoKTtcXG5cXHRcXHR9O1xcblxcblxcdFxcdFBST1RPVFlQRS5fdXBkYXRlQ29udGVudCA9IGZ1bmN0aW9uIChjb250ZW50LCByZXBvc2l0aW9uKSB7XFxuXFx0XFx0XFx0dGhpcy5fdXBkYXRlKGNvbnRlbnQsIHRoaXMuZWxlbWVudHMuY29udGVudCwgcmVwb3NpdGlvbik7XFxuXFx0XFx0fTtcXG5cXG5cXHRcXHRQUk9UT1RZUEUuX3VwZGF0ZVRpdGxlID0gZnVuY3Rpb24gKGNvbnRlbnQsIHJlcG9zaXRpb24pIHtcXG5cXHRcXHRcXHRpZiAodGhpcy5fdXBkYXRlKGNvbnRlbnQsIHRoaXMuZWxlbWVudHMudGl0bGUsIHJlcG9zaXRpb24pID09PSBGQUxTRSkge1xcblxcdFxcdFxcdFxcdHRoaXMuX3JlbW92ZVRpdGxlKEZBTFNFKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fTtcXG5cXG5cXHRcXHRQUk9UT1RZUEUuX2NyZWF0ZVRpdGxlID0gZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdHZhciBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHMsXFxuXFx0XFx0XFx0ICAgIGlkID0gdGhpcy5faWQgKyAnLXRpdGxlJztcXG5cXG5cXHRcXHRcXHQvLyBEZXN0cm95IHByZXZpb3VzIHRpdGxlIGVsZW1lbnQsIGlmIHByZXNlbnRcXG5cXHRcXHRcXHRpZiAoZWxlbWVudHMudGl0bGViYXIpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9yZW1vdmVUaXRsZSgpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBDcmVhdGUgdGl0bGUgYmFyIGFuZCB0aXRsZSBlbGVtZW50c1xcblxcdFxcdFxcdGVsZW1lbnRzLnRpdGxlYmFyID0gJCgnPGRpdiAvPicsIHtcXG5cXHRcXHRcXHRcXHQnY2xhc3MnOiBOQU1FU1BBQ0UgKyAnLXRpdGxlYmFyICcgKyAodGhpcy5vcHRpb25zLnN0eWxlLndpZGdldCA/IGNyZWF0ZVdpZGdldENsYXNzKCdoZWFkZXInKSA6ICcnKVxcblxcdFxcdFxcdH0pLmFwcGVuZChlbGVtZW50cy50aXRsZSA9ICQoJzxkaXYgLz4nLCB7XFxuXFx0XFx0XFx0XFx0J2lkJzogaWQsXFxuXFx0XFx0XFx0XFx0J2NsYXNzJzogTkFNRVNQQUNFICsgJy10aXRsZScsXFxuXFx0XFx0XFx0XFx0J2FyaWEtYXRvbWljJzogVFJVRVxcblxcdFxcdFxcdH0pKS5pbnNlcnRCZWZvcmUoZWxlbWVudHMuY29udGVudClcXG5cXG5cXHRcXHRcXHQvLyBCdXR0b24tc3BlY2lmaWMgZXZlbnRzXFxuXFx0XFx0XFx0LmRlbGVnYXRlKCcucXRpcC1jbG9zZScsICdtb3VzZWRvd24ga2V5ZG93biBtb3VzZXVwIGtleXVwIG1vdXNlb3V0JywgZnVuY3Rpb24gKGV2ZW50KSB7XFxuXFx0XFx0XFx0XFx0JCh0aGlzKS50b2dnbGVDbGFzcygndWktc3RhdGUtYWN0aXZlIHVpLXN0YXRlLWZvY3VzJywgZXZlbnQudHlwZS5zdWJzdHIoLTQpID09PSAnZG93bicpO1xcblxcdFxcdFxcdH0pLmRlbGVnYXRlKCcucXRpcC1jbG9zZScsICdtb3VzZW92ZXIgbW91c2VvdXQnLCBmdW5jdGlvbiAoZXZlbnQpIHtcXG5cXHRcXHRcXHRcXHQkKHRoaXMpLnRvZ2dsZUNsYXNzKCd1aS1zdGF0ZS1ob3ZlcicsIGV2ZW50LnR5cGUgPT09ICdtb3VzZW92ZXInKTtcXG5cXHRcXHRcXHR9KTtcXG5cXG5cXHRcXHRcXHQvLyBDcmVhdGUgYnV0dG9uIGlmIGVuYWJsZWRcXG5cXHRcXHRcXHRpZiAodGhpcy5vcHRpb25zLmNvbnRlbnQuYnV0dG9uKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5fY3JlYXRlQnV0dG9uKCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH07XFxuXFxuXFx0XFx0UFJPVE9UWVBFLl9yZW1vdmVUaXRsZSA9IGZ1bmN0aW9uIChyZXBvc2l0aW9uKSB7XFxuXFx0XFx0XFx0dmFyIGVsZW1lbnRzID0gdGhpcy5lbGVtZW50cztcXG5cXG5cXHRcXHRcXHRpZiAoZWxlbWVudHMudGl0bGUpIHtcXG5cXHRcXHRcXHRcXHRlbGVtZW50cy50aXRsZWJhci5yZW1vdmUoKTtcXG5cXHRcXHRcXHRcXHRlbGVtZW50cy50aXRsZWJhciA9IGVsZW1lbnRzLnRpdGxlID0gZWxlbWVudHMuYnV0dG9uID0gTlVMTDtcXG5cXG5cXHRcXHRcXHRcXHQvLyBSZXBvc2l0aW9uIGlmIGVuYWJsZWRcXG5cXHRcXHRcXHRcXHRpZiAocmVwb3NpdGlvbiAhPT0gRkFMU0UpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnJlcG9zaXRpb24oKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH07XFxuXFx0XFx0O1BST1RPVFlQRS5fY3JlYXRlUG9zQ2xhc3MgPSBmdW5jdGlvbiAobXkpIHtcXG5cXHRcXHRcXHRyZXR1cm4gTkFNRVNQQUNFICsgJy1wb3MtJyArIChteSB8fCB0aGlzLm9wdGlvbnMucG9zaXRpb24ubXkpLmFiYnJldigpO1xcblxcdFxcdH07XFxuXFxuXFx0XFx0UFJPVE9UWVBFLnJlcG9zaXRpb24gPSBmdW5jdGlvbiAoZXZlbnQsIGVmZmVjdCkge1xcblxcdFxcdFxcdGlmICghdGhpcy5yZW5kZXJlZCB8fCB0aGlzLnBvc2l0aW9uaW5nIHx8IHRoaXMuZGVzdHJveWVkKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFNldCBwb3NpdGlvbmluZyBmbGFnXFxuXFx0XFx0XFx0dGhpcy5wb3NpdGlvbmluZyA9IFRSVUU7XFxuXFxuXFx0XFx0XFx0dmFyIGNhY2hlID0gdGhpcy5jYWNoZSxcXG5cXHRcXHRcXHQgICAgdG9vbHRpcCA9IHRoaXMudG9vbHRpcCxcXG5cXHRcXHRcXHQgICAgcG9zT3B0aW9ucyA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbixcXG5cXHRcXHRcXHQgICAgdGFyZ2V0ID0gcG9zT3B0aW9ucy50YXJnZXQsXFxuXFx0XFx0XFx0ICAgIG15ID0gcG9zT3B0aW9ucy5teSxcXG5cXHRcXHRcXHQgICAgYXQgPSBwb3NPcHRpb25zLmF0LFxcblxcdFxcdFxcdCAgICB2aWV3cG9ydCA9IHBvc09wdGlvbnMudmlld3BvcnQsXFxuXFx0XFx0XFx0ICAgIGNvbnRhaW5lciA9IHBvc09wdGlvbnMuY29udGFpbmVyLFxcblxcdFxcdFxcdCAgICBhZGp1c3QgPSBwb3NPcHRpb25zLmFkanVzdCxcXG5cXHRcXHRcXHQgICAgbWV0aG9kID0gYWRqdXN0Lm1ldGhvZC5zcGxpdCgnICcpLFxcblxcdFxcdFxcdCAgICB0b29sdGlwV2lkdGggPSB0b29sdGlwLm91dGVyV2lkdGgoRkFMU0UpLFxcblxcdFxcdFxcdCAgICB0b29sdGlwSGVpZ2h0ID0gdG9vbHRpcC5vdXRlckhlaWdodChGQUxTRSksXFxuXFx0XFx0XFx0ICAgIHRhcmdldFdpZHRoID0gMCxcXG5cXHRcXHRcXHQgICAgdGFyZ2V0SGVpZ2h0ID0gMCxcXG5cXHRcXHRcXHQgICAgdHlwZSA9IHRvb2x0aXAuY3NzKCdwb3NpdGlvbicpLFxcblxcdFxcdFxcdCAgICBwb3NpdGlvbiA9IHsgbGVmdDogMCwgdG9wOiAwIH0sXFxuXFx0XFx0XFx0ICAgIHZpc2libGUgPSB0b29sdGlwWzBdLm9mZnNldFdpZHRoID4gMCxcXG5cXHRcXHRcXHQgICAgaXNTY3JvbGwgPSBldmVudCAmJiBldmVudC50eXBlID09PSAnc2Nyb2xsJyxcXG5cXHRcXHRcXHQgICAgd2luID0gJCh3aW5kb3cpLFxcblxcdFxcdFxcdCAgICBkb2MgPSBjb250YWluZXJbMF0ub3duZXJEb2N1bWVudCxcXG5cXHRcXHRcXHQgICAgbW91c2UgPSB0aGlzLm1vdXNlLFxcblxcdFxcdFxcdCAgICBwbHVnaW5DYWxjdWxhdGlvbnMsXFxuXFx0XFx0XFx0ICAgIG9mZnNldCxcXG5cXHRcXHRcXHQgICAgYWRqdXN0ZWQsXFxuXFx0XFx0XFx0ICAgIG5ld0NsYXNzO1xcblxcblxcdFxcdFxcdC8vIENoZWNrIGlmIGFic29sdXRlIHBvc2l0aW9uIHdhcyBwYXNzZWRcXG5cXHRcXHRcXHRpZiAoJC5pc0FycmF5KHRhcmdldCkgJiYgdGFyZ2V0Lmxlbmd0aCA9PT0gMikge1xcblxcdFxcdFxcdFxcdC8vIEZvcmNlIGxlZnQgdG9wIGFuZCBzZXQgcG9zaXRpb25cXG5cXHRcXHRcXHRcXHRhdCA9IHsgeDogTEVGVCwgeTogVE9QIH07XFxuXFx0XFx0XFx0XFx0cG9zaXRpb24gPSB7IGxlZnQ6IHRhcmdldFswXSwgdG9wOiB0YXJnZXRbMV0gfTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gQ2hlY2sgaWYgbW91c2Ugd2FzIHRoZSB0YXJnZXRcXG5cXHRcXHRcXHRlbHNlIGlmICh0YXJnZXQgPT09ICdtb3VzZScpIHtcXG5cXHRcXHRcXHRcXHRcXHQvLyBGb3JjZSBsZWZ0IHRvcCB0byBhbGxvdyBmbGlwcGluZ1xcblxcdFxcdFxcdFxcdFxcdGF0ID0geyB4OiBMRUZULCB5OiBUT1AgfTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBVc2UgdGhlIG1vdXNlIG9yaWdpbiB0aGF0IGNhdXNlZCB0aGUgc2hvdyBldmVudCwgaWYgZGlzdGFuY2UgaGlkaW5nIGlzIGVuYWJsZWRcXG5cXHRcXHRcXHRcXHRcXHRpZiAoKCFhZGp1c3QubW91c2UgfHwgdGhpcy5vcHRpb25zLmhpZGUuZGlzdGFuY2UpICYmIGNhY2hlLm9yaWdpbiAmJiBjYWNoZS5vcmlnaW4ucGFnZVgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRldmVudCA9IGNhY2hlLm9yaWdpbjtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gVXNlIGNhY2hlZCBldmVudCBmb3IgcmVzaXplL3Njcm9sbCBldmVudHNcXG5cXHRcXHRcXHRcXHRcXHRlbHNlIGlmICghZXZlbnQgfHwgZXZlbnQgJiYgKGV2ZW50LnR5cGUgPT09ICdyZXNpemUnIHx8IGV2ZW50LnR5cGUgPT09ICdzY3JvbGwnKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGV2ZW50ID0gY2FjaGUuZXZlbnQ7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIE90aGVyd2lzZSwgdXNlIHRoZSBjYWNoZWQgbW91c2UgY29vcmRpbmF0ZXMgaWYgYXZhaWxhYmxlXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZWxzZSBpZiAobW91c2UgJiYgbW91c2UucGFnZVgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRldmVudCA9IG1vdXNlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBDYWxjdWxhdGUgYm9keSBhbmQgY29udGFpbmVyIG9mZnNldCBhbmQgdGFrZSB0aGVtIGludG8gYWNjb3VudCBiZWxvd1xcblxcdFxcdFxcdFxcdFxcdGlmICh0eXBlICE9PSAnc3RhdGljJykge1xcblxcdFxcdFxcdFxcdFxcdFxcdHBvc2l0aW9uID0gY29udGFpbmVyLm9mZnNldCgpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRpZiAoZG9jLmJvZHkub2Zmc2V0V2lkdGggIT09ICh3aW5kb3cuaW5uZXJXaWR0aCB8fCBkb2MuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdG9mZnNldCA9ICQoZG9jdW1lbnQuYm9keSkub2Zmc2V0KCk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdC8vIFVzZSBldmVudCBjb29yZGluYXRlcyBmb3IgcG9zaXRpb25cXG5cXHRcXHRcXHRcXHRcXHRwb3NpdGlvbiA9IHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRsZWZ0OiBldmVudC5wYWdlWCAtIHBvc2l0aW9uLmxlZnQgKyAob2Zmc2V0ICYmIG9mZnNldC5sZWZ0IHx8IDApLFxcblxcdFxcdFxcdFxcdFxcdFxcdHRvcDogZXZlbnQucGFnZVkgLSBwb3NpdGlvbi50b3AgKyAob2Zmc2V0ICYmIG9mZnNldC50b3AgfHwgMClcXG5cXHRcXHRcXHRcXHRcXHR9O1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIFNjcm9sbCBldmVudHMgYXJlIGEgcGFpbiwgc29tZSBicm93c2Vyc1xcblxcdFxcdFxcdFxcdFxcdGlmIChhZGp1c3QubW91c2UgJiYgaXNTY3JvbGwgJiYgbW91c2UpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRwb3NpdGlvbi5sZWZ0IC09IChtb3VzZS5zY3JvbGxYIHx8IDApIC0gd2luLnNjcm9sbExlZnQoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRwb3NpdGlvbi50b3AgLT0gKG1vdXNlLnNjcm9sbFkgfHwgMCkgLSB3aW4uc2Nyb2xsVG9wKCk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBUYXJnZXQgd2Fzbid0IG1vdXNlIG9yIGFic29sdXRlLi4uXFxuXFx0XFx0XFx0XFx0ZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gQ2hlY2sgaWYgZXZlbnQgdGFyZ2V0dGluZyBpcyBiZWluZyB1c2VkXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKHRhcmdldCA9PT0gJ2V2ZW50Jykge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChldmVudCAmJiBldmVudC50YXJnZXQgJiYgZXZlbnQudHlwZSAhPT0gJ3Njcm9sbCcgJiYgZXZlbnQudHlwZSAhPT0gJ3Jlc2l6ZScpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjYWNoZS50YXJnZXQgPSAkKGV2ZW50LnRhcmdldCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIGlmICghZXZlbnQudGFyZ2V0KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Y2FjaGUudGFyZ2V0ID0gdGhpcy5lbGVtZW50cy50YXJnZXQ7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSBpZiAodGFyZ2V0ICE9PSAnZXZlbnQnKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y2FjaGUudGFyZ2V0ID0gJCh0YXJnZXQuanF1ZXJ5ID8gdGFyZ2V0IDogdGhpcy5lbGVtZW50cy50YXJnZXQpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR0YXJnZXQgPSBjYWNoZS50YXJnZXQ7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gUGFyc2UgdGhlIHRhcmdldCBpbnRvIGEgalF1ZXJ5IG9iamVjdCBhbmQgbWFrZSBzdXJlIHRoZXJlJ3MgYW4gZWxlbWVudCBwcmVzZW50XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGFyZ2V0ID0gJCh0YXJnZXQpLmVxKDApO1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICh0YXJnZXQubGVuZ3RoID09PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIENoZWNrIGlmIHdpbmRvdyBvciBkb2N1bWVudCBpcyB0aGUgdGFyZ2V0XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZWxzZSBpZiAodGFyZ2V0WzBdID09PSBkb2N1bWVudCB8fCB0YXJnZXRbMF0gPT09IHdpbmRvdykge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRhcmdldFdpZHRoID0gQlJPV1NFUi5pT1MgPyB3aW5kb3cuaW5uZXJXaWR0aCA6IHRhcmdldC53aWR0aCgpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRhcmdldEhlaWdodCA9IEJST1dTRVIuaU9TID8gd2luZG93LmlubmVySGVpZ2h0IDogdGFyZ2V0LmhlaWdodCgpO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICh0YXJnZXRbMF0gPT09IHdpbmRvdykge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHBvc2l0aW9uID0ge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRvcDogKHZpZXdwb3J0IHx8IHRhcmdldCkuc2Nyb2xsVG9wKCksXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bGVmdDogKHZpZXdwb3J0IHx8IHRhcmdldCkuc2Nyb2xsTGVmdCgpXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIENoZWNrIGlmIHRoZSB0YXJnZXQgaXMgYW4gPEFSRUE+IGVsZW1lbnRcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRlbHNlIGlmIChQTFVHSU5TLmltYWdlbWFwICYmIHRhcmdldC5pcygnYXJlYScpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cGx1Z2luQ2FsY3VsYXRpb25zID0gUExVR0lOUy5pbWFnZW1hcCh0aGlzLCB0YXJnZXQsIGF0LCBQTFVHSU5TLnZpZXdwb3J0ID8gbWV0aG9kIDogRkFMU0UpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBDaGVjayBpZiB0aGUgdGFyZ2V0IGlzIGFuIFNWRyBlbGVtZW50XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZWxzZSBpZiAoUExVR0lOUy5zdmcgJiYgdGFyZ2V0ICYmIHRhcmdldFswXS5vd25lclNWR0VsZW1lbnQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRwbHVnaW5DYWxjdWxhdGlvbnMgPSBQTFVHSU5TLnN2Zyh0aGlzLCB0YXJnZXQsIGF0LCBQTFVHSU5TLnZpZXdwb3J0ID8gbWV0aG9kIDogRkFMU0UpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBPdGhlcndpc2UgdXNlIHJlZ3VsYXIgalF1ZXJ5IG1ldGhvZHNcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0YXJnZXRXaWR0aCA9IHRhcmdldC5vdXRlcldpZHRoKEZBTFNFKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0YXJnZXRIZWlnaHQgPSB0YXJnZXQub3V0ZXJIZWlnaHQoRkFMU0UpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHBvc2l0aW9uID0gdGFyZ2V0Lm9mZnNldCgpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBQYXJzZSByZXR1cm5lZCBwbHVnaW4gdmFsdWVzIGludG8gcHJvcGVyIHZhcmlhYmxlc1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChwbHVnaW5DYWxjdWxhdGlvbnMpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0YXJnZXRXaWR0aCA9IHBsdWdpbkNhbGN1bGF0aW9ucy53aWR0aDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0YXJnZXRIZWlnaHQgPSBwbHVnaW5DYWxjdWxhdGlvbnMuaGVpZ2h0O1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG9mZnNldCA9IHBsdWdpbkNhbGN1bGF0aW9ucy5vZmZzZXQ7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cG9zaXRpb24gPSBwbHVnaW5DYWxjdWxhdGlvbnMucG9zaXRpb247XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIEFkanVzdCBwb3NpdGlvbiB0byB0YWtlIGludG8gYWNjb3VudCBvZmZzZXQgcGFyZW50c1xcblxcdFxcdFxcdFxcdFxcdFxcdHBvc2l0aW9uID0gdGhpcy5yZXBvc2l0aW9uLm9mZnNldCh0YXJnZXQsIHBvc2l0aW9uLCBjb250YWluZXIpO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIEFkanVzdCBmb3IgcG9zaXRpb24uZml4ZWQgdG9vbHRpcHMgKGFuZCBhbHNvIGlPUyBzY3JvbGwgYnVnIGluIHYzLjItNC4wICYgdjQuMy00LjMuMilcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoQlJPV1NFUi5pT1MgPiAzLjEgJiYgQlJPV1NFUi5pT1MgPCA0LjEgfHwgQlJPV1NFUi5pT1MgPj0gNC4zICYmIEJST1dTRVIuaU9TIDwgNC4zMyB8fCAhQlJPV1NFUi5pT1MgJiYgdHlwZSA9PT0gJ2ZpeGVkJykge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHBvc2l0aW9uLmxlZnQgLT0gd2luLnNjcm9sbExlZnQoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRwb3NpdGlvbi50b3AgLT0gd2luLnNjcm9sbFRvcCgpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBBZGp1c3QgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGFyZ2V0XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCFwbHVnaW5DYWxjdWxhdGlvbnMgfHwgcGx1Z2luQ2FsY3VsYXRpb25zICYmIHBsdWdpbkNhbGN1bGF0aW9ucy5hZGp1c3RhYmxlICE9PSBGQUxTRSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHBvc2l0aW9uLmxlZnQgKz0gYXQueCA9PT0gUklHSFQgPyB0YXJnZXRXaWR0aCA6IGF0LnggPT09IENFTlRFUiA/IHRhcmdldFdpZHRoIC8gMiA6IDA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cG9zaXRpb24udG9wICs9IGF0LnkgPT09IEJPVFRPTSA/IHRhcmdldEhlaWdodCA6IGF0LnkgPT09IENFTlRFUiA/IHRhcmdldEhlaWdodCAvIDIgOiAwO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gQWRqdXN0IHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRvb2x0aXBcXG5cXHRcXHRcXHRwb3NpdGlvbi5sZWZ0ICs9IGFkanVzdC54ICsgKG15LnggPT09IFJJR0hUID8gLXRvb2x0aXBXaWR0aCA6IG15LnggPT09IENFTlRFUiA/IC10b29sdGlwV2lkdGggLyAyIDogMCk7XFxuXFx0XFx0XFx0cG9zaXRpb24udG9wICs9IGFkanVzdC55ICsgKG15LnkgPT09IEJPVFRPTSA/IC10b29sdGlwSGVpZ2h0IDogbXkueSA9PT0gQ0VOVEVSID8gLXRvb2x0aXBIZWlnaHQgLyAyIDogMCk7XFxuXFxuXFx0XFx0XFx0Ly8gVXNlIHZpZXdwb3J0IGFkanVzdG1lbnQgcGx1Z2luIGlmIGVuYWJsZWRcXG5cXHRcXHRcXHRpZiAoUExVR0lOUy52aWV3cG9ydCkge1xcblxcdFxcdFxcdFxcdGFkanVzdGVkID0gcG9zaXRpb24uYWRqdXN0ZWQgPSBQTFVHSU5TLnZpZXdwb3J0KHRoaXMsIHBvc2l0aW9uLCBwb3NPcHRpb25zLCB0YXJnZXRXaWR0aCwgdGFyZ2V0SGVpZ2h0LCB0b29sdGlwV2lkdGgsIHRvb2x0aXBIZWlnaHQpO1xcblxcblxcdFxcdFxcdFxcdC8vIEFwcGx5IG9mZnNldHMgc3VwcGxpZWQgYnkgcG9zaXRpb25pbmcgcGx1Z2luIChpZiB1c2VkKVxcblxcdFxcdFxcdFxcdGlmIChvZmZzZXQgJiYgYWRqdXN0ZWQubGVmdCkge1xcblxcdFxcdFxcdFxcdFxcdHBvc2l0aW9uLmxlZnQgKz0gb2Zmc2V0LmxlZnQ7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGlmIChvZmZzZXQgJiYgYWRqdXN0ZWQudG9wKSB7XFxuXFx0XFx0XFx0XFx0XFx0cG9zaXRpb24udG9wICs9IG9mZnNldC50b3A7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIEFwcGx5IGFueSBuZXcgJ215JyBwb3NpdGlvblxcblxcdFxcdFxcdFxcdGlmIChhZGp1c3RlZC5teSkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMucG9zaXRpb24ubXkgPSBhZGp1c3RlZC5teTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFZpZXdwb3J0IGFkanVzdG1lbnQgaXMgZGlzYWJsZWQsIHNldCB2YWx1ZXMgdG8gemVyb1xcblxcdFxcdFxcdGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdHBvc2l0aW9uLmFkanVzdGVkID0geyBsZWZ0OiAwLCB0b3A6IDAgfTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gU2V0IHRvb2x0aXAgcG9zaXRpb24gY2xhc3MgaWYgaXQncyBjaGFuZ2VkXFxuXFx0XFx0XFx0aWYgKGNhY2hlLnBvc0NsYXNzICE9PSAobmV3Q2xhc3MgPSB0aGlzLl9jcmVhdGVQb3NDbGFzcyh0aGlzLnBvc2l0aW9uLm15KSkpIHtcXG5cXHRcXHRcXHRcXHR0b29sdGlwLnJlbW92ZUNsYXNzKGNhY2hlLnBvc0NsYXNzKS5hZGRDbGFzcyhjYWNoZS5wb3NDbGFzcyA9IG5ld0NsYXNzKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gdG9vbHRpcG1vdmUgZXZlbnRcXG5cXHRcXHRcXHRpZiAoIXRoaXMuX3RyaWdnZXIoJ21vdmUnLCBbcG9zaXRpb24sIHZpZXdwb3J0LmVsZW0gfHwgdmlld3BvcnRdLCBldmVudCkpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0ZGVsZXRlIHBvc2l0aW9uLmFkanVzdGVkO1xcblxcblxcdFxcdFxcdC8vIElmIGVmZmVjdCBpcyBkaXNhYmxlZCwgdGFyZ2V0IGl0IG1vdXNlLCBubyBhbmltYXRpb24gaXMgZGVmaW5lZCBvciBwb3NpdGlvbmluZyBnaXZlcyBOYU4gb3V0LCBzZXQgQ1NTIGRpcmVjdGx5XFxuXFx0XFx0XFx0aWYgKGVmZmVjdCA9PT0gRkFMU0UgfHwgIXZpc2libGUgfHwgaXNOYU4ocG9zaXRpb24ubGVmdCkgfHwgaXNOYU4ocG9zaXRpb24udG9wKSB8fCB0YXJnZXQgPT09ICdtb3VzZScgfHwgISQuaXNGdW5jdGlvbihwb3NPcHRpb25zLmVmZmVjdCkpIHtcXG5cXHRcXHRcXHRcXHR0b29sdGlwLmNzcyhwb3NpdGlvbik7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFVzZSBjdXN0b20gZnVuY3Rpb24gaWYgcHJvdmlkZWRcXG5cXHRcXHRcXHRlbHNlIGlmICgkLmlzRnVuY3Rpb24ocG9zT3B0aW9ucy5lZmZlY3QpKSB7XFxuXFx0XFx0XFx0XFx0XFx0cG9zT3B0aW9ucy5lZmZlY3QuY2FsbCh0b29sdGlwLCB0aGlzLCAkLmV4dGVuZCh7fSwgcG9zaXRpb24pKTtcXG5cXHRcXHRcXHRcXHRcXHR0b29sdGlwLnF1ZXVlKGZ1bmN0aW9uIChuZXh0KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gUmVzZXQgYXR0cmlidXRlcyB0byBhdm9pZCBjcm9zcy1icm93c2VyIHJlbmRlcmluZyBidWdzXFxuXFx0XFx0XFx0XFx0XFx0XFx0JCh0aGlzKS5jc3MoeyBvcGFjaXR5OiAnJywgaGVpZ2h0OiAnJyB9KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoQlJPV1NFUi5pZSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuc3R5bGUucmVtb3ZlQXR0cmlidXRlKCdmaWx0ZXInKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0bmV4dCgpO1xcblxcdFxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBTZXQgcG9zaXRpb25pbmcgZmxhZ1xcblxcdFxcdFxcdHRoaXMucG9zaXRpb25pbmcgPSBGQUxTRTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXHRcXHR9O1xcblxcblxcdFxcdC8vIEN1c3RvbSAobW9yZSBjb3JyZWN0IGZvciBxVGlwISkgb2Zmc2V0IGNhbGN1bGF0b3JcXG5cXHRcXHRQUk9UT1RZUEUucmVwb3NpdGlvbi5vZmZzZXQgPSBmdW5jdGlvbiAoZWxlbSwgcG9zLCBjb250YWluZXIpIHtcXG5cXHRcXHRcXHRpZiAoIWNvbnRhaW5lclswXSkge1xcblxcdFxcdFxcdFxcdHJldHVybiBwb3M7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHZhciBvd25lckRvY3VtZW50ID0gJChlbGVtWzBdLm93bmVyRG9jdW1lbnQpLFxcblxcdFxcdFxcdCAgICBxdWlya3MgPSAhIUJST1dTRVIuaWUgJiYgZG9jdW1lbnQuY29tcGF0TW9kZSAhPT0gJ0NTUzFDb21wYXQnLFxcblxcdFxcdFxcdCAgICBwYXJlbnQgPSBjb250YWluZXJbMF0sXFxuXFx0XFx0XFx0ICAgIHNjcm9sbGVkLFxcblxcdFxcdFxcdCAgICBwb3NpdGlvbixcXG5cXHRcXHRcXHQgICAgcGFyZW50T2Zmc2V0LFxcblxcdFxcdFxcdCAgICBvdmVyZmxvdztcXG5cXG5cXHRcXHRcXHRmdW5jdGlvbiBzY3JvbGwoZSwgaSkge1xcblxcdFxcdFxcdFxcdHBvcy5sZWZ0ICs9IGkgKiBlLnNjcm9sbExlZnQoKTtcXG5cXHRcXHRcXHRcXHRwb3MudG9wICs9IGkgKiBlLnNjcm9sbFRvcCgpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBDb21wZW5zYXRlIGZvciBub24tc3RhdGljIGNvbnRhaW5lcnMgb2Zmc2V0XFxuXFx0XFx0XFx0ZG8ge1xcblxcdFxcdFxcdFxcdGlmICgocG9zaXRpb24gPSAkLmNzcyhwYXJlbnQsICdwb3NpdGlvbicpKSAhPT0gJ3N0YXRpYycpIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAocG9zaXRpb24gPT09ICdmaXhlZCcpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRwYXJlbnRPZmZzZXQgPSBwYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0c2Nyb2xsKG93bmVyRG9jdW1lbnQsIC0xKTtcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdHBhcmVudE9mZnNldCA9ICQocGFyZW50KS5wb3NpdGlvbigpO1xcblxcdFxcdFxcdFxcdFxcdFxcdHBhcmVudE9mZnNldC5sZWZ0ICs9IHBhcnNlRmxvYXQoJC5jc3MocGFyZW50LCAnYm9yZGVyTGVmdFdpZHRoJykpIHx8IDA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cGFyZW50T2Zmc2V0LnRvcCArPSBwYXJzZUZsb2F0KCQuY3NzKHBhcmVudCwgJ2JvcmRlclRvcFdpZHRoJykpIHx8IDA7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdHBvcy5sZWZ0IC09IHBhcmVudE9mZnNldC5sZWZ0ICsgKHBhcnNlRmxvYXQoJC5jc3MocGFyZW50LCAnbWFyZ2luTGVmdCcpKSB8fCAwKTtcXG5cXHRcXHRcXHRcXHRcXHRwb3MudG9wIC09IHBhcmVudE9mZnNldC50b3AgKyAocGFyc2VGbG9hdCgkLmNzcyhwYXJlbnQsICdtYXJnaW5Ub3AnKSkgfHwgMCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gSWYgdGhpcyBpcyB0aGUgZmlyc3QgcGFyZW50IGVsZW1lbnQgd2l0aCBhbiBvdmVyZmxvdyBvZiBcXFwic2Nyb2xsXFxcIiBvciBcXFwiYXV0b1xcXCIsIHN0b3JlIGl0XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCFzY3JvbGxlZCAmJiAob3ZlcmZsb3cgPSAkLmNzcyhwYXJlbnQsICdvdmVyZmxvdycpKSAhPT0gJ2hpZGRlbicgJiYgb3ZlcmZsb3cgIT09ICd2aXNpYmxlJykge1xcblxcdFxcdFxcdFxcdFxcdFxcdHNjcm9sbGVkID0gJChwYXJlbnQpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSB3aGlsZSAocGFyZW50ID0gcGFyZW50Lm9mZnNldFBhcmVudCk7XFxuXFxuXFx0XFx0XFx0Ly8gQ29tcGVuc2F0ZSBmb3IgY29udGFpbmVycyBzY3JvbGwgaWYgaXQgYWxzbyBoYXMgYW4gb2Zmc2V0UGFyZW50IChvciBpbiBJRSBxdWlya3MgbW9kZSlcXG5cXHRcXHRcXHRpZiAoc2Nyb2xsZWQgJiYgKHNjcm9sbGVkWzBdICE9PSBvd25lckRvY3VtZW50WzBdIHx8IHF1aXJrcykpIHtcXG5cXHRcXHRcXHRcXHRzY3JvbGwoc2Nyb2xsZWQsIDEpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gcG9zO1xcblxcdFxcdH07XFxuXFxuXFx0XFx0Ly8gQ29ybmVyIGNsYXNzXFxuXFx0XFx0dmFyIEMgPSAoQ09STkVSID0gUFJPVE9UWVBFLnJlcG9zaXRpb24uQ29ybmVyID0gZnVuY3Rpb24gKGNvcm5lciwgZm9yY2VZKSB7XFxuXFx0XFx0XFx0Y29ybmVyID0gKCcnICsgY29ybmVyKS5yZXBsYWNlKC8oW0EtWl0pLywgJyAkMScpLnJlcGxhY2UoL21pZGRsZS9naSwgQ0VOVEVSKS50b0xvd2VyQ2FzZSgpO1xcblxcdFxcdFxcdHRoaXMueCA9IChjb3JuZXIubWF0Y2goL2xlZnR8cmlnaHQvaSkgfHwgY29ybmVyLm1hdGNoKC9jZW50ZXIvKSB8fCBbJ2luaGVyaXQnXSlbMF0udG9Mb3dlckNhc2UoKTtcXG5cXHRcXHRcXHR0aGlzLnkgPSAoY29ybmVyLm1hdGNoKC90b3B8Ym90dG9tfGNlbnRlci9pKSB8fCBbJ2luaGVyaXQnXSlbMF0udG9Mb3dlckNhc2UoKTtcXG5cXHRcXHRcXHR0aGlzLmZvcmNlWSA9ICEhZm9yY2VZO1xcblxcblxcdFxcdFxcdHZhciBmID0gY29ybmVyLmNoYXJBdCgwKTtcXG5cXHRcXHRcXHR0aGlzLnByZWNlZGFuY2UgPSBmID09PSAndCcgfHwgZiA9PT0gJ2InID8gWSA6IFg7XFxuXFx0XFx0fSkucHJvdG90eXBlO1xcblxcblxcdFxcdEMuaW52ZXJ0ID0gZnVuY3Rpb24gKHosIGNlbnRlcikge1xcblxcdFxcdFxcdHRoaXNbel0gPSB0aGlzW3pdID09PSBMRUZUID8gUklHSFQgOiB0aGlzW3pdID09PSBSSUdIVCA/IExFRlQgOiBjZW50ZXIgfHwgdGhpc1t6XTtcXG5cXHRcXHR9O1xcblxcblxcdFxcdEMuc3RyaW5nID0gZnVuY3Rpb24gKGpvaW4pIHtcXG5cXHRcXHRcXHR2YXIgeCA9IHRoaXMueCxcXG5cXHRcXHRcXHQgICAgeSA9IHRoaXMueTtcXG5cXG5cXHRcXHRcXHR2YXIgcmVzdWx0ID0geCAhPT0geSA/IHggPT09ICdjZW50ZXInIHx8IHkgIT09ICdjZW50ZXInICYmICh0aGlzLnByZWNlZGFuY2UgPT09IFkgfHwgdGhpcy5mb3JjZVkpID8gW3ksIHhdIDogW3gsIHldIDogW3hdO1xcblxcblxcdFxcdFxcdHJldHVybiBqb2luICE9PSBmYWxzZSA/IHJlc3VsdC5qb2luKCcgJykgOiByZXN1bHQ7XFxuXFx0XFx0fTtcXG5cXG5cXHRcXHRDLmFiYnJldiA9IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHR2YXIgcmVzdWx0ID0gdGhpcy5zdHJpbmcoZmFsc2UpO1xcblxcdFxcdFxcdHJldHVybiByZXN1bHRbMF0uY2hhckF0KDApICsgKHJlc3VsdFsxXSAmJiByZXN1bHRbMV0uY2hhckF0KDApIHx8ICcnKTtcXG5cXHRcXHR9O1xcblxcblxcdFxcdEMuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0cmV0dXJuIG5ldyBDT1JORVIodGhpcy5zdHJpbmcoKSwgdGhpcy5mb3JjZVkpO1xcblxcdFxcdH07XFxuXFxuXFx0XFx0O1xcblxcdFxcdFBST1RPVFlQRS50b2dnbGUgPSBmdW5jdGlvbiAoc3RhdGUsIGV2ZW50KSB7XFxuXFx0XFx0XFx0dmFyIGNhY2hlID0gdGhpcy5jYWNoZSxcXG5cXHRcXHRcXHQgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcXG5cXHRcXHRcXHQgICAgdG9vbHRpcCA9IHRoaXMudG9vbHRpcDtcXG5cXG5cXHRcXHRcXHQvLyBUcnkgdG8gcHJldmVudCBmbGlja2VyaW5nIHdoZW4gdG9vbHRpcCBvdmVybGFwcyBzaG93IGVsZW1lbnRcXG5cXHRcXHRcXHRpZiAoZXZlbnQpIHtcXG5cXHRcXHRcXHRcXHRpZiAoL292ZXJ8ZW50ZXIvLnRlc3QoZXZlbnQudHlwZSkgJiYgY2FjaGUuZXZlbnQgJiYgL291dHxsZWF2ZS8udGVzdChjYWNoZS5ldmVudC50eXBlKSAmJiBvcHRpb25zLnNob3cudGFyZ2V0LmFkZChldmVudC50YXJnZXQpLmxlbmd0aCA9PT0gb3B0aW9ucy5zaG93LnRhcmdldC5sZW5ndGggJiYgdG9vbHRpcC5oYXMoZXZlbnQucmVsYXRlZFRhcmdldCkubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIENhY2hlIGV2ZW50XFxuXFx0XFx0XFx0XFx0Y2FjaGUuZXZlbnQgPSAkLmV2ZW50LmZpeChldmVudCk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIElmIHdlJ3JlIGN1cnJlbnRseSB3YWl0aW5nIGFuZCB3ZSd2ZSBqdXN0IGhpZGRlbi4uLiBzdG9wIGl0XFxuXFx0XFx0XFx0dGhpcy53YWl0aW5nICYmICFzdGF0ZSAmJiAodGhpcy5oaWRkZW5EdXJpbmdXYWl0ID0gVFJVRSk7XFxuXFxuXFx0XFx0XFx0Ly8gUmVuZGVyIHRoZSB0b29sdGlwIGlmIHNob3dpbmcgYW5kIGl0IGlzbid0IGFscmVhZHlcXG5cXHRcXHRcXHRpZiAoIXRoaXMucmVuZGVyZWQpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gc3RhdGUgPyB0aGlzLnJlbmRlcigxKSA6IHRoaXM7XFxuXFx0XFx0XFx0fSBlbHNlIGlmICh0aGlzLmRlc3Ryb3llZCB8fCB0aGlzLmRpc2FibGVkKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHZhciB0eXBlID0gc3RhdGUgPyAnc2hvdycgOiAnaGlkZScsXFxuXFx0XFx0XFx0ICAgIG9wdHMgPSB0aGlzLm9wdGlvbnNbdHlwZV0sXFxuXFx0XFx0XFx0ICAgIG90aGVyT3B0cyA9IHRoaXMub3B0aW9uc1shc3RhdGUgPyAnc2hvdycgOiAnaGlkZSddLFxcblxcdFxcdFxcdCAgICBwb3NPcHRpb25zID0gdGhpcy5vcHRpb25zLnBvc2l0aW9uLFxcblxcdFxcdFxcdCAgICBjb250ZW50T3B0aW9ucyA9IHRoaXMub3B0aW9ucy5jb250ZW50LFxcblxcdFxcdFxcdCAgICB3aWR0aCA9IHRoaXMudG9vbHRpcC5jc3MoJ3dpZHRoJyksXFxuXFx0XFx0XFx0ICAgIHZpc2libGUgPSB0aGlzLnRvb2x0aXAuaXMoJzp2aXNpYmxlJyksXFxuXFx0XFx0XFx0ICAgIGFuaW1hdGUgPSBzdGF0ZSB8fCBvcHRzLnRhcmdldC5sZW5ndGggPT09IDEsXFxuXFx0XFx0XFx0ICAgIHNhbWVUYXJnZXQgPSAhZXZlbnQgfHwgb3B0cy50YXJnZXQubGVuZ3RoIDwgMiB8fCBjYWNoZS50YXJnZXRbMF0gPT09IGV2ZW50LnRhcmdldCxcXG5cXHRcXHRcXHQgICAgaWRlbnRpY2FsU3RhdGUsXFxuXFx0XFx0XFx0ICAgIGFsbG93LFxcblxcdFxcdFxcdCAgICBzaG93RXZlbnQsXFxuXFx0XFx0XFx0ICAgIGRlbGF5LFxcblxcdFxcdFxcdCAgICBhZnRlcjtcXG5cXG5cXHRcXHRcXHQvLyBEZXRlY3Qgc3RhdGUgaWYgdmFsaWQgb25lIGlzbid0IHByb3ZpZGVkXFxuXFx0XFx0XFx0aWYgKCh0eXBlb2Ygc3RhdGUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHN0YXRlKSkuc2VhcmNoKCdib29sZWFufG51bWJlcicpKSB7XFxuXFx0XFx0XFx0XFx0c3RhdGUgPSAhdmlzaWJsZTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gQ2hlY2sgaWYgdGhlIHRvb2x0aXAgaXMgaW4gYW4gaWRlbnRpY2FsIHN0YXRlIHRvIHRoZSBuZXcgd291bGQtYmUgc3RhdGVcXG5cXHRcXHRcXHRpZGVudGljYWxTdGF0ZSA9ICF0b29sdGlwLmlzKCc6YW5pbWF0ZWQnKSAmJiB2aXNpYmxlID09PSBzdGF0ZSAmJiBzYW1lVGFyZ2V0O1xcblxcblxcdFxcdFxcdC8vIEZpcmUgdG9vbHRpcChzaG93L2hpZGUpIGV2ZW50IGFuZCBjaGVjayBpZiBkZXN0cm95ZWRcXG5cXHRcXHRcXHRhbGxvdyA9ICFpZGVudGljYWxTdGF0ZSA/ICEhdGhpcy5fdHJpZ2dlcih0eXBlLCBbOTBdKSA6IE5VTEw7XFxuXFxuXFx0XFx0XFx0Ly8gQ2hlY2sgdG8gbWFrZSBzdXJlIHRoZSB0b29sdGlwIHdhc24ndCBkZXN0cm95ZWQgaW4gdGhlIGNhbGxiYWNrXFxuXFx0XFx0XFx0aWYgKHRoaXMuZGVzdHJveWVkKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIElmIHRoZSB1c2VyIGRpZG4ndCBzdG9wIHRoZSBtZXRob2QgcHJlbWF0dXJlbHkgYW5kIHdlJ3JlIHNob3dpbmcgdGhlIHRvb2x0aXAsIGZvY3VzIGl0XFxuXFx0XFx0XFx0aWYgKGFsbG93ICE9PSBGQUxTRSAmJiBzdGF0ZSkge1xcblxcdFxcdFxcdFxcdHRoaXMuZm9jdXMoZXZlbnQpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBJZiB0aGUgc3RhdGUgaGFzbid0IGNoYW5nZWQgb3IgdGhlIHVzZXIgc3RvcHBlZCBpdCwgcmV0dXJuIGVhcmx5XFxuXFx0XFx0XFx0aWYgKCFhbGxvdyB8fCBpZGVudGljYWxTdGF0ZSkge1xcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBTZXQgQVJJQSBoaWRkZW4gYXR0cmlidXRlXFxuXFx0XFx0XFx0JC5hdHRyKHRvb2x0aXBbMF0sICdhcmlhLWhpZGRlbicsICEhIXN0YXRlKTtcXG5cXG5cXHRcXHRcXHQvLyBFeGVjdXRlIHN0YXRlIHNwZWNpZmljIHByb3BlcnRpZXNcXG5cXHRcXHRcXHRpZiAoc3RhdGUpIHtcXG5cXHRcXHRcXHRcXHQvLyBTdG9yZSBzaG93IG9yaWdpbiBjb29yZGluYXRlc1xcblxcdFxcdFxcdFxcdHRoaXMubW91c2UgJiYgKGNhY2hlLm9yaWdpbiA9ICQuZXZlbnQuZml4KHRoaXMubW91c2UpKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBVcGRhdGUgdG9vbHRpcCBjb250ZW50ICYgdGl0bGUgaWYgaXQncyBhIGR5bmFtaWMgZnVuY3Rpb25cXG5cXHRcXHRcXHRcXHRpZiAoJC5pc0Z1bmN0aW9uKGNvbnRlbnRPcHRpb25zLnRleHQpKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fdXBkYXRlQ29udGVudChjb250ZW50T3B0aW9ucy50ZXh0LCBGQUxTRSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGlmICgkLmlzRnVuY3Rpb24oY29udGVudE9wdGlvbnMudGl0bGUpKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fdXBkYXRlVGl0bGUoY29udGVudE9wdGlvbnMudGl0bGUsIEZBTFNFKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQ2FjaGUgbW91c2Vtb3ZlIGV2ZW50cyBmb3IgcG9zaXRpb25pbmcgcHVycG9zZXMgKGlmIG5vdCBhbHJlYWR5IHRyYWNraW5nKVxcblxcdFxcdFxcdFxcdGlmICghdHJhY2tpbmdCb3VuZCAmJiBwb3NPcHRpb25zLnRhcmdldCA9PT0gJ21vdXNlJyAmJiBwb3NPcHRpb25zLmFkanVzdC5tb3VzZSkge1xcblxcdFxcdFxcdFxcdFxcdCQoZG9jdW1lbnQpLmJpbmQoJ21vdXNlbW92ZS4nICsgTkFNRVNQQUNFLCB0aGlzLl9zdG9yZU1vdXNlKTtcXG5cXHRcXHRcXHRcXHRcXHR0cmFja2luZ0JvdW5kID0gVFJVRTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gVXBkYXRlIHRoZSB0b29sdGlwIHBvc2l0aW9uIChzZXQgd2lkdGggZmlyc3QgdG8gcHJldmVudCB2aWV3cG9ydC9tYXgtd2lkdGggaXNzdWVzKVxcblxcdFxcdFxcdFxcdGlmICghd2lkdGgpIHtcXG5cXHRcXHRcXHRcXHRcXHR0b29sdGlwLmNzcygnd2lkdGgnLCB0b29sdGlwLm91dGVyV2lkdGgoRkFMU0UpKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0dGhpcy5yZXBvc2l0aW9uKGV2ZW50LCBhcmd1bWVudHNbMl0pO1xcblxcdFxcdFxcdFxcdGlmICghd2lkdGgpIHtcXG5cXHRcXHRcXHRcXHRcXHR0b29sdGlwLmNzcygnd2lkdGgnLCAnJyk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIEhpZGUgb3RoZXIgdG9vbHRpcHMgaWYgdG9vbHRpcCBpcyBzb2xvXFxuXFx0XFx0XFx0XFx0aWYgKCEhb3B0cy5zb2xvKSB7XFxuXFx0XFx0XFx0XFx0XFx0KHR5cGVvZiBvcHRzLnNvbG8gPT09ICdzdHJpbmcnID8gJChvcHRzLnNvbG8pIDogJChTRUxFQ1RPUiwgb3B0cy5zb2xvKSkubm90KHRvb2x0aXApLm5vdChvcHRzLnRhcmdldCkucXRpcCgnaGlkZScsICQuRXZlbnQoJ3Rvb2x0aXBzb2xvJykpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdC8vIENsZWFyIHNob3cgdGltZXIgaWYgd2UncmUgaGlkaW5nXFxuXFx0XFx0XFx0XFx0Y2xlYXJUaW1lb3V0KHRoaXMudGltZXJzLnNob3cpO1xcblxcblxcdFxcdFxcdFxcdC8vIFJlbW92ZSBjYWNoZWQgb3JpZ2luIG9uIGhpZGVcXG5cXHRcXHRcXHRcXHRkZWxldGUgY2FjaGUub3JpZ2luO1xcblxcblxcdFxcdFxcdFxcdC8vIFJlbW92ZSBtb3VzZSB0cmFja2luZyBldmVudCBpZiBub3QgbmVlZGVkIChhbGwgdHJhY2tpbmcgcVRpcHMgYXJlIGhpZGRlbilcXG5cXHRcXHRcXHRcXHRpZiAodHJhY2tpbmdCb3VuZCAmJiAhJChTRUxFQ1RPUiArICdbdHJhY2tpbmc9XFxcInRydWVcXFwiXTp2aXNpYmxlJywgb3B0cy5zb2xvKS5ub3QodG9vbHRpcCkubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0JChkb2N1bWVudCkudW5iaW5kKCdtb3VzZW1vdmUuJyArIE5BTUVTUEFDRSk7XFxuXFx0XFx0XFx0XFx0XFx0dHJhY2tpbmdCb3VuZCA9IEZBTFNFO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBCbHVyIHRoZSB0b29sdGlwXFxuXFx0XFx0XFx0XFx0dGhpcy5ibHVyKGV2ZW50KTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gRGVmaW5lIHBvc3QtYW5pbWF0aW9uLCBzdGF0ZSBzcGVjaWZpYyBwcm9wZXJ0aWVzXFxuXFx0XFx0XFx0YWZ0ZXIgPSAkLnByb3h5KGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRpZiAoc3RhdGUpIHtcXG5cXHRcXHRcXHRcXHRcXHQvLyBQcmV2ZW50IGFudGlhbGlhcyBmcm9tIGRpc2FwcGVhcmluZyBpbiBJRSBieSByZW1vdmluZyBmaWx0ZXJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoQlJPV1NFUi5pZSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRvb2x0aXBbMF0uc3R5bGUucmVtb3ZlQXR0cmlidXRlKCdmaWx0ZXInKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gUmVtb3ZlIG92ZXJmbG93IHNldHRpbmcgdG8gcHJldmVudCB0aXAgYnVnc1xcblxcdFxcdFxcdFxcdFxcdHRvb2x0aXAuY3NzKCdvdmVyZmxvdycsICcnKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBBdXRvZm9jdXMgZWxlbWVudHMgaWYgZW5hYmxlZFxcblxcdFxcdFxcdFxcdFxcdGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIG9wdHMuYXV0b2ZvY3VzKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0JCh0aGlzLm9wdGlvbnMuc2hvdy5hdXRvZm9jdXMsIHRvb2x0aXApLmZvY3VzKCk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdC8vIElmIHNldCwgaGlkZSB0b29sdGlwIHdoZW4gaW5hY3RpdmUgZm9yIGRlbGF5IHBlcmlvZFxcblxcdFxcdFxcdFxcdFxcdHRoaXMub3B0aW9ucy5zaG93LnRhcmdldC50cmlnZ2VyKCdxdGlwLScgKyB0aGlzLmlkICsgJy1pbmFjdGl2ZScpO1xcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gUmVzZXQgQ1NTIHN0YXRlc1xcblxcdFxcdFxcdFxcdFxcdHRvb2x0aXAuY3NzKHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRkaXNwbGF5OiAnJyxcXG5cXHRcXHRcXHRcXHRcXHRcXHR2aXNpYmlsaXR5OiAnJyxcXG5cXHRcXHRcXHRcXHRcXHRcXHRvcGFjaXR5OiAnJyxcXG5cXHRcXHRcXHRcXHRcXHRcXHRsZWZ0OiAnJyxcXG5cXHRcXHRcXHRcXHRcXHRcXHR0b3A6ICcnXFxuXFx0XFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIHRvb2x0aXB2aXNpYmxlL3Rvb2x0aXBoaWRkZW4gZXZlbnRzXFxuXFx0XFx0XFx0XFx0dGhpcy5fdHJpZ2dlcihzdGF0ZSA/ICd2aXNpYmxlJyA6ICdoaWRkZW4nKTtcXG5cXHRcXHRcXHR9LCB0aGlzKTtcXG5cXG5cXHRcXHRcXHQvLyBJZiBubyBlZmZlY3QgdHlwZSBpcyBzdXBwbGllZCwgdXNlIGEgc2ltcGxlIHRvZ2dsZVxcblxcdFxcdFxcdGlmIChvcHRzLmVmZmVjdCA9PT0gRkFMU0UgfHwgYW5pbWF0ZSA9PT0gRkFMU0UpIHtcXG5cXHRcXHRcXHRcXHR0b29sdGlwW3R5cGVdKCk7XFxuXFx0XFx0XFx0XFx0YWZ0ZXIoKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gVXNlIGN1c3RvbSBmdW5jdGlvbiBpZiBwcm92aWRlZFxcblxcdFxcdFxcdGVsc2UgaWYgKCQuaXNGdW5jdGlvbihvcHRzLmVmZmVjdCkpIHtcXG5cXHRcXHRcXHRcXHRcXHR0b29sdGlwLnN0b3AoMSwgMSk7XFxuXFx0XFx0XFx0XFx0XFx0b3B0cy5lZmZlY3QuY2FsbCh0b29sdGlwLCB0aGlzKTtcXG5cXHRcXHRcXHRcXHRcXHR0b29sdGlwLnF1ZXVlKCdmeCcsIGZ1bmN0aW9uIChuKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YWZ0ZXIoKTtuKCk7XFxuXFx0XFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIFVzZSBiYXNpYyBmYWRlIGZ1bmN0aW9uIGJ5IGRlZmF1bHRcXG5cXHRcXHRcXHRcXHRlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0b29sdGlwLmZhZGVUbyg5MCwgc3RhdGUgPyAxIDogMCwgYWZ0ZXIpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBJZiBpbmFjdGl2ZSBoaWRlIG1ldGhvZCBpcyBzZXQsIGFjdGl2ZSBpdFxcblxcdFxcdFxcdGlmIChzdGF0ZSkge1xcblxcdFxcdFxcdFxcdG9wdHMudGFyZ2V0LnRyaWdnZXIoJ3F0aXAtJyArIHRoaXMuaWQgKyAnLWluYWN0aXZlJyk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcdFxcdH07XFxuXFxuXFx0XFx0UFJPVE9UWVBFLnNob3cgPSBmdW5jdGlvbiAoZXZlbnQpIHtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy50b2dnbGUoVFJVRSwgZXZlbnQpO1xcblxcdFxcdH07XFxuXFxuXFx0XFx0UFJPVE9UWVBFLmhpZGUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy50b2dnbGUoRkFMU0UsIGV2ZW50KTtcXG5cXHRcXHR9O1xcblxcdFxcdDtQUk9UT1RZUEUuZm9jdXMgPSBmdW5jdGlvbiAoZXZlbnQpIHtcXG5cXHRcXHRcXHRpZiAoIXRoaXMucmVuZGVyZWQgfHwgdGhpcy5kZXN0cm95ZWQpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dmFyIHF0aXBzID0gJChTRUxFQ1RPUiksXFxuXFx0XFx0XFx0ICAgIHRvb2x0aXAgPSB0aGlzLnRvb2x0aXAsXFxuXFx0XFx0XFx0ICAgIGN1ckluZGV4ID0gcGFyc2VJbnQodG9vbHRpcFswXS5zdHlsZS56SW5kZXgsIDEwKSxcXG5cXHRcXHRcXHQgICAgbmV3SW5kZXggPSBRVElQLnppbmRleCArIHF0aXBzLmxlbmd0aCxcXG5cXHRcXHRcXHQgICAgZm9jdXNlZEVsZW07XFxuXFxuXFx0XFx0XFx0Ly8gT25seSB1cGRhdGUgdGhlIHotaW5kZXggaWYgaXQgaGFzIGNoYW5nZWQgYW5kIHRvb2x0aXAgaXMgbm90IGFscmVhZHkgZm9jdXNlZFxcblxcdFxcdFxcdGlmICghdG9vbHRpcC5oYXNDbGFzcyhDTEFTU19GT0NVUykpIHtcXG5cXHRcXHRcXHRcXHQvLyB0b29sdGlwZm9jdXMgZXZlbnRcXG5cXHRcXHRcXHRcXHRpZiAodGhpcy5fdHJpZ2dlcignZm9jdXMnLCBbbmV3SW5kZXhdLCBldmVudCkpIHtcXG5cXHRcXHRcXHRcXHRcXHQvLyBPbmx5IHVwZGF0ZSB6LWluZGV4J3MgaWYgdGhleSd2ZSBjaGFuZ2VkXFxuXFx0XFx0XFx0XFx0XFx0aWYgKGN1ckluZGV4ICE9PSBuZXdJbmRleCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdC8vIFJlZHVjZSBvdXIgei1pbmRleCdzIGFuZCBrZWVwIHRoZW0gcHJvcGVybHkgb3JkZXJlZFxcblxcdFxcdFxcdFxcdFxcdFxcdHF0aXBzLmVhY2goZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICh0aGlzLnN0eWxlLnpJbmRleCA+IGN1ckluZGV4KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5zdHlsZS56SW5kZXggPSB0aGlzLnN0eWxlLnpJbmRleCAtIDE7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH0pO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIEZpcmUgYmx1ciBldmVudCBmb3IgZm9jdXNlZCB0b29sdGlwXFxuXFx0XFx0XFx0XFx0XFx0XFx0cXRpcHMuZmlsdGVyKCcuJyArIENMQVNTX0ZPQ1VTKS5xdGlwKCdibHVyJywgZXZlbnQpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBTZXQgdGhlIG5ldyB6LWluZGV4XFxuXFx0XFx0XFx0XFx0XFx0dG9vbHRpcC5hZGRDbGFzcyhDTEFTU19GT0NVUylbMF0uc3R5bGUuekluZGV4ID0gbmV3SW5kZXg7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXHRcXHR9O1xcblxcblxcdFxcdFBST1RPVFlQRS5ibHVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XFxuXFx0XFx0XFx0aWYgKCF0aGlzLnJlbmRlcmVkIHx8IHRoaXMuZGVzdHJveWVkKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFNldCBmb2N1c2VkIHN0YXR1cyB0byBGQUxTRVxcblxcdFxcdFxcdHRoaXMudG9vbHRpcC5yZW1vdmVDbGFzcyhDTEFTU19GT0NVUyk7XFxuXFxuXFx0XFx0XFx0Ly8gdG9vbHRpcGJsdXIgZXZlbnRcXG5cXHRcXHRcXHR0aGlzLl90cmlnZ2VyKCdibHVyJywgW3RoaXMudG9vbHRpcC5jc3MoJ3pJbmRleCcpXSwgZXZlbnQpO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcdFxcdH07XFxuXFx0XFx0O1BST1RPVFlQRS5kaXNhYmxlID0gZnVuY3Rpb24gKHN0YXRlKSB7XFxuXFx0XFx0XFx0aWYgKHRoaXMuZGVzdHJveWVkKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIElmICd0b2dnbGUnIGlzIHBhc3NlZCwgdG9nZ2xlIHRoZSBjdXJyZW50IHN0YXRlXFxuXFx0XFx0XFx0aWYgKHN0YXRlID09PSAndG9nZ2xlJykge1xcblxcdFxcdFxcdFxcdHN0YXRlID0gISh0aGlzLnJlbmRlcmVkID8gdGhpcy50b29sdGlwLmhhc0NsYXNzKENMQVNTX0RJU0FCTEVEKSA6IHRoaXMuZGlzYWJsZWQpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBEaXNhYmxlIGlmIG5vIHN0YXRlIHBhc3NlZFxcblxcdFxcdFxcdGVsc2UgaWYgKCdib29sZWFuJyAhPT0gdHlwZW9mIHN0YXRlKSB7XFxuXFx0XFx0XFx0XFx0XFx0c3RhdGUgPSBUUlVFO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAodGhpcy5yZW5kZXJlZCkge1xcblxcdFxcdFxcdFxcdHRoaXMudG9vbHRpcC50b2dnbGVDbGFzcyhDTEFTU19ESVNBQkxFRCwgc3RhdGUpLmF0dHIoJ2FyaWEtZGlzYWJsZWQnLCBzdGF0ZSk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMuZGlzYWJsZWQgPSAhIXN0YXRlO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcdFxcdH07XFxuXFxuXFx0XFx0UFJPVE9UWVBFLmVuYWJsZSA9IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5kaXNhYmxlKEZBTFNFKTtcXG5cXHRcXHR9O1xcblxcdFxcdDtQUk9UT1RZUEUuX2NyZWF0ZUJ1dHRvbiA9IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHR2YXIgc2VsZiA9IHRoaXMsXFxuXFx0XFx0XFx0ICAgIGVsZW1lbnRzID0gdGhpcy5lbGVtZW50cyxcXG5cXHRcXHRcXHQgICAgdG9vbHRpcCA9IGVsZW1lbnRzLnRvb2x0aXAsXFxuXFx0XFx0XFx0ICAgIGJ1dHRvbiA9IHRoaXMub3B0aW9ucy5jb250ZW50LmJ1dHRvbixcXG5cXHRcXHRcXHQgICAgaXNTdHJpbmcgPSB0eXBlb2YgYnV0dG9uID09PSAnc3RyaW5nJyxcXG5cXHRcXHRcXHQgICAgY2xvc2UgPSBpc1N0cmluZyA/IGJ1dHRvbiA6ICdDbG9zZSB0b29sdGlwJztcXG5cXG5cXHRcXHRcXHRpZiAoZWxlbWVudHMuYnV0dG9uKSB7XFxuXFx0XFx0XFx0XFx0ZWxlbWVudHMuYnV0dG9uLnJlbW92ZSgpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBVc2UgY3VzdG9tIGJ1dHRvbiBpZiBvbmUgd2FzIHN1cHBsaWVkIGJ5IHVzZXIsIGVsc2UgdXNlIGRlZmF1bHRcXG5cXHRcXHRcXHRpZiAoYnV0dG9uLmpxdWVyeSkge1xcblxcdFxcdFxcdFxcdGVsZW1lbnRzLmJ1dHRvbiA9IGJ1dHRvbjtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdGVsZW1lbnRzLmJ1dHRvbiA9ICQoJzxhIC8+Jywge1xcblxcdFxcdFxcdFxcdFxcdCdjbGFzcyc6ICdxdGlwLWNsb3NlICcgKyAodGhpcy5vcHRpb25zLnN0eWxlLndpZGdldCA/ICcnIDogTkFNRVNQQUNFICsgJy1pY29uJyksXFxuXFx0XFx0XFx0XFx0XFx0J3RpdGxlJzogY2xvc2UsXFxuXFx0XFx0XFx0XFx0XFx0J2FyaWEtbGFiZWwnOiBjbG9zZVxcblxcdFxcdFxcdFxcdH0pLnByZXBlbmQoJCgnPHNwYW4gLz4nLCB7XFxuXFx0XFx0XFx0XFx0XFx0J2NsYXNzJzogJ3VpLWljb24gdWktaWNvbi1jbG9zZScsXFxuXFx0XFx0XFx0XFx0XFx0J2h0bWwnOiAnJnRpbWVzOydcXG5cXHRcXHRcXHRcXHR9KSk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIENyZWF0ZSBidXR0b24gYW5kIHNldHVwIGF0dHJpYnV0ZXNcXG5cXHRcXHRcXHRlbGVtZW50cy5idXR0b24uYXBwZW5kVG8oZWxlbWVudHMudGl0bGViYXIgfHwgdG9vbHRpcCkuYXR0cigncm9sZScsICdidXR0b24nKS5jbGljayhmdW5jdGlvbiAoZXZlbnQpIHtcXG5cXHRcXHRcXHRcXHRpZiAoIXRvb2x0aXAuaGFzQ2xhc3MoQ0xBU1NfRElTQUJMRUQpKSB7XFxuXFx0XFx0XFx0XFx0XFx0c2VsZi5oaWRlKGV2ZW50KTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0cmV0dXJuIEZBTFNFO1xcblxcdFxcdFxcdH0pO1xcblxcdFxcdH07XFxuXFxuXFx0XFx0UFJPVE9UWVBFLl91cGRhdGVCdXR0b24gPSBmdW5jdGlvbiAoYnV0dG9uKSB7XFxuXFx0XFx0XFx0Ly8gTWFrZSBzdXJlIHRvb2x0aXAgaXMgcmVuZGVyZWQgYW5kIGlmIG5vdCwgcmV0dXJuXFxuXFx0XFx0XFx0aWYgKCF0aGlzLnJlbmRlcmVkKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIEZBTFNFO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2YXIgZWxlbSA9IHRoaXMuZWxlbWVudHMuYnV0dG9uO1xcblxcdFxcdFxcdGlmIChidXR0b24pIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9jcmVhdGVCdXR0b24oKTtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdGVsZW0ucmVtb3ZlKCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH07XFxuXFx0XFx0OyAvLyBXaWRnZXQgY2xhc3MgY3JlYXRvclxcblxcdFxcdGZ1bmN0aW9uIGNyZWF0ZVdpZGdldENsYXNzKGNscykge1xcblxcdFxcdFxcdHJldHVybiBXSURHRVQuY29uY2F0KCcnKS5qb2luKGNscyA/ICctJyArIGNscyArICcgJyA6ICcgJyk7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFdpZGdldCBjbGFzcyBzZXR0ZXIgbWV0aG9kXFxuXFx0XFx0UFJPVE9UWVBFLl9zZXRXaWRnZXQgPSBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0dmFyIG9uID0gdGhpcy5vcHRpb25zLnN0eWxlLndpZGdldCxcXG5cXHRcXHRcXHQgICAgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzLFxcblxcdFxcdFxcdCAgICB0b29sdGlwID0gZWxlbWVudHMudG9vbHRpcCxcXG5cXHRcXHRcXHQgICAgZGlzYWJsZWQgPSB0b29sdGlwLmhhc0NsYXNzKENMQVNTX0RJU0FCTEVEKTtcXG5cXG5cXHRcXHRcXHR0b29sdGlwLnJlbW92ZUNsYXNzKENMQVNTX0RJU0FCTEVEKTtcXG5cXHRcXHRcXHRDTEFTU19ESVNBQkxFRCA9IG9uID8gJ3VpLXN0YXRlLWRpc2FibGVkJyA6ICdxdGlwLWRpc2FibGVkJztcXG5cXHRcXHRcXHR0b29sdGlwLnRvZ2dsZUNsYXNzKENMQVNTX0RJU0FCTEVELCBkaXNhYmxlZCk7XFxuXFxuXFx0XFx0XFx0dG9vbHRpcC50b2dnbGVDbGFzcygndWktaGVscGVyLXJlc2V0ICcgKyBjcmVhdGVXaWRnZXRDbGFzcygpLCBvbikudG9nZ2xlQ2xhc3MoQ0xBU1NfREVGQVVMVCwgdGhpcy5vcHRpb25zLnN0eWxlLmRlZiAmJiAhb24pO1xcblxcblxcdFxcdFxcdGlmIChlbGVtZW50cy5jb250ZW50KSB7XFxuXFx0XFx0XFx0XFx0ZWxlbWVudHMuY29udGVudC50b2dnbGVDbGFzcyhjcmVhdGVXaWRnZXRDbGFzcygnY29udGVudCcpLCBvbik7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmIChlbGVtZW50cy50aXRsZWJhcikge1xcblxcdFxcdFxcdFxcdGVsZW1lbnRzLnRpdGxlYmFyLnRvZ2dsZUNsYXNzKGNyZWF0ZVdpZGdldENsYXNzKCdoZWFkZXInKSwgb24pO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoZWxlbWVudHMuYnV0dG9uKSB7XFxuXFx0XFx0XFx0XFx0ZWxlbWVudHMuYnV0dG9uLnRvZ2dsZUNsYXNzKE5BTUVTUEFDRSArICctaWNvbicsICFvbik7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH07XFxuXFx0XFx0O2Z1bmN0aW9uIGRlbGF5KGNhbGxiYWNrLCBkdXJhdGlvbikge1xcblxcdFxcdFxcdC8vIElmIHRvb2x0aXAgaGFzIGRpc3BsYXllZCwgc3RhcnQgaGlkZSB0aW1lclxcblxcdFxcdFxcdGlmIChkdXJhdGlvbiA+IDApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gc2V0VGltZW91dCgkLnByb3h5KGNhbGxiYWNrLCB0aGlzKSwgZHVyYXRpb24pO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0Y2FsbGJhY2suY2FsbCh0aGlzKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIHNob3dNZXRob2QoZXZlbnQpIHtcXG5cXHRcXHRcXHRpZiAodGhpcy50b29sdGlwLmhhc0NsYXNzKENMQVNTX0RJU0FCTEVEKSkge1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gQ2xlYXIgaGlkZSB0aW1lcnNcXG5cXHRcXHRcXHRjbGVhclRpbWVvdXQodGhpcy50aW1lcnMuc2hvdyk7XFxuXFx0XFx0XFx0Y2xlYXJUaW1lb3V0KHRoaXMudGltZXJzLmhpZGUpO1xcblxcblxcdFxcdFxcdC8vIFN0YXJ0IHNob3cgdGltZXJcXG5cXHRcXHRcXHR0aGlzLnRpbWVycy5zaG93ID0gZGVsYXkuY2FsbCh0aGlzLCBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy50b2dnbGUoVFJVRSwgZXZlbnQpO1xcblxcdFxcdFxcdH0sIHRoaXMub3B0aW9ucy5zaG93LmRlbGF5KTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gaGlkZU1ldGhvZChldmVudCkge1xcblxcdFxcdFxcdGlmICh0aGlzLnRvb2x0aXAuaGFzQ2xhc3MoQ0xBU1NfRElTQUJMRUQpIHx8IHRoaXMuZGVzdHJveWVkKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBDaGVjayBpZiBuZXcgdGFyZ2V0IHdhcyBhY3R1YWxseSB0aGUgdG9vbHRpcCBlbGVtZW50XFxuXFx0XFx0XFx0dmFyIHJlbGF0ZWRUYXJnZXQgPSAkKGV2ZW50LnJlbGF0ZWRUYXJnZXQpLFxcblxcdFxcdFxcdCAgICBvbnRvVG9vbHRpcCA9IHJlbGF0ZWRUYXJnZXQuY2xvc2VzdChTRUxFQ1RPUilbMF0gPT09IHRoaXMudG9vbHRpcFswXSxcXG5cXHRcXHRcXHQgICAgb250b1RhcmdldCA9IHJlbGF0ZWRUYXJnZXRbMF0gPT09IHRoaXMub3B0aW9ucy5zaG93LnRhcmdldFswXTtcXG5cXG5cXHRcXHRcXHQvLyBDbGVhciB0aW1lcnMgYW5kIHN0b3AgYW5pbWF0aW9uIHF1ZXVlXFxuXFx0XFx0XFx0Y2xlYXJUaW1lb3V0KHRoaXMudGltZXJzLnNob3cpO1xcblxcdFxcdFxcdGNsZWFyVGltZW91dCh0aGlzLnRpbWVycy5oaWRlKTtcXG5cXG5cXHRcXHRcXHQvLyBQcmV2ZW50IGhpZGluZyBpZiB0b29sdGlwIGlzIGZpeGVkIGFuZCBldmVudCB0YXJnZXQgaXMgdGhlIHRvb2x0aXAuXFxuXFx0XFx0XFx0Ly8gT3IgaWYgbW91c2UgcG9zaXRpb25pbmcgaXMgZW5hYmxlZCBhbmQgY3Vyc29yIG1vbWVudGFyaWx5IG92ZXJsYXBzXFxuXFx0XFx0XFx0aWYgKHRoaXMgIT09IHJlbGF0ZWRUYXJnZXRbMF0gJiYgdGhpcy5vcHRpb25zLnBvc2l0aW9uLnRhcmdldCA9PT0gJ21vdXNlJyAmJiBvbnRvVG9vbHRpcCB8fCB0aGlzLm9wdGlvbnMuaGlkZS5maXhlZCAmJiAvbW91c2Uob3V0fGxlYXZlfG1vdmUpLy50ZXN0KGV2ZW50LnR5cGUpICYmIChvbnRvVG9vbHRpcCB8fCBvbnRvVGFyZ2V0KSkge1xcblxcdFxcdFxcdFxcdHRyeSB7XFxuXFx0XFx0XFx0XFx0XFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG5cXHRcXHRcXHRcXHRcXHRldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcXG5cXHRcXHRcXHRcXHR9IGNhdGNoIChlKSB7fVxcblxcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gSWYgdG9vbHRpcCBoYXMgZGlzcGxheWVkLCBzdGFydCBoaWRlIHRpbWVyXFxuXFx0XFx0XFx0dGhpcy50aW1lcnMuaGlkZSA9IGRlbGF5LmNhbGwodGhpcywgZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdHRoaXMudG9nZ2xlKEZBTFNFLCBldmVudCk7XFxuXFx0XFx0XFx0fSwgdGhpcy5vcHRpb25zLmhpZGUuZGVsYXksIHRoaXMpO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiBpbmFjdGl2ZU1ldGhvZChldmVudCkge1xcblxcdFxcdFxcdGlmICh0aGlzLnRvb2x0aXAuaGFzQ2xhc3MoQ0xBU1NfRElTQUJMRUQpIHx8ICF0aGlzLm9wdGlvbnMuaGlkZS5pbmFjdGl2ZSkge1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gQ2xlYXIgdGltZXJcXG5cXHRcXHRcXHRjbGVhclRpbWVvdXQodGhpcy50aW1lcnMuaW5hY3RpdmUpO1xcblxcblxcdFxcdFxcdHRoaXMudGltZXJzLmluYWN0aXZlID0gZGVsYXkuY2FsbCh0aGlzLCBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5oaWRlKGV2ZW50KTtcXG5cXHRcXHRcXHR9LCB0aGlzLm9wdGlvbnMuaGlkZS5pbmFjdGl2ZSk7XFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIHJlcG9zaXRpb25NZXRob2QoZXZlbnQpIHtcXG5cXHRcXHRcXHRpZiAodGhpcy5yZW5kZXJlZCAmJiB0aGlzLnRvb2x0aXBbMF0ub2Zmc2V0V2lkdGggPiAwKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5yZXBvc2l0aW9uKGV2ZW50KTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFN0b3JlIG1vdXNlIGNvb3JkaW5hdGVzXFxuXFx0XFx0UFJPVE9UWVBFLl9zdG9yZU1vdXNlID0gZnVuY3Rpb24gKGV2ZW50KSB7XFxuXFx0XFx0XFx0KHRoaXMubW91c2UgPSAkLmV2ZW50LmZpeChldmVudCkpLnR5cGUgPSAnbW91c2Vtb3ZlJztcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXHRcXHR9O1xcblxcblxcdFxcdC8vIEJpbmQgZXZlbnRzXFxuXFx0XFx0UFJPVE9UWVBFLl9iaW5kID0gZnVuY3Rpb24gKHRhcmdldHMsIGV2ZW50cywgbWV0aG9kLCBzdWZmaXgsIGNvbnRleHQpIHtcXG5cXHRcXHRcXHRpZiAoIXRhcmdldHMgfHwgIW1ldGhvZCB8fCAhZXZlbnRzLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0dmFyIG5zID0gJy4nICsgdGhpcy5faWQgKyAoc3VmZml4ID8gJy0nICsgc3VmZml4IDogJycpO1xcblxcdFxcdFxcdCQodGFyZ2V0cykuYmluZCgoZXZlbnRzLnNwbGl0ID8gZXZlbnRzIDogZXZlbnRzLmpvaW4obnMgKyAnICcpKSArIG5zLCAkLnByb3h5KG1ldGhvZCwgY29udGV4dCB8fCB0aGlzKSk7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0XFx0fTtcXG5cXHRcXHRQUk9UT1RZUEUuX3VuYmluZCA9IGZ1bmN0aW9uICh0YXJnZXRzLCBzdWZmaXgpIHtcXG5cXHRcXHRcXHR0YXJnZXRzICYmICQodGFyZ2V0cykudW5iaW5kKCcuJyArIHRoaXMuX2lkICsgKHN1ZmZpeCA/ICctJyArIHN1ZmZpeCA6ICcnKSk7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0XFx0fTtcXG5cXG5cXHRcXHQvLyBHbG9iYWwgZGVsZWdhdGlvbiBoZWxwZXJcXG5cXHRcXHRmdW5jdGlvbiBkZWxlZ2F0ZShzZWxlY3RvciwgZXZlbnRzLCBtZXRob2QpIHtcXG5cXHRcXHRcXHQkKGRvY3VtZW50LmJvZHkpLmRlbGVnYXRlKHNlbGVjdG9yLCAoZXZlbnRzLnNwbGl0ID8gZXZlbnRzIDogZXZlbnRzLmpvaW4oJy4nICsgTkFNRVNQQUNFICsgJyAnKSkgKyAnLicgKyBOQU1FU1BBQ0UsIGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHR2YXIgYXBpID0gUVRJUC5hcGlbJC5hdHRyKHRoaXMsIEFUVFJfSUQpXTtcXG5cXHRcXHRcXHRcXHRhcGkgJiYgIWFwaS5kaXNhYmxlZCAmJiBtZXRob2QuYXBwbHkoYXBpLCBhcmd1bWVudHMpO1xcblxcdFxcdFxcdH0pO1xcblxcdFxcdH1cXG5cXHRcXHQvLyBFdmVudCB0cmlnZ2VyXFxuXFx0XFx0UFJPVE9UWVBFLl90cmlnZ2VyID0gZnVuY3Rpb24gKHR5cGUsIGFyZ3MsIGV2ZW50KSB7XFxuXFx0XFx0XFx0dmFyIGNhbGxiYWNrID0gJC5FdmVudCgndG9vbHRpcCcgKyB0eXBlKTtcXG5cXHRcXHRcXHRjYWxsYmFjay5vcmlnaW5hbEV2ZW50ID0gZXZlbnQgJiYgJC5leHRlbmQoe30sIGV2ZW50KSB8fCB0aGlzLmNhY2hlLmV2ZW50IHx8IE5VTEw7XFxuXFxuXFx0XFx0XFx0dGhpcy50cmlnZ2VyaW5nID0gdHlwZTtcXG5cXHRcXHRcXHR0aGlzLnRvb2x0aXAudHJpZ2dlcihjYWxsYmFjaywgW3RoaXNdLmNvbmNhdChhcmdzIHx8IFtdKSk7XFxuXFx0XFx0XFx0dGhpcy50cmlnZ2VyaW5nID0gRkFMU0U7XFxuXFxuXFx0XFx0XFx0cmV0dXJuICFjYWxsYmFjay5pc0RlZmF1bHRQcmV2ZW50ZWQoKTtcXG5cXHRcXHR9O1xcblxcblxcdFxcdFBST1RPVFlQRS5fYmluZEV2ZW50cyA9IGZ1bmN0aW9uIChzaG93RXZlbnRzLCBoaWRlRXZlbnRzLCBzaG93VGFyZ2V0cywgaGlkZVRhcmdldHMsIHNob3dNZXRob2QsIGhpZGVNZXRob2QpIHtcXG5cXHRcXHRcXHQvLyBHZXQgdGFzcmdldHMgdGhhdCBseWUgd2l0aGluIGJvdGhcXG5cXHRcXHRcXHR2YXIgc2ltaWxhclRhcmdldHMgPSBzaG93VGFyZ2V0cy5maWx0ZXIoaGlkZVRhcmdldHMpLmFkZChoaWRlVGFyZ2V0cy5maWx0ZXIoc2hvd1RhcmdldHMpKSxcXG5cXHRcXHRcXHQgICAgdG9nZ2xlRXZlbnRzID0gW107XFxuXFxuXFx0XFx0XFx0Ly8gSWYgaGlkZSBhbmQgc2hvdyB0YXJnZXRzIGFyZSB0aGUgc2FtZS4uLlxcblxcdFxcdFxcdGlmIChzaW1pbGFyVGFyZ2V0cy5sZW5ndGgpIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBGaWx0ZXIgaWRlbnRpY2FsIHNob3cvaGlkZSBldmVudHNcXG5cXHRcXHRcXHRcXHQkLmVhY2goaGlkZUV2ZW50cywgZnVuY3Rpb24gKGksIHR5cGUpIHtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgc2hvd0luZGV4ID0gJC5pbkFycmF5KHR5cGUsIHNob3dFdmVudHMpO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIEJvdGggZXZlbnRzIGFyZSBpZGVudGljYWwsIHJlbW92ZSBmcm9tIGJvdGggaGlkZSBhbmQgc2hvdyBldmVudHNcXG5cXHRcXHRcXHRcXHRcXHQvLyBhbmQgYXBwZW5kIHRvIHRvZ2dsZUV2ZW50c1xcblxcdFxcdFxcdFxcdFxcdHNob3dJbmRleCA+IC0xICYmIHRvZ2dsZUV2ZW50cy5wdXNoKHNob3dFdmVudHMuc3BsaWNlKHNob3dJbmRleCwgMSlbMF0pO1xcblxcdFxcdFxcdFxcdH0pO1xcblxcblxcdFxcdFxcdFxcdC8vIFRvZ2dsZSBldmVudHMgYXJlIHNwZWNpYWwgY2FzZSBvZiBpZGVudGljYWwgc2hvdy9oaWRlIGV2ZW50cywgd2hpY2ggaGFwcGVuIGluIHNlcXVlbmNlXFxuXFx0XFx0XFx0XFx0aWYgKHRvZ2dsZUV2ZW50cy5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRcXHQvLyBCaW5kIHRvZ2dsZSBldmVudHMgdG8gdGhlIHNpbWlsYXIgdGFyZ2V0c1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX2JpbmQoc2ltaWxhclRhcmdldHMsIHRvZ2dsZUV2ZW50cywgZnVuY3Rpb24gKGV2ZW50KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIHN0YXRlID0gdGhpcy5yZW5kZXJlZCA/IHRoaXMudG9vbHRpcFswXS5vZmZzZXRXaWR0aCA+IDAgOiBmYWxzZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHQoc3RhdGUgPyBoaWRlTWV0aG9kIDogc2hvd01ldGhvZCkuY2FsbCh0aGlzLCBldmVudCk7XFxuXFx0XFx0XFx0XFx0XFx0fSk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gUmVtb3ZlIHRoZSBzaW1pbGFyIHRhcmdldHMgZnJvbSB0aGUgcmVndWxhciBzaG93L2hpZGUgYmluZGluZ3NcXG5cXHRcXHRcXHRcXHRcXHRzaG93VGFyZ2V0cyA9IHNob3dUYXJnZXRzLm5vdChzaW1pbGFyVGFyZ2V0cyk7XFxuXFx0XFx0XFx0XFx0XFx0aGlkZVRhcmdldHMgPSBoaWRlVGFyZ2V0cy5ub3Qoc2ltaWxhclRhcmdldHMpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gQXBwbHkgc2hvdy9oaWRlL3RvZ2dsZSBldmVudHNcXG5cXHRcXHRcXHR0aGlzLl9iaW5kKHNob3dUYXJnZXRzLCBzaG93RXZlbnRzLCBzaG93TWV0aG9kKTtcXG5cXHRcXHRcXHR0aGlzLl9iaW5kKGhpZGVUYXJnZXRzLCBoaWRlRXZlbnRzLCBoaWRlTWV0aG9kKTtcXG5cXHRcXHR9O1xcblxcblxcdFxcdFBST1RPVFlQRS5fYXNzaWduSW5pdGlhbEV2ZW50cyA9IGZ1bmN0aW9uIChldmVudCkge1xcblxcdFxcdFxcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxcblxcdFxcdFxcdCAgICBzaG93VGFyZ2V0ID0gb3B0aW9ucy5zaG93LnRhcmdldCxcXG5cXHRcXHRcXHQgICAgaGlkZVRhcmdldCA9IG9wdGlvbnMuaGlkZS50YXJnZXQsXFxuXFx0XFx0XFx0ICAgIHNob3dFdmVudHMgPSBvcHRpb25zLnNob3cuZXZlbnQgPyAkLnRyaW0oJycgKyBvcHRpb25zLnNob3cuZXZlbnQpLnNwbGl0KCcgJykgOiBbXSxcXG5cXHRcXHRcXHQgICAgaGlkZUV2ZW50cyA9IG9wdGlvbnMuaGlkZS5ldmVudCA/ICQudHJpbSgnJyArIG9wdGlvbnMuaGlkZS5ldmVudCkuc3BsaXQoJyAnKSA6IFtdO1xcblxcblxcdFxcdFxcdC8vIENhdGNoIHJlbW92ZS9yZW1vdmVxdGlwIGV2ZW50cyBvbiB0YXJnZXQgZWxlbWVudCB0byBkZXN0cm95IHJlZHVuZGFudCB0b29sdGlwc1xcblxcdFxcdFxcdHRoaXMuX2JpbmQodGhpcy5lbGVtZW50cy50YXJnZXQsIFsncmVtb3ZlJywgJ3JlbW92ZXF0aXAnXSwgZnVuY3Rpb24gKGV2ZW50KSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5kZXN0cm95KHRydWUpO1xcblxcdFxcdFxcdH0sICdkZXN0cm95Jyk7XFxuXFxuXFx0XFx0XFx0LypcXG4gICAgKiBNYWtlIHN1cmUgaG92ZXJJbnRlbnQgZnVuY3Rpb25zIHByb3Blcmx5IGJ5IHVzaW5nIG1vdXNlbGVhdmUgYXMgYSBoaWRlIGV2ZW50IGlmXFxuICAgICogbW91c2VlbnRlci9tb3VzZW91dCBpcyB1c2VkIGZvciBzaG93LmV2ZW50LCBldmVuIGlmIGl0IGlzbid0IGluIHRoZSB1c2VycyBvcHRpb25zLlxcbiAgICAqL1xcblxcdFxcdFxcdGlmICgvbW91c2Uob3ZlcnxlbnRlcikvaS50ZXN0KG9wdGlvbnMuc2hvdy5ldmVudCkgJiYgIS9tb3VzZShvdXR8bGVhdmUpL2kudGVzdChvcHRpb25zLmhpZGUuZXZlbnQpKSB7XFxuXFx0XFx0XFx0XFx0aGlkZUV2ZW50cy5wdXNoKCdtb3VzZWxlYXZlJyk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8qXFxuICAgICogQWxzbyBtYWtlIHN1cmUgaW5pdGlhbCBtb3VzZSB0YXJnZXR0aW5nIHdvcmtzIGNvcnJlY3RseSBieSBjYWNoaW5nIG1vdXNlbW92ZSBjb29yZHNcXG4gICAgKiBvbiBzaG93IHRhcmdldHMgYmVmb3JlIHRoZSB0b29sdGlwIGhhcyByZW5kZXJlZC4gQWxzbyBzZXQgb25UYXJnZXQgd2hlbiB0cmlnZ2VyZWQgdG9cXG4gICAgKiBrZWVwIG1vdXNlIHRyYWNraW5nIHdvcmtpbmcuXFxuICAgICovXFxuXFx0XFx0XFx0dGhpcy5fYmluZChzaG93VGFyZ2V0LCAnbW91c2Vtb3ZlJywgZnVuY3Rpb24gKGV2ZW50KSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5fc3RvcmVNb3VzZShldmVudCk7XFxuXFx0XFx0XFx0XFx0dGhpcy5jYWNoZS5vblRhcmdldCA9IFRSVUU7XFxuXFx0XFx0XFx0fSk7XFxuXFxuXFx0XFx0XFx0Ly8gRGVmaW5lIGhvdmVySW50ZW50IGZ1bmN0aW9uXFxuXFx0XFx0XFx0ZnVuY3Rpb24gaG92ZXJJbnRlbnQoZXZlbnQpIHtcXG5cXHRcXHRcXHRcXHQvLyBPbmx5IGNvbnRpbnVlIGlmIHRvb2x0aXAgaXNuJ3QgZGlzYWJsZWRcXG5cXHRcXHRcXHRcXHRpZiAodGhpcy5kaXNhYmxlZCB8fCB0aGlzLmRlc3Ryb3llZCkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBGQUxTRTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQ2FjaGUgdGhlIGV2ZW50IGRhdGFcXG5cXHRcXHRcXHRcXHR0aGlzLmNhY2hlLmV2ZW50ID0gZXZlbnQgJiYgJC5ldmVudC5maXgoZXZlbnQpO1xcblxcdFxcdFxcdFxcdHRoaXMuY2FjaGUudGFyZ2V0ID0gZXZlbnQgJiYgJChldmVudC50YXJnZXQpO1xcblxcblxcdFxcdFxcdFxcdC8vIFN0YXJ0IHRoZSBldmVudCBzZXF1ZW5jZVxcblxcdFxcdFxcdFxcdGNsZWFyVGltZW91dCh0aGlzLnRpbWVycy5zaG93KTtcXG5cXHRcXHRcXHRcXHR0aGlzLnRpbWVycy5zaG93ID0gZGVsYXkuY2FsbCh0aGlzLCBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5yZW5kZXIoKHR5cGVvZiBldmVudCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoZXZlbnQpKSA9PT0gJ29iamVjdCcgfHwgb3B0aW9ucy5zaG93LnJlYWR5KTtcXG5cXHRcXHRcXHRcXHR9LCBvcHRpb25zLnByZXJlbmRlciA/IDAgOiBvcHRpb25zLnNob3cuZGVsYXkpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBGaWx0ZXIgYW5kIGJpbmQgZXZlbnRzXFxuXFx0XFx0XFx0dGhpcy5fYmluZEV2ZW50cyhzaG93RXZlbnRzLCBoaWRlRXZlbnRzLCBzaG93VGFyZ2V0LCBoaWRlVGFyZ2V0LCBob3ZlckludGVudCwgZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdGlmICghdGhpcy50aW1lcnMpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gRkFMU0U7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGNsZWFyVGltZW91dCh0aGlzLnRpbWVycy5zaG93KTtcXG5cXHRcXHRcXHR9KTtcXG5cXG5cXHRcXHRcXHQvLyBQcmVyZW5kZXJpbmcgaXMgZW5hYmxlZCwgY3JlYXRlIHRvb2x0aXAgbm93XFxuXFx0XFx0XFx0aWYgKG9wdGlvbnMuc2hvdy5yZWFkeSB8fCBvcHRpb25zLnByZXJlbmRlcikge1xcblxcdFxcdFxcdFxcdGhvdmVySW50ZW50LmNhbGwodGhpcywgZXZlbnQpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9O1xcblxcblxcdFxcdC8vIEV2ZW50IGFzc2lnbm1lbnQgbWV0aG9kXFxuXFx0XFx0UFJPVE9UWVBFLl9hc3NpZ25FdmVudHMgPSBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0dmFyIHNlbGYgPSB0aGlzLFxcblxcdFxcdFxcdCAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxcblxcdFxcdFxcdCAgICBwb3NPcHRpb25zID0gb3B0aW9ucy5wb3NpdGlvbixcXG5cXHRcXHRcXHQgICAgdG9vbHRpcCA9IHRoaXMudG9vbHRpcCxcXG5cXHRcXHRcXHQgICAgc2hvd1RhcmdldCA9IG9wdGlvbnMuc2hvdy50YXJnZXQsXFxuXFx0XFx0XFx0ICAgIGhpZGVUYXJnZXQgPSBvcHRpb25zLmhpZGUudGFyZ2V0LFxcblxcdFxcdFxcdCAgICBjb250YWluZXJUYXJnZXQgPSBwb3NPcHRpb25zLmNvbnRhaW5lcixcXG5cXHRcXHRcXHQgICAgdmlld3BvcnRUYXJnZXQgPSBwb3NPcHRpb25zLnZpZXdwb3J0LFxcblxcdFxcdFxcdCAgICBkb2N1bWVudFRhcmdldCA9ICQoZG9jdW1lbnQpLFxcblxcdFxcdFxcdCAgICBib2R5VGFyZ2V0ID0gJChkb2N1bWVudC5ib2R5KSxcXG5cXHRcXHRcXHQgICAgd2luZG93VGFyZ2V0ID0gJCh3aW5kb3cpLFxcblxcdFxcdFxcdCAgICBzaG93RXZlbnRzID0gb3B0aW9ucy5zaG93LmV2ZW50ID8gJC50cmltKCcnICsgb3B0aW9ucy5zaG93LmV2ZW50KS5zcGxpdCgnICcpIDogW10sXFxuXFx0XFx0XFx0ICAgIGhpZGVFdmVudHMgPSBvcHRpb25zLmhpZGUuZXZlbnQgPyAkLnRyaW0oJycgKyBvcHRpb25zLmhpZGUuZXZlbnQpLnNwbGl0KCcgJykgOiBbXTtcXG5cXG5cXHRcXHRcXHQvLyBBc3NpZ24gcGFzc2VkIGV2ZW50IGNhbGxiYWNrc1xcblxcdFxcdFxcdCQuZWFjaChvcHRpb25zLmV2ZW50cywgZnVuY3Rpb24gKG5hbWUsIGNhbGxiYWNrKSB7XFxuXFx0XFx0XFx0XFx0c2VsZi5fYmluZCh0b29sdGlwLCBuYW1lID09PSAndG9nZ2xlJyA/IFsndG9vbHRpcHNob3cnLCAndG9vbHRpcGhpZGUnXSA6IFsndG9vbHRpcCcgKyBuYW1lXSwgY2FsbGJhY2ssIG51bGwsIHRvb2x0aXApO1xcblxcdFxcdFxcdH0pO1xcblxcblxcdFxcdFxcdC8vIEhpZGUgdG9vbHRpcHMgd2hlbiBsZWF2aW5nIGN1cnJlbnQgd2luZG93L2ZyYW1lIChidXQgbm90IHNlbGVjdC9vcHRpb24gZWxlbWVudHMpXFxuXFx0XFx0XFx0aWYgKC9tb3VzZShvdXR8bGVhdmUpL2kudGVzdChvcHRpb25zLmhpZGUuZXZlbnQpICYmIG9wdGlvbnMuaGlkZS5sZWF2ZSA9PT0gJ3dpbmRvdycpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9iaW5kKGRvY3VtZW50VGFyZ2V0LCBbJ21vdXNlb3V0JywgJ2JsdXInXSwgZnVuY3Rpb24gKGV2ZW50KSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCEvc2VsZWN0fG9wdGlvbi8udGVzdChldmVudC50YXJnZXQubm9kZU5hbWUpICYmICFldmVudC5yZWxhdGVkVGFyZ2V0KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5oaWRlKGV2ZW50KTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIEVuYWJsZSBoaWRlLmZpeGVkIGJ5IGFkZGluZyBhcHByb3ByaWF0ZSBjbGFzc1xcblxcdFxcdFxcdGlmIChvcHRpb25zLmhpZGUuZml4ZWQpIHtcXG5cXHRcXHRcXHRcXHRoaWRlVGFyZ2V0ID0gaGlkZVRhcmdldC5hZGQodG9vbHRpcC5hZGRDbGFzcyhDTEFTU19GSVhFRCkpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvKlxcbiAgICAqIE1ha2Ugc3VyZSBob3ZlckludGVudCBmdW5jdGlvbnMgcHJvcGVybHkgYnkgdXNpbmcgbW91c2VsZWF2ZSB0byBjbGVhciBzaG93IHRpbWVyIGlmXFxuICAgICogbW91c2VlbnRlci9tb3VzZW91dCBpcyB1c2VkIGZvciBzaG93LmV2ZW50LCBldmVuIGlmIGl0IGlzbid0IGluIHRoZSB1c2VycyBvcHRpb25zLlxcbiAgICAqL1xcblxcdFxcdFxcdGVsc2UgaWYgKC9tb3VzZShvdmVyfGVudGVyKS9pLnRlc3Qob3B0aW9ucy5zaG93LmV2ZW50KSkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX2JpbmQoaGlkZVRhcmdldCwgJ21vdXNlbGVhdmUnLCBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2xlYXJUaW1lb3V0KHRoaXMudGltZXJzLnNob3cpO1xcblxcdFxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBIaWRlIHRvb2x0aXAgb24gZG9jdW1lbnQgbW91c2Vkb3duIGlmIHVuZm9jdXMgZXZlbnRzIGFyZSBlbmFibGVkXFxuXFx0XFx0XFx0aWYgKCgnJyArIG9wdGlvbnMuaGlkZS5ldmVudCkuaW5kZXhPZigndW5mb2N1cycpID4gLTEpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9iaW5kKGNvbnRhaW5lclRhcmdldC5jbG9zZXN0KCdodG1sJyksIFsnbW91c2Vkb3duJywgJ3RvdWNoc3RhcnQnXSwgZnVuY3Rpb24gKGV2ZW50KSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGVsZW0gPSAkKGV2ZW50LnRhcmdldCksXFxuXFx0XFx0XFx0XFx0XFx0ICAgIGVuYWJsZWQgPSB0aGlzLnJlbmRlcmVkICYmICF0aGlzLnRvb2x0aXAuaGFzQ2xhc3MoQ0xBU1NfRElTQUJMRUQpICYmIHRoaXMudG9vbHRpcFswXS5vZmZzZXRXaWR0aCA+IDAsXFxuXFx0XFx0XFx0XFx0XFx0ICAgIGlzQW5jZXN0b3IgPSBlbGVtLnBhcmVudHMoU0VMRUNUT1IpLmZpbHRlcih0aGlzLnRvb2x0aXBbMF0pLmxlbmd0aCA+IDA7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKGVsZW1bMF0gIT09IHRoaXMudGFyZ2V0WzBdICYmIGVsZW1bMF0gIT09IHRoaXMudG9vbHRpcFswXSAmJiAhaXNBbmNlc3RvciAmJiAhdGhpcy50YXJnZXQuaGFzKGVsZW1bMF0pLmxlbmd0aCAmJiBlbmFibGVkKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5oaWRlKGV2ZW50KTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIENoZWNrIGlmIHRoZSB0b29sdGlwIGhpZGVzIHdoZW4gaW5hY3RpdmVcXG5cXHRcXHRcXHRpZiAoJ251bWJlcicgPT09IHR5cGVvZiBvcHRpb25zLmhpZGUuaW5hY3RpdmUpIHtcXG5cXHRcXHRcXHRcXHQvLyBCaW5kIGluYWN0aXZlIG1ldGhvZCB0byBzaG93IHRhcmdldChzKSBhcyBhIGN1c3RvbSBldmVudFxcblxcdFxcdFxcdFxcdHRoaXMuX2JpbmQoc2hvd1RhcmdldCwgJ3F0aXAtJyArIHRoaXMuaWQgKyAnLWluYWN0aXZlJywgaW5hY3RpdmVNZXRob2QsICdpbmFjdGl2ZScpO1xcblxcblxcdFxcdFxcdFxcdC8vIERlZmluZSBldmVudHMgd2hpY2ggcmVzZXQgdGhlICdpbmFjdGl2ZScgZXZlbnQgaGFuZGxlclxcblxcdFxcdFxcdFxcdHRoaXMuX2JpbmQoaGlkZVRhcmdldC5hZGQodG9vbHRpcCksIFFUSVAuaW5hY3RpdmVFdmVudHMsIGluYWN0aXZlTWV0aG9kKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gRmlsdGVyIGFuZCBiaW5kIGV2ZW50c1xcblxcdFxcdFxcdHRoaXMuX2JpbmRFdmVudHMoc2hvd0V2ZW50cywgaGlkZUV2ZW50cywgc2hvd1RhcmdldCwgaGlkZVRhcmdldCwgc2hvd01ldGhvZCwgaGlkZU1ldGhvZCk7XFxuXFxuXFx0XFx0XFx0Ly8gTW91c2UgbW92ZW1lbnQgYmluZGluZ3NcXG5cXHRcXHRcXHR0aGlzLl9iaW5kKHNob3dUYXJnZXQuYWRkKHRvb2x0aXApLCAnbW91c2Vtb3ZlJywgZnVuY3Rpb24gKGV2ZW50KSB7XFxuXFx0XFx0XFx0XFx0Ly8gQ2hlY2sgaWYgdGhlIHRvb2x0aXAgaGlkZXMgd2hlbiBtb3VzZSBpcyBtb3ZlZCBhIGNlcnRhaW4gZGlzdGFuY2VcXG5cXHRcXHRcXHRcXHRpZiAoJ251bWJlcicgPT09IHR5cGVvZiBvcHRpb25zLmhpZGUuZGlzdGFuY2UpIHtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgb3JpZ2luID0gdGhpcy5jYWNoZS5vcmlnaW4gfHwge30sXFxuXFx0XFx0XFx0XFx0XFx0ICAgIGxpbWl0ID0gdGhpcy5vcHRpb25zLmhpZGUuZGlzdGFuY2UsXFxuXFx0XFx0XFx0XFx0XFx0ICAgIGFicyA9IE1hdGguYWJzO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIENoZWNrIGlmIHRoZSBtb3ZlbWVudCBoYXMgZ29uZSBiZXlvbmQgdGhlIGxpbWl0LCBhbmQgaGlkZSBpdCBpZiBzb1xcblxcdFxcdFxcdFxcdFxcdGlmIChhYnMoZXZlbnQucGFnZVggLSBvcmlnaW4ucGFnZVgpID49IGxpbWl0IHx8IGFicyhldmVudC5wYWdlWSAtIG9yaWdpbi5wYWdlWSkgPj0gbGltaXQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLmhpZGUoZXZlbnQpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQ2FjaGUgbW91c2Vtb3ZlIGNvb3JkcyBvbiBzaG93IHRhcmdldHNcXG5cXHRcXHRcXHRcXHR0aGlzLl9zdG9yZU1vdXNlKGV2ZW50KTtcXG5cXHRcXHRcXHR9KTtcXG5cXG5cXHRcXHRcXHQvLyBNb3VzZSBwb3NpdGlvbmluZyBldmVudHNcXG5cXHRcXHRcXHRpZiAocG9zT3B0aW9ucy50YXJnZXQgPT09ICdtb3VzZScpIHtcXG5cXHRcXHRcXHRcXHQvLyBJZiBtb3VzZSBhZGp1c3RtZW50IGlzIG9uLi4uXFxuXFx0XFx0XFx0XFx0aWYgKHBvc09wdGlvbnMuYWRqdXN0Lm1vdXNlKSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gQXBwbHkgYSBtb3VzZWxlYXZlIGV2ZW50IHNvIHdlIGRvbid0IGdldCBwcm9ibGVtcyB3aXRoIG92ZXJsYXBwaW5nXFxuXFx0XFx0XFx0XFx0XFx0aWYgKG9wdGlvbnMuaGlkZS5ldmVudCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdC8vIFRyYWNrIGlmIHdlJ3JlIG9uIHRoZSB0YXJnZXQgb3Igbm90XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5fYmluZChzaG93VGFyZ2V0LCBbJ21vdXNlZW50ZXInLCAnbW91c2VsZWF2ZSddLCBmdW5jdGlvbiAoZXZlbnQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIXRoaXMuY2FjaGUpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gRkFMU0U7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuY2FjaGUub25UYXJnZXQgPSBldmVudC50eXBlID09PSAnbW91c2VlbnRlcic7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdC8vIFVwZGF0ZSB0b29sdGlwIHBvc2l0aW9uIG9uIG1vdXNlbW92ZVxcblxcdFxcdFxcdFxcdFxcdHRoaXMuX2JpbmQoZG9jdW1lbnRUYXJnZXQsICdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZXZlbnQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBVcGRhdGUgdGhlIHRvb2x0aXAgcG9zaXRpb24gb25seSBpZiB0aGUgdG9vbHRpcCBpcyB2aXNpYmxlIGFuZCBhZGp1c3RtZW50IGlzIGVuYWJsZWRcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAodGhpcy5yZW5kZXJlZCAmJiB0aGlzLmNhY2hlLm9uVGFyZ2V0ICYmICF0aGlzLnRvb2x0aXAuaGFzQ2xhc3MoQ0xBU1NfRElTQUJMRUQpICYmIHRoaXMudG9vbHRpcFswXS5vZmZzZXRXaWR0aCA+IDApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLnJlcG9zaXRpb24oZXZlbnQpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIEFkanVzdCBwb3NpdGlvbnMgb2YgdGhlIHRvb2x0aXAgb24gd2luZG93IHJlc2l6ZSBpZiBlbmFibGVkXFxuXFx0XFx0XFx0aWYgKHBvc09wdGlvbnMuYWRqdXN0LnJlc2l6ZSB8fCB2aWV3cG9ydFRhcmdldC5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9iaW5kKCQuZXZlbnQuc3BlY2lhbC5yZXNpemUgPyB2aWV3cG9ydFRhcmdldCA6IHdpbmRvd1RhcmdldCwgJ3Jlc2l6ZScsIHJlcG9zaXRpb25NZXRob2QpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBBZGp1c3QgdG9vbHRpcCBwb3NpdGlvbiBvbiBzY3JvbGwgb2YgdGhlIHdpbmRvdyBvciB2aWV3cG9ydCBlbGVtZW50IGlmIHByZXNlbnRcXG5cXHRcXHRcXHRpZiAocG9zT3B0aW9ucy5hZGp1c3Quc2Nyb2xsKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5fYmluZCh3aW5kb3dUYXJnZXQuYWRkKHBvc09wdGlvbnMuY29udGFpbmVyKSwgJ3Njcm9sbCcsIHJlcG9zaXRpb25NZXRob2QpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9O1xcblxcblxcdFxcdC8vIFVuLWFzc2lnbm1lbnQgbWV0aG9kXFxuXFx0XFx0UFJPVE9UWVBFLl91bmFzc2lnbkV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcXG5cXHRcXHRcXHQgICAgc2hvd1RhcmdldHMgPSBvcHRpb25zLnNob3cudGFyZ2V0LFxcblxcdFxcdFxcdCAgICBoaWRlVGFyZ2V0cyA9IG9wdGlvbnMuaGlkZS50YXJnZXQsXFxuXFx0XFx0XFx0ICAgIHRhcmdldHMgPSAkLmdyZXAoW3RoaXMuZWxlbWVudHMudGFyZ2V0WzBdLCB0aGlzLnJlbmRlcmVkICYmIHRoaXMudG9vbHRpcFswXSwgb3B0aW9ucy5wb3NpdGlvbi5jb250YWluZXJbMF0sIG9wdGlvbnMucG9zaXRpb24udmlld3BvcnRbMF0sIG9wdGlvbnMucG9zaXRpb24uY29udGFpbmVyLmNsb3Nlc3QoJ2h0bWwnKVswXSwgLy8gdW5mb2N1c1xcblxcdFxcdFxcdHdpbmRvdywgZG9jdW1lbnRdLCBmdW5jdGlvbiAoaSkge1xcblxcdFxcdFxcdFxcdHJldHVybiAodHlwZW9mIGkgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGkpKSA9PT0gJ29iamVjdCc7XFxuXFx0XFx0XFx0fSk7XFxuXFxuXFx0XFx0XFx0Ly8gQWRkIHNob3cgYW5kIGhpZGUgdGFyZ2V0cyBpZiB0aGV5J3JlIHZhbGlkXFxuXFx0XFx0XFx0aWYgKHNob3dUYXJnZXRzICYmIHNob3dUYXJnZXRzLnRvQXJyYXkpIHtcXG5cXHRcXHRcXHRcXHR0YXJnZXRzID0gdGFyZ2V0cy5jb25jYXQoc2hvd1RhcmdldHMudG9BcnJheSgpKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKGhpZGVUYXJnZXRzICYmIGhpZGVUYXJnZXRzLnRvQXJyYXkpIHtcXG5cXHRcXHRcXHRcXHR0YXJnZXRzID0gdGFyZ2V0cy5jb25jYXQoaGlkZVRhcmdldHMudG9BcnJheSgpKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gVW5iaW5kIHRoZSBldmVudHNcXG5cXHRcXHRcXHR0aGlzLl91bmJpbmQodGFyZ2V0cykuX3VuYmluZCh0YXJnZXRzLCAnZGVzdHJveScpLl91bmJpbmQodGFyZ2V0cywgJ2luYWN0aXZlJyk7XFxuXFx0XFx0fTtcXG5cXG5cXHRcXHQvLyBBcHBseSBjb21tb24gZXZlbnQgaGFuZGxlcnMgdXNpbmcgZGVsZWdhdGUgKGF2b2lkcyBleGNlc3NpdmUgLmJpbmQgY2FsbHMhKVxcblxcdFxcdCQoZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdGRlbGVnYXRlKFNFTEVDVE9SLCBbJ21vdXNlZW50ZXInLCAnbW91c2VsZWF2ZSddLCBmdW5jdGlvbiAoZXZlbnQpIHtcXG5cXHRcXHRcXHRcXHR2YXIgc3RhdGUgPSBldmVudC50eXBlID09PSAnbW91c2VlbnRlcicsXFxuXFx0XFx0XFx0XFx0ICAgIHRvb2x0aXAgPSAkKGV2ZW50LmN1cnJlbnRUYXJnZXQpLFxcblxcdFxcdFxcdFxcdCAgICB0YXJnZXQgPSAkKGV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgZXZlbnQudGFyZ2V0KSxcXG5cXHRcXHRcXHRcXHQgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcXG5cXG5cXHRcXHRcXHRcXHQvLyBPbiBtb3VzZWVudGVyLi4uXFxuXFx0XFx0XFx0XFx0aWYgKHN0YXRlKSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gRm9jdXMgdGhlIHRvb2x0aXAgb24gbW91c2VlbnRlciAoei1pbmRleCBzdGFja2luZylcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmZvY3VzKGV2ZW50KTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBDbGVhciBoaWRlIHRpbWVyIG9uIHRvb2x0aXAgaG92ZXIgdG8gcHJldmVudCBpdCBmcm9tIGNsb3NpbmdcXG5cXHRcXHRcXHRcXHRcXHR0b29sdGlwLmhhc0NsYXNzKENMQVNTX0ZJWEVEKSAmJiAhdG9vbHRpcC5oYXNDbGFzcyhDTEFTU19ESVNBQkxFRCkgJiYgY2xlYXJUaW1lb3V0KHRoaXMudGltZXJzLmhpZGUpO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBPbiBtb3VzZWxlYXZlLi4uXFxuXFx0XFx0XFx0XFx0ZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gV2hlbiBtb3VzZSB0cmFja2luZyBpcyBlbmFibGVkLCBoaWRlIHdoZW4gd2UgbGVhdmUgdGhlIHRvb2x0aXAgYW5kIG5vdCBvbnRvIHRoZSBzaG93IHRhcmdldCAoaWYgYSBoaWRlIGV2ZW50IGlzIHNldClcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAob3B0aW9ucy5wb3NpdGlvbi50YXJnZXQgPT09ICdtb3VzZScgJiYgb3B0aW9ucy5wb3NpdGlvbi5hZGp1c3QubW91c2UgJiYgb3B0aW9ucy5oaWRlLmV2ZW50ICYmIG9wdGlvbnMuc2hvdy50YXJnZXQgJiYgIXRhcmdldC5jbG9zZXN0KG9wdGlvbnMuc2hvdy50YXJnZXRbMF0pLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuaGlkZShldmVudCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBBZGQgaG92ZXIgY2xhc3NcXG5cXHRcXHRcXHRcXHR0b29sdGlwLnRvZ2dsZUNsYXNzKENMQVNTX0hPVkVSLCBzdGF0ZSk7XFxuXFx0XFx0XFx0fSk7XFxuXFxuXFx0XFx0XFx0Ly8gRGVmaW5lIGV2ZW50cyB3aGljaCByZXNldCB0aGUgJ2luYWN0aXZlJyBldmVudCBoYW5kbGVyXFxuXFx0XFx0XFx0ZGVsZWdhdGUoJ1snICsgQVRUUl9JRCArICddJywgSU5BQ1RJVkVfRVZFTlRTLCBpbmFjdGl2ZU1ldGhvZCk7XFxuXFx0XFx0fSk7XFxuXFx0XFx0OyAvLyBJbml0aWFsaXphdGlvbiBtZXRob2RcXG5cXHRcXHRmdW5jdGlvbiBpbml0KGVsZW0sIGlkLCBvcHRzKSB7XFxuXFx0XFx0XFx0dmFyIG9iaixcXG5cXHRcXHRcXHQgICAgcG9zT3B0aW9ucyxcXG5cXHRcXHRcXHQgICAgYXR0cixcXG5cXHRcXHRcXHQgICAgY29uZmlnLFxcblxcdFxcdFxcdCAgICB0aXRsZSxcXG5cXG5cXG5cXHRcXHRcXHQvLyBTZXR1cCBlbGVtZW50IHJlZmVyZW5jZXNcXG5cXHRcXHRcXHRkb2NCb2R5ID0gJChkb2N1bWVudC5ib2R5KSxcXG5cXG5cXG5cXHRcXHRcXHQvLyBVc2UgZG9jdW1lbnQgYm9keSBpbnN0ZWFkIG9mIGRvY3VtZW50IGVsZW1lbnQgaWYgbmVlZGVkXFxuXFx0XFx0XFx0bmV3VGFyZ2V0ID0gZWxlbVswXSA9PT0gZG9jdW1lbnQgPyBkb2NCb2R5IDogZWxlbSxcXG5cXG5cXG5cXHRcXHRcXHQvLyBHcmFiIG1ldGFkYXRhIGZyb20gZWxlbWVudCBpZiBwbHVnaW4gaXMgcHJlc2VudFxcblxcdFxcdFxcdG1ldGFkYXRhID0gZWxlbS5tZXRhZGF0YSA/IGVsZW0ubWV0YWRhdGEob3B0cy5tZXRhZGF0YSkgOiBOVUxMLFxcblxcblxcblxcdFxcdFxcdC8vIElmIG1ldGFkYXRhIHR5cGUgaWYgSFRNTDUsIGdyYWIgJ25hbWUnIGZyb20gdGhlIG9iamVjdCBpbnN0ZWFkLCBvciB1c2UgdGhlIHJlZ3VsYXIgZGF0YSBvYmplY3Qgb3RoZXJ3aXNlXFxuXFx0XFx0XFx0bWV0YWRhdGE1ID0gb3B0cy5tZXRhZGF0YS50eXBlID09PSAnaHRtbDUnICYmIG1ldGFkYXRhID8gbWV0YWRhdGFbb3B0cy5tZXRhZGF0YS5uYW1lXSA6IE5VTEwsXFxuXFxuXFxuXFx0XFx0XFx0Ly8gR3JhYiBkYXRhIGZyb20gbWV0YWRhdGEubmFtZSAob3IgZGF0YS1xdGlwb3B0cyBhcyBmYWxsYmFjaykgdXNpbmcgLmRhdGEoKSBtZXRob2QsXFxuXFx0XFx0XFx0aHRtbDUgPSBlbGVtLmRhdGEob3B0cy5tZXRhZGF0YS5uYW1lIHx8ICdxdGlwb3B0cycpO1xcblxcblxcdFxcdFxcdC8vIElmIHdlIGRvbid0IGdldCBhbiBvYmplY3QgcmV0dXJuZWQgYXR0ZW1wdCB0byBwYXJzZSBpdCBtYW51YWx5bCB3aXRob3V0IHBhcnNlSlNPTlxcblxcdFxcdFxcdHRyeSB7XFxuXFx0XFx0XFx0XFx0aHRtbDUgPSB0eXBlb2YgaHRtbDUgPT09ICdzdHJpbmcnID8gJC5wYXJzZUpTT04oaHRtbDUpIDogaHRtbDU7XFxuXFx0XFx0XFx0fSBjYXRjaCAoZSkge31cXG5cXG5cXHRcXHRcXHQvLyBNZXJnZSBpbiBhbmQgc2FuaXRpemUgbWV0YWRhdGFcXG5cXHRcXHRcXHRjb25maWcgPSAkLmV4dGVuZChUUlVFLCB7fSwgUVRJUC5kZWZhdWx0cywgb3B0cywgKHR5cGVvZiBodG1sNSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoaHRtbDUpKSA9PT0gJ29iamVjdCcgPyBzYW5pdGl6ZU9wdGlvbnMoaHRtbDUpIDogTlVMTCwgc2FuaXRpemVPcHRpb25zKG1ldGFkYXRhNSB8fCBtZXRhZGF0YSkpO1xcblxcblxcdFxcdFxcdC8vIFJlLWdyYWIgb3VyIHBvc2l0aW9uaW5nIG9wdGlvbnMgbm93IHdlJ3ZlIG1lcmdlZCBvdXIgbWV0YWRhdGEgYW5kIHNldCBpZCB0byBwYXNzZWQgdmFsdWVcXG5cXHRcXHRcXHRwb3NPcHRpb25zID0gY29uZmlnLnBvc2l0aW9uO1xcblxcdFxcdFxcdGNvbmZpZy5pZCA9IGlkO1xcblxcblxcdFxcdFxcdC8vIFNldHVwIG1pc3NpbmcgY29udGVudCBpZiBub25lIGlzIGRldGVjdGVkXFxuXFx0XFx0XFx0aWYgKCdib29sZWFuJyA9PT0gdHlwZW9mIGNvbmZpZy5jb250ZW50LnRleHQpIHtcXG5cXHRcXHRcXHRcXHRhdHRyID0gZWxlbS5hdHRyKGNvbmZpZy5jb250ZW50LmF0dHIpO1xcblxcblxcdFxcdFxcdFxcdC8vIEdyYWIgZnJvbSBzdXBwbGllZCBhdHRyaWJ1dGUgaWYgYXZhaWxhYmxlXFxuXFx0XFx0XFx0XFx0aWYgKGNvbmZpZy5jb250ZW50LmF0dHIgIT09IEZBTFNFICYmIGF0dHIpIHtcXG5cXHRcXHRcXHRcXHRcXHRjb25maWcuY29udGVudC50ZXh0ID0gYXR0cjtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gTm8gdmFsaWQgY29udGVudCB3YXMgZm91bmQsIGFib3J0IHJlbmRlclxcblxcdFxcdFxcdFxcdGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBGQUxTRTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFNldHVwIHRhcmdldCBvcHRpb25zXFxuXFx0XFx0XFx0aWYgKCFwb3NPcHRpb25zLmNvbnRhaW5lci5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRwb3NPcHRpb25zLmNvbnRhaW5lciA9IGRvY0JvZHk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmIChwb3NPcHRpb25zLnRhcmdldCA9PT0gRkFMU0UpIHtcXG5cXHRcXHRcXHRcXHRwb3NPcHRpb25zLnRhcmdldCA9IG5ld1RhcmdldDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKGNvbmZpZy5zaG93LnRhcmdldCA9PT0gRkFMU0UpIHtcXG5cXHRcXHRcXHRcXHRjb25maWcuc2hvdy50YXJnZXQgPSBuZXdUYXJnZXQ7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmIChjb25maWcuc2hvdy5zb2xvID09PSBUUlVFKSB7XFxuXFx0XFx0XFx0XFx0Y29uZmlnLnNob3cuc29sbyA9IHBvc09wdGlvbnMuY29udGFpbmVyLmNsb3Nlc3QoJ2JvZHknKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKGNvbmZpZy5oaWRlLnRhcmdldCA9PT0gRkFMU0UpIHtcXG5cXHRcXHRcXHRcXHRjb25maWcuaGlkZS50YXJnZXQgPSBuZXdUYXJnZXQ7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmIChjb25maWcucG9zaXRpb24udmlld3BvcnQgPT09IFRSVUUpIHtcXG5cXHRcXHRcXHRcXHRjb25maWcucG9zaXRpb24udmlld3BvcnQgPSBwb3NPcHRpb25zLmNvbnRhaW5lcjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gRW5zdXJlIHdlIG9ubHkgdXNlIGEgc2luZ2xlIGNvbnRhaW5lclxcblxcdFxcdFxcdHBvc09wdGlvbnMuY29udGFpbmVyID0gcG9zT3B0aW9ucy5jb250YWluZXIuZXEoMCk7XFxuXFxuXFx0XFx0XFx0Ly8gQ29udmVydCBwb3NpdGlvbiBjb3JuZXIgdmFsdWVzIGludG8geCBhbmQgeSBzdHJpbmdzXFxuXFx0XFx0XFx0cG9zT3B0aW9ucy5hdCA9IG5ldyBDT1JORVIocG9zT3B0aW9ucy5hdCwgVFJVRSk7XFxuXFx0XFx0XFx0cG9zT3B0aW9ucy5teSA9IG5ldyBDT1JORVIocG9zT3B0aW9ucy5teSk7XFxuXFxuXFx0XFx0XFx0Ly8gRGVzdHJveSBwcmV2aW91cyB0b29sdGlwIGlmIG92ZXJ3cml0ZSBpcyBlbmFibGVkLCBvciBza2lwIGVsZW1lbnQgaWYgbm90XFxuXFx0XFx0XFx0aWYgKGVsZW0uZGF0YShOQU1FU1BBQ0UpKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGNvbmZpZy5vdmVyd3JpdGUpIHtcXG5cXHRcXHRcXHRcXHRcXHRlbGVtLnF0aXAoJ2Rlc3Ryb3knLCB0cnVlKTtcXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKGNvbmZpZy5vdmVyd3JpdGUgPT09IEZBTFNFKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIEZBTFNFO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gQWRkIGhhcy1xdGlwIGF0dHJpYnV0ZVxcblxcdFxcdFxcdGVsZW0uYXR0cihBVFRSX0hBUywgaWQpO1xcblxcblxcdFxcdFxcdC8vIFJlbW92ZSB0aXRsZSBhdHRyaWJ1dGUgYW5kIHN0b3JlIGl0IGlmIHByZXNlbnRcXG5cXHRcXHRcXHRpZiAoY29uZmlnLnN1cHByZXNzICYmICh0aXRsZSA9IGVsZW0uYXR0cigndGl0bGUnKSkpIHtcXG5cXHRcXHRcXHRcXHQvLyBGaW5hbCBhdHRyIGNhbGwgZml4ZXMgZXZlbnQgZGVsZWdhdGlvbSBhbmQgSUUgZGVmYXVsdCB0b29sdGlwIHNob3dpbmcgcHJvYmxlbVxcblxcdFxcdFxcdFxcdGVsZW0ucmVtb3ZlQXR0cigndGl0bGUnKS5hdHRyKG9sZHRpdGxlLCB0aXRsZSkuYXR0cigndGl0bGUnLCAnJyk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIEluaXRpYWxpemUgdGhlIHRvb2x0aXAgYW5kIGFkZCBBUEkgcmVmZXJlbmNlXFxuXFx0XFx0XFx0b2JqID0gbmV3IFFUaXAoZWxlbSwgY29uZmlnLCBpZCwgISFhdHRyKTtcXG5cXHRcXHRcXHRlbGVtLmRhdGEoTkFNRVNQQUNFLCBvYmopO1xcblxcblxcdFxcdFxcdHJldHVybiBvYmo7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIGpRdWVyeSAkLmZuIGV4dGVuc2lvbiBtZXRob2RcXG5cXHRcXHRRVElQID0gJC5mbi5xdGlwID0gZnVuY3Rpb24gKG9wdGlvbnMsIG5vdGF0aW9uLCBuZXdWYWx1ZSkge1xcblxcdFxcdFxcdHZhciBjb21tYW5kID0gKCcnICsgb3B0aW9ucykudG9Mb3dlckNhc2UoKSxcXG5cXHRcXHRcXHQgICAgLy8gUGFyc2UgY29tbWFuZFxcblxcdFxcdFxcdHJldHVybmVkID0gTlVMTCxcXG5cXHRcXHRcXHQgICAgYXJncyA9ICQubWFrZUFycmF5KGFyZ3VtZW50cykuc2xpY2UoMSksXFxuXFx0XFx0XFx0ICAgIGV2ZW50ID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdLFxcblxcdFxcdFxcdCAgICBvcHRzID0gdGhpc1swXSA/ICQuZGF0YSh0aGlzWzBdLCBOQU1FU1BBQ0UpIDogTlVMTDtcXG5cXG5cXHRcXHRcXHQvLyBDaGVjayBmb3IgQVBJIHJlcXVlc3RcXG5cXHRcXHRcXHRpZiAoIWFyZ3VtZW50cy5sZW5ndGggJiYgb3B0cyB8fCBjb21tYW5kID09PSAnYXBpJykge1xcblxcdFxcdFxcdFxcdHJldHVybiBvcHRzO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBFeGVjdXRlIEFQSSBjb21tYW5kIGlmIHByZXNlbnRcXG5cXHRcXHRcXHRlbHNlIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIG9wdGlvbnMpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBhcGkgPSAkLmRhdGEodGhpcywgTkFNRVNQQUNFKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIWFwaSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBUUlVFO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBDYWNoZSB0aGUgZXZlbnQgaWYgcG9zc2libGVcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoZXZlbnQgJiYgZXZlbnQudGltZVN0YW1wKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YXBpLmNhY2hlLmV2ZW50ID0gZXZlbnQ7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIENoZWNrIGZvciBzcGVjaWZpYyBBUEkgY29tbWFuZHNcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAobm90YXRpb24gJiYgKGNvbW1hbmQgPT09ICdvcHRpb24nIHx8IGNvbW1hbmQgPT09ICdvcHRpb25zJykpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAobmV3VmFsdWUgIT09IHVuZGVmaW5lZCB8fCAkLmlzUGxhaW5PYmplY3Qobm90YXRpb24pKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YXBpLnNldChub3RhdGlvbiwgbmV3VmFsdWUpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuZWQgPSBhcGkuZ2V0KG5vdGF0aW9uKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gRkFMU0U7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBFeGVjdXRlIEFQSSBjb21tYW5kXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZWxzZSBpZiAoYXBpW2NvbW1hbmRdKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YXBpW2NvbW1hbmRdLmFwcGx5KGFwaSwgYXJncyk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH0pO1xcblxcblxcdFxcdFxcdFxcdFxcdHJldHVybiByZXR1cm5lZCAhPT0gTlVMTCA/IHJldHVybmVkIDogdGhpcztcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gTm8gQVBJIGNvbW1hbmRzLiB2YWxpZGF0ZSBwcm92aWRlZCBvcHRpb25zIGFuZCBzZXR1cCBxVGlwc1xcblxcdFxcdFxcdFxcdGVsc2UgaWYgKCdvYmplY3QnID09PSAodHlwZW9mIG9wdGlvbnMgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG9wdGlvbnMpKSB8fCAhYXJndW1lbnRzLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdC8vIFNhbml0aXplIG9wdGlvbnMgZmlyc3RcXG5cXHRcXHRcXHRcXHRcXHRcXHRvcHRzID0gc2FuaXRpemVPcHRpb25zKCQuZXh0ZW5kKFRSVUUsIHt9LCBvcHRpb25zKSk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoaSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciBhcGksIGlkO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIEZpbmQgbmV4dCBhdmFpbGFibGUgSUQsIG9yIHVzZSBjdXN0b20gSUQgaWYgcHJvdmlkZWRcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZCA9ICQuaXNBcnJheShvcHRzLmlkKSA/IG9wdHMuaWRbaV0gOiBvcHRzLmlkO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlkID0gIWlkIHx8IGlkID09PSBGQUxTRSB8fCBpZC5sZW5ndGggPCAxIHx8IFFUSVAuYXBpW2lkXSA/IFFUSVAubmV4dGlkKysgOiBpZDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBJbml0aWFsaXplIHRoZSBxVGlwIGFuZCByZS1ncmFiIG5ld2x5IHNhbml0aXplZCBvcHRpb25zXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YXBpID0gaW5pdCgkKHRoaXMpLCBpZCwgb3B0cyk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKGFwaSA9PT0gRkFMU0UpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gVFJVRTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFFUSVAuYXBpW2lkXSA9IGFwaTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gSW5pdGlhbGl6ZSBwbHVnaW5zXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0JC5lYWNoKFBMVUdJTlMsIGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAodGhpcy5pbml0aWFsaXplID09PSAnaW5pdGlhbGl6ZScpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzKGFwaSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH0pO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIEFzc2lnbiBpbml0aWFsIHByZS1yZW5kZXIgZXZlbnRzXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YXBpLl9hc3NpZ25Jbml0aWFsRXZlbnRzKGV2ZW50KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0fTtcXG5cXG5cXHRcXHQvLyBFeHBvc2UgY2xhc3NcXG5cXHRcXHQkLnF0aXAgPSBRVGlwO1xcblxcblxcdFxcdC8vIFBvcHVsYXRlZCBpbiByZW5kZXIgbWV0aG9kXFxuXFx0XFx0UVRJUC5hcGkgPSB7fTtcXG5cXHRcXHQ7JC5lYWNoKHtcXG5cXHRcXHRcXHQvKiBBbGxvdyBvdGhlciBwbHVnaW5zIHRvIHN1Y2Nlc3NmdWxseSByZXRyaWV2ZSB0aGUgdGl0bGUgb2YgYW4gZWxlbWVudCB3aXRoIGEgcVRpcCBhcHBsaWVkICovXFxuXFx0XFx0XFx0YXR0cjogZnVuY3Rpb24gYXR0cihfYXR0ciwgdmFsKSB7XFxuXFx0XFx0XFx0XFx0aWYgKHRoaXMubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIHNlbGYgPSB0aGlzWzBdLFxcblxcdFxcdFxcdFxcdFxcdCAgICB0aXRsZSA9ICd0aXRsZScsXFxuXFx0XFx0XFx0XFx0XFx0ICAgIGFwaSA9ICQuZGF0YShzZWxmLCAncXRpcCcpO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmIChfYXR0ciA9PT0gdGl0bGUgJiYgYXBpICYmICdvYmplY3QnID09PSAodHlwZW9mIGFwaSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoYXBpKSkgJiYgYXBpLm9wdGlvbnMuc3VwcHJlc3MpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gJC5hdHRyKHNlbGYsIG9sZHRpdGxlKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gSWYgcVRpcCBpcyByZW5kZXJlZCBhbmQgdGl0bGUgd2FzIG9yaWdpbmFsbHkgdXNlZCBhcyBjb250ZW50LCB1cGRhdGUgaXRcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoYXBpICYmIGFwaS5vcHRpb25zLmNvbnRlbnQuYXR0ciA9PT0gdGl0bGUgJiYgYXBpLmNhY2hlLmF0dHIpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRhcGkuc2V0KCdjb250ZW50LnRleHQnLCB2YWwpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBVc2UgdGhlIHJlZ3VsYXIgYXR0ciBtZXRob2QgdG8gc2V0LCB0aGVuIGNhY2hlIHRoZSByZXN1bHRcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5hdHRyKG9sZHRpdGxlLCB2YWwpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuICQuZm5bJ2F0dHInICsgcmVwbGFjZVN1ZmZpeF0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdC8qIEFsbG93IGNsb25lIHRvIGNvcnJlY3RseSByZXRyaWV2ZSBjYWNoZWQgdGl0bGUgYXR0cmlidXRlcyAqL1xcblxcdFxcdFxcdGNsb25lOiBmdW5jdGlvbiBjbG9uZShrZWVwRGF0YSkge1xcblxcdFxcdFxcdFxcdHZhciB0aXRsZXMgPSAkKFtdKSxcXG5cXHRcXHRcXHRcXHQgICAgdGl0bGUgPSAndGl0bGUnLFxcblxcblxcblxcdFxcdFxcdFxcdC8vIENsb25lIG91ciBlbGVtZW50IHVzaW5nIHRoZSByZWFsIGNsb25lIG1ldGhvZFxcblxcdFxcdFxcdFxcdGVsZW1zID0gJC5mblsnY2xvbmUnICsgcmVwbGFjZVN1ZmZpeF0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBHcmFiIGFsbCBlbGVtZW50cyB3aXRoIGFuIG9sZHRpdGxlIHNldCwgYW5kIGNoYW5nZSBpdCB0byByZWd1bGFyIHRpdGxlIGF0dHJpYnV0ZSwgaWYga2VlcERhdGEgaXMgZmFsc2VcXG5cXHRcXHRcXHRcXHRpZiAoIWtlZXBEYXRhKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZWxlbXMuZmlsdGVyKCdbJyArIG9sZHRpdGxlICsgJ10nKS5hdHRyKCd0aXRsZScsIGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gJC5hdHRyKHRoaXMsIG9sZHRpdGxlKTtcXG5cXHRcXHRcXHRcXHRcXHR9KS5yZW1vdmVBdHRyKG9sZHRpdGxlKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIGVsZW1zO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LCBmdW5jdGlvbiAobmFtZSwgZnVuYykge1xcblxcdFxcdFxcdGlmICghZnVuYyB8fCAkLmZuW25hbWUgKyByZXBsYWNlU3VmZml4XSkge1xcblxcdFxcdFxcdFxcdHJldHVybiBUUlVFO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2YXIgb2xkID0gJC5mbltuYW1lICsgcmVwbGFjZVN1ZmZpeF0gPSAkLmZuW25hbWVdO1xcblxcdFxcdFxcdCQuZm5bbmFtZV0gPSBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCBvbGQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG5cXHRcXHRcXHR9O1xcblxcdFxcdH0pO1xcblxcblxcdFxcdC8qIEZpcmUgb2ZmICdyZW1vdmVxdGlwJyBoYW5kbGVyIGluICQuY2xlYW5EYXRhIGlmIGpRdWVyeSBVSSBub3QgcHJlc2VudCAoaXQgYWxyZWFkeSBkb2VzIHNpbWlsYXIpLlxcbiAgICogVGhpcyBzbmlwcGV0IGlzIHRha2VuIGRpcmVjdGx5IGZyb20galF1ZXJ5IFVJIHNvdXJjZSBjb2RlIGZvdW5kIGhlcmU6XFxuICAgKiAgICAgaHR0cDovL2NvZGUuanF1ZXJ5LmNvbS91aS9qcXVlcnktdWktZ2l0LmpzXFxuICAgKi9cXG5cXHRcXHRpZiAoISQudWkpIHtcXG5cXHRcXHRcXHQkWydjbGVhbkRhdGEnICsgcmVwbGFjZVN1ZmZpeF0gPSAkLmNsZWFuRGF0YTtcXG5cXHRcXHRcXHQkLmNsZWFuRGF0YSA9IGZ1bmN0aW9uIChlbGVtcykge1xcblxcdFxcdFxcdFxcdGZvciAodmFyIGkgPSAwLCBlbGVtOyAoZWxlbSA9ICQoZWxlbXNbaV0pKS5sZW5ndGg7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdGlmIChlbGVtLmF0dHIoQVRUUl9IQVMpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dHJ5IHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRlbGVtLnRyaWdnZXJIYW5kbGVyKCdyZW1vdmVxdGlwJyk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBjYXRjaCAoZSkge31cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdCRbJ2NsZWFuRGF0YScgKyByZXBsYWNlU3VmZml4XS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcblxcdFxcdFxcdH07XFxuXFx0XFx0fVxcblxcdFxcdDsgLy8gcVRpcCB2ZXJzaW9uXFxuXFx0XFx0UVRJUC52ZXJzaW9uID0gJzIuMi4xLTI5LSc7XFxuXFxuXFx0XFx0Ly8gQmFzZSBJRCBmb3IgYWxsIHFUaXBzXFxuXFx0XFx0UVRJUC5uZXh0aWQgPSAwO1xcblxcblxcdFxcdC8vIEluYWN0aXZlIGV2ZW50cyBhcnJheVxcblxcdFxcdFFUSVAuaW5hY3RpdmVFdmVudHMgPSBJTkFDVElWRV9FVkVOVFM7XFxuXFxuXFx0XFx0Ly8gQmFzZSB6LWluZGV4IGZvciBhbGwgcVRpcHNcXG5cXHRcXHRRVElQLnppbmRleCA9IDE1MDAwO1xcblxcblxcdFxcdC8vIERlZmluZSBjb25maWd1cmF0aW9uIGRlZmF1bHRzXFxuXFx0XFx0UVRJUC5kZWZhdWx0cyA9IHtcXG5cXHRcXHRcXHRwcmVyZW5kZXI6IEZBTFNFLFxcblxcdFxcdFxcdGlkOiBGQUxTRSxcXG5cXHRcXHRcXHRvdmVyd3JpdGU6IFRSVUUsXFxuXFx0XFx0XFx0c3VwcHJlc3M6IFRSVUUsXFxuXFx0XFx0XFx0Y29udGVudDoge1xcblxcdFxcdFxcdFxcdHRleHQ6IFRSVUUsXFxuXFx0XFx0XFx0XFx0YXR0cjogJ3RpdGxlJyxcXG5cXHRcXHRcXHRcXHR0aXRsZTogRkFMU0UsXFxuXFx0XFx0XFx0XFx0YnV0dG9uOiBGQUxTRVxcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0cG9zaXRpb246IHtcXG5cXHRcXHRcXHRcXHRteTogJ3RvcCBsZWZ0JyxcXG5cXHRcXHRcXHRcXHRhdDogJ2JvdHRvbSByaWdodCcsXFxuXFx0XFx0XFx0XFx0dGFyZ2V0OiBGQUxTRSxcXG5cXHRcXHRcXHRcXHRjb250YWluZXI6IEZBTFNFLFxcblxcdFxcdFxcdFxcdHZpZXdwb3J0OiBGQUxTRSxcXG5cXHRcXHRcXHRcXHRhZGp1c3Q6IHtcXG5cXHRcXHRcXHRcXHRcXHR4OiAwLCB5OiAwLFxcblxcdFxcdFxcdFxcdFxcdG1vdXNlOiBUUlVFLFxcblxcdFxcdFxcdFxcdFxcdHNjcm9sbDogVFJVRSxcXG5cXHRcXHRcXHRcXHRcXHRyZXNpemU6IFRSVUUsXFxuXFx0XFx0XFx0XFx0XFx0bWV0aG9kOiAnZmxpcGludmVydCBmbGlwaW52ZXJ0J1xcblxcdFxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0XFx0ZWZmZWN0OiBmdW5jdGlvbiBlZmZlY3QoYXBpLCBwb3MsIHZpZXdwb3J0KSB7XFxuXFx0XFx0XFx0XFx0XFx0JCh0aGlzKS5hbmltYXRlKHBvcywge1xcblxcdFxcdFxcdFxcdFxcdFxcdGR1cmF0aW9uOiAyMDAsXFxuXFx0XFx0XFx0XFx0XFx0XFx0cXVldWU6IEZBTFNFXFxuXFx0XFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0c2hvdzoge1xcblxcdFxcdFxcdFxcdHRhcmdldDogRkFMU0UsXFxuXFx0XFx0XFx0XFx0ZXZlbnQ6ICdtb3VzZWVudGVyJyxcXG5cXHRcXHRcXHRcXHRlZmZlY3Q6IFRSVUUsXFxuXFx0XFx0XFx0XFx0ZGVsYXk6IDkwLFxcblxcdFxcdFxcdFxcdHNvbG86IEZBTFNFLFxcblxcdFxcdFxcdFxcdHJlYWR5OiBGQUxTRSxcXG5cXHRcXHRcXHRcXHRhdXRvZm9jdXM6IEZBTFNFXFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRoaWRlOiB7XFxuXFx0XFx0XFx0XFx0dGFyZ2V0OiBGQUxTRSxcXG5cXHRcXHRcXHRcXHRldmVudDogJ21vdXNlbGVhdmUnLFxcblxcdFxcdFxcdFxcdGVmZmVjdDogVFJVRSxcXG5cXHRcXHRcXHRcXHRkZWxheTogMCxcXG5cXHRcXHRcXHRcXHRmaXhlZDogRkFMU0UsXFxuXFx0XFx0XFx0XFx0aW5hY3RpdmU6IEZBTFNFLFxcblxcdFxcdFxcdFxcdGxlYXZlOiAnd2luZG93JyxcXG5cXHRcXHRcXHRcXHRkaXN0YW5jZTogRkFMU0VcXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdHN0eWxlOiB7XFxuXFx0XFx0XFx0XFx0Y2xhc3NlczogJycsXFxuXFx0XFx0XFx0XFx0d2lkZ2V0OiBGQUxTRSxcXG5cXHRcXHRcXHRcXHR3aWR0aDogRkFMU0UsXFxuXFx0XFx0XFx0XFx0aGVpZ2h0OiBGQUxTRSxcXG5cXHRcXHRcXHRcXHRkZWY6IFRSVUVcXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdGV2ZW50czoge1xcblxcdFxcdFxcdFxcdHJlbmRlcjogTlVMTCxcXG5cXHRcXHRcXHRcXHRtb3ZlOiBOVUxMLFxcblxcdFxcdFxcdFxcdHNob3c6IE5VTEwsXFxuXFx0XFx0XFx0XFx0aGlkZTogTlVMTCxcXG5cXHRcXHRcXHRcXHR0b2dnbGU6IE5VTEwsXFxuXFx0XFx0XFx0XFx0dmlzaWJsZTogTlVMTCxcXG5cXHRcXHRcXHRcXHRoaWRkZW46IE5VTEwsXFxuXFx0XFx0XFx0XFx0Zm9jdXM6IE5VTEwsXFxuXFx0XFx0XFx0XFx0Ymx1cjogTlVMTFxcblxcdFxcdFxcdH1cXG5cXHRcXHR9O1xcblxcdFxcdDt2YXIgVElQLFxcblxcblxcblxcdFxcdC8vIC5iaW5kKCkvLm9uKCkgbmFtZXNwYWNlXFxuXFx0XFx0VElQTlMgPSAnLnF0aXAtdGlwJyxcXG5cXG5cXG5cXHRcXHQvLyBDb21tb24gQ1NTIHN0cmluZ3NcXG5cXHRcXHRNQVJHSU4gPSAnbWFyZ2luJyxcXG5cXHRcXHQgICAgQk9SREVSID0gJ2JvcmRlcicsXFxuXFx0XFx0ICAgIENPTE9SID0gJ2NvbG9yJyxcXG5cXHRcXHQgICAgQkdfQ09MT1IgPSAnYmFja2dyb3VuZC1jb2xvcicsXFxuXFx0XFx0ICAgIFRSQU5TUEFSRU5UID0gJ3RyYW5zcGFyZW50JyxcXG5cXHRcXHQgICAgSU1QT1JUQU5UID0gJyAhaW1wb3J0YW50JyxcXG5cXG5cXG5cXHRcXHQvLyBDaGVjayBpZiB0aGUgYnJvd3NlciBzdXBwb3J0cyA8Y2FudmFzLz4gZWxlbWVudHNcXG5cXHRcXHRIQVNDQU5WQVMgPSAhIWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLmdldENvbnRleHQsXFxuXFxuXFxuXFx0XFx0Ly8gSW52YWxpZCBjb2xvdXIgdmFsdWVzIHVzZWQgaW4gcGFyc2VDb2xvdXJzKClcXG5cXHRcXHRJTlZBTElEID0gL3JnYmE/XFxcXCgwLCAwLCAwKCwgMCk/XFxcXCl8dHJhbnNwYXJlbnR8IzEyMzQ1Ni9pO1xcblxcblxcdFxcdC8vIENhbWVsLWNhc2UgbWV0aG9kLCB0YWtlbiBmcm9tIGpRdWVyeSBzb3VyY2VcXG5cXHRcXHQvLyBodHRwOi8vY29kZS5qcXVlcnkuY29tL2pxdWVyeS0xLjguMC5qc1xcblxcdFxcdGZ1bmN0aW9uIGNhbWVsKHMpIHtcXG5cXHRcXHRcXHRyZXR1cm4gcy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHMuc2xpY2UoMSk7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8qXFxuICAgKiBNb2RpZmllZCBmcm9tIE1vZGVybml6cidzIHRlc3RQcm9wc0FsbCgpXFxuICAgKiBodHRwOi8vbW9kZXJuaXpyLmNvbS9kb3dubG9hZHMvbW9kZXJuaXpyLWxhdGVzdC5qc1xcbiAgICovXFxuXFx0XFx0dmFyIGNzc1Byb3BzID0ge30sXFxuXFx0XFx0ICAgIGNzc1ByZWZpeGVzID0gW1xcXCJXZWJraXRcXFwiLCBcXFwiT1xcXCIsIFxcXCJNb3pcXFwiLCBcXFwibXNcXFwiXTtcXG5cXHRcXHRmdW5jdGlvbiB2ZW5kb3JDc3MoZWxlbSwgcHJvcCkge1xcblxcdFxcdFxcdHZhciB1Y1Byb3AgPSBwcm9wLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcC5zbGljZSgxKSxcXG5cXHRcXHRcXHQgICAgcHJvcHMgPSAocHJvcCArICcgJyArIGNzc1ByZWZpeGVzLmpvaW4odWNQcm9wICsgJyAnKSArIHVjUHJvcCkuc3BsaXQoJyAnKSxcXG5cXHRcXHRcXHQgICAgY3VyLFxcblxcdFxcdFxcdCAgICB2YWwsXFxuXFx0XFx0XFx0ICAgIGkgPSAwO1xcblxcblxcdFxcdFxcdC8vIElmIHRoZSBwcm9wZXJ0eSBoYXMgYWxyZWFkeSBiZWVuIG1hcHBlZC4uLlxcblxcdFxcdFxcdGlmIChjc3NQcm9wc1twcm9wXSkge1xcblxcdFxcdFxcdFxcdHJldHVybiBlbGVtLmNzcyhjc3NQcm9wc1twcm9wXSk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHdoaWxlIChjdXIgPSBwcm9wc1tpKytdKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCh2YWwgPSBlbGVtLmNzcyhjdXIpKSAhPT0gdW5kZWZpbmVkKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGNzc1Byb3BzW3Byb3BdID0gY3VyLCB2YWw7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gUGFyc2UgYSBnaXZlbiBlbGVtZW50cyBDU1MgcHJvcGVydHkgaW50byBhbiBpbnRcXG5cXHRcXHRmdW5jdGlvbiBpbnRDc3MoZWxlbSwgcHJvcCkge1xcblxcdFxcdFxcdHJldHVybiBNYXRoLmNlaWwocGFyc2VGbG9hdCh2ZW5kb3JDc3MoZWxlbSwgcHJvcCkpKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gVk1MIGNyZWF0aW9uIChmb3IgSUUgb25seSlcXG5cXHRcXHRpZiAoIUhBU0NBTlZBUykge1xcblxcdFxcdFxcdHZhciBjcmVhdGVWTUwgPSBmdW5jdGlvbiBjcmVhdGVWTUwodGFnLCBwcm9wcywgc3R5bGUpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gJzxxdGlwdm1sOicgKyB0YWcgKyAnIHhtbG5zPVxcXCJ1cm46c2NoZW1hcy1taWNyb3NvZnQuY29tOnZtbFxcXCIgY2xhc3M9XFxcInF0aXAtdm1sXFxcIiAnICsgKHByb3BzIHx8ICcnKSArICcgc3R5bGU9XFxcImJlaGF2aW9yOiB1cmwoI2RlZmF1bHQjVk1MKTsgJyArIChzdHlsZSB8fCAnJykgKyAnXFxcIiAvPic7XFxuXFx0XFx0XFx0fTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gQ2FudmFzIG9ubHkgZGVmaW5pdGlvbnNcXG5cXHRcXHRlbHNlIHtcXG5cXHRcXHRcXHRcXHR2YXIgUElYRUxfUkFUSU8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxLFxcblxcdFxcdFxcdFxcdCAgICBCQUNLSU5HX1NUT1JFX1JBVElPID0gZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdHZhciBjb250ZXh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykuZ2V0Q29udGV4dCgnMmQnKTtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gY29udGV4dC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGNvbnRleHQud2Via2l0QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjb250ZXh0Lm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY29udGV4dC5tc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY29udGV4dC5vQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCAxO1xcblxcdFxcdFxcdFxcdH0oKSxcXG5cXHRcXHRcXHRcXHQgICAgU0NBTEUgPSBQSVhFTF9SQVRJTyAvIEJBQ0tJTkdfU1RPUkVfUkFUSU87XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIFRpcChxdGlwLCBvcHRpb25zKSB7XFxuXFx0XFx0XFx0dGhpcy5fbnMgPSAndGlwJztcXG5cXHRcXHRcXHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xcblxcdFxcdFxcdHRoaXMub2Zmc2V0ID0gb3B0aW9ucy5vZmZzZXQ7XFxuXFx0XFx0XFx0dGhpcy5zaXplID0gW29wdGlvbnMud2lkdGgsIG9wdGlvbnMuaGVpZ2h0XTtcXG5cXG5cXHRcXHRcXHQvLyBJbml0aWFsaXplXFxuXFx0XFx0XFx0dGhpcy5pbml0KHRoaXMucXRpcCA9IHF0aXApO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQkLmV4dGVuZChUaXAucHJvdG90eXBlLCB7XFxuXFx0XFx0XFx0aW5pdDogZnVuY3Rpb24gaW5pdChxdGlwKSB7XFxuXFx0XFx0XFx0XFx0dmFyIGNvbnRleHQsIHRpcDtcXG5cXG5cXHRcXHRcXHRcXHQvLyBDcmVhdGUgdGlwIGVsZW1lbnQgYW5kIHByZXBlbmQgdG8gdGhlIHRvb2x0aXBcXG5cXHRcXHRcXHRcXHR0aXAgPSB0aGlzLmVsZW1lbnQgPSBxdGlwLmVsZW1lbnRzLnRpcCA9ICQoJzxkaXYgLz4nLCB7ICdjbGFzcyc6IE5BTUVTUEFDRSArICctdGlwJyB9KS5wcmVwZW5kVG8ocXRpcC50b29sdGlwKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBDcmVhdGUgdGlwIGRyYXdpbmcgZWxlbWVudChzKVxcblxcdFxcdFxcdFxcdGlmIChIQVNDQU5WQVMpIHtcXG5cXHRcXHRcXHRcXHRcXHQvLyBzYXZlKCkgYXMgc29vbiBhcyB3ZSBjcmVhdGUgdGhlIGNhbnZhcyBlbGVtZW50IHNvIEZGMiBkb2Vzbid0IGJvcmsgb24gb3VyIGZpcnN0IHJlc3RvcmUoKSFcXG5cXHRcXHRcXHRcXHRcXHRjb250ZXh0ID0gJCgnPGNhbnZhcyAvPicpLmFwcGVuZFRvKHRoaXMuZWxlbWVudClbMF0uZ2V0Q29udGV4dCgnMmQnKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBTZXR1cCBjb25zdGFudCBwYXJhbWV0ZXJzXFxuXFx0XFx0XFx0XFx0XFx0Y29udGV4dC5saW5lSm9pbiA9ICdtaXRlcic7XFxuXFx0XFx0XFx0XFx0XFx0Y29udGV4dC5taXRlckxpbWl0ID0gMTAwMDAwO1xcblxcdFxcdFxcdFxcdFxcdGNvbnRleHQuc2F2ZSgpO1xcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0Y29udGV4dCA9IGNyZWF0ZVZNTCgnc2hhcGUnLCAnY29vcmRvcmlnaW49XFxcIjAsMFxcXCInLCAncG9zaXRpb246YWJzb2x1dGU7Jyk7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5lbGVtZW50Lmh0bWwoY29udGV4dCArIGNvbnRleHQpO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIFByZXZlbnQgbW91c2luZyBkb3duIG9uIHRoZSB0aXAgc2luY2UgaXQgY2F1c2VzIHByb2JsZW1zIHdpdGggLmxpdmUoKSBoYW5kbGluZyBpbiBJRSBkdWUgdG8gVk1MXFxuXFx0XFx0XFx0XFx0XFx0cXRpcC5fYmluZCgkKCcqJywgdGlwKS5hZGQodGlwKSwgWydjbGljaycsICdtb3VzZWRvd24nXSwgZnVuY3Rpb24gKGV2ZW50KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XFxuXFx0XFx0XFx0XFx0XFx0fSwgdGhpcy5fbnMpO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBCaW5kIHVwZGF0ZSBldmVudHNcXG5cXHRcXHRcXHRcXHRxdGlwLl9iaW5kKHF0aXAudG9vbHRpcCwgJ3Rvb2x0aXBtb3ZlJywgdGhpcy5yZXBvc2l0aW9uLCB0aGlzLl9ucywgdGhpcyk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQ3JlYXRlIGl0XFxuXFx0XFx0XFx0XFx0dGhpcy5jcmVhdGUoKTtcXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdF9zd2FwRGltZW5zaW9uczogZnVuY3Rpb24gX3N3YXBEaW1lbnNpb25zKCkge1xcblxcdFxcdFxcdFxcdHRoaXMuc2l6ZVswXSA9IHRoaXMub3B0aW9ucy5oZWlnaHQ7XFxuXFx0XFx0XFx0XFx0dGhpcy5zaXplWzFdID0gdGhpcy5vcHRpb25zLndpZHRoO1xcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0X3Jlc2V0RGltZW5zaW9uczogZnVuY3Rpb24gX3Jlc2V0RGltZW5zaW9ucygpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLnNpemVbMF0gPSB0aGlzLm9wdGlvbnMud2lkdGg7XFxuXFx0XFx0XFx0XFx0dGhpcy5zaXplWzFdID0gdGhpcy5vcHRpb25zLmhlaWdodDtcXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdF91c2VUaXRsZTogZnVuY3Rpb24gX3VzZVRpdGxlKGNvcm5lcikge1xcblxcdFxcdFxcdFxcdHZhciB0aXRsZWJhciA9IHRoaXMucXRpcC5lbGVtZW50cy50aXRsZWJhcjtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGl0bGViYXIgJiYgKGNvcm5lci55ID09PSBUT1AgfHwgY29ybmVyLnkgPT09IENFTlRFUiAmJiB0aGlzLmVsZW1lbnQucG9zaXRpb24oKS50b3AgKyB0aGlzLnNpemVbMV0gLyAyICsgdGhpcy5vcHRpb25zLm9mZnNldCA8IHRpdGxlYmFyLm91dGVySGVpZ2h0KFRSVUUpKTtcXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdF9wYXJzZUNvcm5lcjogZnVuY3Rpb24gX3BhcnNlQ29ybmVyKGNvcm5lcikge1xcblxcdFxcdFxcdFxcdHZhciBteSA9IHRoaXMucXRpcC5vcHRpb25zLnBvc2l0aW9uLm15O1xcblxcblxcdFxcdFxcdFxcdC8vIERldGVjdCBjb3JuZXIgYW5kIG1pbWljIHByb3BlcnRpZXNcXG5cXHRcXHRcXHRcXHRpZiAoY29ybmVyID09PSBGQUxTRSB8fCBteSA9PT0gRkFMU0UpIHtcXG5cXHRcXHRcXHRcXHRcXHRjb3JuZXIgPSBGQUxTRTtcXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKGNvcm5lciA9PT0gVFJVRSkge1xcblxcdFxcdFxcdFxcdFxcdGNvcm5lciA9IG5ldyBDT1JORVIobXkuc3RyaW5nKCkpO1xcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoIWNvcm5lci5zdHJpbmcpIHtcXG5cXHRcXHRcXHRcXHRcXHRjb3JuZXIgPSBuZXcgQ09STkVSKGNvcm5lcik7XFxuXFx0XFx0XFx0XFx0XFx0Y29ybmVyLmZpeGVkID0gVFJVRTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIGNvcm5lcjtcXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdF9wYXJzZVdpZHRoOiBmdW5jdGlvbiBfcGFyc2VXaWR0aChjb3JuZXIsIHNpZGUsIHVzZSkge1xcblxcdFxcdFxcdFxcdHZhciBlbGVtZW50cyA9IHRoaXMucXRpcC5lbGVtZW50cyxcXG5cXHRcXHRcXHRcXHQgICAgcHJvcCA9IEJPUkRFUiArIGNhbWVsKHNpZGUpICsgJ1dpZHRoJztcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gKHVzZSA/IGludENzcyh1c2UsIHByb3ApIDogaW50Q3NzKGVsZW1lbnRzLmNvbnRlbnQsIHByb3ApIHx8IGludENzcyh0aGlzLl91c2VUaXRsZShjb3JuZXIpICYmIGVsZW1lbnRzLnRpdGxlYmFyIHx8IGVsZW1lbnRzLmNvbnRlbnQsIHByb3ApIHx8IGludENzcyhlbGVtZW50cy50b29sdGlwLCBwcm9wKSkgfHwgMDtcXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdF9wYXJzZVJhZGl1czogZnVuY3Rpb24gX3BhcnNlUmFkaXVzKGNvcm5lcikge1xcblxcdFxcdFxcdFxcdHZhciBlbGVtZW50cyA9IHRoaXMucXRpcC5lbGVtZW50cyxcXG5cXHRcXHRcXHRcXHQgICAgcHJvcCA9IEJPUkRFUiArIGNhbWVsKGNvcm5lci55KSArIGNhbWVsKGNvcm5lci54KSArICdSYWRpdXMnO1xcblxcblxcdFxcdFxcdFxcdHJldHVybiBCUk9XU0VSLmllIDwgOSA/IDAgOiBpbnRDc3ModGhpcy5fdXNlVGl0bGUoY29ybmVyKSAmJiBlbGVtZW50cy50aXRsZWJhciB8fCBlbGVtZW50cy5jb250ZW50LCBwcm9wKSB8fCBpbnRDc3MoZWxlbWVudHMudG9vbHRpcCwgcHJvcCkgfHwgMDtcXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdF9pbnZhbGlkQ29sb3VyOiBmdW5jdGlvbiBfaW52YWxpZENvbG91cihlbGVtLCBwcm9wLCBjb21wYXJlKSB7XFxuXFx0XFx0XFx0XFx0dmFyIHZhbCA9IGVsZW0uY3NzKHByb3ApO1xcblxcdFxcdFxcdFxcdHJldHVybiAhdmFsIHx8IGNvbXBhcmUgJiYgdmFsID09PSBlbGVtLmNzcyhjb21wYXJlKSB8fCBJTlZBTElELnRlc3QodmFsKSA/IEZBTFNFIDogdmFsO1xcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0X3BhcnNlQ29sb3VyczogZnVuY3Rpb24gX3BhcnNlQ29sb3Vycyhjb3JuZXIpIHtcXG5cXHRcXHRcXHRcXHR2YXIgZWxlbWVudHMgPSB0aGlzLnF0aXAuZWxlbWVudHMsXFxuXFx0XFx0XFx0XFx0ICAgIHRpcCA9IHRoaXMuZWxlbWVudC5jc3MoJ2Nzc1RleHQnLCAnJyksXFxuXFx0XFx0XFx0XFx0ICAgIGJvcmRlclNpZGUgPSBCT1JERVIgKyBjYW1lbChjb3JuZXJbY29ybmVyLnByZWNlZGFuY2VdKSArIGNhbWVsKENPTE9SKSxcXG5cXHRcXHRcXHRcXHQgICAgY29sb3JFbGVtID0gdGhpcy5fdXNlVGl0bGUoY29ybmVyKSAmJiBlbGVtZW50cy50aXRsZWJhciB8fCBlbGVtZW50cy5jb250ZW50LFxcblxcdFxcdFxcdFxcdCAgICBjc3MgPSB0aGlzLl9pbnZhbGlkQ29sb3VyLFxcblxcdFxcdFxcdFxcdCAgICBjb2xvciA9IFtdO1xcblxcblxcdFxcdFxcdFxcdC8vIEF0dGVtcHQgdG8gZGV0ZWN0IHRoZSBiYWNrZ3JvdW5kIGNvbG91ciBmcm9tIHZhcmlvdXMgZWxlbWVudHMsIGxlZnQtdG8tcmlnaHQgcHJlY2VkYW5jZVxcblxcdFxcdFxcdFxcdGNvbG9yWzBdID0gY3NzKHRpcCwgQkdfQ09MT1IpIHx8IGNzcyhjb2xvckVsZW0sIEJHX0NPTE9SKSB8fCBjc3MoZWxlbWVudHMuY29udGVudCwgQkdfQ09MT1IpIHx8IGNzcyhlbGVtZW50cy50b29sdGlwLCBCR19DT0xPUikgfHwgdGlwLmNzcyhCR19DT0xPUik7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQXR0ZW1wdCB0byBkZXRlY3QgdGhlIGNvcnJlY3QgYm9yZGVyIHNpZGUgY29sb3VyIGZyb20gdmFyaW91cyBlbGVtZW50cywgbGVmdC10by1yaWdodCBwcmVjZWRhbmNlXFxuXFx0XFx0XFx0XFx0Y29sb3JbMV0gPSBjc3ModGlwLCBib3JkZXJTaWRlLCBDT0xPUikgfHwgY3NzKGNvbG9yRWxlbSwgYm9yZGVyU2lkZSwgQ09MT1IpIHx8IGNzcyhlbGVtZW50cy5jb250ZW50LCBib3JkZXJTaWRlLCBDT0xPUikgfHwgY3NzKGVsZW1lbnRzLnRvb2x0aXAsIGJvcmRlclNpZGUsIENPTE9SKSB8fCBlbGVtZW50cy50b29sdGlwLmNzcyhib3JkZXJTaWRlKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBSZXNldCBiYWNrZ3JvdW5kIGFuZCBib3JkZXIgY29sb3Vyc1xcblxcdFxcdFxcdFxcdCQoJyonLCB0aXApLmFkZCh0aXApLmNzcygnY3NzVGV4dCcsIEJHX0NPTE9SICsgJzonICsgVFJBTlNQQVJFTlQgKyBJTVBPUlRBTlQgKyAnOycgKyBCT1JERVIgKyAnOjAnICsgSU1QT1JUQU5UICsgJzsnKTtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gY29sb3I7XFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRfY2FsY3VsYXRlU2l6ZTogZnVuY3Rpb24gX2NhbGN1bGF0ZVNpemUoY29ybmVyKSB7XFxuXFx0XFx0XFx0XFx0dmFyIHkgPSBjb3JuZXIucHJlY2VkYW5jZSA9PT0gWSxcXG5cXHRcXHRcXHRcXHQgICAgd2lkdGggPSB0aGlzLm9wdGlvbnNbJ3dpZHRoJ10sXFxuXFx0XFx0XFx0XFx0ICAgIGhlaWdodCA9IHRoaXMub3B0aW9uc1snaGVpZ2h0J10sXFxuXFx0XFx0XFx0XFx0ICAgIGlzQ2VudGVyID0gY29ybmVyLmFiYnJldigpID09PSAnYycsXFxuXFx0XFx0XFx0XFx0ICAgIGJhc2UgPSAoeSA/IHdpZHRoIDogaGVpZ2h0KSAqIChpc0NlbnRlciA/IDAuNSA6IDEpLFxcblxcdFxcdFxcdFxcdCAgICBwb3cgPSBNYXRoLnBvdyxcXG5cXHRcXHRcXHRcXHQgICAgcm91bmQgPSBNYXRoLnJvdW5kLFxcblxcdFxcdFxcdFxcdCAgICBiaWdIeXAsXFxuXFx0XFx0XFx0XFx0ICAgIHJhdGlvLFxcblxcdFxcdFxcdFxcdCAgICByZXN1bHQsXFxuXFx0XFx0XFx0XFx0ICAgIHNtYWxsSHlwID0gTWF0aC5zcXJ0KHBvdyhiYXNlLCAyKSArIHBvdyhoZWlnaHQsIDIpKSxcXG5cXHRcXHRcXHRcXHQgICAgaHlwID0gW3RoaXMuYm9yZGVyIC8gYmFzZSAqIHNtYWxsSHlwLCB0aGlzLmJvcmRlciAvIGhlaWdodCAqIHNtYWxsSHlwXTtcXG5cXG5cXHRcXHRcXHRcXHRoeXBbMl0gPSBNYXRoLnNxcnQocG93KGh5cFswXSwgMikgLSBwb3codGhpcy5ib3JkZXIsIDIpKTtcXG5cXHRcXHRcXHRcXHRoeXBbM10gPSBNYXRoLnNxcnQocG93KGh5cFsxXSwgMikgLSBwb3codGhpcy5ib3JkZXIsIDIpKTtcXG5cXG5cXHRcXHRcXHRcXHRiaWdIeXAgPSBzbWFsbEh5cCArIGh5cFsyXSArIGh5cFszXSArIChpc0NlbnRlciA/IDAgOiBoeXBbMF0pO1xcblxcdFxcdFxcdFxcdHJhdGlvID0gYmlnSHlwIC8gc21hbGxIeXA7XFxuXFxuXFx0XFx0XFx0XFx0cmVzdWx0ID0gW3JvdW5kKHJhdGlvICogd2lkdGgpLCByb3VuZChyYXRpbyAqIGhlaWdodCldO1xcblxcdFxcdFxcdFxcdHJldHVybiB5ID8gcmVzdWx0IDogcmVzdWx0LnJldmVyc2UoKTtcXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdC8vIFRpcCBjb29yZGluYXRlcyBjYWxjdWxhdG9yXFxuXFx0XFx0XFx0X2NhbGN1bGF0ZVRpcDogZnVuY3Rpb24gX2NhbGN1bGF0ZVRpcChjb3JuZXIsIHNpemUsIHNjYWxlKSB7XFxuXFx0XFx0XFx0XFx0c2NhbGUgPSBzY2FsZSB8fCAxO1xcblxcdFxcdFxcdFxcdHNpemUgPSBzaXplIHx8IHRoaXMuc2l6ZTtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgd2lkdGggPSBzaXplWzBdICogc2NhbGUsXFxuXFx0XFx0XFx0XFx0ICAgIGhlaWdodCA9IHNpemVbMV0gKiBzY2FsZSxcXG5cXHRcXHRcXHRcXHQgICAgd2lkdGgyID0gTWF0aC5jZWlsKHdpZHRoIC8gMiksXFxuXFx0XFx0XFx0XFx0ICAgIGhlaWdodDIgPSBNYXRoLmNlaWwoaGVpZ2h0IC8gMiksXFxuXFxuXFxuXFx0XFx0XFx0XFx0Ly8gRGVmaW5lIHRpcCBjb29yZGluYXRlcyBpbiB0ZXJtcyBvZiBoZWlnaHQgYW5kIHdpZHRoIHZhbHVlc1xcblxcdFxcdFxcdFxcdHRpcHMgPSB7XFxuXFx0XFx0XFx0XFx0XFx0YnI6IFswLCAwLCB3aWR0aCwgaGVpZ2h0LCB3aWR0aCwgMF0sXFxuXFx0XFx0XFx0XFx0XFx0Ymw6IFswLCAwLCB3aWR0aCwgMCwgMCwgaGVpZ2h0XSxcXG5cXHRcXHRcXHRcXHRcXHR0cjogWzAsIGhlaWdodCwgd2lkdGgsIDAsIHdpZHRoLCBoZWlnaHRdLFxcblxcdFxcdFxcdFxcdFxcdHRsOiBbMCwgMCwgMCwgaGVpZ2h0LCB3aWR0aCwgaGVpZ2h0XSxcXG5cXHRcXHRcXHRcXHRcXHR0YzogWzAsIGhlaWdodCwgd2lkdGgyLCAwLCB3aWR0aCwgaGVpZ2h0XSxcXG5cXHRcXHRcXHRcXHRcXHRiYzogWzAsIDAsIHdpZHRoLCAwLCB3aWR0aDIsIGhlaWdodF0sXFxuXFx0XFx0XFx0XFx0XFx0cmM6IFswLCAwLCB3aWR0aCwgaGVpZ2h0MiwgMCwgaGVpZ2h0XSxcXG5cXHRcXHRcXHRcXHRcXHRsYzogW3dpZHRoLCAwLCB3aWR0aCwgaGVpZ2h0LCAwLCBoZWlnaHQyXVxcblxcdFxcdFxcdFxcdH07XFxuXFxuXFx0XFx0XFx0XFx0Ly8gU2V0IGNvbW1vbiBzaWRlIHNoYXBlc1xcblxcdFxcdFxcdFxcdHRpcHMubHQgPSB0aXBzLmJyO3RpcHMucnQgPSB0aXBzLmJsO1xcblxcdFxcdFxcdFxcdHRpcHMubGIgPSB0aXBzLnRyO3RpcHMucmIgPSB0aXBzLnRsO1xcblxcblxcdFxcdFxcdFxcdHJldHVybiB0aXBzW2Nvcm5lci5hYmJyZXYoKV07XFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHQvLyBUaXAgY29vcmRpbmF0ZXMgZHJhd2VyIChjYW52YXMpXFxuXFx0XFx0XFx0X2RyYXdDb29yZHM6IGZ1bmN0aW9uIF9kcmF3Q29vcmRzKGNvbnRleHQsIGNvb3Jkcykge1xcblxcdFxcdFxcdFxcdGNvbnRleHQuYmVnaW5QYXRoKCk7XFxuXFx0XFx0XFx0XFx0Y29udGV4dC5tb3ZlVG8oY29vcmRzWzBdLCBjb29yZHNbMV0pO1xcblxcdFxcdFxcdFxcdGNvbnRleHQubGluZVRvKGNvb3Jkc1syXSwgY29vcmRzWzNdKTtcXG5cXHRcXHRcXHRcXHRjb250ZXh0LmxpbmVUbyhjb29yZHNbNF0sIGNvb3Jkc1s1XSk7XFxuXFx0XFx0XFx0XFx0Y29udGV4dC5jbG9zZVBhdGgoKTtcXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKCkge1xcblxcdFxcdFxcdFxcdC8vIERldGVybWluZSB0aXAgY29ybmVyXFxuXFx0XFx0XFx0XFx0dmFyIGMgPSB0aGlzLmNvcm5lciA9IChIQVNDQU5WQVMgfHwgQlJPV1NFUi5pZSkgJiYgdGhpcy5fcGFyc2VDb3JuZXIodGhpcy5vcHRpb25zLmNvcm5lcik7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSWYgd2UgaGF2ZSBhIHRpcCBjb3JuZXIuLi5cXG5cXHRcXHRcXHRcXHRpZiAodGhpcy5lbmFibGVkID0gISF0aGlzLmNvcm5lciAmJiB0aGlzLmNvcm5lci5hYmJyZXYoKSAhPT0gJ2MnKSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gQ2FjaGUgaXRcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnF0aXAuY2FjaGUuY29ybmVyID0gYy5jbG9uZSgpO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIENyZWF0ZSBpdFxcblxcdFxcdFxcdFxcdFxcdHRoaXMudXBkYXRlKCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIFRvZ2dsZSB0aXAgZWxlbWVudFxcblxcdFxcdFxcdFxcdHRoaXMuZWxlbWVudC50b2dnbGUodGhpcy5lbmFibGVkKTtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5jb3JuZXI7XFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHR1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShjb3JuZXIsIHBvc2l0aW9uKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCF0aGlzLmVuYWJsZWQpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGVsZW1lbnRzID0gdGhpcy5xdGlwLmVsZW1lbnRzLFxcblxcdFxcdFxcdFxcdCAgICB0aXAgPSB0aGlzLmVsZW1lbnQsXFxuXFx0XFx0XFx0XFx0ICAgIGlubmVyID0gdGlwLmNoaWxkcmVuKCksXFxuXFx0XFx0XFx0XFx0ICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXFxuXFx0XFx0XFx0XFx0ICAgIGN1clNpemUgPSB0aGlzLnNpemUsXFxuXFx0XFx0XFx0XFx0ICAgIG1pbWljID0gb3B0aW9ucy5taW1pYyxcXG5cXHRcXHRcXHRcXHQgICAgcm91bmQgPSBNYXRoLnJvdW5kLFxcblxcdFxcdFxcdFxcdCAgICBjb2xvcixcXG5cXHRcXHRcXHRcXHQgICAgcHJlY2VkYW5jZSxcXG5cXHRcXHRcXHRcXHQgICAgY29udGV4dCxcXG5cXHRcXHRcXHRcXHQgICAgY29vcmRzLFxcblxcdFxcdFxcdFxcdCAgICBiaWdDb29yZHMsXFxuXFx0XFx0XFx0XFx0ICAgIHRyYW5zbGF0ZSxcXG5cXHRcXHRcXHRcXHQgICAgbmV3U2l6ZSxcXG5cXHRcXHRcXHRcXHQgICAgYm9yZGVyLFxcblxcdFxcdFxcdFxcdCAgICBCQUNLSU5HX1NUT1JFX1JBVElPO1xcblxcblxcdFxcdFxcdFxcdC8vIFJlLWRldGVybWluZSB0aXAgaWYgbm90IGFscmVhZHkgc2V0XFxuXFx0XFx0XFx0XFx0aWYgKCFjb3JuZXIpIHtcXG5cXHRcXHRcXHRcXHRcXHRjb3JuZXIgPSB0aGlzLnF0aXAuY2FjaGUuY29ybmVyIHx8IHRoaXMuY29ybmVyO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBVc2UgY29ybmVyIHByb3BlcnR5IGlmIHdlIGRldGVjdCBhbiBpbnZhbGlkIG1pbWljIHZhbHVlXFxuXFx0XFx0XFx0XFx0aWYgKG1pbWljID09PSBGQUxTRSkge1xcblxcdFxcdFxcdFxcdFxcdG1pbWljID0gY29ybmVyO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBPdGhlcndpc2UgaW5oZXJpdCBtaW1pYyBwcm9wZXJ0aWVzIGZyb20gdGhlIGNvcm5lciBvYmplY3QgYXMgbmVjZXNzYXJ5XFxuXFx0XFx0XFx0XFx0ZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0bWltaWMgPSBuZXcgQ09STkVSKG1pbWljKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRtaW1pYy5wcmVjZWRhbmNlID0gY29ybmVyLnByZWNlZGFuY2U7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKG1pbWljLnggPT09ICdpbmhlcml0Jykge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG1pbWljLnggPSBjb3JuZXIueDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2UgaWYgKG1pbWljLnkgPT09ICdpbmhlcml0Jykge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG1pbWljLnkgPSBjb3JuZXIueTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2UgaWYgKG1pbWljLnggPT09IG1pbWljLnkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRtaW1pY1tjb3JuZXIucHJlY2VkYW5jZV0gPSBjb3JuZXJbY29ybmVyLnByZWNlZGFuY2VdO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0cHJlY2VkYW5jZSA9IG1pbWljLnByZWNlZGFuY2U7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gRW5zdXJlIHRoZSB0aXAgd2lkdGguaGVpZ2h0IGFyZSByZWxhdGl2ZSB0byB0aGUgdGlwIHBvc2l0aW9uXFxuXFx0XFx0XFx0XFx0aWYgKGNvcm5lci5wcmVjZWRhbmNlID09PSBYKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fc3dhcERpbWVuc2lvbnMoKTtcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX3Jlc2V0RGltZW5zaW9ucygpO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBVcGRhdGUgb3VyIGNvbG91cnNcXG5cXHRcXHRcXHRcXHRjb2xvciA9IHRoaXMuY29sb3IgPSB0aGlzLl9wYXJzZUNvbG91cnMoY29ybmVyKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBEZXRlY3QgYm9yZGVyIHdpZHRoLCB0YWtpbmcgaW50byBhY2NvdW50IGNvbG91cnNcXG5cXHRcXHRcXHRcXHRpZiAoY29sb3JbMV0gIT09IFRSQU5TUEFSRU5UKSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gR3JhYiBib3JkZXIgd2lkdGhcXG5cXHRcXHRcXHRcXHRcXHRib3JkZXIgPSB0aGlzLmJvcmRlciA9IHRoaXMuX3BhcnNlV2lkdGgoY29ybmVyLCBjb3JuZXJbY29ybmVyLnByZWNlZGFuY2VdKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBJZiBib3JkZXIgd2lkdGggaXNuJ3QgemVybywgdXNlIGJvcmRlciBjb2xvciBhcyBmaWxsIGlmIGl0J3Mgbm90IGludmFsaWQgKDEuMCBzdHlsZSB0aXBzKVxcblxcdFxcdFxcdFxcdFxcdGlmIChvcHRpb25zLmJvcmRlciAmJiBib3JkZXIgPCAxICYmICFJTlZBTElELnRlc3QoY29sb3JbMV0pKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y29sb3JbMF0gPSBjb2xvclsxXTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gU2V0IGJvcmRlciB3aWR0aCAodXNlIGRldGVjdGVkIGJvcmRlciB3aWR0aCBpZiBvcHRpb25zLmJvcmRlciBpcyB0cnVlKVxcblxcdFxcdFxcdFxcdFxcdHRoaXMuYm9yZGVyID0gYm9yZGVyID0gb3B0aW9ucy5ib3JkZXIgIT09IFRSVUUgPyBvcHRpb25zLmJvcmRlciA6IGJvcmRlcjtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQm9yZGVyIGNvbG91ciB3YXMgaW52YWxpZCwgc2V0IGJvcmRlciB0byB6ZXJvXFxuXFx0XFx0XFx0XFx0ZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5ib3JkZXIgPSBib3JkZXIgPSAwO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBEZXRlcm1pbmUgdGlwIHNpemVcXG5cXHRcXHRcXHRcXHRuZXdTaXplID0gdGhpcy5zaXplID0gdGhpcy5fY2FsY3VsYXRlU2l6ZShjb3JuZXIpO1xcblxcdFxcdFxcdFxcdHRpcC5jc3Moe1xcblxcdFxcdFxcdFxcdFxcdHdpZHRoOiBuZXdTaXplWzBdLFxcblxcdFxcdFxcdFxcdFxcdGhlaWdodDogbmV3U2l6ZVsxXSxcXG5cXHRcXHRcXHRcXHRcXHRsaW5lSGVpZ2h0OiBuZXdTaXplWzFdICsgJ3B4J1xcblxcdFxcdFxcdFxcdH0pO1xcblxcblxcdFxcdFxcdFxcdC8vIENhbGN1bGF0ZSB0aXAgdHJhbnNsYXRpb25cXG5cXHRcXHRcXHRcXHRpZiAoY29ybmVyLnByZWNlZGFuY2UgPT09IFkpIHtcXG5cXHRcXHRcXHRcXHRcXHR0cmFuc2xhdGUgPSBbcm91bmQobWltaWMueCA9PT0gTEVGVCA/IGJvcmRlciA6IG1pbWljLnggPT09IFJJR0hUID8gbmV3U2l6ZVswXSAtIGN1clNpemVbMF0gLSBib3JkZXIgOiAobmV3U2l6ZVswXSAtIGN1clNpemVbMF0pIC8gMiksIHJvdW5kKG1pbWljLnkgPT09IFRPUCA/IG5ld1NpemVbMV0gLSBjdXJTaXplWzFdIDogMCldO1xcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0dHJhbnNsYXRlID0gW3JvdW5kKG1pbWljLnggPT09IExFRlQgPyBuZXdTaXplWzBdIC0gY3VyU2l6ZVswXSA6IDApLCByb3VuZChtaW1pYy55ID09PSBUT1AgPyBib3JkZXIgOiBtaW1pYy55ID09PSBCT1RUT00gPyBuZXdTaXplWzFdIC0gY3VyU2l6ZVsxXSAtIGJvcmRlciA6IChuZXdTaXplWzFdIC0gY3VyU2l6ZVsxXSkgLyAyKV07XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIENhbnZhcyBkcmF3aW5nIGltcGxlbWVudGF0aW9uXFxuXFx0XFx0XFx0XFx0aWYgKEhBU0NBTlZBUykge1xcblxcdFxcdFxcdFxcdFxcdC8vIEdyYWIgY2FudmFzIGNvbnRleHQgYW5kIGNsZWFyL3NhdmUgaXRcXG5cXHRcXHRcXHRcXHRcXHRjb250ZXh0ID0gaW5uZXJbMF0uZ2V0Q29udGV4dCgnMmQnKTtcXG5cXHRcXHRcXHRcXHRcXHRjb250ZXh0LnJlc3RvcmUoKTtjb250ZXh0LnNhdmUoKTtcXG5cXHRcXHRcXHRcXHRcXHRjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCA2MDAwLCA2MDAwKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBDYWxjdWxhdGUgY29vcmRpbmF0ZXNcXG5cXHRcXHRcXHRcXHRcXHRjb29yZHMgPSB0aGlzLl9jYWxjdWxhdGVUaXAobWltaWMsIGN1clNpemUsIFNDQUxFKTtcXG5cXHRcXHRcXHRcXHRcXHRiaWdDb29yZHMgPSB0aGlzLl9jYWxjdWxhdGVUaXAobWltaWMsIHRoaXMuc2l6ZSwgU0NBTEUpO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIFNldCB0aGUgY2FudmFzIHNpemUgdXNpbmcgY2FsY3VsYXRlZCBzaXplXFxuXFx0XFx0XFx0XFx0XFx0aW5uZXIuYXR0cihXSURUSCwgbmV3U2l6ZVswXSAqIFNDQUxFKS5hdHRyKEhFSUdIVCwgbmV3U2l6ZVsxXSAqIFNDQUxFKTtcXG5cXHRcXHRcXHRcXHRcXHRpbm5lci5jc3MoV0lEVEgsIG5ld1NpemVbMF0pLmNzcyhIRUlHSFQsIG5ld1NpemVbMV0pO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIERyYXcgdGhlIG91dGVyLXN0cm9rZSB0aXBcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9kcmF3Q29vcmRzKGNvbnRleHQsIGJpZ0Nvb3Jkcyk7XFxuXFx0XFx0XFx0XFx0XFx0Y29udGV4dC5maWxsU3R5bGUgPSBjb2xvclsxXTtcXG5cXHRcXHRcXHRcXHRcXHRjb250ZXh0LmZpbGwoKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBEcmF3IHRoZSBhY3R1YWwgdGlwXFxuXFx0XFx0XFx0XFx0XFx0Y29udGV4dC50cmFuc2xhdGUodHJhbnNsYXRlWzBdICogU0NBTEUsIHRyYW5zbGF0ZVsxXSAqIFNDQUxFKTtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9kcmF3Q29vcmRzKGNvbnRleHQsIGNvb3Jkcyk7XFxuXFx0XFx0XFx0XFx0XFx0Y29udGV4dC5maWxsU3R5bGUgPSBjb2xvclswXTtcXG5cXHRcXHRcXHRcXHRcXHRjb250ZXh0LmZpbGwoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gVk1MIChJRSBQcm9wcmlldGFyeSBpbXBsZW1lbnRhdGlvbilcXG5cXHRcXHRcXHRcXHRlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBDYWxjdWxhdGUgY29vcmRpbmF0ZXNcXG5cXHRcXHRcXHRcXHRcXHRcXHRjb29yZHMgPSB0aGlzLl9jYWxjdWxhdGVUaXAobWltaWMpO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIFNldHVwIGNvb3JkaW5hdGVzIHN0cmluZ1xcblxcdFxcdFxcdFxcdFxcdFxcdGNvb3JkcyA9ICdtJyArIGNvb3Jkc1swXSArICcsJyArIGNvb3Jkc1sxXSArICcgbCcgKyBjb29yZHNbMl0gKyAnLCcgKyBjb29yZHNbM10gKyAnICcgKyBjb29yZHNbNF0gKyAnLCcgKyBjb29yZHNbNV0gKyAnIHhlJztcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBTZXR1cCBWTUwtc3BlY2lmaWMgb2Zmc2V0IGZvciBwaXhlbC1wZXJmZWN0aW9uXFxuXFx0XFx0XFx0XFx0XFx0XFx0dHJhbnNsYXRlWzJdID0gYm9yZGVyICYmIC9eKHJ8YikvaS50ZXN0KGNvcm5lci5zdHJpbmcoKSkgPyBCUk9XU0VSLmllID09PSA4ID8gMiA6IDEgOiAwO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIFNldCBpbml0aWFsIENTU1xcblxcdFxcdFxcdFxcdFxcdFxcdGlubmVyLmNzcyh7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y29vcmRzaXplOiBuZXdTaXplWzBdICsgYm9yZGVyICsgJyAnICsgKG5ld1NpemVbMV0gKyBib3JkZXIpLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGFudGlhbGlhczogJycgKyAobWltaWMuc3RyaW5nKCkuaW5kZXhPZihDRU5URVIpID4gLTEpLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGxlZnQ6IHRyYW5zbGF0ZVswXSAtIHRyYW5zbGF0ZVsyXSAqIE51bWJlcihwcmVjZWRhbmNlID09PSBYKSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0b3A6IHRyYW5zbGF0ZVsxXSAtIHRyYW5zbGF0ZVsyXSAqIE51bWJlcihwcmVjZWRhbmNlID09PSBZKSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR3aWR0aDogbmV3U2l6ZVswXSArIGJvcmRlcixcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRoZWlnaHQ6IG5ld1NpemVbMV0gKyBib3JkZXJcXG5cXHRcXHRcXHRcXHRcXHRcXHR9KS5lYWNoKGZ1bmN0aW9uIChpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyICR0aGlzID0gJCh0aGlzKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBTZXQgc2hhcGUgc3BlY2lmaWMgYXR0cmlidXRlc1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdCR0aGlzWyR0aGlzLnByb3AgPyAncHJvcCcgOiAnYXR0ciddKHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjb29yZHNpemU6IG5ld1NpemVbMF0gKyBib3JkZXIgKyAnICcgKyAobmV3U2l6ZVsxXSArIGJvcmRlciksXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cGF0aDogY29vcmRzLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGZpbGxjb2xvcjogY29sb3JbMF0sXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZmlsbGVkOiAhIWksXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0c3Ryb2tlZDogIWlcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9KS50b2dnbGUoISEoYm9yZGVyIHx8IGkpKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBDaGVjayBpZiBib3JkZXIgaXMgZW5hYmxlZCBhbmQgYWRkIHN0cm9rZSBlbGVtZW50XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0IWkgJiYgJHRoaXMuaHRtbChjcmVhdGVWTUwoJ3N0cm9rZScsICd3ZWlnaHQ9XFxcIicgKyBib3JkZXIgKiAyICsgJ3B4XFxcIiBjb2xvcj1cXFwiJyArIGNvbG9yWzFdICsgJ1xcXCIgbWl0ZXJsaW1pdD1cXFwiMTAwMFxcXCIgam9pbnN0eWxlPVxcXCJtaXRlclxcXCInKSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIE9wZXJhIGJ1ZyAjMzU3IC0gSW5jb3JyZWN0IHRpcCBwb3NpdGlvblxcblxcdFxcdFxcdFxcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9DcmFnYTg5L3FUaXAyL2lzc3Vlcy8zNjdcXG5cXHRcXHRcXHRcXHR3aW5kb3cub3BlcmEgJiYgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZWxlbWVudHMudGlwLmNzcyh7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZGlzcGxheTogJ2lubGluZS1ibG9jaycsXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmlzaWJpbGl0eTogJ3Zpc2libGUnXFxuXFx0XFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0XFx0fSwgMSk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gUG9zaXRpb24gaWYgbmVlZGVkXFxuXFx0XFx0XFx0XFx0aWYgKHBvc2l0aW9uICE9PSBGQUxTRSkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuY2FsY3VsYXRlKGNvcm5lciwgbmV3U2l6ZSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0Y2FsY3VsYXRlOiBmdW5jdGlvbiBjYWxjdWxhdGUoY29ybmVyLCBzaXplKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCF0aGlzLmVuYWJsZWQpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gRkFMU0U7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHZhciBzZWxmID0gdGhpcyxcXG5cXHRcXHRcXHRcXHQgICAgZWxlbWVudHMgPSB0aGlzLnF0aXAuZWxlbWVudHMsXFxuXFx0XFx0XFx0XFx0ICAgIHRpcCA9IHRoaXMuZWxlbWVudCxcXG5cXHRcXHRcXHRcXHQgICAgdXNlck9mZnNldCA9IHRoaXMub3B0aW9ucy5vZmZzZXQsXFxuXFx0XFx0XFx0XFx0ICAgIGlzV2lkZ2V0ID0gZWxlbWVudHMudG9vbHRpcC5oYXNDbGFzcygndWktd2lkZ2V0JyksXFxuXFx0XFx0XFx0XFx0ICAgIHBvc2l0aW9uID0ge30sXFxuXFx0XFx0XFx0XFx0ICAgIHByZWNlZGFuY2UsXFxuXFx0XFx0XFx0XFx0ICAgIGNvcm5lcnM7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSW5oZXJpdCBjb3JuZXIgaWYgbm90IHByb3ZpZGVkXFxuXFx0XFx0XFx0XFx0Y29ybmVyID0gY29ybmVyIHx8IHRoaXMuY29ybmVyO1xcblxcdFxcdFxcdFxcdHByZWNlZGFuY2UgPSBjb3JuZXIucHJlY2VkYW5jZTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBEZXRlcm1pbmUgd2hpY2ggdGlwIGRpbWVuc2lvbiB0byB1c2UgZm9yIGFkanVzdG1lbnRcXG5cXHRcXHRcXHRcXHRzaXplID0gc2l6ZSB8fCB0aGlzLl9jYWxjdWxhdGVTaXplKGNvcm5lcik7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gU2V0dXAgY29ybmVycyBhbmQgb2Zmc2V0IGFycmF5XFxuXFx0XFx0XFx0XFx0Y29ybmVycyA9IFtjb3JuZXIueCwgY29ybmVyLnldO1xcblxcdFxcdFxcdFxcdGlmIChwcmVjZWRhbmNlID09PSBYKSB7XFxuXFx0XFx0XFx0XFx0XFx0Y29ybmVycy5yZXZlcnNlKCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIENhbGN1bGF0ZSB0aXAgcG9zaXRpb25cXG5cXHRcXHRcXHRcXHQkLmVhY2goY29ybmVycywgZnVuY3Rpb24gKGksIHNpZGUpIHtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgYiwgYmMsIGJyO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmIChzaWRlID09PSBDRU5URVIpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRiID0gcHJlY2VkYW5jZSA9PT0gWSA/IExFRlQgOiBUT1A7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cG9zaXRpb25bYl0gPSAnNTAlJztcXG5cXHRcXHRcXHRcXHRcXHRcXHRwb3NpdGlvbltNQVJHSU4gKyAnLScgKyBiXSA9IC1NYXRoLnJvdW5kKHNpemVbcHJlY2VkYW5jZSA9PT0gWSA/IDAgOiAxXSAvIDIpICsgdXNlck9mZnNldDtcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdGIgPSBzZWxmLl9wYXJzZVdpZHRoKGNvcm5lciwgc2lkZSwgZWxlbWVudHMudG9vbHRpcCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YmMgPSBzZWxmLl9wYXJzZVdpZHRoKGNvcm5lciwgc2lkZSwgZWxlbWVudHMuY29udGVudCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YnIgPSBzZWxmLl9wYXJzZVJhZGl1cyhjb3JuZXIpO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHBvc2l0aW9uW3NpZGVdID0gTWF0aC5tYXgoLXNlbGYuYm9yZGVyLCBpID8gYmMgOiB1c2VyT2Zmc2V0ICsgKGJyID4gYiA/IGJyIDogLWIpKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fSk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQWRqdXN0IGZvciB0aXAgc2l6ZVxcblxcdFxcdFxcdFxcdHBvc2l0aW9uW2Nvcm5lcltwcmVjZWRhbmNlXV0gLT0gc2l6ZVtwcmVjZWRhbmNlID09PSBYID8gMCA6IDFdO1xcblxcblxcdFxcdFxcdFxcdC8vIFNldCBhbmQgcmV0dXJuIG5ldyBwb3NpdGlvblxcblxcdFxcdFxcdFxcdHRpcC5jc3MoeyBtYXJnaW46ICcnLCB0b3A6ICcnLCBib3R0b206ICcnLCBsZWZ0OiAnJywgcmlnaHQ6ICcnIH0pLmNzcyhwb3NpdGlvbik7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHBvc2l0aW9uO1xcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0cmVwb3NpdGlvbjogZnVuY3Rpb24gcmVwb3NpdGlvbihldmVudCwgYXBpLCBwb3MsIHZpZXdwb3J0KSB7XFxuXFx0XFx0XFx0XFx0aWYgKCF0aGlzLmVuYWJsZWQpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHZhciBjYWNoZSA9IGFwaS5jYWNoZSxcXG5cXHRcXHRcXHRcXHQgICAgbmV3Q29ybmVyID0gdGhpcy5jb3JuZXIuY2xvbmUoKSxcXG5cXHRcXHRcXHRcXHQgICAgYWRqdXN0ID0gcG9zLmFkanVzdGVkLFxcblxcdFxcdFxcdFxcdCAgICBtZXRob2QgPSBhcGkub3B0aW9ucy5wb3NpdGlvbi5hZGp1c3QubWV0aG9kLnNwbGl0KCcgJyksXFxuXFx0XFx0XFx0XFx0ICAgIGhvcml6b250YWwgPSBtZXRob2RbMF0sXFxuXFx0XFx0XFx0XFx0ICAgIHZlcnRpY2FsID0gbWV0aG9kWzFdIHx8IG1ldGhvZFswXSxcXG5cXHRcXHRcXHRcXHQgICAgc2hpZnQgPSB7IGxlZnQ6IEZBTFNFLCB0b3A6IEZBTFNFLCB4OiAwLCB5OiAwIH0sXFxuXFx0XFx0XFx0XFx0ICAgIG9mZnNldCxcXG5cXHRcXHRcXHRcXHQgICAgY3NzID0ge30sXFxuXFx0XFx0XFx0XFx0ICAgIHByb3BzO1xcblxcblxcdFxcdFxcdFxcdGZ1bmN0aW9uIHNoaWZ0ZmxpcChkaXJlY3Rpb24sIHByZWNlZGFuY2UsIHBvcHBvc2l0ZSwgc2lkZSwgb3Bwb3NpdGUpIHtcXG5cXHRcXHRcXHRcXHRcXHQvLyBIb3Jpem9udGFsIC0gU2hpZnQgb3IgZmxpcCBtZXRob2RcXG5cXHRcXHRcXHRcXHRcXHRpZiAoZGlyZWN0aW9uID09PSBTSElGVCAmJiBuZXdDb3JuZXIucHJlY2VkYW5jZSA9PT0gcHJlY2VkYW5jZSAmJiBhZGp1c3Rbc2lkZV0gJiYgbmV3Q29ybmVyW3BvcHBvc2l0ZV0gIT09IENFTlRFUikge1xcblxcdFxcdFxcdFxcdFxcdFxcdG5ld0Nvcm5lci5wcmVjZWRhbmNlID0gbmV3Q29ybmVyLnByZWNlZGFuY2UgPT09IFggPyBZIDogWDtcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2UgaWYgKGRpcmVjdGlvbiAhPT0gU0hJRlQgJiYgYWRqdXN0W3NpZGVdKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0bmV3Q29ybmVyW3ByZWNlZGFuY2VdID0gbmV3Q29ybmVyW3ByZWNlZGFuY2VdID09PSBDRU5URVIgPyBhZGp1c3Rbc2lkZV0gPiAwID8gc2lkZSA6IG9wcG9zaXRlIDogbmV3Q29ybmVyW3ByZWNlZGFuY2VdID09PSBzaWRlID8gb3Bwb3NpdGUgOiBzaWRlO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0ZnVuY3Rpb24gc2hpZnRvbmx5KHh5LCBzaWRlLCBvcHBvc2l0ZSkge1xcblxcdFxcdFxcdFxcdFxcdGlmIChuZXdDb3JuZXJbeHldID09PSBDRU5URVIpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRjc3NbTUFSR0lOICsgJy0nICsgc2lkZV0gPSBzaGlmdFt4eV0gPSBvZmZzZXRbTUFSR0lOICsgJy0nICsgc2lkZV0gLSBhZGp1c3Rbc2lkZV07XFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRwcm9wcyA9IG9mZnNldFtvcHBvc2l0ZV0gIT09IHVuZGVmaW5lZCA/IFthZGp1c3Rbc2lkZV0sIC1vZmZzZXRbc2lkZV1dIDogWy1hZGp1c3Rbc2lkZV0sIG9mZnNldFtzaWRlXV07XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKChzaGlmdFt4eV0gPSBNYXRoLm1heChwcm9wc1swXSwgcHJvcHNbMV0pKSA+IHByb3BzWzBdKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cG9zW3NpZGVdIC09IGFkanVzdFtzaWRlXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzaGlmdFtzaWRlXSA9IEZBTFNFO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRjc3Nbb2Zmc2V0W29wcG9zaXRlXSAhPT0gdW5kZWZpbmVkID8gb3Bwb3NpdGUgOiBzaWRlXSA9IHNoaWZ0W3h5XTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIElmIG91ciB0aXAgcG9zaXRpb24gaXNuJ3QgZml4ZWQgZS5nLiBkb2Vzbid0IGFkanVzdCB3aXRoIHZpZXdwb3J0Li4uXFxuXFx0XFx0XFx0XFx0aWYgKHRoaXMuY29ybmVyLmZpeGVkICE9PSBUUlVFKSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gUGVyZm9ybSBzaGlmdC9mbGlwIGFkanVzdG1lbnRzXFxuXFx0XFx0XFx0XFx0XFx0c2hpZnRmbGlwKGhvcml6b250YWwsIFgsIFksIExFRlQsIFJJR0hUKTtcXG5cXHRcXHRcXHRcXHRcXHRzaGlmdGZsaXAodmVydGljYWwsIFksIFgsIFRPUCwgQk9UVE9NKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBVcGRhdGUgYW5kIHJlZHJhdyB0aGUgdGlwIGlmIG5lZWRlZCAoY2hlY2sgY2FjaGVkIGRldGFpbHMgb2YgbGFzdCBkcmF3biB0aXApXFxuXFx0XFx0XFx0XFx0XFx0aWYgKG5ld0Nvcm5lci5zdHJpbmcoKSAhPT0gY2FjaGUuY29ybmVyLnN0cmluZygpIHx8IGNhY2hlLmNvcm5lclRvcCAhPT0gYWRqdXN0LnRvcCB8fCBjYWNoZS5jb3JuZXJMZWZ0ICE9PSBhZGp1c3QubGVmdCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMudXBkYXRlKG5ld0Nvcm5lciwgRkFMU0UpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gU2V0dXAgdGlwIG9mZnNldCBwcm9wZXJ0aWVzXFxuXFx0XFx0XFx0XFx0b2Zmc2V0ID0gdGhpcy5jYWxjdWxhdGUobmV3Q29ybmVyKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBSZWFkanVzdCBvZmZzZXQgb2JqZWN0IHRvIG1ha2UgaXQgbGVmdC90b3BcXG5cXHRcXHRcXHRcXHRpZiAob2Zmc2V0LnJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcXG5cXHRcXHRcXHRcXHRcXHRvZmZzZXQubGVmdCA9IC1vZmZzZXQucmlnaHQ7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGlmIChvZmZzZXQuYm90dG9tICE9PSB1bmRlZmluZWQpIHtcXG5cXHRcXHRcXHRcXHRcXHRvZmZzZXQudG9wID0gLW9mZnNldC5ib3R0b207XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdG9mZnNldC51c2VyID0gdGhpcy5vZmZzZXQ7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gUGVyZm9ybSBzaGlmdCBhZGp1c3RtZW50c1xcblxcdFxcdFxcdFxcdGlmIChzaGlmdC5sZWZ0ID0gaG9yaXpvbnRhbCA9PT0gU0hJRlQgJiYgISFhZGp1c3QubGVmdCkge1xcblxcdFxcdFxcdFxcdFxcdHNoaWZ0b25seShYLCBMRUZULCBSSUdIVCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGlmIChzaGlmdC50b3AgPSB2ZXJ0aWNhbCA9PT0gU0hJRlQgJiYgISFhZGp1c3QudG9wKSB7XFxuXFx0XFx0XFx0XFx0XFx0c2hpZnRvbmx5KFksIFRPUCwgQk9UVE9NKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0LypcXG4gICAgKiBJZiB0aGUgdGlwIGlzIGFkanVzdGVkIGluIGJvdGggZGltZW5zaW9ucywgb3IgaW4gYVxcbiAgICAqIGRpcmVjdGlvbiB0aGF0IHdvdWxkIGNhdXNlIGl0IHRvIGJlIGFueXdoZXJlIGJ1dCB0aGVcXG4gICAgKiBvdXRlciBib3JkZXIsIGhpZGUgaXQhXFxuICAgICovXFxuXFx0XFx0XFx0XFx0dGhpcy5lbGVtZW50LmNzcyhjc3MpLnRvZ2dsZSghKHNoaWZ0LnggJiYgc2hpZnQueSB8fCBuZXdDb3JuZXIueCA9PT0gQ0VOVEVSICYmIHNoaWZ0LnkgfHwgbmV3Q29ybmVyLnkgPT09IENFTlRFUiAmJiBzaGlmdC54KSk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQWRqdXN0IHBvc2l0aW9uIHRvIGFjY29tb2RhdGUgdGlwIGRpbWVuc2lvbnNcXG5cXHRcXHRcXHRcXHRwb3MubGVmdCAtPSBvZmZzZXQubGVmdC5jaGFyQXQgPyBvZmZzZXQudXNlciA6IGhvcml6b250YWwgIT09IFNISUZUIHx8IHNoaWZ0LnRvcCB8fCAhc2hpZnQubGVmdCAmJiAhc2hpZnQudG9wID8gb2Zmc2V0LmxlZnQgKyB0aGlzLmJvcmRlciA6IDA7XFxuXFx0XFx0XFx0XFx0cG9zLnRvcCAtPSBvZmZzZXQudG9wLmNoYXJBdCA/IG9mZnNldC51c2VyIDogdmVydGljYWwgIT09IFNISUZUIHx8IHNoaWZ0LmxlZnQgfHwgIXNoaWZ0LmxlZnQgJiYgIXNoaWZ0LnRvcCA/IG9mZnNldC50b3AgKyB0aGlzLmJvcmRlciA6IDA7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQ2FjaGUgZGV0YWlsc1xcblxcdFxcdFxcdFxcdGNhY2hlLmNvcm5lckxlZnQgPSBhZGp1c3QubGVmdDtjYWNoZS5jb3JuZXJUb3AgPSBhZGp1c3QudG9wO1xcblxcdFxcdFxcdFxcdGNhY2hlLmNvcm5lciA9IG5ld0Nvcm5lci5jbG9uZSgpO1xcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0ZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcXG5cXHRcXHRcXHRcXHQvLyBVbmJpbmQgZXZlbnRzXFxuXFx0XFx0XFx0XFx0dGhpcy5xdGlwLl91bmJpbmQodGhpcy5xdGlwLnRvb2x0aXAsIHRoaXMuX25zKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBSZW1vdmUgdGhlIHRpcCBlbGVtZW50KHMpXFxuXFx0XFx0XFx0XFx0aWYgKHRoaXMucXRpcC5lbGVtZW50cy50aXApIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnF0aXAuZWxlbWVudHMudGlwLmZpbmQoJyonKS5yZW1vdmUoKS5lbmQoKS5yZW1vdmUoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0pO1xcblxcblxcdFxcdFRJUCA9IFBMVUdJTlMudGlwID0gZnVuY3Rpb24gKGFwaSkge1xcblxcdFxcdFxcdHJldHVybiBuZXcgVGlwKGFwaSwgYXBpLm9wdGlvbnMuc3R5bGUudGlwKTtcXG5cXHRcXHR9O1xcblxcblxcdFxcdC8vIEluaXRpYWxpemUgdGlwIG9uIHJlbmRlclxcblxcdFxcdFRJUC5pbml0aWFsaXplID0gJ3JlbmRlcic7XFxuXFxuXFx0XFx0Ly8gU2V0dXAgcGx1Z2luIHNhbml0aXphdGlvbiBvcHRpb25zXFxuXFx0XFx0VElQLnNhbml0aXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcXG5cXHRcXHRcXHRpZiAob3B0aW9ucy5zdHlsZSAmJiAndGlwJyBpbiBvcHRpb25zLnN0eWxlKSB7XFxuXFx0XFx0XFx0XFx0dmFyIG9wdHMgPSBvcHRpb25zLnN0eWxlLnRpcDtcXG5cXHRcXHRcXHRcXHRpZiAoKHR5cGVvZiBvcHRzID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihvcHRzKSkgIT09ICdvYmplY3QnKSB7XFxuXFx0XFx0XFx0XFx0XFx0b3B0cyA9IG9wdGlvbnMuc3R5bGUudGlwID0geyBjb3JuZXI6IG9wdHMgfTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aWYgKCEvc3RyaW5nfGJvb2xlYW4vaS50ZXN0KF90eXBlb2Yob3B0cy5jb3JuZXIpKSkge1xcblxcdFxcdFxcdFxcdFxcdG9wdHMuY29ybmVyID0gVFJVRTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH07XFxuXFxuXFx0XFx0Ly8gQWRkIG5ldyBvcHRpb24gY2hlY2tzIGZvciB0aGUgcGx1Z2luXFxuXFx0XFx0Q0hFQ0tTLnRpcCA9IHtcXG5cXHRcXHRcXHQnXnBvc2l0aW9uLm15fHN0eWxlLnRpcC4oY29ybmVyfG1pbWljfGJvcmRlcikkJzogZnVuY3Rpb24gcG9zaXRpb25NeVN0eWxlVGlwQ29ybmVyTWltaWNCb3JkZXIkKCkge1xcblxcdFxcdFxcdFxcdC8vIE1ha2Ugc3VyZSBhIHRpcCBjYW4gYmUgZHJhd25cXG5cXHRcXHRcXHRcXHR0aGlzLmNyZWF0ZSgpO1xcblxcblxcdFxcdFxcdFxcdC8vIFJlcG9zaXRpb24gdGhlIHRvb2x0aXBcXG5cXHRcXHRcXHRcXHR0aGlzLnF0aXAucmVwb3NpdGlvbigpO1xcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0J15zdHlsZS50aXAuKGhlaWdodHx3aWR0aCkkJzogZnVuY3Rpb24gc3R5bGVUaXBIZWlnaHRXaWR0aCQob2JqKSB7XFxuXFx0XFx0XFx0XFx0Ly8gUmUtc2V0IGRpbWVuc2lvbnMgYW5kIHJlZHJhdyB0aGUgdGlwXFxuXFx0XFx0XFx0XFx0dGhpcy5zaXplID0gW29iai53aWR0aCwgb2JqLmhlaWdodF07XFxuXFx0XFx0XFx0XFx0dGhpcy51cGRhdGUoKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBSZXBvc2l0aW9uIHRoZSB0b29sdGlwXFxuXFx0XFx0XFx0XFx0dGhpcy5xdGlwLnJlcG9zaXRpb24oKTtcXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdCdeY29udGVudC50aXRsZXxzdHlsZS4oY2xhc3Nlc3x3aWRnZXQpJCc6IGZ1bmN0aW9uIGNvbnRlbnRUaXRsZVN0eWxlQ2xhc3Nlc1dpZGdldCQoKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy51cGRhdGUoKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fTtcXG5cXG5cXHRcXHQvLyBFeHRlbmQgb3JpZ2luYWwgcVRpcCBkZWZhdWx0c1xcblxcdFxcdCQuZXh0ZW5kKFRSVUUsIFFUSVAuZGVmYXVsdHMsIHtcXG5cXHRcXHRcXHRzdHlsZToge1xcblxcdFxcdFxcdFxcdHRpcDoge1xcblxcdFxcdFxcdFxcdFxcdGNvcm5lcjogVFJVRSxcXG5cXHRcXHRcXHRcXHRcXHRtaW1pYzogRkFMU0UsXFxuXFx0XFx0XFx0XFx0XFx0d2lkdGg6IDYsXFxuXFx0XFx0XFx0XFx0XFx0aGVpZ2h0OiA2LFxcblxcdFxcdFxcdFxcdFxcdGJvcmRlcjogVFJVRSxcXG5cXHRcXHRcXHRcXHRcXHRvZmZzZXQ6IDBcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0pO1xcblxcdFxcdDt2YXIgTU9EQUwsXFxuXFx0XFx0ICAgIE9WRVJMQVksXFxuXFx0XFx0ICAgIE1PREFMQ0xBU1MgPSAncXRpcC1tb2RhbCcsXFxuXFx0XFx0ICAgIE1PREFMU0VMRUNUT1IgPSAnLicgKyBNT0RBTENMQVNTO1xcblxcblxcdFxcdE9WRVJMQVkgPSBmdW5jdGlvbiBPVkVSTEFZKCkge1xcblxcdFxcdFxcdHZhciBzZWxmID0gdGhpcyxcXG5cXHRcXHRcXHQgICAgZm9jdXNhYmxlRWxlbXMgPSB7fSxcXG5cXHRcXHRcXHQgICAgY3VycmVudCxcXG5cXHRcXHRcXHQgICAgb25MYXN0LFxcblxcdFxcdFxcdCAgICBwcmV2U3RhdGUsXFxuXFx0XFx0XFx0ICAgIGVsZW07XFxuXFxuXFx0XFx0XFx0Ly8gTW9kaWZpZWQgY29kZSBmcm9tIGpRdWVyeSBVSSAxLjEwLjAgc291cmNlXFxuXFx0XFx0XFx0Ly8gaHR0cDovL2NvZGUuanF1ZXJ5LmNvbS91aS8xLjEwLjAvanF1ZXJ5LXVpLmpzXFxuXFx0XFx0XFx0ZnVuY3Rpb24gZm9jdXNhYmxlKGVsZW1lbnQpIHtcXG5cXHRcXHRcXHRcXHQvLyBVc2UgdGhlIGRlZmluZWQgZm9jdXNhYmxlIGNoZWNrZXIgd2hlbiBwb3NzaWJsZVxcblxcdFxcdFxcdFxcdGlmICgkLmV4cHJbJzonXS5mb2N1c2FibGUpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gJC5leHByWyc6J10uZm9jdXNhYmxlO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR2YXIgaXNUYWJJbmRleE5vdE5hTiA9ICFpc05hTigkLmF0dHIoZWxlbWVudCwgJ3RhYmluZGV4JykpLFxcblxcdFxcdFxcdFxcdCAgICBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWUgJiYgZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxcblxcdFxcdFxcdFxcdCAgICBtYXAsXFxuXFx0XFx0XFx0XFx0ICAgIG1hcE5hbWUsXFxuXFx0XFx0XFx0XFx0ICAgIGltZztcXG5cXG5cXHRcXHRcXHRcXHRpZiAoJ2FyZWEnID09PSBub2RlTmFtZSkge1xcblxcdFxcdFxcdFxcdFxcdG1hcCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcXG5cXHRcXHRcXHRcXHRcXHRtYXBOYW1lID0gbWFwLm5hbWU7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCFlbGVtZW50LmhyZWYgfHwgIW1hcE5hbWUgfHwgbWFwLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09ICdtYXAnKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRpbWcgPSAkKCdpbWdbdXNlbWFwPSMnICsgbWFwTmFtZSArICddJylbMF07XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuICEhaW1nICYmIGltZy5pcygnOnZpc2libGUnKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0cmV0dXJuICgvaW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbnxvYmplY3QvLnRlc3Qobm9kZU5hbWUpID8gIWVsZW1lbnQuZGlzYWJsZWQgOiAnYScgPT09IG5vZGVOYW1lID8gZWxlbWVudC5ocmVmIHx8IGlzVGFiSW5kZXhOb3ROYU4gOiBpc1RhYkluZGV4Tm90TmFOXFxuXFx0XFx0XFx0XFx0KTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gRm9jdXMgaW5wdXRzIHVzaW5nIGNhY2hlZCBmb2N1c2FibGUgZWxlbWVudHMgKHNlZSB1cGRhdGUoKSlcXG5cXHRcXHRcXHRmdW5jdGlvbiBmb2N1c0lucHV0cyhibHVyRWxlbXMpIHtcXG5cXHRcXHRcXHRcXHQvLyBCbHVycmluZyBib2R5IGVsZW1lbnQgaW4gSUUgY2F1c2VzIHdpbmRvdy5vcGVuIHdpbmRvd3MgdG8gdW5mb2N1cyFcXG5cXHRcXHRcXHRcXHRpZiAoZm9jdXNhYmxlRWxlbXMubGVuZ3RoIDwgMSAmJiBibHVyRWxlbXMubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0Ymx1ckVsZW1zLm5vdCgnYm9keScpLmJsdXIoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gRm9jdXMgdGhlIGlucHV0c1xcblxcdFxcdFxcdFxcdGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdGZvY3VzYWJsZUVsZW1zLmZpcnN0KCkuZm9jdXMoKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFN0ZWFsIGZvY3VzIGZyb20gZWxlbWVudHMgb3V0c2lkZSB0b29sdGlwXFxuXFx0XFx0XFx0ZnVuY3Rpb24gc3RlYWxGb2N1cyhldmVudCkge1xcblxcdFxcdFxcdFxcdGlmICghZWxlbS5pcygnOnZpc2libGUnKSkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHRhcmdldCA9ICQoZXZlbnQudGFyZ2V0KSxcXG5cXHRcXHRcXHRcXHQgICAgdG9vbHRpcCA9IGN1cnJlbnQudG9vbHRpcCxcXG5cXHRcXHRcXHRcXHQgICAgY29udGFpbmVyID0gdGFyZ2V0LmNsb3Nlc3QoU0VMRUNUT1IpLFxcblxcdFxcdFxcdFxcdCAgICB0YXJnZXRPblRvcDtcXG5cXG5cXHRcXHRcXHRcXHQvLyBEZXRlcm1pbmUgaWYgaW5wdXQgY29udGFpbmVyIHRhcmdldCBpcyBhYm92ZSB0aGlzXFxuXFx0XFx0XFx0XFx0dGFyZ2V0T25Ub3AgPSBjb250YWluZXIubGVuZ3RoIDwgMSA/IEZBTFNFIDogcGFyc2VJbnQoY29udGFpbmVyWzBdLnN0eWxlLnpJbmRleCwgMTApID4gcGFyc2VJbnQodG9vbHRpcFswXS5zdHlsZS56SW5kZXgsIDEwKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBJZiB3ZSdyZSBzaG93aW5nIGEgbW9kYWwsIGJ1dCBmb2N1cyBoYXMgbGFuZGVkIG9uIGFuIGlucHV0IGJlbG93XFxuXFx0XFx0XFx0XFx0Ly8gdGhpcyBtb2RhbCwgZGl2ZXJ0IGZvY3VzIHRvIHRoZSBmaXJzdCB2aXNpYmxlIGlucHV0IGluIHRoaXMgbW9kYWxcXG5cXHRcXHRcXHRcXHQvLyBvciBpZiB3ZSBjYW4ndCBmaW5kIG9uZS4uLiB0aGUgdG9vbHRpcCBpdHNlbGZcXG5cXHRcXHRcXHRcXHRpZiAoIXRhcmdldE9uVG9wICYmIHRhcmdldC5jbG9zZXN0KFNFTEVDVE9SKVswXSAhPT0gdG9vbHRpcFswXSkge1xcblxcdFxcdFxcdFxcdFxcdGZvY3VzSW5wdXRzKHRhcmdldCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIERldGVjdCB3aGVuIHdlIGxlYXZlIHRoZSBsYXN0IGZvY3VzYWJsZSBlbGVtZW50Li4uXFxuXFx0XFx0XFx0XFx0b25MYXN0ID0gZXZlbnQudGFyZ2V0ID09PSBmb2N1c2FibGVFbGVtc1tmb2N1c2FibGVFbGVtcy5sZW5ndGggLSAxXTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0JC5leHRlbmQoc2VsZiwge1xcblxcdFxcdFxcdFxcdGluaXQ6IGZ1bmN0aW9uIGluaXQoKSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gQ3JlYXRlIGRvY3VtZW50IG92ZXJsYXlcXG5cXHRcXHRcXHRcXHRcXHRlbGVtID0gc2VsZi5lbGVtID0gJCgnPGRpdiAvPicsIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZDogJ3F0aXAtb3ZlcmxheScsXFxuXFx0XFx0XFx0XFx0XFx0XFx0aHRtbDogJzxkaXY+PC9kaXY+JyxcXG5cXHRcXHRcXHRcXHRcXHRcXHRtb3VzZWRvd246IGZ1bmN0aW9uIG1vdXNlZG93bigpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gRkFMU0U7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH0pLmhpZGUoKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBNYWtlIHN1cmUgd2UgY2FuJ3QgZm9jdXMgYW55dGhpbmcgb3V0c2lkZSB0aGUgdG9vbHRpcFxcblxcdFxcdFxcdFxcdFxcdCQoZG9jdW1lbnQuYm9keSkuYmluZCgnZm9jdXNpbicgKyBNT0RBTFNFTEVDVE9SLCBzdGVhbEZvY3VzKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBBcHBseSBrZXlib2FyZCBcXFwiRXNjYXBlIGtleVxcXCIgY2xvc2UgaGFuZGxlclxcblxcdFxcdFxcdFxcdFxcdCQoZG9jdW1lbnQpLmJpbmQoJ2tleWRvd24nICsgTU9EQUxTRUxFQ1RPUiwgZnVuY3Rpb24gKGV2ZW50KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKGN1cnJlbnQgJiYgY3VycmVudC5vcHRpb25zLnNob3cubW9kYWwuZXNjYXBlICYmIGV2ZW50LmtleUNvZGUgPT09IDI3KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y3VycmVudC5oaWRlKGV2ZW50KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fSk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gQXBwbHkgY2xpY2sgaGFuZGxlciBmb3IgYmx1ciBvcHRpb25cXG5cXHRcXHRcXHRcXHRcXHRlbGVtLmJpbmQoJ2NsaWNrJyArIE1PREFMU0VMRUNUT1IsIGZ1bmN0aW9uIChldmVudCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChjdXJyZW50ICYmIGN1cnJlbnQub3B0aW9ucy5zaG93Lm1vZGFsLmJsdXIpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjdXJyZW50LmhpZGUoZXZlbnQpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9KTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gc2VsZjtcXG5cXHRcXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdFxcdHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKGFwaSkge1xcblxcdFxcdFxcdFxcdFxcdC8vIFVwZGF0ZSBjdXJyZW50IEFQSSByZWZlcmVuY2VcXG5cXHRcXHRcXHRcXHRcXHRjdXJyZW50ID0gYXBpO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIFVwZGF0ZSBmb2N1c2FibGUgZWxlbWVudHMgaWYgZW5hYmxlZFxcblxcdFxcdFxcdFxcdFxcdGlmIChhcGkub3B0aW9ucy5zaG93Lm1vZGFsLnN0ZWFsZm9jdXMgIT09IEZBTFNFKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Zm9jdXNhYmxlRWxlbXMgPSBhcGkudG9vbHRpcC5maW5kKCcqJykuZmlsdGVyKGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gZm9jdXNhYmxlKHRoaXMpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Zm9jdXNhYmxlRWxlbXMgPSBbXTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRcXHR0b2dnbGU6IGZ1bmN0aW9uIHRvZ2dsZShhcGksIHN0YXRlLCBkdXJhdGlvbikge1xcblxcdFxcdFxcdFxcdFxcdHZhciBkb2NCb2R5ID0gJChkb2N1bWVudC5ib2R5KSxcXG5cXHRcXHRcXHRcXHRcXHQgICAgdG9vbHRpcCA9IGFwaS50b29sdGlwLFxcblxcdFxcdFxcdFxcdFxcdCAgICBvcHRpb25zID0gYXBpLm9wdGlvbnMuc2hvdy5tb2RhbCxcXG5cXHRcXHRcXHRcXHRcXHQgICAgZWZmZWN0ID0gb3B0aW9ucy5lZmZlY3QsXFxuXFx0XFx0XFx0XFx0XFx0ICAgIHR5cGUgPSBzdGF0ZSA/ICdzaG93JyA6ICdoaWRlJyxcXG5cXHRcXHRcXHRcXHRcXHQgICAgdmlzaWJsZSA9IGVsZW0uaXMoJzp2aXNpYmxlJyksXFxuXFx0XFx0XFx0XFx0XFx0ICAgIHZpc2libGVNb2RhbHMgPSAkKE1PREFMU0VMRUNUT1IpLmZpbHRlcignOnZpc2libGU6bm90KDphbmltYXRlZCknKS5ub3QodG9vbHRpcCksXFxuXFx0XFx0XFx0XFx0XFx0ICAgIHppbmRleDtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBTZXQgYWN0aXZlIHRvb2x0aXAgQVBJIHJlZmVyZW5jZVxcblxcdFxcdFxcdFxcdFxcdHNlbGYudXBkYXRlKGFwaSk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gSWYgdGhlIG1vZGFsIGNhbiBzdGVhbCB0aGUgZm9jdXMuLi5cXG5cXHRcXHRcXHRcXHRcXHQvLyBCbHVyIHRoZSBjdXJyZW50IGl0ZW0gYW5kIGZvY3VzIGFueXRoaW5nIGluIHRoZSBtb2RhbCB3ZSBhblxcblxcdFxcdFxcdFxcdFxcdGlmIChzdGF0ZSAmJiBvcHRpb25zLnN0ZWFsZm9jdXMgIT09IEZBTFNFKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Zm9jdXNJbnB1dHMoJCgnOmZvY3VzJykpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBUb2dnbGUgYmFja2Ryb3AgY3Vyc29yIHN0eWxlIG9uIHNob3dcXG5cXHRcXHRcXHRcXHRcXHRlbGVtLnRvZ2dsZUNsYXNzKCdibHVycycsIG9wdGlvbnMuYmx1cik7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gQXBwZW5kIHRvIGJvZHkgb24gc2hvd1xcblxcdFxcdFxcdFxcdFxcdGlmIChzdGF0ZSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGVsZW0uYXBwZW5kVG8oZG9jdW1lbnQuYm9keSk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdC8vIFByZXZlbnQgbW9kYWwgZnJvbSBjb25mbGljdGluZyB3aXRoIHNob3cuc29sbywgYW5kIGRvbid0IGhpZGUgYmFja2Ryb3AgaXMgb3RoZXIgbW9kYWxzIGFyZSB2aXNpYmxlXFxuXFx0XFx0XFx0XFx0XFx0aWYgKGVsZW0uaXMoJzphbmltYXRlZCcpICYmIHZpc2libGUgPT09IHN0YXRlICYmIHByZXZTdGF0ZSAhPT0gRkFMU0UgfHwgIXN0YXRlICYmIHZpc2libGVNb2RhbHMubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHNlbGY7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdC8vIFN0b3AgYWxsIGFuaW1hdGlvbnNcXG5cXHRcXHRcXHRcXHRcXHRlbGVtLnN0b3AoVFJVRSwgRkFMU0UpO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIFVzZSBjdXN0b20gZnVuY3Rpb24gaWYgcHJvdmlkZWRcXG5cXHRcXHRcXHRcXHRcXHRpZiAoJC5pc0Z1bmN0aW9uKGVmZmVjdCkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRlZmZlY3QuY2FsbChlbGVtLCBzdGF0ZSk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdC8vIElmIG5vIGVmZmVjdCB0eXBlIGlzIHN1cHBsaWVkLCB1c2UgYSBzaW1wbGUgdG9nZ2xlXFxuXFx0XFx0XFx0XFx0XFx0ZWxzZSBpZiAoZWZmZWN0ID09PSBGQUxTRSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGVsZW1bdHlwZV0oKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gVXNlIGJhc2ljIGZhZGUgZnVuY3Rpb25cXG5cXHRcXHRcXHRcXHRcXHRcXHRlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRlbGVtLmZhZGVUbyhwYXJzZUludChkdXJhdGlvbiwgMTApIHx8IDkwLCBzdGF0ZSA/IDEgOiAwLCBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCFzdGF0ZSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGVsZW0uaGlkZSgpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gUmVzZXQgcG9zaXRpb24gYW5kIGRldGFjaCBmcm9tIGJvZHkgb24gaGlkZVxcblxcdFxcdFxcdFxcdFxcdGlmICghc3RhdGUpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRlbGVtLnF1ZXVlKGZ1bmN0aW9uIChuZXh0KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZWxlbS5jc3MoeyBsZWZ0OiAnJywgdG9wOiAnJyB9KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoISQoTU9EQUxTRUxFQ1RPUikubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZWxlbS5kZXRhY2goKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bmV4dCgpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBDYWNoZSB0aGUgc3RhdGVcXG5cXHRcXHRcXHRcXHRcXHRwcmV2U3RhdGUgPSBzdGF0ZTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBJZiB0aGUgdG9vbHRpcCBpcyBkZXN0cm95ZWQsIHNldCByZWZlcmVuY2UgdG8gbnVsbFxcblxcdFxcdFxcdFxcdFxcdGlmIChjdXJyZW50LmRlc3Ryb3llZCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGN1cnJlbnQgPSBOVUxMO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gc2VsZjtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSk7XFxuXFxuXFx0XFx0XFx0c2VsZi5pbml0KCk7XFxuXFx0XFx0fTtcXG5cXHRcXHRPVkVSTEFZID0gbmV3IE9WRVJMQVkoKTtcXG5cXG5cXHRcXHRmdW5jdGlvbiBNb2RhbChhcGksIG9wdGlvbnMpIHtcXG5cXHRcXHRcXHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xcblxcdFxcdFxcdHRoaXMuX25zID0gJy1tb2RhbCc7XFxuXFxuXFx0XFx0XFx0dGhpcy5pbml0KHRoaXMucXRpcCA9IGFwaSk7XFxuXFx0XFx0fVxcblxcblxcdFxcdCQuZXh0ZW5kKE1vZGFsLnByb3RvdHlwZSwge1xcblxcdFxcdFxcdGluaXQ6IGZ1bmN0aW9uIGluaXQocXRpcCkge1xcblxcdFxcdFxcdFxcdHZhciB0b29sdGlwID0gcXRpcC50b29sdGlwO1xcblxcblxcdFxcdFxcdFxcdC8vIElmIG1vZGFsIGlzIGRpc2FibGVkLi4uIHJldHVyblxcblxcdFxcdFxcdFxcdGlmICghdGhpcy5vcHRpb25zLm9uKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIFNldCBvdmVybGF5IHJlZmVyZW5jZVxcblxcdFxcdFxcdFxcdHF0aXAuZWxlbWVudHMub3ZlcmxheSA9IE9WRVJMQVkuZWxlbTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBBZGQgdW5pcXVlIGF0dHJpYnV0ZSBzbyB3ZSBjYW4gZ3JhYiBtb2RhbCB0b29sdGlwcyBlYXNpbHkgdmlhIGEgU0VMRUNUT1IsIGFuZCBzZXQgei1pbmRleFxcblxcdFxcdFxcdFxcdHRvb2x0aXAuYWRkQ2xhc3MoTU9EQUxDTEFTUykuY3NzKCd6LWluZGV4JywgUVRJUC5tb2RhbF96aW5kZXggKyAkKE1PREFMU0VMRUNUT1IpLmxlbmd0aCk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQXBwbHkgb3VyIHNob3cvaGlkZS9mb2N1cyBtb2RhbCBldmVudHNcXG5cXHRcXHRcXHRcXHRxdGlwLl9iaW5kKHRvb2x0aXAsIFsndG9vbHRpcHNob3cnLCAndG9vbHRpcGhpZGUnXSwgZnVuY3Rpb24gKGV2ZW50LCBhcGksIGR1cmF0aW9uKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIG9FdmVudCA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQ7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gTWFrZSBzdXJlIG1vdXNlb3V0IGRvZXNuJ3QgdHJpZ2dlciBhIGhpZGUgd2hlbiBzaG93aW5nIHRoZSBtb2RhbCBhbmQgbW91c2luZyBvbnRvIGJhY2tkcm9wXFxuXFx0XFx0XFx0XFx0XFx0aWYgKGV2ZW50LnRhcmdldCA9PT0gdG9vbHRpcFswXSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChvRXZlbnQgJiYgZXZlbnQudHlwZSA9PT0gJ3Rvb2x0aXBoaWRlJyAmJiAvbW91c2UobGVhdmV8ZW50ZXIpLy50ZXN0KG9FdmVudC50eXBlKSAmJiAkKG9FdmVudC5yZWxhdGVkVGFyZ2V0KS5jbG9zZXN0KE9WRVJMQVkuZWxlbVswXSkubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dHJ5IHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gY2F0Y2ggKGUpIHt9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIGlmICghb0V2ZW50IHx8IG9FdmVudCAmJiBvRXZlbnQudHlwZSAhPT0gJ3Rvb2x0aXBzb2xvJykge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoaXMudG9nZ2xlKGV2ZW50LCBldmVudC50eXBlID09PSAndG9vbHRpcHNob3cnLCBkdXJhdGlvbik7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9LCB0aGlzLl9ucywgdGhpcyk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQWRqdXN0IG1vZGFsIHotaW5kZXggb24gdG9vbHRpcCBmb2N1c1xcblxcdFxcdFxcdFxcdHF0aXAuX2JpbmQodG9vbHRpcCwgJ3Rvb2x0aXBmb2N1cycsIGZ1bmN0aW9uIChldmVudCwgYXBpKSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gSWYgZm9jdXMgd2FzIGNhbmNlbGxlZCBiZWZvcmUgaXQgcmVhY2hlZCB1cywgZG9uJ3QgZG8gYW55dGhpbmdcXG5cXHRcXHRcXHRcXHRcXHRpZiAoZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgfHwgZXZlbnQudGFyZ2V0ICE9PSB0b29sdGlwWzBdKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgcXRpcHMgPSAkKE1PREFMU0VMRUNUT1IpLFxcblxcblxcblxcdFxcdFxcdFxcdFxcdC8vIEtlZXAgdGhlIG1vZGFsJ3MgbG93ZXIgdGhhbiBvdGhlciwgcmVndWxhciBxdGlwc1xcblxcdFxcdFxcdFxcdFxcdG5ld0luZGV4ID0gUVRJUC5tb2RhbF96aW5kZXggKyBxdGlwcy5sZW5ndGgsXFxuXFx0XFx0XFx0XFx0XFx0ICAgIGN1ckluZGV4ID0gcGFyc2VJbnQodG9vbHRpcFswXS5zdHlsZS56SW5kZXgsIDEwKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBTZXQgb3ZlcmxheSB6LWluZGV4XFxuXFx0XFx0XFx0XFx0XFx0T1ZFUkxBWS5lbGVtWzBdLnN0eWxlLnpJbmRleCA9IG5ld0luZGV4IC0gMTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBSZWR1Y2UgbW9kYWwgei1pbmRleCdzIGFuZCBrZWVwIHRoZW0gcHJvcGVybHkgb3JkZXJlZFxcblxcdFxcdFxcdFxcdFxcdHF0aXBzLmVhY2goZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICh0aGlzLnN0eWxlLnpJbmRleCA+IGN1ckluZGV4KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5zdHlsZS56SW5kZXggLT0gMTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fSk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gRmlyZSBibHVyIGV2ZW50IGZvciBmb2N1c2VkIHRvb2x0aXBcXG5cXHRcXHRcXHRcXHRcXHRxdGlwcy5maWx0ZXIoJy4nICsgQ0xBU1NfRk9DVVMpLnF0aXAoJ2JsdXInLCBldmVudC5vcmlnaW5hbEV2ZW50KTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBTZXQgdGhlIG5ldyB6LWluZGV4XFxuXFx0XFx0XFx0XFx0XFx0dG9vbHRpcC5hZGRDbGFzcyhDTEFTU19GT0NVUylbMF0uc3R5bGUuekluZGV4ID0gbmV3SW5kZXg7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gU2V0IGN1cnJlbnRcXG5cXHRcXHRcXHRcXHRcXHRPVkVSTEFZLnVwZGF0ZShhcGkpO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIFByZXZlbnQgZGVmYXVsdCBoYW5kbGluZ1xcblxcdFxcdFxcdFxcdFxcdHRyeSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG5cXHRcXHRcXHRcXHRcXHR9IGNhdGNoIChlKSB7fVxcblxcdFxcdFxcdFxcdH0sIHRoaXMuX25zLCB0aGlzKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBGb2N1cyBhbnkgb3RoZXIgdmlzaWJsZSBtb2RhbHMgd2hlbiB0aGlzIG9uZSBoaWRlc1xcblxcdFxcdFxcdFxcdHF0aXAuX2JpbmQodG9vbHRpcCwgJ3Rvb2x0aXBoaWRlJywgZnVuY3Rpb24gKGV2ZW50KSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGV2ZW50LnRhcmdldCA9PT0gdG9vbHRpcFswXSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdCQoTU9EQUxTRUxFQ1RPUikuZmlsdGVyKCc6dmlzaWJsZScpLm5vdCh0b29sdGlwKS5sYXN0KCkucXRpcCgnZm9jdXMnLCBldmVudCk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH0sIHRoaXMuX25zLCB0aGlzKTtcXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdHRvZ2dsZTogZnVuY3Rpb24gdG9nZ2xlKGV2ZW50LCBzdGF0ZSwgZHVyYXRpb24pIHtcXG5cXHRcXHRcXHRcXHQvLyBNYWtlIHN1cmUgZGVmYXVsdCBldmVudCBoYXNuJ3QgYmVlbiBwcmV2ZW50ZWRcXG5cXHRcXHRcXHRcXHRpZiAoZXZlbnQgJiYgZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gVG9nZ2xlIGl0XFxuXFx0XFx0XFx0XFx0T1ZFUkxBWS50b2dnbGUodGhpcy5xdGlwLCAhIXN0YXRlLCBkdXJhdGlvbik7XFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xcblxcdFxcdFxcdFxcdC8vIFJlbW92ZSBtb2RhbCBjbGFzc1xcblxcdFxcdFxcdFxcdHRoaXMucXRpcC50b29sdGlwLnJlbW92ZUNsYXNzKE1PREFMQ0xBU1MpO1xcblxcblxcdFxcdFxcdFxcdC8vIFJlbW92ZSBib3VuZCBldmVudHNcXG5cXHRcXHRcXHRcXHR0aGlzLnF0aXAuX3VuYmluZCh0aGlzLnF0aXAudG9vbHRpcCwgdGhpcy5fbnMpO1xcblxcblxcdFxcdFxcdFxcdC8vIERlbGV0ZSBlbGVtZW50IHJlZmVyZW5jZVxcblxcdFxcdFxcdFxcdE9WRVJMQVkudG9nZ2xlKHRoaXMucXRpcCwgRkFMU0UpO1xcblxcdFxcdFxcdFxcdGRlbGV0ZSB0aGlzLnF0aXAuZWxlbWVudHMub3ZlcmxheTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSk7XFxuXFxuXFx0XFx0TU9EQUwgPSBQTFVHSU5TLm1vZGFsID0gZnVuY3Rpb24gKGFwaSkge1xcblxcdFxcdFxcdHJldHVybiBuZXcgTW9kYWwoYXBpLCBhcGkub3B0aW9ucy5zaG93Lm1vZGFsKTtcXG5cXHRcXHR9O1xcblxcblxcdFxcdC8vIFNldHVwIHNhbml0aXp0aW9uIHJ1bGVzXFxuXFx0XFx0TU9EQUwuc2FuaXRpemUgPSBmdW5jdGlvbiAob3B0cykge1xcblxcdFxcdFxcdGlmIChvcHRzLnNob3cpIHtcXG5cXHRcXHRcXHRcXHRpZiAoX3R5cGVvZihvcHRzLnNob3cubW9kYWwpICE9PSAnb2JqZWN0Jykge1xcblxcdFxcdFxcdFxcdFxcdG9wdHMuc2hvdy5tb2RhbCA9IHsgb246ICEhb3B0cy5zaG93Lm1vZGFsIH07XFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmICh0eXBlb2Ygb3B0cy5zaG93Lm1vZGFsLm9uID09PSAndW5kZWZpbmVkJykge1xcblxcdFxcdFxcdFxcdFxcdG9wdHMuc2hvdy5tb2RhbC5vbiA9IFRSVUU7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9O1xcblxcblxcdFxcdC8vIEJhc2Ugei1pbmRleCBmb3IgYWxsIG1vZGFsIHRvb2x0aXBzICh1c2UgcVRpcCBjb3JlIHotaW5kZXggYXMgYSBiYXNlKVxcblxcdFxcdFFUSVAubW9kYWxfemluZGV4ID0gUVRJUC56aW5kZXggLSAyMDA7XFxuXFxuXFx0XFx0Ly8gUGx1Z2luIG5lZWRzIHRvIGJlIGluaXRpYWxpemVkIG9uIHJlbmRlclxcblxcdFxcdE1PREFMLmluaXRpYWxpemUgPSAncmVuZGVyJztcXG5cXG5cXHRcXHQvLyBTZXR1cCBvcHRpb24gc2V0IGNoZWNrc1xcblxcdFxcdENIRUNLUy5tb2RhbCA9IHtcXG5cXHRcXHRcXHQnXnNob3cubW9kYWwuKG9ufGJsdXIpJCc6IGZ1bmN0aW9uIHNob3dNb2RhbE9uQmx1ciQoKSB7XFxuXFx0XFx0XFx0XFx0Ly8gSW5pdGlhbGlzZVxcblxcdFxcdFxcdFxcdHRoaXMuZGVzdHJveSgpO1xcblxcdFxcdFxcdFxcdHRoaXMuaW5pdCgpO1xcblxcblxcdFxcdFxcdFxcdC8vIFNob3cgdGhlIG1vZGFsIGlmIG5vdCB2aXNpYmxlIGFscmVhZHkgYW5kIHRvb2x0aXAgaXMgdmlzaWJsZVxcblxcdFxcdFxcdFxcdHRoaXMucXRpcC5lbGVtcy5vdmVybGF5LnRvZ2dsZSh0aGlzLnF0aXAudG9vbHRpcFswXS5vZmZzZXRXaWR0aCA+IDApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9O1xcblxcblxcdFxcdC8vIEV4dGVuZCBvcmlnaW5hbCBhcGkgZGVmYXVsdHNcXG5cXHRcXHQkLmV4dGVuZChUUlVFLCBRVElQLmRlZmF1bHRzLCB7XFxuXFx0XFx0XFx0c2hvdzoge1xcblxcdFxcdFxcdFxcdG1vZGFsOiB7XFxuXFx0XFx0XFx0XFx0XFx0b246IEZBTFNFLFxcblxcdFxcdFxcdFxcdFxcdGVmZmVjdDogVFJVRSxcXG5cXHRcXHRcXHRcXHRcXHRibHVyOiBUUlVFLFxcblxcdFxcdFxcdFxcdFxcdHN0ZWFsZm9jdXM6IFRSVUUsXFxuXFx0XFx0XFx0XFx0XFx0ZXNjYXBlOiBUUlVFXFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9KTtcXG5cXHRcXHQ7UExVR0lOUy52aWV3cG9ydCA9IGZ1bmN0aW9uIChhcGksIHBvc2l0aW9uLCBwb3NPcHRpb25zLCB0YXJnZXRXaWR0aCwgdGFyZ2V0SGVpZ2h0LCBlbGVtV2lkdGgsIGVsZW1IZWlnaHQpIHtcXG5cXHRcXHRcXHR2YXIgdGFyZ2V0ID0gcG9zT3B0aW9ucy50YXJnZXQsXFxuXFx0XFx0XFx0ICAgIHRvb2x0aXAgPSBhcGkuZWxlbWVudHMudG9vbHRpcCxcXG5cXHRcXHRcXHQgICAgbXkgPSBwb3NPcHRpb25zLm15LFxcblxcdFxcdFxcdCAgICBhdCA9IHBvc09wdGlvbnMuYXQsXFxuXFx0XFx0XFx0ICAgIGFkanVzdCA9IHBvc09wdGlvbnMuYWRqdXN0LFxcblxcdFxcdFxcdCAgICBtZXRob2QgPSBhZGp1c3QubWV0aG9kLnNwbGl0KCcgJyksXFxuXFx0XFx0XFx0ICAgIG1ldGhvZFggPSBtZXRob2RbMF0sXFxuXFx0XFx0XFx0ICAgIG1ldGhvZFkgPSBtZXRob2RbMV0gfHwgbWV0aG9kWzBdLFxcblxcdFxcdFxcdCAgICB2aWV3cG9ydCA9IHBvc09wdGlvbnMudmlld3BvcnQsXFxuXFx0XFx0XFx0ICAgIGNvbnRhaW5lciA9IHBvc09wdGlvbnMuY29udGFpbmVyLFxcblxcdFxcdFxcdCAgICBjYWNoZSA9IGFwaS5jYWNoZSxcXG5cXHRcXHRcXHQgICAgYWRqdXN0ZWQgPSB7IGxlZnQ6IDAsIHRvcDogMCB9LFxcblxcdFxcdFxcdCAgICBmaXhlZCxcXG5cXHRcXHRcXHQgICAgbmV3TXksXFxuXFx0XFx0XFx0ICAgIGNvbnRhaW5lck9mZnNldCxcXG5cXHRcXHRcXHQgICAgY29udGFpbmVyU3RhdGljLFxcblxcdFxcdFxcdCAgICB2aWV3cG9ydFdpZHRoLFxcblxcdFxcdFxcdCAgICB2aWV3cG9ydEhlaWdodCxcXG5cXHRcXHRcXHQgICAgdmlld3BvcnRTY3JvbGwsXFxuXFx0XFx0XFx0ICAgIHZpZXdwb3J0T2Zmc2V0O1xcblxcblxcdFxcdFxcdC8vIElmIHZpZXdwb3J0IGlzIG5vdCBhIGpRdWVyeSBlbGVtZW50LCBvciBpdCdzIHRoZSB3aW5kb3cvZG9jdW1lbnQsIG9yIG5vIGFkanVzdG1lbnQgbWV0aG9kIGlzIHVzZWQuLi4gcmV0dXJuXFxuXFx0XFx0XFx0aWYgKCF2aWV3cG9ydC5qcXVlcnkgfHwgdGFyZ2V0WzBdID09PSB3aW5kb3cgfHwgdGFyZ2V0WzBdID09PSBkb2N1bWVudC5ib2R5IHx8IGFkanVzdC5tZXRob2QgPT09ICdub25lJykge1xcblxcdFxcdFxcdFxcdHJldHVybiBhZGp1c3RlZDtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gQ2FjaCBjb250YWluZXIgZGV0YWlsc1xcblxcdFxcdFxcdGNvbnRhaW5lck9mZnNldCA9IGNvbnRhaW5lci5vZmZzZXQoKSB8fCBhZGp1c3RlZDtcXG5cXHRcXHRcXHRjb250YWluZXJTdGF0aWMgPSBjb250YWluZXIuY3NzKCdwb3NpdGlvbicpID09PSAnc3RhdGljJztcXG5cXG5cXHRcXHRcXHQvLyBDYWNoZSBvdXIgdmlld3BvcnQgZGV0YWlsc1xcblxcdFxcdFxcdGZpeGVkID0gdG9vbHRpcC5jc3MoJ3Bvc2l0aW9uJykgPT09ICdmaXhlZCc7XFxuXFx0XFx0XFx0dmlld3BvcnRXaWR0aCA9IHZpZXdwb3J0WzBdID09PSB3aW5kb3cgPyB2aWV3cG9ydC53aWR0aCgpIDogdmlld3BvcnQub3V0ZXJXaWR0aChGQUxTRSk7XFxuXFx0XFx0XFx0dmlld3BvcnRIZWlnaHQgPSB2aWV3cG9ydFswXSA9PT0gd2luZG93ID8gdmlld3BvcnQuaGVpZ2h0KCkgOiB2aWV3cG9ydC5vdXRlckhlaWdodChGQUxTRSk7XFxuXFx0XFx0XFx0dmlld3BvcnRTY3JvbGwgPSB7IGxlZnQ6IGZpeGVkID8gMCA6IHZpZXdwb3J0LnNjcm9sbExlZnQoKSwgdG9wOiBmaXhlZCA/IDAgOiB2aWV3cG9ydC5zY3JvbGxUb3AoKSB9O1xcblxcdFxcdFxcdHZpZXdwb3J0T2Zmc2V0ID0gdmlld3BvcnQub2Zmc2V0KCkgfHwgYWRqdXN0ZWQ7XFxuXFxuXFx0XFx0XFx0Ly8gR2VuZXJpYyBjYWxjdWxhdGlvbiBtZXRob2RcXG5cXHRcXHRcXHRmdW5jdGlvbiBjYWxjdWxhdGUoc2lkZSwgb3RoZXJTaWRlLCB0eXBlLCBhZGp1c3QsIHNpZGUxLCBzaWRlMiwgbGVuZ3RoTmFtZSwgdGFyZ2V0TGVuZ3RoLCBlbGVtTGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0dmFyIGluaXRpYWxQb3MgPSBwb3NpdGlvbltzaWRlMV0sXFxuXFx0XFx0XFx0XFx0ICAgIG15U2lkZSA9IG15W3NpZGVdLFxcblxcdFxcdFxcdFxcdCAgICBhdFNpZGUgPSBhdFtzaWRlXSxcXG5cXHRcXHRcXHRcXHQgICAgaXNTaGlmdCA9IHR5cGUgPT09IFNISUZULFxcblxcdFxcdFxcdFxcdCAgICBteUxlbmd0aCA9IG15U2lkZSA9PT0gc2lkZTEgPyBlbGVtTGVuZ3RoIDogbXlTaWRlID09PSBzaWRlMiA/IC1lbGVtTGVuZ3RoIDogLWVsZW1MZW5ndGggLyAyLFxcblxcdFxcdFxcdFxcdCAgICBhdExlbmd0aCA9IGF0U2lkZSA9PT0gc2lkZTEgPyB0YXJnZXRMZW5ndGggOiBhdFNpZGUgPT09IHNpZGUyID8gLXRhcmdldExlbmd0aCA6IC10YXJnZXRMZW5ndGggLyAyLFxcblxcdFxcdFxcdFxcdCAgICBzaWRlT2Zmc2V0ID0gdmlld3BvcnRTY3JvbGxbc2lkZTFdICsgdmlld3BvcnRPZmZzZXRbc2lkZTFdIC0gKGNvbnRhaW5lclN0YXRpYyA/IDAgOiBjb250YWluZXJPZmZzZXRbc2lkZTFdKSxcXG5cXHRcXHRcXHRcXHQgICAgb3ZlcmZsb3cxID0gc2lkZU9mZnNldCAtIGluaXRpYWxQb3MsXFxuXFx0XFx0XFx0XFx0ICAgIG92ZXJmbG93MiA9IGluaXRpYWxQb3MgKyBlbGVtTGVuZ3RoIC0gKGxlbmd0aE5hbWUgPT09IFdJRFRIID8gdmlld3BvcnRXaWR0aCA6IHZpZXdwb3J0SGVpZ2h0KSAtIHNpZGVPZmZzZXQsXFxuXFx0XFx0XFx0XFx0ICAgIG9mZnNldCA9IG15TGVuZ3RoIC0gKG15LnByZWNlZGFuY2UgPT09IHNpZGUgfHwgbXlTaWRlID09PSBteVtvdGhlclNpZGVdID8gYXRMZW5ndGggOiAwKSAtIChhdFNpZGUgPT09IENFTlRFUiA/IHRhcmdldExlbmd0aCAvIDIgOiAwKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBzaGlmdFxcblxcdFxcdFxcdFxcdGlmIChpc1NoaWZ0KSB7XFxuXFx0XFx0XFx0XFx0XFx0b2Zmc2V0ID0gKG15U2lkZSA9PT0gc2lkZTEgPyAxIDogLTEpICogbXlMZW5ndGg7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gQWRqdXN0IHBvc2l0aW9uIGJ1dCBrZWVwIGl0IHdpdGhpbiB2aWV3cG9ydCBkaW1lbnNpb25zXFxuXFx0XFx0XFx0XFx0XFx0cG9zaXRpb25bc2lkZTFdICs9IG92ZXJmbG93MSA+IDAgPyBvdmVyZmxvdzEgOiBvdmVyZmxvdzIgPiAwID8gLW92ZXJmbG93MiA6IDA7XFxuXFx0XFx0XFx0XFx0XFx0cG9zaXRpb25bc2lkZTFdID0gTWF0aC5tYXgoLWNvbnRhaW5lck9mZnNldFtzaWRlMV0gKyB2aWV3cG9ydE9mZnNldFtzaWRlMV0sIGluaXRpYWxQb3MgLSBvZmZzZXQsIE1hdGgubWluKE1hdGgubWF4KC1jb250YWluZXJPZmZzZXRbc2lkZTFdICsgdmlld3BvcnRPZmZzZXRbc2lkZTFdICsgKGxlbmd0aE5hbWUgPT09IFdJRFRIID8gdmlld3BvcnRXaWR0aCA6IHZpZXdwb3J0SGVpZ2h0KSwgaW5pdGlhbFBvcyArIG9mZnNldCksIHBvc2l0aW9uW3NpZGUxXSxcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBNYWtlIHN1cmUgd2UgZG9uJ3QgYWRqdXN0IGNvbXBsZXRlIG9mZiB0aGUgZWxlbWVudCB3aGVuIHVzaW5nICdjZW50ZXInXFxuXFx0XFx0XFx0XFx0XFx0bXlTaWRlID09PSAnY2VudGVyJyA/IGluaXRpYWxQb3MgLSBteUxlbmd0aCA6IDFFOSkpO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBmbGlwL2ZsaXBpbnZlcnRcXG5cXHRcXHRcXHRcXHRlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBVcGRhdGUgYWRqdXN0bWVudCBhbW91bnQgZGVwZW5kaW5nIG9uIGlmIHVzaW5nIGZsaXBpbnZlcnQgb3IgZmxpcFxcblxcdFxcdFxcdFxcdFxcdFxcdGFkanVzdCAqPSB0eXBlID09PSBGTElQSU5WRVJUID8gMiA6IDA7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gQ2hlY2sgZm9yIG92ZXJmbG93IG9uIHRoZSBsZWZ0L3RvcFxcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChvdmVyZmxvdzEgPiAwICYmIChteVNpZGUgIT09IHNpZGUxIHx8IG92ZXJmbG93MiA+IDApKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cG9zaXRpb25bc2lkZTFdIC09IG9mZnNldCArIGFkanVzdDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRuZXdNeS5pbnZlcnQoc2lkZSwgc2lkZTEpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBDaGVjayBmb3Igb3ZlcmZsb3cgb24gdGhlIGJvdHRvbS9yaWdodFxcblxcdFxcdFxcdFxcdFxcdFxcdGVsc2UgaWYgKG92ZXJmbG93MiA+IDAgJiYgKG15U2lkZSAhPT0gc2lkZTIgfHwgb3ZlcmZsb3cxID4gMCkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRwb3NpdGlvbltzaWRlMV0gLT0gKG15U2lkZSA9PT0gQ0VOVEVSID8gLW9mZnNldCA6IG9mZnNldCkgKyBhZGp1c3Q7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bmV3TXkuaW52ZXJ0KHNpZGUsIHNpZGUyKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gTWFrZSBzdXJlIHdlIGhhdmVuJ3QgbWFkZSB0aGluZ3Mgd29yc2Ugd2l0aCB0aGUgYWRqdXN0bWVudCBhbmQgcmVzZXQgaWYgc29cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAocG9zaXRpb25bc2lkZTFdIDwgdmlld3BvcnRTY3JvbGwgJiYgLXBvc2l0aW9uW3NpZGUxXSA+IG92ZXJmbG93Mikge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHBvc2l0aW9uW3NpZGUxXSA9IGluaXRpYWxQb3M7bmV3TXkgPSBteS5jbG9uZSgpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHBvc2l0aW9uW3NpZGUxXSAtIGluaXRpYWxQb3M7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFNldCBuZXdNeSBpZiB1c2luZyBmbGlwIG9yIGZsaXBpbnZlcnQgbWV0aG9kc1xcblxcdFxcdFxcdGlmIChtZXRob2RYICE9PSAnc2hpZnQnIHx8IG1ldGhvZFkgIT09ICdzaGlmdCcpIHtcXG5cXHRcXHRcXHRcXHRuZXdNeSA9IG15LmNsb25lKCk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIEFkanVzdCBwb3NpdGlvbiBiYXNlZCBvbnZpZXdwb3J0IGFuZCBhZGp1c3RtZW50IG9wdGlvbnNcXG5cXHRcXHRcXHRhZGp1c3RlZCA9IHtcXG5cXHRcXHRcXHRcXHRsZWZ0OiBtZXRob2RYICE9PSAnbm9uZScgPyBjYWxjdWxhdGUoWCwgWSwgbWV0aG9kWCwgYWRqdXN0LngsIExFRlQsIFJJR0hULCBXSURUSCwgdGFyZ2V0V2lkdGgsIGVsZW1XaWR0aCkgOiAwLFxcblxcdFxcdFxcdFxcdHRvcDogbWV0aG9kWSAhPT0gJ25vbmUnID8gY2FsY3VsYXRlKFksIFgsIG1ldGhvZFksIGFkanVzdC55LCBUT1AsIEJPVFRPTSwgSEVJR0hULCB0YXJnZXRIZWlnaHQsIGVsZW1IZWlnaHQpIDogMCxcXG5cXHRcXHRcXHRcXHRteTogbmV3TXlcXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdFxcdHJldHVybiBhZGp1c3RlZDtcXG5cXHRcXHR9O1xcblxcdFxcdDtQTFVHSU5TLnBvbHlzID0ge1xcblxcdFxcdFxcdC8vIFBPTFkgYXJlYSBjb29yZGluYXRlIGNhbGN1bGF0b3JcXG5cXHRcXHRcXHQvL1xcdFNwZWNpYWwgdGhhbmtzIHRvIEVkIENyYWRvY2sgZm9yIGhlbHBpbmcgb3V0IHdpdGggdGhpcy5cXG5cXHRcXHRcXHQvL1xcdFVzZXMgYSBiaW5hcnkgc2VhcmNoIGFsZ29yaXRobSB0byBmaW5kIHN1aXRhYmxlIGNvb3JkaW5hdGVzLlxcblxcdFxcdFxcdHBvbHlnb246IGZ1bmN0aW9uIHBvbHlnb24oYmFzZUNvb3JkcywgY29ybmVyKSB7XFxuXFx0XFx0XFx0XFx0dmFyIHJlc3VsdCA9IHtcXG5cXHRcXHRcXHRcXHRcXHR3aWR0aDogMCwgaGVpZ2h0OiAwLFxcblxcdFxcdFxcdFxcdFxcdHBvc2l0aW9uOiB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dG9wOiAxZTEwLCByaWdodDogMCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRib3R0b206IDAsIGxlZnQ6IDFlMTBcXG5cXHRcXHRcXHRcXHRcXHR9LFxcblxcdFxcdFxcdFxcdFxcdGFkanVzdGFibGU6IEZBTFNFXFxuXFx0XFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRcXHQgICAgaSA9IDAsXFxuXFx0XFx0XFx0XFx0ICAgIG5leHQsXFxuXFx0XFx0XFx0XFx0ICAgIGNvb3JkcyA9IFtdLFxcblxcdFxcdFxcdFxcdCAgICBjb21wYXJlWCA9IDEsXFxuXFx0XFx0XFx0XFx0ICAgIGNvbXBhcmVZID0gMSxcXG5cXHRcXHRcXHRcXHQgICAgcmVhbFggPSAwLFxcblxcdFxcdFxcdFxcdCAgICByZWFsWSA9IDAsXFxuXFx0XFx0XFx0XFx0ICAgIG5ld1dpZHRoLFxcblxcdFxcdFxcdFxcdCAgICBuZXdIZWlnaHQ7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gRmlyc3QgcGFzcywgc2FuaXRpemUgY29vcmRzIGFuZCBkZXRlcm1pbmUgb3V0ZXIgZWRnZXNcXG5cXHRcXHRcXHRcXHRpID0gYmFzZUNvb3Jkcy5sZW5ndGg7d2hpbGUgKGktLSkge1xcblxcdFxcdFxcdFxcdFxcdG5leHQgPSBbcGFyc2VJbnQoYmFzZUNvb3Jkc1stLWldLCAxMCksIHBhcnNlSW50KGJhc2VDb29yZHNbaSArIDFdLCAxMCldO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmIChuZXh0WzBdID4gcmVzdWx0LnBvc2l0aW9uLnJpZ2h0KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmVzdWx0LnBvc2l0aW9uLnJpZ2h0ID0gbmV4dFswXTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aWYgKG5leHRbMF0gPCByZXN1bHQucG9zaXRpb24ubGVmdCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJlc3VsdC5wb3NpdGlvbi5sZWZ0ID0gbmV4dFswXTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aWYgKG5leHRbMV0gPiByZXN1bHQucG9zaXRpb24uYm90dG9tKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmVzdWx0LnBvc2l0aW9uLmJvdHRvbSA9IG5leHRbMV07XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmIChuZXh0WzFdIDwgcmVzdWx0LnBvc2l0aW9uLnRvcCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJlc3VsdC5wb3NpdGlvbi50b3AgPSBuZXh0WzFdO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRjb29yZHMucHVzaChuZXh0KTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQ2FsY3VsYXRlIGhlaWdodCBhbmQgd2lkdGggZnJvbSBvdXRlciBlZGdlc1xcblxcdFxcdFxcdFxcdG5ld1dpZHRoID0gcmVzdWx0LndpZHRoID0gTWF0aC5hYnMocmVzdWx0LnBvc2l0aW9uLnJpZ2h0IC0gcmVzdWx0LnBvc2l0aW9uLmxlZnQpO1xcblxcdFxcdFxcdFxcdG5ld0hlaWdodCA9IHJlc3VsdC5oZWlnaHQgPSBNYXRoLmFicyhyZXN1bHQucG9zaXRpb24uYm90dG9tIC0gcmVzdWx0LnBvc2l0aW9uLnRvcCk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSWYgaXQncyB0aGUgY2VudGVyIGNvcm5lci4uLlxcblxcdFxcdFxcdFxcdGlmIChjb3JuZXIuYWJicmV2KCkgPT09ICdjJykge1xcblxcdFxcdFxcdFxcdFxcdHJlc3VsdC5wb3NpdGlvbiA9IHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRsZWZ0OiByZXN1bHQucG9zaXRpb24ubGVmdCArIHJlc3VsdC53aWR0aCAvIDIsXFxuXFx0XFx0XFx0XFx0XFx0XFx0dG9wOiByZXN1bHQucG9zaXRpb24udG9wICsgcmVzdWx0LmhlaWdodCAvIDJcXG5cXHRcXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gU2Vjb25kIHBhc3MsIHVzZSBhIGJpbmFyeSBzZWFyY2ggYWxnb3JpdGhtIHRvIGxvY2F0ZSBtb3N0IHN1aXRhYmxlIGNvb3JkaW5hdGVcXG5cXHRcXHRcXHRcXHRcXHR3aGlsZSAobmV3V2lkdGggPiAwICYmIG5ld0hlaWdodCA+IDAgJiYgY29tcGFyZVggPiAwICYmIGNvbXBhcmVZID4gMCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdG5ld1dpZHRoID0gTWF0aC5mbG9vcihuZXdXaWR0aCAvIDIpO1xcblxcdFxcdFxcdFxcdFxcdFxcdG5ld0hlaWdodCA9IE1hdGguZmxvb3IobmV3SGVpZ2h0IC8gMik7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKGNvcm5lci54ID09PSBMRUZUKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y29tcGFyZVggPSBuZXdXaWR0aDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2UgaWYgKGNvcm5lci54ID09PSBSSUdIVCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGNvbXBhcmVYID0gcmVzdWx0LndpZHRoIC0gbmV3V2lkdGg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjb21wYXJlWCArPSBNYXRoLmZsb29yKG5ld1dpZHRoIC8gMik7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChjb3JuZXIueSA9PT0gVE9QKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y29tcGFyZVkgPSBuZXdIZWlnaHQ7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIGlmIChjb3JuZXIueSA9PT0gQk9UVE9NKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y29tcGFyZVkgPSByZXN1bHQuaGVpZ2h0IC0gbmV3SGVpZ2h0O1xcblxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y29tcGFyZVkgKz0gTWF0aC5mbG9vcihuZXdIZWlnaHQgLyAyKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aSA9IGNvb3Jkcy5sZW5ndGg7d2hpbGUgKGktLSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChjb29yZHMubGVuZ3RoIDwgMikge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZWFsWCA9IGNvb3Jkc1tpXVswXSAtIHJlc3VsdC5wb3NpdGlvbi5sZWZ0O1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJlYWxZID0gY29vcmRzW2ldWzFdIC0gcmVzdWx0LnBvc2l0aW9uLnRvcDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoY29ybmVyLnggPT09IExFRlQgJiYgcmVhbFggPj0gY29tcGFyZVggfHwgY29ybmVyLnggPT09IFJJR0hUICYmIHJlYWxYIDw9IGNvbXBhcmVYIHx8IGNvcm5lci54ID09PSBDRU5URVIgJiYgKHJlYWxYIDwgY29tcGFyZVggfHwgcmVhbFggPiByZXN1bHQud2lkdGggLSBjb21wYXJlWCkgfHwgY29ybmVyLnkgPT09IFRPUCAmJiByZWFsWSA+PSBjb21wYXJlWSB8fCBjb3JuZXIueSA9PT0gQk9UVE9NICYmIHJlYWxZIDw9IGNvbXBhcmVZIHx8IGNvcm5lci55ID09PSBDRU5URVIgJiYgKHJlYWxZIDwgY29tcGFyZVkgfHwgcmVhbFkgPiByZXN1bHQuaGVpZ2h0IC0gY29tcGFyZVkpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Y29vcmRzLnNwbGljZShpLCAxKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRyZXN1bHQucG9zaXRpb24gPSB7IGxlZnQ6IGNvb3Jkc1swXVswXSwgdG9wOiBjb29yZHNbMF1bMV0gfTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHJlc3VsdDtcXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdHJlY3Q6IGZ1bmN0aW9uIHJlY3QoYXgsIGF5LCBieCwgYnkpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4ge1xcblxcdFxcdFxcdFxcdFxcdHdpZHRoOiBNYXRoLmFicyhieCAtIGF4KSxcXG5cXHRcXHRcXHRcXHRcXHRoZWlnaHQ6IE1hdGguYWJzKGJ5IC0gYXkpLFxcblxcdFxcdFxcdFxcdFxcdHBvc2l0aW9uOiB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0bGVmdDogTWF0aC5taW4oYXgsIGJ4KSxcXG5cXHRcXHRcXHRcXHRcXHRcXHR0b3A6IE1hdGgubWluKGF5LCBieSlcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fTtcXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdF9hbmdsZXM6IHtcXG5cXHRcXHRcXHRcXHR0YzogMyAvIDIsIHRyOiA3IC8gNCwgdGw6IDUgLyA0LFxcblxcdFxcdFxcdFxcdGJjOiAxIC8gMiwgYnI6IDEgLyA0LCBibDogMyAvIDQsXFxuXFx0XFx0XFx0XFx0cmM6IDIsIGxjOiAxLCBjOiAwXFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRlbGxpcHNlOiBmdW5jdGlvbiBlbGxpcHNlKGN4LCBjeSwgcngsIHJ5LCBjb3JuZXIpIHtcXG5cXHRcXHRcXHRcXHR2YXIgYyA9IFBMVUdJTlMucG9seXMuX2FuZ2xlc1tjb3JuZXIuYWJicmV2KCldLFxcblxcdFxcdFxcdFxcdCAgICByeGMgPSBjID09PSAwID8gMCA6IHJ4ICogTWF0aC5jb3MoYyAqIE1hdGguUEkpLFxcblxcdFxcdFxcdFxcdCAgICByeXMgPSByeSAqIE1hdGguc2luKGMgKiBNYXRoLlBJKTtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4ge1xcblxcdFxcdFxcdFxcdFxcdHdpZHRoOiByeCAqIDIgLSBNYXRoLmFicyhyeGMpLFxcblxcdFxcdFxcdFxcdFxcdGhlaWdodDogcnkgKiAyIC0gTWF0aC5hYnMocnlzKSxcXG5cXHRcXHRcXHRcXHRcXHRwb3NpdGlvbjoge1xcblxcdFxcdFxcdFxcdFxcdFxcdGxlZnQ6IGN4ICsgcnhjLFxcblxcdFxcdFxcdFxcdFxcdFxcdHRvcDogY3kgKyByeXNcXG5cXHRcXHRcXHRcXHRcXHR9LFxcblxcdFxcdFxcdFxcdFxcdGFkanVzdGFibGU6IEZBTFNFXFxuXFx0XFx0XFx0XFx0fTtcXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdGNpcmNsZTogZnVuY3Rpb24gY2lyY2xlKGN4LCBjeSwgciwgY29ybmVyKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIFBMVUdJTlMucG9seXMuZWxsaXBzZShjeCwgY3ksIHIsIHIsIGNvcm5lcik7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH07XFxuXFx0XFx0O1BMVUdJTlMuc3ZnID0gZnVuY3Rpb24gKGFwaSwgc3ZnLCBjb3JuZXIpIHtcXG5cXHRcXHRcXHR2YXIgZG9jID0gJChkb2N1bWVudCksXFxuXFx0XFx0XFx0ICAgIGVsZW0gPSBzdmdbMF0sXFxuXFx0XFx0XFx0ICAgIHJvb3QgPSAkKGVsZW0ub3duZXJTVkdFbGVtZW50KSxcXG5cXHRcXHRcXHQgICAgb3duZXJEb2N1bWVudCA9IGVsZW0ub3duZXJEb2N1bWVudCxcXG5cXHRcXHRcXHQgICAgc3Ryb2tlV2lkdGgyID0gKHBhcnNlSW50KHN2Zy5jc3MoJ3N0cm9rZS13aWR0aCcpLCAxMCkgfHwgMCkgLyAyLFxcblxcdFxcdFxcdCAgICBmcmFtZU9mZnNldCxcXG5cXHRcXHRcXHQgICAgbXR4LFxcblxcdFxcdFxcdCAgICB0cmFuc2Zvcm1lZCxcXG5cXHRcXHRcXHQgICAgdmlld0JveCxcXG5cXHRcXHRcXHQgICAgbGVuLFxcblxcdFxcdFxcdCAgICBuZXh0LFxcblxcdFxcdFxcdCAgICBpLFxcblxcdFxcdFxcdCAgICBwb2ludHMsXFxuXFx0XFx0XFx0ICAgIHJlc3VsdCxcXG5cXHRcXHRcXHQgICAgcG9zaXRpb24sXFxuXFx0XFx0XFx0ICAgIGRpbWVuc2lvbnM7XFxuXFxuXFx0XFx0XFx0Ly8gQXNjZW5kIHRoZSBwYXJlbnROb2RlIGNoYWluIHVudGlsIHdlIGZpbmQgYW4gZWxlbWVudCB3aXRoIGdldEJCb3goKVxcblxcdFxcdFxcdHdoaWxlICghZWxlbS5nZXRCQm94KSB7XFxuXFx0XFx0XFx0XFx0ZWxlbSA9IGVsZW0ucGFyZW50Tm9kZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKCFlbGVtLmdldEJCb3ggfHwgIWVsZW0ucGFyZW50Tm9kZSkge1xcblxcdFxcdFxcdFxcdHJldHVybiBGQUxTRTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gRGV0ZXJtaW5lIHdoaWNoIHNoYXBlIGNhbGN1bGF0aW9uIHRvIHVzZVxcblxcdFxcdFxcdHN3aXRjaCAoZWxlbS5ub2RlTmFtZSkge1xcblxcdFxcdFxcdFxcdGNhc2UgJ2VsbGlwc2UnOlxcblxcdFxcdFxcdFxcdGNhc2UgJ2NpcmNsZSc6XFxuXFx0XFx0XFx0XFx0XFx0cmVzdWx0ID0gUExVR0lOUy5wb2x5cy5lbGxpcHNlKGVsZW0uY3guYmFzZVZhbC52YWx1ZSwgZWxlbS5jeS5iYXNlVmFsLnZhbHVlLCAoZWxlbS5yeCB8fCBlbGVtLnIpLmJhc2VWYWwudmFsdWUgKyBzdHJva2VXaWR0aDIsIChlbGVtLnJ5IHx8IGVsZW0ucikuYmFzZVZhbC52YWx1ZSArIHN0cm9rZVdpZHRoMiwgY29ybmVyKTtcXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRjYXNlICdsaW5lJzpcXG5cXHRcXHRcXHRcXHRjYXNlICdwb2x5Z29uJzpcXG5cXHRcXHRcXHRcXHRjYXNlICdwb2x5bGluZSc6XFxuXFx0XFx0XFx0XFx0XFx0Ly8gRGV0ZXJtaW5lIHBvaW50cyBvYmplY3QgKGxpbmUgaGFzIG5vbmUsIHNvIG1pbWljIHVzaW5nIGFycmF5KVxcblxcdFxcdFxcdFxcdFxcdHBvaW50cyA9IGVsZW0ucG9pbnRzIHx8IFt7IHg6IGVsZW0ueDEuYmFzZVZhbC52YWx1ZSwgeTogZWxlbS55MS5iYXNlVmFsLnZhbHVlIH0sIHsgeDogZWxlbS54Mi5iYXNlVmFsLnZhbHVlLCB5OiBlbGVtLnkyLmJhc2VWYWwudmFsdWUgfV07XFxuXFxuXFx0XFx0XFx0XFx0XFx0Zm9yIChyZXN1bHQgPSBbXSwgaSA9IC0xLCBsZW4gPSBwb2ludHMubnVtYmVyT2ZJdGVtcyB8fCBwb2ludHMubGVuZ3RoOyArK2kgPCBsZW47KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0bmV4dCA9IHBvaW50cy5nZXRJdGVtID8gcG9pbnRzLmdldEl0ZW0oaSkgOiBwb2ludHNbaV07XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmVzdWx0LnB1c2guYXBwbHkocmVzdWx0LCBbbmV4dC54LCBuZXh0LnldKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0cmVzdWx0ID0gUExVR0lOUy5wb2x5cy5wb2x5Z29uKHJlc3VsdCwgY29ybmVyKTtcXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHQvLyBVbmtub3duIHNoYXBlIG9yIHJlY3RhbmdsZT8gVXNlIGJvdW5kaW5nIGJveFxcblxcdFxcdFxcdFxcdGRlZmF1bHQ6XFxuXFx0XFx0XFx0XFx0XFx0cmVzdWx0ID0gZWxlbS5nZXRCQm94KCk7XFxuXFx0XFx0XFx0XFx0XFx0cmVzdWx0ID0ge1xcblxcdFxcdFxcdFxcdFxcdFxcdHdpZHRoOiByZXN1bHQud2lkdGgsXFxuXFx0XFx0XFx0XFx0XFx0XFx0aGVpZ2h0OiByZXN1bHQuaGVpZ2h0LFxcblxcdFxcdFxcdFxcdFxcdFxcdHBvc2l0aW9uOiB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bGVmdDogcmVzdWx0LngsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dG9wOiByZXN1bHQueVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBTaG9ydGN1dCBhc3NpZ25tZW50c1xcblxcdFxcdFxcdHBvc2l0aW9uID0gcmVzdWx0LnBvc2l0aW9uO1xcblxcdFxcdFxcdHJvb3QgPSByb290WzBdO1xcblxcblxcdFxcdFxcdC8vIENvbnZlcnQgcG9zaXRpb24gaW50byBhIHBpeGVsIHZhbHVlXFxuXFx0XFx0XFx0aWYgKHJvb3QuY3JlYXRlU1ZHUG9pbnQpIHtcXG5cXHRcXHRcXHRcXHRtdHggPSBlbGVtLmdldFNjcmVlbkNUTSgpO1xcblxcdFxcdFxcdFxcdHBvaW50cyA9IHJvb3QuY3JlYXRlU1ZHUG9pbnQoKTtcXG5cXG5cXHRcXHRcXHRcXHRwb2ludHMueCA9IHBvc2l0aW9uLmxlZnQ7XFxuXFx0XFx0XFx0XFx0cG9pbnRzLnkgPSBwb3NpdGlvbi50b3A7XFxuXFx0XFx0XFx0XFx0dHJhbnNmb3JtZWQgPSBwb2ludHMubWF0cml4VHJhbnNmb3JtKG10eCk7XFxuXFx0XFx0XFx0XFx0cG9zaXRpb24ubGVmdCA9IHRyYW5zZm9ybWVkLng7XFxuXFx0XFx0XFx0XFx0cG9zaXRpb24udG9wID0gdHJhbnNmb3JtZWQueTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gQ2hlY2sgdGhlIGVsZW1lbnQgaXMgbm90IGluIGEgY2hpbGQgZG9jdW1lbnQsIGFuZCBpZiBzbywgYWRqdXN0IGZvciBmcmFtZSBlbGVtZW50cyBvZmZzZXRcXG5cXHRcXHRcXHRpZiAob3duZXJEb2N1bWVudCAhPT0gZG9jdW1lbnQgJiYgYXBpLnBvc2l0aW9uLnRhcmdldCAhPT0gJ21vdXNlJykge1xcblxcdFxcdFxcdFxcdGZyYW1lT2Zmc2V0ID0gJCgob3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCBvd25lckRvY3VtZW50LnBhcmVudFdpbmRvdykuZnJhbWVFbGVtZW50KS5vZmZzZXQoKTtcXG5cXHRcXHRcXHRcXHRpZiAoZnJhbWVPZmZzZXQpIHtcXG5cXHRcXHRcXHRcXHRcXHRwb3NpdGlvbi5sZWZ0ICs9IGZyYW1lT2Zmc2V0LmxlZnQ7XFxuXFx0XFx0XFx0XFx0XFx0cG9zaXRpb24udG9wICs9IGZyYW1lT2Zmc2V0LnRvcDtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIEFkanVzdCBieSBzY3JvbGwgb2Zmc2V0IG9mIG93bmVyIGRvY3VtZW50XFxuXFx0XFx0XFx0b3duZXJEb2N1bWVudCA9ICQob3duZXJEb2N1bWVudCk7XFxuXFx0XFx0XFx0cG9zaXRpb24ubGVmdCArPSBvd25lckRvY3VtZW50LnNjcm9sbExlZnQoKTtcXG5cXHRcXHRcXHRwb3NpdGlvbi50b3AgKz0gb3duZXJEb2N1bWVudC5zY3JvbGxUb3AoKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gcmVzdWx0O1xcblxcdFxcdH07XFxuXFx0XFx0O1BMVUdJTlMuaW1hZ2VtYXAgPSBmdW5jdGlvbiAoYXBpLCBhcmVhLCBjb3JuZXIsIGFkanVzdE1ldGhvZCkge1xcblxcdFxcdFxcdGlmICghYXJlYS5qcXVlcnkpIHtcXG5cXHRcXHRcXHRcXHRhcmVhID0gJChhcmVhKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dmFyIHNoYXBlID0gKGFyZWEuYXR0cignc2hhcGUnKSB8fCAncmVjdCcpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgncG9seScsICdwb2x5Z29uJyksXFxuXFx0XFx0XFx0ICAgIGltYWdlID0gJCgnaW1nW3VzZW1hcD1cXFwiIycgKyBhcmVhLnBhcmVudCgnbWFwJykuYXR0cignbmFtZScpICsgJ1xcXCJdJyksXFxuXFx0XFx0XFx0ICAgIGNvb3Jkc1N0cmluZyA9ICQudHJpbShhcmVhLmF0dHIoJ2Nvb3JkcycpKSxcXG5cXHRcXHRcXHQgICAgY29vcmRzQXJyYXkgPSBjb29yZHNTdHJpbmcucmVwbGFjZSgvLCQvLCAnJykuc3BsaXQoJywnKSxcXG5cXHRcXHRcXHQgICAgaW1hZ2VPZmZzZXQsXFxuXFx0XFx0XFx0ICAgIGNvb3JkcyxcXG5cXHRcXHRcXHQgICAgaSxcXG5cXHRcXHRcXHQgICAgbmV4dCxcXG5cXHRcXHRcXHQgICAgcmVzdWx0LFxcblxcdFxcdFxcdCAgICBsZW47XFxuXFxuXFx0XFx0XFx0Ly8gSWYgd2UgY2FuJ3QgZmluZCB0aGUgaW1hZ2UgdXNpbmcgdGhlIG1hcC4uLlxcblxcdFxcdFxcdGlmICghaW1hZ2UubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIEZBTFNFO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBQYXNzIGNvb3JkaW5hdGVzIHN0cmluZyBpZiBwb2x5Z29uXFxuXFx0XFx0XFx0aWYgKHNoYXBlID09PSAncG9seWdvbicpIHtcXG5cXHRcXHRcXHRcXHRyZXN1bHQgPSBQTFVHSU5TLnBvbHlzLnBvbHlnb24oY29vcmRzQXJyYXksIGNvcm5lcik7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIE90aGVyd2lzZSBwYXJzZSB0aGUgY29vcmRpbmF0ZXMgYW5kIHBhc3MgdGhlbSBhcyBhcmd1bWVudHNcXG5cXHRcXHRcXHRlbHNlIGlmIChQTFVHSU5TLnBvbHlzW3NoYXBlXSkge1xcblxcdFxcdFxcdFxcdFxcdGZvciAoaSA9IC0xLCBsZW4gPSBjb29yZHNBcnJheS5sZW5ndGgsIGNvb3JkcyA9IFtdOyArK2kgPCBsZW47KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y29vcmRzLnB1c2gocGFyc2VJbnQoY29vcmRzQXJyYXlbaV0sIDEwKSk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdHJlc3VsdCA9IFBMVUdJTlMucG9seXNbc2hhcGVdLmFwcGx5KHRoaXMsIGNvb3Jkcy5jb25jYXQoY29ybmVyKSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIElmIG5vIHNoYXByZSBjYWxjdWxhdGlvbiBtZXRob2Qgd2FzIGZvdW5kLCByZXR1cm4gZmFsc2VcXG5cXHRcXHRcXHRcXHRlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gRkFMU0U7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIE1ha2Ugc3VyZSB3ZSBhY2NvdW50IGZvciBwYWRkaW5nIGFuZCBib3JkZXJzIG9uIHRoZSBpbWFnZVxcblxcdFxcdFxcdGltYWdlT2Zmc2V0ID0gaW1hZ2Uub2Zmc2V0KCk7XFxuXFx0XFx0XFx0aW1hZ2VPZmZzZXQubGVmdCArPSBNYXRoLmNlaWwoKGltYWdlLm91dGVyV2lkdGgoRkFMU0UpIC0gaW1hZ2Uud2lkdGgoKSkgLyAyKTtcXG5cXHRcXHRcXHRpbWFnZU9mZnNldC50b3AgKz0gTWF0aC5jZWlsKChpbWFnZS5vdXRlckhlaWdodChGQUxTRSkgLSBpbWFnZS5oZWlnaHQoKSkgLyAyKTtcXG5cXG5cXHRcXHRcXHQvLyBBZGQgaW1hZ2UgcG9zaXRpb24gdG8gb2Zmc2V0IGNvb3JkaW5hdGVzXFxuXFx0XFx0XFx0cmVzdWx0LnBvc2l0aW9uLmxlZnQgKz0gaW1hZ2VPZmZzZXQubGVmdDtcXG5cXHRcXHRcXHRyZXN1bHQucG9zaXRpb24udG9wICs9IGltYWdlT2Zmc2V0LnRvcDtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gcmVzdWx0O1xcblxcdFxcdH07XFxuXFx0XFx0O3ZhciBJRTYsXFxuXFxuXFxuXFx0XFx0LypcXG4gICAqIEJHSUZyYW1lIGFkYXB0aW9uIChodHRwOi8vcGx1Z2lucy5qcXVlcnkuY29tL3Byb2plY3QvYmdpZnJhbWUpXFxuICAgKiBTcGVjaWFsIHRoYW5rcyB0byBCcmFuZG9uIEFhcm9uXFxuICAgKi9cXG5cXHRcXHRCR0lGUkFNRSA9ICc8aWZyYW1lIGNsYXNzPVxcXCJxdGlwLWJnaWZyYW1lXFxcIiBmcmFtZWJvcmRlcj1cXFwiMFxcXCIgdGFiaW5kZXg9XFxcIi0xXFxcIiBzcmM9XFxcImphdmFzY3JpcHQ6XFxcXCdcXFxcJztcXFwiICcgKyAnIHN0eWxlPVxcXCJkaXNwbGF5OmJsb2NrOyBwb3NpdGlvbjphYnNvbHV0ZTsgei1pbmRleDotMTsgZmlsdGVyOmFscGhhKG9wYWNpdHk9MCk7ICcgKyAnLW1zLWZpbHRlcjpcXFwicHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LkFscGhhKE9wYWNpdHk9MClcXFwiO1xcXCI+PC9pZnJhbWU+JztcXG5cXG5cXHRcXHRmdW5jdGlvbiBJZTYoYXBpLCBxdGlwKSB7XFxuXFx0XFx0XFx0dGhpcy5fbnMgPSAnaWU2JztcXG5cXHRcXHRcXHR0aGlzLmluaXQodGhpcy5xdGlwID0gYXBpKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0JC5leHRlbmQoSWU2LnByb3RvdHlwZSwge1xcblxcdFxcdFxcdF9zY3JvbGw6IGZ1bmN0aW9uIF9zY3JvbGwoKSB7XFxuXFx0XFx0XFx0XFx0dmFyIG92ZXJsYXkgPSB0aGlzLnF0aXAuZWxlbWVudHMub3ZlcmxheTtcXG5cXHRcXHRcXHRcXHRvdmVybGF5ICYmIChvdmVybGF5WzBdLnN0eWxlLnRvcCA9ICQod2luZG93KS5zY3JvbGxUb3AoKSArICdweCcpO1xcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0aW5pdDogZnVuY3Rpb24gaW5pdChxdGlwKSB7XFxuXFx0XFx0XFx0XFx0dmFyIHRvb2x0aXAgPSBxdGlwLnRvb2x0aXAsXFxuXFx0XFx0XFx0XFx0ICAgIHNjcm9sbDtcXG5cXG5cXHRcXHRcXHRcXHQvLyBDcmVhdGUgdGhlIEJHSUZyYW1lIGVsZW1lbnQgaWYgbmVlZGVkXFxuXFx0XFx0XFx0XFx0aWYgKCQoJ3NlbGVjdCwgb2JqZWN0JykubGVuZ3RoIDwgMSkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuYmdpZnJhbWUgPSBxdGlwLmVsZW1lbnRzLmJnaWZyYW1lID0gJChCR0lGUkFNRSkuYXBwZW5kVG8odG9vbHRpcCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gVXBkYXRlIEJHSUZyYW1lIG9uIHRvb2x0aXAgbW92ZVxcblxcdFxcdFxcdFxcdFxcdHF0aXAuX2JpbmQodG9vbHRpcCwgJ3Rvb2x0aXBtb3ZlJywgdGhpcy5hZGp1c3RCR0lGcmFtZSwgdGhpcy5fbnMsIHRoaXMpO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyByZWRyYXcoKSBjb250YWluZXIgZm9yIHdpZHRoL2hlaWdodCBjYWxjdWxhdGlvbnNcXG5cXHRcXHRcXHRcXHR0aGlzLnJlZHJhd0NvbnRhaW5lciA9ICQoJzxkaXYvPicsIHsgaWQ6IE5BTUVTUEFDRSArICctcmNvbnRhaW5lcicgfSkuYXBwZW5kVG8oZG9jdW1lbnQuYm9keSk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gRml4dXAgbW9kYWwgcGx1Z2luIGlmIHByZXNlbnQgdG9vXFxuXFx0XFx0XFx0XFx0aWYgKHF0aXAuZWxlbWVudHMub3ZlcmxheSAmJiBxdGlwLmVsZW1lbnRzLm92ZXJsYXkuYWRkQ2xhc3MoJ3F0aXBtb2RhbC1pZTZmaXgnKSkge1xcblxcdFxcdFxcdFxcdFxcdHF0aXAuX2JpbmQod2luZG93LCBbJ3Njcm9sbCcsICdyZXNpemUnXSwgdGhpcy5fc2Nyb2xsLCB0aGlzLl9ucywgdGhpcyk7XFxuXFx0XFx0XFx0XFx0XFx0cXRpcC5fYmluZCh0b29sdGlwLCBbJ3Rvb2x0aXBzaG93J10sIHRoaXMuX3Njcm9sbCwgdGhpcy5fbnMsIHRoaXMpO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBTZXQgZGltZW5zaW9uc1xcblxcdFxcdFxcdFxcdHRoaXMucmVkcmF3KCk7XFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRhZGp1c3RCR0lGcmFtZTogZnVuY3Rpb24gYWRqdXN0QkdJRnJhbWUoKSB7XFxuXFx0XFx0XFx0XFx0dmFyIHRvb2x0aXAgPSB0aGlzLnF0aXAudG9vbHRpcCxcXG5cXHRcXHRcXHRcXHQgICAgZGltZW5zaW9ucyA9IHtcXG5cXHRcXHRcXHRcXHRcXHRoZWlnaHQ6IHRvb2x0aXAub3V0ZXJIZWlnaHQoRkFMU0UpLFxcblxcdFxcdFxcdFxcdFxcdHdpZHRoOiB0b29sdGlwLm91dGVyV2lkdGgoRkFMU0UpXFxuXFx0XFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRcXHQgICAgcGx1Z2luID0gdGhpcy5xdGlwLnBsdWdpbnMudGlwLFxcblxcdFxcdFxcdFxcdCAgICB0aXAgPSB0aGlzLnF0aXAuZWxlbWVudHMudGlwLFxcblxcdFxcdFxcdFxcdCAgICB0aXBBZGp1c3QsXFxuXFx0XFx0XFx0XFx0ICAgIG9mZnNldDtcXG5cXG5cXHRcXHRcXHRcXHQvLyBBZGp1c3QgYm9yZGVyIG9mZnNldFxcblxcdFxcdFxcdFxcdG9mZnNldCA9IHBhcnNlSW50KHRvb2x0aXAuY3NzKCdib3JkZXJMZWZ0V2lkdGgnKSwgMTApIHx8IDA7XFxuXFx0XFx0XFx0XFx0b2Zmc2V0ID0geyBsZWZ0OiAtb2Zmc2V0LCB0b3A6IC1vZmZzZXQgfTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBBZGp1c3QgZm9yIHRpcHMgcGx1Z2luXFxuXFx0XFx0XFx0XFx0aWYgKHBsdWdpbiAmJiB0aXApIHtcXG5cXHRcXHRcXHRcXHRcXHR0aXBBZGp1c3QgPSBwbHVnaW4uY29ybmVyLnByZWNlZGFuY2UgPT09ICd4JyA/IFtXSURUSCwgTEVGVF0gOiBbSEVJR0hULCBUT1BdO1xcblxcdFxcdFxcdFxcdFxcdG9mZnNldFt0aXBBZGp1c3RbMV1dIC09IHRpcFt0aXBBZGp1c3RbMF1dKCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIFVwZGF0ZSBiZ2lmcmFtZVxcblxcdFxcdFxcdFxcdHRoaXMuYmdpZnJhbWUuY3NzKG9mZnNldCkuY3NzKGRpbWVuc2lvbnMpO1xcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0Ly8gTWF4L21pbiB3aWR0aCBzaW11bGF0b3IgZnVuY3Rpb25cXG5cXHRcXHRcXHRyZWRyYXc6IGZ1bmN0aW9uIHJlZHJhdygpIHtcXG5cXHRcXHRcXHRcXHRpZiAodGhpcy5xdGlwLnJlbmRlcmVkIDwgMSB8fCB0aGlzLmRyYXdpbmcpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHRvb2x0aXAgPSB0aGlzLnF0aXAudG9vbHRpcCxcXG5cXHRcXHRcXHRcXHQgICAgc3R5bGUgPSB0aGlzLnF0aXAub3B0aW9ucy5zdHlsZSxcXG5cXHRcXHRcXHRcXHQgICAgY29udGFpbmVyID0gdGhpcy5xdGlwLm9wdGlvbnMucG9zaXRpb24uY29udGFpbmVyLFxcblxcdFxcdFxcdFxcdCAgICBwZXJjLFxcblxcdFxcdFxcdFxcdCAgICB3aWR0aCxcXG5cXHRcXHRcXHRcXHQgICAgbWF4LFxcblxcdFxcdFxcdFxcdCAgICBtaW47XFxuXFxuXFx0XFx0XFx0XFx0Ly8gU2V0IGRyYXdpbmcgZmxhZ1xcblxcdFxcdFxcdFxcdHRoaXMucXRpcC5kcmF3aW5nID0gMTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBJZiB0b29sdGlwIGhhcyBhIHNldCBoZWlnaHQvd2lkdGgsIGp1c3Qgc2V0IGl0Li4uIGxpa2UgYSBib3NzIVxcblxcdFxcdFxcdFxcdGlmIChzdHlsZS5oZWlnaHQpIHtcXG5cXHRcXHRcXHRcXHRcXHR0b29sdGlwLmNzcyhIRUlHSFQsIHN0eWxlLmhlaWdodCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGlmIChzdHlsZS53aWR0aCkge1xcblxcdFxcdFxcdFxcdFxcdHRvb2x0aXAuY3NzKFdJRFRILCBzdHlsZS53aWR0aCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIFNpbXVsYXRlIG1heC9taW4gd2lkdGggaWYgbm90IHNldCB3aWR0aCBwcmVzZW50Li4uXFxuXFx0XFx0XFx0XFx0ZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gUmVzZXQgd2lkdGggYW5kIGFkZCBmbHVpZCBjbGFzc1xcblxcdFxcdFxcdFxcdFxcdFxcdHRvb2x0aXAuY3NzKFdJRFRILCAnJykuYXBwZW5kVG8odGhpcy5yZWRyYXdDb250YWluZXIpO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIEdyYWIgb3VyIHRvb2x0aXAgd2lkdGggKGFkZCAxIGlmIG9kZCBzbyB3ZSBkb24ndCBnZXQgd3JhcHBpbmcgcHJvYmxlbXMuLiBodXp6YWghKVxcblxcdFxcdFxcdFxcdFxcdFxcdHdpZHRoID0gdG9vbHRpcC53aWR0aCgpO1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICh3aWR0aCAlIDIgPCAxKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0d2lkdGggKz0gMTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gR3JhYiBvdXIgbWF4L21pbiBwcm9wZXJ0aWVzXFxuXFx0XFx0XFx0XFx0XFx0XFx0bWF4ID0gdG9vbHRpcC5jc3MoJ21heFdpZHRoJykgfHwgJyc7XFxuXFx0XFx0XFx0XFx0XFx0XFx0bWluID0gdG9vbHRpcC5jc3MoJ21pbldpZHRoJykgfHwgJyc7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gUGFyc2UgaW50byBwcm9wZXIgcGl4ZWwgdmFsdWVzXFxuXFx0XFx0XFx0XFx0XFx0XFx0cGVyYyA9IChtYXggKyBtaW4pLmluZGV4T2YoJyUnKSA+IC0xID8gY29udGFpbmVyLndpZHRoKCkgLyAxMDAgOiAwO1xcblxcdFxcdFxcdFxcdFxcdFxcdG1heCA9IChtYXguaW5kZXhPZignJScpID4gLTEgPyBwZXJjIDogMSkgKiBwYXJzZUludChtYXgsIDEwKSB8fCB3aWR0aDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRtaW4gPSAobWluLmluZGV4T2YoJyUnKSA+IC0xID8gcGVyYyA6IDEpICogcGFyc2VJbnQobWluLCAxMCkgfHwgMDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBEZXRlcm1pbmUgbmV3IGRpbWVuc2lvbiBzaXplIGJhc2VkIG9uIG1heC9taW4vY3VycmVudCB2YWx1ZXNcXG5cXHRcXHRcXHRcXHRcXHRcXHR3aWR0aCA9IG1heCArIG1pbiA/IE1hdGgubWluKE1hdGgubWF4KHdpZHRoLCBtaW4pLCBtYXgpIDogd2lkdGg7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gU2V0IHRoZSBuZXdseSBjYWxjdWxhdGVkIHdpZHRoIGFuZCByZW12b2UgZmx1aWQgY2xhc3NcXG5cXHRcXHRcXHRcXHRcXHRcXHR0b29sdGlwLmNzcyhXSURUSCwgTWF0aC5yb3VuZCh3aWR0aCkpLmFwcGVuZFRvKGNvbnRhaW5lcik7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIFNldCBkcmF3aW5nIGZsYWdcXG5cXHRcXHRcXHRcXHR0aGlzLmRyYXdpbmcgPSAwO1xcblxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0ZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcXG5cXHRcXHRcXHRcXHQvLyBSZW1vdmUgaWZyYW1lXFxuXFx0XFx0XFx0XFx0dGhpcy5iZ2lmcmFtZSAmJiB0aGlzLmJnaWZyYW1lLnJlbW92ZSgpO1xcblxcblxcdFxcdFxcdFxcdC8vIFJlbW92ZSBib3VuZCBldmVudHNcXG5cXHRcXHRcXHRcXHR0aGlzLnF0aXAuX3VuYmluZChbd2luZG93LCB0aGlzLnF0aXAudG9vbHRpcF0sIHRoaXMuX25zKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSk7XFxuXFxuXFx0XFx0SUU2ID0gUExVR0lOUy5pZTYgPSBmdW5jdGlvbiAoYXBpKSB7XFxuXFx0XFx0XFx0Ly8gUHJvY2VlZCBvbmx5IGlmIHRoZSBicm93c2VyIGlzIElFNlxcblxcdFxcdFxcdHJldHVybiBCUk9XU0VSLmllID09PSA2ID8gbmV3IEllNihhcGkpIDogRkFMU0U7XFxuXFx0XFx0fTtcXG5cXG5cXHRcXHRJRTYuaW5pdGlhbGl6ZSA9ICdyZW5kZXInO1xcblxcblxcdFxcdENIRUNLUy5pZTYgPSB7XFxuXFx0XFx0XFx0J15jb250ZW50fHN0eWxlJCc6IGZ1bmN0aW9uIGNvbnRlbnRTdHlsZSQoKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5yZWRyYXcoKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fTtcXG5cXHRcXHQ7XFxuXFx0fSk7XFxufSkod2luZG93LCBkb2N1bWVudCk7XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yYXctbG9hZGVyIS4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWI/P3JlZi0tMC0wIS4vYXNzZXRzL2pzL2pxdWVyeS5xdGlwLm5pZ2h0bHkuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3Jhdy1sb2FkZXIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0wLTAhLi9hc3NldHMvanMvanF1ZXJ5LnF0aXAubmlnaHRseS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIm1vZHVsZS5leHBvcnRzID0gXCJ2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXFxcInN5bWJvbFxcXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXFxcInN5bWJvbFxcXCIgOiB0eXBlb2Ygb2JqOyB9O1xcblxcbi8qISBqUXVlcnkgVUkgLSB2MS4xMS40IC0gMjAxNS0wMy0xMVxcbiogaHR0cDovL2pxdWVyeXVpLmNvbVxcbiogSW5jbHVkZXM6IGNvcmUuanMsIHdpZGdldC5qcywgbW91c2UuanMsIHBvc2l0aW9uLmpzLCBhY2NvcmRpb24uanMsIGF1dG9jb21wbGV0ZS5qcywgYnV0dG9uLmpzLCBkYXRlcGlja2VyLmpzLCBkaWFsb2cuanMsIGRyYWdnYWJsZS5qcywgZHJvcHBhYmxlLmpzLCBlZmZlY3QuanMsIGVmZmVjdC1ibGluZC5qcywgZWZmZWN0LWJvdW5jZS5qcywgZWZmZWN0LWNsaXAuanMsIGVmZmVjdC1kcm9wLmpzLCBlZmZlY3QtZXhwbG9kZS5qcywgZWZmZWN0LWZhZGUuanMsIGVmZmVjdC1mb2xkLmpzLCBlZmZlY3QtaGlnaGxpZ2h0LmpzLCBlZmZlY3QtcHVmZi5qcywgZWZmZWN0LXB1bHNhdGUuanMsIGVmZmVjdC1zY2FsZS5qcywgZWZmZWN0LXNoYWtlLmpzLCBlZmZlY3Qtc2l6ZS5qcywgZWZmZWN0LXNsaWRlLmpzLCBlZmZlY3QtdHJhbnNmZXIuanMsIG1lbnUuanMsIHByb2dyZXNzYmFyLmpzLCByZXNpemFibGUuanMsIHNlbGVjdGFibGUuanMsIHNlbGVjdG1lbnUuanMsIHNsaWRlci5qcywgc29ydGFibGUuanMsIHNwaW5uZXIuanMsIHRhYnMuanMsIHRvb2x0aXAuanNcXG4qIENvcHlyaWdodCAyMDE1IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnM7IExpY2Vuc2VkIE1JVCAqL1xcblxcbihmdW5jdGlvbiAoZmFjdG9yeSkge1xcblxcdGlmICh0eXBlb2YgZGVmaW5lID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIGRlZmluZS5hbWQpIHtcXG5cXG5cXHRcXHQvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXFxuXFx0XFx0ZGVmaW5lKFtcXFwianF1ZXJ5XFxcIl0sIGZhY3RvcnkpO1xcblxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0Ly8gQnJvd3NlciBnbG9iYWxzXFxuXFx0XFx0ZmFjdG9yeShqUXVlcnkpO1xcblxcdH1cXG59KShmdW5jdGlvbiAoJCkge1xcblxcdC8qIVxcbiAgKiBqUXVlcnkgVUkgQ29yZSAxLjExLjRcXG4gICogaHR0cDovL2pxdWVyeXVpLmNvbVxcbiAgKlxcbiAgKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xcbiAgKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXFxuICAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcXG4gICpcXG4gICogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20vY2F0ZWdvcnkvdWktY29yZS9cXG4gICovXFxuXFxuXFx0Ly8gJC51aSBtaWdodCBleGlzdCBmcm9tIGNvbXBvbmVudHMgd2l0aCBubyBkZXBlbmRlbmNpZXMsIGUuZy4sICQudWkucG9zaXRpb25cXG5cXHQkLnVpID0gJC51aSB8fCB7fTtcXG5cXG5cXHQkLmV4dGVuZCgkLnVpLCB7XFxuXFx0XFx0dmVyc2lvbjogXFxcIjEuMTEuNFxcXCIsXFxuXFxuXFx0XFx0a2V5Q29kZToge1xcblxcdFxcdFxcdEJBQ0tTUEFDRTogOCxcXG5cXHRcXHRcXHRDT01NQTogMTg4LFxcblxcdFxcdFxcdERFTEVURTogNDYsXFxuXFx0XFx0XFx0RE9XTjogNDAsXFxuXFx0XFx0XFx0RU5EOiAzNSxcXG5cXHRcXHRcXHRFTlRFUjogMTMsXFxuXFx0XFx0XFx0RVNDQVBFOiAyNyxcXG5cXHRcXHRcXHRIT01FOiAzNixcXG5cXHRcXHRcXHRMRUZUOiAzNyxcXG5cXHRcXHRcXHRQQUdFX0RPV046IDM0LFxcblxcdFxcdFxcdFBBR0VfVVA6IDMzLFxcblxcdFxcdFxcdFBFUklPRDogMTkwLFxcblxcdFxcdFxcdFJJR0hUOiAzOSxcXG5cXHRcXHRcXHRTUEFDRTogMzIsXFxuXFx0XFx0XFx0VEFCOiA5LFxcblxcdFxcdFxcdFVQOiAzOFxcblxcdFxcdH1cXG5cXHR9KTtcXG5cXG5cXHQvLyBwbHVnaW5zXFxuXFx0JC5mbi5leHRlbmQoe1xcblxcdFxcdHNjcm9sbFBhcmVudDogZnVuY3Rpb24gc2Nyb2xsUGFyZW50KGluY2x1ZGVIaWRkZW4pIHtcXG5cXHRcXHRcXHR2YXIgcG9zaXRpb24gPSB0aGlzLmNzcyhcXFwicG9zaXRpb25cXFwiKSxcXG5cXHRcXHRcXHQgICAgZXhjbHVkZVN0YXRpY1BhcmVudCA9IHBvc2l0aW9uID09PSBcXFwiYWJzb2x1dGVcXFwiLFxcblxcdFxcdFxcdCAgICBvdmVyZmxvd1JlZ2V4ID0gaW5jbHVkZUhpZGRlbiA/IC8oYXV0b3xzY3JvbGx8aGlkZGVuKS8gOiAvKGF1dG98c2Nyb2xsKS8sXFxuXFx0XFx0XFx0ICAgIHNjcm9sbFBhcmVudCA9IHRoaXMucGFyZW50cygpLmZpbHRlcihmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0dmFyIHBhcmVudCA9ICQodGhpcyk7XFxuXFx0XFx0XFx0XFx0aWYgKGV4Y2x1ZGVTdGF0aWNQYXJlbnQgJiYgcGFyZW50LmNzcyhcXFwicG9zaXRpb25cXFwiKSA9PT0gXFxcInN0YXRpY1xcXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHJldHVybiBvdmVyZmxvd1JlZ2V4LnRlc3QocGFyZW50LmNzcyhcXFwib3ZlcmZsb3dcXFwiKSArIHBhcmVudC5jc3MoXFxcIm92ZXJmbG93LXlcXFwiKSArIHBhcmVudC5jc3MoXFxcIm92ZXJmbG93LXhcXFwiKSk7XFxuXFx0XFx0XFx0fSkuZXEoMCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHBvc2l0aW9uID09PSBcXFwiZml4ZWRcXFwiIHx8ICFzY3JvbGxQYXJlbnQubGVuZ3RoID8gJCh0aGlzWzBdLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQpIDogc2Nyb2xsUGFyZW50O1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0dW5pcXVlSWQ6IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHR2YXIgdXVpZCA9IDA7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIXRoaXMuaWQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLmlkID0gXFxcInVpLWlkLVxcXCIgKyArK3V1aWQ7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdH07XFxuXFx0XFx0fSgpLFxcblxcblxcdFxcdHJlbW92ZVVuaXF1ZUlkOiBmdW5jdGlvbiByZW1vdmVVbmlxdWVJZCgpIHtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRpZiAoL151aS1pZC1cXFxcZCskLy50ZXN0KHRoaXMuaWQpKSB7XFxuXFx0XFx0XFx0XFx0XFx0JCh0aGlzKS5yZW1vdmVBdHRyKFxcXCJpZFxcXCIpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHR9XFxuXFx0fSk7XFxuXFxuXFx0Ly8gc2VsZWN0b3JzXFxuXFx0ZnVuY3Rpb24gX2ZvY3VzYWJsZShlbGVtZW50LCBpc1RhYkluZGV4Tm90TmFOKSB7XFxuXFx0XFx0dmFyIG1hcCxcXG5cXHRcXHQgICAgbWFwTmFtZSxcXG5cXHRcXHQgICAgaW1nLFxcblxcdFxcdCAgICBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcXG5cXHRcXHRpZiAoXFxcImFyZWFcXFwiID09PSBub2RlTmFtZSkge1xcblxcdFxcdFxcdG1hcCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcXG5cXHRcXHRcXHRtYXBOYW1lID0gbWFwLm5hbWU7XFxuXFx0XFx0XFx0aWYgKCFlbGVtZW50LmhyZWYgfHwgIW1hcE5hbWUgfHwgbWFwLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09IFxcXCJtYXBcXFwiKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpbWcgPSAkKFxcXCJpbWdbdXNlbWFwPScjXFxcIiArIG1hcE5hbWUgKyBcXFwiJ11cXFwiKVswXTtcXG5cXHRcXHRcXHRyZXR1cm4gISFpbWcgJiYgdmlzaWJsZShpbWcpO1xcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gKC9eKGlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b258b2JqZWN0KSQvLnRlc3Qobm9kZU5hbWUpID8gIWVsZW1lbnQuZGlzYWJsZWQgOiBcXFwiYVxcXCIgPT09IG5vZGVOYW1lID8gZWxlbWVudC5ocmVmIHx8IGlzVGFiSW5kZXhOb3ROYU4gOiBpc1RhYkluZGV4Tm90TmFOKSAmJlxcblxcdFxcdC8vIHRoZSBlbGVtZW50IGFuZCBhbGwgb2YgaXRzIGFuY2VzdG9ycyBtdXN0IGJlIHZpc2libGVcXG5cXHRcXHR2aXNpYmxlKGVsZW1lbnQpO1xcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiB2aXNpYmxlKGVsZW1lbnQpIHtcXG5cXHRcXHRyZXR1cm4gJC5leHByLmZpbHRlcnMudmlzaWJsZShlbGVtZW50KSAmJiAhJChlbGVtZW50KS5wYXJlbnRzKCkuYWRkQmFjaygpLmZpbHRlcihmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0cmV0dXJuICQuY3NzKHRoaXMsIFxcXCJ2aXNpYmlsaXR5XFxcIikgPT09IFxcXCJoaWRkZW5cXFwiO1xcblxcdFxcdH0pLmxlbmd0aDtcXG5cXHR9XFxuXFxuXFx0JC5leHRlbmQoJC5leHByW1xcXCI6XFxcIl0sIHtcXG5cXHRcXHRkYXRhOiAkLmV4cHIuY3JlYXRlUHNldWRvID8gJC5leHByLmNyZWF0ZVBzZXVkbyhmdW5jdGlvbiAoZGF0YU5hbWUpIHtcXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gKGVsZW0pIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gISEkLmRhdGEoZWxlbSwgZGF0YU5hbWUpO1xcblxcdFxcdFxcdH07XFxuXFx0XFx0fSkgOlxcblxcdFxcdC8vIHN1cHBvcnQ6IGpRdWVyeSA8MS44XFxuXFx0XFx0ZnVuY3Rpb24gKGVsZW0sIGksIG1hdGNoKSB7XFxuXFx0XFx0XFx0cmV0dXJuICEhJC5kYXRhKGVsZW0sIG1hdGNoWzNdKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdGZvY3VzYWJsZTogZnVuY3Rpb24gZm9jdXNhYmxlKGVsZW1lbnQpIHtcXG5cXHRcXHRcXHRyZXR1cm4gX2ZvY3VzYWJsZShlbGVtZW50LCAhaXNOYU4oJC5hdHRyKGVsZW1lbnQsIFxcXCJ0YWJpbmRleFxcXCIpKSk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHR0YWJiYWJsZTogZnVuY3Rpb24gdGFiYmFibGUoZWxlbWVudCkge1xcblxcdFxcdFxcdHZhciB0YWJJbmRleCA9ICQuYXR0cihlbGVtZW50LCBcXFwidGFiaW5kZXhcXFwiKSxcXG5cXHRcXHRcXHQgICAgaXNUYWJJbmRleE5hTiA9IGlzTmFOKHRhYkluZGV4KTtcXG5cXHRcXHRcXHRyZXR1cm4gKGlzVGFiSW5kZXhOYU4gfHwgdGFiSW5kZXggPj0gMCkgJiYgX2ZvY3VzYWJsZShlbGVtZW50LCAhaXNUYWJJbmRleE5hTik7XFxuXFx0XFx0fVxcblxcdH0pO1xcblxcblxcdC8vIHN1cHBvcnQ6IGpRdWVyeSA8MS44XFxuXFx0aWYgKCEkKFxcXCI8YT5cXFwiKS5vdXRlcldpZHRoKDEpLmpxdWVyeSkge1xcblxcdFxcdCQuZWFjaChbXFxcIldpZHRoXFxcIiwgXFxcIkhlaWdodFxcXCJdLCBmdW5jdGlvbiAoaSwgbmFtZSkge1xcblxcdFxcdFxcdHZhciBzaWRlID0gbmFtZSA9PT0gXFxcIldpZHRoXFxcIiA/IFtcXFwiTGVmdFxcXCIsIFxcXCJSaWdodFxcXCJdIDogW1xcXCJUb3BcXFwiLCBcXFwiQm90dG9tXFxcIl0sXFxuXFx0XFx0XFx0ICAgIHR5cGUgPSBuYW1lLnRvTG93ZXJDYXNlKCksXFxuXFx0XFx0XFx0ICAgIG9yaWcgPSB7XFxuXFx0XFx0XFx0XFx0aW5uZXJXaWR0aDogJC5mbi5pbm5lcldpZHRoLFxcblxcdFxcdFxcdFxcdGlubmVySGVpZ2h0OiAkLmZuLmlubmVySGVpZ2h0LFxcblxcdFxcdFxcdFxcdG91dGVyV2lkdGg6ICQuZm4ub3V0ZXJXaWR0aCxcXG5cXHRcXHRcXHRcXHRvdXRlckhlaWdodDogJC5mbi5vdXRlckhlaWdodFxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0XFx0ZnVuY3Rpb24gcmVkdWNlKGVsZW0sIHNpemUsIGJvcmRlciwgbWFyZ2luKSB7XFxuXFx0XFx0XFx0XFx0JC5lYWNoKHNpZGUsIGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHRzaXplIC09IHBhcnNlRmxvYXQoJC5jc3MoZWxlbSwgXFxcInBhZGRpbmdcXFwiICsgdGhpcykpIHx8IDA7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGJvcmRlcikge1xcblxcdFxcdFxcdFxcdFxcdFxcdHNpemUgLT0gcGFyc2VGbG9hdCgkLmNzcyhlbGVtLCBcXFwiYm9yZGVyXFxcIiArIHRoaXMgKyBcXFwiV2lkdGhcXFwiKSkgfHwgMDtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aWYgKG1hcmdpbikge1xcblxcdFxcdFxcdFxcdFxcdFxcdHNpemUgLT0gcGFyc2VGbG9hdCgkLmNzcyhlbGVtLCBcXFwibWFyZ2luXFxcIiArIHRoaXMpKSB8fCAwO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gc2l6ZTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0JC5mbltcXFwiaW5uZXJcXFwiICsgbmFtZV0gPSBmdW5jdGlvbiAoc2l6ZSkge1xcblxcdFxcdFxcdFxcdGlmIChzaXplID09PSB1bmRlZmluZWQpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gb3JpZ1tcXFwiaW5uZXJcXFwiICsgbmFtZV0uY2FsbCh0aGlzKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0XFx0JCh0aGlzKS5jc3ModHlwZSwgcmVkdWNlKHRoaXMsIHNpemUpICsgXFxcInB4XFxcIik7XFxuXFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHRcXHQkLmZuW1xcXCJvdXRlclxcXCIgKyBuYW1lXSA9IGZ1bmN0aW9uIChzaXplLCBtYXJnaW4pIHtcXG5cXHRcXHRcXHRcXHRpZiAodHlwZW9mIHNpemUgIT09IFxcXCJudW1iZXJcXFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIG9yaWdbXFxcIm91dGVyXFxcIiArIG5hbWVdLmNhbGwodGhpcywgc2l6ZSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdCQodGhpcykuY3NzKHR5cGUsIHJlZHVjZSh0aGlzLCBzaXplLCB0cnVlLCBtYXJnaW4pICsgXFxcInB4XFxcIik7XFxuXFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0fTtcXG5cXHRcXHR9KTtcXG5cXHR9XFxuXFxuXFx0Ly8gc3VwcG9ydDogalF1ZXJ5IDwxLjhcXG5cXHRpZiAoISQuZm4uYWRkQmFjaykge1xcblxcdFxcdCQuZm4uYWRkQmFjayA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xcblxcdFxcdFxcdHJldHVybiB0aGlzLmFkZChzZWxlY3RvciA9PSBudWxsID8gdGhpcy5wcmV2T2JqZWN0IDogdGhpcy5wcmV2T2JqZWN0LmZpbHRlcihzZWxlY3RvcikpO1xcblxcdFxcdH07XFxuXFx0fVxcblxcblxcdC8vIHN1cHBvcnQ6IGpRdWVyeSAxLjYuMSwgMS42LjIgKGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0Lzk0MTMpXFxuXFx0aWYgKCQoXFxcIjxhPlxcXCIpLmRhdGEoXFxcImEtYlxcXCIsIFxcXCJhXFxcIikucmVtb3ZlRGF0YShcXFwiYS1iXFxcIikuZGF0YShcXFwiYS1iXFxcIikpIHtcXG5cXHRcXHQkLmZuLnJlbW92ZURhdGEgPSBmdW5jdGlvbiAocmVtb3ZlRGF0YSkge1xcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiAoa2V5KSB7XFxuXFx0XFx0XFx0XFx0aWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gcmVtb3ZlRGF0YS5jYWxsKHRoaXMsICQuY2FtZWxDYXNlKGtleSkpO1xcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHJlbW92ZURhdGEuY2FsbCh0aGlzKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fTtcXG5cXHRcXHR9KCQuZm4ucmVtb3ZlRGF0YSk7XFxuXFx0fVxcblxcblxcdC8vIGRlcHJlY2F0ZWRcXG5cXHQkLnVpLmllID0gISEvbXNpZSBbXFxcXHcuXSsvLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKTtcXG5cXG5cXHQkLmZuLmV4dGVuZCh7XFxuXFx0XFx0Zm9jdXM6IGZ1bmN0aW9uIChvcmlnKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIChkZWxheSwgZm4pIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdHlwZW9mIGRlbGF5ID09PSBcXFwibnVtYmVyXFxcIiA/IHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGVsZW0gPSB0aGlzO1xcblxcdFxcdFxcdFxcdFxcdHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdCQoZWxlbSkuZm9jdXMoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoZm4pIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRmbi5jYWxsKGVsZW0pO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9LCBkZWxheSk7XFxuXFx0XFx0XFx0XFx0fSkgOiBvcmlnLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuXFx0XFx0XFx0fTtcXG5cXHRcXHR9KCQuZm4uZm9jdXMpLFxcblxcblxcdFxcdGRpc2FibGVTZWxlY3Rpb246IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHR2YXIgZXZlbnRUeXBlID0gXFxcIm9uc2VsZWN0c3RhcnRcXFwiIGluIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXFxcImRpdlxcXCIpID8gXFxcInNlbGVjdHN0YXJ0XFxcIiA6IFxcXCJtb3VzZWRvd25cXFwiO1xcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuYmluZChldmVudFR5cGUgKyBcXFwiLnVpLWRpc2FibGVTZWxlY3Rpb25cXFwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcXG5cXHRcXHRcXHRcXHRcXHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdH07XFxuXFx0XFx0fSgpLFxcblxcblxcdFxcdGVuYWJsZVNlbGVjdGlvbjogZnVuY3Rpb24gZW5hYmxlU2VsZWN0aW9uKCkge1xcblxcdFxcdFxcdHJldHVybiB0aGlzLnVuYmluZChcXFwiLnVpLWRpc2FibGVTZWxlY3Rpb25cXFwiKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdHpJbmRleDogZnVuY3Rpb24gekluZGV4KF96SW5kZXgpIHtcXG5cXHRcXHRcXHRpZiAoX3pJbmRleCAhPT0gdW5kZWZpbmVkKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuY3NzKFxcXCJ6SW5kZXhcXFwiLCBfekluZGV4KTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKHRoaXMubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0dmFyIGVsZW0gPSAkKHRoaXNbMF0pLFxcblxcdFxcdFxcdFxcdCAgICBwb3NpdGlvbixcXG5cXHRcXHRcXHRcXHQgICAgdmFsdWU7XFxuXFx0XFx0XFx0XFx0d2hpbGUgKGVsZW0ubGVuZ3RoICYmIGVsZW1bMF0gIT09IGRvY3VtZW50KSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gSWdub3JlIHotaW5kZXggaWYgcG9zaXRpb24gaXMgc2V0IHRvIGEgdmFsdWUgd2hlcmUgei1pbmRleCBpcyBpZ25vcmVkIGJ5IHRoZSBicm93c2VyXFxuXFx0XFx0XFx0XFx0XFx0Ly8gVGhpcyBtYWtlcyBiZWhhdmlvciBvZiB0aGlzIGZ1bmN0aW9uIGNvbnNpc3RlbnQgYWNyb3NzIGJyb3dzZXJzXFxuXFx0XFx0XFx0XFx0XFx0Ly8gV2ViS2l0IGFsd2F5cyByZXR1cm5zIGF1dG8gaWYgdGhlIGVsZW1lbnQgaXMgcG9zaXRpb25lZFxcblxcdFxcdFxcdFxcdFxcdHBvc2l0aW9uID0gZWxlbS5jc3MoXFxcInBvc2l0aW9uXFxcIik7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHBvc2l0aW9uID09PSBcXFwiYWJzb2x1dGVcXFwiIHx8IHBvc2l0aW9uID09PSBcXFwicmVsYXRpdmVcXFwiIHx8IHBvc2l0aW9uID09PSBcXFwiZml4ZWRcXFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gSUUgcmV0dXJucyAwIHdoZW4gekluZGV4IGlzIG5vdCBzcGVjaWZpZWRcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBvdGhlciBicm93c2VycyByZXR1cm4gYSBzdHJpbmdcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyB3ZSBpZ25vcmUgdGhlIGNhc2Ugb2YgbmVzdGVkIGVsZW1lbnRzIHdpdGggYW4gZXhwbGljaXQgdmFsdWUgb2YgMFxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIDxkaXYgc3R5bGU9XFxcInotaW5kZXg6IC0xMDtcXFwiPjxkaXYgc3R5bGU9XFxcInotaW5kZXg6IDA7XFxcIj48L2Rpdj48L2Rpdj5cXG5cXHRcXHRcXHRcXHRcXHRcXHR2YWx1ZSA9IHBhcnNlSW50KGVsZW0uY3NzKFxcXCJ6SW5kZXhcXFwiKSwgMTApO1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICghaXNOYU4odmFsdWUpICYmIHZhbHVlICE9PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHZhbHVlO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0ZWxlbSA9IGVsZW0ucGFyZW50KCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gMDtcXG5cXHRcXHR9XFxuXFx0fSk7XFxuXFxuXFx0Ly8gJC51aS5wbHVnaW4gaXMgZGVwcmVjYXRlZC4gVXNlICQud2lkZ2V0KCkgZXh0ZW5zaW9ucyBpbnN0ZWFkLlxcblxcdCQudWkucGx1Z2luID0ge1xcblxcdFxcdGFkZDogZnVuY3Rpb24gYWRkKG1vZHVsZSwgb3B0aW9uLCBzZXQpIHtcXG5cXHRcXHRcXHR2YXIgaSxcXG5cXHRcXHRcXHQgICAgcHJvdG8gPSAkLnVpW21vZHVsZV0ucHJvdG90eXBlO1xcblxcdFxcdFxcdGZvciAoaSBpbiBzZXQpIHtcXG5cXHRcXHRcXHRcXHRwcm90by5wbHVnaW5zW2ldID0gcHJvdG8ucGx1Z2luc1tpXSB8fCBbXTtcXG5cXHRcXHRcXHRcXHRwcm90by5wbHVnaW5zW2ldLnB1c2goW29wdGlvbiwgc2V0W2ldXSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFx0XFx0Y2FsbDogZnVuY3Rpb24gY2FsbChpbnN0YW5jZSwgbmFtZSwgYXJncywgYWxsb3dEaXNjb25uZWN0ZWQpIHtcXG5cXHRcXHRcXHR2YXIgaSxcXG5cXHRcXHRcXHQgICAgc2V0ID0gaW5zdGFuY2UucGx1Z2luc1tuYW1lXTtcXG5cXG5cXHRcXHRcXHRpZiAoIXNldCkge1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCFhbGxvd0Rpc2Nvbm5lY3RlZCAmJiAoIWluc3RhbmNlLmVsZW1lbnRbMF0ucGFyZW50Tm9kZSB8fCBpbnN0YW5jZS5lbGVtZW50WzBdLnBhcmVudE5vZGUubm9kZVR5cGUgPT09IDExKSkge1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Zm9yIChpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKykge1xcblxcdFxcdFxcdFxcdGlmIChpbnN0YW5jZS5vcHRpb25zW3NldFtpXVswXV0pIHtcXG5cXHRcXHRcXHRcXHRcXHRzZXRbaV1bMV0uYXBwbHkoaW5zdGFuY2UuZWxlbWVudCwgYXJncyk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fTtcXG5cXG5cXHQvKiFcXG4gICogalF1ZXJ5IFVJIFdpZGdldCAxLjExLjRcXG4gICogaHR0cDovL2pxdWVyeXVpLmNvbVxcbiAgKlxcbiAgKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xcbiAgKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXFxuICAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcXG4gICpcXG4gICogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20valF1ZXJ5LndpZGdldC9cXG4gICovXFxuXFxuXFx0dmFyIHdpZGdldF91dWlkID0gMCxcXG5cXHQgICAgd2lkZ2V0X3NsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xcblxcblxcdCQuY2xlYW5EYXRhID0gZnVuY3Rpb24gKG9yaWcpIHtcXG5cXHRcXHRyZXR1cm4gZnVuY3Rpb24gKGVsZW1zKSB7XFxuXFx0XFx0XFx0dmFyIGV2ZW50cywgZWxlbSwgaTtcXG5cXHRcXHRcXHRmb3IgKGkgPSAwOyAoZWxlbSA9IGVsZW1zW2ldKSAhPSBudWxsOyBpKyspIHtcXG5cXHRcXHRcXHRcXHR0cnkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIE9ubHkgdHJpZ2dlciByZW1vdmUgd2hlbiBuZWNlc3NhcnkgdG8gc2F2ZSB0aW1lXFxuXFx0XFx0XFx0XFx0XFx0ZXZlbnRzID0gJC5fZGF0YShlbGVtLCBcXFwiZXZlbnRzXFxcIik7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGV2ZW50cyAmJiBldmVudHMucmVtb3ZlKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0JChlbGVtKS50cmlnZ2VySGFuZGxlcihcXFwicmVtb3ZlXFxcIik7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdC8vIGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzgyMzVcXG5cXHRcXHRcXHRcXHR9IGNhdGNoIChlKSB7fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRvcmlnKGVsZW1zKTtcXG5cXHRcXHR9O1xcblxcdH0oJC5jbGVhbkRhdGEpO1xcblxcblxcdCQud2lkZ2V0ID0gZnVuY3Rpb24gKG5hbWUsIGJhc2UsIHByb3RvdHlwZSkge1xcblxcdFxcdHZhciBmdWxsTmFtZSxcXG5cXHRcXHQgICAgZXhpc3RpbmdDb25zdHJ1Y3RvcixcXG5cXHRcXHQgICAgY29uc3RydWN0b3IsXFxuXFx0XFx0ICAgIGJhc2VQcm90b3R5cGUsXFxuXFxuXFx0XFx0Ly8gcHJveGllZFByb3RvdHlwZSBhbGxvd3MgdGhlIHByb3ZpZGVkIHByb3RvdHlwZSB0byByZW1haW4gdW5tb2RpZmllZFxcblxcdFxcdC8vIHNvIHRoYXQgaXQgY2FuIGJlIHVzZWQgYXMgYSBtaXhpbiBmb3IgbXVsdGlwbGUgd2lkZ2V0cyAoIzg4NzYpXFxuXFx0XFx0cHJveGllZFByb3RvdHlwZSA9IHt9LFxcblxcdFxcdCAgICBuYW1lc3BhY2UgPSBuYW1lLnNwbGl0KFxcXCIuXFxcIilbMF07XFxuXFxuXFx0XFx0bmFtZSA9IG5hbWUuc3BsaXQoXFxcIi5cXFwiKVsxXTtcXG5cXHRcXHRmdWxsTmFtZSA9IG5hbWVzcGFjZSArIFxcXCItXFxcIiArIG5hbWU7XFxuXFxuXFx0XFx0aWYgKCFwcm90b3R5cGUpIHtcXG5cXHRcXHRcXHRwcm90b3R5cGUgPSBiYXNlO1xcblxcdFxcdFxcdGJhc2UgPSAkLldpZGdldDtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gY3JlYXRlIHNlbGVjdG9yIGZvciBwbHVnaW5cXG5cXHRcXHQkLmV4cHJbXFxcIjpcXFwiXVtmdWxsTmFtZS50b0xvd2VyQ2FzZSgpXSA9IGZ1bmN0aW9uIChlbGVtKSB7XFxuXFx0XFx0XFx0cmV0dXJuICEhJC5kYXRhKGVsZW0sIGZ1bGxOYW1lKTtcXG5cXHRcXHR9O1xcblxcblxcdFxcdCRbbmFtZXNwYWNlXSA9ICRbbmFtZXNwYWNlXSB8fCB7fTtcXG5cXHRcXHRleGlzdGluZ0NvbnN0cnVjdG9yID0gJFtuYW1lc3BhY2VdW25hbWVdO1xcblxcdFxcdGNvbnN0cnVjdG9yID0gJFtuYW1lc3BhY2VdW25hbWVdID0gZnVuY3Rpb24gKG9wdGlvbnMsIGVsZW1lbnQpIHtcXG5cXHRcXHRcXHQvLyBhbGxvdyBpbnN0YW50aWF0aW9uIHdpdGhvdXQgXFxcIm5ld1xcXCIga2V5d29yZFxcblxcdFxcdFxcdGlmICghdGhpcy5fY3JlYXRlV2lkZ2V0KSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIG5ldyBjb25zdHJ1Y3RvcihvcHRpb25zLCBlbGVtZW50KTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gYWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IGluaXRpYWxpemluZyBmb3Igc2ltcGxlIGluaGVyaXRhbmNlXFxuXFx0XFx0XFx0Ly8gbXVzdCB1c2UgXFxcIm5ld1xcXCIga2V5d29yZCAodGhlIGNvZGUgYWJvdmUgYWx3YXlzIHBhc3NlcyBhcmdzKVxcblxcdFxcdFxcdGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5fY3JlYXRlV2lkZ2V0KG9wdGlvbnMsIGVsZW1lbnQpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9O1xcblxcdFxcdC8vIGV4dGVuZCB3aXRoIHRoZSBleGlzdGluZyBjb25zdHJ1Y3RvciB0byBjYXJyeSBvdmVyIGFueSBzdGF0aWMgcHJvcGVydGllc1xcblxcdFxcdCQuZXh0ZW5kKGNvbnN0cnVjdG9yLCBleGlzdGluZ0NvbnN0cnVjdG9yLCB7XFxuXFx0XFx0XFx0dmVyc2lvbjogcHJvdG90eXBlLnZlcnNpb24sXFxuXFx0XFx0XFx0Ly8gY29weSB0aGUgb2JqZWN0IHVzZWQgdG8gY3JlYXRlIHRoZSBwcm90b3R5cGUgaW4gY2FzZSB3ZSBuZWVkIHRvXFxuXFx0XFx0XFx0Ly8gcmVkZWZpbmUgdGhlIHdpZGdldCBsYXRlclxcblxcdFxcdFxcdF9wcm90bzogJC5leHRlbmQoe30sIHByb3RvdHlwZSksXFxuXFx0XFx0XFx0Ly8gdHJhY2sgd2lkZ2V0cyB0aGF0IGluaGVyaXQgZnJvbSB0aGlzIHdpZGdldCBpbiBjYXNlIHRoaXMgd2lkZ2V0IGlzXFxuXFx0XFx0XFx0Ly8gcmVkZWZpbmVkIGFmdGVyIGEgd2lkZ2V0IGluaGVyaXRzIGZyb20gaXRcXG5cXHRcXHRcXHRfY2hpbGRDb25zdHJ1Y3RvcnM6IFtdXFxuXFx0XFx0fSk7XFxuXFxuXFx0XFx0YmFzZVByb3RvdHlwZSA9IG5ldyBiYXNlKCk7XFxuXFx0XFx0Ly8gd2UgbmVlZCB0byBtYWtlIHRoZSBvcHRpb25zIGhhc2ggYSBwcm9wZXJ0eSBkaXJlY3RseSBvbiB0aGUgbmV3IGluc3RhbmNlXFxuXFx0XFx0Ly8gb3RoZXJ3aXNlIHdlJ2xsIG1vZGlmeSB0aGUgb3B0aW9ucyBoYXNoIG9uIHRoZSBwcm90b3R5cGUgdGhhdCB3ZSdyZVxcblxcdFxcdC8vIGluaGVyaXRpbmcgZnJvbVxcblxcdFxcdGJhc2VQcm90b3R5cGUub3B0aW9ucyA9ICQud2lkZ2V0LmV4dGVuZCh7fSwgYmFzZVByb3RvdHlwZS5vcHRpb25zKTtcXG5cXHRcXHQkLmVhY2gocHJvdG90eXBlLCBmdW5jdGlvbiAocHJvcCwgdmFsdWUpIHtcXG5cXHRcXHRcXHRpZiAoISQuaXNGdW5jdGlvbih2YWx1ZSkpIHtcXG5cXHRcXHRcXHRcXHRwcm94aWVkUHJvdG90eXBlW3Byb3BdID0gdmFsdWU7XFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRwcm94aWVkUHJvdG90eXBlW3Byb3BdID0gZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdHZhciBfc3VwZXIgPSBmdW5jdGlvbiBfc3VwZXIoKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGJhc2UucHJvdG90eXBlW3Byb3BdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuXFx0XFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRcXHQgICAgX3N1cGVyQXBwbHkgPSBmdW5jdGlvbiBfc3VwZXJBcHBseShhcmdzKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGJhc2UucHJvdG90eXBlW3Byb3BdLmFwcGx5KHRoaXMsIGFyZ3MpO1xcblxcdFxcdFxcdFxcdH07XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgX19zdXBlciA9IHRoaXMuX3N1cGVyLFxcblxcdFxcdFxcdFxcdFxcdCAgICBfX3N1cGVyQXBwbHkgPSB0aGlzLl9zdXBlckFwcGx5LFxcblxcdFxcdFxcdFxcdFxcdCAgICByZXR1cm5WYWx1ZTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9zdXBlciA9IF9zdXBlcjtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9zdXBlckFwcGx5ID0gX3N1cGVyQXBwbHk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuVmFsdWUgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcblxcblxcdFxcdFxcdFxcdFxcdHRoaXMuX3N1cGVyID0gX19zdXBlcjtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9zdXBlckFwcGx5ID0gX19zdXBlckFwcGx5O1xcblxcblxcdFxcdFxcdFxcdFxcdHJldHVybiByZXR1cm5WYWx1ZTtcXG5cXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdH0oKTtcXG5cXHRcXHR9KTtcXG5cXHRcXHRjb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSAkLndpZGdldC5leHRlbmQoYmFzZVByb3RvdHlwZSwge1xcblxcdFxcdFxcdC8vIFRPRE86IHJlbW92ZSBzdXBwb3J0IGZvciB3aWRnZXRFdmVudFByZWZpeFxcblxcdFxcdFxcdC8vIGFsd2F5cyB1c2UgdGhlIG5hbWUgKyBhIGNvbG9uIGFzIHRoZSBwcmVmaXgsIGUuZy4sIGRyYWdnYWJsZTpzdGFydFxcblxcdFxcdFxcdC8vIGRvbid0IHByZWZpeCBmb3Igd2lkZ2V0cyB0aGF0IGFyZW4ndCBET00tYmFzZWRcXG5cXHRcXHRcXHR3aWRnZXRFdmVudFByZWZpeDogZXhpc3RpbmdDb25zdHJ1Y3RvciA/IGJhc2VQcm90b3R5cGUud2lkZ2V0RXZlbnRQcmVmaXggfHwgbmFtZSA6IG5hbWVcXG5cXHRcXHR9LCBwcm94aWVkUHJvdG90eXBlLCB7XFxuXFx0XFx0XFx0Y29uc3RydWN0b3I6IGNvbnN0cnVjdG9yLFxcblxcdFxcdFxcdG5hbWVzcGFjZTogbmFtZXNwYWNlLFxcblxcdFxcdFxcdHdpZGdldE5hbWU6IG5hbWUsXFxuXFx0XFx0XFx0d2lkZ2V0RnVsbE5hbWU6IGZ1bGxOYW1lXFxuXFx0XFx0fSk7XFxuXFxuXFx0XFx0Ly8gSWYgdGhpcyB3aWRnZXQgaXMgYmVpbmcgcmVkZWZpbmVkIHRoZW4gd2UgbmVlZCB0byBmaW5kIGFsbCB3aWRnZXRzIHRoYXRcXG5cXHRcXHQvLyBhcmUgaW5oZXJpdGluZyBmcm9tIGl0IGFuZCByZWRlZmluZSBhbGwgb2YgdGhlbSBzbyB0aGF0IHRoZXkgaW5oZXJpdCBmcm9tXFxuXFx0XFx0Ly8gdGhlIG5ldyB2ZXJzaW9uIG9mIHRoaXMgd2lkZ2V0LiBXZSdyZSBlc3NlbnRpYWxseSB0cnlpbmcgdG8gcmVwbGFjZSBvbmVcXG5cXHRcXHQvLyBsZXZlbCBpbiB0aGUgcHJvdG90eXBlIGNoYWluLlxcblxcdFxcdGlmIChleGlzdGluZ0NvbnN0cnVjdG9yKSB7XFxuXFx0XFx0XFx0JC5lYWNoKGV4aXN0aW5nQ29uc3RydWN0b3IuX2NoaWxkQ29uc3RydWN0b3JzLCBmdW5jdGlvbiAoaSwgY2hpbGQpIHtcXG5cXHRcXHRcXHRcXHR2YXIgY2hpbGRQcm90b3R5cGUgPSBjaGlsZC5wcm90b3R5cGU7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gcmVkZWZpbmUgdGhlIGNoaWxkIHdpZGdldCB1c2luZyB0aGUgc2FtZSBwcm90b3R5cGUgdGhhdCB3YXNcXG5cXHRcXHRcXHRcXHQvLyBvcmlnaW5hbGx5IHVzZWQsIGJ1dCBpbmhlcml0IGZyb20gdGhlIG5ldyB2ZXJzaW9uIG9mIHRoZSBiYXNlXFxuXFx0XFx0XFx0XFx0JC53aWRnZXQoY2hpbGRQcm90b3R5cGUubmFtZXNwYWNlICsgXFxcIi5cXFwiICsgY2hpbGRQcm90b3R5cGUud2lkZ2V0TmFtZSwgY29uc3RydWN0b3IsIGNoaWxkLl9wcm90byk7XFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0Ly8gcmVtb3ZlIHRoZSBsaXN0IG9mIGV4aXN0aW5nIGNoaWxkIGNvbnN0cnVjdG9ycyBmcm9tIHRoZSBvbGQgY29uc3RydWN0b3JcXG5cXHRcXHRcXHQvLyBzbyB0aGUgb2xkIGNoaWxkIGNvbnN0cnVjdG9ycyBjYW4gYmUgZ2FyYmFnZSBjb2xsZWN0ZWRcXG5cXHRcXHRcXHRkZWxldGUgZXhpc3RpbmdDb25zdHJ1Y3Rvci5fY2hpbGRDb25zdHJ1Y3RvcnM7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRiYXNlLl9jaGlsZENvbnN0cnVjdG9ycy5wdXNoKGNvbnN0cnVjdG9yKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0JC53aWRnZXQuYnJpZGdlKG5hbWUsIGNvbnN0cnVjdG9yKTtcXG5cXG5cXHRcXHRyZXR1cm4gY29uc3RydWN0b3I7XFxuXFx0fTtcXG5cXG5cXHQkLndpZGdldC5leHRlbmQgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XFxuXFx0XFx0dmFyIGlucHV0ID0gd2lkZ2V0X3NsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSxcXG5cXHRcXHQgICAgaW5wdXRJbmRleCA9IDAsXFxuXFx0XFx0ICAgIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoLFxcblxcdFxcdCAgICBrZXksXFxuXFx0XFx0ICAgIHZhbHVlO1xcblxcdFxcdGZvciAoOyBpbnB1dEluZGV4IDwgaW5wdXRMZW5ndGg7IGlucHV0SW5kZXgrKykge1xcblxcdFxcdFxcdGZvciAoa2V5IGluIGlucHV0W2lucHV0SW5kZXhdKSB7XFxuXFx0XFx0XFx0XFx0dmFsdWUgPSBpbnB1dFtpbnB1dEluZGV4XVtrZXldO1xcblxcdFxcdFxcdFxcdGlmIChpbnB1dFtpbnB1dEluZGV4XS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcXG5cXHRcXHRcXHRcXHRcXHQvLyBDbG9uZSBvYmplY3RzXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCQuaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0YXJnZXRba2V5XSA9ICQuaXNQbGFpbk9iamVjdCh0YXJnZXRba2V5XSkgPyAkLndpZGdldC5leHRlbmQoe30sIHRhcmdldFtrZXldLCB2YWx1ZSkgOlxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIERvbid0IGV4dGVuZCBzdHJpbmdzLCBhcnJheXMsIGV0Yy4gd2l0aCBvYmplY3RzXFxuXFx0XFx0XFx0XFx0XFx0XFx0JC53aWRnZXQuZXh0ZW5kKHt9LCB2YWx1ZSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gQ29weSBldmVyeXRoaW5nIGVsc2UgYnkgcmVmZXJlbmNlXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0YXJnZXRba2V5XSA9IHZhbHVlO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gdGFyZ2V0O1xcblxcdH07XFxuXFxuXFx0JC53aWRnZXQuYnJpZGdlID0gZnVuY3Rpb24gKG5hbWUsIG9iamVjdCkge1xcblxcdFxcdHZhciBmdWxsTmFtZSA9IG9iamVjdC5wcm90b3R5cGUud2lkZ2V0RnVsbE5hbWUgfHwgbmFtZTtcXG5cXHRcXHQkLmZuW25hbWVdID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcXG5cXHRcXHRcXHR2YXIgaXNNZXRob2RDYWxsID0gdHlwZW9mIG9wdGlvbnMgPT09IFxcXCJzdHJpbmdcXFwiLFxcblxcdFxcdFxcdCAgICBhcmdzID0gd2lkZ2V0X3NsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSxcXG5cXHRcXHRcXHQgICAgcmV0dXJuVmFsdWUgPSB0aGlzO1xcblxcblxcdFxcdFxcdGlmIChpc01ldGhvZENhbGwpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdHZhciBtZXRob2RWYWx1ZSxcXG5cXHRcXHRcXHRcXHRcXHQgICAgaW5zdGFuY2UgPSAkLmRhdGEodGhpcywgZnVsbE5hbWUpO1xcblxcdFxcdFxcdFxcdFxcdGlmIChvcHRpb25zID09PSBcXFwiaW5zdGFuY2VcXFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuVmFsdWUgPSBpbnN0YW5jZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmICghaW5zdGFuY2UpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gJC5lcnJvcihcXFwiY2Fubm90IGNhbGwgbWV0aG9kcyBvbiBcXFwiICsgbmFtZSArIFxcXCIgcHJpb3IgdG8gaW5pdGlhbGl6YXRpb247IFxcXCIgKyBcXFwiYXR0ZW1wdGVkIHRvIGNhbGwgbWV0aG9kICdcXFwiICsgb3B0aW9ucyArIFxcXCInXFxcIik7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmICghJC5pc0Z1bmN0aW9uKGluc3RhbmNlW29wdGlvbnNdKSB8fCBvcHRpb25zLmNoYXJBdCgwKSA9PT0gXFxcIl9cXFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuICQuZXJyb3IoXFxcIm5vIHN1Y2ggbWV0aG9kICdcXFwiICsgb3B0aW9ucyArIFxcXCInIGZvciBcXFwiICsgbmFtZSArIFxcXCIgd2lkZ2V0IGluc3RhbmNlXFxcIik7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdG1ldGhvZFZhbHVlID0gaW5zdGFuY2Vbb3B0aW9uc10uYXBwbHkoaW5zdGFuY2UsIGFyZ3MpO1xcblxcdFxcdFxcdFxcdFxcdGlmIChtZXRob2RWYWx1ZSAhPT0gaW5zdGFuY2UgJiYgbWV0aG9kVmFsdWUgIT09IHVuZGVmaW5lZCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVyblZhbHVlID0gbWV0aG9kVmFsdWUgJiYgbWV0aG9kVmFsdWUuanF1ZXJ5ID8gcmV0dXJuVmFsdWUucHVzaFN0YWNrKG1ldGhvZFZhbHVlLmdldCgpKSA6IG1ldGhvZFZhbHVlO1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBBbGxvdyBtdWx0aXBsZSBoYXNoZXMgdG8gYmUgcGFzc2VkIG9uIGluaXRcXG5cXHRcXHRcXHRcXHRpZiAoYXJncy5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRcXHRvcHRpb25zID0gJC53aWRnZXQuZXh0ZW5kLmFwcGx5KG51bGwsIFtvcHRpb25zXS5jb25jYXQoYXJncykpO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdHZhciBpbnN0YW5jZSA9ICQuZGF0YSh0aGlzLCBmdWxsTmFtZSk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGluc3RhbmNlKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aW5zdGFuY2Uub3B0aW9uKG9wdGlvbnMgfHwge30pO1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChpbnN0YW5jZS5faW5pdCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGluc3RhbmNlLl9pbml0KCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0JC5kYXRhKHRoaXMsIGZ1bGxOYW1lLCBuZXcgb2JqZWN0KG9wdGlvbnMsIHRoaXMpKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiByZXR1cm5WYWx1ZTtcXG5cXHRcXHR9O1xcblxcdH07XFxuXFxuXFx0JC5XaWRnZXQgPSBmdW5jdGlvbiAoKSAvKiBvcHRpb25zLCBlbGVtZW50ICove307XFxuXFx0JC5XaWRnZXQuX2NoaWxkQ29uc3RydWN0b3JzID0gW107XFxuXFxuXFx0JC5XaWRnZXQucHJvdG90eXBlID0ge1xcblxcdFxcdHdpZGdldE5hbWU6IFxcXCJ3aWRnZXRcXFwiLFxcblxcdFxcdHdpZGdldEV2ZW50UHJlZml4OiBcXFwiXFxcIixcXG5cXHRcXHRkZWZhdWx0RWxlbWVudDogXFxcIjxkaXY+XFxcIixcXG5cXHRcXHRvcHRpb25zOiB7XFxuXFx0XFx0XFx0ZGlzYWJsZWQ6IGZhbHNlLFxcblxcblxcdFxcdFxcdC8vIGNhbGxiYWNrc1xcblxcdFxcdFxcdGNyZWF0ZTogbnVsbFxcblxcdFxcdH0sXFxuXFx0XFx0X2NyZWF0ZVdpZGdldDogZnVuY3Rpb24gX2NyZWF0ZVdpZGdldChvcHRpb25zLCBlbGVtZW50KSB7XFxuXFx0XFx0XFx0ZWxlbWVudCA9ICQoZWxlbWVudCB8fCB0aGlzLmRlZmF1bHRFbGVtZW50IHx8IHRoaXMpWzBdO1xcblxcdFxcdFxcdHRoaXMuZWxlbWVudCA9ICQoZWxlbWVudCk7XFxuXFx0XFx0XFx0dGhpcy51dWlkID0gd2lkZ2V0X3V1aWQrKztcXG5cXHRcXHRcXHR0aGlzLmV2ZW50TmFtZXNwYWNlID0gXFxcIi5cXFwiICsgdGhpcy53aWRnZXROYW1lICsgdGhpcy51dWlkO1xcblxcblxcdFxcdFxcdHRoaXMuYmluZGluZ3MgPSAkKCk7XFxuXFx0XFx0XFx0dGhpcy5ob3ZlcmFibGUgPSAkKCk7XFxuXFx0XFx0XFx0dGhpcy5mb2N1c2FibGUgPSAkKCk7XFxuXFxuXFx0XFx0XFx0aWYgKGVsZW1lbnQgIT09IHRoaXMpIHtcXG5cXHRcXHRcXHRcXHQkLmRhdGEoZWxlbWVudCwgdGhpcy53aWRnZXRGdWxsTmFtZSwgdGhpcyk7XFxuXFx0XFx0XFx0XFx0dGhpcy5fb24odHJ1ZSwgdGhpcy5lbGVtZW50LCB7XFxuXFx0XFx0XFx0XFx0XFx0cmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoZXZlbnQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoZXZlbnQudGFyZ2V0ID09PSBlbGVtZW50KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5kZXN0cm95KCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcXHR0aGlzLmRvY3VtZW50ID0gJChlbGVtZW50LnN0eWxlID9cXG5cXHRcXHRcXHRcXHQvLyBlbGVtZW50IHdpdGhpbiB0aGUgZG9jdW1lbnRcXG5cXHRcXHRcXHRcXHRlbGVtZW50Lm93bmVyRG9jdW1lbnQgOlxcblxcdFxcdFxcdFxcdC8vIGVsZW1lbnQgaXMgd2luZG93IG9yIGRvY3VtZW50XFxuXFx0XFx0XFx0XFx0ZWxlbWVudC5kb2N1bWVudCB8fCBlbGVtZW50KTtcXG5cXHRcXHRcXHRcXHR0aGlzLndpbmRvdyA9ICQodGhpcy5kb2N1bWVudFswXS5kZWZhdWx0VmlldyB8fCB0aGlzLmRvY3VtZW50WzBdLnBhcmVudFdpbmRvdyk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMub3B0aW9ucyA9ICQud2lkZ2V0LmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zLCB0aGlzLl9nZXRDcmVhdGVPcHRpb25zKCksIG9wdGlvbnMpO1xcblxcblxcdFxcdFxcdHRoaXMuX2NyZWF0ZSgpO1xcblxcdFxcdFxcdHRoaXMuX3RyaWdnZXIoXFxcImNyZWF0ZVxcXCIsIG51bGwsIHRoaXMuX2dldENyZWF0ZUV2ZW50RGF0YSgpKTtcXG5cXHRcXHRcXHR0aGlzLl9pbml0KCk7XFxuXFx0XFx0fSxcXG5cXHRcXHRfZ2V0Q3JlYXRlT3B0aW9uczogJC5ub29wLFxcblxcdFxcdF9nZXRDcmVhdGVFdmVudERhdGE6ICQubm9vcCxcXG5cXHRcXHRfY3JlYXRlOiAkLm5vb3AsXFxuXFx0XFx0X2luaXQ6ICQubm9vcCxcXG5cXG5cXHRcXHRkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xcblxcdFxcdFxcdHRoaXMuX2Rlc3Ryb3koKTtcXG5cXHRcXHRcXHQvLyB3ZSBjYW4gcHJvYmFibHkgcmVtb3ZlIHRoZSB1bmJpbmQgY2FsbHMgaW4gMi4wXFxuXFx0XFx0XFx0Ly8gYWxsIGV2ZW50IGJpbmRpbmdzIHNob3VsZCBnbyB0aHJvdWdoIHRoaXMuX29uKClcXG5cXHRcXHRcXHR0aGlzLmVsZW1lbnQudW5iaW5kKHRoaXMuZXZlbnROYW1lc3BhY2UpLnJlbW92ZURhdGEodGhpcy53aWRnZXRGdWxsTmFtZSlcXG5cXHRcXHRcXHQvLyBzdXBwb3J0OiBqcXVlcnkgPDEuNi4zXFxuXFx0XFx0XFx0Ly8gaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvOTQxM1xcblxcdFxcdFxcdC5yZW1vdmVEYXRhKCQuY2FtZWxDYXNlKHRoaXMud2lkZ2V0RnVsbE5hbWUpKTtcXG5cXHRcXHRcXHR0aGlzLndpZGdldCgpLnVuYmluZCh0aGlzLmV2ZW50TmFtZXNwYWNlKS5yZW1vdmVBdHRyKFxcXCJhcmlhLWRpc2FibGVkXFxcIikucmVtb3ZlQ2xhc3ModGhpcy53aWRnZXRGdWxsTmFtZSArIFxcXCItZGlzYWJsZWQgXFxcIiArIFxcXCJ1aS1zdGF0ZS1kaXNhYmxlZFxcXCIpO1xcblxcblxcdFxcdFxcdC8vIGNsZWFuIHVwIGV2ZW50cyBhbmQgc3RhdGVzXFxuXFx0XFx0XFx0dGhpcy5iaW5kaW5ncy51bmJpbmQodGhpcy5ldmVudE5hbWVzcGFjZSk7XFxuXFx0XFx0XFx0dGhpcy5ob3ZlcmFibGUucmVtb3ZlQ2xhc3MoXFxcInVpLXN0YXRlLWhvdmVyXFxcIik7XFxuXFx0XFx0XFx0dGhpcy5mb2N1c2FibGUucmVtb3ZlQ2xhc3MoXFxcInVpLXN0YXRlLWZvY3VzXFxcIik7XFxuXFx0XFx0fSxcXG5cXHRcXHRfZGVzdHJveTogJC5ub29wLFxcblxcblxcdFxcdHdpZGdldDogZnVuY3Rpb24gd2lkZ2V0KCkge1xcblxcdFxcdFxcdHJldHVybiB0aGlzLmVsZW1lbnQ7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRvcHRpb246IGZ1bmN0aW9uIG9wdGlvbihrZXksIHZhbHVlKSB7XFxuXFx0XFx0XFx0dmFyIG9wdGlvbnMgPSBrZXksXFxuXFx0XFx0XFx0ICAgIHBhcnRzLFxcblxcdFxcdFxcdCAgICBjdXJPcHRpb24sXFxuXFx0XFx0XFx0ICAgIGk7XFxuXFxuXFx0XFx0XFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcXG5cXHRcXHRcXHRcXHQvLyBkb24ndCByZXR1cm4gYSByZWZlcmVuY2UgdG8gdGhlIGludGVybmFsIGhhc2hcXG5cXHRcXHRcXHRcXHRyZXR1cm4gJC53aWRnZXQuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAodHlwZW9mIGtleSA9PT0gXFxcInN0cmluZ1xcXCIpIHtcXG5cXHRcXHRcXHRcXHQvLyBoYW5kbGUgbmVzdGVkIGtleXMsIGUuZy4sIFxcXCJmb28uYmFyXFxcIiA9PiB7IGZvbzogeyBiYXI6IF9fXyB9IH1cXG5cXHRcXHRcXHRcXHRvcHRpb25zID0ge307XFxuXFx0XFx0XFx0XFx0cGFydHMgPSBrZXkuc3BsaXQoXFxcIi5cXFwiKTtcXG5cXHRcXHRcXHRcXHRrZXkgPSBwYXJ0cy5zaGlmdCgpO1xcblxcdFxcdFxcdFxcdGlmIChwYXJ0cy5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRcXHRjdXJPcHRpb24gPSBvcHRpb25zW2tleV0gPSAkLndpZGdldC5leHRlbmQoe30sIHRoaXMub3B0aW9uc1trZXldKTtcXG5cXHRcXHRcXHRcXHRcXHRmb3IgKGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoIC0gMTsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y3VyT3B0aW9uW3BhcnRzW2ldXSA9IGN1ck9wdGlvbltwYXJ0c1tpXV0gfHwge307XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y3VyT3B0aW9uID0gY3VyT3B0aW9uW3BhcnRzW2ldXTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0a2V5ID0gcGFydHMucG9wKCk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gY3VyT3B0aW9uW2tleV0gPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjdXJPcHRpb25ba2V5XTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0Y3VyT3B0aW9uW2tleV0gPSB2YWx1ZTtcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMub3B0aW9uc1trZXldID09PSB1bmRlZmluZWQgPyBudWxsIDogdGhpcy5vcHRpb25zW2tleV07XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdG9wdGlvbnNba2V5XSA9IHZhbHVlO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy5fc2V0T3B0aW9ucyhvcHRpb25zKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXHRcXHR9LFxcblxcdFxcdF9zZXRPcHRpb25zOiBmdW5jdGlvbiBfc2V0T3B0aW9ucyhvcHRpb25zKSB7XFxuXFx0XFx0XFx0dmFyIGtleTtcXG5cXG5cXHRcXHRcXHRmb3IgKGtleSBpbiBvcHRpb25zKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5fc2V0T3B0aW9uKGtleSwgb3B0aW9uc1trZXldKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0XFx0fSxcXG5cXHRcXHRfc2V0T3B0aW9uOiBmdW5jdGlvbiBfc2V0T3B0aW9uKGtleSwgdmFsdWUpIHtcXG5cXHRcXHRcXHR0aGlzLm9wdGlvbnNba2V5XSA9IHZhbHVlO1xcblxcblxcdFxcdFxcdGlmIChrZXkgPT09IFxcXCJkaXNhYmxlZFxcXCIpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLndpZGdldCgpLnRvZ2dsZUNsYXNzKHRoaXMud2lkZ2V0RnVsbE5hbWUgKyBcXFwiLWRpc2FibGVkXFxcIiwgISF2YWx1ZSk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSWYgdGhlIHdpZGdldCBpcyBiZWNvbWluZyBkaXNhYmxlZCwgdGhlbiBub3RoaW5nIGlzIGludGVyYWN0aXZlXFxuXFx0XFx0XFx0XFx0aWYgKHZhbHVlKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5ob3ZlcmFibGUucmVtb3ZlQ2xhc3MoXFxcInVpLXN0YXRlLWhvdmVyXFxcIik7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5mb2N1c2FibGUucmVtb3ZlQ2xhc3MoXFxcInVpLXN0YXRlLWZvY3VzXFxcIik7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXHRcXHR9LFxcblxcblxcdFxcdGVuYWJsZTogZnVuY3Rpb24gZW5hYmxlKCkge1xcblxcdFxcdFxcdHJldHVybiB0aGlzLl9zZXRPcHRpb25zKHsgZGlzYWJsZWQ6IGZhbHNlIH0pO1xcblxcdFxcdH0sXFxuXFx0XFx0ZGlzYWJsZTogZnVuY3Rpb24gZGlzYWJsZSgpIHtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5fc2V0T3B0aW9ucyh7IGRpc2FibGVkOiB0cnVlIH0pO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X29uOiBmdW5jdGlvbiBfb24oc3VwcHJlc3NEaXNhYmxlZENoZWNrLCBlbGVtZW50LCBoYW5kbGVycykge1xcblxcdFxcdFxcdHZhciBkZWxlZ2F0ZUVsZW1lbnQsXFxuXFx0XFx0XFx0ICAgIGluc3RhbmNlID0gdGhpcztcXG5cXG5cXHRcXHRcXHQvLyBubyBzdXBwcmVzc0Rpc2FibGVkQ2hlY2sgZmxhZywgc2h1ZmZsZSBhcmd1bWVudHNcXG5cXHRcXHRcXHRpZiAodHlwZW9mIHN1cHByZXNzRGlzYWJsZWRDaGVjayAhPT0gXFxcImJvb2xlYW5cXFwiKSB7XFxuXFx0XFx0XFx0XFx0aGFuZGxlcnMgPSBlbGVtZW50O1xcblxcdFxcdFxcdFxcdGVsZW1lbnQgPSBzdXBwcmVzc0Rpc2FibGVkQ2hlY2s7XFxuXFx0XFx0XFx0XFx0c3VwcHJlc3NEaXNhYmxlZENoZWNrID0gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIG5vIGVsZW1lbnQgYXJndW1lbnQsIHNodWZmbGUgYW5kIHVzZSB0aGlzLmVsZW1lbnRcXG5cXHRcXHRcXHRpZiAoIWhhbmRsZXJzKSB7XFxuXFx0XFx0XFx0XFx0aGFuZGxlcnMgPSBlbGVtZW50O1xcblxcdFxcdFxcdFxcdGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XFxuXFx0XFx0XFx0XFx0ZGVsZWdhdGVFbGVtZW50ID0gdGhpcy53aWRnZXQoKTtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdGVsZW1lbnQgPSBkZWxlZ2F0ZUVsZW1lbnQgPSAkKGVsZW1lbnQpO1xcblxcdFxcdFxcdFxcdHRoaXMuYmluZGluZ3MgPSB0aGlzLmJpbmRpbmdzLmFkZChlbGVtZW50KTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0JC5lYWNoKGhhbmRsZXJzLCBmdW5jdGlvbiAoZXZlbnQsIGhhbmRsZXIpIHtcXG5cXHRcXHRcXHRcXHRmdW5jdGlvbiBoYW5kbGVyUHJveHkoKSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gYWxsb3cgd2lkZ2V0cyB0byBjdXN0b21pemUgdGhlIGRpc2FibGVkIGhhbmRsaW5nXFxuXFx0XFx0XFx0XFx0XFx0Ly8gLSBkaXNhYmxlZCBhcyBhbiBhcnJheSBpbnN0ZWFkIG9mIGJvb2xlYW5cXG5cXHRcXHRcXHRcXHRcXHQvLyAtIGRpc2FibGVkIGNsYXNzIGFzIG1ldGhvZCBmb3IgZGlzYWJsaW5nIGluZGl2aWR1YWwgcGFydHNcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIXN1cHByZXNzRGlzYWJsZWRDaGVjayAmJiAoaW5zdGFuY2Uub3B0aW9ucy5kaXNhYmxlZCA9PT0gdHJ1ZSB8fCAkKHRoaXMpLmhhc0NsYXNzKFxcXCJ1aS1zdGF0ZS1kaXNhYmxlZFxcXCIpKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuICh0eXBlb2YgaGFuZGxlciA9PT0gXFxcInN0cmluZ1xcXCIgPyBpbnN0YW5jZVtoYW5kbGVyXSA6IGhhbmRsZXIpLmFwcGx5KGluc3RhbmNlLCBhcmd1bWVudHMpO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBjb3B5IHRoZSBndWlkIHNvIGRpcmVjdCB1bmJpbmRpbmcgd29ya3NcXG5cXHRcXHRcXHRcXHRpZiAodHlwZW9mIGhhbmRsZXIgIT09IFxcXCJzdHJpbmdcXFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0aGFuZGxlclByb3h5Lmd1aWQgPSBoYW5kbGVyLmd1aWQgPSBoYW5kbGVyLmd1aWQgfHwgaGFuZGxlclByb3h5Lmd1aWQgfHwgJC5ndWlkKys7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHZhciBtYXRjaCA9IGV2ZW50Lm1hdGNoKC9eKFtcXFxcdzotXSopXFxcXHMqKC4qKSQvKSxcXG5cXHRcXHRcXHRcXHQgICAgZXZlbnROYW1lID0gbWF0Y2hbMV0gKyBpbnN0YW5jZS5ldmVudE5hbWVzcGFjZSxcXG5cXHRcXHRcXHRcXHQgICAgc2VsZWN0b3IgPSBtYXRjaFsyXTtcXG5cXHRcXHRcXHRcXHRpZiAoc2VsZWN0b3IpIHtcXG5cXHRcXHRcXHRcXHRcXHRkZWxlZ2F0ZUVsZW1lbnQuZGVsZWdhdGUoc2VsZWN0b3IsIGV2ZW50TmFtZSwgaGFuZGxlclByb3h5KTtcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdGVsZW1lbnQuYmluZChldmVudE5hbWUsIGhhbmRsZXJQcm94eSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0pO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X29mZjogZnVuY3Rpb24gX29mZihlbGVtZW50LCBldmVudE5hbWUpIHtcXG5cXHRcXHRcXHRldmVudE5hbWUgPSAoZXZlbnROYW1lIHx8IFxcXCJcXFwiKS5zcGxpdChcXFwiIFxcXCIpLmpvaW4odGhpcy5ldmVudE5hbWVzcGFjZSArIFxcXCIgXFxcIikgKyB0aGlzLmV2ZW50TmFtZXNwYWNlO1xcblxcdFxcdFxcdGVsZW1lbnQudW5iaW5kKGV2ZW50TmFtZSkudW5kZWxlZ2F0ZShldmVudE5hbWUpO1xcblxcblxcdFxcdFxcdC8vIENsZWFyIHRoZSBzdGFjayB0byBhdm9pZCBtZW1vcnkgbGVha3MgKCMxMDA1NilcXG5cXHRcXHRcXHR0aGlzLmJpbmRpbmdzID0gJCh0aGlzLmJpbmRpbmdzLm5vdChlbGVtZW50KS5nZXQoKSk7XFxuXFx0XFx0XFx0dGhpcy5mb2N1c2FibGUgPSAkKHRoaXMuZm9jdXNhYmxlLm5vdChlbGVtZW50KS5nZXQoKSk7XFxuXFx0XFx0XFx0dGhpcy5ob3ZlcmFibGUgPSAkKHRoaXMuaG92ZXJhYmxlLm5vdChlbGVtZW50KS5nZXQoKSk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfZGVsYXk6IGZ1bmN0aW9uIF9kZWxheShoYW5kbGVyLCBkZWxheSkge1xcblxcdFxcdFxcdGZ1bmN0aW9uIGhhbmRsZXJQcm94eSgpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gKHR5cGVvZiBoYW5kbGVyID09PSBcXFwic3RyaW5nXFxcIiA/IGluc3RhbmNlW2hhbmRsZXJdIDogaGFuZGxlcikuYXBwbHkoaW5zdGFuY2UsIGFyZ3VtZW50cyk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHZhciBpbnN0YW5jZSA9IHRoaXM7XFxuXFx0XFx0XFx0cmV0dXJuIHNldFRpbWVvdXQoaGFuZGxlclByb3h5LCBkZWxheSB8fCAwKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9ob3ZlcmFibGU6IGZ1bmN0aW9uIF9ob3ZlcmFibGUoZWxlbWVudCkge1xcblxcdFxcdFxcdHRoaXMuaG92ZXJhYmxlID0gdGhpcy5ob3ZlcmFibGUuYWRkKGVsZW1lbnQpO1xcblxcdFxcdFxcdHRoaXMuX29uKGVsZW1lbnQsIHtcXG5cXHRcXHRcXHRcXHRtb3VzZWVudGVyOiBmdW5jdGlvbiBtb3VzZWVudGVyKGV2ZW50KSB7XFxuXFx0XFx0XFx0XFx0XFx0JChldmVudC5jdXJyZW50VGFyZ2V0KS5hZGRDbGFzcyhcXFwidWktc3RhdGUtaG92ZXJcXFwiKTtcXG5cXHRcXHRcXHRcXHR9LFxcblxcdFxcdFxcdFxcdG1vdXNlbGVhdmU6IGZ1bmN0aW9uIG1vdXNlbGVhdmUoZXZlbnQpIHtcXG5cXHRcXHRcXHRcXHRcXHQkKGV2ZW50LmN1cnJlbnRUYXJnZXQpLnJlbW92ZUNsYXNzKFxcXCJ1aS1zdGF0ZS1ob3ZlclxcXCIpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9mb2N1c2FibGU6IGZ1bmN0aW9uIF9mb2N1c2FibGUoZWxlbWVudCkge1xcblxcdFxcdFxcdHRoaXMuZm9jdXNhYmxlID0gdGhpcy5mb2N1c2FibGUuYWRkKGVsZW1lbnQpO1xcblxcdFxcdFxcdHRoaXMuX29uKGVsZW1lbnQsIHtcXG5cXHRcXHRcXHRcXHRmb2N1c2luOiBmdW5jdGlvbiBmb2N1c2luKGV2ZW50KSB7XFxuXFx0XFx0XFx0XFx0XFx0JChldmVudC5jdXJyZW50VGFyZ2V0KS5hZGRDbGFzcyhcXFwidWktc3RhdGUtZm9jdXNcXFwiKTtcXG5cXHRcXHRcXHRcXHR9LFxcblxcdFxcdFxcdFxcdGZvY3Vzb3V0OiBmdW5jdGlvbiBmb2N1c291dChldmVudCkge1xcblxcdFxcdFxcdFxcdFxcdCQoZXZlbnQuY3VycmVudFRhcmdldCkucmVtb3ZlQ2xhc3MoXFxcInVpLXN0YXRlLWZvY3VzXFxcIik7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0pO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X3RyaWdnZXI6IGZ1bmN0aW9uIF90cmlnZ2VyKHR5cGUsIGV2ZW50LCBkYXRhKSB7XFxuXFx0XFx0XFx0dmFyIHByb3AsXFxuXFx0XFx0XFx0ICAgIG9yaWcsXFxuXFx0XFx0XFx0ICAgIGNhbGxiYWNrID0gdGhpcy5vcHRpb25zW3R5cGVdO1xcblxcblxcdFxcdFxcdGRhdGEgPSBkYXRhIHx8IHt9O1xcblxcdFxcdFxcdGV2ZW50ID0gJC5FdmVudChldmVudCk7XFxuXFx0XFx0XFx0ZXZlbnQudHlwZSA9ICh0eXBlID09PSB0aGlzLndpZGdldEV2ZW50UHJlZml4ID8gdHlwZSA6IHRoaXMud2lkZ2V0RXZlbnRQcmVmaXggKyB0eXBlKS50b0xvd2VyQ2FzZSgpO1xcblxcdFxcdFxcdC8vIHRoZSBvcmlnaW5hbCBldmVudCBtYXkgY29tZSBmcm9tIGFueSBlbGVtZW50XFxuXFx0XFx0XFx0Ly8gc28gd2UgbmVlZCB0byByZXNldCB0aGUgdGFyZ2V0IG9uIHRoZSBuZXcgZXZlbnRcXG5cXHRcXHRcXHRldmVudC50YXJnZXQgPSB0aGlzLmVsZW1lbnRbMF07XFxuXFxuXFx0XFx0XFx0Ly8gY29weSBvcmlnaW5hbCBldmVudCBwcm9wZXJ0aWVzIG92ZXIgdG8gdGhlIG5ldyBldmVudFxcblxcdFxcdFxcdG9yaWcgPSBldmVudC5vcmlnaW5hbEV2ZW50O1xcblxcdFxcdFxcdGlmIChvcmlnKSB7XFxuXFx0XFx0XFx0XFx0Zm9yIChwcm9wIGluIG9yaWcpIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIShwcm9wIGluIGV2ZW50KSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGV2ZW50W3Byb3BdID0gb3JpZ1twcm9wXTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLmVsZW1lbnQudHJpZ2dlcihldmVudCwgZGF0YSk7XFxuXFx0XFx0XFx0cmV0dXJuICEoJC5pc0Z1bmN0aW9uKGNhbGxiYWNrKSAmJiBjYWxsYmFjay5hcHBseSh0aGlzLmVsZW1lbnRbMF0sIFtldmVudF0uY29uY2F0KGRhdGEpKSA9PT0gZmFsc2UgfHwgZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpO1xcblxcdFxcdH1cXG5cXHR9O1xcblxcblxcdCQuZWFjaCh7IHNob3c6IFxcXCJmYWRlSW5cXFwiLCBoaWRlOiBcXFwiZmFkZU91dFxcXCIgfSwgZnVuY3Rpb24gKG1ldGhvZCwgZGVmYXVsdEVmZmVjdCkge1xcblxcdFxcdCQuV2lkZ2V0LnByb3RvdHlwZVtcXFwiX1xcXCIgKyBtZXRob2RdID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XFxuXFx0XFx0XFx0aWYgKHR5cGVvZiBvcHRpb25zID09PSBcXFwic3RyaW5nXFxcIikge1xcblxcdFxcdFxcdFxcdG9wdGlvbnMgPSB7IGVmZmVjdDogb3B0aW9ucyB9O1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR2YXIgaGFzT3B0aW9ucyxcXG5cXHRcXHRcXHQgICAgZWZmZWN0TmFtZSA9ICFvcHRpb25zID8gbWV0aG9kIDogb3B0aW9ucyA9PT0gdHJ1ZSB8fCB0eXBlb2Ygb3B0aW9ucyA9PT0gXFxcIm51bWJlclxcXCIgPyBkZWZhdWx0RWZmZWN0IDogb3B0aW9ucy5lZmZlY3QgfHwgZGVmYXVsdEVmZmVjdDtcXG5cXHRcXHRcXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcXG5cXHRcXHRcXHRpZiAodHlwZW9mIG9wdGlvbnMgPT09IFxcXCJudW1iZXJcXFwiKSB7XFxuXFx0XFx0XFx0XFx0b3B0aW9ucyA9IHsgZHVyYXRpb246IG9wdGlvbnMgfTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aGFzT3B0aW9ucyA9ICEkLmlzRW1wdHlPYmplY3Qob3B0aW9ucyk7XFxuXFx0XFx0XFx0b3B0aW9ucy5jb21wbGV0ZSA9IGNhbGxiYWNrO1xcblxcdFxcdFxcdGlmIChvcHRpb25zLmRlbGF5KSB7XFxuXFx0XFx0XFx0XFx0ZWxlbWVudC5kZWxheShvcHRpb25zLmRlbGF5KTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKGhhc09wdGlvbnMgJiYgJC5lZmZlY3RzICYmICQuZWZmZWN0cy5lZmZlY3RbZWZmZWN0TmFtZV0pIHtcXG5cXHRcXHRcXHRcXHRlbGVtZW50W21ldGhvZF0ob3B0aW9ucyk7XFxuXFx0XFx0XFx0fSBlbHNlIGlmIChlZmZlY3ROYW1lICE9PSBtZXRob2QgJiYgZWxlbWVudFtlZmZlY3ROYW1lXSkge1xcblxcdFxcdFxcdFxcdGVsZW1lbnRbZWZmZWN0TmFtZV0ob3B0aW9ucy5kdXJhdGlvbiwgb3B0aW9ucy5lYXNpbmcsIGNhbGxiYWNrKTtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdGVsZW1lbnQucXVldWUoZnVuY3Rpb24gKG5leHQpIHtcXG5cXHRcXHRcXHRcXHRcXHQkKHRoaXMpW21ldGhvZF0oKTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoY2FsbGJhY2spIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYWxsYmFjay5jYWxsKGVsZW1lbnRbMF0pO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRuZXh0KCk7XFxuXFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH07XFxuXFx0fSk7XFxuXFxuXFx0dmFyIHdpZGdldCA9ICQud2lkZ2V0O1xcblxcblxcdC8qIVxcbiAgKiBqUXVlcnkgVUkgTW91c2UgMS4xMS40XFxuICAqIGh0dHA6Ly9qcXVlcnl1aS5jb21cXG4gICpcXG4gICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcXG4gICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxcbiAgKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXFxuICAqXFxuICAqIGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL21vdXNlL1xcbiAgKi9cXG5cXG5cXHR2YXIgbW91c2VIYW5kbGVkID0gZmFsc2U7XFxuXFx0JChkb2N1bWVudCkubW91c2V1cChmdW5jdGlvbiAoKSB7XFxuXFx0XFx0bW91c2VIYW5kbGVkID0gZmFsc2U7XFxuXFx0fSk7XFxuXFxuXFx0dmFyIG1vdXNlID0gJC53aWRnZXQoXFxcInVpLm1vdXNlXFxcIiwge1xcblxcdFxcdHZlcnNpb246IFxcXCIxLjExLjRcXFwiLFxcblxcdFxcdG9wdGlvbnM6IHtcXG5cXHRcXHRcXHRjYW5jZWw6IFxcXCJpbnB1dCx0ZXh0YXJlYSxidXR0b24sc2VsZWN0LG9wdGlvblxcXCIsXFxuXFx0XFx0XFx0ZGlzdGFuY2U6IDEsXFxuXFx0XFx0XFx0ZGVsYXk6IDBcXG5cXHRcXHR9LFxcblxcdFxcdF9tb3VzZUluaXQ6IGZ1bmN0aW9uIF9tb3VzZUluaXQoKSB7XFxuXFx0XFx0XFx0dmFyIHRoYXQgPSB0aGlzO1xcblxcblxcdFxcdFxcdHRoaXMuZWxlbWVudC5iaW5kKFxcXCJtb3VzZWRvd24uXFxcIiArIHRoaXMud2lkZ2V0TmFtZSwgZnVuY3Rpb24gKGV2ZW50KSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoYXQuX21vdXNlRG93bihldmVudCk7XFxuXFx0XFx0XFx0fSkuYmluZChcXFwiY2xpY2suXFxcIiArIHRoaXMud2lkZ2V0TmFtZSwgZnVuY3Rpb24gKGV2ZW50KSB7XFxuXFx0XFx0XFx0XFx0aWYgKHRydWUgPT09ICQuZGF0YShldmVudC50YXJnZXQsIHRoYXQud2lkZ2V0TmFtZSArIFxcXCIucHJldmVudENsaWNrRXZlbnRcXFwiKSkge1xcblxcdFxcdFxcdFxcdFxcdCQucmVtb3ZlRGF0YShldmVudC50YXJnZXQsIHRoYXQud2lkZ2V0TmFtZSArIFxcXCIucHJldmVudENsaWNrRXZlbnRcXFwiKTtcXG5cXHRcXHRcXHRcXHRcXHRldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0pO1xcblxcblxcdFxcdFxcdHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0Ly8gVE9ETzogbWFrZSBzdXJlIGRlc3Ryb3lpbmcgb25lIGluc3RhbmNlIG9mIG1vdXNlIGRvZXNuJ3QgbWVzcyB3aXRoXFxuXFx0XFx0Ly8gb3RoZXIgaW5zdGFuY2VzIG9mIG1vdXNlXFxuXFx0XFx0X21vdXNlRGVzdHJveTogZnVuY3Rpb24gX21vdXNlRGVzdHJveSgpIHtcXG5cXHRcXHRcXHR0aGlzLmVsZW1lbnQudW5iaW5kKFxcXCIuXFxcIiArIHRoaXMud2lkZ2V0TmFtZSk7XFxuXFx0XFx0XFx0aWYgKHRoaXMuX21vdXNlTW92ZURlbGVnYXRlKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5kb2N1bWVudC51bmJpbmQoXFxcIm1vdXNlbW92ZS5cXFwiICsgdGhpcy53aWRnZXROYW1lLCB0aGlzLl9tb3VzZU1vdmVEZWxlZ2F0ZSkudW5iaW5kKFxcXCJtb3VzZXVwLlxcXCIgKyB0aGlzLndpZGdldE5hbWUsIHRoaXMuX21vdXNlVXBEZWxlZ2F0ZSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFxuXFx0XFx0X21vdXNlRG93bjogZnVuY3Rpb24gX21vdXNlRG93bihldmVudCkge1xcblxcdFxcdFxcdC8vIGRvbid0IGxldCBtb3JlIHRoYW4gb25lIHdpZGdldCBoYW5kbGUgbW91c2VTdGFydFxcblxcdFxcdFxcdGlmIChtb3VzZUhhbmRsZWQpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMuX21vdXNlTW92ZWQgPSBmYWxzZTtcXG5cXG5cXHRcXHRcXHQvLyB3ZSBtYXkgaGF2ZSBtaXNzZWQgbW91c2V1cCAob3V0IG9mIHdpbmRvdylcXG5cXHRcXHRcXHR0aGlzLl9tb3VzZVN0YXJ0ZWQgJiYgdGhpcy5fbW91c2VVcChldmVudCk7XFxuXFxuXFx0XFx0XFx0dGhpcy5fbW91c2VEb3duRXZlbnQgPSBldmVudDtcXG5cXG5cXHRcXHRcXHR2YXIgdGhhdCA9IHRoaXMsXFxuXFx0XFx0XFx0ICAgIGJ0bklzTGVmdCA9IGV2ZW50LndoaWNoID09PSAxLFxcblxcblxcdFxcdFxcdC8vIGV2ZW50LnRhcmdldC5ub2RlTmFtZSB3b3JrcyBhcm91bmQgYSBidWcgaW4gSUUgOCB3aXRoXFxuXFx0XFx0XFx0Ly8gZGlzYWJsZWQgaW5wdXRzICgjNzYyMClcXG5cXHRcXHRcXHRlbElzQ2FuY2VsID0gdHlwZW9mIHRoaXMub3B0aW9ucy5jYW5jZWwgPT09IFxcXCJzdHJpbmdcXFwiICYmIGV2ZW50LnRhcmdldC5ub2RlTmFtZSA/ICQoZXZlbnQudGFyZ2V0KS5jbG9zZXN0KHRoaXMub3B0aW9ucy5jYW5jZWwpLmxlbmd0aCA6IGZhbHNlO1xcblxcdFxcdFxcdGlmICghYnRuSXNMZWZ0IHx8IGVsSXNDYW5jZWwgfHwgIXRoaXMuX21vdXNlQ2FwdHVyZShldmVudCkpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy5tb3VzZURlbGF5TWV0ID0gIXRoaXMub3B0aW9ucy5kZWxheTtcXG5cXHRcXHRcXHRpZiAoIXRoaXMubW91c2VEZWxheU1ldCkge1xcblxcdFxcdFxcdFxcdHRoaXMuX21vdXNlRGVsYXlUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdHRoYXQubW91c2VEZWxheU1ldCA9IHRydWU7XFxuXFx0XFx0XFx0XFx0fSwgdGhpcy5vcHRpb25zLmRlbGF5KTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKHRoaXMuX21vdXNlRGlzdGFuY2VNZXQoZXZlbnQpICYmIHRoaXMuX21vdXNlRGVsYXlNZXQoZXZlbnQpKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5fbW91c2VTdGFydGVkID0gdGhpcy5fbW91c2VTdGFydChldmVudCkgIT09IGZhbHNlO1xcblxcdFxcdFxcdFxcdGlmICghdGhpcy5fbW91c2VTdGFydGVkKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIENsaWNrIGV2ZW50IG1heSBuZXZlciBoYXZlIGZpcmVkIChHZWNrbyAmIE9wZXJhKVxcblxcdFxcdFxcdGlmICh0cnVlID09PSAkLmRhdGEoZXZlbnQudGFyZ2V0LCB0aGlzLndpZGdldE5hbWUgKyBcXFwiLnByZXZlbnRDbGlja0V2ZW50XFxcIikpIHtcXG5cXHRcXHRcXHRcXHQkLnJlbW92ZURhdGEoZXZlbnQudGFyZ2V0LCB0aGlzLndpZGdldE5hbWUgKyBcXFwiLnByZXZlbnRDbGlja0V2ZW50XFxcIik7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIHRoZXNlIGRlbGVnYXRlcyBhcmUgcmVxdWlyZWQgdG8ga2VlcCBjb250ZXh0XFxuXFx0XFx0XFx0dGhpcy5fbW91c2VNb3ZlRGVsZWdhdGUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhhdC5fbW91c2VNb3ZlKGV2ZW50KTtcXG5cXHRcXHRcXHR9O1xcblxcdFxcdFxcdHRoaXMuX21vdXNlVXBEZWxlZ2F0ZSA9IGZ1bmN0aW9uIChldmVudCkge1xcblxcdFxcdFxcdFxcdHJldHVybiB0aGF0Ll9tb3VzZVVwKGV2ZW50KTtcXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdFxcdHRoaXMuZG9jdW1lbnQuYmluZChcXFwibW91c2Vtb3ZlLlxcXCIgKyB0aGlzLndpZGdldE5hbWUsIHRoaXMuX21vdXNlTW92ZURlbGVnYXRlKS5iaW5kKFxcXCJtb3VzZXVwLlxcXCIgKyB0aGlzLndpZGdldE5hbWUsIHRoaXMuX21vdXNlVXBEZWxlZ2F0ZSk7XFxuXFxuXFx0XFx0XFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG5cXG5cXHRcXHRcXHRtb3VzZUhhbmRsZWQgPSB0cnVlO1xcblxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X21vdXNlTW92ZTogZnVuY3Rpb24gX21vdXNlTW92ZShldmVudCkge1xcblxcdFxcdFxcdC8vIE9ubHkgY2hlY2sgZm9yIG1vdXNldXBzIG91dHNpZGUgdGhlIGRvY3VtZW50IGlmIHlvdSd2ZSBtb3ZlZCBpbnNpZGUgdGhlIGRvY3VtZW50XFxuXFx0XFx0XFx0Ly8gYXQgbGVhc3Qgb25jZS4gVGhpcyBwcmV2ZW50cyB0aGUgZmlyaW5nIG9mIG1vdXNldXAgaW4gdGhlIGNhc2Ugb2YgSUU8OSwgd2hpY2ggd2lsbFxcblxcdFxcdFxcdC8vIGZpcmUgYSBtb3VzZW1vdmUgZXZlbnQgaWYgY29udGVudCBpcyBwbGFjZWQgdW5kZXIgdGhlIGN1cnNvci4gU2VlICM3Nzc4XFxuXFx0XFx0XFx0Ly8gU3VwcG9ydDogSUUgPDlcXG5cXHRcXHRcXHRpZiAodGhpcy5fbW91c2VNb3ZlZCkge1xcblxcdFxcdFxcdFxcdC8vIElFIG1vdXNldXAgY2hlY2sgLSBtb3VzZXVwIGhhcHBlbmVkIHdoZW4gbW91c2Ugd2FzIG91dCBvZiB3aW5kb3dcXG5cXHRcXHRcXHRcXHRpZiAoJC51aS5pZSAmJiAoIWRvY3VtZW50LmRvY3VtZW50TW9kZSB8fCBkb2N1bWVudC5kb2N1bWVudE1vZGUgPCA5KSAmJiAhZXZlbnQuYnV0dG9uKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuX21vdXNlVXAoZXZlbnQpO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIElmcmFtZSBtb3VzZXVwIGNoZWNrIC0gbW91c2V1cCBvY2N1cnJlZCBpbiBhbm90aGVyIGRvY3VtZW50XFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmICghZXZlbnQud2hpY2gpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5fbW91c2VVcChldmVudCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoZXZlbnQud2hpY2ggfHwgZXZlbnQuYnV0dG9uKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5fbW91c2VNb3ZlZCA9IHRydWU7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICh0aGlzLl9tb3VzZVN0YXJ0ZWQpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9tb3VzZURyYWcoZXZlbnQpO1xcblxcdFxcdFxcdFxcdHJldHVybiBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAodGhpcy5fbW91c2VEaXN0YW5jZU1ldChldmVudCkgJiYgdGhpcy5fbW91c2VEZWxheU1ldChldmVudCkpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9tb3VzZVN0YXJ0ZWQgPSB0aGlzLl9tb3VzZVN0YXJ0KHRoaXMuX21vdXNlRG93bkV2ZW50LCBldmVudCkgIT09IGZhbHNlO1xcblxcdFxcdFxcdFxcdHRoaXMuX21vdXNlU3RhcnRlZCA/IHRoaXMuX21vdXNlRHJhZyhldmVudCkgOiB0aGlzLl9tb3VzZVVwKGV2ZW50KTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuICF0aGlzLl9tb3VzZVN0YXJ0ZWQ7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfbW91c2VVcDogZnVuY3Rpb24gX21vdXNlVXAoZXZlbnQpIHtcXG5cXHRcXHRcXHR0aGlzLmRvY3VtZW50LnVuYmluZChcXFwibW91c2Vtb3ZlLlxcXCIgKyB0aGlzLndpZGdldE5hbWUsIHRoaXMuX21vdXNlTW92ZURlbGVnYXRlKS51bmJpbmQoXFxcIm1vdXNldXAuXFxcIiArIHRoaXMud2lkZ2V0TmFtZSwgdGhpcy5fbW91c2VVcERlbGVnYXRlKTtcXG5cXG5cXHRcXHRcXHRpZiAodGhpcy5fbW91c2VTdGFydGVkKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5fbW91c2VTdGFydGVkID0gZmFsc2U7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKGV2ZW50LnRhcmdldCA9PT0gdGhpcy5fbW91c2VEb3duRXZlbnQudGFyZ2V0KSB7XFxuXFx0XFx0XFx0XFx0XFx0JC5kYXRhKGV2ZW50LnRhcmdldCwgdGhpcy53aWRnZXROYW1lICsgXFxcIi5wcmV2ZW50Q2xpY2tFdmVudFxcXCIsIHRydWUpO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR0aGlzLl9tb3VzZVN0b3AoZXZlbnQpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRtb3VzZUhhbmRsZWQgPSBmYWxzZTtcXG5cXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfbW91c2VEaXN0YW5jZU1ldDogZnVuY3Rpb24gX21vdXNlRGlzdGFuY2VNZXQoZXZlbnQpIHtcXG5cXHRcXHRcXHRyZXR1cm4gTWF0aC5tYXgoTWF0aC5hYnModGhpcy5fbW91c2VEb3duRXZlbnQucGFnZVggLSBldmVudC5wYWdlWCksIE1hdGguYWJzKHRoaXMuX21vdXNlRG93bkV2ZW50LnBhZ2VZIC0gZXZlbnQucGFnZVkpKSA+PSB0aGlzLm9wdGlvbnMuZGlzdGFuY2U7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfbW91c2VEZWxheU1ldDogZnVuY3Rpb24gX21vdXNlRGVsYXlNZXQoKSAvKiBldmVudCAqL3tcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5tb3VzZURlbGF5TWV0O1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0Ly8gVGhlc2UgYXJlIHBsYWNlaG9sZGVyIG1ldGhvZHMsIHRvIGJlIG92ZXJyaWRlbiBieSBleHRlbmRpbmcgcGx1Z2luXFxuXFx0XFx0X21vdXNlU3RhcnQ6IGZ1bmN0aW9uIF9tb3VzZVN0YXJ0KCkgLyogZXZlbnQgKi97fSxcXG5cXHRcXHRfbW91c2VEcmFnOiBmdW5jdGlvbiBfbW91c2VEcmFnKCkgLyogZXZlbnQgKi97fSxcXG5cXHRcXHRfbW91c2VTdG9wOiBmdW5jdGlvbiBfbW91c2VTdG9wKCkgLyogZXZlbnQgKi97fSxcXG5cXHRcXHRfbW91c2VDYXB0dXJlOiBmdW5jdGlvbiBfbW91c2VDYXB0dXJlKCkgLyogZXZlbnQgKi97XFxuXFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0fVxcblxcdH0pO1xcblxcblxcdC8qIVxcbiAgKiBqUXVlcnkgVUkgUG9zaXRpb24gMS4xMS40XFxuICAqIGh0dHA6Ly9qcXVlcnl1aS5jb21cXG4gICpcXG4gICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcXG4gICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxcbiAgKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXFxuICAqXFxuICAqIGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL3Bvc2l0aW9uL1xcbiAgKi9cXG5cXG5cXHQoZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdCQudWkgPSAkLnVpIHx8IHt9O1xcblxcblxcdFxcdHZhciBjYWNoZWRTY3JvbGxiYXJXaWR0aCxcXG5cXHRcXHQgICAgc3VwcG9ydHNPZmZzZXRGcmFjdGlvbnMsXFxuXFx0XFx0ICAgIG1heCA9IE1hdGgubWF4LFxcblxcdFxcdCAgICBhYnMgPSBNYXRoLmFicyxcXG5cXHRcXHQgICAgcm91bmQgPSBNYXRoLnJvdW5kLFxcblxcdFxcdCAgICByaG9yaXpvbnRhbCA9IC9sZWZ0fGNlbnRlcnxyaWdodC8sXFxuXFx0XFx0ICAgIHJ2ZXJ0aWNhbCA9IC90b3B8Y2VudGVyfGJvdHRvbS8sXFxuXFx0XFx0ICAgIHJvZmZzZXQgPSAvW1xcXFwrXFxcXC1dXFxcXGQrKFxcXFwuW1xcXFxkXSspPyU/LyxcXG5cXHRcXHQgICAgcnBvc2l0aW9uID0gL15cXFxcdysvLFxcblxcdFxcdCAgICBycGVyY2VudCA9IC8lJC8sXFxuXFx0XFx0ICAgIF9wb3NpdGlvbiA9ICQuZm4ucG9zaXRpb247XFxuXFxuXFx0XFx0ZnVuY3Rpb24gZ2V0T2Zmc2V0cyhvZmZzZXRzLCB3aWR0aCwgaGVpZ2h0KSB7XFxuXFx0XFx0XFx0cmV0dXJuIFtwYXJzZUZsb2F0KG9mZnNldHNbMF0pICogKHJwZXJjZW50LnRlc3Qob2Zmc2V0c1swXSkgPyB3aWR0aCAvIDEwMCA6IDEpLCBwYXJzZUZsb2F0KG9mZnNldHNbMV0pICogKHJwZXJjZW50LnRlc3Qob2Zmc2V0c1sxXSkgPyBoZWlnaHQgLyAxMDAgOiAxKV07XFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIHBhcnNlQ3NzKGVsZW1lbnQsIHByb3BlcnR5KSB7XFxuXFx0XFx0XFx0cmV0dXJuIHBhcnNlSW50KCQuY3NzKGVsZW1lbnQsIHByb3BlcnR5KSwgMTApIHx8IDA7XFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIGdldERpbWVuc2lvbnMoZWxlbSkge1xcblxcdFxcdFxcdHZhciByYXcgPSBlbGVtWzBdO1xcblxcdFxcdFxcdGlmIChyYXcubm9kZVR5cGUgPT09IDkpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4ge1xcblxcdFxcdFxcdFxcdFxcdHdpZHRoOiBlbGVtLndpZHRoKCksXFxuXFx0XFx0XFx0XFx0XFx0aGVpZ2h0OiBlbGVtLmhlaWdodCgpLFxcblxcdFxcdFxcdFxcdFxcdG9mZnNldDogeyB0b3A6IDAsIGxlZnQ6IDAgfVxcblxcdFxcdFxcdFxcdH07XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICgkLmlzV2luZG93KHJhdykpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4ge1xcblxcdFxcdFxcdFxcdFxcdHdpZHRoOiBlbGVtLndpZHRoKCksXFxuXFx0XFx0XFx0XFx0XFx0aGVpZ2h0OiBlbGVtLmhlaWdodCgpLFxcblxcdFxcdFxcdFxcdFxcdG9mZnNldDogeyB0b3A6IGVsZW0uc2Nyb2xsVG9wKCksIGxlZnQ6IGVsZW0uc2Nyb2xsTGVmdCgpIH1cXG5cXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAocmF3LnByZXZlbnREZWZhdWx0KSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHtcXG5cXHRcXHRcXHRcXHRcXHR3aWR0aDogMCxcXG5cXHRcXHRcXHRcXHRcXHRoZWlnaHQ6IDAsXFxuXFx0XFx0XFx0XFx0XFx0b2Zmc2V0OiB7IHRvcDogcmF3LnBhZ2VZLCBsZWZ0OiByYXcucGFnZVggfVxcblxcdFxcdFxcdFxcdH07XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiB7XFxuXFx0XFx0XFx0XFx0d2lkdGg6IGVsZW0ub3V0ZXJXaWR0aCgpLFxcblxcdFxcdFxcdFxcdGhlaWdodDogZWxlbS5vdXRlckhlaWdodCgpLFxcblxcdFxcdFxcdFxcdG9mZnNldDogZWxlbS5vZmZzZXQoKVxcblxcdFxcdFxcdH07XFxuXFx0XFx0fVxcblxcblxcdFxcdCQucG9zaXRpb24gPSB7XFxuXFx0XFx0XFx0c2Nyb2xsYmFyV2lkdGg6IGZ1bmN0aW9uIHNjcm9sbGJhcldpZHRoKCkge1xcblxcdFxcdFxcdFxcdGlmIChjYWNoZWRTY3JvbGxiYXJXaWR0aCAhPT0gdW5kZWZpbmVkKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGNhY2hlZFNjcm9sbGJhcldpZHRoO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR2YXIgdzEsXFxuXFx0XFx0XFx0XFx0ICAgIHcyLFxcblxcdFxcdFxcdFxcdCAgICBkaXYgPSAkKFxcXCI8ZGl2IHN0eWxlPSdkaXNwbGF5OmJsb2NrO3Bvc2l0aW9uOmFic29sdXRlO3dpZHRoOjUwcHg7aGVpZ2h0OjUwcHg7b3ZlcmZsb3c6aGlkZGVuOyc+PGRpdiBzdHlsZT0naGVpZ2h0OjEwMHB4O3dpZHRoOmF1dG87Jz48L2Rpdj48L2Rpdj5cXFwiKSxcXG5cXHRcXHRcXHRcXHQgICAgaW5uZXJEaXYgPSBkaXYuY2hpbGRyZW4oKVswXTtcXG5cXG5cXHRcXHRcXHRcXHQkKFxcXCJib2R5XFxcIikuYXBwZW5kKGRpdik7XFxuXFx0XFx0XFx0XFx0dzEgPSBpbm5lckRpdi5vZmZzZXRXaWR0aDtcXG5cXHRcXHRcXHRcXHRkaXYuY3NzKFxcXCJvdmVyZmxvd1xcXCIsIFxcXCJzY3JvbGxcXFwiKTtcXG5cXG5cXHRcXHRcXHRcXHR3MiA9IGlubmVyRGl2Lm9mZnNldFdpZHRoO1xcblxcblxcdFxcdFxcdFxcdGlmICh3MSA9PT0gdzIpIHtcXG5cXHRcXHRcXHRcXHRcXHR3MiA9IGRpdlswXS5jbGllbnRXaWR0aDtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0ZGl2LnJlbW92ZSgpO1xcblxcblxcdFxcdFxcdFxcdHJldHVybiBjYWNoZWRTY3JvbGxiYXJXaWR0aCA9IHcxIC0gdzI7XFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRnZXRTY3JvbGxJbmZvOiBmdW5jdGlvbiBnZXRTY3JvbGxJbmZvKHdpdGhpbikge1xcblxcdFxcdFxcdFxcdHZhciBvdmVyZmxvd1ggPSB3aXRoaW4uaXNXaW5kb3cgfHwgd2l0aGluLmlzRG9jdW1lbnQgPyBcXFwiXFxcIiA6IHdpdGhpbi5lbGVtZW50LmNzcyhcXFwib3ZlcmZsb3cteFxcXCIpLFxcblxcdFxcdFxcdFxcdCAgICBvdmVyZmxvd1kgPSB3aXRoaW4uaXNXaW5kb3cgfHwgd2l0aGluLmlzRG9jdW1lbnQgPyBcXFwiXFxcIiA6IHdpdGhpbi5lbGVtZW50LmNzcyhcXFwib3ZlcmZsb3cteVxcXCIpLFxcblxcdFxcdFxcdFxcdCAgICBoYXNPdmVyZmxvd1ggPSBvdmVyZmxvd1ggPT09IFxcXCJzY3JvbGxcXFwiIHx8IG92ZXJmbG93WCA9PT0gXFxcImF1dG9cXFwiICYmIHdpdGhpbi53aWR0aCA8IHdpdGhpbi5lbGVtZW50WzBdLnNjcm9sbFdpZHRoLFxcblxcdFxcdFxcdFxcdCAgICBoYXNPdmVyZmxvd1kgPSBvdmVyZmxvd1kgPT09IFxcXCJzY3JvbGxcXFwiIHx8IG92ZXJmbG93WSA9PT0gXFxcImF1dG9cXFwiICYmIHdpdGhpbi5oZWlnaHQgPCB3aXRoaW4uZWxlbWVudFswXS5zY3JvbGxIZWlnaHQ7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHtcXG5cXHRcXHRcXHRcXHRcXHR3aWR0aDogaGFzT3ZlcmZsb3dZID8gJC5wb3NpdGlvbi5zY3JvbGxiYXJXaWR0aCgpIDogMCxcXG5cXHRcXHRcXHRcXHRcXHRoZWlnaHQ6IGhhc092ZXJmbG93WCA/ICQucG9zaXRpb24uc2Nyb2xsYmFyV2lkdGgoKSA6IDBcXG5cXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0Z2V0V2l0aGluSW5mbzogZnVuY3Rpb24gZ2V0V2l0aGluSW5mbyhlbGVtZW50KSB7XFxuXFx0XFx0XFx0XFx0dmFyIHdpdGhpbkVsZW1lbnQgPSAkKGVsZW1lbnQgfHwgd2luZG93KSxcXG5cXHRcXHRcXHRcXHQgICAgaXNXaW5kb3cgPSAkLmlzV2luZG93KHdpdGhpbkVsZW1lbnRbMF0pLFxcblxcdFxcdFxcdFxcdCAgICBpc0RvY3VtZW50ID0gISF3aXRoaW5FbGVtZW50WzBdICYmIHdpdGhpbkVsZW1lbnRbMF0ubm9kZVR5cGUgPT09IDk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHtcXG5cXHRcXHRcXHRcXHRcXHRlbGVtZW50OiB3aXRoaW5FbGVtZW50LFxcblxcdFxcdFxcdFxcdFxcdGlzV2luZG93OiBpc1dpbmRvdyxcXG5cXHRcXHRcXHRcXHRcXHRpc0RvY3VtZW50OiBpc0RvY3VtZW50LFxcblxcdFxcdFxcdFxcdFxcdG9mZnNldDogd2l0aGluRWxlbWVudC5vZmZzZXQoKSB8fCB7IGxlZnQ6IDAsIHRvcDogMCB9LFxcblxcdFxcdFxcdFxcdFxcdHNjcm9sbExlZnQ6IHdpdGhpbkVsZW1lbnQuc2Nyb2xsTGVmdCgpLFxcblxcdFxcdFxcdFxcdFxcdHNjcm9sbFRvcDogd2l0aGluRWxlbWVudC5zY3JvbGxUb3AoKSxcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBzdXBwb3J0OiBqUXVlcnkgMS42LnhcXG5cXHRcXHRcXHRcXHRcXHQvLyBqUXVlcnkgMS42IGRvZXNuJ3Qgc3VwcG9ydCAub3V0ZXJXaWR0aC9IZWlnaHQoKSBvbiBkb2N1bWVudHMgb3Igd2luZG93c1xcblxcdFxcdFxcdFxcdFxcdHdpZHRoOiBpc1dpbmRvdyB8fCBpc0RvY3VtZW50ID8gd2l0aGluRWxlbWVudC53aWR0aCgpIDogd2l0aGluRWxlbWVudC5vdXRlcldpZHRoKCksXFxuXFx0XFx0XFx0XFx0XFx0aGVpZ2h0OiBpc1dpbmRvdyB8fCBpc0RvY3VtZW50ID8gd2l0aGluRWxlbWVudC5oZWlnaHQoKSA6IHdpdGhpbkVsZW1lbnQub3V0ZXJIZWlnaHQoKVxcblxcdFxcdFxcdFxcdH07XFxuXFx0XFx0XFx0fVxcblxcdFxcdH07XFxuXFxuXFx0XFx0JC5mbi5wb3NpdGlvbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XFxuXFx0XFx0XFx0aWYgKCFvcHRpb25zIHx8ICFvcHRpb25zLm9mKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIF9wb3NpdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBtYWtlIGEgY29weSwgd2UgZG9uJ3Qgd2FudCB0byBtb2RpZnkgYXJndW1lbnRzXFxuXFx0XFx0XFx0b3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBvcHRpb25zKTtcXG5cXG5cXHRcXHRcXHR2YXIgYXRPZmZzZXQsXFxuXFx0XFx0XFx0ICAgIHRhcmdldFdpZHRoLFxcblxcdFxcdFxcdCAgICB0YXJnZXRIZWlnaHQsXFxuXFx0XFx0XFx0ICAgIHRhcmdldE9mZnNldCxcXG5cXHRcXHRcXHQgICAgYmFzZVBvc2l0aW9uLFxcblxcdFxcdFxcdCAgICBkaW1lbnNpb25zLFxcblxcdFxcdFxcdCAgICB0YXJnZXQgPSAkKG9wdGlvbnMub2YpLFxcblxcdFxcdFxcdCAgICB3aXRoaW4gPSAkLnBvc2l0aW9uLmdldFdpdGhpbkluZm8ob3B0aW9ucy53aXRoaW4pLFxcblxcdFxcdFxcdCAgICBzY3JvbGxJbmZvID0gJC5wb3NpdGlvbi5nZXRTY3JvbGxJbmZvKHdpdGhpbiksXFxuXFx0XFx0XFx0ICAgIGNvbGxpc2lvbiA9IChvcHRpb25zLmNvbGxpc2lvbiB8fCBcXFwiZmxpcFxcXCIpLnNwbGl0KFxcXCIgXFxcIiksXFxuXFx0XFx0XFx0ICAgIG9mZnNldHMgPSB7fTtcXG5cXG5cXHRcXHRcXHRkaW1lbnNpb25zID0gZ2V0RGltZW5zaW9ucyh0YXJnZXQpO1xcblxcdFxcdFxcdGlmICh0YXJnZXRbMF0ucHJldmVudERlZmF1bHQpIHtcXG5cXHRcXHRcXHRcXHQvLyBmb3JjZSBsZWZ0IHRvcCB0byBhbGxvdyBmbGlwcGluZ1xcblxcdFxcdFxcdFxcdG9wdGlvbnMuYXQgPSBcXFwibGVmdCB0b3BcXFwiO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR0YXJnZXRXaWR0aCA9IGRpbWVuc2lvbnMud2lkdGg7XFxuXFx0XFx0XFx0dGFyZ2V0SGVpZ2h0ID0gZGltZW5zaW9ucy5oZWlnaHQ7XFxuXFx0XFx0XFx0dGFyZ2V0T2Zmc2V0ID0gZGltZW5zaW9ucy5vZmZzZXQ7XFxuXFx0XFx0XFx0Ly8gY2xvbmUgdG8gcmV1c2Ugb3JpZ2luYWwgdGFyZ2V0T2Zmc2V0IGxhdGVyXFxuXFx0XFx0XFx0YmFzZVBvc2l0aW9uID0gJC5leHRlbmQoe30sIHRhcmdldE9mZnNldCk7XFxuXFxuXFx0XFx0XFx0Ly8gZm9yY2UgbXkgYW5kIGF0IHRvIGhhdmUgdmFsaWQgaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgcG9zaXRpb25zXFxuXFx0XFx0XFx0Ly8gaWYgYSB2YWx1ZSBpcyBtaXNzaW5nIG9yIGludmFsaWQsIGl0IHdpbGwgYmUgY29udmVydGVkIHRvIGNlbnRlclxcblxcdFxcdFxcdCQuZWFjaChbXFxcIm15XFxcIiwgXFxcImF0XFxcIl0sIGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHR2YXIgcG9zID0gKG9wdGlvbnNbdGhpc10gfHwgXFxcIlxcXCIpLnNwbGl0KFxcXCIgXFxcIiksXFxuXFx0XFx0XFx0XFx0ICAgIGhvcml6b250YWxPZmZzZXQsXFxuXFx0XFx0XFx0XFx0ICAgIHZlcnRpY2FsT2Zmc2V0O1xcblxcblxcdFxcdFxcdFxcdGlmIChwb3MubGVuZ3RoID09PSAxKSB7XFxuXFx0XFx0XFx0XFx0XFx0cG9zID0gcmhvcml6b250YWwudGVzdChwb3NbMF0pID8gcG9zLmNvbmNhdChbXFxcImNlbnRlclxcXCJdKSA6IHJ2ZXJ0aWNhbC50ZXN0KHBvc1swXSkgPyBbXFxcImNlbnRlclxcXCJdLmNvbmNhdChwb3MpIDogW1xcXCJjZW50ZXJcXFwiLCBcXFwiY2VudGVyXFxcIl07XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHBvc1swXSA9IHJob3Jpem9udGFsLnRlc3QocG9zWzBdKSA/IHBvc1swXSA6IFxcXCJjZW50ZXJcXFwiO1xcblxcdFxcdFxcdFxcdHBvc1sxXSA9IHJ2ZXJ0aWNhbC50ZXN0KHBvc1sxXSkgPyBwb3NbMV0gOiBcXFwiY2VudGVyXFxcIjtcXG5cXG5cXHRcXHRcXHRcXHQvLyBjYWxjdWxhdGUgb2Zmc2V0c1xcblxcdFxcdFxcdFxcdGhvcml6b250YWxPZmZzZXQgPSByb2Zmc2V0LmV4ZWMocG9zWzBdKTtcXG5cXHRcXHRcXHRcXHR2ZXJ0aWNhbE9mZnNldCA9IHJvZmZzZXQuZXhlYyhwb3NbMV0pO1xcblxcdFxcdFxcdFxcdG9mZnNldHNbdGhpc10gPSBbaG9yaXpvbnRhbE9mZnNldCA/IGhvcml6b250YWxPZmZzZXRbMF0gOiAwLCB2ZXJ0aWNhbE9mZnNldCA/IHZlcnRpY2FsT2Zmc2V0WzBdIDogMF07XFxuXFxuXFx0XFx0XFx0XFx0Ly8gcmVkdWNlIHRvIGp1c3QgdGhlIHBvc2l0aW9ucyB3aXRob3V0IHRoZSBvZmZzZXRzXFxuXFx0XFx0XFx0XFx0b3B0aW9uc1t0aGlzXSA9IFtycG9zaXRpb24uZXhlYyhwb3NbMF0pWzBdLCBycG9zaXRpb24uZXhlYyhwb3NbMV0pWzBdXTtcXG5cXHRcXHRcXHR9KTtcXG5cXG5cXHRcXHRcXHQvLyBub3JtYWxpemUgY29sbGlzaW9uIG9wdGlvblxcblxcdFxcdFxcdGlmIChjb2xsaXNpb24ubGVuZ3RoID09PSAxKSB7XFxuXFx0XFx0XFx0XFx0Y29sbGlzaW9uWzFdID0gY29sbGlzaW9uWzBdO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAob3B0aW9ucy5hdFswXSA9PT0gXFxcInJpZ2h0XFxcIikge1xcblxcdFxcdFxcdFxcdGJhc2VQb3NpdGlvbi5sZWZ0ICs9IHRhcmdldFdpZHRoO1xcblxcdFxcdFxcdH0gZWxzZSBpZiAob3B0aW9ucy5hdFswXSA9PT0gXFxcImNlbnRlclxcXCIpIHtcXG5cXHRcXHRcXHRcXHRiYXNlUG9zaXRpb24ubGVmdCArPSB0YXJnZXRXaWR0aCAvIDI7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmIChvcHRpb25zLmF0WzFdID09PSBcXFwiYm90dG9tXFxcIikge1xcblxcdFxcdFxcdFxcdGJhc2VQb3NpdGlvbi50b3AgKz0gdGFyZ2V0SGVpZ2h0O1xcblxcdFxcdFxcdH0gZWxzZSBpZiAob3B0aW9ucy5hdFsxXSA9PT0gXFxcImNlbnRlclxcXCIpIHtcXG5cXHRcXHRcXHRcXHRiYXNlUG9zaXRpb24udG9wICs9IHRhcmdldEhlaWdodCAvIDI7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGF0T2Zmc2V0ID0gZ2V0T2Zmc2V0cyhvZmZzZXRzLmF0LCB0YXJnZXRXaWR0aCwgdGFyZ2V0SGVpZ2h0KTtcXG5cXHRcXHRcXHRiYXNlUG9zaXRpb24ubGVmdCArPSBhdE9mZnNldFswXTtcXG5cXHRcXHRcXHRiYXNlUG9zaXRpb24udG9wICs9IGF0T2Zmc2V0WzFdO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdHZhciBjb2xsaXNpb25Qb3NpdGlvbixcXG5cXHRcXHRcXHRcXHQgICAgdXNpbmcsXFxuXFx0XFx0XFx0XFx0ICAgIGVsZW0gPSAkKHRoaXMpLFxcblxcdFxcdFxcdFxcdCAgICBlbGVtV2lkdGggPSBlbGVtLm91dGVyV2lkdGgoKSxcXG5cXHRcXHRcXHRcXHQgICAgZWxlbUhlaWdodCA9IGVsZW0ub3V0ZXJIZWlnaHQoKSxcXG5cXHRcXHRcXHRcXHQgICAgbWFyZ2luTGVmdCA9IHBhcnNlQ3NzKHRoaXMsIFxcXCJtYXJnaW5MZWZ0XFxcIiksXFxuXFx0XFx0XFx0XFx0ICAgIG1hcmdpblRvcCA9IHBhcnNlQ3NzKHRoaXMsIFxcXCJtYXJnaW5Ub3BcXFwiKSxcXG5cXHRcXHRcXHRcXHQgICAgY29sbGlzaW9uV2lkdGggPSBlbGVtV2lkdGggKyBtYXJnaW5MZWZ0ICsgcGFyc2VDc3ModGhpcywgXFxcIm1hcmdpblJpZ2h0XFxcIikgKyBzY3JvbGxJbmZvLndpZHRoLFxcblxcdFxcdFxcdFxcdCAgICBjb2xsaXNpb25IZWlnaHQgPSBlbGVtSGVpZ2h0ICsgbWFyZ2luVG9wICsgcGFyc2VDc3ModGhpcywgXFxcIm1hcmdpbkJvdHRvbVxcXCIpICsgc2Nyb2xsSW5mby5oZWlnaHQsXFxuXFx0XFx0XFx0XFx0ICAgIHBvc2l0aW9uID0gJC5leHRlbmQoe30sIGJhc2VQb3NpdGlvbiksXFxuXFx0XFx0XFx0XFx0ICAgIG15T2Zmc2V0ID0gZ2V0T2Zmc2V0cyhvZmZzZXRzLm15LCBlbGVtLm91dGVyV2lkdGgoKSwgZWxlbS5vdXRlckhlaWdodCgpKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAob3B0aW9ucy5teVswXSA9PT0gXFxcInJpZ2h0XFxcIikge1xcblxcdFxcdFxcdFxcdFxcdHBvc2l0aW9uLmxlZnQgLT0gZWxlbVdpZHRoO1xcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAob3B0aW9ucy5teVswXSA9PT0gXFxcImNlbnRlclxcXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRwb3NpdGlvbi5sZWZ0IC09IGVsZW1XaWR0aCAvIDI7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmIChvcHRpb25zLm15WzFdID09PSBcXFwiYm90dG9tXFxcIikge1xcblxcdFxcdFxcdFxcdFxcdHBvc2l0aW9uLnRvcCAtPSBlbGVtSGVpZ2h0O1xcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAob3B0aW9ucy5teVsxXSA9PT0gXFxcImNlbnRlclxcXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRwb3NpdGlvbi50b3AgLT0gZWxlbUhlaWdodCAvIDI7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHBvc2l0aW9uLmxlZnQgKz0gbXlPZmZzZXRbMF07XFxuXFx0XFx0XFx0XFx0cG9zaXRpb24udG9wICs9IG15T2Zmc2V0WzFdO1xcblxcblxcdFxcdFxcdFxcdC8vIGlmIHRoZSBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBmcmFjdGlvbnMsIHRoZW4gcm91bmQgZm9yIGNvbnNpc3RlbnQgcmVzdWx0c1xcblxcdFxcdFxcdFxcdGlmICghc3VwcG9ydHNPZmZzZXRGcmFjdGlvbnMpIHtcXG5cXHRcXHRcXHRcXHRcXHRwb3NpdGlvbi5sZWZ0ID0gcm91bmQocG9zaXRpb24ubGVmdCk7XFxuXFx0XFx0XFx0XFx0XFx0cG9zaXRpb24udG9wID0gcm91bmQocG9zaXRpb24udG9wKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Y29sbGlzaW9uUG9zaXRpb24gPSB7XFxuXFx0XFx0XFx0XFx0XFx0bWFyZ2luTGVmdDogbWFyZ2luTGVmdCxcXG5cXHRcXHRcXHRcXHRcXHRtYXJnaW5Ub3A6IG1hcmdpblRvcFxcblxcdFxcdFxcdFxcdH07XFxuXFxuXFx0XFx0XFx0XFx0JC5lYWNoKFtcXFwibGVmdFxcXCIsIFxcXCJ0b3BcXFwiXSwgZnVuY3Rpb24gKGksIGRpcikge1xcblxcdFxcdFxcdFxcdFxcdGlmICgkLnVpLnBvc2l0aW9uW2NvbGxpc2lvbltpXV0pIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHQkLnVpLnBvc2l0aW9uW2NvbGxpc2lvbltpXV1bZGlyXShwb3NpdGlvbiwge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRhcmdldFdpZHRoOiB0YXJnZXRXaWR0aCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0YXJnZXRIZWlnaHQ6IHRhcmdldEhlaWdodCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRlbGVtV2lkdGg6IGVsZW1XaWR0aCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRlbGVtSGVpZ2h0OiBlbGVtSGVpZ2h0LFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGNvbGxpc2lvblBvc2l0aW9uOiBjb2xsaXNpb25Qb3NpdGlvbixcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjb2xsaXNpb25XaWR0aDogY29sbGlzaW9uV2lkdGgsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y29sbGlzaW9uSGVpZ2h0OiBjb2xsaXNpb25IZWlnaHQsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0b2Zmc2V0OiBbYXRPZmZzZXRbMF0gKyBteU9mZnNldFswXSwgYXRPZmZzZXRbMV0gKyBteU9mZnNldFsxXV0sXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bXk6IG9wdGlvbnMubXksXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YXQ6IG9wdGlvbnMuYXQsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0d2l0aGluOiB3aXRoaW4sXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZWxlbTogZWxlbVxcblxcdFxcdFxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9KTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAob3B0aW9ucy51c2luZykge1xcblxcdFxcdFxcdFxcdFxcdC8vIGFkZHMgZmVlZGJhY2sgYXMgc2Vjb25kIGFyZ3VtZW50IHRvIHVzaW5nIGNhbGxiYWNrLCBpZiBwcmVzZW50XFxuXFx0XFx0XFx0XFx0XFx0dXNpbmcgPSBmdW5jdGlvbiB1c2luZyhwcm9wcykge1xcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBsZWZ0ID0gdGFyZ2V0T2Zmc2V0LmxlZnQgLSBwb3NpdGlvbi5sZWZ0LFxcblxcdFxcdFxcdFxcdFxcdFxcdCAgICByaWdodCA9IGxlZnQgKyB0YXJnZXRXaWR0aCAtIGVsZW1XaWR0aCxcXG5cXHRcXHRcXHRcXHRcXHRcXHQgICAgdG9wID0gdGFyZ2V0T2Zmc2V0LnRvcCAtIHBvc2l0aW9uLnRvcCxcXG5cXHRcXHRcXHRcXHRcXHRcXHQgICAgYm90dG9tID0gdG9wICsgdGFyZ2V0SGVpZ2h0IC0gZWxlbUhlaWdodCxcXG5cXHRcXHRcXHRcXHRcXHRcXHQgICAgZmVlZGJhY2sgPSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGFyZ2V0OiB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZWxlbWVudDogdGFyZ2V0LFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGxlZnQ6IHRhcmdldE9mZnNldC5sZWZ0LFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRvcDogdGFyZ2V0T2Zmc2V0LnRvcCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR3aWR0aDogdGFyZ2V0V2lkdGgsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aGVpZ2h0OiB0YXJnZXRIZWlnaHRcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9LFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGVsZW1lbnQ6IHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRlbGVtZW50OiBlbGVtLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGxlZnQ6IHBvc2l0aW9uLmxlZnQsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dG9wOiBwb3NpdGlvbi50b3AsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0d2lkdGg6IGVsZW1XaWR0aCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRoZWlnaHQ6IGVsZW1IZWlnaHRcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9LFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGhvcml6b250YWw6IHJpZ2h0IDwgMCA/IFxcXCJsZWZ0XFxcIiA6IGxlZnQgPiAwID8gXFxcInJpZ2h0XFxcIiA6IFxcXCJjZW50ZXJcXFwiLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZlcnRpY2FsOiBib3R0b20gPCAwID8gXFxcInRvcFxcXCIgOiB0b3AgPiAwID8gXFxcImJvdHRvbVxcXCIgOiBcXFwibWlkZGxlXFxcIlxcblxcdFxcdFxcdFxcdFxcdFxcdH07XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKHRhcmdldFdpZHRoIDwgZWxlbVdpZHRoICYmIGFicyhsZWZ0ICsgcmlnaHQpIDwgdGFyZ2V0V2lkdGgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRmZWVkYmFjay5ob3Jpem9udGFsID0gXFxcImNlbnRlclxcXCI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICh0YXJnZXRIZWlnaHQgPCBlbGVtSGVpZ2h0ICYmIGFicyh0b3AgKyBib3R0b20pIDwgdGFyZ2V0SGVpZ2h0KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZmVlZGJhY2sudmVydGljYWwgPSBcXFwibWlkZGxlXFxcIjtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKG1heChhYnMobGVmdCksIGFicyhyaWdodCkpID4gbWF4KGFicyh0b3ApLCBhYnMoYm90dG9tKSkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRmZWVkYmFjay5pbXBvcnRhbnQgPSBcXFwiaG9yaXpvbnRhbFxcXCI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRmZWVkYmFjay5pbXBvcnRhbnQgPSBcXFwidmVydGljYWxcXFwiO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRvcHRpb25zLnVzaW5nLmNhbGwodGhpcywgcHJvcHMsIGZlZWRiYWNrKTtcXG5cXHRcXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRlbGVtLm9mZnNldCgkLmV4dGVuZChwb3NpdGlvbiwgeyB1c2luZzogdXNpbmcgfSkpO1xcblxcdFxcdFxcdH0pO1xcblxcdFxcdH07XFxuXFxuXFx0XFx0JC51aS5wb3NpdGlvbiA9IHtcXG5cXHRcXHRcXHRmaXQ6IHtcXG5cXHRcXHRcXHRcXHRsZWZ0OiBmdW5jdGlvbiBsZWZ0KHBvc2l0aW9uLCBkYXRhKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIHdpdGhpbiA9IGRhdGEud2l0aGluLFxcblxcdFxcdFxcdFxcdFxcdCAgICB3aXRoaW5PZmZzZXQgPSB3aXRoaW4uaXNXaW5kb3cgPyB3aXRoaW4uc2Nyb2xsTGVmdCA6IHdpdGhpbi5vZmZzZXQubGVmdCxcXG5cXHRcXHRcXHRcXHRcXHQgICAgb3V0ZXJXaWR0aCA9IHdpdGhpbi53aWR0aCxcXG5cXHRcXHRcXHRcXHRcXHQgICAgY29sbGlzaW9uUG9zTGVmdCA9IHBvc2l0aW9uLmxlZnQgLSBkYXRhLmNvbGxpc2lvblBvc2l0aW9uLm1hcmdpbkxlZnQsXFxuXFx0XFx0XFx0XFx0XFx0ICAgIG92ZXJMZWZ0ID0gd2l0aGluT2Zmc2V0IC0gY29sbGlzaW9uUG9zTGVmdCxcXG5cXHRcXHRcXHRcXHRcXHQgICAgb3ZlclJpZ2h0ID0gY29sbGlzaW9uUG9zTGVmdCArIGRhdGEuY29sbGlzaW9uV2lkdGggLSBvdXRlcldpZHRoIC0gd2l0aGluT2Zmc2V0LFxcblxcdFxcdFxcdFxcdFxcdCAgICBuZXdPdmVyUmlnaHQ7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gZWxlbWVudCBpcyB3aWRlciB0aGFuIHdpdGhpblxcblxcdFxcdFxcdFxcdFxcdGlmIChkYXRhLmNvbGxpc2lvbldpZHRoID4gb3V0ZXJXaWR0aCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdC8vIGVsZW1lbnQgaXMgaW5pdGlhbGx5IG92ZXIgdGhlIGxlZnQgc2lkZSBvZiB3aXRoaW5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAob3ZlckxlZnQgPiAwICYmIG92ZXJSaWdodCA8PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bmV3T3ZlclJpZ2h0ID0gcG9zaXRpb24ubGVmdCArIG92ZXJMZWZ0ICsgZGF0YS5jb2xsaXNpb25XaWR0aCAtIG91dGVyV2lkdGggLSB3aXRoaW5PZmZzZXQ7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cG9zaXRpb24ubGVmdCArPSBvdmVyTGVmdCAtIG5ld092ZXJSaWdodDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBlbGVtZW50IGlzIGluaXRpYWxseSBvdmVyIHJpZ2h0IHNpZGUgb2Ygd2l0aGluXFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIGlmIChvdmVyUmlnaHQgPiAwICYmIG92ZXJMZWZ0IDw9IDApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRwb3NpdGlvbi5sZWZ0ID0gd2l0aGluT2Zmc2V0O1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIGVsZW1lbnQgaXMgaW5pdGlhbGx5IG92ZXIgYm90aCBsZWZ0IGFuZCByaWdodCBzaWRlcyBvZiB3aXRoaW5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChvdmVyTGVmdCA+IG92ZXJSaWdodCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHBvc2l0aW9uLmxlZnQgPSB3aXRoaW5PZmZzZXQgKyBvdXRlcldpZHRoIC0gZGF0YS5jb2xsaXNpb25XaWR0aDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHBvc2l0aW9uLmxlZnQgPSB3aXRoaW5PZmZzZXQ7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyB0b28gZmFyIGxlZnQgLT4gYWxpZ24gd2l0aCBsZWZ0IGVkZ2VcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2UgaWYgKG92ZXJMZWZ0ID4gMCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHBvc2l0aW9uLmxlZnQgKz0gb3ZlckxlZnQ7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gdG9vIGZhciByaWdodCAtPiBhbGlnbiB3aXRoIHJpZ2h0IGVkZ2VcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2UgaWYgKG92ZXJSaWdodCA+IDApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRwb3NpdGlvbi5sZWZ0IC09IG92ZXJSaWdodDtcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBhZGp1c3QgYmFzZWQgb24gcG9zaXRpb24gYW5kIG1hcmdpblxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cG9zaXRpb24ubGVmdCA9IG1heChwb3NpdGlvbi5sZWZ0IC0gY29sbGlzaW9uUG9zTGVmdCwgcG9zaXRpb24ubGVmdCk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0XFx0dG9wOiBmdW5jdGlvbiB0b3AocG9zaXRpb24sIGRhdGEpIHtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgd2l0aGluID0gZGF0YS53aXRoaW4sXFxuXFx0XFx0XFx0XFx0XFx0ICAgIHdpdGhpbk9mZnNldCA9IHdpdGhpbi5pc1dpbmRvdyA/IHdpdGhpbi5zY3JvbGxUb3AgOiB3aXRoaW4ub2Zmc2V0LnRvcCxcXG5cXHRcXHRcXHRcXHRcXHQgICAgb3V0ZXJIZWlnaHQgPSBkYXRhLndpdGhpbi5oZWlnaHQsXFxuXFx0XFx0XFx0XFx0XFx0ICAgIGNvbGxpc2lvblBvc1RvcCA9IHBvc2l0aW9uLnRvcCAtIGRhdGEuY29sbGlzaW9uUG9zaXRpb24ubWFyZ2luVG9wLFxcblxcdFxcdFxcdFxcdFxcdCAgICBvdmVyVG9wID0gd2l0aGluT2Zmc2V0IC0gY29sbGlzaW9uUG9zVG9wLFxcblxcdFxcdFxcdFxcdFxcdCAgICBvdmVyQm90dG9tID0gY29sbGlzaW9uUG9zVG9wICsgZGF0YS5jb2xsaXNpb25IZWlnaHQgLSBvdXRlckhlaWdodCAtIHdpdGhpbk9mZnNldCxcXG5cXHRcXHRcXHRcXHRcXHQgICAgbmV3T3ZlckJvdHRvbTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBlbGVtZW50IGlzIHRhbGxlciB0aGFuIHdpdGhpblxcblxcdFxcdFxcdFxcdFxcdGlmIChkYXRhLmNvbGxpc2lvbkhlaWdodCA+IG91dGVySGVpZ2h0KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gZWxlbWVudCBpcyBpbml0aWFsbHkgb3ZlciB0aGUgdG9wIG9mIHdpdGhpblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChvdmVyVG9wID4gMCAmJiBvdmVyQm90dG9tIDw9IDApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRuZXdPdmVyQm90dG9tID0gcG9zaXRpb24udG9wICsgb3ZlclRvcCArIGRhdGEuY29sbGlzaW9uSGVpZ2h0IC0gb3V0ZXJIZWlnaHQgLSB3aXRoaW5PZmZzZXQ7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cG9zaXRpb24udG9wICs9IG92ZXJUb3AgLSBuZXdPdmVyQm90dG9tO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIGVsZW1lbnQgaXMgaW5pdGlhbGx5IG92ZXIgYm90dG9tIG9mIHdpdGhpblxcblxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSBpZiAob3ZlckJvdHRvbSA+IDAgJiYgb3ZlclRvcCA8PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cG9zaXRpb24udG9wID0gd2l0aGluT2Zmc2V0O1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIGVsZW1lbnQgaXMgaW5pdGlhbGx5IG92ZXIgYm90aCB0b3AgYW5kIGJvdHRvbSBvZiB3aXRoaW5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChvdmVyVG9wID4gb3ZlckJvdHRvbSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHBvc2l0aW9uLnRvcCA9IHdpdGhpbk9mZnNldCArIG91dGVySGVpZ2h0IC0gZGF0YS5jb2xsaXNpb25IZWlnaHQ7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRwb3NpdGlvbi50b3AgPSB3aXRoaW5PZmZzZXQ7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyB0b28gZmFyIHVwIC0+IGFsaWduIHdpdGggdG9wXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIGlmIChvdmVyVG9wID4gMCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHBvc2l0aW9uLnRvcCArPSBvdmVyVG9wO1xcblxcdFxcdFxcdFxcdFxcdFxcdC8vIHRvbyBmYXIgZG93biAtPiBhbGlnbiB3aXRoIGJvdHRvbSBlZGdlXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIGlmIChvdmVyQm90dG9tID4gMCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHBvc2l0aW9uLnRvcCAtPSBvdmVyQm90dG9tO1xcblxcdFxcdFxcdFxcdFxcdFxcdC8vIGFkanVzdCBiYXNlZCBvbiBwb3NpdGlvbiBhbmQgbWFyZ2luXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRwb3NpdGlvbi50b3AgPSBtYXgocG9zaXRpb24udG9wIC0gY29sbGlzaW9uUG9zVG9wLCBwb3NpdGlvbi50b3ApO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRmbGlwOiB7XFxuXFx0XFx0XFx0XFx0bGVmdDogZnVuY3Rpb24gbGVmdChwb3NpdGlvbiwgZGF0YSkge1xcblxcdFxcdFxcdFxcdFxcdHZhciB3aXRoaW4gPSBkYXRhLndpdGhpbixcXG5cXHRcXHRcXHRcXHRcXHQgICAgd2l0aGluT2Zmc2V0ID0gd2l0aGluLm9mZnNldC5sZWZ0ICsgd2l0aGluLnNjcm9sbExlZnQsXFxuXFx0XFx0XFx0XFx0XFx0ICAgIG91dGVyV2lkdGggPSB3aXRoaW4ud2lkdGgsXFxuXFx0XFx0XFx0XFx0XFx0ICAgIG9mZnNldExlZnQgPSB3aXRoaW4uaXNXaW5kb3cgPyB3aXRoaW4uc2Nyb2xsTGVmdCA6IHdpdGhpbi5vZmZzZXQubGVmdCxcXG5cXHRcXHRcXHRcXHRcXHQgICAgY29sbGlzaW9uUG9zTGVmdCA9IHBvc2l0aW9uLmxlZnQgLSBkYXRhLmNvbGxpc2lvblBvc2l0aW9uLm1hcmdpbkxlZnQsXFxuXFx0XFx0XFx0XFx0XFx0ICAgIG92ZXJMZWZ0ID0gY29sbGlzaW9uUG9zTGVmdCAtIG9mZnNldExlZnQsXFxuXFx0XFx0XFx0XFx0XFx0ICAgIG92ZXJSaWdodCA9IGNvbGxpc2lvblBvc0xlZnQgKyBkYXRhLmNvbGxpc2lvbldpZHRoIC0gb3V0ZXJXaWR0aCAtIG9mZnNldExlZnQsXFxuXFx0XFx0XFx0XFx0XFx0ICAgIG15T2Zmc2V0ID0gZGF0YS5teVswXSA9PT0gXFxcImxlZnRcXFwiID8gLWRhdGEuZWxlbVdpZHRoIDogZGF0YS5teVswXSA9PT0gXFxcInJpZ2h0XFxcIiA/IGRhdGEuZWxlbVdpZHRoIDogMCxcXG5cXHRcXHRcXHRcXHRcXHQgICAgYXRPZmZzZXQgPSBkYXRhLmF0WzBdID09PSBcXFwibGVmdFxcXCIgPyBkYXRhLnRhcmdldFdpZHRoIDogZGF0YS5hdFswXSA9PT0gXFxcInJpZ2h0XFxcIiA/IC1kYXRhLnRhcmdldFdpZHRoIDogMCxcXG5cXHRcXHRcXHRcXHRcXHQgICAgb2Zmc2V0ID0gLTIgKiBkYXRhLm9mZnNldFswXSxcXG5cXHRcXHRcXHRcXHRcXHQgICAgbmV3T3ZlclJpZ2h0LFxcblxcdFxcdFxcdFxcdFxcdCAgICBuZXdPdmVyTGVmdDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAob3ZlckxlZnQgPCAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0bmV3T3ZlclJpZ2h0ID0gcG9zaXRpb24ubGVmdCArIG15T2Zmc2V0ICsgYXRPZmZzZXQgKyBvZmZzZXQgKyBkYXRhLmNvbGxpc2lvbldpZHRoIC0gb3V0ZXJXaWR0aCAtIHdpdGhpbk9mZnNldDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAobmV3T3ZlclJpZ2h0IDwgMCB8fCBuZXdPdmVyUmlnaHQgPCBhYnMob3ZlckxlZnQpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cG9zaXRpb24ubGVmdCArPSBteU9mZnNldCArIGF0T2Zmc2V0ICsgb2Zmc2V0O1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2UgaWYgKG92ZXJSaWdodCA+IDApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRuZXdPdmVyTGVmdCA9IHBvc2l0aW9uLmxlZnQgLSBkYXRhLmNvbGxpc2lvblBvc2l0aW9uLm1hcmdpbkxlZnQgKyBteU9mZnNldCArIGF0T2Zmc2V0ICsgb2Zmc2V0IC0gb2Zmc2V0TGVmdDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAobmV3T3ZlckxlZnQgPiAwIHx8IGFicyhuZXdPdmVyTGVmdCkgPCBvdmVyUmlnaHQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRwb3NpdGlvbi5sZWZ0ICs9IG15T2Zmc2V0ICsgYXRPZmZzZXQgKyBvZmZzZXQ7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9LFxcblxcdFxcdFxcdFxcdHRvcDogZnVuY3Rpb24gdG9wKHBvc2l0aW9uLCBkYXRhKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIHdpdGhpbiA9IGRhdGEud2l0aGluLFxcblxcdFxcdFxcdFxcdFxcdCAgICB3aXRoaW5PZmZzZXQgPSB3aXRoaW4ub2Zmc2V0LnRvcCArIHdpdGhpbi5zY3JvbGxUb3AsXFxuXFx0XFx0XFx0XFx0XFx0ICAgIG91dGVySGVpZ2h0ID0gd2l0aGluLmhlaWdodCxcXG5cXHRcXHRcXHRcXHRcXHQgICAgb2Zmc2V0VG9wID0gd2l0aGluLmlzV2luZG93ID8gd2l0aGluLnNjcm9sbFRvcCA6IHdpdGhpbi5vZmZzZXQudG9wLFxcblxcdFxcdFxcdFxcdFxcdCAgICBjb2xsaXNpb25Qb3NUb3AgPSBwb3NpdGlvbi50b3AgLSBkYXRhLmNvbGxpc2lvblBvc2l0aW9uLm1hcmdpblRvcCxcXG5cXHRcXHRcXHRcXHRcXHQgICAgb3ZlclRvcCA9IGNvbGxpc2lvblBvc1RvcCAtIG9mZnNldFRvcCxcXG5cXHRcXHRcXHRcXHRcXHQgICAgb3ZlckJvdHRvbSA9IGNvbGxpc2lvblBvc1RvcCArIGRhdGEuY29sbGlzaW9uSGVpZ2h0IC0gb3V0ZXJIZWlnaHQgLSBvZmZzZXRUb3AsXFxuXFx0XFx0XFx0XFx0XFx0ICAgIHRvcCA9IGRhdGEubXlbMV0gPT09IFxcXCJ0b3BcXFwiLFxcblxcdFxcdFxcdFxcdFxcdCAgICBteU9mZnNldCA9IHRvcCA/IC1kYXRhLmVsZW1IZWlnaHQgOiBkYXRhLm15WzFdID09PSBcXFwiYm90dG9tXFxcIiA/IGRhdGEuZWxlbUhlaWdodCA6IDAsXFxuXFx0XFx0XFx0XFx0XFx0ICAgIGF0T2Zmc2V0ID0gZGF0YS5hdFsxXSA9PT0gXFxcInRvcFxcXCIgPyBkYXRhLnRhcmdldEhlaWdodCA6IGRhdGEuYXRbMV0gPT09IFxcXCJib3R0b21cXFwiID8gLWRhdGEudGFyZ2V0SGVpZ2h0IDogMCxcXG5cXHRcXHRcXHRcXHRcXHQgICAgb2Zmc2V0ID0gLTIgKiBkYXRhLm9mZnNldFsxXSxcXG5cXHRcXHRcXHRcXHRcXHQgICAgbmV3T3ZlclRvcCxcXG5cXHRcXHRcXHRcXHRcXHQgICAgbmV3T3ZlckJvdHRvbTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAob3ZlclRvcCA8IDApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRuZXdPdmVyQm90dG9tID0gcG9zaXRpb24udG9wICsgbXlPZmZzZXQgKyBhdE9mZnNldCArIG9mZnNldCArIGRhdGEuY29sbGlzaW9uSGVpZ2h0IC0gb3V0ZXJIZWlnaHQgLSB3aXRoaW5PZmZzZXQ7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKG5ld092ZXJCb3R0b20gPCAwIHx8IG5ld092ZXJCb3R0b20gPCBhYnMob3ZlclRvcCkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRwb3NpdGlvbi50b3AgKz0gbXlPZmZzZXQgKyBhdE9mZnNldCArIG9mZnNldDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIGlmIChvdmVyQm90dG9tID4gMCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdG5ld092ZXJUb3AgPSBwb3NpdGlvbi50b3AgLSBkYXRhLmNvbGxpc2lvblBvc2l0aW9uLm1hcmdpblRvcCArIG15T2Zmc2V0ICsgYXRPZmZzZXQgKyBvZmZzZXQgLSBvZmZzZXRUb3A7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKG5ld092ZXJUb3AgPiAwIHx8IGFicyhuZXdPdmVyVG9wKSA8IG92ZXJCb3R0b20pIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRwb3NpdGlvbi50b3AgKz0gbXlPZmZzZXQgKyBhdE9mZnNldCArIG9mZnNldDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdGZsaXBmaXQ6IHtcXG5cXHRcXHRcXHRcXHRsZWZ0OiBmdW5jdGlvbiBsZWZ0KCkge1xcblxcdFxcdFxcdFxcdFxcdCQudWkucG9zaXRpb24uZmxpcC5sZWZ0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuXFx0XFx0XFx0XFx0XFx0JC51aS5wb3NpdGlvbi5maXQubGVmdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcblxcdFxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0XFx0dG9wOiBmdW5jdGlvbiB0b3AoKSB7XFxuXFx0XFx0XFx0XFx0XFx0JC51aS5wb3NpdGlvbi5mbGlwLnRvcC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcblxcdFxcdFxcdFxcdFxcdCQudWkucG9zaXRpb24uZml0LnRvcC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fTtcXG5cXG5cXHRcXHQvLyBmcmFjdGlvbiBzdXBwb3J0IHRlc3RcXG5cXHRcXHQoZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdHZhciB0ZXN0RWxlbWVudCxcXG5cXHRcXHRcXHQgICAgdGVzdEVsZW1lbnRQYXJlbnQsXFxuXFx0XFx0XFx0ICAgIHRlc3RFbGVtZW50U3R5bGUsXFxuXFx0XFx0XFx0ICAgIG9mZnNldExlZnQsXFxuXFx0XFx0XFx0ICAgIGksXFxuXFx0XFx0XFx0ICAgIGJvZHkgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcXFwiYm9keVxcXCIpWzBdLFxcblxcdFxcdFxcdCAgICBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxcXCJkaXZcXFwiKTtcXG5cXG5cXHRcXHRcXHQvL0NyZWF0ZSBhIFxcXCJmYWtlIGJvZHlcXFwiIGZvciB0ZXN0aW5nIGJhc2VkIG9uIG1ldGhvZCB1c2VkIGluIGpRdWVyeS5zdXBwb3J0XFxuXFx0XFx0XFx0dGVzdEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGJvZHkgPyBcXFwiZGl2XFxcIiA6IFxcXCJib2R5XFxcIik7XFxuXFx0XFx0XFx0dGVzdEVsZW1lbnRTdHlsZSA9IHtcXG5cXHRcXHRcXHRcXHR2aXNpYmlsaXR5OiBcXFwiaGlkZGVuXFxcIixcXG5cXHRcXHRcXHRcXHR3aWR0aDogMCxcXG5cXHRcXHRcXHRcXHRoZWlnaHQ6IDAsXFxuXFx0XFx0XFx0XFx0Ym9yZGVyOiAwLFxcblxcdFxcdFxcdFxcdG1hcmdpbjogMCxcXG5cXHRcXHRcXHRcXHRiYWNrZ3JvdW5kOiBcXFwibm9uZVxcXCJcXG5cXHRcXHRcXHR9O1xcblxcdFxcdFxcdGlmIChib2R5KSB7XFxuXFx0XFx0XFx0XFx0JC5leHRlbmQodGVzdEVsZW1lbnRTdHlsZSwge1xcblxcdFxcdFxcdFxcdFxcdHBvc2l0aW9uOiBcXFwiYWJzb2x1dGVcXFwiLFxcblxcdFxcdFxcdFxcdFxcdGxlZnQ6IFxcXCItMTAwMHB4XFxcIixcXG5cXHRcXHRcXHRcXHRcXHR0b3A6IFxcXCItMTAwMHB4XFxcIlxcblxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRmb3IgKGkgaW4gdGVzdEVsZW1lbnRTdHlsZSkge1xcblxcdFxcdFxcdFxcdHRlc3RFbGVtZW50LnN0eWxlW2ldID0gdGVzdEVsZW1lbnRTdHlsZVtpXTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0dGVzdEVsZW1lbnQuYXBwZW5kQ2hpbGQoZGl2KTtcXG5cXHRcXHRcXHR0ZXN0RWxlbWVudFBhcmVudCA9IGJvZHkgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xcblxcdFxcdFxcdHRlc3RFbGVtZW50UGFyZW50Lmluc2VydEJlZm9yZSh0ZXN0RWxlbWVudCwgdGVzdEVsZW1lbnRQYXJlbnQuZmlyc3RDaGlsZCk7XFxuXFxuXFx0XFx0XFx0ZGl2LnN0eWxlLmNzc1RleHQgPSBcXFwicG9zaXRpb246IGFic29sdXRlOyBsZWZ0OiAxMC43NDMyMjIycHg7XFxcIjtcXG5cXG5cXHRcXHRcXHRvZmZzZXRMZWZ0ID0gJChkaXYpLm9mZnNldCgpLmxlZnQ7XFxuXFx0XFx0XFx0c3VwcG9ydHNPZmZzZXRGcmFjdGlvbnMgPSBvZmZzZXRMZWZ0ID4gMTAgJiYgb2Zmc2V0TGVmdCA8IDExO1xcblxcblxcdFxcdFxcdHRlc3RFbGVtZW50LmlubmVySFRNTCA9IFxcXCJcXFwiO1xcblxcdFxcdFxcdHRlc3RFbGVtZW50UGFyZW50LnJlbW92ZUNoaWxkKHRlc3RFbGVtZW50KTtcXG5cXHRcXHR9KSgpO1xcblxcdH0pKCk7XFxuXFxuXFx0dmFyIHBvc2l0aW9uID0gJC51aS5wb3NpdGlvbjtcXG5cXG5cXHQvKiFcXG4gICogalF1ZXJ5IFVJIEFjY29yZGlvbiAxLjExLjRcXG4gICogaHR0cDovL2pxdWVyeXVpLmNvbVxcbiAgKlxcbiAgKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xcbiAgKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXFxuICAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcXG4gICpcXG4gICogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20vYWNjb3JkaW9uL1xcbiAgKi9cXG5cXG5cXHR2YXIgYWNjb3JkaW9uID0gJC53aWRnZXQoXFxcInVpLmFjY29yZGlvblxcXCIsIHtcXG5cXHRcXHR2ZXJzaW9uOiBcXFwiMS4xMS40XFxcIixcXG5cXHRcXHRvcHRpb25zOiB7XFxuXFx0XFx0XFx0YWN0aXZlOiAwLFxcblxcdFxcdFxcdGFuaW1hdGU6IHt9LFxcblxcdFxcdFxcdGNvbGxhcHNpYmxlOiBmYWxzZSxcXG5cXHRcXHRcXHRldmVudDogXFxcImNsaWNrXFxcIixcXG5cXHRcXHRcXHRoZWFkZXI6IFxcXCI+IGxpID4gOmZpcnN0LWNoaWxkLD4gOm5vdChsaSk6ZXZlblxcXCIsXFxuXFx0XFx0XFx0aGVpZ2h0U3R5bGU6IFxcXCJhdXRvXFxcIixcXG5cXHRcXHRcXHRpY29uczoge1xcblxcdFxcdFxcdFxcdGFjdGl2ZUhlYWRlcjogXFxcInVpLWljb24tdHJpYW5nbGUtMS1zXFxcIixcXG5cXHRcXHRcXHRcXHRoZWFkZXI6IFxcXCJ1aS1pY29uLXRyaWFuZ2xlLTEtZVxcXCJcXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdC8vIGNhbGxiYWNrc1xcblxcdFxcdFxcdGFjdGl2YXRlOiBudWxsLFxcblxcdFxcdFxcdGJlZm9yZUFjdGl2YXRlOiBudWxsXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRoaWRlUHJvcHM6IHtcXG5cXHRcXHRcXHRib3JkZXJUb3BXaWR0aDogXFxcImhpZGVcXFwiLFxcblxcdFxcdFxcdGJvcmRlckJvdHRvbVdpZHRoOiBcXFwiaGlkZVxcXCIsXFxuXFx0XFx0XFx0cGFkZGluZ1RvcDogXFxcImhpZGVcXFwiLFxcblxcdFxcdFxcdHBhZGRpbmdCb3R0b206IFxcXCJoaWRlXFxcIixcXG5cXHRcXHRcXHRoZWlnaHQ6IFxcXCJoaWRlXFxcIlxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2hvd1Byb3BzOiB7XFxuXFx0XFx0XFx0Ym9yZGVyVG9wV2lkdGg6IFxcXCJzaG93XFxcIixcXG5cXHRcXHRcXHRib3JkZXJCb3R0b21XaWR0aDogXFxcInNob3dcXFwiLFxcblxcdFxcdFxcdHBhZGRpbmdUb3A6IFxcXCJzaG93XFxcIixcXG5cXHRcXHRcXHRwYWRkaW5nQm90dG9tOiBcXFwic2hvd1xcXCIsXFxuXFx0XFx0XFx0aGVpZ2h0OiBcXFwic2hvd1xcXCJcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9jcmVhdGU6IGZ1bmN0aW9uIF9jcmVhdGUoKSB7XFxuXFx0XFx0XFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XFxuXFx0XFx0XFx0dGhpcy5wcmV2U2hvdyA9IHRoaXMucHJldkhpZGUgPSAkKCk7XFxuXFx0XFx0XFx0dGhpcy5lbGVtZW50LmFkZENsYXNzKFxcXCJ1aS1hY2NvcmRpb24gdWktd2lkZ2V0IHVpLWhlbHBlci1yZXNldFxcXCIpXFxuXFx0XFx0XFx0Ly8gQVJJQVxcblxcdFxcdFxcdC5hdHRyKFxcXCJyb2xlXFxcIiwgXFxcInRhYmxpc3RcXFwiKTtcXG5cXG5cXHRcXHRcXHQvLyBkb24ndCBhbGxvdyBjb2xsYXBzaWJsZTogZmFsc2UgYW5kIGFjdGl2ZTogZmFsc2UgLyBudWxsXFxuXFx0XFx0XFx0aWYgKCFvcHRpb25zLmNvbGxhcHNpYmxlICYmIChvcHRpb25zLmFjdGl2ZSA9PT0gZmFsc2UgfHwgb3B0aW9ucy5hY3RpdmUgPT0gbnVsbCkpIHtcXG5cXHRcXHRcXHRcXHRvcHRpb25zLmFjdGl2ZSA9IDA7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMuX3Byb2Nlc3NQYW5lbHMoKTtcXG5cXHRcXHRcXHQvLyBoYW5kbGUgbmVnYXRpdmUgdmFsdWVzXFxuXFx0XFx0XFx0aWYgKG9wdGlvbnMuYWN0aXZlIDwgMCkge1xcblxcdFxcdFxcdFxcdG9wdGlvbnMuYWN0aXZlICs9IHRoaXMuaGVhZGVycy5sZW5ndGg7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHRoaXMuX3JlZnJlc2goKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9nZXRDcmVhdGVFdmVudERhdGE6IGZ1bmN0aW9uIF9nZXRDcmVhdGVFdmVudERhdGEoKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHtcXG5cXHRcXHRcXHRcXHRoZWFkZXI6IHRoaXMuYWN0aXZlLFxcblxcdFxcdFxcdFxcdHBhbmVsOiAhdGhpcy5hY3RpdmUubGVuZ3RoID8gJCgpIDogdGhpcy5hY3RpdmUubmV4dCgpXFxuXFx0XFx0XFx0fTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9jcmVhdGVJY29uczogZnVuY3Rpb24gX2NyZWF0ZUljb25zKCkge1xcblxcdFxcdFxcdHZhciBpY29ucyA9IHRoaXMub3B0aW9ucy5pY29ucztcXG5cXHRcXHRcXHRpZiAoaWNvbnMpIHtcXG5cXHRcXHRcXHRcXHQkKFxcXCI8c3Bhbj5cXFwiKS5hZGRDbGFzcyhcXFwidWktYWNjb3JkaW9uLWhlYWRlci1pY29uIHVpLWljb24gXFxcIiArIGljb25zLmhlYWRlcikucHJlcGVuZFRvKHRoaXMuaGVhZGVycyk7XFxuXFx0XFx0XFx0XFx0dGhpcy5hY3RpdmUuY2hpbGRyZW4oXFxcIi51aS1hY2NvcmRpb24taGVhZGVyLWljb25cXFwiKS5yZW1vdmVDbGFzcyhpY29ucy5oZWFkZXIpLmFkZENsYXNzKGljb25zLmFjdGl2ZUhlYWRlcik7XFxuXFx0XFx0XFx0XFx0dGhpcy5oZWFkZXJzLmFkZENsYXNzKFxcXCJ1aS1hY2NvcmRpb24taWNvbnNcXFwiKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfZGVzdHJveUljb25zOiBmdW5jdGlvbiBfZGVzdHJveUljb25zKCkge1xcblxcdFxcdFxcdHRoaXMuaGVhZGVycy5yZW1vdmVDbGFzcyhcXFwidWktYWNjb3JkaW9uLWljb25zXFxcIikuY2hpbGRyZW4oXFxcIi51aS1hY2NvcmRpb24taGVhZGVyLWljb25cXFwiKS5yZW1vdmUoKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9kZXN0cm95OiBmdW5jdGlvbiBfZGVzdHJveSgpIHtcXG5cXHRcXHRcXHR2YXIgY29udGVudHM7XFxuXFxuXFx0XFx0XFx0Ly8gY2xlYW4gdXAgbWFpbiBlbGVtZW50XFxuXFx0XFx0XFx0dGhpcy5lbGVtZW50LnJlbW92ZUNsYXNzKFxcXCJ1aS1hY2NvcmRpb24gdWktd2lkZ2V0IHVpLWhlbHBlci1yZXNldFxcXCIpLnJlbW92ZUF0dHIoXFxcInJvbGVcXFwiKTtcXG5cXG5cXHRcXHRcXHQvLyBjbGVhbiB1cCBoZWFkZXJzXFxuXFx0XFx0XFx0dGhpcy5oZWFkZXJzLnJlbW92ZUNsYXNzKFxcXCJ1aS1hY2NvcmRpb24taGVhZGVyIHVpLWFjY29yZGlvbi1oZWFkZXItYWN0aXZlIHVpLXN0YXRlLWRlZmF1bHQgXFxcIiArIFxcXCJ1aS1jb3JuZXItYWxsIHVpLXN0YXRlLWFjdGl2ZSB1aS1zdGF0ZS1kaXNhYmxlZCB1aS1jb3JuZXItdG9wXFxcIikucmVtb3ZlQXR0cihcXFwicm9sZVxcXCIpLnJlbW92ZUF0dHIoXFxcImFyaWEtZXhwYW5kZWRcXFwiKS5yZW1vdmVBdHRyKFxcXCJhcmlhLXNlbGVjdGVkXFxcIikucmVtb3ZlQXR0cihcXFwiYXJpYS1jb250cm9sc1xcXCIpLnJlbW92ZUF0dHIoXFxcInRhYkluZGV4XFxcIikucmVtb3ZlVW5pcXVlSWQoKTtcXG5cXG5cXHRcXHRcXHR0aGlzLl9kZXN0cm95SWNvbnMoKTtcXG5cXG5cXHRcXHRcXHQvLyBjbGVhbiB1cCBjb250ZW50IHBhbmVsc1xcblxcdFxcdFxcdGNvbnRlbnRzID0gdGhpcy5oZWFkZXJzLm5leHQoKS5yZW1vdmVDbGFzcyhcXFwidWktaGVscGVyLXJlc2V0IHVpLXdpZGdldC1jb250ZW50IHVpLWNvcm5lci1ib3R0b20gXFxcIiArIFxcXCJ1aS1hY2NvcmRpb24tY29udGVudCB1aS1hY2NvcmRpb24tY29udGVudC1hY3RpdmUgdWktc3RhdGUtZGlzYWJsZWRcXFwiKS5jc3MoXFxcImRpc3BsYXlcXFwiLCBcXFwiXFxcIikucmVtb3ZlQXR0cihcXFwicm9sZVxcXCIpLnJlbW92ZUF0dHIoXFxcImFyaWEtaGlkZGVuXFxcIikucmVtb3ZlQXR0cihcXFwiYXJpYS1sYWJlbGxlZGJ5XFxcIikucmVtb3ZlVW5pcXVlSWQoKTtcXG5cXG5cXHRcXHRcXHRpZiAodGhpcy5vcHRpb25zLmhlaWdodFN0eWxlICE9PSBcXFwiY29udGVudFxcXCIpIHtcXG5cXHRcXHRcXHRcXHRjb250ZW50cy5jc3MoXFxcImhlaWdodFxcXCIsIFxcXCJcXFwiKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfc2V0T3B0aW9uOiBmdW5jdGlvbiBfc2V0T3B0aW9uKGtleSwgdmFsdWUpIHtcXG5cXHRcXHRcXHRpZiAoa2V5ID09PSBcXFwiYWN0aXZlXFxcIikge1xcblxcdFxcdFxcdFxcdC8vIF9hY3RpdmF0ZSgpIHdpbGwgaGFuZGxlIGludmFsaWQgdmFsdWVzIGFuZCB1cGRhdGUgdGhpcy5vcHRpb25zXFxuXFx0XFx0XFx0XFx0dGhpcy5fYWN0aXZhdGUodmFsdWUpO1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKGtleSA9PT0gXFxcImV2ZW50XFxcIikge1xcblxcdFxcdFxcdFxcdGlmICh0aGlzLm9wdGlvbnMuZXZlbnQpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9vZmYodGhpcy5oZWFkZXJzLCB0aGlzLm9wdGlvbnMuZXZlbnQpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR0aGlzLl9zZXR1cEV2ZW50cyh2YWx1ZSk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMuX3N1cGVyKGtleSwgdmFsdWUpO1xcblxcblxcdFxcdFxcdC8vIHNldHRpbmcgY29sbGFwc2libGU6IGZhbHNlIHdoaWxlIGNvbGxhcHNlZDsgb3BlbiBmaXJzdCBwYW5lbFxcblxcdFxcdFxcdGlmIChrZXkgPT09IFxcXCJjb2xsYXBzaWJsZVxcXCIgJiYgIXZhbHVlICYmIHRoaXMub3B0aW9ucy5hY3RpdmUgPT09IGZhbHNlKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5fYWN0aXZhdGUoMCk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmIChrZXkgPT09IFxcXCJpY29uc1xcXCIpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9kZXN0cm95SWNvbnMoKTtcXG5cXHRcXHRcXHRcXHRpZiAodmFsdWUpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9jcmVhdGVJY29ucygpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gIzUzMzIgLSBvcGFjaXR5IGRvZXNuJ3QgY2FzY2FkZSB0byBwb3NpdGlvbmVkIGVsZW1lbnRzIGluIElFXFxuXFx0XFx0XFx0Ly8gc28gd2UgbmVlZCB0byBhZGQgdGhlIGRpc2FibGVkIGNsYXNzIHRvIHRoZSBoZWFkZXJzIGFuZCBwYW5lbHNcXG5cXHRcXHRcXHRpZiAoa2V5ID09PSBcXFwiZGlzYWJsZWRcXFwiKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5lbGVtZW50LnRvZ2dsZUNsYXNzKFxcXCJ1aS1zdGF0ZS1kaXNhYmxlZFxcXCIsICEhdmFsdWUpLmF0dHIoXFxcImFyaWEtZGlzYWJsZWRcXFwiLCB2YWx1ZSk7XFxuXFx0XFx0XFx0XFx0dGhpcy5oZWFkZXJzLmFkZCh0aGlzLmhlYWRlcnMubmV4dCgpKS50b2dnbGVDbGFzcyhcXFwidWktc3RhdGUtZGlzYWJsZWRcXFwiLCAhIXZhbHVlKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfa2V5ZG93bjogZnVuY3Rpb24gX2tleWRvd24oZXZlbnQpIHtcXG5cXHRcXHRcXHRpZiAoZXZlbnQuYWx0S2V5IHx8IGV2ZW50LmN0cmxLZXkpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHZhciBrZXlDb2RlID0gJC51aS5rZXlDb2RlLFxcblxcdFxcdFxcdCAgICBsZW5ndGggPSB0aGlzLmhlYWRlcnMubGVuZ3RoLFxcblxcdFxcdFxcdCAgICBjdXJyZW50SW5kZXggPSB0aGlzLmhlYWRlcnMuaW5kZXgoZXZlbnQudGFyZ2V0KSxcXG5cXHRcXHRcXHQgICAgdG9Gb2N1cyA9IGZhbHNlO1xcblxcblxcdFxcdFxcdHN3aXRjaCAoZXZlbnQua2V5Q29kZSkge1xcblxcdFxcdFxcdFxcdGNhc2Uga2V5Q29kZS5SSUdIVDpcXG5cXHRcXHRcXHRcXHRjYXNlIGtleUNvZGUuRE9XTjpcXG5cXHRcXHRcXHRcXHRcXHR0b0ZvY3VzID0gdGhpcy5oZWFkZXJzWyhjdXJyZW50SW5kZXggKyAxKSAlIGxlbmd0aF07XFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0Y2FzZSBrZXlDb2RlLkxFRlQ6XFxuXFx0XFx0XFx0XFx0Y2FzZSBrZXlDb2RlLlVQOlxcblxcdFxcdFxcdFxcdFxcdHRvRm9jdXMgPSB0aGlzLmhlYWRlcnNbKGN1cnJlbnRJbmRleCAtIDEgKyBsZW5ndGgpICUgbGVuZ3RoXTtcXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRjYXNlIGtleUNvZGUuU1BBQ0U6XFxuXFx0XFx0XFx0XFx0Y2FzZSBrZXlDb2RlLkVOVEVSOlxcblxcdFxcdFxcdFxcdFxcdHRoaXMuX2V2ZW50SGFuZGxlcihldmVudCk7XFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0Y2FzZSBrZXlDb2RlLkhPTUU6XFxuXFx0XFx0XFx0XFx0XFx0dG9Gb2N1cyA9IHRoaXMuaGVhZGVyc1swXTtcXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRjYXNlIGtleUNvZGUuRU5EOlxcblxcdFxcdFxcdFxcdFxcdHRvRm9jdXMgPSB0aGlzLmhlYWRlcnNbbGVuZ3RoIC0gMV07XFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICh0b0ZvY3VzKSB7XFxuXFx0XFx0XFx0XFx0JChldmVudC50YXJnZXQpLmF0dHIoXFxcInRhYkluZGV4XFxcIiwgLTEpO1xcblxcdFxcdFxcdFxcdCQodG9Gb2N1cykuYXR0cihcXFwidGFiSW5kZXhcXFwiLCAwKTtcXG5cXHRcXHRcXHRcXHR0b0ZvY3VzLmZvY3VzKCk7XFxuXFx0XFx0XFx0XFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfcGFuZWxLZXlEb3duOiBmdW5jdGlvbiBfcGFuZWxLZXlEb3duKGV2ZW50KSB7XFxuXFx0XFx0XFx0aWYgKGV2ZW50LmtleUNvZGUgPT09ICQudWkua2V5Q29kZS5VUCAmJiBldmVudC5jdHJsS2V5KSB7XFxuXFx0XFx0XFx0XFx0JChldmVudC5jdXJyZW50VGFyZ2V0KS5wcmV2KCkuZm9jdXMoKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRyZWZyZXNoOiBmdW5jdGlvbiByZWZyZXNoKCkge1xcblxcdFxcdFxcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xcblxcdFxcdFxcdHRoaXMuX3Byb2Nlc3NQYW5lbHMoKTtcXG5cXG5cXHRcXHRcXHQvLyB3YXMgY29sbGFwc2VkIG9yIG5vIHBhbmVsXFxuXFx0XFx0XFx0aWYgKG9wdGlvbnMuYWN0aXZlID09PSBmYWxzZSAmJiBvcHRpb25zLmNvbGxhcHNpYmxlID09PSB0cnVlIHx8ICF0aGlzLmhlYWRlcnMubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0b3B0aW9ucy5hY3RpdmUgPSBmYWxzZTtcXG5cXHRcXHRcXHRcXHR0aGlzLmFjdGl2ZSA9ICQoKTtcXG5cXHRcXHRcXHRcXHQvLyBhY3RpdmUgZmFsc2Ugb25seSB3aGVuIGNvbGxhcHNpYmxlIGlzIHRydWVcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKG9wdGlvbnMuYWN0aXZlID09PSBmYWxzZSkge1xcblxcdFxcdFxcdFxcdHRoaXMuX2FjdGl2YXRlKDApO1xcblxcdFxcdFxcdFxcdC8vIHdhcyBhY3RpdmUsIGJ1dCBhY3RpdmUgcGFuZWwgaXMgZ29uZVxcblxcdFxcdFxcdH0gZWxzZSBpZiAodGhpcy5hY3RpdmUubGVuZ3RoICYmICEkLmNvbnRhaW5zKHRoaXMuZWxlbWVudFswXSwgdGhpcy5hY3RpdmVbMF0pKSB7XFxuXFx0XFx0XFx0XFx0Ly8gYWxsIHJlbWFpbmluZyBwYW5lbCBhcmUgZGlzYWJsZWRcXG5cXHRcXHRcXHRcXHRpZiAodGhpcy5oZWFkZXJzLmxlbmd0aCA9PT0gdGhpcy5oZWFkZXJzLmZpbmQoXFxcIi51aS1zdGF0ZS1kaXNhYmxlZFxcXCIpLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdFxcdG9wdGlvbnMuYWN0aXZlID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5hY3RpdmUgPSAkKCk7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gYWN0aXZhdGUgcHJldmlvdXMgcGFuZWxcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX2FjdGl2YXRlKE1hdGgubWF4KDAsIG9wdGlvbnMuYWN0aXZlIC0gMSkpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHQvLyB3YXMgYWN0aXZlLCBhY3RpdmUgcGFuZWwgc3RpbGwgZXhpc3RzXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHQvLyBtYWtlIHN1cmUgYWN0aXZlIGluZGV4IGlzIGNvcnJlY3RcXG5cXHRcXHRcXHRcXHRvcHRpb25zLmFjdGl2ZSA9IHRoaXMuaGVhZGVycy5pbmRleCh0aGlzLmFjdGl2ZSk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMuX2Rlc3Ryb3lJY29ucygpO1xcblxcblxcdFxcdFxcdHRoaXMuX3JlZnJlc2goKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9wcm9jZXNzUGFuZWxzOiBmdW5jdGlvbiBfcHJvY2Vzc1BhbmVscygpIHtcXG5cXHRcXHRcXHR2YXIgcHJldkhlYWRlcnMgPSB0aGlzLmhlYWRlcnMsXFxuXFx0XFx0XFx0ICAgIHByZXZQYW5lbHMgPSB0aGlzLnBhbmVscztcXG5cXG5cXHRcXHRcXHR0aGlzLmhlYWRlcnMgPSB0aGlzLmVsZW1lbnQuZmluZCh0aGlzLm9wdGlvbnMuaGVhZGVyKS5hZGRDbGFzcyhcXFwidWktYWNjb3JkaW9uLWhlYWRlciB1aS1zdGF0ZS1kZWZhdWx0IHVpLWNvcm5lci1hbGxcXFwiKTtcXG5cXG5cXHRcXHRcXHR0aGlzLnBhbmVscyA9IHRoaXMuaGVhZGVycy5uZXh0KCkuYWRkQ2xhc3MoXFxcInVpLWFjY29yZGlvbi1jb250ZW50IHVpLWhlbHBlci1yZXNldCB1aS13aWRnZXQtY29udGVudCB1aS1jb3JuZXItYm90dG9tXFxcIikuZmlsdGVyKFxcXCI6bm90KC51aS1hY2NvcmRpb24tY29udGVudC1hY3RpdmUpXFxcIikuaGlkZSgpO1xcblxcblxcdFxcdFxcdC8vIEF2b2lkIG1lbW9yeSBsZWFrcyAoIzEwMDU2KVxcblxcdFxcdFxcdGlmIChwcmV2UGFuZWxzKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5fb2ZmKHByZXZIZWFkZXJzLm5vdCh0aGlzLmhlYWRlcnMpKTtcXG5cXHRcXHRcXHRcXHR0aGlzLl9vZmYocHJldlBhbmVscy5ub3QodGhpcy5wYW5lbHMpKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfcmVmcmVzaDogZnVuY3Rpb24gX3JlZnJlc2goKSB7XFxuXFx0XFx0XFx0dmFyIG1heEhlaWdodCxcXG5cXHRcXHRcXHQgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcXG5cXHRcXHRcXHQgICAgaGVpZ2h0U3R5bGUgPSBvcHRpb25zLmhlaWdodFN0eWxlLFxcblxcdFxcdFxcdCAgICBwYXJlbnQgPSB0aGlzLmVsZW1lbnQucGFyZW50KCk7XFxuXFxuXFx0XFx0XFx0dGhpcy5hY3RpdmUgPSB0aGlzLl9maW5kQWN0aXZlKG9wdGlvbnMuYWN0aXZlKS5hZGRDbGFzcyhcXFwidWktYWNjb3JkaW9uLWhlYWRlci1hY3RpdmUgdWktc3RhdGUtYWN0aXZlIHVpLWNvcm5lci10b3BcXFwiKS5yZW1vdmVDbGFzcyhcXFwidWktY29ybmVyLWFsbFxcXCIpO1xcblxcdFxcdFxcdHRoaXMuYWN0aXZlLm5leHQoKS5hZGRDbGFzcyhcXFwidWktYWNjb3JkaW9uLWNvbnRlbnQtYWN0aXZlXFxcIikuc2hvdygpO1xcblxcblxcdFxcdFxcdHRoaXMuaGVhZGVycy5hdHRyKFxcXCJyb2xlXFxcIiwgXFxcInRhYlxcXCIpLmVhY2goZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdHZhciBoZWFkZXIgPSAkKHRoaXMpLFxcblxcdFxcdFxcdFxcdCAgICBoZWFkZXJJZCA9IGhlYWRlci51bmlxdWVJZCgpLmF0dHIoXFxcImlkXFxcIiksXFxuXFx0XFx0XFx0XFx0ICAgIHBhbmVsID0gaGVhZGVyLm5leHQoKSxcXG5cXHRcXHRcXHRcXHQgICAgcGFuZWxJZCA9IHBhbmVsLnVuaXF1ZUlkKCkuYXR0cihcXFwiaWRcXFwiKTtcXG5cXHRcXHRcXHRcXHRoZWFkZXIuYXR0cihcXFwiYXJpYS1jb250cm9sc1xcXCIsIHBhbmVsSWQpO1xcblxcdFxcdFxcdFxcdHBhbmVsLmF0dHIoXFxcImFyaWEtbGFiZWxsZWRieVxcXCIsIGhlYWRlcklkKTtcXG5cXHRcXHRcXHR9KS5uZXh0KCkuYXR0cihcXFwicm9sZVxcXCIsIFxcXCJ0YWJwYW5lbFxcXCIpO1xcblxcblxcdFxcdFxcdHRoaXMuaGVhZGVycy5ub3QodGhpcy5hY3RpdmUpLmF0dHIoe1xcblxcdFxcdFxcdFxcdFxcXCJhcmlhLXNlbGVjdGVkXFxcIjogXFxcImZhbHNlXFxcIixcXG5cXHRcXHRcXHRcXHRcXFwiYXJpYS1leHBhbmRlZFxcXCI6IFxcXCJmYWxzZVxcXCIsXFxuXFx0XFx0XFx0XFx0dGFiSW5kZXg6IC0xXFxuXFx0XFx0XFx0fSkubmV4dCgpLmF0dHIoe1xcblxcdFxcdFxcdFxcdFxcXCJhcmlhLWhpZGRlblxcXCI6IFxcXCJ0cnVlXFxcIlxcblxcdFxcdFxcdH0pLmhpZGUoKTtcXG5cXG5cXHRcXHRcXHQvLyBtYWtlIHN1cmUgYXQgbGVhc3Qgb25lIGhlYWRlciBpcyBpbiB0aGUgdGFiIG9yZGVyXFxuXFx0XFx0XFx0aWYgKCF0aGlzLmFjdGl2ZS5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLmhlYWRlcnMuZXEoMCkuYXR0cihcXFwidGFiSW5kZXhcXFwiLCAwKTtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdHRoaXMuYWN0aXZlLmF0dHIoe1xcblxcdFxcdFxcdFxcdFxcdFxcXCJhcmlhLXNlbGVjdGVkXFxcIjogXFxcInRydWVcXFwiLFxcblxcdFxcdFxcdFxcdFxcdFxcXCJhcmlhLWV4cGFuZGVkXFxcIjogXFxcInRydWVcXFwiLFxcblxcdFxcdFxcdFxcdFxcdHRhYkluZGV4OiAwXFxuXFx0XFx0XFx0XFx0fSkubmV4dCgpLmF0dHIoe1xcblxcdFxcdFxcdFxcdFxcdFxcXCJhcmlhLWhpZGRlblxcXCI6IFxcXCJmYWxzZVxcXCJcXG5cXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy5fY3JlYXRlSWNvbnMoKTtcXG5cXG5cXHRcXHRcXHR0aGlzLl9zZXR1cEV2ZW50cyhvcHRpb25zLmV2ZW50KTtcXG5cXG5cXHRcXHRcXHRpZiAoaGVpZ2h0U3R5bGUgPT09IFxcXCJmaWxsXFxcIikge1xcblxcdFxcdFxcdFxcdG1heEhlaWdodCA9IHBhcmVudC5oZWlnaHQoKTtcXG5cXHRcXHRcXHRcXHR0aGlzLmVsZW1lbnQuc2libGluZ3MoXFxcIjp2aXNpYmxlXFxcIikuZWFjaChmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGVsZW0gPSAkKHRoaXMpLFxcblxcdFxcdFxcdFxcdFxcdCAgICBwb3NpdGlvbiA9IGVsZW0uY3NzKFxcXCJwb3NpdGlvblxcXCIpO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmIChwb3NpdGlvbiA9PT0gXFxcImFic29sdXRlXFxcIiB8fCBwb3NpdGlvbiA9PT0gXFxcImZpeGVkXFxcIikge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0bWF4SGVpZ2h0IC09IGVsZW0ub3V0ZXJIZWlnaHQodHJ1ZSk7XFxuXFx0XFx0XFx0XFx0fSk7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5oZWFkZXJzLmVhY2goZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdG1heEhlaWdodCAtPSAkKHRoaXMpLm91dGVySGVpZ2h0KHRydWUpO1xcblxcdFxcdFxcdFxcdH0pO1xcblxcblxcdFxcdFxcdFxcdHRoaXMuaGVhZGVycy5uZXh0KCkuZWFjaChmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0XFx0JCh0aGlzKS5oZWlnaHQoTWF0aC5tYXgoMCwgbWF4SGVpZ2h0IC0gJCh0aGlzKS5pbm5lckhlaWdodCgpICsgJCh0aGlzKS5oZWlnaHQoKSkpO1xcblxcdFxcdFxcdFxcdH0pLmNzcyhcXFwib3ZlcmZsb3dcXFwiLCBcXFwiYXV0b1xcXCIpO1xcblxcdFxcdFxcdH0gZWxzZSBpZiAoaGVpZ2h0U3R5bGUgPT09IFxcXCJhdXRvXFxcIikge1xcblxcdFxcdFxcdFxcdG1heEhlaWdodCA9IDA7XFxuXFx0XFx0XFx0XFx0dGhpcy5oZWFkZXJzLm5leHQoKS5lYWNoKGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHRtYXhIZWlnaHQgPSBNYXRoLm1heChtYXhIZWlnaHQsICQodGhpcykuY3NzKFxcXCJoZWlnaHRcXFwiLCBcXFwiXFxcIikuaGVpZ2h0KCkpO1xcblxcdFxcdFxcdFxcdH0pLmhlaWdodChtYXhIZWlnaHQpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcblxcdFxcdF9hY3RpdmF0ZTogZnVuY3Rpb24gX2FjdGl2YXRlKGluZGV4KSB7XFxuXFx0XFx0XFx0dmFyIGFjdGl2ZSA9IHRoaXMuX2ZpbmRBY3RpdmUoaW5kZXgpWzBdO1xcblxcblxcdFxcdFxcdC8vIHRyeWluZyB0byBhY3RpdmF0ZSB0aGUgYWxyZWFkeSBhY3RpdmUgcGFuZWxcXG5cXHRcXHRcXHRpZiAoYWN0aXZlID09PSB0aGlzLmFjdGl2ZVswXSkge1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gdHJ5aW5nIHRvIGNvbGxhcHNlLCBzaW11bGF0ZSBhIGNsaWNrIG9uIHRoZSBjdXJyZW50bHkgYWN0aXZlIGhlYWRlclxcblxcdFxcdFxcdGFjdGl2ZSA9IGFjdGl2ZSB8fCB0aGlzLmFjdGl2ZVswXTtcXG5cXG5cXHRcXHRcXHR0aGlzLl9ldmVudEhhbmRsZXIoe1xcblxcdFxcdFxcdFxcdHRhcmdldDogYWN0aXZlLFxcblxcdFxcdFxcdFxcdGN1cnJlbnRUYXJnZXQ6IGFjdGl2ZSxcXG5cXHRcXHRcXHRcXHRwcmV2ZW50RGVmYXVsdDogJC5ub29wXFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfZmluZEFjdGl2ZTogZnVuY3Rpb24gX2ZpbmRBY3RpdmUoc2VsZWN0b3IpIHtcXG5cXHRcXHRcXHRyZXR1cm4gdHlwZW9mIHNlbGVjdG9yID09PSBcXFwibnVtYmVyXFxcIiA/IHRoaXMuaGVhZGVycy5lcShzZWxlY3RvcikgOiAkKCk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfc2V0dXBFdmVudHM6IGZ1bmN0aW9uIF9zZXR1cEV2ZW50cyhldmVudCkge1xcblxcdFxcdFxcdHZhciBldmVudHMgPSB7XFxuXFx0XFx0XFx0XFx0a2V5ZG93bjogXFxcIl9rZXlkb3duXFxcIlxcblxcdFxcdFxcdH07XFxuXFx0XFx0XFx0aWYgKGV2ZW50KSB7XFxuXFx0XFx0XFx0XFx0JC5lYWNoKGV2ZW50LnNwbGl0KFxcXCIgXFxcIiksIGZ1bmN0aW9uIChpbmRleCwgZXZlbnROYW1lKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZXZlbnRzW2V2ZW50TmFtZV0gPSBcXFwiX2V2ZW50SGFuZGxlclxcXCI7XFxuXFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMuX29mZih0aGlzLmhlYWRlcnMuYWRkKHRoaXMuaGVhZGVycy5uZXh0KCkpKTtcXG5cXHRcXHRcXHR0aGlzLl9vbih0aGlzLmhlYWRlcnMsIGV2ZW50cyk7XFxuXFx0XFx0XFx0dGhpcy5fb24odGhpcy5oZWFkZXJzLm5leHQoKSwgeyBrZXlkb3duOiBcXFwiX3BhbmVsS2V5RG93blxcXCIgfSk7XFxuXFx0XFx0XFx0dGhpcy5faG92ZXJhYmxlKHRoaXMuaGVhZGVycyk7XFxuXFx0XFx0XFx0dGhpcy5fZm9jdXNhYmxlKHRoaXMuaGVhZGVycyk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfZXZlbnRIYW5kbGVyOiBmdW5jdGlvbiBfZXZlbnRIYW5kbGVyKGV2ZW50KSB7XFxuXFx0XFx0XFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXFxuXFx0XFx0XFx0ICAgIGFjdGl2ZSA9IHRoaXMuYWN0aXZlLFxcblxcdFxcdFxcdCAgICBjbGlja2VkID0gJChldmVudC5jdXJyZW50VGFyZ2V0KSxcXG5cXHRcXHRcXHQgICAgY2xpY2tlZElzQWN0aXZlID0gY2xpY2tlZFswXSA9PT0gYWN0aXZlWzBdLFxcblxcdFxcdFxcdCAgICBjb2xsYXBzaW5nID0gY2xpY2tlZElzQWN0aXZlICYmIG9wdGlvbnMuY29sbGFwc2libGUsXFxuXFx0XFx0XFx0ICAgIHRvU2hvdyA9IGNvbGxhcHNpbmcgPyAkKCkgOiBjbGlja2VkLm5leHQoKSxcXG5cXHRcXHRcXHQgICAgdG9IaWRlID0gYWN0aXZlLm5leHQoKSxcXG5cXHRcXHRcXHQgICAgZXZlbnREYXRhID0ge1xcblxcdFxcdFxcdFxcdG9sZEhlYWRlcjogYWN0aXZlLFxcblxcdFxcdFxcdFxcdG9sZFBhbmVsOiB0b0hpZGUsXFxuXFx0XFx0XFx0XFx0bmV3SGVhZGVyOiBjb2xsYXBzaW5nID8gJCgpIDogY2xpY2tlZCxcXG5cXHRcXHRcXHRcXHRuZXdQYW5lbDogdG9TaG93XFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHRcXHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xcblxcblxcdFxcdFxcdGlmIChcXG5cXHRcXHRcXHQvLyBjbGljayBvbiBhY3RpdmUgaGVhZGVyLCBidXQgbm90IGNvbGxhcHNpYmxlXFxuXFx0XFx0XFx0Y2xpY2tlZElzQWN0aXZlICYmICFvcHRpb25zLmNvbGxhcHNpYmxlIHx8XFxuXFx0XFx0XFx0Ly8gYWxsb3cgY2FuY2VsaW5nIGFjdGl2YXRpb25cXG5cXHRcXHRcXHR0aGlzLl90cmlnZ2VyKFxcXCJiZWZvcmVBY3RpdmF0ZVxcXCIsIGV2ZW50LCBldmVudERhdGEpID09PSBmYWxzZSkge1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0b3B0aW9ucy5hY3RpdmUgPSBjb2xsYXBzaW5nID8gZmFsc2UgOiB0aGlzLmhlYWRlcnMuaW5kZXgoY2xpY2tlZCk7XFxuXFxuXFx0XFx0XFx0Ly8gd2hlbiB0aGUgY2FsbCB0byAuX3RvZ2dsZSgpIGNvbWVzIGFmdGVyIHRoZSBjbGFzcyBjaGFuZ2VzXFxuXFx0XFx0XFx0Ly8gaXQgY2F1c2VzIGEgdmVyeSBvZGQgYnVnIGluIElFIDggKHNlZSAjNjcyMClcXG5cXHRcXHRcXHR0aGlzLmFjdGl2ZSA9IGNsaWNrZWRJc0FjdGl2ZSA/ICQoKSA6IGNsaWNrZWQ7XFxuXFx0XFx0XFx0dGhpcy5fdG9nZ2xlKGV2ZW50RGF0YSk7XFxuXFxuXFx0XFx0XFx0Ly8gc3dpdGNoIGNsYXNzZXNcXG5cXHRcXHRcXHQvLyBjb3JuZXIgY2xhc3NlcyBvbiB0aGUgcHJldmlvdXNseSBhY3RpdmUgaGVhZGVyIHN0YXkgYWZ0ZXIgdGhlIGFuaW1hdGlvblxcblxcdFxcdFxcdGFjdGl2ZS5yZW1vdmVDbGFzcyhcXFwidWktYWNjb3JkaW9uLWhlYWRlci1hY3RpdmUgdWktc3RhdGUtYWN0aXZlXFxcIik7XFxuXFx0XFx0XFx0aWYgKG9wdGlvbnMuaWNvbnMpIHtcXG5cXHRcXHRcXHRcXHRhY3RpdmUuY2hpbGRyZW4oXFxcIi51aS1hY2NvcmRpb24taGVhZGVyLWljb25cXFwiKS5yZW1vdmVDbGFzcyhvcHRpb25zLmljb25zLmFjdGl2ZUhlYWRlcikuYWRkQ2xhc3Mob3B0aW9ucy5pY29ucy5oZWFkZXIpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIWNsaWNrZWRJc0FjdGl2ZSkge1xcblxcdFxcdFxcdFxcdGNsaWNrZWQucmVtb3ZlQ2xhc3MoXFxcInVpLWNvcm5lci1hbGxcXFwiKS5hZGRDbGFzcyhcXFwidWktYWNjb3JkaW9uLWhlYWRlci1hY3RpdmUgdWktc3RhdGUtYWN0aXZlIHVpLWNvcm5lci10b3BcXFwiKTtcXG5cXHRcXHRcXHRcXHRpZiAob3B0aW9ucy5pY29ucykge1xcblxcdFxcdFxcdFxcdFxcdGNsaWNrZWQuY2hpbGRyZW4oXFxcIi51aS1hY2NvcmRpb24taGVhZGVyLWljb25cXFwiKS5yZW1vdmVDbGFzcyhvcHRpb25zLmljb25zLmhlYWRlcikuYWRkQ2xhc3Mob3B0aW9ucy5pY29ucy5hY3RpdmVIZWFkZXIpO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRjbGlja2VkLm5leHQoKS5hZGRDbGFzcyhcXFwidWktYWNjb3JkaW9uLWNvbnRlbnQtYWN0aXZlXFxcIik7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFxuXFx0XFx0X3RvZ2dsZTogZnVuY3Rpb24gX3RvZ2dsZShkYXRhKSB7XFxuXFx0XFx0XFx0dmFyIHRvU2hvdyA9IGRhdGEubmV3UGFuZWwsXFxuXFx0XFx0XFx0ICAgIHRvSGlkZSA9IHRoaXMucHJldlNob3cubGVuZ3RoID8gdGhpcy5wcmV2U2hvdyA6IGRhdGEub2xkUGFuZWw7XFxuXFxuXFx0XFx0XFx0Ly8gaGFuZGxlIGFjdGl2YXRpbmcgYSBwYW5lbCBkdXJpbmcgdGhlIGFuaW1hdGlvbiBmb3IgYW5vdGhlciBhY3RpdmF0aW9uXFxuXFx0XFx0XFx0dGhpcy5wcmV2U2hvdy5hZGQodGhpcy5wcmV2SGlkZSkuc3RvcCh0cnVlLCB0cnVlKTtcXG5cXHRcXHRcXHR0aGlzLnByZXZTaG93ID0gdG9TaG93O1xcblxcdFxcdFxcdHRoaXMucHJldkhpZGUgPSB0b0hpZGU7XFxuXFxuXFx0XFx0XFx0aWYgKHRoaXMub3B0aW9ucy5hbmltYXRlKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5fYW5pbWF0ZSh0b1Nob3csIHRvSGlkZSwgZGF0YSk7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHR0b0hpZGUuaGlkZSgpO1xcblxcdFxcdFxcdFxcdHRvU2hvdy5zaG93KCk7XFxuXFx0XFx0XFx0XFx0dGhpcy5fdG9nZ2xlQ29tcGxldGUoZGF0YSk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRvSGlkZS5hdHRyKHtcXG5cXHRcXHRcXHRcXHRcXFwiYXJpYS1oaWRkZW5cXFwiOiBcXFwidHJ1ZVxcXCJcXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHR0b0hpZGUucHJldigpLmF0dHIoe1xcblxcdFxcdFxcdFxcdFxcXCJhcmlhLXNlbGVjdGVkXFxcIjogXFxcImZhbHNlXFxcIixcXG5cXHRcXHRcXHRcXHRcXFwiYXJpYS1leHBhbmRlZFxcXCI6IFxcXCJmYWxzZVxcXCJcXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHQvLyBpZiB3ZSdyZSBzd2l0Y2hpbmcgcGFuZWxzLCByZW1vdmUgdGhlIG9sZCBoZWFkZXIgZnJvbSB0aGUgdGFiIG9yZGVyXFxuXFx0XFx0XFx0Ly8gaWYgd2UncmUgb3BlbmluZyBmcm9tIGNvbGxhcHNlZCBzdGF0ZSwgcmVtb3ZlIHRoZSBwcmV2aW91cyBoZWFkZXIgZnJvbSB0aGUgdGFiIG9yZGVyXFxuXFx0XFx0XFx0Ly8gaWYgd2UncmUgY29sbGFwc2luZywgdGhlbiBrZWVwIHRoZSBjb2xsYXBzaW5nIGhlYWRlciBpbiB0aGUgdGFiIG9yZGVyXFxuXFx0XFx0XFx0aWYgKHRvU2hvdy5sZW5ndGggJiYgdG9IaWRlLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdHRvSGlkZS5wcmV2KCkuYXR0cih7XFxuXFx0XFx0XFx0XFx0XFx0XFxcInRhYkluZGV4XFxcIjogLTEsXFxuXFx0XFx0XFx0XFx0XFx0XFxcImFyaWEtZXhwYW5kZWRcXFwiOiBcXFwiZmFsc2VcXFwiXFxuXFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0fSBlbHNlIGlmICh0b1Nob3cubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5oZWFkZXJzLmZpbHRlcihmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHBhcnNlSW50KCQodGhpcykuYXR0cihcXFwidGFiSW5kZXhcXFwiKSwgMTApID09PSAwO1xcblxcdFxcdFxcdFxcdH0pLmF0dHIoXFxcInRhYkluZGV4XFxcIiwgLTEpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0b1Nob3cuYXR0cihcXFwiYXJpYS1oaWRkZW5cXFwiLCBcXFwiZmFsc2VcXFwiKS5wcmV2KCkuYXR0cih7XFxuXFx0XFx0XFx0XFx0XFxcImFyaWEtc2VsZWN0ZWRcXFwiOiBcXFwidHJ1ZVxcXCIsXFxuXFx0XFx0XFx0XFx0XFxcImFyaWEtZXhwYW5kZWRcXFwiOiBcXFwidHJ1ZVxcXCIsXFxuXFx0XFx0XFx0XFx0dGFiSW5kZXg6IDBcXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9hbmltYXRlOiBmdW5jdGlvbiBfYW5pbWF0ZSh0b1Nob3csIHRvSGlkZSwgZGF0YSkge1xcblxcdFxcdFxcdHZhciB0b3RhbCxcXG5cXHRcXHRcXHQgICAgZWFzaW5nLFxcblxcdFxcdFxcdCAgICBkdXJhdGlvbixcXG5cXHRcXHRcXHQgICAgdGhhdCA9IHRoaXMsXFxuXFx0XFx0XFx0ICAgIGFkanVzdCA9IDAsXFxuXFx0XFx0XFx0ICAgIGJveFNpemluZyA9IHRvU2hvdy5jc3MoXFxcImJveC1zaXppbmdcXFwiKSxcXG5cXHRcXHRcXHQgICAgZG93biA9IHRvU2hvdy5sZW5ndGggJiYgKCF0b0hpZGUubGVuZ3RoIHx8IHRvU2hvdy5pbmRleCgpIDwgdG9IaWRlLmluZGV4KCkpLFxcblxcdFxcdFxcdCAgICBhbmltYXRlID0gdGhpcy5vcHRpb25zLmFuaW1hdGUgfHwge30sXFxuXFx0XFx0XFx0ICAgIG9wdGlvbnMgPSBkb3duICYmIGFuaW1hdGUuZG93biB8fCBhbmltYXRlLFxcblxcdFxcdFxcdCAgICBjb21wbGV0ZSA9IGZ1bmN0aW9uIGNvbXBsZXRlKCkge1xcblxcdFxcdFxcdFxcdHRoYXQuX3RvZ2dsZUNvbXBsZXRlKGRhdGEpO1xcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0XFx0aWYgKHR5cGVvZiBvcHRpb25zID09PSBcXFwibnVtYmVyXFxcIikge1xcblxcdFxcdFxcdFxcdGR1cmF0aW9uID0gb3B0aW9ucztcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKHR5cGVvZiBvcHRpb25zID09PSBcXFwic3RyaW5nXFxcIikge1xcblxcdFxcdFxcdFxcdGVhc2luZyA9IG9wdGlvbnM7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdC8vIGZhbGwgYmFjayBmcm9tIG9wdGlvbnMgdG8gYW5pbWF0aW9uIGluIGNhc2Ugb2YgcGFydGlhbCBkb3duIHNldHRpbmdzXFxuXFx0XFx0XFx0ZWFzaW5nID0gZWFzaW5nIHx8IG9wdGlvbnMuZWFzaW5nIHx8IGFuaW1hdGUuZWFzaW5nO1xcblxcdFxcdFxcdGR1cmF0aW9uID0gZHVyYXRpb24gfHwgb3B0aW9ucy5kdXJhdGlvbiB8fCBhbmltYXRlLmR1cmF0aW9uO1xcblxcblxcdFxcdFxcdGlmICghdG9IaWRlLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdHJldHVybiB0b1Nob3cuYW5pbWF0ZSh0aGlzLnNob3dQcm9wcywgZHVyYXRpb24sIGVhc2luZywgY29tcGxldGUpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoIXRvU2hvdy5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdG9IaWRlLmFuaW1hdGUodGhpcy5oaWRlUHJvcHMsIGR1cmF0aW9uLCBlYXNpbmcsIGNvbXBsZXRlKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dG90YWwgPSB0b1Nob3cuc2hvdygpLm91dGVySGVpZ2h0KCk7XFxuXFx0XFx0XFx0dG9IaWRlLmFuaW1hdGUodGhpcy5oaWRlUHJvcHMsIHtcXG5cXHRcXHRcXHRcXHRkdXJhdGlvbjogZHVyYXRpb24sXFxuXFx0XFx0XFx0XFx0ZWFzaW5nOiBlYXNpbmcsXFxuXFx0XFx0XFx0XFx0c3RlcDogZnVuY3Rpb24gc3RlcChub3csIGZ4KSB7XFxuXFx0XFx0XFx0XFx0XFx0Zngubm93ID0gTWF0aC5yb3VuZChub3cpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHR0b1Nob3cuaGlkZSgpLmFuaW1hdGUodGhpcy5zaG93UHJvcHMsIHtcXG5cXHRcXHRcXHRcXHRkdXJhdGlvbjogZHVyYXRpb24sXFxuXFx0XFx0XFx0XFx0ZWFzaW5nOiBlYXNpbmcsXFxuXFx0XFx0XFx0XFx0Y29tcGxldGU6IGNvbXBsZXRlLFxcblxcdFxcdFxcdFxcdHN0ZXA6IGZ1bmN0aW9uIHN0ZXAobm93LCBmeCkge1xcblxcdFxcdFxcdFxcdFxcdGZ4Lm5vdyA9IE1hdGgucm91bmQobm93KTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoZngucHJvcCAhPT0gXFxcImhlaWdodFxcXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoYm94U2l6aW5nID09PSBcXFwiY29udGVudC1ib3hcXFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YWRqdXN0ICs9IGZ4Lm5vdztcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIGlmICh0aGF0Lm9wdGlvbnMuaGVpZ2h0U3R5bGUgIT09IFxcXCJjb250ZW50XFxcIikge1xcblxcdFxcdFxcdFxcdFxcdFxcdGZ4Lm5vdyA9IE1hdGgucm91bmQodG90YWwgLSB0b0hpZGUub3V0ZXJIZWlnaHQoKSAtIGFkanVzdCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YWRqdXN0ID0gMDtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0pO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X3RvZ2dsZUNvbXBsZXRlOiBmdW5jdGlvbiBfdG9nZ2xlQ29tcGxldGUoZGF0YSkge1xcblxcdFxcdFxcdHZhciB0b0hpZGUgPSBkYXRhLm9sZFBhbmVsO1xcblxcblxcdFxcdFxcdHRvSGlkZS5yZW1vdmVDbGFzcyhcXFwidWktYWNjb3JkaW9uLWNvbnRlbnQtYWN0aXZlXFxcIikucHJldigpLnJlbW92ZUNsYXNzKFxcXCJ1aS1jb3JuZXItdG9wXFxcIikuYWRkQ2xhc3MoXFxcInVpLWNvcm5lci1hbGxcXFwiKTtcXG5cXG5cXHRcXHRcXHQvLyBXb3JrIGFyb3VuZCBmb3IgcmVuZGVyaW5nIGJ1ZyBpbiBJRSAoIzU0MjEpXFxuXFx0XFx0XFx0aWYgKHRvSGlkZS5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHR0b0hpZGUucGFyZW50KClbMF0uY2xhc3NOYW1lID0gdG9IaWRlLnBhcmVudCgpWzBdLmNsYXNzTmFtZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0dGhpcy5fdHJpZ2dlcihcXFwiYWN0aXZhdGVcXFwiLCBudWxsLCBkYXRhKTtcXG5cXHRcXHR9XFxuXFx0fSk7XFxuXFxuXFx0LyohXFxuICAqIGpRdWVyeSBVSSBNZW51IDEuMTEuNFxcbiAgKiBodHRwOi8vanF1ZXJ5dWkuY29tXFxuICAqXFxuICAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXFxuICAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cXG4gICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxcbiAgKlxcbiAgKiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9tZW51L1xcbiAgKi9cXG5cXG5cXHR2YXIgbWVudSA9ICQud2lkZ2V0KFxcXCJ1aS5tZW51XFxcIiwge1xcblxcdFxcdHZlcnNpb246IFxcXCIxLjExLjRcXFwiLFxcblxcdFxcdGRlZmF1bHRFbGVtZW50OiBcXFwiPHVsPlxcXCIsXFxuXFx0XFx0ZGVsYXk6IDMwMCxcXG5cXHRcXHRvcHRpb25zOiB7XFxuXFx0XFx0XFx0aWNvbnM6IHtcXG5cXHRcXHRcXHRcXHRzdWJtZW51OiBcXFwidWktaWNvbi1jYXJhdC0xLWVcXFwiXFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRpdGVtczogXFxcIj4gKlxcXCIsXFxuXFx0XFx0XFx0bWVudXM6IFxcXCJ1bFxcXCIsXFxuXFx0XFx0XFx0cG9zaXRpb246IHtcXG5cXHRcXHRcXHRcXHRteTogXFxcImxlZnQtMSB0b3BcXFwiLFxcblxcdFxcdFxcdFxcdGF0OiBcXFwicmlnaHQgdG9wXFxcIlxcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0cm9sZTogXFxcIm1lbnVcXFwiLFxcblxcblxcdFxcdFxcdC8vIGNhbGxiYWNrc1xcblxcdFxcdFxcdGJsdXI6IG51bGwsXFxuXFx0XFx0XFx0Zm9jdXM6IG51bGwsXFxuXFx0XFx0XFx0c2VsZWN0OiBudWxsXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfY3JlYXRlOiBmdW5jdGlvbiBfY3JlYXRlKCkge1xcblxcdFxcdFxcdHRoaXMuYWN0aXZlTWVudSA9IHRoaXMuZWxlbWVudDtcXG5cXG5cXHRcXHRcXHQvLyBGbGFnIHVzZWQgdG8gcHJldmVudCBmaXJpbmcgb2YgdGhlIGNsaWNrIGhhbmRsZXJcXG5cXHRcXHRcXHQvLyBhcyB0aGUgZXZlbnQgYnViYmxlcyB1cCB0aHJvdWdoIG5lc3RlZCBtZW51c1xcblxcdFxcdFxcdHRoaXMubW91c2VIYW5kbGVkID0gZmFsc2U7XFxuXFx0XFx0XFx0dGhpcy5lbGVtZW50LnVuaXF1ZUlkKCkuYWRkQ2xhc3MoXFxcInVpLW1lbnUgdWktd2lkZ2V0IHVpLXdpZGdldC1jb250ZW50XFxcIikudG9nZ2xlQ2xhc3MoXFxcInVpLW1lbnUtaWNvbnNcXFwiLCAhIXRoaXMuZWxlbWVudC5maW5kKFxcXCIudWktaWNvblxcXCIpLmxlbmd0aCkuYXR0cih7XFxuXFx0XFx0XFx0XFx0cm9sZTogdGhpcy5vcHRpb25zLnJvbGUsXFxuXFx0XFx0XFx0XFx0dGFiSW5kZXg6IDBcXG5cXHRcXHRcXHR9KTtcXG5cXG5cXHRcXHRcXHRpZiAodGhpcy5vcHRpb25zLmRpc2FibGVkKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5lbGVtZW50LmFkZENsYXNzKFxcXCJ1aS1zdGF0ZS1kaXNhYmxlZFxcXCIpLmF0dHIoXFxcImFyaWEtZGlzYWJsZWRcXFwiLCBcXFwidHJ1ZVxcXCIpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLl9vbih7XFxuXFx0XFx0XFx0XFx0Ly8gUHJldmVudCBmb2N1cyBmcm9tIHN0aWNraW5nIHRvIGxpbmtzIGluc2lkZSBtZW51IGFmdGVyIGNsaWNraW5nXFxuXFx0XFx0XFx0XFx0Ly8gdGhlbSAoZm9jdXMgc2hvdWxkIGFsd2F5cyBzdGF5IG9uIFVMIGR1cmluZyBuYXZpZ2F0aW9uKS5cXG5cXHRcXHRcXHRcXHRcXFwibW91c2Vkb3duIC51aS1tZW51LWl0ZW1cXFwiOiBmdW5jdGlvbiBtb3VzZWRvd25VaU1lbnVJdGVtKGV2ZW50KSB7XFxuXFx0XFx0XFx0XFx0XFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG5cXHRcXHRcXHRcXHR9LFxcblxcdFxcdFxcdFxcdFxcXCJjbGljayAudWktbWVudS1pdGVtXFxcIjogZnVuY3Rpb24gY2xpY2tVaU1lbnVJdGVtKGV2ZW50KSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIHRhcmdldCA9ICQoZXZlbnQudGFyZ2V0KTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIXRoaXMubW91c2VIYW5kbGVkICYmIHRhcmdldC5ub3QoXFxcIi51aS1zdGF0ZS1kaXNhYmxlZFxcXCIpLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuc2VsZWN0KGV2ZW50KTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBPbmx5IHNldCB0aGUgbW91c2VIYW5kbGVkIGZsYWcgaWYgdGhlIGV2ZW50IHdpbGwgYnViYmxlLCBzZWUgIzk0NjkuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5tb3VzZUhhbmRsZWQgPSB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBPcGVuIHN1Ym1lbnUgb24gY2xpY2tcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAodGFyZ2V0LmhhcyhcXFwiLnVpLW1lbnVcXFwiKS5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLmV4cGFuZChldmVudCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIGlmICghdGhpcy5lbGVtZW50LmlzKFxcXCI6Zm9jdXNcXFwiKSAmJiAkKHRoaXMuZG9jdW1lbnRbMF0uYWN0aXZlRWxlbWVudCkuY2xvc2VzdChcXFwiLnVpLW1lbnVcXFwiKS5sZW5ndGgpIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBSZWRpcmVjdCBmb2N1cyB0byB0aGUgbWVudVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuZWxlbWVudC50cmlnZ2VyKFxcXCJmb2N1c1xcXCIsIFt0cnVlXSk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gSWYgdGhlIGFjdGl2ZSBpdGVtIGlzIG9uIHRoZSB0b3AgbGV2ZWwsIGxldCBpdCBzdGF5IGFjdGl2ZS5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBPdGhlcndpc2UsIGJsdXIgdGhlIGFjdGl2ZSBpdGVtIHNpbmNlIGl0IGlzIG5vIGxvbmdlciB2aXNpYmxlLlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICh0aGlzLmFjdGl2ZSAmJiB0aGlzLmFjdGl2ZS5wYXJlbnRzKFxcXCIudWktbWVudVxcXCIpLmxlbmd0aCA9PT0gMSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9LFxcblxcdFxcdFxcdFxcdFxcXCJtb3VzZWVudGVyIC51aS1tZW51LWl0ZW1cXFwiOiBmdW5jdGlvbiBtb3VzZWVudGVyVWlNZW51SXRlbShldmVudCkge1xcblxcdFxcdFxcdFxcdFxcdC8vIElnbm9yZSBtb3VzZSBldmVudHMgd2hpbGUgdHlwZWFoZWFkIGlzIGFjdGl2ZSwgc2VlICMxMDQ1OC5cXG5cXHRcXHRcXHRcXHRcXHQvLyBQcmV2ZW50cyBmb2N1c2luZyB0aGUgd3JvbmcgaXRlbSB3aGVuIHR5cGVhaGVhZCBjYXVzZXMgYSBzY3JvbGwgd2hpbGUgdGhlIG1vdXNlXFxuXFx0XFx0XFx0XFx0XFx0Ly8gaXMgb3ZlciBhbiBpdGVtIGluIHRoZSBtZW51XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHRoaXMucHJldmlvdXNGaWx0ZXIpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdHZhciB0YXJnZXQgPSAkKGV2ZW50LmN1cnJlbnRUYXJnZXQpO1xcblxcdFxcdFxcdFxcdFxcdC8vIFJlbW92ZSB1aS1zdGF0ZS1hY3RpdmUgY2xhc3MgZnJvbSBzaWJsaW5ncyBvZiB0aGUgbmV3bHkgZm9jdXNlZCBtZW51IGl0ZW1cXG5cXHRcXHRcXHRcXHRcXHQvLyB0byBhdm9pZCBhIGp1bXAgY2F1c2VkIGJ5IGFkamFjZW50IGVsZW1lbnRzIGJvdGggaGF2aW5nIGEgY2xhc3Mgd2l0aCBhIGJvcmRlclxcblxcdFxcdFxcdFxcdFxcdHRhcmdldC5zaWJsaW5ncyhcXFwiLnVpLXN0YXRlLWFjdGl2ZVxcXCIpLnJlbW92ZUNsYXNzKFxcXCJ1aS1zdGF0ZS1hY3RpdmVcXFwiKTtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmZvY3VzKGV2ZW50LCB0YXJnZXQpO1xcblxcdFxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0XFx0bW91c2VsZWF2ZTogXFxcImNvbGxhcHNlQWxsXFxcIixcXG5cXHRcXHRcXHRcXHRcXFwibW91c2VsZWF2ZSAudWktbWVudVxcXCI6IFxcXCJjb2xsYXBzZUFsbFxcXCIsXFxuXFx0XFx0XFx0XFx0Zm9jdXM6IGZ1bmN0aW9uIGZvY3VzKGV2ZW50LCBrZWVwQWN0aXZlSXRlbSkge1xcblxcdFxcdFxcdFxcdFxcdC8vIElmIHRoZXJlJ3MgYWxyZWFkeSBhbiBhY3RpdmUgaXRlbSwga2VlcCBpdCBhY3RpdmVcXG5cXHRcXHRcXHRcXHRcXHQvLyBJZiBub3QsIGFjdGl2YXRlIHRoZSBmaXJzdCBpdGVtXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGl0ZW0gPSB0aGlzLmFjdGl2ZSB8fCB0aGlzLmVsZW1lbnQuZmluZCh0aGlzLm9wdGlvbnMuaXRlbXMpLmVxKDApO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICgha2VlcEFjdGl2ZUl0ZW0pIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLmZvY3VzKGV2ZW50LCBpdGVtKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRcXHRibHVyOiBmdW5jdGlvbiBibHVyKGV2ZW50KSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fZGVsYXkoZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICghJC5jb250YWlucyh0aGlzLmVsZW1lbnRbMF0sIHRoaXMuZG9jdW1lbnRbMF0uYWN0aXZlRWxlbWVudCkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLmNvbGxhcHNlQWxsKGV2ZW50KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRcXHRrZXlkb3duOiBcXFwiX2tleWRvd25cXFwiXFxuXFx0XFx0XFx0fSk7XFxuXFxuXFx0XFx0XFx0dGhpcy5yZWZyZXNoKCk7XFxuXFxuXFx0XFx0XFx0Ly8gQ2xpY2tzIG91dHNpZGUgb2YgYSBtZW51IGNvbGxhcHNlIGFueSBvcGVuIG1lbnVzXFxuXFx0XFx0XFx0dGhpcy5fb24odGhpcy5kb2N1bWVudCwge1xcblxcdFxcdFxcdFxcdGNsaWNrOiBmdW5jdGlvbiBjbGljayhldmVudCkge1xcblxcdFxcdFxcdFxcdFxcdGlmICh0aGlzLl9jbG9zZU9uRG9jdW1lbnRDbGljayhldmVudCkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLmNvbGxhcHNlQWxsKGV2ZW50KTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gUmVzZXQgdGhlIG1vdXNlSGFuZGxlZCBmbGFnXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5tb3VzZUhhbmRsZWQgPSBmYWxzZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfZGVzdHJveTogZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XFxuXFx0XFx0XFx0Ly8gRGVzdHJveSAoc3ViKW1lbnVzXFxuXFx0XFx0XFx0dGhpcy5lbGVtZW50LnJlbW92ZUF0dHIoXFxcImFyaWEtYWN0aXZlZGVzY2VuZGFudFxcXCIpLmZpbmQoXFxcIi51aS1tZW51XFxcIikuYWRkQmFjaygpLnJlbW92ZUNsYXNzKFxcXCJ1aS1tZW51IHVpLXdpZGdldCB1aS13aWRnZXQtY29udGVudCB1aS1tZW51LWljb25zIHVpLWZyb250XFxcIikucmVtb3ZlQXR0cihcXFwicm9sZVxcXCIpLnJlbW92ZUF0dHIoXFxcInRhYkluZGV4XFxcIikucmVtb3ZlQXR0cihcXFwiYXJpYS1sYWJlbGxlZGJ5XFxcIikucmVtb3ZlQXR0cihcXFwiYXJpYS1leHBhbmRlZFxcXCIpLnJlbW92ZUF0dHIoXFxcImFyaWEtaGlkZGVuXFxcIikucmVtb3ZlQXR0cihcXFwiYXJpYS1kaXNhYmxlZFxcXCIpLnJlbW92ZVVuaXF1ZUlkKCkuc2hvdygpO1xcblxcblxcdFxcdFxcdC8vIERlc3Ryb3kgbWVudSBpdGVtc1xcblxcdFxcdFxcdHRoaXMuZWxlbWVudC5maW5kKFxcXCIudWktbWVudS1pdGVtXFxcIikucmVtb3ZlQ2xhc3MoXFxcInVpLW1lbnUtaXRlbVxcXCIpLnJlbW92ZUF0dHIoXFxcInJvbGVcXFwiKS5yZW1vdmVBdHRyKFxcXCJhcmlhLWRpc2FibGVkXFxcIikucmVtb3ZlVW5pcXVlSWQoKS5yZW1vdmVDbGFzcyhcXFwidWktc3RhdGUtaG92ZXJcXFwiKS5yZW1vdmVBdHRyKFxcXCJ0YWJJbmRleFxcXCIpLnJlbW92ZUF0dHIoXFxcInJvbGVcXFwiKS5yZW1vdmVBdHRyKFxcXCJhcmlhLWhhc3BvcHVwXFxcIikuY2hpbGRyZW4oKS5lYWNoKGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHR2YXIgZWxlbSA9ICQodGhpcyk7XFxuXFx0XFx0XFx0XFx0aWYgKGVsZW0uZGF0YShcXFwidWktbWVudS1zdWJtZW51LWNhcmF0XFxcIikpIHtcXG5cXHRcXHRcXHRcXHRcXHRlbGVtLnJlbW92ZSgpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9KTtcXG5cXG5cXHRcXHRcXHQvLyBEZXN0cm95IG1lbnUgZGl2aWRlcnNcXG5cXHRcXHRcXHR0aGlzLmVsZW1lbnQuZmluZChcXFwiLnVpLW1lbnUtZGl2aWRlclxcXCIpLnJlbW92ZUNsYXNzKFxcXCJ1aS1tZW51LWRpdmlkZXIgdWktd2lkZ2V0LWNvbnRlbnRcXFwiKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9rZXlkb3duOiBmdW5jdGlvbiBfa2V5ZG93bihldmVudCkge1xcblxcdFxcdFxcdHZhciBtYXRjaCxcXG5cXHRcXHRcXHQgICAgcHJldixcXG5cXHRcXHRcXHQgICAgY2hhcmFjdGVyLFxcblxcdFxcdFxcdCAgICBza2lwLFxcblxcdFxcdFxcdCAgICBwcmV2ZW50RGVmYXVsdCA9IHRydWU7XFxuXFxuXFx0XFx0XFx0c3dpdGNoIChldmVudC5rZXlDb2RlKSB7XFxuXFx0XFx0XFx0XFx0Y2FzZSAkLnVpLmtleUNvZGUuUEFHRV9VUDpcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnByZXZpb3VzUGFnZShldmVudCk7XFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0Y2FzZSAkLnVpLmtleUNvZGUuUEFHRV9ET1dOOlxcblxcdFxcdFxcdFxcdFxcdHRoaXMubmV4dFBhZ2UoZXZlbnQpO1xcblxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdGNhc2UgJC51aS5rZXlDb2RlLkhPTUU6XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fbW92ZShcXFwiZmlyc3RcXFwiLCBcXFwiZmlyc3RcXFwiLCBldmVudCk7XFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0Y2FzZSAkLnVpLmtleUNvZGUuRU5EOlxcblxcdFxcdFxcdFxcdFxcdHRoaXMuX21vdmUoXFxcImxhc3RcXFwiLCBcXFwibGFzdFxcXCIsIGV2ZW50KTtcXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRjYXNlICQudWkua2V5Q29kZS5VUDpcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnByZXZpb3VzKGV2ZW50KTtcXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRjYXNlICQudWkua2V5Q29kZS5ET1dOOlxcblxcdFxcdFxcdFxcdFxcdHRoaXMubmV4dChldmVudCk7XFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0Y2FzZSAkLnVpLmtleUNvZGUuTEVGVDpcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmNvbGxhcHNlKGV2ZW50KTtcXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRjYXNlICQudWkua2V5Q29kZS5SSUdIVDpcXG5cXHRcXHRcXHRcXHRcXHRpZiAodGhpcy5hY3RpdmUgJiYgIXRoaXMuYWN0aXZlLmlzKFxcXCIudWktc3RhdGUtZGlzYWJsZWRcXFwiKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuZXhwYW5kKGV2ZW50KTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0Y2FzZSAkLnVpLmtleUNvZGUuRU5URVI6XFxuXFx0XFx0XFx0XFx0Y2FzZSAkLnVpLmtleUNvZGUuU1BBQ0U6XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fYWN0aXZhdGUoZXZlbnQpO1xcblxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdGNhc2UgJC51aS5rZXlDb2RlLkVTQ0FQRTpcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmNvbGxhcHNlKGV2ZW50KTtcXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRkZWZhdWx0OlxcblxcdFxcdFxcdFxcdFxcdHByZXZlbnREZWZhdWx0ID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0XFx0cHJldiA9IHRoaXMucHJldmlvdXNGaWx0ZXIgfHwgXFxcIlxcXCI7XFxuXFx0XFx0XFx0XFx0XFx0Y2hhcmFjdGVyID0gU3RyaW5nLmZyb21DaGFyQ29kZShldmVudC5rZXlDb2RlKTtcXG5cXHRcXHRcXHRcXHRcXHRza2lwID0gZmFsc2U7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y2xlYXJUaW1lb3V0KHRoaXMuZmlsdGVyVGltZXIpO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmIChjaGFyYWN0ZXIgPT09IHByZXYpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRza2lwID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdGNoYXJhY3RlciA9IHByZXYgKyBjaGFyYWN0ZXI7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdG1hdGNoID0gdGhpcy5fZmlsdGVyTWVudUl0ZW1zKGNoYXJhY3Rlcik7XFxuXFx0XFx0XFx0XFx0XFx0bWF0Y2ggPSBza2lwICYmIG1hdGNoLmluZGV4KHRoaXMuYWN0aXZlLm5leHQoKSkgIT09IC0xID8gdGhpcy5hY3RpdmUubmV4dEFsbChcXFwiLnVpLW1lbnUtaXRlbVxcXCIpIDogbWF0Y2g7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gSWYgbm8gbWF0Y2hlcyBvbiB0aGUgY3VycmVudCBmaWx0ZXIsIHJlc2V0IHRvIHRoZSBsYXN0IGNoYXJhY3RlciBwcmVzc2VkXFxuXFx0XFx0XFx0XFx0XFx0Ly8gdG8gbW92ZSBkb3duIHRoZSBtZW51IHRvIHRoZSBmaXJzdCBpdGVtIHRoYXQgc3RhcnRzIHdpdGggdGhhdCBjaGFyYWN0ZXJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIW1hdGNoLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGNoYXJhY3RlciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoZXZlbnQua2V5Q29kZSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0bWF0Y2ggPSB0aGlzLl9maWx0ZXJNZW51SXRlbXMoY2hhcmFjdGVyKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKG1hdGNoLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuZm9jdXMoZXZlbnQsIG1hdGNoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLnByZXZpb3VzRmlsdGVyID0gY2hhcmFjdGVyO1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuZmlsdGVyVGltZXIgPSB0aGlzLl9kZWxheShmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGVsZXRlIHRoaXMucHJldmlvdXNGaWx0ZXI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSwgMTAwMCk7XFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRkZWxldGUgdGhpcy5wcmV2aW91c0ZpbHRlcjtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmIChwcmV2ZW50RGVmYXVsdCkge1xcblxcdFxcdFxcdFxcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFxuXFx0XFx0X2FjdGl2YXRlOiBmdW5jdGlvbiBfYWN0aXZhdGUoZXZlbnQpIHtcXG5cXHRcXHRcXHRpZiAoIXRoaXMuYWN0aXZlLmlzKFxcXCIudWktc3RhdGUtZGlzYWJsZWRcXFwiKSkge1xcblxcdFxcdFxcdFxcdGlmICh0aGlzLmFjdGl2ZS5pcyhcXFwiW2FyaWEtaGFzcG9wdXA9J3RydWUnXVxcXCIpKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5leHBhbmQoZXZlbnQpO1xcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5zZWxlY3QoZXZlbnQpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRyZWZyZXNoOiBmdW5jdGlvbiByZWZyZXNoKCkge1xcblxcdFxcdFxcdHZhciBtZW51cyxcXG5cXHRcXHRcXHQgICAgaXRlbXMsXFxuXFx0XFx0XFx0ICAgIHRoYXQgPSB0aGlzLFxcblxcdFxcdFxcdCAgICBpY29uID0gdGhpcy5vcHRpb25zLmljb25zLnN1Ym1lbnUsXFxuXFx0XFx0XFx0ICAgIHN1Ym1lbnVzID0gdGhpcy5lbGVtZW50LmZpbmQodGhpcy5vcHRpb25zLm1lbnVzKTtcXG5cXG5cXHRcXHRcXHR0aGlzLmVsZW1lbnQudG9nZ2xlQ2xhc3MoXFxcInVpLW1lbnUtaWNvbnNcXFwiLCAhIXRoaXMuZWxlbWVudC5maW5kKFxcXCIudWktaWNvblxcXCIpLmxlbmd0aCk7XFxuXFxuXFx0XFx0XFx0Ly8gSW5pdGlhbGl6ZSBuZXN0ZWQgbWVudXNcXG5cXHRcXHRcXHRzdWJtZW51cy5maWx0ZXIoXFxcIjpub3QoLnVpLW1lbnUpXFxcIikuYWRkQ2xhc3MoXFxcInVpLW1lbnUgdWktd2lkZ2V0IHVpLXdpZGdldC1jb250ZW50IHVpLWZyb250XFxcIikuaGlkZSgpLmF0dHIoe1xcblxcdFxcdFxcdFxcdHJvbGU6IHRoaXMub3B0aW9ucy5yb2xlLFxcblxcdFxcdFxcdFxcdFxcXCJhcmlhLWhpZGRlblxcXCI6IFxcXCJ0cnVlXFxcIixcXG5cXHRcXHRcXHRcXHRcXFwiYXJpYS1leHBhbmRlZFxcXCI6IFxcXCJmYWxzZVxcXCJcXG5cXHRcXHRcXHR9KS5lYWNoKGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHR2YXIgbWVudSA9ICQodGhpcyksXFxuXFx0XFx0XFx0XFx0ICAgIGl0ZW0gPSBtZW51LnBhcmVudCgpLFxcblxcdFxcdFxcdFxcdCAgICBzdWJtZW51Q2FyYXQgPSAkKFxcXCI8c3Bhbj5cXFwiKS5hZGRDbGFzcyhcXFwidWktbWVudS1pY29uIHVpLWljb24gXFxcIiArIGljb24pLmRhdGEoXFxcInVpLW1lbnUtc3VibWVudS1jYXJhdFxcXCIsIHRydWUpO1xcblxcblxcdFxcdFxcdFxcdGl0ZW0uYXR0cihcXFwiYXJpYS1oYXNwb3B1cFxcXCIsIFxcXCJ0cnVlXFxcIikucHJlcGVuZChzdWJtZW51Q2FyYXQpO1xcblxcdFxcdFxcdFxcdG1lbnUuYXR0cihcXFwiYXJpYS1sYWJlbGxlZGJ5XFxcIiwgaXRlbS5hdHRyKFxcXCJpZFxcXCIpKTtcXG5cXHRcXHRcXHR9KTtcXG5cXG5cXHRcXHRcXHRtZW51cyA9IHN1Ym1lbnVzLmFkZCh0aGlzLmVsZW1lbnQpO1xcblxcdFxcdFxcdGl0ZW1zID0gbWVudXMuZmluZCh0aGlzLm9wdGlvbnMuaXRlbXMpO1xcblxcblxcdFxcdFxcdC8vIEluaXRpYWxpemUgbWVudS1pdGVtcyBjb250YWluaW5nIHNwYWNlcyBhbmQvb3IgZGFzaGVzIG9ubHkgYXMgZGl2aWRlcnNcXG5cXHRcXHRcXHRpdGVtcy5ub3QoXFxcIi51aS1tZW51LWl0ZW1cXFwiKS5lYWNoKGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHR2YXIgaXRlbSA9ICQodGhpcyk7XFxuXFx0XFx0XFx0XFx0aWYgKHRoYXQuX2lzRGl2aWRlcihpdGVtKSkge1xcblxcdFxcdFxcdFxcdFxcdGl0ZW0uYWRkQ2xhc3MoXFxcInVpLXdpZGdldC1jb250ZW50IHVpLW1lbnUtZGl2aWRlclxcXCIpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9KTtcXG5cXG5cXHRcXHRcXHQvLyBEb24ndCByZWZyZXNoIGxpc3QgaXRlbXMgdGhhdCBhcmUgYWxyZWFkeSBhZGFwdGVkXFxuXFx0XFx0XFx0aXRlbXMubm90KFxcXCIudWktbWVudS1pdGVtLCAudWktbWVudS1kaXZpZGVyXFxcIikuYWRkQ2xhc3MoXFxcInVpLW1lbnUtaXRlbVxcXCIpLnVuaXF1ZUlkKCkuYXR0cih7XFxuXFx0XFx0XFx0XFx0dGFiSW5kZXg6IC0xLFxcblxcdFxcdFxcdFxcdHJvbGU6IHRoaXMuX2l0ZW1Sb2xlKClcXG5cXHRcXHRcXHR9KTtcXG5cXG5cXHRcXHRcXHQvLyBBZGQgYXJpYS1kaXNhYmxlZCBhdHRyaWJ1dGUgdG8gYW55IGRpc2FibGVkIG1lbnUgaXRlbVxcblxcdFxcdFxcdGl0ZW1zLmZpbHRlcihcXFwiLnVpLXN0YXRlLWRpc2FibGVkXFxcIikuYXR0cihcXFwiYXJpYS1kaXNhYmxlZFxcXCIsIFxcXCJ0cnVlXFxcIik7XFxuXFxuXFx0XFx0XFx0Ly8gSWYgdGhlIGFjdGl2ZSBpdGVtIGhhcyBiZWVuIHJlbW92ZWQsIGJsdXIgdGhlIG1lbnVcXG5cXHRcXHRcXHRpZiAodGhpcy5hY3RpdmUgJiYgISQuY29udGFpbnModGhpcy5lbGVtZW50WzBdLCB0aGlzLmFjdGl2ZVswXSkpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLmJsdXIoKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfaXRlbVJvbGU6IGZ1bmN0aW9uIF9pdGVtUm9sZSgpIHtcXG5cXHRcXHRcXHRyZXR1cm4ge1xcblxcdFxcdFxcdFxcdG1lbnU6IFxcXCJtZW51aXRlbVxcXCIsXFxuXFx0XFx0XFx0XFx0bGlzdGJveDogXFxcIm9wdGlvblxcXCJcXG5cXHRcXHRcXHR9W3RoaXMub3B0aW9ucy5yb2xlXTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9zZXRPcHRpb246IGZ1bmN0aW9uIF9zZXRPcHRpb24oa2V5LCB2YWx1ZSkge1xcblxcdFxcdFxcdGlmIChrZXkgPT09IFxcXCJpY29uc1xcXCIpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLmVsZW1lbnQuZmluZChcXFwiLnVpLW1lbnUtaWNvblxcXCIpLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5pY29ucy5zdWJtZW51KS5hZGRDbGFzcyh2YWx1ZS5zdWJtZW51KTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKGtleSA9PT0gXFxcImRpc2FibGVkXFxcIikge1xcblxcdFxcdFxcdFxcdHRoaXMuZWxlbWVudC50b2dnbGVDbGFzcyhcXFwidWktc3RhdGUtZGlzYWJsZWRcXFwiLCAhIXZhbHVlKS5hdHRyKFxcXCJhcmlhLWRpc2FibGVkXFxcIiwgdmFsdWUpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR0aGlzLl9zdXBlcihrZXksIHZhbHVlKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdGZvY3VzOiBmdW5jdGlvbiBmb2N1cyhldmVudCwgaXRlbSkge1xcblxcdFxcdFxcdHZhciBuZXN0ZWQsIGZvY3VzZWQ7XFxuXFx0XFx0XFx0dGhpcy5ibHVyKGV2ZW50LCBldmVudCAmJiBldmVudC50eXBlID09PSBcXFwiZm9jdXNcXFwiKTtcXG5cXG5cXHRcXHRcXHR0aGlzLl9zY3JvbGxJbnRvVmlldyhpdGVtKTtcXG5cXG5cXHRcXHRcXHR0aGlzLmFjdGl2ZSA9IGl0ZW0uZmlyc3QoKTtcXG5cXHRcXHRcXHRmb2N1c2VkID0gdGhpcy5hY3RpdmUuYWRkQ2xhc3MoXFxcInVpLXN0YXRlLWZvY3VzXFxcIikucmVtb3ZlQ2xhc3MoXFxcInVpLXN0YXRlLWFjdGl2ZVxcXCIpO1xcblxcdFxcdFxcdC8vIE9ubHkgdXBkYXRlIGFyaWEtYWN0aXZlZGVzY2VuZGFudCBpZiB0aGVyZSdzIGEgcm9sZVxcblxcdFxcdFxcdC8vIG90aGVyd2lzZSB3ZSBhc3N1bWUgZm9jdXMgaXMgbWFuYWdlZCBlbHNld2hlcmVcXG5cXHRcXHRcXHRpZiAodGhpcy5vcHRpb25zLnJvbGUpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLmVsZW1lbnQuYXR0cihcXFwiYXJpYS1hY3RpdmVkZXNjZW5kYW50XFxcIiwgZm9jdXNlZC5hdHRyKFxcXCJpZFxcXCIpKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gSGlnaGxpZ2h0IGFjdGl2ZSBwYXJlbnQgbWVudSBpdGVtLCBpZiBhbnlcXG5cXHRcXHRcXHR0aGlzLmFjdGl2ZS5wYXJlbnQoKS5jbG9zZXN0KFxcXCIudWktbWVudS1pdGVtXFxcIikuYWRkQ2xhc3MoXFxcInVpLXN0YXRlLWFjdGl2ZVxcXCIpO1xcblxcblxcdFxcdFxcdGlmIChldmVudCAmJiBldmVudC50eXBlID09PSBcXFwia2V5ZG93blxcXCIpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9jbG9zZSgpO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0dGhpcy50aW1lciA9IHRoaXMuX2RlbGF5KGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9jbG9zZSgpO1xcblxcdFxcdFxcdFxcdH0sIHRoaXMuZGVsYXkpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRuZXN0ZWQgPSBpdGVtLmNoaWxkcmVuKFxcXCIudWktbWVudVxcXCIpO1xcblxcdFxcdFxcdGlmIChuZXN0ZWQubGVuZ3RoICYmIGV2ZW50ICYmIC9ebW91c2UvLnRlc3QoZXZlbnQudHlwZSkpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9zdGFydE9wZW5pbmcobmVzdGVkKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0dGhpcy5hY3RpdmVNZW51ID0gaXRlbS5wYXJlbnQoKTtcXG5cXG5cXHRcXHRcXHR0aGlzLl90cmlnZ2VyKFxcXCJmb2N1c1xcXCIsIGV2ZW50LCB7IGl0ZW06IGl0ZW0gfSk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfc2Nyb2xsSW50b1ZpZXc6IGZ1bmN0aW9uIF9zY3JvbGxJbnRvVmlldyhpdGVtKSB7XFxuXFx0XFx0XFx0dmFyIGJvcmRlclRvcCwgcGFkZGluZ1RvcCwgb2Zmc2V0LCBzY3JvbGwsIGVsZW1lbnRIZWlnaHQsIGl0ZW1IZWlnaHQ7XFxuXFx0XFx0XFx0aWYgKHRoaXMuX2hhc1Njcm9sbCgpKSB7XFxuXFx0XFx0XFx0XFx0Ym9yZGVyVG9wID0gcGFyc2VGbG9hdCgkLmNzcyh0aGlzLmFjdGl2ZU1lbnVbMF0sIFxcXCJib3JkZXJUb3BXaWR0aFxcXCIpKSB8fCAwO1xcblxcdFxcdFxcdFxcdHBhZGRpbmdUb3AgPSBwYXJzZUZsb2F0KCQuY3NzKHRoaXMuYWN0aXZlTWVudVswXSwgXFxcInBhZGRpbmdUb3BcXFwiKSkgfHwgMDtcXG5cXHRcXHRcXHRcXHRvZmZzZXQgPSBpdGVtLm9mZnNldCgpLnRvcCAtIHRoaXMuYWN0aXZlTWVudS5vZmZzZXQoKS50b3AgLSBib3JkZXJUb3AgLSBwYWRkaW5nVG9wO1xcblxcdFxcdFxcdFxcdHNjcm9sbCA9IHRoaXMuYWN0aXZlTWVudS5zY3JvbGxUb3AoKTtcXG5cXHRcXHRcXHRcXHRlbGVtZW50SGVpZ2h0ID0gdGhpcy5hY3RpdmVNZW51LmhlaWdodCgpO1xcblxcdFxcdFxcdFxcdGl0ZW1IZWlnaHQgPSBpdGVtLm91dGVySGVpZ2h0KCk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKG9mZnNldCA8IDApIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmFjdGl2ZU1lbnUuc2Nyb2xsVG9wKHNjcm9sbCArIG9mZnNldCk7XFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmIChvZmZzZXQgKyBpdGVtSGVpZ2h0ID4gZWxlbWVudEhlaWdodCkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuYWN0aXZlTWVudS5zY3JvbGxUb3Aoc2Nyb2xsICsgb2Zmc2V0IC0gZWxlbWVudEhlaWdodCArIGl0ZW1IZWlnaHQpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRibHVyOiBmdW5jdGlvbiBibHVyKGV2ZW50LCBmcm9tRm9jdXMpIHtcXG5cXHRcXHRcXHRpZiAoIWZyb21Gb2N1cykge1xcblxcdFxcdFxcdFxcdGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCF0aGlzLmFjdGl2ZSkge1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy5hY3RpdmUucmVtb3ZlQ2xhc3MoXFxcInVpLXN0YXRlLWZvY3VzXFxcIik7XFxuXFx0XFx0XFx0dGhpcy5hY3RpdmUgPSBudWxsO1xcblxcblxcdFxcdFxcdHRoaXMuX3RyaWdnZXIoXFxcImJsdXJcXFwiLCBldmVudCwgeyBpdGVtOiB0aGlzLmFjdGl2ZSB9KTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9zdGFydE9wZW5pbmc6IGZ1bmN0aW9uIF9zdGFydE9wZW5pbmcoc3VibWVudSkge1xcblxcdFxcdFxcdGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcXG5cXG5cXHRcXHRcXHQvLyBEb24ndCBvcGVuIGlmIGFscmVhZHkgb3BlbiBmaXhlcyBhIEZpcmVmb3ggYnVnIHRoYXQgY2F1c2VkIGEgLjUgcGl4ZWxcXG5cXHRcXHRcXHQvLyBzaGlmdCBpbiB0aGUgc3VibWVudSBwb3NpdGlvbiB3aGVuIG1vdXNpbmcgb3ZlciB0aGUgY2FyYXQgaWNvblxcblxcdFxcdFxcdGlmIChzdWJtZW51LmF0dHIoXFxcImFyaWEtaGlkZGVuXFxcIikgIT09IFxcXCJ0cnVlXFxcIikge1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy50aW1lciA9IHRoaXMuX2RlbGF5KGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9jbG9zZSgpO1xcblxcdFxcdFxcdFxcdHRoaXMuX29wZW4oc3VibWVudSk7XFxuXFx0XFx0XFx0fSwgdGhpcy5kZWxheSk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfb3BlbjogZnVuY3Rpb24gX29wZW4oc3VibWVudSkge1xcblxcdFxcdFxcdHZhciBwb3NpdGlvbiA9ICQuZXh0ZW5kKHtcXG5cXHRcXHRcXHRcXHRvZjogdGhpcy5hY3RpdmVcXG5cXHRcXHRcXHR9LCB0aGlzLm9wdGlvbnMucG9zaXRpb24pO1xcblxcblxcdFxcdFxcdGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcXG5cXHRcXHRcXHR0aGlzLmVsZW1lbnQuZmluZChcXFwiLnVpLW1lbnVcXFwiKS5ub3Qoc3VibWVudS5wYXJlbnRzKFxcXCIudWktbWVudVxcXCIpKS5oaWRlKCkuYXR0cihcXFwiYXJpYS1oaWRkZW5cXFwiLCBcXFwidHJ1ZVxcXCIpO1xcblxcblxcdFxcdFxcdHN1Ym1lbnUuc2hvdygpLnJlbW92ZUF0dHIoXFxcImFyaWEtaGlkZGVuXFxcIikuYXR0cihcXFwiYXJpYS1leHBhbmRlZFxcXCIsIFxcXCJ0cnVlXFxcIikucG9zaXRpb24ocG9zaXRpb24pO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y29sbGFwc2VBbGw6IGZ1bmN0aW9uIGNvbGxhcHNlQWxsKGV2ZW50LCBhbGwpIHtcXG5cXHRcXHRcXHRjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XFxuXFx0XFx0XFx0dGhpcy50aW1lciA9IHRoaXMuX2RlbGF5KGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHQvLyBJZiB3ZSB3ZXJlIHBhc3NlZCBhbiBldmVudCwgbG9vayBmb3IgdGhlIHN1Ym1lbnUgdGhhdCBjb250YWlucyB0aGUgZXZlbnRcXG5cXHRcXHRcXHRcXHR2YXIgY3VycmVudE1lbnUgPSBhbGwgPyB0aGlzLmVsZW1lbnQgOiAkKGV2ZW50ICYmIGV2ZW50LnRhcmdldCkuY2xvc2VzdCh0aGlzLmVsZW1lbnQuZmluZChcXFwiLnVpLW1lbnVcXFwiKSk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSWYgd2UgZm91bmQgbm8gdmFsaWQgc3VibWVudSBhbmNlc3RvciwgdXNlIHRoZSBtYWluIG1lbnUgdG8gY2xvc2UgYWxsIHN1YiBtZW51cyBhbnl3YXlcXG5cXHRcXHRcXHRcXHRpZiAoIWN1cnJlbnRNZW51Lmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdFxcdGN1cnJlbnRNZW51ID0gdGhpcy5lbGVtZW50O1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR0aGlzLl9jbG9zZShjdXJyZW50TWVudSk7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5ibHVyKGV2ZW50KTtcXG5cXHRcXHRcXHRcXHR0aGlzLmFjdGl2ZU1lbnUgPSBjdXJyZW50TWVudTtcXG5cXHRcXHRcXHR9LCB0aGlzLmRlbGF5KTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdC8vIFdpdGggbm8gYXJndW1lbnRzLCBjbG9zZXMgdGhlIGN1cnJlbnRseSBhY3RpdmUgbWVudSAtIGlmIG5vdGhpbmcgaXMgYWN0aXZlXFxuXFx0XFx0Ly8gaXQgY2xvc2VzIGFsbCBtZW51cy4gIElmIHBhc3NlZCBhbiBhcmd1bWVudCwgaXQgd2lsbCBzZWFyY2ggZm9yIG1lbnVzIEJFTE9XXFxuXFx0XFx0X2Nsb3NlOiBmdW5jdGlvbiBfY2xvc2Uoc3RhcnRNZW51KSB7XFxuXFx0XFx0XFx0aWYgKCFzdGFydE1lbnUpIHtcXG5cXHRcXHRcXHRcXHRzdGFydE1lbnUgPSB0aGlzLmFjdGl2ZSA/IHRoaXMuYWN0aXZlLnBhcmVudCgpIDogdGhpcy5lbGVtZW50O1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRzdGFydE1lbnUuZmluZChcXFwiLnVpLW1lbnVcXFwiKS5oaWRlKCkuYXR0cihcXFwiYXJpYS1oaWRkZW5cXFwiLCBcXFwidHJ1ZVxcXCIpLmF0dHIoXFxcImFyaWEtZXhwYW5kZWRcXFwiLCBcXFwiZmFsc2VcXFwiKS5lbmQoKS5maW5kKFxcXCIudWktc3RhdGUtYWN0aXZlXFxcIikubm90KFxcXCIudWktc3RhdGUtZm9jdXNcXFwiKS5yZW1vdmVDbGFzcyhcXFwidWktc3RhdGUtYWN0aXZlXFxcIik7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfY2xvc2VPbkRvY3VtZW50Q2xpY2s6IGZ1bmN0aW9uIF9jbG9zZU9uRG9jdW1lbnRDbGljayhldmVudCkge1xcblxcdFxcdFxcdHJldHVybiAhJChldmVudC50YXJnZXQpLmNsb3Nlc3QoXFxcIi51aS1tZW51XFxcIikubGVuZ3RoO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X2lzRGl2aWRlcjogZnVuY3Rpb24gX2lzRGl2aWRlcihpdGVtKSB7XFxuXFxuXFx0XFx0XFx0Ly8gTWF0Y2ggaHlwaGVuLCBlbSBkYXNoLCBlbiBkYXNoXFxuXFx0XFx0XFx0cmV0dXJuICEvW15cXFxcLVxcXFx1MjAxNFxcXFx1MjAxM1xcXFxzXS8udGVzdChpdGVtLnRleHQoKSk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjb2xsYXBzZTogZnVuY3Rpb24gY29sbGFwc2UoZXZlbnQpIHtcXG5cXHRcXHRcXHR2YXIgbmV3SXRlbSA9IHRoaXMuYWN0aXZlICYmIHRoaXMuYWN0aXZlLnBhcmVudCgpLmNsb3Nlc3QoXFxcIi51aS1tZW51LWl0ZW1cXFwiLCB0aGlzLmVsZW1lbnQpO1xcblxcdFxcdFxcdGlmIChuZXdJdGVtICYmIG5ld0l0ZW0ubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5fY2xvc2UoKTtcXG5cXHRcXHRcXHRcXHR0aGlzLmZvY3VzKGV2ZW50LCBuZXdJdGVtKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRleHBhbmQ6IGZ1bmN0aW9uIGV4cGFuZChldmVudCkge1xcblxcdFxcdFxcdHZhciBuZXdJdGVtID0gdGhpcy5hY3RpdmUgJiYgdGhpcy5hY3RpdmUuY2hpbGRyZW4oXFxcIi51aS1tZW51IFxcXCIpLmZpbmQodGhpcy5vcHRpb25zLml0ZW1zKS5maXJzdCgpO1xcblxcblxcdFxcdFxcdGlmIChuZXdJdGVtICYmIG5ld0l0ZW0ubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5fb3BlbihuZXdJdGVtLnBhcmVudCgpKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBEZWxheSBzbyBGaXJlZm94IHdpbGwgbm90IGhpZGUgYWN0aXZlZGVzY2VuZGFudCBjaGFuZ2UgaW4gZXhwYW5kaW5nIHN1Ym1lbnUgZnJvbSBBVFxcblxcdFxcdFxcdFxcdHRoaXMuX2RlbGF5KGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmZvY3VzKGV2ZW50LCBuZXdJdGVtKTtcXG5cXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRuZXh0OiBmdW5jdGlvbiBuZXh0KGV2ZW50KSB7XFxuXFx0XFx0XFx0dGhpcy5fbW92ZShcXFwibmV4dFxcXCIsIFxcXCJmaXJzdFxcXCIsIGV2ZW50KTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdHByZXZpb3VzOiBmdW5jdGlvbiBwcmV2aW91cyhldmVudCkge1xcblxcdFxcdFxcdHRoaXMuX21vdmUoXFxcInByZXZcXFwiLCBcXFwibGFzdFxcXCIsIGV2ZW50KTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdGlzRmlyc3RJdGVtOiBmdW5jdGlvbiBpc0ZpcnN0SXRlbSgpIHtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5hY3RpdmUgJiYgIXRoaXMuYWN0aXZlLnByZXZBbGwoXFxcIi51aS1tZW51LWl0ZW1cXFwiKS5sZW5ndGg7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRpc0xhc3RJdGVtOiBmdW5jdGlvbiBpc0xhc3RJdGVtKCkge1xcblxcdFxcdFxcdHJldHVybiB0aGlzLmFjdGl2ZSAmJiAhdGhpcy5hY3RpdmUubmV4dEFsbChcXFwiLnVpLW1lbnUtaXRlbVxcXCIpLmxlbmd0aDtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9tb3ZlOiBmdW5jdGlvbiBfbW92ZShkaXJlY3Rpb24sIGZpbHRlciwgZXZlbnQpIHtcXG5cXHRcXHRcXHR2YXIgbmV4dDtcXG5cXHRcXHRcXHRpZiAodGhpcy5hY3RpdmUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZGlyZWN0aW9uID09PSBcXFwiZmlyc3RcXFwiIHx8IGRpcmVjdGlvbiA9PT0gXFxcImxhc3RcXFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0bmV4dCA9IHRoaXMuYWN0aXZlW2RpcmVjdGlvbiA9PT0gXFxcImZpcnN0XFxcIiA/IFxcXCJwcmV2QWxsXFxcIiA6IFxcXCJuZXh0QWxsXFxcIl0oXFxcIi51aS1tZW51LWl0ZW1cXFwiKS5lcSgtMSk7XFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRuZXh0ID0gdGhpcy5hY3RpdmVbZGlyZWN0aW9uICsgXFxcIkFsbFxcXCJdKFxcXCIudWktbWVudS1pdGVtXFxcIikuZXEoMCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoIW5leHQgfHwgIW5leHQubGVuZ3RoIHx8ICF0aGlzLmFjdGl2ZSkge1xcblxcdFxcdFxcdFxcdG5leHQgPSB0aGlzLmFjdGl2ZU1lbnUuZmluZCh0aGlzLm9wdGlvbnMuaXRlbXMpW2ZpbHRlcl0oKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy5mb2N1cyhldmVudCwgbmV4dCk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRuZXh0UGFnZTogZnVuY3Rpb24gbmV4dFBhZ2UoZXZlbnQpIHtcXG5cXHRcXHRcXHR2YXIgaXRlbSwgYmFzZSwgaGVpZ2h0O1xcblxcblxcdFxcdFxcdGlmICghdGhpcy5hY3RpdmUpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLm5leHQoZXZlbnQpO1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKHRoaXMuaXNMYXN0SXRlbSgpKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAodGhpcy5faGFzU2Nyb2xsKCkpIHtcXG5cXHRcXHRcXHRcXHRiYXNlID0gdGhpcy5hY3RpdmUub2Zmc2V0KCkudG9wO1xcblxcdFxcdFxcdFxcdGhlaWdodCA9IHRoaXMuZWxlbWVudC5oZWlnaHQoKTtcXG5cXHRcXHRcXHRcXHR0aGlzLmFjdGl2ZS5uZXh0QWxsKFxcXCIudWktbWVudS1pdGVtXFxcIikuZWFjaChmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0XFx0aXRlbSA9ICQodGhpcyk7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGl0ZW0ub2Zmc2V0KCkudG9wIC0gYmFzZSAtIGhlaWdodCA8IDA7XFxuXFx0XFx0XFx0XFx0fSk7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5mb2N1cyhldmVudCwgaXRlbSk7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHR0aGlzLmZvY3VzKGV2ZW50LCB0aGlzLmFjdGl2ZU1lbnUuZmluZCh0aGlzLm9wdGlvbnMuaXRlbXMpWyF0aGlzLmFjdGl2ZSA/IFxcXCJmaXJzdFxcXCIgOiBcXFwibGFzdFxcXCJdKCkpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcblxcdFxcdHByZXZpb3VzUGFnZTogZnVuY3Rpb24gcHJldmlvdXNQYWdlKGV2ZW50KSB7XFxuXFx0XFx0XFx0dmFyIGl0ZW0sIGJhc2UsIGhlaWdodDtcXG5cXHRcXHRcXHRpZiAoIXRoaXMuYWN0aXZlKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5uZXh0KGV2ZW50KTtcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICh0aGlzLmlzRmlyc3RJdGVtKCkpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICh0aGlzLl9oYXNTY3JvbGwoKSkge1xcblxcdFxcdFxcdFxcdGJhc2UgPSB0aGlzLmFjdGl2ZS5vZmZzZXQoKS50b3A7XFxuXFx0XFx0XFx0XFx0aGVpZ2h0ID0gdGhpcy5lbGVtZW50LmhlaWdodCgpO1xcblxcdFxcdFxcdFxcdHRoaXMuYWN0aXZlLnByZXZBbGwoXFxcIi51aS1tZW51LWl0ZW1cXFwiKS5lYWNoKGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHRpdGVtID0gJCh0aGlzKTtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gaXRlbS5vZmZzZXQoKS50b3AgLSBiYXNlICsgaGVpZ2h0ID4gMDtcXG5cXHRcXHRcXHRcXHR9KTtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLmZvY3VzKGV2ZW50LCBpdGVtKTtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdHRoaXMuZm9jdXMoZXZlbnQsIHRoaXMuYWN0aXZlTWVudS5maW5kKHRoaXMub3B0aW9ucy5pdGVtcykuZmlyc3QoKSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFxuXFx0XFx0X2hhc1Njcm9sbDogZnVuY3Rpb24gX2hhc1Njcm9sbCgpIHtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5lbGVtZW50Lm91dGVySGVpZ2h0KCkgPCB0aGlzLmVsZW1lbnQucHJvcChcXFwic2Nyb2xsSGVpZ2h0XFxcIik7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZWxlY3Q6IGZ1bmN0aW9uIHNlbGVjdChldmVudCkge1xcblxcdFxcdFxcdC8vIFRPRE86IEl0IHNob3VsZCBuZXZlciBiZSBwb3NzaWJsZSB0byBub3QgaGF2ZSBhbiBhY3RpdmUgaXRlbSBhdCB0aGlzXFxuXFx0XFx0XFx0Ly8gcG9pbnQsIGJ1dCB0aGUgdGVzdHMgZG9uJ3QgdHJpZ2dlciBtb3VzZWVudGVyIGJlZm9yZSBjbGljay5cXG5cXHRcXHRcXHR0aGlzLmFjdGl2ZSA9IHRoaXMuYWN0aXZlIHx8ICQoZXZlbnQudGFyZ2V0KS5jbG9zZXN0KFxcXCIudWktbWVudS1pdGVtXFxcIik7XFxuXFx0XFx0XFx0dmFyIHVpID0geyBpdGVtOiB0aGlzLmFjdGl2ZSB9O1xcblxcdFxcdFxcdGlmICghdGhpcy5hY3RpdmUuaGFzKFxcXCIudWktbWVudVxcXCIpLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdHRoaXMuY29sbGFwc2VBbGwoZXZlbnQsIHRydWUpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR0aGlzLl90cmlnZ2VyKFxcXCJzZWxlY3RcXFwiLCBldmVudCwgdWkpO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X2ZpbHRlck1lbnVJdGVtczogZnVuY3Rpb24gX2ZpbHRlck1lbnVJdGVtcyhjaGFyYWN0ZXIpIHtcXG5cXHRcXHRcXHR2YXIgZXNjYXBlZENoYXJhY3RlciA9IGNoYXJhY3Rlci5yZXBsYWNlKC9bXFxcXC1cXFxcW1xcXFxde30oKSorPy4sXFxcXFxcXFxcXFxcXiR8I1xcXFxzXS9nLCBcXFwiXFxcXFxcXFwkJlxcXCIpLFxcblxcdFxcdFxcdCAgICByZWdleCA9IG5ldyBSZWdFeHAoXFxcIl5cXFwiICsgZXNjYXBlZENoYXJhY3RlciwgXFxcImlcXFwiKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5hY3RpdmVNZW51LmZpbmQodGhpcy5vcHRpb25zLml0ZW1zKVxcblxcblxcdFxcdFxcdC8vIE9ubHkgbWF0Y2ggb24gaXRlbXMsIG5vdCBkaXZpZGVycyBvciBvdGhlciBjb250ZW50ICgjMTA1NzEpXFxuXFx0XFx0XFx0LmZpbHRlcihcXFwiLnVpLW1lbnUtaXRlbVxcXCIpLmZpbHRlcihmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHJlZ2V4LnRlc3QoJC50cmltKCQodGhpcykudGV4dCgpKSk7XFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0fVxcblxcdH0pO1xcblxcblxcdC8qIVxcbiAgKiBqUXVlcnkgVUkgQXV0b2NvbXBsZXRlIDEuMTEuNFxcbiAgKiBodHRwOi8vanF1ZXJ5dWkuY29tXFxuICAqXFxuICAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXFxuICAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cXG4gICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxcbiAgKlxcbiAgKiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9hdXRvY29tcGxldGUvXFxuICAqL1xcblxcblxcdCQud2lkZ2V0KFxcXCJ1aS5hdXRvY29tcGxldGVcXFwiLCB7XFxuXFx0XFx0dmVyc2lvbjogXFxcIjEuMTEuNFxcXCIsXFxuXFx0XFx0ZGVmYXVsdEVsZW1lbnQ6IFxcXCI8aW5wdXQ+XFxcIixcXG5cXHRcXHRvcHRpb25zOiB7XFxuXFx0XFx0XFx0YXBwZW5kVG86IG51bGwsXFxuXFx0XFx0XFx0YXV0b0ZvY3VzOiBmYWxzZSxcXG5cXHRcXHRcXHRkZWxheTogMzAwLFxcblxcdFxcdFxcdG1pbkxlbmd0aDogMSxcXG5cXHRcXHRcXHRwb3NpdGlvbjoge1xcblxcdFxcdFxcdFxcdG15OiBcXFwibGVmdCB0b3BcXFwiLFxcblxcdFxcdFxcdFxcdGF0OiBcXFwibGVmdCBib3R0b21cXFwiLFxcblxcdFxcdFxcdFxcdGNvbGxpc2lvbjogXFxcIm5vbmVcXFwiXFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRzb3VyY2U6IG51bGwsXFxuXFxuXFx0XFx0XFx0Ly8gY2FsbGJhY2tzXFxuXFx0XFx0XFx0Y2hhbmdlOiBudWxsLFxcblxcdFxcdFxcdGNsb3NlOiBudWxsLFxcblxcdFxcdFxcdGZvY3VzOiBudWxsLFxcblxcdFxcdFxcdG9wZW46IG51bGwsXFxuXFx0XFx0XFx0cmVzcG9uc2U6IG51bGwsXFxuXFx0XFx0XFx0c2VhcmNoOiBudWxsLFxcblxcdFxcdFxcdHNlbGVjdDogbnVsbFxcblxcdFxcdH0sXFxuXFxuXFx0XFx0cmVxdWVzdEluZGV4OiAwLFxcblxcdFxcdHBlbmRpbmc6IDAsXFxuXFxuXFx0XFx0X2NyZWF0ZTogZnVuY3Rpb24gX2NyZWF0ZSgpIHtcXG5cXHRcXHRcXHQvLyBTb21lIGJyb3dzZXJzIG9ubHkgcmVwZWF0IGtleWRvd24gZXZlbnRzLCBub3Qga2V5cHJlc3MgZXZlbnRzLFxcblxcdFxcdFxcdC8vIHNvIHdlIHVzZSB0aGUgc3VwcHJlc3NLZXlQcmVzcyBmbGFnIHRvIGRldGVybWluZSBpZiB3ZSd2ZSBhbHJlYWR5XFxuXFx0XFx0XFx0Ly8gaGFuZGxlZCB0aGUga2V5ZG93biBldmVudC4gIzcyNjlcXG5cXHRcXHRcXHQvLyBVbmZvcnR1bmF0ZWx5IHRoZSBjb2RlIGZvciAmIGluIGtleXByZXNzIGlzIHRoZSBzYW1lIGFzIHRoZSB1cCBhcnJvdyxcXG5cXHRcXHRcXHQvLyBzbyB3ZSB1c2UgdGhlIHN1cHByZXNzS2V5UHJlc3NSZXBlYXQgZmxhZyB0byBhdm9pZCBoYW5kbGluZyBrZXlwcmVzc1xcblxcdFxcdFxcdC8vIGV2ZW50cyB3aGVuIHdlIGtub3cgdGhlIGtleWRvd24gZXZlbnQgd2FzIHVzZWQgdG8gbW9kaWZ5IHRoZVxcblxcdFxcdFxcdC8vIHNlYXJjaCB0ZXJtLiAjNzc5OVxcblxcdFxcdFxcdHZhciBzdXBwcmVzc0tleVByZXNzLFxcblxcdFxcdFxcdCAgICBzdXBwcmVzc0tleVByZXNzUmVwZWF0LFxcblxcdFxcdFxcdCAgICBzdXBwcmVzc0lucHV0LFxcblxcdFxcdFxcdCAgICBub2RlTmFtZSA9IHRoaXMuZWxlbWVudFswXS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxcblxcdFxcdFxcdCAgICBpc1RleHRhcmVhID0gbm9kZU5hbWUgPT09IFxcXCJ0ZXh0YXJlYVxcXCIsXFxuXFx0XFx0XFx0ICAgIGlzSW5wdXQgPSBub2RlTmFtZSA9PT0gXFxcImlucHV0XFxcIjtcXG5cXG5cXHRcXHRcXHR0aGlzLmlzTXVsdGlMaW5lID1cXG5cXHRcXHRcXHQvLyBUZXh0YXJlYXMgYXJlIGFsd2F5cyBtdWx0aS1saW5lXFxuXFx0XFx0XFx0aXNUZXh0YXJlYSA/IHRydWUgOlxcblxcdFxcdFxcdC8vIElucHV0cyBhcmUgYWx3YXlzIHNpbmdsZS1saW5lLCBldmVuIGlmIGluc2lkZSBhIGNvbnRlbnRFZGl0YWJsZSBlbGVtZW50XFxuXFx0XFx0XFx0Ly8gSUUgYWxzbyB0cmVhdHMgaW5wdXRzIGFzIGNvbnRlbnRFZGl0YWJsZVxcblxcdFxcdFxcdGlzSW5wdXQgPyBmYWxzZSA6XFxuXFx0XFx0XFx0Ly8gQWxsIG90aGVyIGVsZW1lbnQgdHlwZXMgYXJlIGRldGVybWluZWQgYnkgd2hldGhlciBvciBub3QgdGhleSdyZSBjb250ZW50RWRpdGFibGVcXG5cXHRcXHRcXHR0aGlzLmVsZW1lbnQucHJvcChcXFwiaXNDb250ZW50RWRpdGFibGVcXFwiKTtcXG5cXG5cXHRcXHRcXHR0aGlzLnZhbHVlTWV0aG9kID0gdGhpcy5lbGVtZW50W2lzVGV4dGFyZWEgfHwgaXNJbnB1dCA/IFxcXCJ2YWxcXFwiIDogXFxcInRleHRcXFwiXTtcXG5cXHRcXHRcXHR0aGlzLmlzTmV3TWVudSA9IHRydWU7XFxuXFxuXFx0XFx0XFx0dGhpcy5lbGVtZW50LmFkZENsYXNzKFxcXCJ1aS1hdXRvY29tcGxldGUtaW5wdXRcXFwiKS5hdHRyKFxcXCJhdXRvY29tcGxldGVcXFwiLCBcXFwib2ZmXFxcIik7XFxuXFxuXFx0XFx0XFx0dGhpcy5fb24odGhpcy5lbGVtZW50LCB7XFxuXFx0XFx0XFx0XFx0a2V5ZG93bjogZnVuY3Rpb24ga2V5ZG93bihldmVudCkge1xcblxcdFxcdFxcdFxcdFxcdGlmICh0aGlzLmVsZW1lbnQucHJvcChcXFwicmVhZE9ubHlcXFwiKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHN1cHByZXNzS2V5UHJlc3MgPSB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdFxcdHN1cHByZXNzSW5wdXQgPSB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdFxcdHN1cHByZXNzS2V5UHJlc3NSZXBlYXQgPSB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0c3VwcHJlc3NLZXlQcmVzcyA9IGZhbHNlO1xcblxcdFxcdFxcdFxcdFxcdHN1cHByZXNzSW5wdXQgPSBmYWxzZTtcXG5cXHRcXHRcXHRcXHRcXHRzdXBwcmVzc0tleVByZXNzUmVwZWF0ID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGtleUNvZGUgPSAkLnVpLmtleUNvZGU7XFxuXFx0XFx0XFx0XFx0XFx0c3dpdGNoIChldmVudC5rZXlDb2RlKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSBrZXlDb2RlLlBBR0VfVVA6XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c3VwcHJlc3NLZXlQcmVzcyA9IHRydWU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5fbW92ZShcXFwicHJldmlvdXNQYWdlXFxcIiwgZXZlbnQpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2Uga2V5Q29kZS5QQUdFX0RPV046XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c3VwcHJlc3NLZXlQcmVzcyA9IHRydWU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5fbW92ZShcXFwibmV4dFBhZ2VcXFwiLCBldmVudCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSBrZXlDb2RlLlVQOlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHN1cHByZXNzS2V5UHJlc3MgPSB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuX2tleUV2ZW50KFxcXCJwcmV2aW91c1xcXCIsIGV2ZW50KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlIGtleUNvZGUuRE9XTjpcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzdXBwcmVzc0tleVByZXNzID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl9rZXlFdmVudChcXFwibmV4dFxcXCIsIGV2ZW50KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlIGtleUNvZGUuRU5URVI6XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gd2hlbiBtZW51IGlzIG9wZW4gYW5kIGhhcyBmb2N1c1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICh0aGlzLm1lbnUuYWN0aXZlKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gIzYwNTUgLSBPcGVyYSBzdGlsbCBhbGxvd3MgdGhlIGtleXByZXNzIHRvIG9jY3VyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gd2hpY2ggY2F1c2VzIGZvcm1zIHRvIHN1Ym1pdFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHN1cHByZXNzS2V5UHJlc3MgPSB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5tZW51LnNlbGVjdChldmVudCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2Uga2V5Q29kZS5UQUI6XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKHRoaXMubWVudS5hY3RpdmUpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLm1lbnUuc2VsZWN0KGV2ZW50KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSBrZXlDb2RlLkVTQ0FQRTpcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAodGhpcy5tZW51LmVsZW1lbnQuaXMoXFxcIjp2aXNpYmxlXFxcIikpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIXRoaXMuaXNNdWx0aUxpbmUpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl92YWx1ZSh0aGlzLnRlcm0pO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLmNsb3NlKGV2ZW50KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBEaWZmZXJlbnQgYnJvd3NlcnMgaGF2ZSBkaWZmZXJlbnQgZGVmYXVsdCBiZWhhdmlvciBmb3IgZXNjYXBlXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gU2luZ2xlIHByZXNzIGNhbiBtZWFuIHVuZG8gb3IgY2xlYXJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBEb3VibGUgcHJlc3MgaW4gSUUgbWVhbnMgY2xlYXIgdGhlIHdob2xlIGZvcm1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRkZWZhdWx0OlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHN1cHByZXNzS2V5UHJlc3NSZXBlYXQgPSB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIHNlYXJjaCB0aW1lb3V0IHNob3VsZCBiZSB0cmlnZ2VyZWQgYmVmb3JlIHRoZSBpbnB1dCB2YWx1ZSBpcyBjaGFuZ2VkXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5fc2VhcmNoVGltZW91dChldmVudCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0XFx0a2V5cHJlc3M6IGZ1bmN0aW9uIGtleXByZXNzKGV2ZW50KSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHN1cHByZXNzS2V5UHJlc3MpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzdXBwcmVzc0tleVByZXNzID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCF0aGlzLmlzTXVsdGlMaW5lIHx8IHRoaXMubWVudS5lbGVtZW50LmlzKFxcXCI6dmlzaWJsZVxcXCIpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRpZiAoc3VwcHJlc3NLZXlQcmVzc1JlcGVhdCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gcmVwbGljYXRlIHNvbWUga2V5IGhhbmRsZXJzIHRvIGFsbG93IHRoZW0gdG8gcmVwZWF0IGluIEZpcmVmb3ggYW5kIE9wZXJhXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGtleUNvZGUgPSAkLnVpLmtleUNvZGU7XFxuXFx0XFx0XFx0XFx0XFx0c3dpdGNoIChldmVudC5rZXlDb2RlKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSBrZXlDb2RlLlBBR0VfVVA6XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5fbW92ZShcXFwicHJldmlvdXNQYWdlXFxcIiwgZXZlbnQpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2Uga2V5Q29kZS5QQUdFX0RPV046XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5fbW92ZShcXFwibmV4dFBhZ2VcXFwiLCBldmVudCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSBrZXlDb2RlLlVQOlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuX2tleUV2ZW50KFxcXCJwcmV2aW91c1xcXCIsIGV2ZW50KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlIGtleUNvZGUuRE9XTjpcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl9rZXlFdmVudChcXFwibmV4dFxcXCIsIGV2ZW50KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRcXHRpbnB1dDogZnVuY3Rpb24gaW5wdXQoZXZlbnQpIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoc3VwcHJlc3NJbnB1dCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHN1cHByZXNzSW5wdXQgPSBmYWxzZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fc2VhcmNoVGltZW91dChldmVudCk7XFxuXFx0XFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRcXHRmb2N1czogZnVuY3Rpb24gZm9jdXMoKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5zZWxlY3RlZEl0ZW0gPSBudWxsO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMucHJldmlvdXMgPSB0aGlzLl92YWx1ZSgpO1xcblxcdFxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0XFx0Ymx1cjogZnVuY3Rpb24gYmx1cihldmVudCkge1xcblxcdFxcdFxcdFxcdFxcdGlmICh0aGlzLmNhbmNlbEJsdXIpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRkZWxldGUgdGhpcy5jYW5jZWxCbHVyO1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y2xlYXJUaW1lb3V0KHRoaXMuc2VhcmNoaW5nKTtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmNsb3NlKGV2ZW50KTtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9jaGFuZ2UoZXZlbnQpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9KTtcXG5cXG5cXHRcXHRcXHR0aGlzLl9pbml0U291cmNlKCk7XFxuXFx0XFx0XFx0dGhpcy5tZW51ID0gJChcXFwiPHVsPlxcXCIpLmFkZENsYXNzKFxcXCJ1aS1hdXRvY29tcGxldGUgdWktZnJvbnRcXFwiKS5hcHBlbmRUbyh0aGlzLl9hcHBlbmRUbygpKS5tZW51KHtcXG5cXHRcXHRcXHRcXHQvLyBkaXNhYmxlIEFSSUEgc3VwcG9ydCwgdGhlIGxpdmUgcmVnaW9uIHRha2VzIGNhcmUgb2YgdGhhdFxcblxcdFxcdFxcdFxcdHJvbGU6IG51bGxcXG5cXHRcXHRcXHR9KS5oaWRlKCkubWVudShcXFwiaW5zdGFuY2VcXFwiKTtcXG5cXG5cXHRcXHRcXHR0aGlzLl9vbih0aGlzLm1lbnUuZWxlbWVudCwge1xcblxcdFxcdFxcdFxcdG1vdXNlZG93bjogZnVuY3Rpb24gbW91c2Vkb3duKGV2ZW50KSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gcHJldmVudCBtb3ZpbmcgZm9jdXMgb3V0IG9mIHRoZSB0ZXh0IGZpZWxkXFxuXFx0XFx0XFx0XFx0XFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBJRSBkb2Vzbid0IHByZXZlbnQgbW92aW5nIGZvY3VzIGV2ZW4gd2l0aCBldmVudC5wcmV2ZW50RGVmYXVsdCgpXFxuXFx0XFx0XFx0XFx0XFx0Ly8gc28gd2Ugc2V0IGEgZmxhZyB0byBrbm93IHdoZW4gd2Ugc2hvdWxkIGlnbm9yZSB0aGUgYmx1ciBldmVudFxcblxcdFxcdFxcdFxcdFxcdHRoaXMuY2FuY2VsQmx1ciA9IHRydWU7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fZGVsYXkoZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGRlbGV0ZSB0aGlzLmNhbmNlbEJsdXI7XFxuXFx0XFx0XFx0XFx0XFx0fSk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gY2xpY2tpbmcgb24gdGhlIHNjcm9sbGJhciBjYXVzZXMgZm9jdXMgdG8gc2hpZnQgdG8gdGhlIGJvZHlcXG5cXHRcXHRcXHRcXHRcXHQvLyBidXQgd2UgY2FuJ3QgZGV0ZWN0IGEgbW91c2V1cCBvciBhIGNsaWNrIGltbWVkaWF0ZWx5IGFmdGVyd2FyZFxcblxcdFxcdFxcdFxcdFxcdC8vIHNvIHdlIGhhdmUgdG8gdHJhY2sgdGhlIG5leHQgbW91c2Vkb3duIGFuZCBjbG9zZSB0aGUgbWVudSBpZlxcblxcdFxcdFxcdFxcdFxcdC8vIHRoZSB1c2VyIGNsaWNrcyBzb21ld2hlcmUgb3V0c2lkZSBvZiB0aGUgYXV0b2NvbXBsZXRlXFxuXFx0XFx0XFx0XFx0XFx0dmFyIG1lbnVFbGVtZW50ID0gdGhpcy5tZW51LmVsZW1lbnRbMF07XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCEkKGV2ZW50LnRhcmdldCkuY2xvc2VzdChcXFwiLnVpLW1lbnUtaXRlbVxcXCIpLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuX2RlbGF5KGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgdGhhdCA9IHRoaXM7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5kb2N1bWVudC5vbmUoXFxcIm1vdXNlZG93blxcXCIsIGZ1bmN0aW9uIChldmVudCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChldmVudC50YXJnZXQgIT09IHRoYXQuZWxlbWVudFswXSAmJiBldmVudC50YXJnZXQgIT09IG1lbnVFbGVtZW50ICYmICEkLmNvbnRhaW5zKG1lbnVFbGVtZW50LCBldmVudC50YXJnZXQpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhhdC5jbG9zZSgpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRcXHRtZW51Zm9jdXM6IGZ1bmN0aW9uIG1lbnVmb2N1cyhldmVudCwgdWkpIHtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgbGFiZWwsIGl0ZW07XFxuXFx0XFx0XFx0XFx0XFx0Ly8gc3VwcG9ydDogRmlyZWZveFxcblxcdFxcdFxcdFxcdFxcdC8vIFByZXZlbnQgYWNjaWRlbnRhbCBhY3RpdmF0aW9uIG9mIG1lbnUgaXRlbXMgaW4gRmlyZWZveCAoIzcwMjQgIzkxMTgpXFxuXFx0XFx0XFx0XFx0XFx0aWYgKHRoaXMuaXNOZXdNZW51KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5pc05ld01lbnUgPSBmYWxzZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoZXZlbnQub3JpZ2luYWxFdmVudCAmJiAvXm1vdXNlLy50ZXN0KGV2ZW50Lm9yaWdpbmFsRXZlbnQudHlwZSkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLm1lbnUuYmx1cigpO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuZG9jdW1lbnQub25lKFxcXCJtb3VzZW1vdmVcXFwiLCBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0JChldmVudC50YXJnZXQpLnRyaWdnZXIoZXZlbnQub3JpZ2luYWxFdmVudCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fSk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0aXRlbSA9IHVpLml0ZW0uZGF0YShcXFwidWktYXV0b2NvbXBsZXRlLWl0ZW1cXFwiKTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoZmFsc2UgIT09IHRoaXMuX3RyaWdnZXIoXFxcImZvY3VzXFxcIiwgZXZlbnQsIHsgaXRlbTogaXRlbSB9KSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdC8vIHVzZSB2YWx1ZSB0byBtYXRjaCB3aGF0IHdpbGwgZW5kIHVwIGluIHRoZSBpbnB1dCwgaWYgaXQgd2FzIGEga2V5IGV2ZW50XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKGV2ZW50Lm9yaWdpbmFsRXZlbnQgJiYgL15rZXkvLnRlc3QoZXZlbnQub3JpZ2luYWxFdmVudC50eXBlKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuX3ZhbHVlKGl0ZW0udmFsdWUpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gQW5ub3VuY2UgdGhlIHZhbHVlIGluIHRoZSBsaXZlUmVnaW9uXFxuXFx0XFx0XFx0XFx0XFx0bGFiZWwgPSB1aS5pdGVtLmF0dHIoXFxcImFyaWEtbGFiZWxcXFwiKSB8fCBpdGVtLnZhbHVlO1xcblxcdFxcdFxcdFxcdFxcdGlmIChsYWJlbCAmJiAkLnRyaW0obGFiZWwpLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMubGl2ZVJlZ2lvbi5jaGlsZHJlbigpLmhpZGUoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHQkKFxcXCI8ZGl2PlxcXCIpLnRleHQobGFiZWwpLmFwcGVuZFRvKHRoaXMubGl2ZVJlZ2lvbik7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0XFx0bWVudXNlbGVjdDogZnVuY3Rpb24gbWVudXNlbGVjdChldmVudCwgdWkpIHtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgaXRlbSA9IHVpLml0ZW0uZGF0YShcXFwidWktYXV0b2NvbXBsZXRlLWl0ZW1cXFwiKSxcXG5cXHRcXHRcXHRcXHRcXHQgICAgcHJldmlvdXMgPSB0aGlzLnByZXZpb3VzO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIG9ubHkgdHJpZ2dlciB3aGVuIGZvY3VzIHdhcyBsb3N0IChjbGljayBvbiBtZW51KVxcblxcdFxcdFxcdFxcdFxcdGlmICh0aGlzLmVsZW1lbnRbMF0gIT09IHRoaXMuZG9jdW1lbnRbMF0uYWN0aXZlRWxlbWVudCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuZWxlbWVudC5mb2N1cygpO1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMucHJldmlvdXMgPSBwcmV2aW91cztcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyAjNjEwOSAtIElFIHRyaWdnZXJzIHR3byBmb2N1cyBldmVudHMgYW5kIHRoZSBzZWNvbmRcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBpcyBhc3luY2hyb25vdXMsIHNvIHdlIG5lZWQgdG8gcmVzZXQgdGhlIHByZXZpb3VzXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gdGVybSBzeW5jaHJvbm91c2x5IGFuZCBhc3luY2hyb25vdXNseSA6LShcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl9kZWxheShmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5wcmV2aW91cyA9IHByZXZpb3VzO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuc2VsZWN0ZWRJdGVtID0gaXRlbTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKGZhbHNlICE9PSB0aGlzLl90cmlnZ2VyKFxcXCJzZWxlY3RcXFwiLCBldmVudCwgeyBpdGVtOiBpdGVtIH0pKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5fdmFsdWUoaXRlbS52YWx1ZSk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdC8vIHJlc2V0IHRoZSB0ZXJtIGFmdGVyIHRoZSBzZWxlY3QgZXZlbnRcXG5cXHRcXHRcXHRcXHRcXHQvLyB0aGlzIGFsbG93cyBjdXN0b20gc2VsZWN0IGhhbmRsaW5nIHRvIHdvcmsgcHJvcGVybHlcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnRlcm0gPSB0aGlzLl92YWx1ZSgpO1xcblxcblxcdFxcdFxcdFxcdFxcdHRoaXMuY2xvc2UoZXZlbnQpO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuc2VsZWN0ZWRJdGVtID0gaXRlbTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSk7XFxuXFxuXFx0XFx0XFx0dGhpcy5saXZlUmVnaW9uID0gJChcXFwiPHNwYW4+XFxcIiwge1xcblxcdFxcdFxcdFxcdHJvbGU6IFxcXCJzdGF0dXNcXFwiLFxcblxcdFxcdFxcdFxcdFxcXCJhcmlhLWxpdmVcXFwiOiBcXFwiYXNzZXJ0aXZlXFxcIixcXG5cXHRcXHRcXHRcXHRcXFwiYXJpYS1yZWxldmFudFxcXCI6IFxcXCJhZGRpdGlvbnNcXFwiXFxuXFx0XFx0XFx0fSkuYWRkQ2xhc3MoXFxcInVpLWhlbHBlci1oaWRkZW4tYWNjZXNzaWJsZVxcXCIpLmFwcGVuZFRvKHRoaXMuZG9jdW1lbnRbMF0uYm9keSk7XFxuXFxuXFx0XFx0XFx0Ly8gdHVybmluZyBvZmYgYXV0b2NvbXBsZXRlIHByZXZlbnRzIHRoZSBicm93c2VyIGZyb20gcmVtZW1iZXJpbmcgdGhlXFxuXFx0XFx0XFx0Ly8gdmFsdWUgd2hlbiBuYXZpZ2F0aW5nIHRocm91Z2ggaGlzdG9yeSwgc28gd2UgcmUtZW5hYmxlIGF1dG9jb21wbGV0ZVxcblxcdFxcdFxcdC8vIGlmIHRoZSBwYWdlIGlzIHVubG9hZGVkIGJlZm9yZSB0aGUgd2lkZ2V0IGlzIGRlc3Ryb3llZC4gIzc3OTBcXG5cXHRcXHRcXHR0aGlzLl9vbih0aGlzLndpbmRvdywge1xcblxcdFxcdFxcdFxcdGJlZm9yZXVubG9hZDogZnVuY3Rpb24gYmVmb3JldW5sb2FkKCkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuZWxlbWVudC5yZW1vdmVBdHRyKFxcXCJhdXRvY29tcGxldGVcXFwiKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfZGVzdHJveTogZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XFxuXFx0XFx0XFx0Y2xlYXJUaW1lb3V0KHRoaXMuc2VhcmNoaW5nKTtcXG5cXHRcXHRcXHR0aGlzLmVsZW1lbnQucmVtb3ZlQ2xhc3MoXFxcInVpLWF1dG9jb21wbGV0ZS1pbnB1dFxcXCIpLnJlbW92ZUF0dHIoXFxcImF1dG9jb21wbGV0ZVxcXCIpO1xcblxcdFxcdFxcdHRoaXMubWVudS5lbGVtZW50LnJlbW92ZSgpO1xcblxcdFxcdFxcdHRoaXMubGl2ZVJlZ2lvbi5yZW1vdmUoKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9zZXRPcHRpb246IGZ1bmN0aW9uIF9zZXRPcHRpb24oa2V5LCB2YWx1ZSkge1xcblxcdFxcdFxcdHRoaXMuX3N1cGVyKGtleSwgdmFsdWUpO1xcblxcdFxcdFxcdGlmIChrZXkgPT09IFxcXCJzb3VyY2VcXFwiKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5faW5pdFNvdXJjZSgpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoa2V5ID09PSBcXFwiYXBwZW5kVG9cXFwiKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5tZW51LmVsZW1lbnQuYXBwZW5kVG8odGhpcy5fYXBwZW5kVG8oKSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmIChrZXkgPT09IFxcXCJkaXNhYmxlZFxcXCIgJiYgdmFsdWUgJiYgdGhpcy54aHIpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLnhoci5hYm9ydCgpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcblxcdFxcdF9hcHBlbmRUbzogZnVuY3Rpb24gX2FwcGVuZFRvKCkge1xcblxcdFxcdFxcdHZhciBlbGVtZW50ID0gdGhpcy5vcHRpb25zLmFwcGVuZFRvO1xcblxcblxcdFxcdFxcdGlmIChlbGVtZW50KSB7XFxuXFx0XFx0XFx0XFx0ZWxlbWVudCA9IGVsZW1lbnQuanF1ZXJ5IHx8IGVsZW1lbnQubm9kZVR5cGUgPyAkKGVsZW1lbnQpIDogdGhpcy5kb2N1bWVudC5maW5kKGVsZW1lbnQpLmVxKDApO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIWVsZW1lbnQgfHwgIWVsZW1lbnRbMF0pIHtcXG5cXHRcXHRcXHRcXHRlbGVtZW50ID0gdGhpcy5lbGVtZW50LmNsb3Nlc3QoXFxcIi51aS1mcm9udFxcXCIpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIWVsZW1lbnQubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0ZWxlbWVudCA9IHRoaXMuZG9jdW1lbnRbMF0uYm9keTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGVsZW1lbnQ7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfaW5pdFNvdXJjZTogZnVuY3Rpb24gX2luaXRTb3VyY2UoKSB7XFxuXFx0XFx0XFx0dmFyIGFycmF5LFxcblxcdFxcdFxcdCAgICB1cmwsXFxuXFx0XFx0XFx0ICAgIHRoYXQgPSB0aGlzO1xcblxcdFxcdFxcdGlmICgkLmlzQXJyYXkodGhpcy5vcHRpb25zLnNvdXJjZSkpIHtcXG5cXHRcXHRcXHRcXHRhcnJheSA9IHRoaXMub3B0aW9ucy5zb3VyY2U7XFxuXFx0XFx0XFx0XFx0dGhpcy5zb3VyY2UgPSBmdW5jdGlvbiAocmVxdWVzdCwgcmVzcG9uc2UpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXNwb25zZSgkLnVpLmF1dG9jb21wbGV0ZS5maWx0ZXIoYXJyYXksIHJlcXVlc3QudGVybSkpO1xcblxcdFxcdFxcdFxcdH07XFxuXFx0XFx0XFx0fSBlbHNlIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLnNvdXJjZSA9PT0gXFxcInN0cmluZ1xcXCIpIHtcXG5cXHRcXHRcXHRcXHR1cmwgPSB0aGlzLm9wdGlvbnMuc291cmNlO1xcblxcdFxcdFxcdFxcdHRoaXMuc291cmNlID0gZnVuY3Rpb24gKHJlcXVlc3QsIHJlc3BvbnNlKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHRoYXQueGhyKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhhdC54aHIuYWJvcnQoKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0dGhhdC54aHIgPSAkLmFqYXgoe1xcblxcdFxcdFxcdFxcdFxcdFxcdHVybDogdXJsLFxcblxcdFxcdFxcdFxcdFxcdFxcdGRhdGE6IHJlcXVlc3QsXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZGF0YVR5cGU6IFxcXCJqc29uXFxcIixcXG5cXHRcXHRcXHRcXHRcXHRcXHRzdWNjZXNzOiBmdW5jdGlvbiBzdWNjZXNzKGRhdGEpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXNwb25zZShkYXRhKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9LFxcblxcdFxcdFxcdFxcdFxcdFxcdGVycm9yOiBmdW5jdGlvbiBlcnJvcigpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXNwb25zZShbXSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdFxcdH07XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHR0aGlzLnNvdXJjZSA9IHRoaXMub3B0aW9ucy5zb3VyY2U7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFxuXFx0XFx0X3NlYXJjaFRpbWVvdXQ6IGZ1bmN0aW9uIF9zZWFyY2hUaW1lb3V0KGV2ZW50KSB7XFxuXFx0XFx0XFx0Y2xlYXJUaW1lb3V0KHRoaXMuc2VhcmNoaW5nKTtcXG5cXHRcXHRcXHR0aGlzLnNlYXJjaGluZyA9IHRoaXMuX2RlbGF5KGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBTZWFyY2ggaWYgdGhlIHZhbHVlIGhhcyBjaGFuZ2VkLCBvciBpZiB0aGUgdXNlciByZXR5cGVzIHRoZSBzYW1lIHZhbHVlIChzZWUgIzc0MzQpXFxuXFx0XFx0XFx0XFx0dmFyIGVxdWFsVmFsdWVzID0gdGhpcy50ZXJtID09PSB0aGlzLl92YWx1ZSgpLFxcblxcdFxcdFxcdFxcdCAgICBtZW51VmlzaWJsZSA9IHRoaXMubWVudS5lbGVtZW50LmlzKFxcXCI6dmlzaWJsZVxcXCIpLFxcblxcdFxcdFxcdFxcdCAgICBtb2RpZmllcktleSA9IGV2ZW50LmFsdEtleSB8fCBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuc2hpZnRLZXk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCFlcXVhbFZhbHVlcyB8fCBlcXVhbFZhbHVlcyAmJiAhbWVudVZpc2libGUgJiYgIW1vZGlmaWVyS2V5KSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5zZWxlY3RlZEl0ZW0gPSBudWxsO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuc2VhcmNoKG51bGwsIGV2ZW50KTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSwgdGhpcy5vcHRpb25zLmRlbGF5KTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdHNlYXJjaDogZnVuY3Rpb24gc2VhcmNoKHZhbHVlLCBldmVudCkge1xcblxcdFxcdFxcdHZhbHVlID0gdmFsdWUgIT0gbnVsbCA/IHZhbHVlIDogdGhpcy5fdmFsdWUoKTtcXG5cXG5cXHRcXHRcXHQvLyBhbHdheXMgc2F2ZSB0aGUgYWN0dWFsIHZhbHVlLCBub3QgdGhlIG9uZSBwYXNzZWQgYXMgYW4gYXJndW1lbnRcXG5cXHRcXHRcXHR0aGlzLnRlcm0gPSB0aGlzLl92YWx1ZSgpO1xcblxcblxcdFxcdFxcdGlmICh2YWx1ZS5sZW5ndGggPCB0aGlzLm9wdGlvbnMubWluTGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuY2xvc2UoZXZlbnQpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAodGhpcy5fdHJpZ2dlcihcXFwic2VhcmNoXFxcIiwgZXZlbnQpID09PSBmYWxzZSkge1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuX3NlYXJjaCh2YWx1ZSk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfc2VhcmNoOiBmdW5jdGlvbiBfc2VhcmNoKHZhbHVlKSB7XFxuXFx0XFx0XFx0dGhpcy5wZW5kaW5nKys7XFxuXFx0XFx0XFx0dGhpcy5lbGVtZW50LmFkZENsYXNzKFxcXCJ1aS1hdXRvY29tcGxldGUtbG9hZGluZ1xcXCIpO1xcblxcdFxcdFxcdHRoaXMuY2FuY2VsU2VhcmNoID0gZmFsc2U7XFxuXFxuXFx0XFx0XFx0dGhpcy5zb3VyY2UoeyB0ZXJtOiB2YWx1ZSB9LCB0aGlzLl9yZXNwb25zZSgpKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9yZXNwb25zZTogZnVuY3Rpb24gX3Jlc3BvbnNlKCkge1xcblxcdFxcdFxcdHZhciBpbmRleCA9ICsrdGhpcy5yZXF1ZXN0SW5kZXg7XFxuXFxuXFx0XFx0XFx0cmV0dXJuICQucHJveHkoZnVuY3Rpb24gKGNvbnRlbnQpIHtcXG5cXHRcXHRcXHRcXHRpZiAoaW5kZXggPT09IHRoaXMucmVxdWVzdEluZGV4KSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fX3Jlc3BvbnNlKGNvbnRlbnQpO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR0aGlzLnBlbmRpbmctLTtcXG5cXHRcXHRcXHRcXHRpZiAoIXRoaXMucGVuZGluZykge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuZWxlbWVudC5yZW1vdmVDbGFzcyhcXFwidWktYXV0b2NvbXBsZXRlLWxvYWRpbmdcXFwiKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSwgdGhpcyk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfX3Jlc3BvbnNlOiBmdW5jdGlvbiBfX3Jlc3BvbnNlKGNvbnRlbnQpIHtcXG5cXHRcXHRcXHRpZiAoY29udGVudCkge1xcblxcdFxcdFxcdFxcdGNvbnRlbnQgPSB0aGlzLl9ub3JtYWxpemUoY29udGVudCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHRoaXMuX3RyaWdnZXIoXFxcInJlc3BvbnNlXFxcIiwgbnVsbCwgeyBjb250ZW50OiBjb250ZW50IH0pO1xcblxcdFxcdFxcdGlmICghdGhpcy5vcHRpb25zLmRpc2FibGVkICYmIGNvbnRlbnQgJiYgY29udGVudC5sZW5ndGggJiYgIXRoaXMuY2FuY2VsU2VhcmNoKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5fc3VnZ2VzdChjb250ZW50KTtcXG5cXHRcXHRcXHRcXHR0aGlzLl90cmlnZ2VyKFxcXCJvcGVuXFxcIik7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHQvLyB1c2UgLl9jbG9zZSgpIGluc3RlYWQgb2YgLmNsb3NlKCkgc28gd2UgZG9uJ3QgY2FuY2VsIGZ1dHVyZSBzZWFyY2hlc1xcblxcdFxcdFxcdFxcdHRoaXMuX2Nsb3NlKCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y2xvc2U6IGZ1bmN0aW9uIGNsb3NlKGV2ZW50KSB7XFxuXFx0XFx0XFx0dGhpcy5jYW5jZWxTZWFyY2ggPSB0cnVlO1xcblxcdFxcdFxcdHRoaXMuX2Nsb3NlKGV2ZW50KTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9jbG9zZTogZnVuY3Rpb24gX2Nsb3NlKGV2ZW50KSB7XFxuXFx0XFx0XFx0aWYgKHRoaXMubWVudS5lbGVtZW50LmlzKFxcXCI6dmlzaWJsZVxcXCIpKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5tZW51LmVsZW1lbnQuaGlkZSgpO1xcblxcdFxcdFxcdFxcdHRoaXMubWVudS5ibHVyKCk7XFxuXFx0XFx0XFx0XFx0dGhpcy5pc05ld01lbnUgPSB0cnVlO1xcblxcdFxcdFxcdFxcdHRoaXMuX3RyaWdnZXIoXFxcImNsb3NlXFxcIiwgZXZlbnQpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcblxcdFxcdF9jaGFuZ2U6IGZ1bmN0aW9uIF9jaGFuZ2UoZXZlbnQpIHtcXG5cXHRcXHRcXHRpZiAodGhpcy5wcmV2aW91cyAhPT0gdGhpcy5fdmFsdWUoKSkge1xcblxcdFxcdFxcdFxcdHRoaXMuX3RyaWdnZXIoXFxcImNoYW5nZVxcXCIsIGV2ZW50LCB7IGl0ZW06IHRoaXMuc2VsZWN0ZWRJdGVtIH0pO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcblxcdFxcdF9ub3JtYWxpemU6IGZ1bmN0aW9uIF9ub3JtYWxpemUoaXRlbXMpIHtcXG5cXHRcXHRcXHQvLyBhc3N1bWUgYWxsIGl0ZW1zIGhhdmUgdGhlIHJpZ2h0IGZvcm1hdCB3aGVuIHRoZSBmaXJzdCBpdGVtIGlzIGNvbXBsZXRlXFxuXFx0XFx0XFx0aWYgKGl0ZW1zLmxlbmd0aCAmJiBpdGVtc1swXS5sYWJlbCAmJiBpdGVtc1swXS52YWx1ZSkge1xcblxcdFxcdFxcdFxcdHJldHVybiBpdGVtcztcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuICQubWFwKGl0ZW1zLCBmdW5jdGlvbiAoaXRlbSkge1xcblxcdFxcdFxcdFxcdGlmICh0eXBlb2YgaXRlbSA9PT0gXFxcInN0cmluZ1xcXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4ge1xcblxcdFxcdFxcdFxcdFxcdFxcdGxhYmVsOiBpdGVtLFxcblxcdFxcdFxcdFxcdFxcdFxcdHZhbHVlOiBpdGVtXFxuXFx0XFx0XFx0XFx0XFx0fTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0cmV0dXJuICQuZXh0ZW5kKHt9LCBpdGVtLCB7XFxuXFx0XFx0XFx0XFx0XFx0bGFiZWw6IGl0ZW0ubGFiZWwgfHwgaXRlbS52YWx1ZSxcXG5cXHRcXHRcXHRcXHRcXHR2YWx1ZTogaXRlbS52YWx1ZSB8fCBpdGVtLmxhYmVsXFxuXFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfc3VnZ2VzdDogZnVuY3Rpb24gX3N1Z2dlc3QoaXRlbXMpIHtcXG5cXHRcXHRcXHR2YXIgdWwgPSB0aGlzLm1lbnUuZWxlbWVudC5lbXB0eSgpO1xcblxcdFxcdFxcdHRoaXMuX3JlbmRlck1lbnUodWwsIGl0ZW1zKTtcXG5cXHRcXHRcXHR0aGlzLmlzTmV3TWVudSA9IHRydWU7XFxuXFx0XFx0XFx0dGhpcy5tZW51LnJlZnJlc2goKTtcXG5cXG5cXHRcXHRcXHQvLyBzaXplIGFuZCBwb3NpdGlvbiBtZW51XFxuXFx0XFx0XFx0dWwuc2hvdygpO1xcblxcdFxcdFxcdHRoaXMuX3Jlc2l6ZU1lbnUoKTtcXG5cXHRcXHRcXHR1bC5wb3NpdGlvbigkLmV4dGVuZCh7XFxuXFx0XFx0XFx0XFx0b2Y6IHRoaXMuZWxlbWVudFxcblxcdFxcdFxcdH0sIHRoaXMub3B0aW9ucy5wb3NpdGlvbikpO1xcblxcblxcdFxcdFxcdGlmICh0aGlzLm9wdGlvbnMuYXV0b0ZvY3VzKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5tZW51Lm5leHQoKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfcmVzaXplTWVudTogZnVuY3Rpb24gX3Jlc2l6ZU1lbnUoKSB7XFxuXFx0XFx0XFx0dmFyIHVsID0gdGhpcy5tZW51LmVsZW1lbnQ7XFxuXFx0XFx0XFx0dWwub3V0ZXJXaWR0aChNYXRoLm1heChcXG5cXHRcXHRcXHQvLyBGaXJlZm94IHdyYXBzIGxvbmcgdGV4dCAocG9zc2libHkgYSByb3VuZGluZyBidWcpXFxuXFx0XFx0XFx0Ly8gc28gd2UgYWRkIDFweCB0byBhdm9pZCB0aGUgd3JhcHBpbmcgKCM3NTEzKVxcblxcdFxcdFxcdHVsLndpZHRoKFxcXCJcXFwiKS5vdXRlcldpZHRoKCkgKyAxLCB0aGlzLmVsZW1lbnQub3V0ZXJXaWR0aCgpKSk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfcmVuZGVyTWVudTogZnVuY3Rpb24gX3JlbmRlck1lbnUodWwsIGl0ZW1zKSB7XFxuXFx0XFx0XFx0dmFyIHRoYXQgPSB0aGlzO1xcblxcdFxcdFxcdCQuZWFjaChpdGVtcywgZnVuY3Rpb24gKGluZGV4LCBpdGVtKSB7XFxuXFx0XFx0XFx0XFx0dGhhdC5fcmVuZGVySXRlbURhdGEodWwsIGl0ZW0pO1xcblxcdFxcdFxcdH0pO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X3JlbmRlckl0ZW1EYXRhOiBmdW5jdGlvbiBfcmVuZGVySXRlbURhdGEodWwsIGl0ZW0pIHtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5fcmVuZGVySXRlbSh1bCwgaXRlbSkuZGF0YShcXFwidWktYXV0b2NvbXBsZXRlLWl0ZW1cXFwiLCBpdGVtKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9yZW5kZXJJdGVtOiBmdW5jdGlvbiBfcmVuZGVySXRlbSh1bCwgaXRlbSkge1xcblxcdFxcdFxcdHJldHVybiAkKFxcXCI8bGk+XFxcIikudGV4dChpdGVtLmxhYmVsKS5hcHBlbmRUbyh1bCk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfbW92ZTogZnVuY3Rpb24gX21vdmUoZGlyZWN0aW9uLCBldmVudCkge1xcblxcdFxcdFxcdGlmICghdGhpcy5tZW51LmVsZW1lbnQuaXMoXFxcIjp2aXNpYmxlXFxcIikpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLnNlYXJjaChudWxsLCBldmVudCk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAodGhpcy5tZW51LmlzRmlyc3RJdGVtKCkgJiYgL15wcmV2aW91cy8udGVzdChkaXJlY3Rpb24pIHx8IHRoaXMubWVudS5pc0xhc3RJdGVtKCkgJiYgL15uZXh0Ly50ZXN0KGRpcmVjdGlvbikpIHtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIXRoaXMuaXNNdWx0aUxpbmUpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl92YWx1ZSh0aGlzLnRlcm0pO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR0aGlzLm1lbnUuYmx1cigpO1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0dGhpcy5tZW51W2RpcmVjdGlvbl0oZXZlbnQpO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0d2lkZ2V0OiBmdW5jdGlvbiB3aWRnZXQoKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMubWVudS5lbGVtZW50O1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X3ZhbHVlOiBmdW5jdGlvbiBfdmFsdWUoKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMudmFsdWVNZXRob2QuYXBwbHkodGhpcy5lbGVtZW50LCBhcmd1bWVudHMpO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X2tleUV2ZW50OiBmdW5jdGlvbiBfa2V5RXZlbnQoa2V5RXZlbnQsIGV2ZW50KSB7XFxuXFx0XFx0XFx0aWYgKCF0aGlzLmlzTXVsdGlMaW5lIHx8IHRoaXMubWVudS5lbGVtZW50LmlzKFxcXCI6dmlzaWJsZVxcXCIpKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5fbW92ZShrZXlFdmVudCwgZXZlbnQpO1xcblxcblxcdFxcdFxcdFxcdC8vIHByZXZlbnRzIG1vdmluZyBjdXJzb3IgdG8gYmVnaW5uaW5nL2VuZCBvZiB0aGUgdGV4dCBmaWVsZCBpbiBzb21lIGJyb3dzZXJzXFxuXFx0XFx0XFx0XFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH0pO1xcblxcblxcdCQuZXh0ZW5kKCQudWkuYXV0b2NvbXBsZXRlLCB7XFxuXFx0XFx0ZXNjYXBlUmVnZXg6IGZ1bmN0aW9uIGVzY2FwZVJlZ2V4KHZhbHVlKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHZhbHVlLnJlcGxhY2UoL1tcXFxcLVxcXFxbXFxcXF17fSgpKis/LixcXFxcXFxcXFxcXFxeJHwjXFxcXHNdL2csIFxcXCJcXFxcXFxcXCQmXFxcIik7XFxuXFx0XFx0fSxcXG5cXHRcXHRmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcihhcnJheSwgdGVybSkge1xcblxcdFxcdFxcdHZhciBtYXRjaGVyID0gbmV3IFJlZ0V4cCgkLnVpLmF1dG9jb21wbGV0ZS5lc2NhcGVSZWdleCh0ZXJtKSwgXFxcImlcXFwiKTtcXG5cXHRcXHRcXHRyZXR1cm4gJC5ncmVwKGFycmF5LCBmdW5jdGlvbiAodmFsdWUpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gbWF0Y2hlci50ZXN0KHZhbHVlLmxhYmVsIHx8IHZhbHVlLnZhbHVlIHx8IHZhbHVlKTtcXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHR9XFxuXFx0fSk7XFxuXFxuXFx0Ly8gbGl2ZSByZWdpb24gZXh0ZW5zaW9uLCBhZGRpbmcgYSBgbWVzc2FnZXNgIG9wdGlvblxcblxcdC8vIE5PVEU6IFRoaXMgaXMgYW4gZXhwZXJpbWVudGFsIEFQSS4gV2UgYXJlIHN0aWxsIGludmVzdGlnYXRpbmdcXG5cXHQvLyBhIGZ1bGwgc29sdXRpb24gZm9yIHN0cmluZyBtYW5pcHVsYXRpb24gYW5kIGludGVybmF0aW9uYWxpemF0aW9uLlxcblxcdCQud2lkZ2V0KFxcXCJ1aS5hdXRvY29tcGxldGVcXFwiLCAkLnVpLmF1dG9jb21wbGV0ZSwge1xcblxcdFxcdG9wdGlvbnM6IHtcXG5cXHRcXHRcXHRtZXNzYWdlczoge1xcblxcdFxcdFxcdFxcdG5vUmVzdWx0czogXFxcIk5vIHNlYXJjaCByZXN1bHRzLlxcXCIsXFxuXFx0XFx0XFx0XFx0cmVzdWx0czogZnVuY3Rpb24gcmVzdWx0cyhhbW91bnQpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gYW1vdW50ICsgKGFtb3VudCA+IDEgPyBcXFwiIHJlc3VsdHMgYXJlXFxcIiA6IFxcXCIgcmVzdWx0IGlzXFxcIikgKyBcXFwiIGF2YWlsYWJsZSwgdXNlIHVwIGFuZCBkb3duIGFycm93IGtleXMgdG8gbmF2aWdhdGUuXFxcIjtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFxuXFx0XFx0X19yZXNwb25zZTogZnVuY3Rpb24gX19yZXNwb25zZShjb250ZW50KSB7XFxuXFx0XFx0XFx0dmFyIG1lc3NhZ2U7XFxuXFx0XFx0XFx0dGhpcy5fc3VwZXJBcHBseShhcmd1bWVudHMpO1xcblxcdFxcdFxcdGlmICh0aGlzLm9wdGlvbnMuZGlzYWJsZWQgfHwgdGhpcy5jYW5jZWxTZWFyY2gpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmIChjb250ZW50ICYmIGNvbnRlbnQubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0bWVzc2FnZSA9IHRoaXMub3B0aW9ucy5tZXNzYWdlcy5yZXN1bHRzKGNvbnRlbnQubGVuZ3RoKTtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdG1lc3NhZ2UgPSB0aGlzLm9wdGlvbnMubWVzc2FnZXMubm9SZXN1bHRzO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR0aGlzLmxpdmVSZWdpb24uY2hpbGRyZW4oKS5oaWRlKCk7XFxuXFx0XFx0XFx0JChcXFwiPGRpdj5cXFwiKS50ZXh0KG1lc3NhZ2UpLmFwcGVuZFRvKHRoaXMubGl2ZVJlZ2lvbik7XFxuXFx0XFx0fVxcblxcdH0pO1xcblxcblxcdHZhciBhdXRvY29tcGxldGUgPSAkLnVpLmF1dG9jb21wbGV0ZTtcXG5cXG5cXHQvKiFcXG4gICogalF1ZXJ5IFVJIEJ1dHRvbiAxLjExLjRcXG4gICogaHR0cDovL2pxdWVyeXVpLmNvbVxcbiAgKlxcbiAgKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xcbiAgKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXFxuICAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcXG4gICpcXG4gICogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20vYnV0dG9uL1xcbiAgKi9cXG5cXG5cXHR2YXIgbGFzdEFjdGl2ZSxcXG5cXHQgICAgYmFzZUNsYXNzZXMgPSBcXFwidWktYnV0dG9uIHVpLXdpZGdldCB1aS1zdGF0ZS1kZWZhdWx0IHVpLWNvcm5lci1hbGxcXFwiLFxcblxcdCAgICB0eXBlQ2xhc3NlcyA9IFxcXCJ1aS1idXR0b24taWNvbnMtb25seSB1aS1idXR0b24taWNvbi1vbmx5IHVpLWJ1dHRvbi10ZXh0LWljb25zIHVpLWJ1dHRvbi10ZXh0LWljb24tcHJpbWFyeSB1aS1idXR0b24tdGV4dC1pY29uLXNlY29uZGFyeSB1aS1idXR0b24tdGV4dC1vbmx5XFxcIixcXG5cXHQgICAgZm9ybVJlc2V0SGFuZGxlciA9IGZ1bmN0aW9uIGZvcm1SZXNldEhhbmRsZXIoKSB7XFxuXFx0XFx0dmFyIGZvcm0gPSAkKHRoaXMpO1xcblxcdFxcdHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdGZvcm0uZmluZChcXFwiOnVpLWJ1dHRvblxcXCIpLmJ1dHRvbihcXFwicmVmcmVzaFxcXCIpO1xcblxcdFxcdH0sIDEpO1xcblxcdH0sXFxuXFx0ICAgIHJhZGlvR3JvdXAgPSBmdW5jdGlvbiByYWRpb0dyb3VwKHJhZGlvKSB7XFxuXFx0XFx0dmFyIG5hbWUgPSByYWRpby5uYW1lLFxcblxcdFxcdCAgICBmb3JtID0gcmFkaW8uZm9ybSxcXG5cXHRcXHQgICAgcmFkaW9zID0gJChbXSk7XFxuXFx0XFx0aWYgKG5hbWUpIHtcXG5cXHRcXHRcXHRuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFxcXCJcXFxcXFxcXCdcXFwiKTtcXG5cXHRcXHRcXHRpZiAoZm9ybSkge1xcblxcdFxcdFxcdFxcdHJhZGlvcyA9ICQoZm9ybSkuZmluZChcXFwiW25hbWU9J1xcXCIgKyBuYW1lICsgXFxcIiddW3R5cGU9cmFkaW9dXFxcIik7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRyYWRpb3MgPSAkKFxcXCJbbmFtZT0nXFxcIiArIG5hbWUgKyBcXFwiJ11bdHlwZT1yYWRpb11cXFwiLCByYWRpby5vd25lckRvY3VtZW50KS5maWx0ZXIoZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiAhdGhpcy5mb3JtO1xcblxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0XFx0cmV0dXJuIHJhZGlvcztcXG5cXHR9O1xcblxcblxcdCQud2lkZ2V0KFxcXCJ1aS5idXR0b25cXFwiLCB7XFxuXFx0XFx0dmVyc2lvbjogXFxcIjEuMTEuNFxcXCIsXFxuXFx0XFx0ZGVmYXVsdEVsZW1lbnQ6IFxcXCI8YnV0dG9uPlxcXCIsXFxuXFx0XFx0b3B0aW9uczoge1xcblxcdFxcdFxcdGRpc2FibGVkOiBudWxsLFxcblxcdFxcdFxcdHRleHQ6IHRydWUsXFxuXFx0XFx0XFx0bGFiZWw6IG51bGwsXFxuXFx0XFx0XFx0aWNvbnM6IHtcXG5cXHRcXHRcXHRcXHRwcmltYXJ5OiBudWxsLFxcblxcdFxcdFxcdFxcdHNlY29uZGFyeTogbnVsbFxcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcdFxcdF9jcmVhdGU6IGZ1bmN0aW9uIF9jcmVhdGUoKSB7XFxuXFx0XFx0XFx0dGhpcy5lbGVtZW50LmNsb3Nlc3QoXFxcImZvcm1cXFwiKS51bmJpbmQoXFxcInJlc2V0XFxcIiArIHRoaXMuZXZlbnROYW1lc3BhY2UpLmJpbmQoXFxcInJlc2V0XFxcIiArIHRoaXMuZXZlbnROYW1lc3BhY2UsIGZvcm1SZXNldEhhbmRsZXIpO1xcblxcblxcdFxcdFxcdGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmRpc2FibGVkICE9PSBcXFwiYm9vbGVhblxcXCIpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLm9wdGlvbnMuZGlzYWJsZWQgPSAhIXRoaXMuZWxlbWVudC5wcm9wKFxcXCJkaXNhYmxlZFxcXCIpO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5lbGVtZW50LnByb3AoXFxcImRpc2FibGVkXFxcIiwgdGhpcy5vcHRpb25zLmRpc2FibGVkKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy5fZGV0ZXJtaW5lQnV0dG9uVHlwZSgpO1xcblxcdFxcdFxcdHRoaXMuaGFzVGl0bGUgPSAhIXRoaXMuYnV0dG9uRWxlbWVudC5hdHRyKFxcXCJ0aXRsZVxcXCIpO1xcblxcblxcdFxcdFxcdHZhciB0aGF0ID0gdGhpcyxcXG5cXHRcXHRcXHQgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcXG5cXHRcXHRcXHQgICAgdG9nZ2xlQnV0dG9uID0gdGhpcy50eXBlID09PSBcXFwiY2hlY2tib3hcXFwiIHx8IHRoaXMudHlwZSA9PT0gXFxcInJhZGlvXFxcIixcXG5cXHRcXHRcXHQgICAgYWN0aXZlQ2xhc3MgPSAhdG9nZ2xlQnV0dG9uID8gXFxcInVpLXN0YXRlLWFjdGl2ZVxcXCIgOiBcXFwiXFxcIjtcXG5cXG5cXHRcXHRcXHRpZiAob3B0aW9ucy5sYWJlbCA9PT0gbnVsbCkge1xcblxcdFxcdFxcdFxcdG9wdGlvbnMubGFiZWwgPSB0aGlzLnR5cGUgPT09IFxcXCJpbnB1dFxcXCIgPyB0aGlzLmJ1dHRvbkVsZW1lbnQudmFsKCkgOiB0aGlzLmJ1dHRvbkVsZW1lbnQuaHRtbCgpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLl9ob3ZlcmFibGUodGhpcy5idXR0b25FbGVtZW50KTtcXG5cXG5cXHRcXHRcXHR0aGlzLmJ1dHRvbkVsZW1lbnQuYWRkQ2xhc3MoYmFzZUNsYXNzZXMpLmF0dHIoXFxcInJvbGVcXFwiLCBcXFwiYnV0dG9uXFxcIikuYmluZChcXFwibW91c2VlbnRlclxcXCIgKyB0aGlzLmV2ZW50TmFtZXNwYWNlLCBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0aWYgKG9wdGlvbnMuZGlzYWJsZWQpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGlmICh0aGlzID09PSBsYXN0QWN0aXZlKSB7XFxuXFx0XFx0XFx0XFx0XFx0JCh0aGlzKS5hZGRDbGFzcyhcXFwidWktc3RhdGUtYWN0aXZlXFxcIik7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0pLmJpbmQoXFxcIm1vdXNlbGVhdmVcXFwiICsgdGhpcy5ldmVudE5hbWVzcGFjZSwgZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdGlmIChvcHRpb25zLmRpc2FibGVkKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHQkKHRoaXMpLnJlbW92ZUNsYXNzKGFjdGl2ZUNsYXNzKTtcXG5cXHRcXHRcXHR9KS5iaW5kKFxcXCJjbGlja1xcXCIgKyB0aGlzLmV2ZW50TmFtZXNwYWNlLCBmdW5jdGlvbiAoZXZlbnQpIHtcXG5cXHRcXHRcXHRcXHRpZiAob3B0aW9ucy5kaXNhYmxlZCkge1xcblxcdFxcdFxcdFxcdFxcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XFxuXFx0XFx0XFx0XFx0XFx0ZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0pO1xcblxcblxcdFxcdFxcdC8vIENhbid0IHVzZSBfZm9jdXNhYmxlKCkgYmVjYXVzZSB0aGUgZWxlbWVudCB0aGF0IHJlY2VpdmVzIGZvY3VzXFxuXFx0XFx0XFx0Ly8gYW5kIHRoZSBlbGVtZW50IHRoYXQgZ2V0cyB0aGUgdWktc3RhdGUtZm9jdXMgY2xhc3MgYXJlIGRpZmZlcmVudFxcblxcdFxcdFxcdHRoaXMuX29uKHtcXG5cXHRcXHRcXHRcXHRmb2N1czogZnVuY3Rpb24gZm9jdXMoKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5idXR0b25FbGVtZW50LmFkZENsYXNzKFxcXCJ1aS1zdGF0ZS1mb2N1c1xcXCIpO1xcblxcdFxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0XFx0Ymx1cjogZnVuY3Rpb24gYmx1cigpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmJ1dHRvbkVsZW1lbnQucmVtb3ZlQ2xhc3MoXFxcInVpLXN0YXRlLWZvY3VzXFxcIik7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0pO1xcblxcblxcdFxcdFxcdGlmICh0b2dnbGVCdXR0b24pIHtcXG5cXHRcXHRcXHRcXHR0aGlzLmVsZW1lbnQuYmluZChcXFwiY2hhbmdlXFxcIiArIHRoaXMuZXZlbnROYW1lc3BhY2UsIGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGF0LnJlZnJlc2goKTtcXG5cXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKHRoaXMudHlwZSA9PT0gXFxcImNoZWNrYm94XFxcIikge1xcblxcdFxcdFxcdFxcdHRoaXMuYnV0dG9uRWxlbWVudC5iaW5kKFxcXCJjbGlja1xcXCIgKyB0aGlzLmV2ZW50TmFtZXNwYWNlLCBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKG9wdGlvbnMuZGlzYWJsZWQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdH0gZWxzZSBpZiAodGhpcy50eXBlID09PSBcXFwicmFkaW9cXFwiKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5idXR0b25FbGVtZW50LmJpbmQoXFxcImNsaWNrXFxcIiArIHRoaXMuZXZlbnROYW1lc3BhY2UsIGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAob3B0aW9ucy5kaXNhYmxlZCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0JCh0aGlzKS5hZGRDbGFzcyhcXFwidWktc3RhdGUtYWN0aXZlXFxcIik7XFxuXFx0XFx0XFx0XFx0XFx0dGhhdC5idXR0b25FbGVtZW50LmF0dHIoXFxcImFyaWEtcHJlc3NlZFxcXCIsIFxcXCJ0cnVlXFxcIik7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHJhZGlvID0gdGhhdC5lbGVtZW50WzBdO1xcblxcdFxcdFxcdFxcdFxcdHJhZGlvR3JvdXAocmFkaW8pLm5vdChyYWRpbykubWFwKGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gJCh0aGlzKS5idXR0b24oXFxcIndpZGdldFxcXCIpWzBdO1xcblxcdFxcdFxcdFxcdFxcdH0pLnJlbW92ZUNsYXNzKFxcXCJ1aS1zdGF0ZS1hY3RpdmVcXFwiKS5hdHRyKFxcXCJhcmlhLXByZXNzZWRcXFwiLCBcXFwiZmFsc2VcXFwiKTtcXG5cXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdHRoaXMuYnV0dG9uRWxlbWVudC5iaW5kKFxcXCJtb3VzZWRvd25cXFwiICsgdGhpcy5ldmVudE5hbWVzcGFjZSwgZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdGlmIChvcHRpb25zLmRpc2FibGVkKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHQkKHRoaXMpLmFkZENsYXNzKFxcXCJ1aS1zdGF0ZS1hY3RpdmVcXFwiKTtcXG5cXHRcXHRcXHRcXHRcXHRsYXN0QWN0aXZlID0gdGhpcztcXG5cXHRcXHRcXHRcXHRcXHR0aGF0LmRvY3VtZW50Lm9uZShcXFwibW91c2V1cFxcXCIsIGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRsYXN0QWN0aXZlID0gbnVsbDtcXG5cXHRcXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcXHR9KS5iaW5kKFxcXCJtb3VzZXVwXFxcIiArIHRoaXMuZXZlbnROYW1lc3BhY2UsIGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAob3B0aW9ucy5kaXNhYmxlZCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0JCh0aGlzKS5yZW1vdmVDbGFzcyhcXFwidWktc3RhdGUtYWN0aXZlXFxcIik7XFxuXFx0XFx0XFx0XFx0fSkuYmluZChcXFwia2V5ZG93blxcXCIgKyB0aGlzLmV2ZW50TmFtZXNwYWNlLCBmdW5jdGlvbiAoZXZlbnQpIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAob3B0aW9ucy5kaXNhYmxlZCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGV2ZW50LmtleUNvZGUgPT09ICQudWkua2V5Q29kZS5TUEFDRSB8fCBldmVudC5rZXlDb2RlID09PSAkLnVpLmtleUNvZGUuRU5URVIpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHQkKHRoaXMpLmFkZENsYXNzKFxcXCJ1aS1zdGF0ZS1hY3RpdmVcXFwiKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fSlcXG5cXHRcXHRcXHRcXHQvLyBzZWUgIzg1NTksIHdlIGJpbmQgdG8gYmx1ciBoZXJlIGluIGNhc2UgdGhlIGJ1dHRvbiBlbGVtZW50IGxvc2VzXFxuXFx0XFx0XFx0XFx0Ly8gZm9jdXMgYmV0d2VlbiBrZXlkb3duIGFuZCBrZXl1cCwgaXQgd291bGQgYmUgbGVmdCBpbiBhbiBcXFwiYWN0aXZlXFxcIiBzdGF0ZVxcblxcdFxcdFxcdFxcdC5iaW5kKFxcXCJrZXl1cFxcXCIgKyB0aGlzLmV2ZW50TmFtZXNwYWNlICsgXFxcIiBibHVyXFxcIiArIHRoaXMuZXZlbnROYW1lc3BhY2UsIGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHQkKHRoaXMpLnJlbW92ZUNsYXNzKFxcXCJ1aS1zdGF0ZS1hY3RpdmVcXFwiKTtcXG5cXHRcXHRcXHRcXHR9KTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAodGhpcy5idXR0b25FbGVtZW50LmlzKFxcXCJhXFxcIikpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmJ1dHRvbkVsZW1lbnQua2V5dXAoZnVuY3Rpb24gKGV2ZW50KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKGV2ZW50LmtleUNvZGUgPT09ICQudWkua2V5Q29kZS5TUEFDRSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIFRPRE8gcGFzcyB0aHJvdWdoIG9yaWdpbmFsIGV2ZW50IGNvcnJlY3RseSAoanVzdCBhcyAybmQgYXJndW1lbnQgZG9lc24ndCB3b3JrKVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdCQodGhpcykuY2xpY2soKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLl9zZXRPcHRpb24oXFxcImRpc2FibGVkXFxcIiwgb3B0aW9ucy5kaXNhYmxlZCk7XFxuXFx0XFx0XFx0dGhpcy5fcmVzZXRCdXR0b24oKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9kZXRlcm1pbmVCdXR0b25UeXBlOiBmdW5jdGlvbiBfZGV0ZXJtaW5lQnV0dG9uVHlwZSgpIHtcXG5cXHRcXHRcXHR2YXIgYW5jZXN0b3IsIGxhYmVsU2VsZWN0b3IsIGNoZWNrZWQ7XFxuXFxuXFx0XFx0XFx0aWYgKHRoaXMuZWxlbWVudC5pcyhcXFwiW3R5cGU9Y2hlY2tib3hdXFxcIikpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLnR5cGUgPSBcXFwiY2hlY2tib3hcXFwiO1xcblxcdFxcdFxcdH0gZWxzZSBpZiAodGhpcy5lbGVtZW50LmlzKFxcXCJbdHlwZT1yYWRpb11cXFwiKSkge1xcblxcdFxcdFxcdFxcdHRoaXMudHlwZSA9IFxcXCJyYWRpb1xcXCI7XFxuXFx0XFx0XFx0fSBlbHNlIGlmICh0aGlzLmVsZW1lbnQuaXMoXFxcImlucHV0XFxcIikpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLnR5cGUgPSBcXFwiaW5wdXRcXFwiO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0dGhpcy50eXBlID0gXFxcImJ1dHRvblxcXCI7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICh0aGlzLnR5cGUgPT09IFxcXCJjaGVja2JveFxcXCIgfHwgdGhpcy50eXBlID09PSBcXFwicmFkaW9cXFwiKSB7XFxuXFx0XFx0XFx0XFx0Ly8gd2UgZG9uJ3Qgc2VhcmNoIGFnYWluc3QgdGhlIGRvY3VtZW50IGluIGNhc2UgdGhlIGVsZW1lbnRcXG5cXHRcXHRcXHRcXHQvLyBpcyBkaXNjb25uZWN0ZWQgZnJvbSB0aGUgRE9NXFxuXFx0XFx0XFx0XFx0YW5jZXN0b3IgPSB0aGlzLmVsZW1lbnQucGFyZW50cygpLmxhc3QoKTtcXG5cXHRcXHRcXHRcXHRsYWJlbFNlbGVjdG9yID0gXFxcImxhYmVsW2Zvcj0nXFxcIiArIHRoaXMuZWxlbWVudC5hdHRyKFxcXCJpZFxcXCIpICsgXFxcIiddXFxcIjtcXG5cXHRcXHRcXHRcXHR0aGlzLmJ1dHRvbkVsZW1lbnQgPSBhbmNlc3Rvci5maW5kKGxhYmVsU2VsZWN0b3IpO1xcblxcdFxcdFxcdFxcdGlmICghdGhpcy5idXR0b25FbGVtZW50Lmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdFxcdGFuY2VzdG9yID0gYW5jZXN0b3IubGVuZ3RoID8gYW5jZXN0b3Iuc2libGluZ3MoKSA6IHRoaXMuZWxlbWVudC5zaWJsaW5ncygpO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuYnV0dG9uRWxlbWVudCA9IGFuY2VzdG9yLmZpbHRlcihsYWJlbFNlbGVjdG9yKTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIXRoaXMuYnV0dG9uRWxlbWVudC5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLmJ1dHRvbkVsZW1lbnQgPSBhbmNlc3Rvci5maW5kKGxhYmVsU2VsZWN0b3IpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0dGhpcy5lbGVtZW50LmFkZENsYXNzKFxcXCJ1aS1oZWxwZXItaGlkZGVuLWFjY2Vzc2libGVcXFwiKTtcXG5cXG5cXHRcXHRcXHRcXHRjaGVja2VkID0gdGhpcy5lbGVtZW50LmlzKFxcXCI6Y2hlY2tlZFxcXCIpO1xcblxcdFxcdFxcdFxcdGlmIChjaGVja2VkKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5idXR0b25FbGVtZW50LmFkZENsYXNzKFxcXCJ1aS1zdGF0ZS1hY3RpdmVcXFwiKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0dGhpcy5idXR0b25FbGVtZW50LnByb3AoXFxcImFyaWEtcHJlc3NlZFxcXCIsIGNoZWNrZWQpO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5idXR0b25FbGVtZW50ID0gdGhpcy5lbGVtZW50O1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcblxcdFxcdHdpZGdldDogZnVuY3Rpb24gd2lkZ2V0KCkge1xcblxcdFxcdFxcdHJldHVybiB0aGlzLmJ1dHRvbkVsZW1lbnQ7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfZGVzdHJveTogZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XFxuXFx0XFx0XFx0dGhpcy5lbGVtZW50LnJlbW92ZUNsYXNzKFxcXCJ1aS1oZWxwZXItaGlkZGVuLWFjY2Vzc2libGVcXFwiKTtcXG5cXHRcXHRcXHR0aGlzLmJ1dHRvbkVsZW1lbnQucmVtb3ZlQ2xhc3MoYmFzZUNsYXNzZXMgKyBcXFwiIHVpLXN0YXRlLWFjdGl2ZSBcXFwiICsgdHlwZUNsYXNzZXMpLnJlbW92ZUF0dHIoXFxcInJvbGVcXFwiKS5yZW1vdmVBdHRyKFxcXCJhcmlhLXByZXNzZWRcXFwiKS5odG1sKHRoaXMuYnV0dG9uRWxlbWVudC5maW5kKFxcXCIudWktYnV0dG9uLXRleHRcXFwiKS5odG1sKCkpO1xcblxcblxcdFxcdFxcdGlmICghdGhpcy5oYXNUaXRsZSkge1xcblxcdFxcdFxcdFxcdHRoaXMuYnV0dG9uRWxlbWVudC5yZW1vdmVBdHRyKFxcXCJ0aXRsZVxcXCIpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcblxcdFxcdF9zZXRPcHRpb246IGZ1bmN0aW9uIF9zZXRPcHRpb24oa2V5LCB2YWx1ZSkge1xcblxcdFxcdFxcdHRoaXMuX3N1cGVyKGtleSwgdmFsdWUpO1xcblxcdFxcdFxcdGlmIChrZXkgPT09IFxcXCJkaXNhYmxlZFxcXCIpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLndpZGdldCgpLnRvZ2dsZUNsYXNzKFxcXCJ1aS1zdGF0ZS1kaXNhYmxlZFxcXCIsICEhdmFsdWUpO1xcblxcdFxcdFxcdFxcdHRoaXMuZWxlbWVudC5wcm9wKFxcXCJkaXNhYmxlZFxcXCIsICEhdmFsdWUpO1xcblxcdFxcdFxcdFxcdGlmICh2YWx1ZSkge1xcblxcdFxcdFxcdFxcdFxcdGlmICh0aGlzLnR5cGUgPT09IFxcXCJjaGVja2JveFxcXCIgfHwgdGhpcy50eXBlID09PSBcXFwicmFkaW9cXFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5idXR0b25FbGVtZW50LnJlbW92ZUNsYXNzKFxcXCJ1aS1zdGF0ZS1mb2N1c1xcXCIpO1xcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5idXR0b25FbGVtZW50LnJlbW92ZUNsYXNzKFxcXCJ1aS1zdGF0ZS1mb2N1cyB1aS1zdGF0ZS1hY3RpdmVcXFwiKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0dGhpcy5fcmVzZXRCdXR0b24oKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdHJlZnJlc2g6IGZ1bmN0aW9uIHJlZnJlc2goKSB7XFxuXFx0XFx0XFx0Ly9TZWUgIzgyMzcgJiAjODgyOFxcblxcdFxcdFxcdHZhciBpc0Rpc2FibGVkID0gdGhpcy5lbGVtZW50LmlzKFxcXCJpbnB1dCwgYnV0dG9uXFxcIikgPyB0aGlzLmVsZW1lbnQuaXMoXFxcIjpkaXNhYmxlZFxcXCIpIDogdGhpcy5lbGVtZW50Lmhhc0NsYXNzKFxcXCJ1aS1idXR0b24tZGlzYWJsZWRcXFwiKTtcXG5cXG5cXHRcXHRcXHRpZiAoaXNEaXNhYmxlZCAhPT0gdGhpcy5vcHRpb25zLmRpc2FibGVkKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5fc2V0T3B0aW9uKFxcXCJkaXNhYmxlZFxcXCIsIGlzRGlzYWJsZWQpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAodGhpcy50eXBlID09PSBcXFwicmFkaW9cXFwiKSB7XFxuXFx0XFx0XFx0XFx0cmFkaW9Hcm91cCh0aGlzLmVsZW1lbnRbMF0pLmVhY2goZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdGlmICgkKHRoaXMpLmlzKFxcXCI6Y2hlY2tlZFxcXCIpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0JCh0aGlzKS5idXR0b24oXFxcIndpZGdldFxcXCIpLmFkZENsYXNzKFxcXCJ1aS1zdGF0ZS1hY3RpdmVcXFwiKS5hdHRyKFxcXCJhcmlhLXByZXNzZWRcXFwiLCBcXFwidHJ1ZVxcXCIpO1xcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0JCh0aGlzKS5idXR0b24oXFxcIndpZGdldFxcXCIpLnJlbW92ZUNsYXNzKFxcXCJ1aS1zdGF0ZS1hY3RpdmVcXFwiKS5hdHRyKFxcXCJhcmlhLXByZXNzZWRcXFwiLCBcXFwiZmFsc2VcXFwiKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0fSBlbHNlIGlmICh0aGlzLnR5cGUgPT09IFxcXCJjaGVja2JveFxcXCIpIHtcXG5cXHRcXHRcXHRcXHRpZiAodGhpcy5lbGVtZW50LmlzKFxcXCI6Y2hlY2tlZFxcXCIpKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5idXR0b25FbGVtZW50LmFkZENsYXNzKFxcXCJ1aS1zdGF0ZS1hY3RpdmVcXFwiKS5hdHRyKFxcXCJhcmlhLXByZXNzZWRcXFwiLCBcXFwidHJ1ZVxcXCIpO1xcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5idXR0b25FbGVtZW50LnJlbW92ZUNsYXNzKFxcXCJ1aS1zdGF0ZS1hY3RpdmVcXFwiKS5hdHRyKFxcXCJhcmlhLXByZXNzZWRcXFwiLCBcXFwiZmFsc2VcXFwiKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFxuXFx0XFx0X3Jlc2V0QnV0dG9uOiBmdW5jdGlvbiBfcmVzZXRCdXR0b24oKSB7XFxuXFx0XFx0XFx0aWYgKHRoaXMudHlwZSA9PT0gXFxcImlucHV0XFxcIikge1xcblxcdFxcdFxcdFxcdGlmICh0aGlzLm9wdGlvbnMubGFiZWwpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmVsZW1lbnQudmFsKHRoaXMub3B0aW9ucy5sYWJlbCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0dmFyIGJ1dHRvbkVsZW1lbnQgPSB0aGlzLmJ1dHRvbkVsZW1lbnQucmVtb3ZlQ2xhc3ModHlwZUNsYXNzZXMpLFxcblxcdFxcdFxcdCAgICBidXR0b25UZXh0ID0gJChcXFwiPHNwYW4+PC9zcGFuPlxcXCIsIHRoaXMuZG9jdW1lbnRbMF0pLmFkZENsYXNzKFxcXCJ1aS1idXR0b24tdGV4dFxcXCIpLmh0bWwodGhpcy5vcHRpb25zLmxhYmVsKS5hcHBlbmRUbyhidXR0b25FbGVtZW50LmVtcHR5KCkpLnRleHQoKSxcXG5cXHRcXHRcXHQgICAgaWNvbnMgPSB0aGlzLm9wdGlvbnMuaWNvbnMsXFxuXFx0XFx0XFx0ICAgIG11bHRpcGxlSWNvbnMgPSBpY29ucy5wcmltYXJ5ICYmIGljb25zLnNlY29uZGFyeSxcXG5cXHRcXHRcXHQgICAgYnV0dG9uQ2xhc3NlcyA9IFtdO1xcblxcblxcdFxcdFxcdGlmIChpY29ucy5wcmltYXJ5IHx8IGljb25zLnNlY29uZGFyeSkge1xcblxcdFxcdFxcdFxcdGlmICh0aGlzLm9wdGlvbnMudGV4dCkge1xcblxcdFxcdFxcdFxcdFxcdGJ1dHRvbkNsYXNzZXMucHVzaChcXFwidWktYnV0dG9uLXRleHQtaWNvblxcXCIgKyAobXVsdGlwbGVJY29ucyA/IFxcXCJzXFxcIiA6IGljb25zLnByaW1hcnkgPyBcXFwiLXByaW1hcnlcXFwiIDogXFxcIi1zZWNvbmRhcnlcXFwiKSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmIChpY29ucy5wcmltYXJ5KSB7XFxuXFx0XFx0XFx0XFx0XFx0YnV0dG9uRWxlbWVudC5wcmVwZW5kKFxcXCI8c3BhbiBjbGFzcz0ndWktYnV0dG9uLWljb24tcHJpbWFyeSB1aS1pY29uIFxcXCIgKyBpY29ucy5wcmltYXJ5ICsgXFxcIic+PC9zcGFuPlxcXCIpO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAoaWNvbnMuc2Vjb25kYXJ5KSB7XFxuXFx0XFx0XFx0XFx0XFx0YnV0dG9uRWxlbWVudC5hcHBlbmQoXFxcIjxzcGFuIGNsYXNzPSd1aS1idXR0b24taWNvbi1zZWNvbmRhcnkgdWktaWNvbiBcXFwiICsgaWNvbnMuc2Vjb25kYXJ5ICsgXFxcIic+PC9zcGFuPlxcXCIpO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAoIXRoaXMub3B0aW9ucy50ZXh0KSB7XFxuXFx0XFx0XFx0XFx0XFx0YnV0dG9uQ2xhc3Nlcy5wdXNoKG11bHRpcGxlSWNvbnMgPyBcXFwidWktYnV0dG9uLWljb25zLW9ubHlcXFwiIDogXFxcInVpLWJ1dHRvbi1pY29uLW9ubHlcXFwiKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIXRoaXMuaGFzVGl0bGUpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRidXR0b25FbGVtZW50LmF0dHIoXFxcInRpdGxlXFxcIiwgJC50cmltKGJ1dHRvblRleHQpKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0YnV0dG9uQ2xhc3Nlcy5wdXNoKFxcXCJ1aS1idXR0b24tdGV4dC1vbmx5XFxcIik7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGJ1dHRvbkVsZW1lbnQuYWRkQ2xhc3MoYnV0dG9uQ2xhc3Nlcy5qb2luKFxcXCIgXFxcIikpO1xcblxcdFxcdH1cXG5cXHR9KTtcXG5cXG5cXHQkLndpZGdldChcXFwidWkuYnV0dG9uc2V0XFxcIiwge1xcblxcdFxcdHZlcnNpb246IFxcXCIxLjExLjRcXFwiLFxcblxcdFxcdG9wdGlvbnM6IHtcXG5cXHRcXHRcXHRpdGVtczogXFxcImJ1dHRvbiwgaW5wdXRbdHlwZT1idXR0b25dLCBpbnB1dFt0eXBlPXN1Ym1pdF0sIGlucHV0W3R5cGU9cmVzZXRdLCBpbnB1dFt0eXBlPWNoZWNrYm94XSwgaW5wdXRbdHlwZT1yYWRpb10sIGEsIDpkYXRhKHVpLWJ1dHRvbilcXFwiXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfY3JlYXRlOiBmdW5jdGlvbiBfY3JlYXRlKCkge1xcblxcdFxcdFxcdHRoaXMuZWxlbWVudC5hZGRDbGFzcyhcXFwidWktYnV0dG9uc2V0XFxcIik7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfaW5pdDogZnVuY3Rpb24gX2luaXQoKSB7XFxuXFx0XFx0XFx0dGhpcy5yZWZyZXNoKCk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfc2V0T3B0aW9uOiBmdW5jdGlvbiBfc2V0T3B0aW9uKGtleSwgdmFsdWUpIHtcXG5cXHRcXHRcXHRpZiAoa2V5ID09PSBcXFwiZGlzYWJsZWRcXFwiKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5idXR0b25zLmJ1dHRvbihcXFwib3B0aW9uXFxcIiwga2V5LCB2YWx1ZSk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMuX3N1cGVyKGtleSwgdmFsdWUpO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0cmVmcmVzaDogZnVuY3Rpb24gcmVmcmVzaCgpIHtcXG5cXHRcXHRcXHR2YXIgcnRsID0gdGhpcy5lbGVtZW50LmNzcyhcXFwiZGlyZWN0aW9uXFxcIikgPT09IFxcXCJydGxcXFwiLFxcblxcdFxcdFxcdCAgICBhbGxCdXR0b25zID0gdGhpcy5lbGVtZW50LmZpbmQodGhpcy5vcHRpb25zLml0ZW1zKSxcXG5cXHRcXHRcXHQgICAgZXhpc3RpbmdCdXR0b25zID0gYWxsQnV0dG9ucy5maWx0ZXIoXFxcIjp1aS1idXR0b25cXFwiKTtcXG5cXG5cXHRcXHRcXHQvLyBJbml0aWFsaXplIG5ldyBidXR0b25zXFxuXFx0XFx0XFx0YWxsQnV0dG9ucy5ub3QoXFxcIjp1aS1idXR0b25cXFwiKS5idXR0b24oKTtcXG5cXG5cXHRcXHRcXHQvLyBSZWZyZXNoIGV4aXN0aW5nIGJ1dHRvbnNcXG5cXHRcXHRcXHRleGlzdGluZ0J1dHRvbnMuYnV0dG9uKFxcXCJyZWZyZXNoXFxcIik7XFxuXFxuXFx0XFx0XFx0dGhpcy5idXR0b25zID0gYWxsQnV0dG9ucy5tYXAoZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdHJldHVybiAkKHRoaXMpLmJ1dHRvbihcXFwid2lkZ2V0XFxcIilbMF07XFxuXFx0XFx0XFx0fSkucmVtb3ZlQ2xhc3MoXFxcInVpLWNvcm5lci1hbGwgdWktY29ybmVyLWxlZnQgdWktY29ybmVyLXJpZ2h0XFxcIikuZmlsdGVyKFxcXCI6Zmlyc3RcXFwiKS5hZGRDbGFzcyhydGwgPyBcXFwidWktY29ybmVyLXJpZ2h0XFxcIiA6IFxcXCJ1aS1jb3JuZXItbGVmdFxcXCIpLmVuZCgpLmZpbHRlcihcXFwiOmxhc3RcXFwiKS5hZGRDbGFzcyhydGwgPyBcXFwidWktY29ybmVyLWxlZnRcXFwiIDogXFxcInVpLWNvcm5lci1yaWdodFxcXCIpLmVuZCgpLmVuZCgpO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X2Rlc3Ryb3k6IGZ1bmN0aW9uIF9kZXN0cm95KCkge1xcblxcdFxcdFxcdHRoaXMuZWxlbWVudC5yZW1vdmVDbGFzcyhcXFwidWktYnV0dG9uc2V0XFxcIik7XFxuXFx0XFx0XFx0dGhpcy5idXR0b25zLm1hcChmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuICQodGhpcykuYnV0dG9uKFxcXCJ3aWRnZXRcXFwiKVswXTtcXG5cXHRcXHRcXHR9KS5yZW1vdmVDbGFzcyhcXFwidWktY29ybmVyLWxlZnQgdWktY29ybmVyLXJpZ2h0XFxcIikuZW5kKCkuYnV0dG9uKFxcXCJkZXN0cm95XFxcIik7XFxuXFx0XFx0fVxcblxcdH0pO1xcblxcblxcdHZhciBidXR0b24gPSAkLnVpLmJ1dHRvbjtcXG5cXG5cXHQvKiFcXG4gICogalF1ZXJ5IFVJIERhdGVwaWNrZXIgMS4xMS40XFxuICAqIGh0dHA6Ly9qcXVlcnl1aS5jb21cXG4gICpcXG4gICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcXG4gICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxcbiAgKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXFxuICAqXFxuICAqIGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL2RhdGVwaWNrZXIvXFxuICAqL1xcblxcblxcdCQuZXh0ZW5kKCQudWksIHsgZGF0ZXBpY2tlcjogeyB2ZXJzaW9uOiBcXFwiMS4xMS40XFxcIiB9IH0pO1xcblxcblxcdHZhciBkYXRlcGlja2VyX2luc3RBY3RpdmU7XFxuXFxuXFx0ZnVuY3Rpb24gZGF0ZXBpY2tlcl9nZXRaaW5kZXgoZWxlbSkge1xcblxcdFxcdHZhciBwb3NpdGlvbiwgdmFsdWU7XFxuXFx0XFx0d2hpbGUgKGVsZW0ubGVuZ3RoICYmIGVsZW1bMF0gIT09IGRvY3VtZW50KSB7XFxuXFx0XFx0XFx0Ly8gSWdub3JlIHotaW5kZXggaWYgcG9zaXRpb24gaXMgc2V0IHRvIGEgdmFsdWUgd2hlcmUgei1pbmRleCBpcyBpZ25vcmVkIGJ5IHRoZSBicm93c2VyXFxuXFx0XFx0XFx0Ly8gVGhpcyBtYWtlcyBiZWhhdmlvciBvZiB0aGlzIGZ1bmN0aW9uIGNvbnNpc3RlbnQgYWNyb3NzIGJyb3dzZXJzXFxuXFx0XFx0XFx0Ly8gV2ViS2l0IGFsd2F5cyByZXR1cm5zIGF1dG8gaWYgdGhlIGVsZW1lbnQgaXMgcG9zaXRpb25lZFxcblxcdFxcdFxcdHBvc2l0aW9uID0gZWxlbS5jc3MoXFxcInBvc2l0aW9uXFxcIik7XFxuXFx0XFx0XFx0aWYgKHBvc2l0aW9uID09PSBcXFwiYWJzb2x1dGVcXFwiIHx8IHBvc2l0aW9uID09PSBcXFwicmVsYXRpdmVcXFwiIHx8IHBvc2l0aW9uID09PSBcXFwiZml4ZWRcXFwiKSB7XFxuXFx0XFx0XFx0XFx0Ly8gSUUgcmV0dXJucyAwIHdoZW4gekluZGV4IGlzIG5vdCBzcGVjaWZpZWRcXG5cXHRcXHRcXHRcXHQvLyBvdGhlciBicm93c2VycyByZXR1cm4gYSBzdHJpbmdcXG5cXHRcXHRcXHRcXHQvLyB3ZSBpZ25vcmUgdGhlIGNhc2Ugb2YgbmVzdGVkIGVsZW1lbnRzIHdpdGggYW4gZXhwbGljaXQgdmFsdWUgb2YgMFxcblxcdFxcdFxcdFxcdC8vIDxkaXYgc3R5bGU9XFxcInotaW5kZXg6IC0xMDtcXFwiPjxkaXYgc3R5bGU9XFxcInotaW5kZXg6IDA7XFxcIj48L2Rpdj48L2Rpdj5cXG5cXHRcXHRcXHRcXHR2YWx1ZSA9IHBhcnNlSW50KGVsZW0uY3NzKFxcXCJ6SW5kZXhcXFwiKSwgMTApO1xcblxcdFxcdFxcdFxcdGlmICghaXNOYU4odmFsdWUpICYmIHZhbHVlICE9PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHZhbHVlO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0ZWxlbSA9IGVsZW0ucGFyZW50KCk7XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiAwO1xcblxcdH1cXG5cXHQvKiBEYXRlIHBpY2tlciBtYW5hZ2VyLlxcbiAgICBVc2UgdGhlIHNpbmdsZXRvbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLCAkLmRhdGVwaWNrZXIsIHRvIGludGVyYWN0IHdpdGggdGhlIGRhdGUgcGlja2VyLlxcbiAgICBTZXR0aW5ncyBmb3IgKGdyb3VwcyBvZikgZGF0ZSBwaWNrZXJzIGFyZSBtYWludGFpbmVkIGluIGFuIGluc3RhbmNlIG9iamVjdCxcXG4gICAgYWxsb3dpbmcgbXVsdGlwbGUgZGlmZmVyZW50IHNldHRpbmdzIG9uIHRoZSBzYW1lIHBhZ2UuICovXFxuXFxuXFx0ZnVuY3Rpb24gRGF0ZXBpY2tlcigpIHtcXG5cXHRcXHR0aGlzLl9jdXJJbnN0ID0gbnVsbDsgLy8gVGhlIGN1cnJlbnQgaW5zdGFuY2UgaW4gdXNlXFxuXFx0XFx0dGhpcy5fa2V5RXZlbnQgPSBmYWxzZTsgLy8gSWYgdGhlIGxhc3QgZXZlbnQgd2FzIGEga2V5IGV2ZW50XFxuXFx0XFx0dGhpcy5fZGlzYWJsZWRJbnB1dHMgPSBbXTsgLy8gTGlzdCBvZiBkYXRlIHBpY2tlciBpbnB1dHMgdGhhdCBoYXZlIGJlZW4gZGlzYWJsZWRcXG5cXHRcXHR0aGlzLl9kYXRlcGlja2VyU2hvd2luZyA9IGZhbHNlOyAvLyBUcnVlIGlmIHRoZSBwb3B1cCBwaWNrZXIgaXMgc2hvd2luZyAsIGZhbHNlIGlmIG5vdFxcblxcdFxcdHRoaXMuX2luRGlhbG9nID0gZmFsc2U7IC8vIFRydWUgaWYgc2hvd2luZyB3aXRoaW4gYSBcXFwiZGlhbG9nXFxcIiwgZmFsc2UgaWYgbm90XFxuXFx0XFx0dGhpcy5fbWFpbkRpdklkID0gXFxcInVpLWRhdGVwaWNrZXItZGl2XFxcIjsgLy8gVGhlIElEIG9mIHRoZSBtYWluIGRhdGVwaWNrZXIgZGl2aXNpb25cXG5cXHRcXHR0aGlzLl9pbmxpbmVDbGFzcyA9IFxcXCJ1aS1kYXRlcGlja2VyLWlubGluZVxcXCI7IC8vIFRoZSBuYW1lIG9mIHRoZSBpbmxpbmUgbWFya2VyIGNsYXNzXFxuXFx0XFx0dGhpcy5fYXBwZW5kQ2xhc3MgPSBcXFwidWktZGF0ZXBpY2tlci1hcHBlbmRcXFwiOyAvLyBUaGUgbmFtZSBvZiB0aGUgYXBwZW5kIG1hcmtlciBjbGFzc1xcblxcdFxcdHRoaXMuX3RyaWdnZXJDbGFzcyA9IFxcXCJ1aS1kYXRlcGlja2VyLXRyaWdnZXJcXFwiOyAvLyBUaGUgbmFtZSBvZiB0aGUgdHJpZ2dlciBtYXJrZXIgY2xhc3NcXG5cXHRcXHR0aGlzLl9kaWFsb2dDbGFzcyA9IFxcXCJ1aS1kYXRlcGlja2VyLWRpYWxvZ1xcXCI7IC8vIFRoZSBuYW1lIG9mIHRoZSBkaWFsb2cgbWFya2VyIGNsYXNzXFxuXFx0XFx0dGhpcy5fZGlzYWJsZUNsYXNzID0gXFxcInVpLWRhdGVwaWNrZXItZGlzYWJsZWRcXFwiOyAvLyBUaGUgbmFtZSBvZiB0aGUgZGlzYWJsZWQgY292ZXJpbmcgbWFya2VyIGNsYXNzXFxuXFx0XFx0dGhpcy5fdW5zZWxlY3RhYmxlQ2xhc3MgPSBcXFwidWktZGF0ZXBpY2tlci11bnNlbGVjdGFibGVcXFwiOyAvLyBUaGUgbmFtZSBvZiB0aGUgdW5zZWxlY3RhYmxlIGNlbGwgbWFya2VyIGNsYXNzXFxuXFx0XFx0dGhpcy5fY3VycmVudENsYXNzID0gXFxcInVpLWRhdGVwaWNrZXItY3VycmVudC1kYXlcXFwiOyAvLyBUaGUgbmFtZSBvZiB0aGUgY3VycmVudCBkYXkgbWFya2VyIGNsYXNzXFxuXFx0XFx0dGhpcy5fZGF5T3ZlckNsYXNzID0gXFxcInVpLWRhdGVwaWNrZXItZGF5cy1jZWxsLW92ZXJcXFwiOyAvLyBUaGUgbmFtZSBvZiB0aGUgZGF5IGhvdmVyIG1hcmtlciBjbGFzc1xcblxcdFxcdHRoaXMucmVnaW9uYWwgPSBbXTsgLy8gQXZhaWxhYmxlIHJlZ2lvbmFsIHNldHRpbmdzLCBpbmRleGVkIGJ5IGxhbmd1YWdlIGNvZGVcXG5cXHRcXHR0aGlzLnJlZ2lvbmFsW1xcXCJcXFwiXSA9IHsgLy8gRGVmYXVsdCByZWdpb25hbCBzZXR0aW5nc1xcblxcdFxcdFxcdGNsb3NlVGV4dDogXFxcIkRvbmVcXFwiLCAvLyBEaXNwbGF5IHRleHQgZm9yIGNsb3NlIGxpbmtcXG5cXHRcXHRcXHRwcmV2VGV4dDogXFxcIlByZXZcXFwiLCAvLyBEaXNwbGF5IHRleHQgZm9yIHByZXZpb3VzIG1vbnRoIGxpbmtcXG5cXHRcXHRcXHRuZXh0VGV4dDogXFxcIk5leHRcXFwiLCAvLyBEaXNwbGF5IHRleHQgZm9yIG5leHQgbW9udGggbGlua1xcblxcdFxcdFxcdGN1cnJlbnRUZXh0OiBcXFwiVG9kYXlcXFwiLCAvLyBEaXNwbGF5IHRleHQgZm9yIGN1cnJlbnQgbW9udGggbGlua1xcblxcdFxcdFxcdG1vbnRoTmFtZXM6IFtcXFwiSmFudWFyeVxcXCIsIFxcXCJGZWJydWFyeVxcXCIsIFxcXCJNYXJjaFxcXCIsIFxcXCJBcHJpbFxcXCIsIFxcXCJNYXlcXFwiLCBcXFwiSnVuZVxcXCIsIFxcXCJKdWx5XFxcIiwgXFxcIkF1Z3VzdFxcXCIsIFxcXCJTZXB0ZW1iZXJcXFwiLCBcXFwiT2N0b2JlclxcXCIsIFxcXCJOb3ZlbWJlclxcXCIsIFxcXCJEZWNlbWJlclxcXCJdLCAvLyBOYW1lcyBvZiBtb250aHMgZm9yIGRyb3AtZG93biBhbmQgZm9ybWF0dGluZ1xcblxcdFxcdFxcdG1vbnRoTmFtZXNTaG9ydDogW1xcXCJKYW5cXFwiLCBcXFwiRmViXFxcIiwgXFxcIk1hclxcXCIsIFxcXCJBcHJcXFwiLCBcXFwiTWF5XFxcIiwgXFxcIkp1blxcXCIsIFxcXCJKdWxcXFwiLCBcXFwiQXVnXFxcIiwgXFxcIlNlcFxcXCIsIFxcXCJPY3RcXFwiLCBcXFwiTm92XFxcIiwgXFxcIkRlY1xcXCJdLCAvLyBGb3IgZm9ybWF0dGluZ1xcblxcdFxcdFxcdGRheU5hbWVzOiBbXFxcIlN1bmRheVxcXCIsIFxcXCJNb25kYXlcXFwiLCBcXFwiVHVlc2RheVxcXCIsIFxcXCJXZWRuZXNkYXlcXFwiLCBcXFwiVGh1cnNkYXlcXFwiLCBcXFwiRnJpZGF5XFxcIiwgXFxcIlNhdHVyZGF5XFxcIl0sIC8vIEZvciBmb3JtYXR0aW5nXFxuXFx0XFx0XFx0ZGF5TmFtZXNTaG9ydDogW1xcXCJTdW5cXFwiLCBcXFwiTW9uXFxcIiwgXFxcIlR1ZVxcXCIsIFxcXCJXZWRcXFwiLCBcXFwiVGh1XFxcIiwgXFxcIkZyaVxcXCIsIFxcXCJTYXRcXFwiXSwgLy8gRm9yIGZvcm1hdHRpbmdcXG5cXHRcXHRcXHRkYXlOYW1lc01pbjogW1xcXCJTdVxcXCIsIFxcXCJNb1xcXCIsIFxcXCJUdVxcXCIsIFxcXCJXZVxcXCIsIFxcXCJUaFxcXCIsIFxcXCJGclxcXCIsIFxcXCJTYVxcXCJdLCAvLyBDb2x1bW4gaGVhZGluZ3MgZm9yIGRheXMgc3RhcnRpbmcgYXQgU3VuZGF5XFxuXFx0XFx0XFx0d2Vla0hlYWRlcjogXFxcIldrXFxcIiwgLy8gQ29sdW1uIGhlYWRlciBmb3Igd2VlayBvZiB0aGUgeWVhclxcblxcdFxcdFxcdGRhdGVGb3JtYXQ6IFxcXCJtbS9kZC95eVxcXCIsIC8vIFNlZSBmb3JtYXQgb3B0aW9ucyBvbiBwYXJzZURhdGVcXG5cXHRcXHRcXHRmaXJzdERheTogMCwgLy8gVGhlIGZpcnN0IGRheSBvZiB0aGUgd2VlaywgU3VuID0gMCwgTW9uID0gMSwgLi4uXFxuXFx0XFx0XFx0aXNSVEw6IGZhbHNlLCAvLyBUcnVlIGlmIHJpZ2h0LXRvLWxlZnQgbGFuZ3VhZ2UsIGZhbHNlIGlmIGxlZnQtdG8tcmlnaHRcXG5cXHRcXHRcXHRzaG93TW9udGhBZnRlclllYXI6IGZhbHNlLCAvLyBUcnVlIGlmIHRoZSB5ZWFyIHNlbGVjdCBwcmVjZWRlcyBtb250aCwgZmFsc2UgZm9yIG1vbnRoIHRoZW4geWVhclxcblxcdFxcdFxcdHllYXJTdWZmaXg6IFxcXCJcXFwiIC8vIEFkZGl0aW9uYWwgdGV4dCB0byBhcHBlbmQgdG8gdGhlIHllYXIgaW4gdGhlIG1vbnRoIGhlYWRlcnNcXG5cXHRcXHR9O1xcblxcdFxcdHRoaXMuX2RlZmF1bHRzID0geyAvLyBHbG9iYWwgZGVmYXVsdHMgZm9yIGFsbCB0aGUgZGF0ZSBwaWNrZXIgaW5zdGFuY2VzXFxuXFx0XFx0XFx0c2hvd09uOiBcXFwiZm9jdXNcXFwiLCAvLyBcXFwiZm9jdXNcXFwiIGZvciBwb3B1cCBvbiBmb2N1cyxcXG5cXHRcXHRcXHQvLyBcXFwiYnV0dG9uXFxcIiBmb3IgdHJpZ2dlciBidXR0b24sIG9yIFxcXCJib3RoXFxcIiBmb3IgZWl0aGVyXFxuXFx0XFx0XFx0c2hvd0FuaW06IFxcXCJmYWRlSW5cXFwiLCAvLyBOYW1lIG9mIGpRdWVyeSBhbmltYXRpb24gZm9yIHBvcHVwXFxuXFx0XFx0XFx0c2hvd09wdGlvbnM6IHt9LCAvLyBPcHRpb25zIGZvciBlbmhhbmNlZCBhbmltYXRpb25zXFxuXFx0XFx0XFx0ZGVmYXVsdERhdGU6IG51bGwsIC8vIFVzZWQgd2hlbiBmaWVsZCBpcyBibGFuazogYWN0dWFsIGRhdGUsXFxuXFx0XFx0XFx0Ly8gKy8tbnVtYmVyIGZvciBvZmZzZXQgZnJvbSB0b2RheSwgbnVsbCBmb3IgdG9kYXlcXG5cXHRcXHRcXHRhcHBlbmRUZXh0OiBcXFwiXFxcIiwgLy8gRGlzcGxheSB0ZXh0IGZvbGxvd2luZyB0aGUgaW5wdXQgYm94LCBlLmcuIHNob3dpbmcgdGhlIGZvcm1hdFxcblxcdFxcdFxcdGJ1dHRvblRleHQ6IFxcXCIuLi5cXFwiLCAvLyBUZXh0IGZvciB0cmlnZ2VyIGJ1dHRvblxcblxcdFxcdFxcdGJ1dHRvbkltYWdlOiBcXFwiXFxcIiwgLy8gVVJMIGZvciB0cmlnZ2VyIGJ1dHRvbiBpbWFnZVxcblxcdFxcdFxcdGJ1dHRvbkltYWdlT25seTogZmFsc2UsIC8vIFRydWUgaWYgdGhlIGltYWdlIGFwcGVhcnMgYWxvbmUsIGZhbHNlIGlmIGl0IGFwcGVhcnMgb24gYSBidXR0b25cXG5cXHRcXHRcXHRoaWRlSWZOb1ByZXZOZXh0OiBmYWxzZSwgLy8gVHJ1ZSB0byBoaWRlIG5leHQvcHJldmlvdXMgbW9udGggbGlua3NcXG5cXHRcXHRcXHQvLyBpZiBub3QgYXBwbGljYWJsZSwgZmFsc2UgdG8ganVzdCBkaXNhYmxlIHRoZW1cXG5cXHRcXHRcXHRuYXZpZ2F0aW9uQXNEYXRlRm9ybWF0OiBmYWxzZSwgLy8gVHJ1ZSBpZiBkYXRlIGZvcm1hdHRpbmcgYXBwbGllZCB0byBwcmV2L3RvZGF5L25leHQgbGlua3NcXG5cXHRcXHRcXHRnb3RvQ3VycmVudDogZmFsc2UsIC8vIFRydWUgaWYgdG9kYXkgbGluayBnb2VzIGJhY2sgdG8gY3VycmVudCBzZWxlY3Rpb24gaW5zdGVhZFxcblxcdFxcdFxcdGNoYW5nZU1vbnRoOiBmYWxzZSwgLy8gVHJ1ZSBpZiBtb250aCBjYW4gYmUgc2VsZWN0ZWQgZGlyZWN0bHksIGZhbHNlIGlmIG9ubHkgcHJldi9uZXh0XFxuXFx0XFx0XFx0Y2hhbmdlWWVhcjogZmFsc2UsIC8vIFRydWUgaWYgeWVhciBjYW4gYmUgc2VsZWN0ZWQgZGlyZWN0bHksIGZhbHNlIGlmIG9ubHkgcHJldi9uZXh0XFxuXFx0XFx0XFx0eWVhclJhbmdlOiBcXFwiYy0xMDpjKzEwXFxcIiwgLy8gUmFuZ2Ugb2YgeWVhcnMgdG8gZGlzcGxheSBpbiBkcm9wLWRvd24sXFxuXFx0XFx0XFx0Ly8gZWl0aGVyIHJlbGF0aXZlIHRvIHRvZGF5J3MgeWVhciAoLW5uOitubiksIHJlbGF0aXZlIHRvIGN1cnJlbnRseSBkaXNwbGF5ZWQgeWVhclxcblxcdFxcdFxcdC8vIChjLW5uOmMrbm4pLCBhYnNvbHV0ZSAobm5ubjpubm5uKSwgb3IgYSBjb21iaW5hdGlvbiBvZiB0aGUgYWJvdmUgKG5ubm46LW4pXFxuXFx0XFx0XFx0c2hvd090aGVyTW9udGhzOiBmYWxzZSwgLy8gVHJ1ZSB0byBzaG93IGRhdGVzIGluIG90aGVyIG1vbnRocywgZmFsc2UgdG8gbGVhdmUgYmxhbmtcXG5cXHRcXHRcXHRzZWxlY3RPdGhlck1vbnRoczogZmFsc2UsIC8vIFRydWUgdG8gYWxsb3cgc2VsZWN0aW9uIG9mIGRhdGVzIGluIG90aGVyIG1vbnRocywgZmFsc2UgZm9yIHVuc2VsZWN0YWJsZVxcblxcdFxcdFxcdHNob3dXZWVrOiBmYWxzZSwgLy8gVHJ1ZSB0byBzaG93IHdlZWsgb2YgdGhlIHllYXIsIGZhbHNlIHRvIG5vdCBzaG93IGl0XFxuXFx0XFx0XFx0Y2FsY3VsYXRlV2VlazogdGhpcy5pc284NjAxV2VlaywgLy8gSG93IHRvIGNhbGN1bGF0ZSB0aGUgd2VlayBvZiB0aGUgeWVhcixcXG5cXHRcXHRcXHQvLyB0YWtlcyBhIERhdGUgYW5kIHJldHVybnMgdGhlIG51bWJlciBvZiB0aGUgd2VlayBmb3IgaXRcXG5cXHRcXHRcXHRzaG9ydFllYXJDdXRvZmY6IFxcXCIrMTBcXFwiLCAvLyBTaG9ydCB5ZWFyIHZhbHVlcyA8IHRoaXMgYXJlIGluIHRoZSBjdXJyZW50IGNlbnR1cnksXFxuXFx0XFx0XFx0Ly8gPiB0aGlzIGFyZSBpbiB0aGUgcHJldmlvdXMgY2VudHVyeSxcXG5cXHRcXHRcXHQvLyBzdHJpbmcgdmFsdWUgc3RhcnRpbmcgd2l0aCBcXFwiK1xcXCIgZm9yIGN1cnJlbnQgeWVhciArIHZhbHVlXFxuXFx0XFx0XFx0bWluRGF0ZTogbnVsbCwgLy8gVGhlIGVhcmxpZXN0IHNlbGVjdGFibGUgZGF0ZSwgb3IgbnVsbCBmb3Igbm8gbGltaXRcXG5cXHRcXHRcXHRtYXhEYXRlOiBudWxsLCAvLyBUaGUgbGF0ZXN0IHNlbGVjdGFibGUgZGF0ZSwgb3IgbnVsbCBmb3Igbm8gbGltaXRcXG5cXHRcXHRcXHRkdXJhdGlvbjogXFxcImZhc3RcXFwiLCAvLyBEdXJhdGlvbiBvZiBkaXNwbGF5L2Nsb3N1cmVcXG5cXHRcXHRcXHRiZWZvcmVTaG93RGF5OiBudWxsLCAvLyBGdW5jdGlvbiB0aGF0IHRha2VzIGEgZGF0ZSBhbmQgcmV0dXJucyBhbiBhcnJheSB3aXRoXFxuXFx0XFx0XFx0Ly8gWzBdID0gdHJ1ZSBpZiBzZWxlY3RhYmxlLCBmYWxzZSBpZiBub3QsIFsxXSA9IGN1c3RvbSBDU1MgY2xhc3MgbmFtZShzKSBvciBcXFwiXFxcIixcXG5cXHRcXHRcXHQvLyBbMl0gPSBjZWxsIHRpdGxlIChvcHRpb25hbCksIGUuZy4gJC5kYXRlcGlja2VyLm5vV2Vla2VuZHNcXG5cXHRcXHRcXHRiZWZvcmVTaG93OiBudWxsLCAvLyBGdW5jdGlvbiB0aGF0IHRha2VzIGFuIGlucHV0IGZpZWxkIGFuZFxcblxcdFxcdFxcdC8vIHJldHVybnMgYSBzZXQgb2YgY3VzdG9tIHNldHRpbmdzIGZvciB0aGUgZGF0ZSBwaWNrZXJcXG5cXHRcXHRcXHRvblNlbGVjdDogbnVsbCwgLy8gRGVmaW5lIGEgY2FsbGJhY2sgZnVuY3Rpb24gd2hlbiBhIGRhdGUgaXMgc2VsZWN0ZWRcXG5cXHRcXHRcXHRvbkNoYW5nZU1vbnRoWWVhcjogbnVsbCwgLy8gRGVmaW5lIGEgY2FsbGJhY2sgZnVuY3Rpb24gd2hlbiB0aGUgbW9udGggb3IgeWVhciBpcyBjaGFuZ2VkXFxuXFx0XFx0XFx0b25DbG9zZTogbnVsbCwgLy8gRGVmaW5lIGEgY2FsbGJhY2sgZnVuY3Rpb24gd2hlbiB0aGUgZGF0ZXBpY2tlciBpcyBjbG9zZWRcXG5cXHRcXHRcXHRudW1iZXJPZk1vbnRoczogMSwgLy8gTnVtYmVyIG9mIG1vbnRocyB0byBzaG93IGF0IGEgdGltZVxcblxcdFxcdFxcdHNob3dDdXJyZW50QXRQb3M6IDAsIC8vIFRoZSBwb3NpdGlvbiBpbiBtdWx0aXBlIG1vbnRocyBhdCB3aGljaCB0byBzaG93IHRoZSBjdXJyZW50IG1vbnRoIChzdGFydGluZyBhdCAwKVxcblxcdFxcdFxcdHN0ZXBNb250aHM6IDEsIC8vIE51bWJlciBvZiBtb250aHMgdG8gc3RlcCBiYWNrL2ZvcndhcmRcXG5cXHRcXHRcXHRzdGVwQmlnTW9udGhzOiAxMiwgLy8gTnVtYmVyIG9mIG1vbnRocyB0byBzdGVwIGJhY2svZm9yd2FyZCBmb3IgdGhlIGJpZyBsaW5rc1xcblxcdFxcdFxcdGFsdEZpZWxkOiBcXFwiXFxcIiwgLy8gU2VsZWN0b3IgZm9yIGFuIGFsdGVybmF0ZSBmaWVsZCB0byBzdG9yZSBzZWxlY3RlZCBkYXRlcyBpbnRvXFxuXFx0XFx0XFx0YWx0Rm9ybWF0OiBcXFwiXFxcIiwgLy8gVGhlIGRhdGUgZm9ybWF0IHRvIHVzZSBmb3IgdGhlIGFsdGVybmF0ZSBmaWVsZFxcblxcdFxcdFxcdGNvbnN0cmFpbklucHV0OiB0cnVlLCAvLyBUaGUgaW5wdXQgaXMgY29uc3RyYWluZWQgYnkgdGhlIGN1cnJlbnQgZGF0ZSBmb3JtYXRcXG5cXHRcXHRcXHRzaG93QnV0dG9uUGFuZWw6IGZhbHNlLCAvLyBUcnVlIHRvIHNob3cgYnV0dG9uIHBhbmVsLCBmYWxzZSB0byBub3Qgc2hvdyBpdFxcblxcdFxcdFxcdGF1dG9TaXplOiBmYWxzZSwgLy8gVHJ1ZSB0byBzaXplIHRoZSBpbnB1dCBmb3IgdGhlIGRhdGUgZm9ybWF0LCBmYWxzZSB0byBsZWF2ZSBhcyBpc1xcblxcdFxcdFxcdGRpc2FibGVkOiBmYWxzZSAvLyBUaGUgaW5pdGlhbCBkaXNhYmxlZCBzdGF0ZVxcblxcdFxcdH07XFxuXFx0XFx0JC5leHRlbmQodGhpcy5fZGVmYXVsdHMsIHRoaXMucmVnaW9uYWxbXFxcIlxcXCJdKTtcXG5cXHRcXHR0aGlzLnJlZ2lvbmFsLmVuID0gJC5leHRlbmQodHJ1ZSwge30sIHRoaXMucmVnaW9uYWxbXFxcIlxcXCJdKTtcXG5cXHRcXHR0aGlzLnJlZ2lvbmFsW1xcXCJlbi1VU1xcXCJdID0gJC5leHRlbmQodHJ1ZSwge30sIHRoaXMucmVnaW9uYWwuZW4pO1xcblxcdFxcdHRoaXMuZHBEaXYgPSBkYXRlcGlja2VyX2JpbmRIb3ZlcigkKFxcXCI8ZGl2IGlkPSdcXFwiICsgdGhpcy5fbWFpbkRpdklkICsgXFxcIicgY2xhc3M9J3VpLWRhdGVwaWNrZXIgdWktd2lkZ2V0IHVpLXdpZGdldC1jb250ZW50IHVpLWhlbHBlci1jbGVhcmZpeCB1aS1jb3JuZXItYWxsJz48L2Rpdj5cXFwiKSk7XFxuXFx0fVxcblxcblxcdCQuZXh0ZW5kKERhdGVwaWNrZXIucHJvdG90eXBlLCB7XFxuXFx0XFx0LyogQ2xhc3MgbmFtZSBhZGRlZCB0byBlbGVtZW50cyB0byBpbmRpY2F0ZSBhbHJlYWR5IGNvbmZpZ3VyZWQgd2l0aCBhIGRhdGUgcGlja2VyLiAqL1xcblxcdFxcdG1hcmtlckNsYXNzTmFtZTogXFxcImhhc0RhdGVwaWNrZXJcXFwiLFxcblxcblxcdFxcdC8vS2VlcCB0cmFjayBvZiB0aGUgbWF4aW11bSBudW1iZXIgb2Ygcm93cyBkaXNwbGF5ZWQgKHNlZSAjNzA0MylcXG5cXHRcXHRtYXhSb3dzOiA0LFxcblxcblxcdFxcdC8vIFRPRE8gcmVuYW1lIHRvIFxcXCJ3aWRnZXRcXFwiIHdoZW4gc3dpdGNoaW5nIHRvIHdpZGdldCBmYWN0b3J5XFxuXFx0XFx0X3dpZGdldERhdGVwaWNrZXI6IGZ1bmN0aW9uIF93aWRnZXREYXRlcGlja2VyKCkge1xcblxcdFxcdFxcdHJldHVybiB0aGlzLmRwRGl2O1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0LyogT3ZlcnJpZGUgdGhlIGRlZmF1bHQgc2V0dGluZ3MgZm9yIGFsbCBpbnN0YW5jZXMgb2YgdGhlIGRhdGUgcGlja2VyLlxcbiAgICogQHBhcmFtICBzZXR0aW5ncyAgb2JqZWN0IC0gdGhlIG5ldyBzZXR0aW5ncyB0byB1c2UgYXMgZGVmYXVsdHMgKGFub255bW91cyBvYmplY3QpXFxuICAgKiBAcmV0dXJuIHRoZSBtYW5hZ2VyIG9iamVjdFxcbiAgICovXFxuXFx0XFx0c2V0RGVmYXVsdHM6IGZ1bmN0aW9uIHNldERlZmF1bHRzKHNldHRpbmdzKSB7XFxuXFx0XFx0XFx0ZGF0ZXBpY2tlcl9leHRlbmRSZW1vdmUodGhpcy5fZGVmYXVsdHMsIHNldHRpbmdzIHx8IHt9KTtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXHRcXHR9LFxcblxcblxcdFxcdC8qIEF0dGFjaCB0aGUgZGF0ZSBwaWNrZXIgdG8gYSBqUXVlcnkgc2VsZWN0aW9uLlxcbiAgICogQHBhcmFtICB0YXJnZXRcXHRlbGVtZW50IC0gdGhlIHRhcmdldCBpbnB1dCBmaWVsZCBvciBkaXZpc2lvbiBvciBzcGFuXFxuICAgKiBAcGFyYW0gIHNldHRpbmdzICBvYmplY3QgLSB0aGUgbmV3IHNldHRpbmdzIHRvIHVzZSBmb3IgdGhpcyBkYXRlIHBpY2tlciBpbnN0YW5jZSAoYW5vbnltb3VzKVxcbiAgICovXFxuXFx0XFx0X2F0dGFjaERhdGVwaWNrZXI6IGZ1bmN0aW9uIF9hdHRhY2hEYXRlcGlja2VyKHRhcmdldCwgc2V0dGluZ3MpIHtcXG5cXHRcXHRcXHR2YXIgbm9kZU5hbWUsIGlubGluZSwgaW5zdDtcXG5cXHRcXHRcXHRub2RlTmFtZSA9IHRhcmdldC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xcblxcdFxcdFxcdGlubGluZSA9IG5vZGVOYW1lID09PSBcXFwiZGl2XFxcIiB8fCBub2RlTmFtZSA9PT0gXFxcInNwYW5cXFwiO1xcblxcdFxcdFxcdGlmICghdGFyZ2V0LmlkKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy51dWlkICs9IDE7XFxuXFx0XFx0XFx0XFx0dGFyZ2V0LmlkID0gXFxcImRwXFxcIiArIHRoaXMudXVpZDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aW5zdCA9IHRoaXMuX25ld0luc3QoJCh0YXJnZXQpLCBpbmxpbmUpO1xcblxcdFxcdFxcdGluc3Quc2V0dGluZ3MgPSAkLmV4dGVuZCh7fSwgc2V0dGluZ3MgfHwge30pO1xcblxcdFxcdFxcdGlmIChub2RlTmFtZSA9PT0gXFxcImlucHV0XFxcIikge1xcblxcdFxcdFxcdFxcdHRoaXMuX2Nvbm5lY3REYXRlcGlja2VyKHRhcmdldCwgaW5zdCk7XFxuXFx0XFx0XFx0fSBlbHNlIGlmIChpbmxpbmUpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9pbmxpbmVEYXRlcGlja2VyKHRhcmdldCwgaW5zdCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFxuXFx0XFx0LyogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9iamVjdC4gKi9cXG5cXHRcXHRfbmV3SW5zdDogZnVuY3Rpb24gX25ld0luc3QodGFyZ2V0LCBpbmxpbmUpIHtcXG5cXHRcXHRcXHR2YXIgaWQgPSB0YXJnZXRbMF0uaWQucmVwbGFjZSgvKFteQS1aYS16MC05X1xcXFwtXSkvZywgXFxcIlxcXFxcXFxcXFxcXFxcXFwkMVxcXCIpOyAvLyBlc2NhcGUgalF1ZXJ5IG1ldGEgY2hhcnNcXG5cXHRcXHRcXHRyZXR1cm4geyBpZDogaWQsIGlucHV0OiB0YXJnZXQsIC8vIGFzc29jaWF0ZWQgdGFyZ2V0XFxuXFx0XFx0XFx0XFx0c2VsZWN0ZWREYXk6IDAsIHNlbGVjdGVkTW9udGg6IDAsIHNlbGVjdGVkWWVhcjogMCwgLy8gY3VycmVudCBzZWxlY3Rpb25cXG5cXHRcXHRcXHRcXHRkcmF3TW9udGg6IDAsIGRyYXdZZWFyOiAwLCAvLyBtb250aCBiZWluZyBkcmF3blxcblxcdFxcdFxcdFxcdGlubGluZTogaW5saW5lLCAvLyBpcyBkYXRlcGlja2VyIGlubGluZSBvciBub3RcXG5cXHRcXHRcXHRcXHRkcERpdjogIWlubGluZSA/IHRoaXMuZHBEaXYgOiAvLyBwcmVzZW50YXRpb24gZGl2XFxuXFx0XFx0XFx0XFx0ZGF0ZXBpY2tlcl9iaW5kSG92ZXIoJChcXFwiPGRpdiBjbGFzcz0nXFxcIiArIHRoaXMuX2lubGluZUNsYXNzICsgXFxcIiB1aS1kYXRlcGlja2VyIHVpLXdpZGdldCB1aS13aWRnZXQtY29udGVudCB1aS1oZWxwZXItY2xlYXJmaXggdWktY29ybmVyLWFsbCc+PC9kaXY+XFxcIikpIH07XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvKiBBdHRhY2ggdGhlIGRhdGUgcGlja2VyIHRvIGFuIGlucHV0IGZpZWxkLiAqL1xcblxcdFxcdF9jb25uZWN0RGF0ZXBpY2tlcjogZnVuY3Rpb24gX2Nvbm5lY3REYXRlcGlja2VyKHRhcmdldCwgaW5zdCkge1xcblxcdFxcdFxcdHZhciBpbnB1dCA9ICQodGFyZ2V0KTtcXG5cXHRcXHRcXHRpbnN0LmFwcGVuZCA9ICQoW10pO1xcblxcdFxcdFxcdGluc3QudHJpZ2dlciA9ICQoW10pO1xcblxcdFxcdFxcdGlmIChpbnB1dC5oYXNDbGFzcyh0aGlzLm1hcmtlckNsYXNzTmFtZSkpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHRoaXMuX2F0dGFjaG1lbnRzKGlucHV0LCBpbnN0KTtcXG5cXHRcXHRcXHRpbnB1dC5hZGRDbGFzcyh0aGlzLm1hcmtlckNsYXNzTmFtZSkua2V5ZG93bih0aGlzLl9kb0tleURvd24pLmtleXByZXNzKHRoaXMuX2RvS2V5UHJlc3MpLmtleXVwKHRoaXMuX2RvS2V5VXApO1xcblxcdFxcdFxcdHRoaXMuX2F1dG9TaXplKGluc3QpO1xcblxcdFxcdFxcdCQuZGF0YSh0YXJnZXQsIFxcXCJkYXRlcGlja2VyXFxcIiwgaW5zdCk7XFxuXFx0XFx0XFx0Ly9JZiBkaXNhYmxlZCBvcHRpb24gaXMgdHJ1ZSwgZGlzYWJsZSB0aGUgZGF0ZXBpY2tlciBvbmNlIGl0IGhhcyBiZWVuIGF0dGFjaGVkIHRvIHRoZSBpbnB1dCAoc2VlIHRpY2tldCAjNTY2NSlcXG5cXHRcXHRcXHRpZiAoaW5zdC5zZXR0aW5ncy5kaXNhYmxlZCkge1xcblxcdFxcdFxcdFxcdHRoaXMuX2Rpc2FibGVEYXRlcGlja2VyKHRhcmdldCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFxuXFx0XFx0LyogTWFrZSBhdHRhY2htZW50cyBiYXNlZCBvbiBzZXR0aW5ncy4gKi9cXG5cXHRcXHRfYXR0YWNobWVudHM6IGZ1bmN0aW9uIF9hdHRhY2htZW50cyhpbnB1dCwgaW5zdCkge1xcblxcdFxcdFxcdHZhciBzaG93T24sXFxuXFx0XFx0XFx0ICAgIGJ1dHRvblRleHQsXFxuXFx0XFx0XFx0ICAgIGJ1dHRvbkltYWdlLFxcblxcdFxcdFxcdCAgICBhcHBlbmRUZXh0ID0gdGhpcy5fZ2V0KGluc3QsIFxcXCJhcHBlbmRUZXh0XFxcIiksXFxuXFx0XFx0XFx0ICAgIGlzUlRMID0gdGhpcy5fZ2V0KGluc3QsIFxcXCJpc1JUTFxcXCIpO1xcblxcblxcdFxcdFxcdGlmIChpbnN0LmFwcGVuZCkge1xcblxcdFxcdFxcdFxcdGluc3QuYXBwZW5kLnJlbW92ZSgpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoYXBwZW5kVGV4dCkge1xcblxcdFxcdFxcdFxcdGluc3QuYXBwZW5kID0gJChcXFwiPHNwYW4gY2xhc3M9J1xcXCIgKyB0aGlzLl9hcHBlbmRDbGFzcyArIFxcXCInPlxcXCIgKyBhcHBlbmRUZXh0ICsgXFxcIjwvc3Bhbj5cXFwiKTtcXG5cXHRcXHRcXHRcXHRpbnB1dFtpc1JUTCA/IFxcXCJiZWZvcmVcXFwiIDogXFxcImFmdGVyXFxcIl0oaW5zdC5hcHBlbmQpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpbnB1dC51bmJpbmQoXFxcImZvY3VzXFxcIiwgdGhpcy5fc2hvd0RhdGVwaWNrZXIpO1xcblxcblxcdFxcdFxcdGlmIChpbnN0LnRyaWdnZXIpIHtcXG5cXHRcXHRcXHRcXHRpbnN0LnRyaWdnZXIucmVtb3ZlKCk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHNob3dPbiA9IHRoaXMuX2dldChpbnN0LCBcXFwic2hvd09uXFxcIik7XFxuXFx0XFx0XFx0aWYgKHNob3dPbiA9PT0gXFxcImZvY3VzXFxcIiB8fCBzaG93T24gPT09IFxcXCJib3RoXFxcIikge1xcblxcdFxcdFxcdFxcdC8vIHBvcC11cCBkYXRlIHBpY2tlciB3aGVuIGluIHRoZSBtYXJrZWQgZmllbGRcXG5cXHRcXHRcXHRcXHRpbnB1dC5mb2N1cyh0aGlzLl9zaG93RGF0ZXBpY2tlcik7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmIChzaG93T24gPT09IFxcXCJidXR0b25cXFwiIHx8IHNob3dPbiA9PT0gXFxcImJvdGhcXFwiKSB7XFxuXFx0XFx0XFx0XFx0Ly8gcG9wLXVwIGRhdGUgcGlja2VyIHdoZW4gYnV0dG9uIGNsaWNrZWRcXG5cXHRcXHRcXHRcXHRidXR0b25UZXh0ID0gdGhpcy5fZ2V0KGluc3QsIFxcXCJidXR0b25UZXh0XFxcIik7XFxuXFx0XFx0XFx0XFx0YnV0dG9uSW1hZ2UgPSB0aGlzLl9nZXQoaW5zdCwgXFxcImJ1dHRvbkltYWdlXFxcIik7XFxuXFx0XFx0XFx0XFx0aW5zdC50cmlnZ2VyID0gJCh0aGlzLl9nZXQoaW5zdCwgXFxcImJ1dHRvbkltYWdlT25seVxcXCIpID8gJChcXFwiPGltZy8+XFxcIikuYWRkQ2xhc3ModGhpcy5fdHJpZ2dlckNsYXNzKS5hdHRyKHsgc3JjOiBidXR0b25JbWFnZSwgYWx0OiBidXR0b25UZXh0LCB0aXRsZTogYnV0dG9uVGV4dCB9KSA6ICQoXFxcIjxidXR0b24gdHlwZT0nYnV0dG9uJz48L2J1dHRvbj5cXFwiKS5hZGRDbGFzcyh0aGlzLl90cmlnZ2VyQ2xhc3MpLmh0bWwoIWJ1dHRvbkltYWdlID8gYnV0dG9uVGV4dCA6ICQoXFxcIjxpbWcvPlxcXCIpLmF0dHIoeyBzcmM6IGJ1dHRvbkltYWdlLCBhbHQ6IGJ1dHRvblRleHQsIHRpdGxlOiBidXR0b25UZXh0IH0pKSk7XFxuXFx0XFx0XFx0XFx0aW5wdXRbaXNSVEwgPyBcXFwiYmVmb3JlXFxcIiA6IFxcXCJhZnRlclxcXCJdKGluc3QudHJpZ2dlcik7XFxuXFx0XFx0XFx0XFx0aW5zdC50cmlnZ2VyLmNsaWNrKGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoJC5kYXRlcGlja2VyLl9kYXRlcGlja2VyU2hvd2luZyAmJiAkLmRhdGVwaWNrZXIuX2xhc3RJbnB1dCA9PT0gaW5wdXRbMF0pIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHQkLmRhdGVwaWNrZXIuX2hpZGVEYXRlcGlja2VyKCk7XFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIGlmICgkLmRhdGVwaWNrZXIuX2RhdGVwaWNrZXJTaG93aW5nICYmICQuZGF0ZXBpY2tlci5fbGFzdElucHV0ICE9PSBpbnB1dFswXSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdCQuZGF0ZXBpY2tlci5faGlkZURhdGVwaWNrZXIoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHQkLmRhdGVwaWNrZXIuX3Nob3dEYXRlcGlja2VyKGlucHV0WzBdKTtcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdCQuZGF0ZXBpY2tlci5fc2hvd0RhdGVwaWNrZXIoaW5wdXRbMF0pO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFxuXFx0XFx0LyogQXBwbHkgdGhlIG1heGltdW0gbGVuZ3RoIGZvciB0aGUgZGF0ZSBmb3JtYXQuICovXFxuXFx0XFx0X2F1dG9TaXplOiBmdW5jdGlvbiBfYXV0b1NpemUoaW5zdCkge1xcblxcdFxcdFxcdGlmICh0aGlzLl9nZXQoaW5zdCwgXFxcImF1dG9TaXplXFxcIikgJiYgIWluc3QuaW5saW5lKSB7XFxuXFx0XFx0XFx0XFx0dmFyIGZpbmRNYXgsXFxuXFx0XFx0XFx0XFx0ICAgIG1heCxcXG5cXHRcXHRcXHRcXHQgICAgbWF4SSxcXG5cXHRcXHRcXHRcXHQgICAgaSxcXG5cXHRcXHRcXHRcXHQgICAgZGF0ZSA9IG5ldyBEYXRlKDIwMDksIDEyIC0gMSwgMjApLFxcblxcdFxcdFxcdFxcdCAgICAvLyBFbnN1cmUgZG91YmxlIGRpZ2l0c1xcblxcdFxcdFxcdFxcdGRhdGVGb3JtYXQgPSB0aGlzLl9nZXQoaW5zdCwgXFxcImRhdGVGb3JtYXRcXFwiKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoZGF0ZUZvcm1hdC5tYXRjaCgvW0RNXS8pKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZmluZE1heCA9IGZ1bmN0aW9uIGZpbmRNYXgobmFtZXMpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRtYXggPSAwO1xcblxcdFxcdFxcdFxcdFxcdFxcdG1heEkgPSAwO1xcblxcdFxcdFxcdFxcdFxcdFxcdGZvciAoaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChuYW1lc1tpXS5sZW5ndGggPiBtYXgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRtYXggPSBuYW1lc1tpXS5sZW5ndGg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bWF4SSA9IGk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gbWF4STtcXG5cXHRcXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdFxcdFxcdGRhdGUuc2V0TW9udGgoZmluZE1heCh0aGlzLl9nZXQoaW5zdCwgZGF0ZUZvcm1hdC5tYXRjaCgvTU0vKSA/IFxcXCJtb250aE5hbWVzXFxcIiA6IFxcXCJtb250aE5hbWVzU2hvcnRcXFwiKSkpO1xcblxcdFxcdFxcdFxcdFxcdGRhdGUuc2V0RGF0ZShmaW5kTWF4KHRoaXMuX2dldChpbnN0LCBkYXRlRm9ybWF0Lm1hdGNoKC9ERC8pID8gXFxcImRheU5hbWVzXFxcIiA6IFxcXCJkYXlOYW1lc1Nob3J0XFxcIikpICsgMjAgLSBkYXRlLmdldERheSgpKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aW5zdC5pbnB1dC5hdHRyKFxcXCJzaXplXFxcIiwgdGhpcy5fZm9ybWF0RGF0ZShpbnN0LCBkYXRlKS5sZW5ndGgpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcblxcdFxcdC8qIEF0dGFjaCBhbiBpbmxpbmUgZGF0ZSBwaWNrZXIgdG8gYSBkaXYuICovXFxuXFx0XFx0X2lubGluZURhdGVwaWNrZXI6IGZ1bmN0aW9uIF9pbmxpbmVEYXRlcGlja2VyKHRhcmdldCwgaW5zdCkge1xcblxcdFxcdFxcdHZhciBkaXZTcGFuID0gJCh0YXJnZXQpO1xcblxcdFxcdFxcdGlmIChkaXZTcGFuLmhhc0NsYXNzKHRoaXMubWFya2VyQ2xhc3NOYW1lKSkge1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0ZGl2U3Bhbi5hZGRDbGFzcyh0aGlzLm1hcmtlckNsYXNzTmFtZSkuYXBwZW5kKGluc3QuZHBEaXYpO1xcblxcdFxcdFxcdCQuZGF0YSh0YXJnZXQsIFxcXCJkYXRlcGlja2VyXFxcIiwgaW5zdCk7XFxuXFx0XFx0XFx0dGhpcy5fc2V0RGF0ZShpbnN0LCB0aGlzLl9nZXREZWZhdWx0RGF0ZShpbnN0KSwgdHJ1ZSk7XFxuXFx0XFx0XFx0dGhpcy5fdXBkYXRlRGF0ZXBpY2tlcihpbnN0KTtcXG5cXHRcXHRcXHR0aGlzLl91cGRhdGVBbHRlcm5hdGUoaW5zdCk7XFxuXFx0XFx0XFx0Ly9JZiBkaXNhYmxlZCBvcHRpb24gaXMgdHJ1ZSwgZGlzYWJsZSB0aGUgZGF0ZXBpY2tlciBiZWZvcmUgc2hvd2luZyBpdCAoc2VlIHRpY2tldCAjNTY2NSlcXG5cXHRcXHRcXHRpZiAoaW5zdC5zZXR0aW5ncy5kaXNhYmxlZCkge1xcblxcdFxcdFxcdFxcdHRoaXMuX2Rpc2FibGVEYXRlcGlja2VyKHRhcmdldCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdC8vIFNldCBkaXNwbGF5OmJsb2NrIGluIHBsYWNlIG9mIGluc3QuZHBEaXYuc2hvdygpIHdoaWNoIHdvbid0IHdvcmsgb24gZGlzY29ubmVjdGVkIGVsZW1lbnRzXFxuXFx0XFx0XFx0Ly8gaHR0cDovL2J1Z3MuanF1ZXJ5dWkuY29tL3RpY2tldC83NTUyIC0gQSBEYXRlcGlja2VyIGNyZWF0ZWQgb24gYSBkZXRhY2hlZCBkaXYgaGFzIHplcm8gaGVpZ2h0XFxuXFx0XFx0XFx0aW5zdC5kcERpdi5jc3MoXFxcImRpc3BsYXlcXFwiLCBcXFwiYmxvY2tcXFwiKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdC8qIFBvcC11cCB0aGUgZGF0ZSBwaWNrZXIgaW4gYSBcXFwiZGlhbG9nXFxcIiBib3guXFxuICAgKiBAcGFyYW0gIGlucHV0IGVsZW1lbnQgLSBpZ25vcmVkXFxuICAgKiBAcGFyYW0gIGRhdGVcXHRzdHJpbmcgb3IgRGF0ZSAtIHRoZSBpbml0aWFsIGRhdGUgdG8gZGlzcGxheVxcbiAgICogQHBhcmFtICBvblNlbGVjdCAgZnVuY3Rpb24gLSB0aGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIGEgZGF0ZSBpcyBzZWxlY3RlZFxcbiAgICogQHBhcmFtICBzZXR0aW5ncyAgb2JqZWN0IC0gdXBkYXRlIHRoZSBkaWFsb2cgZGF0ZSBwaWNrZXIgaW5zdGFuY2UncyBzZXR0aW5ncyAoYW5vbnltb3VzIG9iamVjdClcXG4gICAqIEBwYXJhbSAgcG9zIGludFsyXSAtIGNvb3JkaW5hdGVzIGZvciB0aGUgZGlhbG9nJ3MgcG9zaXRpb24gd2l0aGluIHRoZSBzY3JlZW4gb3JcXG4gICAqXFx0XFx0XFx0XFx0XFx0ZXZlbnQgLSB3aXRoIHgveSBjb29yZGluYXRlcyBvclxcbiAgICpcXHRcXHRcXHRcXHRcXHRsZWF2ZSBlbXB0eSBmb3IgZGVmYXVsdCAoc2NyZWVuIGNlbnRyZSlcXG4gICAqIEByZXR1cm4gdGhlIG1hbmFnZXIgb2JqZWN0XFxuICAgKi9cXG5cXHRcXHRfZGlhbG9nRGF0ZXBpY2tlcjogZnVuY3Rpb24gX2RpYWxvZ0RhdGVwaWNrZXIoaW5wdXQsIGRhdGUsIG9uU2VsZWN0LCBzZXR0aW5ncywgcG9zKSB7XFxuXFx0XFx0XFx0dmFyIGlkLFxcblxcdFxcdFxcdCAgICBicm93c2VyV2lkdGgsXFxuXFx0XFx0XFx0ICAgIGJyb3dzZXJIZWlnaHQsXFxuXFx0XFx0XFx0ICAgIHNjcm9sbFgsXFxuXFx0XFx0XFx0ICAgIHNjcm9sbFksXFxuXFx0XFx0XFx0ICAgIGluc3QgPSB0aGlzLl9kaWFsb2dJbnN0OyAvLyBpbnRlcm5hbCBpbnN0YW5jZVxcblxcblxcdFxcdFxcdGlmICghaW5zdCkge1xcblxcdFxcdFxcdFxcdHRoaXMudXVpZCArPSAxO1xcblxcdFxcdFxcdFxcdGlkID0gXFxcImRwXFxcIiArIHRoaXMudXVpZDtcXG5cXHRcXHRcXHRcXHR0aGlzLl9kaWFsb2dJbnB1dCA9ICQoXFxcIjxpbnB1dCB0eXBlPSd0ZXh0JyBpZD0nXFxcIiArIGlkICsgXFxcIicgc3R5bGU9J3Bvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiAtMTAwcHg7IHdpZHRoOiAwcHg7Jy8+XFxcIik7XFxuXFx0XFx0XFx0XFx0dGhpcy5fZGlhbG9nSW5wdXQua2V5ZG93bih0aGlzLl9kb0tleURvd24pO1xcblxcdFxcdFxcdFxcdCQoXFxcImJvZHlcXFwiKS5hcHBlbmQodGhpcy5fZGlhbG9nSW5wdXQpO1xcblxcdFxcdFxcdFxcdGluc3QgPSB0aGlzLl9kaWFsb2dJbnN0ID0gdGhpcy5fbmV3SW5zdCh0aGlzLl9kaWFsb2dJbnB1dCwgZmFsc2UpO1xcblxcdFxcdFxcdFxcdGluc3Quc2V0dGluZ3MgPSB7fTtcXG5cXHRcXHRcXHRcXHQkLmRhdGEodGhpcy5fZGlhbG9nSW5wdXRbMF0sIFxcXCJkYXRlcGlja2VyXFxcIiwgaW5zdCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGRhdGVwaWNrZXJfZXh0ZW5kUmVtb3ZlKGluc3Quc2V0dGluZ3MsIHNldHRpbmdzIHx8IHt9KTtcXG5cXHRcXHRcXHRkYXRlID0gZGF0ZSAmJiBkYXRlLmNvbnN0cnVjdG9yID09PSBEYXRlID8gdGhpcy5fZm9ybWF0RGF0ZShpbnN0LCBkYXRlKSA6IGRhdGU7XFxuXFx0XFx0XFx0dGhpcy5fZGlhbG9nSW5wdXQudmFsKGRhdGUpO1xcblxcblxcdFxcdFxcdHRoaXMuX3BvcyA9IHBvcyA/IHBvcy5sZW5ndGggPyBwb3MgOiBbcG9zLnBhZ2VYLCBwb3MucGFnZVldIDogbnVsbDtcXG5cXHRcXHRcXHRpZiAoIXRoaXMuX3Bvcykge1xcblxcdFxcdFxcdFxcdGJyb3dzZXJXaWR0aCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDtcXG5cXHRcXHRcXHRcXHRicm93c2VySGVpZ2h0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDtcXG5cXHRcXHRcXHRcXHRzY3JvbGxYID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0O1xcblxcdFxcdFxcdFxcdHNjcm9sbFkgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wIHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wO1xcblxcdFxcdFxcdFxcdHRoaXMuX3BvcyA9IC8vIHNob3VsZCB1c2UgYWN0dWFsIHdpZHRoL2hlaWdodCBiZWxvd1xcblxcdFxcdFxcdFxcdFticm93c2VyV2lkdGggLyAyIC0gMTAwICsgc2Nyb2xsWCwgYnJvd3NlckhlaWdodCAvIDIgLSAxNTAgKyBzY3JvbGxZXTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gbW92ZSBpbnB1dCBvbiBzY3JlZW4gZm9yIGZvY3VzLCBidXQgaGlkZGVuIGJlaGluZCBkaWFsb2dcXG5cXHRcXHRcXHR0aGlzLl9kaWFsb2dJbnB1dC5jc3MoXFxcImxlZnRcXFwiLCB0aGlzLl9wb3NbMF0gKyAyMCArIFxcXCJweFxcXCIpLmNzcyhcXFwidG9wXFxcIiwgdGhpcy5fcG9zWzFdICsgXFxcInB4XFxcIik7XFxuXFx0XFx0XFx0aW5zdC5zZXR0aW5ncy5vblNlbGVjdCA9IG9uU2VsZWN0O1xcblxcdFxcdFxcdHRoaXMuX2luRGlhbG9nID0gdHJ1ZTtcXG5cXHRcXHRcXHR0aGlzLmRwRGl2LmFkZENsYXNzKHRoaXMuX2RpYWxvZ0NsYXNzKTtcXG5cXHRcXHRcXHR0aGlzLl9zaG93RGF0ZXBpY2tlcih0aGlzLl9kaWFsb2dJbnB1dFswXSk7XFxuXFx0XFx0XFx0aWYgKCQuYmxvY2tVSSkge1xcblxcdFxcdFxcdFxcdCQuYmxvY2tVSSh0aGlzLmRwRGl2KTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0JC5kYXRhKHRoaXMuX2RpYWxvZ0lucHV0WzBdLCBcXFwiZGF0ZXBpY2tlclxcXCIsIGluc3QpO1xcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0LyogRGV0YWNoIGEgZGF0ZXBpY2tlciBmcm9tIGl0cyBjb250cm9sLlxcbiAgICogQHBhcmFtICB0YXJnZXRcXHRlbGVtZW50IC0gdGhlIHRhcmdldCBpbnB1dCBmaWVsZCBvciBkaXZpc2lvbiBvciBzcGFuXFxuICAgKi9cXG5cXHRcXHRfZGVzdHJveURhdGVwaWNrZXI6IGZ1bmN0aW9uIF9kZXN0cm95RGF0ZXBpY2tlcih0YXJnZXQpIHtcXG5cXHRcXHRcXHR2YXIgbm9kZU5hbWUsXFxuXFx0XFx0XFx0ICAgICR0YXJnZXQgPSAkKHRhcmdldCksXFxuXFx0XFx0XFx0ICAgIGluc3QgPSAkLmRhdGEodGFyZ2V0LCBcXFwiZGF0ZXBpY2tlclxcXCIpO1xcblxcblxcdFxcdFxcdGlmICghJHRhcmdldC5oYXNDbGFzcyh0aGlzLm1hcmtlckNsYXNzTmFtZSkpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdG5vZGVOYW1lID0gdGFyZ2V0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XFxuXFx0XFx0XFx0JC5yZW1vdmVEYXRhKHRhcmdldCwgXFxcImRhdGVwaWNrZXJcXFwiKTtcXG5cXHRcXHRcXHRpZiAobm9kZU5hbWUgPT09IFxcXCJpbnB1dFxcXCIpIHtcXG5cXHRcXHRcXHRcXHRpbnN0LmFwcGVuZC5yZW1vdmUoKTtcXG5cXHRcXHRcXHRcXHRpbnN0LnRyaWdnZXIucmVtb3ZlKCk7XFxuXFx0XFx0XFx0XFx0JHRhcmdldC5yZW1vdmVDbGFzcyh0aGlzLm1hcmtlckNsYXNzTmFtZSkudW5iaW5kKFxcXCJmb2N1c1xcXCIsIHRoaXMuX3Nob3dEYXRlcGlja2VyKS51bmJpbmQoXFxcImtleWRvd25cXFwiLCB0aGlzLl9kb0tleURvd24pLnVuYmluZChcXFwia2V5cHJlc3NcXFwiLCB0aGlzLl9kb0tleVByZXNzKS51bmJpbmQoXFxcImtleXVwXFxcIiwgdGhpcy5fZG9LZXlVcCk7XFxuXFx0XFx0XFx0fSBlbHNlIGlmIChub2RlTmFtZSA9PT0gXFxcImRpdlxcXCIgfHwgbm9kZU5hbWUgPT09IFxcXCJzcGFuXFxcIikge1xcblxcdFxcdFxcdFxcdCR0YXJnZXQucmVtb3ZlQ2xhc3ModGhpcy5tYXJrZXJDbGFzc05hbWUpLmVtcHR5KCk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmIChkYXRlcGlja2VyX2luc3RBY3RpdmUgPT09IGluc3QpIHtcXG5cXHRcXHRcXHRcXHRkYXRlcGlja2VyX2luc3RBY3RpdmUgPSBudWxsO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcblxcdFxcdC8qIEVuYWJsZSB0aGUgZGF0ZSBwaWNrZXIgdG8gYSBqUXVlcnkgc2VsZWN0aW9uLlxcbiAgICogQHBhcmFtICB0YXJnZXRcXHRlbGVtZW50IC0gdGhlIHRhcmdldCBpbnB1dCBmaWVsZCBvciBkaXZpc2lvbiBvciBzcGFuXFxuICAgKi9cXG5cXHRcXHRfZW5hYmxlRGF0ZXBpY2tlcjogZnVuY3Rpb24gX2VuYWJsZURhdGVwaWNrZXIodGFyZ2V0KSB7XFxuXFx0XFx0XFx0dmFyIG5vZGVOYW1lLFxcblxcdFxcdFxcdCAgICBpbmxpbmUsXFxuXFx0XFx0XFx0ICAgICR0YXJnZXQgPSAkKHRhcmdldCksXFxuXFx0XFx0XFx0ICAgIGluc3QgPSAkLmRhdGEodGFyZ2V0LCBcXFwiZGF0ZXBpY2tlclxcXCIpO1xcblxcblxcdFxcdFxcdGlmICghJHRhcmdldC5oYXNDbGFzcyh0aGlzLm1hcmtlckNsYXNzTmFtZSkpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdG5vZGVOYW1lID0gdGFyZ2V0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XFxuXFx0XFx0XFx0aWYgKG5vZGVOYW1lID09PSBcXFwiaW5wdXRcXFwiKSB7XFxuXFx0XFx0XFx0XFx0dGFyZ2V0LmRpc2FibGVkID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0aW5zdC50cmlnZ2VyLmZpbHRlcihcXFwiYnV0dG9uXFxcIikuZWFjaChmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5kaXNhYmxlZCA9IGZhbHNlO1xcblxcdFxcdFxcdFxcdH0pLmVuZCgpLmZpbHRlcihcXFwiaW1nXFxcIikuY3NzKHsgb3BhY2l0eTogXFxcIjEuMFxcXCIsIGN1cnNvcjogXFxcIlxcXCIgfSk7XFxuXFx0XFx0XFx0fSBlbHNlIGlmIChub2RlTmFtZSA9PT0gXFxcImRpdlxcXCIgfHwgbm9kZU5hbWUgPT09IFxcXCJzcGFuXFxcIikge1xcblxcdFxcdFxcdFxcdGlubGluZSA9ICR0YXJnZXQuY2hpbGRyZW4oXFxcIi5cXFwiICsgdGhpcy5faW5saW5lQ2xhc3MpO1xcblxcdFxcdFxcdFxcdGlubGluZS5jaGlsZHJlbigpLnJlbW92ZUNsYXNzKFxcXCJ1aS1zdGF0ZS1kaXNhYmxlZFxcXCIpO1xcblxcdFxcdFxcdFxcdGlubGluZS5maW5kKFxcXCJzZWxlY3QudWktZGF0ZXBpY2tlci1tb250aCwgc2VsZWN0LnVpLWRhdGVwaWNrZXIteWVhclxcXCIpLnByb3AoXFxcImRpc2FibGVkXFxcIiwgZmFsc2UpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR0aGlzLl9kaXNhYmxlZElucHV0cyA9ICQubWFwKHRoaXMuX2Rpc2FibGVkSW5wdXRzLCBmdW5jdGlvbiAodmFsdWUpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdmFsdWUgPT09IHRhcmdldCA/IG51bGwgOiB2YWx1ZTtcXG5cXHRcXHRcXHR9KTsgLy8gZGVsZXRlIGVudHJ5XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvKiBEaXNhYmxlIHRoZSBkYXRlIHBpY2tlciB0byBhIGpRdWVyeSBzZWxlY3Rpb24uXFxuICAgKiBAcGFyYW0gIHRhcmdldFxcdGVsZW1lbnQgLSB0aGUgdGFyZ2V0IGlucHV0IGZpZWxkIG9yIGRpdmlzaW9uIG9yIHNwYW5cXG4gICAqL1xcblxcdFxcdF9kaXNhYmxlRGF0ZXBpY2tlcjogZnVuY3Rpb24gX2Rpc2FibGVEYXRlcGlja2VyKHRhcmdldCkge1xcblxcdFxcdFxcdHZhciBub2RlTmFtZSxcXG5cXHRcXHRcXHQgICAgaW5saW5lLFxcblxcdFxcdFxcdCAgICAkdGFyZ2V0ID0gJCh0YXJnZXQpLFxcblxcdFxcdFxcdCAgICBpbnN0ID0gJC5kYXRhKHRhcmdldCwgXFxcImRhdGVwaWNrZXJcXFwiKTtcXG5cXG5cXHRcXHRcXHRpZiAoISR0YXJnZXQuaGFzQ2xhc3ModGhpcy5tYXJrZXJDbGFzc05hbWUpKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRub2RlTmFtZSA9IHRhcmdldC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xcblxcdFxcdFxcdGlmIChub2RlTmFtZSA9PT0gXFxcImlucHV0XFxcIikge1xcblxcdFxcdFxcdFxcdHRhcmdldC5kaXNhYmxlZCA9IHRydWU7XFxuXFx0XFx0XFx0XFx0aW5zdC50cmlnZ2VyLmZpbHRlcihcXFwiYnV0dG9uXFxcIikuZWFjaChmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5kaXNhYmxlZCA9IHRydWU7XFxuXFx0XFx0XFx0XFx0fSkuZW5kKCkuZmlsdGVyKFxcXCJpbWdcXFwiKS5jc3MoeyBvcGFjaXR5OiBcXFwiMC41XFxcIiwgY3Vyc29yOiBcXFwiZGVmYXVsdFxcXCIgfSk7XFxuXFx0XFx0XFx0fSBlbHNlIGlmIChub2RlTmFtZSA9PT0gXFxcImRpdlxcXCIgfHwgbm9kZU5hbWUgPT09IFxcXCJzcGFuXFxcIikge1xcblxcdFxcdFxcdFxcdGlubGluZSA9ICR0YXJnZXQuY2hpbGRyZW4oXFxcIi5cXFwiICsgdGhpcy5faW5saW5lQ2xhc3MpO1xcblxcdFxcdFxcdFxcdGlubGluZS5jaGlsZHJlbigpLmFkZENsYXNzKFxcXCJ1aS1zdGF0ZS1kaXNhYmxlZFxcXCIpO1xcblxcdFxcdFxcdFxcdGlubGluZS5maW5kKFxcXCJzZWxlY3QudWktZGF0ZXBpY2tlci1tb250aCwgc2VsZWN0LnVpLWRhdGVwaWNrZXIteWVhclxcXCIpLnByb3AoXFxcImRpc2FibGVkXFxcIiwgdHJ1ZSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHRoaXMuX2Rpc2FibGVkSW5wdXRzID0gJC5tYXAodGhpcy5fZGlzYWJsZWRJbnB1dHMsIGZ1bmN0aW9uICh2YWx1ZSkge1xcblxcdFxcdFxcdFxcdHJldHVybiB2YWx1ZSA9PT0gdGFyZ2V0ID8gbnVsbCA6IHZhbHVlO1xcblxcdFxcdFxcdH0pOyAvLyBkZWxldGUgZW50cnlcXG5cXHRcXHRcXHR0aGlzLl9kaXNhYmxlZElucHV0c1t0aGlzLl9kaXNhYmxlZElucHV0cy5sZW5ndGhdID0gdGFyZ2V0O1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0LyogSXMgdGhlIGZpcnN0IGZpZWxkIGluIGEgalF1ZXJ5IGNvbGxlY3Rpb24gZGlzYWJsZWQgYXMgYSBkYXRlcGlja2VyP1xcbiAgICogQHBhcmFtICB0YXJnZXRcXHRlbGVtZW50IC0gdGhlIHRhcmdldCBpbnB1dCBmaWVsZCBvciBkaXZpc2lvbiBvciBzcGFuXFxuICAgKiBAcmV0dXJuIGJvb2xlYW4gLSB0cnVlIGlmIGRpc2FibGVkLCBmYWxzZSBpZiBlbmFibGVkXFxuICAgKi9cXG5cXHRcXHRfaXNEaXNhYmxlZERhdGVwaWNrZXI6IGZ1bmN0aW9uIF9pc0Rpc2FibGVkRGF0ZXBpY2tlcih0YXJnZXQpIHtcXG5cXHRcXHRcXHRpZiAoIXRhcmdldCkge1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9kaXNhYmxlZElucHV0cy5sZW5ndGg7IGkrKykge1xcblxcdFxcdFxcdFxcdGlmICh0aGlzLl9kaXNhYmxlZElucHV0c1tpXSA9PT0gdGFyZ2V0KSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvKiBSZXRyaWV2ZSB0aGUgaW5zdGFuY2UgZGF0YSBmb3IgdGhlIHRhcmdldCBjb250cm9sLlxcbiAgICogQHBhcmFtICB0YXJnZXQgIGVsZW1lbnQgLSB0aGUgdGFyZ2V0IGlucHV0IGZpZWxkIG9yIGRpdmlzaW9uIG9yIHNwYW5cXG4gICAqIEByZXR1cm4gIG9iamVjdCAtIHRoZSBhc3NvY2lhdGVkIGluc3RhbmNlIGRhdGFcXG4gICAqIEB0aHJvd3MgIGVycm9yIGlmIGEgalF1ZXJ5IHByb2JsZW0gZ2V0dGluZyBkYXRhXFxuICAgKi9cXG5cXHRcXHRfZ2V0SW5zdDogZnVuY3Rpb24gX2dldEluc3QodGFyZ2V0KSB7XFxuXFx0XFx0XFx0dHJ5IHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gJC5kYXRhKHRhcmdldCwgXFxcImRhdGVwaWNrZXJcXFwiKTtcXG5cXHRcXHRcXHR9IGNhdGNoIChlcnIpIHtcXG5cXHRcXHRcXHRcXHR0aHJvdyBcXFwiTWlzc2luZyBpbnN0YW5jZSBkYXRhIGZvciB0aGlzIGRhdGVwaWNrZXJcXFwiO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcblxcdFxcdC8qIFVwZGF0ZSBvciByZXRyaWV2ZSB0aGUgc2V0dGluZ3MgZm9yIGEgZGF0ZSBwaWNrZXIgYXR0YWNoZWQgdG8gYW4gaW5wdXQgZmllbGQgb3IgZGl2aXNpb24uXFxuICAgKiBAcGFyYW0gIHRhcmdldCAgZWxlbWVudCAtIHRoZSB0YXJnZXQgaW5wdXQgZmllbGQgb3IgZGl2aXNpb24gb3Igc3BhblxcbiAgICogQHBhcmFtICBuYW1lXFx0b2JqZWN0IC0gdGhlIG5ldyBzZXR0aW5ncyB0byB1cGRhdGUgb3JcXG4gICAqXFx0XFx0XFx0XFx0c3RyaW5nIC0gdGhlIG5hbWUgb2YgdGhlIHNldHRpbmcgdG8gY2hhbmdlIG9yIHJldHJpZXZlLFxcbiAgICpcXHRcXHRcXHRcXHR3aGVuIHJldHJpZXZpbmcgYWxzbyBcXFwiYWxsXFxcIiBmb3IgYWxsIGluc3RhbmNlIHNldHRpbmdzIG9yXFxuICAgKlxcdFxcdFxcdFxcdFxcXCJkZWZhdWx0c1xcXCIgZm9yIGFsbCBnbG9iYWwgZGVmYXVsdHNcXG4gICAqIEBwYXJhbSAgdmFsdWUgICBhbnkgLSB0aGUgbmV3IHZhbHVlIGZvciB0aGUgc2V0dGluZ1xcbiAgICpcXHRcXHRcXHRcXHQob21pdCBpZiBhYm92ZSBpcyBhbiBvYmplY3Qgb3IgdG8gcmV0cmlldmUgYSB2YWx1ZSlcXG4gICAqL1xcblxcdFxcdF9vcHRpb25EYXRlcGlja2VyOiBmdW5jdGlvbiBfb3B0aW9uRGF0ZXBpY2tlcih0YXJnZXQsIG5hbWUsIHZhbHVlKSB7XFxuXFx0XFx0XFx0dmFyIHNldHRpbmdzLFxcblxcdFxcdFxcdCAgICBkYXRlLFxcblxcdFxcdFxcdCAgICBtaW5EYXRlLFxcblxcdFxcdFxcdCAgICBtYXhEYXRlLFxcblxcdFxcdFxcdCAgICBpbnN0ID0gdGhpcy5fZ2V0SW5zdCh0YXJnZXQpO1xcblxcblxcdFxcdFxcdGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyICYmIHR5cGVvZiBuYW1lID09PSBcXFwic3RyaW5nXFxcIikge1xcblxcdFxcdFxcdFxcdHJldHVybiBuYW1lID09PSBcXFwiZGVmYXVsdHNcXFwiID8gJC5leHRlbmQoe30sICQuZGF0ZXBpY2tlci5fZGVmYXVsdHMpIDogaW5zdCA/IG5hbWUgPT09IFxcXCJhbGxcXFwiID8gJC5leHRlbmQoe30sIGluc3Quc2V0dGluZ3MpIDogdGhpcy5fZ2V0KGluc3QsIG5hbWUpIDogbnVsbDtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0c2V0dGluZ3MgPSBuYW1lIHx8IHt9O1xcblxcdFxcdFxcdGlmICh0eXBlb2YgbmFtZSA9PT0gXFxcInN0cmluZ1xcXCIpIHtcXG5cXHRcXHRcXHRcXHRzZXR0aW5ncyA9IHt9O1xcblxcdFxcdFxcdFxcdHNldHRpbmdzW25hbWVdID0gdmFsdWU7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmIChpbnN0KSB7XFxuXFx0XFx0XFx0XFx0aWYgKHRoaXMuX2N1ckluc3QgPT09IGluc3QpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9oaWRlRGF0ZXBpY2tlcigpO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRkYXRlID0gdGhpcy5fZ2V0RGF0ZURhdGVwaWNrZXIodGFyZ2V0LCB0cnVlKTtcXG5cXHRcXHRcXHRcXHRtaW5EYXRlID0gdGhpcy5fZ2V0TWluTWF4RGF0ZShpbnN0LCBcXFwibWluXFxcIik7XFxuXFx0XFx0XFx0XFx0bWF4RGF0ZSA9IHRoaXMuX2dldE1pbk1heERhdGUoaW5zdCwgXFxcIm1heFxcXCIpO1xcblxcdFxcdFxcdFxcdGRhdGVwaWNrZXJfZXh0ZW5kUmVtb3ZlKGluc3Quc2V0dGluZ3MsIHNldHRpbmdzKTtcXG5cXHRcXHRcXHRcXHQvLyByZWZvcm1hdCB0aGUgb2xkIG1pbkRhdGUvbWF4RGF0ZSB2YWx1ZXMgaWYgZGF0ZUZvcm1hdCBjaGFuZ2VzIGFuZCBhIG5ldyBtaW5EYXRlL21heERhdGUgaXNuJ3QgcHJvdmlkZWRcXG5cXHRcXHRcXHRcXHRpZiAobWluRGF0ZSAhPT0gbnVsbCAmJiBzZXR0aW5ncy5kYXRlRm9ybWF0ICE9PSB1bmRlZmluZWQgJiYgc2V0dGluZ3MubWluRGF0ZSA9PT0gdW5kZWZpbmVkKSB7XFxuXFx0XFx0XFx0XFx0XFx0aW5zdC5zZXR0aW5ncy5taW5EYXRlID0gdGhpcy5fZm9ybWF0RGF0ZShpbnN0LCBtaW5EYXRlKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aWYgKG1heERhdGUgIT09IG51bGwgJiYgc2V0dGluZ3MuZGF0ZUZvcm1hdCAhPT0gdW5kZWZpbmVkICYmIHNldHRpbmdzLm1heERhdGUgPT09IHVuZGVmaW5lZCkge1xcblxcdFxcdFxcdFxcdFxcdGluc3Quc2V0dGluZ3MubWF4RGF0ZSA9IHRoaXMuX2Zvcm1hdERhdGUoaW5zdCwgbWF4RGF0ZSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGlmIChcXFwiZGlzYWJsZWRcXFwiIGluIHNldHRpbmdzKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHNldHRpbmdzLmRpc2FibGVkKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5fZGlzYWJsZURhdGVwaWNrZXIodGFyZ2V0KTtcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuX2VuYWJsZURhdGVwaWNrZXIodGFyZ2V0KTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHRoaXMuX2F0dGFjaG1lbnRzKCQodGFyZ2V0KSwgaW5zdCk7XFxuXFx0XFx0XFx0XFx0dGhpcy5fYXV0b1NpemUoaW5zdCk7XFxuXFx0XFx0XFx0XFx0dGhpcy5fc2V0RGF0ZShpbnN0LCBkYXRlKTtcXG5cXHRcXHRcXHRcXHR0aGlzLl91cGRhdGVBbHRlcm5hdGUoaW5zdCk7XFxuXFx0XFx0XFx0XFx0dGhpcy5fdXBkYXRlRGF0ZXBpY2tlcihpbnN0KTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyBjaGFuZ2UgbWV0aG9kIGRlcHJlY2F0ZWRcXG5cXHRcXHRfY2hhbmdlRGF0ZXBpY2tlcjogZnVuY3Rpb24gX2NoYW5nZURhdGVwaWNrZXIodGFyZ2V0LCBuYW1lLCB2YWx1ZSkge1xcblxcdFxcdFxcdHRoaXMuX29wdGlvbkRhdGVwaWNrZXIodGFyZ2V0LCBuYW1lLCB2YWx1ZSk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvKiBSZWRyYXcgdGhlIGRhdGUgcGlja2VyIGF0dGFjaGVkIHRvIGFuIGlucHV0IGZpZWxkIG9yIGRpdmlzaW9uLlxcbiAgICogQHBhcmFtICB0YXJnZXQgIGVsZW1lbnQgLSB0aGUgdGFyZ2V0IGlucHV0IGZpZWxkIG9yIGRpdmlzaW9uIG9yIHNwYW5cXG4gICAqL1xcblxcdFxcdF9yZWZyZXNoRGF0ZXBpY2tlcjogZnVuY3Rpb24gX3JlZnJlc2hEYXRlcGlja2VyKHRhcmdldCkge1xcblxcdFxcdFxcdHZhciBpbnN0ID0gdGhpcy5fZ2V0SW5zdCh0YXJnZXQpO1xcblxcdFxcdFxcdGlmIChpbnN0KSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5fdXBkYXRlRGF0ZXBpY2tlcihpbnN0KTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvKiBTZXQgdGhlIGRhdGVzIGZvciBhIGpRdWVyeSBzZWxlY3Rpb24uXFxuICAgKiBAcGFyYW0gIHRhcmdldCBlbGVtZW50IC0gdGhlIHRhcmdldCBpbnB1dCBmaWVsZCBvciBkaXZpc2lvbiBvciBzcGFuXFxuICAgKiBAcGFyYW0gIGRhdGVcXHREYXRlIC0gdGhlIG5ldyBkYXRlXFxuICAgKi9cXG5cXHRcXHRfc2V0RGF0ZURhdGVwaWNrZXI6IGZ1bmN0aW9uIF9zZXREYXRlRGF0ZXBpY2tlcih0YXJnZXQsIGRhdGUpIHtcXG5cXHRcXHRcXHR2YXIgaW5zdCA9IHRoaXMuX2dldEluc3QodGFyZ2V0KTtcXG5cXHRcXHRcXHRpZiAoaW5zdCkge1xcblxcdFxcdFxcdFxcdHRoaXMuX3NldERhdGUoaW5zdCwgZGF0ZSk7XFxuXFx0XFx0XFx0XFx0dGhpcy5fdXBkYXRlRGF0ZXBpY2tlcihpbnN0KTtcXG5cXHRcXHRcXHRcXHR0aGlzLl91cGRhdGVBbHRlcm5hdGUoaW5zdCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFxuXFx0XFx0LyogR2V0IHRoZSBkYXRlKHMpIGZvciB0aGUgZmlyc3QgZW50cnkgaW4gYSBqUXVlcnkgc2VsZWN0aW9uLlxcbiAgICogQHBhcmFtICB0YXJnZXQgZWxlbWVudCAtIHRoZSB0YXJnZXQgaW5wdXQgZmllbGQgb3IgZGl2aXNpb24gb3Igc3BhblxcbiAgICogQHBhcmFtICBub0RlZmF1bHQgYm9vbGVhbiAtIHRydWUgaWYgbm8gZGVmYXVsdCBkYXRlIGlzIHRvIGJlIHVzZWRcXG4gICAqIEByZXR1cm4gRGF0ZSAtIHRoZSBjdXJyZW50IGRhdGVcXG4gICAqL1xcblxcdFxcdF9nZXREYXRlRGF0ZXBpY2tlcjogZnVuY3Rpb24gX2dldERhdGVEYXRlcGlja2VyKHRhcmdldCwgbm9EZWZhdWx0KSB7XFxuXFx0XFx0XFx0dmFyIGluc3QgPSB0aGlzLl9nZXRJbnN0KHRhcmdldCk7XFxuXFx0XFx0XFx0aWYgKGluc3QgJiYgIWluc3QuaW5saW5lKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5fc2V0RGF0ZUZyb21GaWVsZChpbnN0LCBub0RlZmF1bHQpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gaW5zdCA/IHRoaXMuX2dldERhdGUoaW5zdCkgOiBudWxsO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0LyogSGFuZGxlIGtleXN0cm9rZXMuICovXFxuXFx0XFx0X2RvS2V5RG93bjogZnVuY3Rpb24gX2RvS2V5RG93bihldmVudCkge1xcblxcdFxcdFxcdHZhciBvblNlbGVjdCxcXG5cXHRcXHRcXHQgICAgZGF0ZVN0cixcXG5cXHRcXHRcXHQgICAgc2VsLFxcblxcdFxcdFxcdCAgICBpbnN0ID0gJC5kYXRlcGlja2VyLl9nZXRJbnN0KGV2ZW50LnRhcmdldCksXFxuXFx0XFx0XFx0ICAgIGhhbmRsZWQgPSB0cnVlLFxcblxcdFxcdFxcdCAgICBpc1JUTCA9IGluc3QuZHBEaXYuaXMoXFxcIi51aS1kYXRlcGlja2VyLXJ0bFxcXCIpO1xcblxcblxcdFxcdFxcdGluc3QuX2tleUV2ZW50ID0gdHJ1ZTtcXG5cXHRcXHRcXHRpZiAoJC5kYXRlcGlja2VyLl9kYXRlcGlja2VyU2hvd2luZykge1xcblxcdFxcdFxcdFxcdHN3aXRjaCAoZXZlbnQua2V5Q29kZSkge1xcblxcdFxcdFxcdFxcdFxcdGNhc2UgOTpcXG5cXHRcXHRcXHRcXHRcXHRcXHQkLmRhdGVwaWNrZXIuX2hpZGVEYXRlcGlja2VyKCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aGFuZGxlZCA9IGZhbHNlO1xcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrOyAvLyBoaWRlIG9uIHRhYiBvdXRcXG5cXHRcXHRcXHRcXHRcXHRjYXNlIDEzOlxcblxcdFxcdFxcdFxcdFxcdFxcdHNlbCA9ICQoXFxcInRkLlxcXCIgKyAkLmRhdGVwaWNrZXIuX2RheU92ZXJDbGFzcyArIFxcXCI6bm90KC5cXFwiICsgJC5kYXRlcGlja2VyLl9jdXJyZW50Q2xhc3MgKyBcXFwiKVxcXCIsIGluc3QuZHBEaXYpO1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChzZWxbMF0pIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQkLmRhdGVwaWNrZXIuX3NlbGVjdERheShldmVudC50YXJnZXQsIGluc3Quc2VsZWN0ZWRNb250aCwgaW5zdC5zZWxlY3RlZFllYXIsIHNlbFswXSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdG9uU2VsZWN0ID0gJC5kYXRlcGlja2VyLl9nZXQoaW5zdCwgXFxcIm9uU2VsZWN0XFxcIik7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKG9uU2VsZWN0KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0ZVN0ciA9ICQuZGF0ZXBpY2tlci5fZm9ybWF0RGF0ZShpbnN0KTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyB0cmlnZ2VyIGN1c3RvbSBjYWxsYmFja1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG9uU2VsZWN0LmFwcGx5KGluc3QuaW5wdXQgPyBpbnN0LmlucHV0WzBdIDogbnVsbCwgW2RhdGVTdHIsIGluc3RdKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdCQuZGF0ZXBpY2tlci5faGlkZURhdGVwaWNrZXIoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlOyAvLyBkb24ndCBzdWJtaXQgdGhlIGZvcm1cXG5cXHRcXHRcXHRcXHRcXHRjYXNlIDI3OlxcblxcdFxcdFxcdFxcdFxcdFxcdCQuZGF0ZXBpY2tlci5faGlkZURhdGVwaWNrZXIoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhazsgLy8gaGlkZSBvbiBlc2NhcGVcXG5cXHRcXHRcXHRcXHRcXHRjYXNlIDMzOlxcblxcdFxcdFxcdFxcdFxcdFxcdCQuZGF0ZXBpY2tlci5fYWRqdXN0RGF0ZShldmVudC50YXJnZXQsIGV2ZW50LmN0cmxLZXkgPyAtJC5kYXRlcGlja2VyLl9nZXQoaW5zdCwgXFxcInN0ZXBCaWdNb250aHNcXFwiKSA6IC0kLmRhdGVwaWNrZXIuX2dldChpbnN0LCBcXFwic3RlcE1vbnRoc1xcXCIpLCBcXFwiTVxcXCIpO1xcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrOyAvLyBwcmV2aW91cyBtb250aC95ZWFyIG9uIHBhZ2UgdXAvKyBjdHJsXFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAzNDpcXG5cXHRcXHRcXHRcXHRcXHRcXHQkLmRhdGVwaWNrZXIuX2FkanVzdERhdGUoZXZlbnQudGFyZ2V0LCBldmVudC5jdHJsS2V5ID8gKyQuZGF0ZXBpY2tlci5fZ2V0KGluc3QsIFxcXCJzdGVwQmlnTW9udGhzXFxcIikgOiArJC5kYXRlcGlja2VyLl9nZXQoaW5zdCwgXFxcInN0ZXBNb250aHNcXFwiKSwgXFxcIk1cXFwiKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhazsgLy8gbmV4dCBtb250aC95ZWFyIG9uIHBhZ2UgZG93bi8rIGN0cmxcXG5cXHRcXHRcXHRcXHRcXHRjYXNlIDM1OlxcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQkLmRhdGVwaWNrZXIuX2NsZWFyRGF0ZShldmVudC50YXJnZXQpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRoYW5kbGVkID0gZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5O1xcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrOyAvLyBjbGVhciBvbiBjdHJsIG9yIGNvbW1hbmQgK2VuZFxcblxcdFxcdFxcdFxcdFxcdGNhc2UgMzY6XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdCQuZGF0ZXBpY2tlci5fZ290b1RvZGF5KGV2ZW50LnRhcmdldCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdGhhbmRsZWQgPSBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7IC8vIGN1cnJlbnQgb24gY3RybCBvciBjb21tYW5kICtob21lXFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAzNzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0JC5kYXRlcGlja2VyLl9hZGp1c3REYXRlKGV2ZW50LnRhcmdldCwgaXNSVEwgPyArMSA6IC0xLCBcXFwiRFxcXCIpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRoYW5kbGVkID0gZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5O1xcblxcdFxcdFxcdFxcdFxcdFxcdC8vIC0xIGRheSBvbiBjdHJsIG9yIGNvbW1hbmQgK2xlZnRcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoZXZlbnQub3JpZ2luYWxFdmVudC5hbHRLZXkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQkLmRhdGVwaWNrZXIuX2FkanVzdERhdGUoZXZlbnQudGFyZ2V0LCBldmVudC5jdHJsS2V5ID8gLSQuZGF0ZXBpY2tlci5fZ2V0KGluc3QsIFxcXCJzdGVwQmlnTW9udGhzXFxcIikgOiAtJC5kYXRlcGlja2VyLl9nZXQoaW5zdCwgXFxcInN0ZXBNb250aHNcXFwiKSwgXFxcIk1cXFwiKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gbmV4dCBtb250aC95ZWFyIG9uIGFsdCArbGVmdCBvbiBNYWNcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRjYXNlIDM4OlxcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQkLmRhdGVwaWNrZXIuX2FkanVzdERhdGUoZXZlbnQudGFyZ2V0LCAtNywgXFxcIkRcXFwiKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0aGFuZGxlZCA9IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhazsgLy8gLTEgd2VlayBvbiBjdHJsIG9yIGNvbW1hbmQgK3VwXFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAzOTpcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0JC5kYXRlcGlja2VyLl9hZGp1c3REYXRlKGV2ZW50LnRhcmdldCwgaXNSVEwgPyAtMSA6ICsxLCBcXFwiRFxcXCIpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRoYW5kbGVkID0gZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5O1xcblxcdFxcdFxcdFxcdFxcdFxcdC8vICsxIGRheSBvbiBjdHJsIG9yIGNvbW1hbmQgK3JpZ2h0XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKGV2ZW50Lm9yaWdpbmFsRXZlbnQuYWx0S2V5KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0JC5kYXRlcGlja2VyLl9hZGp1c3REYXRlKGV2ZW50LnRhcmdldCwgZXZlbnQuY3RybEtleSA/ICskLmRhdGVwaWNrZXIuX2dldChpbnN0LCBcXFwic3RlcEJpZ01vbnRoc1xcXCIpIDogKyQuZGF0ZXBpY2tlci5fZ2V0KGluc3QsIFxcXCJzdGVwTW9udGhzXFxcIiksIFxcXCJNXFxcIik7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIG5leHQgbW9udGgveWVhciBvbiBhbHQgK3JpZ2h0XFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSA0MDpcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0JC5kYXRlcGlja2VyLl9hZGp1c3REYXRlKGV2ZW50LnRhcmdldCwgKzcsIFxcXCJEXFxcIik7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdGhhbmRsZWQgPSBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7IC8vICsxIHdlZWsgb24gY3RybCBvciBjb21tYW5kICtkb3duXFxuXFx0XFx0XFx0XFx0XFx0ZGVmYXVsdDpcXG5cXHRcXHRcXHRcXHRcXHRcXHRoYW5kbGVkID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0gZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PT0gMzYgJiYgZXZlbnQuY3RybEtleSkge1xcblxcdFxcdFxcdFxcdC8vIGRpc3BsYXkgdGhlIGRhdGUgcGlja2VyIG9uIGN0cmwraG9tZVxcblxcdFxcdFxcdFxcdCQuZGF0ZXBpY2tlci5fc2hvd0RhdGVwaWNrZXIodGhpcyk7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRoYW5kbGVkID0gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmIChoYW5kbGVkKSB7XFxuXFx0XFx0XFx0XFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG5cXHRcXHRcXHRcXHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvKiBGaWx0ZXIgZW50ZXJlZCBjaGFyYWN0ZXJzIC0gYmFzZWQgb24gZGF0ZSBmb3JtYXQuICovXFxuXFx0XFx0X2RvS2V5UHJlc3M6IGZ1bmN0aW9uIF9kb0tleVByZXNzKGV2ZW50KSB7XFxuXFx0XFx0XFx0dmFyIGNoYXJzLFxcblxcdFxcdFxcdCAgICBjaHIsXFxuXFx0XFx0XFx0ICAgIGluc3QgPSAkLmRhdGVwaWNrZXIuX2dldEluc3QoZXZlbnQudGFyZ2V0KTtcXG5cXG5cXHRcXHRcXHRpZiAoJC5kYXRlcGlja2VyLl9nZXQoaW5zdCwgXFxcImNvbnN0cmFpbklucHV0XFxcIikpIHtcXG5cXHRcXHRcXHRcXHRjaGFycyA9ICQuZGF0ZXBpY2tlci5fcG9zc2libGVDaGFycygkLmRhdGVwaWNrZXIuX2dldChpbnN0LCBcXFwiZGF0ZUZvcm1hdFxcXCIpKTtcXG5cXHRcXHRcXHRcXHRjaHIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGV2ZW50LmNoYXJDb2RlID09IG51bGwgPyBldmVudC5rZXlDb2RlIDogZXZlbnQuY2hhckNvZGUpO1xcblxcdFxcdFxcdFxcdHJldHVybiBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkgfHwgY2hyIDwgXFxcIiBcXFwiIHx8ICFjaGFycyB8fCBjaGFycy5pbmRleE9mKGNocikgPiAtMTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvKiBTeW5jaHJvbmlzZSBtYW51YWwgZW50cnkgYW5kIGZpZWxkL2FsdGVybmF0ZSBmaWVsZC4gKi9cXG5cXHRcXHRfZG9LZXlVcDogZnVuY3Rpb24gX2RvS2V5VXAoZXZlbnQpIHtcXG5cXHRcXHRcXHR2YXIgZGF0ZSxcXG5cXHRcXHRcXHQgICAgaW5zdCA9ICQuZGF0ZXBpY2tlci5fZ2V0SW5zdChldmVudC50YXJnZXQpO1xcblxcblxcdFxcdFxcdGlmIChpbnN0LmlucHV0LnZhbCgpICE9PSBpbnN0Lmxhc3RWYWwpIHtcXG5cXHRcXHRcXHRcXHR0cnkge1xcblxcdFxcdFxcdFxcdFxcdGRhdGUgPSAkLmRhdGVwaWNrZXIucGFyc2VEYXRlKCQuZGF0ZXBpY2tlci5fZ2V0KGluc3QsIFxcXCJkYXRlRm9ybWF0XFxcIiksIGluc3QuaW5wdXQgPyBpbnN0LmlucHV0LnZhbCgpIDogbnVsbCwgJC5kYXRlcGlja2VyLl9nZXRGb3JtYXRDb25maWcoaW5zdCkpO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmIChkYXRlKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gb25seSBpZiB2YWxpZFxcblxcdFxcdFxcdFxcdFxcdFxcdCQuZGF0ZXBpY2tlci5fc2V0RGF0ZUZyb21GaWVsZChpbnN0KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHQkLmRhdGVwaWNrZXIuX3VwZGF0ZUFsdGVybmF0ZShpbnN0KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHQkLmRhdGVwaWNrZXIuX3VwZGF0ZURhdGVwaWNrZXIoaW5zdCk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH0gY2F0Y2ggKGVycikge31cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvKiBQb3AtdXAgdGhlIGRhdGUgcGlja2VyIGZvciBhIGdpdmVuIGlucHV0IGZpZWxkLlxcbiAgICogSWYgZmFsc2UgcmV0dXJuZWQgZnJvbSBiZWZvcmVTaG93IGV2ZW50IGhhbmRsZXIgZG8gbm90IHNob3cuXFxuICAgKiBAcGFyYW0gIGlucHV0ICBlbGVtZW50IC0gdGhlIGlucHV0IGZpZWxkIGF0dGFjaGVkIHRvIHRoZSBkYXRlIHBpY2tlciBvclxcbiAgICpcXHRcXHRcXHRcXHRcXHRldmVudCAtIGlmIHRyaWdnZXJlZCBieSBmb2N1c1xcbiAgICovXFxuXFx0XFx0X3Nob3dEYXRlcGlja2VyOiBmdW5jdGlvbiBfc2hvd0RhdGVwaWNrZXIoaW5wdXQpIHtcXG5cXHRcXHRcXHRpbnB1dCA9IGlucHV0LnRhcmdldCB8fCBpbnB1dDtcXG5cXHRcXHRcXHRpZiAoaW5wdXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gXFxcImlucHV0XFxcIikge1xcblxcdFxcdFxcdFxcdC8vIGZpbmQgZnJvbSBidXR0b24vaW1hZ2UgdHJpZ2dlclxcblxcdFxcdFxcdFxcdGlucHV0ID0gJChcXFwiaW5wdXRcXFwiLCBpbnB1dC5wYXJlbnROb2RlKVswXTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCQuZGF0ZXBpY2tlci5faXNEaXNhYmxlZERhdGVwaWNrZXIoaW5wdXQpIHx8ICQuZGF0ZXBpY2tlci5fbGFzdElucHV0ID09PSBpbnB1dCkge1xcblxcdFxcdFxcdFxcdC8vIGFscmVhZHkgaGVyZVxcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dmFyIGluc3QsIGJlZm9yZVNob3csIGJlZm9yZVNob3dTZXR0aW5ncywgaXNGaXhlZCwgb2Zmc2V0LCBzaG93QW5pbSwgZHVyYXRpb247XFxuXFxuXFx0XFx0XFx0aW5zdCA9ICQuZGF0ZXBpY2tlci5fZ2V0SW5zdChpbnB1dCk7XFxuXFx0XFx0XFx0aWYgKCQuZGF0ZXBpY2tlci5fY3VySW5zdCAmJiAkLmRhdGVwaWNrZXIuX2N1ckluc3QgIT09IGluc3QpIHtcXG5cXHRcXHRcXHRcXHQkLmRhdGVwaWNrZXIuX2N1ckluc3QuZHBEaXYuc3RvcCh0cnVlLCB0cnVlKTtcXG5cXHRcXHRcXHRcXHRpZiAoaW5zdCAmJiAkLmRhdGVwaWNrZXIuX2RhdGVwaWNrZXJTaG93aW5nKSB7XFxuXFx0XFx0XFx0XFx0XFx0JC5kYXRlcGlja2VyLl9oaWRlRGF0ZXBpY2tlcigkLmRhdGVwaWNrZXIuX2N1ckluc3QuaW5wdXRbMF0pO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0YmVmb3JlU2hvdyA9ICQuZGF0ZXBpY2tlci5fZ2V0KGluc3QsIFxcXCJiZWZvcmVTaG93XFxcIik7XFxuXFx0XFx0XFx0YmVmb3JlU2hvd1NldHRpbmdzID0gYmVmb3JlU2hvdyA/IGJlZm9yZVNob3cuYXBwbHkoaW5wdXQsIFtpbnB1dCwgaW5zdF0pIDoge307XFxuXFx0XFx0XFx0aWYgKGJlZm9yZVNob3dTZXR0aW5ncyA9PT0gZmFsc2UpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGRhdGVwaWNrZXJfZXh0ZW5kUmVtb3ZlKGluc3Quc2V0dGluZ3MsIGJlZm9yZVNob3dTZXR0aW5ncyk7XFxuXFxuXFx0XFx0XFx0aW5zdC5sYXN0VmFsID0gbnVsbDtcXG5cXHRcXHRcXHQkLmRhdGVwaWNrZXIuX2xhc3RJbnB1dCA9IGlucHV0O1xcblxcdFxcdFxcdCQuZGF0ZXBpY2tlci5fc2V0RGF0ZUZyb21GaWVsZChpbnN0KTtcXG5cXG5cXHRcXHRcXHRpZiAoJC5kYXRlcGlja2VyLl9pbkRpYWxvZykge1xcblxcdFxcdFxcdFxcdC8vIGhpZGUgY3Vyc29yXFxuXFx0XFx0XFx0XFx0aW5wdXQudmFsdWUgPSBcXFwiXFxcIjtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKCEkLmRhdGVwaWNrZXIuX3Bvcykge1xcblxcdFxcdFxcdFxcdC8vIHBvc2l0aW9uIGJlbG93IGlucHV0XFxuXFx0XFx0XFx0XFx0JC5kYXRlcGlja2VyLl9wb3MgPSAkLmRhdGVwaWNrZXIuX2ZpbmRQb3MoaW5wdXQpO1xcblxcdFxcdFxcdFxcdCQuZGF0ZXBpY2tlci5fcG9zWzFdICs9IGlucHV0Lm9mZnNldEhlaWdodDsgLy8gYWRkIHRoZSBoZWlnaHRcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aXNGaXhlZCA9IGZhbHNlO1xcblxcdFxcdFxcdCQoaW5wdXQpLnBhcmVudHMoKS5lYWNoKGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRpc0ZpeGVkIHw9ICQodGhpcykuY3NzKFxcXCJwb3NpdGlvblxcXCIpID09PSBcXFwiZml4ZWRcXFwiO1xcblxcdFxcdFxcdFxcdHJldHVybiAhaXNGaXhlZDtcXG5cXHRcXHRcXHR9KTtcXG5cXG5cXHRcXHRcXHRvZmZzZXQgPSB7IGxlZnQ6ICQuZGF0ZXBpY2tlci5fcG9zWzBdLCB0b3A6ICQuZGF0ZXBpY2tlci5fcG9zWzFdIH07XFxuXFx0XFx0XFx0JC5kYXRlcGlja2VyLl9wb3MgPSBudWxsO1xcblxcdFxcdFxcdC8vdG8gYXZvaWQgZmxhc2hlcyBvbiBGaXJlZm94XFxuXFx0XFx0XFx0aW5zdC5kcERpdi5lbXB0eSgpO1xcblxcdFxcdFxcdC8vIGRldGVybWluZSBzaXppbmcgb2Zmc2NyZWVuXFxuXFx0XFx0XFx0aW5zdC5kcERpdi5jc3MoeyBwb3NpdGlvbjogXFxcImFic29sdXRlXFxcIiwgZGlzcGxheTogXFxcImJsb2NrXFxcIiwgdG9wOiBcXFwiLTEwMDBweFxcXCIgfSk7XFxuXFx0XFx0XFx0JC5kYXRlcGlja2VyLl91cGRhdGVEYXRlcGlja2VyKGluc3QpO1xcblxcdFxcdFxcdC8vIGZpeCB3aWR0aCBmb3IgZHluYW1pYyBudW1iZXIgb2YgZGF0ZSBwaWNrZXJzXFxuXFx0XFx0XFx0Ly8gYW5kIGFkanVzdCBwb3NpdGlvbiBiZWZvcmUgc2hvd2luZ1xcblxcdFxcdFxcdG9mZnNldCA9ICQuZGF0ZXBpY2tlci5fY2hlY2tPZmZzZXQoaW5zdCwgb2Zmc2V0LCBpc0ZpeGVkKTtcXG5cXHRcXHRcXHRpbnN0LmRwRGl2LmNzcyh7IHBvc2l0aW9uOiAkLmRhdGVwaWNrZXIuX2luRGlhbG9nICYmICQuYmxvY2tVSSA/IFxcXCJzdGF0aWNcXFwiIDogaXNGaXhlZCA/IFxcXCJmaXhlZFxcXCIgOiBcXFwiYWJzb2x1dGVcXFwiLCBkaXNwbGF5OiBcXFwibm9uZVxcXCIsXFxuXFx0XFx0XFx0XFx0bGVmdDogb2Zmc2V0LmxlZnQgKyBcXFwicHhcXFwiLCB0b3A6IG9mZnNldC50b3AgKyBcXFwicHhcXFwiIH0pO1xcblxcblxcdFxcdFxcdGlmICghaW5zdC5pbmxpbmUpIHtcXG5cXHRcXHRcXHRcXHRzaG93QW5pbSA9ICQuZGF0ZXBpY2tlci5fZ2V0KGluc3QsIFxcXCJzaG93QW5pbVxcXCIpO1xcblxcdFxcdFxcdFxcdGR1cmF0aW9uID0gJC5kYXRlcGlja2VyLl9nZXQoaW5zdCwgXFxcImR1cmF0aW9uXFxcIik7XFxuXFx0XFx0XFx0XFx0aW5zdC5kcERpdi5jc3MoXFxcInotaW5kZXhcXFwiLCBkYXRlcGlja2VyX2dldFppbmRleCgkKGlucHV0KSkgKyAxKTtcXG5cXHRcXHRcXHRcXHQkLmRhdGVwaWNrZXIuX2RhdGVwaWNrZXJTaG93aW5nID0gdHJ1ZTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoJC5lZmZlY3RzICYmICQuZWZmZWN0cy5lZmZlY3Rbc2hvd0FuaW1dKSB7XFxuXFx0XFx0XFx0XFx0XFx0aW5zdC5kcERpdi5zaG93KHNob3dBbmltLCAkLmRhdGVwaWNrZXIuX2dldChpbnN0LCBcXFwic2hvd09wdGlvbnNcXFwiKSwgZHVyYXRpb24pO1xcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0aW5zdC5kcERpdltzaG93QW5pbSB8fCBcXFwic2hvd1xcXCJdKHNob3dBbmltID8gZHVyYXRpb24gOiBudWxsKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCQuZGF0ZXBpY2tlci5fc2hvdWxkRm9jdXNJbnB1dChpbnN0KSkge1xcblxcdFxcdFxcdFxcdFxcdGluc3QuaW5wdXQuZm9jdXMoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0JC5kYXRlcGlja2VyLl9jdXJJbnN0ID0gaW5zdDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvKiBHZW5lcmF0ZSB0aGUgZGF0ZSBwaWNrZXIgY29udGVudC4gKi9cXG5cXHRcXHRfdXBkYXRlRGF0ZXBpY2tlcjogZnVuY3Rpb24gX3VwZGF0ZURhdGVwaWNrZXIoaW5zdCkge1xcblxcdFxcdFxcdHRoaXMubWF4Um93cyA9IDQ7IC8vUmVzZXQgdGhlIG1heCBudW1iZXIgb2Ygcm93cyBiZWluZyBkaXNwbGF5ZWQgKHNlZSAjNzA0MylcXG5cXHRcXHRcXHRkYXRlcGlja2VyX2luc3RBY3RpdmUgPSBpbnN0OyAvLyBmb3IgZGVsZWdhdGUgaG92ZXIgZXZlbnRzXFxuXFx0XFx0XFx0aW5zdC5kcERpdi5lbXB0eSgpLmFwcGVuZCh0aGlzLl9nZW5lcmF0ZUhUTUwoaW5zdCkpO1xcblxcdFxcdFxcdHRoaXMuX2F0dGFjaEhhbmRsZXJzKGluc3QpO1xcblxcblxcdFxcdFxcdHZhciBvcmlneWVhcnNodG1sLFxcblxcdFxcdFxcdCAgICBudW1Nb250aHMgPSB0aGlzLl9nZXROdW1iZXJPZk1vbnRocyhpbnN0KSxcXG5cXHRcXHRcXHQgICAgY29scyA9IG51bU1vbnRoc1sxXSxcXG5cXHRcXHRcXHQgICAgd2lkdGggPSAxNyxcXG5cXHRcXHRcXHQgICAgYWN0aXZlQ2VsbCA9IGluc3QuZHBEaXYuZmluZChcXFwiLlxcXCIgKyB0aGlzLl9kYXlPdmVyQ2xhc3MgKyBcXFwiIGFcXFwiKTtcXG5cXG5cXHRcXHRcXHRpZiAoYWN0aXZlQ2VsbC5sZW5ndGggPiAwKSB7XFxuXFx0XFx0XFx0XFx0ZGF0ZXBpY2tlcl9oYW5kbGVNb3VzZW92ZXIuYXBwbHkoYWN0aXZlQ2VsbC5nZXQoMCkpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpbnN0LmRwRGl2LnJlbW92ZUNsYXNzKFxcXCJ1aS1kYXRlcGlja2VyLW11bHRpLTIgdWktZGF0ZXBpY2tlci1tdWx0aS0zIHVpLWRhdGVwaWNrZXItbXVsdGktNFxcXCIpLndpZHRoKFxcXCJcXFwiKTtcXG5cXHRcXHRcXHRpZiAoY29scyA+IDEpIHtcXG5cXHRcXHRcXHRcXHRpbnN0LmRwRGl2LmFkZENsYXNzKFxcXCJ1aS1kYXRlcGlja2VyLW11bHRpLVxcXCIgKyBjb2xzKS5jc3MoXFxcIndpZHRoXFxcIiwgd2lkdGggKiBjb2xzICsgXFxcImVtXFxcIik7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGluc3QuZHBEaXZbKG51bU1vbnRoc1swXSAhPT0gMSB8fCBudW1Nb250aHNbMV0gIT09IDEgPyBcXFwiYWRkXFxcIiA6IFxcXCJyZW1vdmVcXFwiKSArIFxcXCJDbGFzc1xcXCJdKFxcXCJ1aS1kYXRlcGlja2VyLW11bHRpXFxcIik7XFxuXFx0XFx0XFx0aW5zdC5kcERpdlsodGhpcy5fZ2V0KGluc3QsIFxcXCJpc1JUTFxcXCIpID8gXFxcImFkZFxcXCIgOiBcXFwicmVtb3ZlXFxcIikgKyBcXFwiQ2xhc3NcXFwiXShcXFwidWktZGF0ZXBpY2tlci1ydGxcXFwiKTtcXG5cXG5cXHRcXHRcXHRpZiAoaW5zdCA9PT0gJC5kYXRlcGlja2VyLl9jdXJJbnN0ICYmICQuZGF0ZXBpY2tlci5fZGF0ZXBpY2tlclNob3dpbmcgJiYgJC5kYXRlcGlja2VyLl9zaG91bGRGb2N1c0lucHV0KGluc3QpKSB7XFxuXFx0XFx0XFx0XFx0aW5zdC5pbnB1dC5mb2N1cygpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBkZWZmZXJlZCByZW5kZXIgb2YgdGhlIHllYXJzIHNlbGVjdCAodG8gYXZvaWQgZmxhc2hlcyBvbiBGaXJlZm94KVxcblxcdFxcdFxcdGlmIChpbnN0LnllYXJzaHRtbCkge1xcblxcdFxcdFxcdFxcdG9yaWd5ZWFyc2h0bWwgPSBpbnN0LnllYXJzaHRtbDtcXG5cXHRcXHRcXHRcXHRzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHQvL2Fzc3VyZSB0aGF0IGluc3QueWVhcnNodG1sIGRpZG4ndCBjaGFuZ2UuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKG9yaWd5ZWFyc2h0bWwgPT09IGluc3QueWVhcnNodG1sICYmIGluc3QueWVhcnNodG1sKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aW5zdC5kcERpdi5maW5kKFxcXCJzZWxlY3QudWktZGF0ZXBpY2tlci15ZWFyOmZpcnN0XFxcIikucmVwbGFjZVdpdGgoaW5zdC55ZWFyc2h0bWwpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRvcmlneWVhcnNodG1sID0gaW5zdC55ZWFyc2h0bWwgPSBudWxsO1xcblxcdFxcdFxcdFxcdH0sIDApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcblxcdFxcdC8vICM2Njk0IC0gZG9uJ3QgZm9jdXMgdGhlIGlucHV0IGlmIGl0J3MgYWxyZWFkeSBmb2N1c2VkXFxuXFx0XFx0Ly8gdGhpcyBicmVha3MgdGhlIGNoYW5nZSBldmVudCBpbiBJRVxcblxcdFxcdC8vIFN1cHBvcnQ6IElFIGFuZCBqUXVlcnkgPDEuOVxcblxcdFxcdF9zaG91bGRGb2N1c0lucHV0OiBmdW5jdGlvbiBfc2hvdWxkRm9jdXNJbnB1dChpbnN0KSB7XFxuXFx0XFx0XFx0cmV0dXJuIGluc3QuaW5wdXQgJiYgaW5zdC5pbnB1dC5pcyhcXFwiOnZpc2libGVcXFwiKSAmJiAhaW5zdC5pbnB1dC5pcyhcXFwiOmRpc2FibGVkXFxcIikgJiYgIWluc3QuaW5wdXQuaXMoXFxcIjpmb2N1c1xcXCIpO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0LyogQ2hlY2sgcG9zaXRpb25pbmcgdG8gcmVtYWluIG9uIHNjcmVlbi4gKi9cXG5cXHRcXHRfY2hlY2tPZmZzZXQ6IGZ1bmN0aW9uIF9jaGVja09mZnNldChpbnN0LCBvZmZzZXQsIGlzRml4ZWQpIHtcXG5cXHRcXHRcXHR2YXIgZHBXaWR0aCA9IGluc3QuZHBEaXYub3V0ZXJXaWR0aCgpLFxcblxcdFxcdFxcdCAgICBkcEhlaWdodCA9IGluc3QuZHBEaXYub3V0ZXJIZWlnaHQoKSxcXG5cXHRcXHRcXHQgICAgaW5wdXRXaWR0aCA9IGluc3QuaW5wdXQgPyBpbnN0LmlucHV0Lm91dGVyV2lkdGgoKSA6IDAsXFxuXFx0XFx0XFx0ICAgIGlucHV0SGVpZ2h0ID0gaW5zdC5pbnB1dCA/IGluc3QuaW5wdXQub3V0ZXJIZWlnaHQoKSA6IDAsXFxuXFx0XFx0XFx0ICAgIHZpZXdXaWR0aCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCArIChpc0ZpeGVkID8gMCA6ICQoZG9jdW1lbnQpLnNjcm9sbExlZnQoKSksXFxuXFx0XFx0XFx0ICAgIHZpZXdIZWlnaHQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0ICsgKGlzRml4ZWQgPyAwIDogJChkb2N1bWVudCkuc2Nyb2xsVG9wKCkpO1xcblxcblxcdFxcdFxcdG9mZnNldC5sZWZ0IC09IHRoaXMuX2dldChpbnN0LCBcXFwiaXNSVExcXFwiKSA/IGRwV2lkdGggLSBpbnB1dFdpZHRoIDogMDtcXG5cXHRcXHRcXHRvZmZzZXQubGVmdCAtPSBpc0ZpeGVkICYmIG9mZnNldC5sZWZ0ID09PSBpbnN0LmlucHV0Lm9mZnNldCgpLmxlZnQgPyAkKGRvY3VtZW50KS5zY3JvbGxMZWZ0KCkgOiAwO1xcblxcdFxcdFxcdG9mZnNldC50b3AgLT0gaXNGaXhlZCAmJiBvZmZzZXQudG9wID09PSBpbnN0LmlucHV0Lm9mZnNldCgpLnRvcCArIGlucHV0SGVpZ2h0ID8gJChkb2N1bWVudCkuc2Nyb2xsVG9wKCkgOiAwO1xcblxcblxcdFxcdFxcdC8vIG5vdyBjaGVjayBpZiBkYXRlcGlja2VyIGlzIHNob3dpbmcgb3V0c2lkZSB3aW5kb3cgdmlld3BvcnQgLSBtb3ZlIHRvIGEgYmV0dGVyIHBsYWNlIGlmIHNvLlxcblxcdFxcdFxcdG9mZnNldC5sZWZ0IC09IE1hdGgubWluKG9mZnNldC5sZWZ0LCBvZmZzZXQubGVmdCArIGRwV2lkdGggPiB2aWV3V2lkdGggJiYgdmlld1dpZHRoID4gZHBXaWR0aCA/IE1hdGguYWJzKG9mZnNldC5sZWZ0ICsgZHBXaWR0aCAtIHZpZXdXaWR0aCkgOiAwKTtcXG5cXHRcXHRcXHRvZmZzZXQudG9wIC09IE1hdGgubWluKG9mZnNldC50b3AsIG9mZnNldC50b3AgKyBkcEhlaWdodCA+IHZpZXdIZWlnaHQgJiYgdmlld0hlaWdodCA+IGRwSGVpZ2h0ID8gTWF0aC5hYnMoZHBIZWlnaHQgKyBpbnB1dEhlaWdodCkgOiAwKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gb2Zmc2V0O1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0LyogRmluZCBhbiBvYmplY3QncyBwb3NpdGlvbiBvbiB0aGUgc2NyZWVuLiAqL1xcblxcdFxcdF9maW5kUG9zOiBmdW5jdGlvbiBfZmluZFBvcyhvYmopIHtcXG5cXHRcXHRcXHR2YXIgcG9zaXRpb24sXFxuXFx0XFx0XFx0ICAgIGluc3QgPSB0aGlzLl9nZXRJbnN0KG9iaiksXFxuXFx0XFx0XFx0ICAgIGlzUlRMID0gdGhpcy5fZ2V0KGluc3QsIFxcXCJpc1JUTFxcXCIpO1xcblxcblxcdFxcdFxcdHdoaWxlIChvYmogJiYgKG9iai50eXBlID09PSBcXFwiaGlkZGVuXFxcIiB8fCBvYmoubm9kZVR5cGUgIT09IDEgfHwgJC5leHByLmZpbHRlcnMuaGlkZGVuKG9iaikpKSB7XFxuXFx0XFx0XFx0XFx0b2JqID0gb2JqW2lzUlRMID8gXFxcInByZXZpb3VzU2libGluZ1xcXCIgOiBcXFwibmV4dFNpYmxpbmdcXFwiXTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cG9zaXRpb24gPSAkKG9iaikub2Zmc2V0KCk7XFxuXFx0XFx0XFx0cmV0dXJuIFtwb3NpdGlvbi5sZWZ0LCBwb3NpdGlvbi50b3BdO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0LyogSGlkZSB0aGUgZGF0ZSBwaWNrZXIgZnJvbSB2aWV3LlxcbiAgICogQHBhcmFtICBpbnB1dCAgZWxlbWVudCAtIHRoZSBpbnB1dCBmaWVsZCBhdHRhY2hlZCB0byB0aGUgZGF0ZSBwaWNrZXJcXG4gICAqL1xcblxcdFxcdF9oaWRlRGF0ZXBpY2tlcjogZnVuY3Rpb24gX2hpZGVEYXRlcGlja2VyKGlucHV0KSB7XFxuXFx0XFx0XFx0dmFyIHNob3dBbmltLFxcblxcdFxcdFxcdCAgICBkdXJhdGlvbixcXG5cXHRcXHRcXHQgICAgcG9zdFByb2Nlc3MsXFxuXFx0XFx0XFx0ICAgIG9uQ2xvc2UsXFxuXFx0XFx0XFx0ICAgIGluc3QgPSB0aGlzLl9jdXJJbnN0O1xcblxcblxcdFxcdFxcdGlmICghaW5zdCB8fCBpbnB1dCAmJiBpbnN0ICE9PSAkLmRhdGEoaW5wdXQsIFxcXCJkYXRlcGlja2VyXFxcIikpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICh0aGlzLl9kYXRlcGlja2VyU2hvd2luZykge1xcblxcdFxcdFxcdFxcdHNob3dBbmltID0gdGhpcy5fZ2V0KGluc3QsIFxcXCJzaG93QW5pbVxcXCIpO1xcblxcdFxcdFxcdFxcdGR1cmF0aW9uID0gdGhpcy5fZ2V0KGluc3QsIFxcXCJkdXJhdGlvblxcXCIpO1xcblxcdFxcdFxcdFxcdHBvc3RQcm9jZXNzID0gZnVuY3Rpb24gcG9zdFByb2Nlc3MoKSB7XFxuXFx0XFx0XFx0XFx0XFx0JC5kYXRlcGlja2VyLl90aWR5RGlhbG9nKGluc3QpO1xcblxcdFxcdFxcdFxcdH07XFxuXFxuXFx0XFx0XFx0XFx0Ly8gREVQUkVDQVRFRDogYWZ0ZXIgQkMgZm9yIDEuOC54ICQuZWZmZWN0c1sgc2hvd0FuaW0gXSBpcyBub3QgbmVlZGVkXFxuXFx0XFx0XFx0XFx0aWYgKCQuZWZmZWN0cyAmJiAoJC5lZmZlY3RzLmVmZmVjdFtzaG93QW5pbV0gfHwgJC5lZmZlY3RzW3Nob3dBbmltXSkpIHtcXG5cXHRcXHRcXHRcXHRcXHRpbnN0LmRwRGl2LmhpZGUoc2hvd0FuaW0sICQuZGF0ZXBpY2tlci5fZ2V0KGluc3QsIFxcXCJzaG93T3B0aW9uc1xcXCIpLCBkdXJhdGlvbiwgcG9zdFByb2Nlc3MpO1xcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0aW5zdC5kcERpdltzaG93QW5pbSA9PT0gXFxcInNsaWRlRG93blxcXCIgPyBcXFwic2xpZGVVcFxcXCIgOiBzaG93QW5pbSA9PT0gXFxcImZhZGVJblxcXCIgPyBcXFwiZmFkZU91dFxcXCIgOiBcXFwiaGlkZVxcXCJdKHNob3dBbmltID8gZHVyYXRpb24gOiBudWxsLCBwb3N0UHJvY2Vzcyk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmICghc2hvd0FuaW0pIHtcXG5cXHRcXHRcXHRcXHRcXHRwb3N0UHJvY2VzcygpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR0aGlzLl9kYXRlcGlja2VyU2hvd2luZyA9IGZhbHNlO1xcblxcblxcdFxcdFxcdFxcdG9uQ2xvc2UgPSB0aGlzLl9nZXQoaW5zdCwgXFxcIm9uQ2xvc2VcXFwiKTtcXG5cXHRcXHRcXHRcXHRpZiAob25DbG9zZSkge1xcblxcdFxcdFxcdFxcdFxcdG9uQ2xvc2UuYXBwbHkoaW5zdC5pbnB1dCA/IGluc3QuaW5wdXRbMF0gOiBudWxsLCBbaW5zdC5pbnB1dCA/IGluc3QuaW5wdXQudmFsKCkgOiBcXFwiXFxcIiwgaW5zdF0pO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR0aGlzLl9sYXN0SW5wdXQgPSBudWxsO1xcblxcdFxcdFxcdFxcdGlmICh0aGlzLl9pbkRpYWxvZykge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX2RpYWxvZ0lucHV0LmNzcyh7IHBvc2l0aW9uOiBcXFwiYWJzb2x1dGVcXFwiLCBsZWZ0OiBcXFwiMFxcXCIsIHRvcDogXFxcIi0xMDBweFxcXCIgfSk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCQuYmxvY2tVSSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdCQudW5ibG9ja1VJKCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0JChcXFwiYm9keVxcXCIpLmFwcGVuZCh0aGlzLmRwRGl2KTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHRoaXMuX2luRGlhbG9nID0gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFxuXFx0XFx0LyogVGlkeSB1cCBhZnRlciBhIGRpYWxvZyBkaXNwbGF5LiAqL1xcblxcdFxcdF90aWR5RGlhbG9nOiBmdW5jdGlvbiBfdGlkeURpYWxvZyhpbnN0KSB7XFxuXFx0XFx0XFx0aW5zdC5kcERpdi5yZW1vdmVDbGFzcyh0aGlzLl9kaWFsb2dDbGFzcykudW5iaW5kKFxcXCIudWktZGF0ZXBpY2tlci1jYWxlbmRhclxcXCIpO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0LyogQ2xvc2UgZGF0ZSBwaWNrZXIgaWYgY2xpY2tlZCBlbHNld2hlcmUuICovXFxuXFx0XFx0X2NoZWNrRXh0ZXJuYWxDbGljazogZnVuY3Rpb24gX2NoZWNrRXh0ZXJuYWxDbGljayhldmVudCkge1xcblxcdFxcdFxcdGlmICghJC5kYXRlcGlja2VyLl9jdXJJbnN0KSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2YXIgJHRhcmdldCA9ICQoZXZlbnQudGFyZ2V0KSxcXG5cXHRcXHRcXHQgICAgaW5zdCA9ICQuZGF0ZXBpY2tlci5fZ2V0SW5zdCgkdGFyZ2V0WzBdKTtcXG5cXG5cXHRcXHRcXHRpZiAoJHRhcmdldFswXS5pZCAhPT0gJC5kYXRlcGlja2VyLl9tYWluRGl2SWQgJiYgJHRhcmdldC5wYXJlbnRzKFxcXCIjXFxcIiArICQuZGF0ZXBpY2tlci5fbWFpbkRpdklkKS5sZW5ndGggPT09IDAgJiYgISR0YXJnZXQuaGFzQ2xhc3MoJC5kYXRlcGlja2VyLm1hcmtlckNsYXNzTmFtZSkgJiYgISR0YXJnZXQuY2xvc2VzdChcXFwiLlxcXCIgKyAkLmRhdGVwaWNrZXIuX3RyaWdnZXJDbGFzcykubGVuZ3RoICYmICQuZGF0ZXBpY2tlci5fZGF0ZXBpY2tlclNob3dpbmcgJiYgISgkLmRhdGVwaWNrZXIuX2luRGlhbG9nICYmICQuYmxvY2tVSSkgfHwgJHRhcmdldC5oYXNDbGFzcygkLmRhdGVwaWNrZXIubWFya2VyQ2xhc3NOYW1lKSAmJiAkLmRhdGVwaWNrZXIuX2N1ckluc3QgIT09IGluc3QpIHtcXG5cXHRcXHRcXHRcXHQkLmRhdGVwaWNrZXIuX2hpZGVEYXRlcGlja2VyKCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFxuXFx0XFx0LyogQWRqdXN0IG9uZSBvZiB0aGUgZGF0ZSBzdWItZmllbGRzLiAqL1xcblxcdFxcdF9hZGp1c3REYXRlOiBmdW5jdGlvbiBfYWRqdXN0RGF0ZShpZCwgb2Zmc2V0LCBwZXJpb2QpIHtcXG5cXHRcXHRcXHR2YXIgdGFyZ2V0ID0gJChpZCksXFxuXFx0XFx0XFx0ICAgIGluc3QgPSB0aGlzLl9nZXRJbnN0KHRhcmdldFswXSk7XFxuXFxuXFx0XFx0XFx0aWYgKHRoaXMuX2lzRGlzYWJsZWREYXRlcGlja2VyKHRhcmdldFswXSkpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHRoaXMuX2FkanVzdEluc3REYXRlKGluc3QsIG9mZnNldCArIChwZXJpb2QgPT09IFxcXCJNXFxcIiA/IHRoaXMuX2dldChpbnN0LCBcXFwic2hvd0N1cnJlbnRBdFBvc1xcXCIpIDogMCksIC8vIHVuZG8gcG9zaXRpb25pbmdcXG5cXHRcXHRcXHRwZXJpb2QpO1xcblxcdFxcdFxcdHRoaXMuX3VwZGF0ZURhdGVwaWNrZXIoaW5zdCk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvKiBBY3Rpb24gZm9yIGN1cnJlbnQgbGluay4gKi9cXG5cXHRcXHRfZ290b1RvZGF5OiBmdW5jdGlvbiBfZ290b1RvZGF5KGlkKSB7XFxuXFx0XFx0XFx0dmFyIGRhdGUsXFxuXFx0XFx0XFx0ICAgIHRhcmdldCA9ICQoaWQpLFxcblxcdFxcdFxcdCAgICBpbnN0ID0gdGhpcy5fZ2V0SW5zdCh0YXJnZXRbMF0pO1xcblxcblxcdFxcdFxcdGlmICh0aGlzLl9nZXQoaW5zdCwgXFxcImdvdG9DdXJyZW50XFxcIikgJiYgaW5zdC5jdXJyZW50RGF5KSB7XFxuXFx0XFx0XFx0XFx0aW5zdC5zZWxlY3RlZERheSA9IGluc3QuY3VycmVudERheTtcXG5cXHRcXHRcXHRcXHRpbnN0LmRyYXdNb250aCA9IGluc3Quc2VsZWN0ZWRNb250aCA9IGluc3QuY3VycmVudE1vbnRoO1xcblxcdFxcdFxcdFxcdGluc3QuZHJhd1llYXIgPSBpbnN0LnNlbGVjdGVkWWVhciA9IGluc3QuY3VycmVudFllYXI7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRkYXRlID0gbmV3IERhdGUoKTtcXG5cXHRcXHRcXHRcXHRpbnN0LnNlbGVjdGVkRGF5ID0gZGF0ZS5nZXREYXRlKCk7XFxuXFx0XFx0XFx0XFx0aW5zdC5kcmF3TW9udGggPSBpbnN0LnNlbGVjdGVkTW9udGggPSBkYXRlLmdldE1vbnRoKCk7XFxuXFx0XFx0XFx0XFx0aW5zdC5kcmF3WWVhciA9IGluc3Quc2VsZWN0ZWRZZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR0aGlzLl9ub3RpZnlDaGFuZ2UoaW5zdCk7XFxuXFx0XFx0XFx0dGhpcy5fYWRqdXN0RGF0ZSh0YXJnZXQpO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0LyogQWN0aW9uIGZvciBzZWxlY3RpbmcgYSBuZXcgbW9udGgveWVhci4gKi9cXG5cXHRcXHRfc2VsZWN0TW9udGhZZWFyOiBmdW5jdGlvbiBfc2VsZWN0TW9udGhZZWFyKGlkLCBzZWxlY3QsIHBlcmlvZCkge1xcblxcdFxcdFxcdHZhciB0YXJnZXQgPSAkKGlkKSxcXG5cXHRcXHRcXHQgICAgaW5zdCA9IHRoaXMuX2dldEluc3QodGFyZ2V0WzBdKTtcXG5cXG5cXHRcXHRcXHRpbnN0W1xcXCJzZWxlY3RlZFxcXCIgKyAocGVyaW9kID09PSBcXFwiTVxcXCIgPyBcXFwiTW9udGhcXFwiIDogXFxcIlllYXJcXFwiKV0gPSBpbnN0W1xcXCJkcmF3XFxcIiArIChwZXJpb2QgPT09IFxcXCJNXFxcIiA/IFxcXCJNb250aFxcXCIgOiBcXFwiWWVhclxcXCIpXSA9IHBhcnNlSW50KHNlbGVjdC5vcHRpb25zW3NlbGVjdC5zZWxlY3RlZEluZGV4XS52YWx1ZSwgMTApO1xcblxcblxcdFxcdFxcdHRoaXMuX25vdGlmeUNoYW5nZShpbnN0KTtcXG5cXHRcXHRcXHR0aGlzLl9hZGp1c3REYXRlKHRhcmdldCk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvKiBBY3Rpb24gZm9yIHNlbGVjdGluZyBhIGRheS4gKi9cXG5cXHRcXHRfc2VsZWN0RGF5OiBmdW5jdGlvbiBfc2VsZWN0RGF5KGlkLCBtb250aCwgeWVhciwgdGQpIHtcXG5cXHRcXHRcXHR2YXIgaW5zdCxcXG5cXHRcXHRcXHQgICAgdGFyZ2V0ID0gJChpZCk7XFxuXFxuXFx0XFx0XFx0aWYgKCQodGQpLmhhc0NsYXNzKHRoaXMuX3Vuc2VsZWN0YWJsZUNsYXNzKSB8fCB0aGlzLl9pc0Rpc2FibGVkRGF0ZXBpY2tlcih0YXJnZXRbMF0pKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpbnN0ID0gdGhpcy5fZ2V0SW5zdCh0YXJnZXRbMF0pO1xcblxcdFxcdFxcdGluc3Quc2VsZWN0ZWREYXkgPSBpbnN0LmN1cnJlbnREYXkgPSAkKFxcXCJhXFxcIiwgdGQpLmh0bWwoKTtcXG5cXHRcXHRcXHRpbnN0LnNlbGVjdGVkTW9udGggPSBpbnN0LmN1cnJlbnRNb250aCA9IG1vbnRoO1xcblxcdFxcdFxcdGluc3Quc2VsZWN0ZWRZZWFyID0gaW5zdC5jdXJyZW50WWVhciA9IHllYXI7XFxuXFx0XFx0XFx0dGhpcy5fc2VsZWN0RGF0ZShpZCwgdGhpcy5fZm9ybWF0RGF0ZShpbnN0LCBpbnN0LmN1cnJlbnREYXksIGluc3QuY3VycmVudE1vbnRoLCBpbnN0LmN1cnJlbnRZZWFyKSk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvKiBFcmFzZSB0aGUgaW5wdXQgZmllbGQgYW5kIGhpZGUgdGhlIGRhdGUgcGlja2VyLiAqL1xcblxcdFxcdF9jbGVhckRhdGU6IGZ1bmN0aW9uIF9jbGVhckRhdGUoaWQpIHtcXG5cXHRcXHRcXHR2YXIgdGFyZ2V0ID0gJChpZCk7XFxuXFx0XFx0XFx0dGhpcy5fc2VsZWN0RGF0ZSh0YXJnZXQsIFxcXCJcXFwiKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdC8qIFVwZGF0ZSB0aGUgaW5wdXQgZmllbGQgd2l0aCB0aGUgc2VsZWN0ZWQgZGF0ZS4gKi9cXG5cXHRcXHRfc2VsZWN0RGF0ZTogZnVuY3Rpb24gX3NlbGVjdERhdGUoaWQsIGRhdGVTdHIpIHtcXG5cXHRcXHRcXHR2YXIgb25TZWxlY3QsXFxuXFx0XFx0XFx0ICAgIHRhcmdldCA9ICQoaWQpLFxcblxcdFxcdFxcdCAgICBpbnN0ID0gdGhpcy5fZ2V0SW5zdCh0YXJnZXRbMF0pO1xcblxcblxcdFxcdFxcdGRhdGVTdHIgPSBkYXRlU3RyICE9IG51bGwgPyBkYXRlU3RyIDogdGhpcy5fZm9ybWF0RGF0ZShpbnN0KTtcXG5cXHRcXHRcXHRpZiAoaW5zdC5pbnB1dCkge1xcblxcdFxcdFxcdFxcdGluc3QuaW5wdXQudmFsKGRhdGVTdHIpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR0aGlzLl91cGRhdGVBbHRlcm5hdGUoaW5zdCk7XFxuXFxuXFx0XFx0XFx0b25TZWxlY3QgPSB0aGlzLl9nZXQoaW5zdCwgXFxcIm9uU2VsZWN0XFxcIik7XFxuXFx0XFx0XFx0aWYgKG9uU2VsZWN0KSB7XFxuXFx0XFx0XFx0XFx0b25TZWxlY3QuYXBwbHkoaW5zdC5pbnB1dCA/IGluc3QuaW5wdXRbMF0gOiBudWxsLCBbZGF0ZVN0ciwgaW5zdF0pOyAvLyB0cmlnZ2VyIGN1c3RvbSBjYWxsYmFja1xcblxcdFxcdFxcdH0gZWxzZSBpZiAoaW5zdC5pbnB1dCkge1xcblxcdFxcdFxcdFxcdGluc3QuaW5wdXQudHJpZ2dlcihcXFwiY2hhbmdlXFxcIik7IC8vIGZpcmUgdGhlIGNoYW5nZSBldmVudFxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoaW5zdC5pbmxpbmUpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl91cGRhdGVEYXRlcGlja2VyKGluc3QpO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5faGlkZURhdGVwaWNrZXIoKTtcXG5cXHRcXHRcXHRcXHR0aGlzLl9sYXN0SW5wdXQgPSBpbnN0LmlucHV0WzBdO1xcblxcdFxcdFxcdFxcdGlmIChfdHlwZW9mKGluc3QuaW5wdXRbMF0pICE9PSBcXFwib2JqZWN0XFxcIikge1xcblxcdFxcdFxcdFxcdFxcdGluc3QuaW5wdXQuZm9jdXMoKTsgLy8gcmVzdG9yZSBmb2N1c1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR0aGlzLl9sYXN0SW5wdXQgPSBudWxsO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcblxcdFxcdC8qIFVwZGF0ZSBhbnkgYWx0ZXJuYXRlIGZpZWxkIHRvIHN5bmNocm9uaXNlIHdpdGggdGhlIG1haW4gZmllbGQuICovXFxuXFx0XFx0X3VwZGF0ZUFsdGVybmF0ZTogZnVuY3Rpb24gX3VwZGF0ZUFsdGVybmF0ZShpbnN0KSB7XFxuXFx0XFx0XFx0dmFyIGFsdEZvcm1hdCxcXG5cXHRcXHRcXHQgICAgZGF0ZSxcXG5cXHRcXHRcXHQgICAgZGF0ZVN0cixcXG5cXHRcXHRcXHQgICAgYWx0RmllbGQgPSB0aGlzLl9nZXQoaW5zdCwgXFxcImFsdEZpZWxkXFxcIik7XFxuXFxuXFx0XFx0XFx0aWYgKGFsdEZpZWxkKSB7XFxuXFx0XFx0XFx0XFx0Ly8gdXBkYXRlIGFsdGVybmF0ZSBmaWVsZCB0b29cXG5cXHRcXHRcXHRcXHRhbHRGb3JtYXQgPSB0aGlzLl9nZXQoaW5zdCwgXFxcImFsdEZvcm1hdFxcXCIpIHx8IHRoaXMuX2dldChpbnN0LCBcXFwiZGF0ZUZvcm1hdFxcXCIpO1xcblxcdFxcdFxcdFxcdGRhdGUgPSB0aGlzLl9nZXREYXRlKGluc3QpO1xcblxcdFxcdFxcdFxcdGRhdGVTdHIgPSB0aGlzLmZvcm1hdERhdGUoYWx0Rm9ybWF0LCBkYXRlLCB0aGlzLl9nZXRGb3JtYXRDb25maWcoaW5zdCkpO1xcblxcdFxcdFxcdFxcdCQoYWx0RmllbGQpLmVhY2goZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdCQodGhpcykudmFsKGRhdGVTdHIpO1xcblxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcblxcdFxcdC8qIFNldCBhcyBiZWZvcmVTaG93RGF5IGZ1bmN0aW9uIHRvIHByZXZlbnQgc2VsZWN0aW9uIG9mIHdlZWtlbmRzLlxcbiAgICogQHBhcmFtICBkYXRlICBEYXRlIC0gdGhlIGRhdGUgdG8gY3VzdG9taXNlXFxuICAgKiBAcmV0dXJuIFtib29sZWFuLCBzdHJpbmddIC0gaXMgdGhpcyBkYXRlIHNlbGVjdGFibGU/LCB3aGF0IGlzIGl0cyBDU1MgY2xhc3M/XFxuICAgKi9cXG5cXHRcXHRub1dlZWtlbmRzOiBmdW5jdGlvbiBub1dlZWtlbmRzKGRhdGUpIHtcXG5cXHRcXHRcXHR2YXIgZGF5ID0gZGF0ZS5nZXREYXkoKTtcXG5cXHRcXHRcXHRyZXR1cm4gW2RheSA+IDAgJiYgZGF5IDwgNiwgXFxcIlxcXCJdO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0LyogU2V0IGFzIGNhbGN1bGF0ZVdlZWsgdG8gZGV0ZXJtaW5lIHRoZSB3ZWVrIG9mIHRoZSB5ZWFyIGJhc2VkIG9uIHRoZSBJU08gODYwMSBkZWZpbml0aW9uLlxcbiAgICogQHBhcmFtICBkYXRlICBEYXRlIC0gdGhlIGRhdGUgdG8gZ2V0IHRoZSB3ZWVrIGZvclxcbiAgICogQHJldHVybiAgbnVtYmVyIC0gdGhlIG51bWJlciBvZiB0aGUgd2VlayB3aXRoaW4gdGhlIHllYXIgdGhhdCBjb250YWlucyB0aGlzIGRhdGVcXG4gICAqL1xcblxcdFxcdGlzbzg2MDFXZWVrOiBmdW5jdGlvbiBpc284NjAxV2VlayhkYXRlKSB7XFxuXFx0XFx0XFx0dmFyIHRpbWUsXFxuXFx0XFx0XFx0ICAgIGNoZWNrRGF0ZSA9IG5ldyBEYXRlKGRhdGUuZ2V0VGltZSgpKTtcXG5cXG5cXHRcXHRcXHQvLyBGaW5kIFRodXJzZGF5IG9mIHRoaXMgd2VlayBzdGFydGluZyBvbiBNb25kYXlcXG5cXHRcXHRcXHRjaGVja0RhdGUuc2V0RGF0ZShjaGVja0RhdGUuZ2V0RGF0ZSgpICsgNCAtIChjaGVja0RhdGUuZ2V0RGF5KCkgfHwgNykpO1xcblxcblxcdFxcdFxcdHRpbWUgPSBjaGVja0RhdGUuZ2V0VGltZSgpO1xcblxcdFxcdFxcdGNoZWNrRGF0ZS5zZXRNb250aCgwKTsgLy8gQ29tcGFyZSB3aXRoIEphbiAxXFxuXFx0XFx0XFx0Y2hlY2tEYXRlLnNldERhdGUoMSk7XFxuXFx0XFx0XFx0cmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yb3VuZCgodGltZSAtIGNoZWNrRGF0ZSkgLyA4NjQwMDAwMCkgLyA3KSArIDE7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvKiBQYXJzZSBhIHN0cmluZyB2YWx1ZSBpbnRvIGEgZGF0ZSBvYmplY3QuXFxuICAgKiBTZWUgZm9ybWF0RGF0ZSBiZWxvdyBmb3IgdGhlIHBvc3NpYmxlIGZvcm1hdHMuXFxuICAgKlxcbiAgICogQHBhcmFtICBmb3JtYXQgc3RyaW5nIC0gdGhlIGV4cGVjdGVkIGZvcm1hdCBvZiB0aGUgZGF0ZVxcbiAgICogQHBhcmFtICB2YWx1ZSBzdHJpbmcgLSB0aGUgZGF0ZSBpbiB0aGUgYWJvdmUgZm9ybWF0XFxuICAgKiBAcGFyYW0gIHNldHRpbmdzIE9iamVjdCAtIGF0dHJpYnV0ZXMgaW5jbHVkZTpcXG4gICAqXFx0XFx0XFx0XFx0XFx0c2hvcnRZZWFyQ3V0b2ZmICBudW1iZXIgLSB0aGUgY3V0b2ZmIHllYXIgZm9yIGRldGVybWluaW5nIHRoZSBjZW50dXJ5IChvcHRpb25hbClcXG4gICAqXFx0XFx0XFx0XFx0XFx0ZGF5TmFtZXNTaG9ydFxcdHN0cmluZ1s3XSAtIGFiYnJldmlhdGVkIG5hbWVzIG9mIHRoZSBkYXlzIGZyb20gU3VuZGF5IChvcHRpb25hbClcXG4gICAqXFx0XFx0XFx0XFx0XFx0ZGF5TmFtZXNcXHRcXHRzdHJpbmdbN10gLSBuYW1lcyBvZiB0aGUgZGF5cyBmcm9tIFN1bmRheSAob3B0aW9uYWwpXFxuICAgKlxcdFxcdFxcdFxcdFxcdG1vbnRoTmFtZXNTaG9ydCBzdHJpbmdbMTJdIC0gYWJicmV2aWF0ZWQgbmFtZXMgb2YgdGhlIG1vbnRocyAob3B0aW9uYWwpXFxuICAgKlxcdFxcdFxcdFxcdFxcdG1vbnRoTmFtZXNcXHRcXHRzdHJpbmdbMTJdIC0gbmFtZXMgb2YgdGhlIG1vbnRocyAob3B0aW9uYWwpXFxuICAgKiBAcmV0dXJuICBEYXRlIC0gdGhlIGV4dHJhY3RlZCBkYXRlIHZhbHVlIG9yIG51bGwgaWYgdmFsdWUgaXMgYmxhbmtcXG4gICAqL1xcblxcdFxcdHBhcnNlRGF0ZTogZnVuY3Rpb24gcGFyc2VEYXRlKGZvcm1hdCwgdmFsdWUsIHNldHRpbmdzKSB7XFxuXFx0XFx0XFx0aWYgKGZvcm1hdCA9PSBudWxsIHx8IHZhbHVlID09IG51bGwpIHtcXG5cXHRcXHRcXHRcXHR0aHJvdyBcXFwiSW52YWxpZCBhcmd1bWVudHNcXFwiO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2YWx1ZSA9ICh0eXBlb2YgdmFsdWUgPT09IFxcXCJ1bmRlZmluZWRcXFwiID8gXFxcInVuZGVmaW5lZFxcXCIgOiBfdHlwZW9mKHZhbHVlKSkgPT09IFxcXCJvYmplY3RcXFwiID8gdmFsdWUudG9TdHJpbmcoKSA6IHZhbHVlICsgXFxcIlxcXCI7XFxuXFx0XFx0XFx0aWYgKHZhbHVlID09PSBcXFwiXFxcIikge1xcblxcdFxcdFxcdFxcdHJldHVybiBudWxsO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2YXIgaUZvcm1hdCxcXG5cXHRcXHRcXHQgICAgZGltLFxcblxcdFxcdFxcdCAgICBleHRyYSxcXG5cXHRcXHRcXHQgICAgaVZhbHVlID0gMCxcXG5cXHRcXHRcXHQgICAgc2hvcnRZZWFyQ3V0b2ZmVGVtcCA9IChzZXR0aW5ncyA/IHNldHRpbmdzLnNob3J0WWVhckN1dG9mZiA6IG51bGwpIHx8IHRoaXMuX2RlZmF1bHRzLnNob3J0WWVhckN1dG9mZixcXG5cXHRcXHRcXHQgICAgc2hvcnRZZWFyQ3V0b2ZmID0gdHlwZW9mIHNob3J0WWVhckN1dG9mZlRlbXAgIT09IFxcXCJzdHJpbmdcXFwiID8gc2hvcnRZZWFyQ3V0b2ZmVGVtcCA6IG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKSAlIDEwMCArIHBhcnNlSW50KHNob3J0WWVhckN1dG9mZlRlbXAsIDEwKSxcXG5cXHRcXHRcXHQgICAgZGF5TmFtZXNTaG9ydCA9IChzZXR0aW5ncyA/IHNldHRpbmdzLmRheU5hbWVzU2hvcnQgOiBudWxsKSB8fCB0aGlzLl9kZWZhdWx0cy5kYXlOYW1lc1Nob3J0LFxcblxcdFxcdFxcdCAgICBkYXlOYW1lcyA9IChzZXR0aW5ncyA/IHNldHRpbmdzLmRheU5hbWVzIDogbnVsbCkgfHwgdGhpcy5fZGVmYXVsdHMuZGF5TmFtZXMsXFxuXFx0XFx0XFx0ICAgIG1vbnRoTmFtZXNTaG9ydCA9IChzZXR0aW5ncyA/IHNldHRpbmdzLm1vbnRoTmFtZXNTaG9ydCA6IG51bGwpIHx8IHRoaXMuX2RlZmF1bHRzLm1vbnRoTmFtZXNTaG9ydCxcXG5cXHRcXHRcXHQgICAgbW9udGhOYW1lcyA9IChzZXR0aW5ncyA/IHNldHRpbmdzLm1vbnRoTmFtZXMgOiBudWxsKSB8fCB0aGlzLl9kZWZhdWx0cy5tb250aE5hbWVzLFxcblxcdFxcdFxcdCAgICB5ZWFyID0gLTEsXFxuXFx0XFx0XFx0ICAgIG1vbnRoID0gLTEsXFxuXFx0XFx0XFx0ICAgIGRheSA9IC0xLFxcblxcdFxcdFxcdCAgICBkb3kgPSAtMSxcXG5cXHRcXHRcXHQgICAgbGl0ZXJhbCA9IGZhbHNlLFxcblxcdFxcdFxcdCAgICBkYXRlLFxcblxcblxcdFxcdFxcdC8vIENoZWNrIHdoZXRoZXIgYSBmb3JtYXQgY2hhcmFjdGVyIGlzIGRvdWJsZWRcXG5cXHRcXHRcXHRsb29rQWhlYWQgPSBmdW5jdGlvbiBsb29rQWhlYWQobWF0Y2gpIHtcXG5cXHRcXHRcXHRcXHR2YXIgbWF0Y2hlcyA9IGlGb3JtYXQgKyAxIDwgZm9ybWF0Lmxlbmd0aCAmJiBmb3JtYXQuY2hhckF0KGlGb3JtYXQgKyAxKSA9PT0gbWF0Y2g7XFxuXFx0XFx0XFx0XFx0aWYgKG1hdGNoZXMpIHtcXG5cXHRcXHRcXHRcXHRcXHRpRm9ybWF0Kys7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHJldHVybiBtYXRjaGVzO1xcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0Ly8gRXh0cmFjdCBhIG51bWJlciBmcm9tIHRoZSBzdHJpbmcgdmFsdWVcXG5cXHRcXHRcXHRnZXROdW1iZXIgPSBmdW5jdGlvbiBnZXROdW1iZXIobWF0Y2gpIHtcXG5cXHRcXHRcXHRcXHR2YXIgaXNEb3VibGVkID0gbG9va0FoZWFkKG1hdGNoKSxcXG5cXHRcXHRcXHRcXHQgICAgc2l6ZSA9IG1hdGNoID09PSBcXFwiQFxcXCIgPyAxNCA6IG1hdGNoID09PSBcXFwiIVxcXCIgPyAyMCA6IG1hdGNoID09PSBcXFwieVxcXCIgJiYgaXNEb3VibGVkID8gNCA6IG1hdGNoID09PSBcXFwib1xcXCIgPyAzIDogMixcXG5cXHRcXHRcXHRcXHQgICAgbWluU2l6ZSA9IG1hdGNoID09PSBcXFwieVxcXCIgPyBzaXplIDogMSxcXG5cXHRcXHRcXHRcXHQgICAgZGlnaXRzID0gbmV3IFJlZ0V4cChcXFwiXlxcXFxcXFxcZHtcXFwiICsgbWluU2l6ZSArIFxcXCIsXFxcIiArIHNpemUgKyBcXFwifVxcXCIpLFxcblxcdFxcdFxcdFxcdCAgICBudW0gPSB2YWx1ZS5zdWJzdHJpbmcoaVZhbHVlKS5tYXRjaChkaWdpdHMpO1xcblxcdFxcdFxcdFxcdGlmICghbnVtKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhyb3cgXFxcIk1pc3NpbmcgbnVtYmVyIGF0IHBvc2l0aW9uIFxcXCIgKyBpVmFsdWU7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGlWYWx1ZSArPSBudW1bMF0ubGVuZ3RoO1xcblxcdFxcdFxcdFxcdHJldHVybiBwYXJzZUludChudW1bMF0sIDEwKTtcXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdC8vIEV4dHJhY3QgYSBuYW1lIGZyb20gdGhlIHN0cmluZyB2YWx1ZSBhbmQgY29udmVydCB0byBhbiBpbmRleFxcblxcdFxcdFxcdGdldE5hbWUgPSBmdW5jdGlvbiBnZXROYW1lKG1hdGNoLCBzaG9ydE5hbWVzLCBsb25nTmFtZXMpIHtcXG5cXHRcXHRcXHRcXHR2YXIgaW5kZXggPSAtMSxcXG5cXHRcXHRcXHRcXHQgICAgbmFtZXMgPSAkLm1hcChsb29rQWhlYWQobWF0Y2gpID8gbG9uZ05hbWVzIDogc2hvcnROYW1lcywgZnVuY3Rpb24gKHYsIGspIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gW1trLCB2XV07XFxuXFx0XFx0XFx0XFx0fSkuc29ydChmdW5jdGlvbiAoYSwgYikge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiAtKGFbMV0ubGVuZ3RoIC0gYlsxXS5sZW5ndGgpO1xcblxcdFxcdFxcdFxcdH0pO1xcblxcblxcdFxcdFxcdFxcdCQuZWFjaChuYW1lcywgZnVuY3Rpb24gKGksIHBhaXIpIHtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgbmFtZSA9IHBhaXJbMV07XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHZhbHVlLnN1YnN0cihpVmFsdWUsIG5hbWUubGVuZ3RoKS50b0xvd2VyQ2FzZSgpID09PSBuYW1lLnRvTG93ZXJDYXNlKCkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpbmRleCA9IHBhaXJbMF07XFxuXFx0XFx0XFx0XFx0XFx0XFx0aVZhbHVlICs9IG5hbWUubGVuZ3RoO1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0XFx0aWYgKGluZGV4ICE9PSAtMSkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBpbmRleCArIDE7XFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHR0aHJvdyBcXFwiVW5rbm93biBuYW1lIGF0IHBvc2l0aW9uIFxcXCIgKyBpVmFsdWU7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0Ly8gQ29uZmlybSB0aGF0IGEgbGl0ZXJhbCBjaGFyYWN0ZXIgbWF0Y2hlcyB0aGUgc3RyaW5nIHZhbHVlXFxuXFx0XFx0XFx0Y2hlY2tMaXRlcmFsID0gZnVuY3Rpb24gY2hlY2tMaXRlcmFsKCkge1xcblxcdFxcdFxcdFxcdGlmICh2YWx1ZS5jaGFyQXQoaVZhbHVlKSAhPT0gZm9ybWF0LmNoYXJBdChpRm9ybWF0KSkge1xcblxcdFxcdFxcdFxcdFxcdHRocm93IFxcXCJVbmV4cGVjdGVkIGxpdGVyYWwgYXQgcG9zaXRpb24gXFxcIiArIGlWYWx1ZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aVZhbHVlKys7XFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHRcXHRmb3IgKGlGb3JtYXQgPSAwOyBpRm9ybWF0IDwgZm9ybWF0Lmxlbmd0aDsgaUZvcm1hdCsrKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGxpdGVyYWwpIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoZm9ybWF0LmNoYXJBdChpRm9ybWF0KSA9PT0gXFxcIidcXFwiICYmICFsb29rQWhlYWQoXFxcIidcXFwiKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGxpdGVyYWwgPSBmYWxzZTtcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdGNoZWNrTGl0ZXJhbCgpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdHN3aXRjaCAoZm9ybWF0LmNoYXJBdChpRm9ybWF0KSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgXFxcImRcXFwiOlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGRheSA9IGdldE51bWJlcihcXFwiZFxcXCIpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgXFxcIkRcXFwiOlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGdldE5hbWUoXFxcIkRcXFwiLCBkYXlOYW1lc1Nob3J0LCBkYXlOYW1lcyk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSBcXFwib1xcXCI6XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZG95ID0gZ2V0TnVtYmVyKFxcXCJvXFxcIik7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSBcXFwibVxcXCI6XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bW9udGggPSBnZXROdW1iZXIoXFxcIm1cXFwiKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlIFxcXCJNXFxcIjpcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRtb250aCA9IGdldE5hbWUoXFxcIk1cXFwiLCBtb250aE5hbWVzU2hvcnQsIG1vbnRoTmFtZXMpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgXFxcInlcXFwiOlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHllYXIgPSBnZXROdW1iZXIoXFxcInlcXFwiKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlIFxcXCJAXFxcIjpcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRlID0gbmV3IERhdGUoZ2V0TnVtYmVyKFxcXCJAXFxcIikpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHllYXIgPSBkYXRlLmdldEZ1bGxZZWFyKCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bW9udGggPSBkYXRlLmdldE1vbnRoKCkgKyAxO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGRheSA9IGRhdGUuZ2V0RGF0ZSgpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgXFxcIiFcXFwiOlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGUgPSBuZXcgRGF0ZSgoZ2V0TnVtYmVyKFxcXCIhXFxcIikgLSB0aGlzLl90aWNrc1RvMTk3MCkgLyAxMDAwMCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0eWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRtb250aCA9IGRhdGUuZ2V0TW9udGgoKSArIDE7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF5ID0gZGF0ZS5nZXREYXRlKCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSBcXFwiJ1xcXCI6XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKGxvb2tBaGVhZChcXFwiJ1xcXCIpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Y2hlY2tMaXRlcmFsKCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRsaXRlcmFsID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZGVmYXVsdDpcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjaGVja0xpdGVyYWwoKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoaVZhbHVlIDwgdmFsdWUubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0ZXh0cmEgPSB2YWx1ZS5zdWJzdHIoaVZhbHVlKTtcXG5cXHRcXHRcXHRcXHRpZiAoIS9eXFxcXHMrLy50ZXN0KGV4dHJhKSkge1xcblxcdFxcdFxcdFxcdFxcdHRocm93IFxcXCJFeHRyYS91bnBhcnNlZCBjaGFyYWN0ZXJzIGZvdW5kIGluIGRhdGU6IFxcXCIgKyBleHRyYTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICh5ZWFyID09PSAtMSkge1xcblxcdFxcdFxcdFxcdHllYXIgPSBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCk7XFxuXFx0XFx0XFx0fSBlbHNlIGlmICh5ZWFyIDwgMTAwKSB7XFxuXFx0XFx0XFx0XFx0eWVhciArPSBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCkgLSBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCkgJSAxMDAgKyAoeWVhciA8PSBzaG9ydFllYXJDdXRvZmYgPyAwIDogLTEwMCk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmIChkb3kgPiAtMSkge1xcblxcdFxcdFxcdFxcdG1vbnRoID0gMTtcXG5cXHRcXHRcXHRcXHRkYXkgPSBkb3k7XFxuXFx0XFx0XFx0XFx0ZG8ge1xcblxcdFxcdFxcdFxcdFxcdGRpbSA9IHRoaXMuX2dldERheXNJbk1vbnRoKHllYXIsIG1vbnRoIC0gMSk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGRheSA8PSBkaW0pIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0bW9udGgrKztcXG5cXHRcXHRcXHRcXHRcXHRkYXkgLT0gZGltO1xcblxcdFxcdFxcdFxcdH0gd2hpbGUgKHRydWUpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRkYXRlID0gdGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QobmV3IERhdGUoeWVhciwgbW9udGggLSAxLCBkYXkpKTtcXG5cXHRcXHRcXHRpZiAoZGF0ZS5nZXRGdWxsWWVhcigpICE9PSB5ZWFyIHx8IGRhdGUuZ2V0TW9udGgoKSArIDEgIT09IG1vbnRoIHx8IGRhdGUuZ2V0RGF0ZSgpICE9PSBkYXkpIHtcXG5cXHRcXHRcXHRcXHR0aHJvdyBcXFwiSW52YWxpZCBkYXRlXFxcIjsgLy8gRS5nLiAzMS8wMi8wMFxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gZGF0ZTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdC8qIFN0YW5kYXJkIGRhdGUgZm9ybWF0cy4gKi9cXG5cXHRcXHRBVE9NOiBcXFwieXktbW0tZGRcXFwiLCAvLyBSRkMgMzMzOSAoSVNPIDg2MDEpXFxuXFx0XFx0Q09PS0lFOiBcXFwiRCwgZGQgTSB5eVxcXCIsXFxuXFx0XFx0SVNPXzg2MDE6IFxcXCJ5eS1tbS1kZFxcXCIsXFxuXFx0XFx0UkZDXzgyMjogXFxcIkQsIGQgTSB5XFxcIixcXG5cXHRcXHRSRkNfODUwOiBcXFwiREQsIGRkLU0teVxcXCIsXFxuXFx0XFx0UkZDXzEwMzY6IFxcXCJELCBkIE0geVxcXCIsXFxuXFx0XFx0UkZDXzExMjM6IFxcXCJELCBkIE0geXlcXFwiLFxcblxcdFxcdFJGQ18yODIyOiBcXFwiRCwgZCBNIHl5XFxcIixcXG5cXHRcXHRSU1M6IFxcXCJELCBkIE0geVxcXCIsIC8vIFJGQyA4MjJcXG5cXHRcXHRUSUNLUzogXFxcIiFcXFwiLFxcblxcdFxcdFRJTUVTVEFNUDogXFxcIkBcXFwiLFxcblxcdFxcdFczQzogXFxcInl5LW1tLWRkXFxcIiwgLy8gSVNPIDg2MDFcXG5cXG5cXHRcXHRfdGlja3NUbzE5NzA6ICgoMTk3MCAtIDEpICogMzY1ICsgTWF0aC5mbG9vcigxOTcwIC8gNCkgLSBNYXRoLmZsb29yKDE5NzAgLyAxMDApICsgTWF0aC5mbG9vcigxOTcwIC8gNDAwKSkgKiAyNCAqIDYwICogNjAgKiAxMDAwMDAwMCxcXG5cXG5cXHRcXHQvKiBGb3JtYXQgYSBkYXRlIG9iamVjdCBpbnRvIGEgc3RyaW5nIHZhbHVlLlxcbiAgICogVGhlIGZvcm1hdCBjYW4gYmUgY29tYmluYXRpb25zIG9mIHRoZSBmb2xsb3dpbmc6XFxuICAgKiBkICAtIGRheSBvZiBtb250aCAobm8gbGVhZGluZyB6ZXJvKVxcbiAgICogZGQgLSBkYXkgb2YgbW9udGggKHR3byBkaWdpdClcXG4gICAqIG8gIC0gZGF5IG9mIHllYXIgKG5vIGxlYWRpbmcgemVyb3MpXFxuICAgKiBvbyAtIGRheSBvZiB5ZWFyICh0aHJlZSBkaWdpdClcXG4gICAqIEQgIC0gZGF5IG5hbWUgc2hvcnRcXG4gICAqIEREIC0gZGF5IG5hbWUgbG9uZ1xcbiAgICogbSAgLSBtb250aCBvZiB5ZWFyIChubyBsZWFkaW5nIHplcm8pXFxuICAgKiBtbSAtIG1vbnRoIG9mIHllYXIgKHR3byBkaWdpdClcXG4gICAqIE0gIC0gbW9udGggbmFtZSBzaG9ydFxcbiAgICogTU0gLSBtb250aCBuYW1lIGxvbmdcXG4gICAqIHkgIC0geWVhciAodHdvIGRpZ2l0KVxcbiAgICogeXkgLSB5ZWFyIChmb3VyIGRpZ2l0KVxcbiAgICogQCAtIFVuaXggdGltZXN0YW1wIChtcyBzaW5jZSAwMS8wMS8xOTcwKVxcbiAgICogISAtIFdpbmRvd3MgdGlja3MgKDEwMG5zIHNpbmNlIDAxLzAxLzAwMDEpXFxuICAgKiBcXFwiLi4uXFxcIiAtIGxpdGVyYWwgdGV4dFxcbiAgICogJycgLSBzaW5nbGUgcXVvdGVcXG4gICAqXFxuICAgKiBAcGFyYW0gIGZvcm1hdCBzdHJpbmcgLSB0aGUgZGVzaXJlZCBmb3JtYXQgb2YgdGhlIGRhdGVcXG4gICAqIEBwYXJhbSAgZGF0ZSBEYXRlIC0gdGhlIGRhdGUgdmFsdWUgdG8gZm9ybWF0XFxuICAgKiBAcGFyYW0gIHNldHRpbmdzIE9iamVjdCAtIGF0dHJpYnV0ZXMgaW5jbHVkZTpcXG4gICAqXFx0XFx0XFx0XFx0XFx0ZGF5TmFtZXNTaG9ydFxcdHN0cmluZ1s3XSAtIGFiYnJldmlhdGVkIG5hbWVzIG9mIHRoZSBkYXlzIGZyb20gU3VuZGF5IChvcHRpb25hbClcXG4gICAqXFx0XFx0XFx0XFx0XFx0ZGF5TmFtZXNcXHRcXHRzdHJpbmdbN10gLSBuYW1lcyBvZiB0aGUgZGF5cyBmcm9tIFN1bmRheSAob3B0aW9uYWwpXFxuICAgKlxcdFxcdFxcdFxcdFxcdG1vbnRoTmFtZXNTaG9ydCBzdHJpbmdbMTJdIC0gYWJicmV2aWF0ZWQgbmFtZXMgb2YgdGhlIG1vbnRocyAob3B0aW9uYWwpXFxuICAgKlxcdFxcdFxcdFxcdFxcdG1vbnRoTmFtZXNcXHRcXHRzdHJpbmdbMTJdIC0gbmFtZXMgb2YgdGhlIG1vbnRocyAob3B0aW9uYWwpXFxuICAgKiBAcmV0dXJuICBzdHJpbmcgLSB0aGUgZGF0ZSBpbiB0aGUgYWJvdmUgZm9ybWF0XFxuICAgKi9cXG5cXHRcXHRmb3JtYXREYXRlOiBmdW5jdGlvbiBmb3JtYXREYXRlKGZvcm1hdCwgZGF0ZSwgc2V0dGluZ3MpIHtcXG5cXHRcXHRcXHRpZiAoIWRhdGUpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gXFxcIlxcXCI7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHZhciBpRm9ybWF0LFxcblxcdFxcdFxcdCAgICBkYXlOYW1lc1Nob3J0ID0gKHNldHRpbmdzID8gc2V0dGluZ3MuZGF5TmFtZXNTaG9ydCA6IG51bGwpIHx8IHRoaXMuX2RlZmF1bHRzLmRheU5hbWVzU2hvcnQsXFxuXFx0XFx0XFx0ICAgIGRheU5hbWVzID0gKHNldHRpbmdzID8gc2V0dGluZ3MuZGF5TmFtZXMgOiBudWxsKSB8fCB0aGlzLl9kZWZhdWx0cy5kYXlOYW1lcyxcXG5cXHRcXHRcXHQgICAgbW9udGhOYW1lc1Nob3J0ID0gKHNldHRpbmdzID8gc2V0dGluZ3MubW9udGhOYW1lc1Nob3J0IDogbnVsbCkgfHwgdGhpcy5fZGVmYXVsdHMubW9udGhOYW1lc1Nob3J0LFxcblxcdFxcdFxcdCAgICBtb250aE5hbWVzID0gKHNldHRpbmdzID8gc2V0dGluZ3MubW9udGhOYW1lcyA6IG51bGwpIHx8IHRoaXMuX2RlZmF1bHRzLm1vbnRoTmFtZXMsXFxuXFxuXFx0XFx0XFx0Ly8gQ2hlY2sgd2hldGhlciBhIGZvcm1hdCBjaGFyYWN0ZXIgaXMgZG91YmxlZFxcblxcdFxcdFxcdGxvb2tBaGVhZCA9IGZ1bmN0aW9uIGxvb2tBaGVhZChtYXRjaCkge1xcblxcdFxcdFxcdFxcdHZhciBtYXRjaGVzID0gaUZvcm1hdCArIDEgPCBmb3JtYXQubGVuZ3RoICYmIGZvcm1hdC5jaGFyQXQoaUZvcm1hdCArIDEpID09PSBtYXRjaDtcXG5cXHRcXHRcXHRcXHRpZiAobWF0Y2hlcykge1xcblxcdFxcdFxcdFxcdFxcdGlGb3JtYXQrKztcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0cmV0dXJuIG1hdGNoZXM7XFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHQvLyBGb3JtYXQgYSBudW1iZXIsIHdpdGggbGVhZGluZyB6ZXJvIGlmIG5lY2Vzc2FyeVxcblxcdFxcdFxcdGZvcm1hdE51bWJlciA9IGZ1bmN0aW9uIGZvcm1hdE51bWJlcihtYXRjaCwgdmFsdWUsIGxlbikge1xcblxcdFxcdFxcdFxcdHZhciBudW0gPSBcXFwiXFxcIiArIHZhbHVlO1xcblxcdFxcdFxcdFxcdGlmIChsb29rQWhlYWQobWF0Y2gpKSB7XFxuXFx0XFx0XFx0XFx0XFx0d2hpbGUgKG51bS5sZW5ndGggPCBsZW4pIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRudW0gPSBcXFwiMFxcXCIgKyBudW07XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRyZXR1cm4gbnVtO1xcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0Ly8gRm9ybWF0IGEgbmFtZSwgc2hvcnQgb3IgbG9uZyBhcyByZXF1ZXN0ZWRcXG5cXHRcXHRcXHRmb3JtYXROYW1lID0gZnVuY3Rpb24gZm9ybWF0TmFtZShtYXRjaCwgdmFsdWUsIHNob3J0TmFtZXMsIGxvbmdOYW1lcykge1xcblxcdFxcdFxcdFxcdHJldHVybiBsb29rQWhlYWQobWF0Y2gpID8gbG9uZ05hbWVzW3ZhbHVlXSA6IHNob3J0TmFtZXNbdmFsdWVdO1xcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0ICAgIG91dHB1dCA9IFxcXCJcXFwiLFxcblxcdFxcdFxcdCAgICBsaXRlcmFsID0gZmFsc2U7XFxuXFxuXFx0XFx0XFx0aWYgKGRhdGUpIHtcXG5cXHRcXHRcXHRcXHRmb3IgKGlGb3JtYXQgPSAwOyBpRm9ybWF0IDwgZm9ybWF0Lmxlbmd0aDsgaUZvcm1hdCsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGxpdGVyYWwpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoZm9ybWF0LmNoYXJBdChpRm9ybWF0KSA9PT0gXFxcIidcXFwiICYmICFsb29rQWhlYWQoXFxcIidcXFwiKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGxpdGVyYWwgPSBmYWxzZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG91dHB1dCArPSBmb3JtYXQuY2hhckF0KGlGb3JtYXQpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdHN3aXRjaCAoZm9ybWF0LmNoYXJBdChpRm9ybWF0KSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgXFxcImRcXFwiOlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG91dHB1dCArPSBmb3JtYXROdW1iZXIoXFxcImRcXFwiLCBkYXRlLmdldERhdGUoKSwgMik7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSBcXFwiRFxcXCI6XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0b3V0cHV0ICs9IGZvcm1hdE5hbWUoXFxcIkRcXFwiLCBkYXRlLmdldERheSgpLCBkYXlOYW1lc1Nob3J0LCBkYXlOYW1lcyk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSBcXFwib1xcXCI6XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0b3V0cHV0ICs9IGZvcm1hdE51bWJlcihcXFwib1xcXCIsIE1hdGgucm91bmQoKG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpLCBkYXRlLmdldERhdGUoKSkuZ2V0VGltZSgpIC0gbmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCAwLCAwKS5nZXRUaW1lKCkpIC8gODY0MDAwMDApLCAzKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjYXNlIFxcXCJtXFxcIjpcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRvdXRwdXQgKz0gZm9ybWF0TnVtYmVyKFxcXCJtXFxcIiwgZGF0ZS5nZXRNb250aCgpICsgMSwgMik7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSBcXFwiTVxcXCI6XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0b3V0cHV0ICs9IGZvcm1hdE5hbWUoXFxcIk1cXFwiLCBkYXRlLmdldE1vbnRoKCksIG1vbnRoTmFtZXNTaG9ydCwgbW9udGhOYW1lcyk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSBcXFwieVxcXCI6XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0b3V0cHV0ICs9IGxvb2tBaGVhZChcXFwieVxcXCIpID8gZGF0ZS5nZXRGdWxsWWVhcigpIDogKGRhdGUuZ2V0WWVhcigpICUgMTAwIDwgMTAgPyBcXFwiMFxcXCIgOiBcXFwiXFxcIikgKyBkYXRlLmdldFllYXIoKSAlIDEwMDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjYXNlIFxcXCJAXFxcIjpcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRvdXRwdXQgKz0gZGF0ZS5nZXRUaW1lKCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSBcXFwiIVxcXCI6XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0b3V0cHV0ICs9IGRhdGUuZ2V0VGltZSgpICogMTAwMDAgKyB0aGlzLl90aWNrc1RvMTk3MDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjYXNlIFxcXCInXFxcIjpcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAobG9va0FoZWFkKFxcXCInXFxcIikpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRvdXRwdXQgKz0gXFxcIidcXFwiO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bGl0ZXJhbCA9IHRydWU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGRlZmF1bHQ6XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0b3V0cHV0ICs9IGZvcm1hdC5jaGFyQXQoaUZvcm1hdCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiBvdXRwdXQ7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvKiBFeHRyYWN0IGFsbCBwb3NzaWJsZSBjaGFyYWN0ZXJzIGZyb20gdGhlIGRhdGUgZm9ybWF0LiAqL1xcblxcdFxcdF9wb3NzaWJsZUNoYXJzOiBmdW5jdGlvbiBfcG9zc2libGVDaGFycyhmb3JtYXQpIHtcXG5cXHRcXHRcXHR2YXIgaUZvcm1hdCxcXG5cXHRcXHRcXHQgICAgY2hhcnMgPSBcXFwiXFxcIixcXG5cXHRcXHRcXHQgICAgbGl0ZXJhbCA9IGZhbHNlLFxcblxcblxcdFxcdFxcdC8vIENoZWNrIHdoZXRoZXIgYSBmb3JtYXQgY2hhcmFjdGVyIGlzIGRvdWJsZWRcXG5cXHRcXHRcXHRsb29rQWhlYWQgPSBmdW5jdGlvbiBsb29rQWhlYWQobWF0Y2gpIHtcXG5cXHRcXHRcXHRcXHR2YXIgbWF0Y2hlcyA9IGlGb3JtYXQgKyAxIDwgZm9ybWF0Lmxlbmd0aCAmJiBmb3JtYXQuY2hhckF0KGlGb3JtYXQgKyAxKSA9PT0gbWF0Y2g7XFxuXFx0XFx0XFx0XFx0aWYgKG1hdGNoZXMpIHtcXG5cXHRcXHRcXHRcXHRcXHRpRm9ybWF0Kys7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHJldHVybiBtYXRjaGVzO1xcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0XFx0Zm9yIChpRm9ybWF0ID0gMDsgaUZvcm1hdCA8IGZvcm1hdC5sZW5ndGg7IGlGb3JtYXQrKykge1xcblxcdFxcdFxcdFxcdGlmIChsaXRlcmFsKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGZvcm1hdC5jaGFyQXQoaUZvcm1hdCkgPT09IFxcXCInXFxcIiAmJiAhbG9va0FoZWFkKFxcXCInXFxcIikpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRsaXRlcmFsID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRjaGFycyArPSBmb3JtYXQuY2hhckF0KGlGb3JtYXQpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdHN3aXRjaCAoZm9ybWF0LmNoYXJBdChpRm9ybWF0KSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgXFxcImRcXFwiOmNhc2UgXFxcIm1cXFwiOmNhc2UgXFxcInlcXFwiOmNhc2UgXFxcIkBcXFwiOlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGNoYXJzICs9IFxcXCIwMTIzNDU2Nzg5XFxcIjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlIFxcXCJEXFxcIjpjYXNlIFxcXCJNXFxcIjpcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gbnVsbDsgLy8gQWNjZXB0IGFueXRoaW5nXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSBcXFwiJ1xcXCI6XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKGxvb2tBaGVhZChcXFwiJ1xcXCIpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Y2hhcnMgKz0gXFxcIidcXFwiO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bGl0ZXJhbCA9IHRydWU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdFxcdGRlZmF1bHQ6XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y2hhcnMgKz0gZm9ybWF0LmNoYXJBdChpRm9ybWF0KTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gY2hhcnM7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvKiBHZXQgYSBzZXR0aW5nIHZhbHVlLCBkZWZhdWx0aW5nIGlmIG5lY2Vzc2FyeS4gKi9cXG5cXHRcXHRfZ2V0OiBmdW5jdGlvbiBfZ2V0KGluc3QsIG5hbWUpIHtcXG5cXHRcXHRcXHRyZXR1cm4gaW5zdC5zZXR0aW5nc1tuYW1lXSAhPT0gdW5kZWZpbmVkID8gaW5zdC5zZXR0aW5nc1tuYW1lXSA6IHRoaXMuX2RlZmF1bHRzW25hbWVdO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0LyogUGFyc2UgZXhpc3RpbmcgZGF0ZSBhbmQgaW5pdGlhbGlzZSBkYXRlIHBpY2tlci4gKi9cXG5cXHRcXHRfc2V0RGF0ZUZyb21GaWVsZDogZnVuY3Rpb24gX3NldERhdGVGcm9tRmllbGQoaW5zdCwgbm9EZWZhdWx0KSB7XFxuXFx0XFx0XFx0aWYgKGluc3QuaW5wdXQudmFsKCkgPT09IGluc3QubGFzdFZhbCkge1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dmFyIGRhdGVGb3JtYXQgPSB0aGlzLl9nZXQoaW5zdCwgXFxcImRhdGVGb3JtYXRcXFwiKSxcXG5cXHRcXHRcXHQgICAgZGF0ZXMgPSBpbnN0Lmxhc3RWYWwgPSBpbnN0LmlucHV0ID8gaW5zdC5pbnB1dC52YWwoKSA6IG51bGwsXFxuXFx0XFx0XFx0ICAgIGRlZmF1bHREYXRlID0gdGhpcy5fZ2V0RGVmYXVsdERhdGUoaW5zdCksXFxuXFx0XFx0XFx0ICAgIGRhdGUgPSBkZWZhdWx0RGF0ZSxcXG5cXHRcXHRcXHQgICAgc2V0dGluZ3MgPSB0aGlzLl9nZXRGb3JtYXRDb25maWcoaW5zdCk7XFxuXFxuXFx0XFx0XFx0dHJ5IHtcXG5cXHRcXHRcXHRcXHRkYXRlID0gdGhpcy5wYXJzZURhdGUoZGF0ZUZvcm1hdCwgZGF0ZXMsIHNldHRpbmdzKSB8fCBkZWZhdWx0RGF0ZTtcXG5cXHRcXHRcXHR9IGNhdGNoIChldmVudCkge1xcblxcdFxcdFxcdFxcdGRhdGVzID0gbm9EZWZhdWx0ID8gXFxcIlxcXCIgOiBkYXRlcztcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aW5zdC5zZWxlY3RlZERheSA9IGRhdGUuZ2V0RGF0ZSgpO1xcblxcdFxcdFxcdGluc3QuZHJhd01vbnRoID0gaW5zdC5zZWxlY3RlZE1vbnRoID0gZGF0ZS5nZXRNb250aCgpO1xcblxcdFxcdFxcdGluc3QuZHJhd1llYXIgPSBpbnN0LnNlbGVjdGVkWWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKTtcXG5cXHRcXHRcXHRpbnN0LmN1cnJlbnREYXkgPSBkYXRlcyA/IGRhdGUuZ2V0RGF0ZSgpIDogMDtcXG5cXHRcXHRcXHRpbnN0LmN1cnJlbnRNb250aCA9IGRhdGVzID8gZGF0ZS5nZXRNb250aCgpIDogMDtcXG5cXHRcXHRcXHRpbnN0LmN1cnJlbnRZZWFyID0gZGF0ZXMgPyBkYXRlLmdldEZ1bGxZZWFyKCkgOiAwO1xcblxcdFxcdFxcdHRoaXMuX2FkanVzdEluc3REYXRlKGluc3QpO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0LyogUmV0cmlldmUgdGhlIGRlZmF1bHQgZGF0ZSBzaG93biBvbiBvcGVuaW5nLiAqL1xcblxcdFxcdF9nZXREZWZhdWx0RGF0ZTogZnVuY3Rpb24gX2dldERlZmF1bHREYXRlKGluc3QpIHtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5fcmVzdHJpY3RNaW5NYXgoaW5zdCwgdGhpcy5fZGV0ZXJtaW5lRGF0ZShpbnN0LCB0aGlzLl9nZXQoaW5zdCwgXFxcImRlZmF1bHREYXRlXFxcIiksIG5ldyBEYXRlKCkpKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdC8qIEEgZGF0ZSBtYXkgYmUgc3BlY2lmaWVkIGFzIGFuIGV4YWN0IHZhbHVlIG9yIGEgcmVsYXRpdmUgb25lLiAqL1xcblxcdFxcdF9kZXRlcm1pbmVEYXRlOiBmdW5jdGlvbiBfZGV0ZXJtaW5lRGF0ZShpbnN0LCBkYXRlLCBkZWZhdWx0RGF0ZSkge1xcblxcdFxcdFxcdHZhciBvZmZzZXROdW1lcmljID0gZnVuY3Rpb24gb2Zmc2V0TnVtZXJpYyhvZmZzZXQpIHtcXG5cXHRcXHRcXHRcXHR2YXIgZGF0ZSA9IG5ldyBEYXRlKCk7XFxuXFx0XFx0XFx0XFx0ZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpICsgb2Zmc2V0KTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZGF0ZTtcXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdCAgICBvZmZzZXRTdHJpbmcgPSBmdW5jdGlvbiBvZmZzZXRTdHJpbmcob2Zmc2V0KSB7XFxuXFx0XFx0XFx0XFx0dHJ5IHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gJC5kYXRlcGlja2VyLnBhcnNlRGF0ZSgkLmRhdGVwaWNrZXIuX2dldChpbnN0LCBcXFwiZGF0ZUZvcm1hdFxcXCIpLCBvZmZzZXQsICQuZGF0ZXBpY2tlci5fZ2V0Rm9ybWF0Q29uZmlnKGluc3QpKTtcXG5cXHRcXHRcXHRcXHR9IGNhdGNoIChlKSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gSWdub3JlXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHZhciBkYXRlID0gKG9mZnNldC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9eYy8pID8gJC5kYXRlcGlja2VyLl9nZXREYXRlKGluc3QpIDogbnVsbCkgfHwgbmV3IERhdGUoKSxcXG5cXHRcXHRcXHRcXHQgICAgeWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKSxcXG5cXHRcXHRcXHRcXHQgICAgbW9udGggPSBkYXRlLmdldE1vbnRoKCksXFxuXFx0XFx0XFx0XFx0ICAgIGRheSA9IGRhdGUuZ2V0RGF0ZSgpLFxcblxcdFxcdFxcdFxcdCAgICBwYXR0ZXJuID0gLyhbK1xcXFwtXT9bMC05XSspXFxcXHMqKGR8RHx3fFd8bXxNfHl8WSk/L2csXFxuXFx0XFx0XFx0XFx0ICAgIG1hdGNoZXMgPSBwYXR0ZXJuLmV4ZWMob2Zmc2V0KTtcXG5cXG5cXHRcXHRcXHRcXHR3aGlsZSAobWF0Y2hlcykge1xcblxcdFxcdFxcdFxcdFxcdHN3aXRjaCAobWF0Y2hlc1syXSB8fCBcXFwiZFxcXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlIFxcXCJkXFxcIjpjYXNlIFxcXCJEXFxcIjpcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXkgKz0gcGFyc2VJbnQobWF0Y2hlc1sxXSwgMTApO2JyZWFrO1xcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgXFxcIndcXFwiOmNhc2UgXFxcIldcXFwiOlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGRheSArPSBwYXJzZUludChtYXRjaGVzWzFdLCAxMCkgKiA3O2JyZWFrO1xcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgXFxcIm1cXFwiOmNhc2UgXFxcIk1cXFwiOlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG1vbnRoICs9IHBhcnNlSW50KG1hdGNoZXNbMV0sIDEwKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXkgPSBNYXRoLm1pbihkYXksICQuZGF0ZXBpY2tlci5fZ2V0RGF5c0luTW9udGgoeWVhciwgbW9udGgpKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlIFxcXCJ5XFxcIjpjYXNlIFxcXCJZXFxcIjpcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR5ZWFyICs9IHBhcnNlSW50KG1hdGNoZXNbMV0sIDEwKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXkgPSBNYXRoLm1pbihkYXksICQuZGF0ZXBpY2tlci5fZ2V0RGF5c0luTW9udGgoeWVhciwgbW9udGgpKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0bWF0Y2hlcyA9IHBhdHRlcm4uZXhlYyhvZmZzZXQpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRyZXR1cm4gbmV3IERhdGUoeWVhciwgbW9udGgsIGRheSk7XFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHQgICAgbmV3RGF0ZSA9IGRhdGUgPT0gbnVsbCB8fCBkYXRlID09PSBcXFwiXFxcIiA/IGRlZmF1bHREYXRlIDogdHlwZW9mIGRhdGUgPT09IFxcXCJzdHJpbmdcXFwiID8gb2Zmc2V0U3RyaW5nKGRhdGUpIDogdHlwZW9mIGRhdGUgPT09IFxcXCJudW1iZXJcXFwiID8gaXNOYU4oZGF0ZSkgPyBkZWZhdWx0RGF0ZSA6IG9mZnNldE51bWVyaWMoZGF0ZSkgOiBuZXcgRGF0ZShkYXRlLmdldFRpbWUoKSk7XFxuXFxuXFx0XFx0XFx0bmV3RGF0ZSA9IG5ld0RhdGUgJiYgbmV3RGF0ZS50b1N0cmluZygpID09PSBcXFwiSW52YWxpZCBEYXRlXFxcIiA/IGRlZmF1bHREYXRlIDogbmV3RGF0ZTtcXG5cXHRcXHRcXHRpZiAobmV3RGF0ZSkge1xcblxcdFxcdFxcdFxcdG5ld0RhdGUuc2V0SG91cnMoMCk7XFxuXFx0XFx0XFx0XFx0bmV3RGF0ZS5zZXRNaW51dGVzKDApO1xcblxcdFxcdFxcdFxcdG5ld0RhdGUuc2V0U2Vjb25kcygwKTtcXG5cXHRcXHRcXHRcXHRuZXdEYXRlLnNldE1pbGxpc2Vjb25kcygwKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KG5ld0RhdGUpO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0LyogSGFuZGxlIHN3aXRjaCB0by9mcm9tIGRheWxpZ2h0IHNhdmluZy5cXG4gICAqIEhvdXJzIG1heSBiZSBub24temVybyBvbiBkYXlsaWdodCBzYXZpbmcgY3V0LW92ZXI6XFxuICAgKiA+IDEyIHdoZW4gbWlkbmlnaHQgY2hhbmdlb3ZlciwgYnV0IHRoZW4gY2Fubm90IGdlbmVyYXRlXFxuICAgKiBtaWRuaWdodCBkYXRldGltZSwgc28ganVtcCB0byAxQU0sIG90aGVyd2lzZSByZXNldC5cXG4gICAqIEBwYXJhbSAgZGF0ZSAgKERhdGUpIHRoZSBkYXRlIHRvIGNoZWNrXFxuICAgKiBAcmV0dXJuICAoRGF0ZSkgdGhlIGNvcnJlY3RlZCBkYXRlXFxuICAgKi9cXG5cXHRcXHRfZGF5bGlnaHRTYXZpbmdBZGp1c3Q6IGZ1bmN0aW9uIF9kYXlsaWdodFNhdmluZ0FkanVzdChkYXRlKSB7XFxuXFx0XFx0XFx0aWYgKCFkYXRlKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIG51bGw7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGRhdGUuc2V0SG91cnMoZGF0ZS5nZXRIb3VycygpID4gMTIgPyBkYXRlLmdldEhvdXJzKCkgKyAyIDogMCk7XFxuXFx0XFx0XFx0cmV0dXJuIGRhdGU7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvKiBTZXQgdGhlIGRhdGUocykgZGlyZWN0bHkuICovXFxuXFx0XFx0X3NldERhdGU6IGZ1bmN0aW9uIF9zZXREYXRlKGluc3QsIGRhdGUsIG5vQ2hhbmdlKSB7XFxuXFx0XFx0XFx0dmFyIGNsZWFyID0gIWRhdGUsXFxuXFx0XFx0XFx0ICAgIG9yaWdNb250aCA9IGluc3Quc2VsZWN0ZWRNb250aCxcXG5cXHRcXHRcXHQgICAgb3JpZ1llYXIgPSBpbnN0LnNlbGVjdGVkWWVhcixcXG5cXHRcXHRcXHQgICAgbmV3RGF0ZSA9IHRoaXMuX3Jlc3RyaWN0TWluTWF4KGluc3QsIHRoaXMuX2RldGVybWluZURhdGUoaW5zdCwgZGF0ZSwgbmV3IERhdGUoKSkpO1xcblxcblxcdFxcdFxcdGluc3Quc2VsZWN0ZWREYXkgPSBpbnN0LmN1cnJlbnREYXkgPSBuZXdEYXRlLmdldERhdGUoKTtcXG5cXHRcXHRcXHRpbnN0LmRyYXdNb250aCA9IGluc3Quc2VsZWN0ZWRNb250aCA9IGluc3QuY3VycmVudE1vbnRoID0gbmV3RGF0ZS5nZXRNb250aCgpO1xcblxcdFxcdFxcdGluc3QuZHJhd1llYXIgPSBpbnN0LnNlbGVjdGVkWWVhciA9IGluc3QuY3VycmVudFllYXIgPSBuZXdEYXRlLmdldEZ1bGxZZWFyKCk7XFxuXFx0XFx0XFx0aWYgKChvcmlnTW9udGggIT09IGluc3Quc2VsZWN0ZWRNb250aCB8fCBvcmlnWWVhciAhPT0gaW5zdC5zZWxlY3RlZFllYXIpICYmICFub0NoYW5nZSkge1xcblxcdFxcdFxcdFxcdHRoaXMuX25vdGlmeUNoYW5nZShpbnN0KTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0dGhpcy5fYWRqdXN0SW5zdERhdGUoaW5zdCk7XFxuXFx0XFx0XFx0aWYgKGluc3QuaW5wdXQpIHtcXG5cXHRcXHRcXHRcXHRpbnN0LmlucHV0LnZhbChjbGVhciA/IFxcXCJcXFwiIDogdGhpcy5fZm9ybWF0RGF0ZShpbnN0KSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFxuXFx0XFx0LyogUmV0cmlldmUgdGhlIGRhdGUocykgZGlyZWN0bHkuICovXFxuXFx0XFx0X2dldERhdGU6IGZ1bmN0aW9uIF9nZXREYXRlKGluc3QpIHtcXG5cXHRcXHRcXHR2YXIgc3RhcnREYXRlID0gIWluc3QuY3VycmVudFllYXIgfHwgaW5zdC5pbnB1dCAmJiBpbnN0LmlucHV0LnZhbCgpID09PSBcXFwiXFxcIiA/IG51bGwgOiB0aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdChuZXcgRGF0ZShpbnN0LmN1cnJlbnRZZWFyLCBpbnN0LmN1cnJlbnRNb250aCwgaW5zdC5jdXJyZW50RGF5KSk7XFxuXFx0XFx0XFx0cmV0dXJuIHN0YXJ0RGF0ZTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdC8qIEF0dGFjaCB0aGUgb254eHggaGFuZGxlcnMuICBUaGVzZSBhcmUgZGVjbGFyZWQgc3RhdGljYWxseSBzb1xcbiAgICogdGhleSB3b3JrIHdpdGggc3RhdGljIGNvZGUgdHJhbnNmb3JtZXJzIGxpa2UgQ2FqYS5cXG4gICAqL1xcblxcdFxcdF9hdHRhY2hIYW5kbGVyczogZnVuY3Rpb24gX2F0dGFjaEhhbmRsZXJzKGluc3QpIHtcXG5cXHRcXHRcXHR2YXIgc3RlcE1vbnRocyA9IHRoaXMuX2dldChpbnN0LCBcXFwic3RlcE1vbnRoc1xcXCIpLFxcblxcdFxcdFxcdCAgICBpZCA9IFxcXCIjXFxcIiArIGluc3QuaWQucmVwbGFjZSgvXFxcXFxcXFxcXFxcXFxcXC9nLCBcXFwiXFxcXFxcXFxcXFwiKTtcXG5cXHRcXHRcXHRpbnN0LmRwRGl2LmZpbmQoXFxcIltkYXRhLWhhbmRsZXJdXFxcIikubWFwKGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHR2YXIgaGFuZGxlciA9IHtcXG5cXHRcXHRcXHRcXHRcXHRwcmV2OiBmdW5jdGlvbiBwcmV2KCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdCQuZGF0ZXBpY2tlci5fYWRqdXN0RGF0ZShpZCwgLXN0ZXBNb250aHMsIFxcXCJNXFxcIik7XFxuXFx0XFx0XFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRcXHRcXHRuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdCQuZGF0ZXBpY2tlci5fYWRqdXN0RGF0ZShpZCwgK3N0ZXBNb250aHMsIFxcXCJNXFxcIik7XFxuXFx0XFx0XFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRcXHRcXHRoaWRlOiBmdW5jdGlvbiBoaWRlKCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdCQuZGF0ZXBpY2tlci5faGlkZURhdGVwaWNrZXIoKTtcXG5cXHRcXHRcXHRcXHRcXHR9LFxcblxcdFxcdFxcdFxcdFxcdHRvZGF5OiBmdW5jdGlvbiB0b2RheSgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHQkLmRhdGVwaWNrZXIuX2dvdG9Ub2RheShpZCk7XFxuXFx0XFx0XFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRcXHRcXHRzZWxlY3REYXk6IGZ1bmN0aW9uIHNlbGVjdERheSgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHQkLmRhdGVwaWNrZXIuX3NlbGVjdERheShpZCwgK3RoaXMuZ2V0QXR0cmlidXRlKFxcXCJkYXRhLW1vbnRoXFxcIiksICt0aGlzLmdldEF0dHJpYnV0ZShcXFwiZGF0YS15ZWFyXFxcIiksIHRoaXMpO1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHRcXHRcXHR9LFxcblxcdFxcdFxcdFxcdFxcdHNlbGVjdE1vbnRoOiBmdW5jdGlvbiBzZWxlY3RNb250aCgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHQkLmRhdGVwaWNrZXIuX3NlbGVjdE1vbnRoWWVhcihpZCwgdGhpcywgXFxcIk1cXFwiKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRcXHRcXHRzZWxlY3RZZWFyOiBmdW5jdGlvbiBzZWxlY3RZZWFyKCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdCQuZGF0ZXBpY2tlci5fc2VsZWN0TW9udGhZZWFyKGlkLCB0aGlzLCBcXFwiWVxcXCIpO1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fTtcXG5cXHRcXHRcXHRcXHQkKHRoaXMpLmJpbmQodGhpcy5nZXRBdHRyaWJ1dGUoXFxcImRhdGEtZXZlbnRcXFwiKSwgaGFuZGxlclt0aGlzLmdldEF0dHJpYnV0ZShcXFwiZGF0YS1oYW5kbGVyXFxcIildKTtcXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdC8qIEdlbmVyYXRlIHRoZSBIVE1MIGZvciB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgZGF0ZSBwaWNrZXIuICovXFxuXFx0XFx0X2dlbmVyYXRlSFRNTDogZnVuY3Rpb24gX2dlbmVyYXRlSFRNTChpbnN0KSB7XFxuXFx0XFx0XFx0dmFyIG1heERyYXcsXFxuXFx0XFx0XFx0ICAgIHByZXZUZXh0LFxcblxcdFxcdFxcdCAgICBwcmV2LFxcblxcdFxcdFxcdCAgICBuZXh0VGV4dCxcXG5cXHRcXHRcXHQgICAgbmV4dCxcXG5cXHRcXHRcXHQgICAgY3VycmVudFRleHQsXFxuXFx0XFx0XFx0ICAgIGdvdG9EYXRlLFxcblxcdFxcdFxcdCAgICBjb250cm9scyxcXG5cXHRcXHRcXHQgICAgYnV0dG9uUGFuZWwsXFxuXFx0XFx0XFx0ICAgIGZpcnN0RGF5LFxcblxcdFxcdFxcdCAgICBzaG93V2VlayxcXG5cXHRcXHRcXHQgICAgZGF5TmFtZXMsXFxuXFx0XFx0XFx0ICAgIGRheU5hbWVzTWluLFxcblxcdFxcdFxcdCAgICBtb250aE5hbWVzLFxcblxcdFxcdFxcdCAgICBtb250aE5hbWVzU2hvcnQsXFxuXFx0XFx0XFx0ICAgIGJlZm9yZVNob3dEYXksXFxuXFx0XFx0XFx0ICAgIHNob3dPdGhlck1vbnRocyxcXG5cXHRcXHRcXHQgICAgc2VsZWN0T3RoZXJNb250aHMsXFxuXFx0XFx0XFx0ICAgIGRlZmF1bHREYXRlLFxcblxcdFxcdFxcdCAgICBodG1sLFxcblxcdFxcdFxcdCAgICBkb3csXFxuXFx0XFx0XFx0ICAgIHJvdyxcXG5cXHRcXHRcXHQgICAgZ3JvdXAsXFxuXFx0XFx0XFx0ICAgIGNvbCxcXG5cXHRcXHRcXHQgICAgc2VsZWN0ZWREYXRlLFxcblxcdFxcdFxcdCAgICBjb3JuZXJDbGFzcyxcXG5cXHRcXHRcXHQgICAgY2FsZW5kZXIsXFxuXFx0XFx0XFx0ICAgIHRoZWFkLFxcblxcdFxcdFxcdCAgICBkYXksXFxuXFx0XFx0XFx0ICAgIGRheXNJbk1vbnRoLFxcblxcdFxcdFxcdCAgICBsZWFkRGF5cyxcXG5cXHRcXHRcXHQgICAgY3VyUm93cyxcXG5cXHRcXHRcXHQgICAgbnVtUm93cyxcXG5cXHRcXHRcXHQgICAgcHJpbnREYXRlLFxcblxcdFxcdFxcdCAgICBkUm93LFxcblxcdFxcdFxcdCAgICB0Ym9keSxcXG5cXHRcXHRcXHQgICAgZGF5U2V0dGluZ3MsXFxuXFx0XFx0XFx0ICAgIG90aGVyTW9udGgsXFxuXFx0XFx0XFx0ICAgIHVuc2VsZWN0YWJsZSxcXG5cXHRcXHRcXHQgICAgdGVtcERhdGUgPSBuZXcgRGF0ZSgpLFxcblxcdFxcdFxcdCAgICB0b2RheSA9IHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KG5ldyBEYXRlKHRlbXBEYXRlLmdldEZ1bGxZZWFyKCksIHRlbXBEYXRlLmdldE1vbnRoKCksIHRlbXBEYXRlLmdldERhdGUoKSkpLFxcblxcdFxcdFxcdCAgICAvLyBjbGVhciB0aW1lXFxuXFx0XFx0XFx0aXNSVEwgPSB0aGlzLl9nZXQoaW5zdCwgXFxcImlzUlRMXFxcIiksXFxuXFx0XFx0XFx0ICAgIHNob3dCdXR0b25QYW5lbCA9IHRoaXMuX2dldChpbnN0LCBcXFwic2hvd0J1dHRvblBhbmVsXFxcIiksXFxuXFx0XFx0XFx0ICAgIGhpZGVJZk5vUHJldk5leHQgPSB0aGlzLl9nZXQoaW5zdCwgXFxcImhpZGVJZk5vUHJldk5leHRcXFwiKSxcXG5cXHRcXHRcXHQgICAgbmF2aWdhdGlvbkFzRGF0ZUZvcm1hdCA9IHRoaXMuX2dldChpbnN0LCBcXFwibmF2aWdhdGlvbkFzRGF0ZUZvcm1hdFxcXCIpLFxcblxcdFxcdFxcdCAgICBudW1Nb250aHMgPSB0aGlzLl9nZXROdW1iZXJPZk1vbnRocyhpbnN0KSxcXG5cXHRcXHRcXHQgICAgc2hvd0N1cnJlbnRBdFBvcyA9IHRoaXMuX2dldChpbnN0LCBcXFwic2hvd0N1cnJlbnRBdFBvc1xcXCIpLFxcblxcdFxcdFxcdCAgICBzdGVwTW9udGhzID0gdGhpcy5fZ2V0KGluc3QsIFxcXCJzdGVwTW9udGhzXFxcIiksXFxuXFx0XFx0XFx0ICAgIGlzTXVsdGlNb250aCA9IG51bU1vbnRoc1swXSAhPT0gMSB8fCBudW1Nb250aHNbMV0gIT09IDEsXFxuXFx0XFx0XFx0ICAgIGN1cnJlbnREYXRlID0gdGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QoIWluc3QuY3VycmVudERheSA/IG5ldyBEYXRlKDk5OTksIDksIDkpIDogbmV3IERhdGUoaW5zdC5jdXJyZW50WWVhciwgaW5zdC5jdXJyZW50TW9udGgsIGluc3QuY3VycmVudERheSkpLFxcblxcdFxcdFxcdCAgICBtaW5EYXRlID0gdGhpcy5fZ2V0TWluTWF4RGF0ZShpbnN0LCBcXFwibWluXFxcIiksXFxuXFx0XFx0XFx0ICAgIG1heERhdGUgPSB0aGlzLl9nZXRNaW5NYXhEYXRlKGluc3QsIFxcXCJtYXhcXFwiKSxcXG5cXHRcXHRcXHQgICAgZHJhd01vbnRoID0gaW5zdC5kcmF3TW9udGggLSBzaG93Q3VycmVudEF0UG9zLFxcblxcdFxcdFxcdCAgICBkcmF3WWVhciA9IGluc3QuZHJhd1llYXI7XFxuXFxuXFx0XFx0XFx0aWYgKGRyYXdNb250aCA8IDApIHtcXG5cXHRcXHRcXHRcXHRkcmF3TW9udGggKz0gMTI7XFxuXFx0XFx0XFx0XFx0ZHJhd1llYXItLTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKG1heERhdGUpIHtcXG5cXHRcXHRcXHRcXHRtYXhEcmF3ID0gdGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QobmV3IERhdGUobWF4RGF0ZS5nZXRGdWxsWWVhcigpLCBtYXhEYXRlLmdldE1vbnRoKCkgLSBudW1Nb250aHNbMF0gKiBudW1Nb250aHNbMV0gKyAxLCBtYXhEYXRlLmdldERhdGUoKSkpO1xcblxcdFxcdFxcdFxcdG1heERyYXcgPSBtaW5EYXRlICYmIG1heERyYXcgPCBtaW5EYXRlID8gbWluRGF0ZSA6IG1heERyYXc7XFxuXFx0XFx0XFx0XFx0d2hpbGUgKHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KG5ldyBEYXRlKGRyYXdZZWFyLCBkcmF3TW9udGgsIDEpKSA+IG1heERyYXcpIHtcXG5cXHRcXHRcXHRcXHRcXHRkcmF3TW9udGgtLTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoZHJhd01vbnRoIDwgMCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGRyYXdNb250aCA9IDExO1xcblxcdFxcdFxcdFxcdFxcdFxcdGRyYXdZZWFyLS07XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aW5zdC5kcmF3TW9udGggPSBkcmF3TW9udGg7XFxuXFx0XFx0XFx0aW5zdC5kcmF3WWVhciA9IGRyYXdZZWFyO1xcblxcblxcdFxcdFxcdHByZXZUZXh0ID0gdGhpcy5fZ2V0KGluc3QsIFxcXCJwcmV2VGV4dFxcXCIpO1xcblxcdFxcdFxcdHByZXZUZXh0ID0gIW5hdmlnYXRpb25Bc0RhdGVGb3JtYXQgPyBwcmV2VGV4dCA6IHRoaXMuZm9ybWF0RGF0ZShwcmV2VGV4dCwgdGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QobmV3IERhdGUoZHJhd1llYXIsIGRyYXdNb250aCAtIHN0ZXBNb250aHMsIDEpKSwgdGhpcy5fZ2V0Rm9ybWF0Q29uZmlnKGluc3QpKTtcXG5cXG5cXHRcXHRcXHRwcmV2ID0gdGhpcy5fY2FuQWRqdXN0TW9udGgoaW5zdCwgLTEsIGRyYXdZZWFyLCBkcmF3TW9udGgpID8gXFxcIjxhIGNsYXNzPSd1aS1kYXRlcGlja2VyLXByZXYgdWktY29ybmVyLWFsbCcgZGF0YS1oYW5kbGVyPSdwcmV2JyBkYXRhLWV2ZW50PSdjbGljaydcXFwiICsgXFxcIiB0aXRsZT0nXFxcIiArIHByZXZUZXh0ICsgXFxcIic+PHNwYW4gY2xhc3M9J3VpLWljb24gdWktaWNvbi1jaXJjbGUtdHJpYW5nbGUtXFxcIiArIChpc1JUTCA/IFxcXCJlXFxcIiA6IFxcXCJ3XFxcIikgKyBcXFwiJz5cXFwiICsgcHJldlRleHQgKyBcXFwiPC9zcGFuPjwvYT5cXFwiIDogaGlkZUlmTm9QcmV2TmV4dCA/IFxcXCJcXFwiIDogXFxcIjxhIGNsYXNzPSd1aS1kYXRlcGlja2VyLXByZXYgdWktY29ybmVyLWFsbCB1aS1zdGF0ZS1kaXNhYmxlZCcgdGl0bGU9J1xcXCIgKyBwcmV2VGV4dCArIFxcXCInPjxzcGFuIGNsYXNzPSd1aS1pY29uIHVpLWljb24tY2lyY2xlLXRyaWFuZ2xlLVxcXCIgKyAoaXNSVEwgPyBcXFwiZVxcXCIgOiBcXFwid1xcXCIpICsgXFxcIic+XFxcIiArIHByZXZUZXh0ICsgXFxcIjwvc3Bhbj48L2E+XFxcIjtcXG5cXG5cXHRcXHRcXHRuZXh0VGV4dCA9IHRoaXMuX2dldChpbnN0LCBcXFwibmV4dFRleHRcXFwiKTtcXG5cXHRcXHRcXHRuZXh0VGV4dCA9ICFuYXZpZ2F0aW9uQXNEYXRlRm9ybWF0ID8gbmV4dFRleHQgOiB0aGlzLmZvcm1hdERhdGUobmV4dFRleHQsIHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KG5ldyBEYXRlKGRyYXdZZWFyLCBkcmF3TW9udGggKyBzdGVwTW9udGhzLCAxKSksIHRoaXMuX2dldEZvcm1hdENvbmZpZyhpbnN0KSk7XFxuXFxuXFx0XFx0XFx0bmV4dCA9IHRoaXMuX2NhbkFkanVzdE1vbnRoKGluc3QsICsxLCBkcmF3WWVhciwgZHJhd01vbnRoKSA/IFxcXCI8YSBjbGFzcz0ndWktZGF0ZXBpY2tlci1uZXh0IHVpLWNvcm5lci1hbGwnIGRhdGEtaGFuZGxlcj0nbmV4dCcgZGF0YS1ldmVudD0nY2xpY2snXFxcIiArIFxcXCIgdGl0bGU9J1xcXCIgKyBuZXh0VGV4dCArIFxcXCInPjxzcGFuIGNsYXNzPSd1aS1pY29uIHVpLWljb24tY2lyY2xlLXRyaWFuZ2xlLVxcXCIgKyAoaXNSVEwgPyBcXFwid1xcXCIgOiBcXFwiZVxcXCIpICsgXFxcIic+XFxcIiArIG5leHRUZXh0ICsgXFxcIjwvc3Bhbj48L2E+XFxcIiA6IGhpZGVJZk5vUHJldk5leHQgPyBcXFwiXFxcIiA6IFxcXCI8YSBjbGFzcz0ndWktZGF0ZXBpY2tlci1uZXh0IHVpLWNvcm5lci1hbGwgdWktc3RhdGUtZGlzYWJsZWQnIHRpdGxlPSdcXFwiICsgbmV4dFRleHQgKyBcXFwiJz48c3BhbiBjbGFzcz0ndWktaWNvbiB1aS1pY29uLWNpcmNsZS10cmlhbmdsZS1cXFwiICsgKGlzUlRMID8gXFxcIndcXFwiIDogXFxcImVcXFwiKSArIFxcXCInPlxcXCIgKyBuZXh0VGV4dCArIFxcXCI8L3NwYW4+PC9hPlxcXCI7XFxuXFxuXFx0XFx0XFx0Y3VycmVudFRleHQgPSB0aGlzLl9nZXQoaW5zdCwgXFxcImN1cnJlbnRUZXh0XFxcIik7XFxuXFx0XFx0XFx0Z290b0RhdGUgPSB0aGlzLl9nZXQoaW5zdCwgXFxcImdvdG9DdXJyZW50XFxcIikgJiYgaW5zdC5jdXJyZW50RGF5ID8gY3VycmVudERhdGUgOiB0b2RheTtcXG5cXHRcXHRcXHRjdXJyZW50VGV4dCA9ICFuYXZpZ2F0aW9uQXNEYXRlRm9ybWF0ID8gY3VycmVudFRleHQgOiB0aGlzLmZvcm1hdERhdGUoY3VycmVudFRleHQsIGdvdG9EYXRlLCB0aGlzLl9nZXRGb3JtYXRDb25maWcoaW5zdCkpO1xcblxcblxcdFxcdFxcdGNvbnRyb2xzID0gIWluc3QuaW5saW5lID8gXFxcIjxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz0ndWktZGF0ZXBpY2tlci1jbG9zZSB1aS1zdGF0ZS1kZWZhdWx0IHVpLXByaW9yaXR5LXByaW1hcnkgdWktY29ybmVyLWFsbCcgZGF0YS1oYW5kbGVyPSdoaWRlJyBkYXRhLWV2ZW50PSdjbGljayc+XFxcIiArIHRoaXMuX2dldChpbnN0LCBcXFwiY2xvc2VUZXh0XFxcIikgKyBcXFwiPC9idXR0b24+XFxcIiA6IFxcXCJcXFwiO1xcblxcblxcdFxcdFxcdGJ1dHRvblBhbmVsID0gc2hvd0J1dHRvblBhbmVsID8gXFxcIjxkaXYgY2xhc3M9J3VpLWRhdGVwaWNrZXItYnV0dG9ucGFuZSB1aS13aWRnZXQtY29udGVudCc+XFxcIiArIChpc1JUTCA/IGNvbnRyb2xzIDogXFxcIlxcXCIpICsgKHRoaXMuX2lzSW5SYW5nZShpbnN0LCBnb3RvRGF0ZSkgPyBcXFwiPGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPSd1aS1kYXRlcGlja2VyLWN1cnJlbnQgdWktc3RhdGUtZGVmYXVsdCB1aS1wcmlvcml0eS1zZWNvbmRhcnkgdWktY29ybmVyLWFsbCcgZGF0YS1oYW5kbGVyPSd0b2RheScgZGF0YS1ldmVudD0nY2xpY2snXFxcIiArIFxcXCI+XFxcIiArIGN1cnJlbnRUZXh0ICsgXFxcIjwvYnV0dG9uPlxcXCIgOiBcXFwiXFxcIikgKyAoaXNSVEwgPyBcXFwiXFxcIiA6IGNvbnRyb2xzKSArIFxcXCI8L2Rpdj5cXFwiIDogXFxcIlxcXCI7XFxuXFxuXFx0XFx0XFx0Zmlyc3REYXkgPSBwYXJzZUludCh0aGlzLl9nZXQoaW5zdCwgXFxcImZpcnN0RGF5XFxcIiksIDEwKTtcXG5cXHRcXHRcXHRmaXJzdERheSA9IGlzTmFOKGZpcnN0RGF5KSA/IDAgOiBmaXJzdERheTtcXG5cXG5cXHRcXHRcXHRzaG93V2VlayA9IHRoaXMuX2dldChpbnN0LCBcXFwic2hvd1dlZWtcXFwiKTtcXG5cXHRcXHRcXHRkYXlOYW1lcyA9IHRoaXMuX2dldChpbnN0LCBcXFwiZGF5TmFtZXNcXFwiKTtcXG5cXHRcXHRcXHRkYXlOYW1lc01pbiA9IHRoaXMuX2dldChpbnN0LCBcXFwiZGF5TmFtZXNNaW5cXFwiKTtcXG5cXHRcXHRcXHRtb250aE5hbWVzID0gdGhpcy5fZ2V0KGluc3QsIFxcXCJtb250aE5hbWVzXFxcIik7XFxuXFx0XFx0XFx0bW9udGhOYW1lc1Nob3J0ID0gdGhpcy5fZ2V0KGluc3QsIFxcXCJtb250aE5hbWVzU2hvcnRcXFwiKTtcXG5cXHRcXHRcXHRiZWZvcmVTaG93RGF5ID0gdGhpcy5fZ2V0KGluc3QsIFxcXCJiZWZvcmVTaG93RGF5XFxcIik7XFxuXFx0XFx0XFx0c2hvd090aGVyTW9udGhzID0gdGhpcy5fZ2V0KGluc3QsIFxcXCJzaG93T3RoZXJNb250aHNcXFwiKTtcXG5cXHRcXHRcXHRzZWxlY3RPdGhlck1vbnRocyA9IHRoaXMuX2dldChpbnN0LCBcXFwic2VsZWN0T3RoZXJNb250aHNcXFwiKTtcXG5cXHRcXHRcXHRkZWZhdWx0RGF0ZSA9IHRoaXMuX2dldERlZmF1bHREYXRlKGluc3QpO1xcblxcdFxcdFxcdGh0bWwgPSBcXFwiXFxcIjtcXG5cXHRcXHRcXHRkb3c7XFxuXFx0XFx0XFx0Zm9yIChyb3cgPSAwOyByb3cgPCBudW1Nb250aHNbMF07IHJvdysrKSB7XFxuXFx0XFx0XFx0XFx0Z3JvdXAgPSBcXFwiXFxcIjtcXG5cXHRcXHRcXHRcXHR0aGlzLm1heFJvd3MgPSA0O1xcblxcdFxcdFxcdFxcdGZvciAoY29sID0gMDsgY29sIDwgbnVtTW9udGhzWzFdOyBjb2wrKykge1xcblxcdFxcdFxcdFxcdFxcdHNlbGVjdGVkRGF0ZSA9IHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KG5ldyBEYXRlKGRyYXdZZWFyLCBkcmF3TW9udGgsIGluc3Quc2VsZWN0ZWREYXkpKTtcXG5cXHRcXHRcXHRcXHRcXHRjb3JuZXJDbGFzcyA9IFxcXCIgdWktY29ybmVyLWFsbFxcXCI7XFxuXFx0XFx0XFx0XFx0XFx0Y2FsZW5kZXIgPSBcXFwiXFxcIjtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoaXNNdWx0aU1vbnRoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FsZW5kZXIgKz0gXFxcIjxkaXYgY2xhc3M9J3VpLWRhdGVwaWNrZXItZ3JvdXBcXFwiO1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChudW1Nb250aHNbMV0gPiAxKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c3dpdGNoIChjb2wpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjYXNlIDA6XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Y2FsZW5kZXIgKz0gXFxcIiB1aS1kYXRlcGlja2VyLWdyb3VwLWZpcnN0XFxcIjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjb3JuZXJDbGFzcyA9IFxcXCIgdWktY29ybmVyLVxcXCIgKyAoaXNSVEwgPyBcXFwicmlnaHRcXFwiIDogXFxcImxlZnRcXFwiKTticmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjYXNlIG51bU1vbnRoc1sxXSAtIDE6XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Y2FsZW5kZXIgKz0gXFxcIiB1aS1kYXRlcGlja2VyLWdyb3VwLWxhc3RcXFwiO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGNvcm5lckNsYXNzID0gXFxcIiB1aS1jb3JuZXItXFxcIiArIChpc1JUTCA/IFxcXCJsZWZ0XFxcIiA6IFxcXCJyaWdodFxcXCIpO2JyZWFrO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRlZmF1bHQ6XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Y2FsZW5kZXIgKz0gXFxcIiB1aS1kYXRlcGlja2VyLWdyb3VwLW1pZGRsZVxcXCI7Y29ybmVyQ2xhc3MgPSBcXFwiXFxcIjticmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdGNhbGVuZGVyICs9IFxcXCInPlxcXCI7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGNhbGVuZGVyICs9IFxcXCI8ZGl2IGNsYXNzPSd1aS1kYXRlcGlja2VyLWhlYWRlciB1aS13aWRnZXQtaGVhZGVyIHVpLWhlbHBlci1jbGVhcmZpeFxcXCIgKyBjb3JuZXJDbGFzcyArIFxcXCInPlxcXCIgKyAoL2FsbHxsZWZ0Ly50ZXN0KGNvcm5lckNsYXNzKSAmJiByb3cgPT09IDAgPyBpc1JUTCA/IG5leHQgOiBwcmV2IDogXFxcIlxcXCIpICsgKC9hbGx8cmlnaHQvLnRlc3QoY29ybmVyQ2xhc3MpICYmIHJvdyA9PT0gMCA/IGlzUlRMID8gcHJldiA6IG5leHQgOiBcXFwiXFxcIikgKyB0aGlzLl9nZW5lcmF0ZU1vbnRoWWVhckhlYWRlcihpbnN0LCBkcmF3TW9udGgsIGRyYXdZZWFyLCBtaW5EYXRlLCBtYXhEYXRlLCByb3cgPiAwIHx8IGNvbCA+IDAsIG1vbnRoTmFtZXMsIG1vbnRoTmFtZXNTaG9ydCkgKyAvLyBkcmF3IG1vbnRoIGhlYWRlcnNcXG5cXHRcXHRcXHRcXHRcXHRcXFwiPC9kaXY+PHRhYmxlIGNsYXNzPSd1aS1kYXRlcGlja2VyLWNhbGVuZGFyJz48dGhlYWQ+XFxcIiArIFxcXCI8dHI+XFxcIjtcXG5cXHRcXHRcXHRcXHRcXHR0aGVhZCA9IHNob3dXZWVrID8gXFxcIjx0aCBjbGFzcz0ndWktZGF0ZXBpY2tlci13ZWVrLWNvbCc+XFxcIiArIHRoaXMuX2dldChpbnN0LCBcXFwid2Vla0hlYWRlclxcXCIpICsgXFxcIjwvdGg+XFxcIiA6IFxcXCJcXFwiO1xcblxcdFxcdFxcdFxcdFxcdGZvciAoZG93ID0gMDsgZG93IDwgNzsgZG93KyspIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBkYXlzIG9mIHRoZSB3ZWVrXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZGF5ID0gKGRvdyArIGZpcnN0RGF5KSAlIDc7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhlYWQgKz0gXFxcIjx0aCBzY29wZT0nY29sJ1xcXCIgKyAoKGRvdyArIGZpcnN0RGF5ICsgNikgJSA3ID49IDUgPyBcXFwiIGNsYXNzPSd1aS1kYXRlcGlja2VyLXdlZWstZW5kJ1xcXCIgOiBcXFwiXFxcIikgKyBcXFwiPlxcXCIgKyBcXFwiPHNwYW4gdGl0bGU9J1xcXCIgKyBkYXlOYW1lc1tkYXldICsgXFxcIic+XFxcIiArIGRheU5hbWVzTWluW2RheV0gKyBcXFwiPC9zcGFuPjwvdGg+XFxcIjtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0Y2FsZW5kZXIgKz0gdGhlYWQgKyBcXFwiPC90cj48L3RoZWFkPjx0Ym9keT5cXFwiO1xcblxcdFxcdFxcdFxcdFxcdGRheXNJbk1vbnRoID0gdGhpcy5fZ2V0RGF5c0luTW9udGgoZHJhd1llYXIsIGRyYXdNb250aCk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGRyYXdZZWFyID09PSBpbnN0LnNlbGVjdGVkWWVhciAmJiBkcmF3TW9udGggPT09IGluc3Quc2VsZWN0ZWRNb250aCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGluc3Quc2VsZWN0ZWREYXkgPSBNYXRoLm1pbihpbnN0LnNlbGVjdGVkRGF5LCBkYXlzSW5Nb250aCk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGxlYWREYXlzID0gKHRoaXMuX2dldEZpcnN0RGF5T2ZNb250aChkcmF3WWVhciwgZHJhd01vbnRoKSAtIGZpcnN0RGF5ICsgNykgJSA3O1xcblxcdFxcdFxcdFxcdFxcdGN1clJvd3MgPSBNYXRoLmNlaWwoKGxlYWREYXlzICsgZGF5c0luTW9udGgpIC8gNyk7IC8vIGNhbGN1bGF0ZSB0aGUgbnVtYmVyIG9mIHJvd3MgdG8gZ2VuZXJhdGVcXG5cXHRcXHRcXHRcXHRcXHRudW1Sb3dzID0gaXNNdWx0aU1vbnRoID8gdGhpcy5tYXhSb3dzID4gY3VyUm93cyA/IHRoaXMubWF4Um93cyA6IGN1clJvd3MgOiBjdXJSb3dzOyAvL0lmIG11bHRpcGxlIG1vbnRocywgdXNlIHRoZSBoaWdoZXIgbnVtYmVyIG9mIHJvd3MgKHNlZSAjNzA0MylcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLm1heFJvd3MgPSBudW1Sb3dzO1xcblxcdFxcdFxcdFxcdFxcdHByaW50RGF0ZSA9IHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KG5ldyBEYXRlKGRyYXdZZWFyLCBkcmF3TW9udGgsIDEgLSBsZWFkRGF5cykpO1xcblxcdFxcdFxcdFxcdFxcdGZvciAoZFJvdyA9IDA7IGRSb3cgPCBudW1Sb3dzOyBkUm93KyspIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBjcmVhdGUgZGF0ZSBwaWNrZXIgcm93c1xcblxcdFxcdFxcdFxcdFxcdFxcdGNhbGVuZGVyICs9IFxcXCI8dHI+XFxcIjtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0Ym9keSA9ICFzaG93V2VlayA/IFxcXCJcXFwiIDogXFxcIjx0ZCBjbGFzcz0ndWktZGF0ZXBpY2tlci13ZWVrLWNvbCc+XFxcIiArIHRoaXMuX2dldChpbnN0LCBcXFwiY2FsY3VsYXRlV2Vla1xcXCIpKHByaW50RGF0ZSkgKyBcXFwiPC90ZD5cXFwiO1xcblxcdFxcdFxcdFxcdFxcdFxcdGZvciAoZG93ID0gMDsgZG93IDwgNzsgZG93KyspIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBjcmVhdGUgZGF0ZSBwaWNrZXIgZGF5c1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGRheVNldHRpbmdzID0gYmVmb3JlU2hvd0RheSA/IGJlZm9yZVNob3dEYXkuYXBwbHkoaW5zdC5pbnB1dCA/IGluc3QuaW5wdXRbMF0gOiBudWxsLCBbcHJpbnREYXRlXSkgOiBbdHJ1ZSwgXFxcIlxcXCJdO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG90aGVyTW9udGggPSBwcmludERhdGUuZ2V0TW9udGgoKSAhPT0gZHJhd01vbnRoO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHVuc2VsZWN0YWJsZSA9IG90aGVyTW9udGggJiYgIXNlbGVjdE90aGVyTW9udGhzIHx8ICFkYXlTZXR0aW5nc1swXSB8fCBtaW5EYXRlICYmIHByaW50RGF0ZSA8IG1pbkRhdGUgfHwgbWF4RGF0ZSAmJiBwcmludERhdGUgPiBtYXhEYXRlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRib2R5ICs9IFxcXCI8dGQgY2xhc3M9J1xcXCIgKyAoKGRvdyArIGZpcnN0RGF5ICsgNikgJSA3ID49IDUgPyBcXFwiIHVpLWRhdGVwaWNrZXItd2Vlay1lbmRcXFwiIDogXFxcIlxcXCIpICsgKCAvLyBoaWdobGlnaHQgd2Vla2VuZHNcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRvdGhlck1vbnRoID8gXFxcIiB1aS1kYXRlcGlja2VyLW90aGVyLW1vbnRoXFxcIiA6IFxcXCJcXFwiKSArICggLy8gaGlnaGxpZ2h0IGRheXMgZnJvbSBvdGhlciBtb250aHNcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRwcmludERhdGUuZ2V0VGltZSgpID09PSBzZWxlY3RlZERhdGUuZ2V0VGltZSgpICYmIGRyYXdNb250aCA9PT0gaW5zdC5zZWxlY3RlZE1vbnRoICYmIGluc3QuX2tleUV2ZW50IHx8IC8vIHVzZXIgcHJlc3NlZCBrZXlcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRkZWZhdWx0RGF0ZS5nZXRUaW1lKCkgPT09IHByaW50RGF0ZS5nZXRUaW1lKCkgJiYgZGVmYXVsdERhdGUuZ2V0VGltZSgpID09PSBzZWxlY3RlZERhdGUuZ2V0VGltZSgpID9cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBvciBkZWZhdWx0RGF0ZSBpcyBjdXJyZW50IHByaW50ZWREYXRlIGFuZCBkZWZhdWx0RGF0ZSBpcyBzZWxlY3RlZERhdGVcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXFwiIFxcXCIgKyB0aGlzLl9kYXlPdmVyQ2xhc3MgOiBcXFwiXFxcIikgKyAoIC8vIGhpZ2hsaWdodCBzZWxlY3RlZCBkYXlcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR1bnNlbGVjdGFibGUgPyBcXFwiIFxcXCIgKyB0aGlzLl91bnNlbGVjdGFibGVDbGFzcyArIFxcXCIgdWktc3RhdGUtZGlzYWJsZWRcXFwiIDogXFxcIlxcXCIpICsgKCAvLyBoaWdobGlnaHQgdW5zZWxlY3RhYmxlIGRheXNcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRvdGhlck1vbnRoICYmICFzaG93T3RoZXJNb250aHMgPyBcXFwiXFxcIiA6IFxcXCIgXFxcIiArIGRheVNldHRpbmdzWzFdICsgKCAvLyBoaWdobGlnaHQgY3VzdG9tIGRhdGVzXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cHJpbnREYXRlLmdldFRpbWUoKSA9PT0gY3VycmVudERhdGUuZ2V0VGltZSgpID8gXFxcIiBcXFwiICsgdGhpcy5fY3VycmVudENsYXNzIDogXFxcIlxcXCIpICsgKCAvLyBoaWdobGlnaHQgc2VsZWN0ZWQgZGF5XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cHJpbnREYXRlLmdldFRpbWUoKSA9PT0gdG9kYXkuZ2V0VGltZSgpID8gXFxcIiB1aS1kYXRlcGlja2VyLXRvZGF5XFxcIiA6IFxcXCJcXFwiKSkgKyBcXFwiJ1xcXCIgKyAoIC8vIGhpZ2hsaWdodCB0b2RheSAoaWYgZGlmZmVyZW50KVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdCghb3RoZXJNb250aCB8fCBzaG93T3RoZXJNb250aHMpICYmIGRheVNldHRpbmdzWzJdID8gXFxcIiB0aXRsZT0nXFxcIiArIGRheVNldHRpbmdzWzJdLnJlcGxhY2UoLycvZywgXFxcIiYjMzk7XFxcIikgKyBcXFwiJ1xcXCIgOiBcXFwiXFxcIikgKyAoIC8vIGNlbGwgdGl0bGVcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR1bnNlbGVjdGFibGUgPyBcXFwiXFxcIiA6IFxcXCIgZGF0YS1oYW5kbGVyPSdzZWxlY3REYXknIGRhdGEtZXZlbnQ9J2NsaWNrJyBkYXRhLW1vbnRoPSdcXFwiICsgcHJpbnREYXRlLmdldE1vbnRoKCkgKyBcXFwiJyBkYXRhLXllYXI9J1xcXCIgKyBwcmludERhdGUuZ2V0RnVsbFllYXIoKSArIFxcXCInXFxcIikgKyBcXFwiPlxcXCIgKyAoIC8vIGFjdGlvbnNcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRvdGhlck1vbnRoICYmICFzaG93T3RoZXJNb250aHMgPyBcXFwiJiN4YTA7XFxcIiA6IC8vIGRpc3BsYXkgZm9yIG90aGVyIG1vbnRoc1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHVuc2VsZWN0YWJsZSA/IFxcXCI8c3BhbiBjbGFzcz0ndWktc3RhdGUtZGVmYXVsdCc+XFxcIiArIHByaW50RGF0ZS5nZXREYXRlKCkgKyBcXFwiPC9zcGFuPlxcXCIgOiBcXFwiPGEgY2xhc3M9J3VpLXN0YXRlLWRlZmF1bHRcXFwiICsgKHByaW50RGF0ZS5nZXRUaW1lKCkgPT09IHRvZGF5LmdldFRpbWUoKSA/IFxcXCIgdWktc3RhdGUtaGlnaGxpZ2h0XFxcIiA6IFxcXCJcXFwiKSArIChwcmludERhdGUuZ2V0VGltZSgpID09PSBjdXJyZW50RGF0ZS5nZXRUaW1lKCkgPyBcXFwiIHVpLXN0YXRlLWFjdGl2ZVxcXCIgOiBcXFwiXFxcIikgKyAoIC8vIGhpZ2hsaWdodCBzZWxlY3RlZCBkYXlcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRvdGhlck1vbnRoID8gXFxcIiB1aS1wcmlvcml0eS1zZWNvbmRhcnlcXFwiIDogXFxcIlxcXCIpICsgLy8gZGlzdGluZ3Vpc2ggZGF0ZXMgZnJvbSBvdGhlciBtb250aHNcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXFwiJyBocmVmPScjJz5cXFwiICsgcHJpbnREYXRlLmdldERhdGUoKSArIFxcXCI8L2E+XFxcIikgKyBcXFwiPC90ZD5cXFwiOyAvLyBkaXNwbGF5IHNlbGVjdGFibGUgZGF0ZVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHByaW50RGF0ZS5zZXREYXRlKHByaW50RGF0ZS5nZXREYXRlKCkgKyAxKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRwcmludERhdGUgPSB0aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdChwcmludERhdGUpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRjYWxlbmRlciArPSB0Ym9keSArIFxcXCI8L3RyPlxcXCI7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGRyYXdNb250aCsrO1xcblxcdFxcdFxcdFxcdFxcdGlmIChkcmF3TW9udGggPiAxMSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGRyYXdNb250aCA9IDA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZHJhd1llYXIrKztcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0Y2FsZW5kZXIgKz0gXFxcIjwvdGJvZHk+PC90YWJsZT5cXFwiICsgKGlzTXVsdGlNb250aCA/IFxcXCI8L2Rpdj5cXFwiICsgKG51bU1vbnRoc1swXSA+IDAgJiYgY29sID09PSBudW1Nb250aHNbMV0gLSAxID8gXFxcIjxkaXYgY2xhc3M9J3VpLWRhdGVwaWNrZXItcm93LWJyZWFrJz48L2Rpdj5cXFwiIDogXFxcIlxcXCIpIDogXFxcIlxcXCIpO1xcblxcdFxcdFxcdFxcdFxcdGdyb3VwICs9IGNhbGVuZGVyO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRodG1sICs9IGdyb3VwO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRodG1sICs9IGJ1dHRvblBhbmVsO1xcblxcdFxcdFxcdGluc3QuX2tleUV2ZW50ID0gZmFsc2U7XFxuXFx0XFx0XFx0cmV0dXJuIGh0bWw7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvKiBHZW5lcmF0ZSB0aGUgbW9udGggYW5kIHllYXIgaGVhZGVyLiAqL1xcblxcdFxcdF9nZW5lcmF0ZU1vbnRoWWVhckhlYWRlcjogZnVuY3Rpb24gX2dlbmVyYXRlTW9udGhZZWFySGVhZGVyKGluc3QsIGRyYXdNb250aCwgZHJhd1llYXIsIG1pbkRhdGUsIG1heERhdGUsIHNlY29uZGFyeSwgbW9udGhOYW1lcywgbW9udGhOYW1lc1Nob3J0KSB7XFxuXFxuXFx0XFx0XFx0dmFyIGluTWluWWVhcixcXG5cXHRcXHRcXHQgICAgaW5NYXhZZWFyLFxcblxcdFxcdFxcdCAgICBtb250aCxcXG5cXHRcXHRcXHQgICAgeWVhcnMsXFxuXFx0XFx0XFx0ICAgIHRoaXNZZWFyLFxcblxcdFxcdFxcdCAgICBkZXRlcm1pbmVZZWFyLFxcblxcdFxcdFxcdCAgICB5ZWFyLFxcblxcdFxcdFxcdCAgICBlbmRZZWFyLFxcblxcdFxcdFxcdCAgICBjaGFuZ2VNb250aCA9IHRoaXMuX2dldChpbnN0LCBcXFwiY2hhbmdlTW9udGhcXFwiKSxcXG5cXHRcXHRcXHQgICAgY2hhbmdlWWVhciA9IHRoaXMuX2dldChpbnN0LCBcXFwiY2hhbmdlWWVhclxcXCIpLFxcblxcdFxcdFxcdCAgICBzaG93TW9udGhBZnRlclllYXIgPSB0aGlzLl9nZXQoaW5zdCwgXFxcInNob3dNb250aEFmdGVyWWVhclxcXCIpLFxcblxcdFxcdFxcdCAgICBodG1sID0gXFxcIjxkaXYgY2xhc3M9J3VpLWRhdGVwaWNrZXItdGl0bGUnPlxcXCIsXFxuXFx0XFx0XFx0ICAgIG1vbnRoSHRtbCA9IFxcXCJcXFwiO1xcblxcblxcdFxcdFxcdC8vIG1vbnRoIHNlbGVjdGlvblxcblxcdFxcdFxcdGlmIChzZWNvbmRhcnkgfHwgIWNoYW5nZU1vbnRoKSB7XFxuXFx0XFx0XFx0XFx0bW9udGhIdG1sICs9IFxcXCI8c3BhbiBjbGFzcz0ndWktZGF0ZXBpY2tlci1tb250aCc+XFxcIiArIG1vbnRoTmFtZXNbZHJhd01vbnRoXSArIFxcXCI8L3NwYW4+XFxcIjtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdGluTWluWWVhciA9IG1pbkRhdGUgJiYgbWluRGF0ZS5nZXRGdWxsWWVhcigpID09PSBkcmF3WWVhcjtcXG5cXHRcXHRcXHRcXHRpbk1heFllYXIgPSBtYXhEYXRlICYmIG1heERhdGUuZ2V0RnVsbFllYXIoKSA9PT0gZHJhd1llYXI7XFxuXFx0XFx0XFx0XFx0bW9udGhIdG1sICs9IFxcXCI8c2VsZWN0IGNsYXNzPSd1aS1kYXRlcGlja2VyLW1vbnRoJyBkYXRhLWhhbmRsZXI9J3NlbGVjdE1vbnRoJyBkYXRhLWV2ZW50PSdjaGFuZ2UnPlxcXCI7XFxuXFx0XFx0XFx0XFx0Zm9yIChtb250aCA9IDA7IG1vbnRoIDwgMTI7IG1vbnRoKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoKCFpbk1pblllYXIgfHwgbW9udGggPj0gbWluRGF0ZS5nZXRNb250aCgpKSAmJiAoIWluTWF4WWVhciB8fCBtb250aCA8PSBtYXhEYXRlLmdldE1vbnRoKCkpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0bW9udGhIdG1sICs9IFxcXCI8b3B0aW9uIHZhbHVlPSdcXFwiICsgbW9udGggKyBcXFwiJ1xcXCIgKyAobW9udGggPT09IGRyYXdNb250aCA/IFxcXCIgc2VsZWN0ZWQ9J3NlbGVjdGVkJ1xcXCIgOiBcXFwiXFxcIikgKyBcXFwiPlxcXCIgKyBtb250aE5hbWVzU2hvcnRbbW9udGhdICsgXFxcIjwvb3B0aW9uPlxcXCI7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRtb250aEh0bWwgKz0gXFxcIjwvc2VsZWN0PlxcXCI7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICghc2hvd01vbnRoQWZ0ZXJZZWFyKSB7XFxuXFx0XFx0XFx0XFx0aHRtbCArPSBtb250aEh0bWwgKyAoc2Vjb25kYXJ5IHx8ICEoY2hhbmdlTW9udGggJiYgY2hhbmdlWWVhcikgPyBcXFwiJiN4YTA7XFxcIiA6IFxcXCJcXFwiKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8geWVhciBzZWxlY3Rpb25cXG5cXHRcXHRcXHRpZiAoIWluc3QueWVhcnNodG1sKSB7XFxuXFx0XFx0XFx0XFx0aW5zdC55ZWFyc2h0bWwgPSBcXFwiXFxcIjtcXG5cXHRcXHRcXHRcXHRpZiAoc2Vjb25kYXJ5IHx8ICFjaGFuZ2VZZWFyKSB7XFxuXFx0XFx0XFx0XFx0XFx0aHRtbCArPSBcXFwiPHNwYW4gY2xhc3M9J3VpLWRhdGVwaWNrZXIteWVhcic+XFxcIiArIGRyYXdZZWFyICsgXFxcIjwvc3Bhbj5cXFwiO1xcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gZGV0ZXJtaW5lIHJhbmdlIG9mIHllYXJzIHRvIGRpc3BsYXlcXG5cXHRcXHRcXHRcXHRcXHR5ZWFycyA9IHRoaXMuX2dldChpbnN0LCBcXFwieWVhclJhbmdlXFxcIikuc3BsaXQoXFxcIjpcXFwiKTtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzWWVhciA9IG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKTtcXG5cXHRcXHRcXHRcXHRcXHRkZXRlcm1pbmVZZWFyID0gZnVuY3Rpb24gZGV0ZXJtaW5lWWVhcih2YWx1ZSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHZhciB5ZWFyID0gdmFsdWUubWF0Y2goL2NbK1xcXFwtXS4qLykgPyBkcmF3WWVhciArIHBhcnNlSW50KHZhbHVlLnN1YnN0cmluZygxKSwgMTApIDogdmFsdWUubWF0Y2goL1srXFxcXC1dLiovKSA/IHRoaXNZZWFyICsgcGFyc2VJbnQodmFsdWUsIDEwKSA6IHBhcnNlSW50KHZhbHVlLCAxMCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIGlzTmFOKHllYXIpID8gdGhpc1llYXIgOiB5ZWFyO1xcblxcdFxcdFxcdFxcdFxcdH07XFxuXFx0XFx0XFx0XFx0XFx0eWVhciA9IGRldGVybWluZVllYXIoeWVhcnNbMF0pO1xcblxcdFxcdFxcdFxcdFxcdGVuZFllYXIgPSBNYXRoLm1heCh5ZWFyLCBkZXRlcm1pbmVZZWFyKHllYXJzWzFdIHx8IFxcXCJcXFwiKSk7XFxuXFx0XFx0XFx0XFx0XFx0eWVhciA9IG1pbkRhdGUgPyBNYXRoLm1heCh5ZWFyLCBtaW5EYXRlLmdldEZ1bGxZZWFyKCkpIDogeWVhcjtcXG5cXHRcXHRcXHRcXHRcXHRlbmRZZWFyID0gbWF4RGF0ZSA/IE1hdGgubWluKGVuZFllYXIsIG1heERhdGUuZ2V0RnVsbFllYXIoKSkgOiBlbmRZZWFyO1xcblxcdFxcdFxcdFxcdFxcdGluc3QueWVhcnNodG1sICs9IFxcXCI8c2VsZWN0IGNsYXNzPSd1aS1kYXRlcGlja2VyLXllYXInIGRhdGEtaGFuZGxlcj0nc2VsZWN0WWVhcicgZGF0YS1ldmVudD0nY2hhbmdlJz5cXFwiO1xcblxcdFxcdFxcdFxcdFxcdGZvciAoOyB5ZWFyIDw9IGVuZFllYXI7IHllYXIrKykge1xcblxcdFxcdFxcdFxcdFxcdFxcdGluc3QueWVhcnNodG1sICs9IFxcXCI8b3B0aW9uIHZhbHVlPSdcXFwiICsgeWVhciArIFxcXCInXFxcIiArICh5ZWFyID09PSBkcmF3WWVhciA/IFxcXCIgc2VsZWN0ZWQ9J3NlbGVjdGVkJ1xcXCIgOiBcXFwiXFxcIikgKyBcXFwiPlxcXCIgKyB5ZWFyICsgXFxcIjwvb3B0aW9uPlxcXCI7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGluc3QueWVhcnNodG1sICs9IFxcXCI8L3NlbGVjdD5cXFwiO1xcblxcblxcdFxcdFxcdFxcdFxcdGh0bWwgKz0gaW5zdC55ZWFyc2h0bWw7XFxuXFx0XFx0XFx0XFx0XFx0aW5zdC55ZWFyc2h0bWwgPSBudWxsO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aHRtbCArPSB0aGlzLl9nZXQoaW5zdCwgXFxcInllYXJTdWZmaXhcXFwiKTtcXG5cXHRcXHRcXHRpZiAoc2hvd01vbnRoQWZ0ZXJZZWFyKSB7XFxuXFx0XFx0XFx0XFx0aHRtbCArPSAoc2Vjb25kYXJ5IHx8ICEoY2hhbmdlTW9udGggJiYgY2hhbmdlWWVhcikgPyBcXFwiJiN4YTA7XFxcIiA6IFxcXCJcXFwiKSArIG1vbnRoSHRtbDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aHRtbCArPSBcXFwiPC9kaXY+XFxcIjsgLy8gQ2xvc2UgZGF0ZXBpY2tlcl9oZWFkZXJcXG5cXHRcXHRcXHRyZXR1cm4gaHRtbDtcXG5cXHRcXHR9LFxcblxcblxcdFxcdC8qIEFkanVzdCBvbmUgb2YgdGhlIGRhdGUgc3ViLWZpZWxkcy4gKi9cXG5cXHRcXHRfYWRqdXN0SW5zdERhdGU6IGZ1bmN0aW9uIF9hZGp1c3RJbnN0RGF0ZShpbnN0LCBvZmZzZXQsIHBlcmlvZCkge1xcblxcdFxcdFxcdHZhciB5ZWFyID0gaW5zdC5kcmF3WWVhciArIChwZXJpb2QgPT09IFxcXCJZXFxcIiA/IG9mZnNldCA6IDApLFxcblxcdFxcdFxcdCAgICBtb250aCA9IGluc3QuZHJhd01vbnRoICsgKHBlcmlvZCA9PT0gXFxcIk1cXFwiID8gb2Zmc2V0IDogMCksXFxuXFx0XFx0XFx0ICAgIGRheSA9IE1hdGgubWluKGluc3Quc2VsZWN0ZWREYXksIHRoaXMuX2dldERheXNJbk1vbnRoKHllYXIsIG1vbnRoKSkgKyAocGVyaW9kID09PSBcXFwiRFxcXCIgPyBvZmZzZXQgOiAwKSxcXG5cXHRcXHRcXHQgICAgZGF0ZSA9IHRoaXMuX3Jlc3RyaWN0TWluTWF4KGluc3QsIHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KG5ldyBEYXRlKHllYXIsIG1vbnRoLCBkYXkpKSk7XFxuXFxuXFx0XFx0XFx0aW5zdC5zZWxlY3RlZERheSA9IGRhdGUuZ2V0RGF0ZSgpO1xcblxcdFxcdFxcdGluc3QuZHJhd01vbnRoID0gaW5zdC5zZWxlY3RlZE1vbnRoID0gZGF0ZS5nZXRNb250aCgpO1xcblxcdFxcdFxcdGluc3QuZHJhd1llYXIgPSBpbnN0LnNlbGVjdGVkWWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKTtcXG5cXHRcXHRcXHRpZiAocGVyaW9kID09PSBcXFwiTVxcXCIgfHwgcGVyaW9kID09PSBcXFwiWVxcXCIpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9ub3RpZnlDaGFuZ2UoaW5zdCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFxuXFx0XFx0LyogRW5zdXJlIGEgZGF0ZSBpcyB3aXRoaW4gYW55IG1pbi9tYXggYm91bmRzLiAqL1xcblxcdFxcdF9yZXN0cmljdE1pbk1heDogZnVuY3Rpb24gX3Jlc3RyaWN0TWluTWF4KGluc3QsIGRhdGUpIHtcXG5cXHRcXHRcXHR2YXIgbWluRGF0ZSA9IHRoaXMuX2dldE1pbk1heERhdGUoaW5zdCwgXFxcIm1pblxcXCIpLFxcblxcdFxcdFxcdCAgICBtYXhEYXRlID0gdGhpcy5fZ2V0TWluTWF4RGF0ZShpbnN0LCBcXFwibWF4XFxcIiksXFxuXFx0XFx0XFx0ICAgIG5ld0RhdGUgPSBtaW5EYXRlICYmIGRhdGUgPCBtaW5EYXRlID8gbWluRGF0ZSA6IGRhdGU7XFxuXFx0XFx0XFx0cmV0dXJuIG1heERhdGUgJiYgbmV3RGF0ZSA+IG1heERhdGUgPyBtYXhEYXRlIDogbmV3RGF0ZTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdC8qIE5vdGlmeSBjaGFuZ2Ugb2YgbW9udGgveWVhci4gKi9cXG5cXHRcXHRfbm90aWZ5Q2hhbmdlOiBmdW5jdGlvbiBfbm90aWZ5Q2hhbmdlKGluc3QpIHtcXG5cXHRcXHRcXHR2YXIgb25DaGFuZ2UgPSB0aGlzLl9nZXQoaW5zdCwgXFxcIm9uQ2hhbmdlTW9udGhZZWFyXFxcIik7XFxuXFx0XFx0XFx0aWYgKG9uQ2hhbmdlKSB7XFxuXFx0XFx0XFx0XFx0b25DaGFuZ2UuYXBwbHkoaW5zdC5pbnB1dCA/IGluc3QuaW5wdXRbMF0gOiBudWxsLCBbaW5zdC5zZWxlY3RlZFllYXIsIGluc3Quc2VsZWN0ZWRNb250aCArIDEsIGluc3RdKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvKiBEZXRlcm1pbmUgdGhlIG51bWJlciBvZiBtb250aHMgdG8gc2hvdy4gKi9cXG5cXHRcXHRfZ2V0TnVtYmVyT2ZNb250aHM6IGZ1bmN0aW9uIF9nZXROdW1iZXJPZk1vbnRocyhpbnN0KSB7XFxuXFx0XFx0XFx0dmFyIG51bU1vbnRocyA9IHRoaXMuX2dldChpbnN0LCBcXFwibnVtYmVyT2ZNb250aHNcXFwiKTtcXG5cXHRcXHRcXHRyZXR1cm4gbnVtTW9udGhzID09IG51bGwgPyBbMSwgMV0gOiB0eXBlb2YgbnVtTW9udGhzID09PSBcXFwibnVtYmVyXFxcIiA/IFsxLCBudW1Nb250aHNdIDogbnVtTW9udGhzO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0LyogRGV0ZXJtaW5lIHRoZSBjdXJyZW50IG1heGltdW0gZGF0ZSAtIGVuc3VyZSBubyB0aW1lIGNvbXBvbmVudHMgYXJlIHNldC4gKi9cXG5cXHRcXHRfZ2V0TWluTWF4RGF0ZTogZnVuY3Rpb24gX2dldE1pbk1heERhdGUoaW5zdCwgbWluTWF4KSB7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuX2RldGVybWluZURhdGUoaW5zdCwgdGhpcy5fZ2V0KGluc3QsIG1pbk1heCArIFxcXCJEYXRlXFxcIiksIG51bGwpO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0LyogRmluZCB0aGUgbnVtYmVyIG9mIGRheXMgaW4gYSBnaXZlbiBtb250aC4gKi9cXG5cXHRcXHRfZ2V0RGF5c0luTW9udGg6IGZ1bmN0aW9uIF9nZXREYXlzSW5Nb250aCh5ZWFyLCBtb250aCkge1xcblxcdFxcdFxcdHJldHVybiAzMiAtIHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KG5ldyBEYXRlKHllYXIsIG1vbnRoLCAzMikpLmdldERhdGUoKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdC8qIEZpbmQgdGhlIGRheSBvZiB0aGUgd2VlayBvZiB0aGUgZmlyc3Qgb2YgYSBtb250aC4gKi9cXG5cXHRcXHRfZ2V0Rmlyc3REYXlPZk1vbnRoOiBmdW5jdGlvbiBfZ2V0Rmlyc3REYXlPZk1vbnRoKHllYXIsIG1vbnRoKSB7XFxuXFx0XFx0XFx0cmV0dXJuIG5ldyBEYXRlKHllYXIsIG1vbnRoLCAxKS5nZXREYXkoKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdC8qIERldGVybWluZXMgaWYgd2Ugc2hvdWxkIGFsbG93IGEgXFxcIm5leHQvcHJldlxcXCIgbW9udGggZGlzcGxheSBjaGFuZ2UuICovXFxuXFx0XFx0X2NhbkFkanVzdE1vbnRoOiBmdW5jdGlvbiBfY2FuQWRqdXN0TW9udGgoaW5zdCwgb2Zmc2V0LCBjdXJZZWFyLCBjdXJNb250aCkge1xcblxcdFxcdFxcdHZhciBudW1Nb250aHMgPSB0aGlzLl9nZXROdW1iZXJPZk1vbnRocyhpbnN0KSxcXG5cXHRcXHRcXHQgICAgZGF0ZSA9IHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KG5ldyBEYXRlKGN1clllYXIsIGN1ck1vbnRoICsgKG9mZnNldCA8IDAgPyBvZmZzZXQgOiBudW1Nb250aHNbMF0gKiBudW1Nb250aHNbMV0pLCAxKSk7XFxuXFxuXFx0XFx0XFx0aWYgKG9mZnNldCA8IDApIHtcXG5cXHRcXHRcXHRcXHRkYXRlLnNldERhdGUodGhpcy5fZ2V0RGF5c0luTW9udGgoZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCkpKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuX2lzSW5SYW5nZShpbnN0LCBkYXRlKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdC8qIElzIHRoZSBnaXZlbiBkYXRlIGluIHRoZSBhY2NlcHRlZCByYW5nZT8gKi9cXG5cXHRcXHRfaXNJblJhbmdlOiBmdW5jdGlvbiBfaXNJblJhbmdlKGluc3QsIGRhdGUpIHtcXG5cXHRcXHRcXHR2YXIgeWVhclNwbGl0LFxcblxcdFxcdFxcdCAgICBjdXJyZW50WWVhcixcXG5cXHRcXHRcXHQgICAgbWluRGF0ZSA9IHRoaXMuX2dldE1pbk1heERhdGUoaW5zdCwgXFxcIm1pblxcXCIpLFxcblxcdFxcdFxcdCAgICBtYXhEYXRlID0gdGhpcy5fZ2V0TWluTWF4RGF0ZShpbnN0LCBcXFwibWF4XFxcIiksXFxuXFx0XFx0XFx0ICAgIG1pblllYXIgPSBudWxsLFxcblxcdFxcdFxcdCAgICBtYXhZZWFyID0gbnVsbCxcXG5cXHRcXHRcXHQgICAgeWVhcnMgPSB0aGlzLl9nZXQoaW5zdCwgXFxcInllYXJSYW5nZVxcXCIpO1xcblxcdFxcdFxcdGlmICh5ZWFycykge1xcblxcdFxcdFxcdFxcdHllYXJTcGxpdCA9IHllYXJzLnNwbGl0KFxcXCI6XFxcIik7XFxuXFx0XFx0XFx0XFx0Y3VycmVudFllYXIgPSBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCk7XFxuXFx0XFx0XFx0XFx0bWluWWVhciA9IHBhcnNlSW50KHllYXJTcGxpdFswXSwgMTApO1xcblxcdFxcdFxcdFxcdG1heFllYXIgPSBwYXJzZUludCh5ZWFyU3BsaXRbMV0sIDEwKTtcXG5cXHRcXHRcXHRcXHRpZiAoeWVhclNwbGl0WzBdLm1hdGNoKC9bK1xcXFwtXS4qLykpIHtcXG5cXHRcXHRcXHRcXHRcXHRtaW5ZZWFyICs9IGN1cnJlbnRZZWFyO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRpZiAoeWVhclNwbGl0WzFdLm1hdGNoKC9bK1xcXFwtXS4qLykpIHtcXG5cXHRcXHRcXHRcXHRcXHRtYXhZZWFyICs9IGN1cnJlbnRZZWFyO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuICghbWluRGF0ZSB8fCBkYXRlLmdldFRpbWUoKSA+PSBtaW5EYXRlLmdldFRpbWUoKSkgJiYgKCFtYXhEYXRlIHx8IGRhdGUuZ2V0VGltZSgpIDw9IG1heERhdGUuZ2V0VGltZSgpKSAmJiAoIW1pblllYXIgfHwgZGF0ZS5nZXRGdWxsWWVhcigpID49IG1pblllYXIpICYmICghbWF4WWVhciB8fCBkYXRlLmdldEZ1bGxZZWFyKCkgPD0gbWF4WWVhcik7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvKiBQcm92aWRlIHRoZSBjb25maWd1cmF0aW9uIHNldHRpbmdzIGZvciBmb3JtYXR0aW5nL3BhcnNpbmcuICovXFxuXFx0XFx0X2dldEZvcm1hdENvbmZpZzogZnVuY3Rpb24gX2dldEZvcm1hdENvbmZpZyhpbnN0KSB7XFxuXFx0XFx0XFx0dmFyIHNob3J0WWVhckN1dG9mZiA9IHRoaXMuX2dldChpbnN0LCBcXFwic2hvcnRZZWFyQ3V0b2ZmXFxcIik7XFxuXFx0XFx0XFx0c2hvcnRZZWFyQ3V0b2ZmID0gdHlwZW9mIHNob3J0WWVhckN1dG9mZiAhPT0gXFxcInN0cmluZ1xcXCIgPyBzaG9ydFllYXJDdXRvZmYgOiBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCkgJSAxMDAgKyBwYXJzZUludChzaG9ydFllYXJDdXRvZmYsIDEwKTtcXG5cXHRcXHRcXHRyZXR1cm4geyBzaG9ydFllYXJDdXRvZmY6IHNob3J0WWVhckN1dG9mZixcXG5cXHRcXHRcXHRcXHRkYXlOYW1lc1Nob3J0OiB0aGlzLl9nZXQoaW5zdCwgXFxcImRheU5hbWVzU2hvcnRcXFwiKSwgZGF5TmFtZXM6IHRoaXMuX2dldChpbnN0LCBcXFwiZGF5TmFtZXNcXFwiKSxcXG5cXHRcXHRcXHRcXHRtb250aE5hbWVzU2hvcnQ6IHRoaXMuX2dldChpbnN0LCBcXFwibW9udGhOYW1lc1Nob3J0XFxcIiksIG1vbnRoTmFtZXM6IHRoaXMuX2dldChpbnN0LCBcXFwibW9udGhOYW1lc1xcXCIpIH07XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvKiBGb3JtYXQgdGhlIGdpdmVuIGRhdGUgZm9yIGRpc3BsYXkuICovXFxuXFx0XFx0X2Zvcm1hdERhdGU6IGZ1bmN0aW9uIF9mb3JtYXREYXRlKGluc3QsIGRheSwgbW9udGgsIHllYXIpIHtcXG5cXHRcXHRcXHRpZiAoIWRheSkge1xcblxcdFxcdFxcdFxcdGluc3QuY3VycmVudERheSA9IGluc3Quc2VsZWN0ZWREYXk7XFxuXFx0XFx0XFx0XFx0aW5zdC5jdXJyZW50TW9udGggPSBpbnN0LnNlbGVjdGVkTW9udGg7XFxuXFx0XFx0XFx0XFx0aW5zdC5jdXJyZW50WWVhciA9IGluc3Quc2VsZWN0ZWRZZWFyO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR2YXIgZGF0ZSA9IGRheSA/ICh0eXBlb2YgZGF5ID09PSBcXFwidW5kZWZpbmVkXFxcIiA/IFxcXCJ1bmRlZmluZWRcXFwiIDogX3R5cGVvZihkYXkpKSA9PT0gXFxcIm9iamVjdFxcXCIgPyBkYXkgOiB0aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdChuZXcgRGF0ZSh5ZWFyLCBtb250aCwgZGF5KSkgOiB0aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdChuZXcgRGF0ZShpbnN0LmN1cnJlbnRZZWFyLCBpbnN0LmN1cnJlbnRNb250aCwgaW5zdC5jdXJyZW50RGF5KSk7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZm9ybWF0RGF0ZSh0aGlzLl9nZXQoaW5zdCwgXFxcImRhdGVGb3JtYXRcXFwiKSwgZGF0ZSwgdGhpcy5fZ2V0Rm9ybWF0Q29uZmlnKGluc3QpKTtcXG5cXHRcXHR9XFxuXFx0fSk7XFxuXFxuXFx0LypcXG4gICogQmluZCBob3ZlciBldmVudHMgZm9yIGRhdGVwaWNrZXIgZWxlbWVudHMuXFxuICAqIERvbmUgdmlhIGRlbGVnYXRlIHNvIHRoZSBiaW5kaW5nIG9ubHkgb2NjdXJzIG9uY2UgaW4gdGhlIGxpZmV0aW1lIG9mIHRoZSBwYXJlbnQgZGl2LlxcbiAgKiBHbG9iYWwgZGF0ZXBpY2tlcl9pbnN0QWN0aXZlLCBzZXQgYnkgX3VwZGF0ZURhdGVwaWNrZXIgYWxsb3dzIHRoZSBoYW5kbGVycyB0byBmaW5kIHRoZWlyIHdheSBiYWNrIHRvIHRoZSBhY3RpdmUgcGlja2VyLlxcbiAgKi9cXG5cXHRmdW5jdGlvbiBkYXRlcGlja2VyX2JpbmRIb3ZlcihkcERpdikge1xcblxcdFxcdHZhciBzZWxlY3RvciA9IFxcXCJidXR0b24sIC51aS1kYXRlcGlja2VyLXByZXYsIC51aS1kYXRlcGlja2VyLW5leHQsIC51aS1kYXRlcGlja2VyLWNhbGVuZGFyIHRkIGFcXFwiO1xcblxcdFxcdHJldHVybiBkcERpdi5kZWxlZ2F0ZShzZWxlY3RvciwgXFxcIm1vdXNlb3V0XFxcIiwgZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdCQodGhpcykucmVtb3ZlQ2xhc3MoXFxcInVpLXN0YXRlLWhvdmVyXFxcIik7XFxuXFx0XFx0XFx0aWYgKHRoaXMuY2xhc3NOYW1lLmluZGV4T2YoXFxcInVpLWRhdGVwaWNrZXItcHJldlxcXCIpICE9PSAtMSkge1xcblxcdFxcdFxcdFxcdCQodGhpcykucmVtb3ZlQ2xhc3MoXFxcInVpLWRhdGVwaWNrZXItcHJldi1ob3ZlclxcXCIpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAodGhpcy5jbGFzc05hbWUuaW5kZXhPZihcXFwidWktZGF0ZXBpY2tlci1uZXh0XFxcIikgIT09IC0xKSB7XFxuXFx0XFx0XFx0XFx0JCh0aGlzKS5yZW1vdmVDbGFzcyhcXFwidWktZGF0ZXBpY2tlci1uZXh0LWhvdmVyXFxcIik7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0pLmRlbGVnYXRlKHNlbGVjdG9yLCBcXFwibW91c2VvdmVyXFxcIiwgZGF0ZXBpY2tlcl9oYW5kbGVNb3VzZW92ZXIpO1xcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBkYXRlcGlja2VyX2hhbmRsZU1vdXNlb3ZlcigpIHtcXG5cXHRcXHRpZiAoISQuZGF0ZXBpY2tlci5faXNEaXNhYmxlZERhdGVwaWNrZXIoZGF0ZXBpY2tlcl9pbnN0QWN0aXZlLmlubGluZSA/IGRhdGVwaWNrZXJfaW5zdEFjdGl2ZS5kcERpdi5wYXJlbnQoKVswXSA6IGRhdGVwaWNrZXJfaW5zdEFjdGl2ZS5pbnB1dFswXSkpIHtcXG5cXHRcXHRcXHQkKHRoaXMpLnBhcmVudHMoXFxcIi51aS1kYXRlcGlja2VyLWNhbGVuZGFyXFxcIikuZmluZChcXFwiYVxcXCIpLnJlbW92ZUNsYXNzKFxcXCJ1aS1zdGF0ZS1ob3ZlclxcXCIpO1xcblxcdFxcdFxcdCQodGhpcykuYWRkQ2xhc3MoXFxcInVpLXN0YXRlLWhvdmVyXFxcIik7XFxuXFx0XFx0XFx0aWYgKHRoaXMuY2xhc3NOYW1lLmluZGV4T2YoXFxcInVpLWRhdGVwaWNrZXItcHJldlxcXCIpICE9PSAtMSkge1xcblxcdFxcdFxcdFxcdCQodGhpcykuYWRkQ2xhc3MoXFxcInVpLWRhdGVwaWNrZXItcHJldi1ob3ZlclxcXCIpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAodGhpcy5jbGFzc05hbWUuaW5kZXhPZihcXFwidWktZGF0ZXBpY2tlci1uZXh0XFxcIikgIT09IC0xKSB7XFxuXFx0XFx0XFx0XFx0JCh0aGlzKS5hZGRDbGFzcyhcXFwidWktZGF0ZXBpY2tlci1uZXh0LWhvdmVyXFxcIik7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9XFxuXFxuXFx0LyogalF1ZXJ5IGV4dGVuZCBub3cgaWdub3JlcyBudWxscyEgKi9cXG5cXHRmdW5jdGlvbiBkYXRlcGlja2VyX2V4dGVuZFJlbW92ZSh0YXJnZXQsIHByb3BzKSB7XFxuXFx0XFx0JC5leHRlbmQodGFyZ2V0LCBwcm9wcyk7XFxuXFx0XFx0Zm9yICh2YXIgbmFtZSBpbiBwcm9wcykge1xcblxcdFxcdFxcdGlmIChwcm9wc1tuYW1lXSA9PSBudWxsKSB7XFxuXFx0XFx0XFx0XFx0dGFyZ2V0W25hbWVdID0gcHJvcHNbbmFtZV07XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gdGFyZ2V0O1xcblxcdH1cXG5cXG5cXHQvKiBJbnZva2UgdGhlIGRhdGVwaWNrZXIgZnVuY3Rpb25hbGl0eS5cXG4gICAgQHBhcmFtICBvcHRpb25zICBzdHJpbmcgLSBhIGNvbW1hbmQsIG9wdGlvbmFsbHkgZm9sbG93ZWQgYnkgYWRkaXRpb25hbCBwYXJhbWV0ZXJzIG9yXFxuIFxcdFxcdFxcdFxcdFxcdE9iamVjdCAtIHNldHRpbmdzIGZvciBhdHRhY2hpbmcgbmV3IGRhdGVwaWNrZXIgZnVuY3Rpb25hbGl0eVxcbiAgICBAcmV0dXJuICBqUXVlcnkgb2JqZWN0ICovXFxuXFx0JC5mbi5kYXRlcGlja2VyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcXG5cXG5cXHRcXHQvKiBWZXJpZnkgYW4gZW1wdHkgY29sbGVjdGlvbiB3YXNuJ3QgcGFzc2VkIC0gRml4ZXMgIzY5NzYgKi9cXG5cXHRcXHRpZiAoIXRoaXMubGVuZ3RoKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8qIEluaXRpYWxpc2UgdGhlIGRhdGUgcGlja2VyLiAqL1xcblxcdFxcdGlmICghJC5kYXRlcGlja2VyLmluaXRpYWxpemVkKSB7XFxuXFx0XFx0XFx0JChkb2N1bWVudCkubW91c2Vkb3duKCQuZGF0ZXBpY2tlci5fY2hlY2tFeHRlcm5hbENsaWNrKTtcXG5cXHRcXHRcXHQkLmRhdGVwaWNrZXIuaW5pdGlhbGl6ZWQgPSB0cnVlO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvKiBBcHBlbmQgZGF0ZXBpY2tlciBtYWluIGNvbnRhaW5lciB0byBib2R5IGlmIG5vdCBleGlzdC4gKi9cXG5cXHRcXHRpZiAoJChcXFwiI1xcXCIgKyAkLmRhdGVwaWNrZXIuX21haW5EaXZJZCkubGVuZ3RoID09PSAwKSB7XFxuXFx0XFx0XFx0JChcXFwiYm9keVxcXCIpLmFwcGVuZCgkLmRhdGVwaWNrZXIuZHBEaXYpO1xcblxcdFxcdH1cXG5cXG5cXHRcXHR2YXIgb3RoZXJBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcXG5cXHRcXHRpZiAodHlwZW9mIG9wdGlvbnMgPT09IFxcXCJzdHJpbmdcXFwiICYmIChvcHRpb25zID09PSBcXFwiaXNEaXNhYmxlZFxcXCIgfHwgb3B0aW9ucyA9PT0gXFxcImdldERhdGVcXFwiIHx8IG9wdGlvbnMgPT09IFxcXCJ3aWRnZXRcXFwiKSkge1xcblxcdFxcdFxcdHJldHVybiAkLmRhdGVwaWNrZXJbXFxcIl9cXFwiICsgb3B0aW9ucyArIFxcXCJEYXRlcGlja2VyXFxcIl0uYXBwbHkoJC5kYXRlcGlja2VyLCBbdGhpc1swXV0uY29uY2F0KG90aGVyQXJncykpO1xcblxcdFxcdH1cXG5cXHRcXHRpZiAob3B0aW9ucyA9PT0gXFxcIm9wdGlvblxcXCIgJiYgYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiB0eXBlb2YgYXJndW1lbnRzWzFdID09PSBcXFwic3RyaW5nXFxcIikge1xcblxcdFxcdFxcdHJldHVybiAkLmRhdGVwaWNrZXJbXFxcIl9cXFwiICsgb3B0aW9ucyArIFxcXCJEYXRlcGlja2VyXFxcIl0uYXBwbHkoJC5kYXRlcGlja2VyLCBbdGhpc1swXV0uY29uY2F0KG90aGVyQXJncykpO1xcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHR0eXBlb2Ygb3B0aW9ucyA9PT0gXFxcInN0cmluZ1xcXCIgPyAkLmRhdGVwaWNrZXJbXFxcIl9cXFwiICsgb3B0aW9ucyArIFxcXCJEYXRlcGlja2VyXFxcIl0uYXBwbHkoJC5kYXRlcGlja2VyLCBbdGhpc10uY29uY2F0KG90aGVyQXJncykpIDogJC5kYXRlcGlja2VyLl9hdHRhY2hEYXRlcGlja2VyKHRoaXMsIG9wdGlvbnMpO1xcblxcdFxcdH0pO1xcblxcdH07XFxuXFxuXFx0JC5kYXRlcGlja2VyID0gbmV3IERhdGVwaWNrZXIoKTsgLy8gc2luZ2xldG9uIGluc3RhbmNlXFxuXFx0JC5kYXRlcGlja2VyLmluaXRpYWxpemVkID0gZmFsc2U7XFxuXFx0JC5kYXRlcGlja2VyLnV1aWQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcXG5cXHQkLmRhdGVwaWNrZXIudmVyc2lvbiA9IFxcXCIxLjExLjRcXFwiO1xcblxcblxcdHZhciBkYXRlcGlja2VyID0gJC5kYXRlcGlja2VyO1xcblxcblxcdC8qIVxcbiAgKiBqUXVlcnkgVUkgRHJhZ2dhYmxlIDEuMTEuNFxcbiAgKiBodHRwOi8vanF1ZXJ5dWkuY29tXFxuICAqXFxuICAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXFxuICAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cXG4gICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxcbiAgKlxcbiAgKiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9kcmFnZ2FibGUvXFxuICAqL1xcblxcblxcdCQud2lkZ2V0KFxcXCJ1aS5kcmFnZ2FibGVcXFwiLCAkLnVpLm1vdXNlLCB7XFxuXFx0XFx0dmVyc2lvbjogXFxcIjEuMTEuNFxcXCIsXFxuXFx0XFx0d2lkZ2V0RXZlbnRQcmVmaXg6IFxcXCJkcmFnXFxcIixcXG5cXHRcXHRvcHRpb25zOiB7XFxuXFx0XFx0XFx0YWRkQ2xhc3NlczogdHJ1ZSxcXG5cXHRcXHRcXHRhcHBlbmRUbzogXFxcInBhcmVudFxcXCIsXFxuXFx0XFx0XFx0YXhpczogZmFsc2UsXFxuXFx0XFx0XFx0Y29ubmVjdFRvU29ydGFibGU6IGZhbHNlLFxcblxcdFxcdFxcdGNvbnRhaW5tZW50OiBmYWxzZSxcXG5cXHRcXHRcXHRjdXJzb3I6IFxcXCJhdXRvXFxcIixcXG5cXHRcXHRcXHRjdXJzb3JBdDogZmFsc2UsXFxuXFx0XFx0XFx0Z3JpZDogZmFsc2UsXFxuXFx0XFx0XFx0aGFuZGxlOiBmYWxzZSxcXG5cXHRcXHRcXHRoZWxwZXI6IFxcXCJvcmlnaW5hbFxcXCIsXFxuXFx0XFx0XFx0aWZyYW1lRml4OiBmYWxzZSxcXG5cXHRcXHRcXHRvcGFjaXR5OiBmYWxzZSxcXG5cXHRcXHRcXHRyZWZyZXNoUG9zaXRpb25zOiBmYWxzZSxcXG5cXHRcXHRcXHRyZXZlcnQ6IGZhbHNlLFxcblxcdFxcdFxcdHJldmVydER1cmF0aW9uOiA1MDAsXFxuXFx0XFx0XFx0c2NvcGU6IFxcXCJkZWZhdWx0XFxcIixcXG5cXHRcXHRcXHRzY3JvbGw6IHRydWUsXFxuXFx0XFx0XFx0c2Nyb2xsU2Vuc2l0aXZpdHk6IDIwLFxcblxcdFxcdFxcdHNjcm9sbFNwZWVkOiAyMCxcXG5cXHRcXHRcXHRzbmFwOiBmYWxzZSxcXG5cXHRcXHRcXHRzbmFwTW9kZTogXFxcImJvdGhcXFwiLFxcblxcdFxcdFxcdHNuYXBUb2xlcmFuY2U6IDIwLFxcblxcdFxcdFxcdHN0YWNrOiBmYWxzZSxcXG5cXHRcXHRcXHR6SW5kZXg6IGZhbHNlLFxcblxcblxcdFxcdFxcdC8vIGNhbGxiYWNrc1xcblxcdFxcdFxcdGRyYWc6IG51bGwsXFxuXFx0XFx0XFx0c3RhcnQ6IG51bGwsXFxuXFx0XFx0XFx0c3RvcDogbnVsbFxcblxcdFxcdH0sXFxuXFx0XFx0X2NyZWF0ZTogZnVuY3Rpb24gX2NyZWF0ZSgpIHtcXG5cXG5cXHRcXHRcXHRpZiAodGhpcy5vcHRpb25zLmhlbHBlciA9PT0gXFxcIm9yaWdpbmFsXFxcIikge1xcblxcdFxcdFxcdFxcdHRoaXMuX3NldFBvc2l0aW9uUmVsYXRpdmUoKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKHRoaXMub3B0aW9ucy5hZGRDbGFzc2VzKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5lbGVtZW50LmFkZENsYXNzKFxcXCJ1aS1kcmFnZ2FibGVcXFwiKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKHRoaXMub3B0aW9ucy5kaXNhYmxlZCkge1xcblxcdFxcdFxcdFxcdHRoaXMuZWxlbWVudC5hZGRDbGFzcyhcXFwidWktZHJhZ2dhYmxlLWRpc2FibGVkXFxcIik7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHRoaXMuX3NldEhhbmRsZUNsYXNzTmFtZSgpO1xcblxcblxcdFxcdFxcdHRoaXMuX21vdXNlSW5pdCgpO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X3NldE9wdGlvbjogZnVuY3Rpb24gX3NldE9wdGlvbihrZXksIHZhbHVlKSB7XFxuXFx0XFx0XFx0dGhpcy5fc3VwZXIoa2V5LCB2YWx1ZSk7XFxuXFx0XFx0XFx0aWYgKGtleSA9PT0gXFxcImhhbmRsZVxcXCIpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9yZW1vdmVIYW5kbGVDbGFzc05hbWUoKTtcXG5cXHRcXHRcXHRcXHR0aGlzLl9zZXRIYW5kbGVDbGFzc05hbWUoKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfZGVzdHJveTogZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XFxuXFx0XFx0XFx0aWYgKCh0aGlzLmhlbHBlciB8fCB0aGlzLmVsZW1lbnQpLmlzKFxcXCIudWktZHJhZ2dhYmxlLWRyYWdnaW5nXFxcIikpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLmRlc3Ryb3lPbkNsZWFyID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHRoaXMuZWxlbWVudC5yZW1vdmVDbGFzcyhcXFwidWktZHJhZ2dhYmxlIHVpLWRyYWdnYWJsZS1kcmFnZ2luZyB1aS1kcmFnZ2FibGUtZGlzYWJsZWRcXFwiKTtcXG5cXHRcXHRcXHR0aGlzLl9yZW1vdmVIYW5kbGVDbGFzc05hbWUoKTtcXG5cXHRcXHRcXHR0aGlzLl9tb3VzZURlc3Ryb3koKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9tb3VzZUNhcHR1cmU6IGZ1bmN0aW9uIF9tb3VzZUNhcHR1cmUoZXZlbnQpIHtcXG5cXHRcXHRcXHR2YXIgbyA9IHRoaXMub3B0aW9ucztcXG5cXG5cXHRcXHRcXHR0aGlzLl9ibHVyQWN0aXZlRWxlbWVudChldmVudCk7XFxuXFxuXFx0XFx0XFx0Ly8gYW1vbmcgb3RoZXJzLCBwcmV2ZW50IGEgZHJhZyBvbiBhIHJlc2l6YWJsZS1oYW5kbGVcXG5cXHRcXHRcXHRpZiAodGhpcy5oZWxwZXIgfHwgby5kaXNhYmxlZCB8fCAkKGV2ZW50LnRhcmdldCkuY2xvc2VzdChcXFwiLnVpLXJlc2l6YWJsZS1oYW5kbGVcXFwiKS5sZW5ndGggPiAwKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvL1F1aXQgaWYgd2UncmUgbm90IG9uIGEgdmFsaWQgaGFuZGxlXFxuXFx0XFx0XFx0dGhpcy5oYW5kbGUgPSB0aGlzLl9nZXRIYW5kbGUoZXZlbnQpO1xcblxcdFxcdFxcdGlmICghdGhpcy5oYW5kbGUpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMuX2Jsb2NrRnJhbWVzKG8uaWZyYW1lRml4ID09PSB0cnVlID8gXFxcImlmcmFtZVxcXCIgOiBvLmlmcmFtZUZpeCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfYmxvY2tGcmFtZXM6IGZ1bmN0aW9uIF9ibG9ja0ZyYW1lcyhzZWxlY3Rvcikge1xcblxcdFxcdFxcdHRoaXMuaWZyYW1lQmxvY2tzID0gdGhpcy5kb2N1bWVudC5maW5kKHNlbGVjdG9yKS5tYXAoZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdHZhciBpZnJhbWUgPSAkKHRoaXMpO1xcblxcblxcdFxcdFxcdFxcdHJldHVybiAkKFxcXCI8ZGl2PlxcXCIpLmNzcyhcXFwicG9zaXRpb25cXFwiLCBcXFwiYWJzb2x1dGVcXFwiKS5hcHBlbmRUbyhpZnJhbWUucGFyZW50KCkpLm91dGVyV2lkdGgoaWZyYW1lLm91dGVyV2lkdGgoKSkub3V0ZXJIZWlnaHQoaWZyYW1lLm91dGVySGVpZ2h0KCkpLm9mZnNldChpZnJhbWUub2Zmc2V0KCkpWzBdO1xcblxcdFxcdFxcdH0pO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X3VuYmxvY2tGcmFtZXM6IGZ1bmN0aW9uIF91bmJsb2NrRnJhbWVzKCkge1xcblxcdFxcdFxcdGlmICh0aGlzLmlmcmFtZUJsb2Nrcykge1xcblxcdFxcdFxcdFxcdHRoaXMuaWZyYW1lQmxvY2tzLnJlbW92ZSgpO1xcblxcdFxcdFxcdFxcdGRlbGV0ZSB0aGlzLmlmcmFtZUJsb2NrcztcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfYmx1ckFjdGl2ZUVsZW1lbnQ6IGZ1bmN0aW9uIF9ibHVyQWN0aXZlRWxlbWVudChldmVudCkge1xcblxcdFxcdFxcdHZhciBkb2N1bWVudCA9IHRoaXMuZG9jdW1lbnRbMF07XFxuXFxuXFx0XFx0XFx0Ly8gT25seSBuZWVkIHRvIGJsdXIgaWYgdGhlIGV2ZW50IG9jY3VycmVkIG9uIHRoZSBkcmFnZ2FibGUgaXRzZWxmLCBzZWUgIzEwNTI3XFxuXFx0XFx0XFx0aWYgKCF0aGlzLmhhbmRsZUVsZW1lbnQuaXMoZXZlbnQudGFyZ2V0KSkge1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gc3VwcG9ydDogSUU5XFxuXFx0XFx0XFx0Ly8gSUU5IHRocm93cyBhbiBcXFwiVW5zcGVjaWZpZWQgZXJyb3JcXFwiIGFjY2Vzc2luZyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGZyb20gYW4gPGlmcmFtZT5cXG5cXHRcXHRcXHR0cnkge1xcblxcblxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IElFOSwgSUUxMFxcblxcdFxcdFxcdFxcdC8vIElmIHRoZSA8Ym9keT4gaXMgYmx1cnJlZCwgSUUgd2lsbCBzd2l0Y2ggd2luZG93cywgc2VlICM5NTIwXFxuXFx0XFx0XFx0XFx0aWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcXFwiYm9keVxcXCIpIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBCbHVyIGFueSBlbGVtZW50IHRoYXQgY3VycmVudGx5IGhhcyBmb2N1cywgc2VlICM0MjYxXFxuXFx0XFx0XFx0XFx0XFx0JChkb2N1bWVudC5hY3RpdmVFbGVtZW50KS5ibHVyKCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0gY2F0Y2ggKGVycm9yKSB7fVxcblxcdFxcdH0sXFxuXFxuXFx0XFx0X21vdXNlU3RhcnQ6IGZ1bmN0aW9uIF9tb3VzZVN0YXJ0KGV2ZW50KSB7XFxuXFxuXFx0XFx0XFx0dmFyIG8gPSB0aGlzLm9wdGlvbnM7XFxuXFxuXFx0XFx0XFx0Ly9DcmVhdGUgYW5kIGFwcGVuZCB0aGUgdmlzaWJsZSBoZWxwZXJcXG5cXHRcXHRcXHR0aGlzLmhlbHBlciA9IHRoaXMuX2NyZWF0ZUhlbHBlcihldmVudCk7XFxuXFxuXFx0XFx0XFx0dGhpcy5oZWxwZXIuYWRkQ2xhc3MoXFxcInVpLWRyYWdnYWJsZS1kcmFnZ2luZ1xcXCIpO1xcblxcblxcdFxcdFxcdC8vQ2FjaGUgdGhlIGhlbHBlciBzaXplXFxuXFx0XFx0XFx0dGhpcy5fY2FjaGVIZWxwZXJQcm9wb3J0aW9ucygpO1xcblxcblxcdFxcdFxcdC8vSWYgZGRtYW5hZ2VyIGlzIHVzZWQgZm9yIGRyb3BwYWJsZXMsIHNldCB0aGUgZ2xvYmFsIGRyYWdnYWJsZVxcblxcdFxcdFxcdGlmICgkLnVpLmRkbWFuYWdlcikge1xcblxcdFxcdFxcdFxcdCQudWkuZGRtYW5hZ2VyLmN1cnJlbnQgPSB0aGlzO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvKlxcbiAgICAqIC0gUG9zaXRpb24gZ2VuZXJhdGlvbiAtXFxuICAgICogVGhpcyBibG9jayBnZW5lcmF0ZXMgZXZlcnl0aGluZyBwb3NpdGlvbiByZWxhdGVkIC0gaXQncyB0aGUgY29yZSBvZiBkcmFnZ2FibGVzLlxcbiAgICAqL1xcblxcblxcdFxcdFxcdC8vQ2FjaGUgdGhlIG1hcmdpbnMgb2YgdGhlIG9yaWdpbmFsIGVsZW1lbnRcXG5cXHRcXHRcXHR0aGlzLl9jYWNoZU1hcmdpbnMoKTtcXG5cXG5cXHRcXHRcXHQvL1N0b3JlIHRoZSBoZWxwZXIncyBjc3MgcG9zaXRpb25cXG5cXHRcXHRcXHR0aGlzLmNzc1Bvc2l0aW9uID0gdGhpcy5oZWxwZXIuY3NzKFxcXCJwb3NpdGlvblxcXCIpO1xcblxcdFxcdFxcdHRoaXMuc2Nyb2xsUGFyZW50ID0gdGhpcy5oZWxwZXIuc2Nyb2xsUGFyZW50KHRydWUpO1xcblxcdFxcdFxcdHRoaXMub2Zmc2V0UGFyZW50ID0gdGhpcy5oZWxwZXIub2Zmc2V0UGFyZW50KCk7XFxuXFx0XFx0XFx0dGhpcy5oYXNGaXhlZEFuY2VzdG9yID0gdGhpcy5oZWxwZXIucGFyZW50cygpLmZpbHRlcihmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuICQodGhpcykuY3NzKFxcXCJwb3NpdGlvblxcXCIpID09PSBcXFwiZml4ZWRcXFwiO1xcblxcdFxcdFxcdH0pLmxlbmd0aCA+IDA7XFxuXFxuXFx0XFx0XFx0Ly9UaGUgZWxlbWVudCdzIGFic29sdXRlIHBvc2l0aW9uIG9uIHRoZSBwYWdlIG1pbnVzIG1hcmdpbnNcXG5cXHRcXHRcXHR0aGlzLnBvc2l0aW9uQWJzID0gdGhpcy5lbGVtZW50Lm9mZnNldCgpO1xcblxcdFxcdFxcdHRoaXMuX3JlZnJlc2hPZmZzZXRzKGV2ZW50KTtcXG5cXG5cXHRcXHRcXHQvL0dlbmVyYXRlIHRoZSBvcmlnaW5hbCBwb3NpdGlvblxcblxcdFxcdFxcdHRoaXMub3JpZ2luYWxQb3NpdGlvbiA9IHRoaXMucG9zaXRpb24gPSB0aGlzLl9nZW5lcmF0ZVBvc2l0aW9uKGV2ZW50LCBmYWxzZSk7XFxuXFx0XFx0XFx0dGhpcy5vcmlnaW5hbFBhZ2VYID0gZXZlbnQucGFnZVg7XFxuXFx0XFx0XFx0dGhpcy5vcmlnaW5hbFBhZ2VZID0gZXZlbnQucGFnZVk7XFxuXFxuXFx0XFx0XFx0Ly9BZGp1c3QgdGhlIG1vdXNlIG9mZnNldCByZWxhdGl2ZSB0byB0aGUgaGVscGVyIGlmIFxcXCJjdXJzb3JBdFxcXCIgaXMgc3VwcGxpZWRcXG5cXHRcXHRcXHRvLmN1cnNvckF0ICYmIHRoaXMuX2FkanVzdE9mZnNldEZyb21IZWxwZXIoby5jdXJzb3JBdCk7XFxuXFxuXFx0XFx0XFx0Ly9TZXQgYSBjb250YWlubWVudCBpZiBnaXZlbiBpbiB0aGUgb3B0aW9uc1xcblxcdFxcdFxcdHRoaXMuX3NldENvbnRhaW5tZW50KCk7XFxuXFxuXFx0XFx0XFx0Ly9UcmlnZ2VyIGV2ZW50ICsgY2FsbGJhY2tzXFxuXFx0XFx0XFx0aWYgKHRoaXMuX3RyaWdnZXIoXFxcInN0YXJ0XFxcIiwgZXZlbnQpID09PSBmYWxzZSkge1xcblxcdFxcdFxcdFxcdHRoaXMuX2NsZWFyKCk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvL1JlY2FjaGUgdGhlIGhlbHBlciBzaXplXFxuXFx0XFx0XFx0dGhpcy5fY2FjaGVIZWxwZXJQcm9wb3J0aW9ucygpO1xcblxcblxcdFxcdFxcdC8vUHJlcGFyZSB0aGUgZHJvcHBhYmxlIG9mZnNldHNcXG5cXHRcXHRcXHRpZiAoJC51aS5kZG1hbmFnZXIgJiYgIW8uZHJvcEJlaGF2aW91cikge1xcblxcdFxcdFxcdFxcdCQudWkuZGRtYW5hZ2VyLnByZXBhcmVPZmZzZXRzKHRoaXMsIGV2ZW50KTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gUmVzZXQgaGVscGVyJ3MgcmlnaHQvYm90dG9tIGNzcyBpZiB0aGV5J3JlIHNldCBhbmQgc2V0IGV4cGxpY2l0IHdpZHRoL2hlaWdodCBpbnN0ZWFkXFxuXFx0XFx0XFx0Ly8gYXMgdGhpcyBwcmV2ZW50cyByZXNpemluZyBvZiBlbGVtZW50cyB3aXRoIHJpZ2h0L2JvdHRvbSBzZXQgKHNlZSAjNzc3MilcXG5cXHRcXHRcXHR0aGlzLl9ub3JtYWxpemVSaWdodEJvdHRvbSgpO1xcblxcblxcdFxcdFxcdHRoaXMuX21vdXNlRHJhZyhldmVudCwgdHJ1ZSk7IC8vRXhlY3V0ZSB0aGUgZHJhZyBvbmNlIC0gdGhpcyBjYXVzZXMgdGhlIGhlbHBlciBub3QgdG8gYmUgdmlzaWJsZSBiZWZvcmUgZ2V0dGluZyBpdHMgY29ycmVjdCBwb3NpdGlvblxcblxcblxcdFxcdFxcdC8vSWYgdGhlIGRkbWFuYWdlciBpcyB1c2VkIGZvciBkcm9wcGFibGVzLCBpbmZvcm0gdGhlIG1hbmFnZXIgdGhhdCBkcmFnZ2luZyBoYXMgc3RhcnRlZCAoc2VlICM1MDAzKVxcblxcdFxcdFxcdGlmICgkLnVpLmRkbWFuYWdlcikge1xcblxcdFxcdFxcdFxcdCQudWkuZGRtYW5hZ2VyLmRyYWdTdGFydCh0aGlzLCBldmVudCk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X3JlZnJlc2hPZmZzZXRzOiBmdW5jdGlvbiBfcmVmcmVzaE9mZnNldHMoZXZlbnQpIHtcXG5cXHRcXHRcXHR0aGlzLm9mZnNldCA9IHtcXG5cXHRcXHRcXHRcXHR0b3A6IHRoaXMucG9zaXRpb25BYnMudG9wIC0gdGhpcy5tYXJnaW5zLnRvcCxcXG5cXHRcXHRcXHRcXHRsZWZ0OiB0aGlzLnBvc2l0aW9uQWJzLmxlZnQgLSB0aGlzLm1hcmdpbnMubGVmdCxcXG5cXHRcXHRcXHRcXHRzY3JvbGw6IGZhbHNlLFxcblxcdFxcdFxcdFxcdHBhcmVudDogdGhpcy5fZ2V0UGFyZW50T2Zmc2V0KCksXFxuXFx0XFx0XFx0XFx0cmVsYXRpdmU6IHRoaXMuX2dldFJlbGF0aXZlT2Zmc2V0KClcXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdFxcdHRoaXMub2Zmc2V0LmNsaWNrID0ge1xcblxcdFxcdFxcdFxcdGxlZnQ6IGV2ZW50LnBhZ2VYIC0gdGhpcy5vZmZzZXQubGVmdCxcXG5cXHRcXHRcXHRcXHR0b3A6IGV2ZW50LnBhZ2VZIC0gdGhpcy5vZmZzZXQudG9wXFxuXFx0XFx0XFx0fTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9tb3VzZURyYWc6IGZ1bmN0aW9uIF9tb3VzZURyYWcoZXZlbnQsIG5vUHJvcGFnYXRpb24pIHtcXG5cXHRcXHRcXHQvLyByZXNldCBhbnkgbmVjZXNzYXJ5IGNhY2hlZCBwcm9wZXJ0aWVzIChzZWUgIzUwMDkpXFxuXFx0XFx0XFx0aWYgKHRoaXMuaGFzRml4ZWRBbmNlc3Rvcikge1xcblxcdFxcdFxcdFxcdHRoaXMub2Zmc2V0LnBhcmVudCA9IHRoaXMuX2dldFBhcmVudE9mZnNldCgpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvL0NvbXB1dGUgdGhlIGhlbHBlcnMgcG9zaXRpb25cXG5cXHRcXHRcXHR0aGlzLnBvc2l0aW9uID0gdGhpcy5fZ2VuZXJhdGVQb3NpdGlvbihldmVudCwgdHJ1ZSk7XFxuXFx0XFx0XFx0dGhpcy5wb3NpdGlvbkFicyA9IHRoaXMuX2NvbnZlcnRQb3NpdGlvblRvKFxcXCJhYnNvbHV0ZVxcXCIpO1xcblxcblxcdFxcdFxcdC8vQ2FsbCBwbHVnaW5zIGFuZCBjYWxsYmFja3MgYW5kIHVzZSB0aGUgcmVzdWx0aW5nIHBvc2l0aW9uIGlmIHNvbWV0aGluZyBpcyByZXR1cm5lZFxcblxcdFxcdFxcdGlmICghbm9Qcm9wYWdhdGlvbikge1xcblxcdFxcdFxcdFxcdHZhciB1aSA9IHRoaXMuX3VpSGFzaCgpO1xcblxcdFxcdFxcdFxcdGlmICh0aGlzLl90cmlnZ2VyKFxcXCJkcmFnXFxcIiwgZXZlbnQsIHVpKSA9PT0gZmFsc2UpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9tb3VzZVVwKHt9KTtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHRoaXMucG9zaXRpb24gPSB1aS5wb3NpdGlvbjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy5oZWxwZXJbMF0uc3R5bGUubGVmdCA9IHRoaXMucG9zaXRpb24ubGVmdCArIFxcXCJweFxcXCI7XFxuXFx0XFx0XFx0dGhpcy5oZWxwZXJbMF0uc3R5bGUudG9wID0gdGhpcy5wb3NpdGlvbi50b3AgKyBcXFwicHhcXFwiO1xcblxcblxcdFxcdFxcdGlmICgkLnVpLmRkbWFuYWdlcikge1xcblxcdFxcdFxcdFxcdCQudWkuZGRtYW5hZ2VyLmRyYWcodGhpcywgZXZlbnQpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfbW91c2VTdG9wOiBmdW5jdGlvbiBfbW91c2VTdG9wKGV2ZW50KSB7XFxuXFxuXFx0XFx0XFx0Ly9JZiB3ZSBhcmUgdXNpbmcgZHJvcHBhYmxlcywgaW5mb3JtIHRoZSBtYW5hZ2VyIGFib3V0IHRoZSBkcm9wXFxuXFx0XFx0XFx0dmFyIHRoYXQgPSB0aGlzLFxcblxcdFxcdFxcdCAgICBkcm9wcGVkID0gZmFsc2U7XFxuXFx0XFx0XFx0aWYgKCQudWkuZGRtYW5hZ2VyICYmICF0aGlzLm9wdGlvbnMuZHJvcEJlaGF2aW91cikge1xcblxcdFxcdFxcdFxcdGRyb3BwZWQgPSAkLnVpLmRkbWFuYWdlci5kcm9wKHRoaXMsIGV2ZW50KTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly9pZiBhIGRyb3AgY29tZXMgZnJvbSBvdXRzaWRlIChhIHNvcnRhYmxlKVxcblxcdFxcdFxcdGlmICh0aGlzLmRyb3BwZWQpIHtcXG5cXHRcXHRcXHRcXHRkcm9wcGVkID0gdGhpcy5kcm9wcGVkO1xcblxcdFxcdFxcdFxcdHRoaXMuZHJvcHBlZCA9IGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAodGhpcy5vcHRpb25zLnJldmVydCA9PT0gXFxcImludmFsaWRcXFwiICYmICFkcm9wcGVkIHx8IHRoaXMub3B0aW9ucy5yZXZlcnQgPT09IFxcXCJ2YWxpZFxcXCIgJiYgZHJvcHBlZCB8fCB0aGlzLm9wdGlvbnMucmV2ZXJ0ID09PSB0cnVlIHx8ICQuaXNGdW5jdGlvbih0aGlzLm9wdGlvbnMucmV2ZXJ0KSAmJiB0aGlzLm9wdGlvbnMucmV2ZXJ0LmNhbGwodGhpcy5lbGVtZW50LCBkcm9wcGVkKSkge1xcblxcdFxcdFxcdFxcdCQodGhpcy5oZWxwZXIpLmFuaW1hdGUodGhpcy5vcmlnaW5hbFBvc2l0aW9uLCBwYXJzZUludCh0aGlzLm9wdGlvbnMucmV2ZXJ0RHVyYXRpb24sIDEwKSwgZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdGlmICh0aGF0Ll90cmlnZ2VyKFxcXCJzdG9wXFxcIiwgZXZlbnQpICE9PSBmYWxzZSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoYXQuX2NsZWFyKCk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0aWYgKHRoaXMuX3RyaWdnZXIoXFxcInN0b3BcXFwiLCBldmVudCkgIT09IGZhbHNlKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fY2xlYXIoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9tb3VzZVVwOiBmdW5jdGlvbiBfbW91c2VVcChldmVudCkge1xcblxcdFxcdFxcdHRoaXMuX3VuYmxvY2tGcmFtZXMoKTtcXG5cXG5cXHRcXHRcXHQvL0lmIHRoZSBkZG1hbmFnZXIgaXMgdXNlZCBmb3IgZHJvcHBhYmxlcywgaW5mb3JtIHRoZSBtYW5hZ2VyIHRoYXQgZHJhZ2dpbmcgaGFzIHN0b3BwZWQgKHNlZSAjNTAwMylcXG5cXHRcXHRcXHRpZiAoJC51aS5kZG1hbmFnZXIpIHtcXG5cXHRcXHRcXHRcXHQkLnVpLmRkbWFuYWdlci5kcmFnU3RvcCh0aGlzLCBldmVudCk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIE9ubHkgbmVlZCB0byBmb2N1cyBpZiB0aGUgZXZlbnQgb2NjdXJyZWQgb24gdGhlIGRyYWdnYWJsZSBpdHNlbGYsIHNlZSAjMTA1MjdcXG5cXHRcXHRcXHRpZiAodGhpcy5oYW5kbGVFbGVtZW50LmlzKGV2ZW50LnRhcmdldCkpIHtcXG5cXHRcXHRcXHRcXHQvLyBUaGUgaW50ZXJhY3Rpb24gaXMgb3Zlcjsgd2hldGhlciBvciBub3QgdGhlIGNsaWNrIHJlc3VsdGVkIGluIGEgZHJhZywgZm9jdXMgdGhlIGVsZW1lbnRcXG5cXHRcXHRcXHRcXHR0aGlzLmVsZW1lbnQuZm9jdXMoKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuICQudWkubW91c2UucHJvdG90eXBlLl9tb3VzZVVwLmNhbGwodGhpcywgZXZlbnQpO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y2FuY2VsOiBmdW5jdGlvbiBjYW5jZWwoKSB7XFxuXFxuXFx0XFx0XFx0aWYgKHRoaXMuaGVscGVyLmlzKFxcXCIudWktZHJhZ2dhYmxlLWRyYWdnaW5nXFxcIikpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9tb3VzZVVwKHt9KTtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdHRoaXMuX2NsZWFyKCk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X2dldEhhbmRsZTogZnVuY3Rpb24gX2dldEhhbmRsZShldmVudCkge1xcblxcdFxcdFxcdHJldHVybiB0aGlzLm9wdGlvbnMuaGFuZGxlID8gISEkKGV2ZW50LnRhcmdldCkuY2xvc2VzdCh0aGlzLmVsZW1lbnQuZmluZCh0aGlzLm9wdGlvbnMuaGFuZGxlKSkubGVuZ3RoIDogdHJ1ZTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9zZXRIYW5kbGVDbGFzc05hbWU6IGZ1bmN0aW9uIF9zZXRIYW5kbGVDbGFzc05hbWUoKSB7XFxuXFx0XFx0XFx0dGhpcy5oYW5kbGVFbGVtZW50ID0gdGhpcy5vcHRpb25zLmhhbmRsZSA/IHRoaXMuZWxlbWVudC5maW5kKHRoaXMub3B0aW9ucy5oYW5kbGUpIDogdGhpcy5lbGVtZW50O1xcblxcdFxcdFxcdHRoaXMuaGFuZGxlRWxlbWVudC5hZGRDbGFzcyhcXFwidWktZHJhZ2dhYmxlLWhhbmRsZVxcXCIpO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X3JlbW92ZUhhbmRsZUNsYXNzTmFtZTogZnVuY3Rpb24gX3JlbW92ZUhhbmRsZUNsYXNzTmFtZSgpIHtcXG5cXHRcXHRcXHR0aGlzLmhhbmRsZUVsZW1lbnQucmVtb3ZlQ2xhc3MoXFxcInVpLWRyYWdnYWJsZS1oYW5kbGVcXFwiKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9jcmVhdGVIZWxwZXI6IGZ1bmN0aW9uIF9jcmVhdGVIZWxwZXIoZXZlbnQpIHtcXG5cXG5cXHRcXHRcXHR2YXIgbyA9IHRoaXMub3B0aW9ucyxcXG5cXHRcXHRcXHQgICAgaGVscGVySXNGdW5jdGlvbiA9ICQuaXNGdW5jdGlvbihvLmhlbHBlciksXFxuXFx0XFx0XFx0ICAgIGhlbHBlciA9IGhlbHBlcklzRnVuY3Rpb24gPyAkKG8uaGVscGVyLmFwcGx5KHRoaXMuZWxlbWVudFswXSwgW2V2ZW50XSkpIDogby5oZWxwZXIgPT09IFxcXCJjbG9uZVxcXCIgPyB0aGlzLmVsZW1lbnQuY2xvbmUoKS5yZW1vdmVBdHRyKFxcXCJpZFxcXCIpIDogdGhpcy5lbGVtZW50O1xcblxcblxcdFxcdFxcdGlmICghaGVscGVyLnBhcmVudHMoXFxcImJvZHlcXFwiKS5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRoZWxwZXIuYXBwZW5kVG8oby5hcHBlbmRUbyA9PT0gXFxcInBhcmVudFxcXCIgPyB0aGlzLmVsZW1lbnRbMF0ucGFyZW50Tm9kZSA6IG8uYXBwZW5kVG8pO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBodHRwOi8vYnVncy5qcXVlcnl1aS5jb20vdGlja2V0Lzk0NDZcXG5cXHRcXHRcXHQvLyBhIGhlbHBlciBmdW5jdGlvbiBjYW4gcmV0dXJuIHRoZSBvcmlnaW5hbCBlbGVtZW50XFxuXFx0XFx0XFx0Ly8gd2hpY2ggd291bGRuJ3QgaGF2ZSBiZWVuIHNldCB0byByZWxhdGl2ZSBpbiBfY3JlYXRlXFxuXFx0XFx0XFx0aWYgKGhlbHBlcklzRnVuY3Rpb24gJiYgaGVscGVyWzBdID09PSB0aGlzLmVsZW1lbnRbMF0pIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9zZXRQb3NpdGlvblJlbGF0aXZlKCk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmIChoZWxwZXJbMF0gIT09IHRoaXMuZWxlbWVudFswXSAmJiAhLyhmaXhlZHxhYnNvbHV0ZSkvLnRlc3QoaGVscGVyLmNzcyhcXFwicG9zaXRpb25cXFwiKSkpIHtcXG5cXHRcXHRcXHRcXHRoZWxwZXIuY3NzKFxcXCJwb3NpdGlvblxcXCIsIFxcXCJhYnNvbHV0ZVxcXCIpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gaGVscGVyO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X3NldFBvc2l0aW9uUmVsYXRpdmU6IGZ1bmN0aW9uIF9zZXRQb3NpdGlvblJlbGF0aXZlKCkge1xcblxcdFxcdFxcdGlmICghL14oPzpyfGF8ZikvLnRlc3QodGhpcy5lbGVtZW50LmNzcyhcXFwicG9zaXRpb25cXFwiKSkpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLmVsZW1lbnRbMF0uc3R5bGUucG9zaXRpb24gPSBcXFwicmVsYXRpdmVcXFwiO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcblxcdFxcdF9hZGp1c3RPZmZzZXRGcm9tSGVscGVyOiBmdW5jdGlvbiBfYWRqdXN0T2Zmc2V0RnJvbUhlbHBlcihvYmopIHtcXG5cXHRcXHRcXHRpZiAodHlwZW9mIG9iaiA9PT0gXFxcInN0cmluZ1xcXCIpIHtcXG5cXHRcXHRcXHRcXHRvYmogPSBvYmouc3BsaXQoXFxcIiBcXFwiKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKCQuaXNBcnJheShvYmopKSB7XFxuXFx0XFx0XFx0XFx0b2JqID0geyBsZWZ0OiArb2JqWzBdLCB0b3A6ICtvYmpbMV0gfHwgMCB9O1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoXFxcImxlZnRcXFwiIGluIG9iaikge1xcblxcdFxcdFxcdFxcdHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQgPSBvYmoubGVmdCArIHRoaXMubWFyZ2lucy5sZWZ0O1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoXFxcInJpZ2h0XFxcIiBpbiBvYmopIHtcXG5cXHRcXHRcXHRcXHR0aGlzLm9mZnNldC5jbGljay5sZWZ0ID0gdGhpcy5oZWxwZXJQcm9wb3J0aW9ucy53aWR0aCAtIG9iai5yaWdodCArIHRoaXMubWFyZ2lucy5sZWZ0O1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoXFxcInRvcFxcXCIgaW4gb2JqKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5vZmZzZXQuY2xpY2sudG9wID0gb2JqLnRvcCArIHRoaXMubWFyZ2lucy50b3A7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmIChcXFwiYm90dG9tXFxcIiBpbiBvYmopIHtcXG5cXHRcXHRcXHRcXHR0aGlzLm9mZnNldC5jbGljay50b3AgPSB0aGlzLmhlbHBlclByb3BvcnRpb25zLmhlaWdodCAtIG9iai5ib3R0b20gKyB0aGlzLm1hcmdpbnMudG9wO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcblxcdFxcdF9pc1Jvb3ROb2RlOiBmdW5jdGlvbiBfaXNSb290Tm9kZShlbGVtZW50KSB7XFxuXFx0XFx0XFx0cmV0dXJuICgvKGh0bWx8Ym9keSkvaS50ZXN0KGVsZW1lbnQudGFnTmFtZSkgfHwgZWxlbWVudCA9PT0gdGhpcy5kb2N1bWVudFswXVxcblxcdFxcdFxcdCk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfZ2V0UGFyZW50T2Zmc2V0OiBmdW5jdGlvbiBfZ2V0UGFyZW50T2Zmc2V0KCkge1xcblxcblxcdFxcdFxcdC8vR2V0IHRoZSBvZmZzZXRQYXJlbnQgYW5kIGNhY2hlIGl0cyBwb3NpdGlvblxcblxcdFxcdFxcdHZhciBwbyA9IHRoaXMub2Zmc2V0UGFyZW50Lm9mZnNldCgpLFxcblxcdFxcdFxcdCAgICBkb2N1bWVudCA9IHRoaXMuZG9jdW1lbnRbMF07XFxuXFxuXFx0XFx0XFx0Ly8gVGhpcyBpcyBhIHNwZWNpYWwgY2FzZSB3aGVyZSB3ZSBuZWVkIHRvIG1vZGlmeSBhIG9mZnNldCBjYWxjdWxhdGVkIG9uIHN0YXJ0LCBzaW5jZSB0aGUgZm9sbG93aW5nIGhhcHBlbmVkOlxcblxcdFxcdFxcdC8vIDEuIFRoZSBwb3NpdGlvbiBvZiB0aGUgaGVscGVyIGlzIGFic29sdXRlLCBzbyBpdCdzIHBvc2l0aW9uIGlzIGNhbGN1bGF0ZWQgYmFzZWQgb24gdGhlIG5leHQgcG9zaXRpb25lZCBwYXJlbnRcXG5cXHRcXHRcXHQvLyAyLiBUaGUgYWN0dWFsIG9mZnNldCBwYXJlbnQgaXMgYSBjaGlsZCBvZiB0aGUgc2Nyb2xsIHBhcmVudCwgYW5kIHRoZSBzY3JvbGwgcGFyZW50IGlzbid0IHRoZSBkb2N1bWVudCwgd2hpY2ggbWVhbnMgdGhhdFxcblxcdFxcdFxcdC8vICAgIHRoZSBzY3JvbGwgaXMgaW5jbHVkZWQgaW4gdGhlIGluaXRpYWwgY2FsY3VsYXRpb24gb2YgdGhlIG9mZnNldCBvZiB0aGUgcGFyZW50LCBhbmQgbmV2ZXIgcmVjYWxjdWxhdGVkIHVwb24gZHJhZ1xcblxcdFxcdFxcdGlmICh0aGlzLmNzc1Bvc2l0aW9uID09PSBcXFwiYWJzb2x1dGVcXFwiICYmIHRoaXMuc2Nyb2xsUGFyZW50WzBdICE9PSBkb2N1bWVudCAmJiAkLmNvbnRhaW5zKHRoaXMuc2Nyb2xsUGFyZW50WzBdLCB0aGlzLm9mZnNldFBhcmVudFswXSkpIHtcXG5cXHRcXHRcXHRcXHRwby5sZWZ0ICs9IHRoaXMuc2Nyb2xsUGFyZW50LnNjcm9sbExlZnQoKTtcXG5cXHRcXHRcXHRcXHRwby50b3AgKz0gdGhpcy5zY3JvbGxQYXJlbnQuc2Nyb2xsVG9wKCk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICh0aGlzLl9pc1Jvb3ROb2RlKHRoaXMub2Zmc2V0UGFyZW50WzBdKSkge1xcblxcdFxcdFxcdFxcdHBvID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHtcXG5cXHRcXHRcXHRcXHR0b3A6IHBvLnRvcCArIChwYXJzZUludCh0aGlzLm9mZnNldFBhcmVudC5jc3MoXFxcImJvcmRlclRvcFdpZHRoXFxcIiksIDEwKSB8fCAwKSxcXG5cXHRcXHRcXHRcXHRsZWZ0OiBwby5sZWZ0ICsgKHBhcnNlSW50KHRoaXMub2Zmc2V0UGFyZW50LmNzcyhcXFwiYm9yZGVyTGVmdFdpZHRoXFxcIiksIDEwKSB8fCAwKVxcblxcdFxcdFxcdH07XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfZ2V0UmVsYXRpdmVPZmZzZXQ6IGZ1bmN0aW9uIF9nZXRSZWxhdGl2ZU9mZnNldCgpIHtcXG5cXHRcXHRcXHRpZiAodGhpcy5jc3NQb3NpdGlvbiAhPT0gXFxcInJlbGF0aXZlXFxcIikge1xcblxcdFxcdFxcdFxcdHJldHVybiB7IHRvcDogMCwgbGVmdDogMCB9O1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2YXIgcCA9IHRoaXMuZWxlbWVudC5wb3NpdGlvbigpLFxcblxcdFxcdFxcdCAgICBzY3JvbGxJc1Jvb3ROb2RlID0gdGhpcy5faXNSb290Tm9kZSh0aGlzLnNjcm9sbFBhcmVudFswXSk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHtcXG5cXHRcXHRcXHRcXHR0b3A6IHAudG9wIC0gKHBhcnNlSW50KHRoaXMuaGVscGVyLmNzcyhcXFwidG9wXFxcIiksIDEwKSB8fCAwKSArICghc2Nyb2xsSXNSb290Tm9kZSA/IHRoaXMuc2Nyb2xsUGFyZW50LnNjcm9sbFRvcCgpIDogMCksXFxuXFx0XFx0XFx0XFx0bGVmdDogcC5sZWZ0IC0gKHBhcnNlSW50KHRoaXMuaGVscGVyLmNzcyhcXFwibGVmdFxcXCIpLCAxMCkgfHwgMCkgKyAoIXNjcm9sbElzUm9vdE5vZGUgPyB0aGlzLnNjcm9sbFBhcmVudC5zY3JvbGxMZWZ0KCkgOiAwKVxcblxcdFxcdFxcdH07XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfY2FjaGVNYXJnaW5zOiBmdW5jdGlvbiBfY2FjaGVNYXJnaW5zKCkge1xcblxcdFxcdFxcdHRoaXMubWFyZ2lucyA9IHtcXG5cXHRcXHRcXHRcXHRsZWZ0OiBwYXJzZUludCh0aGlzLmVsZW1lbnQuY3NzKFxcXCJtYXJnaW5MZWZ0XFxcIiksIDEwKSB8fCAwLFxcblxcdFxcdFxcdFxcdHRvcDogcGFyc2VJbnQodGhpcy5lbGVtZW50LmNzcyhcXFwibWFyZ2luVG9wXFxcIiksIDEwKSB8fCAwLFxcblxcdFxcdFxcdFxcdHJpZ2h0OiBwYXJzZUludCh0aGlzLmVsZW1lbnQuY3NzKFxcXCJtYXJnaW5SaWdodFxcXCIpLCAxMCkgfHwgMCxcXG5cXHRcXHRcXHRcXHRib3R0b206IHBhcnNlSW50KHRoaXMuZWxlbWVudC5jc3MoXFxcIm1hcmdpbkJvdHRvbVxcXCIpLCAxMCkgfHwgMFxcblxcdFxcdFxcdH07XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfY2FjaGVIZWxwZXJQcm9wb3J0aW9uczogZnVuY3Rpb24gX2NhY2hlSGVscGVyUHJvcG9ydGlvbnMoKSB7XFxuXFx0XFx0XFx0dGhpcy5oZWxwZXJQcm9wb3J0aW9ucyA9IHtcXG5cXHRcXHRcXHRcXHR3aWR0aDogdGhpcy5oZWxwZXIub3V0ZXJXaWR0aCgpLFxcblxcdFxcdFxcdFxcdGhlaWdodDogdGhpcy5oZWxwZXIub3V0ZXJIZWlnaHQoKVxcblxcdFxcdFxcdH07XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfc2V0Q29udGFpbm1lbnQ6IGZ1bmN0aW9uIF9zZXRDb250YWlubWVudCgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgaXNVc2VyU2Nyb2xsYWJsZSxcXG5cXHRcXHRcXHQgICAgYyxcXG5cXHRcXHRcXHQgICAgY2UsXFxuXFx0XFx0XFx0ICAgIG8gPSB0aGlzLm9wdGlvbnMsXFxuXFx0XFx0XFx0ICAgIGRvY3VtZW50ID0gdGhpcy5kb2N1bWVudFswXTtcXG5cXG5cXHRcXHRcXHR0aGlzLnJlbGF0aXZlQ29udGFpbmVyID0gbnVsbDtcXG5cXG5cXHRcXHRcXHRpZiAoIW8uY29udGFpbm1lbnQpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLmNvbnRhaW5tZW50ID0gbnVsbDtcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmIChvLmNvbnRhaW5tZW50ID09PSBcXFwid2luZG93XFxcIikge1xcblxcdFxcdFxcdFxcdHRoaXMuY29udGFpbm1lbnQgPSBbJCh3aW5kb3cpLnNjcm9sbExlZnQoKSAtIHRoaXMub2Zmc2V0LnJlbGF0aXZlLmxlZnQgLSB0aGlzLm9mZnNldC5wYXJlbnQubGVmdCwgJCh3aW5kb3cpLnNjcm9sbFRvcCgpIC0gdGhpcy5vZmZzZXQucmVsYXRpdmUudG9wIC0gdGhpcy5vZmZzZXQucGFyZW50LnRvcCwgJCh3aW5kb3cpLnNjcm9sbExlZnQoKSArICQod2luZG93KS53aWR0aCgpIC0gdGhpcy5oZWxwZXJQcm9wb3J0aW9ucy53aWR0aCAtIHRoaXMubWFyZ2lucy5sZWZ0LCAkKHdpbmRvdykuc2Nyb2xsVG9wKCkgKyAoJCh3aW5kb3cpLmhlaWdodCgpIHx8IGRvY3VtZW50LmJvZHkucGFyZW50Tm9kZS5zY3JvbGxIZWlnaHQpIC0gdGhpcy5oZWxwZXJQcm9wb3J0aW9ucy5oZWlnaHQgLSB0aGlzLm1hcmdpbnMudG9wXTtcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmIChvLmNvbnRhaW5tZW50ID09PSBcXFwiZG9jdW1lbnRcXFwiKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5jb250YWlubWVudCA9IFswLCAwLCAkKGRvY3VtZW50KS53aWR0aCgpIC0gdGhpcy5oZWxwZXJQcm9wb3J0aW9ucy53aWR0aCAtIHRoaXMubWFyZ2lucy5sZWZ0LCAoJChkb2N1bWVudCkuaGVpZ2h0KCkgfHwgZG9jdW1lbnQuYm9keS5wYXJlbnROb2RlLnNjcm9sbEhlaWdodCkgLSB0aGlzLmhlbHBlclByb3BvcnRpb25zLmhlaWdodCAtIHRoaXMubWFyZ2lucy50b3BdO1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKG8uY29udGFpbm1lbnQuY29uc3RydWN0b3IgPT09IEFycmF5KSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5jb250YWlubWVudCA9IG8uY29udGFpbm1lbnQ7XFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoby5jb250YWlubWVudCA9PT0gXFxcInBhcmVudFxcXCIpIHtcXG5cXHRcXHRcXHRcXHRvLmNvbnRhaW5tZW50ID0gdGhpcy5oZWxwZXJbMF0ucGFyZW50Tm9kZTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0YyA9ICQoby5jb250YWlubWVudCk7XFxuXFx0XFx0XFx0Y2UgPSBjWzBdO1xcblxcblxcdFxcdFxcdGlmICghY2UpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlzVXNlclNjcm9sbGFibGUgPSAvKHNjcm9sbHxhdXRvKS8udGVzdChjLmNzcyhcXFwib3ZlcmZsb3dcXFwiKSk7XFxuXFxuXFx0XFx0XFx0dGhpcy5jb250YWlubWVudCA9IFsocGFyc2VJbnQoYy5jc3MoXFxcImJvcmRlckxlZnRXaWR0aFxcXCIpLCAxMCkgfHwgMCkgKyAocGFyc2VJbnQoYy5jc3MoXFxcInBhZGRpbmdMZWZ0XFxcIiksIDEwKSB8fCAwKSwgKHBhcnNlSW50KGMuY3NzKFxcXCJib3JkZXJUb3BXaWR0aFxcXCIpLCAxMCkgfHwgMCkgKyAocGFyc2VJbnQoYy5jc3MoXFxcInBhZGRpbmdUb3BcXFwiKSwgMTApIHx8IDApLCAoaXNVc2VyU2Nyb2xsYWJsZSA/IE1hdGgubWF4KGNlLnNjcm9sbFdpZHRoLCBjZS5vZmZzZXRXaWR0aCkgOiBjZS5vZmZzZXRXaWR0aCkgLSAocGFyc2VJbnQoYy5jc3MoXFxcImJvcmRlclJpZ2h0V2lkdGhcXFwiKSwgMTApIHx8IDApIC0gKHBhcnNlSW50KGMuY3NzKFxcXCJwYWRkaW5nUmlnaHRcXFwiKSwgMTApIHx8IDApIC0gdGhpcy5oZWxwZXJQcm9wb3J0aW9ucy53aWR0aCAtIHRoaXMubWFyZ2lucy5sZWZ0IC0gdGhpcy5tYXJnaW5zLnJpZ2h0LCAoaXNVc2VyU2Nyb2xsYWJsZSA/IE1hdGgubWF4KGNlLnNjcm9sbEhlaWdodCwgY2Uub2Zmc2V0SGVpZ2h0KSA6IGNlLm9mZnNldEhlaWdodCkgLSAocGFyc2VJbnQoYy5jc3MoXFxcImJvcmRlckJvdHRvbVdpZHRoXFxcIiksIDEwKSB8fCAwKSAtIChwYXJzZUludChjLmNzcyhcXFwicGFkZGluZ0JvdHRvbVxcXCIpLCAxMCkgfHwgMCkgLSB0aGlzLmhlbHBlclByb3BvcnRpb25zLmhlaWdodCAtIHRoaXMubWFyZ2lucy50b3AgLSB0aGlzLm1hcmdpbnMuYm90dG9tXTtcXG5cXHRcXHRcXHR0aGlzLnJlbGF0aXZlQ29udGFpbmVyID0gYztcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9jb252ZXJ0UG9zaXRpb25UbzogZnVuY3Rpb24gX2NvbnZlcnRQb3NpdGlvblRvKGQsIHBvcykge1xcblxcblxcdFxcdFxcdGlmICghcG9zKSB7XFxuXFx0XFx0XFx0XFx0cG9zID0gdGhpcy5wb3NpdGlvbjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dmFyIG1vZCA9IGQgPT09IFxcXCJhYnNvbHV0ZVxcXCIgPyAxIDogLTEsXFxuXFx0XFx0XFx0ICAgIHNjcm9sbElzUm9vdE5vZGUgPSB0aGlzLl9pc1Jvb3ROb2RlKHRoaXMuc2Nyb2xsUGFyZW50WzBdKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4ge1xcblxcdFxcdFxcdFxcdHRvcDogcG9zLnRvcCArIC8vIFRoZSBhYnNvbHV0ZSBtb3VzZSBwb3NpdGlvblxcblxcdFxcdFxcdFxcdHRoaXMub2Zmc2V0LnJlbGF0aXZlLnRvcCAqIG1vZCArIC8vIE9ubHkgZm9yIHJlbGF0aXZlIHBvc2l0aW9uZWQgbm9kZXM6IFJlbGF0aXZlIG9mZnNldCBmcm9tIGVsZW1lbnQgdG8gb2Zmc2V0IHBhcmVudFxcblxcdFxcdFxcdFxcdHRoaXMub2Zmc2V0LnBhcmVudC50b3AgKiBtb2QgLSAvLyBUaGUgb2Zmc2V0UGFyZW50J3Mgb2Zmc2V0IHdpdGhvdXQgYm9yZGVycyAob2Zmc2V0ICsgYm9yZGVyKVxcblxcdFxcdFxcdFxcdCh0aGlzLmNzc1Bvc2l0aW9uID09PSBcXFwiZml4ZWRcXFwiID8gLXRoaXMub2Zmc2V0LnNjcm9sbC50b3AgOiBzY3JvbGxJc1Jvb3ROb2RlID8gMCA6IHRoaXMub2Zmc2V0LnNjcm9sbC50b3ApICogbW9kLFxcblxcdFxcdFxcdFxcdGxlZnQ6IHBvcy5sZWZ0ICsgLy8gVGhlIGFic29sdXRlIG1vdXNlIHBvc2l0aW9uXFxuXFx0XFx0XFx0XFx0dGhpcy5vZmZzZXQucmVsYXRpdmUubGVmdCAqIG1vZCArIC8vIE9ubHkgZm9yIHJlbGF0aXZlIHBvc2l0aW9uZWQgbm9kZXM6IFJlbGF0aXZlIG9mZnNldCBmcm9tIGVsZW1lbnQgdG8gb2Zmc2V0IHBhcmVudFxcblxcdFxcdFxcdFxcdHRoaXMub2Zmc2V0LnBhcmVudC5sZWZ0ICogbW9kIC0gLy8gVGhlIG9mZnNldFBhcmVudCdzIG9mZnNldCB3aXRob3V0IGJvcmRlcnMgKG9mZnNldCArIGJvcmRlcilcXG5cXHRcXHRcXHRcXHQodGhpcy5jc3NQb3NpdGlvbiA9PT0gXFxcImZpeGVkXFxcIiA/IC10aGlzLm9mZnNldC5zY3JvbGwubGVmdCA6IHNjcm9sbElzUm9vdE5vZGUgPyAwIDogdGhpcy5vZmZzZXQuc2Nyb2xsLmxlZnQpICogbW9kXFxuXFx0XFx0XFx0fTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9nZW5lcmF0ZVBvc2l0aW9uOiBmdW5jdGlvbiBfZ2VuZXJhdGVQb3NpdGlvbihldmVudCwgY29uc3RyYWluUG9zaXRpb24pIHtcXG5cXG5cXHRcXHRcXHR2YXIgY29udGFpbm1lbnQsXFxuXFx0XFx0XFx0ICAgIGNvLFxcblxcdFxcdFxcdCAgICB0b3AsXFxuXFx0XFx0XFx0ICAgIGxlZnQsXFxuXFx0XFx0XFx0ICAgIG8gPSB0aGlzLm9wdGlvbnMsXFxuXFx0XFx0XFx0ICAgIHNjcm9sbElzUm9vdE5vZGUgPSB0aGlzLl9pc1Jvb3ROb2RlKHRoaXMuc2Nyb2xsUGFyZW50WzBdKSxcXG5cXHRcXHRcXHQgICAgcGFnZVggPSBldmVudC5wYWdlWCxcXG5cXHRcXHRcXHQgICAgcGFnZVkgPSBldmVudC5wYWdlWTtcXG5cXG5cXHRcXHRcXHQvLyBDYWNoZSB0aGUgc2Nyb2xsXFxuXFx0XFx0XFx0aWYgKCFzY3JvbGxJc1Jvb3ROb2RlIHx8ICF0aGlzLm9mZnNldC5zY3JvbGwpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLm9mZnNldC5zY3JvbGwgPSB7XFxuXFx0XFx0XFx0XFx0XFx0dG9wOiB0aGlzLnNjcm9sbFBhcmVudC5zY3JvbGxUb3AoKSxcXG5cXHRcXHRcXHRcXHRcXHRsZWZ0OiB0aGlzLnNjcm9sbFBhcmVudC5zY3JvbGxMZWZ0KClcXG5cXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvKlxcbiAgICAqIC0gUG9zaXRpb24gY29uc3RyYWluaW5nIC1cXG4gICAgKiBDb25zdHJhaW4gdGhlIHBvc2l0aW9uIHRvIGEgbWl4IG9mIGdyaWQsIGNvbnRhaW5tZW50LlxcbiAgICAqL1xcblxcblxcdFxcdFxcdC8vIElmIHdlIGFyZSBub3QgZHJhZ2dpbmcgeWV0LCB3ZSB3b24ndCBjaGVjayBmb3Igb3B0aW9uc1xcblxcdFxcdFxcdGlmIChjb25zdHJhaW5Qb3NpdGlvbikge1xcblxcdFxcdFxcdFxcdGlmICh0aGlzLmNvbnRhaW5tZW50KSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHRoaXMucmVsYXRpdmVDb250YWluZXIpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRjbyA9IHRoaXMucmVsYXRpdmVDb250YWluZXIub2Zmc2V0KCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y29udGFpbm1lbnQgPSBbdGhpcy5jb250YWlubWVudFswXSArIGNvLmxlZnQsIHRoaXMuY29udGFpbm1lbnRbMV0gKyBjby50b3AsIHRoaXMuY29udGFpbm1lbnRbMl0gKyBjby5sZWZ0LCB0aGlzLmNvbnRhaW5tZW50WzNdICsgY28udG9wXTtcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdGNvbnRhaW5tZW50ID0gdGhpcy5jb250YWlubWVudDtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKGV2ZW50LnBhZ2VYIC0gdGhpcy5vZmZzZXQuY2xpY2subGVmdCA8IGNvbnRhaW5tZW50WzBdKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cGFnZVggPSBjb250YWlubWVudFswXSArIHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQ7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmIChldmVudC5wYWdlWSAtIHRoaXMub2Zmc2V0LmNsaWNrLnRvcCA8IGNvbnRhaW5tZW50WzFdKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cGFnZVkgPSBjb250YWlubWVudFsxXSArIHRoaXMub2Zmc2V0LmNsaWNrLnRvcDtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGV2ZW50LnBhZ2VYIC0gdGhpcy5vZmZzZXQuY2xpY2subGVmdCA+IGNvbnRhaW5tZW50WzJdKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cGFnZVggPSBjb250YWlubWVudFsyXSArIHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQ7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmIChldmVudC5wYWdlWSAtIHRoaXMub2Zmc2V0LmNsaWNrLnRvcCA+IGNvbnRhaW5tZW50WzNdKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cGFnZVkgPSBjb250YWlubWVudFszXSArIHRoaXMub2Zmc2V0LmNsaWNrLnRvcDtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmIChvLmdyaWQpIHtcXG5cXHRcXHRcXHRcXHRcXHQvL0NoZWNrIGZvciBncmlkIGVsZW1lbnRzIHNldCB0byAwIHRvIHByZXZlbnQgZGl2aWRlIGJ5IDAgZXJyb3IgY2F1c2luZyBpbnZhbGlkIGFyZ3VtZW50IGVycm9ycyBpbiBJRSAoc2VlIHRpY2tldCAjNjk1MClcXG5cXHRcXHRcXHRcXHRcXHR0b3AgPSBvLmdyaWRbMV0gPyB0aGlzLm9yaWdpbmFsUGFnZVkgKyBNYXRoLnJvdW5kKChwYWdlWSAtIHRoaXMub3JpZ2luYWxQYWdlWSkgLyBvLmdyaWRbMV0pICogby5ncmlkWzFdIDogdGhpcy5vcmlnaW5hbFBhZ2VZO1xcblxcdFxcdFxcdFxcdFxcdHBhZ2VZID0gY29udGFpbm1lbnQgPyB0b3AgLSB0aGlzLm9mZnNldC5jbGljay50b3AgPj0gY29udGFpbm1lbnRbMV0gfHwgdG9wIC0gdGhpcy5vZmZzZXQuY2xpY2sudG9wID4gY29udGFpbm1lbnRbM10gPyB0b3AgOiB0b3AgLSB0aGlzLm9mZnNldC5jbGljay50b3AgPj0gY29udGFpbm1lbnRbMV0gPyB0b3AgLSBvLmdyaWRbMV0gOiB0b3AgKyBvLmdyaWRbMV0gOiB0b3A7XFxuXFxuXFx0XFx0XFx0XFx0XFx0bGVmdCA9IG8uZ3JpZFswXSA/IHRoaXMub3JpZ2luYWxQYWdlWCArIE1hdGgucm91bmQoKHBhZ2VYIC0gdGhpcy5vcmlnaW5hbFBhZ2VYKSAvIG8uZ3JpZFswXSkgKiBvLmdyaWRbMF0gOiB0aGlzLm9yaWdpbmFsUGFnZVg7XFxuXFx0XFx0XFx0XFx0XFx0cGFnZVggPSBjb250YWlubWVudCA/IGxlZnQgLSB0aGlzLm9mZnNldC5jbGljay5sZWZ0ID49IGNvbnRhaW5tZW50WzBdIHx8IGxlZnQgLSB0aGlzLm9mZnNldC5jbGljay5sZWZ0ID4gY29udGFpbm1lbnRbMl0gPyBsZWZ0IDogbGVmdCAtIHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQgPj0gY29udGFpbm1lbnRbMF0gPyBsZWZ0IC0gby5ncmlkWzBdIDogbGVmdCArIG8uZ3JpZFswXSA6IGxlZnQ7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmIChvLmF4aXMgPT09IFxcXCJ5XFxcIikge1xcblxcdFxcdFxcdFxcdFxcdHBhZ2VYID0gdGhpcy5vcmlnaW5hbFBhZ2VYO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAoby5heGlzID09PSBcXFwieFxcXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRwYWdlWSA9IHRoaXMub3JpZ2luYWxQYWdlWTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB7XFxuXFx0XFx0XFx0XFx0dG9wOiBwYWdlWSAtIC8vIFRoZSBhYnNvbHV0ZSBtb3VzZSBwb3NpdGlvblxcblxcdFxcdFxcdFxcdHRoaXMub2Zmc2V0LmNsaWNrLnRvcCAtIC8vIENsaWNrIG9mZnNldCAocmVsYXRpdmUgdG8gdGhlIGVsZW1lbnQpXFxuXFx0XFx0XFx0XFx0dGhpcy5vZmZzZXQucmVsYXRpdmUudG9wIC0gLy8gT25seSBmb3IgcmVsYXRpdmUgcG9zaXRpb25lZCBub2RlczogUmVsYXRpdmUgb2Zmc2V0IGZyb20gZWxlbWVudCB0byBvZmZzZXQgcGFyZW50XFxuXFx0XFx0XFx0XFx0dGhpcy5vZmZzZXQucGFyZW50LnRvcCArICggLy8gVGhlIG9mZnNldFBhcmVudCdzIG9mZnNldCB3aXRob3V0IGJvcmRlcnMgKG9mZnNldCArIGJvcmRlcilcXG5cXHRcXHRcXHRcXHR0aGlzLmNzc1Bvc2l0aW9uID09PSBcXFwiZml4ZWRcXFwiID8gLXRoaXMub2Zmc2V0LnNjcm9sbC50b3AgOiBzY3JvbGxJc1Jvb3ROb2RlID8gMCA6IHRoaXMub2Zmc2V0LnNjcm9sbC50b3ApLFxcblxcdFxcdFxcdFxcdGxlZnQ6IHBhZ2VYIC0gLy8gVGhlIGFic29sdXRlIG1vdXNlIHBvc2l0aW9uXFxuXFx0XFx0XFx0XFx0dGhpcy5vZmZzZXQuY2xpY2subGVmdCAtIC8vIENsaWNrIG9mZnNldCAocmVsYXRpdmUgdG8gdGhlIGVsZW1lbnQpXFxuXFx0XFx0XFx0XFx0dGhpcy5vZmZzZXQucmVsYXRpdmUubGVmdCAtIC8vIE9ubHkgZm9yIHJlbGF0aXZlIHBvc2l0aW9uZWQgbm9kZXM6IFJlbGF0aXZlIG9mZnNldCBmcm9tIGVsZW1lbnQgdG8gb2Zmc2V0IHBhcmVudFxcblxcdFxcdFxcdFxcdHRoaXMub2Zmc2V0LnBhcmVudC5sZWZ0ICsgKCAvLyBUaGUgb2Zmc2V0UGFyZW50J3Mgb2Zmc2V0IHdpdGhvdXQgYm9yZGVycyAob2Zmc2V0ICsgYm9yZGVyKVxcblxcdFxcdFxcdFxcdHRoaXMuY3NzUG9zaXRpb24gPT09IFxcXCJmaXhlZFxcXCIgPyAtdGhpcy5vZmZzZXQuc2Nyb2xsLmxlZnQgOiBzY3JvbGxJc1Jvb3ROb2RlID8gMCA6IHRoaXMub2Zmc2V0LnNjcm9sbC5sZWZ0KVxcblxcdFxcdFxcdH07XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfY2xlYXI6IGZ1bmN0aW9uIF9jbGVhcigpIHtcXG5cXHRcXHRcXHR0aGlzLmhlbHBlci5yZW1vdmVDbGFzcyhcXFwidWktZHJhZ2dhYmxlLWRyYWdnaW5nXFxcIik7XFxuXFx0XFx0XFx0aWYgKHRoaXMuaGVscGVyWzBdICE9PSB0aGlzLmVsZW1lbnRbMF0gJiYgIXRoaXMuY2FuY2VsSGVscGVyUmVtb3ZhbCkge1xcblxcdFxcdFxcdFxcdHRoaXMuaGVscGVyLnJlbW92ZSgpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR0aGlzLmhlbHBlciA9IG51bGw7XFxuXFx0XFx0XFx0dGhpcy5jYW5jZWxIZWxwZXJSZW1vdmFsID0gZmFsc2U7XFxuXFx0XFx0XFx0aWYgKHRoaXMuZGVzdHJveU9uQ2xlYXIpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLmRlc3Ryb3koKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfbm9ybWFsaXplUmlnaHRCb3R0b206IGZ1bmN0aW9uIF9ub3JtYWxpemVSaWdodEJvdHRvbSgpIHtcXG5cXHRcXHRcXHRpZiAodGhpcy5vcHRpb25zLmF4aXMgIT09IFxcXCJ5XFxcIiAmJiB0aGlzLmhlbHBlci5jc3MoXFxcInJpZ2h0XFxcIikgIT09IFxcXCJhdXRvXFxcIikge1xcblxcdFxcdFxcdFxcdHRoaXMuaGVscGVyLndpZHRoKHRoaXMuaGVscGVyLndpZHRoKCkpO1xcblxcdFxcdFxcdFxcdHRoaXMuaGVscGVyLmNzcyhcXFwicmlnaHRcXFwiLCBcXFwiYXV0b1xcXCIpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAodGhpcy5vcHRpb25zLmF4aXMgIT09IFxcXCJ4XFxcIiAmJiB0aGlzLmhlbHBlci5jc3MoXFxcImJvdHRvbVxcXCIpICE9PSBcXFwiYXV0b1xcXCIpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLmhlbHBlci5oZWlnaHQodGhpcy5oZWxwZXIuaGVpZ2h0KCkpO1xcblxcdFxcdFxcdFxcdHRoaXMuaGVscGVyLmNzcyhcXFwiYm90dG9tXFxcIiwgXFxcImF1dG9cXFwiKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyBGcm9tIG5vdyBvbiBidWxrIHN0dWZmIC0gbWFpbmx5IGhlbHBlcnNcXG5cXG5cXHRcXHRfdHJpZ2dlcjogZnVuY3Rpb24gX3RyaWdnZXIodHlwZSwgZXZlbnQsIHVpKSB7XFxuXFx0XFx0XFx0dWkgPSB1aSB8fCB0aGlzLl91aUhhc2goKTtcXG5cXHRcXHRcXHQkLnVpLnBsdWdpbi5jYWxsKHRoaXMsIHR5cGUsIFtldmVudCwgdWksIHRoaXNdLCB0cnVlKTtcXG5cXG5cXHRcXHRcXHQvLyBBYnNvbHV0ZSBwb3NpdGlvbiBhbmQgb2Zmc2V0IChzZWUgIzY4ODQgKSBoYXZlIHRvIGJlIHJlY2FsY3VsYXRlZCBhZnRlciBwbHVnaW5zXFxuXFx0XFx0XFx0aWYgKC9eKGRyYWd8c3RhcnR8c3RvcCkvLnRlc3QodHlwZSkpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLnBvc2l0aW9uQWJzID0gdGhpcy5fY29udmVydFBvc2l0aW9uVG8oXFxcImFic29sdXRlXFxcIik7XFxuXFx0XFx0XFx0XFx0dWkub2Zmc2V0ID0gdGhpcy5wb3NpdGlvbkFicztcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuICQuV2lkZ2V0LnByb3RvdHlwZS5fdHJpZ2dlci5jYWxsKHRoaXMsIHR5cGUsIGV2ZW50LCB1aSk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRwbHVnaW5zOiB7fSxcXG5cXG5cXHRcXHRfdWlIYXNoOiBmdW5jdGlvbiBfdWlIYXNoKCkge1xcblxcdFxcdFxcdHJldHVybiB7XFxuXFx0XFx0XFx0XFx0aGVscGVyOiB0aGlzLmhlbHBlcixcXG5cXHRcXHRcXHRcXHRwb3NpdGlvbjogdGhpcy5wb3NpdGlvbixcXG5cXHRcXHRcXHRcXHRvcmlnaW5hbFBvc2l0aW9uOiB0aGlzLm9yaWdpbmFsUG9zaXRpb24sXFxuXFx0XFx0XFx0XFx0b2Zmc2V0OiB0aGlzLnBvc2l0aW9uQWJzXFxuXFx0XFx0XFx0fTtcXG5cXHRcXHR9XFxuXFxuXFx0fSk7XFxuXFxuXFx0JC51aS5wbHVnaW4uYWRkKFxcXCJkcmFnZ2FibGVcXFwiLCBcXFwiY29ubmVjdFRvU29ydGFibGVcXFwiLCB7XFxuXFx0XFx0c3RhcnQ6IGZ1bmN0aW9uIHN0YXJ0KGV2ZW50LCB1aSwgZHJhZ2dhYmxlKSB7XFxuXFx0XFx0XFx0dmFyIHVpU29ydGFibGUgPSAkLmV4dGVuZCh7fSwgdWksIHtcXG5cXHRcXHRcXHRcXHRpdGVtOiBkcmFnZ2FibGUuZWxlbWVudFxcblxcdFxcdFxcdH0pO1xcblxcblxcdFxcdFxcdGRyYWdnYWJsZS5zb3J0YWJsZXMgPSBbXTtcXG5cXHRcXHRcXHQkKGRyYWdnYWJsZS5vcHRpb25zLmNvbm5lY3RUb1NvcnRhYmxlKS5lYWNoKGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHR2YXIgc29ydGFibGUgPSAkKHRoaXMpLnNvcnRhYmxlKFxcXCJpbnN0YW5jZVxcXCIpO1xcblxcblxcdFxcdFxcdFxcdGlmIChzb3J0YWJsZSAmJiAhc29ydGFibGUub3B0aW9ucy5kaXNhYmxlZCkge1xcblxcdFxcdFxcdFxcdFxcdGRyYWdnYWJsZS5zb3J0YWJsZXMucHVzaChzb3J0YWJsZSk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gcmVmcmVzaFBvc2l0aW9ucyBpcyBjYWxsZWQgYXQgZHJhZyBzdGFydCB0byByZWZyZXNoIHRoZSBjb250YWluZXJDYWNoZVxcblxcdFxcdFxcdFxcdFxcdC8vIHdoaWNoIGlzIHVzZWQgaW4gZHJhZy4gVGhpcyBlbnN1cmVzIGl0J3MgaW5pdGlhbGl6ZWQgYW5kIHN5bmNocm9uaXplZFxcblxcdFxcdFxcdFxcdFxcdC8vIHdpdGggYW55IGNoYW5nZXMgdGhhdCBtaWdodCBoYXZlIGhhcHBlbmVkIG9uIHRoZSBwYWdlIHNpbmNlIGluaXRpYWxpemF0aW9uLlxcblxcdFxcdFxcdFxcdFxcdHNvcnRhYmxlLnJlZnJlc2hQb3NpdGlvbnMoKTtcXG5cXHRcXHRcXHRcXHRcXHRzb3J0YWJsZS5fdHJpZ2dlcihcXFwiYWN0aXZhdGVcXFwiLCBldmVudCwgdWlTb3J0YWJsZSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0pO1xcblxcdFxcdH0sXFxuXFx0XFx0c3RvcDogZnVuY3Rpb24gc3RvcChldmVudCwgdWksIGRyYWdnYWJsZSkge1xcblxcdFxcdFxcdHZhciB1aVNvcnRhYmxlID0gJC5leHRlbmQoe30sIHVpLCB7XFxuXFx0XFx0XFx0XFx0aXRlbTogZHJhZ2dhYmxlLmVsZW1lbnRcXG5cXHRcXHRcXHR9KTtcXG5cXG5cXHRcXHRcXHRkcmFnZ2FibGUuY2FuY2VsSGVscGVyUmVtb3ZhbCA9IGZhbHNlO1xcblxcblxcdFxcdFxcdCQuZWFjaChkcmFnZ2FibGUuc29ydGFibGVzLCBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0dmFyIHNvcnRhYmxlID0gdGhpcztcXG5cXG5cXHRcXHRcXHRcXHRpZiAoc29ydGFibGUuaXNPdmVyKSB7XFxuXFx0XFx0XFx0XFx0XFx0c29ydGFibGUuaXNPdmVyID0gMDtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBBbGxvdyB0aGlzIHNvcnRhYmxlIHRvIGhhbmRsZSByZW1vdmluZyB0aGUgaGVscGVyXFxuXFx0XFx0XFx0XFx0XFx0ZHJhZ2dhYmxlLmNhbmNlbEhlbHBlclJlbW92YWwgPSB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdHNvcnRhYmxlLmNhbmNlbEhlbHBlclJlbW92YWwgPSBmYWxzZTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBVc2UgX3N0b3JlZENTUyBUbyByZXN0b3JlIHByb3BlcnRpZXMgaW4gdGhlIHNvcnRhYmxlLFxcblxcdFxcdFxcdFxcdFxcdC8vIGFzIHRoaXMgYWxzbyBoYW5kbGVzIHJldmVydCAoIzk2NzUpIHNpbmNlIHRoZSBkcmFnZ2FibGVcXG5cXHRcXHRcXHRcXHRcXHQvLyBtYXkgaGF2ZSBtb2RpZmllZCB0aGVtIGluIHVuZXhwZWN0ZWQgd2F5cyAoIzg4MDkpXFxuXFx0XFx0XFx0XFx0XFx0c29ydGFibGUuX3N0b3JlZENTUyA9IHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRwb3NpdGlvbjogc29ydGFibGUucGxhY2Vob2xkZXIuY3NzKFxcXCJwb3NpdGlvblxcXCIpLFxcblxcdFxcdFxcdFxcdFxcdFxcdHRvcDogc29ydGFibGUucGxhY2Vob2xkZXIuY3NzKFxcXCJ0b3BcXFwiKSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRsZWZ0OiBzb3J0YWJsZS5wbGFjZWhvbGRlci5jc3MoXFxcImxlZnRcXFwiKVxcblxcdFxcdFxcdFxcdFxcdH07XFxuXFxuXFx0XFx0XFx0XFx0XFx0c29ydGFibGUuX21vdXNlU3RvcChldmVudCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gT25jZSBkcmFnIGhhcyBlbmRlZCwgdGhlIHNvcnRhYmxlIHNob3VsZCByZXR1cm4gdG8gdXNpbmdcXG5cXHRcXHRcXHRcXHRcXHQvLyBpdHMgb3JpZ2luYWwgaGVscGVyLCBub3QgdGhlIHNoYXJlZCBoZWxwZXIgZnJvbSBkcmFnZ2FibGVcXG5cXHRcXHRcXHRcXHRcXHRzb3J0YWJsZS5vcHRpb25zLmhlbHBlciA9IHNvcnRhYmxlLm9wdGlvbnMuX2hlbHBlcjtcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdC8vIFByZXZlbnQgdGhpcyBTb3J0YWJsZSBmcm9tIHJlbW92aW5nIHRoZSBoZWxwZXIuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gSG93ZXZlciwgZG9uJ3Qgc2V0IHRoZSBkcmFnZ2FibGUgdG8gcmVtb3ZlIHRoZSBoZWxwZXJcXG5cXHRcXHRcXHRcXHRcXHQvLyBlaXRoZXIgYXMgYW5vdGhlciBjb25uZWN0ZWQgU29ydGFibGUgbWF5IHlldCBoYW5kbGUgdGhlIHJlbW92YWwuXFxuXFx0XFx0XFx0XFx0XFx0c29ydGFibGUuY2FuY2VsSGVscGVyUmVtb3ZhbCA9IHRydWU7XFxuXFxuXFx0XFx0XFx0XFx0XFx0c29ydGFibGUuX3RyaWdnZXIoXFxcImRlYWN0aXZhdGVcXFwiLCBldmVudCwgdWlTb3J0YWJsZSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0pO1xcblxcdFxcdH0sXFxuXFx0XFx0ZHJhZzogZnVuY3Rpb24gZHJhZyhldmVudCwgdWksIGRyYWdnYWJsZSkge1xcblxcdFxcdFxcdCQuZWFjaChkcmFnZ2FibGUuc29ydGFibGVzLCBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0dmFyIGlubmVybW9zdEludGVyc2VjdGluZyA9IGZhbHNlLFxcblxcdFxcdFxcdFxcdCAgICBzb3J0YWJsZSA9IHRoaXM7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQ29weSBvdmVyIHZhcmlhYmxlcyB0aGF0IHNvcnRhYmxlJ3MgX2ludGVyc2VjdHNXaXRoIHVzZXNcXG5cXHRcXHRcXHRcXHRzb3J0YWJsZS5wb3NpdGlvbkFicyA9IGRyYWdnYWJsZS5wb3NpdGlvbkFicztcXG5cXHRcXHRcXHRcXHRzb3J0YWJsZS5oZWxwZXJQcm9wb3J0aW9ucyA9IGRyYWdnYWJsZS5oZWxwZXJQcm9wb3J0aW9ucztcXG5cXHRcXHRcXHRcXHRzb3J0YWJsZS5vZmZzZXQuY2xpY2sgPSBkcmFnZ2FibGUub2Zmc2V0LmNsaWNrO1xcblxcblxcdFxcdFxcdFxcdGlmIChzb3J0YWJsZS5faW50ZXJzZWN0c1dpdGgoc29ydGFibGUuY29udGFpbmVyQ2FjaGUpKSB7XFxuXFx0XFx0XFx0XFx0XFx0aW5uZXJtb3N0SW50ZXJzZWN0aW5nID0gdHJ1ZTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQkLmVhY2goZHJhZ2dhYmxlLnNvcnRhYmxlcywgZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdC8vIENvcHkgb3ZlciB2YXJpYWJsZXMgdGhhdCBzb3J0YWJsZSdzIF9pbnRlcnNlY3RzV2l0aCB1c2VzXFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5wb3NpdGlvbkFicyA9IGRyYWdnYWJsZS5wb3NpdGlvbkFicztcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLmhlbHBlclByb3BvcnRpb25zID0gZHJhZ2dhYmxlLmhlbHBlclByb3BvcnRpb25zO1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMub2Zmc2V0LmNsaWNrID0gZHJhZ2dhYmxlLm9mZnNldC5jbGljaztcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAodGhpcyAhPT0gc29ydGFibGUgJiYgdGhpcy5faW50ZXJzZWN0c1dpdGgodGhpcy5jb250YWluZXJDYWNoZSkgJiYgJC5jb250YWlucyhzb3J0YWJsZS5lbGVtZW50WzBdLCB0aGlzLmVsZW1lbnRbMF0pKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aW5uZXJtb3N0SW50ZXJzZWN0aW5nID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBpbm5lcm1vc3RJbnRlcnNlY3Rpbmc7XFxuXFx0XFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmIChpbm5lcm1vc3RJbnRlcnNlY3RpbmcpIHtcXG5cXHRcXHRcXHRcXHRcXHQvLyBJZiBpdCBpbnRlcnNlY3RzLCB3ZSB1c2UgYSBsaXR0bGUgaXNPdmVyIHZhcmlhYmxlIGFuZCBzZXQgaXQgb25jZSxcXG5cXHRcXHRcXHRcXHRcXHQvLyBzbyB0aGF0IHRoZSBtb3ZlLWluIHN0dWZmIGdldHMgZmlyZWQgb25seSBvbmNlLlxcblxcdFxcdFxcdFxcdFxcdGlmICghc29ydGFibGUuaXNPdmVyKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0c29ydGFibGUuaXNPdmVyID0gMTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBTdG9yZSBkcmFnZ2FibGUncyBwYXJlbnQgaW4gY2FzZSB3ZSBuZWVkIHRvIHJlYXBwZW5kIHRvIGl0IGxhdGVyLlxcblxcdFxcdFxcdFxcdFxcdFxcdGRyYWdnYWJsZS5fcGFyZW50ID0gdWkuaGVscGVyLnBhcmVudCgpO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHNvcnRhYmxlLmN1cnJlbnRJdGVtID0gdWkuaGVscGVyLmFwcGVuZFRvKHNvcnRhYmxlLmVsZW1lbnQpLmRhdGEoXFxcInVpLXNvcnRhYmxlLWl0ZW1cXFwiLCB0cnVlKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBTdG9yZSBoZWxwZXIgb3B0aW9uIHRvIGxhdGVyIHJlc3RvcmUgaXRcXG5cXHRcXHRcXHRcXHRcXHRcXHRzb3J0YWJsZS5vcHRpb25zLl9oZWxwZXIgPSBzb3J0YWJsZS5vcHRpb25zLmhlbHBlcjtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRzb3J0YWJsZS5vcHRpb25zLmhlbHBlciA9IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gdWkuaGVscGVyWzBdO1xcblxcdFxcdFxcdFxcdFxcdFxcdH07XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gRmlyZSB0aGUgc3RhcnQgZXZlbnRzIG9mIHRoZSBzb3J0YWJsZSB3aXRoIG91ciBwYXNzZWQgYnJvd3NlciBldmVudCxcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBhbmQgb3VyIG93biBoZWxwZXIgKHNvIGl0IGRvZXNuJ3QgY3JlYXRlIGEgbmV3IG9uZSlcXG5cXHRcXHRcXHRcXHRcXHRcXHRldmVudC50YXJnZXQgPSBzb3J0YWJsZS5jdXJyZW50SXRlbVswXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzb3J0YWJsZS5fbW91c2VDYXB0dXJlKGV2ZW50LCB0cnVlKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzb3J0YWJsZS5fbW91c2VTdGFydChldmVudCwgdHJ1ZSwgdHJ1ZSk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gQmVjYXVzZSB0aGUgYnJvd3NlciBldmVudCBpcyB3YXkgb2ZmIHRoZSBuZXcgYXBwZW5kZWQgcG9ydGxldCxcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBtb2RpZnkgbmVjZXNzYXJ5IHZhcmlhYmxlcyB0byByZWZsZWN0IHRoZSBjaGFuZ2VzXFxuXFx0XFx0XFx0XFx0XFx0XFx0c29ydGFibGUub2Zmc2V0LmNsaWNrLnRvcCA9IGRyYWdnYWJsZS5vZmZzZXQuY2xpY2sudG9wO1xcblxcdFxcdFxcdFxcdFxcdFxcdHNvcnRhYmxlLm9mZnNldC5jbGljay5sZWZ0ID0gZHJhZ2dhYmxlLm9mZnNldC5jbGljay5sZWZ0O1xcblxcdFxcdFxcdFxcdFxcdFxcdHNvcnRhYmxlLm9mZnNldC5wYXJlbnQubGVmdCAtPSBkcmFnZ2FibGUub2Zmc2V0LnBhcmVudC5sZWZ0IC0gc29ydGFibGUub2Zmc2V0LnBhcmVudC5sZWZ0O1xcblxcdFxcdFxcdFxcdFxcdFxcdHNvcnRhYmxlLm9mZnNldC5wYXJlbnQudG9wIC09IGRyYWdnYWJsZS5vZmZzZXQucGFyZW50LnRvcCAtIHNvcnRhYmxlLm9mZnNldC5wYXJlbnQudG9wO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGRyYWdnYWJsZS5fdHJpZ2dlcihcXFwidG9Tb3J0YWJsZVxcXCIsIGV2ZW50KTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBJbmZvcm0gZHJhZ2dhYmxlIHRoYXQgdGhlIGhlbHBlciBpcyBpbiBhIHZhbGlkIGRyb3Agem9uZSxcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyB1c2VkIHNvbGVseSBpbiB0aGUgcmV2ZXJ0IG9wdGlvbiB0byBoYW5kbGUgXFxcInZhbGlkL2ludmFsaWRcXFwiLlxcblxcdFxcdFxcdFxcdFxcdFxcdGRyYWdnYWJsZS5kcm9wcGVkID0gc29ydGFibGUuZWxlbWVudDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBOZWVkIHRvIHJlZnJlc2hQb3NpdGlvbnMgb2YgYWxsIHNvcnRhYmxlcyBpbiB0aGUgY2FzZSB0aGF0XFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gYWRkaW5nIHRvIG9uZSBzb3J0YWJsZSBjaGFuZ2VzIHRoZSBsb2NhdGlvbiBvZiB0aGUgb3RoZXIgc29ydGFibGVzICgjOTY3NSlcXG5cXHRcXHRcXHRcXHRcXHRcXHQkLmVhY2goZHJhZ2dhYmxlLnNvcnRhYmxlcywgZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoaXMucmVmcmVzaFBvc2l0aW9ucygpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH0pO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIGhhY2sgc28gcmVjZWl2ZS91cGRhdGUgY2FsbGJhY2tzIHdvcmsgKG1vc3RseSlcXG5cXHRcXHRcXHRcXHRcXHRcXHRkcmFnZ2FibGUuY3VycmVudEl0ZW0gPSBkcmFnZ2FibGUuZWxlbWVudDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzb3J0YWJsZS5mcm9tT3V0c2lkZSA9IGRyYWdnYWJsZTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKHNvcnRhYmxlLmN1cnJlbnRJdGVtKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0c29ydGFibGUuX21vdXNlRHJhZyhldmVudCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gQ29weSB0aGUgc29ydGFibGUncyBwb3NpdGlvbiBiZWNhdXNlIHRoZSBkcmFnZ2FibGUncyBjYW4gcG90ZW50aWFsbHkgcmVmbGVjdFxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIGEgcmVsYXRpdmUgcG9zaXRpb24sIHdoaWxlIHNvcnRhYmxlIGlzIGFsd2F5cyBhYnNvbHV0ZSwgd2hpY2ggdGhlIGRyYWdnZWRcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBlbGVtZW50IGhhcyBub3cgYmVjb21lLiAoIzg4MDkpXFxuXFx0XFx0XFx0XFx0XFx0XFx0dWkucG9zaXRpb24gPSBzb3J0YWJsZS5wb3NpdGlvbjtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHQvLyBJZiBpdCBkb2Vzbid0IGludGVyc2VjdCB3aXRoIHRoZSBzb3J0YWJsZSwgYW5kIGl0IGludGVyc2VjdGVkIGJlZm9yZSxcXG5cXHRcXHRcXHRcXHRcXHQvLyB3ZSBmYWtlIHRoZSBkcmFnIHN0b3Agb2YgdGhlIHNvcnRhYmxlLCBidXQgbWFrZSBzdXJlIGl0IGRvZXNuJ3QgcmVtb3ZlXFxuXFx0XFx0XFx0XFx0XFx0Ly8gdGhlIGhlbHBlciBieSB1c2luZyBjYW5jZWxIZWxwZXJSZW1vdmFsLlxcblxcdFxcdFxcdFxcdFxcdGlmIChzb3J0YWJsZS5pc092ZXIpIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRzb3J0YWJsZS5pc092ZXIgPSAwO1xcblxcdFxcdFxcdFxcdFxcdFxcdHNvcnRhYmxlLmNhbmNlbEhlbHBlclJlbW92YWwgPSB0cnVlO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIENhbGxpbmcgc29ydGFibGUncyBtb3VzZVN0b3Agd291bGQgdHJpZ2dlciBhIHJldmVydCxcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBzbyByZXZlcnQgbXVzdCBiZSB0ZW1wb3JhcmlseSBmYWxzZSB1bnRpbCBhZnRlciBtb3VzZVN0b3AgaXMgY2FsbGVkLlxcblxcdFxcdFxcdFxcdFxcdFxcdHNvcnRhYmxlLm9wdGlvbnMuX3JldmVydCA9IHNvcnRhYmxlLm9wdGlvbnMucmV2ZXJ0O1xcblxcdFxcdFxcdFxcdFxcdFxcdHNvcnRhYmxlLm9wdGlvbnMucmV2ZXJ0ID0gZmFsc2U7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0c29ydGFibGUuX3RyaWdnZXIoXFxcIm91dFxcXCIsIGV2ZW50LCBzb3J0YWJsZS5fdWlIYXNoKHNvcnRhYmxlKSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0c29ydGFibGUuX21vdXNlU3RvcChldmVudCwgdHJ1ZSk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gcmVzdG9yZSBzb3J0YWJsZSBiZWhhdmlvcnMgdGhhdCB3ZXJlIG1vZGZpZWRcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyB3aGVuIHRoZSBkcmFnZ2FibGUgZW50ZXJlZCB0aGUgc29ydGFibGUgYXJlYSAoIzk0ODEpXFxuXFx0XFx0XFx0XFx0XFx0XFx0c29ydGFibGUub3B0aW9ucy5yZXZlcnQgPSBzb3J0YWJsZS5vcHRpb25zLl9yZXZlcnQ7XFxuXFx0XFx0XFx0XFx0XFx0XFx0c29ydGFibGUub3B0aW9ucy5oZWxwZXIgPSBzb3J0YWJsZS5vcHRpb25zLl9oZWxwZXI7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKHNvcnRhYmxlLnBsYWNlaG9sZGVyKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c29ydGFibGUucGxhY2Vob2xkZXIucmVtb3ZlKCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIFJlc3RvcmUgYW5kIHJlY2FsY3VsYXRlIHRoZSBkcmFnZ2FibGUncyBvZmZzZXQgY29uc2lkZXJpbmcgdGhlIHNvcnRhYmxlXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gbWF5IGhhdmUgbW9kaWZpZWQgdGhlbSBpbiB1bmV4cGVjdGVkIHdheXMuICgjODgwOSwgIzEwNjY5KVxcblxcdFxcdFxcdFxcdFxcdFxcdHVpLmhlbHBlci5hcHBlbmRUbyhkcmFnZ2FibGUuX3BhcmVudCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZHJhZ2dhYmxlLl9yZWZyZXNoT2Zmc2V0cyhldmVudCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dWkucG9zaXRpb24gPSBkcmFnZ2FibGUuX2dlbmVyYXRlUG9zaXRpb24oZXZlbnQsIHRydWUpO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGRyYWdnYWJsZS5fdHJpZ2dlcihcXFwiZnJvbVNvcnRhYmxlXFxcIiwgZXZlbnQpO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIEluZm9ybSBkcmFnZ2FibGUgdGhhdCB0aGUgaGVscGVyIGlzIG5vIGxvbmdlciBpbiBhIHZhbGlkIGRyb3Agem9uZVxcblxcdFxcdFxcdFxcdFxcdFxcdGRyYWdnYWJsZS5kcm9wcGVkID0gZmFsc2U7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gTmVlZCB0byByZWZyZXNoUG9zaXRpb25zIG9mIGFsbCBzb3J0YWJsZXMganVzdCBpbiBjYXNlIHJlbW92aW5nXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gZnJvbSBvbmUgc29ydGFibGUgY2hhbmdlcyB0aGUgbG9jYXRpb24gb2Ygb3RoZXIgc29ydGFibGVzICgjOTY3NSlcXG5cXHRcXHRcXHRcXHRcXHRcXHQkLmVhY2goZHJhZ2dhYmxlLnNvcnRhYmxlcywgZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoaXMucmVmcmVzaFBvc2l0aW9ucygpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0fVxcblxcdH0pO1xcblxcblxcdCQudWkucGx1Z2luLmFkZChcXFwiZHJhZ2dhYmxlXFxcIiwgXFxcImN1cnNvclxcXCIsIHtcXG5cXHRcXHRzdGFydDogZnVuY3Rpb24gc3RhcnQoZXZlbnQsIHVpLCBpbnN0YW5jZSkge1xcblxcdFxcdFxcdHZhciB0ID0gJChcXFwiYm9keVxcXCIpLFxcblxcdFxcdFxcdCAgICBvID0gaW5zdGFuY2Uub3B0aW9ucztcXG5cXG5cXHRcXHRcXHRpZiAodC5jc3MoXFxcImN1cnNvclxcXCIpKSB7XFxuXFx0XFx0XFx0XFx0by5fY3Vyc29yID0gdC5jc3MoXFxcImN1cnNvclxcXCIpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR0LmNzcyhcXFwiY3Vyc29yXFxcIiwgby5jdXJzb3IpO1xcblxcdFxcdH0sXFxuXFx0XFx0c3RvcDogZnVuY3Rpb24gc3RvcChldmVudCwgdWksIGluc3RhbmNlKSB7XFxuXFx0XFx0XFx0dmFyIG8gPSBpbnN0YW5jZS5vcHRpb25zO1xcblxcdFxcdFxcdGlmIChvLl9jdXJzb3IpIHtcXG5cXHRcXHRcXHRcXHQkKFxcXCJib2R5XFxcIikuY3NzKFxcXCJjdXJzb3JcXFwiLCBvLl9jdXJzb3IpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fSk7XFxuXFxuXFx0JC51aS5wbHVnaW4uYWRkKFxcXCJkcmFnZ2FibGVcXFwiLCBcXFwib3BhY2l0eVxcXCIsIHtcXG5cXHRcXHRzdGFydDogZnVuY3Rpb24gc3RhcnQoZXZlbnQsIHVpLCBpbnN0YW5jZSkge1xcblxcdFxcdFxcdHZhciB0ID0gJCh1aS5oZWxwZXIpLFxcblxcdFxcdFxcdCAgICBvID0gaW5zdGFuY2Uub3B0aW9ucztcXG5cXHRcXHRcXHRpZiAodC5jc3MoXFxcIm9wYWNpdHlcXFwiKSkge1xcblxcdFxcdFxcdFxcdG8uX29wYWNpdHkgPSB0LmNzcyhcXFwib3BhY2l0eVxcXCIpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR0LmNzcyhcXFwib3BhY2l0eVxcXCIsIG8ub3BhY2l0eSk7XFxuXFx0XFx0fSxcXG5cXHRcXHRzdG9wOiBmdW5jdGlvbiBzdG9wKGV2ZW50LCB1aSwgaW5zdGFuY2UpIHtcXG5cXHRcXHRcXHR2YXIgbyA9IGluc3RhbmNlLm9wdGlvbnM7XFxuXFx0XFx0XFx0aWYgKG8uX29wYWNpdHkpIHtcXG5cXHRcXHRcXHRcXHQkKHVpLmhlbHBlcikuY3NzKFxcXCJvcGFjaXR5XFxcIiwgby5fb3BhY2l0eSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9KTtcXG5cXG5cXHQkLnVpLnBsdWdpbi5hZGQoXFxcImRyYWdnYWJsZVxcXCIsIFxcXCJzY3JvbGxcXFwiLCB7XFxuXFx0XFx0c3RhcnQ6IGZ1bmN0aW9uIHN0YXJ0KGV2ZW50LCB1aSwgaSkge1xcblxcdFxcdFxcdGlmICghaS5zY3JvbGxQYXJlbnROb3RIaWRkZW4pIHtcXG5cXHRcXHRcXHRcXHRpLnNjcm9sbFBhcmVudE5vdEhpZGRlbiA9IGkuaGVscGVyLnNjcm9sbFBhcmVudChmYWxzZSk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmIChpLnNjcm9sbFBhcmVudE5vdEhpZGRlblswXSAhPT0gaS5kb2N1bWVudFswXSAmJiBpLnNjcm9sbFBhcmVudE5vdEhpZGRlblswXS50YWdOYW1lICE9PSBcXFwiSFRNTFxcXCIpIHtcXG5cXHRcXHRcXHRcXHRpLm92ZXJmbG93T2Zmc2V0ID0gaS5zY3JvbGxQYXJlbnROb3RIaWRkZW4ub2Zmc2V0KCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFx0XFx0ZHJhZzogZnVuY3Rpb24gZHJhZyhldmVudCwgdWksIGkpIHtcXG5cXG5cXHRcXHRcXHR2YXIgbyA9IGkub3B0aW9ucyxcXG5cXHRcXHRcXHQgICAgc2Nyb2xsZWQgPSBmYWxzZSxcXG5cXHRcXHRcXHQgICAgc2Nyb2xsUGFyZW50ID0gaS5zY3JvbGxQYXJlbnROb3RIaWRkZW5bMF0sXFxuXFx0XFx0XFx0ICAgIGRvY3VtZW50ID0gaS5kb2N1bWVudFswXTtcXG5cXG5cXHRcXHRcXHRpZiAoc2Nyb2xsUGFyZW50ICE9PSBkb2N1bWVudCAmJiBzY3JvbGxQYXJlbnQudGFnTmFtZSAhPT0gXFxcIkhUTUxcXFwiKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCFvLmF4aXMgfHwgby5heGlzICE9PSBcXFwieFxcXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoaS5vdmVyZmxvd09mZnNldC50b3AgKyBzY3JvbGxQYXJlbnQub2Zmc2V0SGVpZ2h0IC0gZXZlbnQucGFnZVkgPCBvLnNjcm9sbFNlbnNpdGl2aXR5KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0c2Nyb2xsUGFyZW50LnNjcm9sbFRvcCA9IHNjcm9sbGVkID0gc2Nyb2xsUGFyZW50LnNjcm9sbFRvcCArIG8uc2Nyb2xsU3BlZWQ7XFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIGlmIChldmVudC5wYWdlWSAtIGkub3ZlcmZsb3dPZmZzZXQudG9wIDwgby5zY3JvbGxTZW5zaXRpdml0eSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHNjcm9sbFBhcmVudC5zY3JvbGxUb3AgPSBzY3JvbGxlZCA9IHNjcm9sbFBhcmVudC5zY3JvbGxUb3AgLSBvLnNjcm9sbFNwZWVkO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCFvLmF4aXMgfHwgby5heGlzICE9PSBcXFwieVxcXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoaS5vdmVyZmxvd09mZnNldC5sZWZ0ICsgc2Nyb2xsUGFyZW50Lm9mZnNldFdpZHRoIC0gZXZlbnQucGFnZVggPCBvLnNjcm9sbFNlbnNpdGl2aXR5KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0c2Nyb2xsUGFyZW50LnNjcm9sbExlZnQgPSBzY3JvbGxlZCA9IHNjcm9sbFBhcmVudC5zY3JvbGxMZWZ0ICsgby5zY3JvbGxTcGVlZDtcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2UgaWYgKGV2ZW50LnBhZ2VYIC0gaS5vdmVyZmxvd09mZnNldC5sZWZ0IDwgby5zY3JvbGxTZW5zaXRpdml0eSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHNjcm9sbFBhcmVudC5zY3JvbGxMZWZ0ID0gc2Nyb2xsZWQgPSBzY3JvbGxQYXJlbnQuc2Nyb2xsTGVmdCAtIG8uc2Nyb2xsU3BlZWQ7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdGlmICghby5heGlzIHx8IG8uYXhpcyAhPT0gXFxcInhcXFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGV2ZW50LnBhZ2VZIC0gJChkb2N1bWVudCkuc2Nyb2xsVG9wKCkgPCBvLnNjcm9sbFNlbnNpdGl2aXR5KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0c2Nyb2xsZWQgPSAkKGRvY3VtZW50KS5zY3JvbGxUb3AoJChkb2N1bWVudCkuc2Nyb2xsVG9wKCkgLSBvLnNjcm9sbFNwZWVkKTtcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCQod2luZG93KS5oZWlnaHQoKSAtIChldmVudC5wYWdlWSAtICQoZG9jdW1lbnQpLnNjcm9sbFRvcCgpKSA8IG8uc2Nyb2xsU2Vuc2l0aXZpdHkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzY3JvbGxlZCA9ICQoZG9jdW1lbnQpLnNjcm9sbFRvcCgkKGRvY3VtZW50KS5zY3JvbGxUb3AoKSArIG8uc2Nyb2xsU3BlZWQpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCFvLmF4aXMgfHwgby5heGlzICE9PSBcXFwieVxcXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoZXZlbnQucGFnZVggLSAkKGRvY3VtZW50KS5zY3JvbGxMZWZ0KCkgPCBvLnNjcm9sbFNlbnNpdGl2aXR5KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0c2Nyb2xsZWQgPSAkKGRvY3VtZW50KS5zY3JvbGxMZWZ0KCQoZG9jdW1lbnQpLnNjcm9sbExlZnQoKSAtIG8uc2Nyb2xsU3BlZWQpO1xcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoJCh3aW5kb3cpLndpZHRoKCkgLSAoZXZlbnQucGFnZVggLSAkKGRvY3VtZW50KS5zY3JvbGxMZWZ0KCkpIDwgby5zY3JvbGxTZW5zaXRpdml0eSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHNjcm9sbGVkID0gJChkb2N1bWVudCkuc2Nyb2xsTGVmdCgkKGRvY3VtZW50KS5zY3JvbGxMZWZ0KCkgKyBvLnNjcm9sbFNwZWVkKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoc2Nyb2xsZWQgIT09IGZhbHNlICYmICQudWkuZGRtYW5hZ2VyICYmICFvLmRyb3BCZWhhdmlvdXIpIHtcXG5cXHRcXHRcXHRcXHQkLnVpLmRkbWFuYWdlci5wcmVwYXJlT2Zmc2V0cyhpLCBldmVudCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9KTtcXG5cXG5cXHQkLnVpLnBsdWdpbi5hZGQoXFxcImRyYWdnYWJsZVxcXCIsIFxcXCJzbmFwXFxcIiwge1xcblxcdFxcdHN0YXJ0OiBmdW5jdGlvbiBzdGFydChldmVudCwgdWksIGkpIHtcXG5cXG5cXHRcXHRcXHR2YXIgbyA9IGkub3B0aW9ucztcXG5cXG5cXHRcXHRcXHRpLnNuYXBFbGVtZW50cyA9IFtdO1xcblxcblxcdFxcdFxcdCQoby5zbmFwLmNvbnN0cnVjdG9yICE9PSBTdHJpbmcgPyBvLnNuYXAuaXRlbXMgfHwgXFxcIjpkYXRhKHVpLWRyYWdnYWJsZSlcXFwiIDogby5zbmFwKS5lYWNoKGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHR2YXIgJHQgPSAkKHRoaXMpLFxcblxcdFxcdFxcdFxcdCAgICAkbyA9ICR0Lm9mZnNldCgpO1xcblxcdFxcdFxcdFxcdGlmICh0aGlzICE9PSBpLmVsZW1lbnRbMF0pIHtcXG5cXHRcXHRcXHRcXHRcXHRpLnNuYXBFbGVtZW50cy5wdXNoKHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpdGVtOiB0aGlzLFxcblxcdFxcdFxcdFxcdFxcdFxcdHdpZHRoOiAkdC5vdXRlcldpZHRoKCksIGhlaWdodDogJHQub3V0ZXJIZWlnaHQoKSxcXG5cXHRcXHRcXHRcXHRcXHRcXHR0b3A6ICRvLnRvcCwgbGVmdDogJG8ubGVmdFxcblxcdFxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHR9LFxcblxcdFxcdGRyYWc6IGZ1bmN0aW9uIGRyYWcoZXZlbnQsIHVpLCBpbnN0KSB7XFxuXFxuXFx0XFx0XFx0dmFyIHRzLFxcblxcdFxcdFxcdCAgICBicyxcXG5cXHRcXHRcXHQgICAgbHMsXFxuXFx0XFx0XFx0ICAgIHJzLFxcblxcdFxcdFxcdCAgICBsLFxcblxcdFxcdFxcdCAgICByLFxcblxcdFxcdFxcdCAgICB0LFxcblxcdFxcdFxcdCAgICBiLFxcblxcdFxcdFxcdCAgICBpLFxcblxcdFxcdFxcdCAgICBmaXJzdCxcXG5cXHRcXHRcXHQgICAgbyA9IGluc3Qub3B0aW9ucyxcXG5cXHRcXHRcXHQgICAgZCA9IG8uc25hcFRvbGVyYW5jZSxcXG5cXHRcXHRcXHQgICAgeDEgPSB1aS5vZmZzZXQubGVmdCxcXG5cXHRcXHRcXHQgICAgeDIgPSB4MSArIGluc3QuaGVscGVyUHJvcG9ydGlvbnMud2lkdGgsXFxuXFx0XFx0XFx0ICAgIHkxID0gdWkub2Zmc2V0LnRvcCxcXG5cXHRcXHRcXHQgICAgeTIgPSB5MSArIGluc3QuaGVscGVyUHJvcG9ydGlvbnMuaGVpZ2h0O1xcblxcblxcdFxcdFxcdGZvciAoaSA9IGluc3Quc25hcEVsZW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XFxuXFxuXFx0XFx0XFx0XFx0bCA9IGluc3Quc25hcEVsZW1lbnRzW2ldLmxlZnQgLSBpbnN0Lm1hcmdpbnMubGVmdDtcXG5cXHRcXHRcXHRcXHRyID0gbCArIGluc3Quc25hcEVsZW1lbnRzW2ldLndpZHRoO1xcblxcdFxcdFxcdFxcdHQgPSBpbnN0LnNuYXBFbGVtZW50c1tpXS50b3AgLSBpbnN0Lm1hcmdpbnMudG9wO1xcblxcdFxcdFxcdFxcdGIgPSB0ICsgaW5zdC5zbmFwRWxlbWVudHNbaV0uaGVpZ2h0O1xcblxcblxcdFxcdFxcdFxcdGlmICh4MiA8IGwgLSBkIHx8IHgxID4gciArIGQgfHwgeTIgPCB0IC0gZCB8fCB5MSA+IGIgKyBkIHx8ICEkLmNvbnRhaW5zKGluc3Quc25hcEVsZW1lbnRzW2ldLml0ZW0ub3duZXJEb2N1bWVudCwgaW5zdC5zbmFwRWxlbWVudHNbaV0uaXRlbSkpIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoaW5zdC5zbmFwRWxlbWVudHNbaV0uc25hcHBpbmcpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpbnN0Lm9wdGlvbnMuc25hcC5yZWxlYXNlICYmIGluc3Qub3B0aW9ucy5zbmFwLnJlbGVhc2UuY2FsbChpbnN0LmVsZW1lbnQsIGV2ZW50LCAkLmV4dGVuZChpbnN0Ll91aUhhc2goKSwgeyBzbmFwSXRlbTogaW5zdC5zbmFwRWxlbWVudHNbaV0uaXRlbSB9KSk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGluc3Quc25hcEVsZW1lbnRzW2ldLnNuYXBwaW5nID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0XFx0Y29udGludWU7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmIChvLnNuYXBNb2RlICE9PSBcXFwiaW5uZXJcXFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0dHMgPSBNYXRoLmFicyh0IC0geTIpIDw9IGQ7XFxuXFx0XFx0XFx0XFx0XFx0YnMgPSBNYXRoLmFicyhiIC0geTEpIDw9IGQ7XFxuXFx0XFx0XFx0XFx0XFx0bHMgPSBNYXRoLmFicyhsIC0geDIpIDw9IGQ7XFxuXFx0XFx0XFx0XFx0XFx0cnMgPSBNYXRoLmFicyhyIC0geDEpIDw9IGQ7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHRzKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dWkucG9zaXRpb24udG9wID0gaW5zdC5fY29udmVydFBvc2l0aW9uVG8oXFxcInJlbGF0aXZlXFxcIiwgeyB0b3A6IHQgLSBpbnN0LmhlbHBlclByb3BvcnRpb25zLmhlaWdodCwgbGVmdDogMCB9KS50b3A7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmIChicykge1xcblxcdFxcdFxcdFxcdFxcdFxcdHVpLnBvc2l0aW9uLnRvcCA9IGluc3QuX2NvbnZlcnRQb3NpdGlvblRvKFxcXCJyZWxhdGl2ZVxcXCIsIHsgdG9wOiBiLCBsZWZ0OiAwIH0pLnRvcDtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGxzKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dWkucG9zaXRpb24ubGVmdCA9IGluc3QuX2NvbnZlcnRQb3NpdGlvblRvKFxcXCJyZWxhdGl2ZVxcXCIsIHsgdG9wOiAwLCBsZWZ0OiBsIC0gaW5zdC5oZWxwZXJQcm9wb3J0aW9ucy53aWR0aCB9KS5sZWZ0O1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRpZiAocnMpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR1aS5wb3NpdGlvbi5sZWZ0ID0gaW5zdC5fY29udmVydFBvc2l0aW9uVG8oXFxcInJlbGF0aXZlXFxcIiwgeyB0b3A6IDAsIGxlZnQ6IHIgfSkubGVmdDtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGZpcnN0ID0gdHMgfHwgYnMgfHwgbHMgfHwgcnM7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKG8uc25hcE1vZGUgIT09IFxcXCJvdXRlclxcXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHR0cyA9IE1hdGguYWJzKHQgLSB5MSkgPD0gZDtcXG5cXHRcXHRcXHRcXHRcXHRicyA9IE1hdGguYWJzKGIgLSB5MikgPD0gZDtcXG5cXHRcXHRcXHRcXHRcXHRscyA9IE1hdGguYWJzKGwgLSB4MSkgPD0gZDtcXG5cXHRcXHRcXHRcXHRcXHRycyA9IE1hdGguYWJzKHIgLSB4MikgPD0gZDtcXG5cXHRcXHRcXHRcXHRcXHRpZiAodHMpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR1aS5wb3NpdGlvbi50b3AgPSBpbnN0Ll9jb252ZXJ0UG9zaXRpb25UbyhcXFwicmVsYXRpdmVcXFwiLCB7IHRvcDogdCwgbGVmdDogMCB9KS50b3A7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmIChicykge1xcblxcdFxcdFxcdFxcdFxcdFxcdHVpLnBvc2l0aW9uLnRvcCA9IGluc3QuX2NvbnZlcnRQb3NpdGlvblRvKFxcXCJyZWxhdGl2ZVxcXCIsIHsgdG9wOiBiIC0gaW5zdC5oZWxwZXJQcm9wb3J0aW9ucy5oZWlnaHQsIGxlZnQ6IDAgfSkudG9wO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRpZiAobHMpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR1aS5wb3NpdGlvbi5sZWZ0ID0gaW5zdC5fY29udmVydFBvc2l0aW9uVG8oXFxcInJlbGF0aXZlXFxcIiwgeyB0b3A6IDAsIGxlZnQ6IGwgfSkubGVmdDtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHJzKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dWkucG9zaXRpb24ubGVmdCA9IGluc3QuX2NvbnZlcnRQb3NpdGlvblRvKFxcXCJyZWxhdGl2ZVxcXCIsIHsgdG9wOiAwLCBsZWZ0OiByIC0gaW5zdC5oZWxwZXJQcm9wb3J0aW9ucy53aWR0aCB9KS5sZWZ0O1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCFpbnN0LnNuYXBFbGVtZW50c1tpXS5zbmFwcGluZyAmJiAodHMgfHwgYnMgfHwgbHMgfHwgcnMgfHwgZmlyc3QpKSB7XFxuXFx0XFx0XFx0XFx0XFx0aW5zdC5vcHRpb25zLnNuYXAuc25hcCAmJiBpbnN0Lm9wdGlvbnMuc25hcC5zbmFwLmNhbGwoaW5zdC5lbGVtZW50LCBldmVudCwgJC5leHRlbmQoaW5zdC5fdWlIYXNoKCksIHsgc25hcEl0ZW06IGluc3Quc25hcEVsZW1lbnRzW2ldLml0ZW0gfSkpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRpbnN0LnNuYXBFbGVtZW50c1tpXS5zbmFwcGluZyA9IHRzIHx8IGJzIHx8IGxzIHx8IHJzIHx8IGZpcnN0O1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fSk7XFxuXFxuXFx0JC51aS5wbHVnaW4uYWRkKFxcXCJkcmFnZ2FibGVcXFwiLCBcXFwic3RhY2tcXFwiLCB7XFxuXFx0XFx0c3RhcnQ6IGZ1bmN0aW9uIHN0YXJ0KGV2ZW50LCB1aSwgaW5zdGFuY2UpIHtcXG5cXHRcXHRcXHR2YXIgbWluLFxcblxcdFxcdFxcdCAgICBvID0gaW5zdGFuY2Uub3B0aW9ucyxcXG5cXHRcXHRcXHQgICAgZ3JvdXAgPSAkLm1ha2VBcnJheSgkKG8uc3RhY2spKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIChwYXJzZUludCgkKGEpLmNzcyhcXFwiekluZGV4XFxcIiksIDEwKSB8fCAwKSAtIChwYXJzZUludCgkKGIpLmNzcyhcXFwiekluZGV4XFxcIiksIDEwKSB8fCAwKTtcXG5cXHRcXHRcXHR9KTtcXG5cXG5cXHRcXHRcXHRpZiAoIWdyb3VwLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0bWluID0gcGFyc2VJbnQoJChncm91cFswXSkuY3NzKFxcXCJ6SW5kZXhcXFwiKSwgMTApIHx8IDA7XFxuXFx0XFx0XFx0JChncm91cCkuZWFjaChmdW5jdGlvbiAoaSkge1xcblxcdFxcdFxcdFxcdCQodGhpcykuY3NzKFxcXCJ6SW5kZXhcXFwiLCBtaW4gKyBpKTtcXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHR0aGlzLmNzcyhcXFwiekluZGV4XFxcIiwgbWluICsgZ3JvdXAubGVuZ3RoKTtcXG5cXHRcXHR9XFxuXFx0fSk7XFxuXFxuXFx0JC51aS5wbHVnaW4uYWRkKFxcXCJkcmFnZ2FibGVcXFwiLCBcXFwiekluZGV4XFxcIiwge1xcblxcdFxcdHN0YXJ0OiBmdW5jdGlvbiBzdGFydChldmVudCwgdWksIGluc3RhbmNlKSB7XFxuXFx0XFx0XFx0dmFyIHQgPSAkKHVpLmhlbHBlciksXFxuXFx0XFx0XFx0ICAgIG8gPSBpbnN0YW5jZS5vcHRpb25zO1xcblxcblxcdFxcdFxcdGlmICh0LmNzcyhcXFwiekluZGV4XFxcIikpIHtcXG5cXHRcXHRcXHRcXHRvLl96SW5kZXggPSB0LmNzcyhcXFwiekluZGV4XFxcIik7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHQuY3NzKFxcXCJ6SW5kZXhcXFwiLCBvLnpJbmRleCk7XFxuXFx0XFx0fSxcXG5cXHRcXHRzdG9wOiBmdW5jdGlvbiBzdG9wKGV2ZW50LCB1aSwgaW5zdGFuY2UpIHtcXG5cXHRcXHRcXHR2YXIgbyA9IGluc3RhbmNlLm9wdGlvbnM7XFxuXFxuXFx0XFx0XFx0aWYgKG8uX3pJbmRleCkge1xcblxcdFxcdFxcdFxcdCQodWkuaGVscGVyKS5jc3MoXFxcInpJbmRleFxcXCIsIG8uX3pJbmRleCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9KTtcXG5cXG5cXHR2YXIgZHJhZ2dhYmxlID0gJC51aS5kcmFnZ2FibGU7XFxuXFxuXFx0LyohXFxuICAqIGpRdWVyeSBVSSBSZXNpemFibGUgMS4xMS40XFxuICAqIGh0dHA6Ly9qcXVlcnl1aS5jb21cXG4gICpcXG4gICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcXG4gICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxcbiAgKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXFxuICAqXFxuICAqIGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL3Jlc2l6YWJsZS9cXG4gICovXFxuXFxuXFx0JC53aWRnZXQoXFxcInVpLnJlc2l6YWJsZVxcXCIsICQudWkubW91c2UsIHtcXG5cXHRcXHR2ZXJzaW9uOiBcXFwiMS4xMS40XFxcIixcXG5cXHRcXHR3aWRnZXRFdmVudFByZWZpeDogXFxcInJlc2l6ZVxcXCIsXFxuXFx0XFx0b3B0aW9uczoge1xcblxcdFxcdFxcdGFsc29SZXNpemU6IGZhbHNlLFxcblxcdFxcdFxcdGFuaW1hdGU6IGZhbHNlLFxcblxcdFxcdFxcdGFuaW1hdGVEdXJhdGlvbjogXFxcInNsb3dcXFwiLFxcblxcdFxcdFxcdGFuaW1hdGVFYXNpbmc6IFxcXCJzd2luZ1xcXCIsXFxuXFx0XFx0XFx0YXNwZWN0UmF0aW86IGZhbHNlLFxcblxcdFxcdFxcdGF1dG9IaWRlOiBmYWxzZSxcXG5cXHRcXHRcXHRjb250YWlubWVudDogZmFsc2UsXFxuXFx0XFx0XFx0Z2hvc3Q6IGZhbHNlLFxcblxcdFxcdFxcdGdyaWQ6IGZhbHNlLFxcblxcdFxcdFxcdGhhbmRsZXM6IFxcXCJlLHMsc2VcXFwiLFxcblxcdFxcdFxcdGhlbHBlcjogZmFsc2UsXFxuXFx0XFx0XFx0bWF4SGVpZ2h0OiBudWxsLFxcblxcdFxcdFxcdG1heFdpZHRoOiBudWxsLFxcblxcdFxcdFxcdG1pbkhlaWdodDogMTAsXFxuXFx0XFx0XFx0bWluV2lkdGg6IDEwLFxcblxcdFxcdFxcdC8vIFNlZSAjNzk2MFxcblxcdFxcdFxcdHpJbmRleDogOTAsXFxuXFxuXFx0XFx0XFx0Ly8gY2FsbGJhY2tzXFxuXFx0XFx0XFx0cmVzaXplOiBudWxsLFxcblxcdFxcdFxcdHN0YXJ0OiBudWxsLFxcblxcdFxcdFxcdHN0b3A6IG51bGxcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9udW06IGZ1bmN0aW9uIF9udW0odmFsdWUpIHtcXG5cXHRcXHRcXHRyZXR1cm4gcGFyc2VJbnQodmFsdWUsIDEwKSB8fCAwO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X2lzTnVtYmVyOiBmdW5jdGlvbiBfaXNOdW1iZXIodmFsdWUpIHtcXG5cXHRcXHRcXHRyZXR1cm4gIWlzTmFOKHBhcnNlSW50KHZhbHVlLCAxMCkpO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X2hhc1Njcm9sbDogZnVuY3Rpb24gX2hhc1Njcm9sbChlbCwgYSkge1xcblxcblxcdFxcdFxcdGlmICgkKGVsKS5jc3MoXFxcIm92ZXJmbG93XFxcIikgPT09IFxcXCJoaWRkZW5cXFwiKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2YXIgc2Nyb2xsID0gYSAmJiBhID09PSBcXFwibGVmdFxcXCIgPyBcXFwic2Nyb2xsTGVmdFxcXCIgOiBcXFwic2Nyb2xsVG9wXFxcIixcXG5cXHRcXHRcXHQgICAgaGFzID0gZmFsc2U7XFxuXFxuXFx0XFx0XFx0aWYgKGVsW3Njcm9sbF0gPiAwKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFRPRE86IGRldGVybWluZSB3aGljaCBjYXNlcyBhY3R1YWxseSBjYXVzZSB0aGlzIHRvIGhhcHBlblxcblxcdFxcdFxcdC8vIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSB0aGUgc2Nyb2xsIHNldCwgc2VlIGlmIGl0J3MgcG9zc2libGUgdG9cXG5cXHRcXHRcXHQvLyBzZXQgdGhlIHNjcm9sbFxcblxcdFxcdFxcdGVsW3Njcm9sbF0gPSAxO1xcblxcdFxcdFxcdGhhcyA9IGVsW3Njcm9sbF0gPiAwO1xcblxcdFxcdFxcdGVsW3Njcm9sbF0gPSAwO1xcblxcdFxcdFxcdHJldHVybiBoYXM7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfY3JlYXRlOiBmdW5jdGlvbiBfY3JlYXRlKCkge1xcblxcblxcdFxcdFxcdHZhciBuLFxcblxcdFxcdFxcdCAgICBpLFxcblxcdFxcdFxcdCAgICBoYW5kbGUsXFxuXFx0XFx0XFx0ICAgIGF4aXMsXFxuXFx0XFx0XFx0ICAgIGhuYW1lLFxcblxcdFxcdFxcdCAgICB0aGF0ID0gdGhpcyxcXG5cXHRcXHRcXHQgICAgbyA9IHRoaXMub3B0aW9ucztcXG5cXHRcXHRcXHR0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoXFxcInVpLXJlc2l6YWJsZVxcXCIpO1xcblxcblxcdFxcdFxcdCQuZXh0ZW5kKHRoaXMsIHtcXG5cXHRcXHRcXHRcXHRfYXNwZWN0UmF0aW86ICEhby5hc3BlY3RSYXRpbyxcXG5cXHRcXHRcXHRcXHRhc3BlY3RSYXRpbzogby5hc3BlY3RSYXRpbyxcXG5cXHRcXHRcXHRcXHRvcmlnaW5hbEVsZW1lbnQ6IHRoaXMuZWxlbWVudCxcXG5cXHRcXHRcXHRcXHRfcHJvcG9ydGlvbmFsbHlSZXNpemVFbGVtZW50czogW10sXFxuXFx0XFx0XFx0XFx0X2hlbHBlcjogby5oZWxwZXIgfHwgby5naG9zdCB8fCBvLmFuaW1hdGUgPyBvLmhlbHBlciB8fCBcXFwidWktcmVzaXphYmxlLWhlbHBlclxcXCIgOiBudWxsXFxuXFx0XFx0XFx0fSk7XFxuXFxuXFx0XFx0XFx0Ly8gV3JhcCB0aGUgZWxlbWVudCBpZiBpdCBjYW5ub3QgaG9sZCBjaGlsZCBub2Rlc1xcblxcdFxcdFxcdGlmICh0aGlzLmVsZW1lbnRbMF0ubm9kZU5hbWUubWF0Y2goL14oY2FudmFzfHRleHRhcmVhfGlucHV0fHNlbGVjdHxidXR0b258aW1nKSQvaSkpIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLmVsZW1lbnQud3JhcCgkKFxcXCI8ZGl2IGNsYXNzPSd1aS13cmFwcGVyJyBzdHlsZT0nb3ZlcmZsb3c6IGhpZGRlbjsnPjwvZGl2PlxcXCIpLmNzcyh7XFxuXFx0XFx0XFx0XFx0XFx0cG9zaXRpb246IHRoaXMuZWxlbWVudC5jc3MoXFxcInBvc2l0aW9uXFxcIiksXFxuXFx0XFx0XFx0XFx0XFx0d2lkdGg6IHRoaXMuZWxlbWVudC5vdXRlcldpZHRoKCksXFxuXFx0XFx0XFx0XFx0XFx0aGVpZ2h0OiB0aGlzLmVsZW1lbnQub3V0ZXJIZWlnaHQoKSxcXG5cXHRcXHRcXHRcXHRcXHR0b3A6IHRoaXMuZWxlbWVudC5jc3MoXFxcInRvcFxcXCIpLFxcblxcdFxcdFxcdFxcdFxcdGxlZnQ6IHRoaXMuZWxlbWVudC5jc3MoXFxcImxlZnRcXFwiKVxcblxcdFxcdFxcdFxcdH0pKTtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLmVsZW1lbnQgPSB0aGlzLmVsZW1lbnQucGFyZW50KCkuZGF0YShcXFwidWktcmVzaXphYmxlXFxcIiwgdGhpcy5lbGVtZW50LnJlc2l6YWJsZShcXFwiaW5zdGFuY2VcXFwiKSk7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5lbGVtZW50SXNXcmFwcGVyID0gdHJ1ZTtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLmVsZW1lbnQuY3NzKHtcXG5cXHRcXHRcXHRcXHRcXHRtYXJnaW5MZWZ0OiB0aGlzLm9yaWdpbmFsRWxlbWVudC5jc3MoXFxcIm1hcmdpbkxlZnRcXFwiKSxcXG5cXHRcXHRcXHRcXHRcXHRtYXJnaW5Ub3A6IHRoaXMub3JpZ2luYWxFbGVtZW50LmNzcyhcXFwibWFyZ2luVG9wXFxcIiksXFxuXFx0XFx0XFx0XFx0XFx0bWFyZ2luUmlnaHQ6IHRoaXMub3JpZ2luYWxFbGVtZW50LmNzcyhcXFwibWFyZ2luUmlnaHRcXFwiKSxcXG5cXHRcXHRcXHRcXHRcXHRtYXJnaW5Cb3R0b206IHRoaXMub3JpZ2luYWxFbGVtZW50LmNzcyhcXFwibWFyZ2luQm90dG9tXFxcIilcXG5cXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcXHR0aGlzLm9yaWdpbmFsRWxlbWVudC5jc3Moe1xcblxcdFxcdFxcdFxcdFxcdG1hcmdpbkxlZnQ6IDAsXFxuXFx0XFx0XFx0XFx0XFx0bWFyZ2luVG9wOiAwLFxcblxcdFxcdFxcdFxcdFxcdG1hcmdpblJpZ2h0OiAwLFxcblxcdFxcdFxcdFxcdFxcdG1hcmdpbkJvdHRvbTogMFxcblxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdFxcdC8vIHN1cHBvcnQ6IFNhZmFyaVxcblxcdFxcdFxcdFxcdC8vIFByZXZlbnQgU2FmYXJpIHRleHRhcmVhIHJlc2l6ZVxcblxcdFxcdFxcdFxcdHRoaXMub3JpZ2luYWxSZXNpemVTdHlsZSA9IHRoaXMub3JpZ2luYWxFbGVtZW50LmNzcyhcXFwicmVzaXplXFxcIik7XFxuXFx0XFx0XFx0XFx0dGhpcy5vcmlnaW5hbEVsZW1lbnQuY3NzKFxcXCJyZXNpemVcXFwiLCBcXFwibm9uZVxcXCIpO1xcblxcblxcdFxcdFxcdFxcdHRoaXMuX3Byb3BvcnRpb25hbGx5UmVzaXplRWxlbWVudHMucHVzaCh0aGlzLm9yaWdpbmFsRWxlbWVudC5jc3Moe1xcblxcdFxcdFxcdFxcdFxcdHBvc2l0aW9uOiBcXFwic3RhdGljXFxcIixcXG5cXHRcXHRcXHRcXHRcXHR6b29tOiAxLFxcblxcdFxcdFxcdFxcdFxcdGRpc3BsYXk6IFxcXCJibG9ja1xcXCJcXG5cXHRcXHRcXHRcXHR9KSk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gc3VwcG9ydDogSUU5XFxuXFx0XFx0XFx0XFx0Ly8gYXZvaWQgSUUganVtcCAoaGFyZCBzZXQgdGhlIG1hcmdpbilcXG5cXHRcXHRcXHRcXHR0aGlzLm9yaWdpbmFsRWxlbWVudC5jc3MoeyBtYXJnaW46IHRoaXMub3JpZ2luYWxFbGVtZW50LmNzcyhcXFwibWFyZ2luXFxcIikgfSk7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5fcHJvcG9ydGlvbmFsbHlSZXNpemUoKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy5oYW5kbGVzID0gby5oYW5kbGVzIHx8ICghJChcXFwiLnVpLXJlc2l6YWJsZS1oYW5kbGVcXFwiLCB0aGlzLmVsZW1lbnQpLmxlbmd0aCA/IFxcXCJlLHMsc2VcXFwiIDoge1xcblxcdFxcdFxcdFxcdG46IFxcXCIudWktcmVzaXphYmxlLW5cXFwiLFxcblxcdFxcdFxcdFxcdGU6IFxcXCIudWktcmVzaXphYmxlLWVcXFwiLFxcblxcdFxcdFxcdFxcdHM6IFxcXCIudWktcmVzaXphYmxlLXNcXFwiLFxcblxcdFxcdFxcdFxcdHc6IFxcXCIudWktcmVzaXphYmxlLXdcXFwiLFxcblxcdFxcdFxcdFxcdHNlOiBcXFwiLnVpLXJlc2l6YWJsZS1zZVxcXCIsXFxuXFx0XFx0XFx0XFx0c3c6IFxcXCIudWktcmVzaXphYmxlLXN3XFxcIixcXG5cXHRcXHRcXHRcXHRuZTogXFxcIi51aS1yZXNpemFibGUtbmVcXFwiLFxcblxcdFxcdFxcdFxcdG53OiBcXFwiLnVpLXJlc2l6YWJsZS1ud1xcXCJcXG5cXHRcXHRcXHR9KTtcXG5cXG5cXHRcXHRcXHR0aGlzLl9oYW5kbGVzID0gJCgpO1xcblxcdFxcdFxcdGlmICh0aGlzLmhhbmRsZXMuY29uc3RydWN0b3IgPT09IFN0cmluZykge1xcblxcblxcdFxcdFxcdFxcdGlmICh0aGlzLmhhbmRsZXMgPT09IFxcXCJhbGxcXFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5oYW5kbGVzID0gXFxcIm4sZSxzLHcsc2Usc3csbmUsbndcXFwiO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRuID0gdGhpcy5oYW5kbGVzLnNwbGl0KFxcXCIsXFxcIik7XFxuXFx0XFx0XFx0XFx0dGhpcy5oYW5kbGVzID0ge307XFxuXFxuXFx0XFx0XFx0XFx0Zm9yIChpID0gMDsgaSA8IG4ubGVuZ3RoOyBpKyspIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRoYW5kbGUgPSAkLnRyaW0obltpXSk7XFxuXFx0XFx0XFx0XFx0XFx0aG5hbWUgPSBcXFwidWktcmVzaXphYmxlLVxcXCIgKyBoYW5kbGU7XFxuXFx0XFx0XFx0XFx0XFx0YXhpcyA9ICQoXFxcIjxkaXYgY2xhc3M9J3VpLXJlc2l6YWJsZS1oYW5kbGUgXFxcIiArIGhuYW1lICsgXFxcIic+PC9kaXY+XFxcIik7XFxuXFxuXFx0XFx0XFx0XFx0XFx0YXhpcy5jc3MoeyB6SW5kZXg6IG8uekluZGV4IH0pO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIFRPRE8gOiBXaGF0J3MgZ29pbmcgb24gaGVyZT9cXG5cXHRcXHRcXHRcXHRcXHRpZiAoXFxcInNlXFxcIiA9PT0gaGFuZGxlKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YXhpcy5hZGRDbGFzcyhcXFwidWktaWNvbiB1aS1pY29uLWdyaXBzbWFsbC1kaWFnb25hbC1zZVxcXCIpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmhhbmRsZXNbaGFuZGxlXSA9IFxcXCIudWktcmVzaXphYmxlLVxcXCIgKyBoYW5kbGU7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5lbGVtZW50LmFwcGVuZChheGlzKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMuX3JlbmRlckF4aXMgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGksIGF4aXMsIHBhZFBvcywgcGFkV3JhcHBlcjtcXG5cXG5cXHRcXHRcXHRcXHR0YXJnZXQgPSB0YXJnZXQgfHwgdGhpcy5lbGVtZW50O1xcblxcblxcdFxcdFxcdFxcdGZvciAoaSBpbiB0aGlzLmhhbmRsZXMpIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAodGhpcy5oYW5kbGVzW2ldLmNvbnN0cnVjdG9yID09PSBTdHJpbmcpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLmhhbmRsZXNbaV0gPSB0aGlzLmVsZW1lbnQuY2hpbGRyZW4odGhpcy5oYW5kbGVzW2ldKS5maXJzdCgpLnNob3coKTtcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2UgaWYgKHRoaXMuaGFuZGxlc1tpXS5qcXVlcnkgfHwgdGhpcy5oYW5kbGVzW2ldLm5vZGVUeXBlKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5oYW5kbGVzW2ldID0gJCh0aGlzLmhhbmRsZXNbaV0pO1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuX29uKHRoaXMuaGFuZGxlc1tpXSwgeyBcXFwibW91c2Vkb3duXFxcIjogdGhhdC5fbW91c2VEb3duIH0pO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAodGhpcy5lbGVtZW50SXNXcmFwcGVyICYmIHRoaXMub3JpZ2luYWxFbGVtZW50WzBdLm5vZGVOYW1lLm1hdGNoKC9eKHRleHRhcmVhfGlucHV0fHNlbGVjdHxidXR0b24pJC9pKSkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGF4aXMgPSAkKHRoaXMuaGFuZGxlc1tpXSwgdGhpcy5lbGVtZW50KTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRwYWRXcmFwcGVyID0gL3N3fG5lfG53fHNlfG58cy8udGVzdChpKSA/IGF4aXMub3V0ZXJIZWlnaHQoKSA6IGF4aXMub3V0ZXJXaWR0aCgpO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHBhZFBvcyA9IFtcXFwicGFkZGluZ1xcXCIsIC9uZXxud3xuLy50ZXN0KGkpID8gXFxcIlRvcFxcXCIgOiAvc2V8c3d8cy8udGVzdChpKSA/IFxcXCJCb3R0b21cXFwiIDogL15lJC8udGVzdChpKSA/IFxcXCJSaWdodFxcXCIgOiBcXFwiTGVmdFxcXCJdLmpvaW4oXFxcIlxcXCIpO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHRhcmdldC5jc3MocGFkUG9zLCBwYWRXcmFwcGVyKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl9wcm9wb3J0aW9uYWxseVJlc2l6ZSgpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9oYW5kbGVzID0gdGhpcy5faGFuZGxlcy5hZGQodGhpcy5oYW5kbGVzW2ldKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHRcXHQvLyBUT0RPOiBtYWtlIHJlbmRlckF4aXMgYSBwcm90b3R5cGUgZnVuY3Rpb25cXG5cXHRcXHRcXHR0aGlzLl9yZW5kZXJBeGlzKHRoaXMuZWxlbWVudCk7XFxuXFxuXFx0XFx0XFx0dGhpcy5faGFuZGxlcyA9IHRoaXMuX2hhbmRsZXMuYWRkKHRoaXMuZWxlbWVudC5maW5kKFxcXCIudWktcmVzaXphYmxlLWhhbmRsZVxcXCIpKTtcXG5cXHRcXHRcXHR0aGlzLl9oYW5kbGVzLmRpc2FibGVTZWxlY3Rpb24oKTtcXG5cXG5cXHRcXHRcXHR0aGlzLl9oYW5kbGVzLm1vdXNlb3ZlcihmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCF0aGF0LnJlc2l6aW5nKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHRoaXMuY2xhc3NOYW1lKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YXhpcyA9IHRoaXMuY2xhc3NOYW1lLm1hdGNoKC91aS1yZXNpemFibGUtKHNlfHN3fG5lfG53fG58ZXxzfHcpL2kpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR0aGF0LmF4aXMgPSBheGlzICYmIGF4aXNbMV0gPyBheGlzWzFdIDogXFxcInNlXFxcIjtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSk7XFxuXFxuXFx0XFx0XFx0aWYgKG8uYXV0b0hpZGUpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9oYW5kbGVzLmhpZGUoKTtcXG5cXHRcXHRcXHRcXHQkKHRoaXMuZWxlbWVudCkuYWRkQ2xhc3MoXFxcInVpLXJlc2l6YWJsZS1hdXRvaGlkZVxcXCIpLm1vdXNlZW50ZXIoZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdGlmIChvLmRpc2FibGVkKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHQkKHRoaXMpLnJlbW92ZUNsYXNzKFxcXCJ1aS1yZXNpemFibGUtYXV0b2hpZGVcXFwiKTtcXG5cXHRcXHRcXHRcXHRcXHR0aGF0Ll9oYW5kbGVzLnNob3coKTtcXG5cXHRcXHRcXHRcXHR9KS5tb3VzZWxlYXZlKGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoby5kaXNhYmxlZCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCF0aGF0LnJlc2l6aW5nKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0JCh0aGlzKS5hZGRDbGFzcyhcXFwidWktcmVzaXphYmxlLWF1dG9oaWRlXFxcIik7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhhdC5faGFuZGxlcy5oaWRlKCk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLl9tb3VzZUluaXQoKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9kZXN0cm95OiBmdW5jdGlvbiBfZGVzdHJveSgpIHtcXG5cXG5cXHRcXHRcXHR0aGlzLl9tb3VzZURlc3Ryb3koKTtcXG5cXG5cXHRcXHRcXHR2YXIgd3JhcHBlcixcXG5cXHRcXHRcXHQgICAgX2Rlc3Ryb3kgPSBmdW5jdGlvbiBfZGVzdHJveShleHApIHtcXG5cXHRcXHRcXHRcXHQkKGV4cCkucmVtb3ZlQ2xhc3MoXFxcInVpLXJlc2l6YWJsZSB1aS1yZXNpemFibGUtZGlzYWJsZWQgdWktcmVzaXphYmxlLXJlc2l6aW5nXFxcIikucmVtb3ZlRGF0YShcXFwicmVzaXphYmxlXFxcIikucmVtb3ZlRGF0YShcXFwidWktcmVzaXphYmxlXFxcIikudW5iaW5kKFxcXCIucmVzaXphYmxlXFxcIikuZmluZChcXFwiLnVpLXJlc2l6YWJsZS1oYW5kbGVcXFwiKS5yZW1vdmUoKTtcXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdFxcdC8vIFRPRE86IFVud3JhcCBhdCBzYW1lIERPTSBwb3NpdGlvblxcblxcdFxcdFxcdGlmICh0aGlzLmVsZW1lbnRJc1dyYXBwZXIpIHtcXG5cXHRcXHRcXHRcXHRfZGVzdHJveSh0aGlzLmVsZW1lbnQpO1xcblxcdFxcdFxcdFxcdHdyYXBwZXIgPSB0aGlzLmVsZW1lbnQ7XFxuXFx0XFx0XFx0XFx0dGhpcy5vcmlnaW5hbEVsZW1lbnQuY3NzKHtcXG5cXHRcXHRcXHRcXHRcXHRwb3NpdGlvbjogd3JhcHBlci5jc3MoXFxcInBvc2l0aW9uXFxcIiksXFxuXFx0XFx0XFx0XFx0XFx0d2lkdGg6IHdyYXBwZXIub3V0ZXJXaWR0aCgpLFxcblxcdFxcdFxcdFxcdFxcdGhlaWdodDogd3JhcHBlci5vdXRlckhlaWdodCgpLFxcblxcdFxcdFxcdFxcdFxcdHRvcDogd3JhcHBlci5jc3MoXFxcInRvcFxcXCIpLFxcblxcdFxcdFxcdFxcdFxcdGxlZnQ6IHdyYXBwZXIuY3NzKFxcXCJsZWZ0XFxcIilcXG5cXHRcXHRcXHRcXHR9KS5pbnNlcnRBZnRlcih3cmFwcGVyKTtcXG5cXHRcXHRcXHRcXHR3cmFwcGVyLnJlbW92ZSgpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLm9yaWdpbmFsRWxlbWVudC5jc3MoXFxcInJlc2l6ZVxcXCIsIHRoaXMub3JpZ2luYWxSZXNpemVTdHlsZSk7XFxuXFx0XFx0XFx0X2Rlc3Ryb3kodGhpcy5vcmlnaW5hbEVsZW1lbnQpO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X21vdXNlQ2FwdHVyZTogZnVuY3Rpb24gX21vdXNlQ2FwdHVyZShldmVudCkge1xcblxcdFxcdFxcdHZhciBpLFxcblxcdFxcdFxcdCAgICBoYW5kbGUsXFxuXFx0XFx0XFx0ICAgIGNhcHR1cmUgPSBmYWxzZTtcXG5cXG5cXHRcXHRcXHRmb3IgKGkgaW4gdGhpcy5oYW5kbGVzKSB7XFxuXFx0XFx0XFx0XFx0aGFuZGxlID0gJCh0aGlzLmhhbmRsZXNbaV0pWzBdO1xcblxcdFxcdFxcdFxcdGlmIChoYW5kbGUgPT09IGV2ZW50LnRhcmdldCB8fCAkLmNvbnRhaW5zKGhhbmRsZSwgZXZlbnQudGFyZ2V0KSkge1xcblxcdFxcdFxcdFxcdFxcdGNhcHR1cmUgPSB0cnVlO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuICF0aGlzLm9wdGlvbnMuZGlzYWJsZWQgJiYgY2FwdHVyZTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9tb3VzZVN0YXJ0OiBmdW5jdGlvbiBfbW91c2VTdGFydChldmVudCkge1xcblxcblxcdFxcdFxcdHZhciBjdXJsZWZ0LFxcblxcdFxcdFxcdCAgICBjdXJ0b3AsXFxuXFx0XFx0XFx0ICAgIGN1cnNvcixcXG5cXHRcXHRcXHQgICAgbyA9IHRoaXMub3B0aW9ucyxcXG5cXHRcXHRcXHQgICAgZWwgPSB0aGlzLmVsZW1lbnQ7XFxuXFxuXFx0XFx0XFx0dGhpcy5yZXNpemluZyA9IHRydWU7XFxuXFxuXFx0XFx0XFx0dGhpcy5fcmVuZGVyUHJveHkoKTtcXG5cXG5cXHRcXHRcXHRjdXJsZWZ0ID0gdGhpcy5fbnVtKHRoaXMuaGVscGVyLmNzcyhcXFwibGVmdFxcXCIpKTtcXG5cXHRcXHRcXHRjdXJ0b3AgPSB0aGlzLl9udW0odGhpcy5oZWxwZXIuY3NzKFxcXCJ0b3BcXFwiKSk7XFxuXFxuXFx0XFx0XFx0aWYgKG8uY29udGFpbm1lbnQpIHtcXG5cXHRcXHRcXHRcXHRjdXJsZWZ0ICs9ICQoby5jb250YWlubWVudCkuc2Nyb2xsTGVmdCgpIHx8IDA7XFxuXFx0XFx0XFx0XFx0Y3VydG9wICs9ICQoby5jb250YWlubWVudCkuc2Nyb2xsVG9wKCkgfHwgMDtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy5vZmZzZXQgPSB0aGlzLmhlbHBlci5vZmZzZXQoKTtcXG5cXHRcXHRcXHR0aGlzLnBvc2l0aW9uID0geyBsZWZ0OiBjdXJsZWZ0LCB0b3A6IGN1cnRvcCB9O1xcblxcblxcdFxcdFxcdHRoaXMuc2l6ZSA9IHRoaXMuX2hlbHBlciA/IHtcXG5cXHRcXHRcXHRcXHR3aWR0aDogdGhpcy5oZWxwZXIud2lkdGgoKSxcXG5cXHRcXHRcXHRcXHRoZWlnaHQ6IHRoaXMuaGVscGVyLmhlaWdodCgpXFxuXFx0XFx0XFx0fSA6IHtcXG5cXHRcXHRcXHRcXHR3aWR0aDogZWwud2lkdGgoKSxcXG5cXHRcXHRcXHRcXHRoZWlnaHQ6IGVsLmhlaWdodCgpXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHRcXHR0aGlzLm9yaWdpbmFsU2l6ZSA9IHRoaXMuX2hlbHBlciA/IHtcXG5cXHRcXHRcXHRcXHR3aWR0aDogZWwub3V0ZXJXaWR0aCgpLFxcblxcdFxcdFxcdFxcdGhlaWdodDogZWwub3V0ZXJIZWlnaHQoKVxcblxcdFxcdFxcdH0gOiB7XFxuXFx0XFx0XFx0XFx0d2lkdGg6IGVsLndpZHRoKCksXFxuXFx0XFx0XFx0XFx0aGVpZ2h0OiBlbC5oZWlnaHQoKVxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0XFx0dGhpcy5zaXplRGlmZiA9IHtcXG5cXHRcXHRcXHRcXHR3aWR0aDogZWwub3V0ZXJXaWR0aCgpIC0gZWwud2lkdGgoKSxcXG5cXHRcXHRcXHRcXHRoZWlnaHQ6IGVsLm91dGVySGVpZ2h0KCkgLSBlbC5oZWlnaHQoKVxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0XFx0dGhpcy5vcmlnaW5hbFBvc2l0aW9uID0geyBsZWZ0OiBjdXJsZWZ0LCB0b3A6IGN1cnRvcCB9O1xcblxcdFxcdFxcdHRoaXMub3JpZ2luYWxNb3VzZVBvc2l0aW9uID0geyBsZWZ0OiBldmVudC5wYWdlWCwgdG9wOiBldmVudC5wYWdlWSB9O1xcblxcblxcdFxcdFxcdHRoaXMuYXNwZWN0UmF0aW8gPSB0eXBlb2Ygby5hc3BlY3RSYXRpbyA9PT0gXFxcIm51bWJlclxcXCIgPyBvLmFzcGVjdFJhdGlvIDogdGhpcy5vcmlnaW5hbFNpemUud2lkdGggLyB0aGlzLm9yaWdpbmFsU2l6ZS5oZWlnaHQgfHwgMTtcXG5cXG5cXHRcXHRcXHRjdXJzb3IgPSAkKFxcXCIudWktcmVzaXphYmxlLVxcXCIgKyB0aGlzLmF4aXMpLmNzcyhcXFwiY3Vyc29yXFxcIik7XFxuXFx0XFx0XFx0JChcXFwiYm9keVxcXCIpLmNzcyhcXFwiY3Vyc29yXFxcIiwgY3Vyc29yID09PSBcXFwiYXV0b1xcXCIgPyB0aGlzLmF4aXMgKyBcXFwiLXJlc2l6ZVxcXCIgOiBjdXJzb3IpO1xcblxcblxcdFxcdFxcdGVsLmFkZENsYXNzKFxcXCJ1aS1yZXNpemFibGUtcmVzaXppbmdcXFwiKTtcXG5cXHRcXHRcXHR0aGlzLl9wcm9wYWdhdGUoXFxcInN0YXJ0XFxcIiwgZXZlbnQpO1xcblxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X21vdXNlRHJhZzogZnVuY3Rpb24gX21vdXNlRHJhZyhldmVudCkge1xcblxcblxcdFxcdFxcdHZhciBkYXRhLFxcblxcdFxcdFxcdCAgICBwcm9wcyxcXG5cXHRcXHRcXHQgICAgc21wID0gdGhpcy5vcmlnaW5hbE1vdXNlUG9zaXRpb24sXFxuXFx0XFx0XFx0ICAgIGEgPSB0aGlzLmF4aXMsXFxuXFx0XFx0XFx0ICAgIGR4ID0gZXZlbnQucGFnZVggLSBzbXAubGVmdCB8fCAwLFxcblxcdFxcdFxcdCAgICBkeSA9IGV2ZW50LnBhZ2VZIC0gc21wLnRvcCB8fCAwLFxcblxcdFxcdFxcdCAgICB0cmlnZ2VyID0gdGhpcy5fY2hhbmdlW2FdO1xcblxcblxcdFxcdFxcdHRoaXMuX3VwZGF0ZVByZXZQcm9wZXJ0aWVzKCk7XFxuXFxuXFx0XFx0XFx0aWYgKCF0cmlnZ2VyKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRkYXRhID0gdHJpZ2dlci5hcHBseSh0aGlzLCBbZXZlbnQsIGR4LCBkeV0pO1xcblxcblxcdFxcdFxcdHRoaXMuX3VwZGF0ZVZpcnR1YWxCb3VuZGFyaWVzKGV2ZW50LnNoaWZ0S2V5KTtcXG5cXHRcXHRcXHRpZiAodGhpcy5fYXNwZWN0UmF0aW8gfHwgZXZlbnQuc2hpZnRLZXkpIHtcXG5cXHRcXHRcXHRcXHRkYXRhID0gdGhpcy5fdXBkYXRlUmF0aW8oZGF0YSwgZXZlbnQpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRkYXRhID0gdGhpcy5fcmVzcGVjdFNpemUoZGF0YSwgZXZlbnQpO1xcblxcblxcdFxcdFxcdHRoaXMuX3VwZGF0ZUNhY2hlKGRhdGEpO1xcblxcblxcdFxcdFxcdHRoaXMuX3Byb3BhZ2F0ZShcXFwicmVzaXplXFxcIiwgZXZlbnQpO1xcblxcblxcdFxcdFxcdHByb3BzID0gdGhpcy5fYXBwbHlDaGFuZ2VzKCk7XFxuXFxuXFx0XFx0XFx0aWYgKCF0aGlzLl9oZWxwZXIgJiYgdGhpcy5fcHJvcG9ydGlvbmFsbHlSZXNpemVFbGVtZW50cy5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9wcm9wb3J0aW9uYWxseVJlc2l6ZSgpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoISQuaXNFbXB0eU9iamVjdChwcm9wcykpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl91cGRhdGVQcmV2UHJvcGVydGllcygpO1xcblxcdFxcdFxcdFxcdHRoaXMuX3RyaWdnZXIoXFxcInJlc2l6ZVxcXCIsIGV2ZW50LCB0aGlzLnVpKCkpO1xcblxcdFxcdFxcdFxcdHRoaXMuX2FwcGx5Q2hhbmdlcygpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfbW91c2VTdG9wOiBmdW5jdGlvbiBfbW91c2VTdG9wKGV2ZW50KSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5yZXNpemluZyA9IGZhbHNlO1xcblxcdFxcdFxcdHZhciBwcixcXG5cXHRcXHRcXHQgICAgaXN0YSxcXG5cXHRcXHRcXHQgICAgc29mZnNldGgsXFxuXFx0XFx0XFx0ICAgIHNvZmZzZXR3LFxcblxcdFxcdFxcdCAgICBzLFxcblxcdFxcdFxcdCAgICBsZWZ0LFxcblxcdFxcdFxcdCAgICB0b3AsXFxuXFx0XFx0XFx0ICAgIG8gPSB0aGlzLm9wdGlvbnMsXFxuXFx0XFx0XFx0ICAgIHRoYXQgPSB0aGlzO1xcblxcblxcdFxcdFxcdGlmICh0aGlzLl9oZWxwZXIpIHtcXG5cXG5cXHRcXHRcXHRcXHRwciA9IHRoaXMuX3Byb3BvcnRpb25hbGx5UmVzaXplRWxlbWVudHM7XFxuXFx0XFx0XFx0XFx0aXN0YSA9IHByLmxlbmd0aCAmJiAvdGV4dGFyZWEvaS50ZXN0KHByWzBdLm5vZGVOYW1lKTtcXG5cXHRcXHRcXHRcXHRzb2Zmc2V0aCA9IGlzdGEgJiYgdGhpcy5faGFzU2Nyb2xsKHByWzBdLCBcXFwibGVmdFxcXCIpID8gMCA6IHRoYXQuc2l6ZURpZmYuaGVpZ2h0O1xcblxcdFxcdFxcdFxcdHNvZmZzZXR3ID0gaXN0YSA/IDAgOiB0aGF0LnNpemVEaWZmLndpZHRoO1xcblxcblxcdFxcdFxcdFxcdHMgPSB7XFxuXFx0XFx0XFx0XFx0XFx0d2lkdGg6IHRoYXQuaGVscGVyLndpZHRoKCkgLSBzb2Zmc2V0dyxcXG5cXHRcXHRcXHRcXHRcXHRoZWlnaHQ6IHRoYXQuaGVscGVyLmhlaWdodCgpIC0gc29mZnNldGhcXG5cXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdFxcdGxlZnQgPSBwYXJzZUludCh0aGF0LmVsZW1lbnQuY3NzKFxcXCJsZWZ0XFxcIiksIDEwKSArICh0aGF0LnBvc2l0aW9uLmxlZnQgLSB0aGF0Lm9yaWdpbmFsUG9zaXRpb24ubGVmdCkgfHwgbnVsbDtcXG5cXHRcXHRcXHRcXHR0b3AgPSBwYXJzZUludCh0aGF0LmVsZW1lbnQuY3NzKFxcXCJ0b3BcXFwiKSwgMTApICsgKHRoYXQucG9zaXRpb24udG9wIC0gdGhhdC5vcmlnaW5hbFBvc2l0aW9uLnRvcCkgfHwgbnVsbDtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIW8uYW5pbWF0ZSkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuZWxlbWVudC5jc3MoJC5leHRlbmQocywgeyB0b3A6IHRvcCwgbGVmdDogbGVmdCB9KSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHRoYXQuaGVscGVyLmhlaWdodCh0aGF0LnNpemUuaGVpZ2h0KTtcXG5cXHRcXHRcXHRcXHR0aGF0LmhlbHBlci53aWR0aCh0aGF0LnNpemUud2lkdGgpO1xcblxcblxcdFxcdFxcdFxcdGlmICh0aGlzLl9oZWxwZXIgJiYgIW8uYW5pbWF0ZSkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX3Byb3BvcnRpb25hbGx5UmVzaXplKCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQkKFxcXCJib2R5XFxcIikuY3NzKFxcXCJjdXJzb3JcXFwiLCBcXFwiYXV0b1xcXCIpO1xcblxcblxcdFxcdFxcdHRoaXMuZWxlbWVudC5yZW1vdmVDbGFzcyhcXFwidWktcmVzaXphYmxlLXJlc2l6aW5nXFxcIik7XFxuXFxuXFx0XFx0XFx0dGhpcy5fcHJvcGFnYXRlKFxcXCJzdG9wXFxcIiwgZXZlbnQpO1xcblxcblxcdFxcdFxcdGlmICh0aGlzLl9oZWxwZXIpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLmhlbHBlci5yZW1vdmUoKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X3VwZGF0ZVByZXZQcm9wZXJ0aWVzOiBmdW5jdGlvbiBfdXBkYXRlUHJldlByb3BlcnRpZXMoKSB7XFxuXFx0XFx0XFx0dGhpcy5wcmV2UG9zaXRpb24gPSB7XFxuXFx0XFx0XFx0XFx0dG9wOiB0aGlzLnBvc2l0aW9uLnRvcCxcXG5cXHRcXHRcXHRcXHRsZWZ0OiB0aGlzLnBvc2l0aW9uLmxlZnRcXG5cXHRcXHRcXHR9O1xcblxcdFxcdFxcdHRoaXMucHJldlNpemUgPSB7XFxuXFx0XFx0XFx0XFx0d2lkdGg6IHRoaXMuc2l6ZS53aWR0aCxcXG5cXHRcXHRcXHRcXHRoZWlnaHQ6IHRoaXMuc2l6ZS5oZWlnaHRcXG5cXHRcXHRcXHR9O1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X2FwcGx5Q2hhbmdlczogZnVuY3Rpb24gX2FwcGx5Q2hhbmdlcygpIHtcXG5cXHRcXHRcXHR2YXIgcHJvcHMgPSB7fTtcXG5cXG5cXHRcXHRcXHRpZiAodGhpcy5wb3NpdGlvbi50b3AgIT09IHRoaXMucHJldlBvc2l0aW9uLnRvcCkge1xcblxcdFxcdFxcdFxcdHByb3BzLnRvcCA9IHRoaXMucG9zaXRpb24udG9wICsgXFxcInB4XFxcIjtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKHRoaXMucG9zaXRpb24ubGVmdCAhPT0gdGhpcy5wcmV2UG9zaXRpb24ubGVmdCkge1xcblxcdFxcdFxcdFxcdHByb3BzLmxlZnQgPSB0aGlzLnBvc2l0aW9uLmxlZnQgKyBcXFwicHhcXFwiO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAodGhpcy5zaXplLndpZHRoICE9PSB0aGlzLnByZXZTaXplLndpZHRoKSB7XFxuXFx0XFx0XFx0XFx0cHJvcHMud2lkdGggPSB0aGlzLnNpemUud2lkdGggKyBcXFwicHhcXFwiO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAodGhpcy5zaXplLmhlaWdodCAhPT0gdGhpcy5wcmV2U2l6ZS5oZWlnaHQpIHtcXG5cXHRcXHRcXHRcXHRwcm9wcy5oZWlnaHQgPSB0aGlzLnNpemUuaGVpZ2h0ICsgXFxcInB4XFxcIjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy5oZWxwZXIuY3NzKHByb3BzKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gcHJvcHM7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfdXBkYXRlVmlydHVhbEJvdW5kYXJpZXM6IGZ1bmN0aW9uIF91cGRhdGVWaXJ0dWFsQm91bmRhcmllcyhmb3JjZUFzcGVjdFJhdGlvKSB7XFxuXFx0XFx0XFx0dmFyIHBNaW5XaWR0aCxcXG5cXHRcXHRcXHQgICAgcE1heFdpZHRoLFxcblxcdFxcdFxcdCAgICBwTWluSGVpZ2h0LFxcblxcdFxcdFxcdCAgICBwTWF4SGVpZ2h0LFxcblxcdFxcdFxcdCAgICBiLFxcblxcdFxcdFxcdCAgICBvID0gdGhpcy5vcHRpb25zO1xcblxcblxcdFxcdFxcdGIgPSB7XFxuXFx0XFx0XFx0XFx0bWluV2lkdGg6IHRoaXMuX2lzTnVtYmVyKG8ubWluV2lkdGgpID8gby5taW5XaWR0aCA6IDAsXFxuXFx0XFx0XFx0XFx0bWF4V2lkdGg6IHRoaXMuX2lzTnVtYmVyKG8ubWF4V2lkdGgpID8gby5tYXhXaWR0aCA6IEluZmluaXR5LFxcblxcdFxcdFxcdFxcdG1pbkhlaWdodDogdGhpcy5faXNOdW1iZXIoby5taW5IZWlnaHQpID8gby5taW5IZWlnaHQgOiAwLFxcblxcdFxcdFxcdFxcdG1heEhlaWdodDogdGhpcy5faXNOdW1iZXIoby5tYXhIZWlnaHQpID8gby5tYXhIZWlnaHQgOiBJbmZpbml0eVxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0XFx0aWYgKHRoaXMuX2FzcGVjdFJhdGlvIHx8IGZvcmNlQXNwZWN0UmF0aW8pIHtcXG5cXHRcXHRcXHRcXHRwTWluV2lkdGggPSBiLm1pbkhlaWdodCAqIHRoaXMuYXNwZWN0UmF0aW87XFxuXFx0XFx0XFx0XFx0cE1pbkhlaWdodCA9IGIubWluV2lkdGggLyB0aGlzLmFzcGVjdFJhdGlvO1xcblxcdFxcdFxcdFxcdHBNYXhXaWR0aCA9IGIubWF4SGVpZ2h0ICogdGhpcy5hc3BlY3RSYXRpbztcXG5cXHRcXHRcXHRcXHRwTWF4SGVpZ2h0ID0gYi5tYXhXaWR0aCAvIHRoaXMuYXNwZWN0UmF0aW87XFxuXFxuXFx0XFx0XFx0XFx0aWYgKHBNaW5XaWR0aCA+IGIubWluV2lkdGgpIHtcXG5cXHRcXHRcXHRcXHRcXHRiLm1pbldpZHRoID0gcE1pbldpZHRoO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRpZiAocE1pbkhlaWdodCA+IGIubWluSGVpZ2h0KSB7XFxuXFx0XFx0XFx0XFx0XFx0Yi5taW5IZWlnaHQgPSBwTWluSGVpZ2h0O1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRpZiAocE1heFdpZHRoIDwgYi5tYXhXaWR0aCkge1xcblxcdFxcdFxcdFxcdFxcdGIubWF4V2lkdGggPSBwTWF4V2lkdGg7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGlmIChwTWF4SGVpZ2h0IDwgYi5tYXhIZWlnaHQpIHtcXG5cXHRcXHRcXHRcXHRcXHRiLm1heEhlaWdodCA9IHBNYXhIZWlnaHQ7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR0aGlzLl92Qm91bmRhcmllcyA9IGI7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfdXBkYXRlQ2FjaGU6IGZ1bmN0aW9uIF91cGRhdGVDYWNoZShkYXRhKSB7XFxuXFx0XFx0XFx0dGhpcy5vZmZzZXQgPSB0aGlzLmhlbHBlci5vZmZzZXQoKTtcXG5cXHRcXHRcXHRpZiAodGhpcy5faXNOdW1iZXIoZGF0YS5sZWZ0KSkge1xcblxcdFxcdFxcdFxcdHRoaXMucG9zaXRpb24ubGVmdCA9IGRhdGEubGVmdDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKHRoaXMuX2lzTnVtYmVyKGRhdGEudG9wKSkge1xcblxcdFxcdFxcdFxcdHRoaXMucG9zaXRpb24udG9wID0gZGF0YS50b3A7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICh0aGlzLl9pc051bWJlcihkYXRhLmhlaWdodCkpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLnNpemUuaGVpZ2h0ID0gZGF0YS5oZWlnaHQ7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICh0aGlzLl9pc051bWJlcihkYXRhLndpZHRoKSkge1xcblxcdFxcdFxcdFxcdHRoaXMuc2l6ZS53aWR0aCA9IGRhdGEud2lkdGg7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFxuXFx0XFx0X3VwZGF0ZVJhdGlvOiBmdW5jdGlvbiBfdXBkYXRlUmF0aW8oZGF0YSkge1xcblxcblxcdFxcdFxcdHZhciBjcG9zID0gdGhpcy5wb3NpdGlvbixcXG5cXHRcXHRcXHQgICAgY3NpemUgPSB0aGlzLnNpemUsXFxuXFx0XFx0XFx0ICAgIGEgPSB0aGlzLmF4aXM7XFxuXFxuXFx0XFx0XFx0aWYgKHRoaXMuX2lzTnVtYmVyKGRhdGEuaGVpZ2h0KSkge1xcblxcdFxcdFxcdFxcdGRhdGEud2lkdGggPSBkYXRhLmhlaWdodCAqIHRoaXMuYXNwZWN0UmF0aW87XFxuXFx0XFx0XFx0fSBlbHNlIGlmICh0aGlzLl9pc051bWJlcihkYXRhLndpZHRoKSkge1xcblxcdFxcdFxcdFxcdGRhdGEuaGVpZ2h0ID0gZGF0YS53aWR0aCAvIHRoaXMuYXNwZWN0UmF0aW87XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmIChhID09PSBcXFwic3dcXFwiKSB7XFxuXFx0XFx0XFx0XFx0ZGF0YS5sZWZ0ID0gY3Bvcy5sZWZ0ICsgKGNzaXplLndpZHRoIC0gZGF0YS53aWR0aCk7XFxuXFx0XFx0XFx0XFx0ZGF0YS50b3AgPSBudWxsO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoYSA9PT0gXFxcIm53XFxcIikge1xcblxcdFxcdFxcdFxcdGRhdGEudG9wID0gY3Bvcy50b3AgKyAoY3NpemUuaGVpZ2h0IC0gZGF0YS5oZWlnaHQpO1xcblxcdFxcdFxcdFxcdGRhdGEubGVmdCA9IGNwb3MubGVmdCArIChjc2l6ZS53aWR0aCAtIGRhdGEud2lkdGgpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gZGF0YTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9yZXNwZWN0U2l6ZTogZnVuY3Rpb24gX3Jlc3BlY3RTaXplKGRhdGEpIHtcXG5cXG5cXHRcXHRcXHR2YXIgbyA9IHRoaXMuX3ZCb3VuZGFyaWVzLFxcblxcdFxcdFxcdCAgICBhID0gdGhpcy5heGlzLFxcblxcdFxcdFxcdCAgICBpc21heHcgPSB0aGlzLl9pc051bWJlcihkYXRhLndpZHRoKSAmJiBvLm1heFdpZHRoICYmIG8ubWF4V2lkdGggPCBkYXRhLndpZHRoLFxcblxcdFxcdFxcdCAgICBpc21heGggPSB0aGlzLl9pc051bWJlcihkYXRhLmhlaWdodCkgJiYgby5tYXhIZWlnaHQgJiYgby5tYXhIZWlnaHQgPCBkYXRhLmhlaWdodCxcXG5cXHRcXHRcXHQgICAgaXNtaW53ID0gdGhpcy5faXNOdW1iZXIoZGF0YS53aWR0aCkgJiYgby5taW5XaWR0aCAmJiBvLm1pbldpZHRoID4gZGF0YS53aWR0aCxcXG5cXHRcXHRcXHQgICAgaXNtaW5oID0gdGhpcy5faXNOdW1iZXIoZGF0YS5oZWlnaHQpICYmIG8ubWluSGVpZ2h0ICYmIG8ubWluSGVpZ2h0ID4gZGF0YS5oZWlnaHQsXFxuXFx0XFx0XFx0ICAgIGR3ID0gdGhpcy5vcmlnaW5hbFBvc2l0aW9uLmxlZnQgKyB0aGlzLm9yaWdpbmFsU2l6ZS53aWR0aCxcXG5cXHRcXHRcXHQgICAgZGggPSB0aGlzLnBvc2l0aW9uLnRvcCArIHRoaXMuc2l6ZS5oZWlnaHQsXFxuXFx0XFx0XFx0ICAgIGN3ID0gL3N3fG53fHcvLnRlc3QoYSksXFxuXFx0XFx0XFx0ICAgIGNoID0gL253fG5lfG4vLnRlc3QoYSk7XFxuXFx0XFx0XFx0aWYgKGlzbWludykge1xcblxcdFxcdFxcdFxcdGRhdGEud2lkdGggPSBvLm1pbldpZHRoO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoaXNtaW5oKSB7XFxuXFx0XFx0XFx0XFx0ZGF0YS5oZWlnaHQgPSBvLm1pbkhlaWdodDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKGlzbWF4dykge1xcblxcdFxcdFxcdFxcdGRhdGEud2lkdGggPSBvLm1heFdpZHRoO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoaXNtYXhoKSB7XFxuXFx0XFx0XFx0XFx0ZGF0YS5oZWlnaHQgPSBvLm1heEhlaWdodDtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKGlzbWludyAmJiBjdykge1xcblxcdFxcdFxcdFxcdGRhdGEubGVmdCA9IGR3IC0gby5taW5XaWR0aDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKGlzbWF4dyAmJiBjdykge1xcblxcdFxcdFxcdFxcdGRhdGEubGVmdCA9IGR3IC0gby5tYXhXaWR0aDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKGlzbWluaCAmJiBjaCkge1xcblxcdFxcdFxcdFxcdGRhdGEudG9wID0gZGggLSBvLm1pbkhlaWdodDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKGlzbWF4aCAmJiBjaCkge1xcblxcdFxcdFxcdFxcdGRhdGEudG9wID0gZGggLSBvLm1heEhlaWdodDtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gRml4aW5nIGp1bXAgZXJyb3Igb24gdG9wL2xlZnQgLSBidWcgIzIzMzBcXG5cXHRcXHRcXHRpZiAoIWRhdGEud2lkdGggJiYgIWRhdGEuaGVpZ2h0ICYmICFkYXRhLmxlZnQgJiYgZGF0YS50b3ApIHtcXG5cXHRcXHRcXHRcXHRkYXRhLnRvcCA9IG51bGw7XFxuXFx0XFx0XFx0fSBlbHNlIGlmICghZGF0YS53aWR0aCAmJiAhZGF0YS5oZWlnaHQgJiYgIWRhdGEudG9wICYmIGRhdGEubGVmdCkge1xcblxcdFxcdFxcdFxcdGRhdGEubGVmdCA9IG51bGw7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBkYXRhO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X2dldFBhZGRpbmdQbHVzQm9yZGVyRGltZW5zaW9uczogZnVuY3Rpb24gX2dldFBhZGRpbmdQbHVzQm9yZGVyRGltZW5zaW9ucyhlbGVtZW50KSB7XFxuXFx0XFx0XFx0dmFyIGkgPSAwLFxcblxcdFxcdFxcdCAgICB3aWR0aHMgPSBbXSxcXG5cXHRcXHRcXHQgICAgYm9yZGVycyA9IFtlbGVtZW50LmNzcyhcXFwiYm9yZGVyVG9wV2lkdGhcXFwiKSwgZWxlbWVudC5jc3MoXFxcImJvcmRlclJpZ2h0V2lkdGhcXFwiKSwgZWxlbWVudC5jc3MoXFxcImJvcmRlckJvdHRvbVdpZHRoXFxcIiksIGVsZW1lbnQuY3NzKFxcXCJib3JkZXJMZWZ0V2lkdGhcXFwiKV0sXFxuXFx0XFx0XFx0ICAgIHBhZGRpbmdzID0gW2VsZW1lbnQuY3NzKFxcXCJwYWRkaW5nVG9wXFxcIiksIGVsZW1lbnQuY3NzKFxcXCJwYWRkaW5nUmlnaHRcXFwiKSwgZWxlbWVudC5jc3MoXFxcInBhZGRpbmdCb3R0b21cXFwiKSwgZWxlbWVudC5jc3MoXFxcInBhZGRpbmdMZWZ0XFxcIildO1xcblxcblxcdFxcdFxcdGZvciAoOyBpIDwgNDsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0d2lkdGhzW2ldID0gcGFyc2VJbnQoYm9yZGVyc1tpXSwgMTApIHx8IDA7XFxuXFx0XFx0XFx0XFx0d2lkdGhzW2ldICs9IHBhcnNlSW50KHBhZGRpbmdzW2ldLCAxMCkgfHwgMDtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHtcXG5cXHRcXHRcXHRcXHRoZWlnaHQ6IHdpZHRoc1swXSArIHdpZHRoc1syXSxcXG5cXHRcXHRcXHRcXHR3aWR0aDogd2lkdGhzWzFdICsgd2lkdGhzWzNdXFxuXFx0XFx0XFx0fTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9wcm9wb3J0aW9uYWxseVJlc2l6ZTogZnVuY3Rpb24gX3Byb3BvcnRpb25hbGx5UmVzaXplKCkge1xcblxcblxcdFxcdFxcdGlmICghdGhpcy5fcHJvcG9ydGlvbmFsbHlSZXNpemVFbGVtZW50cy5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHZhciBwcmVsLFxcblxcdFxcdFxcdCAgICBpID0gMCxcXG5cXHRcXHRcXHQgICAgZWxlbWVudCA9IHRoaXMuaGVscGVyIHx8IHRoaXMuZWxlbWVudDtcXG5cXG5cXHRcXHRcXHRmb3IgKDsgaSA8IHRoaXMuX3Byb3BvcnRpb25hbGx5UmVzaXplRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcXG5cXG5cXHRcXHRcXHRcXHRwcmVsID0gdGhpcy5fcHJvcG9ydGlvbmFsbHlSZXNpemVFbGVtZW50c1tpXTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBUT0RPOiBTZWVtcyBsaWtlIGEgYnVnIHRvIGNhY2hlIHRoaXMub3V0ZXJEaW1lbnNpb25zXFxuXFx0XFx0XFx0XFx0Ly8gY29uc2lkZXJpbmcgdGhhdCB3ZSBhcmUgaW4gYSBsb29wLlxcblxcdFxcdFxcdFxcdGlmICghdGhpcy5vdXRlckRpbWVuc2lvbnMpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLm91dGVyRGltZW5zaW9ucyA9IHRoaXMuX2dldFBhZGRpbmdQbHVzQm9yZGVyRGltZW5zaW9ucyhwcmVsKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0cHJlbC5jc3Moe1xcblxcdFxcdFxcdFxcdFxcdGhlaWdodDogZWxlbWVudC5oZWlnaHQoKSAtIHRoaXMub3V0ZXJEaW1lbnNpb25zLmhlaWdodCB8fCAwLFxcblxcdFxcdFxcdFxcdFxcdHdpZHRoOiBlbGVtZW50LndpZHRoKCkgLSB0aGlzLm91dGVyRGltZW5zaW9ucy53aWR0aCB8fCAwXFxuXFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFxuXFx0XFx0X3JlbmRlclByb3h5OiBmdW5jdGlvbiBfcmVuZGVyUHJveHkoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGVsID0gdGhpcy5lbGVtZW50LFxcblxcdFxcdFxcdCAgICBvID0gdGhpcy5vcHRpb25zO1xcblxcdFxcdFxcdHRoaXMuZWxlbWVudE9mZnNldCA9IGVsLm9mZnNldCgpO1xcblxcblxcdFxcdFxcdGlmICh0aGlzLl9oZWxwZXIpIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLmhlbHBlciA9IHRoaXMuaGVscGVyIHx8ICQoXFxcIjxkaXYgc3R5bGU9J292ZXJmbG93OmhpZGRlbjsnPjwvZGl2PlxcXCIpO1xcblxcblxcdFxcdFxcdFxcdHRoaXMuaGVscGVyLmFkZENsYXNzKHRoaXMuX2hlbHBlcikuY3NzKHtcXG5cXHRcXHRcXHRcXHRcXHR3aWR0aDogdGhpcy5lbGVtZW50Lm91dGVyV2lkdGgoKSAtIDEsXFxuXFx0XFx0XFx0XFx0XFx0aGVpZ2h0OiB0aGlzLmVsZW1lbnQub3V0ZXJIZWlnaHQoKSAtIDEsXFxuXFx0XFx0XFx0XFx0XFx0cG9zaXRpb246IFxcXCJhYnNvbHV0ZVxcXCIsXFxuXFx0XFx0XFx0XFx0XFx0bGVmdDogdGhpcy5lbGVtZW50T2Zmc2V0LmxlZnQgKyBcXFwicHhcXFwiLFxcblxcdFxcdFxcdFxcdFxcdHRvcDogdGhpcy5lbGVtZW50T2Zmc2V0LnRvcCArIFxcXCJweFxcXCIsXFxuXFx0XFx0XFx0XFx0XFx0ekluZGV4OiArK28uekluZGV4IC8vVE9ETzogRG9uJ3QgbW9kaWZ5IG9wdGlvblxcblxcdFxcdFxcdFxcdH0pO1xcblxcblxcdFxcdFxcdFxcdHRoaXMuaGVscGVyLmFwcGVuZFRvKFxcXCJib2R5XFxcIikuZGlzYWJsZVNlbGVjdGlvbigpO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5oZWxwZXIgPSB0aGlzLmVsZW1lbnQ7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFxuXFx0XFx0X2NoYW5nZToge1xcblxcdFxcdFxcdGU6IGZ1bmN0aW9uIGUoZXZlbnQsIGR4KSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHsgd2lkdGg6IHRoaXMub3JpZ2luYWxTaXplLndpZHRoICsgZHggfTtcXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdHc6IGZ1bmN0aW9uIHcoZXZlbnQsIGR4KSB7XFxuXFx0XFx0XFx0XFx0dmFyIGNzID0gdGhpcy5vcmlnaW5hbFNpemUsXFxuXFx0XFx0XFx0XFx0ICAgIHNwID0gdGhpcy5vcmlnaW5hbFBvc2l0aW9uO1xcblxcdFxcdFxcdFxcdHJldHVybiB7IGxlZnQ6IHNwLmxlZnQgKyBkeCwgd2lkdGg6IGNzLndpZHRoIC0gZHggfTtcXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdG46IGZ1bmN0aW9uIG4oZXZlbnQsIGR4LCBkeSkge1xcblxcdFxcdFxcdFxcdHZhciBjcyA9IHRoaXMub3JpZ2luYWxTaXplLFxcblxcdFxcdFxcdFxcdCAgICBzcCA9IHRoaXMub3JpZ2luYWxQb3NpdGlvbjtcXG5cXHRcXHRcXHRcXHRyZXR1cm4geyB0b3A6IHNwLnRvcCArIGR5LCBoZWlnaHQ6IGNzLmhlaWdodCAtIGR5IH07XFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRzOiBmdW5jdGlvbiBzKGV2ZW50LCBkeCwgZHkpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4geyBoZWlnaHQ6IHRoaXMub3JpZ2luYWxTaXplLmhlaWdodCArIGR5IH07XFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRzZTogZnVuY3Rpb24gc2UoZXZlbnQsIGR4LCBkeSkge1xcblxcdFxcdFxcdFxcdHJldHVybiAkLmV4dGVuZCh0aGlzLl9jaGFuZ2Uucy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCB0aGlzLl9jaGFuZ2UuZS5hcHBseSh0aGlzLCBbZXZlbnQsIGR4LCBkeV0pKTtcXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdHN3OiBmdW5jdGlvbiBzdyhldmVudCwgZHgsIGR5KSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuICQuZXh0ZW5kKHRoaXMuX2NoYW5nZS5zLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHRoaXMuX2NoYW5nZS53LmFwcGx5KHRoaXMsIFtldmVudCwgZHgsIGR5XSkpO1xcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0bmU6IGZ1bmN0aW9uIG5lKGV2ZW50LCBkeCwgZHkpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gJC5leHRlbmQodGhpcy5fY2hhbmdlLm4uYXBwbHkodGhpcywgYXJndW1lbnRzKSwgdGhpcy5fY2hhbmdlLmUuYXBwbHkodGhpcywgW2V2ZW50LCBkeCwgZHldKSk7XFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRudzogZnVuY3Rpb24gbncoZXZlbnQsIGR4LCBkeSkge1xcblxcdFxcdFxcdFxcdHJldHVybiAkLmV4dGVuZCh0aGlzLl9jaGFuZ2Uubi5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCB0aGlzLl9jaGFuZ2Uudy5hcHBseSh0aGlzLCBbZXZlbnQsIGR4LCBkeV0pKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfcHJvcGFnYXRlOiBmdW5jdGlvbiBfcHJvcGFnYXRlKG4sIGV2ZW50KSB7XFxuXFx0XFx0XFx0JC51aS5wbHVnaW4uY2FsbCh0aGlzLCBuLCBbZXZlbnQsIHRoaXMudWkoKV0pO1xcblxcdFxcdFxcdG4gIT09IFxcXCJyZXNpemVcXFwiICYmIHRoaXMuX3RyaWdnZXIobiwgZXZlbnQsIHRoaXMudWkoKSk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRwbHVnaW5zOiB7fSxcXG5cXG5cXHRcXHR1aTogZnVuY3Rpb24gdWkoKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHtcXG5cXHRcXHRcXHRcXHRvcmlnaW5hbEVsZW1lbnQ6IHRoaXMub3JpZ2luYWxFbGVtZW50LFxcblxcdFxcdFxcdFxcdGVsZW1lbnQ6IHRoaXMuZWxlbWVudCxcXG5cXHRcXHRcXHRcXHRoZWxwZXI6IHRoaXMuaGVscGVyLFxcblxcdFxcdFxcdFxcdHBvc2l0aW9uOiB0aGlzLnBvc2l0aW9uLFxcblxcdFxcdFxcdFxcdHNpemU6IHRoaXMuc2l6ZSxcXG5cXHRcXHRcXHRcXHRvcmlnaW5hbFNpemU6IHRoaXMub3JpZ2luYWxTaXplLFxcblxcdFxcdFxcdFxcdG9yaWdpbmFsUG9zaXRpb246IHRoaXMub3JpZ2luYWxQb3NpdGlvblxcblxcdFxcdFxcdH07XFxuXFx0XFx0fVxcblxcblxcdH0pO1xcblxcblxcdC8qXFxuICAqIFJlc2l6YWJsZSBFeHRlbnNpb25zXFxuICAqL1xcblxcblxcdCQudWkucGx1Z2luLmFkZChcXFwicmVzaXphYmxlXFxcIiwgXFxcImFuaW1hdGVcXFwiLCB7XFxuXFxuXFx0XFx0c3RvcDogZnVuY3Rpb24gc3RvcChldmVudCkge1xcblxcdFxcdFxcdHZhciB0aGF0ID0gJCh0aGlzKS5yZXNpemFibGUoXFxcImluc3RhbmNlXFxcIiksXFxuXFx0XFx0XFx0ICAgIG8gPSB0aGF0Lm9wdGlvbnMsXFxuXFx0XFx0XFx0ICAgIHByID0gdGhhdC5fcHJvcG9ydGlvbmFsbHlSZXNpemVFbGVtZW50cyxcXG5cXHRcXHRcXHQgICAgaXN0YSA9IHByLmxlbmd0aCAmJiAvdGV4dGFyZWEvaS50ZXN0KHByWzBdLm5vZGVOYW1lKSxcXG5cXHRcXHRcXHQgICAgc29mZnNldGggPSBpc3RhICYmIHRoYXQuX2hhc1Njcm9sbChwclswXSwgXFxcImxlZnRcXFwiKSA/IDAgOiB0aGF0LnNpemVEaWZmLmhlaWdodCxcXG5cXHRcXHRcXHQgICAgc29mZnNldHcgPSBpc3RhID8gMCA6IHRoYXQuc2l6ZURpZmYud2lkdGgsXFxuXFx0XFx0XFx0ICAgIHN0eWxlID0geyB3aWR0aDogdGhhdC5zaXplLndpZHRoIC0gc29mZnNldHcsIGhlaWdodDogdGhhdC5zaXplLmhlaWdodCAtIHNvZmZzZXRoIH0sXFxuXFx0XFx0XFx0ICAgIGxlZnQgPSBwYXJzZUludCh0aGF0LmVsZW1lbnQuY3NzKFxcXCJsZWZ0XFxcIiksIDEwKSArICh0aGF0LnBvc2l0aW9uLmxlZnQgLSB0aGF0Lm9yaWdpbmFsUG9zaXRpb24ubGVmdCkgfHwgbnVsbCxcXG5cXHRcXHRcXHQgICAgdG9wID0gcGFyc2VJbnQodGhhdC5lbGVtZW50LmNzcyhcXFwidG9wXFxcIiksIDEwKSArICh0aGF0LnBvc2l0aW9uLnRvcCAtIHRoYXQub3JpZ2luYWxQb3NpdGlvbi50b3ApIHx8IG51bGw7XFxuXFxuXFx0XFx0XFx0dGhhdC5lbGVtZW50LmFuaW1hdGUoJC5leHRlbmQoc3R5bGUsIHRvcCAmJiBsZWZ0ID8geyB0b3A6IHRvcCwgbGVmdDogbGVmdCB9IDoge30pLCB7XFxuXFx0XFx0XFx0XFx0ZHVyYXRpb246IG8uYW5pbWF0ZUR1cmF0aW9uLFxcblxcdFxcdFxcdFxcdGVhc2luZzogby5hbmltYXRlRWFzaW5nLFxcblxcdFxcdFxcdFxcdHN0ZXA6IGZ1bmN0aW9uIHN0ZXAoKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGRhdGEgPSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0d2lkdGg6IHBhcnNlSW50KHRoYXQuZWxlbWVudC5jc3MoXFxcIndpZHRoXFxcIiksIDEwKSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRoZWlnaHQ6IHBhcnNlSW50KHRoYXQuZWxlbWVudC5jc3MoXFxcImhlaWdodFxcXCIpLCAxMCksXFxuXFx0XFx0XFx0XFx0XFx0XFx0dG9wOiBwYXJzZUludCh0aGF0LmVsZW1lbnQuY3NzKFxcXCJ0b3BcXFwiKSwgMTApLFxcblxcdFxcdFxcdFxcdFxcdFxcdGxlZnQ6IHBhcnNlSW50KHRoYXQuZWxlbWVudC5jc3MoXFxcImxlZnRcXFwiKSwgMTApXFxuXFx0XFx0XFx0XFx0XFx0fTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAocHIgJiYgcHIubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0JChwclswXSkuY3NzKHsgd2lkdGg6IGRhdGEud2lkdGgsIGhlaWdodDogZGF0YS5oZWlnaHQgfSk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdC8vIHByb3BhZ2F0aW5nIHJlc2l6ZSwgYW5kIHVwZGF0aW5nIHZhbHVlcyBmb3IgZWFjaCBhbmltYXRpb24gc3RlcFxcblxcdFxcdFxcdFxcdFxcdHRoYXQuX3VwZGF0ZUNhY2hlKGRhdGEpO1xcblxcdFxcdFxcdFxcdFxcdHRoYXQuX3Byb3BhZ2F0ZShcXFwicmVzaXplXFxcIiwgZXZlbnQpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHR9XFxuXFxuXFx0fSk7XFxuXFxuXFx0JC51aS5wbHVnaW4uYWRkKFxcXCJyZXNpemFibGVcXFwiLCBcXFwiY29udGFpbm1lbnRcXFwiLCB7XFxuXFxuXFx0XFx0c3RhcnQ6IGZ1bmN0aW9uIHN0YXJ0KCkge1xcblxcdFxcdFxcdHZhciBlbGVtZW50LFxcblxcdFxcdFxcdCAgICBwLFxcblxcdFxcdFxcdCAgICBjbyxcXG5cXHRcXHRcXHQgICAgY2gsXFxuXFx0XFx0XFx0ICAgIGN3LFxcblxcdFxcdFxcdCAgICB3aWR0aCxcXG5cXHRcXHRcXHQgICAgaGVpZ2h0LFxcblxcdFxcdFxcdCAgICB0aGF0ID0gJCh0aGlzKS5yZXNpemFibGUoXFxcImluc3RhbmNlXFxcIiksXFxuXFx0XFx0XFx0ICAgIG8gPSB0aGF0Lm9wdGlvbnMsXFxuXFx0XFx0XFx0ICAgIGVsID0gdGhhdC5lbGVtZW50LFxcblxcdFxcdFxcdCAgICBvYyA9IG8uY29udGFpbm1lbnQsXFxuXFx0XFx0XFx0ICAgIGNlID0gb2MgaW5zdGFuY2VvZiAkID8gb2MuZ2V0KDApIDogL3BhcmVudC8udGVzdChvYykgPyBlbC5wYXJlbnQoKS5nZXQoMCkgOiBvYztcXG5cXG5cXHRcXHRcXHRpZiAoIWNlKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGF0LmNvbnRhaW5lckVsZW1lbnQgPSAkKGNlKTtcXG5cXG5cXHRcXHRcXHRpZiAoL2RvY3VtZW50Ly50ZXN0KG9jKSB8fCBvYyA9PT0gZG9jdW1lbnQpIHtcXG5cXHRcXHRcXHRcXHR0aGF0LmNvbnRhaW5lck9mZnNldCA9IHtcXG5cXHRcXHRcXHRcXHRcXHRsZWZ0OiAwLFxcblxcdFxcdFxcdFxcdFxcdHRvcDogMFxcblxcdFxcdFxcdFxcdH07XFxuXFx0XFx0XFx0XFx0dGhhdC5jb250YWluZXJQb3NpdGlvbiA9IHtcXG5cXHRcXHRcXHRcXHRcXHRsZWZ0OiAwLFxcblxcdFxcdFxcdFxcdFxcdHRvcDogMFxcblxcdFxcdFxcdFxcdH07XFxuXFxuXFx0XFx0XFx0XFx0dGhhdC5wYXJlbnREYXRhID0ge1xcblxcdFxcdFxcdFxcdFxcdGVsZW1lbnQ6ICQoZG9jdW1lbnQpLFxcblxcdFxcdFxcdFxcdFxcdGxlZnQ6IDAsXFxuXFx0XFx0XFx0XFx0XFx0dG9wOiAwLFxcblxcdFxcdFxcdFxcdFxcdHdpZHRoOiAkKGRvY3VtZW50KS53aWR0aCgpLFxcblxcdFxcdFxcdFxcdFxcdGhlaWdodDogJChkb2N1bWVudCkuaGVpZ2h0KCkgfHwgZG9jdW1lbnQuYm9keS5wYXJlbnROb2RlLnNjcm9sbEhlaWdodFxcblxcdFxcdFxcdFxcdH07XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRlbGVtZW50ID0gJChjZSk7XFxuXFx0XFx0XFx0XFx0cCA9IFtdO1xcblxcdFxcdFxcdFxcdCQoW1xcXCJUb3BcXFwiLCBcXFwiUmlnaHRcXFwiLCBcXFwiTGVmdFxcXCIsIFxcXCJCb3R0b21cXFwiXSkuZWFjaChmdW5jdGlvbiAoaSwgbmFtZSkge1xcblxcdFxcdFxcdFxcdFxcdHBbaV0gPSB0aGF0Ll9udW0oZWxlbWVudC5jc3MoXFxcInBhZGRpbmdcXFwiICsgbmFtZSkpO1xcblxcdFxcdFxcdFxcdH0pO1xcblxcblxcdFxcdFxcdFxcdHRoYXQuY29udGFpbmVyT2Zmc2V0ID0gZWxlbWVudC5vZmZzZXQoKTtcXG5cXHRcXHRcXHRcXHR0aGF0LmNvbnRhaW5lclBvc2l0aW9uID0gZWxlbWVudC5wb3NpdGlvbigpO1xcblxcdFxcdFxcdFxcdHRoYXQuY29udGFpbmVyU2l6ZSA9IHtcXG5cXHRcXHRcXHRcXHRcXHRoZWlnaHQ6IGVsZW1lbnQuaW5uZXJIZWlnaHQoKSAtIHBbM10sXFxuXFx0XFx0XFx0XFx0XFx0d2lkdGg6IGVsZW1lbnQuaW5uZXJXaWR0aCgpIC0gcFsxXVxcblxcdFxcdFxcdFxcdH07XFxuXFxuXFx0XFx0XFx0XFx0Y28gPSB0aGF0LmNvbnRhaW5lck9mZnNldDtcXG5cXHRcXHRcXHRcXHRjaCA9IHRoYXQuY29udGFpbmVyU2l6ZS5oZWlnaHQ7XFxuXFx0XFx0XFx0XFx0Y3cgPSB0aGF0LmNvbnRhaW5lclNpemUud2lkdGg7XFxuXFx0XFx0XFx0XFx0d2lkdGggPSB0aGF0Ll9oYXNTY3JvbGwoY2UsIFxcXCJsZWZ0XFxcIikgPyBjZS5zY3JvbGxXaWR0aCA6IGN3O1xcblxcdFxcdFxcdFxcdGhlaWdodCA9IHRoYXQuX2hhc1Njcm9sbChjZSkgPyBjZS5zY3JvbGxIZWlnaHQgOiBjaDtcXG5cXG5cXHRcXHRcXHRcXHR0aGF0LnBhcmVudERhdGEgPSB7XFxuXFx0XFx0XFx0XFx0XFx0ZWxlbWVudDogY2UsXFxuXFx0XFx0XFx0XFx0XFx0bGVmdDogY28ubGVmdCxcXG5cXHRcXHRcXHRcXHRcXHR0b3A6IGNvLnRvcCxcXG5cXHRcXHRcXHRcXHRcXHR3aWR0aDogd2lkdGgsXFxuXFx0XFx0XFx0XFx0XFx0aGVpZ2h0OiBoZWlnaHRcXG5cXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcblxcdFxcdHJlc2l6ZTogZnVuY3Rpb24gcmVzaXplKGV2ZW50KSB7XFxuXFx0XFx0XFx0dmFyIHdvc2V0LFxcblxcdFxcdFxcdCAgICBob3NldCxcXG5cXHRcXHRcXHQgICAgaXNQYXJlbnQsXFxuXFx0XFx0XFx0ICAgIGlzT2Zmc2V0UmVsYXRpdmUsXFxuXFx0XFx0XFx0ICAgIHRoYXQgPSAkKHRoaXMpLnJlc2l6YWJsZShcXFwiaW5zdGFuY2VcXFwiKSxcXG5cXHRcXHRcXHQgICAgbyA9IHRoYXQub3B0aW9ucyxcXG5cXHRcXHRcXHQgICAgY28gPSB0aGF0LmNvbnRhaW5lck9mZnNldCxcXG5cXHRcXHRcXHQgICAgY3AgPSB0aGF0LnBvc2l0aW9uLFxcblxcdFxcdFxcdCAgICBwUmF0aW8gPSB0aGF0Ll9hc3BlY3RSYXRpbyB8fCBldmVudC5zaGlmdEtleSxcXG5cXHRcXHRcXHQgICAgY29wID0ge1xcblxcdFxcdFxcdFxcdHRvcDogMCxcXG5cXHRcXHRcXHRcXHRsZWZ0OiAwXFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHQgICAgY2UgPSB0aGF0LmNvbnRhaW5lckVsZW1lbnQsXFxuXFx0XFx0XFx0ICAgIGNvbnRpbnVlUmVzaXplID0gdHJ1ZTtcXG5cXG5cXHRcXHRcXHRpZiAoY2VbMF0gIT09IGRvY3VtZW50ICYmIC9zdGF0aWMvLnRlc3QoY2UuY3NzKFxcXCJwb3NpdGlvblxcXCIpKSkge1xcblxcdFxcdFxcdFxcdGNvcCA9IGNvO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoY3AubGVmdCA8ICh0aGF0Ll9oZWxwZXIgPyBjby5sZWZ0IDogMCkpIHtcXG5cXHRcXHRcXHRcXHR0aGF0LnNpemUud2lkdGggPSB0aGF0LnNpemUud2lkdGggKyAodGhhdC5faGVscGVyID8gdGhhdC5wb3NpdGlvbi5sZWZ0IC0gY28ubGVmdCA6IHRoYXQucG9zaXRpb24ubGVmdCAtIGNvcC5sZWZ0KTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAocFJhdGlvKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhhdC5zaXplLmhlaWdodCA9IHRoYXQuc2l6ZS53aWR0aCAvIHRoYXQuYXNwZWN0UmF0aW87XFxuXFx0XFx0XFx0XFx0XFx0Y29udGludWVSZXNpemUgPSBmYWxzZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0dGhhdC5wb3NpdGlvbi5sZWZ0ID0gby5oZWxwZXIgPyBjby5sZWZ0IDogMDtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKGNwLnRvcCA8ICh0aGF0Ll9oZWxwZXIgPyBjby50b3AgOiAwKSkge1xcblxcdFxcdFxcdFxcdHRoYXQuc2l6ZS5oZWlnaHQgPSB0aGF0LnNpemUuaGVpZ2h0ICsgKHRoYXQuX2hlbHBlciA/IHRoYXQucG9zaXRpb24udG9wIC0gY28udG9wIDogdGhhdC5wb3NpdGlvbi50b3ApO1xcblxcblxcdFxcdFxcdFxcdGlmIChwUmF0aW8pIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGF0LnNpemUud2lkdGggPSB0aGF0LnNpemUuaGVpZ2h0ICogdGhhdC5hc3BlY3RSYXRpbztcXG5cXHRcXHRcXHRcXHRcXHRjb250aW51ZVJlc2l6ZSA9IGZhbHNlO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR0aGF0LnBvc2l0aW9uLnRvcCA9IHRoYXQuX2hlbHBlciA/IGNvLnRvcCA6IDA7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlzUGFyZW50ID0gdGhhdC5jb250YWluZXJFbGVtZW50LmdldCgwKSA9PT0gdGhhdC5lbGVtZW50LnBhcmVudCgpLmdldCgwKTtcXG5cXHRcXHRcXHRpc09mZnNldFJlbGF0aXZlID0gL3JlbGF0aXZlfGFic29sdXRlLy50ZXN0KHRoYXQuY29udGFpbmVyRWxlbWVudC5jc3MoXFxcInBvc2l0aW9uXFxcIikpO1xcblxcblxcdFxcdFxcdGlmIChpc1BhcmVudCAmJiBpc09mZnNldFJlbGF0aXZlKSB7XFxuXFx0XFx0XFx0XFx0dGhhdC5vZmZzZXQubGVmdCA9IHRoYXQucGFyZW50RGF0YS5sZWZ0ICsgdGhhdC5wb3NpdGlvbi5sZWZ0O1xcblxcdFxcdFxcdFxcdHRoYXQub2Zmc2V0LnRvcCA9IHRoYXQucGFyZW50RGF0YS50b3AgKyB0aGF0LnBvc2l0aW9uLnRvcDtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdHRoYXQub2Zmc2V0LmxlZnQgPSB0aGF0LmVsZW1lbnQub2Zmc2V0KCkubGVmdDtcXG5cXHRcXHRcXHRcXHR0aGF0Lm9mZnNldC50b3AgPSB0aGF0LmVsZW1lbnQub2Zmc2V0KCkudG9wO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR3b3NldCA9IE1hdGguYWJzKHRoYXQuc2l6ZURpZmYud2lkdGggKyAodGhhdC5faGVscGVyID8gdGhhdC5vZmZzZXQubGVmdCAtIGNvcC5sZWZ0IDogdGhhdC5vZmZzZXQubGVmdCAtIGNvLmxlZnQpKTtcXG5cXG5cXHRcXHRcXHRob3NldCA9IE1hdGguYWJzKHRoYXQuc2l6ZURpZmYuaGVpZ2h0ICsgKHRoYXQuX2hlbHBlciA/IHRoYXQub2Zmc2V0LnRvcCAtIGNvcC50b3AgOiB0aGF0Lm9mZnNldC50b3AgLSBjby50b3ApKTtcXG5cXG5cXHRcXHRcXHRpZiAod29zZXQgKyB0aGF0LnNpemUud2lkdGggPj0gdGhhdC5wYXJlbnREYXRhLndpZHRoKSB7XFxuXFx0XFx0XFx0XFx0dGhhdC5zaXplLndpZHRoID0gdGhhdC5wYXJlbnREYXRhLndpZHRoIC0gd29zZXQ7XFxuXFx0XFx0XFx0XFx0aWYgKHBSYXRpbykge1xcblxcdFxcdFxcdFxcdFxcdHRoYXQuc2l6ZS5oZWlnaHQgPSB0aGF0LnNpemUud2lkdGggLyB0aGF0LmFzcGVjdFJhdGlvO1xcblxcdFxcdFxcdFxcdFxcdGNvbnRpbnVlUmVzaXplID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoaG9zZXQgKyB0aGF0LnNpemUuaGVpZ2h0ID49IHRoYXQucGFyZW50RGF0YS5oZWlnaHQpIHtcXG5cXHRcXHRcXHRcXHR0aGF0LnNpemUuaGVpZ2h0ID0gdGhhdC5wYXJlbnREYXRhLmhlaWdodCAtIGhvc2V0O1xcblxcdFxcdFxcdFxcdGlmIChwUmF0aW8pIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGF0LnNpemUud2lkdGggPSB0aGF0LnNpemUuaGVpZ2h0ICogdGhhdC5hc3BlY3RSYXRpbztcXG5cXHRcXHRcXHRcXHRcXHRjb250aW51ZVJlc2l6ZSA9IGZhbHNlO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCFjb250aW51ZVJlc2l6ZSkge1xcblxcdFxcdFxcdFxcdHRoYXQucG9zaXRpb24ubGVmdCA9IHRoYXQucHJldlBvc2l0aW9uLmxlZnQ7XFxuXFx0XFx0XFx0XFx0dGhhdC5wb3NpdGlvbi50b3AgPSB0aGF0LnByZXZQb3NpdGlvbi50b3A7XFxuXFx0XFx0XFx0XFx0dGhhdC5zaXplLndpZHRoID0gdGhhdC5wcmV2U2l6ZS53aWR0aDtcXG5cXHRcXHRcXHRcXHR0aGF0LnNpemUuaGVpZ2h0ID0gdGhhdC5wcmV2U2l6ZS5oZWlnaHQ7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c3RvcDogZnVuY3Rpb24gc3RvcCgpIHtcXG5cXHRcXHRcXHR2YXIgdGhhdCA9ICQodGhpcykucmVzaXphYmxlKFxcXCJpbnN0YW5jZVxcXCIpLFxcblxcdFxcdFxcdCAgICBvID0gdGhhdC5vcHRpb25zLFxcblxcdFxcdFxcdCAgICBjbyA9IHRoYXQuY29udGFpbmVyT2Zmc2V0LFxcblxcdFxcdFxcdCAgICBjb3AgPSB0aGF0LmNvbnRhaW5lclBvc2l0aW9uLFxcblxcdFxcdFxcdCAgICBjZSA9IHRoYXQuY29udGFpbmVyRWxlbWVudCxcXG5cXHRcXHRcXHQgICAgaGVscGVyID0gJCh0aGF0LmhlbHBlciksXFxuXFx0XFx0XFx0ICAgIGhvID0gaGVscGVyLm9mZnNldCgpLFxcblxcdFxcdFxcdCAgICB3ID0gaGVscGVyLm91dGVyV2lkdGgoKSAtIHRoYXQuc2l6ZURpZmYud2lkdGgsXFxuXFx0XFx0XFx0ICAgIGggPSBoZWxwZXIub3V0ZXJIZWlnaHQoKSAtIHRoYXQuc2l6ZURpZmYuaGVpZ2h0O1xcblxcblxcdFxcdFxcdGlmICh0aGF0Ll9oZWxwZXIgJiYgIW8uYW5pbWF0ZSAmJiAvcmVsYXRpdmUvLnRlc3QoY2UuY3NzKFxcXCJwb3NpdGlvblxcXCIpKSkge1xcblxcdFxcdFxcdFxcdCQodGhpcykuY3NzKHtcXG5cXHRcXHRcXHRcXHRcXHRsZWZ0OiBoby5sZWZ0IC0gY29wLmxlZnQgLSBjby5sZWZ0LFxcblxcdFxcdFxcdFxcdFxcdHdpZHRoOiB3LFxcblxcdFxcdFxcdFxcdFxcdGhlaWdodDogaFxcblxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAodGhhdC5faGVscGVyICYmICFvLmFuaW1hdGUgJiYgL3N0YXRpYy8udGVzdChjZS5jc3MoXFxcInBvc2l0aW9uXFxcIikpKSB7XFxuXFx0XFx0XFx0XFx0JCh0aGlzKS5jc3Moe1xcblxcdFxcdFxcdFxcdFxcdGxlZnQ6IGhvLmxlZnQgLSBjb3AubGVmdCAtIGNvLmxlZnQsXFxuXFx0XFx0XFx0XFx0XFx0d2lkdGg6IHcsXFxuXFx0XFx0XFx0XFx0XFx0aGVpZ2h0OiBoXFxuXFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9KTtcXG5cXG5cXHQkLnVpLnBsdWdpbi5hZGQoXFxcInJlc2l6YWJsZVxcXCIsIFxcXCJhbHNvUmVzaXplXFxcIiwge1xcblxcblxcdFxcdHN0YXJ0OiBmdW5jdGlvbiBzdGFydCgpIHtcXG5cXHRcXHRcXHR2YXIgdGhhdCA9ICQodGhpcykucmVzaXphYmxlKFxcXCJpbnN0YW5jZVxcXCIpLFxcblxcdFxcdFxcdCAgICBvID0gdGhhdC5vcHRpb25zO1xcblxcblxcdFxcdFxcdCQoby5hbHNvUmVzaXplKS5lYWNoKGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHR2YXIgZWwgPSAkKHRoaXMpO1xcblxcdFxcdFxcdFxcdGVsLmRhdGEoXFxcInVpLXJlc2l6YWJsZS1hbHNvcmVzaXplXFxcIiwge1xcblxcdFxcdFxcdFxcdFxcdHdpZHRoOiBwYXJzZUludChlbC53aWR0aCgpLCAxMCksIGhlaWdodDogcGFyc2VJbnQoZWwuaGVpZ2h0KCksIDEwKSxcXG5cXHRcXHRcXHRcXHRcXHRsZWZ0OiBwYXJzZUludChlbC5jc3MoXFxcImxlZnRcXFwiKSwgMTApLCB0b3A6IHBhcnNlSW50KGVsLmNzcyhcXFwidG9wXFxcIiksIDEwKVxcblxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdH0pO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0cmVzaXplOiBmdW5jdGlvbiByZXNpemUoZXZlbnQsIHVpKSB7XFxuXFx0XFx0XFx0dmFyIHRoYXQgPSAkKHRoaXMpLnJlc2l6YWJsZShcXFwiaW5zdGFuY2VcXFwiKSxcXG5cXHRcXHRcXHQgICAgbyA9IHRoYXQub3B0aW9ucyxcXG5cXHRcXHRcXHQgICAgb3MgPSB0aGF0Lm9yaWdpbmFsU2l6ZSxcXG5cXHRcXHRcXHQgICAgb3AgPSB0aGF0Lm9yaWdpbmFsUG9zaXRpb24sXFxuXFx0XFx0XFx0ICAgIGRlbHRhID0ge1xcblxcdFxcdFxcdFxcdGhlaWdodDogdGhhdC5zaXplLmhlaWdodCAtIG9zLmhlaWdodCB8fCAwLFxcblxcdFxcdFxcdFxcdHdpZHRoOiB0aGF0LnNpemUud2lkdGggLSBvcy53aWR0aCB8fCAwLFxcblxcdFxcdFxcdFxcdHRvcDogdGhhdC5wb3NpdGlvbi50b3AgLSBvcC50b3AgfHwgMCxcXG5cXHRcXHRcXHRcXHRsZWZ0OiB0aGF0LnBvc2l0aW9uLmxlZnQgLSBvcC5sZWZ0IHx8IDBcXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdFxcdCQoby5hbHNvUmVzaXplKS5lYWNoKGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHR2YXIgZWwgPSAkKHRoaXMpLFxcblxcdFxcdFxcdFxcdCAgICBzdGFydCA9ICQodGhpcykuZGF0YShcXFwidWktcmVzaXphYmxlLWFsc29yZXNpemVcXFwiKSxcXG5cXHRcXHRcXHRcXHQgICAgc3R5bGUgPSB7fSxcXG5cXHRcXHRcXHRcXHQgICAgY3NzID0gZWwucGFyZW50cyh1aS5vcmlnaW5hbEVsZW1lbnRbMF0pLmxlbmd0aCA/IFtcXFwid2lkdGhcXFwiLCBcXFwiaGVpZ2h0XFxcIl0gOiBbXFxcIndpZHRoXFxcIiwgXFxcImhlaWdodFxcXCIsIFxcXCJ0b3BcXFwiLCBcXFwibGVmdFxcXCJdO1xcblxcblxcdFxcdFxcdFxcdCQuZWFjaChjc3MsIGZ1bmN0aW9uIChpLCBwcm9wKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIHN1bSA9IChzdGFydFtwcm9wXSB8fCAwKSArIChkZWx0YVtwcm9wXSB8fCAwKTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoc3VtICYmIHN1bSA+PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0c3R5bGVbcHJvcF0gPSBzdW0gfHwgbnVsbDtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fSk7XFxuXFxuXFx0XFx0XFx0XFx0ZWwuY3NzKHN0eWxlKTtcXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdHN0b3A6IGZ1bmN0aW9uIHN0b3AoKSB7XFxuXFx0XFx0XFx0JCh0aGlzKS5yZW1vdmVEYXRhKFxcXCJyZXNpemFibGUtYWxzb3Jlc2l6ZVxcXCIpO1xcblxcdFxcdH1cXG5cXHR9KTtcXG5cXG5cXHQkLnVpLnBsdWdpbi5hZGQoXFxcInJlc2l6YWJsZVxcXCIsIFxcXCJnaG9zdFxcXCIsIHtcXG5cXG5cXHRcXHRzdGFydDogZnVuY3Rpb24gc3RhcnQoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHRoYXQgPSAkKHRoaXMpLnJlc2l6YWJsZShcXFwiaW5zdGFuY2VcXFwiKSxcXG5cXHRcXHRcXHQgICAgbyA9IHRoYXQub3B0aW9ucyxcXG5cXHRcXHRcXHQgICAgY3MgPSB0aGF0LnNpemU7XFxuXFxuXFx0XFx0XFx0dGhhdC5naG9zdCA9IHRoYXQub3JpZ2luYWxFbGVtZW50LmNsb25lKCk7XFxuXFx0XFx0XFx0dGhhdC5naG9zdC5jc3Moe1xcblxcdFxcdFxcdFxcdG9wYWNpdHk6IDAuMjUsXFxuXFx0XFx0XFx0XFx0ZGlzcGxheTogXFxcImJsb2NrXFxcIixcXG5cXHRcXHRcXHRcXHRwb3NpdGlvbjogXFxcInJlbGF0aXZlXFxcIixcXG5cXHRcXHRcXHRcXHRoZWlnaHQ6IGNzLmhlaWdodCxcXG5cXHRcXHRcXHRcXHR3aWR0aDogY3Mud2lkdGgsXFxuXFx0XFx0XFx0XFx0bWFyZ2luOiAwLFxcblxcdFxcdFxcdFxcdGxlZnQ6IDAsXFxuXFx0XFx0XFx0XFx0dG9wOiAwXFxuXFx0XFx0XFx0fSkuYWRkQ2xhc3MoXFxcInVpLXJlc2l6YWJsZS1naG9zdFxcXCIpLmFkZENsYXNzKHR5cGVvZiBvLmdob3N0ID09PSBcXFwic3RyaW5nXFxcIiA/IG8uZ2hvc3QgOiBcXFwiXFxcIik7XFxuXFxuXFx0XFx0XFx0dGhhdC5naG9zdC5hcHBlbmRUbyh0aGF0LmhlbHBlcik7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRyZXNpemU6IGZ1bmN0aW9uIHJlc2l6ZSgpIHtcXG5cXHRcXHRcXHR2YXIgdGhhdCA9ICQodGhpcykucmVzaXphYmxlKFxcXCJpbnN0YW5jZVxcXCIpO1xcblxcdFxcdFxcdGlmICh0aGF0Lmdob3N0KSB7XFxuXFx0XFx0XFx0XFx0dGhhdC5naG9zdC5jc3Moe1xcblxcdFxcdFxcdFxcdFxcdHBvc2l0aW9uOiBcXFwicmVsYXRpdmVcXFwiLFxcblxcdFxcdFxcdFxcdFxcdGhlaWdodDogdGhhdC5zaXplLmhlaWdodCxcXG5cXHRcXHRcXHRcXHRcXHR3aWR0aDogdGhhdC5zaXplLndpZHRoXFxuXFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c3RvcDogZnVuY3Rpb24gc3RvcCgpIHtcXG5cXHRcXHRcXHR2YXIgdGhhdCA9ICQodGhpcykucmVzaXphYmxlKFxcXCJpbnN0YW5jZVxcXCIpO1xcblxcdFxcdFxcdGlmICh0aGF0Lmdob3N0ICYmIHRoYXQuaGVscGVyKSB7XFxuXFx0XFx0XFx0XFx0dGhhdC5oZWxwZXIuZ2V0KDApLnJlbW92ZUNoaWxkKHRoYXQuZ2hvc3QuZ2V0KDApKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdH0pO1xcblxcblxcdCQudWkucGx1Z2luLmFkZChcXFwicmVzaXphYmxlXFxcIiwgXFxcImdyaWRcXFwiLCB7XFxuXFxuXFx0XFx0cmVzaXplOiBmdW5jdGlvbiByZXNpemUoKSB7XFxuXFx0XFx0XFx0dmFyIG91dGVyRGltZW5zaW9ucyxcXG5cXHRcXHRcXHQgICAgdGhhdCA9ICQodGhpcykucmVzaXphYmxlKFxcXCJpbnN0YW5jZVxcXCIpLFxcblxcdFxcdFxcdCAgICBvID0gdGhhdC5vcHRpb25zLFxcblxcdFxcdFxcdCAgICBjcyA9IHRoYXQuc2l6ZSxcXG5cXHRcXHRcXHQgICAgb3MgPSB0aGF0Lm9yaWdpbmFsU2l6ZSxcXG5cXHRcXHRcXHQgICAgb3AgPSB0aGF0Lm9yaWdpbmFsUG9zaXRpb24sXFxuXFx0XFx0XFx0ICAgIGEgPSB0aGF0LmF4aXMsXFxuXFx0XFx0XFx0ICAgIGdyaWQgPSB0eXBlb2Ygby5ncmlkID09PSBcXFwibnVtYmVyXFxcIiA/IFtvLmdyaWQsIG8uZ3JpZF0gOiBvLmdyaWQsXFxuXFx0XFx0XFx0ICAgIGdyaWRYID0gZ3JpZFswXSB8fCAxLFxcblxcdFxcdFxcdCAgICBncmlkWSA9IGdyaWRbMV0gfHwgMSxcXG5cXHRcXHRcXHQgICAgb3ggPSBNYXRoLnJvdW5kKChjcy53aWR0aCAtIG9zLndpZHRoKSAvIGdyaWRYKSAqIGdyaWRYLFxcblxcdFxcdFxcdCAgICBveSA9IE1hdGgucm91bmQoKGNzLmhlaWdodCAtIG9zLmhlaWdodCkgLyBncmlkWSkgKiBncmlkWSxcXG5cXHRcXHRcXHQgICAgbmV3V2lkdGggPSBvcy53aWR0aCArIG94LFxcblxcdFxcdFxcdCAgICBuZXdIZWlnaHQgPSBvcy5oZWlnaHQgKyBveSxcXG5cXHRcXHRcXHQgICAgaXNNYXhXaWR0aCA9IG8ubWF4V2lkdGggJiYgby5tYXhXaWR0aCA8IG5ld1dpZHRoLFxcblxcdFxcdFxcdCAgICBpc01heEhlaWdodCA9IG8ubWF4SGVpZ2h0ICYmIG8ubWF4SGVpZ2h0IDwgbmV3SGVpZ2h0LFxcblxcdFxcdFxcdCAgICBpc01pbldpZHRoID0gby5taW5XaWR0aCAmJiBvLm1pbldpZHRoID4gbmV3V2lkdGgsXFxuXFx0XFx0XFx0ICAgIGlzTWluSGVpZ2h0ID0gby5taW5IZWlnaHQgJiYgby5taW5IZWlnaHQgPiBuZXdIZWlnaHQ7XFxuXFxuXFx0XFx0XFx0by5ncmlkID0gZ3JpZDtcXG5cXG5cXHRcXHRcXHRpZiAoaXNNaW5XaWR0aCkge1xcblxcdFxcdFxcdFxcdG5ld1dpZHRoICs9IGdyaWRYO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoaXNNaW5IZWlnaHQpIHtcXG5cXHRcXHRcXHRcXHRuZXdIZWlnaHQgKz0gZ3JpZFk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmIChpc01heFdpZHRoKSB7XFxuXFx0XFx0XFx0XFx0bmV3V2lkdGggLT0gZ3JpZFg7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmIChpc01heEhlaWdodCkge1xcblxcdFxcdFxcdFxcdG5ld0hlaWdodCAtPSBncmlkWTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKC9eKHNlfHN8ZSkkLy50ZXN0KGEpKSB7XFxuXFx0XFx0XFx0XFx0dGhhdC5zaXplLndpZHRoID0gbmV3V2lkdGg7XFxuXFx0XFx0XFx0XFx0dGhhdC5zaXplLmhlaWdodCA9IG5ld0hlaWdodDtcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKC9eKG5lKSQvLnRlc3QoYSkpIHtcXG5cXHRcXHRcXHRcXHR0aGF0LnNpemUud2lkdGggPSBuZXdXaWR0aDtcXG5cXHRcXHRcXHRcXHR0aGF0LnNpemUuaGVpZ2h0ID0gbmV3SGVpZ2h0O1xcblxcdFxcdFxcdFxcdHRoYXQucG9zaXRpb24udG9wID0gb3AudG9wIC0gb3k7XFxuXFx0XFx0XFx0fSBlbHNlIGlmICgvXihzdykkLy50ZXN0KGEpKSB7XFxuXFx0XFx0XFx0XFx0dGhhdC5zaXplLndpZHRoID0gbmV3V2lkdGg7XFxuXFx0XFx0XFx0XFx0dGhhdC5zaXplLmhlaWdodCA9IG5ld0hlaWdodDtcXG5cXHRcXHRcXHRcXHR0aGF0LnBvc2l0aW9uLmxlZnQgPSBvcC5sZWZ0IC0gb3g7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRpZiAobmV3SGVpZ2h0IC0gZ3JpZFkgPD0gMCB8fCBuZXdXaWR0aCAtIGdyaWRYIDw9IDApIHtcXG5cXHRcXHRcXHRcXHRcXHRvdXRlckRpbWVuc2lvbnMgPSB0aGF0Ll9nZXRQYWRkaW5nUGx1c0JvcmRlckRpbWVuc2lvbnModGhpcyk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmIChuZXdIZWlnaHQgLSBncmlkWSA+IDApIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGF0LnNpemUuaGVpZ2h0ID0gbmV3SGVpZ2h0O1xcblxcdFxcdFxcdFxcdFxcdHRoYXQucG9zaXRpb24udG9wID0gb3AudG9wIC0gb3k7XFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRuZXdIZWlnaHQgPSBncmlkWSAtIG91dGVyRGltZW5zaW9ucy5oZWlnaHQ7XFxuXFx0XFx0XFx0XFx0XFx0dGhhdC5zaXplLmhlaWdodCA9IG5ld0hlaWdodDtcXG5cXHRcXHRcXHRcXHRcXHR0aGF0LnBvc2l0aW9uLnRvcCA9IG9wLnRvcCArIG9zLmhlaWdodCAtIG5ld0hlaWdodDtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aWYgKG5ld1dpZHRoIC0gZ3JpZFggPiAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhhdC5zaXplLndpZHRoID0gbmV3V2lkdGg7XFxuXFx0XFx0XFx0XFx0XFx0dGhhdC5wb3NpdGlvbi5sZWZ0ID0gb3AubGVmdCAtIG94O1xcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0bmV3V2lkdGggPSBncmlkWCAtIG91dGVyRGltZW5zaW9ucy53aWR0aDtcXG5cXHRcXHRcXHRcXHRcXHR0aGF0LnNpemUud2lkdGggPSBuZXdXaWR0aDtcXG5cXHRcXHRcXHRcXHRcXHR0aGF0LnBvc2l0aW9uLmxlZnQgPSBvcC5sZWZ0ICsgb3Mud2lkdGggLSBuZXdXaWR0aDtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHR9KTtcXG5cXG5cXHR2YXIgcmVzaXphYmxlID0gJC51aS5yZXNpemFibGU7XFxuXFxuXFx0LyohXFxuICAqIGpRdWVyeSBVSSBEaWFsb2cgMS4xMS40XFxuICAqIGh0dHA6Ly9qcXVlcnl1aS5jb21cXG4gICpcXG4gICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcXG4gICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxcbiAgKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXFxuICAqXFxuICAqIGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL2RpYWxvZy9cXG4gICovXFxuXFxuXFx0dmFyIGRpYWxvZyA9ICQud2lkZ2V0KFxcXCJ1aS5kaWFsb2dcXFwiLCB7XFxuXFx0XFx0dmVyc2lvbjogXFxcIjEuMTEuNFxcXCIsXFxuXFx0XFx0b3B0aW9uczoge1xcblxcdFxcdFxcdGFwcGVuZFRvOiBcXFwiYm9keVxcXCIsXFxuXFx0XFx0XFx0YXV0b09wZW46IHRydWUsXFxuXFx0XFx0XFx0YnV0dG9uczogW10sXFxuXFx0XFx0XFx0Y2xvc2VPbkVzY2FwZTogdHJ1ZSxcXG5cXHRcXHRcXHRjbG9zZVRleHQ6IFxcXCJDbG9zZVxcXCIsXFxuXFx0XFx0XFx0ZGlhbG9nQ2xhc3M6IFxcXCJcXFwiLFxcblxcdFxcdFxcdGRyYWdnYWJsZTogdHJ1ZSxcXG5cXHRcXHRcXHRoaWRlOiBudWxsLFxcblxcdFxcdFxcdGhlaWdodDogXFxcImF1dG9cXFwiLFxcblxcdFxcdFxcdG1heEhlaWdodDogbnVsbCxcXG5cXHRcXHRcXHRtYXhXaWR0aDogbnVsbCxcXG5cXHRcXHRcXHRtaW5IZWlnaHQ6IDE1MCxcXG5cXHRcXHRcXHRtaW5XaWR0aDogMTUwLFxcblxcdFxcdFxcdG1vZGFsOiBmYWxzZSxcXG5cXHRcXHRcXHRwb3NpdGlvbjoge1xcblxcdFxcdFxcdFxcdG15OiBcXFwiY2VudGVyXFxcIixcXG5cXHRcXHRcXHRcXHRhdDogXFxcImNlbnRlclxcXCIsXFxuXFx0XFx0XFx0XFx0b2Y6IHdpbmRvdyxcXG5cXHRcXHRcXHRcXHRjb2xsaXNpb246IFxcXCJmaXRcXFwiLFxcblxcdFxcdFxcdFxcdC8vIEVuc3VyZSB0aGUgdGl0bGViYXIgaXMgYWx3YXlzIHZpc2libGVcXG5cXHRcXHRcXHRcXHR1c2luZzogZnVuY3Rpb24gdXNpbmcocG9zKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIHRvcE9mZnNldCA9ICQodGhpcykuY3NzKHBvcykub2Zmc2V0KCkudG9wO1xcblxcdFxcdFxcdFxcdFxcdGlmICh0b3BPZmZzZXQgPCAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0JCh0aGlzKS5jc3MoXFxcInRvcFxcXCIsIHBvcy50b3AgLSB0b3BPZmZzZXQpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRyZXNpemFibGU6IHRydWUsXFxuXFx0XFx0XFx0c2hvdzogbnVsbCxcXG5cXHRcXHRcXHR0aXRsZTogbnVsbCxcXG5cXHRcXHRcXHR3aWR0aDogMzAwLFxcblxcblxcdFxcdFxcdC8vIGNhbGxiYWNrc1xcblxcdFxcdFxcdGJlZm9yZUNsb3NlOiBudWxsLFxcblxcdFxcdFxcdGNsb3NlOiBudWxsLFxcblxcdFxcdFxcdGRyYWc6IG51bGwsXFxuXFx0XFx0XFx0ZHJhZ1N0YXJ0OiBudWxsLFxcblxcdFxcdFxcdGRyYWdTdG9wOiBudWxsLFxcblxcdFxcdFxcdGZvY3VzOiBudWxsLFxcblxcdFxcdFxcdG9wZW46IG51bGwsXFxuXFx0XFx0XFx0cmVzaXplOiBudWxsLFxcblxcdFxcdFxcdHJlc2l6ZVN0YXJ0OiBudWxsLFxcblxcdFxcdFxcdHJlc2l6ZVN0b3A6IG51bGxcXG5cXHRcXHR9LFxcblxcblxcdFxcdHNpemVSZWxhdGVkT3B0aW9uczoge1xcblxcdFxcdFxcdGJ1dHRvbnM6IHRydWUsXFxuXFx0XFx0XFx0aGVpZ2h0OiB0cnVlLFxcblxcdFxcdFxcdG1heEhlaWdodDogdHJ1ZSxcXG5cXHRcXHRcXHRtYXhXaWR0aDogdHJ1ZSxcXG5cXHRcXHRcXHRtaW5IZWlnaHQ6IHRydWUsXFxuXFx0XFx0XFx0bWluV2lkdGg6IHRydWUsXFxuXFx0XFx0XFx0d2lkdGg6IHRydWVcXG5cXHRcXHR9LFxcblxcblxcdFxcdHJlc2l6YWJsZVJlbGF0ZWRPcHRpb25zOiB7XFxuXFx0XFx0XFx0bWF4SGVpZ2h0OiB0cnVlLFxcblxcdFxcdFxcdG1heFdpZHRoOiB0cnVlLFxcblxcdFxcdFxcdG1pbkhlaWdodDogdHJ1ZSxcXG5cXHRcXHRcXHRtaW5XaWR0aDogdHJ1ZVxcblxcdFxcdH0sXFxuXFxuXFx0XFx0X2NyZWF0ZTogZnVuY3Rpb24gX2NyZWF0ZSgpIHtcXG5cXHRcXHRcXHR0aGlzLm9yaWdpbmFsQ3NzID0ge1xcblxcdFxcdFxcdFxcdGRpc3BsYXk6IHRoaXMuZWxlbWVudFswXS5zdHlsZS5kaXNwbGF5LFxcblxcdFxcdFxcdFxcdHdpZHRoOiB0aGlzLmVsZW1lbnRbMF0uc3R5bGUud2lkdGgsXFxuXFx0XFx0XFx0XFx0bWluSGVpZ2h0OiB0aGlzLmVsZW1lbnRbMF0uc3R5bGUubWluSGVpZ2h0LFxcblxcdFxcdFxcdFxcdG1heEhlaWdodDogdGhpcy5lbGVtZW50WzBdLnN0eWxlLm1heEhlaWdodCxcXG5cXHRcXHRcXHRcXHRoZWlnaHQ6IHRoaXMuZWxlbWVudFswXS5zdHlsZS5oZWlnaHRcXG5cXHRcXHRcXHR9O1xcblxcdFxcdFxcdHRoaXMub3JpZ2luYWxQb3NpdGlvbiA9IHtcXG5cXHRcXHRcXHRcXHRwYXJlbnQ6IHRoaXMuZWxlbWVudC5wYXJlbnQoKSxcXG5cXHRcXHRcXHRcXHRpbmRleDogdGhpcy5lbGVtZW50LnBhcmVudCgpLmNoaWxkcmVuKCkuaW5kZXgodGhpcy5lbGVtZW50KVxcblxcdFxcdFxcdH07XFxuXFx0XFx0XFx0dGhpcy5vcmlnaW5hbFRpdGxlID0gdGhpcy5lbGVtZW50LmF0dHIoXFxcInRpdGxlXFxcIik7XFxuXFx0XFx0XFx0dGhpcy5vcHRpb25zLnRpdGxlID0gdGhpcy5vcHRpb25zLnRpdGxlIHx8IHRoaXMub3JpZ2luYWxUaXRsZTtcXG5cXG5cXHRcXHRcXHR0aGlzLl9jcmVhdGVXcmFwcGVyKCk7XFxuXFxuXFx0XFx0XFx0dGhpcy5lbGVtZW50LnNob3coKS5yZW1vdmVBdHRyKFxcXCJ0aXRsZVxcXCIpLmFkZENsYXNzKFxcXCJ1aS1kaWFsb2ctY29udGVudCB1aS13aWRnZXQtY29udGVudFxcXCIpLmFwcGVuZFRvKHRoaXMudWlEaWFsb2cpO1xcblxcblxcdFxcdFxcdHRoaXMuX2NyZWF0ZVRpdGxlYmFyKCk7XFxuXFx0XFx0XFx0dGhpcy5fY3JlYXRlQnV0dG9uUGFuZSgpO1xcblxcblxcdFxcdFxcdGlmICh0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlICYmICQuZm4uZHJhZ2dhYmxlKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5fbWFrZURyYWdnYWJsZSgpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAodGhpcy5vcHRpb25zLnJlc2l6YWJsZSAmJiAkLmZuLnJlc2l6YWJsZSkge1xcblxcdFxcdFxcdFxcdHRoaXMuX21ha2VSZXNpemFibGUoKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy5faXNPcGVuID0gZmFsc2U7XFxuXFxuXFx0XFx0XFx0dGhpcy5fdHJhY2tGb2N1cygpO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X2luaXQ6IGZ1bmN0aW9uIF9pbml0KCkge1xcblxcdFxcdFxcdGlmICh0aGlzLm9wdGlvbnMuYXV0b09wZW4pIHtcXG5cXHRcXHRcXHRcXHR0aGlzLm9wZW4oKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfYXBwZW5kVG86IGZ1bmN0aW9uIF9hcHBlbmRUbygpIHtcXG5cXHRcXHRcXHR2YXIgZWxlbWVudCA9IHRoaXMub3B0aW9ucy5hcHBlbmRUbztcXG5cXHRcXHRcXHRpZiAoZWxlbWVudCAmJiAoZWxlbWVudC5qcXVlcnkgfHwgZWxlbWVudC5ub2RlVHlwZSkpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gJChlbGVtZW50KTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZG9jdW1lbnQuZmluZChlbGVtZW50IHx8IFxcXCJib2R5XFxcIikuZXEoMCk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfZGVzdHJveTogZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XFxuXFx0XFx0XFx0dmFyIG5leHQsXFxuXFx0XFx0XFx0ICAgIG9yaWdpbmFsUG9zaXRpb24gPSB0aGlzLm9yaWdpbmFsUG9zaXRpb247XFxuXFxuXFx0XFx0XFx0dGhpcy5fdW50cmFja0luc3RhbmNlKCk7XFxuXFx0XFx0XFx0dGhpcy5fZGVzdHJveU92ZXJsYXkoKTtcXG5cXG5cXHRcXHRcXHR0aGlzLmVsZW1lbnQucmVtb3ZlVW5pcXVlSWQoKS5yZW1vdmVDbGFzcyhcXFwidWktZGlhbG9nLWNvbnRlbnQgdWktd2lkZ2V0LWNvbnRlbnRcXFwiKS5jc3ModGhpcy5vcmlnaW5hbENzcylcXG5cXHRcXHRcXHQvLyBXaXRob3V0IGRldGFjaGluZyBmaXJzdCwgdGhlIGZvbGxvd2luZyBiZWNvbWVzIHJlYWxseSBzbG93XFxuXFx0XFx0XFx0LmRldGFjaCgpO1xcblxcblxcdFxcdFxcdHRoaXMudWlEaWFsb2cuc3RvcCh0cnVlLCB0cnVlKS5yZW1vdmUoKTtcXG5cXG5cXHRcXHRcXHRpZiAodGhpcy5vcmlnaW5hbFRpdGxlKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5lbGVtZW50LmF0dHIoXFxcInRpdGxlXFxcIiwgdGhpcy5vcmlnaW5hbFRpdGxlKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0bmV4dCA9IG9yaWdpbmFsUG9zaXRpb24ucGFyZW50LmNoaWxkcmVuKCkuZXEob3JpZ2luYWxQb3NpdGlvbi5pbmRleCk7XFxuXFx0XFx0XFx0Ly8gRG9uJ3QgdHJ5IHRvIHBsYWNlIHRoZSBkaWFsb2cgbmV4dCB0byBpdHNlbGYgKCM4NjEzKVxcblxcdFxcdFxcdGlmIChuZXh0Lmxlbmd0aCAmJiBuZXh0WzBdICE9PSB0aGlzLmVsZW1lbnRbMF0pIHtcXG5cXHRcXHRcXHRcXHRuZXh0LmJlZm9yZSh0aGlzLmVsZW1lbnQpO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0b3JpZ2luYWxQb3NpdGlvbi5wYXJlbnQuYXBwZW5kKHRoaXMuZWxlbWVudCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFxuXFx0XFx0d2lkZ2V0OiBmdW5jdGlvbiB3aWRnZXQoKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMudWlEaWFsb2c7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRkaXNhYmxlOiAkLm5vb3AsXFxuXFx0XFx0ZW5hYmxlOiAkLm5vb3AsXFxuXFxuXFx0XFx0Y2xvc2U6IGZ1bmN0aW9uIGNsb3NlKGV2ZW50KSB7XFxuXFx0XFx0XFx0dmFyIGFjdGl2ZUVsZW1lbnQsXFxuXFx0XFx0XFx0ICAgIHRoYXQgPSB0aGlzO1xcblxcblxcdFxcdFxcdGlmICghdGhpcy5faXNPcGVuIHx8IHRoaXMuX3RyaWdnZXIoXFxcImJlZm9yZUNsb3NlXFxcIiwgZXZlbnQpID09PSBmYWxzZSkge1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy5faXNPcGVuID0gZmFsc2U7XFxuXFx0XFx0XFx0dGhpcy5fZm9jdXNlZEVsZW1lbnQgPSBudWxsO1xcblxcdFxcdFxcdHRoaXMuX2Rlc3Ryb3lPdmVybGF5KCk7XFxuXFx0XFx0XFx0dGhpcy5fdW50cmFja0luc3RhbmNlKCk7XFxuXFxuXFx0XFx0XFx0aWYgKCF0aGlzLm9wZW5lci5maWx0ZXIoXFxcIjpmb2N1c2FibGVcXFwiKS5mb2N1cygpLmxlbmd0aCkge1xcblxcblxcdFxcdFxcdFxcdC8vIHN1cHBvcnQ6IElFOVxcblxcdFxcdFxcdFxcdC8vIElFOSB0aHJvd3MgYW4gXFxcIlVuc3BlY2lmaWVkIGVycm9yXFxcIiBhY2Nlc3NpbmcgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBmcm9tIGFuIDxpZnJhbWU+XFxuXFx0XFx0XFx0XFx0dHJ5IHtcXG5cXHRcXHRcXHRcXHRcXHRhY3RpdmVFbGVtZW50ID0gdGhpcy5kb2N1bWVudFswXS5hY3RpdmVFbGVtZW50O1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIFN1cHBvcnQ6IElFOSwgSUUxMFxcblxcdFxcdFxcdFxcdFxcdC8vIElmIHRoZSA8Ym9keT4gaXMgYmx1cnJlZCwgSUUgd2lsbCBzd2l0Y2ggd2luZG93cywgc2VlICM0NTIwXFxuXFx0XFx0XFx0XFx0XFx0aWYgKGFjdGl2ZUVsZW1lbnQgJiYgYWN0aXZlRWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcXFwiYm9keVxcXCIpIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBIaWRpbmcgYSBmb2N1c2VkIGVsZW1lbnQgZG9lc24ndCB0cmlnZ2VyIGJsdXIgaW4gV2ViS2l0XFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gc28gaW4gY2FzZSB3ZSBoYXZlIG5vdGhpbmcgdG8gZm9jdXMgb24sIGV4cGxpY2l0bHkgYmx1ciB0aGUgYWN0aXZlIGVsZW1lbnRcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NDcxODJcXG5cXHRcXHRcXHRcXHRcXHRcXHQkKGFjdGl2ZUVsZW1lbnQpLmJsdXIoKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fSBjYXRjaCAoZXJyb3IpIHt9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMuX2hpZGUodGhpcy51aURpYWxvZywgdGhpcy5vcHRpb25zLmhpZGUsIGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHR0aGF0Ll90cmlnZ2VyKFxcXCJjbG9zZVxcXCIsIGV2ZW50KTtcXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdGlzT3BlbjogZnVuY3Rpb24gaXNPcGVuKCkge1xcblxcdFxcdFxcdHJldHVybiB0aGlzLl9pc09wZW47XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRtb3ZlVG9Ub3A6IGZ1bmN0aW9uIG1vdmVUb1RvcCgpIHtcXG5cXHRcXHRcXHR0aGlzLl9tb3ZlVG9Ub3AoKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9tb3ZlVG9Ub3A6IGZ1bmN0aW9uIF9tb3ZlVG9Ub3AoZXZlbnQsIHNpbGVudCkge1xcblxcdFxcdFxcdHZhciBtb3ZlZCA9IGZhbHNlLFxcblxcdFxcdFxcdCAgICB6SW5kaWNlcyA9IHRoaXMudWlEaWFsb2cuc2libGluZ3MoXFxcIi51aS1mcm9udDp2aXNpYmxlXFxcIikubWFwKGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gKyQodGhpcykuY3NzKFxcXCJ6LWluZGV4XFxcIik7XFxuXFx0XFx0XFx0fSkuZ2V0KCksXFxuXFx0XFx0XFx0ICAgIHpJbmRleE1heCA9IE1hdGgubWF4LmFwcGx5KG51bGwsIHpJbmRpY2VzKTtcXG5cXG5cXHRcXHRcXHRpZiAoekluZGV4TWF4ID49ICt0aGlzLnVpRGlhbG9nLmNzcyhcXFwiei1pbmRleFxcXCIpKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy51aURpYWxvZy5jc3MoXFxcInotaW5kZXhcXFwiLCB6SW5kZXhNYXggKyAxKTtcXG5cXHRcXHRcXHRcXHRtb3ZlZCA9IHRydWU7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmIChtb3ZlZCAmJiAhc2lsZW50KSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5fdHJpZ2dlcihcXFwiZm9jdXNcXFwiLCBldmVudCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiBtb3ZlZDtcXG5cXHRcXHR9LFxcblxcblxcdFxcdG9wZW46IGZ1bmN0aW9uIG9wZW4oKSB7XFxuXFx0XFx0XFx0dmFyIHRoYXQgPSB0aGlzO1xcblxcdFxcdFxcdGlmICh0aGlzLl9pc09wZW4pIHtcXG5cXHRcXHRcXHRcXHRpZiAodGhpcy5fbW92ZVRvVG9wKCkpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9mb2N1c1RhYmJhYmxlKCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy5faXNPcGVuID0gdHJ1ZTtcXG5cXHRcXHRcXHR0aGlzLm9wZW5lciA9ICQodGhpcy5kb2N1bWVudFswXS5hY3RpdmVFbGVtZW50KTtcXG5cXG5cXHRcXHRcXHR0aGlzLl9zaXplKCk7XFxuXFx0XFx0XFx0dGhpcy5fcG9zaXRpb24oKTtcXG5cXHRcXHRcXHR0aGlzLl9jcmVhdGVPdmVybGF5KCk7XFxuXFx0XFx0XFx0dGhpcy5fbW92ZVRvVG9wKG51bGwsIHRydWUpO1xcblxcblxcdFxcdFxcdC8vIEVuc3VyZSB0aGUgb3ZlcmxheSBpcyBtb3ZlZCB0byB0aGUgdG9wIHdpdGggdGhlIGRpYWxvZywgYnV0IG9ubHkgd2hlblxcblxcdFxcdFxcdC8vIG9wZW5pbmcuIFRoZSBvdmVybGF5IHNob3VsZG4ndCBtb3ZlIGFmdGVyIHRoZSBkaWFsb2cgaXMgb3BlbiBzbyB0aGF0XFxuXFx0XFx0XFx0Ly8gbW9kZWxlc3MgZGlhbG9ncyBvcGVuZWQgYWZ0ZXIgdGhlIG1vZGFsIGRpYWxvZyBzdGFjayBwcm9wZXJseS5cXG5cXHRcXHRcXHRpZiAodGhpcy5vdmVybGF5KSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5vdmVybGF5LmNzcyhcXFwiei1pbmRleFxcXCIsIHRoaXMudWlEaWFsb2cuY3NzKFxcXCJ6LWluZGV4XFxcIikgLSAxKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy5fc2hvdyh0aGlzLnVpRGlhbG9nLCB0aGlzLm9wdGlvbnMuc2hvdywgZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdHRoYXQuX2ZvY3VzVGFiYmFibGUoKTtcXG5cXHRcXHRcXHRcXHR0aGF0Ll90cmlnZ2VyKFxcXCJmb2N1c1xcXCIpO1xcblxcdFxcdFxcdH0pO1xcblxcblxcdFxcdFxcdC8vIFRyYWNrIHRoZSBkaWFsb2cgaW1tZWRpYXRlbHkgdXBvbiBvcGVuZW5pbmcgaW4gY2FzZSBhIGZvY3VzIGV2ZW50XFxuXFx0XFx0XFx0Ly8gc29tZWhvdyBvY2N1cnMgb3V0c2lkZSBvZiB0aGUgZGlhbG9nIGJlZm9yZSBhbiBlbGVtZW50IGluc2lkZSB0aGVcXG5cXHRcXHRcXHQvLyBkaWFsb2cgaXMgZm9jdXNlZCAoIzEwMTUyKVxcblxcdFxcdFxcdHRoaXMuX21ha2VGb2N1c1RhcmdldCgpO1xcblxcblxcdFxcdFxcdHRoaXMuX3RyaWdnZXIoXFxcIm9wZW5cXFwiKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9mb2N1c1RhYmJhYmxlOiBmdW5jdGlvbiBfZm9jdXNUYWJiYWJsZSgpIHtcXG5cXHRcXHRcXHQvLyBTZXQgZm9jdXMgdG8gdGhlIGZpcnN0IG1hdGNoOlxcblxcdFxcdFxcdC8vIDEuIEFuIGVsZW1lbnQgdGhhdCB3YXMgZm9jdXNlZCBwcmV2aW91c2x5XFxuXFx0XFx0XFx0Ly8gMi4gRmlyc3QgZWxlbWVudCBpbnNpZGUgdGhlIGRpYWxvZyBtYXRjaGluZyBbYXV0b2ZvY3VzXVxcblxcdFxcdFxcdC8vIDMuIFRhYmJhYmxlIGVsZW1lbnQgaW5zaWRlIHRoZSBjb250ZW50IGVsZW1lbnRcXG5cXHRcXHRcXHQvLyA0LiBUYWJiYWJsZSBlbGVtZW50IGluc2lkZSB0aGUgYnV0dG9ucGFuZVxcblxcdFxcdFxcdC8vIDUuIFRoZSBjbG9zZSBidXR0b25cXG5cXHRcXHRcXHQvLyA2LiBUaGUgZGlhbG9nIGl0c2VsZlxcblxcdFxcdFxcdHZhciBoYXNGb2N1cyA9IHRoaXMuX2ZvY3VzZWRFbGVtZW50O1xcblxcdFxcdFxcdGlmICghaGFzRm9jdXMpIHtcXG5cXHRcXHRcXHRcXHRoYXNGb2N1cyA9IHRoaXMuZWxlbWVudC5maW5kKFxcXCJbYXV0b2ZvY3VzXVxcXCIpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoIWhhc0ZvY3VzLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdGhhc0ZvY3VzID0gdGhpcy5lbGVtZW50LmZpbmQoXFxcIjp0YWJiYWJsZVxcXCIpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoIWhhc0ZvY3VzLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdGhhc0ZvY3VzID0gdGhpcy51aURpYWxvZ0J1dHRvblBhbmUuZmluZChcXFwiOnRhYmJhYmxlXFxcIik7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICghaGFzRm9jdXMubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0aGFzRm9jdXMgPSB0aGlzLnVpRGlhbG9nVGl0bGViYXJDbG9zZS5maWx0ZXIoXFxcIjp0YWJiYWJsZVxcXCIpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoIWhhc0ZvY3VzLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdGhhc0ZvY3VzID0gdGhpcy51aURpYWxvZztcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aGFzRm9jdXMuZXEoMCkuZm9jdXMoKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9rZWVwRm9jdXM6IGZ1bmN0aW9uIF9rZWVwRm9jdXMoZXZlbnQpIHtcXG5cXHRcXHRcXHRmdW5jdGlvbiBjaGVja0ZvY3VzKCkge1xcblxcdFxcdFxcdFxcdHZhciBhY3RpdmVFbGVtZW50ID0gdGhpcy5kb2N1bWVudFswXS5hY3RpdmVFbGVtZW50LFxcblxcdFxcdFxcdFxcdCAgICBpc0FjdGl2ZSA9IHRoaXMudWlEaWFsb2dbMF0gPT09IGFjdGl2ZUVsZW1lbnQgfHwgJC5jb250YWlucyh0aGlzLnVpRGlhbG9nWzBdLCBhY3RpdmVFbGVtZW50KTtcXG5cXHRcXHRcXHRcXHRpZiAoIWlzQWN0aXZlKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fZm9jdXNUYWJiYWJsZSgpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG5cXHRcXHRcXHRjaGVja0ZvY3VzLmNhbGwodGhpcyk7XFxuXFx0XFx0XFx0Ly8gc3VwcG9ydDogSUVcXG5cXHRcXHRcXHQvLyBJRSA8PSA4IGRvZXNuJ3QgcHJldmVudCBtb3ZpbmcgZm9jdXMgZXZlbiB3aXRoIGV2ZW50LnByZXZlbnREZWZhdWx0KClcXG5cXHRcXHRcXHQvLyBzbyB3ZSBjaGVjayBhZ2FpbiBsYXRlclxcblxcdFxcdFxcdHRoaXMuX2RlbGF5KGNoZWNrRm9jdXMpO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X2NyZWF0ZVdyYXBwZXI6IGZ1bmN0aW9uIF9jcmVhdGVXcmFwcGVyKCkge1xcblxcdFxcdFxcdHRoaXMudWlEaWFsb2cgPSAkKFxcXCI8ZGl2PlxcXCIpLmFkZENsYXNzKFxcXCJ1aS1kaWFsb2cgdWktd2lkZ2V0IHVpLXdpZGdldC1jb250ZW50IHVpLWNvcm5lci1hbGwgdWktZnJvbnQgXFxcIiArIHRoaXMub3B0aW9ucy5kaWFsb2dDbGFzcykuaGlkZSgpLmF0dHIoe1xcblxcdFxcdFxcdFxcdC8vIFNldHRpbmcgdGFiSW5kZXggbWFrZXMgdGhlIGRpdiBmb2N1c2FibGVcXG5cXHRcXHRcXHRcXHR0YWJJbmRleDogLTEsXFxuXFx0XFx0XFx0XFx0cm9sZTogXFxcImRpYWxvZ1xcXCJcXG5cXHRcXHRcXHR9KS5hcHBlbmRUbyh0aGlzLl9hcHBlbmRUbygpKTtcXG5cXG5cXHRcXHRcXHR0aGlzLl9vbih0aGlzLnVpRGlhbG9nLCB7XFxuXFx0XFx0XFx0XFx0a2V5ZG93bjogZnVuY3Rpb24ga2V5ZG93bihldmVudCkge1xcblxcdFxcdFxcdFxcdFxcdGlmICh0aGlzLm9wdGlvbnMuY2xvc2VPbkVzY2FwZSAmJiAhZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgJiYgZXZlbnQua2V5Q29kZSAmJiBldmVudC5rZXlDb2RlID09PSAkLnVpLmtleUNvZGUuRVNDQVBFKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLmNsb3NlKGV2ZW50KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdC8vIHByZXZlbnQgdGFiYmluZyBvdXQgb2YgZGlhbG9nc1xcblxcdFxcdFxcdFxcdFxcdGlmIChldmVudC5rZXlDb2RlICE9PSAkLnVpLmtleUNvZGUuVEFCIHx8IGV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR2YXIgdGFiYmFibGVzID0gdGhpcy51aURpYWxvZy5maW5kKFxcXCI6dGFiYmFibGVcXFwiKSxcXG5cXHRcXHRcXHRcXHRcXHQgICAgZmlyc3QgPSB0YWJiYWJsZXMuZmlsdGVyKFxcXCI6Zmlyc3RcXFwiKSxcXG5cXHRcXHRcXHRcXHRcXHQgICAgbGFzdCA9IHRhYmJhYmxlcy5maWx0ZXIoXFxcIjpsYXN0XFxcIik7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKChldmVudC50YXJnZXQgPT09IGxhc3RbMF0gfHwgZXZlbnQudGFyZ2V0ID09PSB0aGlzLnVpRGlhbG9nWzBdKSAmJiAhZXZlbnQuc2hpZnRLZXkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl9kZWxheShmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Zmlyc3QuZm9jdXMoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoKGV2ZW50LnRhcmdldCA9PT0gZmlyc3RbMF0gfHwgZXZlbnQudGFyZ2V0ID09PSB0aGlzLnVpRGlhbG9nWzBdKSAmJiBldmVudC5zaGlmdEtleSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuX2RlbGF5KGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRsYXN0LmZvY3VzKCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRcXHRtb3VzZWRvd246IGZ1bmN0aW9uIG1vdXNlZG93bihldmVudCkge1xcblxcdFxcdFxcdFxcdFxcdGlmICh0aGlzLl9tb3ZlVG9Ub3AoZXZlbnQpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5fZm9jdXNUYWJiYWJsZSgpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSk7XFxuXFxuXFx0XFx0XFx0Ly8gV2UgYXNzdW1lIHRoYXQgYW55IGV4aXN0aW5nIGFyaWEtZGVzY3JpYmVkYnkgYXR0cmlidXRlIG1lYW5zXFxuXFx0XFx0XFx0Ly8gdGhhdCB0aGUgZGlhbG9nIGNvbnRlbnQgaXMgbWFya2VkIHVwIHByb3Blcmx5XFxuXFx0XFx0XFx0Ly8gb3RoZXJ3aXNlIHdlIGJydXRlIGZvcmNlIHRoZSBjb250ZW50IGFzIHRoZSBkZXNjcmlwdGlvblxcblxcdFxcdFxcdGlmICghdGhpcy5lbGVtZW50LmZpbmQoXFxcIlthcmlhLWRlc2NyaWJlZGJ5XVxcXCIpLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdHRoaXMudWlEaWFsb2cuYXR0cih7XFxuXFx0XFx0XFx0XFx0XFx0XFxcImFyaWEtZGVzY3JpYmVkYnlcXFwiOiB0aGlzLmVsZW1lbnQudW5pcXVlSWQoKS5hdHRyKFxcXCJpZFxcXCIpXFxuXFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFxuXFx0XFx0X2NyZWF0ZVRpdGxlYmFyOiBmdW5jdGlvbiBfY3JlYXRlVGl0bGViYXIoKSB7XFxuXFx0XFx0XFx0dmFyIHVpRGlhbG9nVGl0bGU7XFxuXFxuXFx0XFx0XFx0dGhpcy51aURpYWxvZ1RpdGxlYmFyID0gJChcXFwiPGRpdj5cXFwiKS5hZGRDbGFzcyhcXFwidWktZGlhbG9nLXRpdGxlYmFyIHVpLXdpZGdldC1oZWFkZXIgdWktY29ybmVyLWFsbCB1aS1oZWxwZXItY2xlYXJmaXhcXFwiKS5wcmVwZW5kVG8odGhpcy51aURpYWxvZyk7XFxuXFx0XFx0XFx0dGhpcy5fb24odGhpcy51aURpYWxvZ1RpdGxlYmFyLCB7XFxuXFx0XFx0XFx0XFx0bW91c2Vkb3duOiBmdW5jdGlvbiBtb3VzZWRvd24oZXZlbnQpIHtcXG5cXHRcXHRcXHRcXHRcXHQvLyBEb24ndCBwcmV2ZW50IGNsaWNrIG9uIGNsb3NlIGJ1dHRvbiAoIzg4MzgpXFxuXFx0XFx0XFx0XFx0XFx0Ly8gRm9jdXNpbmcgYSBkaWFsb2cgdGhhdCBpcyBwYXJ0aWFsbHkgc2Nyb2xsZWQgb3V0IG9mIHZpZXdcXG5cXHRcXHRcXHRcXHRcXHQvLyBjYXVzZXMgdGhlIGJyb3dzZXIgdG8gc2Nyb2xsIGl0IGludG8gdmlldywgcHJldmVudGluZyB0aGUgY2xpY2sgZXZlbnRcXG5cXHRcXHRcXHRcXHRcXHRpZiAoISQoZXZlbnQudGFyZ2V0KS5jbG9zZXN0KFxcXCIudWktZGlhbG9nLXRpdGxlYmFyLWNsb3NlXFxcIikpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBEaWFsb2cgaXNuJ3QgZ2V0dGluZyBmb2N1cyB3aGVuIGRyYWdnaW5nICgjODA2MylcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLnVpRGlhbG9nLmZvY3VzKCk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9KTtcXG5cXG5cXHRcXHRcXHQvLyBzdXBwb3J0OiBJRVxcblxcdFxcdFxcdC8vIFVzZSB0eXBlPVxcXCJidXR0b25cXFwiIHRvIHByZXZlbnQgZW50ZXIga2V5cHJlc3NlcyBpbiB0ZXh0Ym94ZXMgZnJvbSBjbG9zaW5nIHRoZVxcblxcdFxcdFxcdC8vIGRpYWxvZyBpbiBJRSAoIzkzMTIpXFxuXFx0XFx0XFx0dGhpcy51aURpYWxvZ1RpdGxlYmFyQ2xvc2UgPSAkKFxcXCI8YnV0dG9uIHR5cGU9J2J1dHRvbic+PC9idXR0b24+XFxcIikuYnV0dG9uKHtcXG5cXHRcXHRcXHRcXHRsYWJlbDogdGhpcy5vcHRpb25zLmNsb3NlVGV4dCxcXG5cXHRcXHRcXHRcXHRpY29uczoge1xcblxcdFxcdFxcdFxcdFxcdHByaW1hcnk6IFxcXCJ1aS1pY29uLWNsb3NldGhpY2tcXFwiXFxuXFx0XFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRcXHR0ZXh0OiBmYWxzZVxcblxcdFxcdFxcdH0pLmFkZENsYXNzKFxcXCJ1aS1kaWFsb2ctdGl0bGViYXItY2xvc2VcXFwiKS5hcHBlbmRUbyh0aGlzLnVpRGlhbG9nVGl0bGViYXIpO1xcblxcdFxcdFxcdHRoaXMuX29uKHRoaXMudWlEaWFsb2dUaXRsZWJhckNsb3NlLCB7XFxuXFx0XFx0XFx0XFx0Y2xpY2s6IGZ1bmN0aW9uIGNsaWNrKGV2ZW50KSB7XFxuXFx0XFx0XFx0XFx0XFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmNsb3NlKGV2ZW50KTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSk7XFxuXFxuXFx0XFx0XFx0dWlEaWFsb2dUaXRsZSA9ICQoXFxcIjxzcGFuPlxcXCIpLnVuaXF1ZUlkKCkuYWRkQ2xhc3MoXFxcInVpLWRpYWxvZy10aXRsZVxcXCIpLnByZXBlbmRUbyh0aGlzLnVpRGlhbG9nVGl0bGViYXIpO1xcblxcdFxcdFxcdHRoaXMuX3RpdGxlKHVpRGlhbG9nVGl0bGUpO1xcblxcblxcdFxcdFxcdHRoaXMudWlEaWFsb2cuYXR0cih7XFxuXFx0XFx0XFx0XFx0XFxcImFyaWEtbGFiZWxsZWRieVxcXCI6IHVpRGlhbG9nVGl0bGUuYXR0cihcXFwiaWRcXFwiKVxcblxcdFxcdFxcdH0pO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X3RpdGxlOiBmdW5jdGlvbiBfdGl0bGUodGl0bGUpIHtcXG5cXHRcXHRcXHRpZiAoIXRoaXMub3B0aW9ucy50aXRsZSkge1xcblxcdFxcdFxcdFxcdHRpdGxlLmh0bWwoXFxcIiYjMTYwO1xcXCIpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR0aXRsZS50ZXh0KHRoaXMub3B0aW9ucy50aXRsZSk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfY3JlYXRlQnV0dG9uUGFuZTogZnVuY3Rpb24gX2NyZWF0ZUJ1dHRvblBhbmUoKSB7XFxuXFx0XFx0XFx0dGhpcy51aURpYWxvZ0J1dHRvblBhbmUgPSAkKFxcXCI8ZGl2PlxcXCIpLmFkZENsYXNzKFxcXCJ1aS1kaWFsb2ctYnV0dG9ucGFuZSB1aS13aWRnZXQtY29udGVudCB1aS1oZWxwZXItY2xlYXJmaXhcXFwiKTtcXG5cXG5cXHRcXHRcXHR0aGlzLnVpQnV0dG9uU2V0ID0gJChcXFwiPGRpdj5cXFwiKS5hZGRDbGFzcyhcXFwidWktZGlhbG9nLWJ1dHRvbnNldFxcXCIpLmFwcGVuZFRvKHRoaXMudWlEaWFsb2dCdXR0b25QYW5lKTtcXG5cXG5cXHRcXHRcXHR0aGlzLl9jcmVhdGVCdXR0b25zKCk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfY3JlYXRlQnV0dG9uczogZnVuY3Rpb24gX2NyZWF0ZUJ1dHRvbnMoKSB7XFxuXFx0XFx0XFx0dmFyIHRoYXQgPSB0aGlzLFxcblxcdFxcdFxcdCAgICBidXR0b25zID0gdGhpcy5vcHRpb25zLmJ1dHRvbnM7XFxuXFxuXFx0XFx0XFx0Ly8gaWYgd2UgYWxyZWFkeSBoYXZlIGEgYnV0dG9uIHBhbmUsIHJlbW92ZSBpdFxcblxcdFxcdFxcdHRoaXMudWlEaWFsb2dCdXR0b25QYW5lLnJlbW92ZSgpO1xcblxcdFxcdFxcdHRoaXMudWlCdXR0b25TZXQuZW1wdHkoKTtcXG5cXG5cXHRcXHRcXHRpZiAoJC5pc0VtcHR5T2JqZWN0KGJ1dHRvbnMpIHx8ICQuaXNBcnJheShidXR0b25zKSAmJiAhYnV0dG9ucy5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLnVpRGlhbG9nLnJlbW92ZUNsYXNzKFxcXCJ1aS1kaWFsb2ctYnV0dG9uc1xcXCIpO1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0JC5lYWNoKGJ1dHRvbnMsIGZ1bmN0aW9uIChuYW1lLCBwcm9wcykge1xcblxcdFxcdFxcdFxcdHZhciBjbGljaywgYnV0dG9uT3B0aW9ucztcXG5cXHRcXHRcXHRcXHRwcm9wcyA9ICQuaXNGdW5jdGlvbihwcm9wcykgPyB7IGNsaWNrOiBwcm9wcywgdGV4dDogbmFtZSB9IDogcHJvcHM7XFxuXFx0XFx0XFx0XFx0Ly8gRGVmYXVsdCB0byBhIG5vbi1zdWJtaXR0aW5nIGJ1dHRvblxcblxcdFxcdFxcdFxcdHByb3BzID0gJC5leHRlbmQoeyB0eXBlOiBcXFwiYnV0dG9uXFxcIiB9LCBwcm9wcyk7XFxuXFx0XFx0XFx0XFx0Ly8gQ2hhbmdlIHRoZSBjb250ZXh0IGZvciB0aGUgY2xpY2sgY2FsbGJhY2sgdG8gYmUgdGhlIG1haW4gZWxlbWVudFxcblxcdFxcdFxcdFxcdGNsaWNrID0gcHJvcHMuY2xpY2s7XFxuXFx0XFx0XFx0XFx0cHJvcHMuY2xpY2sgPSBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0XFx0Y2xpY2suYXBwbHkodGhhdC5lbGVtZW50WzBdLCBhcmd1bWVudHMpO1xcblxcdFxcdFxcdFxcdH07XFxuXFx0XFx0XFx0XFx0YnV0dG9uT3B0aW9ucyA9IHtcXG5cXHRcXHRcXHRcXHRcXHRpY29uczogcHJvcHMuaWNvbnMsXFxuXFx0XFx0XFx0XFx0XFx0dGV4dDogcHJvcHMuc2hvd1RleHRcXG5cXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdFxcdGRlbGV0ZSBwcm9wcy5pY29ucztcXG5cXHRcXHRcXHRcXHRkZWxldGUgcHJvcHMuc2hvd1RleHQ7XFxuXFx0XFx0XFx0XFx0JChcXFwiPGJ1dHRvbj48L2J1dHRvbj5cXFwiLCBwcm9wcykuYnV0dG9uKGJ1dHRvbk9wdGlvbnMpLmFwcGVuZFRvKHRoYXQudWlCdXR0b25TZXQpO1xcblxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdHRoaXMudWlEaWFsb2cuYWRkQ2xhc3MoXFxcInVpLWRpYWxvZy1idXR0b25zXFxcIik7XFxuXFx0XFx0XFx0dGhpcy51aURpYWxvZ0J1dHRvblBhbmUuYXBwZW5kVG8odGhpcy51aURpYWxvZyk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfbWFrZURyYWdnYWJsZTogZnVuY3Rpb24gX21ha2VEcmFnZ2FibGUoKSB7XFxuXFx0XFx0XFx0dmFyIHRoYXQgPSB0aGlzLFxcblxcdFxcdFxcdCAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xcblxcblxcdFxcdFxcdGZ1bmN0aW9uIGZpbHRlcmVkVWkodWkpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4ge1xcblxcdFxcdFxcdFxcdFxcdHBvc2l0aW9uOiB1aS5wb3NpdGlvbixcXG5cXHRcXHRcXHRcXHRcXHRvZmZzZXQ6IHVpLm9mZnNldFxcblxcdFxcdFxcdFxcdH07XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMudWlEaWFsb2cuZHJhZ2dhYmxlKHtcXG5cXHRcXHRcXHRcXHRjYW5jZWw6IFxcXCIudWktZGlhbG9nLWNvbnRlbnQsIC51aS1kaWFsb2ctdGl0bGViYXItY2xvc2VcXFwiLFxcblxcdFxcdFxcdFxcdGhhbmRsZTogXFxcIi51aS1kaWFsb2ctdGl0bGViYXJcXFwiLFxcblxcdFxcdFxcdFxcdGNvbnRhaW5tZW50OiBcXFwiZG9jdW1lbnRcXFwiLFxcblxcdFxcdFxcdFxcdHN0YXJ0OiBmdW5jdGlvbiBzdGFydChldmVudCwgdWkpIHtcXG5cXHRcXHRcXHRcXHRcXHQkKHRoaXMpLmFkZENsYXNzKFxcXCJ1aS1kaWFsb2ctZHJhZ2dpbmdcXFwiKTtcXG5cXHRcXHRcXHRcXHRcXHR0aGF0Ll9ibG9ja0ZyYW1lcygpO1xcblxcdFxcdFxcdFxcdFxcdHRoYXQuX3RyaWdnZXIoXFxcImRyYWdTdGFydFxcXCIsIGV2ZW50LCBmaWx0ZXJlZFVpKHVpKSk7XFxuXFx0XFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRcXHRkcmFnOiBmdW5jdGlvbiBkcmFnKGV2ZW50LCB1aSkge1xcblxcdFxcdFxcdFxcdFxcdHRoYXQuX3RyaWdnZXIoXFxcImRyYWdcXFwiLCBldmVudCwgZmlsdGVyZWRVaSh1aSkpO1xcblxcdFxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0XFx0c3RvcDogZnVuY3Rpb24gc3RvcChldmVudCwgdWkpIHtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgbGVmdCA9IHVpLm9mZnNldC5sZWZ0IC0gdGhhdC5kb2N1bWVudC5zY3JvbGxMZWZ0KCksXFxuXFx0XFx0XFx0XFx0XFx0ICAgIHRvcCA9IHVpLm9mZnNldC50b3AgLSB0aGF0LmRvY3VtZW50LnNjcm9sbFRvcCgpO1xcblxcblxcdFxcdFxcdFxcdFxcdG9wdGlvbnMucG9zaXRpb24gPSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0bXk6IFxcXCJsZWZ0IHRvcFxcXCIsXFxuXFx0XFx0XFx0XFx0XFx0XFx0YXQ6IFxcXCJsZWZ0XFxcIiArIChsZWZ0ID49IDAgPyBcXFwiK1xcXCIgOiBcXFwiXFxcIikgKyBsZWZ0ICsgXFxcIiBcXFwiICsgXFxcInRvcFxcXCIgKyAodG9wID49IDAgPyBcXFwiK1xcXCIgOiBcXFwiXFxcIikgKyB0b3AsXFxuXFx0XFx0XFx0XFx0XFx0XFx0b2Y6IHRoYXQud2luZG93XFxuXFx0XFx0XFx0XFx0XFx0fTtcXG5cXHRcXHRcXHRcXHRcXHQkKHRoaXMpLnJlbW92ZUNsYXNzKFxcXCJ1aS1kaWFsb2ctZHJhZ2dpbmdcXFwiKTtcXG5cXHRcXHRcXHRcXHRcXHR0aGF0Ll91bmJsb2NrRnJhbWVzKCk7XFxuXFx0XFx0XFx0XFx0XFx0dGhhdC5fdHJpZ2dlcihcXFwiZHJhZ1N0b3BcXFwiLCBldmVudCwgZmlsdGVyZWRVaSh1aSkpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9tYWtlUmVzaXphYmxlOiBmdW5jdGlvbiBfbWFrZVJlc2l6YWJsZSgpIHtcXG5cXHRcXHRcXHR2YXIgdGhhdCA9IHRoaXMsXFxuXFx0XFx0XFx0ICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXFxuXFx0XFx0XFx0ICAgIGhhbmRsZXMgPSBvcHRpb25zLnJlc2l6YWJsZSxcXG5cXG5cXHRcXHRcXHQvLyAudWktcmVzaXphYmxlIGhhcyBwb3NpdGlvbjogcmVsYXRpdmUgZGVmaW5lZCBpbiB0aGUgc3R5bGVzaGVldFxcblxcdFxcdFxcdC8vIGJ1dCBkaWFsb2dzIGhhdmUgdG8gdXNlIGFic29sdXRlIG9yIGZpeGVkIHBvc2l0aW9uaW5nXFxuXFx0XFx0XFx0cG9zaXRpb24gPSB0aGlzLnVpRGlhbG9nLmNzcyhcXFwicG9zaXRpb25cXFwiKSxcXG5cXHRcXHRcXHQgICAgcmVzaXplSGFuZGxlcyA9IHR5cGVvZiBoYW5kbGVzID09PSBcXFwic3RyaW5nXFxcIiA/IGhhbmRsZXMgOiBcXFwibixlLHMsdyxzZSxzdyxuZSxud1xcXCI7XFxuXFxuXFx0XFx0XFx0ZnVuY3Rpb24gZmlsdGVyZWRVaSh1aSkge1xcblxcdFxcdFxcdFxcdHJldHVybiB7XFxuXFx0XFx0XFx0XFx0XFx0b3JpZ2luYWxQb3NpdGlvbjogdWkub3JpZ2luYWxQb3NpdGlvbixcXG5cXHRcXHRcXHRcXHRcXHRvcmlnaW5hbFNpemU6IHVpLm9yaWdpbmFsU2l6ZSxcXG5cXHRcXHRcXHRcXHRcXHRwb3NpdGlvbjogdWkucG9zaXRpb24sXFxuXFx0XFx0XFx0XFx0XFx0c2l6ZTogdWkuc2l6ZVxcblxcdFxcdFxcdFxcdH07XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMudWlEaWFsb2cucmVzaXphYmxlKHtcXG5cXHRcXHRcXHRcXHRjYW5jZWw6IFxcXCIudWktZGlhbG9nLWNvbnRlbnRcXFwiLFxcblxcdFxcdFxcdFxcdGNvbnRhaW5tZW50OiBcXFwiZG9jdW1lbnRcXFwiLFxcblxcdFxcdFxcdFxcdGFsc29SZXNpemU6IHRoaXMuZWxlbWVudCxcXG5cXHRcXHRcXHRcXHRtYXhXaWR0aDogb3B0aW9ucy5tYXhXaWR0aCxcXG5cXHRcXHRcXHRcXHRtYXhIZWlnaHQ6IG9wdGlvbnMubWF4SGVpZ2h0LFxcblxcdFxcdFxcdFxcdG1pbldpZHRoOiBvcHRpb25zLm1pbldpZHRoLFxcblxcdFxcdFxcdFxcdG1pbkhlaWdodDogdGhpcy5fbWluSGVpZ2h0KCksXFxuXFx0XFx0XFx0XFx0aGFuZGxlczogcmVzaXplSGFuZGxlcyxcXG5cXHRcXHRcXHRcXHRzdGFydDogZnVuY3Rpb24gc3RhcnQoZXZlbnQsIHVpKSB7XFxuXFx0XFx0XFx0XFx0XFx0JCh0aGlzKS5hZGRDbGFzcyhcXFwidWktZGlhbG9nLXJlc2l6aW5nXFxcIik7XFxuXFx0XFx0XFx0XFx0XFx0dGhhdC5fYmxvY2tGcmFtZXMoKTtcXG5cXHRcXHRcXHRcXHRcXHR0aGF0Ll90cmlnZ2VyKFxcXCJyZXNpemVTdGFydFxcXCIsIGV2ZW50LCBmaWx0ZXJlZFVpKHVpKSk7XFxuXFx0XFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRcXHRyZXNpemU6IGZ1bmN0aW9uIHJlc2l6ZShldmVudCwgdWkpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGF0Ll90cmlnZ2VyKFxcXCJyZXNpemVcXFwiLCBldmVudCwgZmlsdGVyZWRVaSh1aSkpO1xcblxcdFxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0XFx0c3RvcDogZnVuY3Rpb24gc3RvcChldmVudCwgdWkpIHtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgb2Zmc2V0ID0gdGhhdC51aURpYWxvZy5vZmZzZXQoKSxcXG5cXHRcXHRcXHRcXHRcXHQgICAgbGVmdCA9IG9mZnNldC5sZWZ0IC0gdGhhdC5kb2N1bWVudC5zY3JvbGxMZWZ0KCksXFxuXFx0XFx0XFx0XFx0XFx0ICAgIHRvcCA9IG9mZnNldC50b3AgLSB0aGF0LmRvY3VtZW50LnNjcm9sbFRvcCgpO1xcblxcblxcdFxcdFxcdFxcdFxcdG9wdGlvbnMuaGVpZ2h0ID0gdGhhdC51aURpYWxvZy5oZWlnaHQoKTtcXG5cXHRcXHRcXHRcXHRcXHRvcHRpb25zLndpZHRoID0gdGhhdC51aURpYWxvZy53aWR0aCgpO1xcblxcdFxcdFxcdFxcdFxcdG9wdGlvbnMucG9zaXRpb24gPSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0bXk6IFxcXCJsZWZ0IHRvcFxcXCIsXFxuXFx0XFx0XFx0XFx0XFx0XFx0YXQ6IFxcXCJsZWZ0XFxcIiArIChsZWZ0ID49IDAgPyBcXFwiK1xcXCIgOiBcXFwiXFxcIikgKyBsZWZ0ICsgXFxcIiBcXFwiICsgXFxcInRvcFxcXCIgKyAodG9wID49IDAgPyBcXFwiK1xcXCIgOiBcXFwiXFxcIikgKyB0b3AsXFxuXFx0XFx0XFx0XFx0XFx0XFx0b2Y6IHRoYXQud2luZG93XFxuXFx0XFx0XFx0XFx0XFx0fTtcXG5cXHRcXHRcXHRcXHRcXHQkKHRoaXMpLnJlbW92ZUNsYXNzKFxcXCJ1aS1kaWFsb2ctcmVzaXppbmdcXFwiKTtcXG5cXHRcXHRcXHRcXHRcXHR0aGF0Ll91bmJsb2NrRnJhbWVzKCk7XFxuXFx0XFx0XFx0XFx0XFx0dGhhdC5fdHJpZ2dlcihcXFwicmVzaXplU3RvcFxcXCIsIGV2ZW50LCBmaWx0ZXJlZFVpKHVpKSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0pLmNzcyhcXFwicG9zaXRpb25cXFwiLCBwb3NpdGlvbik7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfdHJhY2tGb2N1czogZnVuY3Rpb24gX3RyYWNrRm9jdXMoKSB7XFxuXFx0XFx0XFx0dGhpcy5fb24odGhpcy53aWRnZXQoKSwge1xcblxcdFxcdFxcdFxcdGZvY3VzaW46IGZ1bmN0aW9uIGZvY3VzaW4oZXZlbnQpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9tYWtlRm9jdXNUYXJnZXQoKTtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9mb2N1c2VkRWxlbWVudCA9ICQoZXZlbnQudGFyZ2V0KTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfbWFrZUZvY3VzVGFyZ2V0OiBmdW5jdGlvbiBfbWFrZUZvY3VzVGFyZ2V0KCkge1xcblxcdFxcdFxcdHRoaXMuX3VudHJhY2tJbnN0YW5jZSgpO1xcblxcdFxcdFxcdHRoaXMuX3RyYWNraW5nSW5zdGFuY2VzKCkudW5zaGlmdCh0aGlzKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF91bnRyYWNrSW5zdGFuY2U6IGZ1bmN0aW9uIF91bnRyYWNrSW5zdGFuY2UoKSB7XFxuXFx0XFx0XFx0dmFyIGluc3RhbmNlcyA9IHRoaXMuX3RyYWNraW5nSW5zdGFuY2VzKCksXFxuXFx0XFx0XFx0ICAgIGV4aXN0cyA9ICQuaW5BcnJheSh0aGlzLCBpbnN0YW5jZXMpO1xcblxcdFxcdFxcdGlmIChleGlzdHMgIT09IC0xKSB7XFxuXFx0XFx0XFx0XFx0aW5zdGFuY2VzLnNwbGljZShleGlzdHMsIDEpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcblxcdFxcdF90cmFja2luZ0luc3RhbmNlczogZnVuY3Rpb24gX3RyYWNraW5nSW5zdGFuY2VzKCkge1xcblxcdFxcdFxcdHZhciBpbnN0YW5jZXMgPSB0aGlzLmRvY3VtZW50LmRhdGEoXFxcInVpLWRpYWxvZy1pbnN0YW5jZXNcXFwiKTtcXG5cXHRcXHRcXHRpZiAoIWluc3RhbmNlcykge1xcblxcdFxcdFxcdFxcdGluc3RhbmNlcyA9IFtdO1xcblxcdFxcdFxcdFxcdHRoaXMuZG9jdW1lbnQuZGF0YShcXFwidWktZGlhbG9nLWluc3RhbmNlc1xcXCIsIGluc3RhbmNlcyk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiBpbnN0YW5jZXM7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfbWluSGVpZ2h0OiBmdW5jdGlvbiBfbWluSGVpZ2h0KCkge1xcblxcdFxcdFxcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xcblxcblxcdFxcdFxcdHJldHVybiBvcHRpb25zLmhlaWdodCA9PT0gXFxcImF1dG9cXFwiID8gb3B0aW9ucy5taW5IZWlnaHQgOiBNYXRoLm1pbihvcHRpb25zLm1pbkhlaWdodCwgb3B0aW9ucy5oZWlnaHQpO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X3Bvc2l0aW9uOiBmdW5jdGlvbiBfcG9zaXRpb24oKSB7XFxuXFx0XFx0XFx0Ly8gTmVlZCB0byBzaG93IHRoZSBkaWFsb2cgdG8gZ2V0IHRoZSBhY3R1YWwgb2Zmc2V0IGluIHRoZSBwb3NpdGlvbiBwbHVnaW5cXG5cXHRcXHRcXHR2YXIgaXNWaXNpYmxlID0gdGhpcy51aURpYWxvZy5pcyhcXFwiOnZpc2libGVcXFwiKTtcXG5cXHRcXHRcXHRpZiAoIWlzVmlzaWJsZSkge1xcblxcdFxcdFxcdFxcdHRoaXMudWlEaWFsb2cuc2hvdygpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR0aGlzLnVpRGlhbG9nLnBvc2l0aW9uKHRoaXMub3B0aW9ucy5wb3NpdGlvbik7XFxuXFx0XFx0XFx0aWYgKCFpc1Zpc2libGUpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLnVpRGlhbG9nLmhpZGUoKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfc2V0T3B0aW9uczogZnVuY3Rpb24gX3NldE9wdGlvbnMob3B0aW9ucykge1xcblxcdFxcdFxcdHZhciB0aGF0ID0gdGhpcyxcXG5cXHRcXHRcXHQgICAgcmVzaXplID0gZmFsc2UsXFxuXFx0XFx0XFx0ICAgIHJlc2l6YWJsZU9wdGlvbnMgPSB7fTtcXG5cXG5cXHRcXHRcXHQkLmVhY2gob3B0aW9ucywgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcXG5cXHRcXHRcXHRcXHR0aGF0Ll9zZXRPcHRpb24oa2V5LCB2YWx1ZSk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKGtleSBpbiB0aGF0LnNpemVSZWxhdGVkT3B0aW9ucykge1xcblxcdFxcdFxcdFxcdFxcdHJlc2l6ZSA9IHRydWU7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGlmIChrZXkgaW4gdGhhdC5yZXNpemFibGVSZWxhdGVkT3B0aW9ucykge1xcblxcdFxcdFxcdFxcdFxcdHJlc2l6YWJsZU9wdGlvbnNba2V5XSA9IHZhbHVlO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9KTtcXG5cXG5cXHRcXHRcXHRpZiAocmVzaXplKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5fc2l6ZSgpO1xcblxcdFxcdFxcdFxcdHRoaXMuX3Bvc2l0aW9uKCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICh0aGlzLnVpRGlhbG9nLmlzKFxcXCI6ZGF0YSh1aS1yZXNpemFibGUpXFxcIikpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLnVpRGlhbG9nLnJlc2l6YWJsZShcXFwib3B0aW9uXFxcIiwgcmVzaXphYmxlT3B0aW9ucyk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFxuXFx0XFx0X3NldE9wdGlvbjogZnVuY3Rpb24gX3NldE9wdGlvbihrZXksIHZhbHVlKSB7XFxuXFx0XFx0XFx0dmFyIGlzRHJhZ2dhYmxlLFxcblxcdFxcdFxcdCAgICBpc1Jlc2l6YWJsZSxcXG5cXHRcXHRcXHQgICAgdWlEaWFsb2cgPSB0aGlzLnVpRGlhbG9nO1xcblxcblxcdFxcdFxcdGlmIChrZXkgPT09IFxcXCJkaWFsb2dDbGFzc1xcXCIpIHtcXG5cXHRcXHRcXHRcXHR1aURpYWxvZy5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuZGlhbG9nQ2xhc3MpLmFkZENsYXNzKHZhbHVlKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKGtleSA9PT0gXFxcImRpc2FibGVkXFxcIikge1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy5fc3VwZXIoa2V5LCB2YWx1ZSk7XFxuXFxuXFx0XFx0XFx0aWYgKGtleSA9PT0gXFxcImFwcGVuZFRvXFxcIikge1xcblxcdFxcdFxcdFxcdHRoaXMudWlEaWFsb2cuYXBwZW5kVG8odGhpcy5fYXBwZW5kVG8oKSk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmIChrZXkgPT09IFxcXCJidXR0b25zXFxcIikge1xcblxcdFxcdFxcdFxcdHRoaXMuX2NyZWF0ZUJ1dHRvbnMoKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKGtleSA9PT0gXFxcImNsb3NlVGV4dFxcXCIpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLnVpRGlhbG9nVGl0bGViYXJDbG9zZS5idXR0b24oe1xcblxcdFxcdFxcdFxcdFxcdC8vIEVuc3VyZSB0aGF0IHdlIGFsd2F5cyBwYXNzIGEgc3RyaW5nXFxuXFx0XFx0XFx0XFx0XFx0bGFiZWw6IFxcXCJcXFwiICsgdmFsdWVcXG5cXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKGtleSA9PT0gXFxcImRyYWdnYWJsZVxcXCIpIHtcXG5cXHRcXHRcXHRcXHRpc0RyYWdnYWJsZSA9IHVpRGlhbG9nLmlzKFxcXCI6ZGF0YSh1aS1kcmFnZ2FibGUpXFxcIik7XFxuXFx0XFx0XFx0XFx0aWYgKGlzRHJhZ2dhYmxlICYmICF2YWx1ZSkge1xcblxcdFxcdFxcdFxcdFxcdHVpRGlhbG9nLmRyYWdnYWJsZShcXFwiZGVzdHJveVxcXCIpO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAoIWlzRHJhZ2dhYmxlICYmIHZhbHVlKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fbWFrZURyYWdnYWJsZSgpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKGtleSA9PT0gXFxcInBvc2l0aW9uXFxcIikge1xcblxcdFxcdFxcdFxcdHRoaXMuX3Bvc2l0aW9uKCk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmIChrZXkgPT09IFxcXCJyZXNpemFibGVcXFwiKSB7XFxuXFx0XFx0XFx0XFx0Ly8gY3VycmVudGx5IHJlc2l6YWJsZSwgYmVjb21pbmcgbm9uLXJlc2l6YWJsZVxcblxcdFxcdFxcdFxcdGlzUmVzaXphYmxlID0gdWlEaWFsb2cuaXMoXFxcIjpkYXRhKHVpLXJlc2l6YWJsZSlcXFwiKTtcXG5cXHRcXHRcXHRcXHRpZiAoaXNSZXNpemFibGUgJiYgIXZhbHVlKSB7XFxuXFx0XFx0XFx0XFx0XFx0dWlEaWFsb2cucmVzaXphYmxlKFxcXCJkZXN0cm95XFxcIik7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIGN1cnJlbnRseSByZXNpemFibGUsIGNoYW5naW5nIGhhbmRsZXNcXG5cXHRcXHRcXHRcXHRpZiAoaXNSZXNpemFibGUgJiYgdHlwZW9mIHZhbHVlID09PSBcXFwic3RyaW5nXFxcIikge1xcblxcdFxcdFxcdFxcdFxcdHVpRGlhbG9nLnJlc2l6YWJsZShcXFwib3B0aW9uXFxcIiwgXFxcImhhbmRsZXNcXFwiLCB2YWx1ZSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIGN1cnJlbnRseSBub24tcmVzaXphYmxlLCBiZWNvbWluZyByZXNpemFibGVcXG5cXHRcXHRcXHRcXHRpZiAoIWlzUmVzaXphYmxlICYmIHZhbHVlICE9PSBmYWxzZSkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX21ha2VSZXNpemFibGUoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmIChrZXkgPT09IFxcXCJ0aXRsZVxcXCIpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl90aXRsZSh0aGlzLnVpRGlhbG9nVGl0bGViYXIuZmluZChcXFwiLnVpLWRpYWxvZy10aXRsZVxcXCIpKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfc2l6ZTogZnVuY3Rpb24gX3NpemUoKSB7XFxuXFx0XFx0XFx0Ly8gSWYgdGhlIHVzZXIgaGFzIHJlc2l6ZWQgdGhlIGRpYWxvZywgdGhlIC51aS1kaWFsb2cgYW5kIC51aS1kaWFsb2ctY29udGVudFxcblxcdFxcdFxcdC8vIGRpdnMgd2lsbCBib3RoIGhhdmUgd2lkdGggYW5kIGhlaWdodCBzZXQsIHNvIHdlIG5lZWQgdG8gcmVzZXQgdGhlbVxcblxcdFxcdFxcdHZhciBub25Db250ZW50SGVpZ2h0LFxcblxcdFxcdFxcdCAgICBtaW5Db250ZW50SGVpZ2h0LFxcblxcdFxcdFxcdCAgICBtYXhDb250ZW50SGVpZ2h0LFxcblxcdFxcdFxcdCAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xcblxcblxcdFxcdFxcdC8vIFJlc2V0IGNvbnRlbnQgc2l6aW5nXFxuXFx0XFx0XFx0dGhpcy5lbGVtZW50LnNob3coKS5jc3Moe1xcblxcdFxcdFxcdFxcdHdpZHRoOiBcXFwiYXV0b1xcXCIsXFxuXFx0XFx0XFx0XFx0bWluSGVpZ2h0OiAwLFxcblxcdFxcdFxcdFxcdG1heEhlaWdodDogXFxcIm5vbmVcXFwiLFxcblxcdFxcdFxcdFxcdGhlaWdodDogMFxcblxcdFxcdFxcdH0pO1xcblxcblxcdFxcdFxcdGlmIChvcHRpb25zLm1pbldpZHRoID4gb3B0aW9ucy53aWR0aCkge1xcblxcdFxcdFxcdFxcdG9wdGlvbnMud2lkdGggPSBvcHRpb25zLm1pbldpZHRoO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyByZXNldCB3cmFwcGVyIHNpemluZ1xcblxcdFxcdFxcdC8vIGRldGVybWluZSB0aGUgaGVpZ2h0IG9mIGFsbCB0aGUgbm9uLWNvbnRlbnQgZWxlbWVudHNcXG5cXHRcXHRcXHRub25Db250ZW50SGVpZ2h0ID0gdGhpcy51aURpYWxvZy5jc3Moe1xcblxcdFxcdFxcdFxcdGhlaWdodDogXFxcImF1dG9cXFwiLFxcblxcdFxcdFxcdFxcdHdpZHRoOiBvcHRpb25zLndpZHRoXFxuXFx0XFx0XFx0fSkub3V0ZXJIZWlnaHQoKTtcXG5cXHRcXHRcXHRtaW5Db250ZW50SGVpZ2h0ID0gTWF0aC5tYXgoMCwgb3B0aW9ucy5taW5IZWlnaHQgLSBub25Db250ZW50SGVpZ2h0KTtcXG5cXHRcXHRcXHRtYXhDb250ZW50SGVpZ2h0ID0gdHlwZW9mIG9wdGlvbnMubWF4SGVpZ2h0ID09PSBcXFwibnVtYmVyXFxcIiA/IE1hdGgubWF4KDAsIG9wdGlvbnMubWF4SGVpZ2h0IC0gbm9uQ29udGVudEhlaWdodCkgOiBcXFwibm9uZVxcXCI7XFxuXFxuXFx0XFx0XFx0aWYgKG9wdGlvbnMuaGVpZ2h0ID09PSBcXFwiYXV0b1xcXCIpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLmVsZW1lbnQuY3NzKHtcXG5cXHRcXHRcXHRcXHRcXHRtaW5IZWlnaHQ6IG1pbkNvbnRlbnRIZWlnaHQsXFxuXFx0XFx0XFx0XFx0XFx0bWF4SGVpZ2h0OiBtYXhDb250ZW50SGVpZ2h0LFxcblxcdFxcdFxcdFxcdFxcdGhlaWdodDogXFxcImF1dG9cXFwiXFxuXFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHR0aGlzLmVsZW1lbnQuaGVpZ2h0KE1hdGgubWF4KDAsIG9wdGlvbnMuaGVpZ2h0IC0gbm9uQ29udGVudEhlaWdodCkpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAodGhpcy51aURpYWxvZy5pcyhcXFwiOmRhdGEodWktcmVzaXphYmxlKVxcXCIpKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy51aURpYWxvZy5yZXNpemFibGUoXFxcIm9wdGlvblxcXCIsIFxcXCJtaW5IZWlnaHRcXFwiLCB0aGlzLl9taW5IZWlnaHQoKSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFxuXFx0XFx0X2Jsb2NrRnJhbWVzOiBmdW5jdGlvbiBfYmxvY2tGcmFtZXMoKSB7XFxuXFx0XFx0XFx0dGhpcy5pZnJhbWVCbG9ja3MgPSB0aGlzLmRvY3VtZW50LmZpbmQoXFxcImlmcmFtZVxcXCIpLm1hcChmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0dmFyIGlmcmFtZSA9ICQodGhpcyk7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuICQoXFxcIjxkaXY+XFxcIikuY3NzKHtcXG5cXHRcXHRcXHRcXHRcXHRwb3NpdGlvbjogXFxcImFic29sdXRlXFxcIixcXG5cXHRcXHRcXHRcXHRcXHR3aWR0aDogaWZyYW1lLm91dGVyV2lkdGgoKSxcXG5cXHRcXHRcXHRcXHRcXHRoZWlnaHQ6IGlmcmFtZS5vdXRlckhlaWdodCgpXFxuXFx0XFx0XFx0XFx0fSkuYXBwZW5kVG8oaWZyYW1lLnBhcmVudCgpKS5vZmZzZXQoaWZyYW1lLm9mZnNldCgpKVswXTtcXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF91bmJsb2NrRnJhbWVzOiBmdW5jdGlvbiBfdW5ibG9ja0ZyYW1lcygpIHtcXG5cXHRcXHRcXHRpZiAodGhpcy5pZnJhbWVCbG9ja3MpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLmlmcmFtZUJsb2Nrcy5yZW1vdmUoKTtcXG5cXHRcXHRcXHRcXHRkZWxldGUgdGhpcy5pZnJhbWVCbG9ja3M7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFxuXFx0XFx0X2FsbG93SW50ZXJhY3Rpb246IGZ1bmN0aW9uIF9hbGxvd0ludGVyYWN0aW9uKGV2ZW50KSB7XFxuXFx0XFx0XFx0aWYgKCQoZXZlbnQudGFyZ2V0KS5jbG9zZXN0KFxcXCIudWktZGlhbG9nXFxcIikubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFRPRE86IFJlbW92ZSBoYWNrIHdoZW4gZGF0ZXBpY2tlciBpbXBsZW1lbnRzXFxuXFx0XFx0XFx0Ly8gdGhlIC51aS1mcm9udCBsb2dpYyAoIzg5ODkpXFxuXFx0XFx0XFx0cmV0dXJuICEhJChldmVudC50YXJnZXQpLmNsb3Nlc3QoXFxcIi51aS1kYXRlcGlja2VyXFxcIikubGVuZ3RoO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X2NyZWF0ZU92ZXJsYXk6IGZ1bmN0aW9uIF9jcmVhdGVPdmVybGF5KCkge1xcblxcdFxcdFxcdGlmICghdGhpcy5vcHRpb25zLm1vZGFsKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBXZSB1c2UgYSBkZWxheSBpbiBjYXNlIHRoZSBvdmVybGF5IGlzIGNyZWF0ZWQgZnJvbSBhblxcblxcdFxcdFxcdC8vIGV2ZW50IHRoYXQgd2UncmUgZ29pbmcgdG8gYmUgY2FuY2VsbGluZyAoIzI4MDQpXFxuXFx0XFx0XFx0dmFyIGlzT3BlbmluZyA9IHRydWU7XFxuXFx0XFx0XFx0dGhpcy5fZGVsYXkoZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdGlzT3BlbmluZyA9IGZhbHNlO1xcblxcdFxcdFxcdH0pO1xcblxcblxcdFxcdFxcdGlmICghdGhpcy5kb2N1bWVudC5kYXRhKFxcXCJ1aS1kaWFsb2ctb3ZlcmxheXNcXFwiKSkge1xcblxcblxcdFxcdFxcdFxcdC8vIFByZXZlbnQgdXNlIG9mIGFuY2hvcnMgYW5kIGlucHV0c1xcblxcdFxcdFxcdFxcdC8vIFVzaW5nIF9vbigpIGZvciBhbiBldmVudCBoYW5kbGVyIHNoYXJlZCBhY3Jvc3MgbWFueSBpbnN0YW5jZXMgaXNcXG5cXHRcXHRcXHRcXHQvLyBzYWZlIGJlY2F1c2UgdGhlIGRpYWxvZ3Mgc3RhY2sgYW5kIG11c3QgYmUgY2xvc2VkIGluIHJldmVyc2Ugb3JkZXJcXG5cXHRcXHRcXHRcXHR0aGlzLl9vbih0aGlzLmRvY3VtZW50LCB7XFxuXFx0XFx0XFx0XFx0XFx0Zm9jdXNpbjogZnVuY3Rpb24gZm9jdXNpbihldmVudCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChpc09wZW5pbmcpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICghdGhpcy5fYWxsb3dJbnRlcmFjdGlvbihldmVudCkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuX3RyYWNraW5nSW5zdGFuY2VzKClbMF0uX2ZvY3VzVGFiYmFibGUoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLm92ZXJsYXkgPSAkKFxcXCI8ZGl2PlxcXCIpLmFkZENsYXNzKFxcXCJ1aS13aWRnZXQtb3ZlcmxheSB1aS1mcm9udFxcXCIpLmFwcGVuZFRvKHRoaXMuX2FwcGVuZFRvKCkpO1xcblxcdFxcdFxcdHRoaXMuX29uKHRoaXMub3ZlcmxheSwge1xcblxcdFxcdFxcdFxcdG1vdXNlZG93bjogXFxcIl9rZWVwRm9jdXNcXFwiXFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0dGhpcy5kb2N1bWVudC5kYXRhKFxcXCJ1aS1kaWFsb2ctb3ZlcmxheXNcXFwiLCAodGhpcy5kb2N1bWVudC5kYXRhKFxcXCJ1aS1kaWFsb2ctb3ZlcmxheXNcXFwiKSB8fCAwKSArIDEpO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X2Rlc3Ryb3lPdmVybGF5OiBmdW5jdGlvbiBfZGVzdHJveU92ZXJsYXkoKSB7XFxuXFx0XFx0XFx0aWYgKCF0aGlzLm9wdGlvbnMubW9kYWwpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICh0aGlzLm92ZXJsYXkpIHtcXG5cXHRcXHRcXHRcXHR2YXIgb3ZlcmxheXMgPSB0aGlzLmRvY3VtZW50LmRhdGEoXFxcInVpLWRpYWxvZy1vdmVybGF5c1xcXCIpIC0gMTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIW92ZXJsYXlzKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5kb2N1bWVudC51bmJpbmQoXFxcImZvY3VzaW5cXFwiKS5yZW1vdmVEYXRhKFxcXCJ1aS1kaWFsb2ctb3ZlcmxheXNcXFwiKTtcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuZG9jdW1lbnQuZGF0YShcXFwidWktZGlhbG9nLW92ZXJsYXlzXFxcIiwgb3ZlcmxheXMpO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR0aGlzLm92ZXJsYXkucmVtb3ZlKCk7XFxuXFx0XFx0XFx0XFx0dGhpcy5vdmVybGF5ID0gbnVsbDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH0pO1xcblxcblxcdC8qIVxcbiAgKiBqUXVlcnkgVUkgRHJvcHBhYmxlIDEuMTEuNFxcbiAgKiBodHRwOi8vanF1ZXJ5dWkuY29tXFxuICAqXFxuICAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXFxuICAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cXG4gICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxcbiAgKlxcbiAgKiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9kcm9wcGFibGUvXFxuICAqL1xcblxcblxcdCQud2lkZ2V0KFxcXCJ1aS5kcm9wcGFibGVcXFwiLCB7XFxuXFx0XFx0dmVyc2lvbjogXFxcIjEuMTEuNFxcXCIsXFxuXFx0XFx0d2lkZ2V0RXZlbnRQcmVmaXg6IFxcXCJkcm9wXFxcIixcXG5cXHRcXHRvcHRpb25zOiB7XFxuXFx0XFx0XFx0YWNjZXB0OiBcXFwiKlxcXCIsXFxuXFx0XFx0XFx0YWN0aXZlQ2xhc3M6IGZhbHNlLFxcblxcdFxcdFxcdGFkZENsYXNzZXM6IHRydWUsXFxuXFx0XFx0XFx0Z3JlZWR5OiBmYWxzZSxcXG5cXHRcXHRcXHRob3ZlckNsYXNzOiBmYWxzZSxcXG5cXHRcXHRcXHRzY29wZTogXFxcImRlZmF1bHRcXFwiLFxcblxcdFxcdFxcdHRvbGVyYW5jZTogXFxcImludGVyc2VjdFxcXCIsXFxuXFxuXFx0XFx0XFx0Ly8gY2FsbGJhY2tzXFxuXFx0XFx0XFx0YWN0aXZhdGU6IG51bGwsXFxuXFx0XFx0XFx0ZGVhY3RpdmF0ZTogbnVsbCxcXG5cXHRcXHRcXHRkcm9wOiBudWxsLFxcblxcdFxcdFxcdG91dDogbnVsbCxcXG5cXHRcXHRcXHRvdmVyOiBudWxsXFxuXFx0XFx0fSxcXG5cXHRcXHRfY3JlYXRlOiBmdW5jdGlvbiBfY3JlYXRlKCkge1xcblxcblxcdFxcdFxcdHZhciBwcm9wb3J0aW9ucyxcXG5cXHRcXHRcXHQgICAgbyA9IHRoaXMub3B0aW9ucyxcXG5cXHRcXHRcXHQgICAgYWNjZXB0ID0gby5hY2NlcHQ7XFxuXFxuXFx0XFx0XFx0dGhpcy5pc292ZXIgPSBmYWxzZTtcXG5cXHRcXHRcXHR0aGlzLmlzb3V0ID0gdHJ1ZTtcXG5cXG5cXHRcXHRcXHR0aGlzLmFjY2VwdCA9ICQuaXNGdW5jdGlvbihhY2NlcHQpID8gYWNjZXB0IDogZnVuY3Rpb24gKGQpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZC5pcyhhY2NlcHQpO1xcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0XFx0dGhpcy5wcm9wb3J0aW9ucyA9IGZ1bmN0aW9uICgpIC8qIHZhbHVlVG9Xcml0ZSAqL3tcXG5cXHRcXHRcXHRcXHRpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdFxcdC8vIFN0b3JlIHRoZSBkcm9wcGFibGUncyBwcm9wb3J0aW9uc1xcblxcdFxcdFxcdFxcdFxcdHByb3BvcnRpb25zID0gYXJndW1lbnRzWzBdO1xcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gUmV0cmlldmUgb3IgZGVyaXZlIHRoZSBkcm9wcGFibGUncyBwcm9wb3J0aW9uc1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBwcm9wb3J0aW9ucyA/IHByb3BvcnRpb25zIDogcHJvcG9ydGlvbnMgPSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0d2lkdGg6IHRoaXMuZWxlbWVudFswXS5vZmZzZXRXaWR0aCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRoZWlnaHQ6IHRoaXMuZWxlbWVudFswXS5vZmZzZXRIZWlnaHRcXG5cXHRcXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdFxcdHRoaXMuX2FkZFRvTWFuYWdlcihvLnNjb3BlKTtcXG5cXG5cXHRcXHRcXHRvLmFkZENsYXNzZXMgJiYgdGhpcy5lbGVtZW50LmFkZENsYXNzKFxcXCJ1aS1kcm9wcGFibGVcXFwiKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9hZGRUb01hbmFnZXI6IGZ1bmN0aW9uIF9hZGRUb01hbmFnZXIoc2NvcGUpIHtcXG5cXHRcXHRcXHQvLyBBZGQgdGhlIHJlZmVyZW5jZSBhbmQgcG9zaXRpb25zIHRvIHRoZSBtYW5hZ2VyXFxuXFx0XFx0XFx0JC51aS5kZG1hbmFnZXIuZHJvcHBhYmxlc1tzY29wZV0gPSAkLnVpLmRkbWFuYWdlci5kcm9wcGFibGVzW3Njb3BlXSB8fCBbXTtcXG5cXHRcXHRcXHQkLnVpLmRkbWFuYWdlci5kcm9wcGFibGVzW3Njb3BlXS5wdXNoKHRoaXMpO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X3NwbGljZTogZnVuY3Rpb24gX3NwbGljZShkcm9wKSB7XFxuXFx0XFx0XFx0dmFyIGkgPSAwO1xcblxcdFxcdFxcdGZvciAoOyBpIDwgZHJvcC5sZW5ndGg7IGkrKykge1xcblxcdFxcdFxcdFxcdGlmIChkcm9wW2ldID09PSB0aGlzKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZHJvcC5zcGxpY2UoaSwgMSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcblxcdFxcdF9kZXN0cm95OiBmdW5jdGlvbiBfZGVzdHJveSgpIHtcXG5cXHRcXHRcXHR2YXIgZHJvcCA9ICQudWkuZGRtYW5hZ2VyLmRyb3BwYWJsZXNbdGhpcy5vcHRpb25zLnNjb3BlXTtcXG5cXG5cXHRcXHRcXHR0aGlzLl9zcGxpY2UoZHJvcCk7XFxuXFxuXFx0XFx0XFx0dGhpcy5lbGVtZW50LnJlbW92ZUNsYXNzKFxcXCJ1aS1kcm9wcGFibGUgdWktZHJvcHBhYmxlLWRpc2FibGVkXFxcIik7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfc2V0T3B0aW9uOiBmdW5jdGlvbiBfc2V0T3B0aW9uKGtleSwgdmFsdWUpIHtcXG5cXG5cXHRcXHRcXHRpZiAoa2V5ID09PSBcXFwiYWNjZXB0XFxcIikge1xcblxcdFxcdFxcdFxcdHRoaXMuYWNjZXB0ID0gJC5pc0Z1bmN0aW9uKHZhbHVlKSA/IHZhbHVlIDogZnVuY3Rpb24gKGQpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gZC5pcyh2YWx1ZSk7XFxuXFx0XFx0XFx0XFx0fTtcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKGtleSA9PT0gXFxcInNjb3BlXFxcIikge1xcblxcdFxcdFxcdFxcdHZhciBkcm9wID0gJC51aS5kZG1hbmFnZXIuZHJvcHBhYmxlc1t0aGlzLm9wdGlvbnMuc2NvcGVdO1xcblxcblxcdFxcdFxcdFxcdHRoaXMuX3NwbGljZShkcm9wKTtcXG5cXHRcXHRcXHRcXHR0aGlzLl9hZGRUb01hbmFnZXIodmFsdWUpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLl9zdXBlcihrZXksIHZhbHVlKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9hY3RpdmF0ZTogZnVuY3Rpb24gX2FjdGl2YXRlKGV2ZW50KSB7XFxuXFx0XFx0XFx0dmFyIGRyYWdnYWJsZSA9ICQudWkuZGRtYW5hZ2VyLmN1cnJlbnQ7XFxuXFx0XFx0XFx0aWYgKHRoaXMub3B0aW9ucy5hY3RpdmVDbGFzcykge1xcblxcdFxcdFxcdFxcdHRoaXMuZWxlbWVudC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuYWN0aXZlQ2xhc3MpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoZHJhZ2dhYmxlKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5fdHJpZ2dlcihcXFwiYWN0aXZhdGVcXFwiLCBldmVudCwgdGhpcy51aShkcmFnZ2FibGUpKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfZGVhY3RpdmF0ZTogZnVuY3Rpb24gX2RlYWN0aXZhdGUoZXZlbnQpIHtcXG5cXHRcXHRcXHR2YXIgZHJhZ2dhYmxlID0gJC51aS5kZG1hbmFnZXIuY3VycmVudDtcXG5cXHRcXHRcXHRpZiAodGhpcy5vcHRpb25zLmFjdGl2ZUNsYXNzKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5lbGVtZW50LnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5hY3RpdmVDbGFzcyk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmIChkcmFnZ2FibGUpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl90cmlnZ2VyKFxcXCJkZWFjdGl2YXRlXFxcIiwgZXZlbnQsIHRoaXMudWkoZHJhZ2dhYmxlKSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFxuXFx0XFx0X292ZXI6IGZ1bmN0aW9uIF9vdmVyKGV2ZW50KSB7XFxuXFxuXFx0XFx0XFx0dmFyIGRyYWdnYWJsZSA9ICQudWkuZGRtYW5hZ2VyLmN1cnJlbnQ7XFxuXFxuXFx0XFx0XFx0Ly8gQmFpbCBpZiBkcmFnZ2FibGUgYW5kIGRyb3BwYWJsZSBhcmUgc2FtZSBlbGVtZW50XFxuXFx0XFx0XFx0aWYgKCFkcmFnZ2FibGUgfHwgKGRyYWdnYWJsZS5jdXJyZW50SXRlbSB8fCBkcmFnZ2FibGUuZWxlbWVudClbMF0gPT09IHRoaXMuZWxlbWVudFswXSkge1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKHRoaXMuYWNjZXB0LmNhbGwodGhpcy5lbGVtZW50WzBdLCBkcmFnZ2FibGUuY3VycmVudEl0ZW0gfHwgZHJhZ2dhYmxlLmVsZW1lbnQpKSB7XFxuXFx0XFx0XFx0XFx0aWYgKHRoaXMub3B0aW9ucy5ob3ZlckNsYXNzKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5lbGVtZW50LmFkZENsYXNzKHRoaXMub3B0aW9ucy5ob3ZlckNsYXNzKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0dGhpcy5fdHJpZ2dlcihcXFwib3ZlclxcXCIsIGV2ZW50LCB0aGlzLnVpKGRyYWdnYWJsZSkpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcblxcdFxcdF9vdXQ6IGZ1bmN0aW9uIF9vdXQoZXZlbnQpIHtcXG5cXG5cXHRcXHRcXHR2YXIgZHJhZ2dhYmxlID0gJC51aS5kZG1hbmFnZXIuY3VycmVudDtcXG5cXG5cXHRcXHRcXHQvLyBCYWlsIGlmIGRyYWdnYWJsZSBhbmQgZHJvcHBhYmxlIGFyZSBzYW1lIGVsZW1lbnRcXG5cXHRcXHRcXHRpZiAoIWRyYWdnYWJsZSB8fCAoZHJhZ2dhYmxlLmN1cnJlbnRJdGVtIHx8IGRyYWdnYWJsZS5lbGVtZW50KVswXSA9PT0gdGhpcy5lbGVtZW50WzBdKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAodGhpcy5hY2NlcHQuY2FsbCh0aGlzLmVsZW1lbnRbMF0sIGRyYWdnYWJsZS5jdXJyZW50SXRlbSB8fCBkcmFnZ2FibGUuZWxlbWVudCkpIHtcXG5cXHRcXHRcXHRcXHRpZiAodGhpcy5vcHRpb25zLmhvdmVyQ2xhc3MpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmVsZW1lbnQucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmhvdmVyQ2xhc3MpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR0aGlzLl90cmlnZ2VyKFxcXCJvdXRcXFwiLCBldmVudCwgdGhpcy51aShkcmFnZ2FibGUpKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfZHJvcDogZnVuY3Rpb24gX2Ryb3AoZXZlbnQsIGN1c3RvbSkge1xcblxcblxcdFxcdFxcdHZhciBkcmFnZ2FibGUgPSBjdXN0b20gfHwgJC51aS5kZG1hbmFnZXIuY3VycmVudCxcXG5cXHRcXHRcXHQgICAgY2hpbGRyZW5JbnRlcnNlY3Rpb24gPSBmYWxzZTtcXG5cXG5cXHRcXHRcXHQvLyBCYWlsIGlmIGRyYWdnYWJsZSBhbmQgZHJvcHBhYmxlIGFyZSBzYW1lIGVsZW1lbnRcXG5cXHRcXHRcXHRpZiAoIWRyYWdnYWJsZSB8fCAoZHJhZ2dhYmxlLmN1cnJlbnRJdGVtIHx8IGRyYWdnYWJsZS5lbGVtZW50KVswXSA9PT0gdGhpcy5lbGVtZW50WzBdKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLmVsZW1lbnQuZmluZChcXFwiOmRhdGEodWktZHJvcHBhYmxlKVxcXCIpLm5vdChcXFwiLnVpLWRyYWdnYWJsZS1kcmFnZ2luZ1xcXCIpLmVhY2goZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdHZhciBpbnN0ID0gJCh0aGlzKS5kcm9wcGFibGUoXFxcImluc3RhbmNlXFxcIik7XFxuXFx0XFx0XFx0XFx0aWYgKGluc3Qub3B0aW9ucy5ncmVlZHkgJiYgIWluc3Qub3B0aW9ucy5kaXNhYmxlZCAmJiBpbnN0Lm9wdGlvbnMuc2NvcGUgPT09IGRyYWdnYWJsZS5vcHRpb25zLnNjb3BlICYmIGluc3QuYWNjZXB0LmNhbGwoaW5zdC5lbGVtZW50WzBdLCBkcmFnZ2FibGUuY3VycmVudEl0ZW0gfHwgZHJhZ2dhYmxlLmVsZW1lbnQpICYmICQudWkuaW50ZXJzZWN0KGRyYWdnYWJsZSwgJC5leHRlbmQoaW5zdCwgeyBvZmZzZXQ6IGluc3QuZWxlbWVudC5vZmZzZXQoKSB9KSwgaW5zdC5vcHRpb25zLnRvbGVyYW5jZSwgZXZlbnQpKSB7XFxuXFx0XFx0XFx0XFx0XFx0Y2hpbGRyZW5JbnRlcnNlY3Rpb24gPSB0cnVlO3JldHVybiBmYWxzZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0aWYgKGNoaWxkcmVuSW50ZXJzZWN0aW9uKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAodGhpcy5hY2NlcHQuY2FsbCh0aGlzLmVsZW1lbnRbMF0sIGRyYWdnYWJsZS5jdXJyZW50SXRlbSB8fCBkcmFnZ2FibGUuZWxlbWVudCkpIHtcXG5cXHRcXHRcXHRcXHRpZiAodGhpcy5vcHRpb25zLmFjdGl2ZUNsYXNzKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5lbGVtZW50LnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5hY3RpdmVDbGFzcyk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGlmICh0aGlzLm9wdGlvbnMuaG92ZXJDbGFzcykge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuZWxlbWVudC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuaG92ZXJDbGFzcyk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHRoaXMuX3RyaWdnZXIoXFxcImRyb3BcXFwiLCBldmVudCwgdGhpcy51aShkcmFnZ2FibGUpKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5lbGVtZW50O1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHR1aTogZnVuY3Rpb24gdWkoYykge1xcblxcdFxcdFxcdHJldHVybiB7XFxuXFx0XFx0XFx0XFx0ZHJhZ2dhYmxlOiBjLmN1cnJlbnRJdGVtIHx8IGMuZWxlbWVudCxcXG5cXHRcXHRcXHRcXHRoZWxwZXI6IGMuaGVscGVyLFxcblxcdFxcdFxcdFxcdHBvc2l0aW9uOiBjLnBvc2l0aW9uLFxcblxcdFxcdFxcdFxcdG9mZnNldDogYy5wb3NpdGlvbkFic1xcblxcdFxcdFxcdH07XFxuXFx0XFx0fVxcblxcblxcdH0pO1xcblxcblxcdCQudWkuaW50ZXJzZWN0ID0gZnVuY3Rpb24gKCkge1xcblxcdFxcdGZ1bmN0aW9uIGlzT3ZlckF4aXMoeCwgcmVmZXJlbmNlLCBzaXplKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHggPj0gcmVmZXJlbmNlICYmIHggPCByZWZlcmVuY2UgKyBzaXplO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gZnVuY3Rpb24gKGRyYWdnYWJsZSwgZHJvcHBhYmxlLCB0b2xlcmFuY2VNb2RlLCBldmVudCkge1xcblxcblxcdFxcdFxcdGlmICghZHJvcHBhYmxlLm9mZnNldCkge1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dmFyIHgxID0gKGRyYWdnYWJsZS5wb3NpdGlvbkFicyB8fCBkcmFnZ2FibGUucG9zaXRpb24uYWJzb2x1dGUpLmxlZnQgKyBkcmFnZ2FibGUubWFyZ2lucy5sZWZ0LFxcblxcdFxcdFxcdCAgICB5MSA9IChkcmFnZ2FibGUucG9zaXRpb25BYnMgfHwgZHJhZ2dhYmxlLnBvc2l0aW9uLmFic29sdXRlKS50b3AgKyBkcmFnZ2FibGUubWFyZ2lucy50b3AsXFxuXFx0XFx0XFx0ICAgIHgyID0geDEgKyBkcmFnZ2FibGUuaGVscGVyUHJvcG9ydGlvbnMud2lkdGgsXFxuXFx0XFx0XFx0ICAgIHkyID0geTEgKyBkcmFnZ2FibGUuaGVscGVyUHJvcG9ydGlvbnMuaGVpZ2h0LFxcblxcdFxcdFxcdCAgICBsID0gZHJvcHBhYmxlLm9mZnNldC5sZWZ0LFxcblxcdFxcdFxcdCAgICB0ID0gZHJvcHBhYmxlLm9mZnNldC50b3AsXFxuXFx0XFx0XFx0ICAgIHIgPSBsICsgZHJvcHBhYmxlLnByb3BvcnRpb25zKCkud2lkdGgsXFxuXFx0XFx0XFx0ICAgIGIgPSB0ICsgZHJvcHBhYmxlLnByb3BvcnRpb25zKCkuaGVpZ2h0O1xcblxcblxcdFxcdFxcdHN3aXRjaCAodG9sZXJhbmNlTW9kZSkge1xcblxcdFxcdFxcdFxcdGNhc2UgXFxcImZpdFxcXCI6XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGwgPD0geDEgJiYgeDIgPD0gciAmJiB0IDw9IHkxICYmIHkyIDw9IGI7XFxuXFx0XFx0XFx0XFx0Y2FzZSBcXFwiaW50ZXJzZWN0XFxcIjpcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gbCA8IHgxICsgZHJhZ2dhYmxlLmhlbHBlclByb3BvcnRpb25zLndpZHRoIC8gMiAmJiAvLyBSaWdodCBIYWxmXFxuXFx0XFx0XFx0XFx0XFx0eDIgLSBkcmFnZ2FibGUuaGVscGVyUHJvcG9ydGlvbnMud2lkdGggLyAyIDwgciAmJiAvLyBMZWZ0IEhhbGZcXG5cXHRcXHRcXHRcXHRcXHR0IDwgeTEgKyBkcmFnZ2FibGUuaGVscGVyUHJvcG9ydGlvbnMuaGVpZ2h0IC8gMiAmJiAvLyBCb3R0b20gSGFsZlxcblxcdFxcdFxcdFxcdFxcdHkyIC0gZHJhZ2dhYmxlLmhlbHBlclByb3BvcnRpb25zLmhlaWdodCAvIDIgPCBiOyAvLyBUb3AgSGFsZlxcblxcdFxcdFxcdFxcdGNhc2UgXFxcInBvaW50ZXJcXFwiOlxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBpc092ZXJBeGlzKGV2ZW50LnBhZ2VZLCB0LCBkcm9wcGFibGUucHJvcG9ydGlvbnMoKS5oZWlnaHQpICYmIGlzT3ZlckF4aXMoZXZlbnQucGFnZVgsIGwsIGRyb3BwYWJsZS5wcm9wb3J0aW9ucygpLndpZHRoKTtcXG5cXHRcXHRcXHRcXHRjYXNlIFxcXCJ0b3VjaFxcXCI6XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuICh5MSA+PSB0ICYmIHkxIDw9IGIgfHwgLy8gVG9wIGVkZ2UgdG91Y2hpbmdcXG5cXHRcXHRcXHRcXHRcXHR5MiA+PSB0ICYmIHkyIDw9IGIgfHwgLy8gQm90dG9tIGVkZ2UgdG91Y2hpbmdcXG5cXHRcXHRcXHRcXHRcXHR5MSA8IHQgJiYgeTIgPiBiIC8vIFN1cnJvdW5kZWQgdmVydGljYWxseVxcblxcdFxcdFxcdFxcdFxcdCkgJiYgKHgxID49IGwgJiYgeDEgPD0gciB8fCAvLyBMZWZ0IGVkZ2UgdG91Y2hpbmdcXG5cXHRcXHRcXHRcXHRcXHR4MiA+PSBsICYmIHgyIDw9IHIgfHwgLy8gUmlnaHQgZWRnZSB0b3VjaGluZ1xcblxcdFxcdFxcdFxcdFxcdHgxIDwgbCAmJiB4MiA+IHIgLy8gU3Vycm91bmRlZCBob3Jpem9udGFsbHlcXG5cXHRcXHRcXHRcXHRcXHQpO1xcblxcdFxcdFxcdFxcdGRlZmF1bHQ6XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9O1xcblxcdH0oKTtcXG5cXG5cXHQvKlxcbiBcXHRUaGlzIG1hbmFnZXIgdHJhY2tzIG9mZnNldHMgb2YgZHJhZ2dhYmxlcyBhbmQgZHJvcHBhYmxlc1xcbiAqL1xcblxcdCQudWkuZGRtYW5hZ2VyID0ge1xcblxcdFxcdGN1cnJlbnQ6IG51bGwsXFxuXFx0XFx0ZHJvcHBhYmxlczogeyBcXFwiZGVmYXVsdFxcXCI6IFtdIH0sXFxuXFx0XFx0cHJlcGFyZU9mZnNldHM6IGZ1bmN0aW9uIHByZXBhcmVPZmZzZXRzKHQsIGV2ZW50KSB7XFxuXFxuXFx0XFx0XFx0dmFyIGksXFxuXFx0XFx0XFx0ICAgIGosXFxuXFx0XFx0XFx0ICAgIG0gPSAkLnVpLmRkbWFuYWdlci5kcm9wcGFibGVzW3Qub3B0aW9ucy5zY29wZV0gfHwgW10sXFxuXFx0XFx0XFx0ICAgIHR5cGUgPSBldmVudCA/IGV2ZW50LnR5cGUgOiBudWxsLFxcblxcdFxcdFxcdCAgICAvLyB3b3JrYXJvdW5kIGZvciAjMjMxN1xcblxcdFxcdFxcdGxpc3QgPSAodC5jdXJyZW50SXRlbSB8fCB0LmVsZW1lbnQpLmZpbmQoXFxcIjpkYXRhKHVpLWRyb3BwYWJsZSlcXFwiKS5hZGRCYWNrKCk7XFxuXFxuXFx0XFx0XFx0ZHJvcHBhYmxlc0xvb3A6IGZvciAoaSA9IDA7IGkgPCBtLmxlbmd0aDsgaSsrKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gTm8gZGlzYWJsZWQgYW5kIG5vbi1hY2NlcHRlZFxcblxcdFxcdFxcdFxcdGlmIChtW2ldLm9wdGlvbnMuZGlzYWJsZWQgfHwgdCAmJiAhbVtpXS5hY2NlcHQuY2FsbChtW2ldLmVsZW1lbnRbMF0sIHQuY3VycmVudEl0ZW0gfHwgdC5lbGVtZW50KSkge1xcblxcdFxcdFxcdFxcdFxcdGNvbnRpbnVlO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBGaWx0ZXIgb3V0IGVsZW1lbnRzIGluIHRoZSBjdXJyZW50IGRyYWdnZWQgaXRlbVxcblxcdFxcdFxcdFxcdGZvciAoaiA9IDA7IGogPCBsaXN0Lmxlbmd0aDsgaisrKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGxpc3Rbal0gPT09IG1baV0uZWxlbWVudFswXSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdG1baV0ucHJvcG9ydGlvbnMoKS5oZWlnaHQgPSAwO1xcblxcdFxcdFxcdFxcdFxcdFxcdGNvbnRpbnVlIGRyb3BwYWJsZXNMb29wO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0bVtpXS52aXNpYmxlID0gbVtpXS5lbGVtZW50LmNzcyhcXFwiZGlzcGxheVxcXCIpICE9PSBcXFwibm9uZVxcXCI7XFxuXFx0XFx0XFx0XFx0aWYgKCFtW2ldLnZpc2libGUpIHtcXG5cXHRcXHRcXHRcXHRcXHRjb250aW51ZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQWN0aXZhdGUgdGhlIGRyb3BwYWJsZSBpZiB1c2VkIGRpcmVjdGx5IGZyb20gZHJhZ2dhYmxlc1xcblxcdFxcdFxcdFxcdGlmICh0eXBlID09PSBcXFwibW91c2Vkb3duXFxcIikge1xcblxcdFxcdFxcdFxcdFxcdG1baV0uX2FjdGl2YXRlLmNhbGwobVtpXSwgZXZlbnQpO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRtW2ldLm9mZnNldCA9IG1baV0uZWxlbWVudC5vZmZzZXQoKTtcXG5cXHRcXHRcXHRcXHRtW2ldLnByb3BvcnRpb25zKHsgd2lkdGg6IG1baV0uZWxlbWVudFswXS5vZmZzZXRXaWR0aCwgaGVpZ2h0OiBtW2ldLmVsZW1lbnRbMF0ub2Zmc2V0SGVpZ2h0IH0pO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcdFxcdGRyb3A6IGZ1bmN0aW9uIGRyb3AoZHJhZ2dhYmxlLCBldmVudCkge1xcblxcblxcdFxcdFxcdHZhciBkcm9wcGVkID0gZmFsc2U7XFxuXFx0XFx0XFx0Ly8gQ3JlYXRlIGEgY29weSBvZiB0aGUgZHJvcHBhYmxlcyBpbiBjYXNlIHRoZSBsaXN0IGNoYW5nZXMgZHVyaW5nIHRoZSBkcm9wICgjOTExNilcXG5cXHRcXHRcXHQkLmVhY2goKCQudWkuZGRtYW5hZ2VyLmRyb3BwYWJsZXNbZHJhZ2dhYmxlLm9wdGlvbnMuc2NvcGVdIHx8IFtdKS5zbGljZSgpLCBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCF0aGlzLm9wdGlvbnMpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGlmICghdGhpcy5vcHRpb25zLmRpc2FibGVkICYmIHRoaXMudmlzaWJsZSAmJiAkLnVpLmludGVyc2VjdChkcmFnZ2FibGUsIHRoaXMsIHRoaXMub3B0aW9ucy50b2xlcmFuY2UsIGV2ZW50KSkge1xcblxcdFxcdFxcdFxcdFxcdGRyb3BwZWQgPSB0aGlzLl9kcm9wLmNhbGwodGhpcywgZXZlbnQpIHx8IGRyb3BwZWQ7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmICghdGhpcy5vcHRpb25zLmRpc2FibGVkICYmIHRoaXMudmlzaWJsZSAmJiB0aGlzLmFjY2VwdC5jYWxsKHRoaXMuZWxlbWVudFswXSwgZHJhZ2dhYmxlLmN1cnJlbnRJdGVtIHx8IGRyYWdnYWJsZS5lbGVtZW50KSkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuaXNvdXQgPSB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuaXNvdmVyID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fZGVhY3RpdmF0ZS5jYWxsKHRoaXMsIGV2ZW50KTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0cmV0dXJuIGRyb3BwZWQ7XFxuXFx0XFx0fSxcXG5cXHRcXHRkcmFnU3RhcnQ6IGZ1bmN0aW9uIGRyYWdTdGFydChkcmFnZ2FibGUsIGV2ZW50KSB7XFxuXFx0XFx0XFx0Ly8gTGlzdGVuIGZvciBzY3JvbGxpbmcgc28gdGhhdCBpZiB0aGUgZHJhZ2dpbmcgY2F1c2VzIHNjcm9sbGluZyB0aGUgcG9zaXRpb24gb2YgdGhlIGRyb3BwYWJsZXMgY2FuIGJlIHJlY2FsY3VsYXRlZCAoc2VlICM1MDAzKVxcblxcdFxcdFxcdGRyYWdnYWJsZS5lbGVtZW50LnBhcmVudHNVbnRpbChcXFwiYm9keVxcXCIpLmJpbmQoXFxcInNjcm9sbC5kcm9wcGFibGVcXFwiLCBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCFkcmFnZ2FibGUub3B0aW9ucy5yZWZyZXNoUG9zaXRpb25zKSB7XFxuXFx0XFx0XFx0XFx0XFx0JC51aS5kZG1hbmFnZXIucHJlcGFyZU9mZnNldHMoZHJhZ2dhYmxlLCBldmVudCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0pO1xcblxcdFxcdH0sXFxuXFx0XFx0ZHJhZzogZnVuY3Rpb24gZHJhZyhkcmFnZ2FibGUsIGV2ZW50KSB7XFxuXFxuXFx0XFx0XFx0Ly8gSWYgeW91IGhhdmUgYSBoaWdobHkgZHluYW1pYyBwYWdlLCB5b3UgbWlnaHQgdHJ5IHRoaXMgb3B0aW9uLiBJdCByZW5kZXJzIHBvc2l0aW9ucyBldmVyeSB0aW1lIHlvdSBtb3ZlIHRoZSBtb3VzZS5cXG5cXHRcXHRcXHRpZiAoZHJhZ2dhYmxlLm9wdGlvbnMucmVmcmVzaFBvc2l0aW9ucykge1xcblxcdFxcdFxcdFxcdCQudWkuZGRtYW5hZ2VyLnByZXBhcmVPZmZzZXRzKGRyYWdnYWJsZSwgZXZlbnQpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBSdW4gdGhyb3VnaCBhbGwgZHJvcHBhYmxlcyBhbmQgY2hlY2sgdGhlaXIgcG9zaXRpb25zIGJhc2VkIG9uIHNwZWNpZmljIHRvbGVyYW5jZSBvcHRpb25zXFxuXFx0XFx0XFx0JC5lYWNoKCQudWkuZGRtYW5hZ2VyLmRyb3BwYWJsZXNbZHJhZ2dhYmxlLm9wdGlvbnMuc2NvcGVdIHx8IFtdLCBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKHRoaXMub3B0aW9ucy5kaXNhYmxlZCB8fCB0aGlzLmdyZWVkeUNoaWxkIHx8ICF0aGlzLnZpc2libGUpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHZhciBwYXJlbnRJbnN0YW5jZSxcXG5cXHRcXHRcXHRcXHQgICAgc2NvcGUsXFxuXFx0XFx0XFx0XFx0ICAgIHBhcmVudCxcXG5cXHRcXHRcXHRcXHQgICAgaW50ZXJzZWN0cyA9ICQudWkuaW50ZXJzZWN0KGRyYWdnYWJsZSwgdGhpcywgdGhpcy5vcHRpb25zLnRvbGVyYW5jZSwgZXZlbnQpLFxcblxcdFxcdFxcdFxcdCAgICBjID0gIWludGVyc2VjdHMgJiYgdGhpcy5pc292ZXIgPyBcXFwiaXNvdXRcXFwiIDogaW50ZXJzZWN0cyAmJiAhdGhpcy5pc292ZXIgPyBcXFwiaXNvdmVyXFxcIiA6IG51bGw7XFxuXFx0XFx0XFx0XFx0aWYgKCFjKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAodGhpcy5vcHRpb25zLmdyZWVkeSkge1xcblxcdFxcdFxcdFxcdFxcdC8vIGZpbmQgZHJvcHBhYmxlIHBhcmVudHMgd2l0aCBzYW1lIHNjb3BlXFxuXFx0XFx0XFx0XFx0XFx0c2NvcGUgPSB0aGlzLm9wdGlvbnMuc2NvcGU7XFxuXFx0XFx0XFx0XFx0XFx0cGFyZW50ID0gdGhpcy5lbGVtZW50LnBhcmVudHMoXFxcIjpkYXRhKHVpLWRyb3BwYWJsZSlcXFwiKS5maWx0ZXIoZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiAkKHRoaXMpLmRyb3BwYWJsZShcXFwiaW5zdGFuY2VcXFwiKS5vcHRpb25zLnNjb3BlID09PSBzY29wZTtcXG5cXHRcXHRcXHRcXHRcXHR9KTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAocGFyZW50Lmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHBhcmVudEluc3RhbmNlID0gJChwYXJlbnRbMF0pLmRyb3BwYWJsZShcXFwiaW5zdGFuY2VcXFwiKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRwYXJlbnRJbnN0YW5jZS5ncmVlZHlDaGlsZCA9IGMgPT09IFxcXCJpc292ZXJcXFwiO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gd2UganVzdCBtb3ZlZCBpbnRvIGEgZ3JlZWR5IGNoaWxkXFxuXFx0XFx0XFx0XFx0aWYgKHBhcmVudEluc3RhbmNlICYmIGMgPT09IFxcXCJpc292ZXJcXFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0cGFyZW50SW5zdGFuY2UuaXNvdmVyID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0XFx0cGFyZW50SW5zdGFuY2UuaXNvdXQgPSB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdHBhcmVudEluc3RhbmNlLl9vdXQuY2FsbChwYXJlbnRJbnN0YW5jZSwgZXZlbnQpO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR0aGlzW2NdID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHR0aGlzW2MgPT09IFxcXCJpc291dFxcXCIgPyBcXFwiaXNvdmVyXFxcIiA6IFxcXCJpc291dFxcXCJdID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0dGhpc1tjID09PSBcXFwiaXNvdmVyXFxcIiA/IFxcXCJfb3ZlclxcXCIgOiBcXFwiX291dFxcXCJdLmNhbGwodGhpcywgZXZlbnQpO1xcblxcblxcdFxcdFxcdFxcdC8vIHdlIGp1c3QgbW92ZWQgb3V0IG9mIGEgZ3JlZWR5IGNoaWxkXFxuXFx0XFx0XFx0XFx0aWYgKHBhcmVudEluc3RhbmNlICYmIGMgPT09IFxcXCJpc291dFxcXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRwYXJlbnRJbnN0YW5jZS5pc291dCA9IGZhbHNlO1xcblxcdFxcdFxcdFxcdFxcdHBhcmVudEluc3RhbmNlLmlzb3ZlciA9IHRydWU7XFxuXFx0XFx0XFx0XFx0XFx0cGFyZW50SW5zdGFuY2UuX292ZXIuY2FsbChwYXJlbnRJbnN0YW5jZSwgZXZlbnQpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHR9LFxcblxcdFxcdGRyYWdTdG9wOiBmdW5jdGlvbiBkcmFnU3RvcChkcmFnZ2FibGUsIGV2ZW50KSB7XFxuXFx0XFx0XFx0ZHJhZ2dhYmxlLmVsZW1lbnQucGFyZW50c1VudGlsKFxcXCJib2R5XFxcIikudW5iaW5kKFxcXCJzY3JvbGwuZHJvcHBhYmxlXFxcIik7XFxuXFx0XFx0XFx0Ly8gQ2FsbCBwcmVwYXJlT2Zmc2V0cyBvbmUgZmluYWwgdGltZSBzaW5jZSBJRSBkb2VzIG5vdCBmaXJlIHJldHVybiBzY3JvbGwgZXZlbnRzIHdoZW4gb3ZlcmZsb3cgd2FzIGNhdXNlZCBieSBkcmFnIChzZWUgIzUwMDMpXFxuXFx0XFx0XFx0aWYgKCFkcmFnZ2FibGUub3B0aW9ucy5yZWZyZXNoUG9zaXRpb25zKSB7XFxuXFx0XFx0XFx0XFx0JC51aS5kZG1hbmFnZXIucHJlcGFyZU9mZnNldHMoZHJhZ2dhYmxlLCBldmVudCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9O1xcblxcblxcdHZhciBkcm9wcGFibGUgPSAkLnVpLmRyb3BwYWJsZTtcXG5cXG5cXHQvKiFcXG4gICogalF1ZXJ5IFVJIEVmZmVjdHMgMS4xMS40XFxuICAqIGh0dHA6Ly9qcXVlcnl1aS5jb21cXG4gICpcXG4gICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcXG4gICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxcbiAgKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXFxuICAqXFxuICAqIGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL2NhdGVnb3J5L2VmZmVjdHMtY29yZS9cXG4gICovXFxuXFxuXFx0dmFyIGRhdGFTcGFjZSA9IFxcXCJ1aS1lZmZlY3RzLVxcXCIsXFxuXFxuXFxuXFx0Ly8gQ3JlYXRlIGEgbG9jYWwgalF1ZXJ5IGJlY2F1c2UgalF1ZXJ5IENvbG9yIHJlbGllcyBvbiBpdCBhbmQgdGhlXFxuXFx0Ly8gZ2xvYmFsIG1heSBub3QgZXhpc3Qgd2l0aCBBTUQgYW5kIGEgY3VzdG9tIGJ1aWxkICgjMTAxOTkpXFxuXFx0alF1ZXJ5ID0gJDtcXG5cXG5cXHQkLmVmZmVjdHMgPSB7XFxuXFx0XFx0ZWZmZWN0OiB7fVxcblxcdH07XFxuXFxuXFx0LyohXFxuICAqIGpRdWVyeSBDb2xvciBBbmltYXRpb25zIHYyLjEuMlxcbiAgKiBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS1jb2xvclxcbiAgKlxcbiAgKiBDb3B5cmlnaHQgMjAxNCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXFxuICAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cXG4gICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxcbiAgKlxcbiAgKiBEYXRlOiBXZWQgSmFuIDE2IDA4OjQ3OjA5IDIwMTMgLTA2MDBcXG4gICovXFxuXFx0KGZ1bmN0aW9uIChqUXVlcnksIHVuZGVmaW5lZCkge1xcblxcblxcdFxcdHZhciBzdGVwSG9va3MgPSBcXFwiYmFja2dyb3VuZENvbG9yIGJvcmRlckJvdHRvbUNvbG9yIGJvcmRlckxlZnRDb2xvciBib3JkZXJSaWdodENvbG9yIGJvcmRlclRvcENvbG9yIGNvbG9yIGNvbHVtblJ1bGVDb2xvciBvdXRsaW5lQ29sb3IgdGV4dERlY29yYXRpb25Db2xvciB0ZXh0RW1waGFzaXNDb2xvclxcXCIsXFxuXFxuXFxuXFx0XFx0Ly8gcGx1c2VxdWFscyB0ZXN0IGZvciArPSAxMDAgLT0gMTAwXFxuXFx0XFx0cnBsdXNlcXVhbHMgPSAvXihbXFxcXC0rXSk9XFxcXHMqKFxcXFxkK1xcXFwuP1xcXFxkKikvLFxcblxcblxcdFxcdC8vIGEgc2V0IG9mIFJFJ3MgdGhhdCBjYW4gbWF0Y2ggc3RyaW5ncyBhbmQgZ2VuZXJhdGUgY29sb3IgdHVwbGVzLlxcblxcdFxcdHN0cmluZ1BhcnNlcnMgPSBbe1xcblxcdFxcdFxcdHJlOiAvcmdiYT9cXFxcKFxcXFxzKihcXFxcZHsxLDN9KVxcXFxzKixcXFxccyooXFxcXGR7MSwzfSlcXFxccyosXFxcXHMqKFxcXFxkezEsM30pXFxcXHMqKD86LFxcXFxzKihcXFxcZD8oPzpcXFxcLlxcXFxkKyk/KVxcXFxzKik/XFxcXCkvLFxcblxcdFxcdFxcdHBhcnNlOiBmdW5jdGlvbiBwYXJzZShleGVjUmVzdWx0KSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIFtleGVjUmVzdWx0WzFdLCBleGVjUmVzdWx0WzJdLCBleGVjUmVzdWx0WzNdLCBleGVjUmVzdWx0WzRdXTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSwge1xcblxcdFxcdFxcdHJlOiAvcmdiYT9cXFxcKFxcXFxzKihcXFxcZCsoPzpcXFxcLlxcXFxkKyk/KVxcXFwlXFxcXHMqLFxcXFxzKihcXFxcZCsoPzpcXFxcLlxcXFxkKyk/KVxcXFwlXFxcXHMqLFxcXFxzKihcXFxcZCsoPzpcXFxcLlxcXFxkKyk/KVxcXFwlXFxcXHMqKD86LFxcXFxzKihcXFxcZD8oPzpcXFxcLlxcXFxkKyk/KVxcXFxzKik/XFxcXCkvLFxcblxcdFxcdFxcdHBhcnNlOiBmdW5jdGlvbiBwYXJzZShleGVjUmVzdWx0KSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIFtleGVjUmVzdWx0WzFdICogMi41NSwgZXhlY1Jlc3VsdFsyXSAqIDIuNTUsIGV4ZWNSZXN1bHRbM10gKiAyLjU1LCBleGVjUmVzdWx0WzRdXTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSwge1xcblxcdFxcdFxcdC8vIHRoaXMgcmVnZXggaWdub3JlcyBBLUYgYmVjYXVzZSBpdCdzIGNvbXBhcmVkIGFnYWluc3QgYW4gYWxyZWFkeSBsb3dlcmNhc2VkIHN0cmluZ1xcblxcdFxcdFxcdHJlOiAvIyhbYS1mMC05XXsyfSkoW2EtZjAtOV17Mn0pKFthLWYwLTldezJ9KS8sXFxuXFx0XFx0XFx0cGFyc2U6IGZ1bmN0aW9uIHBhcnNlKGV4ZWNSZXN1bHQpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gW3BhcnNlSW50KGV4ZWNSZXN1bHRbMV0sIDE2KSwgcGFyc2VJbnQoZXhlY1Jlc3VsdFsyXSwgMTYpLCBwYXJzZUludChleGVjUmVzdWx0WzNdLCAxNildO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LCB7XFxuXFx0XFx0XFx0Ly8gdGhpcyByZWdleCBpZ25vcmVzIEEtRiBiZWNhdXNlIGl0J3MgY29tcGFyZWQgYWdhaW5zdCBhbiBhbHJlYWR5IGxvd2VyY2FzZWQgc3RyaW5nXFxuXFx0XFx0XFx0cmU6IC8jKFthLWYwLTldKShbYS1mMC05XSkoW2EtZjAtOV0pLyxcXG5cXHRcXHRcXHRwYXJzZTogZnVuY3Rpb24gcGFyc2UoZXhlY1Jlc3VsdCkge1xcblxcdFxcdFxcdFxcdHJldHVybiBbcGFyc2VJbnQoZXhlY1Jlc3VsdFsxXSArIGV4ZWNSZXN1bHRbMV0sIDE2KSwgcGFyc2VJbnQoZXhlY1Jlc3VsdFsyXSArIGV4ZWNSZXN1bHRbMl0sIDE2KSwgcGFyc2VJbnQoZXhlY1Jlc3VsdFszXSArIGV4ZWNSZXN1bHRbM10sIDE2KV07XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sIHtcXG5cXHRcXHRcXHRyZTogL2hzbGE/XFxcXChcXFxccyooXFxcXGQrKD86XFxcXC5cXFxcZCspPylcXFxccyosXFxcXHMqKFxcXFxkKyg/OlxcXFwuXFxcXGQrKT8pXFxcXCVcXFxccyosXFxcXHMqKFxcXFxkKyg/OlxcXFwuXFxcXGQrKT8pXFxcXCVcXFxccyooPzosXFxcXHMqKFxcXFxkPyg/OlxcXFwuXFxcXGQrKT8pXFxcXHMqKT9cXFxcKS8sXFxuXFx0XFx0XFx0c3BhY2U6IFxcXCJoc2xhXFxcIixcXG5cXHRcXHRcXHRwYXJzZTogZnVuY3Rpb24gcGFyc2UoZXhlY1Jlc3VsdCkge1xcblxcdFxcdFxcdFxcdHJldHVybiBbZXhlY1Jlc3VsdFsxXSwgZXhlY1Jlc3VsdFsyXSAvIDEwMCwgZXhlY1Jlc3VsdFszXSAvIDEwMCwgZXhlY1Jlc3VsdFs0XV07XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1dLFxcblxcblxcblxcdFxcdC8vIGpRdWVyeS5Db2xvciggKVxcblxcdFxcdGNvbG9yID0galF1ZXJ5LkNvbG9yID0gZnVuY3Rpb24gKGNvbG9yLCBncmVlbiwgYmx1ZSwgYWxwaGEpIHtcXG5cXHRcXHRcXHRyZXR1cm4gbmV3IGpRdWVyeS5Db2xvci5mbi5wYXJzZShjb2xvciwgZ3JlZW4sIGJsdWUsIGFscGhhKTtcXG5cXHRcXHR9LFxcblxcdFxcdCAgICBzcGFjZXMgPSB7XFxuXFx0XFx0XFx0cmdiYToge1xcblxcdFxcdFxcdFxcdHByb3BzOiB7XFxuXFx0XFx0XFx0XFx0XFx0cmVkOiB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWR4OiAwLFxcblxcdFxcdFxcdFxcdFxcdFxcdHR5cGU6IFxcXCJieXRlXFxcIlxcblxcdFxcdFxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0XFx0XFx0Z3JlZW46IHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZHg6IDEsXFxuXFx0XFx0XFx0XFx0XFx0XFx0dHlwZTogXFxcImJ5dGVcXFwiXFxuXFx0XFx0XFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRcXHRcXHRibHVlOiB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWR4OiAyLFxcblxcdFxcdFxcdFxcdFxcdFxcdHR5cGU6IFxcXCJieXRlXFxcIlxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRoc2xhOiB7XFxuXFx0XFx0XFx0XFx0cHJvcHM6IHtcXG5cXHRcXHRcXHRcXHRcXHRodWU6IHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZHg6IDAsXFxuXFx0XFx0XFx0XFx0XFx0XFx0dHlwZTogXFxcImRlZ3JlZXNcXFwiXFxuXFx0XFx0XFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRcXHRcXHRzYXR1cmF0aW9uOiB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWR4OiAxLFxcblxcdFxcdFxcdFxcdFxcdFxcdHR5cGU6IFxcXCJwZXJjZW50XFxcIlxcblxcdFxcdFxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0XFx0XFx0bGlnaHRuZXNzOiB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWR4OiAyLFxcblxcdFxcdFxcdFxcdFxcdFxcdHR5cGU6IFxcXCJwZXJjZW50XFxcIlxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFx0XFx0ICAgIHByb3BUeXBlcyA9IHtcXG5cXHRcXHRcXHRcXFwiYnl0ZVxcXCI6IHtcXG5cXHRcXHRcXHRcXHRmbG9vcjogdHJ1ZSxcXG5cXHRcXHRcXHRcXHRtYXg6IDI1NVxcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0XFxcInBlcmNlbnRcXFwiOiB7XFxuXFx0XFx0XFx0XFx0bWF4OiAxXFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRcXFwiZGVncmVlc1xcXCI6IHtcXG5cXHRcXHRcXHRcXHRtb2Q6IDM2MCxcXG5cXHRcXHRcXHRcXHRmbG9vcjogdHJ1ZVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcdFxcdCAgICBzdXBwb3J0ID0gY29sb3Iuc3VwcG9ydCA9IHt9LFxcblxcblxcblxcdFxcdC8vIGVsZW1lbnQgZm9yIHN1cHBvcnQgdGVzdHNcXG5cXHRcXHRzdXBwb3J0RWxlbSA9IGpRdWVyeShcXFwiPHA+XFxcIilbMF0sXFxuXFxuXFxuXFx0XFx0Ly8gY29sb3JzID0galF1ZXJ5LkNvbG9yLm5hbWVzXFxuXFx0XFx0Y29sb3JzLFxcblxcblxcblxcdFxcdC8vIGxvY2FsIGFsaWFzZXMgb2YgZnVuY3Rpb25zIGNhbGxlZCBvZnRlblxcblxcdFxcdGVhY2ggPSBqUXVlcnkuZWFjaDtcXG5cXG5cXHRcXHQvLyBkZXRlcm1pbmUgcmdiYSBzdXBwb3J0IGltbWVkaWF0ZWx5XFxuXFx0XFx0c3VwcG9ydEVsZW0uc3R5bGUuY3NzVGV4dCA9IFxcXCJiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMSwxLDEsLjUpXFxcIjtcXG5cXHRcXHRzdXBwb3J0LnJnYmEgPSBzdXBwb3J0RWxlbS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IuaW5kZXhPZihcXFwicmdiYVxcXCIpID4gLTE7XFxuXFxuXFx0XFx0Ly8gZGVmaW5lIGNhY2hlIG5hbWUgYW5kIGFscGhhIHByb3BlcnRpZXNcXG5cXHRcXHQvLyBmb3IgcmdiYSBhbmQgaHNsYSBzcGFjZXNcXG5cXHRcXHRlYWNoKHNwYWNlcywgZnVuY3Rpb24gKHNwYWNlTmFtZSwgc3BhY2UpIHtcXG5cXHRcXHRcXHRzcGFjZS5jYWNoZSA9IFxcXCJfXFxcIiArIHNwYWNlTmFtZTtcXG5cXHRcXHRcXHRzcGFjZS5wcm9wcy5hbHBoYSA9IHtcXG5cXHRcXHRcXHRcXHRpZHg6IDMsXFxuXFx0XFx0XFx0XFx0dHlwZTogXFxcInBlcmNlbnRcXFwiLFxcblxcdFxcdFxcdFxcdGRlZjogMVxcblxcdFxcdFxcdH07XFxuXFx0XFx0fSk7XFxuXFxuXFx0XFx0ZnVuY3Rpb24gY2xhbXAodmFsdWUsIHByb3AsIGFsbG93RW1wdHkpIHtcXG5cXHRcXHRcXHR2YXIgdHlwZSA9IHByb3BUeXBlc1twcm9wLnR5cGVdIHx8IHt9O1xcblxcblxcdFxcdFxcdGlmICh2YWx1ZSA9PSBudWxsKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGFsbG93RW1wdHkgfHwgIXByb3AuZGVmID8gbnVsbCA6IHByb3AuZGVmO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyB+fiBpcyBhbiBzaG9ydCB3YXkgb2YgZG9pbmcgZmxvb3IgZm9yIHBvc2l0aXZlIG51bWJlcnNcXG5cXHRcXHRcXHR2YWx1ZSA9IHR5cGUuZmxvb3IgPyB+fnZhbHVlIDogcGFyc2VGbG9hdCh2YWx1ZSk7XFxuXFxuXFx0XFx0XFx0Ly8gSUUgd2lsbCBwYXNzIGluIGVtcHR5IHN0cmluZ3MgYXMgdmFsdWUgZm9yIGFscGhhLFxcblxcdFxcdFxcdC8vIHdoaWNoIHdpbGwgaGl0IHRoaXMgY2FzZVxcblxcdFxcdFxcdGlmIChpc05hTih2YWx1ZSkpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gcHJvcC5kZWY7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICh0eXBlLm1vZCkge1xcblxcdFxcdFxcdFxcdC8vIHdlIGFkZCBtb2QgYmVmb3JlIG1vZGRpbmcgdG8gbWFrZSBzdXJlIHRoYXQgbmVnYXRpdmVzIHZhbHVlc1xcblxcdFxcdFxcdFxcdC8vIGdldCBjb252ZXJ0ZWQgcHJvcGVybHk6IC0xMCAtPiAzNTBcXG5cXHRcXHRcXHRcXHRyZXR1cm4gKHZhbHVlICsgdHlwZS5tb2QpICUgdHlwZS5tb2Q7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIGZvciBub3cgYWxsIHByb3BlcnR5IHR5cGVzIHdpdGhvdXQgbW9kIGhhdmUgbWluIGFuZCBtYXhcXG5cXHRcXHRcXHRyZXR1cm4gMCA+IHZhbHVlID8gMCA6IHR5cGUubWF4IDwgdmFsdWUgPyB0eXBlLm1heCA6IHZhbHVlO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiBzdHJpbmdQYXJzZShzdHJpbmcpIHtcXG5cXHRcXHRcXHR2YXIgaW5zdCA9IGNvbG9yKCksXFxuXFx0XFx0XFx0ICAgIHJnYmEgPSBpbnN0Ll9yZ2JhID0gW107XFxuXFxuXFx0XFx0XFx0c3RyaW5nID0gc3RyaW5nLnRvTG93ZXJDYXNlKCk7XFxuXFxuXFx0XFx0XFx0ZWFjaChzdHJpbmdQYXJzZXJzLCBmdW5jdGlvbiAoaSwgcGFyc2VyKSB7XFxuXFx0XFx0XFx0XFx0dmFyIHBhcnNlZCxcXG5cXHRcXHRcXHRcXHQgICAgbWF0Y2ggPSBwYXJzZXIucmUuZXhlYyhzdHJpbmcpLFxcblxcdFxcdFxcdFxcdCAgICB2YWx1ZXMgPSBtYXRjaCAmJiBwYXJzZXIucGFyc2UobWF0Y2gpLFxcblxcdFxcdFxcdFxcdCAgICBzcGFjZU5hbWUgPSBwYXJzZXIuc3BhY2UgfHwgXFxcInJnYmFcXFwiO1xcblxcblxcdFxcdFxcdFxcdGlmICh2YWx1ZXMpIHtcXG5cXHRcXHRcXHRcXHRcXHRwYXJzZWQgPSBpbnN0W3NwYWNlTmFtZV0odmFsdWVzKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBpZiB0aGlzIHdhcyBhbiByZ2JhIHBhcnNlIHRoZSBhc3NpZ25tZW50IG1pZ2h0IGhhcHBlbiB0d2ljZVxcblxcdFxcdFxcdFxcdFxcdC8vIG9oIHdlbGwuLi4uXFxuXFx0XFx0XFx0XFx0XFx0aW5zdFtzcGFjZXNbc3BhY2VOYW1lXS5jYWNoZV0gPSBwYXJzZWRbc3BhY2VzW3NwYWNlTmFtZV0uY2FjaGVdO1xcblxcdFxcdFxcdFxcdFxcdHJnYmEgPSBpbnN0Ll9yZ2JhID0gcGFyc2VkLl9yZ2JhO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIGV4aXQgZWFjaCggc3RyaW5nUGFyc2VycyApIGhlcmUgYmVjYXVzZSB3ZSBtYXRjaGVkXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9KTtcXG5cXG5cXHRcXHRcXHQvLyBGb3VuZCBhIHN0cmluZ1BhcnNlciB0aGF0IGhhbmRsZWQgaXRcXG5cXHRcXHRcXHRpZiAocmdiYS5sZW5ndGgpIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBpZiB0aGlzIGNhbWUgZnJvbSBhIHBhcnNlZCBzdHJpbmcsIGZvcmNlIFxcXCJ0cmFuc3BhcmVudFxcXCIgd2hlbiBhbHBoYSBpcyAwXFxuXFx0XFx0XFx0XFx0Ly8gY2hyb21lLCAoYW5kIG1heWJlIG90aGVycykgcmV0dXJuIFxcXCJ0cmFuc3BhcmVudFxcXCIgYXMgcmdiYSgwLDAsMCwwKVxcblxcdFxcdFxcdFxcdGlmIChyZ2JhLmpvaW4oKSA9PT0gXFxcIjAsMCwwLDBcXFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0alF1ZXJ5LmV4dGVuZChyZ2JhLCBjb2xvcnMudHJhbnNwYXJlbnQpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRyZXR1cm4gaW5zdDtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gbmFtZWQgY29sb3JzXFxuXFx0XFx0XFx0cmV0dXJuIGNvbG9yc1tzdHJpbmddO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRjb2xvci5mbiA9IGpRdWVyeS5leHRlbmQoY29sb3IucHJvdG90eXBlLCB7XFxuXFx0XFx0XFx0cGFyc2U6IGZ1bmN0aW9uIHBhcnNlKHJlZCwgZ3JlZW4sIGJsdWUsIGFscGhhKSB7XFxuXFx0XFx0XFx0XFx0aWYgKHJlZCA9PT0gdW5kZWZpbmVkKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fcmdiYSA9IFtudWxsLCBudWxsLCBudWxsLCBudWxsXTtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aWYgKHJlZC5qcXVlcnkgfHwgcmVkLm5vZGVUeXBlKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmVkID0galF1ZXJ5KHJlZCkuY3NzKGdyZWVuKTtcXG5cXHRcXHRcXHRcXHRcXHRncmVlbiA9IHVuZGVmaW5lZDtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGluc3QgPSB0aGlzLFxcblxcdFxcdFxcdFxcdCAgICB0eXBlID0galF1ZXJ5LnR5cGUocmVkKSxcXG5cXHRcXHRcXHRcXHQgICAgcmdiYSA9IHRoaXMuX3JnYmEgPSBbXTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBtb3JlIHRoYW4gMSBhcmd1bWVudCBzcGVjaWZpZWQgLSBhc3N1bWUgKCByZWQsIGdyZWVuLCBibHVlLCBhbHBoYSApXFxuXFx0XFx0XFx0XFx0aWYgKGdyZWVuICE9PSB1bmRlZmluZWQpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZWQgPSBbcmVkLCBncmVlbiwgYmx1ZSwgYWxwaGFdO1xcblxcdFxcdFxcdFxcdFxcdHR5cGUgPSBcXFwiYXJyYXlcXFwiO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAodHlwZSA9PT0gXFxcInN0cmluZ1xcXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5wYXJzZShzdHJpbmdQYXJzZShyZWQpIHx8IGNvbG9ycy5fZGVmYXVsdCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmICh0eXBlID09PSBcXFwiYXJyYXlcXFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZWFjaChzcGFjZXMucmdiYS5wcm9wcywgZnVuY3Rpb24gKGtleSwgcHJvcCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJnYmFbcHJvcC5pZHhdID0gY2xhbXAocmVkW3Byb3AuaWR4XSwgcHJvcCk7XFxuXFx0XFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmICh0eXBlID09PSBcXFwib2JqZWN0XFxcIikge1xcblxcdFxcdFxcdFxcdFxcdGlmIChyZWQgaW5zdGFuY2VvZiBjb2xvcikge1xcblxcdFxcdFxcdFxcdFxcdFxcdGVhY2goc3BhY2VzLCBmdW5jdGlvbiAoc3BhY2VOYW1lLCBzcGFjZSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChyZWRbc3BhY2UuY2FjaGVdKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aW5zdFtzcGFjZS5jYWNoZV0gPSByZWRbc3BhY2UuY2FjaGVdLnNsaWNlKCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZWFjaChzcGFjZXMsIGZ1bmN0aW9uIChzcGFjZU5hbWUsIHNwYWNlKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIGNhY2hlID0gc3BhY2UuY2FjaGU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZWFjaChzcGFjZS5wcm9wcywgZnVuY3Rpb24gKGtleSwgcHJvcCkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIGlmIHRoZSBjYWNoZSBkb2Vzbid0IGV4aXN0LCBhbmQgd2Uga25vdyBob3cgdG8gY29udmVydFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICghaW5zdFtjYWNoZV0gJiYgc3BhY2UudG8pIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBpZiB0aGUgdmFsdWUgd2FzIG51bGwsIHdlIGRvbid0IG5lZWQgdG8gY29weSBpdFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIGlmIHRoZSBrZXkgd2FzIGFscGhhLCB3ZSBkb24ndCBuZWVkIHRvIGNvcHkgaXQgZWl0aGVyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKGtleSA9PT0gXFxcImFscGhhXFxcIiB8fCByZWRba2V5XSA9PSBudWxsKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpbnN0W2NhY2hlXSA9IHNwYWNlLnRvKGluc3QuX3JnYmEpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyB0aGlzIGlzIHRoZSBvbmx5IGNhc2Ugd2hlcmUgd2UgYWxsb3cgbnVsbHMgZm9yIEFMTCBwcm9wZXJ0aWVzLlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIGNhbGwgY2xhbXAgd2l0aCBhbHdheXNBbGxvd0VtcHR5XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aW5zdFtjYWNoZV1bcHJvcC5pZHhdID0gY2xhbXAocmVkW2tleV0sIHByb3AsIHRydWUpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH0pO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIGV2ZXJ5dGhpbmcgZGVmaW5lZCBidXQgYWxwaGE/XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKGluc3RbY2FjaGVdICYmIGpRdWVyeS5pbkFycmF5KG51bGwsIGluc3RbY2FjaGVdLnNsaWNlKDAsIDMpKSA8IDApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyB1c2UgdGhlIGRlZmF1bHQgb2YgMVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGluc3RbY2FjaGVdWzNdID0gMTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoc3BhY2UuZnJvbSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGluc3QuX3JnYmEgPSBzcGFjZS5mcm9tKGluc3RbY2FjaGVdKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRpczogZnVuY3Rpb24gaXMoY29tcGFyZSkge1xcblxcdFxcdFxcdFxcdHZhciBpcyA9IGNvbG9yKGNvbXBhcmUpLFxcblxcdFxcdFxcdFxcdCAgICBzYW1lID0gdHJ1ZSxcXG5cXHRcXHRcXHRcXHQgICAgaW5zdCA9IHRoaXM7XFxuXFxuXFx0XFx0XFx0XFx0ZWFjaChzcGFjZXMsIGZ1bmN0aW9uIChfLCBzcGFjZSkge1xcblxcdFxcdFxcdFxcdFxcdHZhciBsb2NhbENhY2hlLFxcblxcdFxcdFxcdFxcdFxcdCAgICBpc0NhY2hlID0gaXNbc3BhY2UuY2FjaGVdO1xcblxcdFxcdFxcdFxcdFxcdGlmIChpc0NhY2hlKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0bG9jYWxDYWNoZSA9IGluc3Rbc3BhY2UuY2FjaGVdIHx8IHNwYWNlLnRvICYmIHNwYWNlLnRvKGluc3QuX3JnYmEpIHx8IFtdO1xcblxcdFxcdFxcdFxcdFxcdFxcdGVhY2goc3BhY2UucHJvcHMsIGZ1bmN0aW9uIChfLCBwcm9wKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKGlzQ2FjaGVbcHJvcC5pZHhdICE9IG51bGwpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRzYW1lID0gaXNDYWNoZVtwcm9wLmlkeF0gPT09IGxvY2FsQ2FjaGVbcHJvcC5pZHhdO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBzYW1lO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHNhbWU7XFxuXFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHNhbWU7XFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRfc3BhY2U6IGZ1bmN0aW9uIF9zcGFjZSgpIHtcXG5cXHRcXHRcXHRcXHR2YXIgdXNlZCA9IFtdLFxcblxcdFxcdFxcdFxcdCAgICBpbnN0ID0gdGhpcztcXG5cXHRcXHRcXHRcXHRlYWNoKHNwYWNlcywgZnVuY3Rpb24gKHNwYWNlTmFtZSwgc3BhY2UpIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoaW5zdFtzcGFjZS5jYWNoZV0pIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR1c2VkLnB1c2goc3BhY2VOYW1lKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHVzZWQucG9wKCk7XFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHR0cmFuc2l0aW9uOiBmdW5jdGlvbiB0cmFuc2l0aW9uKG90aGVyLCBkaXN0YW5jZSkge1xcblxcdFxcdFxcdFxcdHZhciBlbmQgPSBjb2xvcihvdGhlciksXFxuXFx0XFx0XFx0XFx0ICAgIHNwYWNlTmFtZSA9IGVuZC5fc3BhY2UoKSxcXG5cXHRcXHRcXHRcXHQgICAgc3BhY2UgPSBzcGFjZXNbc3BhY2VOYW1lXSxcXG5cXHRcXHRcXHRcXHQgICAgc3RhcnRDb2xvciA9IHRoaXMuYWxwaGEoKSA9PT0gMCA/IGNvbG9yKFxcXCJ0cmFuc3BhcmVudFxcXCIpIDogdGhpcyxcXG5cXHRcXHRcXHRcXHQgICAgc3RhcnQgPSBzdGFydENvbG9yW3NwYWNlLmNhY2hlXSB8fCBzcGFjZS50byhzdGFydENvbG9yLl9yZ2JhKSxcXG5cXHRcXHRcXHRcXHQgICAgcmVzdWx0ID0gc3RhcnQuc2xpY2UoKTtcXG5cXG5cXHRcXHRcXHRcXHRlbmQgPSBlbmRbc3BhY2UuY2FjaGVdO1xcblxcdFxcdFxcdFxcdGVhY2goc3BhY2UucHJvcHMsIGZ1bmN0aW9uIChrZXksIHByb3ApIHtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgaW5kZXggPSBwcm9wLmlkeCxcXG5cXHRcXHRcXHRcXHRcXHQgICAgc3RhcnRWYWx1ZSA9IHN0YXJ0W2luZGV4XSxcXG5cXHRcXHRcXHRcXHRcXHQgICAgZW5kVmFsdWUgPSBlbmRbaW5kZXhdLFxcblxcdFxcdFxcdFxcdFxcdCAgICB0eXBlID0gcHJvcFR5cGVzW3Byb3AudHlwZV0gfHwge307XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gaWYgbnVsbCwgZG9uJ3Qgb3ZlcnJpZGUgc3RhcnQgdmFsdWVcXG5cXHRcXHRcXHRcXHRcXHRpZiAoZW5kVmFsdWUgPT09IG51bGwpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdC8vIGlmIG51bGwgLSB1c2UgZW5kXFxuXFx0XFx0XFx0XFx0XFx0aWYgKHN0YXJ0VmFsdWUgPT09IG51bGwpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXN1bHRbaW5kZXhdID0gZW5kVmFsdWU7XFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAodHlwZS5tb2QpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoZW5kVmFsdWUgLSBzdGFydFZhbHVlID4gdHlwZS5tb2QgLyAyKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0c3RhcnRWYWx1ZSArPSB0eXBlLm1vZDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2UgaWYgKHN0YXJ0VmFsdWUgLSBlbmRWYWx1ZSA+IHR5cGUubW9kIC8gMikge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHN0YXJ0VmFsdWUgLT0gdHlwZS5tb2Q7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXN1bHRbaW5kZXhdID0gY2xhbXAoKGVuZFZhbHVlIC0gc3RhcnRWYWx1ZSkgKiBkaXN0YW5jZSArIHN0YXJ0VmFsdWUsIHByb3ApO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpc1tzcGFjZU5hbWVdKHJlc3VsdCk7XFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRibGVuZDogZnVuY3Rpb24gYmxlbmQob3BhcXVlKSB7XFxuXFx0XFx0XFx0XFx0Ly8gaWYgd2UgYXJlIGFscmVhZHkgb3BhcXVlIC0gcmV0dXJuIG91cnNlbGZcXG5cXHRcXHRcXHRcXHRpZiAodGhpcy5fcmdiYVszXSA9PT0gMSkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR2YXIgcmdiID0gdGhpcy5fcmdiYS5zbGljZSgpLFxcblxcdFxcdFxcdFxcdCAgICBhID0gcmdiLnBvcCgpLFxcblxcdFxcdFxcdFxcdCAgICBibGVuZCA9IGNvbG9yKG9wYXF1ZSkuX3JnYmE7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIGNvbG9yKGpRdWVyeS5tYXAocmdiLCBmdW5jdGlvbiAodiwgaSkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiAoMSAtIGEpICogYmxlbmRbaV0gKyBhICogdjtcXG5cXHRcXHRcXHRcXHR9KSk7XFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHR0b1JnYmFTdHJpbmc6IGZ1bmN0aW9uIHRvUmdiYVN0cmluZygpIHtcXG5cXHRcXHRcXHRcXHR2YXIgcHJlZml4ID0gXFxcInJnYmEoXFxcIixcXG5cXHRcXHRcXHRcXHQgICAgcmdiYSA9IGpRdWVyeS5tYXAodGhpcy5fcmdiYSwgZnVuY3Rpb24gKHYsIGkpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdiA9PSBudWxsID8gaSA+IDIgPyAxIDogMCA6IHY7XFxuXFx0XFx0XFx0XFx0fSk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKHJnYmFbM10gPT09IDEpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZ2JhLnBvcCgpO1xcblxcdFxcdFxcdFxcdFxcdHByZWZpeCA9IFxcXCJyZ2IoXFxcIjtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHByZWZpeCArIHJnYmEuam9pbigpICsgXFxcIilcXFwiO1xcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0dG9Ic2xhU3RyaW5nOiBmdW5jdGlvbiB0b0hzbGFTdHJpbmcoKSB7XFxuXFx0XFx0XFx0XFx0dmFyIHByZWZpeCA9IFxcXCJoc2xhKFxcXCIsXFxuXFx0XFx0XFx0XFx0ICAgIGhzbGEgPSBqUXVlcnkubWFwKHRoaXMuaHNsYSgpLCBmdW5jdGlvbiAodiwgaSkge1xcblxcdFxcdFxcdFxcdFxcdGlmICh2ID09IG51bGwpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2ID0gaSA+IDIgPyAxIDogMDtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gY2F0Y2ggMSBhbmQgMlxcblxcdFxcdFxcdFxcdFxcdGlmIChpICYmIGkgPCAzKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0diA9IE1hdGgucm91bmQodiAqIDEwMCkgKyBcXFwiJVxcXCI7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdHJldHVybiB2O1xcblxcdFxcdFxcdFxcdH0pO1xcblxcblxcdFxcdFxcdFxcdGlmIChoc2xhWzNdID09PSAxKSB7XFxuXFx0XFx0XFx0XFx0XFx0aHNsYS5wb3AoKTtcXG5cXHRcXHRcXHRcXHRcXHRwcmVmaXggPSBcXFwiaHNsKFxcXCI7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHJldHVybiBwcmVmaXggKyBoc2xhLmpvaW4oKSArIFxcXCIpXFxcIjtcXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdHRvSGV4U3RyaW5nOiBmdW5jdGlvbiB0b0hleFN0cmluZyhpbmNsdWRlQWxwaGEpIHtcXG5cXHRcXHRcXHRcXHR2YXIgcmdiYSA9IHRoaXMuX3JnYmEuc2xpY2UoKSxcXG5cXHRcXHRcXHRcXHQgICAgYWxwaGEgPSByZ2JhLnBvcCgpO1xcblxcblxcdFxcdFxcdFxcdGlmIChpbmNsdWRlQWxwaGEpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZ2JhLnB1c2gofn4oYWxwaGEgKiAyNTUpKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIFxcXCIjXFxcIiArIGpRdWVyeS5tYXAocmdiYSwgZnVuY3Rpb24gKHYpIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBkZWZhdWx0IHRvIDAgd2hlbiBudWxscyBleGlzdFxcblxcdFxcdFxcdFxcdFxcdHYgPSAodiB8fCAwKS50b1N0cmluZygxNik7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHYubGVuZ3RoID09PSAxID8gXFxcIjBcXFwiICsgdiA6IHY7XFxuXFx0XFx0XFx0XFx0fSkuam9pbihcXFwiXFxcIik7XFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHR0b1N0cmluZzogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuX3JnYmFbM10gPT09IDAgPyBcXFwidHJhbnNwYXJlbnRcXFwiIDogdGhpcy50b1JnYmFTdHJpbmcoKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSk7XFxuXFx0XFx0Y29sb3IuZm4ucGFyc2UucHJvdG90eXBlID0gY29sb3IuZm47XFxuXFxuXFx0XFx0Ly8gaHNsYSBjb252ZXJzaW9ucyBhZGFwdGVkIGZyb206XFxuXFx0XFx0Ly8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9tYWFzaGFhY2svc291cmNlL2Jyb3dzZS9wYWNrYWdlcy9ncmFwaGljcy90cnVuay9zcmMvZ3JhcGhpY3MvY29sb3JzL0hVRTJSR0IuYXM/cj01MDIxXFxuXFxuXFx0XFx0ZnVuY3Rpb24gaHVlMnJnYihwLCBxLCBoKSB7XFxuXFx0XFx0XFx0aCA9IChoICsgMSkgJSAxO1xcblxcdFxcdFxcdGlmIChoICogNiA8IDEpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gcCArIChxIC0gcCkgKiBoICogNjtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKGggKiAyIDwgMSkge1xcblxcdFxcdFxcdFxcdHJldHVybiBxO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoaCAqIDMgPCAyKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHAgKyAocSAtIHApICogKDIgLyAzIC0gaCkgKiA2O1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gcDtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0c3BhY2VzLmhzbGEudG8gPSBmdW5jdGlvbiAocmdiYSkge1xcblxcdFxcdFxcdGlmIChyZ2JhWzBdID09IG51bGwgfHwgcmdiYVsxXSA9PSBudWxsIHx8IHJnYmFbMl0gPT0gbnVsbCkge1xcblxcdFxcdFxcdFxcdHJldHVybiBbbnVsbCwgbnVsbCwgbnVsbCwgcmdiYVszXV07XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHZhciByID0gcmdiYVswXSAvIDI1NSxcXG5cXHRcXHRcXHQgICAgZyA9IHJnYmFbMV0gLyAyNTUsXFxuXFx0XFx0XFx0ICAgIGIgPSByZ2JhWzJdIC8gMjU1LFxcblxcdFxcdFxcdCAgICBhID0gcmdiYVszXSxcXG5cXHRcXHRcXHQgICAgbWF4ID0gTWF0aC5tYXgociwgZywgYiksXFxuXFx0XFx0XFx0ICAgIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpLFxcblxcdFxcdFxcdCAgICBkaWZmID0gbWF4IC0gbWluLFxcblxcdFxcdFxcdCAgICBhZGQgPSBtYXggKyBtaW4sXFxuXFx0XFx0XFx0ICAgIGwgPSBhZGQgKiAwLjUsXFxuXFx0XFx0XFx0ICAgIGgsXFxuXFx0XFx0XFx0ICAgIHM7XFxuXFxuXFx0XFx0XFx0aWYgKG1pbiA9PT0gbWF4KSB7XFxuXFx0XFx0XFx0XFx0aCA9IDA7XFxuXFx0XFx0XFx0fSBlbHNlIGlmIChyID09PSBtYXgpIHtcXG5cXHRcXHRcXHRcXHRoID0gNjAgKiAoZyAtIGIpIC8gZGlmZiArIDM2MDtcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKGcgPT09IG1heCkge1xcblxcdFxcdFxcdFxcdGggPSA2MCAqIChiIC0gcikgLyBkaWZmICsgMTIwO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0aCA9IDYwICogKHIgLSBnKSAvIGRpZmYgKyAyNDA7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIGNocm9tYSAoZGlmZikgPT0gMCBtZWFucyBncmV5c2NhbGUgd2hpY2gsIGJ5IGRlZmluaXRpb24sIHNhdHVyYXRpb24gPSAwJVxcblxcdFxcdFxcdC8vIG90aGVyd2lzZSwgc2F0dXJhdGlvbiBpcyBiYXNlZCBvbiB0aGUgcmF0aW8gb2YgY2hyb21hIChkaWZmKSB0byBsaWdodG5lc3MgKGFkZClcXG5cXHRcXHRcXHRpZiAoZGlmZiA9PT0gMCkge1xcblxcdFxcdFxcdFxcdHMgPSAwO1xcblxcdFxcdFxcdH0gZWxzZSBpZiAobCA8PSAwLjUpIHtcXG5cXHRcXHRcXHRcXHRzID0gZGlmZiAvIGFkZDtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdHMgPSBkaWZmIC8gKDIgLSBhZGQpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gW01hdGgucm91bmQoaCkgJSAzNjAsIHMsIGwsIGEgPT0gbnVsbCA/IDEgOiBhXTtcXG5cXHRcXHR9O1xcblxcblxcdFxcdHNwYWNlcy5oc2xhLmZyb20gPSBmdW5jdGlvbiAoaHNsYSkge1xcblxcdFxcdFxcdGlmIChoc2xhWzBdID09IG51bGwgfHwgaHNsYVsxXSA9PSBudWxsIHx8IGhzbGFbMl0gPT0gbnVsbCkge1xcblxcdFxcdFxcdFxcdHJldHVybiBbbnVsbCwgbnVsbCwgbnVsbCwgaHNsYVszXV07XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHZhciBoID0gaHNsYVswXSAvIDM2MCxcXG5cXHRcXHRcXHQgICAgcyA9IGhzbGFbMV0sXFxuXFx0XFx0XFx0ICAgIGwgPSBoc2xhWzJdLFxcblxcdFxcdFxcdCAgICBhID0gaHNsYVszXSxcXG5cXHRcXHRcXHQgICAgcSA9IGwgPD0gMC41ID8gbCAqICgxICsgcykgOiBsICsgcyAtIGwgKiBzLFxcblxcdFxcdFxcdCAgICBwID0gMiAqIGwgLSBxO1xcblxcblxcdFxcdFxcdHJldHVybiBbTWF0aC5yb3VuZChodWUycmdiKHAsIHEsIGggKyAxIC8gMykgKiAyNTUpLCBNYXRoLnJvdW5kKGh1ZTJyZ2IocCwgcSwgaCkgKiAyNTUpLCBNYXRoLnJvdW5kKGh1ZTJyZ2IocCwgcSwgaCAtIDEgLyAzKSAqIDI1NSksIGFdO1xcblxcdFxcdH07XFxuXFxuXFx0XFx0ZWFjaChzcGFjZXMsIGZ1bmN0aW9uIChzcGFjZU5hbWUsIHNwYWNlKSB7XFxuXFx0XFx0XFx0dmFyIHByb3BzID0gc3BhY2UucHJvcHMsXFxuXFx0XFx0XFx0ICAgIGNhY2hlID0gc3BhY2UuY2FjaGUsXFxuXFx0XFx0XFx0ICAgIHRvID0gc3BhY2UudG8sXFxuXFx0XFx0XFx0ICAgIGZyb20gPSBzcGFjZS5mcm9tO1xcblxcblxcdFxcdFxcdC8vIG1ha2VzIHJnYmEoKSBhbmQgaHNsYSgpXFxuXFx0XFx0XFx0Y29sb3IuZm5bc3BhY2VOYW1lXSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xcblxcblxcdFxcdFxcdFxcdC8vIGdlbmVyYXRlIGEgY2FjaGUgZm9yIHRoaXMgc3BhY2UgaWYgaXQgZG9lc24ndCBleGlzdFxcblxcdFxcdFxcdFxcdGlmICh0byAmJiAhdGhpc1tjYWNoZV0pIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzW2NhY2hlXSA9IHRvKHRoaXMuX3JnYmEpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiB0aGlzW2NhY2hlXS5zbGljZSgpO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR2YXIgcmV0LFxcblxcdFxcdFxcdFxcdCAgICB0eXBlID0galF1ZXJ5LnR5cGUodmFsdWUpLFxcblxcdFxcdFxcdFxcdCAgICBhcnIgPSB0eXBlID09PSBcXFwiYXJyYXlcXFwiIHx8IHR5cGUgPT09IFxcXCJvYmplY3RcXFwiID8gdmFsdWUgOiBhcmd1bWVudHMsXFxuXFx0XFx0XFx0XFx0ICAgIGxvY2FsID0gdGhpc1tjYWNoZV0uc2xpY2UoKTtcXG5cXG5cXHRcXHRcXHRcXHRlYWNoKHByb3BzLCBmdW5jdGlvbiAoa2V5LCBwcm9wKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIHZhbCA9IGFyclt0eXBlID09PSBcXFwib2JqZWN0XFxcIiA/IGtleSA6IHByb3AuaWR4XTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAodmFsID09IG51bGwpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YWwgPSBsb2NhbFtwcm9wLmlkeF07XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGxvY2FsW3Byb3AuaWR4XSA9IGNsYW1wKHZhbCwgcHJvcCk7XFxuXFx0XFx0XFx0XFx0fSk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKGZyb20pIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXQgPSBjb2xvcihmcm9tKGxvY2FsKSk7XFxuXFx0XFx0XFx0XFx0XFx0cmV0W2NhY2hlXSA9IGxvY2FsO1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiByZXQ7XFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gY29sb3IobG9jYWwpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdFxcdC8vIG1ha2VzIHJlZCgpIGdyZWVuKCkgYmx1ZSgpIGFscGhhKCkgaHVlKCkgc2F0dXJhdGlvbigpIGxpZ2h0bmVzcygpXFxuXFx0XFx0XFx0ZWFjaChwcm9wcywgZnVuY3Rpb24gKGtleSwgcHJvcCkge1xcblxcdFxcdFxcdFxcdC8vIGFscGhhIGlzIGluY2x1ZGVkIGluIG1vcmUgdGhhbiBvbmUgc3BhY2VcXG5cXHRcXHRcXHRcXHRpZiAoY29sb3IuZm5ba2V5XSkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0Y29sb3IuZm5ba2V5XSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xcblxcdFxcdFxcdFxcdFxcdHZhciB2dHlwZSA9IGpRdWVyeS50eXBlKHZhbHVlKSxcXG5cXHRcXHRcXHRcXHRcXHQgICAgZm4gPSBrZXkgPT09IFxcXCJhbHBoYVxcXCIgPyB0aGlzLl9oc2xhID8gXFxcImhzbGFcXFwiIDogXFxcInJnYmFcXFwiIDogc3BhY2VOYW1lLFxcblxcdFxcdFxcdFxcdFxcdCAgICBsb2NhbCA9IHRoaXNbZm5dKCksXFxuXFx0XFx0XFx0XFx0XFx0ICAgIGN1ciA9IGxvY2FsW3Byb3AuaWR4XSxcXG5cXHRcXHRcXHRcXHRcXHQgICAgbWF0Y2g7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKHZ0eXBlID09PSBcXFwidW5kZWZpbmVkXFxcIikge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBjdXI7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdGlmICh2dHlwZSA9PT0gXFxcImZ1bmN0aW9uXFxcIikge1xcblxcdFxcdFxcdFxcdFxcdFxcdHZhbHVlID0gdmFsdWUuY2FsbCh0aGlzLCBjdXIpO1xcblxcdFxcdFxcdFxcdFxcdFxcdHZ0eXBlID0galF1ZXJ5LnR5cGUodmFsdWUpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRpZiAodmFsdWUgPT0gbnVsbCAmJiBwcm9wLmVtcHR5KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmICh2dHlwZSA9PT0gXFxcInN0cmluZ1xcXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRtYXRjaCA9IHJwbHVzZXF1YWxzLmV4ZWModmFsdWUpO1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChtYXRjaCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhbHVlID0gY3VyICsgcGFyc2VGbG9hdChtYXRjaFsyXSkgKiAobWF0Y2hbMV0gPT09IFxcXCIrXFxcIiA/IDEgOiAtMSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRsb2NhbFtwcm9wLmlkeF0gPSB2YWx1ZTtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhpc1tmbl0obG9jYWwpO1xcblxcdFxcdFxcdFxcdH07XFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0fSk7XFxuXFxuXFx0XFx0Ly8gYWRkIGNzc0hvb2sgYW5kIC5meC5zdGVwIGZ1bmN0aW9uIGZvciBlYWNoIG5hbWVkIGhvb2suXFxuXFx0XFx0Ly8gYWNjZXB0IGEgc3BhY2Ugc2VwYXJhdGVkIHN0cmluZyBvZiBwcm9wZXJ0aWVzXFxuXFx0XFx0Y29sb3IuaG9vayA9IGZ1bmN0aW9uIChob29rKSB7XFxuXFx0XFx0XFx0dmFyIGhvb2tzID0gaG9vay5zcGxpdChcXFwiIFxcXCIpO1xcblxcdFxcdFxcdGVhY2goaG9va3MsIGZ1bmN0aW9uIChpLCBob29rKSB7XFxuXFx0XFx0XFx0XFx0alF1ZXJ5LmNzc0hvb2tzW2hvb2tdID0ge1xcblxcdFxcdFxcdFxcdFxcdHNldDogZnVuY3Rpb24gc2V0KGVsZW0sIHZhbHVlKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIHBhcnNlZCxcXG5cXHRcXHRcXHRcXHRcXHRcXHQgICAgY3VyRWxlbSxcXG5cXHRcXHRcXHRcXHRcXHRcXHQgICAgYmFja2dyb3VuZENvbG9yID0gXFxcIlxcXCI7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKHZhbHVlICE9PSBcXFwidHJhbnNwYXJlbnRcXFwiICYmIChqUXVlcnkudHlwZSh2YWx1ZSkgIT09IFxcXCJzdHJpbmdcXFwiIHx8IChwYXJzZWQgPSBzdHJpbmdQYXJzZSh2YWx1ZSkpKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhbHVlID0gY29sb3IocGFyc2VkIHx8IHZhbHVlKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIXN1cHBvcnQucmdiYSAmJiB2YWx1ZS5fcmdiYVszXSAhPT0gMSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGN1ckVsZW0gPSBob29rID09PSBcXFwiYmFja2dyb3VuZENvbG9yXFxcIiA/IGVsZW0ucGFyZW50Tm9kZSA6IGVsZW07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0d2hpbGUgKChiYWNrZ3JvdW5kQ29sb3IgPT09IFxcXCJcXFwiIHx8IGJhY2tncm91bmRDb2xvciA9PT0gXFxcInRyYW5zcGFyZW50XFxcIikgJiYgY3VyRWxlbSAmJiBjdXJFbGVtLnN0eWxlKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dHJ5IHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRiYWNrZ3JvdW5kQ29sb3IgPSBqUXVlcnkuY3NzKGN1ckVsZW0sIFxcXCJiYWNrZ3JvdW5kQ29sb3JcXFwiKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjdXJFbGVtID0gY3VyRWxlbS5wYXJlbnROb2RlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gY2F0Y2ggKGUpIHt9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhbHVlID0gdmFsdWUuYmxlbmQoYmFja2dyb3VuZENvbG9yICYmIGJhY2tncm91bmRDb2xvciAhPT0gXFxcInRyYW5zcGFyZW50XFxcIiA/IGJhY2tncm91bmRDb2xvciA6IFxcXCJfZGVmYXVsdFxcXCIpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YWx1ZSA9IHZhbHVlLnRvUmdiYVN0cmluZygpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR0cnkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGVsZW0uc3R5bGVbaG9va10gPSB2YWx1ZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9IGNhdGNoIChlKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gd3JhcHBlZCB0byBwcmV2ZW50IElFIGZyb20gdGhyb3dpbmcgZXJyb3JzIG9uIFxcXCJpbnZhbGlkXFxcIiB2YWx1ZXMgbGlrZSAnYXV0bycgb3IgJ2luaGVyaXQnXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdFxcdGpRdWVyeS5meC5zdGVwW2hvb2tdID0gZnVuY3Rpb24gKGZ4KSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCFmeC5jb2xvckluaXQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRmeC5zdGFydCA9IGNvbG9yKGZ4LmVsZW0sIGhvb2spO1xcblxcdFxcdFxcdFxcdFxcdFxcdGZ4LmVuZCA9IGNvbG9yKGZ4LmVuZCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZnguY29sb3JJbml0ID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0alF1ZXJ5LmNzc0hvb2tzW2hvb2tdLnNldChmeC5lbGVtLCBmeC5zdGFydC50cmFuc2l0aW9uKGZ4LmVuZCwgZngucG9zKSk7XFxuXFx0XFx0XFx0XFx0fTtcXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHR9O1xcblxcblxcdFxcdGNvbG9yLmhvb2soc3RlcEhvb2tzKTtcXG5cXG5cXHRcXHRqUXVlcnkuY3NzSG9va3MuYm9yZGVyQ29sb3IgPSB7XFxuXFx0XFx0XFx0ZXhwYW5kOiBmdW5jdGlvbiBleHBhbmQodmFsdWUpIHtcXG5cXHRcXHRcXHRcXHR2YXIgZXhwYW5kZWQgPSB7fTtcXG5cXG5cXHRcXHRcXHRcXHRlYWNoKFtcXFwiVG9wXFxcIiwgXFxcIlJpZ2h0XFxcIiwgXFxcIkJvdHRvbVxcXCIsIFxcXCJMZWZ0XFxcIl0sIGZ1bmN0aW9uIChpLCBwYXJ0KSB7XFxuXFx0XFx0XFx0XFx0XFx0ZXhwYW5kZWRbXFxcImJvcmRlclxcXCIgKyBwYXJ0ICsgXFxcIkNvbG9yXFxcIl0gPSB2YWx1ZTtcXG5cXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZXhwYW5kZWQ7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH07XFxuXFxuXFx0XFx0Ly8gQmFzaWMgY29sb3IgbmFtZXMgb25seS5cXG5cXHRcXHQvLyBVc2FnZSBvZiBhbnkgb2YgdGhlIG90aGVyIGNvbG9yIG5hbWVzIHJlcXVpcmVzIGFkZGluZyB5b3Vyc2VsZiBvciBpbmNsdWRpbmdcXG5cXHRcXHQvLyBqcXVlcnkuY29sb3Iuc3ZnLW5hbWVzLmpzLlxcblxcdFxcdGNvbG9ycyA9IGpRdWVyeS5Db2xvci5uYW1lcyA9IHtcXG5cXHRcXHRcXHQvLyA0LjEuIEJhc2ljIGNvbG9yIGtleXdvcmRzXFxuXFx0XFx0XFx0YXF1YTogXFxcIiMwMGZmZmZcXFwiLFxcblxcdFxcdFxcdGJsYWNrOiBcXFwiIzAwMDAwMFxcXCIsXFxuXFx0XFx0XFx0Ymx1ZTogXFxcIiMwMDAwZmZcXFwiLFxcblxcdFxcdFxcdGZ1Y2hzaWE6IFxcXCIjZmYwMGZmXFxcIixcXG5cXHRcXHRcXHRncmF5OiBcXFwiIzgwODA4MFxcXCIsXFxuXFx0XFx0XFx0Z3JlZW46IFxcXCIjMDA4MDAwXFxcIixcXG5cXHRcXHRcXHRsaW1lOiBcXFwiIzAwZmYwMFxcXCIsXFxuXFx0XFx0XFx0bWFyb29uOiBcXFwiIzgwMDAwMFxcXCIsXFxuXFx0XFx0XFx0bmF2eTogXFxcIiMwMDAwODBcXFwiLFxcblxcdFxcdFxcdG9saXZlOiBcXFwiIzgwODAwMFxcXCIsXFxuXFx0XFx0XFx0cHVycGxlOiBcXFwiIzgwMDA4MFxcXCIsXFxuXFx0XFx0XFx0cmVkOiBcXFwiI2ZmMDAwMFxcXCIsXFxuXFx0XFx0XFx0c2lsdmVyOiBcXFwiI2MwYzBjMFxcXCIsXFxuXFx0XFx0XFx0dGVhbDogXFxcIiMwMDgwODBcXFwiLFxcblxcdFxcdFxcdHdoaXRlOiBcXFwiI2ZmZmZmZlxcXCIsXFxuXFx0XFx0XFx0eWVsbG93OiBcXFwiI2ZmZmYwMFxcXCIsXFxuXFxuXFx0XFx0XFx0Ly8gNC4yLjMuIFxcXCJ0cmFuc3BhcmVudFxcXCIgY29sb3Iga2V5d29yZFxcblxcdFxcdFxcdHRyYW5zcGFyZW50OiBbbnVsbCwgbnVsbCwgbnVsbCwgMF0sXFxuXFxuXFx0XFx0XFx0X2RlZmF1bHQ6IFxcXCIjZmZmZmZmXFxcIlxcblxcdFxcdH07XFxuXFx0fSkoalF1ZXJ5KTtcXG5cXG5cXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcblxcdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogQ0xBU1MgQU5JTUFUSU9OUyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuXFx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG5cXHQoZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdHZhciBjbGFzc0FuaW1hdGlvbkFjdGlvbnMgPSBbXFxcImFkZFxcXCIsIFxcXCJyZW1vdmVcXFwiLCBcXFwidG9nZ2xlXFxcIl0sXFxuXFx0XFx0ICAgIHNob3J0aGFuZFN0eWxlcyA9IHtcXG5cXHRcXHRcXHRib3JkZXI6IDEsXFxuXFx0XFx0XFx0Ym9yZGVyQm90dG9tOiAxLFxcblxcdFxcdFxcdGJvcmRlckNvbG9yOiAxLFxcblxcdFxcdFxcdGJvcmRlckxlZnQ6IDEsXFxuXFx0XFx0XFx0Ym9yZGVyUmlnaHQ6IDEsXFxuXFx0XFx0XFx0Ym9yZGVyVG9wOiAxLFxcblxcdFxcdFxcdGJvcmRlcldpZHRoOiAxLFxcblxcdFxcdFxcdG1hcmdpbjogMSxcXG5cXHRcXHRcXHRwYWRkaW5nOiAxXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHQkLmVhY2goW1xcXCJib3JkZXJMZWZ0U3R5bGVcXFwiLCBcXFwiYm9yZGVyUmlnaHRTdHlsZVxcXCIsIFxcXCJib3JkZXJCb3R0b21TdHlsZVxcXCIsIFxcXCJib3JkZXJUb3BTdHlsZVxcXCJdLCBmdW5jdGlvbiAoXywgcHJvcCkge1xcblxcdFxcdFxcdCQuZnguc3RlcFtwcm9wXSA9IGZ1bmN0aW9uIChmeCkge1xcblxcdFxcdFxcdFxcdGlmIChmeC5lbmQgIT09IFxcXCJub25lXFxcIiAmJiAhZnguc2V0QXR0ciB8fCBmeC5wb3MgPT09IDEgJiYgIWZ4LnNldEF0dHIpIHtcXG5cXHRcXHRcXHRcXHRcXHRqUXVlcnkuc3R5bGUoZnguZWxlbSwgcHJvcCwgZnguZW5kKTtcXG5cXHRcXHRcXHRcXHRcXHRmeC5zZXRBdHRyID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fTtcXG5cXHRcXHR9KTtcXG5cXG5cXHRcXHRmdW5jdGlvbiBnZXRFbGVtZW50U3R5bGVzKGVsZW0pIHtcXG5cXHRcXHRcXHR2YXIga2V5LFxcblxcdFxcdFxcdCAgICBsZW4sXFxuXFx0XFx0XFx0ICAgIHN0eWxlID0gZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3ID8gZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoZWxlbSwgbnVsbCkgOiBlbGVtLmN1cnJlbnRTdHlsZSxcXG5cXHRcXHRcXHQgICAgc3R5bGVzID0ge307XFxuXFxuXFx0XFx0XFx0aWYgKHN0eWxlICYmIHN0eWxlLmxlbmd0aCAmJiBzdHlsZVswXSAmJiBzdHlsZVtzdHlsZVswXV0pIHtcXG5cXHRcXHRcXHRcXHRsZW4gPSBzdHlsZS5sZW5ndGg7XFxuXFx0XFx0XFx0XFx0d2hpbGUgKGxlbi0tKSB7XFxuXFx0XFx0XFx0XFx0XFx0a2V5ID0gc3R5bGVbbGVuXTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAodHlwZW9mIHN0eWxlW2tleV0gPT09IFxcXCJzdHJpbmdcXFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0c3R5bGVzWyQuY2FtZWxDYXNlKGtleSldID0gc3R5bGVba2V5XTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdC8vIHN1cHBvcnQ6IE9wZXJhLCBJRSA8OVxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0Zm9yIChrZXkgaW4gc3R5bGUpIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAodHlwZW9mIHN0eWxlW2tleV0gPT09IFxcXCJzdHJpbmdcXFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0c3R5bGVzW2tleV0gPSBzdHlsZVtrZXldO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBzdHlsZXM7XFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIHN0eWxlRGlmZmVyZW5jZShvbGRTdHlsZSwgbmV3U3R5bGUpIHtcXG5cXHRcXHRcXHR2YXIgZGlmZiA9IHt9LFxcblxcdFxcdFxcdCAgICBuYW1lLFxcblxcdFxcdFxcdCAgICB2YWx1ZTtcXG5cXG5cXHRcXHRcXHRmb3IgKG5hbWUgaW4gbmV3U3R5bGUpIHtcXG5cXHRcXHRcXHRcXHR2YWx1ZSA9IG5ld1N0eWxlW25hbWVdO1xcblxcdFxcdFxcdFxcdGlmIChvbGRTdHlsZVtuYW1lXSAhPT0gdmFsdWUpIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIXNob3J0aGFuZFN0eWxlc1tuYW1lXSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICgkLmZ4LnN0ZXBbbmFtZV0gfHwgIWlzTmFOKHBhcnNlRmxvYXQodmFsdWUpKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGRpZmZbbmFtZV0gPSB2YWx1ZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGRpZmY7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIHN1cHBvcnQ6IGpRdWVyeSA8MS44XFxuXFx0XFx0aWYgKCEkLmZuLmFkZEJhY2spIHtcXG5cXHRcXHRcXHQkLmZuLmFkZEJhY2sgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5hZGQoc2VsZWN0b3IgPT0gbnVsbCA/IHRoaXMucHJldk9iamVjdCA6IHRoaXMucHJldk9iamVjdC5maWx0ZXIoc2VsZWN0b3IpKTtcXG5cXHRcXHRcXHR9O1xcblxcdFxcdH1cXG5cXG5cXHRcXHQkLmVmZmVjdHMuYW5pbWF0ZUNsYXNzID0gZnVuY3Rpb24gKHZhbHVlLCBkdXJhdGlvbiwgZWFzaW5nLCBjYWxsYmFjaykge1xcblxcdFxcdFxcdHZhciBvID0gJC5zcGVlZChkdXJhdGlvbiwgZWFzaW5nLCBjYWxsYmFjayk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMucXVldWUoZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdHZhciBhbmltYXRlZCA9ICQodGhpcyksXFxuXFx0XFx0XFx0XFx0ICAgIGJhc2VDbGFzcyA9IGFuaW1hdGVkLmF0dHIoXFxcImNsYXNzXFxcIikgfHwgXFxcIlxcXCIsXFxuXFx0XFx0XFx0XFx0ICAgIGFwcGx5Q2xhc3NDaGFuZ2UsXFxuXFx0XFx0XFx0XFx0ICAgIGFsbEFuaW1hdGlvbnMgPSBvLmNoaWxkcmVuID8gYW5pbWF0ZWQuZmluZChcXFwiKlxcXCIpLmFkZEJhY2soKSA6IGFuaW1hdGVkO1xcblxcblxcdFxcdFxcdFxcdC8vIG1hcCB0aGUgYW5pbWF0ZWQgb2JqZWN0cyB0byBzdG9yZSB0aGUgb3JpZ2luYWwgc3R5bGVzLlxcblxcdFxcdFxcdFxcdGFsbEFuaW1hdGlvbnMgPSBhbGxBbmltYXRpb25zLm1hcChmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGVsID0gJCh0aGlzKTtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4ge1xcblxcdFxcdFxcdFxcdFxcdFxcdGVsOiBlbCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRzdGFydDogZ2V0RWxlbWVudFN0eWxlcyh0aGlzKVxcblxcdFxcdFxcdFxcdFxcdH07XFxuXFx0XFx0XFx0XFx0fSk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gYXBwbHkgY2xhc3MgY2hhbmdlXFxuXFx0XFx0XFx0XFx0YXBwbHlDbGFzc0NoYW5nZSA9IGZ1bmN0aW9uIGFwcGx5Q2xhc3NDaGFuZ2UoKSB7XFxuXFx0XFx0XFx0XFx0XFx0JC5lYWNoKGNsYXNzQW5pbWF0aW9uQWN0aW9ucywgZnVuY3Rpb24gKGksIGFjdGlvbikge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICh2YWx1ZVthY3Rpb25dKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YW5pbWF0ZWRbYWN0aW9uICsgXFxcIkNsYXNzXFxcIl0odmFsdWVbYWN0aW9uXSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdFxcdH07XFxuXFx0XFx0XFx0XFx0YXBwbHlDbGFzc0NoYW5nZSgpO1xcblxcblxcdFxcdFxcdFxcdC8vIG1hcCBhbGwgYW5pbWF0ZWQgb2JqZWN0cyBhZ2FpbiAtIGNhbGN1bGF0ZSBuZXcgc3R5bGVzIGFuZCBkaWZmXFxuXFx0XFx0XFx0XFx0YWxsQW5pbWF0aW9ucyA9IGFsbEFuaW1hdGlvbnMubWFwKGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmVuZCA9IGdldEVsZW1lbnRTdHlsZXModGhpcy5lbFswXSk7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5kaWZmID0gc3R5bGVEaWZmZXJlbmNlKHRoaXMuc3RhcnQsIHRoaXMuZW5kKTtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXHRcXHRcXHRcXHR9KTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBhcHBseSBvcmlnaW5hbCBjbGFzc1xcblxcdFxcdFxcdFxcdGFuaW1hdGVkLmF0dHIoXFxcImNsYXNzXFxcIiwgYmFzZUNsYXNzKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBtYXAgYWxsIGFuaW1hdGVkIG9iamVjdHMgYWdhaW4gLSB0aGlzIHRpbWUgY29sbGVjdGluZyBhIHByb21pc2VcXG5cXHRcXHRcXHRcXHRhbGxBbmltYXRpb25zID0gYWxsQW5pbWF0aW9ucy5tYXAoZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdHZhciBzdHlsZUluZm8gPSB0aGlzLFxcblxcdFxcdFxcdFxcdFxcdCAgICBkZmQgPSAkLkRlZmVycmVkKCksXFxuXFx0XFx0XFx0XFx0XFx0ICAgIG9wdHMgPSAkLmV4dGVuZCh7fSwgbywge1xcblxcdFxcdFxcdFxcdFxcdFxcdHF1ZXVlOiBmYWxzZSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRjb21wbGV0ZTogZnVuY3Rpb24gY29tcGxldGUoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGZkLnJlc29sdmUoc3R5bGVJbmZvKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fSk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5lbC5hbmltYXRlKHRoaXMuZGlmZiwgb3B0cyk7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGRmZC5wcm9taXNlKCk7XFxuXFx0XFx0XFx0XFx0fSk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gb25jZSBhbGwgYW5pbWF0aW9ucyBoYXZlIGNvbXBsZXRlZDpcXG5cXHRcXHRcXHRcXHQkLndoZW4uYXBwbHkoJCwgYWxsQW5pbWF0aW9ucy5nZXQoKSkuZG9uZShmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gc2V0IHRoZSBmaW5hbCBjbGFzc1xcblxcdFxcdFxcdFxcdFxcdGFwcGx5Q2xhc3NDaGFuZ2UoKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBmb3IgZWFjaCBhbmltYXRlZCBlbGVtZW50LFxcblxcdFxcdFxcdFxcdFxcdC8vIGNsZWFyIGFsbCBjc3MgcHJvcGVydGllcyB0aGF0IHdlcmUgYW5pbWF0ZWRcXG5cXHRcXHRcXHRcXHRcXHQkLmVhY2goYXJndW1lbnRzLCBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIGVsID0gdGhpcy5lbDtcXG5cXHRcXHRcXHRcXHRcXHRcXHQkLmVhY2godGhpcy5kaWZmLCBmdW5jdGlvbiAoa2V5KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZWwuY3NzKGtleSwgXFxcIlxcXCIpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdFxcdFxcdH0pO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIHRoaXMgaXMgZ3Vhcm50ZWVkIHRvIGJlIHRoZXJlIGlmIHlvdSB1c2UgalF1ZXJ5LnNwZWVkKClcXG5cXHRcXHRcXHRcXHRcXHQvLyBpdCBhbHNvIGhhbmRsZXMgZGVxdWV1aW5nIHRoZSBuZXh0IGFuaW0uLi5cXG5cXHRcXHRcXHRcXHRcXHRvLmNvbXBsZXRlLmNhbGwoYW5pbWF0ZWRbMF0pO1xcblxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdH0pO1xcblxcdFxcdH07XFxuXFxuXFx0XFx0JC5mbi5leHRlbmQoe1xcblxcdFxcdFxcdGFkZENsYXNzOiBmdW5jdGlvbiAob3JpZykge1xcblxcdFxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiAoY2xhc3NOYW1lcywgc3BlZWQsIGVhc2luZywgY2FsbGJhY2spIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gc3BlZWQgPyAkLmVmZmVjdHMuYW5pbWF0ZUNsYXNzLmNhbGwodGhpcywgeyBhZGQ6IGNsYXNzTmFtZXMgfSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2spIDogb3JpZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcblxcdFxcdFxcdFxcdH07XFxuXFx0XFx0XFx0fSgkLmZuLmFkZENsYXNzKSxcXG5cXG5cXHRcXHRcXHRyZW1vdmVDbGFzczogZnVuY3Rpb24gKG9yaWcpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gKGNsYXNzTmFtZXMsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gJC5lZmZlY3RzLmFuaW1hdGVDbGFzcy5jYWxsKHRoaXMsIHsgcmVtb3ZlOiBjbGFzc05hbWVzIH0sIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrKSA6IG9yaWcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG5cXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdH0oJC5mbi5yZW1vdmVDbGFzcyksXFxuXFxuXFx0XFx0XFx0dG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uIChvcmlnKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIChjbGFzc05hbWVzLCBmb3JjZSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2spIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAodHlwZW9mIGZvcmNlID09PSBcXFwiYm9vbGVhblxcXCIgfHwgZm9yY2UgPT09IHVuZGVmaW5lZCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICghc3BlZWQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyB3aXRob3V0IHNwZWVkIHBhcmFtZXRlclxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBvcmlnLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gJC5lZmZlY3RzLmFuaW1hdGVDbGFzcy5jYWxsKHRoaXMsIGZvcmNlID8geyBhZGQ6IGNsYXNzTmFtZXMgfSA6IHsgcmVtb3ZlOiBjbGFzc05hbWVzIH0sIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyB3aXRob3V0IGZvcmNlIHBhcmFtZXRlclxcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiAkLmVmZmVjdHMuYW5pbWF0ZUNsYXNzLmNhbGwodGhpcywgeyB0b2dnbGU6IGNsYXNzTmFtZXMgfSwgZm9yY2UsIHNwZWVkLCBlYXNpbmcpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdH0oJC5mbi50b2dnbGVDbGFzcyksXFxuXFxuXFx0XFx0XFx0c3dpdGNoQ2xhc3M6IGZ1bmN0aW9uIHN3aXRjaENsYXNzKHJlbW92ZSwgYWRkLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjaykge1xcblxcdFxcdFxcdFxcdHJldHVybiAkLmVmZmVjdHMuYW5pbWF0ZUNsYXNzLmNhbGwodGhpcywge1xcblxcdFxcdFxcdFxcdFxcdGFkZDogYWRkLFxcblxcdFxcdFxcdFxcdFxcdHJlbW92ZTogcmVtb3ZlXFxuXFx0XFx0XFx0XFx0fSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2spO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9KTtcXG5cXHR9KSgpO1xcblxcblxcdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuXFx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIEVGRkVDVFMgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG5cXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcblxcblxcdChmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0JC5leHRlbmQoJC5lZmZlY3RzLCB7XFxuXFx0XFx0XFx0dmVyc2lvbjogXFxcIjEuMTEuNFxcXCIsXFxuXFxuXFx0XFx0XFx0Ly8gU2F2ZXMgYSBzZXQgb2YgcHJvcGVydGllcyBpbiBhIGRhdGEgc3RvcmFnZVxcblxcdFxcdFxcdHNhdmU6IGZ1bmN0aW9uIHNhdmUoZWxlbWVudCwgc2V0KSB7XFxuXFx0XFx0XFx0XFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoc2V0W2ldICE9PSBudWxsKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZWxlbWVudC5kYXRhKGRhdGFTcGFjZSArIHNldFtpXSwgZWxlbWVudFswXS5zdHlsZVtzZXRbaV1dKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0Ly8gUmVzdG9yZXMgYSBzZXQgb2YgcHJldmlvdXNseSBzYXZlZCBwcm9wZXJ0aWVzIGZyb20gYSBkYXRhIHN0b3JhZ2VcXG5cXHRcXHRcXHRyZXN0b3JlOiBmdW5jdGlvbiByZXN0b3JlKGVsZW1lbnQsIHNldCkge1xcblxcdFxcdFxcdFxcdHZhciB2YWwsIGk7XFxuXFx0XFx0XFx0XFx0Zm9yIChpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKykge1xcblxcdFxcdFxcdFxcdFxcdGlmIChzZXRbaV0gIT09IG51bGwpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YWwgPSBlbGVtZW50LmRhdGEoZGF0YVNwYWNlICsgc2V0W2ldKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBzdXBwb3J0OiBqUXVlcnkgMS42LjJcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC85OTE3XFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8galF1ZXJ5IDEuNi4yIGluY29ycmVjdGx5IHJldHVybnMgdW5kZWZpbmVkIGZvciBhbnkgZmFsc3kgdmFsdWUuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gV2UgY2FuJ3QgZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIFxcXCJcXFwiIGFuZCAwIGhlcmUsIHNvIHdlIGp1c3QgYXNzdW1lXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gZW1wdHkgc3RyaW5nIHNpbmNlIGl0J3MgbGlrZWx5IHRvIGJlIGEgbW9yZSBjb21tb24gdmFsdWUuLi5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAodmFsID09PSB1bmRlZmluZWQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YWwgPSBcXFwiXFxcIjtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZWxlbWVudC5jc3Moc2V0W2ldLCB2YWwpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRzZXRNb2RlOiBmdW5jdGlvbiBzZXRNb2RlKGVsLCBtb2RlKSB7XFxuXFx0XFx0XFx0XFx0aWYgKG1vZGUgPT09IFxcXCJ0b2dnbGVcXFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0bW9kZSA9IGVsLmlzKFxcXCI6aGlkZGVuXFxcIikgPyBcXFwic2hvd1xcXCIgOiBcXFwiaGlkZVxcXCI7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHJldHVybiBtb2RlO1xcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0Ly8gVHJhbnNsYXRlcyBhIFt0b3AsbGVmdF0gYXJyYXkgaW50byBhIGJhc2VsaW5lIHZhbHVlXFxuXFx0XFx0XFx0Ly8gdGhpcyBzaG91bGQgYmUgYSBsaXR0bGUgbW9yZSBmbGV4aWJsZSBpbiB0aGUgZnV0dXJlIHRvIGhhbmRsZSBhIHN0cmluZyAmIGhhc2hcXG5cXHRcXHRcXHRnZXRCYXNlbGluZTogZnVuY3Rpb24gZ2V0QmFzZWxpbmUob3JpZ2luLCBvcmlnaW5hbCkge1xcblxcdFxcdFxcdFxcdHZhciB5LCB4O1xcblxcdFxcdFxcdFxcdHN3aXRjaCAob3JpZ2luWzBdKSB7XFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSBcXFwidG9wXFxcIjpcXG5cXHRcXHRcXHRcXHRcXHRcXHR5ID0gMDticmVhaztcXG5cXHRcXHRcXHRcXHRcXHRjYXNlIFxcXCJtaWRkbGVcXFwiOlxcblxcdFxcdFxcdFxcdFxcdFxcdHkgPSAwLjU7YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSBcXFwiYm90dG9tXFxcIjpcXG5cXHRcXHRcXHRcXHRcXHRcXHR5ID0gMTticmVhaztcXG5cXHRcXHRcXHRcXHRcXHRkZWZhdWx0OlxcblxcdFxcdFxcdFxcdFxcdFxcdHkgPSBvcmlnaW5bMF0gLyBvcmlnaW5hbC5oZWlnaHQ7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHN3aXRjaCAob3JpZ2luWzFdKSB7XFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSBcXFwibGVmdFxcXCI6XFxuXFx0XFx0XFx0XFx0XFx0XFx0eCA9IDA7YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSBcXFwiY2VudGVyXFxcIjpcXG5cXHRcXHRcXHRcXHRcXHRcXHR4ID0gMC41O2JyZWFrO1xcblxcdFxcdFxcdFxcdFxcdGNhc2UgXFxcInJpZ2h0XFxcIjpcXG5cXHRcXHRcXHRcXHRcXHRcXHR4ID0gMTticmVhaztcXG5cXHRcXHRcXHRcXHRcXHRkZWZhdWx0OlxcblxcdFxcdFxcdFxcdFxcdFxcdHggPSBvcmlnaW5bMV0gLyBvcmlnaW5hbC53aWR0aDtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHtcXG5cXHRcXHRcXHRcXHRcXHR4OiB4LFxcblxcdFxcdFxcdFxcdFxcdHk6IHlcXG5cXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0Ly8gV3JhcHMgdGhlIGVsZW1lbnQgYXJvdW5kIGEgd3JhcHBlciB0aGF0IGNvcGllcyBwb3NpdGlvbiBwcm9wZXJ0aWVzXFxuXFx0XFx0XFx0Y3JlYXRlV3JhcHBlcjogZnVuY3Rpb24gY3JlYXRlV3JhcHBlcihlbGVtZW50KSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gaWYgdGhlIGVsZW1lbnQgaXMgYWxyZWFkeSB3cmFwcGVkLCByZXR1cm4gaXRcXG5cXHRcXHRcXHRcXHRpZiAoZWxlbWVudC5wYXJlbnQoKS5pcyhcXFwiLnVpLWVmZmVjdHMtd3JhcHBlclxcXCIpKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGVsZW1lbnQucGFyZW50KCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIHdyYXAgdGhlIGVsZW1lbnRcXG5cXHRcXHRcXHRcXHR2YXIgcHJvcHMgPSB7XFxuXFx0XFx0XFx0XFx0XFx0d2lkdGg6IGVsZW1lbnQub3V0ZXJXaWR0aCh0cnVlKSxcXG5cXHRcXHRcXHRcXHRcXHRoZWlnaHQ6IGVsZW1lbnQub3V0ZXJIZWlnaHQodHJ1ZSksXFxuXFx0XFx0XFx0XFx0XFx0XFxcImZsb2F0XFxcIjogZWxlbWVudC5jc3MoXFxcImZsb2F0XFxcIilcXG5cXHRcXHRcXHRcXHR9LFxcblxcdFxcdFxcdFxcdCAgICB3cmFwcGVyID0gJChcXFwiPGRpdj48L2Rpdj5cXFwiKS5hZGRDbGFzcyhcXFwidWktZWZmZWN0cy13cmFwcGVyXFxcIikuY3NzKHtcXG5cXHRcXHRcXHRcXHRcXHRmb250U2l6ZTogXFxcIjEwMCVcXFwiLFxcblxcdFxcdFxcdFxcdFxcdGJhY2tncm91bmQ6IFxcXCJ0cmFuc3BhcmVudFxcXCIsXFxuXFx0XFx0XFx0XFx0XFx0Ym9yZGVyOiBcXFwibm9uZVxcXCIsXFxuXFx0XFx0XFx0XFx0XFx0bWFyZ2luOiAwLFxcblxcdFxcdFxcdFxcdFxcdHBhZGRpbmc6IDBcXG5cXHRcXHRcXHRcXHR9KSxcXG5cXG5cXHRcXHRcXHRcXHQvLyBTdG9yZSB0aGUgc2l6ZSBpbiBjYXNlIHdpZHRoL2hlaWdodCBhcmUgZGVmaW5lZCBpbiAlIC0gRml4ZXMgIzUyNDVcXG5cXHRcXHRcXHRcXHRzaXplID0ge1xcblxcdFxcdFxcdFxcdFxcdHdpZHRoOiBlbGVtZW50LndpZHRoKCksXFxuXFx0XFx0XFx0XFx0XFx0aGVpZ2h0OiBlbGVtZW50LmhlaWdodCgpXFxuXFx0XFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRcXHQgICAgYWN0aXZlID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcXG5cXG5cXHRcXHRcXHRcXHQvLyBzdXBwb3J0OiBGaXJlZm94XFxuXFx0XFx0XFx0XFx0Ly8gRmlyZWZveCBpbmNvcnJlY3RseSBleHBvc2VzIGFub255bW91cyBjb250ZW50XFxuXFx0XFx0XFx0XFx0Ly8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NTYxNjY0XFxuXFx0XFx0XFx0XFx0dHJ5IHtcXG5cXHRcXHRcXHRcXHRcXHRhY3RpdmUuaWQ7XFxuXFx0XFx0XFx0XFx0fSBjYXRjaCAoZSkge1xcblxcdFxcdFxcdFxcdFxcdGFjdGl2ZSA9IGRvY3VtZW50LmJvZHk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGVsZW1lbnQud3JhcCh3cmFwcGVyKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBGaXhlcyAjNzU5NSAtIEVsZW1lbnRzIGxvc2UgZm9jdXMgd2hlbiB3cmFwcGVkLlxcblxcdFxcdFxcdFxcdGlmIChlbGVtZW50WzBdID09PSBhY3RpdmUgfHwgJC5jb250YWlucyhlbGVtZW50WzBdLCBhY3RpdmUpKSB7XFxuXFx0XFx0XFx0XFx0XFx0JChhY3RpdmUpLmZvY3VzKCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHdyYXBwZXIgPSBlbGVtZW50LnBhcmVudCgpOyAvL0hvdGZpeCBmb3IgalF1ZXJ5IDEuNCBzaW5jZSBzb21lIGNoYW5nZSBpbiB3cmFwKCkgc2VlbXMgdG8gYWN0dWFsbHkgbG9zZSB0aGUgcmVmZXJlbmNlIHRvIHRoZSB3cmFwcGVkIGVsZW1lbnRcXG5cXG5cXHRcXHRcXHRcXHQvLyB0cmFuc2ZlciBwb3NpdGlvbmluZyBwcm9wZXJ0aWVzIHRvIHRoZSB3cmFwcGVyXFxuXFx0XFx0XFx0XFx0aWYgKGVsZW1lbnQuY3NzKFxcXCJwb3NpdGlvblxcXCIpID09PSBcXFwic3RhdGljXFxcIikge1xcblxcdFxcdFxcdFxcdFxcdHdyYXBwZXIuY3NzKHsgcG9zaXRpb246IFxcXCJyZWxhdGl2ZVxcXCIgfSk7XFxuXFx0XFx0XFx0XFx0XFx0ZWxlbWVudC5jc3MoeyBwb3NpdGlvbjogXFxcInJlbGF0aXZlXFxcIiB9KTtcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdCQuZXh0ZW5kKHByb3BzLCB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cG9zaXRpb246IGVsZW1lbnQuY3NzKFxcXCJwb3NpdGlvblxcXCIpLFxcblxcdFxcdFxcdFxcdFxcdFxcdHpJbmRleDogZWxlbWVudC5jc3MoXFxcInotaW5kZXhcXFwiKVxcblxcdFxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdFxcdFxcdCQuZWFjaChbXFxcInRvcFxcXCIsIFxcXCJsZWZ0XFxcIiwgXFxcImJvdHRvbVxcXCIsIFxcXCJyaWdodFxcXCJdLCBmdW5jdGlvbiAoaSwgcG9zKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cHJvcHNbcG9zXSA9IGVsZW1lbnQuY3NzKHBvcyk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKGlzTmFOKHBhcnNlSW50KHByb3BzW3Bvc10sIDEwKSkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRwcm9wc1twb3NdID0gXFxcImF1dG9cXFwiO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcXHRcXHRlbGVtZW50LmNzcyh7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cG9zaXRpb246IFxcXCJyZWxhdGl2ZVxcXCIsXFxuXFx0XFx0XFx0XFx0XFx0XFx0dG9wOiAwLFxcblxcdFxcdFxcdFxcdFxcdFxcdGxlZnQ6IDAsXFxuXFx0XFx0XFx0XFx0XFx0XFx0cmlnaHQ6IFxcXCJhdXRvXFxcIixcXG5cXHRcXHRcXHRcXHRcXHRcXHRib3R0b206IFxcXCJhdXRvXFxcIlxcblxcdFxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRlbGVtZW50LmNzcyhzaXplKTtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gd3JhcHBlci5jc3MocHJvcHMpLnNob3coKTtcXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdHJlbW92ZVdyYXBwZXI6IGZ1bmN0aW9uIHJlbW92ZVdyYXBwZXIoZWxlbWVudCkge1xcblxcdFxcdFxcdFxcdHZhciBhY3RpdmUgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xcblxcblxcdFxcdFxcdFxcdGlmIChlbGVtZW50LnBhcmVudCgpLmlzKFxcXCIudWktZWZmZWN0cy13cmFwcGVyXFxcIikpIHtcXG5cXHRcXHRcXHRcXHRcXHRlbGVtZW50LnBhcmVudCgpLnJlcGxhY2VXaXRoKGVsZW1lbnQpO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIEZpeGVzICM3NTk1IC0gRWxlbWVudHMgbG9zZSBmb2N1cyB3aGVuIHdyYXBwZWQuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKGVsZW1lbnRbMF0gPT09IGFjdGl2ZSB8fCAkLmNvbnRhaW5zKGVsZW1lbnRbMF0sIGFjdGl2ZSkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHQkKGFjdGl2ZSkuZm9jdXMoKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHJldHVybiBlbGVtZW50O1xcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0c2V0VHJhbnNpdGlvbjogZnVuY3Rpb24gc2V0VHJhbnNpdGlvbihlbGVtZW50LCBsaXN0LCBmYWN0b3IsIHZhbHVlKSB7XFxuXFx0XFx0XFx0XFx0dmFsdWUgPSB2YWx1ZSB8fCB7fTtcXG5cXHRcXHRcXHRcXHQkLmVhY2gobGlzdCwgZnVuY3Rpb24gKGksIHgpIHtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgdW5pdCA9IGVsZW1lbnQuY3NzVW5pdCh4KTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAodW5pdFswXSA+IDApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YWx1ZVt4XSA9IHVuaXRbMF0gKiBmYWN0b3IgKyB1bml0WzFdO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdmFsdWU7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0pO1xcblxcblxcdFxcdC8vIHJldHVybiBhbiBlZmZlY3Qgb3B0aW9ucyBvYmplY3QgZm9yIHRoZSBnaXZlbiBwYXJhbWV0ZXJzOlxcblxcdFxcdGZ1bmN0aW9uIF9ub3JtYWxpemVBcmd1bWVudHMoZWZmZWN0LCBvcHRpb25zLCBzcGVlZCwgY2FsbGJhY2spIHtcXG5cXG5cXHRcXHRcXHQvLyBhbGxvdyBwYXNzaW5nIGFsbCBvcHRpb25zIGFzIHRoZSBmaXJzdCBwYXJhbWV0ZXJcXG5cXHRcXHRcXHRpZiAoJC5pc1BsYWluT2JqZWN0KGVmZmVjdCkpIHtcXG5cXHRcXHRcXHRcXHRvcHRpb25zID0gZWZmZWN0O1xcblxcdFxcdFxcdFxcdGVmZmVjdCA9IGVmZmVjdC5lZmZlY3Q7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIGNvbnZlcnQgdG8gYW4gb2JqZWN0XFxuXFx0XFx0XFx0ZWZmZWN0ID0geyBlZmZlY3Q6IGVmZmVjdCB9O1xcblxcblxcdFxcdFxcdC8vIGNhdGNoIChlZmZlY3QsIG51bGwsIC4uLilcXG5cXHRcXHRcXHRpZiAob3B0aW9ucyA9PSBudWxsKSB7XFxuXFx0XFx0XFx0XFx0b3B0aW9ucyA9IHt9O1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBjYXRjaCAoZWZmZWN0LCBjYWxsYmFjaylcXG5cXHRcXHRcXHRpZiAoJC5pc0Z1bmN0aW9uKG9wdGlvbnMpKSB7XFxuXFx0XFx0XFx0XFx0Y2FsbGJhY2sgPSBvcHRpb25zO1xcblxcdFxcdFxcdFxcdHNwZWVkID0gbnVsbDtcXG5cXHRcXHRcXHRcXHRvcHRpb25zID0ge307XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIGNhdGNoIChlZmZlY3QsIHNwZWVkLCA/KVxcblxcdFxcdFxcdGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXFxcIm51bWJlclxcXCIgfHwgJC5meC5zcGVlZHNbb3B0aW9uc10pIHtcXG5cXHRcXHRcXHRcXHRjYWxsYmFjayA9IHNwZWVkO1xcblxcdFxcdFxcdFxcdHNwZWVkID0gb3B0aW9ucztcXG5cXHRcXHRcXHRcXHRvcHRpb25zID0ge307XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIGNhdGNoIChlZmZlY3QsIG9wdGlvbnMsIGNhbGxiYWNrKVxcblxcdFxcdFxcdGlmICgkLmlzRnVuY3Rpb24oc3BlZWQpKSB7XFxuXFx0XFx0XFx0XFx0Y2FsbGJhY2sgPSBzcGVlZDtcXG5cXHRcXHRcXHRcXHRzcGVlZCA9IG51bGw7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIGFkZCBvcHRpb25zIHRvIGVmZmVjdFxcblxcdFxcdFxcdGlmIChvcHRpb25zKSB7XFxuXFx0XFx0XFx0XFx0JC5leHRlbmQoZWZmZWN0LCBvcHRpb25zKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0c3BlZWQgPSBzcGVlZCB8fCBvcHRpb25zLmR1cmF0aW9uO1xcblxcdFxcdFxcdGVmZmVjdC5kdXJhdGlvbiA9ICQuZngub2ZmID8gMCA6IHR5cGVvZiBzcGVlZCA9PT0gXFxcIm51bWJlclxcXCIgPyBzcGVlZCA6IHNwZWVkIGluICQuZnguc3BlZWRzID8gJC5meC5zcGVlZHNbc3BlZWRdIDogJC5meC5zcGVlZHMuX2RlZmF1bHQ7XFxuXFxuXFx0XFx0XFx0ZWZmZWN0LmNvbXBsZXRlID0gY2FsbGJhY2sgfHwgb3B0aW9ucy5jb21wbGV0ZTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZWZmZWN0O1xcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiBzdGFuZGFyZEFuaW1hdGlvbk9wdGlvbihvcHRpb24pIHtcXG5cXHRcXHRcXHQvLyBWYWxpZCBzdGFuZGFyZCBzcGVlZHMgKG5vdGhpbmcsIG51bWJlciwgbmFtZWQgc3BlZWQpXFxuXFx0XFx0XFx0aWYgKCFvcHRpb24gfHwgdHlwZW9mIG9wdGlvbiA9PT0gXFxcIm51bWJlclxcXCIgfHwgJC5meC5zcGVlZHNbb3B0aW9uXSkge1xcblxcdFxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBJbnZhbGlkIHN0cmluZ3MgLSB0cmVhdCBhcyBcXFwibm9ybWFsXFxcIiBzcGVlZFxcblxcdFxcdFxcdGlmICh0eXBlb2Ygb3B0aW9uID09PSBcXFwic3RyaW5nXFxcIiAmJiAhJC5lZmZlY3RzLmVmZmVjdFtvcHRpb25dKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIENvbXBsZXRlIGNhbGxiYWNrXFxuXFx0XFx0XFx0aWYgKCQuaXNGdW5jdGlvbihvcHRpb24pKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIE9wdGlvbnMgaGFzaCAoYnV0IG5vdCBuYW1pbmcgYW4gZWZmZWN0KVxcblxcdFxcdFxcdGlmICgodHlwZW9mIG9wdGlvbiA9PT0gXFxcInVuZGVmaW5lZFxcXCIgPyBcXFwidW5kZWZpbmVkXFxcIiA6IF90eXBlb2Yob3B0aW9uKSkgPT09IFxcXCJvYmplY3RcXFwiICYmICFvcHRpb24uZWZmZWN0KSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIERpZG4ndCBtYXRjaCBhbnkgc3RhbmRhcmQgQVBJXFxuXFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQkLmZuLmV4dGVuZCh7XFxuXFx0XFx0XFx0ZWZmZWN0OiBmdW5jdGlvbiBlZmZlY3QoKSAvKiBlZmZlY3QsIG9wdGlvbnMsIHNwZWVkLCBjYWxsYmFjayAqL3tcXG5cXHRcXHRcXHRcXHR2YXIgYXJncyA9IF9ub3JtYWxpemVBcmd1bWVudHMuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcXG5cXHRcXHRcXHRcXHQgICAgbW9kZSA9IGFyZ3MubW9kZSxcXG5cXHRcXHRcXHRcXHQgICAgcXVldWUgPSBhcmdzLnF1ZXVlLFxcblxcdFxcdFxcdFxcdCAgICBlZmZlY3RNZXRob2QgPSAkLmVmZmVjdHMuZWZmZWN0W2FyZ3MuZWZmZWN0XTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoJC5meC5vZmYgfHwgIWVmZmVjdE1ldGhvZCkge1xcblxcdFxcdFxcdFxcdFxcdC8vIGRlbGVnYXRlIHRvIHRoZSBvcmlnaW5hbCBtZXRob2QgKGUuZy4sIC5zaG93KCkpIGlmIHBvc3NpYmxlXFxuXFx0XFx0XFx0XFx0XFx0aWYgKG1vZGUpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhpc1ttb2RlXShhcmdzLmR1cmF0aW9uLCBhcmdzLmNvbXBsZXRlKTtcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChhcmdzLmNvbXBsZXRlKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YXJncy5jb21wbGV0ZS5jYWxsKHRoaXMpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGZ1bmN0aW9uIHJ1bihuZXh0KSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGVsZW0gPSAkKHRoaXMpLFxcblxcdFxcdFxcdFxcdFxcdCAgICBjb21wbGV0ZSA9IGFyZ3MuY29tcGxldGUsXFxuXFx0XFx0XFx0XFx0XFx0ICAgIG1vZGUgPSBhcmdzLm1vZGU7XFxuXFxuXFx0XFx0XFx0XFx0XFx0ZnVuY3Rpb24gZG9uZSgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoJC5pc0Z1bmN0aW9uKGNvbXBsZXRlKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGNvbXBsZXRlLmNhbGwoZWxlbVswXSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICgkLmlzRnVuY3Rpb24obmV4dCkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRuZXh0KCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBJZiB0aGUgZWxlbWVudCBhbHJlYWR5IGhhcyB0aGUgY29ycmVjdCBmaW5hbCBzdGF0ZSwgZGVsZWdhdGUgdG9cXG5cXHRcXHRcXHRcXHRcXHQvLyB0aGUgY29yZSBtZXRob2RzIHNvIHRoZSBpbnRlcm5hbCB0cmFja2luZyBvZiBcXFwib2xkZGlzcGxheVxcXCIgd29ya3MuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKGVsZW0uaXMoXFxcIjpoaWRkZW5cXFwiKSA/IG1vZGUgPT09IFxcXCJoaWRlXFxcIiA6IG1vZGUgPT09IFxcXCJzaG93XFxcIikge1xcblxcdFxcdFxcdFxcdFxcdFxcdGVsZW1bbW9kZV0oKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRkb25lKCk7XFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRlZmZlY3RNZXRob2QuY2FsbChlbGVtWzBdLCBhcmdzLCBkb25lKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHJldHVybiBxdWV1ZSA9PT0gZmFsc2UgPyB0aGlzLmVhY2gocnVuKSA6IHRoaXMucXVldWUocXVldWUgfHwgXFxcImZ4XFxcIiwgcnVuKTtcXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdHNob3c6IGZ1bmN0aW9uIChvcmlnKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIChvcHRpb24pIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoc3RhbmRhcmRBbmltYXRpb25PcHRpb24ob3B0aW9uKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBvcmlnLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgYXJncyA9IF9ub3JtYWxpemVBcmd1bWVudHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRhcmdzLm1vZGUgPSBcXFwic2hvd1xcXCI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuZWZmZWN0LmNhbGwodGhpcywgYXJncyk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH07XFxuXFx0XFx0XFx0fSgkLmZuLnNob3cpLFxcblxcblxcdFxcdFxcdGhpZGU6IGZ1bmN0aW9uIChvcmlnKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIChvcHRpb24pIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoc3RhbmRhcmRBbmltYXRpb25PcHRpb24ob3B0aW9uKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBvcmlnLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgYXJncyA9IF9ub3JtYWxpemVBcmd1bWVudHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRhcmdzLm1vZGUgPSBcXFwiaGlkZVxcXCI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuZWZmZWN0LmNhbGwodGhpcywgYXJncyk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH07XFxuXFx0XFx0XFx0fSgkLmZuLmhpZGUpLFxcblxcblxcdFxcdFxcdHRvZ2dsZTogZnVuY3Rpb24gKG9yaWcpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gKG9wdGlvbikge1xcblxcdFxcdFxcdFxcdFxcdGlmIChzdGFuZGFyZEFuaW1hdGlvbk9wdGlvbihvcHRpb24pIHx8IHR5cGVvZiBvcHRpb24gPT09IFxcXCJib29sZWFuXFxcIikge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBvcmlnLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgYXJncyA9IF9ub3JtYWxpemVBcmd1bWVudHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRhcmdzLm1vZGUgPSBcXFwidG9nZ2xlXFxcIjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5lZmZlY3QuY2FsbCh0aGlzLCBhcmdzKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fTtcXG5cXHRcXHRcXHR9KCQuZm4udG9nZ2xlKSxcXG5cXG5cXHRcXHRcXHQvLyBoZWxwZXIgZnVuY3Rpb25zXFxuXFx0XFx0XFx0Y3NzVW5pdDogZnVuY3Rpb24gY3NzVW5pdChrZXkpIHtcXG5cXHRcXHRcXHRcXHR2YXIgc3R5bGUgPSB0aGlzLmNzcyhrZXkpLFxcblxcdFxcdFxcdFxcdCAgICB2YWwgPSBbXTtcXG5cXG5cXHRcXHRcXHRcXHQkLmVhY2goW1xcXCJlbVxcXCIsIFxcXCJweFxcXCIsIFxcXCIlXFxcIiwgXFxcInB0XFxcIl0sIGZ1bmN0aW9uIChpLCB1bml0KSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHN0eWxlLmluZGV4T2YodW5pdCkgPiAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFsID0gW3BhcnNlRmxvYXQoc3R5bGUpLCB1bml0XTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHZhbDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSk7XFxuXFx0fSkoKTtcXG5cXG5cXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcblxcdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBFQVNJTkcgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuXFx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG5cXG5cXHQoZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdC8vIGJhc2VkIG9uIGVhc2luZyBlcXVhdGlvbnMgZnJvbSBSb2JlcnQgUGVubmVyIChodHRwOi8vd3d3LnJvYmVydHBlbm5lci5jb20vZWFzaW5nKVxcblxcblxcdFxcdHZhciBiYXNlRWFzaW5ncyA9IHt9O1xcblxcblxcdFxcdCQuZWFjaChbXFxcIlF1YWRcXFwiLCBcXFwiQ3ViaWNcXFwiLCBcXFwiUXVhcnRcXFwiLCBcXFwiUXVpbnRcXFwiLCBcXFwiRXhwb1xcXCJdLCBmdW5jdGlvbiAoaSwgbmFtZSkge1xcblxcdFxcdFxcdGJhc2VFYXNpbmdzW25hbWVdID0gZnVuY3Rpb24gKHApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gTWF0aC5wb3cocCwgaSArIDIpO1xcblxcdFxcdFxcdH07XFxuXFx0XFx0fSk7XFxuXFxuXFx0XFx0JC5leHRlbmQoYmFzZUVhc2luZ3MsIHtcXG5cXHRcXHRcXHRTaW5lOiBmdW5jdGlvbiBTaW5lKHApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gMSAtIE1hdGguY29zKHAgKiBNYXRoLlBJIC8gMik7XFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRDaXJjOiBmdW5jdGlvbiBDaXJjKHApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gMSAtIE1hdGguc3FydCgxIC0gcCAqIHApO1xcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0RWxhc3RpYzogZnVuY3Rpb24gRWxhc3RpYyhwKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHAgPT09IDAgfHwgcCA9PT0gMSA/IHAgOiAtTWF0aC5wb3coMiwgOCAqIChwIC0gMSkpICogTWF0aC5zaW4oKChwIC0gMSkgKiA4MCAtIDcuNSkgKiBNYXRoLlBJIC8gMTUpO1xcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0QmFjazogZnVuY3Rpb24gQmFjayhwKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHAgKiBwICogKDMgKiBwIC0gMik7XFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRCb3VuY2U6IGZ1bmN0aW9uIEJvdW5jZShwKSB7XFxuXFx0XFx0XFx0XFx0dmFyIHBvdzIsXFxuXFx0XFx0XFx0XFx0ICAgIGJvdW5jZSA9IDQ7XFxuXFxuXFx0XFx0XFx0XFx0d2hpbGUgKHAgPCAoKHBvdzIgPSBNYXRoLnBvdygyLCAtLWJvdW5jZSkpIC0gMSkgLyAxMSkge31cXG5cXHRcXHRcXHRcXHRyZXR1cm4gMSAvIE1hdGgucG93KDQsIDMgLSBib3VuY2UpIC0gNy41NjI1ICogTWF0aC5wb3coKHBvdzIgKiAzIC0gMikgLyAyMiAtIHAsIDIpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9KTtcXG5cXG5cXHRcXHQkLmVhY2goYmFzZUVhc2luZ3MsIGZ1bmN0aW9uIChuYW1lLCBlYXNlSW4pIHtcXG5cXHRcXHRcXHQkLmVhc2luZ1tcXFwiZWFzZUluXFxcIiArIG5hbWVdID0gZWFzZUluO1xcblxcdFxcdFxcdCQuZWFzaW5nW1xcXCJlYXNlT3V0XFxcIiArIG5hbWVdID0gZnVuY3Rpb24gKHApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gMSAtIGVhc2VJbigxIC0gcCk7XFxuXFx0XFx0XFx0fTtcXG5cXHRcXHRcXHQkLmVhc2luZ1tcXFwiZWFzZUluT3V0XFxcIiArIG5hbWVdID0gZnVuY3Rpb24gKHApIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gcCA8IDAuNSA/IGVhc2VJbihwICogMikgLyAyIDogMSAtIGVhc2VJbihwICogLTIgKyAyKSAvIDI7XFxuXFx0XFx0XFx0fTtcXG5cXHRcXHR9KTtcXG5cXHR9KSgpO1xcblxcblxcdHZhciBlZmZlY3QgPSAkLmVmZmVjdHM7XFxuXFxuXFx0LyohXFxuICAqIGpRdWVyeSBVSSBFZmZlY3RzIEJsaW5kIDEuMTEuNFxcbiAgKiBodHRwOi8vanF1ZXJ5dWkuY29tXFxuICAqXFxuICAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXFxuICAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cXG4gICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxcbiAgKlxcbiAgKiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9ibGluZC1lZmZlY3QvXFxuICAqL1xcblxcblxcdHZhciBlZmZlY3RCbGluZCA9ICQuZWZmZWN0cy5lZmZlY3QuYmxpbmQgPSBmdW5jdGlvbiAobywgZG9uZSkge1xcblxcdFxcdC8vIENyZWF0ZSBlbGVtZW50XFxuXFx0XFx0dmFyIGVsID0gJCh0aGlzKSxcXG5cXHRcXHQgICAgcnZlcnRpY2FsID0gL3VwfGRvd258dmVydGljYWwvLFxcblxcdFxcdCAgICBycG9zaXRpdmVtb3Rpb24gPSAvdXB8bGVmdHx2ZXJ0aWNhbHxob3Jpem9udGFsLyxcXG5cXHRcXHQgICAgcHJvcHMgPSBbXFxcInBvc2l0aW9uXFxcIiwgXFxcInRvcFxcXCIsIFxcXCJib3R0b21cXFwiLCBcXFwibGVmdFxcXCIsIFxcXCJyaWdodFxcXCIsIFxcXCJoZWlnaHRcXFwiLCBcXFwid2lkdGhcXFwiXSxcXG5cXHRcXHQgICAgbW9kZSA9ICQuZWZmZWN0cy5zZXRNb2RlKGVsLCBvLm1vZGUgfHwgXFxcImhpZGVcXFwiKSxcXG5cXHRcXHQgICAgZGlyZWN0aW9uID0gby5kaXJlY3Rpb24gfHwgXFxcInVwXFxcIixcXG5cXHRcXHQgICAgdmVydGljYWwgPSBydmVydGljYWwudGVzdChkaXJlY3Rpb24pLFxcblxcdFxcdCAgICByZWYgPSB2ZXJ0aWNhbCA/IFxcXCJoZWlnaHRcXFwiIDogXFxcIndpZHRoXFxcIixcXG5cXHRcXHQgICAgcmVmMiA9IHZlcnRpY2FsID8gXFxcInRvcFxcXCIgOiBcXFwibGVmdFxcXCIsXFxuXFx0XFx0ICAgIG1vdGlvbiA9IHJwb3NpdGl2ZW1vdGlvbi50ZXN0KGRpcmVjdGlvbiksXFxuXFx0XFx0ICAgIGFuaW1hdGlvbiA9IHt9LFxcblxcdFxcdCAgICBzaG93ID0gbW9kZSA9PT0gXFxcInNob3dcXFwiLFxcblxcdFxcdCAgICB3cmFwcGVyLFxcblxcdFxcdCAgICBkaXN0YW5jZSxcXG5cXHRcXHQgICAgbWFyZ2luO1xcblxcblxcdFxcdC8vIGlmIGFscmVhZHkgd3JhcHBlZCwgdGhlIHdyYXBwZXIncyBwcm9wZXJ0aWVzIGFyZSBteSBwcm9wZXJ0eS4gIzYyNDVcXG5cXHRcXHRpZiAoZWwucGFyZW50KCkuaXMoXFxcIi51aS1lZmZlY3RzLXdyYXBwZXJcXFwiKSkge1xcblxcdFxcdFxcdCQuZWZmZWN0cy5zYXZlKGVsLnBhcmVudCgpLCBwcm9wcyk7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHQkLmVmZmVjdHMuc2F2ZShlbCwgcHJvcHMpO1xcblxcdFxcdH1cXG5cXHRcXHRlbC5zaG93KCk7XFxuXFx0XFx0d3JhcHBlciA9ICQuZWZmZWN0cy5jcmVhdGVXcmFwcGVyKGVsKS5jc3Moe1xcblxcdFxcdFxcdG92ZXJmbG93OiBcXFwiaGlkZGVuXFxcIlxcblxcdFxcdH0pO1xcblxcblxcdFxcdGRpc3RhbmNlID0gd3JhcHBlcltyZWZdKCk7XFxuXFx0XFx0bWFyZ2luID0gcGFyc2VGbG9hdCh3cmFwcGVyLmNzcyhyZWYyKSkgfHwgMDtcXG5cXG5cXHRcXHRhbmltYXRpb25bcmVmXSA9IHNob3cgPyBkaXN0YW5jZSA6IDA7XFxuXFx0XFx0aWYgKCFtb3Rpb24pIHtcXG5cXHRcXHRcXHRlbC5jc3ModmVydGljYWwgPyBcXFwiYm90dG9tXFxcIiA6IFxcXCJyaWdodFxcXCIsIDApLmNzcyh2ZXJ0aWNhbCA/IFxcXCJ0b3BcXFwiIDogXFxcImxlZnRcXFwiLCBcXFwiYXV0b1xcXCIpLmNzcyh7IHBvc2l0aW9uOiBcXFwiYWJzb2x1dGVcXFwiIH0pO1xcblxcblxcdFxcdFxcdGFuaW1hdGlvbltyZWYyXSA9IHNob3cgPyBtYXJnaW4gOiBkaXN0YW5jZSArIG1hcmdpbjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gc3RhcnQgYXQgMCBpZiB3ZSBhcmUgc2hvd2luZ1xcblxcdFxcdGlmIChzaG93KSB7XFxuXFx0XFx0XFx0d3JhcHBlci5jc3MocmVmLCAwKTtcXG5cXHRcXHRcXHRpZiAoIW1vdGlvbikge1xcblxcdFxcdFxcdFxcdHdyYXBwZXIuY3NzKHJlZjIsIG1hcmdpbiArIGRpc3RhbmNlKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIEFuaW1hdGVcXG5cXHRcXHR3cmFwcGVyLmFuaW1hdGUoYW5pbWF0aW9uLCB7XFxuXFx0XFx0XFx0ZHVyYXRpb246IG8uZHVyYXRpb24sXFxuXFx0XFx0XFx0ZWFzaW5nOiBvLmVhc2luZyxcXG5cXHRcXHRcXHRxdWV1ZTogZmFsc2UsXFxuXFx0XFx0XFx0Y29tcGxldGU6IGZ1bmN0aW9uIGNvbXBsZXRlKCkge1xcblxcdFxcdFxcdFxcdGlmIChtb2RlID09PSBcXFwiaGlkZVxcXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRlbC5oaWRlKCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdCQuZWZmZWN0cy5yZXN0b3JlKGVsLCBwcm9wcyk7XFxuXFx0XFx0XFx0XFx0JC5lZmZlY3RzLnJlbW92ZVdyYXBwZXIoZWwpO1xcblxcdFxcdFxcdFxcdGRvbmUoKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSk7XFxuXFx0fTtcXG5cXG5cXHQvKiFcXG4gICogalF1ZXJ5IFVJIEVmZmVjdHMgQm91bmNlIDEuMTEuNFxcbiAgKiBodHRwOi8vanF1ZXJ5dWkuY29tXFxuICAqXFxuICAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXFxuICAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cXG4gICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxcbiAgKlxcbiAgKiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9ib3VuY2UtZWZmZWN0L1xcbiAgKi9cXG5cXG5cXHR2YXIgZWZmZWN0Qm91bmNlID0gJC5lZmZlY3RzLmVmZmVjdC5ib3VuY2UgPSBmdW5jdGlvbiAobywgZG9uZSkge1xcblxcdFxcdHZhciBlbCA9ICQodGhpcyksXFxuXFx0XFx0ICAgIHByb3BzID0gW1xcXCJwb3NpdGlvblxcXCIsIFxcXCJ0b3BcXFwiLCBcXFwiYm90dG9tXFxcIiwgXFxcImxlZnRcXFwiLCBcXFwicmlnaHRcXFwiLCBcXFwiaGVpZ2h0XFxcIiwgXFxcIndpZHRoXFxcIl0sXFxuXFxuXFxuXFx0XFx0Ly8gZGVmYXVsdHM6XFxuXFx0XFx0bW9kZSA9ICQuZWZmZWN0cy5zZXRNb2RlKGVsLCBvLm1vZGUgfHwgXFxcImVmZmVjdFxcXCIpLFxcblxcdFxcdCAgICBoaWRlID0gbW9kZSA9PT0gXFxcImhpZGVcXFwiLFxcblxcdFxcdCAgICBzaG93ID0gbW9kZSA9PT0gXFxcInNob3dcXFwiLFxcblxcdFxcdCAgICBkaXJlY3Rpb24gPSBvLmRpcmVjdGlvbiB8fCBcXFwidXBcXFwiLFxcblxcdFxcdCAgICBkaXN0YW5jZSA9IG8uZGlzdGFuY2UsXFxuXFx0XFx0ICAgIHRpbWVzID0gby50aW1lcyB8fCA1LFxcblxcblxcblxcdFxcdC8vIG51bWJlciBvZiBpbnRlcm5hbCBhbmltYXRpb25zXFxuXFx0XFx0YW5pbXMgPSB0aW1lcyAqIDIgKyAoc2hvdyB8fCBoaWRlID8gMSA6IDApLFxcblxcdFxcdCAgICBzcGVlZCA9IG8uZHVyYXRpb24gLyBhbmltcyxcXG5cXHRcXHQgICAgZWFzaW5nID0gby5lYXNpbmcsXFxuXFxuXFxuXFx0XFx0Ly8gdXRpbGl0eTpcXG5cXHRcXHRyZWYgPSBkaXJlY3Rpb24gPT09IFxcXCJ1cFxcXCIgfHwgZGlyZWN0aW9uID09PSBcXFwiZG93blxcXCIgPyBcXFwidG9wXFxcIiA6IFxcXCJsZWZ0XFxcIixcXG5cXHRcXHQgICAgbW90aW9uID0gZGlyZWN0aW9uID09PSBcXFwidXBcXFwiIHx8IGRpcmVjdGlvbiA9PT0gXFxcImxlZnRcXFwiLFxcblxcdFxcdCAgICBpLFxcblxcdFxcdCAgICB1cEFuaW0sXFxuXFx0XFx0ICAgIGRvd25BbmltLFxcblxcblxcblxcdFxcdC8vIHdlIHdpbGwgbmVlZCB0byByZS1hc3NlbWJsZSB0aGUgcXVldWUgdG8gc3RhY2sgb3VyIGFuaW1hdGlvbnMgaW4gcGxhY2VcXG5cXHRcXHRxdWV1ZSA9IGVsLnF1ZXVlKCksXFxuXFx0XFx0ICAgIHF1ZXVlbGVuID0gcXVldWUubGVuZ3RoO1xcblxcblxcdFxcdC8vIEF2b2lkIHRvdWNoaW5nIG9wYWNpdHkgdG8gcHJldmVudCBjbGVhclR5cGUgYW5kIFBORyBpc3N1ZXMgaW4gSUVcXG5cXHRcXHRpZiAoc2hvdyB8fCBoaWRlKSB7XFxuXFx0XFx0XFx0cHJvcHMucHVzaChcXFwib3BhY2l0eVxcXCIpO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQkLmVmZmVjdHMuc2F2ZShlbCwgcHJvcHMpO1xcblxcdFxcdGVsLnNob3coKTtcXG5cXHRcXHQkLmVmZmVjdHMuY3JlYXRlV3JhcHBlcihlbCk7IC8vIENyZWF0ZSBXcmFwcGVyXFxuXFxuXFx0XFx0Ly8gZGVmYXVsdCBkaXN0YW5jZSBmb3IgdGhlIEJJR0dFU1QgYm91bmNlIGlzIHRoZSBvdXRlciBEaXN0YW5jZSAvIDNcXG5cXHRcXHRpZiAoIWRpc3RhbmNlKSB7XFxuXFx0XFx0XFx0ZGlzdGFuY2UgPSBlbFtyZWYgPT09IFxcXCJ0b3BcXFwiID8gXFxcIm91dGVySGVpZ2h0XFxcIiA6IFxcXCJvdXRlcldpZHRoXFxcIl0oKSAvIDM7XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmIChzaG93KSB7XFxuXFx0XFx0XFx0ZG93bkFuaW0gPSB7IG9wYWNpdHk6IDEgfTtcXG5cXHRcXHRcXHRkb3duQW5pbVtyZWZdID0gMDtcXG5cXG5cXHRcXHRcXHQvLyBpZiB3ZSBhcmUgc2hvd2luZywgZm9yY2Ugb3BhY2l0eSAwIGFuZCBzZXQgdGhlIGluaXRpYWwgcG9zaXRpb25cXG5cXHRcXHRcXHQvLyB0aGVuIGRvIHRoZSBcXFwiZmlyc3RcXFwiIGFuaW1hdGlvblxcblxcdFxcdFxcdGVsLmNzcyhcXFwib3BhY2l0eVxcXCIsIDApLmNzcyhyZWYsIG1vdGlvbiA/IC1kaXN0YW5jZSAqIDIgOiBkaXN0YW5jZSAqIDIpLmFuaW1hdGUoZG93bkFuaW0sIHNwZWVkLCBlYXNpbmcpO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBzdGFydCBhdCB0aGUgc21hbGxlc3QgZGlzdGFuY2UgaWYgd2UgYXJlIGhpZGluZ1xcblxcdFxcdGlmIChoaWRlKSB7XFxuXFx0XFx0XFx0ZGlzdGFuY2UgPSBkaXN0YW5jZSAvIE1hdGgucG93KDIsIHRpbWVzIC0gMSk7XFxuXFx0XFx0fVxcblxcblxcdFxcdGRvd25BbmltID0ge307XFxuXFx0XFx0ZG93bkFuaW1bcmVmXSA9IDA7XFxuXFx0XFx0Ly8gQm91bmNlcyB1cC9kb3duL2xlZnQvcmlnaHQgdGhlbiBiYWNrIHRvIDAgLS0gdGltZXMgKiAyIGFuaW1hdGlvbnMgaGFwcGVuIGhlcmVcXG5cXHRcXHRmb3IgKGkgPSAwOyBpIDwgdGltZXM7IGkrKykge1xcblxcdFxcdFxcdHVwQW5pbSA9IHt9O1xcblxcdFxcdFxcdHVwQW5pbVtyZWZdID0gKG1vdGlvbiA/IFxcXCItPVxcXCIgOiBcXFwiKz1cXFwiKSArIGRpc3RhbmNlO1xcblxcblxcdFxcdFxcdGVsLmFuaW1hdGUodXBBbmltLCBzcGVlZCwgZWFzaW5nKS5hbmltYXRlKGRvd25BbmltLCBzcGVlZCwgZWFzaW5nKTtcXG5cXG5cXHRcXHRcXHRkaXN0YW5jZSA9IGhpZGUgPyBkaXN0YW5jZSAqIDIgOiBkaXN0YW5jZSAvIDI7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIExhc3QgQm91bmNlIHdoZW4gSGlkaW5nXFxuXFx0XFx0aWYgKGhpZGUpIHtcXG5cXHRcXHRcXHR1cEFuaW0gPSB7IG9wYWNpdHk6IDAgfTtcXG5cXHRcXHRcXHR1cEFuaW1bcmVmXSA9IChtb3Rpb24gPyBcXFwiLT1cXFwiIDogXFxcIis9XFxcIikgKyBkaXN0YW5jZTtcXG5cXG5cXHRcXHRcXHRlbC5hbmltYXRlKHVwQW5pbSwgc3BlZWQsIGVhc2luZyk7XFxuXFx0XFx0fVxcblxcblxcdFxcdGVsLnF1ZXVlKGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRpZiAoaGlkZSkge1xcblxcdFxcdFxcdFxcdGVsLmhpZGUoKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0JC5lZmZlY3RzLnJlc3RvcmUoZWwsIHByb3BzKTtcXG5cXHRcXHRcXHQkLmVmZmVjdHMucmVtb3ZlV3JhcHBlcihlbCk7XFxuXFx0XFx0XFx0ZG9uZSgpO1xcblxcdFxcdH0pO1xcblxcblxcdFxcdC8vIGluamVjdCBhbGwgdGhlIGFuaW1hdGlvbnMgd2UganVzdCBxdWV1ZWQgdG8gYmUgZmlyc3QgaW4gbGluZSAoYWZ0ZXIgXFxcImlucHJvZ3Jlc3NcXFwiKVxcblxcdFxcdGlmIChxdWV1ZWxlbiA+IDEpIHtcXG5cXHRcXHRcXHRxdWV1ZS5zcGxpY2UuYXBwbHkocXVldWUsIFsxLCAwXS5jb25jYXQocXVldWUuc3BsaWNlKHF1ZXVlbGVuLCBhbmltcyArIDEpKSk7XFxuXFx0XFx0fVxcblxcdFxcdGVsLmRlcXVldWUoKTtcXG5cXHR9O1xcblxcblxcdC8qIVxcbiAgKiBqUXVlcnkgVUkgRWZmZWN0cyBDbGlwIDEuMTEuNFxcbiAgKiBodHRwOi8vanF1ZXJ5dWkuY29tXFxuICAqXFxuICAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXFxuICAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cXG4gICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxcbiAgKlxcbiAgKiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9jbGlwLWVmZmVjdC9cXG4gICovXFxuXFxuXFx0dmFyIGVmZmVjdENsaXAgPSAkLmVmZmVjdHMuZWZmZWN0LmNsaXAgPSBmdW5jdGlvbiAobywgZG9uZSkge1xcblxcdFxcdC8vIENyZWF0ZSBlbGVtZW50XFxuXFx0XFx0dmFyIGVsID0gJCh0aGlzKSxcXG5cXHRcXHQgICAgcHJvcHMgPSBbXFxcInBvc2l0aW9uXFxcIiwgXFxcInRvcFxcXCIsIFxcXCJib3R0b21cXFwiLCBcXFwibGVmdFxcXCIsIFxcXCJyaWdodFxcXCIsIFxcXCJoZWlnaHRcXFwiLCBcXFwid2lkdGhcXFwiXSxcXG5cXHRcXHQgICAgbW9kZSA9ICQuZWZmZWN0cy5zZXRNb2RlKGVsLCBvLm1vZGUgfHwgXFxcImhpZGVcXFwiKSxcXG5cXHRcXHQgICAgc2hvdyA9IG1vZGUgPT09IFxcXCJzaG93XFxcIixcXG5cXHRcXHQgICAgZGlyZWN0aW9uID0gby5kaXJlY3Rpb24gfHwgXFxcInZlcnRpY2FsXFxcIixcXG5cXHRcXHQgICAgdmVydCA9IGRpcmVjdGlvbiA9PT0gXFxcInZlcnRpY2FsXFxcIixcXG5cXHRcXHQgICAgc2l6ZSA9IHZlcnQgPyBcXFwiaGVpZ2h0XFxcIiA6IFxcXCJ3aWR0aFxcXCIsXFxuXFx0XFx0ICAgIHBvc2l0aW9uID0gdmVydCA/IFxcXCJ0b3BcXFwiIDogXFxcImxlZnRcXFwiLFxcblxcdFxcdCAgICBhbmltYXRpb24gPSB7fSxcXG5cXHRcXHQgICAgd3JhcHBlcixcXG5cXHRcXHQgICAgYW5pbWF0ZSxcXG5cXHRcXHQgICAgZGlzdGFuY2U7XFxuXFxuXFx0XFx0Ly8gU2F2ZSAmIFNob3dcXG5cXHRcXHQkLmVmZmVjdHMuc2F2ZShlbCwgcHJvcHMpO1xcblxcdFxcdGVsLnNob3coKTtcXG5cXG5cXHRcXHQvLyBDcmVhdGUgV3JhcHBlclxcblxcdFxcdHdyYXBwZXIgPSAkLmVmZmVjdHMuY3JlYXRlV3JhcHBlcihlbCkuY3NzKHtcXG5cXHRcXHRcXHRvdmVyZmxvdzogXFxcImhpZGRlblxcXCJcXG5cXHRcXHR9KTtcXG5cXHRcXHRhbmltYXRlID0gZWxbMF0udGFnTmFtZSA9PT0gXFxcIklNR1xcXCIgPyB3cmFwcGVyIDogZWw7XFxuXFx0XFx0ZGlzdGFuY2UgPSBhbmltYXRlW3NpemVdKCk7XFxuXFxuXFx0XFx0Ly8gU2hpZnRcXG5cXHRcXHRpZiAoc2hvdykge1xcblxcdFxcdFxcdGFuaW1hdGUuY3NzKHNpemUsIDApO1xcblxcdFxcdFxcdGFuaW1hdGUuY3NzKHBvc2l0aW9uLCBkaXN0YW5jZSAvIDIpO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBDcmVhdGUgQW5pbWF0aW9uIE9iamVjdDpcXG5cXHRcXHRhbmltYXRpb25bc2l6ZV0gPSBzaG93ID8gZGlzdGFuY2UgOiAwO1xcblxcdFxcdGFuaW1hdGlvbltwb3NpdGlvbl0gPSBzaG93ID8gMCA6IGRpc3RhbmNlIC8gMjtcXG5cXG5cXHRcXHQvLyBBbmltYXRlXFxuXFx0XFx0YW5pbWF0ZS5hbmltYXRlKGFuaW1hdGlvbiwge1xcblxcdFxcdFxcdHF1ZXVlOiBmYWxzZSxcXG5cXHRcXHRcXHRkdXJhdGlvbjogby5kdXJhdGlvbixcXG5cXHRcXHRcXHRlYXNpbmc6IG8uZWFzaW5nLFxcblxcdFxcdFxcdGNvbXBsZXRlOiBmdW5jdGlvbiBjb21wbGV0ZSgpIHtcXG5cXHRcXHRcXHRcXHRpZiAoIXNob3cpIHtcXG5cXHRcXHRcXHRcXHRcXHRlbC5oaWRlKCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdCQuZWZmZWN0cy5yZXN0b3JlKGVsLCBwcm9wcyk7XFxuXFx0XFx0XFx0XFx0JC5lZmZlY3RzLnJlbW92ZVdyYXBwZXIoZWwpO1xcblxcdFxcdFxcdFxcdGRvbmUoKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSk7XFxuXFx0fTtcXG5cXG5cXHQvKiFcXG4gICogalF1ZXJ5IFVJIEVmZmVjdHMgRHJvcCAxLjExLjRcXG4gICogaHR0cDovL2pxdWVyeXVpLmNvbVxcbiAgKlxcbiAgKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xcbiAgKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXFxuICAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcXG4gICpcXG4gICogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20vZHJvcC1lZmZlY3QvXFxuICAqL1xcblxcblxcdHZhciBlZmZlY3REcm9wID0gJC5lZmZlY3RzLmVmZmVjdC5kcm9wID0gZnVuY3Rpb24gKG8sIGRvbmUpIHtcXG5cXG5cXHRcXHR2YXIgZWwgPSAkKHRoaXMpLFxcblxcdFxcdCAgICBwcm9wcyA9IFtcXFwicG9zaXRpb25cXFwiLCBcXFwidG9wXFxcIiwgXFxcImJvdHRvbVxcXCIsIFxcXCJsZWZ0XFxcIiwgXFxcInJpZ2h0XFxcIiwgXFxcIm9wYWNpdHlcXFwiLCBcXFwiaGVpZ2h0XFxcIiwgXFxcIndpZHRoXFxcIl0sXFxuXFx0XFx0ICAgIG1vZGUgPSAkLmVmZmVjdHMuc2V0TW9kZShlbCwgby5tb2RlIHx8IFxcXCJoaWRlXFxcIiksXFxuXFx0XFx0ICAgIHNob3cgPSBtb2RlID09PSBcXFwic2hvd1xcXCIsXFxuXFx0XFx0ICAgIGRpcmVjdGlvbiA9IG8uZGlyZWN0aW9uIHx8IFxcXCJsZWZ0XFxcIixcXG5cXHRcXHQgICAgcmVmID0gZGlyZWN0aW9uID09PSBcXFwidXBcXFwiIHx8IGRpcmVjdGlvbiA9PT0gXFxcImRvd25cXFwiID8gXFxcInRvcFxcXCIgOiBcXFwibGVmdFxcXCIsXFxuXFx0XFx0ICAgIG1vdGlvbiA9IGRpcmVjdGlvbiA9PT0gXFxcInVwXFxcIiB8fCBkaXJlY3Rpb24gPT09IFxcXCJsZWZ0XFxcIiA/IFxcXCJwb3NcXFwiIDogXFxcIm5lZ1xcXCIsXFxuXFx0XFx0ICAgIGFuaW1hdGlvbiA9IHtcXG5cXHRcXHRcXHRvcGFjaXR5OiBzaG93ID8gMSA6IDBcXG5cXHRcXHR9LFxcblxcdFxcdCAgICBkaXN0YW5jZTtcXG5cXG5cXHRcXHQvLyBBZGp1c3RcXG5cXHRcXHQkLmVmZmVjdHMuc2F2ZShlbCwgcHJvcHMpO1xcblxcdFxcdGVsLnNob3coKTtcXG5cXHRcXHQkLmVmZmVjdHMuY3JlYXRlV3JhcHBlcihlbCk7XFxuXFxuXFx0XFx0ZGlzdGFuY2UgPSBvLmRpc3RhbmNlIHx8IGVsW3JlZiA9PT0gXFxcInRvcFxcXCIgPyBcXFwib3V0ZXJIZWlnaHRcXFwiIDogXFxcIm91dGVyV2lkdGhcXFwiXSh0cnVlKSAvIDI7XFxuXFxuXFx0XFx0aWYgKHNob3cpIHtcXG5cXHRcXHRcXHRlbC5jc3MoXFxcIm9wYWNpdHlcXFwiLCAwKS5jc3MocmVmLCBtb3Rpb24gPT09IFxcXCJwb3NcXFwiID8gLWRpc3RhbmNlIDogZGlzdGFuY2UpO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBBbmltYXRpb25cXG5cXHRcXHRhbmltYXRpb25bcmVmXSA9IChzaG93ID8gbW90aW9uID09PSBcXFwicG9zXFxcIiA/IFxcXCIrPVxcXCIgOiBcXFwiLT1cXFwiIDogbW90aW9uID09PSBcXFwicG9zXFxcIiA/IFxcXCItPVxcXCIgOiBcXFwiKz1cXFwiKSArIGRpc3RhbmNlO1xcblxcblxcdFxcdC8vIEFuaW1hdGVcXG5cXHRcXHRlbC5hbmltYXRlKGFuaW1hdGlvbiwge1xcblxcdFxcdFxcdHF1ZXVlOiBmYWxzZSxcXG5cXHRcXHRcXHRkdXJhdGlvbjogby5kdXJhdGlvbixcXG5cXHRcXHRcXHRlYXNpbmc6IG8uZWFzaW5nLFxcblxcdFxcdFxcdGNvbXBsZXRlOiBmdW5jdGlvbiBjb21wbGV0ZSgpIHtcXG5cXHRcXHRcXHRcXHRpZiAobW9kZSA9PT0gXFxcImhpZGVcXFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZWwuaGlkZSgpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHQkLmVmZmVjdHMucmVzdG9yZShlbCwgcHJvcHMpO1xcblxcdFxcdFxcdFxcdCQuZWZmZWN0cy5yZW1vdmVXcmFwcGVyKGVsKTtcXG5cXHRcXHRcXHRcXHRkb25lKCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0pO1xcblxcdH07XFxuXFxuXFx0LyohXFxuICAqIGpRdWVyeSBVSSBFZmZlY3RzIEV4cGxvZGUgMS4xMS40XFxuICAqIGh0dHA6Ly9qcXVlcnl1aS5jb21cXG4gICpcXG4gICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcXG4gICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxcbiAgKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXFxuICAqXFxuICAqIGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL2V4cGxvZGUtZWZmZWN0L1xcbiAgKi9cXG5cXG5cXHR2YXIgZWZmZWN0RXhwbG9kZSA9ICQuZWZmZWN0cy5lZmZlY3QuZXhwbG9kZSA9IGZ1bmN0aW9uIChvLCBkb25lKSB7XFxuXFxuXFx0XFx0dmFyIHJvd3MgPSBvLnBpZWNlcyA/IE1hdGgucm91bmQoTWF0aC5zcXJ0KG8ucGllY2VzKSkgOiAzLFxcblxcdFxcdCAgICBjZWxscyA9IHJvd3MsXFxuXFx0XFx0ICAgIGVsID0gJCh0aGlzKSxcXG5cXHRcXHQgICAgbW9kZSA9ICQuZWZmZWN0cy5zZXRNb2RlKGVsLCBvLm1vZGUgfHwgXFxcImhpZGVcXFwiKSxcXG5cXHRcXHQgICAgc2hvdyA9IG1vZGUgPT09IFxcXCJzaG93XFxcIixcXG5cXG5cXG5cXHRcXHQvLyBzaG93IGFuZCB0aGVuIHZpc2liaWxpdHk6aGlkZGVuIHRoZSBlbGVtZW50IGJlZm9yZSBjYWxjdWxhdGluZyBvZmZzZXRcXG5cXHRcXHRvZmZzZXQgPSBlbC5zaG93KCkuY3NzKFxcXCJ2aXNpYmlsaXR5XFxcIiwgXFxcImhpZGRlblxcXCIpLm9mZnNldCgpLFxcblxcblxcblxcdFxcdC8vIHdpZHRoIGFuZCBoZWlnaHQgb2YgYSBwaWVjZVxcblxcdFxcdHdpZHRoID0gTWF0aC5jZWlsKGVsLm91dGVyV2lkdGgoKSAvIGNlbGxzKSxcXG5cXHRcXHQgICAgaGVpZ2h0ID0gTWF0aC5jZWlsKGVsLm91dGVySGVpZ2h0KCkgLyByb3dzKSxcXG5cXHRcXHQgICAgcGllY2VzID0gW10sXFxuXFxuXFxuXFx0XFx0Ly8gbG9vcFxcblxcdFxcdGksXFxuXFx0XFx0ICAgIGosXFxuXFx0XFx0ICAgIGxlZnQsXFxuXFx0XFx0ICAgIHRvcCxcXG5cXHRcXHQgICAgbXgsXFxuXFx0XFx0ICAgIG15O1xcblxcblxcdFxcdC8vIGNoaWxkcmVuIGFuaW1hdGUgY29tcGxldGU6XFxuXFx0XFx0ZnVuY3Rpb24gY2hpbGRDb21wbGV0ZSgpIHtcXG5cXHRcXHRcXHRwaWVjZXMucHVzaCh0aGlzKTtcXG5cXHRcXHRcXHRpZiAocGllY2VzLmxlbmd0aCA9PT0gcm93cyAqIGNlbGxzKSB7XFxuXFx0XFx0XFx0XFx0YW5pbUNvbXBsZXRlKCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBjbG9uZSB0aGUgZWxlbWVudCBmb3IgZWFjaCByb3cgYW5kIGNlbGwuXFxuXFx0XFx0Zm9yIChpID0gMDsgaSA8IHJvd3M7IGkrKykge1xcblxcdFxcdFxcdC8vID09PT5cXG5cXHRcXHRcXHR0b3AgPSBvZmZzZXQudG9wICsgaSAqIGhlaWdodDtcXG5cXHRcXHRcXHRteSA9IGkgLSAocm93cyAtIDEpIC8gMjtcXG5cXG5cXHRcXHRcXHRmb3IgKGogPSAwOyBqIDwgY2VsbHM7IGorKykge1xcblxcdFxcdFxcdFxcdC8vIHx8fFxcblxcdFxcdFxcdFxcdGxlZnQgPSBvZmZzZXQubGVmdCArIGogKiB3aWR0aDtcXG5cXHRcXHRcXHRcXHRteCA9IGogLSAoY2VsbHMgLSAxKSAvIDI7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQ3JlYXRlIGEgY2xvbmUgb2YgdGhlIG5vdyBoaWRkZW4gbWFpbiBlbGVtZW50IHRoYXQgd2lsbCBiZSBhYnNvbHV0ZSBwb3NpdGlvbmVkXFxuXFx0XFx0XFx0XFx0Ly8gd2l0aGluIGEgd3JhcHBlciBkaXYgb2ZmIHRoZSAtbGVmdCBhbmQgLXRvcCBlcXVhbCB0byBzaXplIG9mIG91ciBwaWVjZXNcXG5cXHRcXHRcXHRcXHRlbC5jbG9uZSgpLmFwcGVuZFRvKFxcXCJib2R5XFxcIikud3JhcChcXFwiPGRpdj48L2Rpdj5cXFwiKS5jc3Moe1xcblxcdFxcdFxcdFxcdFxcdHBvc2l0aW9uOiBcXFwiYWJzb2x1dGVcXFwiLFxcblxcdFxcdFxcdFxcdFxcdHZpc2liaWxpdHk6IFxcXCJ2aXNpYmxlXFxcIixcXG5cXHRcXHRcXHRcXHRcXHRsZWZ0OiAtaiAqIHdpZHRoLFxcblxcdFxcdFxcdFxcdFxcdHRvcDogLWkgKiBoZWlnaHRcXG5cXHRcXHRcXHRcXHR9KVxcblxcblxcdFxcdFxcdFxcdC8vIHNlbGVjdCB0aGUgd3JhcHBlciAtIG1ha2UgaXQgb3ZlcmZsb3c6IGhpZGRlbiBhbmQgYWJzb2x1dGUgcG9zaXRpb25lZCBiYXNlZCBvblxcblxcdFxcdFxcdFxcdC8vIHdoZXJlIHRoZSBvcmlnaW5hbCB3YXMgbG9jYXRlZCArbGVmdCBhbmQgK3RvcCBlcXVhbCB0byB0aGUgc2l6ZSBvZiBwaWVjZXNcXG5cXHRcXHRcXHRcXHQucGFyZW50KCkuYWRkQ2xhc3MoXFxcInVpLWVmZmVjdHMtZXhwbG9kZVxcXCIpLmNzcyh7XFxuXFx0XFx0XFx0XFx0XFx0cG9zaXRpb246IFxcXCJhYnNvbHV0ZVxcXCIsXFxuXFx0XFx0XFx0XFx0XFx0b3ZlcmZsb3c6IFxcXCJoaWRkZW5cXFwiLFxcblxcdFxcdFxcdFxcdFxcdHdpZHRoOiB3aWR0aCxcXG5cXHRcXHRcXHRcXHRcXHRoZWlnaHQ6IGhlaWdodCxcXG5cXHRcXHRcXHRcXHRcXHRsZWZ0OiBsZWZ0ICsgKHNob3cgPyBteCAqIHdpZHRoIDogMCksXFxuXFx0XFx0XFx0XFx0XFx0dG9wOiB0b3AgKyAoc2hvdyA/IG15ICogaGVpZ2h0IDogMCksXFxuXFx0XFx0XFx0XFx0XFx0b3BhY2l0eTogc2hvdyA/IDAgOiAxXFxuXFx0XFx0XFx0XFx0fSkuYW5pbWF0ZSh7XFxuXFx0XFx0XFx0XFx0XFx0bGVmdDogbGVmdCArIChzaG93ID8gMCA6IG14ICogd2lkdGgpLFxcblxcdFxcdFxcdFxcdFxcdHRvcDogdG9wICsgKHNob3cgPyAwIDogbXkgKiBoZWlnaHQpLFxcblxcdFxcdFxcdFxcdFxcdG9wYWNpdHk6IHNob3cgPyAxIDogMFxcblxcdFxcdFxcdFxcdH0sIG8uZHVyYXRpb24gfHwgNTAwLCBvLmVhc2luZywgY2hpbGRDb21wbGV0ZSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiBhbmltQ29tcGxldGUoKSB7XFxuXFx0XFx0XFx0ZWwuY3NzKHtcXG5cXHRcXHRcXHRcXHR2aXNpYmlsaXR5OiBcXFwidmlzaWJsZVxcXCJcXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHQkKHBpZWNlcykucmVtb3ZlKCk7XFxuXFx0XFx0XFx0aWYgKCFzaG93KSB7XFxuXFx0XFx0XFx0XFx0ZWwuaGlkZSgpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRkb25lKCk7XFxuXFx0XFx0fVxcblxcdH07XFxuXFxuXFx0LyohXFxuICAqIGpRdWVyeSBVSSBFZmZlY3RzIEZhZGUgMS4xMS40XFxuICAqIGh0dHA6Ly9qcXVlcnl1aS5jb21cXG4gICpcXG4gICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcXG4gICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxcbiAgKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXFxuICAqXFxuICAqIGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL2ZhZGUtZWZmZWN0L1xcbiAgKi9cXG5cXG5cXHR2YXIgZWZmZWN0RmFkZSA9ICQuZWZmZWN0cy5lZmZlY3QuZmFkZSA9IGZ1bmN0aW9uIChvLCBkb25lKSB7XFxuXFx0XFx0dmFyIGVsID0gJCh0aGlzKSxcXG5cXHRcXHQgICAgbW9kZSA9ICQuZWZmZWN0cy5zZXRNb2RlKGVsLCBvLm1vZGUgfHwgXFxcInRvZ2dsZVxcXCIpO1xcblxcblxcdFxcdGVsLmFuaW1hdGUoe1xcblxcdFxcdFxcdG9wYWNpdHk6IG1vZGVcXG5cXHRcXHR9LCB7XFxuXFx0XFx0XFx0cXVldWU6IGZhbHNlLFxcblxcdFxcdFxcdGR1cmF0aW9uOiBvLmR1cmF0aW9uLFxcblxcdFxcdFxcdGVhc2luZzogby5lYXNpbmcsXFxuXFx0XFx0XFx0Y29tcGxldGU6IGRvbmVcXG5cXHRcXHR9KTtcXG5cXHR9O1xcblxcblxcdC8qIVxcbiAgKiBqUXVlcnkgVUkgRWZmZWN0cyBGb2xkIDEuMTEuNFxcbiAgKiBodHRwOi8vanF1ZXJ5dWkuY29tXFxuICAqXFxuICAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXFxuICAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cXG4gICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxcbiAgKlxcbiAgKiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9mb2xkLWVmZmVjdC9cXG4gICovXFxuXFxuXFx0dmFyIGVmZmVjdEZvbGQgPSAkLmVmZmVjdHMuZWZmZWN0LmZvbGQgPSBmdW5jdGlvbiAobywgZG9uZSkge1xcblxcblxcdFxcdC8vIENyZWF0ZSBlbGVtZW50XFxuXFx0XFx0dmFyIGVsID0gJCh0aGlzKSxcXG5cXHRcXHQgICAgcHJvcHMgPSBbXFxcInBvc2l0aW9uXFxcIiwgXFxcInRvcFxcXCIsIFxcXCJib3R0b21cXFwiLCBcXFwibGVmdFxcXCIsIFxcXCJyaWdodFxcXCIsIFxcXCJoZWlnaHRcXFwiLCBcXFwid2lkdGhcXFwiXSxcXG5cXHRcXHQgICAgbW9kZSA9ICQuZWZmZWN0cy5zZXRNb2RlKGVsLCBvLm1vZGUgfHwgXFxcImhpZGVcXFwiKSxcXG5cXHRcXHQgICAgc2hvdyA9IG1vZGUgPT09IFxcXCJzaG93XFxcIixcXG5cXHRcXHQgICAgaGlkZSA9IG1vZGUgPT09IFxcXCJoaWRlXFxcIixcXG5cXHRcXHQgICAgc2l6ZSA9IG8uc2l6ZSB8fCAxNSxcXG5cXHRcXHQgICAgcGVyY2VudCA9IC8oWzAtOV0rKSUvLmV4ZWMoc2l6ZSksXFxuXFx0XFx0ICAgIGhvcml6Rmlyc3QgPSAhIW8uaG9yaXpGaXJzdCxcXG5cXHRcXHQgICAgd2lkdGhGaXJzdCA9IHNob3cgIT09IGhvcml6Rmlyc3QsXFxuXFx0XFx0ICAgIHJlZiA9IHdpZHRoRmlyc3QgPyBbXFxcIndpZHRoXFxcIiwgXFxcImhlaWdodFxcXCJdIDogW1xcXCJoZWlnaHRcXFwiLCBcXFwid2lkdGhcXFwiXSxcXG5cXHRcXHQgICAgZHVyYXRpb24gPSBvLmR1cmF0aW9uIC8gMixcXG5cXHRcXHQgICAgd3JhcHBlcixcXG5cXHRcXHQgICAgZGlzdGFuY2UsXFxuXFx0XFx0ICAgIGFuaW1hdGlvbjEgPSB7fSxcXG5cXHRcXHQgICAgYW5pbWF0aW9uMiA9IHt9O1xcblxcblxcdFxcdCQuZWZmZWN0cy5zYXZlKGVsLCBwcm9wcyk7XFxuXFx0XFx0ZWwuc2hvdygpO1xcblxcblxcdFxcdC8vIENyZWF0ZSBXcmFwcGVyXFxuXFx0XFx0d3JhcHBlciA9ICQuZWZmZWN0cy5jcmVhdGVXcmFwcGVyKGVsKS5jc3Moe1xcblxcdFxcdFxcdG92ZXJmbG93OiBcXFwiaGlkZGVuXFxcIlxcblxcdFxcdH0pO1xcblxcdFxcdGRpc3RhbmNlID0gd2lkdGhGaXJzdCA/IFt3cmFwcGVyLndpZHRoKCksIHdyYXBwZXIuaGVpZ2h0KCldIDogW3dyYXBwZXIuaGVpZ2h0KCksIHdyYXBwZXIud2lkdGgoKV07XFxuXFxuXFx0XFx0aWYgKHBlcmNlbnQpIHtcXG5cXHRcXHRcXHRzaXplID0gcGFyc2VJbnQocGVyY2VudFsxXSwgMTApIC8gMTAwICogZGlzdGFuY2VbaGlkZSA/IDAgOiAxXTtcXG5cXHRcXHR9XFxuXFx0XFx0aWYgKHNob3cpIHtcXG5cXHRcXHRcXHR3cmFwcGVyLmNzcyhob3JpekZpcnN0ID8ge1xcblxcdFxcdFxcdFxcdGhlaWdodDogMCxcXG5cXHRcXHRcXHRcXHR3aWR0aDogc2l6ZVxcblxcdFxcdFxcdH0gOiB7XFxuXFx0XFx0XFx0XFx0aGVpZ2h0OiBzaXplLFxcblxcdFxcdFxcdFxcdHdpZHRoOiAwXFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIEFuaW1hdGlvblxcblxcdFxcdGFuaW1hdGlvbjFbcmVmWzBdXSA9IHNob3cgPyBkaXN0YW5jZVswXSA6IHNpemU7XFxuXFx0XFx0YW5pbWF0aW9uMltyZWZbMV1dID0gc2hvdyA/IGRpc3RhbmNlWzFdIDogMDtcXG5cXG5cXHRcXHQvLyBBbmltYXRlXFxuXFx0XFx0d3JhcHBlci5hbmltYXRlKGFuaW1hdGlvbjEsIGR1cmF0aW9uLCBvLmVhc2luZykuYW5pbWF0ZShhbmltYXRpb24yLCBkdXJhdGlvbiwgby5lYXNpbmcsIGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRpZiAoaGlkZSkge1xcblxcdFxcdFxcdFxcdGVsLmhpZGUoKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0JC5lZmZlY3RzLnJlc3RvcmUoZWwsIHByb3BzKTtcXG5cXHRcXHRcXHQkLmVmZmVjdHMucmVtb3ZlV3JhcHBlcihlbCk7XFxuXFx0XFx0XFx0ZG9uZSgpO1xcblxcdFxcdH0pO1xcblxcdH07XFxuXFxuXFx0LyohXFxuICAqIGpRdWVyeSBVSSBFZmZlY3RzIEhpZ2hsaWdodCAxLjExLjRcXG4gICogaHR0cDovL2pxdWVyeXVpLmNvbVxcbiAgKlxcbiAgKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xcbiAgKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXFxuICAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcXG4gICpcXG4gICogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20vaGlnaGxpZ2h0LWVmZmVjdC9cXG4gICovXFxuXFxuXFx0dmFyIGVmZmVjdEhpZ2hsaWdodCA9ICQuZWZmZWN0cy5lZmZlY3QuaGlnaGxpZ2h0ID0gZnVuY3Rpb24gKG8sIGRvbmUpIHtcXG5cXHRcXHR2YXIgZWxlbSA9ICQodGhpcyksXFxuXFx0XFx0ICAgIHByb3BzID0gW1xcXCJiYWNrZ3JvdW5kSW1hZ2VcXFwiLCBcXFwiYmFja2dyb3VuZENvbG9yXFxcIiwgXFxcIm9wYWNpdHlcXFwiXSxcXG5cXHRcXHQgICAgbW9kZSA9ICQuZWZmZWN0cy5zZXRNb2RlKGVsZW0sIG8ubW9kZSB8fCBcXFwic2hvd1xcXCIpLFxcblxcdFxcdCAgICBhbmltYXRpb24gPSB7XFxuXFx0XFx0XFx0YmFja2dyb3VuZENvbG9yOiBlbGVtLmNzcyhcXFwiYmFja2dyb3VuZENvbG9yXFxcIilcXG5cXHRcXHR9O1xcblxcblxcdFxcdGlmIChtb2RlID09PSBcXFwiaGlkZVxcXCIpIHtcXG5cXHRcXHRcXHRhbmltYXRpb24ub3BhY2l0eSA9IDA7XFxuXFx0XFx0fVxcblxcblxcdFxcdCQuZWZmZWN0cy5zYXZlKGVsZW0sIHByb3BzKTtcXG5cXG5cXHRcXHRlbGVtLnNob3coKS5jc3Moe1xcblxcdFxcdFxcdGJhY2tncm91bmRJbWFnZTogXFxcIm5vbmVcXFwiLFxcblxcdFxcdFxcdGJhY2tncm91bmRDb2xvcjogby5jb2xvciB8fCBcXFwiI2ZmZmY5OVxcXCJcXG5cXHRcXHR9KS5hbmltYXRlKGFuaW1hdGlvbiwge1xcblxcdFxcdFxcdHF1ZXVlOiBmYWxzZSxcXG5cXHRcXHRcXHRkdXJhdGlvbjogby5kdXJhdGlvbixcXG5cXHRcXHRcXHRlYXNpbmc6IG8uZWFzaW5nLFxcblxcdFxcdFxcdGNvbXBsZXRlOiBmdW5jdGlvbiBjb21wbGV0ZSgpIHtcXG5cXHRcXHRcXHRcXHRpZiAobW9kZSA9PT0gXFxcImhpZGVcXFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZWxlbS5oaWRlKCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdCQuZWZmZWN0cy5yZXN0b3JlKGVsZW0sIHByb3BzKTtcXG5cXHRcXHRcXHRcXHRkb25lKCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0pO1xcblxcdH07XFxuXFxuXFx0LyohXFxuICAqIGpRdWVyeSBVSSBFZmZlY3RzIFNpemUgMS4xMS40XFxuICAqIGh0dHA6Ly9qcXVlcnl1aS5jb21cXG4gICpcXG4gICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcXG4gICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxcbiAgKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXFxuICAqXFxuICAqIGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL3NpemUtZWZmZWN0L1xcbiAgKi9cXG5cXG5cXHR2YXIgZWZmZWN0U2l6ZSA9ICQuZWZmZWN0cy5lZmZlY3Quc2l6ZSA9IGZ1bmN0aW9uIChvLCBkb25lKSB7XFxuXFxuXFx0XFx0Ly8gQ3JlYXRlIGVsZW1lbnRcXG5cXHRcXHR2YXIgb3JpZ2luYWwsXFxuXFx0XFx0ICAgIGJhc2VsaW5lLFxcblxcdFxcdCAgICBmYWN0b3IsXFxuXFx0XFx0ICAgIGVsID0gJCh0aGlzKSxcXG5cXHRcXHQgICAgcHJvcHMwID0gW1xcXCJwb3NpdGlvblxcXCIsIFxcXCJ0b3BcXFwiLCBcXFwiYm90dG9tXFxcIiwgXFxcImxlZnRcXFwiLCBcXFwicmlnaHRcXFwiLCBcXFwid2lkdGhcXFwiLCBcXFwiaGVpZ2h0XFxcIiwgXFxcIm92ZXJmbG93XFxcIiwgXFxcIm9wYWNpdHlcXFwiXSxcXG5cXG5cXG5cXHRcXHQvLyBBbHdheXMgcmVzdG9yZVxcblxcdFxcdHByb3BzMSA9IFtcXFwicG9zaXRpb25cXFwiLCBcXFwidG9wXFxcIiwgXFxcImJvdHRvbVxcXCIsIFxcXCJsZWZ0XFxcIiwgXFxcInJpZ2h0XFxcIiwgXFxcIm92ZXJmbG93XFxcIiwgXFxcIm9wYWNpdHlcXFwiXSxcXG5cXG5cXG5cXHRcXHQvLyBDb3B5IGZvciBjaGlsZHJlblxcblxcdFxcdHByb3BzMiA9IFtcXFwid2lkdGhcXFwiLCBcXFwiaGVpZ2h0XFxcIiwgXFxcIm92ZXJmbG93XFxcIl0sXFxuXFx0XFx0ICAgIGNQcm9wcyA9IFtcXFwiZm9udFNpemVcXFwiXSxcXG5cXHRcXHQgICAgdlByb3BzID0gW1xcXCJib3JkZXJUb3BXaWR0aFxcXCIsIFxcXCJib3JkZXJCb3R0b21XaWR0aFxcXCIsIFxcXCJwYWRkaW5nVG9wXFxcIiwgXFxcInBhZGRpbmdCb3R0b21cXFwiXSxcXG5cXHRcXHQgICAgaFByb3BzID0gW1xcXCJib3JkZXJMZWZ0V2lkdGhcXFwiLCBcXFwiYm9yZGVyUmlnaHRXaWR0aFxcXCIsIFxcXCJwYWRkaW5nTGVmdFxcXCIsIFxcXCJwYWRkaW5nUmlnaHRcXFwiXSxcXG5cXG5cXG5cXHRcXHQvLyBTZXQgb3B0aW9uc1xcblxcdFxcdG1vZGUgPSAkLmVmZmVjdHMuc2V0TW9kZShlbCwgby5tb2RlIHx8IFxcXCJlZmZlY3RcXFwiKSxcXG5cXHRcXHQgICAgcmVzdG9yZSA9IG8ucmVzdG9yZSB8fCBtb2RlICE9PSBcXFwiZWZmZWN0XFxcIixcXG5cXHRcXHQgICAgc2NhbGUgPSBvLnNjYWxlIHx8IFxcXCJib3RoXFxcIixcXG5cXHRcXHQgICAgb3JpZ2luID0gby5vcmlnaW4gfHwgW1xcXCJtaWRkbGVcXFwiLCBcXFwiY2VudGVyXFxcIl0sXFxuXFx0XFx0ICAgIHBvc2l0aW9uID0gZWwuY3NzKFxcXCJwb3NpdGlvblxcXCIpLFxcblxcdFxcdCAgICBwcm9wcyA9IHJlc3RvcmUgPyBwcm9wczAgOiBwcm9wczEsXFxuXFx0XFx0ICAgIHplcm8gPSB7XFxuXFx0XFx0XFx0aGVpZ2h0OiAwLFxcblxcdFxcdFxcdHdpZHRoOiAwLFxcblxcdFxcdFxcdG91dGVySGVpZ2h0OiAwLFxcblxcdFxcdFxcdG91dGVyV2lkdGg6IDBcXG5cXHRcXHR9O1xcblxcblxcdFxcdGlmIChtb2RlID09PSBcXFwic2hvd1xcXCIpIHtcXG5cXHRcXHRcXHRlbC5zaG93KCk7XFxuXFx0XFx0fVxcblxcdFxcdG9yaWdpbmFsID0ge1xcblxcdFxcdFxcdGhlaWdodDogZWwuaGVpZ2h0KCksXFxuXFx0XFx0XFx0d2lkdGg6IGVsLndpZHRoKCksXFxuXFx0XFx0XFx0b3V0ZXJIZWlnaHQ6IGVsLm91dGVySGVpZ2h0KCksXFxuXFx0XFx0XFx0b3V0ZXJXaWR0aDogZWwub3V0ZXJXaWR0aCgpXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHRpZiAoby5tb2RlID09PSBcXFwidG9nZ2xlXFxcIiAmJiBtb2RlID09PSBcXFwic2hvd1xcXCIpIHtcXG5cXHRcXHRcXHRlbC5mcm9tID0gby50byB8fCB6ZXJvO1xcblxcdFxcdFxcdGVsLnRvID0gby5mcm9tIHx8IG9yaWdpbmFsO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0ZWwuZnJvbSA9IG8uZnJvbSB8fCAobW9kZSA9PT0gXFxcInNob3dcXFwiID8gemVybyA6IG9yaWdpbmFsKTtcXG5cXHRcXHRcXHRlbC50byA9IG8udG8gfHwgKG1vZGUgPT09IFxcXCJoaWRlXFxcIiA/IHplcm8gOiBvcmlnaW5hbCk7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFNldCBzY2FsaW5nIGZhY3RvclxcblxcdFxcdGZhY3RvciA9IHtcXG5cXHRcXHRcXHRmcm9tOiB7XFxuXFx0XFx0XFx0XFx0eTogZWwuZnJvbS5oZWlnaHQgLyBvcmlnaW5hbC5oZWlnaHQsXFxuXFx0XFx0XFx0XFx0eDogZWwuZnJvbS53aWR0aCAvIG9yaWdpbmFsLndpZHRoXFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHR0bzoge1xcblxcdFxcdFxcdFxcdHk6IGVsLnRvLmhlaWdodCAvIG9yaWdpbmFsLmhlaWdodCxcXG5cXHRcXHRcXHRcXHR4OiBlbC50by53aWR0aCAvIG9yaWdpbmFsLndpZHRoXFxuXFx0XFx0XFx0fVxcblxcdFxcdH07XFxuXFxuXFx0XFx0Ly8gU2NhbGUgdGhlIGNzcyBib3hcXG5cXHRcXHRpZiAoc2NhbGUgPT09IFxcXCJib3hcXFwiIHx8IHNjYWxlID09PSBcXFwiYm90aFxcXCIpIHtcXG5cXG5cXHRcXHRcXHQvLyBWZXJ0aWNhbCBwcm9wcyBzY2FsaW5nXFxuXFx0XFx0XFx0aWYgKGZhY3Rvci5mcm9tLnkgIT09IGZhY3Rvci50by55KSB7XFxuXFx0XFx0XFx0XFx0cHJvcHMgPSBwcm9wcy5jb25jYXQodlByb3BzKTtcXG5cXHRcXHRcXHRcXHRlbC5mcm9tID0gJC5lZmZlY3RzLnNldFRyYW5zaXRpb24oZWwsIHZQcm9wcywgZmFjdG9yLmZyb20ueSwgZWwuZnJvbSk7XFxuXFx0XFx0XFx0XFx0ZWwudG8gPSAkLmVmZmVjdHMuc2V0VHJhbnNpdGlvbihlbCwgdlByb3BzLCBmYWN0b3IudG8ueSwgZWwudG8pO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBIb3Jpem9udGFsIHByb3BzIHNjYWxpbmdcXG5cXHRcXHRcXHRpZiAoZmFjdG9yLmZyb20ueCAhPT0gZmFjdG9yLnRvLngpIHtcXG5cXHRcXHRcXHRcXHRwcm9wcyA9IHByb3BzLmNvbmNhdChoUHJvcHMpO1xcblxcdFxcdFxcdFxcdGVsLmZyb20gPSAkLmVmZmVjdHMuc2V0VHJhbnNpdGlvbihlbCwgaFByb3BzLCBmYWN0b3IuZnJvbS54LCBlbC5mcm9tKTtcXG5cXHRcXHRcXHRcXHRlbC50byA9ICQuZWZmZWN0cy5zZXRUcmFuc2l0aW9uKGVsLCBoUHJvcHMsIGZhY3Rvci50by54LCBlbC50byk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBTY2FsZSB0aGUgY29udGVudFxcblxcdFxcdGlmIChzY2FsZSA9PT0gXFxcImNvbnRlbnRcXFwiIHx8IHNjYWxlID09PSBcXFwiYm90aFxcXCIpIHtcXG5cXG5cXHRcXHRcXHQvLyBWZXJ0aWNhbCBwcm9wcyBzY2FsaW5nXFxuXFx0XFx0XFx0aWYgKGZhY3Rvci5mcm9tLnkgIT09IGZhY3Rvci50by55KSB7XFxuXFx0XFx0XFx0XFx0cHJvcHMgPSBwcm9wcy5jb25jYXQoY1Byb3BzKS5jb25jYXQocHJvcHMyKTtcXG5cXHRcXHRcXHRcXHRlbC5mcm9tID0gJC5lZmZlY3RzLnNldFRyYW5zaXRpb24oZWwsIGNQcm9wcywgZmFjdG9yLmZyb20ueSwgZWwuZnJvbSk7XFxuXFx0XFx0XFx0XFx0ZWwudG8gPSAkLmVmZmVjdHMuc2V0VHJhbnNpdGlvbihlbCwgY1Byb3BzLCBmYWN0b3IudG8ueSwgZWwudG8pO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0JC5lZmZlY3RzLnNhdmUoZWwsIHByb3BzKTtcXG5cXHRcXHRlbC5zaG93KCk7XFxuXFx0XFx0JC5lZmZlY3RzLmNyZWF0ZVdyYXBwZXIoZWwpO1xcblxcdFxcdGVsLmNzcyhcXFwib3ZlcmZsb3dcXFwiLCBcXFwiaGlkZGVuXFxcIikuY3NzKGVsLmZyb20pO1xcblxcblxcdFxcdC8vIEFkanVzdFxcblxcdFxcdGlmIChvcmlnaW4pIHtcXG5cXHRcXHRcXHQvLyBDYWxjdWxhdGUgYmFzZWxpbmUgc2hpZnRzXFxuXFx0XFx0XFx0YmFzZWxpbmUgPSAkLmVmZmVjdHMuZ2V0QmFzZWxpbmUob3JpZ2luLCBvcmlnaW5hbCk7XFxuXFx0XFx0XFx0ZWwuZnJvbS50b3AgPSAob3JpZ2luYWwub3V0ZXJIZWlnaHQgLSBlbC5vdXRlckhlaWdodCgpKSAqIGJhc2VsaW5lLnk7XFxuXFx0XFx0XFx0ZWwuZnJvbS5sZWZ0ID0gKG9yaWdpbmFsLm91dGVyV2lkdGggLSBlbC5vdXRlcldpZHRoKCkpICogYmFzZWxpbmUueDtcXG5cXHRcXHRcXHRlbC50by50b3AgPSAob3JpZ2luYWwub3V0ZXJIZWlnaHQgLSBlbC50by5vdXRlckhlaWdodCkgKiBiYXNlbGluZS55O1xcblxcdFxcdFxcdGVsLnRvLmxlZnQgPSAob3JpZ2luYWwub3V0ZXJXaWR0aCAtIGVsLnRvLm91dGVyV2lkdGgpICogYmFzZWxpbmUueDtcXG5cXHRcXHR9XFxuXFx0XFx0ZWwuY3NzKGVsLmZyb20pOyAvLyBzZXQgdG9wICYgbGVmdFxcblxcblxcdFxcdC8vIEFuaW1hdGVcXG5cXHRcXHRpZiAoc2NhbGUgPT09IFxcXCJjb250ZW50XFxcIiB8fCBzY2FsZSA9PT0gXFxcImJvdGhcXFwiKSB7XFxuXFx0XFx0XFx0Ly8gU2NhbGUgdGhlIGNoaWxkcmVuXFxuXFxuXFx0XFx0XFx0Ly8gQWRkIG1hcmdpbnMvZm9udC1zaXplXFxuXFx0XFx0XFx0dlByb3BzID0gdlByb3BzLmNvbmNhdChbXFxcIm1hcmdpblRvcFxcXCIsIFxcXCJtYXJnaW5Cb3R0b21cXFwiXSkuY29uY2F0KGNQcm9wcyk7XFxuXFx0XFx0XFx0aFByb3BzID0gaFByb3BzLmNvbmNhdChbXFxcIm1hcmdpbkxlZnRcXFwiLCBcXFwibWFyZ2luUmlnaHRcXFwiXSk7XFxuXFx0XFx0XFx0cHJvcHMyID0gcHJvcHMwLmNvbmNhdCh2UHJvcHMpLmNvbmNhdChoUHJvcHMpO1xcblxcblxcdFxcdFxcdGVsLmZpbmQoXFxcIipbd2lkdGhdXFxcIikuZWFjaChmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0dmFyIGNoaWxkID0gJCh0aGlzKSxcXG5cXHRcXHRcXHRcXHQgICAgY19vcmlnaW5hbCA9IHtcXG5cXHRcXHRcXHRcXHRcXHRoZWlnaHQ6IGNoaWxkLmhlaWdodCgpLFxcblxcdFxcdFxcdFxcdFxcdHdpZHRoOiBjaGlsZC53aWR0aCgpLFxcblxcdFxcdFxcdFxcdFxcdG91dGVySGVpZ2h0OiBjaGlsZC5vdXRlckhlaWdodCgpLFxcblxcdFxcdFxcdFxcdFxcdG91dGVyV2lkdGg6IGNoaWxkLm91dGVyV2lkdGgoKVxcblxcdFxcdFxcdFxcdH07XFxuXFx0XFx0XFx0XFx0aWYgKHJlc3RvcmUpIHtcXG5cXHRcXHRcXHRcXHRcXHQkLmVmZmVjdHMuc2F2ZShjaGlsZCwgcHJvcHMyKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Y2hpbGQuZnJvbSA9IHtcXG5cXHRcXHRcXHRcXHRcXHRoZWlnaHQ6IGNfb3JpZ2luYWwuaGVpZ2h0ICogZmFjdG9yLmZyb20ueSxcXG5cXHRcXHRcXHRcXHRcXHR3aWR0aDogY19vcmlnaW5hbC53aWR0aCAqIGZhY3Rvci5mcm9tLngsXFxuXFx0XFx0XFx0XFx0XFx0b3V0ZXJIZWlnaHQ6IGNfb3JpZ2luYWwub3V0ZXJIZWlnaHQgKiBmYWN0b3IuZnJvbS55LFxcblxcdFxcdFxcdFxcdFxcdG91dGVyV2lkdGg6IGNfb3JpZ2luYWwub3V0ZXJXaWR0aCAqIGZhY3Rvci5mcm9tLnhcXG5cXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdFxcdGNoaWxkLnRvID0ge1xcblxcdFxcdFxcdFxcdFxcdGhlaWdodDogY19vcmlnaW5hbC5oZWlnaHQgKiBmYWN0b3IudG8ueSxcXG5cXHRcXHRcXHRcXHRcXHR3aWR0aDogY19vcmlnaW5hbC53aWR0aCAqIGZhY3Rvci50by54LFxcblxcdFxcdFxcdFxcdFxcdG91dGVySGVpZ2h0OiBjX29yaWdpbmFsLmhlaWdodCAqIGZhY3Rvci50by55LFxcblxcdFxcdFxcdFxcdFxcdG91dGVyV2lkdGg6IGNfb3JpZ2luYWwud2lkdGggKiBmYWN0b3IudG8ueFxcblxcdFxcdFxcdFxcdH07XFxuXFxuXFx0XFx0XFx0XFx0Ly8gVmVydGljYWwgcHJvcHMgc2NhbGluZ1xcblxcdFxcdFxcdFxcdGlmIChmYWN0b3IuZnJvbS55ICE9PSBmYWN0b3IudG8ueSkge1xcblxcdFxcdFxcdFxcdFxcdGNoaWxkLmZyb20gPSAkLmVmZmVjdHMuc2V0VHJhbnNpdGlvbihjaGlsZCwgdlByb3BzLCBmYWN0b3IuZnJvbS55LCBjaGlsZC5mcm9tKTtcXG5cXHRcXHRcXHRcXHRcXHRjaGlsZC50byA9ICQuZWZmZWN0cy5zZXRUcmFuc2l0aW9uKGNoaWxkLCB2UHJvcHMsIGZhY3Rvci50by55LCBjaGlsZC50byk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIEhvcml6b250YWwgcHJvcHMgc2NhbGluZ1xcblxcdFxcdFxcdFxcdGlmIChmYWN0b3IuZnJvbS54ICE9PSBmYWN0b3IudG8ueCkge1xcblxcdFxcdFxcdFxcdFxcdGNoaWxkLmZyb20gPSAkLmVmZmVjdHMuc2V0VHJhbnNpdGlvbihjaGlsZCwgaFByb3BzLCBmYWN0b3IuZnJvbS54LCBjaGlsZC5mcm9tKTtcXG5cXHRcXHRcXHRcXHRcXHRjaGlsZC50byA9ICQuZWZmZWN0cy5zZXRUcmFuc2l0aW9uKGNoaWxkLCBoUHJvcHMsIGZhY3Rvci50by54LCBjaGlsZC50byk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIEFuaW1hdGUgY2hpbGRyZW5cXG5cXHRcXHRcXHRcXHRjaGlsZC5jc3MoY2hpbGQuZnJvbSk7XFxuXFx0XFx0XFx0XFx0Y2hpbGQuYW5pbWF0ZShjaGlsZC50bywgby5kdXJhdGlvbiwgby5lYXNpbmcsIGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBSZXN0b3JlIGNoaWxkcmVuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKHJlc3RvcmUpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHQkLmVmZmVjdHMucmVzdG9yZShjaGlsZCwgcHJvcHMyKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIEFuaW1hdGVcXG5cXHRcXHRlbC5hbmltYXRlKGVsLnRvLCB7XFxuXFx0XFx0XFx0cXVldWU6IGZhbHNlLFxcblxcdFxcdFxcdGR1cmF0aW9uOiBvLmR1cmF0aW9uLFxcblxcdFxcdFxcdGVhc2luZzogby5lYXNpbmcsXFxuXFx0XFx0XFx0Y29tcGxldGU6IGZ1bmN0aW9uIGNvbXBsZXRlKCkge1xcblxcdFxcdFxcdFxcdGlmIChlbC50by5vcGFjaXR5ID09PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZWwuY3NzKFxcXCJvcGFjaXR5XFxcIiwgZWwuZnJvbS5vcGFjaXR5KTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aWYgKG1vZGUgPT09IFxcXCJoaWRlXFxcIikge1xcblxcdFxcdFxcdFxcdFxcdGVsLmhpZGUoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0JC5lZmZlY3RzLnJlc3RvcmUoZWwsIHByb3BzKTtcXG5cXHRcXHRcXHRcXHRpZiAoIXJlc3RvcmUpIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyB3ZSBuZWVkIHRvIGNhbGN1bGF0ZSBvdXIgbmV3IHBvc2l0aW9uaW5nIGJhc2VkIG9uIHRoZSBzY2FsaW5nXFxuXFx0XFx0XFx0XFx0XFx0aWYgKHBvc2l0aW9uID09PSBcXFwic3RhdGljXFxcIikge1xcblxcdFxcdFxcdFxcdFxcdFxcdGVsLmNzcyh7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cG9zaXRpb246IFxcXCJyZWxhdGl2ZVxcXCIsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dG9wOiBlbC50by50b3AsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bGVmdDogZWwudG8ubGVmdFxcblxcdFxcdFxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0JC5lYWNoKFtcXFwidG9wXFxcIiwgXFxcImxlZnRcXFwiXSwgZnVuY3Rpb24gKGlkeCwgcG9zKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZWwuY3NzKHBvcywgZnVuY3Rpb24gKF8sIHN0cikge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciB2YWwgPSBwYXJzZUludChzdHIsIDEwKSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQgICAgdG9SZWYgPSBpZHggPyBlbC50by5sZWZ0IDogZWwudG8udG9wO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIGlmIG9yaWdpbmFsIHdhcyBcXFwiYXV0b1xcXCIsIHJlY2FsY3VsYXRlIHRoZSBuZXcgdmFsdWUgZnJvbSB3cmFwcGVyXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKHN0ciA9PT0gXFxcImF1dG9cXFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRvUmVmICsgXFxcInB4XFxcIjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHZhbCArIHRvUmVmICsgXFxcInB4XFxcIjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdCQuZWZmZWN0cy5yZW1vdmVXcmFwcGVyKGVsKTtcXG5cXHRcXHRcXHRcXHRkb25lKCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0pO1xcblxcdH07XFxuXFxuXFx0LyohXFxuICAqIGpRdWVyeSBVSSBFZmZlY3RzIFNjYWxlIDEuMTEuNFxcbiAgKiBodHRwOi8vanF1ZXJ5dWkuY29tXFxuICAqXFxuICAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXFxuICAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cXG4gICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxcbiAgKlxcbiAgKiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9zY2FsZS1lZmZlY3QvXFxuICAqL1xcblxcblxcdHZhciBlZmZlY3RTY2FsZSA9ICQuZWZmZWN0cy5lZmZlY3Quc2NhbGUgPSBmdW5jdGlvbiAobywgZG9uZSkge1xcblxcblxcdFxcdC8vIENyZWF0ZSBlbGVtZW50XFxuXFx0XFx0dmFyIGVsID0gJCh0aGlzKSxcXG5cXHRcXHQgICAgb3B0aW9ucyA9ICQuZXh0ZW5kKHRydWUsIHt9LCBvKSxcXG5cXHRcXHQgICAgbW9kZSA9ICQuZWZmZWN0cy5zZXRNb2RlKGVsLCBvLm1vZGUgfHwgXFxcImVmZmVjdFxcXCIpLFxcblxcdFxcdCAgICBwZXJjZW50ID0gcGFyc2VJbnQoby5wZXJjZW50LCAxMCkgfHwgKHBhcnNlSW50KG8ucGVyY2VudCwgMTApID09PSAwID8gMCA6IG1vZGUgPT09IFxcXCJoaWRlXFxcIiA/IDAgOiAxMDApLFxcblxcdFxcdCAgICBkaXJlY3Rpb24gPSBvLmRpcmVjdGlvbiB8fCBcXFwiYm90aFxcXCIsXFxuXFx0XFx0ICAgIG9yaWdpbiA9IG8ub3JpZ2luLFxcblxcdFxcdCAgICBvcmlnaW5hbCA9IHtcXG5cXHRcXHRcXHRoZWlnaHQ6IGVsLmhlaWdodCgpLFxcblxcdFxcdFxcdHdpZHRoOiBlbC53aWR0aCgpLFxcblxcdFxcdFxcdG91dGVySGVpZ2h0OiBlbC5vdXRlckhlaWdodCgpLFxcblxcdFxcdFxcdG91dGVyV2lkdGg6IGVsLm91dGVyV2lkdGgoKVxcblxcdFxcdH0sXFxuXFx0XFx0ICAgIGZhY3RvciA9IHtcXG5cXHRcXHRcXHR5OiBkaXJlY3Rpb24gIT09IFxcXCJob3Jpem9udGFsXFxcIiA/IHBlcmNlbnQgLyAxMDAgOiAxLFxcblxcdFxcdFxcdHg6IGRpcmVjdGlvbiAhPT0gXFxcInZlcnRpY2FsXFxcIiA/IHBlcmNlbnQgLyAxMDAgOiAxXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHQvLyBXZSBhcmUgZ29pbmcgdG8gcGFzcyB0aGlzIGVmZmVjdCB0byB0aGUgc2l6ZSBlZmZlY3Q6XFxuXFx0XFx0b3B0aW9ucy5lZmZlY3QgPSBcXFwic2l6ZVxcXCI7XFxuXFx0XFx0b3B0aW9ucy5xdWV1ZSA9IGZhbHNlO1xcblxcdFxcdG9wdGlvbnMuY29tcGxldGUgPSBkb25lO1xcblxcblxcdFxcdC8vIFNldCBkZWZhdWx0IG9yaWdpbiBhbmQgcmVzdG9yZSBmb3Igc2hvdy9oaWRlXFxuXFx0XFx0aWYgKG1vZGUgIT09IFxcXCJlZmZlY3RcXFwiKSB7XFxuXFx0XFx0XFx0b3B0aW9ucy5vcmlnaW4gPSBvcmlnaW4gfHwgW1xcXCJtaWRkbGVcXFwiLCBcXFwiY2VudGVyXFxcIl07XFxuXFx0XFx0XFx0b3B0aW9ucy5yZXN0b3JlID0gdHJ1ZTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0b3B0aW9ucy5mcm9tID0gby5mcm9tIHx8IChtb2RlID09PSBcXFwic2hvd1xcXCIgPyB7XFxuXFx0XFx0XFx0aGVpZ2h0OiAwLFxcblxcdFxcdFxcdHdpZHRoOiAwLFxcblxcdFxcdFxcdG91dGVySGVpZ2h0OiAwLFxcblxcdFxcdFxcdG91dGVyV2lkdGg6IDBcXG5cXHRcXHR9IDogb3JpZ2luYWwpO1xcblxcdFxcdG9wdGlvbnMudG8gPSB7XFxuXFx0XFx0XFx0aGVpZ2h0OiBvcmlnaW5hbC5oZWlnaHQgKiBmYWN0b3IueSxcXG5cXHRcXHRcXHR3aWR0aDogb3JpZ2luYWwud2lkdGggKiBmYWN0b3IueCxcXG5cXHRcXHRcXHRvdXRlckhlaWdodDogb3JpZ2luYWwub3V0ZXJIZWlnaHQgKiBmYWN0b3IueSxcXG5cXHRcXHRcXHRvdXRlcldpZHRoOiBvcmlnaW5hbC5vdXRlcldpZHRoICogZmFjdG9yLnhcXG5cXHRcXHR9O1xcblxcblxcdFxcdC8vIEZhZGUgb3B0aW9uIHRvIHN1cHBvcnQgcHVmZlxcblxcdFxcdGlmIChvcHRpb25zLmZhZGUpIHtcXG5cXHRcXHRcXHRpZiAobW9kZSA9PT0gXFxcInNob3dcXFwiKSB7XFxuXFx0XFx0XFx0XFx0b3B0aW9ucy5mcm9tLm9wYWNpdHkgPSAwO1xcblxcdFxcdFxcdFxcdG9wdGlvbnMudG8ub3BhY2l0eSA9IDE7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmIChtb2RlID09PSBcXFwiaGlkZVxcXCIpIHtcXG5cXHRcXHRcXHRcXHRvcHRpb25zLmZyb20ub3BhY2l0eSA9IDE7XFxuXFx0XFx0XFx0XFx0b3B0aW9ucy50by5vcGFjaXR5ID0gMDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIEFuaW1hdGVcXG5cXHRcXHRlbC5lZmZlY3Qob3B0aW9ucyk7XFxuXFx0fTtcXG5cXG5cXHQvKiFcXG4gICogalF1ZXJ5IFVJIEVmZmVjdHMgUHVmZiAxLjExLjRcXG4gICogaHR0cDovL2pxdWVyeXVpLmNvbVxcbiAgKlxcbiAgKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xcbiAgKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXFxuICAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcXG4gICpcXG4gICogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20vcHVmZi1lZmZlY3QvXFxuICAqL1xcblxcblxcdHZhciBlZmZlY3RQdWZmID0gJC5lZmZlY3RzLmVmZmVjdC5wdWZmID0gZnVuY3Rpb24gKG8sIGRvbmUpIHtcXG5cXHRcXHR2YXIgZWxlbSA9ICQodGhpcyksXFxuXFx0XFx0ICAgIG1vZGUgPSAkLmVmZmVjdHMuc2V0TW9kZShlbGVtLCBvLm1vZGUgfHwgXFxcImhpZGVcXFwiKSxcXG5cXHRcXHQgICAgaGlkZSA9IG1vZGUgPT09IFxcXCJoaWRlXFxcIixcXG5cXHRcXHQgICAgcGVyY2VudCA9IHBhcnNlSW50KG8ucGVyY2VudCwgMTApIHx8IDE1MCxcXG5cXHRcXHQgICAgZmFjdG9yID0gcGVyY2VudCAvIDEwMCxcXG5cXHRcXHQgICAgb3JpZ2luYWwgPSB7XFxuXFx0XFx0XFx0aGVpZ2h0OiBlbGVtLmhlaWdodCgpLFxcblxcdFxcdFxcdHdpZHRoOiBlbGVtLndpZHRoKCksXFxuXFx0XFx0XFx0b3V0ZXJIZWlnaHQ6IGVsZW0ub3V0ZXJIZWlnaHQoKSxcXG5cXHRcXHRcXHRvdXRlcldpZHRoOiBlbGVtLm91dGVyV2lkdGgoKVxcblxcdFxcdH07XFxuXFxuXFx0XFx0JC5leHRlbmQobywge1xcblxcdFxcdFxcdGVmZmVjdDogXFxcInNjYWxlXFxcIixcXG5cXHRcXHRcXHRxdWV1ZTogZmFsc2UsXFxuXFx0XFx0XFx0ZmFkZTogdHJ1ZSxcXG5cXHRcXHRcXHRtb2RlOiBtb2RlLFxcblxcdFxcdFxcdGNvbXBsZXRlOiBkb25lLFxcblxcdFxcdFxcdHBlcmNlbnQ6IGhpZGUgPyBwZXJjZW50IDogMTAwLFxcblxcdFxcdFxcdGZyb206IGhpZGUgPyBvcmlnaW5hbCA6IHtcXG5cXHRcXHRcXHRcXHRoZWlnaHQ6IG9yaWdpbmFsLmhlaWdodCAqIGZhY3RvcixcXG5cXHRcXHRcXHRcXHR3aWR0aDogb3JpZ2luYWwud2lkdGggKiBmYWN0b3IsXFxuXFx0XFx0XFx0XFx0b3V0ZXJIZWlnaHQ6IG9yaWdpbmFsLm91dGVySGVpZ2h0ICogZmFjdG9yLFxcblxcdFxcdFxcdFxcdG91dGVyV2lkdGg6IG9yaWdpbmFsLm91dGVyV2lkdGggKiBmYWN0b3JcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSk7XFxuXFxuXFx0XFx0ZWxlbS5lZmZlY3Qobyk7XFxuXFx0fTtcXG5cXG5cXHQvKiFcXG4gICogalF1ZXJ5IFVJIEVmZmVjdHMgUHVsc2F0ZSAxLjExLjRcXG4gICogaHR0cDovL2pxdWVyeXVpLmNvbVxcbiAgKlxcbiAgKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xcbiAgKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXFxuICAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcXG4gICpcXG4gICogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20vcHVsc2F0ZS1lZmZlY3QvXFxuICAqL1xcblxcblxcdHZhciBlZmZlY3RQdWxzYXRlID0gJC5lZmZlY3RzLmVmZmVjdC5wdWxzYXRlID0gZnVuY3Rpb24gKG8sIGRvbmUpIHtcXG5cXHRcXHR2YXIgZWxlbSA9ICQodGhpcyksXFxuXFx0XFx0ICAgIG1vZGUgPSAkLmVmZmVjdHMuc2V0TW9kZShlbGVtLCBvLm1vZGUgfHwgXFxcInNob3dcXFwiKSxcXG5cXHRcXHQgICAgc2hvdyA9IG1vZGUgPT09IFxcXCJzaG93XFxcIixcXG5cXHRcXHQgICAgaGlkZSA9IG1vZGUgPT09IFxcXCJoaWRlXFxcIixcXG5cXHRcXHQgICAgc2hvd2hpZGUgPSBzaG93IHx8IG1vZGUgPT09IFxcXCJoaWRlXFxcIixcXG5cXG5cXG5cXHRcXHQvLyBzaG93aW5nIG9yIGhpZGluZyBsZWF2ZXMgb2YgdGhlIFxcXCJsYXN0XFxcIiBhbmltYXRpb25cXG5cXHRcXHRhbmltcyA9IChvLnRpbWVzIHx8IDUpICogMiArIChzaG93aGlkZSA/IDEgOiAwKSxcXG5cXHRcXHQgICAgZHVyYXRpb24gPSBvLmR1cmF0aW9uIC8gYW5pbXMsXFxuXFx0XFx0ICAgIGFuaW1hdGVUbyA9IDAsXFxuXFx0XFx0ICAgIHF1ZXVlID0gZWxlbS5xdWV1ZSgpLFxcblxcdFxcdCAgICBxdWV1ZWxlbiA9IHF1ZXVlLmxlbmd0aCxcXG5cXHRcXHQgICAgaTtcXG5cXG5cXHRcXHRpZiAoc2hvdyB8fCAhZWxlbS5pcyhcXFwiOnZpc2libGVcXFwiKSkge1xcblxcdFxcdFxcdGVsZW0uY3NzKFxcXCJvcGFjaXR5XFxcIiwgMCkuc2hvdygpO1xcblxcdFxcdFxcdGFuaW1hdGVUbyA9IDE7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIGFuaW1zIC0gMSBvcGFjaXR5IFxcXCJ0b2dnbGVzXFxcIlxcblxcdFxcdGZvciAoaSA9IDE7IGkgPCBhbmltczsgaSsrKSB7XFxuXFx0XFx0XFx0ZWxlbS5hbmltYXRlKHtcXG5cXHRcXHRcXHRcXHRvcGFjaXR5OiBhbmltYXRlVG9cXG5cXHRcXHRcXHR9LCBkdXJhdGlvbiwgby5lYXNpbmcpO1xcblxcdFxcdFxcdGFuaW1hdGVUbyA9IDEgLSBhbmltYXRlVG87XFxuXFx0XFx0fVxcblxcblxcdFxcdGVsZW0uYW5pbWF0ZSh7XFxuXFx0XFx0XFx0b3BhY2l0eTogYW5pbWF0ZVRvXFxuXFx0XFx0fSwgZHVyYXRpb24sIG8uZWFzaW5nKTtcXG5cXG5cXHRcXHRlbGVtLnF1ZXVlKGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRpZiAoaGlkZSkge1xcblxcdFxcdFxcdFxcdGVsZW0uaGlkZSgpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRkb25lKCk7XFxuXFx0XFx0fSk7XFxuXFxuXFx0XFx0Ly8gV2UganVzdCBxdWV1ZWQgdXAgXFxcImFuaW1zXFxcIiBhbmltYXRpb25zLCB3ZSBuZWVkIHRvIHB1dCB0aGVtIG5leHQgaW4gdGhlIHF1ZXVlXFxuXFx0XFx0aWYgKHF1ZXVlbGVuID4gMSkge1xcblxcdFxcdFxcdHF1ZXVlLnNwbGljZS5hcHBseShxdWV1ZSwgWzEsIDBdLmNvbmNhdChxdWV1ZS5zcGxpY2UocXVldWVsZW4sIGFuaW1zICsgMSkpKTtcXG5cXHRcXHR9XFxuXFx0XFx0ZWxlbS5kZXF1ZXVlKCk7XFxuXFx0fTtcXG5cXG5cXHQvKiFcXG4gICogalF1ZXJ5IFVJIEVmZmVjdHMgU2hha2UgMS4xMS40XFxuICAqIGh0dHA6Ly9qcXVlcnl1aS5jb21cXG4gICpcXG4gICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcXG4gICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxcbiAgKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXFxuICAqXFxuICAqIGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL3NoYWtlLWVmZmVjdC9cXG4gICovXFxuXFxuXFx0dmFyIGVmZmVjdFNoYWtlID0gJC5lZmZlY3RzLmVmZmVjdC5zaGFrZSA9IGZ1bmN0aW9uIChvLCBkb25lKSB7XFxuXFxuXFx0XFx0dmFyIGVsID0gJCh0aGlzKSxcXG5cXHRcXHQgICAgcHJvcHMgPSBbXFxcInBvc2l0aW9uXFxcIiwgXFxcInRvcFxcXCIsIFxcXCJib3R0b21cXFwiLCBcXFwibGVmdFxcXCIsIFxcXCJyaWdodFxcXCIsIFxcXCJoZWlnaHRcXFwiLCBcXFwid2lkdGhcXFwiXSxcXG5cXHRcXHQgICAgbW9kZSA9ICQuZWZmZWN0cy5zZXRNb2RlKGVsLCBvLm1vZGUgfHwgXFxcImVmZmVjdFxcXCIpLFxcblxcdFxcdCAgICBkaXJlY3Rpb24gPSBvLmRpcmVjdGlvbiB8fCBcXFwibGVmdFxcXCIsXFxuXFx0XFx0ICAgIGRpc3RhbmNlID0gby5kaXN0YW5jZSB8fCAyMCxcXG5cXHRcXHQgICAgdGltZXMgPSBvLnRpbWVzIHx8IDMsXFxuXFx0XFx0ICAgIGFuaW1zID0gdGltZXMgKiAyICsgMSxcXG5cXHRcXHQgICAgc3BlZWQgPSBNYXRoLnJvdW5kKG8uZHVyYXRpb24gLyBhbmltcyksXFxuXFx0XFx0ICAgIHJlZiA9IGRpcmVjdGlvbiA9PT0gXFxcInVwXFxcIiB8fCBkaXJlY3Rpb24gPT09IFxcXCJkb3duXFxcIiA/IFxcXCJ0b3BcXFwiIDogXFxcImxlZnRcXFwiLFxcblxcdFxcdCAgICBwb3NpdGl2ZU1vdGlvbiA9IGRpcmVjdGlvbiA9PT0gXFxcInVwXFxcIiB8fCBkaXJlY3Rpb24gPT09IFxcXCJsZWZ0XFxcIixcXG5cXHRcXHQgICAgYW5pbWF0aW9uID0ge30sXFxuXFx0XFx0ICAgIGFuaW1hdGlvbjEgPSB7fSxcXG5cXHRcXHQgICAgYW5pbWF0aW9uMiA9IHt9LFxcblxcdFxcdCAgICBpLFxcblxcblxcblxcdFxcdC8vIHdlIHdpbGwgbmVlZCB0byByZS1hc3NlbWJsZSB0aGUgcXVldWUgdG8gc3RhY2sgb3VyIGFuaW1hdGlvbnMgaW4gcGxhY2VcXG5cXHRcXHRxdWV1ZSA9IGVsLnF1ZXVlKCksXFxuXFx0XFx0ICAgIHF1ZXVlbGVuID0gcXVldWUubGVuZ3RoO1xcblxcblxcdFxcdCQuZWZmZWN0cy5zYXZlKGVsLCBwcm9wcyk7XFxuXFx0XFx0ZWwuc2hvdygpO1xcblxcdFxcdCQuZWZmZWN0cy5jcmVhdGVXcmFwcGVyKGVsKTtcXG5cXG5cXHRcXHQvLyBBbmltYXRpb25cXG5cXHRcXHRhbmltYXRpb25bcmVmXSA9IChwb3NpdGl2ZU1vdGlvbiA/IFxcXCItPVxcXCIgOiBcXFwiKz1cXFwiKSArIGRpc3RhbmNlO1xcblxcdFxcdGFuaW1hdGlvbjFbcmVmXSA9IChwb3NpdGl2ZU1vdGlvbiA/IFxcXCIrPVxcXCIgOiBcXFwiLT1cXFwiKSArIGRpc3RhbmNlICogMjtcXG5cXHRcXHRhbmltYXRpb24yW3JlZl0gPSAocG9zaXRpdmVNb3Rpb24gPyBcXFwiLT1cXFwiIDogXFxcIis9XFxcIikgKyBkaXN0YW5jZSAqIDI7XFxuXFxuXFx0XFx0Ly8gQW5pbWF0ZVxcblxcdFxcdGVsLmFuaW1hdGUoYW5pbWF0aW9uLCBzcGVlZCwgby5lYXNpbmcpO1xcblxcblxcdFxcdC8vIFNoYWtlc1xcblxcdFxcdGZvciAoaSA9IDE7IGkgPCB0aW1lczsgaSsrKSB7XFxuXFx0XFx0XFx0ZWwuYW5pbWF0ZShhbmltYXRpb24xLCBzcGVlZCwgby5lYXNpbmcpLmFuaW1hdGUoYW5pbWF0aW9uMiwgc3BlZWQsIG8uZWFzaW5nKTtcXG5cXHRcXHR9XFxuXFx0XFx0ZWwuYW5pbWF0ZShhbmltYXRpb24xLCBzcGVlZCwgby5lYXNpbmcpLmFuaW1hdGUoYW5pbWF0aW9uLCBzcGVlZCAvIDIsIG8uZWFzaW5nKS5xdWV1ZShmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0aWYgKG1vZGUgPT09IFxcXCJoaWRlXFxcIikge1xcblxcdFxcdFxcdFxcdGVsLmhpZGUoKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0JC5lZmZlY3RzLnJlc3RvcmUoZWwsIHByb3BzKTtcXG5cXHRcXHRcXHQkLmVmZmVjdHMucmVtb3ZlV3JhcHBlcihlbCk7XFxuXFx0XFx0XFx0ZG9uZSgpO1xcblxcdFxcdH0pO1xcblxcblxcdFxcdC8vIGluamVjdCBhbGwgdGhlIGFuaW1hdGlvbnMgd2UganVzdCBxdWV1ZWQgdG8gYmUgZmlyc3QgaW4gbGluZSAoYWZ0ZXIgXFxcImlucHJvZ3Jlc3NcXFwiKVxcblxcdFxcdGlmIChxdWV1ZWxlbiA+IDEpIHtcXG5cXHRcXHRcXHRxdWV1ZS5zcGxpY2UuYXBwbHkocXVldWUsIFsxLCAwXS5jb25jYXQocXVldWUuc3BsaWNlKHF1ZXVlbGVuLCBhbmltcyArIDEpKSk7XFxuXFx0XFx0fVxcblxcdFxcdGVsLmRlcXVldWUoKTtcXG5cXHR9O1xcblxcblxcdC8qIVxcbiAgKiBqUXVlcnkgVUkgRWZmZWN0cyBTbGlkZSAxLjExLjRcXG4gICogaHR0cDovL2pxdWVyeXVpLmNvbVxcbiAgKlxcbiAgKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xcbiAgKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXFxuICAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcXG4gICpcXG4gICogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20vc2xpZGUtZWZmZWN0L1xcbiAgKi9cXG5cXG5cXHR2YXIgZWZmZWN0U2xpZGUgPSAkLmVmZmVjdHMuZWZmZWN0LnNsaWRlID0gZnVuY3Rpb24gKG8sIGRvbmUpIHtcXG5cXG5cXHRcXHQvLyBDcmVhdGUgZWxlbWVudFxcblxcdFxcdHZhciBlbCA9ICQodGhpcyksXFxuXFx0XFx0ICAgIHByb3BzID0gW1xcXCJwb3NpdGlvblxcXCIsIFxcXCJ0b3BcXFwiLCBcXFwiYm90dG9tXFxcIiwgXFxcImxlZnRcXFwiLCBcXFwicmlnaHRcXFwiLCBcXFwid2lkdGhcXFwiLCBcXFwiaGVpZ2h0XFxcIl0sXFxuXFx0XFx0ICAgIG1vZGUgPSAkLmVmZmVjdHMuc2V0TW9kZShlbCwgby5tb2RlIHx8IFxcXCJzaG93XFxcIiksXFxuXFx0XFx0ICAgIHNob3cgPSBtb2RlID09PSBcXFwic2hvd1xcXCIsXFxuXFx0XFx0ICAgIGRpcmVjdGlvbiA9IG8uZGlyZWN0aW9uIHx8IFxcXCJsZWZ0XFxcIixcXG5cXHRcXHQgICAgcmVmID0gZGlyZWN0aW9uID09PSBcXFwidXBcXFwiIHx8IGRpcmVjdGlvbiA9PT0gXFxcImRvd25cXFwiID8gXFxcInRvcFxcXCIgOiBcXFwibGVmdFxcXCIsXFxuXFx0XFx0ICAgIHBvc2l0aXZlTW90aW9uID0gZGlyZWN0aW9uID09PSBcXFwidXBcXFwiIHx8IGRpcmVjdGlvbiA9PT0gXFxcImxlZnRcXFwiLFxcblxcdFxcdCAgICBkaXN0YW5jZSxcXG5cXHRcXHQgICAgYW5pbWF0aW9uID0ge307XFxuXFxuXFx0XFx0Ly8gQWRqdXN0XFxuXFx0XFx0JC5lZmZlY3RzLnNhdmUoZWwsIHByb3BzKTtcXG5cXHRcXHRlbC5zaG93KCk7XFxuXFx0XFx0ZGlzdGFuY2UgPSBvLmRpc3RhbmNlIHx8IGVsW3JlZiA9PT0gXFxcInRvcFxcXCIgPyBcXFwib3V0ZXJIZWlnaHRcXFwiIDogXFxcIm91dGVyV2lkdGhcXFwiXSh0cnVlKTtcXG5cXG5cXHRcXHQkLmVmZmVjdHMuY3JlYXRlV3JhcHBlcihlbCkuY3NzKHtcXG5cXHRcXHRcXHRvdmVyZmxvdzogXFxcImhpZGRlblxcXCJcXG5cXHRcXHR9KTtcXG5cXG5cXHRcXHRpZiAoc2hvdykge1xcblxcdFxcdFxcdGVsLmNzcyhyZWYsIHBvc2l0aXZlTW90aW9uID8gaXNOYU4oZGlzdGFuY2UpID8gXFxcIi1cXFwiICsgZGlzdGFuY2UgOiAtZGlzdGFuY2UgOiBkaXN0YW5jZSk7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIEFuaW1hdGlvblxcblxcdFxcdGFuaW1hdGlvbltyZWZdID0gKHNob3cgPyBwb3NpdGl2ZU1vdGlvbiA/IFxcXCIrPVxcXCIgOiBcXFwiLT1cXFwiIDogcG9zaXRpdmVNb3Rpb24gPyBcXFwiLT1cXFwiIDogXFxcIis9XFxcIikgKyBkaXN0YW5jZTtcXG5cXG5cXHRcXHQvLyBBbmltYXRlXFxuXFx0XFx0ZWwuYW5pbWF0ZShhbmltYXRpb24sIHtcXG5cXHRcXHRcXHRxdWV1ZTogZmFsc2UsXFxuXFx0XFx0XFx0ZHVyYXRpb246IG8uZHVyYXRpb24sXFxuXFx0XFx0XFx0ZWFzaW5nOiBvLmVhc2luZyxcXG5cXHRcXHRcXHRjb21wbGV0ZTogZnVuY3Rpb24gY29tcGxldGUoKSB7XFxuXFx0XFx0XFx0XFx0aWYgKG1vZGUgPT09IFxcXCJoaWRlXFxcIikge1xcblxcdFxcdFxcdFxcdFxcdGVsLmhpZGUoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0JC5lZmZlY3RzLnJlc3RvcmUoZWwsIHByb3BzKTtcXG5cXHRcXHRcXHRcXHQkLmVmZmVjdHMucmVtb3ZlV3JhcHBlcihlbCk7XFxuXFx0XFx0XFx0XFx0ZG9uZSgpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9KTtcXG5cXHR9O1xcblxcblxcdC8qIVxcbiAgKiBqUXVlcnkgVUkgRWZmZWN0cyBUcmFuc2ZlciAxLjExLjRcXG4gICogaHR0cDovL2pxdWVyeXVpLmNvbVxcbiAgKlxcbiAgKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xcbiAgKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXFxuICAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcXG4gICpcXG4gICogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20vdHJhbnNmZXItZWZmZWN0L1xcbiAgKi9cXG5cXG5cXHR2YXIgZWZmZWN0VHJhbnNmZXIgPSAkLmVmZmVjdHMuZWZmZWN0LnRyYW5zZmVyID0gZnVuY3Rpb24gKG8sIGRvbmUpIHtcXG5cXHRcXHR2YXIgZWxlbSA9ICQodGhpcyksXFxuXFx0XFx0ICAgIHRhcmdldCA9ICQoby50byksXFxuXFx0XFx0ICAgIHRhcmdldEZpeGVkID0gdGFyZ2V0LmNzcyhcXFwicG9zaXRpb25cXFwiKSA9PT0gXFxcImZpeGVkXFxcIixcXG5cXHRcXHQgICAgYm9keSA9ICQoXFxcImJvZHlcXFwiKSxcXG5cXHRcXHQgICAgZml4VG9wID0gdGFyZ2V0Rml4ZWQgPyBib2R5LnNjcm9sbFRvcCgpIDogMCxcXG5cXHRcXHQgICAgZml4TGVmdCA9IHRhcmdldEZpeGVkID8gYm9keS5zY3JvbGxMZWZ0KCkgOiAwLFxcblxcdFxcdCAgICBlbmRQb3NpdGlvbiA9IHRhcmdldC5vZmZzZXQoKSxcXG5cXHRcXHQgICAgYW5pbWF0aW9uID0ge1xcblxcdFxcdFxcdHRvcDogZW5kUG9zaXRpb24udG9wIC0gZml4VG9wLFxcblxcdFxcdFxcdGxlZnQ6IGVuZFBvc2l0aW9uLmxlZnQgLSBmaXhMZWZ0LFxcblxcdFxcdFxcdGhlaWdodDogdGFyZ2V0LmlubmVySGVpZ2h0KCksXFxuXFx0XFx0XFx0d2lkdGg6IHRhcmdldC5pbm5lcldpZHRoKClcXG5cXHRcXHR9LFxcblxcdFxcdCAgICBzdGFydFBvc2l0aW9uID0gZWxlbS5vZmZzZXQoKSxcXG5cXHRcXHQgICAgdHJhbnNmZXIgPSAkKFxcXCI8ZGl2IGNsYXNzPSd1aS1lZmZlY3RzLXRyYW5zZmVyJz48L2Rpdj5cXFwiKS5hcHBlbmRUbyhkb2N1bWVudC5ib2R5KS5hZGRDbGFzcyhvLmNsYXNzTmFtZSkuY3NzKHtcXG5cXHRcXHRcXHR0b3A6IHN0YXJ0UG9zaXRpb24udG9wIC0gZml4VG9wLFxcblxcdFxcdFxcdGxlZnQ6IHN0YXJ0UG9zaXRpb24ubGVmdCAtIGZpeExlZnQsXFxuXFx0XFx0XFx0aGVpZ2h0OiBlbGVtLmlubmVySGVpZ2h0KCksXFxuXFx0XFx0XFx0d2lkdGg6IGVsZW0uaW5uZXJXaWR0aCgpLFxcblxcdFxcdFxcdHBvc2l0aW9uOiB0YXJnZXRGaXhlZCA/IFxcXCJmaXhlZFxcXCIgOiBcXFwiYWJzb2x1dGVcXFwiXFxuXFx0XFx0fSkuYW5pbWF0ZShhbmltYXRpb24sIG8uZHVyYXRpb24sIG8uZWFzaW5nLCBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0dHJhbnNmZXIucmVtb3ZlKCk7XFxuXFx0XFx0XFx0ZG9uZSgpO1xcblxcdFxcdH0pO1xcblxcdH07XFxuXFxuXFx0LyohXFxuICAqIGpRdWVyeSBVSSBQcm9ncmVzc2JhciAxLjExLjRcXG4gICogaHR0cDovL2pxdWVyeXVpLmNvbVxcbiAgKlxcbiAgKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xcbiAgKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXFxuICAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcXG4gICpcXG4gICogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20vcHJvZ3Jlc3NiYXIvXFxuICAqL1xcblxcblxcdHZhciBwcm9ncmVzc2JhciA9ICQud2lkZ2V0KFxcXCJ1aS5wcm9ncmVzc2JhclxcXCIsIHtcXG5cXHRcXHR2ZXJzaW9uOiBcXFwiMS4xMS40XFxcIixcXG5cXHRcXHRvcHRpb25zOiB7XFxuXFx0XFx0XFx0bWF4OiAxMDAsXFxuXFx0XFx0XFx0dmFsdWU6IDAsXFxuXFxuXFx0XFx0XFx0Y2hhbmdlOiBudWxsLFxcblxcdFxcdFxcdGNvbXBsZXRlOiBudWxsXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRtaW46IDAsXFxuXFxuXFx0XFx0X2NyZWF0ZTogZnVuY3Rpb24gX2NyZWF0ZSgpIHtcXG5cXHRcXHRcXHQvLyBDb25zdHJhaW4gaW5pdGlhbCB2YWx1ZVxcblxcdFxcdFxcdHRoaXMub2xkVmFsdWUgPSB0aGlzLm9wdGlvbnMudmFsdWUgPSB0aGlzLl9jb25zdHJhaW5lZFZhbHVlKCk7XFxuXFxuXFx0XFx0XFx0dGhpcy5lbGVtZW50LmFkZENsYXNzKFxcXCJ1aS1wcm9ncmVzc2JhciB1aS13aWRnZXQgdWktd2lkZ2V0LWNvbnRlbnQgdWktY29ybmVyLWFsbFxcXCIpLmF0dHIoe1xcblxcdFxcdFxcdFxcdC8vIE9ubHkgc2V0IHN0YXRpYyB2YWx1ZXMsIGFyaWEtdmFsdWVub3cgYW5kIGFyaWEtdmFsdWVtYXggYXJlXFxuXFx0XFx0XFx0XFx0Ly8gc2V0IGluc2lkZSBfcmVmcmVzaFZhbHVlKClcXG5cXHRcXHRcXHRcXHRyb2xlOiBcXFwicHJvZ3Jlc3NiYXJcXFwiLFxcblxcdFxcdFxcdFxcdFxcXCJhcmlhLXZhbHVlbWluXFxcIjogdGhpcy5taW5cXG5cXHRcXHRcXHR9KTtcXG5cXG5cXHRcXHRcXHR0aGlzLnZhbHVlRGl2ID0gJChcXFwiPGRpdiBjbGFzcz0ndWktcHJvZ3Jlc3NiYXItdmFsdWUgdWktd2lkZ2V0LWhlYWRlciB1aS1jb3JuZXItbGVmdCc+PC9kaXY+XFxcIikuYXBwZW5kVG8odGhpcy5lbGVtZW50KTtcXG5cXG5cXHRcXHRcXHR0aGlzLl9yZWZyZXNoVmFsdWUoKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9kZXN0cm95OiBmdW5jdGlvbiBfZGVzdHJveSgpIHtcXG5cXHRcXHRcXHR0aGlzLmVsZW1lbnQucmVtb3ZlQ2xhc3MoXFxcInVpLXByb2dyZXNzYmFyIHVpLXdpZGdldCB1aS13aWRnZXQtY29udGVudCB1aS1jb3JuZXItYWxsXFxcIikucmVtb3ZlQXR0cihcXFwicm9sZVxcXCIpLnJlbW92ZUF0dHIoXFxcImFyaWEtdmFsdWVtaW5cXFwiKS5yZW1vdmVBdHRyKFxcXCJhcmlhLXZhbHVlbWF4XFxcIikucmVtb3ZlQXR0cihcXFwiYXJpYS12YWx1ZW5vd1xcXCIpO1xcblxcblxcdFxcdFxcdHRoaXMudmFsdWVEaXYucmVtb3ZlKCk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHR2YWx1ZTogZnVuY3Rpb24gdmFsdWUobmV3VmFsdWUpIHtcXG5cXHRcXHRcXHRpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLm9wdGlvbnMudmFsdWU7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMub3B0aW9ucy52YWx1ZSA9IHRoaXMuX2NvbnN0cmFpbmVkVmFsdWUobmV3VmFsdWUpO1xcblxcdFxcdFxcdHRoaXMuX3JlZnJlc2hWYWx1ZSgpO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X2NvbnN0cmFpbmVkVmFsdWU6IGZ1bmN0aW9uIF9jb25zdHJhaW5lZFZhbHVlKG5ld1ZhbHVlKSB7XFxuXFx0XFx0XFx0aWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcXG5cXHRcXHRcXHRcXHRuZXdWYWx1ZSA9IHRoaXMub3B0aW9ucy52YWx1ZTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy5pbmRldGVybWluYXRlID0gbmV3VmFsdWUgPT09IGZhbHNlO1xcblxcblxcdFxcdFxcdC8vIHNhbml0aXplIHZhbHVlXFxuXFx0XFx0XFx0aWYgKHR5cGVvZiBuZXdWYWx1ZSAhPT0gXFxcIm51bWJlclxcXCIpIHtcXG5cXHRcXHRcXHRcXHRuZXdWYWx1ZSA9IDA7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLmluZGV0ZXJtaW5hdGUgPyBmYWxzZSA6IE1hdGgubWluKHRoaXMub3B0aW9ucy5tYXgsIE1hdGgubWF4KHRoaXMubWluLCBuZXdWYWx1ZSkpO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X3NldE9wdGlvbnM6IGZ1bmN0aW9uIF9zZXRPcHRpb25zKG9wdGlvbnMpIHtcXG5cXHRcXHRcXHQvLyBFbnN1cmUgXFxcInZhbHVlXFxcIiBvcHRpb24gaXMgc2V0IGFmdGVyIG90aGVyIHZhbHVlcyAobGlrZSBtYXgpXFxuXFx0XFx0XFx0dmFyIHZhbHVlID0gb3B0aW9ucy52YWx1ZTtcXG5cXHRcXHRcXHRkZWxldGUgb3B0aW9ucy52YWx1ZTtcXG5cXG5cXHRcXHRcXHR0aGlzLl9zdXBlcihvcHRpb25zKTtcXG5cXG5cXHRcXHRcXHR0aGlzLm9wdGlvbnMudmFsdWUgPSB0aGlzLl9jb25zdHJhaW5lZFZhbHVlKHZhbHVlKTtcXG5cXHRcXHRcXHR0aGlzLl9yZWZyZXNoVmFsdWUoKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9zZXRPcHRpb246IGZ1bmN0aW9uIF9zZXRPcHRpb24oa2V5LCB2YWx1ZSkge1xcblxcdFxcdFxcdGlmIChrZXkgPT09IFxcXCJtYXhcXFwiKSB7XFxuXFx0XFx0XFx0XFx0Ly8gRG9uJ3QgYWxsb3cgYSBtYXggbGVzcyB0aGFuIG1pblxcblxcdFxcdFxcdFxcdHZhbHVlID0gTWF0aC5tYXgodGhpcy5taW4sIHZhbHVlKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKGtleSA9PT0gXFxcImRpc2FibGVkXFxcIikge1xcblxcdFxcdFxcdFxcdHRoaXMuZWxlbWVudC50b2dnbGVDbGFzcyhcXFwidWktc3RhdGUtZGlzYWJsZWRcXFwiLCAhIXZhbHVlKS5hdHRyKFxcXCJhcmlhLWRpc2FibGVkXFxcIiwgdmFsdWUpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR0aGlzLl9zdXBlcihrZXksIHZhbHVlKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9wZXJjZW50YWdlOiBmdW5jdGlvbiBfcGVyY2VudGFnZSgpIHtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5pbmRldGVybWluYXRlID8gMTAwIDogMTAwICogKHRoaXMub3B0aW9ucy52YWx1ZSAtIHRoaXMubWluKSAvICh0aGlzLm9wdGlvbnMubWF4IC0gdGhpcy5taW4pO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X3JlZnJlc2hWYWx1ZTogZnVuY3Rpb24gX3JlZnJlc2hWYWx1ZSgpIHtcXG5cXHRcXHRcXHR2YXIgdmFsdWUgPSB0aGlzLm9wdGlvbnMudmFsdWUsXFxuXFx0XFx0XFx0ICAgIHBlcmNlbnRhZ2UgPSB0aGlzLl9wZXJjZW50YWdlKCk7XFxuXFxuXFx0XFx0XFx0dGhpcy52YWx1ZURpdi50b2dnbGUodGhpcy5pbmRldGVybWluYXRlIHx8IHZhbHVlID4gdGhpcy5taW4pLnRvZ2dsZUNsYXNzKFxcXCJ1aS1jb3JuZXItcmlnaHRcXFwiLCB2YWx1ZSA9PT0gdGhpcy5vcHRpb25zLm1heCkud2lkdGgocGVyY2VudGFnZS50b0ZpeGVkKDApICsgXFxcIiVcXFwiKTtcXG5cXG5cXHRcXHRcXHR0aGlzLmVsZW1lbnQudG9nZ2xlQ2xhc3MoXFxcInVpLXByb2dyZXNzYmFyLWluZGV0ZXJtaW5hdGVcXFwiLCB0aGlzLmluZGV0ZXJtaW5hdGUpO1xcblxcblxcdFxcdFxcdGlmICh0aGlzLmluZGV0ZXJtaW5hdGUpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLmVsZW1lbnQucmVtb3ZlQXR0cihcXFwiYXJpYS12YWx1ZW5vd1xcXCIpO1xcblxcdFxcdFxcdFxcdGlmICghdGhpcy5vdmVybGF5RGl2KSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5vdmVybGF5RGl2ID0gJChcXFwiPGRpdiBjbGFzcz0ndWktcHJvZ3Jlc3NiYXItb3ZlcmxheSc+PC9kaXY+XFxcIikuYXBwZW5kVG8odGhpcy52YWx1ZURpdik7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5lbGVtZW50LmF0dHIoe1xcblxcdFxcdFxcdFxcdFxcdFxcXCJhcmlhLXZhbHVlbWF4XFxcIjogdGhpcy5vcHRpb25zLm1heCxcXG5cXHRcXHRcXHRcXHRcXHRcXFwiYXJpYS12YWx1ZW5vd1xcXCI6IHZhbHVlXFxuXFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0XFx0aWYgKHRoaXMub3ZlcmxheURpdikge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMub3ZlcmxheURpdi5yZW1vdmUoKTtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLm92ZXJsYXlEaXYgPSBudWxsO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKHRoaXMub2xkVmFsdWUgIT09IHZhbHVlKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5vbGRWYWx1ZSA9IHZhbHVlO1xcblxcdFxcdFxcdFxcdHRoaXMuX3RyaWdnZXIoXFxcImNoYW5nZVxcXCIpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAodmFsdWUgPT09IHRoaXMub3B0aW9ucy5tYXgpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl90cmlnZ2VyKFxcXCJjb21wbGV0ZVxcXCIpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fSk7XFxuXFxuXFx0LyohXFxuICAqIGpRdWVyeSBVSSBTZWxlY3RhYmxlIDEuMTEuNFxcbiAgKiBodHRwOi8vanF1ZXJ5dWkuY29tXFxuICAqXFxuICAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXFxuICAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cXG4gICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxcbiAgKlxcbiAgKiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9zZWxlY3RhYmxlL1xcbiAgKi9cXG5cXG5cXHR2YXIgc2VsZWN0YWJsZSA9ICQud2lkZ2V0KFxcXCJ1aS5zZWxlY3RhYmxlXFxcIiwgJC51aS5tb3VzZSwge1xcblxcdFxcdHZlcnNpb246IFxcXCIxLjExLjRcXFwiLFxcblxcdFxcdG9wdGlvbnM6IHtcXG5cXHRcXHRcXHRhcHBlbmRUbzogXFxcImJvZHlcXFwiLFxcblxcdFxcdFxcdGF1dG9SZWZyZXNoOiB0cnVlLFxcblxcdFxcdFxcdGRpc3RhbmNlOiAwLFxcblxcdFxcdFxcdGZpbHRlcjogXFxcIipcXFwiLFxcblxcdFxcdFxcdHRvbGVyYW5jZTogXFxcInRvdWNoXFxcIixcXG5cXG5cXHRcXHRcXHQvLyBjYWxsYmFja3NcXG5cXHRcXHRcXHRzZWxlY3RlZDogbnVsbCxcXG5cXHRcXHRcXHRzZWxlY3Rpbmc6IG51bGwsXFxuXFx0XFx0XFx0c3RhcnQ6IG51bGwsXFxuXFx0XFx0XFx0c3RvcDogbnVsbCxcXG5cXHRcXHRcXHR1bnNlbGVjdGVkOiBudWxsLFxcblxcdFxcdFxcdHVuc2VsZWN0aW5nOiBudWxsXFxuXFx0XFx0fSxcXG5cXHRcXHRfY3JlYXRlOiBmdW5jdGlvbiBfY3JlYXRlKCkge1xcblxcdFxcdFxcdHZhciBzZWxlY3RlZXMsXFxuXFx0XFx0XFx0ICAgIHRoYXQgPSB0aGlzO1xcblxcblxcdFxcdFxcdHRoaXMuZWxlbWVudC5hZGRDbGFzcyhcXFwidWktc2VsZWN0YWJsZVxcXCIpO1xcblxcblxcdFxcdFxcdHRoaXMuZHJhZ2dlZCA9IGZhbHNlO1xcblxcblxcdFxcdFxcdC8vIGNhY2hlIHNlbGVjdGVlIGNoaWxkcmVuIGJhc2VkIG9uIGZpbHRlclxcblxcdFxcdFxcdHRoaXMucmVmcmVzaCA9IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRzZWxlY3RlZXMgPSAkKHRoYXQub3B0aW9ucy5maWx0ZXIsIHRoYXQuZWxlbWVudFswXSk7XFxuXFx0XFx0XFx0XFx0c2VsZWN0ZWVzLmFkZENsYXNzKFxcXCJ1aS1zZWxlY3RlZVxcXCIpO1xcblxcdFxcdFxcdFxcdHNlbGVjdGVlcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgJHRoaXMgPSAkKHRoaXMpLFxcblxcdFxcdFxcdFxcdFxcdCAgICBwb3MgPSAkdGhpcy5vZmZzZXQoKTtcXG5cXHRcXHRcXHRcXHRcXHQkLmRhdGEodGhpcywgXFxcInNlbGVjdGFibGUtaXRlbVxcXCIsIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRlbGVtZW50OiB0aGlzLFxcblxcdFxcdFxcdFxcdFxcdFxcdCRlbGVtZW50OiAkdGhpcyxcXG5cXHRcXHRcXHRcXHRcXHRcXHRsZWZ0OiBwb3MubGVmdCxcXG5cXHRcXHRcXHRcXHRcXHRcXHR0b3A6IHBvcy50b3AsXFxuXFx0XFx0XFx0XFx0XFx0XFx0cmlnaHQ6IHBvcy5sZWZ0ICsgJHRoaXMub3V0ZXJXaWR0aCgpLFxcblxcdFxcdFxcdFxcdFxcdFxcdGJvdHRvbTogcG9zLnRvcCArICR0aGlzLm91dGVySGVpZ2h0KCksXFxuXFx0XFx0XFx0XFx0XFx0XFx0c3RhcnRzZWxlY3RlZDogZmFsc2UsXFxuXFx0XFx0XFx0XFx0XFx0XFx0c2VsZWN0ZWQ6ICR0aGlzLmhhc0NsYXNzKFxcXCJ1aS1zZWxlY3RlZFxcXCIpLFxcblxcdFxcdFxcdFxcdFxcdFxcdHNlbGVjdGluZzogJHRoaXMuaGFzQ2xhc3MoXFxcInVpLXNlbGVjdGluZ1xcXCIpLFxcblxcdFxcdFxcdFxcdFxcdFxcdHVuc2VsZWN0aW5nOiAkdGhpcy5oYXNDbGFzcyhcXFwidWktdW5zZWxlY3RpbmdcXFwiKVxcblxcdFxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdH07XFxuXFx0XFx0XFx0dGhpcy5yZWZyZXNoKCk7XFxuXFxuXFx0XFx0XFx0dGhpcy5zZWxlY3RlZXMgPSBzZWxlY3RlZXMuYWRkQ2xhc3MoXFxcInVpLXNlbGVjdGVlXFxcIik7XFxuXFxuXFx0XFx0XFx0dGhpcy5fbW91c2VJbml0KCk7XFxuXFxuXFx0XFx0XFx0dGhpcy5oZWxwZXIgPSAkKFxcXCI8ZGl2IGNsYXNzPSd1aS1zZWxlY3RhYmxlLWhlbHBlcic+PC9kaXY+XFxcIik7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfZGVzdHJveTogZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XFxuXFx0XFx0XFx0dGhpcy5zZWxlY3RlZXMucmVtb3ZlQ2xhc3MoXFxcInVpLXNlbGVjdGVlXFxcIikucmVtb3ZlRGF0YShcXFwic2VsZWN0YWJsZS1pdGVtXFxcIik7XFxuXFx0XFx0XFx0dGhpcy5lbGVtZW50LnJlbW92ZUNsYXNzKFxcXCJ1aS1zZWxlY3RhYmxlIHVpLXNlbGVjdGFibGUtZGlzYWJsZWRcXFwiKTtcXG5cXHRcXHRcXHR0aGlzLl9tb3VzZURlc3Ryb3koKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9tb3VzZVN0YXJ0OiBmdW5jdGlvbiBfbW91c2VTdGFydChldmVudCkge1xcblxcdFxcdFxcdHZhciB0aGF0ID0gdGhpcyxcXG5cXHRcXHRcXHQgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcXG5cXG5cXHRcXHRcXHR0aGlzLm9wb3MgPSBbZXZlbnQucGFnZVgsIGV2ZW50LnBhZ2VZXTtcXG5cXG5cXHRcXHRcXHRpZiAodGhpcy5vcHRpb25zLmRpc2FibGVkKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLnNlbGVjdGVlcyA9ICQob3B0aW9ucy5maWx0ZXIsIHRoaXMuZWxlbWVudFswXSk7XFxuXFxuXFx0XFx0XFx0dGhpcy5fdHJpZ2dlcihcXFwic3RhcnRcXFwiLCBldmVudCk7XFxuXFxuXFx0XFx0XFx0JChvcHRpb25zLmFwcGVuZFRvKS5hcHBlbmQodGhpcy5oZWxwZXIpO1xcblxcdFxcdFxcdC8vIHBvc2l0aW9uIGhlbHBlciAobGFzc28pXFxuXFx0XFx0XFx0dGhpcy5oZWxwZXIuY3NzKHtcXG5cXHRcXHRcXHRcXHRcXFwibGVmdFxcXCI6IGV2ZW50LnBhZ2VYLFxcblxcdFxcdFxcdFxcdFxcXCJ0b3BcXFwiOiBldmVudC5wYWdlWSxcXG5cXHRcXHRcXHRcXHRcXFwid2lkdGhcXFwiOiAwLFxcblxcdFxcdFxcdFxcdFxcXCJoZWlnaHRcXFwiOiAwXFxuXFx0XFx0XFx0fSk7XFxuXFxuXFx0XFx0XFx0aWYgKG9wdGlvbnMuYXV0b1JlZnJlc2gpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLnJlZnJlc2goKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy5zZWxlY3RlZXMuZmlsdGVyKFxcXCIudWktc2VsZWN0ZWRcXFwiKS5lYWNoKGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHR2YXIgc2VsZWN0ZWUgPSAkLmRhdGEodGhpcywgXFxcInNlbGVjdGFibGUtaXRlbVxcXCIpO1xcblxcdFxcdFxcdFxcdHNlbGVjdGVlLnN0YXJ0c2VsZWN0ZWQgPSB0cnVlO1xcblxcdFxcdFxcdFxcdGlmICghZXZlbnQubWV0YUtleSAmJiAhZXZlbnQuY3RybEtleSkge1xcblxcdFxcdFxcdFxcdFxcdHNlbGVjdGVlLiRlbGVtZW50LnJlbW92ZUNsYXNzKFxcXCJ1aS1zZWxlY3RlZFxcXCIpO1xcblxcdFxcdFxcdFxcdFxcdHNlbGVjdGVlLnNlbGVjdGVkID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0XFx0c2VsZWN0ZWUuJGVsZW1lbnQuYWRkQ2xhc3MoXFxcInVpLXVuc2VsZWN0aW5nXFxcIik7XFxuXFx0XFx0XFx0XFx0XFx0c2VsZWN0ZWUudW5zZWxlY3RpbmcgPSB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdC8vIHNlbGVjdGFibGUgVU5TRUxFQ1RJTkcgY2FsbGJhY2tcXG5cXHRcXHRcXHRcXHRcXHR0aGF0Ll90cmlnZ2VyKFxcXCJ1bnNlbGVjdGluZ1xcXCIsIGV2ZW50LCB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dW5zZWxlY3Rpbmc6IHNlbGVjdGVlLmVsZW1lbnRcXG5cXHRcXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSk7XFxuXFxuXFx0XFx0XFx0JChldmVudC50YXJnZXQpLnBhcmVudHMoKS5hZGRCYWNrKCkuZWFjaChmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0dmFyIGRvU2VsZWN0LFxcblxcdFxcdFxcdFxcdCAgICBzZWxlY3RlZSA9ICQuZGF0YSh0aGlzLCBcXFwic2VsZWN0YWJsZS1pdGVtXFxcIik7XFxuXFx0XFx0XFx0XFx0aWYgKHNlbGVjdGVlKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZG9TZWxlY3QgPSAhZXZlbnQubWV0YUtleSAmJiAhZXZlbnQuY3RybEtleSB8fCAhc2VsZWN0ZWUuJGVsZW1lbnQuaGFzQ2xhc3MoXFxcInVpLXNlbGVjdGVkXFxcIik7XFxuXFx0XFx0XFx0XFx0XFx0c2VsZWN0ZWUuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoZG9TZWxlY3QgPyBcXFwidWktdW5zZWxlY3RpbmdcXFwiIDogXFxcInVpLXNlbGVjdGVkXFxcIikuYWRkQ2xhc3MoZG9TZWxlY3QgPyBcXFwidWktc2VsZWN0aW5nXFxcIiA6IFxcXCJ1aS11bnNlbGVjdGluZ1xcXCIpO1xcblxcdFxcdFxcdFxcdFxcdHNlbGVjdGVlLnVuc2VsZWN0aW5nID0gIWRvU2VsZWN0O1xcblxcdFxcdFxcdFxcdFxcdHNlbGVjdGVlLnNlbGVjdGluZyA9IGRvU2VsZWN0O1xcblxcdFxcdFxcdFxcdFxcdHNlbGVjdGVlLnNlbGVjdGVkID0gZG9TZWxlY3Q7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gc2VsZWN0YWJsZSAoVU4pU0VMRUNUSU5HIGNhbGxiYWNrXFxuXFx0XFx0XFx0XFx0XFx0aWYgKGRvU2VsZWN0KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhhdC5fdHJpZ2dlcihcXFwic2VsZWN0aW5nXFxcIiwgZXZlbnQsIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzZWxlY3Rpbmc6IHNlbGVjdGVlLmVsZW1lbnRcXG5cXHRcXHRcXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoYXQuX3RyaWdnZXIoXFxcInVuc2VsZWN0aW5nXFxcIiwgZXZlbnQsIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR1bnNlbGVjdGluZzogc2VsZWN0ZWUuZWxlbWVudFxcblxcdFxcdFxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0pO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X21vdXNlRHJhZzogZnVuY3Rpb24gX21vdXNlRHJhZyhldmVudCkge1xcblxcblxcdFxcdFxcdHRoaXMuZHJhZ2dlZCA9IHRydWU7XFxuXFxuXFx0XFx0XFx0aWYgKHRoaXMub3B0aW9ucy5kaXNhYmxlZCkge1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dmFyIHRtcCxcXG5cXHRcXHRcXHQgICAgdGhhdCA9IHRoaXMsXFxuXFx0XFx0XFx0ICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXFxuXFx0XFx0XFx0ICAgIHgxID0gdGhpcy5vcG9zWzBdLFxcblxcdFxcdFxcdCAgICB5MSA9IHRoaXMub3Bvc1sxXSxcXG5cXHRcXHRcXHQgICAgeDIgPSBldmVudC5wYWdlWCxcXG5cXHRcXHRcXHQgICAgeTIgPSBldmVudC5wYWdlWTtcXG5cXG5cXHRcXHRcXHRpZiAoeDEgPiB4Mikge1xcblxcdFxcdFxcdFxcdHRtcCA9IHgyO3gyID0geDE7eDEgPSB0bXA7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICh5MSA+IHkyKSB7XFxuXFx0XFx0XFx0XFx0dG1wID0geTI7eTIgPSB5MTt5MSA9IHRtcDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0dGhpcy5oZWxwZXIuY3NzKHsgbGVmdDogeDEsIHRvcDogeTEsIHdpZHRoOiB4MiAtIHgxLCBoZWlnaHQ6IHkyIC0geTEgfSk7XFxuXFxuXFx0XFx0XFx0dGhpcy5zZWxlY3RlZXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0dmFyIHNlbGVjdGVlID0gJC5kYXRhKHRoaXMsIFxcXCJzZWxlY3RhYmxlLWl0ZW1cXFwiKSxcXG5cXHRcXHRcXHRcXHQgICAgaGl0ID0gZmFsc2U7XFxuXFxuXFx0XFx0XFx0XFx0Ly9wcmV2ZW50IGhlbHBlciBmcm9tIGJlaW5nIHNlbGVjdGVkIGlmIGFwcGVuZFRvOiBzZWxlY3RhYmxlXFxuXFx0XFx0XFx0XFx0aWYgKCFzZWxlY3RlZSB8fCBzZWxlY3RlZS5lbGVtZW50ID09PSB0aGF0LmVsZW1lbnRbMF0pIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmIChvcHRpb25zLnRvbGVyYW5jZSA9PT0gXFxcInRvdWNoXFxcIikge1xcblxcdFxcdFxcdFxcdFxcdGhpdCA9ICEoc2VsZWN0ZWUubGVmdCA+IHgyIHx8IHNlbGVjdGVlLnJpZ2h0IDwgeDEgfHwgc2VsZWN0ZWUudG9wID4geTIgfHwgc2VsZWN0ZWUuYm90dG9tIDwgeTEpO1xcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAob3B0aW9ucy50b2xlcmFuY2UgPT09IFxcXCJmaXRcXFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0aGl0ID0gc2VsZWN0ZWUubGVmdCA+IHgxICYmIHNlbGVjdGVlLnJpZ2h0IDwgeDIgJiYgc2VsZWN0ZWUudG9wID4geTEgJiYgc2VsZWN0ZWUuYm90dG9tIDwgeTI7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmIChoaXQpIHtcXG5cXHRcXHRcXHRcXHRcXHQvLyBTRUxFQ1RcXG5cXHRcXHRcXHRcXHRcXHRpZiAoc2VsZWN0ZWUuc2VsZWN0ZWQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzZWxlY3RlZS4kZWxlbWVudC5yZW1vdmVDbGFzcyhcXFwidWktc2VsZWN0ZWRcXFwiKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzZWxlY3RlZS5zZWxlY3RlZCA9IGZhbHNlO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRpZiAoc2VsZWN0ZWUudW5zZWxlY3RpbmcpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzZWxlY3RlZS4kZWxlbWVudC5yZW1vdmVDbGFzcyhcXFwidWktdW5zZWxlY3RpbmdcXFwiKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzZWxlY3RlZS51bnNlbGVjdGluZyA9IGZhbHNlO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIXNlbGVjdGVlLnNlbGVjdGluZykge1xcblxcdFxcdFxcdFxcdFxcdFxcdHNlbGVjdGVlLiRlbGVtZW50LmFkZENsYXNzKFxcXCJ1aS1zZWxlY3RpbmdcXFwiKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzZWxlY3RlZS5zZWxlY3RpbmcgPSB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdFxcdC8vIHNlbGVjdGFibGUgU0VMRUNUSU5HIGNhbGxiYWNrXFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhhdC5fdHJpZ2dlcihcXFwic2VsZWN0aW5nXFxcIiwgZXZlbnQsIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzZWxlY3Rpbmc6IHNlbGVjdGVlLmVsZW1lbnRcXG5cXHRcXHRcXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHQvLyBVTlNFTEVDVFxcblxcdFxcdFxcdFxcdFxcdGlmIChzZWxlY3RlZS5zZWxlY3RpbmcpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoKGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuY3RybEtleSkgJiYgc2VsZWN0ZWUuc3RhcnRzZWxlY3RlZCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHNlbGVjdGVlLiRlbGVtZW50LnJlbW92ZUNsYXNzKFxcXCJ1aS1zZWxlY3RpbmdcXFwiKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzZWxlY3RlZS5zZWxlY3RpbmcgPSBmYWxzZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzZWxlY3RlZS4kZWxlbWVudC5hZGRDbGFzcyhcXFwidWktc2VsZWN0ZWRcXFwiKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzZWxlY3RlZS5zZWxlY3RlZCA9IHRydWU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzZWxlY3RlZS4kZWxlbWVudC5yZW1vdmVDbGFzcyhcXFwidWktc2VsZWN0aW5nXFxcIik7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c2VsZWN0ZWUuc2VsZWN0aW5nID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKHNlbGVjdGVlLnN0YXJ0c2VsZWN0ZWQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRzZWxlY3RlZS4kZWxlbWVudC5hZGRDbGFzcyhcXFwidWktdW5zZWxlY3RpbmdcXFwiKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRzZWxlY3RlZS51bnNlbGVjdGluZyA9IHRydWU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIHNlbGVjdGFibGUgVU5TRUxFQ1RJTkcgY2FsbGJhY2tcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGF0Ll90cmlnZ2VyKFxcXCJ1bnNlbGVjdGluZ1xcXCIsIGV2ZW50LCB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dW5zZWxlY3Rpbmc6IHNlbGVjdGVlLmVsZW1lbnRcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmIChzZWxlY3RlZS5zZWxlY3RlZCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICghZXZlbnQubWV0YUtleSAmJiAhZXZlbnQuY3RybEtleSAmJiAhc2VsZWN0ZWUuc3RhcnRzZWxlY3RlZCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHNlbGVjdGVlLiRlbGVtZW50LnJlbW92ZUNsYXNzKFxcXCJ1aS1zZWxlY3RlZFxcXCIpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHNlbGVjdGVlLnNlbGVjdGVkID0gZmFsc2U7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c2VsZWN0ZWUuJGVsZW1lbnQuYWRkQ2xhc3MoXFxcInVpLXVuc2VsZWN0aW5nXFxcIik7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c2VsZWN0ZWUudW5zZWxlY3RpbmcgPSB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIHNlbGVjdGFibGUgVU5TRUxFQ1RJTkcgY2FsbGJhY2tcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGF0Ll90cmlnZ2VyKFxcXCJ1bnNlbGVjdGluZ1xcXCIsIGV2ZW50LCB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dW5zZWxlY3Rpbmc6IHNlbGVjdGVlLmVsZW1lbnRcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9KTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfbW91c2VTdG9wOiBmdW5jdGlvbiBfbW91c2VTdG9wKGV2ZW50KSB7XFxuXFx0XFx0XFx0dmFyIHRoYXQgPSB0aGlzO1xcblxcblxcdFxcdFxcdHRoaXMuZHJhZ2dlZCA9IGZhbHNlO1xcblxcblxcdFxcdFxcdCQoXFxcIi51aS11bnNlbGVjdGluZ1xcXCIsIHRoaXMuZWxlbWVudFswXSkuZWFjaChmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0dmFyIHNlbGVjdGVlID0gJC5kYXRhKHRoaXMsIFxcXCJzZWxlY3RhYmxlLWl0ZW1cXFwiKTtcXG5cXHRcXHRcXHRcXHRzZWxlY3RlZS4kZWxlbWVudC5yZW1vdmVDbGFzcyhcXFwidWktdW5zZWxlY3RpbmdcXFwiKTtcXG5cXHRcXHRcXHRcXHRzZWxlY3RlZS51bnNlbGVjdGluZyA9IGZhbHNlO1xcblxcdFxcdFxcdFxcdHNlbGVjdGVlLnN0YXJ0c2VsZWN0ZWQgPSBmYWxzZTtcXG5cXHRcXHRcXHRcXHR0aGF0Ll90cmlnZ2VyKFxcXCJ1bnNlbGVjdGVkXFxcIiwgZXZlbnQsIHtcXG5cXHRcXHRcXHRcXHRcXHR1bnNlbGVjdGVkOiBzZWxlY3RlZS5lbGVtZW50XFxuXFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0JChcXFwiLnVpLXNlbGVjdGluZ1xcXCIsIHRoaXMuZWxlbWVudFswXSkuZWFjaChmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0dmFyIHNlbGVjdGVlID0gJC5kYXRhKHRoaXMsIFxcXCJzZWxlY3RhYmxlLWl0ZW1cXFwiKTtcXG5cXHRcXHRcXHRcXHRzZWxlY3RlZS4kZWxlbWVudC5yZW1vdmVDbGFzcyhcXFwidWktc2VsZWN0aW5nXFxcIikuYWRkQ2xhc3MoXFxcInVpLXNlbGVjdGVkXFxcIik7XFxuXFx0XFx0XFx0XFx0c2VsZWN0ZWUuc2VsZWN0aW5nID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0c2VsZWN0ZWUuc2VsZWN0ZWQgPSB0cnVlO1xcblxcdFxcdFxcdFxcdHNlbGVjdGVlLnN0YXJ0c2VsZWN0ZWQgPSB0cnVlO1xcblxcdFxcdFxcdFxcdHRoYXQuX3RyaWdnZXIoXFxcInNlbGVjdGVkXFxcIiwgZXZlbnQsIHtcXG5cXHRcXHRcXHRcXHRcXHRzZWxlY3RlZDogc2VsZWN0ZWUuZWxlbWVudFxcblxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdHRoaXMuX3RyaWdnZXIoXFxcInN0b3BcXFwiLCBldmVudCk7XFxuXFxuXFx0XFx0XFx0dGhpcy5oZWxwZXIucmVtb3ZlKCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdH1cXG5cXG5cXHR9KTtcXG5cXG5cXHQvKiFcXG4gICogalF1ZXJ5IFVJIFNlbGVjdG1lbnUgMS4xMS40XFxuICAqIGh0dHA6Ly9qcXVlcnl1aS5jb21cXG4gICpcXG4gICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcXG4gICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxcbiAgKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXFxuICAqXFxuICAqIGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL3NlbGVjdG1lbnVcXG4gICovXFxuXFxuXFx0dmFyIHNlbGVjdG1lbnUgPSAkLndpZGdldChcXFwidWkuc2VsZWN0bWVudVxcXCIsIHtcXG5cXHRcXHR2ZXJzaW9uOiBcXFwiMS4xMS40XFxcIixcXG5cXHRcXHRkZWZhdWx0RWxlbWVudDogXFxcIjxzZWxlY3Q+XFxcIixcXG5cXHRcXHRvcHRpb25zOiB7XFxuXFx0XFx0XFx0YXBwZW5kVG86IG51bGwsXFxuXFx0XFx0XFx0ZGlzYWJsZWQ6IG51bGwsXFxuXFx0XFx0XFx0aWNvbnM6IHtcXG5cXHRcXHRcXHRcXHRidXR0b246IFxcXCJ1aS1pY29uLXRyaWFuZ2xlLTEtc1xcXCJcXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdHBvc2l0aW9uOiB7XFxuXFx0XFx0XFx0XFx0bXk6IFxcXCJsZWZ0IHRvcFxcXCIsXFxuXFx0XFx0XFx0XFx0YXQ6IFxcXCJsZWZ0IGJvdHRvbVxcXCIsXFxuXFx0XFx0XFx0XFx0Y29sbGlzaW9uOiBcXFwibm9uZVxcXCJcXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdHdpZHRoOiBudWxsLFxcblxcblxcdFxcdFxcdC8vIGNhbGxiYWNrc1xcblxcdFxcdFxcdGNoYW5nZTogbnVsbCxcXG5cXHRcXHRcXHRjbG9zZTogbnVsbCxcXG5cXHRcXHRcXHRmb2N1czogbnVsbCxcXG5cXHRcXHRcXHRvcGVuOiBudWxsLFxcblxcdFxcdFxcdHNlbGVjdDogbnVsbFxcblxcdFxcdH0sXFxuXFxuXFx0XFx0X2NyZWF0ZTogZnVuY3Rpb24gX2NyZWF0ZSgpIHtcXG5cXHRcXHRcXHR2YXIgc2VsZWN0bWVudUlkID0gdGhpcy5lbGVtZW50LnVuaXF1ZUlkKCkuYXR0cihcXFwiaWRcXFwiKTtcXG5cXHRcXHRcXHR0aGlzLmlkcyA9IHtcXG5cXHRcXHRcXHRcXHRlbGVtZW50OiBzZWxlY3RtZW51SWQsXFxuXFx0XFx0XFx0XFx0YnV0dG9uOiBzZWxlY3RtZW51SWQgKyBcXFwiLWJ1dHRvblxcXCIsXFxuXFx0XFx0XFx0XFx0bWVudTogc2VsZWN0bWVudUlkICsgXFxcIi1tZW51XFxcIlxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0XFx0dGhpcy5fZHJhd0J1dHRvbigpO1xcblxcdFxcdFxcdHRoaXMuX2RyYXdNZW51KCk7XFxuXFxuXFx0XFx0XFx0aWYgKHRoaXMub3B0aW9ucy5kaXNhYmxlZCkge1xcblxcdFxcdFxcdFxcdHRoaXMuZGlzYWJsZSgpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcblxcdFxcdF9kcmF3QnV0dG9uOiBmdW5jdGlvbiBfZHJhd0J1dHRvbigpIHtcXG5cXHRcXHRcXHR2YXIgdGhhdCA9IHRoaXM7XFxuXFxuXFx0XFx0XFx0Ly8gQXNzb2NpYXRlIGV4aXN0aW5nIGxhYmVsIHdpdGggdGhlIG5ldyBidXR0b25cXG5cXHRcXHRcXHR0aGlzLmxhYmVsID0gJChcXFwibGFiZWxbZm9yPSdcXFwiICsgdGhpcy5pZHMuZWxlbWVudCArIFxcXCInXVxcXCIpLmF0dHIoXFxcImZvclxcXCIsIHRoaXMuaWRzLmJ1dHRvbik7XFxuXFx0XFx0XFx0dGhpcy5fb24odGhpcy5sYWJlbCwge1xcblxcdFxcdFxcdFxcdGNsaWNrOiBmdW5jdGlvbiBjbGljayhldmVudCkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuYnV0dG9uLmZvY3VzKCk7XFxuXFx0XFx0XFx0XFx0XFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSk7XFxuXFxuXFx0XFx0XFx0Ly8gSGlkZSBvcmlnaW5hbCBzZWxlY3QgZWxlbWVudFxcblxcdFxcdFxcdHRoaXMuZWxlbWVudC5oaWRlKCk7XFxuXFxuXFx0XFx0XFx0Ly8gQ3JlYXRlIGJ1dHRvblxcblxcdFxcdFxcdHRoaXMuYnV0dG9uID0gJChcXFwiPHNwYW4+XFxcIiwge1xcblxcdFxcdFxcdFxcdFxcXCJjbGFzc1xcXCI6IFxcXCJ1aS1zZWxlY3RtZW51LWJ1dHRvbiB1aS13aWRnZXQgdWktc3RhdGUtZGVmYXVsdCB1aS1jb3JuZXItYWxsXFxcIixcXG5cXHRcXHRcXHRcXHR0YWJpbmRleDogdGhpcy5vcHRpb25zLmRpc2FibGVkID8gLTEgOiAwLFxcblxcdFxcdFxcdFxcdGlkOiB0aGlzLmlkcy5idXR0b24sXFxuXFx0XFx0XFx0XFx0cm9sZTogXFxcImNvbWJvYm94XFxcIixcXG5cXHRcXHRcXHRcXHRcXFwiYXJpYS1leHBhbmRlZFxcXCI6IFxcXCJmYWxzZVxcXCIsXFxuXFx0XFx0XFx0XFx0XFxcImFyaWEtYXV0b2NvbXBsZXRlXFxcIjogXFxcImxpc3RcXFwiLFxcblxcdFxcdFxcdFxcdFxcXCJhcmlhLW93bnNcXFwiOiB0aGlzLmlkcy5tZW51LFxcblxcdFxcdFxcdFxcdFxcXCJhcmlhLWhhc3BvcHVwXFxcIjogXFxcInRydWVcXFwiXFxuXFx0XFx0XFx0fSkuaW5zZXJ0QWZ0ZXIodGhpcy5lbGVtZW50KTtcXG5cXG5cXHRcXHRcXHQkKFxcXCI8c3Bhbj5cXFwiLCB7XFxuXFx0XFx0XFx0XFx0XFxcImNsYXNzXFxcIjogXFxcInVpLWljb24gXFxcIiArIHRoaXMub3B0aW9ucy5pY29ucy5idXR0b25cXG5cXHRcXHRcXHR9KS5wcmVwZW5kVG8odGhpcy5idXR0b24pO1xcblxcblxcdFxcdFxcdHRoaXMuYnV0dG9uVGV4dCA9ICQoXFxcIjxzcGFuPlxcXCIsIHtcXG5cXHRcXHRcXHRcXHRcXFwiY2xhc3NcXFwiOiBcXFwidWktc2VsZWN0bWVudS10ZXh0XFxcIlxcblxcdFxcdFxcdH0pLmFwcGVuZFRvKHRoaXMuYnV0dG9uKTtcXG5cXG5cXHRcXHRcXHR0aGlzLl9zZXRUZXh0KHRoaXMuYnV0dG9uVGV4dCwgdGhpcy5lbGVtZW50LmZpbmQoXFxcIm9wdGlvbjpzZWxlY3RlZFxcXCIpLnRleHQoKSk7XFxuXFx0XFx0XFx0dGhpcy5fcmVzaXplQnV0dG9uKCk7XFxuXFxuXFx0XFx0XFx0dGhpcy5fb24odGhpcy5idXR0b24sIHRoaXMuX2J1dHRvbkV2ZW50cyk7XFxuXFx0XFx0XFx0dGhpcy5idXR0b24ub25lKFxcXCJmb2N1c2luXFxcIiwgZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdFxcdC8vIERlbGF5IHJlbmRlcmluZyB0aGUgbWVudSBpdGVtcyB1bnRpbCB0aGUgYnV0dG9uIHJlY2VpdmVzIGZvY3VzLlxcblxcdFxcdFxcdFxcdC8vIFRoZSBtZW51IG1heSBoYXZlIGFscmVhZHkgYmVlbiByZW5kZXJlZCB2aWEgYSBwcm9ncmFtbWF0aWMgb3Blbi5cXG5cXHRcXHRcXHRcXHRpZiAoIXRoYXQubWVudUl0ZW1zKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhhdC5fcmVmcmVzaE1lbnUoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0dGhpcy5faG92ZXJhYmxlKHRoaXMuYnV0dG9uKTtcXG5cXHRcXHRcXHR0aGlzLl9mb2N1c2FibGUodGhpcy5idXR0b24pO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X2RyYXdNZW51OiBmdW5jdGlvbiBfZHJhd01lbnUoKSB7XFxuXFx0XFx0XFx0dmFyIHRoYXQgPSB0aGlzO1xcblxcblxcdFxcdFxcdC8vIENyZWF0ZSBtZW51XFxuXFx0XFx0XFx0dGhpcy5tZW51ID0gJChcXFwiPHVsPlxcXCIsIHtcXG5cXHRcXHRcXHRcXHRcXFwiYXJpYS1oaWRkZW5cXFwiOiBcXFwidHJ1ZVxcXCIsXFxuXFx0XFx0XFx0XFx0XFxcImFyaWEtbGFiZWxsZWRieVxcXCI6IHRoaXMuaWRzLmJ1dHRvbixcXG5cXHRcXHRcXHRcXHRpZDogdGhpcy5pZHMubWVudVxcblxcdFxcdFxcdH0pO1xcblxcblxcdFxcdFxcdC8vIFdyYXAgbWVudVxcblxcdFxcdFxcdHRoaXMubWVudVdyYXAgPSAkKFxcXCI8ZGl2PlxcXCIsIHtcXG5cXHRcXHRcXHRcXHRcXFwiY2xhc3NcXFwiOiBcXFwidWktc2VsZWN0bWVudS1tZW51IHVpLWZyb250XFxcIlxcblxcdFxcdFxcdH0pLmFwcGVuZCh0aGlzLm1lbnUpLmFwcGVuZFRvKHRoaXMuX2FwcGVuZFRvKCkpO1xcblxcblxcdFxcdFxcdC8vIEluaXRpYWxpemUgbWVudSB3aWRnZXRcXG5cXHRcXHRcXHR0aGlzLm1lbnVJbnN0YW5jZSA9IHRoaXMubWVudS5tZW51KHtcXG5cXHRcXHRcXHRcXHRyb2xlOiBcXFwibGlzdGJveFxcXCIsXFxuXFx0XFx0XFx0XFx0c2VsZWN0OiBmdW5jdGlvbiBzZWxlY3QoZXZlbnQsIHVpKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBzdXBwb3J0OiBJRThcXG5cXHRcXHRcXHRcXHRcXHQvLyBJZiB0aGUgaXRlbSB3YXMgc2VsZWN0ZWQgdmlhIGEgY2xpY2ssIHRoZSB0ZXh0IHNlbGVjdGlvblxcblxcdFxcdFxcdFxcdFxcdC8vIHdpbGwgYmUgZGVzdHJveWVkIGluIElFXFxuXFx0XFx0XFx0XFx0XFx0dGhhdC5fc2V0U2VsZWN0aW9uKCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGhhdC5fc2VsZWN0KHVpLml0ZW0uZGF0YShcXFwidWktc2VsZWN0bWVudS1pdGVtXFxcIiksIGV2ZW50KTtcXG5cXHRcXHRcXHRcXHR9LFxcblxcdFxcdFxcdFxcdGZvY3VzOiBmdW5jdGlvbiBmb2N1cyhldmVudCwgdWkpIHtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgaXRlbSA9IHVpLml0ZW0uZGF0YShcXFwidWktc2VsZWN0bWVudS1pdGVtXFxcIik7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gUHJldmVudCBpbml0YWwgZm9jdXMgZnJvbSBmaXJpbmcgYW5kIGNoZWNrIGlmIGl0cyBhIG5ld2x5IGZvY3VzZWQgaXRlbVxcblxcdFxcdFxcdFxcdFxcdGlmICh0aGF0LmZvY3VzSW5kZXggIT0gbnVsbCAmJiBpdGVtLmluZGV4ICE9PSB0aGF0LmZvY3VzSW5kZXgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGF0Ll90cmlnZ2VyKFxcXCJmb2N1c1xcXCIsIGV2ZW50LCB7IGl0ZW06IGl0ZW0gfSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCF0aGF0LmlzT3Blbikge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoYXQuX3NlbGVjdChpdGVtLCBldmVudCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR0aGF0LmZvY3VzSW5kZXggPSBpdGVtLmluZGV4O1xcblxcblxcdFxcdFxcdFxcdFxcdHRoYXQuYnV0dG9uLmF0dHIoXFxcImFyaWEtYWN0aXZlZGVzY2VuZGFudFxcXCIsIHRoYXQubWVudUl0ZW1zLmVxKGl0ZW0uaW5kZXgpLmF0dHIoXFxcImlkXFxcIikpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9KS5tZW51KFxcXCJpbnN0YW5jZVxcXCIpO1xcblxcblxcdFxcdFxcdC8vIEFkanVzdCBtZW51IHN0eWxlcyB0byBkcm9wZG93blxcblxcdFxcdFxcdHRoaXMubWVudS5hZGRDbGFzcyhcXFwidWktY29ybmVyLWJvdHRvbVxcXCIpLnJlbW92ZUNsYXNzKFxcXCJ1aS1jb3JuZXItYWxsXFxcIik7XFxuXFxuXFx0XFx0XFx0Ly8gRG9uJ3QgY2xvc2UgdGhlIG1lbnUgb24gbW91c2VsZWF2ZVxcblxcdFxcdFxcdHRoaXMubWVudUluc3RhbmNlLl9vZmYodGhpcy5tZW51LCBcXFwibW91c2VsZWF2ZVxcXCIpO1xcblxcblxcdFxcdFxcdC8vIENhbmNlbCB0aGUgbWVudSdzIGNvbGxhcHNlQWxsIG9uIGRvY3VtZW50IGNsaWNrXFxuXFx0XFx0XFx0dGhpcy5tZW51SW5zdGFuY2UuX2Nsb3NlT25Eb2N1bWVudENsaWNrID0gZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdFxcdC8vIFNlbGVjdHMgb2Z0ZW4gY29udGFpbiBlbXB0eSBpdGVtcywgYnV0IG5ldmVyIGNvbnRhaW4gZGl2aWRlcnNcXG5cXHRcXHRcXHR0aGlzLm1lbnVJbnN0YW5jZS5faXNEaXZpZGVyID0gZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9O1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0cmVmcmVzaDogZnVuY3Rpb24gcmVmcmVzaCgpIHtcXG5cXHRcXHRcXHR0aGlzLl9yZWZyZXNoTWVudSgpO1xcblxcdFxcdFxcdHRoaXMuX3NldFRleHQodGhpcy5idXR0b25UZXh0LCB0aGlzLl9nZXRTZWxlY3RlZEl0ZW0oKS50ZXh0KCkpO1xcblxcdFxcdFxcdGlmICghdGhpcy5vcHRpb25zLndpZHRoKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5fcmVzaXplQnV0dG9uKCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFxuXFx0XFx0X3JlZnJlc2hNZW51OiBmdW5jdGlvbiBfcmVmcmVzaE1lbnUoKSB7XFxuXFx0XFx0XFx0dGhpcy5tZW51LmVtcHR5KCk7XFxuXFxuXFx0XFx0XFx0dmFyIGl0ZW0sXFxuXFx0XFx0XFx0ICAgIG9wdGlvbnMgPSB0aGlzLmVsZW1lbnQuZmluZChcXFwib3B0aW9uXFxcIik7XFxuXFxuXFx0XFx0XFx0aWYgKCFvcHRpb25zLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy5fcGFyc2VPcHRpb25zKG9wdGlvbnMpO1xcblxcdFxcdFxcdHRoaXMuX3JlbmRlck1lbnUodGhpcy5tZW51LCB0aGlzLml0ZW1zKTtcXG5cXG5cXHRcXHRcXHR0aGlzLm1lbnVJbnN0YW5jZS5yZWZyZXNoKCk7XFxuXFx0XFx0XFx0dGhpcy5tZW51SXRlbXMgPSB0aGlzLm1lbnUuZmluZChcXFwibGlcXFwiKS5ub3QoXFxcIi51aS1zZWxlY3RtZW51LW9wdGdyb3VwXFxcIik7XFxuXFxuXFx0XFx0XFx0aXRlbSA9IHRoaXMuX2dldFNlbGVjdGVkSXRlbSgpO1xcblxcblxcdFxcdFxcdC8vIFVwZGF0ZSB0aGUgbWVudSB0byBoYXZlIHRoZSBjb3JyZWN0IGl0ZW0gZm9jdXNlZFxcblxcdFxcdFxcdHRoaXMubWVudUluc3RhbmNlLmZvY3VzKG51bGwsIGl0ZW0pO1xcblxcdFxcdFxcdHRoaXMuX3NldEFyaWEoaXRlbS5kYXRhKFxcXCJ1aS1zZWxlY3RtZW51LWl0ZW1cXFwiKSk7XFxuXFxuXFx0XFx0XFx0Ly8gU2V0IGRpc2FibGVkIHN0YXRlXFxuXFx0XFx0XFx0dGhpcy5fc2V0T3B0aW9uKFxcXCJkaXNhYmxlZFxcXCIsIHRoaXMuZWxlbWVudC5wcm9wKFxcXCJkaXNhYmxlZFxcXCIpKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdG9wZW46IGZ1bmN0aW9uIG9wZW4oZXZlbnQpIHtcXG5cXHRcXHRcXHRpZiAodGhpcy5vcHRpb25zLmRpc2FibGVkKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBJZiB0aGlzIGlzIHRoZSBmaXJzdCB0aW1lIHRoZSBtZW51IGlzIGJlaW5nIG9wZW5lZCwgcmVuZGVyIHRoZSBpdGVtc1xcblxcdFxcdFxcdGlmICghdGhpcy5tZW51SXRlbXMpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9yZWZyZXNoTWVudSgpO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gTWVudSBjbGVhcnMgZm9jdXMgb24gY2xvc2UsIHJlc2V0IGZvY3VzIHRvIHNlbGVjdGVkIGl0ZW1cXG5cXHRcXHRcXHRcXHR0aGlzLm1lbnUuZmluZChcXFwiLnVpLXN0YXRlLWZvY3VzXFxcIikucmVtb3ZlQ2xhc3MoXFxcInVpLXN0YXRlLWZvY3VzXFxcIik7XFxuXFx0XFx0XFx0XFx0dGhpcy5tZW51SW5zdGFuY2UuZm9jdXMobnVsbCwgdGhpcy5fZ2V0U2VsZWN0ZWRJdGVtKCkpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLmlzT3BlbiA9IHRydWU7XFxuXFx0XFx0XFx0dGhpcy5fdG9nZ2xlQXR0cigpO1xcblxcdFxcdFxcdHRoaXMuX3Jlc2l6ZU1lbnUoKTtcXG5cXHRcXHRcXHR0aGlzLl9wb3NpdGlvbigpO1xcblxcblxcdFxcdFxcdHRoaXMuX29uKHRoaXMuZG9jdW1lbnQsIHRoaXMuX2RvY3VtZW50Q2xpY2spO1xcblxcblxcdFxcdFxcdHRoaXMuX3RyaWdnZXIoXFxcIm9wZW5cXFwiLCBldmVudCk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfcG9zaXRpb246IGZ1bmN0aW9uIF9wb3NpdGlvbigpIHtcXG5cXHRcXHRcXHR0aGlzLm1lbnVXcmFwLnBvc2l0aW9uKCQuZXh0ZW5kKHsgb2Y6IHRoaXMuYnV0dG9uIH0sIHRoaXMub3B0aW9ucy5wb3NpdGlvbikpO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y2xvc2U6IGZ1bmN0aW9uIGNsb3NlKGV2ZW50KSB7XFxuXFx0XFx0XFx0aWYgKCF0aGlzLmlzT3Blbikge1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy5pc09wZW4gPSBmYWxzZTtcXG5cXHRcXHRcXHR0aGlzLl90b2dnbGVBdHRyKCk7XFxuXFxuXFx0XFx0XFx0dGhpcy5yYW5nZSA9IG51bGw7XFxuXFx0XFx0XFx0dGhpcy5fb2ZmKHRoaXMuZG9jdW1lbnQpO1xcblxcblxcdFxcdFxcdHRoaXMuX3RyaWdnZXIoXFxcImNsb3NlXFxcIiwgZXZlbnQpO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0d2lkZ2V0OiBmdW5jdGlvbiB3aWRnZXQoKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuYnV0dG9uO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0bWVudVdpZGdldDogZnVuY3Rpb24gbWVudVdpZGdldCgpIHtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5tZW51O1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X3JlbmRlck1lbnU6IGZ1bmN0aW9uIF9yZW5kZXJNZW51KHVsLCBpdGVtcykge1xcblxcdFxcdFxcdHZhciB0aGF0ID0gdGhpcyxcXG5cXHRcXHRcXHQgICAgY3VycmVudE9wdGdyb3VwID0gXFxcIlxcXCI7XFxuXFxuXFx0XFx0XFx0JC5lYWNoKGl0ZW1zLCBmdW5jdGlvbiAoaW5kZXgsIGl0ZW0pIHtcXG5cXHRcXHRcXHRcXHRpZiAoaXRlbS5vcHRncm91cCAhPT0gY3VycmVudE9wdGdyb3VwKSB7XFxuXFx0XFx0XFx0XFx0XFx0JChcXFwiPGxpPlxcXCIsIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXFwiY2xhc3NcXFwiOiBcXFwidWktc2VsZWN0bWVudS1vcHRncm91cCB1aS1tZW51LWRpdmlkZXJcXFwiICsgKGl0ZW0uZWxlbWVudC5wYXJlbnQoXFxcIm9wdGdyb3VwXFxcIikucHJvcChcXFwiZGlzYWJsZWRcXFwiKSA/IFxcXCIgdWktc3RhdGUtZGlzYWJsZWRcXFwiIDogXFxcIlxcXCIpLFxcblxcdFxcdFxcdFxcdFxcdFxcdHRleHQ6IGl0ZW0ub3B0Z3JvdXBcXG5cXHRcXHRcXHRcXHRcXHR9KS5hcHBlbmRUbyh1bCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y3VycmVudE9wdGdyb3VwID0gaXRlbS5vcHRncm91cDtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0dGhhdC5fcmVuZGVySXRlbURhdGEodWwsIGl0ZW0pO1xcblxcdFxcdFxcdH0pO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X3JlbmRlckl0ZW1EYXRhOiBmdW5jdGlvbiBfcmVuZGVySXRlbURhdGEodWwsIGl0ZW0pIHtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5fcmVuZGVySXRlbSh1bCwgaXRlbSkuZGF0YShcXFwidWktc2VsZWN0bWVudS1pdGVtXFxcIiwgaXRlbSk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfcmVuZGVySXRlbTogZnVuY3Rpb24gX3JlbmRlckl0ZW0odWwsIGl0ZW0pIHtcXG5cXHRcXHRcXHR2YXIgbGkgPSAkKFxcXCI8bGk+XFxcIik7XFxuXFxuXFx0XFx0XFx0aWYgKGl0ZW0uZGlzYWJsZWQpIHtcXG5cXHRcXHRcXHRcXHRsaS5hZGRDbGFzcyhcXFwidWktc3RhdGUtZGlzYWJsZWRcXFwiKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0dGhpcy5fc2V0VGV4dChsaSwgaXRlbS5sYWJlbCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGxpLmFwcGVuZFRvKHVsKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9zZXRUZXh0OiBmdW5jdGlvbiBfc2V0VGV4dChlbGVtZW50LCB2YWx1ZSkge1xcblxcdFxcdFxcdGlmICh2YWx1ZSkge1xcblxcdFxcdFxcdFxcdGVsZW1lbnQudGV4dCh2YWx1ZSk7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRlbGVtZW50Lmh0bWwoXFxcIiYjMTYwO1xcXCIpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcblxcdFxcdF9tb3ZlOiBmdW5jdGlvbiBfbW92ZShkaXJlY3Rpb24sIGV2ZW50KSB7XFxuXFx0XFx0XFx0dmFyIGl0ZW0sXFxuXFx0XFx0XFx0ICAgIG5leHQsXFxuXFx0XFx0XFx0ICAgIGZpbHRlciA9IFxcXCIudWktbWVudS1pdGVtXFxcIjtcXG5cXG5cXHRcXHRcXHRpZiAodGhpcy5pc09wZW4pIHtcXG5cXHRcXHRcXHRcXHRpdGVtID0gdGhpcy5tZW51SXRlbXMuZXEodGhpcy5mb2N1c0luZGV4KTtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdGl0ZW0gPSB0aGlzLm1lbnVJdGVtcy5lcSh0aGlzLmVsZW1lbnRbMF0uc2VsZWN0ZWRJbmRleCk7XFxuXFx0XFx0XFx0XFx0ZmlsdGVyICs9IFxcXCI6bm90KC51aS1zdGF0ZS1kaXNhYmxlZClcXFwiO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoZGlyZWN0aW9uID09PSBcXFwiZmlyc3RcXFwiIHx8IGRpcmVjdGlvbiA9PT0gXFxcImxhc3RcXFwiKSB7XFxuXFx0XFx0XFx0XFx0bmV4dCA9IGl0ZW1bZGlyZWN0aW9uID09PSBcXFwiZmlyc3RcXFwiID8gXFxcInByZXZBbGxcXFwiIDogXFxcIm5leHRBbGxcXFwiXShmaWx0ZXIpLmVxKC0xKTtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdG5leHQgPSBpdGVtW2RpcmVjdGlvbiArIFxcXCJBbGxcXFwiXShmaWx0ZXIpLmVxKDApO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAobmV4dC5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLm1lbnVJbnN0YW5jZS5mb2N1cyhldmVudCwgbmV4dCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFxuXFx0XFx0X2dldFNlbGVjdGVkSXRlbTogZnVuY3Rpb24gX2dldFNlbGVjdGVkSXRlbSgpIHtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5tZW51SXRlbXMuZXEodGhpcy5lbGVtZW50WzBdLnNlbGVjdGVkSW5kZXgpO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X3RvZ2dsZTogZnVuY3Rpb24gX3RvZ2dsZShldmVudCkge1xcblxcdFxcdFxcdHRoaXNbdGhpcy5pc09wZW4gPyBcXFwiY2xvc2VcXFwiIDogXFxcIm9wZW5cXFwiXShldmVudCk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfc2V0U2VsZWN0aW9uOiBmdW5jdGlvbiBfc2V0U2VsZWN0aW9uKCkge1xcblxcdFxcdFxcdHZhciBzZWxlY3Rpb247XFxuXFxuXFx0XFx0XFx0aWYgKCF0aGlzLnJhbmdlKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAod2luZG93LmdldFNlbGVjdGlvbikge1xcblxcdFxcdFxcdFxcdHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcXG5cXHRcXHRcXHRcXHRzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XFxuXFx0XFx0XFx0XFx0c2VsZWN0aW9uLmFkZFJhbmdlKHRoaXMucmFuZ2UpO1xcblxcblxcdFxcdFxcdFxcdC8vIHN1cHBvcnQ6IElFOFxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5yYW5nZS5zZWxlY3QoKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gc3VwcG9ydDogSUVcXG5cXHRcXHRcXHQvLyBTZXR0aW5nIHRoZSB0ZXh0IHNlbGVjdGlvbiBraWxscyB0aGUgYnV0dG9uIGZvY3VzIGluIElFLCBidXRcXG5cXHRcXHRcXHQvLyByZXN0b3JpbmcgdGhlIGZvY3VzIGRvZXNuJ3Qga2lsbCB0aGUgc2VsZWN0aW9uLlxcblxcdFxcdFxcdHRoaXMuYnV0dG9uLmZvY3VzKCk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfZG9jdW1lbnRDbGljazoge1xcblxcdFxcdFxcdG1vdXNlZG93bjogZnVuY3Rpb24gbW91c2Vkb3duKGV2ZW50KSB7XFxuXFx0XFx0XFx0XFx0aWYgKCF0aGlzLmlzT3Blbikge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCEkKGV2ZW50LnRhcmdldCkuY2xvc2VzdChcXFwiLnVpLXNlbGVjdG1lbnUtbWVudSwgI1xcXCIgKyB0aGlzLmlkcy5idXR0b24pLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuY2xvc2UoZXZlbnQpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfYnV0dG9uRXZlbnRzOiB7XFxuXFxuXFx0XFx0XFx0Ly8gUHJldmVudCB0ZXh0IHNlbGVjdGlvbiBmcm9tIGJlaW5nIHJlc2V0IHdoZW4gaW50ZXJhY3Rpbmcgd2l0aCB0aGUgc2VsZWN0bWVudSAoIzEwMTQ0KVxcblxcdFxcdFxcdG1vdXNlZG93bjogZnVuY3Rpb24gbW91c2Vkb3duKCkge1xcblxcdFxcdFxcdFxcdHZhciBzZWxlY3Rpb247XFxuXFxuXFx0XFx0XFx0XFx0aWYgKHdpbmRvdy5nZXRTZWxlY3Rpb24pIHtcXG5cXHRcXHRcXHRcXHRcXHRzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHNlbGVjdGlvbi5yYW5nZUNvdW50KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5yYW5nZSA9IHNlbGVjdGlvbi5nZXRSYW5nZUF0KDApO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBzdXBwb3J0OiBJRThcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMucmFuZ2UgPSBkb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRjbGljazogZnVuY3Rpb24gY2xpY2soZXZlbnQpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9zZXRTZWxlY3Rpb24oKTtcXG5cXHRcXHRcXHRcXHR0aGlzLl90b2dnbGUoZXZlbnQpO1xcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0a2V5ZG93bjogZnVuY3Rpb24ga2V5ZG93bihldmVudCkge1xcblxcdFxcdFxcdFxcdHZhciBwcmV2ZW50RGVmYXVsdCA9IHRydWU7XFxuXFx0XFx0XFx0XFx0c3dpdGNoIChldmVudC5rZXlDb2RlKSB7XFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAkLnVpLmtleUNvZGUuVEFCOlxcblxcdFxcdFxcdFxcdFxcdGNhc2UgJC51aS5rZXlDb2RlLkVTQ0FQRTpcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLmNsb3NlKGV2ZW50KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRwcmV2ZW50RGVmYXVsdCA9IGZhbHNlO1xcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdGNhc2UgJC51aS5rZXlDb2RlLkVOVEVSOlxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICh0aGlzLmlzT3Blbikge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuX3NlbGVjdEZvY3VzZWRJdGVtKGV2ZW50KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAkLnVpLmtleUNvZGUuVVA6XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKGV2ZW50LmFsdEtleSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuX3RvZ2dsZShldmVudCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl9tb3ZlKFxcXCJwcmV2XFxcIiwgZXZlbnQpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRjYXNlICQudWkua2V5Q29kZS5ET1dOOlxcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChldmVudC5hbHRLZXkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl90b2dnbGUoZXZlbnQpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5fbW92ZShcXFwibmV4dFxcXCIsIGV2ZW50KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAkLnVpLmtleUNvZGUuU1BBQ0U6XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKHRoaXMuaXNPcGVuKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5fc2VsZWN0Rm9jdXNlZEl0ZW0oZXZlbnQpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5fdG9nZ2xlKGV2ZW50KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAkLnVpLmtleUNvZGUuTEVGVDpcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl9tb3ZlKFxcXCJwcmV2XFxcIiwgZXZlbnQpO1xcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdGNhc2UgJC51aS5rZXlDb2RlLlJJR0hUOlxcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuX21vdmUoXFxcIm5leHRcXFwiLCBldmVudCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAkLnVpLmtleUNvZGUuSE9NRTpcXG5cXHRcXHRcXHRcXHRcXHRjYXNlICQudWkua2V5Q29kZS5QQUdFX1VQOlxcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuX21vdmUoXFxcImZpcnN0XFxcIiwgZXZlbnQpO1xcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdGNhc2UgJC51aS5rZXlDb2RlLkVORDpcXG5cXHRcXHRcXHRcXHRcXHRjYXNlICQudWkua2V5Q29kZS5QQUdFX0RPV046XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5fbW92ZShcXFwibGFzdFxcXCIsIGV2ZW50KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRkZWZhdWx0OlxcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMubWVudS50cmlnZ2VyKGV2ZW50KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRwcmV2ZW50RGVmYXVsdCA9IGZhbHNlO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAocHJldmVudERlZmF1bHQpIHtcXG5cXHRcXHRcXHRcXHRcXHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfc2VsZWN0Rm9jdXNlZEl0ZW06IGZ1bmN0aW9uIF9zZWxlY3RGb2N1c2VkSXRlbShldmVudCkge1xcblxcdFxcdFxcdHZhciBpdGVtID0gdGhpcy5tZW51SXRlbXMuZXEodGhpcy5mb2N1c0luZGV4KTtcXG5cXHRcXHRcXHRpZiAoIWl0ZW0uaGFzQ2xhc3MoXFxcInVpLXN0YXRlLWRpc2FibGVkXFxcIikpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9zZWxlY3QoaXRlbS5kYXRhKFxcXCJ1aS1zZWxlY3RtZW51LWl0ZW1cXFwiKSwgZXZlbnQpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcblxcdFxcdF9zZWxlY3Q6IGZ1bmN0aW9uIF9zZWxlY3QoaXRlbSwgZXZlbnQpIHtcXG5cXHRcXHRcXHR2YXIgb2xkSW5kZXggPSB0aGlzLmVsZW1lbnRbMF0uc2VsZWN0ZWRJbmRleDtcXG5cXG5cXHRcXHRcXHQvLyBDaGFuZ2UgbmF0aXZlIHNlbGVjdCBlbGVtZW50XFxuXFx0XFx0XFx0dGhpcy5lbGVtZW50WzBdLnNlbGVjdGVkSW5kZXggPSBpdGVtLmluZGV4O1xcblxcdFxcdFxcdHRoaXMuX3NldFRleHQodGhpcy5idXR0b25UZXh0LCBpdGVtLmxhYmVsKTtcXG5cXHRcXHRcXHR0aGlzLl9zZXRBcmlhKGl0ZW0pO1xcblxcdFxcdFxcdHRoaXMuX3RyaWdnZXIoXFxcInNlbGVjdFxcXCIsIGV2ZW50LCB7IGl0ZW06IGl0ZW0gfSk7XFxuXFxuXFx0XFx0XFx0aWYgKGl0ZW0uaW5kZXggIT09IG9sZEluZGV4KSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5fdHJpZ2dlcihcXFwiY2hhbmdlXFxcIiwgZXZlbnQsIHsgaXRlbTogaXRlbSB9KTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy5jbG9zZShldmVudCk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfc2V0QXJpYTogZnVuY3Rpb24gX3NldEFyaWEoaXRlbSkge1xcblxcdFxcdFxcdHZhciBpZCA9IHRoaXMubWVudUl0ZW1zLmVxKGl0ZW0uaW5kZXgpLmF0dHIoXFxcImlkXFxcIik7XFxuXFxuXFx0XFx0XFx0dGhpcy5idXR0b24uYXR0cih7XFxuXFx0XFx0XFx0XFx0XFxcImFyaWEtbGFiZWxsZWRieVxcXCI6IGlkLFxcblxcdFxcdFxcdFxcdFxcXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcXFwiOiBpZFxcblxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdHRoaXMubWVudS5hdHRyKFxcXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcXFwiLCBpZCk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfc2V0T3B0aW9uOiBmdW5jdGlvbiBfc2V0T3B0aW9uKGtleSwgdmFsdWUpIHtcXG5cXHRcXHRcXHRpZiAoa2V5ID09PSBcXFwiaWNvbnNcXFwiKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5idXR0b24uZmluZChcXFwic3Bhbi51aS1pY29uXFxcIikucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmljb25zLmJ1dHRvbikuYWRkQ2xhc3ModmFsdWUuYnV0dG9uKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy5fc3VwZXIoa2V5LCB2YWx1ZSk7XFxuXFxuXFx0XFx0XFx0aWYgKGtleSA9PT0gXFxcImFwcGVuZFRvXFxcIikge1xcblxcdFxcdFxcdFxcdHRoaXMubWVudVdyYXAuYXBwZW5kVG8odGhpcy5fYXBwZW5kVG8oKSk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmIChrZXkgPT09IFxcXCJkaXNhYmxlZFxcXCIpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLm1lbnVJbnN0YW5jZS5vcHRpb24oXFxcImRpc2FibGVkXFxcIiwgdmFsdWUpO1xcblxcdFxcdFxcdFxcdHRoaXMuYnV0dG9uLnRvZ2dsZUNsYXNzKFxcXCJ1aS1zdGF0ZS1kaXNhYmxlZFxcXCIsIHZhbHVlKS5hdHRyKFxcXCJhcmlhLWRpc2FibGVkXFxcIiwgdmFsdWUpO1xcblxcblxcdFxcdFxcdFxcdHRoaXMuZWxlbWVudC5wcm9wKFxcXCJkaXNhYmxlZFxcXCIsIHZhbHVlKTtcXG5cXHRcXHRcXHRcXHRpZiAodmFsdWUpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmJ1dHRvbi5hdHRyKFxcXCJ0YWJpbmRleFxcXCIsIC0xKTtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmNsb3NlKCk7XFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmJ1dHRvbi5hdHRyKFxcXCJ0YWJpbmRleFxcXCIsIDApO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKGtleSA9PT0gXFxcIndpZHRoXFxcIikge1xcblxcdFxcdFxcdFxcdHRoaXMuX3Jlc2l6ZUJ1dHRvbigpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcblxcdFxcdF9hcHBlbmRUbzogZnVuY3Rpb24gX2FwcGVuZFRvKCkge1xcblxcdFxcdFxcdHZhciBlbGVtZW50ID0gdGhpcy5vcHRpb25zLmFwcGVuZFRvO1xcblxcblxcdFxcdFxcdGlmIChlbGVtZW50KSB7XFxuXFx0XFx0XFx0XFx0ZWxlbWVudCA9IGVsZW1lbnQuanF1ZXJ5IHx8IGVsZW1lbnQubm9kZVR5cGUgPyAkKGVsZW1lbnQpIDogdGhpcy5kb2N1bWVudC5maW5kKGVsZW1lbnQpLmVxKDApO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIWVsZW1lbnQgfHwgIWVsZW1lbnRbMF0pIHtcXG5cXHRcXHRcXHRcXHRlbGVtZW50ID0gdGhpcy5lbGVtZW50LmNsb3Nlc3QoXFxcIi51aS1mcm9udFxcXCIpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIWVsZW1lbnQubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0ZWxlbWVudCA9IHRoaXMuZG9jdW1lbnRbMF0uYm9keTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGVsZW1lbnQ7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfdG9nZ2xlQXR0cjogZnVuY3Rpb24gX3RvZ2dsZUF0dHIoKSB7XFxuXFx0XFx0XFx0dGhpcy5idXR0b24udG9nZ2xlQ2xhc3MoXFxcInVpLWNvcm5lci10b3BcXFwiLCB0aGlzLmlzT3BlbikudG9nZ2xlQ2xhc3MoXFxcInVpLWNvcm5lci1hbGxcXFwiLCAhdGhpcy5pc09wZW4pLmF0dHIoXFxcImFyaWEtZXhwYW5kZWRcXFwiLCB0aGlzLmlzT3Blbik7XFxuXFx0XFx0XFx0dGhpcy5tZW51V3JhcC50b2dnbGVDbGFzcyhcXFwidWktc2VsZWN0bWVudS1vcGVuXFxcIiwgdGhpcy5pc09wZW4pO1xcblxcdFxcdFxcdHRoaXMubWVudS5hdHRyKFxcXCJhcmlhLWhpZGRlblxcXCIsICF0aGlzLmlzT3Blbik7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfcmVzaXplQnV0dG9uOiBmdW5jdGlvbiBfcmVzaXplQnV0dG9uKCkge1xcblxcdFxcdFxcdHZhciB3aWR0aCA9IHRoaXMub3B0aW9ucy53aWR0aDtcXG5cXG5cXHRcXHRcXHRpZiAoIXdpZHRoKSB7XFxuXFx0XFx0XFx0XFx0d2lkdGggPSB0aGlzLmVsZW1lbnQuc2hvdygpLm91dGVyV2lkdGgoKTtcXG5cXHRcXHRcXHRcXHR0aGlzLmVsZW1lbnQuaGlkZSgpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLmJ1dHRvbi5vdXRlcldpZHRoKHdpZHRoKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9yZXNpemVNZW51OiBmdW5jdGlvbiBfcmVzaXplTWVudSgpIHtcXG5cXHRcXHRcXHR0aGlzLm1lbnUub3V0ZXJXaWR0aChNYXRoLm1heCh0aGlzLmJ1dHRvbi5vdXRlcldpZHRoKCksXFxuXFxuXFx0XFx0XFx0Ly8gc3VwcG9ydDogSUUxMFxcblxcdFxcdFxcdC8vIElFMTAgd3JhcHMgbG9uZyB0ZXh0IChwb3NzaWJseSBhIHJvdW5kaW5nIGJ1ZylcXG5cXHRcXHRcXHQvLyBzbyB3ZSBhZGQgMXB4IHRvIGF2b2lkIHRoZSB3cmFwcGluZ1xcblxcdFxcdFxcdHRoaXMubWVudS53aWR0aChcXFwiXFxcIikub3V0ZXJXaWR0aCgpICsgMSkpO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X2dldENyZWF0ZU9wdGlvbnM6IGZ1bmN0aW9uIF9nZXRDcmVhdGVPcHRpb25zKCkge1xcblxcdFxcdFxcdHJldHVybiB7IGRpc2FibGVkOiB0aGlzLmVsZW1lbnQucHJvcChcXFwiZGlzYWJsZWRcXFwiKSB9O1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X3BhcnNlT3B0aW9uczogZnVuY3Rpb24gX3BhcnNlT3B0aW9ucyhvcHRpb25zKSB7XFxuXFx0XFx0XFx0dmFyIGRhdGEgPSBbXTtcXG5cXHRcXHRcXHRvcHRpb25zLmVhY2goZnVuY3Rpb24gKGluZGV4LCBpdGVtKSB7XFxuXFx0XFx0XFx0XFx0dmFyIG9wdGlvbiA9ICQoaXRlbSksXFxuXFx0XFx0XFx0XFx0ICAgIG9wdGdyb3VwID0gb3B0aW9uLnBhcmVudChcXFwib3B0Z3JvdXBcXFwiKTtcXG5cXHRcXHRcXHRcXHRkYXRhLnB1c2goe1xcblxcdFxcdFxcdFxcdFxcdGVsZW1lbnQ6IG9wdGlvbixcXG5cXHRcXHRcXHRcXHRcXHRpbmRleDogaW5kZXgsXFxuXFx0XFx0XFx0XFx0XFx0dmFsdWU6IG9wdGlvbi52YWwoKSxcXG5cXHRcXHRcXHRcXHRcXHRsYWJlbDogb3B0aW9uLnRleHQoKSxcXG5cXHRcXHRcXHRcXHRcXHRvcHRncm91cDogb3B0Z3JvdXAuYXR0cihcXFwibGFiZWxcXFwiKSB8fCBcXFwiXFxcIixcXG5cXHRcXHRcXHRcXHRcXHRkaXNhYmxlZDogb3B0Z3JvdXAucHJvcChcXFwiZGlzYWJsZWRcXFwiKSB8fCBvcHRpb24ucHJvcChcXFwiZGlzYWJsZWRcXFwiKVxcblxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdHRoaXMuaXRlbXMgPSBkYXRhO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X2Rlc3Ryb3k6IGZ1bmN0aW9uIF9kZXN0cm95KCkge1xcblxcdFxcdFxcdHRoaXMubWVudVdyYXAucmVtb3ZlKCk7XFxuXFx0XFx0XFx0dGhpcy5idXR0b24ucmVtb3ZlKCk7XFxuXFx0XFx0XFx0dGhpcy5lbGVtZW50LnNob3coKTtcXG5cXHRcXHRcXHR0aGlzLmVsZW1lbnQucmVtb3ZlVW5pcXVlSWQoKTtcXG5cXHRcXHRcXHR0aGlzLmxhYmVsLmF0dHIoXFxcImZvclxcXCIsIHRoaXMuaWRzLmVsZW1lbnQpO1xcblxcdFxcdH1cXG5cXHR9KTtcXG5cXG5cXHQvKiFcXG4gICogalF1ZXJ5IFVJIFNsaWRlciAxLjExLjRcXG4gICogaHR0cDovL2pxdWVyeXVpLmNvbVxcbiAgKlxcbiAgKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xcbiAgKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXFxuICAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcXG4gICpcXG4gICogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20vc2xpZGVyL1xcbiAgKi9cXG5cXG5cXHR2YXIgc2xpZGVyID0gJC53aWRnZXQoXFxcInVpLnNsaWRlclxcXCIsICQudWkubW91c2UsIHtcXG5cXHRcXHR2ZXJzaW9uOiBcXFwiMS4xMS40XFxcIixcXG5cXHRcXHR3aWRnZXRFdmVudFByZWZpeDogXFxcInNsaWRlXFxcIixcXG5cXG5cXHRcXHRvcHRpb25zOiB7XFxuXFx0XFx0XFx0YW5pbWF0ZTogZmFsc2UsXFxuXFx0XFx0XFx0ZGlzdGFuY2U6IDAsXFxuXFx0XFx0XFx0bWF4OiAxMDAsXFxuXFx0XFx0XFx0bWluOiAwLFxcblxcdFxcdFxcdG9yaWVudGF0aW9uOiBcXFwiaG9yaXpvbnRhbFxcXCIsXFxuXFx0XFx0XFx0cmFuZ2U6IGZhbHNlLFxcblxcdFxcdFxcdHN0ZXA6IDEsXFxuXFx0XFx0XFx0dmFsdWU6IDAsXFxuXFx0XFx0XFx0dmFsdWVzOiBudWxsLFxcblxcblxcdFxcdFxcdC8vIGNhbGxiYWNrc1xcblxcdFxcdFxcdGNoYW5nZTogbnVsbCxcXG5cXHRcXHRcXHRzbGlkZTogbnVsbCxcXG5cXHRcXHRcXHRzdGFydDogbnVsbCxcXG5cXHRcXHRcXHRzdG9wOiBudWxsXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyBudW1iZXIgb2YgcGFnZXMgaW4gYSBzbGlkZXJcXG5cXHRcXHQvLyAoaG93IG1hbnkgdGltZXMgY2FuIHlvdSBwYWdlIHVwL2Rvd24gdG8gZ28gdGhyb3VnaCB0aGUgd2hvbGUgcmFuZ2UpXFxuXFx0XFx0bnVtUGFnZXM6IDUsXFxuXFxuXFx0XFx0X2NyZWF0ZTogZnVuY3Rpb24gX2NyZWF0ZSgpIHtcXG5cXHRcXHRcXHR0aGlzLl9rZXlTbGlkaW5nID0gZmFsc2U7XFxuXFx0XFx0XFx0dGhpcy5fbW91c2VTbGlkaW5nID0gZmFsc2U7XFxuXFx0XFx0XFx0dGhpcy5fYW5pbWF0ZU9mZiA9IHRydWU7XFxuXFx0XFx0XFx0dGhpcy5faGFuZGxlSW5kZXggPSBudWxsO1xcblxcdFxcdFxcdHRoaXMuX2RldGVjdE9yaWVudGF0aW9uKCk7XFxuXFx0XFx0XFx0dGhpcy5fbW91c2VJbml0KCk7XFxuXFx0XFx0XFx0dGhpcy5fY2FsY3VsYXRlTmV3TWF4KCk7XFxuXFxuXFx0XFx0XFx0dGhpcy5lbGVtZW50LmFkZENsYXNzKFxcXCJ1aS1zbGlkZXJcXFwiICsgXFxcIiB1aS1zbGlkZXItXFxcIiArIHRoaXMub3JpZW50YXRpb24gKyBcXFwiIHVpLXdpZGdldFxcXCIgKyBcXFwiIHVpLXdpZGdldC1jb250ZW50XFxcIiArIFxcXCIgdWktY29ybmVyLWFsbFxcXCIpO1xcblxcblxcdFxcdFxcdHRoaXMuX3JlZnJlc2goKTtcXG5cXHRcXHRcXHR0aGlzLl9zZXRPcHRpb24oXFxcImRpc2FibGVkXFxcIiwgdGhpcy5vcHRpb25zLmRpc2FibGVkKTtcXG5cXG5cXHRcXHRcXHR0aGlzLl9hbmltYXRlT2ZmID0gZmFsc2U7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfcmVmcmVzaDogZnVuY3Rpb24gX3JlZnJlc2goKSB7XFxuXFx0XFx0XFx0dGhpcy5fY3JlYXRlUmFuZ2UoKTtcXG5cXHRcXHRcXHR0aGlzLl9jcmVhdGVIYW5kbGVzKCk7XFxuXFx0XFx0XFx0dGhpcy5fc2V0dXBFdmVudHMoKTtcXG5cXHRcXHRcXHR0aGlzLl9yZWZyZXNoVmFsdWUoKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9jcmVhdGVIYW5kbGVzOiBmdW5jdGlvbiBfY3JlYXRlSGFuZGxlcygpIHtcXG5cXHRcXHRcXHR2YXIgaSxcXG5cXHRcXHRcXHQgICAgaGFuZGxlQ291bnQsXFxuXFx0XFx0XFx0ICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXFxuXFx0XFx0XFx0ICAgIGV4aXN0aW5nSGFuZGxlcyA9IHRoaXMuZWxlbWVudC5maW5kKFxcXCIudWktc2xpZGVyLWhhbmRsZVxcXCIpLmFkZENsYXNzKFxcXCJ1aS1zdGF0ZS1kZWZhdWx0IHVpLWNvcm5lci1hbGxcXFwiKSxcXG5cXHRcXHRcXHQgICAgaGFuZGxlID0gXFxcIjxzcGFuIGNsYXNzPSd1aS1zbGlkZXItaGFuZGxlIHVpLXN0YXRlLWRlZmF1bHQgdWktY29ybmVyLWFsbCcgdGFiaW5kZXg9JzAnPjwvc3Bhbj5cXFwiLFxcblxcdFxcdFxcdCAgICBoYW5kbGVzID0gW107XFxuXFxuXFx0XFx0XFx0aGFuZGxlQ291bnQgPSBvcHRpb25zLnZhbHVlcyAmJiBvcHRpb25zLnZhbHVlcy5sZW5ndGggfHwgMTtcXG5cXG5cXHRcXHRcXHRpZiAoZXhpc3RpbmdIYW5kbGVzLmxlbmd0aCA+IGhhbmRsZUNvdW50KSB7XFxuXFx0XFx0XFx0XFx0ZXhpc3RpbmdIYW5kbGVzLnNsaWNlKGhhbmRsZUNvdW50KS5yZW1vdmUoKTtcXG5cXHRcXHRcXHRcXHRleGlzdGluZ0hhbmRsZXMgPSBleGlzdGluZ0hhbmRsZXMuc2xpY2UoMCwgaGFuZGxlQ291bnQpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRmb3IgKGkgPSBleGlzdGluZ0hhbmRsZXMubGVuZ3RoOyBpIDwgaGFuZGxlQ291bnQ7IGkrKykge1xcblxcdFxcdFxcdFxcdGhhbmRsZXMucHVzaChoYW5kbGUpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLmhhbmRsZXMgPSBleGlzdGluZ0hhbmRsZXMuYWRkKCQoaGFuZGxlcy5qb2luKFxcXCJcXFwiKSkuYXBwZW5kVG8odGhpcy5lbGVtZW50KSk7XFxuXFxuXFx0XFx0XFx0dGhpcy5oYW5kbGUgPSB0aGlzLmhhbmRsZXMuZXEoMCk7XFxuXFxuXFx0XFx0XFx0dGhpcy5oYW5kbGVzLmVhY2goZnVuY3Rpb24gKGkpIHtcXG5cXHRcXHRcXHRcXHQkKHRoaXMpLmRhdGEoXFxcInVpLXNsaWRlci1oYW5kbGUtaW5kZXhcXFwiLCBpKTtcXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9jcmVhdGVSYW5nZTogZnVuY3Rpb24gX2NyZWF0ZVJhbmdlKCkge1xcblxcdFxcdFxcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxcblxcdFxcdFxcdCAgICBjbGFzc2VzID0gXFxcIlxcXCI7XFxuXFxuXFx0XFx0XFx0aWYgKG9wdGlvbnMucmFuZ2UpIHtcXG5cXHRcXHRcXHRcXHRpZiAob3B0aW9ucy5yYW5nZSA9PT0gdHJ1ZSkge1xcblxcdFxcdFxcdFxcdFxcdGlmICghb3B0aW9ucy52YWx1ZXMpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRvcHRpb25zLnZhbHVlcyA9IFt0aGlzLl92YWx1ZU1pbigpLCB0aGlzLl92YWx1ZU1pbigpXTtcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2UgaWYgKG9wdGlvbnMudmFsdWVzLmxlbmd0aCAmJiBvcHRpb25zLnZhbHVlcy5sZW5ndGggIT09IDIpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRvcHRpb25zLnZhbHVlcyA9IFtvcHRpb25zLnZhbHVlc1swXSwgb3B0aW9ucy52YWx1ZXNbMF1dO1xcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoJC5pc0FycmF5KG9wdGlvbnMudmFsdWVzKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdG9wdGlvbnMudmFsdWVzID0gb3B0aW9ucy52YWx1ZXMuc2xpY2UoMCk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAoIXRoaXMucmFuZ2UgfHwgIXRoaXMucmFuZ2UubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5yYW5nZSA9ICQoXFxcIjxkaXY+PC9kaXY+XFxcIikuYXBwZW5kVG8odGhpcy5lbGVtZW50KTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRjbGFzc2VzID0gXFxcInVpLXNsaWRlci1yYW5nZVxcXCIgK1xcblxcdFxcdFxcdFxcdFxcdC8vIG5vdGU6IHRoaXMgaXNuJ3QgdGhlIG1vc3QgZml0dGluZ2x5IHNlbWFudGljIGZyYW1ld29yayBjbGFzcyBmb3IgdGhpcyBlbGVtZW50LFxcblxcdFxcdFxcdFxcdFxcdC8vIGJ1dCB3b3JrZWQgYmVzdCB2aXN1YWxseSB3aXRoIGEgdmFyaWV0eSBvZiB0aGVtZXNcXG5cXHRcXHRcXHRcXHRcXHRcXFwiIHVpLXdpZGdldC1oZWFkZXIgdWktY29ybmVyLWFsbFxcXCI7XFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnJhbmdlLnJlbW92ZUNsYXNzKFxcXCJ1aS1zbGlkZXItcmFuZ2UtbWluIHVpLXNsaWRlci1yYW5nZS1tYXhcXFwiKVxcblxcdFxcdFxcdFxcdFxcdC8vIEhhbmRsZSByYW5nZSBzd2l0Y2hpbmcgZnJvbSB0cnVlIHRvIG1pbi9tYXhcXG5cXHRcXHRcXHRcXHRcXHQuY3NzKHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXFwibGVmdFxcXCI6IFxcXCJcXFwiLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcXCJib3R0b21cXFwiOiBcXFwiXFxcIlxcblxcdFxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR0aGlzLnJhbmdlLmFkZENsYXNzKGNsYXNzZXMgKyAob3B0aW9ucy5yYW5nZSA9PT0gXFxcIm1pblxcXCIgfHwgb3B0aW9ucy5yYW5nZSA9PT0gXFxcIm1heFxcXCIgPyBcXFwiIHVpLXNsaWRlci1yYW5nZS1cXFwiICsgb3B0aW9ucy5yYW5nZSA6IFxcXCJcXFwiKSk7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRpZiAodGhpcy5yYW5nZSkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMucmFuZ2UucmVtb3ZlKCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHRoaXMucmFuZ2UgPSBudWxsO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcblxcdFxcdF9zZXR1cEV2ZW50czogZnVuY3Rpb24gX3NldHVwRXZlbnRzKCkge1xcblxcdFxcdFxcdHRoaXMuX29mZih0aGlzLmhhbmRsZXMpO1xcblxcdFxcdFxcdHRoaXMuX29uKHRoaXMuaGFuZGxlcywgdGhpcy5faGFuZGxlRXZlbnRzKTtcXG5cXHRcXHRcXHR0aGlzLl9ob3ZlcmFibGUodGhpcy5oYW5kbGVzKTtcXG5cXHRcXHRcXHR0aGlzLl9mb2N1c2FibGUodGhpcy5oYW5kbGVzKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9kZXN0cm95OiBmdW5jdGlvbiBfZGVzdHJveSgpIHtcXG5cXHRcXHRcXHR0aGlzLmhhbmRsZXMucmVtb3ZlKCk7XFxuXFx0XFx0XFx0aWYgKHRoaXMucmFuZ2UpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLnJhbmdlLnJlbW92ZSgpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLmVsZW1lbnQucmVtb3ZlQ2xhc3MoXFxcInVpLXNsaWRlclxcXCIgKyBcXFwiIHVpLXNsaWRlci1ob3Jpem9udGFsXFxcIiArIFxcXCIgdWktc2xpZGVyLXZlcnRpY2FsXFxcIiArIFxcXCIgdWktd2lkZ2V0XFxcIiArIFxcXCIgdWktd2lkZ2V0LWNvbnRlbnRcXFwiICsgXFxcIiB1aS1jb3JuZXItYWxsXFxcIik7XFxuXFxuXFx0XFx0XFx0dGhpcy5fbW91c2VEZXN0cm95KCk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfbW91c2VDYXB0dXJlOiBmdW5jdGlvbiBfbW91c2VDYXB0dXJlKGV2ZW50KSB7XFxuXFx0XFx0XFx0dmFyIHBvc2l0aW9uLFxcblxcdFxcdFxcdCAgICBub3JtVmFsdWUsXFxuXFx0XFx0XFx0ICAgIGRpc3RhbmNlLFxcblxcdFxcdFxcdCAgICBjbG9zZXN0SGFuZGxlLFxcblxcdFxcdFxcdCAgICBpbmRleCxcXG5cXHRcXHRcXHQgICAgYWxsb3dlZCxcXG5cXHRcXHRcXHQgICAgb2Zmc2V0LFxcblxcdFxcdFxcdCAgICBtb3VzZU92ZXJIYW5kbGUsXFxuXFx0XFx0XFx0ICAgIHRoYXQgPSB0aGlzLFxcblxcdFxcdFxcdCAgICBvID0gdGhpcy5vcHRpb25zO1xcblxcblxcdFxcdFxcdGlmIChvLmRpc2FibGVkKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLmVsZW1lbnRTaXplID0ge1xcblxcdFxcdFxcdFxcdHdpZHRoOiB0aGlzLmVsZW1lbnQub3V0ZXJXaWR0aCgpLFxcblxcdFxcdFxcdFxcdGhlaWdodDogdGhpcy5lbGVtZW50Lm91dGVySGVpZ2h0KClcXG5cXHRcXHRcXHR9O1xcblxcdFxcdFxcdHRoaXMuZWxlbWVudE9mZnNldCA9IHRoaXMuZWxlbWVudC5vZmZzZXQoKTtcXG5cXG5cXHRcXHRcXHRwb3NpdGlvbiA9IHsgeDogZXZlbnQucGFnZVgsIHk6IGV2ZW50LnBhZ2VZIH07XFxuXFx0XFx0XFx0bm9ybVZhbHVlID0gdGhpcy5fbm9ybVZhbHVlRnJvbU1vdXNlKHBvc2l0aW9uKTtcXG5cXHRcXHRcXHRkaXN0YW5jZSA9IHRoaXMuX3ZhbHVlTWF4KCkgLSB0aGlzLl92YWx1ZU1pbigpICsgMTtcXG5cXHRcXHRcXHR0aGlzLmhhbmRsZXMuZWFjaChmdW5jdGlvbiAoaSkge1xcblxcdFxcdFxcdFxcdHZhciB0aGlzRGlzdGFuY2UgPSBNYXRoLmFicyhub3JtVmFsdWUgLSB0aGF0LnZhbHVlcyhpKSk7XFxuXFx0XFx0XFx0XFx0aWYgKGRpc3RhbmNlID4gdGhpc0Rpc3RhbmNlIHx8IGRpc3RhbmNlID09PSB0aGlzRGlzdGFuY2UgJiYgKGkgPT09IHRoYXQuX2xhc3RDaGFuZ2VkVmFsdWUgfHwgdGhhdC52YWx1ZXMoaSkgPT09IG8ubWluKSkge1xcblxcdFxcdFxcdFxcdFxcdGRpc3RhbmNlID0gdGhpc0Rpc3RhbmNlO1xcblxcdFxcdFxcdFxcdFxcdGNsb3Nlc3RIYW5kbGUgPSAkKHRoaXMpO1xcblxcdFxcdFxcdFxcdFxcdGluZGV4ID0gaTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSk7XFxuXFxuXFx0XFx0XFx0YWxsb3dlZCA9IHRoaXMuX3N0YXJ0KGV2ZW50LCBpbmRleCk7XFxuXFx0XFx0XFx0aWYgKGFsbG93ZWQgPT09IGZhbHNlKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR0aGlzLl9tb3VzZVNsaWRpbmcgPSB0cnVlO1xcblxcblxcdFxcdFxcdHRoaXMuX2hhbmRsZUluZGV4ID0gaW5kZXg7XFxuXFxuXFx0XFx0XFx0Y2xvc2VzdEhhbmRsZS5hZGRDbGFzcyhcXFwidWktc3RhdGUtYWN0aXZlXFxcIikuZm9jdXMoKTtcXG5cXG5cXHRcXHRcXHRvZmZzZXQgPSBjbG9zZXN0SGFuZGxlLm9mZnNldCgpO1xcblxcdFxcdFxcdG1vdXNlT3ZlckhhbmRsZSA9ICEkKGV2ZW50LnRhcmdldCkucGFyZW50cygpLmFkZEJhY2soKS5pcyhcXFwiLnVpLXNsaWRlci1oYW5kbGVcXFwiKTtcXG5cXHRcXHRcXHR0aGlzLl9jbGlja09mZnNldCA9IG1vdXNlT3ZlckhhbmRsZSA/IHsgbGVmdDogMCwgdG9wOiAwIH0gOiB7XFxuXFx0XFx0XFx0XFx0bGVmdDogZXZlbnQucGFnZVggLSBvZmZzZXQubGVmdCAtIGNsb3Nlc3RIYW5kbGUud2lkdGgoKSAvIDIsXFxuXFx0XFx0XFx0XFx0dG9wOiBldmVudC5wYWdlWSAtIG9mZnNldC50b3AgLSBjbG9zZXN0SGFuZGxlLmhlaWdodCgpIC8gMiAtIChwYXJzZUludChjbG9zZXN0SGFuZGxlLmNzcyhcXFwiYm9yZGVyVG9wV2lkdGhcXFwiKSwgMTApIHx8IDApIC0gKHBhcnNlSW50KGNsb3Nlc3RIYW5kbGUuY3NzKFxcXCJib3JkZXJCb3R0b21XaWR0aFxcXCIpLCAxMCkgfHwgMCkgKyAocGFyc2VJbnQoY2xvc2VzdEhhbmRsZS5jc3MoXFxcIm1hcmdpblRvcFxcXCIpLCAxMCkgfHwgMClcXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdFxcdGlmICghdGhpcy5oYW5kbGVzLmhhc0NsYXNzKFxcXCJ1aS1zdGF0ZS1ob3ZlclxcXCIpKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5fc2xpZGUoZXZlbnQsIGluZGV4LCBub3JtVmFsdWUpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR0aGlzLl9hbmltYXRlT2ZmID0gdHJ1ZTtcXG5cXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9tb3VzZVN0YXJ0OiBmdW5jdGlvbiBfbW91c2VTdGFydCgpIHtcXG5cXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9tb3VzZURyYWc6IGZ1bmN0aW9uIF9tb3VzZURyYWcoZXZlbnQpIHtcXG5cXHRcXHRcXHR2YXIgcG9zaXRpb24gPSB7IHg6IGV2ZW50LnBhZ2VYLCB5OiBldmVudC5wYWdlWSB9LFxcblxcdFxcdFxcdCAgICBub3JtVmFsdWUgPSB0aGlzLl9ub3JtVmFsdWVGcm9tTW91c2UocG9zaXRpb24pO1xcblxcblxcdFxcdFxcdHRoaXMuX3NsaWRlKGV2ZW50LCB0aGlzLl9oYW5kbGVJbmRleCwgbm9ybVZhbHVlKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfbW91c2VTdG9wOiBmdW5jdGlvbiBfbW91c2VTdG9wKGV2ZW50KSB7XFxuXFx0XFx0XFx0dGhpcy5oYW5kbGVzLnJlbW92ZUNsYXNzKFxcXCJ1aS1zdGF0ZS1hY3RpdmVcXFwiKTtcXG5cXHRcXHRcXHR0aGlzLl9tb3VzZVNsaWRpbmcgPSBmYWxzZTtcXG5cXG5cXHRcXHRcXHR0aGlzLl9zdG9wKGV2ZW50LCB0aGlzLl9oYW5kbGVJbmRleCk7XFxuXFx0XFx0XFx0dGhpcy5fY2hhbmdlKGV2ZW50LCB0aGlzLl9oYW5kbGVJbmRleCk7XFxuXFxuXFx0XFx0XFx0dGhpcy5faGFuZGxlSW5kZXggPSBudWxsO1xcblxcdFxcdFxcdHRoaXMuX2NsaWNrT2Zmc2V0ID0gbnVsbDtcXG5cXHRcXHRcXHR0aGlzLl9hbmltYXRlT2ZmID0gZmFsc2U7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X2RldGVjdE9yaWVudGF0aW9uOiBmdW5jdGlvbiBfZGV0ZWN0T3JpZW50YXRpb24oKSB7XFxuXFx0XFx0XFx0dGhpcy5vcmllbnRhdGlvbiA9IHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbiA9PT0gXFxcInZlcnRpY2FsXFxcIiA/IFxcXCJ2ZXJ0aWNhbFxcXCIgOiBcXFwiaG9yaXpvbnRhbFxcXCI7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfbm9ybVZhbHVlRnJvbU1vdXNlOiBmdW5jdGlvbiBfbm9ybVZhbHVlRnJvbU1vdXNlKHBvc2l0aW9uKSB7XFxuXFx0XFx0XFx0dmFyIHBpeGVsVG90YWwsIHBpeGVsTW91c2UsIHBlcmNlbnRNb3VzZSwgdmFsdWVUb3RhbCwgdmFsdWVNb3VzZTtcXG5cXG5cXHRcXHRcXHRpZiAodGhpcy5vcmllbnRhdGlvbiA9PT0gXFxcImhvcml6b250YWxcXFwiKSB7XFxuXFx0XFx0XFx0XFx0cGl4ZWxUb3RhbCA9IHRoaXMuZWxlbWVudFNpemUud2lkdGg7XFxuXFx0XFx0XFx0XFx0cGl4ZWxNb3VzZSA9IHBvc2l0aW9uLnggLSB0aGlzLmVsZW1lbnRPZmZzZXQubGVmdCAtICh0aGlzLl9jbGlja09mZnNldCA/IHRoaXMuX2NsaWNrT2Zmc2V0LmxlZnQgOiAwKTtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdHBpeGVsVG90YWwgPSB0aGlzLmVsZW1lbnRTaXplLmhlaWdodDtcXG5cXHRcXHRcXHRcXHRwaXhlbE1vdXNlID0gcG9zaXRpb24ueSAtIHRoaXMuZWxlbWVudE9mZnNldC50b3AgLSAodGhpcy5fY2xpY2tPZmZzZXQgPyB0aGlzLl9jbGlja09mZnNldC50b3AgOiAwKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cGVyY2VudE1vdXNlID0gcGl4ZWxNb3VzZSAvIHBpeGVsVG90YWw7XFxuXFx0XFx0XFx0aWYgKHBlcmNlbnRNb3VzZSA+IDEpIHtcXG5cXHRcXHRcXHRcXHRwZXJjZW50TW91c2UgPSAxO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAocGVyY2VudE1vdXNlIDwgMCkge1xcblxcdFxcdFxcdFxcdHBlcmNlbnRNb3VzZSA9IDA7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICh0aGlzLm9yaWVudGF0aW9uID09PSBcXFwidmVydGljYWxcXFwiKSB7XFxuXFx0XFx0XFx0XFx0cGVyY2VudE1vdXNlID0gMSAtIHBlcmNlbnRNb3VzZTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dmFsdWVUb3RhbCA9IHRoaXMuX3ZhbHVlTWF4KCkgLSB0aGlzLl92YWx1ZU1pbigpO1xcblxcdFxcdFxcdHZhbHVlTW91c2UgPSB0aGlzLl92YWx1ZU1pbigpICsgcGVyY2VudE1vdXNlICogdmFsdWVUb3RhbDtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5fdHJpbUFsaWduVmFsdWUodmFsdWVNb3VzZSk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfc3RhcnQ6IGZ1bmN0aW9uIF9zdGFydChldmVudCwgaW5kZXgpIHtcXG5cXHRcXHRcXHR2YXIgdWlIYXNoID0ge1xcblxcdFxcdFxcdFxcdGhhbmRsZTogdGhpcy5oYW5kbGVzW2luZGV4XSxcXG5cXHRcXHRcXHRcXHR2YWx1ZTogdGhpcy52YWx1ZSgpXFxuXFx0XFx0XFx0fTtcXG5cXHRcXHRcXHRpZiAodGhpcy5vcHRpb25zLnZhbHVlcyAmJiB0aGlzLm9wdGlvbnMudmFsdWVzLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdHVpSGFzaC52YWx1ZSA9IHRoaXMudmFsdWVzKGluZGV4KTtcXG5cXHRcXHRcXHRcXHR1aUhhc2gudmFsdWVzID0gdGhpcy52YWx1ZXMoKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuX3RyaWdnZXIoXFxcInN0YXJ0XFxcIiwgZXZlbnQsIHVpSGFzaCk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfc2xpZGU6IGZ1bmN0aW9uIF9zbGlkZShldmVudCwgaW5kZXgsIG5ld1ZhbCkge1xcblxcdFxcdFxcdHZhciBvdGhlclZhbCwgbmV3VmFsdWVzLCBhbGxvd2VkO1xcblxcblxcdFxcdFxcdGlmICh0aGlzLm9wdGlvbnMudmFsdWVzICYmIHRoaXMub3B0aW9ucy52YWx1ZXMubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0b3RoZXJWYWwgPSB0aGlzLnZhbHVlcyhpbmRleCA/IDAgOiAxKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAodGhpcy5vcHRpb25zLnZhbHVlcy5sZW5ndGggPT09IDIgJiYgdGhpcy5vcHRpb25zLnJhbmdlID09PSB0cnVlICYmIChpbmRleCA9PT0gMCAmJiBuZXdWYWwgPiBvdGhlclZhbCB8fCBpbmRleCA9PT0gMSAmJiBuZXdWYWwgPCBvdGhlclZhbCkpIHtcXG5cXHRcXHRcXHRcXHRcXHRuZXdWYWwgPSBvdGhlclZhbDtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKG5ld1ZhbCAhPT0gdGhpcy52YWx1ZXMoaW5kZXgpKSB7XFxuXFx0XFx0XFx0XFx0XFx0bmV3VmFsdWVzID0gdGhpcy52YWx1ZXMoKTtcXG5cXHRcXHRcXHRcXHRcXHRuZXdWYWx1ZXNbaW5kZXhdID0gbmV3VmFsO1xcblxcdFxcdFxcdFxcdFxcdC8vIEEgc2xpZGUgY2FuIGJlIGNhbmNlbGVkIGJ5IHJldHVybmluZyBmYWxzZSBmcm9tIHRoZSBzbGlkZSBjYWxsYmFja1xcblxcdFxcdFxcdFxcdFxcdGFsbG93ZWQgPSB0aGlzLl90cmlnZ2VyKFxcXCJzbGlkZVxcXCIsIGV2ZW50LCB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aGFuZGxlOiB0aGlzLmhhbmRsZXNbaW5kZXhdLFxcblxcdFxcdFxcdFxcdFxcdFxcdHZhbHVlOiBuZXdWYWwsXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFsdWVzOiBuZXdWYWx1ZXNcXG5cXHRcXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcXHRcXHRvdGhlclZhbCA9IHRoaXMudmFsdWVzKGluZGV4ID8gMCA6IDEpO1xcblxcdFxcdFxcdFxcdFxcdGlmIChhbGxvd2VkICE9PSBmYWxzZSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMudmFsdWVzKGluZGV4LCBuZXdWYWwpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRpZiAobmV3VmFsICE9PSB0aGlzLnZhbHVlKCkpIHtcXG5cXHRcXHRcXHRcXHRcXHQvLyBBIHNsaWRlIGNhbiBiZSBjYW5jZWxlZCBieSByZXR1cm5pbmcgZmFsc2UgZnJvbSB0aGUgc2xpZGUgY2FsbGJhY2tcXG5cXHRcXHRcXHRcXHRcXHRhbGxvd2VkID0gdGhpcy5fdHJpZ2dlcihcXFwic2xpZGVcXFwiLCBldmVudCwge1xcblxcdFxcdFxcdFxcdFxcdFxcdGhhbmRsZTogdGhpcy5oYW5kbGVzW2luZGV4XSxcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YWx1ZTogbmV3VmFsXFxuXFx0XFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGFsbG93ZWQgIT09IGZhbHNlKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy52YWx1ZShuZXdWYWwpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFxuXFx0XFx0X3N0b3A6IGZ1bmN0aW9uIF9zdG9wKGV2ZW50LCBpbmRleCkge1xcblxcdFxcdFxcdHZhciB1aUhhc2ggPSB7XFxuXFx0XFx0XFx0XFx0aGFuZGxlOiB0aGlzLmhhbmRsZXNbaW5kZXhdLFxcblxcdFxcdFxcdFxcdHZhbHVlOiB0aGlzLnZhbHVlKClcXG5cXHRcXHRcXHR9O1xcblxcdFxcdFxcdGlmICh0aGlzLm9wdGlvbnMudmFsdWVzICYmIHRoaXMub3B0aW9ucy52YWx1ZXMubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0dWlIYXNoLnZhbHVlID0gdGhpcy52YWx1ZXMoaW5kZXgpO1xcblxcdFxcdFxcdFxcdHVpSGFzaC52YWx1ZXMgPSB0aGlzLnZhbHVlcygpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLl90cmlnZ2VyKFxcXCJzdG9wXFxcIiwgZXZlbnQsIHVpSGFzaCk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfY2hhbmdlOiBmdW5jdGlvbiBfY2hhbmdlKGV2ZW50LCBpbmRleCkge1xcblxcdFxcdFxcdGlmICghdGhpcy5fa2V5U2xpZGluZyAmJiAhdGhpcy5fbW91c2VTbGlkaW5nKSB7XFxuXFx0XFx0XFx0XFx0dmFyIHVpSGFzaCA9IHtcXG5cXHRcXHRcXHRcXHRcXHRoYW5kbGU6IHRoaXMuaGFuZGxlc1tpbmRleF0sXFxuXFx0XFx0XFx0XFx0XFx0dmFsdWU6IHRoaXMudmFsdWUoKVxcblxcdFxcdFxcdFxcdH07XFxuXFx0XFx0XFx0XFx0aWYgKHRoaXMub3B0aW9ucy52YWx1ZXMgJiYgdGhpcy5vcHRpb25zLnZhbHVlcy5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRcXHR1aUhhc2gudmFsdWUgPSB0aGlzLnZhbHVlcyhpbmRleCk7XFxuXFx0XFx0XFx0XFx0XFx0dWlIYXNoLnZhbHVlcyA9IHRoaXMudmFsdWVzKCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vc3RvcmUgdGhlIGxhc3QgY2hhbmdlZCB2YWx1ZSBpbmRleCBmb3IgcmVmZXJlbmNlIHdoZW4gaGFuZGxlcyBvdmVybGFwXFxuXFx0XFx0XFx0XFx0dGhpcy5fbGFzdENoYW5nZWRWYWx1ZSA9IGluZGV4O1xcblxcblxcdFxcdFxcdFxcdHRoaXMuX3RyaWdnZXIoXFxcImNoYW5nZVxcXCIsIGV2ZW50LCB1aUhhc2gpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcblxcdFxcdHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShuZXdWYWx1ZSkge1xcblxcdFxcdFxcdGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5vcHRpb25zLnZhbHVlID0gdGhpcy5fdHJpbUFsaWduVmFsdWUobmV3VmFsdWUpO1xcblxcdFxcdFxcdFxcdHRoaXMuX3JlZnJlc2hWYWx1ZSgpO1xcblxcdFxcdFxcdFxcdHRoaXMuX2NoYW5nZShudWxsLCAwKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLl92YWx1ZSgpO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0dmFsdWVzOiBmdW5jdGlvbiB2YWx1ZXMoaW5kZXgsIG5ld1ZhbHVlKSB7XFxuXFx0XFx0XFx0dmFyIHZhbHMsIG5ld1ZhbHVlcywgaTtcXG5cXG5cXHRcXHRcXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLm9wdGlvbnMudmFsdWVzW2luZGV4XSA9IHRoaXMuX3RyaW1BbGlnblZhbHVlKG5ld1ZhbHVlKTtcXG5cXHRcXHRcXHRcXHR0aGlzLl9yZWZyZXNoVmFsdWUoKTtcXG5cXHRcXHRcXHRcXHR0aGlzLl9jaGFuZ2UobnVsbCwgaW5kZXgpO1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRpZiAoJC5pc0FycmF5KGFyZ3VtZW50c1swXSkpIHtcXG5cXHRcXHRcXHRcXHRcXHR2YWxzID0gdGhpcy5vcHRpb25zLnZhbHVlcztcXG5cXHRcXHRcXHRcXHRcXHRuZXdWYWx1ZXMgPSBhcmd1bWVudHNbMF07XFxuXFx0XFx0XFx0XFx0XFx0Zm9yIChpID0gMDsgaSA8IHZhbHMubGVuZ3RoOyBpICs9IDEpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YWxzW2ldID0gdGhpcy5fdHJpbUFsaWduVmFsdWUobmV3VmFsdWVzW2ldKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl9jaGFuZ2UobnVsbCwgaSk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdHRoaXMuX3JlZnJlc2hWYWx1ZSgpO1xcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHRoaXMub3B0aW9ucy52YWx1ZXMgJiYgdGhpcy5vcHRpb25zLnZhbHVlcy5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5fdmFsdWVzKGluZGV4KTtcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiB0aGlzLnZhbHVlKCk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLl92YWx1ZXMoKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfc2V0T3B0aW9uOiBmdW5jdGlvbiBfc2V0T3B0aW9uKGtleSwgdmFsdWUpIHtcXG5cXHRcXHRcXHR2YXIgaSxcXG5cXHRcXHRcXHQgICAgdmFsc0xlbmd0aCA9IDA7XFxuXFxuXFx0XFx0XFx0aWYgKGtleSA9PT0gXFxcInJhbmdlXFxcIiAmJiB0aGlzLm9wdGlvbnMucmFuZ2UgPT09IHRydWUpIHtcXG5cXHRcXHRcXHRcXHRpZiAodmFsdWUgPT09IFxcXCJtaW5cXFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5vcHRpb25zLnZhbHVlID0gdGhpcy5fdmFsdWVzKDApO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMub3B0aW9ucy52YWx1ZXMgPSBudWxsO1xcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAodmFsdWUgPT09IFxcXCJtYXhcXFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5vcHRpb25zLnZhbHVlID0gdGhpcy5fdmFsdWVzKHRoaXMub3B0aW9ucy52YWx1ZXMubGVuZ3RoIC0gMSk7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5vcHRpb25zLnZhbHVlcyA9IG51bGw7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoJC5pc0FycmF5KHRoaXMub3B0aW9ucy52YWx1ZXMpKSB7XFxuXFx0XFx0XFx0XFx0dmFsc0xlbmd0aCA9IHRoaXMub3B0aW9ucy52YWx1ZXMubGVuZ3RoO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoa2V5ID09PSBcXFwiZGlzYWJsZWRcXFwiKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5lbGVtZW50LnRvZ2dsZUNsYXNzKFxcXCJ1aS1zdGF0ZS1kaXNhYmxlZFxcXCIsICEhdmFsdWUpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLl9zdXBlcihrZXksIHZhbHVlKTtcXG5cXG5cXHRcXHRcXHRzd2l0Y2ggKGtleSkge1xcblxcdFxcdFxcdFxcdGNhc2UgXFxcIm9yaWVudGF0aW9uXFxcIjpcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9kZXRlY3RPcmllbnRhdGlvbigpO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuZWxlbWVudC5yZW1vdmVDbGFzcyhcXFwidWktc2xpZGVyLWhvcml6b250YWwgdWktc2xpZGVyLXZlcnRpY2FsXFxcIikuYWRkQ2xhc3MoXFxcInVpLXNsaWRlci1cXFwiICsgdGhpcy5vcmllbnRhdGlvbik7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fcmVmcmVzaFZhbHVlKCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gUmVzZXQgcG9zaXRpb25pbmcgZnJvbSBwcmV2aW91cyBvcmllbnRhdGlvblxcblxcdFxcdFxcdFxcdFxcdHRoaXMuaGFuZGxlcy5jc3ModmFsdWUgPT09IFxcXCJob3Jpem9udGFsXFxcIiA/IFxcXCJib3R0b21cXFwiIDogXFxcImxlZnRcXFwiLCBcXFwiXFxcIik7XFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0Y2FzZSBcXFwidmFsdWVcXFwiOlxcblxcdFxcdFxcdFxcdFxcdHRoaXMuX2FuaW1hdGVPZmYgPSB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX3JlZnJlc2hWYWx1ZSgpO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX2NoYW5nZShudWxsLCAwKTtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9hbmltYXRlT2ZmID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0Y2FzZSBcXFwidmFsdWVzXFxcIjpcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9hbmltYXRlT2ZmID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9yZWZyZXNoVmFsdWUoKTtcXG5cXHRcXHRcXHRcXHRcXHRmb3IgKGkgPSAwOyBpIDwgdmFsc0xlbmd0aDsgaSArPSAxKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5fY2hhbmdlKG51bGwsIGkpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9hbmltYXRlT2ZmID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0Y2FzZSBcXFwic3RlcFxcXCI6XFxuXFx0XFx0XFx0XFx0Y2FzZSBcXFwibWluXFxcIjpcXG5cXHRcXHRcXHRcXHRjYXNlIFxcXCJtYXhcXFwiOlxcblxcdFxcdFxcdFxcdFxcdHRoaXMuX2FuaW1hdGVPZmYgPSB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX2NhbGN1bGF0ZU5ld01heCgpO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX3JlZnJlc2hWYWx1ZSgpO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX2FuaW1hdGVPZmYgPSBmYWxzZTtcXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRjYXNlIFxcXCJyYW5nZVxcXCI6XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fYW5pbWF0ZU9mZiA9IHRydWU7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fcmVmcmVzaCgpO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX2FuaW1hdGVPZmYgPSBmYWxzZTtcXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvL2ludGVybmFsIHZhbHVlIGdldHRlclxcblxcdFxcdC8vIF92YWx1ZSgpIHJldHVybnMgdmFsdWUgdHJpbW1lZCBieSBtaW4gYW5kIG1heCwgYWxpZ25lZCBieSBzdGVwXFxuXFx0XFx0X3ZhbHVlOiBmdW5jdGlvbiBfdmFsdWUoKSB7XFxuXFx0XFx0XFx0dmFyIHZhbCA9IHRoaXMub3B0aW9ucy52YWx1ZTtcXG5cXHRcXHRcXHR2YWwgPSB0aGlzLl90cmltQWxpZ25WYWx1ZSh2YWwpO1xcblxcblxcdFxcdFxcdHJldHVybiB2YWw7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvL2ludGVybmFsIHZhbHVlcyBnZXR0ZXJcXG5cXHRcXHQvLyBfdmFsdWVzKCkgcmV0dXJucyBhcnJheSBvZiB2YWx1ZXMgdHJpbW1lZCBieSBtaW4gYW5kIG1heCwgYWxpZ25lZCBieSBzdGVwXFxuXFx0XFx0Ly8gX3ZhbHVlcyggaW5kZXggKSByZXR1cm5zIHNpbmdsZSB2YWx1ZSB0cmltbWVkIGJ5IG1pbiBhbmQgbWF4LCBhbGlnbmVkIGJ5IHN0ZXBcXG5cXHRcXHRfdmFsdWVzOiBmdW5jdGlvbiBfdmFsdWVzKGluZGV4KSB7XFxuXFx0XFx0XFx0dmFyIHZhbCwgdmFscywgaTtcXG5cXG5cXHRcXHRcXHRpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdHZhbCA9IHRoaXMub3B0aW9ucy52YWx1ZXNbaW5kZXhdO1xcblxcdFxcdFxcdFxcdHZhbCA9IHRoaXMuX3RyaW1BbGlnblZhbHVlKHZhbCk7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHZhbDtcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy52YWx1ZXMgJiYgdGhpcy5vcHRpb25zLnZhbHVlcy5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHQvLyAuc2xpY2UoKSBjcmVhdGVzIGEgY29weSBvZiB0aGUgYXJyYXlcXG5cXHRcXHRcXHRcXHQvLyB0aGlzIGNvcHkgZ2V0cyB0cmltbWVkIGJ5IG1pbiBhbmQgbWF4IGFuZCB0aGVuIHJldHVybmVkXFxuXFx0XFx0XFx0XFx0dmFscyA9IHRoaXMub3B0aW9ucy52YWx1ZXMuc2xpY2UoKTtcXG5cXHRcXHRcXHRcXHRmb3IgKGkgPSAwOyBpIDwgdmFscy5sZW5ndGg7IGkgKz0gMSkge1xcblxcdFxcdFxcdFxcdFxcdHZhbHNbaV0gPSB0aGlzLl90cmltQWxpZ25WYWx1ZSh2YWxzW2ldKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHZhbHM7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gW107XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Ly8gcmV0dXJucyB0aGUgc3RlcC1hbGlnbmVkIHZhbHVlIHRoYXQgdmFsIGlzIGNsb3Nlc3QgdG8sIGJldHdlZW4gKGluY2x1c2l2ZSkgbWluIGFuZCBtYXhcXG5cXHRcXHRfdHJpbUFsaWduVmFsdWU6IGZ1bmN0aW9uIF90cmltQWxpZ25WYWx1ZSh2YWwpIHtcXG5cXHRcXHRcXHRpZiAodmFsIDw9IHRoaXMuX3ZhbHVlTWluKCkpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5fdmFsdWVNaW4oKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKHZhbCA+PSB0aGlzLl92YWx1ZU1heCgpKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuX3ZhbHVlTWF4KCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHZhciBzdGVwID0gdGhpcy5vcHRpb25zLnN0ZXAgPiAwID8gdGhpcy5vcHRpb25zLnN0ZXAgOiAxLFxcblxcdFxcdFxcdCAgICB2YWxNb2RTdGVwID0gKHZhbCAtIHRoaXMuX3ZhbHVlTWluKCkpICUgc3RlcCxcXG5cXHRcXHRcXHQgICAgYWxpZ25WYWx1ZSA9IHZhbCAtIHZhbE1vZFN0ZXA7XFxuXFxuXFx0XFx0XFx0aWYgKE1hdGguYWJzKHZhbE1vZFN0ZXApICogMiA+PSBzdGVwKSB7XFxuXFx0XFx0XFx0XFx0YWxpZ25WYWx1ZSArPSB2YWxNb2RTdGVwID4gMCA/IHN0ZXAgOiAtc3RlcDtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gU2luY2UgSmF2YVNjcmlwdCBoYXMgcHJvYmxlbXMgd2l0aCBsYXJnZSBmbG9hdHMsIHJvdW5kXFxuXFx0XFx0XFx0Ly8gdGhlIGZpbmFsIHZhbHVlIHRvIDUgZGlnaXRzIGFmdGVyIHRoZSBkZWNpbWFsIHBvaW50IChzZWUgIzQxMjQpXFxuXFx0XFx0XFx0cmV0dXJuIHBhcnNlRmxvYXQoYWxpZ25WYWx1ZS50b0ZpeGVkKDUpKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9jYWxjdWxhdGVOZXdNYXg6IGZ1bmN0aW9uIF9jYWxjdWxhdGVOZXdNYXgoKSB7XFxuXFx0XFx0XFx0dmFyIG1heCA9IHRoaXMub3B0aW9ucy5tYXgsXFxuXFx0XFx0XFx0ICAgIG1pbiA9IHRoaXMuX3ZhbHVlTWluKCksXFxuXFx0XFx0XFx0ICAgIHN0ZXAgPSB0aGlzLm9wdGlvbnMuc3RlcCxcXG5cXHRcXHRcXHQgICAgYWJvdmVNaW4gPSBNYXRoLmZsb29yKCsobWF4IC0gbWluKS50b0ZpeGVkKHRoaXMuX3ByZWNpc2lvbigpKSAvIHN0ZXApICogc3RlcDtcXG5cXHRcXHRcXHRtYXggPSBhYm92ZU1pbiArIG1pbjtcXG5cXHRcXHRcXHR0aGlzLm1heCA9IHBhcnNlRmxvYXQobWF4LnRvRml4ZWQodGhpcy5fcHJlY2lzaW9uKCkpKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9wcmVjaXNpb246IGZ1bmN0aW9uIF9wcmVjaXNpb24oKSB7XFxuXFx0XFx0XFx0dmFyIHByZWNpc2lvbiA9IHRoaXMuX3ByZWNpc2lvbk9mKHRoaXMub3B0aW9ucy5zdGVwKTtcXG5cXHRcXHRcXHRpZiAodGhpcy5vcHRpb25zLm1pbiAhPT0gbnVsbCkge1xcblxcdFxcdFxcdFxcdHByZWNpc2lvbiA9IE1hdGgubWF4KHByZWNpc2lvbiwgdGhpcy5fcHJlY2lzaW9uT2YodGhpcy5vcHRpb25zLm1pbikpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gcHJlY2lzaW9uO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X3ByZWNpc2lvbk9mOiBmdW5jdGlvbiBfcHJlY2lzaW9uT2YobnVtKSB7XFxuXFx0XFx0XFx0dmFyIHN0ciA9IG51bS50b1N0cmluZygpLFxcblxcdFxcdFxcdCAgICBkZWNpbWFsID0gc3RyLmluZGV4T2YoXFxcIi5cXFwiKTtcXG5cXHRcXHRcXHRyZXR1cm4gZGVjaW1hbCA9PT0gLTEgPyAwIDogc3RyLmxlbmd0aCAtIGRlY2ltYWwgLSAxO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X3ZhbHVlTWluOiBmdW5jdGlvbiBfdmFsdWVNaW4oKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMub3B0aW9ucy5taW47XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfdmFsdWVNYXg6IGZ1bmN0aW9uIF92YWx1ZU1heCgpIHtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5tYXg7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfcmVmcmVzaFZhbHVlOiBmdW5jdGlvbiBfcmVmcmVzaFZhbHVlKCkge1xcblxcdFxcdFxcdHZhciBsYXN0VmFsUGVyY2VudCxcXG5cXHRcXHRcXHQgICAgdmFsUGVyY2VudCxcXG5cXHRcXHRcXHQgICAgdmFsdWUsXFxuXFx0XFx0XFx0ICAgIHZhbHVlTWluLFxcblxcdFxcdFxcdCAgICB2YWx1ZU1heCxcXG5cXHRcXHRcXHQgICAgb1JhbmdlID0gdGhpcy5vcHRpb25zLnJhbmdlLFxcblxcdFxcdFxcdCAgICBvID0gdGhpcy5vcHRpb25zLFxcblxcdFxcdFxcdCAgICB0aGF0ID0gdGhpcyxcXG5cXHRcXHRcXHQgICAgYW5pbWF0ZSA9ICF0aGlzLl9hbmltYXRlT2ZmID8gby5hbmltYXRlIDogZmFsc2UsXFxuXFx0XFx0XFx0ICAgIF9zZXQgPSB7fTtcXG5cXG5cXHRcXHRcXHRpZiAodGhpcy5vcHRpb25zLnZhbHVlcyAmJiB0aGlzLm9wdGlvbnMudmFsdWVzLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdHRoaXMuaGFuZGxlcy5lYWNoKGZ1bmN0aW9uIChpKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFsUGVyY2VudCA9ICh0aGF0LnZhbHVlcyhpKSAtIHRoYXQuX3ZhbHVlTWluKCkpIC8gKHRoYXQuX3ZhbHVlTWF4KCkgLSB0aGF0Ll92YWx1ZU1pbigpKSAqIDEwMDtcXG5cXHRcXHRcXHRcXHRcXHRfc2V0W3RoYXQub3JpZW50YXRpb24gPT09IFxcXCJob3Jpem9udGFsXFxcIiA/IFxcXCJsZWZ0XFxcIiA6IFxcXCJib3R0b21cXFwiXSA9IHZhbFBlcmNlbnQgKyBcXFwiJVxcXCI7XFxuXFx0XFx0XFx0XFx0XFx0JCh0aGlzKS5zdG9wKDEsIDEpW2FuaW1hdGUgPyBcXFwiYW5pbWF0ZVxcXCIgOiBcXFwiY3NzXFxcIl0oX3NldCwgby5hbmltYXRlKTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAodGhhdC5vcHRpb25zLnJhbmdlID09PSB0cnVlKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKHRoYXQub3JpZW50YXRpb24gPT09IFxcXCJob3Jpem9udGFsXFxcIikge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChpID09PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhhdC5yYW5nZS5zdG9wKDEsIDEpW2FuaW1hdGUgPyBcXFwiYW5pbWF0ZVxcXCIgOiBcXFwiY3NzXFxcIl0oeyBsZWZ0OiB2YWxQZXJjZW50ICsgXFxcIiVcXFwiIH0sIG8uYW5pbWF0ZSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChpID09PSAxKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhhdC5yYW5nZVthbmltYXRlID8gXFxcImFuaW1hdGVcXFwiIDogXFxcImNzc1xcXCJdKHsgd2lkdGg6IHZhbFBlcmNlbnQgLSBsYXN0VmFsUGVyY2VudCArIFxcXCIlXFxcIiB9LCB7IHF1ZXVlOiBmYWxzZSwgZHVyYXRpb246IG8uYW5pbWF0ZSB9KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoaSA9PT0gMCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoYXQucmFuZ2Uuc3RvcCgxLCAxKVthbmltYXRlID8gXFxcImFuaW1hdGVcXFwiIDogXFxcImNzc1xcXCJdKHsgYm90dG9tOiB2YWxQZXJjZW50ICsgXFxcIiVcXFwiIH0sIG8uYW5pbWF0ZSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmIChpID09PSAxKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhhdC5yYW5nZVthbmltYXRlID8gXFxcImFuaW1hdGVcXFwiIDogXFxcImNzc1xcXCJdKHsgaGVpZ2h0OiB2YWxQZXJjZW50IC0gbGFzdFZhbFBlcmNlbnQgKyBcXFwiJVxcXCIgfSwgeyBxdWV1ZTogZmFsc2UsIGR1cmF0aW9uOiBvLmFuaW1hdGUgfSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0bGFzdFZhbFBlcmNlbnQgPSB2YWxQZXJjZW50O1xcblxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0dmFsdWUgPSB0aGlzLnZhbHVlKCk7XFxuXFx0XFx0XFx0XFx0dmFsdWVNaW4gPSB0aGlzLl92YWx1ZU1pbigpO1xcblxcdFxcdFxcdFxcdHZhbHVlTWF4ID0gdGhpcy5fdmFsdWVNYXgoKTtcXG5cXHRcXHRcXHRcXHR2YWxQZXJjZW50ID0gdmFsdWVNYXggIT09IHZhbHVlTWluID8gKHZhbHVlIC0gdmFsdWVNaW4pIC8gKHZhbHVlTWF4IC0gdmFsdWVNaW4pICogMTAwIDogMDtcXG5cXHRcXHRcXHRcXHRfc2V0W3RoaXMub3JpZW50YXRpb24gPT09IFxcXCJob3Jpem9udGFsXFxcIiA/IFxcXCJsZWZ0XFxcIiA6IFxcXCJib3R0b21cXFwiXSA9IHZhbFBlcmNlbnQgKyBcXFwiJVxcXCI7XFxuXFx0XFx0XFx0XFx0dGhpcy5oYW5kbGUuc3RvcCgxLCAxKVthbmltYXRlID8gXFxcImFuaW1hdGVcXFwiIDogXFxcImNzc1xcXCJdKF9zZXQsIG8uYW5pbWF0ZSk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKG9SYW5nZSA9PT0gXFxcIm1pblxcXCIgJiYgdGhpcy5vcmllbnRhdGlvbiA9PT0gXFxcImhvcml6b250YWxcXFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5yYW5nZS5zdG9wKDEsIDEpW2FuaW1hdGUgPyBcXFwiYW5pbWF0ZVxcXCIgOiBcXFwiY3NzXFxcIl0oeyB3aWR0aDogdmFsUGVyY2VudCArIFxcXCIlXFxcIiB9LCBvLmFuaW1hdGUpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRpZiAob1JhbmdlID09PSBcXFwibWF4XFxcIiAmJiB0aGlzLm9yaWVudGF0aW9uID09PSBcXFwiaG9yaXpvbnRhbFxcXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnJhbmdlW2FuaW1hdGUgPyBcXFwiYW5pbWF0ZVxcXCIgOiBcXFwiY3NzXFxcIl0oeyB3aWR0aDogMTAwIC0gdmFsUGVyY2VudCArIFxcXCIlXFxcIiB9LCB7IHF1ZXVlOiBmYWxzZSwgZHVyYXRpb246IG8uYW5pbWF0ZSB9KTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aWYgKG9SYW5nZSA9PT0gXFxcIm1pblxcXCIgJiYgdGhpcy5vcmllbnRhdGlvbiA9PT0gXFxcInZlcnRpY2FsXFxcIikge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMucmFuZ2Uuc3RvcCgxLCAxKVthbmltYXRlID8gXFxcImFuaW1hdGVcXFwiIDogXFxcImNzc1xcXCJdKHsgaGVpZ2h0OiB2YWxQZXJjZW50ICsgXFxcIiVcXFwiIH0sIG8uYW5pbWF0ZSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGlmIChvUmFuZ2UgPT09IFxcXCJtYXhcXFwiICYmIHRoaXMub3JpZW50YXRpb24gPT09IFxcXCJ2ZXJ0aWNhbFxcXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnJhbmdlW2FuaW1hdGUgPyBcXFwiYW5pbWF0ZVxcXCIgOiBcXFwiY3NzXFxcIl0oeyBoZWlnaHQ6IDEwMCAtIHZhbFBlcmNlbnQgKyBcXFwiJVxcXCIgfSwgeyBxdWV1ZTogZmFsc2UsIGR1cmF0aW9uOiBvLmFuaW1hdGUgfSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcblxcdFxcdF9oYW5kbGVFdmVudHM6IHtcXG5cXHRcXHRcXHRrZXlkb3duOiBmdW5jdGlvbiBrZXlkb3duKGV2ZW50KSB7XFxuXFx0XFx0XFx0XFx0dmFyIGFsbG93ZWQsXFxuXFx0XFx0XFx0XFx0ICAgIGN1clZhbCxcXG5cXHRcXHRcXHRcXHQgICAgbmV3VmFsLFxcblxcdFxcdFxcdFxcdCAgICBzdGVwLFxcblxcdFxcdFxcdFxcdCAgICBpbmRleCA9ICQoZXZlbnQudGFyZ2V0KS5kYXRhKFxcXCJ1aS1zbGlkZXItaGFuZGxlLWluZGV4XFxcIik7XFxuXFxuXFx0XFx0XFx0XFx0c3dpdGNoIChldmVudC5rZXlDb2RlKSB7XFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAkLnVpLmtleUNvZGUuSE9NRTpcXG5cXHRcXHRcXHRcXHRcXHRjYXNlICQudWkua2V5Q29kZS5FTkQ6XFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAkLnVpLmtleUNvZGUuUEFHRV9VUDpcXG5cXHRcXHRcXHRcXHRcXHRjYXNlICQudWkua2V5Q29kZS5QQUdFX0RPV046XFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAkLnVpLmtleUNvZGUuVVA6XFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAkLnVpLmtleUNvZGUuUklHSFQ6XFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAkLnVpLmtleUNvZGUuRE9XTjpcXG5cXHRcXHRcXHRcXHRcXHRjYXNlICQudWkua2V5Q29kZS5MRUZUOlxcblxcdFxcdFxcdFxcdFxcdFxcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCF0aGlzLl9rZXlTbGlkaW5nKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5fa2V5U2xpZGluZyA9IHRydWU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0JChldmVudC50YXJnZXQpLmFkZENsYXNzKFxcXCJ1aS1zdGF0ZS1hY3RpdmVcXFwiKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRhbGxvd2VkID0gdGhpcy5fc3RhcnQoZXZlbnQsIGluZGV4KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoYWxsb3dlZCA9PT0gZmFsc2UpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0c3RlcCA9IHRoaXMub3B0aW9ucy5zdGVwO1xcblxcdFxcdFxcdFxcdGlmICh0aGlzLm9wdGlvbnMudmFsdWVzICYmIHRoaXMub3B0aW9ucy52YWx1ZXMubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0Y3VyVmFsID0gbmV3VmFsID0gdGhpcy52YWx1ZXMoaW5kZXgpO1xcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0Y3VyVmFsID0gbmV3VmFsID0gdGhpcy52YWx1ZSgpO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRzd2l0Y2ggKGV2ZW50LmtleUNvZGUpIHtcXG5cXHRcXHRcXHRcXHRcXHRjYXNlICQudWkua2V5Q29kZS5IT01FOlxcblxcdFxcdFxcdFxcdFxcdFxcdG5ld1ZhbCA9IHRoaXMuX3ZhbHVlTWluKCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAkLnVpLmtleUNvZGUuRU5EOlxcblxcdFxcdFxcdFxcdFxcdFxcdG5ld1ZhbCA9IHRoaXMuX3ZhbHVlTWF4KCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAkLnVpLmtleUNvZGUuUEFHRV9VUDpcXG5cXHRcXHRcXHRcXHRcXHRcXHRuZXdWYWwgPSB0aGlzLl90cmltQWxpZ25WYWx1ZShjdXJWYWwgKyAodGhpcy5fdmFsdWVNYXgoKSAtIHRoaXMuX3ZhbHVlTWluKCkpIC8gdGhpcy5udW1QYWdlcyk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAkLnVpLmtleUNvZGUuUEFHRV9ET1dOOlxcblxcdFxcdFxcdFxcdFxcdFxcdG5ld1ZhbCA9IHRoaXMuX3RyaW1BbGlnblZhbHVlKGN1clZhbCAtICh0aGlzLl92YWx1ZU1heCgpIC0gdGhpcy5fdmFsdWVNaW4oKSkgLyB0aGlzLm51bVBhZ2VzKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRjYXNlICQudWkua2V5Q29kZS5VUDpcXG5cXHRcXHRcXHRcXHRcXHRjYXNlICQudWkua2V5Q29kZS5SSUdIVDpcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoY3VyVmFsID09PSB0aGlzLl92YWx1ZU1heCgpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRuZXdWYWwgPSB0aGlzLl90cmltQWxpZ25WYWx1ZShjdXJWYWwgKyBzdGVwKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRjYXNlICQudWkua2V5Q29kZS5ET1dOOlxcblxcdFxcdFxcdFxcdFxcdGNhc2UgJC51aS5rZXlDb2RlLkxFRlQ6XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKGN1clZhbCA9PT0gdGhpcy5fdmFsdWVNaW4oKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0bmV3VmFsID0gdGhpcy5fdHJpbUFsaWduVmFsdWUoY3VyVmFsIC0gc3RlcCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHRoaXMuX3NsaWRlKGV2ZW50LCBpbmRleCwgbmV3VmFsKTtcXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdGtleXVwOiBmdW5jdGlvbiBrZXl1cChldmVudCkge1xcblxcdFxcdFxcdFxcdHZhciBpbmRleCA9ICQoZXZlbnQudGFyZ2V0KS5kYXRhKFxcXCJ1aS1zbGlkZXItaGFuZGxlLWluZGV4XFxcIik7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKHRoaXMuX2tleVNsaWRpbmcpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9rZXlTbGlkaW5nID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fc3RvcChldmVudCwgaW5kZXgpO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX2NoYW5nZShldmVudCwgaW5kZXgpO1xcblxcdFxcdFxcdFxcdFxcdCQoZXZlbnQudGFyZ2V0KS5yZW1vdmVDbGFzcyhcXFwidWktc3RhdGUtYWN0aXZlXFxcIik7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fSk7XFxuXFxuXFx0LyohXFxuICAqIGpRdWVyeSBVSSBTb3J0YWJsZSAxLjExLjRcXG4gICogaHR0cDovL2pxdWVyeXVpLmNvbVxcbiAgKlxcbiAgKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xcbiAgKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXFxuICAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcXG4gICpcXG4gICogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20vc29ydGFibGUvXFxuICAqL1xcblxcblxcdHZhciBzb3J0YWJsZSA9ICQud2lkZ2V0KFxcXCJ1aS5zb3J0YWJsZVxcXCIsICQudWkubW91c2UsIHtcXG5cXHRcXHR2ZXJzaW9uOiBcXFwiMS4xMS40XFxcIixcXG5cXHRcXHR3aWRnZXRFdmVudFByZWZpeDogXFxcInNvcnRcXFwiLFxcblxcdFxcdHJlYWR5OiBmYWxzZSxcXG5cXHRcXHRvcHRpb25zOiB7XFxuXFx0XFx0XFx0YXBwZW5kVG86IFxcXCJwYXJlbnRcXFwiLFxcblxcdFxcdFxcdGF4aXM6IGZhbHNlLFxcblxcdFxcdFxcdGNvbm5lY3RXaXRoOiBmYWxzZSxcXG5cXHRcXHRcXHRjb250YWlubWVudDogZmFsc2UsXFxuXFx0XFx0XFx0Y3Vyc29yOiBcXFwiYXV0b1xcXCIsXFxuXFx0XFx0XFx0Y3Vyc29yQXQ6IGZhbHNlLFxcblxcdFxcdFxcdGRyb3BPbkVtcHR5OiB0cnVlLFxcblxcdFxcdFxcdGZvcmNlUGxhY2Vob2xkZXJTaXplOiBmYWxzZSxcXG5cXHRcXHRcXHRmb3JjZUhlbHBlclNpemU6IGZhbHNlLFxcblxcdFxcdFxcdGdyaWQ6IGZhbHNlLFxcblxcdFxcdFxcdGhhbmRsZTogZmFsc2UsXFxuXFx0XFx0XFx0aGVscGVyOiBcXFwib3JpZ2luYWxcXFwiLFxcblxcdFxcdFxcdGl0ZW1zOiBcXFwiPiAqXFxcIixcXG5cXHRcXHRcXHRvcGFjaXR5OiBmYWxzZSxcXG5cXHRcXHRcXHRwbGFjZWhvbGRlcjogZmFsc2UsXFxuXFx0XFx0XFx0cmV2ZXJ0OiBmYWxzZSxcXG5cXHRcXHRcXHRzY3JvbGw6IHRydWUsXFxuXFx0XFx0XFx0c2Nyb2xsU2Vuc2l0aXZpdHk6IDIwLFxcblxcdFxcdFxcdHNjcm9sbFNwZWVkOiAyMCxcXG5cXHRcXHRcXHRzY29wZTogXFxcImRlZmF1bHRcXFwiLFxcblxcdFxcdFxcdHRvbGVyYW5jZTogXFxcImludGVyc2VjdFxcXCIsXFxuXFx0XFx0XFx0ekluZGV4OiAxMDAwLFxcblxcblxcdFxcdFxcdC8vIGNhbGxiYWNrc1xcblxcdFxcdFxcdGFjdGl2YXRlOiBudWxsLFxcblxcdFxcdFxcdGJlZm9yZVN0b3A6IG51bGwsXFxuXFx0XFx0XFx0Y2hhbmdlOiBudWxsLFxcblxcdFxcdFxcdGRlYWN0aXZhdGU6IG51bGwsXFxuXFx0XFx0XFx0b3V0OiBudWxsLFxcblxcdFxcdFxcdG92ZXI6IG51bGwsXFxuXFx0XFx0XFx0cmVjZWl2ZTogbnVsbCxcXG5cXHRcXHRcXHRyZW1vdmU6IG51bGwsXFxuXFx0XFx0XFx0c29ydDogbnVsbCxcXG5cXHRcXHRcXHRzdGFydDogbnVsbCxcXG5cXHRcXHRcXHRzdG9wOiBudWxsLFxcblxcdFxcdFxcdHVwZGF0ZTogbnVsbFxcblxcdFxcdH0sXFxuXFxuXFx0XFx0X2lzT3ZlckF4aXM6IGZ1bmN0aW9uIF9pc092ZXJBeGlzKHgsIHJlZmVyZW5jZSwgc2l6ZSkge1xcblxcdFxcdFxcdHJldHVybiB4ID49IHJlZmVyZW5jZSAmJiB4IDwgcmVmZXJlbmNlICsgc2l6ZTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9pc0Zsb2F0aW5nOiBmdW5jdGlvbiBfaXNGbG9hdGluZyhpdGVtKSB7XFxuXFx0XFx0XFx0cmV0dXJuICgvbGVmdHxyaWdodC8udGVzdChpdGVtLmNzcyhcXFwiZmxvYXRcXFwiKSkgfHwgL2lubGluZXx0YWJsZS1jZWxsLy50ZXN0KGl0ZW0uY3NzKFxcXCJkaXNwbGF5XFxcIikpXFxuXFx0XFx0XFx0KTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9jcmVhdGU6IGZ1bmN0aW9uIF9jcmVhdGUoKSB7XFxuXFx0XFx0XFx0dGhpcy5jb250YWluZXJDYWNoZSA9IHt9O1xcblxcdFxcdFxcdHRoaXMuZWxlbWVudC5hZGRDbGFzcyhcXFwidWktc29ydGFibGVcXFwiKTtcXG5cXG5cXHRcXHRcXHQvL0dldCB0aGUgaXRlbXNcXG5cXHRcXHRcXHR0aGlzLnJlZnJlc2goKTtcXG5cXG5cXHRcXHRcXHQvL0xldCdzIGRldGVybWluZSB0aGUgcGFyZW50J3Mgb2Zmc2V0XFxuXFx0XFx0XFx0dGhpcy5vZmZzZXQgPSB0aGlzLmVsZW1lbnQub2Zmc2V0KCk7XFxuXFxuXFx0XFx0XFx0Ly9Jbml0aWFsaXplIG1vdXNlIGV2ZW50cyBmb3IgaW50ZXJhY3Rpb25cXG5cXHRcXHRcXHR0aGlzLl9tb3VzZUluaXQoKTtcXG5cXG5cXHRcXHRcXHR0aGlzLl9zZXRIYW5kbGVDbGFzc05hbWUoKTtcXG5cXG5cXHRcXHRcXHQvL1dlJ3JlIHJlYWR5IHRvIGdvXFxuXFx0XFx0XFx0dGhpcy5yZWFkeSA9IHRydWU7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfc2V0T3B0aW9uOiBmdW5jdGlvbiBfc2V0T3B0aW9uKGtleSwgdmFsdWUpIHtcXG5cXHRcXHRcXHR0aGlzLl9zdXBlcihrZXksIHZhbHVlKTtcXG5cXG5cXHRcXHRcXHRpZiAoa2V5ID09PSBcXFwiaGFuZGxlXFxcIikge1xcblxcdFxcdFxcdFxcdHRoaXMuX3NldEhhbmRsZUNsYXNzTmFtZSgpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcblxcdFxcdF9zZXRIYW5kbGVDbGFzc05hbWU6IGZ1bmN0aW9uIF9zZXRIYW5kbGVDbGFzc05hbWUoKSB7XFxuXFx0XFx0XFx0dGhpcy5lbGVtZW50LmZpbmQoXFxcIi51aS1zb3J0YWJsZS1oYW5kbGVcXFwiKS5yZW1vdmVDbGFzcyhcXFwidWktc29ydGFibGUtaGFuZGxlXFxcIik7XFxuXFx0XFx0XFx0JC5lYWNoKHRoaXMuaXRlbXMsIGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHQodGhpcy5pbnN0YW5jZS5vcHRpb25zLmhhbmRsZSA/IHRoaXMuaXRlbS5maW5kKHRoaXMuaW5zdGFuY2Uub3B0aW9ucy5oYW5kbGUpIDogdGhpcy5pdGVtKS5hZGRDbGFzcyhcXFwidWktc29ydGFibGUtaGFuZGxlXFxcIik7XFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfZGVzdHJveTogZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XFxuXFx0XFx0XFx0dGhpcy5lbGVtZW50LnJlbW92ZUNsYXNzKFxcXCJ1aS1zb3J0YWJsZSB1aS1zb3J0YWJsZS1kaXNhYmxlZFxcXCIpLmZpbmQoXFxcIi51aS1zb3J0YWJsZS1oYW5kbGVcXFwiKS5yZW1vdmVDbGFzcyhcXFwidWktc29ydGFibGUtaGFuZGxlXFxcIik7XFxuXFx0XFx0XFx0dGhpcy5fbW91c2VEZXN0cm95KCk7XFxuXFxuXFx0XFx0XFx0Zm9yICh2YXIgaSA9IHRoaXMuaXRlbXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcXG5cXHRcXHRcXHRcXHR0aGlzLml0ZW1zW2ldLml0ZW0ucmVtb3ZlRGF0YSh0aGlzLndpZGdldE5hbWUgKyBcXFwiLWl0ZW1cXFwiKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfbW91c2VDYXB0dXJlOiBmdW5jdGlvbiBfbW91c2VDYXB0dXJlKGV2ZW50LCBvdmVycmlkZUhhbmRsZSkge1xcblxcdFxcdFxcdHZhciBjdXJyZW50SXRlbSA9IG51bGwsXFxuXFx0XFx0XFx0ICAgIHZhbGlkSGFuZGxlID0gZmFsc2UsXFxuXFx0XFx0XFx0ICAgIHRoYXQgPSB0aGlzO1xcblxcblxcdFxcdFxcdGlmICh0aGlzLnJldmVydGluZykge1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKHRoaXMub3B0aW9ucy5kaXNhYmxlZCB8fCB0aGlzLm9wdGlvbnMudHlwZSA9PT0gXFxcInN0YXRpY1xcXCIpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vV2UgaGF2ZSB0byByZWZyZXNoIHRoZSBpdGVtcyBkYXRhIG9uY2UgZmlyc3RcXG5cXHRcXHRcXHR0aGlzLl9yZWZyZXNoSXRlbXMoZXZlbnQpO1xcblxcblxcdFxcdFxcdC8vRmluZCBvdXQgaWYgdGhlIGNsaWNrZWQgbm9kZSAob3Igb25lIG9mIGl0cyBwYXJlbnRzKSBpcyBhIGFjdHVhbCBpdGVtIGluIHRoaXMuaXRlbXNcXG5cXHRcXHRcXHQkKGV2ZW50LnRhcmdldCkucGFyZW50cygpLmVhY2goZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdGlmICgkLmRhdGEodGhpcywgdGhhdC53aWRnZXROYW1lICsgXFxcIi1pdGVtXFxcIikgPT09IHRoYXQpIHtcXG5cXHRcXHRcXHRcXHRcXHRjdXJyZW50SXRlbSA9ICQodGhpcyk7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRpZiAoJC5kYXRhKGV2ZW50LnRhcmdldCwgdGhhdC53aWRnZXROYW1lICsgXFxcIi1pdGVtXFxcIikgPT09IHRoYXQpIHtcXG5cXHRcXHRcXHRcXHRjdXJyZW50SXRlbSA9ICQoZXZlbnQudGFyZ2V0KTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCFjdXJyZW50SXRlbSkge1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKHRoaXMub3B0aW9ucy5oYW5kbGUgJiYgIW92ZXJyaWRlSGFuZGxlKSB7XFxuXFx0XFx0XFx0XFx0JCh0aGlzLm9wdGlvbnMuaGFuZGxlLCBjdXJyZW50SXRlbSkuZmluZChcXFwiKlxcXCIpLmFkZEJhY2soKS5lYWNoKGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAodGhpcyA9PT0gZXZlbnQudGFyZ2V0KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFsaWRIYW5kbGUgPSB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcXHRpZiAoIXZhbGlkSGFuZGxlKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy5jdXJyZW50SXRlbSA9IGN1cnJlbnRJdGVtO1xcblxcdFxcdFxcdHRoaXMuX3JlbW92ZUN1cnJlbnRzRnJvbUl0ZW1zKCk7XFxuXFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfbW91c2VTdGFydDogZnVuY3Rpb24gX21vdXNlU3RhcnQoZXZlbnQsIG92ZXJyaWRlSGFuZGxlLCBub0FjdGl2YXRpb24pIHtcXG5cXG5cXHRcXHRcXHR2YXIgaSxcXG5cXHRcXHRcXHQgICAgYm9keSxcXG5cXHRcXHRcXHQgICAgbyA9IHRoaXMub3B0aW9ucztcXG5cXG5cXHRcXHRcXHR0aGlzLmN1cnJlbnRDb250YWluZXIgPSB0aGlzO1xcblxcblxcdFxcdFxcdC8vV2Ugb25seSBuZWVkIHRvIGNhbGwgcmVmcmVzaFBvc2l0aW9ucywgYmVjYXVzZSB0aGUgcmVmcmVzaEl0ZW1zIGNhbGwgaGFzIGJlZW4gbW92ZWQgdG8gbW91c2VDYXB0dXJlXFxuXFx0XFx0XFx0dGhpcy5yZWZyZXNoUG9zaXRpb25zKCk7XFxuXFxuXFx0XFx0XFx0Ly9DcmVhdGUgYW5kIGFwcGVuZCB0aGUgdmlzaWJsZSBoZWxwZXJcXG5cXHRcXHRcXHR0aGlzLmhlbHBlciA9IHRoaXMuX2NyZWF0ZUhlbHBlcihldmVudCk7XFxuXFxuXFx0XFx0XFx0Ly9DYWNoZSB0aGUgaGVscGVyIHNpemVcXG5cXHRcXHRcXHR0aGlzLl9jYWNoZUhlbHBlclByb3BvcnRpb25zKCk7XFxuXFxuXFx0XFx0XFx0LypcXG4gICAgKiAtIFBvc2l0aW9uIGdlbmVyYXRpb24gLVxcbiAgICAqIFRoaXMgYmxvY2sgZ2VuZXJhdGVzIGV2ZXJ5dGhpbmcgcG9zaXRpb24gcmVsYXRlZCAtIGl0J3MgdGhlIGNvcmUgb2YgZHJhZ2dhYmxlcy5cXG4gICAgKi9cXG5cXG5cXHRcXHRcXHQvL0NhY2hlIHRoZSBtYXJnaW5zIG9mIHRoZSBvcmlnaW5hbCBlbGVtZW50XFxuXFx0XFx0XFx0dGhpcy5fY2FjaGVNYXJnaW5zKCk7XFxuXFxuXFx0XFx0XFx0Ly9HZXQgdGhlIG5leHQgc2Nyb2xsaW5nIHBhcmVudFxcblxcdFxcdFxcdHRoaXMuc2Nyb2xsUGFyZW50ID0gdGhpcy5oZWxwZXIuc2Nyb2xsUGFyZW50KCk7XFxuXFxuXFx0XFx0XFx0Ly9UaGUgZWxlbWVudCdzIGFic29sdXRlIHBvc2l0aW9uIG9uIHRoZSBwYWdlIG1pbnVzIG1hcmdpbnNcXG5cXHRcXHRcXHR0aGlzLm9mZnNldCA9IHRoaXMuY3VycmVudEl0ZW0ub2Zmc2V0KCk7XFxuXFx0XFx0XFx0dGhpcy5vZmZzZXQgPSB7XFxuXFx0XFx0XFx0XFx0dG9wOiB0aGlzLm9mZnNldC50b3AgLSB0aGlzLm1hcmdpbnMudG9wLFxcblxcdFxcdFxcdFxcdGxlZnQ6IHRoaXMub2Zmc2V0LmxlZnQgLSB0aGlzLm1hcmdpbnMubGVmdFxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0XFx0JC5leHRlbmQodGhpcy5vZmZzZXQsIHtcXG5cXHRcXHRcXHRcXHRjbGljazogeyAvL1doZXJlIHRoZSBjbGljayBoYXBwZW5lZCwgcmVsYXRpdmUgdG8gdGhlIGVsZW1lbnRcXG5cXHRcXHRcXHRcXHRcXHRsZWZ0OiBldmVudC5wYWdlWCAtIHRoaXMub2Zmc2V0LmxlZnQsXFxuXFx0XFx0XFx0XFx0XFx0dG9wOiBldmVudC5wYWdlWSAtIHRoaXMub2Zmc2V0LnRvcFxcblxcdFxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0XFx0cGFyZW50OiB0aGlzLl9nZXRQYXJlbnRPZmZzZXQoKSxcXG5cXHRcXHRcXHRcXHRyZWxhdGl2ZTogdGhpcy5fZ2V0UmVsYXRpdmVPZmZzZXQoKSAvL1RoaXMgaXMgYSByZWxhdGl2ZSB0byBhYnNvbHV0ZSBwb3NpdGlvbiBtaW51cyB0aGUgYWN0dWFsIHBvc2l0aW9uIGNhbGN1bGF0aW9uIC0gb25seSB1c2VkIGZvciByZWxhdGl2ZSBwb3NpdGlvbmVkIGhlbHBlclxcblxcdFxcdFxcdH0pO1xcblxcblxcdFxcdFxcdC8vIE9ubHkgYWZ0ZXIgd2UgZ290IHRoZSBvZmZzZXQsIHdlIGNhbiBjaGFuZ2UgdGhlIGhlbHBlcidzIHBvc2l0aW9uIHRvIGFic29sdXRlXFxuXFx0XFx0XFx0Ly8gVE9ETzogU3RpbGwgbmVlZCB0byBmaWd1cmUgb3V0IGEgd2F5IHRvIG1ha2UgcmVsYXRpdmUgc29ydGluZyBwb3NzaWJsZVxcblxcdFxcdFxcdHRoaXMuaGVscGVyLmNzcyhcXFwicG9zaXRpb25cXFwiLCBcXFwiYWJzb2x1dGVcXFwiKTtcXG5cXHRcXHRcXHR0aGlzLmNzc1Bvc2l0aW9uID0gdGhpcy5oZWxwZXIuY3NzKFxcXCJwb3NpdGlvblxcXCIpO1xcblxcblxcdFxcdFxcdC8vR2VuZXJhdGUgdGhlIG9yaWdpbmFsIHBvc2l0aW9uXFxuXFx0XFx0XFx0dGhpcy5vcmlnaW5hbFBvc2l0aW9uID0gdGhpcy5fZ2VuZXJhdGVQb3NpdGlvbihldmVudCk7XFxuXFx0XFx0XFx0dGhpcy5vcmlnaW5hbFBhZ2VYID0gZXZlbnQucGFnZVg7XFxuXFx0XFx0XFx0dGhpcy5vcmlnaW5hbFBhZ2VZID0gZXZlbnQucGFnZVk7XFxuXFxuXFx0XFx0XFx0Ly9BZGp1c3QgdGhlIG1vdXNlIG9mZnNldCByZWxhdGl2ZSB0byB0aGUgaGVscGVyIGlmIFxcXCJjdXJzb3JBdFxcXCIgaXMgc3VwcGxpZWRcXG5cXHRcXHRcXHRvLmN1cnNvckF0ICYmIHRoaXMuX2FkanVzdE9mZnNldEZyb21IZWxwZXIoby5jdXJzb3JBdCk7XFxuXFxuXFx0XFx0XFx0Ly9DYWNoZSB0aGUgZm9ybWVyIERPTSBwb3NpdGlvblxcblxcdFxcdFxcdHRoaXMuZG9tUG9zaXRpb24gPSB7IHByZXY6IHRoaXMuY3VycmVudEl0ZW0ucHJldigpWzBdLCBwYXJlbnQ6IHRoaXMuY3VycmVudEl0ZW0ucGFyZW50KClbMF0gfTtcXG5cXG5cXHRcXHRcXHQvL0lmIHRoZSBoZWxwZXIgaXMgbm90IHRoZSBvcmlnaW5hbCwgaGlkZSB0aGUgb3JpZ2luYWwgc28gaXQncyBub3QgcGxheWluZyBhbnkgcm9sZSBkdXJpbmcgdGhlIGRyYWcsIHdvbid0IGNhdXNlIGFueXRoaW5nIGJhZCB0aGlzIHdheVxcblxcdFxcdFxcdGlmICh0aGlzLmhlbHBlclswXSAhPT0gdGhpcy5jdXJyZW50SXRlbVswXSkge1xcblxcdFxcdFxcdFxcdHRoaXMuY3VycmVudEl0ZW0uaGlkZSgpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvL0NyZWF0ZSB0aGUgcGxhY2Vob2xkZXJcXG5cXHRcXHRcXHR0aGlzLl9jcmVhdGVQbGFjZWhvbGRlcigpO1xcblxcblxcdFxcdFxcdC8vU2V0IGEgY29udGFpbm1lbnQgaWYgZ2l2ZW4gaW4gdGhlIG9wdGlvbnNcXG5cXHRcXHRcXHRpZiAoby5jb250YWlubWVudCkge1xcblxcdFxcdFxcdFxcdHRoaXMuX3NldENvbnRhaW5tZW50KCk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmIChvLmN1cnNvciAmJiBvLmN1cnNvciAhPT0gXFxcImF1dG9cXFwiKSB7XFxuXFx0XFx0XFx0XFx0Ly8gY3Vyc29yIG9wdGlvblxcblxcdFxcdFxcdFxcdGJvZHkgPSB0aGlzLmRvY3VtZW50LmZpbmQoXFxcImJvZHlcXFwiKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBzdXBwb3J0OiBJRVxcblxcdFxcdFxcdFxcdHRoaXMuc3RvcmVkQ3Vyc29yID0gYm9keS5jc3MoXFxcImN1cnNvclxcXCIpO1xcblxcdFxcdFxcdFxcdGJvZHkuY3NzKFxcXCJjdXJzb3JcXFwiLCBvLmN1cnNvcik7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5zdG9yZWRTdHlsZXNoZWV0ID0gJChcXFwiPHN0eWxlPip7IGN1cnNvcjogXFxcIiArIG8uY3Vyc29yICsgXFxcIiAhaW1wb3J0YW50OyB9PC9zdHlsZT5cXFwiKS5hcHBlbmRUbyhib2R5KTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKG8ub3BhY2l0eSkge1xcblxcdFxcdFxcdFxcdC8vIG9wYWNpdHkgb3B0aW9uXFxuXFx0XFx0XFx0XFx0aWYgKHRoaXMuaGVscGVyLmNzcyhcXFwib3BhY2l0eVxcXCIpKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fc3RvcmVkT3BhY2l0eSA9IHRoaXMuaGVscGVyLmNzcyhcXFwib3BhY2l0eVxcXCIpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR0aGlzLmhlbHBlci5jc3MoXFxcIm9wYWNpdHlcXFwiLCBvLm9wYWNpdHkpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoby56SW5kZXgpIHtcXG5cXHRcXHRcXHRcXHQvLyB6SW5kZXggb3B0aW9uXFxuXFx0XFx0XFx0XFx0aWYgKHRoaXMuaGVscGVyLmNzcyhcXFwiekluZGV4XFxcIikpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9zdG9yZWRaSW5kZXggPSB0aGlzLmhlbHBlci5jc3MoXFxcInpJbmRleFxcXCIpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR0aGlzLmhlbHBlci5jc3MoXFxcInpJbmRleFxcXCIsIG8uekluZGV4KTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly9QcmVwYXJlIHNjcm9sbGluZ1xcblxcdFxcdFxcdGlmICh0aGlzLnNjcm9sbFBhcmVudFswXSAhPT0gdGhpcy5kb2N1bWVudFswXSAmJiB0aGlzLnNjcm9sbFBhcmVudFswXS50YWdOYW1lICE9PSBcXFwiSFRNTFxcXCIpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLm92ZXJmbG93T2Zmc2V0ID0gdGhpcy5zY3JvbGxQYXJlbnQub2Zmc2V0KCk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vQ2FsbCBjYWxsYmFja3NcXG5cXHRcXHRcXHR0aGlzLl90cmlnZ2VyKFxcXCJzdGFydFxcXCIsIGV2ZW50LCB0aGlzLl91aUhhc2goKSk7XFxuXFxuXFx0XFx0XFx0Ly9SZWNhY2hlIHRoZSBoZWxwZXIgc2l6ZVxcblxcdFxcdFxcdGlmICghdGhpcy5fcHJlc2VydmVIZWxwZXJQcm9wb3J0aW9ucykge1xcblxcdFxcdFxcdFxcdHRoaXMuX2NhY2hlSGVscGVyUHJvcG9ydGlvbnMoKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly9Qb3N0IFxcXCJhY3RpdmF0ZVxcXCIgZXZlbnRzIHRvIHBvc3NpYmxlIGNvbnRhaW5lcnNcXG5cXHRcXHRcXHRpZiAoIW5vQWN0aXZhdGlvbikge1xcblxcdFxcdFxcdFxcdGZvciAoaSA9IHRoaXMuY29udGFpbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuY29udGFpbmVyc1tpXS5fdHJpZ2dlcihcXFwiYWN0aXZhdGVcXFwiLCBldmVudCwgdGhpcy5fdWlIYXNoKHRoaXMpKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vUHJlcGFyZSBwb3NzaWJsZSBkcm9wcGFibGVzXFxuXFx0XFx0XFx0aWYgKCQudWkuZGRtYW5hZ2VyKSB7XFxuXFx0XFx0XFx0XFx0JC51aS5kZG1hbmFnZXIuY3VycmVudCA9IHRoaXM7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICgkLnVpLmRkbWFuYWdlciAmJiAhby5kcm9wQmVoYXZpb3VyKSB7XFxuXFx0XFx0XFx0XFx0JC51aS5kZG1hbmFnZXIucHJlcGFyZU9mZnNldHModGhpcywgZXZlbnQpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLmRyYWdnaW5nID0gdHJ1ZTtcXG5cXG5cXHRcXHRcXHR0aGlzLmhlbHBlci5hZGRDbGFzcyhcXFwidWktc29ydGFibGUtaGVscGVyXFxcIik7XFxuXFx0XFx0XFx0dGhpcy5fbW91c2VEcmFnKGV2ZW50KTsgLy9FeGVjdXRlIHRoZSBkcmFnIG9uY2UgLSB0aGlzIGNhdXNlcyB0aGUgaGVscGVyIG5vdCB0byBiZSB2aXNpYmxlIGJlZm9yZSBnZXR0aW5nIGl0cyBjb3JyZWN0IHBvc2l0aW9uXFxuXFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfbW91c2VEcmFnOiBmdW5jdGlvbiBfbW91c2VEcmFnKGV2ZW50KSB7XFxuXFx0XFx0XFx0dmFyIGksXFxuXFx0XFx0XFx0ICAgIGl0ZW0sXFxuXFx0XFx0XFx0ICAgIGl0ZW1FbGVtZW50LFxcblxcdFxcdFxcdCAgICBpbnRlcnNlY3Rpb24sXFxuXFx0XFx0XFx0ICAgIG8gPSB0aGlzLm9wdGlvbnMsXFxuXFx0XFx0XFx0ICAgIHNjcm9sbGVkID0gZmFsc2U7XFxuXFxuXFx0XFx0XFx0Ly9Db21wdXRlIHRoZSBoZWxwZXJzIHBvc2l0aW9uXFxuXFx0XFx0XFx0dGhpcy5wb3NpdGlvbiA9IHRoaXMuX2dlbmVyYXRlUG9zaXRpb24oZXZlbnQpO1xcblxcdFxcdFxcdHRoaXMucG9zaXRpb25BYnMgPSB0aGlzLl9jb252ZXJ0UG9zaXRpb25UbyhcXFwiYWJzb2x1dGVcXFwiKTtcXG5cXG5cXHRcXHRcXHRpZiAoIXRoaXMubGFzdFBvc2l0aW9uQWJzKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5sYXN0UG9zaXRpb25BYnMgPSB0aGlzLnBvc2l0aW9uQWJzO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvL0RvIHNjcm9sbGluZ1xcblxcdFxcdFxcdGlmICh0aGlzLm9wdGlvbnMuc2Nyb2xsKSB7XFxuXFx0XFx0XFx0XFx0aWYgKHRoaXMuc2Nyb2xsUGFyZW50WzBdICE9PSB0aGlzLmRvY3VtZW50WzBdICYmIHRoaXMuc2Nyb2xsUGFyZW50WzBdLnRhZ05hbWUgIT09IFxcXCJIVE1MXFxcIikge1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICh0aGlzLm92ZXJmbG93T2Zmc2V0LnRvcCArIHRoaXMuc2Nyb2xsUGFyZW50WzBdLm9mZnNldEhlaWdodCAtIGV2ZW50LnBhZ2VZIDwgby5zY3JvbGxTZW5zaXRpdml0eSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuc2Nyb2xsUGFyZW50WzBdLnNjcm9sbFRvcCA9IHNjcm9sbGVkID0gdGhpcy5zY3JvbGxQYXJlbnRbMF0uc2Nyb2xsVG9wICsgby5zY3JvbGxTcGVlZDtcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2UgaWYgKGV2ZW50LnBhZ2VZIC0gdGhpcy5vdmVyZmxvd09mZnNldC50b3AgPCBvLnNjcm9sbFNlbnNpdGl2aXR5KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5zY3JvbGxQYXJlbnRbMF0uc2Nyb2xsVG9wID0gc2Nyb2xsZWQgPSB0aGlzLnNjcm9sbFBhcmVudFswXS5zY3JvbGxUb3AgLSBvLnNjcm9sbFNwZWVkO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAodGhpcy5vdmVyZmxvd09mZnNldC5sZWZ0ICsgdGhpcy5zY3JvbGxQYXJlbnRbMF0ub2Zmc2V0V2lkdGggLSBldmVudC5wYWdlWCA8IG8uc2Nyb2xsU2Vuc2l0aXZpdHkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLnNjcm9sbFBhcmVudFswXS5zY3JvbGxMZWZ0ID0gc2Nyb2xsZWQgPSB0aGlzLnNjcm9sbFBhcmVudFswXS5zY3JvbGxMZWZ0ICsgby5zY3JvbGxTcGVlZDtcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2UgaWYgKGV2ZW50LnBhZ2VYIC0gdGhpcy5vdmVyZmxvd09mZnNldC5sZWZ0IDwgby5zY3JvbGxTZW5zaXRpdml0eSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuc2Nyb2xsUGFyZW50WzBdLnNjcm9sbExlZnQgPSBzY3JvbGxlZCA9IHRoaXMuc2Nyb2xsUGFyZW50WzBdLnNjcm9sbExlZnQgLSBvLnNjcm9sbFNwZWVkO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdGlmIChldmVudC5wYWdlWSAtIHRoaXMuZG9jdW1lbnQuc2Nyb2xsVG9wKCkgPCBvLnNjcm9sbFNlbnNpdGl2aXR5KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0c2Nyb2xsZWQgPSB0aGlzLmRvY3VtZW50LnNjcm9sbFRvcCh0aGlzLmRvY3VtZW50LnNjcm9sbFRvcCgpIC0gby5zY3JvbGxTcGVlZCk7XFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIGlmICh0aGlzLndpbmRvdy5oZWlnaHQoKSAtIChldmVudC5wYWdlWSAtIHRoaXMuZG9jdW1lbnQuc2Nyb2xsVG9wKCkpIDwgby5zY3JvbGxTZW5zaXRpdml0eSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHNjcm9sbGVkID0gdGhpcy5kb2N1bWVudC5zY3JvbGxUb3AodGhpcy5kb2N1bWVudC5zY3JvbGxUb3AoKSArIG8uc2Nyb2xsU3BlZWQpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoZXZlbnQucGFnZVggLSB0aGlzLmRvY3VtZW50LnNjcm9sbExlZnQoKSA8IG8uc2Nyb2xsU2Vuc2l0aXZpdHkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzY3JvbGxlZCA9IHRoaXMuZG9jdW1lbnQuc2Nyb2xsTGVmdCh0aGlzLmRvY3VtZW50LnNjcm9sbExlZnQoKSAtIG8uc2Nyb2xsU3BlZWQpO1xcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSBpZiAodGhpcy53aW5kb3cud2lkdGgoKSAtIChldmVudC5wYWdlWCAtIHRoaXMuZG9jdW1lbnQuc2Nyb2xsTGVmdCgpKSA8IG8uc2Nyb2xsU2Vuc2l0aXZpdHkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzY3JvbGxlZCA9IHRoaXMuZG9jdW1lbnQuc2Nyb2xsTGVmdCh0aGlzLmRvY3VtZW50LnNjcm9sbExlZnQoKSArIG8uc2Nyb2xsU3BlZWQpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKHNjcm9sbGVkICE9PSBmYWxzZSAmJiAkLnVpLmRkbWFuYWdlciAmJiAhby5kcm9wQmVoYXZpb3VyKSB7XFxuXFx0XFx0XFx0XFx0XFx0JC51aS5kZG1hbmFnZXIucHJlcGFyZU9mZnNldHModGhpcywgZXZlbnQpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly9SZWdlbmVyYXRlIHRoZSBhYnNvbHV0ZSBwb3NpdGlvbiB1c2VkIGZvciBwb3NpdGlvbiBjaGVja3NcXG5cXHRcXHRcXHR0aGlzLnBvc2l0aW9uQWJzID0gdGhpcy5fY29udmVydFBvc2l0aW9uVG8oXFxcImFic29sdXRlXFxcIik7XFxuXFxuXFx0XFx0XFx0Ly9TZXQgdGhlIGhlbHBlciBwb3NpdGlvblxcblxcdFxcdFxcdGlmICghdGhpcy5vcHRpb25zLmF4aXMgfHwgdGhpcy5vcHRpb25zLmF4aXMgIT09IFxcXCJ5XFxcIikge1xcblxcdFxcdFxcdFxcdHRoaXMuaGVscGVyWzBdLnN0eWxlLmxlZnQgPSB0aGlzLnBvc2l0aW9uLmxlZnQgKyBcXFwicHhcXFwiO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoIXRoaXMub3B0aW9ucy5heGlzIHx8IHRoaXMub3B0aW9ucy5heGlzICE9PSBcXFwieFxcXCIpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLmhlbHBlclswXS5zdHlsZS50b3AgPSB0aGlzLnBvc2l0aW9uLnRvcCArIFxcXCJweFxcXCI7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vUmVhcnJhbmdlXFxuXFx0XFx0XFx0Zm9yIChpID0gdGhpcy5pdGVtcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xcblxcblxcdFxcdFxcdFxcdC8vQ2FjaGUgdmFyaWFibGVzIGFuZCBpbnRlcnNlY3Rpb24sIGNvbnRpbnVlIGlmIG5vIGludGVyc2VjdGlvblxcblxcdFxcdFxcdFxcdGl0ZW0gPSB0aGlzLml0ZW1zW2ldO1xcblxcdFxcdFxcdFxcdGl0ZW1FbGVtZW50ID0gaXRlbS5pdGVtWzBdO1xcblxcdFxcdFxcdFxcdGludGVyc2VjdGlvbiA9IHRoaXMuX2ludGVyc2VjdHNXaXRoUG9pbnRlcihpdGVtKTtcXG5cXHRcXHRcXHRcXHRpZiAoIWludGVyc2VjdGlvbikge1xcblxcdFxcdFxcdFxcdFxcdGNvbnRpbnVlO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBPbmx5IHB1dCB0aGUgcGxhY2Vob2xkZXIgaW5zaWRlIHRoZSBjdXJyZW50IENvbnRhaW5lciwgc2tpcCBhbGxcXG5cXHRcXHRcXHRcXHQvLyBpdGVtcyBmcm9tIG90aGVyIGNvbnRhaW5lcnMuIFRoaXMgd29ya3MgYmVjYXVzZSB3aGVuIG1vdmluZ1xcblxcdFxcdFxcdFxcdC8vIGFuIGl0ZW0gZnJvbSBvbmUgY29udGFpbmVyIHRvIGFub3RoZXIgdGhlXFxuXFx0XFx0XFx0XFx0Ly8gY3VycmVudENvbnRhaW5lciBpcyBzd2l0Y2hlZCBiZWZvcmUgdGhlIHBsYWNlaG9sZGVyIGlzIG1vdmVkLlxcblxcdFxcdFxcdFxcdC8vXFxuXFx0XFx0XFx0XFx0Ly8gV2l0aG91dCB0aGlzLCBtb3ZpbmcgaXRlbXMgaW4gXFxcInN1Yi1zb3J0YWJsZXNcXFwiIGNhbiBjYXVzZVxcblxcdFxcdFxcdFxcdC8vIHRoZSBwbGFjZWhvbGRlciB0byBqaXR0ZXIgYmV0d2VlbiB0aGUgb3V0ZXIgYW5kIGlubmVyIGNvbnRhaW5lci5cXG5cXHRcXHRcXHRcXHRpZiAoaXRlbS5pbnN0YW5jZSAhPT0gdGhpcy5jdXJyZW50Q29udGFpbmVyKSB7XFxuXFx0XFx0XFx0XFx0XFx0Y29udGludWU7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIGNhbm5vdCBpbnRlcnNlY3Qgd2l0aCBpdHNlbGZcXG5cXHRcXHRcXHRcXHQvLyBubyB1c2VsZXNzIGFjdGlvbnMgdGhhdCBoYXZlIGJlZW4gZG9uZSBiZWZvcmVcXG5cXHRcXHRcXHRcXHQvLyBubyBhY3Rpb24gaWYgdGhlIGl0ZW0gbW92ZWQgaXMgdGhlIHBhcmVudCBvZiB0aGUgaXRlbSBjaGVja2VkXFxuXFx0XFx0XFx0XFx0aWYgKGl0ZW1FbGVtZW50ICE9PSB0aGlzLmN1cnJlbnRJdGVtWzBdICYmIHRoaXMucGxhY2Vob2xkZXJbaW50ZXJzZWN0aW9uID09PSAxID8gXFxcIm5leHRcXFwiIDogXFxcInByZXZcXFwiXSgpWzBdICE9PSBpdGVtRWxlbWVudCAmJiAhJC5jb250YWlucyh0aGlzLnBsYWNlaG9sZGVyWzBdLCBpdGVtRWxlbWVudCkgJiYgKHRoaXMub3B0aW9ucy50eXBlID09PSBcXFwic2VtaS1keW5hbWljXFxcIiA/ICEkLmNvbnRhaW5zKHRoaXMuZWxlbWVudFswXSwgaXRlbUVsZW1lbnQpIDogdHJ1ZSkpIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmRpcmVjdGlvbiA9IGludGVyc2VjdGlvbiA9PT0gMSA/IFxcXCJkb3duXFxcIiA6IFxcXCJ1cFxcXCI7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKHRoaXMub3B0aW9ucy50b2xlcmFuY2UgPT09IFxcXCJwb2ludGVyXFxcIiB8fCB0aGlzLl9pbnRlcnNlY3RzV2l0aFNpZGVzKGl0ZW0pKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5fcmVhcnJhbmdlKGV2ZW50LCBpdGVtKTtcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl90cmlnZ2VyKFxcXCJjaGFuZ2VcXFwiLCBldmVudCwgdGhpcy5fdWlIYXNoKCkpO1xcblxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly9Qb3N0IGV2ZW50cyB0byBjb250YWluZXJzXFxuXFx0XFx0XFx0dGhpcy5fY29udGFjdENvbnRhaW5lcnMoZXZlbnQpO1xcblxcblxcdFxcdFxcdC8vSW50ZXJjb25uZWN0IHdpdGggZHJvcHBhYmxlc1xcblxcdFxcdFxcdGlmICgkLnVpLmRkbWFuYWdlcikge1xcblxcdFxcdFxcdFxcdCQudWkuZGRtYW5hZ2VyLmRyYWcodGhpcywgZXZlbnQpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvL0NhbGwgY2FsbGJhY2tzXFxuXFx0XFx0XFx0dGhpcy5fdHJpZ2dlcihcXFwic29ydFxcXCIsIGV2ZW50LCB0aGlzLl91aUhhc2goKSk7XFxuXFxuXFx0XFx0XFx0dGhpcy5sYXN0UG9zaXRpb25BYnMgPSB0aGlzLnBvc2l0aW9uQWJzO1xcblxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9tb3VzZVN0b3A6IGZ1bmN0aW9uIF9tb3VzZVN0b3AoZXZlbnQsIG5vUHJvcGFnYXRpb24pIHtcXG5cXG5cXHRcXHRcXHRpZiAoIWV2ZW50KSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvL0lmIHdlIGFyZSB1c2luZyBkcm9wcGFibGVzLCBpbmZvcm0gdGhlIG1hbmFnZXIgYWJvdXQgdGhlIGRyb3BcXG5cXHRcXHRcXHRpZiAoJC51aS5kZG1hbmFnZXIgJiYgIXRoaXMub3B0aW9ucy5kcm9wQmVoYXZpb3VyKSB7XFxuXFx0XFx0XFx0XFx0JC51aS5kZG1hbmFnZXIuZHJvcCh0aGlzLCBldmVudCk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICh0aGlzLm9wdGlvbnMucmV2ZXJ0KSB7XFxuXFx0XFx0XFx0XFx0dmFyIHRoYXQgPSB0aGlzLFxcblxcdFxcdFxcdFxcdCAgICBjdXIgPSB0aGlzLnBsYWNlaG9sZGVyLm9mZnNldCgpLFxcblxcdFxcdFxcdFxcdCAgICBheGlzID0gdGhpcy5vcHRpb25zLmF4aXMsXFxuXFx0XFx0XFx0XFx0ICAgIGFuaW1hdGlvbiA9IHt9O1xcblxcblxcdFxcdFxcdFxcdGlmICghYXhpcyB8fCBheGlzID09PSBcXFwieFxcXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRhbmltYXRpb24ubGVmdCA9IGN1ci5sZWZ0IC0gdGhpcy5vZmZzZXQucGFyZW50LmxlZnQgLSB0aGlzLm1hcmdpbnMubGVmdCArICh0aGlzLm9mZnNldFBhcmVudFswXSA9PT0gdGhpcy5kb2N1bWVudFswXS5ib2R5ID8gMCA6IHRoaXMub2Zmc2V0UGFyZW50WzBdLnNjcm9sbExlZnQpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRpZiAoIWF4aXMgfHwgYXhpcyA9PT0gXFxcInlcXFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0YW5pbWF0aW9uLnRvcCA9IGN1ci50b3AgLSB0aGlzLm9mZnNldC5wYXJlbnQudG9wIC0gdGhpcy5tYXJnaW5zLnRvcCArICh0aGlzLm9mZnNldFBhcmVudFswXSA9PT0gdGhpcy5kb2N1bWVudFswXS5ib2R5ID8gMCA6IHRoaXMub2Zmc2V0UGFyZW50WzBdLnNjcm9sbFRvcCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHRoaXMucmV2ZXJ0aW5nID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHQkKHRoaXMuaGVscGVyKS5hbmltYXRlKGFuaW1hdGlvbiwgcGFyc2VJbnQodGhpcy5vcHRpb25zLnJldmVydCwgMTApIHx8IDUwMCwgZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdHRoYXQuX2NsZWFyKGV2ZW50KTtcXG5cXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdHRoaXMuX2NsZWFyKGV2ZW50LCBub1Byb3BhZ2F0aW9uKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y2FuY2VsOiBmdW5jdGlvbiBjYW5jZWwoKSB7XFxuXFxuXFx0XFx0XFx0aWYgKHRoaXMuZHJhZ2dpbmcpIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLl9tb3VzZVVwKHsgdGFyZ2V0OiBudWxsIH0pO1xcblxcblxcdFxcdFxcdFxcdGlmICh0aGlzLm9wdGlvbnMuaGVscGVyID09PSBcXFwib3JpZ2luYWxcXFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5jdXJyZW50SXRlbS5jc3ModGhpcy5fc3RvcmVkQ1NTKS5yZW1vdmVDbGFzcyhcXFwidWktc29ydGFibGUtaGVscGVyXFxcIik7XFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmN1cnJlbnRJdGVtLnNob3coKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly9Qb3N0IGRlYWN0aXZhdGluZyBldmVudHMgdG8gY29udGFpbmVyc1xcblxcdFxcdFxcdFxcdGZvciAodmFyIGkgPSB0aGlzLmNvbnRhaW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmNvbnRhaW5lcnNbaV0uX3RyaWdnZXIoXFxcImRlYWN0aXZhdGVcXFwiLCBudWxsLCB0aGlzLl91aUhhc2godGhpcykpO1xcblxcdFxcdFxcdFxcdFxcdGlmICh0aGlzLmNvbnRhaW5lcnNbaV0uY29udGFpbmVyQ2FjaGUub3Zlcikge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuY29udGFpbmVyc1tpXS5fdHJpZ2dlcihcXFwib3V0XFxcIiwgbnVsbCwgdGhpcy5fdWlIYXNoKHRoaXMpKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLmNvbnRhaW5lcnNbaV0uY29udGFpbmVyQ2FjaGUub3ZlciA9IDA7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKHRoaXMucGxhY2Vob2xkZXIpIHtcXG5cXHRcXHRcXHRcXHQvLyQodGhpcy5wbGFjZWhvbGRlclswXSkucmVtb3ZlKCk7IHdvdWxkIGhhdmUgYmVlbiB0aGUgalF1ZXJ5IHdheSAtIHVuZm9ydHVuYXRlbHksIGl0IHVuYmluZHMgQUxMIGV2ZW50cyBmcm9tIHRoZSBvcmlnaW5hbCBub2RlIVxcblxcdFxcdFxcdFxcdGlmICh0aGlzLnBsYWNlaG9sZGVyWzBdLnBhcmVudE5vZGUpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnBsYWNlaG9sZGVyWzBdLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5wbGFjZWhvbGRlclswXSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGlmICh0aGlzLm9wdGlvbnMuaGVscGVyICE9PSBcXFwib3JpZ2luYWxcXFwiICYmIHRoaXMuaGVscGVyICYmIHRoaXMuaGVscGVyWzBdLnBhcmVudE5vZGUpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmhlbHBlci5yZW1vdmUoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0JC5leHRlbmQodGhpcywge1xcblxcdFxcdFxcdFxcdFxcdGhlbHBlcjogbnVsbCxcXG5cXHRcXHRcXHRcXHRcXHRkcmFnZ2luZzogZmFsc2UsXFxuXFx0XFx0XFx0XFx0XFx0cmV2ZXJ0aW5nOiBmYWxzZSxcXG5cXHRcXHRcXHRcXHRcXHRfbm9GaW5hbFNvcnQ6IG51bGxcXG5cXHRcXHRcXHRcXHR9KTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAodGhpcy5kb21Qb3NpdGlvbi5wcmV2KSB7XFxuXFx0XFx0XFx0XFx0XFx0JCh0aGlzLmRvbVBvc2l0aW9uLnByZXYpLmFmdGVyKHRoaXMuY3VycmVudEl0ZW0pO1xcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0JCh0aGlzLmRvbVBvc2l0aW9uLnBhcmVudCkucHJlcGVuZCh0aGlzLmN1cnJlbnRJdGVtKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2VyaWFsaXplOiBmdW5jdGlvbiBzZXJpYWxpemUobykge1xcblxcblxcdFxcdFxcdHZhciBpdGVtcyA9IHRoaXMuX2dldEl0ZW1zQXNqUXVlcnkobyAmJiBvLmNvbm5lY3RlZCksXFxuXFx0XFx0XFx0ICAgIHN0ciA9IFtdO1xcblxcdFxcdFxcdG8gPSBvIHx8IHt9O1xcblxcblxcdFxcdFxcdCQoaXRlbXMpLmVhY2goZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdHZhciByZXMgPSAoJChvLml0ZW0gfHwgdGhpcykuYXR0cihvLmF0dHJpYnV0ZSB8fCBcXFwiaWRcXFwiKSB8fCBcXFwiXFxcIikubWF0Y2goby5leHByZXNzaW9uIHx8IC8oLispW1xcXFwtPV9dKC4rKS8pO1xcblxcdFxcdFxcdFxcdGlmIChyZXMpIHtcXG5cXHRcXHRcXHRcXHRcXHRzdHIucHVzaCgoby5rZXkgfHwgcmVzWzFdICsgXFxcIltdXFxcIikgKyBcXFwiPVxcXCIgKyAoby5rZXkgJiYgby5leHByZXNzaW9uID8gcmVzWzFdIDogcmVzWzJdKSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0pO1xcblxcblxcdFxcdFxcdGlmICghc3RyLmxlbmd0aCAmJiBvLmtleSkge1xcblxcdFxcdFxcdFxcdHN0ci5wdXNoKG8ua2V5ICsgXFxcIj1cXFwiKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHN0ci5qb2luKFxcXCImXFxcIik7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHR0b0FycmF5OiBmdW5jdGlvbiB0b0FycmF5KG8pIHtcXG5cXG5cXHRcXHRcXHR2YXIgaXRlbXMgPSB0aGlzLl9nZXRJdGVtc0FzalF1ZXJ5KG8gJiYgby5jb25uZWN0ZWQpLFxcblxcdFxcdFxcdCAgICByZXQgPSBbXTtcXG5cXG5cXHRcXHRcXHRvID0gbyB8fCB7fTtcXG5cXG5cXHRcXHRcXHRpdGVtcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRyZXQucHVzaCgkKG8uaXRlbSB8fCB0aGlzKS5hdHRyKG8uYXR0cmlidXRlIHx8IFxcXCJpZFxcXCIpIHx8IFxcXCJcXFwiKTtcXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRyZXR1cm4gcmV0O1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0LyogQmUgY2FyZWZ1bCB3aXRoIHRoZSBmb2xsb3dpbmcgY29yZSBmdW5jdGlvbnMgKi9cXG5cXHRcXHRfaW50ZXJzZWN0c1dpdGg6IGZ1bmN0aW9uIF9pbnRlcnNlY3RzV2l0aChpdGVtKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHgxID0gdGhpcy5wb3NpdGlvbkFicy5sZWZ0LFxcblxcdFxcdFxcdCAgICB4MiA9IHgxICsgdGhpcy5oZWxwZXJQcm9wb3J0aW9ucy53aWR0aCxcXG5cXHRcXHRcXHQgICAgeTEgPSB0aGlzLnBvc2l0aW9uQWJzLnRvcCxcXG5cXHRcXHRcXHQgICAgeTIgPSB5MSArIHRoaXMuaGVscGVyUHJvcG9ydGlvbnMuaGVpZ2h0LFxcblxcdFxcdFxcdCAgICBsID0gaXRlbS5sZWZ0LFxcblxcdFxcdFxcdCAgICByID0gbCArIGl0ZW0ud2lkdGgsXFxuXFx0XFx0XFx0ICAgIHQgPSBpdGVtLnRvcCxcXG5cXHRcXHRcXHQgICAgYiA9IHQgKyBpdGVtLmhlaWdodCxcXG5cXHRcXHRcXHQgICAgZHlDbGljayA9IHRoaXMub2Zmc2V0LmNsaWNrLnRvcCxcXG5cXHRcXHRcXHQgICAgZHhDbGljayA9IHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQsXFxuXFx0XFx0XFx0ICAgIGlzT3ZlckVsZW1lbnRIZWlnaHQgPSB0aGlzLm9wdGlvbnMuYXhpcyA9PT0gXFxcInhcXFwiIHx8IHkxICsgZHlDbGljayA+IHQgJiYgeTEgKyBkeUNsaWNrIDwgYixcXG5cXHRcXHRcXHQgICAgaXNPdmVyRWxlbWVudFdpZHRoID0gdGhpcy5vcHRpb25zLmF4aXMgPT09IFxcXCJ5XFxcIiB8fCB4MSArIGR4Q2xpY2sgPiBsICYmIHgxICsgZHhDbGljayA8IHIsXFxuXFx0XFx0XFx0ICAgIGlzT3ZlckVsZW1lbnQgPSBpc092ZXJFbGVtZW50SGVpZ2h0ICYmIGlzT3ZlckVsZW1lbnRXaWR0aDtcXG5cXG5cXHRcXHRcXHRpZiAodGhpcy5vcHRpb25zLnRvbGVyYW5jZSA9PT0gXFxcInBvaW50ZXJcXFwiIHx8IHRoaXMub3B0aW9ucy5mb3JjZVBvaW50ZXJGb3JDb250YWluZXJzIHx8IHRoaXMub3B0aW9ucy50b2xlcmFuY2UgIT09IFxcXCJwb2ludGVyXFxcIiAmJiB0aGlzLmhlbHBlclByb3BvcnRpb25zW3RoaXMuZmxvYXRpbmcgPyBcXFwid2lkdGhcXFwiIDogXFxcImhlaWdodFxcXCJdID4gaXRlbVt0aGlzLmZsb2F0aW5nID8gXFxcIndpZHRoXFxcIiA6IFxcXCJoZWlnaHRcXFwiXSkge1xcblxcdFxcdFxcdFxcdHJldHVybiBpc092ZXJFbGVtZW50O1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIGwgPCB4MSArIHRoaXMuaGVscGVyUHJvcG9ydGlvbnMud2lkdGggLyAyICYmIC8vIFJpZ2h0IEhhbGZcXG5cXHRcXHRcXHRcXHR4MiAtIHRoaXMuaGVscGVyUHJvcG9ydGlvbnMud2lkdGggLyAyIDwgciAmJiAvLyBMZWZ0IEhhbGZcXG5cXHRcXHRcXHRcXHR0IDwgeTEgKyB0aGlzLmhlbHBlclByb3BvcnRpb25zLmhlaWdodCAvIDIgJiYgLy8gQm90dG9tIEhhbGZcXG5cXHRcXHRcXHRcXHR5MiAtIHRoaXMuaGVscGVyUHJvcG9ydGlvbnMuaGVpZ2h0IC8gMiA8IGI7IC8vIFRvcCBIYWxmXFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFxuXFx0XFx0X2ludGVyc2VjdHNXaXRoUG9pbnRlcjogZnVuY3Rpb24gX2ludGVyc2VjdHNXaXRoUG9pbnRlcihpdGVtKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGlzT3ZlckVsZW1lbnRIZWlnaHQgPSB0aGlzLm9wdGlvbnMuYXhpcyA9PT0gXFxcInhcXFwiIHx8IHRoaXMuX2lzT3ZlckF4aXModGhpcy5wb3NpdGlvbkFicy50b3AgKyB0aGlzLm9mZnNldC5jbGljay50b3AsIGl0ZW0udG9wLCBpdGVtLmhlaWdodCksXFxuXFx0XFx0XFx0ICAgIGlzT3ZlckVsZW1lbnRXaWR0aCA9IHRoaXMub3B0aW9ucy5heGlzID09PSBcXFwieVxcXCIgfHwgdGhpcy5faXNPdmVyQXhpcyh0aGlzLnBvc2l0aW9uQWJzLmxlZnQgKyB0aGlzLm9mZnNldC5jbGljay5sZWZ0LCBpdGVtLmxlZnQsIGl0ZW0ud2lkdGgpLFxcblxcdFxcdFxcdCAgICBpc092ZXJFbGVtZW50ID0gaXNPdmVyRWxlbWVudEhlaWdodCAmJiBpc092ZXJFbGVtZW50V2lkdGgsXFxuXFx0XFx0XFx0ICAgIHZlcnRpY2FsRGlyZWN0aW9uID0gdGhpcy5fZ2V0RHJhZ1ZlcnRpY2FsRGlyZWN0aW9uKCksXFxuXFx0XFx0XFx0ICAgIGhvcml6b250YWxEaXJlY3Rpb24gPSB0aGlzLl9nZXREcmFnSG9yaXpvbnRhbERpcmVjdGlvbigpO1xcblxcblxcdFxcdFxcdGlmICghaXNPdmVyRWxlbWVudCkge1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZmxvYXRpbmcgPyBob3Jpem9udGFsRGlyZWN0aW9uICYmIGhvcml6b250YWxEaXJlY3Rpb24gPT09IFxcXCJyaWdodFxcXCIgfHwgdmVydGljYWxEaXJlY3Rpb24gPT09IFxcXCJkb3duXFxcIiA/IDIgOiAxIDogdmVydGljYWxEaXJlY3Rpb24gJiYgKHZlcnRpY2FsRGlyZWN0aW9uID09PSBcXFwiZG93blxcXCIgPyAyIDogMSk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfaW50ZXJzZWN0c1dpdGhTaWRlczogZnVuY3Rpb24gX2ludGVyc2VjdHNXaXRoU2lkZXMoaXRlbSkge1xcblxcblxcdFxcdFxcdHZhciBpc092ZXJCb3R0b21IYWxmID0gdGhpcy5faXNPdmVyQXhpcyh0aGlzLnBvc2l0aW9uQWJzLnRvcCArIHRoaXMub2Zmc2V0LmNsaWNrLnRvcCwgaXRlbS50b3AgKyBpdGVtLmhlaWdodCAvIDIsIGl0ZW0uaGVpZ2h0KSxcXG5cXHRcXHRcXHQgICAgaXNPdmVyUmlnaHRIYWxmID0gdGhpcy5faXNPdmVyQXhpcyh0aGlzLnBvc2l0aW9uQWJzLmxlZnQgKyB0aGlzLm9mZnNldC5jbGljay5sZWZ0LCBpdGVtLmxlZnQgKyBpdGVtLndpZHRoIC8gMiwgaXRlbS53aWR0aCksXFxuXFx0XFx0XFx0ICAgIHZlcnRpY2FsRGlyZWN0aW9uID0gdGhpcy5fZ2V0RHJhZ1ZlcnRpY2FsRGlyZWN0aW9uKCksXFxuXFx0XFx0XFx0ICAgIGhvcml6b250YWxEaXJlY3Rpb24gPSB0aGlzLl9nZXREcmFnSG9yaXpvbnRhbERpcmVjdGlvbigpO1xcblxcblxcdFxcdFxcdGlmICh0aGlzLmZsb2F0aW5nICYmIGhvcml6b250YWxEaXJlY3Rpb24pIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gaG9yaXpvbnRhbERpcmVjdGlvbiA9PT0gXFxcInJpZ2h0XFxcIiAmJiBpc092ZXJSaWdodEhhbGYgfHwgaG9yaXpvbnRhbERpcmVjdGlvbiA9PT0gXFxcImxlZnRcXFwiICYmICFpc092ZXJSaWdodEhhbGY7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdmVydGljYWxEaXJlY3Rpb24gJiYgKHZlcnRpY2FsRGlyZWN0aW9uID09PSBcXFwiZG93blxcXCIgJiYgaXNPdmVyQm90dG9tSGFsZiB8fCB2ZXJ0aWNhbERpcmVjdGlvbiA9PT0gXFxcInVwXFxcIiAmJiAhaXNPdmVyQm90dG9tSGFsZik7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFxuXFx0XFx0X2dldERyYWdWZXJ0aWNhbERpcmVjdGlvbjogZnVuY3Rpb24gX2dldERyYWdWZXJ0aWNhbERpcmVjdGlvbigpIHtcXG5cXHRcXHRcXHR2YXIgZGVsdGEgPSB0aGlzLnBvc2l0aW9uQWJzLnRvcCAtIHRoaXMubGFzdFBvc2l0aW9uQWJzLnRvcDtcXG5cXHRcXHRcXHRyZXR1cm4gZGVsdGEgIT09IDAgJiYgKGRlbHRhID4gMCA/IFxcXCJkb3duXFxcIiA6IFxcXCJ1cFxcXCIpO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X2dldERyYWdIb3Jpem9udGFsRGlyZWN0aW9uOiBmdW5jdGlvbiBfZ2V0RHJhZ0hvcml6b250YWxEaXJlY3Rpb24oKSB7XFxuXFx0XFx0XFx0dmFyIGRlbHRhID0gdGhpcy5wb3NpdGlvbkFicy5sZWZ0IC0gdGhpcy5sYXN0UG9zaXRpb25BYnMubGVmdDtcXG5cXHRcXHRcXHRyZXR1cm4gZGVsdGEgIT09IDAgJiYgKGRlbHRhID4gMCA/IFxcXCJyaWdodFxcXCIgOiBcXFwibGVmdFxcXCIpO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0cmVmcmVzaDogZnVuY3Rpb24gcmVmcmVzaChldmVudCkge1xcblxcdFxcdFxcdHRoaXMuX3JlZnJlc2hJdGVtcyhldmVudCk7XFxuXFx0XFx0XFx0dGhpcy5fc2V0SGFuZGxlQ2xhc3NOYW1lKCk7XFxuXFx0XFx0XFx0dGhpcy5yZWZyZXNoUG9zaXRpb25zKCk7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfY29ubmVjdFdpdGg6IGZ1bmN0aW9uIF9jb25uZWN0V2l0aCgpIHtcXG5cXHRcXHRcXHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcXG5cXHRcXHRcXHRyZXR1cm4gb3B0aW9ucy5jb25uZWN0V2l0aC5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nID8gW29wdGlvbnMuY29ubmVjdFdpdGhdIDogb3B0aW9ucy5jb25uZWN0V2l0aDtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9nZXRJdGVtc0FzalF1ZXJ5OiBmdW5jdGlvbiBfZ2V0SXRlbXNBc2pRdWVyeShjb25uZWN0ZWQpIHtcXG5cXG5cXHRcXHRcXHR2YXIgaSxcXG5cXHRcXHRcXHQgICAgaixcXG5cXHRcXHRcXHQgICAgY3VyLFxcblxcdFxcdFxcdCAgICBpbnN0LFxcblxcdFxcdFxcdCAgICBpdGVtcyA9IFtdLFxcblxcdFxcdFxcdCAgICBxdWVyaWVzID0gW10sXFxuXFx0XFx0XFx0ICAgIGNvbm5lY3RXaXRoID0gdGhpcy5fY29ubmVjdFdpdGgoKTtcXG5cXG5cXHRcXHRcXHRpZiAoY29ubmVjdFdpdGggJiYgY29ubmVjdGVkKSB7XFxuXFx0XFx0XFx0XFx0Zm9yIChpID0gY29ubmVjdFdpdGgubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcXG5cXHRcXHRcXHRcXHRcXHRjdXIgPSAkKGNvbm5lY3RXaXRoW2ldLCB0aGlzLmRvY3VtZW50WzBdKTtcXG5cXHRcXHRcXHRcXHRcXHRmb3IgKGogPSBjdXIubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpbnN0ID0gJC5kYXRhKGN1cltqXSwgdGhpcy53aWRnZXRGdWxsTmFtZSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKGluc3QgJiYgaW5zdCAhPT0gdGhpcyAmJiAhaW5zdC5vcHRpb25zLmRpc2FibGVkKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cXVlcmllcy5wdXNoKFskLmlzRnVuY3Rpb24oaW5zdC5vcHRpb25zLml0ZW1zKSA/IGluc3Qub3B0aW9ucy5pdGVtcy5jYWxsKGluc3QuZWxlbWVudCkgOiAkKGluc3Qub3B0aW9ucy5pdGVtcywgaW5zdC5lbGVtZW50KS5ub3QoXFxcIi51aS1zb3J0YWJsZS1oZWxwZXJcXFwiKS5ub3QoXFxcIi51aS1zb3J0YWJsZS1wbGFjZWhvbGRlclxcXCIpLCBpbnN0XSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHF1ZXJpZXMucHVzaChbJC5pc0Z1bmN0aW9uKHRoaXMub3B0aW9ucy5pdGVtcykgPyB0aGlzLm9wdGlvbnMuaXRlbXMuY2FsbCh0aGlzLmVsZW1lbnQsIG51bGwsIHsgb3B0aW9uczogdGhpcy5vcHRpb25zLCBpdGVtOiB0aGlzLmN1cnJlbnRJdGVtIH0pIDogJCh0aGlzLm9wdGlvbnMuaXRlbXMsIHRoaXMuZWxlbWVudCkubm90KFxcXCIudWktc29ydGFibGUtaGVscGVyXFxcIikubm90KFxcXCIudWktc29ydGFibGUtcGxhY2Vob2xkZXJcXFwiKSwgdGhpc10pO1xcblxcblxcdFxcdFxcdGZ1bmN0aW9uIGFkZEl0ZW1zKCkge1xcblxcdFxcdFxcdFxcdGl0ZW1zLnB1c2godGhpcyk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGZvciAoaSA9IHF1ZXJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcXG5cXHRcXHRcXHRcXHRxdWVyaWVzW2ldWzBdLmVhY2goYWRkSXRlbXMpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gJChpdGVtcyk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfcmVtb3ZlQ3VycmVudHNGcm9tSXRlbXM6IGZ1bmN0aW9uIF9yZW1vdmVDdXJyZW50c0Zyb21JdGVtcygpIHtcXG5cXG5cXHRcXHRcXHR2YXIgbGlzdCA9IHRoaXMuY3VycmVudEl0ZW0uZmluZChcXFwiOmRhdGEoXFxcIiArIHRoaXMud2lkZ2V0TmFtZSArIFxcXCItaXRlbSlcXFwiKTtcXG5cXG5cXHRcXHRcXHR0aGlzLml0ZW1zID0gJC5ncmVwKHRoaXMuaXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7XFxuXFx0XFx0XFx0XFx0Zm9yICh2YXIgaiA9IDA7IGogPCBsaXN0Lmxlbmd0aDsgaisrKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGxpc3Rbal0gPT09IGl0ZW0uaXRlbVswXSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdFxcdH0pO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X3JlZnJlc2hJdGVtczogZnVuY3Rpb24gX3JlZnJlc2hJdGVtcyhldmVudCkge1xcblxcblxcdFxcdFxcdHRoaXMuaXRlbXMgPSBbXTtcXG5cXHRcXHRcXHR0aGlzLmNvbnRhaW5lcnMgPSBbdGhpc107XFxuXFxuXFx0XFx0XFx0dmFyIGksXFxuXFx0XFx0XFx0ICAgIGosXFxuXFx0XFx0XFx0ICAgIGN1cixcXG5cXHRcXHRcXHQgICAgaW5zdCxcXG5cXHRcXHRcXHQgICAgdGFyZ2V0RGF0YSxcXG5cXHRcXHRcXHQgICAgX3F1ZXJpZXMsXFxuXFx0XFx0XFx0ICAgIGl0ZW0sXFxuXFx0XFx0XFx0ICAgIHF1ZXJpZXNMZW5ndGgsXFxuXFx0XFx0XFx0ICAgIGl0ZW1zID0gdGhpcy5pdGVtcyxcXG5cXHRcXHRcXHQgICAgcXVlcmllcyA9IFtbJC5pc0Z1bmN0aW9uKHRoaXMub3B0aW9ucy5pdGVtcykgPyB0aGlzLm9wdGlvbnMuaXRlbXMuY2FsbCh0aGlzLmVsZW1lbnRbMF0sIGV2ZW50LCB7IGl0ZW06IHRoaXMuY3VycmVudEl0ZW0gfSkgOiAkKHRoaXMub3B0aW9ucy5pdGVtcywgdGhpcy5lbGVtZW50KSwgdGhpc11dLFxcblxcdFxcdFxcdCAgICBjb25uZWN0V2l0aCA9IHRoaXMuX2Nvbm5lY3RXaXRoKCk7XFxuXFxuXFx0XFx0XFx0aWYgKGNvbm5lY3RXaXRoICYmIHRoaXMucmVhZHkpIHtcXG5cXHRcXHRcXHRcXHQvL1Nob3VsZG4ndCBiZSBydW4gdGhlIGZpcnN0IHRpbWUgdGhyb3VnaCBkdWUgdG8gbWFzc2l2ZSBzbG93LWRvd25cXG5cXHRcXHRcXHRcXHRmb3IgKGkgPSBjb25uZWN0V2l0aC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xcblxcdFxcdFxcdFxcdFxcdGN1ciA9ICQoY29ubmVjdFdpdGhbaV0sIHRoaXMuZG9jdW1lbnRbMF0pO1xcblxcdFxcdFxcdFxcdFxcdGZvciAoaiA9IGN1ci5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGluc3QgPSAkLmRhdGEoY3VyW2pdLCB0aGlzLndpZGdldEZ1bGxOYW1lKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoaW5zdCAmJiBpbnN0ICE9PSB0aGlzICYmICFpbnN0Lm9wdGlvbnMuZGlzYWJsZWQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRxdWVyaWVzLnB1c2goWyQuaXNGdW5jdGlvbihpbnN0Lm9wdGlvbnMuaXRlbXMpID8gaW5zdC5vcHRpb25zLml0ZW1zLmNhbGwoaW5zdC5lbGVtZW50WzBdLCBldmVudCwgeyBpdGVtOiB0aGlzLmN1cnJlbnRJdGVtIH0pIDogJChpbnN0Lm9wdGlvbnMuaXRlbXMsIGluc3QuZWxlbWVudCksIGluc3RdKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLmNvbnRhaW5lcnMucHVzaChpbnN0KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Zm9yIChpID0gcXVlcmllcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xcblxcdFxcdFxcdFxcdHRhcmdldERhdGEgPSBxdWVyaWVzW2ldWzFdO1xcblxcdFxcdFxcdFxcdF9xdWVyaWVzID0gcXVlcmllc1tpXVswXTtcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKGogPSAwLCBxdWVyaWVzTGVuZ3RoID0gX3F1ZXJpZXMubGVuZ3RoOyBqIDwgcXVlcmllc0xlbmd0aDsgaisrKSB7XFxuXFx0XFx0XFx0XFx0XFx0aXRlbSA9ICQoX3F1ZXJpZXNbal0pO1xcblxcblxcdFxcdFxcdFxcdFxcdGl0ZW0uZGF0YSh0aGlzLndpZGdldE5hbWUgKyBcXFwiLWl0ZW1cXFwiLCB0YXJnZXREYXRhKTsgLy8gRGF0YSBmb3IgdGFyZ2V0IGNoZWNraW5nIChtb3VzZSBtYW5hZ2VyKVxcblxcblxcdFxcdFxcdFxcdFxcdGl0ZW1zLnB1c2goe1xcblxcdFxcdFxcdFxcdFxcdFxcdGl0ZW06IGl0ZW0sXFxuXFx0XFx0XFx0XFx0XFx0XFx0aW5zdGFuY2U6IHRhcmdldERhdGEsXFxuXFx0XFx0XFx0XFx0XFx0XFx0d2lkdGg6IDAsIGhlaWdodDogMCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRsZWZ0OiAwLCB0b3A6IDBcXG5cXHRcXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFxuXFx0XFx0cmVmcmVzaFBvc2l0aW9uczogZnVuY3Rpb24gcmVmcmVzaFBvc2l0aW9ucyhmYXN0KSB7XFxuXFxuXFx0XFx0XFx0Ly8gRGV0ZXJtaW5lIHdoZXRoZXIgaXRlbXMgYXJlIGJlaW5nIGRpc3BsYXllZCBob3Jpem9udGFsbHlcXG5cXHRcXHRcXHR0aGlzLmZsb2F0aW5nID0gdGhpcy5pdGVtcy5sZW5ndGggPyB0aGlzLm9wdGlvbnMuYXhpcyA9PT0gXFxcInhcXFwiIHx8IHRoaXMuX2lzRmxvYXRpbmcodGhpcy5pdGVtc1swXS5pdGVtKSA6IGZhbHNlO1xcblxcblxcdFxcdFxcdC8vVGhpcyBoYXMgdG8gYmUgcmVkb25lIGJlY2F1c2UgZHVlIHRvIHRoZSBpdGVtIGJlaW5nIG1vdmVkIG91dC9pbnRvIHRoZSBvZmZzZXRQYXJlbnQsIHRoZSBvZmZzZXRQYXJlbnQncyBwb3NpdGlvbiB3aWxsIGNoYW5nZVxcblxcdFxcdFxcdGlmICh0aGlzLm9mZnNldFBhcmVudCAmJiB0aGlzLmhlbHBlcikge1xcblxcdFxcdFxcdFxcdHRoaXMub2Zmc2V0LnBhcmVudCA9IHRoaXMuX2dldFBhcmVudE9mZnNldCgpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2YXIgaSwgaXRlbSwgdCwgcDtcXG5cXG5cXHRcXHRcXHRmb3IgKGkgPSB0aGlzLml0ZW1zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XFxuXFx0XFx0XFx0XFx0aXRlbSA9IHRoaXMuaXRlbXNbaV07XFxuXFxuXFx0XFx0XFx0XFx0Ly9XZSBpZ25vcmUgY2FsY3VsYXRpbmcgcG9zaXRpb25zIG9mIGFsbCBjb25uZWN0ZWQgY29udGFpbmVycyB3aGVuIHdlJ3JlIG5vdCBvdmVyIHRoZW1cXG5cXHRcXHRcXHRcXHRpZiAoaXRlbS5pbnN0YW5jZSAhPT0gdGhpcy5jdXJyZW50Q29udGFpbmVyICYmIHRoaXMuY3VycmVudENvbnRhaW5lciAmJiBpdGVtLml0ZW1bMF0gIT09IHRoaXMuY3VycmVudEl0ZW1bMF0pIHtcXG5cXHRcXHRcXHRcXHRcXHRjb250aW51ZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0dCA9IHRoaXMub3B0aW9ucy50b2xlcmFuY2VFbGVtZW50ID8gJCh0aGlzLm9wdGlvbnMudG9sZXJhbmNlRWxlbWVudCwgaXRlbS5pdGVtKSA6IGl0ZW0uaXRlbTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIWZhc3QpIHtcXG5cXHRcXHRcXHRcXHRcXHRpdGVtLndpZHRoID0gdC5vdXRlcldpZHRoKCk7XFxuXFx0XFx0XFx0XFx0XFx0aXRlbS5oZWlnaHQgPSB0Lm91dGVySGVpZ2h0KCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHAgPSB0Lm9mZnNldCgpO1xcblxcdFxcdFxcdFxcdGl0ZW0ubGVmdCA9IHAubGVmdDtcXG5cXHRcXHRcXHRcXHRpdGVtLnRvcCA9IHAudG9wO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAodGhpcy5vcHRpb25zLmN1c3RvbSAmJiB0aGlzLm9wdGlvbnMuY3VzdG9tLnJlZnJlc2hDb250YWluZXJzKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5vcHRpb25zLmN1c3RvbS5yZWZyZXNoQ29udGFpbmVycy5jYWxsKHRoaXMpO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0Zm9yIChpID0gdGhpcy5jb250YWluZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XFxuXFx0XFx0XFx0XFx0XFx0cCA9IHRoaXMuY29udGFpbmVyc1tpXS5lbGVtZW50Lm9mZnNldCgpO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuY29udGFpbmVyc1tpXS5jb250YWluZXJDYWNoZS5sZWZ0ID0gcC5sZWZ0O1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuY29udGFpbmVyc1tpXS5jb250YWluZXJDYWNoZS50b3AgPSBwLnRvcDtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmNvbnRhaW5lcnNbaV0uY29udGFpbmVyQ2FjaGUud2lkdGggPSB0aGlzLmNvbnRhaW5lcnNbaV0uZWxlbWVudC5vdXRlcldpZHRoKCk7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5jb250YWluZXJzW2ldLmNvbnRhaW5lckNhY2hlLmhlaWdodCA9IHRoaXMuY29udGFpbmVyc1tpXS5lbGVtZW50Lm91dGVySGVpZ2h0KCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9jcmVhdGVQbGFjZWhvbGRlcjogZnVuY3Rpb24gX2NyZWF0ZVBsYWNlaG9sZGVyKHRoYXQpIHtcXG5cXHRcXHRcXHR0aGF0ID0gdGhhdCB8fCB0aGlzO1xcblxcdFxcdFxcdHZhciBjbGFzc05hbWUsXFxuXFx0XFx0XFx0ICAgIG8gPSB0aGF0Lm9wdGlvbnM7XFxuXFxuXFx0XFx0XFx0aWYgKCFvLnBsYWNlaG9sZGVyIHx8IG8ucGxhY2Vob2xkZXIuY29uc3RydWN0b3IgPT09IFN0cmluZykge1xcblxcdFxcdFxcdFxcdGNsYXNzTmFtZSA9IG8ucGxhY2Vob2xkZXI7XFxuXFx0XFx0XFx0XFx0by5wbGFjZWhvbGRlciA9IHtcXG5cXHRcXHRcXHRcXHRcXHRlbGVtZW50OiBmdW5jdGlvbiBlbGVtZW50KCkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBub2RlTmFtZSA9IHRoYXQuY3VycmVudEl0ZW1bMF0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcXG5cXHRcXHRcXHRcXHRcXHRcXHQgICAgZWxlbWVudCA9ICQoXFxcIjxcXFwiICsgbm9kZU5hbWUgKyBcXFwiPlxcXCIsIHRoYXQuZG9jdW1lbnRbMF0pLmFkZENsYXNzKGNsYXNzTmFtZSB8fCB0aGF0LmN1cnJlbnRJdGVtWzBdLmNsYXNzTmFtZSArIFxcXCIgdWktc29ydGFibGUtcGxhY2Vob2xkZXJcXFwiKS5yZW1vdmVDbGFzcyhcXFwidWktc29ydGFibGUtaGVscGVyXFxcIik7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKG5vZGVOYW1lID09PSBcXFwidGJvZHlcXFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhhdC5fY3JlYXRlVHJQbGFjZWhvbGRlcih0aGF0LmN1cnJlbnRJdGVtLmZpbmQoXFxcInRyXFxcIikuZXEoMCksICQoXFxcIjx0cj5cXFwiLCB0aGF0LmRvY3VtZW50WzBdKS5hcHBlbmRUbyhlbGVtZW50KSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIGlmIChub2RlTmFtZSA9PT0gXFxcInRyXFxcIikge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoYXQuX2NyZWF0ZVRyUGxhY2Vob2xkZXIodGhhdC5jdXJyZW50SXRlbSwgZWxlbWVudCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIGlmIChub2RlTmFtZSA9PT0gXFxcImltZ1xcXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRlbGVtZW50LmF0dHIoXFxcInNyY1xcXCIsIHRoYXQuY3VycmVudEl0ZW0uYXR0cihcXFwic3JjXFxcIikpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIWNsYXNzTmFtZSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGVsZW1lbnQuY3NzKFxcXCJ2aXNpYmlsaXR5XFxcIiwgXFxcImhpZGRlblxcXCIpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gZWxlbWVudDtcXG5cXHRcXHRcXHRcXHRcXHR9LFxcblxcdFxcdFxcdFxcdFxcdHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKGNvbnRhaW5lciwgcCkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIDEuIElmIGEgY2xhc3NOYW1lIGlzIHNldCBhcyAncGxhY2Vob2xkZXIgb3B0aW9uLCB3ZSBkb24ndCBmb3JjZSBzaXplcyAtIHRoZSBjbGFzcyBpcyByZXNwb25zaWJsZSBmb3IgdGhhdFxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIDIuIFRoZSBvcHRpb24gJ2ZvcmNlUGxhY2Vob2xkZXJTaXplIGNhbiBiZSBlbmFibGVkIHRvIGZvcmNlIGl0IGV2ZW4gaWYgYSBjbGFzcyBuYW1lIGlzIHNwZWNpZmllZFxcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChjbGFzc05hbWUgJiYgIW8uZm9yY2VQbGFjZWhvbGRlclNpemUpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vSWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGEgYWN0dWFsIGhlaWdodCBieSBpdHNlbGYgKHdpdGhvdXQgc3R5bGVzIGNvbWluZyBmcm9tIGEgc3R5bGVzaGVldCksIGl0IHJlY2VpdmVzIHRoZSBpbmxpbmUgaGVpZ2h0IGZyb20gdGhlIGRyYWdnZWQgaXRlbVxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICghcC5oZWlnaHQoKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHAuaGVpZ2h0KHRoYXQuY3VycmVudEl0ZW0uaW5uZXJIZWlnaHQoKSAtIHBhcnNlSW50KHRoYXQuY3VycmVudEl0ZW0uY3NzKFxcXCJwYWRkaW5nVG9wXFxcIikgfHwgMCwgMTApIC0gcGFyc2VJbnQodGhhdC5jdXJyZW50SXRlbS5jc3MoXFxcInBhZGRpbmdCb3R0b21cXFwiKSB8fCAwLCAxMCkpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIXAud2lkdGgoKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHAud2lkdGgodGhhdC5jdXJyZW50SXRlbS5pbm5lcldpZHRoKCkgLSBwYXJzZUludCh0aGF0LmN1cnJlbnRJdGVtLmNzcyhcXFwicGFkZGluZ0xlZnRcXFwiKSB8fCAwLCAxMCkgLSBwYXJzZUludCh0aGF0LmN1cnJlbnRJdGVtLmNzcyhcXFwicGFkZGluZ1JpZ2h0XFxcIikgfHwgMCwgMTApKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH07XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vQ3JlYXRlIHRoZSBwbGFjZWhvbGRlclxcblxcdFxcdFxcdHRoYXQucGxhY2Vob2xkZXIgPSAkKG8ucGxhY2Vob2xkZXIuZWxlbWVudC5jYWxsKHRoYXQuZWxlbWVudCwgdGhhdC5jdXJyZW50SXRlbSkpO1xcblxcblxcdFxcdFxcdC8vQXBwZW5kIGl0IGFmdGVyIHRoZSBhY3R1YWwgY3VycmVudCBpdGVtXFxuXFx0XFx0XFx0dGhhdC5jdXJyZW50SXRlbS5hZnRlcih0aGF0LnBsYWNlaG9sZGVyKTtcXG5cXG5cXHRcXHRcXHQvL1VwZGF0ZSB0aGUgc2l6ZSBvZiB0aGUgcGxhY2Vob2xkZXIgKFRPRE86IExvZ2ljIHRvIGZ1enp5LCBzZWUgbGluZSAzMTYvMzE3KVxcblxcdFxcdFxcdG8ucGxhY2Vob2xkZXIudXBkYXRlKHRoYXQsIHRoYXQucGxhY2Vob2xkZXIpO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X2NyZWF0ZVRyUGxhY2Vob2xkZXI6IGZ1bmN0aW9uIF9jcmVhdGVUclBsYWNlaG9sZGVyKHNvdXJjZVRyLCB0YXJnZXRUcikge1xcblxcdFxcdFxcdHZhciB0aGF0ID0gdGhpcztcXG5cXG5cXHRcXHRcXHRzb3VyY2VUci5jaGlsZHJlbigpLmVhY2goZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdCQoXFxcIjx0ZD4mIzE2MDs8L3RkPlxcXCIsIHRoYXQuZG9jdW1lbnRbMF0pLmF0dHIoXFxcImNvbHNwYW5cXFwiLCAkKHRoaXMpLmF0dHIoXFxcImNvbHNwYW5cXFwiKSB8fCAxKS5hcHBlbmRUbyh0YXJnZXRUcik7XFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfY29udGFjdENvbnRhaW5lcnM6IGZ1bmN0aW9uIF9jb250YWN0Q29udGFpbmVycyhldmVudCkge1xcblxcdFxcdFxcdHZhciBpLFxcblxcdFxcdFxcdCAgICBqLFxcblxcdFxcdFxcdCAgICBkaXN0LFxcblxcdFxcdFxcdCAgICBpdGVtV2l0aExlYXN0RGlzdGFuY2UsXFxuXFx0XFx0XFx0ICAgIHBvc1Byb3BlcnR5LFxcblxcdFxcdFxcdCAgICBzaXplUHJvcGVydHksXFxuXFx0XFx0XFx0ICAgIGN1cixcXG5cXHRcXHRcXHQgICAgbmVhckJvdHRvbSxcXG5cXHRcXHRcXHQgICAgZmxvYXRpbmcsXFxuXFx0XFx0XFx0ICAgIGF4aXMsXFxuXFx0XFx0XFx0ICAgIGlubmVybW9zdENvbnRhaW5lciA9IG51bGwsXFxuXFx0XFx0XFx0ICAgIGlubmVybW9zdEluZGV4ID0gbnVsbDtcXG5cXG5cXHRcXHRcXHQvLyBnZXQgaW5uZXJtb3N0IGNvbnRhaW5lciB0aGF0IGludGVyc2VjdHMgd2l0aCBpdGVtXFxuXFx0XFx0XFx0Zm9yIChpID0gdGhpcy5jb250YWluZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gbmV2ZXIgY29uc2lkZXIgYSBjb250YWluZXIgdGhhdCdzIGxvY2F0ZWQgd2l0aGluIHRoZSBpdGVtIGl0c2VsZlxcblxcdFxcdFxcdFxcdGlmICgkLmNvbnRhaW5zKHRoaXMuY3VycmVudEl0ZW1bMF0sIHRoaXMuY29udGFpbmVyc1tpXS5lbGVtZW50WzBdKSkge1xcblxcdFxcdFxcdFxcdFxcdGNvbnRpbnVlO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAodGhpcy5faW50ZXJzZWN0c1dpdGgodGhpcy5jb250YWluZXJzW2ldLmNvbnRhaW5lckNhY2hlKSkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIGlmIHdlJ3ZlIGFscmVhZHkgZm91bmQgYSBjb250YWluZXIgYW5kIGl0J3MgbW9yZSBcXFwiaW5uZXJcXFwiIHRoYW4gdGhpcywgdGhlbiBjb250aW51ZVxcblxcdFxcdFxcdFxcdFxcdGlmIChpbm5lcm1vc3RDb250YWluZXIgJiYgJC5jb250YWlucyh0aGlzLmNvbnRhaW5lcnNbaV0uZWxlbWVudFswXSwgaW5uZXJtb3N0Q29udGFpbmVyLmVsZW1lbnRbMF0pKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y29udGludWU7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdGlubmVybW9zdENvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyc1tpXTtcXG5cXHRcXHRcXHRcXHRcXHRpbm5lcm1vc3RJbmRleCA9IGk7XFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHQvLyBjb250YWluZXIgZG9lc24ndCBpbnRlcnNlY3QuIHRyaWdnZXIgXFxcIm91dFxcXCIgZXZlbnQgaWYgbmVjZXNzYXJ5XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHRoaXMuY29udGFpbmVyc1tpXS5jb250YWluZXJDYWNoZS5vdmVyKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5jb250YWluZXJzW2ldLl90cmlnZ2VyKFxcXCJvdXRcXFwiLCBldmVudCwgdGhpcy5fdWlIYXNoKHRoaXMpKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLmNvbnRhaW5lcnNbaV0uY29udGFpbmVyQ2FjaGUub3ZlciA9IDA7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gaWYgbm8gaW50ZXJzZWN0aW5nIGNvbnRhaW5lcnMgZm91bmQsIHJldHVyblxcblxcdFxcdFxcdGlmICghaW5uZXJtb3N0Q29udGFpbmVyKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBtb3ZlIHRoZSBpdGVtIGludG8gdGhlIGNvbnRhaW5lciBpZiBpdCdzIG5vdCB0aGVyZSBhbHJlYWR5XFxuXFx0XFx0XFx0aWYgKHRoaXMuY29udGFpbmVycy5sZW5ndGggPT09IDEpIHtcXG5cXHRcXHRcXHRcXHRpZiAoIXRoaXMuY29udGFpbmVyc1tpbm5lcm1vc3RJbmRleF0uY29udGFpbmVyQ2FjaGUub3Zlcikge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuY29udGFpbmVyc1tpbm5lcm1vc3RJbmRleF0uX3RyaWdnZXIoXFxcIm92ZXJcXFwiLCBldmVudCwgdGhpcy5fdWlIYXNoKHRoaXMpKTtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmNvbnRhaW5lcnNbaW5uZXJtb3N0SW5kZXhdLmNvbnRhaW5lckNhY2hlLm92ZXIgPSAxO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdC8vV2hlbiBlbnRlcmluZyBhIG5ldyBjb250YWluZXIsIHdlIHdpbGwgZmluZCB0aGUgaXRlbSB3aXRoIHRoZSBsZWFzdCBkaXN0YW5jZSBhbmQgYXBwZW5kIG91ciBpdGVtIG5lYXIgaXRcXG5cXHRcXHRcXHRcXHRkaXN0ID0gMTAwMDA7XFxuXFx0XFx0XFx0XFx0aXRlbVdpdGhMZWFzdERpc3RhbmNlID0gbnVsbDtcXG5cXHRcXHRcXHRcXHRmbG9hdGluZyA9IGlubmVybW9zdENvbnRhaW5lci5mbG9hdGluZyB8fCB0aGlzLl9pc0Zsb2F0aW5nKHRoaXMuY3VycmVudEl0ZW0pO1xcblxcdFxcdFxcdFxcdHBvc1Byb3BlcnR5ID0gZmxvYXRpbmcgPyBcXFwibGVmdFxcXCIgOiBcXFwidG9wXFxcIjtcXG5cXHRcXHRcXHRcXHRzaXplUHJvcGVydHkgPSBmbG9hdGluZyA/IFxcXCJ3aWR0aFxcXCIgOiBcXFwiaGVpZ2h0XFxcIjtcXG5cXHRcXHRcXHRcXHRheGlzID0gZmxvYXRpbmcgPyBcXFwiY2xpZW50WFxcXCIgOiBcXFwiY2xpZW50WVxcXCI7XFxuXFxuXFx0XFx0XFx0XFx0Zm9yIChqID0gdGhpcy5pdGVtcy5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xcblxcdFxcdFxcdFxcdFxcdGlmICghJC5jb250YWlucyh0aGlzLmNvbnRhaW5lcnNbaW5uZXJtb3N0SW5kZXhdLmVsZW1lbnRbMF0sIHRoaXMuaXRlbXNbal0uaXRlbVswXSkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRjb250aW51ZTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHRoaXMuaXRlbXNbal0uaXRlbVswXSA9PT0gdGhpcy5jdXJyZW50SXRlbVswXSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGNvbnRpbnVlO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRjdXIgPSB0aGlzLml0ZW1zW2pdLml0ZW0ub2Zmc2V0KClbcG9zUHJvcGVydHldO1xcblxcdFxcdFxcdFxcdFxcdG5lYXJCb3R0b20gPSBmYWxzZTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoZXZlbnRbYXhpc10gLSBjdXIgPiB0aGlzLml0ZW1zW2pdW3NpemVQcm9wZXJ0eV0gLyAyKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0bmVhckJvdHRvbSA9IHRydWU7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdGlmIChNYXRoLmFicyhldmVudFtheGlzXSAtIGN1cikgPCBkaXN0KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZGlzdCA9IE1hdGguYWJzKGV2ZW50W2F4aXNdIC0gY3VyKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpdGVtV2l0aExlYXN0RGlzdGFuY2UgPSB0aGlzLml0ZW1zW2pdO1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuZGlyZWN0aW9uID0gbmVhckJvdHRvbSA/IFxcXCJ1cFxcXCIgOiBcXFwiZG93blxcXCI7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvL0NoZWNrIGlmIGRyb3BPbkVtcHR5IGlzIGVuYWJsZWRcXG5cXHRcXHRcXHRcXHRpZiAoIWl0ZW1XaXRoTGVhc3REaXN0YW5jZSAmJiAhdGhpcy5vcHRpb25zLmRyb3BPbkVtcHR5KSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAodGhpcy5jdXJyZW50Q29udGFpbmVyID09PSB0aGlzLmNvbnRhaW5lcnNbaW5uZXJtb3N0SW5kZXhdKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCF0aGlzLmN1cnJlbnRDb250YWluZXIuY29udGFpbmVyQ2FjaGUub3Zlcikge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuY29udGFpbmVyc1tpbm5lcm1vc3RJbmRleF0uX3RyaWdnZXIoXFxcIm92ZXJcXFwiLCBldmVudCwgdGhpcy5fdWlIYXNoKCkpO1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuY3VycmVudENvbnRhaW5lci5jb250YWluZXJDYWNoZS5vdmVyID0gMTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpdGVtV2l0aExlYXN0RGlzdGFuY2UgPyB0aGlzLl9yZWFycmFuZ2UoZXZlbnQsIGl0ZW1XaXRoTGVhc3REaXN0YW5jZSwgbnVsbCwgdHJ1ZSkgOiB0aGlzLl9yZWFycmFuZ2UoZXZlbnQsIG51bGwsIHRoaXMuY29udGFpbmVyc1tpbm5lcm1vc3RJbmRleF0uZWxlbWVudCwgdHJ1ZSk7XFxuXFx0XFx0XFx0XFx0dGhpcy5fdHJpZ2dlcihcXFwiY2hhbmdlXFxcIiwgZXZlbnQsIHRoaXMuX3VpSGFzaCgpKTtcXG5cXHRcXHRcXHRcXHR0aGlzLmNvbnRhaW5lcnNbaW5uZXJtb3N0SW5kZXhdLl90cmlnZ2VyKFxcXCJjaGFuZ2VcXFwiLCBldmVudCwgdGhpcy5fdWlIYXNoKHRoaXMpKTtcXG5cXHRcXHRcXHRcXHR0aGlzLmN1cnJlbnRDb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcnNbaW5uZXJtb3N0SW5kZXhdO1xcblxcblxcdFxcdFxcdFxcdC8vVXBkYXRlIHRoZSBwbGFjZWhvbGRlclxcblxcdFxcdFxcdFxcdHRoaXMub3B0aW9ucy5wbGFjZWhvbGRlci51cGRhdGUodGhpcy5jdXJyZW50Q29udGFpbmVyLCB0aGlzLnBsYWNlaG9sZGVyKTtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLmNvbnRhaW5lcnNbaW5uZXJtb3N0SW5kZXhdLl90cmlnZ2VyKFxcXCJvdmVyXFxcIiwgZXZlbnQsIHRoaXMuX3VpSGFzaCh0aGlzKSk7XFxuXFx0XFx0XFx0XFx0dGhpcy5jb250YWluZXJzW2lubmVybW9zdEluZGV4XS5jb250YWluZXJDYWNoZS5vdmVyID0gMTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfY3JlYXRlSGVscGVyOiBmdW5jdGlvbiBfY3JlYXRlSGVscGVyKGV2ZW50KSB7XFxuXFxuXFx0XFx0XFx0dmFyIG8gPSB0aGlzLm9wdGlvbnMsXFxuXFx0XFx0XFx0ICAgIGhlbHBlciA9ICQuaXNGdW5jdGlvbihvLmhlbHBlcikgPyAkKG8uaGVscGVyLmFwcGx5KHRoaXMuZWxlbWVudFswXSwgW2V2ZW50LCB0aGlzLmN1cnJlbnRJdGVtXSkpIDogby5oZWxwZXIgPT09IFxcXCJjbG9uZVxcXCIgPyB0aGlzLmN1cnJlbnRJdGVtLmNsb25lKCkgOiB0aGlzLmN1cnJlbnRJdGVtO1xcblxcblxcdFxcdFxcdC8vQWRkIHRoZSBoZWxwZXIgdG8gdGhlIERPTSBpZiB0aGF0IGRpZG4ndCBoYXBwZW4gYWxyZWFkeVxcblxcdFxcdFxcdGlmICghaGVscGVyLnBhcmVudHMoXFxcImJvZHlcXFwiKS5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHQkKG8uYXBwZW5kVG8gIT09IFxcXCJwYXJlbnRcXFwiID8gby5hcHBlbmRUbyA6IHRoaXMuY3VycmVudEl0ZW1bMF0ucGFyZW50Tm9kZSlbMF0uYXBwZW5kQ2hpbGQoaGVscGVyWzBdKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKGhlbHBlclswXSA9PT0gdGhpcy5jdXJyZW50SXRlbVswXSkge1xcblxcdFxcdFxcdFxcdHRoaXMuX3N0b3JlZENTUyA9IHsgd2lkdGg6IHRoaXMuY3VycmVudEl0ZW1bMF0uc3R5bGUud2lkdGgsIGhlaWdodDogdGhpcy5jdXJyZW50SXRlbVswXS5zdHlsZS5oZWlnaHQsIHBvc2l0aW9uOiB0aGlzLmN1cnJlbnRJdGVtLmNzcyhcXFwicG9zaXRpb25cXFwiKSwgdG9wOiB0aGlzLmN1cnJlbnRJdGVtLmNzcyhcXFwidG9wXFxcIiksIGxlZnQ6IHRoaXMuY3VycmVudEl0ZW0uY3NzKFxcXCJsZWZ0XFxcIikgfTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCFoZWxwZXJbMF0uc3R5bGUud2lkdGggfHwgby5mb3JjZUhlbHBlclNpemUpIHtcXG5cXHRcXHRcXHRcXHRoZWxwZXIud2lkdGgodGhpcy5jdXJyZW50SXRlbS53aWR0aCgpKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKCFoZWxwZXJbMF0uc3R5bGUuaGVpZ2h0IHx8IG8uZm9yY2VIZWxwZXJTaXplKSB7XFxuXFx0XFx0XFx0XFx0aGVscGVyLmhlaWdodCh0aGlzLmN1cnJlbnRJdGVtLmhlaWdodCgpKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGhlbHBlcjtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9hZGp1c3RPZmZzZXRGcm9tSGVscGVyOiBmdW5jdGlvbiBfYWRqdXN0T2Zmc2V0RnJvbUhlbHBlcihvYmopIHtcXG5cXHRcXHRcXHRpZiAodHlwZW9mIG9iaiA9PT0gXFxcInN0cmluZ1xcXCIpIHtcXG5cXHRcXHRcXHRcXHRvYmogPSBvYmouc3BsaXQoXFxcIiBcXFwiKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKCQuaXNBcnJheShvYmopKSB7XFxuXFx0XFx0XFx0XFx0b2JqID0geyBsZWZ0OiArb2JqWzBdLCB0b3A6ICtvYmpbMV0gfHwgMCB9O1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoXFxcImxlZnRcXFwiIGluIG9iaikge1xcblxcdFxcdFxcdFxcdHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQgPSBvYmoubGVmdCArIHRoaXMubWFyZ2lucy5sZWZ0O1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoXFxcInJpZ2h0XFxcIiBpbiBvYmopIHtcXG5cXHRcXHRcXHRcXHR0aGlzLm9mZnNldC5jbGljay5sZWZ0ID0gdGhpcy5oZWxwZXJQcm9wb3J0aW9ucy53aWR0aCAtIG9iai5yaWdodCArIHRoaXMubWFyZ2lucy5sZWZ0O1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoXFxcInRvcFxcXCIgaW4gb2JqKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5vZmZzZXQuY2xpY2sudG9wID0gb2JqLnRvcCArIHRoaXMubWFyZ2lucy50b3A7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmIChcXFwiYm90dG9tXFxcIiBpbiBvYmopIHtcXG5cXHRcXHRcXHRcXHR0aGlzLm9mZnNldC5jbGljay50b3AgPSB0aGlzLmhlbHBlclByb3BvcnRpb25zLmhlaWdodCAtIG9iai5ib3R0b20gKyB0aGlzLm1hcmdpbnMudG9wO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcblxcdFxcdF9nZXRQYXJlbnRPZmZzZXQ6IGZ1bmN0aW9uIF9nZXRQYXJlbnRPZmZzZXQoKSB7XFxuXFxuXFx0XFx0XFx0Ly9HZXQgdGhlIG9mZnNldFBhcmVudCBhbmQgY2FjaGUgaXRzIHBvc2l0aW9uXFxuXFx0XFx0XFx0dGhpcy5vZmZzZXRQYXJlbnQgPSB0aGlzLmhlbHBlci5vZmZzZXRQYXJlbnQoKTtcXG5cXHRcXHRcXHR2YXIgcG8gPSB0aGlzLm9mZnNldFBhcmVudC5vZmZzZXQoKTtcXG5cXG5cXHRcXHRcXHQvLyBUaGlzIGlzIGEgc3BlY2lhbCBjYXNlIHdoZXJlIHdlIG5lZWQgdG8gbW9kaWZ5IGEgb2Zmc2V0IGNhbGN1bGF0ZWQgb24gc3RhcnQsIHNpbmNlIHRoZSBmb2xsb3dpbmcgaGFwcGVuZWQ6XFxuXFx0XFx0XFx0Ly8gMS4gVGhlIHBvc2l0aW9uIG9mIHRoZSBoZWxwZXIgaXMgYWJzb2x1dGUsIHNvIGl0J3MgcG9zaXRpb24gaXMgY2FsY3VsYXRlZCBiYXNlZCBvbiB0aGUgbmV4dCBwb3NpdGlvbmVkIHBhcmVudFxcblxcdFxcdFxcdC8vIDIuIFRoZSBhY3R1YWwgb2Zmc2V0IHBhcmVudCBpcyBhIGNoaWxkIG9mIHRoZSBzY3JvbGwgcGFyZW50LCBhbmQgdGhlIHNjcm9sbCBwYXJlbnQgaXNuJ3QgdGhlIGRvY3VtZW50LCB3aGljaCBtZWFucyB0aGF0XFxuXFx0XFx0XFx0Ly8gICAgdGhlIHNjcm9sbCBpcyBpbmNsdWRlZCBpbiB0aGUgaW5pdGlhbCBjYWxjdWxhdGlvbiBvZiB0aGUgb2Zmc2V0IG9mIHRoZSBwYXJlbnQsIGFuZCBuZXZlciByZWNhbGN1bGF0ZWQgdXBvbiBkcmFnXFxuXFx0XFx0XFx0aWYgKHRoaXMuY3NzUG9zaXRpb24gPT09IFxcXCJhYnNvbHV0ZVxcXCIgJiYgdGhpcy5zY3JvbGxQYXJlbnRbMF0gIT09IHRoaXMuZG9jdW1lbnRbMF0gJiYgJC5jb250YWlucyh0aGlzLnNjcm9sbFBhcmVudFswXSwgdGhpcy5vZmZzZXRQYXJlbnRbMF0pKSB7XFxuXFx0XFx0XFx0XFx0cG8ubGVmdCArPSB0aGlzLnNjcm9sbFBhcmVudC5zY3JvbGxMZWZ0KCk7XFxuXFx0XFx0XFx0XFx0cG8udG9wICs9IHRoaXMuc2Nyb2xsUGFyZW50LnNjcm9sbFRvcCgpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBUaGlzIG5lZWRzIHRvIGJlIGFjdHVhbGx5IGRvbmUgZm9yIGFsbCBicm93c2Vycywgc2luY2UgcGFnZVgvcGFnZVkgaW5jbHVkZXMgdGhpcyBpbmZvcm1hdGlvblxcblxcdFxcdFxcdC8vIHdpdGggYW4gdWdseSBJRSBmaXhcXG5cXHRcXHRcXHRpZiAodGhpcy5vZmZzZXRQYXJlbnRbMF0gPT09IHRoaXMuZG9jdW1lbnRbMF0uYm9keSB8fCB0aGlzLm9mZnNldFBhcmVudFswXS50YWdOYW1lICYmIHRoaXMub2Zmc2V0UGFyZW50WzBdLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXFxcImh0bWxcXFwiICYmICQudWkuaWUpIHtcXG5cXHRcXHRcXHRcXHRwbyA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB7XFxuXFx0XFx0XFx0XFx0dG9wOiBwby50b3AgKyAocGFyc2VJbnQodGhpcy5vZmZzZXRQYXJlbnQuY3NzKFxcXCJib3JkZXJUb3BXaWR0aFxcXCIpLCAxMCkgfHwgMCksXFxuXFx0XFx0XFx0XFx0bGVmdDogcG8ubGVmdCArIChwYXJzZUludCh0aGlzLm9mZnNldFBhcmVudC5jc3MoXFxcImJvcmRlckxlZnRXaWR0aFxcXCIpLCAxMCkgfHwgMClcXG5cXHRcXHRcXHR9O1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X2dldFJlbGF0aXZlT2Zmc2V0OiBmdW5jdGlvbiBfZ2V0UmVsYXRpdmVPZmZzZXQoKSB7XFxuXFxuXFx0XFx0XFx0aWYgKHRoaXMuY3NzUG9zaXRpb24gPT09IFxcXCJyZWxhdGl2ZVxcXCIpIHtcXG5cXHRcXHRcXHRcXHR2YXIgcCA9IHRoaXMuY3VycmVudEl0ZW0ucG9zaXRpb24oKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4ge1xcblxcdFxcdFxcdFxcdFxcdHRvcDogcC50b3AgLSAocGFyc2VJbnQodGhpcy5oZWxwZXIuY3NzKFxcXCJ0b3BcXFwiKSwgMTApIHx8IDApICsgdGhpcy5zY3JvbGxQYXJlbnQuc2Nyb2xsVG9wKCksXFxuXFx0XFx0XFx0XFx0XFx0bGVmdDogcC5sZWZ0IC0gKHBhcnNlSW50KHRoaXMuaGVscGVyLmNzcyhcXFwibGVmdFxcXCIpLCAxMCkgfHwgMCkgKyB0aGlzLnNjcm9sbFBhcmVudC5zY3JvbGxMZWZ0KClcXG5cXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHsgdG9wOiAwLCBsZWZ0OiAwIH07XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFxuXFx0XFx0X2NhY2hlTWFyZ2luczogZnVuY3Rpb24gX2NhY2hlTWFyZ2lucygpIHtcXG5cXHRcXHRcXHR0aGlzLm1hcmdpbnMgPSB7XFxuXFx0XFx0XFx0XFx0bGVmdDogcGFyc2VJbnQodGhpcy5jdXJyZW50SXRlbS5jc3MoXFxcIm1hcmdpbkxlZnRcXFwiKSwgMTApIHx8IDAsXFxuXFx0XFx0XFx0XFx0dG9wOiBwYXJzZUludCh0aGlzLmN1cnJlbnRJdGVtLmNzcyhcXFwibWFyZ2luVG9wXFxcIiksIDEwKSB8fCAwXFxuXFx0XFx0XFx0fTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9jYWNoZUhlbHBlclByb3BvcnRpb25zOiBmdW5jdGlvbiBfY2FjaGVIZWxwZXJQcm9wb3J0aW9ucygpIHtcXG5cXHRcXHRcXHR0aGlzLmhlbHBlclByb3BvcnRpb25zID0ge1xcblxcdFxcdFxcdFxcdHdpZHRoOiB0aGlzLmhlbHBlci5vdXRlcldpZHRoKCksXFxuXFx0XFx0XFx0XFx0aGVpZ2h0OiB0aGlzLmhlbHBlci5vdXRlckhlaWdodCgpXFxuXFx0XFx0XFx0fTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9zZXRDb250YWlubWVudDogZnVuY3Rpb24gX3NldENvbnRhaW5tZW50KCkge1xcblxcblxcdFxcdFxcdHZhciBjZSxcXG5cXHRcXHRcXHQgICAgY28sXFxuXFx0XFx0XFx0ICAgIG92ZXIsXFxuXFx0XFx0XFx0ICAgIG8gPSB0aGlzLm9wdGlvbnM7XFxuXFx0XFx0XFx0aWYgKG8uY29udGFpbm1lbnQgPT09IFxcXCJwYXJlbnRcXFwiKSB7XFxuXFx0XFx0XFx0XFx0by5jb250YWlubWVudCA9IHRoaXMuaGVscGVyWzBdLnBhcmVudE5vZGU7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmIChvLmNvbnRhaW5tZW50ID09PSBcXFwiZG9jdW1lbnRcXFwiIHx8IG8uY29udGFpbm1lbnQgPT09IFxcXCJ3aW5kb3dcXFwiKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5jb250YWlubWVudCA9IFswIC0gdGhpcy5vZmZzZXQucmVsYXRpdmUubGVmdCAtIHRoaXMub2Zmc2V0LnBhcmVudC5sZWZ0LCAwIC0gdGhpcy5vZmZzZXQucmVsYXRpdmUudG9wIC0gdGhpcy5vZmZzZXQucGFyZW50LnRvcCwgby5jb250YWlubWVudCA9PT0gXFxcImRvY3VtZW50XFxcIiA/IHRoaXMuZG9jdW1lbnQud2lkdGgoKSA6IHRoaXMud2luZG93LndpZHRoKCkgLSB0aGlzLmhlbHBlclByb3BvcnRpb25zLndpZHRoIC0gdGhpcy5tYXJnaW5zLmxlZnQsIChvLmNvbnRhaW5tZW50ID09PSBcXFwiZG9jdW1lbnRcXFwiID8gdGhpcy5kb2N1bWVudC53aWR0aCgpIDogdGhpcy53aW5kb3cuaGVpZ2h0KCkgfHwgdGhpcy5kb2N1bWVudFswXS5ib2R5LnBhcmVudE5vZGUuc2Nyb2xsSGVpZ2h0KSAtIHRoaXMuaGVscGVyUHJvcG9ydGlvbnMuaGVpZ2h0IC0gdGhpcy5tYXJnaW5zLnRvcF07XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICghL14oZG9jdW1lbnR8d2luZG93fHBhcmVudCkkLy50ZXN0KG8uY29udGFpbm1lbnQpKSB7XFxuXFx0XFx0XFx0XFx0Y2UgPSAkKG8uY29udGFpbm1lbnQpWzBdO1xcblxcdFxcdFxcdFxcdGNvID0gJChvLmNvbnRhaW5tZW50KS5vZmZzZXQoKTtcXG5cXHRcXHRcXHRcXHRvdmVyID0gJChjZSkuY3NzKFxcXCJvdmVyZmxvd1xcXCIpICE9PSBcXFwiaGlkZGVuXFxcIjtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLmNvbnRhaW5tZW50ID0gW2NvLmxlZnQgKyAocGFyc2VJbnQoJChjZSkuY3NzKFxcXCJib3JkZXJMZWZ0V2lkdGhcXFwiKSwgMTApIHx8IDApICsgKHBhcnNlSW50KCQoY2UpLmNzcyhcXFwicGFkZGluZ0xlZnRcXFwiKSwgMTApIHx8IDApIC0gdGhpcy5tYXJnaW5zLmxlZnQsIGNvLnRvcCArIChwYXJzZUludCgkKGNlKS5jc3MoXFxcImJvcmRlclRvcFdpZHRoXFxcIiksIDEwKSB8fCAwKSArIChwYXJzZUludCgkKGNlKS5jc3MoXFxcInBhZGRpbmdUb3BcXFwiKSwgMTApIHx8IDApIC0gdGhpcy5tYXJnaW5zLnRvcCwgY28ubGVmdCArIChvdmVyID8gTWF0aC5tYXgoY2Uuc2Nyb2xsV2lkdGgsIGNlLm9mZnNldFdpZHRoKSA6IGNlLm9mZnNldFdpZHRoKSAtIChwYXJzZUludCgkKGNlKS5jc3MoXFxcImJvcmRlckxlZnRXaWR0aFxcXCIpLCAxMCkgfHwgMCkgLSAocGFyc2VJbnQoJChjZSkuY3NzKFxcXCJwYWRkaW5nUmlnaHRcXFwiKSwgMTApIHx8IDApIC0gdGhpcy5oZWxwZXJQcm9wb3J0aW9ucy53aWR0aCAtIHRoaXMubWFyZ2lucy5sZWZ0LCBjby50b3AgKyAob3ZlciA/IE1hdGgubWF4KGNlLnNjcm9sbEhlaWdodCwgY2Uub2Zmc2V0SGVpZ2h0KSA6IGNlLm9mZnNldEhlaWdodCkgLSAocGFyc2VJbnQoJChjZSkuY3NzKFxcXCJib3JkZXJUb3BXaWR0aFxcXCIpLCAxMCkgfHwgMCkgLSAocGFyc2VJbnQoJChjZSkuY3NzKFxcXCJwYWRkaW5nQm90dG9tXFxcIiksIDEwKSB8fCAwKSAtIHRoaXMuaGVscGVyUHJvcG9ydGlvbnMuaGVpZ2h0IC0gdGhpcy5tYXJnaW5zLnRvcF07XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFxuXFx0XFx0X2NvbnZlcnRQb3NpdGlvblRvOiBmdW5jdGlvbiBfY29udmVydFBvc2l0aW9uVG8oZCwgcG9zKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCFwb3MpIHtcXG5cXHRcXHRcXHRcXHRwb3MgPSB0aGlzLnBvc2l0aW9uO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR2YXIgbW9kID0gZCA9PT0gXFxcImFic29sdXRlXFxcIiA/IDEgOiAtMSxcXG5cXHRcXHRcXHQgICAgc2Nyb2xsID0gdGhpcy5jc3NQb3NpdGlvbiA9PT0gXFxcImFic29sdXRlXFxcIiAmJiAhKHRoaXMuc2Nyb2xsUGFyZW50WzBdICE9PSB0aGlzLmRvY3VtZW50WzBdICYmICQuY29udGFpbnModGhpcy5zY3JvbGxQYXJlbnRbMF0sIHRoaXMub2Zmc2V0UGFyZW50WzBdKSkgPyB0aGlzLm9mZnNldFBhcmVudCA6IHRoaXMuc2Nyb2xsUGFyZW50LFxcblxcdFxcdFxcdCAgICBzY3JvbGxJc1Jvb3ROb2RlID0gLyhodG1sfGJvZHkpL2kudGVzdChzY3JvbGxbMF0udGFnTmFtZSk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHtcXG5cXHRcXHRcXHRcXHR0b3A6IHBvcy50b3AgKyAvLyBUaGUgYWJzb2x1dGUgbW91c2UgcG9zaXRpb25cXG5cXHRcXHRcXHRcXHR0aGlzLm9mZnNldC5yZWxhdGl2ZS50b3AgKiBtb2QgKyAvLyBPbmx5IGZvciByZWxhdGl2ZSBwb3NpdGlvbmVkIG5vZGVzOiBSZWxhdGl2ZSBvZmZzZXQgZnJvbSBlbGVtZW50IHRvIG9mZnNldCBwYXJlbnRcXG5cXHRcXHRcXHRcXHR0aGlzLm9mZnNldC5wYXJlbnQudG9wICogbW9kIC0gLy8gVGhlIG9mZnNldFBhcmVudCdzIG9mZnNldCB3aXRob3V0IGJvcmRlcnMgKG9mZnNldCArIGJvcmRlcilcXG5cXHRcXHRcXHRcXHQodGhpcy5jc3NQb3NpdGlvbiA9PT0gXFxcImZpeGVkXFxcIiA/IC10aGlzLnNjcm9sbFBhcmVudC5zY3JvbGxUb3AoKSA6IHNjcm9sbElzUm9vdE5vZGUgPyAwIDogc2Nyb2xsLnNjcm9sbFRvcCgpKSAqIG1vZCxcXG5cXHRcXHRcXHRcXHRsZWZ0OiBwb3MubGVmdCArIC8vIFRoZSBhYnNvbHV0ZSBtb3VzZSBwb3NpdGlvblxcblxcdFxcdFxcdFxcdHRoaXMub2Zmc2V0LnJlbGF0aXZlLmxlZnQgKiBtb2QgKyAvLyBPbmx5IGZvciByZWxhdGl2ZSBwb3NpdGlvbmVkIG5vZGVzOiBSZWxhdGl2ZSBvZmZzZXQgZnJvbSBlbGVtZW50IHRvIG9mZnNldCBwYXJlbnRcXG5cXHRcXHRcXHRcXHR0aGlzLm9mZnNldC5wYXJlbnQubGVmdCAqIG1vZCAtIC8vIFRoZSBvZmZzZXRQYXJlbnQncyBvZmZzZXQgd2l0aG91dCBib3JkZXJzIChvZmZzZXQgKyBib3JkZXIpXFxuXFx0XFx0XFx0XFx0KHRoaXMuY3NzUG9zaXRpb24gPT09IFxcXCJmaXhlZFxcXCIgPyAtdGhpcy5zY3JvbGxQYXJlbnQuc2Nyb2xsTGVmdCgpIDogc2Nyb2xsSXNSb290Tm9kZSA/IDAgOiBzY3JvbGwuc2Nyb2xsTGVmdCgpKSAqIG1vZFxcblxcdFxcdFxcdH07XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfZ2VuZXJhdGVQb3NpdGlvbjogZnVuY3Rpb24gX2dlbmVyYXRlUG9zaXRpb24oZXZlbnQpIHtcXG5cXG5cXHRcXHRcXHR2YXIgdG9wLFxcblxcdFxcdFxcdCAgICBsZWZ0LFxcblxcdFxcdFxcdCAgICBvID0gdGhpcy5vcHRpb25zLFxcblxcdFxcdFxcdCAgICBwYWdlWCA9IGV2ZW50LnBhZ2VYLFxcblxcdFxcdFxcdCAgICBwYWdlWSA9IGV2ZW50LnBhZ2VZLFxcblxcdFxcdFxcdCAgICBzY3JvbGwgPSB0aGlzLmNzc1Bvc2l0aW9uID09PSBcXFwiYWJzb2x1dGVcXFwiICYmICEodGhpcy5zY3JvbGxQYXJlbnRbMF0gIT09IHRoaXMuZG9jdW1lbnRbMF0gJiYgJC5jb250YWlucyh0aGlzLnNjcm9sbFBhcmVudFswXSwgdGhpcy5vZmZzZXRQYXJlbnRbMF0pKSA/IHRoaXMub2Zmc2V0UGFyZW50IDogdGhpcy5zY3JvbGxQYXJlbnQsXFxuXFx0XFx0XFx0ICAgIHNjcm9sbElzUm9vdE5vZGUgPSAvKGh0bWx8Ym9keSkvaS50ZXN0KHNjcm9sbFswXS50YWdOYW1lKTtcXG5cXG5cXHRcXHRcXHQvLyBUaGlzIGlzIGFub3RoZXIgdmVyeSB3ZWlyZCBzcGVjaWFsIGNhc2UgdGhhdCBvbmx5IGhhcHBlbnMgZm9yIHJlbGF0aXZlIGVsZW1lbnRzOlxcblxcdFxcdFxcdC8vIDEuIElmIHRoZSBjc3MgcG9zaXRpb24gaXMgcmVsYXRpdmVcXG5cXHRcXHRcXHQvLyAyLiBhbmQgdGhlIHNjcm9sbCBwYXJlbnQgaXMgdGhlIGRvY3VtZW50IG9yIHNpbWlsYXIgdG8gdGhlIG9mZnNldCBwYXJlbnRcXG5cXHRcXHRcXHQvLyB3ZSBoYXZlIHRvIHJlZnJlc2ggdGhlIHJlbGF0aXZlIG9mZnNldCBkdXJpbmcgdGhlIHNjcm9sbCBzbyB0aGVyZSBhcmUgbm8ganVtcHNcXG5cXHRcXHRcXHRpZiAodGhpcy5jc3NQb3NpdGlvbiA9PT0gXFxcInJlbGF0aXZlXFxcIiAmJiAhKHRoaXMuc2Nyb2xsUGFyZW50WzBdICE9PSB0aGlzLmRvY3VtZW50WzBdICYmIHRoaXMuc2Nyb2xsUGFyZW50WzBdICE9PSB0aGlzLm9mZnNldFBhcmVudFswXSkpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLm9mZnNldC5yZWxhdGl2ZSA9IHRoaXMuX2dldFJlbGF0aXZlT2Zmc2V0KCk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8qXFxuICAgICogLSBQb3NpdGlvbiBjb25zdHJhaW5pbmcgLVxcbiAgICAqIENvbnN0cmFpbiB0aGUgcG9zaXRpb24gdG8gYSBtaXggb2YgZ3JpZCwgY29udGFpbm1lbnQuXFxuICAgICovXFxuXFxuXFx0XFx0XFx0aWYgKHRoaXMub3JpZ2luYWxQb3NpdGlvbikge1xcblxcdFxcdFxcdFxcdC8vSWYgd2UgYXJlIG5vdCBkcmFnZ2luZyB5ZXQsIHdlIHdvbid0IGNoZWNrIGZvciBvcHRpb25zXFxuXFxuXFx0XFx0XFx0XFx0aWYgKHRoaXMuY29udGFpbm1lbnQpIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoZXZlbnQucGFnZVggLSB0aGlzLm9mZnNldC5jbGljay5sZWZ0IDwgdGhpcy5jb250YWlubWVudFswXSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHBhZ2VYID0gdGhpcy5jb250YWlubWVudFswXSArIHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQ7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmIChldmVudC5wYWdlWSAtIHRoaXMub2Zmc2V0LmNsaWNrLnRvcCA8IHRoaXMuY29udGFpbm1lbnRbMV0pIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRwYWdlWSA9IHRoaXMuY29udGFpbm1lbnRbMV0gKyB0aGlzLm9mZnNldC5jbGljay50b3A7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGlmIChldmVudC5wYWdlWCAtIHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQgPiB0aGlzLmNvbnRhaW5tZW50WzJdKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cGFnZVggPSB0aGlzLmNvbnRhaW5tZW50WzJdICsgdGhpcy5vZmZzZXQuY2xpY2subGVmdDtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGV2ZW50LnBhZ2VZIC0gdGhpcy5vZmZzZXQuY2xpY2sudG9wID4gdGhpcy5jb250YWlubWVudFszXSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHBhZ2VZID0gdGhpcy5jb250YWlubWVudFszXSArIHRoaXMub2Zmc2V0LmNsaWNrLnRvcDtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmIChvLmdyaWQpIHtcXG5cXHRcXHRcXHRcXHRcXHR0b3AgPSB0aGlzLm9yaWdpbmFsUGFnZVkgKyBNYXRoLnJvdW5kKChwYWdlWSAtIHRoaXMub3JpZ2luYWxQYWdlWSkgLyBvLmdyaWRbMV0pICogby5ncmlkWzFdO1xcblxcdFxcdFxcdFxcdFxcdHBhZ2VZID0gdGhpcy5jb250YWlubWVudCA/IHRvcCAtIHRoaXMub2Zmc2V0LmNsaWNrLnRvcCA+PSB0aGlzLmNvbnRhaW5tZW50WzFdICYmIHRvcCAtIHRoaXMub2Zmc2V0LmNsaWNrLnRvcCA8PSB0aGlzLmNvbnRhaW5tZW50WzNdID8gdG9wIDogdG9wIC0gdGhpcy5vZmZzZXQuY2xpY2sudG9wID49IHRoaXMuY29udGFpbm1lbnRbMV0gPyB0b3AgLSBvLmdyaWRbMV0gOiB0b3AgKyBvLmdyaWRbMV0gOiB0b3A7XFxuXFxuXFx0XFx0XFx0XFx0XFx0bGVmdCA9IHRoaXMub3JpZ2luYWxQYWdlWCArIE1hdGgucm91bmQoKHBhZ2VYIC0gdGhpcy5vcmlnaW5hbFBhZ2VYKSAvIG8uZ3JpZFswXSkgKiBvLmdyaWRbMF07XFxuXFx0XFx0XFx0XFx0XFx0cGFnZVggPSB0aGlzLmNvbnRhaW5tZW50ID8gbGVmdCAtIHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQgPj0gdGhpcy5jb250YWlubWVudFswXSAmJiBsZWZ0IC0gdGhpcy5vZmZzZXQuY2xpY2subGVmdCA8PSB0aGlzLmNvbnRhaW5tZW50WzJdID8gbGVmdCA6IGxlZnQgLSB0aGlzLm9mZnNldC5jbGljay5sZWZ0ID49IHRoaXMuY29udGFpbm1lbnRbMF0gPyBsZWZ0IC0gby5ncmlkWzBdIDogbGVmdCArIG8uZ3JpZFswXSA6IGxlZnQ7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4ge1xcblxcdFxcdFxcdFxcdHRvcDogcGFnZVkgLSAvLyBUaGUgYWJzb2x1dGUgbW91c2UgcG9zaXRpb25cXG5cXHRcXHRcXHRcXHR0aGlzLm9mZnNldC5jbGljay50b3AgLSAvLyBDbGljayBvZmZzZXQgKHJlbGF0aXZlIHRvIHRoZSBlbGVtZW50KVxcblxcdFxcdFxcdFxcdHRoaXMub2Zmc2V0LnJlbGF0aXZlLnRvcCAtIC8vIE9ubHkgZm9yIHJlbGF0aXZlIHBvc2l0aW9uZWQgbm9kZXM6IFJlbGF0aXZlIG9mZnNldCBmcm9tIGVsZW1lbnQgdG8gb2Zmc2V0IHBhcmVudFxcblxcdFxcdFxcdFxcdHRoaXMub2Zmc2V0LnBhcmVudC50b3AgKyAoIC8vIFRoZSBvZmZzZXRQYXJlbnQncyBvZmZzZXQgd2l0aG91dCBib3JkZXJzIChvZmZzZXQgKyBib3JkZXIpXFxuXFx0XFx0XFx0XFx0dGhpcy5jc3NQb3NpdGlvbiA9PT0gXFxcImZpeGVkXFxcIiA/IC10aGlzLnNjcm9sbFBhcmVudC5zY3JvbGxUb3AoKSA6IHNjcm9sbElzUm9vdE5vZGUgPyAwIDogc2Nyb2xsLnNjcm9sbFRvcCgpKSxcXG5cXHRcXHRcXHRcXHRsZWZ0OiBwYWdlWCAtIC8vIFRoZSBhYnNvbHV0ZSBtb3VzZSBwb3NpdGlvblxcblxcdFxcdFxcdFxcdHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQgLSAvLyBDbGljayBvZmZzZXQgKHJlbGF0aXZlIHRvIHRoZSBlbGVtZW50KVxcblxcdFxcdFxcdFxcdHRoaXMub2Zmc2V0LnJlbGF0aXZlLmxlZnQgLSAvLyBPbmx5IGZvciByZWxhdGl2ZSBwb3NpdGlvbmVkIG5vZGVzOiBSZWxhdGl2ZSBvZmZzZXQgZnJvbSBlbGVtZW50IHRvIG9mZnNldCBwYXJlbnRcXG5cXHRcXHRcXHRcXHR0aGlzLm9mZnNldC5wYXJlbnQubGVmdCArICggLy8gVGhlIG9mZnNldFBhcmVudCdzIG9mZnNldCB3aXRob3V0IGJvcmRlcnMgKG9mZnNldCArIGJvcmRlcilcXG5cXHRcXHRcXHRcXHR0aGlzLmNzc1Bvc2l0aW9uID09PSBcXFwiZml4ZWRcXFwiID8gLXRoaXMuc2Nyb2xsUGFyZW50LnNjcm9sbExlZnQoKSA6IHNjcm9sbElzUm9vdE5vZGUgPyAwIDogc2Nyb2xsLnNjcm9sbExlZnQoKSlcXG5cXHRcXHRcXHR9O1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X3JlYXJyYW5nZTogZnVuY3Rpb24gX3JlYXJyYW5nZShldmVudCwgaSwgYSwgaGFyZFJlZnJlc2gpIHtcXG5cXG5cXHRcXHRcXHRhID8gYVswXS5hcHBlbmRDaGlsZCh0aGlzLnBsYWNlaG9sZGVyWzBdKSA6IGkuaXRlbVswXS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLnBsYWNlaG9sZGVyWzBdLCB0aGlzLmRpcmVjdGlvbiA9PT0gXFxcImRvd25cXFwiID8gaS5pdGVtWzBdIDogaS5pdGVtWzBdLm5leHRTaWJsaW5nKTtcXG5cXG5cXHRcXHRcXHQvL1ZhcmlvdXMgdGhpbmdzIGRvbmUgaGVyZSB0byBpbXByb3ZlIHRoZSBwZXJmb3JtYW5jZTpcXG5cXHRcXHRcXHQvLyAxLiB3ZSBjcmVhdGUgYSBzZXRUaW1lb3V0LCB0aGF0IGNhbGxzIHJlZnJlc2hQb3NpdGlvbnNcXG5cXHRcXHRcXHQvLyAyLiBvbiB0aGUgaW5zdGFuY2UsIHdlIGhhdmUgYSBjb3VudGVyIHZhcmlhYmxlLCB0aGF0IGdldCdzIGhpZ2hlciBhZnRlciBldmVyeSBhcHBlbmRcXG5cXHRcXHRcXHQvLyAzLiBvbiB0aGUgbG9jYWwgc2NvcGUsIHdlIGNvcHkgdGhlIGNvdW50ZXIgdmFyaWFibGUsIGFuZCBjaGVjayBpbiB0aGUgdGltZW91dCwgaWYgaXQncyBzdGlsbCB0aGUgc2FtZVxcblxcdFxcdFxcdC8vIDQuIHRoaXMgbGV0cyBvbmx5IHRoZSBsYXN0IGFkZGl0aW9uIHRvIHRoZSB0aW1lb3V0IHN0YWNrIHRocm91Z2hcXG5cXHRcXHRcXHR0aGlzLmNvdW50ZXIgPSB0aGlzLmNvdW50ZXIgPyArK3RoaXMuY291bnRlciA6IDE7XFxuXFx0XFx0XFx0dmFyIGNvdW50ZXIgPSB0aGlzLmNvdW50ZXI7XFxuXFxuXFx0XFx0XFx0dGhpcy5fZGVsYXkoZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdGlmIChjb3VudGVyID09PSB0aGlzLmNvdW50ZXIpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnJlZnJlc2hQb3NpdGlvbnMoIWhhcmRSZWZyZXNoKTsgLy9QcmVjb21wdXRlIGFmdGVyIGVhY2ggRE9NIGluc2VydGlvbiwgTk9UIG9uIG1vdXNlbW92ZVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9jbGVhcjogZnVuY3Rpb24gX2NsZWFyKGV2ZW50LCBub1Byb3BhZ2F0aW9uKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5yZXZlcnRpbmcgPSBmYWxzZTtcXG5cXHRcXHRcXHQvLyBXZSBkZWxheSBhbGwgZXZlbnRzIHRoYXQgaGF2ZSB0byBiZSB0cmlnZ2VyZWQgdG8gYWZ0ZXIgdGhlIHBvaW50IHdoZXJlIHRoZSBwbGFjZWhvbGRlciBoYXMgYmVlbiByZW1vdmVkIGFuZFxcblxcdFxcdFxcdC8vIGV2ZXJ5dGhpbmcgZWxzZSBub3JtYWxpemVkIGFnYWluXFxuXFx0XFx0XFx0dmFyIGksXFxuXFx0XFx0XFx0ICAgIGRlbGF5ZWRUcmlnZ2VycyA9IFtdO1xcblxcblxcdFxcdFxcdC8vIFdlIGZpcnN0IGhhdmUgdG8gdXBkYXRlIHRoZSBkb20gcG9zaXRpb24gb2YgdGhlIGFjdHVhbCBjdXJyZW50SXRlbVxcblxcdFxcdFxcdC8vIE5vdGU6IGRvbid0IGRvIGl0IGlmIHRoZSBjdXJyZW50IGl0ZW0gaXMgYWxyZWFkeSByZW1vdmVkIChieSBhIHVzZXIpLCBvciBpdCBnZXRzIHJlYXBwZW5kZWQgKHNlZSAjNDA4OClcXG5cXHRcXHRcXHRpZiAoIXRoaXMuX25vRmluYWxTb3J0ICYmIHRoaXMuY3VycmVudEl0ZW0ucGFyZW50KCkubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5wbGFjZWhvbGRlci5iZWZvcmUodGhpcy5jdXJyZW50SXRlbSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHRoaXMuX25vRmluYWxTb3J0ID0gbnVsbDtcXG5cXG5cXHRcXHRcXHRpZiAodGhpcy5oZWxwZXJbMF0gPT09IHRoaXMuY3VycmVudEl0ZW1bMF0pIHtcXG5cXHRcXHRcXHRcXHRmb3IgKGkgaW4gdGhpcy5fc3RvcmVkQ1NTKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHRoaXMuX3N0b3JlZENTU1tpXSA9PT0gXFxcImF1dG9cXFwiIHx8IHRoaXMuX3N0b3JlZENTU1tpXSA9PT0gXFxcInN0YXRpY1xcXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl9zdG9yZWRDU1NbaV0gPSBcXFwiXFxcIjtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHRoaXMuY3VycmVudEl0ZW0uY3NzKHRoaXMuX3N0b3JlZENTUykucmVtb3ZlQ2xhc3MoXFxcInVpLXNvcnRhYmxlLWhlbHBlclxcXCIpO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5jdXJyZW50SXRlbS5zaG93KCk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICh0aGlzLmZyb21PdXRzaWRlICYmICFub1Byb3BhZ2F0aW9uKSB7XFxuXFx0XFx0XFx0XFx0ZGVsYXllZFRyaWdnZXJzLnB1c2goZnVuY3Rpb24gKGV2ZW50KSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fdHJpZ2dlcihcXFwicmVjZWl2ZVxcXCIsIGV2ZW50LCB0aGlzLl91aUhhc2godGhpcy5mcm9tT3V0c2lkZSkpO1xcblxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoKHRoaXMuZnJvbU91dHNpZGUgfHwgdGhpcy5kb21Qb3NpdGlvbi5wcmV2ICE9PSB0aGlzLmN1cnJlbnRJdGVtLnByZXYoKS5ub3QoXFxcIi51aS1zb3J0YWJsZS1oZWxwZXJcXFwiKVswXSB8fCB0aGlzLmRvbVBvc2l0aW9uLnBhcmVudCAhPT0gdGhpcy5jdXJyZW50SXRlbS5wYXJlbnQoKVswXSkgJiYgIW5vUHJvcGFnYXRpb24pIHtcXG5cXHRcXHRcXHRcXHRkZWxheWVkVHJpZ2dlcnMucHVzaChmdW5jdGlvbiAoZXZlbnQpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl90cmlnZ2VyKFxcXCJ1cGRhdGVcXFwiLCBldmVudCwgdGhpcy5fdWlIYXNoKCkpO1xcblxcdFxcdFxcdFxcdH0pOyAvL1RyaWdnZXIgdXBkYXRlIGNhbGxiYWNrIGlmIHRoZSBET00gcG9zaXRpb24gaGFzIGNoYW5nZWRcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gQ2hlY2sgaWYgdGhlIGl0ZW1zIENvbnRhaW5lciBoYXMgQ2hhbmdlZCBhbmQgdHJpZ2dlciBhcHByb3ByaWF0ZVxcblxcdFxcdFxcdC8vIGV2ZW50cy5cXG5cXHRcXHRcXHRpZiAodGhpcyAhPT0gdGhpcy5jdXJyZW50Q29udGFpbmVyKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCFub1Byb3BhZ2F0aW9uKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZGVsYXllZFRyaWdnZXJzLnB1c2goZnVuY3Rpb24gKGV2ZW50KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5fdHJpZ2dlcihcXFwicmVtb3ZlXFxcIiwgZXZlbnQsIHRoaXMuX3VpSGFzaCgpKTtcXG5cXHRcXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcXHRcXHRkZWxheWVkVHJpZ2dlcnMucHVzaChmdW5jdGlvbiAoYykge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjLl90cmlnZ2VyKFxcXCJyZWNlaXZlXFxcIiwgZXZlbnQsIHRoaXMuX3VpSGFzaCh0aGlzKSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fTtcXG5cXHRcXHRcXHRcXHRcXHR9LmNhbGwodGhpcywgdGhpcy5jdXJyZW50Q29udGFpbmVyKSk7XFxuXFx0XFx0XFx0XFx0XFx0ZGVsYXllZFRyaWdnZXJzLnB1c2goZnVuY3Rpb24gKGMpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Yy5fdHJpZ2dlcihcXFwidXBkYXRlXFxcIiwgZXZlbnQsIHRoaXMuX3VpSGFzaCh0aGlzKSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fTtcXG5cXHRcXHRcXHRcXHRcXHR9LmNhbGwodGhpcywgdGhpcy5jdXJyZW50Q29udGFpbmVyKSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvL1Bvc3QgZXZlbnRzIHRvIGNvbnRhaW5lcnNcXG5cXHRcXHRcXHRmdW5jdGlvbiBkZWxheUV2ZW50KHR5cGUsIGluc3RhbmNlLCBjb250YWluZXIpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XFxuXFx0XFx0XFx0XFx0XFx0Y29udGFpbmVyLl90cmlnZ2VyKHR5cGUsIGV2ZW50LCBpbnN0YW5jZS5fdWlIYXNoKGluc3RhbmNlKSk7XFxuXFx0XFx0XFx0XFx0fTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0Zm9yIChpID0gdGhpcy5jb250YWluZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCFub1Byb3BhZ2F0aW9uKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZGVsYXllZFRyaWdnZXJzLnB1c2goZGVsYXlFdmVudChcXFwiZGVhY3RpdmF0ZVxcXCIsIHRoaXMsIHRoaXMuY29udGFpbmVyc1tpXSkpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRpZiAodGhpcy5jb250YWluZXJzW2ldLmNvbnRhaW5lckNhY2hlLm92ZXIpIHtcXG5cXHRcXHRcXHRcXHRcXHRkZWxheWVkVHJpZ2dlcnMucHVzaChkZWxheUV2ZW50KFxcXCJvdXRcXFwiLCB0aGlzLCB0aGlzLmNvbnRhaW5lcnNbaV0pKTtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmNvbnRhaW5lcnNbaV0uY29udGFpbmVyQ2FjaGUub3ZlciA9IDA7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvL0RvIHdoYXQgd2FzIG9yaWdpbmFsbHkgaW4gcGx1Z2luc1xcblxcdFxcdFxcdGlmICh0aGlzLnN0b3JlZEN1cnNvcikge1xcblxcdFxcdFxcdFxcdHRoaXMuZG9jdW1lbnQuZmluZChcXFwiYm9keVxcXCIpLmNzcyhcXFwiY3Vyc29yXFxcIiwgdGhpcy5zdG9yZWRDdXJzb3IpO1xcblxcdFxcdFxcdFxcdHRoaXMuc3RvcmVkU3R5bGVzaGVldC5yZW1vdmUoKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKHRoaXMuX3N0b3JlZE9wYWNpdHkpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLmhlbHBlci5jc3MoXFxcIm9wYWNpdHlcXFwiLCB0aGlzLl9zdG9yZWRPcGFjaXR5KTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKHRoaXMuX3N0b3JlZFpJbmRleCkge1xcblxcdFxcdFxcdFxcdHRoaXMuaGVscGVyLmNzcyhcXFwiekluZGV4XFxcIiwgdGhpcy5fc3RvcmVkWkluZGV4ID09PSBcXFwiYXV0b1xcXCIgPyBcXFwiXFxcIiA6IHRoaXMuX3N0b3JlZFpJbmRleCk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcXG5cXG5cXHRcXHRcXHRpZiAoIW5vUHJvcGFnYXRpb24pIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl90cmlnZ2VyKFxcXCJiZWZvcmVTdG9wXFxcIiwgZXZlbnQsIHRoaXMuX3VpSGFzaCgpKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8kKHRoaXMucGxhY2Vob2xkZXJbMF0pLnJlbW92ZSgpOyB3b3VsZCBoYXZlIGJlZW4gdGhlIGpRdWVyeSB3YXkgLSB1bmZvcnR1bmF0ZWx5LCBpdCB1bmJpbmRzIEFMTCBldmVudHMgZnJvbSB0aGUgb3JpZ2luYWwgbm9kZSFcXG5cXHRcXHRcXHR0aGlzLnBsYWNlaG9sZGVyWzBdLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5wbGFjZWhvbGRlclswXSk7XFxuXFxuXFx0XFx0XFx0aWYgKCF0aGlzLmNhbmNlbEhlbHBlclJlbW92YWwpIHtcXG5cXHRcXHRcXHRcXHRpZiAodGhpcy5oZWxwZXJbMF0gIT09IHRoaXMuY3VycmVudEl0ZW1bMF0pIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmhlbHBlci5yZW1vdmUoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0dGhpcy5oZWxwZXIgPSBudWxsO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIW5vUHJvcGFnYXRpb24pIHtcXG5cXHRcXHRcXHRcXHRmb3IgKGkgPSAwOyBpIDwgZGVsYXllZFRyaWdnZXJzLmxlbmd0aDsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZGVsYXllZFRyaWdnZXJzW2ldLmNhbGwodGhpcywgZXZlbnQpO1xcblxcdFxcdFxcdFxcdH0gLy9UcmlnZ2VyIGFsbCBkZWxheWVkIGV2ZW50c1xcblxcdFxcdFxcdFxcdHRoaXMuX3RyaWdnZXIoXFxcInN0b3BcXFwiLCBldmVudCwgdGhpcy5fdWlIYXNoKCkpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLmZyb21PdXRzaWRlID0gZmFsc2U7XFxuXFx0XFx0XFx0cmV0dXJuICF0aGlzLmNhbmNlbEhlbHBlclJlbW92YWw7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfdHJpZ2dlcjogZnVuY3Rpb24gX3RyaWdnZXIoKSB7XFxuXFx0XFx0XFx0aWYgKCQuV2lkZ2V0LnByb3RvdHlwZS5fdHJpZ2dlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpID09PSBmYWxzZSkge1xcblxcdFxcdFxcdFxcdHRoaXMuY2FuY2VsKCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFxuXFx0XFx0X3VpSGFzaDogZnVuY3Rpb24gX3VpSGFzaChfaW5zdCkge1xcblxcdFxcdFxcdHZhciBpbnN0ID0gX2luc3QgfHwgdGhpcztcXG5cXHRcXHRcXHRyZXR1cm4ge1xcblxcdFxcdFxcdFxcdGhlbHBlcjogaW5zdC5oZWxwZXIsXFxuXFx0XFx0XFx0XFx0cGxhY2Vob2xkZXI6IGluc3QucGxhY2Vob2xkZXIgfHwgJChbXSksXFxuXFx0XFx0XFx0XFx0cG9zaXRpb246IGluc3QucG9zaXRpb24sXFxuXFx0XFx0XFx0XFx0b3JpZ2luYWxQb3NpdGlvbjogaW5zdC5vcmlnaW5hbFBvc2l0aW9uLFxcblxcdFxcdFxcdFxcdG9mZnNldDogaW5zdC5wb3NpdGlvbkFicyxcXG5cXHRcXHRcXHRcXHRpdGVtOiBpbnN0LmN1cnJlbnRJdGVtLFxcblxcdFxcdFxcdFxcdHNlbmRlcjogX2luc3QgPyBfaW5zdC5lbGVtZW50IDogbnVsbFxcblxcdFxcdFxcdH07XFxuXFx0XFx0fVxcblxcblxcdH0pO1xcblxcblxcdC8qIVxcbiAgKiBqUXVlcnkgVUkgU3Bpbm5lciAxLjExLjRcXG4gICogaHR0cDovL2pxdWVyeXVpLmNvbVxcbiAgKlxcbiAgKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xcbiAgKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXFxuICAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcXG4gICpcXG4gICogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20vc3Bpbm5lci9cXG4gICovXFxuXFxuXFx0ZnVuY3Rpb24gc3Bpbm5lcl9tb2RpZmllcihmbikge1xcblxcdFxcdHJldHVybiBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0dmFyIHByZXZpb3VzID0gdGhpcy5lbGVtZW50LnZhbCgpO1xcblxcdFxcdFxcdGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuXFx0XFx0XFx0dGhpcy5fcmVmcmVzaCgpO1xcblxcdFxcdFxcdGlmIChwcmV2aW91cyAhPT0gdGhpcy5lbGVtZW50LnZhbCgpKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5fdHJpZ2dlcihcXFwiY2hhbmdlXFxcIik7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH07XFxuXFx0fVxcblxcblxcdHZhciBzcGlubmVyID0gJC53aWRnZXQoXFxcInVpLnNwaW5uZXJcXFwiLCB7XFxuXFx0XFx0dmVyc2lvbjogXFxcIjEuMTEuNFxcXCIsXFxuXFx0XFx0ZGVmYXVsdEVsZW1lbnQ6IFxcXCI8aW5wdXQ+XFxcIixcXG5cXHRcXHR3aWRnZXRFdmVudFByZWZpeDogXFxcInNwaW5cXFwiLFxcblxcdFxcdG9wdGlvbnM6IHtcXG5cXHRcXHRcXHRjdWx0dXJlOiBudWxsLFxcblxcdFxcdFxcdGljb25zOiB7XFxuXFx0XFx0XFx0XFx0ZG93bjogXFxcInVpLWljb24tdHJpYW5nbGUtMS1zXFxcIixcXG5cXHRcXHRcXHRcXHR1cDogXFxcInVpLWljb24tdHJpYW5nbGUtMS1uXFxcIlxcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0aW5jcmVtZW50YWw6IHRydWUsXFxuXFx0XFx0XFx0bWF4OiBudWxsLFxcblxcdFxcdFxcdG1pbjogbnVsbCxcXG5cXHRcXHRcXHRudW1iZXJGb3JtYXQ6IG51bGwsXFxuXFx0XFx0XFx0cGFnZTogMTAsXFxuXFx0XFx0XFx0c3RlcDogMSxcXG5cXG5cXHRcXHRcXHRjaGFuZ2U6IG51bGwsXFxuXFx0XFx0XFx0c3BpbjogbnVsbCxcXG5cXHRcXHRcXHRzdGFydDogbnVsbCxcXG5cXHRcXHRcXHRzdG9wOiBudWxsXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfY3JlYXRlOiBmdW5jdGlvbiBfY3JlYXRlKCkge1xcblxcdFxcdFxcdC8vIGhhbmRsZSBzdHJpbmcgdmFsdWVzIHRoYXQgbmVlZCB0byBiZSBwYXJzZWRcXG5cXHRcXHRcXHR0aGlzLl9zZXRPcHRpb24oXFxcIm1heFxcXCIsIHRoaXMub3B0aW9ucy5tYXgpO1xcblxcdFxcdFxcdHRoaXMuX3NldE9wdGlvbihcXFwibWluXFxcIiwgdGhpcy5vcHRpb25zLm1pbik7XFxuXFx0XFx0XFx0dGhpcy5fc2V0T3B0aW9uKFxcXCJzdGVwXFxcIiwgdGhpcy5vcHRpb25zLnN0ZXApO1xcblxcblxcdFxcdFxcdC8vIE9ubHkgZm9ybWF0IGlmIHRoZXJlIGlzIGEgdmFsdWUsIHByZXZlbnRzIHRoZSBmaWVsZCBmcm9tIGJlaW5nIG1hcmtlZFxcblxcdFxcdFxcdC8vIGFzIGludmFsaWQgaW4gRmlyZWZveCwgc2VlICM5NTczLlxcblxcdFxcdFxcdGlmICh0aGlzLnZhbHVlKCkgIT09IFxcXCJcXFwiKSB7XFxuXFx0XFx0XFx0XFx0Ly8gRm9ybWF0IHRoZSB2YWx1ZSwgYnV0IGRvbid0IGNvbnN0cmFpbi5cXG5cXHRcXHRcXHRcXHR0aGlzLl92YWx1ZSh0aGlzLmVsZW1lbnQudmFsKCksIHRydWUpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLl9kcmF3KCk7XFxuXFx0XFx0XFx0dGhpcy5fb24odGhpcy5fZXZlbnRzKTtcXG5cXHRcXHRcXHR0aGlzLl9yZWZyZXNoKCk7XFxuXFxuXFx0XFx0XFx0Ly8gdHVybmluZyBvZmYgYXV0b2NvbXBsZXRlIHByZXZlbnRzIHRoZSBicm93c2VyIGZyb20gcmVtZW1iZXJpbmcgdGhlXFxuXFx0XFx0XFx0Ly8gdmFsdWUgd2hlbiBuYXZpZ2F0aW5nIHRocm91Z2ggaGlzdG9yeSwgc28gd2UgcmUtZW5hYmxlIGF1dG9jb21wbGV0ZVxcblxcdFxcdFxcdC8vIGlmIHRoZSBwYWdlIGlzIHVubG9hZGVkIGJlZm9yZSB0aGUgd2lkZ2V0IGlzIGRlc3Ryb3llZC4gIzc3OTBcXG5cXHRcXHRcXHR0aGlzLl9vbih0aGlzLndpbmRvdywge1xcblxcdFxcdFxcdFxcdGJlZm9yZXVubG9hZDogZnVuY3Rpb24gYmVmb3JldW5sb2FkKCkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuZWxlbWVudC5yZW1vdmVBdHRyKFxcXCJhdXRvY29tcGxldGVcXFwiKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfZ2V0Q3JlYXRlT3B0aW9uczogZnVuY3Rpb24gX2dldENyZWF0ZU9wdGlvbnMoKSB7XFxuXFx0XFx0XFx0dmFyIG9wdGlvbnMgPSB7fSxcXG5cXHRcXHRcXHQgICAgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcXG5cXG5cXHRcXHRcXHQkLmVhY2goW1xcXCJtaW5cXFwiLCBcXFwibWF4XFxcIiwgXFxcInN0ZXBcXFwiXSwgZnVuY3Rpb24gKGksIG9wdGlvbikge1xcblxcdFxcdFxcdFxcdHZhciB2YWx1ZSA9IGVsZW1lbnQuYXR0cihvcHRpb24pO1xcblxcdFxcdFxcdFxcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdFxcdG9wdGlvbnNbb3B0aW9uXSA9IHZhbHVlO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9KTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gb3B0aW9ucztcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9ldmVudHM6IHtcXG5cXHRcXHRcXHRrZXlkb3duOiBmdW5jdGlvbiBrZXlkb3duKGV2ZW50KSB7XFxuXFx0XFx0XFx0XFx0aWYgKHRoaXMuX3N0YXJ0KGV2ZW50KSAmJiB0aGlzLl9rZXlkb3duKGV2ZW50KSkge1xcblxcdFxcdFxcdFxcdFxcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0a2V5dXA6IFxcXCJfc3RvcFxcXCIsXFxuXFx0XFx0XFx0Zm9jdXM6IGZ1bmN0aW9uIGZvY3VzKCkge1xcblxcdFxcdFxcdFxcdHRoaXMucHJldmlvdXMgPSB0aGlzLmVsZW1lbnQudmFsKCk7XFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRibHVyOiBmdW5jdGlvbiBibHVyKGV2ZW50KSB7XFxuXFx0XFx0XFx0XFx0aWYgKHRoaXMuY2FuY2VsQmx1cikge1xcblxcdFxcdFxcdFxcdFxcdGRlbGV0ZSB0aGlzLmNhbmNlbEJsdXI7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR0aGlzLl9zdG9wKCk7XFxuXFx0XFx0XFx0XFx0dGhpcy5fcmVmcmVzaCgpO1xcblxcdFxcdFxcdFxcdGlmICh0aGlzLnByZXZpb3VzICE9PSB0aGlzLmVsZW1lbnQudmFsKCkpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl90cmlnZ2VyKFxcXCJjaGFuZ2VcXFwiLCBldmVudCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0bW91c2V3aGVlbDogZnVuY3Rpb24gbW91c2V3aGVlbChldmVudCwgZGVsdGEpIHtcXG5cXHRcXHRcXHRcXHRpZiAoIWRlbHRhKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRpZiAoIXRoaXMuc3Bpbm5pbmcgJiYgIXRoaXMuX3N0YXJ0KGV2ZW50KSkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5fc3BpbigoZGVsdGEgPiAwID8gMSA6IC0xKSAqIHRoaXMub3B0aW9ucy5zdGVwLCBldmVudCk7XFxuXFx0XFx0XFx0XFx0Y2xlYXJUaW1lb3V0KHRoaXMubW91c2V3aGVlbFRpbWVyKTtcXG5cXHRcXHRcXHRcXHR0aGlzLm1vdXNld2hlZWxUaW1lciA9IHRoaXMuX2RlbGF5KGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAodGhpcy5zcGlubmluZykge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuX3N0b3AoZXZlbnQpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9LCAxMDApO1xcblxcdFxcdFxcdFxcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRcXFwibW91c2Vkb3duIC51aS1zcGlubmVyLWJ1dHRvblxcXCI6IGZ1bmN0aW9uIG1vdXNlZG93blVpU3Bpbm5lckJ1dHRvbihldmVudCkge1xcblxcdFxcdFxcdFxcdHZhciBwcmV2aW91cztcXG5cXG5cXHRcXHRcXHRcXHQvLyBXZSBuZXZlciB3YW50IHRoZSBidXR0b25zIHRvIGhhdmUgZm9jdXM7IHdoZW5ldmVyIHRoZSB1c2VyIGlzXFxuXFx0XFx0XFx0XFx0Ly8gaW50ZXJhY3Rpbmcgd2l0aCB0aGUgc3Bpbm5lciwgdGhlIGZvY3VzIHNob3VsZCBiZSBvbiB0aGUgaW5wdXQuXFxuXFx0XFx0XFx0XFx0Ly8gSWYgdGhlIGlucHV0IGlzIGZvY3VzZWQgdGhlbiB0aGlzLnByZXZpb3VzIGlzIHByb3Blcmx5IHNldCBmcm9tXFxuXFx0XFx0XFx0XFx0Ly8gd2hlbiB0aGUgaW5wdXQgZmlyc3QgcmVjZWl2ZWQgZm9jdXMuIElmIHRoZSBpbnB1dCBpcyBub3QgZm9jdXNlZFxcblxcdFxcdFxcdFxcdC8vIHRoZW4gd2UgbmVlZCB0byBzZXQgdGhpcy5wcmV2aW91cyBiYXNlZCBvbiB0aGUgdmFsdWUgYmVmb3JlIHNwaW5uaW5nLlxcblxcdFxcdFxcdFxcdHByZXZpb3VzID0gdGhpcy5lbGVtZW50WzBdID09PSB0aGlzLmRvY3VtZW50WzBdLmFjdGl2ZUVsZW1lbnQgPyB0aGlzLnByZXZpb3VzIDogdGhpcy5lbGVtZW50LnZhbCgpO1xcblxcdFxcdFxcdFxcdGZ1bmN0aW9uIGNoZWNrRm9jdXMoKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGlzQWN0aXZlID0gdGhpcy5lbGVtZW50WzBdID09PSB0aGlzLmRvY3VtZW50WzBdLmFjdGl2ZUVsZW1lbnQ7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCFpc0FjdGl2ZSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuZWxlbWVudC5mb2N1cygpO1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMucHJldmlvdXMgPSBwcmV2aW91cztcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBzdXBwb3J0OiBJRVxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIElFIHNldHMgZm9jdXMgYXN5bmNocm9ub3VzbHksIHNvIHdlIG5lZWQgdG8gY2hlY2sgaWYgZm9jdXNcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBtb3ZlZCBvZmYgb2YgdGhlIGlucHV0IGJlY2F1c2UgdGhlIHVzZXIgY2xpY2tlZCBvbiB0aGUgYnV0dG9uLlxcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuX2RlbGF5KGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLnByZXZpb3VzID0gcHJldmlvdXM7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBlbnN1cmUgZm9jdXMgaXMgb24gKG9yIHN0YXlzIG9uKSB0aGUgdGV4dCBmaWVsZFxcblxcdFxcdFxcdFxcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XFxuXFx0XFx0XFx0XFx0Y2hlY2tGb2N1cy5jYWxsKHRoaXMpO1xcblxcblxcdFxcdFxcdFxcdC8vIHN1cHBvcnQ6IElFXFxuXFx0XFx0XFx0XFx0Ly8gSUUgZG9lc24ndCBwcmV2ZW50IG1vdmluZyBmb2N1cyBldmVuIHdpdGggZXZlbnQucHJldmVudERlZmF1bHQoKVxcblxcdFxcdFxcdFxcdC8vIHNvIHdlIHNldCBhIGZsYWcgdG8ga25vdyB3aGVuIHdlIHNob3VsZCBpZ25vcmUgdGhlIGJsdXIgZXZlbnRcXG5cXHRcXHRcXHRcXHQvLyBhbmQgY2hlY2sgKGFnYWluKSBpZiBmb2N1cyBtb3ZlZCBvZmYgb2YgdGhlIGlucHV0LlxcblxcdFxcdFxcdFxcdHRoaXMuY2FuY2VsQmx1ciA9IHRydWU7XFxuXFx0XFx0XFx0XFx0dGhpcy5fZGVsYXkoZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdGRlbGV0ZSB0aGlzLmNhbmNlbEJsdXI7XFxuXFx0XFx0XFx0XFx0XFx0Y2hlY2tGb2N1cy5jYWxsKHRoaXMpO1xcblxcdFxcdFxcdFxcdH0pO1xcblxcblxcdFxcdFxcdFxcdGlmICh0aGlzLl9zdGFydChldmVudCkgPT09IGZhbHNlKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR0aGlzLl9yZXBlYXQobnVsbCwgJChldmVudC5jdXJyZW50VGFyZ2V0KS5oYXNDbGFzcyhcXFwidWktc3Bpbm5lci11cFxcXCIpID8gMSA6IC0xLCBldmVudCk7XFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRcXFwibW91c2V1cCAudWktc3Bpbm5lci1idXR0b25cXFwiOiBcXFwiX3N0b3BcXFwiLFxcblxcdFxcdFxcdFxcXCJtb3VzZWVudGVyIC51aS1zcGlubmVyLWJ1dHRvblxcXCI6IGZ1bmN0aW9uIG1vdXNlZW50ZXJVaVNwaW5uZXJCdXR0b24oZXZlbnQpIHtcXG5cXHRcXHRcXHRcXHQvLyBidXR0b24gd2lsbCBhZGQgdWktc3RhdGUtYWN0aXZlIGlmIG1vdXNlIHdhcyBkb3duIHdoaWxlIG1vdXNlbGVhdmUgYW5kIGtlcHQgZG93blxcblxcdFxcdFxcdFxcdGlmICghJChldmVudC5jdXJyZW50VGFyZ2V0KS5oYXNDbGFzcyhcXFwidWktc3RhdGUtYWN0aXZlXFxcIikpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmICh0aGlzLl9zdGFydChldmVudCkgPT09IGZhbHNlKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR0aGlzLl9yZXBlYXQobnVsbCwgJChldmVudC5jdXJyZW50VGFyZ2V0KS5oYXNDbGFzcyhcXFwidWktc3Bpbm5lci11cFxcXCIpID8gMSA6IC0xLCBldmVudCk7XFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHQvLyBUT0RPOiBkbyB3ZSByZWFsbHkgd2FudCB0byBjb25zaWRlciB0aGlzIGEgc3RvcD9cXG5cXHRcXHRcXHQvLyBzaG91bGRuJ3Qgd2UganVzdCBzdG9wIHRoZSByZXBlYXRlciBhbmQgd2FpdCB1bnRpbCBtb3VzZXVwIGJlZm9yZVxcblxcdFxcdFxcdC8vIHdlIHRyaWdnZXIgdGhlIHN0b3AgZXZlbnQ/XFxuXFx0XFx0XFx0XFxcIm1vdXNlbGVhdmUgLnVpLXNwaW5uZXItYnV0dG9uXFxcIjogXFxcIl9zdG9wXFxcIlxcblxcdFxcdH0sXFxuXFxuXFx0XFx0X2RyYXc6IGZ1bmN0aW9uIF9kcmF3KCkge1xcblxcdFxcdFxcdHZhciB1aVNwaW5uZXIgPSB0aGlzLnVpU3Bpbm5lciA9IHRoaXMuZWxlbWVudC5hZGRDbGFzcyhcXFwidWktc3Bpbm5lci1pbnB1dFxcXCIpLmF0dHIoXFxcImF1dG9jb21wbGV0ZVxcXCIsIFxcXCJvZmZcXFwiKS53cmFwKHRoaXMuX3VpU3Bpbm5lckh0bWwoKSkucGFyZW50KClcXG5cXHRcXHRcXHQvLyBhZGQgYnV0dG9uc1xcblxcdFxcdFxcdC5hcHBlbmQodGhpcy5fYnV0dG9uSHRtbCgpKTtcXG5cXG5cXHRcXHRcXHR0aGlzLmVsZW1lbnQuYXR0cihcXFwicm9sZVxcXCIsIFxcXCJzcGluYnV0dG9uXFxcIik7XFxuXFxuXFx0XFx0XFx0Ly8gYnV0dG9uIGJpbmRpbmdzXFxuXFx0XFx0XFx0dGhpcy5idXR0b25zID0gdWlTcGlubmVyLmZpbmQoXFxcIi51aS1zcGlubmVyLWJ1dHRvblxcXCIpLmF0dHIoXFxcInRhYkluZGV4XFxcIiwgLTEpLmJ1dHRvbigpLnJlbW92ZUNsYXNzKFxcXCJ1aS1jb3JuZXItYWxsXFxcIik7XFxuXFxuXFx0XFx0XFx0Ly8gSUUgNiBkb2Vzbid0IHVuZGVyc3RhbmQgaGVpZ2h0OiA1MCUgZm9yIHRoZSBidXR0b25zXFxuXFx0XFx0XFx0Ly8gdW5sZXNzIHRoZSB3cmFwcGVyIGhhcyBhbiBleHBsaWNpdCBoZWlnaHRcXG5cXHRcXHRcXHRpZiAodGhpcy5idXR0b25zLmhlaWdodCgpID4gTWF0aC5jZWlsKHVpU3Bpbm5lci5oZWlnaHQoKSAqIDAuNSkgJiYgdWlTcGlubmVyLmhlaWdodCgpID4gMCkge1xcblxcdFxcdFxcdFxcdHVpU3Bpbm5lci5oZWlnaHQodWlTcGlubmVyLmhlaWdodCgpKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gZGlzYWJsZSBzcGlubmVyIGlmIGVsZW1lbnQgd2FzIGFscmVhZHkgZGlzYWJsZWRcXG5cXHRcXHRcXHRpZiAodGhpcy5vcHRpb25zLmRpc2FibGVkKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5kaXNhYmxlKCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFxuXFx0XFx0X2tleWRvd246IGZ1bmN0aW9uIF9rZXlkb3duKGV2ZW50KSB7XFxuXFx0XFx0XFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXFxuXFx0XFx0XFx0ICAgIGtleUNvZGUgPSAkLnVpLmtleUNvZGU7XFxuXFxuXFx0XFx0XFx0c3dpdGNoIChldmVudC5rZXlDb2RlKSB7XFxuXFx0XFx0XFx0XFx0Y2FzZSBrZXlDb2RlLlVQOlxcblxcdFxcdFxcdFxcdFxcdHRoaXMuX3JlcGVhdChudWxsLCAxLCBldmVudCk7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0XFx0XFx0Y2FzZSBrZXlDb2RlLkRPV046XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fcmVwZWF0KG51bGwsIC0xLCBldmVudCk7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0XFx0XFx0Y2FzZSBrZXlDb2RlLlBBR0VfVVA6XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fcmVwZWF0KG51bGwsIG9wdGlvbnMucGFnZSwgZXZlbnQpO1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdFxcdFxcdGNhc2Uga2V5Q29kZS5QQUdFX0RPV046XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fcmVwZWF0KG51bGwsIC1vcHRpb25zLnBhZ2UsIGV2ZW50KTtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X3VpU3Bpbm5lckh0bWw6IGZ1bmN0aW9uIF91aVNwaW5uZXJIdG1sKCkge1xcblxcdFxcdFxcdHJldHVybiBcXFwiPHNwYW4gY2xhc3M9J3VpLXNwaW5uZXIgdWktd2lkZ2V0IHVpLXdpZGdldC1jb250ZW50IHVpLWNvcm5lci1hbGwnPjwvc3Bhbj5cXFwiO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X2J1dHRvbkh0bWw6IGZ1bmN0aW9uIF9idXR0b25IdG1sKCkge1xcblxcdFxcdFxcdHJldHVybiBcXFwiXFxcIiArIFxcXCI8YSBjbGFzcz0ndWktc3Bpbm5lci1idXR0b24gdWktc3Bpbm5lci11cCB1aS1jb3JuZXItdHInPlxcXCIgKyBcXFwiPHNwYW4gY2xhc3M9J3VpLWljb24gXFxcIiArIHRoaXMub3B0aW9ucy5pY29ucy51cCArIFxcXCInPiYjOTY1MDs8L3NwYW4+XFxcIiArIFxcXCI8L2E+XFxcIiArIFxcXCI8YSBjbGFzcz0ndWktc3Bpbm5lci1idXR0b24gdWktc3Bpbm5lci1kb3duIHVpLWNvcm5lci1icic+XFxcIiArIFxcXCI8c3BhbiBjbGFzcz0ndWktaWNvbiBcXFwiICsgdGhpcy5vcHRpb25zLmljb25zLmRvd24gKyBcXFwiJz4mIzk2NjA7PC9zcGFuPlxcXCIgKyBcXFwiPC9hPlxcXCI7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfc3RhcnQ6IGZ1bmN0aW9uIF9zdGFydChldmVudCkge1xcblxcdFxcdFxcdGlmICghdGhpcy5zcGlubmluZyAmJiB0aGlzLl90cmlnZ2VyKFxcXCJzdGFydFxcXCIsIGV2ZW50KSA9PT0gZmFsc2UpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICghdGhpcy5jb3VudGVyKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5jb3VudGVyID0gMTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0dGhpcy5zcGlubmluZyA9IHRydWU7XFxuXFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfcmVwZWF0OiBmdW5jdGlvbiBfcmVwZWF0KGksIHN0ZXBzLCBldmVudCkge1xcblxcdFxcdFxcdGkgPSBpIHx8IDUwMDtcXG5cXG5cXHRcXHRcXHRjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XFxuXFx0XFx0XFx0dGhpcy50aW1lciA9IHRoaXMuX2RlbGF5KGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9yZXBlYXQoNDAsIHN0ZXBzLCBldmVudCk7XFxuXFx0XFx0XFx0fSwgaSk7XFxuXFxuXFx0XFx0XFx0dGhpcy5fc3BpbihzdGVwcyAqIHRoaXMub3B0aW9ucy5zdGVwLCBldmVudCk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfc3BpbjogZnVuY3Rpb24gX3NwaW4oc3RlcCwgZXZlbnQpIHtcXG5cXHRcXHRcXHR2YXIgdmFsdWUgPSB0aGlzLnZhbHVlKCkgfHwgMDtcXG5cXG5cXHRcXHRcXHRpZiAoIXRoaXMuY291bnRlcikge1xcblxcdFxcdFxcdFxcdHRoaXMuY291bnRlciA9IDE7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHZhbHVlID0gdGhpcy5fYWRqdXN0VmFsdWUodmFsdWUgKyBzdGVwICogdGhpcy5faW5jcmVtZW50KHRoaXMuY291bnRlcikpO1xcblxcblxcdFxcdFxcdGlmICghdGhpcy5zcGlubmluZyB8fCB0aGlzLl90cmlnZ2VyKFxcXCJzcGluXFxcIiwgZXZlbnQsIHsgdmFsdWU6IHZhbHVlIH0pICE9PSBmYWxzZSkge1xcblxcdFxcdFxcdFxcdHRoaXMuX3ZhbHVlKHZhbHVlKTtcXG5cXHRcXHRcXHRcXHR0aGlzLmNvdW50ZXIrKztcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfaW5jcmVtZW50OiBmdW5jdGlvbiBfaW5jcmVtZW50KGkpIHtcXG5cXHRcXHRcXHR2YXIgaW5jcmVtZW50YWwgPSB0aGlzLm9wdGlvbnMuaW5jcmVtZW50YWw7XFxuXFxuXFx0XFx0XFx0aWYgKGluY3JlbWVudGFsKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuICQuaXNGdW5jdGlvbihpbmNyZW1lbnRhbCkgPyBpbmNyZW1lbnRhbChpKSA6IE1hdGguZmxvb3IoaSAqIGkgKiBpIC8gNTAwMDAgLSBpICogaSAvIDUwMCArIDE3ICogaSAvIDIwMCArIDEpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gMTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9wcmVjaXNpb246IGZ1bmN0aW9uIF9wcmVjaXNpb24oKSB7XFxuXFx0XFx0XFx0dmFyIHByZWNpc2lvbiA9IHRoaXMuX3ByZWNpc2lvbk9mKHRoaXMub3B0aW9ucy5zdGVwKTtcXG5cXHRcXHRcXHRpZiAodGhpcy5vcHRpb25zLm1pbiAhPT0gbnVsbCkge1xcblxcdFxcdFxcdFxcdHByZWNpc2lvbiA9IE1hdGgubWF4KHByZWNpc2lvbiwgdGhpcy5fcHJlY2lzaW9uT2YodGhpcy5vcHRpb25zLm1pbikpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gcHJlY2lzaW9uO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X3ByZWNpc2lvbk9mOiBmdW5jdGlvbiBfcHJlY2lzaW9uT2YobnVtKSB7XFxuXFx0XFx0XFx0dmFyIHN0ciA9IG51bS50b1N0cmluZygpLFxcblxcdFxcdFxcdCAgICBkZWNpbWFsID0gc3RyLmluZGV4T2YoXFxcIi5cXFwiKTtcXG5cXHRcXHRcXHRyZXR1cm4gZGVjaW1hbCA9PT0gLTEgPyAwIDogc3RyLmxlbmd0aCAtIGRlY2ltYWwgLSAxO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X2FkanVzdFZhbHVlOiBmdW5jdGlvbiBfYWRqdXN0VmFsdWUodmFsdWUpIHtcXG5cXHRcXHRcXHR2YXIgYmFzZSxcXG5cXHRcXHRcXHQgICAgYWJvdmVNaW4sXFxuXFx0XFx0XFx0ICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XFxuXFxuXFx0XFx0XFx0Ly8gbWFrZSBzdXJlIHdlJ3JlIGF0IGEgdmFsaWQgc3RlcFxcblxcdFxcdFxcdC8vIC0gZmluZCBvdXQgd2hlcmUgd2UgYXJlIHJlbGF0aXZlIHRvIHRoZSBiYXNlIChtaW4gb3IgMClcXG5cXHRcXHRcXHRiYXNlID0gb3B0aW9ucy5taW4gIT09IG51bGwgPyBvcHRpb25zLm1pbiA6IDA7XFxuXFx0XFx0XFx0YWJvdmVNaW4gPSB2YWx1ZSAtIGJhc2U7XFxuXFx0XFx0XFx0Ly8gLSByb3VuZCB0byB0aGUgbmVhcmVzdCBzdGVwXFxuXFx0XFx0XFx0YWJvdmVNaW4gPSBNYXRoLnJvdW5kKGFib3ZlTWluIC8gb3B0aW9ucy5zdGVwKSAqIG9wdGlvbnMuc3RlcDtcXG5cXHRcXHRcXHQvLyAtIHJvdW5kaW5nIGlzIGJhc2VkIG9uIDAsIHNvIGFkanVzdCBiYWNrIHRvIG91ciBiYXNlXFxuXFx0XFx0XFx0dmFsdWUgPSBiYXNlICsgYWJvdmVNaW47XFxuXFxuXFx0XFx0XFx0Ly8gZml4IHByZWNpc2lvbiBmcm9tIGJhZCBKUyBmbG9hdGluZyBwb2ludCBtYXRoXFxuXFx0XFx0XFx0dmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlLnRvRml4ZWQodGhpcy5fcHJlY2lzaW9uKCkpKTtcXG5cXG5cXHRcXHRcXHQvLyBjbGFtcCB0aGUgdmFsdWVcXG5cXHRcXHRcXHRpZiAob3B0aW9ucy5tYXggIT09IG51bGwgJiYgdmFsdWUgPiBvcHRpb25zLm1heCkge1xcblxcdFxcdFxcdFxcdHJldHVybiBvcHRpb25zLm1heDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKG9wdGlvbnMubWluICE9PSBudWxsICYmIHZhbHVlIDwgb3B0aW9ucy5taW4pIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gb3B0aW9ucy5taW47XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB2YWx1ZTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9zdG9wOiBmdW5jdGlvbiBfc3RvcChldmVudCkge1xcblxcdFxcdFxcdGlmICghdGhpcy5zcGlubmluZykge1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Y2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xcblxcdFxcdFxcdGNsZWFyVGltZW91dCh0aGlzLm1vdXNld2hlZWxUaW1lcik7XFxuXFx0XFx0XFx0dGhpcy5jb3VudGVyID0gMDtcXG5cXHRcXHRcXHR0aGlzLnNwaW5uaW5nID0gZmFsc2U7XFxuXFx0XFx0XFx0dGhpcy5fdHJpZ2dlcihcXFwic3RvcFxcXCIsIGV2ZW50KTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9zZXRPcHRpb246IGZ1bmN0aW9uIF9zZXRPcHRpb24oa2V5LCB2YWx1ZSkge1xcblxcdFxcdFxcdGlmIChrZXkgPT09IFxcXCJjdWx0dXJlXFxcIiB8fCBrZXkgPT09IFxcXCJudW1iZXJGb3JtYXRcXFwiKSB7XFxuXFx0XFx0XFx0XFx0dmFyIHByZXZWYWx1ZSA9IHRoaXMuX3BhcnNlKHRoaXMuZWxlbWVudC52YWwoKSk7XFxuXFx0XFx0XFx0XFx0dGhpcy5vcHRpb25zW2tleV0gPSB2YWx1ZTtcXG5cXHRcXHRcXHRcXHR0aGlzLmVsZW1lbnQudmFsKHRoaXMuX2Zvcm1hdChwcmV2VmFsdWUpKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmIChrZXkgPT09IFxcXCJtYXhcXFwiIHx8IGtleSA9PT0gXFxcIm1pblxcXCIgfHwga2V5ID09PSBcXFwic3RlcFxcXCIpIHtcXG5cXHRcXHRcXHRcXHRpZiAodHlwZW9mIHZhbHVlID09PSBcXFwic3RyaW5nXFxcIikge1xcblxcdFxcdFxcdFxcdFxcdHZhbHVlID0gdGhpcy5fcGFyc2UodmFsdWUpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKGtleSA9PT0gXFxcImljb25zXFxcIikge1xcblxcdFxcdFxcdFxcdHRoaXMuYnV0dG9ucy5maXJzdCgpLmZpbmQoXFxcIi51aS1pY29uXFxcIikucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmljb25zLnVwKS5hZGRDbGFzcyh2YWx1ZS51cCk7XFxuXFx0XFx0XFx0XFx0dGhpcy5idXR0b25zLmxhc3QoKS5maW5kKFxcXCIudWktaWNvblxcXCIpLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5pY29ucy5kb3duKS5hZGRDbGFzcyh2YWx1ZS5kb3duKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy5fc3VwZXIoa2V5LCB2YWx1ZSk7XFxuXFxuXFx0XFx0XFx0aWYgKGtleSA9PT0gXFxcImRpc2FibGVkXFxcIikge1xcblxcdFxcdFxcdFxcdHRoaXMud2lkZ2V0KCkudG9nZ2xlQ2xhc3MoXFxcInVpLXN0YXRlLWRpc2FibGVkXFxcIiwgISF2YWx1ZSk7XFxuXFx0XFx0XFx0XFx0dGhpcy5lbGVtZW50LnByb3AoXFxcImRpc2FibGVkXFxcIiwgISF2YWx1ZSk7XFxuXFx0XFx0XFx0XFx0dGhpcy5idXR0b25zLmJ1dHRvbih2YWx1ZSA/IFxcXCJkaXNhYmxlXFxcIiA6IFxcXCJlbmFibGVcXFwiKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfc2V0T3B0aW9uczogc3Bpbm5lcl9tb2RpZmllcihmdW5jdGlvbiAob3B0aW9ucykge1xcblxcdFxcdFxcdHRoaXMuX3N1cGVyKG9wdGlvbnMpO1xcblxcdFxcdH0pLFxcblxcblxcdFxcdF9wYXJzZTogZnVuY3Rpb24gX3BhcnNlKHZhbCkge1xcblxcdFxcdFxcdGlmICh0eXBlb2YgdmFsID09PSBcXFwic3RyaW5nXFxcIiAmJiB2YWwgIT09IFxcXCJcXFwiKSB7XFxuXFx0XFx0XFx0XFx0dmFsID0gd2luZG93Lkdsb2JhbGl6ZSAmJiB0aGlzLm9wdGlvbnMubnVtYmVyRm9ybWF0ID8gR2xvYmFsaXplLnBhcnNlRmxvYXQodmFsLCAxMCwgdGhpcy5vcHRpb25zLmN1bHR1cmUpIDogK3ZhbDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIHZhbCA9PT0gXFxcIlxcXCIgfHwgaXNOYU4odmFsKSA/IG51bGwgOiB2YWw7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfZm9ybWF0OiBmdW5jdGlvbiBfZm9ybWF0KHZhbHVlKSB7XFxuXFx0XFx0XFx0aWYgKHZhbHVlID09PSBcXFwiXFxcIikge1xcblxcdFxcdFxcdFxcdHJldHVybiBcXFwiXFxcIjtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIHdpbmRvdy5HbG9iYWxpemUgJiYgdGhpcy5vcHRpb25zLm51bWJlckZvcm1hdCA/IEdsb2JhbGl6ZS5mb3JtYXQodmFsdWUsIHRoaXMub3B0aW9ucy5udW1iZXJGb3JtYXQsIHRoaXMub3B0aW9ucy5jdWx0dXJlKSA6IHZhbHVlO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X3JlZnJlc2g6IGZ1bmN0aW9uIF9yZWZyZXNoKCkge1xcblxcdFxcdFxcdHRoaXMuZWxlbWVudC5hdHRyKHtcXG5cXHRcXHRcXHRcXHRcXFwiYXJpYS12YWx1ZW1pblxcXCI6IHRoaXMub3B0aW9ucy5taW4sXFxuXFx0XFx0XFx0XFx0XFxcImFyaWEtdmFsdWVtYXhcXFwiOiB0aGlzLm9wdGlvbnMubWF4LFxcblxcdFxcdFxcdFxcdC8vIFRPRE86IHdoYXQgc2hvdWxkIHdlIGRvIHdpdGggdmFsdWVzIHRoYXQgY2FuJ3QgYmUgcGFyc2VkP1xcblxcdFxcdFxcdFxcdFxcXCJhcmlhLXZhbHVlbm93XFxcIjogdGhpcy5fcGFyc2UodGhpcy5lbGVtZW50LnZhbCgpKVxcblxcdFxcdFxcdH0pO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0aXNWYWxpZDogZnVuY3Rpb24gaXNWYWxpZCgpIHtcXG5cXHRcXHRcXHR2YXIgdmFsdWUgPSB0aGlzLnZhbHVlKCk7XFxuXFxuXFx0XFx0XFx0Ly8gbnVsbCBpcyBpbnZhbGlkXFxuXFx0XFx0XFx0aWYgKHZhbHVlID09PSBudWxsKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBpZiB2YWx1ZSBnZXRzIGFkanVzdGVkLCBpdCdzIGludmFsaWRcXG5cXHRcXHRcXHRyZXR1cm4gdmFsdWUgPT09IHRoaXMuX2FkanVzdFZhbHVlKHZhbHVlKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdC8vIHVwZGF0ZSB0aGUgdmFsdWUgd2l0aG91dCB0cmlnZ2VyaW5nIGNoYW5nZVxcblxcdFxcdF92YWx1ZTogZnVuY3Rpb24gX3ZhbHVlKHZhbHVlLCBhbGxvd0FueSkge1xcblxcdFxcdFxcdHZhciBwYXJzZWQ7XFxuXFx0XFx0XFx0aWYgKHZhbHVlICE9PSBcXFwiXFxcIikge1xcblxcdFxcdFxcdFxcdHBhcnNlZCA9IHRoaXMuX3BhcnNlKHZhbHVlKTtcXG5cXHRcXHRcXHRcXHRpZiAocGFyc2VkICE9PSBudWxsKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCFhbGxvd0FueSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHBhcnNlZCA9IHRoaXMuX2FkanVzdFZhbHVlKHBhcnNlZCk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdHZhbHVlID0gdGhpcy5fZm9ybWF0KHBhcnNlZCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR0aGlzLmVsZW1lbnQudmFsKHZhbHVlKTtcXG5cXHRcXHRcXHR0aGlzLl9yZWZyZXNoKCk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfZGVzdHJveTogZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XFxuXFx0XFx0XFx0dGhpcy5lbGVtZW50LnJlbW92ZUNsYXNzKFxcXCJ1aS1zcGlubmVyLWlucHV0XFxcIikucHJvcChcXFwiZGlzYWJsZWRcXFwiLCBmYWxzZSkucmVtb3ZlQXR0cihcXFwiYXV0b2NvbXBsZXRlXFxcIikucmVtb3ZlQXR0cihcXFwicm9sZVxcXCIpLnJlbW92ZUF0dHIoXFxcImFyaWEtdmFsdWVtaW5cXFwiKS5yZW1vdmVBdHRyKFxcXCJhcmlhLXZhbHVlbWF4XFxcIikucmVtb3ZlQXR0cihcXFwiYXJpYS12YWx1ZW5vd1xcXCIpO1xcblxcdFxcdFxcdHRoaXMudWlTcGlubmVyLnJlcGxhY2VXaXRoKHRoaXMuZWxlbWVudCk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzdGVwVXA6IHNwaW5uZXJfbW9kaWZpZXIoZnVuY3Rpb24gKHN0ZXBzKSB7XFxuXFx0XFx0XFx0dGhpcy5fc3RlcFVwKHN0ZXBzKTtcXG5cXHRcXHR9KSxcXG5cXHRcXHRfc3RlcFVwOiBmdW5jdGlvbiBfc3RlcFVwKHN0ZXBzKSB7XFxuXFx0XFx0XFx0aWYgKHRoaXMuX3N0YXJ0KCkpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9zcGluKChzdGVwcyB8fCAxKSAqIHRoaXMub3B0aW9ucy5zdGVwKTtcXG5cXHRcXHRcXHRcXHR0aGlzLl9zdG9wKCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c3RlcERvd246IHNwaW5uZXJfbW9kaWZpZXIoZnVuY3Rpb24gKHN0ZXBzKSB7XFxuXFx0XFx0XFx0dGhpcy5fc3RlcERvd24oc3RlcHMpO1xcblxcdFxcdH0pLFxcblxcdFxcdF9zdGVwRG93bjogZnVuY3Rpb24gX3N0ZXBEb3duKHN0ZXBzKSB7XFxuXFx0XFx0XFx0aWYgKHRoaXMuX3N0YXJ0KCkpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9zcGluKChzdGVwcyB8fCAxKSAqIC10aGlzLm9wdGlvbnMuc3RlcCk7XFxuXFx0XFx0XFx0XFx0dGhpcy5fc3RvcCgpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcblxcdFxcdHBhZ2VVcDogc3Bpbm5lcl9tb2RpZmllcihmdW5jdGlvbiAocGFnZXMpIHtcXG5cXHRcXHRcXHR0aGlzLl9zdGVwVXAoKHBhZ2VzIHx8IDEpICogdGhpcy5vcHRpb25zLnBhZ2UpO1xcblxcdFxcdH0pLFxcblxcblxcdFxcdHBhZ2VEb3duOiBzcGlubmVyX21vZGlmaWVyKGZ1bmN0aW9uIChwYWdlcykge1xcblxcdFxcdFxcdHRoaXMuX3N0ZXBEb3duKChwYWdlcyB8fCAxKSAqIHRoaXMub3B0aW9ucy5wYWdlKTtcXG5cXHRcXHR9KSxcXG5cXG5cXHRcXHR2YWx1ZTogZnVuY3Rpb24gdmFsdWUobmV3VmFsKSB7XFxuXFx0XFx0XFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuX3BhcnNlKHRoaXMuZWxlbWVudC52YWwoKSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHNwaW5uZXJfbW9kaWZpZXIodGhpcy5fdmFsdWUpLmNhbGwodGhpcywgbmV3VmFsKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdHdpZGdldDogZnVuY3Rpb24gd2lkZ2V0KCkge1xcblxcdFxcdFxcdHJldHVybiB0aGlzLnVpU3Bpbm5lcjtcXG5cXHRcXHR9XFxuXFx0fSk7XFxuXFxuXFx0LyohXFxuICAqIGpRdWVyeSBVSSBUYWJzIDEuMTEuNFxcbiAgKiBodHRwOi8vanF1ZXJ5dWkuY29tXFxuICAqXFxuICAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXFxuICAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cXG4gICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxcbiAgKlxcbiAgKiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS90YWJzL1xcbiAgKi9cXG5cXG5cXHR2YXIgdGFicyA9ICQud2lkZ2V0KFxcXCJ1aS50YWJzXFxcIiwge1xcblxcdFxcdHZlcnNpb246IFxcXCIxLjExLjRcXFwiLFxcblxcdFxcdGRlbGF5OiAzMDAsXFxuXFx0XFx0b3B0aW9uczoge1xcblxcdFxcdFxcdGFjdGl2ZTogbnVsbCxcXG5cXHRcXHRcXHRjb2xsYXBzaWJsZTogZmFsc2UsXFxuXFx0XFx0XFx0ZXZlbnQ6IFxcXCJjbGlja1xcXCIsXFxuXFx0XFx0XFx0aGVpZ2h0U3R5bGU6IFxcXCJjb250ZW50XFxcIixcXG5cXHRcXHRcXHRoaWRlOiBudWxsLFxcblxcdFxcdFxcdHNob3c6IG51bGwsXFxuXFxuXFx0XFx0XFx0Ly8gY2FsbGJhY2tzXFxuXFx0XFx0XFx0YWN0aXZhdGU6IG51bGwsXFxuXFx0XFx0XFx0YmVmb3JlQWN0aXZhdGU6IG51bGwsXFxuXFx0XFx0XFx0YmVmb3JlTG9hZDogbnVsbCxcXG5cXHRcXHRcXHRsb2FkOiBudWxsXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfaXNMb2NhbDogZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdHZhciByaGFzaCA9IC8jLiokLztcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gKGFuY2hvcikge1xcblxcdFxcdFxcdFxcdHZhciBhbmNob3JVcmwsIGxvY2F0aW9uVXJsO1xcblxcblxcdFxcdFxcdFxcdC8vIHN1cHBvcnQ6IElFN1xcblxcdFxcdFxcdFxcdC8vIElFNyBkb2Vzbid0IG5vcm1hbGl6ZSB0aGUgaHJlZiBwcm9wZXJ0eSB3aGVuIHNldCB2aWEgc2NyaXB0ICgjOTMxNylcXG5cXHRcXHRcXHRcXHRhbmNob3IgPSBhbmNob3IuY2xvbmVOb2RlKGZhbHNlKTtcXG5cXG5cXHRcXHRcXHRcXHRhbmNob3JVcmwgPSBhbmNob3IuaHJlZi5yZXBsYWNlKHJoYXNoLCBcXFwiXFxcIik7XFxuXFx0XFx0XFx0XFx0bG9jYXRpb25VcmwgPSBsb2NhdGlvbi5ocmVmLnJlcGxhY2Uocmhhc2gsIFxcXCJcXFwiKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBkZWNvZGluZyBtYXkgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIFVSTCBpc24ndCBVVEYtOCAoIzk1MTgpXFxuXFx0XFx0XFx0XFx0dHJ5IHtcXG5cXHRcXHRcXHRcXHRcXHRhbmNob3JVcmwgPSBkZWNvZGVVUklDb21wb25lbnQoYW5jaG9yVXJsKTtcXG5cXHRcXHRcXHRcXHR9IGNhdGNoIChlcnJvcikge31cXG5cXHRcXHRcXHRcXHR0cnkge1xcblxcdFxcdFxcdFxcdFxcdGxvY2F0aW9uVXJsID0gZGVjb2RlVVJJQ29tcG9uZW50KGxvY2F0aW9uVXJsKTtcXG5cXHRcXHRcXHRcXHR9IGNhdGNoIChlcnJvcikge31cXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gYW5jaG9yLmhhc2gubGVuZ3RoID4gMSAmJiBhbmNob3JVcmwgPT09IGxvY2F0aW9uVXJsO1xcblxcdFxcdFxcdH07XFxuXFx0XFx0fSgpLFxcblxcblxcdFxcdF9jcmVhdGU6IGZ1bmN0aW9uIF9jcmVhdGUoKSB7XFxuXFx0XFx0XFx0dmFyIHRoYXQgPSB0aGlzLFxcblxcdFxcdFxcdCAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xcblxcblxcdFxcdFxcdHRoaXMucnVubmluZyA9IGZhbHNlO1xcblxcblxcdFxcdFxcdHRoaXMuZWxlbWVudC5hZGRDbGFzcyhcXFwidWktdGFicyB1aS13aWRnZXQgdWktd2lkZ2V0LWNvbnRlbnQgdWktY29ybmVyLWFsbFxcXCIpLnRvZ2dsZUNsYXNzKFxcXCJ1aS10YWJzLWNvbGxhcHNpYmxlXFxcIiwgb3B0aW9ucy5jb2xsYXBzaWJsZSk7XFxuXFxuXFx0XFx0XFx0dGhpcy5fcHJvY2Vzc1RhYnMoKTtcXG5cXHRcXHRcXHRvcHRpb25zLmFjdGl2ZSA9IHRoaXMuX2luaXRpYWxBY3RpdmUoKTtcXG5cXG5cXHRcXHRcXHQvLyBUYWtlIGRpc2FibGluZyB0YWJzIHZpYSBjbGFzcyBhdHRyaWJ1dGUgZnJvbSBIVE1MXFxuXFx0XFx0XFx0Ly8gaW50byBhY2NvdW50IGFuZCB1cGRhdGUgb3B0aW9uIHByb3Blcmx5LlxcblxcdFxcdFxcdGlmICgkLmlzQXJyYXkob3B0aW9ucy5kaXNhYmxlZCkpIHtcXG5cXHRcXHRcXHRcXHRvcHRpb25zLmRpc2FibGVkID0gJC51bmlxdWUob3B0aW9ucy5kaXNhYmxlZC5jb25jYXQoJC5tYXAodGhpcy50YWJzLmZpbHRlcihcXFwiLnVpLXN0YXRlLWRpc2FibGVkXFxcIiksIGZ1bmN0aW9uIChsaSkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiB0aGF0LnRhYnMuaW5kZXgobGkpO1xcblxcdFxcdFxcdFxcdH0pKSkuc29ydCgpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBjaGVjayBmb3IgbGVuZ3RoIGF2b2lkcyBlcnJvciB3aGVuIGluaXRpYWxpemluZyBlbXB0eSBsaXN0XFxuXFx0XFx0XFx0aWYgKHRoaXMub3B0aW9ucy5hY3RpdmUgIT09IGZhbHNlICYmIHRoaXMuYW5jaG9ycy5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLmFjdGl2ZSA9IHRoaXMuX2ZpbmRBY3RpdmUob3B0aW9ucy5hY3RpdmUpO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5hY3RpdmUgPSAkKCk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMuX3JlZnJlc2goKTtcXG5cXG5cXHRcXHRcXHRpZiAodGhpcy5hY3RpdmUubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5sb2FkKG9wdGlvbnMuYWN0aXZlKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfaW5pdGlhbEFjdGl2ZTogZnVuY3Rpb24gX2luaXRpYWxBY3RpdmUoKSB7XFxuXFx0XFx0XFx0dmFyIGFjdGl2ZSA9IHRoaXMub3B0aW9ucy5hY3RpdmUsXFxuXFx0XFx0XFx0ICAgIGNvbGxhcHNpYmxlID0gdGhpcy5vcHRpb25zLmNvbGxhcHNpYmxlLFxcblxcdFxcdFxcdCAgICBsb2NhdGlvbkhhc2ggPSBsb2NhdGlvbi5oYXNoLnN1YnN0cmluZygxKTtcXG5cXG5cXHRcXHRcXHRpZiAoYWN0aXZlID09PSBudWxsKSB7XFxuXFx0XFx0XFx0XFx0Ly8gY2hlY2sgdGhlIGZyYWdtZW50IGlkZW50aWZpZXIgaW4gdGhlIFVSTFxcblxcdFxcdFxcdFxcdGlmIChsb2NhdGlvbkhhc2gpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnRhYnMuZWFjaChmdW5jdGlvbiAoaSwgdGFiKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCQodGFiKS5hdHRyKFxcXCJhcmlhLWNvbnRyb2xzXFxcIikgPT09IGxvY2F0aW9uSGFzaCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGFjdGl2ZSA9IGk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gY2hlY2sgZm9yIGEgdGFiIG1hcmtlZCBhY3RpdmUgdmlhIGEgY2xhc3NcXG5cXHRcXHRcXHRcXHRpZiAoYWN0aXZlID09PSBudWxsKSB7XFxuXFx0XFx0XFx0XFx0XFx0YWN0aXZlID0gdGhpcy50YWJzLmluZGV4KHRoaXMudGFicy5maWx0ZXIoXFxcIi51aS10YWJzLWFjdGl2ZVxcXCIpKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gbm8gYWN0aXZlIHRhYiwgc2V0IHRvIGZhbHNlXFxuXFx0XFx0XFx0XFx0aWYgKGFjdGl2ZSA9PT0gbnVsbCB8fCBhY3RpdmUgPT09IC0xKSB7XFxuXFx0XFx0XFx0XFx0XFx0YWN0aXZlID0gdGhpcy50YWJzLmxlbmd0aCA/IDAgOiBmYWxzZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIGhhbmRsZSBudW1iZXJzOiBuZWdhdGl2ZSwgb3V0IG9mIHJhbmdlXFxuXFx0XFx0XFx0aWYgKGFjdGl2ZSAhPT0gZmFsc2UpIHtcXG5cXHRcXHRcXHRcXHRhY3RpdmUgPSB0aGlzLnRhYnMuaW5kZXgodGhpcy50YWJzLmVxKGFjdGl2ZSkpO1xcblxcdFxcdFxcdFxcdGlmIChhY3RpdmUgPT09IC0xKSB7XFxuXFx0XFx0XFx0XFx0XFx0YWN0aXZlID0gY29sbGFwc2libGUgPyBmYWxzZSA6IDA7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBkb24ndCBhbGxvdyBjb2xsYXBzaWJsZTogZmFsc2UgYW5kIGFjdGl2ZTogZmFsc2VcXG5cXHRcXHRcXHRpZiAoIWNvbGxhcHNpYmxlICYmIGFjdGl2ZSA9PT0gZmFsc2UgJiYgdGhpcy5hbmNob3JzLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdGFjdGl2ZSA9IDA7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBhY3RpdmU7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfZ2V0Q3JlYXRlRXZlbnREYXRhOiBmdW5jdGlvbiBfZ2V0Q3JlYXRlRXZlbnREYXRhKCkge1xcblxcdFxcdFxcdHJldHVybiB7XFxuXFx0XFx0XFx0XFx0dGFiOiB0aGlzLmFjdGl2ZSxcXG5cXHRcXHRcXHRcXHRwYW5lbDogIXRoaXMuYWN0aXZlLmxlbmd0aCA/ICQoKSA6IHRoaXMuX2dldFBhbmVsRm9yVGFiKHRoaXMuYWN0aXZlKVxcblxcdFxcdFxcdH07XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfdGFiS2V5ZG93bjogZnVuY3Rpb24gX3RhYktleWRvd24oZXZlbnQpIHtcXG5cXHRcXHRcXHR2YXIgZm9jdXNlZFRhYiA9ICQodGhpcy5kb2N1bWVudFswXS5hY3RpdmVFbGVtZW50KS5jbG9zZXN0KFxcXCJsaVxcXCIpLFxcblxcdFxcdFxcdCAgICBzZWxlY3RlZEluZGV4ID0gdGhpcy50YWJzLmluZGV4KGZvY3VzZWRUYWIpLFxcblxcdFxcdFxcdCAgICBnb2luZ0ZvcndhcmQgPSB0cnVlO1xcblxcblxcdFxcdFxcdGlmICh0aGlzLl9oYW5kbGVQYWdlTmF2KGV2ZW50KSkge1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0c3dpdGNoIChldmVudC5rZXlDb2RlKSB7XFxuXFx0XFx0XFx0XFx0Y2FzZSAkLnVpLmtleUNvZGUuUklHSFQ6XFxuXFx0XFx0XFx0XFx0Y2FzZSAkLnVpLmtleUNvZGUuRE9XTjpcXG5cXHRcXHRcXHRcXHRcXHRzZWxlY3RlZEluZGV4Kys7XFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0Y2FzZSAkLnVpLmtleUNvZGUuVVA6XFxuXFx0XFx0XFx0XFx0Y2FzZSAkLnVpLmtleUNvZGUuTEVGVDpcXG5cXHRcXHRcXHRcXHRcXHRnb2luZ0ZvcndhcmQgPSBmYWxzZTtcXG5cXHRcXHRcXHRcXHRcXHRzZWxlY3RlZEluZGV4LS07XFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0Y2FzZSAkLnVpLmtleUNvZGUuRU5EOlxcblxcdFxcdFxcdFxcdFxcdHNlbGVjdGVkSW5kZXggPSB0aGlzLmFuY2hvcnMubGVuZ3RoIC0gMTtcXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRjYXNlICQudWkua2V5Q29kZS5IT01FOlxcblxcdFxcdFxcdFxcdFxcdHNlbGVjdGVkSW5kZXggPSAwO1xcblxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdGNhc2UgJC51aS5rZXlDb2RlLlNQQUNFOlxcblxcdFxcdFxcdFxcdFxcdC8vIEFjdGl2YXRlIG9ubHksIG5vIGNvbGxhcHNpbmdcXG5cXHRcXHRcXHRcXHRcXHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdFxcdFxcdFxcdFxcdGNsZWFyVGltZW91dCh0aGlzLmFjdGl2YXRpbmcpO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX2FjdGl2YXRlKHNlbGVjdGVkSW5kZXgpO1xcblxcdFxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHRcXHRjYXNlICQudWkua2V5Q29kZS5FTlRFUjpcXG5cXHRcXHRcXHRcXHRcXHQvLyBUb2dnbGUgKGNhbmNlbCBkZWxheWVkIGFjdGl2YXRpb24sIGFsbG93IGNvbGxhcHNpbmcpXFxuXFx0XFx0XFx0XFx0XFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG5cXHRcXHRcXHRcXHRcXHRjbGVhclRpbWVvdXQodGhpcy5hY3RpdmF0aW5nKTtcXG5cXHRcXHRcXHRcXHRcXHQvLyBEZXRlcm1pbmUgaWYgd2Ugc2hvdWxkIGNvbGxhcHNlIG9yIGFjdGl2YXRlXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fYWN0aXZhdGUoc2VsZWN0ZWRJbmRleCA9PT0gdGhpcy5vcHRpb25zLmFjdGl2ZSA/IGZhbHNlIDogc2VsZWN0ZWRJbmRleCk7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdFxcdGRlZmF1bHQ6XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBGb2N1cyB0aGUgYXBwcm9wcmlhdGUgdGFiLCBiYXNlZCBvbiB3aGljaCBrZXkgd2FzIHByZXNzZWRcXG5cXHRcXHRcXHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdFxcdFxcdGNsZWFyVGltZW91dCh0aGlzLmFjdGl2YXRpbmcpO1xcblxcdFxcdFxcdHNlbGVjdGVkSW5kZXggPSB0aGlzLl9mb2N1c05leHRUYWIoc2VsZWN0ZWRJbmRleCwgZ29pbmdGb3J3YXJkKTtcXG5cXG5cXHRcXHRcXHQvLyBOYXZpZ2F0aW5nIHdpdGggY29udHJvbC9jb21tYW5kIGtleSB3aWxsIHByZXZlbnQgYXV0b21hdGljIGFjdGl2YXRpb25cXG5cXHRcXHRcXHRpZiAoIWV2ZW50LmN0cmxLZXkgJiYgIWV2ZW50Lm1ldGFLZXkpIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBVcGRhdGUgYXJpYS1zZWxlY3RlZCBpbW1lZGlhdGVseSBzbyB0aGF0IEFUIHRoaW5rIHRoZSB0YWIgaXMgYWxyZWFkeSBzZWxlY3RlZC5cXG5cXHRcXHRcXHRcXHQvLyBPdGhlcndpc2UgQVQgbWF5IGNvbmZ1c2UgdGhlIHVzZXIgYnkgc3RhdGluZyB0aGF0IHRoZXkgbmVlZCB0byBhY3RpdmF0ZSB0aGUgdGFiLFxcblxcdFxcdFxcdFxcdC8vIGJ1dCB0aGUgdGFiIHdpbGwgYWxyZWFkeSBiZSBhY3RpdmF0ZWQgYnkgdGhlIHRpbWUgdGhlIGFubm91bmNlbWVudCBmaW5pc2hlcy5cXG5cXHRcXHRcXHRcXHRmb2N1c2VkVGFiLmF0dHIoXFxcImFyaWEtc2VsZWN0ZWRcXFwiLCBcXFwiZmFsc2VcXFwiKTtcXG5cXHRcXHRcXHRcXHR0aGlzLnRhYnMuZXEoc2VsZWN0ZWRJbmRleCkuYXR0cihcXFwiYXJpYS1zZWxlY3RlZFxcXCIsIFxcXCJ0cnVlXFxcIik7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5hY3RpdmF0aW5nID0gdGhpcy5fZGVsYXkoZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMub3B0aW9uKFxcXCJhY3RpdmVcXFwiLCBzZWxlY3RlZEluZGV4KTtcXG5cXHRcXHRcXHRcXHR9LCB0aGlzLmRlbGF5KTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfcGFuZWxLZXlkb3duOiBmdW5jdGlvbiBfcGFuZWxLZXlkb3duKGV2ZW50KSB7XFxuXFx0XFx0XFx0aWYgKHRoaXMuX2hhbmRsZVBhZ2VOYXYoZXZlbnQpKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBDdHJsK3VwIG1vdmVzIGZvY3VzIHRvIHRoZSBjdXJyZW50IHRhYlxcblxcdFxcdFxcdGlmIChldmVudC5jdHJsS2V5ICYmIGV2ZW50LmtleUNvZGUgPT09ICQudWkua2V5Q29kZS5VUCkge1xcblxcdFxcdFxcdFxcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XFxuXFx0XFx0XFx0XFx0dGhpcy5hY3RpdmUuZm9jdXMoKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyBBbHQrcGFnZSB1cC9kb3duIG1vdmVzIGZvY3VzIHRvIHRoZSBwcmV2aW91cy9uZXh0IHRhYiAoYW5kIGFjdGl2YXRlcylcXG5cXHRcXHRfaGFuZGxlUGFnZU5hdjogZnVuY3Rpb24gX2hhbmRsZVBhZ2VOYXYoZXZlbnQpIHtcXG5cXHRcXHRcXHRpZiAoZXZlbnQuYWx0S2V5ICYmIGV2ZW50LmtleUNvZGUgPT09ICQudWkua2V5Q29kZS5QQUdFX1VQKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5fYWN0aXZhdGUodGhpcy5fZm9jdXNOZXh0VGFiKHRoaXMub3B0aW9ucy5hY3RpdmUgLSAxLCBmYWxzZSkpO1xcblxcdFxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoZXZlbnQuYWx0S2V5ICYmIGV2ZW50LmtleUNvZGUgPT09ICQudWkua2V5Q29kZS5QQUdFX0RPV04pIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9hY3RpdmF0ZSh0aGlzLl9mb2N1c05leHRUYWIodGhpcy5vcHRpb25zLmFjdGl2ZSArIDEsIHRydWUpKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfZmluZE5leHRUYWI6IGZ1bmN0aW9uIF9maW5kTmV4dFRhYihpbmRleCwgZ29pbmdGb3J3YXJkKSB7XFxuXFx0XFx0XFx0dmFyIGxhc3RUYWJJbmRleCA9IHRoaXMudGFicy5sZW5ndGggLSAxO1xcblxcblxcdFxcdFxcdGZ1bmN0aW9uIGNvbnN0cmFpbigpIHtcXG5cXHRcXHRcXHRcXHRpZiAoaW5kZXggPiBsYXN0VGFiSW5kZXgpIHtcXG5cXHRcXHRcXHRcXHRcXHRpbmRleCA9IDA7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGlmIChpbmRleCA8IDApIHtcXG5cXHRcXHRcXHRcXHRcXHRpbmRleCA9IGxhc3RUYWJJbmRleDtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGluZGV4O1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR3aGlsZSAoJC5pbkFycmF5KGNvbnN0cmFpbigpLCB0aGlzLm9wdGlvbnMuZGlzYWJsZWQpICE9PSAtMSkge1xcblxcdFxcdFxcdFxcdGluZGV4ID0gZ29pbmdGb3J3YXJkID8gaW5kZXggKyAxIDogaW5kZXggLSAxO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gaW5kZXg7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfZm9jdXNOZXh0VGFiOiBmdW5jdGlvbiBfZm9jdXNOZXh0VGFiKGluZGV4LCBnb2luZ0ZvcndhcmQpIHtcXG5cXHRcXHRcXHRpbmRleCA9IHRoaXMuX2ZpbmROZXh0VGFiKGluZGV4LCBnb2luZ0ZvcndhcmQpO1xcblxcdFxcdFxcdHRoaXMudGFicy5lcShpbmRleCkuZm9jdXMoKTtcXG5cXHRcXHRcXHRyZXR1cm4gaW5kZXg7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfc2V0T3B0aW9uOiBmdW5jdGlvbiBfc2V0T3B0aW9uKGtleSwgdmFsdWUpIHtcXG5cXHRcXHRcXHRpZiAoa2V5ID09PSBcXFwiYWN0aXZlXFxcIikge1xcblxcdFxcdFxcdFxcdC8vIF9hY3RpdmF0ZSgpIHdpbGwgaGFuZGxlIGludmFsaWQgdmFsdWVzIGFuZCB1cGRhdGUgdGhpcy5vcHRpb25zXFxuXFx0XFx0XFx0XFx0dGhpcy5fYWN0aXZhdGUodmFsdWUpO1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKGtleSA9PT0gXFxcImRpc2FibGVkXFxcIikge1xcblxcdFxcdFxcdFxcdC8vIGRvbid0IHVzZSB0aGUgd2lkZ2V0IGZhY3RvcnkncyBkaXNhYmxlZCBoYW5kbGluZ1xcblxcdFxcdFxcdFxcdHRoaXMuX3NldHVwRGlzYWJsZWQodmFsdWUpO1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy5fc3VwZXIoa2V5LCB2YWx1ZSk7XFxuXFxuXFx0XFx0XFx0aWYgKGtleSA9PT0gXFxcImNvbGxhcHNpYmxlXFxcIikge1xcblxcdFxcdFxcdFxcdHRoaXMuZWxlbWVudC50b2dnbGVDbGFzcyhcXFwidWktdGFicy1jb2xsYXBzaWJsZVxcXCIsIHZhbHVlKTtcXG5cXHRcXHRcXHRcXHQvLyBTZXR0aW5nIGNvbGxhcHNpYmxlOiBmYWxzZSB3aGlsZSBjb2xsYXBzZWQ7IG9wZW4gZmlyc3QgcGFuZWxcXG5cXHRcXHRcXHRcXHRpZiAoIXZhbHVlICYmIHRoaXMub3B0aW9ucy5hY3RpdmUgPT09IGZhbHNlKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fYWN0aXZhdGUoMCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoa2V5ID09PSBcXFwiZXZlbnRcXFwiKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5fc2V0dXBFdmVudHModmFsdWUpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoa2V5ID09PSBcXFwiaGVpZ2h0U3R5bGVcXFwiKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5fc2V0dXBIZWlnaHRTdHlsZSh2YWx1ZSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFxuXFx0XFx0X3Nhbml0aXplU2VsZWN0b3I6IGZ1bmN0aW9uIF9zYW5pdGl6ZVNlbGVjdG9yKGhhc2gpIHtcXG5cXHRcXHRcXHRyZXR1cm4gaGFzaCA/IGhhc2gucmVwbGFjZSgvWyFcXFwiJCUmJygpKissLlxcXFwvOjs8PT4/QFxcXFxbXFxcXF1cXFxcXmB7fH1+XS9nLCBcXFwiXFxcXFxcXFwkJlxcXCIpIDogXFxcIlxcXCI7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRyZWZyZXNoOiBmdW5jdGlvbiByZWZyZXNoKCkge1xcblxcdFxcdFxcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxcblxcdFxcdFxcdCAgICBsaXMgPSB0aGlzLnRhYmxpc3QuY2hpbGRyZW4oXFxcIjpoYXMoYVtocmVmXSlcXFwiKTtcXG5cXG5cXHRcXHRcXHQvLyBnZXQgZGlzYWJsZWQgdGFicyBmcm9tIGNsYXNzIGF0dHJpYnV0ZSBmcm9tIEhUTUxcXG5cXHRcXHRcXHQvLyB0aGlzIHdpbGwgZ2V0IGNvbnZlcnRlZCB0byBhIGJvb2xlYW4gaWYgbmVlZGVkIGluIF9yZWZyZXNoKClcXG5cXHRcXHRcXHRvcHRpb25zLmRpc2FibGVkID0gJC5tYXAobGlzLmZpbHRlcihcXFwiLnVpLXN0YXRlLWRpc2FibGVkXFxcIiksIGZ1bmN0aW9uICh0YWIpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gbGlzLmluZGV4KHRhYik7XFxuXFx0XFx0XFx0fSk7XFxuXFxuXFx0XFx0XFx0dGhpcy5fcHJvY2Vzc1RhYnMoKTtcXG5cXG5cXHRcXHRcXHQvLyB3YXMgY29sbGFwc2VkIG9yIG5vIHRhYnNcXG5cXHRcXHRcXHRpZiAob3B0aW9ucy5hY3RpdmUgPT09IGZhbHNlIHx8ICF0aGlzLmFuY2hvcnMubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0b3B0aW9ucy5hY3RpdmUgPSBmYWxzZTtcXG5cXHRcXHRcXHRcXHR0aGlzLmFjdGl2ZSA9ICQoKTtcXG5cXHRcXHRcXHRcXHQvLyB3YXMgYWN0aXZlLCBidXQgYWN0aXZlIHRhYiBpcyBnb25lXFxuXFx0XFx0XFx0fSBlbHNlIGlmICh0aGlzLmFjdGl2ZS5sZW5ndGggJiYgISQuY29udGFpbnModGhpcy50YWJsaXN0WzBdLCB0aGlzLmFjdGl2ZVswXSkpIHtcXG5cXHRcXHRcXHRcXHQvLyBhbGwgcmVtYWluaW5nIHRhYnMgYXJlIGRpc2FibGVkXFxuXFx0XFx0XFx0XFx0aWYgKHRoaXMudGFicy5sZW5ndGggPT09IG9wdGlvbnMuZGlzYWJsZWQubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0b3B0aW9ucy5hY3RpdmUgPSBmYWxzZTtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmFjdGl2ZSA9ICQoKTtcXG5cXHRcXHRcXHRcXHRcXHQvLyBhY3RpdmF0ZSBwcmV2aW91cyB0YWJcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX2FjdGl2YXRlKHRoaXMuX2ZpbmROZXh0VGFiKE1hdGgubWF4KDAsIG9wdGlvbnMuYWN0aXZlIC0gMSksIGZhbHNlKSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdC8vIHdhcyBhY3RpdmUsIGFjdGl2ZSB0YWIgc3RpbGwgZXhpc3RzXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHQvLyBtYWtlIHN1cmUgYWN0aXZlIGluZGV4IGlzIGNvcnJlY3RcXG5cXHRcXHRcXHRcXHRvcHRpb25zLmFjdGl2ZSA9IHRoaXMudGFicy5pbmRleCh0aGlzLmFjdGl2ZSk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMuX3JlZnJlc2goKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9yZWZyZXNoOiBmdW5jdGlvbiBfcmVmcmVzaCgpIHtcXG5cXHRcXHRcXHR0aGlzLl9zZXR1cERpc2FibGVkKHRoaXMub3B0aW9ucy5kaXNhYmxlZCk7XFxuXFx0XFx0XFx0dGhpcy5fc2V0dXBFdmVudHModGhpcy5vcHRpb25zLmV2ZW50KTtcXG5cXHRcXHRcXHR0aGlzLl9zZXR1cEhlaWdodFN0eWxlKHRoaXMub3B0aW9ucy5oZWlnaHRTdHlsZSk7XFxuXFxuXFx0XFx0XFx0dGhpcy50YWJzLm5vdCh0aGlzLmFjdGl2ZSkuYXR0cih7XFxuXFx0XFx0XFx0XFx0XFxcImFyaWEtc2VsZWN0ZWRcXFwiOiBcXFwiZmFsc2VcXFwiLFxcblxcdFxcdFxcdFxcdFxcXCJhcmlhLWV4cGFuZGVkXFxcIjogXFxcImZhbHNlXFxcIixcXG5cXHRcXHRcXHRcXHR0YWJJbmRleDogLTFcXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHR0aGlzLnBhbmVscy5ub3QodGhpcy5fZ2V0UGFuZWxGb3JUYWIodGhpcy5hY3RpdmUpKS5oaWRlKCkuYXR0cih7XFxuXFx0XFx0XFx0XFx0XFxcImFyaWEtaGlkZGVuXFxcIjogXFxcInRydWVcXFwiXFxuXFx0XFx0XFx0fSk7XFxuXFxuXFx0XFx0XFx0Ly8gTWFrZSBzdXJlIG9uZSB0YWIgaXMgaW4gdGhlIHRhYiBvcmRlclxcblxcdFxcdFxcdGlmICghdGhpcy5hY3RpdmUubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy50YWJzLmVxKDApLmF0dHIoXFxcInRhYkluZGV4XFxcIiwgMCk7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHR0aGlzLmFjdGl2ZS5hZGRDbGFzcyhcXFwidWktdGFicy1hY3RpdmUgdWktc3RhdGUtYWN0aXZlXFxcIikuYXR0cih7XFxuXFx0XFx0XFx0XFx0XFx0XFxcImFyaWEtc2VsZWN0ZWRcXFwiOiBcXFwidHJ1ZVxcXCIsXFxuXFx0XFx0XFx0XFx0XFx0XFxcImFyaWEtZXhwYW5kZWRcXFwiOiBcXFwidHJ1ZVxcXCIsXFxuXFx0XFx0XFx0XFx0XFx0dGFiSW5kZXg6IDBcXG5cXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcXHR0aGlzLl9nZXRQYW5lbEZvclRhYih0aGlzLmFjdGl2ZSkuc2hvdygpLmF0dHIoe1xcblxcdFxcdFxcdFxcdFxcdFxcXCJhcmlhLWhpZGRlblxcXCI6IFxcXCJmYWxzZVxcXCJcXG5cXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfcHJvY2Vzc1RhYnM6IGZ1bmN0aW9uIF9wcm9jZXNzVGFicygpIHtcXG5cXHRcXHRcXHR2YXIgdGhhdCA9IHRoaXMsXFxuXFx0XFx0XFx0ICAgIHByZXZUYWJzID0gdGhpcy50YWJzLFxcblxcdFxcdFxcdCAgICBwcmV2QW5jaG9ycyA9IHRoaXMuYW5jaG9ycyxcXG5cXHRcXHRcXHQgICAgcHJldlBhbmVscyA9IHRoaXMucGFuZWxzO1xcblxcblxcdFxcdFxcdHRoaXMudGFibGlzdCA9IHRoaXMuX2dldExpc3QoKS5hZGRDbGFzcyhcXFwidWktdGFicy1uYXYgdWktaGVscGVyLXJlc2V0IHVpLWhlbHBlci1jbGVhcmZpeCB1aS13aWRnZXQtaGVhZGVyIHVpLWNvcm5lci1hbGxcXFwiKS5hdHRyKFxcXCJyb2xlXFxcIiwgXFxcInRhYmxpc3RcXFwiKVxcblxcblxcdFxcdFxcdC8vIFByZXZlbnQgdXNlcnMgZnJvbSBmb2N1c2luZyBkaXNhYmxlZCB0YWJzIHZpYSBjbGlja1xcblxcdFxcdFxcdC5kZWxlZ2F0ZShcXFwiPiBsaVxcXCIsIFxcXCJtb3VzZWRvd25cXFwiICsgdGhpcy5ldmVudE5hbWVzcGFjZSwgZnVuY3Rpb24gKGV2ZW50KSB7XFxuXFx0XFx0XFx0XFx0aWYgKCQodGhpcykuaXMoXFxcIi51aS1zdGF0ZS1kaXNhYmxlZFxcXCIpKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSlcXG5cXG5cXHRcXHRcXHQvLyBzdXBwb3J0OiBJRSA8OVxcblxcdFxcdFxcdC8vIFByZXZlbnRpbmcgdGhlIGRlZmF1bHQgYWN0aW9uIGluIG1vdXNlZG93biBkb2Vzbid0IHByZXZlbnQgSUVcXG5cXHRcXHRcXHQvLyBmcm9tIGZvY3VzaW5nIHRoZSBlbGVtZW50LCBzbyBpZiB0aGUgYW5jaG9yIGdldHMgZm9jdXNlZCwgYmx1ci5cXG5cXHRcXHRcXHQvLyBXZSBkb24ndCBoYXZlIHRvIHdvcnJ5IGFib3V0IGZvY3VzaW5nIHRoZSBwcmV2aW91c2x5IGZvY3VzZWRcXG5cXHRcXHRcXHQvLyBlbGVtZW50IHNpbmNlIGNsaWNraW5nIG9uIGEgbm9uLWZvY3VzYWJsZSBlbGVtZW50IHNob3VsZCBmb2N1c1xcblxcdFxcdFxcdC8vIHRoZSBib2R5IGFueXdheS5cXG5cXHRcXHRcXHQuZGVsZWdhdGUoXFxcIi51aS10YWJzLWFuY2hvclxcXCIsIFxcXCJmb2N1c1xcXCIgKyB0aGlzLmV2ZW50TmFtZXNwYWNlLCBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCQodGhpcykuY2xvc2VzdChcXFwibGlcXFwiKS5pcyhcXFwiLnVpLXN0YXRlLWRpc2FibGVkXFxcIikpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmJsdXIoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSk7XFxuXFxuXFx0XFx0XFx0dGhpcy50YWJzID0gdGhpcy50YWJsaXN0LmZpbmQoXFxcIj4gbGk6aGFzKGFbaHJlZl0pXFxcIikuYWRkQ2xhc3MoXFxcInVpLXN0YXRlLWRlZmF1bHQgdWktY29ybmVyLXRvcFxcXCIpLmF0dHIoe1xcblxcdFxcdFxcdFxcdHJvbGU6IFxcXCJ0YWJcXFwiLFxcblxcdFxcdFxcdFxcdHRhYkluZGV4OiAtMVxcblxcdFxcdFxcdH0pO1xcblxcblxcdFxcdFxcdHRoaXMuYW5jaG9ycyA9IHRoaXMudGFicy5tYXAoZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdHJldHVybiAkKFxcXCJhXFxcIiwgdGhpcylbMF07XFxuXFx0XFx0XFx0fSkuYWRkQ2xhc3MoXFxcInVpLXRhYnMtYW5jaG9yXFxcIikuYXR0cih7XFxuXFx0XFx0XFx0XFx0cm9sZTogXFxcInByZXNlbnRhdGlvblxcXCIsXFxuXFx0XFx0XFx0XFx0dGFiSW5kZXg6IC0xXFxuXFx0XFx0XFx0fSk7XFxuXFxuXFx0XFx0XFx0dGhpcy5wYW5lbHMgPSAkKCk7XFxuXFxuXFx0XFx0XFx0dGhpcy5hbmNob3JzLmVhY2goZnVuY3Rpb24gKGksIGFuY2hvcikge1xcblxcdFxcdFxcdFxcdHZhciBzZWxlY3RvcixcXG5cXHRcXHRcXHRcXHQgICAgcGFuZWwsXFxuXFx0XFx0XFx0XFx0ICAgIHBhbmVsSWQsXFxuXFx0XFx0XFx0XFx0ICAgIGFuY2hvcklkID0gJChhbmNob3IpLnVuaXF1ZUlkKCkuYXR0cihcXFwiaWRcXFwiKSxcXG5cXHRcXHRcXHRcXHQgICAgdGFiID0gJChhbmNob3IpLmNsb3Nlc3QoXFxcImxpXFxcIiksXFxuXFx0XFx0XFx0XFx0ICAgIG9yaWdpbmFsQXJpYUNvbnRyb2xzID0gdGFiLmF0dHIoXFxcImFyaWEtY29udHJvbHNcXFwiKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBpbmxpbmUgdGFiXFxuXFx0XFx0XFx0XFx0aWYgKHRoYXQuX2lzTG9jYWwoYW5jaG9yKSkge1xcblxcdFxcdFxcdFxcdFxcdHNlbGVjdG9yID0gYW5jaG9yLmhhc2g7XFxuXFx0XFx0XFx0XFx0XFx0cGFuZWxJZCA9IHNlbGVjdG9yLnN1YnN0cmluZygxKTtcXG5cXHRcXHRcXHRcXHRcXHRwYW5lbCA9IHRoYXQuZWxlbWVudC5maW5kKHRoYXQuX3Nhbml0aXplU2VsZWN0b3Ioc2VsZWN0b3IpKTtcXG5cXHRcXHRcXHRcXHRcXHQvLyByZW1vdGUgdGFiXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHQvLyBJZiB0aGUgdGFiIGRvZXNuJ3QgYWxyZWFkeSBoYXZlIGFyaWEtY29udHJvbHMsXFxuXFx0XFx0XFx0XFx0XFx0Ly8gZ2VuZXJhdGUgYW4gaWQgYnkgdXNpbmcgYSB0aHJvdy1hd2F5IGVsZW1lbnRcXG5cXHRcXHRcXHRcXHRcXHRwYW5lbElkID0gdGFiLmF0dHIoXFxcImFyaWEtY29udHJvbHNcXFwiKSB8fCAkKHt9KS51bmlxdWVJZCgpWzBdLmlkO1xcblxcdFxcdFxcdFxcdFxcdHNlbGVjdG9yID0gXFxcIiNcXFwiICsgcGFuZWxJZDtcXG5cXHRcXHRcXHRcXHRcXHRwYW5lbCA9IHRoYXQuZWxlbWVudC5maW5kKHNlbGVjdG9yKTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIXBhbmVsLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHBhbmVsID0gdGhhdC5fY3JlYXRlUGFuZWwocGFuZWxJZCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cGFuZWwuaW5zZXJ0QWZ0ZXIodGhhdC5wYW5lbHNbaSAtIDFdIHx8IHRoYXQudGFibGlzdCk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdHBhbmVsLmF0dHIoXFxcImFyaWEtbGl2ZVxcXCIsIFxcXCJwb2xpdGVcXFwiKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKHBhbmVsLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdFxcdHRoYXQucGFuZWxzID0gdGhhdC5wYW5lbHMuYWRkKHBhbmVsKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aWYgKG9yaWdpbmFsQXJpYUNvbnRyb2xzKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGFiLmRhdGEoXFxcInVpLXRhYnMtYXJpYS1jb250cm9sc1xcXCIsIG9yaWdpbmFsQXJpYUNvbnRyb2xzKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0dGFiLmF0dHIoe1xcblxcdFxcdFxcdFxcdFxcdFxcXCJhcmlhLWNvbnRyb2xzXFxcIjogcGFuZWxJZCxcXG5cXHRcXHRcXHRcXHRcXHRcXFwiYXJpYS1sYWJlbGxlZGJ5XFxcIjogYW5jaG9ySWRcXG5cXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcXHRwYW5lbC5hdHRyKFxcXCJhcmlhLWxhYmVsbGVkYnlcXFwiLCBhbmNob3JJZCk7XFxuXFx0XFx0XFx0fSk7XFxuXFxuXFx0XFx0XFx0dGhpcy5wYW5lbHMuYWRkQ2xhc3MoXFxcInVpLXRhYnMtcGFuZWwgdWktd2lkZ2V0LWNvbnRlbnQgdWktY29ybmVyLWJvdHRvbVxcXCIpLmF0dHIoXFxcInJvbGVcXFwiLCBcXFwidGFicGFuZWxcXFwiKTtcXG5cXG5cXHRcXHRcXHQvLyBBdm9pZCBtZW1vcnkgbGVha3MgKCMxMDA1NilcXG5cXHRcXHRcXHRpZiAocHJldlRhYnMpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9vZmYocHJldlRhYnMubm90KHRoaXMudGFicykpO1xcblxcdFxcdFxcdFxcdHRoaXMuX29mZihwcmV2QW5jaG9ycy5ub3QodGhpcy5hbmNob3JzKSk7XFxuXFx0XFx0XFx0XFx0dGhpcy5fb2ZmKHByZXZQYW5lbHMubm90KHRoaXMucGFuZWxzKSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Ly8gYWxsb3cgb3ZlcnJpZGluZyBob3cgdG8gZmluZCB0aGUgbGlzdCBmb3IgcmFyZSB1c2FnZSBzY2VuYXJpb3MgKCM3NzE1KVxcblxcdFxcdF9nZXRMaXN0OiBmdW5jdGlvbiBfZ2V0TGlzdCgpIHtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy50YWJsaXN0IHx8IHRoaXMuZWxlbWVudC5maW5kKFxcXCJvbCx1bFxcXCIpLmVxKDApO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X2NyZWF0ZVBhbmVsOiBmdW5jdGlvbiBfY3JlYXRlUGFuZWwoaWQpIHtcXG5cXHRcXHRcXHRyZXR1cm4gJChcXFwiPGRpdj5cXFwiKS5hdHRyKFxcXCJpZFxcXCIsIGlkKS5hZGRDbGFzcyhcXFwidWktdGFicy1wYW5lbCB1aS13aWRnZXQtY29udGVudCB1aS1jb3JuZXItYm90dG9tXFxcIikuZGF0YShcXFwidWktdGFicy1kZXN0cm95XFxcIiwgdHJ1ZSk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfc2V0dXBEaXNhYmxlZDogZnVuY3Rpb24gX3NldHVwRGlzYWJsZWQoZGlzYWJsZWQpIHtcXG5cXHRcXHRcXHRpZiAoJC5pc0FycmF5KGRpc2FibGVkKSkge1xcblxcdFxcdFxcdFxcdGlmICghZGlzYWJsZWQubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZGlzYWJsZWQgPSBmYWxzZTtcXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKGRpc2FibGVkLmxlbmd0aCA9PT0gdGhpcy5hbmNob3JzLmxlbmd0aCkge1xcblxcdFxcdFxcdFxcdFxcdGRpc2FibGVkID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIGRpc2FibGUgdGFic1xcblxcdFxcdFxcdGZvciAodmFyIGkgPSAwLCBsaTsgbGkgPSB0aGlzLnRhYnNbaV07IGkrKykge1xcblxcdFxcdFxcdFxcdGlmIChkaXNhYmxlZCA9PT0gdHJ1ZSB8fCAkLmluQXJyYXkoaSwgZGlzYWJsZWQpICE9PSAtMSkge1xcblxcdFxcdFxcdFxcdFxcdCQobGkpLmFkZENsYXNzKFxcXCJ1aS1zdGF0ZS1kaXNhYmxlZFxcXCIpLmF0dHIoXFxcImFyaWEtZGlzYWJsZWRcXFwiLCBcXFwidHJ1ZVxcXCIpO1xcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0JChsaSkucmVtb3ZlQ2xhc3MoXFxcInVpLXN0YXRlLWRpc2FibGVkXFxcIikucmVtb3ZlQXR0cihcXFwiYXJpYS1kaXNhYmxlZFxcXCIpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy5vcHRpb25zLmRpc2FibGVkID0gZGlzYWJsZWQ7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfc2V0dXBFdmVudHM6IGZ1bmN0aW9uIF9zZXR1cEV2ZW50cyhldmVudCkge1xcblxcdFxcdFxcdHZhciBldmVudHMgPSB7fTtcXG5cXHRcXHRcXHRpZiAoZXZlbnQpIHtcXG5cXHRcXHRcXHRcXHQkLmVhY2goZXZlbnQuc3BsaXQoXFxcIiBcXFwiKSwgZnVuY3Rpb24gKGluZGV4LCBldmVudE5hbWUpIHtcXG5cXHRcXHRcXHRcXHRcXHRldmVudHNbZXZlbnROYW1lXSA9IFxcXCJfZXZlbnRIYW5kbGVyXFxcIjtcXG5cXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy5fb2ZmKHRoaXMuYW5jaG9ycy5hZGQodGhpcy50YWJzKS5hZGQodGhpcy5wYW5lbHMpKTtcXG5cXHRcXHRcXHQvLyBBbHdheXMgcHJldmVudCB0aGUgZGVmYXVsdCBhY3Rpb24sIGV2ZW4gd2hlbiBkaXNhYmxlZFxcblxcdFxcdFxcdHRoaXMuX29uKHRydWUsIHRoaXMuYW5jaG9ycywge1xcblxcdFxcdFxcdFxcdGNsaWNrOiBmdW5jdGlvbiBjbGljayhldmVudCkge1xcblxcdFxcdFxcdFxcdFxcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdHRoaXMuX29uKHRoaXMuYW5jaG9ycywgZXZlbnRzKTtcXG5cXHRcXHRcXHR0aGlzLl9vbih0aGlzLnRhYnMsIHsga2V5ZG93bjogXFxcIl90YWJLZXlkb3duXFxcIiB9KTtcXG5cXHRcXHRcXHR0aGlzLl9vbih0aGlzLnBhbmVscywgeyBrZXlkb3duOiBcXFwiX3BhbmVsS2V5ZG93blxcXCIgfSk7XFxuXFxuXFx0XFx0XFx0dGhpcy5fZm9jdXNhYmxlKHRoaXMudGFicyk7XFxuXFx0XFx0XFx0dGhpcy5faG92ZXJhYmxlKHRoaXMudGFicyk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfc2V0dXBIZWlnaHRTdHlsZTogZnVuY3Rpb24gX3NldHVwSGVpZ2h0U3R5bGUoaGVpZ2h0U3R5bGUpIHtcXG5cXHRcXHRcXHR2YXIgbWF4SGVpZ2h0LFxcblxcdFxcdFxcdCAgICBwYXJlbnQgPSB0aGlzLmVsZW1lbnQucGFyZW50KCk7XFxuXFxuXFx0XFx0XFx0aWYgKGhlaWdodFN0eWxlID09PSBcXFwiZmlsbFxcXCIpIHtcXG5cXHRcXHRcXHRcXHRtYXhIZWlnaHQgPSBwYXJlbnQuaGVpZ2h0KCk7XFxuXFx0XFx0XFx0XFx0bWF4SGVpZ2h0IC09IHRoaXMuZWxlbWVudC5vdXRlckhlaWdodCgpIC0gdGhpcy5lbGVtZW50LmhlaWdodCgpO1xcblxcblxcdFxcdFxcdFxcdHRoaXMuZWxlbWVudC5zaWJsaW5ncyhcXFwiOnZpc2libGVcXFwiKS5lYWNoKGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgZWxlbSA9ICQodGhpcyksXFxuXFx0XFx0XFx0XFx0XFx0ICAgIHBvc2l0aW9uID0gZWxlbS5jc3MoXFxcInBvc2l0aW9uXFxcIik7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKHBvc2l0aW9uID09PSBcXFwiYWJzb2x1dGVcXFwiIHx8IHBvc2l0aW9uID09PSBcXFwiZml4ZWRcXFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRtYXhIZWlnaHQgLT0gZWxlbS5vdXRlckhlaWdodCh0cnVlKTtcXG5cXHRcXHRcXHRcXHR9KTtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLmVsZW1lbnQuY2hpbGRyZW4oKS5ub3QodGhpcy5wYW5lbHMpLmVhY2goZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdG1heEhlaWdodCAtPSAkKHRoaXMpLm91dGVySGVpZ2h0KHRydWUpO1xcblxcdFxcdFxcdFxcdH0pO1xcblxcblxcdFxcdFxcdFxcdHRoaXMucGFuZWxzLmVhY2goZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdCQodGhpcykuaGVpZ2h0KE1hdGgubWF4KDAsIG1heEhlaWdodCAtICQodGhpcykuaW5uZXJIZWlnaHQoKSArICQodGhpcykuaGVpZ2h0KCkpKTtcXG5cXHRcXHRcXHRcXHR9KS5jc3MoXFxcIm92ZXJmbG93XFxcIiwgXFxcImF1dG9cXFwiKTtcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKGhlaWdodFN0eWxlID09PSBcXFwiYXV0b1xcXCIpIHtcXG5cXHRcXHRcXHRcXHRtYXhIZWlnaHQgPSAwO1xcblxcdFxcdFxcdFxcdHRoaXMucGFuZWxzLmVhY2goZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdG1heEhlaWdodCA9IE1hdGgubWF4KG1heEhlaWdodCwgJCh0aGlzKS5oZWlnaHQoXFxcIlxcXCIpLmhlaWdodCgpKTtcXG5cXHRcXHRcXHRcXHR9KS5oZWlnaHQobWF4SGVpZ2h0KTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfZXZlbnRIYW5kbGVyOiBmdW5jdGlvbiBfZXZlbnRIYW5kbGVyKGV2ZW50KSB7XFxuXFx0XFx0XFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXFxuXFx0XFx0XFx0ICAgIGFjdGl2ZSA9IHRoaXMuYWN0aXZlLFxcblxcdFxcdFxcdCAgICBhbmNob3IgPSAkKGV2ZW50LmN1cnJlbnRUYXJnZXQpLFxcblxcdFxcdFxcdCAgICB0YWIgPSBhbmNob3IuY2xvc2VzdChcXFwibGlcXFwiKSxcXG5cXHRcXHRcXHQgICAgY2xpY2tlZElzQWN0aXZlID0gdGFiWzBdID09PSBhY3RpdmVbMF0sXFxuXFx0XFx0XFx0ICAgIGNvbGxhcHNpbmcgPSBjbGlja2VkSXNBY3RpdmUgJiYgb3B0aW9ucy5jb2xsYXBzaWJsZSxcXG5cXHRcXHRcXHQgICAgdG9TaG93ID0gY29sbGFwc2luZyA/ICQoKSA6IHRoaXMuX2dldFBhbmVsRm9yVGFiKHRhYiksXFxuXFx0XFx0XFx0ICAgIHRvSGlkZSA9ICFhY3RpdmUubGVuZ3RoID8gJCgpIDogdGhpcy5fZ2V0UGFuZWxGb3JUYWIoYWN0aXZlKSxcXG5cXHRcXHRcXHQgICAgZXZlbnREYXRhID0ge1xcblxcdFxcdFxcdFxcdG9sZFRhYjogYWN0aXZlLFxcblxcdFxcdFxcdFxcdG9sZFBhbmVsOiB0b0hpZGUsXFxuXFx0XFx0XFx0XFx0bmV3VGFiOiBjb2xsYXBzaW5nID8gJCgpIDogdGFiLFxcblxcdFxcdFxcdFxcdG5ld1BhbmVsOiB0b1Nob3dcXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdFxcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XFxuXFxuXFx0XFx0XFx0aWYgKHRhYi5oYXNDbGFzcyhcXFwidWktc3RhdGUtZGlzYWJsZWRcXFwiKSB8fFxcblxcdFxcdFxcdC8vIHRhYiBpcyBhbHJlYWR5IGxvYWRpbmdcXG5cXHRcXHRcXHR0YWIuaGFzQ2xhc3MoXFxcInVpLXRhYnMtbG9hZGluZ1xcXCIpIHx8XFxuXFx0XFx0XFx0Ly8gY2FuJ3Qgc3dpdGNoIGR1cm5pbmcgYW4gYW5pbWF0aW9uXFxuXFx0XFx0XFx0dGhpcy5ydW5uaW5nIHx8XFxuXFx0XFx0XFx0Ly8gY2xpY2sgb24gYWN0aXZlIGhlYWRlciwgYnV0IG5vdCBjb2xsYXBzaWJsZVxcblxcdFxcdFxcdGNsaWNrZWRJc0FjdGl2ZSAmJiAhb3B0aW9ucy5jb2xsYXBzaWJsZSB8fFxcblxcdFxcdFxcdC8vIGFsbG93IGNhbmNlbGluZyBhY3RpdmF0aW9uXFxuXFx0XFx0XFx0dGhpcy5fdHJpZ2dlcihcXFwiYmVmb3JlQWN0aXZhdGVcXFwiLCBldmVudCwgZXZlbnREYXRhKSA9PT0gZmFsc2UpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdG9wdGlvbnMuYWN0aXZlID0gY29sbGFwc2luZyA/IGZhbHNlIDogdGhpcy50YWJzLmluZGV4KHRhYik7XFxuXFxuXFx0XFx0XFx0dGhpcy5hY3RpdmUgPSBjbGlja2VkSXNBY3RpdmUgPyAkKCkgOiB0YWI7XFxuXFx0XFx0XFx0aWYgKHRoaXMueGhyKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy54aHIuYWJvcnQoKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCF0b0hpZGUubGVuZ3RoICYmICF0b1Nob3cubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0JC5lcnJvcihcXFwialF1ZXJ5IFVJIFRhYnM6IE1pc21hdGNoaW5nIGZyYWdtZW50IGlkZW50aWZpZXIuXFxcIik7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICh0b1Nob3cubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5sb2FkKHRoaXMudGFicy5pbmRleCh0YWIpLCBldmVudCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHRoaXMuX3RvZ2dsZShldmVudCwgZXZlbnREYXRhKTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdC8vIGhhbmRsZXMgc2hvdy9oaWRlIGZvciBzZWxlY3RpbmcgdGFic1xcblxcdFxcdF90b2dnbGU6IGZ1bmN0aW9uIF90b2dnbGUoZXZlbnQsIGV2ZW50RGF0YSkge1xcblxcdFxcdFxcdHZhciB0aGF0ID0gdGhpcyxcXG5cXHRcXHRcXHQgICAgdG9TaG93ID0gZXZlbnREYXRhLm5ld1BhbmVsLFxcblxcdFxcdFxcdCAgICB0b0hpZGUgPSBldmVudERhdGEub2xkUGFuZWw7XFxuXFxuXFx0XFx0XFx0dGhpcy5ydW5uaW5nID0gdHJ1ZTtcXG5cXG5cXHRcXHRcXHRmdW5jdGlvbiBjb21wbGV0ZSgpIHtcXG5cXHRcXHRcXHRcXHR0aGF0LnJ1bm5pbmcgPSBmYWxzZTtcXG5cXHRcXHRcXHRcXHR0aGF0Ll90cmlnZ2VyKFxcXCJhY3RpdmF0ZVxcXCIsIGV2ZW50LCBldmVudERhdGEpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRmdW5jdGlvbiBzaG93KCkge1xcblxcdFxcdFxcdFxcdGV2ZW50RGF0YS5uZXdUYWIuY2xvc2VzdChcXFwibGlcXFwiKS5hZGRDbGFzcyhcXFwidWktdGFicy1hY3RpdmUgdWktc3RhdGUtYWN0aXZlXFxcIik7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKHRvU2hvdy5sZW5ndGggJiYgdGhhdC5vcHRpb25zLnNob3cpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGF0Ll9zaG93KHRvU2hvdywgdGhhdC5vcHRpb25zLnNob3csIGNvbXBsZXRlKTtcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdHRvU2hvdy5zaG93KCk7XFxuXFx0XFx0XFx0XFx0XFx0Y29tcGxldGUoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIHN0YXJ0IG91dCBieSBoaWRpbmcsIHRoZW4gc2hvd2luZywgdGhlbiBjb21wbGV0aW5nXFxuXFx0XFx0XFx0aWYgKHRvSGlkZS5sZW5ndGggJiYgdGhpcy5vcHRpb25zLmhpZGUpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9oaWRlKHRvSGlkZSwgdGhpcy5vcHRpb25zLmhpZGUsIGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHRldmVudERhdGEub2xkVGFiLmNsb3Nlc3QoXFxcImxpXFxcIikucmVtb3ZlQ2xhc3MoXFxcInVpLXRhYnMtYWN0aXZlIHVpLXN0YXRlLWFjdGl2ZVxcXCIpO1xcblxcdFxcdFxcdFxcdFxcdHNob3coKTtcXG5cXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdGV2ZW50RGF0YS5vbGRUYWIuY2xvc2VzdChcXFwibGlcXFwiKS5yZW1vdmVDbGFzcyhcXFwidWktdGFicy1hY3RpdmUgdWktc3RhdGUtYWN0aXZlXFxcIik7XFxuXFx0XFx0XFx0XFx0dG9IaWRlLmhpZGUoKTtcXG5cXHRcXHRcXHRcXHRzaG93KCk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRvSGlkZS5hdHRyKFxcXCJhcmlhLWhpZGRlblxcXCIsIFxcXCJ0cnVlXFxcIik7XFxuXFx0XFx0XFx0ZXZlbnREYXRhLm9sZFRhYi5hdHRyKHtcXG5cXHRcXHRcXHRcXHRcXFwiYXJpYS1zZWxlY3RlZFxcXCI6IFxcXCJmYWxzZVxcXCIsXFxuXFx0XFx0XFx0XFx0XFxcImFyaWEtZXhwYW5kZWRcXFwiOiBcXFwiZmFsc2VcXFwiXFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0Ly8gSWYgd2UncmUgc3dpdGNoaW5nIHRhYnMsIHJlbW92ZSB0aGUgb2xkIHRhYiBmcm9tIHRoZSB0YWIgb3JkZXIuXFxuXFx0XFx0XFx0Ly8gSWYgd2UncmUgb3BlbmluZyBmcm9tIGNvbGxhcHNlZCBzdGF0ZSwgcmVtb3ZlIHRoZSBwcmV2aW91cyB0YWIgZnJvbSB0aGUgdGFiIG9yZGVyLlxcblxcdFxcdFxcdC8vIElmIHdlJ3JlIGNvbGxhcHNpbmcsIHRoZW4ga2VlcCB0aGUgY29sbGFwc2luZyB0YWIgaW4gdGhlIHRhYiBvcmRlci5cXG5cXHRcXHRcXHRpZiAodG9TaG93Lmxlbmd0aCAmJiB0b0hpZGUubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0ZXZlbnREYXRhLm9sZFRhYi5hdHRyKFxcXCJ0YWJJbmRleFxcXCIsIC0xKTtcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKHRvU2hvdy5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLnRhYnMuZmlsdGVyKGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gJCh0aGlzKS5hdHRyKFxcXCJ0YWJJbmRleFxcXCIpID09PSAwO1xcblxcdFxcdFxcdFxcdH0pLmF0dHIoXFxcInRhYkluZGV4XFxcIiwgLTEpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0b1Nob3cuYXR0cihcXFwiYXJpYS1oaWRkZW5cXFwiLCBcXFwiZmFsc2VcXFwiKTtcXG5cXHRcXHRcXHRldmVudERhdGEubmV3VGFiLmF0dHIoe1xcblxcdFxcdFxcdFxcdFxcXCJhcmlhLXNlbGVjdGVkXFxcIjogXFxcInRydWVcXFwiLFxcblxcdFxcdFxcdFxcdFxcXCJhcmlhLWV4cGFuZGVkXFxcIjogXFxcInRydWVcXFwiLFxcblxcdFxcdFxcdFxcdHRhYkluZGV4OiAwXFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfYWN0aXZhdGU6IGZ1bmN0aW9uIF9hY3RpdmF0ZShpbmRleCkge1xcblxcdFxcdFxcdHZhciBhbmNob3IsXFxuXFx0XFx0XFx0ICAgIGFjdGl2ZSA9IHRoaXMuX2ZpbmRBY3RpdmUoaW5kZXgpO1xcblxcblxcdFxcdFxcdC8vIHRyeWluZyB0byBhY3RpdmF0ZSB0aGUgYWxyZWFkeSBhY3RpdmUgcGFuZWxcXG5cXHRcXHRcXHRpZiAoYWN0aXZlWzBdID09PSB0aGlzLmFjdGl2ZVswXSkge1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gdHJ5aW5nIHRvIGNvbGxhcHNlLCBzaW11bGF0ZSBhIGNsaWNrIG9uIHRoZSBjdXJyZW50IGFjdGl2ZSBoZWFkZXJcXG5cXHRcXHRcXHRpZiAoIWFjdGl2ZS5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRhY3RpdmUgPSB0aGlzLmFjdGl2ZTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0YW5jaG9yID0gYWN0aXZlLmZpbmQoXFxcIi51aS10YWJzLWFuY2hvclxcXCIpWzBdO1xcblxcdFxcdFxcdHRoaXMuX2V2ZW50SGFuZGxlcih7XFxuXFx0XFx0XFx0XFx0dGFyZ2V0OiBhbmNob3IsXFxuXFx0XFx0XFx0XFx0Y3VycmVudFRhcmdldDogYW5jaG9yLFxcblxcdFxcdFxcdFxcdHByZXZlbnREZWZhdWx0OiAkLm5vb3BcXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9maW5kQWN0aXZlOiBmdW5jdGlvbiBfZmluZEFjdGl2ZShpbmRleCkge1xcblxcdFxcdFxcdHJldHVybiBpbmRleCA9PT0gZmFsc2UgPyAkKCkgOiB0aGlzLnRhYnMuZXEoaW5kZXgpO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X2dldEluZGV4OiBmdW5jdGlvbiBfZ2V0SW5kZXgoaW5kZXgpIHtcXG5cXHRcXHRcXHQvLyBtZXRhLWZ1bmN0aW9uIHRvIGdpdmUgdXNlcnMgb3B0aW9uIHRvIHByb3ZpZGUgYSBocmVmIHN0cmluZyBpbnN0ZWFkIG9mIGEgbnVtZXJpY2FsIGluZGV4LlxcblxcdFxcdFxcdGlmICh0eXBlb2YgaW5kZXggPT09IFxcXCJzdHJpbmdcXFwiKSB7XFxuXFx0XFx0XFx0XFx0aW5kZXggPSB0aGlzLmFuY2hvcnMuaW5kZXgodGhpcy5hbmNob3JzLmZpbHRlcihcXFwiW2hyZWYkPSdcXFwiICsgaW5kZXggKyBcXFwiJ11cXFwiKSk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBpbmRleDtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9kZXN0cm95OiBmdW5jdGlvbiBfZGVzdHJveSgpIHtcXG5cXHRcXHRcXHRpZiAodGhpcy54aHIpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLnhoci5hYm9ydCgpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLmVsZW1lbnQucmVtb3ZlQ2xhc3MoXFxcInVpLXRhYnMgdWktd2lkZ2V0IHVpLXdpZGdldC1jb250ZW50IHVpLWNvcm5lci1hbGwgdWktdGFicy1jb2xsYXBzaWJsZVxcXCIpO1xcblxcblxcdFxcdFxcdHRoaXMudGFibGlzdC5yZW1vdmVDbGFzcyhcXFwidWktdGFicy1uYXYgdWktaGVscGVyLXJlc2V0IHVpLWhlbHBlci1jbGVhcmZpeCB1aS13aWRnZXQtaGVhZGVyIHVpLWNvcm5lci1hbGxcXFwiKS5yZW1vdmVBdHRyKFxcXCJyb2xlXFxcIik7XFxuXFxuXFx0XFx0XFx0dGhpcy5hbmNob3JzLnJlbW92ZUNsYXNzKFxcXCJ1aS10YWJzLWFuY2hvclxcXCIpLnJlbW92ZUF0dHIoXFxcInJvbGVcXFwiKS5yZW1vdmVBdHRyKFxcXCJ0YWJJbmRleFxcXCIpLnJlbW92ZVVuaXF1ZUlkKCk7XFxuXFxuXFx0XFx0XFx0dGhpcy50YWJsaXN0LnVuYmluZCh0aGlzLmV2ZW50TmFtZXNwYWNlKTtcXG5cXG5cXHRcXHRcXHR0aGlzLnRhYnMuYWRkKHRoaXMucGFuZWxzKS5lYWNoKGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRpZiAoJC5kYXRhKHRoaXMsIFxcXCJ1aS10YWJzLWRlc3Ryb3lcXFwiKSkge1xcblxcdFxcdFxcdFxcdFxcdCQodGhpcykucmVtb3ZlKCk7XFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHQkKHRoaXMpLnJlbW92ZUNsYXNzKFxcXCJ1aS1zdGF0ZS1kZWZhdWx0IHVpLXN0YXRlLWFjdGl2ZSB1aS1zdGF0ZS1kaXNhYmxlZCBcXFwiICsgXFxcInVpLWNvcm5lci10b3AgdWktY29ybmVyLWJvdHRvbSB1aS13aWRnZXQtY29udGVudCB1aS10YWJzLWFjdGl2ZSB1aS10YWJzLXBhbmVsXFxcIikucmVtb3ZlQXR0cihcXFwidGFiSW5kZXhcXFwiKS5yZW1vdmVBdHRyKFxcXCJhcmlhLWxpdmVcXFwiKS5yZW1vdmVBdHRyKFxcXCJhcmlhLWJ1c3lcXFwiKS5yZW1vdmVBdHRyKFxcXCJhcmlhLXNlbGVjdGVkXFxcIikucmVtb3ZlQXR0cihcXFwiYXJpYS1sYWJlbGxlZGJ5XFxcIikucmVtb3ZlQXR0cihcXFwiYXJpYS1oaWRkZW5cXFwiKS5yZW1vdmVBdHRyKFxcXCJhcmlhLWV4cGFuZGVkXFxcIikucmVtb3ZlQXR0cihcXFwicm9sZVxcXCIpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9KTtcXG5cXG5cXHRcXHRcXHR0aGlzLnRhYnMuZWFjaChmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0dmFyIGxpID0gJCh0aGlzKSxcXG5cXHRcXHRcXHRcXHQgICAgcHJldiA9IGxpLmRhdGEoXFxcInVpLXRhYnMtYXJpYS1jb250cm9sc1xcXCIpO1xcblxcdFxcdFxcdFxcdGlmIChwcmV2KSB7XFxuXFx0XFx0XFx0XFx0XFx0bGkuYXR0cihcXFwiYXJpYS1jb250cm9sc1xcXCIsIHByZXYpLnJlbW92ZURhdGEoXFxcInVpLXRhYnMtYXJpYS1jb250cm9sc1xcXCIpO1xcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0bGkucmVtb3ZlQXR0cihcXFwiYXJpYS1jb250cm9sc1xcXCIpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9KTtcXG5cXG5cXHRcXHRcXHR0aGlzLnBhbmVscy5zaG93KCk7XFxuXFxuXFx0XFx0XFx0aWYgKHRoaXMub3B0aW9ucy5oZWlnaHRTdHlsZSAhPT0gXFxcImNvbnRlbnRcXFwiKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5wYW5lbHMuY3NzKFxcXCJoZWlnaHRcXFwiLCBcXFwiXFxcIik7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZW5hYmxlOiBmdW5jdGlvbiBlbmFibGUoaW5kZXgpIHtcXG5cXHRcXHRcXHR2YXIgZGlzYWJsZWQgPSB0aGlzLm9wdGlvbnMuZGlzYWJsZWQ7XFxuXFx0XFx0XFx0aWYgKGRpc2FibGVkID09PSBmYWxzZSkge1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcXG5cXHRcXHRcXHRcXHRkaXNhYmxlZCA9IGZhbHNlO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0aW5kZXggPSB0aGlzLl9nZXRJbmRleChpbmRleCk7XFxuXFx0XFx0XFx0XFx0aWYgKCQuaXNBcnJheShkaXNhYmxlZCkpIHtcXG5cXHRcXHRcXHRcXHRcXHRkaXNhYmxlZCA9ICQubWFwKGRpc2FibGVkLCBmdW5jdGlvbiAobnVtKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIG51bSAhPT0gaW5kZXggPyBudW0gOiBudWxsO1xcblxcdFxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0ZGlzYWJsZWQgPSAkLm1hcCh0aGlzLnRhYnMsIGZ1bmN0aW9uIChsaSwgbnVtKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIG51bSAhPT0gaW5kZXggPyBudW0gOiBudWxsO1xcblxcdFxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0dGhpcy5fc2V0dXBEaXNhYmxlZChkaXNhYmxlZCk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRkaXNhYmxlOiBmdW5jdGlvbiBkaXNhYmxlKGluZGV4KSB7XFxuXFx0XFx0XFx0dmFyIGRpc2FibGVkID0gdGhpcy5vcHRpb25zLmRpc2FibGVkO1xcblxcdFxcdFxcdGlmIChkaXNhYmxlZCA9PT0gdHJ1ZSkge1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcXG5cXHRcXHRcXHRcXHRkaXNhYmxlZCA9IHRydWU7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRpbmRleCA9IHRoaXMuX2dldEluZGV4KGluZGV4KTtcXG5cXHRcXHRcXHRcXHRpZiAoJC5pbkFycmF5KGluZGV4LCBkaXNhYmxlZCkgIT09IC0xKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRpZiAoJC5pc0FycmF5KGRpc2FibGVkKSkge1xcblxcdFxcdFxcdFxcdFxcdGRpc2FibGVkID0gJC5tZXJnZShbaW5kZXhdLCBkaXNhYmxlZCkuc29ydCgpO1xcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0ZGlzYWJsZWQgPSBbaW5kZXhdO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0dGhpcy5fc2V0dXBEaXNhYmxlZChkaXNhYmxlZCk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRsb2FkOiBmdW5jdGlvbiBsb2FkKGluZGV4LCBldmVudCkge1xcblxcdFxcdFxcdGluZGV4ID0gdGhpcy5fZ2V0SW5kZXgoaW5kZXgpO1xcblxcdFxcdFxcdHZhciB0aGF0ID0gdGhpcyxcXG5cXHRcXHRcXHQgICAgdGFiID0gdGhpcy50YWJzLmVxKGluZGV4KSxcXG5cXHRcXHRcXHQgICAgYW5jaG9yID0gdGFiLmZpbmQoXFxcIi51aS10YWJzLWFuY2hvclxcXCIpLFxcblxcdFxcdFxcdCAgICBwYW5lbCA9IHRoaXMuX2dldFBhbmVsRm9yVGFiKHRhYiksXFxuXFx0XFx0XFx0ICAgIGV2ZW50RGF0YSA9IHtcXG5cXHRcXHRcXHRcXHR0YWI6IHRhYixcXG5cXHRcXHRcXHRcXHRwYW5lbDogcGFuZWxcXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdCAgICBjb21wbGV0ZSA9IGZ1bmN0aW9uIGNvbXBsZXRlKGpxWEhSLCBzdGF0dXMpIHtcXG5cXHRcXHRcXHRcXHRpZiAoc3RhdHVzID09PSBcXFwiYWJvcnRcXFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhhdC5wYW5lbHMuc3RvcChmYWxzZSwgdHJ1ZSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHRhYi5yZW1vdmVDbGFzcyhcXFwidWktdGFicy1sb2FkaW5nXFxcIik7XFxuXFx0XFx0XFx0XFx0cGFuZWwucmVtb3ZlQXR0cihcXFwiYXJpYS1idXN5XFxcIik7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKGpxWEhSID09PSB0aGF0Lnhocikge1xcblxcdFxcdFxcdFxcdFxcdGRlbGV0ZSB0aGF0LnhocjtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHRcXHQvLyBub3QgcmVtb3RlXFxuXFx0XFx0XFx0aWYgKHRoaXMuX2lzTG9jYWwoYW5jaG9yWzBdKSkge1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy54aHIgPSAkLmFqYXgodGhpcy5fYWpheFNldHRpbmdzKGFuY2hvciwgZXZlbnQsIGV2ZW50RGF0YSkpO1xcblxcblxcdFxcdFxcdC8vIHN1cHBvcnQ6IGpRdWVyeSA8MS44XFxuXFx0XFx0XFx0Ly8galF1ZXJ5IDwxLjggcmV0dXJucyBmYWxzZSBpZiB0aGUgcmVxdWVzdCBpcyBjYW5jZWxlZCBpbiBiZWZvcmVTZW5kLFxcblxcdFxcdFxcdC8vIGJ1dCBhcyBvZiAxLjgsICQuYWpheCgpIGFsd2F5cyByZXR1cm5zIGEganFYSFIgb2JqZWN0LlxcblxcdFxcdFxcdGlmICh0aGlzLnhociAmJiB0aGlzLnhoci5zdGF0dXNUZXh0ICE9PSBcXFwiY2FuY2VsZWRcXFwiKSB7XFxuXFx0XFx0XFx0XFx0dGFiLmFkZENsYXNzKFxcXCJ1aS10YWJzLWxvYWRpbmdcXFwiKTtcXG5cXHRcXHRcXHRcXHRwYW5lbC5hdHRyKFxcXCJhcmlhLWJ1c3lcXFwiLCBcXFwidHJ1ZVxcXCIpO1xcblxcblxcdFxcdFxcdFxcdHRoaXMueGhyLmRvbmUoZnVuY3Rpb24gKHJlc3BvbnNlLCBzdGF0dXMsIGpxWEhSKSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gc3VwcG9ydDogalF1ZXJ5IDwxLjhcXG5cXHRcXHRcXHRcXHRcXHQvLyBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMTc3OFxcblxcdFxcdFxcdFxcdFxcdHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHBhbmVsLmh0bWwocmVzcG9uc2UpO1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoYXQuX3RyaWdnZXIoXFxcImxvYWRcXFwiLCBldmVudCwgZXZlbnREYXRhKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRjb21wbGV0ZShqcVhIUiwgc3RhdHVzKTtcXG5cXHRcXHRcXHRcXHRcXHR9LCAxKTtcXG5cXHRcXHRcXHRcXHR9KS5mYWlsKGZ1bmN0aW9uIChqcVhIUiwgc3RhdHVzKSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gc3VwcG9ydDogalF1ZXJ5IDwxLjhcXG5cXHRcXHRcXHRcXHRcXHQvLyBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMTc3OFxcblxcdFxcdFxcdFxcdFxcdHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGNvbXBsZXRlKGpxWEhSLCBzdGF0dXMpO1xcblxcdFxcdFxcdFxcdFxcdH0sIDEpO1xcblxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcblxcdFxcdF9hamF4U2V0dGluZ3M6IGZ1bmN0aW9uIF9hamF4U2V0dGluZ3MoYW5jaG9yLCBldmVudCwgZXZlbnREYXRhKSB7XFxuXFx0XFx0XFx0dmFyIHRoYXQgPSB0aGlzO1xcblxcdFxcdFxcdHJldHVybiB7XFxuXFx0XFx0XFx0XFx0dXJsOiBhbmNob3IuYXR0cihcXFwiaHJlZlxcXCIpLFxcblxcdFxcdFxcdFxcdGJlZm9yZVNlbmQ6IGZ1bmN0aW9uIGJlZm9yZVNlbmQoanFYSFIsIHNldHRpbmdzKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoYXQuX3RyaWdnZXIoXFxcImJlZm9yZUxvYWRcXFwiLCBldmVudCwgJC5leHRlbmQoeyBqcVhIUjoganFYSFIsIGFqYXhTZXR0aW5nczogc2V0dGluZ3MgfSwgZXZlbnREYXRhKSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH07XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfZ2V0UGFuZWxGb3JUYWI6IGZ1bmN0aW9uIF9nZXRQYW5lbEZvclRhYih0YWIpIHtcXG5cXHRcXHRcXHR2YXIgaWQgPSAkKHRhYikuYXR0cihcXFwiYXJpYS1jb250cm9sc1xcXCIpO1xcblxcdFxcdFxcdHJldHVybiB0aGlzLmVsZW1lbnQuZmluZCh0aGlzLl9zYW5pdGl6ZVNlbGVjdG9yKFxcXCIjXFxcIiArIGlkKSk7XFxuXFx0XFx0fVxcblxcdH0pO1xcblxcblxcdC8qIVxcbiAgKiBqUXVlcnkgVUkgVG9vbHRpcCAxLjExLjRcXG4gICogaHR0cDovL2pxdWVyeXVpLmNvbVxcbiAgKlxcbiAgKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xcbiAgKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXFxuICAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcXG4gICpcXG4gICogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20vdG9vbHRpcC9cXG4gICovXFxuXFxuXFx0dmFyIHRvb2x0aXAgPSAkLndpZGdldChcXFwidWkudG9vbHRpcFxcXCIsIHtcXG5cXHRcXHR2ZXJzaW9uOiBcXFwiMS4xMS40XFxcIixcXG5cXHRcXHRvcHRpb25zOiB7XFxuXFx0XFx0XFx0Y29udGVudDogZnVuY3Rpb24gY29udGVudCgpIHtcXG5cXHRcXHRcXHRcXHQvLyBzdXBwb3J0OiBJRTw5LCBPcGVyYSBpbiBqUXVlcnkgPDEuN1xcblxcdFxcdFxcdFxcdC8vIC50ZXh0KCkgY2FuJ3QgYWNjZXB0IHVuZGVmaW5lZCwgc28gY29lcmNlIHRvIGEgc3RyaW5nXFxuXFx0XFx0XFx0XFx0dmFyIHRpdGxlID0gJCh0aGlzKS5hdHRyKFxcXCJ0aXRsZVxcXCIpIHx8IFxcXCJcXFwiO1xcblxcdFxcdFxcdFxcdC8vIEVzY2FwZSB0aXRsZSwgc2luY2Ugd2UncmUgZ29pbmcgZnJvbSBhbiBhdHRyaWJ1dGUgdG8gcmF3IEhUTUxcXG5cXHRcXHRcXHRcXHRyZXR1cm4gJChcXFwiPGE+XFxcIikudGV4dCh0aXRsZSkuaHRtbCgpO1xcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0aGlkZTogdHJ1ZSxcXG5cXHRcXHRcXHQvLyBEaXNhYmxlZCBlbGVtZW50cyBoYXZlIGluY29uc2lzdGVudCBiZWhhdmlvciBhY3Jvc3MgYnJvd3NlcnMgKCM4NjYxKVxcblxcdFxcdFxcdGl0ZW1zOiBcXFwiW3RpdGxlXTpub3QoW2Rpc2FibGVkXSlcXFwiLFxcblxcdFxcdFxcdHBvc2l0aW9uOiB7XFxuXFx0XFx0XFx0XFx0bXk6IFxcXCJsZWZ0IHRvcCsxNVxcXCIsXFxuXFx0XFx0XFx0XFx0YXQ6IFxcXCJsZWZ0IGJvdHRvbVxcXCIsXFxuXFx0XFx0XFx0XFx0Y29sbGlzaW9uOiBcXFwiZmxpcGZpdCBmbGlwXFxcIlxcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0c2hvdzogdHJ1ZSxcXG5cXHRcXHRcXHR0b29sdGlwQ2xhc3M6IG51bGwsXFxuXFx0XFx0XFx0dHJhY2s6IGZhbHNlLFxcblxcblxcdFxcdFxcdC8vIGNhbGxiYWNrc1xcblxcdFxcdFxcdGNsb3NlOiBudWxsLFxcblxcdFxcdFxcdG9wZW46IG51bGxcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9hZGREZXNjcmliZWRCeTogZnVuY3Rpb24gX2FkZERlc2NyaWJlZEJ5KGVsZW0sIGlkKSB7XFxuXFx0XFx0XFx0dmFyIGRlc2NyaWJlZGJ5ID0gKGVsZW0uYXR0cihcXFwiYXJpYS1kZXNjcmliZWRieVxcXCIpIHx8IFxcXCJcXFwiKS5zcGxpdCgvXFxcXHMrLyk7XFxuXFx0XFx0XFx0ZGVzY3JpYmVkYnkucHVzaChpZCk7XFxuXFx0XFx0XFx0ZWxlbS5kYXRhKFxcXCJ1aS10b29sdGlwLWlkXFxcIiwgaWQpLmF0dHIoXFxcImFyaWEtZGVzY3JpYmVkYnlcXFwiLCAkLnRyaW0oZGVzY3JpYmVkYnkuam9pbihcXFwiIFxcXCIpKSk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfcmVtb3ZlRGVzY3JpYmVkQnk6IGZ1bmN0aW9uIF9yZW1vdmVEZXNjcmliZWRCeShlbGVtKSB7XFxuXFx0XFx0XFx0dmFyIGlkID0gZWxlbS5kYXRhKFxcXCJ1aS10b29sdGlwLWlkXFxcIiksXFxuXFx0XFx0XFx0ICAgIGRlc2NyaWJlZGJ5ID0gKGVsZW0uYXR0cihcXFwiYXJpYS1kZXNjcmliZWRieVxcXCIpIHx8IFxcXCJcXFwiKS5zcGxpdCgvXFxcXHMrLyksXFxuXFx0XFx0XFx0ICAgIGluZGV4ID0gJC5pbkFycmF5KGlkLCBkZXNjcmliZWRieSk7XFxuXFxuXFx0XFx0XFx0aWYgKGluZGV4ICE9PSAtMSkge1xcblxcdFxcdFxcdFxcdGRlc2NyaWJlZGJ5LnNwbGljZShpbmRleCwgMSk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGVsZW0ucmVtb3ZlRGF0YShcXFwidWktdG9vbHRpcC1pZFxcXCIpO1xcblxcdFxcdFxcdGRlc2NyaWJlZGJ5ID0gJC50cmltKGRlc2NyaWJlZGJ5LmpvaW4oXFxcIiBcXFwiKSk7XFxuXFx0XFx0XFx0aWYgKGRlc2NyaWJlZGJ5KSB7XFxuXFx0XFx0XFx0XFx0ZWxlbS5hdHRyKFxcXCJhcmlhLWRlc2NyaWJlZGJ5XFxcIiwgZGVzY3JpYmVkYnkpO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0ZWxlbS5yZW1vdmVBdHRyKFxcXCJhcmlhLWRlc2NyaWJlZGJ5XFxcIik7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFxuXFx0XFx0X2NyZWF0ZTogZnVuY3Rpb24gX2NyZWF0ZSgpIHtcXG5cXHRcXHRcXHR0aGlzLl9vbih7XFxuXFx0XFx0XFx0XFx0bW91c2VvdmVyOiBcXFwib3BlblxcXCIsXFxuXFx0XFx0XFx0XFx0Zm9jdXNpbjogXFxcIm9wZW5cXFwiXFxuXFx0XFx0XFx0fSk7XFxuXFxuXFx0XFx0XFx0Ly8gSURzIG9mIGdlbmVyYXRlZCB0b29sdGlwcywgbmVlZGVkIGZvciBkZXN0cm95XFxuXFx0XFx0XFx0dGhpcy50b29sdGlwcyA9IHt9O1xcblxcblxcdFxcdFxcdC8vIElEcyBvZiBwYXJlbnQgdG9vbHRpcHMgd2hlcmUgd2UgcmVtb3ZlZCB0aGUgdGl0bGUgYXR0cmlidXRlXFxuXFx0XFx0XFx0dGhpcy5wYXJlbnRzID0ge307XFxuXFxuXFx0XFx0XFx0aWYgKHRoaXMub3B0aW9ucy5kaXNhYmxlZCkge1xcblxcdFxcdFxcdFxcdHRoaXMuX2Rpc2FibGUoKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gQXBwZW5kIHRoZSBhcmlhLWxpdmUgcmVnaW9uIHNvIHRvb2x0aXBzIGFubm91bmNlIGNvcnJlY3RseVxcblxcdFxcdFxcdHRoaXMubGl2ZVJlZ2lvbiA9ICQoXFxcIjxkaXY+XFxcIikuYXR0cih7XFxuXFx0XFx0XFx0XFx0cm9sZTogXFxcImxvZ1xcXCIsXFxuXFx0XFx0XFx0XFx0XFxcImFyaWEtbGl2ZVxcXCI6IFxcXCJhc3NlcnRpdmVcXFwiLFxcblxcdFxcdFxcdFxcdFxcXCJhcmlhLXJlbGV2YW50XFxcIjogXFxcImFkZGl0aW9uc1xcXCJcXG5cXHRcXHRcXHR9KS5hZGRDbGFzcyhcXFwidWktaGVscGVyLWhpZGRlbi1hY2Nlc3NpYmxlXFxcIikuYXBwZW5kVG8odGhpcy5kb2N1bWVudFswXS5ib2R5KTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9zZXRPcHRpb246IGZ1bmN0aW9uIF9zZXRPcHRpb24oa2V5LCB2YWx1ZSkge1xcblxcdFxcdFxcdHZhciB0aGF0ID0gdGhpcztcXG5cXG5cXHRcXHRcXHRpZiAoa2V5ID09PSBcXFwiZGlzYWJsZWRcXFwiKSB7XFxuXFx0XFx0XFx0XFx0dGhpc1t2YWx1ZSA/IFxcXCJfZGlzYWJsZVxcXCIgOiBcXFwiX2VuYWJsZVxcXCJdKCk7XFxuXFx0XFx0XFx0XFx0dGhpcy5vcHRpb25zW2tleV0gPSB2YWx1ZTtcXG5cXHRcXHRcXHRcXHQvLyBkaXNhYmxlIGVsZW1lbnQgc3R5bGUgY2hhbmdlc1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy5fc3VwZXIoa2V5LCB2YWx1ZSk7XFxuXFxuXFx0XFx0XFx0aWYgKGtleSA9PT0gXFxcImNvbnRlbnRcXFwiKSB7XFxuXFx0XFx0XFx0XFx0JC5lYWNoKHRoaXMudG9vbHRpcHMsIGZ1bmN0aW9uIChpZCwgdG9vbHRpcERhdGEpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGF0Ll91cGRhdGVDb250ZW50KHRvb2x0aXBEYXRhLmVsZW1lbnQpO1xcblxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcblxcdFxcdF9kaXNhYmxlOiBmdW5jdGlvbiBfZGlzYWJsZSgpIHtcXG5cXHRcXHRcXHR2YXIgdGhhdCA9IHRoaXM7XFxuXFxuXFx0XFx0XFx0Ly8gY2xvc2Ugb3BlbiB0b29sdGlwc1xcblxcdFxcdFxcdCQuZWFjaCh0aGlzLnRvb2x0aXBzLCBmdW5jdGlvbiAoaWQsIHRvb2x0aXBEYXRhKSB7XFxuXFx0XFx0XFx0XFx0dmFyIGV2ZW50ID0gJC5FdmVudChcXFwiYmx1clxcXCIpO1xcblxcdFxcdFxcdFxcdGV2ZW50LnRhcmdldCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQgPSB0b29sdGlwRGF0YS5lbGVtZW50WzBdO1xcblxcdFxcdFxcdFxcdHRoYXQuY2xvc2UoZXZlbnQsIHRydWUpO1xcblxcdFxcdFxcdH0pO1xcblxcblxcdFxcdFxcdC8vIHJlbW92ZSB0aXRsZSBhdHRyaWJ1dGVzIHRvIHByZXZlbnQgbmF0aXZlIHRvb2x0aXBzXFxuXFx0XFx0XFx0dGhpcy5lbGVtZW50LmZpbmQodGhpcy5vcHRpb25zLml0ZW1zKS5hZGRCYWNrKCkuZWFjaChmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0dmFyIGVsZW1lbnQgPSAkKHRoaXMpO1xcblxcdFxcdFxcdFxcdGlmIChlbGVtZW50LmlzKFxcXCJbdGl0bGVdXFxcIikpIHtcXG5cXHRcXHRcXHRcXHRcXHRlbGVtZW50LmRhdGEoXFxcInVpLXRvb2x0aXAtdGl0bGVcXFwiLCBlbGVtZW50LmF0dHIoXFxcInRpdGxlXFxcIikpLnJlbW92ZUF0dHIoXFxcInRpdGxlXFxcIik7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0pO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0X2VuYWJsZTogZnVuY3Rpb24gX2VuYWJsZSgpIHtcXG5cXHRcXHRcXHQvLyByZXN0b3JlIHRpdGxlIGF0dHJpYnV0ZXNcXG5cXHRcXHRcXHR0aGlzLmVsZW1lbnQuZmluZCh0aGlzLm9wdGlvbnMuaXRlbXMpLmFkZEJhY2soKS5lYWNoKGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHR2YXIgZWxlbWVudCA9ICQodGhpcyk7XFxuXFx0XFx0XFx0XFx0aWYgKGVsZW1lbnQuZGF0YShcXFwidWktdG9vbHRpcC10aXRsZVxcXCIpKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZWxlbWVudC5hdHRyKFxcXCJ0aXRsZVxcXCIsIGVsZW1lbnQuZGF0YShcXFwidWktdG9vbHRpcC10aXRsZVxcXCIpKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRvcGVuOiBmdW5jdGlvbiBvcGVuKGV2ZW50KSB7XFxuXFx0XFx0XFx0dmFyIHRoYXQgPSB0aGlzLFxcblxcdFxcdFxcdCAgICB0YXJnZXQgPSAkKGV2ZW50ID8gZXZlbnQudGFyZ2V0IDogdGhpcy5lbGVtZW50KVxcblxcdFxcdFxcdC8vIHdlIG5lZWQgY2xvc2VzdCBoZXJlIGR1ZSB0byBtb3VzZW92ZXIgYnViYmxpbmcsXFxuXFx0XFx0XFx0Ly8gYnV0IGFsd2F5cyBwb2ludGluZyBhdCB0aGUgc2FtZSBldmVudCB0YXJnZXRcXG5cXHRcXHRcXHQuY2xvc2VzdCh0aGlzLm9wdGlvbnMuaXRlbXMpO1xcblxcblxcdFxcdFxcdC8vIE5vIGVsZW1lbnQgdG8gc2hvdyBhIHRvb2x0aXAgZm9yIG9yIHRoZSB0b29sdGlwIGlzIGFscmVhZHkgb3BlblxcblxcdFxcdFxcdGlmICghdGFyZ2V0Lmxlbmd0aCB8fCB0YXJnZXQuZGF0YShcXFwidWktdG9vbHRpcC1pZFxcXCIpKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAodGFyZ2V0LmF0dHIoXFxcInRpdGxlXFxcIikpIHtcXG5cXHRcXHRcXHRcXHR0YXJnZXQuZGF0YShcXFwidWktdG9vbHRpcC10aXRsZVxcXCIsIHRhcmdldC5hdHRyKFxcXCJ0aXRsZVxcXCIpKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGFyZ2V0LmRhdGEoXFxcInVpLXRvb2x0aXAtb3BlblxcXCIsIHRydWUpO1xcblxcblxcdFxcdFxcdC8vIGtpbGwgcGFyZW50IHRvb2x0aXBzLCBjdXN0b20gb3IgbmF0aXZlLCBmb3IgaG92ZXJcXG5cXHRcXHRcXHRpZiAoZXZlbnQgJiYgZXZlbnQudHlwZSA9PT0gXFxcIm1vdXNlb3ZlclxcXCIpIHtcXG5cXHRcXHRcXHRcXHR0YXJnZXQucGFyZW50cygpLmVhY2goZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdHZhciBwYXJlbnQgPSAkKHRoaXMpLFxcblxcdFxcdFxcdFxcdFxcdCAgICBibHVyRXZlbnQ7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHBhcmVudC5kYXRhKFxcXCJ1aS10b29sdGlwLW9wZW5cXFwiKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGJsdXJFdmVudCA9ICQuRXZlbnQoXFxcImJsdXJcXFwiKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRibHVyRXZlbnQudGFyZ2V0ID0gYmx1ckV2ZW50LmN1cnJlbnRUYXJnZXQgPSB0aGlzO1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoYXQuY2xvc2UoYmx1ckV2ZW50LCB0cnVlKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHBhcmVudC5hdHRyKFxcXCJ0aXRsZVxcXCIpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cGFyZW50LnVuaXF1ZUlkKCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhhdC5wYXJlbnRzW3RoaXMuaWRdID0ge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGVsZW1lbnQ6IHRoaXMsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGl0bGU6IHBhcmVudC5hdHRyKFxcXCJ0aXRsZVxcXCIpXFxuXFx0XFx0XFx0XFx0XFx0XFx0fTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRwYXJlbnQuYXR0cihcXFwidGl0bGVcXFwiLCBcXFwiXFxcIik7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLl9yZWdpc3RlckNsb3NlSGFuZGxlcnMoZXZlbnQsIHRhcmdldCk7XFxuXFx0XFx0XFx0dGhpcy5fdXBkYXRlQ29udGVudCh0YXJnZXQsIGV2ZW50KTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF91cGRhdGVDb250ZW50OiBmdW5jdGlvbiBfdXBkYXRlQ29udGVudCh0YXJnZXQsIGV2ZW50KSB7XFxuXFx0XFx0XFx0dmFyIGNvbnRlbnQsXFxuXFx0XFx0XFx0ICAgIGNvbnRlbnRPcHRpb24gPSB0aGlzLm9wdGlvbnMuY29udGVudCxcXG5cXHRcXHRcXHQgICAgdGhhdCA9IHRoaXMsXFxuXFx0XFx0XFx0ICAgIGV2ZW50VHlwZSA9IGV2ZW50ID8gZXZlbnQudHlwZSA6IG51bGw7XFxuXFxuXFx0XFx0XFx0aWYgKHR5cGVvZiBjb250ZW50T3B0aW9uID09PSBcXFwic3RyaW5nXFxcIikge1xcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLl9vcGVuKGV2ZW50LCB0YXJnZXQsIGNvbnRlbnRPcHRpb24pO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRjb250ZW50ID0gY29udGVudE9wdGlvbi5jYWxsKHRhcmdldFswXSwgZnVuY3Rpb24gKHJlc3BvbnNlKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSUUgbWF5IGluc3RhbnRseSBzZXJ2ZSBhIGNhY2hlZCByZXNwb25zZSBmb3IgYWpheCByZXF1ZXN0c1xcblxcdFxcdFxcdFxcdC8vIGRlbGF5IHRoaXMgY2FsbCB0byBfb3BlbiBzbyB0aGUgb3RoZXIgY2FsbCB0byBfb3BlbiBydW5zIGZpcnN0XFxuXFx0XFx0XFx0XFx0dGhhdC5fZGVsYXkoZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIElnbm9yZSBhc3luYyByZXNwb25zZSBpZiB0b29sdGlwIHdhcyBjbG9zZWQgYWxyZWFkeVxcblxcdFxcdFxcdFxcdFxcdGlmICghdGFyZ2V0LmRhdGEoXFxcInVpLXRvb2x0aXAtb3BlblxcXCIpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBqUXVlcnkgY3JlYXRlcyBhIHNwZWNpYWwgZXZlbnQgZm9yIGZvY3VzaW4gd2hlbiBpdCBkb2Vzbid0XFxuXFx0XFx0XFx0XFx0XFx0Ly8gZXhpc3QgbmF0aXZlbHkuIFRvIGltcHJvdmUgcGVyZm9ybWFuY2UsIHRoZSBuYXRpdmUgZXZlbnRcXG5cXHRcXHRcXHRcXHRcXHQvLyBvYmplY3QgaXMgcmV1c2VkIGFuZCB0aGUgdHlwZSBpcyBjaGFuZ2VkLiBUaGVyZWZvcmUsIHdlIGNhbid0XFxuXFx0XFx0XFx0XFx0XFx0Ly8gcmVseSBvbiB0aGUgdHlwZSBiZWluZyBjb3JyZWN0IGFmdGVyIHRoZSBldmVudCBmaW5pc2hlZFxcblxcdFxcdFxcdFxcdFxcdC8vIGJ1YmJsaW5nLCBzbyB3ZSBzZXQgaXQgYmFjayB0byB0aGUgcHJldmlvdXMgdmFsdWUuICgjODc0MClcXG5cXHRcXHRcXHRcXHRcXHRpZiAoZXZlbnQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRldmVudC50eXBlID0gZXZlbnRUeXBlO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9vcGVuKGV2ZW50LCB0YXJnZXQsIHJlc3BvbnNlKTtcXG5cXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRpZiAoY29udGVudCkge1xcblxcdFxcdFxcdFxcdHRoaXMuX29wZW4oZXZlbnQsIHRhcmdldCwgY29udGVudCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFxuXFx0XFx0X29wZW46IGZ1bmN0aW9uIF9vcGVuKGV2ZW50LCB0YXJnZXQsIGNvbnRlbnQpIHtcXG5cXHRcXHRcXHR2YXIgdG9vbHRpcERhdGEsXFxuXFx0XFx0XFx0ICAgIHRvb2x0aXAsXFxuXFx0XFx0XFx0ICAgIGRlbGF5ZWRTaG93LFxcblxcdFxcdFxcdCAgICBhMTF5Q29udGVudCxcXG5cXHRcXHRcXHQgICAgcG9zaXRpb25PcHRpb24gPSAkLmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zLnBvc2l0aW9uKTtcXG5cXG5cXHRcXHRcXHRpZiAoIWNvbnRlbnQpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIENvbnRlbnQgY2FuIGJlIHVwZGF0ZWQgbXVsdGlwbGUgdGltZXMuIElmIHRoZSB0b29sdGlwIGFscmVhZHlcXG5cXHRcXHRcXHQvLyBleGlzdHMsIHRoZW4ganVzdCB1cGRhdGUgdGhlIGNvbnRlbnQgYW5kIGJhaWwuXFxuXFx0XFx0XFx0dG9vbHRpcERhdGEgPSB0aGlzLl9maW5kKHRhcmdldCk7XFxuXFx0XFx0XFx0aWYgKHRvb2x0aXBEYXRhKSB7XFxuXFx0XFx0XFx0XFx0dG9vbHRpcERhdGEudG9vbHRpcC5maW5kKFxcXCIudWktdG9vbHRpcC1jb250ZW50XFxcIikuaHRtbChjb250ZW50KTtcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIGlmIHdlIGhhdmUgYSB0aXRsZSwgY2xlYXIgaXQgdG8gcHJldmVudCB0aGUgbmF0aXZlIHRvb2x0aXBcXG5cXHRcXHRcXHQvLyB3ZSBoYXZlIHRvIGNoZWNrIGZpcnN0IHRvIGF2b2lkIGRlZmluaW5nIGEgdGl0bGUgaWYgbm9uZSBleGlzdHNcXG5cXHRcXHRcXHQvLyAod2UgZG9uJ3Qgd2FudCB0byBjYXVzZSBhbiBlbGVtZW50IHRvIHN0YXJ0IG1hdGNoaW5nIFt0aXRsZV0pXFxuXFx0XFx0XFx0Ly9cXG5cXHRcXHRcXHQvLyBXZSB1c2UgcmVtb3ZlQXR0ciBvbmx5IGZvciBrZXkgZXZlbnRzLCB0byBhbGxvdyBJRSB0byBleHBvcnQgdGhlIGNvcnJlY3RcXG5cXHRcXHRcXHQvLyBhY2Nlc3NpYmxlIGF0dHJpYnV0ZXMuIEZvciBtb3VzZSBldmVudHMsIHNldCB0byBlbXB0eSBzdHJpbmcgdG8gYXZvaWRcXG5cXHRcXHRcXHQvLyBuYXRpdmUgdG9vbHRpcCBzaG93aW5nIHVwIChoYXBwZW5zIG9ubHkgd2hlbiByZW1vdmluZyBpbnNpZGUgbW91c2VvdmVyKS5cXG5cXHRcXHRcXHRpZiAodGFyZ2V0LmlzKFxcXCJbdGl0bGVdXFxcIikpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZXZlbnQgJiYgZXZlbnQudHlwZSA9PT0gXFxcIm1vdXNlb3ZlclxcXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHR0YXJnZXQuYXR0cihcXFwidGl0bGVcXFwiLCBcXFwiXFxcIik7XFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHR0YXJnZXQucmVtb3ZlQXR0cihcXFwidGl0bGVcXFwiKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRvb2x0aXBEYXRhID0gdGhpcy5fdG9vbHRpcCh0YXJnZXQpO1xcblxcdFxcdFxcdHRvb2x0aXAgPSB0b29sdGlwRGF0YS50b29sdGlwO1xcblxcdFxcdFxcdHRoaXMuX2FkZERlc2NyaWJlZEJ5KHRhcmdldCwgdG9vbHRpcC5hdHRyKFxcXCJpZFxcXCIpKTtcXG5cXHRcXHRcXHR0b29sdGlwLmZpbmQoXFxcIi51aS10b29sdGlwLWNvbnRlbnRcXFwiKS5odG1sKGNvbnRlbnQpO1xcblxcblxcdFxcdFxcdC8vIFN1cHBvcnQ6IFZvaWNlb3ZlciBvbiBPUyBYLCBKQVdTIG9uIElFIDw9IDlcXG5cXHRcXHRcXHQvLyBKQVdTIGFubm91bmNlcyBkZWxldGlvbnMgZXZlbiB3aGVuIGFyaWEtcmVsZXZhbnQ9XFxcImFkZGl0aW9uc1xcXCJcXG5cXHRcXHRcXHQvLyBWb2ljZW92ZXIgd2lsbCBzb21ldGltZXMgcmUtcmVhZCB0aGUgZW50aXJlIGxvZyByZWdpb24ncyBjb250ZW50cyBmcm9tIHRoZSBiZWdpbm5pbmdcXG5cXHRcXHRcXHR0aGlzLmxpdmVSZWdpb24uY2hpbGRyZW4oKS5oaWRlKCk7XFxuXFx0XFx0XFx0aWYgKGNvbnRlbnQuY2xvbmUpIHtcXG5cXHRcXHRcXHRcXHRhMTF5Q29udGVudCA9IGNvbnRlbnQuY2xvbmUoKTtcXG5cXHRcXHRcXHRcXHRhMTF5Q29udGVudC5yZW1vdmVBdHRyKFxcXCJpZFxcXCIpLmZpbmQoXFxcIltpZF1cXFwiKS5yZW1vdmVBdHRyKFxcXCJpZFxcXCIpO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0YTExeUNvbnRlbnQgPSBjb250ZW50O1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHQkKFxcXCI8ZGl2PlxcXCIpLmh0bWwoYTExeUNvbnRlbnQpLmFwcGVuZFRvKHRoaXMubGl2ZVJlZ2lvbik7XFxuXFxuXFx0XFx0XFx0ZnVuY3Rpb24gcG9zaXRpb24oZXZlbnQpIHtcXG5cXHRcXHRcXHRcXHRwb3NpdGlvbk9wdGlvbi5vZiA9IGV2ZW50O1xcblxcdFxcdFxcdFxcdGlmICh0b29sdGlwLmlzKFxcXCI6aGlkZGVuXFxcIikpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHRvb2x0aXAucG9zaXRpb24ocG9zaXRpb25PcHRpb24pO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAodGhpcy5vcHRpb25zLnRyYWNrICYmIGV2ZW50ICYmIC9ebW91c2UvLnRlc3QoZXZlbnQudHlwZSkpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9vbih0aGlzLmRvY3VtZW50LCB7XFxuXFx0XFx0XFx0XFx0XFx0bW91c2Vtb3ZlOiBwb3NpdGlvblxcblxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdFxcdC8vIHRyaWdnZXIgb25jZSB0byBvdmVycmlkZSBlbGVtZW50LXJlbGF0aXZlIHBvc2l0aW9uaW5nXFxuXFx0XFx0XFx0XFx0cG9zaXRpb24oZXZlbnQpO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0dG9vbHRpcC5wb3NpdGlvbigkLmV4dGVuZCh7XFxuXFx0XFx0XFx0XFx0XFx0b2Y6IHRhcmdldFxcblxcdFxcdFxcdFxcdH0sIHRoaXMub3B0aW9ucy5wb3NpdGlvbikpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0b29sdGlwLmhpZGUoKTtcXG5cXG5cXHRcXHRcXHR0aGlzLl9zaG93KHRvb2x0aXAsIHRoaXMub3B0aW9ucy5zaG93KTtcXG5cXHRcXHRcXHQvLyBIYW5kbGUgdHJhY2tpbmcgdG9vbHRpcHMgdGhhdCBhcmUgc2hvd24gd2l0aCBhIGRlbGF5ICgjODY0NCkuIEFzIHNvb25cXG5cXHRcXHRcXHQvLyBhcyB0aGUgdG9vbHRpcCBpcyB2aXNpYmxlLCBwb3NpdGlvbiB0aGUgdG9vbHRpcCB1c2luZyB0aGUgbW9zdCByZWNlbnRcXG5cXHRcXHRcXHQvLyBldmVudC5cXG5cXHRcXHRcXHRpZiAodGhpcy5vcHRpb25zLnNob3cgJiYgdGhpcy5vcHRpb25zLnNob3cuZGVsYXkpIHtcXG5cXHRcXHRcXHRcXHRkZWxheWVkU2hvdyA9IHRoaXMuZGVsYXllZFNob3cgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHRvb2x0aXAuaXMoXFxcIjp2aXNpYmxlXFxcIikpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRwb3NpdGlvbihwb3NpdGlvbk9wdGlvbi5vZik7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2xlYXJJbnRlcnZhbChkZWxheWVkU2hvdyk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH0sICQuZnguaW50ZXJ2YWwpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLl90cmlnZ2VyKFxcXCJvcGVuXFxcIiwgZXZlbnQsIHsgdG9vbHRpcDogdG9vbHRpcCB9KTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9yZWdpc3RlckNsb3NlSGFuZGxlcnM6IGZ1bmN0aW9uIF9yZWdpc3RlckNsb3NlSGFuZGxlcnMoZXZlbnQsIHRhcmdldCkge1xcblxcdFxcdFxcdHZhciBldmVudHMgPSB7XFxuXFx0XFx0XFx0XFx0a2V5dXA6IGZ1bmN0aW9uIGtleXVwKGV2ZW50KSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKGV2ZW50LmtleUNvZGUgPT09ICQudWkua2V5Q29kZS5FU0NBUEUpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgZmFrZUV2ZW50ID0gJC5FdmVudChldmVudCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZmFrZUV2ZW50LmN1cnJlbnRUYXJnZXQgPSB0YXJnZXRbMF07XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5jbG9zZShmYWtlRXZlbnQsIHRydWUpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHRcXHQvLyBPbmx5IGJpbmQgcmVtb3ZlIGhhbmRsZXIgZm9yIGRlbGVnYXRlZCB0YXJnZXRzLiBOb24tZGVsZWdhdGVkXFxuXFx0XFx0XFx0Ly8gdG9vbHRpcHMgd2lsbCBoYW5kbGUgdGhpcyBpbiBkZXN0cm95LlxcblxcdFxcdFxcdGlmICh0YXJnZXRbMF0gIT09IHRoaXMuZWxlbWVudFswXSkge1xcblxcdFxcdFxcdFxcdGV2ZW50cy5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fcmVtb3ZlVG9vbHRpcCh0aGlzLl9maW5kKHRhcmdldCkudG9vbHRpcCk7XFxuXFx0XFx0XFx0XFx0fTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCFldmVudCB8fCBldmVudC50eXBlID09PSBcXFwibW91c2VvdmVyXFxcIikge1xcblxcdFxcdFxcdFxcdGV2ZW50cy5tb3VzZWxlYXZlID0gXFxcImNsb3NlXFxcIjtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWYgKCFldmVudCB8fCBldmVudC50eXBlID09PSBcXFwiZm9jdXNpblxcXCIpIHtcXG5cXHRcXHRcXHRcXHRldmVudHMuZm9jdXNvdXQgPSBcXFwiY2xvc2VcXFwiO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHR0aGlzLl9vbih0cnVlLCB0YXJnZXQsIGV2ZW50cyk7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjbG9zZTogZnVuY3Rpb24gY2xvc2UoZXZlbnQpIHtcXG5cXHRcXHRcXHR2YXIgdG9vbHRpcCxcXG5cXHRcXHRcXHQgICAgdGhhdCA9IHRoaXMsXFxuXFx0XFx0XFx0ICAgIHRhcmdldCA9ICQoZXZlbnQgPyBldmVudC5jdXJyZW50VGFyZ2V0IDogdGhpcy5lbGVtZW50KSxcXG5cXHRcXHRcXHQgICAgdG9vbHRpcERhdGEgPSB0aGlzLl9maW5kKHRhcmdldCk7XFxuXFxuXFx0XFx0XFx0Ly8gVGhlIHRvb2x0aXAgbWF5IGFscmVhZHkgYmUgY2xvc2VkXFxuXFx0XFx0XFx0aWYgKCF0b29sdGlwRGF0YSkge1xcblxcblxcdFxcdFxcdFxcdC8vIFdlIHNldCB1aS10b29sdGlwLW9wZW4gaW1tZWRpYXRlbHkgdXBvbiBvcGVuIChpbiBvcGVuKCkpLCBidXQgb25seSBzZXQgdGhlXFxuXFx0XFx0XFx0XFx0Ly8gYWRkaXRpb25hbCBkYXRhIG9uY2UgdGhlcmUncyBhY3R1YWxseSBjb250ZW50IHRvIHNob3cgKGluIF9vcGVuKCkpLiBTbyBldmVuIGlmIHRoZVxcblxcdFxcdFxcdFxcdC8vIHRvb2x0aXAgZG9lc24ndCBoYXZlIGZ1bGwgZGF0YSwgd2UgYWx3YXlzIHJlbW92ZSB1aS10b29sdGlwLW9wZW4gaW4gY2FzZSB3ZSdyZSBpblxcblxcdFxcdFxcdFxcdC8vIHRoZSBwZXJpb2QgYmV0d2VlbiBvcGVuKCkgYW5kIF9vcGVuKCkuXFxuXFx0XFx0XFx0XFx0dGFyZ2V0LnJlbW92ZURhdGEoXFxcInVpLXRvb2x0aXAtb3BlblxcXCIpO1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dG9vbHRpcCA9IHRvb2x0aXBEYXRhLnRvb2x0aXA7XFxuXFxuXFx0XFx0XFx0Ly8gZGlzYWJsaW5nIGNsb3NlcyB0aGUgdG9vbHRpcCwgc28gd2UgbmVlZCB0byB0cmFjayB3aGVuIHdlJ3JlIGNsb3NpbmdcXG5cXHRcXHRcXHQvLyB0byBhdm9pZCBhbiBpbmZpbml0ZSBsb29wIGluIGNhc2UgdGhlIHRvb2x0aXAgYmVjb21lcyBkaXNhYmxlZCBvbiBjbG9zZVxcblxcdFxcdFxcdGlmICh0b29sdGlwRGF0YS5jbG9zaW5nKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBDbGVhciB0aGUgaW50ZXJ2YWwgZm9yIGRlbGF5ZWQgdHJhY2tpbmcgdG9vbHRpcHNcXG5cXHRcXHRcXHRjbGVhckludGVydmFsKHRoaXMuZGVsYXllZFNob3cpO1xcblxcblxcdFxcdFxcdC8vIG9ubHkgc2V0IHRpdGxlIGlmIHdlIGhhZCBvbmUgYmVmb3JlIChzZWUgY29tbWVudCBpbiBfb3BlbigpKVxcblxcdFxcdFxcdC8vIElmIHRoZSB0aXRsZSBhdHRyaWJ1dGUgaGFzIGNoYW5nZWQgc2luY2Ugb3BlbigpLCBkb24ndCByZXN0b3JlXFxuXFx0XFx0XFx0aWYgKHRhcmdldC5kYXRhKFxcXCJ1aS10b29sdGlwLXRpdGxlXFxcIikgJiYgIXRhcmdldC5hdHRyKFxcXCJ0aXRsZVxcXCIpKSB7XFxuXFx0XFx0XFx0XFx0dGFyZ2V0LmF0dHIoXFxcInRpdGxlXFxcIiwgdGFyZ2V0LmRhdGEoXFxcInVpLXRvb2x0aXAtdGl0bGVcXFwiKSk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMuX3JlbW92ZURlc2NyaWJlZEJ5KHRhcmdldCk7XFxuXFxuXFx0XFx0XFx0dG9vbHRpcERhdGEuaGlkaW5nID0gdHJ1ZTtcXG5cXHRcXHRcXHR0b29sdGlwLnN0b3AodHJ1ZSk7XFxuXFx0XFx0XFx0dGhpcy5faGlkZSh0b29sdGlwLCB0aGlzLm9wdGlvbnMuaGlkZSwgZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdHRoYXQuX3JlbW92ZVRvb2x0aXAoJCh0aGlzKSk7XFxuXFx0XFx0XFx0fSk7XFxuXFxuXFx0XFx0XFx0dGFyZ2V0LnJlbW92ZURhdGEoXFxcInVpLXRvb2x0aXAtb3BlblxcXCIpO1xcblxcdFxcdFxcdHRoaXMuX29mZih0YXJnZXQsIFxcXCJtb3VzZWxlYXZlIGZvY3Vzb3V0IGtleXVwXFxcIik7XFxuXFxuXFx0XFx0XFx0Ly8gUmVtb3ZlICdyZW1vdmUnIGJpbmRpbmcgb25seSBvbiBkZWxlZ2F0ZWQgdGFyZ2V0c1xcblxcdFxcdFxcdGlmICh0YXJnZXRbMF0gIT09IHRoaXMuZWxlbWVudFswXSkge1xcblxcdFxcdFxcdFxcdHRoaXMuX29mZih0YXJnZXQsIFxcXCJyZW1vdmVcXFwiKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0dGhpcy5fb2ZmKHRoaXMuZG9jdW1lbnQsIFxcXCJtb3VzZW1vdmVcXFwiKTtcXG5cXG5cXHRcXHRcXHRpZiAoZXZlbnQgJiYgZXZlbnQudHlwZSA9PT0gXFxcIm1vdXNlbGVhdmVcXFwiKSB7XFxuXFx0XFx0XFx0XFx0JC5lYWNoKHRoaXMucGFyZW50cywgZnVuY3Rpb24gKGlkLCBwYXJlbnQpIHtcXG5cXHRcXHRcXHRcXHRcXHQkKHBhcmVudC5lbGVtZW50KS5hdHRyKFxcXCJ0aXRsZVxcXCIsIHBhcmVudC50aXRsZSk7XFxuXFx0XFx0XFx0XFx0XFx0ZGVsZXRlIHRoYXQucGFyZW50c1tpZF07XFxuXFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRvb2x0aXBEYXRhLmNsb3NpbmcgPSB0cnVlO1xcblxcdFxcdFxcdHRoaXMuX3RyaWdnZXIoXFxcImNsb3NlXFxcIiwgZXZlbnQsIHsgdG9vbHRpcDogdG9vbHRpcCB9KTtcXG5cXHRcXHRcXHRpZiAoIXRvb2x0aXBEYXRhLmhpZGluZykge1xcblxcdFxcdFxcdFxcdHRvb2x0aXBEYXRhLmNsb3NpbmcgPSBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfdG9vbHRpcDogZnVuY3Rpb24gX3Rvb2x0aXAoZWxlbWVudCkge1xcblxcdFxcdFxcdHZhciB0b29sdGlwID0gJChcXFwiPGRpdj5cXFwiKS5hdHRyKFxcXCJyb2xlXFxcIiwgXFxcInRvb2x0aXBcXFwiKS5hZGRDbGFzcyhcXFwidWktdG9vbHRpcCB1aS13aWRnZXQgdWktY29ybmVyLWFsbCB1aS13aWRnZXQtY29udGVudCBcXFwiICsgKHRoaXMub3B0aW9ucy50b29sdGlwQ2xhc3MgfHwgXFxcIlxcXCIpKSxcXG5cXHRcXHRcXHQgICAgaWQgPSB0b29sdGlwLnVuaXF1ZUlkKCkuYXR0cihcXFwiaWRcXFwiKTtcXG5cXG5cXHRcXHRcXHQkKFxcXCI8ZGl2PlxcXCIpLmFkZENsYXNzKFxcXCJ1aS10b29sdGlwLWNvbnRlbnRcXFwiKS5hcHBlbmRUbyh0b29sdGlwKTtcXG5cXG5cXHRcXHRcXHR0b29sdGlwLmFwcGVuZFRvKHRoaXMuZG9jdW1lbnRbMF0uYm9keSk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMudG9vbHRpcHNbaWRdID0ge1xcblxcdFxcdFxcdFxcdGVsZW1lbnQ6IGVsZW1lbnQsXFxuXFx0XFx0XFx0XFx0dG9vbHRpcDogdG9vbHRpcFxcblxcdFxcdFxcdH07XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfZmluZDogZnVuY3Rpb24gX2ZpbmQodGFyZ2V0KSB7XFxuXFx0XFx0XFx0dmFyIGlkID0gdGFyZ2V0LmRhdGEoXFxcInVpLXRvb2x0aXAtaWRcXFwiKTtcXG5cXHRcXHRcXHRyZXR1cm4gaWQgPyB0aGlzLnRvb2x0aXBzW2lkXSA6IG51bGw7XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfcmVtb3ZlVG9vbHRpcDogZnVuY3Rpb24gX3JlbW92ZVRvb2x0aXAodG9vbHRpcCkge1xcblxcdFxcdFxcdHRvb2x0aXAucmVtb3ZlKCk7XFxuXFx0XFx0XFx0ZGVsZXRlIHRoaXMudG9vbHRpcHNbdG9vbHRpcC5hdHRyKFxcXCJpZFxcXCIpXTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdF9kZXN0cm95OiBmdW5jdGlvbiBfZGVzdHJveSgpIHtcXG5cXHRcXHRcXHR2YXIgdGhhdCA9IHRoaXM7XFxuXFxuXFx0XFx0XFx0Ly8gY2xvc2Ugb3BlbiB0b29sdGlwc1xcblxcdFxcdFxcdCQuZWFjaCh0aGlzLnRvb2x0aXBzLCBmdW5jdGlvbiAoaWQsIHRvb2x0aXBEYXRhKSB7XFxuXFx0XFx0XFx0XFx0Ly8gRGVsZWdhdGUgdG8gY2xvc2UgbWV0aG9kIHRvIGhhbmRsZSBjb21tb24gY2xlYW51cFxcblxcdFxcdFxcdFxcdHZhciBldmVudCA9ICQuRXZlbnQoXFxcImJsdXJcXFwiKSxcXG5cXHRcXHRcXHRcXHQgICAgZWxlbWVudCA9IHRvb2x0aXBEYXRhLmVsZW1lbnQ7XFxuXFx0XFx0XFx0XFx0ZXZlbnQudGFyZ2V0ID0gZXZlbnQuY3VycmVudFRhcmdldCA9IGVsZW1lbnRbMF07XFxuXFx0XFx0XFx0XFx0dGhhdC5jbG9zZShldmVudCwgdHJ1ZSk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gUmVtb3ZlIGltbWVkaWF0ZWx5OyBkZXN0cm95aW5nIGFuIG9wZW4gdG9vbHRpcCBkb2Vzbid0IHVzZSB0aGVcXG5cXHRcXHRcXHRcXHQvLyBoaWRlIGFuaW1hdGlvblxcblxcdFxcdFxcdFxcdCQoXFxcIiNcXFwiICsgaWQpLnJlbW92ZSgpO1xcblxcblxcdFxcdFxcdFxcdC8vIFJlc3RvcmUgdGhlIHRpdGxlXFxuXFx0XFx0XFx0XFx0aWYgKGVsZW1lbnQuZGF0YShcXFwidWktdG9vbHRpcC10aXRsZVxcXCIpKSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gSWYgdGhlIHRpdGxlIGF0dHJpYnV0ZSBoYXMgY2hhbmdlZCBzaW5jZSBvcGVuKCksIGRvbid0IHJlc3RvcmVcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIWVsZW1lbnQuYXR0cihcXFwidGl0bGVcXFwiKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGVsZW1lbnQuYXR0cihcXFwidGl0bGVcXFwiLCBlbGVtZW50LmRhdGEoXFxcInVpLXRvb2x0aXAtdGl0bGVcXFwiKSk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGVsZW1lbnQucmVtb3ZlRGF0YShcXFwidWktdG9vbHRpcC10aXRsZVxcXCIpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHR0aGlzLmxpdmVSZWdpb24ucmVtb3ZlKCk7XFxuXFx0XFx0fVxcblxcdH0pO1xcbn0pO1wiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmF3LWxvYWRlciEuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliPz9yZWYtLTAtMCEuL2Fzc2V0cy9qcy9qcXVlcnkudWktMS4xMS40LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9yYXctbG9hZGVyL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMC0wIS4vYXNzZXRzL2pzL2pxdWVyeS51aS0xLjExLjQuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJtb2R1bGUuZXhwb3J0cyA9IFwiLyohXFxuICogalF1ZXJ5IFVwbG9hZCBGaWxlIFBsdWdpblxcbiAqIHZlcnNpb246IDQuMC4xMVxcbiAqIEByZXF1aXJlcyBqUXVlcnkgdjEuNSBvciBsYXRlciAmIGZvcm0gcGx1Z2luXFxuICogQ29weXJpZ2h0IChjKSAyMDEzIFJhdmlzaGFua2VyIEt1c3VtYVxcbiAqIGh0dHA6Ly9oYXlhZ2Vlay5jb20vXFxuICovXFxuKGZ1bmN0aW9uICgkKSB7XFxuICAgIGlmICgkLmZuLmFqYXhGb3JtID09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgJC5nZXRTY3JpcHQoKFxcXCJodHRwczpcXFwiID09IGRvY3VtZW50LmxvY2F0aW9uLnByb3RvY29sID8gXFxcImh0dHBzOi8vXFxcIiA6IFxcXCJodHRwOi8vXFxcIikgKyBcXFwibWFsc3VwLmdpdGh1Yi5pby9qcXVlcnkuZm9ybS5qc1xcXCIpO1xcbiAgICB9XFxuICAgIHZhciBmZWF0dXJlID0ge307XFxuICAgIGZlYXR1cmUuZmlsZWFwaSA9ICQoXFxcIjxpbnB1dCB0eXBlPSdmaWxlJy8+XFxcIikuZ2V0KDApLmZpbGVzICE9PSB1bmRlZmluZWQ7XFxuICAgIGZlYXR1cmUuZm9ybWRhdGEgPSB3aW5kb3cuRm9ybURhdGEgIT09IHVuZGVmaW5lZDtcXG4gICAgJC5mbi51cGxvYWRGaWxlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcXG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIGVhc2llc3Qgd2F5IHRvIGhhdmUgZGVmYXVsdCBvcHRpb25zLlxcbiAgICAgICAgdmFyIHMgPSAkLmV4dGVuZCh7XFxuICAgICAgICAgICAgLy8gVGhlc2UgYXJlIHRoZSBkZWZhdWx0cy5cXG4gICAgICAgICAgICB1cmw6IFxcXCJcXFwiLFxcbiAgICAgICAgICAgIG1ldGhvZDogXFxcIlBPU1RcXFwiLFxcbiAgICAgICAgICAgIGVuY3R5cGU6IFxcXCJtdWx0aXBhcnQvZm9ybS1kYXRhXFxcIixcXG4gICAgICAgICAgICByZXR1cm5UeXBlOiBudWxsLFxcbiAgICAgICAgICAgIGFsbG93RHVwbGljYXRlczogdHJ1ZSxcXG4gICAgICAgICAgICBkdXBsaWNhdGVTdHJpY3Q6IGZhbHNlLFxcbiAgICAgICAgICAgIGFsbG93ZWRUeXBlczogXFxcIipcXFwiLFxcbiAgICAgICAgICAgIC8vRm9yIGxpc3Qgb2YgYWNjZXB0RmlsZXNcXG4gICAgICAgICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzExODMyOTMwL2h0bWwtaW5wdXQtZmlsZS1hY2NlcHQtYXR0cmlidXRlLWZpbGUtdHlwZS1jc3ZcXG4gICAgICAgICAgICBhY2NlcHRGaWxlczogXFxcIipcXFwiLFxcbiAgICAgICAgICAgIGZpbGVOYW1lOiBcXFwiZmlsZVxcXCIsXFxuICAgICAgICAgICAgZm9ybURhdGE6IGZhbHNlLFxcbiAgICAgICAgICAgIGR5bmFtaWNGb3JtRGF0YTogZmFsc2UsXFxuICAgICAgICAgICAgbWF4RmlsZVNpemU6IC0xLFxcbiAgICAgICAgICAgIG1heEZpbGVDb3VudDogLTEsXFxuICAgICAgICAgICAgbXVsdGlwbGU6IHRydWUsXFxuICAgICAgICAgICAgZHJhZ0Ryb3A6IHRydWUsXFxuICAgICAgICAgICAgYXV0b1N1Ym1pdDogdHJ1ZSxcXG4gICAgICAgICAgICBzaG93Q2FuY2VsOiB0cnVlLFxcbiAgICAgICAgICAgIHNob3dBYm9ydDogdHJ1ZSxcXG4gICAgICAgICAgICBzaG93RG9uZTogZmFsc2UsXFxuICAgICAgICAgICAgc2hvd0RlbGV0ZTogZmFsc2UsXFxuICAgICAgICAgICAgc2hvd0Vycm9yOiB0cnVlLFxcbiAgICAgICAgICAgIHNob3dTdGF0dXNBZnRlclN1Y2Nlc3M6IHRydWUsXFxuICAgICAgICAgICAgc2hvd1N0YXR1c0FmdGVyRXJyb3I6IHRydWUsXFxuICAgICAgICAgICAgc2hvd0ZpbGVDb3VudGVyOiB0cnVlLFxcbiAgICAgICAgICAgIGZpbGVDb3VudGVyU3R5bGU6IFxcXCIpLiBcXFwiLFxcbiAgICAgICAgICAgIHNob3dGaWxlU2l6ZTogdHJ1ZSxcXG4gICAgICAgICAgICBzaG93UHJvZ3Jlc3M6IGZhbHNlLFxcbiAgICAgICAgICAgIG5lc3RlZEZvcm1zOiB0cnVlLFxcbiAgICAgICAgICAgIHNob3dEb3dubG9hZDogZmFsc2UsXFxuICAgICAgICAgICAgb25Mb2FkOiBmdW5jdGlvbiBvbkxvYWQob2JqKSB7fSxcXG4gICAgICAgICAgICBvblNlbGVjdDogZnVuY3Rpb24gb25TZWxlY3QoZmlsZXMpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICBvblN1Ym1pdDogZnVuY3Rpb24gb25TdWJtaXQoZmlsZXMsIHhocikge30sXFxuICAgICAgICAgICAgb25TdWNjZXNzOiBmdW5jdGlvbiBvblN1Y2Nlc3MoZmlsZXMsIHJlc3BvbnNlLCB4aHIsIHBkKSB7fSxcXG4gICAgICAgICAgICBvbkVycm9yOiBmdW5jdGlvbiBvbkVycm9yKGZpbGVzLCBzdGF0dXMsIG1lc3NhZ2UsIHBkKSB7fSxcXG4gICAgICAgICAgICBvbkNhbmNlbDogZnVuY3Rpb24gb25DYW5jZWwoZmlsZXMsIHBkKSB7fSxcXG4gICAgICAgICAgICBvbkFib3J0OiBmdW5jdGlvbiBvbkFib3J0KGZpbGVzLCBwZCkge30sXFxuICAgICAgICAgICAgZG93bmxvYWRDYWxsYmFjazogZmFsc2UsXFxuICAgICAgICAgICAgZGVsZXRlQ2FsbGJhY2s6IGZhbHNlLFxcbiAgICAgICAgICAgIGFmdGVyVXBsb2FkQWxsOiBmYWxzZSxcXG4gICAgICAgICAgICBzZXJpYWxpemU6IHRydWUsXFxuICAgICAgICAgICAgc2VxdWVudGlhbDogZmFsc2UsXFxuICAgICAgICAgICAgc2VxdWVudGlhbENvdW50OiAyLFxcbiAgICAgICAgICAgIGN1c3RvbVByb2dyZXNzQmFyOiBmYWxzZSxcXG4gICAgICAgICAgICBhYm9ydEJ1dHRvbkNsYXNzOiBcXFwiYWpheC1maWxlLXVwbG9hZC1hYm9ydFxcXCIsXFxuICAgICAgICAgICAgY2FuY2VsQnV0dG9uQ2xhc3M6IFxcXCJhamF4LWZpbGUtdXBsb2FkLWNhbmNlbFxcXCIsXFxuICAgICAgICAgICAgZHJhZ0Ryb3BDb250YWluZXJDbGFzczogXFxcImFqYXgtdXBsb2FkLWRyYWdkcm9wXFxcIixcXG4gICAgICAgICAgICBkcmFnRHJvcEhvdmVyQ2xhc3M6IFxcXCJzdGF0ZS1ob3ZlclxcXCIsXFxuICAgICAgICAgICAgZXJyb3JDbGFzczogXFxcImFqYXgtZmlsZS11cGxvYWQtZXJyb3JcXFwiLFxcbiAgICAgICAgICAgIHVwbG9hZEJ1dHRvbkNsYXNzOiBcXFwiYWpheC1maWxlLXVwbG9hZFxcXCIsXFxuICAgICAgICAgICAgZHJhZ0Ryb3BTdHI6IFxcXCI8c3Bhbj48Yj5EcmFnICZhbXA7IERyb3AgRmlsZXM8L2I+PC9zcGFuPlxcXCIsXFxuICAgICAgICAgICAgdXBsb2FkU3RyOiBcXFwiVXBsb2FkXFxcIixcXG4gICAgICAgICAgICBhYm9ydFN0cjogXFxcIkFib3J0XFxcIixcXG4gICAgICAgICAgICBjYW5jZWxTdHI6IFxcXCJDYW5jZWxcXFwiLFxcbiAgICAgICAgICAgIGRlbGV0ZVN0cjogXFxcIkRlbGV0ZVxcXCIsXFxuICAgICAgICAgICAgZG9uZVN0cjogXFxcIkRvbmVcXFwiLFxcbiAgICAgICAgICAgIG11bHRpRHJhZ0Vycm9yU3RyOiBcXFwiTXVsdGlwbGUgRmlsZSBEcmFnICZhbXA7IERyb3AgaXMgbm90IGFsbG93ZWQuXFxcIixcXG4gICAgICAgICAgICBleHRFcnJvclN0cjogXFxcImlzIG5vdCBhbGxvd2VkLiBBbGxvd2VkIGV4dGVuc2lvbnM6IFxcXCIsXFxuICAgICAgICAgICAgZHVwbGljYXRlRXJyb3JTdHI6IFxcXCJpcyBub3QgYWxsb3dlZC4gRmlsZSBhbHJlYWR5IGV4aXN0cy5cXFwiLFxcbiAgICAgICAgICAgIHNpemVFcnJvclN0cjogXFxcImlzIG5vdCBhbGxvd2VkLiBBbGxvd2VkIE1heCBzaXplOiBcXFwiLFxcbiAgICAgICAgICAgIHVwbG9hZEVycm9yU3RyOiBcXFwiVXBsb2FkIGlzIG5vdCBhbGxvd2VkXFxcIixcXG4gICAgICAgICAgICBtYXhGaWxlQ291bnRFcnJvclN0cjogXFxcIiBpcyBub3QgYWxsb3dlZC4gTWF4aW11bSBhbGxvd2VkIGZpbGVzIGFyZTpcXFwiLFxcbiAgICAgICAgICAgIGRvd25sb2FkU3RyOiBcXFwiRG93bmxvYWRcXFwiLFxcbiAgICAgICAgICAgIGN1c3RvbUVycm9yS2V5U3RyOiBcXFwianF1ZXJ5LXVwbG9hZC1maWxlLWVycm9yXFxcIixcXG4gICAgICAgICAgICBzaG93UXVldWVEaXY6IGZhbHNlLFxcbiAgICAgICAgICAgIHN0YXR1c0JhcldpZHRoOiA0MDAsXFxuICAgICAgICAgICAgZHJhZ2Ryb3BXaWR0aDogNDAwLFxcbiAgICAgICAgICAgIHNob3dQcmV2aWV3OiBmYWxzZSxcXG4gICAgICAgICAgICBwcmV2aWV3SGVpZ2h0OiBcXFwiYXV0b1xcXCIsXFxuICAgICAgICAgICAgcHJldmlld1dpZHRoOiBcXFwiMTAwJVxcXCIsXFxuICAgICAgICAgICAgZXh0cmFIVE1MOiBmYWxzZSxcXG4gICAgICAgICAgICB1cGxvYWRRdWV1ZU9yZGVyOiAndG9wJyxcXG4gICAgICAgICAgICBoZWFkZXJzOiB7fVxcbiAgICAgICAgfSwgb3B0aW9ucyk7XFxuXFxuICAgICAgICB0aGlzLmZpbGVDb3VudGVyID0gMTtcXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRGaWxlcyA9IDA7XFxuICAgICAgICB2YXIgZm9ybUdyb3VwID0gXFxcImFqYXgtZmlsZS11cGxvYWQtXFxcIiArIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xcbiAgICAgICAgdGhpcy5mb3JtR3JvdXAgPSBmb3JtR3JvdXA7XFxuICAgICAgICB0aGlzLmVycm9yTG9nID0gJChcXFwiPGRpdj48L2Rpdj5cXFwiKTsgLy9Xcml0aW5nIGVycm9yc1xcbiAgICAgICAgdGhpcy5yZXNwb25zZXMgPSBbXTtcXG4gICAgICAgIHRoaXMuZXhpc3RpbmdGaWxlTmFtZXMgPSBbXTtcXG4gICAgICAgIGlmICghZmVhdHVyZS5mb3JtZGF0YSkgLy9jaGVjayBkcmFnIGRyb3AgZW5hYmxlZC5cXG4gICAgICAgICAgICB7XFxuICAgICAgICAgICAgICAgIHMuZHJhZ0Ryb3AgPSBmYWxzZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICBpZiAoIWZlYXR1cmUuZm9ybWRhdGEgfHwgcy5tYXhGaWxlQ291bnQgPT09IDEpIHtcXG4gICAgICAgICAgICBzLm11bHRpcGxlID0gZmFsc2U7XFxuICAgICAgICB9XFxuXFxuICAgICAgICAkKHRoaXMpLmh0bWwoXFxcIlxcXCIpO1xcblxcbiAgICAgICAgdmFyIG9iaiA9IHRoaXM7XFxuXFxuICAgICAgICB2YXIgdXBsb2FkTGFiZWwgPSAkKCc8ZGl2PicgKyBzLnVwbG9hZFN0ciArICc8L2Rpdj4nKTtcXG5cXG4gICAgICAgICQodXBsb2FkTGFiZWwpLmFkZENsYXNzKHMudXBsb2FkQnV0dG9uQ2xhc3MpO1xcblxcbiAgICAgICAgLy8gd2FpdCBmb3JtIGFqYXggRm9ybSBwbHVnaW4gYW5kIGluaXRpYWxpemVcXG4gICAgICAgIChmdW5jdGlvbiBjaGVja0FqYXhGb3JtTG9hZGVkKCkge1xcbiAgICAgICAgICAgIGlmICgkLmZuLmFqYXhGb3JtKSB7XFxuXFxuICAgICAgICAgICAgICAgIGlmIChzLmRyYWdEcm9wKSB7XFxuICAgICAgICAgICAgICAgICAgICB2YXIgZHJhZ0Ryb3AgPSAkKCc8ZGl2IGNsYXNzPVxcXCInICsgcy5kcmFnRHJvcENvbnRhaW5lckNsYXNzICsgJ1xcXCIgc3R5bGU9XFxcInZlcnRpY2FsLWFsaWduOnRvcDtcXFwiPjwvZGl2PicpLndpZHRoKHMuZHJhZ2Ryb3BXaWR0aCk7XFxuICAgICAgICAgICAgICAgICAgICAkKG9iaikuYXBwZW5kKGRyYWdEcm9wKTtcXG4gICAgICAgICAgICAgICAgICAgICQoZHJhZ0Ryb3ApLmFwcGVuZCh1cGxvYWRMYWJlbCk7XFxuICAgICAgICAgICAgICAgICAgICAkKGRyYWdEcm9wKS5hcHBlbmQoJChzLmRyYWdEcm9wU3RyKSk7XFxuICAgICAgICAgICAgICAgICAgICBzZXREcmFnRHJvcEhhbmRsZXJzKG9iaiwgcywgZHJhZ0Ryb3ApO1xcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgJChvYmopLmFwcGVuZCh1cGxvYWRMYWJlbCk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgJChvYmopLmFwcGVuZChvYmouZXJyb3JMb2cpO1xcblxcbiAgICAgICAgICAgICAgICBpZiAocy5zaG93UXVldWVEaXYpIG9iai5jb250YWluZXIgPSAkKFxcXCIjXFxcIiArIHMuc2hvd1F1ZXVlRGl2KTtlbHNlIG9iai5jb250YWluZXIgPSAkKFxcXCI8ZGl2IGNsYXNzPSdhamF4LWZpbGUtdXBsb2FkLWNvbnRhaW5lcic+PC9kaXY+XFxcIikuaW5zZXJ0QWZ0ZXIoJChvYmopKTtcXG5cXG4gICAgICAgICAgICAgICAgcy5vbkxvYWQuY2FsbCh0aGlzLCBvYmopO1xcbiAgICAgICAgICAgICAgICBjcmVhdGVDdXN0b21JbnB1dEZpbGUob2JqLCBmb3JtR3JvdXAsIHMsIHVwbG9hZExhYmVsKTtcXG4gICAgICAgICAgICB9IGVsc2Ugd2luZG93LnNldFRpbWVvdXQoY2hlY2tBamF4Rm9ybUxvYWRlZCwgMTApO1xcbiAgICAgICAgfSkoKTtcXG5cXG4gICAgICAgIHRoaXMuc3RhcnRVcGxvYWQgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgJChcXFwiZm9ybVxcXCIpLmVhY2goZnVuY3Rpb24gKGksIGl0ZW1zKSB7XFxuICAgICAgICAgICAgICAgIGlmICgkKHRoaXMpLmhhc0NsYXNzKG9iai5mb3JtR3JvdXApKSB7XFxuICAgICAgICAgICAgICAgICAgICBtYWluUS5wdXNoKCQodGhpcykpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSk7XFxuXFxuICAgICAgICAgICAgaWYgKG1haW5RLmxlbmd0aCA+PSAxKSBzdWJtaXRQZW5kaW5nVXBsb2FkcygpO1xcbiAgICAgICAgfTtcXG5cXG4gICAgICAgIHRoaXMuZ2V0RmlsZUNvdW50ID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIHJldHVybiBvYmouc2VsZWN0ZWRGaWxlcztcXG4gICAgICAgIH07XFxuICAgICAgICB0aGlzLnN0b3BVcGxvYWQgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgJChcXFwiLlxcXCIgKyBzLmFib3J0QnV0dG9uQ2xhc3MpLmVhY2goZnVuY3Rpb24gKGksIGl0ZW1zKSB7XFxuICAgICAgICAgICAgICAgIGlmICgkKHRoaXMpLmhhc0NsYXNzKG9iai5mb3JtR3JvdXApKSAkKHRoaXMpLmNsaWNrKCk7XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgJChcXFwiLlxcXCIgKyBzLmNhbmNlbEJ1dHRvbkNsYXNzKS5lYWNoKGZ1bmN0aW9uIChpLCBpdGVtcykge1xcbiAgICAgICAgICAgICAgICBpZiAoJCh0aGlzKS5oYXNDbGFzcyhvYmouZm9ybUdyb3VwKSkgJCh0aGlzKS5jbGljaygpO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgfTtcXG4gICAgICAgIHRoaXMuY2FuY2VsQWxsID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICQoXFxcIi5cXFwiICsgcy5jYW5jZWxCdXR0b25DbGFzcykuZWFjaChmdW5jdGlvbiAoaSwgaXRlbXMpIHtcXG4gICAgICAgICAgICAgICAgaWYgKCQodGhpcykuaGFzQ2xhc3Mob2JqLmZvcm1Hcm91cCkpICQodGhpcykuY2xpY2soKTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH07XFxuICAgICAgICB0aGlzLnVwZGF0ZSA9IGZ1bmN0aW9uIChzZXR0aW5ncykge1xcbiAgICAgICAgICAgIC8vdXBkYXRlIG5ldyBzZXR0aW5nc1xcbiAgICAgICAgICAgIHMgPSAkLmV4dGVuZChzLCBzZXR0aW5ncyk7XFxuXFxuICAgICAgICAgICAgLy9XZSBuZWVkIHRvIHVwZGF0ZSBhY3Rpb24gZm9yIGFscmVhZHkgY3JlYXRlZCBGb3JtLiAgICAgICAgICAgIFxcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5oYXNPd25Qcm9wZXJ0eSgndXJsJykpIHtcXG4gICAgICAgICAgICAgICAgJChcXFwiZm9ybVxcXCIpLmVhY2goZnVuY3Rpb24gKGksIGl0ZW1zKSB7XFxuICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLmF0dHIoJ2FjdGlvbicsIHNldHRpbmdzWyd1cmwnXSk7XFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH07XFxuXFxuICAgICAgICB0aGlzLmVucXVldWVGaWxlID0gZnVuY3Rpb24gKGZpbGUpIHtcXG4gICAgICAgICAgICBpZiAoIShmaWxlIGluc3RhbmNlb2YgRmlsZSkpIHJldHVybjtcXG4gICAgICAgICAgICB2YXIgZmlsZXMgPSBbZmlsZV07XFxuICAgICAgICAgICAgc2VyaWFsaXplQW5kVXBsb2FkRmlsZXMocywgb2JqLCBmaWxlcyk7XFxuICAgICAgICB9O1xcblxcbiAgICAgICAgdGhpcy5yZXNldCA9IGZ1bmN0aW9uIChyZW1vdmVTdGF0dXNCYXJzKSB7XFxuICAgICAgICAgICAgb2JqLmZpbGVDb3VudGVyID0gMTtcXG4gICAgICAgICAgICBvYmouc2VsZWN0ZWRGaWxlcyA9IDA7XFxuICAgICAgICAgICAgb2JqLmVycm9yTG9nLmh0bWwoXFxcIlxcXCIpO1xcbiAgICAgICAgICAgIC8vcmVtb3ZlIGFsbCB0aGUgc3RhdHVzIGJhcnMuXFxuICAgICAgICAgICAgaWYgKHJlbW92ZVN0YXR1c0JhcnMgIT0gZmFsc2UpIHtcXG4gICAgICAgICAgICAgICAgb2JqLmNvbnRhaW5lci5odG1sKFxcXCJcXFwiKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9O1xcbiAgICAgICAgdGhpcy5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgb2JqLmNvbnRhaW5lci5odG1sKFxcXCJcXFwiKTtcXG4gICAgICAgICAgICAkKG9iaikucmVtb3ZlKCk7XFxuICAgICAgICB9O1xcbiAgICAgICAgLy9UaGlzIGlzIGZvciBzaG93aW5nIE9sZCBmaWxlcyB0byB1c2VyLlxcbiAgICAgICAgdGhpcy5jcmVhdGVQcm9ncmVzcyA9IGZ1bmN0aW9uIChmaWxlbmFtZSwgZmlsZXBhdGgsIGZpbGVzaXplKSB7XFxuICAgICAgICAgICAgdmFyIHBkID0gbmV3IGNyZWF0ZVByb2dyZXNzRGl2KHRoaXMsIHMpO1xcbiAgICAgICAgICAgIHBkLnByb2dyZXNzRGl2LnNob3coKTtcXG4gICAgICAgICAgICBwZC5wcm9ncmVzc2Jhci53aWR0aCgnMTAwJScpO1xcblxcbiAgICAgICAgICAgIHZhciBmaWxlTmFtZVN0ciA9IFxcXCJcXFwiO1xcbiAgICAgICAgICAgIGlmIChzLnNob3dGaWxlQ291bnRlcikgZmlsZU5hbWVTdHIgPSBvYmouZmlsZUNvdW50ZXIgKyBzLmZpbGVDb3VudGVyU3R5bGUgKyBmaWxlbmFtZTtlbHNlIGZpbGVOYW1lU3RyID0gZmlsZW5hbWU7XFxuXFxuICAgICAgICAgICAgaWYgKHMuc2hvd0ZpbGVTaXplKSBmaWxlTmFtZVN0ciArPSBcXFwiIChcXFwiICsgZ2V0U2l6ZVN0cihmaWxlc2l6ZSkgKyBcXFwiKVxcXCI7XFxuXFxuICAgICAgICAgICAgcGQuZmlsZW5hbWUuaHRtbChmaWxlTmFtZVN0cik7XFxuICAgICAgICAgICAgb2JqLmZpbGVDb3VudGVyKys7XFxuICAgICAgICAgICAgb2JqLnNlbGVjdGVkRmlsZXMrKztcXG4gICAgICAgICAgICBpZiAocy5zaG93UHJldmlldykge1xcbiAgICAgICAgICAgICAgICBwZC5wcmV2aWV3LmF0dHIoJ3NyYycsIGZpbGVwYXRoKTtcXG4gICAgICAgICAgICAgICAgcGQucHJldmlldy5zaG93KCk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmIChzLnNob3dEb3dubG9hZCkge1xcbiAgICAgICAgICAgICAgICBwZC5kb3dubG9hZC5zaG93KCk7XFxuICAgICAgICAgICAgICAgIHBkLmRvd25sb2FkLmNsaWNrKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChzLmRvd25sb2FkQ2FsbGJhY2spIHMuZG93bmxvYWRDYWxsYmFjay5jYWxsKG9iaiwgW2ZpbGVuYW1lXSwgcGQpO1xcbiAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYgKHMuc2hvd0RlbGV0ZSkge1xcbiAgICAgICAgICAgICAgICBwZC5kZWwuc2hvdygpO1xcbiAgICAgICAgICAgICAgICBwZC5kZWwuY2xpY2soZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICAgICAgcGQuc3RhdHVzYmFyLmhpZGUoKS5yZW1vdmUoKTtcXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcnIgPSBbZmlsZW5hbWVdO1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKHMuZGVsZXRlQ2FsbGJhY2spIHMuZGVsZXRlQ2FsbGJhY2suY2FsbCh0aGlzLCBhcnIsIHBkKTtcXG4gICAgICAgICAgICAgICAgICAgIG9iai5zZWxlY3RlZEZpbGVzIC09IDE7XFxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVGaWxlQ291bnRlcihzLCBvYmopO1xcbiAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgcmV0dXJuIHBkO1xcbiAgICAgICAgfTtcXG5cXG4gICAgICAgIHRoaXMuZ2V0UmVzcG9uc2VzID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3BvbnNlcztcXG4gICAgICAgIH07XFxuICAgICAgICB2YXIgbWFpblEgPSBbXTtcXG4gICAgICAgIHZhciBwcm9ncmVzc1EgPSBbXTtcXG4gICAgICAgIHZhciBydW5uaW5nID0gZmFsc2U7XFxuICAgICAgICBmdW5jdGlvbiBzdWJtaXRQZW5kaW5nVXBsb2FkcygpIHtcXG4gICAgICAgICAgICBpZiAocnVubmluZykgcmV0dXJuO1xcbiAgICAgICAgICAgIHJ1bm5pbmcgPSB0cnVlO1xcbiAgICAgICAgICAgIChmdW5jdGlvbiBjaGVja1BlbmRpbmdGb3JtcygpIHtcXG5cXG4gICAgICAgICAgICAgICAgLy9pZiBub3Qgc2VxdWVudGlhbCB1cGxvYWQgYWxsIGZpbGVzXFxuICAgICAgICAgICAgICAgIGlmICghcy5zZXF1ZW50aWFsKSBzLnNlcXVlbnRpYWxDb3VudCA9IDk5OTk5O1xcblxcbiAgICAgICAgICAgICAgICBpZiAobWFpblEubGVuZ3RoID09IDAgJiYgcHJvZ3Jlc3NRLmxlbmd0aCA9PSAwKSB7XFxuICAgICAgICAgICAgICAgICAgICBpZiAocy5hZnRlclVwbG9hZEFsbCkgcy5hZnRlclVwbG9hZEFsbChvYmopO1xcbiAgICAgICAgICAgICAgICAgICAgcnVubmluZyA9IGZhbHNlO1xcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb2dyZXNzUS5sZW5ndGggPCBzLnNlcXVlbnRpYWxDb3VudCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcm0gPSBtYWluUS5zaGlmdCgpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcm0gIT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzUS5wdXNoKGZybSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vUmVtb3ZlIHRoZSBjbGFzcyBncm91cC5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJtLnJlbW92ZUNsYXNzKG9iai5mb3JtR3JvdXApO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm0uc3VibWl0KCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoY2hlY2tQZW5kaW5nRm9ybXMsIDEwMCk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KSgpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZnVuY3Rpb24gc2V0RHJhZ0Ryb3BIYW5kbGVycyhvYmosIHMsIGRkT2JqKSB7XFxuICAgICAgICAgICAgZGRPYmoub24oJ2RyYWdlbnRlcicsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XFxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgICAgICAgICAgJCh0aGlzKS5hZGRDbGFzcyhzLmRyYWdEcm9wSG92ZXJDbGFzcyk7XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgZGRPYmoub24oJ2RyYWdvdmVyJywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgICAgICAgICB2YXIgdGhhdCA9ICQodGhpcyk7XFxuICAgICAgICAgICAgICAgIGlmICh0aGF0Lmhhc0NsYXNzKHMuZHJhZ0Ryb3BDb250YWluZXJDbGFzcykgJiYgIXRoYXQuaGFzQ2xhc3Mocy5kcmFnRHJvcEhvdmVyQ2xhc3MpKSB7XFxuICAgICAgICAgICAgICAgICAgICB0aGF0LmFkZENsYXNzKHMuZHJhZ0Ryb3BIb3ZlckNsYXNzKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIGRkT2JqLm9uKCdkcm9wJywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgICAgICAgICAkKHRoaXMpLnJlbW92ZUNsYXNzKHMuZHJhZ0Ryb3BIb3ZlckNsYXNzKTtcXG4gICAgICAgICAgICAgICAgb2JqLmVycm9yTG9nLmh0bWwoXFxcIlxcXCIpO1xcbiAgICAgICAgICAgICAgICB2YXIgZmlsZXMgPSBlLm9yaWdpbmFsRXZlbnQuZGF0YVRyYW5zZmVyLmZpbGVzO1xcbiAgICAgICAgICAgICAgICBpZiAoIXMubXVsdGlwbGUgJiYgZmlsZXMubGVuZ3RoID4gMSkge1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKHMuc2hvd0Vycm9yKSAkKFxcXCI8ZGl2IGNsYXNzPSdcXFwiICsgcy5lcnJvckNsYXNzICsgXFxcIic+XFxcIiArIHMubXVsdGlEcmFnRXJyb3JTdHIgKyBcXFwiPC9kaXY+XFxcIikuYXBwZW5kVG8ob2JqLmVycm9yTG9nKTtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBpZiAocy5vblNlbGVjdChmaWxlcykgPT0gZmFsc2UpIHJldHVybjtcXG4gICAgICAgICAgICAgICAgc2VyaWFsaXplQW5kVXBsb2FkRmlsZXMocywgb2JqLCBmaWxlcyk7XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgZGRPYmoub24oJ2RyYWdsZWF2ZScsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICAgICAgICAgICQodGhpcykucmVtb3ZlQ2xhc3Mocy5kcmFnRHJvcEhvdmVyQ2xhc3MpO1xcbiAgICAgICAgICAgIH0pO1xcblxcbiAgICAgICAgICAgICQoZG9jdW1lbnQpLm9uKCdkcmFnZW50ZXInLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgJChkb2N1bWVudCkub24oJ2RyYWdvdmVyJywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgICAgICAgICB2YXIgdGhhdCA9ICQodGhpcyk7XFxuICAgICAgICAgICAgICAgIGlmICghdGhhdC5oYXNDbGFzcyhzLmRyYWdEcm9wQ29udGFpbmVyQ2xhc3MpKSB7XFxuICAgICAgICAgICAgICAgICAgICB0aGF0LnJlbW92ZUNsYXNzKHMuZHJhZ0Ryb3BIb3ZlckNsYXNzKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICQoZG9jdW1lbnQpLm9uKCdkcm9wJywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgICAgICAgICAkKHRoaXMpLnJlbW92ZUNsYXNzKHMuZHJhZ0Ryb3BIb3ZlckNsYXNzKTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGZ1bmN0aW9uIGdldFNpemVTdHIoc2l6ZSkge1xcbiAgICAgICAgICAgIHZhciBzaXplU3RyID0gXFxcIlxcXCI7XFxuICAgICAgICAgICAgdmFyIHNpemVLQiA9IHNpemUgLyAxMDI0O1xcbiAgICAgICAgICAgIGlmIChwYXJzZUludChzaXplS0IpID4gMTAyNCkge1xcbiAgICAgICAgICAgICAgICB2YXIgc2l6ZU1CID0gc2l6ZUtCIC8gMTAyNDtcXG4gICAgICAgICAgICAgICAgc2l6ZVN0ciA9IHNpemVNQi50b0ZpeGVkKDIpICsgXFxcIiBNQlxcXCI7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgc2l6ZVN0ciA9IHNpemVLQi50b0ZpeGVkKDIpICsgXFxcIiBLQlxcXCI7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHJldHVybiBzaXplU3RyO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZnVuY3Rpb24gc2VyaWFsaXplRGF0YShleHRyYURhdGEpIHtcXG4gICAgICAgICAgICB2YXIgc2VyaWFsaXplZCA9IFtdO1xcbiAgICAgICAgICAgIGlmIChqUXVlcnkudHlwZShleHRyYURhdGEpID09IFxcXCJzdHJpbmdcXFwiKSB7XFxuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWQgPSBleHRyYURhdGEuc3BsaXQoJyYnKTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkID0gJC5wYXJhbShleHRyYURhdGEpLnNwbGl0KCcmJyk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHZhciBsZW4gPSBzZXJpYWxpemVkLmxlbmd0aDtcXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XFxuICAgICAgICAgICAgdmFyIGksIHBhcnQ7XFxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XFxuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWRbaV0gPSBzZXJpYWxpemVkW2ldLnJlcGxhY2UoL1xcXFwrL2csICcgJyk7XFxuICAgICAgICAgICAgICAgIHBhcnQgPSBzZXJpYWxpemVkW2ldLnNwbGl0KCc9Jyk7XFxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFtkZWNvZGVVUklDb21wb25lbnQocGFydFswXSksIGRlY29kZVVSSUNvbXBvbmVudChwYXJ0WzFdKV0pO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICAgICAgfVxcbiAgICAgICAgZnVuY3Rpb24gbm9zZXJpYWxpemVBbmRVcGxvYWRGaWxlcyhzLCBvYmosIGZpbGVzKSB7XFxuICAgICAgICAgICAgdmFyIHRzID0gJC5leHRlbmQoe30sIHMpO1xcbiAgICAgICAgICAgIHZhciBmZCA9IG5ldyBGb3JtRGF0YSgpO1xcbiAgICAgICAgICAgIHZhciBmaWxlQXJyYXkgPSBbXTtcXG4gICAgICAgICAgICB2YXIgZmlsZU5hbWUgPSBzLmZpbGVOYW1lLnJlcGxhY2UoXFxcIltdXFxcIiwgXFxcIlxcXCIpO1xcbiAgICAgICAgICAgIHZhciBmaWxlTGlzdFN0ciA9IFxcXCJcXFwiO1xcblxcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgICAgICAgaWYgKCFpc0ZpbGVUeXBlQWxsb3dlZChvYmosIHMsIGZpbGVzW2ldLm5hbWUpKSB7XFxuICAgICAgICAgICAgICAgICAgICBpZiAocy5zaG93RXJyb3IpICQoXFxcIjxkaXY+PGZvbnQgY29sb3I9J3JlZCc+PGI+XFxcIiArIGZpbGVzW2ldLm5hbWUgKyBcXFwiPC9iPiBcXFwiICsgcy5leHRFcnJvclN0ciArIHMuYWxsb3dlZFR5cGVzICsgXFxcIjwvZm9udD48L2Rpdj5cXFwiKS5hcHBlbmRUbyhvYmouZXJyb3JMb2cpO1xcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgaWYgKHMubWF4RmlsZVNpemUgIT0gLTEgJiYgZmlsZXNbaV0uc2l6ZSA+IHMubWF4RmlsZVNpemUpIHtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChzLnNob3dFcnJvcikgJChcXFwiPGRpdj48Zm9udCBjb2xvcj0ncmVkJz48Yj5cXFwiICsgZmlsZXNbaV0ubmFtZSArIFxcXCI8L2I+IFxcXCIgKyBzLnNpemVFcnJvclN0ciArIGdldFNpemVTdHIocy5tYXhGaWxlU2l6ZSkgKyBcXFwiPC9mb250PjwvZGl2PlxcXCIpLmFwcGVuZFRvKG9iai5lcnJvckxvZyk7XFxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBmZC5hcHBlbmQoZmlsZU5hbWUgKyBcXFwiW11cXFwiLCBmaWxlc1tpXSk7XFxuICAgICAgICAgICAgICAgIGZpbGVBcnJheS5wdXNoKGZpbGVzW2ldLm5hbWUpO1xcbiAgICAgICAgICAgICAgICBmaWxlTGlzdFN0ciArPSBvYmouZmlsZUNvdW50ZXIgKyBcXFwiKS4gXFxcIiArIGZpbGVzW2ldLm5hbWUgKyBcXFwiPGJyPlxcXCI7XFxuICAgICAgICAgICAgICAgIG9iai5maWxlQ291bnRlcisrO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZiAoZmlsZUFycmF5Lmxlbmd0aCA9PSAwKSByZXR1cm47XFxuXFxuICAgICAgICAgICAgdmFyIGV4dHJhRGF0YSA9IHMuZm9ybURhdGE7XFxuICAgICAgICAgICAgaWYgKGV4dHJhRGF0YSkge1xcbiAgICAgICAgICAgICAgICB2YXIgc0RhdGEgPSBzZXJpYWxpemVEYXRhKGV4dHJhRGF0YSk7XFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc0RhdGEubGVuZ3RoOyBqKyspIHtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChzRGF0YVtqXSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGZkLmFwcGVuZChzRGF0YVtqXVswXSwgc0RhdGFbal1bMV0pO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIHRzLmZpbGVEYXRhID0gZmQ7XFxuICAgICAgICAgICAgdmFyIHBkID0gbmV3IGNyZWF0ZVByb2dyZXNzRGl2KG9iaiwgcyk7XFxuICAgICAgICAgICAgcGQuZmlsZW5hbWUuaHRtbChmaWxlTGlzdFN0cik7XFxuICAgICAgICAgICAgdmFyIGZvcm0gPSAkKFxcXCI8Zm9ybSBzdHlsZT0nZGlzcGxheTpibG9jazsgcG9zaXRpb246YWJzb2x1dGU7bGVmdDogMTUwcHg7JyBjbGFzcz0nXFxcIiArIG9iai5mb3JtR3JvdXAgKyBcXFwiJyBtZXRob2Q9J1xcXCIgKyBzLm1ldGhvZCArIFxcXCInIGFjdGlvbj0nXFxcIiArIHMudXJsICsgXFxcIicgZW5jdHlwZT0nXFxcIiArIHMuZW5jdHlwZSArIFxcXCInPjwvZm9ybT5cXFwiKTtcXG4gICAgICAgICAgICBmb3JtLmFwcGVuZFRvKCdib2R5Jyk7XFxuICAgICAgICAgICAgYWpheEZvcm1TdWJtaXQoZm9ybSwgdHMsIHBkLCBmaWxlQXJyYXksIG9iaik7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBmdW5jdGlvbiBzZXJpYWxpemVBbmRVcGxvYWRGaWxlcyhzLCBvYmosIGZpbGVzKSB7XFxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgICAgICAgICBpZiAoIWlzRmlsZVR5cGVBbGxvd2VkKG9iaiwgcywgZmlsZXNbaV0ubmFtZSkpIHtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChzLnNob3dFcnJvcikgJChcXFwiPGRpdiBjbGFzcz0nXFxcIiArIHMuZXJyb3JDbGFzcyArIFxcXCInPjxiPlxcXCIgKyBmaWxlc1tpXS5uYW1lICsgXFxcIjwvYj4gXFxcIiArIHMuZXh0RXJyb3JTdHIgKyBzLmFsbG93ZWRUeXBlcyArIFxcXCI8L2Rpdj5cXFwiKS5hcHBlbmRUbyhvYmouZXJyb3JMb2cpO1xcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgaWYgKCFzLmFsbG93RHVwbGljYXRlcyAmJiBpc0ZpbGVEdXBsaWNhdGUob2JqLCBmaWxlc1tpXS5uYW1lKSkge1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKHMuc2hvd0Vycm9yKSAkKFxcXCI8ZGl2IGNsYXNzPSdcXFwiICsgcy5lcnJvckNsYXNzICsgXFxcIic+PGI+XFxcIiArIGZpbGVzW2ldLm5hbWUgKyBcXFwiPC9iPiBcXFwiICsgcy5kdXBsaWNhdGVFcnJvclN0ciArIFxcXCI8L2Rpdj5cXFwiKS5hcHBlbmRUbyhvYmouZXJyb3JMb2cpO1xcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgaWYgKHMubWF4RmlsZVNpemUgIT0gLTEgJiYgZmlsZXNbaV0uc2l6ZSA+IHMubWF4RmlsZVNpemUpIHtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChzLnNob3dFcnJvcikgJChcXFwiPGRpdiBjbGFzcz0nXFxcIiArIHMuZXJyb3JDbGFzcyArIFxcXCInPjxiPlxcXCIgKyBmaWxlc1tpXS5uYW1lICsgXFxcIjwvYj4gXFxcIiArIHMuc2l6ZUVycm9yU3RyICsgZ2V0U2l6ZVN0cihzLm1heEZpbGVTaXplKSArIFxcXCI8L2Rpdj5cXFwiKS5hcHBlbmRUbyhvYmouZXJyb3JMb2cpO1xcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgaWYgKHMubWF4RmlsZUNvdW50ICE9IC0xICYmIG9iai5zZWxlY3RlZEZpbGVzID49IHMubWF4RmlsZUNvdW50KSB7XFxuICAgICAgICAgICAgICAgICAgICBpZiAocy5zaG93RXJyb3IpICQoXFxcIjxkaXYgY2xhc3M9J1xcXCIgKyBzLmVycm9yQ2xhc3MgKyBcXFwiJz48Yj5cXFwiICsgZmlsZXNbaV0ubmFtZSArIFxcXCI8L2I+IFxcXCIgKyBzLm1heEZpbGVDb3VudEVycm9yU3RyICsgcy5tYXhGaWxlQ291bnQgKyBcXFwiPC9kaXY+XFxcIikuYXBwZW5kVG8ob2JqLmVycm9yTG9nKTtcXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIG9iai5zZWxlY3RlZEZpbGVzKys7XFxuICAgICAgICAgICAgICAgIG9iai5leGlzdGluZ0ZpbGVOYW1lcy5wdXNoKGZpbGVzW2ldLm5hbWUpO1xcbiAgICAgICAgICAgICAgICAvLyBNYWtlIG9iamVjdCBpbW11dGFibGVcXG4gICAgICAgICAgICAgICAgdmFyIHRzID0gJC5leHRlbmQoe30sIHMpO1xcbiAgICAgICAgICAgICAgICB2YXIgZmQgPSBuZXcgRm9ybURhdGEoKTtcXG4gICAgICAgICAgICAgICAgdmFyIGZpbGVOYW1lID0gcy5maWxlTmFtZS5yZXBsYWNlKFxcXCJbXVxcXCIsIFxcXCJcXFwiKTtcXG4gICAgICAgICAgICAgICAgZmQuYXBwZW5kKGZpbGVOYW1lLCBmaWxlc1tpXSk7XFxuICAgICAgICAgICAgICAgIHZhciBleHRyYURhdGEgPSBzLmZvcm1EYXRhO1xcbiAgICAgICAgICAgICAgICBpZiAoZXh0cmFEYXRhKSB7XFxuICAgICAgICAgICAgICAgICAgICB2YXIgc0RhdGEgPSBzZXJpYWxpemVEYXRhKGV4dHJhRGF0YSk7XFxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNEYXRhLmxlbmd0aDsgaisrKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNEYXRhW2pdKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZkLmFwcGVuZChzRGF0YVtqXVswXSwgc0RhdGFbal1bMV0pO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB0cy5maWxlRGF0YSA9IGZkO1xcblxcbiAgICAgICAgICAgICAgICB2YXIgcGQgPSBuZXcgY3JlYXRlUHJvZ3Jlc3NEaXYob2JqLCBzKTtcXG4gICAgICAgICAgICAgICAgdmFyIGZpbGVOYW1lU3RyID0gXFxcIlxcXCI7XFxuICAgICAgICAgICAgICAgIGlmIChzLnNob3dGaWxlQ291bnRlcikgZmlsZU5hbWVTdHIgPSBvYmouZmlsZUNvdW50ZXIgKyBzLmZpbGVDb3VudGVyU3R5bGUgKyBmaWxlc1tpXS5uYW1lO2Vsc2UgZmlsZU5hbWVTdHIgPSBmaWxlc1tpXS5uYW1lO1xcblxcbiAgICAgICAgICAgICAgICBpZiAocy5zaG93RmlsZVNpemUpIGZpbGVOYW1lU3RyICs9IFxcXCIgKFxcXCIgKyBnZXRTaXplU3RyKGZpbGVzW2ldLnNpemUpICsgXFxcIilcXFwiO1xcblxcbiAgICAgICAgICAgICAgICBwZC5maWxlbmFtZS5odG1sKGZpbGVOYW1lU3RyKTtcXG4gICAgICAgICAgICAgICAgdmFyIGZvcm0gPSAkKFxcXCI8Zm9ybSBzdHlsZT0nZGlzcGxheTpibG9jazsgcG9zaXRpb246YWJzb2x1dGU7bGVmdDogMTUwcHg7JyBjbGFzcz0nXFxcIiArIG9iai5mb3JtR3JvdXAgKyBcXFwiJyBtZXRob2Q9J1xcXCIgKyBzLm1ldGhvZCArIFxcXCInIGFjdGlvbj0nXFxcIiArIHMudXJsICsgXFxcIicgZW5jdHlwZT0nXFxcIiArIHMuZW5jdHlwZSArIFxcXCInPjwvZm9ybT5cXFwiKTtcXG4gICAgICAgICAgICAgICAgZm9ybS5hcHBlbmRUbygnYm9keScpO1xcbiAgICAgICAgICAgICAgICB2YXIgZmlsZUFycmF5ID0gW107XFxuICAgICAgICAgICAgICAgIGZpbGVBcnJheS5wdXNoKGZpbGVzW2ldLm5hbWUpO1xcblxcbiAgICAgICAgICAgICAgICBhamF4Rm9ybVN1Ym1pdChmb3JtLCB0cywgcGQsIGZpbGVBcnJheSwgb2JqLCBmaWxlc1tpXSk7XFxuICAgICAgICAgICAgICAgIG9iai5maWxlQ291bnRlcisrO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGZ1bmN0aW9uIGlzRmlsZVR5cGVBbGxvd2VkKG9iaiwgcywgZmlsZU5hbWUpIHtcXG4gICAgICAgICAgICB2YXIgZmlsZUV4dGVuc2lvbnMgPSBzLmFsbG93ZWRUeXBlcy50b0xvd2VyQ2FzZSgpLnNwbGl0KC9bXFxcXHMsXSsvZyk7XFxuICAgICAgICAgICAgdmFyIGV4dCA9IGZpbGVOYW1lLnNwbGl0KCcuJykucG9wKCkudG9Mb3dlckNhc2UoKTtcXG4gICAgICAgICAgICBpZiAocy5hbGxvd2VkVHlwZXMgIT0gXFxcIipcXFwiICYmIGpRdWVyeS5pbkFycmF5KGV4dCwgZmlsZUV4dGVuc2lvbnMpIDwgMCkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZnVuY3Rpb24gaXNGaWxlRHVwbGljYXRlKG9iaiwgZmlsZW5hbWUpIHtcXG4gICAgICAgICAgICB2YXIgZHVwbGljYXRlID0gZmFsc2U7XFxuICAgICAgICAgICAgaWYgKG9iai5leGlzdGluZ0ZpbGVOYW1lcy5sZW5ndGgpIHtcXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBvYmouZXhpc3RpbmdGaWxlTmFtZXMubGVuZ3RoOyB4KyspIHtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmouZXhpc3RpbmdGaWxlTmFtZXNbeF0gPT0gZmlsZW5hbWUgfHwgcy5kdXBsaWNhdGVTdHJpY3QgJiYgb2JqLmV4aXN0aW5nRmlsZU5hbWVzW3hdLnRvTG93ZXJDYXNlKCkgPT0gZmlsZW5hbWUudG9Mb3dlckNhc2UoKSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGR1cGxpY2F0ZSA9IHRydWU7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgcmV0dXJuIGR1cGxpY2F0ZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGZ1bmN0aW9uIHJlbW92ZUV4aXN0aW5nRmlsZU5hbWUob2JqLCBmaWxlQXJyKSB7XFxuICAgICAgICAgICAgaWYgKG9iai5leGlzdGluZ0ZpbGVOYW1lcy5sZW5ndGgpIHtcXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBmaWxlQXJyLmxlbmd0aDsgeCsrKSB7XFxuICAgICAgICAgICAgICAgICAgICB2YXIgcG9zID0gb2JqLmV4aXN0aW5nRmlsZU5hbWVzLmluZGV4T2YoZmlsZUFyclt4XSk7XFxuICAgICAgICAgICAgICAgICAgICBpZiAocG9zICE9IC0xKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqLmV4aXN0aW5nRmlsZU5hbWVzLnNwbGljZShwb3MsIDEpO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgZnVuY3Rpb24gZ2V0U3JjVG9QcmV2aWV3KGZpbGUsIG9iaikge1xcbiAgICAgICAgICAgIGlmIChmaWxlKSB7XFxuICAgICAgICAgICAgICAgIG9iai5zaG93KCk7XFxuICAgICAgICAgICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xcbiAgICAgICAgICAgICAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgICAgICAgICAgIG9iai5hdHRyKCdzcmMnLCBlLnRhcmdldC5yZXN1bHQpO1xcbiAgICAgICAgICAgICAgICB9O1xcbiAgICAgICAgICAgICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChmaWxlKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICBmdW5jdGlvbiB1cGRhdGVGaWxlQ291bnRlcihzLCBvYmopIHtcXG4gICAgICAgICAgICBpZiAocy5zaG93RmlsZUNvdW50ZXIpIHtcXG4gICAgICAgICAgICAgICAgdmFyIGNvdW50ID0gJChvYmouY29udGFpbmVyKS5maW5kKFxcXCIuYWpheC1maWxlLXVwbG9hZC1maWxlbmFtZVxcXCIpLmxlbmd0aDtcXG4gICAgICAgICAgICAgICAgb2JqLmZpbGVDb3VudGVyID0gY291bnQgKyAxO1xcbiAgICAgICAgICAgICAgICAkKG9iai5jb250YWluZXIpLmZpbmQoXFxcIi5hamF4LWZpbGUtdXBsb2FkLWZpbGVuYW1lXFxcIikuZWFjaChmdW5jdGlvbiAoaSwgaXRlbXMpIHtcXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcnIgPSAkKHRoaXMpLmh0bWwoKS5zcGxpdChzLmZpbGVDb3VudGVyU3R5bGUpO1xcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpbGVOdW0gPSBwYXJzZUludChhcnJbMF0pIC0gMTsgLy9kZWNyZW1lbnQ7XFxuICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IGNvdW50ICsgcy5maWxlQ291bnRlclN0eWxlICsgYXJyWzFdO1xcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5odG1sKG5hbWUpO1xcbiAgICAgICAgICAgICAgICAgICAgY291bnQtLTtcXG4gICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlQ3VzdG9tSW5wdXRGaWxlKG9iaiwgZ3JvdXAsIHMsIHVwbG9hZExhYmVsKSB7XFxuXFxuICAgICAgICAgICAgdmFyIGZpbGVVcGxvYWRJZCA9IFxcXCJhamF4LXVwbG9hZC1pZC1cXFwiICsgbmV3IERhdGUoKS5nZXRUaW1lKCk7XFxuXFxuICAgICAgICAgICAgdmFyIGZvcm0gPSAkKFxcXCI8Zm9ybSBtZXRob2Q9J1xcXCIgKyBzLm1ldGhvZCArIFxcXCInIGFjdGlvbj0nXFxcIiArIHMudXJsICsgXFxcIicgZW5jdHlwZT0nXFxcIiArIHMuZW5jdHlwZSArIFxcXCInPjwvZm9ybT5cXFwiKTtcXG4gICAgICAgICAgICB2YXIgZmlsZUlucHV0U3RyID0gXFxcIjxpbnB1dCB0eXBlPSdmaWxlJyBpZD0nXFxcIiArIGZpbGVVcGxvYWRJZCArIFxcXCInIG5hbWU9J1xcXCIgKyBzLmZpbGVOYW1lICsgXFxcIicgYWNjZXB0PSdcXFwiICsgcy5hY2NlcHRGaWxlcyArIFxcXCInLz5cXFwiO1xcbiAgICAgICAgICAgIGlmIChzLm11bHRpcGxlKSB7XFxuICAgICAgICAgICAgICAgIGlmIChzLmZpbGVOYW1lLmluZGV4T2YoXFxcIltdXFxcIikgIT0gcy5maWxlTmFtZS5sZW5ndGggLSAyKSAvLyBpZiBpdCBkb2VzIG5vdCBlbmR3aXRoXFxuICAgICAgICAgICAgICAgICAgICB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcy5maWxlTmFtZSArPSBcXFwiW11cXFwiO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBmaWxlSW5wdXRTdHIgPSBcXFwiPGlucHV0IHR5cGU9J2ZpbGUnIGlkPSdcXFwiICsgZmlsZVVwbG9hZElkICsgXFxcIicgbmFtZT0nXFxcIiArIHMuZmlsZU5hbWUgKyBcXFwiJyBhY2NlcHQ9J1xcXCIgKyBzLmFjY2VwdEZpbGVzICsgXFxcIicgbXVsdGlwbGUvPlxcXCI7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHZhciBmaWxlSW5wdXQgPSAkKGZpbGVJbnB1dFN0cikuYXBwZW5kVG8oZm9ybSk7XFxuXFxuICAgICAgICAgICAgZmlsZUlucHV0LmNoYW5nZShmdW5jdGlvbiAoKSB7XFxuXFxuICAgICAgICAgICAgICAgIG9iai5lcnJvckxvZy5odG1sKFxcXCJcXFwiKTtcXG4gICAgICAgICAgICAgICAgdmFyIGZpbGVFeHRlbnNpb25zID0gcy5hbGxvd2VkVHlwZXMudG9Mb3dlckNhc2UoKS5zcGxpdChcXFwiLFxcXCIpO1xcbiAgICAgICAgICAgICAgICB2YXIgZmlsZUFycmF5ID0gW107XFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbGVzKSAvL3N1cHBvcnQgcmVhZGluZyBmaWxlc1xcbiAgICAgICAgICAgICAgICAgICAge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmZpbGVzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVBcnJheS5wdXNoKHRoaXMuZmlsZXNbaV0ubmFtZSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzLm9uU2VsZWN0KHRoaXMuZmlsZXMpID09IGZhbHNlKSByZXR1cm47XFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpbGVuYW1lU3RyID0gJCh0aGlzKS52YWwoKTtcXG4gICAgICAgICAgICAgICAgICAgIHZhciBmbGlzdCA9IFtdO1xcbiAgICAgICAgICAgICAgICAgICAgZmlsZUFycmF5LnB1c2goZmlsZW5hbWVTdHIpO1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0ZpbGVUeXBlQWxsb3dlZChvYmosIHMsIGZpbGVuYW1lU3RyKSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzLnNob3dFcnJvcikgJChcXFwiPGRpdiBjbGFzcz0nXFxcIiArIHMuZXJyb3JDbGFzcyArIFxcXCInPjxiPlxcXCIgKyBmaWxlbmFtZVN0ciArIFxcXCI8L2I+IFxcXCIgKyBzLmV4dEVycm9yU3RyICsgcy5hbGxvd2VkVHlwZXMgKyBcXFwiPC9kaXY+XFxcIikuYXBwZW5kVG8ob2JqLmVycm9yTG9nKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAvL2ZhbGxiYWNrIGZvciBicm93c2VyIHdpdGhvdXQgRmlsZUFQSVxcbiAgICAgICAgICAgICAgICAgICAgZmxpc3QucHVzaCh7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZmlsZW5hbWVTdHIsXFxuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogJ05BJ1xcbiAgICAgICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgICAgICBpZiAocy5vblNlbGVjdChmbGlzdCkgPT0gZmFsc2UpIHJldHVybjtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB1cGRhdGVGaWxlQ291bnRlcihzLCBvYmopO1xcblxcbiAgICAgICAgICAgICAgICB1cGxvYWRMYWJlbC51bmJpbmQoXFxcImNsaWNrXFxcIik7XFxuICAgICAgICAgICAgICAgIGZvcm0uaGlkZSgpO1xcbiAgICAgICAgICAgICAgICBjcmVhdGVDdXN0b21JbnB1dEZpbGUob2JqLCBncm91cCwgcywgdXBsb2FkTGFiZWwpO1xcbiAgICAgICAgICAgICAgICBmb3JtLmFkZENsYXNzKGdyb3VwKTtcXG4gICAgICAgICAgICAgICAgaWYgKHMuc2VyaWFsaXplICYmIGZlYXR1cmUuZmlsZWFwaSAmJiBmZWF0dXJlLmZvcm1kYXRhKSAvL3VzZSBIVE1MNSBzdXBwb3J0IGFuZCBzcGxpdCBmaWxlIHN1Ym1pc3Npb25cXG4gICAgICAgICAgICAgICAgICAgIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtLnJlbW92ZUNsYXNzKGdyb3VwKTsgLy9TdG9wIFN1Ym1pdHRpbmcgd2hlbi5cXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmlsZXMgPSB0aGlzLmZpbGVzO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm0ucmVtb3ZlKCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWFsaXplQW5kVXBsb2FkRmlsZXMocywgb2JqLCBmaWxlcyk7XFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpbGVMaXN0ID0gXFxcIlxcXCI7XFxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbGVBcnJheS5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzLnNob3dGaWxlQ291bnRlcikgZmlsZUxpc3QgKz0gb2JqLmZpbGVDb3VudGVyICsgcy5maWxlQ291bnRlclN0eWxlICsgZmlsZUFycmF5W2ldICsgXFxcIjxicj5cXFwiO2Vsc2UgZmlsZUxpc3QgKz0gZmlsZUFycmF5W2ldICsgXFxcIjxicj5cXFwiOztcXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmouZmlsZUNvdW50ZXIrKztcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIGlmIChzLm1heEZpbGVDb3VudCAhPSAtMSAmJiBvYmouc2VsZWN0ZWRGaWxlcyArIGZpbGVBcnJheS5sZW5ndGggPiBzLm1heEZpbGVDb3VudCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzLnNob3dFcnJvcikgJChcXFwiPGRpdiBjbGFzcz0nXFxcIiArIHMuZXJyb3JDbGFzcyArIFxcXCInPjxiPlxcXCIgKyBmaWxlTGlzdCArIFxcXCI8L2I+IFxcXCIgKyBzLm1heEZpbGVDb3VudEVycm9yU3RyICsgcy5tYXhGaWxlQ291bnQgKyBcXFwiPC9kaXY+XFxcIikuYXBwZW5kVG8ob2JqLmVycm9yTG9nKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICBvYmouc2VsZWN0ZWRGaWxlcyArPSBmaWxlQXJyYXkubGVuZ3RoO1xcblxcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBkID0gbmV3IGNyZWF0ZVByb2dyZXNzRGl2KG9iaiwgcyk7XFxuICAgICAgICAgICAgICAgICAgICBwZC5maWxlbmFtZS5odG1sKGZpbGVMaXN0KTtcXG4gICAgICAgICAgICAgICAgICAgIGFqYXhGb3JtU3VibWl0KGZvcm0sIHMsIHBkLCBmaWxlQXJyYXksIG9iaiwgbnVsbCk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KTtcXG5cXG4gICAgICAgICAgICBpZiAocy5uZXN0ZWRGb3Jtcykge1xcbiAgICAgICAgICAgICAgICBmb3JtLmNzcyh7XFxuICAgICAgICAgICAgICAgICAgICAnbWFyZ2luJzogMCxcXG4gICAgICAgICAgICAgICAgICAgICdwYWRkaW5nJzogMFxcbiAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgdXBsb2FkTGFiZWwuY3NzKHtcXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yOiAnZGVmYXVsdCdcXG4gICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgIGZpbGVJbnB1dC5jc3Moe1xcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXFxuICAgICAgICAgICAgICAgICAgICAnY3Vyc29yJzogJ3BvaW50ZXInLFxcbiAgICAgICAgICAgICAgICAgICAgJ3RvcCc6ICcwcHgnLFxcbiAgICAgICAgICAgICAgICAgICAgJ3dpZHRoJzogJzEwMCUnLFxcbiAgICAgICAgICAgICAgICAgICAgJ2hlaWdodCc6ICcxMDAlJyxcXG4gICAgICAgICAgICAgICAgICAgICdsZWZ0JzogJzBweCcsXFxuICAgICAgICAgICAgICAgICAgICAnei1pbmRleCc6ICcxMDAnLFxcbiAgICAgICAgICAgICAgICAgICAgJ29wYWNpdHknOiAnMC4wJyxcXG4gICAgICAgICAgICAgICAgICAgICdmaWx0ZXInOiAnYWxwaGEob3BhY2l0eT0wKScsXFxuICAgICAgICAgICAgICAgICAgICAnLW1zLWZpbHRlcic6IFxcXCJhbHBoYShvcGFjaXR5PTApXFxcIixcXG4gICAgICAgICAgICAgICAgICAgICcta2h0bWwtb3BhY2l0eSc6ICcwLjAnLFxcbiAgICAgICAgICAgICAgICAgICAgJy1tb3otb3BhY2l0eSc6ICcwLjAnXFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICBmb3JtLmFwcGVuZFRvKHVwbG9hZExhYmVsKTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICBmb3JtLmFwcGVuZFRvKCQoJ2JvZHknKSk7XFxuICAgICAgICAgICAgICAgIGZvcm0uY3NzKHtcXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbjogMCxcXG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6IDAsXFxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiAnYmxvY2snLFxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiAnLTI1MHB4J1xcbiAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgaWYgKG5hdmlnYXRvci5hcHBWZXJzaW9uLmluZGV4T2YoXFxcIk1TSUUgXFxcIikgIT0gLTEpIC8vSUUgQnJvd3NlclxcbiAgICAgICAgICAgICAgICAgICAge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwbG9hZExhYmVsLmF0dHIoJ2ZvcicsIGZpbGVVcGxvYWRJZCk7XFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgdXBsb2FkTGFiZWwuY2xpY2soZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVJbnB1dC5jbGljaygpO1xcbiAgICAgICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICBmdW5jdGlvbiBkZWZhdWx0UHJvZ3Jlc3NCYXIob2JqLCBzKSB7XFxuXFxuICAgICAgICAgICAgdGhpcy5zdGF0dXNiYXIgPSAkKFxcXCI8ZGl2IGNsYXNzPSdhamF4LWZpbGUtdXBsb2FkLXN0YXR1c2Jhcic+PC9kaXY+XFxcIikud2lkdGgocy5zdGF0dXNCYXJXaWR0aCk7XFxuICAgICAgICAgICAgdGhpcy5wcmV2aWV3ID0gJChcXFwiPGltZyBjbGFzcz0nYWpheC1maWxlLXVwbG9hZC1wcmV2aWV3JyAvPlxcXCIpLndpZHRoKHMucHJldmlld1dpZHRoKS5oZWlnaHQocy5wcmV2aWV3SGVpZ2h0KS5hcHBlbmRUbyh0aGlzLnN0YXR1c2JhcikuaGlkZSgpO1xcbiAgICAgICAgICAgIHRoaXMuZmlsZW5hbWUgPSAkKFxcXCI8ZGl2IGNsYXNzPSdhamF4LWZpbGUtdXBsb2FkLWZpbGVuYW1lJz48L2Rpdj5cXFwiKS5hcHBlbmRUbyh0aGlzLnN0YXR1c2Jhcik7XFxuICAgICAgICAgICAgdGhpcy5wcm9ncmVzc0RpdiA9ICQoXFxcIjxkaXYgY2xhc3M9J2FqYXgtZmlsZS11cGxvYWQtcHJvZ3Jlc3MnPlxcXCIpLmFwcGVuZFRvKHRoaXMuc3RhdHVzYmFyKS5oaWRlKCk7XFxuICAgICAgICAgICAgdGhpcy5wcm9ncmVzc2JhciA9ICQoXFxcIjxkaXYgY2xhc3M9J2FqYXgtZmlsZS11cGxvYWQtYmFyJz48L2Rpdj5cXFwiKS5hcHBlbmRUbyh0aGlzLnByb2dyZXNzRGl2KTtcXG4gICAgICAgICAgICB0aGlzLmFib3J0ID0gJChcXFwiPGRpdj5cXFwiICsgcy5hYm9ydFN0ciArIFxcXCI8L2Rpdj5cXFwiKS5hcHBlbmRUbyh0aGlzLnN0YXR1c2JhcikuaGlkZSgpO1xcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsID0gJChcXFwiPGRpdj5cXFwiICsgcy5jYW5jZWxTdHIgKyBcXFwiPC9kaXY+XFxcIikuYXBwZW5kVG8odGhpcy5zdGF0dXNiYXIpLmhpZGUoKTtcXG4gICAgICAgICAgICB0aGlzLmRvbmUgPSAkKFxcXCI8ZGl2PlxcXCIgKyBzLmRvbmVTdHIgKyBcXFwiPC9kaXY+XFxcIikuYXBwZW5kVG8odGhpcy5zdGF0dXNiYXIpLmhpZGUoKTtcXG4gICAgICAgICAgICB0aGlzLmRvd25sb2FkID0gJChcXFwiPGRpdj5cXFwiICsgcy5kb3dubG9hZFN0ciArIFxcXCI8L2Rpdj5cXFwiKS5hcHBlbmRUbyh0aGlzLnN0YXR1c2JhcikuaGlkZSgpO1xcbiAgICAgICAgICAgIHRoaXMuZGVsID0gJChcXFwiPGRpdj5cXFwiICsgcy5kZWxldGVTdHIgKyBcXFwiPC9kaXY+XFxcIikuYXBwZW5kVG8odGhpcy5zdGF0dXNiYXIpLmhpZGUoKTtcXG5cXG4gICAgICAgICAgICB0aGlzLmFib3J0LmFkZENsYXNzKFxcXCJhamF4LWZpbGUtdXBsb2FkLXJlZFxcXCIpO1xcbiAgICAgICAgICAgIHRoaXMuZG9uZS5hZGRDbGFzcyhcXFwiYWpheC1maWxlLXVwbG9hZC1ncmVlblxcXCIpO1xcbiAgICAgICAgICAgIHRoaXMuZG93bmxvYWQuYWRkQ2xhc3MoXFxcImFqYXgtZmlsZS11cGxvYWQtZ3JlZW5cXFwiKTtcXG4gICAgICAgICAgICB0aGlzLmNhbmNlbC5hZGRDbGFzcyhcXFwiYWpheC1maWxlLXVwbG9hZC1yZWRcXFwiKTtcXG4gICAgICAgICAgICB0aGlzLmRlbC5hZGRDbGFzcyhcXFwiYWpheC1maWxlLXVwbG9hZC1yZWRcXFwiKTtcXG5cXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcXG4gICAgICAgIH1cXG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVByb2dyZXNzRGl2KG9iaiwgcykge1xcbiAgICAgICAgICAgIHZhciBiYXIgPSBudWxsO1xcbiAgICAgICAgICAgIGlmIChzLmN1c3RvbVByb2dyZXNzQmFyKSBiYXIgPSBuZXcgcy5jdXN0b21Qcm9ncmVzc0JhcihvYmosIHMpO2Vsc2UgYmFyID0gbmV3IGRlZmF1bHRQcm9ncmVzc0JhcihvYmosIHMpO1xcblxcbiAgICAgICAgICAgIGJhci5hYm9ydC5hZGRDbGFzcyhvYmouZm9ybUdyb3VwKTtcXG4gICAgICAgICAgICBiYXIuYWJvcnQuYWRkQ2xhc3Mocy5hYm9ydEJ1dHRvbkNsYXNzKTtcXG5cXG4gICAgICAgICAgICBiYXIuY2FuY2VsLmFkZENsYXNzKG9iai5mb3JtR3JvdXApO1xcbiAgICAgICAgICAgIGJhci5jYW5jZWwuYWRkQ2xhc3Mocy5jYW5jZWxCdXR0b25DbGFzcyk7XFxuXFxuICAgICAgICAgICAgaWYgKHMuZXh0cmFIVE1MKSBiYXIuZXh0cmFIVE1MID0gJChcXFwiPGRpdiBjbGFzcz0nZXh0cmFodG1sJz5cXFwiICsgcy5leHRyYUhUTUwoKSArIFxcXCI8L2Rpdj5cXFwiKS5pbnNlcnRBZnRlcihiYXIuZmlsZW5hbWUpO1xcblxcbiAgICAgICAgICAgIGlmIChzLnVwbG9hZFF1ZXVlT3JkZXIgPT0gJ2JvdHRvbScpICQob2JqLmNvbnRhaW5lcikuYXBwZW5kKGJhci5zdGF0dXNiYXIpO2Vsc2UgJChvYmouY29udGFpbmVyKS5wcmVwZW5kKGJhci5zdGF0dXNiYXIpO1xcbiAgICAgICAgICAgIHJldHVybiBiYXI7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBmdW5jdGlvbiBhamF4Rm9ybVN1Ym1pdChmb3JtLCBzLCBwZCwgZmlsZUFycmF5LCBvYmosIGZpbGUpIHtcXG4gICAgICAgICAgICB2YXIgY3VycmVudFhIUiA9IG51bGw7XFxuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB7XFxuICAgICAgICAgICAgICAgIGNhY2hlOiBmYWxzZSxcXG4gICAgICAgICAgICAgICAgY29udGVudFR5cGU6IGZhbHNlLFxcbiAgICAgICAgICAgICAgICBwcm9jZXNzRGF0YTogZmFsc2UsXFxuICAgICAgICAgICAgICAgIGZvcmNlU3luYzogZmFsc2UsXFxuICAgICAgICAgICAgICAgIHR5cGU6IHMubWV0aG9kLFxcbiAgICAgICAgICAgICAgICBkYXRhOiBzLmZvcm1EYXRhLFxcbiAgICAgICAgICAgICAgICBmb3JtRGF0YTogcy5maWxlRGF0YSxcXG4gICAgICAgICAgICAgICAgZGF0YVR5cGU6IHMucmV0dXJuVHlwZSxcXG4gICAgICAgICAgICAgICAgaGVhZGVyczogcy5oZWFkZXJzLFxcbiAgICAgICAgICAgICAgICBiZWZvcmVTdWJtaXQ6IGZ1bmN0aW9uIGJlZm9yZVN1Ym1pdChmb3JtRGF0YSwgJGZvcm0sIG9wdGlvbnMpIHtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChzLm9uU3VibWl0LmNhbGwodGhpcywgZmlsZUFycmF5KSAhPSBmYWxzZSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzLmR5bmFtaWNGb3JtRGF0YSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc0RhdGEgPSBzZXJpYWxpemVEYXRhKHMuZHluYW1pY0Zvcm1EYXRhKCkpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc0RhdGEpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc0RhdGEubGVuZ3RoOyBqKyspIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc0RhdGFbal0pIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMuc2VyaWFsaXplICYmIHMuZmlsZURhdGEgIT0gdW5kZWZpbmVkKSBvcHRpb25zLmZvcm1EYXRhLmFwcGVuZChzRGF0YVtqXVswXSwgc0RhdGFbal1bMV0pO2Vsc2Ugb3B0aW9ucy5kYXRhW3NEYXRhW2pdWzBdXSA9IHNEYXRhW2pdWzFdO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocy5leHRyYUhUTUwpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJChwZC5leHRyYUhUTUwpLmZpbmQoXFxcImlucHV0LHNlbGVjdCx0ZXh0YXJlYVxcXCIpLmVhY2goZnVuY3Rpb24gKGksIGl0ZW1zKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocy5zZXJpYWxpemUgJiYgcy5maWxlRGF0YSAhPSB1bmRlZmluZWQpIG9wdGlvbnMuZm9ybURhdGEuYXBwZW5kKCQodGhpcykuYXR0cignbmFtZScpLCAkKHRoaXMpLnZhbCgpKTtlbHNlIG9wdGlvbnMuZGF0YVskKHRoaXMpLmF0dHIoJ25hbWUnKV0gPSAkKHRoaXMpLnZhbCgpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICBwZC5zdGF0dXNiYXIuYXBwZW5kKFxcXCI8ZGl2IGNsYXNzPSdcXFwiICsgcy5lcnJvckNsYXNzICsgXFxcIic+XFxcIiArIHMudXBsb2FkRXJyb3JTdHIgKyBcXFwiPC9kaXY+XFxcIik7XFxuICAgICAgICAgICAgICAgICAgICBwZC5jYW5jZWwuc2hvdygpO1xcbiAgICAgICAgICAgICAgICAgICAgZm9ybS5yZW1vdmUoKTtcXG4gICAgICAgICAgICAgICAgICAgIHBkLmNhbmNlbC5jbGljayhmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFpblEuc3BsaWNlKG1haW5RLmluZGV4T2YoZm9ybSksIDEpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUV4aXN0aW5nRmlsZU5hbWUob2JqLCBmaWxlQXJyYXkpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHBkLnN0YXR1c2Jhci5yZW1vdmUoKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBzLm9uQ2FuY2VsLmNhbGwob2JqLCBmaWxlQXJyYXksIHBkKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmouc2VsZWN0ZWRGaWxlcyAtPSBmaWxlQXJyYXkubGVuZ3RoOyAvL3JlZHVjZSBzZWxlY3RlZCBGaWxlIGNvdW50XFxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlRmlsZUNvdW50ZXIocywgb2JqKTtcXG4gICAgICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICBiZWZvcmVTZW5kOiBmdW5jdGlvbiBiZWZvcmVTZW5kKHhociwgbykge1xcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG8uaGVhZGVycykge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgby5oZWFkZXJzW2tleV0pO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICAgICAgcGQucHJvZ3Jlc3NEaXYuc2hvdygpO1xcbiAgICAgICAgICAgICAgICAgICAgcGQuY2FuY2VsLmhpZGUoKTtcXG4gICAgICAgICAgICAgICAgICAgIHBkLmRvbmUuaGlkZSgpO1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKHMuc2hvd0Fib3J0KSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcGQuYWJvcnQuc2hvdygpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHBkLmFib3J0LmNsaWNrKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRXhpc3RpbmdGaWxlTmFtZShvYmosIGZpbGVBcnJheSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5hYm9ydCgpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmouc2VsZWN0ZWRGaWxlcyAtPSBmaWxlQXJyYXkubGVuZ3RoOyAvL3JlZHVjZSBzZWxlY3RlZCBGaWxlIGNvdW50XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMub25BYm9ydC5jYWxsKG9iaiwgZmlsZUFycmF5LCBwZCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICBpZiAoIWZlYXR1cmUuZm9ybWRhdGEpIC8vRm9yIGlmcmFtZSBiYXNlZCBwdXNoXFxuICAgICAgICAgICAgICAgICAgICAgICAge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZC5wcm9ncmVzc2Jhci53aWR0aCgnNSUnKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgcGQucHJvZ3Jlc3NiYXIud2lkdGgoJzElJyk7IC8vRml4IGZvciBzbWFsbCBmaWxlc1xcbiAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICB1cGxvYWRQcm9ncmVzczogZnVuY3Rpb24gdXBsb2FkUHJvZ3Jlc3MoZXZlbnQsIHBvc2l0aW9uLCB0b3RhbCwgcGVyY2VudENvbXBsZXRlKSB7XFxuICAgICAgICAgICAgICAgICAgICAvL0ZpeCBmb3Igc21hbGxlciBmaWxlIHVwbG9hZHMgaW4gTUFDXFxuICAgICAgICAgICAgICAgICAgICBpZiAocGVyY2VudENvbXBsZXRlID4gOTgpIHBlcmNlbnRDb21wbGV0ZSA9IDk4O1xcblxcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBlcmNlbnRWYWwgPSBwZXJjZW50Q29tcGxldGUgKyAnJSc7XFxuICAgICAgICAgICAgICAgICAgICBpZiAocGVyY2VudENvbXBsZXRlID4gMSkgcGQucHJvZ3Jlc3NiYXIud2lkdGgocGVyY2VudFZhbCk7XFxuICAgICAgICAgICAgICAgICAgICBpZiAocy5zaG93UHJvZ3Jlc3MpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBwZC5wcm9ncmVzc2Jhci5odG1sKHBlcmNlbnRWYWwpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHBkLnByb2dyZXNzYmFyLmNzcygndGV4dC1hbGlnbicsICdjZW50ZXInKTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gc3VjY2VzcyhkYXRhLCBtZXNzYWdlLCB4aHIpIHtcXG4gICAgICAgICAgICAgICAgICAgIHBkLmNhbmNlbC5yZW1vdmUoKTtcXG4gICAgICAgICAgICAgICAgICAgIHByb2dyZXNzUS5wb3AoKTtcXG4gICAgICAgICAgICAgICAgICAgIC8vRm9yIGN1c3RvbSBlcnJvcnMuXFxuICAgICAgICAgICAgICAgICAgICBpZiAocy5yZXR1cm5UeXBlID09IFxcXCJqc29uXFxcIiAmJiAkLnR5cGUoZGF0YSkgPT0gXFxcIm9iamVjdFxcXCIgJiYgZGF0YS5oYXNPd25Qcm9wZXJ0eShzLmN1c3RvbUVycm9yS2V5U3RyKSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHBkLmFib3J0LmhpZGUoKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbXNnID0gZGF0YVtzLmN1c3RvbUVycm9yS2V5U3RyXTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBzLm9uRXJyb3IuY2FsbCh0aGlzLCBmaWxlQXJyYXksIDIwMCwgbXNnLCBwZCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMuc2hvd1N0YXR1c0FmdGVyRXJyb3IpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGQucHJvZ3Jlc3NEaXYuaGlkZSgpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZC5zdGF0dXNiYXIuYXBwZW5kKFxcXCI8c3BhbiBjbGFzcz0nXFxcIiArIHMuZXJyb3JDbGFzcyArIFxcXCInPkVSUk9SOiBcXFwiICsgbXNnICsgXFxcIjwvc3Bhbj5cXFwiKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZC5zdGF0dXNiYXIuaGlkZSgpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZC5zdGF0dXNiYXIucmVtb3ZlKCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iai5zZWxlY3RlZEZpbGVzIC09IGZpbGVBcnJheS5sZW5ndGg7IC8vcmVkdWNlIHNlbGVjdGVkIEZpbGUgY291bnRcXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtLnJlbW92ZSgpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIG9iai5yZXNwb25zZXMucHVzaChkYXRhKTtcXG4gICAgICAgICAgICAgICAgICAgIHBkLnByb2dyZXNzYmFyLndpZHRoKCcxMDAlJyk7XFxuICAgICAgICAgICAgICAgICAgICBpZiAocy5zaG93UHJvZ3Jlc3MpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBwZC5wcm9ncmVzc2Jhci5odG1sKCcxMDAlJyk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcGQucHJvZ3Jlc3NiYXIuY3NzKCd0ZXh0LWFsaWduJywgJ2NlbnRlcicpO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICAgICAgcGQuYWJvcnQuaGlkZSgpO1xcbiAgICAgICAgICAgICAgICAgICAgcy5vblN1Y2Nlc3MuY2FsbCh0aGlzLCBmaWxlQXJyYXksIGRhdGEsIHhociwgcGQpO1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKHMuc2hvd1N0YXR1c0FmdGVyU3VjY2Vzcykge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzLnNob3dEb25lKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBkLmRvbmUuc2hvdygpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZC5kb25lLmNsaWNrKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBkLnN0YXR1c2Jhci5oaWRlKFxcXCJzbG93XFxcIik7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZC5zdGF0dXNiYXIucmVtb3ZlKCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBkLmRvbmUuaGlkZSgpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocy5zaG93RGVsZXRlKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBkLmRlbC5zaG93KCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBkLmRlbC5jbGljayhmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVFeGlzdGluZ0ZpbGVOYW1lKG9iaiwgZmlsZUFycmF5KTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBkLnN0YXR1c2Jhci5oaWRlKCkucmVtb3ZlKCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocy5kZWxldGVDYWxsYmFjaykgcy5kZWxldGVDYWxsYmFjay5jYWxsKHRoaXMsIGRhdGEsIHBkKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5zZWxlY3RlZEZpbGVzIC09IGZpbGVBcnJheS5sZW5ndGg7IC8vcmVkdWNlIHNlbGVjdGVkIEZpbGUgY291bnRcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZUZpbGVDb3VudGVyKHMsIG9iaik7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBkLmRlbC5oaWRlKCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBwZC5zdGF0dXNiYXIuaGlkZShcXFwic2xvd1xcXCIpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHBkLnN0YXR1c2Jhci5yZW1vdmUoKTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIGlmIChzLnNob3dEb3dubG9hZCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHBkLmRvd25sb2FkLnNob3coKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBwZC5kb3dubG9hZC5jbGljayhmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzLmRvd25sb2FkQ2FsbGJhY2spIHMuZG93bmxvYWRDYWxsYmFjayhkYXRhLCBwZCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICBmb3JtLnJlbW92ZSgpO1xcbiAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24gZXJyb3IoeGhyLCBzdGF0dXMsIGVyck1zZykge1xcbiAgICAgICAgICAgICAgICAgICAgcGQuY2FuY2VsLnJlbW92ZSgpO1xcbiAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3NRLnBvcCgpO1xcbiAgICAgICAgICAgICAgICAgICAgcGQuYWJvcnQuaGlkZSgpO1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKHhoci5zdGF0dXNUZXh0ID09IFxcXCJhYm9ydFxcXCIpIC8vd2UgYWJvcnRlZCBpdFxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGQuc3RhdHVzYmFyLmhpZGUoXFxcInNsb3dcXFwiKS5yZW1vdmUoKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlRmlsZUNvdW50ZXIocywgb2JqKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHMub25FcnJvci5jYWxsKHRoaXMsIGZpbGVBcnJheSwgc3RhdHVzLCBlcnJNc2csIHBkKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocy5zaG93U3RhdHVzQWZ0ZXJFcnJvcikge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZC5wcm9ncmVzc0Rpdi5oaWRlKCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBkLnN0YXR1c2Jhci5hcHBlbmQoXFxcIjxzcGFuIGNsYXNzPSdcXFwiICsgcy5lcnJvckNsYXNzICsgXFxcIic+RVJST1I6IFxcXCIgKyBlcnJNc2cgKyBcXFwiPC9zcGFuPlxcXCIpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBkLnN0YXR1c2Jhci5oaWRlKCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBkLnN0YXR1c2Jhci5yZW1vdmUoKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqLnNlbGVjdGVkRmlsZXMgLT0gZmlsZUFycmF5Lmxlbmd0aDsgLy9yZWR1Y2Ugc2VsZWN0ZWQgRmlsZSBjb3VudFxcbiAgICAgICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICAgICAgZm9ybS5yZW1vdmUoKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH07XFxuXFxuICAgICAgICAgICAgaWYgKHMuc2hvd1ByZXZpZXcgJiYgZmlsZSAhPSBudWxsKSB7XFxuICAgICAgICAgICAgICAgIGlmIChmaWxlLnR5cGUudG9Mb3dlckNhc2UoKS5zcGxpdChcXFwiL1xcXCIpLnNoaWZ0KCkgPT0gXFxcImltYWdlXFxcIikgZ2V0U3JjVG9QcmV2aWV3KGZpbGUsIHBkLnByZXZpZXcpO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpZiAocy5hdXRvU3VibWl0KSB7XFxuICAgICAgICAgICAgICAgIGZvcm0uYWpheEZvcm0ob3B0aW9ucyk7XFxuICAgICAgICAgICAgICAgIG1haW5RLnB1c2goZm9ybSk7XFxuICAgICAgICAgICAgICAgIHN1Ym1pdFBlbmRpbmdVcGxvYWRzKCk7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgaWYgKHMuc2hvd0NhbmNlbCkge1xcbiAgICAgICAgICAgICAgICAgICAgcGQuY2FuY2VsLnNob3coKTtcXG4gICAgICAgICAgICAgICAgICAgIHBkLmNhbmNlbC5jbGljayhmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFpblEuc3BsaWNlKG1haW5RLmluZGV4T2YoZm9ybSksIDEpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUV4aXN0aW5nRmlsZU5hbWUob2JqLCBmaWxlQXJyYXkpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm0ucmVtb3ZlKCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgcGQuc3RhdHVzYmFyLnJlbW92ZSgpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHMub25DYW5jZWwuY2FsbChvYmosIGZpbGVBcnJheSwgcGQpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iai5zZWxlY3RlZEZpbGVzIC09IGZpbGVBcnJheS5sZW5ndGg7IC8vcmVkdWNlIHNlbGVjdGVkIEZpbGUgY291bnRcXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVGaWxlQ291bnRlcihzLCBvYmopO1xcbiAgICAgICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgZm9ybS5hamF4Rm9ybShvcHRpb25zKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gdGhpcztcXG4gICAgfTtcXG59KShqUXVlcnkpO1wiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmF3LWxvYWRlciEuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliPz9yZWYtLTAtMCEuL2Fzc2V0cy9qcy9qcXVlcnkudXBsb2FkZmlsZS00LjAuMTEuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3Jhdy1sb2FkZXIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0wLTAhLi9hc3NldHMvanMvanF1ZXJ5LnVwbG9hZGZpbGUtNC4wLjExLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc3JjKSB7XG5cdGZ1bmN0aW9uIGxvZyhlcnJvcikge1xuXHRcdCh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIilcblx0XHQmJiAoY29uc29sZS5lcnJvciB8fCBjb25zb2xlLmxvZykoXCJbU2NyaXB0IExvYWRlcl1cIiwgZXJyb3IpO1xuXHR9XG5cblx0Ly8gQ2hlY2sgZm9yIElFID08IDhcblx0ZnVuY3Rpb24gaXNJRSgpIHtcblx0XHRyZXR1cm4gdHlwZW9mIGF0dGFjaEV2ZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBhZGRFdmVudExpc3RlbmVyID09PSBcInVuZGVmaW5lZFwiO1xuXHR9XG5cblx0dHJ5IHtcblx0XHRpZiAodHlwZW9mIGV4ZWNTY3JpcHQgIT09IFwidW5kZWZpbmVkXCIgJiYgaXNJRSgpKSB7XG5cdFx0XHRleGVjU2NyaXB0KHNyYyk7XG5cdFx0fSBlbHNlIGlmICh0eXBlb2YgZXZhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0ZXZhbC5jYWxsKG51bGwsIHNyYyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxvZyhcIkV2YWxFcnJvcjogTm8gZXZhbCBmdW5jdGlvbiBhdmFpbGFibGVcIik7XG5cdFx0fVxuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdGxvZyhlcnJvcik7XG5cdH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMiLCJyZXF1aXJlKFwiISEvaG9tZS9rb25zdGFudGluL3dvcmtzcGFjZS9tbGFiLmxvY2FsLnRlc3Qvbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzXCIpKHJlcXVpcmUoXCIhIS9ob21lL2tvbnN0YW50aW4vd29ya3NwYWNlL21sYWIubG9jYWwudGVzdC9ub2RlX21vZHVsZXMvcmF3LWxvYWRlci9pbmRleC5qcyEvaG9tZS9rb25zdGFudGluL3dvcmtzcGFjZS9tbGFiLmxvY2FsLnRlc3Qvbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMC0wIS9ob21lL2tvbnN0YW50aW4vd29ya3NwYWNlL21sYWIubG9jYWwudGVzdC9hc3NldHMvanMvYm93c2VyLmpzXCIpK1wiXFxuXFxuLy8gU0NSSVBULUxPQURFUiBGT09URVJcXG4vLyMgc291cmNlVVJMPXNjcmlwdDovLy9ob21lL2tvbnN0YW50aW4vd29ya3NwYWNlL21sYWIubG9jYWwudGVzdC9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyUzRj9yZWYtLTAtMCEvaG9tZS9rb25zdGFudGluL3dvcmtzcGFjZS9tbGFiLmxvY2FsLnRlc3QvYXNzZXRzL2pzL2Jvd3Nlci5qc1wiKVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIhLi9hc3NldHMvanMvYm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyL2luZGV4LmpzIS4vYXNzZXRzL2pzL2Jvd3Nlci5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInJlcXVpcmUoXCIhIS9ob21lL2tvbnN0YW50aW4vd29ya3NwYWNlL21sYWIubG9jYWwudGVzdC9ub2RlX21vZHVsZXMvc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanNcIikocmVxdWlyZShcIiEhL2hvbWUva29uc3RhbnRpbi93b3Jrc3BhY2UvbWxhYi5sb2NhbC50ZXN0L25vZGVfbW9kdWxlcy9yYXctbG9hZGVyL2luZGV4LmpzIS9ob21lL2tvbnN0YW50aW4vd29ya3NwYWNlL21sYWIubG9jYWwudGVzdC9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0wLTAhL2hvbWUva29uc3RhbnRpbi93b3Jrc3BhY2UvbWxhYi5sb2NhbC50ZXN0L2Fzc2V0cy9qcy9qcXVlcnktMi4xLjQuanNcIikrXCJcXG5cXG4vLyBTQ1JJUFQtTE9BREVSIEZPT1RFUlxcbi8vIyBzb3VyY2VVUkw9c2NyaXB0Oi8vL2hvbWUva29uc3RhbnRpbi93b3Jrc3BhY2UvbWxhYi5sb2NhbC50ZXN0L25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzJTNGP3JlZi0tMC0wIS9ob21lL2tvbnN0YW50aW4vd29ya3NwYWNlL21sYWIubG9jYWwudGVzdC9hc3NldHMvanMvanF1ZXJ5LTIuMS40LmpzXCIpXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvc2NyaXB0LWxvYWRlciEuL2Fzc2V0cy9qcy9qcXVlcnktMi4xLjQuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvaW5kZXguanMhLi9hc3NldHMvanMvanF1ZXJ5LTIuMS40LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwicmVxdWlyZShcIiEhL2hvbWUva29uc3RhbnRpbi93b3Jrc3BhY2UvbWxhYi5sb2NhbC50ZXN0L25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qc1wiKShyZXF1aXJlKFwiISEvaG9tZS9rb25zdGFudGluL3dvcmtzcGFjZS9tbGFiLmxvY2FsLnRlc3Qvbm9kZV9tb2R1bGVzL3Jhdy1sb2FkZXIvaW5kZXguanMhL2hvbWUva29uc3RhbnRpbi93b3Jrc3BhY2UvbWxhYi5sb2NhbC50ZXN0L25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTAtMCEvaG9tZS9rb25zdGFudGluL3dvcmtzcGFjZS9tbGFiLmxvY2FsLnRlc3QvYXNzZXRzL2pzL2pxdWVyeS5mb3JtLmpzXCIpK1wiXFxuXFxuLy8gU0NSSVBULUxPQURFUiBGT09URVJcXG4vLyMgc291cmNlVVJMPXNjcmlwdDovLy9ob21lL2tvbnN0YW50aW4vd29ya3NwYWNlL21sYWIubG9jYWwudGVzdC9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyUzRj9yZWYtLTAtMCEvaG9tZS9rb25zdGFudGluL3dvcmtzcGFjZS9tbGFiLmxvY2FsLnRlc3QvYXNzZXRzL2pzL2pxdWVyeS5mb3JtLmpzXCIpXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvc2NyaXB0LWxvYWRlciEuL2Fzc2V0cy9qcy9qcXVlcnkuZm9ybS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvc2NyaXB0LWxvYWRlci9pbmRleC5qcyEuL2Fzc2V0cy9qcy9qcXVlcnkuZm9ybS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInJlcXVpcmUoXCIhIS9ob21lL2tvbnN0YW50aW4vd29ya3NwYWNlL21sYWIubG9jYWwudGVzdC9ub2RlX21vZHVsZXMvc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanNcIikocmVxdWlyZShcIiEhL2hvbWUva29uc3RhbnRpbi93b3Jrc3BhY2UvbWxhYi5sb2NhbC50ZXN0L25vZGVfbW9kdWxlcy9yYXctbG9hZGVyL2luZGV4LmpzIS9ob21lL2tvbnN0YW50aW4vd29ya3NwYWNlL21sYWIubG9jYWwudGVzdC9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0wLTAhL2hvbWUva29uc3RhbnRpbi93b3Jrc3BhY2UvbWxhYi5sb2NhbC50ZXN0L2Fzc2V0cy9qcy9qcXVlcnkucXRpcC5uaWdodGx5LmpzXCIpK1wiXFxuXFxuLy8gU0NSSVBULUxPQURFUiBGT09URVJcXG4vLyMgc291cmNlVVJMPXNjcmlwdDovLy9ob21lL2tvbnN0YW50aW4vd29ya3NwYWNlL21sYWIubG9jYWwudGVzdC9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyUzRj9yZWYtLTAtMCEvaG9tZS9rb25zdGFudGluL3dvcmtzcGFjZS9tbGFiLmxvY2FsLnRlc3QvYXNzZXRzL2pzL2pxdWVyeS5xdGlwLm5pZ2h0bHkuanNcIilcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyIS4vYXNzZXRzL2pzL2pxdWVyeS5xdGlwLm5pZ2h0bHkuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvaW5kZXguanMhLi9hc3NldHMvanMvanF1ZXJ5LnF0aXAubmlnaHRseS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInJlcXVpcmUoXCIhIS9ob21lL2tvbnN0YW50aW4vd29ya3NwYWNlL21sYWIubG9jYWwudGVzdC9ub2RlX21vZHVsZXMvc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanNcIikocmVxdWlyZShcIiEhL2hvbWUva29uc3RhbnRpbi93b3Jrc3BhY2UvbWxhYi5sb2NhbC50ZXN0L25vZGVfbW9kdWxlcy9yYXctbG9hZGVyL2luZGV4LmpzIS9ob21lL2tvbnN0YW50aW4vd29ya3NwYWNlL21sYWIubG9jYWwudGVzdC9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0wLTAhL2hvbWUva29uc3RhbnRpbi93b3Jrc3BhY2UvbWxhYi5sb2NhbC50ZXN0L2Fzc2V0cy9qcy9qcXVlcnkudWktMS4xMS40LmpzXCIpK1wiXFxuXFxuLy8gU0NSSVBULUxPQURFUiBGT09URVJcXG4vLyMgc291cmNlVVJMPXNjcmlwdDovLy9ob21lL2tvbnN0YW50aW4vd29ya3NwYWNlL21sYWIubG9jYWwudGVzdC9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyUzRj9yZWYtLTAtMCEvaG9tZS9rb25zdGFudGluL3dvcmtzcGFjZS9tbGFiLmxvY2FsLnRlc3QvYXNzZXRzL2pzL2pxdWVyeS51aS0xLjExLjQuanNcIilcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyIS4vYXNzZXRzL2pzL2pxdWVyeS51aS0xLjExLjQuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvaW5kZXguanMhLi9hc3NldHMvanMvanF1ZXJ5LnVpLTEuMTEuNC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInJlcXVpcmUoXCIhIS9ob21lL2tvbnN0YW50aW4vd29ya3NwYWNlL21sYWIubG9jYWwudGVzdC9ub2RlX21vZHVsZXMvc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanNcIikocmVxdWlyZShcIiEhL2hvbWUva29uc3RhbnRpbi93b3Jrc3BhY2UvbWxhYi5sb2NhbC50ZXN0L25vZGVfbW9kdWxlcy9yYXctbG9hZGVyL2luZGV4LmpzIS9ob21lL2tvbnN0YW50aW4vd29ya3NwYWNlL21sYWIubG9jYWwudGVzdC9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0wLTAhL2hvbWUva29uc3RhbnRpbi93b3Jrc3BhY2UvbWxhYi5sb2NhbC50ZXN0L2Fzc2V0cy9qcy9qcXVlcnkudXBsb2FkZmlsZS00LjAuMTEuanNcIikrXCJcXG5cXG4vLyBTQ1JJUFQtTE9BREVSIEZPT1RFUlxcbi8vIyBzb3VyY2VVUkw9c2NyaXB0Oi8vL2hvbWUva29uc3RhbnRpbi93b3Jrc3BhY2UvbWxhYi5sb2NhbC50ZXN0L25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzJTNGP3JlZi0tMC0wIS9ob21lL2tvbnN0YW50aW4vd29ya3NwYWNlL21sYWIubG9jYWwudGVzdC9hc3NldHMvanMvanF1ZXJ5LnVwbG9hZGZpbGUtNC4wLjExLmpzXCIpXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvc2NyaXB0LWxvYWRlciEuL2Fzc2V0cy9qcy9qcXVlcnkudXBsb2FkZmlsZS00LjAuMTEuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvaW5kZXguanMhLi9hc3NldHMvanMvanF1ZXJ5LnVwbG9hZGZpbGUtNC4wLjExLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIl0sInNvdXJjZVJvb3QiOiIifQ==