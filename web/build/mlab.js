/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/build/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./assets/js/mlab.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./assets/js/mlab.js":
/*!***************************!*\
  !*** ./assets/js/mlab.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// require jQuery normally
var $ = __webpack_require__(/*! script-loader!./jquery-2.1.4.js */ "./node_modules/script-loader/index.js!./assets/js/jquery-2.1.4.js"); // if/when use NPM version, need to create global $ and jQuery variables
// global.$ = global.jQuery = $;


__webpack_require__(/*! script-loader!./jquery.ui-1.11.4.js */ "./node_modules/script-loader/index.js!./assets/js/jquery.ui-1.11.4.js");

__webpack_require__(/*! script-loader!./jquery.form.js */ "./node_modules/script-loader/index.js!./assets/js/jquery.form.js");

__webpack_require__(/*! script-loader!./jquery.uploadfile-4.0.11.js */ "./node_modules/script-loader/index.js!./assets/js/jquery.uploadfile-4.0.11.js"); // require('script-loader!./jquery.qtip-3.0.3.js');


__webpack_require__(/*! script-loader!./jquery.qtip.nightly.js */ "./node_modules/script-loader/index.js!./assets/js/jquery.qtip.nightly.js");

__webpack_require__(/*! script-loader!./bowser.js */ "./node_modules/script-loader/index.js!./assets/js/bowser.js");

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./node_modules/babel-loader/lib/index.js?!./assets/js/bowser.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/raw-loader!./node_modules/babel-loader/lib??ref--4-0!./assets/js/bowser.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "/*!\n  * Bowser - a browser detector\n  * https://github.com/ded/bowser\n  * MIT License | (c) Dustin Diaz 2014\n  */\n!function (name, definition) {\n  if (typeof module != 'undefined' && module.exports) module.exports['browser'] = definition();else if (typeof define == 'function' && define.amd) define(definition);else this[name] = definition();\n}('bowser', function () {\n  /**\n    * See useragents.js for examples of navigator.userAgent\n    */\n  var t = true;\n\n  function detect(ua) {\n    function getFirstMatch(regex) {\n      var match = ua.match(regex);\n      return match && match.length > 1 && match[1] || '';\n    }\n\n    function getSecondMatch(regex) {\n      var match = ua.match(regex);\n      return match && match.length > 1 && match[2] || '';\n    }\n\n    var iosdevice = getFirstMatch(/(ipod|iphone|ipad)/i).toLowerCase(),\n        likeAndroid = /like android/i.test(ua),\n        android = !likeAndroid && /android/i.test(ua),\n        edgeVersion = getFirstMatch(/edge\\/(\\d+(\\.\\d+)?)/i),\n        versionIdentifier = getFirstMatch(/version\\/(\\d+(\\.\\d+)?)/i),\n        tablet = /tablet/i.test(ua),\n        mobile = !tablet && /[^-]mobi/i.test(ua),\n        result;\n\n    if (/opera|opr/i.test(ua)) {\n      result = {\n        name: 'Opera',\n        opera: t,\n        version: versionIdentifier || getFirstMatch(/(?:opera|opr)[\\s\\/](\\d+(\\.\\d+)?)/i)\n      };\n    } else if (/windows phone/i.test(ua)) {\n      result = {\n        name: 'Windows Phone',\n        windowsphone: t\n      };\n\n      if (edgeVersion) {\n        result.msedge = t;\n        result.version = edgeVersion;\n      } else {\n        result.msie = t;\n        result.version = getFirstMatch(/iemobile\\/(\\d+(\\.\\d+)?)/i);\n      }\n    } else if (/msie|trident/i.test(ua)) {\n      result = {\n        name: 'Internet Explorer',\n        msie: t,\n        version: getFirstMatch(/(?:msie |rv:)(\\d+(\\.\\d+)?)/i)\n      };\n    } else if (/chrome.+? edge/i.test(ua)) {\n      result = {\n        name: 'Microsoft Edge',\n        msedge: t,\n        version: edgeVersion\n      };\n    } else if (/chrome|crios|crmo/i.test(ua)) {\n      result = {\n        name: 'Chrome',\n        chrome: t,\n        version: getFirstMatch(/(?:chrome|crios|crmo)\\/(\\d+(\\.\\d+)?)/i)\n      };\n    } else if (iosdevice) {\n      result = {\n        name: iosdevice == 'iphone' ? 'iPhone' : iosdevice == 'ipad' ? 'iPad' : 'iPod' // WTF: version is not part of user agent in web apps\n\n      };\n\n      if (versionIdentifier) {\n        result.version = versionIdentifier;\n      }\n    } else if (/sailfish/i.test(ua)) {\n      result = {\n        name: 'Sailfish',\n        sailfish: t,\n        version: getFirstMatch(/sailfish\\s?browser\\/(\\d+(\\.\\d+)?)/i)\n      };\n    } else if (/seamonkey\\//i.test(ua)) {\n      result = {\n        name: 'SeaMonkey',\n        seamonkey: t,\n        version: getFirstMatch(/seamonkey\\/(\\d+(\\.\\d+)?)/i)\n      };\n    } else if (/firefox|iceweasel/i.test(ua)) {\n      result = {\n        name: 'Firefox',\n        firefox: t,\n        version: getFirstMatch(/(?:firefox|iceweasel)[ \\/](\\d+(\\.\\d+)?)/i)\n      };\n\n      if (/\\((mobile|tablet);[^\\)]*rv:[\\d\\.]+\\)/i.test(ua)) {\n        result.firefoxos = t;\n      }\n    } else if (/silk/i.test(ua)) {\n      result = {\n        name: 'Amazon Silk',\n        silk: t,\n        version: getFirstMatch(/silk\\/(\\d+(\\.\\d+)?)/i)\n      };\n    } else if (android) {\n      result = {\n        name: 'Android',\n        version: versionIdentifier\n      };\n    } else if (/phantom/i.test(ua)) {\n      result = {\n        name: 'PhantomJS',\n        phantom: t,\n        version: getFirstMatch(/phantomjs\\/(\\d+(\\.\\d+)?)/i)\n      };\n    } else if (/blackberry|\\bbb\\d+/i.test(ua) || /rim\\stablet/i.test(ua)) {\n      result = {\n        name: 'BlackBerry',\n        blackberry: t,\n        version: versionIdentifier || getFirstMatch(/blackberry[\\d]+\\/(\\d+(\\.\\d+)?)/i)\n      };\n    } else if (/(web|hpw)os/i.test(ua)) {\n      result = {\n        name: 'WebOS',\n        webos: t,\n        version: versionIdentifier || getFirstMatch(/w(?:eb)?osbrowser\\/(\\d+(\\.\\d+)?)/i)\n      };\n      /touchpad\\//i.test(ua) && (result.touchpad = t);\n    } else if (/bada/i.test(ua)) {\n      result = {\n        name: 'Bada',\n        bada: t,\n        version: getFirstMatch(/dolfin\\/(\\d+(\\.\\d+)?)/i)\n      };\n    } else if (/tizen/i.test(ua)) {\n      result = {\n        name: 'Tizen',\n        tizen: t,\n        version: getFirstMatch(/(?:tizen\\s?)?browser\\/(\\d+(\\.\\d+)?)/i) || versionIdentifier\n      };\n    } else if (/safari/i.test(ua)) {\n      result = {\n        name: 'Safari',\n        safari: t,\n        version: versionIdentifier\n      };\n    } else {\n      result = {\n        name: getFirstMatch(/^(.*)\\/(.*) /),\n        version: getSecondMatch(/^(.*)\\/(.*) /)\n      };\n    } // set webkit or gecko flag for browsers based on these engines\n\n\n    if (!result.msedge && /(apple)?webkit/i.test(ua)) {\n      result.name = result.name || \"Webkit\";\n      result.webkit = t;\n\n      if (!result.version && versionIdentifier) {\n        result.version = versionIdentifier;\n      }\n    } else if (!result.opera && /gecko\\//i.test(ua)) {\n      result.name = result.name || \"Gecko\";\n      result.gecko = t;\n      result.version = result.version || getFirstMatch(/gecko\\/(\\d+(\\.\\d+)?)/i);\n    } // set OS flags for platforms that have multiple browsers\n\n\n    if (!result.msedge && (android || result.silk)) {\n      result.android = t;\n    } else if (iosdevice) {\n      result[iosdevice] = t;\n      result.ios = t;\n    } // OS version extraction\n\n\n    var osVersion = '';\n\n    if (result.windowsphone) {\n      osVersion = getFirstMatch(/windows phone (?:os)?\\s?(\\d+(\\.\\d+)*)/i);\n    } else if (iosdevice) {\n      osVersion = getFirstMatch(/os (\\d+([_\\s]\\d+)*) like mac os x/i);\n      osVersion = osVersion.replace(/[_\\s]/g, '.');\n    } else if (android) {\n      osVersion = getFirstMatch(/android[ \\/-](\\d+(\\.\\d+)*)/i);\n    } else if (result.webos) {\n      osVersion = getFirstMatch(/(?:web|hpw)os\\/(\\d+(\\.\\d+)*)/i);\n    } else if (result.blackberry) {\n      osVersion = getFirstMatch(/rim\\stablet\\sos\\s(\\d+(\\.\\d+)*)/i);\n    } else if (result.bada) {\n      osVersion = getFirstMatch(/bada\\/(\\d+(\\.\\d+)*)/i);\n    } else if (result.tizen) {\n      osVersion = getFirstMatch(/tizen[\\/\\s](\\d+(\\.\\d+)*)/i);\n    }\n\n    if (osVersion) {\n      result.osversion = osVersion;\n    } // device type extraction\n\n\n    var osMajorVersion = osVersion.split('.')[0];\n\n    if (tablet || iosdevice == 'ipad' || android && (osMajorVersion == 3 || osMajorVersion == 4 && !mobile) || result.silk) {\n      result.tablet = t;\n    } else if (mobile || iosdevice == 'iphone' || iosdevice == 'ipod' || android || result.blackberry || result.webos || result.bada) {\n      result.mobile = t;\n    } // Graded Browser Support\n    // http://developer.yahoo.com/yui/articles/gbs\n\n\n    if (result.msedge || result.msie && result.version >= 10 || result.chrome && result.version >= 20 || result.firefox && result.version >= 20.0 || result.safari && result.version >= 6 || result.opera && result.version >= 10.0 || result.ios && result.osversion && result.osversion.split(\".\")[0] >= 6 || result.blackberry && result.version >= 10.1) {\n      result.a = t;\n    } else if (result.msie && result.version < 10 || result.chrome && result.version < 20 || result.firefox && result.version < 20.0 || result.safari && result.version < 6 || result.opera && result.version < 10.0 || result.ios && result.osversion && result.osversion.split(\".\")[0] < 6) {\n      result.c = t;\n    } else result.x = t;\n\n    return result;\n  }\n\n  var bowser = detect(typeof navigator !== 'undefined' ? navigator.userAgent : '');\n\n  bowser.test = function (browserList) {\n    for (var i = 0; i < browserList.length; ++i) {\n      var browserItem = browserList[i];\n\n      if (typeof browserItem === 'string') {\n        if (browserItem in bowser) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  };\n  /*\n   * Set our detect method to the main bowser object so we can\n   * reuse it to test other user agents.\n   * This is needed to implement future tests.\n   */\n\n\n  bowser._detect = detect;\n  return bowser;\n});"

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./node_modules/babel-loader/lib/index.js?!./assets/js/jquery-2.1.4.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/raw-loader!./node_modules/babel-loader/lib??ref--4-0!./assets/js/jquery-2.1.4.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*!\n * jQuery JavaScript Library v2.1.4\n * http://jquery.com/\n *\n * Includes Sizzle.js\n * http://sizzlejs.com/\n *\n * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2015-04-28T16:01Z\n */\n(function (global, factory) {\n  if ((typeof module === \"undefined\" ? \"undefined\" : _typeof(module)) === \"object\" && _typeof(module.exports) === \"object\") {\n    // For CommonJS and CommonJS-like environments where a proper `window`\n    // is present, execute the factory and get jQuery.\n    // For environments that do not have a `window` with a `document`\n    // (such as Node.js), expose a factory as module.exports.\n    // This accentuates the need for the creation of a real `window`.\n    // e.g. var jQuery = require(\"jquery\")(window);\n    // See ticket #14549 for more info.\n    module.exports = global.document ? factory(global, true) : function (w) {\n      if (!w.document) {\n        throw new Error(\"jQuery requires a window with a document\");\n      }\n\n      return factory(w);\n    };\n  } else {\n    factory(global);\n  } // Pass this if window is not defined yet\n\n})(typeof window !== \"undefined\" ? window : this, function (window, noGlobal) {\n  // Support: Firefox 18+\n  // Can't be in strict mode, several libs including ASP.NET trace\n  // the stack via arguments.caller.callee and Firefox dies if\n  // you try to trace through \"use strict\" call chains. (#13335)\n  //\n  var arr = [];\n  var _slice = arr.slice;\n  var concat = arr.concat;\n  var push = arr.push;\n  var indexOf = arr.indexOf;\n  var class2type = {};\n  var toString = class2type.toString;\n  var hasOwn = class2type.hasOwnProperty;\n  var support = {};\n\n  var // Use the correct document accordingly with window argument (sandbox)\n  document = window.document,\n      version = \"2.1.4\",\n      // Define a local copy of jQuery\n  jQuery = function jQuery(selector, context) {\n    // The jQuery object is actually just the init constructor 'enhanced'\n    // Need init if jQuery is called (just allow error to be thrown if not included)\n    return new jQuery.fn.init(selector, context);\n  },\n      // Support: Android<4.1\n  // Make sure we trim BOM and NBSP\n  rtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,\n      // Matches dashed string for camelizing\n  rmsPrefix = /^-ms-/,\n      rdashAlpha = /-([\\da-z])/gi,\n      // Used by jQuery.camelCase as callback to replace()\n  fcamelCase = function fcamelCase(all, letter) {\n    return letter.toUpperCase();\n  };\n\n  jQuery.fn = jQuery.prototype = {\n    // The current version of jQuery being used\n    jquery: version,\n    constructor: jQuery,\n    // Start with an empty selector\n    selector: \"\",\n    // The default length of a jQuery object is 0\n    length: 0,\n    toArray: function toArray() {\n      return _slice.call(this);\n    },\n    // Get the Nth element in the matched element set OR\n    // Get the whole matched element set as a clean array\n    get: function get(num) {\n      return num != null ? // Return just the one element from the set\n      num < 0 ? this[num + this.length] : this[num] : // Return all the elements in a clean array\n      _slice.call(this);\n    },\n    // Take an array of elements and push it onto the stack\n    // (returning the new matched element set)\n    pushStack: function pushStack(elems) {\n      // Build a new jQuery matched element set\n      var ret = jQuery.merge(this.constructor(), elems); // Add the old object onto the stack (as a reference)\n\n      ret.prevObject = this;\n      ret.context = this.context; // Return the newly-formed element set\n\n      return ret;\n    },\n    // Execute a callback for every element in the matched set.\n    // (You can seed the arguments with an array of args, but this is\n    // only used internally.)\n    each: function each(callback, args) {\n      return jQuery.each(this, callback, args);\n    },\n    map: function map(callback) {\n      return this.pushStack(jQuery.map(this, function (elem, i) {\n        return callback.call(elem, i, elem);\n      }));\n    },\n    slice: function slice() {\n      return this.pushStack(_slice.apply(this, arguments));\n    },\n    first: function first() {\n      return this.eq(0);\n    },\n    last: function last() {\n      return this.eq(-1);\n    },\n    eq: function eq(i) {\n      var len = this.length,\n          j = +i + (i < 0 ? len : 0);\n      return this.pushStack(j >= 0 && j < len ? [this[j]] : []);\n    },\n    end: function end() {\n      return this.prevObject || this.constructor(null);\n    },\n    // For internal use only.\n    // Behaves like an Array's method, not like a jQuery method.\n    push: push,\n    sort: arr.sort,\n    splice: arr.splice\n  };\n\n  jQuery.extend = jQuery.fn.extend = function () {\n    var options,\n        name,\n        src,\n        copy,\n        copyIsArray,\n        clone,\n        target = arguments[0] || {},\n        i = 1,\n        length = arguments.length,\n        deep = false; // Handle a deep copy situation\n\n    if (typeof target === \"boolean\") {\n      deep = target; // Skip the boolean and the target\n\n      target = arguments[i] || {};\n      i++;\n    } // Handle case when target is a string or something (possible in deep copy)\n\n\n    if (_typeof(target) !== \"object\" && !jQuery.isFunction(target)) {\n      target = {};\n    } // Extend jQuery itself if only one argument is passed\n\n\n    if (i === length) {\n      target = this;\n      i--;\n    }\n\n    for (; i < length; i++) {\n      // Only deal with non-null/undefined values\n      if ((options = arguments[i]) != null) {\n        // Extend the base object\n        for (name in options) {\n          src = target[name];\n          copy = options[name]; // Prevent never-ending loop\n\n          if (target === copy) {\n            continue;\n          } // Recurse if we're merging plain objects or arrays\n\n\n          if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {\n            if (copyIsArray) {\n              copyIsArray = false;\n              clone = src && jQuery.isArray(src) ? src : [];\n            } else {\n              clone = src && jQuery.isPlainObject(src) ? src : {};\n            } // Never move original objects, clone them\n\n\n            target[name] = jQuery.extend(deep, clone, copy); // Don't bring in undefined values\n          } else if (copy !== undefined) {\n            target[name] = copy;\n          }\n        }\n      }\n    } // Return the modified object\n\n\n    return target;\n  };\n\n  jQuery.extend({\n    // Unique for each copy of jQuery on the page\n    expando: \"jQuery\" + (version + Math.random()).replace(/\\D/g, \"\"),\n    // Assume jQuery is ready without the ready module\n    isReady: true,\n    error: function error(msg) {\n      throw new Error(msg);\n    },\n    noop: function noop() {},\n    isFunction: function isFunction(obj) {\n      return jQuery.type(obj) === \"function\";\n    },\n    isArray: Array.isArray,\n    isWindow: function isWindow(obj) {\n      return obj != null && obj === obj.window;\n    },\n    isNumeric: function isNumeric(obj) {\n      // parseFloat NaNs numeric-cast false positives (null|true|false|\"\")\n      // ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n      // subtraction forces infinities to NaN\n      // adding 1 corrects loss of precision from parseFloat (#15100)\n      return !jQuery.isArray(obj) && obj - parseFloat(obj) + 1 >= 0;\n    },\n    isPlainObject: function isPlainObject(obj) {\n      // Not plain objects:\n      // - Any object or value whose internal [[Class]] property is not \"[object Object]\"\n      // - DOM nodes\n      // - window\n      if (jQuery.type(obj) !== \"object\" || obj.nodeType || jQuery.isWindow(obj)) {\n        return false;\n      }\n\n      if (obj.constructor && !hasOwn.call(obj.constructor.prototype, \"isPrototypeOf\")) {\n        return false;\n      } // If the function hasn't returned already, we're confident that\n      // |obj| is a plain object, created by {} or constructed with new Object\n\n\n      return true;\n    },\n    isEmptyObject: function isEmptyObject(obj) {\n      var name;\n\n      for (name in obj) {\n        return false;\n      }\n\n      return true;\n    },\n    type: function type(obj) {\n      if (obj == null) {\n        return obj + \"\";\n      } // Support: Android<4.0, iOS<6 (functionish RegExp)\n\n\n      return _typeof(obj) === \"object\" || typeof obj === \"function\" ? class2type[toString.call(obj)] || \"object\" : _typeof(obj);\n    },\n    // Evaluates a script in a global context\n    globalEval: function globalEval(code) {\n      var script,\n          indirect = eval;\n      code = jQuery.trim(code);\n\n      if (code) {\n        // If the code includes a valid, prologue position\n        // strict mode pragma, execute code by injecting a\n        // script tag into the document.\n        if (code.indexOf(\"use strict\") === 1) {\n          script = document.createElement(\"script\");\n          script.text = code;\n          document.head.appendChild(script).parentNode.removeChild(script);\n        } else {\n          // Otherwise, avoid the DOM node creation, insertion\n          // and removal by using an indirect global eval\n          indirect(code);\n        }\n      }\n    },\n    // Convert dashed to camelCase; used by the css and data modules\n    // Support: IE9-11+\n    // Microsoft forgot to hump their vendor prefix (#9572)\n    camelCase: function camelCase(string) {\n      return string.replace(rmsPrefix, \"ms-\").replace(rdashAlpha, fcamelCase);\n    },\n    nodeName: function nodeName(elem, name) {\n      return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n    },\n    // args is for internal usage only\n    each: function each(obj, callback, args) {\n      var value,\n          i = 0,\n          length = obj.length,\n          isArray = isArraylike(obj);\n\n      if (args) {\n        if (isArray) {\n          for (; i < length; i++) {\n            value = callback.apply(obj[i], args);\n\n            if (value === false) {\n              break;\n            }\n          }\n        } else {\n          for (i in obj) {\n            value = callback.apply(obj[i], args);\n\n            if (value === false) {\n              break;\n            }\n          }\n        } // A special, fast, case for the most common use of each\n\n      } else {\n        if (isArray) {\n          for (; i < length; i++) {\n            value = callback.call(obj[i], i, obj[i]);\n\n            if (value === false) {\n              break;\n            }\n          }\n        } else {\n          for (i in obj) {\n            value = callback.call(obj[i], i, obj[i]);\n\n            if (value === false) {\n              break;\n            }\n          }\n        }\n      }\n\n      return obj;\n    },\n    // Support: Android<4.1\n    trim: function trim(text) {\n      return text == null ? \"\" : (text + \"\").replace(rtrim, \"\");\n    },\n    // results is for internal usage only\n    makeArray: function makeArray(arr, results) {\n      var ret = results || [];\n\n      if (arr != null) {\n        if (isArraylike(Object(arr))) {\n          jQuery.merge(ret, typeof arr === \"string\" ? [arr] : arr);\n        } else {\n          push.call(ret, arr);\n        }\n      }\n\n      return ret;\n    },\n    inArray: function inArray(elem, arr, i) {\n      return arr == null ? -1 : indexOf.call(arr, elem, i);\n    },\n    merge: function merge(first, second) {\n      var len = +second.length,\n          j = 0,\n          i = first.length;\n\n      for (; j < len; j++) {\n        first[i++] = second[j];\n      }\n\n      first.length = i;\n      return first;\n    },\n    grep: function grep(elems, callback, invert) {\n      var callbackInverse,\n          matches = [],\n          i = 0,\n          length = elems.length,\n          callbackExpect = !invert; // Go through the array, only saving the items\n      // that pass the validator function\n\n      for (; i < length; i++) {\n        callbackInverse = !callback(elems[i], i);\n\n        if (callbackInverse !== callbackExpect) {\n          matches.push(elems[i]);\n        }\n      }\n\n      return matches;\n    },\n    // arg is for internal usage only\n    map: function map(elems, callback, arg) {\n      var value,\n          i = 0,\n          length = elems.length,\n          isArray = isArraylike(elems),\n          ret = []; // Go through the array, translating each of the items to their new values\n\n      if (isArray) {\n        for (; i < length; i++) {\n          value = callback(elems[i], i, arg);\n\n          if (value != null) {\n            ret.push(value);\n          }\n        } // Go through every key on the object,\n\n      } else {\n        for (i in elems) {\n          value = callback(elems[i], i, arg);\n\n          if (value != null) {\n            ret.push(value);\n          }\n        }\n      } // Flatten any nested arrays\n\n\n      return concat.apply([], ret);\n    },\n    // A global GUID counter for objects\n    guid: 1,\n    // Bind a function to a context, optionally partially applying any\n    // arguments.\n    proxy: function proxy(fn, context) {\n      var tmp, args, proxy;\n\n      if (typeof context === \"string\") {\n        tmp = fn[context];\n        context = fn;\n        fn = tmp;\n      } // Quick check to determine if target is callable, in the spec\n      // this throws a TypeError, but we will just return undefined.\n\n\n      if (!jQuery.isFunction(fn)) {\n        return undefined;\n      } // Simulated bind\n\n\n      args = _slice.call(arguments, 2);\n\n      proxy = function proxy() {\n        return fn.apply(context || this, args.concat(_slice.call(arguments)));\n      }; // Set the guid of unique handler to the same of original handler, so it can be removed\n\n\n      proxy.guid = fn.guid = fn.guid || jQuery.guid++;\n      return proxy;\n    },\n    now: Date.now,\n    // jQuery.support is not used in Core but other projects attach their\n    // properties to it so it needs to exist.\n    support: support\n  }); // Populate the class2type map\n\n  jQuery.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"), function (i, name) {\n    class2type[\"[object \" + name + \"]\"] = name.toLowerCase();\n  });\n\n  function isArraylike(obj) {\n    // Support: iOS 8.2 (not reproducible in simulator)\n    // `in` check used to prevent JIT error (gh-2145)\n    // hasOwn isn't used here due to false negatives\n    // regarding Nodelist length in IE\n    var length = \"length\" in obj && obj.length,\n        type = jQuery.type(obj);\n\n    if (type === \"function\" || jQuery.isWindow(obj)) {\n      return false;\n    }\n\n    if (obj.nodeType === 1 && length) {\n      return true;\n    }\n\n    return type === \"array\" || length === 0 || typeof length === \"number\" && length > 0 && length - 1 in obj;\n  }\n\n  var Sizzle =\n  /*!\n   * Sizzle CSS Selector Engine v2.2.0-pre\n   * http://sizzlejs.com/\n   *\n   * Copyright 2008, 2014 jQuery Foundation, Inc. and other contributors\n   * Released under the MIT license\n   * http://jquery.org/license\n   *\n   * Date: 2014-12-16\n   */\n  function (window) {\n    var i,\n        support,\n        Expr,\n        getText,\n        isXML,\n        tokenize,\n        compile,\n        select,\n        outermostContext,\n        sortInput,\n        hasDuplicate,\n        // Local document vars\n    setDocument,\n        document,\n        docElem,\n        documentIsHTML,\n        rbuggyQSA,\n        rbuggyMatches,\n        matches,\n        contains,\n        // Instance-specific data\n    expando = \"sizzle\" + 1 * new Date(),\n        preferredDoc = window.document,\n        dirruns = 0,\n        done = 0,\n        classCache = createCache(),\n        tokenCache = createCache(),\n        compilerCache = createCache(),\n        sortOrder = function sortOrder(a, b) {\n      if (a === b) {\n        hasDuplicate = true;\n      }\n\n      return 0;\n    },\n        // General-purpose constants\n    MAX_NEGATIVE = 1 << 31,\n        // Instance methods\n    hasOwn = {}.hasOwnProperty,\n        arr = [],\n        pop = arr.pop,\n        push_native = arr.push,\n        push = arr.push,\n        slice = arr.slice,\n        // Use a stripped-down indexOf as it's faster than native\n    // http://jsperf.com/thor-indexof-vs-for/5\n    indexOf = function indexOf(list, elem) {\n      var i = 0,\n          len = list.length;\n\n      for (; i < len; i++) {\n        if (list[i] === elem) {\n          return i;\n        }\n      }\n\n      return -1;\n    },\n        booleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n        // Regular expressions\n    // Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace\n    whitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n        // http://www.w3.org/TR/css3-syntax/#characters\n    characterEncoding = \"(?:\\\\\\\\.|[\\\\w-]|[^\\\\x00-\\\\xa0])+\",\n        // Loosely modeled on CSS identifier characters\n    // An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors\n    // Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n    identifier = characterEncoding.replace(\"w\", \"w#\"),\n        // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n    attributes = \"\\\\[\" + whitespace + \"*(\" + characterEncoding + \")(?:\" + whitespace + // Operator (capture 2)\n    \"*([*^$|!~]?=)\" + whitespace + // \"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\"\n    \"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" + whitespace + \"*\\\\]\",\n        pseudos = \":(\" + characterEncoding + \")(?:\\\\((\" + // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n    // 1. quoted (capture 3; capture 4 or capture 5)\n    \"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" + // 2. simple (capture 6)\n    \"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" + // 3. anything else (capture 2)\n    \".*\" + \")\\\\)|)\",\n        // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n    rwhitespace = new RegExp(whitespace + \"+\", \"g\"),\n        rtrim = new RegExp(\"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\"),\n        rcomma = new RegExp(\"^\" + whitespace + \"*,\" + whitespace + \"*\"),\n        rcombinators = new RegExp(\"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\"),\n        rattributeQuotes = new RegExp(\"=\" + whitespace + \"*([^\\\\]'\\\"]*?)\" + whitespace + \"*\\\\]\", \"g\"),\n        rpseudo = new RegExp(pseudos),\n        ridentifier = new RegExp(\"^\" + identifier + \"$\"),\n        matchExpr = {\n      \"ID\": new RegExp(\"^#(\" + characterEncoding + \")\"),\n      \"CLASS\": new RegExp(\"^\\\\.(\" + characterEncoding + \")\"),\n      \"TAG\": new RegExp(\"^(\" + characterEncoding.replace(\"w\", \"w*\") + \")\"),\n      \"ATTR\": new RegExp(\"^\" + attributes),\n      \"PSEUDO\": new RegExp(\"^\" + pseudos),\n      \"CHILD\": new RegExp(\"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace + \"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace + \"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\"),\n      \"bool\": new RegExp(\"^(?:\" + booleans + \")$\", \"i\"),\n      // For use in libraries implementing .is()\n      // We use this for POS matching in `select`\n      \"needsContext\": new RegExp(\"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" + whitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\")\n    },\n        rinputs = /^(?:input|select|textarea|button)$/i,\n        rheader = /^h\\d$/i,\n        rnative = /^[^{]+\\{\\s*\\[native \\w/,\n        // Easily-parseable/retrievable ID or TAG or CLASS selectors\n    rquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n        rsibling = /[+~]/,\n        rescape = /'|\\\\/g,\n        // CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n    runescape = new RegExp(\"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\"),\n        funescape = function funescape(_, escaped, escapedWhitespace) {\n      var high = \"0x\" + escaped - 0x10000; // NaN means non-codepoint\n      // Support: Firefox<24\n      // Workaround erroneous numeric interpretation of +\"0x\"\n\n      return high !== high || escapedWhitespace ? escaped : high < 0 ? // BMP codepoint\n      String.fromCharCode(high + 0x10000) : // Supplemental Plane codepoint (surrogate pair)\n      String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);\n    },\n        // Used for iframes\n    // See setDocument()\n    // Removing the function wrapper causes a \"Permission Denied\"\n    // error in IE\n    unloadHandler = function unloadHandler() {\n      setDocument();\n    }; // Optimize for push.apply( _, NodeList )\n\n\n    try {\n      push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes); // Support: Android<4.0\n      // Detect silently failing push.apply\n\n      arr[preferredDoc.childNodes.length].nodeType;\n    } catch (e) {\n      push = {\n        apply: arr.length ? // Leverage slice if possible\n        function (target, els) {\n          push_native.apply(target, slice.call(els));\n        } : // Support: IE<9\n        // Otherwise append directly\n        function (target, els) {\n          var j = target.length,\n              i = 0; // Can't trust NodeList.length\n\n          while (target[j++] = els[i++]) {}\n\n          target.length = j - 1;\n        }\n      };\n    }\n\n    function Sizzle(selector, context, results, seed) {\n      var match, elem, m, nodeType, // QSA vars\n      i, groups, old, nid, newContext, newSelector;\n\n      if ((context ? context.ownerDocument || context : preferredDoc) !== document) {\n        setDocument(context);\n      }\n\n      context = context || document;\n      results = results || [];\n      nodeType = context.nodeType;\n\n      if (typeof selector !== \"string\" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {\n        return results;\n      }\n\n      if (!seed && documentIsHTML) {\n        // Try to shortcut find operations when possible (e.g., not under DocumentFragment)\n        if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {\n          // Speed-up: Sizzle(\"#ID\")\n          if (m = match[1]) {\n            if (nodeType === 9) {\n              elem = context.getElementById(m); // Check parentNode to catch when Blackberry 4.6 returns\n              // nodes that are no longer in the document (jQuery #6963)\n\n              if (elem && elem.parentNode) {\n                // Handle the case where IE, Opera, and Webkit return items\n                // by name instead of ID\n                if (elem.id === m) {\n                  results.push(elem);\n                  return results;\n                }\n              } else {\n                return results;\n              }\n            } else {\n              // Context is not a document\n              if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) && contains(context, elem) && elem.id === m) {\n                results.push(elem);\n                return results;\n              }\n            } // Speed-up: Sizzle(\"TAG\")\n\n          } else if (match[2]) {\n            push.apply(results, context.getElementsByTagName(selector));\n            return results; // Speed-up: Sizzle(\".CLASS\")\n          } else if ((m = match[3]) && support.getElementsByClassName) {\n            push.apply(results, context.getElementsByClassName(m));\n            return results;\n          }\n        } // QSA path\n\n\n        if (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {\n          nid = old = expando;\n          newContext = context;\n          newSelector = nodeType !== 1 && selector; // qSA works strangely on Element-rooted queries\n          // We can work around this by specifying an extra ID on the root\n          // and working up from there (Thanks to Andrew Dupont for the technique)\n          // IE 8 doesn't work on object elements\n\n          if (nodeType === 1 && context.nodeName.toLowerCase() !== \"object\") {\n            groups = tokenize(selector);\n\n            if (old = context.getAttribute(\"id\")) {\n              nid = old.replace(rescape, \"\\\\$&\");\n            } else {\n              context.setAttribute(\"id\", nid);\n            }\n\n            nid = \"[id='\" + nid + \"'] \";\n            i = groups.length;\n\n            while (i--) {\n              groups[i] = nid + toSelector(groups[i]);\n            }\n\n            newContext = rsibling.test(selector) && testContext(context.parentNode) || context;\n            newSelector = groups.join(\",\");\n          }\n\n          if (newSelector) {\n            try {\n              push.apply(results, newContext.querySelectorAll(newSelector));\n              return results;\n            } catch (qsaError) {} finally {\n              if (!old) {\n                context.removeAttribute(\"id\");\n              }\n            }\n          }\n        }\n      } // All others\n\n\n      return select(selector.replace(rtrim, \"$1\"), context, results, seed);\n    }\n    /**\n     * Create key-value caches of limited size\n     * @returns {Function(string, Object)} Returns the Object data after storing it on itself with\n     *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n     *\tdeleting the oldest entry\n     */\n\n\n    function createCache() {\n      var keys = [];\n\n      function cache(key, value) {\n        // Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n        if (keys.push(key + \" \") > Expr.cacheLength) {\n          // Only keep the most recent entries\n          delete cache[keys.shift()];\n        }\n\n        return cache[key + \" \"] = value;\n      }\n\n      return cache;\n    }\n    /**\n     * Mark a function for special use by Sizzle\n     * @param {Function} fn The function to mark\n     */\n\n\n    function markFunction(fn) {\n      fn[expando] = true;\n      return fn;\n    }\n    /**\n     * Support testing using an element\n     * @param {Function} fn Passed the created div and expects a boolean result\n     */\n\n\n    function assert(fn) {\n      var div = document.createElement(\"div\");\n\n      try {\n        return !!fn(div);\n      } catch (e) {\n        return false;\n      } finally {\n        // Remove from its parent by default\n        if (div.parentNode) {\n          div.parentNode.removeChild(div);\n        } // release memory in IE\n\n\n        div = null;\n      }\n    }\n    /**\n     * Adds the same handler for all of the specified attrs\n     * @param {String} attrs Pipe-separated list of attributes\n     * @param {Function} handler The method that will be applied\n     */\n\n\n    function addHandle(attrs, handler) {\n      var arr = attrs.split(\"|\"),\n          i = attrs.length;\n\n      while (i--) {\n        Expr.attrHandle[arr[i]] = handler;\n      }\n    }\n    /**\n     * Checks document order of two siblings\n     * @param {Element} a\n     * @param {Element} b\n     * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n     */\n\n\n    function siblingCheck(a, b) {\n      var cur = b && a,\n          diff = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE); // Use IE sourceIndex if available on both nodes\n\n      if (diff) {\n        return diff;\n      } // Check if b follows a\n\n\n      if (cur) {\n        while (cur = cur.nextSibling) {\n          if (cur === b) {\n            return -1;\n          }\n        }\n      }\n\n      return a ? 1 : -1;\n    }\n    /**\n     * Returns a function to use in pseudos for input types\n     * @param {String} type\n     */\n\n\n    function createInputPseudo(type) {\n      return function (elem) {\n        var name = elem.nodeName.toLowerCase();\n        return name === \"input\" && elem.type === type;\n      };\n    }\n    /**\n     * Returns a function to use in pseudos for buttons\n     * @param {String} type\n     */\n\n\n    function createButtonPseudo(type) {\n      return function (elem) {\n        var name = elem.nodeName.toLowerCase();\n        return (name === \"input\" || name === \"button\") && elem.type === type;\n      };\n    }\n    /**\n     * Returns a function to use in pseudos for positionals\n     * @param {Function} fn\n     */\n\n\n    function createPositionalPseudo(fn) {\n      return markFunction(function (argument) {\n        argument = +argument;\n        return markFunction(function (seed, matches) {\n          var j,\n              matchIndexes = fn([], seed.length, argument),\n              i = matchIndexes.length; // Match elements found at the specified indexes\n\n          while (i--) {\n            if (seed[j = matchIndexes[i]]) {\n              seed[j] = !(matches[j] = seed[j]);\n            }\n          }\n        });\n      });\n    }\n    /**\n     * Checks a node for validity as a Sizzle context\n     * @param {Element|Object=} context\n     * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n     */\n\n\n    function testContext(context) {\n      return context && typeof context.getElementsByTagName !== \"undefined\" && context;\n    } // Expose support vars for convenience\n\n\n    support = Sizzle.support = {};\n    /**\n     * Detects XML nodes\n     * @param {Element|Object} elem An element or a document\n     * @returns {Boolean} True iff elem is a non-HTML XML node\n     */\n\n    isXML = Sizzle.isXML = function (elem) {\n      // documentElement is verified for cases where it doesn't yet exist\n      // (such as loading iframes in IE - #4833)\n      var documentElement = elem && (elem.ownerDocument || elem).documentElement;\n      return documentElement ? documentElement.nodeName !== \"HTML\" : false;\n    };\n    /**\n     * Sets document-related variables once based on the current document\n     * @param {Element|Object} [doc] An element or document object to use to set the document\n     * @returns {Object} Returns the current document\n     */\n\n\n    setDocument = Sizzle.setDocument = function (node) {\n      var hasCompare,\n          parent,\n          doc = node ? node.ownerDocument || node : preferredDoc; // If no document and documentElement is available, return\n\n      if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {\n        return document;\n      } // Set our document\n\n\n      document = doc;\n      docElem = doc.documentElement;\n      parent = doc.defaultView; // Support: IE>8\n      // If iframe document is assigned to \"document\" variable and if iframe has been reloaded,\n      // IE will throw \"permission denied\" error when accessing \"document\" variable, see jQuery #13936\n      // IE6-8 do not support the defaultView property so parent will be undefined\n\n      if (parent && parent !== parent.top) {\n        // IE11 does not have attachEvent, so all must suffer\n        if (parent.addEventListener) {\n          parent.addEventListener(\"unload\", unloadHandler, false);\n        } else if (parent.attachEvent) {\n          parent.attachEvent(\"onunload\", unloadHandler);\n        }\n      }\n      /* Support tests\n      ---------------------------------------------------------------------- */\n\n\n      documentIsHTML = !isXML(doc);\n      /* Attributes\n      ---------------------------------------------------------------------- */\n      // Support: IE<8\n      // Verify that getAttribute really returns attributes and not properties\n      // (excepting IE8 booleans)\n\n      support.attributes = assert(function (div) {\n        div.className = \"i\";\n        return !div.getAttribute(\"className\");\n      });\n      /* getElement(s)By*\n      ---------------------------------------------------------------------- */\n      // Check if getElementsByTagName(\"*\") returns only elements\n\n      support.getElementsByTagName = assert(function (div) {\n        div.appendChild(doc.createComment(\"\"));\n        return !div.getElementsByTagName(\"*\").length;\n      }); // Support: IE<9\n\n      support.getElementsByClassName = rnative.test(doc.getElementsByClassName); // Support: IE<10\n      // Check if getElementById returns elements by name\n      // The broken getElementById methods don't pick up programatically-set names,\n      // so use a roundabout getElementsByName test\n\n      support.getById = assert(function (div) {\n        docElem.appendChild(div).id = expando;\n        return !doc.getElementsByName || !doc.getElementsByName(expando).length;\n      }); // ID find and filter\n\n      if (support.getById) {\n        Expr.find[\"ID\"] = function (id, context) {\n          if (typeof context.getElementById !== \"undefined\" && documentIsHTML) {\n            var m = context.getElementById(id); // Check parentNode to catch when Blackberry 4.6 returns\n            // nodes that are no longer in the document #6963\n\n            return m && m.parentNode ? [m] : [];\n          }\n        };\n\n        Expr.filter[\"ID\"] = function (id) {\n          var attrId = id.replace(runescape, funescape);\n          return function (elem) {\n            return elem.getAttribute(\"id\") === attrId;\n          };\n        };\n      } else {\n        // Support: IE6/7\n        // getElementById is not reliable as a find shortcut\n        delete Expr.find[\"ID\"];\n\n        Expr.filter[\"ID\"] = function (id) {\n          var attrId = id.replace(runescape, funescape);\n          return function (elem) {\n            var node = typeof elem.getAttributeNode !== \"undefined\" && elem.getAttributeNode(\"id\");\n            return node && node.value === attrId;\n          };\n        };\n      } // Tag\n\n\n      Expr.find[\"TAG\"] = support.getElementsByTagName ? function (tag, context) {\n        if (typeof context.getElementsByTagName !== \"undefined\") {\n          return context.getElementsByTagName(tag); // DocumentFragment nodes don't have gEBTN\n        } else if (support.qsa) {\n          return context.querySelectorAll(tag);\n        }\n      } : function (tag, context) {\n        var elem,\n            tmp = [],\n            i = 0,\n            // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n        results = context.getElementsByTagName(tag); // Filter out possible comments\n\n        if (tag === \"*\") {\n          while (elem = results[i++]) {\n            if (elem.nodeType === 1) {\n              tmp.push(elem);\n            }\n          }\n\n          return tmp;\n        }\n\n        return results;\n      }; // Class\n\n      Expr.find[\"CLASS\"] = support.getElementsByClassName && function (className, context) {\n        if (documentIsHTML) {\n          return context.getElementsByClassName(className);\n        }\n      };\n      /* QSA/matchesSelector\n      ---------------------------------------------------------------------- */\n      // QSA and matchesSelector support\n      // matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\n\n      rbuggyMatches = []; // qSa(:focus) reports false when true (Chrome 21)\n      // We allow this because of a bug in IE8/9 that throws an error\n      // whenever `document.activeElement` is accessed on an iframe\n      // So, we allow :focus to pass through QSA all the time to avoid the IE error\n      // See http://bugs.jquery.com/ticket/13378\n\n      rbuggyQSA = [];\n\n      if (support.qsa = rnative.test(doc.querySelectorAll)) {\n        // Build QSA regex\n        // Regex strategy adopted from Diego Perini\n        assert(function (div) {\n          // Select is set to empty string on purpose\n          // This is to test IE's treatment of not explicitly\n          // setting a boolean content attribute,\n          // since its presence should be enough\n          // http://bugs.jquery.com/ticket/12359\n          docElem.appendChild(div).innerHTML = \"<a id='\" + expando + \"'></a>\" + \"<select id='\" + expando + \"-\\f]' msallowcapture=''>\" + \"<option selected=''></option></select>\"; // Support: IE8, Opera 11-12.16\n          // Nothing should be selected when empty strings follow ^= or $= or *=\n          // The test attribute must be unknown in Opera but \"safe\" for WinRT\n          // http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n\n          if (div.querySelectorAll(\"[msallowcapture^='']\").length) {\n            rbuggyQSA.push(\"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\");\n          } // Support: IE8\n          // Boolean attributes and \"value\" are not treated correctly\n\n\n          if (!div.querySelectorAll(\"[selected]\").length) {\n            rbuggyQSA.push(\"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\");\n          } // Support: Chrome<29, Android<4.2+, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.7+\n\n\n          if (!div.querySelectorAll(\"[id~=\" + expando + \"-]\").length) {\n            rbuggyQSA.push(\"~=\");\n          } // Webkit/Opera - :checked should return selected option elements\n          // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n          // IE8 throws error here and will not see later tests\n\n\n          if (!div.querySelectorAll(\":checked\").length) {\n            rbuggyQSA.push(\":checked\");\n          } // Support: Safari 8+, iOS 8+\n          // https://bugs.webkit.org/show_bug.cgi?id=136851\n          // In-page `selector#id sibing-combinator selector` fails\n\n\n          if (!div.querySelectorAll(\"a#\" + expando + \"+*\").length) {\n            rbuggyQSA.push(\".#.+[+~]\");\n          }\n        });\n        assert(function (div) {\n          // Support: Windows 8 Native Apps\n          // The type and name attributes are restricted during .innerHTML assignment\n          var input = doc.createElement(\"input\");\n          input.setAttribute(\"type\", \"hidden\");\n          div.appendChild(input).setAttribute(\"name\", \"D\"); // Support: IE8\n          // Enforce case-sensitivity of name attribute\n\n          if (div.querySelectorAll(\"[name=d]\").length) {\n            rbuggyQSA.push(\"name\" + whitespace + \"*[*^$|!~]?=\");\n          } // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n          // IE8 throws error here and will not see later tests\n\n\n          if (!div.querySelectorAll(\":enabled\").length) {\n            rbuggyQSA.push(\":enabled\", \":disabled\");\n          } // Opera 10-11 does not throw on post-comma invalid pseudos\n\n\n          div.querySelectorAll(\"*,:x\");\n          rbuggyQSA.push(\",.*:\");\n        });\n      }\n\n      if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {\n        assert(function (div) {\n          // Check to see if it's possible to do matchesSelector\n          // on a disconnected node (IE 9)\n          support.disconnectedMatch = matches.call(div, \"div\"); // This should fail with an exception\n          // Gecko does not error, returns false instead\n\n          matches.call(div, \"[s!='']:x\");\n          rbuggyMatches.push(\"!=\", pseudos);\n        });\n      }\n\n      rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join(\"|\"));\n      rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join(\"|\"));\n      /* Contains\n      ---------------------------------------------------------------------- */\n\n      hasCompare = rnative.test(docElem.compareDocumentPosition); // Element contains another\n      // Purposefully does not implement inclusive descendent\n      // As in, an element does not contain itself\n\n      contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {\n        var adown = a.nodeType === 9 ? a.documentElement : a,\n            bup = b && b.parentNode;\n        return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));\n      } : function (a, b) {\n        if (b) {\n          while (b = b.parentNode) {\n            if (b === a) {\n              return true;\n            }\n          }\n        }\n\n        return false;\n      };\n      /* Sorting\n      ---------------------------------------------------------------------- */\n      // Document order sorting\n\n      sortOrder = hasCompare ? function (a, b) {\n        // Flag for duplicate removal\n        if (a === b) {\n          hasDuplicate = true;\n          return 0;\n        } // Sort on method existence if only one input has compareDocumentPosition\n\n\n        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\n        if (compare) {\n          return compare;\n        } // Calculate position if both inputs belong to the same document\n\n\n        compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : // Otherwise we know they are disconnected\n        1; // Disconnected nodes\n\n        if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {\n          // Choose the first element that is related to our preferred document\n          if (a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {\n            return -1;\n          }\n\n          if (b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {\n            return 1;\n          } // Maintain original order\n\n\n          return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;\n        }\n\n        return compare & 4 ? -1 : 1;\n      } : function (a, b) {\n        // Exit early if the nodes are identical\n        if (a === b) {\n          hasDuplicate = true;\n          return 0;\n        }\n\n        var cur,\n            i = 0,\n            aup = a.parentNode,\n            bup = b.parentNode,\n            ap = [a],\n            bp = [b]; // Parentless nodes are either documents or disconnected\n\n        if (!aup || !bup) {\n          return a === doc ? -1 : b === doc ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0; // If the nodes are siblings, we can do a quick check\n        } else if (aup === bup) {\n          return siblingCheck(a, b);\n        } // Otherwise we need full lists of their ancestors for comparison\n\n\n        cur = a;\n\n        while (cur = cur.parentNode) {\n          ap.unshift(cur);\n        }\n\n        cur = b;\n\n        while (cur = cur.parentNode) {\n          bp.unshift(cur);\n        } // Walk down the tree looking for a discrepancy\n\n\n        while (ap[i] === bp[i]) {\n          i++;\n        }\n\n        return i ? // Do a sibling check if the nodes have a common ancestor\n        siblingCheck(ap[i], bp[i]) : // Otherwise nodes in our document sort first\n        ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;\n      };\n      return doc;\n    };\n\n    Sizzle.matches = function (expr, elements) {\n      return Sizzle(expr, null, null, elements);\n    };\n\n    Sizzle.matchesSelector = function (elem, expr) {\n      // Set document vars if needed\n      if ((elem.ownerDocument || elem) !== document) {\n        setDocument(elem);\n      } // Make sure that attribute selectors are quoted\n\n\n      expr = expr.replace(rattributeQuotes, \"='$1']\");\n\n      if (support.matchesSelector && documentIsHTML && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {\n        try {\n          var ret = matches.call(elem, expr); // IE 9's matchesSelector returns false on disconnected nodes\n\n          if (ret || support.disconnectedMatch || // As well, disconnected nodes are said to be in a document\n          // fragment in IE 9\n          elem.document && elem.document.nodeType !== 11) {\n            return ret;\n          }\n        } catch (e) {}\n      }\n\n      return Sizzle(expr, document, null, [elem]).length > 0;\n    };\n\n    Sizzle.contains = function (context, elem) {\n      // Set document vars if needed\n      if ((context.ownerDocument || context) !== document) {\n        setDocument(context);\n      }\n\n      return contains(context, elem);\n    };\n\n    Sizzle.attr = function (elem, name) {\n      // Set document vars if needed\n      if ((elem.ownerDocument || elem) !== document) {\n        setDocument(elem);\n      }\n\n      var fn = Expr.attrHandle[name.toLowerCase()],\n          // Don't get fooled by Object.prototype properties (jQuery #13807)\n      val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;\n      return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;\n    };\n\n    Sizzle.error = function (msg) {\n      throw new Error(\"Syntax error, unrecognized expression: \" + msg);\n    };\n    /**\n     * Document sorting and removing duplicates\n     * @param {ArrayLike} results\n     */\n\n\n    Sizzle.uniqueSort = function (results) {\n      var elem,\n          duplicates = [],\n          j = 0,\n          i = 0; // Unless we *know* we can detect duplicates, assume their presence\n\n      hasDuplicate = !support.detectDuplicates;\n      sortInput = !support.sortStable && results.slice(0);\n      results.sort(sortOrder);\n\n      if (hasDuplicate) {\n        while (elem = results[i++]) {\n          if (elem === results[i]) {\n            j = duplicates.push(i);\n          }\n        }\n\n        while (j--) {\n          results.splice(duplicates[j], 1);\n        }\n      } // Clear input after sorting to release objects\n      // See https://github.com/jquery/sizzle/pull/225\n\n\n      sortInput = null;\n      return results;\n    };\n    /**\n     * Utility function for retrieving the text value of an array of DOM nodes\n     * @param {Array|Element} elem\n     */\n\n\n    getText = Sizzle.getText = function (elem) {\n      var node,\n          ret = \"\",\n          i = 0,\n          nodeType = elem.nodeType;\n\n      if (!nodeType) {\n        // If no nodeType, this is expected to be an array\n        while (node = elem[i++]) {\n          // Do not traverse comment nodes\n          ret += getText(node);\n        }\n      } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {\n        // Use textContent for elements\n        // innerText usage removed for consistency of new lines (jQuery #11153)\n        if (typeof elem.textContent === \"string\") {\n          return elem.textContent;\n        } else {\n          // Traverse its children\n          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {\n            ret += getText(elem);\n          }\n        }\n      } else if (nodeType === 3 || nodeType === 4) {\n        return elem.nodeValue;\n      } // Do not include comment or processing instruction nodes\n\n\n      return ret;\n    };\n\n    Expr = Sizzle.selectors = {\n      // Can be adjusted by the user\n      cacheLength: 50,\n      createPseudo: markFunction,\n      match: matchExpr,\n      attrHandle: {},\n      find: {},\n      relative: {\n        \">\": {\n          dir: \"parentNode\",\n          first: true\n        },\n        \" \": {\n          dir: \"parentNode\"\n        },\n        \"+\": {\n          dir: \"previousSibling\",\n          first: true\n        },\n        \"~\": {\n          dir: \"previousSibling\"\n        }\n      },\n      preFilter: {\n        \"ATTR\": function ATTR(match) {\n          match[1] = match[1].replace(runescape, funescape); // Move the given value to match[3] whether quoted or unquoted\n\n          match[3] = (match[3] || match[4] || match[5] || \"\").replace(runescape, funescape);\n\n          if (match[2] === \"~=\") {\n            match[3] = \" \" + match[3] + \" \";\n          }\n\n          return match.slice(0, 4);\n        },\n        \"CHILD\": function CHILD(match) {\n          /* matches from matchExpr[\"CHILD\"]\n          \t1 type (only|nth|...)\n          \t2 what (child|of-type)\n          \t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n          \t4 xn-component of xn+y argument ([+-]?\\d*n|)\n          \t5 sign of xn-component\n          \t6 x of xn-component\n          \t7 sign of y-component\n          \t8 y of y-component\n          */\n          match[1] = match[1].toLowerCase();\n\n          if (match[1].slice(0, 3) === \"nth\") {\n            // nth-* requires argument\n            if (!match[3]) {\n              Sizzle.error(match[0]);\n            } // numeric x and y parameters for Expr.filter.CHILD\n            // remember that false/true cast respectively to 0/1\n\n\n            match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === \"even\" || match[3] === \"odd\"));\n            match[5] = +(match[7] + match[8] || match[3] === \"odd\"); // other types prohibit arguments\n          } else if (match[3]) {\n            Sizzle.error(match[0]);\n          }\n\n          return match;\n        },\n        \"PSEUDO\": function PSEUDO(match) {\n          var excess,\n              unquoted = !match[6] && match[2];\n\n          if (matchExpr[\"CHILD\"].test(match[0])) {\n            return null;\n          } // Accept quoted arguments as-is\n\n\n          if (match[3]) {\n            match[2] = match[4] || match[5] || \"\"; // Strip excess characters from unquoted arguments\n          } else if (unquoted && rpseudo.test(unquoted) && ( // Get excess from tokenize (recursively)\n          excess = tokenize(unquoted, true)) && ( // advance to the next closing parenthesis\n          excess = unquoted.indexOf(\")\", unquoted.length - excess) - unquoted.length)) {\n            // excess is a negative index\n            match[0] = match[0].slice(0, excess);\n            match[2] = unquoted.slice(0, excess);\n          } // Return only captures needed by the pseudo filter method (type and argument)\n\n\n          return match.slice(0, 3);\n        }\n      },\n      filter: {\n        \"TAG\": function TAG(nodeNameSelector) {\n          var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();\n          return nodeNameSelector === \"*\" ? function () {\n            return true;\n          } : function (elem) {\n            return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n          };\n        },\n        \"CLASS\": function CLASS(className) {\n          var pattern = classCache[className + \" \"];\n          return pattern || (pattern = new RegExp(\"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\")) && classCache(className, function (elem) {\n            return pattern.test(typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== \"undefined\" && elem.getAttribute(\"class\") || \"\");\n          });\n        },\n        \"ATTR\": function ATTR(name, operator, check) {\n          return function (elem) {\n            var result = Sizzle.attr(elem, name);\n\n            if (result == null) {\n              return operator === \"!=\";\n            }\n\n            if (!operator) {\n              return true;\n            }\n\n            result += \"\";\n            return operator === \"=\" ? result === check : operator === \"!=\" ? result !== check : operator === \"^=\" ? check && result.indexOf(check) === 0 : operator === \"*=\" ? check && result.indexOf(check) > -1 : operator === \"$=\" ? check && result.slice(-check.length) === check : operator === \"~=\" ? (\" \" + result.replace(rwhitespace, \" \") + \" \").indexOf(check) > -1 : operator === \"|=\" ? result === check || result.slice(0, check.length + 1) === check + \"-\" : false;\n          };\n        },\n        \"CHILD\": function CHILD(type, what, argument, first, last) {\n          var simple = type.slice(0, 3) !== \"nth\",\n              forward = type.slice(-4) !== \"last\",\n              ofType = what === \"of-type\";\n          return first === 1 && last === 0 ? // Shortcut for :nth-*(n)\n          function (elem) {\n            return !!elem.parentNode;\n          } : function (elem, context, xml) {\n            var cache,\n                outerCache,\n                node,\n                diff,\n                nodeIndex,\n                start,\n                dir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n                parent = elem.parentNode,\n                name = ofType && elem.nodeName.toLowerCase(),\n                useCache = !xml && !ofType;\n\n            if (parent) {\n              // :(first|last|only)-(child|of-type)\n              if (simple) {\n                while (dir) {\n                  node = elem;\n\n                  while (node = node[dir]) {\n                    if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {\n                      return false;\n                    }\n                  } // Reverse direction for :only-* (if we haven't yet done so)\n\n\n                  start = dir = type === \"only\" && !start && \"nextSibling\";\n                }\n\n                return true;\n              }\n\n              start = [forward ? parent.firstChild : parent.lastChild]; // non-xml :nth-child(...) stores cache data on `parent`\n\n              if (forward && useCache) {\n                // Seek `elem` from a previously-cached index\n                outerCache = parent[expando] || (parent[expando] = {});\n                cache = outerCache[type] || [];\n                nodeIndex = cache[0] === dirruns && cache[1];\n                diff = cache[0] === dirruns && cache[2];\n                node = nodeIndex && parent.childNodes[nodeIndex];\n\n                while (node = ++nodeIndex && node && node[dir] || ( // Fallback to seeking `elem` from the start\n                diff = nodeIndex = 0) || start.pop()) {\n                  // When found, cache indexes on `parent` and break\n                  if (node.nodeType === 1 && ++diff && node === elem) {\n                    outerCache[type] = [dirruns, nodeIndex, diff];\n                    break;\n                  }\n                } // Use previously-cached element index if available\n\n              } else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type]) && cache[0] === dirruns) {\n                diff = cache[1]; // xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)\n              } else {\n                // Use the same loop as above to seek `elem` from the start\n                while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {\n                  if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {\n                    // Cache the index of each encountered element\n                    if (useCache) {\n                      (node[expando] || (node[expando] = {}))[type] = [dirruns, diff];\n                    }\n\n                    if (node === elem) {\n                      break;\n                    }\n                  }\n                }\n              } // Incorporate the offset, then check against cycle size\n\n\n              diff -= last;\n              return diff === first || diff % first === 0 && diff / first >= 0;\n            }\n          };\n        },\n        \"PSEUDO\": function PSEUDO(pseudo, argument) {\n          // pseudo-class names are case-insensitive\n          // http://www.w3.org/TR/selectors/#pseudo-classes\n          // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n          // Remember that setFilters inherits from pseudos\n          var args,\n              fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error(\"unsupported pseudo: \" + pseudo); // The user may use createPseudo to indicate that\n          // arguments are needed to create the filter function\n          // just as Sizzle does\n\n          if (fn[expando]) {\n            return fn(argument);\n          } // But maintain support for old signatures\n\n\n          if (fn.length > 1) {\n            args = [pseudo, pseudo, \"\", argument];\n            return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {\n              var idx,\n                  matched = fn(seed, argument),\n                  i = matched.length;\n\n              while (i--) {\n                idx = indexOf(seed, matched[i]);\n                seed[idx] = !(matches[idx] = matched[i]);\n              }\n            }) : function (elem) {\n              return fn(elem, 0, args);\n            };\n          }\n\n          return fn;\n        }\n      },\n      pseudos: {\n        // Potentially complex pseudos\n        \"not\": markFunction(function (selector) {\n          // Trim the selector passed to compile\n          // to avoid treating leading and trailing\n          // spaces as combinators\n          var input = [],\n              results = [],\n              matcher = compile(selector.replace(rtrim, \"$1\"));\n          return matcher[expando] ? markFunction(function (seed, matches, context, xml) {\n            var elem,\n                unmatched = matcher(seed, null, xml, []),\n                i = seed.length; // Match elements unmatched by `matcher`\n\n            while (i--) {\n              if (elem = unmatched[i]) {\n                seed[i] = !(matches[i] = elem);\n              }\n            }\n          }) : function (elem, context, xml) {\n            input[0] = elem;\n            matcher(input, null, xml, results); // Don't keep the element (issue #299)\n\n            input[0] = null;\n            return !results.pop();\n          };\n        }),\n        \"has\": markFunction(function (selector) {\n          return function (elem) {\n            return Sizzle(selector, elem).length > 0;\n          };\n        }),\n        \"contains\": markFunction(function (text) {\n          text = text.replace(runescape, funescape);\n          return function (elem) {\n            return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;\n          };\n        }),\n        // \"Whether an element is represented by a :lang() selector\n        // is based solely on the element's language value\n        // being equal to the identifier C,\n        // or beginning with the identifier C immediately followed by \"-\".\n        // The matching of C against the element's language value is performed case-insensitively.\n        // The identifier C does not have to be a valid language name.\"\n        // http://www.w3.org/TR/selectors/#lang-pseudo\n        \"lang\": markFunction(function (lang) {\n          // lang value must be a valid identifier\n          if (!ridentifier.test(lang || \"\")) {\n            Sizzle.error(\"unsupported lang: \" + lang);\n          }\n\n          lang = lang.replace(runescape, funescape).toLowerCase();\n          return function (elem) {\n            var elemLang;\n\n            do {\n              if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) {\n                elemLang = elemLang.toLowerCase();\n                return elemLang === lang || elemLang.indexOf(lang + \"-\") === 0;\n              }\n            } while ((elem = elem.parentNode) && elem.nodeType === 1);\n\n            return false;\n          };\n        }),\n        // Miscellaneous\n        \"target\": function target(elem) {\n          var hash = window.location && window.location.hash;\n          return hash && hash.slice(1) === elem.id;\n        },\n        \"root\": function root(elem) {\n          return elem === docElem;\n        },\n        \"focus\": function focus(elem) {\n          return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n        },\n        // Boolean properties\n        \"enabled\": function enabled(elem) {\n          return elem.disabled === false;\n        },\n        \"disabled\": function disabled(elem) {\n          return elem.disabled === true;\n        },\n        \"checked\": function checked(elem) {\n          // In CSS3, :checked should return both checked and selected elements\n          // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n          var nodeName = elem.nodeName.toLowerCase();\n          return nodeName === \"input\" && !!elem.checked || nodeName === \"option\" && !!elem.selected;\n        },\n        \"selected\": function selected(elem) {\n          // Accessing this property makes selected-by-default\n          // options in Safari work properly\n          if (elem.parentNode) {\n            elem.parentNode.selectedIndex;\n          }\n\n          return elem.selected === true;\n        },\n        // Contents\n        \"empty\": function empty(elem) {\n          // http://www.w3.org/TR/selectors/#empty-pseudo\n          // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n          //   but not by others (comment: 8; processing instruction: 7; etc.)\n          // nodeType < 6 works because attributes (2) do not appear as children\n          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {\n            if (elem.nodeType < 6) {\n              return false;\n            }\n          }\n\n          return true;\n        },\n        \"parent\": function parent(elem) {\n          return !Expr.pseudos[\"empty\"](elem);\n        },\n        // Element/input types\n        \"header\": function header(elem) {\n          return rheader.test(elem.nodeName);\n        },\n        \"input\": function input(elem) {\n          return rinputs.test(elem.nodeName);\n        },\n        \"button\": function button(elem) {\n          var name = elem.nodeName.toLowerCase();\n          return name === \"input\" && elem.type === \"button\" || name === \"button\";\n        },\n        \"text\": function text(elem) {\n          var attr;\n          return elem.nodeName.toLowerCase() === \"input\" && elem.type === \"text\" && ( // Support: IE<8\n          // New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n          (attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === \"text\");\n        },\n        // Position-in-collection\n        \"first\": createPositionalPseudo(function () {\n          return [0];\n        }),\n        \"last\": createPositionalPseudo(function (matchIndexes, length) {\n          return [length - 1];\n        }),\n        \"eq\": createPositionalPseudo(function (matchIndexes, length, argument) {\n          return [argument < 0 ? argument + length : argument];\n        }),\n        \"even\": createPositionalPseudo(function (matchIndexes, length) {\n          var i = 0;\n\n          for (; i < length; i += 2) {\n            matchIndexes.push(i);\n          }\n\n          return matchIndexes;\n        }),\n        \"odd\": createPositionalPseudo(function (matchIndexes, length) {\n          var i = 1;\n\n          for (; i < length; i += 2) {\n            matchIndexes.push(i);\n          }\n\n          return matchIndexes;\n        }),\n        \"lt\": createPositionalPseudo(function (matchIndexes, length, argument) {\n          var i = argument < 0 ? argument + length : argument;\n\n          for (; --i >= 0;) {\n            matchIndexes.push(i);\n          }\n\n          return matchIndexes;\n        }),\n        \"gt\": createPositionalPseudo(function (matchIndexes, length, argument) {\n          var i = argument < 0 ? argument + length : argument;\n\n          for (; ++i < length;) {\n            matchIndexes.push(i);\n          }\n\n          return matchIndexes;\n        })\n      }\n    };\n    Expr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"]; // Add button/input type pseudos\n\n    for (i in {\n      radio: true,\n      checkbox: true,\n      file: true,\n      password: true,\n      image: true\n    }) {\n      Expr.pseudos[i] = createInputPseudo(i);\n    }\n\n    for (i in {\n      submit: true,\n      reset: true\n    }) {\n      Expr.pseudos[i] = createButtonPseudo(i);\n    } // Easy API for creating new setFilters\n\n\n    function setFilters() {}\n\n    setFilters.prototype = Expr.filters = Expr.pseudos;\n    Expr.setFilters = new setFilters();\n\n    tokenize = Sizzle.tokenize = function (selector, parseOnly) {\n      var matched,\n          match,\n          tokens,\n          type,\n          soFar,\n          groups,\n          preFilters,\n          cached = tokenCache[selector + \" \"];\n\n      if (cached) {\n        return parseOnly ? 0 : cached.slice(0);\n      }\n\n      soFar = selector;\n      groups = [];\n      preFilters = Expr.preFilter;\n\n      while (soFar) {\n        // Comma and first run\n        if (!matched || (match = rcomma.exec(soFar))) {\n          if (match) {\n            // Don't consume trailing commas as valid\n            soFar = soFar.slice(match[0].length) || soFar;\n          }\n\n          groups.push(tokens = []);\n        }\n\n        matched = false; // Combinators\n\n        if (match = rcombinators.exec(soFar)) {\n          matched = match.shift();\n          tokens.push({\n            value: matched,\n            // Cast descendant combinators to space\n            type: match[0].replace(rtrim, \" \")\n          });\n          soFar = soFar.slice(matched.length);\n        } // Filters\n\n\n        for (type in Expr.filter) {\n          if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {\n            matched = match.shift();\n            tokens.push({\n              value: matched,\n              type: type,\n              matches: match\n            });\n            soFar = soFar.slice(matched.length);\n          }\n        }\n\n        if (!matched) {\n          break;\n        }\n      } // Return the length of the invalid excess\n      // if we're just parsing\n      // Otherwise, throw an error or return tokens\n\n\n      return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : // Cache the tokens\n      tokenCache(selector, groups).slice(0);\n    };\n\n    function toSelector(tokens) {\n      var i = 0,\n          len = tokens.length,\n          selector = \"\";\n\n      for (; i < len; i++) {\n        selector += tokens[i].value;\n      }\n\n      return selector;\n    }\n\n    function addCombinator(matcher, combinator, base) {\n      var dir = combinator.dir,\n          checkNonElements = base && dir === \"parentNode\",\n          doneName = done++;\n      return combinator.first ? // Check against closest ancestor/preceding element\n      function (elem, context, xml) {\n        while (elem = elem[dir]) {\n          if (elem.nodeType === 1 || checkNonElements) {\n            return matcher(elem, context, xml);\n          }\n        }\n      } : // Check against all ancestor/preceding elements\n      function (elem, context, xml) {\n        var oldCache,\n            outerCache,\n            newCache = [dirruns, doneName]; // We can't set arbitrary data on XML nodes, so they don't benefit from dir caching\n\n        if (xml) {\n          while (elem = elem[dir]) {\n            if (elem.nodeType === 1 || checkNonElements) {\n              if (matcher(elem, context, xml)) {\n                return true;\n              }\n            }\n          }\n        } else {\n          while (elem = elem[dir]) {\n            if (elem.nodeType === 1 || checkNonElements) {\n              outerCache = elem[expando] || (elem[expando] = {});\n\n              if ((oldCache = outerCache[dir]) && oldCache[0] === dirruns && oldCache[1] === doneName) {\n                // Assign to newCache so results back-propagate to previous elements\n                return newCache[2] = oldCache[2];\n              } else {\n                // Reuse newcache so results back-propagate to previous elements\n                outerCache[dir] = newCache; // A match means we're done; a fail means we have to keep checking\n\n                if (newCache[2] = matcher(elem, context, xml)) {\n                  return true;\n                }\n              }\n            }\n          }\n        }\n      };\n    }\n\n    function elementMatcher(matchers) {\n      return matchers.length > 1 ? function (elem, context, xml) {\n        var i = matchers.length;\n\n        while (i--) {\n          if (!matchers[i](elem, context, xml)) {\n            return false;\n          }\n        }\n\n        return true;\n      } : matchers[0];\n    }\n\n    function multipleContexts(selector, contexts, results) {\n      var i = 0,\n          len = contexts.length;\n\n      for (; i < len; i++) {\n        Sizzle(selector, contexts[i], results);\n      }\n\n      return results;\n    }\n\n    function condense(unmatched, map, filter, context, xml) {\n      var elem,\n          newUnmatched = [],\n          i = 0,\n          len = unmatched.length,\n          mapped = map != null;\n\n      for (; i < len; i++) {\n        if (elem = unmatched[i]) {\n          if (!filter || filter(elem, context, xml)) {\n            newUnmatched.push(elem);\n\n            if (mapped) {\n              map.push(i);\n            }\n          }\n        }\n      }\n\n      return newUnmatched;\n    }\n\n    function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {\n      if (postFilter && !postFilter[expando]) {\n        postFilter = setMatcher(postFilter);\n      }\n\n      if (postFinder && !postFinder[expando]) {\n        postFinder = setMatcher(postFinder, postSelector);\n      }\n\n      return markFunction(function (seed, results, context, xml) {\n        var temp,\n            i,\n            elem,\n            preMap = [],\n            postMap = [],\n            preexisting = results.length,\n            // Get initial elements from seed or context\n        elems = seed || multipleContexts(selector || \"*\", context.nodeType ? [context] : context, []),\n            // Prefilter to get matcher input, preserving a map for seed-results synchronization\n        matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,\n            matcherOut = matcher ? // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n        postFinder || (seed ? preFilter : preexisting || postFilter) ? // ...intermediate processing is necessary\n        [] : // ...otherwise use results directly\n        results : matcherIn; // Find primary matches\n\n        if (matcher) {\n          matcher(matcherIn, matcherOut, context, xml);\n        } // Apply postFilter\n\n\n        if (postFilter) {\n          temp = condense(matcherOut, postMap);\n          postFilter(temp, [], context, xml); // Un-match failing elements by moving them back to matcherIn\n\n          i = temp.length;\n\n          while (i--) {\n            if (elem = temp[i]) {\n              matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);\n            }\n          }\n        }\n\n        if (seed) {\n          if (postFinder || preFilter) {\n            if (postFinder) {\n              // Get the final matcherOut by condensing this intermediate into postFinder contexts\n              temp = [];\n              i = matcherOut.length;\n\n              while (i--) {\n                if (elem = matcherOut[i]) {\n                  // Restore matcherIn since elem is not yet a final match\n                  temp.push(matcherIn[i] = elem);\n                }\n              }\n\n              postFinder(null, matcherOut = [], temp, xml);\n            } // Move matched elements from seed to results to keep them synchronized\n\n\n            i = matcherOut.length;\n\n            while (i--) {\n              if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {\n                seed[temp] = !(results[temp] = elem);\n              }\n            }\n          } // Add elements to results, through postFinder if defined\n\n        } else {\n          matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);\n\n          if (postFinder) {\n            postFinder(null, results, matcherOut, xml);\n          } else {\n            push.apply(results, matcherOut);\n          }\n        }\n      });\n    }\n\n    function matcherFromTokens(tokens) {\n      var checkContext,\n          matcher,\n          j,\n          len = tokens.length,\n          leadingRelative = Expr.relative[tokens[0].type],\n          implicitRelative = leadingRelative || Expr.relative[\" \"],\n          i = leadingRelative ? 1 : 0,\n          // The foundational matcher ensures that elements are reachable from top-level context(s)\n      matchContext = addCombinator(function (elem) {\n        return elem === checkContext;\n      }, implicitRelative, true),\n          matchAnyContext = addCombinator(function (elem) {\n        return indexOf(checkContext, elem) > -1;\n      }, implicitRelative, true),\n          matchers = [function (elem, context, xml) {\n        var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml)); // Avoid hanging onto element (issue #299)\n\n        checkContext = null;\n        return ret;\n      }];\n\n      for (; i < len; i++) {\n        if (matcher = Expr.relative[tokens[i].type]) {\n          matchers = [addCombinator(elementMatcher(matchers), matcher)];\n        } else {\n          matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches); // Return special upon seeing a positional matcher\n\n          if (matcher[expando]) {\n            // Find the next relative operator (if any) for proper handling\n            j = ++i;\n\n            for (; j < len; j++) {\n              if (Expr.relative[tokens[j].type]) {\n                break;\n              }\n            }\n\n            return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector( // If the preceding token was a descendant combinator, insert an implicit any-element `*`\n            tokens.slice(0, i - 1).concat({\n              value: tokens[i - 2].type === \" \" ? \"*\" : \"\"\n            })).replace(rtrim, \"$1\"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));\n          }\n\n          matchers.push(matcher);\n        }\n      }\n\n      return elementMatcher(matchers);\n    }\n\n    function matcherFromGroupMatchers(elementMatchers, setMatchers) {\n      var bySet = setMatchers.length > 0,\n          byElement = elementMatchers.length > 0,\n          superMatcher = function superMatcher(seed, context, xml, results, outermost) {\n        var elem,\n            j,\n            matcher,\n            matchedCount = 0,\n            i = \"0\",\n            unmatched = seed && [],\n            setMatched = [],\n            contextBackup = outermostContext,\n            // We must always have either seed elements or outermost context\n        elems = seed || byElement && Expr.find[\"TAG\"](\"*\", outermost),\n            // Use integer dirruns iff this is the outermost matcher\n        dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1,\n            len = elems.length;\n\n        if (outermost) {\n          outermostContext = context !== document && context;\n        } // Add elements passing elementMatchers directly to results\n        // Keep `i` a string if there are no elements so `matchedCount` will be \"00\" below\n        // Support: IE<9, Safari\n        // Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n\n\n        for (; i !== len && (elem = elems[i]) != null; i++) {\n          if (byElement && elem) {\n            j = 0;\n\n            while (matcher = elementMatchers[j++]) {\n              if (matcher(elem, context, xml)) {\n                results.push(elem);\n                break;\n              }\n            }\n\n            if (outermost) {\n              dirruns = dirrunsUnique;\n            }\n          } // Track unmatched elements for set filters\n\n\n          if (bySet) {\n            // They will have gone through all possible matchers\n            if (elem = !matcher && elem) {\n              matchedCount--;\n            } // Lengthen the array for every element, matched or not\n\n\n            if (seed) {\n              unmatched.push(elem);\n            }\n          }\n        } // Apply set filters to unmatched elements\n\n\n        matchedCount += i;\n\n        if (bySet && i !== matchedCount) {\n          j = 0;\n\n          while (matcher = setMatchers[j++]) {\n            matcher(unmatched, setMatched, context, xml);\n          }\n\n          if (seed) {\n            // Reintegrate element matches to eliminate the need for sorting\n            if (matchedCount > 0) {\n              while (i--) {\n                if (!(unmatched[i] || setMatched[i])) {\n                  setMatched[i] = pop.call(results);\n                }\n              }\n            } // Discard index placeholder values to get only actual matches\n\n\n            setMatched = condense(setMatched);\n          } // Add matches to results\n\n\n          push.apply(results, setMatched); // Seedless set matches succeeding multiple successful matchers stipulate sorting\n\n          if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {\n            Sizzle.uniqueSort(results);\n          }\n        } // Override manipulation of globals by nested matchers\n\n\n        if (outermost) {\n          dirruns = dirrunsUnique;\n          outermostContext = contextBackup;\n        }\n\n        return unmatched;\n      };\n\n      return bySet ? markFunction(superMatcher) : superMatcher;\n    }\n\n    compile = Sizzle.compile = function (selector, match\n    /* Internal Use Only */\n    ) {\n      var i,\n          setMatchers = [],\n          elementMatchers = [],\n          cached = compilerCache[selector + \" \"];\n\n      if (!cached) {\n        // Generate a function of recursive functions that can be used to check each element\n        if (!match) {\n          match = tokenize(selector);\n        }\n\n        i = match.length;\n\n        while (i--) {\n          cached = matcherFromTokens(match[i]);\n\n          if (cached[expando]) {\n            setMatchers.push(cached);\n          } else {\n            elementMatchers.push(cached);\n          }\n        } // Cache the compiled function\n\n\n        cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers)); // Save selector and tokenization\n\n        cached.selector = selector;\n      }\n\n      return cached;\n    };\n    /**\n     * A low-level selection function that works with Sizzle's compiled\n     *  selector functions\n     * @param {String|Function} selector A selector or a pre-compiled\n     *  selector function built with Sizzle.compile\n     * @param {Element} context\n     * @param {Array} [results]\n     * @param {Array} [seed] A set of elements to match against\n     */\n\n\n    select = Sizzle.select = function (selector, context, results, seed) {\n      var i,\n          tokens,\n          token,\n          type,\n          find,\n          compiled = typeof selector === \"function\" && selector,\n          match = !seed && tokenize(selector = compiled.selector || selector);\n      results = results || []; // Try to minimize operations if there is no seed and only one group\n\n      if (match.length === 1) {\n        // Take a shortcut and set the context if the root selector is an ID\n        tokens = match[0] = match[0].slice(0);\n\n        if (tokens.length > 2 && (token = tokens[0]).type === \"ID\" && support.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {\n          context = (Expr.find[\"ID\"](token.matches[0].replace(runescape, funescape), context) || [])[0];\n\n          if (!context) {\n            return results; // Precompiled matchers will still verify ancestry, so step up a level\n          } else if (compiled) {\n            context = context.parentNode;\n          }\n\n          selector = selector.slice(tokens.shift().value.length);\n        } // Fetch a seed set for right-to-left matching\n\n\n        i = matchExpr[\"needsContext\"].test(selector) ? 0 : tokens.length;\n\n        while (i--) {\n          token = tokens[i]; // Abort if we hit a combinator\n\n          if (Expr.relative[type = token.type]) {\n            break;\n          }\n\n          if (find = Expr.find[type]) {\n            // Search, expanding context for leading sibling combinators\n            if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {\n              // If seed is empty or no tokens remain, we can return early\n              tokens.splice(i, 1);\n              selector = seed.length && toSelector(tokens);\n\n              if (!selector) {\n                push.apply(results, seed);\n                return results;\n              }\n\n              break;\n            }\n          }\n        }\n      } // Compile and execute a filtering function if one is not provided\n      // Provide `match` to avoid retokenization if we modified the selector above\n\n\n      (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, rsibling.test(selector) && testContext(context.parentNode) || context);\n      return results;\n    }; // One-time assignments\n    // Sort stability\n\n\n    support.sortStable = expando.split(\"\").sort(sortOrder).join(\"\") === expando; // Support: Chrome 14-35+\n    // Always assume duplicates if they aren't passed to the comparison function\n\n    support.detectDuplicates = !!hasDuplicate; // Initialize against the default document\n\n    setDocument(); // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n    // Detached nodes confoundingly follow *each other*\n\n    support.sortDetached = assert(function (div1) {\n      // Should return 1, but returns 4 (following)\n      return div1.compareDocumentPosition(document.createElement(\"div\")) & 1;\n    }); // Support: IE<8\n    // Prevent attribute/property \"interpolation\"\n    // http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\n\n    if (!assert(function (div) {\n      div.innerHTML = \"<a href='#'></a>\";\n      return div.firstChild.getAttribute(\"href\") === \"#\";\n    })) {\n      addHandle(\"type|href|height|width\", function (elem, name, isXML) {\n        if (!isXML) {\n          return elem.getAttribute(name, name.toLowerCase() === \"type\" ? 1 : 2);\n        }\n      });\n    } // Support: IE<9\n    // Use defaultValue in place of getAttribute(\"value\")\n\n\n    if (!support.attributes || !assert(function (div) {\n      div.innerHTML = \"<input/>\";\n      div.firstChild.setAttribute(\"value\", \"\");\n      return div.firstChild.getAttribute(\"value\") === \"\";\n    })) {\n      addHandle(\"value\", function (elem, name, isXML) {\n        if (!isXML && elem.nodeName.toLowerCase() === \"input\") {\n          return elem.defaultValue;\n        }\n      });\n    } // Support: IE<9\n    // Use getAttributeNode to fetch booleans when getAttribute lies\n\n\n    if (!assert(function (div) {\n      return div.getAttribute(\"disabled\") == null;\n    })) {\n      addHandle(booleans, function (elem, name, isXML) {\n        var val;\n\n        if (!isXML) {\n          return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;\n        }\n      });\n    }\n\n    return Sizzle;\n  }(window);\n\n  jQuery.find = Sizzle;\n  jQuery.expr = Sizzle.selectors;\n  jQuery.expr[\":\"] = jQuery.expr.pseudos;\n  jQuery.unique = Sizzle.uniqueSort;\n  jQuery.text = Sizzle.getText;\n  jQuery.isXMLDoc = Sizzle.isXML;\n  jQuery.contains = Sizzle.contains;\n  var rneedsContext = jQuery.expr.match.needsContext;\n  var rsingleTag = /^<(\\w+)\\s*\\/?>(?:<\\/\\1>|)$/;\n  var risSimple = /^.[^:#\\[\\.,]*$/; // Implement the identical functionality for filter and not\n\n  function winnow(elements, qualifier, not) {\n    if (jQuery.isFunction(qualifier)) {\n      return jQuery.grep(elements, function (elem, i) {\n        /* jshint -W018 */\n        return !!qualifier.call(elem, i, elem) !== not;\n      });\n    }\n\n    if (qualifier.nodeType) {\n      return jQuery.grep(elements, function (elem) {\n        return elem === qualifier !== not;\n      });\n    }\n\n    if (typeof qualifier === \"string\") {\n      if (risSimple.test(qualifier)) {\n        return jQuery.filter(qualifier, elements, not);\n      }\n\n      qualifier = jQuery.filter(qualifier, elements);\n    }\n\n    return jQuery.grep(elements, function (elem) {\n      return indexOf.call(qualifier, elem) >= 0 !== not;\n    });\n  }\n\n  jQuery.filter = function (expr, elems, not) {\n    var elem = elems[0];\n\n    if (not) {\n      expr = \":not(\" + expr + \")\";\n    }\n\n    return elems.length === 1 && elem.nodeType === 1 ? jQuery.find.matchesSelector(elem, expr) ? [elem] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {\n      return elem.nodeType === 1;\n    }));\n  };\n\n  jQuery.fn.extend({\n    find: function find(selector) {\n      var i,\n          len = this.length,\n          ret = [],\n          self = this;\n\n      if (typeof selector !== \"string\") {\n        return this.pushStack(jQuery(selector).filter(function () {\n          for (i = 0; i < len; i++) {\n            if (jQuery.contains(self[i], this)) {\n              return true;\n            }\n          }\n        }));\n      }\n\n      for (i = 0; i < len; i++) {\n        jQuery.find(selector, self[i], ret);\n      } // Needed because $( selector, context ) becomes $( context ).find( selector )\n\n\n      ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);\n      ret.selector = this.selector ? this.selector + \" \" + selector : selector;\n      return ret;\n    },\n    filter: function filter(selector) {\n      return this.pushStack(winnow(this, selector || [], false));\n    },\n    not: function not(selector) {\n      return this.pushStack(winnow(this, selector || [], true));\n    },\n    is: function is(selector) {\n      return !!winnow(this, // If this is a positional/relative selector, check membership in the returned set\n      // so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n      typeof selector === \"string\" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;\n    }\n  }); // Initialize a jQuery object\n  // A central reference to the root jQuery(document)\n\n  var rootjQuery,\n      // A simple way to check for HTML strings\n  // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n  // Strict HTML recognition (#11290: must start with <)\n  rquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]*))$/,\n      init = jQuery.fn.init = function (selector, context) {\n    var match, elem; // HANDLE: $(\"\"), $(null), $(undefined), $(false)\n\n    if (!selector) {\n      return this;\n    } // Handle HTML strings\n\n\n    if (typeof selector === \"string\") {\n      if (selector[0] === \"<\" && selector[selector.length - 1] === \">\" && selector.length >= 3) {\n        // Assume that strings that start and end with <> are HTML and skip the regex check\n        match = [null, selector, null];\n      } else {\n        match = rquickExpr.exec(selector);\n      } // Match html or make sure no context is specified for #id\n\n\n      if (match && (match[1] || !context)) {\n        // HANDLE: $(html) -> $(array)\n        if (match[1]) {\n          context = context instanceof jQuery ? context[0] : context; // Option to run scripts is true for back-compat\n          // Intentionally let the error be thrown if parseHTML is not present\n\n          jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true)); // HANDLE: $(html, props)\n\n          if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {\n            for (match in context) {\n              // Properties of context are called as methods if possible\n              if (jQuery.isFunction(this[match])) {\n                this[match](context[match]); // ...and otherwise set as attributes\n              } else {\n                this.attr(match, context[match]);\n              }\n            }\n          }\n\n          return this; // HANDLE: $(#id)\n        } else {\n          elem = document.getElementById(match[2]); // Support: Blackberry 4.6\n          // gEBID returns nodes no longer in the document (#6963)\n\n          if (elem && elem.parentNode) {\n            // Inject the element directly into the jQuery object\n            this.length = 1;\n            this[0] = elem;\n          }\n\n          this.context = document;\n          this.selector = selector;\n          return this;\n        } // HANDLE: $(expr, $(...))\n\n      } else if (!context || context.jquery) {\n        return (context || rootjQuery).find(selector); // HANDLE: $(expr, context)\n        // (which is just equivalent to: $(context).find(expr)\n      } else {\n        return this.constructor(context).find(selector);\n      } // HANDLE: $(DOMElement)\n\n    } else if (selector.nodeType) {\n      this.context = this[0] = selector;\n      this.length = 1;\n      return this; // HANDLE: $(function)\n      // Shortcut for document ready\n    } else if (jQuery.isFunction(selector)) {\n      return typeof rootjQuery.ready !== \"undefined\" ? rootjQuery.ready(selector) : // Execute immediately if ready is not present\n      selector(jQuery);\n    }\n\n    if (selector.selector !== undefined) {\n      this.selector = selector.selector;\n      this.context = selector.context;\n    }\n\n    return jQuery.makeArray(selector, this);\n  }; // Give the init function the jQuery prototype for later instantiation\n\n\n  init.prototype = jQuery.fn; // Initialize central reference\n\n  rootjQuery = jQuery(document);\n  var rparentsprev = /^(?:parents|prev(?:Until|All))/,\n      // Methods guaranteed to produce a unique set when starting from a unique set\n  guaranteedUnique = {\n    children: true,\n    contents: true,\n    next: true,\n    prev: true\n  };\n  jQuery.extend({\n    dir: function dir(elem, _dir, until) {\n      var matched = [],\n          truncate = until !== undefined;\n\n      while ((elem = elem[_dir]) && elem.nodeType !== 9) {\n        if (elem.nodeType === 1) {\n          if (truncate && jQuery(elem).is(until)) {\n            break;\n          }\n\n          matched.push(elem);\n        }\n      }\n\n      return matched;\n    },\n    sibling: function sibling(n, elem) {\n      var matched = [];\n\n      for (; n; n = n.nextSibling) {\n        if (n.nodeType === 1 && n !== elem) {\n          matched.push(n);\n        }\n      }\n\n      return matched;\n    }\n  });\n  jQuery.fn.extend({\n    has: function has(target) {\n      var targets = jQuery(target, this),\n          l = targets.length;\n      return this.filter(function () {\n        var i = 0;\n\n        for (; i < l; i++) {\n          if (jQuery.contains(this, targets[i])) {\n            return true;\n          }\n        }\n      });\n    },\n    closest: function closest(selectors, context) {\n      var cur,\n          i = 0,\n          l = this.length,\n          matched = [],\n          pos = rneedsContext.test(selectors) || typeof selectors !== \"string\" ? jQuery(selectors, context || this.context) : 0;\n\n      for (; i < l; i++) {\n        for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {\n          // Always skip document fragments\n          if (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 : // Don't pass non-elements to Sizzle\n          cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {\n            matched.push(cur);\n            break;\n          }\n        }\n      }\n\n      return this.pushStack(matched.length > 1 ? jQuery.unique(matched) : matched);\n    },\n    // Determine the position of an element within the set\n    index: function index(elem) {\n      // No argument, return index in parent\n      if (!elem) {\n        return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;\n      } // Index in selector\n\n\n      if (typeof elem === \"string\") {\n        return indexOf.call(jQuery(elem), this[0]);\n      } // Locate the position of the desired element\n\n\n      return indexOf.call(this, // If it receives a jQuery object, the first element is used\n      elem.jquery ? elem[0] : elem);\n    },\n    add: function add(selector, context) {\n      return this.pushStack(jQuery.unique(jQuery.merge(this.get(), jQuery(selector, context))));\n    },\n    addBack: function addBack(selector) {\n      return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));\n    }\n  });\n\n  function sibling(cur, dir) {\n    while ((cur = cur[dir]) && cur.nodeType !== 1) {}\n\n    return cur;\n  }\n\n  jQuery.each({\n    parent: function parent(elem) {\n      var parent = elem.parentNode;\n      return parent && parent.nodeType !== 11 ? parent : null;\n    },\n    parents: function parents(elem) {\n      return jQuery.dir(elem, \"parentNode\");\n    },\n    parentsUntil: function parentsUntil(elem, i, until) {\n      return jQuery.dir(elem, \"parentNode\", until);\n    },\n    next: function next(elem) {\n      return sibling(elem, \"nextSibling\");\n    },\n    prev: function prev(elem) {\n      return sibling(elem, \"previousSibling\");\n    },\n    nextAll: function nextAll(elem) {\n      return jQuery.dir(elem, \"nextSibling\");\n    },\n    prevAll: function prevAll(elem) {\n      return jQuery.dir(elem, \"previousSibling\");\n    },\n    nextUntil: function nextUntil(elem, i, until) {\n      return jQuery.dir(elem, \"nextSibling\", until);\n    },\n    prevUntil: function prevUntil(elem, i, until) {\n      return jQuery.dir(elem, \"previousSibling\", until);\n    },\n    siblings: function siblings(elem) {\n      return jQuery.sibling((elem.parentNode || {}).firstChild, elem);\n    },\n    children: function children(elem) {\n      return jQuery.sibling(elem.firstChild);\n    },\n    contents: function contents(elem) {\n      return elem.contentDocument || jQuery.merge([], elem.childNodes);\n    }\n  }, function (name, fn) {\n    jQuery.fn[name] = function (until, selector) {\n      var matched = jQuery.map(this, fn, until);\n\n      if (name.slice(-5) !== \"Until\") {\n        selector = until;\n      }\n\n      if (selector && typeof selector === \"string\") {\n        matched = jQuery.filter(selector, matched);\n      }\n\n      if (this.length > 1) {\n        // Remove duplicates\n        if (!guaranteedUnique[name]) {\n          jQuery.unique(matched);\n        } // Reverse order for parents* and prev-derivatives\n\n\n        if (rparentsprev.test(name)) {\n          matched.reverse();\n        }\n      }\n\n      return this.pushStack(matched);\n    };\n  });\n  var rnotwhite = /\\S+/g; // String to Object options format cache\n\n  var optionsCache = {}; // Convert String-formatted options into Object-formatted ones and store in cache\n\n  function createOptions(options) {\n    var object = optionsCache[options] = {};\n    jQuery.each(options.match(rnotwhite) || [], function (_, flag) {\n      object[flag] = true;\n    });\n    return object;\n  }\n  /*\n   * Create a callback list using the following parameters:\n   *\n   *\toptions: an optional list of space-separated options that will change how\n   *\t\t\tthe callback list behaves or a more traditional option object\n   *\n   * By default a callback list will act like an event callback list and can be\n   * \"fired\" multiple times.\n   *\n   * Possible options:\n   *\n   *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n   *\n   *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n   *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n   *\t\t\t\t\tvalues (like a Deferred)\n   *\n   *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n   *\n   *\tstopOnFalse:\tinterrupt callings when a callback returns false\n   *\n   */\n\n\n  jQuery.Callbacks = function (options) {\n    // Convert options from String-formatted to Object-formatted if needed\n    // (we check in cache first)\n    options = typeof options === \"string\" ? optionsCache[options] || createOptions(options) : jQuery.extend({}, options);\n\n    var // Last fire value (for non-forgettable lists)\n    memory,\n        // Flag to know if list was already fired\n    _fired,\n        // Flag to know if list is currently firing\n    firing,\n        // First callback to fire (used internally by add and fireWith)\n    firingStart,\n        // End of the loop when firing\n    firingLength,\n        // Index of currently firing callback (modified by remove if needed)\n    firingIndex,\n        // Actual callback list\n    list = [],\n        // Stack of fire calls for repeatable lists\n    stack = !options.once && [],\n        // Fire callbacks\n    fire = function fire(data) {\n      memory = options.memory && data;\n      _fired = true;\n      firingIndex = firingStart || 0;\n      firingStart = 0;\n      firingLength = list.length;\n      firing = true;\n\n      for (; list && firingIndex < firingLength; firingIndex++) {\n        if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {\n          memory = false; // To prevent further calls using add\n\n          break;\n        }\n      }\n\n      firing = false;\n\n      if (list) {\n        if (stack) {\n          if (stack.length) {\n            fire(stack.shift());\n          }\n        } else if (memory) {\n          list = [];\n        } else {\n          self.disable();\n        }\n      }\n    },\n        // Actual Callbacks object\n    self = {\n      // Add a callback or a collection of callbacks to the list\n      add: function add() {\n        if (list) {\n          // First, we save the current length\n          var start = list.length;\n\n          (function add(args) {\n            jQuery.each(args, function (_, arg) {\n              var type = jQuery.type(arg);\n\n              if (type === \"function\") {\n                if (!options.unique || !self.has(arg)) {\n                  list.push(arg);\n                }\n              } else if (arg && arg.length && type !== \"string\") {\n                // Inspect recursively\n                add(arg);\n              }\n            });\n          })(arguments); // Do we need to add the callbacks to the\n          // current firing batch?\n\n\n          if (firing) {\n            firingLength = list.length; // With memory, if we're not firing then\n            // we should call right away\n          } else if (memory) {\n            firingStart = start;\n            fire(memory);\n          }\n        }\n\n        return this;\n      },\n      // Remove a callback from the list\n      remove: function remove() {\n        if (list) {\n          jQuery.each(arguments, function (_, arg) {\n            var index;\n\n            while ((index = jQuery.inArray(arg, list, index)) > -1) {\n              list.splice(index, 1); // Handle firing indexes\n\n              if (firing) {\n                if (index <= firingLength) {\n                  firingLength--;\n                }\n\n                if (index <= firingIndex) {\n                  firingIndex--;\n                }\n              }\n            }\n          });\n        }\n\n        return this;\n      },\n      // Check if a given callback is in the list.\n      // If no argument is given, return whether or not list has callbacks attached.\n      has: function has(fn) {\n        return fn ? jQuery.inArray(fn, list) > -1 : !!(list && list.length);\n      },\n      // Remove all callbacks from the list\n      empty: function empty() {\n        list = [];\n        firingLength = 0;\n        return this;\n      },\n      // Have the list do nothing anymore\n      disable: function disable() {\n        list = stack = memory = undefined;\n        return this;\n      },\n      // Is it disabled?\n      disabled: function disabled() {\n        return !list;\n      },\n      // Lock the list in its current state\n      lock: function lock() {\n        stack = undefined;\n\n        if (!memory) {\n          self.disable();\n        }\n\n        return this;\n      },\n      // Is it locked?\n      locked: function locked() {\n        return !stack;\n      },\n      // Call all callbacks with the given context and arguments\n      fireWith: function fireWith(context, args) {\n        if (list && (!_fired || stack)) {\n          args = args || [];\n          args = [context, args.slice ? args.slice() : args];\n\n          if (firing) {\n            stack.push(args);\n          } else {\n            fire(args);\n          }\n        }\n\n        return this;\n      },\n      // Call all the callbacks with the given arguments\n      fire: function fire() {\n        self.fireWith(this, arguments);\n        return this;\n      },\n      // To know if the callbacks have already been called at least once\n      fired: function fired() {\n        return !!_fired;\n      }\n    };\n\n    return self;\n  };\n\n  jQuery.extend({\n    Deferred: function Deferred(func) {\n      var tuples = [// action, add listener, listener list, final state\n      [\"resolve\", \"done\", jQuery.Callbacks(\"once memory\"), \"resolved\"], [\"reject\", \"fail\", jQuery.Callbacks(\"once memory\"), \"rejected\"], [\"notify\", \"progress\", jQuery.Callbacks(\"memory\")]],\n          _state = \"pending\",\n          _promise = {\n        state: function state() {\n          return _state;\n        },\n        always: function always() {\n          deferred.done(arguments).fail(arguments);\n          return this;\n        },\n        then: function then()\n        /* fnDone, fnFail, fnProgress */\n        {\n          var fns = arguments;\n          return jQuery.Deferred(function (newDefer) {\n            jQuery.each(tuples, function (i, tuple) {\n              var fn = jQuery.isFunction(fns[i]) && fns[i]; // deferred[ done | fail | progress ] for forwarding actions to newDefer\n\n              deferred[tuple[1]](function () {\n                var returned = fn && fn.apply(this, arguments);\n\n                if (returned && jQuery.isFunction(returned.promise)) {\n                  returned.promise().done(newDefer.resolve).fail(newDefer.reject).progress(newDefer.notify);\n                } else {\n                  newDefer[tuple[0] + \"With\"](this === _promise ? newDefer.promise() : this, fn ? [returned] : arguments);\n                }\n              });\n            });\n            fns = null;\n          }).promise();\n        },\n        // Get a promise for this deferred\n        // If obj is provided, the promise aspect is added to the object\n        promise: function promise(obj) {\n          return obj != null ? jQuery.extend(obj, _promise) : _promise;\n        }\n      },\n          deferred = {}; // Keep pipe for back-compat\n\n      _promise.pipe = _promise.then; // Add list-specific methods\n\n      jQuery.each(tuples, function (i, tuple) {\n        var list = tuple[2],\n            stateString = tuple[3]; // promise[ done | fail | progress ] = list.add\n\n        _promise[tuple[1]] = list.add; // Handle state\n\n        if (stateString) {\n          list.add(function () {\n            // state = [ resolved | rejected ]\n            _state = stateString; // [ reject_list | resolve_list ].disable; progress_list.lock\n          }, tuples[i ^ 1][2].disable, tuples[2][2].lock);\n        } // deferred[ resolve | reject | notify ]\n\n\n        deferred[tuple[0]] = function () {\n          deferred[tuple[0] + \"With\"](this === deferred ? _promise : this, arguments);\n          return this;\n        };\n\n        deferred[tuple[0] + \"With\"] = list.fireWith;\n      }); // Make the deferred a promise\n\n      _promise.promise(deferred); // Call given func if any\n\n\n      if (func) {\n        func.call(deferred, deferred);\n      } // All done!\n\n\n      return deferred;\n    },\n    // Deferred helper\n    when: function when(subordinate\n    /* , ..., subordinateN */\n    ) {\n      var i = 0,\n          resolveValues = _slice.call(arguments),\n          length = resolveValues.length,\n          // the count of uncompleted subordinates\n      remaining = length !== 1 || subordinate && jQuery.isFunction(subordinate.promise) ? length : 0,\n          // the master Deferred. If resolveValues consist of only a single Deferred, just use that.\n      deferred = remaining === 1 ? subordinate : jQuery.Deferred(),\n          // Update function for both resolve and progress values\n      updateFunc = function updateFunc(i, contexts, values) {\n        return function (value) {\n          contexts[i] = this;\n          values[i] = arguments.length > 1 ? _slice.call(arguments) : value;\n\n          if (values === progressValues) {\n            deferred.notifyWith(contexts, values);\n          } else if (! --remaining) {\n            deferred.resolveWith(contexts, values);\n          }\n        };\n      },\n          progressValues,\n          progressContexts,\n          resolveContexts; // Add listeners to Deferred subordinates; treat others as resolved\n\n\n      if (length > 1) {\n        progressValues = new Array(length);\n        progressContexts = new Array(length);\n        resolveContexts = new Array(length);\n\n        for (; i < length; i++) {\n          if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {\n            resolveValues[i].promise().done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject).progress(updateFunc(i, progressContexts, progressValues));\n          } else {\n            --remaining;\n          }\n        }\n      } // If we're not waiting on anything, resolve the master\n\n\n      if (!remaining) {\n        deferred.resolveWith(resolveContexts, resolveValues);\n      }\n\n      return deferred.promise();\n    }\n  }); // The deferred used on DOM ready\n\n  var readyList;\n\n  jQuery.fn.ready = function (fn) {\n    // Add the callback\n    jQuery.ready.promise().done(fn);\n    return this;\n  };\n\n  jQuery.extend({\n    // Is the DOM ready to be used? Set to true once it occurs.\n    isReady: false,\n    // A counter to track how many items to wait for before\n    // the ready event fires. See #6781\n    readyWait: 1,\n    // Hold (or release) the ready event\n    holdReady: function holdReady(hold) {\n      if (hold) {\n        jQuery.readyWait++;\n      } else {\n        jQuery.ready(true);\n      }\n    },\n    // Handle when the DOM is ready\n    ready: function ready(wait) {\n      // Abort if there are pending holds or we're already ready\n      if (wait === true ? --jQuery.readyWait : jQuery.isReady) {\n        return;\n      } // Remember that the DOM is ready\n\n\n      jQuery.isReady = true; // If a normal DOM Ready event fired, decrement, and wait if need be\n\n      if (wait !== true && --jQuery.readyWait > 0) {\n        return;\n      } // If there are functions bound, to execute\n\n\n      readyList.resolveWith(document, [jQuery]); // Trigger any bound ready events\n\n      if (jQuery.fn.triggerHandler) {\n        jQuery(document).triggerHandler(\"ready\");\n        jQuery(document).off(\"ready\");\n      }\n    }\n  });\n  /**\n   * The ready event handler and self cleanup method\n   */\n\n  function completed() {\n    document.removeEventListener(\"DOMContentLoaded\", completed, false);\n    window.removeEventListener(\"load\", completed, false);\n    jQuery.ready();\n  }\n\n  jQuery.ready.promise = function (obj) {\n    if (!readyList) {\n      readyList = jQuery.Deferred(); // Catch cases where $(document).ready() is called after the browser event has already occurred.\n      // We once tried to use readyState \"interactive\" here, but it caused issues like the one\n      // discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15\n\n      if (document.readyState === \"complete\") {\n        // Handle it asynchronously to allow scripts the opportunity to delay ready\n        setTimeout(jQuery.ready);\n      } else {\n        // Use the handy event callback\n        document.addEventListener(\"DOMContentLoaded\", completed, false); // A fallback to window.onload, that will always work\n\n        window.addEventListener(\"load\", completed, false);\n      }\n    }\n\n    return readyList.promise(obj);\n  }; // Kick off the DOM ready check even if the user does not\n\n\n  jQuery.ready.promise(); // Multifunctional method to get and set values of a collection\n  // The value/s can optionally be executed if it's a function\n\n  var access = jQuery.access = function (elems, fn, key, value, chainable, emptyGet, raw) {\n    var i = 0,\n        len = elems.length,\n        bulk = key == null; // Sets many values\n\n    if (jQuery.type(key) === \"object\") {\n      chainable = true;\n\n      for (i in key) {\n        jQuery.access(elems, fn, i, key[i], true, emptyGet, raw);\n      } // Sets one value\n\n    } else if (value !== undefined) {\n      chainable = true;\n\n      if (!jQuery.isFunction(value)) {\n        raw = true;\n      }\n\n      if (bulk) {\n        // Bulk operations run against the entire set\n        if (raw) {\n          fn.call(elems, value);\n          fn = null; // ...except when executing function values\n        } else {\n          bulk = fn;\n\n          fn = function fn(elem, key, value) {\n            return bulk.call(jQuery(elem), value);\n          };\n        }\n      }\n\n      if (fn) {\n        for (; i < len; i++) {\n          fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));\n        }\n      }\n    }\n\n    return chainable ? elems : // Gets\n    bulk ? fn.call(elems) : len ? fn(elems[0], key) : emptyGet;\n  };\n  /**\n   * Determines whether an object can have data\n   */\n\n\n  jQuery.acceptData = function (owner) {\n    // Accepts only:\n    //  - Node\n    //    - Node.ELEMENT_NODE\n    //    - Node.DOCUMENT_NODE\n    //  - Object\n    //    - Any\n\n    /* jshint -W018 */\n    return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;\n  };\n\n  function Data() {\n    // Support: Android<4,\n    // Old WebKit does not have Object.preventExtensions/freeze method,\n    // return new empty object instead with no [[set]] accessor\n    Object.defineProperty(this.cache = {}, 0, {\n      get: function get() {\n        return {};\n      }\n    });\n    this.expando = jQuery.expando + Data.uid++;\n  }\n\n  Data.uid = 1;\n  Data.accepts = jQuery.acceptData;\n  Data.prototype = {\n    key: function key(owner) {\n      // We can accept data for non-element nodes in modern browsers,\n      // but we should not, see #8335.\n      // Always return the key for a frozen object.\n      if (!Data.accepts(owner)) {\n        return 0;\n      }\n\n      var descriptor = {},\n          // Check if the owner object already has a cache key\n      unlock = owner[this.expando]; // If not, create one\n\n      if (!unlock) {\n        unlock = Data.uid++; // Secure it in a non-enumerable, non-writable property\n\n        try {\n          descriptor[this.expando] = {\n            value: unlock\n          };\n          Object.defineProperties(owner, descriptor); // Support: Android<4\n          // Fallback to a less secure definition\n        } catch (e) {\n          descriptor[this.expando] = unlock;\n          jQuery.extend(owner, descriptor);\n        }\n      } // Ensure the cache object\n\n\n      if (!this.cache[unlock]) {\n        this.cache[unlock] = {};\n      }\n\n      return unlock;\n    },\n    set: function set(owner, data, value) {\n      var prop,\n          // There may be an unlock assigned to this node,\n      // if there is no entry for this \"owner\", create one inline\n      // and set the unlock as though an owner entry had always existed\n      unlock = this.key(owner),\n          cache = this.cache[unlock]; // Handle: [ owner, key, value ] args\n\n      if (typeof data === \"string\") {\n        cache[data] = value; // Handle: [ owner, { properties } ] args\n      } else {\n        // Fresh assignments by object are shallow copied\n        if (jQuery.isEmptyObject(cache)) {\n          jQuery.extend(this.cache[unlock], data); // Otherwise, copy the properties one-by-one to the cache object\n        } else {\n          for (prop in data) {\n            cache[prop] = data[prop];\n          }\n        }\n      }\n\n      return cache;\n    },\n    get: function get(owner, key) {\n      // Either a valid cache is found, or will be created.\n      // New caches will be created and the unlock returned,\n      // allowing direct access to the newly created\n      // empty data object. A valid owner object must be provided.\n      var cache = this.cache[this.key(owner)];\n      return key === undefined ? cache : cache[key];\n    },\n    access: function access(owner, key, value) {\n      var stored; // In cases where either:\n      //\n      //   1. No key was specified\n      //   2. A string key was specified, but no value provided\n      //\n      // Take the \"read\" path and allow the get method to determine\n      // which value to return, respectively either:\n      //\n      //   1. The entire cache object\n      //   2. The data stored at the key\n      //\n\n      if (key === undefined || key && typeof key === \"string\" && value === undefined) {\n        stored = this.get(owner, key);\n        return stored !== undefined ? stored : this.get(owner, jQuery.camelCase(key));\n      } // [*]When the key is not a string, or both a key and value\n      // are specified, set or extend (existing objects) with either:\n      //\n      //   1. An object of properties\n      //   2. A key and value\n      //\n\n\n      this.set(owner, key, value); // Since the \"set\" path can have two possible entry points\n      // return the expected data based on which path was taken[*]\n\n      return value !== undefined ? value : key;\n    },\n    remove: function remove(owner, key) {\n      var i,\n          name,\n          camel,\n          unlock = this.key(owner),\n          cache = this.cache[unlock];\n\n      if (key === undefined) {\n        this.cache[unlock] = {};\n      } else {\n        // Support array or space separated string of keys\n        if (jQuery.isArray(key)) {\n          // If \"name\" is an array of keys...\n          // When data is initially created, via (\"key\", \"val\") signature,\n          // keys will be converted to camelCase.\n          // Since there is no way to tell _how_ a key was added, remove\n          // both plain key and camelCase key. #12786\n          // This will only penalize the array argument path.\n          name = key.concat(key.map(jQuery.camelCase));\n        } else {\n          camel = jQuery.camelCase(key); // Try the string as a key before any manipulation\n\n          if (key in cache) {\n            name = [key, camel];\n          } else {\n            // If a key with the spaces exists, use it.\n            // Otherwise, create an array by matching non-whitespace\n            name = camel;\n            name = name in cache ? [name] : name.match(rnotwhite) || [];\n          }\n        }\n\n        i = name.length;\n\n        while (i--) {\n          delete cache[name[i]];\n        }\n      }\n    },\n    hasData: function hasData(owner) {\n      return !jQuery.isEmptyObject(this.cache[owner[this.expando]] || {});\n    },\n    discard: function discard(owner) {\n      if (owner[this.expando]) {\n        delete this.cache[owner[this.expando]];\n      }\n    }\n  };\n  var data_priv = new Data();\n  var data_user = new Data(); //\tImplementation Summary\n  //\n  //\t1. Enforce API surface and semantic compatibility with 1.9.x branch\n  //\t2. Improve the module's maintainability by reducing the storage\n  //\t\tpaths to a single mechanism.\n  //\t3. Use the same single mechanism to support \"private\" and \"user\" data.\n  //\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\n  //\t5. Avoid exposing implementation details on user objects (eg. expando properties)\n  //\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\n\n  var rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n      rmultiDash = /([A-Z])/g;\n\n  function dataAttr(elem, key, data) {\n    var name; // If nothing was found internally, try to fetch any\n    // data from the HTML5 data-* attribute\n\n    if (data === undefined && elem.nodeType === 1) {\n      name = \"data-\" + key.replace(rmultiDash, \"-$1\").toLowerCase();\n      data = elem.getAttribute(name);\n\n      if (typeof data === \"string\") {\n        try {\n          data = data === \"true\" ? true : data === \"false\" ? false : data === \"null\" ? null : // Only convert to a number if it doesn't change the string\n          +data + \"\" === data ? +data : rbrace.test(data) ? jQuery.parseJSON(data) : data;\n        } catch (e) {} // Make sure we set the data so it isn't changed later\n\n\n        data_user.set(elem, key, data);\n      } else {\n        data = undefined;\n      }\n    }\n\n    return data;\n  }\n\n  jQuery.extend({\n    hasData: function hasData(elem) {\n      return data_user.hasData(elem) || data_priv.hasData(elem);\n    },\n    data: function data(elem, name, _data) {\n      return data_user.access(elem, name, _data);\n    },\n    removeData: function removeData(elem, name) {\n      data_user.remove(elem, name);\n    },\n    // TODO: Now that all calls to _data and _removeData have been replaced\n    // with direct calls to data_priv methods, these can be deprecated.\n    _data: function _data(elem, name, data) {\n      return data_priv.access(elem, name, data);\n    },\n    _removeData: function _removeData(elem, name) {\n      data_priv.remove(elem, name);\n    }\n  });\n  jQuery.fn.extend({\n    data: function data(key, value) {\n      var i,\n          name,\n          data,\n          elem = this[0],\n          attrs = elem && elem.attributes; // Gets all values\n\n      if (key === undefined) {\n        if (this.length) {\n          data = data_user.get(elem);\n\n          if (elem.nodeType === 1 && !data_priv.get(elem, \"hasDataAttrs\")) {\n            i = attrs.length;\n\n            while (i--) {\n              // Support: IE11+\n              // The attrs elements can be null (#14894)\n              if (attrs[i]) {\n                name = attrs[i].name;\n\n                if (name.indexOf(\"data-\") === 0) {\n                  name = jQuery.camelCase(name.slice(5));\n                  dataAttr(elem, name, data[name]);\n                }\n              }\n            }\n\n            data_priv.set(elem, \"hasDataAttrs\", true);\n          }\n        }\n\n        return data;\n      } // Sets multiple values\n\n\n      if (_typeof(key) === \"object\") {\n        return this.each(function () {\n          data_user.set(this, key);\n        });\n      }\n\n      return access(this, function (value) {\n        var data,\n            camelKey = jQuery.camelCase(key); // The calling jQuery object (element matches) is not empty\n        // (and therefore has an element appears at this[ 0 ]) and the\n        // `value` parameter was not undefined. An empty jQuery object\n        // will result in `undefined` for elem = this[ 0 ] which will\n        // throw an exception if an attempt to read a data cache is made.\n\n        if (elem && value === undefined) {\n          // Attempt to get data from the cache\n          // with the key as-is\n          data = data_user.get(elem, key);\n\n          if (data !== undefined) {\n            return data;\n          } // Attempt to get data from the cache\n          // with the key camelized\n\n\n          data = data_user.get(elem, camelKey);\n\n          if (data !== undefined) {\n            return data;\n          } // Attempt to \"discover\" the data in\n          // HTML5 custom data-* attrs\n\n\n          data = dataAttr(elem, camelKey, undefined);\n\n          if (data !== undefined) {\n            return data;\n          } // We tried really hard, but the data doesn't exist.\n\n\n          return;\n        } // Set the data...\n\n\n        this.each(function () {\n          // First, attempt to store a copy or reference of any\n          // data that might've been store with a camelCased key.\n          var data = data_user.get(this, camelKey); // For HTML5 data-* attribute interop, we have to\n          // store property names with dashes in a camelCase form.\n          // This might not apply to all properties...*\n\n          data_user.set(this, camelKey, value); // *... In the case of properties that might _actually_\n          // have dashes, we need to also store a copy of that\n          // unchanged property.\n\n          if (key.indexOf(\"-\") !== -1 && data !== undefined) {\n            data_user.set(this, key, value);\n          }\n        });\n      }, null, value, arguments.length > 1, null, true);\n    },\n    removeData: function removeData(key) {\n      return this.each(function () {\n        data_user.remove(this, key);\n      });\n    }\n  });\n  jQuery.extend({\n    queue: function queue(elem, type, data) {\n      var queue;\n\n      if (elem) {\n        type = (type || \"fx\") + \"queue\";\n        queue = data_priv.get(elem, type); // Speed up dequeue by getting out quickly if this is just a lookup\n\n        if (data) {\n          if (!queue || jQuery.isArray(data)) {\n            queue = data_priv.access(elem, type, jQuery.makeArray(data));\n          } else {\n            queue.push(data);\n          }\n        }\n\n        return queue || [];\n      }\n    },\n    dequeue: function dequeue(elem, type) {\n      type = type || \"fx\";\n\n      var queue = jQuery.queue(elem, type),\n          startLength = queue.length,\n          fn = queue.shift(),\n          hooks = jQuery._queueHooks(elem, type),\n          next = function next() {\n        jQuery.dequeue(elem, type);\n      }; // If the fx queue is dequeued, always remove the progress sentinel\n\n\n      if (fn === \"inprogress\") {\n        fn = queue.shift();\n        startLength--;\n      }\n\n      if (fn) {\n        // Add a progress sentinel to prevent the fx queue from being\n        // automatically dequeued\n        if (type === \"fx\") {\n          queue.unshift(\"inprogress\");\n        } // Clear up the last queue stop function\n\n\n        delete hooks.stop;\n        fn.call(elem, next, hooks);\n      }\n\n      if (!startLength && hooks) {\n        hooks.empty.fire();\n      }\n    },\n    // Not public - generate a queueHooks object, or return the current one\n    _queueHooks: function _queueHooks(elem, type) {\n      var key = type + \"queueHooks\";\n      return data_priv.get(elem, key) || data_priv.access(elem, key, {\n        empty: jQuery.Callbacks(\"once memory\").add(function () {\n          data_priv.remove(elem, [type + \"queue\", key]);\n        })\n      });\n    }\n  });\n  jQuery.fn.extend({\n    queue: function queue(type, data) {\n      var setter = 2;\n\n      if (typeof type !== \"string\") {\n        data = type;\n        type = \"fx\";\n        setter--;\n      }\n\n      if (arguments.length < setter) {\n        return jQuery.queue(this[0], type);\n      }\n\n      return data === undefined ? this : this.each(function () {\n        var queue = jQuery.queue(this, type, data); // Ensure a hooks for this queue\n\n        jQuery._queueHooks(this, type);\n\n        if (type === \"fx\" && queue[0] !== \"inprogress\") {\n          jQuery.dequeue(this, type);\n        }\n      });\n    },\n    dequeue: function dequeue(type) {\n      return this.each(function () {\n        jQuery.dequeue(this, type);\n      });\n    },\n    clearQueue: function clearQueue(type) {\n      return this.queue(type || \"fx\", []);\n    },\n    // Get a promise resolved when queues of a certain type\n    // are emptied (fx is the type by default)\n    promise: function promise(type, obj) {\n      var tmp,\n          count = 1,\n          defer = jQuery.Deferred(),\n          elements = this,\n          i = this.length,\n          resolve = function resolve() {\n        if (! --count) {\n          defer.resolveWith(elements, [elements]);\n        }\n      };\n\n      if (typeof type !== \"string\") {\n        obj = type;\n        type = undefined;\n      }\n\n      type = type || \"fx\";\n\n      while (i--) {\n        tmp = data_priv.get(elements[i], type + \"queueHooks\");\n\n        if (tmp && tmp.empty) {\n          count++;\n          tmp.empty.add(resolve);\n        }\n      }\n\n      resolve();\n      return defer.promise(obj);\n    }\n  });\n  var pnum = /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source;\n  var cssExpand = [\"Top\", \"Right\", \"Bottom\", \"Left\"];\n\n  var isHidden = function isHidden(elem, el) {\n    // isHidden might be called from jQuery#filter function;\n    // in that case, element will be second argument\n    elem = el || elem;\n    return jQuery.css(elem, \"display\") === \"none\" || !jQuery.contains(elem.ownerDocument, elem);\n  };\n\n  var rcheckableType = /^(?:checkbox|radio)$/i;\n\n  (function () {\n    var fragment = document.createDocumentFragment(),\n        div = fragment.appendChild(document.createElement(\"div\")),\n        input = document.createElement(\"input\"); // Support: Safari<=5.1\n    // Check state lost if the name is set (#11217)\n    // Support: Windows Web Apps (WWA)\n    // `name` and `type` must use .setAttribute for WWA (#14901)\n\n    input.setAttribute(\"type\", \"radio\");\n    input.setAttribute(\"checked\", \"checked\");\n    input.setAttribute(\"name\", \"t\");\n    div.appendChild(input); // Support: Safari<=5.1, Android<4.2\n    // Older WebKit doesn't clone checked state correctly in fragments\n\n    support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked; // Support: IE<=11+\n    // Make sure textarea (and checkbox) defaultValue is properly cloned\n\n    div.innerHTML = \"<textarea>x</textarea>\";\n    support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;\n  })();\n\n  var strundefined = typeof undefined === \"undefined\" ? \"undefined\" : _typeof(undefined);\n  support.focusinBubbles = \"onfocusin\" in window;\n  var rkeyEvent = /^key/,\n      rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,\n      rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\n      rtypenamespace = /^([^.]*)(?:\\.(.+)|)$/;\n\n  function returnTrue() {\n    return true;\n  }\n\n  function returnFalse() {\n    return false;\n  }\n\n  function safeActiveElement() {\n    try {\n      return document.activeElement;\n    } catch (err) {}\n  }\n  /*\n   * Helper functions for managing events -- not part of the public interface.\n   * Props to Dean Edwards' addEvent library for many of the ideas.\n   */\n\n\n  jQuery.event = {\n    global: {},\n    add: function add(elem, types, handler, data, selector) {\n      var handleObjIn,\n          eventHandle,\n          tmp,\n          events,\n          t,\n          handleObj,\n          special,\n          handlers,\n          type,\n          namespaces,\n          origType,\n          elemData = data_priv.get(elem); // Don't attach events to noData or text/comment nodes (but allow plain objects)\n\n      if (!elemData) {\n        return;\n      } // Caller can pass in an object of custom data in lieu of the handler\n\n\n      if (handler.handler) {\n        handleObjIn = handler;\n        handler = handleObjIn.handler;\n        selector = handleObjIn.selector;\n      } // Make sure that the handler has a unique ID, used to find/remove it later\n\n\n      if (!handler.guid) {\n        handler.guid = jQuery.guid++;\n      } // Init the element's event structure and main handler, if this is the first\n\n\n      if (!(events = elemData.events)) {\n        events = elemData.events = {};\n      }\n\n      if (!(eventHandle = elemData.handle)) {\n        eventHandle = elemData.handle = function (e) {\n          // Discard the second event of a jQuery.event.trigger() and\n          // when an event is called after a page has unloaded\n          return _typeof(jQuery) !== strundefined && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;\n        };\n      } // Handle multiple events separated by a space\n\n\n      types = (types || \"\").match(rnotwhite) || [\"\"];\n      t = types.length;\n\n      while (t--) {\n        tmp = rtypenamespace.exec(types[t]) || [];\n        type = origType = tmp[1];\n        namespaces = (tmp[2] || \"\").split(\".\").sort(); // There *must* be a type, no attaching namespace-only handlers\n\n        if (!type) {\n          continue;\n        } // If event changes its type, use the special event handlers for the changed type\n\n\n        special = jQuery.event.special[type] || {}; // If selector defined, determine special event api type, otherwise given type\n\n        type = (selector ? special.delegateType : special.bindType) || type; // Update special based on newly reset type\n\n        special = jQuery.event.special[type] || {}; // handleObj is passed to all event handlers\n\n        handleObj = jQuery.extend({\n          type: type,\n          origType: origType,\n          data: data,\n          handler: handler,\n          guid: handler.guid,\n          selector: selector,\n          needsContext: selector && jQuery.expr.match.needsContext.test(selector),\n          namespace: namespaces.join(\".\")\n        }, handleObjIn); // Init the event handler queue if we're the first\n\n        if (!(handlers = events[type])) {\n          handlers = events[type] = [];\n          handlers.delegateCount = 0; // Only use addEventListener if the special events handler returns false\n\n          if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {\n            if (elem.addEventListener) {\n              elem.addEventListener(type, eventHandle, false);\n            }\n          }\n        }\n\n        if (special.add) {\n          special.add.call(elem, handleObj);\n\n          if (!handleObj.handler.guid) {\n            handleObj.handler.guid = handler.guid;\n          }\n        } // Add to the element's handler list, delegates in front\n\n\n        if (selector) {\n          handlers.splice(handlers.delegateCount++, 0, handleObj);\n        } else {\n          handlers.push(handleObj);\n        } // Keep track of which events have ever been used, for event optimization\n\n\n        jQuery.event.global[type] = true;\n      }\n    },\n    // Detach an event or set of events from an element\n    remove: function remove(elem, types, handler, selector, mappedTypes) {\n      var j,\n          origCount,\n          tmp,\n          events,\n          t,\n          handleObj,\n          special,\n          handlers,\n          type,\n          namespaces,\n          origType,\n          elemData = data_priv.hasData(elem) && data_priv.get(elem);\n\n      if (!elemData || !(events = elemData.events)) {\n        return;\n      } // Once for each type.namespace in types; type may be omitted\n\n\n      types = (types || \"\").match(rnotwhite) || [\"\"];\n      t = types.length;\n\n      while (t--) {\n        tmp = rtypenamespace.exec(types[t]) || [];\n        type = origType = tmp[1];\n        namespaces = (tmp[2] || \"\").split(\".\").sort(); // Unbind all events (on this namespace, if provided) for the element\n\n        if (!type) {\n          for (type in events) {\n            jQuery.event.remove(elem, type + types[t], handler, selector, true);\n          }\n\n          continue;\n        }\n\n        special = jQuery.event.special[type] || {};\n        type = (selector ? special.delegateType : special.bindType) || type;\n        handlers = events[type] || [];\n        tmp = tmp[2] && new RegExp(\"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\"); // Remove matching events\n\n        origCount = j = handlers.length;\n\n        while (j--) {\n          handleObj = handlers[j];\n\n          if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === \"**\" && handleObj.selector)) {\n            handlers.splice(j, 1);\n\n            if (handleObj.selector) {\n              handlers.delegateCount--;\n            }\n\n            if (special.remove) {\n              special.remove.call(elem, handleObj);\n            }\n          }\n        } // Remove generic event handler if we removed something and no more handlers exist\n        // (avoids potential for endless recursion during removal of special event handlers)\n\n\n        if (origCount && !handlers.length) {\n          if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {\n            jQuery.removeEvent(elem, type, elemData.handle);\n          }\n\n          delete events[type];\n        }\n      } // Remove the expando if it's no longer used\n\n\n      if (jQuery.isEmptyObject(events)) {\n        delete elemData.handle;\n        data_priv.remove(elem, \"events\");\n      }\n    },\n    trigger: function trigger(event, data, elem, onlyHandlers) {\n      var i,\n          cur,\n          tmp,\n          bubbleType,\n          ontype,\n          handle,\n          special,\n          eventPath = [elem || document],\n          type = hasOwn.call(event, \"type\") ? event.type : event,\n          namespaces = hasOwn.call(event, \"namespace\") ? event.namespace.split(\".\") : [];\n      cur = tmp = elem = elem || document; // Don't do events on text and comment nodes\n\n      if (elem.nodeType === 3 || elem.nodeType === 8) {\n        return;\n      } // focus/blur morphs to focusin/out; ensure we're not firing them right now\n\n\n      if (rfocusMorph.test(type + jQuery.event.triggered)) {\n        return;\n      }\n\n      if (type.indexOf(\".\") >= 0) {\n        // Namespaced trigger; create a regexp to match event type in handle()\n        namespaces = type.split(\".\");\n        type = namespaces.shift();\n        namespaces.sort();\n      }\n\n      ontype = type.indexOf(\":\") < 0 && \"on\" + type; // Caller can pass in a jQuery.Event object, Object, or just an event type string\n\n      event = event[jQuery.expando] ? event : new jQuery.Event(type, _typeof(event) === \"object\" && event); // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n\n      event.isTrigger = onlyHandlers ? 2 : 3;\n      event.namespace = namespaces.join(\".\");\n      event.namespace_re = event.namespace ? new RegExp(\"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\") : null; // Clean up the event in case it is being reused\n\n      event.result = undefined;\n\n      if (!event.target) {\n        event.target = elem;\n      } // Clone any incoming data and prepend the event, creating the handler arg list\n\n\n      data = data == null ? [event] : jQuery.makeArray(data, [event]); // Allow special events to draw outside the lines\n\n      special = jQuery.event.special[type] || {};\n\n      if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {\n        return;\n      } // Determine event propagation path in advance, per W3C events spec (#9951)\n      // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n\n\n      if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {\n        bubbleType = special.delegateType || type;\n\n        if (!rfocusMorph.test(bubbleType + type)) {\n          cur = cur.parentNode;\n        }\n\n        for (; cur; cur = cur.parentNode) {\n          eventPath.push(cur);\n          tmp = cur;\n        } // Only add window if we got to document (e.g., not plain obj or detached DOM)\n\n\n        if (tmp === (elem.ownerDocument || document)) {\n          eventPath.push(tmp.defaultView || tmp.parentWindow || window);\n        }\n      } // Fire handlers on the event path\n\n\n      i = 0;\n\n      while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {\n        event.type = i > 1 ? bubbleType : special.bindType || type; // jQuery handler\n\n        handle = (data_priv.get(cur, \"events\") || {})[event.type] && data_priv.get(cur, \"handle\");\n\n        if (handle) {\n          handle.apply(cur, data);\n        } // Native handler\n\n\n        handle = ontype && cur[ontype];\n\n        if (handle && handle.apply && jQuery.acceptData(cur)) {\n          event.result = handle.apply(cur, data);\n\n          if (event.result === false) {\n            event.preventDefault();\n          }\n        }\n      }\n\n      event.type = type; // If nobody prevented the default action, do it now\n\n      if (!onlyHandlers && !event.isDefaultPrevented()) {\n        if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && jQuery.acceptData(elem)) {\n          // Call a native DOM method on the target with the same name name as the event.\n          // Don't do default actions on window, that's where global variables be (#6170)\n          if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {\n            // Don't re-trigger an onFOO event when we call its FOO() method\n            tmp = elem[ontype];\n\n            if (tmp) {\n              elem[ontype] = null;\n            } // Prevent re-triggering of the same event, since we already bubbled it above\n\n\n            jQuery.event.triggered = type;\n            elem[type]();\n            jQuery.event.triggered = undefined;\n\n            if (tmp) {\n              elem[ontype] = tmp;\n            }\n          }\n        }\n      }\n\n      return event.result;\n    },\n    dispatch: function dispatch(event) {\n      // Make a writable jQuery.Event from the native event object\n      event = jQuery.event.fix(event);\n\n      var i,\n          j,\n          ret,\n          matched,\n          handleObj,\n          handlerQueue = [],\n          args = _slice.call(arguments),\n          handlers = (data_priv.get(this, \"events\") || {})[event.type] || [],\n          special = jQuery.event.special[event.type] || {}; // Use the fix-ed jQuery.Event rather than the (read-only) native event\n\n\n      args[0] = event;\n      event.delegateTarget = this; // Call the preDispatch hook for the mapped type, and let it bail if desired\n\n      if (special.preDispatch && special.preDispatch.call(this, event) === false) {\n        return;\n      } // Determine handlers\n\n\n      handlerQueue = jQuery.event.handlers.call(this, event, handlers); // Run delegates first; they may want to stop propagation beneath us\n\n      i = 0;\n\n      while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {\n        event.currentTarget = matched.elem;\n        j = 0;\n\n        while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {\n          // Triggered event must either 1) have no namespace, or 2) have namespace(s)\n          // a subset or equal to those in the bound event (both can have no namespace).\n          if (!event.namespace_re || event.namespace_re.test(handleObj.namespace)) {\n            event.handleObj = handleObj;\n            event.data = handleObj.data;\n            ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);\n\n            if (ret !== undefined) {\n              if ((event.result = ret) === false) {\n                event.preventDefault();\n                event.stopPropagation();\n              }\n            }\n          }\n        }\n      } // Call the postDispatch hook for the mapped type\n\n\n      if (special.postDispatch) {\n        special.postDispatch.call(this, event);\n      }\n\n      return event.result;\n    },\n    handlers: function handlers(event, _handlers) {\n      var i,\n          matches,\n          sel,\n          handleObj,\n          handlerQueue = [],\n          delegateCount = _handlers.delegateCount,\n          cur = event.target; // Find delegate handlers\n      // Black-hole SVG <use> instance trees (#13180)\n      // Avoid non-left-click bubbling in Firefox (#3861)\n\n      if (delegateCount && cur.nodeType && (!event.button || event.type !== \"click\")) {\n        for (; cur !== this; cur = cur.parentNode || this) {\n          // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\n          if (cur.disabled !== true || event.type !== \"click\") {\n            matches = [];\n\n            for (i = 0; i < delegateCount; i++) {\n              handleObj = _handlers[i]; // Don't conflict with Object.prototype properties (#13203)\n\n              sel = handleObj.selector + \" \";\n\n              if (matches[sel] === undefined) {\n                matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) >= 0 : jQuery.find(sel, this, null, [cur]).length;\n              }\n\n              if (matches[sel]) {\n                matches.push(handleObj);\n              }\n            }\n\n            if (matches.length) {\n              handlerQueue.push({\n                elem: cur,\n                handlers: matches\n              });\n            }\n          }\n        }\n      } // Add the remaining (directly-bound) handlers\n\n\n      if (delegateCount < _handlers.length) {\n        handlerQueue.push({\n          elem: this,\n          handlers: _handlers.slice(delegateCount)\n        });\n      }\n\n      return handlerQueue;\n    },\n    // Includes some event props shared by KeyEvent and MouseEvent\n    props: \"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which\".split(\" \"),\n    fixHooks: {},\n    keyHooks: {\n      props: \"char charCode key keyCode\".split(\" \"),\n      filter: function filter(event, original) {\n        // Add which for key events\n        if (event.which == null) {\n          event.which = original.charCode != null ? original.charCode : original.keyCode;\n        }\n\n        return event;\n      }\n    },\n    mouseHooks: {\n      props: \"button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement\".split(\" \"),\n      filter: function filter(event, original) {\n        var eventDoc,\n            doc,\n            body,\n            button = original.button; // Calculate pageX/Y if missing and clientX/Y available\n\n        if (event.pageX == null && original.clientX != null) {\n          eventDoc = event.target.ownerDocument || document;\n          doc = eventDoc.documentElement;\n          body = eventDoc.body;\n          event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);\n          event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);\n        } // Add which for click: 1 === left; 2 === middle; 3 === right\n        // Note: button is not normalized, so don't use it\n\n\n        if (!event.which && button !== undefined) {\n          event.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;\n        }\n\n        return event;\n      }\n    },\n    fix: function fix(event) {\n      if (event[jQuery.expando]) {\n        return event;\n      } // Create a writable copy of the event object and normalize some properties\n\n\n      var i,\n          prop,\n          copy,\n          type = event.type,\n          originalEvent = event,\n          fixHook = this.fixHooks[type];\n\n      if (!fixHook) {\n        this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {};\n      }\n\n      copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;\n      event = new jQuery.Event(originalEvent);\n      i = copy.length;\n\n      while (i--) {\n        prop = copy[i];\n        event[prop] = originalEvent[prop];\n      } // Support: Cordova 2.5 (WebKit) (#13255)\n      // All events should have a target; Cordova deviceready doesn't\n\n\n      if (!event.target) {\n        event.target = document;\n      } // Support: Safari 6.0+, Chrome<28\n      // Target should not be a text node (#504, #13143)\n\n\n      if (event.target.nodeType === 3) {\n        event.target = event.target.parentNode;\n      }\n\n      return fixHook.filter ? fixHook.filter(event, originalEvent) : event;\n    },\n    special: {\n      load: {\n        // Prevent triggered image.load events from bubbling to window.load\n        noBubble: true\n      },\n      focus: {\n        // Fire native event if possible so blur/focus sequence is correct\n        trigger: function trigger() {\n          if (this !== safeActiveElement() && this.focus) {\n            this.focus();\n            return false;\n          }\n        },\n        delegateType: \"focusin\"\n      },\n      blur: {\n        trigger: function trigger() {\n          if (this === safeActiveElement() && this.blur) {\n            this.blur();\n            return false;\n          }\n        },\n        delegateType: \"focusout\"\n      },\n      click: {\n        // For checkbox, fire native event so checked state will be right\n        trigger: function trigger() {\n          if (this.type === \"checkbox\" && this.click && jQuery.nodeName(this, \"input\")) {\n            this.click();\n            return false;\n          }\n        },\n        // For cross-browser consistency, don't fire native .click() on links\n        _default: function _default(event) {\n          return jQuery.nodeName(event.target, \"a\");\n        }\n      },\n      beforeunload: {\n        postDispatch: function postDispatch(event) {\n          // Support: Firefox 20+\n          // Firefox doesn't alert if the returnValue field is not set.\n          if (event.result !== undefined && event.originalEvent) {\n            event.originalEvent.returnValue = event.result;\n          }\n        }\n      }\n    },\n    simulate: function simulate(type, elem, event, bubble) {\n      // Piggyback on a donor event to simulate a different one.\n      // Fake originalEvent to avoid donor's stopPropagation, but if the\n      // simulated event prevents default then we do the same on the donor.\n      var e = jQuery.extend(new jQuery.Event(), event, {\n        type: type,\n        isSimulated: true,\n        originalEvent: {}\n      });\n\n      if (bubble) {\n        jQuery.event.trigger(e, null, elem);\n      } else {\n        jQuery.event.dispatch.call(elem, e);\n      }\n\n      if (e.isDefaultPrevented()) {\n        event.preventDefault();\n      }\n    }\n  };\n\n  jQuery.removeEvent = function (elem, type, handle) {\n    if (elem.removeEventListener) {\n      elem.removeEventListener(type, handle, false);\n    }\n  };\n\n  jQuery.Event = function (src, props) {\n    // Allow instantiation without the 'new' keyword\n    if (!(this instanceof jQuery.Event)) {\n      return new jQuery.Event(src, props);\n    } // Event object\n\n\n    if (src && src.type) {\n      this.originalEvent = src;\n      this.type = src.type; // Events bubbling up the document may have been marked as prevented\n      // by a handler lower down the tree; reflect the correct value.\n\n      this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && // Support: Android<4.0\n      src.returnValue === false ? returnTrue : returnFalse; // Event type\n    } else {\n      this.type = src;\n    } // Put explicitly provided properties onto the event object\n\n\n    if (props) {\n      jQuery.extend(this, props);\n    } // Create a timestamp if incoming event doesn't have one\n\n\n    this.timeStamp = src && src.timeStamp || jQuery.now(); // Mark it as fixed\n\n    this[jQuery.expando] = true;\n  }; // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n  // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\n\n\n  jQuery.Event.prototype = {\n    isDefaultPrevented: returnFalse,\n    isPropagationStopped: returnFalse,\n    isImmediatePropagationStopped: returnFalse,\n    preventDefault: function preventDefault() {\n      var e = this.originalEvent;\n      this.isDefaultPrevented = returnTrue;\n\n      if (e && e.preventDefault) {\n        e.preventDefault();\n      }\n    },\n    stopPropagation: function stopPropagation() {\n      var e = this.originalEvent;\n      this.isPropagationStopped = returnTrue;\n\n      if (e && e.stopPropagation) {\n        e.stopPropagation();\n      }\n    },\n    stopImmediatePropagation: function stopImmediatePropagation() {\n      var e = this.originalEvent;\n      this.isImmediatePropagationStopped = returnTrue;\n\n      if (e && e.stopImmediatePropagation) {\n        e.stopImmediatePropagation();\n      }\n\n      this.stopPropagation();\n    }\n  }; // Create mouseenter/leave events using mouseover/out and event-time checks\n  // Support: Chrome 15+\n\n  jQuery.each({\n    mouseenter: \"mouseover\",\n    mouseleave: \"mouseout\",\n    pointerenter: \"pointerover\",\n    pointerleave: \"pointerout\"\n  }, function (orig, fix) {\n    jQuery.event.special[orig] = {\n      delegateType: fix,\n      bindType: fix,\n      handle: function handle(event) {\n        var ret,\n            target = this,\n            related = event.relatedTarget,\n            handleObj = event.handleObj; // For mousenter/leave call the handler if related is outside the target.\n        // NB: No relatedTarget if the mouse left/entered the browser window\n\n        if (!related || related !== target && !jQuery.contains(target, related)) {\n          event.type = handleObj.origType;\n          ret = handleObj.handler.apply(this, arguments);\n          event.type = fix;\n        }\n\n        return ret;\n      }\n    };\n  }); // Support: Firefox, Chrome, Safari\n  // Create \"bubbling\" focus and blur events\n\n  if (!support.focusinBubbles) {\n    jQuery.each({\n      focus: \"focusin\",\n      blur: \"focusout\"\n    }, function (orig, fix) {\n      // Attach a single capturing handler on the document while someone wants focusin/focusout\n      var handler = function handler(event) {\n        jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), true);\n      };\n\n      jQuery.event.special[fix] = {\n        setup: function setup() {\n          var doc = this.ownerDocument || this,\n              attaches = data_priv.access(doc, fix);\n\n          if (!attaches) {\n            doc.addEventListener(orig, handler, true);\n          }\n\n          data_priv.access(doc, fix, (attaches || 0) + 1);\n        },\n        teardown: function teardown() {\n          var doc = this.ownerDocument || this,\n              attaches = data_priv.access(doc, fix) - 1;\n\n          if (!attaches) {\n            doc.removeEventListener(orig, handler, true);\n            data_priv.remove(doc, fix);\n          } else {\n            data_priv.access(doc, fix, attaches);\n          }\n        }\n      };\n    });\n  }\n\n  jQuery.fn.extend({\n    on: function on(types, selector, data, fn,\n    /*INTERNAL*/\n    one) {\n      var origFn, type; // Types can be a map of types/handlers\n\n      if (_typeof(types) === \"object\") {\n        // ( types-Object, selector, data )\n        if (typeof selector !== \"string\") {\n          // ( types-Object, data )\n          data = data || selector;\n          selector = undefined;\n        }\n\n        for (type in types) {\n          this.on(type, selector, data, types[type], one);\n        }\n\n        return this;\n      }\n\n      if (data == null && fn == null) {\n        // ( types, fn )\n        fn = selector;\n        data = selector = undefined;\n      } else if (fn == null) {\n        if (typeof selector === \"string\") {\n          // ( types, selector, fn )\n          fn = data;\n          data = undefined;\n        } else {\n          // ( types, data, fn )\n          fn = data;\n          data = selector;\n          selector = undefined;\n        }\n      }\n\n      if (fn === false) {\n        fn = returnFalse;\n      } else if (!fn) {\n        return this;\n      }\n\n      if (one === 1) {\n        origFn = fn;\n\n        fn = function fn(event) {\n          // Can use an empty set, since event contains the info\n          jQuery().off(event);\n          return origFn.apply(this, arguments);\n        }; // Use same guid so caller can remove using origFn\n\n\n        fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);\n      }\n\n      return this.each(function () {\n        jQuery.event.add(this, types, fn, data, selector);\n      });\n    },\n    one: function one(types, selector, data, fn) {\n      return this.on(types, selector, data, fn, 1);\n    },\n    off: function off(types, selector, fn) {\n      var handleObj, type;\n\n      if (types && types.preventDefault && types.handleObj) {\n        // ( event )  dispatched jQuery.Event\n        handleObj = types.handleObj;\n        jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + \".\" + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);\n        return this;\n      }\n\n      if (_typeof(types) === \"object\") {\n        // ( types-object [, selector] )\n        for (type in types) {\n          this.off(type, selector, types[type]);\n        }\n\n        return this;\n      }\n\n      if (selector === false || typeof selector === \"function\") {\n        // ( types [, fn] )\n        fn = selector;\n        selector = undefined;\n      }\n\n      if (fn === false) {\n        fn = returnFalse;\n      }\n\n      return this.each(function () {\n        jQuery.event.remove(this, types, fn, selector);\n      });\n    },\n    trigger: function trigger(type, data) {\n      return this.each(function () {\n        jQuery.event.trigger(type, data, this);\n      });\n    },\n    triggerHandler: function triggerHandler(type, data) {\n      var elem = this[0];\n\n      if (elem) {\n        return jQuery.event.trigger(type, data, elem, true);\n      }\n    }\n  });\n  var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/gi,\n      rtagName = /<([\\w:]+)/,\n      rhtml = /<|&#?\\w+;/,\n      rnoInnerhtml = /<(?:script|style|link)/i,\n      // checked=\"checked\" or checked\n  rchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n      rscriptType = /^$|\\/(?:java|ecma)script/i,\n      rscriptTypeMasked = /^true\\/(.*)/,\n      rcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g,\n      // We have to close these tags to support XHTML (#13200)\n  wrapMap = {\n    // Support: IE9\n    option: [1, \"<select multiple='multiple'>\", \"</select>\"],\n    thead: [1, \"<table>\", \"</table>\"],\n    col: [2, \"<table><colgroup>\", \"</colgroup></table>\"],\n    tr: [2, \"<table><tbody>\", \"</tbody></table>\"],\n    td: [3, \"<table><tbody><tr>\", \"</tr></tbody></table>\"],\n    _default: [0, \"\", \"\"]\n  }; // Support: IE9\n\n  wrapMap.optgroup = wrapMap.option;\n  wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\n  wrapMap.th = wrapMap.td; // Support: 1.x compatibility\n  // Manipulating tables requires a tbody\n\n  function manipulationTarget(elem, content) {\n    return jQuery.nodeName(elem, \"table\") && jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, \"tr\") ? elem.getElementsByTagName(\"tbody\")[0] || elem.appendChild(elem.ownerDocument.createElement(\"tbody\")) : elem;\n  } // Replace/restore the type attribute of script elements for safe DOM manipulation\n\n\n  function disableScript(elem) {\n    elem.type = (elem.getAttribute(\"type\") !== null) + \"/\" + elem.type;\n    return elem;\n  }\n\n  function restoreScript(elem) {\n    var match = rscriptTypeMasked.exec(elem.type);\n\n    if (match) {\n      elem.type = match[1];\n    } else {\n      elem.removeAttribute(\"type\");\n    }\n\n    return elem;\n  } // Mark scripts as having already been evaluated\n\n\n  function setGlobalEval(elems, refElements) {\n    var i = 0,\n        l = elems.length;\n\n    for (; i < l; i++) {\n      data_priv.set(elems[i], \"globalEval\", !refElements || data_priv.get(refElements[i], \"globalEval\"));\n    }\n  }\n\n  function cloneCopyEvent(src, dest) {\n    var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;\n\n    if (dest.nodeType !== 1) {\n      return;\n    } // 1. Copy private data: events, handlers, etc.\n\n\n    if (data_priv.hasData(src)) {\n      pdataOld = data_priv.access(src);\n      pdataCur = data_priv.set(dest, pdataOld);\n      events = pdataOld.events;\n\n      if (events) {\n        delete pdataCur.handle;\n        pdataCur.events = {};\n\n        for (type in events) {\n          for (i = 0, l = events[type].length; i < l; i++) {\n            jQuery.event.add(dest, type, events[type][i]);\n          }\n        }\n      }\n    } // 2. Copy user data\n\n\n    if (data_user.hasData(src)) {\n      udataOld = data_user.access(src);\n      udataCur = jQuery.extend({}, udataOld);\n      data_user.set(dest, udataCur);\n    }\n  }\n\n  function getAll(context, tag) {\n    var ret = context.getElementsByTagName ? context.getElementsByTagName(tag || \"*\") : context.querySelectorAll ? context.querySelectorAll(tag || \"*\") : [];\n    return tag === undefined || tag && jQuery.nodeName(context, tag) ? jQuery.merge([context], ret) : ret;\n  } // Fix IE bugs, see support tests\n\n\n  function fixInput(src, dest) {\n    var nodeName = dest.nodeName.toLowerCase(); // Fails to persist the checked state of a cloned checkbox or radio button.\n\n    if (nodeName === \"input\" && rcheckableType.test(src.type)) {\n      dest.checked = src.checked; // Fails to return the selected option to the default selected state when cloning options\n    } else if (nodeName === \"input\" || nodeName === \"textarea\") {\n      dest.defaultValue = src.defaultValue;\n    }\n  }\n\n  jQuery.extend({\n    clone: function clone(elem, dataAndEvents, deepDataAndEvents) {\n      var i,\n          l,\n          srcElements,\n          destElements,\n          clone = elem.cloneNode(true),\n          inPage = jQuery.contains(elem.ownerDocument, elem); // Fix IE cloning issues\n\n      if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {\n        // We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2\n        destElements = getAll(clone);\n        srcElements = getAll(elem);\n\n        for (i = 0, l = srcElements.length; i < l; i++) {\n          fixInput(srcElements[i], destElements[i]);\n        }\n      } // Copy the events from the original to the clone\n\n\n      if (dataAndEvents) {\n        if (deepDataAndEvents) {\n          srcElements = srcElements || getAll(elem);\n          destElements = destElements || getAll(clone);\n\n          for (i = 0, l = srcElements.length; i < l; i++) {\n            cloneCopyEvent(srcElements[i], destElements[i]);\n          }\n        } else {\n          cloneCopyEvent(elem, clone);\n        }\n      } // Preserve script evaluation history\n\n\n      destElements = getAll(clone, \"script\");\n\n      if (destElements.length > 0) {\n        setGlobalEval(destElements, !inPage && getAll(elem, \"script\"));\n      } // Return the cloned set\n\n\n      return clone;\n    },\n    buildFragment: function buildFragment(elems, context, scripts, selection) {\n      var elem,\n          tmp,\n          tag,\n          wrap,\n          contains,\n          j,\n          fragment = context.createDocumentFragment(),\n          nodes = [],\n          i = 0,\n          l = elems.length;\n\n      for (; i < l; i++) {\n        elem = elems[i];\n\n        if (elem || elem === 0) {\n          // Add nodes directly\n          if (jQuery.type(elem) === \"object\") {\n            // Support: QtWebKit, PhantomJS\n            // push.apply(_, arraylike) throws on ancient WebKit\n            jQuery.merge(nodes, elem.nodeType ? [elem] : elem); // Convert non-html into a text node\n          } else if (!rhtml.test(elem)) {\n            nodes.push(context.createTextNode(elem)); // Convert html into DOM nodes\n          } else {\n            tmp = tmp || fragment.appendChild(context.createElement(\"div\")); // Deserialize a standard representation\n\n            tag = (rtagName.exec(elem) || [\"\", \"\"])[1].toLowerCase();\n            wrap = wrapMap[tag] || wrapMap._default;\n            tmp.innerHTML = wrap[1] + elem.replace(rxhtmlTag, \"<$1></$2>\") + wrap[2]; // Descend through wrappers to the right content\n\n            j = wrap[0];\n\n            while (j--) {\n              tmp = tmp.lastChild;\n            } // Support: QtWebKit, PhantomJS\n            // push.apply(_, arraylike) throws on ancient WebKit\n\n\n            jQuery.merge(nodes, tmp.childNodes); // Remember the top-level container\n\n            tmp = fragment.firstChild; // Ensure the created nodes are orphaned (#12392)\n\n            tmp.textContent = \"\";\n          }\n        }\n      } // Remove wrapper from fragment\n\n\n      fragment.textContent = \"\";\n      i = 0;\n\n      while (elem = nodes[i++]) {\n        // #4087 - If origin and destination elements are the same, and this is\n        // that element, do not do anything\n        if (selection && jQuery.inArray(elem, selection) !== -1) {\n          continue;\n        }\n\n        contains = jQuery.contains(elem.ownerDocument, elem); // Append to fragment\n\n        tmp = getAll(fragment.appendChild(elem), \"script\"); // Preserve script evaluation history\n\n        if (contains) {\n          setGlobalEval(tmp);\n        } // Capture executables\n\n\n        if (scripts) {\n          j = 0;\n\n          while (elem = tmp[j++]) {\n            if (rscriptType.test(elem.type || \"\")) {\n              scripts.push(elem);\n            }\n          }\n        }\n      }\n\n      return fragment;\n    },\n    cleanData: function cleanData(elems) {\n      var data,\n          elem,\n          type,\n          key,\n          special = jQuery.event.special,\n          i = 0;\n\n      for (; (elem = elems[i]) !== undefined; i++) {\n        if (jQuery.acceptData(elem)) {\n          key = elem[data_priv.expando];\n\n          if (key && (data = data_priv.cache[key])) {\n            if (data.events) {\n              for (type in data.events) {\n                if (special[type]) {\n                  jQuery.event.remove(elem, type); // This is a shortcut to avoid jQuery.event.remove's overhead\n                } else {\n                  jQuery.removeEvent(elem, type, data.handle);\n                }\n              }\n            }\n\n            if (data_priv.cache[key]) {\n              // Discard any remaining `private` data\n              delete data_priv.cache[key];\n            }\n          }\n        } // Discard any remaining `user` data\n\n\n        delete data_user.cache[elem[data_user.expando]];\n      }\n    }\n  });\n  jQuery.fn.extend({\n    text: function text(value) {\n      return access(this, function (value) {\n        return value === undefined ? jQuery.text(this) : this.empty().each(function () {\n          if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {\n            this.textContent = value;\n          }\n        });\n      }, null, value, arguments.length);\n    },\n    append: function append() {\n      return this.domManip(arguments, function (elem) {\n        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {\n          var target = manipulationTarget(this, elem);\n          target.appendChild(elem);\n        }\n      });\n    },\n    prepend: function prepend() {\n      return this.domManip(arguments, function (elem) {\n        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {\n          var target = manipulationTarget(this, elem);\n          target.insertBefore(elem, target.firstChild);\n        }\n      });\n    },\n    before: function before() {\n      return this.domManip(arguments, function (elem) {\n        if (this.parentNode) {\n          this.parentNode.insertBefore(elem, this);\n        }\n      });\n    },\n    after: function after() {\n      return this.domManip(arguments, function (elem) {\n        if (this.parentNode) {\n          this.parentNode.insertBefore(elem, this.nextSibling);\n        }\n      });\n    },\n    remove: function remove(selector, keepData\n    /* Internal Use Only */\n    ) {\n      var elem,\n          elems = selector ? jQuery.filter(selector, this) : this,\n          i = 0;\n\n      for (; (elem = elems[i]) != null; i++) {\n        if (!keepData && elem.nodeType === 1) {\n          jQuery.cleanData(getAll(elem));\n        }\n\n        if (elem.parentNode) {\n          if (keepData && jQuery.contains(elem.ownerDocument, elem)) {\n            setGlobalEval(getAll(elem, \"script\"));\n          }\n\n          elem.parentNode.removeChild(elem);\n        }\n      }\n\n      return this;\n    },\n    empty: function empty() {\n      var elem,\n          i = 0;\n\n      for (; (elem = this[i]) != null; i++) {\n        if (elem.nodeType === 1) {\n          // Prevent memory leaks\n          jQuery.cleanData(getAll(elem, false)); // Remove any remaining nodes\n\n          elem.textContent = \"\";\n        }\n      }\n\n      return this;\n    },\n    clone: function clone(dataAndEvents, deepDataAndEvents) {\n      dataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n      deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n      return this.map(function () {\n        return jQuery.clone(this, dataAndEvents, deepDataAndEvents);\n      });\n    },\n    html: function html(value) {\n      return access(this, function (value) {\n        var elem = this[0] || {},\n            i = 0,\n            l = this.length;\n\n        if (value === undefined && elem.nodeType === 1) {\n          return elem.innerHTML;\n        } // See if we can take a shortcut and just use innerHTML\n\n\n        if (typeof value === \"string\" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || [\"\", \"\"])[1].toLowerCase()]) {\n          value = value.replace(rxhtmlTag, \"<$1></$2>\");\n\n          try {\n            for (; i < l; i++) {\n              elem = this[i] || {}; // Remove element nodes and prevent memory leaks\n\n              if (elem.nodeType === 1) {\n                jQuery.cleanData(getAll(elem, false));\n                elem.innerHTML = value;\n              }\n            }\n\n            elem = 0; // If using innerHTML throws an exception, use the fallback method\n          } catch (e) {}\n        }\n\n        if (elem) {\n          this.empty().append(value);\n        }\n      }, null, value, arguments.length);\n    },\n    replaceWith: function replaceWith() {\n      var arg = arguments[0]; // Make the changes, replacing each context element with the new content\n\n      this.domManip(arguments, function (elem) {\n        arg = this.parentNode;\n        jQuery.cleanData(getAll(this));\n\n        if (arg) {\n          arg.replaceChild(elem, this);\n        }\n      }); // Force removal if there was no new content (e.g., from empty arguments)\n\n      return arg && (arg.length || arg.nodeType) ? this : this.remove();\n    },\n    detach: function detach(selector) {\n      return this.remove(selector, true);\n    },\n    domManip: function domManip(args, callback) {\n      // Flatten any nested arrays\n      args = concat.apply([], args);\n      var fragment,\n          first,\n          scripts,\n          hasScripts,\n          node,\n          doc,\n          i = 0,\n          l = this.length,\n          set = this,\n          iNoClone = l - 1,\n          value = args[0],\n          isFunction = jQuery.isFunction(value); // We can't cloneNode fragments that contain checked, in WebKit\n\n      if (isFunction || l > 1 && typeof value === \"string\" && !support.checkClone && rchecked.test(value)) {\n        return this.each(function (index) {\n          var self = set.eq(index);\n\n          if (isFunction) {\n            args[0] = value.call(this, index, self.html());\n          }\n\n          self.domManip(args, callback);\n        });\n      }\n\n      if (l) {\n        fragment = jQuery.buildFragment(args, this[0].ownerDocument, false, this);\n        first = fragment.firstChild;\n\n        if (fragment.childNodes.length === 1) {\n          fragment = first;\n        }\n\n        if (first) {\n          scripts = jQuery.map(getAll(fragment, \"script\"), disableScript);\n          hasScripts = scripts.length; // Use the original fragment for the last item instead of the first because it can end up\n          // being emptied incorrectly in certain situations (#8070).\n\n          for (; i < l; i++) {\n            node = fragment;\n\n            if (i !== iNoClone) {\n              node = jQuery.clone(node, true, true); // Keep references to cloned scripts for later restoration\n\n              if (hasScripts) {\n                // Support: QtWebKit\n                // jQuery.merge because push.apply(_, arraylike) throws\n                jQuery.merge(scripts, getAll(node, \"script\"));\n              }\n            }\n\n            callback.call(this[i], node, i);\n          }\n\n          if (hasScripts) {\n            doc = scripts[scripts.length - 1].ownerDocument; // Reenable scripts\n\n            jQuery.map(scripts, restoreScript); // Evaluate executable scripts on first document insertion\n\n            for (i = 0; i < hasScripts; i++) {\n              node = scripts[i];\n\n              if (rscriptType.test(node.type || \"\") && !data_priv.access(node, \"globalEval\") && jQuery.contains(doc, node)) {\n                if (node.src) {\n                  // Optional AJAX dependency, but won't run scripts if not present\n                  if (jQuery._evalUrl) {\n                    jQuery._evalUrl(node.src);\n                  }\n                } else {\n                  jQuery.globalEval(node.textContent.replace(rcleanScript, \"\"));\n                }\n              }\n            }\n          }\n        }\n      }\n\n      return this;\n    }\n  });\n  jQuery.each({\n    appendTo: \"append\",\n    prependTo: \"prepend\",\n    insertBefore: \"before\",\n    insertAfter: \"after\",\n    replaceAll: \"replaceWith\"\n  }, function (name, original) {\n    jQuery.fn[name] = function (selector) {\n      var elems,\n          ret = [],\n          insert = jQuery(selector),\n          last = insert.length - 1,\n          i = 0;\n\n      for (; i <= last; i++) {\n        elems = i === last ? this : this.clone(true);\n        jQuery(insert[i])[original](elems); // Support: QtWebKit\n        // .get() because push.apply(_, arraylike) throws\n\n        push.apply(ret, elems.get());\n      }\n\n      return this.pushStack(ret);\n    };\n  });\n  var iframe,\n      elemdisplay = {};\n  /**\n   * Retrieve the actual display of a element\n   * @param {String} name nodeName of the element\n   * @param {Object} doc Document object\n   */\n  // Called only from within defaultDisplay\n\n  function actualDisplay(name, doc) {\n    var style,\n        elem = jQuery(doc.createElement(name)).appendTo(doc.body),\n        // getDefaultComputedStyle might be reliably used only on attached element\n    display = window.getDefaultComputedStyle && (style = window.getDefaultComputedStyle(elem[0])) ? // Use of this method is a temporary fix (more like optimization) until something better comes along,\n    // since it was removed from specification and supported only in FF\n    style.display : jQuery.css(elem[0], \"display\"); // We don't have any data stored on the element,\n    // so use \"detach\" method as fast way to get rid of the element\n\n    elem.detach();\n    return display;\n  }\n  /**\n   * Try to determine the default display value of an element\n   * @param {String} nodeName\n   */\n\n\n  function defaultDisplay(nodeName) {\n    var doc = document,\n        display = elemdisplay[nodeName];\n\n    if (!display) {\n      display = actualDisplay(nodeName, doc); // If the simple way fails, read from inside an iframe\n\n      if (display === \"none\" || !display) {\n        // Use the already-created iframe if possible\n        iframe = (iframe || jQuery(\"<iframe frameborder='0' width='0' height='0'/>\")).appendTo(doc.documentElement); // Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse\n\n        doc = iframe[0].contentDocument; // Support: IE\n\n        doc.write();\n        doc.close();\n        display = actualDisplay(nodeName, doc);\n        iframe.detach();\n      } // Store the correct default display\n\n\n      elemdisplay[nodeName] = display;\n    }\n\n    return display;\n  }\n\n  var rmargin = /^margin/;\n  var rnumnonpx = new RegExp(\"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\");\n\n  var getStyles = function getStyles(elem) {\n    // Support: IE<=11+, Firefox<=30+ (#15098, #14150)\n    // IE throws on elements created in popups\n    // FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\n    if (elem.ownerDocument.defaultView.opener) {\n      return elem.ownerDocument.defaultView.getComputedStyle(elem, null);\n    }\n\n    return window.getComputedStyle(elem, null);\n  };\n\n  function curCSS(elem, name, computed) {\n    var width,\n        minWidth,\n        maxWidth,\n        ret,\n        style = elem.style;\n    computed = computed || getStyles(elem); // Support: IE9\n    // getPropertyValue is only needed for .css('filter') (#12537)\n\n    if (computed) {\n      ret = computed.getPropertyValue(name) || computed[name];\n    }\n\n    if (computed) {\n      if (ret === \"\" && !jQuery.contains(elem.ownerDocument, elem)) {\n        ret = jQuery.style(elem, name);\n      } // Support: iOS < 6\n      // A tribute to the \"awesome hack by Dean Edwards\"\n      // iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels\n      // this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values\n\n\n      if (rnumnonpx.test(ret) && rmargin.test(name)) {\n        // Remember the original values\n        width = style.width;\n        minWidth = style.minWidth;\n        maxWidth = style.maxWidth; // Put in the new values to get a computed value out\n\n        style.minWidth = style.maxWidth = style.width = ret;\n        ret = computed.width; // Revert the changed values\n\n        style.width = width;\n        style.minWidth = minWidth;\n        style.maxWidth = maxWidth;\n      }\n    }\n\n    return ret !== undefined ? // Support: IE\n    // IE returns zIndex value as an integer.\n    ret + \"\" : ret;\n  }\n\n  function addGetHookIf(conditionFn, hookFn) {\n    // Define the hook, we'll check on the first run if it's really needed.\n    return {\n      get: function get() {\n        if (conditionFn()) {\n          // Hook not needed (or it's not possible to use it due\n          // to missing dependency), remove it.\n          delete this.get;\n          return;\n        } // Hook needed; redefine it so that the support test is not executed again.\n\n\n        return (this.get = hookFn).apply(this, arguments);\n      }\n    };\n  }\n\n  (function () {\n    var pixelPositionVal,\n        boxSizingReliableVal,\n        docElem = document.documentElement,\n        container = document.createElement(\"div\"),\n        div = document.createElement(\"div\");\n\n    if (!div.style) {\n      return;\n    } // Support: IE9-11+\n    // Style of cloned element affects source element cloned (#8908)\n\n\n    div.style.backgroundClip = \"content-box\";\n    div.cloneNode(true).style.backgroundClip = \"\";\n    support.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n    container.style.cssText = \"border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;\" + \"position:absolute\";\n    container.appendChild(div); // Executing both pixelPosition & boxSizingReliable tests require only one layout\n    // so they're executed at the same time to save the second computation.\n\n    function computePixelPositionAndBoxSizingReliable() {\n      div.style.cssText = // Support: Firefox<29, Android 2.3\n      // Vendor-prefix box-sizing\n      \"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;\" + \"box-sizing:border-box;display:block;margin-top:1%;top:1%;\" + \"border:1px;padding:1px;width:4px;position:absolute\";\n      div.innerHTML = \"\";\n      docElem.appendChild(container);\n      var divStyle = window.getComputedStyle(div, null);\n      pixelPositionVal = divStyle.top !== \"1%\";\n      boxSizingReliableVal = divStyle.width === \"4px\";\n      docElem.removeChild(container);\n    } // Support: node.js jsdom\n    // Don't assume that getComputedStyle is a property of the global object\n\n\n    if (window.getComputedStyle) {\n      jQuery.extend(support, {\n        pixelPosition: function pixelPosition() {\n          // This test is executed only once but we still do memoizing\n          // since we can use the boxSizingReliable pre-computing.\n          // No need to check if the test was already performed, though.\n          computePixelPositionAndBoxSizingReliable();\n          return pixelPositionVal;\n        },\n        boxSizingReliable: function boxSizingReliable() {\n          if (boxSizingReliableVal == null) {\n            computePixelPositionAndBoxSizingReliable();\n          }\n\n          return boxSizingReliableVal;\n        },\n        reliableMarginRight: function reliableMarginRight() {\n          // Support: Android 2.3\n          // Check if div with explicit width and no margin-right incorrectly\n          // gets computed margin-right based on width of container. (#3333)\n          // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\n          // This support function is only executed once so no memoizing is needed.\n          var ret,\n              marginDiv = div.appendChild(document.createElement(\"div\")); // Reset CSS: box-sizing; display; margin; border; padding\n\n          marginDiv.style.cssText = div.style.cssText = // Support: Firefox<29, Android 2.3\n          // Vendor-prefix box-sizing\n          \"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;\" + \"box-sizing:content-box;display:block;margin:0;border:0;padding:0\";\n          marginDiv.style.marginRight = marginDiv.style.width = \"0\";\n          div.style.width = \"1px\";\n          docElem.appendChild(container);\n          ret = !parseFloat(window.getComputedStyle(marginDiv, null).marginRight);\n          docElem.removeChild(container);\n          div.removeChild(marginDiv);\n          return ret;\n        }\n      });\n    }\n  })(); // A method for quickly swapping in/out CSS properties to get correct calculations.\n\n\n  jQuery.swap = function (elem, options, callback, args) {\n    var ret,\n        name,\n        old = {}; // Remember the old values, and insert the new ones\n\n    for (name in options) {\n      old[name] = elem.style[name];\n      elem.style[name] = options[name];\n    }\n\n    ret = callback.apply(elem, args || []); // Revert the old values\n\n    for (name in options) {\n      elem.style[name] = old[name];\n    }\n\n    return ret;\n  };\n\n  var // Swappable if display is none or starts with table except \"table\", \"table-cell\", or \"table-caption\"\n  // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n  rdisplayswap = /^(none|table(?!-c[ea]).+)/,\n      rnumsplit = new RegExp(\"^(\" + pnum + \")(.*)$\", \"i\"),\n      rrelNum = new RegExp(\"^([+-])=(\" + pnum + \")\", \"i\"),\n      cssShow = {\n    position: \"absolute\",\n    visibility: \"hidden\",\n    display: \"block\"\n  },\n      cssNormalTransform = {\n    letterSpacing: \"0\",\n    fontWeight: \"400\"\n  },\n      cssPrefixes = [\"Webkit\", \"O\", \"Moz\", \"ms\"]; // Return a css property mapped to a potentially vendor prefixed property\n\n  function vendorPropName(style, name) {\n    // Shortcut for names that are not vendor prefixed\n    if (name in style) {\n      return name;\n    } // Check for vendor prefixed names\n\n\n    var capName = name[0].toUpperCase() + name.slice(1),\n        origName = name,\n        i = cssPrefixes.length;\n\n    while (i--) {\n      name = cssPrefixes[i] + capName;\n\n      if (name in style) {\n        return name;\n      }\n    }\n\n    return origName;\n  }\n\n  function setPositiveNumber(elem, value, subtract) {\n    var matches = rnumsplit.exec(value);\n    return matches ? // Guard against undefined \"subtract\", e.g., when used as in cssHooks\n    Math.max(0, matches[1] - (subtract || 0)) + (matches[2] || \"px\") : value;\n  }\n\n  function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {\n    var i = extra === (isBorderBox ? \"border\" : \"content\") ? // If we already have the right measurement, avoid augmentation\n    4 : // Otherwise initialize for horizontal or vertical properties\n    name === \"width\" ? 1 : 0,\n        val = 0;\n\n    for (; i < 4; i += 2) {\n      // Both box models exclude margin, so add it if we want it\n      if (extra === \"margin\") {\n        val += jQuery.css(elem, extra + cssExpand[i], true, styles);\n      }\n\n      if (isBorderBox) {\n        // border-box includes padding, so remove it if we want content\n        if (extra === \"content\") {\n          val -= jQuery.css(elem, \"padding\" + cssExpand[i], true, styles);\n        } // At this point, extra isn't border nor margin, so remove border\n\n\n        if (extra !== \"margin\") {\n          val -= jQuery.css(elem, \"border\" + cssExpand[i] + \"Width\", true, styles);\n        }\n      } else {\n        // At this point, extra isn't content, so add padding\n        val += jQuery.css(elem, \"padding\" + cssExpand[i], true, styles); // At this point, extra isn't content nor padding, so add border\n\n        if (extra !== \"padding\") {\n          val += jQuery.css(elem, \"border\" + cssExpand[i] + \"Width\", true, styles);\n        }\n      }\n    }\n\n    return val;\n  }\n\n  function getWidthOrHeight(elem, name, extra) {\n    // Start with offset property, which is equivalent to the border-box value\n    var valueIsBorderBox = true,\n        val = name === \"width\" ? elem.offsetWidth : elem.offsetHeight,\n        styles = getStyles(elem),\n        isBorderBox = jQuery.css(elem, \"boxSizing\", false, styles) === \"border-box\"; // Some non-html elements return undefined for offsetWidth, so check for null/undefined\n    // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285\n    // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668\n\n    if (val <= 0 || val == null) {\n      // Fall back to computed then uncomputed css if necessary\n      val = curCSS(elem, name, styles);\n\n      if (val < 0 || val == null) {\n        val = elem.style[name];\n      } // Computed unit is not pixels. Stop here and return.\n\n\n      if (rnumnonpx.test(val)) {\n        return val;\n      } // Check for style in case a browser which returns unreliable values\n      // for getComputedStyle silently falls back to the reliable elem.style\n\n\n      valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]); // Normalize \"\", auto, and prepare for extra\n\n      val = parseFloat(val) || 0;\n    } // Use the active box-sizing model to add/subtract irrelevant styles\n\n\n    return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? \"border\" : \"content\"), valueIsBorderBox, styles) + \"px\";\n  }\n\n  function showHide(elements, show) {\n    var display,\n        elem,\n        hidden,\n        values = [],\n        index = 0,\n        length = elements.length;\n\n    for (; index < length; index++) {\n      elem = elements[index];\n\n      if (!elem.style) {\n        continue;\n      }\n\n      values[index] = data_priv.get(elem, \"olddisplay\");\n      display = elem.style.display;\n\n      if (show) {\n        // Reset the inline display of this element to learn if it is\n        // being hidden by cascaded rules or not\n        if (!values[index] && display === \"none\") {\n          elem.style.display = \"\";\n        } // Set elements which have been overridden with display: none\n        // in a stylesheet to whatever the default browser style is\n        // for such an element\n\n\n        if (elem.style.display === \"\" && isHidden(elem)) {\n          values[index] = data_priv.access(elem, \"olddisplay\", defaultDisplay(elem.nodeName));\n        }\n      } else {\n        hidden = isHidden(elem);\n\n        if (display !== \"none\" || !hidden) {\n          data_priv.set(elem, \"olddisplay\", hidden ? display : jQuery.css(elem, \"display\"));\n        }\n      }\n    } // Set the display of most of the elements in a second loop\n    // to avoid the constant reflow\n\n\n    for (index = 0; index < length; index++) {\n      elem = elements[index];\n\n      if (!elem.style) {\n        continue;\n      }\n\n      if (!show || elem.style.display === \"none\" || elem.style.display === \"\") {\n        elem.style.display = show ? values[index] || \"\" : \"none\";\n      }\n    }\n\n    return elements;\n  }\n\n  jQuery.extend({\n    // Add in style property hooks for overriding the default\n    // behavior of getting and setting a style property\n    cssHooks: {\n      opacity: {\n        get: function get(elem, computed) {\n          if (computed) {\n            // We should always get a number back from opacity\n            var ret = curCSS(elem, \"opacity\");\n            return ret === \"\" ? \"1\" : ret;\n          }\n        }\n      }\n    },\n    // Don't automatically add \"px\" to these possibly-unitless properties\n    cssNumber: {\n      \"columnCount\": true,\n      \"fillOpacity\": true,\n      \"flexGrow\": true,\n      \"flexShrink\": true,\n      \"fontWeight\": true,\n      \"lineHeight\": true,\n      \"opacity\": true,\n      \"order\": true,\n      \"orphans\": true,\n      \"widows\": true,\n      \"zIndex\": true,\n      \"zoom\": true\n    },\n    // Add in properties whose names you wish to fix before\n    // setting or getting the value\n    cssProps: {\n      \"float\": \"cssFloat\"\n    },\n    // Get and set the style property on a DOM Node\n    style: function style(elem, name, value, extra) {\n      // Don't set styles on text and comment nodes\n      if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {\n        return;\n      } // Make sure that we're working with the right name\n\n\n      var ret,\n          type,\n          hooks,\n          origName = jQuery.camelCase(name),\n          style = elem.style;\n      name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(style, origName)); // Gets hook for the prefixed version, then unprefixed version\n\n      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]; // Check if we're setting a value\n\n      if (value !== undefined) {\n        type = _typeof(value); // Convert \"+=\" or \"-=\" to relative numbers (#7345)\n\n        if (type === \"string\" && (ret = rrelNum.exec(value))) {\n          value = (ret[1] + 1) * ret[2] + parseFloat(jQuery.css(elem, name)); // Fixes bug #9237\n\n          type = \"number\";\n        } // Make sure that null and NaN values aren't set (#7116)\n\n\n        if (value == null || value !== value) {\n          return;\n        } // If a number, add 'px' to the (except for certain CSS properties)\n\n\n        if (type === \"number\" && !jQuery.cssNumber[origName]) {\n          value += \"px\";\n        } // Support: IE9-11+\n        // background-* props affect original clone's values\n\n\n        if (!support.clearCloneStyle && value === \"\" && name.indexOf(\"background\") === 0) {\n          style[name] = \"inherit\";\n        } // If a hook was provided, use that value, otherwise just set the specified value\n\n\n        if (!hooks || !(\"set\" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {\n          style[name] = value;\n        }\n      } else {\n        // If a hook was provided get the non-computed value from there\n        if (hooks && \"get\" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {\n          return ret;\n        } // Otherwise just get the value from the style object\n\n\n        return style[name];\n      }\n    },\n    css: function css(elem, name, extra, styles) {\n      var val,\n          num,\n          hooks,\n          origName = jQuery.camelCase(name); // Make sure that we're working with the right name\n\n      name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(elem.style, origName)); // Try prefixed name followed by the unprefixed name\n\n      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]; // If a hook was provided get the computed value from there\n\n      if (hooks && \"get\" in hooks) {\n        val = hooks.get(elem, true, extra);\n      } // Otherwise, if a way to get the computed value exists, use that\n\n\n      if (val === undefined) {\n        val = curCSS(elem, name, styles);\n      } // Convert \"normal\" to computed value\n\n\n      if (val === \"normal\" && name in cssNormalTransform) {\n        val = cssNormalTransform[name];\n      } // Make numeric if forced or a qualifier was provided and val looks numeric\n\n\n      if (extra === \"\" || extra) {\n        num = parseFloat(val);\n        return extra === true || jQuery.isNumeric(num) ? num || 0 : val;\n      }\n\n      return val;\n    }\n  });\n  jQuery.each([\"height\", \"width\"], function (i, name) {\n    jQuery.cssHooks[name] = {\n      get: function get(elem, computed, extra) {\n        if (computed) {\n          // Certain elements can have dimension info if we invisibly show them\n          // but it must have a current display style that would benefit\n          return rdisplayswap.test(jQuery.css(elem, \"display\")) && elem.offsetWidth === 0 ? jQuery.swap(elem, cssShow, function () {\n            return getWidthOrHeight(elem, name, extra);\n          }) : getWidthOrHeight(elem, name, extra);\n        }\n      },\n      set: function set(elem, value, extra) {\n        var styles = extra && getStyles(elem);\n        return setPositiveNumber(elem, value, extra ? augmentWidthOrHeight(elem, name, extra, jQuery.css(elem, \"boxSizing\", false, styles) === \"border-box\", styles) : 0);\n      }\n    };\n  }); // Support: Android 2.3\n\n  jQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight, function (elem, computed) {\n    if (computed) {\n      return jQuery.swap(elem, {\n        \"display\": \"inline-block\"\n      }, curCSS, [elem, \"marginRight\"]);\n    }\n  }); // These hooks are used by animate to expand properties\n\n  jQuery.each({\n    margin: \"\",\n    padding: \"\",\n    border: \"Width\"\n  }, function (prefix, suffix) {\n    jQuery.cssHooks[prefix + suffix] = {\n      expand: function expand(value) {\n        var i = 0,\n            expanded = {},\n            // Assumes a single number if not a string\n        parts = typeof value === \"string\" ? value.split(\" \") : [value];\n\n        for (; i < 4; i++) {\n          expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];\n        }\n\n        return expanded;\n      }\n    };\n\n    if (!rmargin.test(prefix)) {\n      jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;\n    }\n  });\n  jQuery.fn.extend({\n    css: function css(name, value) {\n      return access(this, function (elem, name, value) {\n        var styles,\n            len,\n            map = {},\n            i = 0;\n\n        if (jQuery.isArray(name)) {\n          styles = getStyles(elem);\n          len = name.length;\n\n          for (; i < len; i++) {\n            map[name[i]] = jQuery.css(elem, name[i], false, styles);\n          }\n\n          return map;\n        }\n\n        return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);\n      }, name, value, arguments.length > 1);\n    },\n    show: function show() {\n      return showHide(this, true);\n    },\n    hide: function hide() {\n      return showHide(this);\n    },\n    toggle: function toggle(state) {\n      if (typeof state === \"boolean\") {\n        return state ? this.show() : this.hide();\n      }\n\n      return this.each(function () {\n        if (isHidden(this)) {\n          jQuery(this).show();\n        } else {\n          jQuery(this).hide();\n        }\n      });\n    }\n  });\n\n  function Tween(elem, options, prop, end, easing) {\n    return new Tween.prototype.init(elem, options, prop, end, easing);\n  }\n\n  jQuery.Tween = Tween;\n  Tween.prototype = {\n    constructor: Tween,\n    init: function init(elem, options, prop, end, easing, unit) {\n      this.elem = elem;\n      this.prop = prop;\n      this.easing = easing || \"swing\";\n      this.options = options;\n      this.start = this.now = this.cur();\n      this.end = end;\n      this.unit = unit || (jQuery.cssNumber[prop] ? \"\" : \"px\");\n    },\n    cur: function cur() {\n      var hooks = Tween.propHooks[this.prop];\n      return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);\n    },\n    run: function run(percent) {\n      var eased,\n          hooks = Tween.propHooks[this.prop];\n\n      if (this.options.duration) {\n        this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);\n      } else {\n        this.pos = eased = percent;\n      }\n\n      this.now = (this.end - this.start) * eased + this.start;\n\n      if (this.options.step) {\n        this.options.step.call(this.elem, this.now, this);\n      }\n\n      if (hooks && hooks.set) {\n        hooks.set(this);\n      } else {\n        Tween.propHooks._default.set(this);\n      }\n\n      return this;\n    }\n  };\n  Tween.prototype.init.prototype = Tween.prototype;\n  Tween.propHooks = {\n    _default: {\n      get: function get(tween) {\n        var result;\n\n        if (tween.elem[tween.prop] != null && (!tween.elem.style || tween.elem.style[tween.prop] == null)) {\n          return tween.elem[tween.prop];\n        } // Passing an empty string as a 3rd parameter to .css will automatically\n        // attempt a parseFloat and fallback to a string if the parse fails.\n        // Simple values such as \"10px\" are parsed to Float;\n        // complex values such as \"rotate(1rad)\" are returned as-is.\n\n\n        result = jQuery.css(tween.elem, tween.prop, \"\"); // Empty strings, null, undefined and \"auto\" are converted to 0.\n\n        return !result || result === \"auto\" ? 0 : result;\n      },\n      set: function set(tween) {\n        // Use step hook for back compat.\n        // Use cssHook if its there.\n        // Use .style if available and use plain properties where available.\n        if (jQuery.fx.step[tween.prop]) {\n          jQuery.fx.step[tween.prop](tween);\n        } else if (tween.elem.style && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {\n          jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);\n        } else {\n          tween.elem[tween.prop] = tween.now;\n        }\n      }\n    }\n  }; // Support: IE9\n  // Panic based approach to setting things on disconnected nodes\n\n  Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n    set: function set(tween) {\n      if (tween.elem.nodeType && tween.elem.parentNode) {\n        tween.elem[tween.prop] = tween.now;\n      }\n    }\n  };\n  jQuery.easing = {\n    linear: function linear(p) {\n      return p;\n    },\n    swing: function swing(p) {\n      return 0.5 - Math.cos(p * Math.PI) / 2;\n    }\n  };\n  jQuery.fx = Tween.prototype.init; // Back Compat <1.8 extension point\n\n  jQuery.fx.step = {};\n  var fxNow,\n      timerId,\n      rfxtypes = /^(?:toggle|show|hide)$/,\n      rfxnum = new RegExp(\"^(?:([+-])=|)(\" + pnum + \")([a-z%]*)$\", \"i\"),\n      rrun = /queueHooks$/,\n      animationPrefilters = [defaultPrefilter],\n      tweeners = {\n    \"*\": [function (prop, value) {\n      var tween = this.createTween(prop, value),\n          target = tween.cur(),\n          parts = rfxnum.exec(value),\n          unit = parts && parts[3] || (jQuery.cssNumber[prop] ? \"\" : \"px\"),\n          // Starting value computation is required for potential unit mismatches\n      start = (jQuery.cssNumber[prop] || unit !== \"px\" && +target) && rfxnum.exec(jQuery.css(tween.elem, prop)),\n          scale = 1,\n          maxIterations = 20;\n\n      if (start && start[3] !== unit) {\n        // Trust units reported by jQuery.css\n        unit = unit || start[3]; // Make sure we update the tween properties later on\n\n        parts = parts || []; // Iteratively approximate from a nonzero starting point\n\n        start = +target || 1;\n\n        do {\n          // If previous iteration zeroed out, double until we get *something*.\n          // Use string for doubling so we don't accidentally see scale as unchanged below\n          scale = scale || \".5\"; // Adjust and apply\n\n          start = start / scale;\n          jQuery.style(tween.elem, prop, start + unit); // Update scale, tolerating zero or NaN from tween.cur(),\n          // break the loop if scale is unchanged or perfect, or if we've just had enough\n        } while (scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations);\n      } // Update tween properties\n\n\n      if (parts) {\n        start = tween.start = +start || +target || 0;\n        tween.unit = unit; // If a +=/-= token was provided, we're doing a relative animation\n\n        tween.end = parts[1] ? start + (parts[1] + 1) * parts[2] : +parts[2];\n      }\n\n      return tween;\n    }]\n  }; // Animations created synchronously will run synchronously\n\n  function createFxNow() {\n    setTimeout(function () {\n      fxNow = undefined;\n    });\n    return fxNow = jQuery.now();\n  } // Generate parameters to create a standard animation\n\n\n  function genFx(type, includeWidth) {\n    var which,\n        i = 0,\n        attrs = {\n      height: type\n    }; // If we include width, step value is 1 to do all cssExpand values,\n    // otherwise step value is 2 to skip over Left and Right\n\n    includeWidth = includeWidth ? 1 : 0;\n\n    for (; i < 4; i += 2 - includeWidth) {\n      which = cssExpand[i];\n      attrs[\"margin\" + which] = attrs[\"padding\" + which] = type;\n    }\n\n    if (includeWidth) {\n      attrs.opacity = attrs.width = type;\n    }\n\n    return attrs;\n  }\n\n  function createTween(value, prop, animation) {\n    var tween,\n        collection = (tweeners[prop] || []).concat(tweeners[\"*\"]),\n        index = 0,\n        length = collection.length;\n\n    for (; index < length; index++) {\n      if (tween = collection[index].call(animation, prop, value)) {\n        // We're done with this property\n        return tween;\n      }\n    }\n  }\n\n  function defaultPrefilter(elem, props, opts) {\n    /* jshint validthis: true */\n    var prop,\n        value,\n        toggle,\n        tween,\n        hooks,\n        oldfire,\n        display,\n        checkDisplay,\n        anim = this,\n        orig = {},\n        style = elem.style,\n        hidden = elem.nodeType && isHidden(elem),\n        dataShow = data_priv.get(elem, \"fxshow\"); // Handle queue: false promises\n\n    if (!opts.queue) {\n      hooks = jQuery._queueHooks(elem, \"fx\");\n\n      if (hooks.unqueued == null) {\n        hooks.unqueued = 0;\n        oldfire = hooks.empty.fire;\n\n        hooks.empty.fire = function () {\n          if (!hooks.unqueued) {\n            oldfire();\n          }\n        };\n      }\n\n      hooks.unqueued++;\n      anim.always(function () {\n        // Ensure the complete handler is called before this completes\n        anim.always(function () {\n          hooks.unqueued--;\n\n          if (!jQuery.queue(elem, \"fx\").length) {\n            hooks.empty.fire();\n          }\n        });\n      });\n    } // Height/width overflow pass\n\n\n    if (elem.nodeType === 1 && (\"height\" in props || \"width\" in props)) {\n      // Make sure that nothing sneaks out\n      // Record all 3 overflow attributes because IE9-10 do not\n      // change the overflow attribute when overflowX and\n      // overflowY are set to the same value\n      opts.overflow = [style.overflow, style.overflowX, style.overflowY]; // Set display property to inline-block for height/width\n      // animations on inline elements that are having width/height animated\n\n      display = jQuery.css(elem, \"display\"); // Test default display if display is currently \"none\"\n\n      checkDisplay = display === \"none\" ? data_priv.get(elem, \"olddisplay\") || defaultDisplay(elem.nodeName) : display;\n\n      if (checkDisplay === \"inline\" && jQuery.css(elem, \"float\") === \"none\") {\n        style.display = \"inline-block\";\n      }\n    }\n\n    if (opts.overflow) {\n      style.overflow = \"hidden\";\n      anim.always(function () {\n        style.overflow = opts.overflow[0];\n        style.overflowX = opts.overflow[1];\n        style.overflowY = opts.overflow[2];\n      });\n    } // show/hide pass\n\n\n    for (prop in props) {\n      value = props[prop];\n\n      if (rfxtypes.exec(value)) {\n        delete props[prop];\n        toggle = toggle || value === \"toggle\";\n\n        if (value === (hidden ? \"hide\" : \"show\")) {\n          // If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden\n          if (value === \"show\" && dataShow && dataShow[prop] !== undefined) {\n            hidden = true;\n          } else {\n            continue;\n          }\n        }\n\n        orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop); // Any non-fx value stops us from restoring the original display value\n      } else {\n        display = undefined;\n      }\n    }\n\n    if (!jQuery.isEmptyObject(orig)) {\n      if (dataShow) {\n        if (\"hidden\" in dataShow) {\n          hidden = dataShow.hidden;\n        }\n      } else {\n        dataShow = data_priv.access(elem, \"fxshow\", {});\n      } // Store state if its toggle - enables .stop().toggle() to \"reverse\"\n\n\n      if (toggle) {\n        dataShow.hidden = !hidden;\n      }\n\n      if (hidden) {\n        jQuery(elem).show();\n      } else {\n        anim.done(function () {\n          jQuery(elem).hide();\n        });\n      }\n\n      anim.done(function () {\n        var prop;\n        data_priv.remove(elem, \"fxshow\");\n\n        for (prop in orig) {\n          jQuery.style(elem, prop, orig[prop]);\n        }\n      });\n\n      for (prop in orig) {\n        tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);\n\n        if (!(prop in dataShow)) {\n          dataShow[prop] = tween.start;\n\n          if (hidden) {\n            tween.end = tween.start;\n            tween.start = prop === \"width\" || prop === \"height\" ? 1 : 0;\n          }\n        }\n      } // If this is a noop like .hide().hide(), restore an overwritten display value\n\n    } else if ((display === \"none\" ? defaultDisplay(elem.nodeName) : display) === \"inline\") {\n      style.display = display;\n    }\n  }\n\n  function propFilter(props, specialEasing) {\n    var index, name, easing, value, hooks; // camelCase, specialEasing and expand cssHook pass\n\n    for (index in props) {\n      name = jQuery.camelCase(index);\n      easing = specialEasing[name];\n      value = props[index];\n\n      if (jQuery.isArray(value)) {\n        easing = value[1];\n        value = props[index] = value[0];\n      }\n\n      if (index !== name) {\n        props[name] = value;\n        delete props[index];\n      }\n\n      hooks = jQuery.cssHooks[name];\n\n      if (hooks && \"expand\" in hooks) {\n        value = hooks.expand(value);\n        delete props[name]; // Not quite $.extend, this won't overwrite existing keys.\n        // Reusing 'index' because we have the correct \"name\"\n\n        for (index in value) {\n          if (!(index in props)) {\n            props[index] = value[index];\n            specialEasing[index] = easing;\n          }\n        }\n      } else {\n        specialEasing[name] = easing;\n      }\n    }\n  }\n\n  function Animation(elem, properties, options) {\n    var result,\n        stopped,\n        index = 0,\n        length = animationPrefilters.length,\n        deferred = jQuery.Deferred().always(function () {\n      // Don't match elem in the :animated selector\n      delete tick.elem;\n    }),\n        tick = function tick() {\n      if (stopped) {\n        return false;\n      }\n\n      var currentTime = fxNow || createFxNow(),\n          remaining = Math.max(0, animation.startTime + animation.duration - currentTime),\n          // Support: Android 2.3\n      // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)\n      temp = remaining / animation.duration || 0,\n          percent = 1 - temp,\n          index = 0,\n          length = animation.tweens.length;\n\n      for (; index < length; index++) {\n        animation.tweens[index].run(percent);\n      }\n\n      deferred.notifyWith(elem, [animation, percent, remaining]);\n\n      if (percent < 1 && length) {\n        return remaining;\n      } else {\n        deferred.resolveWith(elem, [animation]);\n        return false;\n      }\n    },\n        animation = deferred.promise({\n      elem: elem,\n      props: jQuery.extend({}, properties),\n      opts: jQuery.extend(true, {\n        specialEasing: {}\n      }, options),\n      originalProperties: properties,\n      originalOptions: options,\n      startTime: fxNow || createFxNow(),\n      duration: options.duration,\n      tweens: [],\n      createTween: function createTween(prop, end) {\n        var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);\n        animation.tweens.push(tween);\n        return tween;\n      },\n      stop: function stop(gotoEnd) {\n        var index = 0,\n            // If we are going to the end, we want to run all the tweens\n        // otherwise we skip this part\n        length = gotoEnd ? animation.tweens.length : 0;\n\n        if (stopped) {\n          return this;\n        }\n\n        stopped = true;\n\n        for (; index < length; index++) {\n          animation.tweens[index].run(1);\n        } // Resolve when we played the last frame; otherwise, reject\n\n\n        if (gotoEnd) {\n          deferred.resolveWith(elem, [animation, gotoEnd]);\n        } else {\n          deferred.rejectWith(elem, [animation, gotoEnd]);\n        }\n\n        return this;\n      }\n    }),\n        props = animation.props;\n\n    propFilter(props, animation.opts.specialEasing);\n\n    for (; index < length; index++) {\n      result = animationPrefilters[index].call(animation, elem, props, animation.opts);\n\n      if (result) {\n        return result;\n      }\n    }\n\n    jQuery.map(props, createTween, animation);\n\n    if (jQuery.isFunction(animation.opts.start)) {\n      animation.opts.start.call(elem, animation);\n    }\n\n    jQuery.fx.timer(jQuery.extend(tick, {\n      elem: elem,\n      anim: animation,\n      queue: animation.opts.queue\n    })); // attach callbacks from options\n\n    return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);\n  }\n\n  jQuery.Animation = jQuery.extend(Animation, {\n    tweener: function tweener(props, callback) {\n      if (jQuery.isFunction(props)) {\n        callback = props;\n        props = [\"*\"];\n      } else {\n        props = props.split(\" \");\n      }\n\n      var prop,\n          index = 0,\n          length = props.length;\n\n      for (; index < length; index++) {\n        prop = props[index];\n        tweeners[prop] = tweeners[prop] || [];\n        tweeners[prop].unshift(callback);\n      }\n    },\n    prefilter: function prefilter(callback, prepend) {\n      if (prepend) {\n        animationPrefilters.unshift(callback);\n      } else {\n        animationPrefilters.push(callback);\n      }\n    }\n  });\n\n  jQuery.speed = function (speed, easing, fn) {\n    var opt = speed && _typeof(speed) === \"object\" ? jQuery.extend({}, speed) : {\n      complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,\n      duration: speed,\n      easing: fn && easing || easing && !jQuery.isFunction(easing) && easing\n    };\n    opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === \"number\" ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default; // Normalize opt.queue - true/undefined/null -> \"fx\"\n\n    if (opt.queue == null || opt.queue === true) {\n      opt.queue = \"fx\";\n    } // Queueing\n\n\n    opt.old = opt.complete;\n\n    opt.complete = function () {\n      if (jQuery.isFunction(opt.old)) {\n        opt.old.call(this);\n      }\n\n      if (opt.queue) {\n        jQuery.dequeue(this, opt.queue);\n      }\n    };\n\n    return opt;\n  };\n\n  jQuery.fn.extend({\n    fadeTo: function fadeTo(speed, to, easing, callback) {\n      // Show any hidden elements after setting opacity to 0\n      return this.filter(isHidden).css(\"opacity\", 0).show() // Animate to the value specified\n      .end().animate({\n        opacity: to\n      }, speed, easing, callback);\n    },\n    animate: function animate(prop, speed, easing, callback) {\n      var empty = jQuery.isEmptyObject(prop),\n          optall = jQuery.speed(speed, easing, callback),\n          doAnimation = function doAnimation() {\n        // Operate on a copy of prop so per-property easing won't be lost\n        var anim = Animation(this, jQuery.extend({}, prop), optall); // Empty animations, or finishing resolves immediately\n\n        if (empty || data_priv.get(this, \"finish\")) {\n          anim.stop(true);\n        }\n      };\n\n      doAnimation.finish = doAnimation;\n      return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);\n    },\n    stop: function stop(type, clearQueue, gotoEnd) {\n      var stopQueue = function stopQueue(hooks) {\n        var stop = hooks.stop;\n        delete hooks.stop;\n        stop(gotoEnd);\n      };\n\n      if (typeof type !== \"string\") {\n        gotoEnd = clearQueue;\n        clearQueue = type;\n        type = undefined;\n      }\n\n      if (clearQueue && type !== false) {\n        this.queue(type || \"fx\", []);\n      }\n\n      return this.each(function () {\n        var dequeue = true,\n            index = type != null && type + \"queueHooks\",\n            timers = jQuery.timers,\n            data = data_priv.get(this);\n\n        if (index) {\n          if (data[index] && data[index].stop) {\n            stopQueue(data[index]);\n          }\n        } else {\n          for (index in data) {\n            if (data[index] && data[index].stop && rrun.test(index)) {\n              stopQueue(data[index]);\n            }\n          }\n        }\n\n        for (index = timers.length; index--;) {\n          if (timers[index].elem === this && (type == null || timers[index].queue === type)) {\n            timers[index].anim.stop(gotoEnd);\n            dequeue = false;\n            timers.splice(index, 1);\n          }\n        } // Start the next in the queue if the last step wasn't forced.\n        // Timers currently will call their complete callbacks, which\n        // will dequeue but only if they were gotoEnd.\n\n\n        if (dequeue || !gotoEnd) {\n          jQuery.dequeue(this, type);\n        }\n      });\n    },\n    finish: function finish(type) {\n      if (type !== false) {\n        type = type || \"fx\";\n      }\n\n      return this.each(function () {\n        var index,\n            data = data_priv.get(this),\n            queue = data[type + \"queue\"],\n            hooks = data[type + \"queueHooks\"],\n            timers = jQuery.timers,\n            length = queue ? queue.length : 0; // Enable finishing flag on private data\n\n        data.finish = true; // Empty the queue first\n\n        jQuery.queue(this, type, []);\n\n        if (hooks && hooks.stop) {\n          hooks.stop.call(this, true);\n        } // Look for any active animations, and finish them\n\n\n        for (index = timers.length; index--;) {\n          if (timers[index].elem === this && timers[index].queue === type) {\n            timers[index].anim.stop(true);\n            timers.splice(index, 1);\n          }\n        } // Look for any animations in the old queue and finish them\n\n\n        for (index = 0; index < length; index++) {\n          if (queue[index] && queue[index].finish) {\n            queue[index].finish.call(this);\n          }\n        } // Turn off finishing flag\n\n\n        delete data.finish;\n      });\n    }\n  });\n  jQuery.each([\"toggle\", \"show\", \"hide\"], function (i, name) {\n    var cssFn = jQuery.fn[name];\n\n    jQuery.fn[name] = function (speed, easing, callback) {\n      return speed == null || typeof speed === \"boolean\" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);\n    };\n  }); // Generate shortcuts for custom animations\n\n  jQuery.each({\n    slideDown: genFx(\"show\"),\n    slideUp: genFx(\"hide\"),\n    slideToggle: genFx(\"toggle\"),\n    fadeIn: {\n      opacity: \"show\"\n    },\n    fadeOut: {\n      opacity: \"hide\"\n    },\n    fadeToggle: {\n      opacity: \"toggle\"\n    }\n  }, function (name, props) {\n    jQuery.fn[name] = function (speed, easing, callback) {\n      return this.animate(props, speed, easing, callback);\n    };\n  });\n  jQuery.timers = [];\n\n  jQuery.fx.tick = function () {\n    var timer,\n        i = 0,\n        timers = jQuery.timers;\n    fxNow = jQuery.now();\n\n    for (; i < timers.length; i++) {\n      timer = timers[i]; // Checks the timer has not already been removed\n\n      if (!timer() && timers[i] === timer) {\n        timers.splice(i--, 1);\n      }\n    }\n\n    if (!timers.length) {\n      jQuery.fx.stop();\n    }\n\n    fxNow = undefined;\n  };\n\n  jQuery.fx.timer = function (timer) {\n    jQuery.timers.push(timer);\n\n    if (timer()) {\n      jQuery.fx.start();\n    } else {\n      jQuery.timers.pop();\n    }\n  };\n\n  jQuery.fx.interval = 13;\n\n  jQuery.fx.start = function () {\n    if (!timerId) {\n      timerId = setInterval(jQuery.fx.tick, jQuery.fx.interval);\n    }\n  };\n\n  jQuery.fx.stop = function () {\n    clearInterval(timerId);\n    timerId = null;\n  };\n\n  jQuery.fx.speeds = {\n    slow: 600,\n    fast: 200,\n    // Default speed\n    _default: 400\n  }; // Based off of the plugin by Clint Helfers, with permission.\n  // http://blindsignals.com/index.php/2009/07/jquery-delay/\n\n  jQuery.fn.delay = function (time, type) {\n    time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;\n    type = type || \"fx\";\n    return this.queue(type, function (next, hooks) {\n      var timeout = setTimeout(next, time);\n\n      hooks.stop = function () {\n        clearTimeout(timeout);\n      };\n    });\n  };\n\n  (function () {\n    var input = document.createElement(\"input\"),\n        select = document.createElement(\"select\"),\n        opt = select.appendChild(document.createElement(\"option\"));\n    input.type = \"checkbox\"; // Support: iOS<=5.1, Android<=4.2+\n    // Default value for a checkbox should be \"on\"\n\n    support.checkOn = input.value !== \"\"; // Support: IE<=11+\n    // Must access selectedIndex to make default options select\n\n    support.optSelected = opt.selected; // Support: Android<=2.3\n    // Options inside disabled selects are incorrectly marked as disabled\n\n    select.disabled = true;\n    support.optDisabled = !opt.disabled; // Support: IE<=11+\n    // An input loses its value after becoming a radio\n\n    input = document.createElement(\"input\");\n    input.value = \"t\";\n    input.type = \"radio\";\n    support.radioValue = input.value === \"t\";\n  })();\n\n  var nodeHook,\n      boolHook,\n      attrHandle = jQuery.expr.attrHandle;\n  jQuery.fn.extend({\n    attr: function attr(name, value) {\n      return access(this, jQuery.attr, name, value, arguments.length > 1);\n    },\n    removeAttr: function removeAttr(name) {\n      return this.each(function () {\n        jQuery.removeAttr(this, name);\n      });\n    }\n  });\n  jQuery.extend({\n    attr: function attr(elem, name, value) {\n      var hooks,\n          ret,\n          nType = elem.nodeType; // don't get/set attributes on text, comment and attribute nodes\n\n      if (!elem || nType === 3 || nType === 8 || nType === 2) {\n        return;\n      } // Fallback to prop when attributes are not supported\n\n\n      if (_typeof(elem.getAttribute) === strundefined) {\n        return jQuery.prop(elem, name, value);\n      } // All attributes are lowercase\n      // Grab necessary hook if one is defined\n\n\n      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {\n        name = name.toLowerCase();\n        hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : nodeHook);\n      }\n\n      if (value !== undefined) {\n        if (value === null) {\n          jQuery.removeAttr(elem, name);\n        } else if (hooks && \"set\" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {\n          return ret;\n        } else {\n          elem.setAttribute(name, value + \"\");\n          return value;\n        }\n      } else if (hooks && \"get\" in hooks && (ret = hooks.get(elem, name)) !== null) {\n        return ret;\n      } else {\n        ret = jQuery.find.attr(elem, name); // Non-existent attributes return null, we normalize to undefined\n\n        return ret == null ? undefined : ret;\n      }\n    },\n    removeAttr: function removeAttr(elem, value) {\n      var name,\n          propName,\n          i = 0,\n          attrNames = value && value.match(rnotwhite);\n\n      if (attrNames && elem.nodeType === 1) {\n        while (name = attrNames[i++]) {\n          propName = jQuery.propFix[name] || name; // Boolean attributes get special treatment (#10870)\n\n          if (jQuery.expr.match.bool.test(name)) {\n            // Set corresponding property to false\n            elem[propName] = false;\n          }\n\n          elem.removeAttribute(name);\n        }\n      }\n    },\n    attrHooks: {\n      type: {\n        set: function set(elem, value) {\n          if (!support.radioValue && value === \"radio\" && jQuery.nodeName(elem, \"input\")) {\n            var val = elem.value;\n            elem.setAttribute(\"type\", value);\n\n            if (val) {\n              elem.value = val;\n            }\n\n            return value;\n          }\n        }\n      }\n    }\n  }); // Hooks for boolean attributes\n\n  boolHook = {\n    set: function set(elem, value, name) {\n      if (value === false) {\n        // Remove boolean attributes when set to false\n        jQuery.removeAttr(elem, name);\n      } else {\n        elem.setAttribute(name, name);\n      }\n\n      return name;\n    }\n  };\n  jQuery.each(jQuery.expr.match.bool.source.match(/\\w+/g), function (i, name) {\n    var getter = attrHandle[name] || jQuery.find.attr;\n\n    attrHandle[name] = function (elem, name, isXML) {\n      var ret, handle;\n\n      if (!isXML) {\n        // Avoid an infinite loop by temporarily removing this function from the getter\n        handle = attrHandle[name];\n        attrHandle[name] = ret;\n        ret = getter(elem, name, isXML) != null ? name.toLowerCase() : null;\n        attrHandle[name] = handle;\n      }\n\n      return ret;\n    };\n  });\n  var rfocusable = /^(?:input|select|textarea|button)$/i;\n  jQuery.fn.extend({\n    prop: function prop(name, value) {\n      return access(this, jQuery.prop, name, value, arguments.length > 1);\n    },\n    removeProp: function removeProp(name) {\n      return this.each(function () {\n        delete this[jQuery.propFix[name] || name];\n      });\n    }\n  });\n  jQuery.extend({\n    propFix: {\n      \"for\": \"htmlFor\",\n      \"class\": \"className\"\n    },\n    prop: function prop(elem, name, value) {\n      var ret,\n          hooks,\n          notxml,\n          nType = elem.nodeType; // Don't get/set properties on text, comment and attribute nodes\n\n      if (!elem || nType === 3 || nType === 8 || nType === 2) {\n        return;\n      }\n\n      notxml = nType !== 1 || !jQuery.isXMLDoc(elem);\n\n      if (notxml) {\n        // Fix name and attach hooks\n        name = jQuery.propFix[name] || name;\n        hooks = jQuery.propHooks[name];\n      }\n\n      if (value !== undefined) {\n        return hooks && \"set\" in hooks && (ret = hooks.set(elem, value, name)) !== undefined ? ret : elem[name] = value;\n      } else {\n        return hooks && \"get\" in hooks && (ret = hooks.get(elem, name)) !== null ? ret : elem[name];\n      }\n    },\n    propHooks: {\n      tabIndex: {\n        get: function get(elem) {\n          return elem.hasAttribute(\"tabindex\") || rfocusable.test(elem.nodeName) || elem.href ? elem.tabIndex : -1;\n        }\n      }\n    }\n  });\n\n  if (!support.optSelected) {\n    jQuery.propHooks.selected = {\n      get: function get(elem) {\n        var parent = elem.parentNode;\n\n        if (parent && parent.parentNode) {\n          parent.parentNode.selectedIndex;\n        }\n\n        return null;\n      }\n    };\n  }\n\n  jQuery.each([\"tabIndex\", \"readOnly\", \"maxLength\", \"cellSpacing\", \"cellPadding\", \"rowSpan\", \"colSpan\", \"useMap\", \"frameBorder\", \"contentEditable\"], function () {\n    jQuery.propFix[this.toLowerCase()] = this;\n  });\n  var rclass = /[\\t\\r\\n\\f]/g;\n  jQuery.fn.extend({\n    addClass: function addClass(value) {\n      var classes,\n          elem,\n          cur,\n          clazz,\n          j,\n          finalValue,\n          proceed = typeof value === \"string\" && value,\n          i = 0,\n          len = this.length;\n\n      if (jQuery.isFunction(value)) {\n        return this.each(function (j) {\n          jQuery(this).addClass(value.call(this, j, this.className));\n        });\n      }\n\n      if (proceed) {\n        // The disjunction here is for better compressibility (see removeClass)\n        classes = (value || \"\").match(rnotwhite) || [];\n\n        for (; i < len; i++) {\n          elem = this[i];\n          cur = elem.nodeType === 1 && (elem.className ? (\" \" + elem.className + \" \").replace(rclass, \" \") : \" \");\n\n          if (cur) {\n            j = 0;\n\n            while (clazz = classes[j++]) {\n              if (cur.indexOf(\" \" + clazz + \" \") < 0) {\n                cur += clazz + \" \";\n              }\n            } // only assign if different to avoid unneeded rendering.\n\n\n            finalValue = jQuery.trim(cur);\n\n            if (elem.className !== finalValue) {\n              elem.className = finalValue;\n            }\n          }\n        }\n      }\n\n      return this;\n    },\n    removeClass: function removeClass(value) {\n      var classes,\n          elem,\n          cur,\n          clazz,\n          j,\n          finalValue,\n          proceed = arguments.length === 0 || typeof value === \"string\" && value,\n          i = 0,\n          len = this.length;\n\n      if (jQuery.isFunction(value)) {\n        return this.each(function (j) {\n          jQuery(this).removeClass(value.call(this, j, this.className));\n        });\n      }\n\n      if (proceed) {\n        classes = (value || \"\").match(rnotwhite) || [];\n\n        for (; i < len; i++) {\n          elem = this[i]; // This expression is here for better compressibility (see addClass)\n\n          cur = elem.nodeType === 1 && (elem.className ? (\" \" + elem.className + \" \").replace(rclass, \" \") : \"\");\n\n          if (cur) {\n            j = 0;\n\n            while (clazz = classes[j++]) {\n              // Remove *all* instances\n              while (cur.indexOf(\" \" + clazz + \" \") >= 0) {\n                cur = cur.replace(\" \" + clazz + \" \", \" \");\n              }\n            } // Only assign if different to avoid unneeded rendering.\n\n\n            finalValue = value ? jQuery.trim(cur) : \"\";\n\n            if (elem.className !== finalValue) {\n              elem.className = finalValue;\n            }\n          }\n        }\n      }\n\n      return this;\n    },\n    toggleClass: function toggleClass(value, stateVal) {\n      var type = _typeof(value);\n\n      if (typeof stateVal === \"boolean\" && type === \"string\") {\n        return stateVal ? this.addClass(value) : this.removeClass(value);\n      }\n\n      if (jQuery.isFunction(value)) {\n        return this.each(function (i) {\n          jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);\n        });\n      }\n\n      return this.each(function () {\n        if (type === \"string\") {\n          // Toggle individual class names\n          var className,\n              i = 0,\n              self = jQuery(this),\n              classNames = value.match(rnotwhite) || [];\n\n          while (className = classNames[i++]) {\n            // Check each className given, space separated list\n            if (self.hasClass(className)) {\n              self.removeClass(className);\n            } else {\n              self.addClass(className);\n            }\n          } // Toggle whole class name\n\n        } else if (type === strundefined || type === \"boolean\") {\n          if (this.className) {\n            // store className if set\n            data_priv.set(this, \"__className__\", this.className);\n          } // If the element has a class name or if we're passed `false`,\n          // then remove the whole classname (if there was one, the above saved it).\n          // Otherwise bring back whatever was previously saved (if anything),\n          // falling back to the empty string if nothing was stored.\n\n\n          this.className = this.className || value === false ? \"\" : data_priv.get(this, \"__className__\") || \"\";\n        }\n      });\n    },\n    hasClass: function hasClass(selector) {\n      var className = \" \" + selector + \" \",\n          i = 0,\n          l = this.length;\n\n      for (; i < l; i++) {\n        if (this[i].nodeType === 1 && (\" \" + this[i].className + \" \").replace(rclass, \" \").indexOf(className) >= 0) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n  });\n  var rreturn = /\\r/g;\n  jQuery.fn.extend({\n    val: function val(value) {\n      var hooks,\n          ret,\n          isFunction,\n          elem = this[0];\n\n      if (!arguments.length) {\n        if (elem) {\n          hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];\n\n          if (hooks && \"get\" in hooks && (ret = hooks.get(elem, \"value\")) !== undefined) {\n            return ret;\n          }\n\n          ret = elem.value;\n          return typeof ret === \"string\" ? // Handle most common string cases\n          ret.replace(rreturn, \"\") : // Handle cases where value is null/undef or number\n          ret == null ? \"\" : ret;\n        }\n\n        return;\n      }\n\n      isFunction = jQuery.isFunction(value);\n      return this.each(function (i) {\n        var val;\n\n        if (this.nodeType !== 1) {\n          return;\n        }\n\n        if (isFunction) {\n          val = value.call(this, i, jQuery(this).val());\n        } else {\n          val = value;\n        } // Treat null/undefined as \"\"; convert numbers to string\n\n\n        if (val == null) {\n          val = \"\";\n        } else if (typeof val === \"number\") {\n          val += \"\";\n        } else if (jQuery.isArray(val)) {\n          val = jQuery.map(val, function (value) {\n            return value == null ? \"\" : value + \"\";\n          });\n        }\n\n        hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()]; // If set returns undefined, fall back to normal setting\n\n        if (!hooks || !(\"set\" in hooks) || hooks.set(this, val, \"value\") === undefined) {\n          this.value = val;\n        }\n      });\n    }\n  });\n  jQuery.extend({\n    valHooks: {\n      option: {\n        get: function get(elem) {\n          var val = jQuery.find.attr(elem, \"value\");\n          return val != null ? val : // Support: IE10-11+\n          // option.text throws exceptions (#14686, #14858)\n          jQuery.trim(jQuery.text(elem));\n        }\n      },\n      select: {\n        get: function get(elem) {\n          var value,\n              option,\n              options = elem.options,\n              index = elem.selectedIndex,\n              one = elem.type === \"select-one\" || index < 0,\n              values = one ? null : [],\n              max = one ? index + 1 : options.length,\n              i = index < 0 ? max : one ? index : 0; // Loop through all the selected options\n\n          for (; i < max; i++) {\n            option = options[i]; // IE6-9 doesn't update selected after form reset (#2551)\n\n            if ((option.selected || i === index) && ( // Don't return options that are disabled or in a disabled optgroup\n            support.optDisabled ? !option.disabled : option.getAttribute(\"disabled\") === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, \"optgroup\"))) {\n              // Get the specific value for the option\n              value = jQuery(option).val(); // We don't need an array for one selects\n\n              if (one) {\n                return value;\n              } // Multi-Selects return an array\n\n\n              values.push(value);\n            }\n          }\n\n          return values;\n        },\n        set: function set(elem, value) {\n          var optionSet,\n              option,\n              options = elem.options,\n              values = jQuery.makeArray(value),\n              i = options.length;\n\n          while (i--) {\n            option = options[i];\n\n            if (option.selected = jQuery.inArray(option.value, values) >= 0) {\n              optionSet = true;\n            }\n          } // Force browsers to behave consistently when non-matching value is set\n\n\n          if (!optionSet) {\n            elem.selectedIndex = -1;\n          }\n\n          return values;\n        }\n      }\n    }\n  }); // Radios and checkboxes getter/setter\n\n  jQuery.each([\"radio\", \"checkbox\"], function () {\n    jQuery.valHooks[this] = {\n      set: function set(elem, value) {\n        if (jQuery.isArray(value)) {\n          return elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0;\n        }\n      }\n    };\n\n    if (!support.checkOn) {\n      jQuery.valHooks[this].get = function (elem) {\n        return elem.getAttribute(\"value\") === null ? \"on\" : elem.value;\n      };\n    }\n  }); // Return jQuery for attributes-only inclusion\n\n  jQuery.each((\"blur focus focusin focusout load resize scroll unload click dblclick \" + \"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" + \"change select submit keydown keypress keyup error contextmenu\").split(\" \"), function (i, name) {\n    // Handle event binding\n    jQuery.fn[name] = function (data, fn) {\n      return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);\n    };\n  });\n  jQuery.fn.extend({\n    hover: function hover(fnOver, fnOut) {\n      return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);\n    },\n    bind: function bind(types, data, fn) {\n      return this.on(types, null, data, fn);\n    },\n    unbind: function unbind(types, fn) {\n      return this.off(types, null, fn);\n    },\n    delegate: function delegate(selector, types, data, fn) {\n      return this.on(types, selector, data, fn);\n    },\n    undelegate: function undelegate(selector, types, fn) {\n      // ( namespace ) or ( selector, types [, fn] )\n      return arguments.length === 1 ? this.off(selector, \"**\") : this.off(types, selector || \"**\", fn);\n    }\n  });\n  var nonce = jQuery.now();\n  var rquery = /\\?/; // Support: Android 2.3\n  // Workaround failure to string-cast null input\n\n  jQuery.parseJSON = function (data) {\n    return JSON.parse(data + \"\");\n  }; // Cross-browser xml parsing\n\n\n  jQuery.parseXML = function (data) {\n    var xml, tmp;\n\n    if (!data || typeof data !== \"string\") {\n      return null;\n    } // Support: IE9\n\n\n    try {\n      tmp = new DOMParser();\n      xml = tmp.parseFromString(data, \"text/xml\");\n    } catch (e) {\n      xml = undefined;\n    }\n\n    if (!xml || xml.getElementsByTagName(\"parsererror\").length) {\n      jQuery.error(\"Invalid XML: \" + data);\n    }\n\n    return xml;\n  };\n\n  var rhash = /#.*$/,\n      rts = /([?&])_=[^&]*/,\n      rheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\n      // #7653, #8125, #8152: local protocol detection\n  rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n      rnoContent = /^(?:GET|HEAD)$/,\n      rprotocol = /^\\/\\//,\n      rurl = /^([\\w.+-]+:)(?:\\/\\/(?:[^\\/?#]*@|)([^\\/?#:]*)(?::(\\d+)|)|)/,\n\n  /* Prefilters\n   * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n   * 2) These are called:\n   *    - BEFORE asking for a transport\n   *    - AFTER param serialization (s.data is a string if s.processData is true)\n   * 3) key is the dataType\n   * 4) the catchall symbol \"*\" can be used\n   * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n   */\n  prefilters = {},\n\n  /* Transports bindings\n   * 1) key is the dataType\n   * 2) the catchall symbol \"*\" can be used\n   * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n   */\n  transports = {},\n      // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n  allTypes = \"*/\".concat(\"*\"),\n      // Document location\n  ajaxLocation = window.location.href,\n      // Segment location into parts\n  ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || []; // Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\n\n  function addToPrefiltersOrTransports(structure) {\n    // dataTypeExpression is optional and defaults to \"*\"\n    return function (dataTypeExpression, func) {\n      if (typeof dataTypeExpression !== \"string\") {\n        func = dataTypeExpression;\n        dataTypeExpression = \"*\";\n      }\n\n      var dataType,\n          i = 0,\n          dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];\n\n      if (jQuery.isFunction(func)) {\n        // For each dataType in the dataTypeExpression\n        while (dataType = dataTypes[i++]) {\n          // Prepend if requested\n          if (dataType[0] === \"+\") {\n            dataType = dataType.slice(1) || \"*\";\n            (structure[dataType] = structure[dataType] || []).unshift(func); // Otherwise append\n          } else {\n            (structure[dataType] = structure[dataType] || []).push(func);\n          }\n        }\n      }\n    };\n  } // Base inspection function for prefilters and transports\n\n\n  function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {\n    var inspected = {},\n        seekingTransport = structure === transports;\n\n    function inspect(dataType) {\n      var selected;\n      inspected[dataType] = true;\n      jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {\n        var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);\n\n        if (typeof dataTypeOrTransport === \"string\" && !seekingTransport && !inspected[dataTypeOrTransport]) {\n          options.dataTypes.unshift(dataTypeOrTransport);\n          inspect(dataTypeOrTransport);\n          return false;\n        } else if (seekingTransport) {\n          return !(selected = dataTypeOrTransport);\n        }\n      });\n      return selected;\n    }\n\n    return inspect(options.dataTypes[0]) || !inspected[\"*\"] && inspect(\"*\");\n  } // A special extend for ajax options\n  // that takes \"flat\" options (not to be deep extended)\n  // Fixes #9887\n\n\n  function ajaxExtend(target, src) {\n    var key,\n        deep,\n        flatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n    for (key in src) {\n      if (src[key] !== undefined) {\n        (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];\n      }\n    }\n\n    if (deep) {\n      jQuery.extend(true, target, deep);\n    }\n\n    return target;\n  }\n  /* Handles responses to an ajax request:\n   * - finds the right dataType (mediates between content-type and expected dataType)\n   * - returns the corresponding response\n   */\n\n\n  function ajaxHandleResponses(s, jqXHR, responses) {\n    var ct,\n        type,\n        finalDataType,\n        firstDataType,\n        contents = s.contents,\n        dataTypes = s.dataTypes; // Remove auto dataType and get content-type in the process\n\n    while (dataTypes[0] === \"*\") {\n      dataTypes.shift();\n\n      if (ct === undefined) {\n        ct = s.mimeType || jqXHR.getResponseHeader(\"Content-Type\");\n      }\n    } // Check if we're dealing with a known content-type\n\n\n    if (ct) {\n      for (type in contents) {\n        if (contents[type] && contents[type].test(ct)) {\n          dataTypes.unshift(type);\n          break;\n        }\n      }\n    } // Check to see if we have a response for the expected dataType\n\n\n    if (dataTypes[0] in responses) {\n      finalDataType = dataTypes[0];\n    } else {\n      // Try convertible dataTypes\n      for (type in responses) {\n        if (!dataTypes[0] || s.converters[type + \" \" + dataTypes[0]]) {\n          finalDataType = type;\n          break;\n        }\n\n        if (!firstDataType) {\n          firstDataType = type;\n        }\n      } // Or just use first one\n\n\n      finalDataType = finalDataType || firstDataType;\n    } // If we found a dataType\n    // We add the dataType to the list if needed\n    // and return the corresponding response\n\n\n    if (finalDataType) {\n      if (finalDataType !== dataTypes[0]) {\n        dataTypes.unshift(finalDataType);\n      }\n\n      return responses[finalDataType];\n    }\n  }\n  /* Chain conversions given the request and the original response\n   * Also sets the responseXXX fields on the jqXHR instance\n   */\n\n\n  function ajaxConvert(s, response, jqXHR, isSuccess) {\n    var conv2,\n        current,\n        conv,\n        tmp,\n        prev,\n        converters = {},\n        // Work with a copy of dataTypes in case we need to modify it for conversion\n    dataTypes = s.dataTypes.slice(); // Create converters map with lowercased keys\n\n    if (dataTypes[1]) {\n      for (conv in s.converters) {\n        converters[conv.toLowerCase()] = s.converters[conv];\n      }\n    }\n\n    current = dataTypes.shift(); // Convert to each sequential dataType\n\n    while (current) {\n      if (s.responseFields[current]) {\n        jqXHR[s.responseFields[current]] = response;\n      } // Apply the dataFilter if provided\n\n\n      if (!prev && isSuccess && s.dataFilter) {\n        response = s.dataFilter(response, s.dataType);\n      }\n\n      prev = current;\n      current = dataTypes.shift();\n\n      if (current) {\n        // There's only work to do if current dataType is non-auto\n        if (current === \"*\") {\n          current = prev; // Convert response if prev dataType is non-auto and differs from current\n        } else if (prev !== \"*\" && prev !== current) {\n          // Seek a direct converter\n          conv = converters[prev + \" \" + current] || converters[\"* \" + current]; // If none found, seek a pair\n\n          if (!conv) {\n            for (conv2 in converters) {\n              // If conv2 outputs current\n              tmp = conv2.split(\" \");\n\n              if (tmp[1] === current) {\n                // If prev can be converted to accepted input\n                conv = converters[prev + \" \" + tmp[0]] || converters[\"* \" + tmp[0]];\n\n                if (conv) {\n                  // Condense equivalence converters\n                  if (conv === true) {\n                    conv = converters[conv2]; // Otherwise, insert the intermediate dataType\n                  } else if (converters[conv2] !== true) {\n                    current = tmp[0];\n                    dataTypes.unshift(tmp[1]);\n                  }\n\n                  break;\n                }\n              }\n            }\n          } // Apply converter (if not an equivalence)\n\n\n          if (conv !== true) {\n            // Unless errors are allowed to bubble, catch and return them\n            if (conv && s[\"throws\"]) {\n              response = conv(response);\n            } else {\n              try {\n                response = conv(response);\n              } catch (e) {\n                return {\n                  state: \"parsererror\",\n                  error: conv ? e : \"No conversion from \" + prev + \" to \" + current\n                };\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return {\n      state: \"success\",\n      data: response\n    };\n  }\n\n  jQuery.extend({\n    // Counter for holding the number of active queries\n    active: 0,\n    // Last-Modified header cache for next request\n    lastModified: {},\n    etag: {},\n    ajaxSettings: {\n      url: ajaxLocation,\n      type: \"GET\",\n      isLocal: rlocalProtocol.test(ajaxLocParts[1]),\n      global: true,\n      processData: true,\n      async: true,\n      contentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n\n      /*\n      timeout: 0,\n      data: null,\n      dataType: null,\n      username: null,\n      password: null,\n      cache: null,\n      throws: false,\n      traditional: false,\n      headers: {},\n      */\n      accepts: {\n        \"*\": allTypes,\n        text: \"text/plain\",\n        html: \"text/html\",\n        xml: \"application/xml, text/xml\",\n        json: \"application/json, text/javascript\"\n      },\n      contents: {\n        xml: /xml/,\n        html: /html/,\n        json: /json/\n      },\n      responseFields: {\n        xml: \"responseXML\",\n        text: \"responseText\",\n        json: \"responseJSON\"\n      },\n      // Data converters\n      // Keys separate source (or catchall \"*\") and destination types with a single space\n      converters: {\n        // Convert anything to text\n        \"* text\": String,\n        // Text to html (true = no transformation)\n        \"text html\": true,\n        // Evaluate text as a json expression\n        \"text json\": jQuery.parseJSON,\n        // Parse text as xml\n        \"text xml\": jQuery.parseXML\n      },\n      // For options that shouldn't be deep extended:\n      // you can add your own custom options here if\n      // and when you create one that shouldn't be\n      // deep extended (see ajaxExtend)\n      flatOptions: {\n        url: true,\n        context: true\n      }\n    },\n    // Creates a full fledged settings object into target\n    // with both ajaxSettings and settings fields.\n    // If target is omitted, writes into ajaxSettings.\n    ajaxSetup: function ajaxSetup(target, settings) {\n      return settings ? // Building a settings object\n      ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : // Extending ajaxSettings\n      ajaxExtend(jQuery.ajaxSettings, target);\n    },\n    ajaxPrefilter: addToPrefiltersOrTransports(prefilters),\n    ajaxTransport: addToPrefiltersOrTransports(transports),\n    // Main method\n    ajax: function ajax(url, options) {\n      // If url is an object, simulate pre-1.5 signature\n      if (_typeof(url) === \"object\") {\n        options = url;\n        url = undefined;\n      } // Force options to be an object\n\n\n      options = options || {};\n\n      var transport,\n          // URL without anti-cache param\n      cacheURL,\n          // Response headers\n      responseHeadersString,\n          responseHeaders,\n          // timeout handle\n      timeoutTimer,\n          // Cross-domain detection vars\n      parts,\n          // To know if global events are to be dispatched\n      fireGlobals,\n          // Loop variable\n      i,\n          // Create the final options object\n      s = jQuery.ajaxSetup({}, options),\n          // Callbacks context\n      callbackContext = s.context || s,\n          // Context for global events is callbackContext if it is a DOM node or jQuery collection\n      globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,\n          // Deferreds\n      deferred = jQuery.Deferred(),\n          completeDeferred = jQuery.Callbacks(\"once memory\"),\n          // Status-dependent callbacks\n      _statusCode = s.statusCode || {},\n          // Headers (they are sent all at once)\n      requestHeaders = {},\n          requestHeadersNames = {},\n          // The jqXHR state\n      state = 0,\n          // Default abort message\n      strAbort = \"canceled\",\n          // Fake xhr\n      jqXHR = {\n        readyState: 0,\n        // Builds headers hashtable if needed\n        getResponseHeader: function getResponseHeader(key) {\n          var match;\n\n          if (state === 2) {\n            if (!responseHeaders) {\n              responseHeaders = {};\n\n              while (match = rheaders.exec(responseHeadersString)) {\n                responseHeaders[match[1].toLowerCase()] = match[2];\n              }\n            }\n\n            match = responseHeaders[key.toLowerCase()];\n          }\n\n          return match == null ? null : match;\n        },\n        // Raw string\n        getAllResponseHeaders: function getAllResponseHeaders() {\n          return state === 2 ? responseHeadersString : null;\n        },\n        // Caches the header\n        setRequestHeader: function setRequestHeader(name, value) {\n          var lname = name.toLowerCase();\n\n          if (!state) {\n            name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;\n            requestHeaders[name] = value;\n          }\n\n          return this;\n        },\n        // Overrides response content-type header\n        overrideMimeType: function overrideMimeType(type) {\n          if (!state) {\n            s.mimeType = type;\n          }\n\n          return this;\n        },\n        // Status-dependent callbacks\n        statusCode: function statusCode(map) {\n          var code;\n\n          if (map) {\n            if (state < 2) {\n              for (code in map) {\n                // Lazy-add the new callback in a way that preserves old ones\n                _statusCode[code] = [_statusCode[code], map[code]];\n              }\n            } else {\n              // Execute the appropriate callbacks\n              jqXHR.always(map[jqXHR.status]);\n            }\n          }\n\n          return this;\n        },\n        // Cancel the request\n        abort: function abort(statusText) {\n          var finalText = statusText || strAbort;\n\n          if (transport) {\n            transport.abort(finalText);\n          }\n\n          done(0, finalText);\n          return this;\n        }\n      }; // Attach deferreds\n\n\n      deferred.promise(jqXHR).complete = completeDeferred.add;\n      jqXHR.success = jqXHR.done;\n      jqXHR.error = jqXHR.fail; // Remove hash character (#7531: and string promotion)\n      // Add protocol if not provided (prefilters might expect it)\n      // Handle falsy url in the settings object (#10093: consistency with old signature)\n      // We also use the url parameter if available\n\n      s.url = ((url || s.url || ajaxLocation) + \"\").replace(rhash, \"\").replace(rprotocol, ajaxLocParts[1] + \"//\"); // Alias method option to type as per ticket #12004\n\n      s.type = options.method || options.type || s.method || s.type; // Extract dataTypes list\n\n      s.dataTypes = jQuery.trim(s.dataType || \"*\").toLowerCase().match(rnotwhite) || [\"\"]; // A cross-domain request is in order when we have a protocol:host:port mismatch\n\n      if (s.crossDomain == null) {\n        parts = rurl.exec(s.url.toLowerCase());\n        s.crossDomain = !!(parts && (parts[1] !== ajaxLocParts[1] || parts[2] !== ajaxLocParts[2] || (parts[3] || (parts[1] === \"http:\" ? \"80\" : \"443\")) !== (ajaxLocParts[3] || (ajaxLocParts[1] === \"http:\" ? \"80\" : \"443\"))));\n      } // Convert data if not already a string\n\n\n      if (s.data && s.processData && typeof s.data !== \"string\") {\n        s.data = jQuery.param(s.data, s.traditional);\n      } // Apply prefilters\n\n\n      inspectPrefiltersOrTransports(prefilters, s, options, jqXHR); // If request was aborted inside a prefilter, stop there\n\n      if (state === 2) {\n        return jqXHR;\n      } // We can fire global events as of now if asked to\n      // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\n\n\n      fireGlobals = jQuery.event && s.global; // Watch for a new set of requests\n\n      if (fireGlobals && jQuery.active++ === 0) {\n        jQuery.event.trigger(\"ajaxStart\");\n      } // Uppercase the type\n\n\n      s.type = s.type.toUpperCase(); // Determine if request has content\n\n      s.hasContent = !rnoContent.test(s.type); // Save the URL in case we're toying with the If-Modified-Since\n      // and/or If-None-Match header later on\n\n      cacheURL = s.url; // More options handling for requests with no content\n\n      if (!s.hasContent) {\n        // If data is available, append data to url\n        if (s.data) {\n          cacheURL = s.url += (rquery.test(cacheURL) ? \"&\" : \"?\") + s.data; // #9682: remove data so that it's not used in an eventual retry\n\n          delete s.data;\n        } // Add anti-cache in url if needed\n\n\n        if (s.cache === false) {\n          s.url = rts.test(cacheURL) ? // If there is already a '_' parameter, set its value\n          cacheURL.replace(rts, \"$1_=\" + nonce++) : // Otherwise add one to the end\n          cacheURL + (rquery.test(cacheURL) ? \"&\" : \"?\") + \"_=\" + nonce++;\n        }\n      } // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\n\n      if (s.ifModified) {\n        if (jQuery.lastModified[cacheURL]) {\n          jqXHR.setRequestHeader(\"If-Modified-Since\", jQuery.lastModified[cacheURL]);\n        }\n\n        if (jQuery.etag[cacheURL]) {\n          jqXHR.setRequestHeader(\"If-None-Match\", jQuery.etag[cacheURL]);\n        }\n      } // Set the correct header, if data is being sent\n\n\n      if (s.data && s.hasContent && s.contentType !== false || options.contentType) {\n        jqXHR.setRequestHeader(\"Content-Type\", s.contentType);\n      } // Set the Accepts header for the server, depending on the dataType\n\n\n      jqXHR.setRequestHeader(\"Accept\", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\") : s.accepts[\"*\"]); // Check for headers option\n\n      for (i in s.headers) {\n        jqXHR.setRequestHeader(i, s.headers[i]);\n      } // Allow custom headers/mimetypes and early abort\n\n\n      if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {\n        // Abort if not done already and return\n        return jqXHR.abort();\n      } // Aborting is no longer a cancellation\n\n\n      strAbort = \"abort\"; // Install callbacks on deferreds\n\n      for (i in {\n        success: 1,\n        error: 1,\n        complete: 1\n      }) {\n        jqXHR[i](s[i]);\n      } // Get transport\n\n\n      transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR); // If no transport, we auto-abort\n\n      if (!transport) {\n        done(-1, \"No Transport\");\n      } else {\n        jqXHR.readyState = 1; // Send global event\n\n        if (fireGlobals) {\n          globalEventContext.trigger(\"ajaxSend\", [jqXHR, s]);\n        } // Timeout\n\n\n        if (s.async && s.timeout > 0) {\n          timeoutTimer = setTimeout(function () {\n            jqXHR.abort(\"timeout\");\n          }, s.timeout);\n        }\n\n        try {\n          state = 1;\n          transport.send(requestHeaders, done);\n        } catch (e) {\n          // Propagate exception as error if not done\n          if (state < 2) {\n            done(-1, e); // Simply rethrow otherwise\n          } else {\n            throw e;\n          }\n        }\n      } // Callback for when everything is done\n\n\n      function done(status, nativeStatusText, responses, headers) {\n        var isSuccess,\n            success,\n            error,\n            response,\n            modified,\n            statusText = nativeStatusText; // Called once\n\n        if (state === 2) {\n          return;\n        } // State is \"done\" now\n\n\n        state = 2; // Clear timeout if it exists\n\n        if (timeoutTimer) {\n          clearTimeout(timeoutTimer);\n        } // Dereference transport for early garbage collection\n        // (no matter how long the jqXHR object will be used)\n\n\n        transport = undefined; // Cache response headers\n\n        responseHeadersString = headers || \"\"; // Set readyState\n\n        jqXHR.readyState = status > 0 ? 4 : 0; // Determine if successful\n\n        isSuccess = status >= 200 && status < 300 || status === 304; // Get response data\n\n        if (responses) {\n          response = ajaxHandleResponses(s, jqXHR, responses);\n        } // Convert no matter what (that way responseXXX fields are always set)\n\n\n        response = ajaxConvert(s, response, jqXHR, isSuccess); // If successful, handle type chaining\n\n        if (isSuccess) {\n          // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n          if (s.ifModified) {\n            modified = jqXHR.getResponseHeader(\"Last-Modified\");\n\n            if (modified) {\n              jQuery.lastModified[cacheURL] = modified;\n            }\n\n            modified = jqXHR.getResponseHeader(\"etag\");\n\n            if (modified) {\n              jQuery.etag[cacheURL] = modified;\n            }\n          } // if no content\n\n\n          if (status === 204 || s.type === \"HEAD\") {\n            statusText = \"nocontent\"; // if not modified\n          } else if (status === 304) {\n            statusText = \"notmodified\"; // If we have data, let's convert it\n          } else {\n            statusText = response.state;\n            success = response.data;\n            error = response.error;\n            isSuccess = !error;\n          }\n        } else {\n          // Extract error from statusText and normalize for non-aborts\n          error = statusText;\n\n          if (status || !statusText) {\n            statusText = \"error\";\n\n            if (status < 0) {\n              status = 0;\n            }\n          }\n        } // Set data for the fake xhr object\n\n\n        jqXHR.status = status;\n        jqXHR.statusText = (nativeStatusText || statusText) + \"\"; // Success/Error\n\n        if (isSuccess) {\n          deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);\n        } else {\n          deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);\n        } // Status-dependent callbacks\n\n\n        jqXHR.statusCode(_statusCode);\n        _statusCode = undefined;\n\n        if (fireGlobals) {\n          globalEventContext.trigger(isSuccess ? \"ajaxSuccess\" : \"ajaxError\", [jqXHR, s, isSuccess ? success : error]);\n        } // Complete\n\n\n        completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);\n\n        if (fireGlobals) {\n          globalEventContext.trigger(\"ajaxComplete\", [jqXHR, s]); // Handle the global AJAX counter\n\n          if (! --jQuery.active) {\n            jQuery.event.trigger(\"ajaxStop\");\n          }\n        }\n      }\n\n      return jqXHR;\n    },\n    getJSON: function getJSON(url, data, callback) {\n      return jQuery.get(url, data, callback, \"json\");\n    },\n    getScript: function getScript(url, callback) {\n      return jQuery.get(url, undefined, callback, \"script\");\n    }\n  });\n  jQuery.each([\"get\", \"post\"], function (i, method) {\n    jQuery[method] = function (url, data, callback, type) {\n      // Shift arguments if data argument was omitted\n      if (jQuery.isFunction(data)) {\n        type = type || callback;\n        callback = data;\n        data = undefined;\n      }\n\n      return jQuery.ajax({\n        url: url,\n        type: method,\n        dataType: type,\n        data: data,\n        success: callback\n      });\n    };\n  });\n\n  jQuery._evalUrl = function (url) {\n    return jQuery.ajax({\n      url: url,\n      type: \"GET\",\n      dataType: \"script\",\n      async: false,\n      global: false,\n      \"throws\": true\n    });\n  };\n\n  jQuery.fn.extend({\n    wrapAll: function wrapAll(html) {\n      var wrap;\n\n      if (jQuery.isFunction(html)) {\n        return this.each(function (i) {\n          jQuery(this).wrapAll(html.call(this, i));\n        });\n      }\n\n      if (this[0]) {\n        // The elements to wrap the target around\n        wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);\n\n        if (this[0].parentNode) {\n          wrap.insertBefore(this[0]);\n        }\n\n        wrap.map(function () {\n          var elem = this;\n\n          while (elem.firstElementChild) {\n            elem = elem.firstElementChild;\n          }\n\n          return elem;\n        }).append(this);\n      }\n\n      return this;\n    },\n    wrapInner: function wrapInner(html) {\n      if (jQuery.isFunction(html)) {\n        return this.each(function (i) {\n          jQuery(this).wrapInner(html.call(this, i));\n        });\n      }\n\n      return this.each(function () {\n        var self = jQuery(this),\n            contents = self.contents();\n\n        if (contents.length) {\n          contents.wrapAll(html);\n        } else {\n          self.append(html);\n        }\n      });\n    },\n    wrap: function wrap(html) {\n      var isFunction = jQuery.isFunction(html);\n      return this.each(function (i) {\n        jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);\n      });\n    },\n    unwrap: function unwrap() {\n      return this.parent().each(function () {\n        if (!jQuery.nodeName(this, \"body\")) {\n          jQuery(this).replaceWith(this.childNodes);\n        }\n      }).end();\n    }\n  });\n\n  jQuery.expr.filters.hidden = function (elem) {\n    // Support: Opera <= 12.12\n    // Opera reports offsetWidths and offsetHeights less than zero on some elements\n    return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;\n  };\n\n  jQuery.expr.filters.visible = function (elem) {\n    return !jQuery.expr.filters.hidden(elem);\n  };\n\n  var r20 = /%20/g,\n      rbracket = /\\[\\]$/,\n      rCRLF = /\\r?\\n/g,\n      rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n      rsubmittable = /^(?:input|select|textarea|keygen)/i;\n\n  function buildParams(prefix, obj, traditional, add) {\n    var name;\n\n    if (jQuery.isArray(obj)) {\n      // Serialize array item.\n      jQuery.each(obj, function (i, v) {\n        if (traditional || rbracket.test(prefix)) {\n          // Treat each array item as a scalar.\n          add(prefix, v);\n        } else {\n          // Item is non-scalar (array or object), encode its numeric index.\n          buildParams(prefix + \"[\" + (_typeof(v) === \"object\" ? i : \"\") + \"]\", v, traditional, add);\n        }\n      });\n    } else if (!traditional && jQuery.type(obj) === \"object\") {\n      // Serialize object item.\n      for (name in obj) {\n        buildParams(prefix + \"[\" + name + \"]\", obj[name], traditional, add);\n      }\n    } else {\n      // Serialize scalar item.\n      add(prefix, obj);\n    }\n  } // Serialize an array of form elements or a set of\n  // key/values into a query string\n\n\n  jQuery.param = function (a, traditional) {\n    var prefix,\n        s = [],\n        add = function add(key, value) {\n      // If value is a function, invoke it and return its value\n      value = jQuery.isFunction(value) ? value() : value == null ? \"\" : value;\n      s[s.length] = encodeURIComponent(key) + \"=\" + encodeURIComponent(value);\n    }; // Set traditional to true for jQuery <= 1.3.2 behavior.\n\n\n    if (traditional === undefined) {\n      traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;\n    } // If an array was passed in, assume that it is an array of form elements.\n\n\n    if (jQuery.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {\n      // Serialize the form elements\n      jQuery.each(a, function () {\n        add(this.name, this.value);\n      });\n    } else {\n      // If traditional, encode the \"old\" way (the way 1.3.2 or older\n      // did it), otherwise encode params recursively.\n      for (prefix in a) {\n        buildParams(prefix, a[prefix], traditional, add);\n      }\n    } // Return the resulting serialization\n\n\n    return s.join(\"&\").replace(r20, \"+\");\n  };\n\n  jQuery.fn.extend({\n    serialize: function serialize() {\n      return jQuery.param(this.serializeArray());\n    },\n    serializeArray: function serializeArray() {\n      return this.map(function () {\n        // Can add propHook for \"elements\" to filter or add form elements\n        var elements = jQuery.prop(this, \"elements\");\n        return elements ? jQuery.makeArray(elements) : this;\n      }).filter(function () {\n        var type = this.type; // Use .is( \":disabled\" ) so that fieldset[disabled] works\n\n        return this.name && !jQuery(this).is(\":disabled\") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));\n      }).map(function (i, elem) {\n        var val = jQuery(this).val();\n        return val == null ? null : jQuery.isArray(val) ? jQuery.map(val, function (val) {\n          return {\n            name: elem.name,\n            value: val.replace(rCRLF, \"\\r\\n\")\n          };\n        }) : {\n          name: elem.name,\n          value: val.replace(rCRLF, \"\\r\\n\")\n        };\n      }).get();\n    }\n  });\n\n  jQuery.ajaxSettings.xhr = function () {\n    try {\n      return new XMLHttpRequest();\n    } catch (e) {}\n  };\n\n  var xhrId = 0,\n      xhrCallbacks = {},\n      xhrSuccessStatus = {\n    // file protocol always yields status code 0, assume 200\n    0: 200,\n    // Support: IE9\n    // #1450: sometimes IE returns 1223 when it should be 204\n    1223: 204\n  },\n      xhrSupported = jQuery.ajaxSettings.xhr(); // Support: IE9\n  // Open requests must be manually aborted on unload (#5280)\n  // See https://support.microsoft.com/kb/2856746 for more info\n\n  if (window.attachEvent) {\n    window.attachEvent(\"onunload\", function () {\n      for (var key in xhrCallbacks) {\n        xhrCallbacks[key]();\n      }\n    });\n  }\n\n  support.cors = !!xhrSupported && \"withCredentials\" in xhrSupported;\n  support.ajax = xhrSupported = !!xhrSupported;\n  jQuery.ajaxTransport(function (options) {\n    var _callback; // Cross domain only allowed if supported through XMLHttpRequest\n\n\n    if (support.cors || xhrSupported && !options.crossDomain) {\n      return {\n        send: function send(headers, complete) {\n          var i,\n              xhr = options.xhr(),\n              id = ++xhrId;\n          xhr.open(options.type, options.url, options.async, options.username, options.password); // Apply custom fields if provided\n\n          if (options.xhrFields) {\n            for (i in options.xhrFields) {\n              xhr[i] = options.xhrFields[i];\n            }\n          } // Override mime type if needed\n\n\n          if (options.mimeType && xhr.overrideMimeType) {\n            xhr.overrideMimeType(options.mimeType);\n          } // X-Requested-With header\n          // For cross-domain requests, seeing as conditions for a preflight are\n          // akin to a jigsaw puzzle, we simply never set it to be sure.\n          // (it can always be set on a per-request basis or even using ajaxSetup)\n          // For same-domain requests, won't change header if already provided.\n\n\n          if (!options.crossDomain && !headers[\"X-Requested-With\"]) {\n            headers[\"X-Requested-With\"] = \"XMLHttpRequest\";\n          } // Set headers\n\n\n          for (i in headers) {\n            xhr.setRequestHeader(i, headers[i]);\n          } // Callback\n\n\n          _callback = function callback(type) {\n            return function () {\n              if (_callback) {\n                delete xhrCallbacks[id];\n                _callback = xhr.onload = xhr.onerror = null;\n\n                if (type === \"abort\") {\n                  xhr.abort();\n                } else if (type === \"error\") {\n                  complete( // file: protocol always yields status 0; see #8605, #14207\n                  xhr.status, xhr.statusText);\n                } else {\n                  complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, // Support: IE9\n                  // Accessing binary-data responseText throws an exception\n                  // (#11426)\n                  typeof xhr.responseText === \"string\" ? {\n                    text: xhr.responseText\n                  } : undefined, xhr.getAllResponseHeaders());\n                }\n              }\n            };\n          }; // Listen to events\n\n\n          xhr.onload = _callback();\n          xhr.onerror = _callback(\"error\"); // Create the abort callback\n\n          _callback = xhrCallbacks[id] = _callback(\"abort\");\n\n          try {\n            // Do send the request (this may raise an exception)\n            xhr.send(options.hasContent && options.data || null);\n          } catch (e) {\n            // #14683: Only rethrow if this hasn't been notified as an error yet\n            if (_callback) {\n              throw e;\n            }\n          }\n        },\n        abort: function abort() {\n          if (_callback) {\n            _callback();\n          }\n        }\n      };\n    }\n  }); // Install script dataType\n\n  jQuery.ajaxSetup({\n    accepts: {\n      script: \"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript\"\n    },\n    contents: {\n      script: /(?:java|ecma)script/\n    },\n    converters: {\n      \"text script\": function textScript(text) {\n        jQuery.globalEval(text);\n        return text;\n      }\n    }\n  }); // Handle cache's special case and crossDomain\n\n  jQuery.ajaxPrefilter(\"script\", function (s) {\n    if (s.cache === undefined) {\n      s.cache = false;\n    }\n\n    if (s.crossDomain) {\n      s.type = \"GET\";\n    }\n  }); // Bind script tag hack transport\n\n  jQuery.ajaxTransport(\"script\", function (s) {\n    // This transport only deals with cross domain requests\n    if (s.crossDomain) {\n      var script, _callback2;\n\n      return {\n        send: function send(_, complete) {\n          script = jQuery(\"<script>\").prop({\n            async: true,\n            charset: s.scriptCharset,\n            src: s.url\n          }).on(\"load error\", _callback2 = function callback(evt) {\n            script.remove();\n            _callback2 = null;\n\n            if (evt) {\n              complete(evt.type === \"error\" ? 404 : 200, evt.type);\n            }\n          });\n          document.head.appendChild(script[0]);\n        },\n        abort: function abort() {\n          if (_callback2) {\n            _callback2();\n          }\n        }\n      };\n    }\n  });\n  var oldCallbacks = [],\n      rjsonp = /(=)\\?(?=&|$)|\\?\\?/; // Default jsonp settings\n\n  jQuery.ajaxSetup({\n    jsonp: \"callback\",\n    jsonpCallback: function jsonpCallback() {\n      var callback = oldCallbacks.pop() || jQuery.expando + \"_\" + nonce++;\n      this[callback] = true;\n      return callback;\n    }\n  }); // Detect, normalize options and install callbacks for jsonp requests\n\n  jQuery.ajaxPrefilter(\"json jsonp\", function (s, originalSettings, jqXHR) {\n    var callbackName,\n        overwritten,\n        responseContainer,\n        jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? \"url\" : typeof s.data === \"string\" && !(s.contentType || \"\").indexOf(\"application/x-www-form-urlencoded\") && rjsonp.test(s.data) && \"data\"); // Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n\n    if (jsonProp || s.dataTypes[0] === \"jsonp\") {\n      // Get callback name, remembering preexisting value associated with it\n      callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback; // Insert callback into url or form data\n\n      if (jsonProp) {\n        s[jsonProp] = s[jsonProp].replace(rjsonp, \"$1\" + callbackName);\n      } else if (s.jsonp !== false) {\n        s.url += (rquery.test(s.url) ? \"&\" : \"?\") + s.jsonp + \"=\" + callbackName;\n      } // Use data converter to retrieve json after script execution\n\n\n      s.converters[\"script json\"] = function () {\n        if (!responseContainer) {\n          jQuery.error(callbackName + \" was not called\");\n        }\n\n        return responseContainer[0];\n      }; // force json dataType\n\n\n      s.dataTypes[0] = \"json\"; // Install callback\n\n      overwritten = window[callbackName];\n\n      window[callbackName] = function () {\n        responseContainer = arguments;\n      }; // Clean-up function (fires after converters)\n\n\n      jqXHR.always(function () {\n        // Restore preexisting value\n        window[callbackName] = overwritten; // Save back as free\n\n        if (s[callbackName]) {\n          // make sure that re-using the options doesn't screw things around\n          s.jsonpCallback = originalSettings.jsonpCallback; // save the callback name for future use\n\n          oldCallbacks.push(callbackName);\n        } // Call if it was a function and we have a response\n\n\n        if (responseContainer && jQuery.isFunction(overwritten)) {\n          overwritten(responseContainer[0]);\n        }\n\n        responseContainer = overwritten = undefined;\n      }); // Delegate to script\n\n      return \"script\";\n    }\n  }); // data: string of html\n  // context (optional): If specified, the fragment will be created in this context, defaults to document\n  // keepScripts (optional): If true, will include scripts passed in the html string\n\n  jQuery.parseHTML = function (data, context, keepScripts) {\n    if (!data || typeof data !== \"string\") {\n      return null;\n    }\n\n    if (typeof context === \"boolean\") {\n      keepScripts = context;\n      context = false;\n    }\n\n    context = context || document;\n    var parsed = rsingleTag.exec(data),\n        scripts = !keepScripts && []; // Single tag\n\n    if (parsed) {\n      return [context.createElement(parsed[1])];\n    }\n\n    parsed = jQuery.buildFragment([data], context, scripts);\n\n    if (scripts && scripts.length) {\n      jQuery(scripts).remove();\n    }\n\n    return jQuery.merge([], parsed.childNodes);\n  }; // Keep a copy of the old load method\n\n\n  var _load = jQuery.fn.load;\n  /**\n   * Load a url into a page\n   */\n\n  jQuery.fn.load = function (url, params, callback) {\n    if (typeof url !== \"string\" && _load) {\n      return _load.apply(this, arguments);\n    }\n\n    var selector,\n        type,\n        response,\n        self = this,\n        off = url.indexOf(\" \");\n\n    if (off >= 0) {\n      selector = jQuery.trim(url.slice(off));\n      url = url.slice(0, off);\n    } // If it's a function\n\n\n    if (jQuery.isFunction(params)) {\n      // We assume that it's the callback\n      callback = params;\n      params = undefined; // Otherwise, build a param string\n    } else if (params && _typeof(params) === \"object\") {\n      type = \"POST\";\n    } // If we have elements to modify, make the request\n\n\n    if (self.length > 0) {\n      jQuery.ajax({\n        url: url,\n        // if \"type\" variable is undefined, then \"GET\" method will be used\n        type: type,\n        dataType: \"html\",\n        data: params\n      }).done(function (responseText) {\n        // Save response for use in complete callback\n        response = arguments;\n        self.html(selector ? // If a selector was specified, locate the right elements in a dummy div\n        // Exclude scripts to avoid IE 'Permission Denied' errors\n        jQuery(\"<div>\").append(jQuery.parseHTML(responseText)).find(selector) : // Otherwise use the full result\n        responseText);\n      }).complete(callback && function (jqXHR, status) {\n        self.each(callback, response || [jqXHR.responseText, status, jqXHR]);\n      });\n    }\n\n    return this;\n  }; // Attach a bunch of functions for handling common AJAX events\n\n\n  jQuery.each([\"ajaxStart\", \"ajaxStop\", \"ajaxComplete\", \"ajaxError\", \"ajaxSuccess\", \"ajaxSend\"], function (i, type) {\n    jQuery.fn[type] = function (fn) {\n      return this.on(type, fn);\n    };\n  });\n\n  jQuery.expr.filters.animated = function (elem) {\n    return jQuery.grep(jQuery.timers, function (fn) {\n      return elem === fn.elem;\n    }).length;\n  };\n\n  var docElem = window.document.documentElement;\n  /**\n   * Gets a window from an element\n   */\n\n  function getWindow(elem) {\n    return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;\n  }\n\n  jQuery.offset = {\n    setOffset: function setOffset(elem, options, i) {\n      var curPosition,\n          curLeft,\n          curCSSTop,\n          curTop,\n          curOffset,\n          curCSSLeft,\n          calculatePosition,\n          position = jQuery.css(elem, \"position\"),\n          curElem = jQuery(elem),\n          props = {}; // Set position first, in-case top/left are set even on static elem\n\n      if (position === \"static\") {\n        elem.style.position = \"relative\";\n      }\n\n      curOffset = curElem.offset();\n      curCSSTop = jQuery.css(elem, \"top\");\n      curCSSLeft = jQuery.css(elem, \"left\");\n      calculatePosition = (position === \"absolute\" || position === \"fixed\") && (curCSSTop + curCSSLeft).indexOf(\"auto\") > -1; // Need to be able to calculate position if either\n      // top or left is auto and position is either absolute or fixed\n\n      if (calculatePosition) {\n        curPosition = curElem.position();\n        curTop = curPosition.top;\n        curLeft = curPosition.left;\n      } else {\n        curTop = parseFloat(curCSSTop) || 0;\n        curLeft = parseFloat(curCSSLeft) || 0;\n      }\n\n      if (jQuery.isFunction(options)) {\n        options = options.call(elem, i, curOffset);\n      }\n\n      if (options.top != null) {\n        props.top = options.top - curOffset.top + curTop;\n      }\n\n      if (options.left != null) {\n        props.left = options.left - curOffset.left + curLeft;\n      }\n\n      if (\"using\" in options) {\n        options.using.call(elem, props);\n      } else {\n        curElem.css(props);\n      }\n    }\n  };\n  jQuery.fn.extend({\n    offset: function offset(options) {\n      if (arguments.length) {\n        return options === undefined ? this : this.each(function (i) {\n          jQuery.offset.setOffset(this, options, i);\n        });\n      }\n\n      var docElem,\n          win,\n          elem = this[0],\n          box = {\n        top: 0,\n        left: 0\n      },\n          doc = elem && elem.ownerDocument;\n\n      if (!doc) {\n        return;\n      }\n\n      docElem = doc.documentElement; // Make sure it's not a disconnected DOM node\n\n      if (!jQuery.contains(docElem, elem)) {\n        return box;\n      } // Support: BlackBerry 5, iOS 3 (original iPhone)\n      // If we don't have gBCR, just use 0,0 rather than error\n\n\n      if (_typeof(elem.getBoundingClientRect) !== strundefined) {\n        box = elem.getBoundingClientRect();\n      }\n\n      win = getWindow(doc);\n      return {\n        top: box.top + win.pageYOffset - docElem.clientTop,\n        left: box.left + win.pageXOffset - docElem.clientLeft\n      };\n    },\n    position: function position() {\n      if (!this[0]) {\n        return;\n      }\n\n      var offsetParent,\n          offset,\n          elem = this[0],\n          parentOffset = {\n        top: 0,\n        left: 0\n      }; // Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent\n\n      if (jQuery.css(elem, \"position\") === \"fixed\") {\n        // Assume getBoundingClientRect is there when computed position is fixed\n        offset = elem.getBoundingClientRect();\n      } else {\n        // Get *real* offsetParent\n        offsetParent = this.offsetParent(); // Get correct offsets\n\n        offset = this.offset();\n\n        if (!jQuery.nodeName(offsetParent[0], \"html\")) {\n          parentOffset = offsetParent.offset();\n        } // Add offsetParent borders\n\n\n        parentOffset.top += jQuery.css(offsetParent[0], \"borderTopWidth\", true);\n        parentOffset.left += jQuery.css(offsetParent[0], \"borderLeftWidth\", true);\n      } // Subtract parent offsets and element margins\n\n\n      return {\n        top: offset.top - parentOffset.top - jQuery.css(elem, \"marginTop\", true),\n        left: offset.left - parentOffset.left - jQuery.css(elem, \"marginLeft\", true)\n      };\n    },\n    offsetParent: function offsetParent() {\n      return this.map(function () {\n        var offsetParent = this.offsetParent || docElem;\n\n        while (offsetParent && !jQuery.nodeName(offsetParent, \"html\") && jQuery.css(offsetParent, \"position\") === \"static\") {\n          offsetParent = offsetParent.offsetParent;\n        }\n\n        return offsetParent || docElem;\n      });\n    }\n  }); // Create scrollLeft and scrollTop methods\n\n  jQuery.each({\n    scrollLeft: \"pageXOffset\",\n    scrollTop: \"pageYOffset\"\n  }, function (method, prop) {\n    var top = \"pageYOffset\" === prop;\n\n    jQuery.fn[method] = function (val) {\n      return access(this, function (elem, method, val) {\n        var win = getWindow(elem);\n\n        if (val === undefined) {\n          return win ? win[prop] : elem[method];\n        }\n\n        if (win) {\n          win.scrollTo(!top ? val : window.pageXOffset, top ? val : window.pageYOffset);\n        } else {\n          elem[method] = val;\n        }\n      }, method, val, arguments.length, null);\n    };\n  }); // Support: Safari<7+, Chrome<37+\n  // Add the top/left cssHooks using jQuery.fn.position\n  // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n  // Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280\n  // getComputedStyle returns percent when specified for top/left/bottom/right;\n  // rather than make the css module depend on the offset module, just check for it here\n\n  jQuery.each([\"top\", \"left\"], function (i, prop) {\n    jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {\n      if (computed) {\n        computed = curCSS(elem, prop); // If curCSS returns percentage, fallback to offset\n\n        return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + \"px\" : computed;\n      }\n    });\n  }); // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\n\n  jQuery.each({\n    Height: \"height\",\n    Width: \"width\"\n  }, function (name, type) {\n    jQuery.each({\n      padding: \"inner\" + name,\n      content: type,\n      \"\": \"outer\" + name\n    }, function (defaultExtra, funcName) {\n      // Margin is only for outerHeight, outerWidth\n      jQuery.fn[funcName] = function (margin, value) {\n        var chainable = arguments.length && (defaultExtra || typeof margin !== \"boolean\"),\n            extra = defaultExtra || (margin === true || value === true ? \"margin\" : \"border\");\n        return access(this, function (elem, type, value) {\n          var doc;\n\n          if (jQuery.isWindow(elem)) {\n            // As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there\n            // isn't a whole lot we can do. See pull request at this URL for discussion:\n            // https://github.com/jquery/jquery/pull/764\n            return elem.document.documentElement[\"client\" + name];\n          } // Get document width or height\n\n\n          if (elem.nodeType === 9) {\n            doc = elem.documentElement; // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n            // whichever is greatest\n\n            return Math.max(elem.body[\"scroll\" + name], doc[\"scroll\" + name], elem.body[\"offset\" + name], doc[\"offset\" + name], doc[\"client\" + name]);\n          }\n\n          return value === undefined ? // Get width or height on the element, requesting but not forcing parseFloat\n          jQuery.css(elem, type, extra) : // Set width or height on the element\n          jQuery.style(elem, type, value, extra);\n        }, type, chainable ? margin : undefined, chainable, null);\n      };\n    });\n  }); // The number of elements contained in the matched element set\n\n  jQuery.fn.size = function () {\n    return this.length;\n  };\n\n  jQuery.fn.andSelf = jQuery.fn.addBack; // Register as a named AMD module, since jQuery can be concatenated with other\n  // files that may use define, but not via a proper concatenation script that\n  // understands anonymous AMD modules. A named AMD is safest and most robust\n  // way to register. Lowercase jquery is used because AMD module names are\n  // derived from file names, and jQuery is normally delivered in a lowercase\n  // file name. Do this after creating the global so that if an AMD module wants\n  // to call noConflict to hide this version of jQuery, it will work.\n  // Note that for maximum portability, libraries that are not jQuery should\n  // declare themselves as anonymous modules, and avoid setting a global if an\n  // AMD loader is present. jQuery is a special case. For more information, see\n  // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n\n  if (typeof define === \"function\" && define.amd) {\n    define(\"jquery\", [], function () {\n      return jQuery;\n    });\n  }\n\n  var // Map over jQuery in case of overwrite\n  _jQuery = window.jQuery,\n      // Map over the $ in case of overwrite\n  _$ = window.$;\n\n  jQuery.noConflict = function (deep) {\n    if (window.$ === jQuery) {\n      window.$ = _$;\n    }\n\n    if (deep && window.jQuery === jQuery) {\n      window.jQuery = _jQuery;\n    }\n\n    return jQuery;\n  }; // Expose jQuery and $ identifiers, even in AMD\n  // (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n  // and CommonJS for browser emulators (#13566)\n\n\n  if (_typeof(noGlobal) === strundefined) {\n    window.jQuery = window.$ = jQuery;\n  }\n\n  return jQuery;\n});"

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./node_modules/babel-loader/lib/index.js?!./assets/js/jquery.form.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/raw-loader!./node_modules/babel-loader/lib??ref--4-0!./assets/js/jquery.form.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*!\n * jQuery Form Plugin\n * version: 3.51.0-2014.06.20\n * Requires jQuery v1.5 or later\n * Copyright (c) 2014 M. Alsup\n * Examples and documentation at: http://malsup.com/jquery/form/\n * Project repository: https://github.com/malsup/form\n * Dual licensed under the MIT and GPL licenses.\n * https://github.com/malsup/form#copyright-and-license\n */\n\n/*global ActiveXObject */\n// AMD support\n(function (factory) {\n  \"use strict\";\n\n  if (typeof define === 'function' && define.amd) {\n    // using AMD; register as anon module\n    define(['jquery'], factory);\n  } else {\n    // no AMD; invoke directly\n    factory(typeof jQuery != 'undefined' ? jQuery : window.Zepto);\n  }\n})(function ($) {\n  \"use strict\";\n  /*\n      Usage Note:\n      -----------\n      Do not use both ajaxSubmit and ajaxForm on the same form.  These\n      functions are mutually exclusive.  Use ajaxSubmit if you want\n      to bind your own submit handler to the form.  For example,\n  \n      $(document).ready(function() {\n          $('#myForm').on('submit', function(e) {\n              e.preventDefault(); // <-- important\n              $(this).ajaxSubmit({\n                  target: '#output'\n              });\n          });\n      });\n  \n      Use ajaxForm when you want the plugin to manage all the event binding\n      for you.  For example,\n  \n      $(document).ready(function() {\n          $('#myForm').ajaxForm({\n              target: '#output'\n          });\n      });\n  \n      You can also use ajaxForm with delegation (requires jQuery v1.7+), so the\n      form does not have to exist when you invoke ajaxForm:\n  \n      $('#myForm').ajaxForm({\n          delegation: true,\n          target: '#output'\n      });\n  \n      When using ajaxForm, the ajaxSubmit function will be invoked for you\n      at the appropriate time.\n  */\n\n  /**\n   * Feature detection\n   */\n\n  var feature = {};\n  feature.fileapi = $(\"<input type='file'/>\").get(0).files !== undefined;\n  feature.formdata = window.FormData !== undefined;\n  var hasProp = !!$.fn.prop; // attr2 uses prop when it can but checks the return type for\n  // an expected string.  this accounts for the case where a form \n  // contains inputs with names like \"action\" or \"method\"; in those\n  // cases \"prop\" returns the element\n\n  $.fn.attr2 = function () {\n    if (!hasProp) {\n      return this.attr.apply(this, arguments);\n    }\n\n    var val = this.prop.apply(this, arguments);\n\n    if (val && val.jquery || typeof val === 'string') {\n      return val;\n    }\n\n    return this.attr.apply(this, arguments);\n  };\n  /**\n   * ajaxSubmit() provides a mechanism for immediately submitting\n   * an HTML form using AJAX.\n   */\n\n\n  $.fn.ajaxSubmit = function (options) {\n    /*jshint scripturl:true */\n    // fast fail if nothing selected (http://dev.jquery.com/ticket/2752)\n    if (!this.length) {\n      log('ajaxSubmit: skipping submit process - no element selected');\n      return this;\n    }\n\n    var method,\n        action,\n        url,\n        $form = this;\n\n    if (typeof options == 'function') {\n      options = {\n        success: options\n      };\n    } else if (options === undefined) {\n      options = {};\n    }\n\n    method = options.type || this.attr2('method');\n    action = options.url || this.attr2('action');\n    url = typeof action === 'string' ? $.trim(action) : '';\n    url = url || window.location.href || '';\n\n    if (url) {\n      // clean url (don't include hash vaue)\n      url = (url.match(/^([^#]+)/) || [])[1];\n    }\n\n    options = $.extend(true, {\n      url: url,\n      success: $.ajaxSettings.success,\n      type: method || $.ajaxSettings.type,\n      iframeSrc: /^https/i.test(window.location.href || '') ? 'javascript:false' : 'about:blank'\n    }, options); // hook for manipulating the form data before it is extracted;\n    // convenient for use with rich editors like tinyMCE or FCKEditor\n\n    var veto = {};\n    this.trigger('form-pre-serialize', [this, options, veto]);\n\n    if (veto.veto) {\n      log('ajaxSubmit: submit vetoed via form-pre-serialize trigger');\n      return this;\n    } // provide opportunity to alter form data before it is serialized\n\n\n    if (options.beforeSerialize && options.beforeSerialize(this, options) === false) {\n      log('ajaxSubmit: submit aborted via beforeSerialize callback');\n      return this;\n    }\n\n    var traditional = options.traditional;\n\n    if (traditional === undefined) {\n      traditional = $.ajaxSettings.traditional;\n    }\n\n    var elements = [];\n    var qx,\n        a = this.formToArray(options.semantic, elements);\n\n    if (options.data) {\n      options.extraData = options.data;\n      qx = $.param(options.data, traditional);\n    } // give pre-submit callback an opportunity to abort the submit\n\n\n    if (options.beforeSubmit && options.beforeSubmit(a, this, options) === false) {\n      log('ajaxSubmit: submit aborted via beforeSubmit callback');\n      return this;\n    } // fire vetoable 'validate' event\n\n\n    this.trigger('form-submit-validate', [a, this, options, veto]);\n\n    if (veto.veto) {\n      log('ajaxSubmit: submit vetoed via form-submit-validate trigger');\n      return this;\n    }\n\n    var q = $.param(a, traditional);\n\n    if (qx) {\n      q = q ? q + '&' + qx : qx;\n    }\n\n    if (options.type.toUpperCase() == 'GET') {\n      options.url += (options.url.indexOf('?') >= 0 ? '&' : '?') + q;\n      options.data = null; // data is null for 'get'\n    } else {\n      options.data = q; // data is the query string for 'post'\n    }\n\n    var callbacks = [];\n\n    if (options.resetForm) {\n      callbacks.push(function () {\n        $form.resetForm();\n      });\n    }\n\n    if (options.clearForm) {\n      callbacks.push(function () {\n        $form.clearForm(options.includeHidden);\n      });\n    } // perform a load on the target only if dataType is not provided\n\n\n    if (!options.dataType && options.target) {\n      var oldSuccess = options.success || function () {};\n\n      callbacks.push(function (data) {\n        var fn = options.replaceTarget ? 'replaceWith' : 'html';\n        $(options.target)[fn](data).each(oldSuccess, arguments);\n      });\n    } else if (options.success) {\n      callbacks.push(options.success);\n    }\n\n    options.success = function (data, status, xhr) {\n      // jQuery 1.4+ passes xhr as 3rd arg\n      var context = options.context || this; // jQuery 1.4+ supports scope context\n\n      for (var i = 0, max = callbacks.length; i < max; i++) {\n        callbacks[i].apply(context, [data, status, xhr || $form, $form]);\n      }\n    };\n\n    if (options.error) {\n      var oldError = options.error;\n\n      options.error = function (xhr, status, error) {\n        var context = options.context || this;\n        oldError.apply(context, [xhr, status, error, $form]);\n      };\n    }\n\n    if (options.complete) {\n      var oldComplete = options.complete;\n\n      options.complete = function (xhr, status) {\n        var context = options.context || this;\n        oldComplete.apply(context, [xhr, status, $form]);\n      };\n    } // are there files to upload?\n    // [value] (issue #113), also see comment:\n    // https://github.com/malsup/form/commit/588306aedba1de01388032d5f42a60159eea9228#commitcomment-2180219\n\n\n    var fileInputs = $('input[type=file]:enabled', this).filter(function () {\n      return $(this).val() !== '';\n    });\n    var hasFileInputs = fileInputs.length > 0;\n    var mp = 'multipart/form-data';\n    var multipart = $form.attr('enctype') == mp || $form.attr('encoding') == mp;\n    var fileAPI = feature.fileapi && feature.formdata;\n    log(\"fileAPI :\" + fileAPI);\n    var shouldUseFrame = (hasFileInputs || multipart) && !fileAPI;\n    var jqxhr; // options.iframe allows user to force iframe mode\n    // 06-NOV-09: now defaulting to iframe mode if file input is detected\n\n    if (options.iframe !== false && (options.iframe || shouldUseFrame)) {\n      // hack to fix Safari hang (thanks to Tim Molendijk for this)\n      // see:  http://groups.google.com/group/jquery-dev/browse_thread/thread/36395b7ab510dd5d\n      if (options.closeKeepAlive) {\n        $.get(options.closeKeepAlive, function () {\n          jqxhr = fileUploadIframe(a);\n        });\n      } else {\n        jqxhr = fileUploadIframe(a);\n      }\n    } else if ((hasFileInputs || multipart) && fileAPI) {\n      jqxhr = fileUploadXhr(a);\n    } else {\n      jqxhr = $.ajax(options);\n    }\n\n    $form.removeData('jqxhr').data('jqxhr', jqxhr); // clear element array\n\n    for (var k = 0; k < elements.length; k++) {\n      elements[k] = null;\n    } // fire 'notify' event\n\n\n    this.trigger('form-submit-notify', [this, options]);\n    return this; // utility fn for deep serialization\n\n    function deepSerialize(extraData) {\n      var serialized = $.param(extraData, options.traditional).split('&');\n      var len = serialized.length;\n      var result = [];\n      var i, part;\n\n      for (i = 0; i < len; i++) {\n        // #252; undo param space replacement\n        serialized[i] = serialized[i].replace(/\\+/g, ' ');\n        part = serialized[i].split('='); // #278; use array instead of object storage, favoring array serializations\n\n        result.push([decodeURIComponent(part[0]), decodeURIComponent(part[1])]);\n      }\n\n      return result;\n    } // XMLHttpRequest Level 2 file uploads (big hat tip to francois2metz)\n\n\n    function fileUploadXhr(a) {\n      var formdata = new FormData();\n\n      for (var i = 0; i < a.length; i++) {\n        formdata.append(a[i].name, a[i].value);\n      }\n\n      if (options.extraData) {\n        var serializedData = deepSerialize(options.extraData);\n\n        for (i = 0; i < serializedData.length; i++) {\n          if (serializedData[i]) {\n            formdata.append(serializedData[i][0], serializedData[i][1]);\n          }\n        }\n      }\n\n      options.data = null;\n      var s = $.extend(true, {}, $.ajaxSettings, options, {\n        contentType: false,\n        processData: false,\n        cache: false,\n        type: method || 'POST'\n      });\n\n      if (options.uploadProgress) {\n        // workaround because jqXHR does not expose upload property\n        s.xhr = function () {\n          var xhr = $.ajaxSettings.xhr();\n\n          if (xhr.upload) {\n            xhr.upload.addEventListener('progress', function (event) {\n              var percent = 0;\n              var position = event.loaded || event.position;\n              /*event.position is deprecated*/\n\n              var total = event.total;\n\n              if (event.lengthComputable) {\n                percent = Math.ceil(position / total * 100);\n              }\n\n              options.uploadProgress(event, position, total, percent);\n            }, false);\n          }\n\n          return xhr;\n        };\n      }\n\n      s.data = null;\n      var beforeSend = s.beforeSend;\n\n      s.beforeSend = function (xhr, o) {\n        //Send FormData() provided by user\n        if (options.formData) {\n          o.data = options.formData;\n        } else {\n          o.data = formdata;\n        }\n\n        if (beforeSend) {\n          beforeSend.call(this, xhr, o);\n        }\n      };\n\n      return $.ajax(s);\n    } // private function for handling file uploads (hat tip to YAHOO!)\n\n\n    function fileUploadIframe(a) {\n      var form = $form[0],\n          el,\n          i,\n          s,\n          g,\n          id,\n          $io,\n          io,\n          xhr,\n          sub,\n          n,\n          timedOut,\n          timeoutHandle;\n      var deferred = $.Deferred(); // #341\n\n      deferred.abort = function (status) {\n        xhr.abort(status);\n      };\n\n      if (a) {\n        // ensure that every serialized input is still enabled\n        for (i = 0; i < elements.length; i++) {\n          el = $(elements[i]);\n\n          if (hasProp) {\n            el.prop('disabled', false);\n          } else {\n            el.removeAttr('disabled');\n          }\n        }\n      }\n\n      s = $.extend(true, {}, $.ajaxSettings, options);\n      s.context = s.context || s;\n      id = 'jqFormIO' + new Date().getTime();\n\n      if (s.iframeTarget) {\n        $io = $(s.iframeTarget);\n        n = $io.attr2('name');\n\n        if (!n) {\n          $io.attr2('name', id);\n        } else {\n          id = n;\n        }\n      } else {\n        $io = $('<iframe name=\"' + id + '\" src=\"' + s.iframeSrc + '\" />');\n        $io.css({\n          position: 'absolute',\n          top: '-1000px',\n          left: '-1000px'\n        });\n      }\n\n      io = $io[0];\n      xhr = {\n        // mock object\n        aborted: 0,\n        responseText: null,\n        responseXML: null,\n        status: 0,\n        statusText: 'n/a',\n        getAllResponseHeaders: function getAllResponseHeaders() {},\n        getResponseHeader: function getResponseHeader() {},\n        setRequestHeader: function setRequestHeader() {},\n        abort: function abort(status) {\n          var e = status === 'timeout' ? 'timeout' : 'aborted';\n          log('aborting upload... ' + e);\n          this.aborted = 1;\n\n          try {\n            // #214, #257\n            if (io.contentWindow.document.execCommand) {\n              io.contentWindow.document.execCommand('Stop');\n            }\n          } catch (ignore) {}\n\n          $io.attr('src', s.iframeSrc); // abort op in progress\n\n          xhr.error = e;\n\n          if (s.error) {\n            s.error.call(s.context, xhr, e, status);\n          }\n\n          if (g) {\n            $.event.trigger(\"ajaxError\", [xhr, s, e]);\n          }\n\n          if (s.complete) {\n            s.complete.call(s.context, xhr, e);\n          }\n        }\n      };\n      g = s.global; // trigger ajax global events so that activity/block indicators work like normal\n\n      if (g && 0 === $.active++) {\n        $.event.trigger(\"ajaxStart\");\n      }\n\n      if (g) {\n        $.event.trigger(\"ajaxSend\", [xhr, s]);\n      }\n\n      if (s.beforeSend && s.beforeSend.call(s.context, xhr, s) === false) {\n        if (s.global) {\n          $.active--;\n        }\n\n        deferred.reject();\n        return deferred;\n      }\n\n      if (xhr.aborted) {\n        deferred.reject();\n        return deferred;\n      } // add submitting element to data if we know it\n\n\n      sub = form.clk;\n\n      if (sub) {\n        n = sub.name;\n\n        if (n && !sub.disabled) {\n          s.extraData = s.extraData || {};\n          s.extraData[n] = sub.value;\n\n          if (sub.type == \"image\") {\n            s.extraData[n + '.x'] = form.clk_x;\n            s.extraData[n + '.y'] = form.clk_y;\n          }\n        }\n      }\n\n      var CLIENT_TIMEOUT_ABORT = 1;\n      var SERVER_ABORT = 2;\n\n      function getDoc(frame) {\n        /* it looks like contentWindow or contentDocument do not\n         * carry the protocol property in ie8, when running under ssl\n         * frame.document is the only valid response document, since\n         * the protocol is know but not on the other two objects. strange?\n         * \"Same origin policy\" http://en.wikipedia.org/wiki/Same_origin_policy\n         */\n        var doc = null; // IE8 cascading access check\n\n        try {\n          if (frame.contentWindow) {\n            doc = frame.contentWindow.document;\n          }\n        } catch (err) {\n          // IE8 access denied under ssl & missing protocol\n          log('cannot get iframe.contentWindow document: ' + err);\n        }\n\n        if (doc) {\n          // successful getting content\n          return doc;\n        }\n\n        try {\n          // simply checking may throw in ie8 under ssl or mismatched protocol\n          doc = frame.contentDocument ? frame.contentDocument : frame.document;\n        } catch (err) {\n          // last attempt\n          log('cannot get iframe.contentDocument: ' + err);\n          doc = frame.document;\n        }\n\n        return doc;\n      } // Rails CSRF hack (thanks to Yvan Barthelemy)\n\n\n      var csrf_token = $('meta[name=csrf-token]').attr('content');\n      var csrf_param = $('meta[name=csrf-param]').attr('content');\n\n      if (csrf_param && csrf_token) {\n        s.extraData = s.extraData || {};\n        s.extraData[csrf_param] = csrf_token;\n      } // take a breath so that pending repaints get some cpu time before the upload starts\n\n\n      function doSubmit() {\n        // make sure form attrs are set\n        var t = $form.attr2('target'),\n            a = $form.attr2('action'),\n            mp = 'multipart/form-data',\n            et = $form.attr('enctype') || $form.attr('encoding') || mp; // update form attrs in IE friendly way\n\n        form.setAttribute('target', id);\n\n        if (!method || /post/i.test(method)) {\n          form.setAttribute('method', 'POST');\n        }\n\n        if (a != s.url) {\n          form.setAttribute('action', s.url);\n        } // ie borks in some cases when setting encoding\n\n\n        if (!s.skipEncodingOverride && (!method || /post/i.test(method))) {\n          $form.attr({\n            encoding: 'multipart/form-data',\n            enctype: 'multipart/form-data'\n          });\n        } // support timout\n\n\n        if (s.timeout) {\n          timeoutHandle = setTimeout(function () {\n            timedOut = true;\n            cb(CLIENT_TIMEOUT_ABORT);\n          }, s.timeout);\n        } // look for server aborts\n\n\n        function checkState() {\n          try {\n            var state = getDoc(io).readyState;\n            log('state = ' + state);\n\n            if (state && state.toLowerCase() == 'uninitialized') {\n              setTimeout(checkState, 50);\n            }\n          } catch (e) {\n            log('Server abort: ', e, ' (', e.name, ')');\n            cb(SERVER_ABORT);\n\n            if (timeoutHandle) {\n              clearTimeout(timeoutHandle);\n            }\n\n            timeoutHandle = undefined;\n          }\n        } // add \"extra\" data to form if provided in options\n\n\n        var extraInputs = [];\n\n        try {\n          if (s.extraData) {\n            for (var n in s.extraData) {\n              if (s.extraData.hasOwnProperty(n)) {\n                // if using the $.param format that allows for multiple values with the same name\n                if ($.isPlainObject(s.extraData[n]) && s.extraData[n].hasOwnProperty('name') && s.extraData[n].hasOwnProperty('value')) {\n                  extraInputs.push($('<input type=\"hidden\" name=\"' + s.extraData[n].name + '\">').val(s.extraData[n].value).appendTo(form)[0]);\n                } else {\n                  extraInputs.push($('<input type=\"hidden\" name=\"' + n + '\">').val(s.extraData[n]).appendTo(form)[0]);\n                }\n              }\n            }\n          }\n\n          if (!s.iframeTarget) {\n            // add iframe to doc and submit the form\n            $io.appendTo('body');\n          }\n\n          if (io.attachEvent) {\n            io.attachEvent('onload', cb);\n          } else {\n            io.addEventListener('load', cb, false);\n          }\n\n          setTimeout(checkState, 15);\n\n          try {\n            form.submit();\n          } catch (err) {\n            // just in case form has element with name/id of 'submit'\n            var submitFn = document.createElement('form').submit;\n            submitFn.apply(form);\n          }\n        } finally {\n          // reset attrs and remove \"extra\" input elements\n          form.setAttribute('action', a);\n          form.setAttribute('enctype', et); // #380\n\n          if (t) {\n            form.setAttribute('target', t);\n          } else {\n            $form.removeAttr('target');\n          }\n\n          $(extraInputs).remove();\n        }\n      }\n\n      if (s.forceSync) {\n        doSubmit();\n      } else {\n        setTimeout(doSubmit, 10); // this lets dom updates render\n      }\n\n      var data,\n          doc,\n          domCheckCount = 50,\n          callbackProcessed;\n\n      function cb(e) {\n        if (xhr.aborted || callbackProcessed) {\n          return;\n        }\n\n        doc = getDoc(io);\n\n        if (!doc) {\n          log('cannot access response document');\n          e = SERVER_ABORT;\n        }\n\n        if (e === CLIENT_TIMEOUT_ABORT && xhr) {\n          xhr.abort('timeout');\n          deferred.reject(xhr, 'timeout');\n          return;\n        } else if (e == SERVER_ABORT && xhr) {\n          xhr.abort('server abort');\n          deferred.reject(xhr, 'error', 'server abort');\n          return;\n        }\n\n        if (!doc || doc.location.href == s.iframeSrc) {\n          // response not received yet\n          if (!timedOut) {\n            return;\n          }\n        }\n\n        if (io.detachEvent) {\n          io.detachEvent('onload', cb);\n        } else {\n          io.removeEventListener('load', cb, false);\n        }\n\n        var status = 'success',\n            errMsg;\n\n        try {\n          if (timedOut) {\n            throw 'timeout';\n          }\n\n          var isXml = s.dataType == 'xml' || doc.XMLDocument || $.isXMLDoc(doc);\n          log('isXml=' + isXml);\n\n          if (!isXml && window.opera && (doc.body === null || !doc.body.innerHTML)) {\n            if (--domCheckCount) {\n              // in some browsers (Opera) the iframe DOM is not always traversable when\n              // the onload callback fires, so we loop a bit to accommodate\n              log('requeing onLoad callback, DOM not available');\n              setTimeout(cb, 250);\n              return;\n            } // let this fall through because server response could be an empty document\n            //log('Could not access iframe DOM after mutiple tries.');\n            //throw 'DOMException: not available';\n\n          } //log('response detected');\n\n\n          var docRoot = doc.body ? doc.body : doc.documentElement;\n          xhr.responseText = docRoot ? docRoot.innerHTML : null;\n          xhr.responseXML = doc.XMLDocument ? doc.XMLDocument : doc;\n\n          if (isXml) {\n            s.dataType = 'xml';\n          }\n\n          xhr.getResponseHeader = function (header) {\n            var headers = {\n              'content-type': s.dataType\n            };\n            return headers[header.toLowerCase()];\n          }; // support for XHR 'status' & 'statusText' emulation :\n\n\n          if (docRoot) {\n            xhr.status = Number(docRoot.getAttribute('status')) || xhr.status;\n            xhr.statusText = docRoot.getAttribute('statusText') || xhr.statusText;\n          }\n\n          var dt = (s.dataType || '').toLowerCase();\n          var scr = /(json|script|text)/.test(dt);\n\n          if (scr || s.textarea) {\n            // see if user embedded response in textarea\n            var ta = doc.getElementsByTagName('textarea')[0];\n\n            if (ta) {\n              xhr.responseText = ta.value; // support for XHR 'status' & 'statusText' emulation :\n\n              xhr.status = Number(ta.getAttribute('status')) || xhr.status;\n              xhr.statusText = ta.getAttribute('statusText') || xhr.statusText;\n            } else if (scr) {\n              // account for browsers injecting pre around json response\n              var pre = doc.getElementsByTagName('pre')[0];\n              var b = doc.getElementsByTagName('body')[0];\n\n              if (pre) {\n                xhr.responseText = pre.textContent ? pre.textContent : pre.innerText;\n              } else if (b) {\n                xhr.responseText = b.textContent ? b.textContent : b.innerText;\n              }\n            }\n          } else if (dt == 'xml' && !xhr.responseXML && xhr.responseText) {\n            xhr.responseXML = toXml(xhr.responseText);\n          }\n\n          try {\n            data = httpData(xhr, dt, s);\n          } catch (err) {\n            status = 'parsererror';\n            xhr.error = errMsg = err || status;\n          }\n        } catch (err) {\n          log('error caught: ', err);\n          status = 'error';\n          xhr.error = errMsg = err || status;\n        }\n\n        if (xhr.aborted) {\n          log('upload aborted');\n          status = null;\n        }\n\n        if (xhr.status) {\n          // we've set xhr.status\n          status = xhr.status >= 200 && xhr.status < 300 || xhr.status === 304 ? 'success' : 'error';\n        } // ordering of these callbacks/triggers is odd, but that's how $.ajax does it\n\n\n        if (status === 'success') {\n          if (s.success) {\n            s.success.call(s.context, data, 'success', xhr);\n          }\n\n          deferred.resolve(xhr.responseText, 'success', xhr);\n\n          if (g) {\n            $.event.trigger(\"ajaxSuccess\", [xhr, s]);\n          }\n        } else if (status) {\n          if (errMsg === undefined) {\n            errMsg = xhr.statusText;\n          }\n\n          if (s.error) {\n            s.error.call(s.context, xhr, status, errMsg);\n          }\n\n          deferred.reject(xhr, 'error', errMsg);\n\n          if (g) {\n            $.event.trigger(\"ajaxError\", [xhr, s, errMsg]);\n          }\n        }\n\n        if (g) {\n          $.event.trigger(\"ajaxComplete\", [xhr, s]);\n        }\n\n        if (g && ! --$.active) {\n          $.event.trigger(\"ajaxStop\");\n        }\n\n        if (s.complete) {\n          s.complete.call(s.context, xhr, status);\n        }\n\n        callbackProcessed = true;\n\n        if (s.timeout) {\n          clearTimeout(timeoutHandle);\n        } // clean up\n\n\n        setTimeout(function () {\n          if (!s.iframeTarget) {\n            $io.remove();\n          } else {\n            //adding else to clean up existing iframe response.\n            $io.attr('src', s.iframeSrc);\n          }\n\n          xhr.responseXML = null;\n        }, 100);\n      }\n\n      var toXml = $.parseXML || function (s, doc) {\n        // use parseXML if available (jQuery 1.5+)\n        if (window.ActiveXObject) {\n          doc = new ActiveXObject('Microsoft.XMLDOM');\n          doc.async = 'false';\n          doc.loadXML(s);\n        } else {\n          doc = new DOMParser().parseFromString(s, 'text/xml');\n        }\n\n        return doc && doc.documentElement && doc.documentElement.nodeName != 'parsererror' ? doc : null;\n      };\n\n      var parseJSON = $.parseJSON || function (s) {\n        /*jslint evil:true */\n        return window['eval']('(' + s + ')');\n      };\n\n      var httpData = function httpData(xhr, type, s) {\n        // mostly lifted from jq1.4.4\n        var ct = xhr.getResponseHeader('content-type') || '',\n            xml = type === 'xml' || !type && ct.indexOf('xml') >= 0,\n            data = xml ? xhr.responseXML : xhr.responseText;\n\n        if (xml && data.documentElement.nodeName === 'parsererror') {\n          if ($.error) {\n            $.error('parsererror');\n          }\n        }\n\n        if (s && s.dataFilter) {\n          data = s.dataFilter(data, type);\n        }\n\n        if (typeof data === 'string') {\n          if (type === 'json' || !type && ct.indexOf('json') >= 0) {\n            data = parseJSON(data);\n          } else if (type === \"script\" || !type && ct.indexOf(\"javascript\") >= 0) {\n            $.globalEval(data);\n          }\n        }\n\n        return data;\n      };\n\n      return deferred;\n    }\n  };\n  /**\n   * ajaxForm() provides a mechanism for fully automating form submission.\n   *\n   * The advantages of using this method instead of ajaxSubmit() are:\n   *\n   * 1: This method will include coordinates for <input type=\"image\" /> elements (if the element\n   *    is used to submit the form).\n   * 2. This method will include the submit element's name/value data (for the element that was\n   *    used to submit the form).\n   * 3. This method binds the submit() method to the form for you.\n   *\n   * The options argument for ajaxForm works exactly as it does for ajaxSubmit.  ajaxForm merely\n   * passes the options argument along after properly binding events for submit elements and\n   * the form itself.\n   */\n\n\n  $.fn.ajaxForm = function (options) {\n    options = options || {};\n    options.delegation = options.delegation && $.isFunction($.fn.on); // in jQuery 1.3+ we can fix mistakes with the ready state\n\n    if (!options.delegation && this.length === 0) {\n      var o = {\n        s: this.selector,\n        c: this.context\n      };\n\n      if (!$.isReady && o.s) {\n        log('DOM not ready, queuing ajaxForm');\n        $(function () {\n          $(o.s, o.c).ajaxForm(options);\n        });\n        return this;\n      } // is your DOM ready?  http://docs.jquery.com/Tutorials:Introducing_$(document).ready()\n\n\n      log('terminating; zero elements found by selector' + ($.isReady ? '' : ' (DOM not ready)'));\n      return this;\n    }\n\n    if (options.delegation) {\n      $(document).off('submit.form-plugin', this.selector, doAjaxSubmit).off('click.form-plugin', this.selector, captureSubmittingElement).on('submit.form-plugin', this.selector, options, doAjaxSubmit).on('click.form-plugin', this.selector, options, captureSubmittingElement);\n      return this;\n    }\n\n    return this.ajaxFormUnbind().bind('submit.form-plugin', options, doAjaxSubmit).bind('click.form-plugin', options, captureSubmittingElement);\n  }; // private event handlers\n\n\n  function doAjaxSubmit(e) {\n    /*jshint validthis:true */\n    var options = e.data;\n\n    if (!e.isDefaultPrevented()) {\n      // if event has been canceled, don't proceed\n      e.preventDefault();\n      $(e.target).ajaxSubmit(options); // #365\n    }\n  }\n\n  function captureSubmittingElement(e) {\n    /*jshint validthis:true */\n    var target = e.target;\n    var $el = $(target);\n\n    if (!$el.is(\"[type=submit],[type=image]\")) {\n      // is this a child element of the submit el?  (ex: a span within a button)\n      var t = $el.closest('[type=submit]');\n\n      if (t.length === 0) {\n        return;\n      }\n\n      target = t[0];\n    }\n\n    var form = this;\n    form.clk = target;\n\n    if (target.type == 'image') {\n      if (e.offsetX !== undefined) {\n        form.clk_x = e.offsetX;\n        form.clk_y = e.offsetY;\n      } else if (typeof $.fn.offset == 'function') {\n        var offset = $el.offset();\n        form.clk_x = e.pageX - offset.left;\n        form.clk_y = e.pageY - offset.top;\n      } else {\n        form.clk_x = e.pageX - target.offsetLeft;\n        form.clk_y = e.pageY - target.offsetTop;\n      }\n    } // clear form vars\n\n\n    setTimeout(function () {\n      form.clk = form.clk_x = form.clk_y = null;\n    }, 100);\n  } // ajaxFormUnbind unbinds the event handlers that were bound by ajaxForm\n\n\n  $.fn.ajaxFormUnbind = function () {\n    return this.unbind('submit.form-plugin click.form-plugin');\n  };\n  /**\n   * formToArray() gathers form element data into an array of objects that can\n   * be passed to any of the following ajax functions: $.get, $.post, or load.\n   * Each object in the array has both a 'name' and 'value' property.  An example of\n   * an array for a simple login form might be:\n   *\n   * [ { name: 'username', value: 'jresig' }, { name: 'password', value: 'secret' } ]\n   *\n   * It is this array that is passed to pre-submit callback functions provided to the\n   * ajaxSubmit() and ajaxForm() methods.\n   */\n\n\n  $.fn.formToArray = function (semantic, elements) {\n    var a = [];\n\n    if (this.length === 0) {\n      return a;\n    }\n\n    var form = this[0];\n    var formId = this.attr('id');\n    var els = semantic ? form.getElementsByTagName('*') : form.elements;\n    var els2;\n\n    if (els && !/MSIE [678]/.test(navigator.userAgent)) {\n      // #390\n      els = $(els).get(); // convert to standard array\n    } // #386; account for inputs outside the form which use the 'form' attribute\n\n\n    if (formId) {\n      els2 = $(':input[form=\"' + formId + '\"]').get(); // hat tip @thet\n\n      if (els2.length) {\n        els = (els || []).concat(els2);\n      }\n    }\n\n    if (!els || !els.length) {\n      return a;\n    }\n\n    var i, j, n, v, el, max, jmax;\n\n    for (i = 0, max = els.length; i < max; i++) {\n      el = els[i];\n      n = el.name;\n\n      if (!n || el.disabled) {\n        continue;\n      }\n\n      if (semantic && form.clk && el.type == \"image\") {\n        // handle image inputs on the fly when semantic == true\n        if (form.clk == el) {\n          a.push({\n            name: n,\n            value: $(el).val(),\n            type: el.type\n          });\n          a.push({\n            name: n + '.x',\n            value: form.clk_x\n          }, {\n            name: n + '.y',\n            value: form.clk_y\n          });\n        }\n\n        continue;\n      }\n\n      v = $.fieldValue(el, true);\n\n      if (v && v.constructor == Array) {\n        if (elements) {\n          elements.push(el);\n        }\n\n        for (j = 0, jmax = v.length; j < jmax; j++) {\n          a.push({\n            name: n,\n            value: v[j]\n          });\n        }\n      } else if (feature.fileapi && el.type == 'file') {\n        if (elements) {\n          elements.push(el);\n        }\n\n        var files = el.files;\n\n        if (files.length) {\n          for (j = 0; j < files.length; j++) {\n            a.push({\n              name: n,\n              value: files[j],\n              type: el.type\n            });\n          }\n        } else {\n          // #180\n          a.push({\n            name: n,\n            value: '',\n            type: el.type\n          });\n        }\n      } else if (v !== null && typeof v != 'undefined') {\n        if (elements) {\n          elements.push(el);\n        }\n\n        a.push({\n          name: n,\n          value: v,\n          type: el.type,\n          required: el.required\n        });\n      }\n    }\n\n    if (!semantic && form.clk) {\n      // input type=='image' are not found in elements array! handle it here\n      var $input = $(form.clk),\n          input = $input[0];\n      n = input.name;\n\n      if (n && !input.disabled && input.type == 'image') {\n        a.push({\n          name: n,\n          value: $input.val()\n        });\n        a.push({\n          name: n + '.x',\n          value: form.clk_x\n        }, {\n          name: n + '.y',\n          value: form.clk_y\n        });\n      }\n    }\n\n    return a;\n  };\n  /**\n   * Serializes form data into a 'submittable' string. This method will return a string\n   * in the format: name1=value1&amp;name2=value2\n   */\n\n\n  $.fn.formSerialize = function (semantic) {\n    //hand off to jQuery.param for proper encoding\n    return $.param(this.formToArray(semantic));\n  };\n  /**\n   * Serializes all field elements in the jQuery object into a query string.\n   * This method will return a string in the format: name1=value1&amp;name2=value2\n   */\n\n\n  $.fn.fieldSerialize = function (successful) {\n    var a = [];\n    this.each(function () {\n      var n = this.name;\n\n      if (!n) {\n        return;\n      }\n\n      var v = $.fieldValue(this, successful);\n\n      if (v && v.constructor == Array) {\n        for (var i = 0, max = v.length; i < max; i++) {\n          a.push({\n            name: n,\n            value: v[i]\n          });\n        }\n      } else if (v !== null && typeof v != 'undefined') {\n        a.push({\n          name: this.name,\n          value: v\n        });\n      }\n    }); //hand off to jQuery.param for proper encoding\n\n    return $.param(a);\n  };\n  /**\n   * Returns the value(s) of the element in the matched set.  For example, consider the following form:\n   *\n   *  <form><fieldset>\n   *      <input name=\"A\" type=\"text\" />\n   *      <input name=\"A\" type=\"text\" />\n   *      <input name=\"B\" type=\"checkbox\" value=\"B1\" />\n   *      <input name=\"B\" type=\"checkbox\" value=\"B2\"/>\n   *      <input name=\"C\" type=\"radio\" value=\"C1\" />\n   *      <input name=\"C\" type=\"radio\" value=\"C2\" />\n   *  </fieldset></form>\n   *\n   *  var v = $('input[type=text]').fieldValue();\n   *  // if no values are entered into the text inputs\n   *  v == ['','']\n   *  // if values entered into the text inputs are 'foo' and 'bar'\n   *  v == ['foo','bar']\n   *\n   *  var v = $('input[type=checkbox]').fieldValue();\n   *  // if neither checkbox is checked\n   *  v === undefined\n   *  // if both checkboxes are checked\n   *  v == ['B1', 'B2']\n   *\n   *  var v = $('input[type=radio]').fieldValue();\n   *  // if neither radio is checked\n   *  v === undefined\n   *  // if first radio is checked\n   *  v == ['C1']\n   *\n   * The successful argument controls whether or not the field element must be 'successful'\n   * (per http://www.w3.org/TR/html4/interact/forms.html#successful-controls).\n   * The default value of the successful argument is true.  If this value is false the value(s)\n   * for each element is returned.\n   *\n   * Note: This method *always* returns an array.  If no valid value can be determined the\n   *    array will be empty, otherwise it will contain one or more values.\n   */\n\n\n  $.fn.fieldValue = function (successful) {\n    for (var val = [], i = 0, max = this.length; i < max; i++) {\n      var el = this[i];\n      var v = $.fieldValue(el, successful);\n\n      if (v === null || typeof v == 'undefined' || v.constructor == Array && !v.length) {\n        continue;\n      }\n\n      if (v.constructor == Array) {\n        $.merge(val, v);\n      } else {\n        val.push(v);\n      }\n    }\n\n    return val;\n  };\n  /**\n   * Returns the value of the field element.\n   */\n\n\n  $.fieldValue = function (el, successful) {\n    var n = el.name,\n        t = el.type,\n        tag = el.tagName.toLowerCase();\n\n    if (successful === undefined) {\n      successful = true;\n    }\n\n    if (successful && (!n || el.disabled || t == 'reset' || t == 'button' || (t == 'checkbox' || t == 'radio') && !el.checked || (t == 'submit' || t == 'image') && el.form && el.form.clk != el || tag == 'select' && el.selectedIndex == -1)) {\n      return null;\n    }\n\n    if (tag == 'select') {\n      var index = el.selectedIndex;\n\n      if (index < 0) {\n        return null;\n      }\n\n      var a = [],\n          ops = el.options;\n      var one = t == 'select-one';\n      var max = one ? index + 1 : ops.length;\n\n      for (var i = one ? index : 0; i < max; i++) {\n        var op = ops[i];\n\n        if (op.selected) {\n          var v = op.value;\n\n          if (!v) {\n            // extra pain for IE...\n            v = op.attributes && op.attributes.value && !op.attributes.value.specified ? op.text : op.value;\n          }\n\n          if (one) {\n            return v;\n          }\n\n          a.push(v);\n        }\n      }\n\n      return a;\n    }\n\n    return $(el).val();\n  };\n  /**\n   * Clears the form data.  Takes the following actions on the form's input fields:\n   *  - input text fields will have their 'value' property set to the empty string\n   *  - select elements will have their 'selectedIndex' property set to -1\n   *  - checkbox and radio inputs will have their 'checked' property set to false\n   *  - inputs of type submit, button, reset, and hidden will *not* be effected\n   *  - button elements will *not* be effected\n   */\n\n\n  $.fn.clearForm = function (includeHidden) {\n    return this.each(function () {\n      $('input,select,textarea', this).clearFields(includeHidden);\n    });\n  };\n  /**\n   * Clears the selected form elements.\n   */\n\n\n  $.fn.clearFields = $.fn.clearInputs = function (includeHidden) {\n    var re = /^(?:color|date|datetime|email|month|number|password|range|search|tel|text|time|url|week)$/i; // 'hidden' is not in this list\n\n    return this.each(function () {\n      var t = this.type,\n          tag = this.tagName.toLowerCase();\n\n      if (re.test(t) || tag == 'textarea') {\n        this.value = '';\n      } else if (t == 'checkbox' || t == 'radio') {\n        this.checked = false;\n      } else if (tag == 'select') {\n        this.selectedIndex = -1;\n      } else if (t == \"file\") {\n        if (/MSIE/.test(navigator.userAgent)) {\n          $(this).replaceWith($(this).clone(true));\n        } else {\n          $(this).val('');\n        }\n      } else if (includeHidden) {\n        // includeHidden can be the value true, or it can be a selector string\n        // indicating a special test; for example:\n        //  $('#myForm').clearForm('.special:hidden')\n        // the above would clean hidden inputs that have the class of 'special'\n        if (includeHidden === true && /hidden/.test(t) || typeof includeHidden == 'string' && $(this).is(includeHidden)) {\n          this.value = '';\n        }\n      }\n    });\n  };\n  /**\n   * Resets the form data.  Causes all form elements to be reset to their original value.\n   */\n\n\n  $.fn.resetForm = function () {\n    return this.each(function () {\n      // guard against an input with the name of 'reset'\n      // note that IE reports the reset function as an 'object'\n      if (typeof this.reset == 'function' || _typeof(this.reset) == 'object' && !this.reset.nodeType) {\n        this.reset();\n      }\n    });\n  };\n  /**\n   * Enables or disables any matching elements.\n   */\n\n\n  $.fn.enable = function (b) {\n    if (b === undefined) {\n      b = true;\n    }\n\n    return this.each(function () {\n      this.disabled = !b;\n    });\n  };\n  /**\n   * Checks/unchecks any matching checkboxes or radio buttons and\n   * selects/deselects and matching option elements.\n   */\n\n\n  $.fn.selected = function (select) {\n    if (select === undefined) {\n      select = true;\n    }\n\n    return this.each(function () {\n      var t = this.type;\n\n      if (t == 'checkbox' || t == 'radio') {\n        this.checked = select;\n      } else if (this.tagName.toLowerCase() == 'option') {\n        var $sel = $(this).parent('select');\n\n        if (select && $sel[0] && $sel[0].type == 'select-one') {\n          // deselect all other options\n          $sel.find('option').selected(false);\n        }\n\n        this.selected = select;\n      }\n    });\n  }; // expose debug var\n\n\n  $.fn.ajaxSubmit.debug = false; // helper fn for console logging\n\n  function log() {\n    if (!$.fn.ajaxSubmit.debug) {\n      return;\n    }\n\n    var msg = '[jquery.form] ' + Array.prototype.join.call(arguments, '');\n\n    if (window.console && window.console.log) {\n      window.console.log(msg);\n    } else if (window.opera && window.opera.postError) {\n      window.opera.postError(msg);\n    }\n  }\n});"

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./node_modules/babel-loader/lib/index.js?!./assets/js/jquery.qtip.nightly.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/raw-loader!./node_modules/babel-loader/lib??ref--4-0!./assets/js/jquery.qtip.nightly.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*\n * qTip2 - Pretty powerful tooltips - v2.2.1-29-\n * http://qtip2.com\n *\n * Copyright (c) 2015 \n * Released under the MIT licenses\n * http://jquery.org/license\n *\n * Date: Tue Dec 8 2015 05:50 EST-0500\n * Plugins: tips modal viewport svg imagemap ie6\n * Styles: core basic css3\n */\n\n/*global window: false, jQuery: false, console: false, define: false */\n\n/* Cache window, document, undefined */\n(function (window, document, undefined) {\n  // Uses AMD or browser globals to create a jQuery plugin.\n  (function (factory) {\n    \"use strict\";\n\n    if (typeof define === 'function' && define.amd) {\n      define(['jquery'], factory);\n    } else if (jQuery && !jQuery.fn.qtip) {\n      factory(jQuery);\n    }\n  })(function ($) {\n    \"use strict\"; // Enable ECMAScript \"strict\" operation for this function. See more: http://ejohn.org/blog/ecmascript-5-strict-mode-json-and-more/\n\n    ; // Munge the primitives - Paul Irish tip\n\n    var TRUE = true,\n        FALSE = false,\n        NULL = null,\n        // Common variables\n    X = 'x',\n        Y = 'y',\n        WIDTH = 'width',\n        HEIGHT = 'height',\n        // Positioning sides\n    TOP = 'top',\n        LEFT = 'left',\n        BOTTOM = 'bottom',\n        RIGHT = 'right',\n        CENTER = 'center',\n        // Position adjustment types\n    FLIP = 'flip',\n        FLIPINVERT = 'flipinvert',\n        SHIFT = 'shift',\n        // Shortcut vars\n    QTIP,\n        PROTOTYPE,\n        CORNER,\n        CHECKS,\n        PLUGINS = {},\n        NAMESPACE = 'qtip',\n        ATTR_HAS = 'data-hasqtip',\n        ATTR_ID = 'data-qtip-id',\n        WIDGET = ['ui-widget', 'ui-tooltip'],\n        SELECTOR = '.' + NAMESPACE,\n        INACTIVE_EVENTS = 'click dblclick mousedown mouseup mousemove mouseleave mouseenter'.split(' '),\n        CLASS_FIXED = NAMESPACE + '-fixed',\n        CLASS_DEFAULT = NAMESPACE + '-default',\n        CLASS_FOCUS = NAMESPACE + '-focus',\n        CLASS_HOVER = NAMESPACE + '-hover',\n        CLASS_DISABLED = NAMESPACE + '-disabled',\n        replaceSuffix = '_replacedByqTip',\n        oldtitle = 'oldtitle',\n        trackingBound,\n        // Browser detection\n    BROWSER = {\n      /*\n       * IE version detection\n       *\n       * Adapted from: http://ajaxian.com/archives/attack-of-the-ie-conditional-comment\n       * Credit to James Padolsey for the original implemntation!\n       */\n      ie: function () {\n        for (var v = 4, i = document.createElement(\"div\"); (i.innerHTML = \"<!--[if gt IE \" + v + \"]><i></i><![endif]-->\") && i.getElementsByTagName(\"i\")[0]; v += 1) {}\n\n        return v > 4 ? v : NaN;\n      }(),\n\n      /*\n       * iOS version detection\n       */\n      iOS: parseFloat(('' + (/CPU.*OS ([0-9_]{1,5})|(CPU like).*AppleWebKit.*Mobile/i.exec(navigator.userAgent) || [0, ''])[1]).replace('undefined', '3_2').replace('_', '.').replace('_', '')) || FALSE\n    };\n    ;\n\n    function QTip(target, options, id, attr) {\n      // Elements and ID\n      this.id = id;\n      this.target = target;\n      this.tooltip = NULL;\n      this.elements = {\n        target: target\n      }; // Internal constructs\n\n      this._id = NAMESPACE + '-' + id;\n      this.timers = {\n        img: {}\n      };\n      this.options = options;\n      this.plugins = {}; // Cache object\n\n      this.cache = {\n        event: {},\n        target: $(),\n        disabled: FALSE,\n        attr: attr,\n        onTooltip: FALSE,\n        lastClass: ''\n      }; // Set the initial flags\n\n      this.rendered = this.destroyed = this.disabled = this.waiting = this.hiddenDuringWait = this.positioning = this.triggering = FALSE;\n    }\n\n    PROTOTYPE = QTip.prototype;\n\n    PROTOTYPE._when = function (deferreds) {\n      return $.when.apply($, deferreds);\n    };\n\n    PROTOTYPE.render = function (show) {\n      if (this.rendered || this.destroyed) {\n        return this;\n      } // If tooltip has already been rendered, exit\n\n\n      var self = this,\n          options = this.options,\n          cache = this.cache,\n          elements = this.elements,\n          text = options.content.text,\n          title = options.content.title,\n          button = options.content.button,\n          posOptions = options.position,\n          namespace = '.' + this._id + ' ',\n          deferreds = [],\n          tooltip; // Add ARIA attributes to target\n\n      $.attr(this.target[0], 'aria-describedby', this._id); // Create public position object that tracks current position corners\n\n      cache.posClass = this._createPosClass((this.position = {\n        my: posOptions.my,\n        at: posOptions.at\n      }).my); // Create tooltip element\n\n      this.tooltip = elements.tooltip = tooltip = $('<div/>', {\n        'id': this._id,\n        'class': [NAMESPACE, CLASS_DEFAULT, options.style.classes, cache.posClass].join(' '),\n        'width': options.style.width || '',\n        'height': options.style.height || '',\n        'tracking': posOptions.target === 'mouse' && posOptions.adjust.mouse,\n\n        /* ARIA specific attributes */\n        'role': 'alert',\n        'aria-live': 'polite',\n        'aria-atomic': FALSE,\n        'aria-describedby': this._id + '-content',\n        'aria-hidden': TRUE\n      }).toggleClass(CLASS_DISABLED, this.disabled).attr(ATTR_ID, this.id).data(NAMESPACE, this).appendTo(posOptions.container).append( // Create content element\n      elements.content = $('<div />', {\n        'class': NAMESPACE + '-content',\n        'id': this._id + '-content',\n        'aria-atomic': TRUE\n      })); // Set rendered flag and prevent redundant reposition calls for now\n\n      this.rendered = -1;\n      this.positioning = TRUE; // Create title...\n\n      if (title) {\n        this._createTitle(); // Update title only if its not a callback (called in toggle if so)\n\n\n        if (!$.isFunction(title)) {\n          deferreds.push(this._updateTitle(title, FALSE));\n        }\n      } // Create button\n\n\n      if (button) {\n        this._createButton();\n      } // Set proper rendered flag and update content if not a callback function (called in toggle)\n\n\n      if (!$.isFunction(text)) {\n        deferreds.push(this._updateContent(text, FALSE));\n      }\n\n      this.rendered = TRUE; // Setup widget classes\n\n      this._setWidget(); // Initialize 'render' plugins\n\n\n      $.each(PLUGINS, function (name) {\n        var instance;\n\n        if (this.initialize === 'render' && (instance = this(self))) {\n          self.plugins[name] = instance;\n        }\n      }); // Unassign initial events and assign proper events\n\n      this._unassignEvents();\n\n      this._assignEvents(); // When deferreds have completed\n\n\n      this._when(deferreds).then(function () {\n        // tooltiprender event\n        self._trigger('render'); // Reset flags\n\n\n        self.positioning = FALSE; // Show tooltip if not hidden during wait period\n\n        if (!self.hiddenDuringWait && (options.show.ready || show)) {\n          self.toggle(TRUE, cache.event, FALSE);\n        }\n\n        self.hiddenDuringWait = FALSE;\n      }); // Expose API\n\n\n      QTIP.api[this.id] = this;\n      return this;\n    };\n\n    PROTOTYPE.destroy = function (immediate) {\n      // Set flag the signify destroy is taking place to plugins\n      // and ensure it only gets destroyed once!\n      if (this.destroyed) {\n        return this.target;\n      }\n\n      function process() {\n        if (this.destroyed) {\n          return;\n        }\n\n        this.destroyed = TRUE;\n        var target = this.target,\n            title = target.attr(oldtitle),\n            timer; // Destroy tooltip if rendered\n\n        if (this.rendered) {\n          this.tooltip.stop(1, 0).find('*').remove().end().remove();\n        } // Destroy all plugins\n\n\n        $.each(this.plugins, function (name) {\n          this.destroy && this.destroy();\n        }); // Clear timers\n\n        for (timer in this.timers) {\n          clearTimeout(this.timers[timer]);\n        } // Remove api object and ARIA attributes\n\n\n        target.removeData(NAMESPACE).removeAttr(ATTR_ID).removeAttr(ATTR_HAS).removeAttr('aria-describedby'); // Reset old title attribute if removed\n\n        if (this.options.suppress && title) {\n          target.attr('title', title).removeAttr(oldtitle);\n        } // Remove qTip events associated with this API\n\n\n        this._unassignEvents(); // Remove ID from used id objects, and delete object references\n        // for better garbage collection and leak protection\n\n\n        this.options = this.elements = this.cache = this.timers = this.plugins = this.mouse = NULL; // Delete epoxsed API object\n\n        delete QTIP.api[this.id];\n      } // If an immediate destroy is needed\n\n\n      if ((immediate !== TRUE || this.triggering === 'hide') && this.rendered) {\n        this.tooltip.one('tooltiphidden', $.proxy(process, this));\n        !this.triggering && this.hide();\n      } // If we're not in the process of hiding... process\n      else {\n          process.call(this);\n        }\n\n      return this.target;\n    };\n\n    ;\n\n    function invalidOpt(a) {\n      return a === NULL || $.type(a) !== 'object';\n    }\n\n    function invalidContent(c) {\n      return !($.isFunction(c) || c && c.attr || c.length || $.type(c) === 'object' && (c.jquery || c.then));\n    } // Option object sanitizer\n\n\n    function sanitizeOptions(opts) {\n      var content, text, ajax, once;\n\n      if (invalidOpt(opts)) {\n        return FALSE;\n      }\n\n      if (invalidOpt(opts.metadata)) {\n        opts.metadata = {\n          type: opts.metadata\n        };\n      }\n\n      if ('content' in opts) {\n        content = opts.content;\n\n        if (invalidOpt(content) || content.jquery || content.done) {\n          content = opts.content = {\n            text: text = invalidContent(content) ? FALSE : content\n          };\n        } else {\n          text = content.text;\n        } // DEPRECATED - Old content.ajax plugin functionality\n        // Converts it into the proper Deferred syntax\n\n\n        if ('ajax' in content) {\n          ajax = content.ajax;\n          once = ajax && ajax.once !== FALSE;\n          delete content.ajax;\n\n          content.text = function (event, api) {\n            var loading = text || $(this).attr(api.options.content.attr) || 'Loading...',\n                deferred = $.ajax($.extend({}, ajax, {\n              context: api\n            })).then(ajax.success, NULL, ajax.error).then(function (content) {\n              if (content && once) {\n                api.set('content.text', content);\n              }\n\n              return content;\n            }, function (xhr, status, error) {\n              if (api.destroyed || xhr.status === 0) {\n                return;\n              }\n\n              api.set('content.text', status + ': ' + error);\n            });\n            return !once ? (api.set('content.text', loading), deferred) : loading;\n          };\n        }\n\n        if ('title' in content) {\n          if ($.isPlainObject(content.title)) {\n            content.button = content.title.button;\n            content.title = content.title.text;\n          }\n\n          if (invalidContent(content.title || FALSE)) {\n            content.title = FALSE;\n          }\n        }\n      }\n\n      if ('position' in opts && invalidOpt(opts.position)) {\n        opts.position = {\n          my: opts.position,\n          at: opts.position\n        };\n      }\n\n      if ('show' in opts && invalidOpt(opts.show)) {\n        opts.show = opts.show.jquery ? {\n          target: opts.show\n        } : opts.show === TRUE ? {\n          ready: TRUE\n        } : {\n          event: opts.show\n        };\n      }\n\n      if ('hide' in opts && invalidOpt(opts.hide)) {\n        opts.hide = opts.hide.jquery ? {\n          target: opts.hide\n        } : {\n          event: opts.hide\n        };\n      }\n\n      if ('style' in opts && invalidOpt(opts.style)) {\n        opts.style = {\n          classes: opts.style\n        };\n      } // Sanitize plugin options\n\n\n      $.each(PLUGINS, function () {\n        this.sanitize && this.sanitize(opts);\n      });\n      return opts;\n    } // Setup builtin .set() option checks\n\n\n    CHECKS = PROTOTYPE.checks = {\n      builtin: {\n        // Core checks\n        '^id$': function id$(obj, o, v, prev) {\n          var id = v === TRUE ? QTIP.nextid : v,\n              new_id = NAMESPACE + '-' + id;\n\n          if (id !== FALSE && id.length > 0 && !$('#' + new_id).length) {\n            this._id = new_id;\n\n            if (this.rendered) {\n              this.tooltip[0].id = this._id;\n              this.elements.content[0].id = this._id + '-content';\n              this.elements.title[0].id = this._id + '-title';\n            }\n          } else {\n            obj[o] = prev;\n          }\n        },\n        '^prerender': function prerender(obj, o, v) {\n          v && !this.rendered && this.render(this.options.show.ready);\n        },\n        // Content checks\n        '^content.text$': function contentText$(obj, o, v) {\n          this._updateContent(v);\n        },\n        '^content.attr$': function contentAttr$(obj, o, v, prev) {\n          if (this.options.content.text === this.target.attr(prev)) {\n            this._updateContent(this.target.attr(v));\n          }\n        },\n        '^content.title$': function contentTitle$(obj, o, v) {\n          // Remove title if content is null\n          if (!v) {\n            return this._removeTitle();\n          } // If title isn't already created, create it now and update\n\n\n          v && !this.elements.title && this._createTitle();\n\n          this._updateTitle(v);\n        },\n        '^content.button$': function contentButton$(obj, o, v) {\n          this._updateButton(v);\n        },\n        '^content.title.(text|button)$': function contentTitleTextButton$(obj, o, v) {\n          this.set('content.' + o, v); // Backwards title.text/button compat\n        },\n        // Position checks\n        '^position.(my|at)$': function positionMyAt$(obj, o, v) {\n          if ('string' === typeof v) {\n            this.position[o] = obj[o] = new CORNER(v, o === 'at');\n          }\n        },\n        '^position.container$': function positionContainer$(obj, o, v) {\n          this.rendered && this.tooltip.appendTo(v);\n        },\n        // Show checks\n        '^show.ready$': function showReady$(obj, o, v) {\n          v && (!this.rendered && this.render(TRUE) || this.toggle(TRUE));\n        },\n        // Style checks\n        '^style.classes$': function styleClasses$(obj, o, v, p) {\n          this.rendered && this.tooltip.removeClass(p).addClass(v);\n        },\n        '^style.(width|height)': function styleWidthHeight(obj, o, v) {\n          this.rendered && this.tooltip.css(o, v);\n        },\n        '^style.widget|content.title': function styleWidgetContentTitle() {\n          this.rendered && this._setWidget();\n        },\n        '^style.def': function styleDef(obj, o, v) {\n          this.rendered && this.tooltip.toggleClass(CLASS_DEFAULT, !!v);\n        },\n        // Events check\n        '^events.(render|show|move|hide|focus|blur)$': function eventsRenderShowMoveHideFocusBlur$(obj, o, v) {\n          this.rendered && this.tooltip[($.isFunction(v) ? '' : 'un') + 'bind']('tooltip' + o, v);\n        },\n        // Properties which require event reassignment\n        '^(show|hide|position).(event|target|fixed|inactive|leave|distance|viewport|adjust)': function showHidePositionEventTargetFixedInactiveLeaveDistanceViewportAdjust() {\n          if (!this.rendered) {\n            return;\n          } // Set tracking flag\n\n\n          var posOptions = this.options.position;\n          this.tooltip.attr('tracking', posOptions.target === 'mouse' && posOptions.adjust.mouse); // Reassign events\n\n          this._unassignEvents();\n\n          this._assignEvents();\n        }\n      }\n    }; // Dot notation converter\n\n    function convertNotation(options, notation) {\n      var i = 0,\n          obj,\n          option = options,\n          // Split notation into array\n      levels = notation.split('.'); // Loop through\n\n      while (option = option[levels[i++]]) {\n        if (i < levels.length) {\n          obj = option;\n        }\n      }\n\n      return [obj || options, levels.pop()];\n    }\n\n    PROTOTYPE.get = function (notation) {\n      if (this.destroyed) {\n        return this;\n      }\n\n      var o = convertNotation(this.options, notation.toLowerCase()),\n          result = o[0][o[1]];\n      return result.precedance ? result.string() : result;\n    };\n\n    function setCallback(notation, args) {\n      var category, rule, match;\n\n      for (category in this.checks) {\n        for (rule in this.checks[category]) {\n          if (match = new RegExp(rule, 'i').exec(notation)) {\n            args.push(match);\n\n            if (category === 'builtin' || this.plugins[category]) {\n              this.checks[category][rule].apply(this.plugins[category] || this, args);\n            }\n          }\n        }\n      }\n    }\n\n    var rmove = /^position\\.(my|at|adjust|target|container|viewport)|style|content|show\\.ready/i,\n        rrender = /^prerender|show\\.ready/i;\n\n    PROTOTYPE.set = function (option, value) {\n      if (this.destroyed) {\n        return this;\n      }\n\n      var rendered = this.rendered,\n          reposition = FALSE,\n          options = this.options,\n          checks = this.checks,\n          name; // Convert singular option/value pair into object form\n\n      if ('string' === typeof option) {\n        name = option;\n        option = {};\n        option[name] = value;\n      } else {\n        option = $.extend({}, option);\n      } // Set all of the defined options to their new values\n\n\n      $.each(option, function (notation, value) {\n        if (rendered && rrender.test(notation)) {\n          delete option[notation];\n          return;\n        } // Set new obj value\n\n\n        var obj = convertNotation(options, notation.toLowerCase()),\n            previous;\n        previous = obj[0][obj[1]];\n        obj[0][obj[1]] = value && value.nodeType ? $(value) : value; // Also check if we need to reposition\n\n        reposition = rmove.test(notation) || reposition; // Set the new params for the callback\n\n        option[notation] = [obj[0], obj[1], value, previous];\n      }); // Re-sanitize options\n\n      sanitizeOptions(options);\n      /*\n       * Execute any valid callbacks for the set options\n       * Also set positioning flag so we don't get loads of redundant repositioning calls.\n       */\n\n      this.positioning = TRUE;\n      $.each(option, $.proxy(setCallback, this));\n      this.positioning = FALSE; // Update position if needed\n\n      if (this.rendered && this.tooltip[0].offsetWidth > 0 && reposition) {\n        this.reposition(options.position.target === 'mouse' ? NULL : this.cache.event);\n      }\n\n      return this;\n    };\n\n    ;\n\n    PROTOTYPE._update = function (content, element, reposition) {\n      var self = this,\n          cache = this.cache; // Make sure tooltip is rendered and content is defined. If not return\n\n      if (!this.rendered || !content) {\n        return FALSE;\n      } // Use function to parse content\n\n\n      if ($.isFunction(content)) {\n        content = content.call(this.elements.target, cache.event, this) || '';\n      } // Handle deferred content\n\n\n      if ($.isFunction(content.then)) {\n        cache.waiting = TRUE;\n        return content.then(function (c) {\n          cache.waiting = FALSE;\n          return self._update(c, element);\n        }, NULL, function (e) {\n          return self._update(e, element);\n        });\n      } // If content is null... return false\n\n\n      if (content === FALSE || !content && content !== '') {\n        return FALSE;\n      } // Append new content if its a DOM array and show it if hidden\n\n\n      if (content.jquery && content.length > 0) {\n        element.empty().append(content.css({\n          display: 'block',\n          visibility: 'visible'\n        }));\n      } // Content is a regular string, insert the new content\n      else {\n          element.html(content);\n        } // Wait for content to be loaded, and reposition\n\n\n      return this._waitForContent(element).then(function (images) {\n        if (self.rendered && self.tooltip[0].offsetWidth > 0) {\n          self.reposition(cache.event, !images.length);\n        }\n      });\n    };\n\n    PROTOTYPE._waitForContent = function (element) {\n      var cache = this.cache; // Set flag\n\n      cache.waiting = TRUE; // If imagesLoaded is included, ensure images have loaded and return promise\n\n      return ($.fn.imagesLoaded ? element.imagesLoaded() : $.Deferred().resolve([])).done(function () {\n        cache.waiting = FALSE;\n      }).promise();\n    };\n\n    PROTOTYPE._updateContent = function (content, reposition) {\n      this._update(content, this.elements.content, reposition);\n    };\n\n    PROTOTYPE._updateTitle = function (content, reposition) {\n      if (this._update(content, this.elements.title, reposition) === FALSE) {\n        this._removeTitle(FALSE);\n      }\n    };\n\n    PROTOTYPE._createTitle = function () {\n      var elements = this.elements,\n          id = this._id + '-title'; // Destroy previous title element, if present\n\n      if (elements.titlebar) {\n        this._removeTitle();\n      } // Create title bar and title elements\n\n\n      elements.titlebar = $('<div />', {\n        'class': NAMESPACE + '-titlebar ' + (this.options.style.widget ? createWidgetClass('header') : '')\n      }).append(elements.title = $('<div />', {\n        'id': id,\n        'class': NAMESPACE + '-title',\n        'aria-atomic': TRUE\n      })).insertBefore(elements.content) // Button-specific events\n      .delegate('.qtip-close', 'mousedown keydown mouseup keyup mouseout', function (event) {\n        $(this).toggleClass('ui-state-active ui-state-focus', event.type.substr(-4) === 'down');\n      }).delegate('.qtip-close', 'mouseover mouseout', function (event) {\n        $(this).toggleClass('ui-state-hover', event.type === 'mouseover');\n      }); // Create button if enabled\n\n      if (this.options.content.button) {\n        this._createButton();\n      }\n    };\n\n    PROTOTYPE._removeTitle = function (reposition) {\n      var elements = this.elements;\n\n      if (elements.title) {\n        elements.titlebar.remove();\n        elements.titlebar = elements.title = elements.button = NULL; // Reposition if enabled\n\n        if (reposition !== FALSE) {\n          this.reposition();\n        }\n      }\n    };\n\n    ;\n\n    PROTOTYPE._createPosClass = function (my) {\n      return NAMESPACE + '-pos-' + (my || this.options.position.my).abbrev();\n    };\n\n    PROTOTYPE.reposition = function (event, effect) {\n      if (!this.rendered || this.positioning || this.destroyed) {\n        return this;\n      } // Set positioning flag\n\n\n      this.positioning = TRUE;\n      var cache = this.cache,\n          tooltip = this.tooltip,\n          posOptions = this.options.position,\n          target = posOptions.target,\n          my = posOptions.my,\n          at = posOptions.at,\n          viewport = posOptions.viewport,\n          container = posOptions.container,\n          adjust = posOptions.adjust,\n          method = adjust.method.split(' '),\n          tooltipWidth = tooltip.outerWidth(FALSE),\n          tooltipHeight = tooltip.outerHeight(FALSE),\n          targetWidth = 0,\n          targetHeight = 0,\n          type = tooltip.css('position'),\n          position = {\n        left: 0,\n        top: 0\n      },\n          visible = tooltip[0].offsetWidth > 0,\n          isScroll = event && event.type === 'scroll',\n          win = $(window),\n          doc = container[0].ownerDocument,\n          mouse = this.mouse,\n          pluginCalculations,\n          offset,\n          adjusted,\n          newClass; // Check if absolute position was passed\n\n      if ($.isArray(target) && target.length === 2) {\n        // Force left top and set position\n        at = {\n          x: LEFT,\n          y: TOP\n        };\n        position = {\n          left: target[0],\n          top: target[1]\n        };\n      } // Check if mouse was the target\n      else if (target === 'mouse') {\n          // Force left top to allow flipping\n          at = {\n            x: LEFT,\n            y: TOP\n          }; // Use the mouse origin that caused the show event, if distance hiding is enabled\n\n          if ((!adjust.mouse || this.options.hide.distance) && cache.origin && cache.origin.pageX) {\n            event = cache.origin;\n          } // Use cached event for resize/scroll events\n          else if (!event || event && (event.type === 'resize' || event.type === 'scroll')) {\n              event = cache.event;\n            } // Otherwise, use the cached mouse coordinates if available\n            else if (mouse && mouse.pageX) {\n                event = mouse;\n              } // Calculate body and container offset and take them into account below\n\n\n          if (type !== 'static') {\n            position = container.offset();\n          }\n\n          if (doc.body.offsetWidth !== (window.innerWidth || doc.documentElement.clientWidth)) {\n            offset = $(document.body).offset();\n          } // Use event coordinates for position\n\n\n          position = {\n            left: event.pageX - position.left + (offset && offset.left || 0),\n            top: event.pageY - position.top + (offset && offset.top || 0)\n          }; // Scroll events are a pain, some browsers\n\n          if (adjust.mouse && isScroll && mouse) {\n            position.left -= (mouse.scrollX || 0) - win.scrollLeft();\n            position.top -= (mouse.scrollY || 0) - win.scrollTop();\n          }\n        } // Target wasn't mouse or absolute...\n        else {\n            // Check if event targetting is being used\n            if (target === 'event') {\n              if (event && event.target && event.type !== 'scroll' && event.type !== 'resize') {\n                cache.target = $(event.target);\n              } else if (!event.target) {\n                cache.target = this.elements.target;\n              }\n            } else if (target !== 'event') {\n              cache.target = $(target.jquery ? target : this.elements.target);\n            }\n\n            target = cache.target; // Parse the target into a jQuery object and make sure there's an element present\n\n            target = $(target).eq(0);\n\n            if (target.length === 0) {\n              return this;\n            } // Check if window or document is the target\n            else if (target[0] === document || target[0] === window) {\n                targetWidth = BROWSER.iOS ? window.innerWidth : target.width();\n                targetHeight = BROWSER.iOS ? window.innerHeight : target.height();\n\n                if (target[0] === window) {\n                  position = {\n                    top: (viewport || target).scrollTop(),\n                    left: (viewport || target).scrollLeft()\n                  };\n                }\n              } // Check if the target is an <AREA> element\n              else if (PLUGINS.imagemap && target.is('area')) {\n                  pluginCalculations = PLUGINS.imagemap(this, target, at, PLUGINS.viewport ? method : FALSE);\n                } // Check if the target is an SVG element\n                else if (PLUGINS.svg && target && target[0].ownerSVGElement) {\n                    pluginCalculations = PLUGINS.svg(this, target, at, PLUGINS.viewport ? method : FALSE);\n                  } // Otherwise use regular jQuery methods\n                  else {\n                      targetWidth = target.outerWidth(FALSE);\n                      targetHeight = target.outerHeight(FALSE);\n                      position = target.offset();\n                    } // Parse returned plugin values into proper variables\n\n\n            if (pluginCalculations) {\n              targetWidth = pluginCalculations.width;\n              targetHeight = pluginCalculations.height;\n              offset = pluginCalculations.offset;\n              position = pluginCalculations.position;\n            } // Adjust position to take into account offset parents\n\n\n            position = this.reposition.offset(target, position, container); // Adjust for position.fixed tooltips (and also iOS scroll bug in v3.2-4.0 & v4.3-4.3.2)\n\n            if (BROWSER.iOS > 3.1 && BROWSER.iOS < 4.1 || BROWSER.iOS >= 4.3 && BROWSER.iOS < 4.33 || !BROWSER.iOS && type === 'fixed') {\n              position.left -= win.scrollLeft();\n              position.top -= win.scrollTop();\n            } // Adjust position relative to target\n\n\n            if (!pluginCalculations || pluginCalculations && pluginCalculations.adjustable !== FALSE) {\n              position.left += at.x === RIGHT ? targetWidth : at.x === CENTER ? targetWidth / 2 : 0;\n              position.top += at.y === BOTTOM ? targetHeight : at.y === CENTER ? targetHeight / 2 : 0;\n            }\n          } // Adjust position relative to tooltip\n\n\n      position.left += adjust.x + (my.x === RIGHT ? -tooltipWidth : my.x === CENTER ? -tooltipWidth / 2 : 0);\n      position.top += adjust.y + (my.y === BOTTOM ? -tooltipHeight : my.y === CENTER ? -tooltipHeight / 2 : 0); // Use viewport adjustment plugin if enabled\n\n      if (PLUGINS.viewport) {\n        adjusted = position.adjusted = PLUGINS.viewport(this, position, posOptions, targetWidth, targetHeight, tooltipWidth, tooltipHeight); // Apply offsets supplied by positioning plugin (if used)\n\n        if (offset && adjusted.left) {\n          position.left += offset.left;\n        }\n\n        if (offset && adjusted.top) {\n          position.top += offset.top;\n        } // Apply any new 'my' position\n\n\n        if (adjusted.my) {\n          this.position.my = adjusted.my;\n        }\n      } // Viewport adjustment is disabled, set values to zero\n      else {\n          position.adjusted = {\n            left: 0,\n            top: 0\n          };\n        } // Set tooltip position class if it's changed\n\n\n      if (cache.posClass !== (newClass = this._createPosClass(this.position.my))) {\n        tooltip.removeClass(cache.posClass).addClass(cache.posClass = newClass);\n      } // tooltipmove event\n\n\n      if (!this._trigger('move', [position, viewport.elem || viewport], event)) {\n        return this;\n      }\n\n      delete position.adjusted; // If effect is disabled, target it mouse, no animation is defined or positioning gives NaN out, set CSS directly\n\n      if (effect === FALSE || !visible || isNaN(position.left) || isNaN(position.top) || target === 'mouse' || !$.isFunction(posOptions.effect)) {\n        tooltip.css(position);\n      } // Use custom function if provided\n      else if ($.isFunction(posOptions.effect)) {\n          posOptions.effect.call(tooltip, this, $.extend({}, position));\n          tooltip.queue(function (next) {\n            // Reset attributes to avoid cross-browser rendering bugs\n            $(this).css({\n              opacity: '',\n              height: ''\n            });\n\n            if (BROWSER.ie) {\n              this.style.removeAttribute('filter');\n            }\n\n            next();\n          });\n        } // Set positioning flag\n\n\n      this.positioning = FALSE;\n      return this;\n    }; // Custom (more correct for qTip!) offset calculator\n\n\n    PROTOTYPE.reposition.offset = function (elem, pos, container) {\n      if (!container[0]) {\n        return pos;\n      }\n\n      var ownerDocument = $(elem[0].ownerDocument),\n          quirks = !!BROWSER.ie && document.compatMode !== 'CSS1Compat',\n          parent = container[0],\n          scrolled,\n          position,\n          parentOffset,\n          overflow;\n\n      function scroll(e, i) {\n        pos.left += i * e.scrollLeft();\n        pos.top += i * e.scrollTop();\n      } // Compensate for non-static containers offset\n\n\n      do {\n        if ((position = $.css(parent, 'position')) !== 'static') {\n          if (position === 'fixed') {\n            parentOffset = parent.getBoundingClientRect();\n            scroll(ownerDocument, -1);\n          } else {\n            parentOffset = $(parent).position();\n            parentOffset.left += parseFloat($.css(parent, 'borderLeftWidth')) || 0;\n            parentOffset.top += parseFloat($.css(parent, 'borderTopWidth')) || 0;\n          }\n\n          pos.left -= parentOffset.left + (parseFloat($.css(parent, 'marginLeft')) || 0);\n          pos.top -= parentOffset.top + (parseFloat($.css(parent, 'marginTop')) || 0); // If this is the first parent element with an overflow of \"scroll\" or \"auto\", store it\n\n          if (!scrolled && (overflow = $.css(parent, 'overflow')) !== 'hidden' && overflow !== 'visible') {\n            scrolled = $(parent);\n          }\n        }\n      } while (parent = parent.offsetParent); // Compensate for containers scroll if it also has an offsetParent (or in IE quirks mode)\n\n\n      if (scrolled && (scrolled[0] !== ownerDocument[0] || quirks)) {\n        scroll(scrolled, 1);\n      }\n\n      return pos;\n    }; // Corner class\n\n\n    var C = (CORNER = PROTOTYPE.reposition.Corner = function (corner, forceY) {\n      corner = ('' + corner).replace(/([A-Z])/, ' $1').replace(/middle/gi, CENTER).toLowerCase();\n      this.x = (corner.match(/left|right/i) || corner.match(/center/) || ['inherit'])[0].toLowerCase();\n      this.y = (corner.match(/top|bottom|center/i) || ['inherit'])[0].toLowerCase();\n      this.forceY = !!forceY;\n      var f = corner.charAt(0);\n      this.precedance = f === 't' || f === 'b' ? Y : X;\n    }).prototype;\n\n    C.invert = function (z, center) {\n      this[z] = this[z] === LEFT ? RIGHT : this[z] === RIGHT ? LEFT : center || this[z];\n    };\n\n    C.string = function (join) {\n      var x = this.x,\n          y = this.y;\n      var result = x !== y ? x === 'center' || y !== 'center' && (this.precedance === Y || this.forceY) ? [y, x] : [x, y] : [x];\n      return join !== false ? result.join(' ') : result;\n    };\n\n    C.abbrev = function () {\n      var result = this.string(false);\n      return result[0].charAt(0) + (result[1] && result[1].charAt(0) || '');\n    };\n\n    C.clone = function () {\n      return new CORNER(this.string(), this.forceY);\n    };\n\n    ;\n\n    PROTOTYPE.toggle = function (state, event) {\n      var cache = this.cache,\n          options = this.options,\n          tooltip = this.tooltip; // Try to prevent flickering when tooltip overlaps show element\n\n      if (event) {\n        if (/over|enter/.test(event.type) && cache.event && /out|leave/.test(cache.event.type) && options.show.target.add(event.target).length === options.show.target.length && tooltip.has(event.relatedTarget).length) {\n          return this;\n        } // Cache event\n\n\n        cache.event = $.event.fix(event);\n      } // If we're currently waiting and we've just hidden... stop it\n\n\n      this.waiting && !state && (this.hiddenDuringWait = TRUE); // Render the tooltip if showing and it isn't already\n\n      if (!this.rendered) {\n        return state ? this.render(1) : this;\n      } else if (this.destroyed || this.disabled) {\n        return this;\n      }\n\n      var type = state ? 'show' : 'hide',\n          opts = this.options[type],\n          otherOpts = this.options[!state ? 'show' : 'hide'],\n          posOptions = this.options.position,\n          contentOptions = this.options.content,\n          width = this.tooltip.css('width'),\n          visible = this.tooltip.is(':visible'),\n          animate = state || opts.target.length === 1,\n          sameTarget = !event || opts.target.length < 2 || cache.target[0] === event.target,\n          identicalState,\n          allow,\n          showEvent,\n          delay,\n          after; // Detect state if valid one isn't provided\n\n      if (_typeof(state).search('boolean|number')) {\n        state = !visible;\n      } // Check if the tooltip is in an identical state to the new would-be state\n\n\n      identicalState = !tooltip.is(':animated') && visible === state && sameTarget; // Fire tooltip(show/hide) event and check if destroyed\n\n      allow = !identicalState ? !!this._trigger(type, [90]) : NULL; // Check to make sure the tooltip wasn't destroyed in the callback\n\n      if (this.destroyed) {\n        return this;\n      } // If the user didn't stop the method prematurely and we're showing the tooltip, focus it\n\n\n      if (allow !== FALSE && state) {\n        this.focus(event);\n      } // If the state hasn't changed or the user stopped it, return early\n\n\n      if (!allow || identicalState) {\n        return this;\n      } // Set ARIA hidden attribute\n\n\n      $.attr(tooltip[0], 'aria-hidden', !!!state); // Execute state specific properties\n\n      if (state) {\n        // Store show origin coordinates\n        this.mouse && (cache.origin = $.event.fix(this.mouse)); // Update tooltip content & title if it's a dynamic function\n\n        if ($.isFunction(contentOptions.text)) {\n          this._updateContent(contentOptions.text, FALSE);\n        }\n\n        if ($.isFunction(contentOptions.title)) {\n          this._updateTitle(contentOptions.title, FALSE);\n        } // Cache mousemove events for positioning purposes (if not already tracking)\n\n\n        if (!trackingBound && posOptions.target === 'mouse' && posOptions.adjust.mouse) {\n          $(document).bind('mousemove.' + NAMESPACE, this._storeMouse);\n          trackingBound = TRUE;\n        } // Update the tooltip position (set width first to prevent viewport/max-width issues)\n\n\n        if (!width) {\n          tooltip.css('width', tooltip.outerWidth(FALSE));\n        }\n\n        this.reposition(event, arguments[2]);\n\n        if (!width) {\n          tooltip.css('width', '');\n        } // Hide other tooltips if tooltip is solo\n\n\n        if (!!opts.solo) {\n          (typeof opts.solo === 'string' ? $(opts.solo) : $(SELECTOR, opts.solo)).not(tooltip).not(opts.target).qtip('hide', $.Event('tooltipsolo'));\n        }\n      } else {\n        // Clear show timer if we're hiding\n        clearTimeout(this.timers.show); // Remove cached origin on hide\n\n        delete cache.origin; // Remove mouse tracking event if not needed (all tracking qTips are hidden)\n\n        if (trackingBound && !$(SELECTOR + '[tracking=\"true\"]:visible', opts.solo).not(tooltip).length) {\n          $(document).unbind('mousemove.' + NAMESPACE);\n          trackingBound = FALSE;\n        } // Blur the tooltip\n\n\n        this.blur(event);\n      } // Define post-animation, state specific properties\n\n\n      after = $.proxy(function () {\n        if (state) {\n          // Prevent antialias from disappearing in IE by removing filter\n          if (BROWSER.ie) {\n            tooltip[0].style.removeAttribute('filter');\n          } // Remove overflow setting to prevent tip bugs\n\n\n          tooltip.css('overflow', ''); // Autofocus elements if enabled\n\n          if ('string' === typeof opts.autofocus) {\n            $(this.options.show.autofocus, tooltip).focus();\n          } // If set, hide tooltip when inactive for delay period\n\n\n          this.options.show.target.trigger('qtip-' + this.id + '-inactive');\n        } else {\n          // Reset CSS states\n          tooltip.css({\n            display: '',\n            visibility: '',\n            opacity: '',\n            left: '',\n            top: ''\n          });\n        } // tooltipvisible/tooltiphidden events\n\n\n        this._trigger(state ? 'visible' : 'hidden');\n      }, this); // If no effect type is supplied, use a simple toggle\n\n      if (opts.effect === FALSE || animate === FALSE) {\n        tooltip[type]();\n        after();\n      } // Use custom function if provided\n      else if ($.isFunction(opts.effect)) {\n          tooltip.stop(1, 1);\n          opts.effect.call(tooltip, this);\n          tooltip.queue('fx', function (n) {\n            after();\n            n();\n          });\n        } // Use basic fade function by default\n        else {\n            tooltip.fadeTo(90, state ? 1 : 0, after);\n          } // If inactive hide method is set, active it\n\n\n      if (state) {\n        opts.target.trigger('qtip-' + this.id + '-inactive');\n      }\n\n      return this;\n    };\n\n    PROTOTYPE.show = function (event) {\n      return this.toggle(TRUE, event);\n    };\n\n    PROTOTYPE.hide = function (event) {\n      return this.toggle(FALSE, event);\n    };\n\n    ;\n\n    PROTOTYPE.focus = function (event) {\n      if (!this.rendered || this.destroyed) {\n        return this;\n      }\n\n      var qtips = $(SELECTOR),\n          tooltip = this.tooltip,\n          curIndex = parseInt(tooltip[0].style.zIndex, 10),\n          newIndex = QTIP.zindex + qtips.length,\n          focusedElem; // Only update the z-index if it has changed and tooltip is not already focused\n\n      if (!tooltip.hasClass(CLASS_FOCUS)) {\n        // tooltipfocus event\n        if (this._trigger('focus', [newIndex], event)) {\n          // Only update z-index's if they've changed\n          if (curIndex !== newIndex) {\n            // Reduce our z-index's and keep them properly ordered\n            qtips.each(function () {\n              if (this.style.zIndex > curIndex) {\n                this.style.zIndex = this.style.zIndex - 1;\n              }\n            }); // Fire blur event for focused tooltip\n\n            qtips.filter('.' + CLASS_FOCUS).qtip('blur', event);\n          } // Set the new z-index\n\n\n          tooltip.addClass(CLASS_FOCUS)[0].style.zIndex = newIndex;\n        }\n      }\n\n      return this;\n    };\n\n    PROTOTYPE.blur = function (event) {\n      if (!this.rendered || this.destroyed) {\n        return this;\n      } // Set focused status to FALSE\n\n\n      this.tooltip.removeClass(CLASS_FOCUS); // tooltipblur event\n\n      this._trigger('blur', [this.tooltip.css('zIndex')], event);\n\n      return this;\n    };\n\n    ;\n\n    PROTOTYPE.disable = function (state) {\n      if (this.destroyed) {\n        return this;\n      } // If 'toggle' is passed, toggle the current state\n\n\n      if (state === 'toggle') {\n        state = !(this.rendered ? this.tooltip.hasClass(CLASS_DISABLED) : this.disabled);\n      } // Disable if no state passed\n      else if ('boolean' !== typeof state) {\n          state = TRUE;\n        }\n\n      if (this.rendered) {\n        this.tooltip.toggleClass(CLASS_DISABLED, state).attr('aria-disabled', state);\n      }\n\n      this.disabled = !!state;\n      return this;\n    };\n\n    PROTOTYPE.enable = function () {\n      return this.disable(FALSE);\n    };\n\n    ;\n\n    PROTOTYPE._createButton = function () {\n      var self = this,\n          elements = this.elements,\n          tooltip = elements.tooltip,\n          button = this.options.content.button,\n          isString = typeof button === 'string',\n          close = isString ? button : 'Close tooltip';\n\n      if (elements.button) {\n        elements.button.remove();\n      } // Use custom button if one was supplied by user, else use default\n\n\n      if (button.jquery) {\n        elements.button = button;\n      } else {\n        elements.button = $('<a />', {\n          'class': 'qtip-close ' + (this.options.style.widget ? '' : NAMESPACE + '-icon'),\n          'title': close,\n          'aria-label': close\n        }).prepend($('<span />', {\n          'class': 'ui-icon ui-icon-close',\n          'html': '&times;'\n        }));\n      } // Create button and setup attributes\n\n\n      elements.button.appendTo(elements.titlebar || tooltip).attr('role', 'button').click(function (event) {\n        if (!tooltip.hasClass(CLASS_DISABLED)) {\n          self.hide(event);\n        }\n\n        return FALSE;\n      });\n    };\n\n    PROTOTYPE._updateButton = function (button) {\n      // Make sure tooltip is rendered and if not, return\n      if (!this.rendered) {\n        return FALSE;\n      }\n\n      var elem = this.elements.button;\n\n      if (button) {\n        this._createButton();\n      } else {\n        elem.remove();\n      }\n    };\n\n    ; // Widget class creator\n\n    function createWidgetClass(cls) {\n      return WIDGET.concat('').join(cls ? '-' + cls + ' ' : ' ');\n    } // Widget class setter method\n\n\n    PROTOTYPE._setWidget = function () {\n      var on = this.options.style.widget,\n          elements = this.elements,\n          tooltip = elements.tooltip,\n          disabled = tooltip.hasClass(CLASS_DISABLED);\n      tooltip.removeClass(CLASS_DISABLED);\n      CLASS_DISABLED = on ? 'ui-state-disabled' : 'qtip-disabled';\n      tooltip.toggleClass(CLASS_DISABLED, disabled);\n      tooltip.toggleClass('ui-helper-reset ' + createWidgetClass(), on).toggleClass(CLASS_DEFAULT, this.options.style.def && !on);\n\n      if (elements.content) {\n        elements.content.toggleClass(createWidgetClass('content'), on);\n      }\n\n      if (elements.titlebar) {\n        elements.titlebar.toggleClass(createWidgetClass('header'), on);\n      }\n\n      if (elements.button) {\n        elements.button.toggleClass(NAMESPACE + '-icon', !on);\n      }\n    };\n\n    ;\n\n    function delay(callback, duration) {\n      // If tooltip has displayed, start hide timer\n      if (duration > 0) {\n        return setTimeout($.proxy(callback, this), duration);\n      } else {\n        callback.call(this);\n      }\n    }\n\n    function showMethod(event) {\n      if (this.tooltip.hasClass(CLASS_DISABLED)) {\n        return;\n      } // Clear hide timers\n\n\n      clearTimeout(this.timers.show);\n      clearTimeout(this.timers.hide); // Start show timer\n\n      this.timers.show = delay.call(this, function () {\n        this.toggle(TRUE, event);\n      }, this.options.show.delay);\n    }\n\n    function hideMethod(event) {\n      if (this.tooltip.hasClass(CLASS_DISABLED) || this.destroyed) {\n        return;\n      } // Check if new target was actually the tooltip element\n\n\n      var relatedTarget = $(event.relatedTarget),\n          ontoTooltip = relatedTarget.closest(SELECTOR)[0] === this.tooltip[0],\n          ontoTarget = relatedTarget[0] === this.options.show.target[0]; // Clear timers and stop animation queue\n\n      clearTimeout(this.timers.show);\n      clearTimeout(this.timers.hide); // Prevent hiding if tooltip is fixed and event target is the tooltip.\n      // Or if mouse positioning is enabled and cursor momentarily overlaps\n\n      if (this !== relatedTarget[0] && this.options.position.target === 'mouse' && ontoTooltip || this.options.hide.fixed && /mouse(out|leave|move)/.test(event.type) && (ontoTooltip || ontoTarget)) {\n        try {\n          event.preventDefault();\n          event.stopImmediatePropagation();\n        } catch (e) {}\n\n        return;\n      } // If tooltip has displayed, start hide timer\n\n\n      this.timers.hide = delay.call(this, function () {\n        this.toggle(FALSE, event);\n      }, this.options.hide.delay, this);\n    }\n\n    function inactiveMethod(event) {\n      if (this.tooltip.hasClass(CLASS_DISABLED) || !this.options.hide.inactive) {\n        return;\n      } // Clear timer\n\n\n      clearTimeout(this.timers.inactive);\n      this.timers.inactive = delay.call(this, function () {\n        this.hide(event);\n      }, this.options.hide.inactive);\n    }\n\n    function repositionMethod(event) {\n      if (this.rendered && this.tooltip[0].offsetWidth > 0) {\n        this.reposition(event);\n      }\n    } // Store mouse coordinates\n\n\n    PROTOTYPE._storeMouse = function (event) {\n      (this.mouse = $.event.fix(event)).type = 'mousemove';\n      return this;\n    }; // Bind events\n\n\n    PROTOTYPE._bind = function (targets, events, method, suffix, context) {\n      if (!targets || !method || !events.length) {\n        return;\n      }\n\n      var ns = '.' + this._id + (suffix ? '-' + suffix : '');\n      $(targets).bind((events.split ? events : events.join(ns + ' ')) + ns, $.proxy(method, context || this));\n      return this;\n    };\n\n    PROTOTYPE._unbind = function (targets, suffix) {\n      targets && $(targets).unbind('.' + this._id + (suffix ? '-' + suffix : ''));\n      return this;\n    }; // Global delegation helper\n\n\n    function delegate(selector, events, method) {\n      $(document.body).delegate(selector, (events.split ? events : events.join('.' + NAMESPACE + ' ')) + '.' + NAMESPACE, function () {\n        var api = QTIP.api[$.attr(this, ATTR_ID)];\n        api && !api.disabled && method.apply(api, arguments);\n      });\n    } // Event trigger\n\n\n    PROTOTYPE._trigger = function (type, args, event) {\n      var callback = $.Event('tooltip' + type);\n      callback.originalEvent = event && $.extend({}, event) || this.cache.event || NULL;\n      this.triggering = type;\n      this.tooltip.trigger(callback, [this].concat(args || []));\n      this.triggering = FALSE;\n      return !callback.isDefaultPrevented();\n    };\n\n    PROTOTYPE._bindEvents = function (showEvents, hideEvents, showTargets, hideTargets, showMethod, hideMethod) {\n      // Get tasrgets that lye within both\n      var similarTargets = showTargets.filter(hideTargets).add(hideTargets.filter(showTargets)),\n          toggleEvents = []; // If hide and show targets are the same...\n\n      if (similarTargets.length) {\n        // Filter identical show/hide events\n        $.each(hideEvents, function (i, type) {\n          var showIndex = $.inArray(type, showEvents); // Both events are identical, remove from both hide and show events\n          // and append to toggleEvents\n\n          showIndex > -1 && toggleEvents.push(showEvents.splice(showIndex, 1)[0]);\n        }); // Toggle events are special case of identical show/hide events, which happen in sequence\n\n        if (toggleEvents.length) {\n          // Bind toggle events to the similar targets\n          this._bind(similarTargets, toggleEvents, function (event) {\n            var state = this.rendered ? this.tooltip[0].offsetWidth > 0 : false;\n            (state ? hideMethod : showMethod).call(this, event);\n          }); // Remove the similar targets from the regular show/hide bindings\n\n\n          showTargets = showTargets.not(similarTargets);\n          hideTargets = hideTargets.not(similarTargets);\n        }\n      } // Apply show/hide/toggle events\n\n\n      this._bind(showTargets, showEvents, showMethod);\n\n      this._bind(hideTargets, hideEvents, hideMethod);\n    };\n\n    PROTOTYPE._assignInitialEvents = function (event) {\n      var options = this.options,\n          showTarget = options.show.target,\n          hideTarget = options.hide.target,\n          showEvents = options.show.event ? $.trim('' + options.show.event).split(' ') : [],\n          hideEvents = options.hide.event ? $.trim('' + options.hide.event).split(' ') : []; // Catch remove/removeqtip events on target element to destroy redundant tooltips\n\n      this._bind(this.elements.target, ['remove', 'removeqtip'], function (event) {\n        this.destroy(true);\n      }, 'destroy');\n      /*\n       * Make sure hoverIntent functions properly by using mouseleave as a hide event if\n       * mouseenter/mouseout is used for show.event, even if it isn't in the users options.\n       */\n\n\n      if (/mouse(over|enter)/i.test(options.show.event) && !/mouse(out|leave)/i.test(options.hide.event)) {\n        hideEvents.push('mouseleave');\n      }\n      /*\n       * Also make sure initial mouse targetting works correctly by caching mousemove coords\n       * on show targets before the tooltip has rendered. Also set onTarget when triggered to\n       * keep mouse tracking working.\n       */\n\n\n      this._bind(showTarget, 'mousemove', function (event) {\n        this._storeMouse(event);\n\n        this.cache.onTarget = TRUE;\n      }); // Define hoverIntent function\n\n\n      function hoverIntent(event) {\n        // Only continue if tooltip isn't disabled\n        if (this.disabled || this.destroyed) {\n          return FALSE;\n        } // Cache the event data\n\n\n        this.cache.event = event && $.event.fix(event);\n        this.cache.target = event && $(event.target); // Start the event sequence\n\n        clearTimeout(this.timers.show);\n        this.timers.show = delay.call(this, function () {\n          this.render(_typeof(event) === 'object' || options.show.ready);\n        }, options.prerender ? 0 : options.show.delay);\n      } // Filter and bind events\n\n\n      this._bindEvents(showEvents, hideEvents, showTarget, hideTarget, hoverIntent, function () {\n        if (!this.timers) {\n          return FALSE;\n        }\n\n        clearTimeout(this.timers.show);\n      }); // Prerendering is enabled, create tooltip now\n\n\n      if (options.show.ready || options.prerender) {\n        hoverIntent.call(this, event);\n      }\n    }; // Event assignment method\n\n\n    PROTOTYPE._assignEvents = function () {\n      var self = this,\n          options = this.options,\n          posOptions = options.position,\n          tooltip = this.tooltip,\n          showTarget = options.show.target,\n          hideTarget = options.hide.target,\n          containerTarget = posOptions.container,\n          viewportTarget = posOptions.viewport,\n          documentTarget = $(document),\n          bodyTarget = $(document.body),\n          windowTarget = $(window),\n          showEvents = options.show.event ? $.trim('' + options.show.event).split(' ') : [],\n          hideEvents = options.hide.event ? $.trim('' + options.hide.event).split(' ') : []; // Assign passed event callbacks\n\n      $.each(options.events, function (name, callback) {\n        self._bind(tooltip, name === 'toggle' ? ['tooltipshow', 'tooltiphide'] : ['tooltip' + name], callback, null, tooltip);\n      }); // Hide tooltips when leaving current window/frame (but not select/option elements)\n\n      if (/mouse(out|leave)/i.test(options.hide.event) && options.hide.leave === 'window') {\n        this._bind(documentTarget, ['mouseout', 'blur'], function (event) {\n          if (!/select|option/.test(event.target.nodeName) && !event.relatedTarget) {\n            this.hide(event);\n          }\n        });\n      } // Enable hide.fixed by adding appropriate class\n\n\n      if (options.hide.fixed) {\n        hideTarget = hideTarget.add(tooltip.addClass(CLASS_FIXED));\n      }\n      /*\n       * Make sure hoverIntent functions properly by using mouseleave to clear show timer if\n       * mouseenter/mouseout is used for show.event, even if it isn't in the users options.\n       */\n      else if (/mouse(over|enter)/i.test(options.show.event)) {\n          this._bind(hideTarget, 'mouseleave', function () {\n            clearTimeout(this.timers.show);\n          });\n        } // Hide tooltip on document mousedown if unfocus events are enabled\n\n\n      if (('' + options.hide.event).indexOf('unfocus') > -1) {\n        this._bind(containerTarget.closest('html'), ['mousedown', 'touchstart'], function (event) {\n          var elem = $(event.target),\n              enabled = this.rendered && !this.tooltip.hasClass(CLASS_DISABLED) && this.tooltip[0].offsetWidth > 0,\n              isAncestor = elem.parents(SELECTOR).filter(this.tooltip[0]).length > 0;\n\n          if (elem[0] !== this.target[0] && elem[0] !== this.tooltip[0] && !isAncestor && !this.target.has(elem[0]).length && enabled) {\n            this.hide(event);\n          }\n        });\n      } // Check if the tooltip hides when inactive\n\n\n      if ('number' === typeof options.hide.inactive) {\n        // Bind inactive method to show target(s) as a custom event\n        this._bind(showTarget, 'qtip-' + this.id + '-inactive', inactiveMethod, 'inactive'); // Define events which reset the 'inactive' event handler\n\n\n        this._bind(hideTarget.add(tooltip), QTIP.inactiveEvents, inactiveMethod);\n      } // Filter and bind events\n\n\n      this._bindEvents(showEvents, hideEvents, showTarget, hideTarget, showMethod, hideMethod); // Mouse movement bindings\n\n\n      this._bind(showTarget.add(tooltip), 'mousemove', function (event) {\n        // Check if the tooltip hides when mouse is moved a certain distance\n        if ('number' === typeof options.hide.distance) {\n          var origin = this.cache.origin || {},\n              limit = this.options.hide.distance,\n              abs = Math.abs; // Check if the movement has gone beyond the limit, and hide it if so\n\n          if (abs(event.pageX - origin.pageX) >= limit || abs(event.pageY - origin.pageY) >= limit) {\n            this.hide(event);\n          }\n        } // Cache mousemove coords on show targets\n\n\n        this._storeMouse(event);\n      }); // Mouse positioning events\n\n\n      if (posOptions.target === 'mouse') {\n        // If mouse adjustment is on...\n        if (posOptions.adjust.mouse) {\n          // Apply a mouseleave event so we don't get problems with overlapping\n          if (options.hide.event) {\n            // Track if we're on the target or not\n            this._bind(showTarget, ['mouseenter', 'mouseleave'], function (event) {\n              if (!this.cache) {\n                return FALSE;\n              }\n\n              this.cache.onTarget = event.type === 'mouseenter';\n            });\n          } // Update tooltip position on mousemove\n\n\n          this._bind(documentTarget, 'mousemove', function (event) {\n            // Update the tooltip position only if the tooltip is visible and adjustment is enabled\n            if (this.rendered && this.cache.onTarget && !this.tooltip.hasClass(CLASS_DISABLED) && this.tooltip[0].offsetWidth > 0) {\n              this.reposition(event);\n            }\n          });\n        }\n      } // Adjust positions of the tooltip on window resize if enabled\n\n\n      if (posOptions.adjust.resize || viewportTarget.length) {\n        this._bind($.event.special.resize ? viewportTarget : windowTarget, 'resize', repositionMethod);\n      } // Adjust tooltip position on scroll of the window or viewport element if present\n\n\n      if (posOptions.adjust.scroll) {\n        this._bind(windowTarget.add(posOptions.container), 'scroll', repositionMethod);\n      }\n    }; // Un-assignment method\n\n\n    PROTOTYPE._unassignEvents = function () {\n      var options = this.options,\n          showTargets = options.show.target,\n          hideTargets = options.hide.target,\n          targets = $.grep([this.elements.target[0], this.rendered && this.tooltip[0], options.position.container[0], options.position.viewport[0], options.position.container.closest('html')[0], // unfocus\n      window, document], function (i) {\n        return _typeof(i) === 'object';\n      }); // Add show and hide targets if they're valid\n\n      if (showTargets && showTargets.toArray) {\n        targets = targets.concat(showTargets.toArray());\n      }\n\n      if (hideTargets && hideTargets.toArray) {\n        targets = targets.concat(hideTargets.toArray());\n      } // Unbind the events\n\n\n      this._unbind(targets)._unbind(targets, 'destroy')._unbind(targets, 'inactive');\n    }; // Apply common event handlers using delegate (avoids excessive .bind calls!)\n\n\n    $(function () {\n      delegate(SELECTOR, ['mouseenter', 'mouseleave'], function (event) {\n        var state = event.type === 'mouseenter',\n            tooltip = $(event.currentTarget),\n            target = $(event.relatedTarget || event.target),\n            options = this.options; // On mouseenter...\n\n        if (state) {\n          // Focus the tooltip on mouseenter (z-index stacking)\n          this.focus(event); // Clear hide timer on tooltip hover to prevent it from closing\n\n          tooltip.hasClass(CLASS_FIXED) && !tooltip.hasClass(CLASS_DISABLED) && clearTimeout(this.timers.hide);\n        } // On mouseleave...\n        else {\n            // When mouse tracking is enabled, hide when we leave the tooltip and not onto the show target (if a hide event is set)\n            if (options.position.target === 'mouse' && options.position.adjust.mouse && options.hide.event && options.show.target && !target.closest(options.show.target[0]).length) {\n              this.hide(event);\n            }\n          } // Add hover class\n\n\n        tooltip.toggleClass(CLASS_HOVER, state);\n      }); // Define events which reset the 'inactive' event handler\n\n      delegate('[' + ATTR_ID + ']', INACTIVE_EVENTS, inactiveMethod);\n    });\n    ; // Initialization method\n\n    function init(elem, id, opts) {\n      var obj,\n          posOptions,\n          attr,\n          config,\n          title,\n          // Setup element references\n      docBody = $(document.body),\n          // Use document body instead of document element if needed\n      newTarget = elem[0] === document ? docBody : elem,\n          // Grab metadata from element if plugin is present\n      metadata = elem.metadata ? elem.metadata(opts.metadata) : NULL,\n          // If metadata type if HTML5, grab 'name' from the object instead, or use the regular data object otherwise\n      metadata5 = opts.metadata.type === 'html5' && metadata ? metadata[opts.metadata.name] : NULL,\n          // Grab data from metadata.name (or data-qtipopts as fallback) using .data() method,\n      html5 = elem.data(opts.metadata.name || 'qtipopts'); // If we don't get an object returned attempt to parse it manualyl without parseJSON\n\n      try {\n        html5 = typeof html5 === 'string' ? $.parseJSON(html5) : html5;\n      } catch (e) {} // Merge in and sanitize metadata\n\n\n      config = $.extend(TRUE, {}, QTIP.defaults, opts, _typeof(html5) === 'object' ? sanitizeOptions(html5) : NULL, sanitizeOptions(metadata5 || metadata)); // Re-grab our positioning options now we've merged our metadata and set id to passed value\n\n      posOptions = config.position;\n      config.id = id; // Setup missing content if none is detected\n\n      if ('boolean' === typeof config.content.text) {\n        attr = elem.attr(config.content.attr); // Grab from supplied attribute if available\n\n        if (config.content.attr !== FALSE && attr) {\n          config.content.text = attr;\n        } // No valid content was found, abort render\n        else {\n            return FALSE;\n          }\n      } // Setup target options\n\n\n      if (!posOptions.container.length) {\n        posOptions.container = docBody;\n      }\n\n      if (posOptions.target === FALSE) {\n        posOptions.target = newTarget;\n      }\n\n      if (config.show.target === FALSE) {\n        config.show.target = newTarget;\n      }\n\n      if (config.show.solo === TRUE) {\n        config.show.solo = posOptions.container.closest('body');\n      }\n\n      if (config.hide.target === FALSE) {\n        config.hide.target = newTarget;\n      }\n\n      if (config.position.viewport === TRUE) {\n        config.position.viewport = posOptions.container;\n      } // Ensure we only use a single container\n\n\n      posOptions.container = posOptions.container.eq(0); // Convert position corner values into x and y strings\n\n      posOptions.at = new CORNER(posOptions.at, TRUE);\n      posOptions.my = new CORNER(posOptions.my); // Destroy previous tooltip if overwrite is enabled, or skip element if not\n\n      if (elem.data(NAMESPACE)) {\n        if (config.overwrite) {\n          elem.qtip('destroy', true);\n        } else if (config.overwrite === FALSE) {\n          return FALSE;\n        }\n      } // Add has-qtip attribute\n\n\n      elem.attr(ATTR_HAS, id); // Remove title attribute and store it if present\n\n      if (config.suppress && (title = elem.attr('title'))) {\n        // Final attr call fixes event delegatiom and IE default tooltip showing problem\n        elem.removeAttr('title').attr(oldtitle, title).attr('title', '');\n      } // Initialize the tooltip and add API reference\n\n\n      obj = new QTip(elem, config, id, !!attr);\n      elem.data(NAMESPACE, obj);\n      return obj;\n    } // jQuery $.fn extension method\n\n\n    QTIP = $.fn.qtip = function (options, notation, newValue) {\n      var command = ('' + options).toLowerCase(),\n          // Parse command\n      returned = NULL,\n          args = $.makeArray(arguments).slice(1),\n          event = args[args.length - 1],\n          opts = this[0] ? $.data(this[0], NAMESPACE) : NULL; // Check for API request\n\n      if (!arguments.length && opts || command === 'api') {\n        return opts;\n      } // Execute API command if present\n      else if ('string' === typeof options) {\n          this.each(function () {\n            var api = $.data(this, NAMESPACE);\n\n            if (!api) {\n              return TRUE;\n            } // Cache the event if possible\n\n\n            if (event && event.timeStamp) {\n              api.cache.event = event;\n            } // Check for specific API commands\n\n\n            if (notation && (command === 'option' || command === 'options')) {\n              if (newValue !== undefined || $.isPlainObject(notation)) {\n                api.set(notation, newValue);\n              } else {\n                returned = api.get(notation);\n                return FALSE;\n              }\n            } // Execute API command\n            else if (api[command]) {\n                api[command].apply(api, args);\n              }\n          });\n          return returned !== NULL ? returned : this;\n        } // No API commands. validate provided options and setup qTips\n        else if ('object' === _typeof(options) || !arguments.length) {\n            // Sanitize options first\n            opts = sanitizeOptions($.extend(TRUE, {}, options));\n            return this.each(function (i) {\n              var api, id; // Find next available ID, or use custom ID if provided\n\n              id = $.isArray(opts.id) ? opts.id[i] : opts.id;\n              id = !id || id === FALSE || id.length < 1 || QTIP.api[id] ? QTIP.nextid++ : id; // Initialize the qTip and re-grab newly sanitized options\n\n              api = init($(this), id, opts);\n\n              if (api === FALSE) {\n                return TRUE;\n              } else {\n                QTIP.api[id] = api;\n              } // Initialize plugins\n\n\n              $.each(PLUGINS, function () {\n                if (this.initialize === 'initialize') {\n                  this(api);\n                }\n              }); // Assign initial pre-render events\n\n              api._assignInitialEvents(event);\n            });\n          }\n    }; // Expose class\n\n\n    $.qtip = QTip; // Populated in render method\n\n    QTIP.api = {};\n    ;\n    $.each({\n      /* Allow other plugins to successfully retrieve the title of an element with a qTip applied */\n      attr: function attr(_attr, val) {\n        if (this.length) {\n          var self = this[0],\n              title = 'title',\n              api = $.data(self, 'qtip');\n\n          if (_attr === title && api && 'object' === _typeof(api) && api.options.suppress) {\n            if (arguments.length < 2) {\n              return $.attr(self, oldtitle);\n            } // If qTip is rendered and title was originally used as content, update it\n\n\n            if (api && api.options.content.attr === title && api.cache.attr) {\n              api.set('content.text', val);\n            } // Use the regular attr method to set, then cache the result\n\n\n            return this.attr(oldtitle, val);\n          }\n        }\n\n        return $.fn['attr' + replaceSuffix].apply(this, arguments);\n      },\n\n      /* Allow clone to correctly retrieve cached title attributes */\n      clone: function clone(keepData) {\n        var titles = $([]),\n            title = 'title',\n            // Clone our element using the real clone method\n        elems = $.fn['clone' + replaceSuffix].apply(this, arguments); // Grab all elements with an oldtitle set, and change it to regular title attribute, if keepData is false\n\n        if (!keepData) {\n          elems.filter('[' + oldtitle + ']').attr('title', function () {\n            return $.attr(this, oldtitle);\n          }).removeAttr(oldtitle);\n        }\n\n        return elems;\n      }\n    }, function (name, func) {\n      if (!func || $.fn[name + replaceSuffix]) {\n        return TRUE;\n      }\n\n      var old = $.fn[name + replaceSuffix] = $.fn[name];\n\n      $.fn[name] = function () {\n        return func.apply(this, arguments) || old.apply(this, arguments);\n      };\n    });\n    /* Fire off 'removeqtip' handler in $.cleanData if jQuery UI not present (it already does similar).\n     * This snippet is taken directly from jQuery UI source code found here:\n     *     http://code.jquery.com/ui/jquery-ui-git.js\n     */\n\n    if (!$.ui) {\n      $['cleanData' + replaceSuffix] = $.cleanData;\n\n      $.cleanData = function (elems) {\n        for (var i = 0, elem; (elem = $(elems[i])).length; i++) {\n          if (elem.attr(ATTR_HAS)) {\n            try {\n              elem.triggerHandler('removeqtip');\n            } catch (e) {}\n          }\n        }\n\n        $['cleanData' + replaceSuffix].apply(this, arguments);\n      };\n    }\n\n    ; // qTip version\n\n    QTIP.version = '2.2.1-29-'; // Base ID for all qTips\n\n    QTIP.nextid = 0; // Inactive events array\n\n    QTIP.inactiveEvents = INACTIVE_EVENTS; // Base z-index for all qTips\n\n    QTIP.zindex = 15000; // Define configuration defaults\n\n    QTIP.defaults = {\n      prerender: FALSE,\n      id: FALSE,\n      overwrite: TRUE,\n      suppress: TRUE,\n      content: {\n        text: TRUE,\n        attr: 'title',\n        title: FALSE,\n        button: FALSE\n      },\n      position: {\n        my: 'top left',\n        at: 'bottom right',\n        target: FALSE,\n        container: FALSE,\n        viewport: FALSE,\n        adjust: {\n          x: 0,\n          y: 0,\n          mouse: TRUE,\n          scroll: TRUE,\n          resize: TRUE,\n          method: 'flipinvert flipinvert'\n        },\n        effect: function effect(api, pos, viewport) {\n          $(this).animate(pos, {\n            duration: 200,\n            queue: FALSE\n          });\n        }\n      },\n      show: {\n        target: FALSE,\n        event: 'mouseenter',\n        effect: TRUE,\n        delay: 90,\n        solo: FALSE,\n        ready: FALSE,\n        autofocus: FALSE\n      },\n      hide: {\n        target: FALSE,\n        event: 'mouseleave',\n        effect: TRUE,\n        delay: 0,\n        fixed: FALSE,\n        inactive: FALSE,\n        leave: 'window',\n        distance: FALSE\n      },\n      style: {\n        classes: '',\n        widget: FALSE,\n        width: FALSE,\n        height: FALSE,\n        def: TRUE\n      },\n      events: {\n        render: NULL,\n        move: NULL,\n        show: NULL,\n        hide: NULL,\n        toggle: NULL,\n        visible: NULL,\n        hidden: NULL,\n        focus: NULL,\n        blur: NULL\n      }\n    };\n    ;\n    var TIP,\n        // .bind()/.on() namespace\n    TIPNS = '.qtip-tip',\n        // Common CSS strings\n    MARGIN = 'margin',\n        BORDER = 'border',\n        COLOR = 'color',\n        BG_COLOR = 'background-color',\n        TRANSPARENT = 'transparent',\n        IMPORTANT = ' !important',\n        // Check if the browser supports <canvas/> elements\n    HASCANVAS = !!document.createElement('canvas').getContext,\n        // Invalid colour values used in parseColours()\n    INVALID = /rgba?\\(0, 0, 0(, 0)?\\)|transparent|#123456/i; // Camel-case method, taken from jQuery source\n    // http://code.jquery.com/jquery-1.8.0.js\n\n    function camel(s) {\n      return s.charAt(0).toUpperCase() + s.slice(1);\n    }\n    /*\n     * Modified from Modernizr's testPropsAll()\n     * http://modernizr.com/downloads/modernizr-latest.js\n     */\n\n\n    var cssProps = {},\n        cssPrefixes = [\"Webkit\", \"O\", \"Moz\", \"ms\"];\n\n    function vendorCss(elem, prop) {\n      var ucProp = prop.charAt(0).toUpperCase() + prop.slice(1),\n          props = (prop + ' ' + cssPrefixes.join(ucProp + ' ') + ucProp).split(' '),\n          cur,\n          val,\n          i = 0; // If the property has already been mapped...\n\n      if (cssProps[prop]) {\n        return elem.css(cssProps[prop]);\n      }\n\n      while (cur = props[i++]) {\n        if ((val = elem.css(cur)) !== undefined) {\n          return cssProps[prop] = cur, val;\n        }\n      }\n    } // Parse a given elements CSS property into an int\n\n\n    function intCss(elem, prop) {\n      return Math.ceil(parseFloat(vendorCss(elem, prop)));\n    } // VML creation (for IE only)\n\n\n    if (!HASCANVAS) {\n      var createVML = function createVML(tag, props, style) {\n        return '<qtipvml:' + tag + ' xmlns=\"urn:schemas-microsoft.com:vml\" class=\"qtip-vml\" ' + (props || '') + ' style=\"behavior: url(#default#VML); ' + (style || '') + '\" />';\n      };\n    } // Canvas only definitions\n    else {\n        var PIXEL_RATIO = window.devicePixelRatio || 1,\n            BACKING_STORE_RATIO = function () {\n          var context = document.createElement('canvas').getContext('2d');\n          return context.backingStorePixelRatio || context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || 1;\n        }(),\n            SCALE = PIXEL_RATIO / BACKING_STORE_RATIO;\n      }\n\n    function Tip(qtip, options) {\n      this._ns = 'tip';\n      this.options = options;\n      this.offset = options.offset;\n      this.size = [options.width, options.height]; // Initialize\n\n      this.init(this.qtip = qtip);\n    }\n\n    $.extend(Tip.prototype, {\n      init: function init(qtip) {\n        var context, tip; // Create tip element and prepend to the tooltip\n\n        tip = this.element = qtip.elements.tip = $('<div />', {\n          'class': NAMESPACE + '-tip'\n        }).prependTo(qtip.tooltip); // Create tip drawing element(s)\n\n        if (HASCANVAS) {\n          // save() as soon as we create the canvas element so FF2 doesn't bork on our first restore()!\n          context = $('<canvas />').appendTo(this.element)[0].getContext('2d'); // Setup constant parameters\n\n          context.lineJoin = 'miter';\n          context.miterLimit = 100000;\n          context.save();\n        } else {\n          context = createVML('shape', 'coordorigin=\"0,0\"', 'position:absolute;');\n          this.element.html(context + context); // Prevent mousing down on the tip since it causes problems with .live() handling in IE due to VML\n\n          qtip._bind($('*', tip).add(tip), ['click', 'mousedown'], function (event) {\n            event.stopPropagation();\n          }, this._ns);\n        } // Bind update events\n\n\n        qtip._bind(qtip.tooltip, 'tooltipmove', this.reposition, this._ns, this); // Create it\n\n\n        this.create();\n      },\n      _swapDimensions: function _swapDimensions() {\n        this.size[0] = this.options.height;\n        this.size[1] = this.options.width;\n      },\n      _resetDimensions: function _resetDimensions() {\n        this.size[0] = this.options.width;\n        this.size[1] = this.options.height;\n      },\n      _useTitle: function _useTitle(corner) {\n        var titlebar = this.qtip.elements.titlebar;\n        return titlebar && (corner.y === TOP || corner.y === CENTER && this.element.position().top + this.size[1] / 2 + this.options.offset < titlebar.outerHeight(TRUE));\n      },\n      _parseCorner: function _parseCorner(corner) {\n        var my = this.qtip.options.position.my; // Detect corner and mimic properties\n\n        if (corner === FALSE || my === FALSE) {\n          corner = FALSE;\n        } else if (corner === TRUE) {\n          corner = new CORNER(my.string());\n        } else if (!corner.string) {\n          corner = new CORNER(corner);\n          corner.fixed = TRUE;\n        }\n\n        return corner;\n      },\n      _parseWidth: function _parseWidth(corner, side, use) {\n        var elements = this.qtip.elements,\n            prop = BORDER + camel(side) + 'Width';\n        return (use ? intCss(use, prop) : intCss(elements.content, prop) || intCss(this._useTitle(corner) && elements.titlebar || elements.content, prop) || intCss(elements.tooltip, prop)) || 0;\n      },\n      _parseRadius: function _parseRadius(corner) {\n        var elements = this.qtip.elements,\n            prop = BORDER + camel(corner.y) + camel(corner.x) + 'Radius';\n        return BROWSER.ie < 9 ? 0 : intCss(this._useTitle(corner) && elements.titlebar || elements.content, prop) || intCss(elements.tooltip, prop) || 0;\n      },\n      _invalidColour: function _invalidColour(elem, prop, compare) {\n        var val = elem.css(prop);\n        return !val || compare && val === elem.css(compare) || INVALID.test(val) ? FALSE : val;\n      },\n      _parseColours: function _parseColours(corner) {\n        var elements = this.qtip.elements,\n            tip = this.element.css('cssText', ''),\n            borderSide = BORDER + camel(corner[corner.precedance]) + camel(COLOR),\n            colorElem = this._useTitle(corner) && elements.titlebar || elements.content,\n            css = this._invalidColour,\n            color = []; // Attempt to detect the background colour from various elements, left-to-right precedance\n\n        color[0] = css(tip, BG_COLOR) || css(colorElem, BG_COLOR) || css(elements.content, BG_COLOR) || css(elements.tooltip, BG_COLOR) || tip.css(BG_COLOR); // Attempt to detect the correct border side colour from various elements, left-to-right precedance\n\n        color[1] = css(tip, borderSide, COLOR) || css(colorElem, borderSide, COLOR) || css(elements.content, borderSide, COLOR) || css(elements.tooltip, borderSide, COLOR) || elements.tooltip.css(borderSide); // Reset background and border colours\n\n        $('*', tip).add(tip).css('cssText', BG_COLOR + ':' + TRANSPARENT + IMPORTANT + ';' + BORDER + ':0' + IMPORTANT + ';');\n        return color;\n      },\n      _calculateSize: function _calculateSize(corner) {\n        var y = corner.precedance === Y,\n            width = this.options['width'],\n            height = this.options['height'],\n            isCenter = corner.abbrev() === 'c',\n            base = (y ? width : height) * (isCenter ? 0.5 : 1),\n            pow = Math.pow,\n            round = Math.round,\n            bigHyp,\n            ratio,\n            result,\n            smallHyp = Math.sqrt(pow(base, 2) + pow(height, 2)),\n            hyp = [this.border / base * smallHyp, this.border / height * smallHyp];\n        hyp[2] = Math.sqrt(pow(hyp[0], 2) - pow(this.border, 2));\n        hyp[3] = Math.sqrt(pow(hyp[1], 2) - pow(this.border, 2));\n        bigHyp = smallHyp + hyp[2] + hyp[3] + (isCenter ? 0 : hyp[0]);\n        ratio = bigHyp / smallHyp;\n        result = [round(ratio * width), round(ratio * height)];\n        return y ? result : result.reverse();\n      },\n      // Tip coordinates calculator\n      _calculateTip: function _calculateTip(corner, size, scale) {\n        scale = scale || 1;\n        size = size || this.size;\n        var width = size[0] * scale,\n            height = size[1] * scale,\n            width2 = Math.ceil(width / 2),\n            height2 = Math.ceil(height / 2),\n            // Define tip coordinates in terms of height and width values\n        tips = {\n          br: [0, 0, width, height, width, 0],\n          bl: [0, 0, width, 0, 0, height],\n          tr: [0, height, width, 0, width, height],\n          tl: [0, 0, 0, height, width, height],\n          tc: [0, height, width2, 0, width, height],\n          bc: [0, 0, width, 0, width2, height],\n          rc: [0, 0, width, height2, 0, height],\n          lc: [width, 0, width, height, 0, height2]\n        }; // Set common side shapes\n\n        tips.lt = tips.br;\n        tips.rt = tips.bl;\n        tips.lb = tips.tr;\n        tips.rb = tips.tl;\n        return tips[corner.abbrev()];\n      },\n      // Tip coordinates drawer (canvas)\n      _drawCoords: function _drawCoords(context, coords) {\n        context.beginPath();\n        context.moveTo(coords[0], coords[1]);\n        context.lineTo(coords[2], coords[3]);\n        context.lineTo(coords[4], coords[5]);\n        context.closePath();\n      },\n      create: function create() {\n        // Determine tip corner\n        var c = this.corner = (HASCANVAS || BROWSER.ie) && this._parseCorner(this.options.corner); // If we have a tip corner...\n\n\n        if (this.enabled = !!this.corner && this.corner.abbrev() !== 'c') {\n          // Cache it\n          this.qtip.cache.corner = c.clone(); // Create it\n\n          this.update();\n        } // Toggle tip element\n\n\n        this.element.toggle(this.enabled);\n        return this.corner;\n      },\n      update: function update(corner, position) {\n        if (!this.enabled) {\n          return this;\n        }\n\n        var elements = this.qtip.elements,\n            tip = this.element,\n            inner = tip.children(),\n            options = this.options,\n            curSize = this.size,\n            mimic = options.mimic,\n            round = Math.round,\n            color,\n            precedance,\n            context,\n            coords,\n            bigCoords,\n            translate,\n            newSize,\n            border,\n            BACKING_STORE_RATIO; // Re-determine tip if not already set\n\n        if (!corner) {\n          corner = this.qtip.cache.corner || this.corner;\n        } // Use corner property if we detect an invalid mimic value\n\n\n        if (mimic === FALSE) {\n          mimic = corner;\n        } // Otherwise inherit mimic properties from the corner object as necessary\n        else {\n            mimic = new CORNER(mimic);\n            mimic.precedance = corner.precedance;\n\n            if (mimic.x === 'inherit') {\n              mimic.x = corner.x;\n            } else if (mimic.y === 'inherit') {\n              mimic.y = corner.y;\n            } else if (mimic.x === mimic.y) {\n              mimic[corner.precedance] = corner[corner.precedance];\n            }\n          }\n\n        precedance = mimic.precedance; // Ensure the tip width.height are relative to the tip position\n\n        if (corner.precedance === X) {\n          this._swapDimensions();\n        } else {\n          this._resetDimensions();\n        } // Update our colours\n\n\n        color = this.color = this._parseColours(corner); // Detect border width, taking into account colours\n\n        if (color[1] !== TRANSPARENT) {\n          // Grab border width\n          border = this.border = this._parseWidth(corner, corner[corner.precedance]); // If border width isn't zero, use border color as fill if it's not invalid (1.0 style tips)\n\n          if (options.border && border < 1 && !INVALID.test(color[1])) {\n            color[0] = color[1];\n          } // Set border width (use detected border width if options.border is true)\n\n\n          this.border = border = options.border !== TRUE ? options.border : border;\n        } // Border colour was invalid, set border to zero\n        else {\n            this.border = border = 0;\n          } // Determine tip size\n\n\n        newSize = this.size = this._calculateSize(corner);\n        tip.css({\n          width: newSize[0],\n          height: newSize[1],\n          lineHeight: newSize[1] + 'px'\n        }); // Calculate tip translation\n\n        if (corner.precedance === Y) {\n          translate = [round(mimic.x === LEFT ? border : mimic.x === RIGHT ? newSize[0] - curSize[0] - border : (newSize[0] - curSize[0]) / 2), round(mimic.y === TOP ? newSize[1] - curSize[1] : 0)];\n        } else {\n          translate = [round(mimic.x === LEFT ? newSize[0] - curSize[0] : 0), round(mimic.y === TOP ? border : mimic.y === BOTTOM ? newSize[1] - curSize[1] - border : (newSize[1] - curSize[1]) / 2)];\n        } // Canvas drawing implementation\n\n\n        if (HASCANVAS) {\n          // Grab canvas context and clear/save it\n          context = inner[0].getContext('2d');\n          context.restore();\n          context.save();\n          context.clearRect(0, 0, 6000, 6000); // Calculate coordinates\n\n          coords = this._calculateTip(mimic, curSize, SCALE);\n          bigCoords = this._calculateTip(mimic, this.size, SCALE); // Set the canvas size using calculated size\n\n          inner.attr(WIDTH, newSize[0] * SCALE).attr(HEIGHT, newSize[1] * SCALE);\n          inner.css(WIDTH, newSize[0]).css(HEIGHT, newSize[1]); // Draw the outer-stroke tip\n\n          this._drawCoords(context, bigCoords);\n\n          context.fillStyle = color[1];\n          context.fill(); // Draw the actual tip\n\n          context.translate(translate[0] * SCALE, translate[1] * SCALE);\n\n          this._drawCoords(context, coords);\n\n          context.fillStyle = color[0];\n          context.fill();\n        } // VML (IE Proprietary implementation)\n        else {\n            // Calculate coordinates\n            coords = this._calculateTip(mimic); // Setup coordinates string\n\n            coords = 'm' + coords[0] + ',' + coords[1] + ' l' + coords[2] + ',' + coords[3] + ' ' + coords[4] + ',' + coords[5] + ' xe'; // Setup VML-specific offset for pixel-perfection\n\n            translate[2] = border && /^(r|b)/i.test(corner.string()) ? BROWSER.ie === 8 ? 2 : 1 : 0; // Set initial CSS\n\n            inner.css({\n              coordsize: newSize[0] + border + ' ' + (newSize[1] + border),\n              antialias: '' + (mimic.string().indexOf(CENTER) > -1),\n              left: translate[0] - translate[2] * Number(precedance === X),\n              top: translate[1] - translate[2] * Number(precedance === Y),\n              width: newSize[0] + border,\n              height: newSize[1] + border\n            }).each(function (i) {\n              var $this = $(this); // Set shape specific attributes\n\n              $this[$this.prop ? 'prop' : 'attr']({\n                coordsize: newSize[0] + border + ' ' + (newSize[1] + border),\n                path: coords,\n                fillcolor: color[0],\n                filled: !!i,\n                stroked: !i\n              }).toggle(!!(border || i)); // Check if border is enabled and add stroke element\n\n              !i && $this.html(createVML('stroke', 'weight=\"' + border * 2 + 'px\" color=\"' + color[1] + '\" miterlimit=\"1000\" joinstyle=\"miter\"'));\n            });\n          } // Opera bug #357 - Incorrect tip position\n        // https://github.com/Craga89/qTip2/issues/367\n\n\n        window.opera && setTimeout(function () {\n          elements.tip.css({\n            display: 'inline-block',\n            visibility: 'visible'\n          });\n        }, 1); // Position if needed\n\n        if (position !== FALSE) {\n          this.calculate(corner, newSize);\n        }\n      },\n      calculate: function calculate(corner, size) {\n        if (!this.enabled) {\n          return FALSE;\n        }\n\n        var self = this,\n            elements = this.qtip.elements,\n            tip = this.element,\n            userOffset = this.options.offset,\n            isWidget = elements.tooltip.hasClass('ui-widget'),\n            position = {},\n            precedance,\n            corners; // Inherit corner if not provided\n\n        corner = corner || this.corner;\n        precedance = corner.precedance; // Determine which tip dimension to use for adjustment\n\n        size = size || this._calculateSize(corner); // Setup corners and offset array\n\n        corners = [corner.x, corner.y];\n\n        if (precedance === X) {\n          corners.reverse();\n        } // Calculate tip position\n\n\n        $.each(corners, function (i, side) {\n          var b, bc, br;\n\n          if (side === CENTER) {\n            b = precedance === Y ? LEFT : TOP;\n            position[b] = '50%';\n            position[MARGIN + '-' + b] = -Math.round(size[precedance === Y ? 0 : 1] / 2) + userOffset;\n          } else {\n            b = self._parseWidth(corner, side, elements.tooltip);\n            bc = self._parseWidth(corner, side, elements.content);\n            br = self._parseRadius(corner);\n            position[side] = Math.max(-self.border, i ? bc : userOffset + (br > b ? br : -b));\n          }\n        }); // Adjust for tip size\n\n        position[corner[precedance]] -= size[precedance === X ? 0 : 1]; // Set and return new position\n\n        tip.css({\n          margin: '',\n          top: '',\n          bottom: '',\n          left: '',\n          right: ''\n        }).css(position);\n        return position;\n      },\n      reposition: function reposition(event, api, pos, viewport) {\n        if (!this.enabled) {\n          return;\n        }\n\n        var cache = api.cache,\n            newCorner = this.corner.clone(),\n            adjust = pos.adjusted,\n            method = api.options.position.adjust.method.split(' '),\n            horizontal = method[0],\n            vertical = method[1] || method[0],\n            shift = {\n          left: FALSE,\n          top: FALSE,\n          x: 0,\n          y: 0\n        },\n            offset,\n            css = {},\n            props;\n\n        function shiftflip(direction, precedance, popposite, side, opposite) {\n          // Horizontal - Shift or flip method\n          if (direction === SHIFT && newCorner.precedance === precedance && adjust[side] && newCorner[popposite] !== CENTER) {\n            newCorner.precedance = newCorner.precedance === X ? Y : X;\n          } else if (direction !== SHIFT && adjust[side]) {\n            newCorner[precedance] = newCorner[precedance] === CENTER ? adjust[side] > 0 ? side : opposite : newCorner[precedance] === side ? opposite : side;\n          }\n        }\n\n        function shiftonly(xy, side, opposite) {\n          if (newCorner[xy] === CENTER) {\n            css[MARGIN + '-' + side] = shift[xy] = offset[MARGIN + '-' + side] - adjust[side];\n          } else {\n            props = offset[opposite] !== undefined ? [adjust[side], -offset[side]] : [-adjust[side], offset[side]];\n\n            if ((shift[xy] = Math.max(props[0], props[1])) > props[0]) {\n              pos[side] -= adjust[side];\n              shift[side] = FALSE;\n            }\n\n            css[offset[opposite] !== undefined ? opposite : side] = shift[xy];\n          }\n        } // If our tip position isn't fixed e.g. doesn't adjust with viewport...\n\n\n        if (this.corner.fixed !== TRUE) {\n          // Perform shift/flip adjustments\n          shiftflip(horizontal, X, Y, LEFT, RIGHT);\n          shiftflip(vertical, Y, X, TOP, BOTTOM); // Update and redraw the tip if needed (check cached details of last drawn tip)\n\n          if (newCorner.string() !== cache.corner.string() || cache.cornerTop !== adjust.top || cache.cornerLeft !== adjust.left) {\n            this.update(newCorner, FALSE);\n          }\n        } // Setup tip offset properties\n\n\n        offset = this.calculate(newCorner); // Readjust offset object to make it left/top\n\n        if (offset.right !== undefined) {\n          offset.left = -offset.right;\n        }\n\n        if (offset.bottom !== undefined) {\n          offset.top = -offset.bottom;\n        }\n\n        offset.user = this.offset; // Perform shift adjustments\n\n        if (shift.left = horizontal === SHIFT && !!adjust.left) {\n          shiftonly(X, LEFT, RIGHT);\n        }\n\n        if (shift.top = vertical === SHIFT && !!adjust.top) {\n          shiftonly(Y, TOP, BOTTOM);\n        }\n        /*\n        * If the tip is adjusted in both dimensions, or in a\n        * direction that would cause it to be anywhere but the\n        * outer border, hide it!\n        */\n\n\n        this.element.css(css).toggle(!(shift.x && shift.y || newCorner.x === CENTER && shift.y || newCorner.y === CENTER && shift.x)); // Adjust position to accomodate tip dimensions\n\n        pos.left -= offset.left.charAt ? offset.user : horizontal !== SHIFT || shift.top || !shift.left && !shift.top ? offset.left + this.border : 0;\n        pos.top -= offset.top.charAt ? offset.user : vertical !== SHIFT || shift.left || !shift.left && !shift.top ? offset.top + this.border : 0; // Cache details\n\n        cache.cornerLeft = adjust.left;\n        cache.cornerTop = adjust.top;\n        cache.corner = newCorner.clone();\n      },\n      destroy: function destroy() {\n        // Unbind events\n        this.qtip._unbind(this.qtip.tooltip, this._ns); // Remove the tip element(s)\n\n\n        if (this.qtip.elements.tip) {\n          this.qtip.elements.tip.find('*').remove().end().remove();\n        }\n      }\n    });\n\n    TIP = PLUGINS.tip = function (api) {\n      return new Tip(api, api.options.style.tip);\n    }; // Initialize tip on render\n\n\n    TIP.initialize = 'render'; // Setup plugin sanitization options\n\n    TIP.sanitize = function (options) {\n      if (options.style && 'tip' in options.style) {\n        var opts = options.style.tip;\n\n        if (_typeof(opts) !== 'object') {\n          opts = options.style.tip = {\n            corner: opts\n          };\n        }\n\n        if (!/string|boolean/i.test(_typeof(opts.corner))) {\n          opts.corner = TRUE;\n        }\n      }\n    }; // Add new option checks for the plugin\n\n\n    CHECKS.tip = {\n      '^position.my|style.tip.(corner|mimic|border)$': function positionMyStyleTipCornerMimicBorder$() {\n        // Make sure a tip can be drawn\n        this.create(); // Reposition the tooltip\n\n        this.qtip.reposition();\n      },\n      '^style.tip.(height|width)$': function styleTipHeightWidth$(obj) {\n        // Re-set dimensions and redraw the tip\n        this.size = [obj.width, obj.height];\n        this.update(); // Reposition the tooltip\n\n        this.qtip.reposition();\n      },\n      '^content.title|style.(classes|widget)$': function contentTitleStyleClassesWidget$() {\n        this.update();\n      }\n    }; // Extend original qTip defaults\n\n    $.extend(TRUE, QTIP.defaults, {\n      style: {\n        tip: {\n          corner: TRUE,\n          mimic: FALSE,\n          width: 6,\n          height: 6,\n          border: TRUE,\n          offset: 0\n        }\n      }\n    });\n    ;\n    var MODAL,\n        OVERLAY,\n        MODALCLASS = 'qtip-modal',\n        MODALSELECTOR = '.' + MODALCLASS;\n\n    OVERLAY = function OVERLAY() {\n      var self = this,\n          focusableElems = {},\n          current,\n          onLast,\n          prevState,\n          elem; // Modified code from jQuery UI 1.10.0 source\n      // http://code.jquery.com/ui/1.10.0/jquery-ui.js\n\n      function focusable(element) {\n        // Use the defined focusable checker when possible\n        if ($.expr[':'].focusable) {\n          return $.expr[':'].focusable;\n        }\n\n        var isTabIndexNotNaN = !isNaN($.attr(element, 'tabindex')),\n            nodeName = element.nodeName && element.nodeName.toLowerCase(),\n            map,\n            mapName,\n            img;\n\n        if ('area' === nodeName) {\n          map = element.parentNode;\n          mapName = map.name;\n\n          if (!element.href || !mapName || map.nodeName.toLowerCase() !== 'map') {\n            return false;\n          }\n\n          img = $('img[usemap=#' + mapName + ']')[0];\n          return !!img && img.is(':visible');\n        }\n\n        return /input|select|textarea|button|object/.test(nodeName) ? !element.disabled : 'a' === nodeName ? element.href || isTabIndexNotNaN : isTabIndexNotNaN;\n      } // Focus inputs using cached focusable elements (see update())\n\n\n      function focusInputs(blurElems) {\n        // Blurring body element in IE causes window.open windows to unfocus!\n        if (focusableElems.length < 1 && blurElems.length) {\n          blurElems.not('body').blur();\n        } // Focus the inputs\n        else {\n            focusableElems.first().focus();\n          }\n      } // Steal focus from elements outside tooltip\n\n\n      function stealFocus(event) {\n        if (!elem.is(':visible')) {\n          return;\n        }\n\n        var target = $(event.target),\n            tooltip = current.tooltip,\n            container = target.closest(SELECTOR),\n            targetOnTop; // Determine if input container target is above this\n\n        targetOnTop = container.length < 1 ? FALSE : parseInt(container[0].style.zIndex, 10) > parseInt(tooltip[0].style.zIndex, 10); // If we're showing a modal, but focus has landed on an input below\n        // this modal, divert focus to the first visible input in this modal\n        // or if we can't find one... the tooltip itself\n\n        if (!targetOnTop && target.closest(SELECTOR)[0] !== tooltip[0]) {\n          focusInputs(target);\n        } // Detect when we leave the last focusable element...\n\n\n        onLast = event.target === focusableElems[focusableElems.length - 1];\n      }\n\n      $.extend(self, {\n        init: function init() {\n          // Create document overlay\n          elem = self.elem = $('<div />', {\n            id: 'qtip-overlay',\n            html: '<div></div>',\n            mousedown: function mousedown() {\n              return FALSE;\n            }\n          }).hide(); // Make sure we can't focus anything outside the tooltip\n\n          $(document.body).bind('focusin' + MODALSELECTOR, stealFocus); // Apply keyboard \"Escape key\" close handler\n\n          $(document).bind('keydown' + MODALSELECTOR, function (event) {\n            if (current && current.options.show.modal.escape && event.keyCode === 27) {\n              current.hide(event);\n            }\n          }); // Apply click handler for blur option\n\n          elem.bind('click' + MODALSELECTOR, function (event) {\n            if (current && current.options.show.modal.blur) {\n              current.hide(event);\n            }\n          });\n          return self;\n        },\n        update: function update(api) {\n          // Update current API reference\n          current = api; // Update focusable elements if enabled\n\n          if (api.options.show.modal.stealfocus !== FALSE) {\n            focusableElems = api.tooltip.find('*').filter(function () {\n              return focusable(this);\n            });\n          } else {\n            focusableElems = [];\n          }\n        },\n        toggle: function toggle(api, state, duration) {\n          var docBody = $(document.body),\n              tooltip = api.tooltip,\n              options = api.options.show.modal,\n              effect = options.effect,\n              type = state ? 'show' : 'hide',\n              visible = elem.is(':visible'),\n              visibleModals = $(MODALSELECTOR).filter(':visible:not(:animated)').not(tooltip),\n              zindex; // Set active tooltip API reference\n\n          self.update(api); // If the modal can steal the focus...\n          // Blur the current item and focus anything in the modal we an\n\n          if (state && options.stealfocus !== FALSE) {\n            focusInputs($(':focus'));\n          } // Toggle backdrop cursor style on show\n\n\n          elem.toggleClass('blurs', options.blur); // Append to body on show\n\n          if (state) {\n            elem.appendTo(document.body);\n          } // Prevent modal from conflicting with show.solo, and don't hide backdrop is other modals are visible\n\n\n          if (elem.is(':animated') && visible === state && prevState !== FALSE || !state && visibleModals.length) {\n            return self;\n          } // Stop all animations\n\n\n          elem.stop(TRUE, FALSE); // Use custom function if provided\n\n          if ($.isFunction(effect)) {\n            effect.call(elem, state);\n          } // If no effect type is supplied, use a simple toggle\n          else if (effect === FALSE) {\n              elem[type]();\n            } // Use basic fade function\n            else {\n                elem.fadeTo(parseInt(duration, 10) || 90, state ? 1 : 0, function () {\n                  if (!state) {\n                    elem.hide();\n                  }\n                });\n              } // Reset position and detach from body on hide\n\n\n          if (!state) {\n            elem.queue(function (next) {\n              elem.css({\n                left: '',\n                top: ''\n              });\n\n              if (!$(MODALSELECTOR).length) {\n                elem.detach();\n              }\n\n              next();\n            });\n          } // Cache the state\n\n\n          prevState = state; // If the tooltip is destroyed, set reference to null\n\n          if (current.destroyed) {\n            current = NULL;\n          }\n\n          return self;\n        }\n      });\n      self.init();\n    };\n\n    OVERLAY = new OVERLAY();\n\n    function Modal(api, options) {\n      this.options = options;\n      this._ns = '-modal';\n      this.init(this.qtip = api);\n    }\n\n    $.extend(Modal.prototype, {\n      init: function init(qtip) {\n        var tooltip = qtip.tooltip; // If modal is disabled... return\n\n        if (!this.options.on) {\n          return this;\n        } // Set overlay reference\n\n\n        qtip.elements.overlay = OVERLAY.elem; // Add unique attribute so we can grab modal tooltips easily via a SELECTOR, and set z-index\n\n        tooltip.addClass(MODALCLASS).css('z-index', QTIP.modal_zindex + $(MODALSELECTOR).length); // Apply our show/hide/focus modal events\n\n        qtip._bind(tooltip, ['tooltipshow', 'tooltiphide'], function (event, api, duration) {\n          var oEvent = event.originalEvent; // Make sure mouseout doesn't trigger a hide when showing the modal and mousing onto backdrop\n\n          if (event.target === tooltip[0]) {\n            if (oEvent && event.type === 'tooltiphide' && /mouse(leave|enter)/.test(oEvent.type) && $(oEvent.relatedTarget).closest(OVERLAY.elem[0]).length) {\n              try {\n                event.preventDefault();\n              } catch (e) {}\n            } else if (!oEvent || oEvent && oEvent.type !== 'tooltipsolo') {\n              this.toggle(event, event.type === 'tooltipshow', duration);\n            }\n          }\n        }, this._ns, this); // Adjust modal z-index on tooltip focus\n\n\n        qtip._bind(tooltip, 'tooltipfocus', function (event, api) {\n          // If focus was cancelled before it reached us, don't do anything\n          if (event.isDefaultPrevented() || event.target !== tooltip[0]) {\n            return;\n          }\n\n          var qtips = $(MODALSELECTOR),\n              // Keep the modal's lower than other, regular qtips\n          newIndex = QTIP.modal_zindex + qtips.length,\n              curIndex = parseInt(tooltip[0].style.zIndex, 10); // Set overlay z-index\n\n          OVERLAY.elem[0].style.zIndex = newIndex - 1; // Reduce modal z-index's and keep them properly ordered\n\n          qtips.each(function () {\n            if (this.style.zIndex > curIndex) {\n              this.style.zIndex -= 1;\n            }\n          }); // Fire blur event for focused tooltip\n\n          qtips.filter('.' + CLASS_FOCUS).qtip('blur', event.originalEvent); // Set the new z-index\n\n          tooltip.addClass(CLASS_FOCUS)[0].style.zIndex = newIndex; // Set current\n\n          OVERLAY.update(api); // Prevent default handling\n\n          try {\n            event.preventDefault();\n          } catch (e) {}\n        }, this._ns, this); // Focus any other visible modals when this one hides\n\n\n        qtip._bind(tooltip, 'tooltiphide', function (event) {\n          if (event.target === tooltip[0]) {\n            $(MODALSELECTOR).filter(':visible').not(tooltip).last().qtip('focus', event);\n          }\n        }, this._ns, this);\n      },\n      toggle: function toggle(event, state, duration) {\n        // Make sure default event hasn't been prevented\n        if (event && event.isDefaultPrevented()) {\n          return this;\n        } // Toggle it\n\n\n        OVERLAY.toggle(this.qtip, !!state, duration);\n      },\n      destroy: function destroy() {\n        // Remove modal class\n        this.qtip.tooltip.removeClass(MODALCLASS); // Remove bound events\n\n        this.qtip._unbind(this.qtip.tooltip, this._ns); // Delete element reference\n\n\n        OVERLAY.toggle(this.qtip, FALSE);\n        delete this.qtip.elements.overlay;\n      }\n    });\n\n    MODAL = PLUGINS.modal = function (api) {\n      return new Modal(api, api.options.show.modal);\n    }; // Setup sanitiztion rules\n\n\n    MODAL.sanitize = function (opts) {\n      if (opts.show) {\n        if (_typeof(opts.show.modal) !== 'object') {\n          opts.show.modal = {\n            on: !!opts.show.modal\n          };\n        } else if (typeof opts.show.modal.on === 'undefined') {\n          opts.show.modal.on = TRUE;\n        }\n      }\n    }; // Base z-index for all modal tooltips (use qTip core z-index as a base)\n\n\n    QTIP.modal_zindex = QTIP.zindex - 200; // Plugin needs to be initialized on render\n\n    MODAL.initialize = 'render'; // Setup option set checks\n\n    CHECKS.modal = {\n      '^show.modal.(on|blur)$': function showModalOnBlur$() {\n        // Initialise\n        this.destroy();\n        this.init(); // Show the modal if not visible already and tooltip is visible\n\n        this.qtip.elems.overlay.toggle(this.qtip.tooltip[0].offsetWidth > 0);\n      }\n    }; // Extend original api defaults\n\n    $.extend(TRUE, QTIP.defaults, {\n      show: {\n        modal: {\n          on: FALSE,\n          effect: TRUE,\n          blur: TRUE,\n          stealfocus: TRUE,\n          escape: TRUE\n        }\n      }\n    });\n    ;\n\n    PLUGINS.viewport = function (api, position, posOptions, targetWidth, targetHeight, elemWidth, elemHeight) {\n      var target = posOptions.target,\n          tooltip = api.elements.tooltip,\n          my = posOptions.my,\n          at = posOptions.at,\n          adjust = posOptions.adjust,\n          method = adjust.method.split(' '),\n          methodX = method[0],\n          methodY = method[1] || method[0],\n          viewport = posOptions.viewport,\n          container = posOptions.container,\n          cache = api.cache,\n          adjusted = {\n        left: 0,\n        top: 0\n      },\n          fixed,\n          newMy,\n          containerOffset,\n          containerStatic,\n          viewportWidth,\n          viewportHeight,\n          viewportScroll,\n          viewportOffset; // If viewport is not a jQuery element, or it's the window/document, or no adjustment method is used... return\n\n      if (!viewport.jquery || target[0] === window || target[0] === document.body || adjust.method === 'none') {\n        return adjusted;\n      } // Cach container details\n\n\n      containerOffset = container.offset() || adjusted;\n      containerStatic = container.css('position') === 'static'; // Cache our viewport details\n\n      fixed = tooltip.css('position') === 'fixed';\n      viewportWidth = viewport[0] === window ? viewport.width() : viewport.outerWidth(FALSE);\n      viewportHeight = viewport[0] === window ? viewport.height() : viewport.outerHeight(FALSE);\n      viewportScroll = {\n        left: fixed ? 0 : viewport.scrollLeft(),\n        top: fixed ? 0 : viewport.scrollTop()\n      };\n      viewportOffset = viewport.offset() || adjusted; // Generic calculation method\n\n      function calculate(side, otherSide, type, adjust, side1, side2, lengthName, targetLength, elemLength) {\n        var initialPos = position[side1],\n            mySide = my[side],\n            atSide = at[side],\n            isShift = type === SHIFT,\n            myLength = mySide === side1 ? elemLength : mySide === side2 ? -elemLength : -elemLength / 2,\n            atLength = atSide === side1 ? targetLength : atSide === side2 ? -targetLength : -targetLength / 2,\n            sideOffset = viewportScroll[side1] + viewportOffset[side1] - (containerStatic ? 0 : containerOffset[side1]),\n            overflow1 = sideOffset - initialPos,\n            overflow2 = initialPos + elemLength - (lengthName === WIDTH ? viewportWidth : viewportHeight) - sideOffset,\n            offset = myLength - (my.precedance === side || mySide === my[otherSide] ? atLength : 0) - (atSide === CENTER ? targetLength / 2 : 0); // shift\n\n        if (isShift) {\n          offset = (mySide === side1 ? 1 : -1) * myLength; // Adjust position but keep it within viewport dimensions\n\n          position[side1] += overflow1 > 0 ? overflow1 : overflow2 > 0 ? -overflow2 : 0;\n          position[side1] = Math.max(-containerOffset[side1] + viewportOffset[side1], initialPos - offset, Math.min(Math.max(-containerOffset[side1] + viewportOffset[side1] + (lengthName === WIDTH ? viewportWidth : viewportHeight), initialPos + offset), position[side1], // Make sure we don't adjust complete off the element when using 'center'\n          mySide === 'center' ? initialPos - myLength : 1E9));\n        } // flip/flipinvert\n        else {\n            // Update adjustment amount depending on if using flipinvert or flip\n            adjust *= type === FLIPINVERT ? 2 : 0; // Check for overflow on the left/top\n\n            if (overflow1 > 0 && (mySide !== side1 || overflow2 > 0)) {\n              position[side1] -= offset + adjust;\n              newMy.invert(side, side1);\n            } // Check for overflow on the bottom/right\n            else if (overflow2 > 0 && (mySide !== side2 || overflow1 > 0)) {\n                position[side1] -= (mySide === CENTER ? -offset : offset) + adjust;\n                newMy.invert(side, side2);\n              } // Make sure we haven't made things worse with the adjustment and reset if so\n\n\n            if (position[side1] < viewportScroll && -position[side1] > overflow2) {\n              position[side1] = initialPos;\n              newMy = my.clone();\n            }\n          }\n\n        return position[side1] - initialPos;\n      } // Set newMy if using flip or flipinvert methods\n\n\n      if (methodX !== 'shift' || methodY !== 'shift') {\n        newMy = my.clone();\n      } // Adjust position based onviewport and adjustment options\n\n\n      adjusted = {\n        left: methodX !== 'none' ? calculate(X, Y, methodX, adjust.x, LEFT, RIGHT, WIDTH, targetWidth, elemWidth) : 0,\n        top: methodY !== 'none' ? calculate(Y, X, methodY, adjust.y, TOP, BOTTOM, HEIGHT, targetHeight, elemHeight) : 0,\n        my: newMy\n      };\n      return adjusted;\n    };\n\n    ;\n    PLUGINS.polys = {\n      // POLY area coordinate calculator\n      //\tSpecial thanks to Ed Cradock for helping out with this.\n      //\tUses a binary search algorithm to find suitable coordinates.\n      polygon: function polygon(baseCoords, corner) {\n        var result = {\n          width: 0,\n          height: 0,\n          position: {\n            top: 1e10,\n            right: 0,\n            bottom: 0,\n            left: 1e10\n          },\n          adjustable: FALSE\n        },\n            i = 0,\n            next,\n            coords = [],\n            compareX = 1,\n            compareY = 1,\n            realX = 0,\n            realY = 0,\n            newWidth,\n            newHeight; // First pass, sanitize coords and determine outer edges\n\n        i = baseCoords.length;\n\n        while (i--) {\n          next = [parseInt(baseCoords[--i], 10), parseInt(baseCoords[i + 1], 10)];\n\n          if (next[0] > result.position.right) {\n            result.position.right = next[0];\n          }\n\n          if (next[0] < result.position.left) {\n            result.position.left = next[0];\n          }\n\n          if (next[1] > result.position.bottom) {\n            result.position.bottom = next[1];\n          }\n\n          if (next[1] < result.position.top) {\n            result.position.top = next[1];\n          }\n\n          coords.push(next);\n        } // Calculate height and width from outer edges\n\n\n        newWidth = result.width = Math.abs(result.position.right - result.position.left);\n        newHeight = result.height = Math.abs(result.position.bottom - result.position.top); // If it's the center corner...\n\n        if (corner.abbrev() === 'c') {\n          result.position = {\n            left: result.position.left + result.width / 2,\n            top: result.position.top + result.height / 2\n          };\n        } else {\n          // Second pass, use a binary search algorithm to locate most suitable coordinate\n          while (newWidth > 0 && newHeight > 0 && compareX > 0 && compareY > 0) {\n            newWidth = Math.floor(newWidth / 2);\n            newHeight = Math.floor(newHeight / 2);\n\n            if (corner.x === LEFT) {\n              compareX = newWidth;\n            } else if (corner.x === RIGHT) {\n              compareX = result.width - newWidth;\n            } else {\n              compareX += Math.floor(newWidth / 2);\n            }\n\n            if (corner.y === TOP) {\n              compareY = newHeight;\n            } else if (corner.y === BOTTOM) {\n              compareY = result.height - newHeight;\n            } else {\n              compareY += Math.floor(newHeight / 2);\n            }\n\n            i = coords.length;\n\n            while (i--) {\n              if (coords.length < 2) {\n                break;\n              }\n\n              realX = coords[i][0] - result.position.left;\n              realY = coords[i][1] - result.position.top;\n\n              if (corner.x === LEFT && realX >= compareX || corner.x === RIGHT && realX <= compareX || corner.x === CENTER && (realX < compareX || realX > result.width - compareX) || corner.y === TOP && realY >= compareY || corner.y === BOTTOM && realY <= compareY || corner.y === CENTER && (realY < compareY || realY > result.height - compareY)) {\n                coords.splice(i, 1);\n              }\n            }\n          }\n\n          result.position = {\n            left: coords[0][0],\n            top: coords[0][1]\n          };\n        }\n\n        return result;\n      },\n      rect: function rect(ax, ay, bx, by) {\n        return {\n          width: Math.abs(bx - ax),\n          height: Math.abs(by - ay),\n          position: {\n            left: Math.min(ax, bx),\n            top: Math.min(ay, by)\n          }\n        };\n      },\n      _angles: {\n        tc: 3 / 2,\n        tr: 7 / 4,\n        tl: 5 / 4,\n        bc: 1 / 2,\n        br: 1 / 4,\n        bl: 3 / 4,\n        rc: 2,\n        lc: 1,\n        c: 0\n      },\n      ellipse: function ellipse(cx, cy, rx, ry, corner) {\n        var c = PLUGINS.polys._angles[corner.abbrev()],\n            rxc = c === 0 ? 0 : rx * Math.cos(c * Math.PI),\n            rys = ry * Math.sin(c * Math.PI);\n\n        return {\n          width: rx * 2 - Math.abs(rxc),\n          height: ry * 2 - Math.abs(rys),\n          position: {\n            left: cx + rxc,\n            top: cy + rys\n          },\n          adjustable: FALSE\n        };\n      },\n      circle: function circle(cx, cy, r, corner) {\n        return PLUGINS.polys.ellipse(cx, cy, r, r, corner);\n      }\n    };\n    ;\n\n    PLUGINS.svg = function (api, svg, corner) {\n      var doc = $(document),\n          elem = svg[0],\n          root = $(elem.ownerSVGElement),\n          ownerDocument = elem.ownerDocument,\n          strokeWidth2 = (parseInt(svg.css('stroke-width'), 10) || 0) / 2,\n          frameOffset,\n          mtx,\n          transformed,\n          viewBox,\n          len,\n          next,\n          i,\n          points,\n          result,\n          position,\n          dimensions; // Ascend the parentNode chain until we find an element with getBBox()\n\n      while (!elem.getBBox) {\n        elem = elem.parentNode;\n      }\n\n      if (!elem.getBBox || !elem.parentNode) {\n        return FALSE;\n      } // Determine which shape calculation to use\n\n\n      switch (elem.nodeName) {\n        case 'ellipse':\n        case 'circle':\n          result = PLUGINS.polys.ellipse(elem.cx.baseVal.value, elem.cy.baseVal.value, (elem.rx || elem.r).baseVal.value + strokeWidth2, (elem.ry || elem.r).baseVal.value + strokeWidth2, corner);\n          break;\n\n        case 'line':\n        case 'polygon':\n        case 'polyline':\n          // Determine points object (line has none, so mimic using array)\n          points = elem.points || [{\n            x: elem.x1.baseVal.value,\n            y: elem.y1.baseVal.value\n          }, {\n            x: elem.x2.baseVal.value,\n            y: elem.y2.baseVal.value\n          }];\n\n          for (result = [], i = -1, len = points.numberOfItems || points.length; ++i < len;) {\n            next = points.getItem ? points.getItem(i) : points[i];\n            result.push.apply(result, [next.x, next.y]);\n          }\n\n          result = PLUGINS.polys.polygon(result, corner);\n          break;\n        // Unknown shape or rectangle? Use bounding box\n\n        default:\n          result = elem.getBBox();\n          result = {\n            width: result.width,\n            height: result.height,\n            position: {\n              left: result.x,\n              top: result.y\n            }\n          };\n          break;\n      } // Shortcut assignments\n\n\n      position = result.position;\n      root = root[0]; // Convert position into a pixel value\n\n      if (root.createSVGPoint) {\n        mtx = elem.getScreenCTM();\n        points = root.createSVGPoint();\n        points.x = position.left;\n        points.y = position.top;\n        transformed = points.matrixTransform(mtx);\n        position.left = transformed.x;\n        position.top = transformed.y;\n      } // Check the element is not in a child document, and if so, adjust for frame elements offset\n\n\n      if (ownerDocument !== document && api.position.target !== 'mouse') {\n        frameOffset = $((ownerDocument.defaultView || ownerDocument.parentWindow).frameElement).offset();\n\n        if (frameOffset) {\n          position.left += frameOffset.left;\n          position.top += frameOffset.top;\n        }\n      } // Adjust by scroll offset of owner document\n\n\n      ownerDocument = $(ownerDocument);\n      position.left += ownerDocument.scrollLeft();\n      position.top += ownerDocument.scrollTop();\n      return result;\n    };\n\n    ;\n\n    PLUGINS.imagemap = function (api, area, corner, adjustMethod) {\n      if (!area.jquery) {\n        area = $(area);\n      }\n\n      var shape = (area.attr('shape') || 'rect').toLowerCase().replace('poly', 'polygon'),\n          image = $('img[usemap=\"#' + area.parent('map').attr('name') + '\"]'),\n          coordsString = $.trim(area.attr('coords')),\n          coordsArray = coordsString.replace(/,$/, '').split(','),\n          imageOffset,\n          coords,\n          i,\n          next,\n          result,\n          len; // If we can't find the image using the map...\n\n      if (!image.length) {\n        return FALSE;\n      } // Pass coordinates string if polygon\n\n\n      if (shape === 'polygon') {\n        result = PLUGINS.polys.polygon(coordsArray, corner);\n      } // Otherwise parse the coordinates and pass them as arguments\n      else if (PLUGINS.polys[shape]) {\n          for (i = -1, len = coordsArray.length, coords = []; ++i < len;) {\n            coords.push(parseInt(coordsArray[i], 10));\n          }\n\n          result = PLUGINS.polys[shape].apply(this, coords.concat(corner));\n        } // If no shapre calculation method was found, return false\n        else {\n            return FALSE;\n          } // Make sure we account for padding and borders on the image\n\n\n      imageOffset = image.offset();\n      imageOffset.left += Math.ceil((image.outerWidth(FALSE) - image.width()) / 2);\n      imageOffset.top += Math.ceil((image.outerHeight(FALSE) - image.height()) / 2); // Add image position to offset coordinates\n\n      result.position.left += imageOffset.left;\n      result.position.top += imageOffset.top;\n      return result;\n    };\n\n    ;\n    var IE6,\n\n    /*\n     * BGIFrame adaption (http://plugins.jquery.com/project/bgiframe)\n     * Special thanks to Brandon Aaron\n     */\n    BGIFRAME = '<iframe class=\"qtip-bgiframe\" frameborder=\"0\" tabindex=\"-1\" src=\"javascript:\\'\\';\" ' + ' style=\"display:block; position:absolute; z-index:-1; filter:alpha(opacity=0); ' + '-ms-filter:\"progid:DXImageTransform.Microsoft.Alpha(Opacity=0)\";\"></iframe>';\n\n    function Ie6(api, qtip) {\n      this._ns = 'ie6';\n      this.init(this.qtip = api);\n    }\n\n    $.extend(Ie6.prototype, {\n      _scroll: function _scroll() {\n        var overlay = this.qtip.elements.overlay;\n        overlay && (overlay[0].style.top = $(window).scrollTop() + 'px');\n      },\n      init: function init(qtip) {\n        var tooltip = qtip.tooltip,\n            scroll; // Create the BGIFrame element if needed\n\n        if ($('select, object').length < 1) {\n          this.bgiframe = qtip.elements.bgiframe = $(BGIFRAME).appendTo(tooltip); // Update BGIFrame on tooltip move\n\n          qtip._bind(tooltip, 'tooltipmove', this.adjustBGIFrame, this._ns, this);\n        } // redraw() container for width/height calculations\n\n\n        this.redrawContainer = $('<div/>', {\n          id: NAMESPACE + '-rcontainer'\n        }).appendTo(document.body); // Fixup modal plugin if present too\n\n        if (qtip.elements.overlay && qtip.elements.overlay.addClass('qtipmodal-ie6fix')) {\n          qtip._bind(window, ['scroll', 'resize'], this._scroll, this._ns, this);\n\n          qtip._bind(tooltip, ['tooltipshow'], this._scroll, this._ns, this);\n        } // Set dimensions\n\n\n        this.redraw();\n      },\n      adjustBGIFrame: function adjustBGIFrame() {\n        var tooltip = this.qtip.tooltip,\n            dimensions = {\n          height: tooltip.outerHeight(FALSE),\n          width: tooltip.outerWidth(FALSE)\n        },\n            plugin = this.qtip.plugins.tip,\n            tip = this.qtip.elements.tip,\n            tipAdjust,\n            offset; // Adjust border offset\n\n        offset = parseInt(tooltip.css('borderLeftWidth'), 10) || 0;\n        offset = {\n          left: -offset,\n          top: -offset\n        }; // Adjust for tips plugin\n\n        if (plugin && tip) {\n          tipAdjust = plugin.corner.precedance === 'x' ? [WIDTH, LEFT] : [HEIGHT, TOP];\n          offset[tipAdjust[1]] -= tip[tipAdjust[0]]();\n        } // Update bgiframe\n\n\n        this.bgiframe.css(offset).css(dimensions);\n      },\n      // Max/min width simulator function\n      redraw: function redraw() {\n        if (this.qtip.rendered < 1 || this.drawing) {\n          return this;\n        }\n\n        var tooltip = this.qtip.tooltip,\n            style = this.qtip.options.style,\n            container = this.qtip.options.position.container,\n            perc,\n            width,\n            max,\n            min; // Set drawing flag\n\n        this.qtip.drawing = 1; // If tooltip has a set height/width, just set it... like a boss!\n\n        if (style.height) {\n          tooltip.css(HEIGHT, style.height);\n        }\n\n        if (style.width) {\n          tooltip.css(WIDTH, style.width);\n        } // Simulate max/min width if not set width present...\n        else {\n            // Reset width and add fluid class\n            tooltip.css(WIDTH, '').appendTo(this.redrawContainer); // Grab our tooltip width (add 1 if odd so we don't get wrapping problems.. huzzah!)\n\n            width = tooltip.width();\n\n            if (width % 2 < 1) {\n              width += 1;\n            } // Grab our max/min properties\n\n\n            max = tooltip.css('maxWidth') || '';\n            min = tooltip.css('minWidth') || ''; // Parse into proper pixel values\n\n            perc = (max + min).indexOf('%') > -1 ? container.width() / 100 : 0;\n            max = (max.indexOf('%') > -1 ? perc : 1) * parseInt(max, 10) || width;\n            min = (min.indexOf('%') > -1 ? perc : 1) * parseInt(min, 10) || 0; // Determine new dimension size based on max/min/current values\n\n            width = max + min ? Math.min(Math.max(width, min), max) : width; // Set the newly calculated width and remvoe fluid class\n\n            tooltip.css(WIDTH, Math.round(width)).appendTo(container);\n          } // Set drawing flag\n\n\n        this.drawing = 0;\n        return this;\n      },\n      destroy: function destroy() {\n        // Remove iframe\n        this.bgiframe && this.bgiframe.remove(); // Remove bound events\n\n        this.qtip._unbind([window, this.qtip.tooltip], this._ns);\n      }\n    });\n\n    IE6 = PLUGINS.ie6 = function (api) {\n      // Proceed only if the browser is IE6\n      return BROWSER.ie === 6 ? new Ie6(api) : FALSE;\n    };\n\n    IE6.initialize = 'render';\n    CHECKS.ie6 = {\n      '^content|style$': function contentStyle$() {\n        this.redraw();\n      }\n    };\n    ;\n  });\n})(window, document);"

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./node_modules/babel-loader/lib/index.js?!./assets/js/jquery.ui-1.11.4.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/raw-loader!./node_modules/babel-loader/lib??ref--4-0!./assets/js/jquery.ui-1.11.4.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*! jQuery UI - v1.11.4 - 2015-03-11\n* http://jqueryui.com\n* Includes: core.js, widget.js, mouse.js, position.js, accordion.js, autocomplete.js, button.js, datepicker.js, dialog.js, draggable.js, droppable.js, effect.js, effect-blind.js, effect-bounce.js, effect-clip.js, effect-drop.js, effect-explode.js, effect-fade.js, effect-fold.js, effect-highlight.js, effect-puff.js, effect-pulsate.js, effect-scale.js, effect-shake.js, effect-size.js, effect-slide.js, effect-transfer.js, menu.js, progressbar.js, resizable.js, selectable.js, selectmenu.js, slider.js, sortable.js, spinner.js, tabs.js, tooltip.js\n* Copyright 2015 jQuery Foundation and other contributors; Licensed MIT */\n(function (factory) {\n  if (typeof define === \"function\" && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([\"jquery\"], factory);\n  } else {\n    // Browser globals\n    factory(jQuery);\n  }\n})(function ($) {\n  /*!\n   * jQuery UI Core 1.11.4\n   * http://jqueryui.com\n   *\n   * Copyright jQuery Foundation and other contributors\n   * Released under the MIT license.\n   * http://jquery.org/license\n   *\n   * http://api.jqueryui.com/category/ui-core/\n   */\n  // $.ui might exist from components with no dependencies, e.g., $.ui.position\n  $.ui = $.ui || {};\n  $.extend($.ui, {\n    version: \"1.11.4\",\n    keyCode: {\n      BACKSPACE: 8,\n      COMMA: 188,\n      DELETE: 46,\n      DOWN: 40,\n      END: 35,\n      ENTER: 13,\n      ESCAPE: 27,\n      HOME: 36,\n      LEFT: 37,\n      PAGE_DOWN: 34,\n      PAGE_UP: 33,\n      PERIOD: 190,\n      RIGHT: 39,\n      SPACE: 32,\n      TAB: 9,\n      UP: 38\n    }\n  }); // plugins\n\n  $.fn.extend({\n    scrollParent: function scrollParent(includeHidden) {\n      var position = this.css(\"position\"),\n          excludeStaticParent = position === \"absolute\",\n          overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/,\n          scrollParent = this.parents().filter(function () {\n        var parent = $(this);\n\n        if (excludeStaticParent && parent.css(\"position\") === \"static\") {\n          return false;\n        }\n\n        return overflowRegex.test(parent.css(\"overflow\") + parent.css(\"overflow-y\") + parent.css(\"overflow-x\"));\n      }).eq(0);\n      return position === \"fixed\" || !scrollParent.length ? $(this[0].ownerDocument || document) : scrollParent;\n    },\n    uniqueId: function () {\n      var uuid = 0;\n      return function () {\n        return this.each(function () {\n          if (!this.id) {\n            this.id = \"ui-id-\" + ++uuid;\n          }\n        });\n      };\n    }(),\n    removeUniqueId: function removeUniqueId() {\n      return this.each(function () {\n        if (/^ui-id-\\d+$/.test(this.id)) {\n          $(this).removeAttr(\"id\");\n        }\n      });\n    }\n  }); // selectors\n\n  function _focusable(element, isTabIndexNotNaN) {\n    var map,\n        mapName,\n        img,\n        nodeName = element.nodeName.toLowerCase();\n\n    if (\"area\" === nodeName) {\n      map = element.parentNode;\n      mapName = map.name;\n\n      if (!element.href || !mapName || map.nodeName.toLowerCase() !== \"map\") {\n        return false;\n      }\n\n      img = $(\"img[usemap='#\" + mapName + \"']\")[0];\n      return !!img && visible(img);\n    }\n\n    return (/^(input|select|textarea|button|object)$/.test(nodeName) ? !element.disabled : \"a\" === nodeName ? element.href || isTabIndexNotNaN : isTabIndexNotNaN) && // the element and all of its ancestors must be visible\n    visible(element);\n  }\n\n  function visible(element) {\n    return $.expr.filters.visible(element) && !$(element).parents().addBack().filter(function () {\n      return $.css(this, \"visibility\") === \"hidden\";\n    }).length;\n  }\n\n  $.extend($.expr[\":\"], {\n    data: $.expr.createPseudo ? $.expr.createPseudo(function (dataName) {\n      return function (elem) {\n        return !!$.data(elem, dataName);\n      };\n    }) : // support: jQuery <1.8\n    function (elem, i, match) {\n      return !!$.data(elem, match[3]);\n    },\n    focusable: function focusable(element) {\n      return _focusable(element, !isNaN($.attr(element, \"tabindex\")));\n    },\n    tabbable: function tabbable(element) {\n      var tabIndex = $.attr(element, \"tabindex\"),\n          isTabIndexNaN = isNaN(tabIndex);\n      return (isTabIndexNaN || tabIndex >= 0) && _focusable(element, !isTabIndexNaN);\n    }\n  }); // support: jQuery <1.8\n\n  if (!$(\"<a>\").outerWidth(1).jquery) {\n    $.each([\"Width\", \"Height\"], function (i, name) {\n      var side = name === \"Width\" ? [\"Left\", \"Right\"] : [\"Top\", \"Bottom\"],\n          type = name.toLowerCase(),\n          orig = {\n        innerWidth: $.fn.innerWidth,\n        innerHeight: $.fn.innerHeight,\n        outerWidth: $.fn.outerWidth,\n        outerHeight: $.fn.outerHeight\n      };\n\n      function reduce(elem, size, border, margin) {\n        $.each(side, function () {\n          size -= parseFloat($.css(elem, \"padding\" + this)) || 0;\n\n          if (border) {\n            size -= parseFloat($.css(elem, \"border\" + this + \"Width\")) || 0;\n          }\n\n          if (margin) {\n            size -= parseFloat($.css(elem, \"margin\" + this)) || 0;\n          }\n        });\n        return size;\n      }\n\n      $.fn[\"inner\" + name] = function (size) {\n        if (size === undefined) {\n          return orig[\"inner\" + name].call(this);\n        }\n\n        return this.each(function () {\n          $(this).css(type, reduce(this, size) + \"px\");\n        });\n      };\n\n      $.fn[\"outer\" + name] = function (size, margin) {\n        if (typeof size !== \"number\") {\n          return orig[\"outer\" + name].call(this, size);\n        }\n\n        return this.each(function () {\n          $(this).css(type, reduce(this, size, true, margin) + \"px\");\n        });\n      };\n    });\n  } // support: jQuery <1.8\n\n\n  if (!$.fn.addBack) {\n    $.fn.addBack = function (selector) {\n      return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));\n    };\n  } // support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)\n\n\n  if ($(\"<a>\").data(\"a-b\", \"a\").removeData(\"a-b\").data(\"a-b\")) {\n    $.fn.removeData = function (removeData) {\n      return function (key) {\n        if (arguments.length) {\n          return removeData.call(this, $.camelCase(key));\n        } else {\n          return removeData.call(this);\n        }\n      };\n    }($.fn.removeData);\n  } // deprecated\n\n\n  $.ui.ie = !!/msie [\\w.]+/.exec(navigator.userAgent.toLowerCase());\n  $.fn.extend({\n    focus: function (orig) {\n      return function (delay, fn) {\n        return typeof delay === \"number\" ? this.each(function () {\n          var elem = this;\n          setTimeout(function () {\n            $(elem).focus();\n\n            if (fn) {\n              fn.call(elem);\n            }\n          }, delay);\n        }) : orig.apply(this, arguments);\n      };\n    }($.fn.focus),\n    disableSelection: function () {\n      var eventType = \"onselectstart\" in document.createElement(\"div\") ? \"selectstart\" : \"mousedown\";\n      return function () {\n        return this.bind(eventType + \".ui-disableSelection\", function (event) {\n          event.preventDefault();\n        });\n      };\n    }(),\n    enableSelection: function enableSelection() {\n      return this.unbind(\".ui-disableSelection\");\n    },\n    zIndex: function zIndex(_zIndex) {\n      if (_zIndex !== undefined) {\n        return this.css(\"zIndex\", _zIndex);\n      }\n\n      if (this.length) {\n        var elem = $(this[0]),\n            position,\n            value;\n\n        while (elem.length && elem[0] !== document) {\n          // Ignore z-index if position is set to a value where z-index is ignored by the browser\n          // This makes behavior of this function consistent across browsers\n          // WebKit always returns auto if the element is positioned\n          position = elem.css(\"position\");\n\n          if (position === \"absolute\" || position === \"relative\" || position === \"fixed\") {\n            // IE returns 0 when zIndex is not specified\n            // other browsers return a string\n            // we ignore the case of nested elements with an explicit value of 0\n            // <div style=\"z-index: -10;\"><div style=\"z-index: 0;\"></div></div>\n            value = parseInt(elem.css(\"zIndex\"), 10);\n\n            if (!isNaN(value) && value !== 0) {\n              return value;\n            }\n          }\n\n          elem = elem.parent();\n        }\n      }\n\n      return 0;\n    }\n  }); // $.ui.plugin is deprecated. Use $.widget() extensions instead.\n\n  $.ui.plugin = {\n    add: function add(module, option, set) {\n      var i,\n          proto = $.ui[module].prototype;\n\n      for (i in set) {\n        proto.plugins[i] = proto.plugins[i] || [];\n        proto.plugins[i].push([option, set[i]]);\n      }\n    },\n    call: function call(instance, name, args, allowDisconnected) {\n      var i,\n          set = instance.plugins[name];\n\n      if (!set) {\n        return;\n      }\n\n      if (!allowDisconnected && (!instance.element[0].parentNode || instance.element[0].parentNode.nodeType === 11)) {\n        return;\n      }\n\n      for (i = 0; i < set.length; i++) {\n        if (instance.options[set[i][0]]) {\n          set[i][1].apply(instance.element, args);\n        }\n      }\n    }\n  };\n  /*!\n   * jQuery UI Widget 1.11.4\n   * http://jqueryui.com\n   *\n   * Copyright jQuery Foundation and other contributors\n   * Released under the MIT license.\n   * http://jquery.org/license\n   *\n   * http://api.jqueryui.com/jQuery.widget/\n   */\n\n  var widget_uuid = 0,\n      widget_slice = Array.prototype.slice;\n\n  $.cleanData = function (orig) {\n    return function (elems) {\n      var events, elem, i;\n\n      for (i = 0; (elem = elems[i]) != null; i++) {\n        try {\n          // Only trigger remove when necessary to save time\n          events = $._data(elem, \"events\");\n\n          if (events && events.remove) {\n            $(elem).triggerHandler(\"remove\");\n          } // http://bugs.jquery.com/ticket/8235\n\n        } catch (e) {}\n      }\n\n      orig(elems);\n    };\n  }($.cleanData);\n\n  $.widget = function (name, base, prototype) {\n    var fullName,\n        existingConstructor,\n        constructor,\n        basePrototype,\n        // proxiedPrototype allows the provided prototype to remain unmodified\n    // so that it can be used as a mixin for multiple widgets (#8876)\n    proxiedPrototype = {},\n        namespace = name.split(\".\")[0];\n    name = name.split(\".\")[1];\n    fullName = namespace + \"-\" + name;\n\n    if (!prototype) {\n      prototype = base;\n      base = $.Widget;\n    } // create selector for plugin\n\n\n    $.expr[\":\"][fullName.toLowerCase()] = function (elem) {\n      return !!$.data(elem, fullName);\n    };\n\n    $[namespace] = $[namespace] || {};\n    existingConstructor = $[namespace][name];\n\n    constructor = $[namespace][name] = function (options, element) {\n      // allow instantiation without \"new\" keyword\n      if (!this._createWidget) {\n        return new constructor(options, element);\n      } // allow instantiation without initializing for simple inheritance\n      // must use \"new\" keyword (the code above always passes args)\n\n\n      if (arguments.length) {\n        this._createWidget(options, element);\n      }\n    }; // extend with the existing constructor to carry over any static properties\n\n\n    $.extend(constructor, existingConstructor, {\n      version: prototype.version,\n      // copy the object used to create the prototype in case we need to\n      // redefine the widget later\n      _proto: $.extend({}, prototype),\n      // track widgets that inherit from this widget in case this widget is\n      // redefined after a widget inherits from it\n      _childConstructors: []\n    });\n    basePrototype = new base(); // we need to make the options hash a property directly on the new instance\n    // otherwise we'll modify the options hash on the prototype that we're\n    // inheriting from\n\n    basePrototype.options = $.widget.extend({}, basePrototype.options);\n    $.each(prototype, function (prop, value) {\n      if (!$.isFunction(value)) {\n        proxiedPrototype[prop] = value;\n        return;\n      }\n\n      proxiedPrototype[prop] = function () {\n        var _super = function _super() {\n          return base.prototype[prop].apply(this, arguments);\n        },\n            _superApply = function _superApply(args) {\n          return base.prototype[prop].apply(this, args);\n        };\n\n        return function () {\n          var __super = this._super,\n              __superApply = this._superApply,\n              returnValue;\n          this._super = _super;\n          this._superApply = _superApply;\n          returnValue = value.apply(this, arguments);\n          this._super = __super;\n          this._superApply = __superApply;\n          return returnValue;\n        };\n      }();\n    });\n    constructor.prototype = $.widget.extend(basePrototype, {\n      // TODO: remove support for widgetEventPrefix\n      // always use the name + a colon as the prefix, e.g., draggable:start\n      // don't prefix for widgets that aren't DOM-based\n      widgetEventPrefix: existingConstructor ? basePrototype.widgetEventPrefix || name : name\n    }, proxiedPrototype, {\n      constructor: constructor,\n      namespace: namespace,\n      widgetName: name,\n      widgetFullName: fullName\n    }); // If this widget is being redefined then we need to find all widgets that\n    // are inheriting from it and redefine all of them so that they inherit from\n    // the new version of this widget. We're essentially trying to replace one\n    // level in the prototype chain.\n\n    if (existingConstructor) {\n      $.each(existingConstructor._childConstructors, function (i, child) {\n        var childPrototype = child.prototype; // redefine the child widget using the same prototype that was\n        // originally used, but inherit from the new version of the base\n\n        $.widget(childPrototype.namespace + \".\" + childPrototype.widgetName, constructor, child._proto);\n      }); // remove the list of existing child constructors from the old constructor\n      // so the old child constructors can be garbage collected\n\n      delete existingConstructor._childConstructors;\n    } else {\n      base._childConstructors.push(constructor);\n    }\n\n    $.widget.bridge(name, constructor);\n    return constructor;\n  };\n\n  $.widget.extend = function (target) {\n    var input = widget_slice.call(arguments, 1),\n        inputIndex = 0,\n        inputLength = input.length,\n        key,\n        value;\n\n    for (; inputIndex < inputLength; inputIndex++) {\n      for (key in input[inputIndex]) {\n        value = input[inputIndex][key];\n\n        if (input[inputIndex].hasOwnProperty(key) && value !== undefined) {\n          // Clone objects\n          if ($.isPlainObject(value)) {\n            target[key] = $.isPlainObject(target[key]) ? $.widget.extend({}, target[key], value) : // Don't extend strings, arrays, etc. with objects\n            $.widget.extend({}, value); // Copy everything else by reference\n          } else {\n            target[key] = value;\n          }\n        }\n      }\n    }\n\n    return target;\n  };\n\n  $.widget.bridge = function (name, object) {\n    var fullName = object.prototype.widgetFullName || name;\n\n    $.fn[name] = function (options) {\n      var isMethodCall = typeof options === \"string\",\n          args = widget_slice.call(arguments, 1),\n          returnValue = this;\n\n      if (isMethodCall) {\n        this.each(function () {\n          var methodValue,\n              instance = $.data(this, fullName);\n\n          if (options === \"instance\") {\n            returnValue = instance;\n            return false;\n          }\n\n          if (!instance) {\n            return $.error(\"cannot call methods on \" + name + \" prior to initialization; \" + \"attempted to call method '\" + options + \"'\");\n          }\n\n          if (!$.isFunction(instance[options]) || options.charAt(0) === \"_\") {\n            return $.error(\"no such method '\" + options + \"' for \" + name + \" widget instance\");\n          }\n\n          methodValue = instance[options].apply(instance, args);\n\n          if (methodValue !== instance && methodValue !== undefined) {\n            returnValue = methodValue && methodValue.jquery ? returnValue.pushStack(methodValue.get()) : methodValue;\n            return false;\n          }\n        });\n      } else {\n        // Allow multiple hashes to be passed on init\n        if (args.length) {\n          options = $.widget.extend.apply(null, [options].concat(args));\n        }\n\n        this.each(function () {\n          var instance = $.data(this, fullName);\n\n          if (instance) {\n            instance.option(options || {});\n\n            if (instance._init) {\n              instance._init();\n            }\n          } else {\n            $.data(this, fullName, new object(options, this));\n          }\n        });\n      }\n\n      return returnValue;\n    };\n  };\n\n  $.Widget = function ()\n  /* options, element */\n  {};\n\n  $.Widget._childConstructors = [];\n  $.Widget.prototype = {\n    widgetName: \"widget\",\n    widgetEventPrefix: \"\",\n    defaultElement: \"<div>\",\n    options: {\n      disabled: false,\n      // callbacks\n      create: null\n    },\n    _createWidget: function _createWidget(options, element) {\n      element = $(element || this.defaultElement || this)[0];\n      this.element = $(element);\n      this.uuid = widget_uuid++;\n      this.eventNamespace = \".\" + this.widgetName + this.uuid;\n      this.bindings = $();\n      this.hoverable = $();\n      this.focusable = $();\n\n      if (element !== this) {\n        $.data(element, this.widgetFullName, this);\n\n        this._on(true, this.element, {\n          remove: function remove(event) {\n            if (event.target === element) {\n              this.destroy();\n            }\n          }\n        });\n\n        this.document = $(element.style ? // element within the document\n        element.ownerDocument : // element is window or document\n        element.document || element);\n        this.window = $(this.document[0].defaultView || this.document[0].parentWindow);\n      }\n\n      this.options = $.widget.extend({}, this.options, this._getCreateOptions(), options);\n\n      this._create();\n\n      this._trigger(\"create\", null, this._getCreateEventData());\n\n      this._init();\n    },\n    _getCreateOptions: $.noop,\n    _getCreateEventData: $.noop,\n    _create: $.noop,\n    _init: $.noop,\n    destroy: function destroy() {\n      this._destroy(); // we can probably remove the unbind calls in 2.0\n      // all event bindings should go through this._on()\n\n\n      this.element.unbind(this.eventNamespace).removeData(this.widgetFullName) // support: jquery <1.6.3\n      // http://bugs.jquery.com/ticket/9413\n      .removeData($.camelCase(this.widgetFullName));\n      this.widget().unbind(this.eventNamespace).removeAttr(\"aria-disabled\").removeClass(this.widgetFullName + \"-disabled \" + \"ui-state-disabled\"); // clean up events and states\n\n      this.bindings.unbind(this.eventNamespace);\n      this.hoverable.removeClass(\"ui-state-hover\");\n      this.focusable.removeClass(\"ui-state-focus\");\n    },\n    _destroy: $.noop,\n    widget: function widget() {\n      return this.element;\n    },\n    option: function option(key, value) {\n      var options = key,\n          parts,\n          curOption,\n          i;\n\n      if (arguments.length === 0) {\n        // don't return a reference to the internal hash\n        return $.widget.extend({}, this.options);\n      }\n\n      if (typeof key === \"string\") {\n        // handle nested keys, e.g., \"foo.bar\" => { foo: { bar: ___ } }\n        options = {};\n        parts = key.split(\".\");\n        key = parts.shift();\n\n        if (parts.length) {\n          curOption = options[key] = $.widget.extend({}, this.options[key]);\n\n          for (i = 0; i < parts.length - 1; i++) {\n            curOption[parts[i]] = curOption[parts[i]] || {};\n            curOption = curOption[parts[i]];\n          }\n\n          key = parts.pop();\n\n          if (arguments.length === 1) {\n            return curOption[key] === undefined ? null : curOption[key];\n          }\n\n          curOption[key] = value;\n        } else {\n          if (arguments.length === 1) {\n            return this.options[key] === undefined ? null : this.options[key];\n          }\n\n          options[key] = value;\n        }\n      }\n\n      this._setOptions(options);\n\n      return this;\n    },\n    _setOptions: function _setOptions(options) {\n      var key;\n\n      for (key in options) {\n        this._setOption(key, options[key]);\n      }\n\n      return this;\n    },\n    _setOption: function _setOption(key, value) {\n      this.options[key] = value;\n\n      if (key === \"disabled\") {\n        this.widget().toggleClass(this.widgetFullName + \"-disabled\", !!value); // If the widget is becoming disabled, then nothing is interactive\n\n        if (value) {\n          this.hoverable.removeClass(\"ui-state-hover\");\n          this.focusable.removeClass(\"ui-state-focus\");\n        }\n      }\n\n      return this;\n    },\n    enable: function enable() {\n      return this._setOptions({\n        disabled: false\n      });\n    },\n    disable: function disable() {\n      return this._setOptions({\n        disabled: true\n      });\n    },\n    _on: function _on(suppressDisabledCheck, element, handlers) {\n      var delegateElement,\n          instance = this; // no suppressDisabledCheck flag, shuffle arguments\n\n      if (typeof suppressDisabledCheck !== \"boolean\") {\n        handlers = element;\n        element = suppressDisabledCheck;\n        suppressDisabledCheck = false;\n      } // no element argument, shuffle and use this.element\n\n\n      if (!handlers) {\n        handlers = element;\n        element = this.element;\n        delegateElement = this.widget();\n      } else {\n        element = delegateElement = $(element);\n        this.bindings = this.bindings.add(element);\n      }\n\n      $.each(handlers, function (event, handler) {\n        function handlerProxy() {\n          // allow widgets to customize the disabled handling\n          // - disabled as an array instead of boolean\n          // - disabled class as method for disabling individual parts\n          if (!suppressDisabledCheck && (instance.options.disabled === true || $(this).hasClass(\"ui-state-disabled\"))) {\n            return;\n          }\n\n          return (typeof handler === \"string\" ? instance[handler] : handler).apply(instance, arguments);\n        } // copy the guid so direct unbinding works\n\n\n        if (typeof handler !== \"string\") {\n          handlerProxy.guid = handler.guid = handler.guid || handlerProxy.guid || $.guid++;\n        }\n\n        var match = event.match(/^([\\w:-]*)\\s*(.*)$/),\n            eventName = match[1] + instance.eventNamespace,\n            selector = match[2];\n\n        if (selector) {\n          delegateElement.delegate(selector, eventName, handlerProxy);\n        } else {\n          element.bind(eventName, handlerProxy);\n        }\n      });\n    },\n    _off: function _off(element, eventName) {\n      eventName = (eventName || \"\").split(\" \").join(this.eventNamespace + \" \") + this.eventNamespace;\n      element.unbind(eventName).undelegate(eventName); // Clear the stack to avoid memory leaks (#10056)\n\n      this.bindings = $(this.bindings.not(element).get());\n      this.focusable = $(this.focusable.not(element).get());\n      this.hoverable = $(this.hoverable.not(element).get());\n    },\n    _delay: function _delay(handler, delay) {\n      function handlerProxy() {\n        return (typeof handler === \"string\" ? instance[handler] : handler).apply(instance, arguments);\n      }\n\n      var instance = this;\n      return setTimeout(handlerProxy, delay || 0);\n    },\n    _hoverable: function _hoverable(element) {\n      this.hoverable = this.hoverable.add(element);\n\n      this._on(element, {\n        mouseenter: function mouseenter(event) {\n          $(event.currentTarget).addClass(\"ui-state-hover\");\n        },\n        mouseleave: function mouseleave(event) {\n          $(event.currentTarget).removeClass(\"ui-state-hover\");\n        }\n      });\n    },\n    _focusable: function _focusable(element) {\n      this.focusable = this.focusable.add(element);\n\n      this._on(element, {\n        focusin: function focusin(event) {\n          $(event.currentTarget).addClass(\"ui-state-focus\");\n        },\n        focusout: function focusout(event) {\n          $(event.currentTarget).removeClass(\"ui-state-focus\");\n        }\n      });\n    },\n    _trigger: function _trigger(type, event, data) {\n      var prop,\n          orig,\n          callback = this.options[type];\n      data = data || {};\n      event = $.Event(event);\n      event.type = (type === this.widgetEventPrefix ? type : this.widgetEventPrefix + type).toLowerCase(); // the original event may come from any element\n      // so we need to reset the target on the new event\n\n      event.target = this.element[0]; // copy original event properties over to the new event\n\n      orig = event.originalEvent;\n\n      if (orig) {\n        for (prop in orig) {\n          if (!(prop in event)) {\n            event[prop] = orig[prop];\n          }\n        }\n      }\n\n      this.element.trigger(event, data);\n      return !($.isFunction(callback) && callback.apply(this.element[0], [event].concat(data)) === false || event.isDefaultPrevented());\n    }\n  };\n  $.each({\n    show: \"fadeIn\",\n    hide: \"fadeOut\"\n  }, function (method, defaultEffect) {\n    $.Widget.prototype[\"_\" + method] = function (element, options, callback) {\n      if (typeof options === \"string\") {\n        options = {\n          effect: options\n        };\n      }\n\n      var hasOptions,\n          effectName = !options ? method : options === true || typeof options === \"number\" ? defaultEffect : options.effect || defaultEffect;\n      options = options || {};\n\n      if (typeof options === \"number\") {\n        options = {\n          duration: options\n        };\n      }\n\n      hasOptions = !$.isEmptyObject(options);\n      options.complete = callback;\n\n      if (options.delay) {\n        element.delay(options.delay);\n      }\n\n      if (hasOptions && $.effects && $.effects.effect[effectName]) {\n        element[method](options);\n      } else if (effectName !== method && element[effectName]) {\n        element[effectName](options.duration, options.easing, callback);\n      } else {\n        element.queue(function (next) {\n          $(this)[method]();\n\n          if (callback) {\n            callback.call(element[0]);\n          }\n\n          next();\n        });\n      }\n    };\n  });\n  var widget = $.widget;\n  /*!\n   * jQuery UI Mouse 1.11.4\n   * http://jqueryui.com\n   *\n   * Copyright jQuery Foundation and other contributors\n   * Released under the MIT license.\n   * http://jquery.org/license\n   *\n   * http://api.jqueryui.com/mouse/\n   */\n\n  var mouseHandled = false;\n  $(document).mouseup(function () {\n    mouseHandled = false;\n  });\n  var mouse = $.widget(\"ui.mouse\", {\n    version: \"1.11.4\",\n    options: {\n      cancel: \"input,textarea,button,select,option\",\n      distance: 1,\n      delay: 0\n    },\n    _mouseInit: function _mouseInit() {\n      var that = this;\n      this.element.bind(\"mousedown.\" + this.widgetName, function (event) {\n        return that._mouseDown(event);\n      }).bind(\"click.\" + this.widgetName, function (event) {\n        if (true === $.data(event.target, that.widgetName + \".preventClickEvent\")) {\n          $.removeData(event.target, that.widgetName + \".preventClickEvent\");\n          event.stopImmediatePropagation();\n          return false;\n        }\n      });\n      this.started = false;\n    },\n    // TODO: make sure destroying one instance of mouse doesn't mess with\n    // other instances of mouse\n    _mouseDestroy: function _mouseDestroy() {\n      this.element.unbind(\".\" + this.widgetName);\n\n      if (this._mouseMoveDelegate) {\n        this.document.unbind(\"mousemove.\" + this.widgetName, this._mouseMoveDelegate).unbind(\"mouseup.\" + this.widgetName, this._mouseUpDelegate);\n      }\n    },\n    _mouseDown: function _mouseDown(event) {\n      // don't let more than one widget handle mouseStart\n      if (mouseHandled) {\n        return;\n      }\n\n      this._mouseMoved = false; // we may have missed mouseup (out of window)\n\n      this._mouseStarted && this._mouseUp(event);\n      this._mouseDownEvent = event;\n      var that = this,\n          btnIsLeft = event.which === 1,\n          // event.target.nodeName works around a bug in IE 8 with\n      // disabled inputs (#7620)\n      elIsCancel = typeof this.options.cancel === \"string\" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false;\n\n      if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {\n        return true;\n      }\n\n      this.mouseDelayMet = !this.options.delay;\n\n      if (!this.mouseDelayMet) {\n        this._mouseDelayTimer = setTimeout(function () {\n          that.mouseDelayMet = true;\n        }, this.options.delay);\n      }\n\n      if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {\n        this._mouseStarted = this._mouseStart(event) !== false;\n\n        if (!this._mouseStarted) {\n          event.preventDefault();\n          return true;\n        }\n      } // Click event may never have fired (Gecko & Opera)\n\n\n      if (true === $.data(event.target, this.widgetName + \".preventClickEvent\")) {\n        $.removeData(event.target, this.widgetName + \".preventClickEvent\");\n      } // these delegates are required to keep context\n\n\n      this._mouseMoveDelegate = function (event) {\n        return that._mouseMove(event);\n      };\n\n      this._mouseUpDelegate = function (event) {\n        return that._mouseUp(event);\n      };\n\n      this.document.bind(\"mousemove.\" + this.widgetName, this._mouseMoveDelegate).bind(\"mouseup.\" + this.widgetName, this._mouseUpDelegate);\n      event.preventDefault();\n      mouseHandled = true;\n      return true;\n    },\n    _mouseMove: function _mouseMove(event) {\n      // Only check for mouseups outside the document if you've moved inside the document\n      // at least once. This prevents the firing of mouseup in the case of IE<9, which will\n      // fire a mousemove event if content is placed under the cursor. See #7778\n      // Support: IE <9\n      if (this._mouseMoved) {\n        // IE mouseup check - mouseup happened when mouse was out of window\n        if ($.ui.ie && (!document.documentMode || document.documentMode < 9) && !event.button) {\n          return this._mouseUp(event); // Iframe mouseup check - mouseup occurred in another document\n        } else if (!event.which) {\n          return this._mouseUp(event);\n        }\n      }\n\n      if (event.which || event.button) {\n        this._mouseMoved = true;\n      }\n\n      if (this._mouseStarted) {\n        this._mouseDrag(event);\n\n        return event.preventDefault();\n      }\n\n      if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {\n        this._mouseStarted = this._mouseStart(this._mouseDownEvent, event) !== false;\n        this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event);\n      }\n\n      return !this._mouseStarted;\n    },\n    _mouseUp: function _mouseUp(event) {\n      this.document.unbind(\"mousemove.\" + this.widgetName, this._mouseMoveDelegate).unbind(\"mouseup.\" + this.widgetName, this._mouseUpDelegate);\n\n      if (this._mouseStarted) {\n        this._mouseStarted = false;\n\n        if (event.target === this._mouseDownEvent.target) {\n          $.data(event.target, this.widgetName + \".preventClickEvent\", true);\n        }\n\n        this._mouseStop(event);\n      }\n\n      mouseHandled = false;\n      return false;\n    },\n    _mouseDistanceMet: function _mouseDistanceMet(event) {\n      return Math.max(Math.abs(this._mouseDownEvent.pageX - event.pageX), Math.abs(this._mouseDownEvent.pageY - event.pageY)) >= this.options.distance;\n    },\n    _mouseDelayMet: function _mouseDelayMet()\n    /* event */\n    {\n      return this.mouseDelayMet;\n    },\n    // These are placeholder methods, to be overriden by extending plugin\n    _mouseStart: function _mouseStart()\n    /* event */\n    {},\n    _mouseDrag: function _mouseDrag()\n    /* event */\n    {},\n    _mouseStop: function _mouseStop()\n    /* event */\n    {},\n    _mouseCapture: function _mouseCapture()\n    /* event */\n    {\n      return true;\n    }\n  });\n  /*!\n   * jQuery UI Position 1.11.4\n   * http://jqueryui.com\n   *\n   * Copyright jQuery Foundation and other contributors\n   * Released under the MIT license.\n   * http://jquery.org/license\n   *\n   * http://api.jqueryui.com/position/\n   */\n\n  (function () {\n    $.ui = $.ui || {};\n    var cachedScrollbarWidth,\n        supportsOffsetFractions,\n        max = Math.max,\n        abs = Math.abs,\n        round = Math.round,\n        rhorizontal = /left|center|right/,\n        rvertical = /top|center|bottom/,\n        roffset = /[\\+\\-]\\d+(\\.[\\d]+)?%?/,\n        rposition = /^\\w+/,\n        rpercent = /%$/,\n        _position = $.fn.position;\n\n    function getOffsets(offsets, width, height) {\n      return [parseFloat(offsets[0]) * (rpercent.test(offsets[0]) ? width / 100 : 1), parseFloat(offsets[1]) * (rpercent.test(offsets[1]) ? height / 100 : 1)];\n    }\n\n    function parseCss(element, property) {\n      return parseInt($.css(element, property), 10) || 0;\n    }\n\n    function getDimensions(elem) {\n      var raw = elem[0];\n\n      if (raw.nodeType === 9) {\n        return {\n          width: elem.width(),\n          height: elem.height(),\n          offset: {\n            top: 0,\n            left: 0\n          }\n        };\n      }\n\n      if ($.isWindow(raw)) {\n        return {\n          width: elem.width(),\n          height: elem.height(),\n          offset: {\n            top: elem.scrollTop(),\n            left: elem.scrollLeft()\n          }\n        };\n      }\n\n      if (raw.preventDefault) {\n        return {\n          width: 0,\n          height: 0,\n          offset: {\n            top: raw.pageY,\n            left: raw.pageX\n          }\n        };\n      }\n\n      return {\n        width: elem.outerWidth(),\n        height: elem.outerHeight(),\n        offset: elem.offset()\n      };\n    }\n\n    $.position = {\n      scrollbarWidth: function scrollbarWidth() {\n        if (cachedScrollbarWidth !== undefined) {\n          return cachedScrollbarWidth;\n        }\n\n        var w1,\n            w2,\n            div = $(\"<div style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>\"),\n            innerDiv = div.children()[0];\n        $(\"body\").append(div);\n        w1 = innerDiv.offsetWidth;\n        div.css(\"overflow\", \"scroll\");\n        w2 = innerDiv.offsetWidth;\n\n        if (w1 === w2) {\n          w2 = div[0].clientWidth;\n        }\n\n        div.remove();\n        return cachedScrollbarWidth = w1 - w2;\n      },\n      getScrollInfo: function getScrollInfo(within) {\n        var overflowX = within.isWindow || within.isDocument ? \"\" : within.element.css(\"overflow-x\"),\n            overflowY = within.isWindow || within.isDocument ? \"\" : within.element.css(\"overflow-y\"),\n            hasOverflowX = overflowX === \"scroll\" || overflowX === \"auto\" && within.width < within.element[0].scrollWidth,\n            hasOverflowY = overflowY === \"scroll\" || overflowY === \"auto\" && within.height < within.element[0].scrollHeight;\n        return {\n          width: hasOverflowY ? $.position.scrollbarWidth() : 0,\n          height: hasOverflowX ? $.position.scrollbarWidth() : 0\n        };\n      },\n      getWithinInfo: function getWithinInfo(element) {\n        var withinElement = $(element || window),\n            isWindow = $.isWindow(withinElement[0]),\n            isDocument = !!withinElement[0] && withinElement[0].nodeType === 9;\n        return {\n          element: withinElement,\n          isWindow: isWindow,\n          isDocument: isDocument,\n          offset: withinElement.offset() || {\n            left: 0,\n            top: 0\n          },\n          scrollLeft: withinElement.scrollLeft(),\n          scrollTop: withinElement.scrollTop(),\n          // support: jQuery 1.6.x\n          // jQuery 1.6 doesn't support .outerWidth/Height() on documents or windows\n          width: isWindow || isDocument ? withinElement.width() : withinElement.outerWidth(),\n          height: isWindow || isDocument ? withinElement.height() : withinElement.outerHeight()\n        };\n      }\n    };\n\n    $.fn.position = function (options) {\n      if (!options || !options.of) {\n        return _position.apply(this, arguments);\n      } // make a copy, we don't want to modify arguments\n\n\n      options = $.extend({}, options);\n      var atOffset,\n          targetWidth,\n          targetHeight,\n          targetOffset,\n          basePosition,\n          dimensions,\n          target = $(options.of),\n          within = $.position.getWithinInfo(options.within),\n          scrollInfo = $.position.getScrollInfo(within),\n          collision = (options.collision || \"flip\").split(\" \"),\n          offsets = {};\n      dimensions = getDimensions(target);\n\n      if (target[0].preventDefault) {\n        // force left top to allow flipping\n        options.at = \"left top\";\n      }\n\n      targetWidth = dimensions.width;\n      targetHeight = dimensions.height;\n      targetOffset = dimensions.offset; // clone to reuse original targetOffset later\n\n      basePosition = $.extend({}, targetOffset); // force my and at to have valid horizontal and vertical positions\n      // if a value is missing or invalid, it will be converted to center\n\n      $.each([\"my\", \"at\"], function () {\n        var pos = (options[this] || \"\").split(\" \"),\n            horizontalOffset,\n            verticalOffset;\n\n        if (pos.length === 1) {\n          pos = rhorizontal.test(pos[0]) ? pos.concat([\"center\"]) : rvertical.test(pos[0]) ? [\"center\"].concat(pos) : [\"center\", \"center\"];\n        }\n\n        pos[0] = rhorizontal.test(pos[0]) ? pos[0] : \"center\";\n        pos[1] = rvertical.test(pos[1]) ? pos[1] : \"center\"; // calculate offsets\n\n        horizontalOffset = roffset.exec(pos[0]);\n        verticalOffset = roffset.exec(pos[1]);\n        offsets[this] = [horizontalOffset ? horizontalOffset[0] : 0, verticalOffset ? verticalOffset[0] : 0]; // reduce to just the positions without the offsets\n\n        options[this] = [rposition.exec(pos[0])[0], rposition.exec(pos[1])[0]];\n      }); // normalize collision option\n\n      if (collision.length === 1) {\n        collision[1] = collision[0];\n      }\n\n      if (options.at[0] === \"right\") {\n        basePosition.left += targetWidth;\n      } else if (options.at[0] === \"center\") {\n        basePosition.left += targetWidth / 2;\n      }\n\n      if (options.at[1] === \"bottom\") {\n        basePosition.top += targetHeight;\n      } else if (options.at[1] === \"center\") {\n        basePosition.top += targetHeight / 2;\n      }\n\n      atOffset = getOffsets(offsets.at, targetWidth, targetHeight);\n      basePosition.left += atOffset[0];\n      basePosition.top += atOffset[1];\n      return this.each(function () {\n        var collisionPosition,\n            using,\n            elem = $(this),\n            elemWidth = elem.outerWidth(),\n            elemHeight = elem.outerHeight(),\n            marginLeft = parseCss(this, \"marginLeft\"),\n            marginTop = parseCss(this, \"marginTop\"),\n            collisionWidth = elemWidth + marginLeft + parseCss(this, \"marginRight\") + scrollInfo.width,\n            collisionHeight = elemHeight + marginTop + parseCss(this, \"marginBottom\") + scrollInfo.height,\n            position = $.extend({}, basePosition),\n            myOffset = getOffsets(offsets.my, elem.outerWidth(), elem.outerHeight());\n\n        if (options.my[0] === \"right\") {\n          position.left -= elemWidth;\n        } else if (options.my[0] === \"center\") {\n          position.left -= elemWidth / 2;\n        }\n\n        if (options.my[1] === \"bottom\") {\n          position.top -= elemHeight;\n        } else if (options.my[1] === \"center\") {\n          position.top -= elemHeight / 2;\n        }\n\n        position.left += myOffset[0];\n        position.top += myOffset[1]; // if the browser doesn't support fractions, then round for consistent results\n\n        if (!supportsOffsetFractions) {\n          position.left = round(position.left);\n          position.top = round(position.top);\n        }\n\n        collisionPosition = {\n          marginLeft: marginLeft,\n          marginTop: marginTop\n        };\n        $.each([\"left\", \"top\"], function (i, dir) {\n          if ($.ui.position[collision[i]]) {\n            $.ui.position[collision[i]][dir](position, {\n              targetWidth: targetWidth,\n              targetHeight: targetHeight,\n              elemWidth: elemWidth,\n              elemHeight: elemHeight,\n              collisionPosition: collisionPosition,\n              collisionWidth: collisionWidth,\n              collisionHeight: collisionHeight,\n              offset: [atOffset[0] + myOffset[0], atOffset[1] + myOffset[1]],\n              my: options.my,\n              at: options.at,\n              within: within,\n              elem: elem\n            });\n          }\n        });\n\n        if (options.using) {\n          // adds feedback as second argument to using callback, if present\n          using = function using(props) {\n            var left = targetOffset.left - position.left,\n                right = left + targetWidth - elemWidth,\n                top = targetOffset.top - position.top,\n                bottom = top + targetHeight - elemHeight,\n                feedback = {\n              target: {\n                element: target,\n                left: targetOffset.left,\n                top: targetOffset.top,\n                width: targetWidth,\n                height: targetHeight\n              },\n              element: {\n                element: elem,\n                left: position.left,\n                top: position.top,\n                width: elemWidth,\n                height: elemHeight\n              },\n              horizontal: right < 0 ? \"left\" : left > 0 ? \"right\" : \"center\",\n              vertical: bottom < 0 ? \"top\" : top > 0 ? \"bottom\" : \"middle\"\n            };\n\n            if (targetWidth < elemWidth && abs(left + right) < targetWidth) {\n              feedback.horizontal = \"center\";\n            }\n\n            if (targetHeight < elemHeight && abs(top + bottom) < targetHeight) {\n              feedback.vertical = \"middle\";\n            }\n\n            if (max(abs(left), abs(right)) > max(abs(top), abs(bottom))) {\n              feedback.important = \"horizontal\";\n            } else {\n              feedback.important = \"vertical\";\n            }\n\n            options.using.call(this, props, feedback);\n          };\n        }\n\n        elem.offset($.extend(position, {\n          using: using\n        }));\n      });\n    };\n\n    $.ui.position = {\n      fit: {\n        left: function left(position, data) {\n          var within = data.within,\n              withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,\n              outerWidth = within.width,\n              collisionPosLeft = position.left - data.collisionPosition.marginLeft,\n              overLeft = withinOffset - collisionPosLeft,\n              overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,\n              newOverRight; // element is wider than within\n\n          if (data.collisionWidth > outerWidth) {\n            // element is initially over the left side of within\n            if (overLeft > 0 && overRight <= 0) {\n              newOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;\n              position.left += overLeft - newOverRight; // element is initially over right side of within\n            } else if (overRight > 0 && overLeft <= 0) {\n              position.left = withinOffset; // element is initially over both left and right sides of within\n            } else {\n              if (overLeft > overRight) {\n                position.left = withinOffset + outerWidth - data.collisionWidth;\n              } else {\n                position.left = withinOffset;\n              }\n            } // too far left -> align with left edge\n\n          } else if (overLeft > 0) {\n            position.left += overLeft; // too far right -> align with right edge\n          } else if (overRight > 0) {\n            position.left -= overRight; // adjust based on position and margin\n          } else {\n            position.left = max(position.left - collisionPosLeft, position.left);\n          }\n        },\n        top: function top(position, data) {\n          var within = data.within,\n              withinOffset = within.isWindow ? within.scrollTop : within.offset.top,\n              outerHeight = data.within.height,\n              collisionPosTop = position.top - data.collisionPosition.marginTop,\n              overTop = withinOffset - collisionPosTop,\n              overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,\n              newOverBottom; // element is taller than within\n\n          if (data.collisionHeight > outerHeight) {\n            // element is initially over the top of within\n            if (overTop > 0 && overBottom <= 0) {\n              newOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset;\n              position.top += overTop - newOverBottom; // element is initially over bottom of within\n            } else if (overBottom > 0 && overTop <= 0) {\n              position.top = withinOffset; // element is initially over both top and bottom of within\n            } else {\n              if (overTop > overBottom) {\n                position.top = withinOffset + outerHeight - data.collisionHeight;\n              } else {\n                position.top = withinOffset;\n              }\n            } // too far up -> align with top\n\n          } else if (overTop > 0) {\n            position.top += overTop; // too far down -> align with bottom edge\n          } else if (overBottom > 0) {\n            position.top -= overBottom; // adjust based on position and margin\n          } else {\n            position.top = max(position.top - collisionPosTop, position.top);\n          }\n        }\n      },\n      flip: {\n        left: function left(position, data) {\n          var within = data.within,\n              withinOffset = within.offset.left + within.scrollLeft,\n              outerWidth = within.width,\n              offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,\n              collisionPosLeft = position.left - data.collisionPosition.marginLeft,\n              overLeft = collisionPosLeft - offsetLeft,\n              overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,\n              myOffset = data.my[0] === \"left\" ? -data.elemWidth : data.my[0] === \"right\" ? data.elemWidth : 0,\n              atOffset = data.at[0] === \"left\" ? data.targetWidth : data.at[0] === \"right\" ? -data.targetWidth : 0,\n              offset = -2 * data.offset[0],\n              newOverRight,\n              newOverLeft;\n\n          if (overLeft < 0) {\n            newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset;\n\n            if (newOverRight < 0 || newOverRight < abs(overLeft)) {\n              position.left += myOffset + atOffset + offset;\n            }\n          } else if (overRight > 0) {\n            newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft;\n\n            if (newOverLeft > 0 || abs(newOverLeft) < overRight) {\n              position.left += myOffset + atOffset + offset;\n            }\n          }\n        },\n        top: function top(position, data) {\n          var within = data.within,\n              withinOffset = within.offset.top + within.scrollTop,\n              outerHeight = within.height,\n              offsetTop = within.isWindow ? within.scrollTop : within.offset.top,\n              collisionPosTop = position.top - data.collisionPosition.marginTop,\n              overTop = collisionPosTop - offsetTop,\n              overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,\n              top = data.my[1] === \"top\",\n              myOffset = top ? -data.elemHeight : data.my[1] === \"bottom\" ? data.elemHeight : 0,\n              atOffset = data.at[1] === \"top\" ? data.targetHeight : data.at[1] === \"bottom\" ? -data.targetHeight : 0,\n              offset = -2 * data.offset[1],\n              newOverTop,\n              newOverBottom;\n\n          if (overTop < 0) {\n            newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;\n\n            if (newOverBottom < 0 || newOverBottom < abs(overTop)) {\n              position.top += myOffset + atOffset + offset;\n            }\n          } else if (overBottom > 0) {\n            newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;\n\n            if (newOverTop > 0 || abs(newOverTop) < overBottom) {\n              position.top += myOffset + atOffset + offset;\n            }\n          }\n        }\n      },\n      flipfit: {\n        left: function left() {\n          $.ui.position.flip.left.apply(this, arguments);\n          $.ui.position.fit.left.apply(this, arguments);\n        },\n        top: function top() {\n          $.ui.position.flip.top.apply(this, arguments);\n          $.ui.position.fit.top.apply(this, arguments);\n        }\n      }\n    }; // fraction support test\n\n    (function () {\n      var testElement,\n          testElementParent,\n          testElementStyle,\n          offsetLeft,\n          i,\n          body = document.getElementsByTagName(\"body\")[0],\n          div = document.createElement(\"div\"); //Create a \"fake body\" for testing based on method used in jQuery.support\n\n      testElement = document.createElement(body ? \"div\" : \"body\");\n      testElementStyle = {\n        visibility: \"hidden\",\n        width: 0,\n        height: 0,\n        border: 0,\n        margin: 0,\n        background: \"none\"\n      };\n\n      if (body) {\n        $.extend(testElementStyle, {\n          position: \"absolute\",\n          left: \"-1000px\",\n          top: \"-1000px\"\n        });\n      }\n\n      for (i in testElementStyle) {\n        testElement.style[i] = testElementStyle[i];\n      }\n\n      testElement.appendChild(div);\n      testElementParent = body || document.documentElement;\n      testElementParent.insertBefore(testElement, testElementParent.firstChild);\n      div.style.cssText = \"position: absolute; left: 10.7432222px;\";\n      offsetLeft = $(div).offset().left;\n      supportsOffsetFractions = offsetLeft > 10 && offsetLeft < 11;\n      testElement.innerHTML = \"\";\n      testElementParent.removeChild(testElement);\n    })();\n  })();\n\n  var position = $.ui.position;\n  /*!\n   * jQuery UI Accordion 1.11.4\n   * http://jqueryui.com\n   *\n   * Copyright jQuery Foundation and other contributors\n   * Released under the MIT license.\n   * http://jquery.org/license\n   *\n   * http://api.jqueryui.com/accordion/\n   */\n\n  var accordion = $.widget(\"ui.accordion\", {\n    version: \"1.11.4\",\n    options: {\n      active: 0,\n      animate: {},\n      collapsible: false,\n      event: \"click\",\n      header: \"> li > :first-child,> :not(li):even\",\n      heightStyle: \"auto\",\n      icons: {\n        activeHeader: \"ui-icon-triangle-1-s\",\n        header: \"ui-icon-triangle-1-e\"\n      },\n      // callbacks\n      activate: null,\n      beforeActivate: null\n    },\n    hideProps: {\n      borderTopWidth: \"hide\",\n      borderBottomWidth: \"hide\",\n      paddingTop: \"hide\",\n      paddingBottom: \"hide\",\n      height: \"hide\"\n    },\n    showProps: {\n      borderTopWidth: \"show\",\n      borderBottomWidth: \"show\",\n      paddingTop: \"show\",\n      paddingBottom: \"show\",\n      height: \"show\"\n    },\n    _create: function _create() {\n      var options = this.options;\n      this.prevShow = this.prevHide = $();\n      this.element.addClass(\"ui-accordion ui-widget ui-helper-reset\") // ARIA\n      .attr(\"role\", \"tablist\"); // don't allow collapsible: false and active: false / null\n\n      if (!options.collapsible && (options.active === false || options.active == null)) {\n        options.active = 0;\n      }\n\n      this._processPanels(); // handle negative values\n\n\n      if (options.active < 0) {\n        options.active += this.headers.length;\n      }\n\n      this._refresh();\n    },\n    _getCreateEventData: function _getCreateEventData() {\n      return {\n        header: this.active,\n        panel: !this.active.length ? $() : this.active.next()\n      };\n    },\n    _createIcons: function _createIcons() {\n      var icons = this.options.icons;\n\n      if (icons) {\n        $(\"<span>\").addClass(\"ui-accordion-header-icon ui-icon \" + icons.header).prependTo(this.headers);\n        this.active.children(\".ui-accordion-header-icon\").removeClass(icons.header).addClass(icons.activeHeader);\n        this.headers.addClass(\"ui-accordion-icons\");\n      }\n    },\n    _destroyIcons: function _destroyIcons() {\n      this.headers.removeClass(\"ui-accordion-icons\").children(\".ui-accordion-header-icon\").remove();\n    },\n    _destroy: function _destroy() {\n      var contents; // clean up main element\n\n      this.element.removeClass(\"ui-accordion ui-widget ui-helper-reset\").removeAttr(\"role\"); // clean up headers\n\n      this.headers.removeClass(\"ui-accordion-header ui-accordion-header-active ui-state-default \" + \"ui-corner-all ui-state-active ui-state-disabled ui-corner-top\").removeAttr(\"role\").removeAttr(\"aria-expanded\").removeAttr(\"aria-selected\").removeAttr(\"aria-controls\").removeAttr(\"tabIndex\").removeUniqueId();\n\n      this._destroyIcons(); // clean up content panels\n\n\n      contents = this.headers.next().removeClass(\"ui-helper-reset ui-widget-content ui-corner-bottom \" + \"ui-accordion-content ui-accordion-content-active ui-state-disabled\").css(\"display\", \"\").removeAttr(\"role\").removeAttr(\"aria-hidden\").removeAttr(\"aria-labelledby\").removeUniqueId();\n\n      if (this.options.heightStyle !== \"content\") {\n        contents.css(\"height\", \"\");\n      }\n    },\n    _setOption: function _setOption(key, value) {\n      if (key === \"active\") {\n        // _activate() will handle invalid values and update this.options\n        this._activate(value);\n\n        return;\n      }\n\n      if (key === \"event\") {\n        if (this.options.event) {\n          this._off(this.headers, this.options.event);\n        }\n\n        this._setupEvents(value);\n      }\n\n      this._super(key, value); // setting collapsible: false while collapsed; open first panel\n\n\n      if (key === \"collapsible\" && !value && this.options.active === false) {\n        this._activate(0);\n      }\n\n      if (key === \"icons\") {\n        this._destroyIcons();\n\n        if (value) {\n          this._createIcons();\n        }\n      } // #5332 - opacity doesn't cascade to positioned elements in IE\n      // so we need to add the disabled class to the headers and panels\n\n\n      if (key === \"disabled\") {\n        this.element.toggleClass(\"ui-state-disabled\", !!value).attr(\"aria-disabled\", value);\n        this.headers.add(this.headers.next()).toggleClass(\"ui-state-disabled\", !!value);\n      }\n    },\n    _keydown: function _keydown(event) {\n      if (event.altKey || event.ctrlKey) {\n        return;\n      }\n\n      var keyCode = $.ui.keyCode,\n          length = this.headers.length,\n          currentIndex = this.headers.index(event.target),\n          toFocus = false;\n\n      switch (event.keyCode) {\n        case keyCode.RIGHT:\n        case keyCode.DOWN:\n          toFocus = this.headers[(currentIndex + 1) % length];\n          break;\n\n        case keyCode.LEFT:\n        case keyCode.UP:\n          toFocus = this.headers[(currentIndex - 1 + length) % length];\n          break;\n\n        case keyCode.SPACE:\n        case keyCode.ENTER:\n          this._eventHandler(event);\n\n          break;\n\n        case keyCode.HOME:\n          toFocus = this.headers[0];\n          break;\n\n        case keyCode.END:\n          toFocus = this.headers[length - 1];\n          break;\n      }\n\n      if (toFocus) {\n        $(event.target).attr(\"tabIndex\", -1);\n        $(toFocus).attr(\"tabIndex\", 0);\n        toFocus.focus();\n        event.preventDefault();\n      }\n    },\n    _panelKeyDown: function _panelKeyDown(event) {\n      if (event.keyCode === $.ui.keyCode.UP && event.ctrlKey) {\n        $(event.currentTarget).prev().focus();\n      }\n    },\n    refresh: function refresh() {\n      var options = this.options;\n\n      this._processPanels(); // was collapsed or no panel\n\n\n      if (options.active === false && options.collapsible === true || !this.headers.length) {\n        options.active = false;\n        this.active = $(); // active false only when collapsible is true\n      } else if (options.active === false) {\n        this._activate(0); // was active, but active panel is gone\n\n      } else if (this.active.length && !$.contains(this.element[0], this.active[0])) {\n        // all remaining panel are disabled\n        if (this.headers.length === this.headers.find(\".ui-state-disabled\").length) {\n          options.active = false;\n          this.active = $(); // activate previous panel\n        } else {\n          this._activate(Math.max(0, options.active - 1));\n        } // was active, active panel still exists\n\n      } else {\n        // make sure active index is correct\n        options.active = this.headers.index(this.active);\n      }\n\n      this._destroyIcons();\n\n      this._refresh();\n    },\n    _processPanels: function _processPanels() {\n      var prevHeaders = this.headers,\n          prevPanels = this.panels;\n      this.headers = this.element.find(this.options.header).addClass(\"ui-accordion-header ui-state-default ui-corner-all\");\n      this.panels = this.headers.next().addClass(\"ui-accordion-content ui-helper-reset ui-widget-content ui-corner-bottom\").filter(\":not(.ui-accordion-content-active)\").hide(); // Avoid memory leaks (#10056)\n\n      if (prevPanels) {\n        this._off(prevHeaders.not(this.headers));\n\n        this._off(prevPanels.not(this.panels));\n      }\n    },\n    _refresh: function _refresh() {\n      var maxHeight,\n          options = this.options,\n          heightStyle = options.heightStyle,\n          parent = this.element.parent();\n      this.active = this._findActive(options.active).addClass(\"ui-accordion-header-active ui-state-active ui-corner-top\").removeClass(\"ui-corner-all\");\n      this.active.next().addClass(\"ui-accordion-content-active\").show();\n      this.headers.attr(\"role\", \"tab\").each(function () {\n        var header = $(this),\n            headerId = header.uniqueId().attr(\"id\"),\n            panel = header.next(),\n            panelId = panel.uniqueId().attr(\"id\");\n        header.attr(\"aria-controls\", panelId);\n        panel.attr(\"aria-labelledby\", headerId);\n      }).next().attr(\"role\", \"tabpanel\");\n      this.headers.not(this.active).attr({\n        \"aria-selected\": \"false\",\n        \"aria-expanded\": \"false\",\n        tabIndex: -1\n      }).next().attr({\n        \"aria-hidden\": \"true\"\n      }).hide(); // make sure at least one header is in the tab order\n\n      if (!this.active.length) {\n        this.headers.eq(0).attr(\"tabIndex\", 0);\n      } else {\n        this.active.attr({\n          \"aria-selected\": \"true\",\n          \"aria-expanded\": \"true\",\n          tabIndex: 0\n        }).next().attr({\n          \"aria-hidden\": \"false\"\n        });\n      }\n\n      this._createIcons();\n\n      this._setupEvents(options.event);\n\n      if (heightStyle === \"fill\") {\n        maxHeight = parent.height();\n        this.element.siblings(\":visible\").each(function () {\n          var elem = $(this),\n              position = elem.css(\"position\");\n\n          if (position === \"absolute\" || position === \"fixed\") {\n            return;\n          }\n\n          maxHeight -= elem.outerHeight(true);\n        });\n        this.headers.each(function () {\n          maxHeight -= $(this).outerHeight(true);\n        });\n        this.headers.next().each(function () {\n          $(this).height(Math.max(0, maxHeight - $(this).innerHeight() + $(this).height()));\n        }).css(\"overflow\", \"auto\");\n      } else if (heightStyle === \"auto\") {\n        maxHeight = 0;\n        this.headers.next().each(function () {\n          maxHeight = Math.max(maxHeight, $(this).css(\"height\", \"\").height());\n        }).height(maxHeight);\n      }\n    },\n    _activate: function _activate(index) {\n      var active = this._findActive(index)[0]; // trying to activate the already active panel\n\n\n      if (active === this.active[0]) {\n        return;\n      } // trying to collapse, simulate a click on the currently active header\n\n\n      active = active || this.active[0];\n\n      this._eventHandler({\n        target: active,\n        currentTarget: active,\n        preventDefault: $.noop\n      });\n    },\n    _findActive: function _findActive(selector) {\n      return typeof selector === \"number\" ? this.headers.eq(selector) : $();\n    },\n    _setupEvents: function _setupEvents(event) {\n      var events = {\n        keydown: \"_keydown\"\n      };\n\n      if (event) {\n        $.each(event.split(\" \"), function (index, eventName) {\n          events[eventName] = \"_eventHandler\";\n        });\n      }\n\n      this._off(this.headers.add(this.headers.next()));\n\n      this._on(this.headers, events);\n\n      this._on(this.headers.next(), {\n        keydown: \"_panelKeyDown\"\n      });\n\n      this._hoverable(this.headers);\n\n      this._focusable(this.headers);\n    },\n    _eventHandler: function _eventHandler(event) {\n      var options = this.options,\n          active = this.active,\n          clicked = $(event.currentTarget),\n          clickedIsActive = clicked[0] === active[0],\n          collapsing = clickedIsActive && options.collapsible,\n          toShow = collapsing ? $() : clicked.next(),\n          toHide = active.next(),\n          eventData = {\n        oldHeader: active,\n        oldPanel: toHide,\n        newHeader: collapsing ? $() : clicked,\n        newPanel: toShow\n      };\n      event.preventDefault();\n\n      if ( // click on active header, but not collapsible\n      clickedIsActive && !options.collapsible || // allow canceling activation\n      this._trigger(\"beforeActivate\", event, eventData) === false) {\n        return;\n      }\n\n      options.active = collapsing ? false : this.headers.index(clicked); // when the call to ._toggle() comes after the class changes\n      // it causes a very odd bug in IE 8 (see #6720)\n\n      this.active = clickedIsActive ? $() : clicked;\n\n      this._toggle(eventData); // switch classes\n      // corner classes on the previously active header stay after the animation\n\n\n      active.removeClass(\"ui-accordion-header-active ui-state-active\");\n\n      if (options.icons) {\n        active.children(\".ui-accordion-header-icon\").removeClass(options.icons.activeHeader).addClass(options.icons.header);\n      }\n\n      if (!clickedIsActive) {\n        clicked.removeClass(\"ui-corner-all\").addClass(\"ui-accordion-header-active ui-state-active ui-corner-top\");\n\n        if (options.icons) {\n          clicked.children(\".ui-accordion-header-icon\").removeClass(options.icons.header).addClass(options.icons.activeHeader);\n        }\n\n        clicked.next().addClass(\"ui-accordion-content-active\");\n      }\n    },\n    _toggle: function _toggle(data) {\n      var toShow = data.newPanel,\n          toHide = this.prevShow.length ? this.prevShow : data.oldPanel; // handle activating a panel during the animation for another activation\n\n      this.prevShow.add(this.prevHide).stop(true, true);\n      this.prevShow = toShow;\n      this.prevHide = toHide;\n\n      if (this.options.animate) {\n        this._animate(toShow, toHide, data);\n      } else {\n        toHide.hide();\n        toShow.show();\n\n        this._toggleComplete(data);\n      }\n\n      toHide.attr({\n        \"aria-hidden\": \"true\"\n      });\n      toHide.prev().attr({\n        \"aria-selected\": \"false\",\n        \"aria-expanded\": \"false\"\n      }); // if we're switching panels, remove the old header from the tab order\n      // if we're opening from collapsed state, remove the previous header from the tab order\n      // if we're collapsing, then keep the collapsing header in the tab order\n\n      if (toShow.length && toHide.length) {\n        toHide.prev().attr({\n          \"tabIndex\": -1,\n          \"aria-expanded\": \"false\"\n        });\n      } else if (toShow.length) {\n        this.headers.filter(function () {\n          return parseInt($(this).attr(\"tabIndex\"), 10) === 0;\n        }).attr(\"tabIndex\", -1);\n      }\n\n      toShow.attr(\"aria-hidden\", \"false\").prev().attr({\n        \"aria-selected\": \"true\",\n        \"aria-expanded\": \"true\",\n        tabIndex: 0\n      });\n    },\n    _animate: function _animate(toShow, toHide, data) {\n      var total,\n          easing,\n          duration,\n          that = this,\n          adjust = 0,\n          boxSizing = toShow.css(\"box-sizing\"),\n          down = toShow.length && (!toHide.length || toShow.index() < toHide.index()),\n          animate = this.options.animate || {},\n          options = down && animate.down || animate,\n          complete = function complete() {\n        that._toggleComplete(data);\n      };\n\n      if (typeof options === \"number\") {\n        duration = options;\n      }\n\n      if (typeof options === \"string\") {\n        easing = options;\n      } // fall back from options to animation in case of partial down settings\n\n\n      easing = easing || options.easing || animate.easing;\n      duration = duration || options.duration || animate.duration;\n\n      if (!toHide.length) {\n        return toShow.animate(this.showProps, duration, easing, complete);\n      }\n\n      if (!toShow.length) {\n        return toHide.animate(this.hideProps, duration, easing, complete);\n      }\n\n      total = toShow.show().outerHeight();\n      toHide.animate(this.hideProps, {\n        duration: duration,\n        easing: easing,\n        step: function step(now, fx) {\n          fx.now = Math.round(now);\n        }\n      });\n      toShow.hide().animate(this.showProps, {\n        duration: duration,\n        easing: easing,\n        complete: complete,\n        step: function step(now, fx) {\n          fx.now = Math.round(now);\n\n          if (fx.prop !== \"height\") {\n            if (boxSizing === \"content-box\") {\n              adjust += fx.now;\n            }\n          } else if (that.options.heightStyle !== \"content\") {\n            fx.now = Math.round(total - toHide.outerHeight() - adjust);\n            adjust = 0;\n          }\n        }\n      });\n    },\n    _toggleComplete: function _toggleComplete(data) {\n      var toHide = data.oldPanel;\n      toHide.removeClass(\"ui-accordion-content-active\").prev().removeClass(\"ui-corner-top\").addClass(\"ui-corner-all\"); // Work around for rendering bug in IE (#5421)\n\n      if (toHide.length) {\n        toHide.parent()[0].className = toHide.parent()[0].className;\n      }\n\n      this._trigger(\"activate\", null, data);\n    }\n  });\n  /*!\n   * jQuery UI Menu 1.11.4\n   * http://jqueryui.com\n   *\n   * Copyright jQuery Foundation and other contributors\n   * Released under the MIT license.\n   * http://jquery.org/license\n   *\n   * http://api.jqueryui.com/menu/\n   */\n\n  var menu = $.widget(\"ui.menu\", {\n    version: \"1.11.4\",\n    defaultElement: \"<ul>\",\n    delay: 300,\n    options: {\n      icons: {\n        submenu: \"ui-icon-carat-1-e\"\n      },\n      items: \"> *\",\n      menus: \"ul\",\n      position: {\n        my: \"left-1 top\",\n        at: \"right top\"\n      },\n      role: \"menu\",\n      // callbacks\n      blur: null,\n      focus: null,\n      select: null\n    },\n    _create: function _create() {\n      this.activeMenu = this.element; // Flag used to prevent firing of the click handler\n      // as the event bubbles up through nested menus\n\n      this.mouseHandled = false;\n      this.element.uniqueId().addClass(\"ui-menu ui-widget ui-widget-content\").toggleClass(\"ui-menu-icons\", !!this.element.find(\".ui-icon\").length).attr({\n        role: this.options.role,\n        tabIndex: 0\n      });\n\n      if (this.options.disabled) {\n        this.element.addClass(\"ui-state-disabled\").attr(\"aria-disabled\", \"true\");\n      }\n\n      this._on({\n        // Prevent focus from sticking to links inside menu after clicking\n        // them (focus should always stay on UL during navigation).\n        \"mousedown .ui-menu-item\": function mousedownUiMenuItem(event) {\n          event.preventDefault();\n        },\n        \"click .ui-menu-item\": function clickUiMenuItem(event) {\n          var target = $(event.target);\n\n          if (!this.mouseHandled && target.not(\".ui-state-disabled\").length) {\n            this.select(event); // Only set the mouseHandled flag if the event will bubble, see #9469.\n\n            if (!event.isPropagationStopped()) {\n              this.mouseHandled = true;\n            } // Open submenu on click\n\n\n            if (target.has(\".ui-menu\").length) {\n              this.expand(event);\n            } else if (!this.element.is(\":focus\") && $(this.document[0].activeElement).closest(\".ui-menu\").length) {\n              // Redirect focus to the menu\n              this.element.trigger(\"focus\", [true]); // If the active item is on the top level, let it stay active.\n              // Otherwise, blur the active item since it is no longer visible.\n\n              if (this.active && this.active.parents(\".ui-menu\").length === 1) {\n                clearTimeout(this.timer);\n              }\n            }\n          }\n        },\n        \"mouseenter .ui-menu-item\": function mouseenterUiMenuItem(event) {\n          // Ignore mouse events while typeahead is active, see #10458.\n          // Prevents focusing the wrong item when typeahead causes a scroll while the mouse\n          // is over an item in the menu\n          if (this.previousFilter) {\n            return;\n          }\n\n          var target = $(event.currentTarget); // Remove ui-state-active class from siblings of the newly focused menu item\n          // to avoid a jump caused by adjacent elements both having a class with a border\n\n          target.siblings(\".ui-state-active\").removeClass(\"ui-state-active\");\n          this.focus(event, target);\n        },\n        mouseleave: \"collapseAll\",\n        \"mouseleave .ui-menu\": \"collapseAll\",\n        focus: function focus(event, keepActiveItem) {\n          // If there's already an active item, keep it active\n          // If not, activate the first item\n          var item = this.active || this.element.find(this.options.items).eq(0);\n\n          if (!keepActiveItem) {\n            this.focus(event, item);\n          }\n        },\n        blur: function blur(event) {\n          this._delay(function () {\n            if (!$.contains(this.element[0], this.document[0].activeElement)) {\n              this.collapseAll(event);\n            }\n          });\n        },\n        keydown: \"_keydown\"\n      });\n\n      this.refresh(); // Clicks outside of a menu collapse any open menus\n\n      this._on(this.document, {\n        click: function click(event) {\n          if (this._closeOnDocumentClick(event)) {\n            this.collapseAll(event);\n          } // Reset the mouseHandled flag\n\n\n          this.mouseHandled = false;\n        }\n      });\n    },\n    _destroy: function _destroy() {\n      // Destroy (sub)menus\n      this.element.removeAttr(\"aria-activedescendant\").find(\".ui-menu\").addBack().removeClass(\"ui-menu ui-widget ui-widget-content ui-menu-icons ui-front\").removeAttr(\"role\").removeAttr(\"tabIndex\").removeAttr(\"aria-labelledby\").removeAttr(\"aria-expanded\").removeAttr(\"aria-hidden\").removeAttr(\"aria-disabled\").removeUniqueId().show(); // Destroy menu items\n\n      this.element.find(\".ui-menu-item\").removeClass(\"ui-menu-item\").removeAttr(\"role\").removeAttr(\"aria-disabled\").removeUniqueId().removeClass(\"ui-state-hover\").removeAttr(\"tabIndex\").removeAttr(\"role\").removeAttr(\"aria-haspopup\").children().each(function () {\n        var elem = $(this);\n\n        if (elem.data(\"ui-menu-submenu-carat\")) {\n          elem.remove();\n        }\n      }); // Destroy menu dividers\n\n      this.element.find(\".ui-menu-divider\").removeClass(\"ui-menu-divider ui-widget-content\");\n    },\n    _keydown: function _keydown(event) {\n      var match,\n          prev,\n          character,\n          skip,\n          preventDefault = true;\n\n      switch (event.keyCode) {\n        case $.ui.keyCode.PAGE_UP:\n          this.previousPage(event);\n          break;\n\n        case $.ui.keyCode.PAGE_DOWN:\n          this.nextPage(event);\n          break;\n\n        case $.ui.keyCode.HOME:\n          this._move(\"first\", \"first\", event);\n\n          break;\n\n        case $.ui.keyCode.END:\n          this._move(\"last\", \"last\", event);\n\n          break;\n\n        case $.ui.keyCode.UP:\n          this.previous(event);\n          break;\n\n        case $.ui.keyCode.DOWN:\n          this.next(event);\n          break;\n\n        case $.ui.keyCode.LEFT:\n          this.collapse(event);\n          break;\n\n        case $.ui.keyCode.RIGHT:\n          if (this.active && !this.active.is(\".ui-state-disabled\")) {\n            this.expand(event);\n          }\n\n          break;\n\n        case $.ui.keyCode.ENTER:\n        case $.ui.keyCode.SPACE:\n          this._activate(event);\n\n          break;\n\n        case $.ui.keyCode.ESCAPE:\n          this.collapse(event);\n          break;\n\n        default:\n          preventDefault = false;\n          prev = this.previousFilter || \"\";\n          character = String.fromCharCode(event.keyCode);\n          skip = false;\n          clearTimeout(this.filterTimer);\n\n          if (character === prev) {\n            skip = true;\n          } else {\n            character = prev + character;\n          }\n\n          match = this._filterMenuItems(character);\n          match = skip && match.index(this.active.next()) !== -1 ? this.active.nextAll(\".ui-menu-item\") : match; // If no matches on the current filter, reset to the last character pressed\n          // to move down the menu to the first item that starts with that character\n\n          if (!match.length) {\n            character = String.fromCharCode(event.keyCode);\n            match = this._filterMenuItems(character);\n          }\n\n          if (match.length) {\n            this.focus(event, match);\n            this.previousFilter = character;\n            this.filterTimer = this._delay(function () {\n              delete this.previousFilter;\n            }, 1000);\n          } else {\n            delete this.previousFilter;\n          }\n\n      }\n\n      if (preventDefault) {\n        event.preventDefault();\n      }\n    },\n    _activate: function _activate(event) {\n      if (!this.active.is(\".ui-state-disabled\")) {\n        if (this.active.is(\"[aria-haspopup='true']\")) {\n          this.expand(event);\n        } else {\n          this.select(event);\n        }\n      }\n    },\n    refresh: function refresh() {\n      var menus,\n          items,\n          that = this,\n          icon = this.options.icons.submenu,\n          submenus = this.element.find(this.options.menus);\n      this.element.toggleClass(\"ui-menu-icons\", !!this.element.find(\".ui-icon\").length); // Initialize nested menus\n\n      submenus.filter(\":not(.ui-menu)\").addClass(\"ui-menu ui-widget ui-widget-content ui-front\").hide().attr({\n        role: this.options.role,\n        \"aria-hidden\": \"true\",\n        \"aria-expanded\": \"false\"\n      }).each(function () {\n        var menu = $(this),\n            item = menu.parent(),\n            submenuCarat = $(\"<span>\").addClass(\"ui-menu-icon ui-icon \" + icon).data(\"ui-menu-submenu-carat\", true);\n        item.attr(\"aria-haspopup\", \"true\").prepend(submenuCarat);\n        menu.attr(\"aria-labelledby\", item.attr(\"id\"));\n      });\n      menus = submenus.add(this.element);\n      items = menus.find(this.options.items); // Initialize menu-items containing spaces and/or dashes only as dividers\n\n      items.not(\".ui-menu-item\").each(function () {\n        var item = $(this);\n\n        if (that._isDivider(item)) {\n          item.addClass(\"ui-widget-content ui-menu-divider\");\n        }\n      }); // Don't refresh list items that are already adapted\n\n      items.not(\".ui-menu-item, .ui-menu-divider\").addClass(\"ui-menu-item\").uniqueId().attr({\n        tabIndex: -1,\n        role: this._itemRole()\n      }); // Add aria-disabled attribute to any disabled menu item\n\n      items.filter(\".ui-state-disabled\").attr(\"aria-disabled\", \"true\"); // If the active item has been removed, blur the menu\n\n      if (this.active && !$.contains(this.element[0], this.active[0])) {\n        this.blur();\n      }\n    },\n    _itemRole: function _itemRole() {\n      return {\n        menu: \"menuitem\",\n        listbox: \"option\"\n      }[this.options.role];\n    },\n    _setOption: function _setOption(key, value) {\n      if (key === \"icons\") {\n        this.element.find(\".ui-menu-icon\").removeClass(this.options.icons.submenu).addClass(value.submenu);\n      }\n\n      if (key === \"disabled\") {\n        this.element.toggleClass(\"ui-state-disabled\", !!value).attr(\"aria-disabled\", value);\n      }\n\n      this._super(key, value);\n    },\n    focus: function focus(event, item) {\n      var nested, focused;\n      this.blur(event, event && event.type === \"focus\");\n\n      this._scrollIntoView(item);\n\n      this.active = item.first();\n      focused = this.active.addClass(\"ui-state-focus\").removeClass(\"ui-state-active\"); // Only update aria-activedescendant if there's a role\n      // otherwise we assume focus is managed elsewhere\n\n      if (this.options.role) {\n        this.element.attr(\"aria-activedescendant\", focused.attr(\"id\"));\n      } // Highlight active parent menu item, if any\n\n\n      this.active.parent().closest(\".ui-menu-item\").addClass(\"ui-state-active\");\n\n      if (event && event.type === \"keydown\") {\n        this._close();\n      } else {\n        this.timer = this._delay(function () {\n          this._close();\n        }, this.delay);\n      }\n\n      nested = item.children(\".ui-menu\");\n\n      if (nested.length && event && /^mouse/.test(event.type)) {\n        this._startOpening(nested);\n      }\n\n      this.activeMenu = item.parent();\n\n      this._trigger(\"focus\", event, {\n        item: item\n      });\n    },\n    _scrollIntoView: function _scrollIntoView(item) {\n      var borderTop, paddingTop, offset, scroll, elementHeight, itemHeight;\n\n      if (this._hasScroll()) {\n        borderTop = parseFloat($.css(this.activeMenu[0], \"borderTopWidth\")) || 0;\n        paddingTop = parseFloat($.css(this.activeMenu[0], \"paddingTop\")) || 0;\n        offset = item.offset().top - this.activeMenu.offset().top - borderTop - paddingTop;\n        scroll = this.activeMenu.scrollTop();\n        elementHeight = this.activeMenu.height();\n        itemHeight = item.outerHeight();\n\n        if (offset < 0) {\n          this.activeMenu.scrollTop(scroll + offset);\n        } else if (offset + itemHeight > elementHeight) {\n          this.activeMenu.scrollTop(scroll + offset - elementHeight + itemHeight);\n        }\n      }\n    },\n    blur: function blur(event, fromFocus) {\n      if (!fromFocus) {\n        clearTimeout(this.timer);\n      }\n\n      if (!this.active) {\n        return;\n      }\n\n      this.active.removeClass(\"ui-state-focus\");\n      this.active = null;\n\n      this._trigger(\"blur\", event, {\n        item: this.active\n      });\n    },\n    _startOpening: function _startOpening(submenu) {\n      clearTimeout(this.timer); // Don't open if already open fixes a Firefox bug that caused a .5 pixel\n      // shift in the submenu position when mousing over the carat icon\n\n      if (submenu.attr(\"aria-hidden\") !== \"true\") {\n        return;\n      }\n\n      this.timer = this._delay(function () {\n        this._close();\n\n        this._open(submenu);\n      }, this.delay);\n    },\n    _open: function _open(submenu) {\n      var position = $.extend({\n        of: this.active\n      }, this.options.position);\n      clearTimeout(this.timer);\n      this.element.find(\".ui-menu\").not(submenu.parents(\".ui-menu\")).hide().attr(\"aria-hidden\", \"true\");\n      submenu.show().removeAttr(\"aria-hidden\").attr(\"aria-expanded\", \"true\").position(position);\n    },\n    collapseAll: function collapseAll(event, all) {\n      clearTimeout(this.timer);\n      this.timer = this._delay(function () {\n        // If we were passed an event, look for the submenu that contains the event\n        var currentMenu = all ? this.element : $(event && event.target).closest(this.element.find(\".ui-menu\")); // If we found no valid submenu ancestor, use the main menu to close all sub menus anyway\n\n        if (!currentMenu.length) {\n          currentMenu = this.element;\n        }\n\n        this._close(currentMenu);\n\n        this.blur(event);\n        this.activeMenu = currentMenu;\n      }, this.delay);\n    },\n    // With no arguments, closes the currently active menu - if nothing is active\n    // it closes all menus.  If passed an argument, it will search for menus BELOW\n    _close: function _close(startMenu) {\n      if (!startMenu) {\n        startMenu = this.active ? this.active.parent() : this.element;\n      }\n\n      startMenu.find(\".ui-menu\").hide().attr(\"aria-hidden\", \"true\").attr(\"aria-expanded\", \"false\").end().find(\".ui-state-active\").not(\".ui-state-focus\").removeClass(\"ui-state-active\");\n    },\n    _closeOnDocumentClick: function _closeOnDocumentClick(event) {\n      return !$(event.target).closest(\".ui-menu\").length;\n    },\n    _isDivider: function _isDivider(item) {\n      // Match hyphen, em dash, en dash\n      return !/[^\\-\\u2014\\u2013\\s]/.test(item.text());\n    },\n    collapse: function collapse(event) {\n      var newItem = this.active && this.active.parent().closest(\".ui-menu-item\", this.element);\n\n      if (newItem && newItem.length) {\n        this._close();\n\n        this.focus(event, newItem);\n      }\n    },\n    expand: function expand(event) {\n      var newItem = this.active && this.active.children(\".ui-menu \").find(this.options.items).first();\n\n      if (newItem && newItem.length) {\n        this._open(newItem.parent()); // Delay so Firefox will not hide activedescendant change in expanding submenu from AT\n\n\n        this._delay(function () {\n          this.focus(event, newItem);\n        });\n      }\n    },\n    next: function next(event) {\n      this._move(\"next\", \"first\", event);\n    },\n    previous: function previous(event) {\n      this._move(\"prev\", \"last\", event);\n    },\n    isFirstItem: function isFirstItem() {\n      return this.active && !this.active.prevAll(\".ui-menu-item\").length;\n    },\n    isLastItem: function isLastItem() {\n      return this.active && !this.active.nextAll(\".ui-menu-item\").length;\n    },\n    _move: function _move(direction, filter, event) {\n      var next;\n\n      if (this.active) {\n        if (direction === \"first\" || direction === \"last\") {\n          next = this.active[direction === \"first\" ? \"prevAll\" : \"nextAll\"](\".ui-menu-item\").eq(-1);\n        } else {\n          next = this.active[direction + \"All\"](\".ui-menu-item\").eq(0);\n        }\n      }\n\n      if (!next || !next.length || !this.active) {\n        next = this.activeMenu.find(this.options.items)[filter]();\n      }\n\n      this.focus(event, next);\n    },\n    nextPage: function nextPage(event) {\n      var item, base, height;\n\n      if (!this.active) {\n        this.next(event);\n        return;\n      }\n\n      if (this.isLastItem()) {\n        return;\n      }\n\n      if (this._hasScroll()) {\n        base = this.active.offset().top;\n        height = this.element.height();\n        this.active.nextAll(\".ui-menu-item\").each(function () {\n          item = $(this);\n          return item.offset().top - base - height < 0;\n        });\n        this.focus(event, item);\n      } else {\n        this.focus(event, this.activeMenu.find(this.options.items)[!this.active ? \"first\" : \"last\"]());\n      }\n    },\n    previousPage: function previousPage(event) {\n      var item, base, height;\n\n      if (!this.active) {\n        this.next(event);\n        return;\n      }\n\n      if (this.isFirstItem()) {\n        return;\n      }\n\n      if (this._hasScroll()) {\n        base = this.active.offset().top;\n        height = this.element.height();\n        this.active.prevAll(\".ui-menu-item\").each(function () {\n          item = $(this);\n          return item.offset().top - base + height > 0;\n        });\n        this.focus(event, item);\n      } else {\n        this.focus(event, this.activeMenu.find(this.options.items).first());\n      }\n    },\n    _hasScroll: function _hasScroll() {\n      return this.element.outerHeight() < this.element.prop(\"scrollHeight\");\n    },\n    select: function select(event) {\n      // TODO: It should never be possible to not have an active item at this\n      // point, but the tests don't trigger mouseenter before click.\n      this.active = this.active || $(event.target).closest(\".ui-menu-item\");\n      var ui = {\n        item: this.active\n      };\n\n      if (!this.active.has(\".ui-menu\").length) {\n        this.collapseAll(event, true);\n      }\n\n      this._trigger(\"select\", event, ui);\n    },\n    _filterMenuItems: function _filterMenuItems(character) {\n      var escapedCharacter = character.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g, \"\\\\$&\"),\n          regex = new RegExp(\"^\" + escapedCharacter, \"i\");\n      return this.activeMenu.find(this.options.items) // Only match on items, not dividers or other content (#10571)\n      .filter(\".ui-menu-item\").filter(function () {\n        return regex.test($.trim($(this).text()));\n      });\n    }\n  });\n  /*!\n   * jQuery UI Autocomplete 1.11.4\n   * http://jqueryui.com\n   *\n   * Copyright jQuery Foundation and other contributors\n   * Released under the MIT license.\n   * http://jquery.org/license\n   *\n   * http://api.jqueryui.com/autocomplete/\n   */\n\n  $.widget(\"ui.autocomplete\", {\n    version: \"1.11.4\",\n    defaultElement: \"<input>\",\n    options: {\n      appendTo: null,\n      autoFocus: false,\n      delay: 300,\n      minLength: 1,\n      position: {\n        my: \"left top\",\n        at: \"left bottom\",\n        collision: \"none\"\n      },\n      source: null,\n      // callbacks\n      change: null,\n      close: null,\n      focus: null,\n      open: null,\n      response: null,\n      search: null,\n      select: null\n    },\n    requestIndex: 0,\n    pending: 0,\n    _create: function _create() {\n      // Some browsers only repeat keydown events, not keypress events,\n      // so we use the suppressKeyPress flag to determine if we've already\n      // handled the keydown event. #7269\n      // Unfortunately the code for & in keypress is the same as the up arrow,\n      // so we use the suppressKeyPressRepeat flag to avoid handling keypress\n      // events when we know the keydown event was used to modify the\n      // search term. #7799\n      var suppressKeyPress,\n          suppressKeyPressRepeat,\n          suppressInput,\n          nodeName = this.element[0].nodeName.toLowerCase(),\n          isTextarea = nodeName === \"textarea\",\n          isInput = nodeName === \"input\";\n      this.isMultiLine = // Textareas are always multi-line\n      isTextarea ? true : // Inputs are always single-line, even if inside a contentEditable element\n      // IE also treats inputs as contentEditable\n      isInput ? false : // All other element types are determined by whether or not they're contentEditable\n      this.element.prop(\"isContentEditable\");\n      this.valueMethod = this.element[isTextarea || isInput ? \"val\" : \"text\"];\n      this.isNewMenu = true;\n      this.element.addClass(\"ui-autocomplete-input\").attr(\"autocomplete\", \"off\");\n\n      this._on(this.element, {\n        keydown: function keydown(event) {\n          if (this.element.prop(\"readOnly\")) {\n            suppressKeyPress = true;\n            suppressInput = true;\n            suppressKeyPressRepeat = true;\n            return;\n          }\n\n          suppressKeyPress = false;\n          suppressInput = false;\n          suppressKeyPressRepeat = false;\n          var keyCode = $.ui.keyCode;\n\n          switch (event.keyCode) {\n            case keyCode.PAGE_UP:\n              suppressKeyPress = true;\n\n              this._move(\"previousPage\", event);\n\n              break;\n\n            case keyCode.PAGE_DOWN:\n              suppressKeyPress = true;\n\n              this._move(\"nextPage\", event);\n\n              break;\n\n            case keyCode.UP:\n              suppressKeyPress = true;\n\n              this._keyEvent(\"previous\", event);\n\n              break;\n\n            case keyCode.DOWN:\n              suppressKeyPress = true;\n\n              this._keyEvent(\"next\", event);\n\n              break;\n\n            case keyCode.ENTER:\n              // when menu is open and has focus\n              if (this.menu.active) {\n                // #6055 - Opera still allows the keypress to occur\n                // which causes forms to submit\n                suppressKeyPress = true;\n                event.preventDefault();\n                this.menu.select(event);\n              }\n\n              break;\n\n            case keyCode.TAB:\n              if (this.menu.active) {\n                this.menu.select(event);\n              }\n\n              break;\n\n            case keyCode.ESCAPE:\n              if (this.menu.element.is(\":visible\")) {\n                if (!this.isMultiLine) {\n                  this._value(this.term);\n                }\n\n                this.close(event); // Different browsers have different default behavior for escape\n                // Single press can mean undo or clear\n                // Double press in IE means clear the whole form\n\n                event.preventDefault();\n              }\n\n              break;\n\n            default:\n              suppressKeyPressRepeat = true; // search timeout should be triggered before the input value is changed\n\n              this._searchTimeout(event);\n\n              break;\n          }\n        },\n        keypress: function keypress(event) {\n          if (suppressKeyPress) {\n            suppressKeyPress = false;\n\n            if (!this.isMultiLine || this.menu.element.is(\":visible\")) {\n              event.preventDefault();\n            }\n\n            return;\n          }\n\n          if (suppressKeyPressRepeat) {\n            return;\n          } // replicate some key handlers to allow them to repeat in Firefox and Opera\n\n\n          var keyCode = $.ui.keyCode;\n\n          switch (event.keyCode) {\n            case keyCode.PAGE_UP:\n              this._move(\"previousPage\", event);\n\n              break;\n\n            case keyCode.PAGE_DOWN:\n              this._move(\"nextPage\", event);\n\n              break;\n\n            case keyCode.UP:\n              this._keyEvent(\"previous\", event);\n\n              break;\n\n            case keyCode.DOWN:\n              this._keyEvent(\"next\", event);\n\n              break;\n          }\n        },\n        input: function input(event) {\n          if (suppressInput) {\n            suppressInput = false;\n            event.preventDefault();\n            return;\n          }\n\n          this._searchTimeout(event);\n        },\n        focus: function focus() {\n          this.selectedItem = null;\n          this.previous = this._value();\n        },\n        blur: function blur(event) {\n          if (this.cancelBlur) {\n            delete this.cancelBlur;\n            return;\n          }\n\n          clearTimeout(this.searching);\n          this.close(event);\n\n          this._change(event);\n        }\n      });\n\n      this._initSource();\n\n      this.menu = $(\"<ul>\").addClass(\"ui-autocomplete ui-front\").appendTo(this._appendTo()).menu({\n        // disable ARIA support, the live region takes care of that\n        role: null\n      }).hide().menu(\"instance\");\n\n      this._on(this.menu.element, {\n        mousedown: function mousedown(event) {\n          // prevent moving focus out of the text field\n          event.preventDefault(); // IE doesn't prevent moving focus even with event.preventDefault()\n          // so we set a flag to know when we should ignore the blur event\n\n          this.cancelBlur = true;\n\n          this._delay(function () {\n            delete this.cancelBlur;\n          }); // clicking on the scrollbar causes focus to shift to the body\n          // but we can't detect a mouseup or a click immediately afterward\n          // so we have to track the next mousedown and close the menu if\n          // the user clicks somewhere outside of the autocomplete\n\n\n          var menuElement = this.menu.element[0];\n\n          if (!$(event.target).closest(\".ui-menu-item\").length) {\n            this._delay(function () {\n              var that = this;\n              this.document.one(\"mousedown\", function (event) {\n                if (event.target !== that.element[0] && event.target !== menuElement && !$.contains(menuElement, event.target)) {\n                  that.close();\n                }\n              });\n            });\n          }\n        },\n        menufocus: function menufocus(event, ui) {\n          var label, item; // support: Firefox\n          // Prevent accidental activation of menu items in Firefox (#7024 #9118)\n\n          if (this.isNewMenu) {\n            this.isNewMenu = false;\n\n            if (event.originalEvent && /^mouse/.test(event.originalEvent.type)) {\n              this.menu.blur();\n              this.document.one(\"mousemove\", function () {\n                $(event.target).trigger(event.originalEvent);\n              });\n              return;\n            }\n          }\n\n          item = ui.item.data(\"ui-autocomplete-item\");\n\n          if (false !== this._trigger(\"focus\", event, {\n            item: item\n          })) {\n            // use value to match what will end up in the input, if it was a key event\n            if (event.originalEvent && /^key/.test(event.originalEvent.type)) {\n              this._value(item.value);\n            }\n          } // Announce the value in the liveRegion\n\n\n          label = ui.item.attr(\"aria-label\") || item.value;\n\n          if (label && $.trim(label).length) {\n            this.liveRegion.children().hide();\n            $(\"<div>\").text(label).appendTo(this.liveRegion);\n          }\n        },\n        menuselect: function menuselect(event, ui) {\n          var item = ui.item.data(\"ui-autocomplete-item\"),\n              previous = this.previous; // only trigger when focus was lost (click on menu)\n\n          if (this.element[0] !== this.document[0].activeElement) {\n            this.element.focus();\n            this.previous = previous; // #6109 - IE triggers two focus events and the second\n            // is asynchronous, so we need to reset the previous\n            // term synchronously and asynchronously :-(\n\n            this._delay(function () {\n              this.previous = previous;\n              this.selectedItem = item;\n            });\n          }\n\n          if (false !== this._trigger(\"select\", event, {\n            item: item\n          })) {\n            this._value(item.value);\n          } // reset the term after the select event\n          // this allows custom select handling to work properly\n\n\n          this.term = this._value();\n          this.close(event);\n          this.selectedItem = item;\n        }\n      });\n\n      this.liveRegion = $(\"<span>\", {\n        role: \"status\",\n        \"aria-live\": \"assertive\",\n        \"aria-relevant\": \"additions\"\n      }).addClass(\"ui-helper-hidden-accessible\").appendTo(this.document[0].body); // turning off autocomplete prevents the browser from remembering the\n      // value when navigating through history, so we re-enable autocomplete\n      // if the page is unloaded before the widget is destroyed. #7790\n\n      this._on(this.window, {\n        beforeunload: function beforeunload() {\n          this.element.removeAttr(\"autocomplete\");\n        }\n      });\n    },\n    _destroy: function _destroy() {\n      clearTimeout(this.searching);\n      this.element.removeClass(\"ui-autocomplete-input\").removeAttr(\"autocomplete\");\n      this.menu.element.remove();\n      this.liveRegion.remove();\n    },\n    _setOption: function _setOption(key, value) {\n      this._super(key, value);\n\n      if (key === \"source\") {\n        this._initSource();\n      }\n\n      if (key === \"appendTo\") {\n        this.menu.element.appendTo(this._appendTo());\n      }\n\n      if (key === \"disabled\" && value && this.xhr) {\n        this.xhr.abort();\n      }\n    },\n    _appendTo: function _appendTo() {\n      var element = this.options.appendTo;\n\n      if (element) {\n        element = element.jquery || element.nodeType ? $(element) : this.document.find(element).eq(0);\n      }\n\n      if (!element || !element[0]) {\n        element = this.element.closest(\".ui-front\");\n      }\n\n      if (!element.length) {\n        element = this.document[0].body;\n      }\n\n      return element;\n    },\n    _initSource: function _initSource() {\n      var array,\n          url,\n          that = this;\n\n      if ($.isArray(this.options.source)) {\n        array = this.options.source;\n\n        this.source = function (request, response) {\n          response($.ui.autocomplete.filter(array, request.term));\n        };\n      } else if (typeof this.options.source === \"string\") {\n        url = this.options.source;\n\n        this.source = function (request, response) {\n          if (that.xhr) {\n            that.xhr.abort();\n          }\n\n          that.xhr = $.ajax({\n            url: url,\n            data: request,\n            dataType: \"json\",\n            success: function success(data) {\n              response(data);\n            },\n            error: function error() {\n              response([]);\n            }\n          });\n        };\n      } else {\n        this.source = this.options.source;\n      }\n    },\n    _searchTimeout: function _searchTimeout(event) {\n      clearTimeout(this.searching);\n      this.searching = this._delay(function () {\n        // Search if the value has changed, or if the user retypes the same value (see #7434)\n        var equalValues = this.term === this._value(),\n            menuVisible = this.menu.element.is(\":visible\"),\n            modifierKey = event.altKey || event.ctrlKey || event.metaKey || event.shiftKey;\n\n        if (!equalValues || equalValues && !menuVisible && !modifierKey) {\n          this.selectedItem = null;\n          this.search(null, event);\n        }\n      }, this.options.delay);\n    },\n    search: function search(value, event) {\n      value = value != null ? value : this._value(); // always save the actual value, not the one passed as an argument\n\n      this.term = this._value();\n\n      if (value.length < this.options.minLength) {\n        return this.close(event);\n      }\n\n      if (this._trigger(\"search\", event) === false) {\n        return;\n      }\n\n      return this._search(value);\n    },\n    _search: function _search(value) {\n      this.pending++;\n      this.element.addClass(\"ui-autocomplete-loading\");\n      this.cancelSearch = false;\n      this.source({\n        term: value\n      }, this._response());\n    },\n    _response: function _response() {\n      var index = ++this.requestIndex;\n      return $.proxy(function (content) {\n        if (index === this.requestIndex) {\n          this.__response(content);\n        }\n\n        this.pending--;\n\n        if (!this.pending) {\n          this.element.removeClass(\"ui-autocomplete-loading\");\n        }\n      }, this);\n    },\n    __response: function __response(content) {\n      if (content) {\n        content = this._normalize(content);\n      }\n\n      this._trigger(\"response\", null, {\n        content: content\n      });\n\n      if (!this.options.disabled && content && content.length && !this.cancelSearch) {\n        this._suggest(content);\n\n        this._trigger(\"open\");\n      } else {\n        // use ._close() instead of .close() so we don't cancel future searches\n        this._close();\n      }\n    },\n    close: function close(event) {\n      this.cancelSearch = true;\n\n      this._close(event);\n    },\n    _close: function _close(event) {\n      if (this.menu.element.is(\":visible\")) {\n        this.menu.element.hide();\n        this.menu.blur();\n        this.isNewMenu = true;\n\n        this._trigger(\"close\", event);\n      }\n    },\n    _change: function _change(event) {\n      if (this.previous !== this._value()) {\n        this._trigger(\"change\", event, {\n          item: this.selectedItem\n        });\n      }\n    },\n    _normalize: function _normalize(items) {\n      // assume all items have the right format when the first item is complete\n      if (items.length && items[0].label && items[0].value) {\n        return items;\n      }\n\n      return $.map(items, function (item) {\n        if (typeof item === \"string\") {\n          return {\n            label: item,\n            value: item\n          };\n        }\n\n        return $.extend({}, item, {\n          label: item.label || item.value,\n          value: item.value || item.label\n        });\n      });\n    },\n    _suggest: function _suggest(items) {\n      var ul = this.menu.element.empty();\n\n      this._renderMenu(ul, items);\n\n      this.isNewMenu = true;\n      this.menu.refresh(); // size and position menu\n\n      ul.show();\n\n      this._resizeMenu();\n\n      ul.position($.extend({\n        of: this.element\n      }, this.options.position));\n\n      if (this.options.autoFocus) {\n        this.menu.next();\n      }\n    },\n    _resizeMenu: function _resizeMenu() {\n      var ul = this.menu.element;\n      ul.outerWidth(Math.max( // Firefox wraps long text (possibly a rounding bug)\n      // so we add 1px to avoid the wrapping (#7513)\n      ul.width(\"\").outerWidth() + 1, this.element.outerWidth()));\n    },\n    _renderMenu: function _renderMenu(ul, items) {\n      var that = this;\n      $.each(items, function (index, item) {\n        that._renderItemData(ul, item);\n      });\n    },\n    _renderItemData: function _renderItemData(ul, item) {\n      return this._renderItem(ul, item).data(\"ui-autocomplete-item\", item);\n    },\n    _renderItem: function _renderItem(ul, item) {\n      return $(\"<li>\").text(item.label).appendTo(ul);\n    },\n    _move: function _move(direction, event) {\n      if (!this.menu.element.is(\":visible\")) {\n        this.search(null, event);\n        return;\n      }\n\n      if (this.menu.isFirstItem() && /^previous/.test(direction) || this.menu.isLastItem() && /^next/.test(direction)) {\n        if (!this.isMultiLine) {\n          this._value(this.term);\n        }\n\n        this.menu.blur();\n        return;\n      }\n\n      this.menu[direction](event);\n    },\n    widget: function widget() {\n      return this.menu.element;\n    },\n    _value: function _value() {\n      return this.valueMethod.apply(this.element, arguments);\n    },\n    _keyEvent: function _keyEvent(keyEvent, event) {\n      if (!this.isMultiLine || this.menu.element.is(\":visible\")) {\n        this._move(keyEvent, event); // prevents moving cursor to beginning/end of the text field in some browsers\n\n\n        event.preventDefault();\n      }\n    }\n  });\n  $.extend($.ui.autocomplete, {\n    escapeRegex: function escapeRegex(value) {\n      return value.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g, \"\\\\$&\");\n    },\n    filter: function filter(array, term) {\n      var matcher = new RegExp($.ui.autocomplete.escapeRegex(term), \"i\");\n      return $.grep(array, function (value) {\n        return matcher.test(value.label || value.value || value);\n      });\n    }\n  }); // live region extension, adding a `messages` option\n  // NOTE: This is an experimental API. We are still investigating\n  // a full solution for string manipulation and internationalization.\n\n  $.widget(\"ui.autocomplete\", $.ui.autocomplete, {\n    options: {\n      messages: {\n        noResults: \"No search results.\",\n        results: function results(amount) {\n          return amount + (amount > 1 ? \" results are\" : \" result is\") + \" available, use up and down arrow keys to navigate.\";\n        }\n      }\n    },\n    __response: function __response(content) {\n      var message;\n\n      this._superApply(arguments);\n\n      if (this.options.disabled || this.cancelSearch) {\n        return;\n      }\n\n      if (content && content.length) {\n        message = this.options.messages.results(content.length);\n      } else {\n        message = this.options.messages.noResults;\n      }\n\n      this.liveRegion.children().hide();\n      $(\"<div>\").text(message).appendTo(this.liveRegion);\n    }\n  });\n  var autocomplete = $.ui.autocomplete;\n  /*!\n   * jQuery UI Button 1.11.4\n   * http://jqueryui.com\n   *\n   * Copyright jQuery Foundation and other contributors\n   * Released under the MIT license.\n   * http://jquery.org/license\n   *\n   * http://api.jqueryui.com/button/\n   */\n\n  var lastActive,\n      baseClasses = \"ui-button ui-widget ui-state-default ui-corner-all\",\n      typeClasses = \"ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only\",\n      formResetHandler = function formResetHandler() {\n    var form = $(this);\n    setTimeout(function () {\n      form.find(\":ui-button\").button(\"refresh\");\n    }, 1);\n  },\n      radioGroup = function radioGroup(radio) {\n    var name = radio.name,\n        form = radio.form,\n        radios = $([]);\n\n    if (name) {\n      name = name.replace(/'/g, \"\\\\'\");\n\n      if (form) {\n        radios = $(form).find(\"[name='\" + name + \"'][type=radio]\");\n      } else {\n        radios = $(\"[name='\" + name + \"'][type=radio]\", radio.ownerDocument).filter(function () {\n          return !this.form;\n        });\n      }\n    }\n\n    return radios;\n  };\n\n  $.widget(\"ui.button\", {\n    version: \"1.11.4\",\n    defaultElement: \"<button>\",\n    options: {\n      disabled: null,\n      text: true,\n      label: null,\n      icons: {\n        primary: null,\n        secondary: null\n      }\n    },\n    _create: function _create() {\n      this.element.closest(\"form\").unbind(\"reset\" + this.eventNamespace).bind(\"reset\" + this.eventNamespace, formResetHandler);\n\n      if (typeof this.options.disabled !== \"boolean\") {\n        this.options.disabled = !!this.element.prop(\"disabled\");\n      } else {\n        this.element.prop(\"disabled\", this.options.disabled);\n      }\n\n      this._determineButtonType();\n\n      this.hasTitle = !!this.buttonElement.attr(\"title\");\n      var that = this,\n          options = this.options,\n          toggleButton = this.type === \"checkbox\" || this.type === \"radio\",\n          activeClass = !toggleButton ? \"ui-state-active\" : \"\";\n\n      if (options.label === null) {\n        options.label = this.type === \"input\" ? this.buttonElement.val() : this.buttonElement.html();\n      }\n\n      this._hoverable(this.buttonElement);\n\n      this.buttonElement.addClass(baseClasses).attr(\"role\", \"button\").bind(\"mouseenter\" + this.eventNamespace, function () {\n        if (options.disabled) {\n          return;\n        }\n\n        if (this === lastActive) {\n          $(this).addClass(\"ui-state-active\");\n        }\n      }).bind(\"mouseleave\" + this.eventNamespace, function () {\n        if (options.disabled) {\n          return;\n        }\n\n        $(this).removeClass(activeClass);\n      }).bind(\"click\" + this.eventNamespace, function (event) {\n        if (options.disabled) {\n          event.preventDefault();\n          event.stopImmediatePropagation();\n        }\n      }); // Can't use _focusable() because the element that receives focus\n      // and the element that gets the ui-state-focus class are different\n\n      this._on({\n        focus: function focus() {\n          this.buttonElement.addClass(\"ui-state-focus\");\n        },\n        blur: function blur() {\n          this.buttonElement.removeClass(\"ui-state-focus\");\n        }\n      });\n\n      if (toggleButton) {\n        this.element.bind(\"change\" + this.eventNamespace, function () {\n          that.refresh();\n        });\n      }\n\n      if (this.type === \"checkbox\") {\n        this.buttonElement.bind(\"click\" + this.eventNamespace, function () {\n          if (options.disabled) {\n            return false;\n          }\n        });\n      } else if (this.type === \"radio\") {\n        this.buttonElement.bind(\"click\" + this.eventNamespace, function () {\n          if (options.disabled) {\n            return false;\n          }\n\n          $(this).addClass(\"ui-state-active\");\n          that.buttonElement.attr(\"aria-pressed\", \"true\");\n          var radio = that.element[0];\n          radioGroup(radio).not(radio).map(function () {\n            return $(this).button(\"widget\")[0];\n          }).removeClass(\"ui-state-active\").attr(\"aria-pressed\", \"false\");\n        });\n      } else {\n        this.buttonElement.bind(\"mousedown\" + this.eventNamespace, function () {\n          if (options.disabled) {\n            return false;\n          }\n\n          $(this).addClass(\"ui-state-active\");\n          lastActive = this;\n          that.document.one(\"mouseup\", function () {\n            lastActive = null;\n          });\n        }).bind(\"mouseup\" + this.eventNamespace, function () {\n          if (options.disabled) {\n            return false;\n          }\n\n          $(this).removeClass(\"ui-state-active\");\n        }).bind(\"keydown\" + this.eventNamespace, function (event) {\n          if (options.disabled) {\n            return false;\n          }\n\n          if (event.keyCode === $.ui.keyCode.SPACE || event.keyCode === $.ui.keyCode.ENTER) {\n            $(this).addClass(\"ui-state-active\");\n          }\n        }) // see #8559, we bind to blur here in case the button element loses\n        // focus between keydown and keyup, it would be left in an \"active\" state\n        .bind(\"keyup\" + this.eventNamespace + \" blur\" + this.eventNamespace, function () {\n          $(this).removeClass(\"ui-state-active\");\n        });\n\n        if (this.buttonElement.is(\"a\")) {\n          this.buttonElement.keyup(function (event) {\n            if (event.keyCode === $.ui.keyCode.SPACE) {\n              // TODO pass through original event correctly (just as 2nd argument doesn't work)\n              $(this).click();\n            }\n          });\n        }\n      }\n\n      this._setOption(\"disabled\", options.disabled);\n\n      this._resetButton();\n    },\n    _determineButtonType: function _determineButtonType() {\n      var ancestor, labelSelector, checked;\n\n      if (this.element.is(\"[type=checkbox]\")) {\n        this.type = \"checkbox\";\n      } else if (this.element.is(\"[type=radio]\")) {\n        this.type = \"radio\";\n      } else if (this.element.is(\"input\")) {\n        this.type = \"input\";\n      } else {\n        this.type = \"button\";\n      }\n\n      if (this.type === \"checkbox\" || this.type === \"radio\") {\n        // we don't search against the document in case the element\n        // is disconnected from the DOM\n        ancestor = this.element.parents().last();\n        labelSelector = \"label[for='\" + this.element.attr(\"id\") + \"']\";\n        this.buttonElement = ancestor.find(labelSelector);\n\n        if (!this.buttonElement.length) {\n          ancestor = ancestor.length ? ancestor.siblings() : this.element.siblings();\n          this.buttonElement = ancestor.filter(labelSelector);\n\n          if (!this.buttonElement.length) {\n            this.buttonElement = ancestor.find(labelSelector);\n          }\n        }\n\n        this.element.addClass(\"ui-helper-hidden-accessible\");\n        checked = this.element.is(\":checked\");\n\n        if (checked) {\n          this.buttonElement.addClass(\"ui-state-active\");\n        }\n\n        this.buttonElement.prop(\"aria-pressed\", checked);\n      } else {\n        this.buttonElement = this.element;\n      }\n    },\n    widget: function widget() {\n      return this.buttonElement;\n    },\n    _destroy: function _destroy() {\n      this.element.removeClass(\"ui-helper-hidden-accessible\");\n      this.buttonElement.removeClass(baseClasses + \" ui-state-active \" + typeClasses).removeAttr(\"role\").removeAttr(\"aria-pressed\").html(this.buttonElement.find(\".ui-button-text\").html());\n\n      if (!this.hasTitle) {\n        this.buttonElement.removeAttr(\"title\");\n      }\n    },\n    _setOption: function _setOption(key, value) {\n      this._super(key, value);\n\n      if (key === \"disabled\") {\n        this.widget().toggleClass(\"ui-state-disabled\", !!value);\n        this.element.prop(\"disabled\", !!value);\n\n        if (value) {\n          if (this.type === \"checkbox\" || this.type === \"radio\") {\n            this.buttonElement.removeClass(\"ui-state-focus\");\n          } else {\n            this.buttonElement.removeClass(\"ui-state-focus ui-state-active\");\n          }\n        }\n\n        return;\n      }\n\n      this._resetButton();\n    },\n    refresh: function refresh() {\n      //See #8237 & #8828\n      var isDisabled = this.element.is(\"input, button\") ? this.element.is(\":disabled\") : this.element.hasClass(\"ui-button-disabled\");\n\n      if (isDisabled !== this.options.disabled) {\n        this._setOption(\"disabled\", isDisabled);\n      }\n\n      if (this.type === \"radio\") {\n        radioGroup(this.element[0]).each(function () {\n          if ($(this).is(\":checked\")) {\n            $(this).button(\"widget\").addClass(\"ui-state-active\").attr(\"aria-pressed\", \"true\");\n          } else {\n            $(this).button(\"widget\").removeClass(\"ui-state-active\").attr(\"aria-pressed\", \"false\");\n          }\n        });\n      } else if (this.type === \"checkbox\") {\n        if (this.element.is(\":checked\")) {\n          this.buttonElement.addClass(\"ui-state-active\").attr(\"aria-pressed\", \"true\");\n        } else {\n          this.buttonElement.removeClass(\"ui-state-active\").attr(\"aria-pressed\", \"false\");\n        }\n      }\n    },\n    _resetButton: function _resetButton() {\n      if (this.type === \"input\") {\n        if (this.options.label) {\n          this.element.val(this.options.label);\n        }\n\n        return;\n      }\n\n      var buttonElement = this.buttonElement.removeClass(typeClasses),\n          buttonText = $(\"<span></span>\", this.document[0]).addClass(\"ui-button-text\").html(this.options.label).appendTo(buttonElement.empty()).text(),\n          icons = this.options.icons,\n          multipleIcons = icons.primary && icons.secondary,\n          buttonClasses = [];\n\n      if (icons.primary || icons.secondary) {\n        if (this.options.text) {\n          buttonClasses.push(\"ui-button-text-icon\" + (multipleIcons ? \"s\" : icons.primary ? \"-primary\" : \"-secondary\"));\n        }\n\n        if (icons.primary) {\n          buttonElement.prepend(\"<span class='ui-button-icon-primary ui-icon \" + icons.primary + \"'></span>\");\n        }\n\n        if (icons.secondary) {\n          buttonElement.append(\"<span class='ui-button-icon-secondary ui-icon \" + icons.secondary + \"'></span>\");\n        }\n\n        if (!this.options.text) {\n          buttonClasses.push(multipleIcons ? \"ui-button-icons-only\" : \"ui-button-icon-only\");\n\n          if (!this.hasTitle) {\n            buttonElement.attr(\"title\", $.trim(buttonText));\n          }\n        }\n      } else {\n        buttonClasses.push(\"ui-button-text-only\");\n      }\n\n      buttonElement.addClass(buttonClasses.join(\" \"));\n    }\n  });\n  $.widget(\"ui.buttonset\", {\n    version: \"1.11.4\",\n    options: {\n      items: \"button, input[type=button], input[type=submit], input[type=reset], input[type=checkbox], input[type=radio], a, :data(ui-button)\"\n    },\n    _create: function _create() {\n      this.element.addClass(\"ui-buttonset\");\n    },\n    _init: function _init() {\n      this.refresh();\n    },\n    _setOption: function _setOption(key, value) {\n      if (key === \"disabled\") {\n        this.buttons.button(\"option\", key, value);\n      }\n\n      this._super(key, value);\n    },\n    refresh: function refresh() {\n      var rtl = this.element.css(\"direction\") === \"rtl\",\n          allButtons = this.element.find(this.options.items),\n          existingButtons = allButtons.filter(\":ui-button\"); // Initialize new buttons\n\n      allButtons.not(\":ui-button\").button(); // Refresh existing buttons\n\n      existingButtons.button(\"refresh\");\n      this.buttons = allButtons.map(function () {\n        return $(this).button(\"widget\")[0];\n      }).removeClass(\"ui-corner-all ui-corner-left ui-corner-right\").filter(\":first\").addClass(rtl ? \"ui-corner-right\" : \"ui-corner-left\").end().filter(\":last\").addClass(rtl ? \"ui-corner-left\" : \"ui-corner-right\").end().end();\n    },\n    _destroy: function _destroy() {\n      this.element.removeClass(\"ui-buttonset\");\n      this.buttons.map(function () {\n        return $(this).button(\"widget\")[0];\n      }).removeClass(\"ui-corner-left ui-corner-right\").end().button(\"destroy\");\n    }\n  });\n  var button = $.ui.button;\n  /*!\n   * jQuery UI Datepicker 1.11.4\n   * http://jqueryui.com\n   *\n   * Copyright jQuery Foundation and other contributors\n   * Released under the MIT license.\n   * http://jquery.org/license\n   *\n   * http://api.jqueryui.com/datepicker/\n   */\n\n  $.extend($.ui, {\n    datepicker: {\n      version: \"1.11.4\"\n    }\n  });\n  var datepicker_instActive;\n\n  function datepicker_getZindex(elem) {\n    var position, value;\n\n    while (elem.length && elem[0] !== document) {\n      // Ignore z-index if position is set to a value where z-index is ignored by the browser\n      // This makes behavior of this function consistent across browsers\n      // WebKit always returns auto if the element is positioned\n      position = elem.css(\"position\");\n\n      if (position === \"absolute\" || position === \"relative\" || position === \"fixed\") {\n        // IE returns 0 when zIndex is not specified\n        // other browsers return a string\n        // we ignore the case of nested elements with an explicit value of 0\n        // <div style=\"z-index: -10;\"><div style=\"z-index: 0;\"></div></div>\n        value = parseInt(elem.css(\"zIndex\"), 10);\n\n        if (!isNaN(value) && value !== 0) {\n          return value;\n        }\n      }\n\n      elem = elem.parent();\n    }\n\n    return 0;\n  }\n  /* Date picker manager.\n     Use the singleton instance of this class, $.datepicker, to interact with the date picker.\n     Settings for (groups of) date pickers are maintained in an instance object,\n     allowing multiple different settings on the same page. */\n\n\n  function Datepicker() {\n    this._curInst = null; // The current instance in use\n\n    this._keyEvent = false; // If the last event was a key event\n\n    this._disabledInputs = []; // List of date picker inputs that have been disabled\n\n    this._datepickerShowing = false; // True if the popup picker is showing , false if not\n\n    this._inDialog = false; // True if showing within a \"dialog\", false if not\n\n    this._mainDivId = \"ui-datepicker-div\"; // The ID of the main datepicker division\n\n    this._inlineClass = \"ui-datepicker-inline\"; // The name of the inline marker class\n\n    this._appendClass = \"ui-datepicker-append\"; // The name of the append marker class\n\n    this._triggerClass = \"ui-datepicker-trigger\"; // The name of the trigger marker class\n\n    this._dialogClass = \"ui-datepicker-dialog\"; // The name of the dialog marker class\n\n    this._disableClass = \"ui-datepicker-disabled\"; // The name of the disabled covering marker class\n\n    this._unselectableClass = \"ui-datepicker-unselectable\"; // The name of the unselectable cell marker class\n\n    this._currentClass = \"ui-datepicker-current-day\"; // The name of the current day marker class\n\n    this._dayOverClass = \"ui-datepicker-days-cell-over\"; // The name of the day hover marker class\n\n    this.regional = []; // Available regional settings, indexed by language code\n\n    this.regional[\"\"] = {\n      // Default regional settings\n      closeText: \"Done\",\n      // Display text for close link\n      prevText: \"Prev\",\n      // Display text for previous month link\n      nextText: \"Next\",\n      // Display text for next month link\n      currentText: \"Today\",\n      // Display text for current month link\n      monthNames: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n      // Names of months for drop-down and formatting\n      monthNamesShort: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"],\n      // For formatting\n      dayNames: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n      // For formatting\n      dayNamesShort: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n      // For formatting\n      dayNamesMin: [\"Su\", \"Mo\", \"Tu\", \"We\", \"Th\", \"Fr\", \"Sa\"],\n      // Column headings for days starting at Sunday\n      weekHeader: \"Wk\",\n      // Column header for week of the year\n      dateFormat: \"mm/dd/yy\",\n      // See format options on parseDate\n      firstDay: 0,\n      // The first day of the week, Sun = 0, Mon = 1, ...\n      isRTL: false,\n      // True if right-to-left language, false if left-to-right\n      showMonthAfterYear: false,\n      // True if the year select precedes month, false for month then year\n      yearSuffix: \"\" // Additional text to append to the year in the month headers\n\n    };\n    this._defaults = {\n      // Global defaults for all the date picker instances\n      showOn: \"focus\",\n      // \"focus\" for popup on focus,\n      // \"button\" for trigger button, or \"both\" for either\n      showAnim: \"fadeIn\",\n      // Name of jQuery animation for popup\n      showOptions: {},\n      // Options for enhanced animations\n      defaultDate: null,\n      // Used when field is blank: actual date,\n      // +/-number for offset from today, null for today\n      appendText: \"\",\n      // Display text following the input box, e.g. showing the format\n      buttonText: \"...\",\n      // Text for trigger button\n      buttonImage: \"\",\n      // URL for trigger button image\n      buttonImageOnly: false,\n      // True if the image appears alone, false if it appears on a button\n      hideIfNoPrevNext: false,\n      // True to hide next/previous month links\n      // if not applicable, false to just disable them\n      navigationAsDateFormat: false,\n      // True if date formatting applied to prev/today/next links\n      gotoCurrent: false,\n      // True if today link goes back to current selection instead\n      changeMonth: false,\n      // True if month can be selected directly, false if only prev/next\n      changeYear: false,\n      // True if year can be selected directly, false if only prev/next\n      yearRange: \"c-10:c+10\",\n      // Range of years to display in drop-down,\n      // either relative to today's year (-nn:+nn), relative to currently displayed year\n      // (c-nn:c+nn), absolute (nnnn:nnnn), or a combination of the above (nnnn:-n)\n      showOtherMonths: false,\n      // True to show dates in other months, false to leave blank\n      selectOtherMonths: false,\n      // True to allow selection of dates in other months, false for unselectable\n      showWeek: false,\n      // True to show week of the year, false to not show it\n      calculateWeek: this.iso8601Week,\n      // How to calculate the week of the year,\n      // takes a Date and returns the number of the week for it\n      shortYearCutoff: \"+10\",\n      // Short year values < this are in the current century,\n      // > this are in the previous century,\n      // string value starting with \"+\" for current year + value\n      minDate: null,\n      // The earliest selectable date, or null for no limit\n      maxDate: null,\n      // The latest selectable date, or null for no limit\n      duration: \"fast\",\n      // Duration of display/closure\n      beforeShowDay: null,\n      // Function that takes a date and returns an array with\n      // [0] = true if selectable, false if not, [1] = custom CSS class name(s) or \"\",\n      // [2] = cell title (optional), e.g. $.datepicker.noWeekends\n      beforeShow: null,\n      // Function that takes an input field and\n      // returns a set of custom settings for the date picker\n      onSelect: null,\n      // Define a callback function when a date is selected\n      onChangeMonthYear: null,\n      // Define a callback function when the month or year is changed\n      onClose: null,\n      // Define a callback function when the datepicker is closed\n      numberOfMonths: 1,\n      // Number of months to show at a time\n      showCurrentAtPos: 0,\n      // The position in multipe months at which to show the current month (starting at 0)\n      stepMonths: 1,\n      // Number of months to step back/forward\n      stepBigMonths: 12,\n      // Number of months to step back/forward for the big links\n      altField: \"\",\n      // Selector for an alternate field to store selected dates into\n      altFormat: \"\",\n      // The date format to use for the alternate field\n      constrainInput: true,\n      // The input is constrained by the current date format\n      showButtonPanel: false,\n      // True to show button panel, false to not show it\n      autoSize: false,\n      // True to size the input for the date format, false to leave as is\n      disabled: false // The initial disabled state\n\n    };\n    $.extend(this._defaults, this.regional[\"\"]);\n    this.regional.en = $.extend(true, {}, this.regional[\"\"]);\n    this.regional[\"en-US\"] = $.extend(true, {}, this.regional.en);\n    this.dpDiv = datepicker_bindHover($(\"<div id='\" + this._mainDivId + \"' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>\"));\n  }\n\n  $.extend(Datepicker.prototype, {\n    /* Class name added to elements to indicate already configured with a date picker. */\n    markerClassName: \"hasDatepicker\",\n    //Keep track of the maximum number of rows displayed (see #7043)\n    maxRows: 4,\n    // TODO rename to \"widget\" when switching to widget factory\n    _widgetDatepicker: function _widgetDatepicker() {\n      return this.dpDiv;\n    },\n\n    /* Override the default settings for all instances of the date picker.\n     * @param  settings  object - the new settings to use as defaults (anonymous object)\n     * @return the manager object\n     */\n    setDefaults: function setDefaults(settings) {\n      datepicker_extendRemove(this._defaults, settings || {});\n      return this;\n    },\n\n    /* Attach the date picker to a jQuery selection.\n     * @param  target\telement - the target input field or division or span\n     * @param  settings  object - the new settings to use for this date picker instance (anonymous)\n     */\n    _attachDatepicker: function _attachDatepicker(target, settings) {\n      var nodeName, inline, inst;\n      nodeName = target.nodeName.toLowerCase();\n      inline = nodeName === \"div\" || nodeName === \"span\";\n\n      if (!target.id) {\n        this.uuid += 1;\n        target.id = \"dp\" + this.uuid;\n      }\n\n      inst = this._newInst($(target), inline);\n      inst.settings = $.extend({}, settings || {});\n\n      if (nodeName === \"input\") {\n        this._connectDatepicker(target, inst);\n      } else if (inline) {\n        this._inlineDatepicker(target, inst);\n      }\n    },\n\n    /* Create a new instance object. */\n    _newInst: function _newInst(target, inline) {\n      var id = target[0].id.replace(/([^A-Za-z0-9_\\-])/g, \"\\\\\\\\$1\"); // escape jQuery meta chars\n\n      return {\n        id: id,\n        input: target,\n        // associated target\n        selectedDay: 0,\n        selectedMonth: 0,\n        selectedYear: 0,\n        // current selection\n        drawMonth: 0,\n        drawYear: 0,\n        // month being drawn\n        inline: inline,\n        // is datepicker inline or not\n        dpDiv: !inline ? this.dpDiv : // presentation div\n        datepicker_bindHover($(\"<div class='\" + this._inlineClass + \" ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>\"))\n      };\n    },\n\n    /* Attach the date picker to an input field. */\n    _connectDatepicker: function _connectDatepicker(target, inst) {\n      var input = $(target);\n      inst.append = $([]);\n      inst.trigger = $([]);\n\n      if (input.hasClass(this.markerClassName)) {\n        return;\n      }\n\n      this._attachments(input, inst);\n\n      input.addClass(this.markerClassName).keydown(this._doKeyDown).keypress(this._doKeyPress).keyup(this._doKeyUp);\n\n      this._autoSize(inst);\n\n      $.data(target, \"datepicker\", inst); //If disabled option is true, disable the datepicker once it has been attached to the input (see ticket #5665)\n\n      if (inst.settings.disabled) {\n        this._disableDatepicker(target);\n      }\n    },\n\n    /* Make attachments based on settings. */\n    _attachments: function _attachments(input, inst) {\n      var showOn,\n          buttonText,\n          buttonImage,\n          appendText = this._get(inst, \"appendText\"),\n          isRTL = this._get(inst, \"isRTL\");\n\n      if (inst.append) {\n        inst.append.remove();\n      }\n\n      if (appendText) {\n        inst.append = $(\"<span class='\" + this._appendClass + \"'>\" + appendText + \"</span>\");\n        input[isRTL ? \"before\" : \"after\"](inst.append);\n      }\n\n      input.unbind(\"focus\", this._showDatepicker);\n\n      if (inst.trigger) {\n        inst.trigger.remove();\n      }\n\n      showOn = this._get(inst, \"showOn\");\n\n      if (showOn === \"focus\" || showOn === \"both\") {\n        // pop-up date picker when in the marked field\n        input.focus(this._showDatepicker);\n      }\n\n      if (showOn === \"button\" || showOn === \"both\") {\n        // pop-up date picker when button clicked\n        buttonText = this._get(inst, \"buttonText\");\n        buttonImage = this._get(inst, \"buttonImage\");\n        inst.trigger = $(this._get(inst, \"buttonImageOnly\") ? $(\"<img/>\").addClass(this._triggerClass).attr({\n          src: buttonImage,\n          alt: buttonText,\n          title: buttonText\n        }) : $(\"<button type='button'></button>\").addClass(this._triggerClass).html(!buttonImage ? buttonText : $(\"<img/>\").attr({\n          src: buttonImage,\n          alt: buttonText,\n          title: buttonText\n        })));\n        input[isRTL ? \"before\" : \"after\"](inst.trigger);\n        inst.trigger.click(function () {\n          if ($.datepicker._datepickerShowing && $.datepicker._lastInput === input[0]) {\n            $.datepicker._hideDatepicker();\n          } else if ($.datepicker._datepickerShowing && $.datepicker._lastInput !== input[0]) {\n            $.datepicker._hideDatepicker();\n\n            $.datepicker._showDatepicker(input[0]);\n          } else {\n            $.datepicker._showDatepicker(input[0]);\n          }\n\n          return false;\n        });\n      }\n    },\n\n    /* Apply the maximum length for the date format. */\n    _autoSize: function _autoSize(inst) {\n      if (this._get(inst, \"autoSize\") && !inst.inline) {\n        var findMax,\n            max,\n            maxI,\n            i,\n            date = new Date(2009, 12 - 1, 20),\n            // Ensure double digits\n        dateFormat = this._get(inst, \"dateFormat\");\n\n        if (dateFormat.match(/[DM]/)) {\n          findMax = function findMax(names) {\n            max = 0;\n            maxI = 0;\n\n            for (i = 0; i < names.length; i++) {\n              if (names[i].length > max) {\n                max = names[i].length;\n                maxI = i;\n              }\n            }\n\n            return maxI;\n          };\n\n          date.setMonth(findMax(this._get(inst, dateFormat.match(/MM/) ? \"monthNames\" : \"monthNamesShort\")));\n          date.setDate(findMax(this._get(inst, dateFormat.match(/DD/) ? \"dayNames\" : \"dayNamesShort\")) + 20 - date.getDay());\n        }\n\n        inst.input.attr(\"size\", this._formatDate(inst, date).length);\n      }\n    },\n\n    /* Attach an inline date picker to a div. */\n    _inlineDatepicker: function _inlineDatepicker(target, inst) {\n      var divSpan = $(target);\n\n      if (divSpan.hasClass(this.markerClassName)) {\n        return;\n      }\n\n      divSpan.addClass(this.markerClassName).append(inst.dpDiv);\n      $.data(target, \"datepicker\", inst);\n\n      this._setDate(inst, this._getDefaultDate(inst), true);\n\n      this._updateDatepicker(inst);\n\n      this._updateAlternate(inst); //If disabled option is true, disable the datepicker before showing it (see ticket #5665)\n\n\n      if (inst.settings.disabled) {\n        this._disableDatepicker(target);\n      } // Set display:block in place of inst.dpDiv.show() which won't work on disconnected elements\n      // http://bugs.jqueryui.com/ticket/7552 - A Datepicker created on a detached div has zero height\n\n\n      inst.dpDiv.css(\"display\", \"block\");\n    },\n\n    /* Pop-up the date picker in a \"dialog\" box.\n     * @param  input element - ignored\n     * @param  date\tstring or Date - the initial date to display\n     * @param  onSelect  function - the function to call when a date is selected\n     * @param  settings  object - update the dialog date picker instance's settings (anonymous object)\n     * @param  pos int[2] - coordinates for the dialog's position within the screen or\n     *\t\t\t\t\tevent - with x/y coordinates or\n     *\t\t\t\t\tleave empty for default (screen centre)\n     * @return the manager object\n     */\n    _dialogDatepicker: function _dialogDatepicker(input, date, onSelect, settings, pos) {\n      var id,\n          browserWidth,\n          browserHeight,\n          scrollX,\n          scrollY,\n          inst = this._dialogInst; // internal instance\n\n      if (!inst) {\n        this.uuid += 1;\n        id = \"dp\" + this.uuid;\n        this._dialogInput = $(\"<input type='text' id='\" + id + \"' style='position: absolute; top: -100px; width: 0px;'/>\");\n\n        this._dialogInput.keydown(this._doKeyDown);\n\n        $(\"body\").append(this._dialogInput);\n        inst = this._dialogInst = this._newInst(this._dialogInput, false);\n        inst.settings = {};\n        $.data(this._dialogInput[0], \"datepicker\", inst);\n      }\n\n      datepicker_extendRemove(inst.settings, settings || {});\n      date = date && date.constructor === Date ? this._formatDate(inst, date) : date;\n\n      this._dialogInput.val(date);\n\n      this._pos = pos ? pos.length ? pos : [pos.pageX, pos.pageY] : null;\n\n      if (!this._pos) {\n        browserWidth = document.documentElement.clientWidth;\n        browserHeight = document.documentElement.clientHeight;\n        scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;\n        scrollY = document.documentElement.scrollTop || document.body.scrollTop;\n        this._pos = // should use actual width/height below\n        [browserWidth / 2 - 100 + scrollX, browserHeight / 2 - 150 + scrollY];\n      } // move input on screen for focus, but hidden behind dialog\n\n\n      this._dialogInput.css(\"left\", this._pos[0] + 20 + \"px\").css(\"top\", this._pos[1] + \"px\");\n\n      inst.settings.onSelect = onSelect;\n      this._inDialog = true;\n      this.dpDiv.addClass(this._dialogClass);\n\n      this._showDatepicker(this._dialogInput[0]);\n\n      if ($.blockUI) {\n        $.blockUI(this.dpDiv);\n      }\n\n      $.data(this._dialogInput[0], \"datepicker\", inst);\n      return this;\n    },\n\n    /* Detach a datepicker from its control.\n     * @param  target\telement - the target input field or division or span\n     */\n    _destroyDatepicker: function _destroyDatepicker(target) {\n      var nodeName,\n          $target = $(target),\n          inst = $.data(target, \"datepicker\");\n\n      if (!$target.hasClass(this.markerClassName)) {\n        return;\n      }\n\n      nodeName = target.nodeName.toLowerCase();\n      $.removeData(target, \"datepicker\");\n\n      if (nodeName === \"input\") {\n        inst.append.remove();\n        inst.trigger.remove();\n        $target.removeClass(this.markerClassName).unbind(\"focus\", this._showDatepicker).unbind(\"keydown\", this._doKeyDown).unbind(\"keypress\", this._doKeyPress).unbind(\"keyup\", this._doKeyUp);\n      } else if (nodeName === \"div\" || nodeName === \"span\") {\n        $target.removeClass(this.markerClassName).empty();\n      }\n\n      if (datepicker_instActive === inst) {\n        datepicker_instActive = null;\n      }\n    },\n\n    /* Enable the date picker to a jQuery selection.\n     * @param  target\telement - the target input field or division or span\n     */\n    _enableDatepicker: function _enableDatepicker(target) {\n      var nodeName,\n          inline,\n          $target = $(target),\n          inst = $.data(target, \"datepicker\");\n\n      if (!$target.hasClass(this.markerClassName)) {\n        return;\n      }\n\n      nodeName = target.nodeName.toLowerCase();\n\n      if (nodeName === \"input\") {\n        target.disabled = false;\n        inst.trigger.filter(\"button\").each(function () {\n          this.disabled = false;\n        }).end().filter(\"img\").css({\n          opacity: \"1.0\",\n          cursor: \"\"\n        });\n      } else if (nodeName === \"div\" || nodeName === \"span\") {\n        inline = $target.children(\".\" + this._inlineClass);\n        inline.children().removeClass(\"ui-state-disabled\");\n        inline.find(\"select.ui-datepicker-month, select.ui-datepicker-year\").prop(\"disabled\", false);\n      }\n\n      this._disabledInputs = $.map(this._disabledInputs, function (value) {\n        return value === target ? null : value;\n      }); // delete entry\n    },\n\n    /* Disable the date picker to a jQuery selection.\n     * @param  target\telement - the target input field or division or span\n     */\n    _disableDatepicker: function _disableDatepicker(target) {\n      var nodeName,\n          inline,\n          $target = $(target),\n          inst = $.data(target, \"datepicker\");\n\n      if (!$target.hasClass(this.markerClassName)) {\n        return;\n      }\n\n      nodeName = target.nodeName.toLowerCase();\n\n      if (nodeName === \"input\") {\n        target.disabled = true;\n        inst.trigger.filter(\"button\").each(function () {\n          this.disabled = true;\n        }).end().filter(\"img\").css({\n          opacity: \"0.5\",\n          cursor: \"default\"\n        });\n      } else if (nodeName === \"div\" || nodeName === \"span\") {\n        inline = $target.children(\".\" + this._inlineClass);\n        inline.children().addClass(\"ui-state-disabled\");\n        inline.find(\"select.ui-datepicker-month, select.ui-datepicker-year\").prop(\"disabled\", true);\n      }\n\n      this._disabledInputs = $.map(this._disabledInputs, function (value) {\n        return value === target ? null : value;\n      }); // delete entry\n\n      this._disabledInputs[this._disabledInputs.length] = target;\n    },\n\n    /* Is the first field in a jQuery collection disabled as a datepicker?\n     * @param  target\telement - the target input field or division or span\n     * @return boolean - true if disabled, false if enabled\n     */\n    _isDisabledDatepicker: function _isDisabledDatepicker(target) {\n      if (!target) {\n        return false;\n      }\n\n      for (var i = 0; i < this._disabledInputs.length; i++) {\n        if (this._disabledInputs[i] === target) {\n          return true;\n        }\n      }\n\n      return false;\n    },\n\n    /* Retrieve the instance data for the target control.\n     * @param  target  element - the target input field or division or span\n     * @return  object - the associated instance data\n     * @throws  error if a jQuery problem getting data\n     */\n    _getInst: function _getInst(target) {\n      try {\n        return $.data(target, \"datepicker\");\n      } catch (err) {\n        throw \"Missing instance data for this datepicker\";\n      }\n    },\n\n    /* Update or retrieve the settings for a date picker attached to an input field or division.\n     * @param  target  element - the target input field or division or span\n     * @param  name\tobject - the new settings to update or\n     *\t\t\t\tstring - the name of the setting to change or retrieve,\n     *\t\t\t\twhen retrieving also \"all\" for all instance settings or\n     *\t\t\t\t\"defaults\" for all global defaults\n     * @param  value   any - the new value for the setting\n     *\t\t\t\t(omit if above is an object or to retrieve a value)\n     */\n    _optionDatepicker: function _optionDatepicker(target, name, value) {\n      var settings,\n          date,\n          minDate,\n          maxDate,\n          inst = this._getInst(target);\n\n      if (arguments.length === 2 && typeof name === \"string\") {\n        return name === \"defaults\" ? $.extend({}, $.datepicker._defaults) : inst ? name === \"all\" ? $.extend({}, inst.settings) : this._get(inst, name) : null;\n      }\n\n      settings = name || {};\n\n      if (typeof name === \"string\") {\n        settings = {};\n        settings[name] = value;\n      }\n\n      if (inst) {\n        if (this._curInst === inst) {\n          this._hideDatepicker();\n        }\n\n        date = this._getDateDatepicker(target, true);\n        minDate = this._getMinMaxDate(inst, \"min\");\n        maxDate = this._getMinMaxDate(inst, \"max\");\n        datepicker_extendRemove(inst.settings, settings); // reformat the old minDate/maxDate values if dateFormat changes and a new minDate/maxDate isn't provided\n\n        if (minDate !== null && settings.dateFormat !== undefined && settings.minDate === undefined) {\n          inst.settings.minDate = this._formatDate(inst, minDate);\n        }\n\n        if (maxDate !== null && settings.dateFormat !== undefined && settings.maxDate === undefined) {\n          inst.settings.maxDate = this._formatDate(inst, maxDate);\n        }\n\n        if (\"disabled\" in settings) {\n          if (settings.disabled) {\n            this._disableDatepicker(target);\n          } else {\n            this._enableDatepicker(target);\n          }\n        }\n\n        this._attachments($(target), inst);\n\n        this._autoSize(inst);\n\n        this._setDate(inst, date);\n\n        this._updateAlternate(inst);\n\n        this._updateDatepicker(inst);\n      }\n    },\n    // change method deprecated\n    _changeDatepicker: function _changeDatepicker(target, name, value) {\n      this._optionDatepicker(target, name, value);\n    },\n\n    /* Redraw the date picker attached to an input field or division.\n     * @param  target  element - the target input field or division or span\n     */\n    _refreshDatepicker: function _refreshDatepicker(target) {\n      var inst = this._getInst(target);\n\n      if (inst) {\n        this._updateDatepicker(inst);\n      }\n    },\n\n    /* Set the dates for a jQuery selection.\n     * @param  target element - the target input field or division or span\n     * @param  date\tDate - the new date\n     */\n    _setDateDatepicker: function _setDateDatepicker(target, date) {\n      var inst = this._getInst(target);\n\n      if (inst) {\n        this._setDate(inst, date);\n\n        this._updateDatepicker(inst);\n\n        this._updateAlternate(inst);\n      }\n    },\n\n    /* Get the date(s) for the first entry in a jQuery selection.\n     * @param  target element - the target input field or division or span\n     * @param  noDefault boolean - true if no default date is to be used\n     * @return Date - the current date\n     */\n    _getDateDatepicker: function _getDateDatepicker(target, noDefault) {\n      var inst = this._getInst(target);\n\n      if (inst && !inst.inline) {\n        this._setDateFromField(inst, noDefault);\n      }\n\n      return inst ? this._getDate(inst) : null;\n    },\n\n    /* Handle keystrokes. */\n    _doKeyDown: function _doKeyDown(event) {\n      var onSelect,\n          dateStr,\n          sel,\n          inst = $.datepicker._getInst(event.target),\n          handled = true,\n          isRTL = inst.dpDiv.is(\".ui-datepicker-rtl\");\n\n      inst._keyEvent = true;\n\n      if ($.datepicker._datepickerShowing) {\n        switch (event.keyCode) {\n          case 9:\n            $.datepicker._hideDatepicker();\n\n            handled = false;\n            break;\n          // hide on tab out\n\n          case 13:\n            sel = $(\"td.\" + $.datepicker._dayOverClass + \":not(.\" + $.datepicker._currentClass + \")\", inst.dpDiv);\n\n            if (sel[0]) {\n              $.datepicker._selectDay(event.target, inst.selectedMonth, inst.selectedYear, sel[0]);\n            }\n\n            onSelect = $.datepicker._get(inst, \"onSelect\");\n\n            if (onSelect) {\n              dateStr = $.datepicker._formatDate(inst); // trigger custom callback\n\n              onSelect.apply(inst.input ? inst.input[0] : null, [dateStr, inst]);\n            } else {\n              $.datepicker._hideDatepicker();\n            }\n\n            return false;\n          // don't submit the form\n\n          case 27:\n            $.datepicker._hideDatepicker();\n\n            break;\n          // hide on escape\n\n          case 33:\n            $.datepicker._adjustDate(event.target, event.ctrlKey ? -$.datepicker._get(inst, \"stepBigMonths\") : -$.datepicker._get(inst, \"stepMonths\"), \"M\");\n\n            break;\n          // previous month/year on page up/+ ctrl\n\n          case 34:\n            $.datepicker._adjustDate(event.target, event.ctrlKey ? +$.datepicker._get(inst, \"stepBigMonths\") : +$.datepicker._get(inst, \"stepMonths\"), \"M\");\n\n            break;\n          // next month/year on page down/+ ctrl\n\n          case 35:\n            if (event.ctrlKey || event.metaKey) {\n              $.datepicker._clearDate(event.target);\n            }\n\n            handled = event.ctrlKey || event.metaKey;\n            break;\n          // clear on ctrl or command +end\n\n          case 36:\n            if (event.ctrlKey || event.metaKey) {\n              $.datepicker._gotoToday(event.target);\n            }\n\n            handled = event.ctrlKey || event.metaKey;\n            break;\n          // current on ctrl or command +home\n\n          case 37:\n            if (event.ctrlKey || event.metaKey) {\n              $.datepicker._adjustDate(event.target, isRTL ? +1 : -1, \"D\");\n            }\n\n            handled = event.ctrlKey || event.metaKey; // -1 day on ctrl or command +left\n\n            if (event.originalEvent.altKey) {\n              $.datepicker._adjustDate(event.target, event.ctrlKey ? -$.datepicker._get(inst, \"stepBigMonths\") : -$.datepicker._get(inst, \"stepMonths\"), \"M\");\n            } // next month/year on alt +left on Mac\n\n\n            break;\n\n          case 38:\n            if (event.ctrlKey || event.metaKey) {\n              $.datepicker._adjustDate(event.target, -7, \"D\");\n            }\n\n            handled = event.ctrlKey || event.metaKey;\n            break;\n          // -1 week on ctrl or command +up\n\n          case 39:\n            if (event.ctrlKey || event.metaKey) {\n              $.datepicker._adjustDate(event.target, isRTL ? -1 : +1, \"D\");\n            }\n\n            handled = event.ctrlKey || event.metaKey; // +1 day on ctrl or command +right\n\n            if (event.originalEvent.altKey) {\n              $.datepicker._adjustDate(event.target, event.ctrlKey ? +$.datepicker._get(inst, \"stepBigMonths\") : +$.datepicker._get(inst, \"stepMonths\"), \"M\");\n            } // next month/year on alt +right\n\n\n            break;\n\n          case 40:\n            if (event.ctrlKey || event.metaKey) {\n              $.datepicker._adjustDate(event.target, +7, \"D\");\n            }\n\n            handled = event.ctrlKey || event.metaKey;\n            break;\n          // +1 week on ctrl or command +down\n\n          default:\n            handled = false;\n        }\n      } else if (event.keyCode === 36 && event.ctrlKey) {\n        // display the date picker on ctrl+home\n        $.datepicker._showDatepicker(this);\n      } else {\n        handled = false;\n      }\n\n      if (handled) {\n        event.preventDefault();\n        event.stopPropagation();\n      }\n    },\n\n    /* Filter entered characters - based on date format. */\n    _doKeyPress: function _doKeyPress(event) {\n      var chars,\n          chr,\n          inst = $.datepicker._getInst(event.target);\n\n      if ($.datepicker._get(inst, \"constrainInput\")) {\n        chars = $.datepicker._possibleChars($.datepicker._get(inst, \"dateFormat\"));\n        chr = String.fromCharCode(event.charCode == null ? event.keyCode : event.charCode);\n        return event.ctrlKey || event.metaKey || chr < \" \" || !chars || chars.indexOf(chr) > -1;\n      }\n    },\n\n    /* Synchronise manual entry and field/alternate field. */\n    _doKeyUp: function _doKeyUp(event) {\n      var date,\n          inst = $.datepicker._getInst(event.target);\n\n      if (inst.input.val() !== inst.lastVal) {\n        try {\n          date = $.datepicker.parseDate($.datepicker._get(inst, \"dateFormat\"), inst.input ? inst.input.val() : null, $.datepicker._getFormatConfig(inst));\n\n          if (date) {\n            // only if valid\n            $.datepicker._setDateFromField(inst);\n\n            $.datepicker._updateAlternate(inst);\n\n            $.datepicker._updateDatepicker(inst);\n          }\n        } catch (err) {}\n      }\n\n      return true;\n    },\n\n    /* Pop-up the date picker for a given input field.\n     * If false returned from beforeShow event handler do not show.\n     * @param  input  element - the input field attached to the date picker or\n     *\t\t\t\t\tevent - if triggered by focus\n     */\n    _showDatepicker: function _showDatepicker(input) {\n      input = input.target || input;\n\n      if (input.nodeName.toLowerCase() !== \"input\") {\n        // find from button/image trigger\n        input = $(\"input\", input.parentNode)[0];\n      }\n\n      if ($.datepicker._isDisabledDatepicker(input) || $.datepicker._lastInput === input) {\n        // already here\n        return;\n      }\n\n      var inst, beforeShow, beforeShowSettings, isFixed, offset, showAnim, duration;\n      inst = $.datepicker._getInst(input);\n\n      if ($.datepicker._curInst && $.datepicker._curInst !== inst) {\n        $.datepicker._curInst.dpDiv.stop(true, true);\n\n        if (inst && $.datepicker._datepickerShowing) {\n          $.datepicker._hideDatepicker($.datepicker._curInst.input[0]);\n        }\n      }\n\n      beforeShow = $.datepicker._get(inst, \"beforeShow\");\n      beforeShowSettings = beforeShow ? beforeShow.apply(input, [input, inst]) : {};\n\n      if (beforeShowSettings === false) {\n        return;\n      }\n\n      datepicker_extendRemove(inst.settings, beforeShowSettings);\n      inst.lastVal = null;\n      $.datepicker._lastInput = input;\n\n      $.datepicker._setDateFromField(inst);\n\n      if ($.datepicker._inDialog) {\n        // hide cursor\n        input.value = \"\";\n      }\n\n      if (!$.datepicker._pos) {\n        // position below input\n        $.datepicker._pos = $.datepicker._findPos(input);\n        $.datepicker._pos[1] += input.offsetHeight; // add the height\n      }\n\n      isFixed = false;\n      $(input).parents().each(function () {\n        isFixed |= $(this).css(\"position\") === \"fixed\";\n        return !isFixed;\n      });\n      offset = {\n        left: $.datepicker._pos[0],\n        top: $.datepicker._pos[1]\n      };\n      $.datepicker._pos = null; //to avoid flashes on Firefox\n\n      inst.dpDiv.empty(); // determine sizing offscreen\n\n      inst.dpDiv.css({\n        position: \"absolute\",\n        display: \"block\",\n        top: \"-1000px\"\n      });\n\n      $.datepicker._updateDatepicker(inst); // fix width for dynamic number of date pickers\n      // and adjust position before showing\n\n\n      offset = $.datepicker._checkOffset(inst, offset, isFixed);\n      inst.dpDiv.css({\n        position: $.datepicker._inDialog && $.blockUI ? \"static\" : isFixed ? \"fixed\" : \"absolute\",\n        display: \"none\",\n        left: offset.left + \"px\",\n        top: offset.top + \"px\"\n      });\n\n      if (!inst.inline) {\n        showAnim = $.datepicker._get(inst, \"showAnim\");\n        duration = $.datepicker._get(inst, \"duration\");\n        inst.dpDiv.css(\"z-index\", datepicker_getZindex($(input)) + 1);\n        $.datepicker._datepickerShowing = true;\n\n        if ($.effects && $.effects.effect[showAnim]) {\n          inst.dpDiv.show(showAnim, $.datepicker._get(inst, \"showOptions\"), duration);\n        } else {\n          inst.dpDiv[showAnim || \"show\"](showAnim ? duration : null);\n        }\n\n        if ($.datepicker._shouldFocusInput(inst)) {\n          inst.input.focus();\n        }\n\n        $.datepicker._curInst = inst;\n      }\n    },\n\n    /* Generate the date picker content. */\n    _updateDatepicker: function _updateDatepicker(inst) {\n      this.maxRows = 4; //Reset the max number of rows being displayed (see #7043)\n\n      datepicker_instActive = inst; // for delegate hover events\n\n      inst.dpDiv.empty().append(this._generateHTML(inst));\n\n      this._attachHandlers(inst);\n\n      var origyearshtml,\n          numMonths = this._getNumberOfMonths(inst),\n          cols = numMonths[1],\n          width = 17,\n          activeCell = inst.dpDiv.find(\".\" + this._dayOverClass + \" a\");\n\n      if (activeCell.length > 0) {\n        datepicker_handleMouseover.apply(activeCell.get(0));\n      }\n\n      inst.dpDiv.removeClass(\"ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4\").width(\"\");\n\n      if (cols > 1) {\n        inst.dpDiv.addClass(\"ui-datepicker-multi-\" + cols).css(\"width\", width * cols + \"em\");\n      }\n\n      inst.dpDiv[(numMonths[0] !== 1 || numMonths[1] !== 1 ? \"add\" : \"remove\") + \"Class\"](\"ui-datepicker-multi\");\n      inst.dpDiv[(this._get(inst, \"isRTL\") ? \"add\" : \"remove\") + \"Class\"](\"ui-datepicker-rtl\");\n\n      if (inst === $.datepicker._curInst && $.datepicker._datepickerShowing && $.datepicker._shouldFocusInput(inst)) {\n        inst.input.focus();\n      } // deffered render of the years select (to avoid flashes on Firefox)\n\n\n      if (inst.yearshtml) {\n        origyearshtml = inst.yearshtml;\n        setTimeout(function () {\n          //assure that inst.yearshtml didn't change.\n          if (origyearshtml === inst.yearshtml && inst.yearshtml) {\n            inst.dpDiv.find(\"select.ui-datepicker-year:first\").replaceWith(inst.yearshtml);\n          }\n\n          origyearshtml = inst.yearshtml = null;\n        }, 0);\n      }\n    },\n    // #6694 - don't focus the input if it's already focused\n    // this breaks the change event in IE\n    // Support: IE and jQuery <1.9\n    _shouldFocusInput: function _shouldFocusInput(inst) {\n      return inst.input && inst.input.is(\":visible\") && !inst.input.is(\":disabled\") && !inst.input.is(\":focus\");\n    },\n\n    /* Check positioning to remain on screen. */\n    _checkOffset: function _checkOffset(inst, offset, isFixed) {\n      var dpWidth = inst.dpDiv.outerWidth(),\n          dpHeight = inst.dpDiv.outerHeight(),\n          inputWidth = inst.input ? inst.input.outerWidth() : 0,\n          inputHeight = inst.input ? inst.input.outerHeight() : 0,\n          viewWidth = document.documentElement.clientWidth + (isFixed ? 0 : $(document).scrollLeft()),\n          viewHeight = document.documentElement.clientHeight + (isFixed ? 0 : $(document).scrollTop());\n      offset.left -= this._get(inst, \"isRTL\") ? dpWidth - inputWidth : 0;\n      offset.left -= isFixed && offset.left === inst.input.offset().left ? $(document).scrollLeft() : 0;\n      offset.top -= isFixed && offset.top === inst.input.offset().top + inputHeight ? $(document).scrollTop() : 0; // now check if datepicker is showing outside window viewport - move to a better place if so.\n\n      offset.left -= Math.min(offset.left, offset.left + dpWidth > viewWidth && viewWidth > dpWidth ? Math.abs(offset.left + dpWidth - viewWidth) : 0);\n      offset.top -= Math.min(offset.top, offset.top + dpHeight > viewHeight && viewHeight > dpHeight ? Math.abs(dpHeight + inputHeight) : 0);\n      return offset;\n    },\n\n    /* Find an object's position on the screen. */\n    _findPos: function _findPos(obj) {\n      var position,\n          inst = this._getInst(obj),\n          isRTL = this._get(inst, \"isRTL\");\n\n      while (obj && (obj.type === \"hidden\" || obj.nodeType !== 1 || $.expr.filters.hidden(obj))) {\n        obj = obj[isRTL ? \"previousSibling\" : \"nextSibling\"];\n      }\n\n      position = $(obj).offset();\n      return [position.left, position.top];\n    },\n\n    /* Hide the date picker from view.\n     * @param  input  element - the input field attached to the date picker\n     */\n    _hideDatepicker: function _hideDatepicker(input) {\n      var showAnim,\n          duration,\n          postProcess,\n          onClose,\n          inst = this._curInst;\n\n      if (!inst || input && inst !== $.data(input, \"datepicker\")) {\n        return;\n      }\n\n      if (this._datepickerShowing) {\n        showAnim = this._get(inst, \"showAnim\");\n        duration = this._get(inst, \"duration\");\n\n        postProcess = function postProcess() {\n          $.datepicker._tidyDialog(inst);\n        }; // DEPRECATED: after BC for 1.8.x $.effects[ showAnim ] is not needed\n\n\n        if ($.effects && ($.effects.effect[showAnim] || $.effects[showAnim])) {\n          inst.dpDiv.hide(showAnim, $.datepicker._get(inst, \"showOptions\"), duration, postProcess);\n        } else {\n          inst.dpDiv[showAnim === \"slideDown\" ? \"slideUp\" : showAnim === \"fadeIn\" ? \"fadeOut\" : \"hide\"](showAnim ? duration : null, postProcess);\n        }\n\n        if (!showAnim) {\n          postProcess();\n        }\n\n        this._datepickerShowing = false;\n        onClose = this._get(inst, \"onClose\");\n\n        if (onClose) {\n          onClose.apply(inst.input ? inst.input[0] : null, [inst.input ? inst.input.val() : \"\", inst]);\n        }\n\n        this._lastInput = null;\n\n        if (this._inDialog) {\n          this._dialogInput.css({\n            position: \"absolute\",\n            left: \"0\",\n            top: \"-100px\"\n          });\n\n          if ($.blockUI) {\n            $.unblockUI();\n            $(\"body\").append(this.dpDiv);\n          }\n        }\n\n        this._inDialog = false;\n      }\n    },\n\n    /* Tidy up after a dialog display. */\n    _tidyDialog: function _tidyDialog(inst) {\n      inst.dpDiv.removeClass(this._dialogClass).unbind(\".ui-datepicker-calendar\");\n    },\n\n    /* Close date picker if clicked elsewhere. */\n    _checkExternalClick: function _checkExternalClick(event) {\n      if (!$.datepicker._curInst) {\n        return;\n      }\n\n      var $target = $(event.target),\n          inst = $.datepicker._getInst($target[0]);\n\n      if ($target[0].id !== $.datepicker._mainDivId && $target.parents(\"#\" + $.datepicker._mainDivId).length === 0 && !$target.hasClass($.datepicker.markerClassName) && !$target.closest(\".\" + $.datepicker._triggerClass).length && $.datepicker._datepickerShowing && !($.datepicker._inDialog && $.blockUI) || $target.hasClass($.datepicker.markerClassName) && $.datepicker._curInst !== inst) {\n        $.datepicker._hideDatepicker();\n      }\n    },\n\n    /* Adjust one of the date sub-fields. */\n    _adjustDate: function _adjustDate(id, offset, period) {\n      var target = $(id),\n          inst = this._getInst(target[0]);\n\n      if (this._isDisabledDatepicker(target[0])) {\n        return;\n      }\n\n      this._adjustInstDate(inst, offset + (period === \"M\" ? this._get(inst, \"showCurrentAtPos\") : 0), // undo positioning\n      period);\n\n      this._updateDatepicker(inst);\n    },\n\n    /* Action for current link. */\n    _gotoToday: function _gotoToday(id) {\n      var date,\n          target = $(id),\n          inst = this._getInst(target[0]);\n\n      if (this._get(inst, \"gotoCurrent\") && inst.currentDay) {\n        inst.selectedDay = inst.currentDay;\n        inst.drawMonth = inst.selectedMonth = inst.currentMonth;\n        inst.drawYear = inst.selectedYear = inst.currentYear;\n      } else {\n        date = new Date();\n        inst.selectedDay = date.getDate();\n        inst.drawMonth = inst.selectedMonth = date.getMonth();\n        inst.drawYear = inst.selectedYear = date.getFullYear();\n      }\n\n      this._notifyChange(inst);\n\n      this._adjustDate(target);\n    },\n\n    /* Action for selecting a new month/year. */\n    _selectMonthYear: function _selectMonthYear(id, select, period) {\n      var target = $(id),\n          inst = this._getInst(target[0]);\n\n      inst[\"selected\" + (period === \"M\" ? \"Month\" : \"Year\")] = inst[\"draw\" + (period === \"M\" ? \"Month\" : \"Year\")] = parseInt(select.options[select.selectedIndex].value, 10);\n\n      this._notifyChange(inst);\n\n      this._adjustDate(target);\n    },\n\n    /* Action for selecting a day. */\n    _selectDay: function _selectDay(id, month, year, td) {\n      var inst,\n          target = $(id);\n\n      if ($(td).hasClass(this._unselectableClass) || this._isDisabledDatepicker(target[0])) {\n        return;\n      }\n\n      inst = this._getInst(target[0]);\n      inst.selectedDay = inst.currentDay = $(\"a\", td).html();\n      inst.selectedMonth = inst.currentMonth = month;\n      inst.selectedYear = inst.currentYear = year;\n\n      this._selectDate(id, this._formatDate(inst, inst.currentDay, inst.currentMonth, inst.currentYear));\n    },\n\n    /* Erase the input field and hide the date picker. */\n    _clearDate: function _clearDate(id) {\n      var target = $(id);\n\n      this._selectDate(target, \"\");\n    },\n\n    /* Update the input field with the selected date. */\n    _selectDate: function _selectDate(id, dateStr) {\n      var onSelect,\n          target = $(id),\n          inst = this._getInst(target[0]);\n\n      dateStr = dateStr != null ? dateStr : this._formatDate(inst);\n\n      if (inst.input) {\n        inst.input.val(dateStr);\n      }\n\n      this._updateAlternate(inst);\n\n      onSelect = this._get(inst, \"onSelect\");\n\n      if (onSelect) {\n        onSelect.apply(inst.input ? inst.input[0] : null, [dateStr, inst]); // trigger custom callback\n      } else if (inst.input) {\n        inst.input.trigger(\"change\"); // fire the change event\n      }\n\n      if (inst.inline) {\n        this._updateDatepicker(inst);\n      } else {\n        this._hideDatepicker();\n\n        this._lastInput = inst.input[0];\n\n        if (_typeof(inst.input[0]) !== \"object\") {\n          inst.input.focus(); // restore focus\n        }\n\n        this._lastInput = null;\n      }\n    },\n\n    /* Update any alternate field to synchronise with the main field. */\n    _updateAlternate: function _updateAlternate(inst) {\n      var altFormat,\n          date,\n          dateStr,\n          altField = this._get(inst, \"altField\");\n\n      if (altField) {\n        // update alternate field too\n        altFormat = this._get(inst, \"altFormat\") || this._get(inst, \"dateFormat\");\n        date = this._getDate(inst);\n        dateStr = this.formatDate(altFormat, date, this._getFormatConfig(inst));\n        $(altField).each(function () {\n          $(this).val(dateStr);\n        });\n      }\n    },\n\n    /* Set as beforeShowDay function to prevent selection of weekends.\n     * @param  date  Date - the date to customise\n     * @return [boolean, string] - is this date selectable?, what is its CSS class?\n     */\n    noWeekends: function noWeekends(date) {\n      var day = date.getDay();\n      return [day > 0 && day < 6, \"\"];\n    },\n\n    /* Set as calculateWeek to determine the week of the year based on the ISO 8601 definition.\n     * @param  date  Date - the date to get the week for\n     * @return  number - the number of the week within the year that contains this date\n     */\n    iso8601Week: function iso8601Week(date) {\n      var time,\n          checkDate = new Date(date.getTime()); // Find Thursday of this week starting on Monday\n\n      checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));\n      time = checkDate.getTime();\n      checkDate.setMonth(0); // Compare with Jan 1\n\n      checkDate.setDate(1);\n      return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;\n    },\n\n    /* Parse a string value into a date object.\n     * See formatDate below for the possible formats.\n     *\n     * @param  format string - the expected format of the date\n     * @param  value string - the date in the above format\n     * @param  settings Object - attributes include:\n     *\t\t\t\t\tshortYearCutoff  number - the cutoff year for determining the century (optional)\n     *\t\t\t\t\tdayNamesShort\tstring[7] - abbreviated names of the days from Sunday (optional)\n     *\t\t\t\t\tdayNames\t\tstring[7] - names of the days from Sunday (optional)\n     *\t\t\t\t\tmonthNamesShort string[12] - abbreviated names of the months (optional)\n     *\t\t\t\t\tmonthNames\t\tstring[12] - names of the months (optional)\n     * @return  Date - the extracted date value or null if value is blank\n     */\n    parseDate: function parseDate(format, value, settings) {\n      if (format == null || value == null) {\n        throw \"Invalid arguments\";\n      }\n\n      value = _typeof(value) === \"object\" ? value.toString() : value + \"\";\n\n      if (value === \"\") {\n        return null;\n      }\n\n      var iFormat,\n          dim,\n          extra,\n          iValue = 0,\n          shortYearCutoffTemp = (settings ? settings.shortYearCutoff : null) || this._defaults.shortYearCutoff,\n          shortYearCutoff = typeof shortYearCutoffTemp !== \"string\" ? shortYearCutoffTemp : new Date().getFullYear() % 100 + parseInt(shortYearCutoffTemp, 10),\n          dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,\n          dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,\n          monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,\n          monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,\n          year = -1,\n          month = -1,\n          day = -1,\n          doy = -1,\n          literal = false,\n          date,\n          // Check whether a format character is doubled\n      lookAhead = function lookAhead(match) {\n        var matches = iFormat + 1 < format.length && format.charAt(iFormat + 1) === match;\n\n        if (matches) {\n          iFormat++;\n        }\n\n        return matches;\n      },\n          // Extract a number from the string value\n      getNumber = function getNumber(match) {\n        var isDoubled = lookAhead(match),\n            size = match === \"@\" ? 14 : match === \"!\" ? 20 : match === \"y\" && isDoubled ? 4 : match === \"o\" ? 3 : 2,\n            minSize = match === \"y\" ? size : 1,\n            digits = new RegExp(\"^\\\\d{\" + minSize + \",\" + size + \"}\"),\n            num = value.substring(iValue).match(digits);\n\n        if (!num) {\n          throw \"Missing number at position \" + iValue;\n        }\n\n        iValue += num[0].length;\n        return parseInt(num[0], 10);\n      },\n          // Extract a name from the string value and convert to an index\n      getName = function getName(match, shortNames, longNames) {\n        var index = -1,\n            names = $.map(lookAhead(match) ? longNames : shortNames, function (v, k) {\n          return [[k, v]];\n        }).sort(function (a, b) {\n          return -(a[1].length - b[1].length);\n        });\n        $.each(names, function (i, pair) {\n          var name = pair[1];\n\n          if (value.substr(iValue, name.length).toLowerCase() === name.toLowerCase()) {\n            index = pair[0];\n            iValue += name.length;\n            return false;\n          }\n        });\n\n        if (index !== -1) {\n          return index + 1;\n        } else {\n          throw \"Unknown name at position \" + iValue;\n        }\n      },\n          // Confirm that a literal character matches the string value\n      checkLiteral = function checkLiteral() {\n        if (value.charAt(iValue) !== format.charAt(iFormat)) {\n          throw \"Unexpected literal at position \" + iValue;\n        }\n\n        iValue++;\n      };\n\n      for (iFormat = 0; iFormat < format.length; iFormat++) {\n        if (literal) {\n          if (format.charAt(iFormat) === \"'\" && !lookAhead(\"'\")) {\n            literal = false;\n          } else {\n            checkLiteral();\n          }\n        } else {\n          switch (format.charAt(iFormat)) {\n            case \"d\":\n              day = getNumber(\"d\");\n              break;\n\n            case \"D\":\n              getName(\"D\", dayNamesShort, dayNames);\n              break;\n\n            case \"o\":\n              doy = getNumber(\"o\");\n              break;\n\n            case \"m\":\n              month = getNumber(\"m\");\n              break;\n\n            case \"M\":\n              month = getName(\"M\", monthNamesShort, monthNames);\n              break;\n\n            case \"y\":\n              year = getNumber(\"y\");\n              break;\n\n            case \"@\":\n              date = new Date(getNumber(\"@\"));\n              year = date.getFullYear();\n              month = date.getMonth() + 1;\n              day = date.getDate();\n              break;\n\n            case \"!\":\n              date = new Date((getNumber(\"!\") - this._ticksTo1970) / 10000);\n              year = date.getFullYear();\n              month = date.getMonth() + 1;\n              day = date.getDate();\n              break;\n\n            case \"'\":\n              if (lookAhead(\"'\")) {\n                checkLiteral();\n              } else {\n                literal = true;\n              }\n\n              break;\n\n            default:\n              checkLiteral();\n          }\n        }\n      }\n\n      if (iValue < value.length) {\n        extra = value.substr(iValue);\n\n        if (!/^\\s+/.test(extra)) {\n          throw \"Extra/unparsed characters found in date: \" + extra;\n        }\n      }\n\n      if (year === -1) {\n        year = new Date().getFullYear();\n      } else if (year < 100) {\n        year += new Date().getFullYear() - new Date().getFullYear() % 100 + (year <= shortYearCutoff ? 0 : -100);\n      }\n\n      if (doy > -1) {\n        month = 1;\n        day = doy;\n\n        do {\n          dim = this._getDaysInMonth(year, month - 1);\n\n          if (day <= dim) {\n            break;\n          }\n\n          month++;\n          day -= dim;\n        } while (true);\n      }\n\n      date = this._daylightSavingAdjust(new Date(year, month - 1, day));\n\n      if (date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day) {\n        throw \"Invalid date\"; // E.g. 31/02/00\n      }\n\n      return date;\n    },\n\n    /* Standard date formats. */\n    ATOM: \"yy-mm-dd\",\n    // RFC 3339 (ISO 8601)\n    COOKIE: \"D, dd M yy\",\n    ISO_8601: \"yy-mm-dd\",\n    RFC_822: \"D, d M y\",\n    RFC_850: \"DD, dd-M-y\",\n    RFC_1036: \"D, d M y\",\n    RFC_1123: \"D, d M yy\",\n    RFC_2822: \"D, d M yy\",\n    RSS: \"D, d M y\",\n    // RFC 822\n    TICKS: \"!\",\n    TIMESTAMP: \"@\",\n    W3C: \"yy-mm-dd\",\n    // ISO 8601\n    _ticksTo1970: ((1970 - 1) * 365 + Math.floor(1970 / 4) - Math.floor(1970 / 100) + Math.floor(1970 / 400)) * 24 * 60 * 60 * 10000000,\n\n    /* Format a date object into a string value.\n     * The format can be combinations of the following:\n     * d  - day of month (no leading zero)\n     * dd - day of month (two digit)\n     * o  - day of year (no leading zeros)\n     * oo - day of year (three digit)\n     * D  - day name short\n     * DD - day name long\n     * m  - month of year (no leading zero)\n     * mm - month of year (two digit)\n     * M  - month name short\n     * MM - month name long\n     * y  - year (two digit)\n     * yy - year (four digit)\n     * @ - Unix timestamp (ms since 01/01/1970)\n     * ! - Windows ticks (100ns since 01/01/0001)\n     * \"...\" - literal text\n     * '' - single quote\n     *\n     * @param  format string - the desired format of the date\n     * @param  date Date - the date value to format\n     * @param  settings Object - attributes include:\n     *\t\t\t\t\tdayNamesShort\tstring[7] - abbreviated names of the days from Sunday (optional)\n     *\t\t\t\t\tdayNames\t\tstring[7] - names of the days from Sunday (optional)\n     *\t\t\t\t\tmonthNamesShort string[12] - abbreviated names of the months (optional)\n     *\t\t\t\t\tmonthNames\t\tstring[12] - names of the months (optional)\n     * @return  string - the date in the above format\n     */\n    formatDate: function formatDate(format, date, settings) {\n      if (!date) {\n        return \"\";\n      }\n\n      var iFormat,\n          dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,\n          dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,\n          monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,\n          monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,\n          // Check whether a format character is doubled\n      lookAhead = function lookAhead(match) {\n        var matches = iFormat + 1 < format.length && format.charAt(iFormat + 1) === match;\n\n        if (matches) {\n          iFormat++;\n        }\n\n        return matches;\n      },\n          // Format a number, with leading zero if necessary\n      formatNumber = function formatNumber(match, value, len) {\n        var num = \"\" + value;\n\n        if (lookAhead(match)) {\n          while (num.length < len) {\n            num = \"0\" + num;\n          }\n        }\n\n        return num;\n      },\n          // Format a name, short or long as requested\n      formatName = function formatName(match, value, shortNames, longNames) {\n        return lookAhead(match) ? longNames[value] : shortNames[value];\n      },\n          output = \"\",\n          literal = false;\n\n      if (date) {\n        for (iFormat = 0; iFormat < format.length; iFormat++) {\n          if (literal) {\n            if (format.charAt(iFormat) === \"'\" && !lookAhead(\"'\")) {\n              literal = false;\n            } else {\n              output += format.charAt(iFormat);\n            }\n          } else {\n            switch (format.charAt(iFormat)) {\n              case \"d\":\n                output += formatNumber(\"d\", date.getDate(), 2);\n                break;\n\n              case \"D\":\n                output += formatName(\"D\", date.getDay(), dayNamesShort, dayNames);\n                break;\n\n              case \"o\":\n                output += formatNumber(\"o\", Math.round((new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 86400000), 3);\n                break;\n\n              case \"m\":\n                output += formatNumber(\"m\", date.getMonth() + 1, 2);\n                break;\n\n              case \"M\":\n                output += formatName(\"M\", date.getMonth(), monthNamesShort, monthNames);\n                break;\n\n              case \"y\":\n                output += lookAhead(\"y\") ? date.getFullYear() : (date.getYear() % 100 < 10 ? \"0\" : \"\") + date.getYear() % 100;\n                break;\n\n              case \"@\":\n                output += date.getTime();\n                break;\n\n              case \"!\":\n                output += date.getTime() * 10000 + this._ticksTo1970;\n                break;\n\n              case \"'\":\n                if (lookAhead(\"'\")) {\n                  output += \"'\";\n                } else {\n                  literal = true;\n                }\n\n                break;\n\n              default:\n                output += format.charAt(iFormat);\n            }\n          }\n        }\n      }\n\n      return output;\n    },\n\n    /* Extract all possible characters from the date format. */\n    _possibleChars: function _possibleChars(format) {\n      var iFormat,\n          chars = \"\",\n          literal = false,\n          // Check whether a format character is doubled\n      lookAhead = function lookAhead(match) {\n        var matches = iFormat + 1 < format.length && format.charAt(iFormat + 1) === match;\n\n        if (matches) {\n          iFormat++;\n        }\n\n        return matches;\n      };\n\n      for (iFormat = 0; iFormat < format.length; iFormat++) {\n        if (literal) {\n          if (format.charAt(iFormat) === \"'\" && !lookAhead(\"'\")) {\n            literal = false;\n          } else {\n            chars += format.charAt(iFormat);\n          }\n        } else {\n          switch (format.charAt(iFormat)) {\n            case \"d\":\n            case \"m\":\n            case \"y\":\n            case \"@\":\n              chars += \"0123456789\";\n              break;\n\n            case \"D\":\n            case \"M\":\n              return null;\n            // Accept anything\n\n            case \"'\":\n              if (lookAhead(\"'\")) {\n                chars += \"'\";\n              } else {\n                literal = true;\n              }\n\n              break;\n\n            default:\n              chars += format.charAt(iFormat);\n          }\n        }\n      }\n\n      return chars;\n    },\n\n    /* Get a setting value, defaulting if necessary. */\n    _get: function _get(inst, name) {\n      return inst.settings[name] !== undefined ? inst.settings[name] : this._defaults[name];\n    },\n\n    /* Parse existing date and initialise date picker. */\n    _setDateFromField: function _setDateFromField(inst, noDefault) {\n      if (inst.input.val() === inst.lastVal) {\n        return;\n      }\n\n      var dateFormat = this._get(inst, \"dateFormat\"),\n          dates = inst.lastVal = inst.input ? inst.input.val() : null,\n          defaultDate = this._getDefaultDate(inst),\n          date = defaultDate,\n          settings = this._getFormatConfig(inst);\n\n      try {\n        date = this.parseDate(dateFormat, dates, settings) || defaultDate;\n      } catch (event) {\n        dates = noDefault ? \"\" : dates;\n      }\n\n      inst.selectedDay = date.getDate();\n      inst.drawMonth = inst.selectedMonth = date.getMonth();\n      inst.drawYear = inst.selectedYear = date.getFullYear();\n      inst.currentDay = dates ? date.getDate() : 0;\n      inst.currentMonth = dates ? date.getMonth() : 0;\n      inst.currentYear = dates ? date.getFullYear() : 0;\n\n      this._adjustInstDate(inst);\n    },\n\n    /* Retrieve the default date shown on opening. */\n    _getDefaultDate: function _getDefaultDate(inst) {\n      return this._restrictMinMax(inst, this._determineDate(inst, this._get(inst, \"defaultDate\"), new Date()));\n    },\n\n    /* A date may be specified as an exact value or a relative one. */\n    _determineDate: function _determineDate(inst, date, defaultDate) {\n      var offsetNumeric = function offsetNumeric(offset) {\n        var date = new Date();\n        date.setDate(date.getDate() + offset);\n        return date;\n      },\n          offsetString = function offsetString(offset) {\n        try {\n          return $.datepicker.parseDate($.datepicker._get(inst, \"dateFormat\"), offset, $.datepicker._getFormatConfig(inst));\n        } catch (e) {// Ignore\n        }\n\n        var date = (offset.toLowerCase().match(/^c/) ? $.datepicker._getDate(inst) : null) || new Date(),\n            year = date.getFullYear(),\n            month = date.getMonth(),\n            day = date.getDate(),\n            pattern = /([+\\-]?[0-9]+)\\s*(d|D|w|W|m|M|y|Y)?/g,\n            matches = pattern.exec(offset);\n\n        while (matches) {\n          switch (matches[2] || \"d\") {\n            case \"d\":\n            case \"D\":\n              day += parseInt(matches[1], 10);\n              break;\n\n            case \"w\":\n            case \"W\":\n              day += parseInt(matches[1], 10) * 7;\n              break;\n\n            case \"m\":\n            case \"M\":\n              month += parseInt(matches[1], 10);\n              day = Math.min(day, $.datepicker._getDaysInMonth(year, month));\n              break;\n\n            case \"y\":\n            case \"Y\":\n              year += parseInt(matches[1], 10);\n              day = Math.min(day, $.datepicker._getDaysInMonth(year, month));\n              break;\n          }\n\n          matches = pattern.exec(offset);\n        }\n\n        return new Date(year, month, day);\n      },\n          newDate = date == null || date === \"\" ? defaultDate : typeof date === \"string\" ? offsetString(date) : typeof date === \"number\" ? isNaN(date) ? defaultDate : offsetNumeric(date) : new Date(date.getTime());\n\n      newDate = newDate && newDate.toString() === \"Invalid Date\" ? defaultDate : newDate;\n\n      if (newDate) {\n        newDate.setHours(0);\n        newDate.setMinutes(0);\n        newDate.setSeconds(0);\n        newDate.setMilliseconds(0);\n      }\n\n      return this._daylightSavingAdjust(newDate);\n    },\n\n    /* Handle switch to/from daylight saving.\n     * Hours may be non-zero on daylight saving cut-over:\n     * > 12 when midnight changeover, but then cannot generate\n     * midnight datetime, so jump to 1AM, otherwise reset.\n     * @param  date  (Date) the date to check\n     * @return  (Date) the corrected date\n     */\n    _daylightSavingAdjust: function _daylightSavingAdjust(date) {\n      if (!date) {\n        return null;\n      }\n\n      date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);\n      return date;\n    },\n\n    /* Set the date(s) directly. */\n    _setDate: function _setDate(inst, date, noChange) {\n      var clear = !date,\n          origMonth = inst.selectedMonth,\n          origYear = inst.selectedYear,\n          newDate = this._restrictMinMax(inst, this._determineDate(inst, date, new Date()));\n\n      inst.selectedDay = inst.currentDay = newDate.getDate();\n      inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();\n      inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();\n\n      if ((origMonth !== inst.selectedMonth || origYear !== inst.selectedYear) && !noChange) {\n        this._notifyChange(inst);\n      }\n\n      this._adjustInstDate(inst);\n\n      if (inst.input) {\n        inst.input.val(clear ? \"\" : this._formatDate(inst));\n      }\n    },\n\n    /* Retrieve the date(s) directly. */\n    _getDate: function _getDate(inst) {\n      var startDate = !inst.currentYear || inst.input && inst.input.val() === \"\" ? null : this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay));\n      return startDate;\n    },\n\n    /* Attach the onxxx handlers.  These are declared statically so\n     * they work with static code transformers like Caja.\n     */\n    _attachHandlers: function _attachHandlers(inst) {\n      var stepMonths = this._get(inst, \"stepMonths\"),\n          id = \"#\" + inst.id.replace(/\\\\\\\\/g, \"\\\\\");\n\n      inst.dpDiv.find(\"[data-handler]\").map(function () {\n        var handler = {\n          prev: function prev() {\n            $.datepicker._adjustDate(id, -stepMonths, \"M\");\n          },\n          next: function next() {\n            $.datepicker._adjustDate(id, +stepMonths, \"M\");\n          },\n          hide: function hide() {\n            $.datepicker._hideDatepicker();\n          },\n          today: function today() {\n            $.datepicker._gotoToday(id);\n          },\n          selectDay: function selectDay() {\n            $.datepicker._selectDay(id, +this.getAttribute(\"data-month\"), +this.getAttribute(\"data-year\"), this);\n\n            return false;\n          },\n          selectMonth: function selectMonth() {\n            $.datepicker._selectMonthYear(id, this, \"M\");\n\n            return false;\n          },\n          selectYear: function selectYear() {\n            $.datepicker._selectMonthYear(id, this, \"Y\");\n\n            return false;\n          }\n        };\n        $(this).bind(this.getAttribute(\"data-event\"), handler[this.getAttribute(\"data-handler\")]);\n      });\n    },\n\n    /* Generate the HTML for the current state of the date picker. */\n    _generateHTML: function _generateHTML(inst) {\n      var maxDraw,\n          prevText,\n          prev,\n          nextText,\n          next,\n          currentText,\n          gotoDate,\n          controls,\n          buttonPanel,\n          firstDay,\n          showWeek,\n          dayNames,\n          dayNamesMin,\n          monthNames,\n          monthNamesShort,\n          beforeShowDay,\n          showOtherMonths,\n          selectOtherMonths,\n          defaultDate,\n          html,\n          dow,\n          row,\n          group,\n          col,\n          selectedDate,\n          cornerClass,\n          calender,\n          thead,\n          day,\n          daysInMonth,\n          leadDays,\n          curRows,\n          numRows,\n          printDate,\n          dRow,\n          tbody,\n          daySettings,\n          otherMonth,\n          unselectable,\n          tempDate = new Date(),\n          today = this._daylightSavingAdjust(new Date(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate())),\n          // clear time\n      isRTL = this._get(inst, \"isRTL\"),\n          showButtonPanel = this._get(inst, \"showButtonPanel\"),\n          hideIfNoPrevNext = this._get(inst, \"hideIfNoPrevNext\"),\n          navigationAsDateFormat = this._get(inst, \"navigationAsDateFormat\"),\n          numMonths = this._getNumberOfMonths(inst),\n          showCurrentAtPos = this._get(inst, \"showCurrentAtPos\"),\n          stepMonths = this._get(inst, \"stepMonths\"),\n          isMultiMonth = numMonths[0] !== 1 || numMonths[1] !== 1,\n          currentDate = this._daylightSavingAdjust(!inst.currentDay ? new Date(9999, 9, 9) : new Date(inst.currentYear, inst.currentMonth, inst.currentDay)),\n          minDate = this._getMinMaxDate(inst, \"min\"),\n          maxDate = this._getMinMaxDate(inst, \"max\"),\n          drawMonth = inst.drawMonth - showCurrentAtPos,\n          drawYear = inst.drawYear;\n\n      if (drawMonth < 0) {\n        drawMonth += 12;\n        drawYear--;\n      }\n\n      if (maxDate) {\n        maxDraw = this._daylightSavingAdjust(new Date(maxDate.getFullYear(), maxDate.getMonth() - numMonths[0] * numMonths[1] + 1, maxDate.getDate()));\n        maxDraw = minDate && maxDraw < minDate ? minDate : maxDraw;\n\n        while (this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1)) > maxDraw) {\n          drawMonth--;\n\n          if (drawMonth < 0) {\n            drawMonth = 11;\n            drawYear--;\n          }\n        }\n      }\n\n      inst.drawMonth = drawMonth;\n      inst.drawYear = drawYear;\n      prevText = this._get(inst, \"prevText\");\n      prevText = !navigationAsDateFormat ? prevText : this.formatDate(prevText, this._daylightSavingAdjust(new Date(drawYear, drawMonth - stepMonths, 1)), this._getFormatConfig(inst));\n      prev = this._canAdjustMonth(inst, -1, drawYear, drawMonth) ? \"<a class='ui-datepicker-prev ui-corner-all' data-handler='prev' data-event='click'\" + \" title='\" + prevText + \"'><span class='ui-icon ui-icon-circle-triangle-\" + (isRTL ? \"e\" : \"w\") + \"'>\" + prevText + \"</span></a>\" : hideIfNoPrevNext ? \"\" : \"<a class='ui-datepicker-prev ui-corner-all ui-state-disabled' title='\" + prevText + \"'><span class='ui-icon ui-icon-circle-triangle-\" + (isRTL ? \"e\" : \"w\") + \"'>\" + prevText + \"</span></a>\";\n      nextText = this._get(inst, \"nextText\");\n      nextText = !navigationAsDateFormat ? nextText : this.formatDate(nextText, this._daylightSavingAdjust(new Date(drawYear, drawMonth + stepMonths, 1)), this._getFormatConfig(inst));\n      next = this._canAdjustMonth(inst, +1, drawYear, drawMonth) ? \"<a class='ui-datepicker-next ui-corner-all' data-handler='next' data-event='click'\" + \" title='\" + nextText + \"'><span class='ui-icon ui-icon-circle-triangle-\" + (isRTL ? \"w\" : \"e\") + \"'>\" + nextText + \"</span></a>\" : hideIfNoPrevNext ? \"\" : \"<a class='ui-datepicker-next ui-corner-all ui-state-disabled' title='\" + nextText + \"'><span class='ui-icon ui-icon-circle-triangle-\" + (isRTL ? \"w\" : \"e\") + \"'>\" + nextText + \"</span></a>\";\n      currentText = this._get(inst, \"currentText\");\n      gotoDate = this._get(inst, \"gotoCurrent\") && inst.currentDay ? currentDate : today;\n      currentText = !navigationAsDateFormat ? currentText : this.formatDate(currentText, gotoDate, this._getFormatConfig(inst));\n      controls = !inst.inline ? \"<button type='button' class='ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all' data-handler='hide' data-event='click'>\" + this._get(inst, \"closeText\") + \"</button>\" : \"\";\n      buttonPanel = showButtonPanel ? \"<div class='ui-datepicker-buttonpane ui-widget-content'>\" + (isRTL ? controls : \"\") + (this._isInRange(inst, gotoDate) ? \"<button type='button' class='ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all' data-handler='today' data-event='click'\" + \">\" + currentText + \"</button>\" : \"\") + (isRTL ? \"\" : controls) + \"</div>\" : \"\";\n      firstDay = parseInt(this._get(inst, \"firstDay\"), 10);\n      firstDay = isNaN(firstDay) ? 0 : firstDay;\n      showWeek = this._get(inst, \"showWeek\");\n      dayNames = this._get(inst, \"dayNames\");\n      dayNamesMin = this._get(inst, \"dayNamesMin\");\n      monthNames = this._get(inst, \"monthNames\");\n      monthNamesShort = this._get(inst, \"monthNamesShort\");\n      beforeShowDay = this._get(inst, \"beforeShowDay\");\n      showOtherMonths = this._get(inst, \"showOtherMonths\");\n      selectOtherMonths = this._get(inst, \"selectOtherMonths\");\n      defaultDate = this._getDefaultDate(inst);\n      html = \"\";\n      dow;\n\n      for (row = 0; row < numMonths[0]; row++) {\n        group = \"\";\n        this.maxRows = 4;\n\n        for (col = 0; col < numMonths[1]; col++) {\n          selectedDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, inst.selectedDay));\n          cornerClass = \" ui-corner-all\";\n          calender = \"\";\n\n          if (isMultiMonth) {\n            calender += \"<div class='ui-datepicker-group\";\n\n            if (numMonths[1] > 1) {\n              switch (col) {\n                case 0:\n                  calender += \" ui-datepicker-group-first\";\n                  cornerClass = \" ui-corner-\" + (isRTL ? \"right\" : \"left\");\n                  break;\n\n                case numMonths[1] - 1:\n                  calender += \" ui-datepicker-group-last\";\n                  cornerClass = \" ui-corner-\" + (isRTL ? \"left\" : \"right\");\n                  break;\n\n                default:\n                  calender += \" ui-datepicker-group-middle\";\n                  cornerClass = \"\";\n                  break;\n              }\n            }\n\n            calender += \"'>\";\n          }\n\n          calender += \"<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix\" + cornerClass + \"'>\" + (/all|left/.test(cornerClass) && row === 0 ? isRTL ? next : prev : \"\") + (/all|right/.test(cornerClass) && row === 0 ? isRTL ? prev : next : \"\") + this._generateMonthYearHeader(inst, drawMonth, drawYear, minDate, maxDate, row > 0 || col > 0, monthNames, monthNamesShort) + // draw month headers\n          \"</div><table class='ui-datepicker-calendar'><thead>\" + \"<tr>\";\n          thead = showWeek ? \"<th class='ui-datepicker-week-col'>\" + this._get(inst, \"weekHeader\") + \"</th>\" : \"\";\n\n          for (dow = 0; dow < 7; dow++) {\n            // days of the week\n            day = (dow + firstDay) % 7;\n            thead += \"<th scope='col'\" + ((dow + firstDay + 6) % 7 >= 5 ? \" class='ui-datepicker-week-end'\" : \"\") + \">\" + \"<span title='\" + dayNames[day] + \"'>\" + dayNamesMin[day] + \"</span></th>\";\n          }\n\n          calender += thead + \"</tr></thead><tbody>\";\n          daysInMonth = this._getDaysInMonth(drawYear, drawMonth);\n\n          if (drawYear === inst.selectedYear && drawMonth === inst.selectedMonth) {\n            inst.selectedDay = Math.min(inst.selectedDay, daysInMonth);\n          }\n\n          leadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7;\n          curRows = Math.ceil((leadDays + daysInMonth) / 7); // calculate the number of rows to generate\n\n          numRows = isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows; //If multiple months, use the higher number of rows (see #7043)\n\n          this.maxRows = numRows;\n          printDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1 - leadDays));\n\n          for (dRow = 0; dRow < numRows; dRow++) {\n            // create date picker rows\n            calender += \"<tr>\";\n            tbody = !showWeek ? \"\" : \"<td class='ui-datepicker-week-col'>\" + this._get(inst, \"calculateWeek\")(printDate) + \"</td>\";\n\n            for (dow = 0; dow < 7; dow++) {\n              // create date picker days\n              daySettings = beforeShowDay ? beforeShowDay.apply(inst.input ? inst.input[0] : null, [printDate]) : [true, \"\"];\n              otherMonth = printDate.getMonth() !== drawMonth;\n              unselectable = otherMonth && !selectOtherMonths || !daySettings[0] || minDate && printDate < minDate || maxDate && printDate > maxDate;\n              tbody += \"<td class='\" + ((dow + firstDay + 6) % 7 >= 5 ? \" ui-datepicker-week-end\" : \"\") + ( // highlight weekends\n              otherMonth ? \" ui-datepicker-other-month\" : \"\") + ( // highlight days from other months\n              printDate.getTime() === selectedDate.getTime() && drawMonth === inst.selectedMonth && inst._keyEvent || // user pressed key\n              defaultDate.getTime() === printDate.getTime() && defaultDate.getTime() === selectedDate.getTime() ? // or defaultDate is current printedDate and defaultDate is selectedDate\n              \" \" + this._dayOverClass : \"\") + ( // highlight selected day\n              unselectable ? \" \" + this._unselectableClass + \" ui-state-disabled\" : \"\") + ( // highlight unselectable days\n              otherMonth && !showOtherMonths ? \"\" : \" \" + daySettings[1] + ( // highlight custom dates\n              printDate.getTime() === currentDate.getTime() ? \" \" + this._currentClass : \"\") + ( // highlight selected day\n              printDate.getTime() === today.getTime() ? \" ui-datepicker-today\" : \"\")) + \"'\" + ( // highlight today (if different)\n              (!otherMonth || showOtherMonths) && daySettings[2] ? \" title='\" + daySettings[2].replace(/'/g, \"&#39;\") + \"'\" : \"\") + ( // cell title\n              unselectable ? \"\" : \" data-handler='selectDay' data-event='click' data-month='\" + printDate.getMonth() + \"' data-year='\" + printDate.getFullYear() + \"'\") + \">\" + ( // actions\n              otherMonth && !showOtherMonths ? \"&#xa0;\" : // display for other months\n              unselectable ? \"<span class='ui-state-default'>\" + printDate.getDate() + \"</span>\" : \"<a class='ui-state-default\" + (printDate.getTime() === today.getTime() ? \" ui-state-highlight\" : \"\") + (printDate.getTime() === currentDate.getTime() ? \" ui-state-active\" : \"\") + ( // highlight selected day\n              otherMonth ? \" ui-priority-secondary\" : \"\") + // distinguish dates from other months\n              \"' href='#'>\" + printDate.getDate() + \"</a>\") + \"</td>\"; // display selectable date\n\n              printDate.setDate(printDate.getDate() + 1);\n              printDate = this._daylightSavingAdjust(printDate);\n            }\n\n            calender += tbody + \"</tr>\";\n          }\n\n          drawMonth++;\n\n          if (drawMonth > 11) {\n            drawMonth = 0;\n            drawYear++;\n          }\n\n          calender += \"</tbody></table>\" + (isMultiMonth ? \"</div>\" + (numMonths[0] > 0 && col === numMonths[1] - 1 ? \"<div class='ui-datepicker-row-break'></div>\" : \"\") : \"\");\n          group += calender;\n        }\n\n        html += group;\n      }\n\n      html += buttonPanel;\n      inst._keyEvent = false;\n      return html;\n    },\n\n    /* Generate the month and year header. */\n    _generateMonthYearHeader: function _generateMonthYearHeader(inst, drawMonth, drawYear, minDate, maxDate, secondary, monthNames, monthNamesShort) {\n      var inMinYear,\n          inMaxYear,\n          month,\n          years,\n          thisYear,\n          determineYear,\n          year,\n          endYear,\n          changeMonth = this._get(inst, \"changeMonth\"),\n          changeYear = this._get(inst, \"changeYear\"),\n          showMonthAfterYear = this._get(inst, \"showMonthAfterYear\"),\n          html = \"<div class='ui-datepicker-title'>\",\n          monthHtml = \"\"; // month selection\n\n\n      if (secondary || !changeMonth) {\n        monthHtml += \"<span class='ui-datepicker-month'>\" + monthNames[drawMonth] + \"</span>\";\n      } else {\n        inMinYear = minDate && minDate.getFullYear() === drawYear;\n        inMaxYear = maxDate && maxDate.getFullYear() === drawYear;\n        monthHtml += \"<select class='ui-datepicker-month' data-handler='selectMonth' data-event='change'>\";\n\n        for (month = 0; month < 12; month++) {\n          if ((!inMinYear || month >= minDate.getMonth()) && (!inMaxYear || month <= maxDate.getMonth())) {\n            monthHtml += \"<option value='\" + month + \"'\" + (month === drawMonth ? \" selected='selected'\" : \"\") + \">\" + monthNamesShort[month] + \"</option>\";\n          }\n        }\n\n        monthHtml += \"</select>\";\n      }\n\n      if (!showMonthAfterYear) {\n        html += monthHtml + (secondary || !(changeMonth && changeYear) ? \"&#xa0;\" : \"\");\n      } // year selection\n\n\n      if (!inst.yearshtml) {\n        inst.yearshtml = \"\";\n\n        if (secondary || !changeYear) {\n          html += \"<span class='ui-datepicker-year'>\" + drawYear + \"</span>\";\n        } else {\n          // determine range of years to display\n          years = this._get(inst, \"yearRange\").split(\":\");\n          thisYear = new Date().getFullYear();\n\n          determineYear = function determineYear(value) {\n            var year = value.match(/c[+\\-].*/) ? drawYear + parseInt(value.substring(1), 10) : value.match(/[+\\-].*/) ? thisYear + parseInt(value, 10) : parseInt(value, 10);\n            return isNaN(year) ? thisYear : year;\n          };\n\n          year = determineYear(years[0]);\n          endYear = Math.max(year, determineYear(years[1] || \"\"));\n          year = minDate ? Math.max(year, minDate.getFullYear()) : year;\n          endYear = maxDate ? Math.min(endYear, maxDate.getFullYear()) : endYear;\n          inst.yearshtml += \"<select class='ui-datepicker-year' data-handler='selectYear' data-event='change'>\";\n\n          for (; year <= endYear; year++) {\n            inst.yearshtml += \"<option value='\" + year + \"'\" + (year === drawYear ? \" selected='selected'\" : \"\") + \">\" + year + \"</option>\";\n          }\n\n          inst.yearshtml += \"</select>\";\n          html += inst.yearshtml;\n          inst.yearshtml = null;\n        }\n      }\n\n      html += this._get(inst, \"yearSuffix\");\n\n      if (showMonthAfterYear) {\n        html += (secondary || !(changeMonth && changeYear) ? \"&#xa0;\" : \"\") + monthHtml;\n      }\n\n      html += \"</div>\"; // Close datepicker_header\n\n      return html;\n    },\n\n    /* Adjust one of the date sub-fields. */\n    _adjustInstDate: function _adjustInstDate(inst, offset, period) {\n      var year = inst.drawYear + (period === \"Y\" ? offset : 0),\n          month = inst.drawMonth + (period === \"M\" ? offset : 0),\n          day = Math.min(inst.selectedDay, this._getDaysInMonth(year, month)) + (period === \"D\" ? offset : 0),\n          date = this._restrictMinMax(inst, this._daylightSavingAdjust(new Date(year, month, day)));\n\n      inst.selectedDay = date.getDate();\n      inst.drawMonth = inst.selectedMonth = date.getMonth();\n      inst.drawYear = inst.selectedYear = date.getFullYear();\n\n      if (period === \"M\" || period === \"Y\") {\n        this._notifyChange(inst);\n      }\n    },\n\n    /* Ensure a date is within any min/max bounds. */\n    _restrictMinMax: function _restrictMinMax(inst, date) {\n      var minDate = this._getMinMaxDate(inst, \"min\"),\n          maxDate = this._getMinMaxDate(inst, \"max\"),\n          newDate = minDate && date < minDate ? minDate : date;\n\n      return maxDate && newDate > maxDate ? maxDate : newDate;\n    },\n\n    /* Notify change of month/year. */\n    _notifyChange: function _notifyChange(inst) {\n      var onChange = this._get(inst, \"onChangeMonthYear\");\n\n      if (onChange) {\n        onChange.apply(inst.input ? inst.input[0] : null, [inst.selectedYear, inst.selectedMonth + 1, inst]);\n      }\n    },\n\n    /* Determine the number of months to show. */\n    _getNumberOfMonths: function _getNumberOfMonths(inst) {\n      var numMonths = this._get(inst, \"numberOfMonths\");\n\n      return numMonths == null ? [1, 1] : typeof numMonths === \"number\" ? [1, numMonths] : numMonths;\n    },\n\n    /* Determine the current maximum date - ensure no time components are set. */\n    _getMinMaxDate: function _getMinMaxDate(inst, minMax) {\n      return this._determineDate(inst, this._get(inst, minMax + \"Date\"), null);\n    },\n\n    /* Find the number of days in a given month. */\n    _getDaysInMonth: function _getDaysInMonth(year, month) {\n      return 32 - this._daylightSavingAdjust(new Date(year, month, 32)).getDate();\n    },\n\n    /* Find the day of the week of the first of a month. */\n    _getFirstDayOfMonth: function _getFirstDayOfMonth(year, month) {\n      return new Date(year, month, 1).getDay();\n    },\n\n    /* Determines if we should allow a \"next/prev\" month display change. */\n    _canAdjustMonth: function _canAdjustMonth(inst, offset, curYear, curMonth) {\n      var numMonths = this._getNumberOfMonths(inst),\n          date = this._daylightSavingAdjust(new Date(curYear, curMonth + (offset < 0 ? offset : numMonths[0] * numMonths[1]), 1));\n\n      if (offset < 0) {\n        date.setDate(this._getDaysInMonth(date.getFullYear(), date.getMonth()));\n      }\n\n      return this._isInRange(inst, date);\n    },\n\n    /* Is the given date in the accepted range? */\n    _isInRange: function _isInRange(inst, date) {\n      var yearSplit,\n          currentYear,\n          minDate = this._getMinMaxDate(inst, \"min\"),\n          maxDate = this._getMinMaxDate(inst, \"max\"),\n          minYear = null,\n          maxYear = null,\n          years = this._get(inst, \"yearRange\");\n\n      if (years) {\n        yearSplit = years.split(\":\");\n        currentYear = new Date().getFullYear();\n        minYear = parseInt(yearSplit[0], 10);\n        maxYear = parseInt(yearSplit[1], 10);\n\n        if (yearSplit[0].match(/[+\\-].*/)) {\n          minYear += currentYear;\n        }\n\n        if (yearSplit[1].match(/[+\\-].*/)) {\n          maxYear += currentYear;\n        }\n      }\n\n      return (!minDate || date.getTime() >= minDate.getTime()) && (!maxDate || date.getTime() <= maxDate.getTime()) && (!minYear || date.getFullYear() >= minYear) && (!maxYear || date.getFullYear() <= maxYear);\n    },\n\n    /* Provide the configuration settings for formatting/parsing. */\n    _getFormatConfig: function _getFormatConfig(inst) {\n      var shortYearCutoff = this._get(inst, \"shortYearCutoff\");\n\n      shortYearCutoff = typeof shortYearCutoff !== \"string\" ? shortYearCutoff : new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10);\n      return {\n        shortYearCutoff: shortYearCutoff,\n        dayNamesShort: this._get(inst, \"dayNamesShort\"),\n        dayNames: this._get(inst, \"dayNames\"),\n        monthNamesShort: this._get(inst, \"monthNamesShort\"),\n        monthNames: this._get(inst, \"monthNames\")\n      };\n    },\n\n    /* Format the given date for display. */\n    _formatDate: function _formatDate(inst, day, month, year) {\n      if (!day) {\n        inst.currentDay = inst.selectedDay;\n        inst.currentMonth = inst.selectedMonth;\n        inst.currentYear = inst.selectedYear;\n      }\n\n      var date = day ? _typeof(day) === \"object\" ? day : this._daylightSavingAdjust(new Date(year, month, day)) : this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay));\n      return this.formatDate(this._get(inst, \"dateFormat\"), date, this._getFormatConfig(inst));\n    }\n  });\n  /*\n   * Bind hover events for datepicker elements.\n   * Done via delegate so the binding only occurs once in the lifetime of the parent div.\n   * Global datepicker_instActive, set by _updateDatepicker allows the handlers to find their way back to the active picker.\n   */\n\n  function datepicker_bindHover(dpDiv) {\n    var selector = \"button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a\";\n    return dpDiv.delegate(selector, \"mouseout\", function () {\n      $(this).removeClass(\"ui-state-hover\");\n\n      if (this.className.indexOf(\"ui-datepicker-prev\") !== -1) {\n        $(this).removeClass(\"ui-datepicker-prev-hover\");\n      }\n\n      if (this.className.indexOf(\"ui-datepicker-next\") !== -1) {\n        $(this).removeClass(\"ui-datepicker-next-hover\");\n      }\n    }).delegate(selector, \"mouseover\", datepicker_handleMouseover);\n  }\n\n  function datepicker_handleMouseover() {\n    if (!$.datepicker._isDisabledDatepicker(datepicker_instActive.inline ? datepicker_instActive.dpDiv.parent()[0] : datepicker_instActive.input[0])) {\n      $(this).parents(\".ui-datepicker-calendar\").find(\"a\").removeClass(\"ui-state-hover\");\n      $(this).addClass(\"ui-state-hover\");\n\n      if (this.className.indexOf(\"ui-datepicker-prev\") !== -1) {\n        $(this).addClass(\"ui-datepicker-prev-hover\");\n      }\n\n      if (this.className.indexOf(\"ui-datepicker-next\") !== -1) {\n        $(this).addClass(\"ui-datepicker-next-hover\");\n      }\n    }\n  }\n  /* jQuery extend now ignores nulls! */\n\n\n  function datepicker_extendRemove(target, props) {\n    $.extend(target, props);\n\n    for (var name in props) {\n      if (props[name] == null) {\n        target[name] = props[name];\n      }\n    }\n\n    return target;\n  }\n  /* Invoke the datepicker functionality.\n     @param  options  string - a command, optionally followed by additional parameters or\n  \t\t\t\t\tObject - settings for attaching new datepicker functionality\n     @return  jQuery object */\n\n\n  $.fn.datepicker = function (options) {\n    /* Verify an empty collection wasn't passed - Fixes #6976 */\n    if (!this.length) {\n      return this;\n    }\n    /* Initialise the date picker. */\n\n\n    if (!$.datepicker.initialized) {\n      $(document).mousedown($.datepicker._checkExternalClick);\n      $.datepicker.initialized = true;\n    }\n    /* Append datepicker main container to body if not exist. */\n\n\n    if ($(\"#\" + $.datepicker._mainDivId).length === 0) {\n      $(\"body\").append($.datepicker.dpDiv);\n    }\n\n    var otherArgs = Array.prototype.slice.call(arguments, 1);\n\n    if (typeof options === \"string\" && (options === \"isDisabled\" || options === \"getDate\" || options === \"widget\")) {\n      return $.datepicker[\"_\" + options + \"Datepicker\"].apply($.datepicker, [this[0]].concat(otherArgs));\n    }\n\n    if (options === \"option\" && arguments.length === 2 && typeof arguments[1] === \"string\") {\n      return $.datepicker[\"_\" + options + \"Datepicker\"].apply($.datepicker, [this[0]].concat(otherArgs));\n    }\n\n    return this.each(function () {\n      typeof options === \"string\" ? $.datepicker[\"_\" + options + \"Datepicker\"].apply($.datepicker, [this].concat(otherArgs)) : $.datepicker._attachDatepicker(this, options);\n    });\n  };\n\n  $.datepicker = new Datepicker(); // singleton instance\n\n  $.datepicker.initialized = false;\n  $.datepicker.uuid = new Date().getTime();\n  $.datepicker.version = \"1.11.4\";\n  var datepicker = $.datepicker;\n  /*!\n   * jQuery UI Draggable 1.11.4\n   * http://jqueryui.com\n   *\n   * Copyright jQuery Foundation and other contributors\n   * Released under the MIT license.\n   * http://jquery.org/license\n   *\n   * http://api.jqueryui.com/draggable/\n   */\n\n  $.widget(\"ui.draggable\", $.ui.mouse, {\n    version: \"1.11.4\",\n    widgetEventPrefix: \"drag\",\n    options: {\n      addClasses: true,\n      appendTo: \"parent\",\n      axis: false,\n      connectToSortable: false,\n      containment: false,\n      cursor: \"auto\",\n      cursorAt: false,\n      grid: false,\n      handle: false,\n      helper: \"original\",\n      iframeFix: false,\n      opacity: false,\n      refreshPositions: false,\n      revert: false,\n      revertDuration: 500,\n      scope: \"default\",\n      scroll: true,\n      scrollSensitivity: 20,\n      scrollSpeed: 20,\n      snap: false,\n      snapMode: \"both\",\n      snapTolerance: 20,\n      stack: false,\n      zIndex: false,\n      // callbacks\n      drag: null,\n      start: null,\n      stop: null\n    },\n    _create: function _create() {\n      if (this.options.helper === \"original\") {\n        this._setPositionRelative();\n      }\n\n      if (this.options.addClasses) {\n        this.element.addClass(\"ui-draggable\");\n      }\n\n      if (this.options.disabled) {\n        this.element.addClass(\"ui-draggable-disabled\");\n      }\n\n      this._setHandleClassName();\n\n      this._mouseInit();\n    },\n    _setOption: function _setOption(key, value) {\n      this._super(key, value);\n\n      if (key === \"handle\") {\n        this._removeHandleClassName();\n\n        this._setHandleClassName();\n      }\n    },\n    _destroy: function _destroy() {\n      if ((this.helper || this.element).is(\".ui-draggable-dragging\")) {\n        this.destroyOnClear = true;\n        return;\n      }\n\n      this.element.removeClass(\"ui-draggable ui-draggable-dragging ui-draggable-disabled\");\n\n      this._removeHandleClassName();\n\n      this._mouseDestroy();\n    },\n    _mouseCapture: function _mouseCapture(event) {\n      var o = this.options;\n\n      this._blurActiveElement(event); // among others, prevent a drag on a resizable-handle\n\n\n      if (this.helper || o.disabled || $(event.target).closest(\".ui-resizable-handle\").length > 0) {\n        return false;\n      } //Quit if we're not on a valid handle\n\n\n      this.handle = this._getHandle(event);\n\n      if (!this.handle) {\n        return false;\n      }\n\n      this._blockFrames(o.iframeFix === true ? \"iframe\" : o.iframeFix);\n\n      return true;\n    },\n    _blockFrames: function _blockFrames(selector) {\n      this.iframeBlocks = this.document.find(selector).map(function () {\n        var iframe = $(this);\n        return $(\"<div>\").css(\"position\", \"absolute\").appendTo(iframe.parent()).outerWidth(iframe.outerWidth()).outerHeight(iframe.outerHeight()).offset(iframe.offset())[0];\n      });\n    },\n    _unblockFrames: function _unblockFrames() {\n      if (this.iframeBlocks) {\n        this.iframeBlocks.remove();\n        delete this.iframeBlocks;\n      }\n    },\n    _blurActiveElement: function _blurActiveElement(event) {\n      var document = this.document[0]; // Only need to blur if the event occurred on the draggable itself, see #10527\n\n      if (!this.handleElement.is(event.target)) {\n        return;\n      } // support: IE9\n      // IE9 throws an \"Unspecified error\" accessing document.activeElement from an <iframe>\n\n\n      try {\n        // Support: IE9, IE10\n        // If the <body> is blurred, IE will switch windows, see #9520\n        if (document.activeElement && document.activeElement.nodeName.toLowerCase() !== \"body\") {\n          // Blur any element that currently has focus, see #4261\n          $(document.activeElement).blur();\n        }\n      } catch (error) {}\n    },\n    _mouseStart: function _mouseStart(event) {\n      var o = this.options; //Create and append the visible helper\n\n      this.helper = this._createHelper(event);\n      this.helper.addClass(\"ui-draggable-dragging\"); //Cache the helper size\n\n      this._cacheHelperProportions(); //If ddmanager is used for droppables, set the global draggable\n\n\n      if ($.ui.ddmanager) {\n        $.ui.ddmanager.current = this;\n      }\n      /*\n       * - Position generation -\n       * This block generates everything position related - it's the core of draggables.\n       */\n      //Cache the margins of the original element\n\n\n      this._cacheMargins(); //Store the helper's css position\n\n\n      this.cssPosition = this.helper.css(\"position\");\n      this.scrollParent = this.helper.scrollParent(true);\n      this.offsetParent = this.helper.offsetParent();\n      this.hasFixedAncestor = this.helper.parents().filter(function () {\n        return $(this).css(\"position\") === \"fixed\";\n      }).length > 0; //The element's absolute position on the page minus margins\n\n      this.positionAbs = this.element.offset();\n\n      this._refreshOffsets(event); //Generate the original position\n\n\n      this.originalPosition = this.position = this._generatePosition(event, false);\n      this.originalPageX = event.pageX;\n      this.originalPageY = event.pageY; //Adjust the mouse offset relative to the helper if \"cursorAt\" is supplied\n\n      o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt); //Set a containment if given in the options\n\n      this._setContainment(); //Trigger event + callbacks\n\n\n      if (this._trigger(\"start\", event) === false) {\n        this._clear();\n\n        return false;\n      } //Recache the helper size\n\n\n      this._cacheHelperProportions(); //Prepare the droppable offsets\n\n\n      if ($.ui.ddmanager && !o.dropBehaviour) {\n        $.ui.ddmanager.prepareOffsets(this, event);\n      } // Reset helper's right/bottom css if they're set and set explicit width/height instead\n      // as this prevents resizing of elements with right/bottom set (see #7772)\n\n\n      this._normalizeRightBottom();\n\n      this._mouseDrag(event, true); //Execute the drag once - this causes the helper not to be visible before getting its correct position\n      //If the ddmanager is used for droppables, inform the manager that dragging has started (see #5003)\n\n\n      if ($.ui.ddmanager) {\n        $.ui.ddmanager.dragStart(this, event);\n      }\n\n      return true;\n    },\n    _refreshOffsets: function _refreshOffsets(event) {\n      this.offset = {\n        top: this.positionAbs.top - this.margins.top,\n        left: this.positionAbs.left - this.margins.left,\n        scroll: false,\n        parent: this._getParentOffset(),\n        relative: this._getRelativeOffset()\n      };\n      this.offset.click = {\n        left: event.pageX - this.offset.left,\n        top: event.pageY - this.offset.top\n      };\n    },\n    _mouseDrag: function _mouseDrag(event, noPropagation) {\n      // reset any necessary cached properties (see #5009)\n      if (this.hasFixedAncestor) {\n        this.offset.parent = this._getParentOffset();\n      } //Compute the helpers position\n\n\n      this.position = this._generatePosition(event, true);\n      this.positionAbs = this._convertPositionTo(\"absolute\"); //Call plugins and callbacks and use the resulting position if something is returned\n\n      if (!noPropagation) {\n        var ui = this._uiHash();\n\n        if (this._trigger(\"drag\", event, ui) === false) {\n          this._mouseUp({});\n\n          return false;\n        }\n\n        this.position = ui.position;\n      }\n\n      this.helper[0].style.left = this.position.left + \"px\";\n      this.helper[0].style.top = this.position.top + \"px\";\n\n      if ($.ui.ddmanager) {\n        $.ui.ddmanager.drag(this, event);\n      }\n\n      return false;\n    },\n    _mouseStop: function _mouseStop(event) {\n      //If we are using droppables, inform the manager about the drop\n      var that = this,\n          dropped = false;\n\n      if ($.ui.ddmanager && !this.options.dropBehaviour) {\n        dropped = $.ui.ddmanager.drop(this, event);\n      } //if a drop comes from outside (a sortable)\n\n\n      if (this.dropped) {\n        dropped = this.dropped;\n        this.dropped = false;\n      }\n\n      if (this.options.revert === \"invalid\" && !dropped || this.options.revert === \"valid\" && dropped || this.options.revert === true || $.isFunction(this.options.revert) && this.options.revert.call(this.element, dropped)) {\n        $(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function () {\n          if (that._trigger(\"stop\", event) !== false) {\n            that._clear();\n          }\n        });\n      } else {\n        if (this._trigger(\"stop\", event) !== false) {\n          this._clear();\n        }\n      }\n\n      return false;\n    },\n    _mouseUp: function _mouseUp(event) {\n      this._unblockFrames(); //If the ddmanager is used for droppables, inform the manager that dragging has stopped (see #5003)\n\n\n      if ($.ui.ddmanager) {\n        $.ui.ddmanager.dragStop(this, event);\n      } // Only need to focus if the event occurred on the draggable itself, see #10527\n\n\n      if (this.handleElement.is(event.target)) {\n        // The interaction is over; whether or not the click resulted in a drag, focus the element\n        this.element.focus();\n      }\n\n      return $.ui.mouse.prototype._mouseUp.call(this, event);\n    },\n    cancel: function cancel() {\n      if (this.helper.is(\".ui-draggable-dragging\")) {\n        this._mouseUp({});\n      } else {\n        this._clear();\n      }\n\n      return this;\n    },\n    _getHandle: function _getHandle(event) {\n      return this.options.handle ? !!$(event.target).closest(this.element.find(this.options.handle)).length : true;\n    },\n    _setHandleClassName: function _setHandleClassName() {\n      this.handleElement = this.options.handle ? this.element.find(this.options.handle) : this.element;\n      this.handleElement.addClass(\"ui-draggable-handle\");\n    },\n    _removeHandleClassName: function _removeHandleClassName() {\n      this.handleElement.removeClass(\"ui-draggable-handle\");\n    },\n    _createHelper: function _createHelper(event) {\n      var o = this.options,\n          helperIsFunction = $.isFunction(o.helper),\n          helper = helperIsFunction ? $(o.helper.apply(this.element[0], [event])) : o.helper === \"clone\" ? this.element.clone().removeAttr(\"id\") : this.element;\n\n      if (!helper.parents(\"body\").length) {\n        helper.appendTo(o.appendTo === \"parent\" ? this.element[0].parentNode : o.appendTo);\n      } // http://bugs.jqueryui.com/ticket/9446\n      // a helper function can return the original element\n      // which wouldn't have been set to relative in _create\n\n\n      if (helperIsFunction && helper[0] === this.element[0]) {\n        this._setPositionRelative();\n      }\n\n      if (helper[0] !== this.element[0] && !/(fixed|absolute)/.test(helper.css(\"position\"))) {\n        helper.css(\"position\", \"absolute\");\n      }\n\n      return helper;\n    },\n    _setPositionRelative: function _setPositionRelative() {\n      if (!/^(?:r|a|f)/.test(this.element.css(\"position\"))) {\n        this.element[0].style.position = \"relative\";\n      }\n    },\n    _adjustOffsetFromHelper: function _adjustOffsetFromHelper(obj) {\n      if (typeof obj === \"string\") {\n        obj = obj.split(\" \");\n      }\n\n      if ($.isArray(obj)) {\n        obj = {\n          left: +obj[0],\n          top: +obj[1] || 0\n        };\n      }\n\n      if (\"left\" in obj) {\n        this.offset.click.left = obj.left + this.margins.left;\n      }\n\n      if (\"right\" in obj) {\n        this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;\n      }\n\n      if (\"top\" in obj) {\n        this.offset.click.top = obj.top + this.margins.top;\n      }\n\n      if (\"bottom\" in obj) {\n        this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;\n      }\n    },\n    _isRootNode: function _isRootNode(element) {\n      return /(html|body)/i.test(element.tagName) || element === this.document[0];\n    },\n    _getParentOffset: function _getParentOffset() {\n      //Get the offsetParent and cache its position\n      var po = this.offsetParent.offset(),\n          document = this.document[0]; // This is a special case where we need to modify a offset calculated on start, since the following happened:\n      // 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent\n      // 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that\n      //    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag\n\n      if (this.cssPosition === \"absolute\" && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {\n        po.left += this.scrollParent.scrollLeft();\n        po.top += this.scrollParent.scrollTop();\n      }\n\n      if (this._isRootNode(this.offsetParent[0])) {\n        po = {\n          top: 0,\n          left: 0\n        };\n      }\n\n      return {\n        top: po.top + (parseInt(this.offsetParent.css(\"borderTopWidth\"), 10) || 0),\n        left: po.left + (parseInt(this.offsetParent.css(\"borderLeftWidth\"), 10) || 0)\n      };\n    },\n    _getRelativeOffset: function _getRelativeOffset() {\n      if (this.cssPosition !== \"relative\") {\n        return {\n          top: 0,\n          left: 0\n        };\n      }\n\n      var p = this.element.position(),\n          scrollIsRootNode = this._isRootNode(this.scrollParent[0]);\n\n      return {\n        top: p.top - (parseInt(this.helper.css(\"top\"), 10) || 0) + (!scrollIsRootNode ? this.scrollParent.scrollTop() : 0),\n        left: p.left - (parseInt(this.helper.css(\"left\"), 10) || 0) + (!scrollIsRootNode ? this.scrollParent.scrollLeft() : 0)\n      };\n    },\n    _cacheMargins: function _cacheMargins() {\n      this.margins = {\n        left: parseInt(this.element.css(\"marginLeft\"), 10) || 0,\n        top: parseInt(this.element.css(\"marginTop\"), 10) || 0,\n        right: parseInt(this.element.css(\"marginRight\"), 10) || 0,\n        bottom: parseInt(this.element.css(\"marginBottom\"), 10) || 0\n      };\n    },\n    _cacheHelperProportions: function _cacheHelperProportions() {\n      this.helperProportions = {\n        width: this.helper.outerWidth(),\n        height: this.helper.outerHeight()\n      };\n    },\n    _setContainment: function _setContainment() {\n      var isUserScrollable,\n          c,\n          ce,\n          o = this.options,\n          document = this.document[0];\n      this.relativeContainer = null;\n\n      if (!o.containment) {\n        this.containment = null;\n        return;\n      }\n\n      if (o.containment === \"window\") {\n        this.containment = [$(window).scrollLeft() - this.offset.relative.left - this.offset.parent.left, $(window).scrollTop() - this.offset.relative.top - this.offset.parent.top, $(window).scrollLeft() + $(window).width() - this.helperProportions.width - this.margins.left, $(window).scrollTop() + ($(window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top];\n        return;\n      }\n\n      if (o.containment === \"document\") {\n        this.containment = [0, 0, $(document).width() - this.helperProportions.width - this.margins.left, ($(document).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top];\n        return;\n      }\n\n      if (o.containment.constructor === Array) {\n        this.containment = o.containment;\n        return;\n      }\n\n      if (o.containment === \"parent\") {\n        o.containment = this.helper[0].parentNode;\n      }\n\n      c = $(o.containment);\n      ce = c[0];\n\n      if (!ce) {\n        return;\n      }\n\n      isUserScrollable = /(scroll|auto)/.test(c.css(\"overflow\"));\n      this.containment = [(parseInt(c.css(\"borderLeftWidth\"), 10) || 0) + (parseInt(c.css(\"paddingLeft\"), 10) || 0), (parseInt(c.css(\"borderTopWidth\"), 10) || 0) + (parseInt(c.css(\"paddingTop\"), 10) || 0), (isUserScrollable ? Math.max(ce.scrollWidth, ce.offsetWidth) : ce.offsetWidth) - (parseInt(c.css(\"borderRightWidth\"), 10) || 0) - (parseInt(c.css(\"paddingRight\"), 10) || 0) - this.helperProportions.width - this.margins.left - this.margins.right, (isUserScrollable ? Math.max(ce.scrollHeight, ce.offsetHeight) : ce.offsetHeight) - (parseInt(c.css(\"borderBottomWidth\"), 10) || 0) - (parseInt(c.css(\"paddingBottom\"), 10) || 0) - this.helperProportions.height - this.margins.top - this.margins.bottom];\n      this.relativeContainer = c;\n    },\n    _convertPositionTo: function _convertPositionTo(d, pos) {\n      if (!pos) {\n        pos = this.position;\n      }\n\n      var mod = d === \"absolute\" ? 1 : -1,\n          scrollIsRootNode = this._isRootNode(this.scrollParent[0]);\n\n      return {\n        top: pos.top + // The absolute mouse position\n        this.offset.relative.top * mod + // Only for relative positioned nodes: Relative offset from element to offset parent\n        this.offset.parent.top * mod - // The offsetParent's offset without borders (offset + border)\n        (this.cssPosition === \"fixed\" ? -this.offset.scroll.top : scrollIsRootNode ? 0 : this.offset.scroll.top) * mod,\n        left: pos.left + // The absolute mouse position\n        this.offset.relative.left * mod + // Only for relative positioned nodes: Relative offset from element to offset parent\n        this.offset.parent.left * mod - // The offsetParent's offset without borders (offset + border)\n        (this.cssPosition === \"fixed\" ? -this.offset.scroll.left : scrollIsRootNode ? 0 : this.offset.scroll.left) * mod\n      };\n    },\n    _generatePosition: function _generatePosition(event, constrainPosition) {\n      var containment,\n          co,\n          top,\n          left,\n          o = this.options,\n          scrollIsRootNode = this._isRootNode(this.scrollParent[0]),\n          pageX = event.pageX,\n          pageY = event.pageY; // Cache the scroll\n\n\n      if (!scrollIsRootNode || !this.offset.scroll) {\n        this.offset.scroll = {\n          top: this.scrollParent.scrollTop(),\n          left: this.scrollParent.scrollLeft()\n        };\n      }\n      /*\n       * - Position constraining -\n       * Constrain the position to a mix of grid, containment.\n       */\n      // If we are not dragging yet, we won't check for options\n\n\n      if (constrainPosition) {\n        if (this.containment) {\n          if (this.relativeContainer) {\n            co = this.relativeContainer.offset();\n            containment = [this.containment[0] + co.left, this.containment[1] + co.top, this.containment[2] + co.left, this.containment[3] + co.top];\n          } else {\n            containment = this.containment;\n          }\n\n          if (event.pageX - this.offset.click.left < containment[0]) {\n            pageX = containment[0] + this.offset.click.left;\n          }\n\n          if (event.pageY - this.offset.click.top < containment[1]) {\n            pageY = containment[1] + this.offset.click.top;\n          }\n\n          if (event.pageX - this.offset.click.left > containment[2]) {\n            pageX = containment[2] + this.offset.click.left;\n          }\n\n          if (event.pageY - this.offset.click.top > containment[3]) {\n            pageY = containment[3] + this.offset.click.top;\n          }\n        }\n\n        if (o.grid) {\n          //Check for grid elements set to 0 to prevent divide by 0 error causing invalid argument errors in IE (see ticket #6950)\n          top = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY;\n          pageY = containment ? top - this.offset.click.top >= containment[1] || top - this.offset.click.top > containment[3] ? top : top - this.offset.click.top >= containment[1] ? top - o.grid[1] : top + o.grid[1] : top;\n          left = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX;\n          pageX = containment ? left - this.offset.click.left >= containment[0] || left - this.offset.click.left > containment[2] ? left : left - this.offset.click.left >= containment[0] ? left - o.grid[0] : left + o.grid[0] : left;\n        }\n\n        if (o.axis === \"y\") {\n          pageX = this.originalPageX;\n        }\n\n        if (o.axis === \"x\") {\n          pageY = this.originalPageY;\n        }\n      }\n\n      return {\n        top: pageY - // The absolute mouse position\n        this.offset.click.top - // Click offset (relative to the element)\n        this.offset.relative.top - // Only for relative positioned nodes: Relative offset from element to offset parent\n        this.offset.parent.top + ( // The offsetParent's offset without borders (offset + border)\n        this.cssPosition === \"fixed\" ? -this.offset.scroll.top : scrollIsRootNode ? 0 : this.offset.scroll.top),\n        left: pageX - // The absolute mouse position\n        this.offset.click.left - // Click offset (relative to the element)\n        this.offset.relative.left - // Only for relative positioned nodes: Relative offset from element to offset parent\n        this.offset.parent.left + ( // The offsetParent's offset without borders (offset + border)\n        this.cssPosition === \"fixed\" ? -this.offset.scroll.left : scrollIsRootNode ? 0 : this.offset.scroll.left)\n      };\n    },\n    _clear: function _clear() {\n      this.helper.removeClass(\"ui-draggable-dragging\");\n\n      if (this.helper[0] !== this.element[0] && !this.cancelHelperRemoval) {\n        this.helper.remove();\n      }\n\n      this.helper = null;\n      this.cancelHelperRemoval = false;\n\n      if (this.destroyOnClear) {\n        this.destroy();\n      }\n    },\n    _normalizeRightBottom: function _normalizeRightBottom() {\n      if (this.options.axis !== \"y\" && this.helper.css(\"right\") !== \"auto\") {\n        this.helper.width(this.helper.width());\n        this.helper.css(\"right\", \"auto\");\n      }\n\n      if (this.options.axis !== \"x\" && this.helper.css(\"bottom\") !== \"auto\") {\n        this.helper.height(this.helper.height());\n        this.helper.css(\"bottom\", \"auto\");\n      }\n    },\n    // From now on bulk stuff - mainly helpers\n    _trigger: function _trigger(type, event, ui) {\n      ui = ui || this._uiHash();\n      $.ui.plugin.call(this, type, [event, ui, this], true); // Absolute position and offset (see #6884 ) have to be recalculated after plugins\n\n      if (/^(drag|start|stop)/.test(type)) {\n        this.positionAbs = this._convertPositionTo(\"absolute\");\n        ui.offset = this.positionAbs;\n      }\n\n      return $.Widget.prototype._trigger.call(this, type, event, ui);\n    },\n    plugins: {},\n    _uiHash: function _uiHash() {\n      return {\n        helper: this.helper,\n        position: this.position,\n        originalPosition: this.originalPosition,\n        offset: this.positionAbs\n      };\n    }\n  });\n  $.ui.plugin.add(\"draggable\", \"connectToSortable\", {\n    start: function start(event, ui, draggable) {\n      var uiSortable = $.extend({}, ui, {\n        item: draggable.element\n      });\n      draggable.sortables = [];\n      $(draggable.options.connectToSortable).each(function () {\n        var sortable = $(this).sortable(\"instance\");\n\n        if (sortable && !sortable.options.disabled) {\n          draggable.sortables.push(sortable); // refreshPositions is called at drag start to refresh the containerCache\n          // which is used in drag. This ensures it's initialized and synchronized\n          // with any changes that might have happened on the page since initialization.\n\n          sortable.refreshPositions();\n\n          sortable._trigger(\"activate\", event, uiSortable);\n        }\n      });\n    },\n    stop: function stop(event, ui, draggable) {\n      var uiSortable = $.extend({}, ui, {\n        item: draggable.element\n      });\n      draggable.cancelHelperRemoval = false;\n      $.each(draggable.sortables, function () {\n        var sortable = this;\n\n        if (sortable.isOver) {\n          sortable.isOver = 0; // Allow this sortable to handle removing the helper\n\n          draggable.cancelHelperRemoval = true;\n          sortable.cancelHelperRemoval = false; // Use _storedCSS To restore properties in the sortable,\n          // as this also handles revert (#9675) since the draggable\n          // may have modified them in unexpected ways (#8809)\n\n          sortable._storedCSS = {\n            position: sortable.placeholder.css(\"position\"),\n            top: sortable.placeholder.css(\"top\"),\n            left: sortable.placeholder.css(\"left\")\n          };\n\n          sortable._mouseStop(event); // Once drag has ended, the sortable should return to using\n          // its original helper, not the shared helper from draggable\n\n\n          sortable.options.helper = sortable.options._helper;\n        } else {\n          // Prevent this Sortable from removing the helper.\n          // However, don't set the draggable to remove the helper\n          // either as another connected Sortable may yet handle the removal.\n          sortable.cancelHelperRemoval = true;\n\n          sortable._trigger(\"deactivate\", event, uiSortable);\n        }\n      });\n    },\n    drag: function drag(event, ui, draggable) {\n      $.each(draggable.sortables, function () {\n        var innermostIntersecting = false,\n            sortable = this; // Copy over variables that sortable's _intersectsWith uses\n\n        sortable.positionAbs = draggable.positionAbs;\n        sortable.helperProportions = draggable.helperProportions;\n        sortable.offset.click = draggable.offset.click;\n\n        if (sortable._intersectsWith(sortable.containerCache)) {\n          innermostIntersecting = true;\n          $.each(draggable.sortables, function () {\n            // Copy over variables that sortable's _intersectsWith uses\n            this.positionAbs = draggable.positionAbs;\n            this.helperProportions = draggable.helperProportions;\n            this.offset.click = draggable.offset.click;\n\n            if (this !== sortable && this._intersectsWith(this.containerCache) && $.contains(sortable.element[0], this.element[0])) {\n              innermostIntersecting = false;\n            }\n\n            return innermostIntersecting;\n          });\n        }\n\n        if (innermostIntersecting) {\n          // If it intersects, we use a little isOver variable and set it once,\n          // so that the move-in stuff gets fired only once.\n          if (!sortable.isOver) {\n            sortable.isOver = 1; // Store draggable's parent in case we need to reappend to it later.\n\n            draggable._parent = ui.helper.parent();\n            sortable.currentItem = ui.helper.appendTo(sortable.element).data(\"ui-sortable-item\", true); // Store helper option to later restore it\n\n            sortable.options._helper = sortable.options.helper;\n\n            sortable.options.helper = function () {\n              return ui.helper[0];\n            }; // Fire the start events of the sortable with our passed browser event,\n            // and our own helper (so it doesn't create a new one)\n\n\n            event.target = sortable.currentItem[0];\n\n            sortable._mouseCapture(event, true);\n\n            sortable._mouseStart(event, true, true); // Because the browser event is way off the new appended portlet,\n            // modify necessary variables to reflect the changes\n\n\n            sortable.offset.click.top = draggable.offset.click.top;\n            sortable.offset.click.left = draggable.offset.click.left;\n            sortable.offset.parent.left -= draggable.offset.parent.left - sortable.offset.parent.left;\n            sortable.offset.parent.top -= draggable.offset.parent.top - sortable.offset.parent.top;\n\n            draggable._trigger(\"toSortable\", event); // Inform draggable that the helper is in a valid drop zone,\n            // used solely in the revert option to handle \"valid/invalid\".\n\n\n            draggable.dropped = sortable.element; // Need to refreshPositions of all sortables in the case that\n            // adding to one sortable changes the location of the other sortables (#9675)\n\n            $.each(draggable.sortables, function () {\n              this.refreshPositions();\n            }); // hack so receive/update callbacks work (mostly)\n\n            draggable.currentItem = draggable.element;\n            sortable.fromOutside = draggable;\n          }\n\n          if (sortable.currentItem) {\n            sortable._mouseDrag(event); // Copy the sortable's position because the draggable's can potentially reflect\n            // a relative position, while sortable is always absolute, which the dragged\n            // element has now become. (#8809)\n\n\n            ui.position = sortable.position;\n          }\n        } else {\n          // If it doesn't intersect with the sortable, and it intersected before,\n          // we fake the drag stop of the sortable, but make sure it doesn't remove\n          // the helper by using cancelHelperRemoval.\n          if (sortable.isOver) {\n            sortable.isOver = 0;\n            sortable.cancelHelperRemoval = true; // Calling sortable's mouseStop would trigger a revert,\n            // so revert must be temporarily false until after mouseStop is called.\n\n            sortable.options._revert = sortable.options.revert;\n            sortable.options.revert = false;\n\n            sortable._trigger(\"out\", event, sortable._uiHash(sortable));\n\n            sortable._mouseStop(event, true); // restore sortable behaviors that were modfied\n            // when the draggable entered the sortable area (#9481)\n\n\n            sortable.options.revert = sortable.options._revert;\n            sortable.options.helper = sortable.options._helper;\n\n            if (sortable.placeholder) {\n              sortable.placeholder.remove();\n            } // Restore and recalculate the draggable's offset considering the sortable\n            // may have modified them in unexpected ways. (#8809, #10669)\n\n\n            ui.helper.appendTo(draggable._parent);\n\n            draggable._refreshOffsets(event);\n\n            ui.position = draggable._generatePosition(event, true);\n\n            draggable._trigger(\"fromSortable\", event); // Inform draggable that the helper is no longer in a valid drop zone\n\n\n            draggable.dropped = false; // Need to refreshPositions of all sortables just in case removing\n            // from one sortable changes the location of other sortables (#9675)\n\n            $.each(draggable.sortables, function () {\n              this.refreshPositions();\n            });\n          }\n        }\n      });\n    }\n  });\n  $.ui.plugin.add(\"draggable\", \"cursor\", {\n    start: function start(event, ui, instance) {\n      var t = $(\"body\"),\n          o = instance.options;\n\n      if (t.css(\"cursor\")) {\n        o._cursor = t.css(\"cursor\");\n      }\n\n      t.css(\"cursor\", o.cursor);\n    },\n    stop: function stop(event, ui, instance) {\n      var o = instance.options;\n\n      if (o._cursor) {\n        $(\"body\").css(\"cursor\", o._cursor);\n      }\n    }\n  });\n  $.ui.plugin.add(\"draggable\", \"opacity\", {\n    start: function start(event, ui, instance) {\n      var t = $(ui.helper),\n          o = instance.options;\n\n      if (t.css(\"opacity\")) {\n        o._opacity = t.css(\"opacity\");\n      }\n\n      t.css(\"opacity\", o.opacity);\n    },\n    stop: function stop(event, ui, instance) {\n      var o = instance.options;\n\n      if (o._opacity) {\n        $(ui.helper).css(\"opacity\", o._opacity);\n      }\n    }\n  });\n  $.ui.plugin.add(\"draggable\", \"scroll\", {\n    start: function start(event, ui, i) {\n      if (!i.scrollParentNotHidden) {\n        i.scrollParentNotHidden = i.helper.scrollParent(false);\n      }\n\n      if (i.scrollParentNotHidden[0] !== i.document[0] && i.scrollParentNotHidden[0].tagName !== \"HTML\") {\n        i.overflowOffset = i.scrollParentNotHidden.offset();\n      }\n    },\n    drag: function drag(event, ui, i) {\n      var o = i.options,\n          scrolled = false,\n          scrollParent = i.scrollParentNotHidden[0],\n          document = i.document[0];\n\n      if (scrollParent !== document && scrollParent.tagName !== \"HTML\") {\n        if (!o.axis || o.axis !== \"x\") {\n          if (i.overflowOffset.top + scrollParent.offsetHeight - event.pageY < o.scrollSensitivity) {\n            scrollParent.scrollTop = scrolled = scrollParent.scrollTop + o.scrollSpeed;\n          } else if (event.pageY - i.overflowOffset.top < o.scrollSensitivity) {\n            scrollParent.scrollTop = scrolled = scrollParent.scrollTop - o.scrollSpeed;\n          }\n        }\n\n        if (!o.axis || o.axis !== \"y\") {\n          if (i.overflowOffset.left + scrollParent.offsetWidth - event.pageX < o.scrollSensitivity) {\n            scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft + o.scrollSpeed;\n          } else if (event.pageX - i.overflowOffset.left < o.scrollSensitivity) {\n            scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft - o.scrollSpeed;\n          }\n        }\n      } else {\n        if (!o.axis || o.axis !== \"x\") {\n          if (event.pageY - $(document).scrollTop() < o.scrollSensitivity) {\n            scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);\n          } else if ($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {\n            scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);\n          }\n        }\n\n        if (!o.axis || o.axis !== \"y\") {\n          if (event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {\n            scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);\n          } else if ($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {\n            scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);\n          }\n        }\n      }\n\n      if (scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {\n        $.ui.ddmanager.prepareOffsets(i, event);\n      }\n    }\n  });\n  $.ui.plugin.add(\"draggable\", \"snap\", {\n    start: function start(event, ui, i) {\n      var o = i.options;\n      i.snapElements = [];\n      $(o.snap.constructor !== String ? o.snap.items || \":data(ui-draggable)\" : o.snap).each(function () {\n        var $t = $(this),\n            $o = $t.offset();\n\n        if (this !== i.element[0]) {\n          i.snapElements.push({\n            item: this,\n            width: $t.outerWidth(),\n            height: $t.outerHeight(),\n            top: $o.top,\n            left: $o.left\n          });\n        }\n      });\n    },\n    drag: function drag(event, ui, inst) {\n      var ts,\n          bs,\n          ls,\n          rs,\n          l,\n          r,\n          t,\n          b,\n          i,\n          first,\n          o = inst.options,\n          d = o.snapTolerance,\n          x1 = ui.offset.left,\n          x2 = x1 + inst.helperProportions.width,\n          y1 = ui.offset.top,\n          y2 = y1 + inst.helperProportions.height;\n\n      for (i = inst.snapElements.length - 1; i >= 0; i--) {\n        l = inst.snapElements[i].left - inst.margins.left;\n        r = l + inst.snapElements[i].width;\n        t = inst.snapElements[i].top - inst.margins.top;\n        b = t + inst.snapElements[i].height;\n\n        if (x2 < l - d || x1 > r + d || y2 < t - d || y1 > b + d || !$.contains(inst.snapElements[i].item.ownerDocument, inst.snapElements[i].item)) {\n          if (inst.snapElements[i].snapping) {\n            inst.options.snap.release && inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), {\n              snapItem: inst.snapElements[i].item\n            }));\n          }\n\n          inst.snapElements[i].snapping = false;\n          continue;\n        }\n\n        if (o.snapMode !== \"inner\") {\n          ts = Math.abs(t - y2) <= d;\n          bs = Math.abs(b - y1) <= d;\n          ls = Math.abs(l - x2) <= d;\n          rs = Math.abs(r - x1) <= d;\n\n          if (ts) {\n            ui.position.top = inst._convertPositionTo(\"relative\", {\n              top: t - inst.helperProportions.height,\n              left: 0\n            }).top;\n          }\n\n          if (bs) {\n            ui.position.top = inst._convertPositionTo(\"relative\", {\n              top: b,\n              left: 0\n            }).top;\n          }\n\n          if (ls) {\n            ui.position.left = inst._convertPositionTo(\"relative\", {\n              top: 0,\n              left: l - inst.helperProportions.width\n            }).left;\n          }\n\n          if (rs) {\n            ui.position.left = inst._convertPositionTo(\"relative\", {\n              top: 0,\n              left: r\n            }).left;\n          }\n        }\n\n        first = ts || bs || ls || rs;\n\n        if (o.snapMode !== \"outer\") {\n          ts = Math.abs(t - y1) <= d;\n          bs = Math.abs(b - y2) <= d;\n          ls = Math.abs(l - x1) <= d;\n          rs = Math.abs(r - x2) <= d;\n\n          if (ts) {\n            ui.position.top = inst._convertPositionTo(\"relative\", {\n              top: t,\n              left: 0\n            }).top;\n          }\n\n          if (bs) {\n            ui.position.top = inst._convertPositionTo(\"relative\", {\n              top: b - inst.helperProportions.height,\n              left: 0\n            }).top;\n          }\n\n          if (ls) {\n            ui.position.left = inst._convertPositionTo(\"relative\", {\n              top: 0,\n              left: l\n            }).left;\n          }\n\n          if (rs) {\n            ui.position.left = inst._convertPositionTo(\"relative\", {\n              top: 0,\n              left: r - inst.helperProportions.width\n            }).left;\n          }\n        }\n\n        if (!inst.snapElements[i].snapping && (ts || bs || ls || rs || first)) {\n          inst.options.snap.snap && inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), {\n            snapItem: inst.snapElements[i].item\n          }));\n        }\n\n        inst.snapElements[i].snapping = ts || bs || ls || rs || first;\n      }\n    }\n  });\n  $.ui.plugin.add(\"draggable\", \"stack\", {\n    start: function start(event, ui, instance) {\n      var min,\n          o = instance.options,\n          group = $.makeArray($(o.stack)).sort(function (a, b) {\n        return (parseInt($(a).css(\"zIndex\"), 10) || 0) - (parseInt($(b).css(\"zIndex\"), 10) || 0);\n      });\n\n      if (!group.length) {\n        return;\n      }\n\n      min = parseInt($(group[0]).css(\"zIndex\"), 10) || 0;\n      $(group).each(function (i) {\n        $(this).css(\"zIndex\", min + i);\n      });\n      this.css(\"zIndex\", min + group.length);\n    }\n  });\n  $.ui.plugin.add(\"draggable\", \"zIndex\", {\n    start: function start(event, ui, instance) {\n      var t = $(ui.helper),\n          o = instance.options;\n\n      if (t.css(\"zIndex\")) {\n        o._zIndex = t.css(\"zIndex\");\n      }\n\n      t.css(\"zIndex\", o.zIndex);\n    },\n    stop: function stop(event, ui, instance) {\n      var o = instance.options;\n\n      if (o._zIndex) {\n        $(ui.helper).css(\"zIndex\", o._zIndex);\n      }\n    }\n  });\n  var draggable = $.ui.draggable;\n  /*!\n   * jQuery UI Resizable 1.11.4\n   * http://jqueryui.com\n   *\n   * Copyright jQuery Foundation and other contributors\n   * Released under the MIT license.\n   * http://jquery.org/license\n   *\n   * http://api.jqueryui.com/resizable/\n   */\n\n  $.widget(\"ui.resizable\", $.ui.mouse, {\n    version: \"1.11.4\",\n    widgetEventPrefix: \"resize\",\n    options: {\n      alsoResize: false,\n      animate: false,\n      animateDuration: \"slow\",\n      animateEasing: \"swing\",\n      aspectRatio: false,\n      autoHide: false,\n      containment: false,\n      ghost: false,\n      grid: false,\n      handles: \"e,s,se\",\n      helper: false,\n      maxHeight: null,\n      maxWidth: null,\n      minHeight: 10,\n      minWidth: 10,\n      // See #7960\n      zIndex: 90,\n      // callbacks\n      resize: null,\n      start: null,\n      stop: null\n    },\n    _num: function _num(value) {\n      return parseInt(value, 10) || 0;\n    },\n    _isNumber: function _isNumber(value) {\n      return !isNaN(parseInt(value, 10));\n    },\n    _hasScroll: function _hasScroll(el, a) {\n      if ($(el).css(\"overflow\") === \"hidden\") {\n        return false;\n      }\n\n      var scroll = a && a === \"left\" ? \"scrollLeft\" : \"scrollTop\",\n          has = false;\n\n      if (el[scroll] > 0) {\n        return true;\n      } // TODO: determine which cases actually cause this to happen\n      // if the element doesn't have the scroll set, see if it's possible to\n      // set the scroll\n\n\n      el[scroll] = 1;\n      has = el[scroll] > 0;\n      el[scroll] = 0;\n      return has;\n    },\n    _create: function _create() {\n      var n,\n          i,\n          handle,\n          axis,\n          hname,\n          that = this,\n          o = this.options;\n      this.element.addClass(\"ui-resizable\");\n      $.extend(this, {\n        _aspectRatio: !!o.aspectRatio,\n        aspectRatio: o.aspectRatio,\n        originalElement: this.element,\n        _proportionallyResizeElements: [],\n        _helper: o.helper || o.ghost || o.animate ? o.helper || \"ui-resizable-helper\" : null\n      }); // Wrap the element if it cannot hold child nodes\n\n      if (this.element[0].nodeName.match(/^(canvas|textarea|input|select|button|img)$/i)) {\n        this.element.wrap($(\"<div class='ui-wrapper' style='overflow: hidden;'></div>\").css({\n          position: this.element.css(\"position\"),\n          width: this.element.outerWidth(),\n          height: this.element.outerHeight(),\n          top: this.element.css(\"top\"),\n          left: this.element.css(\"left\")\n        }));\n        this.element = this.element.parent().data(\"ui-resizable\", this.element.resizable(\"instance\"));\n        this.elementIsWrapper = true;\n        this.element.css({\n          marginLeft: this.originalElement.css(\"marginLeft\"),\n          marginTop: this.originalElement.css(\"marginTop\"),\n          marginRight: this.originalElement.css(\"marginRight\"),\n          marginBottom: this.originalElement.css(\"marginBottom\")\n        });\n        this.originalElement.css({\n          marginLeft: 0,\n          marginTop: 0,\n          marginRight: 0,\n          marginBottom: 0\n        }); // support: Safari\n        // Prevent Safari textarea resize\n\n        this.originalResizeStyle = this.originalElement.css(\"resize\");\n        this.originalElement.css(\"resize\", \"none\");\n\n        this._proportionallyResizeElements.push(this.originalElement.css({\n          position: \"static\",\n          zoom: 1,\n          display: \"block\"\n        })); // support: IE9\n        // avoid IE jump (hard set the margin)\n\n\n        this.originalElement.css({\n          margin: this.originalElement.css(\"margin\")\n        });\n\n        this._proportionallyResize();\n      }\n\n      this.handles = o.handles || (!$(\".ui-resizable-handle\", this.element).length ? \"e,s,se\" : {\n        n: \".ui-resizable-n\",\n        e: \".ui-resizable-e\",\n        s: \".ui-resizable-s\",\n        w: \".ui-resizable-w\",\n        se: \".ui-resizable-se\",\n        sw: \".ui-resizable-sw\",\n        ne: \".ui-resizable-ne\",\n        nw: \".ui-resizable-nw\"\n      });\n      this._handles = $();\n\n      if (this.handles.constructor === String) {\n        if (this.handles === \"all\") {\n          this.handles = \"n,e,s,w,se,sw,ne,nw\";\n        }\n\n        n = this.handles.split(\",\");\n        this.handles = {};\n\n        for (i = 0; i < n.length; i++) {\n          handle = $.trim(n[i]);\n          hname = \"ui-resizable-\" + handle;\n          axis = $(\"<div class='ui-resizable-handle \" + hname + \"'></div>\");\n          axis.css({\n            zIndex: o.zIndex\n          }); // TODO : What's going on here?\n\n          if (\"se\" === handle) {\n            axis.addClass(\"ui-icon ui-icon-gripsmall-diagonal-se\");\n          }\n\n          this.handles[handle] = \".ui-resizable-\" + handle;\n          this.element.append(axis);\n        }\n      }\n\n      this._renderAxis = function (target) {\n        var i, axis, padPos, padWrapper;\n        target = target || this.element;\n\n        for (i in this.handles) {\n          if (this.handles[i].constructor === String) {\n            this.handles[i] = this.element.children(this.handles[i]).first().show();\n          } else if (this.handles[i].jquery || this.handles[i].nodeType) {\n            this.handles[i] = $(this.handles[i]);\n\n            this._on(this.handles[i], {\n              \"mousedown\": that._mouseDown\n            });\n          }\n\n          if (this.elementIsWrapper && this.originalElement[0].nodeName.match(/^(textarea|input|select|button)$/i)) {\n            axis = $(this.handles[i], this.element);\n            padWrapper = /sw|ne|nw|se|n|s/.test(i) ? axis.outerHeight() : axis.outerWidth();\n            padPos = [\"padding\", /ne|nw|n/.test(i) ? \"Top\" : /se|sw|s/.test(i) ? \"Bottom\" : /^e$/.test(i) ? \"Right\" : \"Left\"].join(\"\");\n            target.css(padPos, padWrapper);\n\n            this._proportionallyResize();\n          }\n\n          this._handles = this._handles.add(this.handles[i]);\n        }\n      }; // TODO: make renderAxis a prototype function\n\n\n      this._renderAxis(this.element);\n\n      this._handles = this._handles.add(this.element.find(\".ui-resizable-handle\"));\n\n      this._handles.disableSelection();\n\n      this._handles.mouseover(function () {\n        if (!that.resizing) {\n          if (this.className) {\n            axis = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);\n          }\n\n          that.axis = axis && axis[1] ? axis[1] : \"se\";\n        }\n      });\n\n      if (o.autoHide) {\n        this._handles.hide();\n\n        $(this.element).addClass(\"ui-resizable-autohide\").mouseenter(function () {\n          if (o.disabled) {\n            return;\n          }\n\n          $(this).removeClass(\"ui-resizable-autohide\");\n\n          that._handles.show();\n        }).mouseleave(function () {\n          if (o.disabled) {\n            return;\n          }\n\n          if (!that.resizing) {\n            $(this).addClass(\"ui-resizable-autohide\");\n\n            that._handles.hide();\n          }\n        });\n      }\n\n      this._mouseInit();\n    },\n    _destroy: function _destroy() {\n      this._mouseDestroy();\n\n      var wrapper,\n          _destroy = function _destroy(exp) {\n        $(exp).removeClass(\"ui-resizable ui-resizable-disabled ui-resizable-resizing\").removeData(\"resizable\").removeData(\"ui-resizable\").unbind(\".resizable\").find(\".ui-resizable-handle\").remove();\n      }; // TODO: Unwrap at same DOM position\n\n\n      if (this.elementIsWrapper) {\n        _destroy(this.element);\n\n        wrapper = this.element;\n        this.originalElement.css({\n          position: wrapper.css(\"position\"),\n          width: wrapper.outerWidth(),\n          height: wrapper.outerHeight(),\n          top: wrapper.css(\"top\"),\n          left: wrapper.css(\"left\")\n        }).insertAfter(wrapper);\n        wrapper.remove();\n      }\n\n      this.originalElement.css(\"resize\", this.originalResizeStyle);\n\n      _destroy(this.originalElement);\n\n      return this;\n    },\n    _mouseCapture: function _mouseCapture(event) {\n      var i,\n          handle,\n          capture = false;\n\n      for (i in this.handles) {\n        handle = $(this.handles[i])[0];\n\n        if (handle === event.target || $.contains(handle, event.target)) {\n          capture = true;\n        }\n      }\n\n      return !this.options.disabled && capture;\n    },\n    _mouseStart: function _mouseStart(event) {\n      var curleft,\n          curtop,\n          cursor,\n          o = this.options,\n          el = this.element;\n      this.resizing = true;\n\n      this._renderProxy();\n\n      curleft = this._num(this.helper.css(\"left\"));\n      curtop = this._num(this.helper.css(\"top\"));\n\n      if (o.containment) {\n        curleft += $(o.containment).scrollLeft() || 0;\n        curtop += $(o.containment).scrollTop() || 0;\n      }\n\n      this.offset = this.helper.offset();\n      this.position = {\n        left: curleft,\n        top: curtop\n      };\n      this.size = this._helper ? {\n        width: this.helper.width(),\n        height: this.helper.height()\n      } : {\n        width: el.width(),\n        height: el.height()\n      };\n      this.originalSize = this._helper ? {\n        width: el.outerWidth(),\n        height: el.outerHeight()\n      } : {\n        width: el.width(),\n        height: el.height()\n      };\n      this.sizeDiff = {\n        width: el.outerWidth() - el.width(),\n        height: el.outerHeight() - el.height()\n      };\n      this.originalPosition = {\n        left: curleft,\n        top: curtop\n      };\n      this.originalMousePosition = {\n        left: event.pageX,\n        top: event.pageY\n      };\n      this.aspectRatio = typeof o.aspectRatio === \"number\" ? o.aspectRatio : this.originalSize.width / this.originalSize.height || 1;\n      cursor = $(\".ui-resizable-\" + this.axis).css(\"cursor\");\n      $(\"body\").css(\"cursor\", cursor === \"auto\" ? this.axis + \"-resize\" : cursor);\n      el.addClass(\"ui-resizable-resizing\");\n\n      this._propagate(\"start\", event);\n\n      return true;\n    },\n    _mouseDrag: function _mouseDrag(event) {\n      var data,\n          props,\n          smp = this.originalMousePosition,\n          a = this.axis,\n          dx = event.pageX - smp.left || 0,\n          dy = event.pageY - smp.top || 0,\n          trigger = this._change[a];\n\n      this._updatePrevProperties();\n\n      if (!trigger) {\n        return false;\n      }\n\n      data = trigger.apply(this, [event, dx, dy]);\n\n      this._updateVirtualBoundaries(event.shiftKey);\n\n      if (this._aspectRatio || event.shiftKey) {\n        data = this._updateRatio(data, event);\n      }\n\n      data = this._respectSize(data, event);\n\n      this._updateCache(data);\n\n      this._propagate(\"resize\", event);\n\n      props = this._applyChanges();\n\n      if (!this._helper && this._proportionallyResizeElements.length) {\n        this._proportionallyResize();\n      }\n\n      if (!$.isEmptyObject(props)) {\n        this._updatePrevProperties();\n\n        this._trigger(\"resize\", event, this.ui());\n\n        this._applyChanges();\n      }\n\n      return false;\n    },\n    _mouseStop: function _mouseStop(event) {\n      this.resizing = false;\n      var pr,\n          ista,\n          soffseth,\n          soffsetw,\n          s,\n          left,\n          top,\n          o = this.options,\n          that = this;\n\n      if (this._helper) {\n        pr = this._proportionallyResizeElements;\n        ista = pr.length && /textarea/i.test(pr[0].nodeName);\n        soffseth = ista && this._hasScroll(pr[0], \"left\") ? 0 : that.sizeDiff.height;\n        soffsetw = ista ? 0 : that.sizeDiff.width;\n        s = {\n          width: that.helper.width() - soffsetw,\n          height: that.helper.height() - soffseth\n        };\n        left = parseInt(that.element.css(\"left\"), 10) + (that.position.left - that.originalPosition.left) || null;\n        top = parseInt(that.element.css(\"top\"), 10) + (that.position.top - that.originalPosition.top) || null;\n\n        if (!o.animate) {\n          this.element.css($.extend(s, {\n            top: top,\n            left: left\n          }));\n        }\n\n        that.helper.height(that.size.height);\n        that.helper.width(that.size.width);\n\n        if (this._helper && !o.animate) {\n          this._proportionallyResize();\n        }\n      }\n\n      $(\"body\").css(\"cursor\", \"auto\");\n      this.element.removeClass(\"ui-resizable-resizing\");\n\n      this._propagate(\"stop\", event);\n\n      if (this._helper) {\n        this.helper.remove();\n      }\n\n      return false;\n    },\n    _updatePrevProperties: function _updatePrevProperties() {\n      this.prevPosition = {\n        top: this.position.top,\n        left: this.position.left\n      };\n      this.prevSize = {\n        width: this.size.width,\n        height: this.size.height\n      };\n    },\n    _applyChanges: function _applyChanges() {\n      var props = {};\n\n      if (this.position.top !== this.prevPosition.top) {\n        props.top = this.position.top + \"px\";\n      }\n\n      if (this.position.left !== this.prevPosition.left) {\n        props.left = this.position.left + \"px\";\n      }\n\n      if (this.size.width !== this.prevSize.width) {\n        props.width = this.size.width + \"px\";\n      }\n\n      if (this.size.height !== this.prevSize.height) {\n        props.height = this.size.height + \"px\";\n      }\n\n      this.helper.css(props);\n      return props;\n    },\n    _updateVirtualBoundaries: function _updateVirtualBoundaries(forceAspectRatio) {\n      var pMinWidth,\n          pMaxWidth,\n          pMinHeight,\n          pMaxHeight,\n          b,\n          o = this.options;\n      b = {\n        minWidth: this._isNumber(o.minWidth) ? o.minWidth : 0,\n        maxWidth: this._isNumber(o.maxWidth) ? o.maxWidth : Infinity,\n        minHeight: this._isNumber(o.minHeight) ? o.minHeight : 0,\n        maxHeight: this._isNumber(o.maxHeight) ? o.maxHeight : Infinity\n      };\n\n      if (this._aspectRatio || forceAspectRatio) {\n        pMinWidth = b.minHeight * this.aspectRatio;\n        pMinHeight = b.minWidth / this.aspectRatio;\n        pMaxWidth = b.maxHeight * this.aspectRatio;\n        pMaxHeight = b.maxWidth / this.aspectRatio;\n\n        if (pMinWidth > b.minWidth) {\n          b.minWidth = pMinWidth;\n        }\n\n        if (pMinHeight > b.minHeight) {\n          b.minHeight = pMinHeight;\n        }\n\n        if (pMaxWidth < b.maxWidth) {\n          b.maxWidth = pMaxWidth;\n        }\n\n        if (pMaxHeight < b.maxHeight) {\n          b.maxHeight = pMaxHeight;\n        }\n      }\n\n      this._vBoundaries = b;\n    },\n    _updateCache: function _updateCache(data) {\n      this.offset = this.helper.offset();\n\n      if (this._isNumber(data.left)) {\n        this.position.left = data.left;\n      }\n\n      if (this._isNumber(data.top)) {\n        this.position.top = data.top;\n      }\n\n      if (this._isNumber(data.height)) {\n        this.size.height = data.height;\n      }\n\n      if (this._isNumber(data.width)) {\n        this.size.width = data.width;\n      }\n    },\n    _updateRatio: function _updateRatio(data) {\n      var cpos = this.position,\n          csize = this.size,\n          a = this.axis;\n\n      if (this._isNumber(data.height)) {\n        data.width = data.height * this.aspectRatio;\n      } else if (this._isNumber(data.width)) {\n        data.height = data.width / this.aspectRatio;\n      }\n\n      if (a === \"sw\") {\n        data.left = cpos.left + (csize.width - data.width);\n        data.top = null;\n      }\n\n      if (a === \"nw\") {\n        data.top = cpos.top + (csize.height - data.height);\n        data.left = cpos.left + (csize.width - data.width);\n      }\n\n      return data;\n    },\n    _respectSize: function _respectSize(data) {\n      var o = this._vBoundaries,\n          a = this.axis,\n          ismaxw = this._isNumber(data.width) && o.maxWidth && o.maxWidth < data.width,\n          ismaxh = this._isNumber(data.height) && o.maxHeight && o.maxHeight < data.height,\n          isminw = this._isNumber(data.width) && o.minWidth && o.minWidth > data.width,\n          isminh = this._isNumber(data.height) && o.minHeight && o.minHeight > data.height,\n          dw = this.originalPosition.left + this.originalSize.width,\n          dh = this.position.top + this.size.height,\n          cw = /sw|nw|w/.test(a),\n          ch = /nw|ne|n/.test(a);\n\n      if (isminw) {\n        data.width = o.minWidth;\n      }\n\n      if (isminh) {\n        data.height = o.minHeight;\n      }\n\n      if (ismaxw) {\n        data.width = o.maxWidth;\n      }\n\n      if (ismaxh) {\n        data.height = o.maxHeight;\n      }\n\n      if (isminw && cw) {\n        data.left = dw - o.minWidth;\n      }\n\n      if (ismaxw && cw) {\n        data.left = dw - o.maxWidth;\n      }\n\n      if (isminh && ch) {\n        data.top = dh - o.minHeight;\n      }\n\n      if (ismaxh && ch) {\n        data.top = dh - o.maxHeight;\n      } // Fixing jump error on top/left - bug #2330\n\n\n      if (!data.width && !data.height && !data.left && data.top) {\n        data.top = null;\n      } else if (!data.width && !data.height && !data.top && data.left) {\n        data.left = null;\n      }\n\n      return data;\n    },\n    _getPaddingPlusBorderDimensions: function _getPaddingPlusBorderDimensions(element) {\n      var i = 0,\n          widths = [],\n          borders = [element.css(\"borderTopWidth\"), element.css(\"borderRightWidth\"), element.css(\"borderBottomWidth\"), element.css(\"borderLeftWidth\")],\n          paddings = [element.css(\"paddingTop\"), element.css(\"paddingRight\"), element.css(\"paddingBottom\"), element.css(\"paddingLeft\")];\n\n      for (; i < 4; i++) {\n        widths[i] = parseInt(borders[i], 10) || 0;\n        widths[i] += parseInt(paddings[i], 10) || 0;\n      }\n\n      return {\n        height: widths[0] + widths[2],\n        width: widths[1] + widths[3]\n      };\n    },\n    _proportionallyResize: function _proportionallyResize() {\n      if (!this._proportionallyResizeElements.length) {\n        return;\n      }\n\n      var prel,\n          i = 0,\n          element = this.helper || this.element;\n\n      for (; i < this._proportionallyResizeElements.length; i++) {\n        prel = this._proportionallyResizeElements[i]; // TODO: Seems like a bug to cache this.outerDimensions\n        // considering that we are in a loop.\n\n        if (!this.outerDimensions) {\n          this.outerDimensions = this._getPaddingPlusBorderDimensions(prel);\n        }\n\n        prel.css({\n          height: element.height() - this.outerDimensions.height || 0,\n          width: element.width() - this.outerDimensions.width || 0\n        });\n      }\n    },\n    _renderProxy: function _renderProxy() {\n      var el = this.element,\n          o = this.options;\n      this.elementOffset = el.offset();\n\n      if (this._helper) {\n        this.helper = this.helper || $(\"<div style='overflow:hidden;'></div>\");\n        this.helper.addClass(this._helper).css({\n          width: this.element.outerWidth() - 1,\n          height: this.element.outerHeight() - 1,\n          position: \"absolute\",\n          left: this.elementOffset.left + \"px\",\n          top: this.elementOffset.top + \"px\",\n          zIndex: ++o.zIndex //TODO: Don't modify option\n\n        });\n        this.helper.appendTo(\"body\").disableSelection();\n      } else {\n        this.helper = this.element;\n      }\n    },\n    _change: {\n      e: function e(event, dx) {\n        return {\n          width: this.originalSize.width + dx\n        };\n      },\n      w: function w(event, dx) {\n        var cs = this.originalSize,\n            sp = this.originalPosition;\n        return {\n          left: sp.left + dx,\n          width: cs.width - dx\n        };\n      },\n      n: function n(event, dx, dy) {\n        var cs = this.originalSize,\n            sp = this.originalPosition;\n        return {\n          top: sp.top + dy,\n          height: cs.height - dy\n        };\n      },\n      s: function s(event, dx, dy) {\n        return {\n          height: this.originalSize.height + dy\n        };\n      },\n      se: function se(event, dx, dy) {\n        return $.extend(this._change.s.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));\n      },\n      sw: function sw(event, dx, dy) {\n        return $.extend(this._change.s.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));\n      },\n      ne: function ne(event, dx, dy) {\n        return $.extend(this._change.n.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));\n      },\n      nw: function nw(event, dx, dy) {\n        return $.extend(this._change.n.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));\n      }\n    },\n    _propagate: function _propagate(n, event) {\n      $.ui.plugin.call(this, n, [event, this.ui()]);\n      n !== \"resize\" && this._trigger(n, event, this.ui());\n    },\n    plugins: {},\n    ui: function ui() {\n      return {\n        originalElement: this.originalElement,\n        element: this.element,\n        helper: this.helper,\n        position: this.position,\n        size: this.size,\n        originalSize: this.originalSize,\n        originalPosition: this.originalPosition\n      };\n    }\n  });\n  /*\n   * Resizable Extensions\n   */\n\n  $.ui.plugin.add(\"resizable\", \"animate\", {\n    stop: function stop(event) {\n      var that = $(this).resizable(\"instance\"),\n          o = that.options,\n          pr = that._proportionallyResizeElements,\n          ista = pr.length && /textarea/i.test(pr[0].nodeName),\n          soffseth = ista && that._hasScroll(pr[0], \"left\") ? 0 : that.sizeDiff.height,\n          soffsetw = ista ? 0 : that.sizeDiff.width,\n          style = {\n        width: that.size.width - soffsetw,\n        height: that.size.height - soffseth\n      },\n          left = parseInt(that.element.css(\"left\"), 10) + (that.position.left - that.originalPosition.left) || null,\n          top = parseInt(that.element.css(\"top\"), 10) + (that.position.top - that.originalPosition.top) || null;\n      that.element.animate($.extend(style, top && left ? {\n        top: top,\n        left: left\n      } : {}), {\n        duration: o.animateDuration,\n        easing: o.animateEasing,\n        step: function step() {\n          var data = {\n            width: parseInt(that.element.css(\"width\"), 10),\n            height: parseInt(that.element.css(\"height\"), 10),\n            top: parseInt(that.element.css(\"top\"), 10),\n            left: parseInt(that.element.css(\"left\"), 10)\n          };\n\n          if (pr && pr.length) {\n            $(pr[0]).css({\n              width: data.width,\n              height: data.height\n            });\n          } // propagating resize, and updating values for each animation step\n\n\n          that._updateCache(data);\n\n          that._propagate(\"resize\", event);\n        }\n      });\n    }\n  });\n  $.ui.plugin.add(\"resizable\", \"containment\", {\n    start: function start() {\n      var element,\n          p,\n          co,\n          ch,\n          cw,\n          width,\n          height,\n          that = $(this).resizable(\"instance\"),\n          o = that.options,\n          el = that.element,\n          oc = o.containment,\n          ce = oc instanceof $ ? oc.get(0) : /parent/.test(oc) ? el.parent().get(0) : oc;\n\n      if (!ce) {\n        return;\n      }\n\n      that.containerElement = $(ce);\n\n      if (/document/.test(oc) || oc === document) {\n        that.containerOffset = {\n          left: 0,\n          top: 0\n        };\n        that.containerPosition = {\n          left: 0,\n          top: 0\n        };\n        that.parentData = {\n          element: $(document),\n          left: 0,\n          top: 0,\n          width: $(document).width(),\n          height: $(document).height() || document.body.parentNode.scrollHeight\n        };\n      } else {\n        element = $(ce);\n        p = [];\n        $([\"Top\", \"Right\", \"Left\", \"Bottom\"]).each(function (i, name) {\n          p[i] = that._num(element.css(\"padding\" + name));\n        });\n        that.containerOffset = element.offset();\n        that.containerPosition = element.position();\n        that.containerSize = {\n          height: element.innerHeight() - p[3],\n          width: element.innerWidth() - p[1]\n        };\n        co = that.containerOffset;\n        ch = that.containerSize.height;\n        cw = that.containerSize.width;\n        width = that._hasScroll(ce, \"left\") ? ce.scrollWidth : cw;\n        height = that._hasScroll(ce) ? ce.scrollHeight : ch;\n        that.parentData = {\n          element: ce,\n          left: co.left,\n          top: co.top,\n          width: width,\n          height: height\n        };\n      }\n    },\n    resize: function resize(event) {\n      var woset,\n          hoset,\n          isParent,\n          isOffsetRelative,\n          that = $(this).resizable(\"instance\"),\n          o = that.options,\n          co = that.containerOffset,\n          cp = that.position,\n          pRatio = that._aspectRatio || event.shiftKey,\n          cop = {\n        top: 0,\n        left: 0\n      },\n          ce = that.containerElement,\n          continueResize = true;\n\n      if (ce[0] !== document && /static/.test(ce.css(\"position\"))) {\n        cop = co;\n      }\n\n      if (cp.left < (that._helper ? co.left : 0)) {\n        that.size.width = that.size.width + (that._helper ? that.position.left - co.left : that.position.left - cop.left);\n\n        if (pRatio) {\n          that.size.height = that.size.width / that.aspectRatio;\n          continueResize = false;\n        }\n\n        that.position.left = o.helper ? co.left : 0;\n      }\n\n      if (cp.top < (that._helper ? co.top : 0)) {\n        that.size.height = that.size.height + (that._helper ? that.position.top - co.top : that.position.top);\n\n        if (pRatio) {\n          that.size.width = that.size.height * that.aspectRatio;\n          continueResize = false;\n        }\n\n        that.position.top = that._helper ? co.top : 0;\n      }\n\n      isParent = that.containerElement.get(0) === that.element.parent().get(0);\n      isOffsetRelative = /relative|absolute/.test(that.containerElement.css(\"position\"));\n\n      if (isParent && isOffsetRelative) {\n        that.offset.left = that.parentData.left + that.position.left;\n        that.offset.top = that.parentData.top + that.position.top;\n      } else {\n        that.offset.left = that.element.offset().left;\n        that.offset.top = that.element.offset().top;\n      }\n\n      woset = Math.abs(that.sizeDiff.width + (that._helper ? that.offset.left - cop.left : that.offset.left - co.left));\n      hoset = Math.abs(that.sizeDiff.height + (that._helper ? that.offset.top - cop.top : that.offset.top - co.top));\n\n      if (woset + that.size.width >= that.parentData.width) {\n        that.size.width = that.parentData.width - woset;\n\n        if (pRatio) {\n          that.size.height = that.size.width / that.aspectRatio;\n          continueResize = false;\n        }\n      }\n\n      if (hoset + that.size.height >= that.parentData.height) {\n        that.size.height = that.parentData.height - hoset;\n\n        if (pRatio) {\n          that.size.width = that.size.height * that.aspectRatio;\n          continueResize = false;\n        }\n      }\n\n      if (!continueResize) {\n        that.position.left = that.prevPosition.left;\n        that.position.top = that.prevPosition.top;\n        that.size.width = that.prevSize.width;\n        that.size.height = that.prevSize.height;\n      }\n    },\n    stop: function stop() {\n      var that = $(this).resizable(\"instance\"),\n          o = that.options,\n          co = that.containerOffset,\n          cop = that.containerPosition,\n          ce = that.containerElement,\n          helper = $(that.helper),\n          ho = helper.offset(),\n          w = helper.outerWidth() - that.sizeDiff.width,\n          h = helper.outerHeight() - that.sizeDiff.height;\n\n      if (that._helper && !o.animate && /relative/.test(ce.css(\"position\"))) {\n        $(this).css({\n          left: ho.left - cop.left - co.left,\n          width: w,\n          height: h\n        });\n      }\n\n      if (that._helper && !o.animate && /static/.test(ce.css(\"position\"))) {\n        $(this).css({\n          left: ho.left - cop.left - co.left,\n          width: w,\n          height: h\n        });\n      }\n    }\n  });\n  $.ui.plugin.add(\"resizable\", \"alsoResize\", {\n    start: function start() {\n      var that = $(this).resizable(\"instance\"),\n          o = that.options;\n      $(o.alsoResize).each(function () {\n        var el = $(this);\n        el.data(\"ui-resizable-alsoresize\", {\n          width: parseInt(el.width(), 10),\n          height: parseInt(el.height(), 10),\n          left: parseInt(el.css(\"left\"), 10),\n          top: parseInt(el.css(\"top\"), 10)\n        });\n      });\n    },\n    resize: function resize(event, ui) {\n      var that = $(this).resizable(\"instance\"),\n          o = that.options,\n          os = that.originalSize,\n          op = that.originalPosition,\n          delta = {\n        height: that.size.height - os.height || 0,\n        width: that.size.width - os.width || 0,\n        top: that.position.top - op.top || 0,\n        left: that.position.left - op.left || 0\n      };\n      $(o.alsoResize).each(function () {\n        var el = $(this),\n            start = $(this).data(\"ui-resizable-alsoresize\"),\n            style = {},\n            css = el.parents(ui.originalElement[0]).length ? [\"width\", \"height\"] : [\"width\", \"height\", \"top\", \"left\"];\n        $.each(css, function (i, prop) {\n          var sum = (start[prop] || 0) + (delta[prop] || 0);\n\n          if (sum && sum >= 0) {\n            style[prop] = sum || null;\n          }\n        });\n        el.css(style);\n      });\n    },\n    stop: function stop() {\n      $(this).removeData(\"resizable-alsoresize\");\n    }\n  });\n  $.ui.plugin.add(\"resizable\", \"ghost\", {\n    start: function start() {\n      var that = $(this).resizable(\"instance\"),\n          o = that.options,\n          cs = that.size;\n      that.ghost = that.originalElement.clone();\n      that.ghost.css({\n        opacity: 0.25,\n        display: \"block\",\n        position: \"relative\",\n        height: cs.height,\n        width: cs.width,\n        margin: 0,\n        left: 0,\n        top: 0\n      }).addClass(\"ui-resizable-ghost\").addClass(typeof o.ghost === \"string\" ? o.ghost : \"\");\n      that.ghost.appendTo(that.helper);\n    },\n    resize: function resize() {\n      var that = $(this).resizable(\"instance\");\n\n      if (that.ghost) {\n        that.ghost.css({\n          position: \"relative\",\n          height: that.size.height,\n          width: that.size.width\n        });\n      }\n    },\n    stop: function stop() {\n      var that = $(this).resizable(\"instance\");\n\n      if (that.ghost && that.helper) {\n        that.helper.get(0).removeChild(that.ghost.get(0));\n      }\n    }\n  });\n  $.ui.plugin.add(\"resizable\", \"grid\", {\n    resize: function resize() {\n      var outerDimensions,\n          that = $(this).resizable(\"instance\"),\n          o = that.options,\n          cs = that.size,\n          os = that.originalSize,\n          op = that.originalPosition,\n          a = that.axis,\n          grid = typeof o.grid === \"number\" ? [o.grid, o.grid] : o.grid,\n          gridX = grid[0] || 1,\n          gridY = grid[1] || 1,\n          ox = Math.round((cs.width - os.width) / gridX) * gridX,\n          oy = Math.round((cs.height - os.height) / gridY) * gridY,\n          newWidth = os.width + ox,\n          newHeight = os.height + oy,\n          isMaxWidth = o.maxWidth && o.maxWidth < newWidth,\n          isMaxHeight = o.maxHeight && o.maxHeight < newHeight,\n          isMinWidth = o.minWidth && o.minWidth > newWidth,\n          isMinHeight = o.minHeight && o.minHeight > newHeight;\n      o.grid = grid;\n\n      if (isMinWidth) {\n        newWidth += gridX;\n      }\n\n      if (isMinHeight) {\n        newHeight += gridY;\n      }\n\n      if (isMaxWidth) {\n        newWidth -= gridX;\n      }\n\n      if (isMaxHeight) {\n        newHeight -= gridY;\n      }\n\n      if (/^(se|s|e)$/.test(a)) {\n        that.size.width = newWidth;\n        that.size.height = newHeight;\n      } else if (/^(ne)$/.test(a)) {\n        that.size.width = newWidth;\n        that.size.height = newHeight;\n        that.position.top = op.top - oy;\n      } else if (/^(sw)$/.test(a)) {\n        that.size.width = newWidth;\n        that.size.height = newHeight;\n        that.position.left = op.left - ox;\n      } else {\n        if (newHeight - gridY <= 0 || newWidth - gridX <= 0) {\n          outerDimensions = that._getPaddingPlusBorderDimensions(this);\n        }\n\n        if (newHeight - gridY > 0) {\n          that.size.height = newHeight;\n          that.position.top = op.top - oy;\n        } else {\n          newHeight = gridY - outerDimensions.height;\n          that.size.height = newHeight;\n          that.position.top = op.top + os.height - newHeight;\n        }\n\n        if (newWidth - gridX > 0) {\n          that.size.width = newWidth;\n          that.position.left = op.left - ox;\n        } else {\n          newWidth = gridX - outerDimensions.width;\n          that.size.width = newWidth;\n          that.position.left = op.left + os.width - newWidth;\n        }\n      }\n    }\n  });\n  var resizable = $.ui.resizable;\n  /*!\n   * jQuery UI Dialog 1.11.4\n   * http://jqueryui.com\n   *\n   * Copyright jQuery Foundation and other contributors\n   * Released under the MIT license.\n   * http://jquery.org/license\n   *\n   * http://api.jqueryui.com/dialog/\n   */\n\n  var dialog = $.widget(\"ui.dialog\", {\n    version: \"1.11.4\",\n    options: {\n      appendTo: \"body\",\n      autoOpen: true,\n      buttons: [],\n      closeOnEscape: true,\n      closeText: \"Close\",\n      dialogClass: \"\",\n      draggable: true,\n      hide: null,\n      height: \"auto\",\n      maxHeight: null,\n      maxWidth: null,\n      minHeight: 150,\n      minWidth: 150,\n      modal: false,\n      position: {\n        my: \"center\",\n        at: \"center\",\n        of: window,\n        collision: \"fit\",\n        // Ensure the titlebar is always visible\n        using: function using(pos) {\n          var topOffset = $(this).css(pos).offset().top;\n\n          if (topOffset < 0) {\n            $(this).css(\"top\", pos.top - topOffset);\n          }\n        }\n      },\n      resizable: true,\n      show: null,\n      title: null,\n      width: 300,\n      // callbacks\n      beforeClose: null,\n      close: null,\n      drag: null,\n      dragStart: null,\n      dragStop: null,\n      focus: null,\n      open: null,\n      resize: null,\n      resizeStart: null,\n      resizeStop: null\n    },\n    sizeRelatedOptions: {\n      buttons: true,\n      height: true,\n      maxHeight: true,\n      maxWidth: true,\n      minHeight: true,\n      minWidth: true,\n      width: true\n    },\n    resizableRelatedOptions: {\n      maxHeight: true,\n      maxWidth: true,\n      minHeight: true,\n      minWidth: true\n    },\n    _create: function _create() {\n      this.originalCss = {\n        display: this.element[0].style.display,\n        width: this.element[0].style.width,\n        minHeight: this.element[0].style.minHeight,\n        maxHeight: this.element[0].style.maxHeight,\n        height: this.element[0].style.height\n      };\n      this.originalPosition = {\n        parent: this.element.parent(),\n        index: this.element.parent().children().index(this.element)\n      };\n      this.originalTitle = this.element.attr(\"title\");\n      this.options.title = this.options.title || this.originalTitle;\n\n      this._createWrapper();\n\n      this.element.show().removeAttr(\"title\").addClass(\"ui-dialog-content ui-widget-content\").appendTo(this.uiDialog);\n\n      this._createTitlebar();\n\n      this._createButtonPane();\n\n      if (this.options.draggable && $.fn.draggable) {\n        this._makeDraggable();\n      }\n\n      if (this.options.resizable && $.fn.resizable) {\n        this._makeResizable();\n      }\n\n      this._isOpen = false;\n\n      this._trackFocus();\n    },\n    _init: function _init() {\n      if (this.options.autoOpen) {\n        this.open();\n      }\n    },\n    _appendTo: function _appendTo() {\n      var element = this.options.appendTo;\n\n      if (element && (element.jquery || element.nodeType)) {\n        return $(element);\n      }\n\n      return this.document.find(element || \"body\").eq(0);\n    },\n    _destroy: function _destroy() {\n      var next,\n          originalPosition = this.originalPosition;\n\n      this._untrackInstance();\n\n      this._destroyOverlay();\n\n      this.element.removeUniqueId().removeClass(\"ui-dialog-content ui-widget-content\").css(this.originalCss) // Without detaching first, the following becomes really slow\n      .detach();\n      this.uiDialog.stop(true, true).remove();\n\n      if (this.originalTitle) {\n        this.element.attr(\"title\", this.originalTitle);\n      }\n\n      next = originalPosition.parent.children().eq(originalPosition.index); // Don't try to place the dialog next to itself (#8613)\n\n      if (next.length && next[0] !== this.element[0]) {\n        next.before(this.element);\n      } else {\n        originalPosition.parent.append(this.element);\n      }\n    },\n    widget: function widget() {\n      return this.uiDialog;\n    },\n    disable: $.noop,\n    enable: $.noop,\n    close: function close(event) {\n      var activeElement,\n          that = this;\n\n      if (!this._isOpen || this._trigger(\"beforeClose\", event) === false) {\n        return;\n      }\n\n      this._isOpen = false;\n      this._focusedElement = null;\n\n      this._destroyOverlay();\n\n      this._untrackInstance();\n\n      if (!this.opener.filter(\":focusable\").focus().length) {\n        // support: IE9\n        // IE9 throws an \"Unspecified error\" accessing document.activeElement from an <iframe>\n        try {\n          activeElement = this.document[0].activeElement; // Support: IE9, IE10\n          // If the <body> is blurred, IE will switch windows, see #4520\n\n          if (activeElement && activeElement.nodeName.toLowerCase() !== \"body\") {\n            // Hiding a focused element doesn't trigger blur in WebKit\n            // so in case we have nothing to focus on, explicitly blur the active element\n            // https://bugs.webkit.org/show_bug.cgi?id=47182\n            $(activeElement).blur();\n          }\n        } catch (error) {}\n      }\n\n      this._hide(this.uiDialog, this.options.hide, function () {\n        that._trigger(\"close\", event);\n      });\n    },\n    isOpen: function isOpen() {\n      return this._isOpen;\n    },\n    moveToTop: function moveToTop() {\n      this._moveToTop();\n    },\n    _moveToTop: function _moveToTop(event, silent) {\n      var moved = false,\n          zIndices = this.uiDialog.siblings(\".ui-front:visible\").map(function () {\n        return +$(this).css(\"z-index\");\n      }).get(),\n          zIndexMax = Math.max.apply(null, zIndices);\n\n      if (zIndexMax >= +this.uiDialog.css(\"z-index\")) {\n        this.uiDialog.css(\"z-index\", zIndexMax + 1);\n        moved = true;\n      }\n\n      if (moved && !silent) {\n        this._trigger(\"focus\", event);\n      }\n\n      return moved;\n    },\n    open: function open() {\n      var that = this;\n\n      if (this._isOpen) {\n        if (this._moveToTop()) {\n          this._focusTabbable();\n        }\n\n        return;\n      }\n\n      this._isOpen = true;\n      this.opener = $(this.document[0].activeElement);\n\n      this._size();\n\n      this._position();\n\n      this._createOverlay();\n\n      this._moveToTop(null, true); // Ensure the overlay is moved to the top with the dialog, but only when\n      // opening. The overlay shouldn't move after the dialog is open so that\n      // modeless dialogs opened after the modal dialog stack properly.\n\n\n      if (this.overlay) {\n        this.overlay.css(\"z-index\", this.uiDialog.css(\"z-index\") - 1);\n      }\n\n      this._show(this.uiDialog, this.options.show, function () {\n        that._focusTabbable();\n\n        that._trigger(\"focus\");\n      }); // Track the dialog immediately upon openening in case a focus event\n      // somehow occurs outside of the dialog before an element inside the\n      // dialog is focused (#10152)\n\n\n      this._makeFocusTarget();\n\n      this._trigger(\"open\");\n    },\n    _focusTabbable: function _focusTabbable() {\n      // Set focus to the first match:\n      // 1. An element that was focused previously\n      // 2. First element inside the dialog matching [autofocus]\n      // 3. Tabbable element inside the content element\n      // 4. Tabbable element inside the buttonpane\n      // 5. The close button\n      // 6. The dialog itself\n      var hasFocus = this._focusedElement;\n\n      if (!hasFocus) {\n        hasFocus = this.element.find(\"[autofocus]\");\n      }\n\n      if (!hasFocus.length) {\n        hasFocus = this.element.find(\":tabbable\");\n      }\n\n      if (!hasFocus.length) {\n        hasFocus = this.uiDialogButtonPane.find(\":tabbable\");\n      }\n\n      if (!hasFocus.length) {\n        hasFocus = this.uiDialogTitlebarClose.filter(\":tabbable\");\n      }\n\n      if (!hasFocus.length) {\n        hasFocus = this.uiDialog;\n      }\n\n      hasFocus.eq(0).focus();\n    },\n    _keepFocus: function _keepFocus(event) {\n      function checkFocus() {\n        var activeElement = this.document[0].activeElement,\n            isActive = this.uiDialog[0] === activeElement || $.contains(this.uiDialog[0], activeElement);\n\n        if (!isActive) {\n          this._focusTabbable();\n        }\n      }\n\n      event.preventDefault();\n      checkFocus.call(this); // support: IE\n      // IE <= 8 doesn't prevent moving focus even with event.preventDefault()\n      // so we check again later\n\n      this._delay(checkFocus);\n    },\n    _createWrapper: function _createWrapper() {\n      this.uiDialog = $(\"<div>\").addClass(\"ui-dialog ui-widget ui-widget-content ui-corner-all ui-front \" + this.options.dialogClass).hide().attr({\n        // Setting tabIndex makes the div focusable\n        tabIndex: -1,\n        role: \"dialog\"\n      }).appendTo(this._appendTo());\n\n      this._on(this.uiDialog, {\n        keydown: function keydown(event) {\n          if (this.options.closeOnEscape && !event.isDefaultPrevented() && event.keyCode && event.keyCode === $.ui.keyCode.ESCAPE) {\n            event.preventDefault();\n            this.close(event);\n            return;\n          } // prevent tabbing out of dialogs\n\n\n          if (event.keyCode !== $.ui.keyCode.TAB || event.isDefaultPrevented()) {\n            return;\n          }\n\n          var tabbables = this.uiDialog.find(\":tabbable\"),\n              first = tabbables.filter(\":first\"),\n              last = tabbables.filter(\":last\");\n\n          if ((event.target === last[0] || event.target === this.uiDialog[0]) && !event.shiftKey) {\n            this._delay(function () {\n              first.focus();\n            });\n\n            event.preventDefault();\n          } else if ((event.target === first[0] || event.target === this.uiDialog[0]) && event.shiftKey) {\n            this._delay(function () {\n              last.focus();\n            });\n\n            event.preventDefault();\n          }\n        },\n        mousedown: function mousedown(event) {\n          if (this._moveToTop(event)) {\n            this._focusTabbable();\n          }\n        }\n      }); // We assume that any existing aria-describedby attribute means\n      // that the dialog content is marked up properly\n      // otherwise we brute force the content as the description\n\n\n      if (!this.element.find(\"[aria-describedby]\").length) {\n        this.uiDialog.attr({\n          \"aria-describedby\": this.element.uniqueId().attr(\"id\")\n        });\n      }\n    },\n    _createTitlebar: function _createTitlebar() {\n      var uiDialogTitle;\n      this.uiDialogTitlebar = $(\"<div>\").addClass(\"ui-dialog-titlebar ui-widget-header ui-corner-all ui-helper-clearfix\").prependTo(this.uiDialog);\n\n      this._on(this.uiDialogTitlebar, {\n        mousedown: function mousedown(event) {\n          // Don't prevent click on close button (#8838)\n          // Focusing a dialog that is partially scrolled out of view\n          // causes the browser to scroll it into view, preventing the click event\n          if (!$(event.target).closest(\".ui-dialog-titlebar-close\")) {\n            // Dialog isn't getting focus when dragging (#8063)\n            this.uiDialog.focus();\n          }\n        }\n      }); // support: IE\n      // Use type=\"button\" to prevent enter keypresses in textboxes from closing the\n      // dialog in IE (#9312)\n\n\n      this.uiDialogTitlebarClose = $(\"<button type='button'></button>\").button({\n        label: this.options.closeText,\n        icons: {\n          primary: \"ui-icon-closethick\"\n        },\n        text: false\n      }).addClass(\"ui-dialog-titlebar-close\").appendTo(this.uiDialogTitlebar);\n\n      this._on(this.uiDialogTitlebarClose, {\n        click: function click(event) {\n          event.preventDefault();\n          this.close(event);\n        }\n      });\n\n      uiDialogTitle = $(\"<span>\").uniqueId().addClass(\"ui-dialog-title\").prependTo(this.uiDialogTitlebar);\n\n      this._title(uiDialogTitle);\n\n      this.uiDialog.attr({\n        \"aria-labelledby\": uiDialogTitle.attr(\"id\")\n      });\n    },\n    _title: function _title(title) {\n      if (!this.options.title) {\n        title.html(\"&#160;\");\n      }\n\n      title.text(this.options.title);\n    },\n    _createButtonPane: function _createButtonPane() {\n      this.uiDialogButtonPane = $(\"<div>\").addClass(\"ui-dialog-buttonpane ui-widget-content ui-helper-clearfix\");\n      this.uiButtonSet = $(\"<div>\").addClass(\"ui-dialog-buttonset\").appendTo(this.uiDialogButtonPane);\n\n      this._createButtons();\n    },\n    _createButtons: function _createButtons() {\n      var that = this,\n          buttons = this.options.buttons; // if we already have a button pane, remove it\n\n      this.uiDialogButtonPane.remove();\n      this.uiButtonSet.empty();\n\n      if ($.isEmptyObject(buttons) || $.isArray(buttons) && !buttons.length) {\n        this.uiDialog.removeClass(\"ui-dialog-buttons\");\n        return;\n      }\n\n      $.each(buttons, function (name, props) {\n        var click, buttonOptions;\n        props = $.isFunction(props) ? {\n          click: props,\n          text: name\n        } : props; // Default to a non-submitting button\n\n        props = $.extend({\n          type: \"button\"\n        }, props); // Change the context for the click callback to be the main element\n\n        click = props.click;\n\n        props.click = function () {\n          click.apply(that.element[0], arguments);\n        };\n\n        buttonOptions = {\n          icons: props.icons,\n          text: props.showText\n        };\n        delete props.icons;\n        delete props.showText;\n        $(\"<button></button>\", props).button(buttonOptions).appendTo(that.uiButtonSet);\n      });\n      this.uiDialog.addClass(\"ui-dialog-buttons\");\n      this.uiDialogButtonPane.appendTo(this.uiDialog);\n    },\n    _makeDraggable: function _makeDraggable() {\n      var that = this,\n          options = this.options;\n\n      function filteredUi(ui) {\n        return {\n          position: ui.position,\n          offset: ui.offset\n        };\n      }\n\n      this.uiDialog.draggable({\n        cancel: \".ui-dialog-content, .ui-dialog-titlebar-close\",\n        handle: \".ui-dialog-titlebar\",\n        containment: \"document\",\n        start: function start(event, ui) {\n          $(this).addClass(\"ui-dialog-dragging\");\n\n          that._blockFrames();\n\n          that._trigger(\"dragStart\", event, filteredUi(ui));\n        },\n        drag: function drag(event, ui) {\n          that._trigger(\"drag\", event, filteredUi(ui));\n        },\n        stop: function stop(event, ui) {\n          var left = ui.offset.left - that.document.scrollLeft(),\n              top = ui.offset.top - that.document.scrollTop();\n          options.position = {\n            my: \"left top\",\n            at: \"left\" + (left >= 0 ? \"+\" : \"\") + left + \" \" + \"top\" + (top >= 0 ? \"+\" : \"\") + top,\n            of: that.window\n          };\n          $(this).removeClass(\"ui-dialog-dragging\");\n\n          that._unblockFrames();\n\n          that._trigger(\"dragStop\", event, filteredUi(ui));\n        }\n      });\n    },\n    _makeResizable: function _makeResizable() {\n      var that = this,\n          options = this.options,\n          handles = options.resizable,\n          // .ui-resizable has position: relative defined in the stylesheet\n      // but dialogs have to use absolute or fixed positioning\n      position = this.uiDialog.css(\"position\"),\n          resizeHandles = typeof handles === \"string\" ? handles : \"n,e,s,w,se,sw,ne,nw\";\n\n      function filteredUi(ui) {\n        return {\n          originalPosition: ui.originalPosition,\n          originalSize: ui.originalSize,\n          position: ui.position,\n          size: ui.size\n        };\n      }\n\n      this.uiDialog.resizable({\n        cancel: \".ui-dialog-content\",\n        containment: \"document\",\n        alsoResize: this.element,\n        maxWidth: options.maxWidth,\n        maxHeight: options.maxHeight,\n        minWidth: options.minWidth,\n        minHeight: this._minHeight(),\n        handles: resizeHandles,\n        start: function start(event, ui) {\n          $(this).addClass(\"ui-dialog-resizing\");\n\n          that._blockFrames();\n\n          that._trigger(\"resizeStart\", event, filteredUi(ui));\n        },\n        resize: function resize(event, ui) {\n          that._trigger(\"resize\", event, filteredUi(ui));\n        },\n        stop: function stop(event, ui) {\n          var offset = that.uiDialog.offset(),\n              left = offset.left - that.document.scrollLeft(),\n              top = offset.top - that.document.scrollTop();\n          options.height = that.uiDialog.height();\n          options.width = that.uiDialog.width();\n          options.position = {\n            my: \"left top\",\n            at: \"left\" + (left >= 0 ? \"+\" : \"\") + left + \" \" + \"top\" + (top >= 0 ? \"+\" : \"\") + top,\n            of: that.window\n          };\n          $(this).removeClass(\"ui-dialog-resizing\");\n\n          that._unblockFrames();\n\n          that._trigger(\"resizeStop\", event, filteredUi(ui));\n        }\n      }).css(\"position\", position);\n    },\n    _trackFocus: function _trackFocus() {\n      this._on(this.widget(), {\n        focusin: function focusin(event) {\n          this._makeFocusTarget();\n\n          this._focusedElement = $(event.target);\n        }\n      });\n    },\n    _makeFocusTarget: function _makeFocusTarget() {\n      this._untrackInstance();\n\n      this._trackingInstances().unshift(this);\n    },\n    _untrackInstance: function _untrackInstance() {\n      var instances = this._trackingInstances(),\n          exists = $.inArray(this, instances);\n\n      if (exists !== -1) {\n        instances.splice(exists, 1);\n      }\n    },\n    _trackingInstances: function _trackingInstances() {\n      var instances = this.document.data(\"ui-dialog-instances\");\n\n      if (!instances) {\n        instances = [];\n        this.document.data(\"ui-dialog-instances\", instances);\n      }\n\n      return instances;\n    },\n    _minHeight: function _minHeight() {\n      var options = this.options;\n      return options.height === \"auto\" ? options.minHeight : Math.min(options.minHeight, options.height);\n    },\n    _position: function _position() {\n      // Need to show the dialog to get the actual offset in the position plugin\n      var isVisible = this.uiDialog.is(\":visible\");\n\n      if (!isVisible) {\n        this.uiDialog.show();\n      }\n\n      this.uiDialog.position(this.options.position);\n\n      if (!isVisible) {\n        this.uiDialog.hide();\n      }\n    },\n    _setOptions: function _setOptions(options) {\n      var that = this,\n          resize = false,\n          resizableOptions = {};\n      $.each(options, function (key, value) {\n        that._setOption(key, value);\n\n        if (key in that.sizeRelatedOptions) {\n          resize = true;\n        }\n\n        if (key in that.resizableRelatedOptions) {\n          resizableOptions[key] = value;\n        }\n      });\n\n      if (resize) {\n        this._size();\n\n        this._position();\n      }\n\n      if (this.uiDialog.is(\":data(ui-resizable)\")) {\n        this.uiDialog.resizable(\"option\", resizableOptions);\n      }\n    },\n    _setOption: function _setOption(key, value) {\n      var isDraggable,\n          isResizable,\n          uiDialog = this.uiDialog;\n\n      if (key === \"dialogClass\") {\n        uiDialog.removeClass(this.options.dialogClass).addClass(value);\n      }\n\n      if (key === \"disabled\") {\n        return;\n      }\n\n      this._super(key, value);\n\n      if (key === \"appendTo\") {\n        this.uiDialog.appendTo(this._appendTo());\n      }\n\n      if (key === \"buttons\") {\n        this._createButtons();\n      }\n\n      if (key === \"closeText\") {\n        this.uiDialogTitlebarClose.button({\n          // Ensure that we always pass a string\n          label: \"\" + value\n        });\n      }\n\n      if (key === \"draggable\") {\n        isDraggable = uiDialog.is(\":data(ui-draggable)\");\n\n        if (isDraggable && !value) {\n          uiDialog.draggable(\"destroy\");\n        }\n\n        if (!isDraggable && value) {\n          this._makeDraggable();\n        }\n      }\n\n      if (key === \"position\") {\n        this._position();\n      }\n\n      if (key === \"resizable\") {\n        // currently resizable, becoming non-resizable\n        isResizable = uiDialog.is(\":data(ui-resizable)\");\n\n        if (isResizable && !value) {\n          uiDialog.resizable(\"destroy\");\n        } // currently resizable, changing handles\n\n\n        if (isResizable && typeof value === \"string\") {\n          uiDialog.resizable(\"option\", \"handles\", value);\n        } // currently non-resizable, becoming resizable\n\n\n        if (!isResizable && value !== false) {\n          this._makeResizable();\n        }\n      }\n\n      if (key === \"title\") {\n        this._title(this.uiDialogTitlebar.find(\".ui-dialog-title\"));\n      }\n    },\n    _size: function _size() {\n      // If the user has resized the dialog, the .ui-dialog and .ui-dialog-content\n      // divs will both have width and height set, so we need to reset them\n      var nonContentHeight,\n          minContentHeight,\n          maxContentHeight,\n          options = this.options; // Reset content sizing\n\n      this.element.show().css({\n        width: \"auto\",\n        minHeight: 0,\n        maxHeight: \"none\",\n        height: 0\n      });\n\n      if (options.minWidth > options.width) {\n        options.width = options.minWidth;\n      } // reset wrapper sizing\n      // determine the height of all the non-content elements\n\n\n      nonContentHeight = this.uiDialog.css({\n        height: \"auto\",\n        width: options.width\n      }).outerHeight();\n      minContentHeight = Math.max(0, options.minHeight - nonContentHeight);\n      maxContentHeight = typeof options.maxHeight === \"number\" ? Math.max(0, options.maxHeight - nonContentHeight) : \"none\";\n\n      if (options.height === \"auto\") {\n        this.element.css({\n          minHeight: minContentHeight,\n          maxHeight: maxContentHeight,\n          height: \"auto\"\n        });\n      } else {\n        this.element.height(Math.max(0, options.height - nonContentHeight));\n      }\n\n      if (this.uiDialog.is(\":data(ui-resizable)\")) {\n        this.uiDialog.resizable(\"option\", \"minHeight\", this._minHeight());\n      }\n    },\n    _blockFrames: function _blockFrames() {\n      this.iframeBlocks = this.document.find(\"iframe\").map(function () {\n        var iframe = $(this);\n        return $(\"<div>\").css({\n          position: \"absolute\",\n          width: iframe.outerWidth(),\n          height: iframe.outerHeight()\n        }).appendTo(iframe.parent()).offset(iframe.offset())[0];\n      });\n    },\n    _unblockFrames: function _unblockFrames() {\n      if (this.iframeBlocks) {\n        this.iframeBlocks.remove();\n        delete this.iframeBlocks;\n      }\n    },\n    _allowInteraction: function _allowInteraction(event) {\n      if ($(event.target).closest(\".ui-dialog\").length) {\n        return true;\n      } // TODO: Remove hack when datepicker implements\n      // the .ui-front logic (#8989)\n\n\n      return !!$(event.target).closest(\".ui-datepicker\").length;\n    },\n    _createOverlay: function _createOverlay() {\n      if (!this.options.modal) {\n        return;\n      } // We use a delay in case the overlay is created from an\n      // event that we're going to be cancelling (#2804)\n\n\n      var isOpening = true;\n\n      this._delay(function () {\n        isOpening = false;\n      });\n\n      if (!this.document.data(\"ui-dialog-overlays\")) {\n        // Prevent use of anchors and inputs\n        // Using _on() for an event handler shared across many instances is\n        // safe because the dialogs stack and must be closed in reverse order\n        this._on(this.document, {\n          focusin: function focusin(event) {\n            if (isOpening) {\n              return;\n            }\n\n            if (!this._allowInteraction(event)) {\n              event.preventDefault();\n\n              this._trackingInstances()[0]._focusTabbable();\n            }\n          }\n        });\n      }\n\n      this.overlay = $(\"<div>\").addClass(\"ui-widget-overlay ui-front\").appendTo(this._appendTo());\n\n      this._on(this.overlay, {\n        mousedown: \"_keepFocus\"\n      });\n\n      this.document.data(\"ui-dialog-overlays\", (this.document.data(\"ui-dialog-overlays\") || 0) + 1);\n    },\n    _destroyOverlay: function _destroyOverlay() {\n      if (!this.options.modal) {\n        return;\n      }\n\n      if (this.overlay) {\n        var overlays = this.document.data(\"ui-dialog-overlays\") - 1;\n\n        if (!overlays) {\n          this.document.unbind(\"focusin\").removeData(\"ui-dialog-overlays\");\n        } else {\n          this.document.data(\"ui-dialog-overlays\", overlays);\n        }\n\n        this.overlay.remove();\n        this.overlay = null;\n      }\n    }\n  });\n  /*!\n   * jQuery UI Droppable 1.11.4\n   * http://jqueryui.com\n   *\n   * Copyright jQuery Foundation and other contributors\n   * Released under the MIT license.\n   * http://jquery.org/license\n   *\n   * http://api.jqueryui.com/droppable/\n   */\n\n  $.widget(\"ui.droppable\", {\n    version: \"1.11.4\",\n    widgetEventPrefix: \"drop\",\n    options: {\n      accept: \"*\",\n      activeClass: false,\n      addClasses: true,\n      greedy: false,\n      hoverClass: false,\n      scope: \"default\",\n      tolerance: \"intersect\",\n      // callbacks\n      activate: null,\n      deactivate: null,\n      drop: null,\n      out: null,\n      over: null\n    },\n    _create: function _create() {\n      var proportions,\n          o = this.options,\n          accept = o.accept;\n      this.isover = false;\n      this.isout = true;\n      this.accept = $.isFunction(accept) ? accept : function (d) {\n        return d.is(accept);\n      };\n\n      this.proportions = function ()\n      /* valueToWrite */\n      {\n        if (arguments.length) {\n          // Store the droppable's proportions\n          proportions = arguments[0];\n        } else {\n          // Retrieve or derive the droppable's proportions\n          return proportions ? proportions : proportions = {\n            width: this.element[0].offsetWidth,\n            height: this.element[0].offsetHeight\n          };\n        }\n      };\n\n      this._addToManager(o.scope);\n\n      o.addClasses && this.element.addClass(\"ui-droppable\");\n    },\n    _addToManager: function _addToManager(scope) {\n      // Add the reference and positions to the manager\n      $.ui.ddmanager.droppables[scope] = $.ui.ddmanager.droppables[scope] || [];\n      $.ui.ddmanager.droppables[scope].push(this);\n    },\n    _splice: function _splice(drop) {\n      var i = 0;\n\n      for (; i < drop.length; i++) {\n        if (drop[i] === this) {\n          drop.splice(i, 1);\n        }\n      }\n    },\n    _destroy: function _destroy() {\n      var drop = $.ui.ddmanager.droppables[this.options.scope];\n\n      this._splice(drop);\n\n      this.element.removeClass(\"ui-droppable ui-droppable-disabled\");\n    },\n    _setOption: function _setOption(key, value) {\n      if (key === \"accept\") {\n        this.accept = $.isFunction(value) ? value : function (d) {\n          return d.is(value);\n        };\n      } else if (key === \"scope\") {\n        var drop = $.ui.ddmanager.droppables[this.options.scope];\n\n        this._splice(drop);\n\n        this._addToManager(value);\n      }\n\n      this._super(key, value);\n    },\n    _activate: function _activate(event) {\n      var draggable = $.ui.ddmanager.current;\n\n      if (this.options.activeClass) {\n        this.element.addClass(this.options.activeClass);\n      }\n\n      if (draggable) {\n        this._trigger(\"activate\", event, this.ui(draggable));\n      }\n    },\n    _deactivate: function _deactivate(event) {\n      var draggable = $.ui.ddmanager.current;\n\n      if (this.options.activeClass) {\n        this.element.removeClass(this.options.activeClass);\n      }\n\n      if (draggable) {\n        this._trigger(\"deactivate\", event, this.ui(draggable));\n      }\n    },\n    _over: function _over(event) {\n      var draggable = $.ui.ddmanager.current; // Bail if draggable and droppable are same element\n\n      if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {\n        return;\n      }\n\n      if (this.accept.call(this.element[0], draggable.currentItem || draggable.element)) {\n        if (this.options.hoverClass) {\n          this.element.addClass(this.options.hoverClass);\n        }\n\n        this._trigger(\"over\", event, this.ui(draggable));\n      }\n    },\n    _out: function _out(event) {\n      var draggable = $.ui.ddmanager.current; // Bail if draggable and droppable are same element\n\n      if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {\n        return;\n      }\n\n      if (this.accept.call(this.element[0], draggable.currentItem || draggable.element)) {\n        if (this.options.hoverClass) {\n          this.element.removeClass(this.options.hoverClass);\n        }\n\n        this._trigger(\"out\", event, this.ui(draggable));\n      }\n    },\n    _drop: function _drop(event, custom) {\n      var draggable = custom || $.ui.ddmanager.current,\n          childrenIntersection = false; // Bail if draggable and droppable are same element\n\n      if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {\n        return false;\n      }\n\n      this.element.find(\":data(ui-droppable)\").not(\".ui-draggable-dragging\").each(function () {\n        var inst = $(this).droppable(\"instance\");\n\n        if (inst.options.greedy && !inst.options.disabled && inst.options.scope === draggable.options.scope && inst.accept.call(inst.element[0], draggable.currentItem || draggable.element) && $.ui.intersect(draggable, $.extend(inst, {\n          offset: inst.element.offset()\n        }), inst.options.tolerance, event)) {\n          childrenIntersection = true;\n          return false;\n        }\n      });\n\n      if (childrenIntersection) {\n        return false;\n      }\n\n      if (this.accept.call(this.element[0], draggable.currentItem || draggable.element)) {\n        if (this.options.activeClass) {\n          this.element.removeClass(this.options.activeClass);\n        }\n\n        if (this.options.hoverClass) {\n          this.element.removeClass(this.options.hoverClass);\n        }\n\n        this._trigger(\"drop\", event, this.ui(draggable));\n\n        return this.element;\n      }\n\n      return false;\n    },\n    ui: function ui(c) {\n      return {\n        draggable: c.currentItem || c.element,\n        helper: c.helper,\n        position: c.position,\n        offset: c.positionAbs\n      };\n    }\n  });\n\n  $.ui.intersect = function () {\n    function isOverAxis(x, reference, size) {\n      return x >= reference && x < reference + size;\n    }\n\n    return function (draggable, droppable, toleranceMode, event) {\n      if (!droppable.offset) {\n        return false;\n      }\n\n      var x1 = (draggable.positionAbs || draggable.position.absolute).left + draggable.margins.left,\n          y1 = (draggable.positionAbs || draggable.position.absolute).top + draggable.margins.top,\n          x2 = x1 + draggable.helperProportions.width,\n          y2 = y1 + draggable.helperProportions.height,\n          l = droppable.offset.left,\n          t = droppable.offset.top,\n          r = l + droppable.proportions().width,\n          b = t + droppable.proportions().height;\n\n      switch (toleranceMode) {\n        case \"fit\":\n          return l <= x1 && x2 <= r && t <= y1 && y2 <= b;\n\n        case \"intersect\":\n          return l < x1 + draggable.helperProportions.width / 2 && // Right Half\n          x2 - draggable.helperProportions.width / 2 < r && // Left Half\n          t < y1 + draggable.helperProportions.height / 2 && // Bottom Half\n          y2 - draggable.helperProportions.height / 2 < b;\n        // Top Half\n\n        case \"pointer\":\n          return isOverAxis(event.pageY, t, droppable.proportions().height) && isOverAxis(event.pageX, l, droppable.proportions().width);\n\n        case \"touch\":\n          return (y1 >= t && y1 <= b || // Top edge touching\n          y2 >= t && y2 <= b || // Bottom edge touching\n          y1 < t && y2 > b // Surrounded vertically\n          ) && (x1 >= l && x1 <= r || // Left edge touching\n          x2 >= l && x2 <= r || // Right edge touching\n          x1 < l && x2 > r // Surrounded horizontally\n          );\n\n        default:\n          return false;\n      }\n    };\n  }();\n  /*\n  \tThis manager tracks offsets of draggables and droppables\n  */\n\n\n  $.ui.ddmanager = {\n    current: null,\n    droppables: {\n      \"default\": []\n    },\n    prepareOffsets: function prepareOffsets(t, event) {\n      var i,\n          j,\n          m = $.ui.ddmanager.droppables[t.options.scope] || [],\n          type = event ? event.type : null,\n          // workaround for #2317\n      list = (t.currentItem || t.element).find(\":data(ui-droppable)\").addBack();\n\n      droppablesLoop: for (i = 0; i < m.length; i++) {\n        // No disabled and non-accepted\n        if (m[i].options.disabled || t && !m[i].accept.call(m[i].element[0], t.currentItem || t.element)) {\n          continue;\n        } // Filter out elements in the current dragged item\n\n\n        for (j = 0; j < list.length; j++) {\n          if (list[j] === m[i].element[0]) {\n            m[i].proportions().height = 0;\n            continue droppablesLoop;\n          }\n        }\n\n        m[i].visible = m[i].element.css(\"display\") !== \"none\";\n\n        if (!m[i].visible) {\n          continue;\n        } // Activate the droppable if used directly from draggables\n\n\n        if (type === \"mousedown\") {\n          m[i]._activate.call(m[i], event);\n        }\n\n        m[i].offset = m[i].element.offset();\n        m[i].proportions({\n          width: m[i].element[0].offsetWidth,\n          height: m[i].element[0].offsetHeight\n        });\n      }\n    },\n    drop: function drop(draggable, event) {\n      var dropped = false; // Create a copy of the droppables in case the list changes during the drop (#9116)\n\n      $.each(($.ui.ddmanager.droppables[draggable.options.scope] || []).slice(), function () {\n        if (!this.options) {\n          return;\n        }\n\n        if (!this.options.disabled && this.visible && $.ui.intersect(draggable, this, this.options.tolerance, event)) {\n          dropped = this._drop.call(this, event) || dropped;\n        }\n\n        if (!this.options.disabled && this.visible && this.accept.call(this.element[0], draggable.currentItem || draggable.element)) {\n          this.isout = true;\n          this.isover = false;\n\n          this._deactivate.call(this, event);\n        }\n      });\n      return dropped;\n    },\n    dragStart: function dragStart(draggable, event) {\n      // Listen for scrolling so that if the dragging causes scrolling the position of the droppables can be recalculated (see #5003)\n      draggable.element.parentsUntil(\"body\").bind(\"scroll.droppable\", function () {\n        if (!draggable.options.refreshPositions) {\n          $.ui.ddmanager.prepareOffsets(draggable, event);\n        }\n      });\n    },\n    drag: function drag(draggable, event) {\n      // If you have a highly dynamic page, you might try this option. It renders positions every time you move the mouse.\n      if (draggable.options.refreshPositions) {\n        $.ui.ddmanager.prepareOffsets(draggable, event);\n      } // Run through all droppables and check their positions based on specific tolerance options\n\n\n      $.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function () {\n        if (this.options.disabled || this.greedyChild || !this.visible) {\n          return;\n        }\n\n        var parentInstance,\n            scope,\n            parent,\n            intersects = $.ui.intersect(draggable, this, this.options.tolerance, event),\n            c = !intersects && this.isover ? \"isout\" : intersects && !this.isover ? \"isover\" : null;\n\n        if (!c) {\n          return;\n        }\n\n        if (this.options.greedy) {\n          // find droppable parents with same scope\n          scope = this.options.scope;\n          parent = this.element.parents(\":data(ui-droppable)\").filter(function () {\n            return $(this).droppable(\"instance\").options.scope === scope;\n          });\n\n          if (parent.length) {\n            parentInstance = $(parent[0]).droppable(\"instance\");\n            parentInstance.greedyChild = c === \"isover\";\n          }\n        } // we just moved into a greedy child\n\n\n        if (parentInstance && c === \"isover\") {\n          parentInstance.isover = false;\n          parentInstance.isout = true;\n\n          parentInstance._out.call(parentInstance, event);\n        }\n\n        this[c] = true;\n        this[c === \"isout\" ? \"isover\" : \"isout\"] = false;\n        this[c === \"isover\" ? \"_over\" : \"_out\"].call(this, event); // we just moved out of a greedy child\n\n        if (parentInstance && c === \"isout\") {\n          parentInstance.isout = false;\n          parentInstance.isover = true;\n\n          parentInstance._over.call(parentInstance, event);\n        }\n      });\n    },\n    dragStop: function dragStop(draggable, event) {\n      draggable.element.parentsUntil(\"body\").unbind(\"scroll.droppable\"); // Call prepareOffsets one final time since IE does not fire return scroll events when overflow was caused by drag (see #5003)\n\n      if (!draggable.options.refreshPositions) {\n        $.ui.ddmanager.prepareOffsets(draggable, event);\n      }\n    }\n  };\n  var droppable = $.ui.droppable;\n  /*!\n   * jQuery UI Effects 1.11.4\n   * http://jqueryui.com\n   *\n   * Copyright jQuery Foundation and other contributors\n   * Released under the MIT license.\n   * http://jquery.org/license\n   *\n   * http://api.jqueryui.com/category/effects-core/\n   */\n\n  var dataSpace = \"ui-effects-\",\n      // Create a local jQuery because jQuery Color relies on it and the\n  // global may not exist with AMD and a custom build (#10199)\n  jQuery = $;\n  $.effects = {\n    effect: {}\n  };\n  /*!\n   * jQuery Color Animations v2.1.2\n   * https://github.com/jquery/jquery-color\n   *\n   * Copyright 2014 jQuery Foundation and other contributors\n   * Released under the MIT license.\n   * http://jquery.org/license\n   *\n   * Date: Wed Jan 16 08:47:09 2013 -0600\n   */\n\n  (function (jQuery, undefined) {\n    var stepHooks = \"backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor\",\n        // plusequals test for += 100 -= 100\n    rplusequals = /^([\\-+])=\\s*(\\d+\\.?\\d*)/,\n        // a set of RE's that can match strings and generate color tuples.\n    stringParsers = [{\n      re: /rgba?\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*(?:,\\s*(\\d?(?:\\.\\d+)?)\\s*)?\\)/,\n      parse: function parse(execResult) {\n        return [execResult[1], execResult[2], execResult[3], execResult[4]];\n      }\n    }, {\n      re: /rgba?\\(\\s*(\\d+(?:\\.\\d+)?)\\%\\s*,\\s*(\\d+(?:\\.\\d+)?)\\%\\s*,\\s*(\\d+(?:\\.\\d+)?)\\%\\s*(?:,\\s*(\\d?(?:\\.\\d+)?)\\s*)?\\)/,\n      parse: function parse(execResult) {\n        return [execResult[1] * 2.55, execResult[2] * 2.55, execResult[3] * 2.55, execResult[4]];\n      }\n    }, {\n      // this regex ignores A-F because it's compared against an already lowercased string\n      re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,\n      parse: function parse(execResult) {\n        return [parseInt(execResult[1], 16), parseInt(execResult[2], 16), parseInt(execResult[3], 16)];\n      }\n    }, {\n      // this regex ignores A-F because it's compared against an already lowercased string\n      re: /#([a-f0-9])([a-f0-9])([a-f0-9])/,\n      parse: function parse(execResult) {\n        return [parseInt(execResult[1] + execResult[1], 16), parseInt(execResult[2] + execResult[2], 16), parseInt(execResult[3] + execResult[3], 16)];\n      }\n    }, {\n      re: /hsla?\\(\\s*(\\d+(?:\\.\\d+)?)\\s*,\\s*(\\d+(?:\\.\\d+)?)\\%\\s*,\\s*(\\d+(?:\\.\\d+)?)\\%\\s*(?:,\\s*(\\d?(?:\\.\\d+)?)\\s*)?\\)/,\n      space: \"hsla\",\n      parse: function parse(execResult) {\n        return [execResult[1], execResult[2] / 100, execResult[3] / 100, execResult[4]];\n      }\n    }],\n        // jQuery.Color( )\n    color = jQuery.Color = function (color, green, blue, alpha) {\n      return new jQuery.Color.fn.parse(color, green, blue, alpha);\n    },\n        spaces = {\n      rgba: {\n        props: {\n          red: {\n            idx: 0,\n            type: \"byte\"\n          },\n          green: {\n            idx: 1,\n            type: \"byte\"\n          },\n          blue: {\n            idx: 2,\n            type: \"byte\"\n          }\n        }\n      },\n      hsla: {\n        props: {\n          hue: {\n            idx: 0,\n            type: \"degrees\"\n          },\n          saturation: {\n            idx: 1,\n            type: \"percent\"\n          },\n          lightness: {\n            idx: 2,\n            type: \"percent\"\n          }\n        }\n      }\n    },\n        propTypes = {\n      \"byte\": {\n        floor: true,\n        max: 255\n      },\n      \"percent\": {\n        max: 1\n      },\n      \"degrees\": {\n        mod: 360,\n        floor: true\n      }\n    },\n        support = color.support = {},\n        // element for support tests\n    supportElem = jQuery(\"<p>\")[0],\n        // colors = jQuery.Color.names\n    colors,\n        // local aliases of functions called often\n    each = jQuery.each; // determine rgba support immediately\n\n\n    supportElem.style.cssText = \"background-color:rgba(1,1,1,.5)\";\n    support.rgba = supportElem.style.backgroundColor.indexOf(\"rgba\") > -1; // define cache name and alpha properties\n    // for rgba and hsla spaces\n\n    each(spaces, function (spaceName, space) {\n      space.cache = \"_\" + spaceName;\n      space.props.alpha = {\n        idx: 3,\n        type: \"percent\",\n        def: 1\n      };\n    });\n\n    function clamp(value, prop, allowEmpty) {\n      var type = propTypes[prop.type] || {};\n\n      if (value == null) {\n        return allowEmpty || !prop.def ? null : prop.def;\n      } // ~~ is an short way of doing floor for positive numbers\n\n\n      value = type.floor ? ~~value : parseFloat(value); // IE will pass in empty strings as value for alpha,\n      // which will hit this case\n\n      if (isNaN(value)) {\n        return prop.def;\n      }\n\n      if (type.mod) {\n        // we add mod before modding to make sure that negatives values\n        // get converted properly: -10 -> 350\n        return (value + type.mod) % type.mod;\n      } // for now all property types without mod have min and max\n\n\n      return 0 > value ? 0 : type.max < value ? type.max : value;\n    }\n\n    function stringParse(string) {\n      var inst = color(),\n          rgba = inst._rgba = [];\n      string = string.toLowerCase();\n      each(stringParsers, function (i, parser) {\n        var parsed,\n            match = parser.re.exec(string),\n            values = match && parser.parse(match),\n            spaceName = parser.space || \"rgba\";\n\n        if (values) {\n          parsed = inst[spaceName](values); // if this was an rgba parse the assignment might happen twice\n          // oh well....\n\n          inst[spaces[spaceName].cache] = parsed[spaces[spaceName].cache];\n          rgba = inst._rgba = parsed._rgba; // exit each( stringParsers ) here because we matched\n\n          return false;\n        }\n      }); // Found a stringParser that handled it\n\n      if (rgba.length) {\n        // if this came from a parsed string, force \"transparent\" when alpha is 0\n        // chrome, (and maybe others) return \"transparent\" as rgba(0,0,0,0)\n        if (rgba.join() === \"0,0,0,0\") {\n          jQuery.extend(rgba, colors.transparent);\n        }\n\n        return inst;\n      } // named colors\n\n\n      return colors[string];\n    }\n\n    color.fn = jQuery.extend(color.prototype, {\n      parse: function parse(red, green, blue, alpha) {\n        if (red === undefined) {\n          this._rgba = [null, null, null, null];\n          return this;\n        }\n\n        if (red.jquery || red.nodeType) {\n          red = jQuery(red).css(green);\n          green = undefined;\n        }\n\n        var inst = this,\n            type = jQuery.type(red),\n            rgba = this._rgba = []; // more than 1 argument specified - assume ( red, green, blue, alpha )\n\n        if (green !== undefined) {\n          red = [red, green, blue, alpha];\n          type = \"array\";\n        }\n\n        if (type === \"string\") {\n          return this.parse(stringParse(red) || colors._default);\n        }\n\n        if (type === \"array\") {\n          each(spaces.rgba.props, function (key, prop) {\n            rgba[prop.idx] = clamp(red[prop.idx], prop);\n          });\n          return this;\n        }\n\n        if (type === \"object\") {\n          if (red instanceof color) {\n            each(spaces, function (spaceName, space) {\n              if (red[space.cache]) {\n                inst[space.cache] = red[space.cache].slice();\n              }\n            });\n          } else {\n            each(spaces, function (spaceName, space) {\n              var cache = space.cache;\n              each(space.props, function (key, prop) {\n                // if the cache doesn't exist, and we know how to convert\n                if (!inst[cache] && space.to) {\n                  // if the value was null, we don't need to copy it\n                  // if the key was alpha, we don't need to copy it either\n                  if (key === \"alpha\" || red[key] == null) {\n                    return;\n                  }\n\n                  inst[cache] = space.to(inst._rgba);\n                } // this is the only case where we allow nulls for ALL properties.\n                // call clamp with alwaysAllowEmpty\n\n\n                inst[cache][prop.idx] = clamp(red[key], prop, true);\n              }); // everything defined but alpha?\n\n              if (inst[cache] && jQuery.inArray(null, inst[cache].slice(0, 3)) < 0) {\n                // use the default of 1\n                inst[cache][3] = 1;\n\n                if (space.from) {\n                  inst._rgba = space.from(inst[cache]);\n                }\n              }\n            });\n          }\n\n          return this;\n        }\n      },\n      is: function is(compare) {\n        var is = color(compare),\n            same = true,\n            inst = this;\n        each(spaces, function (_, space) {\n          var localCache,\n              isCache = is[space.cache];\n\n          if (isCache) {\n            localCache = inst[space.cache] || space.to && space.to(inst._rgba) || [];\n            each(space.props, function (_, prop) {\n              if (isCache[prop.idx] != null) {\n                same = isCache[prop.idx] === localCache[prop.idx];\n                return same;\n              }\n            });\n          }\n\n          return same;\n        });\n        return same;\n      },\n      _space: function _space() {\n        var used = [],\n            inst = this;\n        each(spaces, function (spaceName, space) {\n          if (inst[space.cache]) {\n            used.push(spaceName);\n          }\n        });\n        return used.pop();\n      },\n      transition: function transition(other, distance) {\n        var end = color(other),\n            spaceName = end._space(),\n            space = spaces[spaceName],\n            startColor = this.alpha() === 0 ? color(\"transparent\") : this,\n            start = startColor[space.cache] || space.to(startColor._rgba),\n            result = start.slice();\n\n        end = end[space.cache];\n        each(space.props, function (key, prop) {\n          var index = prop.idx,\n              startValue = start[index],\n              endValue = end[index],\n              type = propTypes[prop.type] || {}; // if null, don't override start value\n\n          if (endValue === null) {\n            return;\n          } // if null - use end\n\n\n          if (startValue === null) {\n            result[index] = endValue;\n          } else {\n            if (type.mod) {\n              if (endValue - startValue > type.mod / 2) {\n                startValue += type.mod;\n              } else if (startValue - endValue > type.mod / 2) {\n                startValue -= type.mod;\n              }\n            }\n\n            result[index] = clamp((endValue - startValue) * distance + startValue, prop);\n          }\n        });\n        return this[spaceName](result);\n      },\n      blend: function blend(opaque) {\n        // if we are already opaque - return ourself\n        if (this._rgba[3] === 1) {\n          return this;\n        }\n\n        var rgb = this._rgba.slice(),\n            a = rgb.pop(),\n            blend = color(opaque)._rgba;\n\n        return color(jQuery.map(rgb, function (v, i) {\n          return (1 - a) * blend[i] + a * v;\n        }));\n      },\n      toRgbaString: function toRgbaString() {\n        var prefix = \"rgba(\",\n            rgba = jQuery.map(this._rgba, function (v, i) {\n          return v == null ? i > 2 ? 1 : 0 : v;\n        });\n\n        if (rgba[3] === 1) {\n          rgba.pop();\n          prefix = \"rgb(\";\n        }\n\n        return prefix + rgba.join() + \")\";\n      },\n      toHslaString: function toHslaString() {\n        var prefix = \"hsla(\",\n            hsla = jQuery.map(this.hsla(), function (v, i) {\n          if (v == null) {\n            v = i > 2 ? 1 : 0;\n          } // catch 1 and 2\n\n\n          if (i && i < 3) {\n            v = Math.round(v * 100) + \"%\";\n          }\n\n          return v;\n        });\n\n        if (hsla[3] === 1) {\n          hsla.pop();\n          prefix = \"hsl(\";\n        }\n\n        return prefix + hsla.join() + \")\";\n      },\n      toHexString: function toHexString(includeAlpha) {\n        var rgba = this._rgba.slice(),\n            alpha = rgba.pop();\n\n        if (includeAlpha) {\n          rgba.push(~~(alpha * 255));\n        }\n\n        return \"#\" + jQuery.map(rgba, function (v) {\n          // default to 0 when nulls exist\n          v = (v || 0).toString(16);\n          return v.length === 1 ? \"0\" + v : v;\n        }).join(\"\");\n      },\n      toString: function toString() {\n        return this._rgba[3] === 0 ? \"transparent\" : this.toRgbaString();\n      }\n    });\n    color.fn.parse.prototype = color.fn; // hsla conversions adapted from:\n    // https://code.google.com/p/maashaack/source/browse/packages/graphics/trunk/src/graphics/colors/HUE2RGB.as?r=5021\n\n    function hue2rgb(p, q, h) {\n      h = (h + 1) % 1;\n\n      if (h * 6 < 1) {\n        return p + (q - p) * h * 6;\n      }\n\n      if (h * 2 < 1) {\n        return q;\n      }\n\n      if (h * 3 < 2) {\n        return p + (q - p) * (2 / 3 - h) * 6;\n      }\n\n      return p;\n    }\n\n    spaces.hsla.to = function (rgba) {\n      if (rgba[0] == null || rgba[1] == null || rgba[2] == null) {\n        return [null, null, null, rgba[3]];\n      }\n\n      var r = rgba[0] / 255,\n          g = rgba[1] / 255,\n          b = rgba[2] / 255,\n          a = rgba[3],\n          max = Math.max(r, g, b),\n          min = Math.min(r, g, b),\n          diff = max - min,\n          add = max + min,\n          l = add * 0.5,\n          h,\n          s;\n\n      if (min === max) {\n        h = 0;\n      } else if (r === max) {\n        h = 60 * (g - b) / diff + 360;\n      } else if (g === max) {\n        h = 60 * (b - r) / diff + 120;\n      } else {\n        h = 60 * (r - g) / diff + 240;\n      } // chroma (diff) == 0 means greyscale which, by definition, saturation = 0%\n      // otherwise, saturation is based on the ratio of chroma (diff) to lightness (add)\n\n\n      if (diff === 0) {\n        s = 0;\n      } else if (l <= 0.5) {\n        s = diff / add;\n      } else {\n        s = diff / (2 - add);\n      }\n\n      return [Math.round(h) % 360, s, l, a == null ? 1 : a];\n    };\n\n    spaces.hsla.from = function (hsla) {\n      if (hsla[0] == null || hsla[1] == null || hsla[2] == null) {\n        return [null, null, null, hsla[3]];\n      }\n\n      var h = hsla[0] / 360,\n          s = hsla[1],\n          l = hsla[2],\n          a = hsla[3],\n          q = l <= 0.5 ? l * (1 + s) : l + s - l * s,\n          p = 2 * l - q;\n      return [Math.round(hue2rgb(p, q, h + 1 / 3) * 255), Math.round(hue2rgb(p, q, h) * 255), Math.round(hue2rgb(p, q, h - 1 / 3) * 255), a];\n    };\n\n    each(spaces, function (spaceName, space) {\n      var props = space.props,\n          cache = space.cache,\n          to = space.to,\n          from = space.from; // makes rgba() and hsla()\n\n      color.fn[spaceName] = function (value) {\n        // generate a cache for this space if it doesn't exist\n        if (to && !this[cache]) {\n          this[cache] = to(this._rgba);\n        }\n\n        if (value === undefined) {\n          return this[cache].slice();\n        }\n\n        var ret,\n            type = jQuery.type(value),\n            arr = type === \"array\" || type === \"object\" ? value : arguments,\n            local = this[cache].slice();\n        each(props, function (key, prop) {\n          var val = arr[type === \"object\" ? key : prop.idx];\n\n          if (val == null) {\n            val = local[prop.idx];\n          }\n\n          local[prop.idx] = clamp(val, prop);\n        });\n\n        if (from) {\n          ret = color(from(local));\n          ret[cache] = local;\n          return ret;\n        } else {\n          return color(local);\n        }\n      }; // makes red() green() blue() alpha() hue() saturation() lightness()\n\n\n      each(props, function (key, prop) {\n        // alpha is included in more than one space\n        if (color.fn[key]) {\n          return;\n        }\n\n        color.fn[key] = function (value) {\n          var vtype = jQuery.type(value),\n              fn = key === \"alpha\" ? this._hsla ? \"hsla\" : \"rgba\" : spaceName,\n              local = this[fn](),\n              cur = local[prop.idx],\n              match;\n\n          if (vtype === \"undefined\") {\n            return cur;\n          }\n\n          if (vtype === \"function\") {\n            value = value.call(this, cur);\n            vtype = jQuery.type(value);\n          }\n\n          if (value == null && prop.empty) {\n            return this;\n          }\n\n          if (vtype === \"string\") {\n            match = rplusequals.exec(value);\n\n            if (match) {\n              value = cur + parseFloat(match[2]) * (match[1] === \"+\" ? 1 : -1);\n            }\n          }\n\n          local[prop.idx] = value;\n          return this[fn](local);\n        };\n      });\n    }); // add cssHook and .fx.step function for each named hook.\n    // accept a space separated string of properties\n\n    color.hook = function (hook) {\n      var hooks = hook.split(\" \");\n      each(hooks, function (i, hook) {\n        jQuery.cssHooks[hook] = {\n          set: function set(elem, value) {\n            var parsed,\n                curElem,\n                backgroundColor = \"\";\n\n            if (value !== \"transparent\" && (jQuery.type(value) !== \"string\" || (parsed = stringParse(value)))) {\n              value = color(parsed || value);\n\n              if (!support.rgba && value._rgba[3] !== 1) {\n                curElem = hook === \"backgroundColor\" ? elem.parentNode : elem;\n\n                while ((backgroundColor === \"\" || backgroundColor === \"transparent\") && curElem && curElem.style) {\n                  try {\n                    backgroundColor = jQuery.css(curElem, \"backgroundColor\");\n                    curElem = curElem.parentNode;\n                  } catch (e) {}\n                }\n\n                value = value.blend(backgroundColor && backgroundColor !== \"transparent\" ? backgroundColor : \"_default\");\n              }\n\n              value = value.toRgbaString();\n            }\n\n            try {\n              elem.style[hook] = value;\n            } catch (e) {// wrapped to prevent IE from throwing errors on \"invalid\" values like 'auto' or 'inherit'\n            }\n          }\n        };\n\n        jQuery.fx.step[hook] = function (fx) {\n          if (!fx.colorInit) {\n            fx.start = color(fx.elem, hook);\n            fx.end = color(fx.end);\n            fx.colorInit = true;\n          }\n\n          jQuery.cssHooks[hook].set(fx.elem, fx.start.transition(fx.end, fx.pos));\n        };\n      });\n    };\n\n    color.hook(stepHooks);\n    jQuery.cssHooks.borderColor = {\n      expand: function expand(value) {\n        var expanded = {};\n        each([\"Top\", \"Right\", \"Bottom\", \"Left\"], function (i, part) {\n          expanded[\"border\" + part + \"Color\"] = value;\n        });\n        return expanded;\n      }\n    }; // Basic color names only.\n    // Usage of any of the other color names requires adding yourself or including\n    // jquery.color.svg-names.js.\n\n    colors = jQuery.Color.names = {\n      // 4.1. Basic color keywords\n      aqua: \"#00ffff\",\n      black: \"#000000\",\n      blue: \"#0000ff\",\n      fuchsia: \"#ff00ff\",\n      gray: \"#808080\",\n      green: \"#008000\",\n      lime: \"#00ff00\",\n      maroon: \"#800000\",\n      navy: \"#000080\",\n      olive: \"#808000\",\n      purple: \"#800080\",\n      red: \"#ff0000\",\n      silver: \"#c0c0c0\",\n      teal: \"#008080\",\n      white: \"#ffffff\",\n      yellow: \"#ffff00\",\n      // 4.2.3. \"transparent\" color keyword\n      transparent: [null, null, null, 0],\n      _default: \"#ffffff\"\n    };\n  })(jQuery);\n  /******************************************************************************/\n\n  /****************************** CLASS ANIMATIONS ******************************/\n\n  /******************************************************************************/\n\n\n  (function () {\n    var classAnimationActions = [\"add\", \"remove\", \"toggle\"],\n        shorthandStyles = {\n      border: 1,\n      borderBottom: 1,\n      borderColor: 1,\n      borderLeft: 1,\n      borderRight: 1,\n      borderTop: 1,\n      borderWidth: 1,\n      margin: 1,\n      padding: 1\n    };\n    $.each([\"borderLeftStyle\", \"borderRightStyle\", \"borderBottomStyle\", \"borderTopStyle\"], function (_, prop) {\n      $.fx.step[prop] = function (fx) {\n        if (fx.end !== \"none\" && !fx.setAttr || fx.pos === 1 && !fx.setAttr) {\n          jQuery.style(fx.elem, prop, fx.end);\n          fx.setAttr = true;\n        }\n      };\n    });\n\n    function getElementStyles(elem) {\n      var key,\n          len,\n          style = elem.ownerDocument.defaultView ? elem.ownerDocument.defaultView.getComputedStyle(elem, null) : elem.currentStyle,\n          styles = {};\n\n      if (style && style.length && style[0] && style[style[0]]) {\n        len = style.length;\n\n        while (len--) {\n          key = style[len];\n\n          if (typeof style[key] === \"string\") {\n            styles[$.camelCase(key)] = style[key];\n          }\n        } // support: Opera, IE <9\n\n      } else {\n        for (key in style) {\n          if (typeof style[key] === \"string\") {\n            styles[key] = style[key];\n          }\n        }\n      }\n\n      return styles;\n    }\n\n    function styleDifference(oldStyle, newStyle) {\n      var diff = {},\n          name,\n          value;\n\n      for (name in newStyle) {\n        value = newStyle[name];\n\n        if (oldStyle[name] !== value) {\n          if (!shorthandStyles[name]) {\n            if ($.fx.step[name] || !isNaN(parseFloat(value))) {\n              diff[name] = value;\n            }\n          }\n        }\n      }\n\n      return diff;\n    } // support: jQuery <1.8\n\n\n    if (!$.fn.addBack) {\n      $.fn.addBack = function (selector) {\n        return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));\n      };\n    }\n\n    $.effects.animateClass = function (value, duration, easing, callback) {\n      var o = $.speed(duration, easing, callback);\n      return this.queue(function () {\n        var animated = $(this),\n            baseClass = animated.attr(\"class\") || \"\",\n            applyClassChange,\n            allAnimations = o.children ? animated.find(\"*\").addBack() : animated; // map the animated objects to store the original styles.\n\n        allAnimations = allAnimations.map(function () {\n          var el = $(this);\n          return {\n            el: el,\n            start: getElementStyles(this)\n          };\n        }); // apply class change\n\n        applyClassChange = function applyClassChange() {\n          $.each(classAnimationActions, function (i, action) {\n            if (value[action]) {\n              animated[action + \"Class\"](value[action]);\n            }\n          });\n        };\n\n        applyClassChange(); // map all animated objects again - calculate new styles and diff\n\n        allAnimations = allAnimations.map(function () {\n          this.end = getElementStyles(this.el[0]);\n          this.diff = styleDifference(this.start, this.end);\n          return this;\n        }); // apply original class\n\n        animated.attr(\"class\", baseClass); // map all animated objects again - this time collecting a promise\n\n        allAnimations = allAnimations.map(function () {\n          var styleInfo = this,\n              dfd = $.Deferred(),\n              opts = $.extend({}, o, {\n            queue: false,\n            complete: function complete() {\n              dfd.resolve(styleInfo);\n            }\n          });\n          this.el.animate(this.diff, opts);\n          return dfd.promise();\n        }); // once all animations have completed:\n\n        $.when.apply($, allAnimations.get()).done(function () {\n          // set the final class\n          applyClassChange(); // for each animated element,\n          // clear all css properties that were animated\n\n          $.each(arguments, function () {\n            var el = this.el;\n            $.each(this.diff, function (key) {\n              el.css(key, \"\");\n            });\n          }); // this is guarnteed to be there if you use jQuery.speed()\n          // it also handles dequeuing the next anim...\n\n          o.complete.call(animated[0]);\n        });\n      });\n    };\n\n    $.fn.extend({\n      addClass: function (orig) {\n        return function (classNames, speed, easing, callback) {\n          return speed ? $.effects.animateClass.call(this, {\n            add: classNames\n          }, speed, easing, callback) : orig.apply(this, arguments);\n        };\n      }($.fn.addClass),\n      removeClass: function (orig) {\n        return function (classNames, speed, easing, callback) {\n          return arguments.length > 1 ? $.effects.animateClass.call(this, {\n            remove: classNames\n          }, speed, easing, callback) : orig.apply(this, arguments);\n        };\n      }($.fn.removeClass),\n      toggleClass: function (orig) {\n        return function (classNames, force, speed, easing, callback) {\n          if (typeof force === \"boolean\" || force === undefined) {\n            if (!speed) {\n              // without speed parameter\n              return orig.apply(this, arguments);\n            } else {\n              return $.effects.animateClass.call(this, force ? {\n                add: classNames\n              } : {\n                remove: classNames\n              }, speed, easing, callback);\n            }\n          } else {\n            // without force parameter\n            return $.effects.animateClass.call(this, {\n              toggle: classNames\n            }, force, speed, easing);\n          }\n        };\n      }($.fn.toggleClass),\n      switchClass: function switchClass(remove, add, speed, easing, callback) {\n        return $.effects.animateClass.call(this, {\n          add: add,\n          remove: remove\n        }, speed, easing, callback);\n      }\n    });\n  })();\n  /******************************************************************************/\n\n  /*********************************** EFFECTS **********************************/\n\n  /******************************************************************************/\n\n\n  (function () {\n    $.extend($.effects, {\n      version: \"1.11.4\",\n      // Saves a set of properties in a data storage\n      save: function save(element, set) {\n        for (var i = 0; i < set.length; i++) {\n          if (set[i] !== null) {\n            element.data(dataSpace + set[i], element[0].style[set[i]]);\n          }\n        }\n      },\n      // Restores a set of previously saved properties from a data storage\n      restore: function restore(element, set) {\n        var val, i;\n\n        for (i = 0; i < set.length; i++) {\n          if (set[i] !== null) {\n            val = element.data(dataSpace + set[i]); // support: jQuery 1.6.2\n            // http://bugs.jquery.com/ticket/9917\n            // jQuery 1.6.2 incorrectly returns undefined for any falsy value.\n            // We can't differentiate between \"\" and 0 here, so we just assume\n            // empty string since it's likely to be a more common value...\n\n            if (val === undefined) {\n              val = \"\";\n            }\n\n            element.css(set[i], val);\n          }\n        }\n      },\n      setMode: function setMode(el, mode) {\n        if (mode === \"toggle\") {\n          mode = el.is(\":hidden\") ? \"show\" : \"hide\";\n        }\n\n        return mode;\n      },\n      // Translates a [top,left] array into a baseline value\n      // this should be a little more flexible in the future to handle a string & hash\n      getBaseline: function getBaseline(origin, original) {\n        var y, x;\n\n        switch (origin[0]) {\n          case \"top\":\n            y = 0;\n            break;\n\n          case \"middle\":\n            y = 0.5;\n            break;\n\n          case \"bottom\":\n            y = 1;\n            break;\n\n          default:\n            y = origin[0] / original.height;\n        }\n\n        switch (origin[1]) {\n          case \"left\":\n            x = 0;\n            break;\n\n          case \"center\":\n            x = 0.5;\n            break;\n\n          case \"right\":\n            x = 1;\n            break;\n\n          default:\n            x = origin[1] / original.width;\n        }\n\n        return {\n          x: x,\n          y: y\n        };\n      },\n      // Wraps the element around a wrapper that copies position properties\n      createWrapper: function createWrapper(element) {\n        // if the element is already wrapped, return it\n        if (element.parent().is(\".ui-effects-wrapper\")) {\n          return element.parent();\n        } // wrap the element\n\n\n        var props = {\n          width: element.outerWidth(true),\n          height: element.outerHeight(true),\n          \"float\": element.css(\"float\")\n        },\n            wrapper = $(\"<div></div>\").addClass(\"ui-effects-wrapper\").css({\n          fontSize: \"100%\",\n          background: \"transparent\",\n          border: \"none\",\n          margin: 0,\n          padding: 0\n        }),\n            // Store the size in case width/height are defined in % - Fixes #5245\n        size = {\n          width: element.width(),\n          height: element.height()\n        },\n            active = document.activeElement; // support: Firefox\n        // Firefox incorrectly exposes anonymous content\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=561664\n\n        try {\n          active.id;\n        } catch (e) {\n          active = document.body;\n        }\n\n        element.wrap(wrapper); // Fixes #7595 - Elements lose focus when wrapped.\n\n        if (element[0] === active || $.contains(element[0], active)) {\n          $(active).focus();\n        }\n\n        wrapper = element.parent(); //Hotfix for jQuery 1.4 since some change in wrap() seems to actually lose the reference to the wrapped element\n        // transfer positioning properties to the wrapper\n\n        if (element.css(\"position\") === \"static\") {\n          wrapper.css({\n            position: \"relative\"\n          });\n          element.css({\n            position: \"relative\"\n          });\n        } else {\n          $.extend(props, {\n            position: element.css(\"position\"),\n            zIndex: element.css(\"z-index\")\n          });\n          $.each([\"top\", \"left\", \"bottom\", \"right\"], function (i, pos) {\n            props[pos] = element.css(pos);\n\n            if (isNaN(parseInt(props[pos], 10))) {\n              props[pos] = \"auto\";\n            }\n          });\n          element.css({\n            position: \"relative\",\n            top: 0,\n            left: 0,\n            right: \"auto\",\n            bottom: \"auto\"\n          });\n        }\n\n        element.css(size);\n        return wrapper.css(props).show();\n      },\n      removeWrapper: function removeWrapper(element) {\n        var active = document.activeElement;\n\n        if (element.parent().is(\".ui-effects-wrapper\")) {\n          element.parent().replaceWith(element); // Fixes #7595 - Elements lose focus when wrapped.\n\n          if (element[0] === active || $.contains(element[0], active)) {\n            $(active).focus();\n          }\n        }\n\n        return element;\n      },\n      setTransition: function setTransition(element, list, factor, value) {\n        value = value || {};\n        $.each(list, function (i, x) {\n          var unit = element.cssUnit(x);\n\n          if (unit[0] > 0) {\n            value[x] = unit[0] * factor + unit[1];\n          }\n        });\n        return value;\n      }\n    }); // return an effect options object for the given parameters:\n\n    function _normalizeArguments(effect, options, speed, callback) {\n      // allow passing all options as the first parameter\n      if ($.isPlainObject(effect)) {\n        options = effect;\n        effect = effect.effect;\n      } // convert to an object\n\n\n      effect = {\n        effect: effect\n      }; // catch (effect, null, ...)\n\n      if (options == null) {\n        options = {};\n      } // catch (effect, callback)\n\n\n      if ($.isFunction(options)) {\n        callback = options;\n        speed = null;\n        options = {};\n      } // catch (effect, speed, ?)\n\n\n      if (typeof options === \"number\" || $.fx.speeds[options]) {\n        callback = speed;\n        speed = options;\n        options = {};\n      } // catch (effect, options, callback)\n\n\n      if ($.isFunction(speed)) {\n        callback = speed;\n        speed = null;\n      } // add options to effect\n\n\n      if (options) {\n        $.extend(effect, options);\n      }\n\n      speed = speed || options.duration;\n      effect.duration = $.fx.off ? 0 : typeof speed === \"number\" ? speed : speed in $.fx.speeds ? $.fx.speeds[speed] : $.fx.speeds._default;\n      effect.complete = callback || options.complete;\n      return effect;\n    }\n\n    function standardAnimationOption(option) {\n      // Valid standard speeds (nothing, number, named speed)\n      if (!option || typeof option === \"number\" || $.fx.speeds[option]) {\n        return true;\n      } // Invalid strings - treat as \"normal\" speed\n\n\n      if (typeof option === \"string\" && !$.effects.effect[option]) {\n        return true;\n      } // Complete callback\n\n\n      if ($.isFunction(option)) {\n        return true;\n      } // Options hash (but not naming an effect)\n\n\n      if (_typeof(option) === \"object\" && !option.effect) {\n        return true;\n      } // Didn't match any standard API\n\n\n      return false;\n    }\n\n    $.fn.extend({\n      effect: function effect()\n      /* effect, options, speed, callback */\n      {\n        var args = _normalizeArguments.apply(this, arguments),\n            mode = args.mode,\n            queue = args.queue,\n            effectMethod = $.effects.effect[args.effect];\n\n        if ($.fx.off || !effectMethod) {\n          // delegate to the original method (e.g., .show()) if possible\n          if (mode) {\n            return this[mode](args.duration, args.complete);\n          } else {\n            return this.each(function () {\n              if (args.complete) {\n                args.complete.call(this);\n              }\n            });\n          }\n        }\n\n        function run(next) {\n          var elem = $(this),\n              complete = args.complete,\n              mode = args.mode;\n\n          function done() {\n            if ($.isFunction(complete)) {\n              complete.call(elem[0]);\n            }\n\n            if ($.isFunction(next)) {\n              next();\n            }\n          } // If the element already has the correct final state, delegate to\n          // the core methods so the internal tracking of \"olddisplay\" works.\n\n\n          if (elem.is(\":hidden\") ? mode === \"hide\" : mode === \"show\") {\n            elem[mode]();\n            done();\n          } else {\n            effectMethod.call(elem[0], args, done);\n          }\n        }\n\n        return queue === false ? this.each(run) : this.queue(queue || \"fx\", run);\n      },\n      show: function (orig) {\n        return function (option) {\n          if (standardAnimationOption(option)) {\n            return orig.apply(this, arguments);\n          } else {\n            var args = _normalizeArguments.apply(this, arguments);\n\n            args.mode = \"show\";\n            return this.effect.call(this, args);\n          }\n        };\n      }($.fn.show),\n      hide: function (orig) {\n        return function (option) {\n          if (standardAnimationOption(option)) {\n            return orig.apply(this, arguments);\n          } else {\n            var args = _normalizeArguments.apply(this, arguments);\n\n            args.mode = \"hide\";\n            return this.effect.call(this, args);\n          }\n        };\n      }($.fn.hide),\n      toggle: function (orig) {\n        return function (option) {\n          if (standardAnimationOption(option) || typeof option === \"boolean\") {\n            return orig.apply(this, arguments);\n          } else {\n            var args = _normalizeArguments.apply(this, arguments);\n\n            args.mode = \"toggle\";\n            return this.effect.call(this, args);\n          }\n        };\n      }($.fn.toggle),\n      // helper functions\n      cssUnit: function cssUnit(key) {\n        var style = this.css(key),\n            val = [];\n        $.each([\"em\", \"px\", \"%\", \"pt\"], function (i, unit) {\n          if (style.indexOf(unit) > 0) {\n            val = [parseFloat(style), unit];\n          }\n        });\n        return val;\n      }\n    });\n  })();\n  /******************************************************************************/\n\n  /*********************************** EASING ***********************************/\n\n  /******************************************************************************/\n\n\n  (function () {\n    // based on easing equations from Robert Penner (http://www.robertpenner.com/easing)\n    var baseEasings = {};\n    $.each([\"Quad\", \"Cubic\", \"Quart\", \"Quint\", \"Expo\"], function (i, name) {\n      baseEasings[name] = function (p) {\n        return Math.pow(p, i + 2);\n      };\n    });\n    $.extend(baseEasings, {\n      Sine: function Sine(p) {\n        return 1 - Math.cos(p * Math.PI / 2);\n      },\n      Circ: function Circ(p) {\n        return 1 - Math.sqrt(1 - p * p);\n      },\n      Elastic: function Elastic(p) {\n        return p === 0 || p === 1 ? p : -Math.pow(2, 8 * (p - 1)) * Math.sin(((p - 1) * 80 - 7.5) * Math.PI / 15);\n      },\n      Back: function Back(p) {\n        return p * p * (3 * p - 2);\n      },\n      Bounce: function Bounce(p) {\n        var pow2,\n            bounce = 4;\n\n        while (p < ((pow2 = Math.pow(2, --bounce)) - 1) / 11) {}\n\n        return 1 / Math.pow(4, 3 - bounce) - 7.5625 * Math.pow((pow2 * 3 - 2) / 22 - p, 2);\n      }\n    });\n    $.each(baseEasings, function (name, easeIn) {\n      $.easing[\"easeIn\" + name] = easeIn;\n\n      $.easing[\"easeOut\" + name] = function (p) {\n        return 1 - easeIn(1 - p);\n      };\n\n      $.easing[\"easeInOut\" + name] = function (p) {\n        return p < 0.5 ? easeIn(p * 2) / 2 : 1 - easeIn(p * -2 + 2) / 2;\n      };\n    });\n  })();\n\n  var effect = $.effects;\n  /*!\n   * jQuery UI Effects Blind 1.11.4\n   * http://jqueryui.com\n   *\n   * Copyright jQuery Foundation and other contributors\n   * Released under the MIT license.\n   * http://jquery.org/license\n   *\n   * http://api.jqueryui.com/blind-effect/\n   */\n\n  var effectBlind = $.effects.effect.blind = function (o, done) {\n    // Create element\n    var el = $(this),\n        rvertical = /up|down|vertical/,\n        rpositivemotion = /up|left|vertical|horizontal/,\n        props = [\"position\", \"top\", \"bottom\", \"left\", \"right\", \"height\", \"width\"],\n        mode = $.effects.setMode(el, o.mode || \"hide\"),\n        direction = o.direction || \"up\",\n        vertical = rvertical.test(direction),\n        ref = vertical ? \"height\" : \"width\",\n        ref2 = vertical ? \"top\" : \"left\",\n        motion = rpositivemotion.test(direction),\n        animation = {},\n        show = mode === \"show\",\n        wrapper,\n        distance,\n        margin; // if already wrapped, the wrapper's properties are my property. #6245\n\n    if (el.parent().is(\".ui-effects-wrapper\")) {\n      $.effects.save(el.parent(), props);\n    } else {\n      $.effects.save(el, props);\n    }\n\n    el.show();\n    wrapper = $.effects.createWrapper(el).css({\n      overflow: \"hidden\"\n    });\n    distance = wrapper[ref]();\n    margin = parseFloat(wrapper.css(ref2)) || 0;\n    animation[ref] = show ? distance : 0;\n\n    if (!motion) {\n      el.css(vertical ? \"bottom\" : \"right\", 0).css(vertical ? \"top\" : \"left\", \"auto\").css({\n        position: \"absolute\"\n      });\n      animation[ref2] = show ? margin : distance + margin;\n    } // start at 0 if we are showing\n\n\n    if (show) {\n      wrapper.css(ref, 0);\n\n      if (!motion) {\n        wrapper.css(ref2, margin + distance);\n      }\n    } // Animate\n\n\n    wrapper.animate(animation, {\n      duration: o.duration,\n      easing: o.easing,\n      queue: false,\n      complete: function complete() {\n        if (mode === \"hide\") {\n          el.hide();\n        }\n\n        $.effects.restore(el, props);\n        $.effects.removeWrapper(el);\n        done();\n      }\n    });\n  };\n  /*!\n   * jQuery UI Effects Bounce 1.11.4\n   * http://jqueryui.com\n   *\n   * Copyright jQuery Foundation and other contributors\n   * Released under the MIT license.\n   * http://jquery.org/license\n   *\n   * http://api.jqueryui.com/bounce-effect/\n   */\n\n\n  var effectBounce = $.effects.effect.bounce = function (o, done) {\n    var el = $(this),\n        props = [\"position\", \"top\", \"bottom\", \"left\", \"right\", \"height\", \"width\"],\n        // defaults:\n    mode = $.effects.setMode(el, o.mode || \"effect\"),\n        hide = mode === \"hide\",\n        show = mode === \"show\",\n        direction = o.direction || \"up\",\n        distance = o.distance,\n        times = o.times || 5,\n        // number of internal animations\n    anims = times * 2 + (show || hide ? 1 : 0),\n        speed = o.duration / anims,\n        easing = o.easing,\n        // utility:\n    ref = direction === \"up\" || direction === \"down\" ? \"top\" : \"left\",\n        motion = direction === \"up\" || direction === \"left\",\n        i,\n        upAnim,\n        downAnim,\n        // we will need to re-assemble the queue to stack our animations in place\n    queue = el.queue(),\n        queuelen = queue.length; // Avoid touching opacity to prevent clearType and PNG issues in IE\n\n    if (show || hide) {\n      props.push(\"opacity\");\n    }\n\n    $.effects.save(el, props);\n    el.show();\n    $.effects.createWrapper(el); // Create Wrapper\n    // default distance for the BIGGEST bounce is the outer Distance / 3\n\n    if (!distance) {\n      distance = el[ref === \"top\" ? \"outerHeight\" : \"outerWidth\"]() / 3;\n    }\n\n    if (show) {\n      downAnim = {\n        opacity: 1\n      };\n      downAnim[ref] = 0; // if we are showing, force opacity 0 and set the initial position\n      // then do the \"first\" animation\n\n      el.css(\"opacity\", 0).css(ref, motion ? -distance * 2 : distance * 2).animate(downAnim, speed, easing);\n    } // start at the smallest distance if we are hiding\n\n\n    if (hide) {\n      distance = distance / Math.pow(2, times - 1);\n    }\n\n    downAnim = {};\n    downAnim[ref] = 0; // Bounces up/down/left/right then back to 0 -- times * 2 animations happen here\n\n    for (i = 0; i < times; i++) {\n      upAnim = {};\n      upAnim[ref] = (motion ? \"-=\" : \"+=\") + distance;\n      el.animate(upAnim, speed, easing).animate(downAnim, speed, easing);\n      distance = hide ? distance * 2 : distance / 2;\n    } // Last Bounce when Hiding\n\n\n    if (hide) {\n      upAnim = {\n        opacity: 0\n      };\n      upAnim[ref] = (motion ? \"-=\" : \"+=\") + distance;\n      el.animate(upAnim, speed, easing);\n    }\n\n    el.queue(function () {\n      if (hide) {\n        el.hide();\n      }\n\n      $.effects.restore(el, props);\n      $.effects.removeWrapper(el);\n      done();\n    }); // inject all the animations we just queued to be first in line (after \"inprogress\")\n\n    if (queuelen > 1) {\n      queue.splice.apply(queue, [1, 0].concat(queue.splice(queuelen, anims + 1)));\n    }\n\n    el.dequeue();\n  };\n  /*!\n   * jQuery UI Effects Clip 1.11.4\n   * http://jqueryui.com\n   *\n   * Copyright jQuery Foundation and other contributors\n   * Released under the MIT license.\n   * http://jquery.org/license\n   *\n   * http://api.jqueryui.com/clip-effect/\n   */\n\n\n  var effectClip = $.effects.effect.clip = function (o, done) {\n    // Create element\n    var el = $(this),\n        props = [\"position\", \"top\", \"bottom\", \"left\", \"right\", \"height\", \"width\"],\n        mode = $.effects.setMode(el, o.mode || \"hide\"),\n        show = mode === \"show\",\n        direction = o.direction || \"vertical\",\n        vert = direction === \"vertical\",\n        size = vert ? \"height\" : \"width\",\n        position = vert ? \"top\" : \"left\",\n        animation = {},\n        wrapper,\n        animate,\n        distance; // Save & Show\n\n    $.effects.save(el, props);\n    el.show(); // Create Wrapper\n\n    wrapper = $.effects.createWrapper(el).css({\n      overflow: \"hidden\"\n    });\n    animate = el[0].tagName === \"IMG\" ? wrapper : el;\n    distance = animate[size](); // Shift\n\n    if (show) {\n      animate.css(size, 0);\n      animate.css(position, distance / 2);\n    } // Create Animation Object:\n\n\n    animation[size] = show ? distance : 0;\n    animation[position] = show ? 0 : distance / 2; // Animate\n\n    animate.animate(animation, {\n      queue: false,\n      duration: o.duration,\n      easing: o.easing,\n      complete: function complete() {\n        if (!show) {\n          el.hide();\n        }\n\n        $.effects.restore(el, props);\n        $.effects.removeWrapper(el);\n        done();\n      }\n    });\n  };\n  /*!\n   * jQuery UI Effects Drop 1.11.4\n   * http://jqueryui.com\n   *\n   * Copyright jQuery Foundation and other contributors\n   * Released under the MIT license.\n   * http://jquery.org/license\n   *\n   * http://api.jqueryui.com/drop-effect/\n   */\n\n\n  var effectDrop = $.effects.effect.drop = function (o, done) {\n    var el = $(this),\n        props = [\"position\", \"top\", \"bottom\", \"left\", \"right\", \"opacity\", \"height\", \"width\"],\n        mode = $.effects.setMode(el, o.mode || \"hide\"),\n        show = mode === \"show\",\n        direction = o.direction || \"left\",\n        ref = direction === \"up\" || direction === \"down\" ? \"top\" : \"left\",\n        motion = direction === \"up\" || direction === \"left\" ? \"pos\" : \"neg\",\n        animation = {\n      opacity: show ? 1 : 0\n    },\n        distance; // Adjust\n\n    $.effects.save(el, props);\n    el.show();\n    $.effects.createWrapper(el);\n    distance = o.distance || el[ref === \"top\" ? \"outerHeight\" : \"outerWidth\"](true) / 2;\n\n    if (show) {\n      el.css(\"opacity\", 0).css(ref, motion === \"pos\" ? -distance : distance);\n    } // Animation\n\n\n    animation[ref] = (show ? motion === \"pos\" ? \"+=\" : \"-=\" : motion === \"pos\" ? \"-=\" : \"+=\") + distance; // Animate\n\n    el.animate(animation, {\n      queue: false,\n      duration: o.duration,\n      easing: o.easing,\n      complete: function complete() {\n        if (mode === \"hide\") {\n          el.hide();\n        }\n\n        $.effects.restore(el, props);\n        $.effects.removeWrapper(el);\n        done();\n      }\n    });\n  };\n  /*!\n   * jQuery UI Effects Explode 1.11.4\n   * http://jqueryui.com\n   *\n   * Copyright jQuery Foundation and other contributors\n   * Released under the MIT license.\n   * http://jquery.org/license\n   *\n   * http://api.jqueryui.com/explode-effect/\n   */\n\n\n  var effectExplode = $.effects.effect.explode = function (o, done) {\n    var rows = o.pieces ? Math.round(Math.sqrt(o.pieces)) : 3,\n        cells = rows,\n        el = $(this),\n        mode = $.effects.setMode(el, o.mode || \"hide\"),\n        show = mode === \"show\",\n        // show and then visibility:hidden the element before calculating offset\n    offset = el.show().css(\"visibility\", \"hidden\").offset(),\n        // width and height of a piece\n    width = Math.ceil(el.outerWidth() / cells),\n        height = Math.ceil(el.outerHeight() / rows),\n        pieces = [],\n        // loop\n    i,\n        j,\n        left,\n        top,\n        mx,\n        my; // children animate complete:\n\n    function childComplete() {\n      pieces.push(this);\n\n      if (pieces.length === rows * cells) {\n        animComplete();\n      }\n    } // clone the element for each row and cell.\n\n\n    for (i = 0; i < rows; i++) {\n      // ===>\n      top = offset.top + i * height;\n      my = i - (rows - 1) / 2;\n\n      for (j = 0; j < cells; j++) {\n        // |||\n        left = offset.left + j * width;\n        mx = j - (cells - 1) / 2; // Create a clone of the now hidden main element that will be absolute positioned\n        // within a wrapper div off the -left and -top equal to size of our pieces\n\n        el.clone().appendTo(\"body\").wrap(\"<div></div>\").css({\n          position: \"absolute\",\n          visibility: \"visible\",\n          left: -j * width,\n          top: -i * height\n        }) // select the wrapper - make it overflow: hidden and absolute positioned based on\n        // where the original was located +left and +top equal to the size of pieces\n        .parent().addClass(\"ui-effects-explode\").css({\n          position: \"absolute\",\n          overflow: \"hidden\",\n          width: width,\n          height: height,\n          left: left + (show ? mx * width : 0),\n          top: top + (show ? my * height : 0),\n          opacity: show ? 0 : 1\n        }).animate({\n          left: left + (show ? 0 : mx * width),\n          top: top + (show ? 0 : my * height),\n          opacity: show ? 1 : 0\n        }, o.duration || 500, o.easing, childComplete);\n      }\n    }\n\n    function animComplete() {\n      el.css({\n        visibility: \"visible\"\n      });\n      $(pieces).remove();\n\n      if (!show) {\n        el.hide();\n      }\n\n      done();\n    }\n  };\n  /*!\n   * jQuery UI Effects Fade 1.11.4\n   * http://jqueryui.com\n   *\n   * Copyright jQuery Foundation and other contributors\n   * Released under the MIT license.\n   * http://jquery.org/license\n   *\n   * http://api.jqueryui.com/fade-effect/\n   */\n\n\n  var effectFade = $.effects.effect.fade = function (o, done) {\n    var el = $(this),\n        mode = $.effects.setMode(el, o.mode || \"toggle\");\n    el.animate({\n      opacity: mode\n    }, {\n      queue: false,\n      duration: o.duration,\n      easing: o.easing,\n      complete: done\n    });\n  };\n  /*!\n   * jQuery UI Effects Fold 1.11.4\n   * http://jqueryui.com\n   *\n   * Copyright jQuery Foundation and other contributors\n   * Released under the MIT license.\n   * http://jquery.org/license\n   *\n   * http://api.jqueryui.com/fold-effect/\n   */\n\n\n  var effectFold = $.effects.effect.fold = function (o, done) {\n    // Create element\n    var el = $(this),\n        props = [\"position\", \"top\", \"bottom\", \"left\", \"right\", \"height\", \"width\"],\n        mode = $.effects.setMode(el, o.mode || \"hide\"),\n        show = mode === \"show\",\n        hide = mode === \"hide\",\n        size = o.size || 15,\n        percent = /([0-9]+)%/.exec(size),\n        horizFirst = !!o.horizFirst,\n        widthFirst = show !== horizFirst,\n        ref = widthFirst ? [\"width\", \"height\"] : [\"height\", \"width\"],\n        duration = o.duration / 2,\n        wrapper,\n        distance,\n        animation1 = {},\n        animation2 = {};\n    $.effects.save(el, props);\n    el.show(); // Create Wrapper\n\n    wrapper = $.effects.createWrapper(el).css({\n      overflow: \"hidden\"\n    });\n    distance = widthFirst ? [wrapper.width(), wrapper.height()] : [wrapper.height(), wrapper.width()];\n\n    if (percent) {\n      size = parseInt(percent[1], 10) / 100 * distance[hide ? 0 : 1];\n    }\n\n    if (show) {\n      wrapper.css(horizFirst ? {\n        height: 0,\n        width: size\n      } : {\n        height: size,\n        width: 0\n      });\n    } // Animation\n\n\n    animation1[ref[0]] = show ? distance[0] : size;\n    animation2[ref[1]] = show ? distance[1] : 0; // Animate\n\n    wrapper.animate(animation1, duration, o.easing).animate(animation2, duration, o.easing, function () {\n      if (hide) {\n        el.hide();\n      }\n\n      $.effects.restore(el, props);\n      $.effects.removeWrapper(el);\n      done();\n    });\n  };\n  /*!\n   * jQuery UI Effects Highlight 1.11.4\n   * http://jqueryui.com\n   *\n   * Copyright jQuery Foundation and other contributors\n   * Released under the MIT license.\n   * http://jquery.org/license\n   *\n   * http://api.jqueryui.com/highlight-effect/\n   */\n\n\n  var effectHighlight = $.effects.effect.highlight = function (o, done) {\n    var elem = $(this),\n        props = [\"backgroundImage\", \"backgroundColor\", \"opacity\"],\n        mode = $.effects.setMode(elem, o.mode || \"show\"),\n        animation = {\n      backgroundColor: elem.css(\"backgroundColor\")\n    };\n\n    if (mode === \"hide\") {\n      animation.opacity = 0;\n    }\n\n    $.effects.save(elem, props);\n    elem.show().css({\n      backgroundImage: \"none\",\n      backgroundColor: o.color || \"#ffff99\"\n    }).animate(animation, {\n      queue: false,\n      duration: o.duration,\n      easing: o.easing,\n      complete: function complete() {\n        if (mode === \"hide\") {\n          elem.hide();\n        }\n\n        $.effects.restore(elem, props);\n        done();\n      }\n    });\n  };\n  /*!\n   * jQuery UI Effects Size 1.11.4\n   * http://jqueryui.com\n   *\n   * Copyright jQuery Foundation and other contributors\n   * Released under the MIT license.\n   * http://jquery.org/license\n   *\n   * http://api.jqueryui.com/size-effect/\n   */\n\n\n  var effectSize = $.effects.effect.size = function (o, done) {\n    // Create element\n    var original,\n        baseline,\n        factor,\n        el = $(this),\n        props0 = [\"position\", \"top\", \"bottom\", \"left\", \"right\", \"width\", \"height\", \"overflow\", \"opacity\"],\n        // Always restore\n    props1 = [\"position\", \"top\", \"bottom\", \"left\", \"right\", \"overflow\", \"opacity\"],\n        // Copy for children\n    props2 = [\"width\", \"height\", \"overflow\"],\n        cProps = [\"fontSize\"],\n        vProps = [\"borderTopWidth\", \"borderBottomWidth\", \"paddingTop\", \"paddingBottom\"],\n        hProps = [\"borderLeftWidth\", \"borderRightWidth\", \"paddingLeft\", \"paddingRight\"],\n        // Set options\n    mode = $.effects.setMode(el, o.mode || \"effect\"),\n        restore = o.restore || mode !== \"effect\",\n        scale = o.scale || \"both\",\n        origin = o.origin || [\"middle\", \"center\"],\n        position = el.css(\"position\"),\n        props = restore ? props0 : props1,\n        zero = {\n      height: 0,\n      width: 0,\n      outerHeight: 0,\n      outerWidth: 0\n    };\n\n    if (mode === \"show\") {\n      el.show();\n    }\n\n    original = {\n      height: el.height(),\n      width: el.width(),\n      outerHeight: el.outerHeight(),\n      outerWidth: el.outerWidth()\n    };\n\n    if (o.mode === \"toggle\" && mode === \"show\") {\n      el.from = o.to || zero;\n      el.to = o.from || original;\n    } else {\n      el.from = o.from || (mode === \"show\" ? zero : original);\n      el.to = o.to || (mode === \"hide\" ? zero : original);\n    } // Set scaling factor\n\n\n    factor = {\n      from: {\n        y: el.from.height / original.height,\n        x: el.from.width / original.width\n      },\n      to: {\n        y: el.to.height / original.height,\n        x: el.to.width / original.width\n      }\n    }; // Scale the css box\n\n    if (scale === \"box\" || scale === \"both\") {\n      // Vertical props scaling\n      if (factor.from.y !== factor.to.y) {\n        props = props.concat(vProps);\n        el.from = $.effects.setTransition(el, vProps, factor.from.y, el.from);\n        el.to = $.effects.setTransition(el, vProps, factor.to.y, el.to);\n      } // Horizontal props scaling\n\n\n      if (factor.from.x !== factor.to.x) {\n        props = props.concat(hProps);\n        el.from = $.effects.setTransition(el, hProps, factor.from.x, el.from);\n        el.to = $.effects.setTransition(el, hProps, factor.to.x, el.to);\n      }\n    } // Scale the content\n\n\n    if (scale === \"content\" || scale === \"both\") {\n      // Vertical props scaling\n      if (factor.from.y !== factor.to.y) {\n        props = props.concat(cProps).concat(props2);\n        el.from = $.effects.setTransition(el, cProps, factor.from.y, el.from);\n        el.to = $.effects.setTransition(el, cProps, factor.to.y, el.to);\n      }\n    }\n\n    $.effects.save(el, props);\n    el.show();\n    $.effects.createWrapper(el);\n    el.css(\"overflow\", \"hidden\").css(el.from); // Adjust\n\n    if (origin) {\n      // Calculate baseline shifts\n      baseline = $.effects.getBaseline(origin, original);\n      el.from.top = (original.outerHeight - el.outerHeight()) * baseline.y;\n      el.from.left = (original.outerWidth - el.outerWidth()) * baseline.x;\n      el.to.top = (original.outerHeight - el.to.outerHeight) * baseline.y;\n      el.to.left = (original.outerWidth - el.to.outerWidth) * baseline.x;\n    }\n\n    el.css(el.from); // set top & left\n    // Animate\n\n    if (scale === \"content\" || scale === \"both\") {\n      // Scale the children\n      // Add margins/font-size\n      vProps = vProps.concat([\"marginTop\", \"marginBottom\"]).concat(cProps);\n      hProps = hProps.concat([\"marginLeft\", \"marginRight\"]);\n      props2 = props0.concat(vProps).concat(hProps);\n      el.find(\"*[width]\").each(function () {\n        var child = $(this),\n            c_original = {\n          height: child.height(),\n          width: child.width(),\n          outerHeight: child.outerHeight(),\n          outerWidth: child.outerWidth()\n        };\n\n        if (restore) {\n          $.effects.save(child, props2);\n        }\n\n        child.from = {\n          height: c_original.height * factor.from.y,\n          width: c_original.width * factor.from.x,\n          outerHeight: c_original.outerHeight * factor.from.y,\n          outerWidth: c_original.outerWidth * factor.from.x\n        };\n        child.to = {\n          height: c_original.height * factor.to.y,\n          width: c_original.width * factor.to.x,\n          outerHeight: c_original.height * factor.to.y,\n          outerWidth: c_original.width * factor.to.x\n        }; // Vertical props scaling\n\n        if (factor.from.y !== factor.to.y) {\n          child.from = $.effects.setTransition(child, vProps, factor.from.y, child.from);\n          child.to = $.effects.setTransition(child, vProps, factor.to.y, child.to);\n        } // Horizontal props scaling\n\n\n        if (factor.from.x !== factor.to.x) {\n          child.from = $.effects.setTransition(child, hProps, factor.from.x, child.from);\n          child.to = $.effects.setTransition(child, hProps, factor.to.x, child.to);\n        } // Animate children\n\n\n        child.css(child.from);\n        child.animate(child.to, o.duration, o.easing, function () {\n          // Restore children\n          if (restore) {\n            $.effects.restore(child, props2);\n          }\n        });\n      });\n    } // Animate\n\n\n    el.animate(el.to, {\n      queue: false,\n      duration: o.duration,\n      easing: o.easing,\n      complete: function complete() {\n        if (el.to.opacity === 0) {\n          el.css(\"opacity\", el.from.opacity);\n        }\n\n        if (mode === \"hide\") {\n          el.hide();\n        }\n\n        $.effects.restore(el, props);\n\n        if (!restore) {\n          // we need to calculate our new positioning based on the scaling\n          if (position === \"static\") {\n            el.css({\n              position: \"relative\",\n              top: el.to.top,\n              left: el.to.left\n            });\n          } else {\n            $.each([\"top\", \"left\"], function (idx, pos) {\n              el.css(pos, function (_, str) {\n                var val = parseInt(str, 10),\n                    toRef = idx ? el.to.left : el.to.top; // if original was \"auto\", recalculate the new value from wrapper\n\n                if (str === \"auto\") {\n                  return toRef + \"px\";\n                }\n\n                return val + toRef + \"px\";\n              });\n            });\n          }\n        }\n\n        $.effects.removeWrapper(el);\n        done();\n      }\n    });\n  };\n  /*!\n   * jQuery UI Effects Scale 1.11.4\n   * http://jqueryui.com\n   *\n   * Copyright jQuery Foundation and other contributors\n   * Released under the MIT license.\n   * http://jquery.org/license\n   *\n   * http://api.jqueryui.com/scale-effect/\n   */\n\n\n  var effectScale = $.effects.effect.scale = function (o, done) {\n    // Create element\n    var el = $(this),\n        options = $.extend(true, {}, o),\n        mode = $.effects.setMode(el, o.mode || \"effect\"),\n        percent = parseInt(o.percent, 10) || (parseInt(o.percent, 10) === 0 ? 0 : mode === \"hide\" ? 0 : 100),\n        direction = o.direction || \"both\",\n        origin = o.origin,\n        original = {\n      height: el.height(),\n      width: el.width(),\n      outerHeight: el.outerHeight(),\n      outerWidth: el.outerWidth()\n    },\n        factor = {\n      y: direction !== \"horizontal\" ? percent / 100 : 1,\n      x: direction !== \"vertical\" ? percent / 100 : 1\n    }; // We are going to pass this effect to the size effect:\n\n    options.effect = \"size\";\n    options.queue = false;\n    options.complete = done; // Set default origin and restore for show/hide\n\n    if (mode !== \"effect\") {\n      options.origin = origin || [\"middle\", \"center\"];\n      options.restore = true;\n    }\n\n    options.from = o.from || (mode === \"show\" ? {\n      height: 0,\n      width: 0,\n      outerHeight: 0,\n      outerWidth: 0\n    } : original);\n    options.to = {\n      height: original.height * factor.y,\n      width: original.width * factor.x,\n      outerHeight: original.outerHeight * factor.y,\n      outerWidth: original.outerWidth * factor.x\n    }; // Fade option to support puff\n\n    if (options.fade) {\n      if (mode === \"show\") {\n        options.from.opacity = 0;\n        options.to.opacity = 1;\n      }\n\n      if (mode === \"hide\") {\n        options.from.opacity = 1;\n        options.to.opacity = 0;\n      }\n    } // Animate\n\n\n    el.effect(options);\n  };\n  /*!\n   * jQuery UI Effects Puff 1.11.4\n   * http://jqueryui.com\n   *\n   * Copyright jQuery Foundation and other contributors\n   * Released under the MIT license.\n   * http://jquery.org/license\n   *\n   * http://api.jqueryui.com/puff-effect/\n   */\n\n\n  var effectPuff = $.effects.effect.puff = function (o, done) {\n    var elem = $(this),\n        mode = $.effects.setMode(elem, o.mode || \"hide\"),\n        hide = mode === \"hide\",\n        percent = parseInt(o.percent, 10) || 150,\n        factor = percent / 100,\n        original = {\n      height: elem.height(),\n      width: elem.width(),\n      outerHeight: elem.outerHeight(),\n      outerWidth: elem.outerWidth()\n    };\n    $.extend(o, {\n      effect: \"scale\",\n      queue: false,\n      fade: true,\n      mode: mode,\n      complete: done,\n      percent: hide ? percent : 100,\n      from: hide ? original : {\n        height: original.height * factor,\n        width: original.width * factor,\n        outerHeight: original.outerHeight * factor,\n        outerWidth: original.outerWidth * factor\n      }\n    });\n    elem.effect(o);\n  };\n  /*!\n   * jQuery UI Effects Pulsate 1.11.4\n   * http://jqueryui.com\n   *\n   * Copyright jQuery Foundation and other contributors\n   * Released under the MIT license.\n   * http://jquery.org/license\n   *\n   * http://api.jqueryui.com/pulsate-effect/\n   */\n\n\n  var effectPulsate = $.effects.effect.pulsate = function (o, done) {\n    var elem = $(this),\n        mode = $.effects.setMode(elem, o.mode || \"show\"),\n        show = mode === \"show\",\n        hide = mode === \"hide\",\n        showhide = show || mode === \"hide\",\n        // showing or hiding leaves of the \"last\" animation\n    anims = (o.times || 5) * 2 + (showhide ? 1 : 0),\n        duration = o.duration / anims,\n        animateTo = 0,\n        queue = elem.queue(),\n        queuelen = queue.length,\n        i;\n\n    if (show || !elem.is(\":visible\")) {\n      elem.css(\"opacity\", 0).show();\n      animateTo = 1;\n    } // anims - 1 opacity \"toggles\"\n\n\n    for (i = 1; i < anims; i++) {\n      elem.animate({\n        opacity: animateTo\n      }, duration, o.easing);\n      animateTo = 1 - animateTo;\n    }\n\n    elem.animate({\n      opacity: animateTo\n    }, duration, o.easing);\n    elem.queue(function () {\n      if (hide) {\n        elem.hide();\n      }\n\n      done();\n    }); // We just queued up \"anims\" animations, we need to put them next in the queue\n\n    if (queuelen > 1) {\n      queue.splice.apply(queue, [1, 0].concat(queue.splice(queuelen, anims + 1)));\n    }\n\n    elem.dequeue();\n  };\n  /*!\n   * jQuery UI Effects Shake 1.11.4\n   * http://jqueryui.com\n   *\n   * Copyright jQuery Foundation and other contributors\n   * Released under the MIT license.\n   * http://jquery.org/license\n   *\n   * http://api.jqueryui.com/shake-effect/\n   */\n\n\n  var effectShake = $.effects.effect.shake = function (o, done) {\n    var el = $(this),\n        props = [\"position\", \"top\", \"bottom\", \"left\", \"right\", \"height\", \"width\"],\n        mode = $.effects.setMode(el, o.mode || \"effect\"),\n        direction = o.direction || \"left\",\n        distance = o.distance || 20,\n        times = o.times || 3,\n        anims = times * 2 + 1,\n        speed = Math.round(o.duration / anims),\n        ref = direction === \"up\" || direction === \"down\" ? \"top\" : \"left\",\n        positiveMotion = direction === \"up\" || direction === \"left\",\n        animation = {},\n        animation1 = {},\n        animation2 = {},\n        i,\n        // we will need to re-assemble the queue to stack our animations in place\n    queue = el.queue(),\n        queuelen = queue.length;\n    $.effects.save(el, props);\n    el.show();\n    $.effects.createWrapper(el); // Animation\n\n    animation[ref] = (positiveMotion ? \"-=\" : \"+=\") + distance;\n    animation1[ref] = (positiveMotion ? \"+=\" : \"-=\") + distance * 2;\n    animation2[ref] = (positiveMotion ? \"-=\" : \"+=\") + distance * 2; // Animate\n\n    el.animate(animation, speed, o.easing); // Shakes\n\n    for (i = 1; i < times; i++) {\n      el.animate(animation1, speed, o.easing).animate(animation2, speed, o.easing);\n    }\n\n    el.animate(animation1, speed, o.easing).animate(animation, speed / 2, o.easing).queue(function () {\n      if (mode === \"hide\") {\n        el.hide();\n      }\n\n      $.effects.restore(el, props);\n      $.effects.removeWrapper(el);\n      done();\n    }); // inject all the animations we just queued to be first in line (after \"inprogress\")\n\n    if (queuelen > 1) {\n      queue.splice.apply(queue, [1, 0].concat(queue.splice(queuelen, anims + 1)));\n    }\n\n    el.dequeue();\n  };\n  /*!\n   * jQuery UI Effects Slide 1.11.4\n   * http://jqueryui.com\n   *\n   * Copyright jQuery Foundation and other contributors\n   * Released under the MIT license.\n   * http://jquery.org/license\n   *\n   * http://api.jqueryui.com/slide-effect/\n   */\n\n\n  var effectSlide = $.effects.effect.slide = function (o, done) {\n    // Create element\n    var el = $(this),\n        props = [\"position\", \"top\", \"bottom\", \"left\", \"right\", \"width\", \"height\"],\n        mode = $.effects.setMode(el, o.mode || \"show\"),\n        show = mode === \"show\",\n        direction = o.direction || \"left\",\n        ref = direction === \"up\" || direction === \"down\" ? \"top\" : \"left\",\n        positiveMotion = direction === \"up\" || direction === \"left\",\n        distance,\n        animation = {}; // Adjust\n\n    $.effects.save(el, props);\n    el.show();\n    distance = o.distance || el[ref === \"top\" ? \"outerHeight\" : \"outerWidth\"](true);\n    $.effects.createWrapper(el).css({\n      overflow: \"hidden\"\n    });\n\n    if (show) {\n      el.css(ref, positiveMotion ? isNaN(distance) ? \"-\" + distance : -distance : distance);\n    } // Animation\n\n\n    animation[ref] = (show ? positiveMotion ? \"+=\" : \"-=\" : positiveMotion ? \"-=\" : \"+=\") + distance; // Animate\n\n    el.animate(animation, {\n      queue: false,\n      duration: o.duration,\n      easing: o.easing,\n      complete: function complete() {\n        if (mode === \"hide\") {\n          el.hide();\n        }\n\n        $.effects.restore(el, props);\n        $.effects.removeWrapper(el);\n        done();\n      }\n    });\n  };\n  /*!\n   * jQuery UI Effects Transfer 1.11.4\n   * http://jqueryui.com\n   *\n   * Copyright jQuery Foundation and other contributors\n   * Released under the MIT license.\n   * http://jquery.org/license\n   *\n   * http://api.jqueryui.com/transfer-effect/\n   */\n\n\n  var effectTransfer = $.effects.effect.transfer = function (o, done) {\n    var elem = $(this),\n        target = $(o.to),\n        targetFixed = target.css(\"position\") === \"fixed\",\n        body = $(\"body\"),\n        fixTop = targetFixed ? body.scrollTop() : 0,\n        fixLeft = targetFixed ? body.scrollLeft() : 0,\n        endPosition = target.offset(),\n        animation = {\n      top: endPosition.top - fixTop,\n      left: endPosition.left - fixLeft,\n      height: target.innerHeight(),\n      width: target.innerWidth()\n    },\n        startPosition = elem.offset(),\n        transfer = $(\"<div class='ui-effects-transfer'></div>\").appendTo(document.body).addClass(o.className).css({\n      top: startPosition.top - fixTop,\n      left: startPosition.left - fixLeft,\n      height: elem.innerHeight(),\n      width: elem.innerWidth(),\n      position: targetFixed ? \"fixed\" : \"absolute\"\n    }).animate(animation, o.duration, o.easing, function () {\n      transfer.remove();\n      done();\n    });\n  };\n  /*!\n   * jQuery UI Progressbar 1.11.4\n   * http://jqueryui.com\n   *\n   * Copyright jQuery Foundation and other contributors\n   * Released under the MIT license.\n   * http://jquery.org/license\n   *\n   * http://api.jqueryui.com/progressbar/\n   */\n\n\n  var progressbar = $.widget(\"ui.progressbar\", {\n    version: \"1.11.4\",\n    options: {\n      max: 100,\n      value: 0,\n      change: null,\n      complete: null\n    },\n    min: 0,\n    _create: function _create() {\n      // Constrain initial value\n      this.oldValue = this.options.value = this._constrainedValue();\n      this.element.addClass(\"ui-progressbar ui-widget ui-widget-content ui-corner-all\").attr({\n        // Only set static values, aria-valuenow and aria-valuemax are\n        // set inside _refreshValue()\n        role: \"progressbar\",\n        \"aria-valuemin\": this.min\n      });\n      this.valueDiv = $(\"<div class='ui-progressbar-value ui-widget-header ui-corner-left'></div>\").appendTo(this.element);\n\n      this._refreshValue();\n    },\n    _destroy: function _destroy() {\n      this.element.removeClass(\"ui-progressbar ui-widget ui-widget-content ui-corner-all\").removeAttr(\"role\").removeAttr(\"aria-valuemin\").removeAttr(\"aria-valuemax\").removeAttr(\"aria-valuenow\");\n      this.valueDiv.remove();\n    },\n    value: function value(newValue) {\n      if (newValue === undefined) {\n        return this.options.value;\n      }\n\n      this.options.value = this._constrainedValue(newValue);\n\n      this._refreshValue();\n    },\n    _constrainedValue: function _constrainedValue(newValue) {\n      if (newValue === undefined) {\n        newValue = this.options.value;\n      }\n\n      this.indeterminate = newValue === false; // sanitize value\n\n      if (typeof newValue !== \"number\") {\n        newValue = 0;\n      }\n\n      return this.indeterminate ? false : Math.min(this.options.max, Math.max(this.min, newValue));\n    },\n    _setOptions: function _setOptions(options) {\n      // Ensure \"value\" option is set after other values (like max)\n      var value = options.value;\n      delete options.value;\n\n      this._super(options);\n\n      this.options.value = this._constrainedValue(value);\n\n      this._refreshValue();\n    },\n    _setOption: function _setOption(key, value) {\n      if (key === \"max\") {\n        // Don't allow a max less than min\n        value = Math.max(this.min, value);\n      }\n\n      if (key === \"disabled\") {\n        this.element.toggleClass(\"ui-state-disabled\", !!value).attr(\"aria-disabled\", value);\n      }\n\n      this._super(key, value);\n    },\n    _percentage: function _percentage() {\n      return this.indeterminate ? 100 : 100 * (this.options.value - this.min) / (this.options.max - this.min);\n    },\n    _refreshValue: function _refreshValue() {\n      var value = this.options.value,\n          percentage = this._percentage();\n\n      this.valueDiv.toggle(this.indeterminate || value > this.min).toggleClass(\"ui-corner-right\", value === this.options.max).width(percentage.toFixed(0) + \"%\");\n      this.element.toggleClass(\"ui-progressbar-indeterminate\", this.indeterminate);\n\n      if (this.indeterminate) {\n        this.element.removeAttr(\"aria-valuenow\");\n\n        if (!this.overlayDiv) {\n          this.overlayDiv = $(\"<div class='ui-progressbar-overlay'></div>\").appendTo(this.valueDiv);\n        }\n      } else {\n        this.element.attr({\n          \"aria-valuemax\": this.options.max,\n          \"aria-valuenow\": value\n        });\n\n        if (this.overlayDiv) {\n          this.overlayDiv.remove();\n          this.overlayDiv = null;\n        }\n      }\n\n      if (this.oldValue !== value) {\n        this.oldValue = value;\n\n        this._trigger(\"change\");\n      }\n\n      if (value === this.options.max) {\n        this._trigger(\"complete\");\n      }\n    }\n  });\n  /*!\n   * jQuery UI Selectable 1.11.4\n   * http://jqueryui.com\n   *\n   * Copyright jQuery Foundation and other contributors\n   * Released under the MIT license.\n   * http://jquery.org/license\n   *\n   * http://api.jqueryui.com/selectable/\n   */\n\n  var selectable = $.widget(\"ui.selectable\", $.ui.mouse, {\n    version: \"1.11.4\",\n    options: {\n      appendTo: \"body\",\n      autoRefresh: true,\n      distance: 0,\n      filter: \"*\",\n      tolerance: \"touch\",\n      // callbacks\n      selected: null,\n      selecting: null,\n      start: null,\n      stop: null,\n      unselected: null,\n      unselecting: null\n    },\n    _create: function _create() {\n      var selectees,\n          that = this;\n      this.element.addClass(\"ui-selectable\");\n      this.dragged = false; // cache selectee children based on filter\n\n      this.refresh = function () {\n        selectees = $(that.options.filter, that.element[0]);\n        selectees.addClass(\"ui-selectee\");\n        selectees.each(function () {\n          var $this = $(this),\n              pos = $this.offset();\n          $.data(this, \"selectable-item\", {\n            element: this,\n            $element: $this,\n            left: pos.left,\n            top: pos.top,\n            right: pos.left + $this.outerWidth(),\n            bottom: pos.top + $this.outerHeight(),\n            startselected: false,\n            selected: $this.hasClass(\"ui-selected\"),\n            selecting: $this.hasClass(\"ui-selecting\"),\n            unselecting: $this.hasClass(\"ui-unselecting\")\n          });\n        });\n      };\n\n      this.refresh();\n      this.selectees = selectees.addClass(\"ui-selectee\");\n\n      this._mouseInit();\n\n      this.helper = $(\"<div class='ui-selectable-helper'></div>\");\n    },\n    _destroy: function _destroy() {\n      this.selectees.removeClass(\"ui-selectee\").removeData(\"selectable-item\");\n      this.element.removeClass(\"ui-selectable ui-selectable-disabled\");\n\n      this._mouseDestroy();\n    },\n    _mouseStart: function _mouseStart(event) {\n      var that = this,\n          options = this.options;\n      this.opos = [event.pageX, event.pageY];\n\n      if (this.options.disabled) {\n        return;\n      }\n\n      this.selectees = $(options.filter, this.element[0]);\n\n      this._trigger(\"start\", event);\n\n      $(options.appendTo).append(this.helper); // position helper (lasso)\n\n      this.helper.css({\n        \"left\": event.pageX,\n        \"top\": event.pageY,\n        \"width\": 0,\n        \"height\": 0\n      });\n\n      if (options.autoRefresh) {\n        this.refresh();\n      }\n\n      this.selectees.filter(\".ui-selected\").each(function () {\n        var selectee = $.data(this, \"selectable-item\");\n        selectee.startselected = true;\n\n        if (!event.metaKey && !event.ctrlKey) {\n          selectee.$element.removeClass(\"ui-selected\");\n          selectee.selected = false;\n          selectee.$element.addClass(\"ui-unselecting\");\n          selectee.unselecting = true; // selectable UNSELECTING callback\n\n          that._trigger(\"unselecting\", event, {\n            unselecting: selectee.element\n          });\n        }\n      });\n      $(event.target).parents().addBack().each(function () {\n        var doSelect,\n            selectee = $.data(this, \"selectable-item\");\n\n        if (selectee) {\n          doSelect = !event.metaKey && !event.ctrlKey || !selectee.$element.hasClass(\"ui-selected\");\n          selectee.$element.removeClass(doSelect ? \"ui-unselecting\" : \"ui-selected\").addClass(doSelect ? \"ui-selecting\" : \"ui-unselecting\");\n          selectee.unselecting = !doSelect;\n          selectee.selecting = doSelect;\n          selectee.selected = doSelect; // selectable (UN)SELECTING callback\n\n          if (doSelect) {\n            that._trigger(\"selecting\", event, {\n              selecting: selectee.element\n            });\n          } else {\n            that._trigger(\"unselecting\", event, {\n              unselecting: selectee.element\n            });\n          }\n\n          return false;\n        }\n      });\n    },\n    _mouseDrag: function _mouseDrag(event) {\n      this.dragged = true;\n\n      if (this.options.disabled) {\n        return;\n      }\n\n      var tmp,\n          that = this,\n          options = this.options,\n          x1 = this.opos[0],\n          y1 = this.opos[1],\n          x2 = event.pageX,\n          y2 = event.pageY;\n\n      if (x1 > x2) {\n        tmp = x2;\n        x2 = x1;\n        x1 = tmp;\n      }\n\n      if (y1 > y2) {\n        tmp = y2;\n        y2 = y1;\n        y1 = tmp;\n      }\n\n      this.helper.css({\n        left: x1,\n        top: y1,\n        width: x2 - x1,\n        height: y2 - y1\n      });\n      this.selectees.each(function () {\n        var selectee = $.data(this, \"selectable-item\"),\n            hit = false; //prevent helper from being selected if appendTo: selectable\n\n        if (!selectee || selectee.element === that.element[0]) {\n          return;\n        }\n\n        if (options.tolerance === \"touch\") {\n          hit = !(selectee.left > x2 || selectee.right < x1 || selectee.top > y2 || selectee.bottom < y1);\n        } else if (options.tolerance === \"fit\") {\n          hit = selectee.left > x1 && selectee.right < x2 && selectee.top > y1 && selectee.bottom < y2;\n        }\n\n        if (hit) {\n          // SELECT\n          if (selectee.selected) {\n            selectee.$element.removeClass(\"ui-selected\");\n            selectee.selected = false;\n          }\n\n          if (selectee.unselecting) {\n            selectee.$element.removeClass(\"ui-unselecting\");\n            selectee.unselecting = false;\n          }\n\n          if (!selectee.selecting) {\n            selectee.$element.addClass(\"ui-selecting\");\n            selectee.selecting = true; // selectable SELECTING callback\n\n            that._trigger(\"selecting\", event, {\n              selecting: selectee.element\n            });\n          }\n        } else {\n          // UNSELECT\n          if (selectee.selecting) {\n            if ((event.metaKey || event.ctrlKey) && selectee.startselected) {\n              selectee.$element.removeClass(\"ui-selecting\");\n              selectee.selecting = false;\n              selectee.$element.addClass(\"ui-selected\");\n              selectee.selected = true;\n            } else {\n              selectee.$element.removeClass(\"ui-selecting\");\n              selectee.selecting = false;\n\n              if (selectee.startselected) {\n                selectee.$element.addClass(\"ui-unselecting\");\n                selectee.unselecting = true;\n              } // selectable UNSELECTING callback\n\n\n              that._trigger(\"unselecting\", event, {\n                unselecting: selectee.element\n              });\n            }\n          }\n\n          if (selectee.selected) {\n            if (!event.metaKey && !event.ctrlKey && !selectee.startselected) {\n              selectee.$element.removeClass(\"ui-selected\");\n              selectee.selected = false;\n              selectee.$element.addClass(\"ui-unselecting\");\n              selectee.unselecting = true; // selectable UNSELECTING callback\n\n              that._trigger(\"unselecting\", event, {\n                unselecting: selectee.element\n              });\n            }\n          }\n        }\n      });\n      return false;\n    },\n    _mouseStop: function _mouseStop(event) {\n      var that = this;\n      this.dragged = false;\n      $(\".ui-unselecting\", this.element[0]).each(function () {\n        var selectee = $.data(this, \"selectable-item\");\n        selectee.$element.removeClass(\"ui-unselecting\");\n        selectee.unselecting = false;\n        selectee.startselected = false;\n\n        that._trigger(\"unselected\", event, {\n          unselected: selectee.element\n        });\n      });\n      $(\".ui-selecting\", this.element[0]).each(function () {\n        var selectee = $.data(this, \"selectable-item\");\n        selectee.$element.removeClass(\"ui-selecting\").addClass(\"ui-selected\");\n        selectee.selecting = false;\n        selectee.selected = true;\n        selectee.startselected = true;\n\n        that._trigger(\"selected\", event, {\n          selected: selectee.element\n        });\n      });\n\n      this._trigger(\"stop\", event);\n\n      this.helper.remove();\n      return false;\n    }\n  });\n  /*!\n   * jQuery UI Selectmenu 1.11.4\n   * http://jqueryui.com\n   *\n   * Copyright jQuery Foundation and other contributors\n   * Released under the MIT license.\n   * http://jquery.org/license\n   *\n   * http://api.jqueryui.com/selectmenu\n   */\n\n  var selectmenu = $.widget(\"ui.selectmenu\", {\n    version: \"1.11.4\",\n    defaultElement: \"<select>\",\n    options: {\n      appendTo: null,\n      disabled: null,\n      icons: {\n        button: \"ui-icon-triangle-1-s\"\n      },\n      position: {\n        my: \"left top\",\n        at: \"left bottom\",\n        collision: \"none\"\n      },\n      width: null,\n      // callbacks\n      change: null,\n      close: null,\n      focus: null,\n      open: null,\n      select: null\n    },\n    _create: function _create() {\n      var selectmenuId = this.element.uniqueId().attr(\"id\");\n      this.ids = {\n        element: selectmenuId,\n        button: selectmenuId + \"-button\",\n        menu: selectmenuId + \"-menu\"\n      };\n\n      this._drawButton();\n\n      this._drawMenu();\n\n      if (this.options.disabled) {\n        this.disable();\n      }\n    },\n    _drawButton: function _drawButton() {\n      var that = this; // Associate existing label with the new button\n\n      this.label = $(\"label[for='\" + this.ids.element + \"']\").attr(\"for\", this.ids.button);\n\n      this._on(this.label, {\n        click: function click(event) {\n          this.button.focus();\n          event.preventDefault();\n        }\n      }); // Hide original select element\n\n\n      this.element.hide(); // Create button\n\n      this.button = $(\"<span>\", {\n        \"class\": \"ui-selectmenu-button ui-widget ui-state-default ui-corner-all\",\n        tabindex: this.options.disabled ? -1 : 0,\n        id: this.ids.button,\n        role: \"combobox\",\n        \"aria-expanded\": \"false\",\n        \"aria-autocomplete\": \"list\",\n        \"aria-owns\": this.ids.menu,\n        \"aria-haspopup\": \"true\"\n      }).insertAfter(this.element);\n      $(\"<span>\", {\n        \"class\": \"ui-icon \" + this.options.icons.button\n      }).prependTo(this.button);\n      this.buttonText = $(\"<span>\", {\n        \"class\": \"ui-selectmenu-text\"\n      }).appendTo(this.button);\n\n      this._setText(this.buttonText, this.element.find(\"option:selected\").text());\n\n      this._resizeButton();\n\n      this._on(this.button, this._buttonEvents);\n\n      this.button.one(\"focusin\", function () {\n        // Delay rendering the menu items until the button receives focus.\n        // The menu may have already been rendered via a programmatic open.\n        if (!that.menuItems) {\n          that._refreshMenu();\n        }\n      });\n\n      this._hoverable(this.button);\n\n      this._focusable(this.button);\n    },\n    _drawMenu: function _drawMenu() {\n      var that = this; // Create menu\n\n      this.menu = $(\"<ul>\", {\n        \"aria-hidden\": \"true\",\n        \"aria-labelledby\": this.ids.button,\n        id: this.ids.menu\n      }); // Wrap menu\n\n      this.menuWrap = $(\"<div>\", {\n        \"class\": \"ui-selectmenu-menu ui-front\"\n      }).append(this.menu).appendTo(this._appendTo()); // Initialize menu widget\n\n      this.menuInstance = this.menu.menu({\n        role: \"listbox\",\n        select: function select(event, ui) {\n          event.preventDefault(); // support: IE8\n          // If the item was selected via a click, the text selection\n          // will be destroyed in IE\n\n          that._setSelection();\n\n          that._select(ui.item.data(\"ui-selectmenu-item\"), event);\n        },\n        focus: function focus(event, ui) {\n          var item = ui.item.data(\"ui-selectmenu-item\"); // Prevent inital focus from firing and check if its a newly focused item\n\n          if (that.focusIndex != null && item.index !== that.focusIndex) {\n            that._trigger(\"focus\", event, {\n              item: item\n            });\n\n            if (!that.isOpen) {\n              that._select(item, event);\n            }\n          }\n\n          that.focusIndex = item.index;\n          that.button.attr(\"aria-activedescendant\", that.menuItems.eq(item.index).attr(\"id\"));\n        }\n      }).menu(\"instance\"); // Adjust menu styles to dropdown\n\n      this.menu.addClass(\"ui-corner-bottom\").removeClass(\"ui-corner-all\"); // Don't close the menu on mouseleave\n\n      this.menuInstance._off(this.menu, \"mouseleave\"); // Cancel the menu's collapseAll on document click\n\n\n      this.menuInstance._closeOnDocumentClick = function () {\n        return false;\n      }; // Selects often contain empty items, but never contain dividers\n\n\n      this.menuInstance._isDivider = function () {\n        return false;\n      };\n    },\n    refresh: function refresh() {\n      this._refreshMenu();\n\n      this._setText(this.buttonText, this._getSelectedItem().text());\n\n      if (!this.options.width) {\n        this._resizeButton();\n      }\n    },\n    _refreshMenu: function _refreshMenu() {\n      this.menu.empty();\n      var item,\n          options = this.element.find(\"option\");\n\n      if (!options.length) {\n        return;\n      }\n\n      this._parseOptions(options);\n\n      this._renderMenu(this.menu, this.items);\n\n      this.menuInstance.refresh();\n      this.menuItems = this.menu.find(\"li\").not(\".ui-selectmenu-optgroup\");\n      item = this._getSelectedItem(); // Update the menu to have the correct item focused\n\n      this.menuInstance.focus(null, item);\n\n      this._setAria(item.data(\"ui-selectmenu-item\")); // Set disabled state\n\n\n      this._setOption(\"disabled\", this.element.prop(\"disabled\"));\n    },\n    open: function open(event) {\n      if (this.options.disabled) {\n        return;\n      } // If this is the first time the menu is being opened, render the items\n\n\n      if (!this.menuItems) {\n        this._refreshMenu();\n      } else {\n        // Menu clears focus on close, reset focus to selected item\n        this.menu.find(\".ui-state-focus\").removeClass(\"ui-state-focus\");\n        this.menuInstance.focus(null, this._getSelectedItem());\n      }\n\n      this.isOpen = true;\n\n      this._toggleAttr();\n\n      this._resizeMenu();\n\n      this._position();\n\n      this._on(this.document, this._documentClick);\n\n      this._trigger(\"open\", event);\n    },\n    _position: function _position() {\n      this.menuWrap.position($.extend({\n        of: this.button\n      }, this.options.position));\n    },\n    close: function close(event) {\n      if (!this.isOpen) {\n        return;\n      }\n\n      this.isOpen = false;\n\n      this._toggleAttr();\n\n      this.range = null;\n\n      this._off(this.document);\n\n      this._trigger(\"close\", event);\n    },\n    widget: function widget() {\n      return this.button;\n    },\n    menuWidget: function menuWidget() {\n      return this.menu;\n    },\n    _renderMenu: function _renderMenu(ul, items) {\n      var that = this,\n          currentOptgroup = \"\";\n      $.each(items, function (index, item) {\n        if (item.optgroup !== currentOptgroup) {\n          $(\"<li>\", {\n            \"class\": \"ui-selectmenu-optgroup ui-menu-divider\" + (item.element.parent(\"optgroup\").prop(\"disabled\") ? \" ui-state-disabled\" : \"\"),\n            text: item.optgroup\n          }).appendTo(ul);\n          currentOptgroup = item.optgroup;\n        }\n\n        that._renderItemData(ul, item);\n      });\n    },\n    _renderItemData: function _renderItemData(ul, item) {\n      return this._renderItem(ul, item).data(\"ui-selectmenu-item\", item);\n    },\n    _renderItem: function _renderItem(ul, item) {\n      var li = $(\"<li>\");\n\n      if (item.disabled) {\n        li.addClass(\"ui-state-disabled\");\n      }\n\n      this._setText(li, item.label);\n\n      return li.appendTo(ul);\n    },\n    _setText: function _setText(element, value) {\n      if (value) {\n        element.text(value);\n      } else {\n        element.html(\"&#160;\");\n      }\n    },\n    _move: function _move(direction, event) {\n      var item,\n          next,\n          filter = \".ui-menu-item\";\n\n      if (this.isOpen) {\n        item = this.menuItems.eq(this.focusIndex);\n      } else {\n        item = this.menuItems.eq(this.element[0].selectedIndex);\n        filter += \":not(.ui-state-disabled)\";\n      }\n\n      if (direction === \"first\" || direction === \"last\") {\n        next = item[direction === \"first\" ? \"prevAll\" : \"nextAll\"](filter).eq(-1);\n      } else {\n        next = item[direction + \"All\"](filter).eq(0);\n      }\n\n      if (next.length) {\n        this.menuInstance.focus(event, next);\n      }\n    },\n    _getSelectedItem: function _getSelectedItem() {\n      return this.menuItems.eq(this.element[0].selectedIndex);\n    },\n    _toggle: function _toggle(event) {\n      this[this.isOpen ? \"close\" : \"open\"](event);\n    },\n    _setSelection: function _setSelection() {\n      var selection;\n\n      if (!this.range) {\n        return;\n      }\n\n      if (window.getSelection) {\n        selection = window.getSelection();\n        selection.removeAllRanges();\n        selection.addRange(this.range); // support: IE8\n      } else {\n        this.range.select();\n      } // support: IE\n      // Setting the text selection kills the button focus in IE, but\n      // restoring the focus doesn't kill the selection.\n\n\n      this.button.focus();\n    },\n    _documentClick: {\n      mousedown: function mousedown(event) {\n        if (!this.isOpen) {\n          return;\n        }\n\n        if (!$(event.target).closest(\".ui-selectmenu-menu, #\" + this.ids.button).length) {\n          this.close(event);\n        }\n      }\n    },\n    _buttonEvents: {\n      // Prevent text selection from being reset when interacting with the selectmenu (#10144)\n      mousedown: function mousedown() {\n        var selection;\n\n        if (window.getSelection) {\n          selection = window.getSelection();\n\n          if (selection.rangeCount) {\n            this.range = selection.getRangeAt(0);\n          } // support: IE8\n\n        } else {\n          this.range = document.selection.createRange();\n        }\n      },\n      click: function click(event) {\n        this._setSelection();\n\n        this._toggle(event);\n      },\n      keydown: function keydown(event) {\n        var preventDefault = true;\n\n        switch (event.keyCode) {\n          case $.ui.keyCode.TAB:\n          case $.ui.keyCode.ESCAPE:\n            this.close(event);\n            preventDefault = false;\n            break;\n\n          case $.ui.keyCode.ENTER:\n            if (this.isOpen) {\n              this._selectFocusedItem(event);\n            }\n\n            break;\n\n          case $.ui.keyCode.UP:\n            if (event.altKey) {\n              this._toggle(event);\n            } else {\n              this._move(\"prev\", event);\n            }\n\n            break;\n\n          case $.ui.keyCode.DOWN:\n            if (event.altKey) {\n              this._toggle(event);\n            } else {\n              this._move(\"next\", event);\n            }\n\n            break;\n\n          case $.ui.keyCode.SPACE:\n            if (this.isOpen) {\n              this._selectFocusedItem(event);\n            } else {\n              this._toggle(event);\n            }\n\n            break;\n\n          case $.ui.keyCode.LEFT:\n            this._move(\"prev\", event);\n\n            break;\n\n          case $.ui.keyCode.RIGHT:\n            this._move(\"next\", event);\n\n            break;\n\n          case $.ui.keyCode.HOME:\n          case $.ui.keyCode.PAGE_UP:\n            this._move(\"first\", event);\n\n            break;\n\n          case $.ui.keyCode.END:\n          case $.ui.keyCode.PAGE_DOWN:\n            this._move(\"last\", event);\n\n            break;\n\n          default:\n            this.menu.trigger(event);\n            preventDefault = false;\n        }\n\n        if (preventDefault) {\n          event.preventDefault();\n        }\n      }\n    },\n    _selectFocusedItem: function _selectFocusedItem(event) {\n      var item = this.menuItems.eq(this.focusIndex);\n\n      if (!item.hasClass(\"ui-state-disabled\")) {\n        this._select(item.data(\"ui-selectmenu-item\"), event);\n      }\n    },\n    _select: function _select(item, event) {\n      var oldIndex = this.element[0].selectedIndex; // Change native select element\n\n      this.element[0].selectedIndex = item.index;\n\n      this._setText(this.buttonText, item.label);\n\n      this._setAria(item);\n\n      this._trigger(\"select\", event, {\n        item: item\n      });\n\n      if (item.index !== oldIndex) {\n        this._trigger(\"change\", event, {\n          item: item\n        });\n      }\n\n      this.close(event);\n    },\n    _setAria: function _setAria(item) {\n      var id = this.menuItems.eq(item.index).attr(\"id\");\n      this.button.attr({\n        \"aria-labelledby\": id,\n        \"aria-activedescendant\": id\n      });\n      this.menu.attr(\"aria-activedescendant\", id);\n    },\n    _setOption: function _setOption(key, value) {\n      if (key === \"icons\") {\n        this.button.find(\"span.ui-icon\").removeClass(this.options.icons.button).addClass(value.button);\n      }\n\n      this._super(key, value);\n\n      if (key === \"appendTo\") {\n        this.menuWrap.appendTo(this._appendTo());\n      }\n\n      if (key === \"disabled\") {\n        this.menuInstance.option(\"disabled\", value);\n        this.button.toggleClass(\"ui-state-disabled\", value).attr(\"aria-disabled\", value);\n        this.element.prop(\"disabled\", value);\n\n        if (value) {\n          this.button.attr(\"tabindex\", -1);\n          this.close();\n        } else {\n          this.button.attr(\"tabindex\", 0);\n        }\n      }\n\n      if (key === \"width\") {\n        this._resizeButton();\n      }\n    },\n    _appendTo: function _appendTo() {\n      var element = this.options.appendTo;\n\n      if (element) {\n        element = element.jquery || element.nodeType ? $(element) : this.document.find(element).eq(0);\n      }\n\n      if (!element || !element[0]) {\n        element = this.element.closest(\".ui-front\");\n      }\n\n      if (!element.length) {\n        element = this.document[0].body;\n      }\n\n      return element;\n    },\n    _toggleAttr: function _toggleAttr() {\n      this.button.toggleClass(\"ui-corner-top\", this.isOpen).toggleClass(\"ui-corner-all\", !this.isOpen).attr(\"aria-expanded\", this.isOpen);\n      this.menuWrap.toggleClass(\"ui-selectmenu-open\", this.isOpen);\n      this.menu.attr(\"aria-hidden\", !this.isOpen);\n    },\n    _resizeButton: function _resizeButton() {\n      var width = this.options.width;\n\n      if (!width) {\n        width = this.element.show().outerWidth();\n        this.element.hide();\n      }\n\n      this.button.outerWidth(width);\n    },\n    _resizeMenu: function _resizeMenu() {\n      this.menu.outerWidth(Math.max(this.button.outerWidth(), // support: IE10\n      // IE10 wraps long text (possibly a rounding bug)\n      // so we add 1px to avoid the wrapping\n      this.menu.width(\"\").outerWidth() + 1));\n    },\n    _getCreateOptions: function _getCreateOptions() {\n      return {\n        disabled: this.element.prop(\"disabled\")\n      };\n    },\n    _parseOptions: function _parseOptions(options) {\n      var data = [];\n      options.each(function (index, item) {\n        var option = $(item),\n            optgroup = option.parent(\"optgroup\");\n        data.push({\n          element: option,\n          index: index,\n          value: option.val(),\n          label: option.text(),\n          optgroup: optgroup.attr(\"label\") || \"\",\n          disabled: optgroup.prop(\"disabled\") || option.prop(\"disabled\")\n        });\n      });\n      this.items = data;\n    },\n    _destroy: function _destroy() {\n      this.menuWrap.remove();\n      this.button.remove();\n      this.element.show();\n      this.element.removeUniqueId();\n      this.label.attr(\"for\", this.ids.element);\n    }\n  });\n  /*!\n   * jQuery UI Slider 1.11.4\n   * http://jqueryui.com\n   *\n   * Copyright jQuery Foundation and other contributors\n   * Released under the MIT license.\n   * http://jquery.org/license\n   *\n   * http://api.jqueryui.com/slider/\n   */\n\n  var slider = $.widget(\"ui.slider\", $.ui.mouse, {\n    version: \"1.11.4\",\n    widgetEventPrefix: \"slide\",\n    options: {\n      animate: false,\n      distance: 0,\n      max: 100,\n      min: 0,\n      orientation: \"horizontal\",\n      range: false,\n      step: 1,\n      value: 0,\n      values: null,\n      // callbacks\n      change: null,\n      slide: null,\n      start: null,\n      stop: null\n    },\n    // number of pages in a slider\n    // (how many times can you page up/down to go through the whole range)\n    numPages: 5,\n    _create: function _create() {\n      this._keySliding = false;\n      this._mouseSliding = false;\n      this._animateOff = true;\n      this._handleIndex = null;\n\n      this._detectOrientation();\n\n      this._mouseInit();\n\n      this._calculateNewMax();\n\n      this.element.addClass(\"ui-slider\" + \" ui-slider-\" + this.orientation + \" ui-widget\" + \" ui-widget-content\" + \" ui-corner-all\");\n\n      this._refresh();\n\n      this._setOption(\"disabled\", this.options.disabled);\n\n      this._animateOff = false;\n    },\n    _refresh: function _refresh() {\n      this._createRange();\n\n      this._createHandles();\n\n      this._setupEvents();\n\n      this._refreshValue();\n    },\n    _createHandles: function _createHandles() {\n      var i,\n          handleCount,\n          options = this.options,\n          existingHandles = this.element.find(\".ui-slider-handle\").addClass(\"ui-state-default ui-corner-all\"),\n          handle = \"<span class='ui-slider-handle ui-state-default ui-corner-all' tabindex='0'></span>\",\n          handles = [];\n      handleCount = options.values && options.values.length || 1;\n\n      if (existingHandles.length > handleCount) {\n        existingHandles.slice(handleCount).remove();\n        existingHandles = existingHandles.slice(0, handleCount);\n      }\n\n      for (i = existingHandles.length; i < handleCount; i++) {\n        handles.push(handle);\n      }\n\n      this.handles = existingHandles.add($(handles.join(\"\")).appendTo(this.element));\n      this.handle = this.handles.eq(0);\n      this.handles.each(function (i) {\n        $(this).data(\"ui-slider-handle-index\", i);\n      });\n    },\n    _createRange: function _createRange() {\n      var options = this.options,\n          classes = \"\";\n\n      if (options.range) {\n        if (options.range === true) {\n          if (!options.values) {\n            options.values = [this._valueMin(), this._valueMin()];\n          } else if (options.values.length && options.values.length !== 2) {\n            options.values = [options.values[0], options.values[0]];\n          } else if ($.isArray(options.values)) {\n            options.values = options.values.slice(0);\n          }\n        }\n\n        if (!this.range || !this.range.length) {\n          this.range = $(\"<div></div>\").appendTo(this.element);\n          classes = \"ui-slider-range\" + // note: this isn't the most fittingly semantic framework class for this element,\n          // but worked best visually with a variety of themes\n          \" ui-widget-header ui-corner-all\";\n        } else {\n          this.range.removeClass(\"ui-slider-range-min ui-slider-range-max\") // Handle range switching from true to min/max\n          .css({\n            \"left\": \"\",\n            \"bottom\": \"\"\n          });\n        }\n\n        this.range.addClass(classes + (options.range === \"min\" || options.range === \"max\" ? \" ui-slider-range-\" + options.range : \"\"));\n      } else {\n        if (this.range) {\n          this.range.remove();\n        }\n\n        this.range = null;\n      }\n    },\n    _setupEvents: function _setupEvents() {\n      this._off(this.handles);\n\n      this._on(this.handles, this._handleEvents);\n\n      this._hoverable(this.handles);\n\n      this._focusable(this.handles);\n    },\n    _destroy: function _destroy() {\n      this.handles.remove();\n\n      if (this.range) {\n        this.range.remove();\n      }\n\n      this.element.removeClass(\"ui-slider\" + \" ui-slider-horizontal\" + \" ui-slider-vertical\" + \" ui-widget\" + \" ui-widget-content\" + \" ui-corner-all\");\n\n      this._mouseDestroy();\n    },\n    _mouseCapture: function _mouseCapture(event) {\n      var position,\n          normValue,\n          distance,\n          closestHandle,\n          index,\n          allowed,\n          offset,\n          mouseOverHandle,\n          that = this,\n          o = this.options;\n\n      if (o.disabled) {\n        return false;\n      }\n\n      this.elementSize = {\n        width: this.element.outerWidth(),\n        height: this.element.outerHeight()\n      };\n      this.elementOffset = this.element.offset();\n      position = {\n        x: event.pageX,\n        y: event.pageY\n      };\n      normValue = this._normValueFromMouse(position);\n      distance = this._valueMax() - this._valueMin() + 1;\n      this.handles.each(function (i) {\n        var thisDistance = Math.abs(normValue - that.values(i));\n\n        if (distance > thisDistance || distance === thisDistance && (i === that._lastChangedValue || that.values(i) === o.min)) {\n          distance = thisDistance;\n          closestHandle = $(this);\n          index = i;\n        }\n      });\n      allowed = this._start(event, index);\n\n      if (allowed === false) {\n        return false;\n      }\n\n      this._mouseSliding = true;\n      this._handleIndex = index;\n      closestHandle.addClass(\"ui-state-active\").focus();\n      offset = closestHandle.offset();\n      mouseOverHandle = !$(event.target).parents().addBack().is(\".ui-slider-handle\");\n      this._clickOffset = mouseOverHandle ? {\n        left: 0,\n        top: 0\n      } : {\n        left: event.pageX - offset.left - closestHandle.width() / 2,\n        top: event.pageY - offset.top - closestHandle.height() / 2 - (parseInt(closestHandle.css(\"borderTopWidth\"), 10) || 0) - (parseInt(closestHandle.css(\"borderBottomWidth\"), 10) || 0) + (parseInt(closestHandle.css(\"marginTop\"), 10) || 0)\n      };\n\n      if (!this.handles.hasClass(\"ui-state-hover\")) {\n        this._slide(event, index, normValue);\n      }\n\n      this._animateOff = true;\n      return true;\n    },\n    _mouseStart: function _mouseStart() {\n      return true;\n    },\n    _mouseDrag: function _mouseDrag(event) {\n      var position = {\n        x: event.pageX,\n        y: event.pageY\n      },\n          normValue = this._normValueFromMouse(position);\n\n      this._slide(event, this._handleIndex, normValue);\n\n      return false;\n    },\n    _mouseStop: function _mouseStop(event) {\n      this.handles.removeClass(\"ui-state-active\");\n      this._mouseSliding = false;\n\n      this._stop(event, this._handleIndex);\n\n      this._change(event, this._handleIndex);\n\n      this._handleIndex = null;\n      this._clickOffset = null;\n      this._animateOff = false;\n      return false;\n    },\n    _detectOrientation: function _detectOrientation() {\n      this.orientation = this.options.orientation === \"vertical\" ? \"vertical\" : \"horizontal\";\n    },\n    _normValueFromMouse: function _normValueFromMouse(position) {\n      var pixelTotal, pixelMouse, percentMouse, valueTotal, valueMouse;\n\n      if (this.orientation === \"horizontal\") {\n        pixelTotal = this.elementSize.width;\n        pixelMouse = position.x - this.elementOffset.left - (this._clickOffset ? this._clickOffset.left : 0);\n      } else {\n        pixelTotal = this.elementSize.height;\n        pixelMouse = position.y - this.elementOffset.top - (this._clickOffset ? this._clickOffset.top : 0);\n      }\n\n      percentMouse = pixelMouse / pixelTotal;\n\n      if (percentMouse > 1) {\n        percentMouse = 1;\n      }\n\n      if (percentMouse < 0) {\n        percentMouse = 0;\n      }\n\n      if (this.orientation === \"vertical\") {\n        percentMouse = 1 - percentMouse;\n      }\n\n      valueTotal = this._valueMax() - this._valueMin();\n      valueMouse = this._valueMin() + percentMouse * valueTotal;\n      return this._trimAlignValue(valueMouse);\n    },\n    _start: function _start(event, index) {\n      var uiHash = {\n        handle: this.handles[index],\n        value: this.value()\n      };\n\n      if (this.options.values && this.options.values.length) {\n        uiHash.value = this.values(index);\n        uiHash.values = this.values();\n      }\n\n      return this._trigger(\"start\", event, uiHash);\n    },\n    _slide: function _slide(event, index, newVal) {\n      var otherVal, newValues, allowed;\n\n      if (this.options.values && this.options.values.length) {\n        otherVal = this.values(index ? 0 : 1);\n\n        if (this.options.values.length === 2 && this.options.range === true && (index === 0 && newVal > otherVal || index === 1 && newVal < otherVal)) {\n          newVal = otherVal;\n        }\n\n        if (newVal !== this.values(index)) {\n          newValues = this.values();\n          newValues[index] = newVal; // A slide can be canceled by returning false from the slide callback\n\n          allowed = this._trigger(\"slide\", event, {\n            handle: this.handles[index],\n            value: newVal,\n            values: newValues\n          });\n          otherVal = this.values(index ? 0 : 1);\n\n          if (allowed !== false) {\n            this.values(index, newVal);\n          }\n        }\n      } else {\n        if (newVal !== this.value()) {\n          // A slide can be canceled by returning false from the slide callback\n          allowed = this._trigger(\"slide\", event, {\n            handle: this.handles[index],\n            value: newVal\n          });\n\n          if (allowed !== false) {\n            this.value(newVal);\n          }\n        }\n      }\n    },\n    _stop: function _stop(event, index) {\n      var uiHash = {\n        handle: this.handles[index],\n        value: this.value()\n      };\n\n      if (this.options.values && this.options.values.length) {\n        uiHash.value = this.values(index);\n        uiHash.values = this.values();\n      }\n\n      this._trigger(\"stop\", event, uiHash);\n    },\n    _change: function _change(event, index) {\n      if (!this._keySliding && !this._mouseSliding) {\n        var uiHash = {\n          handle: this.handles[index],\n          value: this.value()\n        };\n\n        if (this.options.values && this.options.values.length) {\n          uiHash.value = this.values(index);\n          uiHash.values = this.values();\n        } //store the last changed value index for reference when handles overlap\n\n\n        this._lastChangedValue = index;\n\n        this._trigger(\"change\", event, uiHash);\n      }\n    },\n    value: function value(newValue) {\n      if (arguments.length) {\n        this.options.value = this._trimAlignValue(newValue);\n\n        this._refreshValue();\n\n        this._change(null, 0);\n\n        return;\n      }\n\n      return this._value();\n    },\n    values: function values(index, newValue) {\n      var vals, newValues, i;\n\n      if (arguments.length > 1) {\n        this.options.values[index] = this._trimAlignValue(newValue);\n\n        this._refreshValue();\n\n        this._change(null, index);\n\n        return;\n      }\n\n      if (arguments.length) {\n        if ($.isArray(arguments[0])) {\n          vals = this.options.values;\n          newValues = arguments[0];\n\n          for (i = 0; i < vals.length; i += 1) {\n            vals[i] = this._trimAlignValue(newValues[i]);\n\n            this._change(null, i);\n          }\n\n          this._refreshValue();\n        } else {\n          if (this.options.values && this.options.values.length) {\n            return this._values(index);\n          } else {\n            return this.value();\n          }\n        }\n      } else {\n        return this._values();\n      }\n    },\n    _setOption: function _setOption(key, value) {\n      var i,\n          valsLength = 0;\n\n      if (key === \"range\" && this.options.range === true) {\n        if (value === \"min\") {\n          this.options.value = this._values(0);\n          this.options.values = null;\n        } else if (value === \"max\") {\n          this.options.value = this._values(this.options.values.length - 1);\n          this.options.values = null;\n        }\n      }\n\n      if ($.isArray(this.options.values)) {\n        valsLength = this.options.values.length;\n      }\n\n      if (key === \"disabled\") {\n        this.element.toggleClass(\"ui-state-disabled\", !!value);\n      }\n\n      this._super(key, value);\n\n      switch (key) {\n        case \"orientation\":\n          this._detectOrientation();\n\n          this.element.removeClass(\"ui-slider-horizontal ui-slider-vertical\").addClass(\"ui-slider-\" + this.orientation);\n\n          this._refreshValue(); // Reset positioning from previous orientation\n\n\n          this.handles.css(value === \"horizontal\" ? \"bottom\" : \"left\", \"\");\n          break;\n\n        case \"value\":\n          this._animateOff = true;\n\n          this._refreshValue();\n\n          this._change(null, 0);\n\n          this._animateOff = false;\n          break;\n\n        case \"values\":\n          this._animateOff = true;\n\n          this._refreshValue();\n\n          for (i = 0; i < valsLength; i += 1) {\n            this._change(null, i);\n          }\n\n          this._animateOff = false;\n          break;\n\n        case \"step\":\n        case \"min\":\n        case \"max\":\n          this._animateOff = true;\n\n          this._calculateNewMax();\n\n          this._refreshValue();\n\n          this._animateOff = false;\n          break;\n\n        case \"range\":\n          this._animateOff = true;\n\n          this._refresh();\n\n          this._animateOff = false;\n          break;\n      }\n    },\n    //internal value getter\n    // _value() returns value trimmed by min and max, aligned by step\n    _value: function _value() {\n      var val = this.options.value;\n      val = this._trimAlignValue(val);\n      return val;\n    },\n    //internal values getter\n    // _values() returns array of values trimmed by min and max, aligned by step\n    // _values( index ) returns single value trimmed by min and max, aligned by step\n    _values: function _values(index) {\n      var val, vals, i;\n\n      if (arguments.length) {\n        val = this.options.values[index];\n        val = this._trimAlignValue(val);\n        return val;\n      } else if (this.options.values && this.options.values.length) {\n        // .slice() creates a copy of the array\n        // this copy gets trimmed by min and max and then returned\n        vals = this.options.values.slice();\n\n        for (i = 0; i < vals.length; i += 1) {\n          vals[i] = this._trimAlignValue(vals[i]);\n        }\n\n        return vals;\n      } else {\n        return [];\n      }\n    },\n    // returns the step-aligned value that val is closest to, between (inclusive) min and max\n    _trimAlignValue: function _trimAlignValue(val) {\n      if (val <= this._valueMin()) {\n        return this._valueMin();\n      }\n\n      if (val >= this._valueMax()) {\n        return this._valueMax();\n      }\n\n      var step = this.options.step > 0 ? this.options.step : 1,\n          valModStep = (val - this._valueMin()) % step,\n          alignValue = val - valModStep;\n\n      if (Math.abs(valModStep) * 2 >= step) {\n        alignValue += valModStep > 0 ? step : -step;\n      } // Since JavaScript has problems with large floats, round\n      // the final value to 5 digits after the decimal point (see #4124)\n\n\n      return parseFloat(alignValue.toFixed(5));\n    },\n    _calculateNewMax: function _calculateNewMax() {\n      var max = this.options.max,\n          min = this._valueMin(),\n          step = this.options.step,\n          aboveMin = Math.floor(+(max - min).toFixed(this._precision()) / step) * step;\n\n      max = aboveMin + min;\n      this.max = parseFloat(max.toFixed(this._precision()));\n    },\n    _precision: function _precision() {\n      var precision = this._precisionOf(this.options.step);\n\n      if (this.options.min !== null) {\n        precision = Math.max(precision, this._precisionOf(this.options.min));\n      }\n\n      return precision;\n    },\n    _precisionOf: function _precisionOf(num) {\n      var str = num.toString(),\n          decimal = str.indexOf(\".\");\n      return decimal === -1 ? 0 : str.length - decimal - 1;\n    },\n    _valueMin: function _valueMin() {\n      return this.options.min;\n    },\n    _valueMax: function _valueMax() {\n      return this.max;\n    },\n    _refreshValue: function _refreshValue() {\n      var lastValPercent,\n          valPercent,\n          value,\n          valueMin,\n          valueMax,\n          oRange = this.options.range,\n          o = this.options,\n          that = this,\n          animate = !this._animateOff ? o.animate : false,\n          _set = {};\n\n      if (this.options.values && this.options.values.length) {\n        this.handles.each(function (i) {\n          valPercent = (that.values(i) - that._valueMin()) / (that._valueMax() - that._valueMin()) * 100;\n          _set[that.orientation === \"horizontal\" ? \"left\" : \"bottom\"] = valPercent + \"%\";\n          $(this).stop(1, 1)[animate ? \"animate\" : \"css\"](_set, o.animate);\n\n          if (that.options.range === true) {\n            if (that.orientation === \"horizontal\") {\n              if (i === 0) {\n                that.range.stop(1, 1)[animate ? \"animate\" : \"css\"]({\n                  left: valPercent + \"%\"\n                }, o.animate);\n              }\n\n              if (i === 1) {\n                that.range[animate ? \"animate\" : \"css\"]({\n                  width: valPercent - lastValPercent + \"%\"\n                }, {\n                  queue: false,\n                  duration: o.animate\n                });\n              }\n            } else {\n              if (i === 0) {\n                that.range.stop(1, 1)[animate ? \"animate\" : \"css\"]({\n                  bottom: valPercent + \"%\"\n                }, o.animate);\n              }\n\n              if (i === 1) {\n                that.range[animate ? \"animate\" : \"css\"]({\n                  height: valPercent - lastValPercent + \"%\"\n                }, {\n                  queue: false,\n                  duration: o.animate\n                });\n              }\n            }\n          }\n\n          lastValPercent = valPercent;\n        });\n      } else {\n        value = this.value();\n        valueMin = this._valueMin();\n        valueMax = this._valueMax();\n        valPercent = valueMax !== valueMin ? (value - valueMin) / (valueMax - valueMin) * 100 : 0;\n        _set[this.orientation === \"horizontal\" ? \"left\" : \"bottom\"] = valPercent + \"%\";\n        this.handle.stop(1, 1)[animate ? \"animate\" : \"css\"](_set, o.animate);\n\n        if (oRange === \"min\" && this.orientation === \"horizontal\") {\n          this.range.stop(1, 1)[animate ? \"animate\" : \"css\"]({\n            width: valPercent + \"%\"\n          }, o.animate);\n        }\n\n        if (oRange === \"max\" && this.orientation === \"horizontal\") {\n          this.range[animate ? \"animate\" : \"css\"]({\n            width: 100 - valPercent + \"%\"\n          }, {\n            queue: false,\n            duration: o.animate\n          });\n        }\n\n        if (oRange === \"min\" && this.orientation === \"vertical\") {\n          this.range.stop(1, 1)[animate ? \"animate\" : \"css\"]({\n            height: valPercent + \"%\"\n          }, o.animate);\n        }\n\n        if (oRange === \"max\" && this.orientation === \"vertical\") {\n          this.range[animate ? \"animate\" : \"css\"]({\n            height: 100 - valPercent + \"%\"\n          }, {\n            queue: false,\n            duration: o.animate\n          });\n        }\n      }\n    },\n    _handleEvents: {\n      keydown: function keydown(event) {\n        var allowed,\n            curVal,\n            newVal,\n            step,\n            index = $(event.target).data(\"ui-slider-handle-index\");\n\n        switch (event.keyCode) {\n          case $.ui.keyCode.HOME:\n          case $.ui.keyCode.END:\n          case $.ui.keyCode.PAGE_UP:\n          case $.ui.keyCode.PAGE_DOWN:\n          case $.ui.keyCode.UP:\n          case $.ui.keyCode.RIGHT:\n          case $.ui.keyCode.DOWN:\n          case $.ui.keyCode.LEFT:\n            event.preventDefault();\n\n            if (!this._keySliding) {\n              this._keySliding = true;\n              $(event.target).addClass(\"ui-state-active\");\n              allowed = this._start(event, index);\n\n              if (allowed === false) {\n                return;\n              }\n            }\n\n            break;\n        }\n\n        step = this.options.step;\n\n        if (this.options.values && this.options.values.length) {\n          curVal = newVal = this.values(index);\n        } else {\n          curVal = newVal = this.value();\n        }\n\n        switch (event.keyCode) {\n          case $.ui.keyCode.HOME:\n            newVal = this._valueMin();\n            break;\n\n          case $.ui.keyCode.END:\n            newVal = this._valueMax();\n            break;\n\n          case $.ui.keyCode.PAGE_UP:\n            newVal = this._trimAlignValue(curVal + (this._valueMax() - this._valueMin()) / this.numPages);\n            break;\n\n          case $.ui.keyCode.PAGE_DOWN:\n            newVal = this._trimAlignValue(curVal - (this._valueMax() - this._valueMin()) / this.numPages);\n            break;\n\n          case $.ui.keyCode.UP:\n          case $.ui.keyCode.RIGHT:\n            if (curVal === this._valueMax()) {\n              return;\n            }\n\n            newVal = this._trimAlignValue(curVal + step);\n            break;\n\n          case $.ui.keyCode.DOWN:\n          case $.ui.keyCode.LEFT:\n            if (curVal === this._valueMin()) {\n              return;\n            }\n\n            newVal = this._trimAlignValue(curVal - step);\n            break;\n        }\n\n        this._slide(event, index, newVal);\n      },\n      keyup: function keyup(event) {\n        var index = $(event.target).data(\"ui-slider-handle-index\");\n\n        if (this._keySliding) {\n          this._keySliding = false;\n\n          this._stop(event, index);\n\n          this._change(event, index);\n\n          $(event.target).removeClass(\"ui-state-active\");\n        }\n      }\n    }\n  });\n  /*!\n   * jQuery UI Sortable 1.11.4\n   * http://jqueryui.com\n   *\n   * Copyright jQuery Foundation and other contributors\n   * Released under the MIT license.\n   * http://jquery.org/license\n   *\n   * http://api.jqueryui.com/sortable/\n   */\n\n  var sortable = $.widget(\"ui.sortable\", $.ui.mouse, {\n    version: \"1.11.4\",\n    widgetEventPrefix: \"sort\",\n    ready: false,\n    options: {\n      appendTo: \"parent\",\n      axis: false,\n      connectWith: false,\n      containment: false,\n      cursor: \"auto\",\n      cursorAt: false,\n      dropOnEmpty: true,\n      forcePlaceholderSize: false,\n      forceHelperSize: false,\n      grid: false,\n      handle: false,\n      helper: \"original\",\n      items: \"> *\",\n      opacity: false,\n      placeholder: false,\n      revert: false,\n      scroll: true,\n      scrollSensitivity: 20,\n      scrollSpeed: 20,\n      scope: \"default\",\n      tolerance: \"intersect\",\n      zIndex: 1000,\n      // callbacks\n      activate: null,\n      beforeStop: null,\n      change: null,\n      deactivate: null,\n      out: null,\n      over: null,\n      receive: null,\n      remove: null,\n      sort: null,\n      start: null,\n      stop: null,\n      update: null\n    },\n    _isOverAxis: function _isOverAxis(x, reference, size) {\n      return x >= reference && x < reference + size;\n    },\n    _isFloating: function _isFloating(item) {\n      return /left|right/.test(item.css(\"float\")) || /inline|table-cell/.test(item.css(\"display\"));\n    },\n    _create: function _create() {\n      this.containerCache = {};\n      this.element.addClass(\"ui-sortable\"); //Get the items\n\n      this.refresh(); //Let's determine the parent's offset\n\n      this.offset = this.element.offset(); //Initialize mouse events for interaction\n\n      this._mouseInit();\n\n      this._setHandleClassName(); //We're ready to go\n\n\n      this.ready = true;\n    },\n    _setOption: function _setOption(key, value) {\n      this._super(key, value);\n\n      if (key === \"handle\") {\n        this._setHandleClassName();\n      }\n    },\n    _setHandleClassName: function _setHandleClassName() {\n      this.element.find(\".ui-sortable-handle\").removeClass(\"ui-sortable-handle\");\n      $.each(this.items, function () {\n        (this.instance.options.handle ? this.item.find(this.instance.options.handle) : this.item).addClass(\"ui-sortable-handle\");\n      });\n    },\n    _destroy: function _destroy() {\n      this.element.removeClass(\"ui-sortable ui-sortable-disabled\").find(\".ui-sortable-handle\").removeClass(\"ui-sortable-handle\");\n\n      this._mouseDestroy();\n\n      for (var i = this.items.length - 1; i >= 0; i--) {\n        this.items[i].item.removeData(this.widgetName + \"-item\");\n      }\n\n      return this;\n    },\n    _mouseCapture: function _mouseCapture(event, overrideHandle) {\n      var currentItem = null,\n          validHandle = false,\n          that = this;\n\n      if (this.reverting) {\n        return false;\n      }\n\n      if (this.options.disabled || this.options.type === \"static\") {\n        return false;\n      } //We have to refresh the items data once first\n\n\n      this._refreshItems(event); //Find out if the clicked node (or one of its parents) is a actual item in this.items\n\n\n      $(event.target).parents().each(function () {\n        if ($.data(this, that.widgetName + \"-item\") === that) {\n          currentItem = $(this);\n          return false;\n        }\n      });\n\n      if ($.data(event.target, that.widgetName + \"-item\") === that) {\n        currentItem = $(event.target);\n      }\n\n      if (!currentItem) {\n        return false;\n      }\n\n      if (this.options.handle && !overrideHandle) {\n        $(this.options.handle, currentItem).find(\"*\").addBack().each(function () {\n          if (this === event.target) {\n            validHandle = true;\n          }\n        });\n\n        if (!validHandle) {\n          return false;\n        }\n      }\n\n      this.currentItem = currentItem;\n\n      this._removeCurrentsFromItems();\n\n      return true;\n    },\n    _mouseStart: function _mouseStart(event, overrideHandle, noActivation) {\n      var i,\n          body,\n          o = this.options;\n      this.currentContainer = this; //We only need to call refreshPositions, because the refreshItems call has been moved to mouseCapture\n\n      this.refreshPositions(); //Create and append the visible helper\n\n      this.helper = this._createHelper(event); //Cache the helper size\n\n      this._cacheHelperProportions();\n      /*\n       * - Position generation -\n       * This block generates everything position related - it's the core of draggables.\n       */\n      //Cache the margins of the original element\n\n\n      this._cacheMargins(); //Get the next scrolling parent\n\n\n      this.scrollParent = this.helper.scrollParent(); //The element's absolute position on the page minus margins\n\n      this.offset = this.currentItem.offset();\n      this.offset = {\n        top: this.offset.top - this.margins.top,\n        left: this.offset.left - this.margins.left\n      };\n      $.extend(this.offset, {\n        click: {\n          //Where the click happened, relative to the element\n          left: event.pageX - this.offset.left,\n          top: event.pageY - this.offset.top\n        },\n        parent: this._getParentOffset(),\n        relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper\n\n      }); // Only after we got the offset, we can change the helper's position to absolute\n      // TODO: Still need to figure out a way to make relative sorting possible\n\n      this.helper.css(\"position\", \"absolute\");\n      this.cssPosition = this.helper.css(\"position\"); //Generate the original position\n\n      this.originalPosition = this._generatePosition(event);\n      this.originalPageX = event.pageX;\n      this.originalPageY = event.pageY; //Adjust the mouse offset relative to the helper if \"cursorAt\" is supplied\n\n      o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt); //Cache the former DOM position\n\n      this.domPosition = {\n        prev: this.currentItem.prev()[0],\n        parent: this.currentItem.parent()[0]\n      }; //If the helper is not the original, hide the original so it's not playing any role during the drag, won't cause anything bad this way\n\n      if (this.helper[0] !== this.currentItem[0]) {\n        this.currentItem.hide();\n      } //Create the placeholder\n\n\n      this._createPlaceholder(); //Set a containment if given in the options\n\n\n      if (o.containment) {\n        this._setContainment();\n      }\n\n      if (o.cursor && o.cursor !== \"auto\") {\n        // cursor option\n        body = this.document.find(\"body\"); // support: IE\n\n        this.storedCursor = body.css(\"cursor\");\n        body.css(\"cursor\", o.cursor);\n        this.storedStylesheet = $(\"<style>*{ cursor: \" + o.cursor + \" !important; }</style>\").appendTo(body);\n      }\n\n      if (o.opacity) {\n        // opacity option\n        if (this.helper.css(\"opacity\")) {\n          this._storedOpacity = this.helper.css(\"opacity\");\n        }\n\n        this.helper.css(\"opacity\", o.opacity);\n      }\n\n      if (o.zIndex) {\n        // zIndex option\n        if (this.helper.css(\"zIndex\")) {\n          this._storedZIndex = this.helper.css(\"zIndex\");\n        }\n\n        this.helper.css(\"zIndex\", o.zIndex);\n      } //Prepare scrolling\n\n\n      if (this.scrollParent[0] !== this.document[0] && this.scrollParent[0].tagName !== \"HTML\") {\n        this.overflowOffset = this.scrollParent.offset();\n      } //Call callbacks\n\n\n      this._trigger(\"start\", event, this._uiHash()); //Recache the helper size\n\n\n      if (!this._preserveHelperProportions) {\n        this._cacheHelperProportions();\n      } //Post \"activate\" events to possible containers\n\n\n      if (!noActivation) {\n        for (i = this.containers.length - 1; i >= 0; i--) {\n          this.containers[i]._trigger(\"activate\", event, this._uiHash(this));\n        }\n      } //Prepare possible droppables\n\n\n      if ($.ui.ddmanager) {\n        $.ui.ddmanager.current = this;\n      }\n\n      if ($.ui.ddmanager && !o.dropBehaviour) {\n        $.ui.ddmanager.prepareOffsets(this, event);\n      }\n\n      this.dragging = true;\n      this.helper.addClass(\"ui-sortable-helper\");\n\n      this._mouseDrag(event); //Execute the drag once - this causes the helper not to be visible before getting its correct position\n\n\n      return true;\n    },\n    _mouseDrag: function _mouseDrag(event) {\n      var i,\n          item,\n          itemElement,\n          intersection,\n          o = this.options,\n          scrolled = false; //Compute the helpers position\n\n      this.position = this._generatePosition(event);\n      this.positionAbs = this._convertPositionTo(\"absolute\");\n\n      if (!this.lastPositionAbs) {\n        this.lastPositionAbs = this.positionAbs;\n      } //Do scrolling\n\n\n      if (this.options.scroll) {\n        if (this.scrollParent[0] !== this.document[0] && this.scrollParent[0].tagName !== \"HTML\") {\n          if (this.overflowOffset.top + this.scrollParent[0].offsetHeight - event.pageY < o.scrollSensitivity) {\n            this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed;\n          } else if (event.pageY - this.overflowOffset.top < o.scrollSensitivity) {\n            this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed;\n          }\n\n          if (this.overflowOffset.left + this.scrollParent[0].offsetWidth - event.pageX < o.scrollSensitivity) {\n            this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed;\n          } else if (event.pageX - this.overflowOffset.left < o.scrollSensitivity) {\n            this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed;\n          }\n        } else {\n          if (event.pageY - this.document.scrollTop() < o.scrollSensitivity) {\n            scrolled = this.document.scrollTop(this.document.scrollTop() - o.scrollSpeed);\n          } else if (this.window.height() - (event.pageY - this.document.scrollTop()) < o.scrollSensitivity) {\n            scrolled = this.document.scrollTop(this.document.scrollTop() + o.scrollSpeed);\n          }\n\n          if (event.pageX - this.document.scrollLeft() < o.scrollSensitivity) {\n            scrolled = this.document.scrollLeft(this.document.scrollLeft() - o.scrollSpeed);\n          } else if (this.window.width() - (event.pageX - this.document.scrollLeft()) < o.scrollSensitivity) {\n            scrolled = this.document.scrollLeft(this.document.scrollLeft() + o.scrollSpeed);\n          }\n        }\n\n        if (scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {\n          $.ui.ddmanager.prepareOffsets(this, event);\n        }\n      } //Regenerate the absolute position used for position checks\n\n\n      this.positionAbs = this._convertPositionTo(\"absolute\"); //Set the helper position\n\n      if (!this.options.axis || this.options.axis !== \"y\") {\n        this.helper[0].style.left = this.position.left + \"px\";\n      }\n\n      if (!this.options.axis || this.options.axis !== \"x\") {\n        this.helper[0].style.top = this.position.top + \"px\";\n      } //Rearrange\n\n\n      for (i = this.items.length - 1; i >= 0; i--) {\n        //Cache variables and intersection, continue if no intersection\n        item = this.items[i];\n        itemElement = item.item[0];\n        intersection = this._intersectsWithPointer(item);\n\n        if (!intersection) {\n          continue;\n        } // Only put the placeholder inside the current Container, skip all\n        // items from other containers. This works because when moving\n        // an item from one container to another the\n        // currentContainer is switched before the placeholder is moved.\n        //\n        // Without this, moving items in \"sub-sortables\" can cause\n        // the placeholder to jitter between the outer and inner container.\n\n\n        if (item.instance !== this.currentContainer) {\n          continue;\n        } // cannot intersect with itself\n        // no useless actions that have been done before\n        // no action if the item moved is the parent of the item checked\n\n\n        if (itemElement !== this.currentItem[0] && this.placeholder[intersection === 1 ? \"next\" : \"prev\"]()[0] !== itemElement && !$.contains(this.placeholder[0], itemElement) && (this.options.type === \"semi-dynamic\" ? !$.contains(this.element[0], itemElement) : true)) {\n          this.direction = intersection === 1 ? \"down\" : \"up\";\n\n          if (this.options.tolerance === \"pointer\" || this._intersectsWithSides(item)) {\n            this._rearrange(event, item);\n          } else {\n            break;\n          }\n\n          this._trigger(\"change\", event, this._uiHash());\n\n          break;\n        }\n      } //Post events to containers\n\n\n      this._contactContainers(event); //Interconnect with droppables\n\n\n      if ($.ui.ddmanager) {\n        $.ui.ddmanager.drag(this, event);\n      } //Call callbacks\n\n\n      this._trigger(\"sort\", event, this._uiHash());\n\n      this.lastPositionAbs = this.positionAbs;\n      return false;\n    },\n    _mouseStop: function _mouseStop(event, noPropagation) {\n      if (!event) {\n        return;\n      } //If we are using droppables, inform the manager about the drop\n\n\n      if ($.ui.ddmanager && !this.options.dropBehaviour) {\n        $.ui.ddmanager.drop(this, event);\n      }\n\n      if (this.options.revert) {\n        var that = this,\n            cur = this.placeholder.offset(),\n            axis = this.options.axis,\n            animation = {};\n\n        if (!axis || axis === \"x\") {\n          animation.left = cur.left - this.offset.parent.left - this.margins.left + (this.offsetParent[0] === this.document[0].body ? 0 : this.offsetParent[0].scrollLeft);\n        }\n\n        if (!axis || axis === \"y\") {\n          animation.top = cur.top - this.offset.parent.top - this.margins.top + (this.offsetParent[0] === this.document[0].body ? 0 : this.offsetParent[0].scrollTop);\n        }\n\n        this.reverting = true;\n        $(this.helper).animate(animation, parseInt(this.options.revert, 10) || 500, function () {\n          that._clear(event);\n        });\n      } else {\n        this._clear(event, noPropagation);\n      }\n\n      return false;\n    },\n    cancel: function cancel() {\n      if (this.dragging) {\n        this._mouseUp({\n          target: null\n        });\n\n        if (this.options.helper === \"original\") {\n          this.currentItem.css(this._storedCSS).removeClass(\"ui-sortable-helper\");\n        } else {\n          this.currentItem.show();\n        } //Post deactivating events to containers\n\n\n        for (var i = this.containers.length - 1; i >= 0; i--) {\n          this.containers[i]._trigger(\"deactivate\", null, this._uiHash(this));\n\n          if (this.containers[i].containerCache.over) {\n            this.containers[i]._trigger(\"out\", null, this._uiHash(this));\n\n            this.containers[i].containerCache.over = 0;\n          }\n        }\n      }\n\n      if (this.placeholder) {\n        //$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!\n        if (this.placeholder[0].parentNode) {\n          this.placeholder[0].parentNode.removeChild(this.placeholder[0]);\n        }\n\n        if (this.options.helper !== \"original\" && this.helper && this.helper[0].parentNode) {\n          this.helper.remove();\n        }\n\n        $.extend(this, {\n          helper: null,\n          dragging: false,\n          reverting: false,\n          _noFinalSort: null\n        });\n\n        if (this.domPosition.prev) {\n          $(this.domPosition.prev).after(this.currentItem);\n        } else {\n          $(this.domPosition.parent).prepend(this.currentItem);\n        }\n      }\n\n      return this;\n    },\n    serialize: function serialize(o) {\n      var items = this._getItemsAsjQuery(o && o.connected),\n          str = [];\n\n      o = o || {};\n      $(items).each(function () {\n        var res = ($(o.item || this).attr(o.attribute || \"id\") || \"\").match(o.expression || /(.+)[\\-=_](.+)/);\n\n        if (res) {\n          str.push((o.key || res[1] + \"[]\") + \"=\" + (o.key && o.expression ? res[1] : res[2]));\n        }\n      });\n\n      if (!str.length && o.key) {\n        str.push(o.key + \"=\");\n      }\n\n      return str.join(\"&\");\n    },\n    toArray: function toArray(o) {\n      var items = this._getItemsAsjQuery(o && o.connected),\n          ret = [];\n\n      o = o || {};\n      items.each(function () {\n        ret.push($(o.item || this).attr(o.attribute || \"id\") || \"\");\n      });\n      return ret;\n    },\n\n    /* Be careful with the following core functions */\n    _intersectsWith: function _intersectsWith(item) {\n      var x1 = this.positionAbs.left,\n          x2 = x1 + this.helperProportions.width,\n          y1 = this.positionAbs.top,\n          y2 = y1 + this.helperProportions.height,\n          l = item.left,\n          r = l + item.width,\n          t = item.top,\n          b = t + item.height,\n          dyClick = this.offset.click.top,\n          dxClick = this.offset.click.left,\n          isOverElementHeight = this.options.axis === \"x\" || y1 + dyClick > t && y1 + dyClick < b,\n          isOverElementWidth = this.options.axis === \"y\" || x1 + dxClick > l && x1 + dxClick < r,\n          isOverElement = isOverElementHeight && isOverElementWidth;\n\n      if (this.options.tolerance === \"pointer\" || this.options.forcePointerForContainers || this.options.tolerance !== \"pointer\" && this.helperProportions[this.floating ? \"width\" : \"height\"] > item[this.floating ? \"width\" : \"height\"]) {\n        return isOverElement;\n      } else {\n        return l < x1 + this.helperProportions.width / 2 && // Right Half\n        x2 - this.helperProportions.width / 2 < r && // Left Half\n        t < y1 + this.helperProportions.height / 2 && // Bottom Half\n        y2 - this.helperProportions.height / 2 < b; // Top Half\n      }\n    },\n    _intersectsWithPointer: function _intersectsWithPointer(item) {\n      var isOverElementHeight = this.options.axis === \"x\" || this._isOverAxis(this.positionAbs.top + this.offset.click.top, item.top, item.height),\n          isOverElementWidth = this.options.axis === \"y\" || this._isOverAxis(this.positionAbs.left + this.offset.click.left, item.left, item.width),\n          isOverElement = isOverElementHeight && isOverElementWidth,\n          verticalDirection = this._getDragVerticalDirection(),\n          horizontalDirection = this._getDragHorizontalDirection();\n\n      if (!isOverElement) {\n        return false;\n      }\n\n      return this.floating ? horizontalDirection && horizontalDirection === \"right\" || verticalDirection === \"down\" ? 2 : 1 : verticalDirection && (verticalDirection === \"down\" ? 2 : 1);\n    },\n    _intersectsWithSides: function _intersectsWithSides(item) {\n      var isOverBottomHalf = this._isOverAxis(this.positionAbs.top + this.offset.click.top, item.top + item.height / 2, item.height),\n          isOverRightHalf = this._isOverAxis(this.positionAbs.left + this.offset.click.left, item.left + item.width / 2, item.width),\n          verticalDirection = this._getDragVerticalDirection(),\n          horizontalDirection = this._getDragHorizontalDirection();\n\n      if (this.floating && horizontalDirection) {\n        return horizontalDirection === \"right\" && isOverRightHalf || horizontalDirection === \"left\" && !isOverRightHalf;\n      } else {\n        return verticalDirection && (verticalDirection === \"down\" && isOverBottomHalf || verticalDirection === \"up\" && !isOverBottomHalf);\n      }\n    },\n    _getDragVerticalDirection: function _getDragVerticalDirection() {\n      var delta = this.positionAbs.top - this.lastPositionAbs.top;\n      return delta !== 0 && (delta > 0 ? \"down\" : \"up\");\n    },\n    _getDragHorizontalDirection: function _getDragHorizontalDirection() {\n      var delta = this.positionAbs.left - this.lastPositionAbs.left;\n      return delta !== 0 && (delta > 0 ? \"right\" : \"left\");\n    },\n    refresh: function refresh(event) {\n      this._refreshItems(event);\n\n      this._setHandleClassName();\n\n      this.refreshPositions();\n      return this;\n    },\n    _connectWith: function _connectWith() {\n      var options = this.options;\n      return options.connectWith.constructor === String ? [options.connectWith] : options.connectWith;\n    },\n    _getItemsAsjQuery: function _getItemsAsjQuery(connected) {\n      var i,\n          j,\n          cur,\n          inst,\n          items = [],\n          queries = [],\n          connectWith = this._connectWith();\n\n      if (connectWith && connected) {\n        for (i = connectWith.length - 1; i >= 0; i--) {\n          cur = $(connectWith[i], this.document[0]);\n\n          for (j = cur.length - 1; j >= 0; j--) {\n            inst = $.data(cur[j], this.widgetFullName);\n\n            if (inst && inst !== this && !inst.options.disabled) {\n              queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element) : $(inst.options.items, inst.element).not(\".ui-sortable-helper\").not(\".ui-sortable-placeholder\"), inst]);\n            }\n          }\n        }\n      }\n\n      queries.push([$.isFunction(this.options.items) ? this.options.items.call(this.element, null, {\n        options: this.options,\n        item: this.currentItem\n      }) : $(this.options.items, this.element).not(\".ui-sortable-helper\").not(\".ui-sortable-placeholder\"), this]);\n\n      function addItems() {\n        items.push(this);\n      }\n\n      for (i = queries.length - 1; i >= 0; i--) {\n        queries[i][0].each(addItems);\n      }\n\n      return $(items);\n    },\n    _removeCurrentsFromItems: function _removeCurrentsFromItems() {\n      var list = this.currentItem.find(\":data(\" + this.widgetName + \"-item)\");\n      this.items = $.grep(this.items, function (item) {\n        for (var j = 0; j < list.length; j++) {\n          if (list[j] === item.item[0]) {\n            return false;\n          }\n        }\n\n        return true;\n      });\n    },\n    _refreshItems: function _refreshItems(event) {\n      this.items = [];\n      this.containers = [this];\n\n      var i,\n          j,\n          cur,\n          inst,\n          targetData,\n          _queries,\n          item,\n          queriesLength,\n          items = this.items,\n          queries = [[$.isFunction(this.options.items) ? this.options.items.call(this.element[0], event, {\n        item: this.currentItem\n      }) : $(this.options.items, this.element), this]],\n          connectWith = this._connectWith();\n\n      if (connectWith && this.ready) {\n        //Shouldn't be run the first time through due to massive slow-down\n        for (i = connectWith.length - 1; i >= 0; i--) {\n          cur = $(connectWith[i], this.document[0]);\n\n          for (j = cur.length - 1; j >= 0; j--) {\n            inst = $.data(cur[j], this.widgetFullName);\n\n            if (inst && inst !== this && !inst.options.disabled) {\n              queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element[0], event, {\n                item: this.currentItem\n              }) : $(inst.options.items, inst.element), inst]);\n              this.containers.push(inst);\n            }\n          }\n        }\n      }\n\n      for (i = queries.length - 1; i >= 0; i--) {\n        targetData = queries[i][1];\n        _queries = queries[i][0];\n\n        for (j = 0, queriesLength = _queries.length; j < queriesLength; j++) {\n          item = $(_queries[j]);\n          item.data(this.widgetName + \"-item\", targetData); // Data for target checking (mouse manager)\n\n          items.push({\n            item: item,\n            instance: targetData,\n            width: 0,\n            height: 0,\n            left: 0,\n            top: 0\n          });\n        }\n      }\n    },\n    refreshPositions: function refreshPositions(fast) {\n      // Determine whether items are being displayed horizontally\n      this.floating = this.items.length ? this.options.axis === \"x\" || this._isFloating(this.items[0].item) : false; //This has to be redone because due to the item being moved out/into the offsetParent, the offsetParent's position will change\n\n      if (this.offsetParent && this.helper) {\n        this.offset.parent = this._getParentOffset();\n      }\n\n      var i, item, t, p;\n\n      for (i = this.items.length - 1; i >= 0; i--) {\n        item = this.items[i]; //We ignore calculating positions of all connected containers when we're not over them\n\n        if (item.instance !== this.currentContainer && this.currentContainer && item.item[0] !== this.currentItem[0]) {\n          continue;\n        }\n\n        t = this.options.toleranceElement ? $(this.options.toleranceElement, item.item) : item.item;\n\n        if (!fast) {\n          item.width = t.outerWidth();\n          item.height = t.outerHeight();\n        }\n\n        p = t.offset();\n        item.left = p.left;\n        item.top = p.top;\n      }\n\n      if (this.options.custom && this.options.custom.refreshContainers) {\n        this.options.custom.refreshContainers.call(this);\n      } else {\n        for (i = this.containers.length - 1; i >= 0; i--) {\n          p = this.containers[i].element.offset();\n          this.containers[i].containerCache.left = p.left;\n          this.containers[i].containerCache.top = p.top;\n          this.containers[i].containerCache.width = this.containers[i].element.outerWidth();\n          this.containers[i].containerCache.height = this.containers[i].element.outerHeight();\n        }\n      }\n\n      return this;\n    },\n    _createPlaceholder: function _createPlaceholder(that) {\n      that = that || this;\n      var className,\n          o = that.options;\n\n      if (!o.placeholder || o.placeholder.constructor === String) {\n        className = o.placeholder;\n        o.placeholder = {\n          element: function element() {\n            var nodeName = that.currentItem[0].nodeName.toLowerCase(),\n                element = $(\"<\" + nodeName + \">\", that.document[0]).addClass(className || that.currentItem[0].className + \" ui-sortable-placeholder\").removeClass(\"ui-sortable-helper\");\n\n            if (nodeName === \"tbody\") {\n              that._createTrPlaceholder(that.currentItem.find(\"tr\").eq(0), $(\"<tr>\", that.document[0]).appendTo(element));\n            } else if (nodeName === \"tr\") {\n              that._createTrPlaceholder(that.currentItem, element);\n            } else if (nodeName === \"img\") {\n              element.attr(\"src\", that.currentItem.attr(\"src\"));\n            }\n\n            if (!className) {\n              element.css(\"visibility\", \"hidden\");\n            }\n\n            return element;\n          },\n          update: function update(container, p) {\n            // 1. If a className is set as 'placeholder option, we don't force sizes - the class is responsible for that\n            // 2. The option 'forcePlaceholderSize can be enabled to force it even if a class name is specified\n            if (className && !o.forcePlaceholderSize) {\n              return;\n            } //If the element doesn't have a actual height by itself (without styles coming from a stylesheet), it receives the inline height from the dragged item\n\n\n            if (!p.height()) {\n              p.height(that.currentItem.innerHeight() - parseInt(that.currentItem.css(\"paddingTop\") || 0, 10) - parseInt(that.currentItem.css(\"paddingBottom\") || 0, 10));\n            }\n\n            if (!p.width()) {\n              p.width(that.currentItem.innerWidth() - parseInt(that.currentItem.css(\"paddingLeft\") || 0, 10) - parseInt(that.currentItem.css(\"paddingRight\") || 0, 10));\n            }\n          }\n        };\n      } //Create the placeholder\n\n\n      that.placeholder = $(o.placeholder.element.call(that.element, that.currentItem)); //Append it after the actual current item\n\n      that.currentItem.after(that.placeholder); //Update the size of the placeholder (TODO: Logic to fuzzy, see line 316/317)\n\n      o.placeholder.update(that, that.placeholder);\n    },\n    _createTrPlaceholder: function _createTrPlaceholder(sourceTr, targetTr) {\n      var that = this;\n      sourceTr.children().each(function () {\n        $(\"<td>&#160;</td>\", that.document[0]).attr(\"colspan\", $(this).attr(\"colspan\") || 1).appendTo(targetTr);\n      });\n    },\n    _contactContainers: function _contactContainers(event) {\n      var i,\n          j,\n          dist,\n          itemWithLeastDistance,\n          posProperty,\n          sizeProperty,\n          cur,\n          nearBottom,\n          floating,\n          axis,\n          innermostContainer = null,\n          innermostIndex = null; // get innermost container that intersects with item\n\n      for (i = this.containers.length - 1; i >= 0; i--) {\n        // never consider a container that's located within the item itself\n        if ($.contains(this.currentItem[0], this.containers[i].element[0])) {\n          continue;\n        }\n\n        if (this._intersectsWith(this.containers[i].containerCache)) {\n          // if we've already found a container and it's more \"inner\" than this, then continue\n          if (innermostContainer && $.contains(this.containers[i].element[0], innermostContainer.element[0])) {\n            continue;\n          }\n\n          innermostContainer = this.containers[i];\n          innermostIndex = i;\n        } else {\n          // container doesn't intersect. trigger \"out\" event if necessary\n          if (this.containers[i].containerCache.over) {\n            this.containers[i]._trigger(\"out\", event, this._uiHash(this));\n\n            this.containers[i].containerCache.over = 0;\n          }\n        }\n      } // if no intersecting containers found, return\n\n\n      if (!innermostContainer) {\n        return;\n      } // move the item into the container if it's not there already\n\n\n      if (this.containers.length === 1) {\n        if (!this.containers[innermostIndex].containerCache.over) {\n          this.containers[innermostIndex]._trigger(\"over\", event, this._uiHash(this));\n\n          this.containers[innermostIndex].containerCache.over = 1;\n        }\n      } else {\n        //When entering a new container, we will find the item with the least distance and append our item near it\n        dist = 10000;\n        itemWithLeastDistance = null;\n        floating = innermostContainer.floating || this._isFloating(this.currentItem);\n        posProperty = floating ? \"left\" : \"top\";\n        sizeProperty = floating ? \"width\" : \"height\";\n        axis = floating ? \"clientX\" : \"clientY\";\n\n        for (j = this.items.length - 1; j >= 0; j--) {\n          if (!$.contains(this.containers[innermostIndex].element[0], this.items[j].item[0])) {\n            continue;\n          }\n\n          if (this.items[j].item[0] === this.currentItem[0]) {\n            continue;\n          }\n\n          cur = this.items[j].item.offset()[posProperty];\n          nearBottom = false;\n\n          if (event[axis] - cur > this.items[j][sizeProperty] / 2) {\n            nearBottom = true;\n          }\n\n          if (Math.abs(event[axis] - cur) < dist) {\n            dist = Math.abs(event[axis] - cur);\n            itemWithLeastDistance = this.items[j];\n            this.direction = nearBottom ? \"up\" : \"down\";\n          }\n        } //Check if dropOnEmpty is enabled\n\n\n        if (!itemWithLeastDistance && !this.options.dropOnEmpty) {\n          return;\n        }\n\n        if (this.currentContainer === this.containers[innermostIndex]) {\n          if (!this.currentContainer.containerCache.over) {\n            this.containers[innermostIndex]._trigger(\"over\", event, this._uiHash());\n\n            this.currentContainer.containerCache.over = 1;\n          }\n\n          return;\n        }\n\n        itemWithLeastDistance ? this._rearrange(event, itemWithLeastDistance, null, true) : this._rearrange(event, null, this.containers[innermostIndex].element, true);\n\n        this._trigger(\"change\", event, this._uiHash());\n\n        this.containers[innermostIndex]._trigger(\"change\", event, this._uiHash(this));\n\n        this.currentContainer = this.containers[innermostIndex]; //Update the placeholder\n\n        this.options.placeholder.update(this.currentContainer, this.placeholder);\n\n        this.containers[innermostIndex]._trigger(\"over\", event, this._uiHash(this));\n\n        this.containers[innermostIndex].containerCache.over = 1;\n      }\n    },\n    _createHelper: function _createHelper(event) {\n      var o = this.options,\n          helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event, this.currentItem])) : o.helper === \"clone\" ? this.currentItem.clone() : this.currentItem; //Add the helper to the DOM if that didn't happen already\n\n      if (!helper.parents(\"body\").length) {\n        $(o.appendTo !== \"parent\" ? o.appendTo : this.currentItem[0].parentNode)[0].appendChild(helper[0]);\n      }\n\n      if (helper[0] === this.currentItem[0]) {\n        this._storedCSS = {\n          width: this.currentItem[0].style.width,\n          height: this.currentItem[0].style.height,\n          position: this.currentItem.css(\"position\"),\n          top: this.currentItem.css(\"top\"),\n          left: this.currentItem.css(\"left\")\n        };\n      }\n\n      if (!helper[0].style.width || o.forceHelperSize) {\n        helper.width(this.currentItem.width());\n      }\n\n      if (!helper[0].style.height || o.forceHelperSize) {\n        helper.height(this.currentItem.height());\n      }\n\n      return helper;\n    },\n    _adjustOffsetFromHelper: function _adjustOffsetFromHelper(obj) {\n      if (typeof obj === \"string\") {\n        obj = obj.split(\" \");\n      }\n\n      if ($.isArray(obj)) {\n        obj = {\n          left: +obj[0],\n          top: +obj[1] || 0\n        };\n      }\n\n      if (\"left\" in obj) {\n        this.offset.click.left = obj.left + this.margins.left;\n      }\n\n      if (\"right\" in obj) {\n        this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;\n      }\n\n      if (\"top\" in obj) {\n        this.offset.click.top = obj.top + this.margins.top;\n      }\n\n      if (\"bottom\" in obj) {\n        this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;\n      }\n    },\n    _getParentOffset: function _getParentOffset() {\n      //Get the offsetParent and cache its position\n      this.offsetParent = this.helper.offsetParent();\n      var po = this.offsetParent.offset(); // This is a special case where we need to modify a offset calculated on start, since the following happened:\n      // 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent\n      // 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that\n      //    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag\n\n      if (this.cssPosition === \"absolute\" && this.scrollParent[0] !== this.document[0] && $.contains(this.scrollParent[0], this.offsetParent[0])) {\n        po.left += this.scrollParent.scrollLeft();\n        po.top += this.scrollParent.scrollTop();\n      } // This needs to be actually done for all browsers, since pageX/pageY includes this information\n      // with an ugly IE fix\n\n\n      if (this.offsetParent[0] === this.document[0].body || this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() === \"html\" && $.ui.ie) {\n        po = {\n          top: 0,\n          left: 0\n        };\n      }\n\n      return {\n        top: po.top + (parseInt(this.offsetParent.css(\"borderTopWidth\"), 10) || 0),\n        left: po.left + (parseInt(this.offsetParent.css(\"borderLeftWidth\"), 10) || 0)\n      };\n    },\n    _getRelativeOffset: function _getRelativeOffset() {\n      if (this.cssPosition === \"relative\") {\n        var p = this.currentItem.position();\n        return {\n          top: p.top - (parseInt(this.helper.css(\"top\"), 10) || 0) + this.scrollParent.scrollTop(),\n          left: p.left - (parseInt(this.helper.css(\"left\"), 10) || 0) + this.scrollParent.scrollLeft()\n        };\n      } else {\n        return {\n          top: 0,\n          left: 0\n        };\n      }\n    },\n    _cacheMargins: function _cacheMargins() {\n      this.margins = {\n        left: parseInt(this.currentItem.css(\"marginLeft\"), 10) || 0,\n        top: parseInt(this.currentItem.css(\"marginTop\"), 10) || 0\n      };\n    },\n    _cacheHelperProportions: function _cacheHelperProportions() {\n      this.helperProportions = {\n        width: this.helper.outerWidth(),\n        height: this.helper.outerHeight()\n      };\n    },\n    _setContainment: function _setContainment() {\n      var ce,\n          co,\n          over,\n          o = this.options;\n\n      if (o.containment === \"parent\") {\n        o.containment = this.helper[0].parentNode;\n      }\n\n      if (o.containment === \"document\" || o.containment === \"window\") {\n        this.containment = [0 - this.offset.relative.left - this.offset.parent.left, 0 - this.offset.relative.top - this.offset.parent.top, o.containment === \"document\" ? this.document.width() : this.window.width() - this.helperProportions.width - this.margins.left, (o.containment === \"document\" ? this.document.width() : this.window.height() || this.document[0].body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top];\n      }\n\n      if (!/^(document|window|parent)$/.test(o.containment)) {\n        ce = $(o.containment)[0];\n        co = $(o.containment).offset();\n        over = $(ce).css(\"overflow\") !== \"hidden\";\n        this.containment = [co.left + (parseInt($(ce).css(\"borderLeftWidth\"), 10) || 0) + (parseInt($(ce).css(\"paddingLeft\"), 10) || 0) - this.margins.left, co.top + (parseInt($(ce).css(\"borderTopWidth\"), 10) || 0) + (parseInt($(ce).css(\"paddingTop\"), 10) || 0) - this.margins.top, co.left + (over ? Math.max(ce.scrollWidth, ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css(\"borderLeftWidth\"), 10) || 0) - (parseInt($(ce).css(\"paddingRight\"), 10) || 0) - this.helperProportions.width - this.margins.left, co.top + (over ? Math.max(ce.scrollHeight, ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css(\"borderTopWidth\"), 10) || 0) - (parseInt($(ce).css(\"paddingBottom\"), 10) || 0) - this.helperProportions.height - this.margins.top];\n      }\n    },\n    _convertPositionTo: function _convertPositionTo(d, pos) {\n      if (!pos) {\n        pos = this.position;\n      }\n\n      var mod = d === \"absolute\" ? 1 : -1,\n          scroll = this.cssPosition === \"absolute\" && !(this.scrollParent[0] !== this.document[0] && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent,\n          scrollIsRootNode = /(html|body)/i.test(scroll[0].tagName);\n      return {\n        top: pos.top + // The absolute mouse position\n        this.offset.relative.top * mod + // Only for relative positioned nodes: Relative offset from element to offset parent\n        this.offset.parent.top * mod - // The offsetParent's offset without borders (offset + border)\n        (this.cssPosition === \"fixed\" ? -this.scrollParent.scrollTop() : scrollIsRootNode ? 0 : scroll.scrollTop()) * mod,\n        left: pos.left + // The absolute mouse position\n        this.offset.relative.left * mod + // Only for relative positioned nodes: Relative offset from element to offset parent\n        this.offset.parent.left * mod - // The offsetParent's offset without borders (offset + border)\n        (this.cssPosition === \"fixed\" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft()) * mod\n      };\n    },\n    _generatePosition: function _generatePosition(event) {\n      var top,\n          left,\n          o = this.options,\n          pageX = event.pageX,\n          pageY = event.pageY,\n          scroll = this.cssPosition === \"absolute\" && !(this.scrollParent[0] !== this.document[0] && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent,\n          scrollIsRootNode = /(html|body)/i.test(scroll[0].tagName); // This is another very weird special case that only happens for relative elements:\n      // 1. If the css position is relative\n      // 2. and the scroll parent is the document or similar to the offset parent\n      // we have to refresh the relative offset during the scroll so there are no jumps\n\n      if (this.cssPosition === \"relative\" && !(this.scrollParent[0] !== this.document[0] && this.scrollParent[0] !== this.offsetParent[0])) {\n        this.offset.relative = this._getRelativeOffset();\n      }\n      /*\n       * - Position constraining -\n       * Constrain the position to a mix of grid, containment.\n       */\n\n\n      if (this.originalPosition) {\n        //If we are not dragging yet, we won't check for options\n        if (this.containment) {\n          if (event.pageX - this.offset.click.left < this.containment[0]) {\n            pageX = this.containment[0] + this.offset.click.left;\n          }\n\n          if (event.pageY - this.offset.click.top < this.containment[1]) {\n            pageY = this.containment[1] + this.offset.click.top;\n          }\n\n          if (event.pageX - this.offset.click.left > this.containment[2]) {\n            pageX = this.containment[2] + this.offset.click.left;\n          }\n\n          if (event.pageY - this.offset.click.top > this.containment[3]) {\n            pageY = this.containment[3] + this.offset.click.top;\n          }\n        }\n\n        if (o.grid) {\n          top = this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1];\n          pageY = this.containment ? top - this.offset.click.top >= this.containment[1] && top - this.offset.click.top <= this.containment[3] ? top : top - this.offset.click.top >= this.containment[1] ? top - o.grid[1] : top + o.grid[1] : top;\n          left = this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0];\n          pageX = this.containment ? left - this.offset.click.left >= this.containment[0] && left - this.offset.click.left <= this.containment[2] ? left : left - this.offset.click.left >= this.containment[0] ? left - o.grid[0] : left + o.grid[0] : left;\n        }\n      }\n\n      return {\n        top: pageY - // The absolute mouse position\n        this.offset.click.top - // Click offset (relative to the element)\n        this.offset.relative.top - // Only for relative positioned nodes: Relative offset from element to offset parent\n        this.offset.parent.top + ( // The offsetParent's offset without borders (offset + border)\n        this.cssPosition === \"fixed\" ? -this.scrollParent.scrollTop() : scrollIsRootNode ? 0 : scroll.scrollTop()),\n        left: pageX - // The absolute mouse position\n        this.offset.click.left - // Click offset (relative to the element)\n        this.offset.relative.left - // Only for relative positioned nodes: Relative offset from element to offset parent\n        this.offset.parent.left + ( // The offsetParent's offset without borders (offset + border)\n        this.cssPosition === \"fixed\" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft())\n      };\n    },\n    _rearrange: function _rearrange(event, i, a, hardRefresh) {\n      a ? a[0].appendChild(this.placeholder[0]) : i.item[0].parentNode.insertBefore(this.placeholder[0], this.direction === \"down\" ? i.item[0] : i.item[0].nextSibling); //Various things done here to improve the performance:\n      // 1. we create a setTimeout, that calls refreshPositions\n      // 2. on the instance, we have a counter variable, that get's higher after every append\n      // 3. on the local scope, we copy the counter variable, and check in the timeout, if it's still the same\n      // 4. this lets only the last addition to the timeout stack through\n\n      this.counter = this.counter ? ++this.counter : 1;\n      var counter = this.counter;\n\n      this._delay(function () {\n        if (counter === this.counter) {\n          this.refreshPositions(!hardRefresh); //Precompute after each DOM insertion, NOT on mousemove\n        }\n      });\n    },\n    _clear: function _clear(event, noPropagation) {\n      this.reverting = false; // We delay all events that have to be triggered to after the point where the placeholder has been removed and\n      // everything else normalized again\n\n      var i,\n          delayedTriggers = []; // We first have to update the dom position of the actual currentItem\n      // Note: don't do it if the current item is already removed (by a user), or it gets reappended (see #4088)\n\n      if (!this._noFinalSort && this.currentItem.parent().length) {\n        this.placeholder.before(this.currentItem);\n      }\n\n      this._noFinalSort = null;\n\n      if (this.helper[0] === this.currentItem[0]) {\n        for (i in this._storedCSS) {\n          if (this._storedCSS[i] === \"auto\" || this._storedCSS[i] === \"static\") {\n            this._storedCSS[i] = \"\";\n          }\n        }\n\n        this.currentItem.css(this._storedCSS).removeClass(\"ui-sortable-helper\");\n      } else {\n        this.currentItem.show();\n      }\n\n      if (this.fromOutside && !noPropagation) {\n        delayedTriggers.push(function (event) {\n          this._trigger(\"receive\", event, this._uiHash(this.fromOutside));\n        });\n      }\n\n      if ((this.fromOutside || this.domPosition.prev !== this.currentItem.prev().not(\".ui-sortable-helper\")[0] || this.domPosition.parent !== this.currentItem.parent()[0]) && !noPropagation) {\n        delayedTriggers.push(function (event) {\n          this._trigger(\"update\", event, this._uiHash());\n        }); //Trigger update callback if the DOM position has changed\n      } // Check if the items Container has Changed and trigger appropriate\n      // events.\n\n\n      if (this !== this.currentContainer) {\n        if (!noPropagation) {\n          delayedTriggers.push(function (event) {\n            this._trigger(\"remove\", event, this._uiHash());\n          });\n          delayedTriggers.push(function (c) {\n            return function (event) {\n              c._trigger(\"receive\", event, this._uiHash(this));\n            };\n          }.call(this, this.currentContainer));\n          delayedTriggers.push(function (c) {\n            return function (event) {\n              c._trigger(\"update\", event, this._uiHash(this));\n            };\n          }.call(this, this.currentContainer));\n        }\n      } //Post events to containers\n\n\n      function delayEvent(type, instance, container) {\n        return function (event) {\n          container._trigger(type, event, instance._uiHash(instance));\n        };\n      }\n\n      for (i = this.containers.length - 1; i >= 0; i--) {\n        if (!noPropagation) {\n          delayedTriggers.push(delayEvent(\"deactivate\", this, this.containers[i]));\n        }\n\n        if (this.containers[i].containerCache.over) {\n          delayedTriggers.push(delayEvent(\"out\", this, this.containers[i]));\n          this.containers[i].containerCache.over = 0;\n        }\n      } //Do what was originally in plugins\n\n\n      if (this.storedCursor) {\n        this.document.find(\"body\").css(\"cursor\", this.storedCursor);\n        this.storedStylesheet.remove();\n      }\n\n      if (this._storedOpacity) {\n        this.helper.css(\"opacity\", this._storedOpacity);\n      }\n\n      if (this._storedZIndex) {\n        this.helper.css(\"zIndex\", this._storedZIndex === \"auto\" ? \"\" : this._storedZIndex);\n      }\n\n      this.dragging = false;\n\n      if (!noPropagation) {\n        this._trigger(\"beforeStop\", event, this._uiHash());\n      } //$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!\n\n\n      this.placeholder[0].parentNode.removeChild(this.placeholder[0]);\n\n      if (!this.cancelHelperRemoval) {\n        if (this.helper[0] !== this.currentItem[0]) {\n          this.helper.remove();\n        }\n\n        this.helper = null;\n      }\n\n      if (!noPropagation) {\n        for (i = 0; i < delayedTriggers.length; i++) {\n          delayedTriggers[i].call(this, event);\n        } //Trigger all delayed events\n\n\n        this._trigger(\"stop\", event, this._uiHash());\n      }\n\n      this.fromOutside = false;\n      return !this.cancelHelperRemoval;\n    },\n    _trigger: function _trigger() {\n      if ($.Widget.prototype._trigger.apply(this, arguments) === false) {\n        this.cancel();\n      }\n    },\n    _uiHash: function _uiHash(_inst) {\n      var inst = _inst || this;\n      return {\n        helper: inst.helper,\n        placeholder: inst.placeholder || $([]),\n        position: inst.position,\n        originalPosition: inst.originalPosition,\n        offset: inst.positionAbs,\n        item: inst.currentItem,\n        sender: _inst ? _inst.element : null\n      };\n    }\n  });\n  /*!\n   * jQuery UI Spinner 1.11.4\n   * http://jqueryui.com\n   *\n   * Copyright jQuery Foundation and other contributors\n   * Released under the MIT license.\n   * http://jquery.org/license\n   *\n   * http://api.jqueryui.com/spinner/\n   */\n\n  function spinner_modifier(fn) {\n    return function () {\n      var previous = this.element.val();\n      fn.apply(this, arguments);\n\n      this._refresh();\n\n      if (previous !== this.element.val()) {\n        this._trigger(\"change\");\n      }\n    };\n  }\n\n  var spinner = $.widget(\"ui.spinner\", {\n    version: \"1.11.4\",\n    defaultElement: \"<input>\",\n    widgetEventPrefix: \"spin\",\n    options: {\n      culture: null,\n      icons: {\n        down: \"ui-icon-triangle-1-s\",\n        up: \"ui-icon-triangle-1-n\"\n      },\n      incremental: true,\n      max: null,\n      min: null,\n      numberFormat: null,\n      page: 10,\n      step: 1,\n      change: null,\n      spin: null,\n      start: null,\n      stop: null\n    },\n    _create: function _create() {\n      // handle string values that need to be parsed\n      this._setOption(\"max\", this.options.max);\n\n      this._setOption(\"min\", this.options.min);\n\n      this._setOption(\"step\", this.options.step); // Only format if there is a value, prevents the field from being marked\n      // as invalid in Firefox, see #9573.\n\n\n      if (this.value() !== \"\") {\n        // Format the value, but don't constrain.\n        this._value(this.element.val(), true);\n      }\n\n      this._draw();\n\n      this._on(this._events);\n\n      this._refresh(); // turning off autocomplete prevents the browser from remembering the\n      // value when navigating through history, so we re-enable autocomplete\n      // if the page is unloaded before the widget is destroyed. #7790\n\n\n      this._on(this.window, {\n        beforeunload: function beforeunload() {\n          this.element.removeAttr(\"autocomplete\");\n        }\n      });\n    },\n    _getCreateOptions: function _getCreateOptions() {\n      var options = {},\n          element = this.element;\n      $.each([\"min\", \"max\", \"step\"], function (i, option) {\n        var value = element.attr(option);\n\n        if (value !== undefined && value.length) {\n          options[option] = value;\n        }\n      });\n      return options;\n    },\n    _events: {\n      keydown: function keydown(event) {\n        if (this._start(event) && this._keydown(event)) {\n          event.preventDefault();\n        }\n      },\n      keyup: \"_stop\",\n      focus: function focus() {\n        this.previous = this.element.val();\n      },\n      blur: function blur(event) {\n        if (this.cancelBlur) {\n          delete this.cancelBlur;\n          return;\n        }\n\n        this._stop();\n\n        this._refresh();\n\n        if (this.previous !== this.element.val()) {\n          this._trigger(\"change\", event);\n        }\n      },\n      mousewheel: function mousewheel(event, delta) {\n        if (!delta) {\n          return;\n        }\n\n        if (!this.spinning && !this._start(event)) {\n          return false;\n        }\n\n        this._spin((delta > 0 ? 1 : -1) * this.options.step, event);\n\n        clearTimeout(this.mousewheelTimer);\n        this.mousewheelTimer = this._delay(function () {\n          if (this.spinning) {\n            this._stop(event);\n          }\n        }, 100);\n        event.preventDefault();\n      },\n      \"mousedown .ui-spinner-button\": function mousedownUiSpinnerButton(event) {\n        var previous; // We never want the buttons to have focus; whenever the user is\n        // interacting with the spinner, the focus should be on the input.\n        // If the input is focused then this.previous is properly set from\n        // when the input first received focus. If the input is not focused\n        // then we need to set this.previous based on the value before spinning.\n\n        previous = this.element[0] === this.document[0].activeElement ? this.previous : this.element.val();\n\n        function checkFocus() {\n          var isActive = this.element[0] === this.document[0].activeElement;\n\n          if (!isActive) {\n            this.element.focus();\n            this.previous = previous; // support: IE\n            // IE sets focus asynchronously, so we need to check if focus\n            // moved off of the input because the user clicked on the button.\n\n            this._delay(function () {\n              this.previous = previous;\n            });\n          }\n        } // ensure focus is on (or stays on) the text field\n\n\n        event.preventDefault();\n        checkFocus.call(this); // support: IE\n        // IE doesn't prevent moving focus even with event.preventDefault()\n        // so we set a flag to know when we should ignore the blur event\n        // and check (again) if focus moved off of the input.\n\n        this.cancelBlur = true;\n\n        this._delay(function () {\n          delete this.cancelBlur;\n          checkFocus.call(this);\n        });\n\n        if (this._start(event) === false) {\n          return;\n        }\n\n        this._repeat(null, $(event.currentTarget).hasClass(\"ui-spinner-up\") ? 1 : -1, event);\n      },\n      \"mouseup .ui-spinner-button\": \"_stop\",\n      \"mouseenter .ui-spinner-button\": function mouseenterUiSpinnerButton(event) {\n        // button will add ui-state-active if mouse was down while mouseleave and kept down\n        if (!$(event.currentTarget).hasClass(\"ui-state-active\")) {\n          return;\n        }\n\n        if (this._start(event) === false) {\n          return false;\n        }\n\n        this._repeat(null, $(event.currentTarget).hasClass(\"ui-spinner-up\") ? 1 : -1, event);\n      },\n      // TODO: do we really want to consider this a stop?\n      // shouldn't we just stop the repeater and wait until mouseup before\n      // we trigger the stop event?\n      \"mouseleave .ui-spinner-button\": \"_stop\"\n    },\n    _draw: function _draw() {\n      var uiSpinner = this.uiSpinner = this.element.addClass(\"ui-spinner-input\").attr(\"autocomplete\", \"off\").wrap(this._uiSpinnerHtml()).parent() // add buttons\n      .append(this._buttonHtml());\n      this.element.attr(\"role\", \"spinbutton\"); // button bindings\n\n      this.buttons = uiSpinner.find(\".ui-spinner-button\").attr(\"tabIndex\", -1).button().removeClass(\"ui-corner-all\"); // IE 6 doesn't understand height: 50% for the buttons\n      // unless the wrapper has an explicit height\n\n      if (this.buttons.height() > Math.ceil(uiSpinner.height() * 0.5) && uiSpinner.height() > 0) {\n        uiSpinner.height(uiSpinner.height());\n      } // disable spinner if element was already disabled\n\n\n      if (this.options.disabled) {\n        this.disable();\n      }\n    },\n    _keydown: function _keydown(event) {\n      var options = this.options,\n          keyCode = $.ui.keyCode;\n\n      switch (event.keyCode) {\n        case keyCode.UP:\n          this._repeat(null, 1, event);\n\n          return true;\n\n        case keyCode.DOWN:\n          this._repeat(null, -1, event);\n\n          return true;\n\n        case keyCode.PAGE_UP:\n          this._repeat(null, options.page, event);\n\n          return true;\n\n        case keyCode.PAGE_DOWN:\n          this._repeat(null, -options.page, event);\n\n          return true;\n      }\n\n      return false;\n    },\n    _uiSpinnerHtml: function _uiSpinnerHtml() {\n      return \"<span class='ui-spinner ui-widget ui-widget-content ui-corner-all'></span>\";\n    },\n    _buttonHtml: function _buttonHtml() {\n      return \"\" + \"<a class='ui-spinner-button ui-spinner-up ui-corner-tr'>\" + \"<span class='ui-icon \" + this.options.icons.up + \"'>&#9650;</span>\" + \"</a>\" + \"<a class='ui-spinner-button ui-spinner-down ui-corner-br'>\" + \"<span class='ui-icon \" + this.options.icons.down + \"'>&#9660;</span>\" + \"</a>\";\n    },\n    _start: function _start(event) {\n      if (!this.spinning && this._trigger(\"start\", event) === false) {\n        return false;\n      }\n\n      if (!this.counter) {\n        this.counter = 1;\n      }\n\n      this.spinning = true;\n      return true;\n    },\n    _repeat: function _repeat(i, steps, event) {\n      i = i || 500;\n      clearTimeout(this.timer);\n      this.timer = this._delay(function () {\n        this._repeat(40, steps, event);\n      }, i);\n\n      this._spin(steps * this.options.step, event);\n    },\n    _spin: function _spin(step, event) {\n      var value = this.value() || 0;\n\n      if (!this.counter) {\n        this.counter = 1;\n      }\n\n      value = this._adjustValue(value + step * this._increment(this.counter));\n\n      if (!this.spinning || this._trigger(\"spin\", event, {\n        value: value\n      }) !== false) {\n        this._value(value);\n\n        this.counter++;\n      }\n    },\n    _increment: function _increment(i) {\n      var incremental = this.options.incremental;\n\n      if (incremental) {\n        return $.isFunction(incremental) ? incremental(i) : Math.floor(i * i * i / 50000 - i * i / 500 + 17 * i / 200 + 1);\n      }\n\n      return 1;\n    },\n    _precision: function _precision() {\n      var precision = this._precisionOf(this.options.step);\n\n      if (this.options.min !== null) {\n        precision = Math.max(precision, this._precisionOf(this.options.min));\n      }\n\n      return precision;\n    },\n    _precisionOf: function _precisionOf(num) {\n      var str = num.toString(),\n          decimal = str.indexOf(\".\");\n      return decimal === -1 ? 0 : str.length - decimal - 1;\n    },\n    _adjustValue: function _adjustValue(value) {\n      var base,\n          aboveMin,\n          options = this.options; // make sure we're at a valid step\n      // - find out where we are relative to the base (min or 0)\n\n      base = options.min !== null ? options.min : 0;\n      aboveMin = value - base; // - round to the nearest step\n\n      aboveMin = Math.round(aboveMin / options.step) * options.step; // - rounding is based on 0, so adjust back to our base\n\n      value = base + aboveMin; // fix precision from bad JS floating point math\n\n      value = parseFloat(value.toFixed(this._precision())); // clamp the value\n\n      if (options.max !== null && value > options.max) {\n        return options.max;\n      }\n\n      if (options.min !== null && value < options.min) {\n        return options.min;\n      }\n\n      return value;\n    },\n    _stop: function _stop(event) {\n      if (!this.spinning) {\n        return;\n      }\n\n      clearTimeout(this.timer);\n      clearTimeout(this.mousewheelTimer);\n      this.counter = 0;\n      this.spinning = false;\n\n      this._trigger(\"stop\", event);\n    },\n    _setOption: function _setOption(key, value) {\n      if (key === \"culture\" || key === \"numberFormat\") {\n        var prevValue = this._parse(this.element.val());\n\n        this.options[key] = value;\n        this.element.val(this._format(prevValue));\n        return;\n      }\n\n      if (key === \"max\" || key === \"min\" || key === \"step\") {\n        if (typeof value === \"string\") {\n          value = this._parse(value);\n        }\n      }\n\n      if (key === \"icons\") {\n        this.buttons.first().find(\".ui-icon\").removeClass(this.options.icons.up).addClass(value.up);\n        this.buttons.last().find(\".ui-icon\").removeClass(this.options.icons.down).addClass(value.down);\n      }\n\n      this._super(key, value);\n\n      if (key === \"disabled\") {\n        this.widget().toggleClass(\"ui-state-disabled\", !!value);\n        this.element.prop(\"disabled\", !!value);\n        this.buttons.button(value ? \"disable\" : \"enable\");\n      }\n    },\n    _setOptions: spinner_modifier(function (options) {\n      this._super(options);\n    }),\n    _parse: function _parse(val) {\n      if (typeof val === \"string\" && val !== \"\") {\n        val = window.Globalize && this.options.numberFormat ? Globalize.parseFloat(val, 10, this.options.culture) : +val;\n      }\n\n      return val === \"\" || isNaN(val) ? null : val;\n    },\n    _format: function _format(value) {\n      if (value === \"\") {\n        return \"\";\n      }\n\n      return window.Globalize && this.options.numberFormat ? Globalize.format(value, this.options.numberFormat, this.options.culture) : value;\n    },\n    _refresh: function _refresh() {\n      this.element.attr({\n        \"aria-valuemin\": this.options.min,\n        \"aria-valuemax\": this.options.max,\n        // TODO: what should we do with values that can't be parsed?\n        \"aria-valuenow\": this._parse(this.element.val())\n      });\n    },\n    isValid: function isValid() {\n      var value = this.value(); // null is invalid\n\n      if (value === null) {\n        return false;\n      } // if value gets adjusted, it's invalid\n\n\n      return value === this._adjustValue(value);\n    },\n    // update the value without triggering change\n    _value: function _value(value, allowAny) {\n      var parsed;\n\n      if (value !== \"\") {\n        parsed = this._parse(value);\n\n        if (parsed !== null) {\n          if (!allowAny) {\n            parsed = this._adjustValue(parsed);\n          }\n\n          value = this._format(parsed);\n        }\n      }\n\n      this.element.val(value);\n\n      this._refresh();\n    },\n    _destroy: function _destroy() {\n      this.element.removeClass(\"ui-spinner-input\").prop(\"disabled\", false).removeAttr(\"autocomplete\").removeAttr(\"role\").removeAttr(\"aria-valuemin\").removeAttr(\"aria-valuemax\").removeAttr(\"aria-valuenow\");\n      this.uiSpinner.replaceWith(this.element);\n    },\n    stepUp: spinner_modifier(function (steps) {\n      this._stepUp(steps);\n    }),\n    _stepUp: function _stepUp(steps) {\n      if (this._start()) {\n        this._spin((steps || 1) * this.options.step);\n\n        this._stop();\n      }\n    },\n    stepDown: spinner_modifier(function (steps) {\n      this._stepDown(steps);\n    }),\n    _stepDown: function _stepDown(steps) {\n      if (this._start()) {\n        this._spin((steps || 1) * -this.options.step);\n\n        this._stop();\n      }\n    },\n    pageUp: spinner_modifier(function (pages) {\n      this._stepUp((pages || 1) * this.options.page);\n    }),\n    pageDown: spinner_modifier(function (pages) {\n      this._stepDown((pages || 1) * this.options.page);\n    }),\n    value: function value(newVal) {\n      if (!arguments.length) {\n        return this._parse(this.element.val());\n      }\n\n      spinner_modifier(this._value).call(this, newVal);\n    },\n    widget: function widget() {\n      return this.uiSpinner;\n    }\n  });\n  /*!\n   * jQuery UI Tabs 1.11.4\n   * http://jqueryui.com\n   *\n   * Copyright jQuery Foundation and other contributors\n   * Released under the MIT license.\n   * http://jquery.org/license\n   *\n   * http://api.jqueryui.com/tabs/\n   */\n\n  var tabs = $.widget(\"ui.tabs\", {\n    version: \"1.11.4\",\n    delay: 300,\n    options: {\n      active: null,\n      collapsible: false,\n      event: \"click\",\n      heightStyle: \"content\",\n      hide: null,\n      show: null,\n      // callbacks\n      activate: null,\n      beforeActivate: null,\n      beforeLoad: null,\n      load: null\n    },\n    _isLocal: function () {\n      var rhash = /#.*$/;\n      return function (anchor) {\n        var anchorUrl, locationUrl; // support: IE7\n        // IE7 doesn't normalize the href property when set via script (#9317)\n\n        anchor = anchor.cloneNode(false);\n        anchorUrl = anchor.href.replace(rhash, \"\");\n        locationUrl = location.href.replace(rhash, \"\"); // decoding may throw an error if the URL isn't UTF-8 (#9518)\n\n        try {\n          anchorUrl = decodeURIComponent(anchorUrl);\n        } catch (error) {}\n\n        try {\n          locationUrl = decodeURIComponent(locationUrl);\n        } catch (error) {}\n\n        return anchor.hash.length > 1 && anchorUrl === locationUrl;\n      };\n    }(),\n    _create: function _create() {\n      var that = this,\n          options = this.options;\n      this.running = false;\n      this.element.addClass(\"ui-tabs ui-widget ui-widget-content ui-corner-all\").toggleClass(\"ui-tabs-collapsible\", options.collapsible);\n\n      this._processTabs();\n\n      options.active = this._initialActive(); // Take disabling tabs via class attribute from HTML\n      // into account and update option properly.\n\n      if ($.isArray(options.disabled)) {\n        options.disabled = $.unique(options.disabled.concat($.map(this.tabs.filter(\".ui-state-disabled\"), function (li) {\n          return that.tabs.index(li);\n        }))).sort();\n      } // check for length avoids error when initializing empty list\n\n\n      if (this.options.active !== false && this.anchors.length) {\n        this.active = this._findActive(options.active);\n      } else {\n        this.active = $();\n      }\n\n      this._refresh();\n\n      if (this.active.length) {\n        this.load(options.active);\n      }\n    },\n    _initialActive: function _initialActive() {\n      var active = this.options.active,\n          collapsible = this.options.collapsible,\n          locationHash = location.hash.substring(1);\n\n      if (active === null) {\n        // check the fragment identifier in the URL\n        if (locationHash) {\n          this.tabs.each(function (i, tab) {\n            if ($(tab).attr(\"aria-controls\") === locationHash) {\n              active = i;\n              return false;\n            }\n          });\n        } // check for a tab marked active via a class\n\n\n        if (active === null) {\n          active = this.tabs.index(this.tabs.filter(\".ui-tabs-active\"));\n        } // no active tab, set to false\n\n\n        if (active === null || active === -1) {\n          active = this.tabs.length ? 0 : false;\n        }\n      } // handle numbers: negative, out of range\n\n\n      if (active !== false) {\n        active = this.tabs.index(this.tabs.eq(active));\n\n        if (active === -1) {\n          active = collapsible ? false : 0;\n        }\n      } // don't allow collapsible: false and active: false\n\n\n      if (!collapsible && active === false && this.anchors.length) {\n        active = 0;\n      }\n\n      return active;\n    },\n    _getCreateEventData: function _getCreateEventData() {\n      return {\n        tab: this.active,\n        panel: !this.active.length ? $() : this._getPanelForTab(this.active)\n      };\n    },\n    _tabKeydown: function _tabKeydown(event) {\n      var focusedTab = $(this.document[0].activeElement).closest(\"li\"),\n          selectedIndex = this.tabs.index(focusedTab),\n          goingForward = true;\n\n      if (this._handlePageNav(event)) {\n        return;\n      }\n\n      switch (event.keyCode) {\n        case $.ui.keyCode.RIGHT:\n        case $.ui.keyCode.DOWN:\n          selectedIndex++;\n          break;\n\n        case $.ui.keyCode.UP:\n        case $.ui.keyCode.LEFT:\n          goingForward = false;\n          selectedIndex--;\n          break;\n\n        case $.ui.keyCode.END:\n          selectedIndex = this.anchors.length - 1;\n          break;\n\n        case $.ui.keyCode.HOME:\n          selectedIndex = 0;\n          break;\n\n        case $.ui.keyCode.SPACE:\n          // Activate only, no collapsing\n          event.preventDefault();\n          clearTimeout(this.activating);\n\n          this._activate(selectedIndex);\n\n          return;\n\n        case $.ui.keyCode.ENTER:\n          // Toggle (cancel delayed activation, allow collapsing)\n          event.preventDefault();\n          clearTimeout(this.activating); // Determine if we should collapse or activate\n\n          this._activate(selectedIndex === this.options.active ? false : selectedIndex);\n\n          return;\n\n        default:\n          return;\n      } // Focus the appropriate tab, based on which key was pressed\n\n\n      event.preventDefault();\n      clearTimeout(this.activating);\n      selectedIndex = this._focusNextTab(selectedIndex, goingForward); // Navigating with control/command key will prevent automatic activation\n\n      if (!event.ctrlKey && !event.metaKey) {\n        // Update aria-selected immediately so that AT think the tab is already selected.\n        // Otherwise AT may confuse the user by stating that they need to activate the tab,\n        // but the tab will already be activated by the time the announcement finishes.\n        focusedTab.attr(\"aria-selected\", \"false\");\n        this.tabs.eq(selectedIndex).attr(\"aria-selected\", \"true\");\n        this.activating = this._delay(function () {\n          this.option(\"active\", selectedIndex);\n        }, this.delay);\n      }\n    },\n    _panelKeydown: function _panelKeydown(event) {\n      if (this._handlePageNav(event)) {\n        return;\n      } // Ctrl+up moves focus to the current tab\n\n\n      if (event.ctrlKey && event.keyCode === $.ui.keyCode.UP) {\n        event.preventDefault();\n        this.active.focus();\n      }\n    },\n    // Alt+page up/down moves focus to the previous/next tab (and activates)\n    _handlePageNav: function _handlePageNav(event) {\n      if (event.altKey && event.keyCode === $.ui.keyCode.PAGE_UP) {\n        this._activate(this._focusNextTab(this.options.active - 1, false));\n\n        return true;\n      }\n\n      if (event.altKey && event.keyCode === $.ui.keyCode.PAGE_DOWN) {\n        this._activate(this._focusNextTab(this.options.active + 1, true));\n\n        return true;\n      }\n    },\n    _findNextTab: function _findNextTab(index, goingForward) {\n      var lastTabIndex = this.tabs.length - 1;\n\n      function constrain() {\n        if (index > lastTabIndex) {\n          index = 0;\n        }\n\n        if (index < 0) {\n          index = lastTabIndex;\n        }\n\n        return index;\n      }\n\n      while ($.inArray(constrain(), this.options.disabled) !== -1) {\n        index = goingForward ? index + 1 : index - 1;\n      }\n\n      return index;\n    },\n    _focusNextTab: function _focusNextTab(index, goingForward) {\n      index = this._findNextTab(index, goingForward);\n      this.tabs.eq(index).focus();\n      return index;\n    },\n    _setOption: function _setOption(key, value) {\n      if (key === \"active\") {\n        // _activate() will handle invalid values and update this.options\n        this._activate(value);\n\n        return;\n      }\n\n      if (key === \"disabled\") {\n        // don't use the widget factory's disabled handling\n        this._setupDisabled(value);\n\n        return;\n      }\n\n      this._super(key, value);\n\n      if (key === \"collapsible\") {\n        this.element.toggleClass(\"ui-tabs-collapsible\", value); // Setting collapsible: false while collapsed; open first panel\n\n        if (!value && this.options.active === false) {\n          this._activate(0);\n        }\n      }\n\n      if (key === \"event\") {\n        this._setupEvents(value);\n      }\n\n      if (key === \"heightStyle\") {\n        this._setupHeightStyle(value);\n      }\n    },\n    _sanitizeSelector: function _sanitizeSelector(hash) {\n      return hash ? hash.replace(/[!\"$%&'()*+,.\\/:;<=>?@\\[\\]\\^`{|}~]/g, \"\\\\$&\") : \"\";\n    },\n    refresh: function refresh() {\n      var options = this.options,\n          lis = this.tablist.children(\":has(a[href])\"); // get disabled tabs from class attribute from HTML\n      // this will get converted to a boolean if needed in _refresh()\n\n      options.disabled = $.map(lis.filter(\".ui-state-disabled\"), function (tab) {\n        return lis.index(tab);\n      });\n\n      this._processTabs(); // was collapsed or no tabs\n\n\n      if (options.active === false || !this.anchors.length) {\n        options.active = false;\n        this.active = $(); // was active, but active tab is gone\n      } else if (this.active.length && !$.contains(this.tablist[0], this.active[0])) {\n        // all remaining tabs are disabled\n        if (this.tabs.length === options.disabled.length) {\n          options.active = false;\n          this.active = $(); // activate previous tab\n        } else {\n          this._activate(this._findNextTab(Math.max(0, options.active - 1), false));\n        } // was active, active tab still exists\n\n      } else {\n        // make sure active index is correct\n        options.active = this.tabs.index(this.active);\n      }\n\n      this._refresh();\n    },\n    _refresh: function _refresh() {\n      this._setupDisabled(this.options.disabled);\n\n      this._setupEvents(this.options.event);\n\n      this._setupHeightStyle(this.options.heightStyle);\n\n      this.tabs.not(this.active).attr({\n        \"aria-selected\": \"false\",\n        \"aria-expanded\": \"false\",\n        tabIndex: -1\n      });\n      this.panels.not(this._getPanelForTab(this.active)).hide().attr({\n        \"aria-hidden\": \"true\"\n      }); // Make sure one tab is in the tab order\n\n      if (!this.active.length) {\n        this.tabs.eq(0).attr(\"tabIndex\", 0);\n      } else {\n        this.active.addClass(\"ui-tabs-active ui-state-active\").attr({\n          \"aria-selected\": \"true\",\n          \"aria-expanded\": \"true\",\n          tabIndex: 0\n        });\n\n        this._getPanelForTab(this.active).show().attr({\n          \"aria-hidden\": \"false\"\n        });\n      }\n    },\n    _processTabs: function _processTabs() {\n      var that = this,\n          prevTabs = this.tabs,\n          prevAnchors = this.anchors,\n          prevPanels = this.panels;\n      this.tablist = this._getList().addClass(\"ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all\").attr(\"role\", \"tablist\") // Prevent users from focusing disabled tabs via click\n      .delegate(\"> li\", \"mousedown\" + this.eventNamespace, function (event) {\n        if ($(this).is(\".ui-state-disabled\")) {\n          event.preventDefault();\n        }\n      }) // support: IE <9\n      // Preventing the default action in mousedown doesn't prevent IE\n      // from focusing the element, so if the anchor gets focused, blur.\n      // We don't have to worry about focusing the previously focused\n      // element since clicking on a non-focusable element should focus\n      // the body anyway.\n      .delegate(\".ui-tabs-anchor\", \"focus\" + this.eventNamespace, function () {\n        if ($(this).closest(\"li\").is(\".ui-state-disabled\")) {\n          this.blur();\n        }\n      });\n      this.tabs = this.tablist.find(\"> li:has(a[href])\").addClass(\"ui-state-default ui-corner-top\").attr({\n        role: \"tab\",\n        tabIndex: -1\n      });\n      this.anchors = this.tabs.map(function () {\n        return $(\"a\", this)[0];\n      }).addClass(\"ui-tabs-anchor\").attr({\n        role: \"presentation\",\n        tabIndex: -1\n      });\n      this.panels = $();\n      this.anchors.each(function (i, anchor) {\n        var selector,\n            panel,\n            panelId,\n            anchorId = $(anchor).uniqueId().attr(\"id\"),\n            tab = $(anchor).closest(\"li\"),\n            originalAriaControls = tab.attr(\"aria-controls\"); // inline tab\n\n        if (that._isLocal(anchor)) {\n          selector = anchor.hash;\n          panelId = selector.substring(1);\n          panel = that.element.find(that._sanitizeSelector(selector)); // remote tab\n        } else {\n          // If the tab doesn't already have aria-controls,\n          // generate an id by using a throw-away element\n          panelId = tab.attr(\"aria-controls\") || $({}).uniqueId()[0].id;\n          selector = \"#\" + panelId;\n          panel = that.element.find(selector);\n\n          if (!panel.length) {\n            panel = that._createPanel(panelId);\n            panel.insertAfter(that.panels[i - 1] || that.tablist);\n          }\n\n          panel.attr(\"aria-live\", \"polite\");\n        }\n\n        if (panel.length) {\n          that.panels = that.panels.add(panel);\n        }\n\n        if (originalAriaControls) {\n          tab.data(\"ui-tabs-aria-controls\", originalAriaControls);\n        }\n\n        tab.attr({\n          \"aria-controls\": panelId,\n          \"aria-labelledby\": anchorId\n        });\n        panel.attr(\"aria-labelledby\", anchorId);\n      });\n      this.panels.addClass(\"ui-tabs-panel ui-widget-content ui-corner-bottom\").attr(\"role\", \"tabpanel\"); // Avoid memory leaks (#10056)\n\n      if (prevTabs) {\n        this._off(prevTabs.not(this.tabs));\n\n        this._off(prevAnchors.not(this.anchors));\n\n        this._off(prevPanels.not(this.panels));\n      }\n    },\n    // allow overriding how to find the list for rare usage scenarios (#7715)\n    _getList: function _getList() {\n      return this.tablist || this.element.find(\"ol,ul\").eq(0);\n    },\n    _createPanel: function _createPanel(id) {\n      return $(\"<div>\").attr(\"id\", id).addClass(\"ui-tabs-panel ui-widget-content ui-corner-bottom\").data(\"ui-tabs-destroy\", true);\n    },\n    _setupDisabled: function _setupDisabled(disabled) {\n      if ($.isArray(disabled)) {\n        if (!disabled.length) {\n          disabled = false;\n        } else if (disabled.length === this.anchors.length) {\n          disabled = true;\n        }\n      } // disable tabs\n\n\n      for (var i = 0, li; li = this.tabs[i]; i++) {\n        if (disabled === true || $.inArray(i, disabled) !== -1) {\n          $(li).addClass(\"ui-state-disabled\").attr(\"aria-disabled\", \"true\");\n        } else {\n          $(li).removeClass(\"ui-state-disabled\").removeAttr(\"aria-disabled\");\n        }\n      }\n\n      this.options.disabled = disabled;\n    },\n    _setupEvents: function _setupEvents(event) {\n      var events = {};\n\n      if (event) {\n        $.each(event.split(\" \"), function (index, eventName) {\n          events[eventName] = \"_eventHandler\";\n        });\n      }\n\n      this._off(this.anchors.add(this.tabs).add(this.panels)); // Always prevent the default action, even when disabled\n\n\n      this._on(true, this.anchors, {\n        click: function click(event) {\n          event.preventDefault();\n        }\n      });\n\n      this._on(this.anchors, events);\n\n      this._on(this.tabs, {\n        keydown: \"_tabKeydown\"\n      });\n\n      this._on(this.panels, {\n        keydown: \"_panelKeydown\"\n      });\n\n      this._focusable(this.tabs);\n\n      this._hoverable(this.tabs);\n    },\n    _setupHeightStyle: function _setupHeightStyle(heightStyle) {\n      var maxHeight,\n          parent = this.element.parent();\n\n      if (heightStyle === \"fill\") {\n        maxHeight = parent.height();\n        maxHeight -= this.element.outerHeight() - this.element.height();\n        this.element.siblings(\":visible\").each(function () {\n          var elem = $(this),\n              position = elem.css(\"position\");\n\n          if (position === \"absolute\" || position === \"fixed\") {\n            return;\n          }\n\n          maxHeight -= elem.outerHeight(true);\n        });\n        this.element.children().not(this.panels).each(function () {\n          maxHeight -= $(this).outerHeight(true);\n        });\n        this.panels.each(function () {\n          $(this).height(Math.max(0, maxHeight - $(this).innerHeight() + $(this).height()));\n        }).css(\"overflow\", \"auto\");\n      } else if (heightStyle === \"auto\") {\n        maxHeight = 0;\n        this.panels.each(function () {\n          maxHeight = Math.max(maxHeight, $(this).height(\"\").height());\n        }).height(maxHeight);\n      }\n    },\n    _eventHandler: function _eventHandler(event) {\n      var options = this.options,\n          active = this.active,\n          anchor = $(event.currentTarget),\n          tab = anchor.closest(\"li\"),\n          clickedIsActive = tab[0] === active[0],\n          collapsing = clickedIsActive && options.collapsible,\n          toShow = collapsing ? $() : this._getPanelForTab(tab),\n          toHide = !active.length ? $() : this._getPanelForTab(active),\n          eventData = {\n        oldTab: active,\n        oldPanel: toHide,\n        newTab: collapsing ? $() : tab,\n        newPanel: toShow\n      };\n      event.preventDefault();\n\n      if (tab.hasClass(\"ui-state-disabled\") || // tab is already loading\n      tab.hasClass(\"ui-tabs-loading\") || // can't switch durning an animation\n      this.running || // click on active header, but not collapsible\n      clickedIsActive && !options.collapsible || // allow canceling activation\n      this._trigger(\"beforeActivate\", event, eventData) === false) {\n        return;\n      }\n\n      options.active = collapsing ? false : this.tabs.index(tab);\n      this.active = clickedIsActive ? $() : tab;\n\n      if (this.xhr) {\n        this.xhr.abort();\n      }\n\n      if (!toHide.length && !toShow.length) {\n        $.error(\"jQuery UI Tabs: Mismatching fragment identifier.\");\n      }\n\n      if (toShow.length) {\n        this.load(this.tabs.index(tab), event);\n      }\n\n      this._toggle(event, eventData);\n    },\n    // handles show/hide for selecting tabs\n    _toggle: function _toggle(event, eventData) {\n      var that = this,\n          toShow = eventData.newPanel,\n          toHide = eventData.oldPanel;\n      this.running = true;\n\n      function complete() {\n        that.running = false;\n\n        that._trigger(\"activate\", event, eventData);\n      }\n\n      function show() {\n        eventData.newTab.closest(\"li\").addClass(\"ui-tabs-active ui-state-active\");\n\n        if (toShow.length && that.options.show) {\n          that._show(toShow, that.options.show, complete);\n        } else {\n          toShow.show();\n          complete();\n        }\n      } // start out by hiding, then showing, then completing\n\n\n      if (toHide.length && this.options.hide) {\n        this._hide(toHide, this.options.hide, function () {\n          eventData.oldTab.closest(\"li\").removeClass(\"ui-tabs-active ui-state-active\");\n          show();\n        });\n      } else {\n        eventData.oldTab.closest(\"li\").removeClass(\"ui-tabs-active ui-state-active\");\n        toHide.hide();\n        show();\n      }\n\n      toHide.attr(\"aria-hidden\", \"true\");\n      eventData.oldTab.attr({\n        \"aria-selected\": \"false\",\n        \"aria-expanded\": \"false\"\n      }); // If we're switching tabs, remove the old tab from the tab order.\n      // If we're opening from collapsed state, remove the previous tab from the tab order.\n      // If we're collapsing, then keep the collapsing tab in the tab order.\n\n      if (toShow.length && toHide.length) {\n        eventData.oldTab.attr(\"tabIndex\", -1);\n      } else if (toShow.length) {\n        this.tabs.filter(function () {\n          return $(this).attr(\"tabIndex\") === 0;\n        }).attr(\"tabIndex\", -1);\n      }\n\n      toShow.attr(\"aria-hidden\", \"false\");\n      eventData.newTab.attr({\n        \"aria-selected\": \"true\",\n        \"aria-expanded\": \"true\",\n        tabIndex: 0\n      });\n    },\n    _activate: function _activate(index) {\n      var anchor,\n          active = this._findActive(index); // trying to activate the already active panel\n\n\n      if (active[0] === this.active[0]) {\n        return;\n      } // trying to collapse, simulate a click on the current active header\n\n\n      if (!active.length) {\n        active = this.active;\n      }\n\n      anchor = active.find(\".ui-tabs-anchor\")[0];\n\n      this._eventHandler({\n        target: anchor,\n        currentTarget: anchor,\n        preventDefault: $.noop\n      });\n    },\n    _findActive: function _findActive(index) {\n      return index === false ? $() : this.tabs.eq(index);\n    },\n    _getIndex: function _getIndex(index) {\n      // meta-function to give users option to provide a href string instead of a numerical index.\n      if (typeof index === \"string\") {\n        index = this.anchors.index(this.anchors.filter(\"[href$='\" + index + \"']\"));\n      }\n\n      return index;\n    },\n    _destroy: function _destroy() {\n      if (this.xhr) {\n        this.xhr.abort();\n      }\n\n      this.element.removeClass(\"ui-tabs ui-widget ui-widget-content ui-corner-all ui-tabs-collapsible\");\n      this.tablist.removeClass(\"ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all\").removeAttr(\"role\");\n      this.anchors.removeClass(\"ui-tabs-anchor\").removeAttr(\"role\").removeAttr(\"tabIndex\").removeUniqueId();\n      this.tablist.unbind(this.eventNamespace);\n      this.tabs.add(this.panels).each(function () {\n        if ($.data(this, \"ui-tabs-destroy\")) {\n          $(this).remove();\n        } else {\n          $(this).removeClass(\"ui-state-default ui-state-active ui-state-disabled \" + \"ui-corner-top ui-corner-bottom ui-widget-content ui-tabs-active ui-tabs-panel\").removeAttr(\"tabIndex\").removeAttr(\"aria-live\").removeAttr(\"aria-busy\").removeAttr(\"aria-selected\").removeAttr(\"aria-labelledby\").removeAttr(\"aria-hidden\").removeAttr(\"aria-expanded\").removeAttr(\"role\");\n        }\n      });\n      this.tabs.each(function () {\n        var li = $(this),\n            prev = li.data(\"ui-tabs-aria-controls\");\n\n        if (prev) {\n          li.attr(\"aria-controls\", prev).removeData(\"ui-tabs-aria-controls\");\n        } else {\n          li.removeAttr(\"aria-controls\");\n        }\n      });\n      this.panels.show();\n\n      if (this.options.heightStyle !== \"content\") {\n        this.panels.css(\"height\", \"\");\n      }\n    },\n    enable: function enable(index) {\n      var disabled = this.options.disabled;\n\n      if (disabled === false) {\n        return;\n      }\n\n      if (index === undefined) {\n        disabled = false;\n      } else {\n        index = this._getIndex(index);\n\n        if ($.isArray(disabled)) {\n          disabled = $.map(disabled, function (num) {\n            return num !== index ? num : null;\n          });\n        } else {\n          disabled = $.map(this.tabs, function (li, num) {\n            return num !== index ? num : null;\n          });\n        }\n      }\n\n      this._setupDisabled(disabled);\n    },\n    disable: function disable(index) {\n      var disabled = this.options.disabled;\n\n      if (disabled === true) {\n        return;\n      }\n\n      if (index === undefined) {\n        disabled = true;\n      } else {\n        index = this._getIndex(index);\n\n        if ($.inArray(index, disabled) !== -1) {\n          return;\n        }\n\n        if ($.isArray(disabled)) {\n          disabled = $.merge([index], disabled).sort();\n        } else {\n          disabled = [index];\n        }\n      }\n\n      this._setupDisabled(disabled);\n    },\n    load: function load(index, event) {\n      index = this._getIndex(index);\n\n      var that = this,\n          tab = this.tabs.eq(index),\n          anchor = tab.find(\".ui-tabs-anchor\"),\n          panel = this._getPanelForTab(tab),\n          eventData = {\n        tab: tab,\n        panel: panel\n      },\n          complete = function complete(jqXHR, status) {\n        if (status === \"abort\") {\n          that.panels.stop(false, true);\n        }\n\n        tab.removeClass(\"ui-tabs-loading\");\n        panel.removeAttr(\"aria-busy\");\n\n        if (jqXHR === that.xhr) {\n          delete that.xhr;\n        }\n      }; // not remote\n\n\n      if (this._isLocal(anchor[0])) {\n        return;\n      }\n\n      this.xhr = $.ajax(this._ajaxSettings(anchor, event, eventData)); // support: jQuery <1.8\n      // jQuery <1.8 returns false if the request is canceled in beforeSend,\n      // but as of 1.8, $.ajax() always returns a jqXHR object.\n\n      if (this.xhr && this.xhr.statusText !== \"canceled\") {\n        tab.addClass(\"ui-tabs-loading\");\n        panel.attr(\"aria-busy\", \"true\");\n        this.xhr.done(function (response, status, jqXHR) {\n          // support: jQuery <1.8\n          // http://bugs.jquery.com/ticket/11778\n          setTimeout(function () {\n            panel.html(response);\n\n            that._trigger(\"load\", event, eventData);\n\n            complete(jqXHR, status);\n          }, 1);\n        }).fail(function (jqXHR, status) {\n          // support: jQuery <1.8\n          // http://bugs.jquery.com/ticket/11778\n          setTimeout(function () {\n            complete(jqXHR, status);\n          }, 1);\n        });\n      }\n    },\n    _ajaxSettings: function _ajaxSettings(anchor, event, eventData) {\n      var that = this;\n      return {\n        url: anchor.attr(\"href\"),\n        beforeSend: function beforeSend(jqXHR, settings) {\n          return that._trigger(\"beforeLoad\", event, $.extend({\n            jqXHR: jqXHR,\n            ajaxSettings: settings\n          }, eventData));\n        }\n      };\n    },\n    _getPanelForTab: function _getPanelForTab(tab) {\n      var id = $(tab).attr(\"aria-controls\");\n      return this.element.find(this._sanitizeSelector(\"#\" + id));\n    }\n  });\n  /*!\n   * jQuery UI Tooltip 1.11.4\n   * http://jqueryui.com\n   *\n   * Copyright jQuery Foundation and other contributors\n   * Released under the MIT license.\n   * http://jquery.org/license\n   *\n   * http://api.jqueryui.com/tooltip/\n   */\n\n  var tooltip = $.widget(\"ui.tooltip\", {\n    version: \"1.11.4\",\n    options: {\n      content: function content() {\n        // support: IE<9, Opera in jQuery <1.7\n        // .text() can't accept undefined, so coerce to a string\n        var title = $(this).attr(\"title\") || \"\"; // Escape title, since we're going from an attribute to raw HTML\n\n        return $(\"<a>\").text(title).html();\n      },\n      hide: true,\n      // Disabled elements have inconsistent behavior across browsers (#8661)\n      items: \"[title]:not([disabled])\",\n      position: {\n        my: \"left top+15\",\n        at: \"left bottom\",\n        collision: \"flipfit flip\"\n      },\n      show: true,\n      tooltipClass: null,\n      track: false,\n      // callbacks\n      close: null,\n      open: null\n    },\n    _addDescribedBy: function _addDescribedBy(elem, id) {\n      var describedby = (elem.attr(\"aria-describedby\") || \"\").split(/\\s+/);\n      describedby.push(id);\n      elem.data(\"ui-tooltip-id\", id).attr(\"aria-describedby\", $.trim(describedby.join(\" \")));\n    },\n    _removeDescribedBy: function _removeDescribedBy(elem) {\n      var id = elem.data(\"ui-tooltip-id\"),\n          describedby = (elem.attr(\"aria-describedby\") || \"\").split(/\\s+/),\n          index = $.inArray(id, describedby);\n\n      if (index !== -1) {\n        describedby.splice(index, 1);\n      }\n\n      elem.removeData(\"ui-tooltip-id\");\n      describedby = $.trim(describedby.join(\" \"));\n\n      if (describedby) {\n        elem.attr(\"aria-describedby\", describedby);\n      } else {\n        elem.removeAttr(\"aria-describedby\");\n      }\n    },\n    _create: function _create() {\n      this._on({\n        mouseover: \"open\",\n        focusin: \"open\"\n      }); // IDs of generated tooltips, needed for destroy\n\n\n      this.tooltips = {}; // IDs of parent tooltips where we removed the title attribute\n\n      this.parents = {};\n\n      if (this.options.disabled) {\n        this._disable();\n      } // Append the aria-live region so tooltips announce correctly\n\n\n      this.liveRegion = $(\"<div>\").attr({\n        role: \"log\",\n        \"aria-live\": \"assertive\",\n        \"aria-relevant\": \"additions\"\n      }).addClass(\"ui-helper-hidden-accessible\").appendTo(this.document[0].body);\n    },\n    _setOption: function _setOption(key, value) {\n      var that = this;\n\n      if (key === \"disabled\") {\n        this[value ? \"_disable\" : \"_enable\"]();\n        this.options[key] = value; // disable element style changes\n\n        return;\n      }\n\n      this._super(key, value);\n\n      if (key === \"content\") {\n        $.each(this.tooltips, function (id, tooltipData) {\n          that._updateContent(tooltipData.element);\n        });\n      }\n    },\n    _disable: function _disable() {\n      var that = this; // close open tooltips\n\n      $.each(this.tooltips, function (id, tooltipData) {\n        var event = $.Event(\"blur\");\n        event.target = event.currentTarget = tooltipData.element[0];\n        that.close(event, true);\n      }); // remove title attributes to prevent native tooltips\n\n      this.element.find(this.options.items).addBack().each(function () {\n        var element = $(this);\n\n        if (element.is(\"[title]\")) {\n          element.data(\"ui-tooltip-title\", element.attr(\"title\")).removeAttr(\"title\");\n        }\n      });\n    },\n    _enable: function _enable() {\n      // restore title attributes\n      this.element.find(this.options.items).addBack().each(function () {\n        var element = $(this);\n\n        if (element.data(\"ui-tooltip-title\")) {\n          element.attr(\"title\", element.data(\"ui-tooltip-title\"));\n        }\n      });\n    },\n    open: function open(event) {\n      var that = this,\n          target = $(event ? event.target : this.element) // we need closest here due to mouseover bubbling,\n      // but always pointing at the same event target\n      .closest(this.options.items); // No element to show a tooltip for or the tooltip is already open\n\n      if (!target.length || target.data(\"ui-tooltip-id\")) {\n        return;\n      }\n\n      if (target.attr(\"title\")) {\n        target.data(\"ui-tooltip-title\", target.attr(\"title\"));\n      }\n\n      target.data(\"ui-tooltip-open\", true); // kill parent tooltips, custom or native, for hover\n\n      if (event && event.type === \"mouseover\") {\n        target.parents().each(function () {\n          var parent = $(this),\n              blurEvent;\n\n          if (parent.data(\"ui-tooltip-open\")) {\n            blurEvent = $.Event(\"blur\");\n            blurEvent.target = blurEvent.currentTarget = this;\n            that.close(blurEvent, true);\n          }\n\n          if (parent.attr(\"title\")) {\n            parent.uniqueId();\n            that.parents[this.id] = {\n              element: this,\n              title: parent.attr(\"title\")\n            };\n            parent.attr(\"title\", \"\");\n          }\n        });\n      }\n\n      this._registerCloseHandlers(event, target);\n\n      this._updateContent(target, event);\n    },\n    _updateContent: function _updateContent(target, event) {\n      var content,\n          contentOption = this.options.content,\n          that = this,\n          eventType = event ? event.type : null;\n\n      if (typeof contentOption === \"string\") {\n        return this._open(event, target, contentOption);\n      }\n\n      content = contentOption.call(target[0], function (response) {\n        // IE may instantly serve a cached response for ajax requests\n        // delay this call to _open so the other call to _open runs first\n        that._delay(function () {\n          // Ignore async response if tooltip was closed already\n          if (!target.data(\"ui-tooltip-open\")) {\n            return;\n          } // jQuery creates a special event for focusin when it doesn't\n          // exist natively. To improve performance, the native event\n          // object is reused and the type is changed. Therefore, we can't\n          // rely on the type being correct after the event finished\n          // bubbling, so we set it back to the previous value. (#8740)\n\n\n          if (event) {\n            event.type = eventType;\n          }\n\n          this._open(event, target, response);\n        });\n      });\n\n      if (content) {\n        this._open(event, target, content);\n      }\n    },\n    _open: function _open(event, target, content) {\n      var tooltipData,\n          tooltip,\n          delayedShow,\n          a11yContent,\n          positionOption = $.extend({}, this.options.position);\n\n      if (!content) {\n        return;\n      } // Content can be updated multiple times. If the tooltip already\n      // exists, then just update the content and bail.\n\n\n      tooltipData = this._find(target);\n\n      if (tooltipData) {\n        tooltipData.tooltip.find(\".ui-tooltip-content\").html(content);\n        return;\n      } // if we have a title, clear it to prevent the native tooltip\n      // we have to check first to avoid defining a title if none exists\n      // (we don't want to cause an element to start matching [title])\n      //\n      // We use removeAttr only for key events, to allow IE to export the correct\n      // accessible attributes. For mouse events, set to empty string to avoid\n      // native tooltip showing up (happens only when removing inside mouseover).\n\n\n      if (target.is(\"[title]\")) {\n        if (event && event.type === \"mouseover\") {\n          target.attr(\"title\", \"\");\n        } else {\n          target.removeAttr(\"title\");\n        }\n      }\n\n      tooltipData = this._tooltip(target);\n      tooltip = tooltipData.tooltip;\n\n      this._addDescribedBy(target, tooltip.attr(\"id\"));\n\n      tooltip.find(\".ui-tooltip-content\").html(content); // Support: Voiceover on OS X, JAWS on IE <= 9\n      // JAWS announces deletions even when aria-relevant=\"additions\"\n      // Voiceover will sometimes re-read the entire log region's contents from the beginning\n\n      this.liveRegion.children().hide();\n\n      if (content.clone) {\n        a11yContent = content.clone();\n        a11yContent.removeAttr(\"id\").find(\"[id]\").removeAttr(\"id\");\n      } else {\n        a11yContent = content;\n      }\n\n      $(\"<div>\").html(a11yContent).appendTo(this.liveRegion);\n\n      function position(event) {\n        positionOption.of = event;\n\n        if (tooltip.is(\":hidden\")) {\n          return;\n        }\n\n        tooltip.position(positionOption);\n      }\n\n      if (this.options.track && event && /^mouse/.test(event.type)) {\n        this._on(this.document, {\n          mousemove: position\n        }); // trigger once to override element-relative positioning\n\n\n        position(event);\n      } else {\n        tooltip.position($.extend({\n          of: target\n        }, this.options.position));\n      }\n\n      tooltip.hide();\n\n      this._show(tooltip, this.options.show); // Handle tracking tooltips that are shown with a delay (#8644). As soon\n      // as the tooltip is visible, position the tooltip using the most recent\n      // event.\n\n\n      if (this.options.show && this.options.show.delay) {\n        delayedShow = this.delayedShow = setInterval(function () {\n          if (tooltip.is(\":visible\")) {\n            position(positionOption.of);\n            clearInterval(delayedShow);\n          }\n        }, $.fx.interval);\n      }\n\n      this._trigger(\"open\", event, {\n        tooltip: tooltip\n      });\n    },\n    _registerCloseHandlers: function _registerCloseHandlers(event, target) {\n      var events = {\n        keyup: function keyup(event) {\n          if (event.keyCode === $.ui.keyCode.ESCAPE) {\n            var fakeEvent = $.Event(event);\n            fakeEvent.currentTarget = target[0];\n            this.close(fakeEvent, true);\n          }\n        }\n      }; // Only bind remove handler for delegated targets. Non-delegated\n      // tooltips will handle this in destroy.\n\n      if (target[0] !== this.element[0]) {\n        events.remove = function () {\n          this._removeTooltip(this._find(target).tooltip);\n        };\n      }\n\n      if (!event || event.type === \"mouseover\") {\n        events.mouseleave = \"close\";\n      }\n\n      if (!event || event.type === \"focusin\") {\n        events.focusout = \"close\";\n      }\n\n      this._on(true, target, events);\n    },\n    close: function close(event) {\n      var tooltip,\n          that = this,\n          target = $(event ? event.currentTarget : this.element),\n          tooltipData = this._find(target); // The tooltip may already be closed\n\n\n      if (!tooltipData) {\n        // We set ui-tooltip-open immediately upon open (in open()), but only set the\n        // additional data once there's actually content to show (in _open()). So even if the\n        // tooltip doesn't have full data, we always remove ui-tooltip-open in case we're in\n        // the period between open() and _open().\n        target.removeData(\"ui-tooltip-open\");\n        return;\n      }\n\n      tooltip = tooltipData.tooltip; // disabling closes the tooltip, so we need to track when we're closing\n      // to avoid an infinite loop in case the tooltip becomes disabled on close\n\n      if (tooltipData.closing) {\n        return;\n      } // Clear the interval for delayed tracking tooltips\n\n\n      clearInterval(this.delayedShow); // only set title if we had one before (see comment in _open())\n      // If the title attribute has changed since open(), don't restore\n\n      if (target.data(\"ui-tooltip-title\") && !target.attr(\"title\")) {\n        target.attr(\"title\", target.data(\"ui-tooltip-title\"));\n      }\n\n      this._removeDescribedBy(target);\n\n      tooltipData.hiding = true;\n      tooltip.stop(true);\n\n      this._hide(tooltip, this.options.hide, function () {\n        that._removeTooltip($(this));\n      });\n\n      target.removeData(\"ui-tooltip-open\");\n\n      this._off(target, \"mouseleave focusout keyup\"); // Remove 'remove' binding only on delegated targets\n\n\n      if (target[0] !== this.element[0]) {\n        this._off(target, \"remove\");\n      }\n\n      this._off(this.document, \"mousemove\");\n\n      if (event && event.type === \"mouseleave\") {\n        $.each(this.parents, function (id, parent) {\n          $(parent.element).attr(\"title\", parent.title);\n          delete that.parents[id];\n        });\n      }\n\n      tooltipData.closing = true;\n\n      this._trigger(\"close\", event, {\n        tooltip: tooltip\n      });\n\n      if (!tooltipData.hiding) {\n        tooltipData.closing = false;\n      }\n    },\n    _tooltip: function _tooltip(element) {\n      var tooltip = $(\"<div>\").attr(\"role\", \"tooltip\").addClass(\"ui-tooltip ui-widget ui-corner-all ui-widget-content \" + (this.options.tooltipClass || \"\")),\n          id = tooltip.uniqueId().attr(\"id\");\n      $(\"<div>\").addClass(\"ui-tooltip-content\").appendTo(tooltip);\n      tooltip.appendTo(this.document[0].body);\n      return this.tooltips[id] = {\n        element: element,\n        tooltip: tooltip\n      };\n    },\n    _find: function _find(target) {\n      var id = target.data(\"ui-tooltip-id\");\n      return id ? this.tooltips[id] : null;\n    },\n    _removeTooltip: function _removeTooltip(tooltip) {\n      tooltip.remove();\n      delete this.tooltips[tooltip.attr(\"id\")];\n    },\n    _destroy: function _destroy() {\n      var that = this; // close open tooltips\n\n      $.each(this.tooltips, function (id, tooltipData) {\n        // Delegate to close method to handle common cleanup\n        var event = $.Event(\"blur\"),\n            element = tooltipData.element;\n        event.target = event.currentTarget = element[0];\n        that.close(event, true); // Remove immediately; destroying an open tooltip doesn't use the\n        // hide animation\n\n        $(\"#\" + id).remove(); // Restore the title\n\n        if (element.data(\"ui-tooltip-title\")) {\n          // If the title attribute has changed since open(), don't restore\n          if (!element.attr(\"title\")) {\n            element.attr(\"title\", element.data(\"ui-tooltip-title\"));\n          }\n\n          element.removeData(\"ui-tooltip-title\");\n        }\n      });\n      this.liveRegion.remove();\n    }\n  });\n});"

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./node_modules/babel-loader/lib/index.js?!./assets/js/jquery.uploadfile-4.0.11.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/raw-loader!./node_modules/babel-loader/lib??ref--4-0!./assets/js/jquery.uploadfile-4.0.11.js ***!
  \*******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "/*!\n * jQuery Upload File Plugin\n * version: 4.0.11\n * @requires jQuery v1.5 or later & form plugin\n * Copyright (c) 2013 Ravishanker Kusuma\n * http://hayageek.com/\n */\n(function ($) {\n  if ($.fn.ajaxForm == undefined) {\n    $.getScript((\"https:\" == document.location.protocol ? \"https://\" : \"http://\") + \"malsup.github.io/jquery.form.js\");\n  }\n\n  var feature = {};\n  feature.fileapi = $(\"<input type='file'/>\").get(0).files !== undefined;\n  feature.formdata = window.FormData !== undefined;\n\n  $.fn.uploadFile = function (options) {\n    // This is the easiest way to have default options.\n    var s = $.extend({\n      // These are the defaults.\n      url: \"\",\n      method: \"POST\",\n      enctype: \"multipart/form-data\",\n      returnType: null,\n      allowDuplicates: true,\n      duplicateStrict: false,\n      allowedTypes: \"*\",\n      //For list of acceptFiles\n      // http://stackoverflow.com/questions/11832930/html-input-file-accept-attribute-file-type-csv\n      acceptFiles: \"*\",\n      fileName: \"file\",\n      formData: false,\n      dynamicFormData: false,\n      maxFileSize: -1,\n      maxFileCount: -1,\n      multiple: true,\n      dragDrop: true,\n      autoSubmit: true,\n      showCancel: true,\n      showAbort: true,\n      showDone: false,\n      showDelete: false,\n      showError: true,\n      showStatusAfterSuccess: true,\n      showStatusAfterError: true,\n      showFileCounter: true,\n      fileCounterStyle: \"). \",\n      showFileSize: true,\n      showProgress: false,\n      nestedForms: true,\n      showDownload: false,\n      onLoad: function onLoad(obj) {},\n      onSelect: function onSelect(files) {\n        return true;\n      },\n      onSubmit: function onSubmit(files, xhr) {},\n      onSuccess: function onSuccess(files, response, xhr, pd) {},\n      onError: function onError(files, status, message, pd) {},\n      onCancel: function onCancel(files, pd) {},\n      onAbort: function onAbort(files, pd) {},\n      downloadCallback: false,\n      deleteCallback: false,\n      afterUploadAll: false,\n      serialize: true,\n      sequential: false,\n      sequentialCount: 2,\n      customProgressBar: false,\n      abortButtonClass: \"ajax-file-upload-abort\",\n      cancelButtonClass: \"ajax-file-upload-cancel\",\n      dragDropContainerClass: \"ajax-upload-dragdrop\",\n      dragDropHoverClass: \"state-hover\",\n      errorClass: \"ajax-file-upload-error\",\n      uploadButtonClass: \"ajax-file-upload\",\n      dragDropStr: \"<span><b>Drag &amp; Drop Files</b></span>\",\n      uploadStr: \"Upload\",\n      abortStr: \"Abort\",\n      cancelStr: \"Cancel\",\n      deleteStr: \"Delete\",\n      doneStr: \"Done\",\n      multiDragErrorStr: \"Multiple File Drag &amp; Drop is not allowed.\",\n      extErrorStr: \"is not allowed. Allowed extensions: \",\n      duplicateErrorStr: \"is not allowed. File already exists.\",\n      sizeErrorStr: \"is not allowed. Allowed Max size: \",\n      uploadErrorStr: \"Upload is not allowed\",\n      maxFileCountErrorStr: \" is not allowed. Maximum allowed files are:\",\n      downloadStr: \"Download\",\n      customErrorKeyStr: \"jquery-upload-file-error\",\n      showQueueDiv: false,\n      statusBarWidth: 400,\n      dragdropWidth: 400,\n      showPreview: false,\n      previewHeight: \"auto\",\n      previewWidth: \"100%\",\n      extraHTML: false,\n      uploadQueueOrder: 'top',\n      headers: {}\n    }, options);\n    this.fileCounter = 1;\n    this.selectedFiles = 0;\n    var formGroup = \"ajax-file-upload-\" + new Date().getTime();\n    this.formGroup = formGroup;\n    this.errorLog = $(\"<div></div>\"); //Writing errors\n\n    this.responses = [];\n    this.existingFileNames = [];\n\n    if (!feature.formdata) //check drag drop enabled.\n      {\n        s.dragDrop = false;\n      }\n\n    if (!feature.formdata || s.maxFileCount === 1) {\n      s.multiple = false;\n    }\n\n    $(this).html(\"\");\n    var obj = this;\n    var uploadLabel = $('<div>' + s.uploadStr + '</div>');\n    $(uploadLabel).addClass(s.uploadButtonClass); // wait form ajax Form plugin and initialize\n\n    (function checkAjaxFormLoaded() {\n      if ($.fn.ajaxForm) {\n        if (s.dragDrop) {\n          var dragDrop = $('<div class=\"' + s.dragDropContainerClass + '\" style=\"vertical-align:top;\"></div>').width(s.dragdropWidth);\n          $(obj).append(dragDrop);\n          $(dragDrop).append(uploadLabel);\n          $(dragDrop).append($(s.dragDropStr));\n          setDragDropHandlers(obj, s, dragDrop);\n        } else {\n          $(obj).append(uploadLabel);\n        }\n\n        $(obj).append(obj.errorLog);\n        if (s.showQueueDiv) obj.container = $(\"#\" + s.showQueueDiv);else obj.container = $(\"<div class='ajax-file-upload-container'></div>\").insertAfter($(obj));\n        s.onLoad.call(this, obj);\n        createCustomInputFile(obj, formGroup, s, uploadLabel);\n      } else window.setTimeout(checkAjaxFormLoaded, 10);\n    })();\n\n    this.startUpload = function () {\n      $(\"form\").each(function (i, items) {\n        if ($(this).hasClass(obj.formGroup)) {\n          mainQ.push($(this));\n        }\n      });\n      if (mainQ.length >= 1) submitPendingUploads();\n    };\n\n    this.getFileCount = function () {\n      return obj.selectedFiles;\n    };\n\n    this.stopUpload = function () {\n      $(\".\" + s.abortButtonClass).each(function (i, items) {\n        if ($(this).hasClass(obj.formGroup)) $(this).click();\n      });\n      $(\".\" + s.cancelButtonClass).each(function (i, items) {\n        if ($(this).hasClass(obj.formGroup)) $(this).click();\n      });\n    };\n\n    this.cancelAll = function () {\n      $(\".\" + s.cancelButtonClass).each(function (i, items) {\n        if ($(this).hasClass(obj.formGroup)) $(this).click();\n      });\n    };\n\n    this.update = function (settings) {\n      //update new settings\n      s = $.extend(s, settings); //We need to update action for already created Form.            \n\n      if (settings.hasOwnProperty('url')) {\n        $(\"form\").each(function (i, items) {\n          $(this).attr('action', settings['url']);\n        });\n      }\n    };\n\n    this.enqueueFile = function (file) {\n      if (!(file instanceof File)) return;\n      var files = [file];\n      serializeAndUploadFiles(s, obj, files);\n    };\n\n    this.reset = function (removeStatusBars) {\n      obj.fileCounter = 1;\n      obj.selectedFiles = 0;\n      obj.errorLog.html(\"\"); //remove all the status bars.\n\n      if (removeStatusBars != false) {\n        obj.container.html(\"\");\n      }\n    };\n\n    this.remove = function () {\n      obj.container.html(\"\");\n      $(obj).remove();\n    }; //This is for showing Old files to user.\n\n\n    this.createProgress = function (filename, filepath, filesize) {\n      var pd = new createProgressDiv(this, s);\n      pd.progressDiv.show();\n      pd.progressbar.width('100%');\n      var fileNameStr = \"\";\n      if (s.showFileCounter) fileNameStr = obj.fileCounter + s.fileCounterStyle + filename;else fileNameStr = filename;\n      if (s.showFileSize) fileNameStr += \" (\" + getSizeStr(filesize) + \")\";\n      pd.filename.html(fileNameStr);\n      obj.fileCounter++;\n      obj.selectedFiles++;\n\n      if (s.showPreview) {\n        pd.preview.attr('src', filepath);\n        pd.preview.show();\n      }\n\n      if (s.showDownload) {\n        pd.download.show();\n        pd.download.click(function () {\n          if (s.downloadCallback) s.downloadCallback.call(obj, [filename], pd);\n        });\n      }\n\n      if (s.showDelete) {\n        pd.del.show();\n        pd.del.click(function () {\n          pd.statusbar.hide().remove();\n          var arr = [filename];\n          if (s.deleteCallback) s.deleteCallback.call(this, arr, pd);\n          obj.selectedFiles -= 1;\n          updateFileCounter(s, obj);\n        });\n      }\n\n      return pd;\n    };\n\n    this.getResponses = function () {\n      return this.responses;\n    };\n\n    var mainQ = [];\n    var progressQ = [];\n    var running = false;\n\n    function submitPendingUploads() {\n      if (running) return;\n      running = true;\n\n      (function checkPendingForms() {\n        //if not sequential upload all files\n        if (!s.sequential) s.sequentialCount = 99999;\n\n        if (mainQ.length == 0 && progressQ.length == 0) {\n          if (s.afterUploadAll) s.afterUploadAll(obj);\n          running = false;\n        } else {\n          if (progressQ.length < s.sequentialCount) {\n            var frm = mainQ.shift();\n\n            if (frm != undefined) {\n              progressQ.push(frm); //Remove the class group.\n\n              frm.removeClass(obj.formGroup);\n              frm.submit();\n            }\n          }\n\n          window.setTimeout(checkPendingForms, 100);\n        }\n      })();\n    }\n\n    function setDragDropHandlers(obj, s, ddObj) {\n      ddObj.on('dragenter', function (e) {\n        e.stopPropagation();\n        e.preventDefault();\n        $(this).addClass(s.dragDropHoverClass);\n      });\n      ddObj.on('dragover', function (e) {\n        e.stopPropagation();\n        e.preventDefault();\n        var that = $(this);\n\n        if (that.hasClass(s.dragDropContainerClass) && !that.hasClass(s.dragDropHoverClass)) {\n          that.addClass(s.dragDropHoverClass);\n        }\n      });\n      ddObj.on('drop', function (e) {\n        e.preventDefault();\n        $(this).removeClass(s.dragDropHoverClass);\n        obj.errorLog.html(\"\");\n        var files = e.originalEvent.dataTransfer.files;\n\n        if (!s.multiple && files.length > 1) {\n          if (s.showError) $(\"<div class='\" + s.errorClass + \"'>\" + s.multiDragErrorStr + \"</div>\").appendTo(obj.errorLog);\n          return;\n        }\n\n        if (s.onSelect(files) == false) return;\n        serializeAndUploadFiles(s, obj, files);\n      });\n      ddObj.on('dragleave', function (e) {\n        $(this).removeClass(s.dragDropHoverClass);\n      });\n      $(document).on('dragenter', function (e) {\n        e.stopPropagation();\n        e.preventDefault();\n      });\n      $(document).on('dragover', function (e) {\n        e.stopPropagation();\n        e.preventDefault();\n        var that = $(this);\n\n        if (!that.hasClass(s.dragDropContainerClass)) {\n          that.removeClass(s.dragDropHoverClass);\n        }\n      });\n      $(document).on('drop', function (e) {\n        e.stopPropagation();\n        e.preventDefault();\n        $(this).removeClass(s.dragDropHoverClass);\n      });\n    }\n\n    function getSizeStr(size) {\n      var sizeStr = \"\";\n      var sizeKB = size / 1024;\n\n      if (parseInt(sizeKB) > 1024) {\n        var sizeMB = sizeKB / 1024;\n        sizeStr = sizeMB.toFixed(2) + \" MB\";\n      } else {\n        sizeStr = sizeKB.toFixed(2) + \" KB\";\n      }\n\n      return sizeStr;\n    }\n\n    function serializeData(extraData) {\n      var serialized = [];\n\n      if (jQuery.type(extraData) == \"string\") {\n        serialized = extraData.split('&');\n      } else {\n        serialized = $.param(extraData).split('&');\n      }\n\n      var len = serialized.length;\n      var result = [];\n      var i, part;\n\n      for (i = 0; i < len; i++) {\n        serialized[i] = serialized[i].replace(/\\+/g, ' ');\n        part = serialized[i].split('=');\n        result.push([decodeURIComponent(part[0]), decodeURIComponent(part[1])]);\n      }\n\n      return result;\n    }\n\n    function noserializeAndUploadFiles(s, obj, files) {\n      var ts = $.extend({}, s);\n      var fd = new FormData();\n      var fileArray = [];\n      var fileName = s.fileName.replace(\"[]\", \"\");\n      var fileListStr = \"\";\n\n      for (var i = 0; i < files.length; i++) {\n        if (!isFileTypeAllowed(obj, s, files[i].name)) {\n          if (s.showError) $(\"<div><font color='red'><b>\" + files[i].name + \"</b> \" + s.extErrorStr + s.allowedTypes + \"</font></div>\").appendTo(obj.errorLog);\n          continue;\n        }\n\n        if (s.maxFileSize != -1 && files[i].size > s.maxFileSize) {\n          if (s.showError) $(\"<div><font color='red'><b>\" + files[i].name + \"</b> \" + s.sizeErrorStr + getSizeStr(s.maxFileSize) + \"</font></div>\").appendTo(obj.errorLog);\n          continue;\n        }\n\n        fd.append(fileName + \"[]\", files[i]);\n        fileArray.push(files[i].name);\n        fileListStr += obj.fileCounter + \"). \" + files[i].name + \"<br>\";\n        obj.fileCounter++;\n      }\n\n      if (fileArray.length == 0) return;\n      var extraData = s.formData;\n\n      if (extraData) {\n        var sData = serializeData(extraData);\n\n        for (var j = 0; j < sData.length; j++) {\n          if (sData[j]) {\n            fd.append(sData[j][0], sData[j][1]);\n          }\n        }\n      }\n\n      ts.fileData = fd;\n      var pd = new createProgressDiv(obj, s);\n      pd.filename.html(fileListStr);\n      var form = $(\"<form style='display:block; position:absolute;left: 150px;' class='\" + obj.formGroup + \"' method='\" + s.method + \"' action='\" + s.url + \"' enctype='\" + s.enctype + \"'></form>\");\n      form.appendTo('body');\n      ajaxFormSubmit(form, ts, pd, fileArray, obj);\n    }\n\n    function serializeAndUploadFiles(s, obj, files) {\n      for (var i = 0; i < files.length; i++) {\n        if (!isFileTypeAllowed(obj, s, files[i].name)) {\n          if (s.showError) $(\"<div class='\" + s.errorClass + \"'><b>\" + files[i].name + \"</b> \" + s.extErrorStr + s.allowedTypes + \"</div>\").appendTo(obj.errorLog);\n          continue;\n        }\n\n        if (!s.allowDuplicates && isFileDuplicate(obj, files[i].name)) {\n          if (s.showError) $(\"<div class='\" + s.errorClass + \"'><b>\" + files[i].name + \"</b> \" + s.duplicateErrorStr + \"</div>\").appendTo(obj.errorLog);\n          continue;\n        }\n\n        if (s.maxFileSize != -1 && files[i].size > s.maxFileSize) {\n          if (s.showError) $(\"<div class='\" + s.errorClass + \"'><b>\" + files[i].name + \"</b> \" + s.sizeErrorStr + getSizeStr(s.maxFileSize) + \"</div>\").appendTo(obj.errorLog);\n          continue;\n        }\n\n        if (s.maxFileCount != -1 && obj.selectedFiles >= s.maxFileCount) {\n          if (s.showError) $(\"<div class='\" + s.errorClass + \"'><b>\" + files[i].name + \"</b> \" + s.maxFileCountErrorStr + s.maxFileCount + \"</div>\").appendTo(obj.errorLog);\n          continue;\n        }\n\n        obj.selectedFiles++;\n        obj.existingFileNames.push(files[i].name); // Make object immutable\n\n        var ts = $.extend({}, s);\n        var fd = new FormData();\n        var fileName = s.fileName.replace(\"[]\", \"\");\n        fd.append(fileName, files[i]);\n        var extraData = s.formData;\n\n        if (extraData) {\n          var sData = serializeData(extraData);\n\n          for (var j = 0; j < sData.length; j++) {\n            if (sData[j]) {\n              fd.append(sData[j][0], sData[j][1]);\n            }\n          }\n        }\n\n        ts.fileData = fd;\n        var pd = new createProgressDiv(obj, s);\n        var fileNameStr = \"\";\n        if (s.showFileCounter) fileNameStr = obj.fileCounter + s.fileCounterStyle + files[i].name;else fileNameStr = files[i].name;\n        if (s.showFileSize) fileNameStr += \" (\" + getSizeStr(files[i].size) + \")\";\n        pd.filename.html(fileNameStr);\n        var form = $(\"<form style='display:block; position:absolute;left: 150px;' class='\" + obj.formGroup + \"' method='\" + s.method + \"' action='\" + s.url + \"' enctype='\" + s.enctype + \"'></form>\");\n        form.appendTo('body');\n        var fileArray = [];\n        fileArray.push(files[i].name);\n        ajaxFormSubmit(form, ts, pd, fileArray, obj, files[i]);\n        obj.fileCounter++;\n      }\n    }\n\n    function isFileTypeAllowed(obj, s, fileName) {\n      var fileExtensions = s.allowedTypes.toLowerCase().split(/[\\s,]+/g);\n      var ext = fileName.split('.').pop().toLowerCase();\n\n      if (s.allowedTypes != \"*\" && jQuery.inArray(ext, fileExtensions) < 0) {\n        return false;\n      }\n\n      return true;\n    }\n\n    function isFileDuplicate(obj, filename) {\n      var duplicate = false;\n\n      if (obj.existingFileNames.length) {\n        for (var x = 0; x < obj.existingFileNames.length; x++) {\n          if (obj.existingFileNames[x] == filename || s.duplicateStrict && obj.existingFileNames[x].toLowerCase() == filename.toLowerCase()) {\n            duplicate = true;\n          }\n        }\n      }\n\n      return duplicate;\n    }\n\n    function removeExistingFileName(obj, fileArr) {\n      if (obj.existingFileNames.length) {\n        for (var x = 0; x < fileArr.length; x++) {\n          var pos = obj.existingFileNames.indexOf(fileArr[x]);\n\n          if (pos != -1) {\n            obj.existingFileNames.splice(pos, 1);\n          }\n        }\n      }\n    }\n\n    function getSrcToPreview(file, obj) {\n      if (file) {\n        obj.show();\n        var reader = new FileReader();\n\n        reader.onload = function (e) {\n          obj.attr('src', e.target.result);\n        };\n\n        reader.readAsDataURL(file);\n      }\n    }\n\n    function updateFileCounter(s, obj) {\n      if (s.showFileCounter) {\n        var count = $(obj.container).find(\".ajax-file-upload-filename\").length;\n        obj.fileCounter = count + 1;\n        $(obj.container).find(\".ajax-file-upload-filename\").each(function (i, items) {\n          var arr = $(this).html().split(s.fileCounterStyle);\n          var fileNum = parseInt(arr[0]) - 1; //decrement;\n\n          var name = count + s.fileCounterStyle + arr[1];\n          $(this).html(name);\n          count--;\n        });\n      }\n    }\n\n    function createCustomInputFile(obj, group, s, uploadLabel) {\n      var fileUploadId = \"ajax-upload-id-\" + new Date().getTime();\n      var form = $(\"<form method='\" + s.method + \"' action='\" + s.url + \"' enctype='\" + s.enctype + \"'></form>\");\n      var fileInputStr = \"<input type='file' id='\" + fileUploadId + \"' name='\" + s.fileName + \"' accept='\" + s.acceptFiles + \"'/>\";\n\n      if (s.multiple) {\n        if (s.fileName.indexOf(\"[]\") != s.fileName.length - 2) // if it does not endwith\n          {\n            s.fileName += \"[]\";\n          }\n\n        fileInputStr = \"<input type='file' id='\" + fileUploadId + \"' name='\" + s.fileName + \"' accept='\" + s.acceptFiles + \"' multiple/>\";\n      }\n\n      var fileInput = $(fileInputStr).appendTo(form);\n      fileInput.change(function () {\n        obj.errorLog.html(\"\");\n        var fileExtensions = s.allowedTypes.toLowerCase().split(\",\");\n        var fileArray = [];\n\n        if (this.files) //support reading files\n          {\n            for (i = 0; i < this.files.length; i++) {\n              fileArray.push(this.files[i].name);\n            }\n\n            if (s.onSelect(this.files) == false) return;\n          } else {\n          var filenameStr = $(this).val();\n          var flist = [];\n          fileArray.push(filenameStr);\n\n          if (!isFileTypeAllowed(obj, s, filenameStr)) {\n            if (s.showError) $(\"<div class='\" + s.errorClass + \"'><b>\" + filenameStr + \"</b> \" + s.extErrorStr + s.allowedTypes + \"</div>\").appendTo(obj.errorLog);\n            return;\n          } //fallback for browser without FileAPI\n\n\n          flist.push({\n            name: filenameStr,\n            size: 'NA'\n          });\n          if (s.onSelect(flist) == false) return;\n        }\n\n        updateFileCounter(s, obj);\n        uploadLabel.unbind(\"click\");\n        form.hide();\n        createCustomInputFile(obj, group, s, uploadLabel);\n        form.addClass(group);\n\n        if (s.serialize && feature.fileapi && feature.formdata) //use HTML5 support and split file submission\n          {\n            form.removeClass(group); //Stop Submitting when.\n\n            var files = this.files;\n            form.remove();\n            serializeAndUploadFiles(s, obj, files);\n          } else {\n          var fileList = \"\";\n\n          for (var i = 0; i < fileArray.length; i++) {\n            if (s.showFileCounter) fileList += obj.fileCounter + s.fileCounterStyle + fileArray[i] + \"<br>\";else fileList += fileArray[i] + \"<br>\";\n            ;\n            obj.fileCounter++;\n          }\n\n          if (s.maxFileCount != -1 && obj.selectedFiles + fileArray.length > s.maxFileCount) {\n            if (s.showError) $(\"<div class='\" + s.errorClass + \"'><b>\" + fileList + \"</b> \" + s.maxFileCountErrorStr + s.maxFileCount + \"</div>\").appendTo(obj.errorLog);\n            return;\n          }\n\n          obj.selectedFiles += fileArray.length;\n          var pd = new createProgressDiv(obj, s);\n          pd.filename.html(fileList);\n          ajaxFormSubmit(form, s, pd, fileArray, obj, null);\n        }\n      });\n\n      if (s.nestedForms) {\n        form.css({\n          'margin': 0,\n          'padding': 0\n        });\n        uploadLabel.css({\n          position: 'relative',\n          overflow: 'hidden',\n          cursor: 'default'\n        });\n        fileInput.css({\n          position: 'absolute',\n          'cursor': 'pointer',\n          'top': '0px',\n          'width': '100%',\n          'height': '100%',\n          'left': '0px',\n          'z-index': '100',\n          'opacity': '0.0',\n          'filter': 'alpha(opacity=0)',\n          '-ms-filter': \"alpha(opacity=0)\",\n          '-khtml-opacity': '0.0',\n          '-moz-opacity': '0.0'\n        });\n        form.appendTo(uploadLabel);\n      } else {\n        form.appendTo($('body'));\n        form.css({\n          margin: 0,\n          padding: 0,\n          display: 'block',\n          position: 'absolute',\n          left: '-250px'\n        });\n\n        if (navigator.appVersion.indexOf(\"MSIE \") != -1) //IE Browser\n          {\n            uploadLabel.attr('for', fileUploadId);\n          } else {\n          uploadLabel.click(function () {\n            fileInput.click();\n          });\n        }\n      }\n    }\n\n    function defaultProgressBar(obj, s) {\n      this.statusbar = $(\"<div class='ajax-file-upload-statusbar'></div>\").width(s.statusBarWidth);\n      this.preview = $(\"<img class='ajax-file-upload-preview' />\").width(s.previewWidth).height(s.previewHeight).appendTo(this.statusbar).hide();\n      this.filename = $(\"<div class='ajax-file-upload-filename'></div>\").appendTo(this.statusbar);\n      this.progressDiv = $(\"<div class='ajax-file-upload-progress'>\").appendTo(this.statusbar).hide();\n      this.progressbar = $(\"<div class='ajax-file-upload-bar'></div>\").appendTo(this.progressDiv);\n      this.abort = $(\"<div>\" + s.abortStr + \"</div>\").appendTo(this.statusbar).hide();\n      this.cancel = $(\"<div>\" + s.cancelStr + \"</div>\").appendTo(this.statusbar).hide();\n      this.done = $(\"<div>\" + s.doneStr + \"</div>\").appendTo(this.statusbar).hide();\n      this.download = $(\"<div>\" + s.downloadStr + \"</div>\").appendTo(this.statusbar).hide();\n      this.del = $(\"<div>\" + s.deleteStr + \"</div>\").appendTo(this.statusbar).hide();\n      this.abort.addClass(\"ajax-file-upload-red\");\n      this.done.addClass(\"ajax-file-upload-green\");\n      this.download.addClass(\"ajax-file-upload-green\");\n      this.cancel.addClass(\"ajax-file-upload-red\");\n      this.del.addClass(\"ajax-file-upload-red\");\n      return this;\n    }\n\n    function createProgressDiv(obj, s) {\n      var bar = null;\n      if (s.customProgressBar) bar = new s.customProgressBar(obj, s);else bar = new defaultProgressBar(obj, s);\n      bar.abort.addClass(obj.formGroup);\n      bar.abort.addClass(s.abortButtonClass);\n      bar.cancel.addClass(obj.formGroup);\n      bar.cancel.addClass(s.cancelButtonClass);\n      if (s.extraHTML) bar.extraHTML = $(\"<div class='extrahtml'>\" + s.extraHTML() + \"</div>\").insertAfter(bar.filename);\n      if (s.uploadQueueOrder == 'bottom') $(obj.container).append(bar.statusbar);else $(obj.container).prepend(bar.statusbar);\n      return bar;\n    }\n\n    function ajaxFormSubmit(form, s, pd, fileArray, obj, file) {\n      var currentXHR = null;\n      var options = {\n        cache: false,\n        contentType: false,\n        processData: false,\n        forceSync: false,\n        type: s.method,\n        data: s.formData,\n        formData: s.fileData,\n        dataType: s.returnType,\n        headers: s.headers,\n        beforeSubmit: function beforeSubmit(formData, $form, options) {\n          if (s.onSubmit.call(this, fileArray) != false) {\n            if (s.dynamicFormData) {\n              var sData = serializeData(s.dynamicFormData());\n\n              if (sData) {\n                for (var j = 0; j < sData.length; j++) {\n                  if (sData[j]) {\n                    if (s.serialize && s.fileData != undefined) options.formData.append(sData[j][0], sData[j][1]);else options.data[sData[j][0]] = sData[j][1];\n                  }\n                }\n              }\n            }\n\n            if (s.extraHTML) {\n              $(pd.extraHTML).find(\"input,select,textarea\").each(function (i, items) {\n                if (s.serialize && s.fileData != undefined) options.formData.append($(this).attr('name'), $(this).val());else options.data[$(this).attr('name')] = $(this).val();\n              });\n            }\n\n            return true;\n          }\n\n          pd.statusbar.append(\"<div class='\" + s.errorClass + \"'>\" + s.uploadErrorStr + \"</div>\");\n          pd.cancel.show();\n          form.remove();\n          pd.cancel.click(function () {\n            mainQ.splice(mainQ.indexOf(form), 1);\n            removeExistingFileName(obj, fileArray);\n            pd.statusbar.remove();\n            s.onCancel.call(obj, fileArray, pd);\n            obj.selectedFiles -= fileArray.length; //reduce selected File count\n\n            updateFileCounter(s, obj);\n          });\n          return false;\n        },\n        beforeSend: function beforeSend(xhr, o) {\n          for (var key in o.headers) {\n            xhr.setRequestHeader(key, o.headers[key]);\n          }\n\n          pd.progressDiv.show();\n          pd.cancel.hide();\n          pd.done.hide();\n\n          if (s.showAbort) {\n            pd.abort.show();\n            pd.abort.click(function () {\n              removeExistingFileName(obj, fileArray);\n              xhr.abort();\n              obj.selectedFiles -= fileArray.length; //reduce selected File count\n\n              s.onAbort.call(obj, fileArray, pd);\n            });\n          }\n\n          if (!feature.formdata) //For iframe based push\n            {\n              pd.progressbar.width('5%');\n            } else pd.progressbar.width('1%'); //Fix for small files\n\n        },\n        uploadProgress: function uploadProgress(event, position, total, percentComplete) {\n          //Fix for smaller file uploads in MAC\n          if (percentComplete > 98) percentComplete = 98;\n          var percentVal = percentComplete + '%';\n          if (percentComplete > 1) pd.progressbar.width(percentVal);\n\n          if (s.showProgress) {\n            pd.progressbar.html(percentVal);\n            pd.progressbar.css('text-align', 'center');\n          }\n        },\n        success: function success(data, message, xhr) {\n          pd.cancel.remove();\n          progressQ.pop(); //For custom errors.\n\n          if (s.returnType == \"json\" && $.type(data) == \"object\" && data.hasOwnProperty(s.customErrorKeyStr)) {\n            pd.abort.hide();\n            var msg = data[s.customErrorKeyStr];\n            s.onError.call(this, fileArray, 200, msg, pd);\n\n            if (s.showStatusAfterError) {\n              pd.progressDiv.hide();\n              pd.statusbar.append(\"<span class='\" + s.errorClass + \"'>ERROR: \" + msg + \"</span>\");\n            } else {\n              pd.statusbar.hide();\n              pd.statusbar.remove();\n            }\n\n            obj.selectedFiles -= fileArray.length; //reduce selected File count\n\n            form.remove();\n            return;\n          }\n\n          obj.responses.push(data);\n          pd.progressbar.width('100%');\n\n          if (s.showProgress) {\n            pd.progressbar.html('100%');\n            pd.progressbar.css('text-align', 'center');\n          }\n\n          pd.abort.hide();\n          s.onSuccess.call(this, fileArray, data, xhr, pd);\n\n          if (s.showStatusAfterSuccess) {\n            if (s.showDone) {\n              pd.done.show();\n              pd.done.click(function () {\n                pd.statusbar.hide(\"slow\");\n                pd.statusbar.remove();\n              });\n            } else {\n              pd.done.hide();\n            }\n\n            if (s.showDelete) {\n              pd.del.show();\n              pd.del.click(function () {\n                removeExistingFileName(obj, fileArray);\n                pd.statusbar.hide().remove();\n                if (s.deleteCallback) s.deleteCallback.call(this, data, pd);\n                obj.selectedFiles -= fileArray.length; //reduce selected File count\n\n                updateFileCounter(s, obj);\n              });\n            } else {\n              pd.del.hide();\n            }\n          } else {\n            pd.statusbar.hide(\"slow\");\n            pd.statusbar.remove();\n          }\n\n          if (s.showDownload) {\n            pd.download.show();\n            pd.download.click(function () {\n              if (s.downloadCallback) s.downloadCallback(data, pd);\n            });\n          }\n\n          form.remove();\n        },\n        error: function error(xhr, status, errMsg) {\n          pd.cancel.remove();\n          progressQ.pop();\n          pd.abort.hide();\n\n          if (xhr.statusText == \"abort\") //we aborted it\n            {\n              pd.statusbar.hide(\"slow\").remove();\n              updateFileCounter(s, obj);\n            } else {\n            s.onError.call(this, fileArray, status, errMsg, pd);\n\n            if (s.showStatusAfterError) {\n              pd.progressDiv.hide();\n              pd.statusbar.append(\"<span class='\" + s.errorClass + \"'>ERROR: \" + errMsg + \"</span>\");\n            } else {\n              pd.statusbar.hide();\n              pd.statusbar.remove();\n            }\n\n            obj.selectedFiles -= fileArray.length; //reduce selected File count\n          }\n\n          form.remove();\n        }\n      };\n\n      if (s.showPreview && file != null) {\n        if (file.type.toLowerCase().split(\"/\").shift() == \"image\") getSrcToPreview(file, pd.preview);\n      }\n\n      if (s.autoSubmit) {\n        form.ajaxForm(options);\n        mainQ.push(form);\n        submitPendingUploads();\n      } else {\n        if (s.showCancel) {\n          pd.cancel.show();\n          pd.cancel.click(function () {\n            mainQ.splice(mainQ.indexOf(form), 1);\n            removeExistingFileName(obj, fileArray);\n            form.remove();\n            pd.statusbar.remove();\n            s.onCancel.call(obj, fileArray, pd);\n            obj.selectedFiles -= fileArray.length; //reduce selected File count\n\n            updateFileCounter(s, obj);\n          });\n        }\n\n        form.ajaxForm(options);\n      }\n    }\n\n    return this;\n  };\n})(jQuery);"

/***/ }),

/***/ "./node_modules/script-loader/addScript.js":
/*!*************************************************!*\
  !*** ./node_modules/script-loader/addScript.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
module.exports = function(src) {
	function log(error) {
		(typeof console !== "undefined")
		&& (console.error || console.log)("[Script Loader]", error);
	}

	// Check for IE =< 8
	function isIE() {
		return typeof attachEvent !== "undefined" && typeof addEventListener === "undefined";
	}

	try {
		if (typeof execScript !== "undefined" && isIE()) {
			execScript(src);
		} else if (typeof eval !== "undefined") {
			eval.call(null, src);
		} else {
			log("EvalError: No eval function available");
		}
	} catch (error) {
		log(error);
	}
}


/***/ }),

/***/ "./node_modules/script-loader/index.js!./assets/js/bowser.js":
/*!**********************************************************!*\
  !*** ./node_modules/script-loader!./assets/js/bowser.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! !./node_modules/script-loader/addScript.js */ "./node_modules/script-loader/addScript.js")(__webpack_require__(/*! !./node_modules/raw-loader!./node_modules/babel-loader/lib??ref--4-0!./assets/js/bowser.js */ "./node_modules/raw-loader/index.js!./node_modules/babel-loader/lib/index.js?!./assets/js/bowser.js")+"\n\n// SCRIPT-LOADER FOOTER\n//# sourceURL=script:///home/osboxes/workspace/mlab.local.test/node_modules/babel-loader/lib/index.js%3F?ref--4-0!/home/osboxes/workspace/mlab.local.test/assets/js/bowser.js")

/***/ }),

/***/ "./node_modules/script-loader/index.js!./assets/js/jquery-2.1.4.js":
/*!****************************************************************!*\
  !*** ./node_modules/script-loader!./assets/js/jquery-2.1.4.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! !./node_modules/script-loader/addScript.js */ "./node_modules/script-loader/addScript.js")(__webpack_require__(/*! !./node_modules/raw-loader!./node_modules/babel-loader/lib??ref--4-0!./assets/js/jquery-2.1.4.js */ "./node_modules/raw-loader/index.js!./node_modules/babel-loader/lib/index.js?!./assets/js/jquery-2.1.4.js")+"\n\n// SCRIPT-LOADER FOOTER\n//# sourceURL=script:///home/osboxes/workspace/mlab.local.test/node_modules/babel-loader/lib/index.js%3F?ref--4-0!/home/osboxes/workspace/mlab.local.test/assets/js/jquery-2.1.4.js")

/***/ }),

/***/ "./node_modules/script-loader/index.js!./assets/js/jquery.form.js":
/*!***************************************************************!*\
  !*** ./node_modules/script-loader!./assets/js/jquery.form.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! !./node_modules/script-loader/addScript.js */ "./node_modules/script-loader/addScript.js")(__webpack_require__(/*! !./node_modules/raw-loader!./node_modules/babel-loader/lib??ref--4-0!./assets/js/jquery.form.js */ "./node_modules/raw-loader/index.js!./node_modules/babel-loader/lib/index.js?!./assets/js/jquery.form.js")+"\n\n// SCRIPT-LOADER FOOTER\n//# sourceURL=script:///home/osboxes/workspace/mlab.local.test/node_modules/babel-loader/lib/index.js%3F?ref--4-0!/home/osboxes/workspace/mlab.local.test/assets/js/jquery.form.js")

/***/ }),

/***/ "./node_modules/script-loader/index.js!./assets/js/jquery.qtip.nightly.js":
/*!***********************************************************************!*\
  !*** ./node_modules/script-loader!./assets/js/jquery.qtip.nightly.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! !./node_modules/script-loader/addScript.js */ "./node_modules/script-loader/addScript.js")(__webpack_require__(/*! !./node_modules/raw-loader!./node_modules/babel-loader/lib??ref--4-0!./assets/js/jquery.qtip.nightly.js */ "./node_modules/raw-loader/index.js!./node_modules/babel-loader/lib/index.js?!./assets/js/jquery.qtip.nightly.js")+"\n\n// SCRIPT-LOADER FOOTER\n//# sourceURL=script:///home/osboxes/workspace/mlab.local.test/node_modules/babel-loader/lib/index.js%3F?ref--4-0!/home/osboxes/workspace/mlab.local.test/assets/js/jquery.qtip.nightly.js")

/***/ }),

/***/ "./node_modules/script-loader/index.js!./assets/js/jquery.ui-1.11.4.js":
/*!********************************************************************!*\
  !*** ./node_modules/script-loader!./assets/js/jquery.ui-1.11.4.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! !./node_modules/script-loader/addScript.js */ "./node_modules/script-loader/addScript.js")(__webpack_require__(/*! !./node_modules/raw-loader!./node_modules/babel-loader/lib??ref--4-0!./assets/js/jquery.ui-1.11.4.js */ "./node_modules/raw-loader/index.js!./node_modules/babel-loader/lib/index.js?!./assets/js/jquery.ui-1.11.4.js")+"\n\n// SCRIPT-LOADER FOOTER\n//# sourceURL=script:///home/osboxes/workspace/mlab.local.test/node_modules/babel-loader/lib/index.js%3F?ref--4-0!/home/osboxes/workspace/mlab.local.test/assets/js/jquery.ui-1.11.4.js")

/***/ }),

/***/ "./node_modules/script-loader/index.js!./assets/js/jquery.uploadfile-4.0.11.js":
/*!****************************************************************************!*\
  !*** ./node_modules/script-loader!./assets/js/jquery.uploadfile-4.0.11.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! !./node_modules/script-loader/addScript.js */ "./node_modules/script-loader/addScript.js")(__webpack_require__(/*! !./node_modules/raw-loader!./node_modules/babel-loader/lib??ref--4-0!./assets/js/jquery.uploadfile-4.0.11.js */ "./node_modules/raw-loader/index.js!./node_modules/babel-loader/lib/index.js?!./assets/js/jquery.uploadfile-4.0.11.js")+"\n\n// SCRIPT-LOADER FOOTER\n//# sourceURL=script:///home/osboxes/workspace/mlab.local.test/node_modules/babel-loader/lib/index.js%3F?ref--4-0!/home/osboxes/workspace/mlab.local.test/assets/js/jquery.uploadfile-4.0.11.js")

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vYXNzZXRzL2pzL21sYWIuanMiLCJ3ZWJwYWNrOi8vLy4vYXNzZXRzL2pzL2Jvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvanF1ZXJ5LTIuMS40LmpzIiwid2VicGFjazovLy8uL2Fzc2V0cy9qcy9qcXVlcnkuZm9ybS5qcyIsIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvanF1ZXJ5LnF0aXAubmlnaHRseS5qcyIsIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvanF1ZXJ5LnVpLTEuMTEuNC5qcyIsIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvanF1ZXJ5LnVwbG9hZGZpbGUtNC4wLjExLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qcyIsIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvYm93c2VyLmpzPzRiZGUiLCJ3ZWJwYWNrOi8vLy4vYXNzZXRzL2pzL2pxdWVyeS0yLjEuNC5qcz82YTc1Iiwid2VicGFjazovLy8uL2Fzc2V0cy9qcy9qcXVlcnkuZm9ybS5qcz84MWU1Iiwid2VicGFjazovLy8uL2Fzc2V0cy9qcy9qcXVlcnkucXRpcC5uaWdodGx5LmpzPzRiNTkiLCJ3ZWJwYWNrOi8vLy4vYXNzZXRzL2pzL2pxdWVyeS51aS0xLjExLjQuanM/ODE2MSIsIndlYnBhY2s6Ly8vLi9hc3NldHMvanMvanF1ZXJ5LnVwbG9hZGZpbGUtNC4wLjExLmpzPzU4YzYiXSwibmFtZXMiOlsiJCIsInJlcXVpcmUiXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtEQUEwQyxnQ0FBZ0M7QUFDMUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnRUFBd0Qsa0JBQWtCO0FBQzFFO0FBQ0EseURBQWlELGNBQWM7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUF5QyxpQ0FBaUM7QUFDMUUsd0hBQWdILG1CQUFtQixFQUFFO0FBQ3JJO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FBQ3ZELHlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUFzRCwrREFBK0Q7O0FBRXJIO0FBQ0E7OztBQUdBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2xGQTtBQUNBLElBQU1BLENBQUMsR0FBR0MsbUJBQU8sQ0FBQywwR0FBRCxDQUFqQixDLENBRUE7QUFDQTs7O0FBRUFBLG1CQUFPLENBQUMsa0hBQUQsQ0FBUDs7QUFDQUEsbUJBQU8sQ0FBQyx3R0FBRCxDQUFQOztBQUNBQSxtQkFBTyxDQUFDLGtJQUFELENBQVAsQyxDQUNBOzs7QUFDQUEsbUJBQU8sQ0FBQyx3SEFBRCxDQUFQOztBQUNBQSxtQkFBTyxDQUFDLDhGQUFELENBQVAsQzs7Ozs7Ozs7Ozs7QUNYQSx1S0FBdUssaUdBQWlHLHVFQUF1RSwrQkFBK0IsR0FBRyx3QkFBd0IsNkZBQTZGLDJCQUEyQixxQ0FBcUMsb0NBQW9DLDJEQUEyRCxPQUFPLHdDQUF3QyxvQ0FBb0MsMkRBQTJELE9BQU8sMmFBQTJhLG9DQUFvQyxrQkFBa0Isb0pBQW9KLE9BQU8sc0NBQXNDLGtCQUFrQixtRUFBbUUsNEJBQTRCLDRCQUE0Qix1Q0FBdUMsU0FBUyxPQUFPLDBCQUEwQix5RUFBeUUsU0FBUyxPQUFPLHFDQUFxQyxrQkFBa0Isa0lBQWtJLE9BQU8sdUNBQXVDLGtCQUFrQiw2RkFBNkYsT0FBTywwQ0FBMEMsa0JBQWtCLG9JQUFvSSxPQUFPLHNCQUFzQixrQkFBa0IsMEpBQTBKLGtDQUFrQyw2Q0FBNkMsU0FBUyxPQUFPLGlDQUFpQyxrQkFBa0Isc0lBQXNJLE9BQU8scUNBQXFDLGtCQUFrQiw4SEFBOEgsT0FBTywwQ0FBMEMsa0JBQWtCLHlJQUF5SSxrQ0FBa0Msb0NBQW9DLCtCQUErQixTQUFTLE9BQU8sNkJBQTZCLGtCQUFrQixzSEFBc0gsT0FBTyxvQkFBb0Isa0JBQWtCLHdFQUF3RSxPQUFPLGdDQUFnQyxrQkFBa0IsNEhBQTRILE9BQU8seUVBQXlFLGtCQUFrQiw0SkFBNEosT0FBTyxvQ0FBb0Msa0JBQWtCLG1KQUFtSix5REFBeUQsT0FBTyw2QkFBNkIsa0JBQWtCLGlIQUFpSCxPQUFPLDhCQUE4QixrQkFBa0IsdUpBQXVKLE9BQU8sK0JBQStCLGtCQUFrQiwyRkFBMkYsT0FBTyxPQUFPLGtCQUFrQiwyR0FBMkcsT0FBTyw2SEFBNkgsZ0RBQWdELDBCQUEwQixxREFBcUQsNkNBQTZDLFNBQVMsT0FBTyxrREFBa0QsK0NBQStDLHlCQUF5QixzRkFBc0YsT0FBTyxxSEFBcUgsMkJBQTJCLE9BQU8sc0JBQXNCLDhCQUE4Qix1QkFBdUIsT0FBTyxzREFBc0Qsa0NBQWtDLGdGQUFnRixPQUFPLHNCQUFzQiwyRUFBMkUsc0RBQXNELE9BQU8sb0JBQW9CLHFFQUFxRSxPQUFPLHlCQUF5Qix1RUFBdUUsT0FBTyw4QkFBOEIsMkVBQTJFLE9BQU8sd0JBQXdCLDhEQUE4RCxPQUFPLHlCQUF5QixvRUFBb0UsT0FBTyx3QkFBd0IscUNBQXFDLE9BQU8saUZBQWlGLGlJQUFpSSwwQkFBMEIsT0FBTyxrSUFBa0ksMEJBQTBCLE9BQU8sb2JBQW9iLHFCQUFxQixPQUFPLDRSQUE0UixxQkFBcUIsT0FBTyxtQkFBbUIsc0JBQXNCLEtBQUssdUZBQXVGLDRDQUE0QyxxQkFBcUIsd0JBQXdCLE9BQU8seUNBQXlDLGdEQUFnRCxzQ0FBc0Msd0JBQXdCLFdBQVcsU0FBUyxPQUFPLHFCQUFxQixNQUFNLHVNQUF1TSxrQkFBa0IsR0FBRyxFQUFFLEM7Ozs7Ozs7Ozs7O0FDQTl3USx5Q0FBeUMsK0VBQStFLGtDQUFrQyxtQkFBbUIsR0FBRyxFQUFFLE9BQU8sa0NBQWtDLGtJQUFrSSxHQUFHLEVBQUUscUJBQXFCLEVBQUUsd1VBQXdVLHVJQUF1SSx3WUFBd1ksd0hBQXdILDBCQUEwQix3RUFBd0UsU0FBUyw0QkFBNEIsUUFBUSxLQUFLLE9BQU8sc0JBQXNCLEtBQUssK0NBQStDLGdGQUFnRiwwUEFBMFAsMkJBQTJCLDRCQUE0Qix3QkFBd0IsOEJBQThCLHdCQUF3Qix1Q0FBdUMsMkNBQTJDLHFCQUFxQixvT0FBb08sb05BQW9OLEtBQUssdVZBQXVWLGtDQUFrQyxNQUFNLHNDQUFzQyxpUUFBaVEsaUNBQWlDLE9BQU8sb0pBQW9KLHFNQUFxTSxPQUFPLDBKQUEwSiwyR0FBMkcsc0ZBQXNGLG1DQUFtQyw0REFBNEQsT0FBTyxtTkFBbU4saURBQWlELE9BQU8sb0NBQW9DLG1FQUFtRSw4Q0FBOEMsU0FBUyxHQUFHLE9BQU8sZ0NBQWdDLDZEQUE2RCxPQUFPLGdDQUFnQywwQkFBMEIsT0FBTyw4QkFBOEIsMkJBQTJCLE9BQU8sMkJBQTJCLHFFQUFxRSxrRUFBa0UsT0FBTyw0QkFBNEIseURBQXlELE9BQU8sc0tBQXNLLHNEQUFzRCx5SUFBeUksNEVBQTRFLDRFQUE0RSxzQkFBc0IseUVBQXlFLFlBQVksT0FBTyx5SkFBeUosb0JBQW9CLE9BQU8sb0ZBQW9GLHNCQUFzQixZQUFZLE9BQU8sY0FBYyxZQUFZLE9BQU8sa0dBQWtHLG9FQUFvRSwrQkFBK0IsaUNBQWlDLGlFQUFpRSx1QkFBdUIsYUFBYSwrSkFBK0osZ0NBQWdDLG9DQUFvQyw4REFBOEQsZUFBZSxPQUFPLG9FQUFvRSxlQUFlLDZHQUE2RyxnREFBZ0QsK0JBQStCLGtDQUFrQyxhQUFhLFdBQVcsU0FBUyxPQUFPLHNEQUFzRCxNQUFNLHFCQUFxQiw2T0FBNk8sNkJBQTZCLE9BQU8sK0JBQStCLDZDQUE2QyxpREFBaUQsT0FBTyxzRUFBc0UsaURBQWlELE9BQU8sMkNBQTJDLHVXQUF1VyxPQUFPLG1EQUFtRCx5UEFBeVAsdUJBQXVCLFNBQVMsOEZBQThGLHVCQUF1QixTQUFTLGtIQUFrSCx1REFBdUQsT0FBTyxtREFBbUQsaUJBQWlCLDZCQUE2Qix1QkFBdUIsU0FBUyxzQkFBc0IsT0FBTyxpQ0FBaUMsMEJBQTBCLDRCQUE0QixTQUFTLGdNQUFnTSxPQUFPLDZGQUE2RiwrQ0FBK0MsaUNBQWlDLHFCQUFxQixxTkFBcU4sd0RBQXdELCtCQUErQiw2RUFBNkUsV0FBVyxPQUFPLHNKQUFzSixXQUFXLFNBQVMsT0FBTyxzQ0FBc0Msb0tBQW9LLGtGQUFrRixPQUFPLGdEQUFnRCxtRkFBbUYsT0FBTyx5RkFBeUYsMkdBQTJHLHFCQUFxQix3QkFBd0Isa0JBQWtCLFlBQVksT0FBTyxtREFBbUQsc0NBQXNDLHNCQUFzQixlQUFlLGFBQWEsV0FBVyxPQUFPLDRCQUE0QixtREFBbUQsc0NBQXNDLHNCQUFzQixlQUFlLGFBQWEsV0FBVyxvRUFBb0UsT0FBTyx3QkFBd0Isa0JBQWtCLFlBQVksT0FBTyx1REFBdUQsc0NBQXNDLHNCQUFzQixlQUFlLGFBQWEsV0FBVyxPQUFPLDRCQUE0Qix1REFBdUQsc0NBQXNDLHNCQUFzQixlQUFlLGFBQWEsV0FBVyxTQUFTLHFCQUFxQixPQUFPLCtEQUErRCx3RUFBd0UsT0FBTywrRkFBK0YsZ0NBQWdDLDRCQUE0Qix5Q0FBeUMsdUVBQXVFLFdBQVcsT0FBTyxnQ0FBZ0MsV0FBVyxTQUFTLHFCQUFxQixPQUFPLGdEQUFnRCw2REFBNkQsT0FBTyw2Q0FBNkMsZ0ZBQWdGLGdCQUFnQixTQUFTLE9BQU8saUNBQWlDLFNBQVMsMkJBQTJCLHFCQUFxQixPQUFPLHFEQUFxRCw4SUFBOEksMEdBQTBHLFlBQVksT0FBTyxtREFBbUQscURBQXFELG1DQUFtQyxXQUFXLFNBQVMseUJBQXlCLE9BQU8sdUZBQXVGLG9JQUFvSSxtR0FBbUcsZ0JBQWdCLFlBQVksT0FBTywrQ0FBK0Msa0NBQWtDLDhCQUE4QixhQUFhLFdBQVcsa0RBQWtELE9BQU8sNEJBQTRCLCtDQUErQyxrQ0FBa0MsOEJBQThCLGFBQWEsV0FBVyxTQUFTLHNFQUFzRSxPQUFPLDhMQUE4TCw2QkFBNkIsOENBQThDLDRCQUE0Qix1QkFBdUIsbUJBQW1CLFNBQVMsOEtBQThLLDJCQUEyQixTQUFTLCtEQUErRCxvQ0FBb0MsZ0ZBQWdGLFVBQVUsb0pBQW9KLHFCQUFxQixPQUFPLDBLQUEwSyxFQUFFLHFKQUFxSixtRUFBbUUsS0FBSyxFQUFFLGlDQUFpQyxtU0FBbVMsNERBQTRELHFCQUFxQixPQUFPLDJDQUEyQyxvQkFBb0IsT0FBTyxxSEFBcUgsS0FBSyxnVEFBZ1QsK3NCQUErc0Isc0JBQXNCLDhCQUE4QixTQUFTLG1CQUFtQixPQUFPLGtIQUFrSCxtVEFBbVQsZ0RBQWdELGdCQUFnQixTQUFTLE9BQU8saUNBQWlDLHFCQUFxQixXQUFXLFNBQVMsb0JBQW9CLE9BQU8sdzRDQUF3NEMsdytCQUF3K0IsbTZCQUFtNkIsa0hBQWtILEtBQUssbVZBQW1WLElBQUksb0lBQW9JLDhDQUE4QywyWEFBMlgsT0FBTyxpTUFBaU0sc0JBQXNCLFFBQVEseURBQXlELHVGQUF1Riw0SEFBNEgsT0FBTyxZQUFZLGdCQUFnQiw2RkFBNkYsdURBQXVELFdBQVcsMkZBQTJGLHdEQUF3RCw4RUFBOEUsb0NBQW9DLFdBQVcsVUFBVSxPQUFPLDJEQUEyRCxzR0FBc0cseUZBQXlGLCtCQUErQixTQUFTLHdDQUF3QyxnQ0FBZ0Msb0NBQW9DLG1IQUFtSCx5QkFBeUIsU0FBUyx3Q0FBd0Msb0tBQW9LLHVFQUF1RSxtQ0FBbUMsaURBQWlELG1MQUFtTCw2SkFBNkosdUNBQXVDLG1DQUFtQyxtQkFBbUIsaUJBQWlCLE9BQU8saUNBQWlDLGlCQUFpQixlQUFlLE9BQU8sd0xBQXdMLHFDQUFxQyxpQ0FBaUMsaUJBQWlCLGVBQWUsNENBQTRDLHFCQUFxQiwwRUFBMEUsNkJBQTZCLDZDQUE2Qyw2REFBNkQscUVBQXFFLDZCQUE2QixhQUFhLFdBQVcseUZBQXlGLGdDQUFnQyxpQ0FBaUMscURBQXFELHdWQUF3ViwwQ0FBMEMseURBQXlELHVEQUF1RCxlQUFlLE9BQU8sa0RBQWtELGVBQWUsZ0RBQWdELGdDQUFnQyw2QkFBNkIsd0RBQXdELGVBQWUsbUdBQW1HLCtDQUErQyxhQUFhLGdDQUFnQyxtQkFBbUIsOEVBQThFLCtCQUErQixlQUFlLG9CQUFvQixVQUFVLDJCQUEyQixrREFBa0QsaUJBQWlCLGVBQWUsYUFBYSxXQUFXLFNBQVMsaUdBQWlHLE9BQU8sNEVBQTRFLHlCQUF5Qiw0T0FBNE8sc0JBQXNCLHNDQUFzQyw2SkFBNkosdUZBQXVGLFdBQVcsOENBQThDLFNBQVMsdUJBQXVCLE9BQU8sNEVBQTRFLFNBQVMsc0VBQXNFLDJCQUEyQixrQkFBa0IsT0FBTyxtRUFBbUUsU0FBUywrRkFBK0Ysa0RBQWtELGVBQWUsMkJBQTJCLFNBQVMsWUFBWSx1QkFBdUIsU0FBUyxVQUFVLDZFQUE2RSw0Q0FBNEMsV0FBVyxpREFBaUQsU0FBUyxPQUFPLHVGQUF1RixPQUFPLHlEQUF5RCxTQUFTLCtGQUErRixrRUFBa0UsdUJBQXVCLDRDQUE0QyxTQUFTLE9BQU8sd0VBQXdFLFFBQVEsbUJBQW1CLFFBQVEscUJBQXFCLE9BQU8sbUhBQW1ILCtKQUErSixzRUFBc0Usc0JBQXNCLFNBQVMsOENBQThDLHlDQUF5Qyw0QkFBNEIsd0JBQXdCLGFBQWEsV0FBVyxTQUFTLDRCQUE0QixPQUFPLHVGQUF1RixPQUFPLDBEQUEwRCxnQ0FBZ0MsaURBQWlELDBEQUEwRCxVQUFVLE9BQU8sbUZBQW1GLE9BQU8sMkRBQTJELGdDQUFnQyxpREFBaUQsbUZBQW1GLFVBQVUsT0FBTyx1RkFBdUYsU0FBUywyREFBMkQsaURBQWlELCtCQUErQix3REFBd0QsdUhBQXVILDRFQUE0RSw4Q0FBOEMsa0RBQWtELGVBQWUsYUFBYSxXQUFXLEVBQUUsU0FBUyxFQUFFLE9BQU8saUZBQWlGLGdCQUFnQiwyQkFBMkIsdUJBQXVCLHdHQUF3RywyRkFBMkYsT0FBTywrRUFBK0Usb0RBQW9ELGVBQWUsaURBQWlELFFBQVEsOEZBQThGLGdOQUFnTiwrRUFBK0UsUUFBUSxxR0FBcUcsZUFBZSxrRkFBa0YsT0FBTyxvR0FBb0csNkdBQTZHLDBJQUEwSSwwQkFBMEIsU0FBUywrQ0FBK0Msc0NBQXNDLGlDQUFpQyxvV0FBb1csdUdBQXVHLHNFQUFzRSxXQUFXLCtCQUErQiw0REFBNEQsV0FBVyxTQUFTLGtKQUFrSix1U0FBdVMsZ0NBQWdDLGtEQUFrRCxTQUFTLEVBQUUsaVBBQWlQLG1EQUFtRCx5REFBeUQsU0FBUyxFQUFFLHFHQUFxRywwUUFBMFEsZ0RBQWdELGtGQUFrRixTQUFTLEVBQUUsc0RBQXNELHNEQUFzRCxvRkFBb0YsaURBQWlELDRLQUE0SyxhQUFhLFlBQVksaURBQWlELDBEQUEwRCxvQ0FBb0MsMERBQTBELGNBQWMsWUFBWSxTQUFTLE9BQU8sNEhBQTRILGlEQUFpRCwwREFBMEQsb0NBQW9DLHlHQUF5RyxtREFBbUQsY0FBYyxZQUFZLFNBQVMsZ0dBQWdHLHNFQUFzRSxxREFBcUQsc0RBQXNELHdCQUF3QixpREFBaUQsV0FBVyxTQUFTLDRCQUE0QixpTkFBaU4sZ0VBQWdFLHlDQUF5Qyx3Q0FBd0MsK0JBQStCLGVBQWUsYUFBYSx5QkFBeUIsV0FBVywyQkFBMkIsVUFBVSwyR0FBMkcsK0JBQStCLDZEQUE2RCxXQUFXLFVBQVUsb1FBQW9RLCtWQUErVixpRUFBaUUsa0hBQWtILDJjQUEyYyxzV0FBc1csNkVBQTZFLGFBQWEsNEpBQTRKLHlGQUF5RixhQUFhLDhKQUE4SixxQ0FBcUMsYUFBYSxpUkFBaVIsMkNBQTJDLGFBQWEsOE9BQThPLDJDQUEyQyxhQUFhLFdBQVcsRUFBRSxpQ0FBaUMseUxBQXlMLHFEQUFxRCxpRUFBaUUsdUlBQXVJLHNFQUFzRSxhQUFhLHlOQUF5TiwwREFBMEQsYUFBYSwyR0FBMkcscUNBQXFDLFdBQVcsRUFBRSxTQUFTLDBNQUEwTSxpQ0FBaUMsaUxBQWlMLCtJQUErSSxnREFBZ0QsV0FBVyxFQUFFLFNBQVMsNEVBQTRFLHNGQUFzRix5S0FBeUssb09BQW9PLHFHQUFxRyx5S0FBeUssU0FBUyxvQkFBb0Isa0JBQWtCLHNDQUFzQyw0QkFBNEIsNEJBQTRCLGVBQWUsYUFBYSxXQUFXLHlCQUF5QixVQUFVLHdMQUF3TCwrREFBK0QsZ0NBQWdDLHFCQUFxQixXQUFXLDhKQUE4SiwwQkFBMEIsMkJBQTJCLFdBQVcsa09BQWtPLHlIQUF5SCw4S0FBOEssd0JBQXdCLGFBQWEsK0ZBQStGLHVCQUF1QixhQUFhLGdIQUFnSCxXQUFXLHdDQUF3QyxTQUFTLG9CQUFvQiwwRUFBMEUsZ0NBQWdDLHFCQUFxQixXQUFXLHdKQUF3Six3RkFBd0YsdUlBQXVJLGlFQUFpRSx3QkFBd0Isc0NBQXNDLFdBQVcsd0ZBQXdGLDBDQUEwQyw0QkFBNEIsV0FBVyxvQkFBb0IsMENBQTBDLDRCQUE0QixXQUFXLHVGQUF1RixnQkFBZ0IsV0FBVywyT0FBMk8sVUFBVSxtQkFBbUIsUUFBUSxvREFBb0Qsa0RBQWtELFFBQVEsd0RBQXdELDhGQUE4Riw0QkFBNEIsU0FBUywrR0FBK0csb0pBQW9KLGVBQWUsK0NBQStDLDJRQUEyUSx5QkFBeUIsYUFBYSxXQUFXLGFBQWEsU0FBUyxpRUFBaUUsUUFBUSxvREFBb0Qsb0dBQW9HLCtCQUErQixTQUFTLHlDQUF5QyxRQUFRLDZDQUE2Qyw4RkFBOEYsNEJBQTRCLFNBQVMsd1BBQXdQLG1MQUFtTCxRQUFRLHVDQUF1QywyRUFBMkUsUUFBUSwyRUFBMkUsVUFBVSxtRUFBbUUsaUZBQWlGLHVIQUF1SCw0REFBNEQsZ0NBQWdDLDZCQUE2Qix1Q0FBdUMsc0NBQXNDLHFDQUFxQyxhQUFhLFdBQVcseUJBQXlCLDZDQUE2QyxXQUFXLFNBQVMscUlBQXFJLHVCQUF1QixRQUFRLDBHQUEwRyxjQUFjLG9FQUFvRSwrRkFBK0YsMEJBQTBCLGdHQUFnRyw2RUFBNkUsV0FBVyxTQUFTLGdFQUFnRSxpTEFBaUwsb0NBQW9DLFdBQVcsT0FBTyw0RUFBNEUsTUFBTSwyQkFBMkIsbUNBQW1DLGFBQWEsV0FBVyxTQUFTLDZDQUE2QyxnQ0FBZ0MsU0FBUyxpRkFBaUYsUUFBUSxtQ0FBbUMsZ0pBQWdKLGlCQUFpQixvQkFBb0Isa0JBQWtCLGtFQUFrRSxtQkFBbUIsMENBQTBDLG1CQUFtQix1RUFBdUUsbUJBQW1CLCtDQUErQyxTQUFTLHFCQUFxQiwwQ0FBMEMsOERBQThELGlLQUFpSyx3Q0FBd0Msa0RBQWtELGFBQWEsdUNBQXVDLFdBQVcsNkNBQTZDLG1iQUFtYixxREFBcUQsc0VBQXNFLHVDQUF1QyxlQUFlLGtQQUFrUCx3RUFBd0UsK0NBQStDLHFCQUFxQixxQ0FBcUMsYUFBYSwyQkFBMkIsV0FBVywrQ0FBK0Msd0VBQXdFLHdEQUF3RCwwQkFBMEIsYUFBYSxnRUFBZ0Usc0RBQXNELGdFQUFnRSxxUkFBcVIsOEZBQThGLG1EQUFtRCxhQUFhLHdIQUF3SCxXQUFXLFNBQVMsa0JBQWtCLG1EQUFtRCx3RkFBd0YsNkRBQTZELDBCQUEwQixhQUFhLG9CQUFvQiwrRUFBK0UsY0FBYyxXQUFXLGlEQUFpRCx3REFBd0Qsd0tBQXdLLGdMQUFnTCxhQUFhLEVBQUUsV0FBVywyREFBMkQsb0NBQW9DLG1EQUFtRCxxQ0FBcUMsMkNBQTJDLGVBQWUsZ0NBQWdDLDRCQUE0QixlQUFlLCtCQUErQiw2ZUFBNmUsY0FBYyxXQUFXLHlFQUF5RSwwSkFBMEoscUdBQXFHLHVDQUF1QyxhQUFhLGtDQUFrQyxpWUFBaVksNkJBQTZCLGtGQUFrRiwrQkFBK0IsZ0NBQWdDLGdEQUFnRCxnR0FBZ0cscUNBQXFDLHVCQUF1QixxQkFBcUIsa0pBQWtKLG1CQUFtQixnQ0FBZ0MsaUJBQWlCLDJFQUEyRSxxR0FBcUcsc0lBQXNJLEVBQUUsaURBQWlELCtEQUErRCwwREFBMEQsbUVBQW1FLDZLQUE2SywrSUFBK0ksb0VBQW9FLDRCQUE0QixxQkFBcUIsbUJBQW1CLHVFQUF1RSxvRUFBb0Usb0NBQW9DLGtDQUFrQyw2RkFBNkYsT0FBTyx5TEFBeUwsMEdBQTBHLHlHQUF5Ryw2REFBNkQsMkJBQTJCLHVCQUF1Qiw0Q0FBNEMsOEJBQThCLHVCQUF1QixxQkFBcUIsbUJBQW1CLGlCQUFpQiwwRkFBMEYsaUZBQWlGLGVBQWUsY0FBYyxXQUFXLDBEQUEwRCxnYkFBZ2IscUxBQXFMLGtDQUFrQyxhQUFhLCtFQUErRSxzREFBc0QsbUhBQW1ILGdIQUFnSCwrQkFBK0Isa0RBQWtELDJEQUEyRCxpQkFBaUIsZUFBZSxxQkFBcUIseUNBQXlDLGdCQUFnQixhQUFhLHdCQUF3QixXQUFXLFNBQVMsbUJBQW1CLDZGQUE2RixzUUFBc1EsMkZBQTJGLG9IQUFvSCxzRUFBc0UsMENBQTBDLGlEQUFpRCxpQkFBaUIsZUFBZSxhQUFhLG1DQUFtQyw4QkFBOEIsaURBQWlELHVFQUF1RSxvQ0FBb0MsY0FBYyxXQUFXLHVEQUF1RCxvQ0FBb0MsdURBQXVELGNBQWMsV0FBVyx3REFBd0Qsc0RBQXNELG9DQUFvQyw4RkFBOEYsY0FBYyxXQUFXLHVoQkFBdWhCLHNHQUFzRywwREFBMEQsYUFBYSxzRUFBc0Usb0NBQW9DLDJCQUEyQixvQkFBb0IsNkhBQTZILG9EQUFvRCxtRkFBbUYsaUJBQWlCLGVBQWUseURBQXlELDZCQUE2QixjQUFjLFdBQVcseUVBQXlFLCtEQUErRCxxREFBcUQsV0FBVywwQ0FBMEMsb0NBQW9DLFdBQVcsNENBQTRDLGtKQUFrSixXQUFXLCtFQUErRSwyQ0FBMkMsV0FBVyxrREFBa0QsMENBQTBDLFdBQVcsZ0RBQWdELHFOQUFxTiwwR0FBMEcsV0FBVyxrREFBa0QsZ0pBQWdKLDRDQUE0QyxhQUFhLDRDQUE0QyxXQUFXLGlFQUFpRSxxSUFBcUksVUFBVSwrREFBK0QsMkJBQTJCLGdJQUFnSSxNQUFNLDJCQUEyQixzQ0FBc0MsNkJBQTZCLGVBQWUsYUFBYSwwQkFBMEIsV0FBVyw4Q0FBOEMsa0RBQWtELFdBQVcsOEVBQThFLCtDQUErQyxXQUFXLDRDQUE0QywrQ0FBK0MsV0FBVyw4Q0FBOEMsbURBQW1ELHlGQUF5RixXQUFXLDBDQUEwQyxxQkFBcUIsd1NBQXdTLFdBQVcsNkZBQTZGLHVCQUF1QixXQUFXLDhFQUE4RSxnQ0FBZ0MsV0FBVyxzRkFBc0YsaUVBQWlFLFdBQVcsOEVBQThFLHNCQUFzQixvQkFBb0IsWUFBWSxVQUFVLG1DQUFtQyxhQUFhLGtDQUFrQyxXQUFXLDZFQUE2RSxzQkFBc0Isb0JBQW9CLFlBQVksVUFBVSxtQ0FBbUMsYUFBYSxrQ0FBa0MsV0FBVyxzRkFBc0YsZ0VBQWdFLG9CQUFvQixVQUFVLEdBQUcsbUNBQW1DLGFBQWEsa0NBQWtDLFdBQVcsc0ZBQXNGLGdFQUFnRSxvQkFBb0IsY0FBYyxHQUFHLG1DQUFtQyxhQUFhLGtDQUFrQyxXQUFXLFVBQVUsUUFBUSxtREFBbUQsb0RBQW9ELCtHQUErRyxHQUFHLCtDQUErQyxPQUFPLG1CQUFtQiwrQ0FBK0MsR0FBRyxnREFBZ0QsT0FBTywwRUFBMEUsMkRBQTJELHlDQUF5QyxxRUFBcUUsd0xBQXdMLHVCQUF1QixpREFBaUQsU0FBUywyQkFBMkIsb0JBQW9CLG9DQUFvQyx5QkFBeUIseUZBQXlGLHdCQUF3QixtSEFBbUgsYUFBYSx1Q0FBdUMsV0FBVyw0QkFBNEIsa0VBQWtFLG9DQUFvQyx5QkFBeUIsaUpBQWlKLEVBQUUsZ0RBQWdELFdBQVcsb0RBQW9ELG9IQUFvSCxzQ0FBc0MsMkJBQTJCLHVHQUF1RyxFQUFFLGtEQUFrRCxhQUFhLFdBQVcsMkJBQTJCLGtCQUFrQixXQUFXLFNBQVMsZ1JBQWdSLFFBQVEscUNBQXFDLDhFQUE4RSxnQkFBZ0IsU0FBUyxPQUFPLHNDQUFzQyxTQUFTLDBCQUEwQixPQUFPLDJEQUEyRCw2SEFBNkgsNEhBQTRILG9DQUFvQywwREFBMEQsaURBQWlELGFBQWEsV0FBVyxTQUFTLDBGQUEwRiw2RkFBNkYsMEdBQTBHLHNDQUFzQyw0REFBNEQsa0RBQWtELDhCQUE4QixpQkFBaUIsZUFBZSxhQUFhLFdBQVcsT0FBTyxzQ0FBc0MsNERBQTRELGlFQUFpRSxFQUFFLDRHQUE0Ryx5SUFBeUksaUJBQWlCLE9BQU8sK0hBQStILDZCQUE2QiwwR0FBMEcsZ0NBQWdDLG1CQUFtQixpQkFBaUIsZUFBZSxhQUFhLFdBQVcsVUFBVSxPQUFPLDJDQUEyQyxvRUFBb0Usa0NBQWtDLHlCQUF5QixtREFBbUQsMkJBQTJCLGFBQWEsV0FBVyx3QkFBd0IsU0FBUyxlQUFlLE9BQU8sZ0VBQWdFLG9EQUFvRCxnQkFBZ0IsU0FBUyxPQUFPLGlEQUFpRCxTQUFTLHlCQUF5QixPQUFPLGlFQUFpRSxxSUFBcUksZ0JBQWdCLFNBQVMsT0FBTyxvQ0FBb0Msd0RBQXdELHNDQUFzQyw2QkFBNkIsNEJBQTRCLGVBQWUsYUFBYSxXQUFXLFNBQVMsOEJBQThCLE9BQU8saUdBQWlHLGlEQUFpRCw4Q0FBOEMsU0FBUyxtREFBbUQsNERBQTRELFNBQVMsc0VBQXNFLG0xQkFBbTFCLGtEQUFrRCx5REFBeUQsV0FBVyxtREFBbUQsaURBQWlELCtDQUErQyw0RkFBNEYsMkJBQTJCLG1DQUFtQyx5RUFBeUUsZUFBZSxhQUFhLFdBQVcsdUJBQXVCLDBDQUEwQywrQkFBK0IsOEhBQThILHNDQUFzQywrQkFBK0IsNkNBQTZDLCtIQUErSCxtQkFBbUIsaUJBQWlCLCtEQUErRCxlQUFlLGdIQUFnSCw2QkFBNkIsMkdBQTJHLHVEQUF1RCxpQkFBaUIsZUFBZSxhQUFhLHVFQUF1RSxPQUFPLDJIQUEySCwrQkFBK0IseURBQXlELGFBQWEsT0FBTyw4Q0FBOEMsYUFBYSxXQUFXLFNBQVMsRUFBRSxPQUFPLDRDQUE0QyxpYUFBaWEsdUNBQXVDLFNBQVMsdUZBQXVGLGtEQUFrRCxTQUFTLGlGQUFpRiw4TEFBOEwsMkVBQTJFLHFCQUFxQixTQUFTLEVBQUUsZ0JBQWdCLFNBQVMsT0FBTyx3REFBd0QsMEVBQTBFLFdBQVcsT0FBTyxpRkFBaUYsd0ZBQXdGLG1HQUFtRyxzQkFBc0IsU0FBUyxPQUFPLG9EQUFvRCx3QkFBd0IsaUJBQWlCLGVBQWUsZ09BQWdPLGlGQUFpRiwyS0FBMkssYUFBYSxxQ0FBcUMsV0FBVyxTQUFTLDBDQUEwQyxPQUFPLHlFQUF5RSx3TEFBd0wseWpCQUF5akIsNEJBQTRCLCtEQUErRCxXQUFXLHNQQUFzUCw4REFBOEQsd0NBQXdDLE9BQU8sb0NBQW9DLG9CQUFvQix3REFBd0Qsa0RBQWtELHFDQUFxQyx3QkFBd0IsaUJBQWlCLGVBQWUsZ0NBQWdDLHdDQUF3QyxlQUFlLGFBQWEsd0VBQXdFLDhHQUE4RywrQkFBK0IsZUFBZSxxRkFBcUYscUNBQXFDLGVBQWUsYUFBYSxXQUFXLDJFQUEyRSw4Q0FBOEMsa0JBQWtCLGtEQUFrRCwyREFBMkQsYUFBYSx5QkFBeUIsbUhBQW1ILDZCQUE2Qix5REFBeUQsc0RBQXNELG1CQUFtQixpQkFBaUIsZUFBZSxtSEFBbUgsYUFBYSwwRUFBMEUsMkxBQTJMLHlDQUF5QyxhQUFhLFdBQVcscUZBQXFGLG9DQUFvQyw2Q0FBNkMsV0FBVyw2QkFBNkIsVUFBVSxtRUFBbUUsT0FBTyxrR0FBa0csaUlBQWlJLHdCQUF3QixxSEFBcUgsdUNBQXVDLFdBQVcsNkJBQTZCLHlCQUF5QixpREFBaUQsb0NBQW9DLHVDQUF1QyxhQUFhLE9BQU8sMkNBQTJDLGFBQWEsV0FBVyxzSUFBc0kseUVBQXlFLFNBQVMsd0JBQXdCLFFBQVEsK0hBQStILGdCQUFnQiw0R0FBNEcsUUFBUSx5QkFBeUIsTUFBTSwyQkFBMkIsTUFBTSxtSUFBbUkseU9BQXlPLGdDQUFnQyx3R0FBd0csOEhBQThILDJLQUEySyw0R0FBNEcsNkJBQTZCLDZCQUE2QixvRkFBb0YscUJBQXFCLDJDQUEyQyxhQUFhLHFFQUFxRSxXQUFXLGdJQUFnSSx5QkFBeUIsOEJBQThCLHFGQUFxRixvQkFBb0IsYUFBYSwyQ0FBMkMsdU9BQXVPLGdIQUFnSCw2REFBNkQsa0NBQWtDLDRDQUE0QyxpQ0FBaUMsaUJBQWlCLHdCQUF3QixlQUFlLGFBQWEsV0FBVyxTQUFTLDBUQUEwVCx1QkFBdUIsUUFBUSx5SUFBeUksOEpBQThKLGlFQUFpRSx3TEFBd0wsc0lBQXNJLE9BQU8sRUFBRSxtTEFBbUwsNkNBQTZDLCtEQUErRCxPQUFPLElBQUksNEVBQTRFLHVCQUF1QixvRkFBb0YsV0FBVyxTQUFTLEVBQUUsT0FBTywySUFBMkkscUNBQXFDLHFEQUFxRCwrREFBK0QsT0FBTyxJQUFJLDJEQUEyRCxvRUFBb0UscUNBQXFDLFdBQVcsU0FBUyxFQUFFLE9BQU8sNkhBQTZILHNEQUFzRCxPQUFPLElBQUksMERBQTBELGtCQUFrQix5QkFBeUIsc0lBQXNJLFdBQVcsU0FBUyxFQUFFLE9BQU8sc0JBQXNCLEtBQUssU0FBUywyQkFBMkIsbUNBQW1DLDZDQUE2QyxzQ0FBc0MsaUNBQWlDLG1DQUFtQyxzQ0FBc0MsdURBQXVELHVEQUF1RCx1Q0FBdUMsNkdBQTZHLHlDQUF5Qyx5REFBeUQscUZBQXFGLFNBQVMsRUFBRSxPQUFPLGlDQUFpQyxzREFBc0QsNENBQTRDLFNBQVMsRUFBRSxPQUFPLDhDQUE4Qyx3Q0FBd0MseURBQXlELFNBQVMseURBQXlELE9BQU8sc0RBQXNELDBEQUEwRCxPQUFPLEVBQUUsS0FBSyxtREFBbUQsMEJBQTBCLGtCQUFrQix3Q0FBd0MsT0FBTyxpTEFBaUwsbUNBQW1DLE9BQU8sR0FBRyxNQUFNLHdCQUF3QixxQ0FBcUMseUZBQXlGLCtDQUErQyxxRUFBcUUsdUJBQXVCLFNBQVMsT0FBTyxtREFBbUQsNEJBQTRCLGVBQWUsYUFBYSxXQUFXLEdBQUcsU0FBUyxxQkFBcUIsU0FBUyxPQUFPLDhDQUE4QyxTQUFTLG9KQUFvSixtRkFBbUYsbUJBQW1CLE9BQU8sMENBQTBDLG1FQUFtRSxPQUFPLG9DQUFvQyxrRUFBa0UsT0FBTyxrQ0FBa0MsaVVBQWlVLE9BQU8sS0FBSyxFQUFFLHFaQUFxWixzQkFBc0IsNEVBQTRFLG9CQUFvQixPQUFPLHNFQUFzRSx1R0FBdUcsc0lBQXNJLFNBQVMsT0FBTyw0Q0FBNEMsU0FBUyw2R0FBNkcsaUVBQWlFLHVFQUF1RSwrUUFBK1EseUdBQXlHLHNDQUFzQywrSEFBK0gsOENBQThDLHVEQUF1RCxPQUFPLG1EQUFtRCxpQkFBaUIsZUFBZSxhQUFhLDBCQUEwQiw2QkFBNkIsT0FBTyxxREFBcUQsMklBQTJJLGlHQUFpRyw2QkFBNkIsYUFBYSxzQ0FBc0MscUNBQXFDLHdCQUF3QixXQUFXLHNDQUFzQyx1Q0FBdUMsd0RBQXdELHFHQUFxRyxPQUFPLDBEQUEwRCxTQUFTLGtDQUFrQyw4QkFBOEIsMENBQTBDLHdCQUF3QixvQkFBb0Isb0VBQW9FLHdDQUF3QywrSkFBK0osT0FBTyw4Q0FBOEMsMENBQTBDLHdDQUF3QyxPQUFPLGdEQUFnRCxNQUFNLDBHQUEwRyxvRUFBb0UscUtBQXFLLGlGQUFpRixtQkFBbUIsNENBQTRDLG9FQUFvRSw4REFBOEQsb0NBQW9DLHFEQUFxRCxvQkFBb0IsYUFBYSxpQ0FBaUMsV0FBVyxTQUFTLHlCQUF5QixPQUFPLDJDQUEyQyx5QkFBeUIsZ0JBQWdCLEdBQUcscUJBQXFCLCtDQUErQyw0QkFBNEIsV0FBVyxTQUFTLHlCQUF5QixPQUFPLEtBQUssRUFBRSxzQkFBc0IsaUNBQWlDLDBFQUEwRSx3Q0FBd0Msb0JBQW9CLGtCQUFrQixPQUFPLE9BQU8sb0RBQW9ELDBCQUEwQixhQUFhLFdBQVcsU0FBUyxFQUFFLE9BQU8sc0RBQXNELDJOQUEyTixnQkFBZ0IsT0FBTyxPQUFPLDZCQUE2Qix3QkFBd0Isd0JBQXdCLG9PQUFvTyxnQ0FBZ0Msb0JBQW9CLGFBQWEsV0FBVyxTQUFTLHVGQUF1RixPQUFPLGdHQUFnRyxrRUFBa0Usb0ZBQW9GLFNBQVMsa0VBQWtFLHFEQUFxRCxTQUFTLHNMQUFzTCxPQUFPLDZDQUE2QyxrR0FBa0csT0FBTyw0Q0FBNEMsK0ZBQStGLE9BQU8sS0FBSyxFQUFFLGtDQUFrQyx1REFBdUQsbUJBQW1CLEtBQUssbUJBQW1CLHFDQUFxQyxxQ0FBcUMsZ0VBQWdFLE9BQU8sd0NBQXdDLGdEQUFnRCxPQUFPLDREQUE0RCx1REFBdUQsT0FBTyxrQ0FBa0MsOENBQThDLE9BQU8sa0NBQWtDLGtEQUFrRCxPQUFPLHdDQUF3QyxpREFBaUQsT0FBTyx3Q0FBd0MscURBQXFELE9BQU8sc0RBQXNELHdEQUF3RCxPQUFPLHNEQUFzRCw0REFBNEQsT0FBTywwQ0FBMEMsb0RBQW9ELG9CQUFvQixPQUFPLDBDQUEwQywrQ0FBK0MsT0FBTywwQ0FBMEMseUVBQXlFLE9BQU8sS0FBSyx1QkFBdUIsb0RBQW9ELGtEQUFrRCw2Q0FBNkMsMkJBQTJCLFNBQVMsMkRBQTJELHFEQUFxRCxTQUFTLGdDQUFnQyxzRUFBc0UsbUNBQW1DLFdBQVcsK0ZBQStGLDhCQUE4QixXQUFXLFNBQVMseUNBQXlDLFFBQVEsS0FBSyxFQUFFLDRCQUE0QixxRUFBcUUseUhBQXlILDhDQUE4QyxzRUFBc0UsNEJBQTRCLE9BQU8sRUFBRSxvQkFBb0IsS0FBSyw4NUJBQTg1QixnT0FBZ08sV0FBVyxvb0JBQW9vQix3Q0FBd0Msc0JBQXNCLHVDQUF1Qyx3QkFBd0IsbUNBQW1DLHNCQUFzQixnQkFBZ0Isb0NBQW9DLGlCQUFpQiwyRkFBMkYsMkJBQTJCLDBEQUEwRCxXQUFXLFNBQVMseUJBQXlCLHFCQUFxQixzQkFBc0IsK0JBQStCLGtDQUFrQyxhQUFhLFdBQVcsbUJBQW1CLHNCQUFzQixXQUFXLE9BQU8sMkJBQTJCLFdBQVcsU0FBUyxPQUFPLG1EQUFtRCwrRkFBK0YscUJBQXFCLG9GQUFvRixtQ0FBbUMsbURBQW1ELDRDQUE0Qyw4Q0FBOEMsMERBQTBELG1DQUFtQyxtQkFBbUIsaUJBQWlCLHFEQUFxRCxtRUFBbUUsaUJBQWlCLGVBQWUsRUFBRSxhQUFhLGFBQWEsMkdBQTJHLHlDQUF5QyxnR0FBZ0csbUJBQW1CLGtDQUFrQywyQkFBMkIsYUFBYSxXQUFXLHdCQUF3QixTQUFTLDhFQUE4RSxxQkFBcUIsc0RBQXNELHdCQUF3Qix5RUFBeUUsc0NBQXNDLHdEQUF3RCw4Q0FBOEMsbUNBQW1DLG1CQUFtQiwrQ0FBK0Msa0NBQWtDLG1CQUFtQixpQkFBaUIsZUFBZSxhQUFhLEVBQUUsV0FBVyx3QkFBd0IsU0FBUywwS0FBMEssOEVBQThFLFNBQVMsK0VBQStFLG9CQUFvQiwyQkFBMkIsc0JBQXNCLFNBQVMsaUZBQWlGLDRDQUE0QyxzQkFBc0IsU0FBUyxrRUFBa0UsdUJBQXVCLFNBQVMsNkVBQTZFLDRCQUE0QiwwQkFBMEIsMkJBQTJCLFdBQVcsd0JBQXdCLFNBQVMsNERBQTRELHdCQUF3QixTQUFTLHVIQUF1SCwyQ0FBMkMsOEJBQThCLCtEQUErRCwyQkFBMkIsK0JBQStCLGFBQWEsT0FBTyx5QkFBeUIsYUFBYSxXQUFXLHdCQUF3QixTQUFTLDBGQUEwRix5Q0FBeUMsc0JBQXNCLFNBQVMsNEdBQTRHLDBCQUEwQixTQUFTLFFBQVEsb0JBQW9CLE1BQU0scUJBQXFCLHlDQUF5Qyx1VkFBdVYsbUNBQW1DLDBCQUEwQixXQUFXLHNDQUFzQyxxREFBcUQsd0JBQXdCLFdBQVcscUZBQXFGLGdDQUFnQyx3REFBd0QsdURBQXVELDZEQUE2RCwySEFBMkgsaUVBQWlFLDBFQUEwRSw4R0FBOEcsbUJBQW1CLE9BQU8sOEhBQThILG1CQUFtQixpQkFBaUIsRUFBRSxlQUFlLEVBQUUseUJBQXlCLGFBQWEsWUFBWSxXQUFXLGlLQUFpSyx5RUFBeUUsV0FBVyxTQUFTLDJCQUEyQixxRUFBcUUsZ0ZBQWdGLG1FQUFtRSwwRkFBMEYsOENBQThDLGtDQUFrQyxtRkFBbUYsMkNBQTJDLGdDQUFnQywrQ0FBK0MsV0FBVyx5RkFBeUYsMEZBQTBGLHdCQUF3QixZQUFZLDBEQUEwRCxTQUFTLEVBQUUsb0VBQW9FLGlEQUFpRCx3Q0FBd0MsU0FBUyx5Q0FBeUMsT0FBTyxzR0FBc0csdWpCQUF1akIsbUNBQW1DLCtCQUErQiw4RUFBOEUsOENBQThDLG9EQUFvRCxhQUFhLDBCQUEwQixxREFBcUQsYUFBYSxZQUFZLFNBQVMscUZBQXFGLDJDQUEyQyxzREFBc0QsNkNBQTZDLCtDQUErQyw4Q0FBOEMsa0JBQWtCLFlBQVksT0FBTyxrRkFBa0YsNktBQTZLLGFBQWEsT0FBTywwQkFBMEIsYUFBYSxXQUFXLFNBQVMscUZBQXFGLCtEQUErRCxTQUFTLG9DQUFvQyxPQUFPLEtBQUssRUFBRSxzREFBc0QsdUNBQXVDLCtEQUErRCxrQkFBa0IsTUFBTSxxQkFBcUIsb1NBQW9TLG1CQUFtQiw2QkFBNkIsU0FBUyxPQUFPLDZCQUE2QixTQUFTLE9BQU8seUVBQXlFLG9JQUFvSSxpQkFBaUIsU0FBUyxvRUFBb0UsNkhBQTZILGlCQUFpQixTQUFTLGtHQUFrRywyRUFBMkUscURBQXFELDBDQUEwQyxTQUFTLE9BQU8sS0FBSyxFQUFFLGdHQUFnRywyRUFBMkUsNkRBQTZELHFCQUFxQixLQUFLLDZDQUE2Qyx1QkFBdUIsc0NBQXNDLDRVQUE0VSx3SEFBd0gsU0FBUyxPQUFPLHFIQUFxSCxzSEFBc0gsU0FBUyxPQUFPLHNDQUFzQyxNQUFNLHlGQUF5RiwrTkFBK04sMEVBQTBFLGtFQUFrRSx5QkFBeUIsMEJBQTBCLG1FQUFtRSxTQUFTLDJCQUEyQixnQ0FBZ0MseUJBQXlCLDBDQUEwQyxxQkFBcUIsU0FBUyxxQkFBcUIsMkVBQTJFLGtDQUFrQyxzQkFBc0IsdURBQXVELE9BQU8sc0JBQXNCLGtEQUFrRCxvREFBb0QsY0FBYyxXQUFXLFNBQVMsbUJBQW1CLGdCQUFnQixTQUFTLE9BQU8sd0ZBQXdGLFdBQVcsU0FBUyxPQUFPLDJHQUEyRyxNQUFNLDZHQUE2RyxnUEFBZ1AsTUFBTSx1QkFBdUIsaU5BQWlOLE1BQU0sNkJBQTZCLG9CQUFvQixTQUFTLE9BQU8sRUFBRSxpREFBaUQsS0FBSyxtQkFBbUIscUNBQXFDLHNCQUFzQixnQ0FBZ0MsdU1BQXVNLG1CQUFtQixTQUFTLDZCQUE2QixzR0FBc0csOENBQThDLDhCQUE4Qix5RUFBeUUsd0NBQXdDLHlDQUF5Qyx1REFBdUQsb0ZBQW9GLFlBQVksOENBQThDLDZDQUE2QyxXQUFXLFNBQVMsaUVBQWlFLGtDQUFrQyxTQUFTLHdCQUF3QixPQUFPLDhDQUE4QyxtU0FBbVMsaUZBQWlGLDhCQUE4QixzQkFBc0IsYUFBYSxnQkFBZ0IsT0FBTyx1R0FBdUcsb0RBQW9ELDRFQUE0RSxPQUFPLGdDQUFnQyx1Q0FBdUMsYUFBYSxXQUFXLFNBQVMsdUJBQXVCLE9BQU8sc0NBQXNDLHFTQUFxUyxzREFBc0QsT0FBTyxtREFBbUQsbUJBQW1CLGtkQUFrZCx3Q0FBd0Msd0ZBQXdGLFNBQVMscVFBQXFRLG9MQUFvTCxPQUFPLDRDQUE0Qyw2SEFBNkgsa0NBQWtDLGtDQUFrQyxTQUFTLE9BQU8sZ0dBQWdHLDZhQUE2YSxXQUFXLE9BQU8sMENBQTBDLG9GQUFvRixrQ0FBa0MsYUFBYSxPQUFPLDBKQUEwSiwwRUFBMEUsYUFBYSxXQUFXLDRCQUE0Qix5QkFBeUIsa0NBQWtDLFdBQVcsU0FBUyxPQUFPLHlDQUF5QywwRUFBMEUsRUFBRSxPQUFPLHlDQUF5QyxrQ0FBa0MsaURBQWlELFNBQVMsT0FBTyxNQUFNLCtCQUErQiwrQkFBK0IsbWtCQUFta0IsWUFBWSxvREFBb0QsMENBQTBDLGVBQWUsMEpBQTBKLDBFQUEwRSx1Q0FBdUMsMkNBQTJDLGVBQWUsK1BBQStQLFdBQVcsYUFBYSxvR0FBb0csU0FBUyxPQUFPLDJCQUEyQixTQUFTLE9BQU8sb0JBQW9CLEtBQUsscUJBQXFCLHVDQUF1QyxrRUFBa0UsT0FBTywrQ0FBK0MsbURBQW1ELE9BQU8sb0RBQW9ELHFDQUFxQyxPQUFPLHNNQUFzTSxrREFBa0QsT0FBTyxzREFBc0QscUNBQXFDLE9BQU8sS0FBSyxFQUFFLHNCQUFzQix1Q0FBdUMsdUhBQXVILHFEQUFxRCw0QkFBNEIsdUNBQXVDLGtGQUFrRiwrQkFBK0IsNkJBQTZCLDBIQUEwSCx1Q0FBdUMsd0RBQXdELDJEQUEyRCxxREFBcUQsbUJBQW1CLGlCQUFpQixlQUFlLDREQUE0RCxhQUFhLFdBQVcsd0JBQXdCLFNBQVMsc0VBQXNFLHdDQUF3QyxxQ0FBcUMsV0FBVyxFQUFFLFNBQVMsZ0RBQWdELGtFQUFrRSw0WUFBNFksOEhBQThILHVDQUF1QywwQkFBMEIsYUFBYSxnSUFBZ0ksdUNBQXVDLDBCQUEwQixhQUFhLDBJQUEwSSx1Q0FBdUMsMEJBQTBCLGFBQWEsNEVBQTRFLFdBQVcsd0RBQXdELHlMQUF5TCxrT0FBa08sOE5BQThOLDhDQUE4QyxhQUFhLFdBQVcsRUFBRSxTQUFTLGlEQUFpRCxPQUFPLDZDQUE2QyxzQ0FBc0Msc0NBQXNDLFNBQVMsRUFBRSxPQUFPLEtBQUssRUFBRSxtQkFBbUIsK0NBQStDLGtCQUFrQixxQkFBcUIsOENBQThDLDRDQUE0QywyRkFBMkYsaURBQWlELDJFQUEyRSxhQUFhLE9BQU8sK0JBQStCLGFBQWEsV0FBVywrQkFBK0IsU0FBUyxPQUFPLDhDQUE4Qyw4QkFBOEIsNE1BQTRNLHFDQUFxQyxVQUFVLDRHQUE0Ryw2QkFBNkIsd0JBQXdCLFNBQVMsbUJBQW1CLDBJQUEwSSwwQ0FBMEMsV0FBVyx5RUFBeUUscUNBQXFDLFNBQVMsc0NBQXNDLDZCQUE2QixTQUFTLE9BQU8sbUlBQW1JLHdDQUF3Qyx3RUFBd0Usb0VBQW9FLDREQUE0RCxXQUFXLFVBQVUsRUFBRSxPQUFPLEtBQUssRUFBRSxzQkFBc0IseUNBQXlDLHVCQUF1QiwyQ0FBMkMsc0JBQXNCLHdCQUF3QixtQkFBbUIsU0FBUywwQ0FBMEMsNkNBQTZDLFNBQVMsb0VBQW9FLHFEQUFxRCw0RUFBNEUsaUVBQWlFLHVDQUF1QyxXQUFXLFNBQVMsRUFBRSxPQUFPLHdDQUF3QyxzQ0FBc0MscUNBQXFDLFNBQVMsRUFBRSxPQUFPLDhDQUE4Qyw4Q0FBOEMsT0FBTywwSkFBMEosOEtBQThLLDBCQUEwQixvREFBb0QsV0FBVyxVQUFVLDJDQUEyQyxxQkFBcUIsMkJBQTJCLFNBQVMsZ0NBQWdDLHVCQUF1QixrRUFBa0UsbUNBQW1DLG9CQUFvQixtQ0FBbUMsV0FBVyxTQUFTLG9CQUFvQixrQ0FBa0MsT0FBTyxLQUFLLEVBQUUsZ0VBQWdFLCtEQUErRCxrREFBa0QsOERBQThELDhFQUE4RSxzR0FBc0csTUFBTSxtREFBbUQsb0JBQW9CLGlMQUFpTCx1T0FBdU8sbURBQW1ELDBDQUEwQyw2QkFBNkIsZ01BQWdNLGlKQUFpSiw0RUFBNEUsS0FBSyxJQUFJLGlHQUFpRyxxREFBcUQsaU1BQWlNLDZCQUE2QixrQkFBa0IsS0FBSyw4QkFBOEIsbUJBQW1CLEtBQUssb0NBQW9DLFdBQVcsc0NBQXNDLE9BQU8sZUFBZSxLQUFLLDBMQUEwTCxnQkFBZ0IsZ0VBQWdFLHdRQUF3USwyR0FBMkcsaUJBQWlCLFNBQVMsd0dBQXdHLGdDQUFnQyx3Q0FBd0MsMENBQTBDLFNBQVMsNEdBQTRHLHVDQUF1QyxTQUFTLDJIQUEySCx3Q0FBd0MsU0FBUyxpREFBaUQsd0RBQXdELDJSQUEyUixZQUFZLFNBQVMsOEdBQThHLHlCQUF5Qix1QkFBdUIsb0RBQW9ELG1DQUFtQyw0REFBNEQsd0ZBQXdGLHFCQUFxQixXQUFXLDJJQUEySSwrSkFBK0osbUdBQW1HLG9GQUFvRixvVEFBb1QsZUFBZSxnR0FBZ0cseUNBQXlDLHVDQUF1QyxpTEFBaUwsMENBQTBDLGdFQUFnRSxlQUFlLGFBQWEsV0FBVyw4QkFBOEIsOENBQThDLDRDQUE0QyxvREFBb0QsYUFBYSxXQUFXLHNGQUFzRixvRUFBb0UsV0FBVyxPQUFPLHFDQUFxQyxXQUFXLHlIQUF5SCxTQUFTLE9BQU8sc0lBQXNJLHVSQUF1Uix5REFBeUQsaUJBQWlCLFNBQVMsMENBQTBDLG1GQUFtRix5QkFBeUIsdUJBQXVCLG9EQUFvRCxtQ0FBbUMsNERBQTRELDhGQUE4RixrQ0FBa0Msa0ZBQWtGLGFBQWEsdUJBQXVCLFdBQVcsdURBQXVELDhFQUE4RSx3Q0FBd0MsNkdBQTZHLHNFQUFzRSx5QkFBeUIsb0NBQW9DLGdRQUFnUSxvQ0FBb0MseUNBQXlDLHlDQUF5QyxlQUFlLHFDQUFxQyxxREFBcUQsZUFBZSxhQUFhLFdBQVcsbU9BQW1PLDBHQUEwRyw4REFBOEQsYUFBYSxrQ0FBa0MsV0FBVyxTQUFTLDRGQUE0RixpQ0FBaUMsNkNBQTZDLFNBQVMsT0FBTyxtRUFBbUUsOFVBQThVLDRDQUE0Qyx3R0FBd0csaUJBQWlCLFNBQVMscUNBQXFDLHlHQUF5RyxpQkFBaUIsU0FBUyx5Q0FBeUMsZ0NBQWdDLHlGQUF5RixvQ0FBb0MsNEJBQTRCLFNBQVMsNERBQTRELG1NQUFtTSw2Q0FBNkMsOEVBQThFLGlEQUFpRCx5SUFBeUksb0ZBQW9GLDhCQUE4Qiw4QkFBOEIsU0FBUyw0SkFBNEosdUdBQXVHLGdHQUFnRyxpQkFBaUIsU0FBUyw2SEFBNkgsNEhBQTRILG9EQUFvRCx1REFBdUQsaUNBQWlDLFdBQVcsa0JBQWtCLEtBQUssd0JBQXdCLGdDQUFnQyxzQkFBc0IsV0FBVyw0SUFBNEksMEVBQTBFLFdBQVcsU0FBUyxxREFBcUQsMkVBQTJFLHFFQUFxRSw0RUFBNEUsZ0RBQWdELHlCQUF5QixvQ0FBb0MsV0FBVywrREFBK0QsbUVBQW1FLG1EQUFtRCwyQ0FBMkMscUNBQXFDLGFBQWEsV0FBVyxTQUFTLDRCQUE0QixrSEFBa0gsMEhBQTBILDBRQUEwUSwrR0FBK0csMEJBQTBCLG9DQUFvQyxlQUFlLDhIQUE4SCwyQkFBMkIsaURBQWlELDBCQUEwQixtQ0FBbUMsZUFBZSxhQUFhLFdBQVcsU0FBUyw4QkFBOEIsT0FBTywyQ0FBMkMsNEdBQTRHLDZOQUE2TixpRkFBaUYsb0dBQW9HLG9DQUFvQyxvS0FBb0ssaUJBQWlCLFNBQVMsbUdBQW1HLHdCQUF3Qiw2REFBNkQsa0ZBQWtGLDZDQUE2QyxnQkFBZ0IsbUdBQW1HLHdRQUF3USwwQ0FBMEMsMENBQTBDLG9FQUFvRSx5REFBeUQsd0NBQXdDLHFEQUFxRCx5Q0FBeUMsMENBQTBDLGlCQUFpQixlQUFlLGFBQWEsV0FBVyxTQUFTLHlGQUF5RixpREFBaUQsU0FBUyw4QkFBOEIsT0FBTyxzREFBc0QseUxBQXlMLHlPQUF5TyxnQkFBZ0IsY0FBYyxnQ0FBZ0MsMkpBQTJKLDJCQUEyQiwyQkFBMkIsbUJBQW1CLE9BQU8seUNBQXlDLCtHQUErRyxtREFBbUQseUlBQXlJLGlCQUFpQixxQ0FBcUMsMENBQTBDLGlCQUFpQixlQUFlLHFDQUFxQyxtQ0FBbUMsZ0ZBQWdGLEVBQUUsZUFBZSxhQUFhLFdBQVcsU0FBUyxrR0FBa0csNkJBQTZCLHNGQUFzRixFQUFFLFNBQVMsOEJBQThCLE9BQU8sMk9BQTJPLGtCQUFrQiw0R0FBNEcseUVBQXlFLDJGQUEyRixXQUFXLHlCQUF5QixTQUFTLE9BQU8sb0JBQW9CLHVLQUF1SyxtR0FBbUcsMEhBQTBILDhEQUE4RCwyQ0FBMkMsaUNBQWlDLCtKQUErSiwySkFBMkosV0FBVyxvQ0FBb0MsY0FBYyxpSUFBaUksK0VBQStFLFdBQVcseUJBQXlCLFNBQVMsT0FBTyxpQ0FBaUMsb0NBQW9DLHVCQUF1QixTQUFTLDBPQUEwTyx5QkFBeUIsK0hBQStILFNBQVMsK0VBQStFLGdEQUFnRCx3QkFBd0IsdUJBQXVCLHlCQUF5Qiw0Q0FBNEMsU0FBUyxxRkFBcUYsNERBQTRELGtDQUFrQyxTQUFTLDJJQUEySSxpREFBaUQsU0FBUywrRUFBK0UsT0FBTyxpQkFBaUIsZUFBZSw4R0FBOEcsaUJBQWlCLG1IQUFtSCw2REFBNkQsMkJBQTJCLDJCQUEyQixhQUFhLFdBQVcsNkNBQTZDLGdCQUFnQix1Q0FBdUMsNERBQTRELDBCQUEwQiwyQkFBMkIsYUFBYSxXQUFXLDhDQUE4QyxpQkFBaUIsa0hBQWtILCtGQUErRiwyQkFBMkIsMkJBQTJCLGFBQWEsV0FBVyw4SEFBOEgsd0RBQXdELFdBQVcsU0FBUyx3QkFBd0Isc0RBQXNELGdMQUFnTCw2REFBNkQsYUFBYSxXQUFXLFNBQVMsT0FBTywrREFBK0QsbVJBQW1SLDRFQUE0RSxTQUFTLEVBQUUsdUJBQXVCLDhDQUE4QyxTQUFTLE9BQU8sOENBQThDLFNBQVMsdUNBQXVDLGlDQUFpQyxTQUFTLE9BQU8sTUFBTSwwREFBMEQscUNBQXFDLHNEQUFzRCxPQUFPLE1BQU0sNENBQTRDLGtHQUFrRyw0Q0FBNEMsT0FBTyxnREFBZ0QsaUNBQWlDLDZCQUE2QixpSEFBaUgsaU5BQWlOLHFCQUFxQixPQUFPLHdCQUF3QixPQUFPLGtGQUFrRixtQ0FBbUMsT0FBTyx5SEFBeUgsd0RBQXdELE1BQU0sa05BQWtOLGdMQUFnTCxtQ0FBbUMsNkNBQTZDLHNDQUFzQyw2QkFBNkIsU0FBUyxPQUFPLG9EQUFvRCxtQ0FBbUMsK0NBQStDLHVDQUF1Qyw4QkFBOEIsU0FBUyxPQUFPLHNFQUFzRSxtQ0FBbUMsd0RBQXdELGdEQUFnRCx1Q0FBdUMsU0FBUyxpQ0FBaUMsT0FBTyxNQUFNLHlIQUF5SCwwSUFBMEksd0JBQXdCLG9DQUFvQyx3RkFBd0Ysb0lBQW9JLDhPQUE4Tyw0Q0FBNEMsMkRBQTJELDZCQUE2QixXQUFXLHVCQUF1QixTQUFTLFFBQVEsS0FBSyxFQUFFLHdIQUF3SCxtQkFBbUIsNERBQTRELHdCQUF3QixnSkFBZ0osa0ZBQWtGLFVBQVUsdUNBQXVDLG1DQUFtQyx1R0FBdUcsOEJBQThCLHdEQUF3RCxhQUFhLDhEQUE4RCxXQUFXLDBDQUEwQywyR0FBMkcsOEJBQThCLDJEQUEyRCx5Q0FBeUMsYUFBYSxPQUFPLG1EQUFtRCxhQUFhLFdBQVcsVUFBVSxPQUFPLEVBQUUsS0FBSyx3QkFBd0IsOEVBQThFLHlCQUF5QixzRkFBc0YsNEZBQTRGLHlFQUF5RSxpQ0FBaUMsV0FBVyxpQ0FBaUMsNERBQTRELFdBQVcsd0JBQXdCLFNBQVMsMkNBQTJDLGtEQUFrRCxzQ0FBc0MsU0FBUyx1QkFBdUIsK0NBQStDLDREQUE0RCw2QkFBNkIsV0FBVyxPQUFPLHdEQUF3RCw0QkFBNEIsaUNBQWlDLFdBQVcsU0FBUyw2QkFBNkIsMkJBQTJCLFNBQVMsZ0JBQWdCLHNCQUFzQixTQUFTLDBCQUEwQixzQkFBc0IscUNBQXFDLGtHQUFrRyxpREFBaUQsWUFBWSx3SEFBd0gsU0FBUyx3Q0FBd0MsNERBQTRELFNBQVMsRUFBRSxPQUFPLHFEQUFxRCxxREFBcUQsT0FBTywrQ0FBK0MsNEJBQTRCLGlFQUFpRSxxRkFBcUYsK0tBQStLLHNCQUFzQixTQUFTLDhDQUE4Qyx5RUFBeUUsa0RBQWtELFdBQVcsd0JBQXdCLFNBQVMsdUVBQXVFLHFEQUFxRCwrQkFBK0IsU0FBUyw2QkFBNkIsMkJBQTJCLFNBQVMsd0NBQXdDLHlEQUF5RCxTQUFTLEVBQUUsT0FBTyw4Q0FBOEMsc0NBQXNDLGlEQUFpRCxTQUFTLEVBQUUsT0FBTyw0REFBNEQsMkJBQTJCLHFCQUFxQiw4REFBOEQsU0FBUyxPQUFPLEtBQUssRUFBRSwySkFBMkosc1lBQXNZLGlXQUFpVyx3REFBd0QsdUZBQXVGLDRCQUE0QiwySEFBMkgsbVBBQW1QLEtBQUsseUhBQXlILDZFQUE2RSxrQkFBa0IsS0FBSyxvQ0FBb0Msb0RBQW9ELG9CQUFvQiw2QkFBNkIsT0FBTyxPQUFPLHVDQUF1QyxPQUFPLG9CQUFvQixLQUFLLHFHQUFxRywyQ0FBMkMsY0FBYyxPQUFPLE9BQU8sK0dBQStHLE9BQU8sS0FBSywwQ0FBMEMscUVBQXFFLGtDQUFrQyxlQUFlLE9BQU8sdUZBQXVGLHlDQUF5QyxpREFBaUQsaUNBQWlDLHVCQUF1QixpQ0FBaUMsK0JBQStCLGtDQUFrQyxnREFBZ0QsT0FBTyxPQUFPLDREQUE0RCxhQUFhLFdBQVcsU0FBUyxPQUFPLDREQUE0RCx5Q0FBeUMsbUNBQW1DLFlBQVksc0NBQXNDLE9BQU8sS0FBSyxxQ0FBcUMsbUtBQW1LLDRHQUE0RyxLQUFLLHdFQUF3RSxpREFBaUQsa0pBQWtKLG1DQUFtQyxpR0FBaUcsZ0VBQWdFLDZDQUE2QyxPQUFPLEtBQUsscUJBQXFCLHFFQUFxRSxxTEFBcUwsNElBQTRJLHVJQUF1SSxxQ0FBcUMsK0NBQStDLE9BQU8sT0FBTyxzREFBc0QsV0FBVyxTQUFTLGtGQUFrRixrQ0FBa0Msc0RBQXNELHlEQUF5RCxpREFBaUQsT0FBTyxPQUFPLDhEQUE4RCxhQUFhLFdBQVcsT0FBTyx3Q0FBd0MsV0FBVyxTQUFTLDJGQUEyRix3Q0FBd0MsMkVBQTJFLFNBQVMsa0RBQWtELE9BQU8sa0ZBQWtGLG1PQUFtTyxnQkFBZ0IsT0FBTyxPQUFPLDBCQUEwQixxQ0FBcUMsb0ZBQW9GLGdMQUFnTCxrREFBa0QsOEJBQThCLHVEQUF1RCw0Q0FBNEMsT0FBTyxnRkFBZ0Ysc0hBQXNILHNEQUFzRCx5RkFBeUYsNkVBQTZFLDZCQUE2QixvQ0FBb0MsZUFBZSx3SkFBd0osOEVBQThFLHlGQUF5RixhQUFhLFdBQVcsU0FBUyx3RUFBd0UsY0FBYyxxQ0FBcUMsa01BQWtNLHFCQUFxQixXQUFXLGlFQUFpRSx1RkFBdUYsaUVBQWlFLCtCQUErQixXQUFXLG1EQUFtRCxrQkFBa0IsdUNBQXVDLHdEQUF3RCxtQ0FBbUMsZUFBZSxhQUFhLFdBQVcsU0FBUywwQkFBMEIsT0FBTyw2Q0FBNkMsZ0lBQWdJLGdCQUFnQixpQ0FBaUMsT0FBTyx3Q0FBd0MsMENBQTBDLHlEQUF5RCxnQ0FBZ0MsMkNBQTJDLHNDQUFzQyxvREFBb0QsaUZBQWlGLE9BQU8sZ0VBQWdFLG1CQUFtQixpQkFBaUIsZUFBZSwyQ0FBMkMsbUdBQW1HLGVBQWUsYUFBYSxXQUFXLG1HQUFtRyxTQUFTLE9BQU8sS0FBSyxFQUFFLHNCQUFzQixrQ0FBa0MsOENBQThDLDBGQUEwRixxRkFBcUYsdUNBQXVDLGFBQWEsV0FBVyxFQUFFLFNBQVMsaUNBQWlDLE9BQU8sa0NBQWtDLHlEQUF5RCxtRkFBbUYsd0RBQXdELHFDQUFxQyxXQUFXLFNBQVMsRUFBRSxPQUFPLG9DQUFvQyx5REFBeUQsbUZBQW1GLHdEQUF3RCx5REFBeUQsV0FBVyxTQUFTLEVBQUUsT0FBTyxrQ0FBa0MseURBQXlELGdDQUFnQyxxREFBcUQsV0FBVyxTQUFTLEVBQUUsT0FBTyxnQ0FBZ0MseURBQXlELGdDQUFnQyxpRUFBaUUsV0FBVyxTQUFTLEVBQUUsT0FBTyx1RkFBdUYsdUdBQXVHLGdCQUFnQiwyQkFBMkIsT0FBTyxpREFBaUQsMkNBQTJDLFdBQVcsa0NBQWtDLHdFQUF3RSxzREFBc0QsYUFBYSxnREFBZ0QsV0FBVyxTQUFTLHNCQUFzQixPQUFPLGdDQUFnQyxtQ0FBbUMsZ0JBQWdCLDBCQUEwQixPQUFPLG9DQUFvQyxxRkFBcUYsb0VBQW9FLFdBQVcsU0FBUyxzQkFBc0IsT0FBTyxnRUFBZ0Usc0VBQXNFLDBGQUEwRixxQ0FBcUMsc0VBQXNFLFNBQVMsRUFBRSxPQUFPLG1DQUFtQyw4Q0FBOEMsa0NBQWtDLG1EQUFtRCw2REFBNkQsa0NBQWtDLFdBQVcsME1BQTBNLDREQUE0RCxtQkFBbUIsb0JBQW9CLE9BQU8sT0FBTyxxQ0FBcUMsNkZBQTZGLHdEQUF3RCx5Q0FBeUMsaUJBQWlCLGVBQWUseUJBQXlCLGdGQUFnRixhQUFhLFdBQVcsdUJBQXVCLHVDQUF1QyxXQUFXLFNBQVMsaUNBQWlDLE9BQU8sNENBQTRDLCtCQUErQiw2SEFBNkgsZ0NBQWdDLHlDQUF5QyxzQkFBc0IseUNBQXlDLFdBQVcsU0FBUyxFQUFFLHNKQUFzSixPQUFPLDBDQUEwQywyQ0FBMkMsT0FBTyxvREFBb0QsMEVBQTBFLG1TQUFtUyxrTEFBa0wsNkNBQTZDLHFDQUFxQywrQkFBK0IsNkRBQTZELGFBQWEsNENBQTRDLFdBQVcsRUFBRSxTQUFTLGtCQUFrQixvRkFBb0Ysc0NBQXNDLG1EQUFtRCw2QkFBNkIsV0FBVyx3QkFBd0IsOEVBQThFLHdDQUF3QyxxTEFBcUwsT0FBTyxPQUFPLDhCQUE4QixxQ0FBcUMsc0RBQXNELDhGQUE4RixpTEFBaUwsaUJBQWlCLGVBQWUsZ0RBQWdELGFBQWEsK0JBQStCLDhEQUE4RCx1RUFBdUUsc0ZBQXNGLGdCQUFnQixPQUFPLGtDQUFrQyxxSUFBcUksaUNBQWlDLCtIQUErSCxnREFBZ0QscUJBQXFCLG1CQUFtQixPQUFPLG9GQUFvRixtQkFBbUIsaUJBQWlCLGVBQWUsYUFBYSxXQUFXLFNBQVMsc0JBQXNCLE9BQU8sS0FBSyxFQUFFLGlCQUFpQiwwSkFBMEosNkJBQTZCLDZDQUE2QyxvSUFBb0ksZ0JBQWdCLFdBQVcsT0FBTyx1REFBdUQsNkNBQTZDLHlIQUF5SCxTQUFTLHFDQUFxQyxRQUFRLEtBQUssRUFBRSx3Q0FBd0MscUVBQXFFLE9BQU8sNENBQTRDLE9BQU8saUhBQWlILG1mQUFtZiw4SUFBOEkscUJBQXFCLEtBQUsscUZBQXFGLE9BQU8sMkRBQTJELG1FQUFtRSx1QkFBdUIsK0NBQStDLHdHQUF3RywrS0FBK0ssMkhBQTJILHVDQUF1QyxzQkFBc0IsaURBQWlELDBCQUEwQixTQUFTLGlGQUFpRixPQUFPLHVCQUF1QixLQUFLLDhCQUE4QiwyRUFBMkUsZ0RBQWdELGlQQUFpUCwyRUFBMkUsT0FBTyxtREFBbUQsTUFBTSw2Q0FBNkMsaUdBQWlHLDZDQUE2QywyR0FBMkcsZ0VBQWdFLE9BQU8sdUJBQXVCLHlFQUF5RSx5Q0FBeUMsU0FBUyw2VkFBNlYsdUVBQXVFLG9DQUFvQyxvQ0FBb0MscUhBQXFILCtCQUErQiw2REFBNkQsb0NBQW9DLG9DQUFvQyxTQUFTLE9BQU8sdUhBQXVILEtBQUssa0RBQWtELDJGQUEyRiw2QkFBNkIsOEJBQThCLCtJQUErSSxtQkFBbUIsV0FBVyxnQkFBZ0IsNEhBQTRILFNBQVMsUUFBUSxLQUFLLG9CQUFvQiw2TUFBNk0seUJBQXlCLGVBQWUsT0FBTywrSUFBK0ksc0RBQXNELDZFQUE2RSwyQ0FBMkMsUUFBUSxTQUFTLE1BQU0sYUFBYSxlQUFlLDJCQUEyQixpQ0FBaUMsNE5BQTROLDBJQUEwSSwyQkFBMkIsNkJBQTZCLGNBQWMsY0FBYyxPQUFPLGtCQUFrQixZQUFZLFVBQVUsb0JBQW9CLDZCQUE2Qix1Q0FBdUMsMERBQTBELG1EQUFtRCwwREFBMEQsdUNBQXVDLE9BQU8sZ0pBQWdKLGdDQUFnQyxtREFBbUQsNlFBQTZRLG9DQUFvQyxXQUFXLDREQUE0RCwrQ0FBK0MseURBQXlELGFBQWEsMENBQTBDLFdBQVcsZ0VBQWdFLDZjQUE2YywwQkFBMEIsU0FBUyxRQUFRLFFBQVEsMkxBQTJMLDRCQUE0Qiw4QkFBOEIsY0FBYyxTQUFTLFNBQVMsWUFBWSx3RUFBd0Usc0NBQXNDLDJDQUEyQyxvRkFBb0YsMkNBQTJDLHVDQUF1Qyx1QkFBdUIsV0FBVyxTQUFTLEVBQUUsT0FBTyxLQUFLLElBQUksb0pBQW9KLGdEQUFnRCxtRkFBbUYscUNBQXFDLHlDQUF5QyxPQUFPLCtDQUErQyx3REFBd0QscUNBQXFDLE9BQU8sbUJBQW1CLE1BQU0sbVpBQW1aLHVGQUF1RiwrQkFBK0IseURBQXlELDREQUE0RCxzSEFBc0gsa0ZBQWtGLG9CQUFvQixPQUFPLDRKQUE0SixxQkFBcUIsd0NBQXdDLDhCQUE4QixzQkFBc0IsU0FBUyxPQUFPLHdCQUF3QixLQUFLLHlEQUF5RCwwQ0FBMEMsK0tBQStLLEtBQUssNkVBQTZFLDRQQUE0UCxjQUFjLE9BQU8sVUFBVSxxR0FBcUcsc0VBQXNFLFNBQVMsNEJBQTRCLCtHQUErRyw4RUFBOEUsV0FBVywyR0FBMkcseUZBQXlGLFdBQVcsU0FBUyxPQUFPLDJJQUEySSx5R0FBeUcseUZBQXlGLFdBQVcsU0FBUyxPQUFPLG1CQUFtQixLQUFLLG9EQUFvRCx5VEFBeVQscVFBQXFRLDBHQUEwRyx1Q0FBdUMsaUNBQWlDLFNBQVMsNEZBQTRGLHFCQUFxQixTQUFTLDJQQUEyUCxvRkFBb0YsT0FBTyxtTkFBbU4sS0FBSyx5Q0FBeUMsK0hBQStILGNBQWMsZ0JBQWdCLFdBQVcsK0JBQStCLDRCQUE0QixtQkFBbUIsU0FBUyw4REFBOEQscUNBQXFDLHFCQUFxQixnTEFBZ0wsc0NBQXNDLFdBQVcscU9BQXFPLGtHQUFrRyxXQUFXLFNBQVMsT0FBTyxrQ0FBa0Msa0RBQWtELGtHQUFrRyxXQUFXLFNBQVMsT0FBTywwSEFBMEgsZ0JBQWdCLFdBQVcsK0JBQStCLDRCQUE0QixtQkFBbUIsU0FBUyx3RkFBd0YsdUVBQXVFLFNBQVMsT0FBTyx3QkFBd0IsS0FBSyxxQkFBcUIseUlBQXlJLGtCQUFrQiw2Q0FBNkMsMkJBQTJCLGtIQUFrSCxnREFBZ0QsYUFBYSxXQUFXLFNBQVMsT0FBTyxnR0FBZ0cseVVBQXlVLG9IQUFvSCxzQ0FBc0MsNkdBQTZHLHNJQUFzSSxpQkFBaUIsU0FBUyx3TEFBd0wsMEdBQTBHLG9JQUFvSSxzRUFBc0UsZ0NBQWdDLDZIQUE2SCwrRUFBK0UsbURBQW1ELFdBQVcsOEdBQThHLG1CQUFtQixXQUFXLDJJQUEySSw0QkFBNEIsV0FBVyx1TEFBdUwsc0NBQXNDLFdBQVcsNkxBQTZMLGdDQUFnQyxXQUFXLFNBQVMsT0FBTywwS0FBMEssdUJBQXVCLFdBQVcsdUZBQXVGLFNBQVMsT0FBTyxxREFBcUQsZ0dBQWdHLHFLQUFxSywwSEFBMEgsc0dBQXNHLDZDQUE2QyxTQUFTLHNHQUFzRywyQ0FBMkMsU0FBUywyR0FBMkcseUNBQXlDLFNBQVMsc0hBQXNILGdDQUFnQywwRUFBMEUsU0FBUyxxQkFBcUIsT0FBTyxLQUFLLEVBQUUsNkRBQTZELCtCQUErQixrREFBa0QseUJBQXlCLG1TQUFtUyx5REFBeUQsYUFBYSx3Q0FBd0MsV0FBVyxTQUFTLGdEQUFnRCxnREFBZ0QsZ0xBQWdMLFNBQVMsUUFBUSxLQUFLLEVBQUUsaUlBQWlJLHFCQUFxQixrQ0FBa0MsZ0RBQWdELG1DQUFtQyxPQUFPLEtBQUssRUFBRSwyRUFBMkUsbUVBQW1FLDZCQUE2QiwwQ0FBMEMsd0NBQXdDLCtDQUErQyxzSUFBc0ksa0JBQWtCLE9BQU8sT0FBTyw0RkFBNEYsV0FBVyw0QkFBNEIsU0FBUyxRQUFRLG9DQUFvQyxpRUFBaUUsT0FBTyxLQUFLLEVBQUUsc0JBQXNCLHNDQUFzQywwREFBMEQsNkRBQTZELHFCQUFxQix1Q0FBdUMscUNBQXFDLDhCQUE4QixvQkFBb0IsU0FBUyxPQUFPLHNFQUFzRSxhQUFhLHlCQUF5QixXQUFXLGtHQUFrRyxTQUFTLHFDQUFxQyxPQUFPLDhCQUE4QixvQ0FBb0MsT0FBTyw4QkFBOEIsOEJBQThCLE9BQU8sdUNBQXVDLDJDQUEyQyxtREFBbUQsU0FBUyx3Q0FBd0MsK0JBQStCLGdDQUFnQyxXQUFXLE9BQU8sZ0NBQWdDLFdBQVcsU0FBUyxFQUFFLE9BQU8sS0FBSyxFQUFFLHdEQUF3RCx3RUFBd0UsS0FBSywyQkFBMkIsdUJBQXVCLDRGQUE0Rix5QkFBeUIseUJBQXlCLDBDQUEwQywrQkFBK0IsMkNBQTJDLHVCQUF1QixxRUFBcUUsT0FBTyw0QkFBNEIsK0NBQStDLHlGQUF5RixPQUFPLG1DQUFtQyxpRUFBaUUsc0NBQXNDLCtIQUErSCxTQUFTLE9BQU8scUNBQXFDLFNBQVMsa0VBQWtFLGtDQUFrQyw0REFBNEQsU0FBUyxtQ0FBbUMsMEJBQTBCLFNBQVMsT0FBTyw2Q0FBNkMsU0FBUyxzQkFBc0IsT0FBTyxNQUFNLHFEQUFxRCx1QkFBdUIsaUJBQWlCLGtDQUFrQyxxQkFBcUIsZ0hBQWdILDBDQUEwQyxXQUFXLHVOQUF1Tix3SUFBd0ksa0lBQWtJLFNBQVMsbUNBQW1DLDBNQUEwTSw4Q0FBOEMsV0FBVyx1SEFBdUgseUVBQXlFLFdBQVcsT0FBTywrQ0FBK0MsV0FBVyxTQUFTLE9BQU8sTUFBTSxtSkFBbUosZ0NBQWdDLDJEQUEyRCw2Q0FBNkMsU0FBUyxPQUFPLE1BQU0scUJBQXFCLGtDQUFrQyxpQkFBaUIsT0FBTyxpQ0FBaUMsK0NBQStDLE9BQU8sTUFBTSxxQ0FBcUMsOERBQThELDRQQUE0UCxzQ0FBc0MsdWNBQXVjLDJDQUEyQyxpRkFBaUYscUZBQXFGLDBGQUEwRixnQkFBZ0IsaU5BQWlOLHdEQUF3RCx5REFBeUQsZ0tBQWdLLG9GQUFvRixTQUFTLG1EQUFtRCx1REFBdUQsNEJBQTRCLG9KQUFvSixTQUFTLHVCQUF1QixPQUFPLE9BQU8seUZBQXlGLDhCQUE4QiwwQkFBMEIsT0FBTyxFQUFFLGtDQUFrQyxLQUFLLGtHQUFrRyxtREFBbUQsNEJBQTRCLDhLQUE4SyxjQUFjLE9BQU8seUJBQXlCLDZCQUE2QixzRUFBc0UsT0FBTywyQkFBMkIsMkNBQTJDLE9BQU8scUJBQXFCLEtBQUssb0RBQW9ELCtJQUErSSxjQUFjLGdCQUFnQixXQUFXLHFFQUFxRSxpRUFBaUUsU0FBUyxPQUFPLEtBQUssb0RBQW9ELHNOQUFzTixzSUFBc0ksMERBQTBELGlEQUFpRCx1Q0FBdUMsNkJBQTZCLHFDQUFxQyw0Q0FBNEMsa0NBQWtDLHdCQUF3QixhQUFhLFlBQVksU0FBUywyQkFBMkIsaUNBQWlDLDJHQUEyRyw2QkFBNkIsdURBQXVELGlDQUFpQyxhQUFhLFdBQVcsRUFBRSxTQUFTLEVBQUUsT0FBTyxpSEFBaUgsaVNBQWlTLHlMQUF5TCx3TEFBd0wsd0ZBQXdGLDJDQUEyQyxTQUFTLE9BQU8sNEJBQTRCLG9DQUFvQyxpQ0FBaUMsNENBQTRDLDZDQUE2Qyw2Q0FBNkMsU0FBUyxFQUFFLE9BQU8saURBQWlELDRCQUE0QixxQ0FBcUMsNkJBQTZCLGtEQUFrRCwyREFBMkQsZ09BQWdPLDRCQUE0QixhQUFhLE9BQU8sdUJBQXVCLGFBQWEsV0FBVyxnRkFBZ0YsZ0ZBQWdGLE9BQU8sOEJBQThCLFNBQVMsT0FBTywwQ0FBMEMsdUJBQXVCLHVDQUF1QyxxQ0FBcUMsV0FBVyxTQUFTLE9BQU8sMERBQTBELEVBQUUsU0FBUyxnR0FBZ0csb0NBQW9DLFNBQVMsdUJBQXVCLDhCQUE4QixTQUFTLE9BQU8saUNBQWlDLGdDQUFnQyxXQUFXLEVBQUUsU0FBUyxpQ0FBaUMsbUJBQW1CLDZDQUE2QyxnQ0FBZ0MsaURBQWlELFdBQVcsU0FBUyxFQUFFLDhCQUE4Qix1RUFBdUUsc0NBQXNDLHlDQUF5QywyQkFBMkIsc0NBQXNDLDhFQUE4RSxhQUFhLFdBQVcsU0FBUyx3RkFBd0YsNEZBQTRGLGdDQUFnQyxPQUFPLEtBQUssaURBQWlELDRDQUE0QyxrRkFBa0YsdUNBQXVDLHFDQUFxQyw2QkFBNkIsc0NBQXNDLDRCQUE0QiwwQ0FBMEMsU0FBUywrQkFBK0IsOEJBQThCLDhCQUE4QixTQUFTLHdDQUF3Qyw2Q0FBNkMsc0NBQXNDLDZCQUE2Qiw4SkFBOEosb0NBQW9DLDBDQUEwQyw0Q0FBNEMsYUFBYSxXQUFXLFNBQVMsT0FBTyx1Q0FBdUMsU0FBUyxPQUFPLEtBQUsscURBQXFELGdLQUFnSyw4RUFBOEUsT0FBTyxvQ0FBb0Msc0JBQXNCLHVCQUF1QixTQUFTLHFaQUFxWixnQkFBZ0IsZ0JBQWdCLFdBQVcsK0NBQStDLFNBQVMscUVBQXFFLHNDQUFzQywyQkFBMkIsU0FBUyxPQUFPLGtEQUFrRCx1QkFBdUIsU0FBUyxPQUFPLHlDQUF5QyxrREFBa0QsaURBQWlELDJCQUEyQixTQUFTLHlPQUF5TyxpSUFBaUksdUNBQXVDLHVCQUF1QixTQUFTLHVDQUF1QyxtTUFBbU0sMEJBQTBCLHdCQUF3QixXQUFXLDJCQUEyQixrQkFBa0IsZ0JBQWdCLFdBQVcsMkNBQTJDLFdBQVcsMENBQTBDLDhDQUE4Qyw2REFBNkQsV0FBVyxPQUFPLDREQUE0RCxXQUFXLHdCQUF3QixTQUFTLE9BQU8sb0NBQW9DLHdEQUF3RCxjQUFjLGdCQUFnQixXQUFXLHlGQUF5Rix1QkFBdUIsd0JBQXdCLFNBQVMsT0FBTyxrREFBa0Qsc0RBQXNELG1EQUFtRCxPQUFPLDZDQUE2QyxxRkFBcUYsR0FBRyx1TUFBdU0sS0FBSyxtREFBbUQsa0RBQWtELHVDQUF1QywyQkFBMkIsMEJBQTBCLFNBQVMsT0FBTyxxQ0FBcUMsU0FBUywyRUFBMkUsZ0JBQWdCLGdCQUFnQixXQUFXLDhCQUE4QixnREFBZ0QsMkNBQTJDLFNBQVMsT0FBTyx5REFBeUQsc0JBQXNCLGdEQUFnRCxTQUFTLE9BQU8sNkNBQTZDLFNBQVMsT0FBTyxLQUFLLEVBQUUsbURBQW1ELHlFQUF5RSxZQUFZLHlMQUF5TCwyTEFBMkwsNkdBQTZHLDJCQUEyQixPQUFPLDZDQUE2QyxvQ0FBb0MseUNBQXlDLDZCQUE2QixTQUFTLDBCQUEwQiwwQ0FBMEMsU0FBUyxRQUFRLG1CQUFtQixNQUFNLHdCQUF3Qiw0REFBNEQsdUxBQXVMLDhCQUE4QiwyQkFBMkIsT0FBTyxpRUFBaUUsNEpBQTRKLGdJQUFnSSxpQkFBaUIsa0hBQWtILDRCQUE0QixXQUFXLFVBQVUsMkNBQTJDLGdIQUFnSCxPQUFPLHVEQUF1RCxtREFBbUQsZ0NBQWdDLDRCQUE0Qix3QkFBd0IsVUFBVSwyQ0FBMkMsK0JBQStCLDRCQUE0QiwyQkFBMkIsU0FBUyw2Q0FBNkMseUNBQXlDLFNBQVMsd0NBQXdDLHVLQUF1Syx3QkFBd0Isa0RBQWtELHFDQUFxQyxhQUFhLFdBQVcsT0FBTyxpQ0FBaUMsd0VBQXdFLHVDQUF1QyxlQUFlLGFBQWEsV0FBVyx1Q0FBdUMsU0FBUyxHQUFHLGdHQUFnRywrQ0FBK0MsOEJBQThCLHNDQUFzQyxhQUFhLFdBQVcsc09BQXNPLHVDQUF1QyxXQUFXLFNBQVMsRUFBRSxPQUFPLHNDQUFzQyw2QkFBNkIsZ0NBQWdDLFNBQVMsd0NBQXdDLGlQQUFpUCx3RUFBd0Usa0VBQWtFLHNDQUFzQyx3Q0FBd0MsV0FBVyw0RkFBNEYsU0FBUyxHQUFHLDhFQUE4RSw0Q0FBNEMsc0NBQXNDLGFBQWEsV0FBVyx5RkFBeUYsZ0JBQWdCLFdBQVcsc0RBQXNELDZDQUE2QyxhQUFhLFdBQVcsNERBQTRELFNBQVMsRUFBRSxPQUFPLEtBQUssRUFBRSxzRUFBc0Usa0NBQWtDLDhEQUE4RCx1SkFBdUosUUFBUSxLQUFLLEVBQUUsK0RBQStELG9IQUFvSCxnQ0FBZ0MsaUJBQWlCLGdDQUFnQyxvQkFBb0Isa0NBQWtDLEtBQUssMEJBQTBCLDREQUE0RCw0REFBNEQsUUFBUSxLQUFLLEVBQUUsdUJBQXVCLG9DQUFvQyxpRUFBaUUsMkJBQTJCLGNBQWMsbUJBQW1CLE9BQU8sMEJBQTBCLGlHQUFpRyxnQ0FBZ0MsU0FBUyxPQUFPLDZCQUE2Qix5QkFBeUIsT0FBTywwQkFBMEIsTUFBTSwwQ0FBMEMsZ0NBQWdDLHNCQUFzQiwwQkFBMEIsT0FBTyxPQUFPLDRCQUE0QixPQUFPLE1BQU0sOEJBQThCLHFDQUFxQyxxQkFBcUIsa0VBQWtFLE9BQU8sTUFBTSxvQ0FBb0MsNkJBQTZCLHFCQUFxQixNQUFNLDBCQUEwQiwrRUFBK0UsMktBQTJLLCtEQUErRCw0QkFBNEIsc0RBQXNELDZDQUE2QyxvQ0FBb0MsZ0NBQWdDLFVBQVUsT0FBTyxFQUFFLE1BQU0sb0JBQW9CLGlMQUFpTCxnQ0FBZ0MseUlBQXlJLGdJQUFnSSxtSUFBbUksMENBQTBDLDhIQUE4SCwwQkFBMEIsNkJBQTZCLGlEQUFpRCxLQUFLLElBQUksZ0ZBQWdGLHNCQUFzQix3Q0FBd0MsNEVBQTRFLE9BQU8sOENBQThDLHNDQUFzQyx3Q0FBd0MsU0FBUyxFQUFFLE9BQU8sS0FBSyxFQUFFLG1CQUFtQiw4Q0FBOEMsb0VBQW9FLG9JQUFvSSxpQkFBaUIsU0FBUyxvSEFBb0gsZ0RBQWdELFNBQVMsd0lBQXdJLG9DQUFvQyxzR0FBc0csU0FBUyxvQ0FBb0MsK0JBQStCLDBDQUEwQyxXQUFXLDRGQUE0Rix1QkFBdUIsV0FBVyxPQUFPLGtEQUFrRCx5QkFBeUIsV0FBVyxTQUFTLGdGQUFnRixxQkFBcUIsU0FBUyxPQUFPLDZDQUE2QyxtSEFBbUgsU0FBUyxPQUFPLHFEQUFxRCxnSEFBZ0gsaURBQWlELHlDQUF5QyxvREFBb0QsMkdBQTJHLHlGQUF5RixhQUFhLHlDQUF5QyxXQUFXLFNBQVMsT0FBTyxtQkFBbUIsZUFBZSwwQ0FBMEMsaUdBQWlHLG1DQUFtQyxpREFBaUQsMEJBQTBCLGlDQUFpQyxlQUFlLDZCQUE2QixhQUFhLFdBQVcsU0FBUyxPQUFPLEtBQUssRUFBRSxrREFBa0QsNENBQTRDLDhCQUE4QixnR0FBZ0csU0FBUyxPQUFPLHdDQUF3QyxTQUFTLHNCQUFzQixPQUFPLE1BQU0sa0ZBQWtGLHdEQUF3RCx5REFBeUQsd0JBQXdCLHVCQUF1Qiw2SEFBNkgsaUNBQWlDLDhFQUE4RSxvQ0FBb0MsU0FBUyxxQkFBcUIsUUFBUSxLQUFLLEVBQUUsMkRBQTJELHNCQUFzQix3Q0FBd0MsNEVBQTRFLE9BQU8sOENBQThDLHNDQUFzQyxvREFBb0QsU0FBUyxFQUFFLE9BQU8sS0FBSyxFQUFFLG1CQUFtQixnQkFBZ0Isb0VBQW9FLCtDQUErQyx1RkFBdUYsb0lBQW9JLGlCQUFpQixTQUFTLHlEQUF5RCx1QkFBdUIsb0ZBQW9GLHlDQUF5QyxTQUFTLG9DQUFvQyw0SEFBNEgsU0FBUyxPQUFPLHdHQUF3RyxTQUFTLE9BQU8sbUJBQW1CLG1CQUFtQixtQ0FBbUMsdUhBQXVILFdBQVcsU0FBUyxPQUFPLEtBQUssRUFBRSxpQ0FBaUMsbUNBQW1DLGlDQUFpQyx1Q0FBdUMsOENBQThDLDRDQUE0QyxXQUFXLHdCQUF3QixTQUFTLFFBQVEsS0FBSywwTEFBMEwsZ0RBQWdELEtBQUssRUFBRSxtQ0FBbUMsc0JBQXNCLDBDQUEwQyx1TkFBdU4seUNBQXlDLHlDQUF5Qyx1RUFBdUUsV0FBVyxFQUFFLFNBQVMsd0JBQXdCLDRJQUE0SSxrQkFBa0IsU0FBUyxPQUFPLDJCQUEyQiw0SEFBNEgsd0JBQXdCLG9CQUFvQiw4Q0FBOEMsNkRBQTZELHVDQUF1QyxpQkFBaUIsZUFBZSx5R0FBeUcsb0RBQW9ELDRDQUE0QyxlQUFlLGFBQWEsV0FBVyxTQUFTLHNCQUFzQixPQUFPLGlEQUFpRCxpUEFBaVAseUNBQXlDLHlDQUF5QywwRUFBMEUsV0FBVyxFQUFFLFNBQVMsd0JBQXdCLDJEQUEyRCxrQkFBa0IsU0FBUyxPQUFPLDJCQUEyQixrTUFBa00sd0JBQXdCLG9CQUFvQiw4Q0FBOEMsMEdBQTBHLGtFQUFrRSxpQkFBaUIsZUFBZSx3SEFBd0gsb0RBQW9ELDRDQUE0QyxlQUFlLGFBQWEsV0FBVyxTQUFTLHNCQUFzQixPQUFPLDJEQUEyRCxrQ0FBa0MsdUVBQXVFLDJFQUEyRSxTQUFTLHlDQUF5Qyx5Q0FBeUMsOEZBQThGLFdBQVcsRUFBRSxTQUFTLHdDQUF3QyxvQ0FBb0MsMExBQTBMLG1EQUFtRCw4R0FBOEcsNENBQTRDLGVBQWUsT0FBTyx5Q0FBeUMsZUFBZSxhQUFhLHdDQUF3QywwREFBMEQsaUNBQWlDLDRHQUE0RyxhQUFhLHNhQUFzYSxXQUFXLFNBQVMsRUFBRSxPQUFPLDhDQUE4QywrRkFBK0YsZ0JBQWdCLE9BQU8sT0FBTyw2SEFBNkgsd0JBQXdCLFdBQVcsU0FBUyx1QkFBdUIsT0FBTyxLQUFLLEVBQUUseUJBQXlCLHNCQUFzQixnQ0FBZ0Msb0ZBQW9GLGtDQUFrQyxxQkFBcUIsK0ZBQStGLGtHQUFrRyx5QkFBeUIsYUFBYSwrQkFBK0Isa05BQWtOLFdBQVcsbUJBQW1CLFNBQVMsZ0RBQWdELHVDQUF1QyxrQkFBa0Isc0NBQXNDLG1CQUFtQixXQUFXLDZCQUE2QiwwREFBMEQsV0FBVyxPQUFPLHdCQUF3QixXQUFXLGlDQUFpQywwREFBMEQsdUJBQXVCLFdBQVcsc0NBQXNDLHdCQUF3QixXQUFXLGdDQUFnQyxvREFBb0QseURBQXlELGFBQWEsRUFBRSxXQUFXLCtGQUErRiwwSkFBMEosNkJBQTZCLFdBQVcsU0FBUyxFQUFFLE9BQU8sS0FBSyxFQUFFLG1CQUFtQixpQkFBaUIsaUJBQWlCLG1DQUFtQyx3REFBd0QsbUtBQW1LLFdBQVcsU0FBUyxrQkFBa0IsbUNBQW1DLHFWQUFxViw2REFBNkQsU0FBUyxPQUFPLGtDQUFrQyxrWEFBa1gscUdBQXFHLHNFQUFzRSwrQkFBK0IsaUJBQWlCLHdFQUF3RSxlQUFlLGFBQWEsNEJBQTRCLFdBQVcsMkNBQTJDLDRLQUE0SywyQkFBMkIsa0NBQWtDLGtGQUFrRixpQ0FBaUMsZUFBZSxhQUFhLHlHQUF5RyxzQ0FBc0MsYUFBYSw0QkFBNEIsV0FBVyxTQUFTLE9BQU8sS0FBSyxFQUFFLGlHQUFpRywrQkFBK0Isd0NBQXdDLHNDQUFzQyxpRkFBaUYsV0FBVyxTQUFTLFFBQVEsK0JBQStCLHFEQUFxRCw2RUFBNkUsVUFBVSxPQUFPLEtBQUssRUFBRSwrVEFBK1QsMEVBQTBFLHlGQUF5RixRQUFRLEtBQUssRUFBRSxzQkFBc0IsNENBQTRDLG1FQUFtRSxPQUFPLDZDQUE2Qyw4Q0FBOEMsT0FBTywyQ0FBMkMseUNBQXlDLE9BQU8sK0RBQStELGtEQUFrRCxPQUFPLDZEQUE2RCxtS0FBbUssT0FBTyxLQUFLLEVBQUUsNkJBQTZCLHVCQUF1QixxSEFBcUgscUNBQXFDLE1BQU0sd0VBQXdFLG1CQUFtQixrREFBa0Qsb0JBQW9CLE9BQU8sK0JBQStCLDhCQUE4QixzREFBc0QsT0FBTyxZQUFZLHdCQUF3QixPQUFPLHVFQUF1RSwrQ0FBK0MsT0FBTyxtQkFBbUIsTUFBTSxrMUJBQWsxQix3TkFBd04sd0RBQXdELHFQQUFxUCxpSUFBaUksK0dBQStHLHVEQUF1RCxvQ0FBb0MscUNBQXFDLFNBQVMseUhBQXlILHdDQUF3QyxxR0FBcUcsMkVBQTJFLG9EQUFvRCw4RUFBOEUsaUNBQWlDLE9BQU8sMkVBQTJFLGFBQWEsV0FBVyxTQUFTLFFBQVEsS0FBSyxzSkFBc0osd0JBQXdCLHVEQUF1RCxvQ0FBb0MscUJBQXFCLG1DQUFtQyxpRkFBaUYsd0ZBQXdGLG9IQUFvSCwyREFBMkQseUNBQXlDLHlCQUF5QixXQUFXLDZCQUE2QixxREFBcUQsV0FBVyxTQUFTLEVBQUUsd0JBQXdCLE9BQU8sb0ZBQW9GLEtBQUssNkpBQTZKLDJGQUEyRiwwQkFBMEIscUNBQXFDLHlEQUF5RCxtQkFBbUIsU0FBUyxPQUFPLG1CQUFtQiwwQ0FBMEMsT0FBTyxzQkFBc0IsS0FBSyxnUEFBZ1AsOElBQThJLG9HQUFvRywwQkFBMEIsaUNBQWlDLHVFQUF1RSxTQUFTLE9BQU8sdUVBQXVFLGdDQUFnQywwREFBMEQsb0NBQW9DLGtCQUFrQixXQUFXLFNBQVMsT0FBTywwR0FBMEcscUNBQXFDLE9BQU8sT0FBTyxxRUFBcUUsMkVBQTJFLGlDQUFpQyxrQkFBa0IsV0FBVyxpQ0FBaUMsaUNBQWlDLFdBQVcsU0FBUyxvRkFBb0YsT0FBTyx3SkFBd0osNkNBQTZDLDJDQUEyQyxTQUFTLDBDQUEwQyxPQUFPLEtBQUsscU1BQXFNLHVHQUF1Ryw2SEFBNkgseUVBQXlFLG9DQUFvQyw4REFBOEQsU0FBUyxPQUFPLG9DQUFvQyxnRUFBZ0Usd0NBQXdDLHNEQUFzRCxTQUFTLHlGQUF5Rix3REFBd0QsU0FBUyx5QkFBeUIsb0NBQW9DLHdCQUF3QixzR0FBc0csMkJBQTJCLHFGQUFxRiwrQ0FBK0MsNEhBQTRILHdEQUF3RCx5Q0FBeUMsb0ZBQW9GLDJDQUEyQyx5SkFBeUosK0JBQStCLDhGQUE4RiwrQ0FBK0Msb0VBQW9FLHVDQUF1Qyx1Q0FBdUMsZ0RBQWdELHFCQUFxQiw0QkFBNEIsbUJBQW1CLGlCQUFpQixlQUFlLGFBQWEsK0VBQStFLHFIQUFxSCwwQ0FBMEMsZUFBZSxPQUFPLHFCQUFxQiw0Q0FBNEMsaUJBQWlCLFlBQVksMEJBQTBCLHdKQUF3SixpQkFBaUIsZUFBZSxhQUFhLFdBQVcsU0FBUyxPQUFPLGdCQUFnQix5REFBeUQsS0FBSyxxQkFBcUIsbUpBQW1KLGVBQWUsc0JBQXNCLGtPQUFrTyxnT0FBZ08sNkJBQTZCLGtNQUFrTSxvQkFBb0IsMkVBQTJFLDBCQUEwQix5R0FBeUcsNklBQTZJLDJUQUEyVCxpT0FBaU8sb0RBQW9ELE9BQU8sK05BQStOLHdNQUF3TSxPQUFPLHdMQUF3TCxvR0FBb0csd0JBQXdCLDBCQUEwQixTQUFTLHFFQUFxRSwwZEFBMGQsK2dCQUErZ0IsOEVBQThFLHFDQUFxQyw2SkFBNkoscUlBQXFJLHNCQUFzQixnQ0FBZ0MscUNBQXFDLHFDQUFxQyx3RUFBd0UscUVBQXFFLGlCQUFpQixlQUFlLDJEQUEyRCxhQUFhLGtEQUFrRCxXQUFXLDJGQUEyRiw4REFBOEQsV0FBVyxtR0FBbUcsMkNBQTJDLDJCQUEyQixxRkFBcUYsMkNBQTJDLGFBQWEsMEJBQTBCLFdBQVcsaUhBQWlILHlCQUF5QixnQ0FBZ0MsYUFBYSwwQkFBMEIsV0FBVyx3RkFBd0YscUJBQXFCLHdCQUF3Qiw4QkFBOEIsbUNBQW1DLG9KQUFvSixpQkFBaUIsZUFBZSxPQUFPLG9HQUFvRyxlQUFlLGFBQWEsMEJBQTBCLFdBQVcsNkVBQTZFLG1EQUFtRCw4QkFBOEIseUNBQXlDLGFBQWEsaUNBQWlDLHdCQUF3QixXQUFXLFVBQVUsd0ZBQXdGLG1DQUFtQyxpQ0FBaUMsdVlBQXVZLDRIQUE0SCw0SEFBNEgsdUhBQXVILGlEQUFpRCwrT0FBK08sU0FBUyxrSEFBa0gsdURBQXVELFNBQVMsNkZBQTZGLHFGQUFxRix1QkFBdUIsU0FBUyxpTUFBaU0sd0ZBQXdGLDhDQUE4QyxTQUFTLGdFQUFnRSxzRkFBc0YsMElBQTBJLG9GQUFvRiw0RUFBNEUsaUZBQWlGLDZGQUE2RixXQUFXLHlFQUF5RSx1UUFBdVEsV0FBVyxTQUFTLGdIQUFnSCw4Q0FBOEMseUZBQXlGLFdBQVcsd0NBQXdDLDZFQUE2RSxXQUFXLFNBQVMsNElBQTRJLGtFQUFrRSxTQUFTLGdQQUFnUCxzQ0FBc0MsNERBQTRELGtEQUFrRCxTQUFTLDRKQUE0SixnRkFBZ0YsU0FBUyx5RUFBeUUsdURBQXVELHNFQUFzRSxHQUFHLHlCQUF5QixTQUFTLHNHQUFzRyw2REFBNkQscUNBQXFDLFNBQVMsT0FBTywrQkFBK0IsbURBQW1ELGlFQUFpRSxXQUFXLHdEQUF3RCxtREFBbUQsdUNBQXVDLGFBQWEsYUFBYSxXQUFXLGlCQUFpQixzQkFBc0IsaURBQWlELFdBQVcsWUFBWSxtRkFBbUYsMEJBQTBCLHlDQUF5QyxPQUFPLHNCQUFzQixhQUFhLFdBQVcsU0FBUyxpSEFBaUgsNEpBQTRKLDZDQUE2QyxtQkFBbUIsV0FBVyxpREFBaUQsNkRBQTZELHVDQUF1QyxXQUFXLHlKQUF5Siw4RUFBOEUsb0VBQW9FLG1HQUFtRyxpREFBaUQsZ0VBQWdFLFdBQVcsMklBQTJJLG1FQUFtRSwySEFBMkgsb0VBQW9FLCtCQUErQix5REFBeUQsZUFBZSw2REFBNkQsK0JBQStCLGlEQUFpRCxlQUFlLGFBQWEsNkVBQTZFLHlDQUF5QyxnQ0FBZ0MsMkJBQTJCLDJDQUEyQyxrREFBa0QsT0FBTywwQ0FBMEMsc0NBQXNDLHFDQUFxQyxpQ0FBaUMsYUFBYSxXQUFXLE9BQU8sd0dBQXdHLDBDQUEwQyxxQ0FBcUMsaUNBQWlDLDJCQUEyQixlQUFlLGFBQWEsV0FBVyx3RUFBd0UscUVBQXFFLDZDQUE2QyxnRkFBZ0YsV0FBVyxPQUFPLDZFQUE2RSxXQUFXLDBFQUEwRSxrQ0FBa0MsOEJBQThCLDZIQUE2SCxXQUFXLDBGQUEwRiw4QkFBOEIscUVBQXFFLHdFQUF3RSxpREFBaUQsYUFBYSxXQUFXLFNBQVMsdUJBQXVCLE9BQU8sdURBQXVELHlEQUF5RCxPQUFPLHFEQUFxRCxnRUFBZ0UsT0FBTyxLQUFLLEVBQUUsMkRBQTJELDZEQUE2RCw2RkFBNkYsa0NBQWtDLDBCQUEwQiwyQkFBMkIsU0FBUyw4QkFBOEIsNEhBQTRILEVBQUUsUUFBUSxLQUFLLEVBQUUsd0NBQXdDLDBCQUEwQiw4SUFBOEksRUFBRSxNQUFNLHdCQUF3Qix1Q0FBdUMsaUJBQWlCLHdDQUF3Qyx5Q0FBeUMscURBQXFELFdBQVcsRUFBRSxTQUFTLHdCQUF3QiwwSEFBMEgscUNBQXFDLHVDQUF1QyxXQUFXLGtDQUFrQyw0QkFBNEIsOENBQThDLDRDQUE0QyxhQUFhLDBCQUEwQixXQUFXLGVBQWUsU0FBUyxzQkFBc0IsT0FBTyw0Q0FBNEMsc0NBQXNDLHlDQUF5Qyx1REFBdUQsV0FBVyxFQUFFLFNBQVMsd0NBQXdDLDJFQUEyRSxrQ0FBa0MsbUNBQW1DLFdBQVcsT0FBTyw4QkFBOEIsV0FBVyxTQUFTLEVBQUUsT0FBTyxrQ0FBa0MsaURBQWlELHVDQUF1Qyx1RUFBdUUsU0FBUyxFQUFFLE9BQU8sa0NBQWtDLCtDQUErQyxpREFBaUQsc0RBQXNELFdBQVcsU0FBUyxRQUFRLE9BQU8sS0FBSyxFQUFFLG9EQUFvRCxrTEFBa0wsTUFBTSxxREFBcUQsK0NBQStDLE1BQU0sNk1BQTZNLDJEQUEyRCxlQUFlLGtDQUFrQywwRUFBMEUscURBQXFELDRFQUE0RSxXQUFXLE9BQU8sNExBQTRMLFdBQVcsU0FBUyxFQUFFLE9BQU8sNERBQTRELDREQUE0RCxrRkFBa0YsU0FBUyxPQUFPLE9BQU8sMERBQTBELE9BQU8sS0FBSywwSUFBMEksNEVBQTRFLG1KQUFtSixrRkFBa0YsUUFBUSxtR0FBbUcsNkVBQTZFLE9BQU8scUpBQXFKLDBFQUEwRSxxQ0FBcUMsU0FBUyxFQUFFLE9BQU8sT0FBTyw0SkFBNEosMkRBQTJELFNBQVMsT0FBTyx5RkFBeUYsTUFBTSx3QkFBd0IsdUNBQXVDLG1EQUFtRCxPQUFPLGtEQUFrRCxxQ0FBcUMsc0lBQXNJLDhEQUE4RCxTQUFTLHNCQUFzQiwrQkFBK0IsZ1BBQWdQLFNBQVMsMEJBQTBCLHVDQUF1Qyw0RkFBNEYsb0JBQW9CLCtGQUErRixXQUFXLEtBQUsseUZBQXlGLFNBQVMsUUFBUSxPQUFPLEtBQUssRUFBRSw2Q0FBNkMsV0FBVyxvQ0FBb0MsT0FBTyxhQUFhLE1BQU0sNkNBQTZDLDZCQUE2QixtTEFBbUwsa0RBQWtELCtLQUErSyxvREFBb0QsdUNBQXVDLDhCQUE4QixTQUFTLE9BQU8sRUFBRSxLQUFLLDJFQUEyRSxpREFBaUQsNkNBQTZDLG9CQUFvQixzSUFBc0ksZ0JBQWdCLGtEQUFrRCxtRkFBbUYsbUdBQW1HLHlFQUF5RSw0Q0FBNEMsOENBQThDLGVBQWUsYUFBYSwrRkFBK0YscURBQXFELGFBQWEseWFBQXlhLGlFQUFpRSxhQUFhLG1EQUFtRCxrREFBa0QsYUFBYSxpRUFBaUUsa0NBQWtDLGdDQUFnQywwQ0FBMEMsOERBQThELDZDQUE2QyxnQ0FBZ0MsbUJBQW1CLCtCQUErQix1RUFBdUUsa0VBQWtFLG1CQUFtQixPQUFPLGtSQUFrUixpRUFBaUUsMkNBQTJDLG1CQUFtQixpQkFBaUIsZ0JBQWdCLGNBQWMsNkRBQTZELCtDQUErQywrRkFBK0YsbUJBQW1CLHFJQUFxSSxhQUFhLFlBQVksZ0hBQWdILHdCQUF3QixlQUFlLGFBQWEsV0FBVyxvQ0FBb0MsNEJBQTRCLDBCQUEwQixhQUFhLFdBQVcsVUFBVSxPQUFPLEtBQUssRUFBRSxtREFBbUQsZ0JBQWdCLG9IQUFvSCxrQkFBa0IsNENBQTRDLG9CQUFvQixvREFBb0Qsa0NBQWtDLHNCQUFzQixTQUFTLE9BQU8sS0FBSyxFQUFFLG9HQUFvRyxrQ0FBa0Msd0JBQXdCLE9BQU8sNEJBQTRCLHlCQUF5QixPQUFPLEtBQUssRUFBRSx1RkFBdUYsdUZBQXVGLCtCQUErQixrQkFBa0IsNENBQTRDLGdEQUFnRCxzR0FBc0csMERBQTBELDhCQUE4QixnQ0FBZ0MsMEJBQTBCLHVFQUF1RSxlQUFlLGFBQWEsRUFBRSxpREFBaUQsV0FBVyxvQ0FBb0MsNkJBQTZCLDJCQUEyQixhQUFhLFdBQVcsVUFBVSxPQUFPLEtBQUssRUFBRSxrRUFBa0Usa0RBQWtELHlFQUF5RSw4RUFBOEUsOEJBQThCLHdCQUF3QixPQUFPLEtBQUssRUFBRSx3SkFBd0osK1JBQStSLHVJQUF1SSxnTUFBZ00sa0VBQWtFLDJFQUEyRSxTQUFTLDhCQUE4Qix5RkFBeUYsU0FBUyx1SEFBdUgsbUNBQW1DLDZEQUE2RCxXQUFXLHdDQUF3QyxVQUFVLDZEQUE2RCxpRUFBaUUsOENBQThDLHdDQUF3QyxVQUFVLG9GQUFvRixtRkFBbUYsdURBQXVELDJJQUEySSx1RkFBdUYsV0FBVyw0SEFBNEgsOENBQThDLFdBQVcsd0RBQXdELFNBQVMsRUFBRSxrREFBa0QsT0FBTyxLQUFLLEVBQUUseVJBQXlSLGdEQUFnRCxvQkFBb0IsT0FBTyw2Q0FBNkMsOEJBQThCLHdCQUF3QixPQUFPLHNDQUFzQyxnRkFBZ0YsbUNBQW1DLGtEQUFrRCxPQUFPLGdFQUFnRSx3Q0FBd0MsaUNBQWlDLE9BQU8sbURBQW1ELE1BQU0seUVBQXlFLG9HQUFvRywrQ0FBK0MsNENBQTRDLE9BQU8sZ0hBQWdILHVCQUF1QiwrQ0FBK0MsZ0NBQWdDLE9BQU8sZ0VBQWdFLHFFQUFxRSwyQkFBMkIsMENBQTBDLHFEQUFxRCx3QkFBd0IsT0FBTyxtRkFBbUYscUJBQXFCLG9MQUFvTCxnQ0FBZ0Msc0ZBQXNGLHNUQUFzVCxTQUFTLGlEQUFpRCwrRUFBK0UsU0FBUyxFQUFFLE9BQU8sb0JBQW9CLE1BQU0sc01BQXNNLHVDQUF1QyxpQ0FBaUMsUUFBUSxLQUFLLEVBQUUsc0RBQXNELHVEQUF1RCxnQ0FBZ0MsT0FBTyxTQUFTLE1BQU0sb0RBQW9ELGtGQUFrRixvRkFBb0YsS0FBSyx1QkFBdUIsdURBQXVELGdSQUFnUiw0R0FBNEcsNkNBQTZDLFNBQVMsdUNBQXVDLDhDQUE4QyxnREFBZ0QscUlBQXFJLDRKQUE0SiwyQ0FBMkMsbUNBQW1DLHFDQUFxQyxTQUFTLE9BQU8sOENBQThDLGdEQUFnRCxTQUFTLDJDQUEyQyxxREFBcUQsU0FBUyxvQ0FBb0MsMkRBQTJELFNBQVMscUNBQXFDLCtEQUErRCxTQUFTLHFDQUFxQywwQ0FBMEMsU0FBUyxPQUFPLDZCQUE2QixTQUFTLE9BQU8sTUFBTSxzQkFBc0Isd0NBQXdDLCtCQUErQix3RUFBd0Usc0RBQXNELFdBQVcsRUFBRSxTQUFTLG9GQUFvRiwyQ0FBMkMsOENBQThDLHFCQUFxQixpQkFBaUIsU0FBUyx3Q0FBd0MsOEZBQThGLHFCQUFxQixTQUFTLHlMQUF5TCw2Q0FBNkMsU0FBUywrQkFBK0IsZ0JBQWdCLHNJQUFzSSxPQUFPLHNDQUFzQyx1QkFBdUIsaUJBQWlCLFNBQVMscUdBQXFHLDRDQUE0QywyREFBMkQsZUFBZSxtR0FBbUcsa0lBQWtJLFNBQVMsT0FBTyxpRkFBaUYsMERBQTBELDhEQUE4RCxpREFBaUQsV0FBVyxvSEFBb0gsc0ZBQXNGLFNBQVMsbUVBQW1FLHVMQUF1TCxPQUFPLDhDQUE4QyxxQ0FBcUMsMERBQTBELHVJQUF1SSxxREFBcUQsV0FBVywyQ0FBMkMsU0FBUyxFQUFFLE9BQU8sS0FBSyxFQUFFLDhEQUE4RCx1RUFBdUUsMkJBQTJCLHlDQUF5Qyw0Q0FBNEMsMERBQTBELG9DQUFvQyxvQ0FBb0Msa0RBQWtELFdBQVcsc0JBQXNCLDBGQUEwRixXQUFXLE9BQU8sK0JBQStCLFdBQVcsU0FBUyx1Q0FBdUMsUUFBUSxLQUFLLEVBQUUsd1RBQXdULHFKQUFxSiw2RkFBNkYsdUJBQXVCLHdDQUF3QyxvSkFBb0osU0FBUyxPQUFPLEVBQUUsS0FBSyxFQUFFLHdHQUF3RyxvREFBb0QseUJBQXlCLG1CQUFtQiw2RkFBNkYscUNBQXFDLDZHQUE2RyxrTUFBa00sNERBQTRELG9CQUFvQiwwQ0FBMEMsd1RBQXdULGFBQWEsMEVBQTBFLHlDQUF5QywwUkFBMFIsYUFBYSwyUEFBMlAsV0FBVyx5REFBeUQsVUFBVSxPQUFPLEVBQUUsS0FBSyxFQUFFLG1HQUFtRyx5QkFBeUIsTUFBTSw0Q0FBNEMsaTZCQUFpNkIsMENBQTBDLHNCQUFzQixPQUFPLEVBQUUsS0FBSyw2SUFBNkksMkNBQTJDLGdDQUFnQyxzQkFBc0IsT0FBTywrQ0FBK0MsZ0NBQWdDLE9BQU8sc0JBQXNCLE1BQU0sdU5BQXVOLHdDQUF3QyxLQUFLLG9CQUFvQixHQUFHLEVBQUUsQzs7Ozs7Ozs7Ozs7QUNBM3R1Uix5Q0FBeUMsK0VBQStFLGtDQUFrQyxtQkFBbUIsR0FBRyxFQUFFLE9BQU8sa0NBQWtDLGtJQUFrSSxHQUFHLEVBQUUscUJBQXFCLEVBQUUsNGFBQTRhLG1CQUFtQix1REFBdUQsbUJBQW1CLDBEQUEwRCxLQUFLLE9BQU8sZ0JBQWdCLG9GQUFvRixLQUFLLEdBQUcsZ0JBQWdCLG1CQUFtQixxU0FBcVMsbURBQW1ELG1DQUFtQyxxREFBcUQsc0RBQXNELEVBQUUsYUFBYSxFQUFFLFNBQVMsRUFBRSx5SkFBeUosbUNBQW1DLDhDQUE4QyxFQUFFLFNBQVMsRUFBRSxxTEFBcUwsbUVBQW1FLEVBQUUscUxBQXFMLDZFQUE2RSxxREFBcUQsOEJBQThCLGtNQUFrTSxrRkFBa0YscUJBQXFCLGdEQUFnRCxPQUFPLG1EQUFtRCwyREFBMkQsbUJBQW1CLE9BQU8sZ0RBQWdELE1BQU0sOEpBQThKLG1JQUFtSSx5RUFBeUUsb0JBQW9CLE9BQU8seUVBQXlFLDJDQUEyQyxtQkFBbUIsb0NBQW9DLE9BQU8sa0NBQWtDLHFCQUFxQixPQUFPLHNEQUFzRCxtREFBbUQsNkRBQTZELDhDQUE4QyxrQkFBa0IsNkZBQTZGLE9BQU8sa0NBQWtDLDhNQUE4TSxXQUFXLCtEQUErRCw2RkFBNkYsZ0VBQWdFLHdCQUF3Qix3RUFBd0Usb0JBQW9CLE9BQU8sOEpBQThKLHVFQUF1RSxvQkFBb0IsT0FBTyw4Q0FBOEMsd0NBQXdDLGlEQUFpRCxPQUFPLDBCQUEwQix3RUFBd0UsMkJBQTJCLHlDQUF5QyxnREFBZ0QsT0FBTyx3SkFBd0osb0VBQW9FLG9CQUFvQixPQUFPLDJHQUEyRyx3QkFBd0IsMEVBQTBFLG9CQUFvQixPQUFPLHdDQUF3QyxpQkFBaUIsa0NBQWtDLE9BQU8sa0RBQWtELHVFQUF1RSw0QkFBNEIsaUNBQWlDLE9BQU8seUJBQXlCLDhDQUE4QywyQkFBMkIsZ0NBQWdDLG9DQUFvQyw0QkFBNEIsU0FBUyxFQUFFLE9BQU8sZ0NBQWdDLG9DQUFvQyxpREFBaUQsU0FBUyxFQUFFLE9BQU8scUhBQXFILDJEQUEyRCwwQ0FBMEMsa0VBQWtFLGtFQUFrRSxTQUFTLEVBQUUsT0FBTyw0QkFBNEIsd0NBQXdDLE9BQU8sd0RBQXdELDBGQUEwRix1RkFBdUYsU0FBUyxPQUFPLDJFQUEyRSxTQUFTLFFBQVEsNEJBQTRCLHFDQUFxQyx5REFBeUQsZ0RBQWdELCtEQUErRCxVQUFVLE9BQU8sK0JBQStCLDJDQUEyQyxxREFBcUQsZ0RBQWdELDJEQUEyRCxVQUFVLE9BQU8sOFFBQThRLG9DQUFvQyxPQUFPLEVBQUUsZ0RBQWdELHFDQUFxQyxrRkFBa0Ysd0RBQXdELG1DQUFtQyxvRUFBb0UsZ0JBQWdCLDJNQUEyTSwwTUFBME0scURBQXFELHdDQUF3QyxXQUFXLEVBQUUsU0FBUyxPQUFPLHNDQUFzQyxTQUFTLE9BQU8sb0RBQW9ELGlDQUFpQyxPQUFPLE9BQU8sZ0NBQWdDLE9BQU8sdURBQXVELDhDQUE4QyxxQkFBcUIsT0FBTywyQkFBMkIsT0FBTyxxRkFBcUYsa0JBQWtCLGdGQUFnRiw0RUFBNEUsb0NBQW9DLHdCQUF3QixvQkFBb0IscUJBQXFCLFNBQVMsT0FBTyxrQkFBa0IsMEZBQTBGLDBDQUEwQyxTQUFTLHVKQUF1SixTQUFTLHdCQUF3QixPQUFPLDJHQUEyRyxzQ0FBc0MseUJBQXlCLGNBQWMsT0FBTyxpREFBaUQsU0FBUyxrQ0FBa0MsZ0VBQWdFLHVCQUF1QiwyQkFBMkIsT0FBTyxvQ0FBb0MsMEVBQTBFLGFBQWEsV0FBVyxTQUFTLDhCQUE4QixpQ0FBaUMsNEJBQTRCLDBIQUEwSCxFQUFFLHVDQUF1QyxvR0FBb0csMkNBQTJDLCtCQUErQix3RUFBd0UsZ0NBQWdDLDhEQUE4RCwwRkFBMEYsK0NBQStDLDhEQUE4RCxpQkFBaUIsMEVBQTBFLGVBQWUsU0FBUyxhQUFhLHlCQUF5QixZQUFZLFNBQVMsd0JBQXdCLHNDQUFzQyw0Q0FBNEMsNkVBQTZFLHNDQUFzQyxXQUFXLE9BQU8sOEJBQThCLFdBQVcsNkJBQTZCLDBDQUEwQyxXQUFXLFVBQVUsMkJBQTJCLE9BQU8sMEdBQTBHLGdPQUFnTyxvQ0FBb0Msc0RBQXNELDRCQUE0QixVQUFVLGtCQUFrQixxRkFBcUYscUJBQXFCLE9BQU8sZ0NBQWdDLDRCQUE0Qix5Q0FBeUMsYUFBYSxPQUFPLHdDQUF3QyxhQUFhLFdBQVcsU0FBUywrQkFBK0IsMkJBQTJCLG1DQUFtQywrQ0FBK0MsK0JBQStCLGtDQUFrQyxnQ0FBZ0MscUJBQXFCLGtDQUFrQyxXQUFXLE9BQU8sbUJBQW1CLFdBQVcsU0FBUyxPQUFPLGdGQUFnRixtQkFBbUIsa0dBQWtHLEVBQUUsU0FBUyxzQkFBc0IsZUFBZSwwTkFBME4sNkRBQTZELDJEQUEyRCwwQ0FBMEMsaUVBQWlFLDJDQUEyQyw2QkFBNkIsbUJBQW1CLHFGQUFxRiw4REFBOEQsZUFBZSxhQUFhLGtCQUFrQiwyQ0FBMkMsb0RBQW9ELDRCQUE0QixzREFBc0QsYUFBYSxzQkFBc0IsMERBQTBELGFBQWEsK0JBQStCLGlEQUFpRCxhQUFhLFdBQVcsVUFBVSxxQkFBcUIsdUhBQXVILHlDQUF5QyxTQUFTLGtCQUFrQixrREFBa0QsU0FBUywrRUFBK0UseUJBQXlCLHVCQUF1QixXQUFXLDhCQUE4QiwwQkFBMEIsU0FBUyw0QkFBNEIsNEJBQTRCLDBCQUEwQixTQUFTLDJFQUEyRSxvQkFBb0IsdUJBQXVCLHFDQUFxQyw0Q0FBNEMsdUNBQXVDLDBDQUEwQyxpREFBaUQsaURBQWlELGFBQWEsV0FBVyxTQUFTLHVDQUF1Qyw2QkFBNkIsa0NBQWtDLG9aQUFvWiwrQ0FBK0Msc0NBQXNDLGlEQUFpRCxhQUFhLFdBQVcsY0FBYyxpSUFBaUksV0FBVyxzQkFBc0IsZ0VBQWdFLFdBQVcsaUJBQWlCLGlLQUFpSyxXQUFXLGNBQWMsd0ZBQXdGLGlDQUFpQyxXQUFXLHVCQUF1QixTQUFTLHVIQUF1SCxvRUFBb0UseUNBQXlDLDBDQUEwQywrQ0FBK0MsU0FBUyxzSEFBc0gsMk9BQTJPLG9GQUFvRixrREFBa0QsZ0RBQWdELFdBQVcsNkJBQTZCLCtDQUErQyxXQUFXLGlJQUFpSSx3QkFBd0IsdUdBQXVHLEVBQUUsV0FBVyxnREFBZ0Qsb0RBQW9ELDhCQUE4Qix1Q0FBdUMsYUFBYSxhQUFhLFdBQVcsK0RBQStELGlCQUFpQixnREFBZ0Qsc0NBQXNDLHNFQUFzRSwyQ0FBMkMsZUFBZSxhQUFhLFlBQVksMERBQTBELCtCQUErQixvQ0FBb0MsNENBQTRDLGVBQWUsMENBQTBDLGFBQWEsV0FBVyx3RkFBd0YsaUJBQWlCLDhCQUE4QiwwQ0FBMEMsb0RBQW9ELDhPQUE4TyxvSkFBb0osbUJBQW1CLE9BQU8sNEhBQTRILG1CQUFtQixpQkFBaUIsZUFBZSxhQUFhLG9DQUFvQyx5RkFBeUYsYUFBYSxtQ0FBbUMsMkNBQTJDLGFBQWEsT0FBTyxxREFBcUQsYUFBYSx5Q0FBeUMsbUJBQW1CLDRCQUE0QixhQUFhLGNBQWMsMElBQTBJLG1DQUFtQyxhQUFhLFdBQVcsVUFBVSx5R0FBeUcsNkNBQTZDLDhCQUE4Qiw2Q0FBNkMsYUFBYSxPQUFPLHlDQUF5QyxhQUFhLHNDQUFzQyxXQUFXLFNBQVMsNEJBQTRCLHFCQUFxQixTQUFTLE9BQU8sbUNBQW1DLHlDQUF5QyxnR0FBZ0csMEJBQTBCLGlEQUFpRCxtQkFBbUIsV0FBVyw2QkFBNkIsdUJBQXVCLG1EQUFtRCw2QkFBNkIsV0FBVyxvREFBb0QsaUNBQWlDLDRDQUE0QyxtQkFBbUIsV0FBVyxxQ0FBcUMsc0NBQXNDLDBEQUEwRCxtQkFBbUIsV0FBVywyREFBMkQsb0VBQW9FLHFCQUFxQixhQUFhLFdBQVcsaUNBQWlDLHlDQUF5QyxXQUFXLE9BQU8sc0RBQXNELFdBQVcsd0RBQXdELGlCQUFpQiwyQkFBMkIsOEJBQThCLGFBQWEsb0ZBQW9GLGtDQUFrQyx5RkFBeUYsb0NBQW9DLHlPQUF5TyxvQ0FBb0MsdUJBQXVCLGVBQWUsb0pBQW9KLG9EQUFvRCxlQUFlLDRCQUE0Qix3RUFBd0Usa0VBQWtFLHNFQUFzRSwwQkFBMEIsaUNBQWlDLGFBQWEseURBQXlELDZCQUE2QiwwREFBMEQsbURBQW1ELGNBQWMscUZBQXFGLGdGQUFnRixvRkFBb0YsYUFBYSx3REFBd0Qsb0RBQW9ELHNDQUFzQyx5SEFBeUgseUJBQXlCLDRDQUE0QyxzSUFBc0ksaUZBQWlGLGVBQWUsZ0JBQWdCLHVJQUF1SSw0REFBNEQsNEJBQTRCLHVGQUF1RixpQkFBaUIsY0FBYyxpRkFBaUYsaUJBQWlCLGVBQWUsYUFBYSxnRUFBZ0Usd0RBQXdELGFBQWEsbUJBQW1CLDBDQUEwQyxhQUFhLGNBQWMscUNBQXFDLGlEQUFpRCxhQUFhLFdBQVcsY0FBYyx1Q0FBdUMsNkJBQTZCLCtDQUErQyxXQUFXLDhCQUE4QixrQ0FBa0MsMEJBQTBCLFdBQVcsNkJBQTZCLDBJQUEwSSxXQUFXLHVIQUF1SCw0QkFBNEIsOERBQThELGFBQWEsaUVBQWlFLHNCQUFzQix5REFBeUQsYUFBYSxXQUFXLG1CQUFtQix1Q0FBdUMsc0NBQXNDLGFBQWEsNEJBQTRCLDJEQUEyRCxhQUFhLG9EQUFvRCxzQkFBc0IsK0RBQStELGFBQWEsV0FBVyxvQkFBb0Isd0RBQXdELFdBQVcsb0NBQW9DLDBDQUEwQyxXQUFXLDZCQUE2QixvREFBb0QsV0FBVyxxQ0FBcUMsNEJBQTRCLHdDQUF3QyxXQUFXLGtEQUFrRCxrQ0FBa0MsMkJBQTJCLGFBQWEsT0FBTyw0R0FBNEcsYUFBYSxxQ0FBcUMsV0FBVyxPQUFPLFNBQVMsdURBQXVELHlGQUF5Rix3REFBd0QsZ0NBQWdDLDJCQUEyQixXQUFXLE9BQU8saUVBQWlFLFdBQVcsNEdBQTRHLFVBQVUsdURBQXVELDhFQUE4RSxVQUFVLDBEQUEwRCwwT0FBME8seUVBQXlFLDBCQUEwQixxQ0FBcUMsYUFBYSxXQUFXLG9DQUFvQyw0Q0FBNEMsV0FBVywyQ0FBMkMsc0VBQXNFLHFDQUFxQyxhQUFhLDRFQUE0RSxpQ0FBaUMsYUFBYSxXQUFXLHdCQUF3QixVQUFVLDBCQUEwQixPQUFPLE1BQU0sd3dCQUF3d0IsOEJBQThCLHVFQUF1RSxrSEFBa0gsaUJBQWlCLDhEQUE4RCxrQ0FBa0MsaURBQWlELHlCQUF5QiwwQ0FBMEMsV0FBVyxFQUFFLHNCQUFzQixTQUFTLHFIQUFxSCwyRUFBMkUsb0JBQW9CLE9BQU8saUNBQWlDLHNSQUFzUixvQkFBb0IsT0FBTyxvSkFBb0osTUFBTSw0REFBNEQsMkRBQTJELHNDQUFzQywrRUFBK0Usd0NBQXdDLGVBQWUsS0FBSyw0Q0FBNEMsNERBQTRELDBCQUEwQixzREFBc0QsK0hBQStILCtCQUErQixpQkFBaUIsU0FBUyx3QkFBd0IsT0FBTyx3QkFBd0Isd0JBQXdCLHFDQUFxQyxzQ0FBc0MsaUNBQWlDLGlDQUFpQyxTQUFTLDZDQUE2QyxvQ0FBb0MsNkNBQTZDLDRDQUE0QyxTQUFTLE9BQU8sbURBQW1ELGtEQUFrRCxTQUFTLE9BQU8scURBQXFELGtEQUFrRCxPQUFPLE9BQU8sS0FBSyxvSEFBb0gsaUVBQWlFLE1BQU0sOFRBQThULG9DQUFvQyxHQUFHLG9DQUFvQywyTUFBMk0saUJBQWlCLGdDQUFnQyxpQkFBaUIsT0FBTywyQkFBMkIsbUNBQW1DLDBFQUEwRSxlQUFlLDZEQUE2RCwwQ0FBMEMsb0NBQW9DLFNBQVMsMEZBQTBGLDBEQUEwRCw2Q0FBNkMseUNBQXlDLFNBQVMsT0FBTyxrQ0FBa0MsaUJBQWlCLE9BQU8sc0NBQXNDLHFDQUFxQyxTQUFTLE9BQU8sb0JBQW9CLG9CQUFvQixrQ0FBa0MsbUJBQW1CLFNBQVMsNkRBQTZELGdHQUFnRyxvQkFBb0IsK0ZBQStGLEVBQUUsb0JBQW9CLHlFQUF5RSxHQUFHLHlFQUF5RSxFQUFFLFdBQVcscUJBQXFCLFNBQVMscUNBQXFDLDRDQUE0Qyx5QkFBeUIsOEJBQThCLFdBQVcsd0NBQXdDLFVBQVUsT0FBTyxvQkFBb0IsNERBQTRELEVBQUUsV0FBVyxTQUFTLGlEQUFpRCx5QkFBeUIsOEJBQThCLFdBQVcsaUNBQWlDLCtCQUErQix1QkFBdUIsa0JBQWtCLE9BQU8sc0JBQXNCLG9HQUFvRyxFQUFFLGFBQWEsV0FBVyxPQUFPLHVDQUF1QyxzRkFBc0YsRUFBRSxXQUFXLFNBQVMsa0RBQWtELHlCQUF5Qiw4QkFBOEIsV0FBVyxvQkFBb0IsK0dBQStHLEVBQUUsU0FBUyxPQUFPLG9DQUFvQyw2SUFBNkksdUJBQXVCLDhEQUE4RCxrQkFBa0IsOERBQThELEVBQUUsa0JBQWtCLG1FQUFtRSxHQUFHLG1FQUFtRSxFQUFFLFNBQVMsT0FBTyxpQkFBaUIsTUFBTSx1SUFBdUkscUVBQXFFLHFHQUFxRyxNQUFNLDZKQUE2Six3RUFBd0UsaUJBQWlCLDZCQUE2QiwwQkFBMEIsbUJBQW1CLGlCQUFpQixTQUFTLGlEQUFpRCw0Q0FBNEMseUNBQXlDLFNBQVMsT0FBTyxvQkFBb0IsNERBQTRELEVBQUUsV0FBVyxTQUFTLGtEQUFrRCxrQkFBa0IsMkRBQTJELEVBQUUsU0FBUyxPQUFPLEVBQUUseUVBQXlFLE1BQU0sa2pCQUFrakIsd09BQXdPLDRMQUE0TCxrcEJBQWtwQixrREFBa0QsU0FBUyxPQUFPLHlCQUF5Qiw2Q0FBNkMsNkZBQTZGLG1CQUFtQixTQUFTLHVDQUF1QywwQkFBMEIsU0FBUyxPQUFPLHNCQUFzQixTQUFTLE9BQU8sbUJBQW1CLE1BQU0sOEdBQThHLHFGQUFxRix1Q0FBdUMsMEJBQTBCLE9BQU8scVBBQXFQLG9CQUFvQixPQUFPLDhCQUE4QixxQ0FBcUMsMEJBQTBCLHNCQUFzQixTQUFTLGtEQUFrRCxvQ0FBb0MsK0NBQStDLHVDQUF1QyxTQUFTLE9BQU8sMEJBQTBCLDhCQUE4Qiw2QkFBNkIsdUJBQXVCLG1KQUFtSixhQUFhLHdCQUF3Qix1QkFBdUIsYUFBYSx3QkFBd0IsV0FBVyxTQUFTLG1CQUFtQixPQUFPLDJCQUEyQixNQUFNLDBnQkFBMGdCLG9DQUFvQyxvRUFBb0UsT0FBTyxFQUFFLE1BQU0sK0hBQStILDRHQUE0RyxzRUFBc0UsdUVBQXVFLGdEQUFnRCwwQkFBMEIsU0FBUyw0Q0FBNEMsK0JBQStCLFNBQVMsNEJBQTRCLGtDQUFrQyxTQUFTLDBCQUEwQixpREFBaUQscURBQXFELFdBQVcsT0FBTyw0QkFBNEIsV0FBVyxTQUFTLDBCQUEwQix1SEFBdUgsaVJBQWlSLDRCQUE0QixXQUFXLFNBQVMsT0FBTyxFQUFFLE1BQU0sK0lBQStJLG9DQUFvQyxvT0FBb08sdUJBQXVCLFNBQVMsT0FBTyxFQUFFLE1BQU0sbUdBQW1HLDRCQUE0QixpQkFBaUIsT0FBTyxzQ0FBc0MsMkJBQTJCLE9BQU8sRUFBRSxNQUFNLGtMQUFrTCxpQ0FBaUMsc0JBQXNCLE9BQU8sc0NBQXNDLDBCQUEwQixnREFBZ0QsZ0NBQWdDLFNBQVMsbURBQW1ELDhDQUE4QyxvRUFBb0UseUZBQXlGLFdBQVcsbUNBQW1DLFNBQVMsT0FBTyxFQUFFLE1BQU0sMERBQTBELHVEQUF1RCxtQ0FBbUMsZUFBZSxPQUFPLDhFQUE4RSxtREFBbUQsZ0NBQWdDLE9BQU8sbURBQW1ELG9DQUFvQyxPQUFPLEtBQUssR0FBRyxFQUFFLEM7Ozs7Ozs7Ozs7O0FDQXB2MEMseUNBQXlDLCtFQUErRSxrQ0FBa0MsbUJBQW1CLEdBQUcsRUFBRSxPQUFPLGtDQUFrQyxrSUFBa0ksR0FBRyxFQUFFLHFCQUFxQixFQUFFLDJjQUEyYyxzRkFBc0YscUJBQXFCLHlEQUF5RCxvQ0FBb0MsT0FBTyxzQ0FBc0Msd0JBQXdCLE9BQU8sS0FBSyxnQkFBZ0IscUJBQXFCLDhJQUE4SSxxbUJBQXFtQixpcUJBQWlxQixtUEFBbVAsOERBQThELHdHQUF3RyxXQUFXLG1DQUFtQyxTQUFTLDBHQUEwRyxJQUFJLDhKQUE4SixPQUFPLGtEQUFrRCwrQ0FBK0MsNkJBQTZCLDRCQUE0Qix5QkFBeUIsa0NBQWtDLGlFQUFpRSx1QkFBdUIsaUJBQWlCLFVBQVUsK0JBQStCLDBCQUEwQix3Q0FBd0MsbUJBQW1CLGtJQUFrSSxzS0FBc0ssT0FBTyxtQ0FBbUMsZ0RBQWdELDBDQUEwQyxRQUFRLDRDQUE0Qyw4Q0FBOEMsc0JBQXNCLFNBQVMscWJBQXFiLGdHQUFnRyx3SUFBd0ksZ0VBQWdFLE1BQU0sNkZBQTZGLGdnQkFBZ2dCLG1NQUFtTSxzSEFBc0gsR0FBRyxpR0FBaUcsZ0NBQWdDLHlDQUF5Qyw4QkFBOEIsNkdBQTZHLDREQUE0RCxXQUFXLFNBQVMsMENBQTBDLCtCQUErQixTQUFTLG1JQUFtSSwyREFBMkQsU0FBUywrQkFBK0Isb0RBQW9ELDRFQUE0RSx1QkFBdUIsMEVBQTBFLDBDQUEwQyxXQUFXLFNBQVMsRUFBRSxxRkFBcUYsK0JBQStCLHFGQUFxRixrRUFBa0Usc0RBQXNELDBIQUEwSCxrREFBa0QsV0FBVywwQ0FBMEMsU0FBUyxFQUFFLG1EQUFtRCxvQkFBb0IsUUFBUSxrREFBa0QsaUpBQWlKLDZCQUE2QixTQUFTLDhCQUE4QiwrQkFBK0IsbUJBQW1CLFdBQVcsa0NBQWtDLG1HQUFtRywrREFBK0Qsc0VBQXNFLFdBQVcsMkVBQTJFLDJDQUEyQyxXQUFXLEVBQUUsd0RBQXdELDZDQUE2QyxXQUFXLDRKQUE0Six5RkFBeUYsNkRBQTZELFdBQVcsb0ZBQW9GLHVPQUF1TyxrRUFBa0UsU0FBUywySEFBMkgsb0VBQW9FLDBDQUEwQyxTQUFTLGtFQUFrRSwrQkFBK0IsV0FBVyw2QkFBNkIsUUFBUSxTQUFTLGdDQUFnQyxvREFBb0QsT0FBTyxvQ0FBb0MsK0dBQStHLE9BQU8scUVBQXFFLHNDQUFzQyxpQ0FBaUMsdUJBQXVCLFNBQVMsMENBQTBDLDJCQUEyQiwyQ0FBMkMsU0FBUyxrQ0FBa0MsaUNBQWlDLHdFQUF3RSxzQ0FBc0Msa0ZBQWtGLFdBQVcsT0FBTyxnQ0FBZ0MsV0FBVyxvSkFBb0osZ0NBQWdDLCtDQUErQyxnQ0FBZ0Msb0RBQW9ELDBJQUEwSSxTQUFTLDJDQUEyQyxpRUFBaUUsc0NBQXNDLG1EQUFtRCxpQkFBaUIsaUNBQWlDLGVBQWUsaUNBQWlDLHdEQUF3RCx5QkFBeUIsaUJBQWlCLGlFQUFpRSxlQUFlLEVBQUUsb0ZBQW9GLGNBQWMsV0FBVyxxQ0FBcUMsaURBQWlELG9EQUFvRCxpREFBaUQsYUFBYSwyREFBMkQsb0NBQW9DLGFBQWEsV0FBVyxTQUFTLGdFQUFnRSwyQkFBMkIsdUVBQXVFLFNBQVMsd0RBQXdELDBDQUEwQyx3Q0FBd0MseUJBQXlCLGtDQUFrQyxJQUFJLHdDQUF3QyxTQUFTLHdEQUF3RCwwQ0FBMEMsd0NBQXdDLElBQUksd0NBQXdDLFNBQVMsMERBQTBELHdCQUF3QiwyQ0FBMkMsU0FBUyxvRUFBb0UsK0NBQStDLFNBQVMsRUFBRSxvQkFBb0IsT0FBTyw2RUFBNkUsa0JBQWtCLHlFQUF5RSxnR0FBZ0csNkVBQTZFLGdDQUFnQyxvQ0FBb0MsOENBQThDLG9FQUFvRSxnRUFBZ0UsZUFBZSxhQUFhLE9BQU8sNEJBQTRCLGFBQWEsV0FBVyx3REFBd0Qsd0VBQXdFLFdBQVcsMEZBQTBGLG1DQUFtQyxXQUFXLHFFQUFxRSx1RUFBdUUsdURBQXVELGFBQWEsV0FBVyxpRUFBaUUsbUVBQW1FLHlDQUF5QyxhQUFhLDZIQUE2SCxtQ0FBbUMsV0FBVyxtRUFBbUUsa0NBQWtDLFdBQVcseUZBQXlGLHdDQUF3QyxpREFBaUQsZ0dBQWdHLHdDQUF3QyxvRUFBb0UsYUFBYSxXQUFXLDJFQUEyRSxzREFBc0QsV0FBVyxtRkFBbUYsNEVBQTRFLFdBQVcsNkZBQTZGLHFFQUFxRSxXQUFXLDBFQUEwRSxvREFBb0QsV0FBVyw4RUFBOEUsK0NBQStDLFdBQVcsdURBQXVELDBFQUEwRSxXQUFXLDJJQUEySSxvR0FBb0csV0FBVyx5T0FBeU8saUNBQWlDLHFCQUFxQixhQUFhLDRFQUE0RSxvR0FBb0csd0RBQXdELG1DQUFtQyxXQUFXLFNBQVMsUUFBUSwrRUFBK0UsNElBQTRJLGdFQUFnRSxrQ0FBa0MseUJBQXlCLFdBQVcsU0FBUyxnREFBZ0QsT0FBTyw2Q0FBNkMsNkJBQTZCLHNCQUFzQixTQUFTLHdHQUF3Ryw0REFBNEQsUUFBUSw4Q0FBOEMsa0NBQWtDLHlDQUF5QywrQ0FBK0MsK0RBQStELCtCQUErQix1RUFBdUUsd0ZBQXdGLGVBQWUsYUFBYSxXQUFXLFNBQVMsT0FBTyxzSkFBc0osa0RBQWtELDZCQUE2QixzQkFBc0IsU0FBUywySkFBMkosa0dBQWtHLHdCQUF3QixzQkFBc0IsK0JBQStCLFNBQVMsT0FBTyw4QkFBOEIsVUFBVSxTQUFTLDZHQUE2RyxtREFBbUQsb0NBQW9DLG1CQUFtQixXQUFXLHFIQUFxSCxvQ0FBb0Msc0VBQXNFLG1HQUFtRyx3R0FBd0csU0FBUyxFQUFFLDBEQUEwRCw2TUFBNk0sbURBQW1ELGlDQUFpQyw0R0FBNEcseUZBQXlGLFNBQVMsc0JBQXNCLFFBQVEsU0FBUyxxRUFBcUUsdURBQXVELGtIQUFrSCx1QkFBdUIsU0FBUyx5RUFBeUUsZ0ZBQWdGLFNBQVMsd0VBQXdFLCtCQUErQiw0Q0FBNEMsa0NBQWtDLDRDQUE0QyxXQUFXLHNCQUFzQiw0Q0FBNEMsV0FBVyxFQUFFLFNBQVMsd0dBQXdHLHVCQUF1QixTQUFTLHNIQUFzSCw4Q0FBOEMseUVBQXlFLEdBQUcsU0FBUyxxRUFBcUUsa0NBQWtDLFdBQVcsMEhBQTBILGlFQUFpRSx5REFBeUQsV0FBVyxTQUFTLEVBQUUsUUFBUSx3REFBd0QsK0JBQStCLDJDQUEyQyx3TEFBd0wsZ0NBQWdDLFNBQVMsWUFBWSxRQUFRLG1FQUFtRSxpRUFBaUUsUUFBUSxpRUFBaUUsK0VBQStFLG1DQUFtQyxTQUFTLFFBQVEsOENBQThDLDBFQUEwRSxnRkFBZ0YsOEJBQThCLFNBQVMscUZBQXFGLHFIQUFxSCx3Q0FBd0MsaUdBQWlHLDBKQUEwSixrR0FBa0csU0FBUyxrRUFBa0UsNEVBQTRFLFNBQVMsRUFBRSx3RUFBd0UsK0JBQStCLFNBQVMsUUFBUSx3REFBd0QscUNBQXFDLCtCQUErQixxQ0FBcUMsc0VBQXNFLGdFQUFnRSw4QkFBOEIsV0FBVyxTQUFTLFFBQVEsU0FBUyxtREFBbUQsK0VBQStFLFFBQVEseURBQXlELG1FQUFtRSxzQkFBc0IsU0FBUyw0REFBNEQsMm1CQUEybUIsMkNBQTJDLDhTQUE4UyxrR0FBa0csNERBQTRELGtEQUFrRCxzQkFBc0Isa0VBQWtFLFNBQVMsdUVBQXVFLGlFQUFpRSx3REFBd0QsMExBQTBMLG1DQUFtQyxhQUFhLDRJQUE0SSxvQ0FBb0MsZUFBZSwwR0FBMEcsZ0NBQWdDLGlCQUFpQixnSEFBZ0gsNENBQTRDLGFBQWEsb0dBQW9HLGlEQUFpRCxhQUFhLGtFQUFrRSx3S0FBd0ssaUdBQWlHLHVFQUF1RSxxRUFBcUUsYUFBYSxXQUFXLHNEQUFzRCwrRkFBK0Ysa0dBQWtHLGlEQUFpRCxpQkFBaUIsMEJBQTBCLHNEQUFzRCxpQkFBaUIsZUFBZSwrQkFBK0IsZ0ZBQWdGLGVBQWUsc0NBQXNDLDJIQUEySCwwQ0FBMEMsNEJBQTRCLGVBQWUscUhBQXFILGlGQUFpRixvRkFBb0YsK0NBQStDLGdDQUFnQywrSUFBK0ksbUJBQW1CLGlCQUFpQiw2R0FBNkcsK0dBQStHLG1CQUFtQix5SEFBeUgsNEdBQTRHLHFCQUFxQixrRUFBa0UsK0RBQStELGlFQUFpRSxtREFBbUQsdUJBQXVCLGlHQUFpRyx1REFBdUQseURBQXlELG1EQUFtRCx1REFBdUQsZUFBZSx3SUFBd0ksc09BQXNPLGtEQUFrRCxnREFBZ0QsZUFBZSxtSkFBbUosc0dBQXNHLHdHQUF3RyxlQUFlLGFBQWEsMEpBQTBKLGlIQUFpSCw4RUFBOEUsOElBQThJLG9HQUFvRyx5Q0FBeUMsV0FBVyx5Q0FBeUMsdUNBQXVDLFdBQVcsK0RBQStELDJDQUEyQyxXQUFXLFNBQVMscUVBQXFFLGlDQUFpQyx3REFBd0QsV0FBVyx1SUFBdUksa0ZBQWtGLFNBQVMsNEdBQTRHLHNCQUFzQixTQUFTLG1DQUFtQyx3UUFBd1EsZ0NBQWdDLFNBQVMsc0ZBQXNGLDZEQUE2RCxhQUFhLDJDQUEyQyxrR0FBa0cscUVBQXFFLEVBQUUsaUNBQWlDLHFEQUFxRCxlQUFlLHVCQUF1QixhQUFhLEVBQUUsV0FBVyw2REFBNkQsb0JBQW9CLFFBQVEsOEhBQThILDRCQUE0QixxQkFBcUIsU0FBUywyUEFBMlAsaUNBQWlDLHlDQUF5Qyx1Q0FBdUMsU0FBUywrREFBK0Qsb0VBQW9FLHVDQUF1Qyw0REFBNEQsd0NBQXdDLGFBQWEsT0FBTyxrREFBa0QscUZBQXFGLG1GQUFtRixhQUFhLDZGQUE2Rix3RkFBd0YsMk1BQTJNLG1DQUFtQyxhQUFhLFdBQVcsU0FBUyxzQ0FBc0MscUtBQXFLLDhCQUE4QixTQUFTLHFCQUFxQixRQUFRLHFHQUFxRyxtR0FBbUcseUdBQXlHLHNGQUFzRiwrQkFBK0IsaUNBQWlDLHlEQUF5RCxPQUFPLFlBQVkseUNBQXlDLDBGQUEwRixRQUFRLG9DQUFvQyw4Q0FBOEMsa0lBQWtJLDBEQUEwRCxRQUFRLGdDQUFnQyx3Q0FBd0MsOEVBQThFLFFBQVEsK0JBQStCLHNEQUFzRCxRQUFRLFNBQVMsb0RBQW9ELHFHQUFxRyxzRkFBc0YsNk5BQTZOLHdCQUF3QixXQUFXLDhEQUE4RCxTQUFTLG9JQUFvSSxxRkFBcUYsK0NBQStDLFNBQVMsNENBQTRDLHNCQUFzQixTQUFTLGdsQkFBZ2xCLG9HQUFvRywyQkFBMkIsU0FBUyxvS0FBb0ssK0hBQStILGtHQUFrRyxzQkFBc0IsU0FBUyxxSUFBcUksNEJBQTRCLFNBQVMsK0dBQStHLHNCQUFzQixTQUFTLHFGQUFxRiwyREFBMkQsMkdBQTJHLGlIQUFpSCw0REFBNEQsV0FBVyxxREFBcUQsMkRBQTJELFdBQVcsNEtBQTRLLHlFQUF5RSxpQ0FBaUMsV0FBVyxpSEFBaUgsNERBQTRELFdBQVcsaURBQWlELHlCQUF5QixxQ0FBcUMsV0FBVywwRUFBMEUsdUpBQXVKLFdBQVcsU0FBUyxPQUFPLHNGQUFzRixnRUFBZ0UsNExBQTRMLHlEQUF5RCxrQ0FBa0MsV0FBVyxtREFBbUQsU0FBUyw2RkFBNkYsc0JBQXNCLHdHQUF3Ryx5REFBeUQsYUFBYSwyRkFBMkYsd0ZBQXdGLDhEQUE4RCxhQUFhLHlJQUF5SSxXQUFXLE9BQU8sd0RBQXdELDBJQUEwSSxFQUFFLFdBQVcsaUdBQWlHLFNBQVMsUUFBUSxpSEFBaUgsMEJBQTBCLGtCQUFrQixTQUFTLGdGQUFnRiwrQkFBK0IsNENBQTRDLDhDQUE4QyxzQkFBc0Isa0JBQWtCLGFBQWEsRUFBRSxXQUFXLHNEQUFzRCx1REFBdUQsYUFBYSxxRUFBcUUsK0RBQStELFNBQVMsc0JBQXNCLFFBQVEsMkNBQTJDLHdDQUF3QyxRQUFRLDJDQUEyQyx5Q0FBeUMsUUFBUSxTQUFTLDRDQUE0QywrQ0FBK0Msc0JBQXNCLFNBQVMsNE1BQTRNLCtIQUErSCx5RkFBeUYsK0ZBQStGLDBHQUEwRyxtREFBbUQsNERBQTRELGlCQUFpQixlQUFlLEVBQUUsMkdBQTJHLGFBQWEsZ0dBQWdHLFdBQVcsU0FBUyxzQkFBc0IsUUFBUSwyQ0FBMkMsK0NBQStDLHNCQUFzQixTQUFTLGlGQUFpRiwwRkFBMEYsc0JBQXNCLFFBQVEsU0FBUyw4Q0FBOEMsNkJBQTZCLHNCQUFzQixTQUFTLHdGQUF3RiwyRkFBMkYsU0FBUyw0RUFBNEUseUJBQXlCLFdBQVcsOEJBQThCLHVGQUF1RixTQUFTLGtDQUFrQyxvQkFBb0IsUUFBUSx3Q0FBd0MsbUNBQW1DLFFBQVEsU0FBUywrQ0FBK0MsK1BBQStQLGdDQUFnQyxtQ0FBbUMsU0FBUyxtR0FBbUcsbUNBQW1DLFNBQVMsT0FBTyx3Q0FBd0MsaUtBQWlLLHlCQUF5Qix5RUFBeUUsWUFBWSxHQUFHLFNBQVMsd0pBQXdKLGtEQUFrRCw2QkFBNkIsV0FBVyx5QkFBeUIsU0FBUyxFQUFFLFFBQVEscURBQXFELHdGQUF3Rix1QkFBdUIsU0FBUywwQ0FBMEMsdUJBQXVCLCtCQUErQixTQUFTLE9BQU8sd0JBQXdCLFNBQVMsUUFBUSxTQUFTLGlFQUFpRSxtRUFBbUUsT0FBTyw0RUFBNEUsK0tBQStLLDRDQUE0QyxvRUFBb0Usc0RBQXNELG9JQUFvSSxpQ0FBaUMseUVBQXlFLFNBQVMsa0NBQWtDLHlFQUF5RSxTQUFTLGdDQUFnQyxnRUFBZ0UsU0FBUyxRQUFRLFNBQVMsNENBQTRDLGdGQUFnRiwrREFBK0QsU0FBUyxPQUFPLDhCQUE4QixTQUFTLE9BQU8sb0NBQW9DLG9EQUFvRCxpQkFBaUIsU0FBUyxnRUFBZ0UsdUNBQXVDLCtFQUErRSxtQ0FBbUMsU0FBUywyQkFBMkIsT0FBTyxvQ0FBb0Msc0VBQXNFLGlCQUFpQixTQUFTLDBRQUEwUSxrRkFBa0YsdUNBQXVDLCtWQUErVixlQUFlLG1DQUFtQyw2Q0FBNkMsV0FBVyxhQUFhLG1CQUFtQixTQUFTLDJHQUEyRyxvQ0FBb0MsU0FBUyxpQ0FBaUMsT0FBTyx3Q0FBd0MsbUZBQW1GLGlCQUFpQixTQUFTLDhEQUE4RCw2REFBNkQsMkJBQTJCLFNBQVMsOEJBQThCLE9BQU8sMENBQTBDLCtEQUErRCxpQ0FBaUMsU0FBUyxPQUFPLCtFQUErRSw2REFBNkQsb0JBQW9CLFFBQVEsZ0dBQWdHLG9EQUFvRCxpQkFBaUIsU0FBUyxpRUFBaUUsZ0hBQWdILG9CQUFvQixRQUFRLHdEQUF3RCxvRkFBb0Ysb0JBQW9CLFFBQVEsbUZBQW1GLHlJQUF5SSxvREFBb0QsK0RBQStELFNBQVMsRUFBRSxPQUFPLDhFQUE4RSxpREFBaUQscURBQXFELHFDQUFxQywrQkFBK0Isa0VBQWtFLGdDQUFnQyw4Q0FBOEMsUUFBUSxxSEFBcUgsNEtBQTRLLGtGQUFrRiwrRkFBK0Ysd0RBQXdELG1NQUFtTSxXQUFXLEVBQUUsZ0lBQWdJLCtIQUErSCxrRkFBa0Ysa0VBQWtFLGFBQWEsRUFBRSxnSUFBZ0ksMERBQTBELFdBQVcsU0FBUyw2RkFBNkYsMERBQTBELFFBQVEsMkRBQTJELHlUQUF5VCx5S0FBeUssNkJBQTZCLFNBQVMsYUFBYSw2VEFBNlQsd0NBQXdDLFNBQVMsMlRBQTJULGtDQUFrQyx1Q0FBdUMsU0FBUyxFQUFFLHdFQUF3RSxvR0FBb0cseUJBQXlCLFdBQVcscUZBQXFGLHVEQUF1RCx1RUFBdUUsMkRBQTJELDJFQUEyRSxXQUFXLDhDQUE4QyxTQUFTLGlJQUFpSSw2QkFBNkIseUJBQXlCLFdBQVcsMkNBQTJDLFNBQVMsRUFBRSx5R0FBeUcsd0NBQXdDLFNBQVMsUUFBUSw0RUFBNEUsMG5CQUEwbkIsNkZBQTZGLGdJQUFnSSxTQUFTLEVBQUUsb0xBQW9MLDZFQUE2RSx1RkFBdUYsK0JBQStCLGFBQWEsV0FBVyxFQUFFLFNBQVMsc0ZBQXNGLHFFQUFxRSxTQUFTLGlSQUFpUiw4REFBOEQsNkNBQTZDLGFBQWEsRUFBRSxXQUFXLHdJQUF3SSxxR0FBcUcsbVBBQW1QLDRJQUE0SSwrQkFBK0IsYUFBYSxXQUFXLEVBQUUsU0FBUyx3R0FBd0csbUtBQW1LLGlKQUFpSixTQUFTLCtIQUErSCwwR0FBMEcsd0lBQXdJLGdEQUFnRCxtRkFBbUYsK0tBQStLLCtCQUErQixhQUFhLFdBQVcsZ0ZBQWdGLFNBQVMsRUFBRSw0RUFBNEUsaUZBQWlGLHNIQUFzSCx5SUFBeUksa0NBQWtDLCtCQUErQixpQkFBaUIsb0VBQW9FLGVBQWUsRUFBRSxhQUFhLGtIQUFrSCwyT0FBMk8sdUNBQXVDLGVBQWUsYUFBYSxFQUFFLFdBQVcsU0FBUyxtSUFBbUkseUdBQXlHLFNBQVMsNkhBQTZILHlGQUF5RixTQUFTLFFBQVEsMkVBQTJFLHVYQUF1WCx5Q0FBeUMsU0FBUyxFQUFFLGlHQUFpRywwREFBMEQsU0FBUyxtREFBbUQsMERBQTBELFNBQVMsZ0hBQWdILFFBQVEsdUdBQXVHLDJFQUEyRSxvTUFBb00sNENBQTRDLCtGQUErRixtTEFBbUwsV0FBVyxvQ0FBb0MsNlRBQTZULGlDQUFpQyxlQUFlLGFBQWEseUVBQXlFLFNBQVMsRUFBRSxtSUFBbUksT0FBTyxFQUFFLE9BQU8sZ0VBQWdFLG95QkFBb3lCLG9HQUFvRyx5RUFBeUUsU0FBUyxhQUFhLHdFQUF3RSw0SEFBNEgsbUlBQW1JLHVCQUF1QixzR0FBc0csZ0RBQWdELHFHQUFxRyx1Q0FBdUMsV0FBVyw0REFBNEQsMkJBQTJCLGFBQWEsU0FBUyx1RUFBdUUseUNBQXlDLFNBQVMsNENBQTRDLHdDQUF3QyxTQUFTLDZDQUE2Qyx5Q0FBeUMsU0FBUywwQ0FBMEMsa0VBQWtFLFNBQVMsNkNBQTZDLHlDQUF5QyxTQUFTLGtEQUFrRCwwREFBMEQsU0FBUyx1R0FBdUcsaUhBQWlILGtEQUFrRCxpSEFBaUgsaUNBQWlDLHVDQUF1QyxXQUFXLHVDQUF1Qyx5QkFBeUIsV0FBVyxTQUFTLDhEQUE4RCxrSEFBa0gscUtBQXFLLFNBQVMscUdBQXFHLGtDQUFrQyxtQkFBbUIsT0FBTyxxR0FBcUcsbVFBQW1RLHdGQUF3RixzQkFBc0IsU0FBUyxpRkFBaUYsbUNBQW1DLGdEQUFnRCwyQkFBMkIsNEJBQTRCLGVBQWUsZ0ZBQWdGLHdDQUF3QyxlQUFlLHVIQUF1SCwwRUFBMEUsOENBQThDLGlCQUFpQixPQUFPLCtDQUErQywrQkFBK0IsaUJBQWlCLGVBQWUsNkRBQTZELGdEQUFnRCxpQkFBaUIsYUFBYSxFQUFFLHVEQUF1RCxXQUFXLHNJQUFzSSw2RkFBNkYsWUFBWSw2Q0FBNkMsNEJBQTRCLHlIQUF5SCwrRkFBK0YsMkdBQTJHLHNDQUFzQyw4QkFBOEIsaUJBQWlCLE9BQU8scUNBQXFDLGlCQUFpQix1RUFBdUUseURBQXlELDhCQUE4QixtQkFBbUIsaUJBQWlCLEVBQUUsc0ZBQXNGLGVBQWUsRUFBRSxhQUFhLFFBQVEsd0NBQXdDLG9EQUFvRCxPQUFPLGNBQWMsK0lBQStJLDRCQUE0QiwwR0FBMEcsZ0dBQWdHLHlDQUF5Qyw4Q0FBOEMsZUFBZSwrSkFBK0osNkNBQTZDLGVBQWUsK0dBQStHLGFBQWEsV0FBVyx1RUFBdUUsU0FBUyxtSEFBbUgsZ01BQWdNLHNJQUFzSSwwRUFBMEUsNENBQTRDLGFBQWEsdUJBQXVCLFdBQVcseUJBQXlCLFNBQVMsT0FBTyx5QkFBeUIsa0RBQWtELHNCQUFzQixTQUFTLDREQUE0RCxvQ0FBb0MsMkVBQTJFLFVBQVUsT0FBTyxFQUFFLDJRQUEyUSxxREFBcUQsMENBQTBDLCtCQUErQiw2QkFBNkIsT0FBTyxzQ0FBc0MsbUJBQW1CLGtEQUFrRCxlQUFlLGFBQWEsYUFBYSxXQUFXLGtFQUFrRSxVQUFVLE9BQU8sU0FBUyxtREFBbUQsaURBQWlELHVFQUF1RSwwREFBMEQsMERBQTBELDRHQUE0RyxvR0FBb0csb0JBQW9CLHNKQUFzSixrS0FBa0ssd0RBQXdELGtDQUFrQyxtRUFBbUUsRUFBRSxXQUFXLFNBQVMsZ0JBQWdCLGlMQUFpTCxnQkFBZ0IsNk1BQTZNLGlCQUFpQix5SEFBeUgsa0JBQWtCLCtNQUErTSxRQUFRLE9BQU8saWlCQUFpaUIseUhBQXlILHNEQUFzRCxPQUFPLHdKQUF3Siw4REFBOEQsd0NBQXdDLDBNQUEwTSw2RUFBNkUsMENBQTBDLFNBQVMsb0NBQW9DLG9EQUFvRCw2Q0FBNkMsV0FBVyxTQUFTLE9BQU8sMEZBQTBGLDREQUE0RCxPQUFPLHlEQUF5RCwrREFBK0QsNEpBQTRKLDZCQUE2QixVQUFVLE9BQU8sdUNBQXVDLDBHQUEwRyw0RUFBNEUsMk1BQTJNLFdBQVcsMkRBQTJELFNBQVMscUNBQXFDLHlCQUF5QiwrQkFBK0IscUNBQXFDLG9EQUFvRCxvREFBb0QsT0FBTyxpQ0FBaUMsbUNBQW1DLDJCQUEyQixvSEFBb0gsa0RBQWtELDBCQUEwQiw2REFBNkQsMExBQTBMLHNFQUFzRSx3Q0FBd0MsMkJBQTJCLFdBQVcsT0FBTyxtRkFBbUYsR0FBRyxpREFBaUQsNExBQTRMLHNDQUFzQyxhQUFhLFlBQVksV0FBVyw2R0FBNkcseUNBQXlDLFNBQVMsc0RBQXNELDZDQUE2Qyw0Q0FBNEMsU0FBUyx3REFBd0QsNENBQTRDLDZDQUE2QyxTQUFTLGdEQUFnRCxxREFBcUQsNEtBQTRLLFNBQVMsc0RBQXNELGlEQUFpRCx5RkFBeUYsMkJBQTJCLFdBQVcsNEJBQTRCLDZDQUE2QyxXQUFXLDJCQUEyQix3Q0FBd0MsZ0NBQWdDLFdBQVcsMEJBQTBCLFNBQVMsK0RBQStELGdHQUFnRyxvTUFBb00sU0FBUyxzREFBc0QsdUhBQXVILDJKQUEySixTQUFTLHVFQUF1RSxtQ0FBbUMsaUdBQWlHLFNBQVMsd0RBQXdELCtVQUErVSw0UEFBNFAsd1RBQXdULG9JQUFvSSxrQ0FBa0MsR0FBRyx1QkFBdUIsU0FBUywwREFBMEQseWdCQUF5Z0IsbUVBQW1FLG1FQUFtRSx3RUFBd0Usb0NBQW9DLGlFQUFpRSwrQ0FBK0MsU0FBUywwR0FBMEcsNkJBQTZCLG1DQUFtQyxvUUFBb1EsNFpBQTRaLHdEQUF3RCw0QkFBNEIsNEJBQTRCLDRCQUE0Qix1Q0FBdUMsU0FBUyx1R0FBdUcsOEJBQThCLCtDQUErQywrQ0FBK0MsK0NBQStDLDhCQUE4QixTQUFTLG9DQUFvQyxxSUFBcUksK0dBQStHLHNFQUFzRSx5Q0FBeUMsV0FBVyxzRUFBc0UsNkJBQTZCLFNBQVMsb0RBQW9ELDhCQUE4Qix3QkFBd0IsV0FBVyxxZEFBcWQsaUVBQWlFLDJEQUEyRCxXQUFXLCtGQUErRiwyQkFBMkIsV0FBVywwRkFBMEYsd0NBQXdDLG1EQUFtRCw0Q0FBNEMsbUNBQW1DLGVBQWUsa0NBQWtDLG1DQUFtQyxlQUFlLGdDQUFnQyxxRUFBcUUsZUFBZSxhQUFhLDBDQUEwQywwR0FBMEcsbUNBQW1DLFdBQVcsT0FBTyxvQ0FBb0MsV0FBVyxvRkFBb0YsK0ZBQStGLHVIQUF1SCx5S0FBeUssa0NBQWtDLGFBQWEsbUtBQW1LLFdBQVcsaUVBQWlFLHVDQUF1QyxhQUFhLHNGQUFzRixtQkFBbUIsaUhBQWlILEVBQUUsdUVBQXVFLHdNQUF3TSxXQUFXLE9BQU8seU1BQXlNLFdBQVcsK0RBQStELG9HQUFvRyw4QkFBOEIsMkJBQTJCLGdEQUFnRCwwRkFBMEYsb0VBQW9FLGtJQUFrSSxpRUFBaUUsZ0ZBQWdGLDJDQUEyQywyQkFBMkIsbUdBQW1HLGdEQUFnRCwyQ0FBMkMsMkJBQTJCLFdBQVcsdURBQXVELHVGQUF1Rix3S0FBd0ssMEpBQTBKLDhDQUE4QyxpWkFBaVoscUJBQXFCLG9DQUFvQyx3RkFBd0YsZ09BQWdPLDBCQUEwQixtTkFBbU4sZUFBZSxFQUFFLGFBQWEseUpBQXlKLDhCQUE4QixzRkFBc0YsRUFBRSxXQUFXLEtBQUssMkRBQTJELDRDQUE0QyxXQUFXLFNBQVMsc0RBQXNELDhCQUE4Qix5QkFBeUIsV0FBVyxtUEFBbVAsZ0RBQWdELDZFQUE2RSx5Q0FBeUMsOEdBQThHLDZFQUE2RSxtQ0FBbUMsOEJBQThCLFdBQVcsNEVBQTRFLDBCQUEwQixvQ0FBb0MsZ0RBQWdELGtDQUFrQyx3R0FBd0csYUFBYSxPQUFPLG1FQUFtRSxvRUFBb0UsNkNBQTZDLGdHQUFnRyxhQUFhLFdBQVcsRUFBRSxrR0FBa0csb0RBQW9ELHVIQUF1SCxnQkFBZ0IsMEJBQTBCLFNBQVMscUVBQXFFLDhCQUE4QixtQkFBbUIsV0FBVyxxU0FBcVMsMkZBQTJGLDRDQUE0QyxxQkFBcUIsa0ZBQWtGLGdMQUFnTCx3RUFBd0UsYUFBYSxnREFBZ0QsK0pBQStKLGFBQWEsV0FBVyxvREFBb0QsMkNBQTJDLGdHQUFnRyxhQUFhLE9BQU8scUhBQXFILDRFQUE0RSwwQ0FBMEMsb0NBQW9DLGVBQWUsa0ZBQWtGLGFBQWEsV0FBVyx1SEFBdUgsa0dBQWtHLG1EQUFtRCx1TkFBdU4sNENBQTRDLGFBQWEsV0FBVyxnRkFBZ0YsMkZBQTJGLHdDQUF3QyxXQUFXLDhDQUE4Qyx3Q0FBd0MsV0FBVyxzQ0FBc0Msa0dBQWtHLHNDQUFzQyxXQUFXLGlFQUFpRSxzQ0FBc0MsV0FBVyxvVUFBb1UsME1BQTBNLG9KQUFvSiw0REFBNEQsdUNBQXVDLDJDQUEyQyxTQUFTLHNDQUFzQyxtRkFBbUYsd0VBQXdFLHFFQUFxRSxXQUFXLFNBQVMsT0FBTyxFQUFFLDRDQUE0QyxtREFBbUQsUUFBUSxnRUFBZ0UsZ0ZBQWdGLHNEQUFzRCx1Q0FBdUMsNkNBQTZDLHdDQUF3Qyx3Q0FBd0MsV0FBVyxnRUFBZ0UsK0JBQStCLFdBQVcsU0FBUyxRQUFRLGdFQUFnRSwwR0FBMEcsaUVBQWlFLDZEQUE2RCxTQUFTLDJFQUEyRSwrRkFBK0Ysd0JBQXdCLDZEQUE2RCxTQUFTLCtGQUErRix3QkFBd0IsU0FBUyxRQUFRLHdFQUF3RSxnQkFBZ0IsZ0JBQWdCLHNKQUFzSixTQUFTLE9BQU8sRUFBRSxPQUFPLGlIQUFpSCxzQ0FBc0MsdURBQXVELCtFQUErRSw2SUFBNkksa0dBQWtHLHlDQUF5QyxXQUFXLDZNQUE2TSxzQ0FBc0MscUNBQXFDLCtCQUErQixzRkFBc0YsMkJBQTJCLGFBQWEseURBQXlELCtDQUErQyxXQUFXLHFLQUFxSyxTQUFTLDRHQUE0Ryw2SUFBNkkseUNBQXlDLFdBQVcsb0NBQW9DLDZDQUE2QyxhQUFhLFNBQVMscUZBQXFGLHFDQUFxQyxtQkFBbUIsV0FBVyw4SkFBOEosOExBQThMLHlSQUF5UixnQ0FBZ0MsV0FBVyx3SUFBd0ksU0FBUywwQkFBMEIsaUNBQWlDLG1GQUFtRixrSEFBa0gsNkJBQTZCLGVBQWUsYUFBYSxTQUFTLG9JQUFvSSwySEFBMkgseUZBQXlGLG9DQUFvQyxlQUFlLGFBQWEsRUFBRSwwR0FBMEcsK0RBQStELG9DQUFvQyxlQUFlLGFBQWEsRUFBRSx3QkFBd0IsV0FBVyx5Q0FBeUMscUVBQXFFLHdHQUF3Ryx5RUFBeUUsdUNBQXVDLGVBQWUsRUFBRSxhQUFhLE9BQU8sa0NBQWtDLGFBQWEsV0FBVywwREFBMEQsOFhBQThYLG1FQUFtRSwyS0FBMkssdUNBQXVDLGFBQWEsZ0dBQWdHLG9EQUFvRCwyQ0FBMkMsYUFBYSwrTkFBK04sMEJBQTBCLGFBQWEsOERBQThELDRFQUE0RSx1Q0FBdUMsYUFBYSw4RkFBOEYsNkJBQTZCLGVBQWUsK0NBQStDLHdGQUF3RixpQ0FBaUMsa0NBQWtDLHFCQUFxQixtQkFBbUIsRUFBRSxpQkFBaUIsNEVBQTRFLDBDQUEwQywwQkFBMEIscUVBQXFFLEVBQUUsaURBQWlELGdDQUFnQyxpQkFBaUIseUJBQXlCLGVBQWUsRUFBRSxhQUFhLHFEQUFxRCw0RkFBNEYsNkJBQTZCLGFBQWEsMEJBQTBCLFdBQVcsU0FBUyxFQUFFLG9CQUFvQixRQUFRLGdDQUFnQyxzQ0FBc0MsK0JBQStCLDRCQUE0QixtQ0FBbUMsT0FBTyxtQ0FBbUMsbUNBQW1DLHFDQUFxQyxxRUFBcUUsd0JBQXdCLFdBQVcsNEVBQTRFLGtNQUFrTSwySUFBMkksNkNBQTZDLDhJQUE4SSxnS0FBZ0sscUJBQXFCLHlDQUF5QyxpQkFBaUIsYUFBYSxlQUFlLCtEQUErRCwyRUFBMkUsZUFBZSxhQUFhLFdBQVcsa0JBQWtCLGtIQUFrSCx5SkFBeUoscUJBQXFCLGFBQWEsdU9BQXVPLGlGQUFpRiwrRkFBK0YsaURBQWlELHVDQUF1QyxlQUFlLGFBQWEsRUFBRSx1SEFBdUgsOEZBQThGLGlEQUFpRCwrQ0FBK0MscUNBQXFDLGFBQWEsYUFBYSxXQUFXLGtCQUFrQix5SEFBeUgsOENBQThDLDJGQUEyRixhQUFhLFdBQVcsa0JBQWtCLFNBQVMsMERBQTBELDhHQUE4Ryx3QkFBd0IsV0FBVyx3RUFBd0UsU0FBUyxzQ0FBc0MsbUZBQW1GLGtGQUFrRiwyRUFBMkUsNENBQTRDLFNBQVMsT0FBTyxFQUFFLGdEQUFnRCxzREFBc0QsUUFBUSx1RUFBdUUsd0JBQXdCLHNEQUFzRCwrQkFBK0IsaURBQWlELFdBQVcsc0RBQXNELHNDQUFzQyxXQUFXLFNBQVMsUUFBUSx5SEFBeUgsZ0ZBQWdGLG1EQUFtRCwrREFBK0QsZ0RBQWdELHNCQUFzQixpSkFBaUosU0FBUyxRQUFRLHVFQUF1RSxlQUFlLGtCQUFrQixzSUFBc0ksU0FBUyxPQUFPLEVBQUUsT0FBTyxtSEFBbUgsZ2NBQWdjLDJDQUEyQyx3TUFBd00sbU9BQW1PLDBCQUEwQixTQUFTLHVGQUF1RixpRUFBaUUsb0ZBQW9GLCtGQUErRixrR0FBa0csMEJBQTBCLDJHQUEyRyx1REFBdUQsK0lBQStJLG95QkFBb3lCLG1DQUFtQyw0REFBNEQsc0pBQXNKLDBaQUEwWixXQUFXLG1DQUFtQyxzSUFBc0ksaUhBQWlILG1EQUFtRCwwQ0FBMEMsZUFBZSx3SEFBd0gscUZBQXFGLDRDQUE0QyxpQkFBaUIsdUtBQXVLLDZDQUE2QyxtQ0FBbUMsZUFBZSxhQUFhLGdEQUFnRCxTQUFTLDhHQUE4Ryw2QkFBNkIsU0FBUyxtRkFBbUYsK1FBQStRLHdCQUF3QixRQUFRLFNBQVMsdUJBQXVCLDRPQUE0Tyx3QkFBd0Isa0VBQWtFLDRHQUE0Ryx5Q0FBeUMsdU5BQXVOLDJGQUEyRix5QkFBeUIsb0ZBQW9GLG9EQUFvRCw4Q0FBOEMsYUFBYSxtREFBbUQsNkNBQTZDLGFBQWEscURBQXFELCtDQUErQyxhQUFhLGtEQUFrRCw0Q0FBNEMsYUFBYSxnQ0FBZ0MsV0FBVyw4SUFBOEksNkZBQTZGLDBFQUEwRSwrQkFBK0Isb0lBQW9JLFdBQVcsT0FBTywrS0FBK0ssa0RBQWtELG9EQUFvRCx3Q0FBd0Msb0NBQW9DLGVBQWUsK0JBQStCLG1EQUFtRCxlQUFlLE9BQU8scURBQXFELGVBQWUsdUNBQXVDLHFDQUFxQyxlQUFlLGdDQUFnQyxxREFBcUQsZUFBZSxPQUFPLHNEQUFzRCxlQUFlLGtDQUFrQyw2QkFBNkIsd0NBQXdDLHdCQUF3QixpQkFBaUIsOERBQThELDJEQUEyRCxnV0FBZ1csc0NBQXNDLGlCQUFpQixlQUFlLGFBQWEsaUNBQWlDLDhFQUE4RSxXQUFXLDBCQUEwQixTQUFTLDhDQUE4QyxrQkFBa0Isa0dBQWtHLHFGQUFxRixZQUFZLFNBQVMsbUJBQW1CLCtLQUErSyw0REFBNEQscUtBQXFLLG9CQUFvQiw0R0FBNEcscUVBQXFFLDBDQUEwQyxTQUFTLHFEQUFxRCw2REFBNkQsU0FBUyxRQUFRLE9BQU8sbURBQW1ELG1iQUFtYix3R0FBd0csaUNBQWlDLFNBQVMsa0RBQWtELHVCQUF1QixTQUFTLGdGQUFnRixzUEFBc1Asa0JBQWtCLDZMQUE2TCwwRkFBMEYsR0FBRywwRkFBMEYsRUFBRSxvRkFBb0YsV0FBVyxHQUFHLG9FQUFvRSwwREFBMEQsYUFBYSw2REFBNkQsa0JBQWtCLGlIQUFpSCxzQkFBc0IsK0ZBQStGLDJFQUEyRSxjQUFjLGtCQUFrQixTQUFTLCtEQUErRCx1QkFBdUIsMkVBQTJFLG9DQUFvQyx5Q0FBeUMsbUNBQW1DLGtDQUFrQyxvREFBb0Qsd0NBQXdDLHVDQUF1QyxTQUFTLDZLQUE2SywyR0FBMkcsOEJBQThCLDhDQUE4Qyw0Q0FBNEMsV0FBVyxTQUFTLDBGQUEwRixvREFBb0Qsa0RBQWtELHNCQUFzQixRQUFRLFNBQVMsdUVBQXVFLDJCQUEyQix5QkFBeUIsU0FBUyx3WkFBd1osNkVBQTZFLHVCQUF1QixTQUFTLDRFQUE0RSw4REFBOEQsU0FBUyxzR0FBc0csK0RBQStELFdBQVcsR0FBRyx3REFBd0QsYUFBYSwrRUFBK0UsV0FBVywyRUFBMkUsMkJBQTJCLGFBQWEsc0dBQXNHLHFGQUFxRixzRkFBc0YsK0ZBQStGLCtDQUErQyxzQkFBc0IsUUFBUSxTQUFTLDRQQUE0UCwrQkFBK0IsbUJBQW1CLFlBQVkseUJBQXlCLHdFQUF3RSxjQUFjLGlDQUFpQyx5QkFBeUIsbUNBQW1DLE9BQU8saUNBQWlDLHFDQUFxQyxtREFBbUQsMkVBQTJFLFNBQVMsb0NBQW9DLDBEQUEwRCwwRkFBMEYsbUZBQW1GLHlIQUF5SCxXQUFXLHNHQUFzRyxvREFBb0QsMEJBQTBCLG1JQUFtSSxtRkFBbUYsaUZBQWlGLFdBQVcsOENBQThDLFNBQVMsb0RBQW9ELHNFQUFzRSxzR0FBc0csc0lBQXNJLCtGQUErRixvQkFBb0IsOERBQThELDBEQUEwRCx5RkFBeUYsd0RBQXdELFdBQVcsMkVBQTJFLFNBQVMsK0VBQStFLHVEQUF1RCx3QkFBd0IsV0FBVyxvT0FBb08sc0RBQXNELGlHQUFpRyw4Q0FBOEMsV0FBVyw4QkFBOEIsNENBQTRDLFdBQVcsc0VBQXNFLG9IQUFvSCw2SEFBNkgsb0NBQW9DLDJCQUEyQixlQUFlLHFGQUFxRixrREFBa0QscUhBQXFILG9GQUFvRixnRkFBZ0YsZ0pBQWdKLG1JQUFtSSxhQUFhLG1EQUFtRCxzQkFBc0IsU0FBUyxzQ0FBc0MsNEVBQTRFLDRGQUE0RixTQUFTLE9BQU8sRUFBRSw0Q0FBNEMsb0dBQW9HLFFBQVEsa0NBQWtDLG9CQUFvQixxREFBcUQsd0JBQXdCLFNBQVMsUUFBUSxPQUFPLEtBQUssRUFBRSxHQUFHLG9CQUFvQixDOzs7Ozs7Ozs7OztBQ0F2MTFILHlDQUF5QywrRUFBK0Usa0NBQWtDLG1CQUFtQixHQUFHLEVBQUUsT0FBTyxrQ0FBa0Msa0lBQWtJLEdBQUcsRUFBRSxxQkFBcUIsRUFBRSxncUJBQWdxQix1Q0FBdUMsdURBQXVELGtGQUFrRixLQUFLLE9BQU8sOENBQThDLEtBQUssR0FBRyxnQkFBZ0Isc1dBQXNXLG9CQUFvQiwwQ0FBMEMseVNBQXlTLEtBQUssRUFBRSw4QkFBOEIsMERBQTBELDZQQUE2UCwrQkFBK0IsaUZBQWlGLHlCQUF5QixXQUFXLDBIQUEwSCxTQUFTLFFBQVEsb0hBQW9ILE9BQU8sOEJBQThCLHFCQUFxQiw0QkFBNEIsd0NBQXdDLDJCQUEyQiw0Q0FBNEMsYUFBYSxXQUFXLEVBQUUsVUFBVSxPQUFPLG9EQUFvRCxzQ0FBc0MsNkNBQTZDLHVDQUF1QyxXQUFXLFNBQVMsRUFBRSxPQUFPLEtBQUssRUFBRSxtRUFBbUUsa0dBQWtHLG9DQUFvQyxpQ0FBaUMsMkJBQTJCLG9GQUFvRix1QkFBdUIsU0FBUywyREFBMkQscUNBQXFDLE9BQU8sMFBBQTBQLEtBQUssaUNBQWlDLG9HQUFvRywwREFBMEQsT0FBTyxTQUFTLEtBQUssK0JBQStCLDJFQUEyRSxnQ0FBZ0MsMENBQTBDLFVBQVUsT0FBTyw0REFBNEQsd0NBQXdDLE9BQU8sK0NBQStDLDBFQUEwRSxPQUFPLDZDQUE2QyxpR0FBaUcsdUZBQXVGLE9BQU8sS0FBSyxFQUFFLHFFQUFxRSwwREFBMEQsZ0pBQWdKLHFLQUFxSyx1REFBdUQsb0NBQW9DLHFFQUFxRSwyQkFBMkIsa0ZBQWtGLGFBQWEsMkJBQTJCLHNFQUFzRSxhQUFhLFdBQVcsRUFBRSxzQkFBc0IsU0FBUyxvREFBb0QsbUNBQW1DLHFEQUFxRCxXQUFXLDBDQUEwQywyREFBMkQsV0FBVyxFQUFFLFVBQVUsNERBQTRELDJDQUEyQywyREFBMkQsV0FBVywwQ0FBMEMseUVBQXlFLFdBQVcsRUFBRSxVQUFVLE9BQU8sRUFBRSxLQUFLLG9EQUFvRCwwQ0FBMEMsK0ZBQStGLFFBQVEsS0FBSyxxSkFBcUosK0NBQStDLCtCQUErQixpQ0FBaUMsMkRBQTJELFdBQVcsT0FBTyx5Q0FBeUMsV0FBVyxVQUFVLE9BQU8sa0JBQWtCLEtBQUsseUZBQXlGLGlCQUFpQiw4QkFBOEIscUNBQXFDLHNFQUFzRSw0QkFBNEIsb0NBQW9DLDhCQUE4Qix5QkFBeUIsOEJBQThCLGVBQWUsYUFBYSxTQUFTLFdBQVcsZ0NBQWdDLFVBQVUsT0FBTyxrREFBa0QsK0dBQStHLDRCQUE0QixtRkFBbUYsbUNBQW1DLFdBQVcsRUFBRSxVQUFVLE9BQU8sc0RBQXNELHFEQUFxRCxPQUFPLHlDQUF5QyxvQ0FBb0MsK0NBQStDLFNBQVMsNEJBQTRCLDJFQUEyRSx5REFBeUQscVNBQXFTLHFHQUFxRyxzT0FBc08sMkJBQTJCLHdFQUF3RSxtREFBbUQsNkJBQTZCLGVBQWUsYUFBYSxtQ0FBbUMsV0FBVyxTQUFTLG1CQUFtQixPQUFPLEtBQUssRUFBRSxzRkFBc0YsOENBQThDLHlEQUF5RCwwQkFBMEIsb0RBQW9ELGtEQUFrRCxTQUFTLE9BQU8scUVBQXFFLHVEQUF1RCxxQkFBcUIsaUJBQWlCLFNBQVMsMEhBQTBILGlCQUFpQixTQUFTLHFCQUFxQixnQkFBZ0IsT0FBTyw0Q0FBNEMsb0RBQW9ELFdBQVcsU0FBUyxPQUFPLE1BQU0scVVBQXFVLHFDQUFxQywrQkFBK0IsNEJBQTRCLHFCQUFxQiwyQkFBMkIsT0FBTyxlQUFlLDZHQUE2Ryw0Q0FBNEMsaURBQWlELGFBQWEsbURBQW1ELGFBQWEsU0FBUyxzQkFBc0IsUUFBUSxLQUFLLGNBQWMsbURBQW1ELGlSQUFpUiw0Q0FBNEMsa0NBQWtDLDBDQUEwQyx5QkFBeUIseUJBQXlCLHdCQUF3QixPQUFPLGlHQUFpRyx3Q0FBd0MsUUFBUSwwQ0FBMEMsK0NBQStDLHdFQUF3RSx3RkFBd0YsbURBQW1ELFNBQVMsNktBQTZLLCtDQUErQyxTQUFTLFFBQVEsa0lBQWtJLDRLQUE0SyxtTEFBbUwsRUFBRSxpQ0FBaUMsa09BQWtPLHlCQUF5QixnREFBZ0QsbUNBQW1DLHlDQUF5QyxpQkFBaUIsU0FBUyxnREFBZ0QsMENBQTBDLCtEQUErRCxXQUFXLHlEQUF5RCwwREFBMEQsWUFBWSxnQ0FBZ0Msa0hBQWtILGlDQUFpQywyQ0FBMkMsdURBQXVELGtDQUFrQyw0Q0FBNEMsK0JBQStCLFlBQVksU0FBUyxHQUFHLE9BQU8sRUFBRSw4REFBOEQsaVNBQWlTLHFCQUFxQiw4SEFBOEgsRUFBRSxxVEFBcVQsNEVBQTRFLCtDQUErQyx1UEFBdVAsU0FBUyxFQUFFLG9NQUFvTSxPQUFPLE9BQU8sa0RBQWtELE9BQU8sMkNBQTJDLHlCQUF5QixNQUFNLDJDQUEyQyw4SUFBOEksY0FBYywwQkFBMEIsZ0JBQWdCLHdDQUF3Qyx5Q0FBeUMsK0VBQStFLHFFQUFxRSw2RUFBNkUsMEdBQTBHLFNBQVMsa0RBQWtELE9BQU8sa0NBQWtDLGFBQWEsV0FBVyxTQUFTLE9BQU8sc0JBQXNCLE1BQU0saURBQWlELDZEQUE2RCx5Q0FBeUMsMklBQTJJLDZCQUE2QixpQ0FBaUMsOEVBQThFLDZDQUE2QyxxQ0FBcUMsMkJBQTJCLGFBQWEsOEJBQThCLDZGQUE2Rix3REFBd0QsYUFBYSxvRkFBb0Ysd0dBQXdHLGFBQWEsb0VBQW9FLDBFQUEwRSx1SEFBdUgsMkJBQTJCLGFBQWEsV0FBVyxFQUFFLFNBQVMsT0FBTyxtRkFBbUYsMEVBQTBFLFdBQVcsbUNBQW1DLGtEQUFrRCw2QkFBNkIsMkNBQTJDLEVBQUUscUNBQXFDLGlDQUFpQyxlQUFlLGFBQWEsT0FBTyxnRUFBZ0UsYUFBYSxXQUFXLEVBQUUsU0FBUyw2QkFBNkIsUUFBUSxNQUFNLDZEQUE2RCx1Q0FBdUMsMEJBQTBCLDJHQUEyRyx1RUFBdUUsZ0VBQWdFLCtEQUErRCxrQ0FBa0Msa0NBQWtDLGtFQUFrRSw0QkFBNEIsNkJBQTZCLDZCQUE2QixpQ0FBaUMscURBQXFELDBDQUEwQyw0Q0FBNEMsNkNBQTZDLCtCQUErQixlQUFlLGFBQWEsV0FBVyxFQUFFLHFMQUFxTCx5RkFBeUYsU0FBUywyQ0FBMkMsbURBQW1ELHlCQUF5QixzRUFBc0UsdUJBQXVCLE9BQU8sZ0pBQWdKLHdCQUF3Qiw2VEFBNlQsMEpBQTBKLGtGQUFrRix1REFBdUQsdURBQXVELE9BQU8seURBQXlELDRCQUE0QixPQUFPLDRDQUE0QyxnRkFBZ0YsdUNBQXVDLDZGQUE2RixnQkFBZ0IsU0FBUywwQ0FBMEMsdURBQXVELE9BQU8sV0FBVyxFQUFFLHVCQUF1QixtQ0FBbUMsOEJBQThCLCtCQUErQix5REFBeUQscUJBQXFCLHlCQUF5QixzQkFBc0IsT0FBTyw4REFBOEQsOENBQThDLGFBQWEsZ0NBQWdDLDJDQUEyQywwRUFBMEUsYUFBYSxxQ0FBcUMsV0FBVyxPQUFPLHlDQUF5QyxnRkFBZ0YsYUFBYSxtQ0FBbUMsV0FBVyxTQUFTLG9DQUFvQyxzQkFBc0IsT0FBTyxtREFBbUQsZ0JBQWdCLGdDQUFnQyw2Q0FBNkMsU0FBUyxzQkFBc0IsT0FBTyxvREFBb0Qsa0NBQWtDLHFDQUFxQyxrRkFBa0YsMkZBQTJGLDJEQUEyRCwyREFBMkQsV0FBVyxTQUFTLHNCQUFzQixPQUFPLGtDQUFrQyxpQ0FBaUMsa0NBQWtDLEVBQUUsT0FBTyxvQ0FBb0MsaUNBQWlDLGlDQUFpQyxFQUFFLE9BQU8sb0VBQW9FLHdEQUF3RCxpSEFBaUgsNkJBQTZCLDBDQUEwQyx3Q0FBd0MsU0FBUyxpRkFBaUYsNkJBQTZCLGlDQUFpQywwQ0FBMEMsU0FBUyxPQUFPLGlEQUFpRCxxREFBcUQsU0FBUyxzREFBc0QsbUNBQW1DLDJUQUEyVCxxQkFBcUIsYUFBYSw4R0FBOEcsV0FBVyw2RkFBNkYsNkZBQTZGLFdBQVcsMkpBQTJKLDJCQUEyQix3RUFBd0UsV0FBVyxPQUFPLGtEQUFrRCxXQUFXLFNBQVMsRUFBRSxPQUFPLGdEQUFnRCw2R0FBNkcsd0RBQXdELGdIQUFnSCw4REFBOEQsOERBQThELE9BQU8sZ0RBQWdELGlDQUFpQywwR0FBMEcsU0FBUyw4QkFBOEIsb0RBQW9ELE9BQU8saURBQWlELHFEQUFxRCw2QkFBNkIsa0RBQWtELGdFQUFnRSxXQUFXLG1EQUFtRCxtRUFBbUUsV0FBVyxTQUFTLEVBQUUsT0FBTyxpREFBaUQscURBQXFELDZCQUE2Qiw0Q0FBNEMsZ0VBQWdFLFdBQVcsK0NBQStDLG1FQUFtRSxXQUFXLFNBQVMsRUFBRSxPQUFPLHVEQUF1RCw0RUFBNEUsMEJBQTBCLCtCQUErQiw0R0FBNEcsbUpBQW1KLDZGQUE2RixxQkFBcUIsOEJBQThCLG1DQUFtQyx1Q0FBdUMsYUFBYSxXQUFXLFNBQVMsNENBQTRDLDBJQUEwSSxPQUFPLE1BQU0sWUFBWSxtREFBbUQsb0NBQW9DLGtGQUFrRiw0Q0FBNEMscUJBQXFCLHVDQUF1QyxTQUFTLDBLQUEwSyxnQ0FBZ0MsOENBQThDLHFCQUFxQix5Q0FBeUMsU0FBUyxpREFBaUQsb0NBQW9DLDhCQUE4Qix1Q0FBdUMsU0FBUyx3RUFBd0UsbUNBQW1DLFNBQVMseURBQXlELDBFQUEwRSxTQUFTLE9BQU8seUNBQXlDLDhCQUE4Qiw2QkFBNkIsd0NBQXdDLGFBQWEscUJBQXFCLFdBQVcsRUFBRSxTQUFTLFFBQVEsS0FBSyxFQUFFLDBCQUEwQixvUkFBb1IscUNBQXFDLDJCQUEyQixLQUFLLEVBQUUsd0NBQXdDLDBDQUEwQyxtR0FBbUcsMENBQTBDLHdCQUF3Qiw4RUFBOEUsd0NBQXdDLFNBQVMsdURBQXVELHdGQUF3RixpRkFBaUYsNkNBQTZDLHlCQUF5QixXQUFXLFNBQVMsRUFBRSw2QkFBNkIsT0FBTyw0SkFBNEoscURBQXFELHdDQUF3Qyx3SkFBd0osU0FBUyxPQUFPLCtDQUErQyxzRkFBc0YsaUJBQWlCLFNBQVMsbUNBQW1DLG1HQUFtRyxxQ0FBcUMsOFRBQThULHVFQUF1RSxzQkFBc0IsU0FBUyxtREFBbUQsb0NBQW9DLDBEQUEwRCxzQ0FBc0MsV0FBVyxzQkFBc0IsU0FBUyw0RUFBNEUsaUVBQWlFLHNDQUFzQyxtQ0FBbUMsd0JBQXdCLFdBQVcsU0FBUyw4SUFBOEksK0VBQStFLFNBQVMsd0dBQXdHLHdDQUF3QyxVQUFVLG9EQUFvRCxzQ0FBc0MsVUFBVSxvSkFBb0osK0JBQStCLDRCQUE0QixvQkFBb0IsT0FBTywrQ0FBK0Msa1VBQWtVLCtLQUErSyx3Q0FBd0MsMEVBQTBFLHlCQUF5Qix3Q0FBd0MsV0FBVyxTQUFTLDRDQUE0QyxrQ0FBa0MsU0FBUyxtQ0FBbUMsaUNBQWlDLDBDQUEwQyxTQUFTLDRFQUE0RSx1RkFBdUYsNkVBQTZFLFNBQVMscUNBQXFDLE9BQU8sMkNBQTJDLHNKQUFzSixtQ0FBbUMscUNBQXFDLCtEQUErRCxpRkFBaUYsV0FBVyxtQ0FBbUMsU0FBUywrQkFBK0IscUJBQXFCLE9BQU8sNkRBQTZELHlKQUF5SixPQUFPLHdFQUF3RSxrQ0FBa0MsT0FBTyw4SUFBOEksaUVBQWlFLGlFQUFpRSxzRUFBc0Usb0JBQW9CLE9BQU8sS0FBSyxFQUFFLCtRQUErUSx3QkFBd0IsbVhBQW1YLHFEQUFxRCxpS0FBaUssT0FBTyw4Q0FBOEMsMkRBQTJELE9BQU8sc0NBQXNDLDBCQUEwQixtQ0FBbUMsa0JBQWtCLHVGQUF1Rix1REFBdUQsWUFBWSxTQUFTLGdDQUFnQyxrQkFBa0IsdUZBQXVGLHNGQUFzRixZQUFZLFNBQVMsbUNBQW1DLGtCQUFrQixnRUFBZ0UsdUVBQXVFLFlBQVksU0FBUyxrQkFBa0IsaUhBQWlILE9BQU8sc0JBQXNCLG1EQUFtRCxtREFBbUQsd0NBQXdDLFdBQVcsc0ZBQXNGLGtCQUFrQixXQUFXLFlBQVksZ0JBQWdCLDJCQUEyQixXQUFXLDZEQUE2RCxrQ0FBa0Msb0NBQW9DLDRDQUE0QyxvQ0FBb0MsNEJBQTRCLG9DQUFvQyxXQUFXLHlCQUF5QixnREFBZ0QsU0FBUyx3REFBd0Qsd2RBQXdkLGtCQUFrQixnSkFBZ0osU0FBUyx5REFBeUQsMExBQTBMLGtCQUFrQixvSkFBb0osdURBQXVELDJhQUEyYSxTQUFTLFFBQVEsNENBQTRDLHNDQUFzQyxrREFBa0QsU0FBUyxtRkFBbUYsV0FBVyx3WUFBd1ksMkNBQTJDLHlDQUF5QyxpRkFBaUYsU0FBUyx5Q0FBeUMseUNBQXlDLHlDQUF5QyxrRkFBa0YsZ0JBQWdCLDhMQUE4TCxxSEFBcUgsbUNBQW1DLHFKQUFxSixXQUFXLG9FQUFvRSxnRUFBZ0UseUVBQXlFLGdEQUFnRCwrR0FBK0csdUlBQXVJLFNBQVMsRUFBRSxxRUFBcUUsc0NBQXNDLFNBQVMsNENBQTRDLDJDQUEyQyxTQUFTLHlDQUF5QywrQ0FBK0MsU0FBUyw2Q0FBNkMsMkNBQTJDLFNBQVMseUNBQXlDLCtDQUErQyxTQUFTLHVFQUF1RSx5Q0FBeUMsd0NBQXdDLHNDQUFzQywwaEJBQTBoQix1R0FBdUcsOENBQThDLHVDQUF1QyxXQUFXLHlDQUF5QywyQ0FBMkMsV0FBVywrQ0FBK0MsdUNBQXVDLFdBQVcseUNBQXlDLDJDQUEyQyxXQUFXLHlDQUF5QyxzQ0FBc0MsMEhBQTBILGlEQUFpRCwrQ0FBK0MsV0FBVyxpQ0FBaUMsK0VBQStFLHlEQUF5RCw4Q0FBOEMsMERBQTBELDBnQkFBMGdCLEVBQUUsYUFBYSxXQUFXLEVBQUUsZ0NBQWdDLHdIQUF3SCxxUUFBcVEseUJBQXlCLGdOQUFnTiwyQkFBMkIsa01BQWtNLHdMQUF3TCxpRkFBaUYsaURBQWlELGVBQWUsb0ZBQW9GLCtDQUErQyxlQUFlLDhFQUE4RSxvREFBb0QsZUFBZSxPQUFPLGtEQUFrRCxlQUFlLDBEQUEwRCxjQUFjLFdBQVcsNENBQTRDLG1DQUFtQyxHQUFHLFNBQVMsRUFBRSxRQUFRLHlCQUF5QixjQUFjLCtDQUErQyxtYkFBbWIscUZBQXFGLHFIQUFxSCwwR0FBMEcseURBQXlELGlFQUFpRSwyQ0FBMkMsNkNBQTZDLGdGQUFnRixPQUFPLDJDQUEyQyxrRkFBa0YsaUJBQWlCLE9BQU8sK0NBQStDLGlCQUFpQixlQUFlLHVEQUF1RCx5QkFBeUIsd0NBQXdDLHVEQUF1RCwwQkFBMEIseUNBQXlDLG9EQUFvRCxPQUFPLG1GQUFtRixhQUFhLFdBQVcsOENBQThDLHNiQUFzYix3RkFBd0YsK0dBQStHLDJHQUEyRyx3REFBd0QsNkRBQTZELDJDQUEyQyw0Q0FBNEMsMEVBQTBFLE9BQU8sMkNBQTJDLG1GQUFtRixpQkFBaUIsT0FBTyw4Q0FBOEMsaUJBQWlCLGVBQWUsK0NBQStDLHdCQUF3QixzQ0FBc0MsdURBQXVELDJCQUEyQix5Q0FBeUMsb0RBQW9ELE9BQU8sK0VBQStFLGFBQWEsV0FBVyxTQUFTLGdCQUFnQiwrQ0FBK0MsMHlCQUEweUIsaUNBQWlDLDRIQUE0SCx1RUFBdUUsOERBQThELGVBQWUsYUFBYSwwQkFBMEIsMEhBQTBILHNFQUFzRSw4REFBOEQsZUFBZSxhQUFhLFdBQVcsOENBQThDLGcwQkFBZzBCLGdDQUFnQyw4SEFBOEgsd0VBQXdFLDZEQUE2RCxlQUFlLGFBQWEsMkJBQTJCLHNIQUFzSCxxRUFBcUUsNkRBQTZELGVBQWUsYUFBYSxXQUFXLFNBQVMsbUJBQW1CLGlDQUFpQywyREFBMkQsMERBQTBELFdBQVcsZ0NBQWdDLDBEQUEwRCx5REFBeUQsV0FBVyxTQUFTLFFBQVEsK0NBQStDLHdPQUF3TyxzSkFBc0osNEJBQTRCLHdKQUF3SixxQkFBcUIsc0NBQXNDLHdHQUF3RyxFQUFFLFNBQVMsdUNBQXVDLHFEQUFxRCxTQUFTLHVDQUF1Qyw2REFBNkQsa0ZBQWtGLGlEQUFpRCxvQkFBb0IsR0FBRywwQ0FBMEMscUVBQXFFLHFDQUFxQyxtREFBbUQsT0FBTyxJQUFJLEtBQUssSUFBSSxtQ0FBbUMsK1NBQStTLDBDQUEwQyxxQ0FBcUMsMkpBQTJKLG9HQUFvRywrRUFBK0UsbUJBQW1CLGlLQUFpSyxtQkFBbUIsaUtBQWlLLG9DQUFvQyxtQ0FBbUMsNENBQTRDLHNIQUFzSCx3SkFBd0osNkJBQTZCLFNBQVMsZ0NBQWdDLCtEQUErRCxnREFBZ0QsU0FBUywwQkFBMEIsT0FBTyw0REFBNEQsZ0JBQWdCLHVHQUF1RyxPQUFPLDhDQUE4Qyx1Q0FBdUMsc0JBQXNCLCtHQUErRyxxSEFBcUgsd0RBQXdELFNBQVMsT0FBTyxnREFBZ0QsMEdBQTBHLE9BQU8sc0NBQXNDLHFCQUFxQiw2SEFBNkgsMFZBQTBWLCtCQUErQiw2VUFBNlUseURBQXlELHlDQUF5QyxTQUFTLE9BQU8sb0RBQW9ELGlDQUFpQywyR0FBMkcsbUJBQW1CLFNBQVMsa0NBQWtDLG1DQUFtQyx3REFBd0QsV0FBVyxxQ0FBcUMsU0FBUyxrQ0FBa0MsK0NBQStDLHNHQUFzRyw0QkFBNEIsU0FBUyxrQ0FBa0MsK0JBQStCLHdCQUF3QixnQ0FBZ0MsV0FBVyxTQUFTLGdMQUFnTCxrR0FBa0csNEZBQTRGLFNBQVMsT0FBTywyQ0FBMkMsNENBQTRDLGlCQUFpQixTQUFTLHNLQUFzSyxrQ0FBa0MseUhBQXlILGtCQUFrQixpSUFBaUksa0JBQWtCLGtHQUFrRyxvQkFBb0Isb0VBQW9FLGtCQUFrQiw0RUFBNEUsa0JBQWtCLFNBQVMsd0JBQXdCLGlEQUFpRCwyQ0FBMkMsMEJBQTBCLGlDQUFpQyxTQUFTLE9BQU8scURBQXFELGlFQUFpRSxnREFBZ0QsU0FBUyxPQUFPLG9DQUFvQyxtQ0FBbUMsZ0NBQWdDLGdJQUFnSSxpQ0FBaUMsNEJBQTRCLHVEQUF1RCxxQ0FBcUMsNEJBQTRCLG1EQUFtRCwrRUFBK0Usc0lBQXNJLG1DQUFtQyw4QkFBOEIsc0NBQXNDLE9BQU8sNERBQTRELFdBQVcsb0RBQW9ELE9BQU8seUdBQXlHLFNBQVMsK0JBQStCLDBCQUEwQixPQUFPLGtEQUFrRCw0RUFBNEUsK0hBQStILHNMQUFzTCwwREFBMEQsbURBQW1ELG1EQUFtRCxTQUFTLE9BQU8sc0NBQXNDLGtKQUFrSiw2SkFBNkosNEVBQTRFLCtEQUErRCxpTEFBaUwsa0RBQWtELG9EQUFvRCxTQUFTLHNDQUFzQyw0Q0FBNEMsNkdBQTZHLGVBQWUsNENBQTRDLFNBQVMseUZBQXlGLG1EQUFtRCxTQUFTLE9BQU8sNEJBQTRCLGtIQUFrSCxlQUFlLGlEQUFpRCxFQUFFLFNBQVMsOEJBQThCLDJDQUEyQyx5Q0FBeUMsc0NBQXNDLGdFQUFnRSxpRkFBaUYsd0VBQXdFLHFCQUFxQixhQUFhLGtEQUFrRCxXQUFXLEVBQUUseUNBQXlDLG1EQUFtRCxXQUFXLEVBQUUsZ0RBQWdELDhGQUE4RixXQUFXLDhCQUE4QixTQUFTLHFDQUFxQyx3QkFBd0IsZ0RBQWdELG9GQUFvRixXQUFXLG9CQUFvQixTQUFTLE9BQU8sNkNBQTZDLGdEQUFnRCwyRkFBMkYsaUJBQWlCLFNBQVMscUhBQXFILDhCQUE4QixrR0FBa0csRUFBRSxPQUFPLG9EQUFvRCxnRkFBZ0YsT0FBTyxtREFBbUQsc0JBQXNCLHlDQUF5QyxzQkFBc0Isa0VBQWtFLGtEQUFrRCxXQUFXLEVBQUUsU0FBUywyREFBMkQseUNBQXlDLHlDQUF5Qyw2Q0FBNkMsRUFBRSx3Q0FBd0Msd0NBQXdDLE9BQU8scURBQXFELDJWQUEyViwySUFBMkksK0JBQStCLHFOQUFxTixpQkFBaUIsU0FBUyw0RUFBNEUsNEtBQTRLLGtDQUFrQyxtTEFBbUwsOEJBQThCLGdJQUFnSSxTQUFTLGlDQUFpQyx3SEFBd0gsZ0NBQWdDLG1JQUFtSSxXQUFXLHFFQUFxRSxTQUFTLE9BQU8sd0NBQXdDLDZHQUE2RyxxSUFBcUksK0JBQStCLCtCQUErQixxQ0FBcUMsOENBQThDLFNBQVMsT0FBTyx3QkFBd0Isd0JBQXdCLHVDQUF1QyxTQUFTLHVCQUF1Qiw0Q0FBNEMsRUFBRSw0QkFBNEIsc0ZBQXNGLEVBQUUscVNBQXFTLDhCQUE4QixnRkFBZ0YsRUFBRSxTQUFTLDBCQUEwQiwyQ0FBMkMsa0VBQWtFLFdBQVcseUJBQXlCLFNBQVMsK0RBQStELDBHQUEwRyxFQUFFLE9BQU8sMERBQTBELG9TQUFvUyxtR0FBbUcscUNBQXFDLFVBQVUsOENBQThDLDZCQUE2QixTQUFTLDhDQUE4QywyQkFBMkIsU0FBUyx3SUFBd0ksb0VBQW9FLCtCQUErQiw0RUFBNEUsU0FBUywrQkFBK0IsNEVBQTRFLFNBQVMsOENBQThDLHdDQUF3Qyw4RkFBOEYscUNBQXFDLFdBQVcsU0FBUyxFQUFFLCtDQUErQywySEFBMkgscUNBQXFDLDJDQUEyQyxrREFBa0QsaUNBQWlDLGVBQWUsYUFBYSxxREFBcUQseUVBQXlFLHlCQUF5QixhQUFhLFdBQVcsU0FBUyxFQUFFLE9BQU8sd0RBQXdELG1DQUFtQyw4SEFBOEgsNkVBQTZFLHNFQUFzRSxTQUFTLGtEQUFrRCxPQUFPLEtBQUssRUFBRSwyUkFBMlIsMEZBQTBGLGdCQUFnQixpREFBaUQsaUVBQWlFLGlFQUFpRSw4R0FBOEcsb0NBQW9DLHVDQUF1QywrSUFBK0ksaUtBQWlLLGdFQUFnRSxFQUFFLHNDQUFzQyx5RkFBeUYsU0FBUyxvQkFBb0IsNk5BQTZOLG1DQUFtQyxXQUFXLHFFQUFxRSx5Q0FBeUMsb0ZBQW9GLGlDQUFpQywySEFBMkgseUNBQXlDLGVBQWUsaUZBQWlGLG1DQUFtQyxlQUFlLDJHQUEyRyxxR0FBcUcsc09BQXNPLDJDQUEyQyxpQkFBaUIsZUFBZSxhQUFhLFdBQVcsK0VBQStFLHVQQUF1UCxxQkFBcUIsYUFBYSxrREFBa0QsOFBBQThQLHNDQUFzQyxXQUFXLGtKQUFrSixnTUFBZ00sb0NBQW9DLHNDQUFzQyxhQUFhLFdBQVcsdUNBQXVDLHFDQUFxQyxpRkFBaUYsd0NBQXdDLGVBQWUsYUFBYSxFQUFFLFdBQVcseUNBQXlDLEVBQUUseUJBQXlCLHVGQUF1Rix3Q0FBd0Msb0RBQW9ELHNDQUFzQyxhQUFhLHlFQUF5RSxXQUFXLFNBQVMsRUFBRSxPQUFPLHNDQUFzQywrWEFBK1gsZ1RBQWdULDZCQUE2Qix1REFBdUQsMEJBQTBCLFdBQVcsU0FBUyxFQUFFLDhIQUE4SCxPQUFPLDJDQUEyQyw0R0FBNEcsa0NBQWtDLHlFQUF5RSxrQkFBa0IseUVBQXlFLGtCQUFrQix1RkFBdUYsb0JBQW9CLG9GQUFvRixvQkFBb0Isa0VBQWtFLGtCQUFrQixnRUFBZ0Usa0JBQWtCLG9FQUFvRSxrQkFBa0IsNkdBQTZHLGlDQUFpQyxhQUFhLG9CQUFvQix3R0FBd0csb0JBQW9CLHNFQUFzRSxrQkFBa0IsdURBQXVELCtDQUErQywyREFBMkQseUJBQXlCLDJDQUEyQyx1Q0FBdUMsMEJBQTBCLGFBQWEsT0FBTywyQ0FBMkMsYUFBYSx1REFBdUQsb0hBQW9ILG9NQUFvTSw2REFBNkQsdURBQXVELGFBQWEsaUNBQWlDLHVDQUF1Qyw4Q0FBOEMsMERBQTBELDJDQUEyQyxlQUFlLFFBQVEsYUFBYSxPQUFPLHlDQUF5QyxhQUFhLFdBQVcsK0JBQStCLGlDQUFpQyxTQUFTLE9BQU8sNkNBQTZDLHNEQUFzRCwyREFBMkQsK0JBQStCLFdBQVcsT0FBTywrQkFBK0IsV0FBVyxTQUFTLE9BQU8sb0NBQW9DLHVLQUF1Syw4RkFBOEYsaUpBQWlKLHFIQUFxSCxvQkFBb0IsNExBQTRMLHVFQUF1RSw0REFBNEQsU0FBUyxFQUFFLDJDQUEyQywrQ0FBK0MsbUlBQW1JLDZCQUE2Qix3Q0FBd0MsaUVBQWlFLFdBQVcsU0FBUyxFQUFFLDBKQUEwSixnRUFBZ0UsRUFBRSwwSUFBMEksa0lBQWtJLHNCQUFzQixTQUFTLE9BQU8sd0NBQXdDLGdCQUFnQixtRUFBbUUsb0JBQW9CLE9BQU8sb0RBQW9ELGdDQUFnQywrR0FBK0csU0FBUyxxQ0FBcUMsa0dBQWtHLFNBQVMsa0NBQWtDLE9BQU8sMkNBQTJDLDRCQUE0Qiw0REFBNEQscUNBQXFDLHFDQUFxQyw0RkFBNEYsa0pBQWtKLDZFQUE2RSxTQUFTLHVJQUF1SSxvREFBb0Qsd0JBQXdCLFNBQVMsT0FBTyxnREFBZ0QsMEJBQTBCLFdBQVcsY0FBYyxTQUFTLCtDQUErQyxvRUFBb0UscUNBQXFDLFNBQVMsMENBQTBDLDJDQUEyQyw2QkFBNkIsRUFBRSxPQUFPLHdEQUF3RCw2RUFBNkUsa0NBQWtDLHFGQUFxRixrRkFBa0YsNkZBQTZGLCtDQUErQyxtREFBbUQsMENBQTBDLDZCQUE2Qix1REFBdUQsV0FBVyxnREFBZ0Qsb0ZBQW9GLFdBQVcsU0FBUyxPQUFPLDhDQUE4Qyx5QkFBeUIsbUNBQW1DLFNBQVMsNkJBQTZCLGlCQUFpQixTQUFTLHNEQUFzRCwyQkFBMkIsMENBQTBDLG9DQUFvQyxFQUFFLE9BQU8sdURBQXVELGlDQUFpQyw2TUFBNk0saUJBQWlCLFNBQVMsZ0RBQWdELHdCQUF3QixnQ0FBZ0MsU0FBUyxjQUFjLE9BQU8sdUNBQXVDLGlDQUFpQyxrQ0FBa0MseUJBQXlCLGlDQUFpQyxrSEFBa0gsd0dBQXdHLE9BQU8sc0RBQXNELGlDQUFpQyw4Q0FBOEMsd01BQXdNLGdJQUFnSSx1Q0FBdUMsV0FBVyxxQ0FBcUMsNkJBQTZCLHdDQUF3QyxTQUFTLGNBQWMsT0FBTyxrTkFBa04seUJBQXlCLHdFQUF3RSxTQUFTLDRNQUE0TSxPQUFPLHFFQUFxRSw2REFBNkQsT0FBTyw4Q0FBOEMscUdBQXFHLE9BQU8sMkNBQTJDLG1HQUFtRywwQ0FBMEMsd0JBQXdCLHVDQUF1QyxTQUFTLE9BQU8sdUNBQXVDLDBHQUEwRywwQ0FBMEMsdUNBQXVDLDhIQUE4SCx1Q0FBdUMsV0FBVyxFQUFFLFNBQVMsT0FBTyxtQ0FBbUMsK0NBQStDLE9BQU8sMkNBQTJDLDhDQUE4QyxPQUFPLDRDQUE0Qyw2RUFBNkUsT0FBTywwQ0FBMEMsNkVBQTZFLE9BQU8sd0RBQXdELGlCQUFpQiw0QkFBNEIsa0VBQWtFLDhHQUE4RyxXQUFXLE9BQU8sNkVBQTZFLFdBQVcsU0FBUyxzREFBc0Qsb0VBQW9FLFNBQVMsa0NBQWtDLE9BQU8sMkNBQTJDLCtCQUErQiw2QkFBNkIsMkJBQTJCLGlCQUFpQixTQUFTLGtDQUFrQyxpQkFBaUIsU0FBUyxrQ0FBa0MsMENBQTBDLHlDQUF5QyxtRUFBbUUsMkJBQTJCLHlEQUF5RCxXQUFXLEVBQUUsa0NBQWtDLFNBQVMsT0FBTyw2R0FBNkcsU0FBUyxPQUFPLG1EQUFtRCwrQkFBK0IsNkJBQTZCLDJCQUEyQixpQkFBaUIsU0FBUyxtQ0FBbUMsaUJBQWlCLFNBQVMsa0NBQWtDLDBDQUEwQyx5Q0FBeUMsbUVBQW1FLDJCQUEyQix5REFBeUQsV0FBVyxFQUFFLGtDQUFrQyxTQUFTLE9BQU8sOEVBQThFLFNBQVMsT0FBTywwQ0FBMEMsZ0ZBQWdGLE9BQU8sdUNBQXVDLHFPQUFxTyxrQkFBa0IscUNBQXFDLHNEQUFzRCx3Q0FBd0MsU0FBUywrQ0FBK0MsT0FBTywrREFBK0QsOERBQThELHFHQUFxRyw2S0FBNkssb0RBQW9ELFNBQVMsRUFBRSxPQUFPLEtBQUssRUFBRSx3U0FBd1MsNEVBQTRFLDJHQUEyRywrRkFBK0YsaU1BQWlNLDJFQUEyRSwyckJBQTJyQixvWEFBb1gsb0ZBQW9GLDhCQUE4Qix5RkFBeUYsa0NBQWtDLDRDQUE0QyxrREFBa0Qsc0NBQXNDLG1DQUFtQyw0Q0FBNEMscUJBQXFCLGFBQWEsdUNBQXVDLGtDQUFrQywyQ0FBMkMsdUNBQXVDLHNDQUFzQywyRUFBMkUsc0RBQXNELHdCQUF3QiwrRUFBK0Usa0RBQWtELHdCQUF3Qix3RUFBd0Usc0RBQXNELHdCQUF3QiwwRUFBMEUsa0RBQWtELHdCQUF3Qiw0SEFBNEgsZ0tBQWdLLHlDQUF5QywwQ0FBMEMsaUJBQWlCLHdCQUF3Qix3RUFBd0UsMENBQTBDLGlCQUFpQix3QkFBd0IsNkZBQTZGLDBDQUEwQywyQ0FBMkMsbUJBQW1CLHNDQUFzQyxzT0FBc08saUJBQWlCLHdCQUF3QixzRUFBc0UscUhBQXFILHdCQUF3QixhQUFhLFdBQVcsK0NBQStDLG1DQUFtQyx1Q0FBdUMsOEVBQThFLHVDQUF1QyxlQUFlLHVCQUF1QixhQUFhLDJDQUEyQyxxQkFBcUIsYUFBYSx1SEFBdUgsc0NBQXNDLHVGQUF1Rix3QkFBd0IsdUZBQXVGLHdCQUF3QixvRkFBb0Ysd0JBQXdCLGtGQUFrRix3QkFBd0IsYUFBYSxXQUFXLHlDQUF5QyxnQ0FBZ0Msb0NBQW9DLHFDQUFxQyxxQkFBcUIsYUFBYSx5Q0FBeUMsV0FBVyxvQ0FBb0MscUNBQXFDLDBDQUEwQyxXQUFXLHVDQUF1QyxrQ0FBa0MscUNBQXFDLHFCQUFxQixhQUFhLDJDQUEyQyw4QkFBOEIsa0NBQWtDLFdBQVcsU0FBUyxFQUFFLDZCQUE2QiwwR0FBMEcsa0dBQWtHLDRCQUE0Qix1Q0FBdUMsZ0RBQWdELDRGQUE0RixxTEFBcUwsdUNBQXVDLHFDQUFxQyxhQUFhLEVBQUUsa1ZBQWtWLHVFQUF1RSx1Q0FBdUMsZ0NBQWdDLG1FQUFtRSxtSUFBbUksaUNBQWlDLG1CQUFtQixpQkFBaUIsRUFBRSxlQUFlLEVBQUUsYUFBYSxXQUFXLHFEQUFxRCw0QkFBNEIsMElBQTBJLHFDQUFxQyxxRkFBcUYsaUNBQWlDLDhEQUE4RCwrREFBK0QsaUJBQWlCLEVBQUUsdUJBQXVCLGVBQWUsYUFBYSw0REFBNEQsNkRBQTZELHFDQUFxQyxJQUFJLHlLQUF5Syx3Q0FBd0MsZUFBZSxhQUFhLDJHQUEyRyxrREFBa0QsZ0RBQWdELGlFQUFpRSxhQUFhLFdBQVcsdURBQXVELHVHQUF1RywySEFBMkgsbUNBQW1DLHVDQUF1Qyw0TkFBNE4seUNBQXlDLHlDQUF5QyxlQUFlLEVBQUUsYUFBYSw4REFBOEQscUNBQXFDLElBQUksc0NBQXNDLGFBQWEscUpBQXFKLDhCQUE4QixxQ0FBcUMsV0FBVyxTQUFTLEVBQUUsMkNBQTJDLHFIQUFxSCw0RUFBNEUsNlBBQTZQLGlEQUFpRCxzREFBc0QsV0FBVyxTQUFTLEVBQUUsT0FBTyxzQ0FBc0MscUNBQXFDLHlGQUF5RixtQ0FBbUMsaUNBQWlDLE9BQU8sb0RBQW9ELGdDQUFnQyxtQ0FBbUMsNkJBQTZCLFNBQVMscUNBQXFDLHVEQUF1RCxTQUFTLDBEQUEwRCwyQkFBMkIsU0FBUyxPQUFPLHdDQUF3Qyw0Q0FBNEMsd0JBQXdCLHdHQUF3RyxTQUFTLHdDQUF3Qyx3REFBd0QsU0FBUyxnQ0FBZ0MsMENBQTBDLFNBQVMseUJBQXlCLE9BQU8sNENBQTRDLDBEQUEwRCwrQ0FBK0Msc0NBQXNDLHdEQUF3RCxvRUFBb0UsWUFBWSxTQUFTLHNEQUFzRCxvQ0FBb0Msd0RBQXdELDJCQUEyQiwrQkFBK0IsYUFBYSxpQ0FBaUMsbUlBQW1JLCtCQUErQixlQUFlLHdDQUF3Qyw2QkFBNkIsZUFBZSxhQUFhLEVBQUUsWUFBWSxTQUFTLE9BQU8sNENBQTRDLFNBQVMsT0FBTyx1REFBdUQscUNBQXFDLGtEQUFrRCxtVEFBbVQsOEVBQThFLHFDQUFxQyxxQ0FBcUMsV0FBVyxTQUFTLHNCQUFzQixPQUFPLDhDQUE4QyxzREFBc0QsdUdBQXVHLHNEQUFzRCxtQ0FBbUMsU0FBUywyREFBMkQsaUJBQWlCLFNBQVMscUNBQXFDLE9BQU8seUNBQXlDLHVCQUF1QiwyREFBMkQsa0NBQWtDLHFCQUFxQiw4QkFBOEIsb0JBQW9CLE9BQU8sd0NBQXdDLHdDQUF3QywyQ0FBMkMsNENBQTRDLHFDQUFxQyxXQUFXLDJCQUEyQixnQ0FBZ0Msa0VBQWtFLFdBQVcsU0FBUyxRQUFRLE9BQU8saURBQWlELHNCQUFzQiw2Q0FBNkMsU0FBUyw2Q0FBNkMsbUNBQW1DLEVBQUUsMEZBQTBGLGlDQUFpQyxvQ0FBb0MsU0FBUyxPQUFPLHlHQUF5RyxTQUFTLE9BQU8scUNBQXFDLGlDQUFpQyw2QkFBNkIsT0FBTyx1Q0FBdUMsaURBQWlELG1DQUFtQywyQkFBMkIsZ0NBQWdDLDRDQUE0QyxTQUFTLE9BQU8seUNBQXlDLDhDQUE4Qyw0Q0FBNEMsOENBQThDLEVBQUUsU0FBUyxPQUFPLCtDQUErQyxnSkFBZ0osdUJBQXVCLFNBQVMsK0NBQStDLDJDQUEyQyxvQkFBb0IsaUVBQWlFLFdBQVcsOEJBQThCLFNBQVMsa0dBQWtHLEVBQUUsU0FBUyxFQUFFLE9BQU8sMkNBQTJDLDJDQUEyQyxzQ0FBc0MsZ0NBQWdDLDRCQUE0Qiw4Q0FBOEMsNkJBQTZCLGdDQUFnQyxtQ0FBbUMsMEJBQTBCLHVDQUF1QywyQkFBMkIsU0FBUyxPQUFPLDRDQUE0QyxtQ0FBbUMsK01BQStNLE9BQU8scURBQXFELHdCQUF3Qiw4Q0FBOEMseUNBQXlDLFNBQVMsRUFBRSxPQUFPLDREQUE0RCwrRUFBK0UsT0FBTyxvREFBb0QseURBQXlELE9BQU8sZ0RBQWdELGtEQUFrRCxtQ0FBbUMsaUJBQWlCLFNBQVMsNEhBQTRILGtDQUFrQyxtQ0FBbUMsV0FBVyw2QkFBNkIsaUJBQWlCLFNBQVMsc0NBQXNDLE9BQU8sa0NBQWtDLGlDQUFpQyxPQUFPLGtDQUFrQywrREFBK0QsT0FBTyx1REFBdUQsc0VBQXNFLHNDQUFzQyxtSEFBbUgsU0FBUyxPQUFPLEtBQUssRUFBRSxpQ0FBaUMsZ0RBQWdELDBDQUEwQyxxQ0FBcUMsT0FBTyw2Q0FBNkMsNkVBQTZFLCtDQUErQyxtRUFBbUUsU0FBUyxFQUFFLE9BQU8sS0FBSyxFQUFFLHlQQUF5UCxnQkFBZ0IsbUJBQW1CLHlGQUF5Rix1SUFBdUksV0FBVyxTQUFTLE9BQU8saURBQWlELG9CQUFvQixzQ0FBc0MsMkRBQTJELGlCQUFpQixTQUFTLDBDQUEwQyxrRUFBa0UsU0FBUyxPQUFPLG9EQUFvRCxTQUFTLDRDQUE0Qyw2REFBNkQsT0FBTyxLQUFLLEVBQUUseUNBQXlDLHVqQkFBdWpCLHlCQUF5Qiw4QkFBOEIsc0RBQXNELE9BQU8sS0FBSyxLQUFLLGtEQUFrRCxpRkFBaUYsbUJBQW1CLDZDQUE2QyxxQkFBcUIseUVBQXlFLFNBQVMsT0FBTyx1R0FBdUcsOEJBQThCLFdBQVcsRUFBRSxTQUFTLE9BQU8sc0JBQXNCLE1BQU0sK0JBQStCLDZFQUE2RSw4RUFBOEUsMERBQTBELE9BQU8sb0NBQW9DLHVJQUF1SSw2REFBNkQsb0VBQW9FLFNBQVMsT0FBTyxpRUFBaUUsU0FBUyxzQ0FBc0MsK0RBQStELGlOQUFpTix1Q0FBdUMseUdBQXlHLFNBQVMsOENBQThDLHNJQUFzSSxpQ0FBaUMsbUJBQW1CLFdBQVcsc0NBQXNDLGtEQUFrRCxXQUFXLFNBQVMsMERBQTBELGlDQUFpQyxtQkFBbUIsV0FBVyw2Q0FBNkMsU0FBUywwREFBMEQsaUNBQWlDLG1DQUFtQyw2Q0FBNkMsV0FBVyxTQUFTLEVBQUUsaUtBQWlLLG1DQUFtQyw0REFBNEQsV0FBVyxrQ0FBa0MsK0RBQStELFdBQVcsU0FBUyxFQUFFLDZCQUE2QiwyRUFBMkUsMkJBQTJCLFdBQVcsRUFBRSxTQUFTLDJDQUEyQyxnRkFBZ0YsbUNBQW1DLDJCQUEyQixhQUFhLFdBQVcsRUFBRSxTQUFTLG9DQUFvQyxnRkFBZ0YsbUNBQW1DLDJCQUEyQixhQUFhLG9EQUFvRCxnRUFBZ0Usd0NBQXdDLDBEQUEwRCxtREFBbUQsYUFBYSxxRUFBcUUsV0FBVyxFQUFFLFNBQVMsT0FBTyxvRkFBb0YsbUNBQW1DLDJCQUEyQixhQUFhLG9EQUFvRCw4QkFBOEIsd0RBQXdELGdDQUFnQyxhQUFhLEVBQUUsV0FBVyx1REFBdUQsbUNBQW1DLDJCQUEyQixhQUFhLHVEQUF1RCxXQUFXLDREQUE0RCxtQ0FBbUMsMkJBQTJCLGFBQWEsaUdBQWlHLG9EQUFvRCxhQUFhLFdBQVcsMFBBQTBQLHFEQUFxRCxXQUFXLEVBQUUsK0NBQStDLHVEQUF1RCx5REFBeUQsaUlBQWlJLGVBQWUsYUFBYSxFQUFFLFdBQVcsU0FBUywwREFBMEQsOEJBQThCLE9BQU8sOERBQThELDZDQUE2QyxxREFBcUQsbUNBQW1DLFNBQVMsOENBQThDLGdDQUFnQyxTQUFTLHVDQUF1QyxnQ0FBZ0MsU0FBUyxPQUFPLGlDQUFpQyxTQUFTLHNFQUFzRSxpS0FBaUssK0VBQStFLDREQUE0RCw2Q0FBNkMsdUZBQXVGLGdFQUFnRSwrQ0FBK0MsZ0VBQWdFLGFBQWEsV0FBVyxtRUFBbUUsa0RBQWtELDBCQUEwQiw2REFBNkQsV0FBVywrREFBK0QsU0FBUyxPQUFPLDRDQUE0QyxTQUFTLE9BQU8sa0NBQWtDLGtDQUFrQyxPQUFPLHNDQUFzQyxrRUFBa0Usc01BQXNNLCtCQUErQixtREFBbUQsU0FBUyxPQUFPLG9EQUFvRCxnQ0FBZ0MscUNBQXFDLG9FQUFvRSxtREFBbUQsd0JBQXdCLHdFQUF3RSxpRUFBaUUsYUFBYSxPQUFPLGlGQUFpRixhQUFhLFdBQVcsbUJBQW1CLFNBQVMsOEJBQThCLE9BQU8sb0NBQW9DLHdLQUF3SyxxREFBcUQsb0RBQW9ELFNBQVMsd0NBQXdDLHdEQUF3RCwyQ0FBMkMsd0dBQXdHLGFBQWEsT0FBTyw0R0FBNEcsYUFBYSxXQUFXLEVBQUUsU0FBUyx1Q0FBdUMsOENBQThDLDhGQUE4RixXQUFXLE9BQU8sa0dBQWtHLFdBQVcsU0FBUyxPQUFPLDhDQUE4QyxzQ0FBc0MsbUNBQW1DLGlEQUFpRCxXQUFXLG1CQUFtQixTQUFTLDBXQUEwVyxpREFBaUQsa0NBQWtDLGtJQUFrSSxXQUFXLGdDQUFnQyxvSEFBb0gsV0FBVyxrQ0FBa0MsdUhBQXVILFdBQVcscUNBQXFDLG1HQUFtRyxtQ0FBbUMsZ0VBQWdFLGFBQWEsV0FBVyxTQUFTLE9BQU8sc0RBQXNELFNBQVMsNERBQTRELE9BQU8sS0FBSyxFQUFFLGdDQUFnQywwQ0FBMEMseUpBQXlKLG9DQUFvQyxnREFBZ0QsT0FBTyxnQ0FBZ0MsdUJBQXVCLE9BQU8sb0RBQW9ELG1DQUFtQyxzREFBc0QsU0FBUyxrQ0FBa0MsT0FBTyxvQ0FBb0MsNkxBQTZMLDRFQUE0RSwwRUFBMEUsbURBQW1ELCtDQUErQyxTQUFTLHlPQUF5TyxPQUFPLHNDQUFzQyxtREFBbUQsc0NBQXNDLCtDQUErQyxTQUFTLDRFQUE0RSxPQUFPLEtBQUssRUFBRSw2QkFBNkIscVJBQXFSLG1CQUFtQixrQ0FBa0MsS0FBSyxFQUFFLDhCQUE4QiwyQ0FBMkMsMEJBQTBCLHFEQUFxRCxxUkFBcVIsaUdBQWlHLHNOQUFzTiwyQkFBMkIsb0VBQW9FLCtDQUErQyx5QkFBeUIsV0FBVyxTQUFTLCtCQUErQixPQUFPLGlCQUFpQixLQUFLLDRTQUE0UywyQkFBMkIsOERBQThELHVFQUF1RSw4RkFBOEYscUZBQXFGLHFHQUFxRywrRkFBK0YsNEZBQTRGLDhGQUE4Riw2RkFBNkYsK0ZBQStGLG1IQUFtSCw2R0FBNkcsMEdBQTBHLHFFQUFxRSx3RkFBd0Ysa2tEQUFra0Qsd0JBQXdCLCtSQUErUiw4b0hBQThvSCxvREFBb0QsMENBQTBDLHVCQUF1QixrREFBa0Qsb0JBQW9CLDhLQUE4SyxLQUFLLHNDQUFzQyxxVkFBcVYsMEJBQTBCLE9BQU8sd1FBQXdRLDhEQUE4RCxFQUFFLG9CQUFvQixPQUFPLDJUQUEyVCxtQ0FBbUMsaURBQWlELCtEQUErRCwyQkFBMkIseUJBQXlCLHlDQUF5QyxTQUFTLGtEQUFrRCxtQ0FBbUMsZ0JBQWdCLEVBQUUsdUNBQXVDLGdEQUFnRCxTQUFTLG1CQUFtQiwrQ0FBK0MsU0FBUyxPQUFPLCtGQUErRiw2RUFBNkUsOENBQThDLHFpQkFBcWlCLE9BQU8sNkhBQTZILDhCQUE4Qiw0QkFBNEIsNkJBQTZCLHFEQUFxRCxpQkFBaUIsU0FBUyx5Q0FBeUMsd0hBQXdILCtCQUErQiwrQ0FBK0Msc0pBQXNKLDBDQUEwQyxTQUFTLE9BQU8sMEdBQTBHLDBLQUEwSyw0QkFBNEIsK0JBQStCLFNBQVMsMkJBQTJCLHFHQUFxRyw2REFBNkQsU0FBUyx3REFBd0QsNkJBQTZCLGdDQUFnQyxTQUFTLCtDQUErQyw0REFBNEQsb0dBQW9HLFNBQVMsNkRBQTZELDBHQUEwRyx5REFBeUQsbUhBQW1ILGlHQUFpRyw2SEFBNkgsaUdBQWlHLElBQUksOERBQThELDBDQUEwQywwRkFBMEYsNkNBQTZDLGFBQWEsb0ZBQW9GLDZDQUE2Qyx1REFBdUQsYUFBYSxPQUFPLHFEQUFxRCxhQUFhLDJCQUEyQixXQUFXLEVBQUUsU0FBUyxPQUFPLHVHQUF1Ryw0REFBNEQsdU5BQXVOLDJDQUEyQywrQ0FBK0Msc0JBQXNCLHVCQUF1QiwyQkFBMkIsa0JBQWtCLE9BQU8sNENBQTRDLHdDQUF3QywyQkFBMkIsaUJBQWlCLGVBQWUsNEJBQTRCLGNBQWMscUhBQXFILG1JQUFtSSxXQUFXLDJFQUEyRSxTQUFTLE9BQU8sd0hBQXdILGdDQUFnQyx1REFBdUQsaUJBQWlCLFNBQVMsb0VBQW9FLDZDQUE2QyxnRUFBZ0UsdUNBQXVDLHNDQUFzQyxtSUFBbUksMENBQTBDLFNBQVMsd1BBQXdQLE9BQU8scXFCQUFxcUIsOElBQThJLDJDQUEyQyx5QkFBeUIsa0NBQWtDLGlHQUFpRyxhQUFhLFlBQVksT0FBTyx1REFBdUQsa0RBQWtELDRFQUE0RSw2QkFBNkIsNkRBQTZELFNBQVMsK0RBQStELEVBQUUsdUZBQXVGLHNDQUFzQyw2RUFBNkUsMkJBQTJCLDhEQUE4RCxnRUFBZ0Usb0ZBQW9GLGtGQUFrRiw2SUFBNkksU0FBUyx3S0FBd0ssNENBQTRDLDhCQUE4QiwrQ0FBK0MscURBQXFELDBCQUEwQixnQ0FBZ0MsU0FBUyw2REFBNkQsb0JBQW9CLE9BQU8sc01BQXNNLHVHQUF1Ryx3REFBd0QsaUJBQWlCLFNBQVMsbURBQW1ELDZDQUE2Qyx1Q0FBdUMsK0JBQStCLGdDQUFnQyx5TUFBeU0sU0FBUywwREFBMEQsNERBQTRELFNBQVMsK0NBQStDLHVDQUF1QyxTQUFTLE9BQU8sNE1BQTRNLDBIQUEwSCx3REFBd0QsaUJBQWlCLFNBQVMsbURBQW1ELHVDQUF1QyxrQ0FBa0MsNERBQTRELGtDQUFrQyxXQUFXLDZCQUE2QixnRUFBZ0UsRUFBRSxTQUFTLDBEQUEwRCwrREFBK0QsK0RBQStELDJHQUEyRyxTQUFTLCtFQUErRSxpREFBaUQsU0FBUyxFQUFFLHVCQUF1QiwrTUFBK00sMEhBQTBILHdEQUF3RCxpQkFBaUIsU0FBUyxtREFBbUQsdUNBQXVDLGlDQUFpQyw0REFBNEQsaUNBQWlDLFdBQVcsNkJBQTZCLHVFQUF1RSxFQUFFLFNBQVMsMERBQTBELCtEQUErRCw0REFBNEQsMEdBQTBHLFNBQVMsK0VBQStFLGlEQUFpRCxTQUFTLEVBQUUscUZBQXFGLE9BQU8sdVNBQXVTLHNCQUFzQix1QkFBdUIsU0FBUyx5QkFBeUIsaUNBQWlDLE9BQU8sbURBQW1ELHdCQUF3QixXQUFXLFNBQVMsdUJBQXVCLE9BQU8sOFNBQThTLGFBQWEsZ0RBQWdELFNBQVMsY0FBYyw4REFBOEQsU0FBUyxPQUFPLHFvQkFBcW9CLHVIQUF1SCxxRUFBcUUsb0RBQW9ELGlFQUFpRSxnREFBZ0QsU0FBUyxnQ0FBZ0MsMkNBQTJDLHdCQUF3QixpQ0FBaUMsU0FBUyxxQkFBcUIsdUNBQXVDLG1DQUFtQyxXQUFXLHlEQUF5RCx1REFBdUQsdURBQXVELDJEQUEyRCxvTkFBb04sb0VBQW9FLFdBQVcsMEdBQTBHLG9FQUFvRSxXQUFXLDJDQUEyQyxvQ0FBb0MsOENBQThDLGFBQWEsT0FBTyw2Q0FBNkMsYUFBYSxXQUFXLCtDQUErQyxpQ0FBaUMsc0NBQXNDLHdDQUF3Qyx5Q0FBeUMsU0FBUyxPQUFPLDRHQUE0RyxvREFBb0QsT0FBTywrTkFBK04seUNBQXlDLHFCQUFxQix1Q0FBdUMsU0FBUyxPQUFPLHFQQUFxUCx5Q0FBeUMscUJBQXFCLG9DQUFvQyx5Q0FBeUMsd0NBQXdDLFNBQVMsT0FBTyx1VkFBdVYseUNBQXlDLHFDQUFxQyxrREFBa0QsU0FBUyxtREFBbUQsT0FBTywrRUFBK0UscU1BQXFNLGdDQUFnQyxnREFBZ0Qsa0NBQWtDLGdFQUFnRSxnQ0FBZ0Msb0JBQW9CLDhLQUE4Syw2QkFBNkIscUdBQXFHLGVBQWUsaUVBQWlFLCtCQUErQix5REFBeUQsZ0hBQWdILGVBQWUsT0FBTywrQ0FBK0MsZUFBZSw2QkFBNkIsdUdBQXVHLHNCQUFzQix1TkFBdU4sc0JBQXNCLDhPQUE4TyxzQkFBc0IsMkhBQTJILHNEQUFzRCxlQUFlLHlEQUF5RCxvQkFBb0IscUhBQXFILHNEQUFzRCxlQUFlLHlEQUF5RCxvQkFBb0Isd0hBQXdILCtFQUErRSxlQUFlLHlEQUF5RCxvRkFBb0Ysc0tBQXNLLGVBQWUsK0RBQStELHlFQUF5RSxrRUFBa0UsZUFBZSx5REFBeUQsb0JBQW9CLHNIQUFzSCwrRUFBK0UsZUFBZSx5REFBeUQscUZBQXFGLHNLQUFzSyxlQUFlLHlEQUF5RCx5RUFBeUUsa0VBQWtFLGVBQWUseURBQXlELG9CQUFvQixtR0FBbUcsV0FBVyxTQUFTLGtEQUFrRCw4RkFBOEYsU0FBUyxPQUFPLDBCQUEwQixTQUFTLHdCQUF3QixpQ0FBaUMsa0NBQWtDLFNBQVMsT0FBTyxnSEFBZ0gseUZBQXlGLDREQUE0RCx1RkFBdUYsNkZBQTZGLG9HQUFvRyxTQUFTLE9BQU8sNEdBQTRHLHdFQUF3RSxrREFBa0QsZUFBZSw4SkFBOEoseUJBQXlCLGlGQUFpRixvREFBb0QscURBQXFELGFBQWEsV0FBVyxlQUFlLFNBQVMsc0JBQXNCLE9BQU8sZ1VBQWdVLHNDQUFzQywyREFBMkQsK0ZBQStGLFNBQVMsK0ZBQStGLDBDQUEwQyxTQUFTLHdGQUF3Riw0Q0FBNEMsd0VBQXdFLHVEQUF1RCwwREFBMEQseUVBQXlFLFdBQVcsU0FBUywrREFBK0Qsc0ZBQXNGLDZDQUE2QyxpQkFBaUIsU0FBUyxxRUFBcUUsNEJBQTRCLHdDQUF3QywrQ0FBK0MsdUNBQXVDLHFEQUFxRCxTQUFTLG1DQUFtQyw0RkFBNEYscURBQXFELDJCQUEyQiwwQkFBMEIsNkNBQTZDLDZEQUE2RCwwQkFBMEIsU0FBUyxFQUFFLGtCQUFrQixrRkFBa0YsaUNBQWlDLDJEQUEyRCx3REFBd0QsaUdBQWlHLEVBQUUsK0NBQStDLG1LQUFtSyx3QkFBd0Isc05BQXNOLEVBQUUsNkJBQTZCLDJEQUEyRCwyREFBMkQsMEVBQTBFLGlEQUFpRCwwREFBMEQsMEZBQTBGLFdBQVcsT0FBTyx5RUFBeUUsV0FBVyx1REFBdUQsK0JBQStCLFdBQVcseUNBQXlDLFNBQVMsT0FBTywyR0FBMkcseUJBQXlCLGtHQUFrRywyRkFBMkYscUNBQXFDLHVOQUF1TixzQ0FBc0MsOERBQThELFNBQVMsb0hBQW9ILHlCQUF5QixxR0FBcUcsU0FBUyw2SEFBNkgsMkdBQTJHLDBIQUEwSCw2QkFBNkIsU0FBUyxzR0FBc0cseUNBQXlDLGtDQUFrQyw0SEFBNEgsK0ZBQStGLGFBQWEsb0RBQW9ELFdBQVcsS0FBSyxTQUFTLE9BQU8seU1BQXlNLHdIQUF3SCxPQUFPLHVIQUF1SCxxYkFBcWIsNkVBQTZFLDBHQUEwRyxvSEFBb0gseVBBQXlQLCtJQUErSSxzQkFBc0IsT0FBTywrRkFBK0YsMEdBQTBHLHdHQUF3RyxtRUFBbUUsU0FBUyxxQ0FBcUMsNkNBQTZDLE9BQU8seUxBQXlMLHVIQUF1SCx5RUFBeUUsaUJBQWlCLFNBQVMsd0NBQXdDLG1EQUFtRCxtREFBbUQsa0RBQWtELDJDQUEyQyxZQUFZLDJKQUEySix1R0FBdUcsV0FBVyxPQUFPLDZKQUE2SixXQUFXLDRCQUE0QiwwQkFBMEIsV0FBVyw0Q0FBNEMsaURBQWlELDBCQUEwQiwyR0FBMkcsV0FBVyxtQ0FBbUMsaUNBQWlDLG1DQUFtQyx5R0FBeUcsRUFBRSw4QkFBOEIsNEJBQTRCLDZDQUE2QyxhQUFhLFdBQVcsbUNBQW1DLFNBQVMsT0FBTyw2RkFBNkYsc0ZBQXNGLE9BQU8sc0hBQXNILHFDQUFxQyxpQkFBaUIsU0FBUyw2RkFBNkYsOFlBQThZLHlDQUF5QyxTQUFTLE9BQU8sOEdBQThHLHVFQUF1RSxzREFBc0QsaUJBQWlCLFNBQVMsaUpBQWlKLHVDQUF1QyxPQUFPLGtGQUFrRix3RkFBd0Ysb0VBQW9FLDZDQUE2QyxrRUFBa0UsK0RBQStELFNBQVMsT0FBTyw0QkFBNEIsNENBQTRDLGdFQUFnRSxpRUFBaUUsU0FBUyxtQ0FBbUMsbUNBQW1DLE9BQU8sNEhBQTRILHVFQUF1RSxpTUFBaU0sbUNBQW1DLG1DQUFtQyxPQUFPLHNHQUFzRyw0Q0FBNEMsaUdBQWlHLGlCQUFpQixTQUFTLDBDQUEwQyxpRUFBaUUsdURBQXVELG9EQUFvRCw2R0FBNkcsT0FBTyx5R0FBeUcsMkJBQTJCLHlDQUF5QyxPQUFPLG1IQUFtSCw0RkFBNEYsdUVBQXVFLDJCQUEyQixrQ0FBa0MsU0FBUyxzQ0FBc0MsbURBQW1ELHlCQUF5Qiw2RUFBNkUsb0NBQW9DLHVCQUF1Qix5Q0FBeUMsa0NBQWtDLDRCQUE0Qix1Q0FBdUMsU0FBUyxPQUFPLGlDQUFpQyw0Q0FBNEMsd0RBQXdELCtCQUErQiw0QkFBNEIsbUNBQW1DLFNBQVMsT0FBTyxzSUFBc0ksZ0hBQWdILHlCQUF5QiwrSEFBK0gscUNBQXFDLGtGQUFrRix3Q0FBd0MsaUNBQWlDLFdBQVcsRUFBRSxTQUFTLE9BQU8seVFBQXlRLGdDQUFnQywwQ0FBMEMsT0FBTywrU0FBK1Msa0VBQWtFLGtJQUFrSSxtQ0FBbUMsOEJBQThCLHFEQUFxRCw2RUFBNkUsT0FBTyxnM0JBQWczQiw4Q0FBOEMsc0NBQXNDLFNBQVMsa0ZBQWtGLCtCQUErQixzQkFBc0IsU0FBUywwOUJBQTA5Qiw0RkFBNEYsMEJBQTBCLHNCQUFzQixXQUFXLDJCQUEyQixTQUFTLHFHQUFxRyx1UUFBdVEsaUNBQWlDLDhEQUE4RCx1QkFBdUIsMkRBQTJELFdBQVcsb0NBQW9DLHNDQUFzQyxTQUFTLDhJQUE4SSxpSEFBaUgsNEJBQTRCLFdBQVcsd0JBQXdCLGdEQUFnRCxXQUFXLEVBQUUsNENBQTRDLCtCQUErQiwyRkFBMkYsOEJBQThCLG9DQUFvQywyQkFBMkIsYUFBYSxXQUFXLEVBQUUsK0JBQStCLDZCQUE2QixXQUFXLE9BQU8seURBQXlELFdBQVcsU0FBUyx5SEFBeUgsZ0VBQWdFLCtEQUErRCxXQUFXLHFCQUFxQixVQUFVLDJCQUEyQix5QkFBeUIsYUFBYSx3QkFBd0Isd0VBQXdFLDhCQUE4QixhQUFhLE9BQU8sNkJBQTZCLGFBQWEsV0FBVyxPQUFPLDZDQUE2QyxnRUFBZ0Usc0JBQXNCLG1GQUFtRixzQkFBc0Isa0VBQWtFLHNCQUFzQixvRUFBb0Usc0JBQXNCLCtGQUErRixzQkFBc0IsbUVBQW1FLHNCQUFzQiw2RUFBNkUsMENBQTBDLDRDQUE0QyxxQ0FBcUMsc0JBQXNCLDJHQUEyRywwQ0FBMEMsNENBQTRDLHFDQUFxQyxzQkFBc0Isa0VBQWtFLGlDQUFpQyxpQkFBaUIsT0FBTyxpQ0FBaUMsaUJBQWlCLHdCQUF3Qix1REFBdUQsYUFBYSxXQUFXLFNBQVMsc0NBQXNDLHVDQUF1Qyx1Q0FBdUMsd0VBQXdFLFdBQVcsU0FBUyw0QkFBNEIsMENBQTBDLFNBQVMsdUJBQXVCLG1IQUFtSCxTQUFTLHlCQUF5QixvQkFBb0Isb0JBQW9CLGdCQUFnQix3REFBd0QsK0JBQStCLG9CQUFvQixhQUFhLHNCQUFzQix1QkFBdUIsV0FBVyxjQUFjLFNBQVMsNEVBQTRFLHVHQUF1RyxpQ0FBaUMsMEJBQTBCLHNCQUFzQixPQUFPLHMyREFBczJELG9CQUFvQixzQkFBc0IsU0FBUyx5Z0JBQXlnQiw0RkFBNEYsMEJBQTBCLHNCQUFzQixXQUFXLDJCQUEyQixTQUFTLGdJQUFnSSxpQ0FBaUMsbUNBQW1DLHNDQUFzQyxnQ0FBZ0MsYUFBYSxXQUFXLHVCQUF1QixTQUFTLHdJQUF3SSx5RUFBeUUsU0FBUyx1REFBdUQscUJBQXFCLDJCQUEyQix5QkFBeUIsYUFBYSwwQkFBMEIsMEVBQTBFLGdDQUFnQyxlQUFlLE9BQU8saURBQWlELGVBQWUsYUFBYSxPQUFPLCtDQUErQyw4RkFBOEYsd0JBQXdCLG1IQUFtSCx3QkFBd0IsaU9BQWlPLHdCQUF3QixxR0FBcUcsd0JBQXdCLHlIQUF5SCx3QkFBd0IsbUtBQW1LLHdCQUF3Qix3RUFBd0Usd0JBQXdCLG9HQUFvRyx3QkFBd0Isc0VBQXNFLG9DQUFvQyxtQkFBbUIsT0FBTyxtQ0FBbUMsbUJBQW1CLDBCQUEwQiw2RUFBNkUsZUFBZSxhQUFhLFdBQVcsU0FBUyx3QkFBd0IsT0FBTywySEFBMkgsa0xBQWtMLDRGQUE0RiwwQkFBMEIsc0JBQXNCLFdBQVcsMkJBQTJCLFVBQVUsMkJBQTJCLHlCQUF5QixhQUFhLHdCQUF3Qix3RUFBd0UsOEJBQThCLGFBQWEsT0FBTyw4Q0FBOEMsYUFBYSxXQUFXLE9BQU8sNkNBQTZDLDRJQUE0SSxzQkFBc0IsZ0ZBQWdGLGtHQUFrRyxpQ0FBaUMsaUJBQWlCLE9BQU8saUNBQWlDLGlCQUFpQix3QkFBd0Isd0VBQXdFLGFBQWEsV0FBVyxTQUFTLHVCQUF1QixPQUFPLG1HQUFtRyw4RkFBOEYsT0FBTyxvSUFBb0ksZ0RBQWdELGlCQUFpQixTQUFTLDBRQUEwUSxlQUFlLDRFQUE0RSxTQUFTLGdCQUFnQiwyQ0FBMkMsU0FBUyw0Q0FBNEMsOERBQThELCtEQUErRCxxREFBcUQsd0RBQXdELDBEQUEwRCxxQ0FBcUMsT0FBTyxpSEFBaUgsbUhBQW1ILE9BQU8sbUpBQW1KLDREQUE0RCxnQ0FBZ0MsZ0RBQWdELHNCQUFzQixTQUFTLDJEQUEyRCxlQUFlLGdJQUFnSSxXQUFXLFlBQVksb0JBQW9CLDRVQUE0VSw2QkFBNkIsMENBQTBDLGtHQUFrRyxzQkFBc0Isd0dBQXdHLHNCQUFzQixzR0FBc0csK0VBQStFLHNCQUFzQixxR0FBcUcsK0VBQStFLHNCQUFzQixhQUFhLDZDQUE2QyxXQUFXLDhDQUE4QyxTQUFTLCtOQUErTiwrRkFBK0Ysd0JBQXdCLDhCQUE4QixnQ0FBZ0MsZ0NBQWdDLHFDQUFxQyxTQUFTLHFEQUFxRCxPQUFPLCtZQUErWSxvQkFBb0Isc0JBQXNCLFNBQVMsd0VBQXdFLG9CQUFvQixPQUFPLGlHQUFpRyw0TUFBNE0saUVBQWlFLHFGQUFxRixxRkFBcUYsa0dBQWtHLG1DQUFtQyxTQUFTLHFDQUFxQywyQkFBMkIsZ0VBQWdFLFNBQVMsT0FBTyxzRkFBc0YseUxBQXlMLHlCQUF5QixPQUFPLG1NQUFtTSx5SEFBeUgsK0RBQStELHlCQUF5QixtQ0FBbUMsK0RBQStELGFBQWEsb0NBQW9DLCtEQUErRCxhQUFhLG9DQUFvQyw2Q0FBNkMsYUFBYSxzQ0FBc0MsMENBQTBDLGFBQWEsOENBQThDLHVIQUF1SCw2QkFBNkIsYUFBYSxrREFBa0QsNkRBQTZELDZCQUE2QixhQUFhLGdEQUFnRCw2REFBNkQsNkJBQTZCLGFBQWEsWUFBWSx3R0FBd0csU0FBUyxFQUFFLE9BQU8sNkhBQTZILGsyREFBazJELDhCQUE4QiwwQkFBMEIscUJBQXFCLFNBQVMsd0JBQXdCLHlKQUF5SixxRUFBcUUsNEZBQTRGLHdCQUF3QixrQ0FBa0MsNkJBQTZCLHlCQUF5QixhQUFhLFdBQVcsU0FBUyxxQ0FBcUMsaUNBQWlDLGlEQUFpRCwwTEFBMEwsbWhCQUFtaEIsaURBQWlELDBMQUEwTCxtaEJBQW1oQix1REFBdUQsNkZBQTZGLGtJQUFrSSwyT0FBMk8seVpBQXlaLCtEQUErRCxrREFBa0QsaURBQWlELGlEQUFpRCx1REFBdUQscURBQXFELCtEQUErRCwyREFBMkQsK0RBQStELG1FQUFtRSxpREFBaUQsb0JBQW9CLFlBQVksdUJBQXVCLG9CQUFvQixTQUFTLHVCQUF1QiwyQkFBMkIseUJBQXlCLG9CQUFvQixTQUFTLHVHQUF1Ryw2Q0FBNkMsNEJBQTRCLGlDQUFpQyw4REFBOEQsdUNBQXVDLDhCQUE4Qix3RkFBd0YsbUZBQW1GLDBCQUEwQix3R0FBd0csbUZBQW1GLDBCQUEwQiw0RkFBNEYsdUNBQXVDLDBCQUEwQixpQkFBaUIsZUFBZSxtQ0FBbUMsYUFBYSxxZkFBcWYsNEhBQTRILDJCQUEyQixTQUFTLFNBQVMsMEVBQTBFLHFOQUFxTixhQUFhLDJEQUEyRCxvRUFBb0UsdUZBQXVGLHlFQUF5RSxhQUFhLDRGQUE0Riw4REFBOEQsNklBQTZJLHFHQUFxRyxnR0FBZ0csNEJBQTRCLGdCQUFnQixVQUFVLDJFQUEyRSw2SUFBNkksNkJBQTZCLFNBQVMsU0FBUywyS0FBMkssZ0VBQWdFLHVKQUF1SiwwdkNBQTB2QyxzU0FBc1Msd2hCQUF3aEIsd0ZBQXdGLGtFQUFrRSxlQUFlLDhDQUE4QyxhQUFhLDBCQUEwQixtQ0FBbUMsNEJBQTRCLHlCQUF5QixhQUFhLDhMQUE4TCw4QkFBOEIsV0FBVywwQkFBMEIsU0FBUyw4QkFBOEIsK0JBQStCLG9CQUFvQixPQUFPLDBNQUEwTSx1YkFBdWIsK0RBQStELG9HQUFvRyxTQUFTLE9BQU8sb0VBQW9FLG9FQUFvRSwrR0FBK0csMkJBQTJCLFlBQVksV0FBVyw2R0FBNkcsMEtBQTBLLGFBQWEsV0FBVyx1Q0FBdUMsU0FBUyxvQ0FBb0MsbUZBQW1GLFdBQVcsU0FBUyxvREFBb0QsZ0NBQWdDLDJDQUEyQyxtRkFBbUYsV0FBVyxPQUFPLGtIQUFrSCxnREFBZ0QsNkRBQTZELGlMQUFpTCxtREFBbUQsY0FBYyw2Q0FBNkMsc0VBQXNFLDBFQUEwRSxtRkFBbUYsb0hBQW9ILG9CQUFvQixpQkFBaUIsVUFBVSwwSkFBMEosYUFBYSw4Q0FBOEMsbUNBQW1DLGtDQUFrQyxXQUFXLFNBQVMsa0RBQWtELG1DQUFtQyx1RUFBdUUsdUJBQXVCLFNBQVMsNkJBQTZCLGlEQUFpRCxPQUFPLHdIQUF3SCxnV0FBZ1csNENBQTRDLDhEQUE4RCwrREFBK0QscURBQXFELG1DQUFtQyxTQUFTLE9BQU8sdUhBQXVILG1MQUFtTCxrRUFBa0UsT0FBTyw4RkFBOEYsOERBQThELHlCQUF5QiwrR0FBK0csU0FBUyxPQUFPLG1IQUFtSCw0REFBNEQsMkdBQTJHLE9BQU8sbUpBQW1KLG1GQUFtRixPQUFPLHNIQUFzSCxvRkFBb0YsT0FBTyxzSUFBc0ksaURBQWlELE9BQU8sb0tBQW9LLDBMQUEwTCwyQkFBMkIsa0ZBQWtGLFNBQVMsNkNBQTZDLE9BQU8sMEdBQTBHLHlRQUF5USxzQkFBc0IseUNBQXlDLGlEQUFpRCwrQ0FBK0MsK0NBQStDLGlEQUFpRCxtQ0FBbUMsV0FBVyxpREFBaUQsbUNBQW1DLFdBQVcsU0FBUyxzTkFBc04sT0FBTyxrSUFBa0ksbUVBQW1FLHFKQUFxSixnQkFBZ0Isd1JBQXdSLE9BQU8sa0hBQWtILG1CQUFtQiw2Q0FBNkMsaURBQWlELCtDQUErQyxTQUFTLG1OQUFtTixtR0FBbUcsT0FBTyxLQUFLLEVBQUUsbVVBQW1VLHdHQUF3RyxpRUFBaUUsZ0RBQWdELHNFQUFzRSw0REFBNEQsU0FBUyxzRUFBc0UsNERBQTRELFNBQVMsT0FBTyxnRUFBZ0UsS0FBSyw2Q0FBNkMseUpBQXlKLGlHQUFpRyw2Q0FBNkMsc0VBQXNFLHlEQUF5RCxTQUFTLHNFQUFzRSx5REFBeUQsU0FBUyxPQUFPLEtBQUssbUdBQW1HLDhCQUE4QixpQ0FBaUMsa0NBQWtDLHFDQUFxQyxTQUFTLE9BQU8sc0JBQXNCLEtBQUssOFJBQThSLDJGQUEyRixvQkFBb0IsT0FBTyxpRkFBaUYsZ0VBQWdFLHdDQUF3QyxPQUFPLGtJQUFrSSwrQ0FBK0MsT0FBTyxpRUFBaUUsaUlBQWlJLCtHQUErRyxPQUFPLHFHQUFxRywrR0FBK0csT0FBTyxzQ0FBc0MscUxBQXFMLE9BQU8sRUFBRSxNQUFNLHNDQUFzQyw2REFBNkQsNkNBQTZDLHNDQUFzQyxrQ0FBa0MsMlNBQTJTLDRFQUE0RSw4cUJBQThxQixvQ0FBb0MsbURBQW1ELHNDQUFzQyxTQUFTLHdDQUF3QyxrREFBa0QsU0FBUyxzQ0FBc0MsMkRBQTJELFNBQVMscUNBQXFDLDRCQUE0QixPQUFPLG9EQUFvRCxnQ0FBZ0MsbUNBQW1DLHdDQUF3Qyx1Q0FBdUMsU0FBUyxPQUFPLHNDQUFzQywyRUFBMkUscUNBQXFDLGlCQUFpQixTQUFTLGlHQUFpRyx3Q0FBd0MsK0JBQStCLE9BQU8scURBQXFELDZCQUE2Qix5Q0FBeUMsa0tBQWtLLHVCQUF1QixTQUFTLHVGQUF1Riw2QkFBNkIsdUJBQXVCLFNBQVMsNkVBQTZFLHNCQUFzQixPQUFPLHNEQUFzRCwwRUFBMEUsK0JBQStCLHFMQUFxTCxTQUFTLEVBQUUsT0FBTyxrREFBa0QsZ0NBQWdDLHFDQUFxQyxtQ0FBbUMsU0FBUyxPQUFPLCtEQUErRCx3Q0FBd0Msb0lBQW9JLGlCQUFpQixTQUFTLGlJQUFpSSw0TUFBNE0sZ0hBQWdILFdBQVcsU0FBUyxpQkFBaUIsT0FBTyxpREFBaUQsNkJBQTZCLHlGQUF5Rix3REFBd0QsaUVBQWlFLGlHQUFpRyx3Q0FBd0MsU0FBUyxxT0FBcU8sK0ZBQStGLDJEQUEyRCx1REFBdUQsMEVBQTBFLHlEQUF5RCxTQUFTLGFBQWEsK0dBQStHLHNDQUFzQywwSEFBMEgseUNBQXlDLHlDQUF5Qyw4SUFBOEksNkVBQTZFLHdGQUF3Rix3QkFBd0IseUJBQXlCLFNBQVMscUVBQXFFLHFGQUFxRixxREFBcUQsU0FBUyxtTkFBbU4sdUNBQXVDLG1QQUFtUCxnREFBZ0QsU0FBUyxzQkFBc0IsT0FBTyx5REFBeUQsdUJBQXVCLDBPQUEwTyw2QkFBNkIscUdBQXFHLE9BQU8sOERBQThELGdHQUFnRyx1REFBdUQsU0FBUywrRkFBK0YsaUVBQWlFLG9IQUFvSCxrQ0FBa0MsK0RBQStELDRCQUE0QixFQUFFLDJCQUEyQixXQUFXLHdDQUF3QyxTQUFTLGtFQUFrRSw4REFBOEQsK0JBQStCLDJDQUEyQyxTQUFTLHVCQUF1QixPQUFPLCtDQUErQywySEFBMkgsOERBQThELHFEQUFxRCxTQUFTLDJFQUEyRSxpQ0FBaUMsK0JBQStCLFNBQVMsd09BQXdPLGdIQUFnSCwyREFBMkQsNEJBQTRCLGFBQWEsV0FBVyxFQUFFLFNBQVMsT0FBTyx5REFBeUQsMEJBQTBCLFdBQVcsU0FBUyx1QkFBdUIsT0FBTywyQ0FBMkMsOEJBQThCLHFJQUFxSSwrQ0FBK0MsU0FBUyxzSUFBc0kscUNBQXFDLDhGQUE4RixTQUFTLGlFQUFpRSxPQUFPLGtDQUFrQyx5REFBeUQsMEJBQTBCLEVBQUUsU0FBUyxPQUFPLHdCQUF3QixTQUFTLHNCQUFzQixPQUFPLCtDQUErQyxxSEFBcUgsT0FBTyw0REFBNEQseUdBQXlHLDZEQUE2RCxPQUFPLGtFQUFrRSxnRUFBZ0UsT0FBTyxxREFBcUQseVBBQXlQLGlEQUFpRCwrRkFBK0YsU0FBUyxzT0FBc08sc0NBQXNDLFNBQVMsb0dBQW9HLGlEQUFpRCxTQUFTLHdCQUF3QixPQUFPLDhEQUE4RCxpRUFBaUUsd0RBQXdELFNBQVMsT0FBTyx1RUFBdUUsd0NBQXdDLGlDQUFpQyxTQUFTLCtCQUErQixpQkFBaUIsbUVBQW1FLFNBQVMsZ0NBQWdDLGdFQUFnRSxTQUFTLGlDQUFpQyxnR0FBZ0csU0FBUywrQkFBK0IsNkRBQTZELFNBQVMsa0NBQWtDLGdHQUFnRyxTQUFTLE9BQU8sbURBQW1ELG9GQUFvRixPQUFPLHNEQUFzRCx5SUFBeUksc25CQUFzbkIsb0RBQW9ELGtEQUFrRCxTQUFTLHVEQUF1RCxnQkFBZ0Isa0RBQWtELFNBQVMsa0JBQWtCLDBMQUEwTCxPQUFPLDBEQUEwRCxnREFBZ0Qsa0JBQWtCLGtEQUFrRCxTQUFTLGdIQUFnSCxrQkFBa0IsMlFBQTJRLE9BQU8sZ0RBQWdELHdCQUF3Qiw2UkFBNlIsT0FBTyxvRUFBb0Usa0NBQWtDLCtGQUErRixPQUFPLG9EQUFvRCwrSEFBK0gsc0NBQXNDLCtCQUErQixrQ0FBa0MsaUJBQWlCLFNBQVMsNkNBQTZDLGdhQUFnYSxpQkFBaUIsU0FBUywrQ0FBK0MsZ09BQWdPLGlCQUFpQixTQUFTLG9EQUFvRCwyQ0FBMkMsaUJBQWlCLFNBQVMsNkNBQTZDLG9EQUFvRCxTQUFTLCtCQUErQixrQkFBa0Isb0JBQW9CLGlCQUFpQixTQUFTLHVFQUF1RSxrdEJBQWt0QixtQ0FBbUMsT0FBTyxnRUFBZ0UsbUJBQW1CLDhCQUE4QixTQUFTLHNIQUFzSCxrQkFBa0IsK3pCQUErekIsT0FBTyxnRkFBZ0YsMk9BQTJPLCtFQUErRSxnQ0FBZ0MsMkdBQTJHLFNBQVMsOE5BQThOLGlDQUFpQyx5Q0FBeUMsbURBQW1ELHVKQUF1SixhQUFhLE9BQU8sNkNBQTZDLGFBQWEsMEVBQTBFLDhEQUE4RCxhQUFhLHlFQUF5RSw2REFBNkQsYUFBYSwwRUFBMEUsOERBQThELGFBQWEseUVBQXlFLDZEQUE2RCxhQUFhLFdBQVcseUJBQXlCLDZRQUE2USxnT0FBZ08sMElBQTBJLDBPQUEwTyxXQUFXLG1DQUFtQyx1Q0FBdUMsV0FBVyxtQ0FBbUMsdUNBQXVDLFdBQVcsU0FBUyxrQkFBa0IsKzZCQUErNkIsT0FBTyxrQ0FBa0MsMkRBQTJELGdGQUFnRiwrQkFBK0IsU0FBUyw2QkFBNkIseUNBQXlDLG9DQUFvQyx5QkFBeUIsU0FBUyxPQUFPLGdFQUFnRSxxRkFBcUYsaURBQWlELCtDQUErQyxTQUFTLHdGQUF3RixtREFBbUQsZ0RBQWdELFNBQVMsT0FBTyxxR0FBcUcsa0NBQWtDLDhEQUE4RCxtSUFBbUksbUVBQW1FLHVDQUF1QyxTQUFTLHlFQUF5RSxPQUFPLGtCQUFrQixvQ0FBb0MsZ0JBQWdCLDhKQUE4SixPQUFPLEtBQUssRUFBRSwyREFBMkQsbURBQW1ELG9DQUFvQyxPQUFPLDBDQUEwQyxFQUFFLGlDQUFpQyxpRUFBaUUsd0RBQXdELHlEQUF5RCwrQ0FBK0Msa1NBQWtTLGlFQUFpRSxXQUFXLFNBQVMsRUFBRSxPQUFPLGtEQUFrRCxvQ0FBb0MsT0FBTywwQ0FBMEMsRUFBRSw4Q0FBOEMsaURBQWlELDhCQUE4QixrQ0FBa0MsZ0NBQWdDLHdHQUF3RyxpREFBaUQsb09BQW9PLHdMQUF3TCx5Q0FBeUMsdU1BQXVNLFdBQVcsT0FBTyxpUUFBaVEsbUVBQW1FLFdBQVcsU0FBUyxFQUFFLE9BQU8sa0RBQWtELGlEQUFpRCwwRUFBMEUscUhBQXFILG1FQUFtRSx5REFBeUQsb0VBQW9FLHlDQUF5QyxxREFBcUQsZ0lBQWdJLG1FQUFtRSx5REFBeUQseUlBQXlJLDhDQUE4QyxlQUFlLDZDQUE2QyxhQUFhLEVBQUUsV0FBVyx3Q0FBd0Msa0xBQWtMLGtDQUFrQyw0SEFBNEgsMkdBQTJHLDhHQUE4Ryx1REFBdUQsb0NBQW9DLGdCQUFnQixxTUFBcU0sb0RBQW9ELHdEQUF3RCw2TUFBNk0sdUVBQXVFLHdHQUF3RyxxR0FBcUcsMERBQTBELGtNQUFrTSxrTkFBa04sd0NBQXdDLGVBQWUsRUFBRSw0R0FBNEcsK0NBQStDLGFBQWEseUNBQXlDLHlDQUF5Qyw0UUFBNFEsYUFBYSxXQUFXLE9BQU8sa1FBQWtRLGtDQUFrQyxrREFBa0QsZ05BQWdOLDhDQUE4Qyw4RUFBOEUsaURBQWlELDBMQUEwTCxpRUFBaUUsMkNBQTJDLDhDQUE4QyxlQUFlLDhNQUE4TSxpREFBaUQsdUVBQXVFLDREQUE0RCxrSEFBa0gsOE1BQThNLHdDQUF3QyxlQUFlLEVBQUUsYUFBYSxXQUFXLFNBQVMsRUFBRSxPQUFPLEtBQUssRUFBRSxnREFBZ0Qsa0RBQWtELDZEQUE2RCxrQ0FBa0Msd0NBQXdDLFNBQVMsc0NBQXNDLE9BQU8saURBQWlELGlDQUFpQywwQkFBMEIsaURBQWlELFNBQVMsT0FBTyxLQUFLLEVBQUUsaURBQWlELGtEQUFrRCw4REFBOEQsbUNBQW1DLDBDQUEwQyxTQUFTLHdDQUF3QyxPQUFPLGlEQUFpRCxpQ0FBaUMsMkJBQTJCLG9EQUFvRCxTQUFTLE9BQU8sS0FBSyxFQUFFLGdEQUFnRCwyQ0FBMkMsdUNBQXVDLGlFQUFpRSxTQUFTLGdIQUFnSCw4REFBOEQsU0FBUyxPQUFPLDBDQUEwQyxrSkFBa0osK0VBQStFLDRDQUE0Qyx1R0FBdUcseUZBQXlGLGFBQWEscUVBQXFFLHlGQUF5RixhQUFhLFdBQVcsOENBQThDLHVHQUF1RywyRkFBMkYsYUFBYSxzRUFBc0UsMkZBQTJGLGFBQWEsV0FBVyxTQUFTLE9BQU8sNENBQTRDLDhFQUE4RSx3RkFBd0YsYUFBYSwrRkFBK0Ysd0ZBQXdGLGFBQWEsV0FBVyw4Q0FBOEMsK0VBQStFLDBGQUEwRixhQUFhLCtGQUErRiwwRkFBMEYsYUFBYSxXQUFXLFNBQVMseUVBQXlFLGtEQUFrRCxTQUFTLE9BQU8sS0FBSyxFQUFFLDhDQUE4QywyQ0FBMkMsMEJBQTBCLDRCQUE0Qiw4R0FBOEcsMERBQTBELHdDQUF3QyxpQ0FBaUMsdUtBQXVLLEVBQUUsV0FBVyxTQUFTLEVBQUUsT0FBTyw2Q0FBNkMsdVhBQXVYLGdEQUFnRCxRQUFRLE9BQU8sNERBQTRELDZDQUE2QywwREFBMEQsOENBQThDLDBKQUEwSixnREFBZ0QseUhBQXlILGtFQUFrRSxHQUFHLGFBQWEsb0RBQW9ELHFCQUFxQixXQUFXLDJDQUEyQyx1Q0FBdUMsdUNBQXVDLHVDQUF1Qyx1Q0FBdUMsdUJBQXVCLHVFQUF1RSw2RkFBNkYsTUFBTSxhQUFhLHVCQUF1Qix1RUFBdUUsNkRBQTZELE1BQU0sYUFBYSx1QkFBdUIsd0VBQXdFLDRGQUE0RixPQUFPLGFBQWEsdUJBQXVCLHdFQUF3RSw2REFBNkQsT0FBTyxhQUFhLFdBQVcseUNBQXlDLDJDQUEyQyx1Q0FBdUMsdUNBQXVDLHVDQUF1Qyx1Q0FBdUMsdUJBQXVCLHVFQUF1RSw2REFBNkQsTUFBTSxhQUFhLHVCQUF1Qix1RUFBdUUsNkZBQTZGLE1BQU0sYUFBYSx1QkFBdUIsd0VBQXdFLDZEQUE2RCxPQUFPLGFBQWEsdUJBQXVCLHdFQUF3RSw0RkFBNEYsT0FBTyxhQUFhLFdBQVcsb0ZBQW9GLGlIQUFpSCw4REFBOEQsR0FBRyxXQUFXLDBFQUEwRSxTQUFTLE9BQU8sS0FBSyxFQUFFLCtDQUErQyxrREFBa0QsbUhBQW1ILHVHQUF1RyxTQUFTLEVBQUUsOEJBQThCLGlCQUFpQixTQUFTLCtEQUErRCxvQ0FBb0MsMkNBQTJDLFNBQVMsRUFBRSxpREFBaUQsT0FBTyxLQUFLLEVBQUUsZ0RBQWdELGtEQUFrRCw4REFBOEQsa0NBQWtDLHdDQUF3QyxTQUFTLHNDQUFzQyxPQUFPLGlEQUFpRCxpQ0FBaUMsMEJBQTBCLGtEQUFrRCxTQUFTLE9BQU8sS0FBSyxFQUFFLG1DQUFtQywyU0FBMlMsOEVBQThFLG9mQUFvZixtQ0FBbUMsd0NBQXdDLE9BQU8sNkNBQTZDLDJDQUEyQyxPQUFPLCtDQUErQyxxREFBcUQsdUJBQXVCLFNBQVMsb0dBQW9HLCtCQUErQixzQkFBc0IsU0FBUywrTEFBK0wsNkJBQTZCLHVCQUF1QixtQkFBbUIsT0FBTyxvQ0FBb0MsdUlBQXVJLGdEQUFnRCx3QkFBd0IsMFFBQTBRLEVBQUUsaUpBQWlKLGdGQUFnRixpQkFBaUIsbVBBQW1QLEdBQUcsNEdBQTRHLHVDQUF1Qyw0QkFBNEIsa1JBQWtSLEVBQUUsb0NBQW9DLG9IQUFvSCxFQUFFLDBJQUEwSSx5REFBeUQsOEVBQThFLDhGQUE4RixHQUFHLHdHQUF3RyxtRUFBbUUsRUFBRSx5Q0FBeUMsU0FBUyx5R0FBeUcsd1JBQXdSLEVBQUUsNEJBQTRCLG9EQUFvRCx5Q0FBeUMsbURBQW1ELFdBQVcsMENBQTBDLDRCQUE0Qix1QkFBdUIsY0FBYyxPQUFPLGtDQUFrQywrQ0FBK0Msa0ZBQWtGLHNCQUFzQiwyQ0FBMkMsRUFBRSxzRUFBc0UsdUVBQXVFLGFBQWEsaUVBQWlFLHNDQUFzQyxXQUFXLFNBQVMsZ0RBQWdELDBDQUEwQywwQ0FBMEMscUNBQXFDLHlEQUF5RCxzRkFBc0YsYUFBYSwrREFBK0QsbURBQW1ELDJDQUEyQyw2REFBNkQsRUFBRSxhQUFhLHlIQUF5SCxzREFBc0QsOEZBQThGLHFKQUFxSiw2Q0FBNkMsNkNBQTZDLGFBQWEsaUVBQWlFLFdBQVcsVUFBVSx5RkFBeUYseUZBQXlGLDJDQUEyQywrQ0FBK0MsK0JBQStCLGlDQUFpQyxpRkFBaUYsYUFBYSw2REFBNkQsV0FBVyxTQUFTLEVBQUUsMkJBQTJCLCtCQUErQix3RkFBd0YsNkJBQTZCLHFCQUFxQixhQUFhLDZEQUE2RCxtQ0FBbUMsV0FBVywwQkFBMEIsNkJBQTZCLHFCQUFxQixhQUFhLG1DQUFtQywwREFBMEQscUNBQXFDLGFBQWEsV0FBVyxFQUFFLFNBQVMsNEJBQTRCLE9BQU8sc0NBQXNDLDZCQUE2QixxRUFBcUUsaU5BQWlOLFVBQVUsNkVBQTZFLGlDQUFpQyxtQ0FBbUMsb0NBQW9DLDBOQUEwTix1QkFBdUIsMkJBQTJCLFNBQVMseUVBQXlFLHlDQUF5QyxzQkFBc0IsT0FBTyxxREFBcUQsNkRBQTZELG1DQUFtQyx5Q0FBeUMsOEVBQThFLDJCQUEyQixXQUFXLFNBQVMsbURBQW1ELE9BQU8saURBQWlELHFIQUFxSCw2QkFBNkIsOEJBQThCLHlEQUF5RCxxREFBcUQsOEJBQThCLHdEQUF3RCxzREFBc0QsU0FBUyw2Q0FBNkMseUJBQXlCLHVEQUF1RCxvQ0FBb0Msb0ZBQW9GLElBQUksbUVBQW1FLDRDQUE0Qyw0RUFBNEUsSUFBSSxtRUFBbUUseUJBQXlCLHdHQUF3RyxpQ0FBaUMsdURBQXVELHNDQUFzQyxnRUFBZ0UseUlBQXlJLG1FQUFtRSw0RkFBNEYsK0NBQStDLDRDQUE0QyxzQkFBc0IsT0FBTywrQ0FBK0MseU9BQXlPLHVDQUF1Qyx5QkFBeUIsdUJBQXVCLFNBQVMsc0RBQXNELHdEQUF3RCxvREFBb0QsZ0RBQWdELFNBQVMsZ0RBQWdELGtDQUFrQyw2Q0FBNkMsdUNBQXVDLDJFQUEyRSx1Q0FBdUMsU0FBUyx3Q0FBd0MsdUNBQXVDLHdEQUF3RCxpQ0FBaUMsU0FBUyx1QkFBdUIsT0FBTywrQ0FBK0MsOEJBQThCLDhLQUE4Syw2QkFBNkIsa0RBQWtELCtEQUErRCx5RkFBeUYsb0RBQW9ELGVBQWUsaUhBQWlILHNIQUFzSCxrSEFBa0gsNkJBQTZCLDBDQUEwQyw0REFBNEQsR0FBRyxXQUFXLGlEQUFpRCw2Q0FBNkMsNkNBQTZDLHlDQUF5QyxXQUFXLFNBQVMsZ0RBQWdELDREQUE0RCwyQ0FBMkMsNkJBQTZCLCtCQUErQixTQUFTLHVCQUF1QixPQUFPLGdFQUFnRSw2QkFBNkIsNkVBQTZFLHlCQUF5Qiw2RUFBNkUsT0FBTyxnREFBZ0QsdUJBQXVCLDREQUE0RCxpREFBaUQsU0FBUyw4REFBOEQsbURBQW1ELFNBQVMsd0RBQXdELGlEQUFpRCxTQUFTLDBEQUEwRCxtREFBbUQsU0FBUyxpQ0FBaUMscUJBQXFCLE9BQU8sc0ZBQXNGLHFJQUFxSSxhQUFhLDZSQUE2UixzREFBc0QscURBQXFELHFEQUFxRCxxREFBcUQscURBQXFELHlDQUF5QyxtQ0FBbUMsV0FBVywyQ0FBMkMscUNBQXFDLFdBQVcseUNBQXlDLG1DQUFtQyxXQUFXLDJDQUEyQyxxQ0FBcUMsV0FBVyxTQUFTLGdDQUFnQyxPQUFPLGtEQUFrRCwyQ0FBMkMsMENBQTBDLHlDQUF5QyxTQUFTLHlDQUF5Qyx1Q0FBdUMsU0FBUyw0Q0FBNEMseUNBQXlDLFNBQVMsMkNBQTJDLHVDQUF1QyxTQUFTLE9BQU8sa0RBQWtELHlGQUF5Riw0Q0FBNEMsc0RBQXNELFNBQVMsdUNBQXVDLHNEQUFzRCxTQUFTLDZCQUE2Qiw2REFBNkQsMEJBQTBCLFNBQVMsNkJBQTZCLDZEQUE2RCw2REFBNkQsU0FBUyxzQkFBc0IsT0FBTyxrREFBa0QsMG1CQUEwbUIsdUJBQXVCLGtDQUFrQyxTQUFTLHVCQUF1QixvQ0FBb0MsU0FBUyx1QkFBdUIsa0NBQWtDLFNBQVMsdUJBQXVCLG9DQUFvQyxTQUFTLDZCQUE2QixzQ0FBc0MsU0FBUyw2QkFBNkIsc0NBQXNDLFNBQVMsNkJBQTZCLHNDQUFzQyxTQUFTLDZCQUE2QixzQ0FBc0MsU0FBUyxxSEFBcUgsMEJBQTBCLFNBQVMsa0VBQWtFLDJCQUEyQixTQUFTLHNCQUFzQixPQUFPLDJGQUEyRiw2VkFBNlYsZ0JBQWdCLE9BQU8sT0FBTyxvREFBb0Qsc0RBQXNELFNBQVMsa0JBQWtCLHdGQUF3RixPQUFPLGdFQUFnRSx5REFBeUQsaUJBQWlCLFNBQVMsdUZBQXVGLGdCQUFnQiwrQ0FBK0MsT0FBTyx1REFBdUQsK0lBQStJLDhFQUE4RSxXQUFXLHNCQUFzQix1SkFBdUosRUFBRSxTQUFTLE9BQU8sOENBQThDLDJEQUEyRCx5Q0FBeUMsNkJBQTZCLHVFQUF1RSxZQUFZLGtEQUFrRCxrVEFBa1QsRUFBRSw0REFBNEQsU0FBUyxPQUFPLHFDQUFxQyxTQUFTLE9BQU8saUJBQWlCLGtDQUFrQyxrQkFBa0IsMkRBQTJELFNBQVMsbUNBQW1DLDhFQUE4RSxrQkFBa0IsMkVBQTJFLFNBQVMsdUNBQXVDLDhFQUE4RSxrQkFBa0IsMkVBQTJFLFNBQVMsdUNBQXVDLGtCQUFrQiw2REFBNkQsU0FBUyx5Q0FBeUMsOEdBQThHLFNBQVMseUNBQXlDLDhHQUE4RyxTQUFTLHlDQUF5Qyw4R0FBOEcsU0FBUyx5Q0FBeUMsOEdBQThHLFNBQVMsT0FBTyxrREFBa0Qsc0RBQXNELCtEQUErRCxPQUFPLGtCQUFrQiwwQkFBMEIsZ0JBQWdCLCtRQUErUSxPQUFPLEtBQUssRUFBRSwyRkFBMkYsa0NBQWtDLDJXQUEyVyxrR0FBa0csNk9BQTZPLDREQUE0RCxnREFBZ0QsS0FBSyxJQUFJLHlHQUF5Ryx3QkFBd0IscVFBQXFRLG9DQUFvQyw0QkFBNEIsb0ZBQW9GLEVBQUUsYUFBYSwyR0FBMkcsaURBQWlELFdBQVcsU0FBUyxFQUFFLE9BQU8sS0FBSyxFQUFFLHFEQUFxRCwrQkFBK0IsNFZBQTRWLG9CQUFvQixpQkFBaUIsU0FBUyx3Q0FBd0MsdURBQXVELGtDQUFrQyxrREFBa0Qsb0NBQW9DLGtEQUFrRCw2QkFBNkIsNE1BQTRNLFNBQVMsT0FBTywwQkFBMEIsaUJBQWlCLGlGQUFpRiw4REFBOEQsV0FBVyxFQUFFLGtEQUFrRCxzREFBc0QsZ0NBQWdDLDJHQUEyRyxvQ0FBb0MseUNBQXlDLHdDQUF3QyxzRUFBc0UsOERBQThELDZCQUE2Qix5SUFBeUksU0FBUyxPQUFPLHVDQUF1Qyx1VEFBdVQsMkNBQTJDLDBFQUEwRSwwRUFBMEUsbUJBQW1CLFNBQVMsdURBQXVELDRIQUE0SCx5QkFBeUIsa0VBQWtFLG1DQUFtQyxXQUFXLHdEQUF3RCxTQUFTLHFEQUFxRCxnSEFBZ0gseUJBQXlCLGtFQUFrRSxtQ0FBbUMsV0FBVywwREFBMEQsU0FBUyxtRkFBbUYsNkZBQTZGLDZDQUE2Qyx1RUFBdUUsb0VBQW9FLFNBQVMsT0FBTyx3REFBd0Qsc0RBQXNELFNBQVMsNEhBQTRILHVIQUF1SCxpRUFBaUUsMERBQTBELHlCQUF5QixrRUFBa0UsbUNBQW1DLFdBQVcsU0FBUyxtRUFBbUUsNERBQTRELHlCQUF5QixrRUFBa0UsbUNBQW1DLFdBQVcsU0FBUyxnQ0FBZ0Msc0RBQXNELG9EQUFvRCxnREFBZ0Qsa0RBQWtELFNBQVMsT0FBTyw4QkFBOEIsaVlBQWlZLG9GQUFvRix1QkFBdUIsb0dBQW9HLEVBQUUsU0FBUyxrRkFBa0YsdUJBQXVCLG9HQUFvRyxFQUFFLFNBQVMsT0FBTyxLQUFLLEVBQUUsb0RBQW9ELCtCQUErQixnRkFBZ0YsMENBQTBDLDJCQUEyQixnREFBZ0Qsb01BQW9NLEVBQUUsU0FBUyxFQUFFLE9BQU8sMkNBQTJDLCtLQUErSywrTUFBK00sMENBQTBDLG1IQUFtSCxxSUFBcUksMENBQTBDLDhEQUE4RCxvQ0FBb0Msd0NBQXdDLGFBQWEsV0FBVyxFQUFFLHdCQUF3QixTQUFTLEVBQUUsT0FBTyw4QkFBOEIscURBQXFELE9BQU8sS0FBSyxFQUFFLCtDQUErQywrQkFBK0IsMkdBQTJHLGtEQUFrRCx3QkFBd0IsMk1BQTJNLDRGQUE0Rix5Q0FBeUMsT0FBTyxrQ0FBa0MsbURBQW1ELDJCQUEyQiwwQkFBMEIscUhBQXFILEVBQUUsU0FBUyxPQUFPLDhCQUE4QixtREFBbUQsMENBQTBDLDREQUE0RCxTQUFTLE9BQU8sS0FBSyxFQUFFLDhDQUE4QyxpQ0FBaUMseTBCQUF5MEIsc0JBQXNCLDJCQUEyQiw0QkFBNEIsU0FBUyw0QkFBNEIsNkJBQTZCLFNBQVMsMkJBQTJCLDRCQUE0QixTQUFTLDRCQUE0Qiw2QkFBNkIsU0FBUyxxQ0FBcUMscUNBQXFDLHVDQUF1QyxTQUFTLDZCQUE2QixxQ0FBcUMsdUNBQXVDLDBDQUEwQyxTQUFTLDZCQUE2QixxQ0FBcUMsdUNBQXVDLDRDQUE0QyxTQUFTLE9BQU8sZ0VBQWdFLHlFQUF5RSxXQUFXLHdDQUF3Qyx5Q0FBeUMsNENBQTRDLFdBQVcsT0FBTyx1REFBdUQseUNBQXlDLCtEQUErRCxXQUFXLHVDQUF1Qyx1Q0FBdUMsOENBQThDLFdBQVcsT0FBTyxxREFBcUQsdUNBQXVDLCtEQUErRCxXQUFXLFNBQVMsT0FBTyxLQUFLLEVBQUUsbUNBQW1DLG1TQUFtUywwQ0FBMEMsaVdBQWlXLDRMQUE0TCwwREFBMEQsa0NBQWtDLHdEQUF3RCxhQUFhLFdBQVcsU0FBUyw0VUFBNFUsNEJBQTRCLG1LQUFtSyxpQ0FBaUMsb0dBQW9HLG9DQUFvQyw0QkFBNEIsZ1FBQWdRLGlDQUFpQyx1SEFBdUgsMERBQTBELHNFQUFzRSxnQ0FBZ0MsOEhBQThILGlDQUFpQyxtQ0FBbUMseURBQXlELGdDQUFnQyxTQUFTLHlEQUF5RCxnQ0FBZ0MsU0FBUywrQkFBK0IsNkJBQTZCLE9BQU8sZ0NBQWdDLG9DQUFvQyxzQkFBc0IsU0FBUyxPQUFPLHdDQUF3Qyw0Q0FBNEMsZ0VBQWdFLDRCQUE0QixTQUFTLCtEQUErRCxPQUFPLHNDQUFzQyxzRUFBc0Usa0NBQWtDLGlDQUFpQyxrTUFBa00sZ0RBQWdELG1DQUFtQywyREFBMkQsU0FBUywrRUFBK0UsbUhBQW1ILG9DQUFvQyxTQUFTLE9BQU8sdURBQXVELFNBQVMsT0FBTyxrQ0FBa0MsNkJBQTZCLE9BQU8sZ0ZBQWdGLGtEQUFrRCxpRkFBaUYsaUJBQWlCLFNBQVMsK0JBQStCLG9DQUFvQyxpQ0FBaUMsa0NBQWtDLG1FQUFtRSwwSUFBMEksMkRBQTJELHVMQUF1TCx1UUFBdVEsYUFBYSxXQUFXLGlCQUFpQixTQUFTLG9FQUFvRSwwQ0FBMEMsU0FBUyxFQUFFLE9BQU8sa0NBQWtDLDRCQUE0QixPQUFPLHdDQUF3QywwQkFBMEIsT0FBTyx1REFBdUQsZ0hBQWdILDJDQUEyQyxTQUFTLCtEQUErRCw2REFBNkQsd0RBQXdELHVCQUF1QixTQUFTLGlDQUFpQywwQ0FBMEMsU0FBUyx1QkFBdUIsT0FBTyw4QkFBOEIsd0JBQXdCLDZCQUE2QixrQ0FBa0Msa0NBQWtDLFdBQVcsbUJBQW1CLFNBQVMsOEJBQThCLHdEQUF3RCx1QkFBdUIsMkJBQTJCLGdDQUFnQyxzQ0FBc0MsZ1FBQWdRLDRFQUE0RSxTQUFTLG9FQUFvRSxnQ0FBZ0MscUNBQXFDLFNBQVMsRUFBRSwwTkFBME4sa0NBQWtDLE9BQU8sa0RBQWtELG9YQUFvWCwwQkFBMEIsd0RBQXdELFNBQVMsaUNBQWlDLHNEQUFzRCxTQUFTLGlDQUFpQyxpRUFBaUUsU0FBUyxpQ0FBaUMsc0VBQXNFLFNBQVMsaUNBQWlDLG1DQUFtQyxTQUFTLGlDQUFpQyxPQUFPLCtDQUErQywrQkFBK0Isd0tBQXdLLDRCQUE0QixrQ0FBa0MsV0FBVyxTQUFTLGlDQUFpQyw4QkFBOEIsbUtBQW1LLE9BQU8sa0RBQWtELHlKQUF5SiwrR0FBK0csNkJBQTZCLG1DQUFtQyw0Q0FBNEMsc0lBQXNJLHFDQUFxQyxnQ0FBZ0MscUJBQXFCLGFBQWEseUhBQXlILHFCQUFxQixhQUFhLHdLQUF3Syx1R0FBdUcsdUNBQXVDLDhCQUE4QixlQUFlLEVBQUUsdUNBQXVDLGFBQWEsK0ZBQStGLHVDQUF1Qyw2QkFBNkIsZUFBZSxFQUFFLHVDQUF1QyxhQUFhLFdBQVcsaURBQWlELHlDQUF5QyxvQ0FBb0MsYUFBYSxXQUFXLFNBQVMsRUFBRSw4UEFBOFAsOEJBQThCLGlGQUFpRixFQUFFLFNBQVMsT0FBTyxvREFBb0QsMEJBQTBCLHlKQUF5SiwyQ0FBMkMsZ0RBQWdELCtSQUErUixxR0FBcUcsYUFBYSxXQUFXLFNBQVMsRUFBRSw4TkFBOE4sMERBQTBELHNEQUFzRCwrQkFBK0IseUVBQXlFLGdEQUFnRCx3Q0FBd0MsbUNBQW1DLDhCQUE4QixXQUFXLFNBQVMsRUFBRSxrSEFBa0gscUNBQXFDLDhCQUE4QixrRUFBa0UsRUFBRSxPQUFPLHVDQUF1QyxrQ0FBa0MsNkJBQTZCLElBQUksU0FBUyx5Q0FBeUMsT0FBTyx3REFBd0QsdUhBQXVILDRHQUE0RyxnQ0FBZ0MsT0FBTyxrREFBa0QsbUVBQW1FLDBGQUEwRixpQ0FBaUMsa0ZBQWtGLDJEQUEyRCxpQkFBaUIsU0FBUyxrREFBa0QsbUNBQW1DLHlDQUF5QywwREFBMEQsU0FBUyxvRUFBb0UsdUNBQXVDLFNBQVMsb0dBQW9HLHVDQUF1QyxvREFBb0QsWUFBWSw2QkFBNkIsMkVBQTJFLDZCQUE2QixnQ0FBZ0MsMkZBQTJGLFNBQVMsRUFBRSxzREFBc0Qsd0RBQXdELE9BQU8sa0RBQWtELDJEQUEyRCxtQ0FBbUMsa0JBQWtCLDJFQUEyRSxTQUFTLG1DQUFtQyw4TEFBOEwscURBQXFELGtDQUFrQyxrRUFBa0UsV0FBVywyQ0FBMkMsMkRBQTJELFdBQVcsMkNBQTJDLG1JQUFtSSxnQ0FBZ0MsNkxBQTZMLHdEQUF3RCxvQ0FBb0MsaUVBQWlFLFdBQVcsU0FBUyxFQUFFLE9BQU8sa0RBQWtELGlZQUFpWSxtQ0FBbUMsa0JBQWtCLG1LQUFtSyxTQUFTLG1DQUFtQyxxVkFBcVYscURBQXFELGtDQUFrQyxvRUFBb0UsV0FBVywrQ0FBK0MsNkRBQTZELFdBQVcsMkNBQTJDLDZLQUE2SyxvREFBb0Qsa0RBQWtELGdDQUFnQyw2TEFBNkwsd0RBQXdELG9DQUFvQyxtRUFBbUUsV0FBVyxTQUFTLDhCQUE4QixPQUFPLDRDQUE0QyxpQ0FBaUMsNENBQTRDLG9DQUFvQyxxREFBcUQsV0FBVyxTQUFTLEVBQUUsT0FBTyxzREFBc0QsZ0NBQWdDLGtEQUFrRCxPQUFPLHNEQUFzRCxrR0FBa0csOEJBQThCLHNDQUFzQyxTQUFTLE9BQU8sMERBQTBELG9FQUFvRSwyQkFBMkIseUJBQXlCLGlFQUFpRSxTQUFTLDJCQUEyQixPQUFPLDBDQUEwQyxtQ0FBbUMsNkdBQTZHLE9BQU8sd0NBQXdDLHlJQUF5SSwyQkFBMkIsK0JBQStCLFNBQVMsd0RBQXdELDJCQUEyQiwrQkFBK0IsU0FBUyxPQUFPLG1EQUFtRCxxRkFBcUYsK0NBQStDLHNDQUFzQyxpREFBaUQsMEJBQTBCLFdBQVcsc0RBQXNELDBDQUEwQyxXQUFXLFNBQVMsRUFBRSx1QkFBdUIsdUJBQXVCLDZCQUE2QixTQUFTLDBEQUEwRCxnRUFBZ0UsU0FBUyxPQUFPLG9EQUFvRCxxRkFBcUYsd0NBQXdDLHlFQUF5RSxTQUFTLHFDQUFxQyxpQkFBaUIsU0FBUyxrQ0FBa0MscUNBQXFDLG1EQUFtRCxTQUFTLG9DQUFvQyxnQ0FBZ0MsU0FBUyxzQ0FBc0MsNkNBQTZDLDRGQUE0RixFQUFFLFNBQVMsc0NBQXNDLDZEQUE2RCx3Q0FBd0MsNENBQTRDLFdBQVcsd0NBQXdDLGtDQUFrQyxXQUFXLFNBQVMscUNBQXFDLDJCQUEyQixTQUFTLHNDQUFzQyxxSEFBcUgsd0NBQXdDLDRDQUE0QyxXQUFXLHdHQUF3RywrREFBK0QsV0FBVyxtR0FBbUcsa0NBQWtDLFdBQVcsU0FBUyxrQ0FBa0Msd0VBQXdFLFNBQVMsT0FBTyxnQ0FBZ0MsMlJBQTJSLDJEQUEyRCwyR0FBMkcsRUFBRSxpREFBaUQsMkNBQTJDLFNBQVMseUlBQXlJLGtFQUFrRSxnQkFBZ0IsNkVBQTZFLGtJQUFrSSw0Q0FBNEMsNEJBQTRCLHVIQUF1SCxFQUFFLFNBQVMsT0FBTyw4RUFBOEUsU0FBUywwREFBMEQsZ0ZBQWdGLFNBQVMsT0FBTyw4Q0FBOEMsNEVBQTRFLCtCQUErQixtQ0FBbUMsNkhBQTZILHVEQUF1RCxTQUFTLEVBQUUsT0FBTyxrREFBa0QsZ0NBQWdDLHFDQUFxQyxtQ0FBbUMsU0FBUyxPQUFPLDZEQUE2RCw2REFBNkQsc0JBQXNCLFNBQVMsOEpBQThKLE9BQU8sa0RBQWtELGtDQUFrQyxpQkFBaUIsU0FBUyxvSkFBb0osbUNBQW1DLDRCQUE0QixTQUFTLEVBQUUsNERBQTRELDZPQUE2Tyw4Q0FBOEMsOEJBQThCLHVCQUF1QixlQUFlLHFEQUFxRCx1Q0FBdUMsZ0VBQWdFLGVBQWUsYUFBYSxXQUFXLEVBQUUsU0FBUywwR0FBMEcsa0NBQWtDLDRDQUE0QyxFQUFFLDRHQUE0RyxPQUFPLG9EQUFvRCxrQ0FBa0MsaUJBQWlCLFNBQVMsNkJBQTZCLHdFQUF3RSw0QkFBNEIsaUZBQWlGLFdBQVcsT0FBTyxpRUFBaUUsV0FBVyxrQ0FBa0MsOEJBQThCLFNBQVMsT0FBTyxLQUFLLEVBQUUsK1JBQStSLDRFQUE0RSx3VEFBd1Qsb0NBQW9DLG1GQUFtRiw0QkFBNEIsMEJBQTBCLG9FQUFvRSw4QkFBOEIsVUFBVSwyRUFBMkUsaUNBQWlDLHVGQUF1RixXQUFXLE9BQU8sMkhBQTJILGlIQUFpSCxXQUFXLFVBQVUsc0NBQXNDLGtFQUFrRSxPQUFPLHFEQUFxRCwySUFBMkksb0RBQW9ELE9BQU8sd0NBQXdDLGtCQUFrQixnQkFBZ0IsaUJBQWlCLE9BQU8saUNBQWlDLDhCQUE4QixXQUFXLFNBQVMsT0FBTyxzQ0FBc0MsaUVBQWlFLDZCQUE2QiwyRUFBMkUsT0FBTyxvREFBb0QsaUNBQWlDLG9FQUFvRSwrQkFBK0IsWUFBWSxTQUFTLDhCQUE4QixtRUFBbUUsK0JBQStCLHNDQUFzQyxTQUFTLGtDQUFrQyxPQUFPLDZDQUE2QywrQ0FBK0MseUNBQXlDLDBEQUEwRCxTQUFTLDBCQUEwQixpRUFBaUUsU0FBUyxPQUFPLGlEQUFpRCwrQ0FBK0MseUNBQXlDLDZEQUE2RCxTQUFTLDBCQUEwQixtRUFBbUUsU0FBUyxPQUFPLHFDQUFxQywrQ0FBK0Msc0pBQXNKLGlCQUFpQixTQUFTLDhGQUE4Rix3Q0FBd0MsMkRBQTJELFdBQVcsK0RBQStELFNBQVMsT0FBTyxtQ0FBbUMsK0NBQStDLHNKQUFzSixpQkFBaUIsU0FBUyw4RkFBOEYsd0NBQXdDLDhEQUE4RCxXQUFXLDhEQUE4RCxTQUFTLE9BQU8sNkNBQTZDLGtHQUFrRyxzSkFBc0osdUJBQXVCLFNBQVMsdUdBQXVHLHFEQUFxRCw4T0FBOE8sb0RBQW9ELG9DQUFvQyx3Q0FBd0MseUJBQXlCLFdBQVcsU0FBUyxFQUFFLHFDQUFxQyx1QkFBdUIsU0FBUyw4RkFBOEYseUNBQXlDLCtEQUErRCxXQUFXLDBDQUEwQyw4REFBOEQsV0FBVywrREFBK0QsZ0NBQWdDLFNBQVMsdUJBQXVCLE9BQU8sMkJBQTJCLGdCQUFnQixtSkFBbUosT0FBTyxLQUFLLEVBQUUsb0NBQW9DLCtDQUErQyxzREFBc0QsT0FBTyxzRUFBc0UsZ0NBQWdDLHVCQUF1QixTQUFTLDZlQUE2ZSxrQ0FBa0MsbUZBQW1GLG9VQUFvVSw2TEFBNkwsaVlBQWlZLDZDQUE2QyxTQUFTLFFBQVEsS0FBSyxHQUFHLG9HQUFvRyx1Q0FBdUMsOEJBQThCLDBEQUEwRCxpUUFBaVEscUNBQXFDLGNBQWMsT0FBTyxzSkFBc0oscUJBQXFCLFdBQVcsNEVBQTRFLGlCQUFpQixPQUFPLDhDQUE4Qyw0Q0FBNEMsc0NBQXNDLGFBQWEsV0FBVyxzRUFBc0UsZ0NBQWdDLHFCQUFxQixXQUFXLHNHQUFzRyw2Q0FBNkMsV0FBVyxnREFBZ0QsNEJBQTRCLDBHQUEwRyxFQUFFLFNBQVMsT0FBTyw4Q0FBOEMsNEJBQTRCLHNMQUFzTCw4QkFBOEIsbUJBQW1CLFdBQVcsMkhBQTJILDhEQUE4RCxXQUFXLDBJQUEwSSw4QkFBOEIsZ0NBQWdDLGlEQUFpRCxXQUFXLFNBQVMsRUFBRSx1QkFBdUIsT0FBTyx3REFBd0QsZ09BQWdPLG9EQUFvRCw0REFBNEQsV0FBVyxTQUFTLEVBQUUsT0FBTyw4Q0FBOEMsNktBQTZLLDBEQUEwRCxTQUFTLHNMQUFzTCwyRUFBMkUsbUJBQW1CLFdBQVcsNFFBQTRRLHFCQUFxQixtQkFBbUIsV0FBVyxzQ0FBc0MsNEZBQTRGLHVGQUF1Riw2RUFBNkUsYUFBYSxFQUFFLGtDQUFrQyxvRUFBb0UsNERBQTRELGFBQWEsV0FBVyw0RkFBNEYsMENBQTBDLHdDQUF3Qyw4REFBOEQsV0FBVywyQkFBMkIsaUVBQWlFLDBFQUEwRSwyRkFBMkYseUNBQXlDLHlDQUF5QywrREFBK0QsV0FBVyxTQUFTLEVBQUUsT0FBTyxzREFBc0QsOEVBQThFLG1MQUFtTCwwREFBMEQsU0FBUyxPQUFPLE1BQU0sbUNBQW1DLHNjQUFzYyxpQkFBaUIsZ0JBQWdCLE1BQU0sZ1VBQWdVLDBYQUEwWCw4QkFBOEIsSUFBSSxlQUFlLElBQUksZUFBZSxJQUFJLHFGQUFxRiw4RUFBOEUsU0FBUyxPQUFPLEdBQUcsOExBQThMLG1HQUFtRyxTQUFTLE9BQU8sR0FBRyxvSEFBb0gsRUFBRSxXQUFXLEVBQUUsV0FBVyxFQUFFLDhDQUE4Qyx5R0FBeUcsU0FBUyxPQUFPLEdBQUcscUxBQXFMLHlKQUF5SixTQUFTLE9BQU8sR0FBRyxtTkFBbU4sMEZBQTBGLFNBQVMsT0FBTyxpR0FBaUcsb0VBQW9FLE9BQU8scUJBQXFCLGVBQWUsa0JBQWtCLGtCQUFrQiw4REFBOEQscUJBQXFCLDhEQUE4RCxvQkFBb0IsOERBQThELFdBQVcsU0FBUyxnQkFBZ0Isa0JBQWtCLGtCQUFrQixpRUFBaUUsMEJBQTBCLGlFQUFpRSx5QkFBeUIsaUVBQWlFLFdBQVcsU0FBUyxPQUFPLHdCQUF3QixtQkFBbUIsaURBQWlELHVCQUF1Qix5QkFBeUIsdUJBQXVCLGlEQUFpRCxPQUFPLHVDQUF1QyxnTkFBZ04sZ0hBQWdILDhFQUE4RSw2SEFBNkgsd0NBQXdDLDZCQUE2Qix1RUFBdUUsT0FBTyxFQUFFLGlEQUFpRCw4Q0FBOEMsOEJBQThCLDJEQUEyRCxTQUFTLHVIQUF1SCxxSEFBcUgsMEJBQTBCLFNBQVMseUJBQXlCLHVLQUF1SyxTQUFTLGtJQUFrSSxPQUFPLHNDQUFzQyw4REFBOEQsc0NBQXNDLGtEQUFrRCx5S0FBeUsseUJBQXlCLDZDQUE2Qyx1S0FBdUssNkNBQTZDLGlGQUFpRixXQUFXLFNBQVMsRUFBRSxvRUFBb0UsZ05BQWdOLG9EQUFvRCxXQUFXLHdCQUF3QixTQUFTLGtEQUFrRCxPQUFPLG1EQUFtRCx3REFBd0Qsa0NBQWtDLGtEQUFrRCx3QkFBd0IsV0FBVyw2Q0FBNkMseUNBQXlDLDhCQUE4QixXQUFXLHVHQUF1Ryw2R0FBNkcsNENBQTRDLDZCQUE2QixXQUFXLHNDQUFzQyxtRUFBbUUsV0FBVyxxQ0FBcUMsMERBQTBELDBEQUEwRCxhQUFhLEVBQUUsd0JBQXdCLFdBQVcsc0NBQXNDLHVDQUF1Qyx3REFBd0QsdUNBQXVDLCtEQUErRCxpQkFBaUIsZUFBZSxFQUFFLGFBQWEsT0FBTyx3REFBd0Qsd0NBQXdDLHdEQUF3RCw0SEFBNEgsa05BQWtOLDZCQUE2QixxQkFBcUIseURBQXlELG1CQUFtQixpTUFBaU0saUJBQWlCLEVBQUUsMEhBQTBILDhFQUE4RSxxQ0FBcUMseURBQXlELG1CQUFtQixpQkFBaUIsZUFBZSxFQUFFLGFBQWEsMEJBQTBCLFdBQVcsU0FBUyxtQ0FBbUMsc0ZBQXNGLDRDQUE0QyxxRUFBcUUsNEJBQTRCLHVGQUF1RixvREFBb0QsZ0RBQWdELG9FQUFvRSw4QkFBOEIsaUJBQWlCLGVBQWUsRUFBRSxhQUFhLDBCQUEwQixXQUFXLEVBQUUsc0JBQXNCLFNBQVMsb0NBQW9DLGtEQUFrRCxvREFBb0Qsb0NBQW9DLG1DQUFtQyxhQUFhLFdBQVcsRUFBRSw0QkFBNEIsU0FBUywyREFBMkQsK1NBQStTLG1DQUFtQyxrREFBa0QsbUtBQW1LLDZFQUE2RSxxQkFBcUIsYUFBYSwrREFBK0QsdUNBQXVDLGFBQWEsT0FBTyw2QkFBNkIsMkRBQTJELHlDQUF5QyxpQkFBaUIsaURBQWlELHlDQUF5QyxpQkFBaUIsZUFBZSw2RkFBNkYsYUFBYSxXQUFXLEVBQUUseUNBQXlDLFNBQVMsd0NBQXdDLDBGQUEwRix3QkFBd0IsV0FBVywrR0FBK0csMERBQTBELDhDQUE4QyxXQUFXLEdBQUcsU0FBUyxnREFBZ0QsOEZBQThGLGlEQUFpRCxXQUFXLEVBQUUsZ0NBQWdDLHVCQUF1Qiw4QkFBOEIsV0FBVyxnREFBZ0QsU0FBUyxnREFBZ0QsK0ZBQStGLDRCQUE0QixnQ0FBZ0MsYUFBYSxrREFBa0QsOENBQThDLGFBQWEsdUJBQXVCLFdBQVcsRUFBRSxnQ0FBZ0MsdUJBQXVCLDhCQUE4QixXQUFXLGdEQUFnRCxTQUFTLDBEQUEwRCx5RUFBeUUsK0JBQStCLHVDQUF1QyxXQUFXLDBEQUEwRCxrRkFBa0Ysa0RBQWtELFdBQVcsYUFBYSxTQUFTLHdDQUF3Qyw2RUFBNkUsU0FBUyxPQUFPLEVBQUUsMENBQTBDLDZMQUE2TCx3QkFBd0IsMEJBQTBCLHFDQUFxQyxTQUFTLDBCQUEwQixtQkFBbUIsU0FBUywwQkFBMEIsK0NBQStDLFNBQVMsbUJBQW1CLE9BQU8sMENBQTBDLG9FQUFvRSw2Q0FBNkMsU0FBUywyU0FBMlMsNEJBQTRCLGdCQUFnQixTQUFTLHNCQUFzQix3Q0FBd0MsU0FBUyxzQkFBc0Isd0NBQXdDLFNBQVMsT0FBTyx3Q0FBd0MsU0FBUyxtTUFBbU0sZ0JBQWdCLFNBQVMscUJBQXFCLHlCQUF5QixTQUFTLE9BQU8sK0JBQStCLFNBQVMsZ0VBQWdFLFFBQVEsNENBQTRDLG9FQUFvRSw2Q0FBNkMsU0FBUyx5TEFBeUwsK0lBQStJLFFBQVEsa0RBQWtELHdIQUF3SCw2RUFBNkUsbUdBQW1HLHlDQUF5QyxXQUFXLHNDQUFzQyx1Q0FBdUMsV0FBVyx3TEFBd0wsNENBQTRDLGdFQUFnRSxnQ0FBZ0Msb0NBQW9DLGFBQWEsaURBQWlELFdBQVcsRUFBRSx1QkFBdUIscUNBQXFDLCtCQUErQix1QkFBdUIsV0FBVyxPQUFPLGdDQUFnQyxXQUFXLFVBQVUsbUhBQW1ILG1GQUFtRixtQkFBbUIsV0FBVyw4Q0FBOEMsZ09BQWdPLDRDQUE0Qyx5QkFBeUIsYUFBYSwyQ0FBMkMsNENBQTRDLHlDQUF5QyxhQUFhLGdEQUFnRCwwQkFBMEIsYUFBYSx5Q0FBeUMsOENBQThDLDRCQUE0QixtRkFBbUYsZUFBZSxhQUFhLHNDQUFzQyxtQ0FBbUMsWUFBWSxTQUFTLEVBQUUsT0FBTyxFQUFFLHNKQUFzSixzQ0FBc0Msd0NBQXdDLG1DQUFtQyw0Q0FBNEMsNEZBQTRGLHdIQUF3SCwrQ0FBK0MsOERBQThELGtGQUFrRiwySEFBMkgseUJBQXlCLGlGQUFpRixtREFBbUQscUJBQXFCLGFBQWEsbUJBQW1CLGlJQUFpSSxpQkFBaUIsK0NBQStDLGVBQWUscUJBQXFCLHlDQUF5QyxlQUFlLFlBQVksMkdBQTJHLGFBQWEsWUFBWSxrREFBa0QsZ0NBQWdDLDhDQUE4QyxxQ0FBcUMsa0NBQWtDLGFBQWEsc0ZBQXNGLFlBQVksU0FBUyxFQUFFLFFBQVEsOEJBQThCLHFDQUFxQyx3Q0FBd0MsNEJBQTRCLCtFQUErRSw0REFBNEQsV0FBVyxFQUFFLDBCQUEwQixTQUFTLFFBQVEseUxBQXlMLGlsQkFBaWxCLEtBQUssVUFBVSxzUkFBc1IsaUdBQWlHLHNNQUFzTSx5SEFBeUgseUNBQXlDLGtGQUFrRixnREFBZ0QsOEJBQThCLFdBQVcsVUFBVSxPQUFPLEVBQUUseUNBQXlDLDZMQUE2TCxxRUFBcUUsNkJBQTZCLDJCQUEyQiw2QkFBNkIscURBQXFELG9EQUFvRCxhQUFhLFdBQVcsb0NBQW9DLE9BQU8sOEJBQThCLG1EQUFtRCx1Q0FBdUMsYUFBYSxXQUFXLFNBQVMsd0JBQXdCLE9BQU8sc0RBQXNELHFCQUFxQixvQ0FBb0Msa0NBQWtDLGlDQUFpQywyQ0FBMkMseUNBQXlDLGlFQUFpRSxtQ0FBbUMsZUFBZSxhQUFhLFdBQVcsU0FBUyxzQkFBc0IsT0FBTyxzREFBc0QsNENBQTRDLGlHQUFpRyxVQUFVLE9BQU8sK0VBQStFLG9EQUFvRCx1Q0FBdUMsZ05BQWdOLHFIQUFxSCw2QkFBNkIsb0JBQW9CLDhFQUE4RSxXQUFXLEVBQUUsa0ZBQWtGLGdFQUFnRSxrQ0FBa0MsNERBQTRELGVBQWUsYUFBYSxFQUFFLFlBQVksK0JBQStCLDZIQUE2SCxvREFBb0QsOERBQThELHdCQUF3QixXQUFXLEVBQUUsd0VBQXdFLDhIQUE4SCxzR0FBc0csTUFBTSx3RUFBd0UsdUNBQXVDLGVBQWUsYUFBYSxFQUFFLDZDQUE2QyxpQ0FBaUMsV0FBVyxFQUFFLDBHQUEwRyxpRUFBaUUscUlBQXFJLCtCQUErQixnREFBZ0Qsa0NBQWtDLGVBQWUsRUFBRSxhQUFhLEVBQUUsK0pBQStKLFdBQVcsRUFBRSxTQUFTLEVBQUUsUUFBUSxxQkFBcUIsbUNBQW1DLGlFQUFpRSw4REFBOEQsMENBQTBDLHlEQUF5RCxZQUFZLFNBQVMsc0RBQXNELGlFQUFpRSw2RUFBNkUsNkNBQTZDLHlEQUF5RCxZQUFZLFNBQVMseURBQXlELHdFQUF3RSxzRUFBc0UsMkJBQTJCLDZGQUE2RixlQUFlLE9BQU8sa0VBQWtFLGtEQUFrRCxJQUFJLHFEQUFxRCwyQkFBMkIsZUFBZSxhQUFhLE9BQU8sZ0dBQWdHLGlEQUFpRCx3QkFBd0IsYUFBYSxZQUFZLFNBQVMsb0dBQW9HLG9EQUFvRCwwREFBMEQsMkJBQTJCLFNBQVMsT0FBTyxFQUFFLEtBQUssSUFBSSxzUkFBc1IsMkJBQTJCLDZIQUE2SCx5QkFBeUIsZ0JBQWdCLE9BQU8sa0NBQWtDLHlFQUF5RSxhQUFhLFdBQVcsU0FBUyw4SEFBOEgscUJBQXFCLHVCQUF1QixnQkFBZ0IsT0FBTyxrQ0FBa0MscURBQXFELGtXQUFrVywyQkFBMkIsZUFBZSx5Q0FBeUMsYUFBYSxXQUFXLFNBQVMsOENBQThDLG9DQUFvQyw0REFBNEQsV0FBVyx3QkFBd0IsU0FBUyxvTkFBb04sbUJBQW1CLGdDQUFnQyw2Q0FBNkMsb0JBQW9CLG9EQUFvRCxvQkFBb0Isa0RBQWtELG9CQUFvQixvRUFBb0UsV0FBVyxnQ0FBZ0MsOENBQThDLG9CQUFvQixvREFBb0Qsb0JBQW9CLGlEQUFpRCxvQkFBb0IsbUVBQW1FLFdBQVcsb0JBQW9CLDZDQUE2QyxTQUFTLHNJQUFzSSxzSEFBc0gsb0NBQW9DLFdBQVcsK0NBQStDLGtKQUFrSixrRkFBa0YsMkpBQTJKLHVHQUF1RyxrRkFBa0YsK0NBQStDLCtKQUErSixzQkFBc0IsV0FBVyxZQUFZLG1DQUFtQyxXQUFXLGtDQUFrQyw2SEFBNkgsOEJBQThCLFdBQVcsdUNBQXVDLHNPQUFzTyx5QkFBeUIsaURBQWlELEVBQUUseUJBQXlCLGlEQUFpRCxFQUFFLFdBQVcsT0FBTyw2QkFBNkIsNkdBQTZHLEVBQUUsa0ZBQWtGLDRDQUE0QyxzREFBc0Qsc0NBQXNDLGVBQWUsYUFBYSxFQUFFLHlCQUF5Qix5SkFBeUosRUFBRSxXQUFXLDhCQUE4QiwyQ0FBMkMsU0FBUyx5REFBeUQsOENBQThDLCtEQUErRCxrREFBa0QsK0hBQStILGdDQUFnQyxhQUFhLFdBQVcsMkJBQTJCLFNBQVMsOEVBQThFLDhCQUE4Qix3Q0FBd0MsMENBQTBDLGdDQUFnQyxvREFBb0QsYUFBYSxXQUFXLEVBQUUsdUJBQXVCLFNBQVMsT0FBTyxFQUFFLHFJQUFxSSxpR0FBaUcsMkJBQTJCLGlDQUFpQyxTQUFTLDhDQUE4QyxrQ0FBa0MsNkRBQTZELHVCQUF1QixTQUFTLG9FQUFvRSw2QkFBNkIsdUJBQXVCLHVCQUF1QixTQUFTLG9HQUFvRywyQkFBMkIsMEJBQTBCLHVCQUF1QixTQUFTLDJFQUEyRSwyQkFBMkIsdUJBQXVCLFNBQVMsbURBQW1ELG9DQUFvQyxTQUFTLDRDQUE0QyxnSkFBZ0osdURBQXVELHNCQUFzQixPQUFPLGtEQUFrRCw0SUFBNEksc0JBQXNCLFNBQVMsMkhBQTJILHNCQUFzQixTQUFTLDREQUE0RCxzQkFBc0IsU0FBUyw4R0FBOEcsc0JBQXNCLFNBQVMsMERBQTBELE9BQU8scUJBQXFCLHdGQUF3RiwyTEFBMkwsNENBQTRDLGlHQUFpRyw4REFBOEQsYUFBYSxPQUFPLDRDQUE0QyxvQ0FBb0MsMkNBQTJDLGlCQUFpQixlQUFlLEVBQUUsYUFBYSxXQUFXLGdDQUFnQyx5R0FBeUcsK0JBQStCLDJDQUEyQyx1Q0FBdUMsZUFBZSx5Q0FBeUMsdUJBQXVCLGVBQWUsYUFBYSx1T0FBdU8sMkJBQTJCLHFCQUFxQixhQUFhLE9BQU8scURBQXFELGFBQWEsV0FBVyx1RkFBdUYsU0FBUyxnQ0FBZ0Msb0NBQW9DLGtEQUFrRCxpREFBaUQsYUFBYSxPQUFPLG9FQUFvRSxxQ0FBcUMsa0RBQWtELGFBQWEsWUFBWSxTQUFTLDJDQUEyQyxvQ0FBb0Msa0RBQWtELGlEQUFpRCxhQUFhLE9BQU8sb0VBQW9FLHFDQUFxQyxrREFBa0QsYUFBYSxZQUFZLFNBQVMsNkNBQTZDLG9DQUFvQyxtRkFBbUYsaURBQWlELGFBQWEsT0FBTyxvRUFBb0UsdUNBQXVDLGtEQUFrRCxhQUFhLFlBQVksU0FBUyxpRkFBaUYsMkRBQTJELHNFQUFzRSwwQ0FBMEMsOENBQThDLGFBQWEsV0FBVyxFQUFFLHFCQUFxQixTQUFTLE9BQU8sRUFBRSxLQUFLLElBQUksc1JBQXNSLHFIQUFxSCx3RkFBd0YsMENBQTBDLG9DQUFvQyxVQUFVLE9BQU8sRUFBRSw2QkFBNkIsZ0NBQWdDLCtDQUErQyxTQUFTLGlDQUFpQywwQ0FBMEMsU0FBUyx1Q0FBdUMsb0hBQW9ILFNBQVMsaUNBQWlDLHFDQUFxQyxTQUFTLHFDQUFxQyw0Q0FBNEMsb0VBQW9FLCtGQUErRixTQUFTLE9BQU8sRUFBRSxtREFBbUQsNkNBQTZDLHVEQUF1RCxtQ0FBbUMsVUFBVSx5REFBeUQsMEVBQTBFLFVBQVUsT0FBTyxFQUFFLEtBQUssSUFBSSw2QkFBNkIseVVBQXlVLHFqQkFBcWpCLDBGQUEwRiw2SEFBNkgsMkNBQTJDLE9BQU8sT0FBTyxrQ0FBa0MsT0FBTyxrQkFBa0IsaURBQWlELG1DQUFtQyxFQUFFLGdDQUFnQyxrREFBa0QsMkNBQTJDLHNCQUFzQix1R0FBdUcseUNBQXlDLEVBQUUsNERBQTRELE9BQU8scURBQXFELDRCQUE0Qix3QkFBd0IsK0NBQStDLFNBQVMsT0FBTyxpREFBaUQsa0hBQWtILGtDQUFrQyxzQkFBc0IsV0FBVyx5Q0FBeUMsc0NBQXNDLGlCQUFpQixTQUFTLE9BQU8sRUFBRSxNQUFNLCtVQUErVSwwM0JBQTAzQiwrRkFBK0YsZ0NBQWdDLE9BQU8sa0NBQWtDLGdCQUFnQixrQ0FBa0Msb0hBQW9ILGdGQUFnRixPQUFPLG1CQUFtQixvQkFBb0IsOEJBQThCLDBCQUEwQiwrTkFBK04sT0FBTyx3RUFBd0UscURBQXFELE9BQU8sc0JBQXNCLHdCQUF3QixvR0FBb0csV0FBVyxPQUFPLG9CQUFvQiw0REFBNEQsMkVBQTJFLHNEQUFzRCxPQUFPLGdEQUFnRCxrQkFBa0IsOEJBQThCLDREQUE0RCwwQ0FBMEMsT0FBTyw4QkFBOEIsbUJBQW1CLG9CQUFvQixTQUFTLHVDQUF1QyxvQ0FBb0MsZUFBZSxPQUFPLEVBQUUsa0hBQWtILG9GQUFvRixPQUFPLHFCQUFxQixNQUFNLHVVQUF1VSxrY0FBa2Msd0RBQXdELGlEQUFpRCxnQkFBZ0IscUVBQXFFLG1DQUFtQyxFQUFFLHlEQUF5RCxpQ0FBaUMsNEJBQTRCLDZCQUE2Qiw0Q0FBNEMsT0FBTyw0RUFBNEUsb0RBQW9ELCtDQUErQyxrSEFBa0gsc0JBQXNCLHNCQUFzQixXQUFXLHlDQUF5QyxzQ0FBc0MsaUJBQWlCLFNBQVMsT0FBTyxFQUFFLE1BQU0sdVVBQXVVLG1kQUFtZCxvQ0FBb0Msb0JBQW9CLDRDQUE0QyxnQkFBZ0Isa0NBQWtDLGdHQUFnRyxtQkFBbUIsbUZBQW1GLE9BQU8sd0lBQXdJLDBDQUEwQyxrSEFBa0gsa0NBQWtDLHNCQUFzQixXQUFXLHlDQUF5QyxzQ0FBc0MsaUJBQWlCLFNBQVMsT0FBTyxFQUFFLE1BQU0sbVZBQW1WLGltQkFBaW1CLGdFQUFnRSwwQkFBMEIsK0NBQStDLHlCQUF5QixTQUFTLE9BQU8saUVBQWlFLFVBQVUsT0FBTyxxREFBcUQsZ0NBQWdDLHFCQUFxQixXQUFXLE9BQU8seURBQXlELG1DQUFtQywyT0FBMk8sMklBQTJJLG1PQUFtTyxxUUFBcVEsV0FBVyw2SUFBNkksOENBQThDLFNBQVMsT0FBTyxpQ0FBaUMsZ0JBQWdCLDBDQUEwQyxFQUFFLDJCQUEyQixzQkFBc0Isb0JBQW9CLFNBQVMsaUJBQWlCLE9BQU8sTUFBTSx1VUFBdVUsb0ZBQW9GLGtCQUFrQiw0QkFBNEIsR0FBRyx3R0FBd0csRUFBRSxNQUFNLHVVQUF1VSw0bEJBQTRsQiwyQkFBMkIsZ0NBQWdDLGdCQUFnQixxRUFBcUUsbUNBQW1DLEVBQUUsd0dBQXdHLHNCQUFzQix1RUFBdUUsT0FBTyxtQkFBbUIsa0NBQWtDLGtEQUFrRCxJQUFJLGtEQUFrRCxFQUFFLE9BQU8sc0VBQXNFLGtEQUFrRCx3SEFBd0gsbUJBQW1CLG9CQUFvQixTQUFTLHVDQUF1QyxvQ0FBb0MsZUFBZSxPQUFPLEVBQUUsTUFBTSwyVkFBMlYsdUxBQXVMLDhEQUE4RCxnQ0FBZ0MsOEJBQThCLE9BQU8sb0NBQW9DLHVCQUF1Qix3RkFBd0Ysc0JBQXNCLGtIQUFrSCxrQ0FBa0Msd0JBQXdCLFdBQVcsMkNBQTJDLGlCQUFpQixTQUFTLE9BQU8sRUFBRSxNQUFNLHVVQUF1VSxzK0JBQXMrQix1RkFBdUYsZ0NBQWdDLGtCQUFrQixPQUFPLG9CQUFvQix1SUFBdUkseURBQXlELCtCQUErQixtQ0FBbUMsT0FBTyxPQUFPLGtFQUFrRSw4REFBOEQsT0FBTywwQ0FBMEMsZUFBZSxrR0FBa0csY0FBYyw4RkFBOEYsUUFBUSwyRUFBMkUsNkVBQTZFLHVDQUF1QyxnRkFBZ0YsMEVBQTBFLFNBQVMsNEVBQTRFLHVDQUF1QyxnRkFBZ0YsMEVBQTBFLFNBQVMsT0FBTyxpRkFBaUYsNkVBQTZFLHNEQUFzRCxnRkFBZ0YsMEVBQTBFLFNBQVMsT0FBTyxrQ0FBa0MsZ0JBQWdCLGtDQUFrQyxvREFBb0QsK0JBQStCLCtGQUErRiw2RUFBNkUsNEVBQTRFLDRFQUE0RSwyRUFBMkUsT0FBTyx3QkFBd0IsNEZBQTRGLDhJQUE4SSxrRUFBa0Usc0RBQXNELGdEQUFnRCwwREFBMEQsdUtBQXVLLDBCQUEwQiwwQ0FBMEMsV0FBVywwQkFBMEIsbVBBQW1QLHNCQUFzQixpT0FBaU8sMEVBQTBFLDJGQUEyRixxRkFBcUYsV0FBVyw4RUFBOEUsMkZBQTJGLHFGQUFxRixXQUFXLHdEQUF3RCxxRUFBcUUseURBQXlELCtDQUErQyxhQUFhLFdBQVcsRUFBRSxTQUFTLEVBQUUsT0FBTyx3Q0FBd0Msa0hBQWtILG9DQUFvQyxpREFBaUQsV0FBVyxvQ0FBb0Msc0JBQXNCLFdBQVcseUNBQXlDLDJCQUEyQixzSEFBc0gsc0JBQXNCLHFIQUFxSCxFQUFFLGFBQWEsT0FBTywrREFBK0QsK0NBQStDLHlHQUF5RywrR0FBK0csMENBQTBDLG1CQUFtQixnREFBZ0QsaUJBQWlCLEVBQUUsZUFBZSxFQUFFLGFBQWEsV0FBVyx3Q0FBd0MsaUJBQWlCLFNBQVMsT0FBTyxFQUFFLE1BQU0sMlVBQTJVLG1GQUFtRixtUkFBbVIsc0lBQXNJLHFCQUFxQiw2SEFBNkgsMEZBQTBGLDRCQUE0Qiw4QkFBOEIsa0ZBQWtGLDREQUE0RCwrQkFBK0IsT0FBTyx1REFBdUQsc0ZBQXNGLGFBQWEsb0JBQW9CLG1NQUFtTSwwREFBMEQsZ0NBQWdDLG1DQUFtQyxpQ0FBaUMsU0FBUyxrQ0FBa0MsbUNBQW1DLGlDQUFpQyxTQUFTLE9BQU8sd0NBQXdDLE1BQU0sdVVBQXVVLG1PQUFtTywrSUFBK0ksbUJBQW1CLG1MQUFtTCxvTUFBb00sT0FBTyxFQUFFLHFCQUFxQixNQUFNLG1WQUFtViw2Y0FBNmMsNkNBQTZDLHdDQUF3QyxzQkFBc0IsT0FBTyxzREFBc0QsV0FBVyxPQUFPLHNCQUFzQixxQ0FBcUMsc0JBQXNCLGtDQUFrQyxPQUFPLHNCQUFzQixpQ0FBaUMsc0JBQXNCLDhCQUE4QixtQkFBbUIsc0JBQXNCLFNBQVMsaUJBQWlCLE9BQU8sRUFBRSw0R0FBNEcsb0ZBQW9GLE9BQU8sdUJBQXVCLE1BQU0sMlVBQTJVLGdqQkFBZ2pCLDBCQUEwQiwwQkFBMEIsMkpBQTJKLGdDQUFnQyxnQkFBZ0Isa0NBQWtDLG9GQUFvRiwwRUFBMEUsMEVBQTBFLDBEQUEwRCw2QkFBNkIsV0FBVyxPQUFPLHFGQUFxRixPQUFPLDJHQUEyRyxnQ0FBZ0Msb0JBQW9CLFNBQVMsdUNBQXVDLG9DQUFvQyxlQUFlLE9BQU8sRUFBRSxrSEFBa0gsb0ZBQW9GLE9BQU8scUJBQXFCLE1BQU0sMlVBQTJVLHNlQUFzZSw0Q0FBNEMsZ0JBQWdCLDRGQUE0Rix1Q0FBdUMsbUNBQW1DLEVBQUUsbUJBQW1CLGdHQUFnRyxPQUFPLGdJQUFnSSwwQ0FBMEMsa0hBQWtILGtDQUFrQyxzQkFBc0IsV0FBVyx5Q0FBeUMsc0NBQXNDLGlCQUFpQixTQUFTLE9BQU8sRUFBRSxNQUFNLHVWQUF1Viw2VEFBNlQsNkpBQTZKLGdLQUFnSyxzTkFBc04sd0RBQXdELDBCQUEwQixlQUFlLE9BQU8sRUFBRSxNQUFNLHlUQUF5VCwwQ0FBMEMsb0ZBQW9GLGlEQUFpRCx3R0FBd0csa0dBQWtHLDZMQUE2TCxFQUFFLCtIQUErSCwrQkFBK0IsT0FBTyxzQ0FBc0MsOE1BQThNLCtCQUErQixPQUFPLHdDQUF3QyxxQ0FBcUMsb0NBQW9DLFNBQVMsZ0VBQWdFLCtCQUErQixPQUFPLGdFQUFnRSxxQ0FBcUMsd0NBQXdDLFNBQVMsa0RBQWtELGlFQUFpRSx1QkFBdUIsU0FBUyx1R0FBdUcsT0FBTyxtREFBbUQseUdBQXlHLDZCQUE2QiwrQkFBK0IsNkRBQTZELCtCQUErQixPQUFPLG9EQUFvRCw4QkFBOEIsd0ZBQXdGLFNBQVMscUNBQXFDLGtHQUFrRyxTQUFTLGtDQUFrQyxPQUFPLDRDQUE0QyxnSEFBZ0gsT0FBTyxnREFBZ0QsbUZBQW1GLHlLQUF5Syx1RkFBdUYsbUNBQW1DLHFEQUFxRCxtQ0FBbUMsd0dBQXdHLFdBQVcsU0FBUyxPQUFPLDZCQUE2QiwrRkFBK0YsRUFBRSxrQ0FBa0MscUNBQXFDLG1DQUFtQyxXQUFXLFNBQVMsd0NBQXdDLGdDQUFnQyxzQ0FBc0MsU0FBUywyQ0FBMkMsc0NBQXNDLFNBQVMsT0FBTyxLQUFLLEVBQUUsK1RBQStULDBDQUEwQywrUkFBK1Isb0NBQW9DLDhDQUE4QyxpREFBaUQsNkJBQTZCLGlGQUFpRiw4REFBOEQsOENBQThDLHNDQUFzQyxxRUFBcUUsK0NBQStDLHdiQUF3YixFQUFFLFdBQVcsRUFBRSxVQUFVLHlCQUF5Qiw2REFBNkQsNEJBQTRCLHdFQUF3RSxPQUFPLHNDQUFzQyxvRkFBb0YsMkVBQTJFLCtCQUErQixPQUFPLGlEQUFpRCwyREFBMkQsK0NBQStDLHNDQUFzQyxpQkFBaUIsU0FBUyw4REFBOEQsMENBQTBDLGtEQUFrRCxzREFBc0Qsc0hBQXNILEVBQUUsb0NBQW9DLHlCQUF5QixTQUFTLG9FQUFvRSwyREFBMkQsd0NBQXdDLG1EQUFtRCwyREFBMkQsc0NBQXNDLDJEQUEyRCx3Q0FBd0Msd0ZBQXdGLHdEQUF3RCxFQUFFLFdBQVcsU0FBUyxFQUFFLDhEQUE4RCxrRkFBa0YsMkJBQTJCLHdHQUF3RyxzSkFBc0osNkNBQTZDLDBDQUEwQyx5Q0FBeUMsa0VBQWtFLG1EQUFtRCwwREFBMEQsRUFBRSxhQUFhLE9BQU8scURBQXFELDREQUE0RCxFQUFFLGFBQWEsMkJBQTJCLFdBQVcsU0FBUyxFQUFFLE9BQU8sK0NBQStDLDRCQUE0QixzQ0FBc0MsaUJBQWlCLFNBQVMsbU1BQW1NLHdCQUF3QixtQkFBbUIsa0JBQWtCLG1CQUFtQixTQUFTLHdCQUF3QixtQkFBbUIsa0JBQWtCLG1CQUFtQixTQUFTLDJCQUEyQixnR0FBZ0csRUFBRSx5Q0FBeUMscUZBQXFGLGlJQUFpSSxtQkFBbUIsV0FBVyxrREFBa0QsNEdBQTRHLFdBQVcsMENBQTBDLHlHQUF5RyxXQUFXLHNCQUFzQix5REFBeUQsNkRBQTZELHdDQUF3QyxhQUFhLHlDQUF5QyxnRUFBZ0UsMkNBQTJDLGFBQWEsd0NBQXdDLDJEQUEyRCx3Q0FBd0Msc0ZBQXNGLDBEQUEwRCxFQUFFLGFBQWEsV0FBVyxPQUFPLDREQUE0RCwrRUFBK0UsZ0VBQWdFLDJDQUEyQyw0REFBNEQseUNBQXlDLGVBQWUsT0FBTyxnRUFBZ0UsMkNBQTJDLCtDQUErQyxpRUFBaUUsOENBQThDLGlCQUFpQiw4RkFBOEYsZ0VBQWdFLEVBQUUsZUFBZSxhQUFhLHNDQUFzQyxnRkFBZ0YsK0RBQStELDBDQUEwQywrREFBK0QsNENBQTRDLDRGQUE0RixnRUFBZ0UsRUFBRSxlQUFlLGFBQWEsV0FBVyxTQUFTLEVBQUUscUJBQXFCLE9BQU8sK0NBQStDLHdCQUF3Qiw2QkFBNkIsa0VBQWtFLDJEQUEyRCw0REFBNEQsdUNBQXVDLHlDQUF5QyxrREFBa0QsbURBQW1ELEVBQUUsU0FBUyxFQUFFLGdFQUFnRSwyREFBMkQsb0ZBQW9GLHFDQUFxQyxtQ0FBbUMsd0NBQXdDLGdEQUFnRCxpREFBaUQsRUFBRSxTQUFTLEVBQUUseUNBQXlDLCtCQUErQixxQkFBcUIsT0FBTyxLQUFLLEVBQUUsa1RBQWtULDZFQUE2RSw4REFBOEQsbURBQW1ELG9CQUFvQiwrRkFBK0Ysb0pBQW9KLG9DQUFvQyxnRUFBZ0Usb0JBQW9CLCtIQUErSCw2QkFBNkIsMkJBQTJCLHNDQUFzQyx5QkFBeUIsU0FBUyxPQUFPLDRDQUE0Qyx3QkFBd0IscUpBQXFKLGdDQUFnQyx3Q0FBd0MsZ0NBQWdDLG1DQUFtQyxXQUFXLFNBQVMsRUFBRSxnRUFBZ0Usd0RBQXdELDJXQUEyVyw0QkFBNEIsdUJBQXVCLHNFQUFzRSx5QkFBeUIseUNBQXlDLG9EQUFvRCx3QkFBd0Isd0ZBQXdGLCtCQUErQixvREFBb0Qsb0RBQW9ELHlMQUF5TCxnQ0FBZ0MsV0FBVyxTQUFTLEVBQUUsdUNBQXVDLHVDQUF1QyxPQUFPLHdDQUF3Qyx3QkFBd0Isa0RBQWtELHVIQUF1SCxFQUFFLHFEQUFxRCw2REFBNkQsK0NBQStDLHdFQUF3RSwwRUFBMEUsbUNBQW1DLGdLQUFnSyx3RUFBd0UsV0FBVyw2Q0FBNkMsNERBQTRELHdKQUF3SiwrQ0FBK0MseUNBQXlDLEVBQUUsbUNBQW1DLDBDQUEwQyxlQUFlLGFBQWEsMkNBQTJDLG9HQUFvRyxXQUFXLFNBQVMscUJBQXFCLG9IQUFvSCxrR0FBa0csc0hBQXNILHVCQUF1QixVQUFVLHlIQUF5SCx1QkFBdUIsVUFBVSxPQUFPLG9DQUFvQyw0QkFBNEIseUVBQXlFLG9DQUFvQywrQkFBK0IsU0FBUyxPQUFPLDhDQUE4QywwQkFBMEIscUVBQXFFLGdDQUFnQyxpQkFBaUIsU0FBUyxzQ0FBc0Msa0RBQWtELHNDQUFzQyxpRkFBaUYsdUNBQXVDLGtHQUFrRywyREFBMkQsaUdBQWlHLE9BQU8sbUNBQW1DLG9DQUFvQyxpQkFBaUIsU0FBUywwR0FBMEcsOEJBQThCLFNBQVMsT0FBTyxtSkFBbUosaUVBQWlFLFNBQVMsNkJBQTZCLDZCQUE2Qiw2QkFBNkIsMkJBQTJCLHVEQUF1RCx5Q0FBeUMsT0FBTyx3Q0FBd0MseUNBQXlDLGtDQUFrQywwQkFBMEIsT0FBTyxxQ0FBcUMsMkJBQTJCLGlCQUFpQixTQUFTLDhCQUE4Qiw2QkFBNkIsNEJBQTRCLG1DQUFtQywwQ0FBMEMsT0FBTyxrQ0FBa0MsMkJBQTJCLE9BQU8sMENBQTBDLHlCQUF5QixPQUFPLHFEQUFxRCwyREFBMkQsOENBQThDLGtEQUFrRCx5QkFBeUIsMk1BQTJNLGVBQWUsNENBQTRDLFdBQVcsMkNBQTJDLFNBQVMsRUFBRSxPQUFPLDREQUE0RCw2RUFBNkUsT0FBTyxvREFBb0QsNkJBQTZCLDhCQUE4Qiw2Q0FBNkMsU0FBUyx3Q0FBd0MsaUNBQWlDLE9BQU8sb0RBQW9ELG9CQUFvQiw4QkFBOEIsU0FBUyxPQUFPLCtCQUErQixJQUFJLFNBQVMsT0FBTyxnREFBZ0QseUVBQXlFLDRCQUE0QixvREFBb0QsU0FBUyxPQUFPLGtFQUFrRSxpREFBaUQsU0FBUyxrRUFBa0UsMEZBQTBGLFNBQVMsT0FBTyx5REFBeUQsU0FBUyw0QkFBNEIsK0NBQStDLFNBQVMsT0FBTyxzREFBc0QsZ0VBQWdFLE9BQU8seUNBQXlDLHdEQUF3RCxPQUFPLGdEQUFnRCxzQkFBc0IsNEJBQTRCLGlCQUFpQixTQUFTLG9DQUFvQyw0Q0FBNEMsc0NBQXNDLHlDQUF5Qyx5QkFBeUIsT0FBTyw4QkFBOEIsU0FBUyxnTEFBZ0wsT0FBTyx3QkFBd0IsOENBQThDLDZCQUE2QixtQkFBbUIsV0FBVyxnR0FBZ0csOEJBQThCLFdBQVcsU0FBUyxPQUFPLHVCQUF1Qix5SUFBeUksd0JBQXdCLHNDQUFzQyw4Q0FBOEMseUNBQXlDLG1EQUFtRCxhQUFhLDZCQUE2QixPQUFPLDBEQUEwRCxXQUFXLFNBQVMsdUNBQXVDLCtCQUErQixnQ0FBZ0MsU0FBUywyQ0FBMkMsb0NBQW9DLG9DQUFvQyx1R0FBdUcscUNBQXFDLG9CQUFvQixzRUFBc0UsK0NBQStDLGVBQWUsc0JBQXNCLG9FQUFvRSxvQ0FBb0MsZUFBZSxPQUFPLDRDQUE0QyxlQUFlLHNCQUFzQixzRUFBc0Usb0NBQW9DLGVBQWUsT0FBTyw0Q0FBNEMsZUFBZSxzQkFBc0Isc0VBQXNFLCtDQUErQyxlQUFlLE9BQU8sb0NBQW9DLGVBQWUsc0JBQXNCLCtFQUErRSxzQkFBc0IsZ0ZBQWdGLHNCQUFzQixzSEFBc0gsc0JBQXNCLHNIQUFzSCxzQkFBc0IsNkRBQTZELHFDQUFxQyxXQUFXLGlDQUFpQyxtQ0FBbUMsV0FBVyxTQUFTLE9BQU8sK0RBQStELHNEQUFzRCxzREFBc0QsaUVBQWlFLFNBQVMsT0FBTywrQ0FBK0MscURBQXFELHFGQUFxRixxREFBcUQsOEJBQThCLDRDQUE0Qyw2QkFBNkIsRUFBRSx3Q0FBd0MsNENBQTRDLGlDQUFpQyxFQUFFLFNBQVMsNEJBQTRCLE9BQU8sMENBQTBDLDREQUE0RCwwQkFBMEIsa0ZBQWtGLEVBQUUsc0RBQXNELE9BQU8sb0RBQW9ELGdDQUFnQywyR0FBMkcsU0FBUyxrQ0FBa0MscUNBQXFDLG1EQUFtRCxTQUFTLHFDQUFxQyx3REFBd0QsK0ZBQStGLGlEQUFpRCx3QkFBd0IsK0NBQStDLHlCQUF5QixXQUFXLE9BQU8sOENBQThDLFdBQVcsU0FBUyxrQ0FBa0MsK0JBQStCLFNBQVMsT0FBTyx3Q0FBd0MsNENBQTRDLHdCQUF3Qix3R0FBd0csU0FBUyx3Q0FBd0Msd0RBQXdELFNBQVMsZ0NBQWdDLDBDQUEwQyxTQUFTLHlCQUF5QixPQUFPLDRDQUE0QyxrSkFBa0osdUVBQXVFLHNEQUFzRCxPQUFPLGdEQUFnRCx1Q0FBdUMsdUJBQXVCLG1EQUFtRCw4QkFBOEIsU0FBUyx3Q0FBd0MsT0FBTyw0Q0FBNEMsd09BQXdPLE9BQU8sd0RBQXdELGdCQUFnQiw2REFBNkQsT0FBTyx1REFBdUQsc0JBQXNCLDZDQUE2QyxvRkFBb0YscUJBQXFCLHNRQUFzUSxFQUFFLFNBQVMsRUFBRSwwQkFBMEIsT0FBTyxzQ0FBc0MsK0JBQStCLDZCQUE2Qiw0QkFBNEIsc0NBQXNDLG1EQUFtRCxPQUFPLEtBQUssRUFBRSwrU0FBK1MsNkVBQTZFLG9TQUFvUyxzS0FBc0ssaUNBQWlDLG1DQUFtQyxnQ0FBZ0MsaUNBQWlDLG9DQUFvQyw0QkFBNEIsa0NBQWtDLG1KQUFtSiwwQkFBMEIsK0RBQStELG1DQUFtQyxPQUFPLHNDQUFzQyw0QkFBNEIsZ0NBQWdDLDhCQUE4QiwrQkFBK0IsT0FBTyxrREFBa0Qsa1VBQWtVLG1FQUFtRSxxREFBcUQsc0RBQXNELGtFQUFrRSxTQUFTLDBDQUEwQyxpQkFBaUIsT0FBTywrQkFBK0IsU0FBUywyRkFBMkYseUNBQXlDLHdDQUF3QyxzREFBc0QsU0FBUyxFQUFFLE9BQU8sOENBQThDLDhEQUE4RCw4QkFBOEIsdUNBQXVDLGtDQUFrQyxvRUFBb0UsYUFBYSxpRUFBaUUsc0VBQXNFLGFBQWEsc0NBQXNDLHVEQUF1RCxhQUFhLFdBQVcsb0RBQW9ELG1FQUFtRSw2T0FBNk8sV0FBVyxPQUFPLGdKQUFnSix3RUFBd0UsRUFBRSxXQUFXLG1KQUFtSixTQUFTLE9BQU8sMkJBQTJCLGdDQUFnQyxXQUFXLDhCQUE4QixTQUFTLE9BQU8sOENBQThDLGdDQUFnQyxxREFBcUQsd0NBQXdDLHdDQUF3QyxPQUFPLHNDQUFzQyw4QkFBOEIsMkJBQTJCLDhCQUE4QixTQUFTLHVLQUF1SywrQkFBK0IsT0FBTyxxREFBcUQsb09BQW9PLDJCQUEyQix1QkFBdUIsU0FBUyw4QkFBOEIsaUdBQWlHLG1EQUFtRCxvQkFBb0IsMkRBQTJELHVEQUF1RCwyREFBMkQsd0NBQXdDLGtFQUFrRSxxSUFBcUksb0NBQW9DLG9DQUFvQyxzQkFBc0IsV0FBVyxTQUFTLEVBQUUsNENBQTRDLGtDQUFrQyx1QkFBdUIsU0FBUyxvQ0FBb0Msa0NBQWtDLDREQUE0RCx3Q0FBd0MseUZBQXlGLCtDQUErQywyQ0FBMkMsSUFBSSx5VUFBeVUsMkRBQTJELCtDQUErQyxTQUFTLGtDQUFrQyxvQkFBb0IsT0FBTyw0Q0FBNEMsb0JBQW9CLE9BQU8sK0NBQStDLHdCQUF3QiwwREFBMEQsNERBQTRELDJEQUEyRCx1QkFBdUIsT0FBTywrQ0FBK0Msc0RBQXNELG1DQUFtQywrQ0FBK0MsaURBQWlELG1DQUFtQyxpQ0FBaUMsaUNBQWlDLHFCQUFxQixPQUFPLDBEQUEwRCxxR0FBcUcsT0FBTyxvRUFBb0UseUVBQXlFLG9EQUFvRCw4Q0FBOEMsK0dBQStHLFNBQVMsT0FBTywrQ0FBK0MsNkdBQTZHLFNBQVMsaURBQWlELGlDQUFpQywyQkFBMkIsU0FBUyxpQ0FBaUMsMkJBQTJCLFNBQVMsa0RBQWtELDBDQUEwQyxTQUFTLDJEQUEyRCxrRUFBa0UsZ0RBQWdELE9BQU8sOENBQThDLHNCQUFzQiw2RUFBNkUsa0VBQWtFLDRDQUE0Qyx3Q0FBd0MsU0FBUyx5REFBeUQsT0FBTyxzREFBc0QseUNBQXlDLGtFQUFrRSxnREFBZ0QsNEpBQTRKLDhCQUE4QixXQUFXLGdEQUFnRCxzQ0FBc0Msc0NBQXNDLCtIQUErSCxrSEFBa0gsRUFBRSxrREFBa0Qsc0NBQXNDLHlDQUF5QyxhQUFhLFdBQVcsU0FBUyxPQUFPLHdDQUF3Qyx3SUFBd0ksa0ZBQWtGLEVBQUUsc0NBQXNDLGlDQUFpQyxhQUFhLFdBQVcsU0FBUyxPQUFPLDRDQUE0QyxzQkFBc0IsNkVBQTZFLGtFQUFrRSw0Q0FBNEMsd0NBQXdDLFNBQVMsaURBQWlELE9BQU8sZ0RBQWdELHVEQUF1RCx3QkFBd0IsbUZBQW1GLG9FQUFvRSw4Q0FBOEMsMENBQTBDLFdBQVcscUhBQXFILHFEQUFxRCxTQUFTLE9BQU8sd0NBQXdDLCtCQUErQiw4REFBOEQsaUNBQWlDLGtDQUFrQyxtQkFBbUIsU0FBUywrQkFBK0IsT0FBTyxpREFBaUQsK0JBQStCLHFDQUFxQyxzRUFBc0UsaUNBQWlDLHNDQUFzQyxtQkFBbUIsU0FBUyxpQ0FBaUMsd0NBQXdDLHVDQUF1QyxxQ0FBcUMseUJBQXlCLGlCQUFpQixVQUFVLDJEQUEyRCxzQ0FBc0MsYUFBYSxtQ0FBbUMsV0FBVyxPQUFPLG9FQUFvRSx5Q0FBeUMsYUFBYSxPQUFPLGtDQUFrQyxhQUFhLFdBQVcsU0FBUyxPQUFPLGdDQUFnQyxTQUFTLE9BQU8sb0RBQW9ELHlDQUF5QyxpRUFBaUUsa0NBQWtDLGlEQUFpRCx1Q0FBdUMsV0FBVyw4QkFBOEIsOEVBQThFLHVDQUF1QyxXQUFXLFNBQVMsK0NBQStDLGtEQUFrRCxTQUFTLHFDQUFxQyxtRUFBbUUsU0FBUyxrQ0FBa0Msd0JBQXdCLHFFQUFxRSxnSUFBZ0ksbUNBQW1DLHdJQUF3SSxrQkFBa0IsK0RBQStELG1DQUFtQyxvQ0FBb0MsdUNBQXVDLGtCQUFrQixnRUFBZ0UsbUNBQW1DLHlCQUF5QixnQkFBZ0IsVUFBVSxvQ0FBb0MsYUFBYSx1Q0FBdUMsa0JBQWtCLDRHQUE0RyxzQ0FBc0MsbUNBQW1DLHVDQUF1QyxrQkFBa0IsK0RBQStELDhCQUE4Qix1Q0FBdUMsa0JBQWtCLFNBQVMsT0FBTyxzSUFBc0kscUNBQXFDLHdDQUF3QyxtQkFBbUIsT0FBTywrT0FBK08seUJBQXlCLGlDQUFpQywyQ0FBMkMsMENBQTBDLHFCQUFxQixTQUFTLDhEQUE4RCxrS0FBa0ssdUJBQXVCLGlCQUFpQixVQUFVLG9EQUFvRCxXQUFXLHdCQUF3QixTQUFTLE9BQU8sb0JBQW9CLFNBQVMsT0FBTyxzSkFBc0osc0NBQXNDLGtDQUFrQyxTQUFTLHdDQUF3QyxrQ0FBa0MsU0FBUyxzS0FBc0ssaURBQWlELHNEQUFzRCxTQUFTLHlMQUF5TCxPQUFPLHNEQUFzRCxvTUFBb00sK0JBQStCLDhEQUE4RCxPQUFPLDBDQUEwQyw2REFBNkQsMENBQTBDLCtFQUErRSxTQUFTLDJCQUEyQixPQUFPLGlEQUFpRCwwRUFBMEUsNkRBQTZELE9BQU8sd0NBQXdDLGdDQUFnQyxPQUFPLHdDQUF3Qyx3QkFBd0IsT0FBTyxnREFBZ0QsNlJBQTZSLGtFQUFrRSwwQ0FBMEMsMkdBQTJHLG1HQUFtRyxpRkFBaUYsZ0RBQWdELHdEQUF3RCw4QkFBOEIsMEVBQTBFLCtEQUErRCxhQUFhLGlCQUFpQixnQ0FBZ0MsK0RBQStELGlGQUFpRixHQUFHLDJGQUEyRixFQUFFLGlCQUFpQixlQUFlLE9BQU8sOEJBQThCLDBFQUEwRSxpRUFBaUUsYUFBYSxpQkFBaUIsZ0NBQWdDLCtEQUErRCxrRkFBa0YsR0FBRywyRkFBMkYsRUFBRSxpQkFBaUIsZUFBZSxhQUFhLDBDQUEwQyxXQUFXLEVBQUUsU0FBUyxPQUFPLCtCQUErQixzQ0FBc0Msc0NBQXNDLG9HQUFvRyxpR0FBaUcsbUZBQW1GLDRFQUE0RSxvRUFBb0Usb0RBQW9ELGFBQWEsV0FBVyw0RUFBNEUseURBQXlELDBEQUEwRCxHQUFHLHlFQUF5RSxFQUFFLFdBQVcsMEVBQTBFLG9FQUFvRSxxREFBcUQsYUFBYSxXQUFXLDBFQUEwRSx5REFBeUQsMkRBQTJELEdBQUcseUVBQXlFLEVBQUUsV0FBVyxTQUFTLE9BQU8sdUJBQXVCLDBDQUEwQywwSkFBMEosb0NBQW9DLG1VQUFtVSx3Q0FBd0Msd0NBQXdDLDhEQUE4RCxvREFBb0QsMENBQTBDLHlCQUF5QixpQkFBaUIsZUFBZSxzQkFBc0IsV0FBVyxxQ0FBcUMsb0VBQW9FLGlEQUFpRCxXQUFXLE9BQU8sMkNBQTJDLFdBQVcsb0NBQW9DLDJFQUEyRSxvQkFBb0IsNEVBQTRFLG9CQUFvQixvSkFBb0osb0JBQW9CLHNKQUFzSixvQkFBb0IsdUhBQXVILHVCQUF1QixlQUFlLDZEQUE2RCxvQkFBb0Isd0hBQXdILHVCQUF1QixlQUFlLDZEQUE2RCxvQkFBb0IsV0FBVyw4Q0FBOEMsU0FBUyx1Q0FBdUMsdUVBQXVFLG1DQUFtQyxxQ0FBcUMsdUNBQXVDLHlDQUF5QywrREFBK0QsV0FBVyxTQUFTLE9BQU8sS0FBSyxFQUFFLHVUQUF1VCwrRkFBK0YsODBCQUE4MEIsOERBQThELHNEQUFzRCxPQUFPLGdEQUFnRCx5R0FBeUcsT0FBTyxvQ0FBb0MsaUNBQWlDLCtDQUErQyx5Q0FBeUMsb0ZBQW9GLHNFQUFzRSxxQ0FBcUMsa0RBQWtELE9BQU8sb0RBQW9ELGdDQUFnQyxtQ0FBbUMscUNBQXFDLFNBQVMsT0FBTyw0REFBNEQsdUZBQXVGLHdDQUF3QyxxSUFBcUksU0FBUyxFQUFFLE9BQU8sc0NBQXNDLHlJQUF5SSwrQkFBK0IsNkNBQTZDLFFBQVEsT0FBTyxxRUFBcUUsU0FBUyxzQkFBc0IsT0FBTyxxRUFBcUUsdUZBQXVGLCtCQUErQix1QkFBdUIsU0FBUywwRUFBMEUsdUJBQXVCLFNBQVMscUZBQXFGLDhJQUE4SSxtRUFBbUUsa0NBQWtDLHlCQUF5QixXQUFXLFNBQVMsRUFBRSwyRUFBMkUsd0NBQXdDLFNBQVMsNkJBQTZCLHVCQUF1QixTQUFTLHVEQUF1RCxzRkFBc0Ysd0NBQXdDLGlDQUFpQyxhQUFhLFdBQVcsRUFBRSwrQkFBK0IseUJBQXlCLFdBQVcsU0FBUyx5Q0FBeUMsMENBQTBDLHNCQUFzQixPQUFPLCtFQUErRSw0REFBNEQscUNBQXFDLHdJQUF3SSx5RkFBeUYsaUVBQWlFLHFPQUFxTywyRkFBMkYsOEdBQThHLHVCQUF1QixnSEFBZ0gsK0JBQStCLGtCQUFrQix5S0FBeUssOE5BQThOLEVBQUUsd05BQXdOLHlEQUF5RCxpR0FBaUcseUNBQXlDLHlDQUF5Qyw4SUFBOEksOERBQThELG1HQUFtRyw4TEFBOEwsa0NBQWtDLFNBQVMsK0RBQStELDRFQUE0RSxpQ0FBaUMsU0FBUyxrREFBa0Qsd0VBQXdFLG9FQUFvRSx5Q0FBeUMsK0NBQStDLHVDQUF1QyxFQUFFLDJCQUEyQixTQUFTLDBCQUEwQix3RUFBd0UsK0RBQStELFdBQVcsb0RBQW9ELFNBQVMseUJBQXlCLHNFQUFzRSw2REFBNkQsV0FBVyxrREFBa0QsU0FBUyw2SEFBNkgsMkRBQTJELFNBQVMsNkVBQTZFLDZFQUE2RSx5Q0FBeUMsU0FBUyxrRkFBa0YsOENBQThDLFFBQVEsT0FBTyxpRkFBaUYsV0FBVyxTQUFTLCtEQUErRCx3Q0FBd0MsU0FBUyxtREFBbUQscURBQXFELFNBQVMsK0JBQStCLHFEQUFxRCxpQ0FBaUMsK0hBQStILE9BQU8sK0NBQStDLDBJQUEwSSx1RkFBdUYsaUVBQWlFLHNDQUFzQyxrREFBa0QsU0FBUyxxREFBcUQsdUdBQXVHLGtIQUFrSCx5R0FBeUcsYUFBYSx3RUFBd0UseUdBQXlHLGFBQWEsb0hBQW9ILDJHQUEyRyxhQUFhLHlFQUF5RSwyR0FBMkcsYUFBYSxXQUFXLE9BQU8sZ0ZBQWdGLDRGQUE0RixhQUFhLG1HQUFtRyw0RkFBNEYsYUFBYSxtRkFBbUYsOEZBQThGLGFBQWEsbUdBQW1HLDhGQUE4RixhQUFhLFdBQVcsMkVBQTJFLHVEQUF1RCxXQUFXLFNBQVMsaUlBQWlJLDRGQUE0RixrRUFBa0UsU0FBUyxrRUFBa0UsZ0VBQWdFLFNBQVMsdURBQXVELFFBQVEsT0FBTyx3R0FBd0cscUNBQXFDLDJEQUEyRCxnQ0FBZ0MscUJBQXFCLFdBQVcsc2VBQXNlLHFCQUFxQixXQUFXLCtiQUErYixvRUFBb0UsOEZBQThGLDJDQUEyQyxhQUFhLE9BQU8sb0JBQW9CLGFBQWEsK0RBQStELG9CQUFvQixXQUFXLFNBQVMsdUVBQXVFLGdFQUFnRSwyQ0FBMkMsU0FBUyw0RUFBNEUsa0RBQWtELHFCQUFxQixPQUFPLDhEQUE4RCxxQkFBcUIsaUJBQWlCLFNBQVMsZ0lBQWdJLDJDQUEyQyxTQUFTLG9DQUFvQyw0SUFBNEksMENBQTBDLDZLQUE2SyxXQUFXLDBDQUEwQyx3S0FBd0ssV0FBVyxrQ0FBa0MsbUdBQW1HLCtCQUErQixXQUFXLEVBQUUsU0FBUyxPQUFPLDRDQUE0QyxTQUFTLHVCQUF1QixPQUFPLGtDQUFrQyw0QkFBNEIseUJBQXlCLG1DQUFtQyxFQUFFLHVEQUF1RCxzRkFBc0YsV0FBVyxPQUFPLG9DQUFvQyxXQUFXLCtGQUErRixRQUFRLE9BQU8sa0ZBQWtGLDJEQUEyRCw2RUFBNkUsMkRBQTJELGFBQWEsV0FBVyxTQUFTLGlDQUFpQyw0Q0FBNEMsNklBQTZJLDRFQUE0RSxXQUFXLG1HQUFtRyxpQ0FBaUMsV0FBVyw0QkFBNEIsMkhBQTJILEVBQUUsd0NBQXdDLDZEQUE2RCxXQUFXLE9BQU8saUVBQWlFLFdBQVcsU0FBUyxzQkFBc0IsT0FBTyx5Q0FBeUMsa0ZBQWtGLHNCQUFzQixtQ0FBbUMscUhBQXFILHNCQUFzQixxR0FBcUcsV0FBVyxTQUFTLEVBQUUscUNBQXFDLGtDQUFrQyxTQUFTLGlDQUFpQyxPQUFPLHFDQUFxQyxrRkFBa0Ysc0JBQXNCLGdDQUFnQywwRUFBMEUsU0FBUyxFQUFFLG1CQUFtQixPQUFPLGtIQUFrSCxncEJBQWdwQiw0UEFBNFAsK0JBQStCLFNBQVMsT0FBTyx5UUFBeVEscUJBQXFCLE9BQU8sc0VBQXNFLDJmQUEyZiwrQkFBK0IsdUJBQXVCLFNBQVMsb01BQW9NLE9BQU8sa0VBQWtFLG9aQUFvWixxREFBcUQsOEhBQThILFNBQVMsT0FBTyxnSkFBZ0osU0FBUyxPQUFPLHdFQUF3RSxvRUFBb0UsOERBQThELE9BQU8sNEVBQTRFLHNFQUFzRSxpRUFBaUUsT0FBTyx5Q0FBeUMsa0NBQWtDLHFDQUFxQyxrQ0FBa0Msb0JBQW9CLE9BQU8sOENBQThDLG1DQUFtQyx3R0FBd0csT0FBTyxpRUFBaUUsMkpBQTJKLHlDQUF5QywwQ0FBMEMsUUFBUSxPQUFPLHNEQUFzRCxzQ0FBc0MsUUFBUSxPQUFPLHlEQUF5RCxzRUFBc0Usb05BQW9OLGVBQWUsYUFBYSxXQUFXLFNBQVMsd0dBQXdHLHlFQUF5RSwrR0FBK0csK0JBQStCLDJCQUEyQixTQUFTLHNDQUFzQyxRQUFRLE9BQU8sdUNBQXVDLFNBQVMsMEJBQTBCLE9BQU8sc0VBQXNFLG9GQUFvRix5REFBeUQseUJBQXlCLGlCQUFpQixPQUFPLDJDQUEyQywyQkFBMkIsYUFBYSxXQUFXLHdCQUF3QixTQUFTLEVBQUUsT0FBTyxxREFBcUQsd0JBQXdCLGlDQUFpQyxpU0FBaVMseUNBQXlDLDhGQUE4RiwwQ0FBMEMsc0hBQXNILFFBQVEsT0FBTyxzREFBc0Qsc0NBQXNDLFFBQVEsT0FBTyx5REFBeUQsc0VBQXNFLGtIQUFrSCx5REFBeUQsZ0RBQWdELDJDQUEyQyxlQUFlLGFBQWEsV0FBVyxTQUFTLHNDQUFzQyxRQUFRLE9BQU8scUNBQXFDLG1DQUFtQyx3REFBd0QsbUJBQW1CLE9BQU8sa0NBQWtDLCtEQUErRCxzRUFBc0Usa0tBQWtLLEVBQUUsV0FBVyxTQUFTLE9BQU8sMERBQTBELDJMQUEyTCxnTEFBZ0wsdURBQXVELFNBQVMsNEJBQTRCLHlDQUF5QyxRQUFRLE9BQU8sK0JBQStCLGtOQUFrTixxQkFBcUIsV0FBVyx3R0FBd0csd0JBQXdCLHdDQUF3QywwQ0FBMEMsV0FBVywyQkFBMkIsNkJBQTZCLDJCQUEyQixTQUFTLDZFQUE2RSwyREFBMkQsU0FBUyxPQUFPLDhDQUE4QyxRQUFRLE9BQU8sb0RBQW9ELDREQUE0RCwwREFBMEQsOEZBQThGLGdHQUFnRyxXQUFXLFNBQVMsc0JBQXNCLE9BQU8sOERBQThELDRCQUE0QixtREFBbUQsdUVBQXVFLG9DQUFvQywyQkFBMkIseUNBQXlDLDBRQUEwUSw2Q0FBNkMsZ0lBQWdJLGVBQWUsZ0NBQWdDLHFFQUFxRSxlQUFlLGlDQUFpQyxzRUFBc0UsZUFBZSxpQ0FBaUMsd0RBQXdELGVBQWUsK0JBQStCLGFBQWEsb0RBQW9ELG9TQUFvUyx1QkFBdUIsZUFBZSwyTEFBMkwsZ0xBQWdMLGVBQWUsaUNBQWlDLDhLQUE4SyxlQUFlLGFBQWEsWUFBWSxTQUFTLHNIQUFzSCw2RkFBNkYscUlBQXFJLE9BQU8sZ0ZBQWdGLHdCQUF3Qiw4Q0FBOEMsd0JBQXdCLGdHQUFnRyxTQUFTLEVBQUUsT0FBTywrREFBK0QscVJBQXFSLG1HQUFtRyxRQUFRLE9BQU8sNEpBQTRKLHFCQUFxQixXQUFXLDBFQUEwRSxtTkFBbU4sdUJBQXVCLGFBQWEsc0RBQXNELCtCQUErQixXQUFXLE9BQU8sdUlBQXVJLDhFQUE4RSwyREFBMkQsYUFBYSxXQUFXLFNBQVMscUZBQXFGLGlCQUFpQixTQUFTLDZHQUE2RyxxRUFBcUUsMEZBQTBGLHNFQUFzRSxXQUFXLFNBQVMsT0FBTywySUFBMkksdUNBQXVDLHVGQUF1RixzREFBc0QsMkRBQTJELHNEQUFzRCwyQ0FBMkMsUUFBUSxPQUFPLGlHQUFpRyx1QkFBdUIsYUFBYSxrRUFBa0UsdUJBQXVCLGFBQWEsNkRBQTZELCtCQUErQix3RUFBd0UsZ0NBQWdDLGFBQWEsdURBQXVELGlEQUFpRCxvREFBb0QsOERBQThELGFBQWEsV0FBVywwR0FBMEcsbUJBQW1CLFdBQVcsNEVBQTRFLDZEQUE2RCx3RkFBd0YsOERBQThELGFBQWEscUJBQXFCLFdBQVcsNEtBQTRLLDZEQUE2RCw0RkFBNEYsb0VBQW9FLDhHQUE4RywwRkFBMEYsb0VBQW9FLFNBQVMsT0FBTyxxREFBcUQsZ05BQWdOLDJHQUEyRywrR0FBK0csU0FBUyxrREFBa0QsNkJBQTZCLDRRQUE0USxTQUFTLDREQUE0RCxpREFBaUQsU0FBUyw2REFBNkQsbURBQW1ELFNBQVMsd0JBQXdCLE9BQU8sdUVBQXVFLHdDQUF3QyxpQ0FBaUMsU0FBUywrQkFBK0IsaUJBQWlCLG1FQUFtRSxTQUFTLGdDQUFnQyxnRUFBZ0UsU0FBUyxpQ0FBaUMsZ0dBQWdHLFNBQVMsK0JBQStCLDZEQUE2RCxTQUFTLGtDQUFrQyxnR0FBZ0csU0FBUyxPQUFPLHNEQUFzRCw0R0FBNEcsNENBQTRDLDhuQkFBOG5CLG9EQUFvRCxrREFBa0QsU0FBUyxxU0FBcVMsZ0JBQWdCLGtEQUFrRCxTQUFTLGtCQUFrQiwwTEFBMEwsT0FBTywwREFBMEQsZ0RBQWdELDhDQUE4QyxrQkFBa0IsNk5BQTZOLFNBQVMsT0FBTyxrQkFBa0Isa0RBQWtELFNBQVMsT0FBTyxnREFBZ0Qsd0JBQXdCLHVKQUF1SixPQUFPLG9FQUFvRSxrQ0FBa0MsK0ZBQStGLE9BQU8sb0RBQW9ELDRFQUE0RSw2Q0FBNkMsb0RBQW9ELFNBQVMsK0VBQStFLG9jQUFvYyxTQUFTLGtFQUFrRSxtQ0FBbUMseUNBQXlDLHdEQUF3RCwwdkJBQTB2QixTQUFTLE9BQU8sZ0VBQWdFLG1CQUFtQiw4QkFBOEIsU0FBUywrVEFBK1QsZ0JBQWdCLHEwQkFBcTBCLE9BQU8sNkRBQTZELDZZQUE2WSxnY0FBZ2MsMkRBQTJELFNBQVMsaUtBQWlLLG1HQUFtRyw2RUFBNkUsbUVBQW1FLGFBQWEsOEVBQThFLGtFQUFrRSxhQUFhLCtFQUErRSxtRUFBbUUsYUFBYSw4RUFBOEUsa0VBQWtFLGFBQWEsV0FBVyx5QkFBeUIsd0dBQXdHLHFQQUFxUCx5R0FBeUcsK1BBQStQLFdBQVcsU0FBUyxrQkFBa0IscTdCQUFxN0IsT0FBTyxrRUFBa0UsNEtBQTRLLDZjQUE2YyxtQ0FBbUMsbUNBQW1DLHlDQUF5QyxnREFBZ0QsbUVBQW1FLFNBQVMsRUFBRSxPQUFPLHNEQUFzRCwrQkFBK0IsMk1BQTJNLCtQQUErUCxvREFBb0QsU0FBUyxtQ0FBbUMsdURBQXVELHNDQUFzQyx1RkFBdUYsd0NBQXdDLGFBQWEsV0FBVyxzRkFBc0YsU0FBUyxPQUFPLGtDQUFrQyxTQUFTLG1EQUFtRCxpREFBaUQsOEVBQThFLFdBQVcsRUFBRSxTQUFTLHNNQUFzTSxpREFBaUQsNkRBQTZELFdBQVcsRUFBRSxtRUFBbUUsdUlBQXVJLCtCQUErQixtREFBbUQsK0RBQStELGFBQWEsRUFBRSwrQ0FBK0MsdUNBQXVDLG1FQUFtRSxnQkFBZ0IsYUFBYSxvQ0FBb0MsK0NBQStDLHVDQUF1QyxrRUFBa0UsZ0JBQWdCLGFBQWEsb0NBQW9DLFdBQVcsU0FBUyx3RkFBd0YsbUNBQW1DLHdFQUF3RSxZQUFZLFNBQVMsOENBQThDLFFBQVEsT0FBTywrQkFBK0IsdUZBQXVGLFdBQVcseURBQXlELGdGQUFnRix1REFBdUQsV0FBVyxTQUFTLHdFQUF3RSwwRUFBMEUseUNBQXlDLFNBQVMsb0NBQW9DLDREQUE0RCxTQUFTLG1DQUFtQyxtR0FBbUcsU0FBUyxnQ0FBZ0MsK0JBQStCLCtEQUErRCxTQUFTLG1DQUFtQywwS0FBMEssMENBQTBDLHVEQUF1RCxpQ0FBaUMsV0FBVywrQkFBK0IsU0FBUywrQkFBK0IscUJBQXFCLDRCQUE0QixPQUFPLGlEQUFpRCxXQUFXLDBGQUEwRixTQUFTLG1DQUFtQyx5Q0FBeUMsT0FBTyxzQ0FBc0MsMkVBQTJFLHdCQUF3QixTQUFTLE9BQU8seUNBQXlDLGlDQUFpQyxnQkFBZ0IsK1JBQStSLE9BQU8sS0FBSyxFQUFFLDhSQUE4UiwwQkFBMEIsMENBQTBDLGtDQUFrQywwQkFBMEIsZ0RBQWdELG9DQUFvQyxTQUFTLFFBQVEsS0FBSyw4Q0FBOEMsOEdBQThHLHNDQUFzQyx3RkFBd0YsZ05BQWdOLG9DQUFvQyx5R0FBeUcscURBQXFELHVEQUF1RCw2SkFBNkosbUdBQW1HLFNBQVMsdUJBQXVCLGlDQUFpQywwQkFBMEIsK1BBQStQLGlEQUFpRCxzREFBc0QsV0FBVyxTQUFTLEVBQUUsT0FBTyx3REFBd0Qsd0JBQXdCLG9DQUFvQyxtRUFBbUUsMkNBQTJDLHNEQUFzRCxvQ0FBb0MsV0FBVyxTQUFTLEVBQUUsdUJBQXVCLE9BQU8saUJBQWlCLDBDQUEwQywyREFBMkQsbUNBQW1DLFdBQVcsU0FBUywyREFBMkQsNkNBQTZDLFNBQVMscUNBQXFDLGdDQUFnQyxtQ0FBbUMsbUJBQW1CLFdBQVcseUJBQXlCLDRCQUE0Qix1REFBdUQsNkNBQTZDLFdBQVcsU0FBUyx3REFBd0QsdUJBQXVCLG1CQUFtQixXQUFXLHdEQUF3RCx5QkFBeUIsV0FBVyx3RUFBd0UsK0NBQStDLDBEQUEwRCxnQ0FBZ0MsZ0NBQWdDLGFBQWEsV0FBVyxPQUFPLGlDQUFpQyxTQUFTLHFGQUFxRix1QkFBdUIsNENBQTRDLDJiQUEyYixtQ0FBbUMsOEVBQThFLDhCQUE4QixtQ0FBbUMsdUNBQXVDLGtOQUFrTix5Q0FBeUMsZUFBZSxFQUFFLGFBQWEsV0FBVyx3RkFBd0YsZ0NBQWdDLHdRQUF3USxxQ0FBcUMsbUNBQW1DLGtDQUFrQyxXQUFXLEVBQUUsK0NBQStDLG1CQUFtQixXQUFXLG1HQUFtRyxTQUFTLHlJQUF5SSxtS0FBbUssbUJBQW1CLFdBQVcsK0NBQStDLHlCQUF5QixXQUFXLG1HQUFtRyxTQUFTLHdPQUF3TyxnQ0FBZ0MsNE1BQTRNLG9EQUFvRCxrSkFBa0osaU5BQWlOLCtDQUErQyxTQUFTLDJGQUEyRix5QkFBeUIsU0FBUyxPQUFPLDJDQUEyQyxzRUFBc0Usa0NBQWtDLG1FQUFtRSwwQkFBMEIsd0VBQXdFLDBCQUEwQixxRkFBcUYsMEJBQTBCLHdGQUF3RiwwQkFBMEIsU0FBUyx1QkFBdUIsT0FBTyxrREFBa0QsOEZBQThGLE9BQU8sNENBQTRDLG9KQUFvSix5SkFBeUoscUJBQXFCLE9BQU8sdUNBQXVDLDBFQUEwRSx1QkFBdUIsU0FBUyw4QkFBOEIsMkJBQTJCLFNBQVMsK0JBQStCLG9CQUFvQixPQUFPLG1EQUFtRCxxQkFBcUIsaUNBQWlDLDhDQUE4Qyx5Q0FBeUMsU0FBUyxLQUFLLHVEQUF1RCxPQUFPLDJDQUEyQyxzQ0FBc0MsOEJBQThCLDJCQUEyQixTQUFTLGtGQUFrRixnRUFBZ0UsK0JBQStCLGNBQWMsNkJBQTZCLDJCQUEyQixTQUFTLE9BQU8sMkNBQTJDLG1EQUFtRCw0QkFBNEIsNkhBQTZILFNBQVMsbUJBQW1CLE9BQU8sMENBQTBDLDZEQUE2RCwwQ0FBMEMsK0VBQStFLFNBQVMsMkJBQTJCLE9BQU8saURBQWlELDBFQUEwRSw2REFBNkQsT0FBTyxtREFBbUQseUVBQXlFLDZKQUE2SixnQ0FBZ0MsdUdBQXVHLDBGQUEwRixnSEFBZ0gsK0VBQStFLDZCQUE2QixTQUFTLDREQUE0RCw2QkFBNkIsU0FBUyx1QkFBdUIsT0FBTyxxQ0FBcUMsNkJBQTZCLGlCQUFpQixTQUFTLG1DQUFtQywyQ0FBMkMseUJBQXlCLDhCQUE4Qix5Q0FBeUMsT0FBTyxvREFBb0QsOERBQThELDBEQUEwRCxzQ0FBc0Msb0RBQW9ELGlCQUFpQixTQUFTLHVFQUF1RSw0Q0FBNEMsdUNBQXVDLFdBQVcsU0FBUyxrQ0FBa0Msd0dBQXdHLDJHQUEyRyxTQUFTLGtDQUFrQyxxQ0FBcUMsb0VBQW9FLG1EQUFtRCxnRUFBZ0UsU0FBUyxPQUFPLHlEQUF5RCw2QkFBNkIsT0FBTyxzQ0FBc0Msd0RBQXdELDJIQUEySCxTQUFTLHlEQUF5RCxPQUFPLHlDQUF5Qyw2QkFBNkIsc0JBQXNCLFNBQVMsa0pBQWtKLE9BQU8sc0NBQXNDLDJCQUEyQix1T0FBdU8sRUFBRSxPQUFPLG9DQUFvQyxpQ0FBaUMsa0RBQWtELHVCQUF1QixTQUFTLDhGQUE4RixPQUFPLG9HQUFvRyxtQkFBbUIsK0JBQStCLHNDQUFzQyxrQ0FBa0MsNEJBQTRCLGlEQUFpRCxhQUFhLDJDQUEyQyxXQUFXLFNBQVMsa0NBQWtDLDBCQUEwQixPQUFPLHNDQUFzQyw2TkFBNk4saURBQWlELE9BQU8sa0RBQWtELDRCQUE0QixPQUFPLDBDQUEwQyw0QkFBNEIsdURBQXVELHlCQUF5QixTQUFTLE9BQU8sb0RBQW9ELDhCQUE4QixPQUFPLDhDQUE4Qyw0QkFBNEIsd0RBQXdELHlCQUF5QixTQUFTLE9BQU8sa0RBQWtELHVEQUF1RCxPQUFPLHFEQUFxRCx5REFBeUQsT0FBTyx1Q0FBdUMsZ0NBQWdDLGlEQUFpRCxTQUFTLDJEQUEyRCxPQUFPLGtDQUFrQyw4QkFBOEIsT0FBTyxLQUFLLEVBQUUsMlJBQTJSLDJEQUEyRCwwUUFBMFEsOEJBQThCLDJCQUEyQixrQ0FBa0MscUNBQXFDLDZJQUE2SSx1REFBdUQsMkRBQTJELCtFQUErRSxzREFBc0QsV0FBVyxpQkFBaUIsaUJBQWlCLDBEQUEwRCxXQUFXLGlCQUFpQix1RUFBdUUsVUFBVSxPQUFPLHNDQUFzQywyREFBMkQsNkJBQTZCLCtJQUErSSw4QkFBOEIsaURBQWlELG9KQUFvSiw2SEFBNkgsdUNBQXVDLFdBQVcsV0FBVyxTQUFTLHFJQUFxSSx5REFBeUQsU0FBUyxPQUFPLDRCQUE0QixTQUFTLDBCQUEwQixtQ0FBbUMsb0NBQW9DLFNBQVMsT0FBTyxrREFBa0Qsa0pBQWtKLGdDQUFnQyxrRkFBa0YsOENBQThDLG9FQUFvRSwyQkFBMkIsNkJBQTZCLGVBQWUsYUFBYSxFQUFFLFdBQVcsaUZBQWlGLDRFQUE0RSxXQUFXLG9GQUFvRixrREFBa0QsV0FBVyxTQUFTLDZFQUE2RSx5REFBeUQsZ0NBQWdDLDZDQUE2QyxXQUFXLFNBQVMsOEhBQThILHFCQUFxQixTQUFTLHdCQUF3QixPQUFPLDREQUE0RCxnQkFBZ0IsbUhBQW1ILE9BQU8saURBQWlELG1LQUFtSywyQ0FBMkMsaUJBQWlCLFNBQVMsa0NBQWtDLCtGQUErRixrQkFBa0IsbUdBQW1HLDRCQUE0QixrQkFBa0Isc0ZBQXNGLGtCQUFrQixpRUFBaUUsa0JBQWtCLGtIQUFrSCwwQ0FBMEMsNENBQTRDLHFCQUFxQiwwSUFBMEksMENBQTBDLDJJQUEySSxxQkFBcUIsdUNBQXVDLFNBQVMsZ0dBQWdHLHNDQUFzQyx3RUFBd0UsMEhBQTBILHlVQUF5VSx3RUFBd0UscURBQXFELG1EQUFtRCxXQUFXLGNBQWMsU0FBUyxPQUFPLHFEQUFxRCx5Q0FBeUMsaUJBQWlCLFNBQVMsK0dBQStHLGlDQUFpQyw4QkFBOEIsU0FBUyxPQUFPLHFJQUFxSSxxRUFBcUUsNkVBQTZFLHdCQUF3QixTQUFTLHlFQUF5RSw0RUFBNEUsd0JBQXdCLFNBQVMsT0FBTyxpRUFBaUUsZ0RBQWdELGdDQUFnQyxxQ0FBcUMsc0JBQXNCLFdBQVcsNEJBQTRCLGlDQUFpQyxXQUFXLHlCQUF5QixTQUFTLHdFQUF3RSx1REFBdUQsU0FBUyx1QkFBdUIsT0FBTyxtRUFBbUUsdURBQXVELG9DQUFvQyxxQkFBcUIsT0FBTyxvREFBb0QsaUNBQWlDLDJHQUEyRyxtQkFBbUIsU0FBUyxxQ0FBcUMsa0dBQWtHLG1CQUFtQixTQUFTLGtDQUFrQyx3Q0FBd0MsbUVBQW1FLCtDQUErQywyRUFBMkUsOEJBQThCLFdBQVcsU0FBUyxrQ0FBa0MsbUNBQW1DLFNBQVMsd0NBQXdDLHdDQUF3QyxTQUFTLE9BQU8sNERBQTRELHVEQUF1RCxnQkFBZ0IsRUFBRSx5QkFBeUIsT0FBTyxvQ0FBb0MsOEZBQThGLGtOQUFrTixnQ0FBZ0MsU0FBUyxFQUFFLDhCQUE4QiwrRkFBK0YsaUNBQWlDLDRCQUE0QiwrQ0FBK0MsK0VBQStFLHlHQUF5RyxtQ0FBbUMsOEJBQThCLG9DQUFvQyxPQUFPLHNGQUFzRixXQUFXLGtEQUFrRCxPQUFPLHNHQUFzRyxTQUFTLDBCQUEwQixPQUFPLHNDQUFzQyxtREFBbUQsZ0RBQWdELDJEQUEyRCwyQ0FBMkMsNkdBQTZHLEVBQUUsd0VBQXdFLDRDQUE0QyxFQUFFLDZFQUE2RSxnREFBZ0QsU0FBUyxPQUFPLHlFQUF5RSxrSEFBa0gsRUFBRSwyREFBMkQsaURBQWlELEVBQUUsU0FBUyxPQUFPLDhDQUE4QyxxSUFBcUksd1NBQXdTLG1EQUFtRCxtQ0FBbUMsV0FBVyxTQUFTLHFhQUFxYSxtRUFBbUUsd0JBQXdCLFdBQVcsU0FBUyxFQUFFLGdIQUFnSCx1REFBdUQsRUFBRSxrREFBa0QsbUNBQW1DLFNBQVMscUNBQXFDLGdFQUFnRSxFQUFFLDBCQUEwQixnREFBZ0QsMk9BQTJPLHNEQUFzRCxtQ0FBbUMsNENBQTRDLHdFQUF3RSx5QkFBeUIsT0FBTyxpTEFBaUwsbUJBQW1CLHVDQUF1QyxnREFBZ0Qsa0NBQWtDLGlEQUFpRCxvRUFBb0UsYUFBYSxvREFBb0QsV0FBVywrQkFBK0IsaURBQWlELFdBQVcsdUNBQXVDLHNFQUFzRSxXQUFXLHNCQUFzQiwyRkFBMkYsRUFBRSxvREFBb0QsU0FBUyxFQUFFLGdIQUFnSCx3REFBd0QsNkNBQTZDLHFEQUFxRCxtREFBbUQsU0FBUyxPQUFPLHFIQUFxSCxrRUFBa0UsT0FBTyxnREFBZ0QsNElBQTRJLE9BQU8sMERBQTBELGtDQUFrQyxpQ0FBaUMsNkJBQTZCLFdBQVcsb0RBQW9ELDRCQUE0QixXQUFXLFNBQVMsK0NBQStDLG1CQUFtQixPQUFPLG1FQUFtRSxvRkFBb0YsV0FBVyxPQUFPLG1GQUFtRixXQUFXLFNBQVMsMkNBQTJDLE9BQU8sbURBQW1ELHdCQUF3QixzQkFBc0Isa0VBQWtFLGtEQUFrRCxXQUFXLEVBQUUsU0FBUyxrRUFBa0UsbUdBQW1HLHdDQUF3QyxtQ0FBbUMsV0FBVyxTQUFTLEVBQUUseUNBQXlDLCtCQUErQiwyQ0FBMkMsRUFBRSxpQ0FBaUMsNkNBQTZDLEVBQUUscUNBQXFDLHFDQUFxQyxPQUFPLG1FQUFtRSxpRUFBaUUseUNBQXlDLHNDQUFzQywwRUFBMEUsZ0VBQWdFLGlGQUFpRix3RUFBd0UscUJBQXFCLGFBQWEsa0RBQWtELFdBQVcsRUFBRSxxRUFBcUUsbURBQW1ELFdBQVcsRUFBRSx3Q0FBd0MsOEZBQThGLFdBQVcsOEJBQThCLFNBQVMscUNBQXFDLHdCQUF3Qix3Q0FBd0MsMkVBQTJFLFdBQVcsb0JBQW9CLFNBQVMsT0FBTyxxREFBcUQsZ2JBQWdiLGlJQUFpSSwrQkFBK0IsNlhBQTZYLGlCQUFpQixTQUFTLHFFQUFxRSxrREFBa0QseUJBQXlCLDJCQUEyQixTQUFTLGlEQUFpRCx3RUFBd0UsU0FBUyw4QkFBOEIsaURBQWlELFNBQVMseUNBQXlDLE9BQU8saUdBQWlHLHdHQUF3Ryw0QkFBNEIsK0JBQStCLCtCQUErQiwwREFBMEQsU0FBUywyQkFBMkIsd0ZBQXdGLHFEQUFxRCw0REFBNEQsV0FBVyxPQUFPLDBCQUEwQix1QkFBdUIsV0FBVyxTQUFTLDJHQUEyRyw2REFBNkQsNkZBQTZGLG1CQUFtQixXQUFXLEVBQUUsU0FBUyxPQUFPLDJGQUEyRix3QkFBd0IsaUJBQWlCLFNBQVMsaURBQWlELCtCQUErQixzRkFBc0YsRUFBRSw2UkFBNlIsa0RBQWtELFNBQVMsMEJBQTBCLHdDQUF3QyxvREFBb0QsV0FBVyx5QkFBeUIsU0FBUyxrREFBa0QsK0JBQStCLDBHQUEwRyxFQUFFLE9BQU8sNkNBQTZDLGdFQUFnRSw4RkFBOEYsaUJBQWlCLFNBQVMsc0dBQXNHLCtCQUErQixTQUFTLHVEQUF1RCw4QkFBOEIsa0dBQWtHLEVBQUUsT0FBTyxpREFBaUQsMkRBQTJELE9BQU8sNkNBQTZDLDhJQUE4SSx5RkFBeUYsU0FBUyx1QkFBdUIsT0FBTyxzQ0FBc0MsdUJBQXVCLDJCQUEyQixTQUFTLDhHQUE4Ryx5SUFBeUksb0hBQW9ILGlEQUFpRCxxREFBcUQsa0RBQWtELDZCQUE2QixXQUFXLE9BQU8sdVlBQXVZLFdBQVcsU0FBUyxFQUFFLG9DQUFvQyxtRkFBbUYsdUJBQXVCLG1GQUFtRixXQUFXLE9BQU8sNkNBQTZDLFdBQVcsU0FBUyxFQUFFLDJCQUEyQix5REFBeUQsNENBQTRDLFNBQVMsT0FBTyx1Q0FBdUMsNkNBQTZDLG1DQUFtQyxpQkFBaUIsU0FBUyxvQ0FBb0MsMkJBQTJCLFNBQVMsT0FBTyx3Q0FBd0Msc0NBQXNDLHVEQUF1RCxnREFBZ0QsYUFBYSxFQUFFLFdBQVcsT0FBTyw0REFBNEQsZ0RBQWdELGFBQWEsRUFBRSxXQUFXLFNBQVMsd0NBQXdDLE9BQU8seUNBQXlDLDZDQUE2QyxrQ0FBa0MsaUJBQWlCLFNBQVMsb0NBQW9DLDBCQUEwQixTQUFTLE9BQU8sd0NBQXdDLG9EQUFvRCxtQkFBbUIsV0FBVyxzQ0FBc0MseURBQXlELFdBQVcsT0FBTywrQkFBK0IsV0FBVyxTQUFTLHdDQUF3QyxPQUFPLDBDQUEwQyxzQ0FBc0MsMExBQTBMLGtEQUFrRCwwREFBMEQscUNBQXFDLDBDQUEwQyxXQUFXLGlEQUFpRCwwQ0FBMEMscUNBQXFDLDRCQUE0QixXQUFXLFVBQVUseURBQXlELGlCQUFpQixTQUFTLDBFQUEwRSx3T0FBd08sNENBQTRDLDhDQUE4Qyw0REFBNEQseUhBQXlILG1DQUFtQywwREFBMEQsd0NBQXdDLGFBQWEsS0FBSyxXQUFXLGlDQUFpQyx5SEFBeUgsc0NBQXNDLGFBQWEsS0FBSyxXQUFXLEVBQUUsU0FBUyxPQUFPLHdFQUF3RSx3QkFBd0IsZ0JBQWdCLGlHQUFpRyxrRUFBa0UsNEVBQTRFLGNBQWMsV0FBVyxVQUFVLE9BQU8sdURBQXVELGdEQUFnRCxxRUFBcUUsT0FBTyxLQUFLLEVBQUUsdVNBQXVTLDBDQUEwQyxxQ0FBcUMsd0tBQXdLLGtIQUFrSCxTQUFTLGlLQUFpSywwR0FBMEcscUlBQXFJLDREQUE0RCxrRkFBa0YsNkJBQTZCLHFHQUFxRyxPQUFPLDhEQUE4RCwrS0FBK0ssNkJBQTZCLHVDQUF1QyxTQUFTLDZDQUE2QyxzREFBc0QsNEJBQTRCLHVEQUF1RCxTQUFTLE9BQU8sZ0RBQWdELFNBQVMsT0FBTyxvQ0FBb0Msa0JBQWtCLGtFQUFrRSxFQUFFLGdGQUFnRiwyRkFBMkYsc0NBQXNDLDBCQUEwQixTQUFTLCtHQUErRyxrSEFBa0gsNEVBQTRFLE9BQU8sb0RBQW9ELHdCQUF3QixxQ0FBcUMscURBQXFELG9DQUFvQyxvREFBb0QsU0FBUyxrQ0FBa0Msb0NBQW9DLDREQUE0RCxxREFBcUQsV0FBVyxFQUFFLFNBQVMsT0FBTyxzQ0FBc0Msd0JBQXdCLG1GQUFtRix3Q0FBd0Msc0VBQXNFLGtDQUFrQyxTQUFTLEVBQUUsa0lBQWtJLGdDQUFnQywwQ0FBMEMsOEZBQThGLFdBQVcsU0FBUyxFQUFFLE9BQU8sb0NBQW9DLDZHQUE2RyxnQ0FBZ0MscURBQXFELHdFQUF3RSxXQUFXLFNBQVMsRUFBRSxPQUFPLG1DQUFtQyxrT0FBa08sb0lBQW9JLGlCQUFpQixTQUFTLHVDQUF1QyxvRUFBb0UsU0FBUyxpREFBaUQsMkdBQTJHLDZDQUE2QywyREFBMkQscURBQXFELDRDQUE0QyxnRUFBZ0UsMENBQTBDLGFBQWEsMkNBQTJDLGdDQUFnQyx1Q0FBdUMsMkZBQTJGLDJDQUEyQyxhQUFhLFdBQVcsRUFBRSxTQUFTLHFEQUFxRCw2Q0FBNkMsT0FBTywrREFBK0QsK0lBQStJLG9EQUFvRCwwREFBMEQsU0FBUyx1RUFBdUUscUxBQXFMLHNIQUFzSCxxQkFBcUIsYUFBYSw0WEFBNFgscUNBQXFDLGFBQWEsa0RBQWtELFdBQVcsRUFBRSxTQUFTLEVBQUUsd0JBQXdCLDZDQUE2QyxTQUFTLE9BQU8sc0RBQXNELG9JQUFvSSx5QkFBeUIseUJBQXlCLGlCQUFpQixTQUFTLHVLQUF1Syw0QkFBNEIsMEVBQTBFLGlCQUFpQixTQUFTLHlmQUF5ZixzREFBc0QseUNBQXlDLFdBQVcsT0FBTyx5Q0FBeUMsV0FBVyxTQUFTLDhDQUE4QyxzQ0FBc0MsNkRBQTZELDhEQUE4RCxtUUFBbVEsOEJBQThCLHdDQUF3QywyRUFBMkUsU0FBUyxPQUFPLGdDQUFnQyxTQUFTLG1FQUFtRSxvQ0FBb0Msb0NBQW9DLDBDQUEwQyxtQkFBbUIsV0FBVyw2Q0FBNkMsU0FBUyx5RUFBeUUsbUNBQW1DLDBDQUEwQyxFQUFFLHVGQUF1RixTQUFTLE9BQU8scUNBQXFDLGlDQUFpQywwQkFBMEIsU0FBUyx5QkFBeUIsaURBQWlELHlPQUF5TyxvRUFBb0UsMkNBQTJDLDBDQUEwQyx5Q0FBeUMsYUFBYSxXQUFXLGlCQUFpQixTQUFTLDBDQUEwQyxtQ0FBbUMsRUFBRSxPQUFPLCtFQUErRSxzQkFBc0Isd0NBQXdDLHdEQUF3RCw2Q0FBNkMsa0RBQWtELDBDQUEwQyxhQUFhLFdBQVcsVUFBVSwrSkFBK0osdUNBQXVDLDREQUE0RCxZQUFZLFNBQVMsdURBQXVELHdDQUF3QyxTQUFTLHFEQUFxRCxzQ0FBc0MsU0FBUyx5Q0FBeUMsT0FBTyxxQ0FBcUMsNEpBQTRKLG9FQUFvRSx3WEFBd1gsaUJBQWlCLFNBQVMsd0NBQXdDLDhMQUE4TCxpQkFBaUIsU0FBUyxnR0FBZ0csc05BQXNOLG9FQUFvRSxTQUFTLDBDQUEwQyxvQ0FBb0MsMkJBQTJCLDhEQUE4RCx1Q0FBdUMsU0FBUyxFQUFFLGlEQUFpRCwyREFBMkQscUdBQXFHLHdDQUF3QyxTQUFTLGtEQUFrRCx1REFBdUQsc0RBQXNELDREQUE0RCxvQ0FBb0MsV0FBVyxFQUFFLFNBQVMscUNBQXFDLDJDQUEyQyxtQ0FBbUMsRUFBRSxvQ0FBb0Msc0NBQXNDLFNBQVMsT0FBTyw2Q0FBNkMsME5BQTBOLHdFQUF3RSxnREFBZ0Qsb0NBQW9DLCtEQUErRCxPQUFPLHNDQUFzQyxnREFBZ0QsNkNBQTZDLE9BQU8seURBQXlELHlCQUF5QixtREFBbUQsT0FBTyxzQ0FBc0Msd0JBQXdCLG1GQUFtRixrSkFBa0osMERBQTBELGtDQUFrQyx1QkFBdUIseUdBQXlHLDBFQUEwRSx3SEFBd0gsMEVBQTBFLGFBQWEsdURBQXVELFdBQVcsU0FBUyxFQUFFLGlDQUFpQyxPQUFPLEtBQUssRUFBRSxHQUFHLEVBQUUsQzs7Ozs7Ozs7Ozs7QUNBbDk1aEIsaU5BQWlOLHFDQUFxQyxpSUFBaUksS0FBSyx1QkFBdUIsNkVBQTZFLHFEQUFxRCw0Q0FBNEMsaUZBQWlGLDArQkFBMCtCLDZDQUE2QyxzQkFBc0IsU0FBUyxtREFBbUQsbUVBQW1FLGlFQUFpRSxrREFBa0QsZ0RBQWdELHFpQkFBcWlCLDhOQUE4TiwwcUJBQTBxQixPQUFPLFdBQVcsMkJBQTJCLDZCQUE2QixtRUFBbUUsaUNBQWlDLHlDQUF5Qyw2Q0FBNkMsa0NBQWtDLGtFQUFrRSw2QkFBNkIsU0FBUyx3REFBd0QsMkJBQTJCLE9BQU8sMkJBQTJCLHFCQUFxQiw0REFBNEQsbURBQW1ELHNGQUFzRiw0QkFBNEIsMkJBQTJCLHlHQUF5RyxtQ0FBbUMsb0NBQW9DLDRDQUE0QyxpREFBaUQsa0RBQWtELFdBQVcsT0FBTyx1Q0FBdUMsV0FBVyx3Q0FBd0Msd0VBQXdFLCtGQUErRixtQ0FBbUMsZ0VBQWdFLFNBQVMsaURBQWlELE9BQU8sSUFBSSx3Q0FBd0MsOENBQThDLGdEQUFnRCxnQ0FBZ0MsV0FBVyxTQUFTLEVBQUUsc0RBQXNELFFBQVEseUNBQXlDLGlDQUFpQyxRQUFRLHVDQUF1QyxnRUFBZ0UsK0RBQStELFNBQVMsRUFBRSxpRUFBaUUsK0RBQStELFNBQVMsRUFBRSxRQUFRLHNDQUFzQyxpRUFBaUUsK0RBQStELFNBQVMsRUFBRSxRQUFRLDJDQUEyQywrREFBK0QsZ0hBQWdILGdEQUFnRCxvREFBb0QsV0FBVyxFQUFFLFNBQVMsUUFBUSw0Q0FBNEMsNENBQTRDLDJCQUEyQiwrQ0FBK0MsUUFBUSxrREFBa0QsNEJBQTRCLDhCQUE4QixnQ0FBZ0Msd0VBQXdFLG1DQUFtQyxTQUFTLFFBQVEsbUNBQW1DLGlDQUFpQyx3QkFBd0IsUUFBUSxrSEFBa0gsZ0RBQWdELDhCQUE4QixxQ0FBcUMsK0JBQStCLDZGQUE2Riw0QkFBNEIsaUZBQWlGLHNDQUFzQywwQkFBMEIsNEJBQTRCLDhCQUE4QiwyQ0FBMkMsNEJBQTRCLFNBQVMsK0JBQStCLDZCQUE2Qix5Q0FBeUMsaUZBQWlGLFdBQVcsRUFBRSxTQUFTLDZCQUE2Qix3QkFBd0Isb0NBQW9DLHlDQUF5QyxpQ0FBaUMsdUVBQXVFLG1DQUFtQyxzQ0FBc0MsV0FBVyxFQUFFLFNBQVMsb0JBQW9CLFFBQVEseUNBQXlDLDhCQUE4QixRQUFRLHVCQUF1Qix5QkFBeUIsMEJBQTBCLHlDQUF5Qyw0QkFBNEIsdUJBQXVCLHlDQUF5QyxxR0FBcUcsNkRBQTZELHdEQUF3RCw0QkFBNEIsV0FBVyxPQUFPLHVEQUF1RCxzQ0FBc0MsdUNBQXVDLG9DQUFvQywyRUFBMkUsNkJBQTZCLGVBQWUsYUFBYSx3REFBd0QsV0FBVyxTQUFTLElBQUksT0FBTyxxREFBcUQsNENBQTRDLDhCQUE4Qiw2QkFBNkIsaURBQWlELFNBQVMsRUFBRSwyQ0FBMkMsOEJBQThCLDZCQUE2Qiw2QkFBNkIsa0dBQWtHLGdEQUFnRCxXQUFXLFNBQVMsRUFBRSx1Q0FBdUMsNkJBQTZCLG9EQUFvRCxrQ0FBa0MseURBQXlELGtEQUFrRCxtSUFBbUksbUJBQW1CLFdBQVcsbURBQW1ELGlEQUFpRCxTQUFTLEVBQUUsNENBQTRDLG9EQUFvRCxTQUFTLEVBQUUsa0RBQWtELDhCQUE4Qiw2QkFBNkIsU0FBUyxFQUFFLGlEQUFpRCw4QkFBOEIsNkJBQTZCLDZCQUE2QiwyREFBMkQsbURBQW1ELFdBQVcsU0FBUyxFQUFFLDZDQUE2Qyw4QkFBOEIsNkJBQTZCLG9EQUFvRCxTQUFTLEVBQUUsT0FBTyxtQ0FBbUMsMkJBQTJCLGlDQUFpQyx3Q0FBd0MscUNBQXFDLGdEQUFnRCxTQUFTLE9BQU8sZ0RBQWdELFNBQVMseUJBQXlCLE9BQU8sMkNBQTJDLDRCQUE0QixxREFBcUQsNENBQTRDLFNBQVMsT0FBTyxxREFBcUQsU0FBUyxzQ0FBc0Msd0JBQXdCLG9CQUFvQixxQkFBcUIsU0FBUyxPQUFPLDZEQUE2RCwwQ0FBMEMsa0ZBQWtGLFNBQVMsd0JBQXdCLE9BQU8sMkRBQTJELDRCQUE0QixLQUFLLGdDQUFnQywyQkFBMkIsd0RBQXdELCtCQUErQix5QkFBeUIsa0JBQWtCLE9BQU8sMERBQTBELHVLQUF1SyxxQkFBcUIsV0FBVyx1RUFBdUUsbUxBQW1MLHFCQUFxQixXQUFXLG1EQUFtRCx3Q0FBd0MsOEVBQThFLDRCQUE0QixTQUFTLDRDQUE0QyxtQ0FBbUMsMEJBQTBCLCtDQUErQywyQkFBMkIsa0JBQWtCLE9BQU8sMkJBQTJCLGtEQUFrRCxhQUFhLFdBQVcsU0FBUywyQkFBMkIsK0NBQStDLHNDQUFzQyxrREFBa0QsbUJBQW1CLFlBQVksZ0lBQWdJLDhCQUE4QixxREFBcUQsT0FBTyx5REFBeUQsdUJBQXVCLGtCQUFrQixPQUFPLDBEQUEwRCw2S0FBNksscUJBQXFCLFdBQVcsNEVBQTRFLGtLQUFrSyxxQkFBcUIsV0FBVyx1RUFBdUUseUxBQXlMLHFCQUFxQixXQUFXLDhFQUE4RSxzTEFBc0wscUJBQXFCLFdBQVcsZ0NBQWdDLG9EQUFvRCx5REFBeUQsS0FBSyxrQ0FBa0MsMERBQTBELHdDQUF3QyxxQ0FBcUMsNEJBQTRCLGlEQUFpRCw2QkFBNkIsa0JBQWtCLE9BQU8sNkJBQTZCLG9EQUFvRCxlQUFlLGFBQWEsV0FBVyw2QkFBNkIsaURBQWlELGlDQUFpQyxvR0FBb0csaUNBQWlDLHdGQUF3Rix3Q0FBd0Msb0RBQW9ELG1CQUFtQixZQUFZLGdJQUFnSSxnQ0FBZ0MsNkJBQTZCLHdDQUF3QyxpRUFBaUUsNEJBQTRCLFNBQVMsT0FBTyxzREFBc0QsNEVBQTRFLDBEQUEwRCxtRkFBbUYsdUJBQXVCLFNBQVMsc0JBQXNCLE9BQU8saURBQWlELDhCQUE4Qiw2Q0FBNkMseUJBQXlCLGtDQUFrQyxPQUFPLGdKQUFnSiwrQkFBK0IsYUFBYSxXQUFXLFNBQVMsMkJBQTJCLE9BQU8sdURBQXVELDJDQUEyQyx5QkFBeUIsb0JBQW9CLE9BQU8sZ0VBQWdFLDhCQUE4QixtREFBbUQsYUFBYSxXQUFXLFNBQVMsT0FBTyw2Q0FBNkMsbUJBQW1CLHFCQUFxQix3Q0FBd0MsMENBQTBDLDZDQUE2QyxZQUFZLHVDQUF1QyxTQUFTLE9BQU8sNENBQTRDLGdDQUFnQyxtRkFBbUYsc0NBQXNDLDBGQUEwRiwrREFBK0QsK0NBQStDLGFBQWEsNkRBQTZELCtCQUErQixvQkFBb0IsV0FBVyxFQUFFLFNBQVMsT0FBTyxvRUFBb0Usc0VBQXNFLDJIQUEySCw2SUFBNkksMkJBQTJCLHlHQUF5RyxtQ0FBbUMsYUFBYSxzSkFBc0osU0FBUyx5REFBeUQsc0NBQXNDLGtDQUFrQyx5RUFBeUUsNkJBQTZCLGdFQUFnRSx5QkFBeUIsdUJBQXVCLE9BQU8sbURBQW1ELGVBQWUsNERBQTRELGFBQWEsT0FBTyw0Q0FBNEMsMkJBQTJCLHdDQUF3Qyw0REFBNEQsNktBQTZLLHFCQUFxQixhQUFhLG1FQUFtRSxxRUFBcUUsRUFBRSxtREFBbUQsV0FBVyxzQ0FBc0Msd0NBQXdDLHNCQUFzQiw0REFBNEQsK0JBQStCLDhIQUE4SCxzQ0FBc0MsK0RBQStELDRCQUE0QixxREFBcUQsYUFBYSxPQUFPLGdDQUFnQyw2QkFBNkIsc0JBQXNCLE9BQU8sZ0hBQWdILHlDQUF5QyxlQUFlLGdDQUFnQyxhQUFhLGtHQUFrRyxtTEFBbUwscUJBQXFCLGFBQWEsb0RBQW9ELG1EQUFtRCx1Q0FBdUMsOERBQThELFdBQVcsU0FBUyxFQUFFLDhCQUE4QixvQkFBb0IsMkRBQTJELEVBQUUsMkJBQTJCLHdHQUF3RyxFQUFFLHlCQUF5QiwrWUFBK1ksRUFBRSxxQ0FBcUMsU0FBUyxPQUFPLG1DQUFtQyxvQkFBb0IsZ0pBQWdKLEVBQUUsd0ZBQXdGLG9EQUFvRCxhQUFhLE9BQU8sMkNBQTJDLGdDQUFnQyxhQUFhLEVBQUUsV0FBVyxTQUFTLE9BQU8sNkNBQTZDLHVHQUF1RyxxSkFBcUosc0dBQXNHLDBHQUEwRyxzR0FBc0csNEZBQTRGLDhGQUE4RiwwRkFBMEYsa0dBQWtHLDJGQUEyRixzREFBc0QsdURBQXVELDJEQUEyRCx1REFBdUQsb0RBQW9ELG9CQUFvQixPQUFPLDRDQUE0Qyx1QkFBdUIsdUVBQXVFLDBDQUEwQywwQ0FBMEMsK0NBQStDLDJDQUEyQyxpREFBaUQsK0hBQStILG1GQUFtRiw2Q0FBNkMsbUJBQW1CLE9BQU8sb0VBQW9FLDhCQUE4Qix1QkFBdUIsc1VBQXNVLDREQUE0RCxzQ0FBc0MsK0RBQStELDhCQUE4QixpQ0FBaUMsa0JBQWtCLE9BQU8sbUNBQW1DLG9IQUFvSCw2Q0FBNkMscUJBQXFCLG1CQUFtQixpQkFBaUIsZUFBZSxrQ0FBa0MsMEZBQTBGLDJIQUEySCx3REFBd0QsaUJBQWlCLEVBQUUsZUFBZSw0QkFBNEIsYUFBYSw0R0FBNEcsNkJBQTZCLDBCQUEwQix5Q0FBeUMsbURBQW1ELHFEQUFxRCxvQ0FBb0Msa0RBQWtELG9EQUFvRCx1RUFBdUUsYUFBYSxFQUFFLHlCQUF5QixXQUFXLG9EQUFvRCx3Q0FBd0Msd0RBQXdELGFBQWEsb0NBQW9DLDZCQUE2QiwyQkFBMkIsZ0NBQWdDLDhCQUE4QiwwQ0FBMEMsdURBQXVELDRCQUE0QixzREFBc0Qsa0ZBQWtGLGVBQWUsRUFBRSxhQUFhLDJFQUEyRSwyQ0FBMkMsZUFBZSxpQ0FBaUMsbUNBQW1DLDZGQUE2Riw0R0FBNEcsbURBQW1ELHNFQUFzRSxtQ0FBbUMsOENBQThDLHlEQUF5RCxhQUFhLFdBQVcsMERBQTBELCtCQUErQiw0QkFBNEIsNElBQTRJLDhCQUE4QixrREFBa0QsNERBQTRELDZDQUE2QyxzQ0FBc0MsMEdBQTBHLGVBQWUsT0FBTyxvQ0FBb0Msc0NBQXNDLGVBQWUsc0RBQXNELDJEQUEyRCxxQkFBcUIsYUFBYSx1Q0FBdUMseUNBQXlDLG1DQUFtQywwQ0FBMEMseURBQXlELGFBQWEsOEJBQThCLDZEQUE2RCw2Q0FBNkMsK0JBQStCLCtCQUErQiwyQ0FBMkMsOENBQThDLHdDQUF3QyxpQkFBaUIsRUFBRSxlQUFlLE9BQU8sK0JBQStCLGVBQWUsbUNBQW1DLDhCQUE4QiwwQ0FBMEMseURBQXlELCtDQUErQyw4RUFBOEUsd0RBQXdELDJFQUEyRSxpQkFBaUIsRUFBRSxlQUFlLE9BQU8sOEJBQThCLGVBQWUsYUFBYSxPQUFPLDBDQUEwQyxvQ0FBb0MsYUFBYSxtQ0FBbUMsaUNBQWlDLDZDQUE2QyxxRUFBcUUsZUFBZSxFQUFFLGFBQWEsNEJBQTRCLFdBQVcsdURBQXVELCtCQUErQiw0QkFBNEIsNEJBQTRCLDZFQUE2RSxxREFBcUQsMENBQTBDLGVBQWUsT0FBTyxrRUFBa0UsNkNBQTZDLHNDQUFzQyw2R0FBNkcsZUFBZSxPQUFPLG9DQUFvQyxzQ0FBc0MsZUFBZSxzREFBc0QsMENBQTBDLDRCQUE0QixXQUFXLFVBQVUsOENBQThDLDJHQUEyRyxTQUFTLDZCQUE2QixpQ0FBaUMsMkJBQTJCLGlDQUFpQyxTQUFTLE9BQU8sNkJBQTZCLDZCQUE2Qix5Q0FBeUMsbURBQW1ELHFEQUFxRCw0QkFBNEIsb0NBQW9DLGtEQUFrRCxvREFBb0QsdUVBQXVFLGFBQWEsRUFBRSxXQUFXLG1DQUFtQyxTQUFTLE9BQU8sb0JBQW9CLE1BQU0sR0FBRyxVQUFVLEM7Ozs7Ozs7Ozs7O0FDQTd0OUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDMUJBLG1CQUFPLENBQUMsNkZBQW1GLEVBQUUsbUJBQU8sQ0FBQyxzTUFBaU8sK007Ozs7Ozs7Ozs7O0FDQXRVLG1CQUFPLENBQUMsNkZBQW1GLEVBQUUsbUJBQU8sQ0FBQyxrTkFBdU8scU47Ozs7Ozs7Ozs7O0FDQTVVLG1CQUFPLENBQUMsNkZBQW1GLEVBQUUsbUJBQU8sQ0FBQyxnTkFBc08sb047Ozs7Ozs7Ozs7O0FDQTNVLG1CQUFPLENBQUMsNkZBQW1GLEVBQUUsbUJBQU8sQ0FBQyxnT0FBOE8sNE47Ozs7Ozs7Ozs7O0FDQW5WLG1CQUFPLENBQUMsNkZBQW1GLEVBQUUsbUJBQU8sQ0FBQywwTkFBMk8seU47Ozs7Ozs7Ozs7O0FDQWhWLG1CQUFPLENBQUMsNkZBQW1GLEVBQUUsbUJBQU8sQ0FBQywwT0FBbVAsaU8iLCJmaWxlIjoibWxhYi5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiL2J1aWxkL1wiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL2Fzc2V0cy9qcy9tbGFiLmpzXCIpO1xuIiwiLy8gcmVxdWlyZSBqUXVlcnkgbm9ybWFsbHlcbmNvbnN0ICQgPSByZXF1aXJlKCdzY3JpcHQtbG9hZGVyIS4vanF1ZXJ5LTIuMS40LmpzJyk7XG5cbi8vIGlmL3doZW4gdXNlIE5QTSB2ZXJzaW9uLCBuZWVkIHRvIGNyZWF0ZSBnbG9iYWwgJCBhbmQgalF1ZXJ5IHZhcmlhYmxlc1xuLy8gZ2xvYmFsLiQgPSBnbG9iYWwualF1ZXJ5ID0gJDtcblxucmVxdWlyZSgnc2NyaXB0LWxvYWRlciEuL2pxdWVyeS51aS0xLjExLjQuanMnKTtcbnJlcXVpcmUoJ3NjcmlwdC1sb2FkZXIhLi9qcXVlcnkuZm9ybS5qcycpO1xucmVxdWlyZSgnc2NyaXB0LWxvYWRlciEuL2pxdWVyeS51cGxvYWRmaWxlLTQuMC4xMS5qcycpO1xuLy8gcmVxdWlyZSgnc2NyaXB0LWxvYWRlciEuL2pxdWVyeS5xdGlwLTMuMC4zLmpzJyk7XG5yZXF1aXJlKCdzY3JpcHQtbG9hZGVyIS4vanF1ZXJ5LnF0aXAubmlnaHRseS5qcycpO1xucmVxdWlyZSgnc2NyaXB0LWxvYWRlciEuL2Jvd3Nlci5qcycpOyIsIm1vZHVsZS5leHBvcnRzID0gXCIvKiFcXG4gICogQm93c2VyIC0gYSBicm93c2VyIGRldGVjdG9yXFxuICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9kZWQvYm93c2VyXFxuICAqIE1JVCBMaWNlbnNlIHwgKGMpIER1c3RpbiBEaWF6IDIwMTRcXG4gICovXFxuIWZ1bmN0aW9uIChuYW1lLCBkZWZpbml0aW9uKSB7XFxuICBpZiAodHlwZW9mIG1vZHVsZSAhPSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykgbW9kdWxlLmV4cG9ydHNbJ2Jyb3dzZXInXSA9IGRlZmluaXRpb24oKTtlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkgZGVmaW5lKGRlZmluaXRpb24pO2Vsc2UgdGhpc1tuYW1lXSA9IGRlZmluaXRpb24oKTtcXG59KCdib3dzZXInLCBmdW5jdGlvbiAoKSB7XFxuICAvKipcXG4gICAgKiBTZWUgdXNlcmFnZW50cy5qcyBmb3IgZXhhbXBsZXMgb2YgbmF2aWdhdG9yLnVzZXJBZ2VudFxcbiAgICAqL1xcbiAgdmFyIHQgPSB0cnVlO1xcblxcbiAgZnVuY3Rpb24gZGV0ZWN0KHVhKSB7XFxuICAgIGZ1bmN0aW9uIGdldEZpcnN0TWF0Y2gocmVnZXgpIHtcXG4gICAgICB2YXIgbWF0Y2ggPSB1YS5tYXRjaChyZWdleCk7XFxuICAgICAgcmV0dXJuIG1hdGNoICYmIG1hdGNoLmxlbmd0aCA+IDEgJiYgbWF0Y2hbMV0gfHwgJyc7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gZ2V0U2Vjb25kTWF0Y2gocmVnZXgpIHtcXG4gICAgICB2YXIgbWF0Y2ggPSB1YS5tYXRjaChyZWdleCk7XFxuICAgICAgcmV0dXJuIG1hdGNoICYmIG1hdGNoLmxlbmd0aCA+IDEgJiYgbWF0Y2hbMl0gfHwgJyc7XFxuICAgIH1cXG5cXG4gICAgdmFyIGlvc2RldmljZSA9IGdldEZpcnN0TWF0Y2goLyhpcG9kfGlwaG9uZXxpcGFkKS9pKS50b0xvd2VyQ2FzZSgpLFxcbiAgICAgICAgbGlrZUFuZHJvaWQgPSAvbGlrZSBhbmRyb2lkL2kudGVzdCh1YSksXFxuICAgICAgICBhbmRyb2lkID0gIWxpa2VBbmRyb2lkICYmIC9hbmRyb2lkL2kudGVzdCh1YSksXFxuICAgICAgICBlZGdlVmVyc2lvbiA9IGdldEZpcnN0TWF0Y2goL2VkZ2VcXFxcLyhcXFxcZCsoXFxcXC5cXFxcZCspPykvaSksXFxuICAgICAgICB2ZXJzaW9uSWRlbnRpZmllciA9IGdldEZpcnN0TWF0Y2goL3ZlcnNpb25cXFxcLyhcXFxcZCsoXFxcXC5cXFxcZCspPykvaSksXFxuICAgICAgICB0YWJsZXQgPSAvdGFibGV0L2kudGVzdCh1YSksXFxuICAgICAgICBtb2JpbGUgPSAhdGFibGV0ICYmIC9bXi1dbW9iaS9pLnRlc3QodWEpLFxcbiAgICAgICAgcmVzdWx0O1xcblxcbiAgICBpZiAoL29wZXJhfG9wci9pLnRlc3QodWEpKSB7XFxuICAgICAgcmVzdWx0ID0ge1xcbiAgICAgICAgbmFtZTogJ09wZXJhJyxcXG4gICAgICAgIG9wZXJhOiB0LFxcbiAgICAgICAgdmVyc2lvbjogdmVyc2lvbklkZW50aWZpZXIgfHwgZ2V0Rmlyc3RNYXRjaCgvKD86b3BlcmF8b3ByKVtcXFxcc1xcXFwvXShcXFxcZCsoXFxcXC5cXFxcZCspPykvaSlcXG4gICAgICB9O1xcbiAgICB9IGVsc2UgaWYgKC93aW5kb3dzIHBob25lL2kudGVzdCh1YSkpIHtcXG4gICAgICByZXN1bHQgPSB7XFxuICAgICAgICBuYW1lOiAnV2luZG93cyBQaG9uZScsXFxuICAgICAgICB3aW5kb3dzcGhvbmU6IHRcXG4gICAgICB9O1xcblxcbiAgICAgIGlmIChlZGdlVmVyc2lvbikge1xcbiAgICAgICAgcmVzdWx0Lm1zZWRnZSA9IHQ7XFxuICAgICAgICByZXN1bHQudmVyc2lvbiA9IGVkZ2VWZXJzaW9uO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICByZXN1bHQubXNpZSA9IHQ7XFxuICAgICAgICByZXN1bHQudmVyc2lvbiA9IGdldEZpcnN0TWF0Y2goL2llbW9iaWxlXFxcXC8oXFxcXGQrKFxcXFwuXFxcXGQrKT8pL2kpO1xcbiAgICAgIH1cXG4gICAgfSBlbHNlIGlmICgvbXNpZXx0cmlkZW50L2kudGVzdCh1YSkpIHtcXG4gICAgICByZXN1bHQgPSB7XFxuICAgICAgICBuYW1lOiAnSW50ZXJuZXQgRXhwbG9yZXInLFxcbiAgICAgICAgbXNpZTogdCxcXG4gICAgICAgIHZlcnNpb246IGdldEZpcnN0TWF0Y2goLyg/Om1zaWUgfHJ2OikoXFxcXGQrKFxcXFwuXFxcXGQrKT8pL2kpXFxuICAgICAgfTtcXG4gICAgfSBlbHNlIGlmICgvY2hyb21lLis/IGVkZ2UvaS50ZXN0KHVhKSkge1xcbiAgICAgIHJlc3VsdCA9IHtcXG4gICAgICAgIG5hbWU6ICdNaWNyb3NvZnQgRWRnZScsXFxuICAgICAgICBtc2VkZ2U6IHQsXFxuICAgICAgICB2ZXJzaW9uOiBlZGdlVmVyc2lvblxcbiAgICAgIH07XFxuICAgIH0gZWxzZSBpZiAoL2Nocm9tZXxjcmlvc3xjcm1vL2kudGVzdCh1YSkpIHtcXG4gICAgICByZXN1bHQgPSB7XFxuICAgICAgICBuYW1lOiAnQ2hyb21lJyxcXG4gICAgICAgIGNocm9tZTogdCxcXG4gICAgICAgIHZlcnNpb246IGdldEZpcnN0TWF0Y2goLyg/OmNocm9tZXxjcmlvc3xjcm1vKVxcXFwvKFxcXFxkKyhcXFxcLlxcXFxkKyk/KS9pKVxcbiAgICAgIH07XFxuICAgIH0gZWxzZSBpZiAoaW9zZGV2aWNlKSB7XFxuICAgICAgcmVzdWx0ID0ge1xcbiAgICAgICAgbmFtZTogaW9zZGV2aWNlID09ICdpcGhvbmUnID8gJ2lQaG9uZScgOiBpb3NkZXZpY2UgPT0gJ2lwYWQnID8gJ2lQYWQnIDogJ2lQb2QnIC8vIFdURjogdmVyc2lvbiBpcyBub3QgcGFydCBvZiB1c2VyIGFnZW50IGluIHdlYiBhcHBzXFxuXFxuICAgICAgfTtcXG5cXG4gICAgICBpZiAodmVyc2lvbklkZW50aWZpZXIpIHtcXG4gICAgICAgIHJlc3VsdC52ZXJzaW9uID0gdmVyc2lvbklkZW50aWZpZXI7XFxuICAgICAgfVxcbiAgICB9IGVsc2UgaWYgKC9zYWlsZmlzaC9pLnRlc3QodWEpKSB7XFxuICAgICAgcmVzdWx0ID0ge1xcbiAgICAgICAgbmFtZTogJ1NhaWxmaXNoJyxcXG4gICAgICAgIHNhaWxmaXNoOiB0LFxcbiAgICAgICAgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvc2FpbGZpc2hcXFxccz9icm93c2VyXFxcXC8oXFxcXGQrKFxcXFwuXFxcXGQrKT8pL2kpXFxuICAgICAgfTtcXG4gICAgfSBlbHNlIGlmICgvc2VhbW9ua2V5XFxcXC8vaS50ZXN0KHVhKSkge1xcbiAgICAgIHJlc3VsdCA9IHtcXG4gICAgICAgIG5hbWU6ICdTZWFNb25rZXknLFxcbiAgICAgICAgc2VhbW9ua2V5OiB0LFxcbiAgICAgICAgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvc2VhbW9ua2V5XFxcXC8oXFxcXGQrKFxcXFwuXFxcXGQrKT8pL2kpXFxuICAgICAgfTtcXG4gICAgfSBlbHNlIGlmICgvZmlyZWZveHxpY2V3ZWFzZWwvaS50ZXN0KHVhKSkge1xcbiAgICAgIHJlc3VsdCA9IHtcXG4gICAgICAgIG5hbWU6ICdGaXJlZm94JyxcXG4gICAgICAgIGZpcmVmb3g6IHQsXFxuICAgICAgICB2ZXJzaW9uOiBnZXRGaXJzdE1hdGNoKC8oPzpmaXJlZm94fGljZXdlYXNlbClbIFxcXFwvXShcXFxcZCsoXFxcXC5cXFxcZCspPykvaSlcXG4gICAgICB9O1xcblxcbiAgICAgIGlmICgvXFxcXCgobW9iaWxlfHRhYmxldCk7W15cXFxcKV0qcnY6W1xcXFxkXFxcXC5dK1xcXFwpL2kudGVzdCh1YSkpIHtcXG4gICAgICAgIHJlc3VsdC5maXJlZm94b3MgPSB0O1xcbiAgICAgIH1cXG4gICAgfSBlbHNlIGlmICgvc2lsay9pLnRlc3QodWEpKSB7XFxuICAgICAgcmVzdWx0ID0ge1xcbiAgICAgICAgbmFtZTogJ0FtYXpvbiBTaWxrJyxcXG4gICAgICAgIHNpbGs6IHQsXFxuICAgICAgICB2ZXJzaW9uOiBnZXRGaXJzdE1hdGNoKC9zaWxrXFxcXC8oXFxcXGQrKFxcXFwuXFxcXGQrKT8pL2kpXFxuICAgICAgfTtcXG4gICAgfSBlbHNlIGlmIChhbmRyb2lkKSB7XFxuICAgICAgcmVzdWx0ID0ge1xcbiAgICAgICAgbmFtZTogJ0FuZHJvaWQnLFxcbiAgICAgICAgdmVyc2lvbjogdmVyc2lvbklkZW50aWZpZXJcXG4gICAgICB9O1xcbiAgICB9IGVsc2UgaWYgKC9waGFudG9tL2kudGVzdCh1YSkpIHtcXG4gICAgICByZXN1bHQgPSB7XFxuICAgICAgICBuYW1lOiAnUGhhbnRvbUpTJyxcXG4gICAgICAgIHBoYW50b206IHQsXFxuICAgICAgICB2ZXJzaW9uOiBnZXRGaXJzdE1hdGNoKC9waGFudG9tanNcXFxcLyhcXFxcZCsoXFxcXC5cXFxcZCspPykvaSlcXG4gICAgICB9O1xcbiAgICB9IGVsc2UgaWYgKC9ibGFja2JlcnJ5fFxcXFxiYmJcXFxcZCsvaS50ZXN0KHVhKSB8fCAvcmltXFxcXHN0YWJsZXQvaS50ZXN0KHVhKSkge1xcbiAgICAgIHJlc3VsdCA9IHtcXG4gICAgICAgIG5hbWU6ICdCbGFja0JlcnJ5JyxcXG4gICAgICAgIGJsYWNrYmVycnk6IHQsXFxuICAgICAgICB2ZXJzaW9uOiB2ZXJzaW9uSWRlbnRpZmllciB8fCBnZXRGaXJzdE1hdGNoKC9ibGFja2JlcnJ5W1xcXFxkXStcXFxcLyhcXFxcZCsoXFxcXC5cXFxcZCspPykvaSlcXG4gICAgICB9O1xcbiAgICB9IGVsc2UgaWYgKC8od2VifGhwdylvcy9pLnRlc3QodWEpKSB7XFxuICAgICAgcmVzdWx0ID0ge1xcbiAgICAgICAgbmFtZTogJ1dlYk9TJyxcXG4gICAgICAgIHdlYm9zOiB0LFxcbiAgICAgICAgdmVyc2lvbjogdmVyc2lvbklkZW50aWZpZXIgfHwgZ2V0Rmlyc3RNYXRjaCgvdyg/OmViKT9vc2Jyb3dzZXJcXFxcLyhcXFxcZCsoXFxcXC5cXFxcZCspPykvaSlcXG4gICAgICB9O1xcbiAgICAgIC90b3VjaHBhZFxcXFwvL2kudGVzdCh1YSkgJiYgKHJlc3VsdC50b3VjaHBhZCA9IHQpO1xcbiAgICB9IGVsc2UgaWYgKC9iYWRhL2kudGVzdCh1YSkpIHtcXG4gICAgICByZXN1bHQgPSB7XFxuICAgICAgICBuYW1lOiAnQmFkYScsXFxuICAgICAgICBiYWRhOiB0LFxcbiAgICAgICAgdmVyc2lvbjogZ2V0Rmlyc3RNYXRjaCgvZG9sZmluXFxcXC8oXFxcXGQrKFxcXFwuXFxcXGQrKT8pL2kpXFxuICAgICAgfTtcXG4gICAgfSBlbHNlIGlmICgvdGl6ZW4vaS50ZXN0KHVhKSkge1xcbiAgICAgIHJlc3VsdCA9IHtcXG4gICAgICAgIG5hbWU6ICdUaXplbicsXFxuICAgICAgICB0aXplbjogdCxcXG4gICAgICAgIHZlcnNpb246IGdldEZpcnN0TWF0Y2goLyg/OnRpemVuXFxcXHM/KT9icm93c2VyXFxcXC8oXFxcXGQrKFxcXFwuXFxcXGQrKT8pL2kpIHx8IHZlcnNpb25JZGVudGlmaWVyXFxuICAgICAgfTtcXG4gICAgfSBlbHNlIGlmICgvc2FmYXJpL2kudGVzdCh1YSkpIHtcXG4gICAgICByZXN1bHQgPSB7XFxuICAgICAgICBuYW1lOiAnU2FmYXJpJyxcXG4gICAgICAgIHNhZmFyaTogdCxcXG4gICAgICAgIHZlcnNpb246IHZlcnNpb25JZGVudGlmaWVyXFxuICAgICAgfTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICByZXN1bHQgPSB7XFxuICAgICAgICBuYW1lOiBnZXRGaXJzdE1hdGNoKC9eKC4qKVxcXFwvKC4qKSAvKSxcXG4gICAgICAgIHZlcnNpb246IGdldFNlY29uZE1hdGNoKC9eKC4qKVxcXFwvKC4qKSAvKVxcbiAgICAgIH07XFxuICAgIH0gLy8gc2V0IHdlYmtpdCBvciBnZWNrbyBmbGFnIGZvciBicm93c2VycyBiYXNlZCBvbiB0aGVzZSBlbmdpbmVzXFxuXFxuXFxuICAgIGlmICghcmVzdWx0Lm1zZWRnZSAmJiAvKGFwcGxlKT93ZWJraXQvaS50ZXN0KHVhKSkge1xcbiAgICAgIHJlc3VsdC5uYW1lID0gcmVzdWx0Lm5hbWUgfHwgXFxcIldlYmtpdFxcXCI7XFxuICAgICAgcmVzdWx0LndlYmtpdCA9IHQ7XFxuXFxuICAgICAgaWYgKCFyZXN1bHQudmVyc2lvbiAmJiB2ZXJzaW9uSWRlbnRpZmllcikge1xcbiAgICAgICAgcmVzdWx0LnZlcnNpb24gPSB2ZXJzaW9uSWRlbnRpZmllcjtcXG4gICAgICB9XFxuICAgIH0gZWxzZSBpZiAoIXJlc3VsdC5vcGVyYSAmJiAvZ2Vja29cXFxcLy9pLnRlc3QodWEpKSB7XFxuICAgICAgcmVzdWx0Lm5hbWUgPSByZXN1bHQubmFtZSB8fCBcXFwiR2Vja29cXFwiO1xcbiAgICAgIHJlc3VsdC5nZWNrbyA9IHQ7XFxuICAgICAgcmVzdWx0LnZlcnNpb24gPSByZXN1bHQudmVyc2lvbiB8fCBnZXRGaXJzdE1hdGNoKC9nZWNrb1xcXFwvKFxcXFxkKyhcXFxcLlxcXFxkKyk/KS9pKTtcXG4gICAgfSAvLyBzZXQgT1MgZmxhZ3MgZm9yIHBsYXRmb3JtcyB0aGF0IGhhdmUgbXVsdGlwbGUgYnJvd3NlcnNcXG5cXG5cXG4gICAgaWYgKCFyZXN1bHQubXNlZGdlICYmIChhbmRyb2lkIHx8IHJlc3VsdC5zaWxrKSkge1xcbiAgICAgIHJlc3VsdC5hbmRyb2lkID0gdDtcXG4gICAgfSBlbHNlIGlmIChpb3NkZXZpY2UpIHtcXG4gICAgICByZXN1bHRbaW9zZGV2aWNlXSA9IHQ7XFxuICAgICAgcmVzdWx0LmlvcyA9IHQ7XFxuICAgIH0gLy8gT1MgdmVyc2lvbiBleHRyYWN0aW9uXFxuXFxuXFxuICAgIHZhciBvc1ZlcnNpb24gPSAnJztcXG5cXG4gICAgaWYgKHJlc3VsdC53aW5kb3dzcGhvbmUpIHtcXG4gICAgICBvc1ZlcnNpb24gPSBnZXRGaXJzdE1hdGNoKC93aW5kb3dzIHBob25lICg/Om9zKT9cXFxccz8oXFxcXGQrKFxcXFwuXFxcXGQrKSopL2kpO1xcbiAgICB9IGVsc2UgaWYgKGlvc2RldmljZSkge1xcbiAgICAgIG9zVmVyc2lvbiA9IGdldEZpcnN0TWF0Y2goL29zIChcXFxcZCsoW19cXFxcc11cXFxcZCspKikgbGlrZSBtYWMgb3MgeC9pKTtcXG4gICAgICBvc1ZlcnNpb24gPSBvc1ZlcnNpb24ucmVwbGFjZSgvW19cXFxcc10vZywgJy4nKTtcXG4gICAgfSBlbHNlIGlmIChhbmRyb2lkKSB7XFxuICAgICAgb3NWZXJzaW9uID0gZ2V0Rmlyc3RNYXRjaCgvYW5kcm9pZFsgXFxcXC8tXShcXFxcZCsoXFxcXC5cXFxcZCspKikvaSk7XFxuICAgIH0gZWxzZSBpZiAocmVzdWx0LndlYm9zKSB7XFxuICAgICAgb3NWZXJzaW9uID0gZ2V0Rmlyc3RNYXRjaCgvKD86d2VifGhwdylvc1xcXFwvKFxcXFxkKyhcXFxcLlxcXFxkKykqKS9pKTtcXG4gICAgfSBlbHNlIGlmIChyZXN1bHQuYmxhY2tiZXJyeSkge1xcbiAgICAgIG9zVmVyc2lvbiA9IGdldEZpcnN0TWF0Y2goL3JpbVxcXFxzdGFibGV0XFxcXHNvc1xcXFxzKFxcXFxkKyhcXFxcLlxcXFxkKykqKS9pKTtcXG4gICAgfSBlbHNlIGlmIChyZXN1bHQuYmFkYSkge1xcbiAgICAgIG9zVmVyc2lvbiA9IGdldEZpcnN0TWF0Y2goL2JhZGFcXFxcLyhcXFxcZCsoXFxcXC5cXFxcZCspKikvaSk7XFxuICAgIH0gZWxzZSBpZiAocmVzdWx0LnRpemVuKSB7XFxuICAgICAgb3NWZXJzaW9uID0gZ2V0Rmlyc3RNYXRjaCgvdGl6ZW5bXFxcXC9cXFxcc10oXFxcXGQrKFxcXFwuXFxcXGQrKSopL2kpO1xcbiAgICB9XFxuXFxuICAgIGlmIChvc1ZlcnNpb24pIHtcXG4gICAgICByZXN1bHQub3N2ZXJzaW9uID0gb3NWZXJzaW9uO1xcbiAgICB9IC8vIGRldmljZSB0eXBlIGV4dHJhY3Rpb25cXG5cXG5cXG4gICAgdmFyIG9zTWFqb3JWZXJzaW9uID0gb3NWZXJzaW9uLnNwbGl0KCcuJylbMF07XFxuXFxuICAgIGlmICh0YWJsZXQgfHwgaW9zZGV2aWNlID09ICdpcGFkJyB8fCBhbmRyb2lkICYmIChvc01ham9yVmVyc2lvbiA9PSAzIHx8IG9zTWFqb3JWZXJzaW9uID09IDQgJiYgIW1vYmlsZSkgfHwgcmVzdWx0LnNpbGspIHtcXG4gICAgICByZXN1bHQudGFibGV0ID0gdDtcXG4gICAgfSBlbHNlIGlmIChtb2JpbGUgfHwgaW9zZGV2aWNlID09ICdpcGhvbmUnIHx8IGlvc2RldmljZSA9PSAnaXBvZCcgfHwgYW5kcm9pZCB8fCByZXN1bHQuYmxhY2tiZXJyeSB8fCByZXN1bHQud2Vib3MgfHwgcmVzdWx0LmJhZGEpIHtcXG4gICAgICByZXN1bHQubW9iaWxlID0gdDtcXG4gICAgfSAvLyBHcmFkZWQgQnJvd3NlciBTdXBwb3J0XFxuICAgIC8vIGh0dHA6Ly9kZXZlbG9wZXIueWFob28uY29tL3l1aS9hcnRpY2xlcy9nYnNcXG5cXG5cXG4gICAgaWYgKHJlc3VsdC5tc2VkZ2UgfHwgcmVzdWx0Lm1zaWUgJiYgcmVzdWx0LnZlcnNpb24gPj0gMTAgfHwgcmVzdWx0LmNocm9tZSAmJiByZXN1bHQudmVyc2lvbiA+PSAyMCB8fCByZXN1bHQuZmlyZWZveCAmJiByZXN1bHQudmVyc2lvbiA+PSAyMC4wIHx8IHJlc3VsdC5zYWZhcmkgJiYgcmVzdWx0LnZlcnNpb24gPj0gNiB8fCByZXN1bHQub3BlcmEgJiYgcmVzdWx0LnZlcnNpb24gPj0gMTAuMCB8fCByZXN1bHQuaW9zICYmIHJlc3VsdC5vc3ZlcnNpb24gJiYgcmVzdWx0Lm9zdmVyc2lvbi5zcGxpdChcXFwiLlxcXCIpWzBdID49IDYgfHwgcmVzdWx0LmJsYWNrYmVycnkgJiYgcmVzdWx0LnZlcnNpb24gPj0gMTAuMSkge1xcbiAgICAgIHJlc3VsdC5hID0gdDtcXG4gICAgfSBlbHNlIGlmIChyZXN1bHQubXNpZSAmJiByZXN1bHQudmVyc2lvbiA8IDEwIHx8IHJlc3VsdC5jaHJvbWUgJiYgcmVzdWx0LnZlcnNpb24gPCAyMCB8fCByZXN1bHQuZmlyZWZveCAmJiByZXN1bHQudmVyc2lvbiA8IDIwLjAgfHwgcmVzdWx0LnNhZmFyaSAmJiByZXN1bHQudmVyc2lvbiA8IDYgfHwgcmVzdWx0Lm9wZXJhICYmIHJlc3VsdC52ZXJzaW9uIDwgMTAuMCB8fCByZXN1bHQuaW9zICYmIHJlc3VsdC5vc3ZlcnNpb24gJiYgcmVzdWx0Lm9zdmVyc2lvbi5zcGxpdChcXFwiLlxcXCIpWzBdIDwgNikge1xcbiAgICAgIHJlc3VsdC5jID0gdDtcXG4gICAgfSBlbHNlIHJlc3VsdC54ID0gdDtcXG5cXG4gICAgcmV0dXJuIHJlc3VsdDtcXG4gIH1cXG5cXG4gIHZhciBib3dzZXIgPSBkZXRlY3QodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgPyBuYXZpZ2F0b3IudXNlckFnZW50IDogJycpO1xcblxcbiAgYm93c2VyLnRlc3QgPSBmdW5jdGlvbiAoYnJvd3Nlckxpc3QpIHtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBicm93c2VyTGlzdC5sZW5ndGg7ICsraSkge1xcbiAgICAgIHZhciBicm93c2VySXRlbSA9IGJyb3dzZXJMaXN0W2ldO1xcblxcbiAgICAgIGlmICh0eXBlb2YgYnJvd3Nlckl0ZW0gPT09ICdzdHJpbmcnKSB7XFxuICAgICAgICBpZiAoYnJvd3Nlckl0ZW0gaW4gYm93c2VyKSB7XFxuICAgICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICByZXR1cm4gZmFsc2U7XFxuICB9O1xcbiAgLypcXG4gICAqIFNldCBvdXIgZGV0ZWN0IG1ldGhvZCB0byB0aGUgbWFpbiBib3dzZXIgb2JqZWN0IHNvIHdlIGNhblxcbiAgICogcmV1c2UgaXQgdG8gdGVzdCBvdGhlciB1c2VyIGFnZW50cy5cXG4gICAqIFRoaXMgaXMgbmVlZGVkIHRvIGltcGxlbWVudCBmdXR1cmUgdGVzdHMuXFxuICAgKi9cXG5cXG5cXG4gIGJvd3Nlci5fZGV0ZWN0ID0gZGV0ZWN0O1xcbiAgcmV0dXJuIGJvd3NlcjtcXG59KTtcIiIsIm1vZHVsZS5leHBvcnRzID0gXCJmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcXFwic3ltYm9sXFxcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXFxcInN5bWJvbFxcXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cXG5cXG4vKiFcXG4gKiBqUXVlcnkgSmF2YVNjcmlwdCBMaWJyYXJ5IHYyLjEuNFxcbiAqIGh0dHA6Ly9qcXVlcnkuY29tL1xcbiAqXFxuICogSW5jbHVkZXMgU2l6emxlLmpzXFxuICogaHR0cDovL3NpenpsZWpzLmNvbS9cXG4gKlxcbiAqIENvcHlyaWdodCAyMDA1LCAyMDE0IGpRdWVyeSBGb3VuZGF0aW9uLCBJbmMuIGFuZCBvdGhlciBjb250cmlidXRvcnNcXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXFxuICpcXG4gKiBEYXRlOiAyMDE1LTA0LTI4VDE2OjAxWlxcbiAqL1xcbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XFxuICBpZiAoKHR5cGVvZiBtb2R1bGUgPT09IFxcXCJ1bmRlZmluZWRcXFwiID8gXFxcInVuZGVmaW5lZFxcXCIgOiBfdHlwZW9mKG1vZHVsZSkpID09PSBcXFwib2JqZWN0XFxcIiAmJiBfdHlwZW9mKG1vZHVsZS5leHBvcnRzKSA9PT0gXFxcIm9iamVjdFxcXCIpIHtcXG4gICAgLy8gRm9yIENvbW1vbkpTIGFuZCBDb21tb25KUy1saWtlIGVudmlyb25tZW50cyB3aGVyZSBhIHByb3BlciBgd2luZG93YFxcbiAgICAvLyBpcyBwcmVzZW50LCBleGVjdXRlIHRoZSBmYWN0b3J5IGFuZCBnZXQgalF1ZXJ5LlxcbiAgICAvLyBGb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IGhhdmUgYSBgd2luZG93YCB3aXRoIGEgYGRvY3VtZW50YFxcbiAgICAvLyAoc3VjaCBhcyBOb2RlLmpzKSwgZXhwb3NlIGEgZmFjdG9yeSBhcyBtb2R1bGUuZXhwb3J0cy5cXG4gICAgLy8gVGhpcyBhY2NlbnR1YXRlcyB0aGUgbmVlZCBmb3IgdGhlIGNyZWF0aW9uIG9mIGEgcmVhbCBgd2luZG93YC5cXG4gICAgLy8gZS5nLiB2YXIgalF1ZXJ5ID0gcmVxdWlyZShcXFwianF1ZXJ5XFxcIikod2luZG93KTtcXG4gICAgLy8gU2VlIHRpY2tldCAjMTQ1NDkgZm9yIG1vcmUgaW5mby5cXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuZG9jdW1lbnQgPyBmYWN0b3J5KGdsb2JhbCwgdHJ1ZSkgOiBmdW5jdGlvbiAodykge1xcbiAgICAgIGlmICghdy5kb2N1bWVudCkge1xcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXCJqUXVlcnkgcmVxdWlyZXMgYSB3aW5kb3cgd2l0aCBhIGRvY3VtZW50XFxcIik7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBmYWN0b3J5KHcpO1xcbiAgICB9O1xcbiAgfSBlbHNlIHtcXG4gICAgZmFjdG9yeShnbG9iYWwpO1xcbiAgfSAvLyBQYXNzIHRoaXMgaWYgd2luZG93IGlzIG5vdCBkZWZpbmVkIHlldFxcblxcbn0pKHR5cGVvZiB3aW5kb3cgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gd2luZG93IDogdGhpcywgZnVuY3Rpb24gKHdpbmRvdywgbm9HbG9iYWwpIHtcXG4gIC8vIFN1cHBvcnQ6IEZpcmVmb3ggMTgrXFxuICAvLyBDYW4ndCBiZSBpbiBzdHJpY3QgbW9kZSwgc2V2ZXJhbCBsaWJzIGluY2x1ZGluZyBBU1AuTkVUIHRyYWNlXFxuICAvLyB0aGUgc3RhY2sgdmlhIGFyZ3VtZW50cy5jYWxsZXIuY2FsbGVlIGFuZCBGaXJlZm94IGRpZXMgaWZcXG4gIC8vIHlvdSB0cnkgdG8gdHJhY2UgdGhyb3VnaCBcXFwidXNlIHN0cmljdFxcXCIgY2FsbCBjaGFpbnMuICgjMTMzMzUpXFxuICAvL1xcbiAgdmFyIGFyciA9IFtdO1xcbiAgdmFyIF9zbGljZSA9IGFyci5zbGljZTtcXG4gIHZhciBjb25jYXQgPSBhcnIuY29uY2F0O1xcbiAgdmFyIHB1c2ggPSBhcnIucHVzaDtcXG4gIHZhciBpbmRleE9mID0gYXJyLmluZGV4T2Y7XFxuICB2YXIgY2xhc3MydHlwZSA9IHt9O1xcbiAgdmFyIHRvU3RyaW5nID0gY2xhc3MydHlwZS50b1N0cmluZztcXG4gIHZhciBoYXNPd24gPSBjbGFzczJ0eXBlLmhhc093blByb3BlcnR5O1xcbiAgdmFyIHN1cHBvcnQgPSB7fTtcXG5cXG4gIHZhciAvLyBVc2UgdGhlIGNvcnJlY3QgZG9jdW1lbnQgYWNjb3JkaW5nbHkgd2l0aCB3aW5kb3cgYXJndW1lbnQgKHNhbmRib3gpXFxuICBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudCxcXG4gICAgICB2ZXJzaW9uID0gXFxcIjIuMS40XFxcIixcXG4gICAgICAvLyBEZWZpbmUgYSBsb2NhbCBjb3B5IG9mIGpRdWVyeVxcbiAgalF1ZXJ5ID0gZnVuY3Rpb24galF1ZXJ5KHNlbGVjdG9yLCBjb250ZXh0KSB7XFxuICAgIC8vIFRoZSBqUXVlcnkgb2JqZWN0IGlzIGFjdHVhbGx5IGp1c3QgdGhlIGluaXQgY29uc3RydWN0b3IgJ2VuaGFuY2VkJ1xcbiAgICAvLyBOZWVkIGluaXQgaWYgalF1ZXJ5IGlzIGNhbGxlZCAoanVzdCBhbGxvdyBlcnJvciB0byBiZSB0aHJvd24gaWYgbm90IGluY2x1ZGVkKVxcbiAgICByZXR1cm4gbmV3IGpRdWVyeS5mbi5pbml0KHNlbGVjdG9yLCBjb250ZXh0KTtcXG4gIH0sXFxuICAgICAgLy8gU3VwcG9ydDogQW5kcm9pZDw0LjFcXG4gIC8vIE1ha2Ugc3VyZSB3ZSB0cmltIEJPTSBhbmQgTkJTUFxcbiAgcnRyaW0gPSAvXltcXFxcc1xcXFx1RkVGRlxcXFx4QTBdK3xbXFxcXHNcXFxcdUZFRkZcXFxceEEwXSskL2csXFxuICAgICAgLy8gTWF0Y2hlcyBkYXNoZWQgc3RyaW5nIGZvciBjYW1lbGl6aW5nXFxuICBybXNQcmVmaXggPSAvXi1tcy0vLFxcbiAgICAgIHJkYXNoQWxwaGEgPSAvLShbXFxcXGRhLXpdKS9naSxcXG4gICAgICAvLyBVc2VkIGJ5IGpRdWVyeS5jYW1lbENhc2UgYXMgY2FsbGJhY2sgdG8gcmVwbGFjZSgpXFxuICBmY2FtZWxDYXNlID0gZnVuY3Rpb24gZmNhbWVsQ2FzZShhbGwsIGxldHRlcikge1xcbiAgICByZXR1cm4gbGV0dGVyLnRvVXBwZXJDYXNlKCk7XFxuICB9O1xcblxcbiAgalF1ZXJ5LmZuID0galF1ZXJ5LnByb3RvdHlwZSA9IHtcXG4gICAgLy8gVGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBqUXVlcnkgYmVpbmcgdXNlZFxcbiAgICBqcXVlcnk6IHZlcnNpb24sXFxuICAgIGNvbnN0cnVjdG9yOiBqUXVlcnksXFxuICAgIC8vIFN0YXJ0IHdpdGggYW4gZW1wdHkgc2VsZWN0b3JcXG4gICAgc2VsZWN0b3I6IFxcXCJcXFwiLFxcbiAgICAvLyBUaGUgZGVmYXVsdCBsZW5ndGggb2YgYSBqUXVlcnkgb2JqZWN0IGlzIDBcXG4gICAgbGVuZ3RoOiAwLFxcbiAgICB0b0FycmF5OiBmdW5jdGlvbiB0b0FycmF5KCkge1xcbiAgICAgIHJldHVybiBfc2xpY2UuY2FsbCh0aGlzKTtcXG4gICAgfSxcXG4gICAgLy8gR2V0IHRoZSBOdGggZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBlbGVtZW50IHNldCBPUlxcbiAgICAvLyBHZXQgdGhlIHdob2xlIG1hdGNoZWQgZWxlbWVudCBzZXQgYXMgYSBjbGVhbiBhcnJheVxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldChudW0pIHtcXG4gICAgICByZXR1cm4gbnVtICE9IG51bGwgPyAvLyBSZXR1cm4ganVzdCB0aGUgb25lIGVsZW1lbnQgZnJvbSB0aGUgc2V0XFxuICAgICAgbnVtIDwgMCA/IHRoaXNbbnVtICsgdGhpcy5sZW5ndGhdIDogdGhpc1tudW1dIDogLy8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgaW4gYSBjbGVhbiBhcnJheVxcbiAgICAgIF9zbGljZS5jYWxsKHRoaXMpO1xcbiAgICB9LFxcbiAgICAvLyBUYWtlIGFuIGFycmF5IG9mIGVsZW1lbnRzIGFuZCBwdXNoIGl0IG9udG8gdGhlIHN0YWNrXFxuICAgIC8vIChyZXR1cm5pbmcgdGhlIG5ldyBtYXRjaGVkIGVsZW1lbnQgc2V0KVxcbiAgICBwdXNoU3RhY2s6IGZ1bmN0aW9uIHB1c2hTdGFjayhlbGVtcykge1xcbiAgICAgIC8vIEJ1aWxkIGEgbmV3IGpRdWVyeSBtYXRjaGVkIGVsZW1lbnQgc2V0XFxuICAgICAgdmFyIHJldCA9IGpRdWVyeS5tZXJnZSh0aGlzLmNvbnN0cnVjdG9yKCksIGVsZW1zKTsgLy8gQWRkIHRoZSBvbGQgb2JqZWN0IG9udG8gdGhlIHN0YWNrIChhcyBhIHJlZmVyZW5jZSlcXG5cXG4gICAgICByZXQucHJldk9iamVjdCA9IHRoaXM7XFxuICAgICAgcmV0LmNvbnRleHQgPSB0aGlzLmNvbnRleHQ7IC8vIFJldHVybiB0aGUgbmV3bHktZm9ybWVkIGVsZW1lbnQgc2V0XFxuXFxuICAgICAgcmV0dXJuIHJldDtcXG4gICAgfSxcXG4gICAgLy8gRXhlY3V0ZSBhIGNhbGxiYWNrIGZvciBldmVyeSBlbGVtZW50IGluIHRoZSBtYXRjaGVkIHNldC5cXG4gICAgLy8gKFlvdSBjYW4gc2VlZCB0aGUgYXJndW1lbnRzIHdpdGggYW4gYXJyYXkgb2YgYXJncywgYnV0IHRoaXMgaXNcXG4gICAgLy8gb25seSB1c2VkIGludGVybmFsbHkuKVxcbiAgICBlYWNoOiBmdW5jdGlvbiBlYWNoKGNhbGxiYWNrLCBhcmdzKSB7XFxuICAgICAgcmV0dXJuIGpRdWVyeS5lYWNoKHRoaXMsIGNhbGxiYWNrLCBhcmdzKTtcXG4gICAgfSxcXG4gICAgbWFwOiBmdW5jdGlvbiBtYXAoY2FsbGJhY2spIHtcXG4gICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soalF1ZXJ5Lm1hcCh0aGlzLCBmdW5jdGlvbiAoZWxlbSwgaSkge1xcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoZWxlbSwgaSwgZWxlbSk7XFxuICAgICAgfSkpO1xcbiAgICB9LFxcbiAgICBzbGljZTogZnVuY3Rpb24gc2xpY2UoKSB7XFxuICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKF9zbGljZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcXG4gICAgfSxcXG4gICAgZmlyc3Q6IGZ1bmN0aW9uIGZpcnN0KCkge1xcbiAgICAgIHJldHVybiB0aGlzLmVxKDApO1xcbiAgICB9LFxcbiAgICBsYXN0OiBmdW5jdGlvbiBsYXN0KCkge1xcbiAgICAgIHJldHVybiB0aGlzLmVxKC0xKTtcXG4gICAgfSxcXG4gICAgZXE6IGZ1bmN0aW9uIGVxKGkpIHtcXG4gICAgICB2YXIgbGVuID0gdGhpcy5sZW5ndGgsXFxuICAgICAgICAgIGogPSAraSArIChpIDwgMCA/IGxlbiA6IDApO1xcbiAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayhqID49IDAgJiYgaiA8IGxlbiA/IFt0aGlzW2pdXSA6IFtdKTtcXG4gICAgfSxcXG4gICAgZW5kOiBmdW5jdGlvbiBlbmQoKSB7XFxuICAgICAgcmV0dXJuIHRoaXMucHJldk9iamVjdCB8fCB0aGlzLmNvbnN0cnVjdG9yKG51bGwpO1xcbiAgICB9LFxcbiAgICAvLyBGb3IgaW50ZXJuYWwgdXNlIG9ubHkuXFxuICAgIC8vIEJlaGF2ZXMgbGlrZSBhbiBBcnJheSdzIG1ldGhvZCwgbm90IGxpa2UgYSBqUXVlcnkgbWV0aG9kLlxcbiAgICBwdXNoOiBwdXNoLFxcbiAgICBzb3J0OiBhcnIuc29ydCxcXG4gICAgc3BsaWNlOiBhcnIuc3BsaWNlXFxuICB9O1xcblxcbiAgalF1ZXJ5LmV4dGVuZCA9IGpRdWVyeS5mbi5leHRlbmQgPSBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciBvcHRpb25zLFxcbiAgICAgICAgbmFtZSxcXG4gICAgICAgIHNyYyxcXG4gICAgICAgIGNvcHksXFxuICAgICAgICBjb3B5SXNBcnJheSxcXG4gICAgICAgIGNsb25lLFxcbiAgICAgICAgdGFyZ2V0ID0gYXJndW1lbnRzWzBdIHx8IHt9LFxcbiAgICAgICAgaSA9IDEsXFxuICAgICAgICBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxcbiAgICAgICAgZGVlcCA9IGZhbHNlOyAvLyBIYW5kbGUgYSBkZWVwIGNvcHkgc2l0dWF0aW9uXFxuXFxuICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSBcXFwiYm9vbGVhblxcXCIpIHtcXG4gICAgICBkZWVwID0gdGFyZ2V0OyAvLyBTa2lwIHRoZSBib29sZWFuIGFuZCB0aGUgdGFyZ2V0XFxuXFxuICAgICAgdGFyZ2V0ID0gYXJndW1lbnRzW2ldIHx8IHt9O1xcbiAgICAgIGkrKztcXG4gICAgfSAvLyBIYW5kbGUgY2FzZSB3aGVuIHRhcmdldCBpcyBhIHN0cmluZyBvciBzb21ldGhpbmcgKHBvc3NpYmxlIGluIGRlZXAgY29weSlcXG5cXG5cXG4gICAgaWYgKF90eXBlb2YodGFyZ2V0KSAhPT0gXFxcIm9iamVjdFxcXCIgJiYgIWpRdWVyeS5pc0Z1bmN0aW9uKHRhcmdldCkpIHtcXG4gICAgICB0YXJnZXQgPSB7fTtcXG4gICAgfSAvLyBFeHRlbmQgalF1ZXJ5IGl0c2VsZiBpZiBvbmx5IG9uZSBhcmd1bWVudCBpcyBwYXNzZWRcXG5cXG5cXG4gICAgaWYgKGkgPT09IGxlbmd0aCkge1xcbiAgICAgIHRhcmdldCA9IHRoaXM7XFxuICAgICAgaS0tO1xcbiAgICB9XFxuXFxuICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcXG4gICAgICAvLyBPbmx5IGRlYWwgd2l0aCBub24tbnVsbC91bmRlZmluZWQgdmFsdWVzXFxuICAgICAgaWYgKChvcHRpb25zID0gYXJndW1lbnRzW2ldKSAhPSBudWxsKSB7XFxuICAgICAgICAvLyBFeHRlbmQgdGhlIGJhc2Ugb2JqZWN0XFxuICAgICAgICBmb3IgKG5hbWUgaW4gb3B0aW9ucykge1xcbiAgICAgICAgICBzcmMgPSB0YXJnZXRbbmFtZV07XFxuICAgICAgICAgIGNvcHkgPSBvcHRpb25zW25hbWVdOyAvLyBQcmV2ZW50IG5ldmVyLWVuZGluZyBsb29wXFxuXFxuICAgICAgICAgIGlmICh0YXJnZXQgPT09IGNvcHkpIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfSAvLyBSZWN1cnNlIGlmIHdlJ3JlIG1lcmdpbmcgcGxhaW4gb2JqZWN0cyBvciBhcnJheXNcXG5cXG5cXG4gICAgICAgICAgaWYgKGRlZXAgJiYgY29weSAmJiAoalF1ZXJ5LmlzUGxhaW5PYmplY3QoY29weSkgfHwgKGNvcHlJc0FycmF5ID0galF1ZXJ5LmlzQXJyYXkoY29weSkpKSkge1xcbiAgICAgICAgICAgIGlmIChjb3B5SXNBcnJheSkge1xcbiAgICAgICAgICAgICAgY29weUlzQXJyYXkgPSBmYWxzZTtcXG4gICAgICAgICAgICAgIGNsb25lID0gc3JjICYmIGpRdWVyeS5pc0FycmF5KHNyYykgPyBzcmMgOiBbXTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgY2xvbmUgPSBzcmMgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3Qoc3JjKSA/IHNyYyA6IHt9O1xcbiAgICAgICAgICAgIH0gLy8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXFxuXFxuXFxuICAgICAgICAgICAgdGFyZ2V0W25hbWVdID0galF1ZXJ5LmV4dGVuZChkZWVwLCBjbG9uZSwgY29weSk7IC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcXG4gICAgICAgICAgfSBlbHNlIGlmIChjb3B5ICE9PSB1bmRlZmluZWQpIHtcXG4gICAgICAgICAgICB0YXJnZXRbbmFtZV0gPSBjb3B5O1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9IC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XFxuXFxuXFxuICAgIHJldHVybiB0YXJnZXQ7XFxuICB9O1xcblxcbiAgalF1ZXJ5LmV4dGVuZCh7XFxuICAgIC8vIFVuaXF1ZSBmb3IgZWFjaCBjb3B5IG9mIGpRdWVyeSBvbiB0aGUgcGFnZVxcbiAgICBleHBhbmRvOiBcXFwialF1ZXJ5XFxcIiArICh2ZXJzaW9uICsgTWF0aC5yYW5kb20oKSkucmVwbGFjZSgvXFxcXEQvZywgXFxcIlxcXCIpLFxcbiAgICAvLyBBc3N1bWUgalF1ZXJ5IGlzIHJlYWR5IHdpdGhvdXQgdGhlIHJlYWR5IG1vZHVsZVxcbiAgICBpc1JlYWR5OiB0cnVlLFxcbiAgICBlcnJvcjogZnVuY3Rpb24gZXJyb3IobXNnKSB7XFxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XFxuICAgIH0sXFxuICAgIG5vb3A6IGZ1bmN0aW9uIG5vb3AoKSB7fSxcXG4gICAgaXNGdW5jdGlvbjogZnVuY3Rpb24gaXNGdW5jdGlvbihvYmopIHtcXG4gICAgICByZXR1cm4galF1ZXJ5LnR5cGUob2JqKSA9PT0gXFxcImZ1bmN0aW9uXFxcIjtcXG4gICAgfSxcXG4gICAgaXNBcnJheTogQXJyYXkuaXNBcnJheSxcXG4gICAgaXNXaW5kb3c6IGZ1bmN0aW9uIGlzV2luZG93KG9iaikge1xcbiAgICAgIHJldHVybiBvYmogIT0gbnVsbCAmJiBvYmogPT09IG9iai53aW5kb3c7XFxuICAgIH0sXFxuICAgIGlzTnVtZXJpYzogZnVuY3Rpb24gaXNOdW1lcmljKG9iaikge1xcbiAgICAgIC8vIHBhcnNlRmxvYXQgTmFOcyBudW1lcmljLWNhc3QgZmFsc2UgcG9zaXRpdmVzIChudWxsfHRydWV8ZmFsc2V8XFxcIlxcXCIpXFxuICAgICAgLy8gLi4uYnV0IG1pc2ludGVycHJldHMgbGVhZGluZy1udW1iZXIgc3RyaW5ncywgcGFydGljdWxhcmx5IGhleCBsaXRlcmFscyAoXFxcIjB4Li4uXFxcIilcXG4gICAgICAvLyBzdWJ0cmFjdGlvbiBmb3JjZXMgaW5maW5pdGllcyB0byBOYU5cXG4gICAgICAvLyBhZGRpbmcgMSBjb3JyZWN0cyBsb3NzIG9mIHByZWNpc2lvbiBmcm9tIHBhcnNlRmxvYXQgKCMxNTEwMClcXG4gICAgICByZXR1cm4gIWpRdWVyeS5pc0FycmF5KG9iaikgJiYgb2JqIC0gcGFyc2VGbG9hdChvYmopICsgMSA+PSAwO1xcbiAgICB9LFxcbiAgICBpc1BsYWluT2JqZWN0OiBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KG9iaikge1xcbiAgICAgIC8vIE5vdCBwbGFpbiBvYmplY3RzOlxcbiAgICAgIC8vIC0gQW55IG9iamVjdCBvciB2YWx1ZSB3aG9zZSBpbnRlcm5hbCBbW0NsYXNzXV0gcHJvcGVydHkgaXMgbm90IFxcXCJbb2JqZWN0IE9iamVjdF1cXFwiXFxuICAgICAgLy8gLSBET00gbm9kZXNcXG4gICAgICAvLyAtIHdpbmRvd1xcbiAgICAgIGlmIChqUXVlcnkudHlwZShvYmopICE9PSBcXFwib2JqZWN0XFxcIiB8fCBvYmoubm9kZVR5cGUgfHwgalF1ZXJ5LmlzV2luZG93KG9iaikpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKG9iai5jb25zdHJ1Y3RvciAmJiAhaGFzT3duLmNhbGwob2JqLmNvbnN0cnVjdG9yLnByb3RvdHlwZSwgXFxcImlzUHJvdG90eXBlT2ZcXFwiKSkge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH0gLy8gSWYgdGhlIGZ1bmN0aW9uIGhhc24ndCByZXR1cm5lZCBhbHJlYWR5LCB3ZSdyZSBjb25maWRlbnQgdGhhdFxcbiAgICAgIC8vIHxvYmp8IGlzIGEgcGxhaW4gb2JqZWN0LCBjcmVhdGVkIGJ5IHt9IG9yIGNvbnN0cnVjdGVkIHdpdGggbmV3IE9iamVjdFxcblxcblxcbiAgICAgIHJldHVybiB0cnVlO1xcbiAgICB9LFxcbiAgICBpc0VtcHR5T2JqZWN0OiBmdW5jdGlvbiBpc0VtcHR5T2JqZWN0KG9iaikge1xcbiAgICAgIHZhciBuYW1lO1xcblxcbiAgICAgIGZvciAobmFtZSBpbiBvYmopIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHRydWU7XFxuICAgIH0sXFxuICAgIHR5cGU6IGZ1bmN0aW9uIHR5cGUob2JqKSB7XFxuICAgICAgaWYgKG9iaiA9PSBudWxsKSB7XFxuICAgICAgICByZXR1cm4gb2JqICsgXFxcIlxcXCI7XFxuICAgICAgfSAvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMCwgaU9TPDYgKGZ1bmN0aW9uaXNoIFJlZ0V4cClcXG5cXG5cXG4gICAgICByZXR1cm4gX3R5cGVvZihvYmopID09PSBcXFwib2JqZWN0XFxcIiB8fCB0eXBlb2Ygb2JqID09PSBcXFwiZnVuY3Rpb25cXFwiID8gY2xhc3MydHlwZVt0b1N0cmluZy5jYWxsKG9iaildIHx8IFxcXCJvYmplY3RcXFwiIDogX3R5cGVvZihvYmopO1xcbiAgICB9LFxcbiAgICAvLyBFdmFsdWF0ZXMgYSBzY3JpcHQgaW4gYSBnbG9iYWwgY29udGV4dFxcbiAgICBnbG9iYWxFdmFsOiBmdW5jdGlvbiBnbG9iYWxFdmFsKGNvZGUpIHtcXG4gICAgICB2YXIgc2NyaXB0LFxcbiAgICAgICAgICBpbmRpcmVjdCA9IGV2YWw7XFxuICAgICAgY29kZSA9IGpRdWVyeS50cmltKGNvZGUpO1xcblxcbiAgICAgIGlmIChjb2RlKSB7XFxuICAgICAgICAvLyBJZiB0aGUgY29kZSBpbmNsdWRlcyBhIHZhbGlkLCBwcm9sb2d1ZSBwb3NpdGlvblxcbiAgICAgICAgLy8gc3RyaWN0IG1vZGUgcHJhZ21hLCBleGVjdXRlIGNvZGUgYnkgaW5qZWN0aW5nIGFcXG4gICAgICAgIC8vIHNjcmlwdCB0YWcgaW50byB0aGUgZG9jdW1lbnQuXFxuICAgICAgICBpZiAoY29kZS5pbmRleE9mKFxcXCJ1c2Ugc3RyaWN0XFxcIikgPT09IDEpIHtcXG4gICAgICAgICAgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwic2NyaXB0XFxcIik7XFxuICAgICAgICAgIHNjcmlwdC50ZXh0ID0gY29kZTtcXG4gICAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIC8vIE90aGVyd2lzZSwgYXZvaWQgdGhlIERPTSBub2RlIGNyZWF0aW9uLCBpbnNlcnRpb25cXG4gICAgICAgICAgLy8gYW5kIHJlbW92YWwgYnkgdXNpbmcgYW4gaW5kaXJlY3QgZ2xvYmFsIGV2YWxcXG4gICAgICAgICAgaW5kaXJlY3QoY29kZSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9LFxcbiAgICAvLyBDb252ZXJ0IGRhc2hlZCB0byBjYW1lbENhc2U7IHVzZWQgYnkgdGhlIGNzcyBhbmQgZGF0YSBtb2R1bGVzXFxuICAgIC8vIFN1cHBvcnQ6IElFOS0xMStcXG4gICAgLy8gTWljcm9zb2Z0IGZvcmdvdCB0byBodW1wIHRoZWlyIHZlbmRvciBwcmVmaXggKCM5NTcyKVxcbiAgICBjYW1lbENhc2U6IGZ1bmN0aW9uIGNhbWVsQ2FzZShzdHJpbmcpIHtcXG4gICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2Uocm1zUHJlZml4LCBcXFwibXMtXFxcIikucmVwbGFjZShyZGFzaEFscGhhLCBmY2FtZWxDYXNlKTtcXG4gICAgfSxcXG4gICAgbm9kZU5hbWU6IGZ1bmN0aW9uIG5vZGVOYW1lKGVsZW0sIG5hbWUpIHtcXG4gICAgICByZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUudG9Mb3dlckNhc2UoKTtcXG4gICAgfSxcXG4gICAgLy8gYXJncyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxcbiAgICBlYWNoOiBmdW5jdGlvbiBlYWNoKG9iaiwgY2FsbGJhY2ssIGFyZ3MpIHtcXG4gICAgICB2YXIgdmFsdWUsXFxuICAgICAgICAgIGkgPSAwLFxcbiAgICAgICAgICBsZW5ndGggPSBvYmoubGVuZ3RoLFxcbiAgICAgICAgICBpc0FycmF5ID0gaXNBcnJheWxpa2Uob2JqKTtcXG5cXG4gICAgICBpZiAoYXJncykge1xcbiAgICAgICAgaWYgKGlzQXJyYXkpIHtcXG4gICAgICAgICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xcbiAgICAgICAgICAgIHZhbHVlID0gY2FsbGJhY2suYXBwbHkob2JqW2ldLCBhcmdzKTtcXG5cXG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IGZhbHNlKSB7XFxuICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGZvciAoaSBpbiBvYmopIHtcXG4gICAgICAgICAgICB2YWx1ZSA9IGNhbGxiYWNrLmFwcGx5KG9ialtpXSwgYXJncyk7XFxuXFxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBmYWxzZSkge1xcbiAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9IC8vIEEgc3BlY2lhbCwgZmFzdCwgY2FzZSBmb3IgdGhlIG1vc3QgY29tbW9uIHVzZSBvZiBlYWNoXFxuXFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGlmIChpc0FycmF5KSB7XFxuICAgICAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgICB2YWx1ZSA9IGNhbGxiYWNrLmNhbGwob2JqW2ldLCBpLCBvYmpbaV0pO1xcblxcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcXG4gICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgZm9yIChpIGluIG9iaikge1xcbiAgICAgICAgICAgIHZhbHVlID0gY2FsbGJhY2suY2FsbChvYmpbaV0sIGksIG9ialtpXSk7XFxuXFxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBmYWxzZSkge1xcbiAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBvYmo7XFxuICAgIH0sXFxuICAgIC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4xXFxuICAgIHRyaW06IGZ1bmN0aW9uIHRyaW0odGV4dCkge1xcbiAgICAgIHJldHVybiB0ZXh0ID09IG51bGwgPyBcXFwiXFxcIiA6ICh0ZXh0ICsgXFxcIlxcXCIpLnJlcGxhY2UocnRyaW0sIFxcXCJcXFwiKTtcXG4gICAgfSxcXG4gICAgLy8gcmVzdWx0cyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxcbiAgICBtYWtlQXJyYXk6IGZ1bmN0aW9uIG1ha2VBcnJheShhcnIsIHJlc3VsdHMpIHtcXG4gICAgICB2YXIgcmV0ID0gcmVzdWx0cyB8fCBbXTtcXG5cXG4gICAgICBpZiAoYXJyICE9IG51bGwpIHtcXG4gICAgICAgIGlmIChpc0FycmF5bGlrZShPYmplY3QoYXJyKSkpIHtcXG4gICAgICAgICAgalF1ZXJ5Lm1lcmdlKHJldCwgdHlwZW9mIGFyciA9PT0gXFxcInN0cmluZ1xcXCIgPyBbYXJyXSA6IGFycik7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBwdXNoLmNhbGwocmV0LCBhcnIpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gcmV0O1xcbiAgICB9LFxcbiAgICBpbkFycmF5OiBmdW5jdGlvbiBpbkFycmF5KGVsZW0sIGFyciwgaSkge1xcbiAgICAgIHJldHVybiBhcnIgPT0gbnVsbCA/IC0xIDogaW5kZXhPZi5jYWxsKGFyciwgZWxlbSwgaSk7XFxuICAgIH0sXFxuICAgIG1lcmdlOiBmdW5jdGlvbiBtZXJnZShmaXJzdCwgc2Vjb25kKSB7XFxuICAgICAgdmFyIGxlbiA9ICtzZWNvbmQubGVuZ3RoLFxcbiAgICAgICAgICBqID0gMCxcXG4gICAgICAgICAgaSA9IGZpcnN0Lmxlbmd0aDtcXG5cXG4gICAgICBmb3IgKDsgaiA8IGxlbjsgaisrKSB7XFxuICAgICAgICBmaXJzdFtpKytdID0gc2Vjb25kW2pdO1xcbiAgICAgIH1cXG5cXG4gICAgICBmaXJzdC5sZW5ndGggPSBpO1xcbiAgICAgIHJldHVybiBmaXJzdDtcXG4gICAgfSxcXG4gICAgZ3JlcDogZnVuY3Rpb24gZ3JlcChlbGVtcywgY2FsbGJhY2ssIGludmVydCkge1xcbiAgICAgIHZhciBjYWxsYmFja0ludmVyc2UsXFxuICAgICAgICAgIG1hdGNoZXMgPSBbXSxcXG4gICAgICAgICAgaSA9IDAsXFxuICAgICAgICAgIGxlbmd0aCA9IGVsZW1zLmxlbmd0aCxcXG4gICAgICAgICAgY2FsbGJhY2tFeHBlY3QgPSAhaW52ZXJ0OyAvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgb25seSBzYXZpbmcgdGhlIGl0ZW1zXFxuICAgICAgLy8gdGhhdCBwYXNzIHRoZSB2YWxpZGF0b3IgZnVuY3Rpb25cXG5cXG4gICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XFxuICAgICAgICBjYWxsYmFja0ludmVyc2UgPSAhY2FsbGJhY2soZWxlbXNbaV0sIGkpO1xcblxcbiAgICAgICAgaWYgKGNhbGxiYWNrSW52ZXJzZSAhPT0gY2FsbGJhY2tFeHBlY3QpIHtcXG4gICAgICAgICAgbWF0Y2hlcy5wdXNoKGVsZW1zW2ldKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIG1hdGNoZXM7XFxuICAgIH0sXFxuICAgIC8vIGFyZyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxcbiAgICBtYXA6IGZ1bmN0aW9uIG1hcChlbGVtcywgY2FsbGJhY2ssIGFyZykge1xcbiAgICAgIHZhciB2YWx1ZSxcXG4gICAgICAgICAgaSA9IDAsXFxuICAgICAgICAgIGxlbmd0aCA9IGVsZW1zLmxlbmd0aCxcXG4gICAgICAgICAgaXNBcnJheSA9IGlzQXJyYXlsaWtlKGVsZW1zKSxcXG4gICAgICAgICAgcmV0ID0gW107IC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCB0cmFuc2xhdGluZyBlYWNoIG9mIHRoZSBpdGVtcyB0byB0aGVpciBuZXcgdmFsdWVzXFxuXFxuICAgICAgaWYgKGlzQXJyYXkpIHtcXG4gICAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgdmFsdWUgPSBjYWxsYmFjayhlbGVtc1tpXSwgaSwgYXJnKTtcXG5cXG4gICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcXG4gICAgICAgICAgICByZXQucHVzaCh2YWx1ZSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gLy8gR28gdGhyb3VnaCBldmVyeSBrZXkgb24gdGhlIG9iamVjdCxcXG5cXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgZm9yIChpIGluIGVsZW1zKSB7XFxuICAgICAgICAgIHZhbHVlID0gY2FsbGJhY2soZWxlbXNbaV0sIGksIGFyZyk7XFxuXFxuICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XFxuICAgICAgICAgICAgcmV0LnB1c2godmFsdWUpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfSAvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXFxuXFxuXFxuICAgICAgcmV0dXJuIGNvbmNhdC5hcHBseShbXSwgcmV0KTtcXG4gICAgfSxcXG4gICAgLy8gQSBnbG9iYWwgR1VJRCBjb3VudGVyIGZvciBvYmplY3RzXFxuICAgIGd1aWQ6IDEsXFxuICAgIC8vIEJpbmQgYSBmdW5jdGlvbiB0byBhIGNvbnRleHQsIG9wdGlvbmFsbHkgcGFydGlhbGx5IGFwcGx5aW5nIGFueVxcbiAgICAvLyBhcmd1bWVudHMuXFxuICAgIHByb3h5OiBmdW5jdGlvbiBwcm94eShmbiwgY29udGV4dCkge1xcbiAgICAgIHZhciB0bXAsIGFyZ3MsIHByb3h5O1xcblxcbiAgICAgIGlmICh0eXBlb2YgY29udGV4dCA9PT0gXFxcInN0cmluZ1xcXCIpIHtcXG4gICAgICAgIHRtcCA9IGZuW2NvbnRleHRdO1xcbiAgICAgICAgY29udGV4dCA9IGZuO1xcbiAgICAgICAgZm4gPSB0bXA7XFxuICAgICAgfSAvLyBRdWljayBjaGVjayB0byBkZXRlcm1pbmUgaWYgdGFyZ2V0IGlzIGNhbGxhYmxlLCBpbiB0aGUgc3BlY1xcbiAgICAgIC8vIHRoaXMgdGhyb3dzIGEgVHlwZUVycm9yLCBidXQgd2Ugd2lsbCBqdXN0IHJldHVybiB1bmRlZmluZWQuXFxuXFxuXFxuICAgICAgaWYgKCFqUXVlcnkuaXNGdW5jdGlvbihmbikpIHtcXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XFxuICAgICAgfSAvLyBTaW11bGF0ZWQgYmluZFxcblxcblxcbiAgICAgIGFyZ3MgPSBfc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xcblxcbiAgICAgIHByb3h5ID0gZnVuY3Rpb24gcHJveHkoKSB7XFxuICAgICAgICByZXR1cm4gZm4uYXBwbHkoY29udGV4dCB8fCB0aGlzLCBhcmdzLmNvbmNhdChfc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XFxuICAgICAgfTsgLy8gU2V0IHRoZSBndWlkIG9mIHVuaXF1ZSBoYW5kbGVyIHRvIHRoZSBzYW1lIG9mIG9yaWdpbmFsIGhhbmRsZXIsIHNvIGl0IGNhbiBiZSByZW1vdmVkXFxuXFxuXFxuICAgICAgcHJveHkuZ3VpZCA9IGZuLmd1aWQgPSBmbi5ndWlkIHx8IGpRdWVyeS5ndWlkKys7XFxuICAgICAgcmV0dXJuIHByb3h5O1xcbiAgICB9LFxcbiAgICBub3c6IERhdGUubm93LFxcbiAgICAvLyBqUXVlcnkuc3VwcG9ydCBpcyBub3QgdXNlZCBpbiBDb3JlIGJ1dCBvdGhlciBwcm9qZWN0cyBhdHRhY2ggdGhlaXJcXG4gICAgLy8gcHJvcGVydGllcyB0byBpdCBzbyBpdCBuZWVkcyB0byBleGlzdC5cXG4gICAgc3VwcG9ydDogc3VwcG9ydFxcbiAgfSk7IC8vIFBvcHVsYXRlIHRoZSBjbGFzczJ0eXBlIG1hcFxcblxcbiAgalF1ZXJ5LmVhY2goXFxcIkJvb2xlYW4gTnVtYmVyIFN0cmluZyBGdW5jdGlvbiBBcnJheSBEYXRlIFJlZ0V4cCBPYmplY3QgRXJyb3JcXFwiLnNwbGl0KFxcXCIgXFxcIiksIGZ1bmN0aW9uIChpLCBuYW1lKSB7XFxuICAgIGNsYXNzMnR5cGVbXFxcIltvYmplY3QgXFxcIiArIG5hbWUgKyBcXFwiXVxcXCJdID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xcbiAgfSk7XFxuXFxuICBmdW5jdGlvbiBpc0FycmF5bGlrZShvYmopIHtcXG4gICAgLy8gU3VwcG9ydDogaU9TIDguMiAobm90IHJlcHJvZHVjaWJsZSBpbiBzaW11bGF0b3IpXFxuICAgIC8vIGBpbmAgY2hlY2sgdXNlZCB0byBwcmV2ZW50IEpJVCBlcnJvciAoZ2gtMjE0NSlcXG4gICAgLy8gaGFzT3duIGlzbid0IHVzZWQgaGVyZSBkdWUgdG8gZmFsc2UgbmVnYXRpdmVzXFxuICAgIC8vIHJlZ2FyZGluZyBOb2RlbGlzdCBsZW5ndGggaW4gSUVcXG4gICAgdmFyIGxlbmd0aCA9IFxcXCJsZW5ndGhcXFwiIGluIG9iaiAmJiBvYmoubGVuZ3RoLFxcbiAgICAgICAgdHlwZSA9IGpRdWVyeS50eXBlKG9iaik7XFxuXFxuICAgIGlmICh0eXBlID09PSBcXFwiZnVuY3Rpb25cXFwiIHx8IGpRdWVyeS5pc1dpbmRvdyhvYmopKSB7XFxuICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9XFxuXFxuICAgIGlmIChvYmoubm9kZVR5cGUgPT09IDEgJiYgbGVuZ3RoKSB7XFxuICAgICAgcmV0dXJuIHRydWU7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHR5cGUgPT09IFxcXCJhcnJheVxcXCIgfHwgbGVuZ3RoID09PSAwIHx8IHR5cGVvZiBsZW5ndGggPT09IFxcXCJudW1iZXJcXFwiICYmIGxlbmd0aCA+IDAgJiYgbGVuZ3RoIC0gMSBpbiBvYmo7XFxuICB9XFxuXFxuICB2YXIgU2l6emxlID1cXG4gIC8qIVxcbiAgICogU2l6emxlIENTUyBTZWxlY3RvciBFbmdpbmUgdjIuMi4wLXByZVxcbiAgICogaHR0cDovL3NpenpsZWpzLmNvbS9cXG4gICAqXFxuICAgKiBDb3B5cmlnaHQgMjAwOCwgMjAxNCBqUXVlcnkgRm91bmRhdGlvbiwgSW5jLiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXFxuICAgKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcXG4gICAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcXG4gICAqXFxuICAgKiBEYXRlOiAyMDE0LTEyLTE2XFxuICAgKi9cXG4gIGZ1bmN0aW9uICh3aW5kb3cpIHtcXG4gICAgdmFyIGksXFxuICAgICAgICBzdXBwb3J0LFxcbiAgICAgICAgRXhwcixcXG4gICAgICAgIGdldFRleHQsXFxuICAgICAgICBpc1hNTCxcXG4gICAgICAgIHRva2VuaXplLFxcbiAgICAgICAgY29tcGlsZSxcXG4gICAgICAgIHNlbGVjdCxcXG4gICAgICAgIG91dGVybW9zdENvbnRleHQsXFxuICAgICAgICBzb3J0SW5wdXQsXFxuICAgICAgICBoYXNEdXBsaWNhdGUsXFxuICAgICAgICAvLyBMb2NhbCBkb2N1bWVudCB2YXJzXFxuICAgIHNldERvY3VtZW50LFxcbiAgICAgICAgZG9jdW1lbnQsXFxuICAgICAgICBkb2NFbGVtLFxcbiAgICAgICAgZG9jdW1lbnRJc0hUTUwsXFxuICAgICAgICByYnVnZ3lRU0EsXFxuICAgICAgICByYnVnZ3lNYXRjaGVzLFxcbiAgICAgICAgbWF0Y2hlcyxcXG4gICAgICAgIGNvbnRhaW5zLFxcbiAgICAgICAgLy8gSW5zdGFuY2Utc3BlY2lmaWMgZGF0YVxcbiAgICBleHBhbmRvID0gXFxcInNpenpsZVxcXCIgKyAxICogbmV3IERhdGUoKSxcXG4gICAgICAgIHByZWZlcnJlZERvYyA9IHdpbmRvdy5kb2N1bWVudCxcXG4gICAgICAgIGRpcnJ1bnMgPSAwLFxcbiAgICAgICAgZG9uZSA9IDAsXFxuICAgICAgICBjbGFzc0NhY2hlID0gY3JlYXRlQ2FjaGUoKSxcXG4gICAgICAgIHRva2VuQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxcbiAgICAgICAgY29tcGlsZXJDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXFxuICAgICAgICBzb3J0T3JkZXIgPSBmdW5jdGlvbiBzb3J0T3JkZXIoYSwgYikge1xcbiAgICAgIGlmIChhID09PSBiKSB7XFxuICAgICAgICBoYXNEdXBsaWNhdGUgPSB0cnVlO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gMDtcXG4gICAgfSxcXG4gICAgICAgIC8vIEdlbmVyYWwtcHVycG9zZSBjb25zdGFudHNcXG4gICAgTUFYX05FR0FUSVZFID0gMSA8PCAzMSxcXG4gICAgICAgIC8vIEluc3RhbmNlIG1ldGhvZHNcXG4gICAgaGFzT3duID0ge30uaGFzT3duUHJvcGVydHksXFxuICAgICAgICBhcnIgPSBbXSxcXG4gICAgICAgIHBvcCA9IGFyci5wb3AsXFxuICAgICAgICBwdXNoX25hdGl2ZSA9IGFyci5wdXNoLFxcbiAgICAgICAgcHVzaCA9IGFyci5wdXNoLFxcbiAgICAgICAgc2xpY2UgPSBhcnIuc2xpY2UsXFxuICAgICAgICAvLyBVc2UgYSBzdHJpcHBlZC1kb3duIGluZGV4T2YgYXMgaXQncyBmYXN0ZXIgdGhhbiBuYXRpdmVcXG4gICAgLy8gaHR0cDovL2pzcGVyZi5jb20vdGhvci1pbmRleG9mLXZzLWZvci81XFxuICAgIGluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mKGxpc3QsIGVsZW0pIHtcXG4gICAgICB2YXIgaSA9IDAsXFxuICAgICAgICAgIGxlbiA9IGxpc3QubGVuZ3RoO1xcblxcbiAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcXG4gICAgICAgIGlmIChsaXN0W2ldID09PSBlbGVtKSB7XFxuICAgICAgICAgIHJldHVybiBpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gLTE7XFxuICAgIH0sXFxuICAgICAgICBib29sZWFucyA9IFxcXCJjaGVja2VkfHNlbGVjdGVkfGFzeW5jfGF1dG9mb2N1c3xhdXRvcGxheXxjb250cm9sc3xkZWZlcnxkaXNhYmxlZHxoaWRkZW58aXNtYXB8bG9vcHxtdWx0aXBsZXxvcGVufHJlYWRvbmx5fHJlcXVpcmVkfHNjb3BlZFxcXCIsXFxuICAgICAgICAvLyBSZWd1bGFyIGV4cHJlc3Npb25zXFxuICAgIC8vIFdoaXRlc3BhY2UgY2hhcmFjdGVycyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXNlbGVjdG9ycy8jd2hpdGVzcGFjZVxcbiAgICB3aGl0ZXNwYWNlID0gXFxcIltcXFxcXFxcXHgyMFxcXFxcXFxcdFxcXFxcXFxcclxcXFxcXFxcblxcXFxcXFxcZl1cXFwiLFxcbiAgICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1zeW50YXgvI2NoYXJhY3RlcnNcXG4gICAgY2hhcmFjdGVyRW5jb2RpbmcgPSBcXFwiKD86XFxcXFxcXFxcXFxcXFxcXC58W1xcXFxcXFxcdy1dfFteXFxcXFxcXFx4MDAtXFxcXFxcXFx4YTBdKStcXFwiLFxcbiAgICAgICAgLy8gTG9vc2VseSBtb2RlbGVkIG9uIENTUyBpZGVudGlmaWVyIGNoYXJhY3RlcnNcXG4gICAgLy8gQW4gdW5xdW90ZWQgdmFsdWUgc2hvdWxkIGJlIGEgQ1NTIGlkZW50aWZpZXIgaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1zZWxlY3RvcnMvI2F0dHJpYnV0ZS1zZWxlY3RvcnNcXG4gICAgLy8gUHJvcGVyIHN5bnRheDogaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI3ZhbHVlLWRlZi1pZGVudGlmaWVyXFxuICAgIGlkZW50aWZpZXIgPSBjaGFyYWN0ZXJFbmNvZGluZy5yZXBsYWNlKFxcXCJ3XFxcIiwgXFxcIncjXFxcIiksXFxuICAgICAgICAvLyBBdHRyaWJ1dGUgc2VsZWN0b3JzOiBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2F0dHJpYnV0ZS1zZWxlY3RvcnNcXG4gICAgYXR0cmlidXRlcyA9IFxcXCJcXFxcXFxcXFtcXFwiICsgd2hpdGVzcGFjZSArIFxcXCIqKFxcXCIgKyBjaGFyYWN0ZXJFbmNvZGluZyArIFxcXCIpKD86XFxcIiArIHdoaXRlc3BhY2UgKyAvLyBPcGVyYXRvciAoY2FwdHVyZSAyKVxcbiAgICBcXFwiKihbKl4kfCF+XT89KVxcXCIgKyB3aGl0ZXNwYWNlICsgLy8gXFxcIkF0dHJpYnV0ZSB2YWx1ZXMgbXVzdCBiZSBDU1MgaWRlbnRpZmllcnMgW2NhcHR1cmUgNV0gb3Igc3RyaW5ncyBbY2FwdHVyZSAzIG9yIGNhcHR1cmUgNF1cXFwiXFxuICAgIFxcXCIqKD86JygoPzpcXFxcXFxcXFxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcXFxcXFwnXSkqKSd8XFxcXFxcXCIoKD86XFxcXFxcXFxcXFxcXFxcXC58W15cXFxcXFxcXFxcXFxcXFxcXFxcXFxcXCJdKSopXFxcXFxcXCJ8KFxcXCIgKyBpZGVudGlmaWVyICsgXFxcIikpfClcXFwiICsgd2hpdGVzcGFjZSArIFxcXCIqXFxcXFxcXFxdXFxcIixcXG4gICAgICAgIHBzZXVkb3MgPSBcXFwiOihcXFwiICsgY2hhcmFjdGVyRW5jb2RpbmcgKyBcXFwiKSg/OlxcXFxcXFxcKChcXFwiICsgLy8gVG8gcmVkdWNlIHRoZSBudW1iZXIgb2Ygc2VsZWN0b3JzIG5lZWRpbmcgdG9rZW5pemUgaW4gdGhlIHByZUZpbHRlciwgcHJlZmVyIGFyZ3VtZW50czpcXG4gICAgLy8gMS4gcXVvdGVkIChjYXB0dXJlIDM7IGNhcHR1cmUgNCBvciBjYXB0dXJlIDUpXFxuICAgIFxcXCIoJygoPzpcXFxcXFxcXFxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcXFxcXFwnXSkqKSd8XFxcXFxcXCIoKD86XFxcXFxcXFxcXFxcXFxcXC58W15cXFxcXFxcXFxcXFxcXFxcXFxcXFxcXCJdKSopXFxcXFxcXCIpfFxcXCIgKyAvLyAyLiBzaW1wbGUgKGNhcHR1cmUgNilcXG4gICAgXFxcIigoPzpcXFxcXFxcXFxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcXFxcXFwoKVtcXFxcXFxcXF1dfFxcXCIgKyBhdHRyaWJ1dGVzICsgXFxcIikqKXxcXFwiICsgLy8gMy4gYW55dGhpbmcgZWxzZSAoY2FwdHVyZSAyKVxcbiAgICBcXFwiLipcXFwiICsgXFxcIilcXFxcXFxcXCl8KVxcXCIsXFxuICAgICAgICAvLyBMZWFkaW5nIGFuZCBub24tZXNjYXBlZCB0cmFpbGluZyB3aGl0ZXNwYWNlLCBjYXB0dXJpbmcgc29tZSBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXJzIHByZWNlZGluZyB0aGUgbGF0dGVyXFxuICAgIHJ3aGl0ZXNwYWNlID0gbmV3IFJlZ0V4cCh3aGl0ZXNwYWNlICsgXFxcIitcXFwiLCBcXFwiZ1xcXCIpLFxcbiAgICAgICAgcnRyaW0gPSBuZXcgUmVnRXhwKFxcXCJeXFxcIiArIHdoaXRlc3BhY2UgKyBcXFwiK3woKD86XnxbXlxcXFxcXFxcXFxcXFxcXFxdKSg/OlxcXFxcXFxcXFxcXFxcXFwuKSopXFxcIiArIHdoaXRlc3BhY2UgKyBcXFwiKyRcXFwiLCBcXFwiZ1xcXCIpLFxcbiAgICAgICAgcmNvbW1hID0gbmV3IFJlZ0V4cChcXFwiXlxcXCIgKyB3aGl0ZXNwYWNlICsgXFxcIiosXFxcIiArIHdoaXRlc3BhY2UgKyBcXFwiKlxcXCIpLFxcbiAgICAgICAgcmNvbWJpbmF0b3JzID0gbmV3IFJlZ0V4cChcXFwiXlxcXCIgKyB3aGl0ZXNwYWNlICsgXFxcIiooWz4rfl18XFxcIiArIHdoaXRlc3BhY2UgKyBcXFwiKVxcXCIgKyB3aGl0ZXNwYWNlICsgXFxcIipcXFwiKSxcXG4gICAgICAgIHJhdHRyaWJ1dGVRdW90ZXMgPSBuZXcgUmVnRXhwKFxcXCI9XFxcIiArIHdoaXRlc3BhY2UgKyBcXFwiKihbXlxcXFxcXFxcXSdcXFxcXFxcIl0qPylcXFwiICsgd2hpdGVzcGFjZSArIFxcXCIqXFxcXFxcXFxdXFxcIiwgXFxcImdcXFwiKSxcXG4gICAgICAgIHJwc2V1ZG8gPSBuZXcgUmVnRXhwKHBzZXVkb3MpLFxcbiAgICAgICAgcmlkZW50aWZpZXIgPSBuZXcgUmVnRXhwKFxcXCJeXFxcIiArIGlkZW50aWZpZXIgKyBcXFwiJFxcXCIpLFxcbiAgICAgICAgbWF0Y2hFeHByID0ge1xcbiAgICAgIFxcXCJJRFxcXCI6IG5ldyBSZWdFeHAoXFxcIl4jKFxcXCIgKyBjaGFyYWN0ZXJFbmNvZGluZyArIFxcXCIpXFxcIiksXFxuICAgICAgXFxcIkNMQVNTXFxcIjogbmV3IFJlZ0V4cChcXFwiXlxcXFxcXFxcLihcXFwiICsgY2hhcmFjdGVyRW5jb2RpbmcgKyBcXFwiKVxcXCIpLFxcbiAgICAgIFxcXCJUQUdcXFwiOiBuZXcgUmVnRXhwKFxcXCJeKFxcXCIgKyBjaGFyYWN0ZXJFbmNvZGluZy5yZXBsYWNlKFxcXCJ3XFxcIiwgXFxcIncqXFxcIikgKyBcXFwiKVxcXCIpLFxcbiAgICAgIFxcXCJBVFRSXFxcIjogbmV3IFJlZ0V4cChcXFwiXlxcXCIgKyBhdHRyaWJ1dGVzKSxcXG4gICAgICBcXFwiUFNFVURPXFxcIjogbmV3IFJlZ0V4cChcXFwiXlxcXCIgKyBwc2V1ZG9zKSxcXG4gICAgICBcXFwiQ0hJTERcXFwiOiBuZXcgUmVnRXhwKFxcXCJeOihvbmx5fGZpcnN0fGxhc3R8bnRofG50aC1sYXN0KS0oY2hpbGR8b2YtdHlwZSkoPzpcXFxcXFxcXChcXFwiICsgd2hpdGVzcGFjZSArIFxcXCIqKGV2ZW58b2RkfCgoWystXXwpKFxcXFxcXFxcZCopbnwpXFxcIiArIHdoaXRlc3BhY2UgKyBcXFwiKig/OihbKy1dfClcXFwiICsgd2hpdGVzcGFjZSArIFxcXCIqKFxcXFxcXFxcZCspfCkpXFxcIiArIHdoaXRlc3BhY2UgKyBcXFwiKlxcXFxcXFxcKXwpXFxcIiwgXFxcImlcXFwiKSxcXG4gICAgICBcXFwiYm9vbFxcXCI6IG5ldyBSZWdFeHAoXFxcIl4oPzpcXFwiICsgYm9vbGVhbnMgKyBcXFwiKSRcXFwiLCBcXFwiaVxcXCIpLFxcbiAgICAgIC8vIEZvciB1c2UgaW4gbGlicmFyaWVzIGltcGxlbWVudGluZyAuaXMoKVxcbiAgICAgIC8vIFdlIHVzZSB0aGlzIGZvciBQT1MgbWF0Y2hpbmcgaW4gYHNlbGVjdGBcXG4gICAgICBcXFwibmVlZHNDb250ZXh0XFxcIjogbmV3IFJlZ0V4cChcXFwiXlxcXCIgKyB3aGl0ZXNwYWNlICsgXFxcIipbPit+XXw6KGV2ZW58b2RkfGVxfGd0fGx0fG50aHxmaXJzdHxsYXN0KSg/OlxcXFxcXFxcKFxcXCIgKyB3aGl0ZXNwYWNlICsgXFxcIiooKD86LVxcXFxcXFxcZCk/XFxcXFxcXFxkKilcXFwiICsgd2hpdGVzcGFjZSArIFxcXCIqXFxcXFxcXFwpfCkoPz1bXi1dfCQpXFxcIiwgXFxcImlcXFwiKVxcbiAgICB9LFxcbiAgICAgICAgcmlucHV0cyA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXFxuICAgICAgICByaGVhZGVyID0gL15oXFxcXGQkL2ksXFxuICAgICAgICBybmF0aXZlID0gL15bXntdK1xcXFx7XFxcXHMqXFxcXFtuYXRpdmUgXFxcXHcvLFxcbiAgICAgICAgLy8gRWFzaWx5LXBhcnNlYWJsZS9yZXRyaWV2YWJsZSBJRCBvciBUQUcgb3IgQ0xBU1Mgc2VsZWN0b3JzXFxuICAgIHJxdWlja0V4cHIgPSAvXig/OiMoW1xcXFx3LV0rKXwoXFxcXHcrKXxcXFxcLihbXFxcXHctXSspKSQvLFxcbiAgICAgICAgcnNpYmxpbmcgPSAvWyt+XS8sXFxuICAgICAgICByZXNjYXBlID0gLyd8XFxcXFxcXFwvZyxcXG4gICAgICAgIC8vIENTUyBlc2NhcGVzIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCNlc2NhcGVkLWNoYXJhY3RlcnNcXG4gICAgcnVuZXNjYXBlID0gbmV3IFJlZ0V4cChcXFwiXFxcXFxcXFxcXFxcXFxcXChbXFxcXFxcXFxkYS1mXXsxLDZ9XFxcIiArIHdoaXRlc3BhY2UgKyBcXFwiP3woXFxcIiArIHdoaXRlc3BhY2UgKyBcXFwiKXwuKVxcXCIsIFxcXCJpZ1xcXCIpLFxcbiAgICAgICAgZnVuZXNjYXBlID0gZnVuY3Rpb24gZnVuZXNjYXBlKF8sIGVzY2FwZWQsIGVzY2FwZWRXaGl0ZXNwYWNlKSB7XFxuICAgICAgdmFyIGhpZ2ggPSBcXFwiMHhcXFwiICsgZXNjYXBlZCAtIDB4MTAwMDA7IC8vIE5hTiBtZWFucyBub24tY29kZXBvaW50XFxuICAgICAgLy8gU3VwcG9ydDogRmlyZWZveDwyNFxcbiAgICAgIC8vIFdvcmthcm91bmQgZXJyb25lb3VzIG51bWVyaWMgaW50ZXJwcmV0YXRpb24gb2YgK1xcXCIweFxcXCJcXG5cXG4gICAgICByZXR1cm4gaGlnaCAhPT0gaGlnaCB8fCBlc2NhcGVkV2hpdGVzcGFjZSA/IGVzY2FwZWQgOiBoaWdoIDwgMCA/IC8vIEJNUCBjb2RlcG9pbnRcXG4gICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKGhpZ2ggKyAweDEwMDAwKSA6IC8vIFN1cHBsZW1lbnRhbCBQbGFuZSBjb2RlcG9pbnQgKHN1cnJvZ2F0ZSBwYWlyKVxcbiAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaGlnaCA+PiAxMCB8IDB4RDgwMCwgaGlnaCAmIDB4M0ZGIHwgMHhEQzAwKTtcXG4gICAgfSxcXG4gICAgICAgIC8vIFVzZWQgZm9yIGlmcmFtZXNcXG4gICAgLy8gU2VlIHNldERvY3VtZW50KClcXG4gICAgLy8gUmVtb3ZpbmcgdGhlIGZ1bmN0aW9uIHdyYXBwZXIgY2F1c2VzIGEgXFxcIlBlcm1pc3Npb24gRGVuaWVkXFxcIlxcbiAgICAvLyBlcnJvciBpbiBJRVxcbiAgICB1bmxvYWRIYW5kbGVyID0gZnVuY3Rpb24gdW5sb2FkSGFuZGxlcigpIHtcXG4gICAgICBzZXREb2N1bWVudCgpO1xcbiAgICB9OyAvLyBPcHRpbWl6ZSBmb3IgcHVzaC5hcHBseSggXywgTm9kZUxpc3QgKVxcblxcblxcbiAgICB0cnkge1xcbiAgICAgIHB1c2guYXBwbHkoYXJyID0gc2xpY2UuY2FsbChwcmVmZXJyZWREb2MuY2hpbGROb2RlcyksIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzKTsgLy8gU3VwcG9ydDogQW5kcm9pZDw0LjBcXG4gICAgICAvLyBEZXRlY3Qgc2lsZW50bHkgZmFpbGluZyBwdXNoLmFwcGx5XFxuXFxuICAgICAgYXJyW3ByZWZlcnJlZERvYy5jaGlsZE5vZGVzLmxlbmd0aF0ubm9kZVR5cGU7XFxuICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICBwdXNoID0ge1xcbiAgICAgICAgYXBwbHk6IGFyci5sZW5ndGggPyAvLyBMZXZlcmFnZSBzbGljZSBpZiBwb3NzaWJsZVxcbiAgICAgICAgZnVuY3Rpb24gKHRhcmdldCwgZWxzKSB7XFxuICAgICAgICAgIHB1c2hfbmF0aXZlLmFwcGx5KHRhcmdldCwgc2xpY2UuY2FsbChlbHMpKTtcXG4gICAgICAgIH0gOiAvLyBTdXBwb3J0OiBJRTw5XFxuICAgICAgICAvLyBPdGhlcndpc2UgYXBwZW5kIGRpcmVjdGx5XFxuICAgICAgICBmdW5jdGlvbiAodGFyZ2V0LCBlbHMpIHtcXG4gICAgICAgICAgdmFyIGogPSB0YXJnZXQubGVuZ3RoLFxcbiAgICAgICAgICAgICAgaSA9IDA7IC8vIENhbid0IHRydXN0IE5vZGVMaXN0Lmxlbmd0aFxcblxcbiAgICAgICAgICB3aGlsZSAodGFyZ2V0W2orK10gPSBlbHNbaSsrXSkge31cXG5cXG4gICAgICAgICAgdGFyZ2V0Lmxlbmd0aCA9IGogLSAxO1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gU2l6emxlKHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkKSB7XFxuICAgICAgdmFyIG1hdGNoLCBlbGVtLCBtLCBub2RlVHlwZSwgLy8gUVNBIHZhcnNcXG4gICAgICBpLCBncm91cHMsIG9sZCwgbmlkLCBuZXdDb250ZXh0LCBuZXdTZWxlY3RvcjtcXG5cXG4gICAgICBpZiAoKGNvbnRleHQgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IHByZWZlcnJlZERvYykgIT09IGRvY3VtZW50KSB7XFxuICAgICAgICBzZXREb2N1bWVudChjb250ZXh0KTtcXG4gICAgICB9XFxuXFxuICAgICAgY29udGV4dCA9IGNvbnRleHQgfHwgZG9jdW1lbnQ7XFxuICAgICAgcmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XFxuICAgICAgbm9kZVR5cGUgPSBjb250ZXh0Lm5vZGVUeXBlO1xcblxcbiAgICAgIGlmICh0eXBlb2Ygc2VsZWN0b3IgIT09IFxcXCJzdHJpbmdcXFwiIHx8ICFzZWxlY3RvciB8fCBub2RlVHlwZSAhPT0gMSAmJiBub2RlVHlwZSAhPT0gOSAmJiBub2RlVHlwZSAhPT0gMTEpIHtcXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIXNlZWQgJiYgZG9jdW1lbnRJc0hUTUwpIHtcXG4gICAgICAgIC8vIFRyeSB0byBzaG9ydGN1dCBmaW5kIG9wZXJhdGlvbnMgd2hlbiBwb3NzaWJsZSAoZS5nLiwgbm90IHVuZGVyIERvY3VtZW50RnJhZ21lbnQpXFxuICAgICAgICBpZiAobm9kZVR5cGUgIT09IDExICYmIChtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyhzZWxlY3RvcikpKSB7XFxuICAgICAgICAgIC8vIFNwZWVkLXVwOiBTaXp6bGUoXFxcIiNJRFxcXCIpXFxuICAgICAgICAgIGlmIChtID0gbWF0Y2hbMV0pIHtcXG4gICAgICAgICAgICBpZiAobm9kZVR5cGUgPT09IDkpIHtcXG4gICAgICAgICAgICAgIGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKG0pOyAvLyBDaGVjayBwYXJlbnROb2RlIHRvIGNhdGNoIHdoZW4gQmxhY2tiZXJyeSA0LjYgcmV0dXJuc1xcbiAgICAgICAgICAgICAgLy8gbm9kZXMgdGhhdCBhcmUgbm8gbG9uZ2VyIGluIHRoZSBkb2N1bWVudCAoalF1ZXJ5ICM2OTYzKVxcblxcbiAgICAgICAgICAgICAgaWYgKGVsZW0gJiYgZWxlbS5wYXJlbnROb2RlKSB7XFxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSB0aGUgY2FzZSB3aGVyZSBJRSwgT3BlcmEsIGFuZCBXZWJraXQgcmV0dXJuIGl0ZW1zXFxuICAgICAgICAgICAgICAgIC8vIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxcbiAgICAgICAgICAgICAgICBpZiAoZWxlbS5pZCA9PT0gbSkge1xcbiAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChlbGVtKTtcXG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgIC8vIENvbnRleHQgaXMgbm90IGEgZG9jdW1lbnRcXG4gICAgICAgICAgICAgIGlmIChjb250ZXh0Lm93bmVyRG9jdW1lbnQgJiYgKGVsZW0gPSBjb250ZXh0Lm93bmVyRG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobSkpICYmIGNvbnRhaW5zKGNvbnRleHQsIGVsZW0pICYmIGVsZW0uaWQgPT09IG0pIHtcXG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGVsZW0pO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9IC8vIFNwZWVkLXVwOiBTaXp6bGUoXFxcIlRBR1xcXCIpXFxuXFxuICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2hbMl0pIHtcXG4gICAgICAgICAgICBwdXNoLmFwcGx5KHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoc2VsZWN0b3IpKTtcXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0czsgLy8gU3BlZWQtdXA6IFNpenpsZShcXFwiLkNMQVNTXFxcIilcXG4gICAgICAgICAgfSBlbHNlIGlmICgobSA9IG1hdGNoWzNdKSAmJiBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUpIHtcXG4gICAgICAgICAgICBwdXNoLmFwcGx5KHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShtKSk7XFxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gLy8gUVNBIHBhdGhcXG5cXG5cXG4gICAgICAgIGlmIChzdXBwb3J0LnFzYSAmJiAoIXJidWdneVFTQSB8fCAhcmJ1Z2d5UVNBLnRlc3Qoc2VsZWN0b3IpKSkge1xcbiAgICAgICAgICBuaWQgPSBvbGQgPSBleHBhbmRvO1xcbiAgICAgICAgICBuZXdDb250ZXh0ID0gY29udGV4dDtcXG4gICAgICAgICAgbmV3U2VsZWN0b3IgPSBub2RlVHlwZSAhPT0gMSAmJiBzZWxlY3RvcjsgLy8gcVNBIHdvcmtzIHN0cmFuZ2VseSBvbiBFbGVtZW50LXJvb3RlZCBxdWVyaWVzXFxuICAgICAgICAgIC8vIFdlIGNhbiB3b3JrIGFyb3VuZCB0aGlzIGJ5IHNwZWNpZnlpbmcgYW4gZXh0cmEgSUQgb24gdGhlIHJvb3RcXG4gICAgICAgICAgLy8gYW5kIHdvcmtpbmcgdXAgZnJvbSB0aGVyZSAoVGhhbmtzIHRvIEFuZHJldyBEdXBvbnQgZm9yIHRoZSB0ZWNobmlxdWUpXFxuICAgICAgICAgIC8vIElFIDggZG9lc24ndCB3b3JrIG9uIG9iamVjdCBlbGVtZW50c1xcblxcbiAgICAgICAgICBpZiAobm9kZVR5cGUgPT09IDEgJiYgY29udGV4dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcXFwib2JqZWN0XFxcIikge1xcbiAgICAgICAgICAgIGdyb3VwcyA9IHRva2VuaXplKHNlbGVjdG9yKTtcXG5cXG4gICAgICAgICAgICBpZiAob2xkID0gY29udGV4dC5nZXRBdHRyaWJ1dGUoXFxcImlkXFxcIikpIHtcXG4gICAgICAgICAgICAgIG5pZCA9IG9sZC5yZXBsYWNlKHJlc2NhcGUsIFxcXCJcXFxcXFxcXCQmXFxcIik7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgIGNvbnRleHQuc2V0QXR0cmlidXRlKFxcXCJpZFxcXCIsIG5pZCk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIG5pZCA9IFxcXCJbaWQ9J1xcXCIgKyBuaWQgKyBcXFwiJ10gXFxcIjtcXG4gICAgICAgICAgICBpID0gZ3JvdXBzLmxlbmd0aDtcXG5cXG4gICAgICAgICAgICB3aGlsZSAoaS0tKSB7XFxuICAgICAgICAgICAgICBncm91cHNbaV0gPSBuaWQgKyB0b1NlbGVjdG9yKGdyb3Vwc1tpXSk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIG5ld0NvbnRleHQgPSByc2libGluZy50ZXN0KHNlbGVjdG9yKSAmJiB0ZXN0Q29udGV4dChjb250ZXh0LnBhcmVudE5vZGUpIHx8IGNvbnRleHQ7XFxuICAgICAgICAgICAgbmV3U2VsZWN0b3IgPSBncm91cHMuam9pbihcXFwiLFxcXCIpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmIChuZXdTZWxlY3Rvcikge1xcbiAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICBwdXNoLmFwcGx5KHJlc3VsdHMsIG5ld0NvbnRleHQucXVlcnlTZWxlY3RvckFsbChuZXdTZWxlY3RvcikpO1xcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XFxuICAgICAgICAgICAgfSBjYXRjaCAocXNhRXJyb3IpIHt9IGZpbmFsbHkge1xcbiAgICAgICAgICAgICAgaWYgKCFvbGQpIHtcXG4gICAgICAgICAgICAgICAgY29udGV4dC5yZW1vdmVBdHRyaWJ1dGUoXFxcImlkXFxcIik7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfSAvLyBBbGwgb3RoZXJzXFxuXFxuXFxuICAgICAgcmV0dXJuIHNlbGVjdChzZWxlY3Rvci5yZXBsYWNlKHJ0cmltLCBcXFwiJDFcXFwiKSwgY29udGV4dCwgcmVzdWx0cywgc2VlZCk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIENyZWF0ZSBrZXktdmFsdWUgY2FjaGVzIG9mIGxpbWl0ZWQgc2l6ZVxcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb24oc3RyaW5nLCBPYmplY3QpfSBSZXR1cm5zIHRoZSBPYmplY3QgZGF0YSBhZnRlciBzdG9yaW5nIGl0IG9uIGl0c2VsZiB3aXRoXFxuICAgICAqXFx0cHJvcGVydHkgbmFtZSB0aGUgKHNwYWNlLXN1ZmZpeGVkKSBzdHJpbmcgYW5kIChpZiB0aGUgY2FjaGUgaXMgbGFyZ2VyIHRoYW4gRXhwci5jYWNoZUxlbmd0aClcXG4gICAgICpcXHRkZWxldGluZyB0aGUgb2xkZXN0IGVudHJ5XFxuICAgICAqL1xcblxcblxcbiAgICBmdW5jdGlvbiBjcmVhdGVDYWNoZSgpIHtcXG4gICAgICB2YXIga2V5cyA9IFtdO1xcblxcbiAgICAgIGZ1bmN0aW9uIGNhY2hlKGtleSwgdmFsdWUpIHtcXG4gICAgICAgIC8vIFVzZSAoa2V5ICsgXFxcIiBcXFwiKSB0byBhdm9pZCBjb2xsaXNpb24gd2l0aCBuYXRpdmUgcHJvdG90eXBlIHByb3BlcnRpZXMgKHNlZSBJc3N1ZSAjMTU3KVxcbiAgICAgICAgaWYgKGtleXMucHVzaChrZXkgKyBcXFwiIFxcXCIpID4gRXhwci5jYWNoZUxlbmd0aCkge1xcbiAgICAgICAgICAvLyBPbmx5IGtlZXAgdGhlIG1vc3QgcmVjZW50IGVudHJpZXNcXG4gICAgICAgICAgZGVsZXRlIGNhY2hlW2tleXMuc2hpZnQoKV07XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gY2FjaGVba2V5ICsgXFxcIiBcXFwiXSA9IHZhbHVlO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gY2FjaGU7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIE1hcmsgYSBmdW5jdGlvbiBmb3Igc3BlY2lhbCB1c2UgYnkgU2l6emxlXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBtYXJrXFxuICAgICAqL1xcblxcblxcbiAgICBmdW5jdGlvbiBtYXJrRnVuY3Rpb24oZm4pIHtcXG4gICAgICBmbltleHBhbmRvXSA9IHRydWU7XFxuICAgICAgcmV0dXJuIGZuO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBTdXBwb3J0IHRlc3RpbmcgdXNpbmcgYW4gZWxlbWVudFxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBQYXNzZWQgdGhlIGNyZWF0ZWQgZGl2IGFuZCBleHBlY3RzIGEgYm9vbGVhbiByZXN1bHRcXG4gICAgICovXFxuXFxuXFxuICAgIGZ1bmN0aW9uIGFzc2VydChmbikge1xcbiAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxcXCJkaXZcXFwiKTtcXG5cXG4gICAgICB0cnkge1xcbiAgICAgICAgcmV0dXJuICEhZm4oZGl2KTtcXG4gICAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfSBmaW5hbGx5IHtcXG4gICAgICAgIC8vIFJlbW92ZSBmcm9tIGl0cyBwYXJlbnQgYnkgZGVmYXVsdFxcbiAgICAgICAgaWYgKGRpdi5wYXJlbnROb2RlKSB7XFxuICAgICAgICAgIGRpdi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGRpdik7XFxuICAgICAgICB9IC8vIHJlbGVhc2UgbWVtb3J5IGluIElFXFxuXFxuXFxuICAgICAgICBkaXYgPSBudWxsO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQWRkcyB0aGUgc2FtZSBoYW5kbGVyIGZvciBhbGwgb2YgdGhlIHNwZWNpZmllZCBhdHRyc1xcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0cnMgUGlwZS1zZXBhcmF0ZWQgbGlzdCBvZiBhdHRyaWJ1dGVzXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgVGhlIG1ldGhvZCB0aGF0IHdpbGwgYmUgYXBwbGllZFxcbiAgICAgKi9cXG5cXG5cXG4gICAgZnVuY3Rpb24gYWRkSGFuZGxlKGF0dHJzLCBoYW5kbGVyKSB7XFxuICAgICAgdmFyIGFyciA9IGF0dHJzLnNwbGl0KFxcXCJ8XFxcIiksXFxuICAgICAgICAgIGkgPSBhdHRycy5sZW5ndGg7XFxuXFxuICAgICAgd2hpbGUgKGktLSkge1xcbiAgICAgICAgRXhwci5hdHRySGFuZGxlW2FycltpXV0gPSBoYW5kbGVyO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogQ2hlY2tzIGRvY3VtZW50IG9yZGVyIG9mIHR3byBzaWJsaW5nc1xcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGFcXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBiXFxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IFJldHVybnMgbGVzcyB0aGFuIDAgaWYgYSBwcmVjZWRlcyBiLCBncmVhdGVyIHRoYW4gMCBpZiBhIGZvbGxvd3MgYlxcbiAgICAgKi9cXG5cXG5cXG4gICAgZnVuY3Rpb24gc2libGluZ0NoZWNrKGEsIGIpIHtcXG4gICAgICB2YXIgY3VyID0gYiAmJiBhLFxcbiAgICAgICAgICBkaWZmID0gY3VyICYmIGEubm9kZVR5cGUgPT09IDEgJiYgYi5ub2RlVHlwZSA9PT0gMSAmJiAofmIuc291cmNlSW5kZXggfHwgTUFYX05FR0FUSVZFKSAtICh+YS5zb3VyY2VJbmRleCB8fCBNQVhfTkVHQVRJVkUpOyAvLyBVc2UgSUUgc291cmNlSW5kZXggaWYgYXZhaWxhYmxlIG9uIGJvdGggbm9kZXNcXG5cXG4gICAgICBpZiAoZGlmZikge1xcbiAgICAgICAgcmV0dXJuIGRpZmY7XFxuICAgICAgfSAvLyBDaGVjayBpZiBiIGZvbGxvd3MgYVxcblxcblxcbiAgICAgIGlmIChjdXIpIHtcXG4gICAgICAgIHdoaWxlIChjdXIgPSBjdXIubmV4dFNpYmxpbmcpIHtcXG4gICAgICAgICAgaWYgKGN1ciA9PT0gYikge1xcbiAgICAgICAgICAgIHJldHVybiAtMTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gYSA/IDEgOiAtMTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBpbnB1dCB0eXBlc1xcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxcbiAgICAgKi9cXG5cXG5cXG4gICAgZnVuY3Rpb24gY3JlYXRlSW5wdXRQc2V1ZG8odHlwZSkge1xcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZWxlbSkge1xcbiAgICAgICAgdmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XFxuICAgICAgICByZXR1cm4gbmFtZSA9PT0gXFxcImlucHV0XFxcIiAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XFxuICAgICAgfTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBidXR0b25zXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXFxuICAgICAqL1xcblxcblxcbiAgICBmdW5jdGlvbiBjcmVhdGVCdXR0b25Qc2V1ZG8odHlwZSkge1xcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZWxlbSkge1xcbiAgICAgICAgdmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XFxuICAgICAgICByZXR1cm4gKG5hbWUgPT09IFxcXCJpbnB1dFxcXCIgfHwgbmFtZSA9PT0gXFxcImJ1dHRvblxcXCIpICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcXG4gICAgICB9O1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIHBvc2l0aW9uYWxzXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICAgICAqL1xcblxcblxcbiAgICBmdW5jdGlvbiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZuKSB7XFxuICAgICAgcmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiAoYXJndW1lbnQpIHtcXG4gICAgICAgIGFyZ3VtZW50ID0gK2FyZ3VtZW50O1xcbiAgICAgICAgcmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiAoc2VlZCwgbWF0Y2hlcykge1xcbiAgICAgICAgICB2YXIgaixcXG4gICAgICAgICAgICAgIG1hdGNoSW5kZXhlcyA9IGZuKFtdLCBzZWVkLmxlbmd0aCwgYXJndW1lbnQpLFxcbiAgICAgICAgICAgICAgaSA9IG1hdGNoSW5kZXhlcy5sZW5ndGg7IC8vIE1hdGNoIGVsZW1lbnRzIGZvdW5kIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhlc1xcblxcbiAgICAgICAgICB3aGlsZSAoaS0tKSB7XFxuICAgICAgICAgICAgaWYgKHNlZWRbaiA9IG1hdGNoSW5kZXhlc1tpXV0pIHtcXG4gICAgICAgICAgICAgIHNlZWRbal0gPSAhKG1hdGNoZXNbal0gPSBzZWVkW2pdKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBDaGVja3MgYSBub2RlIGZvciB2YWxpZGl0eSBhcyBhIFNpenpsZSBjb250ZXh0XFxuICAgICAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3Q9fSBjb250ZXh0XFxuICAgICAqIEByZXR1cm5zIHtFbGVtZW50fE9iamVjdHxCb29sZWFufSBUaGUgaW5wdXQgbm9kZSBpZiBhY2NlcHRhYmxlLCBvdGhlcndpc2UgYSBmYWxzeSB2YWx1ZVxcbiAgICAgKi9cXG5cXG5cXG4gICAgZnVuY3Rpb24gdGVzdENvbnRleHQoY29udGV4dCkge1xcbiAgICAgIHJldHVybiBjb250ZXh0ICYmIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcXFwidW5kZWZpbmVkXFxcIiAmJiBjb250ZXh0O1xcbiAgICB9IC8vIEV4cG9zZSBzdXBwb3J0IHZhcnMgZm9yIGNvbnZlbmllbmNlXFxuXFxuXFxuICAgIHN1cHBvcnQgPSBTaXp6bGUuc3VwcG9ydCA9IHt9O1xcbiAgICAvKipcXG4gICAgICogRGV0ZWN0cyBYTUwgbm9kZXNcXG4gICAgICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gZWxlbSBBbiBlbGVtZW50IG9yIGEgZG9jdW1lbnRcXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWZmIGVsZW0gaXMgYSBub24tSFRNTCBYTUwgbm9kZVxcbiAgICAgKi9cXG5cXG4gICAgaXNYTUwgPSBTaXp6bGUuaXNYTUwgPSBmdW5jdGlvbiAoZWxlbSkge1xcbiAgICAgIC8vIGRvY3VtZW50RWxlbWVudCBpcyB2ZXJpZmllZCBmb3IgY2FzZXMgd2hlcmUgaXQgZG9lc24ndCB5ZXQgZXhpc3RcXG4gICAgICAvLyAoc3VjaCBhcyBsb2FkaW5nIGlmcmFtZXMgaW4gSUUgLSAjNDgzMylcXG4gICAgICB2YXIgZG9jdW1lbnRFbGVtZW50ID0gZWxlbSAmJiAoZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0pLmRvY3VtZW50RWxlbWVudDtcXG4gICAgICByZXR1cm4gZG9jdW1lbnRFbGVtZW50ID8gZG9jdW1lbnRFbGVtZW50Lm5vZGVOYW1lICE9PSBcXFwiSFRNTFxcXCIgOiBmYWxzZTtcXG4gICAgfTtcXG4gICAgLyoqXFxuICAgICAqIFNldHMgZG9jdW1lbnQtcmVsYXRlZCB2YXJpYWJsZXMgb25jZSBiYXNlZCBvbiB0aGUgY3VycmVudCBkb2N1bWVudFxcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBbZG9jXSBBbiBlbGVtZW50IG9yIGRvY3VtZW50IG9iamVjdCB0byB1c2UgdG8gc2V0IHRoZSBkb2N1bWVudFxcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjdXJyZW50IGRvY3VtZW50XFxuICAgICAqL1xcblxcblxcbiAgICBzZXREb2N1bWVudCA9IFNpenpsZS5zZXREb2N1bWVudCA9IGZ1bmN0aW9uIChub2RlKSB7XFxuICAgICAgdmFyIGhhc0NvbXBhcmUsXFxuICAgICAgICAgIHBhcmVudCxcXG4gICAgICAgICAgZG9jID0gbm9kZSA/IG5vZGUub3duZXJEb2N1bWVudCB8fCBub2RlIDogcHJlZmVycmVkRG9jOyAvLyBJZiBubyBkb2N1bWVudCBhbmQgZG9jdW1lbnRFbGVtZW50IGlzIGF2YWlsYWJsZSwgcmV0dXJuXFxuXFxuICAgICAgaWYgKGRvYyA9PT0gZG9jdW1lbnQgfHwgZG9jLm5vZGVUeXBlICE9PSA5IHx8ICFkb2MuZG9jdW1lbnRFbGVtZW50KSB7XFxuICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XFxuICAgICAgfSAvLyBTZXQgb3VyIGRvY3VtZW50XFxuXFxuXFxuICAgICAgZG9jdW1lbnQgPSBkb2M7XFxuICAgICAgZG9jRWxlbSA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XFxuICAgICAgcGFyZW50ID0gZG9jLmRlZmF1bHRWaWV3OyAvLyBTdXBwb3J0OiBJRT44XFxuICAgICAgLy8gSWYgaWZyYW1lIGRvY3VtZW50IGlzIGFzc2lnbmVkIHRvIFxcXCJkb2N1bWVudFxcXCIgdmFyaWFibGUgYW5kIGlmIGlmcmFtZSBoYXMgYmVlbiByZWxvYWRlZCxcXG4gICAgICAvLyBJRSB3aWxsIHRocm93IFxcXCJwZXJtaXNzaW9uIGRlbmllZFxcXCIgZXJyb3Igd2hlbiBhY2Nlc3NpbmcgXFxcImRvY3VtZW50XFxcIiB2YXJpYWJsZSwgc2VlIGpRdWVyeSAjMTM5MzZcXG4gICAgICAvLyBJRTYtOCBkbyBub3Qgc3VwcG9ydCB0aGUgZGVmYXVsdFZpZXcgcHJvcGVydHkgc28gcGFyZW50IHdpbGwgYmUgdW5kZWZpbmVkXFxuXFxuICAgICAgaWYgKHBhcmVudCAmJiBwYXJlbnQgIT09IHBhcmVudC50b3ApIHtcXG4gICAgICAgIC8vIElFMTEgZG9lcyBub3QgaGF2ZSBhdHRhY2hFdmVudCwgc28gYWxsIG11c3Qgc3VmZmVyXFxuICAgICAgICBpZiAocGFyZW50LmFkZEV2ZW50TGlzdGVuZXIpIHtcXG4gICAgICAgICAgcGFyZW50LmFkZEV2ZW50TGlzdGVuZXIoXFxcInVubG9hZFxcXCIsIHVubG9hZEhhbmRsZXIsIGZhbHNlKTtcXG4gICAgICAgIH0gZWxzZSBpZiAocGFyZW50LmF0dGFjaEV2ZW50KSB7XFxuICAgICAgICAgIHBhcmVudC5hdHRhY2hFdmVudChcXFwib251bmxvYWRcXFwiLCB1bmxvYWRIYW5kbGVyKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgLyogU3VwcG9ydCB0ZXN0c1xcbiAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cXG5cXG5cXG4gICAgICBkb2N1bWVudElzSFRNTCA9ICFpc1hNTChkb2MpO1xcbiAgICAgIC8qIEF0dHJpYnV0ZXNcXG4gICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXFxuICAgICAgLy8gU3VwcG9ydDogSUU8OFxcbiAgICAgIC8vIFZlcmlmeSB0aGF0IGdldEF0dHJpYnV0ZSByZWFsbHkgcmV0dXJucyBhdHRyaWJ1dGVzIGFuZCBub3QgcHJvcGVydGllc1xcbiAgICAgIC8vIChleGNlcHRpbmcgSUU4IGJvb2xlYW5zKVxcblxcbiAgICAgIHN1cHBvcnQuYXR0cmlidXRlcyA9IGFzc2VydChmdW5jdGlvbiAoZGl2KSB7XFxuICAgICAgICBkaXYuY2xhc3NOYW1lID0gXFxcImlcXFwiO1xcbiAgICAgICAgcmV0dXJuICFkaXYuZ2V0QXR0cmlidXRlKFxcXCJjbGFzc05hbWVcXFwiKTtcXG4gICAgICB9KTtcXG4gICAgICAvKiBnZXRFbGVtZW50KHMpQnkqXFxuICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xcbiAgICAgIC8vIENoZWNrIGlmIGdldEVsZW1lbnRzQnlUYWdOYW1lKFxcXCIqXFxcIikgcmV0dXJucyBvbmx5IGVsZW1lbnRzXFxuXFxuICAgICAgc3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA9IGFzc2VydChmdW5jdGlvbiAoZGl2KSB7XFxuICAgICAgICBkaXYuYXBwZW5kQ2hpbGQoZG9jLmNyZWF0ZUNvbW1lbnQoXFxcIlxcXCIpKTtcXG4gICAgICAgIHJldHVybiAhZGl2LmdldEVsZW1lbnRzQnlUYWdOYW1lKFxcXCIqXFxcIikubGVuZ3RoO1xcbiAgICAgIH0pOyAvLyBTdXBwb3J0OiBJRTw5XFxuXFxuICAgICAgc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lID0gcm5hdGl2ZS50ZXN0KGRvYy5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKTsgLy8gU3VwcG9ydDogSUU8MTBcXG4gICAgICAvLyBDaGVjayBpZiBnZXRFbGVtZW50QnlJZCByZXR1cm5zIGVsZW1lbnRzIGJ5IG5hbWVcXG4gICAgICAvLyBUaGUgYnJva2VuIGdldEVsZW1lbnRCeUlkIG1ldGhvZHMgZG9uJ3QgcGljayB1cCBwcm9ncmFtYXRpY2FsbHktc2V0IG5hbWVzLFxcbiAgICAgIC8vIHNvIHVzZSBhIHJvdW5kYWJvdXQgZ2V0RWxlbWVudHNCeU5hbWUgdGVzdFxcblxcbiAgICAgIHN1cHBvcnQuZ2V0QnlJZCA9IGFzc2VydChmdW5jdGlvbiAoZGl2KSB7XFxuICAgICAgICBkb2NFbGVtLmFwcGVuZENoaWxkKGRpdikuaWQgPSBleHBhbmRvO1xcbiAgICAgICAgcmV0dXJuICFkb2MuZ2V0RWxlbWVudHNCeU5hbWUgfHwgIWRvYy5nZXRFbGVtZW50c0J5TmFtZShleHBhbmRvKS5sZW5ndGg7XFxuICAgICAgfSk7IC8vIElEIGZpbmQgYW5kIGZpbHRlclxcblxcbiAgICAgIGlmIChzdXBwb3J0LmdldEJ5SWQpIHtcXG4gICAgICAgIEV4cHIuZmluZFtcXFwiSURcXFwiXSA9IGZ1bmN0aW9uIChpZCwgY29udGV4dCkge1xcbiAgICAgICAgICBpZiAodHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IFxcXCJ1bmRlZmluZWRcXFwiICYmIGRvY3VtZW50SXNIVE1MKSB7XFxuICAgICAgICAgICAgdmFyIG0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKGlkKTsgLy8gQ2hlY2sgcGFyZW50Tm9kZSB0byBjYXRjaCB3aGVuIEJsYWNrYmVycnkgNC42IHJldHVybnNcXG4gICAgICAgICAgICAvLyBub2RlcyB0aGF0IGFyZSBubyBsb25nZXIgaW4gdGhlIGRvY3VtZW50ICM2OTYzXFxuXFxuICAgICAgICAgICAgcmV0dXJuIG0gJiYgbS5wYXJlbnROb2RlID8gW21dIDogW107XFxuICAgICAgICAgIH1cXG4gICAgICAgIH07XFxuXFxuICAgICAgICBFeHByLmZpbHRlcltcXFwiSURcXFwiXSA9IGZ1bmN0aW9uIChpZCkge1xcbiAgICAgICAgICB2YXIgYXR0cklkID0gaWQucmVwbGFjZShydW5lc2NhcGUsIGZ1bmVzY2FwZSk7XFxuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZWxlbSkge1xcbiAgICAgICAgICAgIHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZShcXFwiaWRcXFwiKSA9PT0gYXR0cklkO1xcbiAgICAgICAgICB9O1xcbiAgICAgICAgfTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgLy8gU3VwcG9ydDogSUU2LzdcXG4gICAgICAgIC8vIGdldEVsZW1lbnRCeUlkIGlzIG5vdCByZWxpYWJsZSBhcyBhIGZpbmQgc2hvcnRjdXRcXG4gICAgICAgIGRlbGV0ZSBFeHByLmZpbmRbXFxcIklEXFxcIl07XFxuXFxuICAgICAgICBFeHByLmZpbHRlcltcXFwiSURcXFwiXSA9IGZ1bmN0aW9uIChpZCkge1xcbiAgICAgICAgICB2YXIgYXR0cklkID0gaWQucmVwbGFjZShydW5lc2NhcGUsIGZ1bmVzY2FwZSk7XFxuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZWxlbSkge1xcbiAgICAgICAgICAgIHZhciBub2RlID0gdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlTm9kZSAhPT0gXFxcInVuZGVmaW5lZFxcXCIgJiYgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFxcXCJpZFxcXCIpO1xcbiAgICAgICAgICAgIHJldHVybiBub2RlICYmIG5vZGUudmFsdWUgPT09IGF0dHJJZDtcXG4gICAgICAgICAgfTtcXG4gICAgICAgIH07XFxuICAgICAgfSAvLyBUYWdcXG5cXG5cXG4gICAgICBFeHByLmZpbmRbXFxcIlRBR1xcXCJdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA/IGZ1bmN0aW9uICh0YWcsIGNvbnRleHQpIHtcXG4gICAgICAgIGlmICh0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXFxcInVuZGVmaW5lZFxcXCIpIHtcXG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUodGFnKTsgLy8gRG9jdW1lbnRGcmFnbWVudCBub2RlcyBkb24ndCBoYXZlIGdFQlROXFxuICAgICAgICB9IGVsc2UgaWYgKHN1cHBvcnQucXNhKSB7XFxuICAgICAgICAgIHJldHVybiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwodGFnKTtcXG4gICAgICAgIH1cXG4gICAgICB9IDogZnVuY3Rpb24gKHRhZywgY29udGV4dCkge1xcbiAgICAgICAgdmFyIGVsZW0sXFxuICAgICAgICAgICAgdG1wID0gW10sXFxuICAgICAgICAgICAgaSA9IDAsXFxuICAgICAgICAgICAgLy8gQnkgaGFwcHkgY29pbmNpZGVuY2UsIGEgKGJyb2tlbikgZ0VCVE4gYXBwZWFycyBvbiBEb2N1bWVudEZyYWdtZW50IG5vZGVzIHRvb1xcbiAgICAgICAgcmVzdWx0cyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUodGFnKTsgLy8gRmlsdGVyIG91dCBwb3NzaWJsZSBjb21tZW50c1xcblxcbiAgICAgICAgaWYgKHRhZyA9PT0gXFxcIipcXFwiKSB7XFxuICAgICAgICAgIHdoaWxlIChlbGVtID0gcmVzdWx0c1tpKytdKSB7XFxuICAgICAgICAgICAgaWYgKGVsZW0ubm9kZVR5cGUgPT09IDEpIHtcXG4gICAgICAgICAgICAgIHRtcC5wdXNoKGVsZW0pO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICByZXR1cm4gdG1wO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XFxuICAgICAgfTsgLy8gQ2xhc3NcXG5cXG4gICAgICBFeHByLmZpbmRbXFxcIkNMQVNTXFxcIl0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiYgZnVuY3Rpb24gKGNsYXNzTmFtZSwgY29udGV4dCkge1xcbiAgICAgICAgaWYgKGRvY3VtZW50SXNIVE1MKSB7XFxuICAgICAgICAgIHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoY2xhc3NOYW1lKTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIC8qIFFTQS9tYXRjaGVzU2VsZWN0b3JcXG4gICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXFxuICAgICAgLy8gUVNBIGFuZCBtYXRjaGVzU2VsZWN0b3Igc3VwcG9ydFxcbiAgICAgIC8vIG1hdGNoZXNTZWxlY3Rvcig6YWN0aXZlKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoSUU5L09wZXJhIDExLjUpXFxuXFxuXFxuICAgICAgcmJ1Z2d5TWF0Y2hlcyA9IFtdOyAvLyBxU2EoOmZvY3VzKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoQ2hyb21lIDIxKVxcbiAgICAgIC8vIFdlIGFsbG93IHRoaXMgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBJRTgvOSB0aGF0IHRocm93cyBhbiBlcnJvclxcbiAgICAgIC8vIHdoZW5ldmVyIGBkb2N1bWVudC5hY3RpdmVFbGVtZW50YCBpcyBhY2Nlc3NlZCBvbiBhbiBpZnJhbWVcXG4gICAgICAvLyBTbywgd2UgYWxsb3cgOmZvY3VzIHRvIHBhc3MgdGhyb3VnaCBRU0EgYWxsIHRoZSB0aW1lIHRvIGF2b2lkIHRoZSBJRSBlcnJvclxcbiAgICAgIC8vIFNlZSBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMzM3OFxcblxcbiAgICAgIHJidWdneVFTQSA9IFtdO1xcblxcbiAgICAgIGlmIChzdXBwb3J0LnFzYSA9IHJuYXRpdmUudGVzdChkb2MucXVlcnlTZWxlY3RvckFsbCkpIHtcXG4gICAgICAgIC8vIEJ1aWxkIFFTQSByZWdleFxcbiAgICAgICAgLy8gUmVnZXggc3RyYXRlZ3kgYWRvcHRlZCBmcm9tIERpZWdvIFBlcmluaVxcbiAgICAgICAgYXNzZXJ0KGZ1bmN0aW9uIChkaXYpIHtcXG4gICAgICAgICAgLy8gU2VsZWN0IGlzIHNldCB0byBlbXB0eSBzdHJpbmcgb24gcHVycG9zZVxcbiAgICAgICAgICAvLyBUaGlzIGlzIHRvIHRlc3QgSUUncyB0cmVhdG1lbnQgb2Ygbm90IGV4cGxpY2l0bHlcXG4gICAgICAgICAgLy8gc2V0dGluZyBhIGJvb2xlYW4gY29udGVudCBhdHRyaWJ1dGUsXFxuICAgICAgICAgIC8vIHNpbmNlIGl0cyBwcmVzZW5jZSBzaG91bGQgYmUgZW5vdWdoXFxuICAgICAgICAgIC8vIGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEyMzU5XFxuICAgICAgICAgIGRvY0VsZW0uYXBwZW5kQ2hpbGQoZGl2KS5pbm5lckhUTUwgPSBcXFwiPGEgaWQ9J1xcXCIgKyBleHBhbmRvICsgXFxcIic+PC9hPlxcXCIgKyBcXFwiPHNlbGVjdCBpZD0nXFxcIiArIGV4cGFuZG8gKyBcXFwiLVxcXFxmXScgbXNhbGxvd2NhcHR1cmU9Jyc+XFxcIiArIFxcXCI8b3B0aW9uIHNlbGVjdGVkPScnPjwvb3B0aW9uPjwvc2VsZWN0PlxcXCI7IC8vIFN1cHBvcnQ6IElFOCwgT3BlcmEgMTEtMTIuMTZcXG4gICAgICAgICAgLy8gTm90aGluZyBzaG91bGQgYmUgc2VsZWN0ZWQgd2hlbiBlbXB0eSBzdHJpbmdzIGZvbGxvdyBePSBvciAkPSBvciAqPVxcbiAgICAgICAgICAvLyBUaGUgdGVzdCBhdHRyaWJ1dGUgbXVzdCBiZSB1bmtub3duIGluIE9wZXJhIGJ1dCBcXFwic2FmZVxcXCIgZm9yIFdpblJUXFxuICAgICAgICAgIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9oaDQ2NTM4OC5hc3B4I2F0dHJpYnV0ZV9zZWN0aW9uXFxuXFxuICAgICAgICAgIGlmIChkaXYucXVlcnlTZWxlY3RvckFsbChcXFwiW21zYWxsb3djYXB0dXJlXj0nJ11cXFwiKS5sZW5ndGgpIHtcXG4gICAgICAgICAgICByYnVnZ3lRU0EucHVzaChcXFwiWypeJF09XFxcIiArIHdoaXRlc3BhY2UgKyBcXFwiKig/OicnfFxcXFxcXFwiXFxcXFxcXCIpXFxcIik7XFxuICAgICAgICAgIH0gLy8gU3VwcG9ydDogSUU4XFxuICAgICAgICAgIC8vIEJvb2xlYW4gYXR0cmlidXRlcyBhbmQgXFxcInZhbHVlXFxcIiBhcmUgbm90IHRyZWF0ZWQgY29ycmVjdGx5XFxuXFxuXFxuICAgICAgICAgIGlmICghZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXFxcIltzZWxlY3RlZF1cXFwiKS5sZW5ndGgpIHtcXG4gICAgICAgICAgICByYnVnZ3lRU0EucHVzaChcXFwiXFxcXFxcXFxbXFxcIiArIHdoaXRlc3BhY2UgKyBcXFwiKig/OnZhbHVlfFxcXCIgKyBib29sZWFucyArIFxcXCIpXFxcIik7XFxuICAgICAgICAgIH0gLy8gU3VwcG9ydDogQ2hyb21lPDI5LCBBbmRyb2lkPDQuMissIFNhZmFyaTw3LjArLCBpT1M8Ny4wKywgUGhhbnRvbUpTPDEuOS43K1xcblxcblxcbiAgICAgICAgICBpZiAoIWRpdi5xdWVyeVNlbGVjdG9yQWxsKFxcXCJbaWR+PVxcXCIgKyBleHBhbmRvICsgXFxcIi1dXFxcIikubGVuZ3RoKSB7XFxuICAgICAgICAgICAgcmJ1Z2d5UVNBLnB1c2goXFxcIn49XFxcIik7XFxuICAgICAgICAgIH0gLy8gV2Via2l0L09wZXJhIC0gOmNoZWNrZWQgc2hvdWxkIHJldHVybiBzZWxlY3RlZCBvcHRpb24gZWxlbWVudHNcXG4gICAgICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcXG4gICAgICAgICAgLy8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcXG5cXG5cXG4gICAgICAgICAgaWYgKCFkaXYucXVlcnlTZWxlY3RvckFsbChcXFwiOmNoZWNrZWRcXFwiKS5sZW5ndGgpIHtcXG4gICAgICAgICAgICByYnVnZ3lRU0EucHVzaChcXFwiOmNoZWNrZWRcXFwiKTtcXG4gICAgICAgICAgfSAvLyBTdXBwb3J0OiBTYWZhcmkgOCssIGlPUyA4K1xcbiAgICAgICAgICAvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM2ODUxXFxuICAgICAgICAgIC8vIEluLXBhZ2UgYHNlbGVjdG9yI2lkIHNpYmluZy1jb21iaW5hdG9yIHNlbGVjdG9yYCBmYWlsc1xcblxcblxcbiAgICAgICAgICBpZiAoIWRpdi5xdWVyeVNlbGVjdG9yQWxsKFxcXCJhI1xcXCIgKyBleHBhbmRvICsgXFxcIisqXFxcIikubGVuZ3RoKSB7XFxuICAgICAgICAgICAgcmJ1Z2d5UVNBLnB1c2goXFxcIi4jLitbK35dXFxcIik7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICAgICAgYXNzZXJ0KGZ1bmN0aW9uIChkaXYpIHtcXG4gICAgICAgICAgLy8gU3VwcG9ydDogV2luZG93cyA4IE5hdGl2ZSBBcHBzXFxuICAgICAgICAgIC8vIFRoZSB0eXBlIGFuZCBuYW1lIGF0dHJpYnV0ZXMgYXJlIHJlc3RyaWN0ZWQgZHVyaW5nIC5pbm5lckhUTUwgYXNzaWdubWVudFxcbiAgICAgICAgICB2YXIgaW5wdXQgPSBkb2MuY3JlYXRlRWxlbWVudChcXFwiaW5wdXRcXFwiKTtcXG4gICAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKFxcXCJ0eXBlXFxcIiwgXFxcImhpZGRlblxcXCIpO1xcbiAgICAgICAgICBkaXYuYXBwZW5kQ2hpbGQoaW5wdXQpLnNldEF0dHJpYnV0ZShcXFwibmFtZVxcXCIsIFxcXCJEXFxcIik7IC8vIFN1cHBvcnQ6IElFOFxcbiAgICAgICAgICAvLyBFbmZvcmNlIGNhc2Utc2Vuc2l0aXZpdHkgb2YgbmFtZSBhdHRyaWJ1dGVcXG5cXG4gICAgICAgICAgaWYgKGRpdi5xdWVyeVNlbGVjdG9yQWxsKFxcXCJbbmFtZT1kXVxcXCIpLmxlbmd0aCkge1xcbiAgICAgICAgICAgIHJidWdneVFTQS5wdXNoKFxcXCJuYW1lXFxcIiArIHdoaXRlc3BhY2UgKyBcXFwiKlsqXiR8IX5dPz1cXFwiKTtcXG4gICAgICAgICAgfSAvLyBGRiAzLjUgLSA6ZW5hYmxlZC86ZGlzYWJsZWQgYW5kIGhpZGRlbiBlbGVtZW50cyAoaGlkZGVuIGVsZW1lbnRzIGFyZSBzdGlsbCBlbmFibGVkKVxcbiAgICAgICAgICAvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xcblxcblxcbiAgICAgICAgICBpZiAoIWRpdi5xdWVyeVNlbGVjdG9yQWxsKFxcXCI6ZW5hYmxlZFxcXCIpLmxlbmd0aCkge1xcbiAgICAgICAgICAgIHJidWdneVFTQS5wdXNoKFxcXCI6ZW5hYmxlZFxcXCIsIFxcXCI6ZGlzYWJsZWRcXFwiKTtcXG4gICAgICAgICAgfSAvLyBPcGVyYSAxMC0xMSBkb2VzIG5vdCB0aHJvdyBvbiBwb3N0LWNvbW1hIGludmFsaWQgcHNldWRvc1xcblxcblxcbiAgICAgICAgICBkaXYucXVlcnlTZWxlY3RvckFsbChcXFwiKiw6eFxcXCIpO1xcbiAgICAgICAgICByYnVnZ3lRU0EucHVzaChcXFwiLC4qOlxcXCIpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciA9IHJuYXRpdmUudGVzdChtYXRjaGVzID0gZG9jRWxlbS5tYXRjaGVzIHx8IGRvY0VsZW0ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8IGRvY0VsZW0ubW96TWF0Y2hlc1NlbGVjdG9yIHx8IGRvY0VsZW0ub01hdGNoZXNTZWxlY3RvciB8fCBkb2NFbGVtLm1zTWF0Y2hlc1NlbGVjdG9yKSkge1xcbiAgICAgICAgYXNzZXJ0KGZ1bmN0aW9uIChkaXYpIHtcXG4gICAgICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIGl0J3MgcG9zc2libGUgdG8gZG8gbWF0Y2hlc1NlbGVjdG9yXFxuICAgICAgICAgIC8vIG9uIGEgZGlzY29ubmVjdGVkIG5vZGUgKElFIDkpXFxuICAgICAgICAgIHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggPSBtYXRjaGVzLmNhbGwoZGl2LCBcXFwiZGl2XFxcIik7IC8vIFRoaXMgc2hvdWxkIGZhaWwgd2l0aCBhbiBleGNlcHRpb25cXG4gICAgICAgICAgLy8gR2Vja28gZG9lcyBub3QgZXJyb3IsIHJldHVybnMgZmFsc2UgaW5zdGVhZFxcblxcbiAgICAgICAgICBtYXRjaGVzLmNhbGwoZGl2LCBcXFwiW3MhPScnXTp4XFxcIik7XFxuICAgICAgICAgIHJidWdneU1hdGNoZXMucHVzaChcXFwiIT1cXFwiLCBwc2V1ZG9zKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG5cXG4gICAgICByYnVnZ3lRU0EgPSByYnVnZ3lRU0EubGVuZ3RoICYmIG5ldyBSZWdFeHAocmJ1Z2d5UVNBLmpvaW4oXFxcInxcXFwiKSk7XFxuICAgICAgcmJ1Z2d5TWF0Y2hlcyA9IHJidWdneU1hdGNoZXMubGVuZ3RoICYmIG5ldyBSZWdFeHAocmJ1Z2d5TWF0Y2hlcy5qb2luKFxcXCJ8XFxcIikpO1xcbiAgICAgIC8qIENvbnRhaW5zXFxuICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xcblxcbiAgICAgIGhhc0NvbXBhcmUgPSBybmF0aXZlLnRlc3QoZG9jRWxlbS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbik7IC8vIEVsZW1lbnQgY29udGFpbnMgYW5vdGhlclxcbiAgICAgIC8vIFB1cnBvc2VmdWxseSBkb2VzIG5vdCBpbXBsZW1lbnQgaW5jbHVzaXZlIGRlc2NlbmRlbnRcXG4gICAgICAvLyBBcyBpbiwgYW4gZWxlbWVudCBkb2VzIG5vdCBjb250YWluIGl0c2VsZlxcblxcbiAgICAgIGNvbnRhaW5zID0gaGFzQ29tcGFyZSB8fCBybmF0aXZlLnRlc3QoZG9jRWxlbS5jb250YWlucykgPyBmdW5jdGlvbiAoYSwgYikge1xcbiAgICAgICAgdmFyIGFkb3duID0gYS5ub2RlVHlwZSA9PT0gOSA/IGEuZG9jdW1lbnRFbGVtZW50IDogYSxcXG4gICAgICAgICAgICBidXAgPSBiICYmIGIucGFyZW50Tm9kZTtcXG4gICAgICAgIHJldHVybiBhID09PSBidXAgfHwgISEoYnVwICYmIGJ1cC5ub2RlVHlwZSA9PT0gMSAmJiAoYWRvd24uY29udGFpbnMgPyBhZG93bi5jb250YWlucyhidXApIDogYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAmJiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGJ1cCkgJiAxNikpO1xcbiAgICAgIH0gOiBmdW5jdGlvbiAoYSwgYikge1xcbiAgICAgICAgaWYgKGIpIHtcXG4gICAgICAgICAgd2hpbGUgKGIgPSBiLnBhcmVudE5vZGUpIHtcXG4gICAgICAgICAgICBpZiAoYiA9PT0gYSkge1xcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfTtcXG4gICAgICAvKiBTb3J0aW5nXFxuICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xcbiAgICAgIC8vIERvY3VtZW50IG9yZGVyIHNvcnRpbmdcXG5cXG4gICAgICBzb3J0T3JkZXIgPSBoYXNDb21wYXJlID8gZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgICAgIC8vIEZsYWcgZm9yIGR1cGxpY2F0ZSByZW1vdmFsXFxuICAgICAgICBpZiAoYSA9PT0gYikge1xcbiAgICAgICAgICBoYXNEdXBsaWNhdGUgPSB0cnVlO1xcbiAgICAgICAgICByZXR1cm4gMDtcXG4gICAgICAgIH0gLy8gU29ydCBvbiBtZXRob2QgZXhpc3RlbmNlIGlmIG9ubHkgb25lIGlucHV0IGhhcyBjb21wYXJlRG9jdW1lbnRQb3NpdGlvblxcblxcblxcbiAgICAgICAgdmFyIGNvbXBhcmUgPSAhYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAtICFiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uO1xcblxcbiAgICAgICAgaWYgKGNvbXBhcmUpIHtcXG4gICAgICAgICAgcmV0dXJuIGNvbXBhcmU7XFxuICAgICAgICB9IC8vIENhbGN1bGF0ZSBwb3NpdGlvbiBpZiBib3RoIGlucHV0cyBiZWxvbmcgdG8gdGhlIHNhbWUgZG9jdW1lbnRcXG5cXG5cXG4gICAgICAgIGNvbXBhcmUgPSAoYS5vd25lckRvY3VtZW50IHx8IGEpID09PSAoYi5vd25lckRvY3VtZW50IHx8IGIpID8gYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihiKSA6IC8vIE90aGVyd2lzZSB3ZSBrbm93IHRoZXkgYXJlIGRpc2Nvbm5lY3RlZFxcbiAgICAgICAgMTsgLy8gRGlzY29ubmVjdGVkIG5vZGVzXFxuXFxuICAgICAgICBpZiAoY29tcGFyZSAmIDEgfHwgIXN1cHBvcnQuc29ydERldGFjaGVkICYmIGIuY29tcGFyZURvY3VtZW50UG9zaXRpb24oYSkgPT09IGNvbXBhcmUpIHtcXG4gICAgICAgICAgLy8gQ2hvb3NlIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgaXMgcmVsYXRlZCB0byBvdXIgcHJlZmVycmVkIGRvY3VtZW50XFxuICAgICAgICAgIGlmIChhID09PSBkb2MgfHwgYS5vd25lckRvY3VtZW50ID09PSBwcmVmZXJyZWREb2MgJiYgY29udGFpbnMocHJlZmVycmVkRG9jLCBhKSkge1xcbiAgICAgICAgICAgIHJldHVybiAtMTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAoYiA9PT0gZG9jIHx8IGIub3duZXJEb2N1bWVudCA9PT0gcHJlZmVycmVkRG9jICYmIGNvbnRhaW5zKHByZWZlcnJlZERvYywgYikpIHtcXG4gICAgICAgICAgICByZXR1cm4gMTtcXG4gICAgICAgICAgfSAvLyBNYWludGFpbiBvcmlnaW5hbCBvcmRlclxcblxcblxcbiAgICAgICAgICByZXR1cm4gc29ydElucHV0ID8gaW5kZXhPZihzb3J0SW5wdXQsIGEpIC0gaW5kZXhPZihzb3J0SW5wdXQsIGIpIDogMDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiBjb21wYXJlICYgNCA/IC0xIDogMTtcXG4gICAgICB9IDogZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgICAgIC8vIEV4aXQgZWFybHkgaWYgdGhlIG5vZGVzIGFyZSBpZGVudGljYWxcXG4gICAgICAgIGlmIChhID09PSBiKSB7XFxuICAgICAgICAgIGhhc0R1cGxpY2F0ZSA9IHRydWU7XFxuICAgICAgICAgIHJldHVybiAwO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdmFyIGN1cixcXG4gICAgICAgICAgICBpID0gMCxcXG4gICAgICAgICAgICBhdXAgPSBhLnBhcmVudE5vZGUsXFxuICAgICAgICAgICAgYnVwID0gYi5wYXJlbnROb2RlLFxcbiAgICAgICAgICAgIGFwID0gW2FdLFxcbiAgICAgICAgICAgIGJwID0gW2JdOyAvLyBQYXJlbnRsZXNzIG5vZGVzIGFyZSBlaXRoZXIgZG9jdW1lbnRzIG9yIGRpc2Nvbm5lY3RlZFxcblxcbiAgICAgICAgaWYgKCFhdXAgfHwgIWJ1cCkge1xcbiAgICAgICAgICByZXR1cm4gYSA9PT0gZG9jID8gLTEgOiBiID09PSBkb2MgPyAxIDogYXVwID8gLTEgOiBidXAgPyAxIDogc29ydElucHV0ID8gaW5kZXhPZihzb3J0SW5wdXQsIGEpIC0gaW5kZXhPZihzb3J0SW5wdXQsIGIpIDogMDsgLy8gSWYgdGhlIG5vZGVzIGFyZSBzaWJsaW5ncywgd2UgY2FuIGRvIGEgcXVpY2sgY2hlY2tcXG4gICAgICAgIH0gZWxzZSBpZiAoYXVwID09PSBidXApIHtcXG4gICAgICAgICAgcmV0dXJuIHNpYmxpbmdDaGVjayhhLCBiKTtcXG4gICAgICAgIH0gLy8gT3RoZXJ3aXNlIHdlIG5lZWQgZnVsbCBsaXN0cyBvZiB0aGVpciBhbmNlc3RvcnMgZm9yIGNvbXBhcmlzb25cXG5cXG5cXG4gICAgICAgIGN1ciA9IGE7XFxuXFxuICAgICAgICB3aGlsZSAoY3VyID0gY3VyLnBhcmVudE5vZGUpIHtcXG4gICAgICAgICAgYXAudW5zaGlmdChjdXIpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgY3VyID0gYjtcXG5cXG4gICAgICAgIHdoaWxlIChjdXIgPSBjdXIucGFyZW50Tm9kZSkge1xcbiAgICAgICAgICBicC51bnNoaWZ0KGN1cik7XFxuICAgICAgICB9IC8vIFdhbGsgZG93biB0aGUgdHJlZSBsb29raW5nIGZvciBhIGRpc2NyZXBhbmN5XFxuXFxuXFxuICAgICAgICB3aGlsZSAoYXBbaV0gPT09IGJwW2ldKSB7XFxuICAgICAgICAgIGkrKztcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiBpID8gLy8gRG8gYSBzaWJsaW5nIGNoZWNrIGlmIHRoZSBub2RlcyBoYXZlIGEgY29tbW9uIGFuY2VzdG9yXFxuICAgICAgICBzaWJsaW5nQ2hlY2soYXBbaV0sIGJwW2ldKSA6IC8vIE90aGVyd2lzZSBub2RlcyBpbiBvdXIgZG9jdW1lbnQgc29ydCBmaXJzdFxcbiAgICAgICAgYXBbaV0gPT09IHByZWZlcnJlZERvYyA/IC0xIDogYnBbaV0gPT09IHByZWZlcnJlZERvYyA/IDEgOiAwO1xcbiAgICAgIH07XFxuICAgICAgcmV0dXJuIGRvYztcXG4gICAgfTtcXG5cXG4gICAgU2l6emxlLm1hdGNoZXMgPSBmdW5jdGlvbiAoZXhwciwgZWxlbWVudHMpIHtcXG4gICAgICByZXR1cm4gU2l6emxlKGV4cHIsIG51bGwsIG51bGwsIGVsZW1lbnRzKTtcXG4gICAgfTtcXG5cXG4gICAgU2l6emxlLm1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uIChlbGVtLCBleHByKSB7XFxuICAgICAgLy8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXFxuICAgICAgaWYgKChlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSkgIT09IGRvY3VtZW50KSB7XFxuICAgICAgICBzZXREb2N1bWVudChlbGVtKTtcXG4gICAgICB9IC8vIE1ha2Ugc3VyZSB0aGF0IGF0dHJpYnV0ZSBzZWxlY3RvcnMgYXJlIHF1b3RlZFxcblxcblxcbiAgICAgIGV4cHIgPSBleHByLnJlcGxhY2UocmF0dHJpYnV0ZVF1b3RlcywgXFxcIj0nJDEnXVxcXCIpO1xcblxcbiAgICAgIGlmIChzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciAmJiBkb2N1bWVudElzSFRNTCAmJiAoIXJidWdneU1hdGNoZXMgfHwgIXJidWdneU1hdGNoZXMudGVzdChleHByKSkgJiYgKCFyYnVnZ3lRU0EgfHwgIXJidWdneVFTQS50ZXN0KGV4cHIpKSkge1xcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgdmFyIHJldCA9IG1hdGNoZXMuY2FsbChlbGVtLCBleHByKTsgLy8gSUUgOSdzIG1hdGNoZXNTZWxlY3RvciByZXR1cm5zIGZhbHNlIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xcblxcbiAgICAgICAgICBpZiAocmV0IHx8IHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggfHwgLy8gQXMgd2VsbCwgZGlzY29ubmVjdGVkIG5vZGVzIGFyZSBzYWlkIHRvIGJlIGluIGEgZG9jdW1lbnRcXG4gICAgICAgICAgLy8gZnJhZ21lbnQgaW4gSUUgOVxcbiAgICAgICAgICBlbGVtLmRvY3VtZW50ICYmIGVsZW0uZG9jdW1lbnQubm9kZVR5cGUgIT09IDExKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHJldDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBjYXRjaCAoZSkge31cXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIFNpenpsZShleHByLCBkb2N1bWVudCwgbnVsbCwgW2VsZW1dKS5sZW5ndGggPiAwO1xcbiAgICB9O1xcblxcbiAgICBTaXp6bGUuY29udGFpbnMgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlbSkge1xcbiAgICAgIC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxcbiAgICAgIGlmICgoY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQpICE9PSBkb2N1bWVudCkge1xcbiAgICAgICAgc2V0RG9jdW1lbnQoY29udGV4dCk7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBjb250YWlucyhjb250ZXh0LCBlbGVtKTtcXG4gICAgfTtcXG5cXG4gICAgU2l6emxlLmF0dHIgPSBmdW5jdGlvbiAoZWxlbSwgbmFtZSkge1xcbiAgICAgIC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxcbiAgICAgIGlmICgoZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0pICE9PSBkb2N1bWVudCkge1xcbiAgICAgICAgc2V0RG9jdW1lbnQoZWxlbSk7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBmbiA9IEV4cHIuYXR0ckhhbmRsZVtuYW1lLnRvTG93ZXJDYXNlKCldLFxcbiAgICAgICAgICAvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoalF1ZXJ5ICMxMzgwNylcXG4gICAgICB2YWwgPSBmbiAmJiBoYXNPd24uY2FsbChFeHByLmF0dHJIYW5kbGUsIG5hbWUudG9Mb3dlckNhc2UoKSkgPyBmbihlbGVtLCBuYW1lLCAhZG9jdW1lbnRJc0hUTUwpIDogdW5kZWZpbmVkO1xcbiAgICAgIHJldHVybiB2YWwgIT09IHVuZGVmaW5lZCA/IHZhbCA6IHN1cHBvcnQuYXR0cmlidXRlcyB8fCAhZG9jdW1lbnRJc0hUTUwgPyBlbGVtLmdldEF0dHJpYnV0ZShuYW1lKSA6ICh2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUobmFtZSkpICYmIHZhbC5zcGVjaWZpZWQgPyB2YWwudmFsdWUgOiBudWxsO1xcbiAgICB9O1xcblxcbiAgICBTaXp6bGUuZXJyb3IgPSBmdW5jdGlvbiAobXNnKSB7XFxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXCJTeW50YXggZXJyb3IsIHVucmVjb2duaXplZCBleHByZXNzaW9uOiBcXFwiICsgbXNnKTtcXG4gICAgfTtcXG4gICAgLyoqXFxuICAgICAqIERvY3VtZW50IHNvcnRpbmcgYW5kIHJlbW92aW5nIGR1cGxpY2F0ZXNcXG4gICAgICogQHBhcmFtIHtBcnJheUxpa2V9IHJlc3VsdHNcXG4gICAgICovXFxuXFxuXFxuICAgIFNpenpsZS51bmlxdWVTb3J0ID0gZnVuY3Rpb24gKHJlc3VsdHMpIHtcXG4gICAgICB2YXIgZWxlbSxcXG4gICAgICAgICAgZHVwbGljYXRlcyA9IFtdLFxcbiAgICAgICAgICBqID0gMCxcXG4gICAgICAgICAgaSA9IDA7IC8vIFVubGVzcyB3ZSAqa25vdyogd2UgY2FuIGRldGVjdCBkdXBsaWNhdGVzLCBhc3N1bWUgdGhlaXIgcHJlc2VuY2VcXG5cXG4gICAgICBoYXNEdXBsaWNhdGUgPSAhc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzO1xcbiAgICAgIHNvcnRJbnB1dCA9ICFzdXBwb3J0LnNvcnRTdGFibGUgJiYgcmVzdWx0cy5zbGljZSgwKTtcXG4gICAgICByZXN1bHRzLnNvcnQoc29ydE9yZGVyKTtcXG5cXG4gICAgICBpZiAoaGFzRHVwbGljYXRlKSB7XFxuICAgICAgICB3aGlsZSAoZWxlbSA9IHJlc3VsdHNbaSsrXSkge1xcbiAgICAgICAgICBpZiAoZWxlbSA9PT0gcmVzdWx0c1tpXSkge1xcbiAgICAgICAgICAgIGogPSBkdXBsaWNhdGVzLnB1c2goaSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHdoaWxlIChqLS0pIHtcXG4gICAgICAgICAgcmVzdWx0cy5zcGxpY2UoZHVwbGljYXRlc1tqXSwgMSk7XFxuICAgICAgICB9XFxuICAgICAgfSAvLyBDbGVhciBpbnB1dCBhZnRlciBzb3J0aW5nIHRvIHJlbGVhc2Ugb2JqZWN0c1xcbiAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L3NpenpsZS9wdWxsLzIyNVxcblxcblxcbiAgICAgIHNvcnRJbnB1dCA9IG51bGw7XFxuICAgICAgcmV0dXJuIHJlc3VsdHM7XFxuICAgIH07XFxuICAgIC8qKlxcbiAgICAgKiBVdGlsaXR5IGZ1bmN0aW9uIGZvciByZXRyaWV2aW5nIHRoZSB0ZXh0IHZhbHVlIG9mIGFuIGFycmF5IG9mIERPTSBub2Rlc1xcbiAgICAgKiBAcGFyYW0ge0FycmF5fEVsZW1lbnR9IGVsZW1cXG4gICAgICovXFxuXFxuXFxuICAgIGdldFRleHQgPSBTaXp6bGUuZ2V0VGV4dCA9IGZ1bmN0aW9uIChlbGVtKSB7XFxuICAgICAgdmFyIG5vZGUsXFxuICAgICAgICAgIHJldCA9IFxcXCJcXFwiLFxcbiAgICAgICAgICBpID0gMCxcXG4gICAgICAgICAgbm9kZVR5cGUgPSBlbGVtLm5vZGVUeXBlO1xcblxcbiAgICAgIGlmICghbm9kZVR5cGUpIHtcXG4gICAgICAgIC8vIElmIG5vIG5vZGVUeXBlLCB0aGlzIGlzIGV4cGVjdGVkIHRvIGJlIGFuIGFycmF5XFxuICAgICAgICB3aGlsZSAobm9kZSA9IGVsZW1baSsrXSkge1xcbiAgICAgICAgICAvLyBEbyBub3QgdHJhdmVyc2UgY29tbWVudCBub2Rlc1xcbiAgICAgICAgICByZXQgKz0gZ2V0VGV4dChub2RlKTtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2UgaWYgKG5vZGVUeXBlID09PSAxIHx8IG5vZGVUeXBlID09PSA5IHx8IG5vZGVUeXBlID09PSAxMSkge1xcbiAgICAgICAgLy8gVXNlIHRleHRDb250ZW50IGZvciBlbGVtZW50c1xcbiAgICAgICAgLy8gaW5uZXJUZXh0IHVzYWdlIHJlbW92ZWQgZm9yIGNvbnNpc3RlbmN5IG9mIG5ldyBsaW5lcyAoalF1ZXJ5ICMxMTE1MylcXG4gICAgICAgIGlmICh0eXBlb2YgZWxlbS50ZXh0Q29udGVudCA9PT0gXFxcInN0cmluZ1xcXCIpIHtcXG4gICAgICAgICAgcmV0dXJuIGVsZW0udGV4dENvbnRlbnQ7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAvLyBUcmF2ZXJzZSBpdHMgY2hpbGRyZW5cXG4gICAgICAgICAgZm9yIChlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZykge1xcbiAgICAgICAgICAgIHJldCArPSBnZXRUZXh0KGVsZW0pO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIGlmIChub2RlVHlwZSA9PT0gMyB8fCBub2RlVHlwZSA9PT0gNCkge1xcbiAgICAgICAgcmV0dXJuIGVsZW0ubm9kZVZhbHVlO1xcbiAgICAgIH0gLy8gRG8gbm90IGluY2x1ZGUgY29tbWVudCBvciBwcm9jZXNzaW5nIGluc3RydWN0aW9uIG5vZGVzXFxuXFxuXFxuICAgICAgcmV0dXJuIHJldDtcXG4gICAgfTtcXG5cXG4gICAgRXhwciA9IFNpenpsZS5zZWxlY3RvcnMgPSB7XFxuICAgICAgLy8gQ2FuIGJlIGFkanVzdGVkIGJ5IHRoZSB1c2VyXFxuICAgICAgY2FjaGVMZW5ndGg6IDUwLFxcbiAgICAgIGNyZWF0ZVBzZXVkbzogbWFya0Z1bmN0aW9uLFxcbiAgICAgIG1hdGNoOiBtYXRjaEV4cHIsXFxuICAgICAgYXR0ckhhbmRsZToge30sXFxuICAgICAgZmluZDoge30sXFxuICAgICAgcmVsYXRpdmU6IHtcXG4gICAgICAgIFxcXCI+XFxcIjoge1xcbiAgICAgICAgICBkaXI6IFxcXCJwYXJlbnROb2RlXFxcIixcXG4gICAgICAgICAgZmlyc3Q6IHRydWVcXG4gICAgICAgIH0sXFxuICAgICAgICBcXFwiIFxcXCI6IHtcXG4gICAgICAgICAgZGlyOiBcXFwicGFyZW50Tm9kZVxcXCJcXG4gICAgICAgIH0sXFxuICAgICAgICBcXFwiK1xcXCI6IHtcXG4gICAgICAgICAgZGlyOiBcXFwicHJldmlvdXNTaWJsaW5nXFxcIixcXG4gICAgICAgICAgZmlyc3Q6IHRydWVcXG4gICAgICAgIH0sXFxuICAgICAgICBcXFwiflxcXCI6IHtcXG4gICAgICAgICAgZGlyOiBcXFwicHJldmlvdXNTaWJsaW5nXFxcIlxcbiAgICAgICAgfVxcbiAgICAgIH0sXFxuICAgICAgcHJlRmlsdGVyOiB7XFxuICAgICAgICBcXFwiQVRUUlxcXCI6IGZ1bmN0aW9uIEFUVFIobWF0Y2gpIHtcXG4gICAgICAgICAgbWF0Y2hbMV0gPSBtYXRjaFsxXS5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKTsgLy8gTW92ZSB0aGUgZ2l2ZW4gdmFsdWUgdG8gbWF0Y2hbM10gd2hldGhlciBxdW90ZWQgb3IgdW5xdW90ZWRcXG5cXG4gICAgICAgICAgbWF0Y2hbM10gPSAobWF0Y2hbM10gfHwgbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXFxcIlxcXCIpLnJlcGxhY2UocnVuZXNjYXBlLCBmdW5lc2NhcGUpO1xcblxcbiAgICAgICAgICBpZiAobWF0Y2hbMl0gPT09IFxcXCJ+PVxcXCIpIHtcXG4gICAgICAgICAgICBtYXRjaFszXSA9IFxcXCIgXFxcIiArIG1hdGNoWzNdICsgXFxcIiBcXFwiO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHJldHVybiBtYXRjaC5zbGljZSgwLCA0KTtcXG4gICAgICAgIH0sXFxuICAgICAgICBcXFwiQ0hJTERcXFwiOiBmdW5jdGlvbiBDSElMRChtYXRjaCkge1xcbiAgICAgICAgICAvKiBtYXRjaGVzIGZyb20gbWF0Y2hFeHByW1xcXCJDSElMRFxcXCJdXFxuICAgICAgICAgIFxcdDEgdHlwZSAob25seXxudGh8Li4uKVxcbiAgICAgICAgICBcXHQyIHdoYXQgKGNoaWxkfG9mLXR5cGUpXFxuICAgICAgICAgIFxcdDMgYXJndW1lbnQgKGV2ZW58b2RkfFxcXFxkKnxcXFxcZCpuKFsrLV1cXFxcZCspP3wuLi4pXFxuICAgICAgICAgIFxcdDQgeG4tY29tcG9uZW50IG9mIHhuK3kgYXJndW1lbnQgKFsrLV0/XFxcXGQqbnwpXFxuICAgICAgICAgIFxcdDUgc2lnbiBvZiB4bi1jb21wb25lbnRcXG4gICAgICAgICAgXFx0NiB4IG9mIHhuLWNvbXBvbmVudFxcbiAgICAgICAgICBcXHQ3IHNpZ24gb2YgeS1jb21wb25lbnRcXG4gICAgICAgICAgXFx0OCB5IG9mIHktY29tcG9uZW50XFxuICAgICAgICAgICovXFxuICAgICAgICAgIG1hdGNoWzFdID0gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcXG5cXG4gICAgICAgICAgaWYgKG1hdGNoWzFdLnNsaWNlKDAsIDMpID09PSBcXFwibnRoXFxcIikge1xcbiAgICAgICAgICAgIC8vIG50aC0qIHJlcXVpcmVzIGFyZ3VtZW50XFxuICAgICAgICAgICAgaWYgKCFtYXRjaFszXSkge1xcbiAgICAgICAgICAgICAgU2l6emxlLmVycm9yKG1hdGNoWzBdKTtcXG4gICAgICAgICAgICB9IC8vIG51bWVyaWMgeCBhbmQgeSBwYXJhbWV0ZXJzIGZvciBFeHByLmZpbHRlci5DSElMRFxcbiAgICAgICAgICAgIC8vIHJlbWVtYmVyIHRoYXQgZmFsc2UvdHJ1ZSBjYXN0IHJlc3BlY3RpdmVseSB0byAwLzFcXG5cXG5cXG4gICAgICAgICAgICBtYXRjaFs0XSA9ICsobWF0Y2hbNF0gPyBtYXRjaFs1XSArIChtYXRjaFs2XSB8fCAxKSA6IDIgKiAobWF0Y2hbM10gPT09IFxcXCJldmVuXFxcIiB8fCBtYXRjaFszXSA9PT0gXFxcIm9kZFxcXCIpKTtcXG4gICAgICAgICAgICBtYXRjaFs1XSA9ICsobWF0Y2hbN10gKyBtYXRjaFs4XSB8fCBtYXRjaFszXSA9PT0gXFxcIm9kZFxcXCIpOyAvLyBvdGhlciB0eXBlcyBwcm9oaWJpdCBhcmd1bWVudHNcXG4gICAgICAgICAgfSBlbHNlIGlmIChtYXRjaFszXSkge1xcbiAgICAgICAgICAgIFNpenpsZS5lcnJvcihtYXRjaFswXSk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgcmV0dXJuIG1hdGNoO1xcbiAgICAgICAgfSxcXG4gICAgICAgIFxcXCJQU0VVRE9cXFwiOiBmdW5jdGlvbiBQU0VVRE8obWF0Y2gpIHtcXG4gICAgICAgICAgdmFyIGV4Y2VzcyxcXG4gICAgICAgICAgICAgIHVucXVvdGVkID0gIW1hdGNoWzZdICYmIG1hdGNoWzJdO1xcblxcbiAgICAgICAgICBpZiAobWF0Y2hFeHByW1xcXCJDSElMRFxcXCJdLnRlc3QobWF0Y2hbMF0pKSB7XFxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XFxuICAgICAgICAgIH0gLy8gQWNjZXB0IHF1b3RlZCBhcmd1bWVudHMgYXMtaXNcXG5cXG5cXG4gICAgICAgICAgaWYgKG1hdGNoWzNdKSB7XFxuICAgICAgICAgICAgbWF0Y2hbMl0gPSBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBcXFwiXFxcIjsgLy8gU3RyaXAgZXhjZXNzIGNoYXJhY3RlcnMgZnJvbSB1bnF1b3RlZCBhcmd1bWVudHNcXG4gICAgICAgICAgfSBlbHNlIGlmICh1bnF1b3RlZCAmJiBycHNldWRvLnRlc3QodW5xdW90ZWQpICYmICggLy8gR2V0IGV4Y2VzcyBmcm9tIHRva2VuaXplIChyZWN1cnNpdmVseSlcXG4gICAgICAgICAgZXhjZXNzID0gdG9rZW5pemUodW5xdW90ZWQsIHRydWUpKSAmJiAoIC8vIGFkdmFuY2UgdG8gdGhlIG5leHQgY2xvc2luZyBwYXJlbnRoZXNpc1xcbiAgICAgICAgICBleGNlc3MgPSB1bnF1b3RlZC5pbmRleE9mKFxcXCIpXFxcIiwgdW5xdW90ZWQubGVuZ3RoIC0gZXhjZXNzKSAtIHVucXVvdGVkLmxlbmd0aCkpIHtcXG4gICAgICAgICAgICAvLyBleGNlc3MgaXMgYSBuZWdhdGl2ZSBpbmRleFxcbiAgICAgICAgICAgIG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UoMCwgZXhjZXNzKTtcXG4gICAgICAgICAgICBtYXRjaFsyXSA9IHVucXVvdGVkLnNsaWNlKDAsIGV4Y2Vzcyk7XFxuICAgICAgICAgIH0gLy8gUmV0dXJuIG9ubHkgY2FwdHVyZXMgbmVlZGVkIGJ5IHRoZSBwc2V1ZG8gZmlsdGVyIG1ldGhvZCAodHlwZSBhbmQgYXJndW1lbnQpXFxuXFxuXFxuICAgICAgICAgIHJldHVybiBtYXRjaC5zbGljZSgwLCAzKTtcXG4gICAgICAgIH1cXG4gICAgICB9LFxcbiAgICAgIGZpbHRlcjoge1xcbiAgICAgICAgXFxcIlRBR1xcXCI6IGZ1bmN0aW9uIFRBRyhub2RlTmFtZVNlbGVjdG9yKSB7XFxuICAgICAgICAgIHZhciBub2RlTmFtZSA9IG5vZGVOYW1lU2VsZWN0b3IucmVwbGFjZShydW5lc2NhcGUsIGZ1bmVzY2FwZSkudG9Mb3dlckNhc2UoKTtcXG4gICAgICAgICAgcmV0dXJuIG5vZGVOYW1lU2VsZWN0b3IgPT09IFxcXCIqXFxcIiA/IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgICAgfSA6IGZ1bmN0aW9uIChlbGVtKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBub2RlTmFtZTtcXG4gICAgICAgICAgfTtcXG4gICAgICAgIH0sXFxuICAgICAgICBcXFwiQ0xBU1NcXFwiOiBmdW5jdGlvbiBDTEFTUyhjbGFzc05hbWUpIHtcXG4gICAgICAgICAgdmFyIHBhdHRlcm4gPSBjbGFzc0NhY2hlW2NsYXNzTmFtZSArIFxcXCIgXFxcIl07XFxuICAgICAgICAgIHJldHVybiBwYXR0ZXJuIHx8IChwYXR0ZXJuID0gbmV3IFJlZ0V4cChcXFwiKF58XFxcIiArIHdoaXRlc3BhY2UgKyBcXFwiKVxcXCIgKyBjbGFzc05hbWUgKyBcXFwiKFxcXCIgKyB3aGl0ZXNwYWNlICsgXFxcInwkKVxcXCIpKSAmJiBjbGFzc0NhY2hlKGNsYXNzTmFtZSwgZnVuY3Rpb24gKGVsZW0pIHtcXG4gICAgICAgICAgICByZXR1cm4gcGF0dGVybi50ZXN0KHR5cGVvZiBlbGVtLmNsYXNzTmFtZSA9PT0gXFxcInN0cmluZ1xcXCIgJiYgZWxlbS5jbGFzc05hbWUgfHwgdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlICE9PSBcXFwidW5kZWZpbmVkXFxcIiAmJiBlbGVtLmdldEF0dHJpYnV0ZShcXFwiY2xhc3NcXFwiKSB8fCBcXFwiXFxcIik7XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfSxcXG4gICAgICAgIFxcXCJBVFRSXFxcIjogZnVuY3Rpb24gQVRUUihuYW1lLCBvcGVyYXRvciwgY2hlY2spIHtcXG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtKSB7XFxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFNpenpsZS5hdHRyKGVsZW0sIG5hbWUpO1xcblxcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCkge1xcbiAgICAgICAgICAgICAgcmV0dXJuIG9wZXJhdG9yID09PSBcXFwiIT1cXFwiO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpZiAoIW9wZXJhdG9yKSB7XFxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgcmVzdWx0ICs9IFxcXCJcXFwiO1xcbiAgICAgICAgICAgIHJldHVybiBvcGVyYXRvciA9PT0gXFxcIj1cXFwiID8gcmVzdWx0ID09PSBjaGVjayA6IG9wZXJhdG9yID09PSBcXFwiIT1cXFwiID8gcmVzdWx0ICE9PSBjaGVjayA6IG9wZXJhdG9yID09PSBcXFwiXj1cXFwiID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoY2hlY2spID09PSAwIDogb3BlcmF0b3IgPT09IFxcXCIqPVxcXCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZihjaGVjaykgPiAtMSA6IG9wZXJhdG9yID09PSBcXFwiJD1cXFwiID8gY2hlY2sgJiYgcmVzdWx0LnNsaWNlKC1jaGVjay5sZW5ndGgpID09PSBjaGVjayA6IG9wZXJhdG9yID09PSBcXFwifj1cXFwiID8gKFxcXCIgXFxcIiArIHJlc3VsdC5yZXBsYWNlKHJ3aGl0ZXNwYWNlLCBcXFwiIFxcXCIpICsgXFxcIiBcXFwiKS5pbmRleE9mKGNoZWNrKSA+IC0xIDogb3BlcmF0b3IgPT09IFxcXCJ8PVxcXCIgPyByZXN1bHQgPT09IGNoZWNrIHx8IHJlc3VsdC5zbGljZSgwLCBjaGVjay5sZW5ndGggKyAxKSA9PT0gY2hlY2sgKyBcXFwiLVxcXCIgOiBmYWxzZTtcXG4gICAgICAgICAgfTtcXG4gICAgICAgIH0sXFxuICAgICAgICBcXFwiQ0hJTERcXFwiOiBmdW5jdGlvbiBDSElMRCh0eXBlLCB3aGF0LCBhcmd1bWVudCwgZmlyc3QsIGxhc3QpIHtcXG4gICAgICAgICAgdmFyIHNpbXBsZSA9IHR5cGUuc2xpY2UoMCwgMykgIT09IFxcXCJudGhcXFwiLFxcbiAgICAgICAgICAgICAgZm9yd2FyZCA9IHR5cGUuc2xpY2UoLTQpICE9PSBcXFwibGFzdFxcXCIsXFxuICAgICAgICAgICAgICBvZlR5cGUgPSB3aGF0ID09PSBcXFwib2YtdHlwZVxcXCI7XFxuICAgICAgICAgIHJldHVybiBmaXJzdCA9PT0gMSAmJiBsYXN0ID09PSAwID8gLy8gU2hvcnRjdXQgZm9yIDpudGgtKihuKVxcbiAgICAgICAgICBmdW5jdGlvbiAoZWxlbSkge1xcbiAgICAgICAgICAgIHJldHVybiAhIWVsZW0ucGFyZW50Tm9kZTtcXG4gICAgICAgICAgfSA6IGZ1bmN0aW9uIChlbGVtLCBjb250ZXh0LCB4bWwpIHtcXG4gICAgICAgICAgICB2YXIgY2FjaGUsXFxuICAgICAgICAgICAgICAgIG91dGVyQ2FjaGUsXFxuICAgICAgICAgICAgICAgIG5vZGUsXFxuICAgICAgICAgICAgICAgIGRpZmYsXFxuICAgICAgICAgICAgICAgIG5vZGVJbmRleCxcXG4gICAgICAgICAgICAgICAgc3RhcnQsXFxuICAgICAgICAgICAgICAgIGRpciA9IHNpbXBsZSAhPT0gZm9yd2FyZCA/IFxcXCJuZXh0U2libGluZ1xcXCIgOiBcXFwicHJldmlvdXNTaWJsaW5nXFxcIixcXG4gICAgICAgICAgICAgICAgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlLFxcbiAgICAgICAgICAgICAgICBuYW1lID0gb2ZUeXBlICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcXG4gICAgICAgICAgICAgICAgdXNlQ2FjaGUgPSAheG1sICYmICFvZlR5cGU7XFxuXFxuICAgICAgICAgICAgaWYgKHBhcmVudCkge1xcbiAgICAgICAgICAgICAgLy8gOihmaXJzdHxsYXN0fG9ubHkpLShjaGlsZHxvZi10eXBlKVxcbiAgICAgICAgICAgICAgaWYgKHNpbXBsZSkge1xcbiAgICAgICAgICAgICAgICB3aGlsZSAoZGlyKSB7XFxuICAgICAgICAgICAgICAgICAgbm9kZSA9IGVsZW07XFxuXFxuICAgICAgICAgICAgICAgICAgd2hpbGUgKG5vZGUgPSBub2RlW2Rpcl0pIHtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChvZlR5cGUgPyBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOiBub2RlLm5vZGVUeXBlID09PSAxKSB7XFxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICB9IC8vIFJldmVyc2UgZGlyZWN0aW9uIGZvciA6b25seS0qIChpZiB3ZSBoYXZlbid0IHlldCBkb25lIHNvKVxcblxcblxcbiAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gZGlyID0gdHlwZSA9PT0gXFxcIm9ubHlcXFwiICYmICFzdGFydCAmJiBcXFwibmV4dFNpYmxpbmdcXFwiO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgc3RhcnQgPSBbZm9yd2FyZCA/IHBhcmVudC5maXJzdENoaWxkIDogcGFyZW50Lmxhc3RDaGlsZF07IC8vIG5vbi14bWwgOm50aC1jaGlsZCguLi4pIHN0b3JlcyBjYWNoZSBkYXRhIG9uIGBwYXJlbnRgXFxuXFxuICAgICAgICAgICAgICBpZiAoZm9yd2FyZCAmJiB1c2VDYWNoZSkge1xcbiAgICAgICAgICAgICAgICAvLyBTZWVrIGBlbGVtYCBmcm9tIGEgcHJldmlvdXNseS1jYWNoZWQgaW5kZXhcXG4gICAgICAgICAgICAgICAgb3V0ZXJDYWNoZSA9IHBhcmVudFtleHBhbmRvXSB8fCAocGFyZW50W2V4cGFuZG9dID0ge30pO1xcbiAgICAgICAgICAgICAgICBjYWNoZSA9IG91dGVyQ2FjaGVbdHlwZV0gfHwgW107XFxuICAgICAgICAgICAgICAgIG5vZGVJbmRleCA9IGNhY2hlWzBdID09PSBkaXJydW5zICYmIGNhY2hlWzFdO1xcbiAgICAgICAgICAgICAgICBkaWZmID0gY2FjaGVbMF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbMl07XFxuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlSW5kZXggJiYgcGFyZW50LmNoaWxkTm9kZXNbbm9kZUluZGV4XTtcXG5cXG4gICAgICAgICAgICAgICAgd2hpbGUgKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbZGlyXSB8fCAoIC8vIEZhbGxiYWNrIHRvIHNlZWtpbmcgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XFxuICAgICAgICAgICAgICAgIGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkge1xcbiAgICAgICAgICAgICAgICAgIC8vIFdoZW4gZm91bmQsIGNhY2hlIGluZGV4ZXMgb24gYHBhcmVudGAgYW5kIGJyZWFrXFxuICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEgJiYgKytkaWZmICYmIG5vZGUgPT09IGVsZW0pIHtcXG4gICAgICAgICAgICAgICAgICAgIG91dGVyQ2FjaGVbdHlwZV0gPSBbZGlycnVucywgbm9kZUluZGV4LCBkaWZmXTtcXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfSAvLyBVc2UgcHJldmlvdXNseS1jYWNoZWQgZWxlbWVudCBpbmRleCBpZiBhdmFpbGFibGVcXG5cXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodXNlQ2FjaGUgJiYgKGNhY2hlID0gKGVsZW1bZXhwYW5kb10gfHwgKGVsZW1bZXhwYW5kb10gPSB7fSkpW3R5cGVdKSAmJiBjYWNoZVswXSA9PT0gZGlycnVucykge1xcbiAgICAgICAgICAgICAgICBkaWZmID0gY2FjaGVbMV07IC8vIHhtbCA6bnRoLWNoaWxkKC4uLikgb3IgOm50aC1sYXN0LWNoaWxkKC4uLikgb3IgOm50aCgtbGFzdCk/LW9mLXR5cGUoLi4uKVxcbiAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgLy8gVXNlIHRoZSBzYW1lIGxvb3AgYXMgYWJvdmUgdG8gc2VlayBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcXG4gICAgICAgICAgICAgICAgd2hpbGUgKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbZGlyXSB8fCAoZGlmZiA9IG5vZGVJbmRleCA9IDApIHx8IHN0YXJ0LnBvcCgpKSB7XFxuICAgICAgICAgICAgICAgICAgaWYgKChvZlR5cGUgPyBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOiBub2RlLm5vZGVUeXBlID09PSAxKSAmJiArK2RpZmYpIHtcXG4gICAgICAgICAgICAgICAgICAgIC8vIENhY2hlIHRoZSBpbmRleCBvZiBlYWNoIGVuY291bnRlcmVkIGVsZW1lbnRcXG4gICAgICAgICAgICAgICAgICAgIGlmICh1c2VDYWNoZSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAobm9kZVtleHBhbmRvXSB8fCAobm9kZVtleHBhbmRvXSA9IHt9KSlbdHlwZV0gPSBbZGlycnVucywgZGlmZl07XFxuICAgICAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSA9PT0gZWxlbSkge1xcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIH0gLy8gSW5jb3Jwb3JhdGUgdGhlIG9mZnNldCwgdGhlbiBjaGVjayBhZ2FpbnN0IGN5Y2xlIHNpemVcXG5cXG5cXG4gICAgICAgICAgICAgIGRpZmYgLT0gbGFzdDtcXG4gICAgICAgICAgICAgIHJldHVybiBkaWZmID09PSBmaXJzdCB8fCBkaWZmICUgZmlyc3QgPT09IDAgJiYgZGlmZiAvIGZpcnN0ID49IDA7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9O1xcbiAgICAgICAgfSxcXG4gICAgICAgIFxcXCJQU0VVRE9cXFwiOiBmdW5jdGlvbiBQU0VVRE8ocHNldWRvLCBhcmd1bWVudCkge1xcbiAgICAgICAgICAvLyBwc2V1ZG8tY2xhc3MgbmFtZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmVcXG4gICAgICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNwc2V1ZG8tY2xhc3Nlc1xcbiAgICAgICAgICAvLyBQcmlvcml0aXplIGJ5IGNhc2Ugc2Vuc2l0aXZpdHkgaW4gY2FzZSBjdXN0b20gcHNldWRvcyBhcmUgYWRkZWQgd2l0aCB1cHBlcmNhc2UgbGV0dGVyc1xcbiAgICAgICAgICAvLyBSZW1lbWJlciB0aGF0IHNldEZpbHRlcnMgaW5oZXJpdHMgZnJvbSBwc2V1ZG9zXFxuICAgICAgICAgIHZhciBhcmdzLFxcbiAgICAgICAgICAgICAgZm4gPSBFeHByLnBzZXVkb3NbcHNldWRvXSB8fCBFeHByLnNldEZpbHRlcnNbcHNldWRvLnRvTG93ZXJDYXNlKCldIHx8IFNpenpsZS5lcnJvcihcXFwidW5zdXBwb3J0ZWQgcHNldWRvOiBcXFwiICsgcHNldWRvKTsgLy8gVGhlIHVzZXIgbWF5IHVzZSBjcmVhdGVQc2V1ZG8gdG8gaW5kaWNhdGUgdGhhdFxcbiAgICAgICAgICAvLyBhcmd1bWVudHMgYXJlIG5lZWRlZCB0byBjcmVhdGUgdGhlIGZpbHRlciBmdW5jdGlvblxcbiAgICAgICAgICAvLyBqdXN0IGFzIFNpenpsZSBkb2VzXFxuXFxuICAgICAgICAgIGlmIChmbltleHBhbmRvXSkge1xcbiAgICAgICAgICAgIHJldHVybiBmbihhcmd1bWVudCk7XFxuICAgICAgICAgIH0gLy8gQnV0IG1haW50YWluIHN1cHBvcnQgZm9yIG9sZCBzaWduYXR1cmVzXFxuXFxuXFxuICAgICAgICAgIGlmIChmbi5sZW5ndGggPiAxKSB7XFxuICAgICAgICAgICAgYXJncyA9IFtwc2V1ZG8sIHBzZXVkbywgXFxcIlxcXCIsIGFyZ3VtZW50XTtcXG4gICAgICAgICAgICByZXR1cm4gRXhwci5zZXRGaWx0ZXJzLmhhc093blByb3BlcnR5KHBzZXVkby50b0xvd2VyQ2FzZSgpKSA/IG1hcmtGdW5jdGlvbihmdW5jdGlvbiAoc2VlZCwgbWF0Y2hlcykge1xcbiAgICAgICAgICAgICAgdmFyIGlkeCxcXG4gICAgICAgICAgICAgICAgICBtYXRjaGVkID0gZm4oc2VlZCwgYXJndW1lbnQpLFxcbiAgICAgICAgICAgICAgICAgIGkgPSBtYXRjaGVkLmxlbmd0aDtcXG5cXG4gICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcXG4gICAgICAgICAgICAgICAgaWR4ID0gaW5kZXhPZihzZWVkLCBtYXRjaGVkW2ldKTtcXG4gICAgICAgICAgICAgICAgc2VlZFtpZHhdID0gIShtYXRjaGVzW2lkeF0gPSBtYXRjaGVkW2ldKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KSA6IGZ1bmN0aW9uIChlbGVtKSB7XFxuICAgICAgICAgICAgICByZXR1cm4gZm4oZWxlbSwgMCwgYXJncyk7XFxuICAgICAgICAgICAgfTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICByZXR1cm4gZm47XFxuICAgICAgICB9XFxuICAgICAgfSxcXG4gICAgICBwc2V1ZG9zOiB7XFxuICAgICAgICAvLyBQb3RlbnRpYWxseSBjb21wbGV4IHBzZXVkb3NcXG4gICAgICAgIFxcXCJub3RcXFwiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24gKHNlbGVjdG9yKSB7XFxuICAgICAgICAgIC8vIFRyaW0gdGhlIHNlbGVjdG9yIHBhc3NlZCB0byBjb21waWxlXFxuICAgICAgICAgIC8vIHRvIGF2b2lkIHRyZWF0aW5nIGxlYWRpbmcgYW5kIHRyYWlsaW5nXFxuICAgICAgICAgIC8vIHNwYWNlcyBhcyBjb21iaW5hdG9yc1xcbiAgICAgICAgICB2YXIgaW5wdXQgPSBbXSxcXG4gICAgICAgICAgICAgIHJlc3VsdHMgPSBbXSxcXG4gICAgICAgICAgICAgIG1hdGNoZXIgPSBjb21waWxlKHNlbGVjdG9yLnJlcGxhY2UocnRyaW0sIFxcXCIkMVxcXCIpKTtcXG4gICAgICAgICAgcmV0dXJuIG1hdGNoZXJbZXhwYW5kb10gPyBtYXJrRnVuY3Rpb24oZnVuY3Rpb24gKHNlZWQsIG1hdGNoZXMsIGNvbnRleHQsIHhtbCkge1xcbiAgICAgICAgICAgIHZhciBlbGVtLFxcbiAgICAgICAgICAgICAgICB1bm1hdGNoZWQgPSBtYXRjaGVyKHNlZWQsIG51bGwsIHhtbCwgW10pLFxcbiAgICAgICAgICAgICAgICBpID0gc2VlZC5sZW5ndGg7IC8vIE1hdGNoIGVsZW1lbnRzIHVubWF0Y2hlZCBieSBgbWF0Y2hlcmBcXG5cXG4gICAgICAgICAgICB3aGlsZSAoaS0tKSB7XFxuICAgICAgICAgICAgICBpZiAoZWxlbSA9IHVubWF0Y2hlZFtpXSkge1xcbiAgICAgICAgICAgICAgICBzZWVkW2ldID0gIShtYXRjaGVzW2ldID0gZWxlbSk7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9KSA6IGZ1bmN0aW9uIChlbGVtLCBjb250ZXh0LCB4bWwpIHtcXG4gICAgICAgICAgICBpbnB1dFswXSA9IGVsZW07XFxuICAgICAgICAgICAgbWF0Y2hlcihpbnB1dCwgbnVsbCwgeG1sLCByZXN1bHRzKTsgLy8gRG9uJ3Qga2VlcCB0aGUgZWxlbWVudCAoaXNzdWUgIzI5OSlcXG5cXG4gICAgICAgICAgICBpbnB1dFswXSA9IG51bGw7XFxuICAgICAgICAgICAgcmV0dXJuICFyZXN1bHRzLnBvcCgpO1xcbiAgICAgICAgICB9O1xcbiAgICAgICAgfSksXFxuICAgICAgICBcXFwiaGFzXFxcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uIChzZWxlY3Rvcikge1xcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVsZW0pIHtcXG4gICAgICAgICAgICByZXR1cm4gU2l6emxlKHNlbGVjdG9yLCBlbGVtKS5sZW5ndGggPiAwO1xcbiAgICAgICAgICB9O1xcbiAgICAgICAgfSksXFxuICAgICAgICBcXFwiY29udGFpbnNcXFwiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24gKHRleHQpIHtcXG4gICAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZShydW5lc2NhcGUsIGZ1bmVzY2FwZSk7XFxuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZWxlbSkge1xcbiAgICAgICAgICAgIHJldHVybiAoZWxlbS50ZXh0Q29udGVudCB8fCBlbGVtLmlubmVyVGV4dCB8fCBnZXRUZXh0KGVsZW0pKS5pbmRleE9mKHRleHQpID4gLTE7XFxuICAgICAgICAgIH07XFxuICAgICAgICB9KSxcXG4gICAgICAgIC8vIFxcXCJXaGV0aGVyIGFuIGVsZW1lbnQgaXMgcmVwcmVzZW50ZWQgYnkgYSA6bGFuZygpIHNlbGVjdG9yXFxuICAgICAgICAvLyBpcyBiYXNlZCBzb2xlbHkgb24gdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZVxcbiAgICAgICAgLy8gYmVpbmcgZXF1YWwgdG8gdGhlIGlkZW50aWZpZXIgQyxcXG4gICAgICAgIC8vIG9yIGJlZ2lubmluZyB3aXRoIHRoZSBpZGVudGlmaWVyIEMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgXFxcIi1cXFwiLlxcbiAgICAgICAgLy8gVGhlIG1hdGNoaW5nIG9mIEMgYWdhaW5zdCB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlIGlzIHBlcmZvcm1lZCBjYXNlLWluc2Vuc2l0aXZlbHkuXFxuICAgICAgICAvLyBUaGUgaWRlbnRpZmllciBDIGRvZXMgbm90IGhhdmUgdG8gYmUgYSB2YWxpZCBsYW5ndWFnZSBuYW1lLlxcXCJcXG4gICAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jbGFuZy1wc2V1ZG9cXG4gICAgICAgIFxcXCJsYW5nXFxcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uIChsYW5nKSB7XFxuICAgICAgICAgIC8vIGxhbmcgdmFsdWUgbXVzdCBiZSBhIHZhbGlkIGlkZW50aWZpZXJcXG4gICAgICAgICAgaWYgKCFyaWRlbnRpZmllci50ZXN0KGxhbmcgfHwgXFxcIlxcXCIpKSB7XFxuICAgICAgICAgICAgU2l6emxlLmVycm9yKFxcXCJ1bnN1cHBvcnRlZCBsYW5nOiBcXFwiICsgbGFuZyk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgbGFuZyA9IGxhbmcucmVwbGFjZShydW5lc2NhcGUsIGZ1bmVzY2FwZSkudG9Mb3dlckNhc2UoKTtcXG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtKSB7XFxuICAgICAgICAgICAgdmFyIGVsZW1MYW5nO1xcblxcbiAgICAgICAgICAgIGRvIHtcXG4gICAgICAgICAgICAgIGlmIChlbGVtTGFuZyA9IGRvY3VtZW50SXNIVE1MID8gZWxlbS5sYW5nIDogZWxlbS5nZXRBdHRyaWJ1dGUoXFxcInhtbDpsYW5nXFxcIikgfHwgZWxlbS5nZXRBdHRyaWJ1dGUoXFxcImxhbmdcXFwiKSkge1xcbiAgICAgICAgICAgICAgICBlbGVtTGFuZyA9IGVsZW1MYW5nLnRvTG93ZXJDYXNlKCk7XFxuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtTGFuZyA9PT0gbGFuZyB8fCBlbGVtTGFuZy5pbmRleE9mKGxhbmcgKyBcXFwiLVxcXCIpID09PSAwO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0gd2hpbGUgKChlbGVtID0gZWxlbS5wYXJlbnROb2RlKSAmJiBlbGVtLm5vZGVUeXBlID09PSAxKTtcXG5cXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICAgIH07XFxuICAgICAgICB9KSxcXG4gICAgICAgIC8vIE1pc2NlbGxhbmVvdXNcXG4gICAgICAgIFxcXCJ0YXJnZXRcXFwiOiBmdW5jdGlvbiB0YXJnZXQoZWxlbSkge1xcbiAgICAgICAgICB2YXIgaGFzaCA9IHdpbmRvdy5sb2NhdGlvbiAmJiB3aW5kb3cubG9jYXRpb24uaGFzaDtcXG4gICAgICAgICAgcmV0dXJuIGhhc2ggJiYgaGFzaC5zbGljZSgxKSA9PT0gZWxlbS5pZDtcXG4gICAgICAgIH0sXFxuICAgICAgICBcXFwicm9vdFxcXCI6IGZ1bmN0aW9uIHJvb3QoZWxlbSkge1xcbiAgICAgICAgICByZXR1cm4gZWxlbSA9PT0gZG9jRWxlbTtcXG4gICAgICAgIH0sXFxuICAgICAgICBcXFwiZm9jdXNcXFwiOiBmdW5jdGlvbiBmb2N1cyhlbGVtKSB7XFxuICAgICAgICAgIHJldHVybiBlbGVtID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmICghZG9jdW1lbnQuaGFzRm9jdXMgfHwgZG9jdW1lbnQuaGFzRm9jdXMoKSkgJiYgISEoZWxlbS50eXBlIHx8IGVsZW0uaHJlZiB8fCB+ZWxlbS50YWJJbmRleCk7XFxuICAgICAgICB9LFxcbiAgICAgICAgLy8gQm9vbGVhbiBwcm9wZXJ0aWVzXFxuICAgICAgICBcXFwiZW5hYmxlZFxcXCI6IGZ1bmN0aW9uIGVuYWJsZWQoZWxlbSkge1xcbiAgICAgICAgICByZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZmFsc2U7XFxuICAgICAgICB9LFxcbiAgICAgICAgXFxcImRpc2FibGVkXFxcIjogZnVuY3Rpb24gZGlzYWJsZWQoZWxlbSkge1xcbiAgICAgICAgICByZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gdHJ1ZTtcXG4gICAgICAgIH0sXFxuICAgICAgICBcXFwiY2hlY2tlZFxcXCI6IGZ1bmN0aW9uIGNoZWNrZWQoZWxlbSkge1xcbiAgICAgICAgICAvLyBJbiBDU1MzLCA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIGJvdGggY2hlY2tlZCBhbmQgc2VsZWN0ZWQgZWxlbWVudHNcXG4gICAgICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcXG4gICAgICAgICAgdmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xcbiAgICAgICAgICByZXR1cm4gbm9kZU5hbWUgPT09IFxcXCJpbnB1dFxcXCIgJiYgISFlbGVtLmNoZWNrZWQgfHwgbm9kZU5hbWUgPT09IFxcXCJvcHRpb25cXFwiICYmICEhZWxlbS5zZWxlY3RlZDtcXG4gICAgICAgIH0sXFxuICAgICAgICBcXFwic2VsZWN0ZWRcXFwiOiBmdW5jdGlvbiBzZWxlY3RlZChlbGVtKSB7XFxuICAgICAgICAgIC8vIEFjY2Vzc2luZyB0aGlzIHByb3BlcnR5IG1ha2VzIHNlbGVjdGVkLWJ5LWRlZmF1bHRcXG4gICAgICAgICAgLy8gb3B0aW9ucyBpbiBTYWZhcmkgd29yayBwcm9wZXJseVxcbiAgICAgICAgICBpZiAoZWxlbS5wYXJlbnROb2RlKSB7XFxuICAgICAgICAgICAgZWxlbS5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgcmV0dXJuIGVsZW0uc2VsZWN0ZWQgPT09IHRydWU7XFxuICAgICAgICB9LFxcbiAgICAgICAgLy8gQ29udGVudHNcXG4gICAgICAgIFxcXCJlbXB0eVxcXCI6IGZ1bmN0aW9uIGVtcHR5KGVsZW0pIHtcXG4gICAgICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNlbXB0eS1wc2V1ZG9cXG4gICAgICAgICAgLy8gOmVtcHR5IGlzIG5lZ2F0ZWQgYnkgZWxlbWVudCAoMSkgb3IgY29udGVudCBub2RlcyAodGV4dDogMzsgY2RhdGE6IDQ7IGVudGl0eSByZWY6IDUpLFxcbiAgICAgICAgICAvLyAgIGJ1dCBub3QgYnkgb3RoZXJzIChjb21tZW50OiA4OyBwcm9jZXNzaW5nIGluc3RydWN0aW9uOiA3OyBldGMuKVxcbiAgICAgICAgICAvLyBub2RlVHlwZSA8IDYgd29ya3MgYmVjYXVzZSBhdHRyaWJ1dGVzICgyKSBkbyBub3QgYXBwZWFyIGFzIGNoaWxkcmVuXFxuICAgICAgICAgIGZvciAoZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcpIHtcXG4gICAgICAgICAgICBpZiAoZWxlbS5ub2RlVHlwZSA8IDYpIHtcXG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgICB9LFxcbiAgICAgICAgXFxcInBhcmVudFxcXCI6IGZ1bmN0aW9uIHBhcmVudChlbGVtKSB7XFxuICAgICAgICAgIHJldHVybiAhRXhwci5wc2V1ZG9zW1xcXCJlbXB0eVxcXCJdKGVsZW0pO1xcbiAgICAgICAgfSxcXG4gICAgICAgIC8vIEVsZW1lbnQvaW5wdXQgdHlwZXNcXG4gICAgICAgIFxcXCJoZWFkZXJcXFwiOiBmdW5jdGlvbiBoZWFkZXIoZWxlbSkge1xcbiAgICAgICAgICByZXR1cm4gcmhlYWRlci50ZXN0KGVsZW0ubm9kZU5hbWUpO1xcbiAgICAgICAgfSxcXG4gICAgICAgIFxcXCJpbnB1dFxcXCI6IGZ1bmN0aW9uIGlucHV0KGVsZW0pIHtcXG4gICAgICAgICAgcmV0dXJuIHJpbnB1dHMudGVzdChlbGVtLm5vZGVOYW1lKTtcXG4gICAgICAgIH0sXFxuICAgICAgICBcXFwiYnV0dG9uXFxcIjogZnVuY3Rpb24gYnV0dG9uKGVsZW0pIHtcXG4gICAgICAgICAgdmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XFxuICAgICAgICAgIHJldHVybiBuYW1lID09PSBcXFwiaW5wdXRcXFwiICYmIGVsZW0udHlwZSA9PT0gXFxcImJ1dHRvblxcXCIgfHwgbmFtZSA9PT0gXFxcImJ1dHRvblxcXCI7XFxuICAgICAgICB9LFxcbiAgICAgICAgXFxcInRleHRcXFwiOiBmdW5jdGlvbiB0ZXh0KGVsZW0pIHtcXG4gICAgICAgICAgdmFyIGF0dHI7XFxuICAgICAgICAgIHJldHVybiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFxcXCJpbnB1dFxcXCIgJiYgZWxlbS50eXBlID09PSBcXFwidGV4dFxcXCIgJiYgKCAvLyBTdXBwb3J0OiBJRTw4XFxuICAgICAgICAgIC8vIE5ldyBIVE1MNSBhdHRyaWJ1dGUgdmFsdWVzIChlLmcuLCBcXFwic2VhcmNoXFxcIikgYXBwZWFyIHdpdGggZWxlbS50eXBlID09PSBcXFwidGV4dFxcXCJcXG4gICAgICAgICAgKGF0dHIgPSBlbGVtLmdldEF0dHJpYnV0ZShcXFwidHlwZVxcXCIpKSA9PSBudWxsIHx8IGF0dHIudG9Mb3dlckNhc2UoKSA9PT0gXFxcInRleHRcXFwiKTtcXG4gICAgICAgIH0sXFxuICAgICAgICAvLyBQb3NpdGlvbi1pbi1jb2xsZWN0aW9uXFxuICAgICAgICBcXFwiZmlyc3RcXFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgcmV0dXJuIFswXTtcXG4gICAgICAgIH0pLFxcbiAgICAgICAgXFxcImxhc3RcXFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uIChtYXRjaEluZGV4ZXMsIGxlbmd0aCkge1xcbiAgICAgICAgICByZXR1cm4gW2xlbmd0aCAtIDFdO1xcbiAgICAgICAgfSksXFxuICAgICAgICBcXFwiZXFcXFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uIChtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQpIHtcXG4gICAgICAgICAgcmV0dXJuIFthcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50XTtcXG4gICAgICAgIH0pLFxcbiAgICAgICAgXFxcImV2ZW5cXFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uIChtYXRjaEluZGV4ZXMsIGxlbmd0aCkge1xcbiAgICAgICAgICB2YXIgaSA9IDA7XFxuXFxuICAgICAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpICs9IDIpIHtcXG4gICAgICAgICAgICBtYXRjaEluZGV4ZXMucHVzaChpKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICByZXR1cm4gbWF0Y2hJbmRleGVzO1xcbiAgICAgICAgfSksXFxuICAgICAgICBcXFwib2RkXFxcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiAobWF0Y2hJbmRleGVzLCBsZW5ndGgpIHtcXG4gICAgICAgICAgdmFyIGkgPSAxO1xcblxcbiAgICAgICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSArPSAyKSB7XFxuICAgICAgICAgICAgbWF0Y2hJbmRleGVzLnB1c2goaSk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgcmV0dXJuIG1hdGNoSW5kZXhlcztcXG4gICAgICAgIH0pLFxcbiAgICAgICAgXFxcImx0XFxcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiAobWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50KSB7XFxuICAgICAgICAgIHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcXG5cXG4gICAgICAgICAgZm9yICg7IC0taSA+PSAwOykge1xcbiAgICAgICAgICAgIG1hdGNoSW5kZXhlcy5wdXNoKGkpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHJldHVybiBtYXRjaEluZGV4ZXM7XFxuICAgICAgICB9KSxcXG4gICAgICAgIFxcXCJndFxcXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24gKG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCkge1xcbiAgICAgICAgICB2YXIgaSA9IGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQ7XFxuXFxuICAgICAgICAgIGZvciAoOyArK2kgPCBsZW5ndGg7KSB7XFxuICAgICAgICAgICAgbWF0Y2hJbmRleGVzLnB1c2goaSk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgcmV0dXJuIG1hdGNoSW5kZXhlcztcXG4gICAgICAgIH0pXFxuICAgICAgfVxcbiAgICB9O1xcbiAgICBFeHByLnBzZXVkb3NbXFxcIm50aFxcXCJdID0gRXhwci5wc2V1ZG9zW1xcXCJlcVxcXCJdOyAvLyBBZGQgYnV0dG9uL2lucHV0IHR5cGUgcHNldWRvc1xcblxcbiAgICBmb3IgKGkgaW4ge1xcbiAgICAgIHJhZGlvOiB0cnVlLFxcbiAgICAgIGNoZWNrYm94OiB0cnVlLFxcbiAgICAgIGZpbGU6IHRydWUsXFxuICAgICAgcGFzc3dvcmQ6IHRydWUsXFxuICAgICAgaW1hZ2U6IHRydWVcXG4gICAgfSkge1xcbiAgICAgIEV4cHIucHNldWRvc1tpXSA9IGNyZWF0ZUlucHV0UHNldWRvKGkpO1xcbiAgICB9XFxuXFxuICAgIGZvciAoaSBpbiB7XFxuICAgICAgc3VibWl0OiB0cnVlLFxcbiAgICAgIHJlc2V0OiB0cnVlXFxuICAgIH0pIHtcXG4gICAgICBFeHByLnBzZXVkb3NbaV0gPSBjcmVhdGVCdXR0b25Qc2V1ZG8oaSk7XFxuICAgIH0gLy8gRWFzeSBBUEkgZm9yIGNyZWF0aW5nIG5ldyBzZXRGaWx0ZXJzXFxuXFxuXFxuICAgIGZ1bmN0aW9uIHNldEZpbHRlcnMoKSB7fVxcblxcbiAgICBzZXRGaWx0ZXJzLnByb3RvdHlwZSA9IEV4cHIuZmlsdGVycyA9IEV4cHIucHNldWRvcztcXG4gICAgRXhwci5zZXRGaWx0ZXJzID0gbmV3IHNldEZpbHRlcnMoKTtcXG5cXG4gICAgdG9rZW5pemUgPSBTaXp6bGUudG9rZW5pemUgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIHBhcnNlT25seSkge1xcbiAgICAgIHZhciBtYXRjaGVkLFxcbiAgICAgICAgICBtYXRjaCxcXG4gICAgICAgICAgdG9rZW5zLFxcbiAgICAgICAgICB0eXBlLFxcbiAgICAgICAgICBzb0ZhcixcXG4gICAgICAgICAgZ3JvdXBzLFxcbiAgICAgICAgICBwcmVGaWx0ZXJzLFxcbiAgICAgICAgICBjYWNoZWQgPSB0b2tlbkNhY2hlW3NlbGVjdG9yICsgXFxcIiBcXFwiXTtcXG5cXG4gICAgICBpZiAoY2FjaGVkKSB7XFxuICAgICAgICByZXR1cm4gcGFyc2VPbmx5ID8gMCA6IGNhY2hlZC5zbGljZSgwKTtcXG4gICAgICB9XFxuXFxuICAgICAgc29GYXIgPSBzZWxlY3RvcjtcXG4gICAgICBncm91cHMgPSBbXTtcXG4gICAgICBwcmVGaWx0ZXJzID0gRXhwci5wcmVGaWx0ZXI7XFxuXFxuICAgICAgd2hpbGUgKHNvRmFyKSB7XFxuICAgICAgICAvLyBDb21tYSBhbmQgZmlyc3QgcnVuXFxuICAgICAgICBpZiAoIW1hdGNoZWQgfHwgKG1hdGNoID0gcmNvbW1hLmV4ZWMoc29GYXIpKSkge1xcbiAgICAgICAgICBpZiAobWF0Y2gpIHtcXG4gICAgICAgICAgICAvLyBEb24ndCBjb25zdW1lIHRyYWlsaW5nIGNvbW1hcyBhcyB2YWxpZFxcbiAgICAgICAgICAgIHNvRmFyID0gc29GYXIuc2xpY2UobWF0Y2hbMF0ubGVuZ3RoKSB8fCBzb0ZhcjtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBncm91cHMucHVzaCh0b2tlbnMgPSBbXSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBtYXRjaGVkID0gZmFsc2U7IC8vIENvbWJpbmF0b3JzXFxuXFxuICAgICAgICBpZiAobWF0Y2ggPSByY29tYmluYXRvcnMuZXhlYyhzb0ZhcikpIHtcXG4gICAgICAgICAgbWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XFxuICAgICAgICAgIHRva2Vucy5wdXNoKHtcXG4gICAgICAgICAgICB2YWx1ZTogbWF0Y2hlZCxcXG4gICAgICAgICAgICAvLyBDYXN0IGRlc2NlbmRhbnQgY29tYmluYXRvcnMgdG8gc3BhY2VcXG4gICAgICAgICAgICB0eXBlOiBtYXRjaFswXS5yZXBsYWNlKHJ0cmltLCBcXFwiIFxcXCIpXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgICBzb0ZhciA9IHNvRmFyLnNsaWNlKG1hdGNoZWQubGVuZ3RoKTtcXG4gICAgICAgIH0gLy8gRmlsdGVyc1xcblxcblxcbiAgICAgICAgZm9yICh0eXBlIGluIEV4cHIuZmlsdGVyKSB7XFxuICAgICAgICAgIGlmICgobWF0Y2ggPSBtYXRjaEV4cHJbdHlwZV0uZXhlYyhzb0ZhcikpICYmICghcHJlRmlsdGVyc1t0eXBlXSB8fCAobWF0Y2ggPSBwcmVGaWx0ZXJzW3R5cGVdKG1hdGNoKSkpKSB7XFxuICAgICAgICAgICAgbWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XFxuICAgICAgICAgICAgdG9rZW5zLnB1c2goe1xcbiAgICAgICAgICAgICAgdmFsdWU6IG1hdGNoZWQsXFxuICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxcbiAgICAgICAgICAgICAgbWF0Y2hlczogbWF0Y2hcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICBzb0ZhciA9IHNvRmFyLnNsaWNlKG1hdGNoZWQubGVuZ3RoKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKCFtYXRjaGVkKSB7XFxuICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgfVxcbiAgICAgIH0gLy8gUmV0dXJuIHRoZSBsZW5ndGggb2YgdGhlIGludmFsaWQgZXhjZXNzXFxuICAgICAgLy8gaWYgd2UncmUganVzdCBwYXJzaW5nXFxuICAgICAgLy8gT3RoZXJ3aXNlLCB0aHJvdyBhbiBlcnJvciBvciByZXR1cm4gdG9rZW5zXFxuXFxuXFxuICAgICAgcmV0dXJuIHBhcnNlT25seSA/IHNvRmFyLmxlbmd0aCA6IHNvRmFyID8gU2l6emxlLmVycm9yKHNlbGVjdG9yKSA6IC8vIENhY2hlIHRoZSB0b2tlbnNcXG4gICAgICB0b2tlbkNhY2hlKHNlbGVjdG9yLCBncm91cHMpLnNsaWNlKDApO1xcbiAgICB9O1xcblxcbiAgICBmdW5jdGlvbiB0b1NlbGVjdG9yKHRva2Vucykge1xcbiAgICAgIHZhciBpID0gMCxcXG4gICAgICAgICAgbGVuID0gdG9rZW5zLmxlbmd0aCxcXG4gICAgICAgICAgc2VsZWN0b3IgPSBcXFwiXFxcIjtcXG5cXG4gICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XFxuICAgICAgICBzZWxlY3RvciArPSB0b2tlbnNbaV0udmFsdWU7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBzZWxlY3RvcjtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBhZGRDb21iaW5hdG9yKG1hdGNoZXIsIGNvbWJpbmF0b3IsIGJhc2UpIHtcXG4gICAgICB2YXIgZGlyID0gY29tYmluYXRvci5kaXIsXFxuICAgICAgICAgIGNoZWNrTm9uRWxlbWVudHMgPSBiYXNlICYmIGRpciA9PT0gXFxcInBhcmVudE5vZGVcXFwiLFxcbiAgICAgICAgICBkb25lTmFtZSA9IGRvbmUrKztcXG4gICAgICByZXR1cm4gY29tYmluYXRvci5maXJzdCA/IC8vIENoZWNrIGFnYWluc3QgY2xvc2VzdCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudFxcbiAgICAgIGZ1bmN0aW9uIChlbGVtLCBjb250ZXh0LCB4bWwpIHtcXG4gICAgICAgIHdoaWxlIChlbGVtID0gZWxlbVtkaXJdKSB7XFxuICAgICAgICAgIGlmIChlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMpIHtcXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlcihlbGVtLCBjb250ZXh0LCB4bWwpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfSA6IC8vIENoZWNrIGFnYWluc3QgYWxsIGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50c1xcbiAgICAgIGZ1bmN0aW9uIChlbGVtLCBjb250ZXh0LCB4bWwpIHtcXG4gICAgICAgIHZhciBvbGRDYWNoZSxcXG4gICAgICAgICAgICBvdXRlckNhY2hlLFxcbiAgICAgICAgICAgIG5ld0NhY2hlID0gW2RpcnJ1bnMsIGRvbmVOYW1lXTsgLy8gV2UgY2FuJ3Qgc2V0IGFyYml0cmFyeSBkYXRhIG9uIFhNTCBub2Rlcywgc28gdGhleSBkb24ndCBiZW5lZml0IGZyb20gZGlyIGNhY2hpbmdcXG5cXG4gICAgICAgIGlmICh4bWwpIHtcXG4gICAgICAgICAgd2hpbGUgKGVsZW0gPSBlbGVtW2Rpcl0pIHtcXG4gICAgICAgICAgICBpZiAoZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzKSB7XFxuICAgICAgICAgICAgICBpZiAobWF0Y2hlcihlbGVtLCBjb250ZXh0LCB4bWwpKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgd2hpbGUgKGVsZW0gPSBlbGVtW2Rpcl0pIHtcXG4gICAgICAgICAgICBpZiAoZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzKSB7XFxuICAgICAgICAgICAgICBvdXRlckNhY2hlID0gZWxlbVtleHBhbmRvXSB8fCAoZWxlbVtleHBhbmRvXSA9IHt9KTtcXG5cXG4gICAgICAgICAgICAgIGlmICgob2xkQ2FjaGUgPSBvdXRlckNhY2hlW2Rpcl0pICYmIG9sZENhY2hlWzBdID09PSBkaXJydW5zICYmIG9sZENhY2hlWzFdID09PSBkb25lTmFtZSkge1xcbiAgICAgICAgICAgICAgICAvLyBBc3NpZ24gdG8gbmV3Q2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3Q2FjaGVbMl0gPSBvbGRDYWNoZVsyXTtcXG4gICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIC8vIFJldXNlIG5ld2NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcXG4gICAgICAgICAgICAgICAgb3V0ZXJDYWNoZVtkaXJdID0gbmV3Q2FjaGU7IC8vIEEgbWF0Y2ggbWVhbnMgd2UncmUgZG9uZTsgYSBmYWlsIG1lYW5zIHdlIGhhdmUgdG8ga2VlcCBjaGVja2luZ1xcblxcbiAgICAgICAgICAgICAgICBpZiAobmV3Q2FjaGVbMl0gPSBtYXRjaGVyKGVsZW0sIGNvbnRleHQsIHhtbCkpIHtcXG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gZWxlbWVudE1hdGNoZXIobWF0Y2hlcnMpIHtcXG4gICAgICByZXR1cm4gbWF0Y2hlcnMubGVuZ3RoID4gMSA/IGZ1bmN0aW9uIChlbGVtLCBjb250ZXh0LCB4bWwpIHtcXG4gICAgICAgIHZhciBpID0gbWF0Y2hlcnMubGVuZ3RoO1xcblxcbiAgICAgICAgd2hpbGUgKGktLSkge1xcbiAgICAgICAgICBpZiAoIW1hdGNoZXJzW2ldKGVsZW0sIGNvbnRleHQsIHhtbCkpIHtcXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgIH0gOiBtYXRjaGVyc1swXTtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBtdWx0aXBsZUNvbnRleHRzKHNlbGVjdG9yLCBjb250ZXh0cywgcmVzdWx0cykge1xcbiAgICAgIHZhciBpID0gMCxcXG4gICAgICAgICAgbGVuID0gY29udGV4dHMubGVuZ3RoO1xcblxcbiAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcXG4gICAgICAgIFNpenpsZShzZWxlY3RvciwgY29udGV4dHNbaV0sIHJlc3VsdHMpO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gcmVzdWx0cztcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBjb25kZW5zZSh1bm1hdGNoZWQsIG1hcCwgZmlsdGVyLCBjb250ZXh0LCB4bWwpIHtcXG4gICAgICB2YXIgZWxlbSxcXG4gICAgICAgICAgbmV3VW5tYXRjaGVkID0gW10sXFxuICAgICAgICAgIGkgPSAwLFxcbiAgICAgICAgICBsZW4gPSB1bm1hdGNoZWQubGVuZ3RoLFxcbiAgICAgICAgICBtYXBwZWQgPSBtYXAgIT0gbnVsbDtcXG5cXG4gICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XFxuICAgICAgICBpZiAoZWxlbSA9IHVubWF0Y2hlZFtpXSkge1xcbiAgICAgICAgICBpZiAoIWZpbHRlciB8fCBmaWx0ZXIoZWxlbSwgY29udGV4dCwgeG1sKSkge1xcbiAgICAgICAgICAgIG5ld1VubWF0Y2hlZC5wdXNoKGVsZW0pO1xcblxcbiAgICAgICAgICAgIGlmIChtYXBwZWQpIHtcXG4gICAgICAgICAgICAgIG1hcC5wdXNoKGkpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gbmV3VW5tYXRjaGVkO1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIHNldE1hdGNoZXIocHJlRmlsdGVyLCBzZWxlY3RvciwgbWF0Y2hlciwgcG9zdEZpbHRlciwgcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yKSB7XFxuICAgICAgaWYgKHBvc3RGaWx0ZXIgJiYgIXBvc3RGaWx0ZXJbZXhwYW5kb10pIHtcXG4gICAgICAgIHBvc3RGaWx0ZXIgPSBzZXRNYXRjaGVyKHBvc3RGaWx0ZXIpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAocG9zdEZpbmRlciAmJiAhcG9zdEZpbmRlcltleHBhbmRvXSkge1xcbiAgICAgICAgcG9zdEZpbmRlciA9IHNldE1hdGNoZXIocG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yKTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiAoc2VlZCwgcmVzdWx0cywgY29udGV4dCwgeG1sKSB7XFxuICAgICAgICB2YXIgdGVtcCxcXG4gICAgICAgICAgICBpLFxcbiAgICAgICAgICAgIGVsZW0sXFxuICAgICAgICAgICAgcHJlTWFwID0gW10sXFxuICAgICAgICAgICAgcG9zdE1hcCA9IFtdLFxcbiAgICAgICAgICAgIHByZWV4aXN0aW5nID0gcmVzdWx0cy5sZW5ndGgsXFxuICAgICAgICAgICAgLy8gR2V0IGluaXRpYWwgZWxlbWVudHMgZnJvbSBzZWVkIG9yIGNvbnRleHRcXG4gICAgICAgIGVsZW1zID0gc2VlZCB8fCBtdWx0aXBsZUNvbnRleHRzKHNlbGVjdG9yIHx8IFxcXCIqXFxcIiwgY29udGV4dC5ub2RlVHlwZSA/IFtjb250ZXh0XSA6IGNvbnRleHQsIFtdKSxcXG4gICAgICAgICAgICAvLyBQcmVmaWx0ZXIgdG8gZ2V0IG1hdGNoZXIgaW5wdXQsIHByZXNlcnZpbmcgYSBtYXAgZm9yIHNlZWQtcmVzdWx0cyBzeW5jaHJvbml6YXRpb25cXG4gICAgICAgIG1hdGNoZXJJbiA9IHByZUZpbHRlciAmJiAoc2VlZCB8fCAhc2VsZWN0b3IpID8gY29uZGVuc2UoZWxlbXMsIHByZU1hcCwgcHJlRmlsdGVyLCBjb250ZXh0LCB4bWwpIDogZWxlbXMsXFxuICAgICAgICAgICAgbWF0Y2hlck91dCA9IG1hdGNoZXIgPyAvLyBJZiB3ZSBoYXZlIGEgcG9zdEZpbmRlciwgb3IgZmlsdGVyZWQgc2VlZCwgb3Igbm9uLXNlZWQgcG9zdEZpbHRlciBvciBwcmVleGlzdGluZyByZXN1bHRzLFxcbiAgICAgICAgcG9zdEZpbmRlciB8fCAoc2VlZCA/IHByZUZpbHRlciA6IHByZWV4aXN0aW5nIHx8IHBvc3RGaWx0ZXIpID8gLy8gLi4uaW50ZXJtZWRpYXRlIHByb2Nlc3NpbmcgaXMgbmVjZXNzYXJ5XFxuICAgICAgICBbXSA6IC8vIC4uLm90aGVyd2lzZSB1c2UgcmVzdWx0cyBkaXJlY3RseVxcbiAgICAgICAgcmVzdWx0cyA6IG1hdGNoZXJJbjsgLy8gRmluZCBwcmltYXJ5IG1hdGNoZXNcXG5cXG4gICAgICAgIGlmIChtYXRjaGVyKSB7XFxuICAgICAgICAgIG1hdGNoZXIobWF0Y2hlckluLCBtYXRjaGVyT3V0LCBjb250ZXh0LCB4bWwpO1xcbiAgICAgICAgfSAvLyBBcHBseSBwb3N0RmlsdGVyXFxuXFxuXFxuICAgICAgICBpZiAocG9zdEZpbHRlcikge1xcbiAgICAgICAgICB0ZW1wID0gY29uZGVuc2UobWF0Y2hlck91dCwgcG9zdE1hcCk7XFxuICAgICAgICAgIHBvc3RGaWx0ZXIodGVtcCwgW10sIGNvbnRleHQsIHhtbCk7IC8vIFVuLW1hdGNoIGZhaWxpbmcgZWxlbWVudHMgYnkgbW92aW5nIHRoZW0gYmFjayB0byBtYXRjaGVySW5cXG5cXG4gICAgICAgICAgaSA9IHRlbXAubGVuZ3RoO1xcblxcbiAgICAgICAgICB3aGlsZSAoaS0tKSB7XFxuICAgICAgICAgICAgaWYgKGVsZW0gPSB0ZW1wW2ldKSB7XFxuICAgICAgICAgICAgICBtYXRjaGVyT3V0W3Bvc3RNYXBbaV1dID0gIShtYXRjaGVySW5bcG9zdE1hcFtpXV0gPSBlbGVtKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChzZWVkKSB7XFxuICAgICAgICAgIGlmIChwb3N0RmluZGVyIHx8IHByZUZpbHRlcikge1xcbiAgICAgICAgICAgIGlmIChwb3N0RmluZGVyKSB7XFxuICAgICAgICAgICAgICAvLyBHZXQgdGhlIGZpbmFsIG1hdGNoZXJPdXQgYnkgY29uZGVuc2luZyB0aGlzIGludGVybWVkaWF0ZSBpbnRvIHBvc3RGaW5kZXIgY29udGV4dHNcXG4gICAgICAgICAgICAgIHRlbXAgPSBbXTtcXG4gICAgICAgICAgICAgIGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcXG5cXG4gICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcXG4gICAgICAgICAgICAgICAgaWYgKGVsZW0gPSBtYXRjaGVyT3V0W2ldKSB7XFxuICAgICAgICAgICAgICAgICAgLy8gUmVzdG9yZSBtYXRjaGVySW4gc2luY2UgZWxlbSBpcyBub3QgeWV0IGEgZmluYWwgbWF0Y2hcXG4gICAgICAgICAgICAgICAgICB0ZW1wLnB1c2gobWF0Y2hlckluW2ldID0gZWxlbSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgIHBvc3RGaW5kZXIobnVsbCwgbWF0Y2hlck91dCA9IFtdLCB0ZW1wLCB4bWwpO1xcbiAgICAgICAgICAgIH0gLy8gTW92ZSBtYXRjaGVkIGVsZW1lbnRzIGZyb20gc2VlZCB0byByZXN1bHRzIHRvIGtlZXAgdGhlbSBzeW5jaHJvbml6ZWRcXG5cXG5cXG4gICAgICAgICAgICBpID0gbWF0Y2hlck91dC5sZW5ndGg7XFxuXFxuICAgICAgICAgICAgd2hpbGUgKGktLSkge1xcbiAgICAgICAgICAgICAgaWYgKChlbGVtID0gbWF0Y2hlck91dFtpXSkgJiYgKHRlbXAgPSBwb3N0RmluZGVyID8gaW5kZXhPZihzZWVkLCBlbGVtKSA6IHByZU1hcFtpXSkgPiAtMSkge1xcbiAgICAgICAgICAgICAgICBzZWVkW3RlbXBdID0gIShyZXN1bHRzW3RlbXBdID0gZWxlbSk7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9IC8vIEFkZCBlbGVtZW50cyB0byByZXN1bHRzLCB0aHJvdWdoIHBvc3RGaW5kZXIgaWYgZGVmaW5lZFxcblxcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgbWF0Y2hlck91dCA9IGNvbmRlbnNlKG1hdGNoZXJPdXQgPT09IHJlc3VsdHMgPyBtYXRjaGVyT3V0LnNwbGljZShwcmVleGlzdGluZywgbWF0Y2hlck91dC5sZW5ndGgpIDogbWF0Y2hlck91dCk7XFxuXFxuICAgICAgICAgIGlmIChwb3N0RmluZGVyKSB7XFxuICAgICAgICAgICAgcG9zdEZpbmRlcihudWxsLCByZXN1bHRzLCBtYXRjaGVyT3V0LCB4bWwpO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHB1c2guYXBwbHkocmVzdWx0cywgbWF0Y2hlck91dCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBtYXRjaGVyRnJvbVRva2Vucyh0b2tlbnMpIHtcXG4gICAgICB2YXIgY2hlY2tDb250ZXh0LFxcbiAgICAgICAgICBtYXRjaGVyLFxcbiAgICAgICAgICBqLFxcbiAgICAgICAgICBsZW4gPSB0b2tlbnMubGVuZ3RoLFxcbiAgICAgICAgICBsZWFkaW5nUmVsYXRpdmUgPSBFeHByLnJlbGF0aXZlW3Rva2Vuc1swXS50eXBlXSxcXG4gICAgICAgICAgaW1wbGljaXRSZWxhdGl2ZSA9IGxlYWRpbmdSZWxhdGl2ZSB8fCBFeHByLnJlbGF0aXZlW1xcXCIgXFxcIl0sXFxuICAgICAgICAgIGkgPSBsZWFkaW5nUmVsYXRpdmUgPyAxIDogMCxcXG4gICAgICAgICAgLy8gVGhlIGZvdW5kYXRpb25hbCBtYXRjaGVyIGVuc3VyZXMgdGhhdCBlbGVtZW50cyBhcmUgcmVhY2hhYmxlIGZyb20gdG9wLWxldmVsIGNvbnRleHQocylcXG4gICAgICBtYXRjaENvbnRleHQgPSBhZGRDb21iaW5hdG9yKGZ1bmN0aW9uIChlbGVtKSB7XFxuICAgICAgICByZXR1cm4gZWxlbSA9PT0gY2hlY2tDb250ZXh0O1xcbiAgICAgIH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUpLFxcbiAgICAgICAgICBtYXRjaEFueUNvbnRleHQgPSBhZGRDb21iaW5hdG9yKGZ1bmN0aW9uIChlbGVtKSB7XFxuICAgICAgICByZXR1cm4gaW5kZXhPZihjaGVja0NvbnRleHQsIGVsZW0pID4gLTE7XFxuICAgICAgfSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSksXFxuICAgICAgICAgIG1hdGNoZXJzID0gW2Z1bmN0aW9uIChlbGVtLCBjb250ZXh0LCB4bWwpIHtcXG4gICAgICAgIHZhciByZXQgPSAhbGVhZGluZ1JlbGF0aXZlICYmICh4bWwgfHwgY29udGV4dCAhPT0gb3V0ZXJtb3N0Q29udGV4dCkgfHwgKChjaGVja0NvbnRleHQgPSBjb250ZXh0KS5ub2RlVHlwZSA/IG1hdGNoQ29udGV4dChlbGVtLCBjb250ZXh0LCB4bWwpIDogbWF0Y2hBbnlDb250ZXh0KGVsZW0sIGNvbnRleHQsIHhtbCkpOyAvLyBBdm9pZCBoYW5naW5nIG9udG8gZWxlbWVudCAoaXNzdWUgIzI5OSlcXG5cXG4gICAgICAgIGNoZWNrQ29udGV4dCA9IG51bGw7XFxuICAgICAgICByZXR1cm4gcmV0O1xcbiAgICAgIH1dO1xcblxcbiAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcXG4gICAgICAgIGlmIChtYXRjaGVyID0gRXhwci5yZWxhdGl2ZVt0b2tlbnNbaV0udHlwZV0pIHtcXG4gICAgICAgICAgbWF0Y2hlcnMgPSBbYWRkQ29tYmluYXRvcihlbGVtZW50TWF0Y2hlcihtYXRjaGVycyksIG1hdGNoZXIpXTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIG1hdGNoZXIgPSBFeHByLmZpbHRlclt0b2tlbnNbaV0udHlwZV0uYXBwbHkobnVsbCwgdG9rZW5zW2ldLm1hdGNoZXMpOyAvLyBSZXR1cm4gc3BlY2lhbCB1cG9uIHNlZWluZyBhIHBvc2l0aW9uYWwgbWF0Y2hlclxcblxcbiAgICAgICAgICBpZiAobWF0Y2hlcltleHBhbmRvXSkge1xcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIG5leHQgcmVsYXRpdmUgb3BlcmF0b3IgKGlmIGFueSkgZm9yIHByb3BlciBoYW5kbGluZ1xcbiAgICAgICAgICAgIGogPSArK2k7XFxuXFxuICAgICAgICAgICAgZm9yICg7IGogPCBsZW47IGorKykge1xcbiAgICAgICAgICAgICAgaWYgKEV4cHIucmVsYXRpdmVbdG9rZW5zW2pdLnR5cGVdKSB7XFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICByZXR1cm4gc2V0TWF0Y2hlcihpID4gMSAmJiBlbGVtZW50TWF0Y2hlcihtYXRjaGVycyksIGkgPiAxICYmIHRvU2VsZWN0b3IoIC8vIElmIHRoZSBwcmVjZWRpbmcgdG9rZW4gd2FzIGEgZGVzY2VuZGFudCBjb21iaW5hdG9yLCBpbnNlcnQgYW4gaW1wbGljaXQgYW55LWVsZW1lbnQgYCpgXFxuICAgICAgICAgICAgdG9rZW5zLnNsaWNlKDAsIGkgLSAxKS5jb25jYXQoe1xcbiAgICAgICAgICAgICAgdmFsdWU6IHRva2Vuc1tpIC0gMl0udHlwZSA9PT0gXFxcIiBcXFwiID8gXFxcIipcXFwiIDogXFxcIlxcXCJcXG4gICAgICAgICAgICB9KSkucmVwbGFjZShydHJpbSwgXFxcIiQxXFxcIiksIG1hdGNoZXIsIGkgPCBqICYmIG1hdGNoZXJGcm9tVG9rZW5zKHRva2Vucy5zbGljZShpLCBqKSksIGogPCBsZW4gJiYgbWF0Y2hlckZyb21Ub2tlbnModG9rZW5zID0gdG9rZW5zLnNsaWNlKGopKSwgaiA8IGxlbiAmJiB0b1NlbGVjdG9yKHRva2VucykpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIG1hdGNoZXJzLnB1c2gobWF0Y2hlcik7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBlbGVtZW50TWF0Y2hlcihtYXRjaGVycyk7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMpIHtcXG4gICAgICB2YXIgYnlTZXQgPSBzZXRNYXRjaGVycy5sZW5ndGggPiAwLFxcbiAgICAgICAgICBieUVsZW1lbnQgPSBlbGVtZW50TWF0Y2hlcnMubGVuZ3RoID4gMCxcXG4gICAgICAgICAgc3VwZXJNYXRjaGVyID0gZnVuY3Rpb24gc3VwZXJNYXRjaGVyKHNlZWQsIGNvbnRleHQsIHhtbCwgcmVzdWx0cywgb3V0ZXJtb3N0KSB7XFxuICAgICAgICB2YXIgZWxlbSxcXG4gICAgICAgICAgICBqLFxcbiAgICAgICAgICAgIG1hdGNoZXIsXFxuICAgICAgICAgICAgbWF0Y2hlZENvdW50ID0gMCxcXG4gICAgICAgICAgICBpID0gXFxcIjBcXFwiLFxcbiAgICAgICAgICAgIHVubWF0Y2hlZCA9IHNlZWQgJiYgW10sXFxuICAgICAgICAgICAgc2V0TWF0Y2hlZCA9IFtdLFxcbiAgICAgICAgICAgIGNvbnRleHRCYWNrdXAgPSBvdXRlcm1vc3RDb250ZXh0LFxcbiAgICAgICAgICAgIC8vIFdlIG11c3QgYWx3YXlzIGhhdmUgZWl0aGVyIHNlZWQgZWxlbWVudHMgb3Igb3V0ZXJtb3N0IGNvbnRleHRcXG4gICAgICAgIGVsZW1zID0gc2VlZCB8fCBieUVsZW1lbnQgJiYgRXhwci5maW5kW1xcXCJUQUdcXFwiXShcXFwiKlxcXCIsIG91dGVybW9zdCksXFxuICAgICAgICAgICAgLy8gVXNlIGludGVnZXIgZGlycnVucyBpZmYgdGhpcyBpcyB0aGUgb3V0ZXJtb3N0IG1hdGNoZXJcXG4gICAgICAgIGRpcnJ1bnNVbmlxdWUgPSBkaXJydW5zICs9IGNvbnRleHRCYWNrdXAgPT0gbnVsbCA/IDEgOiBNYXRoLnJhbmRvbSgpIHx8IDAuMSxcXG4gICAgICAgICAgICBsZW4gPSBlbGVtcy5sZW5ndGg7XFxuXFxuICAgICAgICBpZiAob3V0ZXJtb3N0KSB7XFxuICAgICAgICAgIG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0ICE9PSBkb2N1bWVudCAmJiBjb250ZXh0O1xcbiAgICAgICAgfSAvLyBBZGQgZWxlbWVudHMgcGFzc2luZyBlbGVtZW50TWF0Y2hlcnMgZGlyZWN0bHkgdG8gcmVzdWx0c1xcbiAgICAgICAgLy8gS2VlcCBgaWAgYSBzdHJpbmcgaWYgdGhlcmUgYXJlIG5vIGVsZW1lbnRzIHNvIGBtYXRjaGVkQ291bnRgIHdpbGwgYmUgXFxcIjAwXFxcIiBiZWxvd1xcbiAgICAgICAgLy8gU3VwcG9ydDogSUU8OSwgU2FmYXJpXFxuICAgICAgICAvLyBUb2xlcmF0ZSBOb2RlTGlzdCBwcm9wZXJ0aWVzIChJRTogXFxcImxlbmd0aFxcXCI7IFNhZmFyaTogPG51bWJlcj4pIG1hdGNoaW5nIGVsZW1lbnRzIGJ5IGlkXFxuXFxuXFxuICAgICAgICBmb3IgKDsgaSAhPT0gbGVuICYmIChlbGVtID0gZWxlbXNbaV0pICE9IG51bGw7IGkrKykge1xcbiAgICAgICAgICBpZiAoYnlFbGVtZW50ICYmIGVsZW0pIHtcXG4gICAgICAgICAgICBqID0gMDtcXG5cXG4gICAgICAgICAgICB3aGlsZSAobWF0Y2hlciA9IGVsZW1lbnRNYXRjaGVyc1tqKytdKSB7XFxuICAgICAgICAgICAgICBpZiAobWF0Y2hlcihlbGVtLCBjb250ZXh0LCB4bWwpKSB7XFxuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChlbGVtKTtcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmIChvdXRlcm1vc3QpIHtcXG4gICAgICAgICAgICAgIGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSAvLyBUcmFjayB1bm1hdGNoZWQgZWxlbWVudHMgZm9yIHNldCBmaWx0ZXJzXFxuXFxuXFxuICAgICAgICAgIGlmIChieVNldCkge1xcbiAgICAgICAgICAgIC8vIFRoZXkgd2lsbCBoYXZlIGdvbmUgdGhyb3VnaCBhbGwgcG9zc2libGUgbWF0Y2hlcnNcXG4gICAgICAgICAgICBpZiAoZWxlbSA9ICFtYXRjaGVyICYmIGVsZW0pIHtcXG4gICAgICAgICAgICAgIG1hdGNoZWRDb3VudC0tO1xcbiAgICAgICAgICAgIH0gLy8gTGVuZ3RoZW4gdGhlIGFycmF5IGZvciBldmVyeSBlbGVtZW50LCBtYXRjaGVkIG9yIG5vdFxcblxcblxcbiAgICAgICAgICAgIGlmIChzZWVkKSB7XFxuICAgICAgICAgICAgICB1bm1hdGNoZWQucHVzaChlbGVtKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gLy8gQXBwbHkgc2V0IGZpbHRlcnMgdG8gdW5tYXRjaGVkIGVsZW1lbnRzXFxuXFxuXFxuICAgICAgICBtYXRjaGVkQ291bnQgKz0gaTtcXG5cXG4gICAgICAgIGlmIChieVNldCAmJiBpICE9PSBtYXRjaGVkQ291bnQpIHtcXG4gICAgICAgICAgaiA9IDA7XFxuXFxuICAgICAgICAgIHdoaWxlIChtYXRjaGVyID0gc2V0TWF0Y2hlcnNbaisrXSkge1xcbiAgICAgICAgICAgIG1hdGNoZXIodW5tYXRjaGVkLCBzZXRNYXRjaGVkLCBjb250ZXh0LCB4bWwpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmIChzZWVkKSB7XFxuICAgICAgICAgICAgLy8gUmVpbnRlZ3JhdGUgZWxlbWVudCBtYXRjaGVzIHRvIGVsaW1pbmF0ZSB0aGUgbmVlZCBmb3Igc29ydGluZ1xcbiAgICAgICAgICAgIGlmIChtYXRjaGVkQ291bnQgPiAwKSB7XFxuICAgICAgICAgICAgICB3aGlsZSAoaS0tKSB7XFxuICAgICAgICAgICAgICAgIGlmICghKHVubWF0Y2hlZFtpXSB8fCBzZXRNYXRjaGVkW2ldKSkge1xcbiAgICAgICAgICAgICAgICAgIHNldE1hdGNoZWRbaV0gPSBwb3AuY2FsbChyZXN1bHRzKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0gLy8gRGlzY2FyZCBpbmRleCBwbGFjZWhvbGRlciB2YWx1ZXMgdG8gZ2V0IG9ubHkgYWN0dWFsIG1hdGNoZXNcXG5cXG5cXG4gICAgICAgICAgICBzZXRNYXRjaGVkID0gY29uZGVuc2Uoc2V0TWF0Y2hlZCk7XFxuICAgICAgICAgIH0gLy8gQWRkIG1hdGNoZXMgdG8gcmVzdWx0c1xcblxcblxcbiAgICAgICAgICBwdXNoLmFwcGx5KHJlc3VsdHMsIHNldE1hdGNoZWQpOyAvLyBTZWVkbGVzcyBzZXQgbWF0Y2hlcyBzdWNjZWVkaW5nIG11bHRpcGxlIHN1Y2Nlc3NmdWwgbWF0Y2hlcnMgc3RpcHVsYXRlIHNvcnRpbmdcXG5cXG4gICAgICAgICAgaWYgKG91dGVybW9zdCAmJiAhc2VlZCAmJiBzZXRNYXRjaGVkLmxlbmd0aCA+IDAgJiYgbWF0Y2hlZENvdW50ICsgc2V0TWF0Y2hlcnMubGVuZ3RoID4gMSkge1xcbiAgICAgICAgICAgIFNpenpsZS51bmlxdWVTb3J0KHJlc3VsdHMpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IC8vIE92ZXJyaWRlIG1hbmlwdWxhdGlvbiBvZiBnbG9iYWxzIGJ5IG5lc3RlZCBtYXRjaGVyc1xcblxcblxcbiAgICAgICAgaWYgKG91dGVybW9zdCkge1xcbiAgICAgICAgICBkaXJydW5zID0gZGlycnVuc1VuaXF1ZTtcXG4gICAgICAgICAgb3V0ZXJtb3N0Q29udGV4dCA9IGNvbnRleHRCYWNrdXA7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gdW5tYXRjaGVkO1xcbiAgICAgIH07XFxuXFxuICAgICAgcmV0dXJuIGJ5U2V0ID8gbWFya0Z1bmN0aW9uKHN1cGVyTWF0Y2hlcikgOiBzdXBlck1hdGNoZXI7XFxuICAgIH1cXG5cXG4gICAgY29tcGlsZSA9IFNpenpsZS5jb21waWxlID0gZnVuY3Rpb24gKHNlbGVjdG9yLCBtYXRjaFxcbiAgICAvKiBJbnRlcm5hbCBVc2UgT25seSAqL1xcbiAgICApIHtcXG4gICAgICB2YXIgaSxcXG4gICAgICAgICAgc2V0TWF0Y2hlcnMgPSBbXSxcXG4gICAgICAgICAgZWxlbWVudE1hdGNoZXJzID0gW10sXFxuICAgICAgICAgIGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGVbc2VsZWN0b3IgKyBcXFwiIFxcXCJdO1xcblxcbiAgICAgIGlmICghY2FjaGVkKSB7XFxuICAgICAgICAvLyBHZW5lcmF0ZSBhIGZ1bmN0aW9uIG9mIHJlY3Vyc2l2ZSBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCB0byBjaGVjayBlYWNoIGVsZW1lbnRcXG4gICAgICAgIGlmICghbWF0Y2gpIHtcXG4gICAgICAgICAgbWF0Y2ggPSB0b2tlbml6ZShzZWxlY3Rvcik7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpID0gbWF0Y2gubGVuZ3RoO1xcblxcbiAgICAgICAgd2hpbGUgKGktLSkge1xcbiAgICAgICAgICBjYWNoZWQgPSBtYXRjaGVyRnJvbVRva2VucyhtYXRjaFtpXSk7XFxuXFxuICAgICAgICAgIGlmIChjYWNoZWRbZXhwYW5kb10pIHtcXG4gICAgICAgICAgICBzZXRNYXRjaGVycy5wdXNoKGNhY2hlZCk7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgZWxlbWVudE1hdGNoZXJzLnB1c2goY2FjaGVkKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSAvLyBDYWNoZSB0aGUgY29tcGlsZWQgZnVuY3Rpb25cXG5cXG5cXG4gICAgICAgIGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGUoc2VsZWN0b3IsIG1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyhlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzKSk7IC8vIFNhdmUgc2VsZWN0b3IgYW5kIHRva2VuaXphdGlvblxcblxcbiAgICAgICAgY2FjaGVkLnNlbGVjdG9yID0gc2VsZWN0b3I7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBjYWNoZWQ7XFxuICAgIH07XFxuICAgIC8qKlxcbiAgICAgKiBBIGxvdy1sZXZlbCBzZWxlY3Rpb24gZnVuY3Rpb24gdGhhdCB3b3JrcyB3aXRoIFNpenpsZSdzIGNvbXBpbGVkXFxuICAgICAqICBzZWxlY3RvciBmdW5jdGlvbnNcXG4gICAgICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHNlbGVjdG9yIEEgc2VsZWN0b3Igb3IgYSBwcmUtY29tcGlsZWRcXG4gICAgICogIHNlbGVjdG9yIGZ1bmN0aW9uIGJ1aWx0IHdpdGggU2l6emxlLmNvbXBpbGVcXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBjb250ZXh0XFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHRzXVxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbc2VlZF0gQSBzZXQgb2YgZWxlbWVudHMgdG8gbWF0Y2ggYWdhaW5zdFxcbiAgICAgKi9cXG5cXG5cXG4gICAgc2VsZWN0ID0gU2l6emxlLnNlbGVjdCA9IGZ1bmN0aW9uIChzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCkge1xcbiAgICAgIHZhciBpLFxcbiAgICAgICAgICB0b2tlbnMsXFxuICAgICAgICAgIHRva2VuLFxcbiAgICAgICAgICB0eXBlLFxcbiAgICAgICAgICBmaW5kLFxcbiAgICAgICAgICBjb21waWxlZCA9IHR5cGVvZiBzZWxlY3RvciA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBzZWxlY3RvcixcXG4gICAgICAgICAgbWF0Y2ggPSAhc2VlZCAmJiB0b2tlbml6ZShzZWxlY3RvciA9IGNvbXBpbGVkLnNlbGVjdG9yIHx8IHNlbGVjdG9yKTtcXG4gICAgICByZXN1bHRzID0gcmVzdWx0cyB8fCBbXTsgLy8gVHJ5IHRvIG1pbmltaXplIG9wZXJhdGlvbnMgaWYgdGhlcmUgaXMgbm8gc2VlZCBhbmQgb25seSBvbmUgZ3JvdXBcXG5cXG4gICAgICBpZiAobWF0Y2gubGVuZ3RoID09PSAxKSB7XFxuICAgICAgICAvLyBUYWtlIGEgc2hvcnRjdXQgYW5kIHNldCB0aGUgY29udGV4dCBpZiB0aGUgcm9vdCBzZWxlY3RvciBpcyBhbiBJRFxcbiAgICAgICAgdG9rZW5zID0gbWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSgwKTtcXG5cXG4gICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID4gMiAmJiAodG9rZW4gPSB0b2tlbnNbMF0pLnR5cGUgPT09IFxcXCJJRFxcXCIgJiYgc3VwcG9ydC5nZXRCeUlkICYmIGNvbnRleHQubm9kZVR5cGUgPT09IDkgJiYgZG9jdW1lbnRJc0hUTUwgJiYgRXhwci5yZWxhdGl2ZVt0b2tlbnNbMV0udHlwZV0pIHtcXG4gICAgICAgICAgY29udGV4dCA9IChFeHByLmZpbmRbXFxcIklEXFxcIl0odG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKSwgY29udGV4dCkgfHwgW10pWzBdO1xcblxcbiAgICAgICAgICBpZiAoIWNvbnRleHQpIHtcXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0czsgLy8gUHJlY29tcGlsZWQgbWF0Y2hlcnMgd2lsbCBzdGlsbCB2ZXJpZnkgYW5jZXN0cnksIHNvIHN0ZXAgdXAgYSBsZXZlbFxcbiAgICAgICAgICB9IGVsc2UgaWYgKGNvbXBpbGVkKSB7XFxuICAgICAgICAgICAgY29udGV4dCA9IGNvbnRleHQucGFyZW50Tm9kZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBzZWxlY3RvciA9IHNlbGVjdG9yLnNsaWNlKHRva2Vucy5zaGlmdCgpLnZhbHVlLmxlbmd0aCk7XFxuICAgICAgICB9IC8vIEZldGNoIGEgc2VlZCBzZXQgZm9yIHJpZ2h0LXRvLWxlZnQgbWF0Y2hpbmdcXG5cXG5cXG4gICAgICAgIGkgPSBtYXRjaEV4cHJbXFxcIm5lZWRzQ29udGV4dFxcXCJdLnRlc3Qoc2VsZWN0b3IpID8gMCA6IHRva2Vucy5sZW5ndGg7XFxuXFxuICAgICAgICB3aGlsZSAoaS0tKSB7XFxuICAgICAgICAgIHRva2VuID0gdG9rZW5zW2ldOyAvLyBBYm9ydCBpZiB3ZSBoaXQgYSBjb21iaW5hdG9yXFxuXFxuICAgICAgICAgIGlmIChFeHByLnJlbGF0aXZlW3R5cGUgPSB0b2tlbi50eXBlXSkge1xcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmIChmaW5kID0gRXhwci5maW5kW3R5cGVdKSB7XFxuICAgICAgICAgICAgLy8gU2VhcmNoLCBleHBhbmRpbmcgY29udGV4dCBmb3IgbGVhZGluZyBzaWJsaW5nIGNvbWJpbmF0b3JzXFxuICAgICAgICAgICAgaWYgKHNlZWQgPSBmaW5kKHRva2VuLm1hdGNoZXNbMF0ucmVwbGFjZShydW5lc2NhcGUsIGZ1bmVzY2FwZSksIHJzaWJsaW5nLnRlc3QodG9rZW5zWzBdLnR5cGUpICYmIHRlc3RDb250ZXh0KGNvbnRleHQucGFyZW50Tm9kZSkgfHwgY29udGV4dCkpIHtcXG4gICAgICAgICAgICAgIC8vIElmIHNlZWQgaXMgZW1wdHkgb3Igbm8gdG9rZW5zIHJlbWFpbiwgd2UgY2FuIHJldHVybiBlYXJseVxcbiAgICAgICAgICAgICAgdG9rZW5zLnNwbGljZShpLCAxKTtcXG4gICAgICAgICAgICAgIHNlbGVjdG9yID0gc2VlZC5sZW5ndGggJiYgdG9TZWxlY3Rvcih0b2tlbnMpO1xcblxcbiAgICAgICAgICAgICAgaWYgKCFzZWxlY3Rvcikge1xcbiAgICAgICAgICAgICAgICBwdXNoLmFwcGx5KHJlc3VsdHMsIHNlZWQpO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcXG4gICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH0gLy8gQ29tcGlsZSBhbmQgZXhlY3V0ZSBhIGZpbHRlcmluZyBmdW5jdGlvbiBpZiBvbmUgaXMgbm90IHByb3ZpZGVkXFxuICAgICAgLy8gUHJvdmlkZSBgbWF0Y2hgIHRvIGF2b2lkIHJldG9rZW5pemF0aW9uIGlmIHdlIG1vZGlmaWVkIHRoZSBzZWxlY3RvciBhYm92ZVxcblxcblxcbiAgICAgIChjb21waWxlZCB8fCBjb21waWxlKHNlbGVjdG9yLCBtYXRjaCkpKHNlZWQsIGNvbnRleHQsICFkb2N1bWVudElzSFRNTCwgcmVzdWx0cywgcnNpYmxpbmcudGVzdChzZWxlY3RvcikgJiYgdGVzdENvbnRleHQoY29udGV4dC5wYXJlbnROb2RlKSB8fCBjb250ZXh0KTtcXG4gICAgICByZXR1cm4gcmVzdWx0cztcXG4gICAgfTsgLy8gT25lLXRpbWUgYXNzaWdubWVudHNcXG4gICAgLy8gU29ydCBzdGFiaWxpdHlcXG5cXG5cXG4gICAgc3VwcG9ydC5zb3J0U3RhYmxlID0gZXhwYW5kby5zcGxpdChcXFwiXFxcIikuc29ydChzb3J0T3JkZXIpLmpvaW4oXFxcIlxcXCIpID09PSBleHBhbmRvOyAvLyBTdXBwb3J0OiBDaHJvbWUgMTQtMzUrXFxuICAgIC8vIEFsd2F5cyBhc3N1bWUgZHVwbGljYXRlcyBpZiB0aGV5IGFyZW4ndCBwYXNzZWQgdG8gdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25cXG5cXG4gICAgc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzID0gISFoYXNEdXBsaWNhdGU7IC8vIEluaXRpYWxpemUgYWdhaW5zdCB0aGUgZGVmYXVsdCBkb2N1bWVudFxcblxcbiAgICBzZXREb2N1bWVudCgpOyAvLyBTdXBwb3J0OiBXZWJraXQ8NTM3LjMyIC0gU2FmYXJpIDYuMC4zL0Nocm9tZSAyNSAoZml4ZWQgaW4gQ2hyb21lIDI3KVxcbiAgICAvLyBEZXRhY2hlZCBub2RlcyBjb25mb3VuZGluZ2x5IGZvbGxvdyAqZWFjaCBvdGhlcipcXG5cXG4gICAgc3VwcG9ydC5zb3J0RGV0YWNoZWQgPSBhc3NlcnQoZnVuY3Rpb24gKGRpdjEpIHtcXG4gICAgICAvLyBTaG91bGQgcmV0dXJuIDEsIGJ1dCByZXR1cm5zIDQgKGZvbGxvd2luZylcXG4gICAgICByZXR1cm4gZGl2MS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxcXCJkaXZcXFwiKSkgJiAxO1xcbiAgICB9KTsgLy8gU3VwcG9ydDogSUU8OFxcbiAgICAvLyBQcmV2ZW50IGF0dHJpYnV0ZS9wcm9wZXJ0eSBcXFwiaW50ZXJwb2xhdGlvblxcXCJcXG4gICAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTM2NDI5JTI4VlMuODUlMjkuYXNweFxcblxcbiAgICBpZiAoIWFzc2VydChmdW5jdGlvbiAoZGl2KSB7XFxuICAgICAgZGl2LmlubmVySFRNTCA9IFxcXCI8YSBocmVmPScjJz48L2E+XFxcIjtcXG4gICAgICByZXR1cm4gZGl2LmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKFxcXCJocmVmXFxcIikgPT09IFxcXCIjXFxcIjtcXG4gICAgfSkpIHtcXG4gICAgICBhZGRIYW5kbGUoXFxcInR5cGV8aHJlZnxoZWlnaHR8d2lkdGhcXFwiLCBmdW5jdGlvbiAoZWxlbSwgbmFtZSwgaXNYTUwpIHtcXG4gICAgICAgIGlmICghaXNYTUwpIHtcXG4gICAgICAgICAgcmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKG5hbWUsIG5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXFxcInR5cGVcXFwiID8gMSA6IDIpO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcbiAgICB9IC8vIFN1cHBvcnQ6IElFPDlcXG4gICAgLy8gVXNlIGRlZmF1bHRWYWx1ZSBpbiBwbGFjZSBvZiBnZXRBdHRyaWJ1dGUoXFxcInZhbHVlXFxcIilcXG5cXG5cXG4gICAgaWYgKCFzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWFzc2VydChmdW5jdGlvbiAoZGl2KSB7XFxuICAgICAgZGl2LmlubmVySFRNTCA9IFxcXCI8aW5wdXQvPlxcXCI7XFxuICAgICAgZGl2LmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKFxcXCJ2YWx1ZVxcXCIsIFxcXCJcXFwiKTtcXG4gICAgICByZXR1cm4gZGl2LmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKFxcXCJ2YWx1ZVxcXCIpID09PSBcXFwiXFxcIjtcXG4gICAgfSkpIHtcXG4gICAgICBhZGRIYW5kbGUoXFxcInZhbHVlXFxcIiwgZnVuY3Rpb24gKGVsZW0sIG5hbWUsIGlzWE1MKSB7XFxuICAgICAgICBpZiAoIWlzWE1MICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXFxcImlucHV0XFxcIikge1xcbiAgICAgICAgICByZXR1cm4gZWxlbS5kZWZhdWx0VmFsdWU7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgIH0gLy8gU3VwcG9ydDogSUU8OVxcbiAgICAvLyBVc2UgZ2V0QXR0cmlidXRlTm9kZSB0byBmZXRjaCBib29sZWFucyB3aGVuIGdldEF0dHJpYnV0ZSBsaWVzXFxuXFxuXFxuICAgIGlmICghYXNzZXJ0KGZ1bmN0aW9uIChkaXYpIHtcXG4gICAgICByZXR1cm4gZGl2LmdldEF0dHJpYnV0ZShcXFwiZGlzYWJsZWRcXFwiKSA9PSBudWxsO1xcbiAgICB9KSkge1xcbiAgICAgIGFkZEhhbmRsZShib29sZWFucywgZnVuY3Rpb24gKGVsZW0sIG5hbWUsIGlzWE1MKSB7XFxuICAgICAgICB2YXIgdmFsO1xcblxcbiAgICAgICAgaWYgKCFpc1hNTCkge1xcbiAgICAgICAgICByZXR1cm4gZWxlbVtuYW1lXSA9PT0gdHJ1ZSA/IG5hbWUudG9Mb3dlckNhc2UoKSA6ICh2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUobmFtZSkpICYmIHZhbC5zcGVjaWZpZWQgPyB2YWwudmFsdWUgOiBudWxsO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBTaXp6bGU7XFxuICB9KHdpbmRvdyk7XFxuXFxuICBqUXVlcnkuZmluZCA9IFNpenpsZTtcXG4gIGpRdWVyeS5leHByID0gU2l6emxlLnNlbGVjdG9ycztcXG4gIGpRdWVyeS5leHByW1xcXCI6XFxcIl0gPSBqUXVlcnkuZXhwci5wc2V1ZG9zO1xcbiAgalF1ZXJ5LnVuaXF1ZSA9IFNpenpsZS51bmlxdWVTb3J0O1xcbiAgalF1ZXJ5LnRleHQgPSBTaXp6bGUuZ2V0VGV4dDtcXG4gIGpRdWVyeS5pc1hNTERvYyA9IFNpenpsZS5pc1hNTDtcXG4gIGpRdWVyeS5jb250YWlucyA9IFNpenpsZS5jb250YWlucztcXG4gIHZhciBybmVlZHNDb250ZXh0ID0galF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0O1xcbiAgdmFyIHJzaW5nbGVUYWcgPSAvXjwoXFxcXHcrKVxcXFxzKlxcXFwvPz4oPzo8XFxcXC9cXFxcMT58KSQvO1xcbiAgdmFyIHJpc1NpbXBsZSA9IC9eLlteOiNcXFxcW1xcXFwuLF0qJC87IC8vIEltcGxlbWVudCB0aGUgaWRlbnRpY2FsIGZ1bmN0aW9uYWxpdHkgZm9yIGZpbHRlciBhbmQgbm90XFxuXFxuICBmdW5jdGlvbiB3aW5ub3coZWxlbWVudHMsIHF1YWxpZmllciwgbm90KSB7XFxuICAgIGlmIChqUXVlcnkuaXNGdW5jdGlvbihxdWFsaWZpZXIpKSB7XFxuICAgICAgcmV0dXJuIGpRdWVyeS5ncmVwKGVsZW1lbnRzLCBmdW5jdGlvbiAoZWxlbSwgaSkge1xcbiAgICAgICAgLyoganNoaW50IC1XMDE4ICovXFxuICAgICAgICByZXR1cm4gISFxdWFsaWZpZXIuY2FsbChlbGVtLCBpLCBlbGVtKSAhPT0gbm90O1xcbiAgICAgIH0pO1xcbiAgICB9XFxuXFxuICAgIGlmIChxdWFsaWZpZXIubm9kZVR5cGUpIHtcXG4gICAgICByZXR1cm4galF1ZXJ5LmdyZXAoZWxlbWVudHMsIGZ1bmN0aW9uIChlbGVtKSB7XFxuICAgICAgICByZXR1cm4gZWxlbSA9PT0gcXVhbGlmaWVyICE9PSBub3Q7XFxuICAgICAgfSk7XFxuICAgIH1cXG5cXG4gICAgaWYgKHR5cGVvZiBxdWFsaWZpZXIgPT09IFxcXCJzdHJpbmdcXFwiKSB7XFxuICAgICAgaWYgKHJpc1NpbXBsZS50ZXN0KHF1YWxpZmllcikpIHtcXG4gICAgICAgIHJldHVybiBqUXVlcnkuZmlsdGVyKHF1YWxpZmllciwgZWxlbWVudHMsIG5vdCk7XFxuICAgICAgfVxcblxcbiAgICAgIHF1YWxpZmllciA9IGpRdWVyeS5maWx0ZXIocXVhbGlmaWVyLCBlbGVtZW50cyk7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIGpRdWVyeS5ncmVwKGVsZW1lbnRzLCBmdW5jdGlvbiAoZWxlbSkge1xcbiAgICAgIHJldHVybiBpbmRleE9mLmNhbGwocXVhbGlmaWVyLCBlbGVtKSA+PSAwICE9PSBub3Q7XFxuICAgIH0pO1xcbiAgfVxcblxcbiAgalF1ZXJ5LmZpbHRlciA9IGZ1bmN0aW9uIChleHByLCBlbGVtcywgbm90KSB7XFxuICAgIHZhciBlbGVtID0gZWxlbXNbMF07XFxuXFxuICAgIGlmIChub3QpIHtcXG4gICAgICBleHByID0gXFxcIjpub3QoXFxcIiArIGV4cHIgKyBcXFwiKVxcXCI7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIGVsZW1zLmxlbmd0aCA9PT0gMSAmJiBlbGVtLm5vZGVUeXBlID09PSAxID8galF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKGVsZW0sIGV4cHIpID8gW2VsZW1dIDogW10gOiBqUXVlcnkuZmluZC5tYXRjaGVzKGV4cHIsIGpRdWVyeS5ncmVwKGVsZW1zLCBmdW5jdGlvbiAoZWxlbSkge1xcbiAgICAgIHJldHVybiBlbGVtLm5vZGVUeXBlID09PSAxO1xcbiAgICB9KSk7XFxuICB9O1xcblxcbiAgalF1ZXJ5LmZuLmV4dGVuZCh7XFxuICAgIGZpbmQ6IGZ1bmN0aW9uIGZpbmQoc2VsZWN0b3IpIHtcXG4gICAgICB2YXIgaSxcXG4gICAgICAgICAgbGVuID0gdGhpcy5sZW5ndGgsXFxuICAgICAgICAgIHJldCA9IFtdLFxcbiAgICAgICAgICBzZWxmID0gdGhpcztcXG5cXG4gICAgICBpZiAodHlwZW9mIHNlbGVjdG9yICE9PSBcXFwic3RyaW5nXFxcIikge1xcbiAgICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKGpRdWVyeShzZWxlY3RvcikuZmlsdGVyKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XFxuICAgICAgICAgICAgaWYgKGpRdWVyeS5jb250YWlucyhzZWxmW2ldLCB0aGlzKSkge1xcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9KSk7XFxuICAgICAgfVxcblxcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xcbiAgICAgICAgalF1ZXJ5LmZpbmQoc2VsZWN0b3IsIHNlbGZbaV0sIHJldCk7XFxuICAgICAgfSAvLyBOZWVkZWQgYmVjYXVzZSAkKCBzZWxlY3RvciwgY29udGV4dCApIGJlY29tZXMgJCggY29udGV4dCApLmZpbmQoIHNlbGVjdG9yIClcXG5cXG5cXG4gICAgICByZXQgPSB0aGlzLnB1c2hTdGFjayhsZW4gPiAxID8galF1ZXJ5LnVuaXF1ZShyZXQpIDogcmV0KTtcXG4gICAgICByZXQuc2VsZWN0b3IgPSB0aGlzLnNlbGVjdG9yID8gdGhpcy5zZWxlY3RvciArIFxcXCIgXFxcIiArIHNlbGVjdG9yIDogc2VsZWN0b3I7XFxuICAgICAgcmV0dXJuIHJldDtcXG4gICAgfSxcXG4gICAgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIoc2VsZWN0b3IpIHtcXG4gICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2sod2lubm93KHRoaXMsIHNlbGVjdG9yIHx8IFtdLCBmYWxzZSkpO1xcbiAgICB9LFxcbiAgICBub3Q6IGZ1bmN0aW9uIG5vdChzZWxlY3Rvcikge1xcbiAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayh3aW5ub3codGhpcywgc2VsZWN0b3IgfHwgW10sIHRydWUpKTtcXG4gICAgfSxcXG4gICAgaXM6IGZ1bmN0aW9uIGlzKHNlbGVjdG9yKSB7XFxuICAgICAgcmV0dXJuICEhd2lubm93KHRoaXMsIC8vIElmIHRoaXMgaXMgYSBwb3NpdGlvbmFsL3JlbGF0aXZlIHNlbGVjdG9yLCBjaGVjayBtZW1iZXJzaGlwIGluIHRoZSByZXR1cm5lZCBzZXRcXG4gICAgICAvLyBzbyAkKFxcXCJwOmZpcnN0XFxcIikuaXMoXFxcInA6bGFzdFxcXCIpIHdvbid0IHJldHVybiB0cnVlIGZvciBhIGRvYyB3aXRoIHR3byBcXFwicFxcXCIuXFxuICAgICAgdHlwZW9mIHNlbGVjdG9yID09PSBcXFwic3RyaW5nXFxcIiAmJiBybmVlZHNDb250ZXh0LnRlc3Qoc2VsZWN0b3IpID8galF1ZXJ5KHNlbGVjdG9yKSA6IHNlbGVjdG9yIHx8IFtdLCBmYWxzZSkubGVuZ3RoO1xcbiAgICB9XFxuICB9KTsgLy8gSW5pdGlhbGl6ZSBhIGpRdWVyeSBvYmplY3RcXG4gIC8vIEEgY2VudHJhbCByZWZlcmVuY2UgdG8gdGhlIHJvb3QgalF1ZXJ5KGRvY3VtZW50KVxcblxcbiAgdmFyIHJvb3RqUXVlcnksXFxuICAgICAgLy8gQSBzaW1wbGUgd2F5IHRvIGNoZWNrIGZvciBIVE1MIHN0cmluZ3NcXG4gIC8vIFByaW9yaXRpemUgI2lkIG92ZXIgPHRhZz4gdG8gYXZvaWQgWFNTIHZpYSBsb2NhdGlvbi5oYXNoICgjOTUyMSlcXG4gIC8vIFN0cmljdCBIVE1MIHJlY29nbml0aW9uICgjMTEyOTA6IG11c3Qgc3RhcnQgd2l0aCA8KVxcbiAgcnF1aWNrRXhwciA9IC9eKD86XFxcXHMqKDxbXFxcXHdcXFxcV10rPilbXj5dKnwjKFtcXFxcdy1dKikpJC8sXFxuICAgICAgaW5pdCA9IGpRdWVyeS5mbi5pbml0ID0gZnVuY3Rpb24gKHNlbGVjdG9yLCBjb250ZXh0KSB7XFxuICAgIHZhciBtYXRjaCwgZWxlbTsgLy8gSEFORExFOiAkKFxcXCJcXFwiKSwgJChudWxsKSwgJCh1bmRlZmluZWQpLCAkKGZhbHNlKVxcblxcbiAgICBpZiAoIXNlbGVjdG9yKSB7XFxuICAgICAgcmV0dXJuIHRoaXM7XFxuICAgIH0gLy8gSGFuZGxlIEhUTUwgc3RyaW5nc1xcblxcblxcbiAgICBpZiAodHlwZW9mIHNlbGVjdG9yID09PSBcXFwic3RyaW5nXFxcIikge1xcbiAgICAgIGlmIChzZWxlY3RvclswXSA9PT0gXFxcIjxcXFwiICYmIHNlbGVjdG9yW3NlbGVjdG9yLmxlbmd0aCAtIDFdID09PSBcXFwiPlxcXCIgJiYgc2VsZWN0b3IubGVuZ3RoID49IDMpIHtcXG4gICAgICAgIC8vIEFzc3VtZSB0aGF0IHN0cmluZ3MgdGhhdCBzdGFydCBhbmQgZW5kIHdpdGggPD4gYXJlIEhUTUwgYW5kIHNraXAgdGhlIHJlZ2V4IGNoZWNrXFxuICAgICAgICBtYXRjaCA9IFtudWxsLCBzZWxlY3RvciwgbnVsbF07XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIG1hdGNoID0gcnF1aWNrRXhwci5leGVjKHNlbGVjdG9yKTtcXG4gICAgICB9IC8vIE1hdGNoIGh0bWwgb3IgbWFrZSBzdXJlIG5vIGNvbnRleHQgaXMgc3BlY2lmaWVkIGZvciAjaWRcXG5cXG5cXG4gICAgICBpZiAobWF0Y2ggJiYgKG1hdGNoWzFdIHx8ICFjb250ZXh0KSkge1xcbiAgICAgICAgLy8gSEFORExFOiAkKGh0bWwpIC0+ICQoYXJyYXkpXFxuICAgICAgICBpZiAobWF0Y2hbMV0pIHtcXG4gICAgICAgICAgY29udGV4dCA9IGNvbnRleHQgaW5zdGFuY2VvZiBqUXVlcnkgPyBjb250ZXh0WzBdIDogY29udGV4dDsgLy8gT3B0aW9uIHRvIHJ1biBzY3JpcHRzIGlzIHRydWUgZm9yIGJhY2stY29tcGF0XFxuICAgICAgICAgIC8vIEludGVudGlvbmFsbHkgbGV0IHRoZSBlcnJvciBiZSB0aHJvd24gaWYgcGFyc2VIVE1MIGlzIG5vdCBwcmVzZW50XFxuXFxuICAgICAgICAgIGpRdWVyeS5tZXJnZSh0aGlzLCBqUXVlcnkucGFyc2VIVE1MKG1hdGNoWzFdLCBjb250ZXh0ICYmIGNvbnRleHQubm9kZVR5cGUgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IGRvY3VtZW50LCB0cnVlKSk7IC8vIEhBTkRMRTogJChodG1sLCBwcm9wcylcXG5cXG4gICAgICAgICAgaWYgKHJzaW5nbGVUYWcudGVzdChtYXRjaFsxXSkgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3QoY29udGV4dCkpIHtcXG4gICAgICAgICAgICBmb3IgKG1hdGNoIGluIGNvbnRleHQpIHtcXG4gICAgICAgICAgICAgIC8vIFByb3BlcnRpZXMgb2YgY29udGV4dCBhcmUgY2FsbGVkIGFzIG1ldGhvZHMgaWYgcG9zc2libGVcXG4gICAgICAgICAgICAgIGlmIChqUXVlcnkuaXNGdW5jdGlvbih0aGlzW21hdGNoXSkpIHtcXG4gICAgICAgICAgICAgICAgdGhpc1ttYXRjaF0oY29udGV4dFttYXRjaF0pOyAvLyAuLi5hbmQgb3RoZXJ3aXNlIHNldCBhcyBhdHRyaWJ1dGVzXFxuICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICB0aGlzLmF0dHIobWF0Y2gsIGNvbnRleHRbbWF0Y2hdKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgcmV0dXJuIHRoaXM7IC8vIEhBTkRMRTogJCgjaWQpXFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBlbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobWF0Y2hbMl0pOyAvLyBTdXBwb3J0OiBCbGFja2JlcnJ5IDQuNlxcbiAgICAgICAgICAvLyBnRUJJRCByZXR1cm5zIG5vZGVzIG5vIGxvbmdlciBpbiB0aGUgZG9jdW1lbnQgKCM2OTYzKVxcblxcbiAgICAgICAgICBpZiAoZWxlbSAmJiBlbGVtLnBhcmVudE5vZGUpIHtcXG4gICAgICAgICAgICAvLyBJbmplY3QgdGhlIGVsZW1lbnQgZGlyZWN0bHkgaW50byB0aGUgalF1ZXJ5IG9iamVjdFxcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gMTtcXG4gICAgICAgICAgICB0aGlzWzBdID0gZWxlbTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICB0aGlzLmNvbnRleHQgPSBkb2N1bWVudDtcXG4gICAgICAgICAgdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xcbiAgICAgICAgICByZXR1cm4gdGhpcztcXG4gICAgICAgIH0gLy8gSEFORExFOiAkKGV4cHIsICQoLi4uKSlcXG5cXG4gICAgICB9IGVsc2UgaWYgKCFjb250ZXh0IHx8IGNvbnRleHQuanF1ZXJ5KSB7XFxuICAgICAgICByZXR1cm4gKGNvbnRleHQgfHwgcm9vdGpRdWVyeSkuZmluZChzZWxlY3Rvcik7IC8vIEhBTkRMRTogJChleHByLCBjb250ZXh0KVxcbiAgICAgICAgLy8gKHdoaWNoIGlzIGp1c3QgZXF1aXZhbGVudCB0bzogJChjb250ZXh0KS5maW5kKGV4cHIpXFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKGNvbnRleHQpLmZpbmQoc2VsZWN0b3IpO1xcbiAgICAgIH0gLy8gSEFORExFOiAkKERPTUVsZW1lbnQpXFxuXFxuICAgIH0gZWxzZSBpZiAoc2VsZWN0b3Iubm9kZVR5cGUpIHtcXG4gICAgICB0aGlzLmNvbnRleHQgPSB0aGlzWzBdID0gc2VsZWN0b3I7XFxuICAgICAgdGhpcy5sZW5ndGggPSAxO1xcbiAgICAgIHJldHVybiB0aGlzOyAvLyBIQU5ETEU6ICQoZnVuY3Rpb24pXFxuICAgICAgLy8gU2hvcnRjdXQgZm9yIGRvY3VtZW50IHJlYWR5XFxuICAgIH0gZWxzZSBpZiAoalF1ZXJ5LmlzRnVuY3Rpb24oc2VsZWN0b3IpKSB7XFxuICAgICAgcmV0dXJuIHR5cGVvZiByb290alF1ZXJ5LnJlYWR5ICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IHJvb3RqUXVlcnkucmVhZHkoc2VsZWN0b3IpIDogLy8gRXhlY3V0ZSBpbW1lZGlhdGVseSBpZiByZWFkeSBpcyBub3QgcHJlc2VudFxcbiAgICAgIHNlbGVjdG9yKGpRdWVyeSk7XFxuICAgIH1cXG5cXG4gICAgaWYgKHNlbGVjdG9yLnNlbGVjdG9yICE9PSB1bmRlZmluZWQpIHtcXG4gICAgICB0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3Iuc2VsZWN0b3I7XFxuICAgICAgdGhpcy5jb250ZXh0ID0gc2VsZWN0b3IuY29udGV4dDtcXG4gICAgfVxcblxcbiAgICByZXR1cm4galF1ZXJ5Lm1ha2VBcnJheShzZWxlY3RvciwgdGhpcyk7XFxuICB9OyAvLyBHaXZlIHRoZSBpbml0IGZ1bmN0aW9uIHRoZSBqUXVlcnkgcHJvdG90eXBlIGZvciBsYXRlciBpbnN0YW50aWF0aW9uXFxuXFxuXFxuICBpbml0LnByb3RvdHlwZSA9IGpRdWVyeS5mbjsgLy8gSW5pdGlhbGl6ZSBjZW50cmFsIHJlZmVyZW5jZVxcblxcbiAgcm9vdGpRdWVyeSA9IGpRdWVyeShkb2N1bWVudCk7XFxuICB2YXIgcnBhcmVudHNwcmV2ID0gL14oPzpwYXJlbnRzfHByZXYoPzpVbnRpbHxBbGwpKS8sXFxuICAgICAgLy8gTWV0aG9kcyBndWFyYW50ZWVkIHRvIHByb2R1Y2UgYSB1bmlxdWUgc2V0IHdoZW4gc3RhcnRpbmcgZnJvbSBhIHVuaXF1ZSBzZXRcXG4gIGd1YXJhbnRlZWRVbmlxdWUgPSB7XFxuICAgIGNoaWxkcmVuOiB0cnVlLFxcbiAgICBjb250ZW50czogdHJ1ZSxcXG4gICAgbmV4dDogdHJ1ZSxcXG4gICAgcHJldjogdHJ1ZVxcbiAgfTtcXG4gIGpRdWVyeS5leHRlbmQoe1xcbiAgICBkaXI6IGZ1bmN0aW9uIGRpcihlbGVtLCBfZGlyLCB1bnRpbCkge1xcbiAgICAgIHZhciBtYXRjaGVkID0gW10sXFxuICAgICAgICAgIHRydW5jYXRlID0gdW50aWwgIT09IHVuZGVmaW5lZDtcXG5cXG4gICAgICB3aGlsZSAoKGVsZW0gPSBlbGVtW19kaXJdKSAmJiBlbGVtLm5vZGVUeXBlICE9PSA5KSB7XFxuICAgICAgICBpZiAoZWxlbS5ub2RlVHlwZSA9PT0gMSkge1xcbiAgICAgICAgICBpZiAodHJ1bmNhdGUgJiYgalF1ZXJ5KGVsZW0pLmlzKHVudGlsKSkge1xcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIG1hdGNoZWQucHVzaChlbGVtKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIG1hdGNoZWQ7XFxuICAgIH0sXFxuICAgIHNpYmxpbmc6IGZ1bmN0aW9uIHNpYmxpbmcobiwgZWxlbSkge1xcbiAgICAgIHZhciBtYXRjaGVkID0gW107XFxuXFxuICAgICAgZm9yICg7IG47IG4gPSBuLm5leHRTaWJsaW5nKSB7XFxuICAgICAgICBpZiAobi5ub2RlVHlwZSA9PT0gMSAmJiBuICE9PSBlbGVtKSB7XFxuICAgICAgICAgIG1hdGNoZWQucHVzaChuKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIG1hdGNoZWQ7XFxuICAgIH1cXG4gIH0pO1xcbiAgalF1ZXJ5LmZuLmV4dGVuZCh7XFxuICAgIGhhczogZnVuY3Rpb24gaGFzKHRhcmdldCkge1xcbiAgICAgIHZhciB0YXJnZXRzID0galF1ZXJ5KHRhcmdldCwgdGhpcyksXFxuICAgICAgICAgIGwgPSB0YXJnZXRzLmxlbmd0aDtcXG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIGkgPSAwO1xcblxcbiAgICAgICAgZm9yICg7IGkgPCBsOyBpKyspIHtcXG4gICAgICAgICAgaWYgKGpRdWVyeS5jb250YWlucyh0aGlzLCB0YXJnZXRzW2ldKSkge1xcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgIH0sXFxuICAgIGNsb3Nlc3Q6IGZ1bmN0aW9uIGNsb3Nlc3Qoc2VsZWN0b3JzLCBjb250ZXh0KSB7XFxuICAgICAgdmFyIGN1cixcXG4gICAgICAgICAgaSA9IDAsXFxuICAgICAgICAgIGwgPSB0aGlzLmxlbmd0aCxcXG4gICAgICAgICAgbWF0Y2hlZCA9IFtdLFxcbiAgICAgICAgICBwb3MgPSBybmVlZHNDb250ZXh0LnRlc3Qoc2VsZWN0b3JzKSB8fCB0eXBlb2Ygc2VsZWN0b3JzICE9PSBcXFwic3RyaW5nXFxcIiA/IGpRdWVyeShzZWxlY3RvcnMsIGNvbnRleHQgfHwgdGhpcy5jb250ZXh0KSA6IDA7XFxuXFxuICAgICAgZm9yICg7IGkgPCBsOyBpKyspIHtcXG4gICAgICAgIGZvciAoY3VyID0gdGhpc1tpXTsgY3VyICYmIGN1ciAhPT0gY29udGV4dDsgY3VyID0gY3VyLnBhcmVudE5vZGUpIHtcXG4gICAgICAgICAgLy8gQWx3YXlzIHNraXAgZG9jdW1lbnQgZnJhZ21lbnRzXFxuICAgICAgICAgIGlmIChjdXIubm9kZVR5cGUgPCAxMSAmJiAocG9zID8gcG9zLmluZGV4KGN1cikgPiAtMSA6IC8vIERvbid0IHBhc3Mgbm9uLWVsZW1lbnRzIHRvIFNpenpsZVxcbiAgICAgICAgICBjdXIubm9kZVR5cGUgPT09IDEgJiYgalF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKGN1ciwgc2VsZWN0b3JzKSkpIHtcXG4gICAgICAgICAgICBtYXRjaGVkLnB1c2goY3VyKTtcXG4gICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2sobWF0Y2hlZC5sZW5ndGggPiAxID8galF1ZXJ5LnVuaXF1ZShtYXRjaGVkKSA6IG1hdGNoZWQpO1xcbiAgICB9LFxcbiAgICAvLyBEZXRlcm1pbmUgdGhlIHBvc2l0aW9uIG9mIGFuIGVsZW1lbnQgd2l0aGluIHRoZSBzZXRcXG4gICAgaW5kZXg6IGZ1bmN0aW9uIGluZGV4KGVsZW0pIHtcXG4gICAgICAvLyBObyBhcmd1bWVudCwgcmV0dXJuIGluZGV4IGluIHBhcmVudFxcbiAgICAgIGlmICghZWxlbSkge1xcbiAgICAgICAgcmV0dXJuIHRoaXNbMF0gJiYgdGhpc1swXS5wYXJlbnROb2RlID8gdGhpcy5maXJzdCgpLnByZXZBbGwoKS5sZW5ndGggOiAtMTtcXG4gICAgICB9IC8vIEluZGV4IGluIHNlbGVjdG9yXFxuXFxuXFxuICAgICAgaWYgKHR5cGVvZiBlbGVtID09PSBcXFwic3RyaW5nXFxcIikge1xcbiAgICAgICAgcmV0dXJuIGluZGV4T2YuY2FsbChqUXVlcnkoZWxlbSksIHRoaXNbMF0pO1xcbiAgICAgIH0gLy8gTG9jYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgZGVzaXJlZCBlbGVtZW50XFxuXFxuXFxuICAgICAgcmV0dXJuIGluZGV4T2YuY2FsbCh0aGlzLCAvLyBJZiBpdCByZWNlaXZlcyBhIGpRdWVyeSBvYmplY3QsIHRoZSBmaXJzdCBlbGVtZW50IGlzIHVzZWRcXG4gICAgICBlbGVtLmpxdWVyeSA/IGVsZW1bMF0gOiBlbGVtKTtcXG4gICAgfSxcXG4gICAgYWRkOiBmdW5jdGlvbiBhZGQoc2VsZWN0b3IsIGNvbnRleHQpIHtcXG4gICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soalF1ZXJ5LnVuaXF1ZShqUXVlcnkubWVyZ2UodGhpcy5nZXQoKSwgalF1ZXJ5KHNlbGVjdG9yLCBjb250ZXh0KSkpKTtcXG4gICAgfSxcXG4gICAgYWRkQmFjazogZnVuY3Rpb24gYWRkQmFjayhzZWxlY3Rvcikge1xcbiAgICAgIHJldHVybiB0aGlzLmFkZChzZWxlY3RvciA9PSBudWxsID8gdGhpcy5wcmV2T2JqZWN0IDogdGhpcy5wcmV2T2JqZWN0LmZpbHRlcihzZWxlY3RvcikpO1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIGZ1bmN0aW9uIHNpYmxpbmcoY3VyLCBkaXIpIHtcXG4gICAgd2hpbGUgKChjdXIgPSBjdXJbZGlyXSkgJiYgY3VyLm5vZGVUeXBlICE9PSAxKSB7fVxcblxcbiAgICByZXR1cm4gY3VyO1xcbiAgfVxcblxcbiAgalF1ZXJ5LmVhY2goe1xcbiAgICBwYXJlbnQ6IGZ1bmN0aW9uIHBhcmVudChlbGVtKSB7XFxuICAgICAgdmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcXG4gICAgICByZXR1cm4gcGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSAhPT0gMTEgPyBwYXJlbnQgOiBudWxsO1xcbiAgICB9LFxcbiAgICBwYXJlbnRzOiBmdW5jdGlvbiBwYXJlbnRzKGVsZW0pIHtcXG4gICAgICByZXR1cm4galF1ZXJ5LmRpcihlbGVtLCBcXFwicGFyZW50Tm9kZVxcXCIpO1xcbiAgICB9LFxcbiAgICBwYXJlbnRzVW50aWw6IGZ1bmN0aW9uIHBhcmVudHNVbnRpbChlbGVtLCBpLCB1bnRpbCkge1xcbiAgICAgIHJldHVybiBqUXVlcnkuZGlyKGVsZW0sIFxcXCJwYXJlbnROb2RlXFxcIiwgdW50aWwpO1xcbiAgICB9LFxcbiAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KGVsZW0pIHtcXG4gICAgICByZXR1cm4gc2libGluZyhlbGVtLCBcXFwibmV4dFNpYmxpbmdcXFwiKTtcXG4gICAgfSxcXG4gICAgcHJldjogZnVuY3Rpb24gcHJldihlbGVtKSB7XFxuICAgICAgcmV0dXJuIHNpYmxpbmcoZWxlbSwgXFxcInByZXZpb3VzU2libGluZ1xcXCIpO1xcbiAgICB9LFxcbiAgICBuZXh0QWxsOiBmdW5jdGlvbiBuZXh0QWxsKGVsZW0pIHtcXG4gICAgICByZXR1cm4galF1ZXJ5LmRpcihlbGVtLCBcXFwibmV4dFNpYmxpbmdcXFwiKTtcXG4gICAgfSxcXG4gICAgcHJldkFsbDogZnVuY3Rpb24gcHJldkFsbChlbGVtKSB7XFxuICAgICAgcmV0dXJuIGpRdWVyeS5kaXIoZWxlbSwgXFxcInByZXZpb3VzU2libGluZ1xcXCIpO1xcbiAgICB9LFxcbiAgICBuZXh0VW50aWw6IGZ1bmN0aW9uIG5leHRVbnRpbChlbGVtLCBpLCB1bnRpbCkge1xcbiAgICAgIHJldHVybiBqUXVlcnkuZGlyKGVsZW0sIFxcXCJuZXh0U2libGluZ1xcXCIsIHVudGlsKTtcXG4gICAgfSxcXG4gICAgcHJldlVudGlsOiBmdW5jdGlvbiBwcmV2VW50aWwoZWxlbSwgaSwgdW50aWwpIHtcXG4gICAgICByZXR1cm4galF1ZXJ5LmRpcihlbGVtLCBcXFwicHJldmlvdXNTaWJsaW5nXFxcIiwgdW50aWwpO1xcbiAgICB9LFxcbiAgICBzaWJsaW5nczogZnVuY3Rpb24gc2libGluZ3MoZWxlbSkge1xcbiAgICAgIHJldHVybiBqUXVlcnkuc2libGluZygoZWxlbS5wYXJlbnROb2RlIHx8IHt9KS5maXJzdENoaWxkLCBlbGVtKTtcXG4gICAgfSxcXG4gICAgY2hpbGRyZW46IGZ1bmN0aW9uIGNoaWxkcmVuKGVsZW0pIHtcXG4gICAgICByZXR1cm4galF1ZXJ5LnNpYmxpbmcoZWxlbS5maXJzdENoaWxkKTtcXG4gICAgfSxcXG4gICAgY29udGVudHM6IGZ1bmN0aW9uIGNvbnRlbnRzKGVsZW0pIHtcXG4gICAgICByZXR1cm4gZWxlbS5jb250ZW50RG9jdW1lbnQgfHwgalF1ZXJ5Lm1lcmdlKFtdLCBlbGVtLmNoaWxkTm9kZXMpO1xcbiAgICB9XFxuICB9LCBmdW5jdGlvbiAobmFtZSwgZm4pIHtcXG4gICAgalF1ZXJ5LmZuW25hbWVdID0gZnVuY3Rpb24gKHVudGlsLCBzZWxlY3Rvcikge1xcbiAgICAgIHZhciBtYXRjaGVkID0galF1ZXJ5Lm1hcCh0aGlzLCBmbiwgdW50aWwpO1xcblxcbiAgICAgIGlmIChuYW1lLnNsaWNlKC01KSAhPT0gXFxcIlVudGlsXFxcIikge1xcbiAgICAgICAgc2VsZWN0b3IgPSB1bnRpbDtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHNlbGVjdG9yICYmIHR5cGVvZiBzZWxlY3RvciA9PT0gXFxcInN0cmluZ1xcXCIpIHtcXG4gICAgICAgIG1hdGNoZWQgPSBqUXVlcnkuZmlsdGVyKHNlbGVjdG9yLCBtYXRjaGVkKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMubGVuZ3RoID4gMSkge1xcbiAgICAgICAgLy8gUmVtb3ZlIGR1cGxpY2F0ZXNcXG4gICAgICAgIGlmICghZ3VhcmFudGVlZFVuaXF1ZVtuYW1lXSkge1xcbiAgICAgICAgICBqUXVlcnkudW5pcXVlKG1hdGNoZWQpO1xcbiAgICAgICAgfSAvLyBSZXZlcnNlIG9yZGVyIGZvciBwYXJlbnRzKiBhbmQgcHJldi1kZXJpdmF0aXZlc1xcblxcblxcbiAgICAgICAgaWYgKHJwYXJlbnRzcHJldi50ZXN0KG5hbWUpKSB7XFxuICAgICAgICAgIG1hdGNoZWQucmV2ZXJzZSgpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2sobWF0Y2hlZCk7XFxuICAgIH07XFxuICB9KTtcXG4gIHZhciBybm90d2hpdGUgPSAvXFxcXFMrL2c7IC8vIFN0cmluZyB0byBPYmplY3Qgb3B0aW9ucyBmb3JtYXQgY2FjaGVcXG5cXG4gIHZhciBvcHRpb25zQ2FjaGUgPSB7fTsgLy8gQ29udmVydCBTdHJpbmctZm9ybWF0dGVkIG9wdGlvbnMgaW50byBPYmplY3QtZm9ybWF0dGVkIG9uZXMgYW5kIHN0b3JlIGluIGNhY2hlXFxuXFxuICBmdW5jdGlvbiBjcmVhdGVPcHRpb25zKG9wdGlvbnMpIHtcXG4gICAgdmFyIG9iamVjdCA9IG9wdGlvbnNDYWNoZVtvcHRpb25zXSA9IHt9O1xcbiAgICBqUXVlcnkuZWFjaChvcHRpb25zLm1hdGNoKHJub3R3aGl0ZSkgfHwgW10sIGZ1bmN0aW9uIChfLCBmbGFnKSB7XFxuICAgICAgb2JqZWN0W2ZsYWddID0gdHJ1ZTtcXG4gICAgfSk7XFxuICAgIHJldHVybiBvYmplY3Q7XFxuICB9XFxuICAvKlxcbiAgICogQ3JlYXRlIGEgY2FsbGJhY2sgbGlzdCB1c2luZyB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XFxuICAgKlxcbiAgICpcXHRvcHRpb25zOiBhbiBvcHRpb25hbCBsaXN0IG9mIHNwYWNlLXNlcGFyYXRlZCBvcHRpb25zIHRoYXQgd2lsbCBjaGFuZ2UgaG93XFxuICAgKlxcdFxcdFxcdHRoZSBjYWxsYmFjayBsaXN0IGJlaGF2ZXMgb3IgYSBtb3JlIHRyYWRpdGlvbmFsIG9wdGlvbiBvYmplY3RcXG4gICAqXFxuICAgKiBCeSBkZWZhdWx0IGEgY2FsbGJhY2sgbGlzdCB3aWxsIGFjdCBsaWtlIGFuIGV2ZW50IGNhbGxiYWNrIGxpc3QgYW5kIGNhbiBiZVxcbiAgICogXFxcImZpcmVkXFxcIiBtdWx0aXBsZSB0aW1lcy5cXG4gICAqXFxuICAgKiBQb3NzaWJsZSBvcHRpb25zOlxcbiAgICpcXG4gICAqXFx0b25jZTpcXHRcXHRcXHR3aWxsIGVuc3VyZSB0aGUgY2FsbGJhY2sgbGlzdCBjYW4gb25seSBiZSBmaXJlZCBvbmNlIChsaWtlIGEgRGVmZXJyZWQpXFxuICAgKlxcbiAgICpcXHRtZW1vcnk6XFx0XFx0XFx0d2lsbCBrZWVwIHRyYWNrIG9mIHByZXZpb3VzIHZhbHVlcyBhbmQgd2lsbCBjYWxsIGFueSBjYWxsYmFjayBhZGRlZFxcbiAgICpcXHRcXHRcXHRcXHRcXHRhZnRlciB0aGUgbGlzdCBoYXMgYmVlbiBmaXJlZCByaWdodCBhd2F5IHdpdGggdGhlIGxhdGVzdCBcXFwibWVtb3JpemVkXFxcIlxcbiAgICpcXHRcXHRcXHRcXHRcXHR2YWx1ZXMgKGxpa2UgYSBEZWZlcnJlZClcXG4gICAqXFxuICAgKlxcdHVuaXF1ZTpcXHRcXHRcXHR3aWxsIGVuc3VyZSBhIGNhbGxiYWNrIGNhbiBvbmx5IGJlIGFkZGVkIG9uY2UgKG5vIGR1cGxpY2F0ZSBpbiB0aGUgbGlzdClcXG4gICAqXFxuICAgKlxcdHN0b3BPbkZhbHNlOlxcdGludGVycnVwdCBjYWxsaW5ncyB3aGVuIGEgY2FsbGJhY2sgcmV0dXJucyBmYWxzZVxcbiAgICpcXG4gICAqL1xcblxcblxcbiAgalF1ZXJ5LkNhbGxiYWNrcyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XFxuICAgIC8vIENvbnZlcnQgb3B0aW9ucyBmcm9tIFN0cmluZy1mb3JtYXR0ZWQgdG8gT2JqZWN0LWZvcm1hdHRlZCBpZiBuZWVkZWRcXG4gICAgLy8gKHdlIGNoZWNrIGluIGNhY2hlIGZpcnN0KVxcbiAgICBvcHRpb25zID0gdHlwZW9mIG9wdGlvbnMgPT09IFxcXCJzdHJpbmdcXFwiID8gb3B0aW9uc0NhY2hlW29wdGlvbnNdIHx8IGNyZWF0ZU9wdGlvbnMob3B0aW9ucykgOiBqUXVlcnkuZXh0ZW5kKHt9LCBvcHRpb25zKTtcXG5cXG4gICAgdmFyIC8vIExhc3QgZmlyZSB2YWx1ZSAoZm9yIG5vbi1mb3JnZXR0YWJsZSBsaXN0cylcXG4gICAgbWVtb3J5LFxcbiAgICAgICAgLy8gRmxhZyB0byBrbm93IGlmIGxpc3Qgd2FzIGFscmVhZHkgZmlyZWRcXG4gICAgX2ZpcmVkLFxcbiAgICAgICAgLy8gRmxhZyB0byBrbm93IGlmIGxpc3QgaXMgY3VycmVudGx5IGZpcmluZ1xcbiAgICBmaXJpbmcsXFxuICAgICAgICAvLyBGaXJzdCBjYWxsYmFjayB0byBmaXJlICh1c2VkIGludGVybmFsbHkgYnkgYWRkIGFuZCBmaXJlV2l0aClcXG4gICAgZmlyaW5nU3RhcnQsXFxuICAgICAgICAvLyBFbmQgb2YgdGhlIGxvb3Agd2hlbiBmaXJpbmdcXG4gICAgZmlyaW5nTGVuZ3RoLFxcbiAgICAgICAgLy8gSW5kZXggb2YgY3VycmVudGx5IGZpcmluZyBjYWxsYmFjayAobW9kaWZpZWQgYnkgcmVtb3ZlIGlmIG5lZWRlZClcXG4gICAgZmlyaW5nSW5kZXgsXFxuICAgICAgICAvLyBBY3R1YWwgY2FsbGJhY2sgbGlzdFxcbiAgICBsaXN0ID0gW10sXFxuICAgICAgICAvLyBTdGFjayBvZiBmaXJlIGNhbGxzIGZvciByZXBlYXRhYmxlIGxpc3RzXFxuICAgIHN0YWNrID0gIW9wdGlvbnMub25jZSAmJiBbXSxcXG4gICAgICAgIC8vIEZpcmUgY2FsbGJhY2tzXFxuICAgIGZpcmUgPSBmdW5jdGlvbiBmaXJlKGRhdGEpIHtcXG4gICAgICBtZW1vcnkgPSBvcHRpb25zLm1lbW9yeSAmJiBkYXRhO1xcbiAgICAgIF9maXJlZCA9IHRydWU7XFxuICAgICAgZmlyaW5nSW5kZXggPSBmaXJpbmdTdGFydCB8fCAwO1xcbiAgICAgIGZpcmluZ1N0YXJ0ID0gMDtcXG4gICAgICBmaXJpbmdMZW5ndGggPSBsaXN0Lmxlbmd0aDtcXG4gICAgICBmaXJpbmcgPSB0cnVlO1xcblxcbiAgICAgIGZvciAoOyBsaXN0ICYmIGZpcmluZ0luZGV4IDwgZmlyaW5nTGVuZ3RoOyBmaXJpbmdJbmRleCsrKSB7XFxuICAgICAgICBpZiAobGlzdFtmaXJpbmdJbmRleF0uYXBwbHkoZGF0YVswXSwgZGF0YVsxXSkgPT09IGZhbHNlICYmIG9wdGlvbnMuc3RvcE9uRmFsc2UpIHtcXG4gICAgICAgICAgbWVtb3J5ID0gZmFsc2U7IC8vIFRvIHByZXZlbnQgZnVydGhlciBjYWxscyB1c2luZyBhZGRcXG5cXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGZpcmluZyA9IGZhbHNlO1xcblxcbiAgICAgIGlmIChsaXN0KSB7XFxuICAgICAgICBpZiAoc3RhY2spIHtcXG4gICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCkge1xcbiAgICAgICAgICAgIGZpcmUoc3RhY2suc2hpZnQoKSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSBpZiAobWVtb3J5KSB7XFxuICAgICAgICAgIGxpc3QgPSBbXTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHNlbGYuZGlzYWJsZSgpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgICAgIC8vIEFjdHVhbCBDYWxsYmFja3Mgb2JqZWN0XFxuICAgIHNlbGYgPSB7XFxuICAgICAgLy8gQWRkIGEgY2FsbGJhY2sgb3IgYSBjb2xsZWN0aW9uIG9mIGNhbGxiYWNrcyB0byB0aGUgbGlzdFxcbiAgICAgIGFkZDogZnVuY3Rpb24gYWRkKCkge1xcbiAgICAgICAgaWYgKGxpc3QpIHtcXG4gICAgICAgICAgLy8gRmlyc3QsIHdlIHNhdmUgdGhlIGN1cnJlbnQgbGVuZ3RoXFxuICAgICAgICAgIHZhciBzdGFydCA9IGxpc3QubGVuZ3RoO1xcblxcbiAgICAgICAgICAoZnVuY3Rpb24gYWRkKGFyZ3MpIHtcXG4gICAgICAgICAgICBqUXVlcnkuZWFjaChhcmdzLCBmdW5jdGlvbiAoXywgYXJnKSB7XFxuICAgICAgICAgICAgICB2YXIgdHlwZSA9IGpRdWVyeS50eXBlKGFyZyk7XFxuXFxuICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gXFxcImZ1bmN0aW9uXFxcIikge1xcbiAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMudW5pcXVlIHx8ICFzZWxmLmhhcyhhcmcpKSB7XFxuICAgICAgICAgICAgICAgICAgbGlzdC5wdXNoKGFyZyk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJnICYmIGFyZy5sZW5ndGggJiYgdHlwZSAhPT0gXFxcInN0cmluZ1xcXCIpIHtcXG4gICAgICAgICAgICAgICAgLy8gSW5zcGVjdCByZWN1cnNpdmVseVxcbiAgICAgICAgICAgICAgICBhZGQoYXJnKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgfSkoYXJndW1lbnRzKTsgLy8gRG8gd2UgbmVlZCB0byBhZGQgdGhlIGNhbGxiYWNrcyB0byB0aGVcXG4gICAgICAgICAgLy8gY3VycmVudCBmaXJpbmcgYmF0Y2g/XFxuXFxuXFxuICAgICAgICAgIGlmIChmaXJpbmcpIHtcXG4gICAgICAgICAgICBmaXJpbmdMZW5ndGggPSBsaXN0Lmxlbmd0aDsgLy8gV2l0aCBtZW1vcnksIGlmIHdlJ3JlIG5vdCBmaXJpbmcgdGhlblxcbiAgICAgICAgICAgIC8vIHdlIHNob3VsZCBjYWxsIHJpZ2h0IGF3YXlcXG4gICAgICAgICAgfSBlbHNlIGlmIChtZW1vcnkpIHtcXG4gICAgICAgICAgICBmaXJpbmdTdGFydCA9IHN0YXJ0O1xcbiAgICAgICAgICAgIGZpcmUobWVtb3J5KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIHRoaXM7XFxuICAgICAgfSxcXG4gICAgICAvLyBSZW1vdmUgYSBjYWxsYmFjayBmcm9tIHRoZSBsaXN0XFxuICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XFxuICAgICAgICBpZiAobGlzdCkge1xcbiAgICAgICAgICBqUXVlcnkuZWFjaChhcmd1bWVudHMsIGZ1bmN0aW9uIChfLCBhcmcpIHtcXG4gICAgICAgICAgICB2YXIgaW5kZXg7XFxuXFxuICAgICAgICAgICAgd2hpbGUgKChpbmRleCA9IGpRdWVyeS5pbkFycmF5KGFyZywgbGlzdCwgaW5kZXgpKSA+IC0xKSB7XFxuICAgICAgICAgICAgICBsaXN0LnNwbGljZShpbmRleCwgMSk7IC8vIEhhbmRsZSBmaXJpbmcgaW5kZXhlc1xcblxcbiAgICAgICAgICAgICAgaWYgKGZpcmluZykge1xcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPD0gZmlyaW5nTGVuZ3RoKSB7XFxuICAgICAgICAgICAgICAgICAgZmlyaW5nTGVuZ3RoLS07XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDw9IGZpcmluZ0luZGV4KSB7XFxuICAgICAgICAgICAgICAgICAgZmlyaW5nSW5kZXgtLTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gdGhpcztcXG4gICAgICB9LFxcbiAgICAgIC8vIENoZWNrIGlmIGEgZ2l2ZW4gY2FsbGJhY2sgaXMgaW4gdGhlIGxpc3QuXFxuICAgICAgLy8gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHJldHVybiB3aGV0aGVyIG9yIG5vdCBsaXN0IGhhcyBjYWxsYmFja3MgYXR0YWNoZWQuXFxuICAgICAgaGFzOiBmdW5jdGlvbiBoYXMoZm4pIHtcXG4gICAgICAgIHJldHVybiBmbiA/IGpRdWVyeS5pbkFycmF5KGZuLCBsaXN0KSA+IC0xIDogISEobGlzdCAmJiBsaXN0Lmxlbmd0aCk7XFxuICAgICAgfSxcXG4gICAgICAvLyBSZW1vdmUgYWxsIGNhbGxiYWNrcyBmcm9tIHRoZSBsaXN0XFxuICAgICAgZW1wdHk6IGZ1bmN0aW9uIGVtcHR5KCkge1xcbiAgICAgICAgbGlzdCA9IFtdO1xcbiAgICAgICAgZmlyaW5nTGVuZ3RoID0gMDtcXG4gICAgICAgIHJldHVybiB0aGlzO1xcbiAgICAgIH0sXFxuICAgICAgLy8gSGF2ZSB0aGUgbGlzdCBkbyBub3RoaW5nIGFueW1vcmVcXG4gICAgICBkaXNhYmxlOiBmdW5jdGlvbiBkaXNhYmxlKCkge1xcbiAgICAgICAgbGlzdCA9IHN0YWNrID0gbWVtb3J5ID0gdW5kZWZpbmVkO1xcbiAgICAgICAgcmV0dXJuIHRoaXM7XFxuICAgICAgfSxcXG4gICAgICAvLyBJcyBpdCBkaXNhYmxlZD9cXG4gICAgICBkaXNhYmxlZDogZnVuY3Rpb24gZGlzYWJsZWQoKSB7XFxuICAgICAgICByZXR1cm4gIWxpc3Q7XFxuICAgICAgfSxcXG4gICAgICAvLyBMb2NrIHRoZSBsaXN0IGluIGl0cyBjdXJyZW50IHN0YXRlXFxuICAgICAgbG9jazogZnVuY3Rpb24gbG9jaygpIHtcXG4gICAgICAgIHN0YWNrID0gdW5kZWZpbmVkO1xcblxcbiAgICAgICAgaWYgKCFtZW1vcnkpIHtcXG4gICAgICAgICAgc2VsZi5kaXNhYmxlKCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gdGhpcztcXG4gICAgICB9LFxcbiAgICAgIC8vIElzIGl0IGxvY2tlZD9cXG4gICAgICBsb2NrZWQ6IGZ1bmN0aW9uIGxvY2tlZCgpIHtcXG4gICAgICAgIHJldHVybiAhc3RhY2s7XFxuICAgICAgfSxcXG4gICAgICAvLyBDYWxsIGFsbCBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gY29udGV4dCBhbmQgYXJndW1lbnRzXFxuICAgICAgZmlyZVdpdGg6IGZ1bmN0aW9uIGZpcmVXaXRoKGNvbnRleHQsIGFyZ3MpIHtcXG4gICAgICAgIGlmIChsaXN0ICYmICghX2ZpcmVkIHx8IHN0YWNrKSkge1xcbiAgICAgICAgICBhcmdzID0gYXJncyB8fCBbXTtcXG4gICAgICAgICAgYXJncyA9IFtjb250ZXh0LCBhcmdzLnNsaWNlID8gYXJncy5zbGljZSgpIDogYXJnc107XFxuXFxuICAgICAgICAgIGlmIChmaXJpbmcpIHtcXG4gICAgICAgICAgICBzdGFjay5wdXNoKGFyZ3MpO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGZpcmUoYXJncyk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiB0aGlzO1xcbiAgICAgIH0sXFxuICAgICAgLy8gQ2FsbCBhbGwgdGhlIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudHNcXG4gICAgICBmaXJlOiBmdW5jdGlvbiBmaXJlKCkge1xcbiAgICAgICAgc2VsZi5maXJlV2l0aCh0aGlzLCBhcmd1bWVudHMpO1xcbiAgICAgICAgcmV0dXJuIHRoaXM7XFxuICAgICAgfSxcXG4gICAgICAvLyBUbyBrbm93IGlmIHRoZSBjYWxsYmFja3MgaGF2ZSBhbHJlYWR5IGJlZW4gY2FsbGVkIGF0IGxlYXN0IG9uY2VcXG4gICAgICBmaXJlZDogZnVuY3Rpb24gZmlyZWQoKSB7XFxuICAgICAgICByZXR1cm4gISFfZmlyZWQ7XFxuICAgICAgfVxcbiAgICB9O1xcblxcbiAgICByZXR1cm4gc2VsZjtcXG4gIH07XFxuXFxuICBqUXVlcnkuZXh0ZW5kKHtcXG4gICAgRGVmZXJyZWQ6IGZ1bmN0aW9uIERlZmVycmVkKGZ1bmMpIHtcXG4gICAgICB2YXIgdHVwbGVzID0gWy8vIGFjdGlvbiwgYWRkIGxpc3RlbmVyLCBsaXN0ZW5lciBsaXN0LCBmaW5hbCBzdGF0ZVxcbiAgICAgIFtcXFwicmVzb2x2ZVxcXCIsIFxcXCJkb25lXFxcIiwgalF1ZXJ5LkNhbGxiYWNrcyhcXFwib25jZSBtZW1vcnlcXFwiKSwgXFxcInJlc29sdmVkXFxcIl0sIFtcXFwicmVqZWN0XFxcIiwgXFxcImZhaWxcXFwiLCBqUXVlcnkuQ2FsbGJhY2tzKFxcXCJvbmNlIG1lbW9yeVxcXCIpLCBcXFwicmVqZWN0ZWRcXFwiXSwgW1xcXCJub3RpZnlcXFwiLCBcXFwicHJvZ3Jlc3NcXFwiLCBqUXVlcnkuQ2FsbGJhY2tzKFxcXCJtZW1vcnlcXFwiKV1dLFxcbiAgICAgICAgICBfc3RhdGUgPSBcXFwicGVuZGluZ1xcXCIsXFxuICAgICAgICAgIF9wcm9taXNlID0ge1xcbiAgICAgICAgc3RhdGU6IGZ1bmN0aW9uIHN0YXRlKCkge1xcbiAgICAgICAgICByZXR1cm4gX3N0YXRlO1xcbiAgICAgICAgfSxcXG4gICAgICAgIGFsd2F5czogZnVuY3Rpb24gYWx3YXlzKCkge1xcbiAgICAgICAgICBkZWZlcnJlZC5kb25lKGFyZ3VtZW50cykuZmFpbChhcmd1bWVudHMpO1xcbiAgICAgICAgICByZXR1cm4gdGhpcztcXG4gICAgICAgIH0sXFxuICAgICAgICB0aGVuOiBmdW5jdGlvbiB0aGVuKClcXG4gICAgICAgIC8qIGZuRG9uZSwgZm5GYWlsLCBmblByb2dyZXNzICovXFxuICAgICAgICB7XFxuICAgICAgICAgIHZhciBmbnMgPSBhcmd1bWVudHM7XFxuICAgICAgICAgIHJldHVybiBqUXVlcnkuRGVmZXJyZWQoZnVuY3Rpb24gKG5ld0RlZmVyKSB7XFxuICAgICAgICAgICAgalF1ZXJ5LmVhY2godHVwbGVzLCBmdW5jdGlvbiAoaSwgdHVwbGUpIHtcXG4gICAgICAgICAgICAgIHZhciBmbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKGZuc1tpXSkgJiYgZm5zW2ldOyAvLyBkZWZlcnJlZFsgZG9uZSB8IGZhaWwgfCBwcm9ncmVzcyBdIGZvciBmb3J3YXJkaW5nIGFjdGlvbnMgdG8gbmV3RGVmZXJcXG5cXG4gICAgICAgICAgICAgIGRlZmVycmVkW3R1cGxlWzFdXShmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgIHZhciByZXR1cm5lZCA9IGZuICYmIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuXFxuICAgICAgICAgICAgICAgIGlmIChyZXR1cm5lZCAmJiBqUXVlcnkuaXNGdW5jdGlvbihyZXR1cm5lZC5wcm9taXNlKSkge1xcbiAgICAgICAgICAgICAgICAgIHJldHVybmVkLnByb21pc2UoKS5kb25lKG5ld0RlZmVyLnJlc29sdmUpLmZhaWwobmV3RGVmZXIucmVqZWN0KS5wcm9ncmVzcyhuZXdEZWZlci5ub3RpZnkpO1xcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgIG5ld0RlZmVyW3R1cGxlWzBdICsgXFxcIldpdGhcXFwiXSh0aGlzID09PSBfcHJvbWlzZSA/IG5ld0RlZmVyLnByb21pc2UoKSA6IHRoaXMsIGZuID8gW3JldHVybmVkXSA6IGFyZ3VtZW50cyk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIGZucyA9IG51bGw7XFxuICAgICAgICAgIH0pLnByb21pc2UoKTtcXG4gICAgICAgIH0sXFxuICAgICAgICAvLyBHZXQgYSBwcm9taXNlIGZvciB0aGlzIGRlZmVycmVkXFxuICAgICAgICAvLyBJZiBvYmogaXMgcHJvdmlkZWQsIHRoZSBwcm9taXNlIGFzcGVjdCBpcyBhZGRlZCB0byB0aGUgb2JqZWN0XFxuICAgICAgICBwcm9taXNlOiBmdW5jdGlvbiBwcm9taXNlKG9iaikge1xcbiAgICAgICAgICByZXR1cm4gb2JqICE9IG51bGwgPyBqUXVlcnkuZXh0ZW5kKG9iaiwgX3Byb21pc2UpIDogX3Byb21pc2U7XFxuICAgICAgICB9XFxuICAgICAgfSxcXG4gICAgICAgICAgZGVmZXJyZWQgPSB7fTsgLy8gS2VlcCBwaXBlIGZvciBiYWNrLWNvbXBhdFxcblxcbiAgICAgIF9wcm9taXNlLnBpcGUgPSBfcHJvbWlzZS50aGVuOyAvLyBBZGQgbGlzdC1zcGVjaWZpYyBtZXRob2RzXFxuXFxuICAgICAgalF1ZXJ5LmVhY2godHVwbGVzLCBmdW5jdGlvbiAoaSwgdHVwbGUpIHtcXG4gICAgICAgIHZhciBsaXN0ID0gdHVwbGVbMl0sXFxuICAgICAgICAgICAgc3RhdGVTdHJpbmcgPSB0dXBsZVszXTsgLy8gcHJvbWlzZVsgZG9uZSB8IGZhaWwgfCBwcm9ncmVzcyBdID0gbGlzdC5hZGRcXG5cXG4gICAgICAgIF9wcm9taXNlW3R1cGxlWzFdXSA9IGxpc3QuYWRkOyAvLyBIYW5kbGUgc3RhdGVcXG5cXG4gICAgICAgIGlmIChzdGF0ZVN0cmluZykge1xcbiAgICAgICAgICBsaXN0LmFkZChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgLy8gc3RhdGUgPSBbIHJlc29sdmVkIHwgcmVqZWN0ZWQgXVxcbiAgICAgICAgICAgIF9zdGF0ZSA9IHN0YXRlU3RyaW5nOyAvLyBbIHJlamVjdF9saXN0IHwgcmVzb2x2ZV9saXN0IF0uZGlzYWJsZTsgcHJvZ3Jlc3NfbGlzdC5sb2NrXFxuICAgICAgICAgIH0sIHR1cGxlc1tpIF4gMV1bMl0uZGlzYWJsZSwgdHVwbGVzWzJdWzJdLmxvY2spO1xcbiAgICAgICAgfSAvLyBkZWZlcnJlZFsgcmVzb2x2ZSB8IHJlamVjdCB8IG5vdGlmeSBdXFxuXFxuXFxuICAgICAgICBkZWZlcnJlZFt0dXBsZVswXV0gPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIGRlZmVycmVkW3R1cGxlWzBdICsgXFxcIldpdGhcXFwiXSh0aGlzID09PSBkZWZlcnJlZCA/IF9wcm9taXNlIDogdGhpcywgYXJndW1lbnRzKTtcXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XFxuICAgICAgICB9O1xcblxcbiAgICAgICAgZGVmZXJyZWRbdHVwbGVbMF0gKyBcXFwiV2l0aFxcXCJdID0gbGlzdC5maXJlV2l0aDtcXG4gICAgICB9KTsgLy8gTWFrZSB0aGUgZGVmZXJyZWQgYSBwcm9taXNlXFxuXFxuICAgICAgX3Byb21pc2UucHJvbWlzZShkZWZlcnJlZCk7IC8vIENhbGwgZ2l2ZW4gZnVuYyBpZiBhbnlcXG5cXG5cXG4gICAgICBpZiAoZnVuYykge1xcbiAgICAgICAgZnVuYy5jYWxsKGRlZmVycmVkLCBkZWZlcnJlZCk7XFxuICAgICAgfSAvLyBBbGwgZG9uZSFcXG5cXG5cXG4gICAgICByZXR1cm4gZGVmZXJyZWQ7XFxuICAgIH0sXFxuICAgIC8vIERlZmVycmVkIGhlbHBlclxcbiAgICB3aGVuOiBmdW5jdGlvbiB3aGVuKHN1Ym9yZGluYXRlXFxuICAgIC8qICwgLi4uLCBzdWJvcmRpbmF0ZU4gKi9cXG4gICAgKSB7XFxuICAgICAgdmFyIGkgPSAwLFxcbiAgICAgICAgICByZXNvbHZlVmFsdWVzID0gX3NsaWNlLmNhbGwoYXJndW1lbnRzKSxcXG4gICAgICAgICAgbGVuZ3RoID0gcmVzb2x2ZVZhbHVlcy5sZW5ndGgsXFxuICAgICAgICAgIC8vIHRoZSBjb3VudCBvZiB1bmNvbXBsZXRlZCBzdWJvcmRpbmF0ZXNcXG4gICAgICByZW1haW5pbmcgPSBsZW5ndGggIT09IDEgfHwgc3Vib3JkaW5hdGUgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oc3Vib3JkaW5hdGUucHJvbWlzZSkgPyBsZW5ndGggOiAwLFxcbiAgICAgICAgICAvLyB0aGUgbWFzdGVyIERlZmVycmVkLiBJZiByZXNvbHZlVmFsdWVzIGNvbnNpc3Qgb2Ygb25seSBhIHNpbmdsZSBEZWZlcnJlZCwganVzdCB1c2UgdGhhdC5cXG4gICAgICBkZWZlcnJlZCA9IHJlbWFpbmluZyA9PT0gMSA/IHN1Ym9yZGluYXRlIDogalF1ZXJ5LkRlZmVycmVkKCksXFxuICAgICAgICAgIC8vIFVwZGF0ZSBmdW5jdGlvbiBmb3IgYm90aCByZXNvbHZlIGFuZCBwcm9ncmVzcyB2YWx1ZXNcXG4gICAgICB1cGRhdGVGdW5jID0gZnVuY3Rpb24gdXBkYXRlRnVuYyhpLCBjb250ZXh0cywgdmFsdWVzKSB7XFxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XFxuICAgICAgICAgIGNvbnRleHRzW2ldID0gdGhpcztcXG4gICAgICAgICAgdmFsdWVzW2ldID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBfc2xpY2UuY2FsbChhcmd1bWVudHMpIDogdmFsdWU7XFxuXFxuICAgICAgICAgIGlmICh2YWx1ZXMgPT09IHByb2dyZXNzVmFsdWVzKSB7XFxuICAgICAgICAgICAgZGVmZXJyZWQubm90aWZ5V2l0aChjb250ZXh0cywgdmFsdWVzKTtcXG4gICAgICAgICAgfSBlbHNlIGlmICghIC0tcmVtYWluaW5nKSB7XFxuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZVdpdGgoY29udGV4dHMsIHZhbHVlcyk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH07XFxuICAgICAgfSxcXG4gICAgICAgICAgcHJvZ3Jlc3NWYWx1ZXMsXFxuICAgICAgICAgIHByb2dyZXNzQ29udGV4dHMsXFxuICAgICAgICAgIHJlc29sdmVDb250ZXh0czsgLy8gQWRkIGxpc3RlbmVycyB0byBEZWZlcnJlZCBzdWJvcmRpbmF0ZXM7IHRyZWF0IG90aGVycyBhcyByZXNvbHZlZFxcblxcblxcbiAgICAgIGlmIChsZW5ndGggPiAxKSB7XFxuICAgICAgICBwcm9ncmVzc1ZhbHVlcyA9IG5ldyBBcnJheShsZW5ndGgpO1xcbiAgICAgICAgcHJvZ3Jlc3NDb250ZXh0cyA9IG5ldyBBcnJheShsZW5ndGgpO1xcbiAgICAgICAgcmVzb2x2ZUNvbnRleHRzID0gbmV3IEFycmF5KGxlbmd0aCk7XFxuXFxuICAgICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgIGlmIChyZXNvbHZlVmFsdWVzW2ldICYmIGpRdWVyeS5pc0Z1bmN0aW9uKHJlc29sdmVWYWx1ZXNbaV0ucHJvbWlzZSkpIHtcXG4gICAgICAgICAgICByZXNvbHZlVmFsdWVzW2ldLnByb21pc2UoKS5kb25lKHVwZGF0ZUZ1bmMoaSwgcmVzb2x2ZUNvbnRleHRzLCByZXNvbHZlVmFsdWVzKSkuZmFpbChkZWZlcnJlZC5yZWplY3QpLnByb2dyZXNzKHVwZGF0ZUZ1bmMoaSwgcHJvZ3Jlc3NDb250ZXh0cywgcHJvZ3Jlc3NWYWx1ZXMpKTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAtLXJlbWFpbmluZztcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH0gLy8gSWYgd2UncmUgbm90IHdhaXRpbmcgb24gYW55dGhpbmcsIHJlc29sdmUgdGhlIG1hc3RlclxcblxcblxcbiAgICAgIGlmICghcmVtYWluaW5nKSB7XFxuICAgICAgICBkZWZlcnJlZC5yZXNvbHZlV2l0aChyZXNvbHZlQ29udGV4dHMsIHJlc29sdmVWYWx1ZXMpO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZSgpO1xcbiAgICB9XFxuICB9KTsgLy8gVGhlIGRlZmVycmVkIHVzZWQgb24gRE9NIHJlYWR5XFxuXFxuICB2YXIgcmVhZHlMaXN0O1xcblxcbiAgalF1ZXJ5LmZuLnJlYWR5ID0gZnVuY3Rpb24gKGZuKSB7XFxuICAgIC8vIEFkZCB0aGUgY2FsbGJhY2tcXG4gICAgalF1ZXJ5LnJlYWR5LnByb21pc2UoKS5kb25lKGZuKTtcXG4gICAgcmV0dXJuIHRoaXM7XFxuICB9O1xcblxcbiAgalF1ZXJ5LmV4dGVuZCh7XFxuICAgIC8vIElzIHRoZSBET00gcmVhZHkgdG8gYmUgdXNlZD8gU2V0IHRvIHRydWUgb25jZSBpdCBvY2N1cnMuXFxuICAgIGlzUmVhZHk6IGZhbHNlLFxcbiAgICAvLyBBIGNvdW50ZXIgdG8gdHJhY2sgaG93IG1hbnkgaXRlbXMgdG8gd2FpdCBmb3IgYmVmb3JlXFxuICAgIC8vIHRoZSByZWFkeSBldmVudCBmaXJlcy4gU2VlICM2NzgxXFxuICAgIHJlYWR5V2FpdDogMSxcXG4gICAgLy8gSG9sZCAob3IgcmVsZWFzZSkgdGhlIHJlYWR5IGV2ZW50XFxuICAgIGhvbGRSZWFkeTogZnVuY3Rpb24gaG9sZFJlYWR5KGhvbGQpIHtcXG4gICAgICBpZiAoaG9sZCkge1xcbiAgICAgICAgalF1ZXJ5LnJlYWR5V2FpdCsrO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBqUXVlcnkucmVhZHkodHJ1ZSk7XFxuICAgICAgfVxcbiAgICB9LFxcbiAgICAvLyBIYW5kbGUgd2hlbiB0aGUgRE9NIGlzIHJlYWR5XFxuICAgIHJlYWR5OiBmdW5jdGlvbiByZWFkeSh3YWl0KSB7XFxuICAgICAgLy8gQWJvcnQgaWYgdGhlcmUgYXJlIHBlbmRpbmcgaG9sZHMgb3Igd2UncmUgYWxyZWFkeSByZWFkeVxcbiAgICAgIGlmICh3YWl0ID09PSB0cnVlID8gLS1qUXVlcnkucmVhZHlXYWl0IDogalF1ZXJ5LmlzUmVhZHkpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9IC8vIFJlbWVtYmVyIHRoYXQgdGhlIERPTSBpcyByZWFkeVxcblxcblxcbiAgICAgIGpRdWVyeS5pc1JlYWR5ID0gdHJ1ZTsgLy8gSWYgYSBub3JtYWwgRE9NIFJlYWR5IGV2ZW50IGZpcmVkLCBkZWNyZW1lbnQsIGFuZCB3YWl0IGlmIG5lZWQgYmVcXG5cXG4gICAgICBpZiAod2FpdCAhPT0gdHJ1ZSAmJiAtLWpRdWVyeS5yZWFkeVdhaXQgPiAwKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfSAvLyBJZiB0aGVyZSBhcmUgZnVuY3Rpb25zIGJvdW5kLCB0byBleGVjdXRlXFxuXFxuXFxuICAgICAgcmVhZHlMaXN0LnJlc29sdmVXaXRoKGRvY3VtZW50LCBbalF1ZXJ5XSk7IC8vIFRyaWdnZXIgYW55IGJvdW5kIHJlYWR5IGV2ZW50c1xcblxcbiAgICAgIGlmIChqUXVlcnkuZm4udHJpZ2dlckhhbmRsZXIpIHtcXG4gICAgICAgIGpRdWVyeShkb2N1bWVudCkudHJpZ2dlckhhbmRsZXIoXFxcInJlYWR5XFxcIik7XFxuICAgICAgICBqUXVlcnkoZG9jdW1lbnQpLm9mZihcXFwicmVhZHlcXFwiKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH0pO1xcbiAgLyoqXFxuICAgKiBUaGUgcmVhZHkgZXZlbnQgaGFuZGxlciBhbmQgc2VsZiBjbGVhbnVwIG1ldGhvZFxcbiAgICovXFxuXFxuICBmdW5jdGlvbiBjb21wbGV0ZWQoKSB7XFxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXFxcIkRPTUNvbnRlbnRMb2FkZWRcXFwiLCBjb21wbGV0ZWQsIGZhbHNlKTtcXG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXFxcImxvYWRcXFwiLCBjb21wbGV0ZWQsIGZhbHNlKTtcXG4gICAgalF1ZXJ5LnJlYWR5KCk7XFxuICB9XFxuXFxuICBqUXVlcnkucmVhZHkucHJvbWlzZSA9IGZ1bmN0aW9uIChvYmopIHtcXG4gICAgaWYgKCFyZWFkeUxpc3QpIHtcXG4gICAgICByZWFkeUxpc3QgPSBqUXVlcnkuRGVmZXJyZWQoKTsgLy8gQ2F0Y2ggY2FzZXMgd2hlcmUgJChkb2N1bWVudCkucmVhZHkoKSBpcyBjYWxsZWQgYWZ0ZXIgdGhlIGJyb3dzZXIgZXZlbnQgaGFzIGFscmVhZHkgb2NjdXJyZWQuXFxuICAgICAgLy8gV2Ugb25jZSB0cmllZCB0byB1c2UgcmVhZHlTdGF0ZSBcXFwiaW50ZXJhY3RpdmVcXFwiIGhlcmUsIGJ1dCBpdCBjYXVzZWQgaXNzdWVzIGxpa2UgdGhlIG9uZVxcbiAgICAgIC8vIGRpc2NvdmVyZWQgYnkgQ2hyaXNTIGhlcmU6IGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEyMjgyI2NvbW1lbnQ6MTVcXG5cXG4gICAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXFxcImNvbXBsZXRlXFxcIikge1xcbiAgICAgICAgLy8gSGFuZGxlIGl0IGFzeW5jaHJvbm91c2x5IHRvIGFsbG93IHNjcmlwdHMgdGhlIG9wcG9ydHVuaXR5IHRvIGRlbGF5IHJlYWR5XFxuICAgICAgICBzZXRUaW1lb3V0KGpRdWVyeS5yZWFkeSk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIC8vIFVzZSB0aGUgaGFuZHkgZXZlbnQgY2FsbGJhY2tcXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXFxcIkRPTUNvbnRlbnRMb2FkZWRcXFwiLCBjb21wbGV0ZWQsIGZhbHNlKTsgLy8gQSBmYWxsYmFjayB0byB3aW5kb3cub25sb2FkLCB0aGF0IHdpbGwgYWx3YXlzIHdvcmtcXG5cXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFxcXCJsb2FkXFxcIiwgY29tcGxldGVkLCBmYWxzZSk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHJldHVybiByZWFkeUxpc3QucHJvbWlzZShvYmopO1xcbiAgfTsgLy8gS2ljayBvZmYgdGhlIERPTSByZWFkeSBjaGVjayBldmVuIGlmIHRoZSB1c2VyIGRvZXMgbm90XFxuXFxuXFxuICBqUXVlcnkucmVhZHkucHJvbWlzZSgpOyAvLyBNdWx0aWZ1bmN0aW9uYWwgbWV0aG9kIHRvIGdldCBhbmQgc2V0IHZhbHVlcyBvZiBhIGNvbGxlY3Rpb25cXG4gIC8vIFRoZSB2YWx1ZS9zIGNhbiBvcHRpb25hbGx5IGJlIGV4ZWN1dGVkIGlmIGl0J3MgYSBmdW5jdGlvblxcblxcbiAgdmFyIGFjY2VzcyA9IGpRdWVyeS5hY2Nlc3MgPSBmdW5jdGlvbiAoZWxlbXMsIGZuLCBrZXksIHZhbHVlLCBjaGFpbmFibGUsIGVtcHR5R2V0LCByYXcpIHtcXG4gICAgdmFyIGkgPSAwLFxcbiAgICAgICAgbGVuID0gZWxlbXMubGVuZ3RoLFxcbiAgICAgICAgYnVsayA9IGtleSA9PSBudWxsOyAvLyBTZXRzIG1hbnkgdmFsdWVzXFxuXFxuICAgIGlmIChqUXVlcnkudHlwZShrZXkpID09PSBcXFwib2JqZWN0XFxcIikge1xcbiAgICAgIGNoYWluYWJsZSA9IHRydWU7XFxuXFxuICAgICAgZm9yIChpIGluIGtleSkge1xcbiAgICAgICAgalF1ZXJ5LmFjY2VzcyhlbGVtcywgZm4sIGksIGtleVtpXSwgdHJ1ZSwgZW1wdHlHZXQsIHJhdyk7XFxuICAgICAgfSAvLyBTZXRzIG9uZSB2YWx1ZVxcblxcbiAgICB9IGVsc2UgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcXG4gICAgICBjaGFpbmFibGUgPSB0cnVlO1xcblxcbiAgICAgIGlmICghalF1ZXJ5LmlzRnVuY3Rpb24odmFsdWUpKSB7XFxuICAgICAgICByYXcgPSB0cnVlO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoYnVsaykge1xcbiAgICAgICAgLy8gQnVsayBvcGVyYXRpb25zIHJ1biBhZ2FpbnN0IHRoZSBlbnRpcmUgc2V0XFxuICAgICAgICBpZiAocmF3KSB7XFxuICAgICAgICAgIGZuLmNhbGwoZWxlbXMsIHZhbHVlKTtcXG4gICAgICAgICAgZm4gPSBudWxsOyAvLyAuLi5leGNlcHQgd2hlbiBleGVjdXRpbmcgZnVuY3Rpb24gdmFsdWVzXFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBidWxrID0gZm47XFxuXFxuICAgICAgICAgIGZuID0gZnVuY3Rpb24gZm4oZWxlbSwga2V5LCB2YWx1ZSkge1xcbiAgICAgICAgICAgIHJldHVybiBidWxrLmNhbGwoalF1ZXJ5KGVsZW0pLCB2YWx1ZSk7XFxuICAgICAgICAgIH07XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChmbikge1xcbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xcbiAgICAgICAgICBmbihlbGVtc1tpXSwga2V5LCByYXcgPyB2YWx1ZSA6IHZhbHVlLmNhbGwoZWxlbXNbaV0sIGksIGZuKGVsZW1zW2ldLCBrZXkpKSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHJldHVybiBjaGFpbmFibGUgPyBlbGVtcyA6IC8vIEdldHNcXG4gICAgYnVsayA/IGZuLmNhbGwoZWxlbXMpIDogbGVuID8gZm4oZWxlbXNbMF0sIGtleSkgOiBlbXB0eUdldDtcXG4gIH07XFxuICAvKipcXG4gICAqIERldGVybWluZXMgd2hldGhlciBhbiBvYmplY3QgY2FuIGhhdmUgZGF0YVxcbiAgICovXFxuXFxuXFxuICBqUXVlcnkuYWNjZXB0RGF0YSA9IGZ1bmN0aW9uIChvd25lcikge1xcbiAgICAvLyBBY2NlcHRzIG9ubHk6XFxuICAgIC8vICAtIE5vZGVcXG4gICAgLy8gICAgLSBOb2RlLkVMRU1FTlRfTk9ERVxcbiAgICAvLyAgICAtIE5vZGUuRE9DVU1FTlRfTk9ERVxcbiAgICAvLyAgLSBPYmplY3RcXG4gICAgLy8gICAgLSBBbnlcXG5cXG4gICAgLyoganNoaW50IC1XMDE4ICovXFxuICAgIHJldHVybiBvd25lci5ub2RlVHlwZSA9PT0gMSB8fCBvd25lci5ub2RlVHlwZSA9PT0gOSB8fCAhK293bmVyLm5vZGVUeXBlO1xcbiAgfTtcXG5cXG4gIGZ1bmN0aW9uIERhdGEoKSB7XFxuICAgIC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NCxcXG4gICAgLy8gT2xkIFdlYktpdCBkb2VzIG5vdCBoYXZlIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucy9mcmVlemUgbWV0aG9kLFxcbiAgICAvLyByZXR1cm4gbmV3IGVtcHR5IG9iamVjdCBpbnN0ZWFkIHdpdGggbm8gW1tzZXRdXSBhY2Nlc3NvclxcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5jYWNoZSA9IHt9LCAwLCB7XFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XFxuICAgICAgICByZXR1cm4ge307XFxuICAgICAgfVxcbiAgICB9KTtcXG4gICAgdGhpcy5leHBhbmRvID0galF1ZXJ5LmV4cGFuZG8gKyBEYXRhLnVpZCsrO1xcbiAgfVxcblxcbiAgRGF0YS51aWQgPSAxO1xcbiAgRGF0YS5hY2NlcHRzID0galF1ZXJ5LmFjY2VwdERhdGE7XFxuICBEYXRhLnByb3RvdHlwZSA9IHtcXG4gICAga2V5OiBmdW5jdGlvbiBrZXkob3duZXIpIHtcXG4gICAgICAvLyBXZSBjYW4gYWNjZXB0IGRhdGEgZm9yIG5vbi1lbGVtZW50IG5vZGVzIGluIG1vZGVybiBicm93c2VycyxcXG4gICAgICAvLyBidXQgd2Ugc2hvdWxkIG5vdCwgc2VlICM4MzM1LlxcbiAgICAgIC8vIEFsd2F5cyByZXR1cm4gdGhlIGtleSBmb3IgYSBmcm96ZW4gb2JqZWN0LlxcbiAgICAgIGlmICghRGF0YS5hY2NlcHRzKG93bmVyKSkge1xcbiAgICAgICAgcmV0dXJuIDA7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBkZXNjcmlwdG9yID0ge30sXFxuICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBvd25lciBvYmplY3QgYWxyZWFkeSBoYXMgYSBjYWNoZSBrZXlcXG4gICAgICB1bmxvY2sgPSBvd25lclt0aGlzLmV4cGFuZG9dOyAvLyBJZiBub3QsIGNyZWF0ZSBvbmVcXG5cXG4gICAgICBpZiAoIXVubG9jaykge1xcbiAgICAgICAgdW5sb2NrID0gRGF0YS51aWQrKzsgLy8gU2VjdXJlIGl0IGluIGEgbm9uLWVudW1lcmFibGUsIG5vbi13cml0YWJsZSBwcm9wZXJ0eVxcblxcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgZGVzY3JpcHRvclt0aGlzLmV4cGFuZG9dID0ge1xcbiAgICAgICAgICAgIHZhbHVlOiB1bmxvY2tcXG4gICAgICAgICAgfTtcXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMob3duZXIsIGRlc2NyaXB0b3IpOyAvLyBTdXBwb3J0OiBBbmRyb2lkPDRcXG4gICAgICAgICAgLy8gRmFsbGJhY2sgdG8gYSBsZXNzIHNlY3VyZSBkZWZpbml0aW9uXFxuICAgICAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICAgIGRlc2NyaXB0b3JbdGhpcy5leHBhbmRvXSA9IHVubG9jaztcXG4gICAgICAgICAgalF1ZXJ5LmV4dGVuZChvd25lciwgZGVzY3JpcHRvcik7XFxuICAgICAgICB9XFxuICAgICAgfSAvLyBFbnN1cmUgdGhlIGNhY2hlIG9iamVjdFxcblxcblxcbiAgICAgIGlmICghdGhpcy5jYWNoZVt1bmxvY2tdKSB7XFxuICAgICAgICB0aGlzLmNhY2hlW3VubG9ja10gPSB7fTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHVubG9jaztcXG4gICAgfSxcXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQob3duZXIsIGRhdGEsIHZhbHVlKSB7XFxuICAgICAgdmFyIHByb3AsXFxuICAgICAgICAgIC8vIFRoZXJlIG1heSBiZSBhbiB1bmxvY2sgYXNzaWduZWQgdG8gdGhpcyBub2RlLFxcbiAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIGVudHJ5IGZvciB0aGlzIFxcXCJvd25lclxcXCIsIGNyZWF0ZSBvbmUgaW5saW5lXFxuICAgICAgLy8gYW5kIHNldCB0aGUgdW5sb2NrIGFzIHRob3VnaCBhbiBvd25lciBlbnRyeSBoYWQgYWx3YXlzIGV4aXN0ZWRcXG4gICAgICB1bmxvY2sgPSB0aGlzLmtleShvd25lciksXFxuICAgICAgICAgIGNhY2hlID0gdGhpcy5jYWNoZVt1bmxvY2tdOyAvLyBIYW5kbGU6IFsgb3duZXIsIGtleSwgdmFsdWUgXSBhcmdzXFxuXFxuICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSBcXFwic3RyaW5nXFxcIikge1xcbiAgICAgICAgY2FjaGVbZGF0YV0gPSB2YWx1ZTsgLy8gSGFuZGxlOiBbIG93bmVyLCB7IHByb3BlcnRpZXMgfSBdIGFyZ3NcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgLy8gRnJlc2ggYXNzaWdubWVudHMgYnkgb2JqZWN0IGFyZSBzaGFsbG93IGNvcGllZFxcbiAgICAgICAgaWYgKGpRdWVyeS5pc0VtcHR5T2JqZWN0KGNhY2hlKSkge1xcbiAgICAgICAgICBqUXVlcnkuZXh0ZW5kKHRoaXMuY2FjaGVbdW5sb2NrXSwgZGF0YSk7IC8vIE90aGVyd2lzZSwgY29weSB0aGUgcHJvcGVydGllcyBvbmUtYnktb25lIHRvIHRoZSBjYWNoZSBvYmplY3RcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGZvciAocHJvcCBpbiBkYXRhKSB7XFxuICAgICAgICAgICAgY2FjaGVbcHJvcF0gPSBkYXRhW3Byb3BdO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBjYWNoZTtcXG4gICAgfSxcXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQob3duZXIsIGtleSkge1xcbiAgICAgIC8vIEVpdGhlciBhIHZhbGlkIGNhY2hlIGlzIGZvdW5kLCBvciB3aWxsIGJlIGNyZWF0ZWQuXFxuICAgICAgLy8gTmV3IGNhY2hlcyB3aWxsIGJlIGNyZWF0ZWQgYW5kIHRoZSB1bmxvY2sgcmV0dXJuZWQsXFxuICAgICAgLy8gYWxsb3dpbmcgZGlyZWN0IGFjY2VzcyB0byB0aGUgbmV3bHkgY3JlYXRlZFxcbiAgICAgIC8vIGVtcHR5IGRhdGEgb2JqZWN0LiBBIHZhbGlkIG93bmVyIG9iamVjdCBtdXN0IGJlIHByb3ZpZGVkLlxcbiAgICAgIHZhciBjYWNoZSA9IHRoaXMuY2FjaGVbdGhpcy5rZXkob3duZXIpXTtcXG4gICAgICByZXR1cm4ga2V5ID09PSB1bmRlZmluZWQgPyBjYWNoZSA6IGNhY2hlW2tleV07XFxuICAgIH0sXFxuICAgIGFjY2VzczogZnVuY3Rpb24gYWNjZXNzKG93bmVyLCBrZXksIHZhbHVlKSB7XFxuICAgICAgdmFyIHN0b3JlZDsgLy8gSW4gY2FzZXMgd2hlcmUgZWl0aGVyOlxcbiAgICAgIC8vXFxuICAgICAgLy8gICAxLiBObyBrZXkgd2FzIHNwZWNpZmllZFxcbiAgICAgIC8vICAgMi4gQSBzdHJpbmcga2V5IHdhcyBzcGVjaWZpZWQsIGJ1dCBubyB2YWx1ZSBwcm92aWRlZFxcbiAgICAgIC8vXFxuICAgICAgLy8gVGFrZSB0aGUgXFxcInJlYWRcXFwiIHBhdGggYW5kIGFsbG93IHRoZSBnZXQgbWV0aG9kIHRvIGRldGVybWluZVxcbiAgICAgIC8vIHdoaWNoIHZhbHVlIHRvIHJldHVybiwgcmVzcGVjdGl2ZWx5IGVpdGhlcjpcXG4gICAgICAvL1xcbiAgICAgIC8vICAgMS4gVGhlIGVudGlyZSBjYWNoZSBvYmplY3RcXG4gICAgICAvLyAgIDIuIFRoZSBkYXRhIHN0b3JlZCBhdCB0aGUga2V5XFxuICAgICAgLy9cXG5cXG4gICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQgfHwga2V5ICYmIHR5cGVvZiBrZXkgPT09IFxcXCJzdHJpbmdcXFwiICYmIHZhbHVlID09PSB1bmRlZmluZWQpIHtcXG4gICAgICAgIHN0b3JlZCA9IHRoaXMuZ2V0KG93bmVyLCBrZXkpO1xcbiAgICAgICAgcmV0dXJuIHN0b3JlZCAhPT0gdW5kZWZpbmVkID8gc3RvcmVkIDogdGhpcy5nZXQob3duZXIsIGpRdWVyeS5jYW1lbENhc2Uoa2V5KSk7XFxuICAgICAgfSAvLyBbKl1XaGVuIHRoZSBrZXkgaXMgbm90IGEgc3RyaW5nLCBvciBib3RoIGEga2V5IGFuZCB2YWx1ZVxcbiAgICAgIC8vIGFyZSBzcGVjaWZpZWQsIHNldCBvciBleHRlbmQgKGV4aXN0aW5nIG9iamVjdHMpIHdpdGggZWl0aGVyOlxcbiAgICAgIC8vXFxuICAgICAgLy8gICAxLiBBbiBvYmplY3Qgb2YgcHJvcGVydGllc1xcbiAgICAgIC8vICAgMi4gQSBrZXkgYW5kIHZhbHVlXFxuICAgICAgLy9cXG5cXG5cXG4gICAgICB0aGlzLnNldChvd25lciwga2V5LCB2YWx1ZSk7IC8vIFNpbmNlIHRoZSBcXFwic2V0XFxcIiBwYXRoIGNhbiBoYXZlIHR3byBwb3NzaWJsZSBlbnRyeSBwb2ludHNcXG4gICAgICAvLyByZXR1cm4gdGhlIGV4cGVjdGVkIGRhdGEgYmFzZWQgb24gd2hpY2ggcGF0aCB3YXMgdGFrZW5bKl1cXG5cXG4gICAgICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoga2V5O1xcbiAgICB9LFxcbiAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShvd25lciwga2V5KSB7XFxuICAgICAgdmFyIGksXFxuICAgICAgICAgIG5hbWUsXFxuICAgICAgICAgIGNhbWVsLFxcbiAgICAgICAgICB1bmxvY2sgPSB0aGlzLmtleShvd25lciksXFxuICAgICAgICAgIGNhY2hlID0gdGhpcy5jYWNoZVt1bmxvY2tdO1xcblxcbiAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgdGhpcy5jYWNoZVt1bmxvY2tdID0ge307XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIC8vIFN1cHBvcnQgYXJyYXkgb3Igc3BhY2Ugc2VwYXJhdGVkIHN0cmluZyBvZiBrZXlzXFxuICAgICAgICBpZiAoalF1ZXJ5LmlzQXJyYXkoa2V5KSkge1xcbiAgICAgICAgICAvLyBJZiBcXFwibmFtZVxcXCIgaXMgYW4gYXJyYXkgb2Yga2V5cy4uLlxcbiAgICAgICAgICAvLyBXaGVuIGRhdGEgaXMgaW5pdGlhbGx5IGNyZWF0ZWQsIHZpYSAoXFxcImtleVxcXCIsIFxcXCJ2YWxcXFwiKSBzaWduYXR1cmUsXFxuICAgICAgICAgIC8vIGtleXMgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gY2FtZWxDYXNlLlxcbiAgICAgICAgICAvLyBTaW5jZSB0aGVyZSBpcyBubyB3YXkgdG8gdGVsbCBfaG93XyBhIGtleSB3YXMgYWRkZWQsIHJlbW92ZVxcbiAgICAgICAgICAvLyBib3RoIHBsYWluIGtleSBhbmQgY2FtZWxDYXNlIGtleS4gIzEyNzg2XFxuICAgICAgICAgIC8vIFRoaXMgd2lsbCBvbmx5IHBlbmFsaXplIHRoZSBhcnJheSBhcmd1bWVudCBwYXRoLlxcbiAgICAgICAgICBuYW1lID0ga2V5LmNvbmNhdChrZXkubWFwKGpRdWVyeS5jYW1lbENhc2UpKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGNhbWVsID0galF1ZXJ5LmNhbWVsQ2FzZShrZXkpOyAvLyBUcnkgdGhlIHN0cmluZyBhcyBhIGtleSBiZWZvcmUgYW55IG1hbmlwdWxhdGlvblxcblxcbiAgICAgICAgICBpZiAoa2V5IGluIGNhY2hlKSB7XFxuICAgICAgICAgICAgbmFtZSA9IFtrZXksIGNhbWVsXTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAvLyBJZiBhIGtleSB3aXRoIHRoZSBzcGFjZXMgZXhpc3RzLCB1c2UgaXQuXFxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBjcmVhdGUgYW4gYXJyYXkgYnkgbWF0Y2hpbmcgbm9uLXdoaXRlc3BhY2VcXG4gICAgICAgICAgICBuYW1lID0gY2FtZWw7XFxuICAgICAgICAgICAgbmFtZSA9IG5hbWUgaW4gY2FjaGUgPyBbbmFtZV0gOiBuYW1lLm1hdGNoKHJub3R3aGl0ZSkgfHwgW107XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGkgPSBuYW1lLmxlbmd0aDtcXG5cXG4gICAgICAgIHdoaWxlIChpLS0pIHtcXG4gICAgICAgICAgZGVsZXRlIGNhY2hlW25hbWVbaV1dO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgaGFzRGF0YTogZnVuY3Rpb24gaGFzRGF0YShvd25lcikge1xcbiAgICAgIHJldHVybiAhalF1ZXJ5LmlzRW1wdHlPYmplY3QodGhpcy5jYWNoZVtvd25lclt0aGlzLmV4cGFuZG9dXSB8fCB7fSk7XFxuICAgIH0sXFxuICAgIGRpc2NhcmQ6IGZ1bmN0aW9uIGRpc2NhcmQob3duZXIpIHtcXG4gICAgICBpZiAob3duZXJbdGhpcy5leHBhbmRvXSkge1xcbiAgICAgICAgZGVsZXRlIHRoaXMuY2FjaGVbb3duZXJbdGhpcy5leHBhbmRvXV07XFxuICAgICAgfVxcbiAgICB9XFxuICB9O1xcbiAgdmFyIGRhdGFfcHJpdiA9IG5ldyBEYXRhKCk7XFxuICB2YXIgZGF0YV91c2VyID0gbmV3IERhdGEoKTsgLy9cXHRJbXBsZW1lbnRhdGlvbiBTdW1tYXJ5XFxuICAvL1xcbiAgLy9cXHQxLiBFbmZvcmNlIEFQSSBzdXJmYWNlIGFuZCBzZW1hbnRpYyBjb21wYXRpYmlsaXR5IHdpdGggMS45LnggYnJhbmNoXFxuICAvL1xcdDIuIEltcHJvdmUgdGhlIG1vZHVsZSdzIG1haW50YWluYWJpbGl0eSBieSByZWR1Y2luZyB0aGUgc3RvcmFnZVxcbiAgLy9cXHRcXHRwYXRocyB0byBhIHNpbmdsZSBtZWNoYW5pc20uXFxuICAvL1xcdDMuIFVzZSB0aGUgc2FtZSBzaW5nbGUgbWVjaGFuaXNtIHRvIHN1cHBvcnQgXFxcInByaXZhdGVcXFwiIGFuZCBcXFwidXNlclxcXCIgZGF0YS5cXG4gIC8vXFx0NC4gX05ldmVyXyBleHBvc2UgXFxcInByaXZhdGVcXFwiIGRhdGEgdG8gdXNlciBjb2RlIChUT0RPOiBEcm9wIF9kYXRhLCBfcmVtb3ZlRGF0YSlcXG4gIC8vXFx0NS4gQXZvaWQgZXhwb3NpbmcgaW1wbGVtZW50YXRpb24gZGV0YWlscyBvbiB1c2VyIG9iamVjdHMgKGVnLiBleHBhbmRvIHByb3BlcnRpZXMpXFxuICAvL1xcdDYuIFByb3ZpZGUgYSBjbGVhciBwYXRoIGZvciBpbXBsZW1lbnRhdGlvbiB1cGdyYWRlIHRvIFdlYWtNYXAgaW4gMjAxNFxcblxcbiAgdmFyIHJicmFjZSA9IC9eKD86XFxcXHtbXFxcXHdcXFxcV10qXFxcXH18XFxcXFtbXFxcXHdcXFxcV10qXFxcXF0pJC8sXFxuICAgICAgcm11bHRpRGFzaCA9IC8oW0EtWl0pL2c7XFxuXFxuICBmdW5jdGlvbiBkYXRhQXR0cihlbGVtLCBrZXksIGRhdGEpIHtcXG4gICAgdmFyIG5hbWU7IC8vIElmIG5vdGhpbmcgd2FzIGZvdW5kIGludGVybmFsbHksIHRyeSB0byBmZXRjaCBhbnlcXG4gICAgLy8gZGF0YSBmcm9tIHRoZSBIVE1MNSBkYXRhLSogYXR0cmlidXRlXFxuXFxuICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSkge1xcbiAgICAgIG5hbWUgPSBcXFwiZGF0YS1cXFwiICsga2V5LnJlcGxhY2Uocm11bHRpRGFzaCwgXFxcIi0kMVxcXCIpLnRvTG93ZXJDYXNlKCk7XFxuICAgICAgZGF0YSA9IGVsZW0uZ2V0QXR0cmlidXRlKG5hbWUpO1xcblxcbiAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXFxcInN0cmluZ1xcXCIpIHtcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgIGRhdGEgPSBkYXRhID09PSBcXFwidHJ1ZVxcXCIgPyB0cnVlIDogZGF0YSA9PT0gXFxcImZhbHNlXFxcIiA/IGZhbHNlIDogZGF0YSA9PT0gXFxcIm51bGxcXFwiID8gbnVsbCA6IC8vIE9ubHkgY29udmVydCB0byBhIG51bWJlciBpZiBpdCBkb2Vzbid0IGNoYW5nZSB0aGUgc3RyaW5nXFxuICAgICAgICAgICtkYXRhICsgXFxcIlxcXCIgPT09IGRhdGEgPyArZGF0YSA6IHJicmFjZS50ZXN0KGRhdGEpID8galF1ZXJ5LnBhcnNlSlNPTihkYXRhKSA6IGRhdGE7XFxuICAgICAgICB9IGNhdGNoIChlKSB7fSAvLyBNYWtlIHN1cmUgd2Ugc2V0IHRoZSBkYXRhIHNvIGl0IGlzbid0IGNoYW5nZWQgbGF0ZXJcXG5cXG5cXG4gICAgICAgIGRhdGFfdXNlci5zZXQoZWxlbSwga2V5LCBkYXRhKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgZGF0YSA9IHVuZGVmaW5lZDtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIGRhdGE7XFxuICB9XFxuXFxuICBqUXVlcnkuZXh0ZW5kKHtcXG4gICAgaGFzRGF0YTogZnVuY3Rpb24gaGFzRGF0YShlbGVtKSB7XFxuICAgICAgcmV0dXJuIGRhdGFfdXNlci5oYXNEYXRhKGVsZW0pIHx8IGRhdGFfcHJpdi5oYXNEYXRhKGVsZW0pO1xcbiAgICB9LFxcbiAgICBkYXRhOiBmdW5jdGlvbiBkYXRhKGVsZW0sIG5hbWUsIF9kYXRhKSB7XFxuICAgICAgcmV0dXJuIGRhdGFfdXNlci5hY2Nlc3MoZWxlbSwgbmFtZSwgX2RhdGEpO1xcbiAgICB9LFxcbiAgICByZW1vdmVEYXRhOiBmdW5jdGlvbiByZW1vdmVEYXRhKGVsZW0sIG5hbWUpIHtcXG4gICAgICBkYXRhX3VzZXIucmVtb3ZlKGVsZW0sIG5hbWUpO1xcbiAgICB9LFxcbiAgICAvLyBUT0RPOiBOb3cgdGhhdCBhbGwgY2FsbHMgdG8gX2RhdGEgYW5kIF9yZW1vdmVEYXRhIGhhdmUgYmVlbiByZXBsYWNlZFxcbiAgICAvLyB3aXRoIGRpcmVjdCBjYWxscyB0byBkYXRhX3ByaXYgbWV0aG9kcywgdGhlc2UgY2FuIGJlIGRlcHJlY2F0ZWQuXFxuICAgIF9kYXRhOiBmdW5jdGlvbiBfZGF0YShlbGVtLCBuYW1lLCBkYXRhKSB7XFxuICAgICAgcmV0dXJuIGRhdGFfcHJpdi5hY2Nlc3MoZWxlbSwgbmFtZSwgZGF0YSk7XFxuICAgIH0sXFxuICAgIF9yZW1vdmVEYXRhOiBmdW5jdGlvbiBfcmVtb3ZlRGF0YShlbGVtLCBuYW1lKSB7XFxuICAgICAgZGF0YV9wcml2LnJlbW92ZShlbGVtLCBuYW1lKTtcXG4gICAgfVxcbiAgfSk7XFxuICBqUXVlcnkuZm4uZXh0ZW5kKHtcXG4gICAgZGF0YTogZnVuY3Rpb24gZGF0YShrZXksIHZhbHVlKSB7XFxuICAgICAgdmFyIGksXFxuICAgICAgICAgIG5hbWUsXFxuICAgICAgICAgIGRhdGEsXFxuICAgICAgICAgIGVsZW0gPSB0aGlzWzBdLFxcbiAgICAgICAgICBhdHRycyA9IGVsZW0gJiYgZWxlbS5hdHRyaWJ1dGVzOyAvLyBHZXRzIGFsbCB2YWx1ZXNcXG5cXG4gICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcXG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCkge1xcbiAgICAgICAgICBkYXRhID0gZGF0YV91c2VyLmdldChlbGVtKTtcXG5cXG4gICAgICAgICAgaWYgKGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgIWRhdGFfcHJpdi5nZXQoZWxlbSwgXFxcImhhc0RhdGFBdHRyc1xcXCIpKSB7XFxuICAgICAgICAgICAgaSA9IGF0dHJzLmxlbmd0aDtcXG5cXG4gICAgICAgICAgICB3aGlsZSAoaS0tKSB7XFxuICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRTExK1xcbiAgICAgICAgICAgICAgLy8gVGhlIGF0dHJzIGVsZW1lbnRzIGNhbiBiZSBudWxsICgjMTQ4OTQpXFxuICAgICAgICAgICAgICBpZiAoYXR0cnNbaV0pIHtcXG4gICAgICAgICAgICAgICAgbmFtZSA9IGF0dHJzW2ldLm5hbWU7XFxuXFxuICAgICAgICAgICAgICAgIGlmIChuYW1lLmluZGV4T2YoXFxcImRhdGEtXFxcIikgPT09IDApIHtcXG4gICAgICAgICAgICAgICAgICBuYW1lID0galF1ZXJ5LmNhbWVsQ2FzZShuYW1lLnNsaWNlKDUpKTtcXG4gICAgICAgICAgICAgICAgICBkYXRhQXR0cihlbGVtLCBuYW1lLCBkYXRhW25hbWVdKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBkYXRhX3ByaXYuc2V0KGVsZW0sIFxcXCJoYXNEYXRhQXR0cnNcXFwiLCB0cnVlKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIGRhdGE7XFxuICAgICAgfSAvLyBTZXRzIG11bHRpcGxlIHZhbHVlc1xcblxcblxcbiAgICAgIGlmIChfdHlwZW9mKGtleSkgPT09IFxcXCJvYmplY3RcXFwiKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgZGF0YV91c2VyLnNldCh0aGlzLCBrZXkpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBhY2Nlc3ModGhpcywgZnVuY3Rpb24gKHZhbHVlKSB7XFxuICAgICAgICB2YXIgZGF0YSxcXG4gICAgICAgICAgICBjYW1lbEtleSA9IGpRdWVyeS5jYW1lbENhc2Uoa2V5KTsgLy8gVGhlIGNhbGxpbmcgalF1ZXJ5IG9iamVjdCAoZWxlbWVudCBtYXRjaGVzKSBpcyBub3QgZW1wdHlcXG4gICAgICAgIC8vIChhbmQgdGhlcmVmb3JlIGhhcyBhbiBlbGVtZW50IGFwcGVhcnMgYXQgdGhpc1sgMCBdKSBhbmQgdGhlXFxuICAgICAgICAvLyBgdmFsdWVgIHBhcmFtZXRlciB3YXMgbm90IHVuZGVmaW5lZC4gQW4gZW1wdHkgalF1ZXJ5IG9iamVjdFxcbiAgICAgICAgLy8gd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgZm9yIGVsZW0gPSB0aGlzWyAwIF0gd2hpY2ggd2lsbFxcbiAgICAgICAgLy8gdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFuIGF0dGVtcHQgdG8gcmVhZCBhIGRhdGEgY2FjaGUgaXMgbWFkZS5cXG5cXG4gICAgICAgIGlmIChlbGVtICYmIHZhbHVlID09PSB1bmRlZmluZWQpIHtcXG4gICAgICAgICAgLy8gQXR0ZW1wdCB0byBnZXQgZGF0YSBmcm9tIHRoZSBjYWNoZVxcbiAgICAgICAgICAvLyB3aXRoIHRoZSBrZXkgYXMtaXNcXG4gICAgICAgICAgZGF0YSA9IGRhdGFfdXNlci5nZXQoZWxlbSwga2V5KTtcXG5cXG4gICAgICAgICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xcbiAgICAgICAgICB9IC8vIEF0dGVtcHQgdG8gZ2V0IGRhdGEgZnJvbSB0aGUgY2FjaGVcXG4gICAgICAgICAgLy8gd2l0aCB0aGUga2V5IGNhbWVsaXplZFxcblxcblxcbiAgICAgICAgICBkYXRhID0gZGF0YV91c2VyLmdldChlbGVtLCBjYW1lbEtleSk7XFxuXFxuICAgICAgICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcXG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcXG4gICAgICAgICAgfSAvLyBBdHRlbXB0IHRvIFxcXCJkaXNjb3ZlclxcXCIgdGhlIGRhdGEgaW5cXG4gICAgICAgICAgLy8gSFRNTDUgY3VzdG9tIGRhdGEtKiBhdHRyc1xcblxcblxcbiAgICAgICAgICBkYXRhID0gZGF0YUF0dHIoZWxlbSwgY2FtZWxLZXksIHVuZGVmaW5lZCk7XFxuXFxuICAgICAgICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcXG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcXG4gICAgICAgICAgfSAvLyBXZSB0cmllZCByZWFsbHkgaGFyZCwgYnV0IHRoZSBkYXRhIGRvZXNuJ3QgZXhpc3QuXFxuXFxuXFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH0gLy8gU2V0IHRoZSBkYXRhLi4uXFxuXFxuXFxuICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAvLyBGaXJzdCwgYXR0ZW1wdCB0byBzdG9yZSBhIGNvcHkgb3IgcmVmZXJlbmNlIG9mIGFueVxcbiAgICAgICAgICAvLyBkYXRhIHRoYXQgbWlnaHQndmUgYmVlbiBzdG9yZSB3aXRoIGEgY2FtZWxDYXNlZCBrZXkuXFxuICAgICAgICAgIHZhciBkYXRhID0gZGF0YV91c2VyLmdldCh0aGlzLCBjYW1lbEtleSk7IC8vIEZvciBIVE1MNSBkYXRhLSogYXR0cmlidXRlIGludGVyb3AsIHdlIGhhdmUgdG9cXG4gICAgICAgICAgLy8gc3RvcmUgcHJvcGVydHkgbmFtZXMgd2l0aCBkYXNoZXMgaW4gYSBjYW1lbENhc2UgZm9ybS5cXG4gICAgICAgICAgLy8gVGhpcyBtaWdodCBub3QgYXBwbHkgdG8gYWxsIHByb3BlcnRpZXMuLi4qXFxuXFxuICAgICAgICAgIGRhdGFfdXNlci5zZXQodGhpcywgY2FtZWxLZXksIHZhbHVlKTsgLy8gKi4uLiBJbiB0aGUgY2FzZSBvZiBwcm9wZXJ0aWVzIHRoYXQgbWlnaHQgX2FjdHVhbGx5X1xcbiAgICAgICAgICAvLyBoYXZlIGRhc2hlcywgd2UgbmVlZCB0byBhbHNvIHN0b3JlIGEgY29weSBvZiB0aGF0XFxuICAgICAgICAgIC8vIHVuY2hhbmdlZCBwcm9wZXJ0eS5cXG5cXG4gICAgICAgICAgaWYgKGtleS5pbmRleE9mKFxcXCItXFxcIikgIT09IC0xICYmIGRhdGEgIT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgICAgIGRhdGFfdXNlci5zZXQodGhpcywga2V5LCB2YWx1ZSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICAgIH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSwgbnVsbCwgdHJ1ZSk7XFxuICAgIH0sXFxuICAgIHJlbW92ZURhdGE6IGZ1bmN0aW9uIHJlbW92ZURhdGEoa2V5KSB7XFxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICBkYXRhX3VzZXIucmVtb3ZlKHRoaXMsIGtleSk7XFxuICAgICAgfSk7XFxuICAgIH1cXG4gIH0pO1xcbiAgalF1ZXJ5LmV4dGVuZCh7XFxuICAgIHF1ZXVlOiBmdW5jdGlvbiBxdWV1ZShlbGVtLCB0eXBlLCBkYXRhKSB7XFxuICAgICAgdmFyIHF1ZXVlO1xcblxcbiAgICAgIGlmIChlbGVtKSB7XFxuICAgICAgICB0eXBlID0gKHR5cGUgfHwgXFxcImZ4XFxcIikgKyBcXFwicXVldWVcXFwiO1xcbiAgICAgICAgcXVldWUgPSBkYXRhX3ByaXYuZ2V0KGVsZW0sIHR5cGUpOyAvLyBTcGVlZCB1cCBkZXF1ZXVlIGJ5IGdldHRpbmcgb3V0IHF1aWNrbHkgaWYgdGhpcyBpcyBqdXN0IGEgbG9va3VwXFxuXFxuICAgICAgICBpZiAoZGF0YSkge1xcbiAgICAgICAgICBpZiAoIXF1ZXVlIHx8IGpRdWVyeS5pc0FycmF5KGRhdGEpKSB7XFxuICAgICAgICAgICAgcXVldWUgPSBkYXRhX3ByaXYuYWNjZXNzKGVsZW0sIHR5cGUsIGpRdWVyeS5tYWtlQXJyYXkoZGF0YSkpO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHF1ZXVlLnB1c2goZGF0YSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiBxdWV1ZSB8fCBbXTtcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIGRlcXVldWU6IGZ1bmN0aW9uIGRlcXVldWUoZWxlbSwgdHlwZSkge1xcbiAgICAgIHR5cGUgPSB0eXBlIHx8IFxcXCJmeFxcXCI7XFxuXFxuICAgICAgdmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKGVsZW0sIHR5cGUpLFxcbiAgICAgICAgICBzdGFydExlbmd0aCA9IHF1ZXVlLmxlbmd0aCxcXG4gICAgICAgICAgZm4gPSBxdWV1ZS5zaGlmdCgpLFxcbiAgICAgICAgICBob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyhlbGVtLCB0eXBlKSxcXG4gICAgICAgICAgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XFxuICAgICAgICBqUXVlcnkuZGVxdWV1ZShlbGVtLCB0eXBlKTtcXG4gICAgICB9OyAvLyBJZiB0aGUgZnggcXVldWUgaXMgZGVxdWV1ZWQsIGFsd2F5cyByZW1vdmUgdGhlIHByb2dyZXNzIHNlbnRpbmVsXFxuXFxuXFxuICAgICAgaWYgKGZuID09PSBcXFwiaW5wcm9ncmVzc1xcXCIpIHtcXG4gICAgICAgIGZuID0gcXVldWUuc2hpZnQoKTtcXG4gICAgICAgIHN0YXJ0TGVuZ3RoLS07XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChmbikge1xcbiAgICAgICAgLy8gQWRkIGEgcHJvZ3Jlc3Mgc2VudGluZWwgdG8gcHJldmVudCB0aGUgZnggcXVldWUgZnJvbSBiZWluZ1xcbiAgICAgICAgLy8gYXV0b21hdGljYWxseSBkZXF1ZXVlZFxcbiAgICAgICAgaWYgKHR5cGUgPT09IFxcXCJmeFxcXCIpIHtcXG4gICAgICAgICAgcXVldWUudW5zaGlmdChcXFwiaW5wcm9ncmVzc1xcXCIpO1xcbiAgICAgICAgfSAvLyBDbGVhciB1cCB0aGUgbGFzdCBxdWV1ZSBzdG9wIGZ1bmN0aW9uXFxuXFxuXFxuICAgICAgICBkZWxldGUgaG9va3Muc3RvcDtcXG4gICAgICAgIGZuLmNhbGwoZWxlbSwgbmV4dCwgaG9va3MpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIXN0YXJ0TGVuZ3RoICYmIGhvb2tzKSB7XFxuICAgICAgICBob29rcy5lbXB0eS5maXJlKCk7XFxuICAgICAgfVxcbiAgICB9LFxcbiAgICAvLyBOb3QgcHVibGljIC0gZ2VuZXJhdGUgYSBxdWV1ZUhvb2tzIG9iamVjdCwgb3IgcmV0dXJuIHRoZSBjdXJyZW50IG9uZVxcbiAgICBfcXVldWVIb29rczogZnVuY3Rpb24gX3F1ZXVlSG9va3MoZWxlbSwgdHlwZSkge1xcbiAgICAgIHZhciBrZXkgPSB0eXBlICsgXFxcInF1ZXVlSG9va3NcXFwiO1xcbiAgICAgIHJldHVybiBkYXRhX3ByaXYuZ2V0KGVsZW0sIGtleSkgfHwgZGF0YV9wcml2LmFjY2VzcyhlbGVtLCBrZXksIHtcXG4gICAgICAgIGVtcHR5OiBqUXVlcnkuQ2FsbGJhY2tzKFxcXCJvbmNlIG1lbW9yeVxcXCIpLmFkZChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIGRhdGFfcHJpdi5yZW1vdmUoZWxlbSwgW3R5cGUgKyBcXFwicXVldWVcXFwiLCBrZXldKTtcXG4gICAgICAgIH0pXFxuICAgICAgfSk7XFxuICAgIH1cXG4gIH0pO1xcbiAgalF1ZXJ5LmZuLmV4dGVuZCh7XFxuICAgIHF1ZXVlOiBmdW5jdGlvbiBxdWV1ZSh0eXBlLCBkYXRhKSB7XFxuICAgICAgdmFyIHNldHRlciA9IDI7XFxuXFxuICAgICAgaWYgKHR5cGVvZiB0eXBlICE9PSBcXFwic3RyaW5nXFxcIikge1xcbiAgICAgICAgZGF0YSA9IHR5cGU7XFxuICAgICAgICB0eXBlID0gXFxcImZ4XFxcIjtcXG4gICAgICAgIHNldHRlci0tO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IHNldHRlcikge1xcbiAgICAgICAgcmV0dXJuIGpRdWVyeS5xdWV1ZSh0aGlzWzBdLCB0eXBlKTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIGRhdGEgPT09IHVuZGVmaW5lZCA/IHRoaXMgOiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKHRoaXMsIHR5cGUsIGRhdGEpOyAvLyBFbnN1cmUgYSBob29rcyBmb3IgdGhpcyBxdWV1ZVxcblxcbiAgICAgICAgalF1ZXJ5Ll9xdWV1ZUhvb2tzKHRoaXMsIHR5cGUpO1xcblxcbiAgICAgICAgaWYgKHR5cGUgPT09IFxcXCJmeFxcXCIgJiYgcXVldWVbMF0gIT09IFxcXCJpbnByb2dyZXNzXFxcIikge1xcbiAgICAgICAgICBqUXVlcnkuZGVxdWV1ZSh0aGlzLCB0eXBlKTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgfSxcXG4gICAgZGVxdWV1ZTogZnVuY3Rpb24gZGVxdWV1ZSh0eXBlKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICBqUXVlcnkuZGVxdWV1ZSh0aGlzLCB0eXBlKTtcXG4gICAgICB9KTtcXG4gICAgfSxcXG4gICAgY2xlYXJRdWV1ZTogZnVuY3Rpb24gY2xlYXJRdWV1ZSh0eXBlKSB7XFxuICAgICAgcmV0dXJuIHRoaXMucXVldWUodHlwZSB8fCBcXFwiZnhcXFwiLCBbXSk7XFxuICAgIH0sXFxuICAgIC8vIEdldCBhIHByb21pc2UgcmVzb2x2ZWQgd2hlbiBxdWV1ZXMgb2YgYSBjZXJ0YWluIHR5cGVcXG4gICAgLy8gYXJlIGVtcHRpZWQgKGZ4IGlzIHRoZSB0eXBlIGJ5IGRlZmF1bHQpXFxuICAgIHByb21pc2U6IGZ1bmN0aW9uIHByb21pc2UodHlwZSwgb2JqKSB7XFxuICAgICAgdmFyIHRtcCxcXG4gICAgICAgICAgY291bnQgPSAxLFxcbiAgICAgICAgICBkZWZlciA9IGpRdWVyeS5EZWZlcnJlZCgpLFxcbiAgICAgICAgICBlbGVtZW50cyA9IHRoaXMsXFxuICAgICAgICAgIGkgPSB0aGlzLmxlbmd0aCxcXG4gICAgICAgICAgcmVzb2x2ZSA9IGZ1bmN0aW9uIHJlc29sdmUoKSB7XFxuICAgICAgICBpZiAoISAtLWNvdW50KSB7XFxuICAgICAgICAgIGRlZmVyLnJlc29sdmVXaXRoKGVsZW1lbnRzLCBbZWxlbWVudHNdKTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcblxcbiAgICAgIGlmICh0eXBlb2YgdHlwZSAhPT0gXFxcInN0cmluZ1xcXCIpIHtcXG4gICAgICAgIG9iaiA9IHR5cGU7XFxuICAgICAgICB0eXBlID0gdW5kZWZpbmVkO1xcbiAgICAgIH1cXG5cXG4gICAgICB0eXBlID0gdHlwZSB8fCBcXFwiZnhcXFwiO1xcblxcbiAgICAgIHdoaWxlIChpLS0pIHtcXG4gICAgICAgIHRtcCA9IGRhdGFfcHJpdi5nZXQoZWxlbWVudHNbaV0sIHR5cGUgKyBcXFwicXVldWVIb29rc1xcXCIpO1xcblxcbiAgICAgICAgaWYgKHRtcCAmJiB0bXAuZW1wdHkpIHtcXG4gICAgICAgICAgY291bnQrKztcXG4gICAgICAgICAgdG1wLmVtcHR5LmFkZChyZXNvbHZlKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgcmVzb2x2ZSgpO1xcbiAgICAgIHJldHVybiBkZWZlci5wcm9taXNlKG9iaik7XFxuICAgIH1cXG4gIH0pO1xcbiAgdmFyIHBudW0gPSAvWystXT8oPzpcXFxcZCpcXFxcLnwpXFxcXGQrKD86W2VFXVsrLV0/XFxcXGQrfCkvLnNvdXJjZTtcXG4gIHZhciBjc3NFeHBhbmQgPSBbXFxcIlRvcFxcXCIsIFxcXCJSaWdodFxcXCIsIFxcXCJCb3R0b21cXFwiLCBcXFwiTGVmdFxcXCJdO1xcblxcbiAgdmFyIGlzSGlkZGVuID0gZnVuY3Rpb24gaXNIaWRkZW4oZWxlbSwgZWwpIHtcXG4gICAgLy8gaXNIaWRkZW4gbWlnaHQgYmUgY2FsbGVkIGZyb20galF1ZXJ5I2ZpbHRlciBmdW5jdGlvbjtcXG4gICAgLy8gaW4gdGhhdCBjYXNlLCBlbGVtZW50IHdpbGwgYmUgc2Vjb25kIGFyZ3VtZW50XFxuICAgIGVsZW0gPSBlbCB8fCBlbGVtO1xcbiAgICByZXR1cm4galF1ZXJ5LmNzcyhlbGVtLCBcXFwiZGlzcGxheVxcXCIpID09PSBcXFwibm9uZVxcXCIgfHwgIWpRdWVyeS5jb250YWlucyhlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0pO1xcbiAgfTtcXG5cXG4gIHZhciByY2hlY2thYmxlVHlwZSA9IC9eKD86Y2hlY2tib3h8cmFkaW8pJC9pO1xcblxcbiAgKGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxcbiAgICAgICAgZGl2ID0gZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwiZGl2XFxcIikpLFxcbiAgICAgICAgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxcXCJpbnB1dFxcXCIpOyAvLyBTdXBwb3J0OiBTYWZhcmk8PTUuMVxcbiAgICAvLyBDaGVjayBzdGF0ZSBsb3N0IGlmIHRoZSBuYW1lIGlzIHNldCAoIzExMjE3KVxcbiAgICAvLyBTdXBwb3J0OiBXaW5kb3dzIFdlYiBBcHBzIChXV0EpXFxuICAgIC8vIGBuYW1lYCBhbmQgYHR5cGVgIG11c3QgdXNlIC5zZXRBdHRyaWJ1dGUgZm9yIFdXQSAoIzE0OTAxKVxcblxcbiAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoXFxcInR5cGVcXFwiLCBcXFwicmFkaW9cXFwiKTtcXG4gICAgaW5wdXQuc2V0QXR0cmlidXRlKFxcXCJjaGVja2VkXFxcIiwgXFxcImNoZWNrZWRcXFwiKTtcXG4gICAgaW5wdXQuc2V0QXR0cmlidXRlKFxcXCJuYW1lXFxcIiwgXFxcInRcXFwiKTtcXG4gICAgZGl2LmFwcGVuZENoaWxkKGlucHV0KTsgLy8gU3VwcG9ydDogU2FmYXJpPD01LjEsIEFuZHJvaWQ8NC4yXFxuICAgIC8vIE9sZGVyIFdlYktpdCBkb2Vzbid0IGNsb25lIGNoZWNrZWQgc3RhdGUgY29ycmVjdGx5IGluIGZyYWdtZW50c1xcblxcbiAgICBzdXBwb3J0LmNoZWNrQ2xvbmUgPSBkaXYuY2xvbmVOb2RlKHRydWUpLmNsb25lTm9kZSh0cnVlKS5sYXN0Q2hpbGQuY2hlY2tlZDsgLy8gU3VwcG9ydDogSUU8PTExK1xcbiAgICAvLyBNYWtlIHN1cmUgdGV4dGFyZWEgKGFuZCBjaGVja2JveCkgZGVmYXVsdFZhbHVlIGlzIHByb3Blcmx5IGNsb25lZFxcblxcbiAgICBkaXYuaW5uZXJIVE1MID0gXFxcIjx0ZXh0YXJlYT54PC90ZXh0YXJlYT5cXFwiO1xcbiAgICBzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkID0gISFkaXYuY2xvbmVOb2RlKHRydWUpLmxhc3RDaGlsZC5kZWZhdWx0VmFsdWU7XFxuICB9KSgpO1xcblxcbiAgdmFyIHN0cnVuZGVmaW5lZCA9IHR5cGVvZiB1bmRlZmluZWQgPT09IFxcXCJ1bmRlZmluZWRcXFwiID8gXFxcInVuZGVmaW5lZFxcXCIgOiBfdHlwZW9mKHVuZGVmaW5lZCk7XFxuICBzdXBwb3J0LmZvY3VzaW5CdWJibGVzID0gXFxcIm9uZm9jdXNpblxcXCIgaW4gd2luZG93O1xcbiAgdmFyIHJrZXlFdmVudCA9IC9ea2V5LyxcXG4gICAgICBybW91c2VFdmVudCA9IC9eKD86bW91c2V8cG9pbnRlcnxjb250ZXh0bWVudSl8Y2xpY2svLFxcbiAgICAgIHJmb2N1c01vcnBoID0gL14oPzpmb2N1c2luZm9jdXN8Zm9jdXNvdXRibHVyKSQvLFxcbiAgICAgIHJ0eXBlbmFtZXNwYWNlID0gL14oW14uXSopKD86XFxcXC4oLispfCkkLztcXG5cXG4gIGZ1bmN0aW9uIHJldHVyblRydWUoKSB7XFxuICAgIHJldHVybiB0cnVlO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XFxuICAgIHJldHVybiBmYWxzZTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIHNhZmVBY3RpdmVFbGVtZW50KCkge1xcbiAgICB0cnkge1xcbiAgICAgIHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xcbiAgICB9IGNhdGNoIChlcnIpIHt9XFxuICB9XFxuICAvKlxcbiAgICogSGVscGVyIGZ1bmN0aW9ucyBmb3IgbWFuYWdpbmcgZXZlbnRzIC0tIG5vdCBwYXJ0IG9mIHRoZSBwdWJsaWMgaW50ZXJmYWNlLlxcbiAgICogUHJvcHMgdG8gRGVhbiBFZHdhcmRzJyBhZGRFdmVudCBsaWJyYXJ5IGZvciBtYW55IG9mIHRoZSBpZGVhcy5cXG4gICAqL1xcblxcblxcbiAgalF1ZXJ5LmV2ZW50ID0ge1xcbiAgICBnbG9iYWw6IHt9LFxcbiAgICBhZGQ6IGZ1bmN0aW9uIGFkZChlbGVtLCB0eXBlcywgaGFuZGxlciwgZGF0YSwgc2VsZWN0b3IpIHtcXG4gICAgICB2YXIgaGFuZGxlT2JqSW4sXFxuICAgICAgICAgIGV2ZW50SGFuZGxlLFxcbiAgICAgICAgICB0bXAsXFxuICAgICAgICAgIGV2ZW50cyxcXG4gICAgICAgICAgdCxcXG4gICAgICAgICAgaGFuZGxlT2JqLFxcbiAgICAgICAgICBzcGVjaWFsLFxcbiAgICAgICAgICBoYW5kbGVycyxcXG4gICAgICAgICAgdHlwZSxcXG4gICAgICAgICAgbmFtZXNwYWNlcyxcXG4gICAgICAgICAgb3JpZ1R5cGUsXFxuICAgICAgICAgIGVsZW1EYXRhID0gZGF0YV9wcml2LmdldChlbGVtKTsgLy8gRG9uJ3QgYXR0YWNoIGV2ZW50cyB0byBub0RhdGEgb3IgdGV4dC9jb21tZW50IG5vZGVzIChidXQgYWxsb3cgcGxhaW4gb2JqZWN0cylcXG5cXG4gICAgICBpZiAoIWVsZW1EYXRhKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfSAvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYW4gb2JqZWN0IG9mIGN1c3RvbSBkYXRhIGluIGxpZXUgb2YgdGhlIGhhbmRsZXJcXG5cXG5cXG4gICAgICBpZiAoaGFuZGxlci5oYW5kbGVyKSB7XFxuICAgICAgICBoYW5kbGVPYmpJbiA9IGhhbmRsZXI7XFxuICAgICAgICBoYW5kbGVyID0gaGFuZGxlT2JqSW4uaGFuZGxlcjtcXG4gICAgICAgIHNlbGVjdG9yID0gaGFuZGxlT2JqSW4uc2VsZWN0b3I7XFxuICAgICAgfSAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgaGFuZGxlciBoYXMgYSB1bmlxdWUgSUQsIHVzZWQgdG8gZmluZC9yZW1vdmUgaXQgbGF0ZXJcXG5cXG5cXG4gICAgICBpZiAoIWhhbmRsZXIuZ3VpZCkge1xcbiAgICAgICAgaGFuZGxlci5ndWlkID0galF1ZXJ5Lmd1aWQrKztcXG4gICAgICB9IC8vIEluaXQgdGhlIGVsZW1lbnQncyBldmVudCBzdHJ1Y3R1cmUgYW5kIG1haW4gaGFuZGxlciwgaWYgdGhpcyBpcyB0aGUgZmlyc3RcXG5cXG5cXG4gICAgICBpZiAoIShldmVudHMgPSBlbGVtRGF0YS5ldmVudHMpKSB7XFxuICAgICAgICBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgPSB7fTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCEoZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUpKSB7XFxuICAgICAgICBldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSA9IGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICAgIC8vIERpc2NhcmQgdGhlIHNlY29uZCBldmVudCBvZiBhIGpRdWVyeS5ldmVudC50cmlnZ2VyKCkgYW5kXFxuICAgICAgICAgIC8vIHdoZW4gYW4gZXZlbnQgaXMgY2FsbGVkIGFmdGVyIGEgcGFnZSBoYXMgdW5sb2FkZWRcXG4gICAgICAgICAgcmV0dXJuIF90eXBlb2YoalF1ZXJ5KSAhPT0gc3RydW5kZWZpbmVkICYmIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgIT09IGUudHlwZSA/IGpRdWVyeS5ldmVudC5kaXNwYXRjaC5hcHBseShlbGVtLCBhcmd1bWVudHMpIDogdW5kZWZpbmVkO1xcbiAgICAgICAgfTtcXG4gICAgICB9IC8vIEhhbmRsZSBtdWx0aXBsZSBldmVudHMgc2VwYXJhdGVkIGJ5IGEgc3BhY2VcXG5cXG5cXG4gICAgICB0eXBlcyA9ICh0eXBlcyB8fCBcXFwiXFxcIikubWF0Y2gocm5vdHdoaXRlKSB8fCBbXFxcIlxcXCJdO1xcbiAgICAgIHQgPSB0eXBlcy5sZW5ndGg7XFxuXFxuICAgICAgd2hpbGUgKHQtLSkge1xcbiAgICAgICAgdG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyh0eXBlc1t0XSkgfHwgW107XFxuICAgICAgICB0eXBlID0gb3JpZ1R5cGUgPSB0bXBbMV07XFxuICAgICAgICBuYW1lc3BhY2VzID0gKHRtcFsyXSB8fCBcXFwiXFxcIikuc3BsaXQoXFxcIi5cXFwiKS5zb3J0KCk7IC8vIFRoZXJlICptdXN0KiBiZSBhIHR5cGUsIG5vIGF0dGFjaGluZyBuYW1lc3BhY2Utb25seSBoYW5kbGVyc1xcblxcbiAgICAgICAgaWYgKCF0eXBlKSB7XFxuICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgfSAvLyBJZiBldmVudCBjaGFuZ2VzIGl0cyB0eXBlLCB1c2UgdGhlIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMgZm9yIHRoZSBjaGFuZ2VkIHR5cGVcXG5cXG5cXG4gICAgICAgIHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFt0eXBlXSB8fCB7fTsgLy8gSWYgc2VsZWN0b3IgZGVmaW5lZCwgZGV0ZXJtaW5lIHNwZWNpYWwgZXZlbnQgYXBpIHR5cGUsIG90aGVyd2lzZSBnaXZlbiB0eXBlXFxuXFxuICAgICAgICB0eXBlID0gKHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlKSB8fCB0eXBlOyAvLyBVcGRhdGUgc3BlY2lhbCBiYXNlZCBvbiBuZXdseSByZXNldCB0eXBlXFxuXFxuICAgICAgICBzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbdHlwZV0gfHwge307IC8vIGhhbmRsZU9iaiBpcyBwYXNzZWQgdG8gYWxsIGV2ZW50IGhhbmRsZXJzXFxuXFxuICAgICAgICBoYW5kbGVPYmogPSBqUXVlcnkuZXh0ZW5kKHtcXG4gICAgICAgICAgdHlwZTogdHlwZSxcXG4gICAgICAgICAgb3JpZ1R5cGU6IG9yaWdUeXBlLFxcbiAgICAgICAgICBkYXRhOiBkYXRhLFxcbiAgICAgICAgICBoYW5kbGVyOiBoYW5kbGVyLFxcbiAgICAgICAgICBndWlkOiBoYW5kbGVyLmd1aWQsXFxuICAgICAgICAgIHNlbGVjdG9yOiBzZWxlY3RvcixcXG4gICAgICAgICAgbmVlZHNDb250ZXh0OiBzZWxlY3RvciAmJiBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQudGVzdChzZWxlY3RvciksXFxuICAgICAgICAgIG5hbWVzcGFjZTogbmFtZXNwYWNlcy5qb2luKFxcXCIuXFxcIilcXG4gICAgICAgIH0sIGhhbmRsZU9iakluKTsgLy8gSW5pdCB0aGUgZXZlbnQgaGFuZGxlciBxdWV1ZSBpZiB3ZSdyZSB0aGUgZmlyc3RcXG5cXG4gICAgICAgIGlmICghKGhhbmRsZXJzID0gZXZlbnRzW3R5cGVdKSkge1xcbiAgICAgICAgICBoYW5kbGVycyA9IGV2ZW50c1t0eXBlXSA9IFtdO1xcbiAgICAgICAgICBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50ID0gMDsgLy8gT25seSB1c2UgYWRkRXZlbnRMaXN0ZW5lciBpZiB0aGUgc3BlY2lhbCBldmVudHMgaGFuZGxlciByZXR1cm5zIGZhbHNlXFxuXFxuICAgICAgICAgIGlmICghc3BlY2lhbC5zZXR1cCB8fCBzcGVjaWFsLnNldHVwLmNhbGwoZWxlbSwgZGF0YSwgbmFtZXNwYWNlcywgZXZlbnRIYW5kbGUpID09PSBmYWxzZSkge1xcbiAgICAgICAgICAgIGlmIChlbGVtLmFkZEV2ZW50TGlzdGVuZXIpIHtcXG4gICAgICAgICAgICAgIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBldmVudEhhbmRsZSwgZmFsc2UpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKHNwZWNpYWwuYWRkKSB7XFxuICAgICAgICAgIHNwZWNpYWwuYWRkLmNhbGwoZWxlbSwgaGFuZGxlT2JqKTtcXG5cXG4gICAgICAgICAgaWYgKCFoYW5kbGVPYmouaGFuZGxlci5ndWlkKSB7XFxuICAgICAgICAgICAgaGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCA9IGhhbmRsZXIuZ3VpZDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSAvLyBBZGQgdG8gdGhlIGVsZW1lbnQncyBoYW5kbGVyIGxpc3QsIGRlbGVnYXRlcyBpbiBmcm9udFxcblxcblxcbiAgICAgICAgaWYgKHNlbGVjdG9yKSB7XFxuICAgICAgICAgIGhhbmRsZXJzLnNwbGljZShoYW5kbGVycy5kZWxlZ2F0ZUNvdW50KyssIDAsIGhhbmRsZU9iaik7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBoYW5kbGVycy5wdXNoKGhhbmRsZU9iaik7XFxuICAgICAgICB9IC8vIEtlZXAgdHJhY2sgb2Ygd2hpY2ggZXZlbnRzIGhhdmUgZXZlciBiZWVuIHVzZWQsIGZvciBldmVudCBvcHRpbWl6YXRpb25cXG5cXG5cXG4gICAgICAgIGpRdWVyeS5ldmVudC5nbG9iYWxbdHlwZV0gPSB0cnVlO1xcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgLy8gRGV0YWNoIGFuIGV2ZW50IG9yIHNldCBvZiBldmVudHMgZnJvbSBhbiBlbGVtZW50XFxuICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBzZWxlY3RvciwgbWFwcGVkVHlwZXMpIHtcXG4gICAgICB2YXIgaixcXG4gICAgICAgICAgb3JpZ0NvdW50LFxcbiAgICAgICAgICB0bXAsXFxuICAgICAgICAgIGV2ZW50cyxcXG4gICAgICAgICAgdCxcXG4gICAgICAgICAgaGFuZGxlT2JqLFxcbiAgICAgICAgICBzcGVjaWFsLFxcbiAgICAgICAgICBoYW5kbGVycyxcXG4gICAgICAgICAgdHlwZSxcXG4gICAgICAgICAgbmFtZXNwYWNlcyxcXG4gICAgICAgICAgb3JpZ1R5cGUsXFxuICAgICAgICAgIGVsZW1EYXRhID0gZGF0YV9wcml2Lmhhc0RhdGEoZWxlbSkgJiYgZGF0YV9wcml2LmdldChlbGVtKTtcXG5cXG4gICAgICBpZiAoIWVsZW1EYXRhIHx8ICEoZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzKSkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH0gLy8gT25jZSBmb3IgZWFjaCB0eXBlLm5hbWVzcGFjZSBpbiB0eXBlczsgdHlwZSBtYXkgYmUgb21pdHRlZFxcblxcblxcbiAgICAgIHR5cGVzID0gKHR5cGVzIHx8IFxcXCJcXFwiKS5tYXRjaChybm90d2hpdGUpIHx8IFtcXFwiXFxcIl07XFxuICAgICAgdCA9IHR5cGVzLmxlbmd0aDtcXG5cXG4gICAgICB3aGlsZSAodC0tKSB7XFxuICAgICAgICB0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKHR5cGVzW3RdKSB8fCBbXTtcXG4gICAgICAgIHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsxXTtcXG4gICAgICAgIG5hbWVzcGFjZXMgPSAodG1wWzJdIHx8IFxcXCJcXFwiKS5zcGxpdChcXFwiLlxcXCIpLnNvcnQoKTsgLy8gVW5iaW5kIGFsbCBldmVudHMgKG9uIHRoaXMgbmFtZXNwYWNlLCBpZiBwcm92aWRlZCkgZm9yIHRoZSBlbGVtZW50XFxuXFxuICAgICAgICBpZiAoIXR5cGUpIHtcXG4gICAgICAgICAgZm9yICh0eXBlIGluIGV2ZW50cykge1xcbiAgICAgICAgICAgIGpRdWVyeS5ldmVudC5yZW1vdmUoZWxlbSwgdHlwZSArIHR5cGVzW3RdLCBoYW5kbGVyLCBzZWxlY3RvciwgdHJ1ZSk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgY29udGludWU7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbdHlwZV0gfHwge307XFxuICAgICAgICB0eXBlID0gKHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlKSB8fCB0eXBlO1xcbiAgICAgICAgaGFuZGxlcnMgPSBldmVudHNbdHlwZV0gfHwgW107XFxuICAgICAgICB0bXAgPSB0bXBbMl0gJiYgbmV3IFJlZ0V4cChcXFwiKF58XFxcXFxcXFwuKVxcXCIgKyBuYW1lc3BhY2VzLmpvaW4oXFxcIlxcXFxcXFxcLig/Oi4qXFxcXFxcXFwufClcXFwiKSArIFxcXCIoXFxcXFxcXFwufCQpXFxcIik7IC8vIFJlbW92ZSBtYXRjaGluZyBldmVudHNcXG5cXG4gICAgICAgIG9yaWdDb3VudCA9IGogPSBoYW5kbGVycy5sZW5ndGg7XFxuXFxuICAgICAgICB3aGlsZSAoai0tKSB7XFxuICAgICAgICAgIGhhbmRsZU9iaiA9IGhhbmRsZXJzW2pdO1xcblxcbiAgICAgICAgICBpZiAoKG1hcHBlZFR5cGVzIHx8IG9yaWdUeXBlID09PSBoYW5kbGVPYmoub3JpZ1R5cGUpICYmICghaGFuZGxlciB8fCBoYW5kbGVyLmd1aWQgPT09IGhhbmRsZU9iai5ndWlkKSAmJiAoIXRtcCB8fCB0bXAudGVzdChoYW5kbGVPYmoubmFtZXNwYWNlKSkgJiYgKCFzZWxlY3RvciB8fCBzZWxlY3RvciA9PT0gaGFuZGxlT2JqLnNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSBcXFwiKipcXFwiICYmIGhhbmRsZU9iai5zZWxlY3RvcikpIHtcXG4gICAgICAgICAgICBoYW5kbGVycy5zcGxpY2UoaiwgMSk7XFxuXFxuICAgICAgICAgICAgaWYgKGhhbmRsZU9iai5zZWxlY3Rvcikge1xcbiAgICAgICAgICAgICAgaGFuZGxlcnMuZGVsZWdhdGVDb3VudC0tO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpZiAoc3BlY2lhbC5yZW1vdmUpIHtcXG4gICAgICAgICAgICAgIHNwZWNpYWwucmVtb3ZlLmNhbGwoZWxlbSwgaGFuZGxlT2JqKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gLy8gUmVtb3ZlIGdlbmVyaWMgZXZlbnQgaGFuZGxlciBpZiB3ZSByZW1vdmVkIHNvbWV0aGluZyBhbmQgbm8gbW9yZSBoYW5kbGVycyBleGlzdFxcbiAgICAgICAgLy8gKGF2b2lkcyBwb3RlbnRpYWwgZm9yIGVuZGxlc3MgcmVjdXJzaW9uIGR1cmluZyByZW1vdmFsIG9mIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMpXFxuXFxuXFxuICAgICAgICBpZiAob3JpZ0NvdW50ICYmICFoYW5kbGVycy5sZW5ndGgpIHtcXG4gICAgICAgICAgaWYgKCFzcGVjaWFsLnRlYXJkb3duIHx8IHNwZWNpYWwudGVhcmRvd24uY2FsbChlbGVtLCBuYW1lc3BhY2VzLCBlbGVtRGF0YS5oYW5kbGUpID09PSBmYWxzZSkge1xcbiAgICAgICAgICAgIGpRdWVyeS5yZW1vdmVFdmVudChlbGVtLCB0eXBlLCBlbGVtRGF0YS5oYW5kbGUpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XFxuICAgICAgICB9XFxuICAgICAgfSAvLyBSZW1vdmUgdGhlIGV4cGFuZG8gaWYgaXQncyBubyBsb25nZXIgdXNlZFxcblxcblxcbiAgICAgIGlmIChqUXVlcnkuaXNFbXB0eU9iamVjdChldmVudHMpKSB7XFxuICAgICAgICBkZWxldGUgZWxlbURhdGEuaGFuZGxlO1xcbiAgICAgICAgZGF0YV9wcml2LnJlbW92ZShlbGVtLCBcXFwiZXZlbnRzXFxcIik7XFxuICAgICAgfVxcbiAgICB9LFxcbiAgICB0cmlnZ2VyOiBmdW5jdGlvbiB0cmlnZ2VyKGV2ZW50LCBkYXRhLCBlbGVtLCBvbmx5SGFuZGxlcnMpIHtcXG4gICAgICB2YXIgaSxcXG4gICAgICAgICAgY3VyLFxcbiAgICAgICAgICB0bXAsXFxuICAgICAgICAgIGJ1YmJsZVR5cGUsXFxuICAgICAgICAgIG9udHlwZSxcXG4gICAgICAgICAgaGFuZGxlLFxcbiAgICAgICAgICBzcGVjaWFsLFxcbiAgICAgICAgICBldmVudFBhdGggPSBbZWxlbSB8fCBkb2N1bWVudF0sXFxuICAgICAgICAgIHR5cGUgPSBoYXNPd24uY2FsbChldmVudCwgXFxcInR5cGVcXFwiKSA/IGV2ZW50LnR5cGUgOiBldmVudCxcXG4gICAgICAgICAgbmFtZXNwYWNlcyA9IGhhc093bi5jYWxsKGV2ZW50LCBcXFwibmFtZXNwYWNlXFxcIikgPyBldmVudC5uYW1lc3BhY2Uuc3BsaXQoXFxcIi5cXFwiKSA6IFtdO1xcbiAgICAgIGN1ciA9IHRtcCA9IGVsZW0gPSBlbGVtIHx8IGRvY3VtZW50OyAvLyBEb24ndCBkbyBldmVudHMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xcblxcbiAgICAgIGlmIChlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDgpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9IC8vIGZvY3VzL2JsdXIgbW9ycGhzIHRvIGZvY3VzaW4vb3V0OyBlbnN1cmUgd2UncmUgbm90IGZpcmluZyB0aGVtIHJpZ2h0IG5vd1xcblxcblxcbiAgICAgIGlmIChyZm9jdXNNb3JwaC50ZXN0KHR5cGUgKyBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkKSkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodHlwZS5pbmRleE9mKFxcXCIuXFxcIikgPj0gMCkge1xcbiAgICAgICAgLy8gTmFtZXNwYWNlZCB0cmlnZ2VyOyBjcmVhdGUgYSByZWdleHAgdG8gbWF0Y2ggZXZlbnQgdHlwZSBpbiBoYW5kbGUoKVxcbiAgICAgICAgbmFtZXNwYWNlcyA9IHR5cGUuc3BsaXQoXFxcIi5cXFwiKTtcXG4gICAgICAgIHR5cGUgPSBuYW1lc3BhY2VzLnNoaWZ0KCk7XFxuICAgICAgICBuYW1lc3BhY2VzLnNvcnQoKTtcXG4gICAgICB9XFxuXFxuICAgICAgb250eXBlID0gdHlwZS5pbmRleE9mKFxcXCI6XFxcIikgPCAwICYmIFxcXCJvblxcXCIgKyB0eXBlOyAvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYSBqUXVlcnkuRXZlbnQgb2JqZWN0LCBPYmplY3QsIG9yIGp1c3QgYW4gZXZlbnQgdHlwZSBzdHJpbmdcXG5cXG4gICAgICBldmVudCA9IGV2ZW50W2pRdWVyeS5leHBhbmRvXSA/IGV2ZW50IDogbmV3IGpRdWVyeS5FdmVudCh0eXBlLCBfdHlwZW9mKGV2ZW50KSA9PT0gXFxcIm9iamVjdFxcXCIgJiYgZXZlbnQpOyAvLyBUcmlnZ2VyIGJpdG1hc2s6ICYgMSBmb3IgbmF0aXZlIGhhbmRsZXJzOyAmIDIgZm9yIGpRdWVyeSAoYWx3YXlzIHRydWUpXFxuXFxuICAgICAgZXZlbnQuaXNUcmlnZ2VyID0gb25seUhhbmRsZXJzID8gMiA6IDM7XFxuICAgICAgZXZlbnQubmFtZXNwYWNlID0gbmFtZXNwYWNlcy5qb2luKFxcXCIuXFxcIik7XFxuICAgICAgZXZlbnQubmFtZXNwYWNlX3JlID0gZXZlbnQubmFtZXNwYWNlID8gbmV3IFJlZ0V4cChcXFwiKF58XFxcXFxcXFwuKVxcXCIgKyBuYW1lc3BhY2VzLmpvaW4oXFxcIlxcXFxcXFxcLig/Oi4qXFxcXFxcXFwufClcXFwiKSArIFxcXCIoXFxcXFxcXFwufCQpXFxcIikgOiBudWxsOyAvLyBDbGVhbiB1cCB0aGUgZXZlbnQgaW4gY2FzZSBpdCBpcyBiZWluZyByZXVzZWRcXG5cXG4gICAgICBldmVudC5yZXN1bHQgPSB1bmRlZmluZWQ7XFxuXFxuICAgICAgaWYgKCFldmVudC50YXJnZXQpIHtcXG4gICAgICAgIGV2ZW50LnRhcmdldCA9IGVsZW07XFxuICAgICAgfSAvLyBDbG9uZSBhbnkgaW5jb21pbmcgZGF0YSBhbmQgcHJlcGVuZCB0aGUgZXZlbnQsIGNyZWF0aW5nIHRoZSBoYW5kbGVyIGFyZyBsaXN0XFxuXFxuXFxuICAgICAgZGF0YSA9IGRhdGEgPT0gbnVsbCA/IFtldmVudF0gOiBqUXVlcnkubWFrZUFycmF5KGRhdGEsIFtldmVudF0pOyAvLyBBbGxvdyBzcGVjaWFsIGV2ZW50cyB0byBkcmF3IG91dHNpZGUgdGhlIGxpbmVzXFxuXFxuICAgICAgc3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsW3R5cGVdIHx8IHt9O1xcblxcbiAgICAgIGlmICghb25seUhhbmRsZXJzICYmIHNwZWNpYWwudHJpZ2dlciAmJiBzcGVjaWFsLnRyaWdnZXIuYXBwbHkoZWxlbSwgZGF0YSkgPT09IGZhbHNlKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfSAvLyBEZXRlcm1pbmUgZXZlbnQgcHJvcGFnYXRpb24gcGF0aCBpbiBhZHZhbmNlLCBwZXIgVzNDIGV2ZW50cyBzcGVjICgjOTk1MSlcXG4gICAgICAvLyBCdWJibGUgdXAgdG8gZG9jdW1lbnQsIHRoZW4gdG8gd2luZG93OyB3YXRjaCBmb3IgYSBnbG9iYWwgb3duZXJEb2N1bWVudCB2YXIgKCM5NzI0KVxcblxcblxcbiAgICAgIGlmICghb25seUhhbmRsZXJzICYmICFzcGVjaWFsLm5vQnViYmxlICYmICFqUXVlcnkuaXNXaW5kb3coZWxlbSkpIHtcXG4gICAgICAgIGJ1YmJsZVR5cGUgPSBzcGVjaWFsLmRlbGVnYXRlVHlwZSB8fCB0eXBlO1xcblxcbiAgICAgICAgaWYgKCFyZm9jdXNNb3JwaC50ZXN0KGJ1YmJsZVR5cGUgKyB0eXBlKSkge1xcbiAgICAgICAgICBjdXIgPSBjdXIucGFyZW50Tm9kZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGZvciAoOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlKSB7XFxuICAgICAgICAgIGV2ZW50UGF0aC5wdXNoKGN1cik7XFxuICAgICAgICAgIHRtcCA9IGN1cjtcXG4gICAgICAgIH0gLy8gT25seSBhZGQgd2luZG93IGlmIHdlIGdvdCB0byBkb2N1bWVudCAoZS5nLiwgbm90IHBsYWluIG9iaiBvciBkZXRhY2hlZCBET00pXFxuXFxuXFxuICAgICAgICBpZiAodG1wID09PSAoZWxlbS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50KSkge1xcbiAgICAgICAgICBldmVudFBhdGgucHVzaCh0bXAuZGVmYXVsdFZpZXcgfHwgdG1wLnBhcmVudFdpbmRvdyB8fCB3aW5kb3cpO1xcbiAgICAgICAgfVxcbiAgICAgIH0gLy8gRmlyZSBoYW5kbGVycyBvbiB0aGUgZXZlbnQgcGF0aFxcblxcblxcbiAgICAgIGkgPSAwO1xcblxcbiAgICAgIHdoaWxlICgoY3VyID0gZXZlbnRQYXRoW2krK10pICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XFxuICAgICAgICBldmVudC50eXBlID0gaSA+IDEgPyBidWJibGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSB8fCB0eXBlOyAvLyBqUXVlcnkgaGFuZGxlclxcblxcbiAgICAgICAgaGFuZGxlID0gKGRhdGFfcHJpdi5nZXQoY3VyLCBcXFwiZXZlbnRzXFxcIikgfHwge30pW2V2ZW50LnR5cGVdICYmIGRhdGFfcHJpdi5nZXQoY3VyLCBcXFwiaGFuZGxlXFxcIik7XFxuXFxuICAgICAgICBpZiAoaGFuZGxlKSB7XFxuICAgICAgICAgIGhhbmRsZS5hcHBseShjdXIsIGRhdGEpO1xcbiAgICAgICAgfSAvLyBOYXRpdmUgaGFuZGxlclxcblxcblxcbiAgICAgICAgaGFuZGxlID0gb250eXBlICYmIGN1cltvbnR5cGVdO1xcblxcbiAgICAgICAgaWYgKGhhbmRsZSAmJiBoYW5kbGUuYXBwbHkgJiYgalF1ZXJ5LmFjY2VwdERhdGEoY3VyKSkge1xcbiAgICAgICAgICBldmVudC5yZXN1bHQgPSBoYW5kbGUuYXBwbHkoY3VyLCBkYXRhKTtcXG5cXG4gICAgICAgICAgaWYgKGV2ZW50LnJlc3VsdCA9PT0gZmFsc2UpIHtcXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGV2ZW50LnR5cGUgPSB0eXBlOyAvLyBJZiBub2JvZHkgcHJldmVudGVkIHRoZSBkZWZhdWx0IGFjdGlvbiwgZG8gaXQgbm93XFxuXFxuICAgICAgaWYgKCFvbmx5SGFuZGxlcnMgJiYgIWV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XFxuICAgICAgICBpZiAoKCFzcGVjaWFsLl9kZWZhdWx0IHx8IHNwZWNpYWwuX2RlZmF1bHQuYXBwbHkoZXZlbnRQYXRoLnBvcCgpLCBkYXRhKSA9PT0gZmFsc2UpICYmIGpRdWVyeS5hY2NlcHREYXRhKGVsZW0pKSB7XFxuICAgICAgICAgIC8vIENhbGwgYSBuYXRpdmUgRE9NIG1ldGhvZCBvbiB0aGUgdGFyZ2V0IHdpdGggdGhlIHNhbWUgbmFtZSBuYW1lIGFzIHRoZSBldmVudC5cXG4gICAgICAgICAgLy8gRG9uJ3QgZG8gZGVmYXVsdCBhY3Rpb25zIG9uIHdpbmRvdywgdGhhdCdzIHdoZXJlIGdsb2JhbCB2YXJpYWJsZXMgYmUgKCM2MTcwKVxcbiAgICAgICAgICBpZiAob250eXBlICYmIGpRdWVyeS5pc0Z1bmN0aW9uKGVsZW1bdHlwZV0pICYmICFqUXVlcnkuaXNXaW5kb3coZWxlbSkpIHtcXG4gICAgICAgICAgICAvLyBEb24ndCByZS10cmlnZ2VyIGFuIG9uRk9PIGV2ZW50IHdoZW4gd2UgY2FsbCBpdHMgRk9PKCkgbWV0aG9kXFxuICAgICAgICAgICAgdG1wID0gZWxlbVtvbnR5cGVdO1xcblxcbiAgICAgICAgICAgIGlmICh0bXApIHtcXG4gICAgICAgICAgICAgIGVsZW1bb250eXBlXSA9IG51bGw7XFxuICAgICAgICAgICAgfSAvLyBQcmV2ZW50IHJlLXRyaWdnZXJpbmcgb2YgdGhlIHNhbWUgZXZlbnQsIHNpbmNlIHdlIGFscmVhZHkgYnViYmxlZCBpdCBhYm92ZVxcblxcblxcbiAgICAgICAgICAgIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB0eXBlO1xcbiAgICAgICAgICAgIGVsZW1bdHlwZV0oKTtcXG4gICAgICAgICAgICBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdW5kZWZpbmVkO1xcblxcbiAgICAgICAgICAgIGlmICh0bXApIHtcXG4gICAgICAgICAgICAgIGVsZW1bb250eXBlXSA9IHRtcDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIGV2ZW50LnJlc3VsdDtcXG4gICAgfSxcXG4gICAgZGlzcGF0Y2g6IGZ1bmN0aW9uIGRpc3BhdGNoKGV2ZW50KSB7XFxuICAgICAgLy8gTWFrZSBhIHdyaXRhYmxlIGpRdWVyeS5FdmVudCBmcm9tIHRoZSBuYXRpdmUgZXZlbnQgb2JqZWN0XFxuICAgICAgZXZlbnQgPSBqUXVlcnkuZXZlbnQuZml4KGV2ZW50KTtcXG5cXG4gICAgICB2YXIgaSxcXG4gICAgICAgICAgaixcXG4gICAgICAgICAgcmV0LFxcbiAgICAgICAgICBtYXRjaGVkLFxcbiAgICAgICAgICBoYW5kbGVPYmosXFxuICAgICAgICAgIGhhbmRsZXJRdWV1ZSA9IFtdLFxcbiAgICAgICAgICBhcmdzID0gX3NsaWNlLmNhbGwoYXJndW1lbnRzKSxcXG4gICAgICAgICAgaGFuZGxlcnMgPSAoZGF0YV9wcml2LmdldCh0aGlzLCBcXFwiZXZlbnRzXFxcIikgfHwge30pW2V2ZW50LnR5cGVdIHx8IFtdLFxcbiAgICAgICAgICBzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbZXZlbnQudHlwZV0gfHwge307IC8vIFVzZSB0aGUgZml4LWVkIGpRdWVyeS5FdmVudCByYXRoZXIgdGhhbiB0aGUgKHJlYWQtb25seSkgbmF0aXZlIGV2ZW50XFxuXFxuXFxuICAgICAgYXJnc1swXSA9IGV2ZW50O1xcbiAgICAgIGV2ZW50LmRlbGVnYXRlVGFyZ2V0ID0gdGhpczsgLy8gQ2FsbCB0aGUgcHJlRGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlLCBhbmQgbGV0IGl0IGJhaWwgaWYgZGVzaXJlZFxcblxcbiAgICAgIGlmIChzcGVjaWFsLnByZURpc3BhdGNoICYmIHNwZWNpYWwucHJlRGlzcGF0Y2guY2FsbCh0aGlzLCBldmVudCkgPT09IGZhbHNlKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfSAvLyBEZXRlcm1pbmUgaGFuZGxlcnNcXG5cXG5cXG4gICAgICBoYW5kbGVyUXVldWUgPSBqUXVlcnkuZXZlbnQuaGFuZGxlcnMuY2FsbCh0aGlzLCBldmVudCwgaGFuZGxlcnMpOyAvLyBSdW4gZGVsZWdhdGVzIGZpcnN0OyB0aGV5IG1heSB3YW50IHRvIHN0b3AgcHJvcGFnYXRpb24gYmVuZWF0aCB1c1xcblxcbiAgICAgIGkgPSAwO1xcblxcbiAgICAgIHdoaWxlICgobWF0Y2hlZCA9IGhhbmRsZXJRdWV1ZVtpKytdKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xcbiAgICAgICAgZXZlbnQuY3VycmVudFRhcmdldCA9IG1hdGNoZWQuZWxlbTtcXG4gICAgICAgIGogPSAwO1xcblxcbiAgICAgICAgd2hpbGUgKChoYW5kbGVPYmogPSBtYXRjaGVkLmhhbmRsZXJzW2orK10pICYmICFldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XFxuICAgICAgICAgIC8vIFRyaWdnZXJlZCBldmVudCBtdXN0IGVpdGhlciAxKSBoYXZlIG5vIG5hbWVzcGFjZSwgb3IgMikgaGF2ZSBuYW1lc3BhY2UocylcXG4gICAgICAgICAgLy8gYSBzdWJzZXQgb3IgZXF1YWwgdG8gdGhvc2UgaW4gdGhlIGJvdW5kIGV2ZW50IChib3RoIGNhbiBoYXZlIG5vIG5hbWVzcGFjZSkuXFxuICAgICAgICAgIGlmICghZXZlbnQubmFtZXNwYWNlX3JlIHx8IGV2ZW50Lm5hbWVzcGFjZV9yZS50ZXN0KGhhbmRsZU9iai5uYW1lc3BhY2UpKSB7XFxuICAgICAgICAgICAgZXZlbnQuaGFuZGxlT2JqID0gaGFuZGxlT2JqO1xcbiAgICAgICAgICAgIGV2ZW50LmRhdGEgPSBoYW5kbGVPYmouZGF0YTtcXG4gICAgICAgICAgICByZXQgPSAoKGpRdWVyeS5ldmVudC5zcGVjaWFsW2hhbmRsZU9iai5vcmlnVHlwZV0gfHwge30pLmhhbmRsZSB8fCBoYW5kbGVPYmouaGFuZGxlcikuYXBwbHkobWF0Y2hlZC5lbGVtLCBhcmdzKTtcXG5cXG4gICAgICAgICAgICBpZiAocmV0ICE9PSB1bmRlZmluZWQpIHtcXG4gICAgICAgICAgICAgIGlmICgoZXZlbnQucmVzdWx0ID0gcmV0KSA9PT0gZmFsc2UpIHtcXG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfSAvLyBDYWxsIHRoZSBwb3N0RGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlXFxuXFxuXFxuICAgICAgaWYgKHNwZWNpYWwucG9zdERpc3BhdGNoKSB7XFxuICAgICAgICBzcGVjaWFsLnBvc3REaXNwYXRjaC5jYWxsKHRoaXMsIGV2ZW50KTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIGV2ZW50LnJlc3VsdDtcXG4gICAgfSxcXG4gICAgaGFuZGxlcnM6IGZ1bmN0aW9uIGhhbmRsZXJzKGV2ZW50LCBfaGFuZGxlcnMpIHtcXG4gICAgICB2YXIgaSxcXG4gICAgICAgICAgbWF0Y2hlcyxcXG4gICAgICAgICAgc2VsLFxcbiAgICAgICAgICBoYW5kbGVPYmosXFxuICAgICAgICAgIGhhbmRsZXJRdWV1ZSA9IFtdLFxcbiAgICAgICAgICBkZWxlZ2F0ZUNvdW50ID0gX2hhbmRsZXJzLmRlbGVnYXRlQ291bnQsXFxuICAgICAgICAgIGN1ciA9IGV2ZW50LnRhcmdldDsgLy8gRmluZCBkZWxlZ2F0ZSBoYW5kbGVyc1xcbiAgICAgIC8vIEJsYWNrLWhvbGUgU1ZHIDx1c2U+IGluc3RhbmNlIHRyZWVzICgjMTMxODApXFxuICAgICAgLy8gQXZvaWQgbm9uLWxlZnQtY2xpY2sgYnViYmxpbmcgaW4gRmlyZWZveCAoIzM4NjEpXFxuXFxuICAgICAgaWYgKGRlbGVnYXRlQ291bnQgJiYgY3VyLm5vZGVUeXBlICYmICghZXZlbnQuYnV0dG9uIHx8IGV2ZW50LnR5cGUgIT09IFxcXCJjbGlja1xcXCIpKSB7XFxuICAgICAgICBmb3IgKDsgY3VyICE9PSB0aGlzOyBjdXIgPSBjdXIucGFyZW50Tm9kZSB8fCB0aGlzKSB7XFxuICAgICAgICAgIC8vIERvbid0IHByb2Nlc3MgY2xpY2tzIG9uIGRpc2FibGVkIGVsZW1lbnRzICgjNjkxMSwgIzgxNjUsICMxMTM4MiwgIzExNzY0KVxcbiAgICAgICAgICBpZiAoY3VyLmRpc2FibGVkICE9PSB0cnVlIHx8IGV2ZW50LnR5cGUgIT09IFxcXCJjbGlja1xcXCIpIHtcXG4gICAgICAgICAgICBtYXRjaGVzID0gW107XFxuXFxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGRlbGVnYXRlQ291bnQ7IGkrKykge1xcbiAgICAgICAgICAgICAgaGFuZGxlT2JqID0gX2hhbmRsZXJzW2ldOyAvLyBEb24ndCBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoIzEzMjAzKVxcblxcbiAgICAgICAgICAgICAgc2VsID0gaGFuZGxlT2JqLnNlbGVjdG9yICsgXFxcIiBcXFwiO1xcblxcbiAgICAgICAgICAgICAgaWYgKG1hdGNoZXNbc2VsXSA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgICAgICAgIG1hdGNoZXNbc2VsXSA9IGhhbmRsZU9iai5uZWVkc0NvbnRleHQgPyBqUXVlcnkoc2VsLCB0aGlzKS5pbmRleChjdXIpID49IDAgOiBqUXVlcnkuZmluZChzZWwsIHRoaXMsIG51bGwsIFtjdXJdKS5sZW5ndGg7XFxuICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICBpZiAobWF0Y2hlc1tzZWxdKSB7XFxuICAgICAgICAgICAgICAgIG1hdGNoZXMucHVzaChoYW5kbGVPYmopO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpZiAobWF0Y2hlcy5sZW5ndGgpIHtcXG4gICAgICAgICAgICAgIGhhbmRsZXJRdWV1ZS5wdXNoKHtcXG4gICAgICAgICAgICAgICAgZWxlbTogY3VyLFxcbiAgICAgICAgICAgICAgICBoYW5kbGVyczogbWF0Y2hlc1xcbiAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfSAvLyBBZGQgdGhlIHJlbWFpbmluZyAoZGlyZWN0bHktYm91bmQpIGhhbmRsZXJzXFxuXFxuXFxuICAgICAgaWYgKGRlbGVnYXRlQ291bnQgPCBfaGFuZGxlcnMubGVuZ3RoKSB7XFxuICAgICAgICBoYW5kbGVyUXVldWUucHVzaCh7XFxuICAgICAgICAgIGVsZW06IHRoaXMsXFxuICAgICAgICAgIGhhbmRsZXJzOiBfaGFuZGxlcnMuc2xpY2UoZGVsZWdhdGVDb3VudClcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gaGFuZGxlclF1ZXVlO1xcbiAgICB9LFxcbiAgICAvLyBJbmNsdWRlcyBzb21lIGV2ZW50IHByb3BzIHNoYXJlZCBieSBLZXlFdmVudCBhbmQgTW91c2VFdmVudFxcbiAgICBwcm9wczogXFxcImFsdEtleSBidWJibGVzIGNhbmNlbGFibGUgY3RybEtleSBjdXJyZW50VGFyZ2V0IGV2ZW50UGhhc2UgbWV0YUtleSByZWxhdGVkVGFyZ2V0IHNoaWZ0S2V5IHRhcmdldCB0aW1lU3RhbXAgdmlldyB3aGljaFxcXCIuc3BsaXQoXFxcIiBcXFwiKSxcXG4gICAgZml4SG9va3M6IHt9LFxcbiAgICBrZXlIb29rczoge1xcbiAgICAgIHByb3BzOiBcXFwiY2hhciBjaGFyQ29kZSBrZXkga2V5Q29kZVxcXCIuc3BsaXQoXFxcIiBcXFwiKSxcXG4gICAgICBmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcihldmVudCwgb3JpZ2luYWwpIHtcXG4gICAgICAgIC8vIEFkZCB3aGljaCBmb3Iga2V5IGV2ZW50c1xcbiAgICAgICAgaWYgKGV2ZW50LndoaWNoID09IG51bGwpIHtcXG4gICAgICAgICAgZXZlbnQud2hpY2ggPSBvcmlnaW5hbC5jaGFyQ29kZSAhPSBudWxsID8gb3JpZ2luYWwuY2hhckNvZGUgOiBvcmlnaW5hbC5rZXlDb2RlO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIGV2ZW50O1xcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgbW91c2VIb29rczoge1xcbiAgICAgIHByb3BzOiBcXFwiYnV0dG9uIGJ1dHRvbnMgY2xpZW50WCBjbGllbnRZIG9mZnNldFggb2Zmc2V0WSBwYWdlWCBwYWdlWSBzY3JlZW5YIHNjcmVlblkgdG9FbGVtZW50XFxcIi5zcGxpdChcXFwiIFxcXCIpLFxcbiAgICAgIGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKGV2ZW50LCBvcmlnaW5hbCkge1xcbiAgICAgICAgdmFyIGV2ZW50RG9jLFxcbiAgICAgICAgICAgIGRvYyxcXG4gICAgICAgICAgICBib2R5LFxcbiAgICAgICAgICAgIGJ1dHRvbiA9IG9yaWdpbmFsLmJ1dHRvbjsgLy8gQ2FsY3VsYXRlIHBhZ2VYL1kgaWYgbWlzc2luZyBhbmQgY2xpZW50WC9ZIGF2YWlsYWJsZVxcblxcbiAgICAgICAgaWYgKGV2ZW50LnBhZ2VYID09IG51bGwgJiYgb3JpZ2luYWwuY2xpZW50WCAhPSBudWxsKSB7XFxuICAgICAgICAgIGV2ZW50RG9jID0gZXZlbnQudGFyZ2V0Lm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQ7XFxuICAgICAgICAgIGRvYyA9IGV2ZW50RG9jLmRvY3VtZW50RWxlbWVudDtcXG4gICAgICAgICAgYm9keSA9IGV2ZW50RG9jLmJvZHk7XFxuICAgICAgICAgIGV2ZW50LnBhZ2VYID0gb3JpZ2luYWwuY2xpZW50WCArIChkb2MgJiYgZG9jLnNjcm9sbExlZnQgfHwgYm9keSAmJiBib2R5LnNjcm9sbExlZnQgfHwgMCkgLSAoZG9jICYmIGRvYy5jbGllbnRMZWZ0IHx8IGJvZHkgJiYgYm9keS5jbGllbnRMZWZ0IHx8IDApO1xcbiAgICAgICAgICBldmVudC5wYWdlWSA9IG9yaWdpbmFsLmNsaWVudFkgKyAoZG9jICYmIGRvYy5zY3JvbGxUb3AgfHwgYm9keSAmJiBib2R5LnNjcm9sbFRvcCB8fCAwKSAtIChkb2MgJiYgZG9jLmNsaWVudFRvcCB8fCBib2R5ICYmIGJvZHkuY2xpZW50VG9wIHx8IDApO1xcbiAgICAgICAgfSAvLyBBZGQgd2hpY2ggZm9yIGNsaWNrOiAxID09PSBsZWZ0OyAyID09PSBtaWRkbGU7IDMgPT09IHJpZ2h0XFxuICAgICAgICAvLyBOb3RlOiBidXR0b24gaXMgbm90IG5vcm1hbGl6ZWQsIHNvIGRvbid0IHVzZSBpdFxcblxcblxcbiAgICAgICAgaWYgKCFldmVudC53aGljaCAmJiBidXR0b24gIT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgICBldmVudC53aGljaCA9IGJ1dHRvbiAmIDEgPyAxIDogYnV0dG9uICYgMiA/IDMgOiBidXR0b24gJiA0ID8gMiA6IDA7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gZXZlbnQ7XFxuICAgICAgfVxcbiAgICB9LFxcbiAgICBmaXg6IGZ1bmN0aW9uIGZpeChldmVudCkge1xcbiAgICAgIGlmIChldmVudFtqUXVlcnkuZXhwYW5kb10pIHtcXG4gICAgICAgIHJldHVybiBldmVudDtcXG4gICAgICB9IC8vIENyZWF0ZSBhIHdyaXRhYmxlIGNvcHkgb2YgdGhlIGV2ZW50IG9iamVjdCBhbmQgbm9ybWFsaXplIHNvbWUgcHJvcGVydGllc1xcblxcblxcbiAgICAgIHZhciBpLFxcbiAgICAgICAgICBwcm9wLFxcbiAgICAgICAgICBjb3B5LFxcbiAgICAgICAgICB0eXBlID0gZXZlbnQudHlwZSxcXG4gICAgICAgICAgb3JpZ2luYWxFdmVudCA9IGV2ZW50LFxcbiAgICAgICAgICBmaXhIb29rID0gdGhpcy5maXhIb29rc1t0eXBlXTtcXG5cXG4gICAgICBpZiAoIWZpeEhvb2spIHtcXG4gICAgICAgIHRoaXMuZml4SG9va3NbdHlwZV0gPSBmaXhIb29rID0gcm1vdXNlRXZlbnQudGVzdCh0eXBlKSA/IHRoaXMubW91c2VIb29rcyA6IHJrZXlFdmVudC50ZXN0KHR5cGUpID8gdGhpcy5rZXlIb29rcyA6IHt9O1xcbiAgICAgIH1cXG5cXG4gICAgICBjb3B5ID0gZml4SG9vay5wcm9wcyA/IHRoaXMucHJvcHMuY29uY2F0KGZpeEhvb2sucHJvcHMpIDogdGhpcy5wcm9wcztcXG4gICAgICBldmVudCA9IG5ldyBqUXVlcnkuRXZlbnQob3JpZ2luYWxFdmVudCk7XFxuICAgICAgaSA9IGNvcHkubGVuZ3RoO1xcblxcbiAgICAgIHdoaWxlIChpLS0pIHtcXG4gICAgICAgIHByb3AgPSBjb3B5W2ldO1xcbiAgICAgICAgZXZlbnRbcHJvcF0gPSBvcmlnaW5hbEV2ZW50W3Byb3BdO1xcbiAgICAgIH0gLy8gU3VwcG9ydDogQ29yZG92YSAyLjUgKFdlYktpdCkgKCMxMzI1NSlcXG4gICAgICAvLyBBbGwgZXZlbnRzIHNob3VsZCBoYXZlIGEgdGFyZ2V0OyBDb3Jkb3ZhIGRldmljZXJlYWR5IGRvZXNuJ3RcXG5cXG5cXG4gICAgICBpZiAoIWV2ZW50LnRhcmdldCkge1xcbiAgICAgICAgZXZlbnQudGFyZ2V0ID0gZG9jdW1lbnQ7XFxuICAgICAgfSAvLyBTdXBwb3J0OiBTYWZhcmkgNi4wKywgQ2hyb21lPDI4XFxuICAgICAgLy8gVGFyZ2V0IHNob3VsZCBub3QgYmUgYSB0ZXh0IG5vZGUgKCM1MDQsICMxMzE0MylcXG5cXG5cXG4gICAgICBpZiAoZXZlbnQudGFyZ2V0Lm5vZGVUeXBlID09PSAzKSB7XFxuICAgICAgICBldmVudC50YXJnZXQgPSBldmVudC50YXJnZXQucGFyZW50Tm9kZTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIGZpeEhvb2suZmlsdGVyID8gZml4SG9vay5maWx0ZXIoZXZlbnQsIG9yaWdpbmFsRXZlbnQpIDogZXZlbnQ7XFxuICAgIH0sXFxuICAgIHNwZWNpYWw6IHtcXG4gICAgICBsb2FkOiB7XFxuICAgICAgICAvLyBQcmV2ZW50IHRyaWdnZXJlZCBpbWFnZS5sb2FkIGV2ZW50cyBmcm9tIGJ1YmJsaW5nIHRvIHdpbmRvdy5sb2FkXFxuICAgICAgICBub0J1YmJsZTogdHJ1ZVxcbiAgICAgIH0sXFxuICAgICAgZm9jdXM6IHtcXG4gICAgICAgIC8vIEZpcmUgbmF0aXZlIGV2ZW50IGlmIHBvc3NpYmxlIHNvIGJsdXIvZm9jdXMgc2VxdWVuY2UgaXMgY29ycmVjdFxcbiAgICAgICAgdHJpZ2dlcjogZnVuY3Rpb24gdHJpZ2dlcigpIHtcXG4gICAgICAgICAgaWYgKHRoaXMgIT09IHNhZmVBY3RpdmVFbGVtZW50KCkgJiYgdGhpcy5mb2N1cykge1xcbiAgICAgICAgICAgIHRoaXMuZm9jdXMoKTtcXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuICAgICAgICBkZWxlZ2F0ZVR5cGU6IFxcXCJmb2N1c2luXFxcIlxcbiAgICAgIH0sXFxuICAgICAgYmx1cjoge1xcbiAgICAgICAgdHJpZ2dlcjogZnVuY3Rpb24gdHJpZ2dlcigpIHtcXG4gICAgICAgICAgaWYgKHRoaXMgPT09IHNhZmVBY3RpdmVFbGVtZW50KCkgJiYgdGhpcy5ibHVyKSB7XFxuICAgICAgICAgICAgdGhpcy5ibHVyKCk7XFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgZGVsZWdhdGVUeXBlOiBcXFwiZm9jdXNvdXRcXFwiXFxuICAgICAgfSxcXG4gICAgICBjbGljazoge1xcbiAgICAgICAgLy8gRm9yIGNoZWNrYm94LCBmaXJlIG5hdGl2ZSBldmVudCBzbyBjaGVja2VkIHN0YXRlIHdpbGwgYmUgcmlnaHRcXG4gICAgICAgIHRyaWdnZXI6IGZ1bmN0aW9uIHRyaWdnZXIoKSB7XFxuICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09IFxcXCJjaGVja2JveFxcXCIgJiYgdGhpcy5jbGljayAmJiBqUXVlcnkubm9kZU5hbWUodGhpcywgXFxcImlucHV0XFxcIikpIHtcXG4gICAgICAgICAgICB0aGlzLmNsaWNrKCk7XFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgLy8gRm9yIGNyb3NzLWJyb3dzZXIgY29uc2lzdGVuY3ksIGRvbid0IGZpcmUgbmF0aXZlIC5jbGljaygpIG9uIGxpbmtzXFxuICAgICAgICBfZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoZXZlbnQpIHtcXG4gICAgICAgICAgcmV0dXJuIGpRdWVyeS5ub2RlTmFtZShldmVudC50YXJnZXQsIFxcXCJhXFxcIik7XFxuICAgICAgICB9XFxuICAgICAgfSxcXG4gICAgICBiZWZvcmV1bmxvYWQ6IHtcXG4gICAgICAgIHBvc3REaXNwYXRjaDogZnVuY3Rpb24gcG9zdERpc3BhdGNoKGV2ZW50KSB7XFxuICAgICAgICAgIC8vIFN1cHBvcnQ6IEZpcmVmb3ggMjArXFxuICAgICAgICAgIC8vIEZpcmVmb3ggZG9lc24ndCBhbGVydCBpZiB0aGUgcmV0dXJuVmFsdWUgZmllbGQgaXMgbm90IHNldC5cXG4gICAgICAgICAgaWYgKGV2ZW50LnJlc3VsdCAhPT0gdW5kZWZpbmVkICYmIGV2ZW50Lm9yaWdpbmFsRXZlbnQpIHtcXG4gICAgICAgICAgICBldmVudC5vcmlnaW5hbEV2ZW50LnJldHVyblZhbHVlID0gZXZlbnQucmVzdWx0O1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9LFxcbiAgICBzaW11bGF0ZTogZnVuY3Rpb24gc2ltdWxhdGUodHlwZSwgZWxlbSwgZXZlbnQsIGJ1YmJsZSkge1xcbiAgICAgIC8vIFBpZ2d5YmFjayBvbiBhIGRvbm9yIGV2ZW50IHRvIHNpbXVsYXRlIGEgZGlmZmVyZW50IG9uZS5cXG4gICAgICAvLyBGYWtlIG9yaWdpbmFsRXZlbnQgdG8gYXZvaWQgZG9ub3IncyBzdG9wUHJvcGFnYXRpb24sIGJ1dCBpZiB0aGVcXG4gICAgICAvLyBzaW11bGF0ZWQgZXZlbnQgcHJldmVudHMgZGVmYXVsdCB0aGVuIHdlIGRvIHRoZSBzYW1lIG9uIHRoZSBkb25vci5cXG4gICAgICB2YXIgZSA9IGpRdWVyeS5leHRlbmQobmV3IGpRdWVyeS5FdmVudCgpLCBldmVudCwge1xcbiAgICAgICAgdHlwZTogdHlwZSxcXG4gICAgICAgIGlzU2ltdWxhdGVkOiB0cnVlLFxcbiAgICAgICAgb3JpZ2luYWxFdmVudDoge31cXG4gICAgICB9KTtcXG5cXG4gICAgICBpZiAoYnViYmxlKSB7XFxuICAgICAgICBqUXVlcnkuZXZlbnQudHJpZ2dlcihlLCBudWxsLCBlbGVtKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgalF1ZXJ5LmV2ZW50LmRpc3BhdGNoLmNhbGwoZWxlbSwgZSk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChlLmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XFxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfTtcXG5cXG4gIGpRdWVyeS5yZW1vdmVFdmVudCA9IGZ1bmN0aW9uIChlbGVtLCB0eXBlLCBoYW5kbGUpIHtcXG4gICAgaWYgKGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xcbiAgICAgIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGUsIGZhbHNlKTtcXG4gICAgfVxcbiAgfTtcXG5cXG4gIGpRdWVyeS5FdmVudCA9IGZ1bmN0aW9uIChzcmMsIHByb3BzKSB7XFxuICAgIC8vIEFsbG93IGluc3RhbnRpYXRpb24gd2l0aG91dCB0aGUgJ25ldycga2V5d29yZFxcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgalF1ZXJ5LkV2ZW50KSkge1xcbiAgICAgIHJldHVybiBuZXcgalF1ZXJ5LkV2ZW50KHNyYywgcHJvcHMpO1xcbiAgICB9IC8vIEV2ZW50IG9iamVjdFxcblxcblxcbiAgICBpZiAoc3JjICYmIHNyYy50eXBlKSB7XFxuICAgICAgdGhpcy5vcmlnaW5hbEV2ZW50ID0gc3JjO1xcbiAgICAgIHRoaXMudHlwZSA9IHNyYy50eXBlOyAvLyBFdmVudHMgYnViYmxpbmcgdXAgdGhlIGRvY3VtZW50IG1heSBoYXZlIGJlZW4gbWFya2VkIGFzIHByZXZlbnRlZFxcbiAgICAgIC8vIGJ5IGEgaGFuZGxlciBsb3dlciBkb3duIHRoZSB0cmVlOyByZWZsZWN0IHRoZSBjb3JyZWN0IHZhbHVlLlxcblxcbiAgICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gc3JjLmRlZmF1bHRQcmV2ZW50ZWQgfHwgc3JjLmRlZmF1bHRQcmV2ZW50ZWQgPT09IHVuZGVmaW5lZCAmJiAvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMFxcbiAgICAgIHNyYy5yZXR1cm5WYWx1ZSA9PT0gZmFsc2UgPyByZXR1cm5UcnVlIDogcmV0dXJuRmFsc2U7IC8vIEV2ZW50IHR5cGVcXG4gICAgfSBlbHNlIHtcXG4gICAgICB0aGlzLnR5cGUgPSBzcmM7XFxuICAgIH0gLy8gUHV0IGV4cGxpY2l0bHkgcHJvdmlkZWQgcHJvcGVydGllcyBvbnRvIHRoZSBldmVudCBvYmplY3RcXG5cXG5cXG4gICAgaWYgKHByb3BzKSB7XFxuICAgICAgalF1ZXJ5LmV4dGVuZCh0aGlzLCBwcm9wcyk7XFxuICAgIH0gLy8gQ3JlYXRlIGEgdGltZXN0YW1wIGlmIGluY29taW5nIGV2ZW50IGRvZXNuJ3QgaGF2ZSBvbmVcXG5cXG5cXG4gICAgdGhpcy50aW1lU3RhbXAgPSBzcmMgJiYgc3JjLnRpbWVTdGFtcCB8fCBqUXVlcnkubm93KCk7IC8vIE1hcmsgaXQgYXMgZml4ZWRcXG5cXG4gICAgdGhpc1tqUXVlcnkuZXhwYW5kb10gPSB0cnVlO1xcbiAgfTsgLy8galF1ZXJ5LkV2ZW50IGlzIGJhc2VkIG9uIERPTTMgRXZlbnRzIGFzIHNwZWNpZmllZCBieSB0aGUgRUNNQVNjcmlwdCBMYW5ndWFnZSBCaW5kaW5nXFxuICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDAzMDMzMS9lY21hLXNjcmlwdC1iaW5kaW5nLmh0bWxcXG5cXG5cXG4gIGpRdWVyeS5FdmVudC5wcm90b3R5cGUgPSB7XFxuICAgIGlzRGVmYXVsdFByZXZlbnRlZDogcmV0dXJuRmFsc2UsXFxuICAgIGlzUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcXG4gICAgaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxcbiAgICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gcHJldmVudERlZmF1bHQoKSB7XFxuICAgICAgdmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XFxuICAgICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSByZXR1cm5UcnVlO1xcblxcbiAgICAgIGlmIChlICYmIGUucHJldmVudERlZmF1bHQpIHtcXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uKCkge1xcbiAgICAgIHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xcbiAgICAgIHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xcblxcbiAgICAgIGlmIChlICYmIGUuc3RvcFByb3BhZ2F0aW9uKSB7XFxuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOiBmdW5jdGlvbiBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSB7XFxuICAgICAgdmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XFxuICAgICAgdGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XFxuXFxuICAgICAgaWYgKGUgJiYgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24pIHtcXG4gICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XFxuICAgIH1cXG4gIH07IC8vIENyZWF0ZSBtb3VzZWVudGVyL2xlYXZlIGV2ZW50cyB1c2luZyBtb3VzZW92ZXIvb3V0IGFuZCBldmVudC10aW1lIGNoZWNrc1xcbiAgLy8gU3VwcG9ydDogQ2hyb21lIDE1K1xcblxcbiAgalF1ZXJ5LmVhY2goe1xcbiAgICBtb3VzZWVudGVyOiBcXFwibW91c2VvdmVyXFxcIixcXG4gICAgbW91c2VsZWF2ZTogXFxcIm1vdXNlb3V0XFxcIixcXG4gICAgcG9pbnRlcmVudGVyOiBcXFwicG9pbnRlcm92ZXJcXFwiLFxcbiAgICBwb2ludGVybGVhdmU6IFxcXCJwb2ludGVyb3V0XFxcIlxcbiAgfSwgZnVuY3Rpb24gKG9yaWcsIGZpeCkge1xcbiAgICBqUXVlcnkuZXZlbnQuc3BlY2lhbFtvcmlnXSA9IHtcXG4gICAgICBkZWxlZ2F0ZVR5cGU6IGZpeCxcXG4gICAgICBiaW5kVHlwZTogZml4LFxcbiAgICAgIGhhbmRsZTogZnVuY3Rpb24gaGFuZGxlKGV2ZW50KSB7XFxuICAgICAgICB2YXIgcmV0LFxcbiAgICAgICAgICAgIHRhcmdldCA9IHRoaXMsXFxuICAgICAgICAgICAgcmVsYXRlZCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQsXFxuICAgICAgICAgICAgaGFuZGxlT2JqID0gZXZlbnQuaGFuZGxlT2JqOyAvLyBGb3IgbW91c2VudGVyL2xlYXZlIGNhbGwgdGhlIGhhbmRsZXIgaWYgcmVsYXRlZCBpcyBvdXRzaWRlIHRoZSB0YXJnZXQuXFxuICAgICAgICAvLyBOQjogTm8gcmVsYXRlZFRhcmdldCBpZiB0aGUgbW91c2UgbGVmdC9lbnRlcmVkIHRoZSBicm93c2VyIHdpbmRvd1xcblxcbiAgICAgICAgaWYgKCFyZWxhdGVkIHx8IHJlbGF0ZWQgIT09IHRhcmdldCAmJiAhalF1ZXJ5LmNvbnRhaW5zKHRhcmdldCwgcmVsYXRlZCkpIHtcXG4gICAgICAgICAgZXZlbnQudHlwZSA9IGhhbmRsZU9iai5vcmlnVHlwZTtcXG4gICAgICAgICAgcmV0ID0gaGFuZGxlT2JqLmhhbmRsZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gICAgICAgICAgZXZlbnQudHlwZSA9IGZpeDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiByZXQ7XFxuICAgICAgfVxcbiAgICB9O1xcbiAgfSk7IC8vIFN1cHBvcnQ6IEZpcmVmb3gsIENocm9tZSwgU2FmYXJpXFxuICAvLyBDcmVhdGUgXFxcImJ1YmJsaW5nXFxcIiBmb2N1cyBhbmQgYmx1ciBldmVudHNcXG5cXG4gIGlmICghc3VwcG9ydC5mb2N1c2luQnViYmxlcykge1xcbiAgICBqUXVlcnkuZWFjaCh7XFxuICAgICAgZm9jdXM6IFxcXCJmb2N1c2luXFxcIixcXG4gICAgICBibHVyOiBcXFwiZm9jdXNvdXRcXFwiXFxuICAgIH0sIGZ1bmN0aW9uIChvcmlnLCBmaXgpIHtcXG4gICAgICAvLyBBdHRhY2ggYSBzaW5nbGUgY2FwdHVyaW5nIGhhbmRsZXIgb24gdGhlIGRvY3VtZW50IHdoaWxlIHNvbWVvbmUgd2FudHMgZm9jdXNpbi9mb2N1c291dFxcbiAgICAgIHZhciBoYW5kbGVyID0gZnVuY3Rpb24gaGFuZGxlcihldmVudCkge1xcbiAgICAgICAgalF1ZXJ5LmV2ZW50LnNpbXVsYXRlKGZpeCwgZXZlbnQudGFyZ2V0LCBqUXVlcnkuZXZlbnQuZml4KGV2ZW50KSwgdHJ1ZSk7XFxuICAgICAgfTtcXG5cXG4gICAgICBqUXVlcnkuZXZlbnQuc3BlY2lhbFtmaXhdID0ge1xcbiAgICAgICAgc2V0dXA6IGZ1bmN0aW9uIHNldHVwKCkge1xcbiAgICAgICAgICB2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXFxuICAgICAgICAgICAgICBhdHRhY2hlcyA9IGRhdGFfcHJpdi5hY2Nlc3MoZG9jLCBmaXgpO1xcblxcbiAgICAgICAgICBpZiAoIWF0dGFjaGVzKSB7XFxuICAgICAgICAgICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIob3JpZywgaGFuZGxlciwgdHJ1ZSk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZGF0YV9wcml2LmFjY2Vzcyhkb2MsIGZpeCwgKGF0dGFjaGVzIHx8IDApICsgMSk7XFxuICAgICAgICB9LFxcbiAgICAgICAgdGVhcmRvd246IGZ1bmN0aW9uIHRlYXJkb3duKCkge1xcbiAgICAgICAgICB2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXFxuICAgICAgICAgICAgICBhdHRhY2hlcyA9IGRhdGFfcHJpdi5hY2Nlc3MoZG9jLCBmaXgpIC0gMTtcXG5cXG4gICAgICAgICAgaWYgKCFhdHRhY2hlcykge1xcbiAgICAgICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKG9yaWcsIGhhbmRsZXIsIHRydWUpO1xcbiAgICAgICAgICAgIGRhdGFfcHJpdi5yZW1vdmUoZG9jLCBmaXgpO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGRhdGFfcHJpdi5hY2Nlc3MoZG9jLCBmaXgsIGF0dGFjaGVzKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgIH0pO1xcbiAgfVxcblxcbiAgalF1ZXJ5LmZuLmV4dGVuZCh7XFxuICAgIG9uOiBmdW5jdGlvbiBvbih0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLFxcbiAgICAvKklOVEVSTkFMKi9cXG4gICAgb25lKSB7XFxuICAgICAgdmFyIG9yaWdGbiwgdHlwZTsgLy8gVHlwZXMgY2FuIGJlIGEgbWFwIG9mIHR5cGVzL2hhbmRsZXJzXFxuXFxuICAgICAgaWYgKF90eXBlb2YodHlwZXMpID09PSBcXFwib2JqZWN0XFxcIikge1xcbiAgICAgICAgLy8gKCB0eXBlcy1PYmplY3QsIHNlbGVjdG9yLCBkYXRhIClcXG4gICAgICAgIGlmICh0eXBlb2Ygc2VsZWN0b3IgIT09IFxcXCJzdHJpbmdcXFwiKSB7XFxuICAgICAgICAgIC8vICggdHlwZXMtT2JqZWN0LCBkYXRhIClcXG4gICAgICAgICAgZGF0YSA9IGRhdGEgfHwgc2VsZWN0b3I7XFxuICAgICAgICAgIHNlbGVjdG9yID0gdW5kZWZpbmVkO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZm9yICh0eXBlIGluIHR5cGVzKSB7XFxuICAgICAgICAgIHRoaXMub24odHlwZSwgc2VsZWN0b3IsIGRhdGEsIHR5cGVzW3R5cGVdLCBvbmUpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIHRoaXM7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChkYXRhID09IG51bGwgJiYgZm4gPT0gbnVsbCkge1xcbiAgICAgICAgLy8gKCB0eXBlcywgZm4gKVxcbiAgICAgICAgZm4gPSBzZWxlY3RvcjtcXG4gICAgICAgIGRhdGEgPSBzZWxlY3RvciA9IHVuZGVmaW5lZDtcXG4gICAgICB9IGVsc2UgaWYgKGZuID09IG51bGwpIHtcXG4gICAgICAgIGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09IFxcXCJzdHJpbmdcXFwiKSB7XFxuICAgICAgICAgIC8vICggdHlwZXMsIHNlbGVjdG9yLCBmbiApXFxuICAgICAgICAgIGZuID0gZGF0YTtcXG4gICAgICAgICAgZGF0YSA9IHVuZGVmaW5lZDtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIC8vICggdHlwZXMsIGRhdGEsIGZuIClcXG4gICAgICAgICAgZm4gPSBkYXRhO1xcbiAgICAgICAgICBkYXRhID0gc2VsZWN0b3I7XFxuICAgICAgICAgIHNlbGVjdG9yID0gdW5kZWZpbmVkO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoZm4gPT09IGZhbHNlKSB7XFxuICAgICAgICBmbiA9IHJldHVybkZhbHNlO1xcbiAgICAgIH0gZWxzZSBpZiAoIWZuKSB7XFxuICAgICAgICByZXR1cm4gdGhpcztcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKG9uZSA9PT0gMSkge1xcbiAgICAgICAgb3JpZ0ZuID0gZm47XFxuXFxuICAgICAgICBmbiA9IGZ1bmN0aW9uIGZuKGV2ZW50KSB7XFxuICAgICAgICAgIC8vIENhbiB1c2UgYW4gZW1wdHkgc2V0LCBzaW5jZSBldmVudCBjb250YWlucyB0aGUgaW5mb1xcbiAgICAgICAgICBqUXVlcnkoKS5vZmYoZXZlbnQpO1xcbiAgICAgICAgICByZXR1cm4gb3JpZ0ZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICAgICAgICB9OyAvLyBVc2Ugc2FtZSBndWlkIHNvIGNhbGxlciBjYW4gcmVtb3ZlIHVzaW5nIG9yaWdGblxcblxcblxcbiAgICAgICAgZm4uZ3VpZCA9IG9yaWdGbi5ndWlkIHx8IChvcmlnRm4uZ3VpZCA9IGpRdWVyeS5ndWlkKyspO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGpRdWVyeS5ldmVudC5hZGQodGhpcywgdHlwZXMsIGZuLCBkYXRhLCBzZWxlY3Rvcik7XFxuICAgICAgfSk7XFxuICAgIH0sXFxuICAgIG9uZTogZnVuY3Rpb24gb25lKHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4pIHtcXG4gICAgICByZXR1cm4gdGhpcy5vbih0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCAxKTtcXG4gICAgfSxcXG4gICAgb2ZmOiBmdW5jdGlvbiBvZmYodHlwZXMsIHNlbGVjdG9yLCBmbikge1xcbiAgICAgIHZhciBoYW5kbGVPYmosIHR5cGU7XFxuXFxuICAgICAgaWYgKHR5cGVzICYmIHR5cGVzLnByZXZlbnREZWZhdWx0ICYmIHR5cGVzLmhhbmRsZU9iaikge1xcbiAgICAgICAgLy8gKCBldmVudCApICBkaXNwYXRjaGVkIGpRdWVyeS5FdmVudFxcbiAgICAgICAgaGFuZGxlT2JqID0gdHlwZXMuaGFuZGxlT2JqO1xcbiAgICAgICAgalF1ZXJ5KHR5cGVzLmRlbGVnYXRlVGFyZ2V0KS5vZmYoaGFuZGxlT2JqLm5hbWVzcGFjZSA/IGhhbmRsZU9iai5vcmlnVHlwZSArIFxcXCIuXFxcIiArIGhhbmRsZU9iai5uYW1lc3BhY2UgOiBoYW5kbGVPYmoub3JpZ1R5cGUsIGhhbmRsZU9iai5zZWxlY3RvciwgaGFuZGxlT2JqLmhhbmRsZXIpO1xcbiAgICAgICAgcmV0dXJuIHRoaXM7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChfdHlwZW9mKHR5cGVzKSA9PT0gXFxcIm9iamVjdFxcXCIpIHtcXG4gICAgICAgIC8vICggdHlwZXMtb2JqZWN0IFssIHNlbGVjdG9yXSApXFxuICAgICAgICBmb3IgKHR5cGUgaW4gdHlwZXMpIHtcXG4gICAgICAgICAgdGhpcy5vZmYodHlwZSwgc2VsZWN0b3IsIHR5cGVzW3R5cGVdKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiB0aGlzO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoc2VsZWN0b3IgPT09IGZhbHNlIHx8IHR5cGVvZiBzZWxlY3RvciA9PT0gXFxcImZ1bmN0aW9uXFxcIikge1xcbiAgICAgICAgLy8gKCB0eXBlcyBbLCBmbl0gKVxcbiAgICAgICAgZm4gPSBzZWxlY3RvcjtcXG4gICAgICAgIHNlbGVjdG9yID0gdW5kZWZpbmVkO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoZm4gPT09IGZhbHNlKSB7XFxuICAgICAgICBmbiA9IHJldHVybkZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGpRdWVyeS5ldmVudC5yZW1vdmUodGhpcywgdHlwZXMsIGZuLCBzZWxlY3Rvcik7XFxuICAgICAgfSk7XFxuICAgIH0sXFxuICAgIHRyaWdnZXI6IGZ1bmN0aW9uIHRyaWdnZXIodHlwZSwgZGF0YSkge1xcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgalF1ZXJ5LmV2ZW50LnRyaWdnZXIodHlwZSwgZGF0YSwgdGhpcyk7XFxuICAgICAgfSk7XFxuICAgIH0sXFxuICAgIHRyaWdnZXJIYW5kbGVyOiBmdW5jdGlvbiB0cmlnZ2VySGFuZGxlcih0eXBlLCBkYXRhKSB7XFxuICAgICAgdmFyIGVsZW0gPSB0aGlzWzBdO1xcblxcbiAgICAgIGlmIChlbGVtKSB7XFxuICAgICAgICByZXR1cm4galF1ZXJ5LmV2ZW50LnRyaWdnZXIodHlwZSwgZGF0YSwgZWxlbSwgdHJ1ZSk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9KTtcXG4gIHZhciByeGh0bWxUYWcgPSAvPCg/IWFyZWF8YnJ8Y29sfGVtYmVkfGhyfGltZ3xpbnB1dHxsaW5rfG1ldGF8cGFyYW0pKChbXFxcXHc6XSspW14+XSopXFxcXC8+L2dpLFxcbiAgICAgIHJ0YWdOYW1lID0gLzwoW1xcXFx3Ol0rKS8sXFxuICAgICAgcmh0bWwgPSAvPHwmIz9cXFxcdys7LyxcXG4gICAgICBybm9Jbm5lcmh0bWwgPSAvPCg/OnNjcmlwdHxzdHlsZXxsaW5rKS9pLFxcbiAgICAgIC8vIGNoZWNrZWQ9XFxcImNoZWNrZWRcXFwiIG9yIGNoZWNrZWRcXG4gIHJjaGVja2VkID0gL2NoZWNrZWRcXFxccyooPzpbXj1dfD1cXFxccyouY2hlY2tlZC4pL2ksXFxuICAgICAgcnNjcmlwdFR5cGUgPSAvXiR8XFxcXC8oPzpqYXZhfGVjbWEpc2NyaXB0L2ksXFxuICAgICAgcnNjcmlwdFR5cGVNYXNrZWQgPSAvXnRydWVcXFxcLyguKikvLFxcbiAgICAgIHJjbGVhblNjcmlwdCA9IC9eXFxcXHMqPCEoPzpcXFxcW0NEQVRBXFxcXFt8LS0pfCg/OlxcXFxdXFxcXF18LS0pPlxcXFxzKiQvZyxcXG4gICAgICAvLyBXZSBoYXZlIHRvIGNsb3NlIHRoZXNlIHRhZ3MgdG8gc3VwcG9ydCBYSFRNTCAoIzEzMjAwKVxcbiAgd3JhcE1hcCA9IHtcXG4gICAgLy8gU3VwcG9ydDogSUU5XFxuICAgIG9wdGlvbjogWzEsIFxcXCI8c2VsZWN0IG11bHRpcGxlPSdtdWx0aXBsZSc+XFxcIiwgXFxcIjwvc2VsZWN0PlxcXCJdLFxcbiAgICB0aGVhZDogWzEsIFxcXCI8dGFibGU+XFxcIiwgXFxcIjwvdGFibGU+XFxcIl0sXFxuICAgIGNvbDogWzIsIFxcXCI8dGFibGU+PGNvbGdyb3VwPlxcXCIsIFxcXCI8L2NvbGdyb3VwPjwvdGFibGU+XFxcIl0sXFxuICAgIHRyOiBbMiwgXFxcIjx0YWJsZT48dGJvZHk+XFxcIiwgXFxcIjwvdGJvZHk+PC90YWJsZT5cXFwiXSxcXG4gICAgdGQ6IFszLCBcXFwiPHRhYmxlPjx0Ym9keT48dHI+XFxcIiwgXFxcIjwvdHI+PC90Ym9keT48L3RhYmxlPlxcXCJdLFxcbiAgICBfZGVmYXVsdDogWzAsIFxcXCJcXFwiLCBcXFwiXFxcIl1cXG4gIH07IC8vIFN1cHBvcnQ6IElFOVxcblxcbiAgd3JhcE1hcC5vcHRncm91cCA9IHdyYXBNYXAub3B0aW9uO1xcbiAgd3JhcE1hcC50Ym9keSA9IHdyYXBNYXAudGZvb3QgPSB3cmFwTWFwLmNvbGdyb3VwID0gd3JhcE1hcC5jYXB0aW9uID0gd3JhcE1hcC50aGVhZDtcXG4gIHdyYXBNYXAudGggPSB3cmFwTWFwLnRkOyAvLyBTdXBwb3J0OiAxLnggY29tcGF0aWJpbGl0eVxcbiAgLy8gTWFuaXB1bGF0aW5nIHRhYmxlcyByZXF1aXJlcyBhIHRib2R5XFxuXFxuICBmdW5jdGlvbiBtYW5pcHVsYXRpb25UYXJnZXQoZWxlbSwgY29udGVudCkge1xcbiAgICByZXR1cm4galF1ZXJ5Lm5vZGVOYW1lKGVsZW0sIFxcXCJ0YWJsZVxcXCIpICYmIGpRdWVyeS5ub2RlTmFtZShjb250ZW50Lm5vZGVUeXBlICE9PSAxMSA/IGNvbnRlbnQgOiBjb250ZW50LmZpcnN0Q2hpbGQsIFxcXCJ0clxcXCIpID8gZWxlbS5nZXRFbGVtZW50c0J5VGFnTmFtZShcXFwidGJvZHlcXFwiKVswXSB8fCBlbGVtLmFwcGVuZENoaWxkKGVsZW0ub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KFxcXCJ0Ym9keVxcXCIpKSA6IGVsZW07XFxuICB9IC8vIFJlcGxhY2UvcmVzdG9yZSB0aGUgdHlwZSBhdHRyaWJ1dGUgb2Ygc2NyaXB0IGVsZW1lbnRzIGZvciBzYWZlIERPTSBtYW5pcHVsYXRpb25cXG5cXG5cXG4gIGZ1bmN0aW9uIGRpc2FibGVTY3JpcHQoZWxlbSkge1xcbiAgICBlbGVtLnR5cGUgPSAoZWxlbS5nZXRBdHRyaWJ1dGUoXFxcInR5cGVcXFwiKSAhPT0gbnVsbCkgKyBcXFwiL1xcXCIgKyBlbGVtLnR5cGU7XFxuICAgIHJldHVybiBlbGVtO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gcmVzdG9yZVNjcmlwdChlbGVtKSB7XFxuICAgIHZhciBtYXRjaCA9IHJzY3JpcHRUeXBlTWFza2VkLmV4ZWMoZWxlbS50eXBlKTtcXG5cXG4gICAgaWYgKG1hdGNoKSB7XFxuICAgICAgZWxlbS50eXBlID0gbWF0Y2hbMV07XFxuICAgIH0gZWxzZSB7XFxuICAgICAgZWxlbS5yZW1vdmVBdHRyaWJ1dGUoXFxcInR5cGVcXFwiKTtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gZWxlbTtcXG4gIH0gLy8gTWFyayBzY3JpcHRzIGFzIGhhdmluZyBhbHJlYWR5IGJlZW4gZXZhbHVhdGVkXFxuXFxuXFxuICBmdW5jdGlvbiBzZXRHbG9iYWxFdmFsKGVsZW1zLCByZWZFbGVtZW50cykge1xcbiAgICB2YXIgaSA9IDAsXFxuICAgICAgICBsID0gZWxlbXMubGVuZ3RoO1xcblxcbiAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xcbiAgICAgIGRhdGFfcHJpdi5zZXQoZWxlbXNbaV0sIFxcXCJnbG9iYWxFdmFsXFxcIiwgIXJlZkVsZW1lbnRzIHx8IGRhdGFfcHJpdi5nZXQocmVmRWxlbWVudHNbaV0sIFxcXCJnbG9iYWxFdmFsXFxcIikpO1xcbiAgICB9XFxuICB9XFxuXFxuICBmdW5jdGlvbiBjbG9uZUNvcHlFdmVudChzcmMsIGRlc3QpIHtcXG4gICAgdmFyIGksIGwsIHR5cGUsIHBkYXRhT2xkLCBwZGF0YUN1ciwgdWRhdGFPbGQsIHVkYXRhQ3VyLCBldmVudHM7XFxuXFxuICAgIGlmIChkZXN0Lm5vZGVUeXBlICE9PSAxKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9IC8vIDEuIENvcHkgcHJpdmF0ZSBkYXRhOiBldmVudHMsIGhhbmRsZXJzLCBldGMuXFxuXFxuXFxuICAgIGlmIChkYXRhX3ByaXYuaGFzRGF0YShzcmMpKSB7XFxuICAgICAgcGRhdGFPbGQgPSBkYXRhX3ByaXYuYWNjZXNzKHNyYyk7XFxuICAgICAgcGRhdGFDdXIgPSBkYXRhX3ByaXYuc2V0KGRlc3QsIHBkYXRhT2xkKTtcXG4gICAgICBldmVudHMgPSBwZGF0YU9sZC5ldmVudHM7XFxuXFxuICAgICAgaWYgKGV2ZW50cykge1xcbiAgICAgICAgZGVsZXRlIHBkYXRhQ3VyLmhhbmRsZTtcXG4gICAgICAgIHBkYXRhQ3VyLmV2ZW50cyA9IHt9O1xcblxcbiAgICAgICAgZm9yICh0eXBlIGluIGV2ZW50cykge1xcbiAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gZXZlbnRzW3R5cGVdLmxlbmd0aDsgaSA8IGw7IGkrKykge1xcbiAgICAgICAgICAgIGpRdWVyeS5ldmVudC5hZGQoZGVzdCwgdHlwZSwgZXZlbnRzW3R5cGVdW2ldKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfSAvLyAyLiBDb3B5IHVzZXIgZGF0YVxcblxcblxcbiAgICBpZiAoZGF0YV91c2VyLmhhc0RhdGEoc3JjKSkge1xcbiAgICAgIHVkYXRhT2xkID0gZGF0YV91c2VyLmFjY2VzcyhzcmMpO1xcbiAgICAgIHVkYXRhQ3VyID0galF1ZXJ5LmV4dGVuZCh7fSwgdWRhdGFPbGQpO1xcbiAgICAgIGRhdGFfdXNlci5zZXQoZGVzdCwgdWRhdGFDdXIpO1xcbiAgICB9XFxuICB9XFxuXFxuICBmdW5jdGlvbiBnZXRBbGwoY29udGV4dCwgdGFnKSB7XFxuICAgIHZhciByZXQgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lID8gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSh0YWcgfHwgXFxcIipcXFwiKSA6IGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCA/IGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCh0YWcgfHwgXFxcIipcXFwiKSA6IFtdO1xcbiAgICByZXR1cm4gdGFnID09PSB1bmRlZmluZWQgfHwgdGFnICYmIGpRdWVyeS5ub2RlTmFtZShjb250ZXh0LCB0YWcpID8galF1ZXJ5Lm1lcmdlKFtjb250ZXh0XSwgcmV0KSA6IHJldDtcXG4gIH0gLy8gRml4IElFIGJ1Z3MsIHNlZSBzdXBwb3J0IHRlc3RzXFxuXFxuXFxuICBmdW5jdGlvbiBmaXhJbnB1dChzcmMsIGRlc3QpIHtcXG4gICAgdmFyIG5vZGVOYW1lID0gZGVzdC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpOyAvLyBGYWlscyB0byBwZXJzaXN0IHRoZSBjaGVja2VkIHN0YXRlIG9mIGEgY2xvbmVkIGNoZWNrYm94IG9yIHJhZGlvIGJ1dHRvbi5cXG5cXG4gICAgaWYgKG5vZGVOYW1lID09PSBcXFwiaW5wdXRcXFwiICYmIHJjaGVja2FibGVUeXBlLnRlc3Qoc3JjLnR5cGUpKSB7XFxuICAgICAgZGVzdC5jaGVja2VkID0gc3JjLmNoZWNrZWQ7IC8vIEZhaWxzIHRvIHJldHVybiB0aGUgc2VsZWN0ZWQgb3B0aW9uIHRvIHRoZSBkZWZhdWx0IHNlbGVjdGVkIHN0YXRlIHdoZW4gY2xvbmluZyBvcHRpb25zXFxuICAgIH0gZWxzZSBpZiAobm9kZU5hbWUgPT09IFxcXCJpbnB1dFxcXCIgfHwgbm9kZU5hbWUgPT09IFxcXCJ0ZXh0YXJlYVxcXCIpIHtcXG4gICAgICBkZXN0LmRlZmF1bHRWYWx1ZSA9IHNyYy5kZWZhdWx0VmFsdWU7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGpRdWVyeS5leHRlbmQoe1xcbiAgICBjbG9uZTogZnVuY3Rpb24gY2xvbmUoZWxlbSwgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMpIHtcXG4gICAgICB2YXIgaSxcXG4gICAgICAgICAgbCxcXG4gICAgICAgICAgc3JjRWxlbWVudHMsXFxuICAgICAgICAgIGRlc3RFbGVtZW50cyxcXG4gICAgICAgICAgY2xvbmUgPSBlbGVtLmNsb25lTm9kZSh0cnVlKSxcXG4gICAgICAgICAgaW5QYWdlID0galF1ZXJ5LmNvbnRhaW5zKGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSk7IC8vIEZpeCBJRSBjbG9uaW5nIGlzc3Vlc1xcblxcbiAgICAgIGlmICghc3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCAmJiAoZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBlbGVtLm5vZGVUeXBlID09PSAxMSkgJiYgIWpRdWVyeS5pc1hNTERvYyhlbGVtKSkge1xcbiAgICAgICAgLy8gV2UgZXNjaGV3IFNpenpsZSBoZXJlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zOiBodHRwOi8vanNwZXJmLmNvbS9nZXRhbGwtdnMtc2l6emxlLzJcXG4gICAgICAgIGRlc3RFbGVtZW50cyA9IGdldEFsbChjbG9uZSk7XFxuICAgICAgICBzcmNFbGVtZW50cyA9IGdldEFsbChlbGVtKTtcXG5cXG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcXG4gICAgICAgICAgZml4SW5wdXQoc3JjRWxlbWVudHNbaV0sIGRlc3RFbGVtZW50c1tpXSk7XFxuICAgICAgICB9XFxuICAgICAgfSAvLyBDb3B5IHRoZSBldmVudHMgZnJvbSB0aGUgb3JpZ2luYWwgdG8gdGhlIGNsb25lXFxuXFxuXFxuICAgICAgaWYgKGRhdGFBbmRFdmVudHMpIHtcXG4gICAgICAgIGlmIChkZWVwRGF0YUFuZEV2ZW50cykge1xcbiAgICAgICAgICBzcmNFbGVtZW50cyA9IHNyY0VsZW1lbnRzIHx8IGdldEFsbChlbGVtKTtcXG4gICAgICAgICAgZGVzdEVsZW1lbnRzID0gZGVzdEVsZW1lbnRzIHx8IGdldEFsbChjbG9uZSk7XFxuXFxuICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcXG4gICAgICAgICAgICBjbG9uZUNvcHlFdmVudChzcmNFbGVtZW50c1tpXSwgZGVzdEVsZW1lbnRzW2ldKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgY2xvbmVDb3B5RXZlbnQoZWxlbSwgY2xvbmUpO1xcbiAgICAgICAgfVxcbiAgICAgIH0gLy8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxcblxcblxcbiAgICAgIGRlc3RFbGVtZW50cyA9IGdldEFsbChjbG9uZSwgXFxcInNjcmlwdFxcXCIpO1xcblxcbiAgICAgIGlmIChkZXN0RWxlbWVudHMubGVuZ3RoID4gMCkge1xcbiAgICAgICAgc2V0R2xvYmFsRXZhbChkZXN0RWxlbWVudHMsICFpblBhZ2UgJiYgZ2V0QWxsKGVsZW0sIFxcXCJzY3JpcHRcXFwiKSk7XFxuICAgICAgfSAvLyBSZXR1cm4gdGhlIGNsb25lZCBzZXRcXG5cXG5cXG4gICAgICByZXR1cm4gY2xvbmU7XFxuICAgIH0sXFxuICAgIGJ1aWxkRnJhZ21lbnQ6IGZ1bmN0aW9uIGJ1aWxkRnJhZ21lbnQoZWxlbXMsIGNvbnRleHQsIHNjcmlwdHMsIHNlbGVjdGlvbikge1xcbiAgICAgIHZhciBlbGVtLFxcbiAgICAgICAgICB0bXAsXFxuICAgICAgICAgIHRhZyxcXG4gICAgICAgICAgd3JhcCxcXG4gICAgICAgICAgY29udGFpbnMsXFxuICAgICAgICAgIGosXFxuICAgICAgICAgIGZyYWdtZW50ID0gY29udGV4dC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXFxuICAgICAgICAgIG5vZGVzID0gW10sXFxuICAgICAgICAgIGkgPSAwLFxcbiAgICAgICAgICBsID0gZWxlbXMubGVuZ3RoO1xcblxcbiAgICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XFxuICAgICAgICBlbGVtID0gZWxlbXNbaV07XFxuXFxuICAgICAgICBpZiAoZWxlbSB8fCBlbGVtID09PSAwKSB7XFxuICAgICAgICAgIC8vIEFkZCBub2RlcyBkaXJlY3RseVxcbiAgICAgICAgICBpZiAoalF1ZXJ5LnR5cGUoZWxlbSkgPT09IFxcXCJvYmplY3RcXFwiKSB7XFxuICAgICAgICAgICAgLy8gU3VwcG9ydDogUXRXZWJLaXQsIFBoYW50b21KU1xcbiAgICAgICAgICAgIC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcXG4gICAgICAgICAgICBqUXVlcnkubWVyZ2Uobm9kZXMsIGVsZW0ubm9kZVR5cGUgPyBbZWxlbV0gOiBlbGVtKTsgLy8gQ29udmVydCBub24taHRtbCBpbnRvIGEgdGV4dCBub2RlXFxuICAgICAgICAgIH0gZWxzZSBpZiAoIXJodG1sLnRlc3QoZWxlbSkpIHtcXG4gICAgICAgICAgICBub2Rlcy5wdXNoKGNvbnRleHQuY3JlYXRlVGV4dE5vZGUoZWxlbSkpOyAvLyBDb252ZXJ0IGh0bWwgaW50byBET00gbm9kZXNcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICB0bXAgPSB0bXAgfHwgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoY29udGV4dC5jcmVhdGVFbGVtZW50KFxcXCJkaXZcXFwiKSk7IC8vIERlc2VyaWFsaXplIGEgc3RhbmRhcmQgcmVwcmVzZW50YXRpb25cXG5cXG4gICAgICAgICAgICB0YWcgPSAocnRhZ05hbWUuZXhlYyhlbGVtKSB8fCBbXFxcIlxcXCIsIFxcXCJcXFwiXSlbMV0udG9Mb3dlckNhc2UoKTtcXG4gICAgICAgICAgICB3cmFwID0gd3JhcE1hcFt0YWddIHx8IHdyYXBNYXAuX2RlZmF1bHQ7XFxuICAgICAgICAgICAgdG1wLmlubmVySFRNTCA9IHdyYXBbMV0gKyBlbGVtLnJlcGxhY2UocnhodG1sVGFnLCBcXFwiPCQxPjwvJDI+XFxcIikgKyB3cmFwWzJdOyAvLyBEZXNjZW5kIHRocm91Z2ggd3JhcHBlcnMgdG8gdGhlIHJpZ2h0IGNvbnRlbnRcXG5cXG4gICAgICAgICAgICBqID0gd3JhcFswXTtcXG5cXG4gICAgICAgICAgICB3aGlsZSAoai0tKSB7XFxuICAgICAgICAgICAgICB0bXAgPSB0bXAubGFzdENoaWxkO1xcbiAgICAgICAgICAgIH0gLy8gU3VwcG9ydDogUXRXZWJLaXQsIFBoYW50b21KU1xcbiAgICAgICAgICAgIC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcXG5cXG5cXG4gICAgICAgICAgICBqUXVlcnkubWVyZ2Uobm9kZXMsIHRtcC5jaGlsZE5vZGVzKTsgLy8gUmVtZW1iZXIgdGhlIHRvcC1sZXZlbCBjb250YWluZXJcXG5cXG4gICAgICAgICAgICB0bXAgPSBmcmFnbWVudC5maXJzdENoaWxkOyAvLyBFbnN1cmUgdGhlIGNyZWF0ZWQgbm9kZXMgYXJlIG9ycGhhbmVkICgjMTIzOTIpXFxuXFxuICAgICAgICAgICAgdG1wLnRleHRDb250ZW50ID0gXFxcIlxcXCI7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9IC8vIFJlbW92ZSB3cmFwcGVyIGZyb20gZnJhZ21lbnRcXG5cXG5cXG4gICAgICBmcmFnbWVudC50ZXh0Q29udGVudCA9IFxcXCJcXFwiO1xcbiAgICAgIGkgPSAwO1xcblxcbiAgICAgIHdoaWxlIChlbGVtID0gbm9kZXNbaSsrXSkge1xcbiAgICAgICAgLy8gIzQwODcgLSBJZiBvcmlnaW4gYW5kIGRlc3RpbmF0aW9uIGVsZW1lbnRzIGFyZSB0aGUgc2FtZSwgYW5kIHRoaXMgaXNcXG4gICAgICAgIC8vIHRoYXQgZWxlbWVudCwgZG8gbm90IGRvIGFueXRoaW5nXFxuICAgICAgICBpZiAoc2VsZWN0aW9uICYmIGpRdWVyeS5pbkFycmF5KGVsZW0sIHNlbGVjdGlvbikgIT09IC0xKSB7XFxuICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgY29udGFpbnMgPSBqUXVlcnkuY29udGFpbnMoZWxlbS5vd25lckRvY3VtZW50LCBlbGVtKTsgLy8gQXBwZW5kIHRvIGZyYWdtZW50XFxuXFxuICAgICAgICB0bXAgPSBnZXRBbGwoZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZWxlbSksIFxcXCJzY3JpcHRcXFwiKTsgLy8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxcblxcbiAgICAgICAgaWYgKGNvbnRhaW5zKSB7XFxuICAgICAgICAgIHNldEdsb2JhbEV2YWwodG1wKTtcXG4gICAgICAgIH0gLy8gQ2FwdHVyZSBleGVjdXRhYmxlc1xcblxcblxcbiAgICAgICAgaWYgKHNjcmlwdHMpIHtcXG4gICAgICAgICAgaiA9IDA7XFxuXFxuICAgICAgICAgIHdoaWxlIChlbGVtID0gdG1wW2orK10pIHtcXG4gICAgICAgICAgICBpZiAocnNjcmlwdFR5cGUudGVzdChlbGVtLnR5cGUgfHwgXFxcIlxcXCIpKSB7XFxuICAgICAgICAgICAgICBzY3JpcHRzLnB1c2goZWxlbSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBmcmFnbWVudDtcXG4gICAgfSxcXG4gICAgY2xlYW5EYXRhOiBmdW5jdGlvbiBjbGVhbkRhdGEoZWxlbXMpIHtcXG4gICAgICB2YXIgZGF0YSxcXG4gICAgICAgICAgZWxlbSxcXG4gICAgICAgICAgdHlwZSxcXG4gICAgICAgICAga2V5LFxcbiAgICAgICAgICBzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWwsXFxuICAgICAgICAgIGkgPSAwO1xcblxcbiAgICAgIGZvciAoOyAoZWxlbSA9IGVsZW1zW2ldKSAhPT0gdW5kZWZpbmVkOyBpKyspIHtcXG4gICAgICAgIGlmIChqUXVlcnkuYWNjZXB0RGF0YShlbGVtKSkge1xcbiAgICAgICAgICBrZXkgPSBlbGVtW2RhdGFfcHJpdi5leHBhbmRvXTtcXG5cXG4gICAgICAgICAgaWYgKGtleSAmJiAoZGF0YSA9IGRhdGFfcHJpdi5jYWNoZVtrZXldKSkge1xcbiAgICAgICAgICAgIGlmIChkYXRhLmV2ZW50cykge1xcbiAgICAgICAgICAgICAgZm9yICh0eXBlIGluIGRhdGEuZXZlbnRzKSB7XFxuICAgICAgICAgICAgICAgIGlmIChzcGVjaWFsW3R5cGVdKSB7XFxuICAgICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LnJlbW92ZShlbGVtLCB0eXBlKTsgLy8gVGhpcyBpcyBhIHNob3J0Y3V0IHRvIGF2b2lkIGpRdWVyeS5ldmVudC5yZW1vdmUncyBvdmVyaGVhZFxcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgIGpRdWVyeS5yZW1vdmVFdmVudChlbGVtLCB0eXBlLCBkYXRhLmhhbmRsZSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaWYgKGRhdGFfcHJpdi5jYWNoZVtrZXldKSB7XFxuICAgICAgICAgICAgICAvLyBEaXNjYXJkIGFueSByZW1haW5pbmcgYHByaXZhdGVgIGRhdGFcXG4gICAgICAgICAgICAgIGRlbGV0ZSBkYXRhX3ByaXYuY2FjaGVba2V5XTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gLy8gRGlzY2FyZCBhbnkgcmVtYWluaW5nIGB1c2VyYCBkYXRhXFxuXFxuXFxuICAgICAgICBkZWxldGUgZGF0YV91c2VyLmNhY2hlW2VsZW1bZGF0YV91c2VyLmV4cGFuZG9dXTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH0pO1xcbiAgalF1ZXJ5LmZuLmV4dGVuZCh7XFxuICAgIHRleHQ6IGZ1bmN0aW9uIHRleHQodmFsdWUpIHtcXG4gICAgICByZXR1cm4gYWNjZXNzKHRoaXMsIGZ1bmN0aW9uICh2YWx1ZSkge1xcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyBqUXVlcnkudGV4dCh0aGlzKSA6IHRoaXMuZW1wdHkoKS5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgaWYgKHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSkge1xcbiAgICAgICAgICAgIHRoaXMudGV4dENvbnRlbnQgPSB2YWx1ZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgICAgfSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGgpO1xcbiAgICB9LFxcbiAgICBhcHBlbmQ6IGZ1bmN0aW9uIGFwcGVuZCgpIHtcXG4gICAgICByZXR1cm4gdGhpcy5kb21NYW5pcChhcmd1bWVudHMsIGZ1bmN0aW9uIChlbGVtKSB7XFxuICAgICAgICBpZiAodGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5KSB7XFxuICAgICAgICAgIHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQodGhpcywgZWxlbSk7XFxuICAgICAgICAgIHRhcmdldC5hcHBlbmRDaGlsZChlbGVtKTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgfSxcXG4gICAgcHJlcGVuZDogZnVuY3Rpb24gcHJlcGVuZCgpIHtcXG4gICAgICByZXR1cm4gdGhpcy5kb21NYW5pcChhcmd1bWVudHMsIGZ1bmN0aW9uIChlbGVtKSB7XFxuICAgICAgICBpZiAodGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5KSB7XFxuICAgICAgICAgIHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQodGhpcywgZWxlbSk7XFxuICAgICAgICAgIHRhcmdldC5pbnNlcnRCZWZvcmUoZWxlbSwgdGFyZ2V0LmZpcnN0Q2hpbGQpO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcbiAgICB9LFxcbiAgICBiZWZvcmU6IGZ1bmN0aW9uIGJlZm9yZSgpIHtcXG4gICAgICByZXR1cm4gdGhpcy5kb21NYW5pcChhcmd1bWVudHMsIGZ1bmN0aW9uIChlbGVtKSB7XFxuICAgICAgICBpZiAodGhpcy5wYXJlbnROb2RlKSB7XFxuICAgICAgICAgIHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWxlbSwgdGhpcyk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgIH0sXFxuICAgIGFmdGVyOiBmdW5jdGlvbiBhZnRlcigpIHtcXG4gICAgICByZXR1cm4gdGhpcy5kb21NYW5pcChhcmd1bWVudHMsIGZ1bmN0aW9uIChlbGVtKSB7XFxuICAgICAgICBpZiAodGhpcy5wYXJlbnROb2RlKSB7XFxuICAgICAgICAgIHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWxlbSwgdGhpcy5uZXh0U2libGluZyk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgIH0sXFxuICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKHNlbGVjdG9yLCBrZWVwRGF0YVxcbiAgICAvKiBJbnRlcm5hbCBVc2UgT25seSAqL1xcbiAgICApIHtcXG4gICAgICB2YXIgZWxlbSxcXG4gICAgICAgICAgZWxlbXMgPSBzZWxlY3RvciA/IGpRdWVyeS5maWx0ZXIoc2VsZWN0b3IsIHRoaXMpIDogdGhpcyxcXG4gICAgICAgICAgaSA9IDA7XFxuXFxuICAgICAgZm9yICg7IChlbGVtID0gZWxlbXNbaV0pICE9IG51bGw7IGkrKykge1xcbiAgICAgICAgaWYgKCFrZWVwRGF0YSAmJiBlbGVtLm5vZGVUeXBlID09PSAxKSB7XFxuICAgICAgICAgIGpRdWVyeS5jbGVhbkRhdGEoZ2V0QWxsKGVsZW0pKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChlbGVtLnBhcmVudE5vZGUpIHtcXG4gICAgICAgICAgaWYgKGtlZXBEYXRhICYmIGpRdWVyeS5jb250YWlucyhlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0pKSB7XFxuICAgICAgICAgICAgc2V0R2xvYmFsRXZhbChnZXRBbGwoZWxlbSwgXFxcInNjcmlwdFxcXCIpKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBlbGVtLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlbSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiB0aGlzO1xcbiAgICB9LFxcbiAgICBlbXB0eTogZnVuY3Rpb24gZW1wdHkoKSB7XFxuICAgICAgdmFyIGVsZW0sXFxuICAgICAgICAgIGkgPSAwO1xcblxcbiAgICAgIGZvciAoOyAoZWxlbSA9IHRoaXNbaV0pICE9IG51bGw7IGkrKykge1xcbiAgICAgICAgaWYgKGVsZW0ubm9kZVR5cGUgPT09IDEpIHtcXG4gICAgICAgICAgLy8gUHJldmVudCBtZW1vcnkgbGVha3NcXG4gICAgICAgICAgalF1ZXJ5LmNsZWFuRGF0YShnZXRBbGwoZWxlbSwgZmFsc2UpKTsgLy8gUmVtb3ZlIGFueSByZW1haW5pbmcgbm9kZXNcXG5cXG4gICAgICAgICAgZWxlbS50ZXh0Q29udGVudCA9IFxcXCJcXFwiO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gdGhpcztcXG4gICAgfSxcXG4gICAgY2xvbmU6IGZ1bmN0aW9uIGNsb25lKGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzKSB7XFxuICAgICAgZGF0YUFuZEV2ZW50cyA9IGRhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGZhbHNlIDogZGF0YUFuZEV2ZW50cztcXG4gICAgICBkZWVwRGF0YUFuZEV2ZW50cyA9IGRlZXBEYXRhQW5kRXZlbnRzID09IG51bGwgPyBkYXRhQW5kRXZlbnRzIDogZGVlcERhdGFBbmRFdmVudHM7XFxuICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHJldHVybiBqUXVlcnkuY2xvbmUodGhpcywgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMpO1xcbiAgICAgIH0pO1xcbiAgICB9LFxcbiAgICBodG1sOiBmdW5jdGlvbiBodG1sKHZhbHVlKSB7XFxuICAgICAgcmV0dXJuIGFjY2Vzcyh0aGlzLCBmdW5jdGlvbiAodmFsdWUpIHtcXG4gICAgICAgIHZhciBlbGVtID0gdGhpc1swXSB8fCB7fSxcXG4gICAgICAgICAgICBpID0gMCxcXG4gICAgICAgICAgICBsID0gdGhpcy5sZW5ndGg7XFxuXFxuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxKSB7XFxuICAgICAgICAgIHJldHVybiBlbGVtLmlubmVySFRNTDtcXG4gICAgICAgIH0gLy8gU2VlIGlmIHdlIGNhbiB0YWtlIGEgc2hvcnRjdXQgYW5kIGp1c3QgdXNlIGlubmVySFRNTFxcblxcblxcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXFxcInN0cmluZ1xcXCIgJiYgIXJub0lubmVyaHRtbC50ZXN0KHZhbHVlKSAmJiAhd3JhcE1hcFsocnRhZ05hbWUuZXhlYyh2YWx1ZSkgfHwgW1xcXCJcXFwiLCBcXFwiXFxcIl0pWzFdLnRvTG93ZXJDYXNlKCldKSB7XFxuICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZShyeGh0bWxUYWcsIFxcXCI8JDE+PC8kMj5cXFwiKTtcXG5cXG4gICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xcbiAgICAgICAgICAgICAgZWxlbSA9IHRoaXNbaV0gfHwge307IC8vIFJlbW92ZSBlbGVtZW50IG5vZGVzIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrc1xcblxcbiAgICAgICAgICAgICAgaWYgKGVsZW0ubm9kZVR5cGUgPT09IDEpIHtcXG4gICAgICAgICAgICAgICAgalF1ZXJ5LmNsZWFuRGF0YShnZXRBbGwoZWxlbSwgZmFsc2UpKTtcXG4gICAgICAgICAgICAgICAgZWxlbS5pbm5lckhUTUwgPSB2YWx1ZTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgZWxlbSA9IDA7IC8vIElmIHVzaW5nIGlubmVySFRNTCB0aHJvd3MgYW4gZXhjZXB0aW9uLCB1c2UgdGhlIGZhbGxiYWNrIG1ldGhvZFxcbiAgICAgICAgICB9IGNhdGNoIChlKSB7fVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKGVsZW0pIHtcXG4gICAgICAgICAgdGhpcy5lbXB0eSgpLmFwcGVuZCh2YWx1ZSk7XFxuICAgICAgICB9XFxuICAgICAgfSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGgpO1xcbiAgICB9LFxcbiAgICByZXBsYWNlV2l0aDogZnVuY3Rpb24gcmVwbGFjZVdpdGgoKSB7XFxuICAgICAgdmFyIGFyZyA9IGFyZ3VtZW50c1swXTsgLy8gTWFrZSB0aGUgY2hhbmdlcywgcmVwbGFjaW5nIGVhY2ggY29udGV4dCBlbGVtZW50IHdpdGggdGhlIG5ldyBjb250ZW50XFxuXFxuICAgICAgdGhpcy5kb21NYW5pcChhcmd1bWVudHMsIGZ1bmN0aW9uIChlbGVtKSB7XFxuICAgICAgICBhcmcgPSB0aGlzLnBhcmVudE5vZGU7XFxuICAgICAgICBqUXVlcnkuY2xlYW5EYXRhKGdldEFsbCh0aGlzKSk7XFxuXFxuICAgICAgICBpZiAoYXJnKSB7XFxuICAgICAgICAgIGFyZy5yZXBsYWNlQ2hpbGQoZWxlbSwgdGhpcyk7XFxuICAgICAgICB9XFxuICAgICAgfSk7IC8vIEZvcmNlIHJlbW92YWwgaWYgdGhlcmUgd2FzIG5vIG5ldyBjb250ZW50IChlLmcuLCBmcm9tIGVtcHR5IGFyZ3VtZW50cylcXG5cXG4gICAgICByZXR1cm4gYXJnICYmIChhcmcubGVuZ3RoIHx8IGFyZy5ub2RlVHlwZSkgPyB0aGlzIDogdGhpcy5yZW1vdmUoKTtcXG4gICAgfSxcXG4gICAgZGV0YWNoOiBmdW5jdGlvbiBkZXRhY2goc2VsZWN0b3IpIHtcXG4gICAgICByZXR1cm4gdGhpcy5yZW1vdmUoc2VsZWN0b3IsIHRydWUpO1xcbiAgICB9LFxcbiAgICBkb21NYW5pcDogZnVuY3Rpb24gZG9tTWFuaXAoYXJncywgY2FsbGJhY2spIHtcXG4gICAgICAvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXFxuICAgICAgYXJncyA9IGNvbmNhdC5hcHBseShbXSwgYXJncyk7XFxuICAgICAgdmFyIGZyYWdtZW50LFxcbiAgICAgICAgICBmaXJzdCxcXG4gICAgICAgICAgc2NyaXB0cyxcXG4gICAgICAgICAgaGFzU2NyaXB0cyxcXG4gICAgICAgICAgbm9kZSxcXG4gICAgICAgICAgZG9jLFxcbiAgICAgICAgICBpID0gMCxcXG4gICAgICAgICAgbCA9IHRoaXMubGVuZ3RoLFxcbiAgICAgICAgICBzZXQgPSB0aGlzLFxcbiAgICAgICAgICBpTm9DbG9uZSA9IGwgLSAxLFxcbiAgICAgICAgICB2YWx1ZSA9IGFyZ3NbMF0sXFxuICAgICAgICAgIGlzRnVuY3Rpb24gPSBqUXVlcnkuaXNGdW5jdGlvbih2YWx1ZSk7IC8vIFdlIGNhbid0IGNsb25lTm9kZSBmcmFnbWVudHMgdGhhdCBjb250YWluIGNoZWNrZWQsIGluIFdlYktpdFxcblxcbiAgICAgIGlmIChpc0Z1bmN0aW9uIHx8IGwgPiAxICYmIHR5cGVvZiB2YWx1ZSA9PT0gXFxcInN0cmluZ1xcXCIgJiYgIXN1cHBvcnQuY2hlY2tDbG9uZSAmJiByY2hlY2tlZC50ZXN0KHZhbHVlKSkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoaW5kZXgpIHtcXG4gICAgICAgICAgdmFyIHNlbGYgPSBzZXQuZXEoaW5kZXgpO1xcblxcbiAgICAgICAgICBpZiAoaXNGdW5jdGlvbikge1xcbiAgICAgICAgICAgIGFyZ3NbMF0gPSB2YWx1ZS5jYWxsKHRoaXMsIGluZGV4LCBzZWxmLmh0bWwoKSk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgc2VsZi5kb21NYW5pcChhcmdzLCBjYWxsYmFjayk7XFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGwpIHtcXG4gICAgICAgIGZyYWdtZW50ID0galF1ZXJ5LmJ1aWxkRnJhZ21lbnQoYXJncywgdGhpc1swXS5vd25lckRvY3VtZW50LCBmYWxzZSwgdGhpcyk7XFxuICAgICAgICBmaXJzdCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XFxuXFxuICAgICAgICBpZiAoZnJhZ21lbnQuY2hpbGROb2Rlcy5sZW5ndGggPT09IDEpIHtcXG4gICAgICAgICAgZnJhZ21lbnQgPSBmaXJzdDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChmaXJzdCkge1xcbiAgICAgICAgICBzY3JpcHRzID0galF1ZXJ5Lm1hcChnZXRBbGwoZnJhZ21lbnQsIFxcXCJzY3JpcHRcXFwiKSwgZGlzYWJsZVNjcmlwdCk7XFxuICAgICAgICAgIGhhc1NjcmlwdHMgPSBzY3JpcHRzLmxlbmd0aDsgLy8gVXNlIHRoZSBvcmlnaW5hbCBmcmFnbWVudCBmb3IgdGhlIGxhc3QgaXRlbSBpbnN0ZWFkIG9mIHRoZSBmaXJzdCBiZWNhdXNlIGl0IGNhbiBlbmQgdXBcXG4gICAgICAgICAgLy8gYmVpbmcgZW1wdGllZCBpbmNvcnJlY3RseSBpbiBjZXJ0YWluIHNpdHVhdGlvbnMgKCM4MDcwKS5cXG5cXG4gICAgICAgICAgZm9yICg7IGkgPCBsOyBpKyspIHtcXG4gICAgICAgICAgICBub2RlID0gZnJhZ21lbnQ7XFxuXFxuICAgICAgICAgICAgaWYgKGkgIT09IGlOb0Nsb25lKSB7XFxuICAgICAgICAgICAgICBub2RlID0galF1ZXJ5LmNsb25lKG5vZGUsIHRydWUsIHRydWUpOyAvLyBLZWVwIHJlZmVyZW5jZXMgdG8gY2xvbmVkIHNjcmlwdHMgZm9yIGxhdGVyIHJlc3RvcmF0aW9uXFxuXFxuICAgICAgICAgICAgICBpZiAoaGFzU2NyaXB0cykge1xcbiAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBRdFdlYktpdFxcbiAgICAgICAgICAgICAgICAvLyBqUXVlcnkubWVyZ2UgYmVjYXVzZSBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzXFxuICAgICAgICAgICAgICAgIGpRdWVyeS5tZXJnZShzY3JpcHRzLCBnZXRBbGwobm9kZSwgXFxcInNjcmlwdFxcXCIpKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzW2ldLCBub2RlLCBpKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAoaGFzU2NyaXB0cykge1xcbiAgICAgICAgICAgIGRvYyA9IHNjcmlwdHNbc2NyaXB0cy5sZW5ndGggLSAxXS5vd25lckRvY3VtZW50OyAvLyBSZWVuYWJsZSBzY3JpcHRzXFxuXFxuICAgICAgICAgICAgalF1ZXJ5Lm1hcChzY3JpcHRzLCByZXN0b3JlU2NyaXB0KTsgLy8gRXZhbHVhdGUgZXhlY3V0YWJsZSBzY3JpcHRzIG9uIGZpcnN0IGRvY3VtZW50IGluc2VydGlvblxcblxcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBoYXNTY3JpcHRzOyBpKyspIHtcXG4gICAgICAgICAgICAgIG5vZGUgPSBzY3JpcHRzW2ldO1xcblxcbiAgICAgICAgICAgICAgaWYgKHJzY3JpcHRUeXBlLnRlc3Qobm9kZS50eXBlIHx8IFxcXCJcXFwiKSAmJiAhZGF0YV9wcml2LmFjY2Vzcyhub2RlLCBcXFwiZ2xvYmFsRXZhbFxcXCIpICYmIGpRdWVyeS5jb250YWlucyhkb2MsIG5vZGUpKSB7XFxuICAgICAgICAgICAgICAgIGlmIChub2RlLnNyYykge1xcbiAgICAgICAgICAgICAgICAgIC8vIE9wdGlvbmFsIEFKQVggZGVwZW5kZW5jeSwgYnV0IHdvbid0IHJ1biBzY3JpcHRzIGlmIG5vdCBwcmVzZW50XFxuICAgICAgICAgICAgICAgICAgaWYgKGpRdWVyeS5fZXZhbFVybCkge1xcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5Ll9ldmFsVXJsKG5vZGUuc3JjKTtcXG4gICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgalF1ZXJ5Lmdsb2JhbEV2YWwobm9kZS50ZXh0Q29udGVudC5yZXBsYWNlKHJjbGVhblNjcmlwdCwgXFxcIlxcXCIpKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gdGhpcztcXG4gICAgfVxcbiAgfSk7XFxuICBqUXVlcnkuZWFjaCh7XFxuICAgIGFwcGVuZFRvOiBcXFwiYXBwZW5kXFxcIixcXG4gICAgcHJlcGVuZFRvOiBcXFwicHJlcGVuZFxcXCIsXFxuICAgIGluc2VydEJlZm9yZTogXFxcImJlZm9yZVxcXCIsXFxuICAgIGluc2VydEFmdGVyOiBcXFwiYWZ0ZXJcXFwiLFxcbiAgICByZXBsYWNlQWxsOiBcXFwicmVwbGFjZVdpdGhcXFwiXFxuICB9LCBmdW5jdGlvbiAobmFtZSwgb3JpZ2luYWwpIHtcXG4gICAgalF1ZXJ5LmZuW25hbWVdID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XFxuICAgICAgdmFyIGVsZW1zLFxcbiAgICAgICAgICByZXQgPSBbXSxcXG4gICAgICAgICAgaW5zZXJ0ID0galF1ZXJ5KHNlbGVjdG9yKSxcXG4gICAgICAgICAgbGFzdCA9IGluc2VydC5sZW5ndGggLSAxLFxcbiAgICAgICAgICBpID0gMDtcXG5cXG4gICAgICBmb3IgKDsgaSA8PSBsYXN0OyBpKyspIHtcXG4gICAgICAgIGVsZW1zID0gaSA9PT0gbGFzdCA/IHRoaXMgOiB0aGlzLmNsb25lKHRydWUpO1xcbiAgICAgICAgalF1ZXJ5KGluc2VydFtpXSlbb3JpZ2luYWxdKGVsZW1zKTsgLy8gU3VwcG9ydDogUXRXZWJLaXRcXG4gICAgICAgIC8vIC5nZXQoKSBiZWNhdXNlIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3NcXG5cXG4gICAgICAgIHB1c2guYXBwbHkocmV0LCBlbGVtcy5nZXQoKSk7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayhyZXQpO1xcbiAgICB9O1xcbiAgfSk7XFxuICB2YXIgaWZyYW1lLFxcbiAgICAgIGVsZW1kaXNwbGF5ID0ge307XFxuICAvKipcXG4gICAqIFJldHJpZXZlIHRoZSBhY3R1YWwgZGlzcGxheSBvZiBhIGVsZW1lbnRcXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG5vZGVOYW1lIG9mIHRoZSBlbGVtZW50XFxuICAgKiBAcGFyYW0ge09iamVjdH0gZG9jIERvY3VtZW50IG9iamVjdFxcbiAgICovXFxuICAvLyBDYWxsZWQgb25seSBmcm9tIHdpdGhpbiBkZWZhdWx0RGlzcGxheVxcblxcbiAgZnVuY3Rpb24gYWN0dWFsRGlzcGxheShuYW1lLCBkb2MpIHtcXG4gICAgdmFyIHN0eWxlLFxcbiAgICAgICAgZWxlbSA9IGpRdWVyeShkb2MuY3JlYXRlRWxlbWVudChuYW1lKSkuYXBwZW5kVG8oZG9jLmJvZHkpLFxcbiAgICAgICAgLy8gZ2V0RGVmYXVsdENvbXB1dGVkU3R5bGUgbWlnaHQgYmUgcmVsaWFibHkgdXNlZCBvbmx5IG9uIGF0dGFjaGVkIGVsZW1lbnRcXG4gICAgZGlzcGxheSA9IHdpbmRvdy5nZXREZWZhdWx0Q29tcHV0ZWRTdHlsZSAmJiAoc3R5bGUgPSB3aW5kb3cuZ2V0RGVmYXVsdENvbXB1dGVkU3R5bGUoZWxlbVswXSkpID8gLy8gVXNlIG9mIHRoaXMgbWV0aG9kIGlzIGEgdGVtcG9yYXJ5IGZpeCAobW9yZSBsaWtlIG9wdGltaXphdGlvbikgdW50aWwgc29tZXRoaW5nIGJldHRlciBjb21lcyBhbG9uZyxcXG4gICAgLy8gc2luY2UgaXQgd2FzIHJlbW92ZWQgZnJvbSBzcGVjaWZpY2F0aW9uIGFuZCBzdXBwb3J0ZWQgb25seSBpbiBGRlxcbiAgICBzdHlsZS5kaXNwbGF5IDogalF1ZXJ5LmNzcyhlbGVtWzBdLCBcXFwiZGlzcGxheVxcXCIpOyAvLyBXZSBkb24ndCBoYXZlIGFueSBkYXRhIHN0b3JlZCBvbiB0aGUgZWxlbWVudCxcXG4gICAgLy8gc28gdXNlIFxcXCJkZXRhY2hcXFwiIG1ldGhvZCBhcyBmYXN0IHdheSB0byBnZXQgcmlkIG9mIHRoZSBlbGVtZW50XFxuXFxuICAgIGVsZW0uZGV0YWNoKCk7XFxuICAgIHJldHVybiBkaXNwbGF5O1xcbiAgfVxcbiAgLyoqXFxuICAgKiBUcnkgdG8gZGV0ZXJtaW5lIHRoZSBkZWZhdWx0IGRpc3BsYXkgdmFsdWUgb2YgYW4gZWxlbWVudFxcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5vZGVOYW1lXFxuICAgKi9cXG5cXG5cXG4gIGZ1bmN0aW9uIGRlZmF1bHREaXNwbGF5KG5vZGVOYW1lKSB7XFxuICAgIHZhciBkb2MgPSBkb2N1bWVudCxcXG4gICAgICAgIGRpc3BsYXkgPSBlbGVtZGlzcGxheVtub2RlTmFtZV07XFxuXFxuICAgIGlmICghZGlzcGxheSkge1xcbiAgICAgIGRpc3BsYXkgPSBhY3R1YWxEaXNwbGF5KG5vZGVOYW1lLCBkb2MpOyAvLyBJZiB0aGUgc2ltcGxlIHdheSBmYWlscywgcmVhZCBmcm9tIGluc2lkZSBhbiBpZnJhbWVcXG5cXG4gICAgICBpZiAoZGlzcGxheSA9PT0gXFxcIm5vbmVcXFwiIHx8ICFkaXNwbGF5KSB7XFxuICAgICAgICAvLyBVc2UgdGhlIGFscmVhZHktY3JlYXRlZCBpZnJhbWUgaWYgcG9zc2libGVcXG4gICAgICAgIGlmcmFtZSA9IChpZnJhbWUgfHwgalF1ZXJ5KFxcXCI8aWZyYW1lIGZyYW1lYm9yZGVyPScwJyB3aWR0aD0nMCcgaGVpZ2h0PScwJy8+XFxcIikpLmFwcGVuZFRvKGRvYy5kb2N1bWVudEVsZW1lbnQpOyAvLyBBbHdheXMgd3JpdGUgYSBuZXcgSFRNTCBza2VsZXRvbiBzbyBXZWJraXQgYW5kIEZpcmVmb3ggZG9uJ3QgY2hva2Ugb24gcmV1c2VcXG5cXG4gICAgICAgIGRvYyA9IGlmcmFtZVswXS5jb250ZW50RG9jdW1lbnQ7IC8vIFN1cHBvcnQ6IElFXFxuXFxuICAgICAgICBkb2Mud3JpdGUoKTtcXG4gICAgICAgIGRvYy5jbG9zZSgpO1xcbiAgICAgICAgZGlzcGxheSA9IGFjdHVhbERpc3BsYXkobm9kZU5hbWUsIGRvYyk7XFxuICAgICAgICBpZnJhbWUuZGV0YWNoKCk7XFxuICAgICAgfSAvLyBTdG9yZSB0aGUgY29ycmVjdCBkZWZhdWx0IGRpc3BsYXlcXG5cXG5cXG4gICAgICBlbGVtZGlzcGxheVtub2RlTmFtZV0gPSBkaXNwbGF5O1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBkaXNwbGF5O1xcbiAgfVxcblxcbiAgdmFyIHJtYXJnaW4gPSAvXm1hcmdpbi87XFxuICB2YXIgcm51bW5vbnB4ID0gbmV3IFJlZ0V4cChcXFwiXihcXFwiICsgcG51bSArIFxcXCIpKD8hcHgpW2EteiVdKyRcXFwiLCBcXFwiaVxcXCIpO1xcblxcbiAgdmFyIGdldFN0eWxlcyA9IGZ1bmN0aW9uIGdldFN0eWxlcyhlbGVtKSB7XFxuICAgIC8vIFN1cHBvcnQ6IElFPD0xMSssIEZpcmVmb3g8PTMwKyAoIzE1MDk4LCAjMTQxNTApXFxuICAgIC8vIElFIHRocm93cyBvbiBlbGVtZW50cyBjcmVhdGVkIGluIHBvcHVwc1xcbiAgICAvLyBGRiBtZWFud2hpbGUgdGhyb3dzIG9uIGZyYW1lIGVsZW1lbnRzIHRocm91Z2ggXFxcImRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGVcXFwiXFxuICAgIGlmIChlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcub3BlbmVyKSB7XFxuICAgICAgcmV0dXJuIGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGVsZW0sIG51bGwpO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtLCBudWxsKTtcXG4gIH07XFxuXFxuICBmdW5jdGlvbiBjdXJDU1MoZWxlbSwgbmFtZSwgY29tcHV0ZWQpIHtcXG4gICAgdmFyIHdpZHRoLFxcbiAgICAgICAgbWluV2lkdGgsXFxuICAgICAgICBtYXhXaWR0aCxcXG4gICAgICAgIHJldCxcXG4gICAgICAgIHN0eWxlID0gZWxlbS5zdHlsZTtcXG4gICAgY29tcHV0ZWQgPSBjb21wdXRlZCB8fCBnZXRTdHlsZXMoZWxlbSk7IC8vIFN1cHBvcnQ6IElFOVxcbiAgICAvLyBnZXRQcm9wZXJ0eVZhbHVlIGlzIG9ubHkgbmVlZGVkIGZvciAuY3NzKCdmaWx0ZXInKSAoIzEyNTM3KVxcblxcbiAgICBpZiAoY29tcHV0ZWQpIHtcXG4gICAgICByZXQgPSBjb21wdXRlZC5nZXRQcm9wZXJ0eVZhbHVlKG5hbWUpIHx8IGNvbXB1dGVkW25hbWVdO1xcbiAgICB9XFxuXFxuICAgIGlmIChjb21wdXRlZCkge1xcbiAgICAgIGlmIChyZXQgPT09IFxcXCJcXFwiICYmICFqUXVlcnkuY29udGFpbnMoZWxlbS5vd25lckRvY3VtZW50LCBlbGVtKSkge1xcbiAgICAgICAgcmV0ID0galF1ZXJ5LnN0eWxlKGVsZW0sIG5hbWUpO1xcbiAgICAgIH0gLy8gU3VwcG9ydDogaU9TIDwgNlxcbiAgICAgIC8vIEEgdHJpYnV0ZSB0byB0aGUgXFxcImF3ZXNvbWUgaGFjayBieSBEZWFuIEVkd2FyZHNcXFwiXFxuICAgICAgLy8gaU9TIDwgNiAoYXQgbGVhc3QpIHJldHVybnMgcGVyY2VudGFnZSBmb3IgYSBsYXJnZXIgc2V0IG9mIHZhbHVlcywgYnV0IHdpZHRoIHNlZW1zIHRvIGJlIHJlbGlhYmx5IHBpeGVsc1xcbiAgICAgIC8vIHRoaXMgaXMgYWdhaW5zdCB0aGUgQ1NTT00gZHJhZnQgc3BlYzogaHR0cDovL2Rldi53My5vcmcvY3Nzd2cvY3Nzb20vI3Jlc29sdmVkLXZhbHVlc1xcblxcblxcbiAgICAgIGlmIChybnVtbm9ucHgudGVzdChyZXQpICYmIHJtYXJnaW4udGVzdChuYW1lKSkge1xcbiAgICAgICAgLy8gUmVtZW1iZXIgdGhlIG9yaWdpbmFsIHZhbHVlc1xcbiAgICAgICAgd2lkdGggPSBzdHlsZS53aWR0aDtcXG4gICAgICAgIG1pbldpZHRoID0gc3R5bGUubWluV2lkdGg7XFxuICAgICAgICBtYXhXaWR0aCA9IHN0eWxlLm1heFdpZHRoOyAvLyBQdXQgaW4gdGhlIG5ldyB2YWx1ZXMgdG8gZ2V0IGEgY29tcHV0ZWQgdmFsdWUgb3V0XFxuXFxuICAgICAgICBzdHlsZS5taW5XaWR0aCA9IHN0eWxlLm1heFdpZHRoID0gc3R5bGUud2lkdGggPSByZXQ7XFxuICAgICAgICByZXQgPSBjb21wdXRlZC53aWR0aDsgLy8gUmV2ZXJ0IHRoZSBjaGFuZ2VkIHZhbHVlc1xcblxcbiAgICAgICAgc3R5bGUud2lkdGggPSB3aWR0aDtcXG4gICAgICAgIHN0eWxlLm1pbldpZHRoID0gbWluV2lkdGg7XFxuICAgICAgICBzdHlsZS5tYXhXaWR0aCA9IG1heFdpZHRoO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICByZXR1cm4gcmV0ICE9PSB1bmRlZmluZWQgPyAvLyBTdXBwb3J0OiBJRVxcbiAgICAvLyBJRSByZXR1cm5zIHpJbmRleCB2YWx1ZSBhcyBhbiBpbnRlZ2VyLlxcbiAgICByZXQgKyBcXFwiXFxcIiA6IHJldDtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGFkZEdldEhvb2tJZihjb25kaXRpb25GbiwgaG9va0ZuKSB7XFxuICAgIC8vIERlZmluZSB0aGUgaG9vaywgd2UnbGwgY2hlY2sgb24gdGhlIGZpcnN0IHJ1biBpZiBpdCdzIHJlYWxseSBuZWVkZWQuXFxuICAgIHJldHVybiB7XFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XFxuICAgICAgICBpZiAoY29uZGl0aW9uRm4oKSkge1xcbiAgICAgICAgICAvLyBIb29rIG5vdCBuZWVkZWQgKG9yIGl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBpdCBkdWVcXG4gICAgICAgICAgLy8gdG8gbWlzc2luZyBkZXBlbmRlbmN5KSwgcmVtb3ZlIGl0LlxcbiAgICAgICAgICBkZWxldGUgdGhpcy5nZXQ7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH0gLy8gSG9vayBuZWVkZWQ7IHJlZGVmaW5lIGl0IHNvIHRoYXQgdGhlIHN1cHBvcnQgdGVzdCBpcyBub3QgZXhlY3V0ZWQgYWdhaW4uXFxuXFxuXFxuICAgICAgICByZXR1cm4gKHRoaXMuZ2V0ID0gaG9va0ZuKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgICAgIH1cXG4gICAgfTtcXG4gIH1cXG5cXG4gIChmdW5jdGlvbiAoKSB7XFxuICAgIHZhciBwaXhlbFBvc2l0aW9uVmFsLFxcbiAgICAgICAgYm94U2l6aW5nUmVsaWFibGVWYWwsXFxuICAgICAgICBkb2NFbGVtID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxcbiAgICAgICAgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwiZGl2XFxcIiksXFxuICAgICAgICBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxcXCJkaXZcXFwiKTtcXG5cXG4gICAgaWYgKCFkaXYuc3R5bGUpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH0gLy8gU3VwcG9ydDogSUU5LTExK1xcbiAgICAvLyBTdHlsZSBvZiBjbG9uZWQgZWxlbWVudCBhZmZlY3RzIHNvdXJjZSBlbGVtZW50IGNsb25lZCAoIzg5MDgpXFxuXFxuXFxuICAgIGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFxcXCJjb250ZW50LWJveFxcXCI7XFxuICAgIGRpdi5jbG9uZU5vZGUodHJ1ZSkuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcXFwiXFxcIjtcXG4gICAgc3VwcG9ydC5jbGVhckNsb25lU3R5bGUgPSBkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPT09IFxcXCJjb250ZW50LWJveFxcXCI7XFxuICAgIGNvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gXFxcImJvcmRlcjowO3dpZHRoOjA7aGVpZ2h0OjA7dG9wOjA7bGVmdDotOTk5OXB4O21hcmdpbi10b3A6MXB4O1xcXCIgKyBcXFwicG9zaXRpb246YWJzb2x1dGVcXFwiO1xcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZGl2KTsgLy8gRXhlY3V0aW5nIGJvdGggcGl4ZWxQb3NpdGlvbiAmIGJveFNpemluZ1JlbGlhYmxlIHRlc3RzIHJlcXVpcmUgb25seSBvbmUgbGF5b3V0XFxuICAgIC8vIHNvIHRoZXkncmUgZXhlY3V0ZWQgYXQgdGhlIHNhbWUgdGltZSB0byBzYXZlIHRoZSBzZWNvbmQgY29tcHV0YXRpb24uXFxuXFxuICAgIGZ1bmN0aW9uIGNvbXB1dGVQaXhlbFBvc2l0aW9uQW5kQm94U2l6aW5nUmVsaWFibGUoKSB7XFxuICAgICAgZGl2LnN0eWxlLmNzc1RleHQgPSAvLyBTdXBwb3J0OiBGaXJlZm94PDI5LCBBbmRyb2lkIDIuM1xcbiAgICAgIC8vIFZlbmRvci1wcmVmaXggYm94LXNpemluZ1xcbiAgICAgIFxcXCItd2Via2l0LWJveC1zaXppbmc6Ym9yZGVyLWJveDstbW96LWJveC1zaXppbmc6Ym9yZGVyLWJveDtcXFwiICsgXFxcImJveC1zaXppbmc6Ym9yZGVyLWJveDtkaXNwbGF5OmJsb2NrO21hcmdpbi10b3A6MSU7dG9wOjElO1xcXCIgKyBcXFwiYm9yZGVyOjFweDtwYWRkaW5nOjFweDt3aWR0aDo0cHg7cG9zaXRpb246YWJzb2x1dGVcXFwiO1xcbiAgICAgIGRpdi5pbm5lckhUTUwgPSBcXFwiXFxcIjtcXG4gICAgICBkb2NFbGVtLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XFxuICAgICAgdmFyIGRpdlN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZGl2LCBudWxsKTtcXG4gICAgICBwaXhlbFBvc2l0aW9uVmFsID0gZGl2U3R5bGUudG9wICE9PSBcXFwiMSVcXFwiO1xcbiAgICAgIGJveFNpemluZ1JlbGlhYmxlVmFsID0gZGl2U3R5bGUud2lkdGggPT09IFxcXCI0cHhcXFwiO1xcbiAgICAgIGRvY0VsZW0ucmVtb3ZlQ2hpbGQoY29udGFpbmVyKTtcXG4gICAgfSAvLyBTdXBwb3J0OiBub2RlLmpzIGpzZG9tXFxuICAgIC8vIERvbid0IGFzc3VtZSB0aGF0IGdldENvbXB1dGVkU3R5bGUgaXMgYSBwcm9wZXJ0eSBvZiB0aGUgZ2xvYmFsIG9iamVjdFxcblxcblxcbiAgICBpZiAod2luZG93LmdldENvbXB1dGVkU3R5bGUpIHtcXG4gICAgICBqUXVlcnkuZXh0ZW5kKHN1cHBvcnQsIHtcXG4gICAgICAgIHBpeGVsUG9zaXRpb246IGZ1bmN0aW9uIHBpeGVsUG9zaXRpb24oKSB7XFxuICAgICAgICAgIC8vIFRoaXMgdGVzdCBpcyBleGVjdXRlZCBvbmx5IG9uY2UgYnV0IHdlIHN0aWxsIGRvIG1lbW9pemluZ1xcbiAgICAgICAgICAvLyBzaW5jZSB3ZSBjYW4gdXNlIHRoZSBib3hTaXppbmdSZWxpYWJsZSBwcmUtY29tcHV0aW5nLlxcbiAgICAgICAgICAvLyBObyBuZWVkIHRvIGNoZWNrIGlmIHRoZSB0ZXN0IHdhcyBhbHJlYWR5IHBlcmZvcm1lZCwgdGhvdWdoLlxcbiAgICAgICAgICBjb21wdXRlUGl4ZWxQb3NpdGlvbkFuZEJveFNpemluZ1JlbGlhYmxlKCk7XFxuICAgICAgICAgIHJldHVybiBwaXhlbFBvc2l0aW9uVmFsO1xcbiAgICAgICAgfSxcXG4gICAgICAgIGJveFNpemluZ1JlbGlhYmxlOiBmdW5jdGlvbiBib3hTaXppbmdSZWxpYWJsZSgpIHtcXG4gICAgICAgICAgaWYgKGJveFNpemluZ1JlbGlhYmxlVmFsID09IG51bGwpIHtcXG4gICAgICAgICAgICBjb21wdXRlUGl4ZWxQb3NpdGlvbkFuZEJveFNpemluZ1JlbGlhYmxlKCk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgcmV0dXJuIGJveFNpemluZ1JlbGlhYmxlVmFsO1xcbiAgICAgICAgfSxcXG4gICAgICAgIHJlbGlhYmxlTWFyZ2luUmlnaHQ6IGZ1bmN0aW9uIHJlbGlhYmxlTWFyZ2luUmlnaHQoKSB7XFxuICAgICAgICAgIC8vIFN1cHBvcnQ6IEFuZHJvaWQgMi4zXFxuICAgICAgICAgIC8vIENoZWNrIGlmIGRpdiB3aXRoIGV4cGxpY2l0IHdpZHRoIGFuZCBubyBtYXJnaW4tcmlnaHQgaW5jb3JyZWN0bHlcXG4gICAgICAgICAgLy8gZ2V0cyBjb21wdXRlZCBtYXJnaW4tcmlnaHQgYmFzZWQgb24gd2lkdGggb2YgY29udGFpbmVyLiAoIzMzMzMpXFxuICAgICAgICAgIC8vIFdlYktpdCBCdWcgMTMzNDMgLSBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgd3JvbmcgdmFsdWUgZm9yIG1hcmdpbi1yaWdodFxcbiAgICAgICAgICAvLyBUaGlzIHN1cHBvcnQgZnVuY3Rpb24gaXMgb25seSBleGVjdXRlZCBvbmNlIHNvIG5vIG1lbW9pemluZyBpcyBuZWVkZWQuXFxuICAgICAgICAgIHZhciByZXQsXFxuICAgICAgICAgICAgICBtYXJnaW5EaXYgPSBkaXYuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwiZGl2XFxcIikpOyAvLyBSZXNldCBDU1M6IGJveC1zaXppbmc7IGRpc3BsYXk7IG1hcmdpbjsgYm9yZGVyOyBwYWRkaW5nXFxuXFxuICAgICAgICAgIG1hcmdpbkRpdi5zdHlsZS5jc3NUZXh0ID0gZGl2LnN0eWxlLmNzc1RleHQgPSAvLyBTdXBwb3J0OiBGaXJlZm94PDI5LCBBbmRyb2lkIDIuM1xcbiAgICAgICAgICAvLyBWZW5kb3ItcHJlZml4IGJveC1zaXppbmdcXG4gICAgICAgICAgXFxcIi13ZWJraXQtYm94LXNpemluZzpjb250ZW50LWJveDstbW96LWJveC1zaXppbmc6Y29udGVudC1ib3g7XFxcIiArIFxcXCJib3gtc2l6aW5nOmNvbnRlbnQtYm94O2Rpc3BsYXk6YmxvY2s7bWFyZ2luOjA7Ym9yZGVyOjA7cGFkZGluZzowXFxcIjtcXG4gICAgICAgICAgbWFyZ2luRGl2LnN0eWxlLm1hcmdpblJpZ2h0ID0gbWFyZ2luRGl2LnN0eWxlLndpZHRoID0gXFxcIjBcXFwiO1xcbiAgICAgICAgICBkaXYuc3R5bGUud2lkdGggPSBcXFwiMXB4XFxcIjtcXG4gICAgICAgICAgZG9jRWxlbS5hcHBlbmRDaGlsZChjb250YWluZXIpO1xcbiAgICAgICAgICByZXQgPSAhcGFyc2VGbG9hdCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShtYXJnaW5EaXYsIG51bGwpLm1hcmdpblJpZ2h0KTtcXG4gICAgICAgICAgZG9jRWxlbS5yZW1vdmVDaGlsZChjb250YWluZXIpO1xcbiAgICAgICAgICBkaXYucmVtb3ZlQ2hpbGQobWFyZ2luRGl2KTtcXG4gICAgICAgICAgcmV0dXJuIHJldDtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgfVxcbiAgfSkoKTsgLy8gQSBtZXRob2QgZm9yIHF1aWNrbHkgc3dhcHBpbmcgaW4vb3V0IENTUyBwcm9wZXJ0aWVzIHRvIGdldCBjb3JyZWN0IGNhbGN1bGF0aW9ucy5cXG5cXG5cXG4gIGpRdWVyeS5zd2FwID0gZnVuY3Rpb24gKGVsZW0sIG9wdGlvbnMsIGNhbGxiYWNrLCBhcmdzKSB7XFxuICAgIHZhciByZXQsXFxuICAgICAgICBuYW1lLFxcbiAgICAgICAgb2xkID0ge307IC8vIFJlbWVtYmVyIHRoZSBvbGQgdmFsdWVzLCBhbmQgaW5zZXJ0IHRoZSBuZXcgb25lc1xcblxcbiAgICBmb3IgKG5hbWUgaW4gb3B0aW9ucykge1xcbiAgICAgIG9sZFtuYW1lXSA9IGVsZW0uc3R5bGVbbmFtZV07XFxuICAgICAgZWxlbS5zdHlsZVtuYW1lXSA9IG9wdGlvbnNbbmFtZV07XFxuICAgIH1cXG5cXG4gICAgcmV0ID0gY2FsbGJhY2suYXBwbHkoZWxlbSwgYXJncyB8fCBbXSk7IC8vIFJldmVydCB0aGUgb2xkIHZhbHVlc1xcblxcbiAgICBmb3IgKG5hbWUgaW4gb3B0aW9ucykge1xcbiAgICAgIGVsZW0uc3R5bGVbbmFtZV0gPSBvbGRbbmFtZV07XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHJldDtcXG4gIH07XFxuXFxuICB2YXIgLy8gU3dhcHBhYmxlIGlmIGRpc3BsYXkgaXMgbm9uZSBvciBzdGFydHMgd2l0aCB0YWJsZSBleGNlcHQgXFxcInRhYmxlXFxcIiwgXFxcInRhYmxlLWNlbGxcXFwiLCBvciBcXFwidGFibGUtY2FwdGlvblxcXCJcXG4gIC8vIFNlZSBoZXJlIGZvciBkaXNwbGF5IHZhbHVlczogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9DU1MvZGlzcGxheVxcbiAgcmRpc3BsYXlzd2FwID0gL14obm9uZXx0YWJsZSg/IS1jW2VhXSkuKykvLFxcbiAgICAgIHJudW1zcGxpdCA9IG5ldyBSZWdFeHAoXFxcIl4oXFxcIiArIHBudW0gKyBcXFwiKSguKikkXFxcIiwgXFxcImlcXFwiKSxcXG4gICAgICBycmVsTnVtID0gbmV3IFJlZ0V4cChcXFwiXihbKy1dKT0oXFxcIiArIHBudW0gKyBcXFwiKVxcXCIsIFxcXCJpXFxcIiksXFxuICAgICAgY3NzU2hvdyA9IHtcXG4gICAgcG9zaXRpb246IFxcXCJhYnNvbHV0ZVxcXCIsXFxuICAgIHZpc2liaWxpdHk6IFxcXCJoaWRkZW5cXFwiLFxcbiAgICBkaXNwbGF5OiBcXFwiYmxvY2tcXFwiXFxuICB9LFxcbiAgICAgIGNzc05vcm1hbFRyYW5zZm9ybSA9IHtcXG4gICAgbGV0dGVyU3BhY2luZzogXFxcIjBcXFwiLFxcbiAgICBmb250V2VpZ2h0OiBcXFwiNDAwXFxcIlxcbiAgfSxcXG4gICAgICBjc3NQcmVmaXhlcyA9IFtcXFwiV2Via2l0XFxcIiwgXFxcIk9cXFwiLCBcXFwiTW96XFxcIiwgXFxcIm1zXFxcIl07IC8vIFJldHVybiBhIGNzcyBwcm9wZXJ0eSBtYXBwZWQgdG8gYSBwb3RlbnRpYWxseSB2ZW5kb3IgcHJlZml4ZWQgcHJvcGVydHlcXG5cXG4gIGZ1bmN0aW9uIHZlbmRvclByb3BOYW1lKHN0eWxlLCBuYW1lKSB7XFxuICAgIC8vIFNob3J0Y3V0IGZvciBuYW1lcyB0aGF0IGFyZSBub3QgdmVuZG9yIHByZWZpeGVkXFxuICAgIGlmIChuYW1lIGluIHN0eWxlKSB7XFxuICAgICAgcmV0dXJuIG5hbWU7XFxuICAgIH0gLy8gQ2hlY2sgZm9yIHZlbmRvciBwcmVmaXhlZCBuYW1lc1xcblxcblxcbiAgICB2YXIgY2FwTmFtZSA9IG5hbWVbMF0udG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSksXFxuICAgICAgICBvcmlnTmFtZSA9IG5hbWUsXFxuICAgICAgICBpID0gY3NzUHJlZml4ZXMubGVuZ3RoO1xcblxcbiAgICB3aGlsZSAoaS0tKSB7XFxuICAgICAgbmFtZSA9IGNzc1ByZWZpeGVzW2ldICsgY2FwTmFtZTtcXG5cXG4gICAgICBpZiAobmFtZSBpbiBzdHlsZSkge1xcbiAgICAgICAgcmV0dXJuIG5hbWU7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHJldHVybiBvcmlnTmFtZTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIHNldFBvc2l0aXZlTnVtYmVyKGVsZW0sIHZhbHVlLCBzdWJ0cmFjdCkge1xcbiAgICB2YXIgbWF0Y2hlcyA9IHJudW1zcGxpdC5leGVjKHZhbHVlKTtcXG4gICAgcmV0dXJuIG1hdGNoZXMgPyAvLyBHdWFyZCBhZ2FpbnN0IHVuZGVmaW5lZCBcXFwic3VidHJhY3RcXFwiLCBlLmcuLCB3aGVuIHVzZWQgYXMgaW4gY3NzSG9va3NcXG4gICAgTWF0aC5tYXgoMCwgbWF0Y2hlc1sxXSAtIChzdWJ0cmFjdCB8fCAwKSkgKyAobWF0Y2hlc1syXSB8fCBcXFwicHhcXFwiKSA6IHZhbHVlO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gYXVnbWVudFdpZHRoT3JIZWlnaHQoZWxlbSwgbmFtZSwgZXh0cmEsIGlzQm9yZGVyQm94LCBzdHlsZXMpIHtcXG4gICAgdmFyIGkgPSBleHRyYSA9PT0gKGlzQm9yZGVyQm94ID8gXFxcImJvcmRlclxcXCIgOiBcXFwiY29udGVudFxcXCIpID8gLy8gSWYgd2UgYWxyZWFkeSBoYXZlIHRoZSByaWdodCBtZWFzdXJlbWVudCwgYXZvaWQgYXVnbWVudGF0aW9uXFxuICAgIDQgOiAvLyBPdGhlcndpc2UgaW5pdGlhbGl6ZSBmb3IgaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCBwcm9wZXJ0aWVzXFxuICAgIG5hbWUgPT09IFxcXCJ3aWR0aFxcXCIgPyAxIDogMCxcXG4gICAgICAgIHZhbCA9IDA7XFxuXFxuICAgIGZvciAoOyBpIDwgNDsgaSArPSAyKSB7XFxuICAgICAgLy8gQm90aCBib3ggbW9kZWxzIGV4Y2x1ZGUgbWFyZ2luLCBzbyBhZGQgaXQgaWYgd2Ugd2FudCBpdFxcbiAgICAgIGlmIChleHRyYSA9PT0gXFxcIm1hcmdpblxcXCIpIHtcXG4gICAgICAgIHZhbCArPSBqUXVlcnkuY3NzKGVsZW0sIGV4dHJhICsgY3NzRXhwYW5kW2ldLCB0cnVlLCBzdHlsZXMpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoaXNCb3JkZXJCb3gpIHtcXG4gICAgICAgIC8vIGJvcmRlci1ib3ggaW5jbHVkZXMgcGFkZGluZywgc28gcmVtb3ZlIGl0IGlmIHdlIHdhbnQgY29udGVudFxcbiAgICAgICAgaWYgKGV4dHJhID09PSBcXFwiY29udGVudFxcXCIpIHtcXG4gICAgICAgICAgdmFsIC09IGpRdWVyeS5jc3MoZWxlbSwgXFxcInBhZGRpbmdcXFwiICsgY3NzRXhwYW5kW2ldLCB0cnVlLCBzdHlsZXMpO1xcbiAgICAgICAgfSAvLyBBdCB0aGlzIHBvaW50LCBleHRyYSBpc24ndCBib3JkZXIgbm9yIG1hcmdpbiwgc28gcmVtb3ZlIGJvcmRlclxcblxcblxcbiAgICAgICAgaWYgKGV4dHJhICE9PSBcXFwibWFyZ2luXFxcIikge1xcbiAgICAgICAgICB2YWwgLT0galF1ZXJ5LmNzcyhlbGVtLCBcXFwiYm9yZGVyXFxcIiArIGNzc0V4cGFuZFtpXSArIFxcXCJXaWR0aFxcXCIsIHRydWUsIHN0eWxlcyk7XFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIC8vIEF0IHRoaXMgcG9pbnQsIGV4dHJhIGlzbid0IGNvbnRlbnQsIHNvIGFkZCBwYWRkaW5nXFxuICAgICAgICB2YWwgKz0galF1ZXJ5LmNzcyhlbGVtLCBcXFwicGFkZGluZ1xcXCIgKyBjc3NFeHBhbmRbaV0sIHRydWUsIHN0eWxlcyk7IC8vIEF0IHRoaXMgcG9pbnQsIGV4dHJhIGlzbid0IGNvbnRlbnQgbm9yIHBhZGRpbmcsIHNvIGFkZCBib3JkZXJcXG5cXG4gICAgICAgIGlmIChleHRyYSAhPT0gXFxcInBhZGRpbmdcXFwiKSB7XFxuICAgICAgICAgIHZhbCArPSBqUXVlcnkuY3NzKGVsZW0sIFxcXCJib3JkZXJcXFwiICsgY3NzRXhwYW5kW2ldICsgXFxcIldpZHRoXFxcIiwgdHJ1ZSwgc3R5bGVzKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHZhbDtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGdldFdpZHRoT3JIZWlnaHQoZWxlbSwgbmFtZSwgZXh0cmEpIHtcXG4gICAgLy8gU3RhcnQgd2l0aCBvZmZzZXQgcHJvcGVydHksIHdoaWNoIGlzIGVxdWl2YWxlbnQgdG8gdGhlIGJvcmRlci1ib3ggdmFsdWVcXG4gICAgdmFyIHZhbHVlSXNCb3JkZXJCb3ggPSB0cnVlLFxcbiAgICAgICAgdmFsID0gbmFtZSA9PT0gXFxcIndpZHRoXFxcIiA/IGVsZW0ub2Zmc2V0V2lkdGggOiBlbGVtLm9mZnNldEhlaWdodCxcXG4gICAgICAgIHN0eWxlcyA9IGdldFN0eWxlcyhlbGVtKSxcXG4gICAgICAgIGlzQm9yZGVyQm94ID0galF1ZXJ5LmNzcyhlbGVtLCBcXFwiYm94U2l6aW5nXFxcIiwgZmFsc2UsIHN0eWxlcykgPT09IFxcXCJib3JkZXItYm94XFxcIjsgLy8gU29tZSBub24taHRtbCBlbGVtZW50cyByZXR1cm4gdW5kZWZpbmVkIGZvciBvZmZzZXRXaWR0aCwgc28gY2hlY2sgZm9yIG51bGwvdW5kZWZpbmVkXFxuICAgIC8vIHN2ZyAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY0OTI4NVxcbiAgICAvLyBNYXRoTUwgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD00OTE2NjhcXG5cXG4gICAgaWYgKHZhbCA8PSAwIHx8IHZhbCA9PSBudWxsKSB7XFxuICAgICAgLy8gRmFsbCBiYWNrIHRvIGNvbXB1dGVkIHRoZW4gdW5jb21wdXRlZCBjc3MgaWYgbmVjZXNzYXJ5XFxuICAgICAgdmFsID0gY3VyQ1NTKGVsZW0sIG5hbWUsIHN0eWxlcyk7XFxuXFxuICAgICAgaWYgKHZhbCA8IDAgfHwgdmFsID09IG51bGwpIHtcXG4gICAgICAgIHZhbCA9IGVsZW0uc3R5bGVbbmFtZV07XFxuICAgICAgfSAvLyBDb21wdXRlZCB1bml0IGlzIG5vdCBwaXhlbHMuIFN0b3AgaGVyZSBhbmQgcmV0dXJuLlxcblxcblxcbiAgICAgIGlmIChybnVtbm9ucHgudGVzdCh2YWwpKSB7XFxuICAgICAgICByZXR1cm4gdmFsO1xcbiAgICAgIH0gLy8gQ2hlY2sgZm9yIHN0eWxlIGluIGNhc2UgYSBicm93c2VyIHdoaWNoIHJldHVybnMgdW5yZWxpYWJsZSB2YWx1ZXNcXG4gICAgICAvLyBmb3IgZ2V0Q29tcHV0ZWRTdHlsZSBzaWxlbnRseSBmYWxscyBiYWNrIHRvIHRoZSByZWxpYWJsZSBlbGVtLnN0eWxlXFxuXFxuXFxuICAgICAgdmFsdWVJc0JvcmRlckJveCA9IGlzQm9yZGVyQm94ICYmIChzdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlKCkgfHwgdmFsID09PSBlbGVtLnN0eWxlW25hbWVdKTsgLy8gTm9ybWFsaXplIFxcXCJcXFwiLCBhdXRvLCBhbmQgcHJlcGFyZSBmb3IgZXh0cmFcXG5cXG4gICAgICB2YWwgPSBwYXJzZUZsb2F0KHZhbCkgfHwgMDtcXG4gICAgfSAvLyBVc2UgdGhlIGFjdGl2ZSBib3gtc2l6aW5nIG1vZGVsIHRvIGFkZC9zdWJ0cmFjdCBpcnJlbGV2YW50IHN0eWxlc1xcblxcblxcbiAgICByZXR1cm4gdmFsICsgYXVnbWVudFdpZHRoT3JIZWlnaHQoZWxlbSwgbmFtZSwgZXh0cmEgfHwgKGlzQm9yZGVyQm94ID8gXFxcImJvcmRlclxcXCIgOiBcXFwiY29udGVudFxcXCIpLCB2YWx1ZUlzQm9yZGVyQm94LCBzdHlsZXMpICsgXFxcInB4XFxcIjtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIHNob3dIaWRlKGVsZW1lbnRzLCBzaG93KSB7XFxuICAgIHZhciBkaXNwbGF5LFxcbiAgICAgICAgZWxlbSxcXG4gICAgICAgIGhpZGRlbixcXG4gICAgICAgIHZhbHVlcyA9IFtdLFxcbiAgICAgICAgaW5kZXggPSAwLFxcbiAgICAgICAgbGVuZ3RoID0gZWxlbWVudHMubGVuZ3RoO1xcblxcbiAgICBmb3IgKDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcXG4gICAgICBlbGVtID0gZWxlbWVudHNbaW5kZXhdO1xcblxcbiAgICAgIGlmICghZWxlbS5zdHlsZSkge1xcbiAgICAgICAgY29udGludWU7XFxuICAgICAgfVxcblxcbiAgICAgIHZhbHVlc1tpbmRleF0gPSBkYXRhX3ByaXYuZ2V0KGVsZW0sIFxcXCJvbGRkaXNwbGF5XFxcIik7XFxuICAgICAgZGlzcGxheSA9IGVsZW0uc3R5bGUuZGlzcGxheTtcXG5cXG4gICAgICBpZiAoc2hvdykge1xcbiAgICAgICAgLy8gUmVzZXQgdGhlIGlubGluZSBkaXNwbGF5IG9mIHRoaXMgZWxlbWVudCB0byBsZWFybiBpZiBpdCBpc1xcbiAgICAgICAgLy8gYmVpbmcgaGlkZGVuIGJ5IGNhc2NhZGVkIHJ1bGVzIG9yIG5vdFxcbiAgICAgICAgaWYgKCF2YWx1ZXNbaW5kZXhdICYmIGRpc3BsYXkgPT09IFxcXCJub25lXFxcIikge1xcbiAgICAgICAgICBlbGVtLnN0eWxlLmRpc3BsYXkgPSBcXFwiXFxcIjtcXG4gICAgICAgIH0gLy8gU2V0IGVsZW1lbnRzIHdoaWNoIGhhdmUgYmVlbiBvdmVycmlkZGVuIHdpdGggZGlzcGxheTogbm9uZVxcbiAgICAgICAgLy8gaW4gYSBzdHlsZXNoZWV0IHRvIHdoYXRldmVyIHRoZSBkZWZhdWx0IGJyb3dzZXIgc3R5bGUgaXNcXG4gICAgICAgIC8vIGZvciBzdWNoIGFuIGVsZW1lbnRcXG5cXG5cXG4gICAgICAgIGlmIChlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFxcXCJcXFwiICYmIGlzSGlkZGVuKGVsZW0pKSB7XFxuICAgICAgICAgIHZhbHVlc1tpbmRleF0gPSBkYXRhX3ByaXYuYWNjZXNzKGVsZW0sIFxcXCJvbGRkaXNwbGF5XFxcIiwgZGVmYXVsdERpc3BsYXkoZWxlbS5ub2RlTmFtZSkpO1xcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBoaWRkZW4gPSBpc0hpZGRlbihlbGVtKTtcXG5cXG4gICAgICAgIGlmIChkaXNwbGF5ICE9PSBcXFwibm9uZVxcXCIgfHwgIWhpZGRlbikge1xcbiAgICAgICAgICBkYXRhX3ByaXYuc2V0KGVsZW0sIFxcXCJvbGRkaXNwbGF5XFxcIiwgaGlkZGVuID8gZGlzcGxheSA6IGpRdWVyeS5jc3MoZWxlbSwgXFxcImRpc3BsYXlcXFwiKSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9IC8vIFNldCB0aGUgZGlzcGxheSBvZiBtb3N0IG9mIHRoZSBlbGVtZW50cyBpbiBhIHNlY29uZCBsb29wXFxuICAgIC8vIHRvIGF2b2lkIHRoZSBjb25zdGFudCByZWZsb3dcXG5cXG5cXG4gICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XFxuICAgICAgZWxlbSA9IGVsZW1lbnRzW2luZGV4XTtcXG5cXG4gICAgICBpZiAoIWVsZW0uc3R5bGUpIHtcXG4gICAgICAgIGNvbnRpbnVlO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIXNob3cgfHwgZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcXFwibm9uZVxcXCIgfHwgZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcXFwiXFxcIikge1xcbiAgICAgICAgZWxlbS5zdHlsZS5kaXNwbGF5ID0gc2hvdyA/IHZhbHVlc1tpbmRleF0gfHwgXFxcIlxcXCIgOiBcXFwibm9uZVxcXCI7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHJldHVybiBlbGVtZW50cztcXG4gIH1cXG5cXG4gIGpRdWVyeS5leHRlbmQoe1xcbiAgICAvLyBBZGQgaW4gc3R5bGUgcHJvcGVydHkgaG9va3MgZm9yIG92ZXJyaWRpbmcgdGhlIGRlZmF1bHRcXG4gICAgLy8gYmVoYXZpb3Igb2YgZ2V0dGluZyBhbmQgc2V0dGluZyBhIHN0eWxlIHByb3BlcnR5XFxuICAgIGNzc0hvb2tzOiB7XFxuICAgICAgb3BhY2l0eToge1xcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoZWxlbSwgY29tcHV0ZWQpIHtcXG4gICAgICAgICAgaWYgKGNvbXB1dGVkKSB7XFxuICAgICAgICAgICAgLy8gV2Ugc2hvdWxkIGFsd2F5cyBnZXQgYSBudW1iZXIgYmFjayBmcm9tIG9wYWNpdHlcXG4gICAgICAgICAgICB2YXIgcmV0ID0gY3VyQ1NTKGVsZW0sIFxcXCJvcGFjaXR5XFxcIik7XFxuICAgICAgICAgICAgcmV0dXJuIHJldCA9PT0gXFxcIlxcXCIgPyBcXFwiMVxcXCIgOiByZXQ7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH0sXFxuICAgIC8vIERvbid0IGF1dG9tYXRpY2FsbHkgYWRkIFxcXCJweFxcXCIgdG8gdGhlc2UgcG9zc2libHktdW5pdGxlc3MgcHJvcGVydGllc1xcbiAgICBjc3NOdW1iZXI6IHtcXG4gICAgICBcXFwiY29sdW1uQ291bnRcXFwiOiB0cnVlLFxcbiAgICAgIFxcXCJmaWxsT3BhY2l0eVxcXCI6IHRydWUsXFxuICAgICAgXFxcImZsZXhHcm93XFxcIjogdHJ1ZSxcXG4gICAgICBcXFwiZmxleFNocmlua1xcXCI6IHRydWUsXFxuICAgICAgXFxcImZvbnRXZWlnaHRcXFwiOiB0cnVlLFxcbiAgICAgIFxcXCJsaW5lSGVpZ2h0XFxcIjogdHJ1ZSxcXG4gICAgICBcXFwib3BhY2l0eVxcXCI6IHRydWUsXFxuICAgICAgXFxcIm9yZGVyXFxcIjogdHJ1ZSxcXG4gICAgICBcXFwib3JwaGFuc1xcXCI6IHRydWUsXFxuICAgICAgXFxcIndpZG93c1xcXCI6IHRydWUsXFxuICAgICAgXFxcInpJbmRleFxcXCI6IHRydWUsXFxuICAgICAgXFxcInpvb21cXFwiOiB0cnVlXFxuICAgIH0sXFxuICAgIC8vIEFkZCBpbiBwcm9wZXJ0aWVzIHdob3NlIG5hbWVzIHlvdSB3aXNoIHRvIGZpeCBiZWZvcmVcXG4gICAgLy8gc2V0dGluZyBvciBnZXR0aW5nIHRoZSB2YWx1ZVxcbiAgICBjc3NQcm9wczoge1xcbiAgICAgIFxcXCJmbG9hdFxcXCI6IFxcXCJjc3NGbG9hdFxcXCJcXG4gICAgfSxcXG4gICAgLy8gR2V0IGFuZCBzZXQgdGhlIHN0eWxlIHByb3BlcnR5IG9uIGEgRE9NIE5vZGVcXG4gICAgc3R5bGU6IGZ1bmN0aW9uIHN0eWxlKGVsZW0sIG5hbWUsIHZhbHVlLCBleHRyYSkge1xcbiAgICAgIC8vIERvbid0IHNldCBzdHlsZXMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xcbiAgICAgIGlmICghZWxlbSB8fCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggfHwgIWVsZW0uc3R5bGUpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9IC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxcblxcblxcbiAgICAgIHZhciByZXQsXFxuICAgICAgICAgIHR5cGUsXFxuICAgICAgICAgIGhvb2tzLFxcbiAgICAgICAgICBvcmlnTmFtZSA9IGpRdWVyeS5jYW1lbENhc2UobmFtZSksXFxuICAgICAgICAgIHN0eWxlID0gZWxlbS5zdHlsZTtcXG4gICAgICBuYW1lID0galF1ZXJ5LmNzc1Byb3BzW29yaWdOYW1lXSB8fCAoalF1ZXJ5LmNzc1Byb3BzW29yaWdOYW1lXSA9IHZlbmRvclByb3BOYW1lKHN0eWxlLCBvcmlnTmFtZSkpOyAvLyBHZXRzIGhvb2sgZm9yIHRoZSBwcmVmaXhlZCB2ZXJzaW9uLCB0aGVuIHVucHJlZml4ZWQgdmVyc2lvblxcblxcbiAgICAgIGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzW25hbWVdIHx8IGpRdWVyeS5jc3NIb29rc1tvcmlnTmFtZV07IC8vIENoZWNrIGlmIHdlJ3JlIHNldHRpbmcgYSB2YWx1ZVxcblxcbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICB0eXBlID0gX3R5cGVvZih2YWx1ZSk7IC8vIENvbnZlcnQgXFxcIis9XFxcIiBvciBcXFwiLT1cXFwiIHRvIHJlbGF0aXZlIG51bWJlcnMgKCM3MzQ1KVxcblxcbiAgICAgICAgaWYgKHR5cGUgPT09IFxcXCJzdHJpbmdcXFwiICYmIChyZXQgPSBycmVsTnVtLmV4ZWModmFsdWUpKSkge1xcbiAgICAgICAgICB2YWx1ZSA9IChyZXRbMV0gKyAxKSAqIHJldFsyXSArIHBhcnNlRmxvYXQoalF1ZXJ5LmNzcyhlbGVtLCBuYW1lKSk7IC8vIEZpeGVzIGJ1ZyAjOTIzN1xcblxcbiAgICAgICAgICB0eXBlID0gXFxcIm51bWJlclxcXCI7XFxuICAgICAgICB9IC8vIE1ha2Ugc3VyZSB0aGF0IG51bGwgYW5kIE5hTiB2YWx1ZXMgYXJlbid0IHNldCAoIzcxMTYpXFxuXFxuXFxuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSAhPT0gdmFsdWUpIHtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfSAvLyBJZiBhIG51bWJlciwgYWRkICdweCcgdG8gdGhlIChleGNlcHQgZm9yIGNlcnRhaW4gQ1NTIHByb3BlcnRpZXMpXFxuXFxuXFxuICAgICAgICBpZiAodHlwZSA9PT0gXFxcIm51bWJlclxcXCIgJiYgIWpRdWVyeS5jc3NOdW1iZXJbb3JpZ05hbWVdKSB7XFxuICAgICAgICAgIHZhbHVlICs9IFxcXCJweFxcXCI7XFxuICAgICAgICB9IC8vIFN1cHBvcnQ6IElFOS0xMStcXG4gICAgICAgIC8vIGJhY2tncm91bmQtKiBwcm9wcyBhZmZlY3Qgb3JpZ2luYWwgY2xvbmUncyB2YWx1ZXNcXG5cXG5cXG4gICAgICAgIGlmICghc3VwcG9ydC5jbGVhckNsb25lU3R5bGUgJiYgdmFsdWUgPT09IFxcXCJcXFwiICYmIG5hbWUuaW5kZXhPZihcXFwiYmFja2dyb3VuZFxcXCIpID09PSAwKSB7XFxuICAgICAgICAgIHN0eWxlW25hbWVdID0gXFxcImluaGVyaXRcXFwiO1xcbiAgICAgICAgfSAvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkLCB1c2UgdGhhdCB2YWx1ZSwgb3RoZXJ3aXNlIGp1c3Qgc2V0IHRoZSBzcGVjaWZpZWQgdmFsdWVcXG5cXG5cXG4gICAgICAgIGlmICghaG9va3MgfHwgIShcXFwic2V0XFxcIiBpbiBob29rcykgfHwgKHZhbHVlID0gaG9va3Muc2V0KGVsZW0sIHZhbHVlLCBleHRyYSkpICE9PSB1bmRlZmluZWQpIHtcXG4gICAgICAgICAgc3R5bGVbbmFtZV0gPSB2YWx1ZTtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgLy8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIG5vbi1jb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXFxuICAgICAgICBpZiAoaG9va3MgJiYgXFxcImdldFxcXCIgaW4gaG9va3MgJiYgKHJldCA9IGhvb2tzLmdldChlbGVtLCBmYWxzZSwgZXh0cmEpKSAhPT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgIHJldHVybiByZXQ7XFxuICAgICAgICB9IC8vIE90aGVyd2lzZSBqdXN0IGdldCB0aGUgdmFsdWUgZnJvbSB0aGUgc3R5bGUgb2JqZWN0XFxuXFxuXFxuICAgICAgICByZXR1cm4gc3R5bGVbbmFtZV07XFxuICAgICAgfVxcbiAgICB9LFxcbiAgICBjc3M6IGZ1bmN0aW9uIGNzcyhlbGVtLCBuYW1lLCBleHRyYSwgc3R5bGVzKSB7XFxuICAgICAgdmFyIHZhbCxcXG4gICAgICAgICAgbnVtLFxcbiAgICAgICAgICBob29rcyxcXG4gICAgICAgICAgb3JpZ05hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKG5hbWUpOyAvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWVcXG5cXG4gICAgICBuYW1lID0galF1ZXJ5LmNzc1Byb3BzW29yaWdOYW1lXSB8fCAoalF1ZXJ5LmNzc1Byb3BzW29yaWdOYW1lXSA9IHZlbmRvclByb3BOYW1lKGVsZW0uc3R5bGUsIG9yaWdOYW1lKSk7IC8vIFRyeSBwcmVmaXhlZCBuYW1lIGZvbGxvd2VkIGJ5IHRoZSB1bnByZWZpeGVkIG5hbWVcXG5cXG4gICAgICBob29rcyA9IGpRdWVyeS5jc3NIb29rc1tuYW1lXSB8fCBqUXVlcnkuY3NzSG9va3Nbb3JpZ05hbWVdOyAvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxcblxcbiAgICAgIGlmIChob29rcyAmJiBcXFwiZ2V0XFxcIiBpbiBob29rcykge1xcbiAgICAgICAgdmFsID0gaG9va3MuZ2V0KGVsZW0sIHRydWUsIGV4dHJhKTtcXG4gICAgICB9IC8vIE90aGVyd2lzZSwgaWYgYSB3YXkgdG8gZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBleGlzdHMsIHVzZSB0aGF0XFxuXFxuXFxuICAgICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICB2YWwgPSBjdXJDU1MoZWxlbSwgbmFtZSwgc3R5bGVzKTtcXG4gICAgICB9IC8vIENvbnZlcnQgXFxcIm5vcm1hbFxcXCIgdG8gY29tcHV0ZWQgdmFsdWVcXG5cXG5cXG4gICAgICBpZiAodmFsID09PSBcXFwibm9ybWFsXFxcIiAmJiBuYW1lIGluIGNzc05vcm1hbFRyYW5zZm9ybSkge1xcbiAgICAgICAgdmFsID0gY3NzTm9ybWFsVHJhbnNmb3JtW25hbWVdO1xcbiAgICAgIH0gLy8gTWFrZSBudW1lcmljIGlmIGZvcmNlZCBvciBhIHF1YWxpZmllciB3YXMgcHJvdmlkZWQgYW5kIHZhbCBsb29rcyBudW1lcmljXFxuXFxuXFxuICAgICAgaWYgKGV4dHJhID09PSBcXFwiXFxcIiB8fCBleHRyYSkge1xcbiAgICAgICAgbnVtID0gcGFyc2VGbG9hdCh2YWwpO1xcbiAgICAgICAgcmV0dXJuIGV4dHJhID09PSB0cnVlIHx8IGpRdWVyeS5pc051bWVyaWMobnVtKSA/IG51bSB8fCAwIDogdmFsO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gdmFsO1xcbiAgICB9XFxuICB9KTtcXG4gIGpRdWVyeS5lYWNoKFtcXFwiaGVpZ2h0XFxcIiwgXFxcIndpZHRoXFxcIl0sIGZ1bmN0aW9uIChpLCBuYW1lKSB7XFxuICAgIGpRdWVyeS5jc3NIb29rc1tuYW1lXSA9IHtcXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldChlbGVtLCBjb21wdXRlZCwgZXh0cmEpIHtcXG4gICAgICAgIGlmIChjb21wdXRlZCkge1xcbiAgICAgICAgICAvLyBDZXJ0YWluIGVsZW1lbnRzIGNhbiBoYXZlIGRpbWVuc2lvbiBpbmZvIGlmIHdlIGludmlzaWJseSBzaG93IHRoZW1cXG4gICAgICAgICAgLy8gYnV0IGl0IG11c3QgaGF2ZSBhIGN1cnJlbnQgZGlzcGxheSBzdHlsZSB0aGF0IHdvdWxkIGJlbmVmaXRcXG4gICAgICAgICAgcmV0dXJuIHJkaXNwbGF5c3dhcC50ZXN0KGpRdWVyeS5jc3MoZWxlbSwgXFxcImRpc3BsYXlcXFwiKSkgJiYgZWxlbS5vZmZzZXRXaWR0aCA9PT0gMCA/IGpRdWVyeS5zd2FwKGVsZW0sIGNzc1Nob3csIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICByZXR1cm4gZ2V0V2lkdGhPckhlaWdodChlbGVtLCBuYW1lLCBleHRyYSk7XFxuICAgICAgICAgIH0pIDogZ2V0V2lkdGhPckhlaWdodChlbGVtLCBuYW1lLCBleHRyYSk7XFxuICAgICAgICB9XFxuICAgICAgfSxcXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldChlbGVtLCB2YWx1ZSwgZXh0cmEpIHtcXG4gICAgICAgIHZhciBzdHlsZXMgPSBleHRyYSAmJiBnZXRTdHlsZXMoZWxlbSk7XFxuICAgICAgICByZXR1cm4gc2V0UG9zaXRpdmVOdW1iZXIoZWxlbSwgdmFsdWUsIGV4dHJhID8gYXVnbWVudFdpZHRoT3JIZWlnaHQoZWxlbSwgbmFtZSwgZXh0cmEsIGpRdWVyeS5jc3MoZWxlbSwgXFxcImJveFNpemluZ1xcXCIsIGZhbHNlLCBzdHlsZXMpID09PSBcXFwiYm9yZGVyLWJveFxcXCIsIHN0eWxlcykgOiAwKTtcXG4gICAgICB9XFxuICAgIH07XFxuICB9KTsgLy8gU3VwcG9ydDogQW5kcm9pZCAyLjNcXG5cXG4gIGpRdWVyeS5jc3NIb29rcy5tYXJnaW5SaWdodCA9IGFkZEdldEhvb2tJZihzdXBwb3J0LnJlbGlhYmxlTWFyZ2luUmlnaHQsIGZ1bmN0aW9uIChlbGVtLCBjb21wdXRlZCkge1xcbiAgICBpZiAoY29tcHV0ZWQpIHtcXG4gICAgICByZXR1cm4galF1ZXJ5LnN3YXAoZWxlbSwge1xcbiAgICAgICAgXFxcImRpc3BsYXlcXFwiOiBcXFwiaW5saW5lLWJsb2NrXFxcIlxcbiAgICAgIH0sIGN1ckNTUywgW2VsZW0sIFxcXCJtYXJnaW5SaWdodFxcXCJdKTtcXG4gICAgfVxcbiAgfSk7IC8vIFRoZXNlIGhvb2tzIGFyZSB1c2VkIGJ5IGFuaW1hdGUgdG8gZXhwYW5kIHByb3BlcnRpZXNcXG5cXG4gIGpRdWVyeS5lYWNoKHtcXG4gICAgbWFyZ2luOiBcXFwiXFxcIixcXG4gICAgcGFkZGluZzogXFxcIlxcXCIsXFxuICAgIGJvcmRlcjogXFxcIldpZHRoXFxcIlxcbiAgfSwgZnVuY3Rpb24gKHByZWZpeCwgc3VmZml4KSB7XFxuICAgIGpRdWVyeS5jc3NIb29rc1twcmVmaXggKyBzdWZmaXhdID0ge1xcbiAgICAgIGV4cGFuZDogZnVuY3Rpb24gZXhwYW5kKHZhbHVlKSB7XFxuICAgICAgICB2YXIgaSA9IDAsXFxuICAgICAgICAgICAgZXhwYW5kZWQgPSB7fSxcXG4gICAgICAgICAgICAvLyBBc3N1bWVzIGEgc2luZ2xlIG51bWJlciBpZiBub3QgYSBzdHJpbmdcXG4gICAgICAgIHBhcnRzID0gdHlwZW9mIHZhbHVlID09PSBcXFwic3RyaW5nXFxcIiA/IHZhbHVlLnNwbGl0KFxcXCIgXFxcIikgOiBbdmFsdWVdO1xcblxcbiAgICAgICAgZm9yICg7IGkgPCA0OyBpKyspIHtcXG4gICAgICAgICAgZXhwYW5kZWRbcHJlZml4ICsgY3NzRXhwYW5kW2ldICsgc3VmZml4XSA9IHBhcnRzW2ldIHx8IHBhcnRzW2kgLSAyXSB8fCBwYXJ0c1swXTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiBleHBhbmRlZDtcXG4gICAgICB9XFxuICAgIH07XFxuXFxuICAgIGlmICghcm1hcmdpbi50ZXN0KHByZWZpeCkpIHtcXG4gICAgICBqUXVlcnkuY3NzSG9va3NbcHJlZml4ICsgc3VmZml4XS5zZXQgPSBzZXRQb3NpdGl2ZU51bWJlcjtcXG4gICAgfVxcbiAgfSk7XFxuICBqUXVlcnkuZm4uZXh0ZW5kKHtcXG4gICAgY3NzOiBmdW5jdGlvbiBjc3MobmFtZSwgdmFsdWUpIHtcXG4gICAgICByZXR1cm4gYWNjZXNzKHRoaXMsIGZ1bmN0aW9uIChlbGVtLCBuYW1lLCB2YWx1ZSkge1xcbiAgICAgICAgdmFyIHN0eWxlcyxcXG4gICAgICAgICAgICBsZW4sXFxuICAgICAgICAgICAgbWFwID0ge30sXFxuICAgICAgICAgICAgaSA9IDA7XFxuXFxuICAgICAgICBpZiAoalF1ZXJ5LmlzQXJyYXkobmFtZSkpIHtcXG4gICAgICAgICAgc3R5bGVzID0gZ2V0U3R5bGVzKGVsZW0pO1xcbiAgICAgICAgICBsZW4gPSBuYW1lLmxlbmd0aDtcXG5cXG4gICAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xcbiAgICAgICAgICAgIG1hcFtuYW1lW2ldXSA9IGpRdWVyeS5jc3MoZWxlbSwgbmFtZVtpXSwgZmFsc2UsIHN0eWxlcyk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgcmV0dXJuIG1hcDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID8galF1ZXJ5LnN0eWxlKGVsZW0sIG5hbWUsIHZhbHVlKSA6IGpRdWVyeS5jc3MoZWxlbSwgbmFtZSk7XFxuICAgICAgfSwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxKTtcXG4gICAgfSxcXG4gICAgc2hvdzogZnVuY3Rpb24gc2hvdygpIHtcXG4gICAgICByZXR1cm4gc2hvd0hpZGUodGhpcywgdHJ1ZSk7XFxuICAgIH0sXFxuICAgIGhpZGU6IGZ1bmN0aW9uIGhpZGUoKSB7XFxuICAgICAgcmV0dXJuIHNob3dIaWRlKHRoaXMpO1xcbiAgICB9LFxcbiAgICB0b2dnbGU6IGZ1bmN0aW9uIHRvZ2dsZShzdGF0ZSkge1xcbiAgICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFxcXCJib29sZWFuXFxcIikge1xcbiAgICAgICAgcmV0dXJuIHN0YXRlID8gdGhpcy5zaG93KCkgOiB0aGlzLmhpZGUoKTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICBpZiAoaXNIaWRkZW4odGhpcykpIHtcXG4gICAgICAgICAgalF1ZXJ5KHRoaXMpLnNob3coKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGpRdWVyeSh0aGlzKS5oaWRlKCk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgIH1cXG4gIH0pO1xcblxcbiAgZnVuY3Rpb24gVHdlZW4oZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcpIHtcXG4gICAgcmV0dXJuIG5ldyBUd2Vlbi5wcm90b3R5cGUuaW5pdChlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyk7XFxuICB9XFxuXFxuICBqUXVlcnkuVHdlZW4gPSBUd2VlbjtcXG4gIFR3ZWVuLnByb3RvdHlwZSA9IHtcXG4gICAgY29uc3RydWN0b3I6IFR3ZWVuLFxcbiAgICBpbml0OiBmdW5jdGlvbiBpbml0KGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nLCB1bml0KSB7XFxuICAgICAgdGhpcy5lbGVtID0gZWxlbTtcXG4gICAgICB0aGlzLnByb3AgPSBwcm9wO1xcbiAgICAgIHRoaXMuZWFzaW5nID0gZWFzaW5nIHx8IFxcXCJzd2luZ1xcXCI7XFxuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcXG4gICAgICB0aGlzLnN0YXJ0ID0gdGhpcy5ub3cgPSB0aGlzLmN1cigpO1xcbiAgICAgIHRoaXMuZW5kID0gZW5kO1xcbiAgICAgIHRoaXMudW5pdCA9IHVuaXQgfHwgKGpRdWVyeS5jc3NOdW1iZXJbcHJvcF0gPyBcXFwiXFxcIiA6IFxcXCJweFxcXCIpO1xcbiAgICB9LFxcbiAgICBjdXI6IGZ1bmN0aW9uIGN1cigpIHtcXG4gICAgICB2YXIgaG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbdGhpcy5wcm9wXTtcXG4gICAgICByZXR1cm4gaG9va3MgJiYgaG9va3MuZ2V0ID8gaG9va3MuZ2V0KHRoaXMpIDogVHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LmdldCh0aGlzKTtcXG4gICAgfSxcXG4gICAgcnVuOiBmdW5jdGlvbiBydW4ocGVyY2VudCkge1xcbiAgICAgIHZhciBlYXNlZCxcXG4gICAgICAgICAgaG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbdGhpcy5wcm9wXTtcXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmR1cmF0aW9uKSB7XFxuICAgICAgICB0aGlzLnBvcyA9IGVhc2VkID0galF1ZXJ5LmVhc2luZ1t0aGlzLmVhc2luZ10ocGVyY2VudCwgdGhpcy5vcHRpb25zLmR1cmF0aW9uICogcGVyY2VudCwgMCwgMSwgdGhpcy5vcHRpb25zLmR1cmF0aW9uKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdGhpcy5wb3MgPSBlYXNlZCA9IHBlcmNlbnQ7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMubm93ID0gKHRoaXMuZW5kIC0gdGhpcy5zdGFydCkgKiBlYXNlZCArIHRoaXMuc3RhcnQ7XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdGVwKSB7XFxuICAgICAgICB0aGlzLm9wdGlvbnMuc3RlcC5jYWxsKHRoaXMuZWxlbSwgdGhpcy5ub3csIHRoaXMpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoaG9va3MgJiYgaG9va3Muc2V0KSB7XFxuICAgICAgICBob29rcy5zZXQodGhpcyk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5zZXQodGhpcyk7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiB0aGlzO1xcbiAgICB9XFxuICB9O1xcbiAgVHdlZW4ucHJvdG90eXBlLmluaXQucHJvdG90eXBlID0gVHdlZW4ucHJvdG90eXBlO1xcbiAgVHdlZW4ucHJvcEhvb2tzID0ge1xcbiAgICBfZGVmYXVsdDoge1xcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KHR3ZWVuKSB7XFxuICAgICAgICB2YXIgcmVzdWx0O1xcblxcbiAgICAgICAgaWYgKHR3ZWVuLmVsZW1bdHdlZW4ucHJvcF0gIT0gbnVsbCAmJiAoIXR3ZWVuLmVsZW0uc3R5bGUgfHwgdHdlZW4uZWxlbS5zdHlsZVt0d2Vlbi5wcm9wXSA9PSBudWxsKSkge1xcbiAgICAgICAgICByZXR1cm4gdHdlZW4uZWxlbVt0d2Vlbi5wcm9wXTtcXG4gICAgICAgIH0gLy8gUGFzc2luZyBhbiBlbXB0eSBzdHJpbmcgYXMgYSAzcmQgcGFyYW1ldGVyIHRvIC5jc3Mgd2lsbCBhdXRvbWF0aWNhbGx5XFxuICAgICAgICAvLyBhdHRlbXB0IGEgcGFyc2VGbG9hdCBhbmQgZmFsbGJhY2sgdG8gYSBzdHJpbmcgaWYgdGhlIHBhcnNlIGZhaWxzLlxcbiAgICAgICAgLy8gU2ltcGxlIHZhbHVlcyBzdWNoIGFzIFxcXCIxMHB4XFxcIiBhcmUgcGFyc2VkIHRvIEZsb2F0O1xcbiAgICAgICAgLy8gY29tcGxleCB2YWx1ZXMgc3VjaCBhcyBcXFwicm90YXRlKDFyYWQpXFxcIiBhcmUgcmV0dXJuZWQgYXMtaXMuXFxuXFxuXFxuICAgICAgICByZXN1bHQgPSBqUXVlcnkuY3NzKHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIFxcXCJcXFwiKTsgLy8gRW1wdHkgc3RyaW5ncywgbnVsbCwgdW5kZWZpbmVkIGFuZCBcXFwiYXV0b1xcXCIgYXJlIGNvbnZlcnRlZCB0byAwLlxcblxcbiAgICAgICAgcmV0dXJuICFyZXN1bHQgfHwgcmVzdWx0ID09PSBcXFwiYXV0b1xcXCIgPyAwIDogcmVzdWx0O1xcbiAgICAgIH0sXFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodHdlZW4pIHtcXG4gICAgICAgIC8vIFVzZSBzdGVwIGhvb2sgZm9yIGJhY2sgY29tcGF0LlxcbiAgICAgICAgLy8gVXNlIGNzc0hvb2sgaWYgaXRzIHRoZXJlLlxcbiAgICAgICAgLy8gVXNlIC5zdHlsZSBpZiBhdmFpbGFibGUgYW5kIHVzZSBwbGFpbiBwcm9wZXJ0aWVzIHdoZXJlIGF2YWlsYWJsZS5cXG4gICAgICAgIGlmIChqUXVlcnkuZnguc3RlcFt0d2Vlbi5wcm9wXSkge1xcbiAgICAgICAgICBqUXVlcnkuZnguc3RlcFt0d2Vlbi5wcm9wXSh0d2Vlbik7XFxuICAgICAgICB9IGVsc2UgaWYgKHR3ZWVuLmVsZW0uc3R5bGUgJiYgKHR3ZWVuLmVsZW0uc3R5bGVbalF1ZXJ5LmNzc1Byb3BzW3R3ZWVuLnByb3BdXSAhPSBudWxsIHx8IGpRdWVyeS5jc3NIb29rc1t0d2Vlbi5wcm9wXSkpIHtcXG4gICAgICAgICAgalF1ZXJ5LnN0eWxlKHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIHR3ZWVuLm5vdyArIHR3ZWVuLnVuaXQpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgdHdlZW4uZWxlbVt0d2Vlbi5wcm9wXSA9IHR3ZWVuLm5vdztcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG4gIH07IC8vIFN1cHBvcnQ6IElFOVxcbiAgLy8gUGFuaWMgYmFzZWQgYXBwcm9hY2ggdG8gc2V0dGluZyB0aGluZ3Mgb24gZGlzY29ubmVjdGVkIG5vZGVzXFxuXFxuICBUd2Vlbi5wcm9wSG9va3Muc2Nyb2xsVG9wID0gVHdlZW4ucHJvcEhvb2tzLnNjcm9sbExlZnQgPSB7XFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHR3ZWVuKSB7XFxuICAgICAgaWYgKHR3ZWVuLmVsZW0ubm9kZVR5cGUgJiYgdHdlZW4uZWxlbS5wYXJlbnROb2RlKSB7XFxuICAgICAgICB0d2Vlbi5lbGVtW3R3ZWVuLnByb3BdID0gdHdlZW4ubm93O1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfTtcXG4gIGpRdWVyeS5lYXNpbmcgPSB7XFxuICAgIGxpbmVhcjogZnVuY3Rpb24gbGluZWFyKHApIHtcXG4gICAgICByZXR1cm4gcDtcXG4gICAgfSxcXG4gICAgc3dpbmc6IGZ1bmN0aW9uIHN3aW5nKHApIHtcXG4gICAgICByZXR1cm4gMC41IC0gTWF0aC5jb3MocCAqIE1hdGguUEkpIC8gMjtcXG4gICAgfVxcbiAgfTtcXG4gIGpRdWVyeS5meCA9IFR3ZWVuLnByb3RvdHlwZS5pbml0OyAvLyBCYWNrIENvbXBhdCA8MS44IGV4dGVuc2lvbiBwb2ludFxcblxcbiAgalF1ZXJ5LmZ4LnN0ZXAgPSB7fTtcXG4gIHZhciBmeE5vdyxcXG4gICAgICB0aW1lcklkLFxcbiAgICAgIHJmeHR5cGVzID0gL14oPzp0b2dnbGV8c2hvd3xoaWRlKSQvLFxcbiAgICAgIHJmeG51bSA9IG5ldyBSZWdFeHAoXFxcIl4oPzooWystXSk9fCkoXFxcIiArIHBudW0gKyBcXFwiKShbYS16JV0qKSRcXFwiLCBcXFwiaVxcXCIpLFxcbiAgICAgIHJydW4gPSAvcXVldWVIb29rcyQvLFxcbiAgICAgIGFuaW1hdGlvblByZWZpbHRlcnMgPSBbZGVmYXVsdFByZWZpbHRlcl0sXFxuICAgICAgdHdlZW5lcnMgPSB7XFxuICAgIFxcXCIqXFxcIjogW2Z1bmN0aW9uIChwcm9wLCB2YWx1ZSkge1xcbiAgICAgIHZhciB0d2VlbiA9IHRoaXMuY3JlYXRlVHdlZW4ocHJvcCwgdmFsdWUpLFxcbiAgICAgICAgICB0YXJnZXQgPSB0d2Vlbi5jdXIoKSxcXG4gICAgICAgICAgcGFydHMgPSByZnhudW0uZXhlYyh2YWx1ZSksXFxuICAgICAgICAgIHVuaXQgPSBwYXJ0cyAmJiBwYXJ0c1szXSB8fCAoalF1ZXJ5LmNzc051bWJlcltwcm9wXSA/IFxcXCJcXFwiIDogXFxcInB4XFxcIiksXFxuICAgICAgICAgIC8vIFN0YXJ0aW5nIHZhbHVlIGNvbXB1dGF0aW9uIGlzIHJlcXVpcmVkIGZvciBwb3RlbnRpYWwgdW5pdCBtaXNtYXRjaGVzXFxuICAgICAgc3RhcnQgPSAoalF1ZXJ5LmNzc051bWJlcltwcm9wXSB8fCB1bml0ICE9PSBcXFwicHhcXFwiICYmICt0YXJnZXQpICYmIHJmeG51bS5leGVjKGpRdWVyeS5jc3ModHdlZW4uZWxlbSwgcHJvcCkpLFxcbiAgICAgICAgICBzY2FsZSA9IDEsXFxuICAgICAgICAgIG1heEl0ZXJhdGlvbnMgPSAyMDtcXG5cXG4gICAgICBpZiAoc3RhcnQgJiYgc3RhcnRbM10gIT09IHVuaXQpIHtcXG4gICAgICAgIC8vIFRydXN0IHVuaXRzIHJlcG9ydGVkIGJ5IGpRdWVyeS5jc3NcXG4gICAgICAgIHVuaXQgPSB1bml0IHx8IHN0YXJ0WzNdOyAvLyBNYWtlIHN1cmUgd2UgdXBkYXRlIHRoZSB0d2VlbiBwcm9wZXJ0aWVzIGxhdGVyIG9uXFxuXFxuICAgICAgICBwYXJ0cyA9IHBhcnRzIHx8IFtdOyAvLyBJdGVyYXRpdmVseSBhcHByb3hpbWF0ZSBmcm9tIGEgbm9uemVybyBzdGFydGluZyBwb2ludFxcblxcbiAgICAgICAgc3RhcnQgPSArdGFyZ2V0IHx8IDE7XFxuXFxuICAgICAgICBkbyB7XFxuICAgICAgICAgIC8vIElmIHByZXZpb3VzIGl0ZXJhdGlvbiB6ZXJvZWQgb3V0LCBkb3VibGUgdW50aWwgd2UgZ2V0ICpzb21ldGhpbmcqLlxcbiAgICAgICAgICAvLyBVc2Ugc3RyaW5nIGZvciBkb3VibGluZyBzbyB3ZSBkb24ndCBhY2NpZGVudGFsbHkgc2VlIHNjYWxlIGFzIHVuY2hhbmdlZCBiZWxvd1xcbiAgICAgICAgICBzY2FsZSA9IHNjYWxlIHx8IFxcXCIuNVxcXCI7IC8vIEFkanVzdCBhbmQgYXBwbHlcXG5cXG4gICAgICAgICAgc3RhcnQgPSBzdGFydCAvIHNjYWxlO1xcbiAgICAgICAgICBqUXVlcnkuc3R5bGUodHdlZW4uZWxlbSwgcHJvcCwgc3RhcnQgKyB1bml0KTsgLy8gVXBkYXRlIHNjYWxlLCB0b2xlcmF0aW5nIHplcm8gb3IgTmFOIGZyb20gdHdlZW4uY3VyKCksXFxuICAgICAgICAgIC8vIGJyZWFrIHRoZSBsb29wIGlmIHNjYWxlIGlzIHVuY2hhbmdlZCBvciBwZXJmZWN0LCBvciBpZiB3ZSd2ZSBqdXN0IGhhZCBlbm91Z2hcXG4gICAgICAgIH0gd2hpbGUgKHNjYWxlICE9PSAoc2NhbGUgPSB0d2Vlbi5jdXIoKSAvIHRhcmdldCkgJiYgc2NhbGUgIT09IDEgJiYgLS1tYXhJdGVyYXRpb25zKTtcXG4gICAgICB9IC8vIFVwZGF0ZSB0d2VlbiBwcm9wZXJ0aWVzXFxuXFxuXFxuICAgICAgaWYgKHBhcnRzKSB7XFxuICAgICAgICBzdGFydCA9IHR3ZWVuLnN0YXJ0ID0gK3N0YXJ0IHx8ICt0YXJnZXQgfHwgMDtcXG4gICAgICAgIHR3ZWVuLnVuaXQgPSB1bml0OyAvLyBJZiBhICs9Ly09IHRva2VuIHdhcyBwcm92aWRlZCwgd2UncmUgZG9pbmcgYSByZWxhdGl2ZSBhbmltYXRpb25cXG5cXG4gICAgICAgIHR3ZWVuLmVuZCA9IHBhcnRzWzFdID8gc3RhcnQgKyAocGFydHNbMV0gKyAxKSAqIHBhcnRzWzJdIDogK3BhcnRzWzJdO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gdHdlZW47XFxuICAgIH1dXFxuICB9OyAvLyBBbmltYXRpb25zIGNyZWF0ZWQgc3luY2hyb25vdXNseSB3aWxsIHJ1biBzeW5jaHJvbm91c2x5XFxuXFxuICBmdW5jdGlvbiBjcmVhdGVGeE5vdygpIHtcXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgZnhOb3cgPSB1bmRlZmluZWQ7XFxuICAgIH0pO1xcbiAgICByZXR1cm4gZnhOb3cgPSBqUXVlcnkubm93KCk7XFxuICB9IC8vIEdlbmVyYXRlIHBhcmFtZXRlcnMgdG8gY3JlYXRlIGEgc3RhbmRhcmQgYW5pbWF0aW9uXFxuXFxuXFxuICBmdW5jdGlvbiBnZW5GeCh0eXBlLCBpbmNsdWRlV2lkdGgpIHtcXG4gICAgdmFyIHdoaWNoLFxcbiAgICAgICAgaSA9IDAsXFxuICAgICAgICBhdHRycyA9IHtcXG4gICAgICBoZWlnaHQ6IHR5cGVcXG4gICAgfTsgLy8gSWYgd2UgaW5jbHVkZSB3aWR0aCwgc3RlcCB2YWx1ZSBpcyAxIHRvIGRvIGFsbCBjc3NFeHBhbmQgdmFsdWVzLFxcbiAgICAvLyBvdGhlcndpc2Ugc3RlcCB2YWx1ZSBpcyAyIHRvIHNraXAgb3ZlciBMZWZ0IGFuZCBSaWdodFxcblxcbiAgICBpbmNsdWRlV2lkdGggPSBpbmNsdWRlV2lkdGggPyAxIDogMDtcXG5cXG4gICAgZm9yICg7IGkgPCA0OyBpICs9IDIgLSBpbmNsdWRlV2lkdGgpIHtcXG4gICAgICB3aGljaCA9IGNzc0V4cGFuZFtpXTtcXG4gICAgICBhdHRyc1tcXFwibWFyZ2luXFxcIiArIHdoaWNoXSA9IGF0dHJzW1xcXCJwYWRkaW5nXFxcIiArIHdoaWNoXSA9IHR5cGU7XFxuICAgIH1cXG5cXG4gICAgaWYgKGluY2x1ZGVXaWR0aCkge1xcbiAgICAgIGF0dHJzLm9wYWNpdHkgPSBhdHRycy53aWR0aCA9IHR5cGU7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIGF0dHJzO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gY3JlYXRlVHdlZW4odmFsdWUsIHByb3AsIGFuaW1hdGlvbikge1xcbiAgICB2YXIgdHdlZW4sXFxuICAgICAgICBjb2xsZWN0aW9uID0gKHR3ZWVuZXJzW3Byb3BdIHx8IFtdKS5jb25jYXQodHdlZW5lcnNbXFxcIipcXFwiXSksXFxuICAgICAgICBpbmRleCA9IDAsXFxuICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcXG5cXG4gICAgZm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XFxuICAgICAgaWYgKHR3ZWVuID0gY29sbGVjdGlvbltpbmRleF0uY2FsbChhbmltYXRpb24sIHByb3AsIHZhbHVlKSkge1xcbiAgICAgICAgLy8gV2UncmUgZG9uZSB3aXRoIHRoaXMgcHJvcGVydHlcXG4gICAgICAgIHJldHVybiB0d2VlbjtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGRlZmF1bHRQcmVmaWx0ZXIoZWxlbSwgcHJvcHMsIG9wdHMpIHtcXG4gICAgLyoganNoaW50IHZhbGlkdGhpczogdHJ1ZSAqL1xcbiAgICB2YXIgcHJvcCxcXG4gICAgICAgIHZhbHVlLFxcbiAgICAgICAgdG9nZ2xlLFxcbiAgICAgICAgdHdlZW4sXFxuICAgICAgICBob29rcyxcXG4gICAgICAgIG9sZGZpcmUsXFxuICAgICAgICBkaXNwbGF5LFxcbiAgICAgICAgY2hlY2tEaXNwbGF5LFxcbiAgICAgICAgYW5pbSA9IHRoaXMsXFxuICAgICAgICBvcmlnID0ge30sXFxuICAgICAgICBzdHlsZSA9IGVsZW0uc3R5bGUsXFxuICAgICAgICBoaWRkZW4gPSBlbGVtLm5vZGVUeXBlICYmIGlzSGlkZGVuKGVsZW0pLFxcbiAgICAgICAgZGF0YVNob3cgPSBkYXRhX3ByaXYuZ2V0KGVsZW0sIFxcXCJmeHNob3dcXFwiKTsgLy8gSGFuZGxlIHF1ZXVlOiBmYWxzZSBwcm9taXNlc1xcblxcbiAgICBpZiAoIW9wdHMucXVldWUpIHtcXG4gICAgICBob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyhlbGVtLCBcXFwiZnhcXFwiKTtcXG5cXG4gICAgICBpZiAoaG9va3MudW5xdWV1ZWQgPT0gbnVsbCkge1xcbiAgICAgICAgaG9va3MudW5xdWV1ZWQgPSAwO1xcbiAgICAgICAgb2xkZmlyZSA9IGhvb2tzLmVtcHR5LmZpcmU7XFxuXFxuICAgICAgICBob29rcy5lbXB0eS5maXJlID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBpZiAoIWhvb2tzLnVucXVldWVkKSB7XFxuICAgICAgICAgICAgb2xkZmlyZSgpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9O1xcbiAgICAgIH1cXG5cXG4gICAgICBob29rcy51bnF1ZXVlZCsrO1xcbiAgICAgIGFuaW0uYWx3YXlzKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIC8vIEVuc3VyZSB0aGUgY29tcGxldGUgaGFuZGxlciBpcyBjYWxsZWQgYmVmb3JlIHRoaXMgY29tcGxldGVzXFxuICAgICAgICBhbmltLmFsd2F5cyhmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIGhvb2tzLnVucXVldWVkLS07XFxuXFxuICAgICAgICAgIGlmICghalF1ZXJ5LnF1ZXVlKGVsZW0sIFxcXCJmeFxcXCIpLmxlbmd0aCkge1xcbiAgICAgICAgICAgIGhvb2tzLmVtcHR5LmZpcmUoKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgICAgfSk7XFxuICAgIH0gLy8gSGVpZ2h0L3dpZHRoIG92ZXJmbG93IHBhc3NcXG5cXG5cXG4gICAgaWYgKGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKFxcXCJoZWlnaHRcXFwiIGluIHByb3BzIHx8IFxcXCJ3aWR0aFxcXCIgaW4gcHJvcHMpKSB7XFxuICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgbm90aGluZyBzbmVha3Mgb3V0XFxuICAgICAgLy8gUmVjb3JkIGFsbCAzIG92ZXJmbG93IGF0dHJpYnV0ZXMgYmVjYXVzZSBJRTktMTAgZG8gbm90XFxuICAgICAgLy8gY2hhbmdlIHRoZSBvdmVyZmxvdyBhdHRyaWJ1dGUgd2hlbiBvdmVyZmxvd1ggYW5kXFxuICAgICAgLy8gb3ZlcmZsb3dZIGFyZSBzZXQgdG8gdGhlIHNhbWUgdmFsdWVcXG4gICAgICBvcHRzLm92ZXJmbG93ID0gW3N0eWxlLm92ZXJmbG93LCBzdHlsZS5vdmVyZmxvd1gsIHN0eWxlLm92ZXJmbG93WV07IC8vIFNldCBkaXNwbGF5IHByb3BlcnR5IHRvIGlubGluZS1ibG9jayBmb3IgaGVpZ2h0L3dpZHRoXFxuICAgICAgLy8gYW5pbWF0aW9ucyBvbiBpbmxpbmUgZWxlbWVudHMgdGhhdCBhcmUgaGF2aW5nIHdpZHRoL2hlaWdodCBhbmltYXRlZFxcblxcbiAgICAgIGRpc3BsYXkgPSBqUXVlcnkuY3NzKGVsZW0sIFxcXCJkaXNwbGF5XFxcIik7IC8vIFRlc3QgZGVmYXVsdCBkaXNwbGF5IGlmIGRpc3BsYXkgaXMgY3VycmVudGx5IFxcXCJub25lXFxcIlxcblxcbiAgICAgIGNoZWNrRGlzcGxheSA9IGRpc3BsYXkgPT09IFxcXCJub25lXFxcIiA/IGRhdGFfcHJpdi5nZXQoZWxlbSwgXFxcIm9sZGRpc3BsYXlcXFwiKSB8fCBkZWZhdWx0RGlzcGxheShlbGVtLm5vZGVOYW1lKSA6IGRpc3BsYXk7XFxuXFxuICAgICAgaWYgKGNoZWNrRGlzcGxheSA9PT0gXFxcImlubGluZVxcXCIgJiYgalF1ZXJ5LmNzcyhlbGVtLCBcXFwiZmxvYXRcXFwiKSA9PT0gXFxcIm5vbmVcXFwiKSB7XFxuICAgICAgICBzdHlsZS5kaXNwbGF5ID0gXFxcImlubGluZS1ibG9ja1xcXCI7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGlmIChvcHRzLm92ZXJmbG93KSB7XFxuICAgICAgc3R5bGUub3ZlcmZsb3cgPSBcXFwiaGlkZGVuXFxcIjtcXG4gICAgICBhbmltLmFsd2F5cyhmdW5jdGlvbiAoKSB7XFxuICAgICAgICBzdHlsZS5vdmVyZmxvdyA9IG9wdHMub3ZlcmZsb3dbMF07XFxuICAgICAgICBzdHlsZS5vdmVyZmxvd1ggPSBvcHRzLm92ZXJmbG93WzFdO1xcbiAgICAgICAgc3R5bGUub3ZlcmZsb3dZID0gb3B0cy5vdmVyZmxvd1syXTtcXG4gICAgICB9KTtcXG4gICAgfSAvLyBzaG93L2hpZGUgcGFzc1xcblxcblxcbiAgICBmb3IgKHByb3AgaW4gcHJvcHMpIHtcXG4gICAgICB2YWx1ZSA9IHByb3BzW3Byb3BdO1xcblxcbiAgICAgIGlmIChyZnh0eXBlcy5leGVjKHZhbHVlKSkge1xcbiAgICAgICAgZGVsZXRlIHByb3BzW3Byb3BdO1xcbiAgICAgICAgdG9nZ2xlID0gdG9nZ2xlIHx8IHZhbHVlID09PSBcXFwidG9nZ2xlXFxcIjtcXG5cXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gKGhpZGRlbiA/IFxcXCJoaWRlXFxcIiA6IFxcXCJzaG93XFxcIikpIHtcXG4gICAgICAgICAgLy8gSWYgdGhlcmUgaXMgZGF0YVNob3cgbGVmdCBvdmVyIGZyb20gYSBzdG9wcGVkIGhpZGUgb3Igc2hvdyBhbmQgd2UgYXJlIGdvaW5nIHRvIHByb2NlZWQgd2l0aCBzaG93LCB3ZSBzaG91bGQgcHJldGVuZCB0byBiZSBoaWRkZW5cXG4gICAgICAgICAgaWYgKHZhbHVlID09PSBcXFwic2hvd1xcXCIgJiYgZGF0YVNob3cgJiYgZGF0YVNob3dbcHJvcF0gIT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgICAgIGhpZGRlbiA9IHRydWU7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIG9yaWdbcHJvcF0gPSBkYXRhU2hvdyAmJiBkYXRhU2hvd1twcm9wXSB8fCBqUXVlcnkuc3R5bGUoZWxlbSwgcHJvcCk7IC8vIEFueSBub24tZnggdmFsdWUgc3RvcHMgdXMgZnJvbSByZXN0b3JpbmcgdGhlIG9yaWdpbmFsIGRpc3BsYXkgdmFsdWVcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgZGlzcGxheSA9IHVuZGVmaW5lZDtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgaWYgKCFqUXVlcnkuaXNFbXB0eU9iamVjdChvcmlnKSkge1xcbiAgICAgIGlmIChkYXRhU2hvdykge1xcbiAgICAgICAgaWYgKFxcXCJoaWRkZW5cXFwiIGluIGRhdGFTaG93KSB7XFxuICAgICAgICAgIGhpZGRlbiA9IGRhdGFTaG93LmhpZGRlbjtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgZGF0YVNob3cgPSBkYXRhX3ByaXYuYWNjZXNzKGVsZW0sIFxcXCJmeHNob3dcXFwiLCB7fSk7XFxuICAgICAgfSAvLyBTdG9yZSBzdGF0ZSBpZiBpdHMgdG9nZ2xlIC0gZW5hYmxlcyAuc3RvcCgpLnRvZ2dsZSgpIHRvIFxcXCJyZXZlcnNlXFxcIlxcblxcblxcbiAgICAgIGlmICh0b2dnbGUpIHtcXG4gICAgICAgIGRhdGFTaG93LmhpZGRlbiA9ICFoaWRkZW47XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChoaWRkZW4pIHtcXG4gICAgICAgIGpRdWVyeShlbGVtKS5zaG93KCk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGFuaW0uZG9uZShmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIGpRdWVyeShlbGVtKS5oaWRlKCk7XFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuXFxuICAgICAgYW5pbS5kb25lKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciBwcm9wO1xcbiAgICAgICAgZGF0YV9wcml2LnJlbW92ZShlbGVtLCBcXFwiZnhzaG93XFxcIik7XFxuXFxuICAgICAgICBmb3IgKHByb3AgaW4gb3JpZykge1xcbiAgICAgICAgICBqUXVlcnkuc3R5bGUoZWxlbSwgcHJvcCwgb3JpZ1twcm9wXSk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuXFxuICAgICAgZm9yIChwcm9wIGluIG9yaWcpIHtcXG4gICAgICAgIHR3ZWVuID0gY3JlYXRlVHdlZW4oaGlkZGVuID8gZGF0YVNob3dbcHJvcF0gOiAwLCBwcm9wLCBhbmltKTtcXG5cXG4gICAgICAgIGlmICghKHByb3AgaW4gZGF0YVNob3cpKSB7XFxuICAgICAgICAgIGRhdGFTaG93W3Byb3BdID0gdHdlZW4uc3RhcnQ7XFxuXFxuICAgICAgICAgIGlmIChoaWRkZW4pIHtcXG4gICAgICAgICAgICB0d2Vlbi5lbmQgPSB0d2Vlbi5zdGFydDtcXG4gICAgICAgICAgICB0d2Vlbi5zdGFydCA9IHByb3AgPT09IFxcXCJ3aWR0aFxcXCIgfHwgcHJvcCA9PT0gXFxcImhlaWdodFxcXCIgPyAxIDogMDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH0gLy8gSWYgdGhpcyBpcyBhIG5vb3AgbGlrZSAuaGlkZSgpLmhpZGUoKSwgcmVzdG9yZSBhbiBvdmVyd3JpdHRlbiBkaXNwbGF5IHZhbHVlXFxuXFxuICAgIH0gZWxzZSBpZiAoKGRpc3BsYXkgPT09IFxcXCJub25lXFxcIiA/IGRlZmF1bHREaXNwbGF5KGVsZW0ubm9kZU5hbWUpIDogZGlzcGxheSkgPT09IFxcXCJpbmxpbmVcXFwiKSB7XFxuICAgICAgc3R5bGUuZGlzcGxheSA9IGRpc3BsYXk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIHByb3BGaWx0ZXIocHJvcHMsIHNwZWNpYWxFYXNpbmcpIHtcXG4gICAgdmFyIGluZGV4LCBuYW1lLCBlYXNpbmcsIHZhbHVlLCBob29rczsgLy8gY2FtZWxDYXNlLCBzcGVjaWFsRWFzaW5nIGFuZCBleHBhbmQgY3NzSG9vayBwYXNzXFxuXFxuICAgIGZvciAoaW5kZXggaW4gcHJvcHMpIHtcXG4gICAgICBuYW1lID0galF1ZXJ5LmNhbWVsQ2FzZShpbmRleCk7XFxuICAgICAgZWFzaW5nID0gc3BlY2lhbEVhc2luZ1tuYW1lXTtcXG4gICAgICB2YWx1ZSA9IHByb3BzW2luZGV4XTtcXG5cXG4gICAgICBpZiAoalF1ZXJ5LmlzQXJyYXkodmFsdWUpKSB7XFxuICAgICAgICBlYXNpbmcgPSB2YWx1ZVsxXTtcXG4gICAgICAgIHZhbHVlID0gcHJvcHNbaW5kZXhdID0gdmFsdWVbMF07XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChpbmRleCAhPT0gbmFtZSkge1xcbiAgICAgICAgcHJvcHNbbmFtZV0gPSB2YWx1ZTtcXG4gICAgICAgIGRlbGV0ZSBwcm9wc1tpbmRleF07XFxuICAgICAgfVxcblxcbiAgICAgIGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzW25hbWVdO1xcblxcbiAgICAgIGlmIChob29rcyAmJiBcXFwiZXhwYW5kXFxcIiBpbiBob29rcykge1xcbiAgICAgICAgdmFsdWUgPSBob29rcy5leHBhbmQodmFsdWUpO1xcbiAgICAgICAgZGVsZXRlIHByb3BzW25hbWVdOyAvLyBOb3QgcXVpdGUgJC5leHRlbmQsIHRoaXMgd29uJ3Qgb3ZlcndyaXRlIGV4aXN0aW5nIGtleXMuXFxuICAgICAgICAvLyBSZXVzaW5nICdpbmRleCcgYmVjYXVzZSB3ZSBoYXZlIHRoZSBjb3JyZWN0IFxcXCJuYW1lXFxcIlxcblxcbiAgICAgICAgZm9yIChpbmRleCBpbiB2YWx1ZSkge1xcbiAgICAgICAgICBpZiAoIShpbmRleCBpbiBwcm9wcykpIHtcXG4gICAgICAgICAgICBwcm9wc1tpbmRleF0gPSB2YWx1ZVtpbmRleF07XFxuICAgICAgICAgICAgc3BlY2lhbEVhc2luZ1tpbmRleF0gPSBlYXNpbmc7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgc3BlY2lhbEVhc2luZ1tuYW1lXSA9IGVhc2luZztcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIEFuaW1hdGlvbihlbGVtLCBwcm9wZXJ0aWVzLCBvcHRpb25zKSB7XFxuICAgIHZhciByZXN1bHQsXFxuICAgICAgICBzdG9wcGVkLFxcbiAgICAgICAgaW5kZXggPSAwLFxcbiAgICAgICAgbGVuZ3RoID0gYW5pbWF0aW9uUHJlZmlsdGVycy5sZW5ndGgsXFxuICAgICAgICBkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLmFsd2F5cyhmdW5jdGlvbiAoKSB7XFxuICAgICAgLy8gRG9uJ3QgbWF0Y2ggZWxlbSBpbiB0aGUgOmFuaW1hdGVkIHNlbGVjdG9yXFxuICAgICAgZGVsZXRlIHRpY2suZWxlbTtcXG4gICAgfSksXFxuICAgICAgICB0aWNrID0gZnVuY3Rpb24gdGljaygpIHtcXG4gICAgICBpZiAoc3RvcHBlZCkge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgY3VycmVudFRpbWUgPSBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxcbiAgICAgICAgICByZW1haW5pbmcgPSBNYXRoLm1heCgwLCBhbmltYXRpb24uc3RhcnRUaW1lICsgYW5pbWF0aW9uLmR1cmF0aW9uIC0gY3VycmVudFRpbWUpLFxcbiAgICAgICAgICAvLyBTdXBwb3J0OiBBbmRyb2lkIDIuM1xcbiAgICAgIC8vIEFyY2hhaWMgY3Jhc2ggYnVnIHdvbid0IGFsbG93IHVzIHRvIHVzZSBgMSAtICggMC41IHx8IDAgKWAgKCMxMjQ5NylcXG4gICAgICB0ZW1wID0gcmVtYWluaW5nIC8gYW5pbWF0aW9uLmR1cmF0aW9uIHx8IDAsXFxuICAgICAgICAgIHBlcmNlbnQgPSAxIC0gdGVtcCxcXG4gICAgICAgICAgaW5kZXggPSAwLFxcbiAgICAgICAgICBsZW5ndGggPSBhbmltYXRpb24udHdlZW5zLmxlbmd0aDtcXG5cXG4gICAgICBmb3IgKDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcXG4gICAgICAgIGFuaW1hdGlvbi50d2VlbnNbaW5kZXhdLnJ1bihwZXJjZW50KTtcXG4gICAgICB9XFxuXFxuICAgICAgZGVmZXJyZWQubm90aWZ5V2l0aChlbGVtLCBbYW5pbWF0aW9uLCBwZXJjZW50LCByZW1haW5pbmddKTtcXG5cXG4gICAgICBpZiAocGVyY2VudCA8IDEgJiYgbGVuZ3RoKSB7XFxuICAgICAgICByZXR1cm4gcmVtYWluaW5nO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBkZWZlcnJlZC5yZXNvbHZlV2l0aChlbGVtLCBbYW5pbWF0aW9uXSk7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcbiAgICB9LFxcbiAgICAgICAgYW5pbWF0aW9uID0gZGVmZXJyZWQucHJvbWlzZSh7XFxuICAgICAgZWxlbTogZWxlbSxcXG4gICAgICBwcm9wczogalF1ZXJ5LmV4dGVuZCh7fSwgcHJvcGVydGllcyksXFxuICAgICAgb3B0czogalF1ZXJ5LmV4dGVuZCh0cnVlLCB7XFxuICAgICAgICBzcGVjaWFsRWFzaW5nOiB7fVxcbiAgICAgIH0sIG9wdGlvbnMpLFxcbiAgICAgIG9yaWdpbmFsUHJvcGVydGllczogcHJvcGVydGllcyxcXG4gICAgICBvcmlnaW5hbE9wdGlvbnM6IG9wdGlvbnMsXFxuICAgICAgc3RhcnRUaW1lOiBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxcbiAgICAgIGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxcbiAgICAgIHR3ZWVuczogW10sXFxuICAgICAgY3JlYXRlVHdlZW46IGZ1bmN0aW9uIGNyZWF0ZVR3ZWVuKHByb3AsIGVuZCkge1xcbiAgICAgICAgdmFyIHR3ZWVuID0galF1ZXJ5LlR3ZWVuKGVsZW0sIGFuaW1hdGlvbi5vcHRzLCBwcm9wLCBlbmQsIGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmdbcHJvcF0gfHwgYW5pbWF0aW9uLm9wdHMuZWFzaW5nKTtcXG4gICAgICAgIGFuaW1hdGlvbi50d2VlbnMucHVzaCh0d2Vlbik7XFxuICAgICAgICByZXR1cm4gdHdlZW47XFxuICAgICAgfSxcXG4gICAgICBzdG9wOiBmdW5jdGlvbiBzdG9wKGdvdG9FbmQpIHtcXG4gICAgICAgIHZhciBpbmRleCA9IDAsXFxuICAgICAgICAgICAgLy8gSWYgd2UgYXJlIGdvaW5nIHRvIHRoZSBlbmQsIHdlIHdhbnQgdG8gcnVuIGFsbCB0aGUgdHdlZW5zXFxuICAgICAgICAvLyBvdGhlcndpc2Ugd2Ugc2tpcCB0aGlzIHBhcnRcXG4gICAgICAgIGxlbmd0aCA9IGdvdG9FbmQgPyBhbmltYXRpb24udHdlZW5zLmxlbmd0aCA6IDA7XFxuXFxuICAgICAgICBpZiAoc3RvcHBlZCkge1xcbiAgICAgICAgICByZXR1cm4gdGhpcztcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHN0b3BwZWQgPSB0cnVlO1xcblxcbiAgICAgICAgZm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XFxuICAgICAgICAgIGFuaW1hdGlvbi50d2VlbnNbaW5kZXhdLnJ1bigxKTtcXG4gICAgICAgIH0gLy8gUmVzb2x2ZSB3aGVuIHdlIHBsYXllZCB0aGUgbGFzdCBmcmFtZTsgb3RoZXJ3aXNlLCByZWplY3RcXG5cXG5cXG4gICAgICAgIGlmIChnb3RvRW5kKSB7XFxuICAgICAgICAgIGRlZmVycmVkLnJlc29sdmVXaXRoKGVsZW0sIFthbmltYXRpb24sIGdvdG9FbmRdKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGRlZmVycmVkLnJlamVjdFdpdGgoZWxlbSwgW2FuaW1hdGlvbiwgZ290b0VuZF0pO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIHRoaXM7XFxuICAgICAgfVxcbiAgICB9KSxcXG4gICAgICAgIHByb3BzID0gYW5pbWF0aW9uLnByb3BzO1xcblxcbiAgICBwcm9wRmlsdGVyKHByb3BzLCBhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nKTtcXG5cXG4gICAgZm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XFxuICAgICAgcmVzdWx0ID0gYW5pbWF0aW9uUHJlZmlsdGVyc1tpbmRleF0uY2FsbChhbmltYXRpb24sIGVsZW0sIHByb3BzLCBhbmltYXRpb24ub3B0cyk7XFxuXFxuICAgICAgaWYgKHJlc3VsdCkge1xcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgalF1ZXJ5Lm1hcChwcm9wcywgY3JlYXRlVHdlZW4sIGFuaW1hdGlvbik7XFxuXFxuICAgIGlmIChqUXVlcnkuaXNGdW5jdGlvbihhbmltYXRpb24ub3B0cy5zdGFydCkpIHtcXG4gICAgICBhbmltYXRpb24ub3B0cy5zdGFydC5jYWxsKGVsZW0sIGFuaW1hdGlvbik7XFxuICAgIH1cXG5cXG4gICAgalF1ZXJ5LmZ4LnRpbWVyKGpRdWVyeS5leHRlbmQodGljaywge1xcbiAgICAgIGVsZW06IGVsZW0sXFxuICAgICAgYW5pbTogYW5pbWF0aW9uLFxcbiAgICAgIHF1ZXVlOiBhbmltYXRpb24ub3B0cy5xdWV1ZVxcbiAgICB9KSk7IC8vIGF0dGFjaCBjYWxsYmFja3MgZnJvbSBvcHRpb25zXFxuXFxuICAgIHJldHVybiBhbmltYXRpb24ucHJvZ3Jlc3MoYW5pbWF0aW9uLm9wdHMucHJvZ3Jlc3MpLmRvbmUoYW5pbWF0aW9uLm9wdHMuZG9uZSwgYW5pbWF0aW9uLm9wdHMuY29tcGxldGUpLmZhaWwoYW5pbWF0aW9uLm9wdHMuZmFpbCkuYWx3YXlzKGFuaW1hdGlvbi5vcHRzLmFsd2F5cyk7XFxuICB9XFxuXFxuICBqUXVlcnkuQW5pbWF0aW9uID0galF1ZXJ5LmV4dGVuZChBbmltYXRpb24sIHtcXG4gICAgdHdlZW5lcjogZnVuY3Rpb24gdHdlZW5lcihwcm9wcywgY2FsbGJhY2spIHtcXG4gICAgICBpZiAoalF1ZXJ5LmlzRnVuY3Rpb24ocHJvcHMpKSB7XFxuICAgICAgICBjYWxsYmFjayA9IHByb3BzO1xcbiAgICAgICAgcHJvcHMgPSBbXFxcIipcXFwiXTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgcHJvcHMgPSBwcm9wcy5zcGxpdChcXFwiIFxcXCIpO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgcHJvcCxcXG4gICAgICAgICAgaW5kZXggPSAwLFxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XFxuXFxuICAgICAgZm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XFxuICAgICAgICBwcm9wID0gcHJvcHNbaW5kZXhdO1xcbiAgICAgICAgdHdlZW5lcnNbcHJvcF0gPSB0d2VlbmVyc1twcm9wXSB8fCBbXTtcXG4gICAgICAgIHR3ZWVuZXJzW3Byb3BdLnVuc2hpZnQoY2FsbGJhY2spO1xcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgcHJlZmlsdGVyOiBmdW5jdGlvbiBwcmVmaWx0ZXIoY2FsbGJhY2ssIHByZXBlbmQpIHtcXG4gICAgICBpZiAocHJlcGVuZCkge1xcbiAgICAgICAgYW5pbWF0aW9uUHJlZmlsdGVycy51bnNoaWZ0KGNhbGxiYWNrKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgYW5pbWF0aW9uUHJlZmlsdGVycy5wdXNoKGNhbGxiYWNrKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH0pO1xcblxcbiAgalF1ZXJ5LnNwZWVkID0gZnVuY3Rpb24gKHNwZWVkLCBlYXNpbmcsIGZuKSB7XFxuICAgIHZhciBvcHQgPSBzcGVlZCAmJiBfdHlwZW9mKHNwZWVkKSA9PT0gXFxcIm9iamVjdFxcXCIgPyBqUXVlcnkuZXh0ZW5kKHt9LCBzcGVlZCkgOiB7XFxuICAgICAgY29tcGxldGU6IGZuIHx8ICFmbiAmJiBlYXNpbmcgfHwgalF1ZXJ5LmlzRnVuY3Rpb24oc3BlZWQpICYmIHNwZWVkLFxcbiAgICAgIGR1cmF0aW9uOiBzcGVlZCxcXG4gICAgICBlYXNpbmc6IGZuICYmIGVhc2luZyB8fCBlYXNpbmcgJiYgIWpRdWVyeS5pc0Z1bmN0aW9uKGVhc2luZykgJiYgZWFzaW5nXFxuICAgIH07XFxuICAgIG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5vZmYgPyAwIDogdHlwZW9mIG9wdC5kdXJhdGlvbiA9PT0gXFxcIm51bWJlclxcXCIgPyBvcHQuZHVyYXRpb24gOiBvcHQuZHVyYXRpb24gaW4galF1ZXJ5LmZ4LnNwZWVkcyA/IGpRdWVyeS5meC5zcGVlZHNbb3B0LmR1cmF0aW9uXSA6IGpRdWVyeS5meC5zcGVlZHMuX2RlZmF1bHQ7IC8vIE5vcm1hbGl6ZSBvcHQucXVldWUgLSB0cnVlL3VuZGVmaW5lZC9udWxsIC0+IFxcXCJmeFxcXCJcXG5cXG4gICAgaWYgKG9wdC5xdWV1ZSA9PSBudWxsIHx8IG9wdC5xdWV1ZSA9PT0gdHJ1ZSkge1xcbiAgICAgIG9wdC5xdWV1ZSA9IFxcXCJmeFxcXCI7XFxuICAgIH0gLy8gUXVldWVpbmdcXG5cXG5cXG4gICAgb3B0Lm9sZCA9IG9wdC5jb21wbGV0ZTtcXG5cXG4gICAgb3B0LmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xcbiAgICAgIGlmIChqUXVlcnkuaXNGdW5jdGlvbihvcHQub2xkKSkge1xcbiAgICAgICAgb3B0Lm9sZC5jYWxsKHRoaXMpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAob3B0LnF1ZXVlKSB7XFxuICAgICAgICBqUXVlcnkuZGVxdWV1ZSh0aGlzLCBvcHQucXVldWUpO1xcbiAgICAgIH1cXG4gICAgfTtcXG5cXG4gICAgcmV0dXJuIG9wdDtcXG4gIH07XFxuXFxuICBqUXVlcnkuZm4uZXh0ZW5kKHtcXG4gICAgZmFkZVRvOiBmdW5jdGlvbiBmYWRlVG8oc3BlZWQsIHRvLCBlYXNpbmcsIGNhbGxiYWNrKSB7XFxuICAgICAgLy8gU2hvdyBhbnkgaGlkZGVuIGVsZW1lbnRzIGFmdGVyIHNldHRpbmcgb3BhY2l0eSB0byAwXFxuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKGlzSGlkZGVuKS5jc3MoXFxcIm9wYWNpdHlcXFwiLCAwKS5zaG93KCkgLy8gQW5pbWF0ZSB0byB0aGUgdmFsdWUgc3BlY2lmaWVkXFxuICAgICAgLmVuZCgpLmFuaW1hdGUoe1xcbiAgICAgICAgb3BhY2l0eTogdG9cXG4gICAgICB9LCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayk7XFxuICAgIH0sXFxuICAgIGFuaW1hdGU6IGZ1bmN0aW9uIGFuaW1hdGUocHJvcCwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2spIHtcXG4gICAgICB2YXIgZW1wdHkgPSBqUXVlcnkuaXNFbXB0eU9iamVjdChwcm9wKSxcXG4gICAgICAgICAgb3B0YWxsID0galF1ZXJ5LnNwZWVkKHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrKSxcXG4gICAgICAgICAgZG9BbmltYXRpb24gPSBmdW5jdGlvbiBkb0FuaW1hdGlvbigpIHtcXG4gICAgICAgIC8vIE9wZXJhdGUgb24gYSBjb3B5IG9mIHByb3Agc28gcGVyLXByb3BlcnR5IGVhc2luZyB3b24ndCBiZSBsb3N0XFxuICAgICAgICB2YXIgYW5pbSA9IEFuaW1hdGlvbih0aGlzLCBqUXVlcnkuZXh0ZW5kKHt9LCBwcm9wKSwgb3B0YWxsKTsgLy8gRW1wdHkgYW5pbWF0aW9ucywgb3IgZmluaXNoaW5nIHJlc29sdmVzIGltbWVkaWF0ZWx5XFxuXFxuICAgICAgICBpZiAoZW1wdHkgfHwgZGF0YV9wcml2LmdldCh0aGlzLCBcXFwiZmluaXNoXFxcIikpIHtcXG4gICAgICAgICAgYW5pbS5zdG9wKHRydWUpO1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuXFxuICAgICAgZG9BbmltYXRpb24uZmluaXNoID0gZG9BbmltYXRpb247XFxuICAgICAgcmV0dXJuIGVtcHR5IHx8IG9wdGFsbC5xdWV1ZSA9PT0gZmFsc2UgPyB0aGlzLmVhY2goZG9BbmltYXRpb24pIDogdGhpcy5xdWV1ZShvcHRhbGwucXVldWUsIGRvQW5pbWF0aW9uKTtcXG4gICAgfSxcXG4gICAgc3RvcDogZnVuY3Rpb24gc3RvcCh0eXBlLCBjbGVhclF1ZXVlLCBnb3RvRW5kKSB7XFxuICAgICAgdmFyIHN0b3BRdWV1ZSA9IGZ1bmN0aW9uIHN0b3BRdWV1ZShob29rcykge1xcbiAgICAgICAgdmFyIHN0b3AgPSBob29rcy5zdG9wO1xcbiAgICAgICAgZGVsZXRlIGhvb2tzLnN0b3A7XFxuICAgICAgICBzdG9wKGdvdG9FbmQpO1xcbiAgICAgIH07XFxuXFxuICAgICAgaWYgKHR5cGVvZiB0eXBlICE9PSBcXFwic3RyaW5nXFxcIikge1xcbiAgICAgICAgZ290b0VuZCA9IGNsZWFyUXVldWU7XFxuICAgICAgICBjbGVhclF1ZXVlID0gdHlwZTtcXG4gICAgICAgIHR5cGUgPSB1bmRlZmluZWQ7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChjbGVhclF1ZXVlICYmIHR5cGUgIT09IGZhbHNlKSB7XFxuICAgICAgICB0aGlzLnF1ZXVlKHR5cGUgfHwgXFxcImZ4XFxcIiwgW10pO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciBkZXF1ZXVlID0gdHJ1ZSxcXG4gICAgICAgICAgICBpbmRleCA9IHR5cGUgIT0gbnVsbCAmJiB0eXBlICsgXFxcInF1ZXVlSG9va3NcXFwiLFxcbiAgICAgICAgICAgIHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXFxuICAgICAgICAgICAgZGF0YSA9IGRhdGFfcHJpdi5nZXQodGhpcyk7XFxuXFxuICAgICAgICBpZiAoaW5kZXgpIHtcXG4gICAgICAgICAgaWYgKGRhdGFbaW5kZXhdICYmIGRhdGFbaW5kZXhdLnN0b3ApIHtcXG4gICAgICAgICAgICBzdG9wUXVldWUoZGF0YVtpbmRleF0pO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBmb3IgKGluZGV4IGluIGRhdGEpIHtcXG4gICAgICAgICAgICBpZiAoZGF0YVtpbmRleF0gJiYgZGF0YVtpbmRleF0uc3RvcCAmJiBycnVuLnRlc3QoaW5kZXgpKSB7XFxuICAgICAgICAgICAgICBzdG9wUXVldWUoZGF0YVtpbmRleF0pO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgZm9yIChpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07KSB7XFxuICAgICAgICAgIGlmICh0aW1lcnNbaW5kZXhdLmVsZW0gPT09IHRoaXMgJiYgKHR5cGUgPT0gbnVsbCB8fCB0aW1lcnNbaW5kZXhdLnF1ZXVlID09PSB0eXBlKSkge1xcbiAgICAgICAgICAgIHRpbWVyc1tpbmRleF0uYW5pbS5zdG9wKGdvdG9FbmQpO1xcbiAgICAgICAgICAgIGRlcXVldWUgPSBmYWxzZTtcXG4gICAgICAgICAgICB0aW1lcnMuc3BsaWNlKGluZGV4LCAxKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSAvLyBTdGFydCB0aGUgbmV4dCBpbiB0aGUgcXVldWUgaWYgdGhlIGxhc3Qgc3RlcCB3YXNuJ3QgZm9yY2VkLlxcbiAgICAgICAgLy8gVGltZXJzIGN1cnJlbnRseSB3aWxsIGNhbGwgdGhlaXIgY29tcGxldGUgY2FsbGJhY2tzLCB3aGljaFxcbiAgICAgICAgLy8gd2lsbCBkZXF1ZXVlIGJ1dCBvbmx5IGlmIHRoZXkgd2VyZSBnb3RvRW5kLlxcblxcblxcbiAgICAgICAgaWYgKGRlcXVldWUgfHwgIWdvdG9FbmQpIHtcXG4gICAgICAgICAgalF1ZXJ5LmRlcXVldWUodGhpcywgdHlwZSk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgIH0sXFxuICAgIGZpbmlzaDogZnVuY3Rpb24gZmluaXNoKHR5cGUpIHtcXG4gICAgICBpZiAodHlwZSAhPT0gZmFsc2UpIHtcXG4gICAgICAgIHR5cGUgPSB0eXBlIHx8IFxcXCJmeFxcXCI7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIGluZGV4LFxcbiAgICAgICAgICAgIGRhdGEgPSBkYXRhX3ByaXYuZ2V0KHRoaXMpLFxcbiAgICAgICAgICAgIHF1ZXVlID0gZGF0YVt0eXBlICsgXFxcInF1ZXVlXFxcIl0sXFxuICAgICAgICAgICAgaG9va3MgPSBkYXRhW3R5cGUgKyBcXFwicXVldWVIb29rc1xcXCJdLFxcbiAgICAgICAgICAgIHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXFxuICAgICAgICAgICAgbGVuZ3RoID0gcXVldWUgPyBxdWV1ZS5sZW5ndGggOiAwOyAvLyBFbmFibGUgZmluaXNoaW5nIGZsYWcgb24gcHJpdmF0ZSBkYXRhXFxuXFxuICAgICAgICBkYXRhLmZpbmlzaCA9IHRydWU7IC8vIEVtcHR5IHRoZSBxdWV1ZSBmaXJzdFxcblxcbiAgICAgICAgalF1ZXJ5LnF1ZXVlKHRoaXMsIHR5cGUsIFtdKTtcXG5cXG4gICAgICAgIGlmIChob29rcyAmJiBob29rcy5zdG9wKSB7XFxuICAgICAgICAgIGhvb2tzLnN0b3AuY2FsbCh0aGlzLCB0cnVlKTtcXG4gICAgICAgIH0gLy8gTG9vayBmb3IgYW55IGFjdGl2ZSBhbmltYXRpb25zLCBhbmQgZmluaXNoIHRoZW1cXG5cXG5cXG4gICAgICAgIGZvciAoaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOykge1xcbiAgICAgICAgICBpZiAodGltZXJzW2luZGV4XS5lbGVtID09PSB0aGlzICYmIHRpbWVyc1tpbmRleF0ucXVldWUgPT09IHR5cGUpIHtcXG4gICAgICAgICAgICB0aW1lcnNbaW5kZXhdLmFuaW0uc3RvcCh0cnVlKTtcXG4gICAgICAgICAgICB0aW1lcnMuc3BsaWNlKGluZGV4LCAxKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSAvLyBMb29rIGZvciBhbnkgYW5pbWF0aW9ucyBpbiB0aGUgb2xkIHF1ZXVlIGFuZCBmaW5pc2ggdGhlbVxcblxcblxcbiAgICAgICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XFxuICAgICAgICAgIGlmIChxdWV1ZVtpbmRleF0gJiYgcXVldWVbaW5kZXhdLmZpbmlzaCkge1xcbiAgICAgICAgICAgIHF1ZXVlW2luZGV4XS5maW5pc2guY2FsbCh0aGlzKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSAvLyBUdXJuIG9mZiBmaW5pc2hpbmcgZmxhZ1xcblxcblxcbiAgICAgICAgZGVsZXRlIGRhdGEuZmluaXNoO1xcbiAgICAgIH0pO1xcbiAgICB9XFxuICB9KTtcXG4gIGpRdWVyeS5lYWNoKFtcXFwidG9nZ2xlXFxcIiwgXFxcInNob3dcXFwiLCBcXFwiaGlkZVxcXCJdLCBmdW5jdGlvbiAoaSwgbmFtZSkge1xcbiAgICB2YXIgY3NzRm4gPSBqUXVlcnkuZm5bbmFtZV07XFxuXFxuICAgIGpRdWVyeS5mbltuYW1lXSA9IGZ1bmN0aW9uIChzcGVlZCwgZWFzaW5nLCBjYWxsYmFjaykge1xcbiAgICAgIHJldHVybiBzcGVlZCA9PSBudWxsIHx8IHR5cGVvZiBzcGVlZCA9PT0gXFxcImJvb2xlYW5cXFwiID8gY3NzRm4uYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IHRoaXMuYW5pbWF0ZShnZW5GeChuYW1lLCB0cnVlKSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2spO1xcbiAgICB9O1xcbiAgfSk7IC8vIEdlbmVyYXRlIHNob3J0Y3V0cyBmb3IgY3VzdG9tIGFuaW1hdGlvbnNcXG5cXG4gIGpRdWVyeS5lYWNoKHtcXG4gICAgc2xpZGVEb3duOiBnZW5GeChcXFwic2hvd1xcXCIpLFxcbiAgICBzbGlkZVVwOiBnZW5GeChcXFwiaGlkZVxcXCIpLFxcbiAgICBzbGlkZVRvZ2dsZTogZ2VuRngoXFxcInRvZ2dsZVxcXCIpLFxcbiAgICBmYWRlSW46IHtcXG4gICAgICBvcGFjaXR5OiBcXFwic2hvd1xcXCJcXG4gICAgfSxcXG4gICAgZmFkZU91dDoge1xcbiAgICAgIG9wYWNpdHk6IFxcXCJoaWRlXFxcIlxcbiAgICB9LFxcbiAgICBmYWRlVG9nZ2xlOiB7XFxuICAgICAgb3BhY2l0eTogXFxcInRvZ2dsZVxcXCJcXG4gICAgfVxcbiAgfSwgZnVuY3Rpb24gKG5hbWUsIHByb3BzKSB7XFxuICAgIGpRdWVyeS5mbltuYW1lXSA9IGZ1bmN0aW9uIChzcGVlZCwgZWFzaW5nLCBjYWxsYmFjaykge1xcbiAgICAgIHJldHVybiB0aGlzLmFuaW1hdGUocHJvcHMsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrKTtcXG4gICAgfTtcXG4gIH0pO1xcbiAgalF1ZXJ5LnRpbWVycyA9IFtdO1xcblxcbiAgalF1ZXJ5LmZ4LnRpY2sgPSBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciB0aW1lcixcXG4gICAgICAgIGkgPSAwLFxcbiAgICAgICAgdGltZXJzID0galF1ZXJ5LnRpbWVycztcXG4gICAgZnhOb3cgPSBqUXVlcnkubm93KCk7XFxuXFxuICAgIGZvciAoOyBpIDwgdGltZXJzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgdGltZXIgPSB0aW1lcnNbaV07IC8vIENoZWNrcyB0aGUgdGltZXIgaGFzIG5vdCBhbHJlYWR5IGJlZW4gcmVtb3ZlZFxcblxcbiAgICAgIGlmICghdGltZXIoKSAmJiB0aW1lcnNbaV0gPT09IHRpbWVyKSB7XFxuICAgICAgICB0aW1lcnMuc3BsaWNlKGktLSwgMSk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGlmICghdGltZXJzLmxlbmd0aCkge1xcbiAgICAgIGpRdWVyeS5meC5zdG9wKCk7XFxuICAgIH1cXG5cXG4gICAgZnhOb3cgPSB1bmRlZmluZWQ7XFxuICB9O1xcblxcbiAgalF1ZXJ5LmZ4LnRpbWVyID0gZnVuY3Rpb24gKHRpbWVyKSB7XFxuICAgIGpRdWVyeS50aW1lcnMucHVzaCh0aW1lcik7XFxuXFxuICAgIGlmICh0aW1lcigpKSB7XFxuICAgICAgalF1ZXJ5LmZ4LnN0YXJ0KCk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgalF1ZXJ5LnRpbWVycy5wb3AoKTtcXG4gICAgfVxcbiAgfTtcXG5cXG4gIGpRdWVyeS5meC5pbnRlcnZhbCA9IDEzO1xcblxcbiAgalF1ZXJ5LmZ4LnN0YXJ0ID0gZnVuY3Rpb24gKCkge1xcbiAgICBpZiAoIXRpbWVySWQpIHtcXG4gICAgICB0aW1lcklkID0gc2V0SW50ZXJ2YWwoalF1ZXJ5LmZ4LnRpY2ssIGpRdWVyeS5meC5pbnRlcnZhbCk7XFxuICAgIH1cXG4gIH07XFxuXFxuICBqUXVlcnkuZnguc3RvcCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgY2xlYXJJbnRlcnZhbCh0aW1lcklkKTtcXG4gICAgdGltZXJJZCA9IG51bGw7XFxuICB9O1xcblxcbiAgalF1ZXJ5LmZ4LnNwZWVkcyA9IHtcXG4gICAgc2xvdzogNjAwLFxcbiAgICBmYXN0OiAyMDAsXFxuICAgIC8vIERlZmF1bHQgc3BlZWRcXG4gICAgX2RlZmF1bHQ6IDQwMFxcbiAgfTsgLy8gQmFzZWQgb2ZmIG9mIHRoZSBwbHVnaW4gYnkgQ2xpbnQgSGVsZmVycywgd2l0aCBwZXJtaXNzaW9uLlxcbiAgLy8gaHR0cDovL2JsaW5kc2lnbmFscy5jb20vaW5kZXgucGhwLzIwMDkvMDcvanF1ZXJ5LWRlbGF5L1xcblxcbiAgalF1ZXJ5LmZuLmRlbGF5ID0gZnVuY3Rpb24gKHRpbWUsIHR5cGUpIHtcXG4gICAgdGltZSA9IGpRdWVyeS5meCA/IGpRdWVyeS5meC5zcGVlZHNbdGltZV0gfHwgdGltZSA6IHRpbWU7XFxuICAgIHR5cGUgPSB0eXBlIHx8IFxcXCJmeFxcXCI7XFxuICAgIHJldHVybiB0aGlzLnF1ZXVlKHR5cGUsIGZ1bmN0aW9uIChuZXh0LCBob29rcykge1xcbiAgICAgIHZhciB0aW1lb3V0ID0gc2V0VGltZW91dChuZXh0LCB0aW1lKTtcXG5cXG4gICAgICBob29rcy5zdG9wID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xcbiAgICAgIH07XFxuICAgIH0pO1xcbiAgfTtcXG5cXG4gIChmdW5jdGlvbiAoKSB7XFxuICAgIHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXFxcImlucHV0XFxcIiksXFxuICAgICAgICBzZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxcXCJzZWxlY3RcXFwiKSxcXG4gICAgICAgIG9wdCA9IHNlbGVjdC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxcXCJvcHRpb25cXFwiKSk7XFxuICAgIGlucHV0LnR5cGUgPSBcXFwiY2hlY2tib3hcXFwiOyAvLyBTdXBwb3J0OiBpT1M8PTUuMSwgQW5kcm9pZDw9NC4yK1xcbiAgICAvLyBEZWZhdWx0IHZhbHVlIGZvciBhIGNoZWNrYm94IHNob3VsZCBiZSBcXFwib25cXFwiXFxuXFxuICAgIHN1cHBvcnQuY2hlY2tPbiA9IGlucHV0LnZhbHVlICE9PSBcXFwiXFxcIjsgLy8gU3VwcG9ydDogSUU8PTExK1xcbiAgICAvLyBNdXN0IGFjY2VzcyBzZWxlY3RlZEluZGV4IHRvIG1ha2UgZGVmYXVsdCBvcHRpb25zIHNlbGVjdFxcblxcbiAgICBzdXBwb3J0Lm9wdFNlbGVjdGVkID0gb3B0LnNlbGVjdGVkOyAvLyBTdXBwb3J0OiBBbmRyb2lkPD0yLjNcXG4gICAgLy8gT3B0aW9ucyBpbnNpZGUgZGlzYWJsZWQgc2VsZWN0cyBhcmUgaW5jb3JyZWN0bHkgbWFya2VkIGFzIGRpc2FibGVkXFxuXFxuICAgIHNlbGVjdC5kaXNhYmxlZCA9IHRydWU7XFxuICAgIHN1cHBvcnQub3B0RGlzYWJsZWQgPSAhb3B0LmRpc2FibGVkOyAvLyBTdXBwb3J0OiBJRTw9MTErXFxuICAgIC8vIEFuIGlucHV0IGxvc2VzIGl0cyB2YWx1ZSBhZnRlciBiZWNvbWluZyBhIHJhZGlvXFxuXFxuICAgIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwiaW5wdXRcXFwiKTtcXG4gICAgaW5wdXQudmFsdWUgPSBcXFwidFxcXCI7XFxuICAgIGlucHV0LnR5cGUgPSBcXFwicmFkaW9cXFwiO1xcbiAgICBzdXBwb3J0LnJhZGlvVmFsdWUgPSBpbnB1dC52YWx1ZSA9PT0gXFxcInRcXFwiO1xcbiAgfSkoKTtcXG5cXG4gIHZhciBub2RlSG9vayxcXG4gICAgICBib29sSG9vayxcXG4gICAgICBhdHRySGFuZGxlID0galF1ZXJ5LmV4cHIuYXR0ckhhbmRsZTtcXG4gIGpRdWVyeS5mbi5leHRlbmQoe1xcbiAgICBhdHRyOiBmdW5jdGlvbiBhdHRyKG5hbWUsIHZhbHVlKSB7XFxuICAgICAgcmV0dXJuIGFjY2Vzcyh0aGlzLCBqUXVlcnkuYXR0ciwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxKTtcXG4gICAgfSxcXG4gICAgcmVtb3ZlQXR0cjogZnVuY3Rpb24gcmVtb3ZlQXR0cihuYW1lKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICBqUXVlcnkucmVtb3ZlQXR0cih0aGlzLCBuYW1lKTtcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgfSk7XFxuICBqUXVlcnkuZXh0ZW5kKHtcXG4gICAgYXR0cjogZnVuY3Rpb24gYXR0cihlbGVtLCBuYW1lLCB2YWx1ZSkge1xcbiAgICAgIHZhciBob29rcyxcXG4gICAgICAgICAgcmV0LFxcbiAgICAgICAgICBuVHlwZSA9IGVsZW0ubm9kZVR5cGU7IC8vIGRvbid0IGdldC9zZXQgYXR0cmlidXRlcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcXG5cXG4gICAgICBpZiAoIWVsZW0gfHwgblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9IC8vIEZhbGxiYWNrIHRvIHByb3Agd2hlbiBhdHRyaWJ1dGVzIGFyZSBub3Qgc3VwcG9ydGVkXFxuXFxuXFxuICAgICAgaWYgKF90eXBlb2YoZWxlbS5nZXRBdHRyaWJ1dGUpID09PSBzdHJ1bmRlZmluZWQpIHtcXG4gICAgICAgIHJldHVybiBqUXVlcnkucHJvcChlbGVtLCBuYW1lLCB2YWx1ZSk7XFxuICAgICAgfSAvLyBBbGwgYXR0cmlidXRlcyBhcmUgbG93ZXJjYXNlXFxuICAgICAgLy8gR3JhYiBuZWNlc3NhcnkgaG9vayBpZiBvbmUgaXMgZGVmaW5lZFxcblxcblxcbiAgICAgIGlmIChuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKGVsZW0pKSB7XFxuICAgICAgICBuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xcbiAgICAgICAgaG9va3MgPSBqUXVlcnkuYXR0ckhvb2tzW25hbWVdIHx8IChqUXVlcnkuZXhwci5tYXRjaC5ib29sLnRlc3QobmFtZSkgPyBib29sSG9vayA6IG5vZGVIb29rKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xcbiAgICAgICAgICBqUXVlcnkucmVtb3ZlQXR0cihlbGVtLCBuYW1lKTtcXG4gICAgICAgIH0gZWxzZSBpZiAoaG9va3MgJiYgXFxcInNldFxcXCIgaW4gaG9va3MgJiYgKHJldCA9IGhvb2tzLnNldChlbGVtLCB2YWx1ZSwgbmFtZSkpICE9PSB1bmRlZmluZWQpIHtcXG4gICAgICAgICAgcmV0dXJuIHJldDtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlICsgXFxcIlxcXCIpO1xcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIGlmIChob29rcyAmJiBcXFwiZ2V0XFxcIiBpbiBob29rcyAmJiAocmV0ID0gaG9va3MuZ2V0KGVsZW0sIG5hbWUpKSAhPT0gbnVsbCkge1xcbiAgICAgICAgcmV0dXJuIHJldDtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgcmV0ID0galF1ZXJ5LmZpbmQuYXR0cihlbGVtLCBuYW1lKTsgLy8gTm9uLWV4aXN0ZW50IGF0dHJpYnV0ZXMgcmV0dXJuIG51bGwsIHdlIG5vcm1hbGl6ZSB0byB1bmRlZmluZWRcXG5cXG4gICAgICAgIHJldHVybiByZXQgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHJldDtcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIHJlbW92ZUF0dHI6IGZ1bmN0aW9uIHJlbW92ZUF0dHIoZWxlbSwgdmFsdWUpIHtcXG4gICAgICB2YXIgbmFtZSxcXG4gICAgICAgICAgcHJvcE5hbWUsXFxuICAgICAgICAgIGkgPSAwLFxcbiAgICAgICAgICBhdHRyTmFtZXMgPSB2YWx1ZSAmJiB2YWx1ZS5tYXRjaChybm90d2hpdGUpO1xcblxcbiAgICAgIGlmIChhdHRyTmFtZXMgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSkge1xcbiAgICAgICAgd2hpbGUgKG5hbWUgPSBhdHRyTmFtZXNbaSsrXSkge1xcbiAgICAgICAgICBwcm9wTmFtZSA9IGpRdWVyeS5wcm9wRml4W25hbWVdIHx8IG5hbWU7IC8vIEJvb2xlYW4gYXR0cmlidXRlcyBnZXQgc3BlY2lhbCB0cmVhdG1lbnQgKCMxMDg3MClcXG5cXG4gICAgICAgICAgaWYgKGpRdWVyeS5leHByLm1hdGNoLmJvb2wudGVzdChuYW1lKSkge1xcbiAgICAgICAgICAgIC8vIFNldCBjb3JyZXNwb25kaW5nIHByb3BlcnR5IHRvIGZhbHNlXFxuICAgICAgICAgICAgZWxlbVtwcm9wTmFtZV0gPSBmYWxzZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBlbGVtLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH0sXFxuICAgIGF0dHJIb29rczoge1xcbiAgICAgIHR5cGU6IHtcXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGVsZW0sIHZhbHVlKSB7XFxuICAgICAgICAgIGlmICghc3VwcG9ydC5yYWRpb1ZhbHVlICYmIHZhbHVlID09PSBcXFwicmFkaW9cXFwiICYmIGpRdWVyeS5ub2RlTmFtZShlbGVtLCBcXFwiaW5wdXRcXFwiKSkge1xcbiAgICAgICAgICAgIHZhciB2YWwgPSBlbGVtLnZhbHVlO1xcbiAgICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKFxcXCJ0eXBlXFxcIiwgdmFsdWUpO1xcblxcbiAgICAgICAgICAgIGlmICh2YWwpIHtcXG4gICAgICAgICAgICAgIGVsZW0udmFsdWUgPSB2YWw7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcbiAgfSk7IC8vIEhvb2tzIGZvciBib29sZWFuIGF0dHJpYnV0ZXNcXG5cXG4gIGJvb2xIb29rID0ge1xcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChlbGVtLCB2YWx1ZSwgbmFtZSkge1xcbiAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcXG4gICAgICAgIC8vIFJlbW92ZSBib29sZWFuIGF0dHJpYnV0ZXMgd2hlbiBzZXQgdG8gZmFsc2VcXG4gICAgICAgIGpRdWVyeS5yZW1vdmVBdHRyKGVsZW0sIG5hbWUpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZShuYW1lLCBuYW1lKTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIG5hbWU7XFxuICAgIH1cXG4gIH07XFxuICBqUXVlcnkuZWFjaChqUXVlcnkuZXhwci5tYXRjaC5ib29sLnNvdXJjZS5tYXRjaCgvXFxcXHcrL2cpLCBmdW5jdGlvbiAoaSwgbmFtZSkge1xcbiAgICB2YXIgZ2V0dGVyID0gYXR0ckhhbmRsZVtuYW1lXSB8fCBqUXVlcnkuZmluZC5hdHRyO1xcblxcbiAgICBhdHRySGFuZGxlW25hbWVdID0gZnVuY3Rpb24gKGVsZW0sIG5hbWUsIGlzWE1MKSB7XFxuICAgICAgdmFyIHJldCwgaGFuZGxlO1xcblxcbiAgICAgIGlmICghaXNYTUwpIHtcXG4gICAgICAgIC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3AgYnkgdGVtcG9yYXJpbHkgcmVtb3ZpbmcgdGhpcyBmdW5jdGlvbiBmcm9tIHRoZSBnZXR0ZXJcXG4gICAgICAgIGhhbmRsZSA9IGF0dHJIYW5kbGVbbmFtZV07XFxuICAgICAgICBhdHRySGFuZGxlW25hbWVdID0gcmV0O1xcbiAgICAgICAgcmV0ID0gZ2V0dGVyKGVsZW0sIG5hbWUsIGlzWE1MKSAhPSBudWxsID8gbmFtZS50b0xvd2VyQ2FzZSgpIDogbnVsbDtcXG4gICAgICAgIGF0dHJIYW5kbGVbbmFtZV0gPSBoYW5kbGU7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiByZXQ7XFxuICAgIH07XFxuICB9KTtcXG4gIHZhciByZm9jdXNhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaTtcXG4gIGpRdWVyeS5mbi5leHRlbmQoe1xcbiAgICBwcm9wOiBmdW5jdGlvbiBwcm9wKG5hbWUsIHZhbHVlKSB7XFxuICAgICAgcmV0dXJuIGFjY2Vzcyh0aGlzLCBqUXVlcnkucHJvcCwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxKTtcXG4gICAgfSxcXG4gICAgcmVtb3ZlUHJvcDogZnVuY3Rpb24gcmVtb3ZlUHJvcChuYW1lKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICBkZWxldGUgdGhpc1tqUXVlcnkucHJvcEZpeFtuYW1lXSB8fCBuYW1lXTtcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgfSk7XFxuICBqUXVlcnkuZXh0ZW5kKHtcXG4gICAgcHJvcEZpeDoge1xcbiAgICAgIFxcXCJmb3JcXFwiOiBcXFwiaHRtbEZvclxcXCIsXFxuICAgICAgXFxcImNsYXNzXFxcIjogXFxcImNsYXNzTmFtZVxcXCJcXG4gICAgfSxcXG4gICAgcHJvcDogZnVuY3Rpb24gcHJvcChlbGVtLCBuYW1lLCB2YWx1ZSkge1xcbiAgICAgIHZhciByZXQsXFxuICAgICAgICAgIGhvb2tzLFxcbiAgICAgICAgICBub3R4bWwsXFxuICAgICAgICAgIG5UeXBlID0gZWxlbS5ub2RlVHlwZTsgLy8gRG9uJ3QgZ2V0L3NldCBwcm9wZXJ0aWVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xcblxcbiAgICAgIGlmICghZWxlbSB8fCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMikge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBub3R4bWwgPSBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKGVsZW0pO1xcblxcbiAgICAgIGlmIChub3R4bWwpIHtcXG4gICAgICAgIC8vIEZpeCBuYW1lIGFuZCBhdHRhY2ggaG9va3NcXG4gICAgICAgIG5hbWUgPSBqUXVlcnkucHJvcEZpeFtuYW1lXSB8fCBuYW1lO1xcbiAgICAgICAgaG9va3MgPSBqUXVlcnkucHJvcEhvb2tzW25hbWVdO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgcmV0dXJuIGhvb2tzICYmIFxcXCJzZXRcXFwiIGluIGhvb2tzICYmIChyZXQgPSBob29rcy5zZXQoZWxlbSwgdmFsdWUsIG5hbWUpKSAhPT0gdW5kZWZpbmVkID8gcmV0IDogZWxlbVtuYW1lXSA9IHZhbHVlO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICByZXR1cm4gaG9va3MgJiYgXFxcImdldFxcXCIgaW4gaG9va3MgJiYgKHJldCA9IGhvb2tzLmdldChlbGVtLCBuYW1lKSkgIT09IG51bGwgPyByZXQgOiBlbGVtW25hbWVdO1xcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgcHJvcEhvb2tzOiB7XFxuICAgICAgdGFiSW5kZXg6IHtcXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KGVsZW0pIHtcXG4gICAgICAgICAgcmV0dXJuIGVsZW0uaGFzQXR0cmlidXRlKFxcXCJ0YWJpbmRleFxcXCIpIHx8IHJmb2N1c2FibGUudGVzdChlbGVtLm5vZGVOYW1lKSB8fCBlbGVtLmhyZWYgPyBlbGVtLnRhYkluZGV4IDogLTE7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuICB9KTtcXG5cXG4gIGlmICghc3VwcG9ydC5vcHRTZWxlY3RlZCkge1xcbiAgICBqUXVlcnkucHJvcEhvb2tzLnNlbGVjdGVkID0ge1xcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KGVsZW0pIHtcXG4gICAgICAgIHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XFxuXFxuICAgICAgICBpZiAocGFyZW50ICYmIHBhcmVudC5wYXJlbnROb2RlKSB7XFxuICAgICAgICAgIHBhcmVudC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gbnVsbDtcXG4gICAgICB9XFxuICAgIH07XFxuICB9XFxuXFxuICBqUXVlcnkuZWFjaChbXFxcInRhYkluZGV4XFxcIiwgXFxcInJlYWRPbmx5XFxcIiwgXFxcIm1heExlbmd0aFxcXCIsIFxcXCJjZWxsU3BhY2luZ1xcXCIsIFxcXCJjZWxsUGFkZGluZ1xcXCIsIFxcXCJyb3dTcGFuXFxcIiwgXFxcImNvbFNwYW5cXFwiLCBcXFwidXNlTWFwXFxcIiwgXFxcImZyYW1lQm9yZGVyXFxcIiwgXFxcImNvbnRlbnRFZGl0YWJsZVxcXCJdLCBmdW5jdGlvbiAoKSB7XFxuICAgIGpRdWVyeS5wcm9wRml4W3RoaXMudG9Mb3dlckNhc2UoKV0gPSB0aGlzO1xcbiAgfSk7XFxuICB2YXIgcmNsYXNzID0gL1tcXFxcdFxcXFxyXFxcXG5cXFxcZl0vZztcXG4gIGpRdWVyeS5mbi5leHRlbmQoe1xcbiAgICBhZGRDbGFzczogZnVuY3Rpb24gYWRkQ2xhc3ModmFsdWUpIHtcXG4gICAgICB2YXIgY2xhc3NlcyxcXG4gICAgICAgICAgZWxlbSxcXG4gICAgICAgICAgY3VyLFxcbiAgICAgICAgICBjbGF6eixcXG4gICAgICAgICAgaixcXG4gICAgICAgICAgZmluYWxWYWx1ZSxcXG4gICAgICAgICAgcHJvY2VlZCA9IHR5cGVvZiB2YWx1ZSA9PT0gXFxcInN0cmluZ1xcXCIgJiYgdmFsdWUsXFxuICAgICAgICAgIGkgPSAwLFxcbiAgICAgICAgICBsZW4gPSB0aGlzLmxlbmd0aDtcXG5cXG4gICAgICBpZiAoalF1ZXJ5LmlzRnVuY3Rpb24odmFsdWUpKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uIChqKSB7XFxuICAgICAgICAgIGpRdWVyeSh0aGlzKS5hZGRDbGFzcyh2YWx1ZS5jYWxsKHRoaXMsIGosIHRoaXMuY2xhc3NOYW1lKSk7XFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHByb2NlZWQpIHtcXG4gICAgICAgIC8vIFRoZSBkaXNqdW5jdGlvbiBoZXJlIGlzIGZvciBiZXR0ZXIgY29tcHJlc3NpYmlsaXR5IChzZWUgcmVtb3ZlQ2xhc3MpXFxuICAgICAgICBjbGFzc2VzID0gKHZhbHVlIHx8IFxcXCJcXFwiKS5tYXRjaChybm90d2hpdGUpIHx8IFtdO1xcblxcbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xcbiAgICAgICAgICBlbGVtID0gdGhpc1tpXTtcXG4gICAgICAgICAgY3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoZWxlbS5jbGFzc05hbWUgPyAoXFxcIiBcXFwiICsgZWxlbS5jbGFzc05hbWUgKyBcXFwiIFxcXCIpLnJlcGxhY2UocmNsYXNzLCBcXFwiIFxcXCIpIDogXFxcIiBcXFwiKTtcXG5cXG4gICAgICAgICAgaWYgKGN1cikge1xcbiAgICAgICAgICAgIGogPSAwO1xcblxcbiAgICAgICAgICAgIHdoaWxlIChjbGF6eiA9IGNsYXNzZXNbaisrXSkge1xcbiAgICAgICAgICAgICAgaWYgKGN1ci5pbmRleE9mKFxcXCIgXFxcIiArIGNsYXp6ICsgXFxcIiBcXFwiKSA8IDApIHtcXG4gICAgICAgICAgICAgICAgY3VyICs9IGNsYXp6ICsgXFxcIiBcXFwiO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0gLy8gb25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cXG5cXG5cXG4gICAgICAgICAgICBmaW5hbFZhbHVlID0galF1ZXJ5LnRyaW0oY3VyKTtcXG5cXG4gICAgICAgICAgICBpZiAoZWxlbS5jbGFzc05hbWUgIT09IGZpbmFsVmFsdWUpIHtcXG4gICAgICAgICAgICAgIGVsZW0uY2xhc3NOYW1lID0gZmluYWxWYWx1ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHRoaXM7XFxuICAgIH0sXFxuICAgIHJlbW92ZUNsYXNzOiBmdW5jdGlvbiByZW1vdmVDbGFzcyh2YWx1ZSkge1xcbiAgICAgIHZhciBjbGFzc2VzLFxcbiAgICAgICAgICBlbGVtLFxcbiAgICAgICAgICBjdXIsXFxuICAgICAgICAgIGNsYXp6LFxcbiAgICAgICAgICBqLFxcbiAgICAgICAgICBmaW5hbFZhbHVlLFxcbiAgICAgICAgICBwcm9jZWVkID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMCB8fCB0eXBlb2YgdmFsdWUgPT09IFxcXCJzdHJpbmdcXFwiICYmIHZhbHVlLFxcbiAgICAgICAgICBpID0gMCxcXG4gICAgICAgICAgbGVuID0gdGhpcy5sZW5ndGg7XFxuXFxuICAgICAgaWYgKGpRdWVyeS5pc0Z1bmN0aW9uKHZhbHVlKSkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoaikge1xcbiAgICAgICAgICBqUXVlcnkodGhpcykucmVtb3ZlQ2xhc3ModmFsdWUuY2FsbCh0aGlzLCBqLCB0aGlzLmNsYXNzTmFtZSkpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChwcm9jZWVkKSB7XFxuICAgICAgICBjbGFzc2VzID0gKHZhbHVlIHx8IFxcXCJcXFwiKS5tYXRjaChybm90d2hpdGUpIHx8IFtdO1xcblxcbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xcbiAgICAgICAgICBlbGVtID0gdGhpc1tpXTsgLy8gVGhpcyBleHByZXNzaW9uIGlzIGhlcmUgZm9yIGJldHRlciBjb21wcmVzc2liaWxpdHkgKHNlZSBhZGRDbGFzcylcXG5cXG4gICAgICAgICAgY3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoZWxlbS5jbGFzc05hbWUgPyAoXFxcIiBcXFwiICsgZWxlbS5jbGFzc05hbWUgKyBcXFwiIFxcXCIpLnJlcGxhY2UocmNsYXNzLCBcXFwiIFxcXCIpIDogXFxcIlxcXCIpO1xcblxcbiAgICAgICAgICBpZiAoY3VyKSB7XFxuICAgICAgICAgICAgaiA9IDA7XFxuXFxuICAgICAgICAgICAgd2hpbGUgKGNsYXp6ID0gY2xhc3Nlc1tqKytdKSB7XFxuICAgICAgICAgICAgICAvLyBSZW1vdmUgKmFsbCogaW5zdGFuY2VzXFxuICAgICAgICAgICAgICB3aGlsZSAoY3VyLmluZGV4T2YoXFxcIiBcXFwiICsgY2xhenogKyBcXFwiIFxcXCIpID49IDApIHtcXG4gICAgICAgICAgICAgICAgY3VyID0gY3VyLnJlcGxhY2UoXFxcIiBcXFwiICsgY2xhenogKyBcXFwiIFxcXCIsIFxcXCIgXFxcIik7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSAvLyBPbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxcblxcblxcbiAgICAgICAgICAgIGZpbmFsVmFsdWUgPSB2YWx1ZSA/IGpRdWVyeS50cmltKGN1cikgOiBcXFwiXFxcIjtcXG5cXG4gICAgICAgICAgICBpZiAoZWxlbS5jbGFzc05hbWUgIT09IGZpbmFsVmFsdWUpIHtcXG4gICAgICAgICAgICAgIGVsZW0uY2xhc3NOYW1lID0gZmluYWxWYWx1ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHRoaXM7XFxuICAgIH0sXFxuICAgIHRvZ2dsZUNsYXNzOiBmdW5jdGlvbiB0b2dnbGVDbGFzcyh2YWx1ZSwgc3RhdGVWYWwpIHtcXG4gICAgICB2YXIgdHlwZSA9IF90eXBlb2YodmFsdWUpO1xcblxcbiAgICAgIGlmICh0eXBlb2Ygc3RhdGVWYWwgPT09IFxcXCJib29sZWFuXFxcIiAmJiB0eXBlID09PSBcXFwic3RyaW5nXFxcIikge1xcbiAgICAgICAgcmV0dXJuIHN0YXRlVmFsID8gdGhpcy5hZGRDbGFzcyh2YWx1ZSkgOiB0aGlzLnJlbW92ZUNsYXNzKHZhbHVlKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGpRdWVyeS5pc0Z1bmN0aW9uKHZhbHVlKSkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoaSkge1xcbiAgICAgICAgICBqUXVlcnkodGhpcykudG9nZ2xlQ2xhc3ModmFsdWUuY2FsbCh0aGlzLCBpLCB0aGlzLmNsYXNzTmFtZSwgc3RhdGVWYWwpLCBzdGF0ZVZhbCk7XFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICBpZiAodHlwZSA9PT0gXFxcInN0cmluZ1xcXCIpIHtcXG4gICAgICAgICAgLy8gVG9nZ2xlIGluZGl2aWR1YWwgY2xhc3MgbmFtZXNcXG4gICAgICAgICAgdmFyIGNsYXNzTmFtZSxcXG4gICAgICAgICAgICAgIGkgPSAwLFxcbiAgICAgICAgICAgICAgc2VsZiA9IGpRdWVyeSh0aGlzKSxcXG4gICAgICAgICAgICAgIGNsYXNzTmFtZXMgPSB2YWx1ZS5tYXRjaChybm90d2hpdGUpIHx8IFtdO1xcblxcbiAgICAgICAgICB3aGlsZSAoY2xhc3NOYW1lID0gY2xhc3NOYW1lc1tpKytdKSB7XFxuICAgICAgICAgICAgLy8gQ2hlY2sgZWFjaCBjbGFzc05hbWUgZ2l2ZW4sIHNwYWNlIHNlcGFyYXRlZCBsaXN0XFxuICAgICAgICAgICAgaWYgKHNlbGYuaGFzQ2xhc3MoY2xhc3NOYW1lKSkge1xcbiAgICAgICAgICAgICAgc2VsZi5yZW1vdmVDbGFzcyhjbGFzc05hbWUpO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICBzZWxmLmFkZENsYXNzKGNsYXNzTmFtZSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9IC8vIFRvZ2dsZSB3aG9sZSBjbGFzcyBuYW1lXFxuXFxuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IHN0cnVuZGVmaW5lZCB8fCB0eXBlID09PSBcXFwiYm9vbGVhblxcXCIpIHtcXG4gICAgICAgICAgaWYgKHRoaXMuY2xhc3NOYW1lKSB7XFxuICAgICAgICAgICAgLy8gc3RvcmUgY2xhc3NOYW1lIGlmIHNldFxcbiAgICAgICAgICAgIGRhdGFfcHJpdi5zZXQodGhpcywgXFxcIl9fY2xhc3NOYW1lX19cXFwiLCB0aGlzLmNsYXNzTmFtZSk7XFxuICAgICAgICAgIH0gLy8gSWYgdGhlIGVsZW1lbnQgaGFzIGEgY2xhc3MgbmFtZSBvciBpZiB3ZSdyZSBwYXNzZWQgYGZhbHNlYCxcXG4gICAgICAgICAgLy8gdGhlbiByZW1vdmUgdGhlIHdob2xlIGNsYXNzbmFtZSAoaWYgdGhlcmUgd2FzIG9uZSwgdGhlIGFib3ZlIHNhdmVkIGl0KS5cXG4gICAgICAgICAgLy8gT3RoZXJ3aXNlIGJyaW5nIGJhY2sgd2hhdGV2ZXIgd2FzIHByZXZpb3VzbHkgc2F2ZWQgKGlmIGFueXRoaW5nKSxcXG4gICAgICAgICAgLy8gZmFsbGluZyBiYWNrIHRvIHRoZSBlbXB0eSBzdHJpbmcgaWYgbm90aGluZyB3YXMgc3RvcmVkLlxcblxcblxcbiAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IHRoaXMuY2xhc3NOYW1lIHx8IHZhbHVlID09PSBmYWxzZSA/IFxcXCJcXFwiIDogZGF0YV9wcml2LmdldCh0aGlzLCBcXFwiX19jbGFzc05hbWVfX1xcXCIpIHx8IFxcXCJcXFwiO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcbiAgICB9LFxcbiAgICBoYXNDbGFzczogZnVuY3Rpb24gaGFzQ2xhc3Moc2VsZWN0b3IpIHtcXG4gICAgICB2YXIgY2xhc3NOYW1lID0gXFxcIiBcXFwiICsgc2VsZWN0b3IgKyBcXFwiIFxcXCIsXFxuICAgICAgICAgIGkgPSAwLFxcbiAgICAgICAgICBsID0gdGhpcy5sZW5ndGg7XFxuXFxuICAgICAgZm9yICg7IGkgPCBsOyBpKyspIHtcXG4gICAgICAgIGlmICh0aGlzW2ldLm5vZGVUeXBlID09PSAxICYmIChcXFwiIFxcXCIgKyB0aGlzW2ldLmNsYXNzTmFtZSArIFxcXCIgXFxcIikucmVwbGFjZShyY2xhc3MsIFxcXCIgXFxcIikuaW5kZXhPZihjbGFzc05hbWUpID49IDApIHtcXG4gICAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcbiAgfSk7XFxuICB2YXIgcnJldHVybiA9IC9cXFxcci9nO1xcbiAgalF1ZXJ5LmZuLmV4dGVuZCh7XFxuICAgIHZhbDogZnVuY3Rpb24gdmFsKHZhbHVlKSB7XFxuICAgICAgdmFyIGhvb2tzLFxcbiAgICAgICAgICByZXQsXFxuICAgICAgICAgIGlzRnVuY3Rpb24sXFxuICAgICAgICAgIGVsZW0gPSB0aGlzWzBdO1xcblxcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xcbiAgICAgICAgaWYgKGVsZW0pIHtcXG4gICAgICAgICAgaG9va3MgPSBqUXVlcnkudmFsSG9va3NbZWxlbS50eXBlXSB8fCBqUXVlcnkudmFsSG9va3NbZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpXTtcXG5cXG4gICAgICAgICAgaWYgKGhvb2tzICYmIFxcXCJnZXRcXFwiIGluIGhvb2tzICYmIChyZXQgPSBob29rcy5nZXQoZWxlbSwgXFxcInZhbHVlXFxcIikpICE9PSB1bmRlZmluZWQpIHtcXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHJldCA9IGVsZW0udmFsdWU7XFxuICAgICAgICAgIHJldHVybiB0eXBlb2YgcmV0ID09PSBcXFwic3RyaW5nXFxcIiA/IC8vIEhhbmRsZSBtb3N0IGNvbW1vbiBzdHJpbmcgY2FzZXNcXG4gICAgICAgICAgcmV0LnJlcGxhY2UocnJldHVybiwgXFxcIlxcXCIpIDogLy8gSGFuZGxlIGNhc2VzIHdoZXJlIHZhbHVlIGlzIG51bGwvdW5kZWYgb3IgbnVtYmVyXFxuICAgICAgICAgIHJldCA9PSBudWxsID8gXFxcIlxcXCIgOiByZXQ7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGlzRnVuY3Rpb24gPSBqUXVlcnkuaXNGdW5jdGlvbih2YWx1ZSk7XFxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoaSkge1xcbiAgICAgICAgdmFyIHZhbDtcXG5cXG4gICAgICAgIGlmICh0aGlzLm5vZGVUeXBlICE9PSAxKSB7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKSB7XFxuICAgICAgICAgIHZhbCA9IHZhbHVlLmNhbGwodGhpcywgaSwgalF1ZXJ5KHRoaXMpLnZhbCgpKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHZhbCA9IHZhbHVlO1xcbiAgICAgICAgfSAvLyBUcmVhdCBudWxsL3VuZGVmaW5lZCBhcyBcXFwiXFxcIjsgY29udmVydCBudW1iZXJzIHRvIHN0cmluZ1xcblxcblxcbiAgICAgICAgaWYgKHZhbCA9PSBudWxsKSB7XFxuICAgICAgICAgIHZhbCA9IFxcXCJcXFwiO1xcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSBcXFwibnVtYmVyXFxcIikge1xcbiAgICAgICAgICB2YWwgKz0gXFxcIlxcXCI7XFxuICAgICAgICB9IGVsc2UgaWYgKGpRdWVyeS5pc0FycmF5KHZhbCkpIHtcXG4gICAgICAgICAgdmFsID0galF1ZXJ5Lm1hcCh2YWwsIGZ1bmN0aW9uICh2YWx1ZSkge1xcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gXFxcIlxcXCIgOiB2YWx1ZSArIFxcXCJcXFwiO1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzW3RoaXMudHlwZV0gfHwgalF1ZXJ5LnZhbEhvb2tzW3RoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKV07IC8vIElmIHNldCByZXR1cm5zIHVuZGVmaW5lZCwgZmFsbCBiYWNrIHRvIG5vcm1hbCBzZXR0aW5nXFxuXFxuICAgICAgICBpZiAoIWhvb2tzIHx8ICEoXFxcInNldFxcXCIgaW4gaG9va3MpIHx8IGhvb2tzLnNldCh0aGlzLCB2YWwsIFxcXCJ2YWx1ZVxcXCIpID09PSB1bmRlZmluZWQpIHtcXG4gICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbDtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgfVxcbiAgfSk7XFxuICBqUXVlcnkuZXh0ZW5kKHtcXG4gICAgdmFsSG9va3M6IHtcXG4gICAgICBvcHRpb246IHtcXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KGVsZW0pIHtcXG4gICAgICAgICAgdmFyIHZhbCA9IGpRdWVyeS5maW5kLmF0dHIoZWxlbSwgXFxcInZhbHVlXFxcIik7XFxuICAgICAgICAgIHJldHVybiB2YWwgIT0gbnVsbCA/IHZhbCA6IC8vIFN1cHBvcnQ6IElFMTAtMTErXFxuICAgICAgICAgIC8vIG9wdGlvbi50ZXh0IHRocm93cyBleGNlcHRpb25zICgjMTQ2ODYsICMxNDg1OClcXG4gICAgICAgICAgalF1ZXJ5LnRyaW0oalF1ZXJ5LnRleHQoZWxlbSkpO1xcbiAgICAgICAgfVxcbiAgICAgIH0sXFxuICAgICAgc2VsZWN0OiB7XFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldChlbGVtKSB7XFxuICAgICAgICAgIHZhciB2YWx1ZSxcXG4gICAgICAgICAgICAgIG9wdGlvbixcXG4gICAgICAgICAgICAgIG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXFxuICAgICAgICAgICAgICBpbmRleCA9IGVsZW0uc2VsZWN0ZWRJbmRleCxcXG4gICAgICAgICAgICAgIG9uZSA9IGVsZW0udHlwZSA9PT0gXFxcInNlbGVjdC1vbmVcXFwiIHx8IGluZGV4IDwgMCxcXG4gICAgICAgICAgICAgIHZhbHVlcyA9IG9uZSA/IG51bGwgOiBbXSxcXG4gICAgICAgICAgICAgIG1heCA9IG9uZSA/IGluZGV4ICsgMSA6IG9wdGlvbnMubGVuZ3RoLFxcbiAgICAgICAgICAgICAgaSA9IGluZGV4IDwgMCA/IG1heCA6IG9uZSA/IGluZGV4IDogMDsgLy8gTG9vcCB0aHJvdWdoIGFsbCB0aGUgc2VsZWN0ZWQgb3B0aW9uc1xcblxcbiAgICAgICAgICBmb3IgKDsgaSA8IG1heDsgaSsrKSB7XFxuICAgICAgICAgICAgb3B0aW9uID0gb3B0aW9uc1tpXTsgLy8gSUU2LTkgZG9lc24ndCB1cGRhdGUgc2VsZWN0ZWQgYWZ0ZXIgZm9ybSByZXNldCAoIzI1NTEpXFxuXFxuICAgICAgICAgICAgaWYgKChvcHRpb24uc2VsZWN0ZWQgfHwgaSA9PT0gaW5kZXgpICYmICggLy8gRG9uJ3QgcmV0dXJuIG9wdGlvbnMgdGhhdCBhcmUgZGlzYWJsZWQgb3IgaW4gYSBkaXNhYmxlZCBvcHRncm91cFxcbiAgICAgICAgICAgIHN1cHBvcnQub3B0RGlzYWJsZWQgPyAhb3B0aW9uLmRpc2FibGVkIDogb3B0aW9uLmdldEF0dHJpYnV0ZShcXFwiZGlzYWJsZWRcXFwiKSA9PT0gbnVsbCkgJiYgKCFvcHRpb24ucGFyZW50Tm9kZS5kaXNhYmxlZCB8fCAhalF1ZXJ5Lm5vZGVOYW1lKG9wdGlvbi5wYXJlbnROb2RlLCBcXFwib3B0Z3JvdXBcXFwiKSkpIHtcXG4gICAgICAgICAgICAgIC8vIEdldCB0aGUgc3BlY2lmaWMgdmFsdWUgZm9yIHRoZSBvcHRpb25cXG4gICAgICAgICAgICAgIHZhbHVlID0galF1ZXJ5KG9wdGlvbikudmFsKCk7IC8vIFdlIGRvbid0IG5lZWQgYW4gYXJyYXkgZm9yIG9uZSBzZWxlY3RzXFxuXFxuICAgICAgICAgICAgICBpZiAob25lKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcXG4gICAgICAgICAgICAgIH0gLy8gTXVsdGktU2VsZWN0cyByZXR1cm4gYW4gYXJyYXlcXG5cXG5cXG4gICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgcmV0dXJuIHZhbHVlcztcXG4gICAgICAgIH0sXFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChlbGVtLCB2YWx1ZSkge1xcbiAgICAgICAgICB2YXIgb3B0aW9uU2V0LFxcbiAgICAgICAgICAgICAgb3B0aW9uLFxcbiAgICAgICAgICAgICAgb3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcXG4gICAgICAgICAgICAgIHZhbHVlcyA9IGpRdWVyeS5tYWtlQXJyYXkodmFsdWUpLFxcbiAgICAgICAgICAgICAgaSA9IG9wdGlvbnMubGVuZ3RoO1xcblxcbiAgICAgICAgICB3aGlsZSAoaS0tKSB7XFxuICAgICAgICAgICAgb3B0aW9uID0gb3B0aW9uc1tpXTtcXG5cXG4gICAgICAgICAgICBpZiAob3B0aW9uLnNlbGVjdGVkID0galF1ZXJ5LmluQXJyYXkob3B0aW9uLnZhbHVlLCB2YWx1ZXMpID49IDApIHtcXG4gICAgICAgICAgICAgIG9wdGlvblNldCA9IHRydWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9IC8vIEZvcmNlIGJyb3dzZXJzIHRvIGJlaGF2ZSBjb25zaXN0ZW50bHkgd2hlbiBub24tbWF0Y2hpbmcgdmFsdWUgaXMgc2V0XFxuXFxuXFxuICAgICAgICAgIGlmICghb3B0aW9uU2V0KSB7XFxuICAgICAgICAgICAgZWxlbS5zZWxlY3RlZEluZGV4ID0gLTE7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgcmV0dXJuIHZhbHVlcztcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG4gIH0pOyAvLyBSYWRpb3MgYW5kIGNoZWNrYm94ZXMgZ2V0dGVyL3NldHRlclxcblxcbiAgalF1ZXJ5LmVhY2goW1xcXCJyYWRpb1xcXCIsIFxcXCJjaGVja2JveFxcXCJdLCBmdW5jdGlvbiAoKSB7XFxuICAgIGpRdWVyeS52YWxIb29rc1t0aGlzXSA9IHtcXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldChlbGVtLCB2YWx1ZSkge1xcbiAgICAgICAgaWYgKGpRdWVyeS5pc0FycmF5KHZhbHVlKSkge1xcbiAgICAgICAgICByZXR1cm4gZWxlbS5jaGVja2VkID0galF1ZXJ5LmluQXJyYXkoalF1ZXJ5KGVsZW0pLnZhbCgpLCB2YWx1ZSkgPj0gMDtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH07XFxuXFxuICAgIGlmICghc3VwcG9ydC5jaGVja09uKSB7XFxuICAgICAgalF1ZXJ5LnZhbEhvb2tzW3RoaXNdLmdldCA9IGZ1bmN0aW9uIChlbGVtKSB7XFxuICAgICAgICByZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoXFxcInZhbHVlXFxcIikgPT09IG51bGwgPyBcXFwib25cXFwiIDogZWxlbS52YWx1ZTtcXG4gICAgICB9O1xcbiAgICB9XFxuICB9KTsgLy8gUmV0dXJuIGpRdWVyeSBmb3IgYXR0cmlidXRlcy1vbmx5IGluY2x1c2lvblxcblxcbiAgalF1ZXJ5LmVhY2goKFxcXCJibHVyIGZvY3VzIGZvY3VzaW4gZm9jdXNvdXQgbG9hZCByZXNpemUgc2Nyb2xsIHVubG9hZCBjbGljayBkYmxjbGljayBcXFwiICsgXFxcIm1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIFxcXCIgKyBcXFwiY2hhbmdlIHNlbGVjdCBzdWJtaXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBlcnJvciBjb250ZXh0bWVudVxcXCIpLnNwbGl0KFxcXCIgXFxcIiksIGZ1bmN0aW9uIChpLCBuYW1lKSB7XFxuICAgIC8vIEhhbmRsZSBldmVudCBiaW5kaW5nXFxuICAgIGpRdWVyeS5mbltuYW1lXSA9IGZ1bmN0aW9uIChkYXRhLCBmbikge1xcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMCA/IHRoaXMub24obmFtZSwgbnVsbCwgZGF0YSwgZm4pIDogdGhpcy50cmlnZ2VyKG5hbWUpO1xcbiAgICB9O1xcbiAgfSk7XFxuICBqUXVlcnkuZm4uZXh0ZW5kKHtcXG4gICAgaG92ZXI6IGZ1bmN0aW9uIGhvdmVyKGZuT3ZlciwgZm5PdXQpIHtcXG4gICAgICByZXR1cm4gdGhpcy5tb3VzZWVudGVyKGZuT3ZlcikubW91c2VsZWF2ZShmbk91dCB8fCBmbk92ZXIpO1xcbiAgICB9LFxcbiAgICBiaW5kOiBmdW5jdGlvbiBiaW5kKHR5cGVzLCBkYXRhLCBmbikge1xcbiAgICAgIHJldHVybiB0aGlzLm9uKHR5cGVzLCBudWxsLCBkYXRhLCBmbik7XFxuICAgIH0sXFxuICAgIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKHR5cGVzLCBmbikge1xcbiAgICAgIHJldHVybiB0aGlzLm9mZih0eXBlcywgbnVsbCwgZm4pO1xcbiAgICB9LFxcbiAgICBkZWxlZ2F0ZTogZnVuY3Rpb24gZGVsZWdhdGUoc2VsZWN0b3IsIHR5cGVzLCBkYXRhLCBmbikge1xcbiAgICAgIHJldHVybiB0aGlzLm9uKHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4pO1xcbiAgICB9LFxcbiAgICB1bmRlbGVnYXRlOiBmdW5jdGlvbiB1bmRlbGVnYXRlKHNlbGVjdG9yLCB0eXBlcywgZm4pIHtcXG4gICAgICAvLyAoIG5hbWVzcGFjZSApIG9yICggc2VsZWN0b3IsIHR5cGVzIFssIGZuXSApXFxuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyB0aGlzLm9mZihzZWxlY3RvciwgXFxcIioqXFxcIikgOiB0aGlzLm9mZih0eXBlcywgc2VsZWN0b3IgfHwgXFxcIioqXFxcIiwgZm4pO1xcbiAgICB9XFxuICB9KTtcXG4gIHZhciBub25jZSA9IGpRdWVyeS5ub3coKTtcXG4gIHZhciBycXVlcnkgPSAvXFxcXD8vOyAvLyBTdXBwb3J0OiBBbmRyb2lkIDIuM1xcbiAgLy8gV29ya2Fyb3VuZCBmYWlsdXJlIHRvIHN0cmluZy1jYXN0IG51bGwgaW5wdXRcXG5cXG4gIGpRdWVyeS5wYXJzZUpTT04gPSBmdW5jdGlvbiAoZGF0YSkge1xcbiAgICByZXR1cm4gSlNPTi5wYXJzZShkYXRhICsgXFxcIlxcXCIpO1xcbiAgfTsgLy8gQ3Jvc3MtYnJvd3NlciB4bWwgcGFyc2luZ1xcblxcblxcbiAgalF1ZXJ5LnBhcnNlWE1MID0gZnVuY3Rpb24gKGRhdGEpIHtcXG4gICAgdmFyIHhtbCwgdG1wO1xcblxcbiAgICBpZiAoIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09IFxcXCJzdHJpbmdcXFwiKSB7XFxuICAgICAgcmV0dXJuIG51bGw7XFxuICAgIH0gLy8gU3VwcG9ydDogSUU5XFxuXFxuXFxuICAgIHRyeSB7XFxuICAgICAgdG1wID0gbmV3IERPTVBhcnNlcigpO1xcbiAgICAgIHhtbCA9IHRtcC5wYXJzZUZyb21TdHJpbmcoZGF0YSwgXFxcInRleHQveG1sXFxcIik7XFxuICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICB4bWwgPSB1bmRlZmluZWQ7XFxuICAgIH1cXG5cXG4gICAgaWYgKCF4bWwgfHwgeG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFxcXCJwYXJzZXJlcnJvclxcXCIpLmxlbmd0aCkge1xcbiAgICAgIGpRdWVyeS5lcnJvcihcXFwiSW52YWxpZCBYTUw6IFxcXCIgKyBkYXRhKTtcXG4gICAgfVxcblxcbiAgICByZXR1cm4geG1sO1xcbiAgfTtcXG5cXG4gIHZhciByaGFzaCA9IC8jLiokLyxcXG4gICAgICBydHMgPSAvKFs/Jl0pXz1bXiZdKi8sXFxuICAgICAgcmhlYWRlcnMgPSAvXiguKj8pOlsgXFxcXHRdKihbXlxcXFxyXFxcXG5dKikkL21nLFxcbiAgICAgIC8vICM3NjUzLCAjODEyNSwgIzgxNTI6IGxvY2FsIHByb3RvY29sIGRldGVjdGlvblxcbiAgcmxvY2FsUHJvdG9jb2wgPSAvXig/OmFib3V0fGFwcHxhcHAtc3RvcmFnZXwuKy1leHRlbnNpb258ZmlsZXxyZXN8d2lkZ2V0KTokLyxcXG4gICAgICBybm9Db250ZW50ID0gL14oPzpHRVR8SEVBRCkkLyxcXG4gICAgICBycHJvdG9jb2wgPSAvXlxcXFwvXFxcXC8vLFxcbiAgICAgIHJ1cmwgPSAvXihbXFxcXHcuKy1dKzopKD86XFxcXC9cXFxcLyg/OlteXFxcXC8/I10qQHwpKFteXFxcXC8/IzpdKikoPzo6KFxcXFxkKyl8KXwpLyxcXG5cXG4gIC8qIFByZWZpbHRlcnNcXG4gICAqIDEpIFRoZXkgYXJlIHVzZWZ1bCB0byBpbnRyb2R1Y2UgY3VzdG9tIGRhdGFUeXBlcyAoc2VlIGFqYXgvanNvbnAuanMgZm9yIGFuIGV4YW1wbGUpXFxuICAgKiAyKSBUaGVzZSBhcmUgY2FsbGVkOlxcbiAgICogICAgLSBCRUZPUkUgYXNraW5nIGZvciBhIHRyYW5zcG9ydFxcbiAgICogICAgLSBBRlRFUiBwYXJhbSBzZXJpYWxpemF0aW9uIChzLmRhdGEgaXMgYSBzdHJpbmcgaWYgcy5wcm9jZXNzRGF0YSBpcyB0cnVlKVxcbiAgICogMykga2V5IGlzIHRoZSBkYXRhVHlwZVxcbiAgICogNCkgdGhlIGNhdGNoYWxsIHN5bWJvbCBcXFwiKlxcXCIgY2FuIGJlIHVzZWRcXG4gICAqIDUpIGV4ZWN1dGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGNvbnRpbnVlIGRvd24gdG8gXFxcIipcXFwiIGlmIG5lZWRlZFxcbiAgICovXFxuICBwcmVmaWx0ZXJzID0ge30sXFxuXFxuICAvKiBUcmFuc3BvcnRzIGJpbmRpbmdzXFxuICAgKiAxKSBrZXkgaXMgdGhlIGRhdGFUeXBlXFxuICAgKiAyKSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFxcXCIqXFxcIiBjYW4gYmUgdXNlZFxcbiAgICogMykgc2VsZWN0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gZ28gdG8gXFxcIipcXFwiIGlmIG5lZWRlZFxcbiAgICovXFxuICB0cmFuc3BvcnRzID0ge30sXFxuICAgICAgLy8gQXZvaWQgY29tbWVudC1wcm9sb2cgY2hhciBzZXF1ZW5jZSAoIzEwMDk4KTsgbXVzdCBhcHBlYXNlIGxpbnQgYW5kIGV2YWRlIGNvbXByZXNzaW9uXFxuICBhbGxUeXBlcyA9IFxcXCIqL1xcXCIuY29uY2F0KFxcXCIqXFxcIiksXFxuICAgICAgLy8gRG9jdW1lbnQgbG9jYXRpb25cXG4gIGFqYXhMb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmLFxcbiAgICAgIC8vIFNlZ21lbnQgbG9jYXRpb24gaW50byBwYXJ0c1xcbiAgYWpheExvY1BhcnRzID0gcnVybC5leGVjKGFqYXhMb2NhdGlvbi50b0xvd2VyQ2FzZSgpKSB8fCBbXTsgLy8gQmFzZSBcXFwiY29uc3RydWN0b3JcXFwiIGZvciBqUXVlcnkuYWpheFByZWZpbHRlciBhbmQgalF1ZXJ5LmFqYXhUcmFuc3BvcnRcXG5cXG4gIGZ1bmN0aW9uIGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyhzdHJ1Y3R1cmUpIHtcXG4gICAgLy8gZGF0YVR5cGVFeHByZXNzaW9uIGlzIG9wdGlvbmFsIGFuZCBkZWZhdWx0cyB0byBcXFwiKlxcXCJcXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhVHlwZUV4cHJlc3Npb24sIGZ1bmMpIHtcXG4gICAgICBpZiAodHlwZW9mIGRhdGFUeXBlRXhwcmVzc2lvbiAhPT0gXFxcInN0cmluZ1xcXCIpIHtcXG4gICAgICAgIGZ1bmMgPSBkYXRhVHlwZUV4cHJlc3Npb247XFxuICAgICAgICBkYXRhVHlwZUV4cHJlc3Npb24gPSBcXFwiKlxcXCI7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBkYXRhVHlwZSxcXG4gICAgICAgICAgaSA9IDAsXFxuICAgICAgICAgIGRhdGFUeXBlcyA9IGRhdGFUeXBlRXhwcmVzc2lvbi50b0xvd2VyQ2FzZSgpLm1hdGNoKHJub3R3aGl0ZSkgfHwgW107XFxuXFxuICAgICAgaWYgKGpRdWVyeS5pc0Z1bmN0aW9uKGZ1bmMpKSB7XFxuICAgICAgICAvLyBGb3IgZWFjaCBkYXRhVHlwZSBpbiB0aGUgZGF0YVR5cGVFeHByZXNzaW9uXFxuICAgICAgICB3aGlsZSAoZGF0YVR5cGUgPSBkYXRhVHlwZXNbaSsrXSkge1xcbiAgICAgICAgICAvLyBQcmVwZW5kIGlmIHJlcXVlc3RlZFxcbiAgICAgICAgICBpZiAoZGF0YVR5cGVbMF0gPT09IFxcXCIrXFxcIikge1xcbiAgICAgICAgICAgIGRhdGFUeXBlID0gZGF0YVR5cGUuc2xpY2UoMSkgfHwgXFxcIipcXFwiO1xcbiAgICAgICAgICAgIChzdHJ1Y3R1cmVbZGF0YVR5cGVdID0gc3RydWN0dXJlW2RhdGFUeXBlXSB8fCBbXSkudW5zaGlmdChmdW5jKTsgLy8gT3RoZXJ3aXNlIGFwcGVuZFxcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIChzdHJ1Y3R1cmVbZGF0YVR5cGVdID0gc3RydWN0dXJlW2RhdGFUeXBlXSB8fCBbXSkucHVzaChmdW5jKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfTtcXG4gIH0gLy8gQmFzZSBpbnNwZWN0aW9uIGZ1bmN0aW9uIGZvciBwcmVmaWx0ZXJzIGFuZCB0cmFuc3BvcnRzXFxuXFxuXFxuICBmdW5jdGlvbiBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyhzdHJ1Y3R1cmUsIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIpIHtcXG4gICAgdmFyIGluc3BlY3RlZCA9IHt9LFxcbiAgICAgICAgc2Vla2luZ1RyYW5zcG9ydCA9IHN0cnVjdHVyZSA9PT0gdHJhbnNwb3J0cztcXG5cXG4gICAgZnVuY3Rpb24gaW5zcGVjdChkYXRhVHlwZSkge1xcbiAgICAgIHZhciBzZWxlY3RlZDtcXG4gICAgICBpbnNwZWN0ZWRbZGF0YVR5cGVdID0gdHJ1ZTtcXG4gICAgICBqUXVlcnkuZWFjaChzdHJ1Y3R1cmVbZGF0YVR5cGVdIHx8IFtdLCBmdW5jdGlvbiAoXywgcHJlZmlsdGVyT3JGYWN0b3J5KSB7XFxuICAgICAgICB2YXIgZGF0YVR5cGVPclRyYW5zcG9ydCA9IHByZWZpbHRlck9yRmFjdG9yeShvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSKTtcXG5cXG4gICAgICAgIGlmICh0eXBlb2YgZGF0YVR5cGVPclRyYW5zcG9ydCA9PT0gXFxcInN0cmluZ1xcXCIgJiYgIXNlZWtpbmdUcmFuc3BvcnQgJiYgIWluc3BlY3RlZFtkYXRhVHlwZU9yVHJhbnNwb3J0XSkge1xcbiAgICAgICAgICBvcHRpb25zLmRhdGFUeXBlcy51bnNoaWZ0KGRhdGFUeXBlT3JUcmFuc3BvcnQpO1xcbiAgICAgICAgICBpbnNwZWN0KGRhdGFUeXBlT3JUcmFuc3BvcnQpO1xcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICB9IGVsc2UgaWYgKHNlZWtpbmdUcmFuc3BvcnQpIHtcXG4gICAgICAgICAgcmV0dXJuICEoc2VsZWN0ZWQgPSBkYXRhVHlwZU9yVHJhbnNwb3J0KTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgICByZXR1cm4gc2VsZWN0ZWQ7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIGluc3BlY3Qob3B0aW9ucy5kYXRhVHlwZXNbMF0pIHx8ICFpbnNwZWN0ZWRbXFxcIipcXFwiXSAmJiBpbnNwZWN0KFxcXCIqXFxcIik7XFxuICB9IC8vIEEgc3BlY2lhbCBleHRlbmQgZm9yIGFqYXggb3B0aW9uc1xcbiAgLy8gdGhhdCB0YWtlcyBcXFwiZmxhdFxcXCIgb3B0aW9ucyAobm90IHRvIGJlIGRlZXAgZXh0ZW5kZWQpXFxuICAvLyBGaXhlcyAjOTg4N1xcblxcblxcbiAgZnVuY3Rpb24gYWpheEV4dGVuZCh0YXJnZXQsIHNyYykge1xcbiAgICB2YXIga2V5LFxcbiAgICAgICAgZGVlcCxcXG4gICAgICAgIGZsYXRPcHRpb25zID0galF1ZXJ5LmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9ucyB8fCB7fTtcXG5cXG4gICAgZm9yIChrZXkgaW4gc3JjKSB7XFxuICAgICAgaWYgKHNyY1trZXldICE9PSB1bmRlZmluZWQpIHtcXG4gICAgICAgIChmbGF0T3B0aW9uc1trZXldID8gdGFyZ2V0IDogZGVlcCB8fCAoZGVlcCA9IHt9KSlba2V5XSA9IHNyY1trZXldO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBpZiAoZGVlcCkge1xcbiAgICAgIGpRdWVyeS5leHRlbmQodHJ1ZSwgdGFyZ2V0LCBkZWVwKTtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gdGFyZ2V0O1xcbiAgfVxcbiAgLyogSGFuZGxlcyByZXNwb25zZXMgdG8gYW4gYWpheCByZXF1ZXN0OlxcbiAgICogLSBmaW5kcyB0aGUgcmlnaHQgZGF0YVR5cGUgKG1lZGlhdGVzIGJldHdlZW4gY29udGVudC10eXBlIGFuZCBleHBlY3RlZCBkYXRhVHlwZSlcXG4gICAqIC0gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxcbiAgICovXFxuXFxuXFxuICBmdW5jdGlvbiBhamF4SGFuZGxlUmVzcG9uc2VzKHMsIGpxWEhSLCByZXNwb25zZXMpIHtcXG4gICAgdmFyIGN0LFxcbiAgICAgICAgdHlwZSxcXG4gICAgICAgIGZpbmFsRGF0YVR5cGUsXFxuICAgICAgICBmaXJzdERhdGFUeXBlLFxcbiAgICAgICAgY29udGVudHMgPSBzLmNvbnRlbnRzLFxcbiAgICAgICAgZGF0YVR5cGVzID0gcy5kYXRhVHlwZXM7IC8vIFJlbW92ZSBhdXRvIGRhdGFUeXBlIGFuZCBnZXQgY29udGVudC10eXBlIGluIHRoZSBwcm9jZXNzXFxuXFxuICAgIHdoaWxlIChkYXRhVHlwZXNbMF0gPT09IFxcXCIqXFxcIikge1xcbiAgICAgIGRhdGFUeXBlcy5zaGlmdCgpO1xcblxcbiAgICAgIGlmIChjdCA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICBjdCA9IHMubWltZVR5cGUgfHwganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoXFxcIkNvbnRlbnQtVHlwZVxcXCIpO1xcbiAgICAgIH1cXG4gICAgfSAvLyBDaGVjayBpZiB3ZSdyZSBkZWFsaW5nIHdpdGggYSBrbm93biBjb250ZW50LXR5cGVcXG5cXG5cXG4gICAgaWYgKGN0KSB7XFxuICAgICAgZm9yICh0eXBlIGluIGNvbnRlbnRzKSB7XFxuICAgICAgICBpZiAoY29udGVudHNbdHlwZV0gJiYgY29udGVudHNbdHlwZV0udGVzdChjdCkpIHtcXG4gICAgICAgICAgZGF0YVR5cGVzLnVuc2hpZnQodHlwZSk7XFxuICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfSAvLyBDaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBhIHJlc3BvbnNlIGZvciB0aGUgZXhwZWN0ZWQgZGF0YVR5cGVcXG5cXG5cXG4gICAgaWYgKGRhdGFUeXBlc1swXSBpbiByZXNwb25zZXMpIHtcXG4gICAgICBmaW5hbERhdGFUeXBlID0gZGF0YVR5cGVzWzBdO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIC8vIFRyeSBjb252ZXJ0aWJsZSBkYXRhVHlwZXNcXG4gICAgICBmb3IgKHR5cGUgaW4gcmVzcG9uc2VzKSB7XFxuICAgICAgICBpZiAoIWRhdGFUeXBlc1swXSB8fCBzLmNvbnZlcnRlcnNbdHlwZSArIFxcXCIgXFxcIiArIGRhdGFUeXBlc1swXV0pIHtcXG4gICAgICAgICAgZmluYWxEYXRhVHlwZSA9IHR5cGU7XFxuICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKCFmaXJzdERhdGFUeXBlKSB7XFxuICAgICAgICAgIGZpcnN0RGF0YVR5cGUgPSB0eXBlO1xcbiAgICAgICAgfVxcbiAgICAgIH0gLy8gT3IganVzdCB1c2UgZmlyc3Qgb25lXFxuXFxuXFxuICAgICAgZmluYWxEYXRhVHlwZSA9IGZpbmFsRGF0YVR5cGUgfHwgZmlyc3REYXRhVHlwZTtcXG4gICAgfSAvLyBJZiB3ZSBmb3VuZCBhIGRhdGFUeXBlXFxuICAgIC8vIFdlIGFkZCB0aGUgZGF0YVR5cGUgdG8gdGhlIGxpc3QgaWYgbmVlZGVkXFxuICAgIC8vIGFuZCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2VcXG5cXG5cXG4gICAgaWYgKGZpbmFsRGF0YVR5cGUpIHtcXG4gICAgICBpZiAoZmluYWxEYXRhVHlwZSAhPT0gZGF0YVR5cGVzWzBdKSB7XFxuICAgICAgICBkYXRhVHlwZXMudW5zaGlmdChmaW5hbERhdGFUeXBlKTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHJlc3BvbnNlc1tmaW5hbERhdGFUeXBlXTtcXG4gICAgfVxcbiAgfVxcbiAgLyogQ2hhaW4gY29udmVyc2lvbnMgZ2l2ZW4gdGhlIHJlcXVlc3QgYW5kIHRoZSBvcmlnaW5hbCByZXNwb25zZVxcbiAgICogQWxzbyBzZXRzIHRoZSByZXNwb25zZVhYWCBmaWVsZHMgb24gdGhlIGpxWEhSIGluc3RhbmNlXFxuICAgKi9cXG5cXG5cXG4gIGZ1bmN0aW9uIGFqYXhDb252ZXJ0KHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzKSB7XFxuICAgIHZhciBjb252MixcXG4gICAgICAgIGN1cnJlbnQsXFxuICAgICAgICBjb252LFxcbiAgICAgICAgdG1wLFxcbiAgICAgICAgcHJldixcXG4gICAgICAgIGNvbnZlcnRlcnMgPSB7fSxcXG4gICAgICAgIC8vIFdvcmsgd2l0aCBhIGNvcHkgb2YgZGF0YVR5cGVzIGluIGNhc2Ugd2UgbmVlZCB0byBtb2RpZnkgaXQgZm9yIGNvbnZlcnNpb25cXG4gICAgZGF0YVR5cGVzID0gcy5kYXRhVHlwZXMuc2xpY2UoKTsgLy8gQ3JlYXRlIGNvbnZlcnRlcnMgbWFwIHdpdGggbG93ZXJjYXNlZCBrZXlzXFxuXFxuICAgIGlmIChkYXRhVHlwZXNbMV0pIHtcXG4gICAgICBmb3IgKGNvbnYgaW4gcy5jb252ZXJ0ZXJzKSB7XFxuICAgICAgICBjb252ZXJ0ZXJzW2NvbnYudG9Mb3dlckNhc2UoKV0gPSBzLmNvbnZlcnRlcnNbY29udl07XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTsgLy8gQ29udmVydCB0byBlYWNoIHNlcXVlbnRpYWwgZGF0YVR5cGVcXG5cXG4gICAgd2hpbGUgKGN1cnJlbnQpIHtcXG4gICAgICBpZiAocy5yZXNwb25zZUZpZWxkc1tjdXJyZW50XSkge1xcbiAgICAgICAganFYSFJbcy5yZXNwb25zZUZpZWxkc1tjdXJyZW50XV0gPSByZXNwb25zZTtcXG4gICAgICB9IC8vIEFwcGx5IHRoZSBkYXRhRmlsdGVyIGlmIHByb3ZpZGVkXFxuXFxuXFxuICAgICAgaWYgKCFwcmV2ICYmIGlzU3VjY2VzcyAmJiBzLmRhdGFGaWx0ZXIpIHtcXG4gICAgICAgIHJlc3BvbnNlID0gcy5kYXRhRmlsdGVyKHJlc3BvbnNlLCBzLmRhdGFUeXBlKTtcXG4gICAgICB9XFxuXFxuICAgICAgcHJldiA9IGN1cnJlbnQ7XFxuICAgICAgY3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xcblxcbiAgICAgIGlmIChjdXJyZW50KSB7XFxuICAgICAgICAvLyBUaGVyZSdzIG9ubHkgd29yayB0byBkbyBpZiBjdXJyZW50IGRhdGFUeXBlIGlzIG5vbi1hdXRvXFxuICAgICAgICBpZiAoY3VycmVudCA9PT0gXFxcIipcXFwiKSB7XFxuICAgICAgICAgIGN1cnJlbnQgPSBwcmV2OyAvLyBDb252ZXJ0IHJlc3BvbnNlIGlmIHByZXYgZGF0YVR5cGUgaXMgbm9uLWF1dG8gYW5kIGRpZmZlcnMgZnJvbSBjdXJyZW50XFxuICAgICAgICB9IGVsc2UgaWYgKHByZXYgIT09IFxcXCIqXFxcIiAmJiBwcmV2ICE9PSBjdXJyZW50KSB7XFxuICAgICAgICAgIC8vIFNlZWsgYSBkaXJlY3QgY29udmVydGVyXFxuICAgICAgICAgIGNvbnYgPSBjb252ZXJ0ZXJzW3ByZXYgKyBcXFwiIFxcXCIgKyBjdXJyZW50XSB8fCBjb252ZXJ0ZXJzW1xcXCIqIFxcXCIgKyBjdXJyZW50XTsgLy8gSWYgbm9uZSBmb3VuZCwgc2VlayBhIHBhaXJcXG5cXG4gICAgICAgICAgaWYgKCFjb252KSB7XFxuICAgICAgICAgICAgZm9yIChjb252MiBpbiBjb252ZXJ0ZXJzKSB7XFxuICAgICAgICAgICAgICAvLyBJZiBjb252MiBvdXRwdXRzIGN1cnJlbnRcXG4gICAgICAgICAgICAgIHRtcCA9IGNvbnYyLnNwbGl0KFxcXCIgXFxcIik7XFxuXFxuICAgICAgICAgICAgICBpZiAodG1wWzFdID09PSBjdXJyZW50KSB7XFxuICAgICAgICAgICAgICAgIC8vIElmIHByZXYgY2FuIGJlIGNvbnZlcnRlZCB0byBhY2NlcHRlZCBpbnB1dFxcbiAgICAgICAgICAgICAgICBjb252ID0gY29udmVydGVyc1twcmV2ICsgXFxcIiBcXFwiICsgdG1wWzBdXSB8fCBjb252ZXJ0ZXJzW1xcXCIqIFxcXCIgKyB0bXBbMF1dO1xcblxcbiAgICAgICAgICAgICAgICBpZiAoY29udikge1xcbiAgICAgICAgICAgICAgICAgIC8vIENvbmRlbnNlIGVxdWl2YWxlbmNlIGNvbnZlcnRlcnNcXG4gICAgICAgICAgICAgICAgICBpZiAoY29udiA9PT0gdHJ1ZSkge1xcbiAgICAgICAgICAgICAgICAgICAgY29udiA9IGNvbnZlcnRlcnNbY29udjJdOyAvLyBPdGhlcndpc2UsIGluc2VydCB0aGUgaW50ZXJtZWRpYXRlIGRhdGFUeXBlXFxuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb252ZXJ0ZXJzW2NvbnYyXSAhPT0gdHJ1ZSkge1xcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IHRtcFswXTtcXG4gICAgICAgICAgICAgICAgICAgIGRhdGFUeXBlcy51bnNoaWZ0KHRtcFsxXSk7XFxuICAgICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9IC8vIEFwcGx5IGNvbnZlcnRlciAoaWYgbm90IGFuIGVxdWl2YWxlbmNlKVxcblxcblxcbiAgICAgICAgICBpZiAoY29udiAhPT0gdHJ1ZSkge1xcbiAgICAgICAgICAgIC8vIFVubGVzcyBlcnJvcnMgYXJlIGFsbG93ZWQgdG8gYnViYmxlLCBjYXRjaCBhbmQgcmV0dXJuIHRoZW1cXG4gICAgICAgICAgICBpZiAoY29udiAmJiBzW1xcXCJ0aHJvd3NcXFwiXSkge1xcbiAgICAgICAgICAgICAgcmVzcG9uc2UgPSBjb252KHJlc3BvbnNlKTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBjb252KHJlc3BvbnNlKTtcXG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgICBzdGF0ZTogXFxcInBhcnNlcmVycm9yXFxcIixcXG4gICAgICAgICAgICAgICAgICBlcnJvcjogY29udiA/IGUgOiBcXFwiTm8gY29udmVyc2lvbiBmcm9tIFxcXCIgKyBwcmV2ICsgXFxcIiB0byBcXFwiICsgY3VycmVudFxcbiAgICAgICAgICAgICAgICB9O1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICByZXR1cm4ge1xcbiAgICAgIHN0YXRlOiBcXFwic3VjY2Vzc1xcXCIsXFxuICAgICAgZGF0YTogcmVzcG9uc2VcXG4gICAgfTtcXG4gIH1cXG5cXG4gIGpRdWVyeS5leHRlbmQoe1xcbiAgICAvLyBDb3VudGVyIGZvciBob2xkaW5nIHRoZSBudW1iZXIgb2YgYWN0aXZlIHF1ZXJpZXNcXG4gICAgYWN0aXZlOiAwLFxcbiAgICAvLyBMYXN0LU1vZGlmaWVkIGhlYWRlciBjYWNoZSBmb3IgbmV4dCByZXF1ZXN0XFxuICAgIGxhc3RNb2RpZmllZDoge30sXFxuICAgIGV0YWc6IHt9LFxcbiAgICBhamF4U2V0dGluZ3M6IHtcXG4gICAgICB1cmw6IGFqYXhMb2NhdGlvbixcXG4gICAgICB0eXBlOiBcXFwiR0VUXFxcIixcXG4gICAgICBpc0xvY2FsOiBybG9jYWxQcm90b2NvbC50ZXN0KGFqYXhMb2NQYXJ0c1sxXSksXFxuICAgICAgZ2xvYmFsOiB0cnVlLFxcbiAgICAgIHByb2Nlc3NEYXRhOiB0cnVlLFxcbiAgICAgIGFzeW5jOiB0cnVlLFxcbiAgICAgIGNvbnRlbnRUeXBlOiBcXFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04XFxcIixcXG5cXG4gICAgICAvKlxcbiAgICAgIHRpbWVvdXQ6IDAsXFxuICAgICAgZGF0YTogbnVsbCxcXG4gICAgICBkYXRhVHlwZTogbnVsbCxcXG4gICAgICB1c2VybmFtZTogbnVsbCxcXG4gICAgICBwYXNzd29yZDogbnVsbCxcXG4gICAgICBjYWNoZTogbnVsbCxcXG4gICAgICB0aHJvd3M6IGZhbHNlLFxcbiAgICAgIHRyYWRpdGlvbmFsOiBmYWxzZSxcXG4gICAgICBoZWFkZXJzOiB7fSxcXG4gICAgICAqL1xcbiAgICAgIGFjY2VwdHM6IHtcXG4gICAgICAgIFxcXCIqXFxcIjogYWxsVHlwZXMsXFxuICAgICAgICB0ZXh0OiBcXFwidGV4dC9wbGFpblxcXCIsXFxuICAgICAgICBodG1sOiBcXFwidGV4dC9odG1sXFxcIixcXG4gICAgICAgIHhtbDogXFxcImFwcGxpY2F0aW9uL3htbCwgdGV4dC94bWxcXFwiLFxcbiAgICAgICAganNvbjogXFxcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvamF2YXNjcmlwdFxcXCJcXG4gICAgICB9LFxcbiAgICAgIGNvbnRlbnRzOiB7XFxuICAgICAgICB4bWw6IC94bWwvLFxcbiAgICAgICAgaHRtbDogL2h0bWwvLFxcbiAgICAgICAganNvbjogL2pzb24vXFxuICAgICAgfSxcXG4gICAgICByZXNwb25zZUZpZWxkczoge1xcbiAgICAgICAgeG1sOiBcXFwicmVzcG9uc2VYTUxcXFwiLFxcbiAgICAgICAgdGV4dDogXFxcInJlc3BvbnNlVGV4dFxcXCIsXFxuICAgICAgICBqc29uOiBcXFwicmVzcG9uc2VKU09OXFxcIlxcbiAgICAgIH0sXFxuICAgICAgLy8gRGF0YSBjb252ZXJ0ZXJzXFxuICAgICAgLy8gS2V5cyBzZXBhcmF0ZSBzb3VyY2UgKG9yIGNhdGNoYWxsIFxcXCIqXFxcIikgYW5kIGRlc3RpbmF0aW9uIHR5cGVzIHdpdGggYSBzaW5nbGUgc3BhY2VcXG4gICAgICBjb252ZXJ0ZXJzOiB7XFxuICAgICAgICAvLyBDb252ZXJ0IGFueXRoaW5nIHRvIHRleHRcXG4gICAgICAgIFxcXCIqIHRleHRcXFwiOiBTdHJpbmcsXFxuICAgICAgICAvLyBUZXh0IHRvIGh0bWwgKHRydWUgPSBubyB0cmFuc2Zvcm1hdGlvbilcXG4gICAgICAgIFxcXCJ0ZXh0IGh0bWxcXFwiOiB0cnVlLFxcbiAgICAgICAgLy8gRXZhbHVhdGUgdGV4dCBhcyBhIGpzb24gZXhwcmVzc2lvblxcbiAgICAgICAgXFxcInRleHQganNvblxcXCI6IGpRdWVyeS5wYXJzZUpTT04sXFxuICAgICAgICAvLyBQYXJzZSB0ZXh0IGFzIHhtbFxcbiAgICAgICAgXFxcInRleHQgeG1sXFxcIjogalF1ZXJ5LnBhcnNlWE1MXFxuICAgICAgfSxcXG4gICAgICAvLyBGb3Igb3B0aW9ucyB0aGF0IHNob3VsZG4ndCBiZSBkZWVwIGV4dGVuZGVkOlxcbiAgICAgIC8vIHlvdSBjYW4gYWRkIHlvdXIgb3duIGN1c3RvbSBvcHRpb25zIGhlcmUgaWZcXG4gICAgICAvLyBhbmQgd2hlbiB5b3UgY3JlYXRlIG9uZSB0aGF0IHNob3VsZG4ndCBiZVxcbiAgICAgIC8vIGRlZXAgZXh0ZW5kZWQgKHNlZSBhamF4RXh0ZW5kKVxcbiAgICAgIGZsYXRPcHRpb25zOiB7XFxuICAgICAgICB1cmw6IHRydWUsXFxuICAgICAgICBjb250ZXh0OiB0cnVlXFxuICAgICAgfVxcbiAgICB9LFxcbiAgICAvLyBDcmVhdGVzIGEgZnVsbCBmbGVkZ2VkIHNldHRpbmdzIG9iamVjdCBpbnRvIHRhcmdldFxcbiAgICAvLyB3aXRoIGJvdGggYWpheFNldHRpbmdzIGFuZCBzZXR0aW5ncyBmaWVsZHMuXFxuICAgIC8vIElmIHRhcmdldCBpcyBvbWl0dGVkLCB3cml0ZXMgaW50byBhamF4U2V0dGluZ3MuXFxuICAgIGFqYXhTZXR1cDogZnVuY3Rpb24gYWpheFNldHVwKHRhcmdldCwgc2V0dGluZ3MpIHtcXG4gICAgICByZXR1cm4gc2V0dGluZ3MgPyAvLyBCdWlsZGluZyBhIHNldHRpbmdzIG9iamVjdFxcbiAgICAgIGFqYXhFeHRlbmQoYWpheEV4dGVuZCh0YXJnZXQsIGpRdWVyeS5hamF4U2V0dGluZ3MpLCBzZXR0aW5ncykgOiAvLyBFeHRlbmRpbmcgYWpheFNldHRpbmdzXFxuICAgICAgYWpheEV4dGVuZChqUXVlcnkuYWpheFNldHRpbmdzLCB0YXJnZXQpO1xcbiAgICB9LFxcbiAgICBhamF4UHJlZmlsdGVyOiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMocHJlZmlsdGVycyksXFxuICAgIGFqYXhUcmFuc3BvcnQ6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyh0cmFuc3BvcnRzKSxcXG4gICAgLy8gTWFpbiBtZXRob2RcXG4gICAgYWpheDogZnVuY3Rpb24gYWpheCh1cmwsIG9wdGlvbnMpIHtcXG4gICAgICAvLyBJZiB1cmwgaXMgYW4gb2JqZWN0LCBzaW11bGF0ZSBwcmUtMS41IHNpZ25hdHVyZVxcbiAgICAgIGlmIChfdHlwZW9mKHVybCkgPT09IFxcXCJvYmplY3RcXFwiKSB7XFxuICAgICAgICBvcHRpb25zID0gdXJsO1xcbiAgICAgICAgdXJsID0gdW5kZWZpbmVkO1xcbiAgICAgIH0gLy8gRm9yY2Ugb3B0aW9ucyB0byBiZSBhbiBvYmplY3RcXG5cXG5cXG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcXG5cXG4gICAgICB2YXIgdHJhbnNwb3J0LFxcbiAgICAgICAgICAvLyBVUkwgd2l0aG91dCBhbnRpLWNhY2hlIHBhcmFtXFxuICAgICAgY2FjaGVVUkwsXFxuICAgICAgICAgIC8vIFJlc3BvbnNlIGhlYWRlcnNcXG4gICAgICByZXNwb25zZUhlYWRlcnNTdHJpbmcsXFxuICAgICAgICAgIHJlc3BvbnNlSGVhZGVycyxcXG4gICAgICAgICAgLy8gdGltZW91dCBoYW5kbGVcXG4gICAgICB0aW1lb3V0VGltZXIsXFxuICAgICAgICAgIC8vIENyb3NzLWRvbWFpbiBkZXRlY3Rpb24gdmFyc1xcbiAgICAgIHBhcnRzLFxcbiAgICAgICAgICAvLyBUbyBrbm93IGlmIGdsb2JhbCBldmVudHMgYXJlIHRvIGJlIGRpc3BhdGNoZWRcXG4gICAgICBmaXJlR2xvYmFscyxcXG4gICAgICAgICAgLy8gTG9vcCB2YXJpYWJsZVxcbiAgICAgIGksXFxuICAgICAgICAgIC8vIENyZWF0ZSB0aGUgZmluYWwgb3B0aW9ucyBvYmplY3RcXG4gICAgICBzID0galF1ZXJ5LmFqYXhTZXR1cCh7fSwgb3B0aW9ucyksXFxuICAgICAgICAgIC8vIENhbGxiYWNrcyBjb250ZXh0XFxuICAgICAgY2FsbGJhY2tDb250ZXh0ID0gcy5jb250ZXh0IHx8IHMsXFxuICAgICAgICAgIC8vIENvbnRleHQgZm9yIGdsb2JhbCBldmVudHMgaXMgY2FsbGJhY2tDb250ZXh0IGlmIGl0IGlzIGEgRE9NIG5vZGUgb3IgalF1ZXJ5IGNvbGxlY3Rpb25cXG4gICAgICBnbG9iYWxFdmVudENvbnRleHQgPSBzLmNvbnRleHQgJiYgKGNhbGxiYWNrQ29udGV4dC5ub2RlVHlwZSB8fCBjYWxsYmFja0NvbnRleHQuanF1ZXJ5KSA/IGpRdWVyeShjYWxsYmFja0NvbnRleHQpIDogalF1ZXJ5LmV2ZW50LFxcbiAgICAgICAgICAvLyBEZWZlcnJlZHNcXG4gICAgICBkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLFxcbiAgICAgICAgICBjb21wbGV0ZURlZmVycmVkID0galF1ZXJ5LkNhbGxiYWNrcyhcXFwib25jZSBtZW1vcnlcXFwiKSxcXG4gICAgICAgICAgLy8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3NcXG4gICAgICBfc3RhdHVzQ29kZSA9IHMuc3RhdHVzQ29kZSB8fCB7fSxcXG4gICAgICAgICAgLy8gSGVhZGVycyAodGhleSBhcmUgc2VudCBhbGwgYXQgb25jZSlcXG4gICAgICByZXF1ZXN0SGVhZGVycyA9IHt9LFxcbiAgICAgICAgICByZXF1ZXN0SGVhZGVyc05hbWVzID0ge30sXFxuICAgICAgICAgIC8vIFRoZSBqcVhIUiBzdGF0ZVxcbiAgICAgIHN0YXRlID0gMCxcXG4gICAgICAgICAgLy8gRGVmYXVsdCBhYm9ydCBtZXNzYWdlXFxuICAgICAgc3RyQWJvcnQgPSBcXFwiY2FuY2VsZWRcXFwiLFxcbiAgICAgICAgICAvLyBGYWtlIHhoclxcbiAgICAgIGpxWEhSID0ge1xcbiAgICAgICAgcmVhZHlTdGF0ZTogMCxcXG4gICAgICAgIC8vIEJ1aWxkcyBoZWFkZXJzIGhhc2h0YWJsZSBpZiBuZWVkZWRcXG4gICAgICAgIGdldFJlc3BvbnNlSGVhZGVyOiBmdW5jdGlvbiBnZXRSZXNwb25zZUhlYWRlcihrZXkpIHtcXG4gICAgICAgICAgdmFyIG1hdGNoO1xcblxcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IDIpIHtcXG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlSGVhZGVycykge1xcbiAgICAgICAgICAgICAgcmVzcG9uc2VIZWFkZXJzID0ge307XFxuXFxuICAgICAgICAgICAgICB3aGlsZSAobWF0Y2ggPSByaGVhZGVycy5leGVjKHJlc3BvbnNlSGVhZGVyc1N0cmluZykpIHtcXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VIZWFkZXJzW21hdGNoWzFdLnRvTG93ZXJDYXNlKCldID0gbWF0Y2hbMl07XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIG1hdGNoID0gcmVzcG9uc2VIZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICByZXR1cm4gbWF0Y2ggPT0gbnVsbCA/IG51bGwgOiBtYXRjaDtcXG4gICAgICAgIH0sXFxuICAgICAgICAvLyBSYXcgc3RyaW5nXFxuICAgICAgICBnZXRBbGxSZXNwb25zZUhlYWRlcnM6IGZ1bmN0aW9uIGdldEFsbFJlc3BvbnNlSGVhZGVycygpIHtcXG4gICAgICAgICAgcmV0dXJuIHN0YXRlID09PSAyID8gcmVzcG9uc2VIZWFkZXJzU3RyaW5nIDogbnVsbDtcXG4gICAgICAgIH0sXFxuICAgICAgICAvLyBDYWNoZXMgdGhlIGhlYWRlclxcbiAgICAgICAgc2V0UmVxdWVzdEhlYWRlcjogZnVuY3Rpb24gc2V0UmVxdWVzdEhlYWRlcihuYW1lLCB2YWx1ZSkge1xcbiAgICAgICAgICB2YXIgbG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XFxuXFxuICAgICAgICAgIGlmICghc3RhdGUpIHtcXG4gICAgICAgICAgICBuYW1lID0gcmVxdWVzdEhlYWRlcnNOYW1lc1tsbmFtZV0gPSByZXF1ZXN0SGVhZGVyc05hbWVzW2xuYW1lXSB8fCBuYW1lO1xcbiAgICAgICAgICAgIHJlcXVlc3RIZWFkZXJzW25hbWVdID0gdmFsdWU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XFxuICAgICAgICB9LFxcbiAgICAgICAgLy8gT3ZlcnJpZGVzIHJlc3BvbnNlIGNvbnRlbnQtdHlwZSBoZWFkZXJcXG4gICAgICAgIG92ZXJyaWRlTWltZVR5cGU6IGZ1bmN0aW9uIG92ZXJyaWRlTWltZVR5cGUodHlwZSkge1xcbiAgICAgICAgICBpZiAoIXN0YXRlKSB7XFxuICAgICAgICAgICAgcy5taW1lVHlwZSA9IHR5cGU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XFxuICAgICAgICB9LFxcbiAgICAgICAgLy8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3NcXG4gICAgICAgIHN0YXR1c0NvZGU6IGZ1bmN0aW9uIHN0YXR1c0NvZGUobWFwKSB7XFxuICAgICAgICAgIHZhciBjb2RlO1xcblxcbiAgICAgICAgICBpZiAobWFwKSB7XFxuICAgICAgICAgICAgaWYgKHN0YXRlIDwgMikge1xcbiAgICAgICAgICAgICAgZm9yIChjb2RlIGluIG1hcCkge1xcbiAgICAgICAgICAgICAgICAvLyBMYXp5LWFkZCB0aGUgbmV3IGNhbGxiYWNrIGluIGEgd2F5IHRoYXQgcHJlc2VydmVzIG9sZCBvbmVzXFxuICAgICAgICAgICAgICAgIF9zdGF0dXNDb2RlW2NvZGVdID0gW19zdGF0dXNDb2RlW2NvZGVdLCBtYXBbY29kZV1dO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAvLyBFeGVjdXRlIHRoZSBhcHByb3ByaWF0ZSBjYWxsYmFja3NcXG4gICAgICAgICAgICAgIGpxWEhSLmFsd2F5cyhtYXBbanFYSFIuc3RhdHVzXSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHJldHVybiB0aGlzO1xcbiAgICAgICAgfSxcXG4gICAgICAgIC8vIENhbmNlbCB0aGUgcmVxdWVzdFxcbiAgICAgICAgYWJvcnQ6IGZ1bmN0aW9uIGFib3J0KHN0YXR1c1RleHQpIHtcXG4gICAgICAgICAgdmFyIGZpbmFsVGV4dCA9IHN0YXR1c1RleHQgfHwgc3RyQWJvcnQ7XFxuXFxuICAgICAgICAgIGlmICh0cmFuc3BvcnQpIHtcXG4gICAgICAgICAgICB0cmFuc3BvcnQuYWJvcnQoZmluYWxUZXh0KTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBkb25lKDAsIGZpbmFsVGV4dCk7XFxuICAgICAgICAgIHJldHVybiB0aGlzO1xcbiAgICAgICAgfVxcbiAgICAgIH07IC8vIEF0dGFjaCBkZWZlcnJlZHNcXG5cXG5cXG4gICAgICBkZWZlcnJlZC5wcm9taXNlKGpxWEhSKS5jb21wbGV0ZSA9IGNvbXBsZXRlRGVmZXJyZWQuYWRkO1xcbiAgICAgIGpxWEhSLnN1Y2Nlc3MgPSBqcVhIUi5kb25lO1xcbiAgICAgIGpxWEhSLmVycm9yID0ganFYSFIuZmFpbDsgLy8gUmVtb3ZlIGhhc2ggY2hhcmFjdGVyICgjNzUzMTogYW5kIHN0cmluZyBwcm9tb3Rpb24pXFxuICAgICAgLy8gQWRkIHByb3RvY29sIGlmIG5vdCBwcm92aWRlZCAocHJlZmlsdGVycyBtaWdodCBleHBlY3QgaXQpXFxuICAgICAgLy8gSGFuZGxlIGZhbHN5IHVybCBpbiB0aGUgc2V0dGluZ3Mgb2JqZWN0ICgjMTAwOTM6IGNvbnNpc3RlbmN5IHdpdGggb2xkIHNpZ25hdHVyZSlcXG4gICAgICAvLyBXZSBhbHNvIHVzZSB0aGUgdXJsIHBhcmFtZXRlciBpZiBhdmFpbGFibGVcXG5cXG4gICAgICBzLnVybCA9ICgodXJsIHx8IHMudXJsIHx8IGFqYXhMb2NhdGlvbikgKyBcXFwiXFxcIikucmVwbGFjZShyaGFzaCwgXFxcIlxcXCIpLnJlcGxhY2UocnByb3RvY29sLCBhamF4TG9jUGFydHNbMV0gKyBcXFwiLy9cXFwiKTsgLy8gQWxpYXMgbWV0aG9kIG9wdGlvbiB0byB0eXBlIGFzIHBlciB0aWNrZXQgIzEyMDA0XFxuXFxuICAgICAgcy50eXBlID0gb3B0aW9ucy5tZXRob2QgfHwgb3B0aW9ucy50eXBlIHx8IHMubWV0aG9kIHx8IHMudHlwZTsgLy8gRXh0cmFjdCBkYXRhVHlwZXMgbGlzdFxcblxcbiAgICAgIHMuZGF0YVR5cGVzID0galF1ZXJ5LnRyaW0ocy5kYXRhVHlwZSB8fCBcXFwiKlxcXCIpLnRvTG93ZXJDYXNlKCkubWF0Y2gocm5vdHdoaXRlKSB8fCBbXFxcIlxcXCJdOyAvLyBBIGNyb3NzLWRvbWFpbiByZXF1ZXN0IGlzIGluIG9yZGVyIHdoZW4gd2UgaGF2ZSBhIHByb3RvY29sOmhvc3Q6cG9ydCBtaXNtYXRjaFxcblxcbiAgICAgIGlmIChzLmNyb3NzRG9tYWluID09IG51bGwpIHtcXG4gICAgICAgIHBhcnRzID0gcnVybC5leGVjKHMudXJsLnRvTG93ZXJDYXNlKCkpO1xcbiAgICAgICAgcy5jcm9zc0RvbWFpbiA9ICEhKHBhcnRzICYmIChwYXJ0c1sxXSAhPT0gYWpheExvY1BhcnRzWzFdIHx8IHBhcnRzWzJdICE9PSBhamF4TG9jUGFydHNbMl0gfHwgKHBhcnRzWzNdIHx8IChwYXJ0c1sxXSA9PT0gXFxcImh0dHA6XFxcIiA/IFxcXCI4MFxcXCIgOiBcXFwiNDQzXFxcIikpICE9PSAoYWpheExvY1BhcnRzWzNdIHx8IChhamF4TG9jUGFydHNbMV0gPT09IFxcXCJodHRwOlxcXCIgPyBcXFwiODBcXFwiIDogXFxcIjQ0M1xcXCIpKSkpO1xcbiAgICAgIH0gLy8gQ29udmVydCBkYXRhIGlmIG5vdCBhbHJlYWR5IGEgc3RyaW5nXFxuXFxuXFxuICAgICAgaWYgKHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmIHR5cGVvZiBzLmRhdGEgIT09IFxcXCJzdHJpbmdcXFwiKSB7XFxuICAgICAgICBzLmRhdGEgPSBqUXVlcnkucGFyYW0ocy5kYXRhLCBzLnRyYWRpdGlvbmFsKTtcXG4gICAgICB9IC8vIEFwcGx5IHByZWZpbHRlcnNcXG5cXG5cXG4gICAgICBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyhwcmVmaWx0ZXJzLCBzLCBvcHRpb25zLCBqcVhIUik7IC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGEgcHJlZmlsdGVyLCBzdG9wIHRoZXJlXFxuXFxuICAgICAgaWYgKHN0YXRlID09PSAyKSB7XFxuICAgICAgICByZXR1cm4ganFYSFI7XFxuICAgICAgfSAvLyBXZSBjYW4gZmlyZSBnbG9iYWwgZXZlbnRzIGFzIG9mIG5vdyBpZiBhc2tlZCB0b1xcbiAgICAgIC8vIERvbid0IGZpcmUgZXZlbnRzIGlmIGpRdWVyeS5ldmVudCBpcyB1bmRlZmluZWQgaW4gYW4gQU1ELXVzYWdlIHNjZW5hcmlvICgjMTUxMTgpXFxuXFxuXFxuICAgICAgZmlyZUdsb2JhbHMgPSBqUXVlcnkuZXZlbnQgJiYgcy5nbG9iYWw7IC8vIFdhdGNoIGZvciBhIG5ldyBzZXQgb2YgcmVxdWVzdHNcXG5cXG4gICAgICBpZiAoZmlyZUdsb2JhbHMgJiYgalF1ZXJ5LmFjdGl2ZSsrID09PSAwKSB7XFxuICAgICAgICBqUXVlcnkuZXZlbnQudHJpZ2dlcihcXFwiYWpheFN0YXJ0XFxcIik7XFxuICAgICAgfSAvLyBVcHBlcmNhc2UgdGhlIHR5cGVcXG5cXG5cXG4gICAgICBzLnR5cGUgPSBzLnR5cGUudG9VcHBlckNhc2UoKTsgLy8gRGV0ZXJtaW5lIGlmIHJlcXVlc3QgaGFzIGNvbnRlbnRcXG5cXG4gICAgICBzLmhhc0NvbnRlbnQgPSAhcm5vQ29udGVudC50ZXN0KHMudHlwZSk7IC8vIFNhdmUgdGhlIFVSTCBpbiBjYXNlIHdlJ3JlIHRveWluZyB3aXRoIHRoZSBJZi1Nb2RpZmllZC1TaW5jZVxcbiAgICAgIC8vIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciBsYXRlciBvblxcblxcbiAgICAgIGNhY2hlVVJMID0gcy51cmw7IC8vIE1vcmUgb3B0aW9ucyBoYW5kbGluZyBmb3IgcmVxdWVzdHMgd2l0aCBubyBjb250ZW50XFxuXFxuICAgICAgaWYgKCFzLmhhc0NvbnRlbnQpIHtcXG4gICAgICAgIC8vIElmIGRhdGEgaXMgYXZhaWxhYmxlLCBhcHBlbmQgZGF0YSB0byB1cmxcXG4gICAgICAgIGlmIChzLmRhdGEpIHtcXG4gICAgICAgICAgY2FjaGVVUkwgPSBzLnVybCArPSAocnF1ZXJ5LnRlc3QoY2FjaGVVUkwpID8gXFxcIiZcXFwiIDogXFxcIj9cXFwiKSArIHMuZGF0YTsgLy8gIzk2ODI6IHJlbW92ZSBkYXRhIHNvIHRoYXQgaXQncyBub3QgdXNlZCBpbiBhbiBldmVudHVhbCByZXRyeVxcblxcbiAgICAgICAgICBkZWxldGUgcy5kYXRhO1xcbiAgICAgICAgfSAvLyBBZGQgYW50aS1jYWNoZSBpbiB1cmwgaWYgbmVlZGVkXFxuXFxuXFxuICAgICAgICBpZiAocy5jYWNoZSA9PT0gZmFsc2UpIHtcXG4gICAgICAgICAgcy51cmwgPSBydHMudGVzdChjYWNoZVVSTCkgPyAvLyBJZiB0aGVyZSBpcyBhbHJlYWR5IGEgJ18nIHBhcmFtZXRlciwgc2V0IGl0cyB2YWx1ZVxcbiAgICAgICAgICBjYWNoZVVSTC5yZXBsYWNlKHJ0cywgXFxcIiQxXz1cXFwiICsgbm9uY2UrKykgOiAvLyBPdGhlcndpc2UgYWRkIG9uZSB0byB0aGUgZW5kXFxuICAgICAgICAgIGNhY2hlVVJMICsgKHJxdWVyeS50ZXN0KGNhY2hlVVJMKSA/IFxcXCImXFxcIiA6IFxcXCI/XFxcIikgKyBcXFwiXz1cXFwiICsgbm9uY2UrKztcXG4gICAgICAgIH1cXG4gICAgICB9IC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXFxuXFxuXFxuICAgICAgaWYgKHMuaWZNb2RpZmllZCkge1xcbiAgICAgICAgaWYgKGpRdWVyeS5sYXN0TW9kaWZpZWRbY2FjaGVVUkxdKSB7XFxuICAgICAgICAgIGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoXFxcIklmLU1vZGlmaWVkLVNpbmNlXFxcIiwgalF1ZXJ5Lmxhc3RNb2RpZmllZFtjYWNoZVVSTF0pO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKGpRdWVyeS5ldGFnW2NhY2hlVVJMXSkge1xcbiAgICAgICAgICBqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKFxcXCJJZi1Ob25lLU1hdGNoXFxcIiwgalF1ZXJ5LmV0YWdbY2FjaGVVUkxdKTtcXG4gICAgICAgIH1cXG4gICAgICB9IC8vIFNldCB0aGUgY29ycmVjdCBoZWFkZXIsIGlmIGRhdGEgaXMgYmVpbmcgc2VudFxcblxcblxcbiAgICAgIGlmIChzLmRhdGEgJiYgcy5oYXNDb250ZW50ICYmIHMuY29udGVudFR5cGUgIT09IGZhbHNlIHx8IG9wdGlvbnMuY29udGVudFR5cGUpIHtcXG4gICAgICAgIGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoXFxcIkNvbnRlbnQtVHlwZVxcXCIsIHMuY29udGVudFR5cGUpO1xcbiAgICAgIH0gLy8gU2V0IHRoZSBBY2NlcHRzIGhlYWRlciBmb3IgdGhlIHNlcnZlciwgZGVwZW5kaW5nIG9uIHRoZSBkYXRhVHlwZVxcblxcblxcbiAgICAgIGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoXFxcIkFjY2VwdFxcXCIsIHMuZGF0YVR5cGVzWzBdICYmIHMuYWNjZXB0c1tzLmRhdGFUeXBlc1swXV0gPyBzLmFjY2VwdHNbcy5kYXRhVHlwZXNbMF1dICsgKHMuZGF0YVR5cGVzWzBdICE9PSBcXFwiKlxcXCIgPyBcXFwiLCBcXFwiICsgYWxsVHlwZXMgKyBcXFwiOyBxPTAuMDFcXFwiIDogXFxcIlxcXCIpIDogcy5hY2NlcHRzW1xcXCIqXFxcIl0pOyAvLyBDaGVjayBmb3IgaGVhZGVycyBvcHRpb25cXG5cXG4gICAgICBmb3IgKGkgaW4gcy5oZWFkZXJzKSB7XFxuICAgICAgICBqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKGksIHMuaGVhZGVyc1tpXSk7XFxuICAgICAgfSAvLyBBbGxvdyBjdXN0b20gaGVhZGVycy9taW1ldHlwZXMgYW5kIGVhcmx5IGFib3J0XFxuXFxuXFxuICAgICAgaWYgKHMuYmVmb3JlU2VuZCAmJiAocy5iZWZvcmVTZW5kLmNhbGwoY2FsbGJhY2tDb250ZXh0LCBqcVhIUiwgcykgPT09IGZhbHNlIHx8IHN0YXRlID09PSAyKSkge1xcbiAgICAgICAgLy8gQWJvcnQgaWYgbm90IGRvbmUgYWxyZWFkeSBhbmQgcmV0dXJuXFxuICAgICAgICByZXR1cm4ganFYSFIuYWJvcnQoKTtcXG4gICAgICB9IC8vIEFib3J0aW5nIGlzIG5vIGxvbmdlciBhIGNhbmNlbGxhdGlvblxcblxcblxcbiAgICAgIHN0ckFib3J0ID0gXFxcImFib3J0XFxcIjsgLy8gSW5zdGFsbCBjYWxsYmFja3Mgb24gZGVmZXJyZWRzXFxuXFxuICAgICAgZm9yIChpIGluIHtcXG4gICAgICAgIHN1Y2Nlc3M6IDEsXFxuICAgICAgICBlcnJvcjogMSxcXG4gICAgICAgIGNvbXBsZXRlOiAxXFxuICAgICAgfSkge1xcbiAgICAgICAganFYSFJbaV0oc1tpXSk7XFxuICAgICAgfSAvLyBHZXQgdHJhbnNwb3J0XFxuXFxuXFxuICAgICAgdHJhbnNwb3J0ID0gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHModHJhbnNwb3J0cywgcywgb3B0aW9ucywganFYSFIpOyAvLyBJZiBubyB0cmFuc3BvcnQsIHdlIGF1dG8tYWJvcnRcXG5cXG4gICAgICBpZiAoIXRyYW5zcG9ydCkge1xcbiAgICAgICAgZG9uZSgtMSwgXFxcIk5vIFRyYW5zcG9ydFxcXCIpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBqcVhIUi5yZWFkeVN0YXRlID0gMTsgLy8gU2VuZCBnbG9iYWwgZXZlbnRcXG5cXG4gICAgICAgIGlmIChmaXJlR2xvYmFscykge1xcbiAgICAgICAgICBnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlcihcXFwiYWpheFNlbmRcXFwiLCBbanFYSFIsIHNdKTtcXG4gICAgICAgIH0gLy8gVGltZW91dFxcblxcblxcbiAgICAgICAgaWYgKHMuYXN5bmMgJiYgcy50aW1lb3V0ID4gMCkge1xcbiAgICAgICAgICB0aW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBqcVhIUi5hYm9ydChcXFwidGltZW91dFxcXCIpO1xcbiAgICAgICAgICB9LCBzLnRpbWVvdXQpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgc3RhdGUgPSAxO1xcbiAgICAgICAgICB0cmFuc3BvcnQuc2VuZChyZXF1ZXN0SGVhZGVycywgZG9uZSk7XFxuICAgICAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICAgIC8vIFByb3BhZ2F0ZSBleGNlcHRpb24gYXMgZXJyb3IgaWYgbm90IGRvbmVcXG4gICAgICAgICAgaWYgKHN0YXRlIDwgMikge1xcbiAgICAgICAgICAgIGRvbmUoLTEsIGUpOyAvLyBTaW1wbHkgcmV0aHJvdyBvdGhlcndpc2VcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICB0aHJvdyBlO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfSAvLyBDYWxsYmFjayBmb3Igd2hlbiBldmVyeXRoaW5nIGlzIGRvbmVcXG5cXG5cXG4gICAgICBmdW5jdGlvbiBkb25lKHN0YXR1cywgbmF0aXZlU3RhdHVzVGV4dCwgcmVzcG9uc2VzLCBoZWFkZXJzKSB7XFxuICAgICAgICB2YXIgaXNTdWNjZXNzLFxcbiAgICAgICAgICAgIHN1Y2Nlc3MsXFxuICAgICAgICAgICAgZXJyb3IsXFxuICAgICAgICAgICAgcmVzcG9uc2UsXFxuICAgICAgICAgICAgbW9kaWZpZWQsXFxuICAgICAgICAgICAgc3RhdHVzVGV4dCA9IG5hdGl2ZVN0YXR1c1RleHQ7IC8vIENhbGxlZCBvbmNlXFxuXFxuICAgICAgICBpZiAoc3RhdGUgPT09IDIpIHtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfSAvLyBTdGF0ZSBpcyBcXFwiZG9uZVxcXCIgbm93XFxuXFxuXFxuICAgICAgICBzdGF0ZSA9IDI7IC8vIENsZWFyIHRpbWVvdXQgaWYgaXQgZXhpc3RzXFxuXFxuICAgICAgICBpZiAodGltZW91dFRpbWVyKSB7XFxuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0VGltZXIpO1xcbiAgICAgICAgfSAvLyBEZXJlZmVyZW5jZSB0cmFuc3BvcnQgZm9yIGVhcmx5IGdhcmJhZ2UgY29sbGVjdGlvblxcbiAgICAgICAgLy8gKG5vIG1hdHRlciBob3cgbG9uZyB0aGUganFYSFIgb2JqZWN0IHdpbGwgYmUgdXNlZClcXG5cXG5cXG4gICAgICAgIHRyYW5zcG9ydCA9IHVuZGVmaW5lZDsgLy8gQ2FjaGUgcmVzcG9uc2UgaGVhZGVyc1xcblxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzU3RyaW5nID0gaGVhZGVycyB8fCBcXFwiXFxcIjsgLy8gU2V0IHJlYWR5U3RhdGVcXG5cXG4gICAgICAgIGpxWEhSLnJlYWR5U3RhdGUgPSBzdGF0dXMgPiAwID8gNCA6IDA7IC8vIERldGVybWluZSBpZiBzdWNjZXNzZnVsXFxuXFxuICAgICAgICBpc1N1Y2Nlc3MgPSBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCB8fCBzdGF0dXMgPT09IDMwNDsgLy8gR2V0IHJlc3BvbnNlIGRhdGFcXG5cXG4gICAgICAgIGlmIChyZXNwb25zZXMpIHtcXG4gICAgICAgICAgcmVzcG9uc2UgPSBhamF4SGFuZGxlUmVzcG9uc2VzKHMsIGpxWEhSLCByZXNwb25zZXMpO1xcbiAgICAgICAgfSAvLyBDb252ZXJ0IG5vIG1hdHRlciB3aGF0ICh0aGF0IHdheSByZXNwb25zZVhYWCBmaWVsZHMgYXJlIGFsd2F5cyBzZXQpXFxuXFxuXFxuICAgICAgICByZXNwb25zZSA9IGFqYXhDb252ZXJ0KHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzKTsgLy8gSWYgc3VjY2Vzc2Z1bCwgaGFuZGxlIHR5cGUgY2hhaW5pbmdcXG5cXG4gICAgICAgIGlmIChpc1N1Y2Nlc3MpIHtcXG4gICAgICAgICAgLy8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cXG4gICAgICAgICAgaWYgKHMuaWZNb2RpZmllZCkge1xcbiAgICAgICAgICAgIG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoXFxcIkxhc3QtTW9kaWZpZWRcXFwiKTtcXG5cXG4gICAgICAgICAgICBpZiAobW9kaWZpZWQpIHtcXG4gICAgICAgICAgICAgIGpRdWVyeS5sYXN0TW9kaWZpZWRbY2FjaGVVUkxdID0gbW9kaWZpZWQ7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoXFxcImV0YWdcXFwiKTtcXG5cXG4gICAgICAgICAgICBpZiAobW9kaWZpZWQpIHtcXG4gICAgICAgICAgICAgIGpRdWVyeS5ldGFnW2NhY2hlVVJMXSA9IG1vZGlmaWVkO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSAvLyBpZiBubyBjb250ZW50XFxuXFxuXFxuICAgICAgICAgIGlmIChzdGF0dXMgPT09IDIwNCB8fCBzLnR5cGUgPT09IFxcXCJIRUFEXFxcIikge1xcbiAgICAgICAgICAgIHN0YXR1c1RleHQgPSBcXFwibm9jb250ZW50XFxcIjsgLy8gaWYgbm90IG1vZGlmaWVkXFxuICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdHVzID09PSAzMDQpIHtcXG4gICAgICAgICAgICBzdGF0dXNUZXh0ID0gXFxcIm5vdG1vZGlmaWVkXFxcIjsgLy8gSWYgd2UgaGF2ZSBkYXRhLCBsZXQncyBjb252ZXJ0IGl0XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgc3RhdHVzVGV4dCA9IHJlc3BvbnNlLnN0YXRlO1xcbiAgICAgICAgICAgIHN1Y2Nlc3MgPSByZXNwb25zZS5kYXRhO1xcbiAgICAgICAgICAgIGVycm9yID0gcmVzcG9uc2UuZXJyb3I7XFxuICAgICAgICAgICAgaXNTdWNjZXNzID0gIWVycm9yO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAvLyBFeHRyYWN0IGVycm9yIGZyb20gc3RhdHVzVGV4dCBhbmQgbm9ybWFsaXplIGZvciBub24tYWJvcnRzXFxuICAgICAgICAgIGVycm9yID0gc3RhdHVzVGV4dDtcXG5cXG4gICAgICAgICAgaWYgKHN0YXR1cyB8fCAhc3RhdHVzVGV4dCkge1xcbiAgICAgICAgICAgIHN0YXR1c1RleHQgPSBcXFwiZXJyb3JcXFwiO1xcblxcbiAgICAgICAgICAgIGlmIChzdGF0dXMgPCAwKSB7XFxuICAgICAgICAgICAgICBzdGF0dXMgPSAwO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfSAvLyBTZXQgZGF0YSBmb3IgdGhlIGZha2UgeGhyIG9iamVjdFxcblxcblxcbiAgICAgICAganFYSFIuc3RhdHVzID0gc3RhdHVzO1xcbiAgICAgICAganFYSFIuc3RhdHVzVGV4dCA9IChuYXRpdmVTdGF0dXNUZXh0IHx8IHN0YXR1c1RleHQpICsgXFxcIlxcXCI7IC8vIFN1Y2Nlc3MvRXJyb3JcXG5cXG4gICAgICAgIGlmIChpc1N1Y2Nlc3MpIHtcXG4gICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZVdpdGgoY2FsbGJhY2tDb250ZXh0LCBbc3VjY2Vzcywgc3RhdHVzVGV4dCwganFYSFJdKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGRlZmVycmVkLnJlamVjdFdpdGgoY2FsbGJhY2tDb250ZXh0LCBbanFYSFIsIHN0YXR1c1RleHQsIGVycm9yXSk7XFxuICAgICAgICB9IC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXFxuXFxuXFxuICAgICAgICBqcVhIUi5zdGF0dXNDb2RlKF9zdGF0dXNDb2RlKTtcXG4gICAgICAgIF9zdGF0dXNDb2RlID0gdW5kZWZpbmVkO1xcblxcbiAgICAgICAgaWYgKGZpcmVHbG9iYWxzKSB7XFxuICAgICAgICAgIGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKGlzU3VjY2VzcyA/IFxcXCJhamF4U3VjY2Vzc1xcXCIgOiBcXFwiYWpheEVycm9yXFxcIiwgW2pxWEhSLCBzLCBpc1N1Y2Nlc3MgPyBzdWNjZXNzIDogZXJyb3JdKTtcXG4gICAgICAgIH0gLy8gQ29tcGxldGVcXG5cXG5cXG4gICAgICAgIGNvbXBsZXRlRGVmZXJyZWQuZmlyZVdpdGgoY2FsbGJhY2tDb250ZXh0LCBbanFYSFIsIHN0YXR1c1RleHRdKTtcXG5cXG4gICAgICAgIGlmIChmaXJlR2xvYmFscykge1xcbiAgICAgICAgICBnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlcihcXFwiYWpheENvbXBsZXRlXFxcIiwgW2pxWEhSLCBzXSk7IC8vIEhhbmRsZSB0aGUgZ2xvYmFsIEFKQVggY291bnRlclxcblxcbiAgICAgICAgICBpZiAoISAtLWpRdWVyeS5hY3RpdmUpIHtcXG4gICAgICAgICAgICBqUXVlcnkuZXZlbnQudHJpZ2dlcihcXFwiYWpheFN0b3BcXFwiKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4ganFYSFI7XFxuICAgIH0sXFxuICAgIGdldEpTT046IGZ1bmN0aW9uIGdldEpTT04odXJsLCBkYXRhLCBjYWxsYmFjaykge1xcbiAgICAgIHJldHVybiBqUXVlcnkuZ2V0KHVybCwgZGF0YSwgY2FsbGJhY2ssIFxcXCJqc29uXFxcIik7XFxuICAgIH0sXFxuICAgIGdldFNjcmlwdDogZnVuY3Rpb24gZ2V0U2NyaXB0KHVybCwgY2FsbGJhY2spIHtcXG4gICAgICByZXR1cm4galF1ZXJ5LmdldCh1cmwsIHVuZGVmaW5lZCwgY2FsbGJhY2ssIFxcXCJzY3JpcHRcXFwiKTtcXG4gICAgfVxcbiAgfSk7XFxuICBqUXVlcnkuZWFjaChbXFxcImdldFxcXCIsIFxcXCJwb3N0XFxcIl0sIGZ1bmN0aW9uIChpLCBtZXRob2QpIHtcXG4gICAgalF1ZXJ5W21ldGhvZF0gPSBmdW5jdGlvbiAodXJsLCBkYXRhLCBjYWxsYmFjaywgdHlwZSkge1xcbiAgICAgIC8vIFNoaWZ0IGFyZ3VtZW50cyBpZiBkYXRhIGFyZ3VtZW50IHdhcyBvbWl0dGVkXFxuICAgICAgaWYgKGpRdWVyeS5pc0Z1bmN0aW9uKGRhdGEpKSB7XFxuICAgICAgICB0eXBlID0gdHlwZSB8fCBjYWxsYmFjaztcXG4gICAgICAgIGNhbGxiYWNrID0gZGF0YTtcXG4gICAgICAgIGRhdGEgPSB1bmRlZmluZWQ7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBqUXVlcnkuYWpheCh7XFxuICAgICAgICB1cmw6IHVybCxcXG4gICAgICAgIHR5cGU6IG1ldGhvZCxcXG4gICAgICAgIGRhdGFUeXBlOiB0eXBlLFxcbiAgICAgICAgZGF0YTogZGF0YSxcXG4gICAgICAgIHN1Y2Nlc3M6IGNhbGxiYWNrXFxuICAgICAgfSk7XFxuICAgIH07XFxuICB9KTtcXG5cXG4gIGpRdWVyeS5fZXZhbFVybCA9IGZ1bmN0aW9uICh1cmwpIHtcXG4gICAgcmV0dXJuIGpRdWVyeS5hamF4KHtcXG4gICAgICB1cmw6IHVybCxcXG4gICAgICB0eXBlOiBcXFwiR0VUXFxcIixcXG4gICAgICBkYXRhVHlwZTogXFxcInNjcmlwdFxcXCIsXFxuICAgICAgYXN5bmM6IGZhbHNlLFxcbiAgICAgIGdsb2JhbDogZmFsc2UsXFxuICAgICAgXFxcInRocm93c1xcXCI6IHRydWVcXG4gICAgfSk7XFxuICB9O1xcblxcbiAgalF1ZXJ5LmZuLmV4dGVuZCh7XFxuICAgIHdyYXBBbGw6IGZ1bmN0aW9uIHdyYXBBbGwoaHRtbCkge1xcbiAgICAgIHZhciB3cmFwO1xcblxcbiAgICAgIGlmIChqUXVlcnkuaXNGdW5jdGlvbihodG1sKSkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoaSkge1xcbiAgICAgICAgICBqUXVlcnkodGhpcykud3JhcEFsbChodG1sLmNhbGwodGhpcywgaSkpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzWzBdKSB7XFxuICAgICAgICAvLyBUaGUgZWxlbWVudHMgdG8gd3JhcCB0aGUgdGFyZ2V0IGFyb3VuZFxcbiAgICAgICAgd3JhcCA9IGpRdWVyeShodG1sLCB0aGlzWzBdLm93bmVyRG9jdW1lbnQpLmVxKDApLmNsb25lKHRydWUpO1xcblxcbiAgICAgICAgaWYgKHRoaXNbMF0ucGFyZW50Tm9kZSkge1xcbiAgICAgICAgICB3cmFwLmluc2VydEJlZm9yZSh0aGlzWzBdKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHdyYXAubWFwKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgdmFyIGVsZW0gPSB0aGlzO1xcblxcbiAgICAgICAgICB3aGlsZSAoZWxlbS5maXJzdEVsZW1lbnRDaGlsZCkge1xcbiAgICAgICAgICAgIGVsZW0gPSBlbGVtLmZpcnN0RWxlbWVudENoaWxkO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHJldHVybiBlbGVtO1xcbiAgICAgICAgfSkuYXBwZW5kKHRoaXMpO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gdGhpcztcXG4gICAgfSxcXG4gICAgd3JhcElubmVyOiBmdW5jdGlvbiB3cmFwSW5uZXIoaHRtbCkge1xcbiAgICAgIGlmIChqUXVlcnkuaXNGdW5jdGlvbihodG1sKSkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoaSkge1xcbiAgICAgICAgICBqUXVlcnkodGhpcykud3JhcElubmVyKGh0bWwuY2FsbCh0aGlzLCBpKSk7XFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgc2VsZiA9IGpRdWVyeSh0aGlzKSxcXG4gICAgICAgICAgICBjb250ZW50cyA9IHNlbGYuY29udGVudHMoKTtcXG5cXG4gICAgICAgIGlmIChjb250ZW50cy5sZW5ndGgpIHtcXG4gICAgICAgICAgY29udGVudHMud3JhcEFsbChodG1sKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHNlbGYuYXBwZW5kKGh0bWwpO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcbiAgICB9LFxcbiAgICB3cmFwOiBmdW5jdGlvbiB3cmFwKGh0bWwpIHtcXG4gICAgICB2YXIgaXNGdW5jdGlvbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKGh0bWwpO1xcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKGkpIHtcXG4gICAgICAgIGpRdWVyeSh0aGlzKS53cmFwQWxsKGlzRnVuY3Rpb24gPyBodG1sLmNhbGwodGhpcywgaSkgOiBodG1sKTtcXG4gICAgICB9KTtcXG4gICAgfSxcXG4gICAgdW53cmFwOiBmdW5jdGlvbiB1bndyYXAoKSB7XFxuICAgICAgcmV0dXJuIHRoaXMucGFyZW50KCkuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICBpZiAoIWpRdWVyeS5ub2RlTmFtZSh0aGlzLCBcXFwiYm9keVxcXCIpKSB7XFxuICAgICAgICAgIGpRdWVyeSh0aGlzKS5yZXBsYWNlV2l0aCh0aGlzLmNoaWxkTm9kZXMpO1xcbiAgICAgICAgfVxcbiAgICAgIH0pLmVuZCgpO1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIGpRdWVyeS5leHByLmZpbHRlcnMuaGlkZGVuID0gZnVuY3Rpb24gKGVsZW0pIHtcXG4gICAgLy8gU3VwcG9ydDogT3BlcmEgPD0gMTIuMTJcXG4gICAgLy8gT3BlcmEgcmVwb3J0cyBvZmZzZXRXaWR0aHMgYW5kIG9mZnNldEhlaWdodHMgbGVzcyB0aGFuIHplcm8gb24gc29tZSBlbGVtZW50c1xcbiAgICByZXR1cm4gZWxlbS5vZmZzZXRXaWR0aCA8PSAwICYmIGVsZW0ub2Zmc2V0SGVpZ2h0IDw9IDA7XFxuICB9O1xcblxcbiAgalF1ZXJ5LmV4cHIuZmlsdGVycy52aXNpYmxlID0gZnVuY3Rpb24gKGVsZW0pIHtcXG4gICAgcmV0dXJuICFqUXVlcnkuZXhwci5maWx0ZXJzLmhpZGRlbihlbGVtKTtcXG4gIH07XFxuXFxuICB2YXIgcjIwID0gLyUyMC9nLFxcbiAgICAgIHJicmFja2V0ID0gL1xcXFxbXFxcXF0kLyxcXG4gICAgICByQ1JMRiA9IC9cXFxccj9cXFxcbi9nLFxcbiAgICAgIHJzdWJtaXR0ZXJUeXBlcyA9IC9eKD86c3VibWl0fGJ1dHRvbnxpbWFnZXxyZXNldHxmaWxlKSQvaSxcXG4gICAgICByc3VibWl0dGFibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxrZXlnZW4pL2k7XFxuXFxuICBmdW5jdGlvbiBidWlsZFBhcmFtcyhwcmVmaXgsIG9iaiwgdHJhZGl0aW9uYWwsIGFkZCkge1xcbiAgICB2YXIgbmFtZTtcXG5cXG4gICAgaWYgKGpRdWVyeS5pc0FycmF5KG9iaikpIHtcXG4gICAgICAvLyBTZXJpYWxpemUgYXJyYXkgaXRlbS5cXG4gICAgICBqUXVlcnkuZWFjaChvYmosIGZ1bmN0aW9uIChpLCB2KSB7XFxuICAgICAgICBpZiAodHJhZGl0aW9uYWwgfHwgcmJyYWNrZXQudGVzdChwcmVmaXgpKSB7XFxuICAgICAgICAgIC8vIFRyZWF0IGVhY2ggYXJyYXkgaXRlbSBhcyBhIHNjYWxhci5cXG4gICAgICAgICAgYWRkKHByZWZpeCwgdik7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAvLyBJdGVtIGlzIG5vbi1zY2FsYXIgKGFycmF5IG9yIG9iamVjdCksIGVuY29kZSBpdHMgbnVtZXJpYyBpbmRleC5cXG4gICAgICAgICAgYnVpbGRQYXJhbXMocHJlZml4ICsgXFxcIltcXFwiICsgKF90eXBlb2YodikgPT09IFxcXCJvYmplY3RcXFwiID8gaSA6IFxcXCJcXFwiKSArIFxcXCJdXFxcIiwgdiwgdHJhZGl0aW9uYWwsIGFkZCk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgIH0gZWxzZSBpZiAoIXRyYWRpdGlvbmFsICYmIGpRdWVyeS50eXBlKG9iaikgPT09IFxcXCJvYmplY3RcXFwiKSB7XFxuICAgICAgLy8gU2VyaWFsaXplIG9iamVjdCBpdGVtLlxcbiAgICAgIGZvciAobmFtZSBpbiBvYmopIHtcXG4gICAgICAgIGJ1aWxkUGFyYW1zKHByZWZpeCArIFxcXCJbXFxcIiArIG5hbWUgKyBcXFwiXVxcXCIsIG9ialtuYW1lXSwgdHJhZGl0aW9uYWwsIGFkZCk7XFxuICAgICAgfVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIC8vIFNlcmlhbGl6ZSBzY2FsYXIgaXRlbS5cXG4gICAgICBhZGQocHJlZml4LCBvYmopO1xcbiAgICB9XFxuICB9IC8vIFNlcmlhbGl6ZSBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzIG9yIGEgc2V0IG9mXFxuICAvLyBrZXkvdmFsdWVzIGludG8gYSBxdWVyeSBzdHJpbmdcXG5cXG5cXG4gIGpRdWVyeS5wYXJhbSA9IGZ1bmN0aW9uIChhLCB0cmFkaXRpb25hbCkge1xcbiAgICB2YXIgcHJlZml4LFxcbiAgICAgICAgcyA9IFtdLFxcbiAgICAgICAgYWRkID0gZnVuY3Rpb24gYWRkKGtleSwgdmFsdWUpIHtcXG4gICAgICAvLyBJZiB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCBpbnZva2UgaXQgYW5kIHJldHVybiBpdHMgdmFsdWVcXG4gICAgICB2YWx1ZSA9IGpRdWVyeS5pc0Z1bmN0aW9uKHZhbHVlKSA/IHZhbHVlKCkgOiB2YWx1ZSA9PSBudWxsID8gXFxcIlxcXCIgOiB2YWx1ZTtcXG4gICAgICBzW3MubGVuZ3RoXSA9IGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgXFxcIj1cXFwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcXG4gICAgfTsgLy8gU2V0IHRyYWRpdGlvbmFsIHRvIHRydWUgZm9yIGpRdWVyeSA8PSAxLjMuMiBiZWhhdmlvci5cXG5cXG5cXG4gICAgaWYgKHRyYWRpdGlvbmFsID09PSB1bmRlZmluZWQpIHtcXG4gICAgICB0cmFkaXRpb25hbCA9IGpRdWVyeS5hamF4U2V0dGluZ3MgJiYgalF1ZXJ5LmFqYXhTZXR0aW5ncy50cmFkaXRpb25hbDtcXG4gICAgfSAvLyBJZiBhbiBhcnJheSB3YXMgcGFzc2VkIGluLCBhc3N1bWUgdGhhdCBpdCBpcyBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzLlxcblxcblxcbiAgICBpZiAoalF1ZXJ5LmlzQXJyYXkoYSkgfHwgYS5qcXVlcnkgJiYgIWpRdWVyeS5pc1BsYWluT2JqZWN0KGEpKSB7XFxuICAgICAgLy8gU2VyaWFsaXplIHRoZSBmb3JtIGVsZW1lbnRzXFxuICAgICAgalF1ZXJ5LmVhY2goYSwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgYWRkKHRoaXMubmFtZSwgdGhpcy52YWx1ZSk7XFxuICAgICAgfSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgLy8gSWYgdHJhZGl0aW9uYWwsIGVuY29kZSB0aGUgXFxcIm9sZFxcXCIgd2F5ICh0aGUgd2F5IDEuMy4yIG9yIG9sZGVyXFxuICAgICAgLy8gZGlkIGl0KSwgb3RoZXJ3aXNlIGVuY29kZSBwYXJhbXMgcmVjdXJzaXZlbHkuXFxuICAgICAgZm9yIChwcmVmaXggaW4gYSkge1xcbiAgICAgICAgYnVpbGRQYXJhbXMocHJlZml4LCBhW3ByZWZpeF0sIHRyYWRpdGlvbmFsLCBhZGQpO1xcbiAgICAgIH1cXG4gICAgfSAvLyBSZXR1cm4gdGhlIHJlc3VsdGluZyBzZXJpYWxpemF0aW9uXFxuXFxuXFxuICAgIHJldHVybiBzLmpvaW4oXFxcIiZcXFwiKS5yZXBsYWNlKHIyMCwgXFxcIitcXFwiKTtcXG4gIH07XFxuXFxuICBqUXVlcnkuZm4uZXh0ZW5kKHtcXG4gICAgc2VyaWFsaXplOiBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XFxuICAgICAgcmV0dXJuIGpRdWVyeS5wYXJhbSh0aGlzLnNlcmlhbGl6ZUFycmF5KCkpO1xcbiAgICB9LFxcbiAgICBzZXJpYWxpemVBcnJheTogZnVuY3Rpb24gc2VyaWFsaXplQXJyYXkoKSB7XFxuICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIC8vIENhbiBhZGQgcHJvcEhvb2sgZm9yIFxcXCJlbGVtZW50c1xcXCIgdG8gZmlsdGVyIG9yIGFkZCBmb3JtIGVsZW1lbnRzXFxuICAgICAgICB2YXIgZWxlbWVudHMgPSBqUXVlcnkucHJvcCh0aGlzLCBcXFwiZWxlbWVudHNcXFwiKTtcXG4gICAgICAgIHJldHVybiBlbGVtZW50cyA/IGpRdWVyeS5tYWtlQXJyYXkoZWxlbWVudHMpIDogdGhpcztcXG4gICAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIHR5cGUgPSB0aGlzLnR5cGU7IC8vIFVzZSAuaXMoIFxcXCI6ZGlzYWJsZWRcXFwiICkgc28gdGhhdCBmaWVsZHNldFtkaXNhYmxlZF0gd29ya3NcXG5cXG4gICAgICAgIHJldHVybiB0aGlzLm5hbWUgJiYgIWpRdWVyeSh0aGlzKS5pcyhcXFwiOmRpc2FibGVkXFxcIikgJiYgcnN1Ym1pdHRhYmxlLnRlc3QodGhpcy5ub2RlTmFtZSkgJiYgIXJzdWJtaXR0ZXJUeXBlcy50ZXN0KHR5cGUpICYmICh0aGlzLmNoZWNrZWQgfHwgIXJjaGVja2FibGVUeXBlLnRlc3QodHlwZSkpO1xcbiAgICAgIH0pLm1hcChmdW5jdGlvbiAoaSwgZWxlbSkge1xcbiAgICAgICAgdmFyIHZhbCA9IGpRdWVyeSh0aGlzKS52YWwoKTtcXG4gICAgICAgIHJldHVybiB2YWwgPT0gbnVsbCA/IG51bGwgOiBqUXVlcnkuaXNBcnJheSh2YWwpID8galF1ZXJ5Lm1hcCh2YWwsIGZ1bmN0aW9uICh2YWwpIHtcXG4gICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICBuYW1lOiBlbGVtLm5hbWUsXFxuICAgICAgICAgICAgdmFsdWU6IHZhbC5yZXBsYWNlKHJDUkxGLCBcXFwiXFxcXHJcXFxcblxcXCIpXFxuICAgICAgICAgIH07XFxuICAgICAgICB9KSA6IHtcXG4gICAgICAgICAgbmFtZTogZWxlbS5uYW1lLFxcbiAgICAgICAgICB2YWx1ZTogdmFsLnJlcGxhY2UockNSTEYsIFxcXCJcXFxcclxcXFxuXFxcIilcXG4gICAgICAgIH07XFxuICAgICAgfSkuZ2V0KCk7XFxuICAgIH1cXG4gIH0pO1xcblxcbiAgalF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIgPSBmdW5jdGlvbiAoKSB7XFxuICAgIHRyeSB7XFxuICAgICAgcmV0dXJuIG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xcbiAgICB9IGNhdGNoIChlKSB7fVxcbiAgfTtcXG5cXG4gIHZhciB4aHJJZCA9IDAsXFxuICAgICAgeGhyQ2FsbGJhY2tzID0ge30sXFxuICAgICAgeGhyU3VjY2Vzc1N0YXR1cyA9IHtcXG4gICAgLy8gZmlsZSBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyBjb2RlIDAsIGFzc3VtZSAyMDBcXG4gICAgMDogMjAwLFxcbiAgICAvLyBTdXBwb3J0OiBJRTlcXG4gICAgLy8gIzE0NTA6IHNvbWV0aW1lcyBJRSByZXR1cm5zIDEyMjMgd2hlbiBpdCBzaG91bGQgYmUgMjA0XFxuICAgIDEyMjM6IDIwNFxcbiAgfSxcXG4gICAgICB4aHJTdXBwb3J0ZWQgPSBqUXVlcnkuYWpheFNldHRpbmdzLnhocigpOyAvLyBTdXBwb3J0OiBJRTlcXG4gIC8vIE9wZW4gcmVxdWVzdHMgbXVzdCBiZSBtYW51YWxseSBhYm9ydGVkIG9uIHVubG9hZCAoIzUyODApXFxuICAvLyBTZWUgaHR0cHM6Ly9zdXBwb3J0Lm1pY3Jvc29mdC5jb20va2IvMjg1Njc0NiBmb3IgbW9yZSBpbmZvXFxuXFxuICBpZiAod2luZG93LmF0dGFjaEV2ZW50KSB7XFxuICAgIHdpbmRvdy5hdHRhY2hFdmVudChcXFwib251bmxvYWRcXFwiLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgZm9yICh2YXIga2V5IGluIHhockNhbGxiYWNrcykge1xcbiAgICAgICAgeGhyQ2FsbGJhY2tzW2tleV0oKTtcXG4gICAgICB9XFxuICAgIH0pO1xcbiAgfVxcblxcbiAgc3VwcG9ydC5jb3JzID0gISF4aHJTdXBwb3J0ZWQgJiYgXFxcIndpdGhDcmVkZW50aWFsc1xcXCIgaW4geGhyU3VwcG9ydGVkO1xcbiAgc3VwcG9ydC5hamF4ID0geGhyU3VwcG9ydGVkID0gISF4aHJTdXBwb3J0ZWQ7XFxuICBqUXVlcnkuYWpheFRyYW5zcG9ydChmdW5jdGlvbiAob3B0aW9ucykge1xcbiAgICB2YXIgX2NhbGxiYWNrOyAvLyBDcm9zcyBkb21haW4gb25seSBhbGxvd2VkIGlmIHN1cHBvcnRlZCB0aHJvdWdoIFhNTEh0dHBSZXF1ZXN0XFxuXFxuXFxuICAgIGlmIChzdXBwb3J0LmNvcnMgfHwgeGhyU3VwcG9ydGVkICYmICFvcHRpb25zLmNyb3NzRG9tYWluKSB7XFxuICAgICAgcmV0dXJuIHtcXG4gICAgICAgIHNlbmQ6IGZ1bmN0aW9uIHNlbmQoaGVhZGVycywgY29tcGxldGUpIHtcXG4gICAgICAgICAgdmFyIGksXFxuICAgICAgICAgICAgICB4aHIgPSBvcHRpb25zLnhocigpLFxcbiAgICAgICAgICAgICAgaWQgPSArK3hocklkO1xcbiAgICAgICAgICB4aHIub3BlbihvcHRpb25zLnR5cGUsIG9wdGlvbnMudXJsLCBvcHRpb25zLmFzeW5jLCBvcHRpb25zLnVzZXJuYW1lLCBvcHRpb25zLnBhc3N3b3JkKTsgLy8gQXBwbHkgY3VzdG9tIGZpZWxkcyBpZiBwcm92aWRlZFxcblxcbiAgICAgICAgICBpZiAob3B0aW9ucy54aHJGaWVsZHMpIHtcXG4gICAgICAgICAgICBmb3IgKGkgaW4gb3B0aW9ucy54aHJGaWVsZHMpIHtcXG4gICAgICAgICAgICAgIHhocltpXSA9IG9wdGlvbnMueGhyRmllbGRzW2ldO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSAvLyBPdmVycmlkZSBtaW1lIHR5cGUgaWYgbmVlZGVkXFxuXFxuXFxuICAgICAgICAgIGlmIChvcHRpb25zLm1pbWVUeXBlICYmIHhoci5vdmVycmlkZU1pbWVUeXBlKSB7XFxuICAgICAgICAgICAgeGhyLm92ZXJyaWRlTWltZVR5cGUob3B0aW9ucy5taW1lVHlwZSk7XFxuICAgICAgICAgIH0gLy8gWC1SZXF1ZXN0ZWQtV2l0aCBoZWFkZXJcXG4gICAgICAgICAgLy8gRm9yIGNyb3NzLWRvbWFpbiByZXF1ZXN0cywgc2VlaW5nIGFzIGNvbmRpdGlvbnMgZm9yIGEgcHJlZmxpZ2h0IGFyZVxcbiAgICAgICAgICAvLyBha2luIHRvIGEgamlnc2F3IHB1enpsZSwgd2Ugc2ltcGx5IG5ldmVyIHNldCBpdCB0byBiZSBzdXJlLlxcbiAgICAgICAgICAvLyAoaXQgY2FuIGFsd2F5cyBiZSBzZXQgb24gYSBwZXItcmVxdWVzdCBiYXNpcyBvciBldmVuIHVzaW5nIGFqYXhTZXR1cClcXG4gICAgICAgICAgLy8gRm9yIHNhbWUtZG9tYWluIHJlcXVlc3RzLCB3b24ndCBjaGFuZ2UgaGVhZGVyIGlmIGFscmVhZHkgcHJvdmlkZWQuXFxuXFxuXFxuICAgICAgICAgIGlmICghb3B0aW9ucy5jcm9zc0RvbWFpbiAmJiAhaGVhZGVyc1tcXFwiWC1SZXF1ZXN0ZWQtV2l0aFxcXCJdKSB7XFxuICAgICAgICAgICAgaGVhZGVyc1tcXFwiWC1SZXF1ZXN0ZWQtV2l0aFxcXCJdID0gXFxcIlhNTEh0dHBSZXF1ZXN0XFxcIjtcXG4gICAgICAgICAgfSAvLyBTZXQgaGVhZGVyc1xcblxcblxcbiAgICAgICAgICBmb3IgKGkgaW4gaGVhZGVycykge1xcbiAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGksIGhlYWRlcnNbaV0pO1xcbiAgICAgICAgICB9IC8vIENhbGxiYWNrXFxuXFxuXFxuICAgICAgICAgIF9jYWxsYmFjayA9IGZ1bmN0aW9uIGNhbGxiYWNrKHR5cGUpIHtcXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgaWYgKF9jYWxsYmFjaykge1xcbiAgICAgICAgICAgICAgICBkZWxldGUgeGhyQ2FsbGJhY2tzW2lkXTtcXG4gICAgICAgICAgICAgICAgX2NhbGxiYWNrID0geGhyLm9ubG9hZCA9IHhoci5vbmVycm9yID0gbnVsbDtcXG5cXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IFxcXCJhYm9ydFxcXCIpIHtcXG4gICAgICAgICAgICAgICAgICB4aHIuYWJvcnQoKTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcXFwiZXJyb3JcXFwiKSB7XFxuICAgICAgICAgICAgICAgICAgY29tcGxldGUoIC8vIGZpbGU6IHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIDA7IHNlZSAjODYwNSwgIzE0MjA3XFxuICAgICAgICAgICAgICAgICAgeGhyLnN0YXR1cywgeGhyLnN0YXR1c1RleHQpO1xcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgIGNvbXBsZXRlKHhoclN1Y2Nlc3NTdGF0dXNbeGhyLnN0YXR1c10gfHwgeGhyLnN0YXR1cywgeGhyLnN0YXR1c1RleHQsIC8vIFN1cHBvcnQ6IElFOVxcbiAgICAgICAgICAgICAgICAgIC8vIEFjY2Vzc2luZyBiaW5hcnktZGF0YSByZXNwb25zZVRleHQgdGhyb3dzIGFuIGV4Y2VwdGlvblxcbiAgICAgICAgICAgICAgICAgIC8vICgjMTE0MjYpXFxuICAgICAgICAgICAgICAgICAgdHlwZW9mIHhoci5yZXNwb25zZVRleHQgPT09IFxcXCJzdHJpbmdcXFwiID8ge1xcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogeGhyLnJlc3BvbnNlVGV4dFxcbiAgICAgICAgICAgICAgICAgIH0gOiB1bmRlZmluZWQsIHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9O1xcbiAgICAgICAgICB9OyAvLyBMaXN0ZW4gdG8gZXZlbnRzXFxuXFxuXFxuICAgICAgICAgIHhoci5vbmxvYWQgPSBfY2FsbGJhY2soKTtcXG4gICAgICAgICAgeGhyLm9uZXJyb3IgPSBfY2FsbGJhY2soXFxcImVycm9yXFxcIik7IC8vIENyZWF0ZSB0aGUgYWJvcnQgY2FsbGJhY2tcXG5cXG4gICAgICAgICAgX2NhbGxiYWNrID0geGhyQ2FsbGJhY2tzW2lkXSA9IF9jYWxsYmFjayhcXFwiYWJvcnRcXFwiKTtcXG5cXG4gICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAvLyBEbyBzZW5kIHRoZSByZXF1ZXN0ICh0aGlzIG1heSByYWlzZSBhbiBleGNlcHRpb24pXFxuICAgICAgICAgICAgeGhyLnNlbmQob3B0aW9ucy5oYXNDb250ZW50ICYmIG9wdGlvbnMuZGF0YSB8fCBudWxsKTtcXG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgICAgIC8vICMxNDY4MzogT25seSByZXRocm93IGlmIHRoaXMgaGFzbid0IGJlZW4gbm90aWZpZWQgYXMgYW4gZXJyb3IgeWV0XFxuICAgICAgICAgICAgaWYgKF9jYWxsYmFjaykge1xcbiAgICAgICAgICAgICAgdGhyb3cgZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuICAgICAgICBhYm9ydDogZnVuY3Rpb24gYWJvcnQoKSB7XFxuICAgICAgICAgIGlmIChfY2FsbGJhY2spIHtcXG4gICAgICAgICAgICBfY2FsbGJhY2soKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgIH1cXG4gIH0pOyAvLyBJbnN0YWxsIHNjcmlwdCBkYXRhVHlwZVxcblxcbiAgalF1ZXJ5LmFqYXhTZXR1cCh7XFxuICAgIGFjY2VwdHM6IHtcXG4gICAgICBzY3JpcHQ6IFxcXCJ0ZXh0L2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2VjbWFzY3JpcHQsIGFwcGxpY2F0aW9uL3gtZWNtYXNjcmlwdFxcXCJcXG4gICAgfSxcXG4gICAgY29udGVudHM6IHtcXG4gICAgICBzY3JpcHQ6IC8oPzpqYXZhfGVjbWEpc2NyaXB0L1xcbiAgICB9LFxcbiAgICBjb252ZXJ0ZXJzOiB7XFxuICAgICAgXFxcInRleHQgc2NyaXB0XFxcIjogZnVuY3Rpb24gdGV4dFNjcmlwdCh0ZXh0KSB7XFxuICAgICAgICBqUXVlcnkuZ2xvYmFsRXZhbCh0ZXh0KTtcXG4gICAgICAgIHJldHVybiB0ZXh0O1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfSk7IC8vIEhhbmRsZSBjYWNoZSdzIHNwZWNpYWwgY2FzZSBhbmQgY3Jvc3NEb21haW5cXG5cXG4gIGpRdWVyeS5hamF4UHJlZmlsdGVyKFxcXCJzY3JpcHRcXFwiLCBmdW5jdGlvbiAocykge1xcbiAgICBpZiAocy5jYWNoZSA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgcy5jYWNoZSA9IGZhbHNlO1xcbiAgICB9XFxuXFxuICAgIGlmIChzLmNyb3NzRG9tYWluKSB7XFxuICAgICAgcy50eXBlID0gXFxcIkdFVFxcXCI7XFxuICAgIH1cXG4gIH0pOyAvLyBCaW5kIHNjcmlwdCB0YWcgaGFjayB0cmFuc3BvcnRcXG5cXG4gIGpRdWVyeS5hamF4VHJhbnNwb3J0KFxcXCJzY3JpcHRcXFwiLCBmdW5jdGlvbiAocykge1xcbiAgICAvLyBUaGlzIHRyYW5zcG9ydCBvbmx5IGRlYWxzIHdpdGggY3Jvc3MgZG9tYWluIHJlcXVlc3RzXFxuICAgIGlmIChzLmNyb3NzRG9tYWluKSB7XFxuICAgICAgdmFyIHNjcmlwdCwgX2NhbGxiYWNrMjtcXG5cXG4gICAgICByZXR1cm4ge1xcbiAgICAgICAgc2VuZDogZnVuY3Rpb24gc2VuZChfLCBjb21wbGV0ZSkge1xcbiAgICAgICAgICBzY3JpcHQgPSBqUXVlcnkoXFxcIjxzY3JpcHQ+XFxcIikucHJvcCh7XFxuICAgICAgICAgICAgYXN5bmM6IHRydWUsXFxuICAgICAgICAgICAgY2hhcnNldDogcy5zY3JpcHRDaGFyc2V0LFxcbiAgICAgICAgICAgIHNyYzogcy51cmxcXG4gICAgICAgICAgfSkub24oXFxcImxvYWQgZXJyb3JcXFwiLCBfY2FsbGJhY2syID0gZnVuY3Rpb24gY2FsbGJhY2soZXZ0KSB7XFxuICAgICAgICAgICAgc2NyaXB0LnJlbW92ZSgpO1xcbiAgICAgICAgICAgIF9jYWxsYmFjazIgPSBudWxsO1xcblxcbiAgICAgICAgICAgIGlmIChldnQpIHtcXG4gICAgICAgICAgICAgIGNvbXBsZXRlKGV2dC50eXBlID09PSBcXFwiZXJyb3JcXFwiID8gNDA0IDogMjAwLCBldnQudHlwZSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9KTtcXG4gICAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzY3JpcHRbMF0pO1xcbiAgICAgICAgfSxcXG4gICAgICAgIGFib3J0OiBmdW5jdGlvbiBhYm9ydCgpIHtcXG4gICAgICAgICAgaWYgKF9jYWxsYmFjazIpIHtcXG4gICAgICAgICAgICBfY2FsbGJhY2syKCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICB9XFxuICB9KTtcXG4gIHZhciBvbGRDYWxsYmFja3MgPSBbXSxcXG4gICAgICByanNvbnAgPSAvKD0pXFxcXD8oPz0mfCQpfFxcXFw/XFxcXD8vOyAvLyBEZWZhdWx0IGpzb25wIHNldHRpbmdzXFxuXFxuICBqUXVlcnkuYWpheFNldHVwKHtcXG4gICAganNvbnA6IFxcXCJjYWxsYmFja1xcXCIsXFxuICAgIGpzb25wQ2FsbGJhY2s6IGZ1bmN0aW9uIGpzb25wQ2FsbGJhY2soKSB7XFxuICAgICAgdmFyIGNhbGxiYWNrID0gb2xkQ2FsbGJhY2tzLnBvcCgpIHx8IGpRdWVyeS5leHBhbmRvICsgXFxcIl9cXFwiICsgbm9uY2UrKztcXG4gICAgICB0aGlzW2NhbGxiYWNrXSA9IHRydWU7XFxuICAgICAgcmV0dXJuIGNhbGxiYWNrO1xcbiAgICB9XFxuICB9KTsgLy8gRGV0ZWN0LCBub3JtYWxpemUgb3B0aW9ucyBhbmQgaW5zdGFsbCBjYWxsYmFja3MgZm9yIGpzb25wIHJlcXVlc3RzXFxuXFxuICBqUXVlcnkuYWpheFByZWZpbHRlcihcXFwianNvbiBqc29ucFxcXCIsIGZ1bmN0aW9uIChzLCBvcmlnaW5hbFNldHRpbmdzLCBqcVhIUikge1xcbiAgICB2YXIgY2FsbGJhY2tOYW1lLFxcbiAgICAgICAgb3ZlcndyaXR0ZW4sXFxuICAgICAgICByZXNwb25zZUNvbnRhaW5lcixcXG4gICAgICAgIGpzb25Qcm9wID0gcy5qc29ucCAhPT0gZmFsc2UgJiYgKHJqc29ucC50ZXN0KHMudXJsKSA/IFxcXCJ1cmxcXFwiIDogdHlwZW9mIHMuZGF0YSA9PT0gXFxcInN0cmluZ1xcXCIgJiYgIShzLmNvbnRlbnRUeXBlIHx8IFxcXCJcXFwiKS5pbmRleE9mKFxcXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcXFwiKSAmJiByanNvbnAudGVzdChzLmRhdGEpICYmIFxcXCJkYXRhXFxcIik7IC8vIEhhbmRsZSBpZmYgdGhlIGV4cGVjdGVkIGRhdGEgdHlwZSBpcyBcXFwianNvbnBcXFwiIG9yIHdlIGhhdmUgYSBwYXJhbWV0ZXIgdG8gc2V0XFxuXFxuICAgIGlmIChqc29uUHJvcCB8fCBzLmRhdGFUeXBlc1swXSA9PT0gXFxcImpzb25wXFxcIikge1xcbiAgICAgIC8vIEdldCBjYWxsYmFjayBuYW1lLCByZW1lbWJlcmluZyBwcmVleGlzdGluZyB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggaXRcXG4gICAgICBjYWxsYmFja05hbWUgPSBzLmpzb25wQ2FsbGJhY2sgPSBqUXVlcnkuaXNGdW5jdGlvbihzLmpzb25wQ2FsbGJhY2spID8gcy5qc29ucENhbGxiYWNrKCkgOiBzLmpzb25wQ2FsbGJhY2s7IC8vIEluc2VydCBjYWxsYmFjayBpbnRvIHVybCBvciBmb3JtIGRhdGFcXG5cXG4gICAgICBpZiAoanNvblByb3ApIHtcXG4gICAgICAgIHNbanNvblByb3BdID0gc1tqc29uUHJvcF0ucmVwbGFjZShyanNvbnAsIFxcXCIkMVxcXCIgKyBjYWxsYmFja05hbWUpO1xcbiAgICAgIH0gZWxzZSBpZiAocy5qc29ucCAhPT0gZmFsc2UpIHtcXG4gICAgICAgIHMudXJsICs9IChycXVlcnkudGVzdChzLnVybCkgPyBcXFwiJlxcXCIgOiBcXFwiP1xcXCIpICsgcy5qc29ucCArIFxcXCI9XFxcIiArIGNhbGxiYWNrTmFtZTtcXG4gICAgICB9IC8vIFVzZSBkYXRhIGNvbnZlcnRlciB0byByZXRyaWV2ZSBqc29uIGFmdGVyIHNjcmlwdCBleGVjdXRpb25cXG5cXG5cXG4gICAgICBzLmNvbnZlcnRlcnNbXFxcInNjcmlwdCBqc29uXFxcIl0gPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICBpZiAoIXJlc3BvbnNlQ29udGFpbmVyKSB7XFxuICAgICAgICAgIGpRdWVyeS5lcnJvcihjYWxsYmFja05hbWUgKyBcXFwiIHdhcyBub3QgY2FsbGVkXFxcIik7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gcmVzcG9uc2VDb250YWluZXJbMF07XFxuICAgICAgfTsgLy8gZm9yY2UganNvbiBkYXRhVHlwZVxcblxcblxcbiAgICAgIHMuZGF0YVR5cGVzWzBdID0gXFxcImpzb25cXFwiOyAvLyBJbnN0YWxsIGNhbGxiYWNrXFxuXFxuICAgICAgb3ZlcndyaXR0ZW4gPSB3aW5kb3dbY2FsbGJhY2tOYW1lXTtcXG5cXG4gICAgICB3aW5kb3dbY2FsbGJhY2tOYW1lXSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHJlc3BvbnNlQ29udGFpbmVyID0gYXJndW1lbnRzO1xcbiAgICAgIH07IC8vIENsZWFuLXVwIGZ1bmN0aW9uIChmaXJlcyBhZnRlciBjb252ZXJ0ZXJzKVxcblxcblxcbiAgICAgIGpxWEhSLmFsd2F5cyhmdW5jdGlvbiAoKSB7XFxuICAgICAgICAvLyBSZXN0b3JlIHByZWV4aXN0aW5nIHZhbHVlXFxuICAgICAgICB3aW5kb3dbY2FsbGJhY2tOYW1lXSA9IG92ZXJ3cml0dGVuOyAvLyBTYXZlIGJhY2sgYXMgZnJlZVxcblxcbiAgICAgICAgaWYgKHNbY2FsbGJhY2tOYW1lXSkge1xcbiAgICAgICAgICAvLyBtYWtlIHN1cmUgdGhhdCByZS11c2luZyB0aGUgb3B0aW9ucyBkb2Vzbid0IHNjcmV3IHRoaW5ncyBhcm91bmRcXG4gICAgICAgICAgcy5qc29ucENhbGxiYWNrID0gb3JpZ2luYWxTZXR0aW5ncy5qc29ucENhbGxiYWNrOyAvLyBzYXZlIHRoZSBjYWxsYmFjayBuYW1lIGZvciBmdXR1cmUgdXNlXFxuXFxuICAgICAgICAgIG9sZENhbGxiYWNrcy5wdXNoKGNhbGxiYWNrTmFtZSk7XFxuICAgICAgICB9IC8vIENhbGwgaWYgaXQgd2FzIGEgZnVuY3Rpb24gYW5kIHdlIGhhdmUgYSByZXNwb25zZVxcblxcblxcbiAgICAgICAgaWYgKHJlc3BvbnNlQ29udGFpbmVyICYmIGpRdWVyeS5pc0Z1bmN0aW9uKG92ZXJ3cml0dGVuKSkge1xcbiAgICAgICAgICBvdmVyd3JpdHRlbihyZXNwb25zZUNvbnRhaW5lclswXSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXNwb25zZUNvbnRhaW5lciA9IG92ZXJ3cml0dGVuID0gdW5kZWZpbmVkO1xcbiAgICAgIH0pOyAvLyBEZWxlZ2F0ZSB0byBzY3JpcHRcXG5cXG4gICAgICByZXR1cm4gXFxcInNjcmlwdFxcXCI7XFxuICAgIH1cXG4gIH0pOyAvLyBkYXRhOiBzdHJpbmcgb2YgaHRtbFxcbiAgLy8gY29udGV4dCAob3B0aW9uYWwpOiBJZiBzcGVjaWZpZWQsIHRoZSBmcmFnbWVudCB3aWxsIGJlIGNyZWF0ZWQgaW4gdGhpcyBjb250ZXh0LCBkZWZhdWx0cyB0byBkb2N1bWVudFxcbiAgLy8ga2VlcFNjcmlwdHMgKG9wdGlvbmFsKTogSWYgdHJ1ZSwgd2lsbCBpbmNsdWRlIHNjcmlwdHMgcGFzc2VkIGluIHRoZSBodG1sIHN0cmluZ1xcblxcbiAgalF1ZXJ5LnBhcnNlSFRNTCA9IGZ1bmN0aW9uIChkYXRhLCBjb250ZXh0LCBrZWVwU2NyaXB0cykge1xcbiAgICBpZiAoIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09IFxcXCJzdHJpbmdcXFwiKSB7XFxuICAgICAgcmV0dXJuIG51bGw7XFxuICAgIH1cXG5cXG4gICAgaWYgKHR5cGVvZiBjb250ZXh0ID09PSBcXFwiYm9vbGVhblxcXCIpIHtcXG4gICAgICBrZWVwU2NyaXB0cyA9IGNvbnRleHQ7XFxuICAgICAgY29udGV4dCA9IGZhbHNlO1xcbiAgICB9XFxuXFxuICAgIGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xcbiAgICB2YXIgcGFyc2VkID0gcnNpbmdsZVRhZy5leGVjKGRhdGEpLFxcbiAgICAgICAgc2NyaXB0cyA9ICFrZWVwU2NyaXB0cyAmJiBbXTsgLy8gU2luZ2xlIHRhZ1xcblxcbiAgICBpZiAocGFyc2VkKSB7XFxuICAgICAgcmV0dXJuIFtjb250ZXh0LmNyZWF0ZUVsZW1lbnQocGFyc2VkWzFdKV07XFxuICAgIH1cXG5cXG4gICAgcGFyc2VkID0galF1ZXJ5LmJ1aWxkRnJhZ21lbnQoW2RhdGFdLCBjb250ZXh0LCBzY3JpcHRzKTtcXG5cXG4gICAgaWYgKHNjcmlwdHMgJiYgc2NyaXB0cy5sZW5ndGgpIHtcXG4gICAgICBqUXVlcnkoc2NyaXB0cykucmVtb3ZlKCk7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIGpRdWVyeS5tZXJnZShbXSwgcGFyc2VkLmNoaWxkTm9kZXMpO1xcbiAgfTsgLy8gS2VlcCBhIGNvcHkgb2YgdGhlIG9sZCBsb2FkIG1ldGhvZFxcblxcblxcbiAgdmFyIF9sb2FkID0galF1ZXJ5LmZuLmxvYWQ7XFxuICAvKipcXG4gICAqIExvYWQgYSB1cmwgaW50byBhIHBhZ2VcXG4gICAqL1xcblxcbiAgalF1ZXJ5LmZuLmxvYWQgPSBmdW5jdGlvbiAodXJsLCBwYXJhbXMsIGNhbGxiYWNrKSB7XFxuICAgIGlmICh0eXBlb2YgdXJsICE9PSBcXFwic3RyaW5nXFxcIiAmJiBfbG9hZCkge1xcbiAgICAgIHJldHVybiBfbG9hZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgICB9XFxuXFxuICAgIHZhciBzZWxlY3RvcixcXG4gICAgICAgIHR5cGUsXFxuICAgICAgICByZXNwb25zZSxcXG4gICAgICAgIHNlbGYgPSB0aGlzLFxcbiAgICAgICAgb2ZmID0gdXJsLmluZGV4T2YoXFxcIiBcXFwiKTtcXG5cXG4gICAgaWYgKG9mZiA+PSAwKSB7XFxuICAgICAgc2VsZWN0b3IgPSBqUXVlcnkudHJpbSh1cmwuc2xpY2Uob2ZmKSk7XFxuICAgICAgdXJsID0gdXJsLnNsaWNlKDAsIG9mZik7XFxuICAgIH0gLy8gSWYgaXQncyBhIGZ1bmN0aW9uXFxuXFxuXFxuICAgIGlmIChqUXVlcnkuaXNGdW5jdGlvbihwYXJhbXMpKSB7XFxuICAgICAgLy8gV2UgYXNzdW1lIHRoYXQgaXQncyB0aGUgY2FsbGJhY2tcXG4gICAgICBjYWxsYmFjayA9IHBhcmFtcztcXG4gICAgICBwYXJhbXMgPSB1bmRlZmluZWQ7IC8vIE90aGVyd2lzZSwgYnVpbGQgYSBwYXJhbSBzdHJpbmdcXG4gICAgfSBlbHNlIGlmIChwYXJhbXMgJiYgX3R5cGVvZihwYXJhbXMpID09PSBcXFwib2JqZWN0XFxcIikge1xcbiAgICAgIHR5cGUgPSBcXFwiUE9TVFxcXCI7XFxuICAgIH0gLy8gSWYgd2UgaGF2ZSBlbGVtZW50cyB0byBtb2RpZnksIG1ha2UgdGhlIHJlcXVlc3RcXG5cXG5cXG4gICAgaWYgKHNlbGYubGVuZ3RoID4gMCkge1xcbiAgICAgIGpRdWVyeS5hamF4KHtcXG4gICAgICAgIHVybDogdXJsLFxcbiAgICAgICAgLy8gaWYgXFxcInR5cGVcXFwiIHZhcmlhYmxlIGlzIHVuZGVmaW5lZCwgdGhlbiBcXFwiR0VUXFxcIiBtZXRob2Qgd2lsbCBiZSB1c2VkXFxuICAgICAgICB0eXBlOiB0eXBlLFxcbiAgICAgICAgZGF0YVR5cGU6IFxcXCJodG1sXFxcIixcXG4gICAgICAgIGRhdGE6IHBhcmFtc1xcbiAgICAgIH0pLmRvbmUoZnVuY3Rpb24gKHJlc3BvbnNlVGV4dCkge1xcbiAgICAgICAgLy8gU2F2ZSByZXNwb25zZSBmb3IgdXNlIGluIGNvbXBsZXRlIGNhbGxiYWNrXFxuICAgICAgICByZXNwb25zZSA9IGFyZ3VtZW50cztcXG4gICAgICAgIHNlbGYuaHRtbChzZWxlY3RvciA/IC8vIElmIGEgc2VsZWN0b3Igd2FzIHNwZWNpZmllZCwgbG9jYXRlIHRoZSByaWdodCBlbGVtZW50cyBpbiBhIGR1bW15IGRpdlxcbiAgICAgICAgLy8gRXhjbHVkZSBzY3JpcHRzIHRvIGF2b2lkIElFICdQZXJtaXNzaW9uIERlbmllZCcgZXJyb3JzXFxuICAgICAgICBqUXVlcnkoXFxcIjxkaXY+XFxcIikuYXBwZW5kKGpRdWVyeS5wYXJzZUhUTUwocmVzcG9uc2VUZXh0KSkuZmluZChzZWxlY3RvcikgOiAvLyBPdGhlcndpc2UgdXNlIHRoZSBmdWxsIHJlc3VsdFxcbiAgICAgICAgcmVzcG9uc2VUZXh0KTtcXG4gICAgICB9KS5jb21wbGV0ZShjYWxsYmFjayAmJiBmdW5jdGlvbiAoanFYSFIsIHN0YXR1cykge1xcbiAgICAgICAgc2VsZi5lYWNoKGNhbGxiYWNrLCByZXNwb25zZSB8fCBbanFYSFIucmVzcG9uc2VUZXh0LCBzdGF0dXMsIGpxWEhSXSk7XFxuICAgICAgfSk7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHRoaXM7XFxuICB9OyAvLyBBdHRhY2ggYSBidW5jaCBvZiBmdW5jdGlvbnMgZm9yIGhhbmRsaW5nIGNvbW1vbiBBSkFYIGV2ZW50c1xcblxcblxcbiAgalF1ZXJ5LmVhY2goW1xcXCJhamF4U3RhcnRcXFwiLCBcXFwiYWpheFN0b3BcXFwiLCBcXFwiYWpheENvbXBsZXRlXFxcIiwgXFxcImFqYXhFcnJvclxcXCIsIFxcXCJhamF4U3VjY2Vzc1xcXCIsIFxcXCJhamF4U2VuZFxcXCJdLCBmdW5jdGlvbiAoaSwgdHlwZSkge1xcbiAgICBqUXVlcnkuZm5bdHlwZV0gPSBmdW5jdGlvbiAoZm4pIHtcXG4gICAgICByZXR1cm4gdGhpcy5vbih0eXBlLCBmbik7XFxuICAgIH07XFxuICB9KTtcXG5cXG4gIGpRdWVyeS5leHByLmZpbHRlcnMuYW5pbWF0ZWQgPSBmdW5jdGlvbiAoZWxlbSkge1xcbiAgICByZXR1cm4galF1ZXJ5LmdyZXAoalF1ZXJ5LnRpbWVycywgZnVuY3Rpb24gKGZuKSB7XFxuICAgICAgcmV0dXJuIGVsZW0gPT09IGZuLmVsZW07XFxuICAgIH0pLmxlbmd0aDtcXG4gIH07XFxuXFxuICB2YXIgZG9jRWxlbSA9IHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XFxuICAvKipcXG4gICAqIEdldHMgYSB3aW5kb3cgZnJvbSBhbiBlbGVtZW50XFxuICAgKi9cXG5cXG4gIGZ1bmN0aW9uIGdldFdpbmRvdyhlbGVtKSB7XFxuICAgIHJldHVybiBqUXVlcnkuaXNXaW5kb3coZWxlbSkgPyBlbGVtIDogZWxlbS5ub2RlVHlwZSA9PT0gOSAmJiBlbGVtLmRlZmF1bHRWaWV3O1xcbiAgfVxcblxcbiAgalF1ZXJ5Lm9mZnNldCA9IHtcXG4gICAgc2V0T2Zmc2V0OiBmdW5jdGlvbiBzZXRPZmZzZXQoZWxlbSwgb3B0aW9ucywgaSkge1xcbiAgICAgIHZhciBjdXJQb3NpdGlvbixcXG4gICAgICAgICAgY3VyTGVmdCxcXG4gICAgICAgICAgY3VyQ1NTVG9wLFxcbiAgICAgICAgICBjdXJUb3AsXFxuICAgICAgICAgIGN1ck9mZnNldCxcXG4gICAgICAgICAgY3VyQ1NTTGVmdCxcXG4gICAgICAgICAgY2FsY3VsYXRlUG9zaXRpb24sXFxuICAgICAgICAgIHBvc2l0aW9uID0galF1ZXJ5LmNzcyhlbGVtLCBcXFwicG9zaXRpb25cXFwiKSxcXG4gICAgICAgICAgY3VyRWxlbSA9IGpRdWVyeShlbGVtKSxcXG4gICAgICAgICAgcHJvcHMgPSB7fTsgLy8gU2V0IHBvc2l0aW9uIGZpcnN0LCBpbi1jYXNlIHRvcC9sZWZ0IGFyZSBzZXQgZXZlbiBvbiBzdGF0aWMgZWxlbVxcblxcbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gXFxcInN0YXRpY1xcXCIpIHtcXG4gICAgICAgIGVsZW0uc3R5bGUucG9zaXRpb24gPSBcXFwicmVsYXRpdmVcXFwiO1xcbiAgICAgIH1cXG5cXG4gICAgICBjdXJPZmZzZXQgPSBjdXJFbGVtLm9mZnNldCgpO1xcbiAgICAgIGN1ckNTU1RvcCA9IGpRdWVyeS5jc3MoZWxlbSwgXFxcInRvcFxcXCIpO1xcbiAgICAgIGN1ckNTU0xlZnQgPSBqUXVlcnkuY3NzKGVsZW0sIFxcXCJsZWZ0XFxcIik7XFxuICAgICAgY2FsY3VsYXRlUG9zaXRpb24gPSAocG9zaXRpb24gPT09IFxcXCJhYnNvbHV0ZVxcXCIgfHwgcG9zaXRpb24gPT09IFxcXCJmaXhlZFxcXCIpICYmIChjdXJDU1NUb3AgKyBjdXJDU1NMZWZ0KS5pbmRleE9mKFxcXCJhdXRvXFxcIikgPiAtMTsgLy8gTmVlZCB0byBiZSBhYmxlIHRvIGNhbGN1bGF0ZSBwb3NpdGlvbiBpZiBlaXRoZXJcXG4gICAgICAvLyB0b3Agb3IgbGVmdCBpcyBhdXRvIGFuZCBwb3NpdGlvbiBpcyBlaXRoZXIgYWJzb2x1dGUgb3IgZml4ZWRcXG5cXG4gICAgICBpZiAoY2FsY3VsYXRlUG9zaXRpb24pIHtcXG4gICAgICAgIGN1clBvc2l0aW9uID0gY3VyRWxlbS5wb3NpdGlvbigpO1xcbiAgICAgICAgY3VyVG9wID0gY3VyUG9zaXRpb24udG9wO1xcbiAgICAgICAgY3VyTGVmdCA9IGN1clBvc2l0aW9uLmxlZnQ7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGN1clRvcCA9IHBhcnNlRmxvYXQoY3VyQ1NTVG9wKSB8fCAwO1xcbiAgICAgICAgY3VyTGVmdCA9IHBhcnNlRmxvYXQoY3VyQ1NTTGVmdCkgfHwgMDtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGpRdWVyeS5pc0Z1bmN0aW9uKG9wdGlvbnMpKSB7XFxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucy5jYWxsKGVsZW0sIGksIGN1ck9mZnNldCk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChvcHRpb25zLnRvcCAhPSBudWxsKSB7XFxuICAgICAgICBwcm9wcy50b3AgPSBvcHRpb25zLnRvcCAtIGN1ck9mZnNldC50b3AgKyBjdXJUb3A7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChvcHRpb25zLmxlZnQgIT0gbnVsbCkge1xcbiAgICAgICAgcHJvcHMubGVmdCA9IG9wdGlvbnMubGVmdCAtIGN1ck9mZnNldC5sZWZ0ICsgY3VyTGVmdDtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKFxcXCJ1c2luZ1xcXCIgaW4gb3B0aW9ucykge1xcbiAgICAgICAgb3B0aW9ucy51c2luZy5jYWxsKGVsZW0sIHByb3BzKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgY3VyRWxlbS5jc3MocHJvcHMpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfTtcXG4gIGpRdWVyeS5mbi5leHRlbmQoe1xcbiAgICBvZmZzZXQ6IGZ1bmN0aW9uIG9mZnNldChvcHRpb25zKSB7XFxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcXG4gICAgICAgIHJldHVybiBvcHRpb25zID09PSB1bmRlZmluZWQgPyB0aGlzIDogdGhpcy5lYWNoKGZ1bmN0aW9uIChpKSB7XFxuICAgICAgICAgIGpRdWVyeS5vZmZzZXQuc2V0T2Zmc2V0KHRoaXMsIG9wdGlvbnMsIGkpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBkb2NFbGVtLFxcbiAgICAgICAgICB3aW4sXFxuICAgICAgICAgIGVsZW0gPSB0aGlzWzBdLFxcbiAgICAgICAgICBib3ggPSB7XFxuICAgICAgICB0b3A6IDAsXFxuICAgICAgICBsZWZ0OiAwXFxuICAgICAgfSxcXG4gICAgICAgICAgZG9jID0gZWxlbSAmJiBlbGVtLm93bmVyRG9jdW1lbnQ7XFxuXFxuICAgICAgaWYgKCFkb2MpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgZG9jRWxlbSA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7IC8vIE1ha2Ugc3VyZSBpdCdzIG5vdCBhIGRpc2Nvbm5lY3RlZCBET00gbm9kZVxcblxcbiAgICAgIGlmICghalF1ZXJ5LmNvbnRhaW5zKGRvY0VsZW0sIGVsZW0pKSB7XFxuICAgICAgICByZXR1cm4gYm94O1xcbiAgICAgIH0gLy8gU3VwcG9ydDogQmxhY2tCZXJyeSA1LCBpT1MgMyAob3JpZ2luYWwgaVBob25lKVxcbiAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgZ0JDUiwganVzdCB1c2UgMCwwIHJhdGhlciB0aGFuIGVycm9yXFxuXFxuXFxuICAgICAgaWYgKF90eXBlb2YoZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QpICE9PSBzdHJ1bmRlZmluZWQpIHtcXG4gICAgICAgIGJveCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XFxuICAgICAgfVxcblxcbiAgICAgIHdpbiA9IGdldFdpbmRvdyhkb2MpO1xcbiAgICAgIHJldHVybiB7XFxuICAgICAgICB0b3A6IGJveC50b3AgKyB3aW4ucGFnZVlPZmZzZXQgLSBkb2NFbGVtLmNsaWVudFRvcCxcXG4gICAgICAgIGxlZnQ6IGJveC5sZWZ0ICsgd2luLnBhZ2VYT2Zmc2V0IC0gZG9jRWxlbS5jbGllbnRMZWZ0XFxuICAgICAgfTtcXG4gICAgfSxcXG4gICAgcG9zaXRpb246IGZ1bmN0aW9uIHBvc2l0aW9uKCkge1xcbiAgICAgIGlmICghdGhpc1swXSkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgb2Zmc2V0UGFyZW50LFxcbiAgICAgICAgICBvZmZzZXQsXFxuICAgICAgICAgIGVsZW0gPSB0aGlzWzBdLFxcbiAgICAgICAgICBwYXJlbnRPZmZzZXQgPSB7XFxuICAgICAgICB0b3A6IDAsXFxuICAgICAgICBsZWZ0OiAwXFxuICAgICAgfTsgLy8gRml4ZWQgZWxlbWVudHMgYXJlIG9mZnNldCBmcm9tIHdpbmRvdyAocGFyZW50T2Zmc2V0ID0ge3RvcDowLCBsZWZ0OiAwfSwgYmVjYXVzZSBpdCBpcyBpdHMgb25seSBvZmZzZXQgcGFyZW50XFxuXFxuICAgICAgaWYgKGpRdWVyeS5jc3MoZWxlbSwgXFxcInBvc2l0aW9uXFxcIikgPT09IFxcXCJmaXhlZFxcXCIpIHtcXG4gICAgICAgIC8vIEFzc3VtZSBnZXRCb3VuZGluZ0NsaWVudFJlY3QgaXMgdGhlcmUgd2hlbiBjb21wdXRlZCBwb3NpdGlvbiBpcyBmaXhlZFxcbiAgICAgICAgb2Zmc2V0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgLy8gR2V0ICpyZWFsKiBvZmZzZXRQYXJlbnRcXG4gICAgICAgIG9mZnNldFBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50KCk7IC8vIEdldCBjb3JyZWN0IG9mZnNldHNcXG5cXG4gICAgICAgIG9mZnNldCA9IHRoaXMub2Zmc2V0KCk7XFxuXFxuICAgICAgICBpZiAoIWpRdWVyeS5ub2RlTmFtZShvZmZzZXRQYXJlbnRbMF0sIFxcXCJodG1sXFxcIikpIHtcXG4gICAgICAgICAgcGFyZW50T2Zmc2V0ID0gb2Zmc2V0UGFyZW50Lm9mZnNldCgpO1xcbiAgICAgICAgfSAvLyBBZGQgb2Zmc2V0UGFyZW50IGJvcmRlcnNcXG5cXG5cXG4gICAgICAgIHBhcmVudE9mZnNldC50b3AgKz0galF1ZXJ5LmNzcyhvZmZzZXRQYXJlbnRbMF0sIFxcXCJib3JkZXJUb3BXaWR0aFxcXCIsIHRydWUpO1xcbiAgICAgICAgcGFyZW50T2Zmc2V0LmxlZnQgKz0galF1ZXJ5LmNzcyhvZmZzZXRQYXJlbnRbMF0sIFxcXCJib3JkZXJMZWZ0V2lkdGhcXFwiLCB0cnVlKTtcXG4gICAgICB9IC8vIFN1YnRyYWN0IHBhcmVudCBvZmZzZXRzIGFuZCBlbGVtZW50IG1hcmdpbnNcXG5cXG5cXG4gICAgICByZXR1cm4ge1xcbiAgICAgICAgdG9wOiBvZmZzZXQudG9wIC0gcGFyZW50T2Zmc2V0LnRvcCAtIGpRdWVyeS5jc3MoZWxlbSwgXFxcIm1hcmdpblRvcFxcXCIsIHRydWUpLFxcbiAgICAgICAgbGVmdDogb2Zmc2V0LmxlZnQgLSBwYXJlbnRPZmZzZXQubGVmdCAtIGpRdWVyeS5jc3MoZWxlbSwgXFxcIm1hcmdpbkxlZnRcXFwiLCB0cnVlKVxcbiAgICAgIH07XFxuICAgIH0sXFxuICAgIG9mZnNldFBhcmVudDogZnVuY3Rpb24gb2Zmc2V0UGFyZW50KCkge1xcbiAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgb2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQgfHwgZG9jRWxlbTtcXG5cXG4gICAgICAgIHdoaWxlIChvZmZzZXRQYXJlbnQgJiYgIWpRdWVyeS5ub2RlTmFtZShvZmZzZXRQYXJlbnQsIFxcXCJodG1sXFxcIikgJiYgalF1ZXJ5LmNzcyhvZmZzZXRQYXJlbnQsIFxcXCJwb3NpdGlvblxcXCIpID09PSBcXFwic3RhdGljXFxcIikge1xcbiAgICAgICAgICBvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0UGFyZW50O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIG9mZnNldFBhcmVudCB8fCBkb2NFbGVtO1xcbiAgICAgIH0pO1xcbiAgICB9XFxuICB9KTsgLy8gQ3JlYXRlIHNjcm9sbExlZnQgYW5kIHNjcm9sbFRvcCBtZXRob2RzXFxuXFxuICBqUXVlcnkuZWFjaCh7XFxuICAgIHNjcm9sbExlZnQ6IFxcXCJwYWdlWE9mZnNldFxcXCIsXFxuICAgIHNjcm9sbFRvcDogXFxcInBhZ2VZT2Zmc2V0XFxcIlxcbiAgfSwgZnVuY3Rpb24gKG1ldGhvZCwgcHJvcCkge1xcbiAgICB2YXIgdG9wID0gXFxcInBhZ2VZT2Zmc2V0XFxcIiA9PT0gcHJvcDtcXG5cXG4gICAgalF1ZXJ5LmZuW21ldGhvZF0gPSBmdW5jdGlvbiAodmFsKSB7XFxuICAgICAgcmV0dXJuIGFjY2Vzcyh0aGlzLCBmdW5jdGlvbiAoZWxlbSwgbWV0aG9kLCB2YWwpIHtcXG4gICAgICAgIHZhciB3aW4gPSBnZXRXaW5kb3coZWxlbSk7XFxuXFxuICAgICAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcXG4gICAgICAgICAgcmV0dXJuIHdpbiA/IHdpbltwcm9wXSA6IGVsZW1bbWV0aG9kXTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICh3aW4pIHtcXG4gICAgICAgICAgd2luLnNjcm9sbFRvKCF0b3AgPyB2YWwgOiB3aW5kb3cucGFnZVhPZmZzZXQsIHRvcCA/IHZhbCA6IHdpbmRvdy5wYWdlWU9mZnNldCk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBlbGVtW21ldGhvZF0gPSB2YWw7XFxuICAgICAgICB9XFxuICAgICAgfSwgbWV0aG9kLCB2YWwsIGFyZ3VtZW50cy5sZW5ndGgsIG51bGwpO1xcbiAgICB9O1xcbiAgfSk7IC8vIFN1cHBvcnQ6IFNhZmFyaTw3KywgQ2hyb21lPDM3K1xcbiAgLy8gQWRkIHRoZSB0b3AvbGVmdCBjc3NIb29rcyB1c2luZyBqUXVlcnkuZm4ucG9zaXRpb25cXG4gIC8vIFdlYmtpdCBidWc6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yOTA4NFxcbiAgLy8gQmxpbmsgYnVnOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MjI5MjgwXFxuICAvLyBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgcGVyY2VudCB3aGVuIHNwZWNpZmllZCBmb3IgdG9wL2xlZnQvYm90dG9tL3JpZ2h0O1xcbiAgLy8gcmF0aGVyIHRoYW4gbWFrZSB0aGUgY3NzIG1vZHVsZSBkZXBlbmQgb24gdGhlIG9mZnNldCBtb2R1bGUsIGp1c3QgY2hlY2sgZm9yIGl0IGhlcmVcXG5cXG4gIGpRdWVyeS5lYWNoKFtcXFwidG9wXFxcIiwgXFxcImxlZnRcXFwiXSwgZnVuY3Rpb24gKGksIHByb3ApIHtcXG4gICAgalF1ZXJ5LmNzc0hvb2tzW3Byb3BdID0gYWRkR2V0SG9va0lmKHN1cHBvcnQucGl4ZWxQb3NpdGlvbiwgZnVuY3Rpb24gKGVsZW0sIGNvbXB1dGVkKSB7XFxuICAgICAgaWYgKGNvbXB1dGVkKSB7XFxuICAgICAgICBjb21wdXRlZCA9IGN1ckNTUyhlbGVtLCBwcm9wKTsgLy8gSWYgY3VyQ1NTIHJldHVybnMgcGVyY2VudGFnZSwgZmFsbGJhY2sgdG8gb2Zmc2V0XFxuXFxuICAgICAgICByZXR1cm4gcm51bW5vbnB4LnRlc3QoY29tcHV0ZWQpID8galF1ZXJ5KGVsZW0pLnBvc2l0aW9uKClbcHJvcF0gKyBcXFwicHhcXFwiIDogY29tcHV0ZWQ7XFxuICAgICAgfVxcbiAgICB9KTtcXG4gIH0pOyAvLyBDcmVhdGUgaW5uZXJIZWlnaHQsIGlubmVyV2lkdGgsIGhlaWdodCwgd2lkdGgsIG91dGVySGVpZ2h0IGFuZCBvdXRlcldpZHRoIG1ldGhvZHNcXG5cXG4gIGpRdWVyeS5lYWNoKHtcXG4gICAgSGVpZ2h0OiBcXFwiaGVpZ2h0XFxcIixcXG4gICAgV2lkdGg6IFxcXCJ3aWR0aFxcXCJcXG4gIH0sIGZ1bmN0aW9uIChuYW1lLCB0eXBlKSB7XFxuICAgIGpRdWVyeS5lYWNoKHtcXG4gICAgICBwYWRkaW5nOiBcXFwiaW5uZXJcXFwiICsgbmFtZSxcXG4gICAgICBjb250ZW50OiB0eXBlLFxcbiAgICAgIFxcXCJcXFwiOiBcXFwib3V0ZXJcXFwiICsgbmFtZVxcbiAgICB9LCBmdW5jdGlvbiAoZGVmYXVsdEV4dHJhLCBmdW5jTmFtZSkge1xcbiAgICAgIC8vIE1hcmdpbiBpcyBvbmx5IGZvciBvdXRlckhlaWdodCwgb3V0ZXJXaWR0aFxcbiAgICAgIGpRdWVyeS5mbltmdW5jTmFtZV0gPSBmdW5jdGlvbiAobWFyZ2luLCB2YWx1ZSkge1xcbiAgICAgICAgdmFyIGNoYWluYWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggJiYgKGRlZmF1bHRFeHRyYSB8fCB0eXBlb2YgbWFyZ2luICE9PSBcXFwiYm9vbGVhblxcXCIpLFxcbiAgICAgICAgICAgIGV4dHJhID0gZGVmYXVsdEV4dHJhIHx8IChtYXJnaW4gPT09IHRydWUgfHwgdmFsdWUgPT09IHRydWUgPyBcXFwibWFyZ2luXFxcIiA6IFxcXCJib3JkZXJcXFwiKTtcXG4gICAgICAgIHJldHVybiBhY2Nlc3ModGhpcywgZnVuY3Rpb24gKGVsZW0sIHR5cGUsIHZhbHVlKSB7XFxuICAgICAgICAgIHZhciBkb2M7XFxuXFxuICAgICAgICAgIGlmIChqUXVlcnkuaXNXaW5kb3coZWxlbSkpIHtcXG4gICAgICAgICAgICAvLyBBcyBvZiA1LzgvMjAxMiB0aGlzIHdpbGwgeWllbGQgaW5jb3JyZWN0IHJlc3VsdHMgZm9yIE1vYmlsZSBTYWZhcmksIGJ1dCB0aGVyZVxcbiAgICAgICAgICAgIC8vIGlzbid0IGEgd2hvbGUgbG90IHdlIGNhbiBkby4gU2VlIHB1bGwgcmVxdWVzdCBhdCB0aGlzIFVSTCBmb3IgZGlzY3Vzc2lvbjpcXG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9wdWxsLzc2NFxcbiAgICAgICAgICAgIHJldHVybiBlbGVtLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFtcXFwiY2xpZW50XFxcIiArIG5hbWVdO1xcbiAgICAgICAgICB9IC8vIEdldCBkb2N1bWVudCB3aWR0aCBvciBoZWlnaHRcXG5cXG5cXG4gICAgICAgICAgaWYgKGVsZW0ubm9kZVR5cGUgPT09IDkpIHtcXG4gICAgICAgICAgICBkb2MgPSBlbGVtLmRvY3VtZW50RWxlbWVudDsgLy8gRWl0aGVyIHNjcm9sbFtXaWR0aC9IZWlnaHRdIG9yIG9mZnNldFtXaWR0aC9IZWlnaHRdIG9yIGNsaWVudFtXaWR0aC9IZWlnaHRdLFxcbiAgICAgICAgICAgIC8vIHdoaWNoZXZlciBpcyBncmVhdGVzdFxcblxcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1heChlbGVtLmJvZHlbXFxcInNjcm9sbFxcXCIgKyBuYW1lXSwgZG9jW1xcXCJzY3JvbGxcXFwiICsgbmFtZV0sIGVsZW0uYm9keVtcXFwib2Zmc2V0XFxcIiArIG5hbWVdLCBkb2NbXFxcIm9mZnNldFxcXCIgKyBuYW1lXSwgZG9jW1xcXCJjbGllbnRcXFwiICsgbmFtZV0pO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gLy8gR2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudCwgcmVxdWVzdGluZyBidXQgbm90IGZvcmNpbmcgcGFyc2VGbG9hdFxcbiAgICAgICAgICBqUXVlcnkuY3NzKGVsZW0sIHR5cGUsIGV4dHJhKSA6IC8vIFNldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnRcXG4gICAgICAgICAgalF1ZXJ5LnN0eWxlKGVsZW0sIHR5cGUsIHZhbHVlLCBleHRyYSk7XFxuICAgICAgICB9LCB0eXBlLCBjaGFpbmFibGUgPyBtYXJnaW4gOiB1bmRlZmluZWQsIGNoYWluYWJsZSwgbnVsbCk7XFxuICAgICAgfTtcXG4gICAgfSk7XFxuICB9KTsgLy8gVGhlIG51bWJlciBvZiBlbGVtZW50cyBjb250YWluZWQgaW4gdGhlIG1hdGNoZWQgZWxlbWVudCBzZXRcXG5cXG4gIGpRdWVyeS5mbi5zaXplID0gZnVuY3Rpb24gKCkge1xcbiAgICByZXR1cm4gdGhpcy5sZW5ndGg7XFxuICB9O1xcblxcbiAgalF1ZXJ5LmZuLmFuZFNlbGYgPSBqUXVlcnkuZm4uYWRkQmFjazsgLy8gUmVnaXN0ZXIgYXMgYSBuYW1lZCBBTUQgbW9kdWxlLCBzaW5jZSBqUXVlcnkgY2FuIGJlIGNvbmNhdGVuYXRlZCB3aXRoIG90aGVyXFxuICAvLyBmaWxlcyB0aGF0IG1heSB1c2UgZGVmaW5lLCBidXQgbm90IHZpYSBhIHByb3BlciBjb25jYXRlbmF0aW9uIHNjcmlwdCB0aGF0XFxuICAvLyB1bmRlcnN0YW5kcyBhbm9ueW1vdXMgQU1EIG1vZHVsZXMuIEEgbmFtZWQgQU1EIGlzIHNhZmVzdCBhbmQgbW9zdCByb2J1c3RcXG4gIC8vIHdheSB0byByZWdpc3Rlci4gTG93ZXJjYXNlIGpxdWVyeSBpcyB1c2VkIGJlY2F1c2UgQU1EIG1vZHVsZSBuYW1lcyBhcmVcXG4gIC8vIGRlcml2ZWQgZnJvbSBmaWxlIG5hbWVzLCBhbmQgalF1ZXJ5IGlzIG5vcm1hbGx5IGRlbGl2ZXJlZCBpbiBhIGxvd2VyY2FzZVxcbiAgLy8gZmlsZSBuYW1lLiBEbyB0aGlzIGFmdGVyIGNyZWF0aW5nIHRoZSBnbG9iYWwgc28gdGhhdCBpZiBhbiBBTUQgbW9kdWxlIHdhbnRzXFxuICAvLyB0byBjYWxsIG5vQ29uZmxpY3QgdG8gaGlkZSB0aGlzIHZlcnNpb24gb2YgalF1ZXJ5LCBpdCB3aWxsIHdvcmsuXFxuICAvLyBOb3RlIHRoYXQgZm9yIG1heGltdW0gcG9ydGFiaWxpdHksIGxpYnJhcmllcyB0aGF0IGFyZSBub3QgalF1ZXJ5IHNob3VsZFxcbiAgLy8gZGVjbGFyZSB0aGVtc2VsdmVzIGFzIGFub255bW91cyBtb2R1bGVzLCBhbmQgYXZvaWQgc2V0dGluZyBhIGdsb2JhbCBpZiBhblxcbiAgLy8gQU1EIGxvYWRlciBpcyBwcmVzZW50LiBqUXVlcnkgaXMgYSBzcGVjaWFsIGNhc2UuIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWVcXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcmJ1cmtlL3JlcXVpcmVqcy93aWtpL1VwZGF0aW5nLWV4aXN0aW5nLWxpYnJhcmllcyN3aWtpLWFub25cXG5cXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIGRlZmluZS5hbWQpIHtcXG4gICAgZGVmaW5lKFxcXCJqcXVlcnlcXFwiLCBbXSwgZnVuY3Rpb24gKCkge1xcbiAgICAgIHJldHVybiBqUXVlcnk7XFxuICAgIH0pO1xcbiAgfVxcblxcbiAgdmFyIC8vIE1hcCBvdmVyIGpRdWVyeSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxcbiAgX2pRdWVyeSA9IHdpbmRvdy5qUXVlcnksXFxuICAgICAgLy8gTWFwIG92ZXIgdGhlICQgaW4gY2FzZSBvZiBvdmVyd3JpdGVcXG4gIF8kID0gd2luZG93LiQ7XFxuXFxuICBqUXVlcnkubm9Db25mbGljdCA9IGZ1bmN0aW9uIChkZWVwKSB7XFxuICAgIGlmICh3aW5kb3cuJCA9PT0galF1ZXJ5KSB7XFxuICAgICAgd2luZG93LiQgPSBfJDtcXG4gICAgfVxcblxcbiAgICBpZiAoZGVlcCAmJiB3aW5kb3cualF1ZXJ5ID09PSBqUXVlcnkpIHtcXG4gICAgICB3aW5kb3cualF1ZXJ5ID0gX2pRdWVyeTtcXG4gICAgfVxcblxcbiAgICByZXR1cm4galF1ZXJ5O1xcbiAgfTsgLy8gRXhwb3NlIGpRdWVyeSBhbmQgJCBpZGVudGlmaWVycywgZXZlbiBpbiBBTURcXG4gIC8vICgjNzEwMiNjb21tZW50OjEwLCBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9wdWxsLzU1NylcXG4gIC8vIGFuZCBDb21tb25KUyBmb3IgYnJvd3NlciBlbXVsYXRvcnMgKCMxMzU2NilcXG5cXG5cXG4gIGlmIChfdHlwZW9mKG5vR2xvYmFsKSA9PT0gc3RydW5kZWZpbmVkKSB7XFxuICAgIHdpbmRvdy5qUXVlcnkgPSB3aW5kb3cuJCA9IGpRdWVyeTtcXG4gIH1cXG5cXG4gIHJldHVybiBqUXVlcnk7XFxufSk7XCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXFxcInN5bWJvbFxcXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFxcXCJzeW1ib2xcXFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XFxuXFxuLyohXFxuICogalF1ZXJ5IEZvcm0gUGx1Z2luXFxuICogdmVyc2lvbjogMy41MS4wLTIwMTQuMDYuMjBcXG4gKiBSZXF1aXJlcyBqUXVlcnkgdjEuNSBvciBsYXRlclxcbiAqIENvcHlyaWdodCAoYykgMjAxNCBNLiBBbHN1cFxcbiAqIEV4YW1wbGVzIGFuZCBkb2N1bWVudGF0aW9uIGF0OiBodHRwOi8vbWFsc3VwLmNvbS9qcXVlcnkvZm9ybS9cXG4gKiBQcm9qZWN0IHJlcG9zaXRvcnk6IGh0dHBzOi8vZ2l0aHViLmNvbS9tYWxzdXAvZm9ybVxcbiAqIER1YWwgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBhbmQgR1BMIGxpY2Vuc2VzLlxcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYWxzdXAvZm9ybSNjb3B5cmlnaHQtYW5kLWxpY2Vuc2VcXG4gKi9cXG5cXG4vKmdsb2JhbCBBY3RpdmVYT2JqZWN0ICovXFxuLy8gQU1EIHN1cHBvcnRcXG4oZnVuY3Rpb24gKGZhY3RvcnkpIHtcXG4gIFxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcXG4gICAgLy8gdXNpbmcgQU1EOyByZWdpc3RlciBhcyBhbm9uIG1vZHVsZVxcbiAgICBkZWZpbmUoWydqcXVlcnknXSwgZmFjdG9yeSk7XFxuICB9IGVsc2Uge1xcbiAgICAvLyBubyBBTUQ7IGludm9rZSBkaXJlY3RseVxcbiAgICBmYWN0b3J5KHR5cGVvZiBqUXVlcnkgIT0gJ3VuZGVmaW5lZCcgPyBqUXVlcnkgOiB3aW5kb3cuWmVwdG8pO1xcbiAgfVxcbn0pKGZ1bmN0aW9uICgkKSB7XFxuICBcXFwidXNlIHN0cmljdFxcXCI7XFxuICAvKlxcbiAgICAgIFVzYWdlIE5vdGU6XFxuICAgICAgLS0tLS0tLS0tLS1cXG4gICAgICBEbyBub3QgdXNlIGJvdGggYWpheFN1Ym1pdCBhbmQgYWpheEZvcm0gb24gdGhlIHNhbWUgZm9ybS4gIFRoZXNlXFxuICAgICAgZnVuY3Rpb25zIGFyZSBtdXR1YWxseSBleGNsdXNpdmUuICBVc2UgYWpheFN1Ym1pdCBpZiB5b3Ugd2FudFxcbiAgICAgIHRvIGJpbmQgeW91ciBvd24gc3VibWl0IGhhbmRsZXIgdG8gdGhlIGZvcm0uICBGb3IgZXhhbXBsZSxcXG4gIFxcbiAgICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xcbiAgICAgICAgICAkKCcjbXlGb3JtJykub24oJ3N1Ym1pdCcsIGZ1bmN0aW9uKGUpIHtcXG4gICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTsgLy8gPC0tIGltcG9ydGFudFxcbiAgICAgICAgICAgICAgJCh0aGlzKS5hamF4U3VibWl0KHtcXG4gICAgICAgICAgICAgICAgICB0YXJnZXQ6ICcjb3V0cHV0J1xcbiAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgIH0pO1xcbiAgICAgIH0pO1xcbiAgXFxuICAgICAgVXNlIGFqYXhGb3JtIHdoZW4geW91IHdhbnQgdGhlIHBsdWdpbiB0byBtYW5hZ2UgYWxsIHRoZSBldmVudCBiaW5kaW5nXFxuICAgICAgZm9yIHlvdS4gIEZvciBleGFtcGxlLFxcbiAgXFxuICAgICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XFxuICAgICAgICAgICQoJyNteUZvcm0nKS5hamF4Rm9ybSh7XFxuICAgICAgICAgICAgICB0YXJnZXQ6ICcjb3V0cHV0J1xcbiAgICAgICAgICB9KTtcXG4gICAgICB9KTtcXG4gIFxcbiAgICAgIFlvdSBjYW4gYWxzbyB1c2UgYWpheEZvcm0gd2l0aCBkZWxlZ2F0aW9uIChyZXF1aXJlcyBqUXVlcnkgdjEuNyspLCBzbyB0aGVcXG4gICAgICBmb3JtIGRvZXMgbm90IGhhdmUgdG8gZXhpc3Qgd2hlbiB5b3UgaW52b2tlIGFqYXhGb3JtOlxcbiAgXFxuICAgICAgJCgnI215Rm9ybScpLmFqYXhGb3JtKHtcXG4gICAgICAgICAgZGVsZWdhdGlvbjogdHJ1ZSxcXG4gICAgICAgICAgdGFyZ2V0OiAnI291dHB1dCdcXG4gICAgICB9KTtcXG4gIFxcbiAgICAgIFdoZW4gdXNpbmcgYWpheEZvcm0sIHRoZSBhamF4U3VibWl0IGZ1bmN0aW9uIHdpbGwgYmUgaW52b2tlZCBmb3IgeW91XFxuICAgICAgYXQgdGhlIGFwcHJvcHJpYXRlIHRpbWUuXFxuICAqL1xcblxcbiAgLyoqXFxuICAgKiBGZWF0dXJlIGRldGVjdGlvblxcbiAgICovXFxuXFxuICB2YXIgZmVhdHVyZSA9IHt9O1xcbiAgZmVhdHVyZS5maWxlYXBpID0gJChcXFwiPGlucHV0IHR5cGU9J2ZpbGUnLz5cXFwiKS5nZXQoMCkuZmlsZXMgIT09IHVuZGVmaW5lZDtcXG4gIGZlYXR1cmUuZm9ybWRhdGEgPSB3aW5kb3cuRm9ybURhdGEgIT09IHVuZGVmaW5lZDtcXG4gIHZhciBoYXNQcm9wID0gISEkLmZuLnByb3A7IC8vIGF0dHIyIHVzZXMgcHJvcCB3aGVuIGl0IGNhbiBidXQgY2hlY2tzIHRoZSByZXR1cm4gdHlwZSBmb3JcXG4gIC8vIGFuIGV4cGVjdGVkIHN0cmluZy4gIHRoaXMgYWNjb3VudHMgZm9yIHRoZSBjYXNlIHdoZXJlIGEgZm9ybSBcXG4gIC8vIGNvbnRhaW5zIGlucHV0cyB3aXRoIG5hbWVzIGxpa2UgXFxcImFjdGlvblxcXCIgb3IgXFxcIm1ldGhvZFxcXCI7IGluIHRob3NlXFxuICAvLyBjYXNlcyBcXFwicHJvcFxcXCIgcmV0dXJucyB0aGUgZWxlbWVudFxcblxcbiAgJC5mbi5hdHRyMiA9IGZ1bmN0aW9uICgpIHtcXG4gICAgaWYgKCFoYXNQcm9wKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuYXR0ci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgICB9XFxuXFxuICAgIHZhciB2YWwgPSB0aGlzLnByb3AuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG5cXG4gICAgaWYgKHZhbCAmJiB2YWwuanF1ZXJ5IHx8IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XFxuICAgICAgcmV0dXJuIHZhbDtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gdGhpcy5hdHRyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICB9O1xcbiAgLyoqXFxuICAgKiBhamF4U3VibWl0KCkgcHJvdmlkZXMgYSBtZWNoYW5pc20gZm9yIGltbWVkaWF0ZWx5IHN1Ym1pdHRpbmdcXG4gICAqIGFuIEhUTUwgZm9ybSB1c2luZyBBSkFYLlxcbiAgICovXFxuXFxuXFxuICAkLmZuLmFqYXhTdWJtaXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xcbiAgICAvKmpzaGludCBzY3JpcHR1cmw6dHJ1ZSAqL1xcbiAgICAvLyBmYXN0IGZhaWwgaWYgbm90aGluZyBzZWxlY3RlZCAoaHR0cDovL2Rldi5qcXVlcnkuY29tL3RpY2tldC8yNzUyKVxcbiAgICBpZiAoIXRoaXMubGVuZ3RoKSB7XFxuICAgICAgbG9nKCdhamF4U3VibWl0OiBza2lwcGluZyBzdWJtaXQgcHJvY2VzcyAtIG5vIGVsZW1lbnQgc2VsZWN0ZWQnKTtcXG4gICAgICByZXR1cm4gdGhpcztcXG4gICAgfVxcblxcbiAgICB2YXIgbWV0aG9kLFxcbiAgICAgICAgYWN0aW9uLFxcbiAgICAgICAgdXJsLFxcbiAgICAgICAgJGZvcm0gPSB0aGlzO1xcblxcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgIG9wdGlvbnMgPSB7XFxuICAgICAgICBzdWNjZXNzOiBvcHRpb25zXFxuICAgICAgfTtcXG4gICAgfSBlbHNlIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcXG4gICAgICBvcHRpb25zID0ge307XFxuICAgIH1cXG5cXG4gICAgbWV0aG9kID0gb3B0aW9ucy50eXBlIHx8IHRoaXMuYXR0cjIoJ21ldGhvZCcpO1xcbiAgICBhY3Rpb24gPSBvcHRpb25zLnVybCB8fCB0aGlzLmF0dHIyKCdhY3Rpb24nKTtcXG4gICAgdXJsID0gdHlwZW9mIGFjdGlvbiA9PT0gJ3N0cmluZycgPyAkLnRyaW0oYWN0aW9uKSA6ICcnO1xcbiAgICB1cmwgPSB1cmwgfHwgd2luZG93LmxvY2F0aW9uLmhyZWYgfHwgJyc7XFxuXFxuICAgIGlmICh1cmwpIHtcXG4gICAgICAvLyBjbGVhbiB1cmwgKGRvbid0IGluY2x1ZGUgaGFzaCB2YXVlKVxcbiAgICAgIHVybCA9ICh1cmwubWF0Y2goL14oW14jXSspLykgfHwgW10pWzFdO1xcbiAgICB9XFxuXFxuICAgIG9wdGlvbnMgPSAkLmV4dGVuZCh0cnVlLCB7XFxuICAgICAgdXJsOiB1cmwsXFxuICAgICAgc3VjY2VzczogJC5hamF4U2V0dGluZ3Muc3VjY2VzcyxcXG4gICAgICB0eXBlOiBtZXRob2QgfHwgJC5hamF4U2V0dGluZ3MudHlwZSxcXG4gICAgICBpZnJhbWVTcmM6IC9eaHR0cHMvaS50ZXN0KHdpbmRvdy5sb2NhdGlvbi5ocmVmIHx8ICcnKSA/ICdqYXZhc2NyaXB0OmZhbHNlJyA6ICdhYm91dDpibGFuaydcXG4gICAgfSwgb3B0aW9ucyk7IC8vIGhvb2sgZm9yIG1hbmlwdWxhdGluZyB0aGUgZm9ybSBkYXRhIGJlZm9yZSBpdCBpcyBleHRyYWN0ZWQ7XFxuICAgIC8vIGNvbnZlbmllbnQgZm9yIHVzZSB3aXRoIHJpY2ggZWRpdG9ycyBsaWtlIHRpbnlNQ0Ugb3IgRkNLRWRpdG9yXFxuXFxuICAgIHZhciB2ZXRvID0ge307XFxuICAgIHRoaXMudHJpZ2dlcignZm9ybS1wcmUtc2VyaWFsaXplJywgW3RoaXMsIG9wdGlvbnMsIHZldG9dKTtcXG5cXG4gICAgaWYgKHZldG8udmV0bykge1xcbiAgICAgIGxvZygnYWpheFN1Ym1pdDogc3VibWl0IHZldG9lZCB2aWEgZm9ybS1wcmUtc2VyaWFsaXplIHRyaWdnZXInKTtcXG4gICAgICByZXR1cm4gdGhpcztcXG4gICAgfSAvLyBwcm92aWRlIG9wcG9ydHVuaXR5IHRvIGFsdGVyIGZvcm0gZGF0YSBiZWZvcmUgaXQgaXMgc2VyaWFsaXplZFxcblxcblxcbiAgICBpZiAob3B0aW9ucy5iZWZvcmVTZXJpYWxpemUgJiYgb3B0aW9ucy5iZWZvcmVTZXJpYWxpemUodGhpcywgb3B0aW9ucykgPT09IGZhbHNlKSB7XFxuICAgICAgbG9nKCdhamF4U3VibWl0OiBzdWJtaXQgYWJvcnRlZCB2aWEgYmVmb3JlU2VyaWFsaXplIGNhbGxiYWNrJyk7XFxuICAgICAgcmV0dXJuIHRoaXM7XFxuICAgIH1cXG5cXG4gICAgdmFyIHRyYWRpdGlvbmFsID0gb3B0aW9ucy50cmFkaXRpb25hbDtcXG5cXG4gICAgaWYgKHRyYWRpdGlvbmFsID09PSB1bmRlZmluZWQpIHtcXG4gICAgICB0cmFkaXRpb25hbCA9ICQuYWpheFNldHRpbmdzLnRyYWRpdGlvbmFsO1xcbiAgICB9XFxuXFxuICAgIHZhciBlbGVtZW50cyA9IFtdO1xcbiAgICB2YXIgcXgsXFxuICAgICAgICBhID0gdGhpcy5mb3JtVG9BcnJheShvcHRpb25zLnNlbWFudGljLCBlbGVtZW50cyk7XFxuXFxuICAgIGlmIChvcHRpb25zLmRhdGEpIHtcXG4gICAgICBvcHRpb25zLmV4dHJhRGF0YSA9IG9wdGlvbnMuZGF0YTtcXG4gICAgICBxeCA9ICQucGFyYW0ob3B0aW9ucy5kYXRhLCB0cmFkaXRpb25hbCk7XFxuICAgIH0gLy8gZ2l2ZSBwcmUtc3VibWl0IGNhbGxiYWNrIGFuIG9wcG9ydHVuaXR5IHRvIGFib3J0IHRoZSBzdWJtaXRcXG5cXG5cXG4gICAgaWYgKG9wdGlvbnMuYmVmb3JlU3VibWl0ICYmIG9wdGlvbnMuYmVmb3JlU3VibWl0KGEsIHRoaXMsIG9wdGlvbnMpID09PSBmYWxzZSkge1xcbiAgICAgIGxvZygnYWpheFN1Ym1pdDogc3VibWl0IGFib3J0ZWQgdmlhIGJlZm9yZVN1Ym1pdCBjYWxsYmFjaycpO1xcbiAgICAgIHJldHVybiB0aGlzO1xcbiAgICB9IC8vIGZpcmUgdmV0b2FibGUgJ3ZhbGlkYXRlJyBldmVudFxcblxcblxcbiAgICB0aGlzLnRyaWdnZXIoJ2Zvcm0tc3VibWl0LXZhbGlkYXRlJywgW2EsIHRoaXMsIG9wdGlvbnMsIHZldG9dKTtcXG5cXG4gICAgaWYgKHZldG8udmV0bykge1xcbiAgICAgIGxvZygnYWpheFN1Ym1pdDogc3VibWl0IHZldG9lZCB2aWEgZm9ybS1zdWJtaXQtdmFsaWRhdGUgdHJpZ2dlcicpO1xcbiAgICAgIHJldHVybiB0aGlzO1xcbiAgICB9XFxuXFxuICAgIHZhciBxID0gJC5wYXJhbShhLCB0cmFkaXRpb25hbCk7XFxuXFxuICAgIGlmIChxeCkge1xcbiAgICAgIHEgPSBxID8gcSArICcmJyArIHF4IDogcXg7XFxuICAgIH1cXG5cXG4gICAgaWYgKG9wdGlvbnMudHlwZS50b1VwcGVyQ2FzZSgpID09ICdHRVQnKSB7XFxuICAgICAgb3B0aW9ucy51cmwgKz0gKG9wdGlvbnMudXJsLmluZGV4T2YoJz8nKSA+PSAwID8gJyYnIDogJz8nKSArIHE7XFxuICAgICAgb3B0aW9ucy5kYXRhID0gbnVsbDsgLy8gZGF0YSBpcyBudWxsIGZvciAnZ2V0J1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIG9wdGlvbnMuZGF0YSA9IHE7IC8vIGRhdGEgaXMgdGhlIHF1ZXJ5IHN0cmluZyBmb3IgJ3Bvc3QnXFxuICAgIH1cXG5cXG4gICAgdmFyIGNhbGxiYWNrcyA9IFtdO1xcblxcbiAgICBpZiAob3B0aW9ucy5yZXNldEZvcm0pIHtcXG4gICAgICBjYWxsYmFja3MucHVzaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAkZm9ybS5yZXNldEZvcm0oKTtcXG4gICAgICB9KTtcXG4gICAgfVxcblxcbiAgICBpZiAob3B0aW9ucy5jbGVhckZvcm0pIHtcXG4gICAgICBjYWxsYmFja3MucHVzaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAkZm9ybS5jbGVhckZvcm0ob3B0aW9ucy5pbmNsdWRlSGlkZGVuKTtcXG4gICAgICB9KTtcXG4gICAgfSAvLyBwZXJmb3JtIGEgbG9hZCBvbiB0aGUgdGFyZ2V0IG9ubHkgaWYgZGF0YVR5cGUgaXMgbm90IHByb3ZpZGVkXFxuXFxuXFxuICAgIGlmICghb3B0aW9ucy5kYXRhVHlwZSAmJiBvcHRpb25zLnRhcmdldCkge1xcbiAgICAgIHZhciBvbGRTdWNjZXNzID0gb3B0aW9ucy5zdWNjZXNzIHx8IGZ1bmN0aW9uICgpIHt9O1xcblxcbiAgICAgIGNhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uIChkYXRhKSB7XFxuICAgICAgICB2YXIgZm4gPSBvcHRpb25zLnJlcGxhY2VUYXJnZXQgPyAncmVwbGFjZVdpdGgnIDogJ2h0bWwnO1xcbiAgICAgICAgJChvcHRpb25zLnRhcmdldClbZm5dKGRhdGEpLmVhY2gob2xkU3VjY2VzcywgYXJndW1lbnRzKTtcXG4gICAgICB9KTtcXG4gICAgfSBlbHNlIGlmIChvcHRpb25zLnN1Y2Nlc3MpIHtcXG4gICAgICBjYWxsYmFja3MucHVzaChvcHRpb25zLnN1Y2Nlc3MpO1xcbiAgICB9XFxuXFxuICAgIG9wdGlvbnMuc3VjY2VzcyA9IGZ1bmN0aW9uIChkYXRhLCBzdGF0dXMsIHhocikge1xcbiAgICAgIC8vIGpRdWVyeSAxLjQrIHBhc3NlcyB4aHIgYXMgM3JkIGFyZ1xcbiAgICAgIHZhciBjb250ZXh0ID0gb3B0aW9ucy5jb250ZXh0IHx8IHRoaXM7IC8vIGpRdWVyeSAxLjQrIHN1cHBvcnRzIHNjb3BlIGNvbnRleHRcXG5cXG4gICAgICBmb3IgKHZhciBpID0gMCwgbWF4ID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IG1heDsgaSsrKSB7XFxuICAgICAgICBjYWxsYmFja3NbaV0uYXBwbHkoY29udGV4dCwgW2RhdGEsIHN0YXR1cywgeGhyIHx8ICRmb3JtLCAkZm9ybV0pO1xcbiAgICAgIH1cXG4gICAgfTtcXG5cXG4gICAgaWYgKG9wdGlvbnMuZXJyb3IpIHtcXG4gICAgICB2YXIgb2xkRXJyb3IgPSBvcHRpb25zLmVycm9yO1xcblxcbiAgICAgIG9wdGlvbnMuZXJyb3IgPSBmdW5jdGlvbiAoeGhyLCBzdGF0dXMsIGVycm9yKSB7XFxuICAgICAgICB2YXIgY29udGV4dCA9IG9wdGlvbnMuY29udGV4dCB8fCB0aGlzO1xcbiAgICAgICAgb2xkRXJyb3IuYXBwbHkoY29udGV4dCwgW3hociwgc3RhdHVzLCBlcnJvciwgJGZvcm1dKTtcXG4gICAgICB9O1xcbiAgICB9XFxuXFxuICAgIGlmIChvcHRpb25zLmNvbXBsZXRlKSB7XFxuICAgICAgdmFyIG9sZENvbXBsZXRlID0gb3B0aW9ucy5jb21wbGV0ZTtcXG5cXG4gICAgICBvcHRpb25zLmNvbXBsZXRlID0gZnVuY3Rpb24gKHhociwgc3RhdHVzKSB7XFxuICAgICAgICB2YXIgY29udGV4dCA9IG9wdGlvbnMuY29udGV4dCB8fCB0aGlzO1xcbiAgICAgICAgb2xkQ29tcGxldGUuYXBwbHkoY29udGV4dCwgW3hociwgc3RhdHVzLCAkZm9ybV0pO1xcbiAgICAgIH07XFxuICAgIH0gLy8gYXJlIHRoZXJlIGZpbGVzIHRvIHVwbG9hZD9cXG4gICAgLy8gW3ZhbHVlXSAoaXNzdWUgIzExMyksIGFsc28gc2VlIGNvbW1lbnQ6XFxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tYWxzdXAvZm9ybS9jb21taXQvNTg4MzA2YWVkYmExZGUwMTM4ODAzMmQ1ZjQyYTYwMTU5ZWVhOTIyOCNjb21taXRjb21tZW50LTIxODAyMTlcXG5cXG5cXG4gICAgdmFyIGZpbGVJbnB1dHMgPSAkKCdpbnB1dFt0eXBlPWZpbGVdOmVuYWJsZWQnLCB0aGlzKS5maWx0ZXIoZnVuY3Rpb24gKCkge1xcbiAgICAgIHJldHVybiAkKHRoaXMpLnZhbCgpICE9PSAnJztcXG4gICAgfSk7XFxuICAgIHZhciBoYXNGaWxlSW5wdXRzID0gZmlsZUlucHV0cy5sZW5ndGggPiAwO1xcbiAgICB2YXIgbXAgPSAnbXVsdGlwYXJ0L2Zvcm0tZGF0YSc7XFxuICAgIHZhciBtdWx0aXBhcnQgPSAkZm9ybS5hdHRyKCdlbmN0eXBlJykgPT0gbXAgfHwgJGZvcm0uYXR0cignZW5jb2RpbmcnKSA9PSBtcDtcXG4gICAgdmFyIGZpbGVBUEkgPSBmZWF0dXJlLmZpbGVhcGkgJiYgZmVhdHVyZS5mb3JtZGF0YTtcXG4gICAgbG9nKFxcXCJmaWxlQVBJIDpcXFwiICsgZmlsZUFQSSk7XFxuICAgIHZhciBzaG91bGRVc2VGcmFtZSA9IChoYXNGaWxlSW5wdXRzIHx8IG11bHRpcGFydCkgJiYgIWZpbGVBUEk7XFxuICAgIHZhciBqcXhocjsgLy8gb3B0aW9ucy5pZnJhbWUgYWxsb3dzIHVzZXIgdG8gZm9yY2UgaWZyYW1lIG1vZGVcXG4gICAgLy8gMDYtTk9WLTA5OiBub3cgZGVmYXVsdGluZyB0byBpZnJhbWUgbW9kZSBpZiBmaWxlIGlucHV0IGlzIGRldGVjdGVkXFxuXFxuICAgIGlmIChvcHRpb25zLmlmcmFtZSAhPT0gZmFsc2UgJiYgKG9wdGlvbnMuaWZyYW1lIHx8IHNob3VsZFVzZUZyYW1lKSkge1xcbiAgICAgIC8vIGhhY2sgdG8gZml4IFNhZmFyaSBoYW5nICh0aGFua3MgdG8gVGltIE1vbGVuZGlqayBmb3IgdGhpcylcXG4gICAgICAvLyBzZWU6ICBodHRwOi8vZ3JvdXBzLmdvb2dsZS5jb20vZ3JvdXAvanF1ZXJ5LWRldi9icm93c2VfdGhyZWFkL3RocmVhZC8zNjM5NWI3YWI1MTBkZDVkXFxuICAgICAgaWYgKG9wdGlvbnMuY2xvc2VLZWVwQWxpdmUpIHtcXG4gICAgICAgICQuZ2V0KG9wdGlvbnMuY2xvc2VLZWVwQWxpdmUsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAganF4aHIgPSBmaWxlVXBsb2FkSWZyYW1lKGEpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGpxeGhyID0gZmlsZVVwbG9hZElmcmFtZShhKTtcXG4gICAgICB9XFxuICAgIH0gZWxzZSBpZiAoKGhhc0ZpbGVJbnB1dHMgfHwgbXVsdGlwYXJ0KSAmJiBmaWxlQVBJKSB7XFxuICAgICAganF4aHIgPSBmaWxlVXBsb2FkWGhyKGEpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGpxeGhyID0gJC5hamF4KG9wdGlvbnMpO1xcbiAgICB9XFxuXFxuICAgICRmb3JtLnJlbW92ZURhdGEoJ2pxeGhyJykuZGF0YSgnanF4aHInLCBqcXhocik7IC8vIGNsZWFyIGVsZW1lbnQgYXJyYXlcXG5cXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBlbGVtZW50cy5sZW5ndGg7IGsrKykge1xcbiAgICAgIGVsZW1lbnRzW2tdID0gbnVsbDtcXG4gICAgfSAvLyBmaXJlICdub3RpZnknIGV2ZW50XFxuXFxuXFxuICAgIHRoaXMudHJpZ2dlcignZm9ybS1zdWJtaXQtbm90aWZ5JywgW3RoaXMsIG9wdGlvbnNdKTtcXG4gICAgcmV0dXJuIHRoaXM7IC8vIHV0aWxpdHkgZm4gZm9yIGRlZXAgc2VyaWFsaXphdGlvblxcblxcbiAgICBmdW5jdGlvbiBkZWVwU2VyaWFsaXplKGV4dHJhRGF0YSkge1xcbiAgICAgIHZhciBzZXJpYWxpemVkID0gJC5wYXJhbShleHRyYURhdGEsIG9wdGlvbnMudHJhZGl0aW9uYWwpLnNwbGl0KCcmJyk7XFxuICAgICAgdmFyIGxlbiA9IHNlcmlhbGl6ZWQubGVuZ3RoO1xcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcXG4gICAgICB2YXIgaSwgcGFydDtcXG5cXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcXG4gICAgICAgIC8vICMyNTI7IHVuZG8gcGFyYW0gc3BhY2UgcmVwbGFjZW1lbnRcXG4gICAgICAgIHNlcmlhbGl6ZWRbaV0gPSBzZXJpYWxpemVkW2ldLnJlcGxhY2UoL1xcXFwrL2csICcgJyk7XFxuICAgICAgICBwYXJ0ID0gc2VyaWFsaXplZFtpXS5zcGxpdCgnPScpOyAvLyAjMjc4OyB1c2UgYXJyYXkgaW5zdGVhZCBvZiBvYmplY3Qgc3RvcmFnZSwgZmF2b3JpbmcgYXJyYXkgc2VyaWFsaXphdGlvbnNcXG5cXG4gICAgICAgIHJlc3VsdC5wdXNoKFtkZWNvZGVVUklDb21wb25lbnQocGFydFswXSksIGRlY29kZVVSSUNvbXBvbmVudChwYXJ0WzFdKV0pO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICB9IC8vIFhNTEh0dHBSZXF1ZXN0IExldmVsIDIgZmlsZSB1cGxvYWRzIChiaWcgaGF0IHRpcCB0byBmcmFuY29pczJtZXR6KVxcblxcblxcbiAgICBmdW5jdGlvbiBmaWxlVXBsb2FkWGhyKGEpIHtcXG4gICAgICB2YXIgZm9ybWRhdGEgPSBuZXcgRm9ybURhdGEoKTtcXG5cXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgIGZvcm1kYXRhLmFwcGVuZChhW2ldLm5hbWUsIGFbaV0udmFsdWUpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAob3B0aW9ucy5leHRyYURhdGEpIHtcXG4gICAgICAgIHZhciBzZXJpYWxpemVkRGF0YSA9IGRlZXBTZXJpYWxpemUob3B0aW9ucy5leHRyYURhdGEpO1xcblxcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlcmlhbGl6ZWREYXRhLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgIGlmIChzZXJpYWxpemVkRGF0YVtpXSkge1xcbiAgICAgICAgICAgIGZvcm1kYXRhLmFwcGVuZChzZXJpYWxpemVkRGF0YVtpXVswXSwgc2VyaWFsaXplZERhdGFbaV1bMV0pO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIG9wdGlvbnMuZGF0YSA9IG51bGw7XFxuICAgICAgdmFyIHMgPSAkLmV4dGVuZCh0cnVlLCB7fSwgJC5hamF4U2V0dGluZ3MsIG9wdGlvbnMsIHtcXG4gICAgICAgIGNvbnRlbnRUeXBlOiBmYWxzZSxcXG4gICAgICAgIHByb2Nlc3NEYXRhOiBmYWxzZSxcXG4gICAgICAgIGNhY2hlOiBmYWxzZSxcXG4gICAgICAgIHR5cGU6IG1ldGhvZCB8fCAnUE9TVCdcXG4gICAgICB9KTtcXG5cXG4gICAgICBpZiAob3B0aW9ucy51cGxvYWRQcm9ncmVzcykge1xcbiAgICAgICAgLy8gd29ya2Fyb3VuZCBiZWNhdXNlIGpxWEhSIGRvZXMgbm90IGV4cG9zZSB1cGxvYWQgcHJvcGVydHlcXG4gICAgICAgIHMueGhyID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICB2YXIgeGhyID0gJC5hamF4U2V0dGluZ3MueGhyKCk7XFxuXFxuICAgICAgICAgIGlmICh4aHIudXBsb2FkKSB7XFxuICAgICAgICAgICAgeGhyLnVwbG9hZC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIGZ1bmN0aW9uIChldmVudCkge1xcbiAgICAgICAgICAgICAgdmFyIHBlcmNlbnQgPSAwO1xcbiAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gZXZlbnQubG9hZGVkIHx8IGV2ZW50LnBvc2l0aW9uO1xcbiAgICAgICAgICAgICAgLypldmVudC5wb3NpdGlvbiBpcyBkZXByZWNhdGVkKi9cXG5cXG4gICAgICAgICAgICAgIHZhciB0b3RhbCA9IGV2ZW50LnRvdGFsO1xcblxcbiAgICAgICAgICAgICAgaWYgKGV2ZW50Lmxlbmd0aENvbXB1dGFibGUpIHtcXG4gICAgICAgICAgICAgICAgcGVyY2VudCA9IE1hdGguY2VpbChwb3NpdGlvbiAvIHRvdGFsICogMTAwKTtcXG4gICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgIG9wdGlvbnMudXBsb2FkUHJvZ3Jlc3MoZXZlbnQsIHBvc2l0aW9uLCB0b3RhbCwgcGVyY2VudCk7XFxuICAgICAgICAgICAgfSwgZmFsc2UpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHJldHVybiB4aHI7XFxuICAgICAgICB9O1xcbiAgICAgIH1cXG5cXG4gICAgICBzLmRhdGEgPSBudWxsO1xcbiAgICAgIHZhciBiZWZvcmVTZW5kID0gcy5iZWZvcmVTZW5kO1xcblxcbiAgICAgIHMuYmVmb3JlU2VuZCA9IGZ1bmN0aW9uICh4aHIsIG8pIHtcXG4gICAgICAgIC8vU2VuZCBGb3JtRGF0YSgpIHByb3ZpZGVkIGJ5IHVzZXJcXG4gICAgICAgIGlmIChvcHRpb25zLmZvcm1EYXRhKSB7XFxuICAgICAgICAgIG8uZGF0YSA9IG9wdGlvbnMuZm9ybURhdGE7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBvLmRhdGEgPSBmb3JtZGF0YTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChiZWZvcmVTZW5kKSB7XFxuICAgICAgICAgIGJlZm9yZVNlbmQuY2FsbCh0aGlzLCB4aHIsIG8pO1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuXFxuICAgICAgcmV0dXJuICQuYWpheChzKTtcXG4gICAgfSAvLyBwcml2YXRlIGZ1bmN0aW9uIGZvciBoYW5kbGluZyBmaWxlIHVwbG9hZHMgKGhhdCB0aXAgdG8gWUFIT08hKVxcblxcblxcbiAgICBmdW5jdGlvbiBmaWxlVXBsb2FkSWZyYW1lKGEpIHtcXG4gICAgICB2YXIgZm9ybSA9ICRmb3JtWzBdLFxcbiAgICAgICAgICBlbCxcXG4gICAgICAgICAgaSxcXG4gICAgICAgICAgcyxcXG4gICAgICAgICAgZyxcXG4gICAgICAgICAgaWQsXFxuICAgICAgICAgICRpbyxcXG4gICAgICAgICAgaW8sXFxuICAgICAgICAgIHhocixcXG4gICAgICAgICAgc3ViLFxcbiAgICAgICAgICBuLFxcbiAgICAgICAgICB0aW1lZE91dCxcXG4gICAgICAgICAgdGltZW91dEhhbmRsZTtcXG4gICAgICB2YXIgZGVmZXJyZWQgPSAkLkRlZmVycmVkKCk7IC8vICMzNDFcXG5cXG4gICAgICBkZWZlcnJlZC5hYm9ydCA9IGZ1bmN0aW9uIChzdGF0dXMpIHtcXG4gICAgICAgIHhoci5hYm9ydChzdGF0dXMpO1xcbiAgICAgIH07XFxuXFxuICAgICAgaWYgKGEpIHtcXG4gICAgICAgIC8vIGVuc3VyZSB0aGF0IGV2ZXJ5IHNlcmlhbGl6ZWQgaW5wdXQgaXMgc3RpbGwgZW5hYmxlZFxcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgIGVsID0gJChlbGVtZW50c1tpXSk7XFxuXFxuICAgICAgICAgIGlmIChoYXNQcm9wKSB7XFxuICAgICAgICAgICAgZWwucHJvcCgnZGlzYWJsZWQnLCBmYWxzZSk7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgZWwucmVtb3ZlQXR0cignZGlzYWJsZWQnKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBzID0gJC5leHRlbmQodHJ1ZSwge30sICQuYWpheFNldHRpbmdzLCBvcHRpb25zKTtcXG4gICAgICBzLmNvbnRleHQgPSBzLmNvbnRleHQgfHwgcztcXG4gICAgICBpZCA9ICdqcUZvcm1JTycgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcXG5cXG4gICAgICBpZiAocy5pZnJhbWVUYXJnZXQpIHtcXG4gICAgICAgICRpbyA9ICQocy5pZnJhbWVUYXJnZXQpO1xcbiAgICAgICAgbiA9ICRpby5hdHRyMignbmFtZScpO1xcblxcbiAgICAgICAgaWYgKCFuKSB7XFxuICAgICAgICAgICRpby5hdHRyMignbmFtZScsIGlkKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGlkID0gbjtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgJGlvID0gJCgnPGlmcmFtZSBuYW1lPVxcXCInICsgaWQgKyAnXFxcIiBzcmM9XFxcIicgKyBzLmlmcmFtZVNyYyArICdcXFwiIC8+Jyk7XFxuICAgICAgICAkaW8uY3NzKHtcXG4gICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXFxuICAgICAgICAgIHRvcDogJy0xMDAwcHgnLFxcbiAgICAgICAgICBsZWZ0OiAnLTEwMDBweCdcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG5cXG4gICAgICBpbyA9ICRpb1swXTtcXG4gICAgICB4aHIgPSB7XFxuICAgICAgICAvLyBtb2NrIG9iamVjdFxcbiAgICAgICAgYWJvcnRlZDogMCxcXG4gICAgICAgIHJlc3BvbnNlVGV4dDogbnVsbCxcXG4gICAgICAgIHJlc3BvbnNlWE1MOiBudWxsLFxcbiAgICAgICAgc3RhdHVzOiAwLFxcbiAgICAgICAgc3RhdHVzVGV4dDogJ24vYScsXFxuICAgICAgICBnZXRBbGxSZXNwb25zZUhlYWRlcnM6IGZ1bmN0aW9uIGdldEFsbFJlc3BvbnNlSGVhZGVycygpIHt9LFxcbiAgICAgICAgZ2V0UmVzcG9uc2VIZWFkZXI6IGZ1bmN0aW9uIGdldFJlc3BvbnNlSGVhZGVyKCkge30sXFxuICAgICAgICBzZXRSZXF1ZXN0SGVhZGVyOiBmdW5jdGlvbiBzZXRSZXF1ZXN0SGVhZGVyKCkge30sXFxuICAgICAgICBhYm9ydDogZnVuY3Rpb24gYWJvcnQoc3RhdHVzKSB7XFxuICAgICAgICAgIHZhciBlID0gc3RhdHVzID09PSAndGltZW91dCcgPyAndGltZW91dCcgOiAnYWJvcnRlZCc7XFxuICAgICAgICAgIGxvZygnYWJvcnRpbmcgdXBsb2FkLi4uICcgKyBlKTtcXG4gICAgICAgICAgdGhpcy5hYm9ydGVkID0gMTtcXG5cXG4gICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAvLyAjMjE0LCAjMjU3XFxuICAgICAgICAgICAgaWYgKGlvLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQuZXhlY0NvbW1hbmQpIHtcXG4gICAgICAgICAgICAgIGlvLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQuZXhlY0NvbW1hbmQoJ1N0b3AnKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cXG5cXG4gICAgICAgICAgJGlvLmF0dHIoJ3NyYycsIHMuaWZyYW1lU3JjKTsgLy8gYWJvcnQgb3AgaW4gcHJvZ3Jlc3NcXG5cXG4gICAgICAgICAgeGhyLmVycm9yID0gZTtcXG5cXG4gICAgICAgICAgaWYgKHMuZXJyb3IpIHtcXG4gICAgICAgICAgICBzLmVycm9yLmNhbGwocy5jb250ZXh0LCB4aHIsIGUsIHN0YXR1cyk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaWYgKGcpIHtcXG4gICAgICAgICAgICAkLmV2ZW50LnRyaWdnZXIoXFxcImFqYXhFcnJvclxcXCIsIFt4aHIsIHMsIGVdKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAocy5jb21wbGV0ZSkge1xcbiAgICAgICAgICAgIHMuY29tcGxldGUuY2FsbChzLmNvbnRleHQsIHhociwgZSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIGcgPSBzLmdsb2JhbDsgLy8gdHJpZ2dlciBhamF4IGdsb2JhbCBldmVudHMgc28gdGhhdCBhY3Rpdml0eS9ibG9jayBpbmRpY2F0b3JzIHdvcmsgbGlrZSBub3JtYWxcXG5cXG4gICAgICBpZiAoZyAmJiAwID09PSAkLmFjdGl2ZSsrKSB7XFxuICAgICAgICAkLmV2ZW50LnRyaWdnZXIoXFxcImFqYXhTdGFydFxcXCIpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoZykge1xcbiAgICAgICAgJC5ldmVudC50cmlnZ2VyKFxcXCJhamF4U2VuZFxcXCIsIFt4aHIsIHNdKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHMuYmVmb3JlU2VuZCAmJiBzLmJlZm9yZVNlbmQuY2FsbChzLmNvbnRleHQsIHhociwgcykgPT09IGZhbHNlKSB7XFxuICAgICAgICBpZiAocy5nbG9iYWwpIHtcXG4gICAgICAgICAgJC5hY3RpdmUtLTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGRlZmVycmVkLnJlamVjdCgpO1xcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoeGhyLmFib3J0ZWQpIHtcXG4gICAgICAgIGRlZmVycmVkLnJlamVjdCgpO1xcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkO1xcbiAgICAgIH0gLy8gYWRkIHN1Ym1pdHRpbmcgZWxlbWVudCB0byBkYXRhIGlmIHdlIGtub3cgaXRcXG5cXG5cXG4gICAgICBzdWIgPSBmb3JtLmNsaztcXG5cXG4gICAgICBpZiAoc3ViKSB7XFxuICAgICAgICBuID0gc3ViLm5hbWU7XFxuXFxuICAgICAgICBpZiAobiAmJiAhc3ViLmRpc2FibGVkKSB7XFxuICAgICAgICAgIHMuZXh0cmFEYXRhID0gcy5leHRyYURhdGEgfHwge307XFxuICAgICAgICAgIHMuZXh0cmFEYXRhW25dID0gc3ViLnZhbHVlO1xcblxcbiAgICAgICAgICBpZiAoc3ViLnR5cGUgPT0gXFxcImltYWdlXFxcIikge1xcbiAgICAgICAgICAgIHMuZXh0cmFEYXRhW24gKyAnLngnXSA9IGZvcm0uY2xrX3g7XFxuICAgICAgICAgICAgcy5leHRyYURhdGFbbiArICcueSddID0gZm9ybS5jbGtfeTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgQ0xJRU5UX1RJTUVPVVRfQUJPUlQgPSAxO1xcbiAgICAgIHZhciBTRVJWRVJfQUJPUlQgPSAyO1xcblxcbiAgICAgIGZ1bmN0aW9uIGdldERvYyhmcmFtZSkge1xcbiAgICAgICAgLyogaXQgbG9va3MgbGlrZSBjb250ZW50V2luZG93IG9yIGNvbnRlbnREb2N1bWVudCBkbyBub3RcXG4gICAgICAgICAqIGNhcnJ5IHRoZSBwcm90b2NvbCBwcm9wZXJ0eSBpbiBpZTgsIHdoZW4gcnVubmluZyB1bmRlciBzc2xcXG4gICAgICAgICAqIGZyYW1lLmRvY3VtZW50IGlzIHRoZSBvbmx5IHZhbGlkIHJlc3BvbnNlIGRvY3VtZW50LCBzaW5jZVxcbiAgICAgICAgICogdGhlIHByb3RvY29sIGlzIGtub3cgYnV0IG5vdCBvbiB0aGUgb3RoZXIgdHdvIG9iamVjdHMuIHN0cmFuZ2U/XFxuICAgICAgICAgKiBcXFwiU2FtZSBvcmlnaW4gcG9saWN5XFxcIiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NhbWVfb3JpZ2luX3BvbGljeVxcbiAgICAgICAgICovXFxuICAgICAgICB2YXIgZG9jID0gbnVsbDsgLy8gSUU4IGNhc2NhZGluZyBhY2Nlc3MgY2hlY2tcXG5cXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgIGlmIChmcmFtZS5jb250ZW50V2luZG93KSB7XFxuICAgICAgICAgICAgZG9jID0gZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XFxuICAgICAgICAgIC8vIElFOCBhY2Nlc3MgZGVuaWVkIHVuZGVyIHNzbCAmIG1pc3NpbmcgcHJvdG9jb2xcXG4gICAgICAgICAgbG9nKCdjYW5ub3QgZ2V0IGlmcmFtZS5jb250ZW50V2luZG93IGRvY3VtZW50OiAnICsgZXJyKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChkb2MpIHtcXG4gICAgICAgICAgLy8gc3VjY2Vzc2Z1bCBnZXR0aW5nIGNvbnRlbnRcXG4gICAgICAgICAgcmV0dXJuIGRvYztcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgIC8vIHNpbXBseSBjaGVja2luZyBtYXkgdGhyb3cgaW4gaWU4IHVuZGVyIHNzbCBvciBtaXNtYXRjaGVkIHByb3RvY29sXFxuICAgICAgICAgIGRvYyA9IGZyYW1lLmNvbnRlbnREb2N1bWVudCA/IGZyYW1lLmNvbnRlbnREb2N1bWVudCA6IGZyYW1lLmRvY3VtZW50O1xcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XFxuICAgICAgICAgIC8vIGxhc3QgYXR0ZW1wdFxcbiAgICAgICAgICBsb2coJ2Nhbm5vdCBnZXQgaWZyYW1lLmNvbnRlbnREb2N1bWVudDogJyArIGVycik7XFxuICAgICAgICAgIGRvYyA9IGZyYW1lLmRvY3VtZW50O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIGRvYztcXG4gICAgICB9IC8vIFJhaWxzIENTUkYgaGFjayAodGhhbmtzIHRvIFl2YW4gQmFydGhlbGVteSlcXG5cXG5cXG4gICAgICB2YXIgY3NyZl90b2tlbiA9ICQoJ21ldGFbbmFtZT1jc3JmLXRva2VuXScpLmF0dHIoJ2NvbnRlbnQnKTtcXG4gICAgICB2YXIgY3NyZl9wYXJhbSA9ICQoJ21ldGFbbmFtZT1jc3JmLXBhcmFtXScpLmF0dHIoJ2NvbnRlbnQnKTtcXG5cXG4gICAgICBpZiAoY3NyZl9wYXJhbSAmJiBjc3JmX3Rva2VuKSB7XFxuICAgICAgICBzLmV4dHJhRGF0YSA9IHMuZXh0cmFEYXRhIHx8IHt9O1xcbiAgICAgICAgcy5leHRyYURhdGFbY3NyZl9wYXJhbV0gPSBjc3JmX3Rva2VuO1xcbiAgICAgIH0gLy8gdGFrZSBhIGJyZWF0aCBzbyB0aGF0IHBlbmRpbmcgcmVwYWludHMgZ2V0IHNvbWUgY3B1IHRpbWUgYmVmb3JlIHRoZSB1cGxvYWQgc3RhcnRzXFxuXFxuXFxuICAgICAgZnVuY3Rpb24gZG9TdWJtaXQoKSB7XFxuICAgICAgICAvLyBtYWtlIHN1cmUgZm9ybSBhdHRycyBhcmUgc2V0XFxuICAgICAgICB2YXIgdCA9ICRmb3JtLmF0dHIyKCd0YXJnZXQnKSxcXG4gICAgICAgICAgICBhID0gJGZvcm0uYXR0cjIoJ2FjdGlvbicpLFxcbiAgICAgICAgICAgIG1wID0gJ211bHRpcGFydC9mb3JtLWRhdGEnLFxcbiAgICAgICAgICAgIGV0ID0gJGZvcm0uYXR0cignZW5jdHlwZScpIHx8ICRmb3JtLmF0dHIoJ2VuY29kaW5nJykgfHwgbXA7IC8vIHVwZGF0ZSBmb3JtIGF0dHJzIGluIElFIGZyaWVuZGx5IHdheVxcblxcbiAgICAgICAgZm9ybS5zZXRBdHRyaWJ1dGUoJ3RhcmdldCcsIGlkKTtcXG5cXG4gICAgICAgIGlmICghbWV0aG9kIHx8IC9wb3N0L2kudGVzdChtZXRob2QpKSB7XFxuICAgICAgICAgIGZvcm0uc2V0QXR0cmlidXRlKCdtZXRob2QnLCAnUE9TVCcpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKGEgIT0gcy51cmwpIHtcXG4gICAgICAgICAgZm9ybS5zZXRBdHRyaWJ1dGUoJ2FjdGlvbicsIHMudXJsKTtcXG4gICAgICAgIH0gLy8gaWUgYm9ya3MgaW4gc29tZSBjYXNlcyB3aGVuIHNldHRpbmcgZW5jb2RpbmdcXG5cXG5cXG4gICAgICAgIGlmICghcy5za2lwRW5jb2RpbmdPdmVycmlkZSAmJiAoIW1ldGhvZCB8fCAvcG9zdC9pLnRlc3QobWV0aG9kKSkpIHtcXG4gICAgICAgICAgJGZvcm0uYXR0cih7XFxuICAgICAgICAgICAgZW5jb2Rpbmc6ICdtdWx0aXBhcnQvZm9ybS1kYXRhJyxcXG4gICAgICAgICAgICBlbmN0eXBlOiAnbXVsdGlwYXJ0L2Zvcm0tZGF0YSdcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9IC8vIHN1cHBvcnQgdGltb3V0XFxuXFxuXFxuICAgICAgICBpZiAocy50aW1lb3V0KSB7XFxuICAgICAgICAgIHRpbWVvdXRIYW5kbGUgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICB0aW1lZE91dCA9IHRydWU7XFxuICAgICAgICAgICAgY2IoQ0xJRU5UX1RJTUVPVVRfQUJPUlQpO1xcbiAgICAgICAgICB9LCBzLnRpbWVvdXQpO1xcbiAgICAgICAgfSAvLyBsb29rIGZvciBzZXJ2ZXIgYWJvcnRzXFxuXFxuXFxuICAgICAgICBmdW5jdGlvbiBjaGVja1N0YXRlKCkge1xcbiAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IGdldERvYyhpbykucmVhZHlTdGF0ZTtcXG4gICAgICAgICAgICBsb2coJ3N0YXRlID0gJyArIHN0YXRlKTtcXG5cXG4gICAgICAgICAgICBpZiAoc3RhdGUgJiYgc3RhdGUudG9Mb3dlckNhc2UoKSA9PSAndW5pbml0aWFsaXplZCcpIHtcXG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoY2hlY2tTdGF0ZSwgNTApO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgICAgIGxvZygnU2VydmVyIGFib3J0OiAnLCBlLCAnICgnLCBlLm5hbWUsICcpJyk7XFxuICAgICAgICAgICAgY2IoU0VSVkVSX0FCT1JUKTtcXG5cXG4gICAgICAgICAgICBpZiAodGltZW91dEhhbmRsZSkge1xcbiAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRIYW5kbGUpO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICB0aW1lb3V0SGFuZGxlID0gdW5kZWZpbmVkO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IC8vIGFkZCBcXFwiZXh0cmFcXFwiIGRhdGEgdG8gZm9ybSBpZiBwcm92aWRlZCBpbiBvcHRpb25zXFxuXFxuXFxuICAgICAgICB2YXIgZXh0cmFJbnB1dHMgPSBbXTtcXG5cXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgIGlmIChzLmV4dHJhRGF0YSkge1xcbiAgICAgICAgICAgIGZvciAodmFyIG4gaW4gcy5leHRyYURhdGEpIHtcXG4gICAgICAgICAgICAgIGlmIChzLmV4dHJhRGF0YS5oYXNPd25Qcm9wZXJ0eShuKSkge1xcbiAgICAgICAgICAgICAgICAvLyBpZiB1c2luZyB0aGUgJC5wYXJhbSBmb3JtYXQgdGhhdCBhbGxvd3MgZm9yIG11bHRpcGxlIHZhbHVlcyB3aXRoIHRoZSBzYW1lIG5hbWVcXG4gICAgICAgICAgICAgICAgaWYgKCQuaXNQbGFpbk9iamVjdChzLmV4dHJhRGF0YVtuXSkgJiYgcy5leHRyYURhdGFbbl0uaGFzT3duUHJvcGVydHkoJ25hbWUnKSAmJiBzLmV4dHJhRGF0YVtuXS5oYXNPd25Qcm9wZXJ0eSgndmFsdWUnKSkge1xcbiAgICAgICAgICAgICAgICAgIGV4dHJhSW5wdXRzLnB1c2goJCgnPGlucHV0IHR5cGU9XFxcImhpZGRlblxcXCIgbmFtZT1cXFwiJyArIHMuZXh0cmFEYXRhW25dLm5hbWUgKyAnXFxcIj4nKS52YWwocy5leHRyYURhdGFbbl0udmFsdWUpLmFwcGVuZFRvKGZvcm0pWzBdKTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICBleHRyYUlucHV0cy5wdXNoKCQoJzxpbnB1dCB0eXBlPVxcXCJoaWRkZW5cXFwiIG5hbWU9XFxcIicgKyBuICsgJ1xcXCI+JykudmFsKHMuZXh0cmFEYXRhW25dKS5hcHBlbmRUbyhmb3JtKVswXSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaWYgKCFzLmlmcmFtZVRhcmdldCkge1xcbiAgICAgICAgICAgIC8vIGFkZCBpZnJhbWUgdG8gZG9jIGFuZCBzdWJtaXQgdGhlIGZvcm1cXG4gICAgICAgICAgICAkaW8uYXBwZW5kVG8oJ2JvZHknKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAoaW8uYXR0YWNoRXZlbnQpIHtcXG4gICAgICAgICAgICBpby5hdHRhY2hFdmVudCgnb25sb2FkJywgY2IpO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGlvLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBjYiwgZmFsc2UpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHNldFRpbWVvdXQoY2hlY2tTdGF0ZSwgMTUpO1xcblxcbiAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgIGZvcm0uc3VibWl0KCk7XFxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xcbiAgICAgICAgICAgIC8vIGp1c3QgaW4gY2FzZSBmb3JtIGhhcyBlbGVtZW50IHdpdGggbmFtZS9pZCBvZiAnc3VibWl0J1xcbiAgICAgICAgICAgIHZhciBzdWJtaXRGbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Zvcm0nKS5zdWJtaXQ7XFxuICAgICAgICAgICAgc3VibWl0Rm4uYXBwbHkoZm9ybSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gZmluYWxseSB7XFxuICAgICAgICAgIC8vIHJlc2V0IGF0dHJzIGFuZCByZW1vdmUgXFxcImV4dHJhXFxcIiBpbnB1dCBlbGVtZW50c1xcbiAgICAgICAgICBmb3JtLnNldEF0dHJpYnV0ZSgnYWN0aW9uJywgYSk7XFxuICAgICAgICAgIGZvcm0uc2V0QXR0cmlidXRlKCdlbmN0eXBlJywgZXQpOyAvLyAjMzgwXFxuXFxuICAgICAgICAgIGlmICh0KSB7XFxuICAgICAgICAgICAgZm9ybS5zZXRBdHRyaWJ1dGUoJ3RhcmdldCcsIHQpO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICRmb3JtLnJlbW92ZUF0dHIoJ3RhcmdldCcpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgICQoZXh0cmFJbnB1dHMpLnJlbW92ZSgpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBpZiAocy5mb3JjZVN5bmMpIHtcXG4gICAgICAgIGRvU3VibWl0KCk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHNldFRpbWVvdXQoZG9TdWJtaXQsIDEwKTsgLy8gdGhpcyBsZXRzIGRvbSB1cGRhdGVzIHJlbmRlclxcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgZGF0YSxcXG4gICAgICAgICAgZG9jLFxcbiAgICAgICAgICBkb21DaGVja0NvdW50ID0gNTAsXFxuICAgICAgICAgIGNhbGxiYWNrUHJvY2Vzc2VkO1xcblxcbiAgICAgIGZ1bmN0aW9uIGNiKGUpIHtcXG4gICAgICAgIGlmICh4aHIuYWJvcnRlZCB8fCBjYWxsYmFja1Byb2Nlc3NlZCkge1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICBkb2MgPSBnZXREb2MoaW8pO1xcblxcbiAgICAgICAgaWYgKCFkb2MpIHtcXG4gICAgICAgICAgbG9nKCdjYW5ub3QgYWNjZXNzIHJlc3BvbnNlIGRvY3VtZW50Jyk7XFxuICAgICAgICAgIGUgPSBTRVJWRVJfQUJPUlQ7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoZSA9PT0gQ0xJRU5UX1RJTUVPVVRfQUJPUlQgJiYgeGhyKSB7XFxuICAgICAgICAgIHhoci5hYm9ydCgndGltZW91dCcpO1xcbiAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoeGhyLCAndGltZW91dCcpO1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9IGVsc2UgaWYgKGUgPT0gU0VSVkVSX0FCT1JUICYmIHhocikge1xcbiAgICAgICAgICB4aHIuYWJvcnQoJ3NlcnZlciBhYm9ydCcpO1xcbiAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoeGhyLCAnZXJyb3InLCAnc2VydmVyIGFib3J0Jyk7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICghZG9jIHx8IGRvYy5sb2NhdGlvbi5ocmVmID09IHMuaWZyYW1lU3JjKSB7XFxuICAgICAgICAgIC8vIHJlc3BvbnNlIG5vdCByZWNlaXZlZCB5ZXRcXG4gICAgICAgICAgaWYgKCF0aW1lZE91dCkge1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKGlvLmRldGFjaEV2ZW50KSB7XFxuICAgICAgICAgIGlvLmRldGFjaEV2ZW50KCdvbmxvYWQnLCBjYik7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBpby5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkJywgY2IsIGZhbHNlKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHZhciBzdGF0dXMgPSAnc3VjY2VzcycsXFxuICAgICAgICAgICAgZXJyTXNnO1xcblxcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgaWYgKHRpbWVkT3V0KSB7XFxuICAgICAgICAgICAgdGhyb3cgJ3RpbWVvdXQnO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHZhciBpc1htbCA9IHMuZGF0YVR5cGUgPT0gJ3htbCcgfHwgZG9jLlhNTERvY3VtZW50IHx8ICQuaXNYTUxEb2MoZG9jKTtcXG4gICAgICAgICAgbG9nKCdpc1htbD0nICsgaXNYbWwpO1xcblxcbiAgICAgICAgICBpZiAoIWlzWG1sICYmIHdpbmRvdy5vcGVyYSAmJiAoZG9jLmJvZHkgPT09IG51bGwgfHwgIWRvYy5ib2R5LmlubmVySFRNTCkpIHtcXG4gICAgICAgICAgICBpZiAoLS1kb21DaGVja0NvdW50KSB7XFxuICAgICAgICAgICAgICAvLyBpbiBzb21lIGJyb3dzZXJzIChPcGVyYSkgdGhlIGlmcmFtZSBET00gaXMgbm90IGFsd2F5cyB0cmF2ZXJzYWJsZSB3aGVuXFxuICAgICAgICAgICAgICAvLyB0aGUgb25sb2FkIGNhbGxiYWNrIGZpcmVzLCBzbyB3ZSBsb29wIGEgYml0IHRvIGFjY29tbW9kYXRlXFxuICAgICAgICAgICAgICBsb2coJ3JlcXVlaW5nIG9uTG9hZCBjYWxsYmFjaywgRE9NIG5vdCBhdmFpbGFibGUnKTtcXG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoY2IsIDI1MCk7XFxuICAgICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgICAgfSAvLyBsZXQgdGhpcyBmYWxsIHRocm91Z2ggYmVjYXVzZSBzZXJ2ZXIgcmVzcG9uc2UgY291bGQgYmUgYW4gZW1wdHkgZG9jdW1lbnRcXG4gICAgICAgICAgICAvL2xvZygnQ291bGQgbm90IGFjY2VzcyBpZnJhbWUgRE9NIGFmdGVyIG11dGlwbGUgdHJpZXMuJyk7XFxuICAgICAgICAgICAgLy90aHJvdyAnRE9NRXhjZXB0aW9uOiBub3QgYXZhaWxhYmxlJztcXG5cXG4gICAgICAgICAgfSAvL2xvZygncmVzcG9uc2UgZGV0ZWN0ZWQnKTtcXG5cXG5cXG4gICAgICAgICAgdmFyIGRvY1Jvb3QgPSBkb2MuYm9keSA/IGRvYy5ib2R5IDogZG9jLmRvY3VtZW50RWxlbWVudDtcXG4gICAgICAgICAgeGhyLnJlc3BvbnNlVGV4dCA9IGRvY1Jvb3QgPyBkb2NSb290LmlubmVySFRNTCA6IG51bGw7XFxuICAgICAgICAgIHhoci5yZXNwb25zZVhNTCA9IGRvYy5YTUxEb2N1bWVudCA/IGRvYy5YTUxEb2N1bWVudCA6IGRvYztcXG5cXG4gICAgICAgICAgaWYgKGlzWG1sKSB7XFxuICAgICAgICAgICAgcy5kYXRhVHlwZSA9ICd4bWwnO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHhoci5nZXRSZXNwb25zZUhlYWRlciA9IGZ1bmN0aW9uIChoZWFkZXIpIHtcXG4gICAgICAgICAgICB2YXIgaGVhZGVycyA9IHtcXG4gICAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiBzLmRhdGFUeXBlXFxuICAgICAgICAgICAgfTtcXG4gICAgICAgICAgICByZXR1cm4gaGVhZGVyc1toZWFkZXIudG9Mb3dlckNhc2UoKV07XFxuICAgICAgICAgIH07IC8vIHN1cHBvcnQgZm9yIFhIUiAnc3RhdHVzJyAmICdzdGF0dXNUZXh0JyBlbXVsYXRpb24gOlxcblxcblxcbiAgICAgICAgICBpZiAoZG9jUm9vdCkge1xcbiAgICAgICAgICAgIHhoci5zdGF0dXMgPSBOdW1iZXIoZG9jUm9vdC5nZXRBdHRyaWJ1dGUoJ3N0YXR1cycpKSB8fCB4aHIuc3RhdHVzO1xcbiAgICAgICAgICAgIHhoci5zdGF0dXNUZXh0ID0gZG9jUm9vdC5nZXRBdHRyaWJ1dGUoJ3N0YXR1c1RleHQnKSB8fCB4aHIuc3RhdHVzVGV4dDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICB2YXIgZHQgPSAocy5kYXRhVHlwZSB8fCAnJykudG9Mb3dlckNhc2UoKTtcXG4gICAgICAgICAgdmFyIHNjciA9IC8oanNvbnxzY3JpcHR8dGV4dCkvLnRlc3QoZHQpO1xcblxcbiAgICAgICAgICBpZiAoc2NyIHx8IHMudGV4dGFyZWEpIHtcXG4gICAgICAgICAgICAvLyBzZWUgaWYgdXNlciBlbWJlZGRlZCByZXNwb25zZSBpbiB0ZXh0YXJlYVxcbiAgICAgICAgICAgIHZhciB0YSA9IGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSgndGV4dGFyZWEnKVswXTtcXG5cXG4gICAgICAgICAgICBpZiAodGEpIHtcXG4gICAgICAgICAgICAgIHhoci5yZXNwb25zZVRleHQgPSB0YS52YWx1ZTsgLy8gc3VwcG9ydCBmb3IgWEhSICdzdGF0dXMnICYgJ3N0YXR1c1RleHQnIGVtdWxhdGlvbiA6XFxuXFxuICAgICAgICAgICAgICB4aHIuc3RhdHVzID0gTnVtYmVyKHRhLmdldEF0dHJpYnV0ZSgnc3RhdHVzJykpIHx8IHhoci5zdGF0dXM7XFxuICAgICAgICAgICAgICB4aHIuc3RhdHVzVGV4dCA9IHRhLmdldEF0dHJpYnV0ZSgnc3RhdHVzVGV4dCcpIHx8IHhoci5zdGF0dXNUZXh0O1xcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2NyKSB7XFxuICAgICAgICAgICAgICAvLyBhY2NvdW50IGZvciBicm93c2VycyBpbmplY3RpbmcgcHJlIGFyb3VuZCBqc29uIHJlc3BvbnNlXFxuICAgICAgICAgICAgICB2YXIgcHJlID0gZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdwcmUnKVswXTtcXG4gICAgICAgICAgICAgIHZhciBiID0gZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdib2R5JylbMF07XFxuXFxuICAgICAgICAgICAgICBpZiAocHJlKSB7XFxuICAgICAgICAgICAgICAgIHhoci5yZXNwb25zZVRleHQgPSBwcmUudGV4dENvbnRlbnQgPyBwcmUudGV4dENvbnRlbnQgOiBwcmUuaW5uZXJUZXh0O1xcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChiKSB7XFxuICAgICAgICAgICAgICAgIHhoci5yZXNwb25zZVRleHQgPSBiLnRleHRDb250ZW50ID8gYi50ZXh0Q29udGVudCA6IGIuaW5uZXJUZXh0O1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSBlbHNlIGlmIChkdCA9PSAneG1sJyAmJiAheGhyLnJlc3BvbnNlWE1MICYmIHhoci5yZXNwb25zZVRleHQpIHtcXG4gICAgICAgICAgICB4aHIucmVzcG9uc2VYTUwgPSB0b1htbCh4aHIucmVzcG9uc2VUZXh0KTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgIGRhdGEgPSBodHRwRGF0YSh4aHIsIGR0LCBzKTtcXG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XFxuICAgICAgICAgICAgc3RhdHVzID0gJ3BhcnNlcmVycm9yJztcXG4gICAgICAgICAgICB4aHIuZXJyb3IgPSBlcnJNc2cgPSBlcnIgfHwgc3RhdHVzO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcXG4gICAgICAgICAgbG9nKCdlcnJvciBjYXVnaHQ6ICcsIGVycik7XFxuICAgICAgICAgIHN0YXR1cyA9ICdlcnJvcic7XFxuICAgICAgICAgIHhoci5lcnJvciA9IGVyck1zZyA9IGVyciB8fCBzdGF0dXM7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoeGhyLmFib3J0ZWQpIHtcXG4gICAgICAgICAgbG9nKCd1cGxvYWQgYWJvcnRlZCcpO1xcbiAgICAgICAgICBzdGF0dXMgPSBudWxsO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKHhoci5zdGF0dXMpIHtcXG4gICAgICAgICAgLy8gd2UndmUgc2V0IHhoci5zdGF0dXNcXG4gICAgICAgICAgc3RhdHVzID0geGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8IDMwMCB8fCB4aHIuc3RhdHVzID09PSAzMDQgPyAnc3VjY2VzcycgOiAnZXJyb3InO1xcbiAgICAgICAgfSAvLyBvcmRlcmluZyBvZiB0aGVzZSBjYWxsYmFja3MvdHJpZ2dlcnMgaXMgb2RkLCBidXQgdGhhdCdzIGhvdyAkLmFqYXggZG9lcyBpdFxcblxcblxcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ3N1Y2Nlc3MnKSB7XFxuICAgICAgICAgIGlmIChzLnN1Y2Nlc3MpIHtcXG4gICAgICAgICAgICBzLnN1Y2Nlc3MuY2FsbChzLmNvbnRleHQsIGRhdGEsICdzdWNjZXNzJywgeGhyKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHhoci5yZXNwb25zZVRleHQsICdzdWNjZXNzJywgeGhyKTtcXG5cXG4gICAgICAgICAgaWYgKGcpIHtcXG4gICAgICAgICAgICAkLmV2ZW50LnRyaWdnZXIoXFxcImFqYXhTdWNjZXNzXFxcIiwgW3hociwgc10pO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2UgaWYgKHN0YXR1cykge1xcbiAgICAgICAgICBpZiAoZXJyTXNnID09PSB1bmRlZmluZWQpIHtcXG4gICAgICAgICAgICBlcnJNc2cgPSB4aHIuc3RhdHVzVGV4dDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAocy5lcnJvcikge1xcbiAgICAgICAgICAgIHMuZXJyb3IuY2FsbChzLmNvbnRleHQsIHhociwgc3RhdHVzLCBlcnJNc2cpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGRlZmVycmVkLnJlamVjdCh4aHIsICdlcnJvcicsIGVyck1zZyk7XFxuXFxuICAgICAgICAgIGlmIChnKSB7XFxuICAgICAgICAgICAgJC5ldmVudC50cmlnZ2VyKFxcXCJhamF4RXJyb3JcXFwiLCBbeGhyLCBzLCBlcnJNc2ddKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKGcpIHtcXG4gICAgICAgICAgJC5ldmVudC50cmlnZ2VyKFxcXCJhamF4Q29tcGxldGVcXFwiLCBbeGhyLCBzXSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoZyAmJiAhIC0tJC5hY3RpdmUpIHtcXG4gICAgICAgICAgJC5ldmVudC50cmlnZ2VyKFxcXCJhamF4U3RvcFxcXCIpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKHMuY29tcGxldGUpIHtcXG4gICAgICAgICAgcy5jb21wbGV0ZS5jYWxsKHMuY29udGV4dCwgeGhyLCBzdGF0dXMpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgY2FsbGJhY2tQcm9jZXNzZWQgPSB0cnVlO1xcblxcbiAgICAgICAgaWYgKHMudGltZW91dCkge1xcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dEhhbmRsZSk7XFxuICAgICAgICB9IC8vIGNsZWFuIHVwXFxuXFxuXFxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgaWYgKCFzLmlmcmFtZVRhcmdldCkge1xcbiAgICAgICAgICAgICRpby5yZW1vdmUoKTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAvL2FkZGluZyBlbHNlIHRvIGNsZWFuIHVwIGV4aXN0aW5nIGlmcmFtZSByZXNwb25zZS5cXG4gICAgICAgICAgICAkaW8uYXR0cignc3JjJywgcy5pZnJhbWVTcmMpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHhoci5yZXNwb25zZVhNTCA9IG51bGw7XFxuICAgICAgICB9LCAxMDApO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgdG9YbWwgPSAkLnBhcnNlWE1MIHx8IGZ1bmN0aW9uIChzLCBkb2MpIHtcXG4gICAgICAgIC8vIHVzZSBwYXJzZVhNTCBpZiBhdmFpbGFibGUgKGpRdWVyeSAxLjUrKVxcbiAgICAgICAgaWYgKHdpbmRvdy5BY3RpdmVYT2JqZWN0KSB7XFxuICAgICAgICAgIGRvYyA9IG5ldyBBY3RpdmVYT2JqZWN0KCdNaWNyb3NvZnQuWE1MRE9NJyk7XFxuICAgICAgICAgIGRvYy5hc3luYyA9ICdmYWxzZSc7XFxuICAgICAgICAgIGRvYy5sb2FkWE1MKHMpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgZG9jID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhzLCAndGV4dC94bWwnKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiBkb2MgJiYgZG9jLmRvY3VtZW50RWxlbWVudCAmJiBkb2MuZG9jdW1lbnRFbGVtZW50Lm5vZGVOYW1lICE9ICdwYXJzZXJlcnJvcicgPyBkb2MgOiBudWxsO1xcbiAgICAgIH07XFxuXFxuICAgICAgdmFyIHBhcnNlSlNPTiA9ICQucGFyc2VKU09OIHx8IGZ1bmN0aW9uIChzKSB7XFxuICAgICAgICAvKmpzbGludCBldmlsOnRydWUgKi9cXG4gICAgICAgIHJldHVybiB3aW5kb3dbJ2V2YWwnXSgnKCcgKyBzICsgJyknKTtcXG4gICAgICB9O1xcblxcbiAgICAgIHZhciBodHRwRGF0YSA9IGZ1bmN0aW9uIGh0dHBEYXRhKHhociwgdHlwZSwgcykge1xcbiAgICAgICAgLy8gbW9zdGx5IGxpZnRlZCBmcm9tIGpxMS40LjRcXG4gICAgICAgIHZhciBjdCA9IHhoci5nZXRSZXNwb25zZUhlYWRlcignY29udGVudC10eXBlJykgfHwgJycsXFxuICAgICAgICAgICAgeG1sID0gdHlwZSA9PT0gJ3htbCcgfHwgIXR5cGUgJiYgY3QuaW5kZXhPZigneG1sJykgPj0gMCxcXG4gICAgICAgICAgICBkYXRhID0geG1sID8geGhyLnJlc3BvbnNlWE1MIDogeGhyLnJlc3BvbnNlVGV4dDtcXG5cXG4gICAgICAgIGlmICh4bWwgJiYgZGF0YS5kb2N1bWVudEVsZW1lbnQubm9kZU5hbWUgPT09ICdwYXJzZXJlcnJvcicpIHtcXG4gICAgICAgICAgaWYgKCQuZXJyb3IpIHtcXG4gICAgICAgICAgICAkLmVycm9yKCdwYXJzZXJlcnJvcicpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAocyAmJiBzLmRhdGFGaWx0ZXIpIHtcXG4gICAgICAgICAgZGF0YSA9IHMuZGF0YUZpbHRlcihkYXRhLCB0eXBlKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcXG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdqc29uJyB8fCAhdHlwZSAmJiBjdC5pbmRleE9mKCdqc29uJykgPj0gMCkge1xcbiAgICAgICAgICAgIGRhdGEgPSBwYXJzZUpTT04oZGF0YSk7XFxuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXFxcInNjcmlwdFxcXCIgfHwgIXR5cGUgJiYgY3QuaW5kZXhPZihcXFwiamF2YXNjcmlwdFxcXCIpID49IDApIHtcXG4gICAgICAgICAgICAkLmdsb2JhbEV2YWwoZGF0YSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiBkYXRhO1xcbiAgICAgIH07XFxuXFxuICAgICAgcmV0dXJuIGRlZmVycmVkO1xcbiAgICB9XFxuICB9O1xcbiAgLyoqXFxuICAgKiBhamF4Rm9ybSgpIHByb3ZpZGVzIGEgbWVjaGFuaXNtIGZvciBmdWxseSBhdXRvbWF0aW5nIGZvcm0gc3VibWlzc2lvbi5cXG4gICAqXFxuICAgKiBUaGUgYWR2YW50YWdlcyBvZiB1c2luZyB0aGlzIG1ldGhvZCBpbnN0ZWFkIG9mIGFqYXhTdWJtaXQoKSBhcmU6XFxuICAgKlxcbiAgICogMTogVGhpcyBtZXRob2Qgd2lsbCBpbmNsdWRlIGNvb3JkaW5hdGVzIGZvciA8aW5wdXQgdHlwZT1cXFwiaW1hZ2VcXFwiIC8+IGVsZW1lbnRzIChpZiB0aGUgZWxlbWVudFxcbiAgICogICAgaXMgdXNlZCB0byBzdWJtaXQgdGhlIGZvcm0pLlxcbiAgICogMi4gVGhpcyBtZXRob2Qgd2lsbCBpbmNsdWRlIHRoZSBzdWJtaXQgZWxlbWVudCdzIG5hbWUvdmFsdWUgZGF0YSAoZm9yIHRoZSBlbGVtZW50IHRoYXQgd2FzXFxuICAgKiAgICB1c2VkIHRvIHN1Ym1pdCB0aGUgZm9ybSkuXFxuICAgKiAzLiBUaGlzIG1ldGhvZCBiaW5kcyB0aGUgc3VibWl0KCkgbWV0aG9kIHRvIHRoZSBmb3JtIGZvciB5b3UuXFxuICAgKlxcbiAgICogVGhlIG9wdGlvbnMgYXJndW1lbnQgZm9yIGFqYXhGb3JtIHdvcmtzIGV4YWN0bHkgYXMgaXQgZG9lcyBmb3IgYWpheFN1Ym1pdC4gIGFqYXhGb3JtIG1lcmVseVxcbiAgICogcGFzc2VzIHRoZSBvcHRpb25zIGFyZ3VtZW50IGFsb25nIGFmdGVyIHByb3Blcmx5IGJpbmRpbmcgZXZlbnRzIGZvciBzdWJtaXQgZWxlbWVudHMgYW5kXFxuICAgKiB0aGUgZm9ybSBpdHNlbGYuXFxuICAgKi9cXG5cXG5cXG4gICQuZm4uYWpheEZvcm0gPSBmdW5jdGlvbiAob3B0aW9ucykge1xcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcXG4gICAgb3B0aW9ucy5kZWxlZ2F0aW9uID0gb3B0aW9ucy5kZWxlZ2F0aW9uICYmICQuaXNGdW5jdGlvbigkLmZuLm9uKTsgLy8gaW4galF1ZXJ5IDEuMysgd2UgY2FuIGZpeCBtaXN0YWtlcyB3aXRoIHRoZSByZWFkeSBzdGF0ZVxcblxcbiAgICBpZiAoIW9wdGlvbnMuZGVsZWdhdGlvbiAmJiB0aGlzLmxlbmd0aCA9PT0gMCkge1xcbiAgICAgIHZhciBvID0ge1xcbiAgICAgICAgczogdGhpcy5zZWxlY3RvcixcXG4gICAgICAgIGM6IHRoaXMuY29udGV4dFxcbiAgICAgIH07XFxuXFxuICAgICAgaWYgKCEkLmlzUmVhZHkgJiYgby5zKSB7XFxuICAgICAgICBsb2coJ0RPTSBub3QgcmVhZHksIHF1ZXVpbmcgYWpheEZvcm0nKTtcXG4gICAgICAgICQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAkKG8ucywgby5jKS5hamF4Rm9ybShvcHRpb25zKTtcXG4gICAgICAgIH0pO1xcbiAgICAgICAgcmV0dXJuIHRoaXM7XFxuICAgICAgfSAvLyBpcyB5b3VyIERPTSByZWFkeT8gIGh0dHA6Ly9kb2NzLmpxdWVyeS5jb20vVHV0b3JpYWxzOkludHJvZHVjaW5nXyQoZG9jdW1lbnQpLnJlYWR5KClcXG5cXG5cXG4gICAgICBsb2coJ3Rlcm1pbmF0aW5nOyB6ZXJvIGVsZW1lbnRzIGZvdW5kIGJ5IHNlbGVjdG9yJyArICgkLmlzUmVhZHkgPyAnJyA6ICcgKERPTSBub3QgcmVhZHkpJykpO1xcbiAgICAgIHJldHVybiB0aGlzO1xcbiAgICB9XFxuXFxuICAgIGlmIChvcHRpb25zLmRlbGVnYXRpb24pIHtcXG4gICAgICAkKGRvY3VtZW50KS5vZmYoJ3N1Ym1pdC5mb3JtLXBsdWdpbicsIHRoaXMuc2VsZWN0b3IsIGRvQWpheFN1Ym1pdCkub2ZmKCdjbGljay5mb3JtLXBsdWdpbicsIHRoaXMuc2VsZWN0b3IsIGNhcHR1cmVTdWJtaXR0aW5nRWxlbWVudCkub24oJ3N1Ym1pdC5mb3JtLXBsdWdpbicsIHRoaXMuc2VsZWN0b3IsIG9wdGlvbnMsIGRvQWpheFN1Ym1pdCkub24oJ2NsaWNrLmZvcm0tcGx1Z2luJywgdGhpcy5zZWxlY3Rvciwgb3B0aW9ucywgY2FwdHVyZVN1Ym1pdHRpbmdFbGVtZW50KTtcXG4gICAgICByZXR1cm4gdGhpcztcXG4gICAgfVxcblxcbiAgICByZXR1cm4gdGhpcy5hamF4Rm9ybVVuYmluZCgpLmJpbmQoJ3N1Ym1pdC5mb3JtLXBsdWdpbicsIG9wdGlvbnMsIGRvQWpheFN1Ym1pdCkuYmluZCgnY2xpY2suZm9ybS1wbHVnaW4nLCBvcHRpb25zLCBjYXB0dXJlU3VibWl0dGluZ0VsZW1lbnQpO1xcbiAgfTsgLy8gcHJpdmF0ZSBldmVudCBoYW5kbGVyc1xcblxcblxcbiAgZnVuY3Rpb24gZG9BamF4U3VibWl0KGUpIHtcXG4gICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cXG4gICAgdmFyIG9wdGlvbnMgPSBlLmRhdGE7XFxuXFxuICAgIGlmICghZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xcbiAgICAgIC8vIGlmIGV2ZW50IGhhcyBiZWVuIGNhbmNlbGVkLCBkb24ndCBwcm9jZWVkXFxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICQoZS50YXJnZXQpLmFqYXhTdWJtaXQob3B0aW9ucyk7IC8vICMzNjVcXG4gICAgfVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gY2FwdHVyZVN1Ym1pdHRpbmdFbGVtZW50KGUpIHtcXG4gICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cXG4gICAgdmFyIHRhcmdldCA9IGUudGFyZ2V0O1xcbiAgICB2YXIgJGVsID0gJCh0YXJnZXQpO1xcblxcbiAgICBpZiAoISRlbC5pcyhcXFwiW3R5cGU9c3VibWl0XSxbdHlwZT1pbWFnZV1cXFwiKSkge1xcbiAgICAgIC8vIGlzIHRoaXMgYSBjaGlsZCBlbGVtZW50IG9mIHRoZSBzdWJtaXQgZWw/ICAoZXg6IGEgc3BhbiB3aXRoaW4gYSBidXR0b24pXFxuICAgICAgdmFyIHQgPSAkZWwuY2xvc2VzdCgnW3R5cGU9c3VibWl0XScpO1xcblxcbiAgICAgIGlmICh0Lmxlbmd0aCA9PT0gMCkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICB0YXJnZXQgPSB0WzBdO1xcbiAgICB9XFxuXFxuICAgIHZhciBmb3JtID0gdGhpcztcXG4gICAgZm9ybS5jbGsgPSB0YXJnZXQ7XFxuXFxuICAgIGlmICh0YXJnZXQudHlwZSA9PSAnaW1hZ2UnKSB7XFxuICAgICAgaWYgKGUub2Zmc2V0WCAhPT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICBmb3JtLmNsa194ID0gZS5vZmZzZXRYO1xcbiAgICAgICAgZm9ybS5jbGtfeSA9IGUub2Zmc2V0WTtcXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiAkLmZuLm9mZnNldCA9PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICB2YXIgb2Zmc2V0ID0gJGVsLm9mZnNldCgpO1xcbiAgICAgICAgZm9ybS5jbGtfeCA9IGUucGFnZVggLSBvZmZzZXQubGVmdDtcXG4gICAgICAgIGZvcm0uY2xrX3kgPSBlLnBhZ2VZIC0gb2Zmc2V0LnRvcDtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgZm9ybS5jbGtfeCA9IGUucGFnZVggLSB0YXJnZXQub2Zmc2V0TGVmdDtcXG4gICAgICAgIGZvcm0uY2xrX3kgPSBlLnBhZ2VZIC0gdGFyZ2V0Lm9mZnNldFRvcDtcXG4gICAgICB9XFxuICAgIH0gLy8gY2xlYXIgZm9ybSB2YXJzXFxuXFxuXFxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgIGZvcm0uY2xrID0gZm9ybS5jbGtfeCA9IGZvcm0uY2xrX3kgPSBudWxsO1xcbiAgICB9LCAxMDApO1xcbiAgfSAvLyBhamF4Rm9ybVVuYmluZCB1bmJpbmRzIHRoZSBldmVudCBoYW5kbGVycyB0aGF0IHdlcmUgYm91bmQgYnkgYWpheEZvcm1cXG5cXG5cXG4gICQuZm4uYWpheEZvcm1VbmJpbmQgPSBmdW5jdGlvbiAoKSB7XFxuICAgIHJldHVybiB0aGlzLnVuYmluZCgnc3VibWl0LmZvcm0tcGx1Z2luIGNsaWNrLmZvcm0tcGx1Z2luJyk7XFxuICB9O1xcbiAgLyoqXFxuICAgKiBmb3JtVG9BcnJheSgpIGdhdGhlcnMgZm9ybSBlbGVtZW50IGRhdGEgaW50byBhbiBhcnJheSBvZiBvYmplY3RzIHRoYXQgY2FuXFxuICAgKiBiZSBwYXNzZWQgdG8gYW55IG9mIHRoZSBmb2xsb3dpbmcgYWpheCBmdW5jdGlvbnM6ICQuZ2V0LCAkLnBvc3QsIG9yIGxvYWQuXFxuICAgKiBFYWNoIG9iamVjdCBpbiB0aGUgYXJyYXkgaGFzIGJvdGggYSAnbmFtZScgYW5kICd2YWx1ZScgcHJvcGVydHkuICBBbiBleGFtcGxlIG9mXFxuICAgKiBhbiBhcnJheSBmb3IgYSBzaW1wbGUgbG9naW4gZm9ybSBtaWdodCBiZTpcXG4gICAqXFxuICAgKiBbIHsgbmFtZTogJ3VzZXJuYW1lJywgdmFsdWU6ICdqcmVzaWcnIH0sIHsgbmFtZTogJ3Bhc3N3b3JkJywgdmFsdWU6ICdzZWNyZXQnIH0gXVxcbiAgICpcXG4gICAqIEl0IGlzIHRoaXMgYXJyYXkgdGhhdCBpcyBwYXNzZWQgdG8gcHJlLXN1Ym1pdCBjYWxsYmFjayBmdW5jdGlvbnMgcHJvdmlkZWQgdG8gdGhlXFxuICAgKiBhamF4U3VibWl0KCkgYW5kIGFqYXhGb3JtKCkgbWV0aG9kcy5cXG4gICAqL1xcblxcblxcbiAgJC5mbi5mb3JtVG9BcnJheSA9IGZ1bmN0aW9uIChzZW1hbnRpYywgZWxlbWVudHMpIHtcXG4gICAgdmFyIGEgPSBbXTtcXG5cXG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB7XFxuICAgICAgcmV0dXJuIGE7XFxuICAgIH1cXG5cXG4gICAgdmFyIGZvcm0gPSB0aGlzWzBdO1xcbiAgICB2YXIgZm9ybUlkID0gdGhpcy5hdHRyKCdpZCcpO1xcbiAgICB2YXIgZWxzID0gc2VtYW50aWMgPyBmb3JtLmdldEVsZW1lbnRzQnlUYWdOYW1lKCcqJykgOiBmb3JtLmVsZW1lbnRzO1xcbiAgICB2YXIgZWxzMjtcXG5cXG4gICAgaWYgKGVscyAmJiAhL01TSUUgWzY3OF0vLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcXG4gICAgICAvLyAjMzkwXFxuICAgICAgZWxzID0gJChlbHMpLmdldCgpOyAvLyBjb252ZXJ0IHRvIHN0YW5kYXJkIGFycmF5XFxuICAgIH0gLy8gIzM4NjsgYWNjb3VudCBmb3IgaW5wdXRzIG91dHNpZGUgdGhlIGZvcm0gd2hpY2ggdXNlIHRoZSAnZm9ybScgYXR0cmlidXRlXFxuXFxuXFxuICAgIGlmIChmb3JtSWQpIHtcXG4gICAgICBlbHMyID0gJCgnOmlucHV0W2Zvcm09XFxcIicgKyBmb3JtSWQgKyAnXFxcIl0nKS5nZXQoKTsgLy8gaGF0IHRpcCBAdGhldFxcblxcbiAgICAgIGlmIChlbHMyLmxlbmd0aCkge1xcbiAgICAgICAgZWxzID0gKGVscyB8fCBbXSkuY29uY2F0KGVsczIpO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBpZiAoIWVscyB8fCAhZWxzLmxlbmd0aCkge1xcbiAgICAgIHJldHVybiBhO1xcbiAgICB9XFxuXFxuICAgIHZhciBpLCBqLCBuLCB2LCBlbCwgbWF4LCBqbWF4O1xcblxcbiAgICBmb3IgKGkgPSAwLCBtYXggPSBlbHMubGVuZ3RoOyBpIDwgbWF4OyBpKyspIHtcXG4gICAgICBlbCA9IGVsc1tpXTtcXG4gICAgICBuID0gZWwubmFtZTtcXG5cXG4gICAgICBpZiAoIW4gfHwgZWwuZGlzYWJsZWQpIHtcXG4gICAgICAgIGNvbnRpbnVlO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoc2VtYW50aWMgJiYgZm9ybS5jbGsgJiYgZWwudHlwZSA9PSBcXFwiaW1hZ2VcXFwiKSB7XFxuICAgICAgICAvLyBoYW5kbGUgaW1hZ2UgaW5wdXRzIG9uIHRoZSBmbHkgd2hlbiBzZW1hbnRpYyA9PSB0cnVlXFxuICAgICAgICBpZiAoZm9ybS5jbGsgPT0gZWwpIHtcXG4gICAgICAgICAgYS5wdXNoKHtcXG4gICAgICAgICAgICBuYW1lOiBuLFxcbiAgICAgICAgICAgIHZhbHVlOiAkKGVsKS52YWwoKSxcXG4gICAgICAgICAgICB0eXBlOiBlbC50eXBlXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgICBhLnB1c2goe1xcbiAgICAgICAgICAgIG5hbWU6IG4gKyAnLngnLFxcbiAgICAgICAgICAgIHZhbHVlOiBmb3JtLmNsa194XFxuICAgICAgICAgIH0sIHtcXG4gICAgICAgICAgICBuYW1lOiBuICsgJy55JyxcXG4gICAgICAgICAgICB2YWx1ZTogZm9ybS5jbGtfeVxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGNvbnRpbnVlO1xcbiAgICAgIH1cXG5cXG4gICAgICB2ID0gJC5maWVsZFZhbHVlKGVsLCB0cnVlKTtcXG5cXG4gICAgICBpZiAodiAmJiB2LmNvbnN0cnVjdG9yID09IEFycmF5KSB7XFxuICAgICAgICBpZiAoZWxlbWVudHMpIHtcXG4gICAgICAgICAgZWxlbWVudHMucHVzaChlbCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBmb3IgKGogPSAwLCBqbWF4ID0gdi5sZW5ndGg7IGogPCBqbWF4OyBqKyspIHtcXG4gICAgICAgICAgYS5wdXNoKHtcXG4gICAgICAgICAgICBuYW1lOiBuLFxcbiAgICAgICAgICAgIHZhbHVlOiB2W2pdXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSBpZiAoZmVhdHVyZS5maWxlYXBpICYmIGVsLnR5cGUgPT0gJ2ZpbGUnKSB7XFxuICAgICAgICBpZiAoZWxlbWVudHMpIHtcXG4gICAgICAgICAgZWxlbWVudHMucHVzaChlbCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB2YXIgZmlsZXMgPSBlbC5maWxlcztcXG5cXG4gICAgICAgIGlmIChmaWxlcy5sZW5ndGgpIHtcXG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGZpbGVzLmxlbmd0aDsgaisrKSB7XFxuICAgICAgICAgICAgYS5wdXNoKHtcXG4gICAgICAgICAgICAgIG5hbWU6IG4sXFxuICAgICAgICAgICAgICB2YWx1ZTogZmlsZXNbal0sXFxuICAgICAgICAgICAgICB0eXBlOiBlbC50eXBlXFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIC8vICMxODBcXG4gICAgICAgICAgYS5wdXNoKHtcXG4gICAgICAgICAgICBuYW1lOiBuLFxcbiAgICAgICAgICAgIHZhbHVlOiAnJyxcXG4gICAgICAgICAgICB0eXBlOiBlbC50eXBlXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSBpZiAodiAhPT0gbnVsbCAmJiB0eXBlb2YgdiAhPSAndW5kZWZpbmVkJykge1xcbiAgICAgICAgaWYgKGVsZW1lbnRzKSB7XFxuICAgICAgICAgIGVsZW1lbnRzLnB1c2goZWwpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgYS5wdXNoKHtcXG4gICAgICAgICAgbmFtZTogbixcXG4gICAgICAgICAgdmFsdWU6IHYsXFxuICAgICAgICAgIHR5cGU6IGVsLnR5cGUsXFxuICAgICAgICAgIHJlcXVpcmVkOiBlbC5yZXF1aXJlZFxcbiAgICAgICAgfSk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGlmICghc2VtYW50aWMgJiYgZm9ybS5jbGspIHtcXG4gICAgICAvLyBpbnB1dCB0eXBlPT0naW1hZ2UnIGFyZSBub3QgZm91bmQgaW4gZWxlbWVudHMgYXJyYXkhIGhhbmRsZSBpdCBoZXJlXFxuICAgICAgdmFyICRpbnB1dCA9ICQoZm9ybS5jbGspLFxcbiAgICAgICAgICBpbnB1dCA9ICRpbnB1dFswXTtcXG4gICAgICBuID0gaW5wdXQubmFtZTtcXG5cXG4gICAgICBpZiAobiAmJiAhaW5wdXQuZGlzYWJsZWQgJiYgaW5wdXQudHlwZSA9PSAnaW1hZ2UnKSB7XFxuICAgICAgICBhLnB1c2goe1xcbiAgICAgICAgICBuYW1lOiBuLFxcbiAgICAgICAgICB2YWx1ZTogJGlucHV0LnZhbCgpXFxuICAgICAgICB9KTtcXG4gICAgICAgIGEucHVzaCh7XFxuICAgICAgICAgIG5hbWU6IG4gKyAnLngnLFxcbiAgICAgICAgICB2YWx1ZTogZm9ybS5jbGtfeFxcbiAgICAgICAgfSwge1xcbiAgICAgICAgICBuYW1lOiBuICsgJy55JyxcXG4gICAgICAgICAgdmFsdWU6IGZvcm0uY2xrX3lcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICByZXR1cm4gYTtcXG4gIH07XFxuICAvKipcXG4gICAqIFNlcmlhbGl6ZXMgZm9ybSBkYXRhIGludG8gYSAnc3VibWl0dGFibGUnIHN0cmluZy4gVGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gYSBzdHJpbmdcXG4gICAqIGluIHRoZSBmb3JtYXQ6IG5hbWUxPXZhbHVlMSZhbXA7bmFtZTI9dmFsdWUyXFxuICAgKi9cXG5cXG5cXG4gICQuZm4uZm9ybVNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChzZW1hbnRpYykge1xcbiAgICAvL2hhbmQgb2ZmIHRvIGpRdWVyeS5wYXJhbSBmb3IgcHJvcGVyIGVuY29kaW5nXFxuICAgIHJldHVybiAkLnBhcmFtKHRoaXMuZm9ybVRvQXJyYXkoc2VtYW50aWMpKTtcXG4gIH07XFxuICAvKipcXG4gICAqIFNlcmlhbGl6ZXMgYWxsIGZpZWxkIGVsZW1lbnRzIGluIHRoZSBqUXVlcnkgb2JqZWN0IGludG8gYSBxdWVyeSBzdHJpbmcuXFxuICAgKiBUaGlzIG1ldGhvZCB3aWxsIHJldHVybiBhIHN0cmluZyBpbiB0aGUgZm9ybWF0OiBuYW1lMT12YWx1ZTEmYW1wO25hbWUyPXZhbHVlMlxcbiAgICovXFxuXFxuXFxuICAkLmZuLmZpZWxkU2VyaWFsaXplID0gZnVuY3Rpb24gKHN1Y2Nlc3NmdWwpIHtcXG4gICAgdmFyIGEgPSBbXTtcXG4gICAgdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICB2YXIgbiA9IHRoaXMubmFtZTtcXG5cXG4gICAgICBpZiAoIW4pIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIHYgPSAkLmZpZWxkVmFsdWUodGhpcywgc3VjY2Vzc2Z1bCk7XFxuXFxuICAgICAgaWYgKHYgJiYgdi5jb25zdHJ1Y3RvciA9PSBBcnJheSkge1xcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG1heCA9IHYubGVuZ3RoOyBpIDwgbWF4OyBpKyspIHtcXG4gICAgICAgICAgYS5wdXNoKHtcXG4gICAgICAgICAgICBuYW1lOiBuLFxcbiAgICAgICAgICAgIHZhbHVlOiB2W2ldXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSBpZiAodiAhPT0gbnVsbCAmJiB0eXBlb2YgdiAhPSAndW5kZWZpbmVkJykge1xcbiAgICAgICAgYS5wdXNoKHtcXG4gICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxcbiAgICAgICAgICB2YWx1ZTogdlxcbiAgICAgICAgfSk7XFxuICAgICAgfVxcbiAgICB9KTsgLy9oYW5kIG9mZiB0byBqUXVlcnkucGFyYW0gZm9yIHByb3BlciBlbmNvZGluZ1xcblxcbiAgICByZXR1cm4gJC5wYXJhbShhKTtcXG4gIH07XFxuICAvKipcXG4gICAqIFJldHVybnMgdGhlIHZhbHVlKHMpIG9mIHRoZSBlbGVtZW50IGluIHRoZSBtYXRjaGVkIHNldC4gIEZvciBleGFtcGxlLCBjb25zaWRlciB0aGUgZm9sbG93aW5nIGZvcm06XFxuICAgKlxcbiAgICogIDxmb3JtPjxmaWVsZHNldD5cXG4gICAqICAgICAgPGlucHV0IG5hbWU9XFxcIkFcXFwiIHR5cGU9XFxcInRleHRcXFwiIC8+XFxuICAgKiAgICAgIDxpbnB1dCBuYW1lPVxcXCJBXFxcIiB0eXBlPVxcXCJ0ZXh0XFxcIiAvPlxcbiAgICogICAgICA8aW5wdXQgbmFtZT1cXFwiQlxcXCIgdHlwZT1cXFwiY2hlY2tib3hcXFwiIHZhbHVlPVxcXCJCMVxcXCIgLz5cXG4gICAqICAgICAgPGlucHV0IG5hbWU9XFxcIkJcXFwiIHR5cGU9XFxcImNoZWNrYm94XFxcIiB2YWx1ZT1cXFwiQjJcXFwiLz5cXG4gICAqICAgICAgPGlucHV0IG5hbWU9XFxcIkNcXFwiIHR5cGU9XFxcInJhZGlvXFxcIiB2YWx1ZT1cXFwiQzFcXFwiIC8+XFxuICAgKiAgICAgIDxpbnB1dCBuYW1lPVxcXCJDXFxcIiB0eXBlPVxcXCJyYWRpb1xcXCIgdmFsdWU9XFxcIkMyXFxcIiAvPlxcbiAgICogIDwvZmllbGRzZXQ+PC9mb3JtPlxcbiAgICpcXG4gICAqICB2YXIgdiA9ICQoJ2lucHV0W3R5cGU9dGV4dF0nKS5maWVsZFZhbHVlKCk7XFxuICAgKiAgLy8gaWYgbm8gdmFsdWVzIGFyZSBlbnRlcmVkIGludG8gdGhlIHRleHQgaW5wdXRzXFxuICAgKiAgdiA9PSBbJycsJyddXFxuICAgKiAgLy8gaWYgdmFsdWVzIGVudGVyZWQgaW50byB0aGUgdGV4dCBpbnB1dHMgYXJlICdmb28nIGFuZCAnYmFyJ1xcbiAgICogIHYgPT0gWydmb28nLCdiYXInXVxcbiAgICpcXG4gICAqICB2YXIgdiA9ICQoJ2lucHV0W3R5cGU9Y2hlY2tib3hdJykuZmllbGRWYWx1ZSgpO1xcbiAgICogIC8vIGlmIG5laXRoZXIgY2hlY2tib3ggaXMgY2hlY2tlZFxcbiAgICogIHYgPT09IHVuZGVmaW5lZFxcbiAgICogIC8vIGlmIGJvdGggY2hlY2tib3hlcyBhcmUgY2hlY2tlZFxcbiAgICogIHYgPT0gWydCMScsICdCMiddXFxuICAgKlxcbiAgICogIHZhciB2ID0gJCgnaW5wdXRbdHlwZT1yYWRpb10nKS5maWVsZFZhbHVlKCk7XFxuICAgKiAgLy8gaWYgbmVpdGhlciByYWRpbyBpcyBjaGVja2VkXFxuICAgKiAgdiA9PT0gdW5kZWZpbmVkXFxuICAgKiAgLy8gaWYgZmlyc3QgcmFkaW8gaXMgY2hlY2tlZFxcbiAgICogIHYgPT0gWydDMSddXFxuICAgKlxcbiAgICogVGhlIHN1Y2Nlc3NmdWwgYXJndW1lbnQgY29udHJvbHMgd2hldGhlciBvciBub3QgdGhlIGZpZWxkIGVsZW1lbnQgbXVzdCBiZSAnc3VjY2Vzc2Z1bCdcXG4gICAqIChwZXIgaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDQvaW50ZXJhY3QvZm9ybXMuaHRtbCNzdWNjZXNzZnVsLWNvbnRyb2xzKS5cXG4gICAqIFRoZSBkZWZhdWx0IHZhbHVlIG9mIHRoZSBzdWNjZXNzZnVsIGFyZ3VtZW50IGlzIHRydWUuICBJZiB0aGlzIHZhbHVlIGlzIGZhbHNlIHRoZSB2YWx1ZShzKVxcbiAgICogZm9yIGVhY2ggZWxlbWVudCBpcyByZXR1cm5lZC5cXG4gICAqXFxuICAgKiBOb3RlOiBUaGlzIG1ldGhvZCAqYWx3YXlzKiByZXR1cm5zIGFuIGFycmF5LiAgSWYgbm8gdmFsaWQgdmFsdWUgY2FuIGJlIGRldGVybWluZWQgdGhlXFxuICAgKiAgICBhcnJheSB3aWxsIGJlIGVtcHR5LCBvdGhlcndpc2UgaXQgd2lsbCBjb250YWluIG9uZSBvciBtb3JlIHZhbHVlcy5cXG4gICAqL1xcblxcblxcbiAgJC5mbi5maWVsZFZhbHVlID0gZnVuY3Rpb24gKHN1Y2Nlc3NmdWwpIHtcXG4gICAgZm9yICh2YXIgdmFsID0gW10sIGkgPSAwLCBtYXggPSB0aGlzLmxlbmd0aDsgaSA8IG1heDsgaSsrKSB7XFxuICAgICAgdmFyIGVsID0gdGhpc1tpXTtcXG4gICAgICB2YXIgdiA9ICQuZmllbGRWYWx1ZShlbCwgc3VjY2Vzc2Z1bCk7XFxuXFxuICAgICAgaWYgKHYgPT09IG51bGwgfHwgdHlwZW9mIHYgPT0gJ3VuZGVmaW5lZCcgfHwgdi5jb25zdHJ1Y3RvciA9PSBBcnJheSAmJiAhdi5sZW5ndGgpIHtcXG4gICAgICAgIGNvbnRpbnVlO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodi5jb25zdHJ1Y3RvciA9PSBBcnJheSkge1xcbiAgICAgICAgJC5tZXJnZSh2YWwsIHYpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB2YWwucHVzaCh2KTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHZhbDtcXG4gIH07XFxuICAvKipcXG4gICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBmaWVsZCBlbGVtZW50LlxcbiAgICovXFxuXFxuXFxuICAkLmZpZWxkVmFsdWUgPSBmdW5jdGlvbiAoZWwsIHN1Y2Nlc3NmdWwpIHtcXG4gICAgdmFyIG4gPSBlbC5uYW1lLFxcbiAgICAgICAgdCA9IGVsLnR5cGUsXFxuICAgICAgICB0YWcgPSBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XFxuXFxuICAgIGlmIChzdWNjZXNzZnVsID09PSB1bmRlZmluZWQpIHtcXG4gICAgICBzdWNjZXNzZnVsID0gdHJ1ZTtcXG4gICAgfVxcblxcbiAgICBpZiAoc3VjY2Vzc2Z1bCAmJiAoIW4gfHwgZWwuZGlzYWJsZWQgfHwgdCA9PSAncmVzZXQnIHx8IHQgPT0gJ2J1dHRvbicgfHwgKHQgPT0gJ2NoZWNrYm94JyB8fCB0ID09ICdyYWRpbycpICYmICFlbC5jaGVja2VkIHx8ICh0ID09ICdzdWJtaXQnIHx8IHQgPT0gJ2ltYWdlJykgJiYgZWwuZm9ybSAmJiBlbC5mb3JtLmNsayAhPSBlbCB8fCB0YWcgPT0gJ3NlbGVjdCcgJiYgZWwuc2VsZWN0ZWRJbmRleCA9PSAtMSkpIHtcXG4gICAgICByZXR1cm4gbnVsbDtcXG4gICAgfVxcblxcbiAgICBpZiAodGFnID09ICdzZWxlY3QnKSB7XFxuICAgICAgdmFyIGluZGV4ID0gZWwuc2VsZWN0ZWRJbmRleDtcXG5cXG4gICAgICBpZiAoaW5kZXggPCAwKSB7XFxuICAgICAgICByZXR1cm4gbnVsbDtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIGEgPSBbXSxcXG4gICAgICAgICAgb3BzID0gZWwub3B0aW9ucztcXG4gICAgICB2YXIgb25lID0gdCA9PSAnc2VsZWN0LW9uZSc7XFxuICAgICAgdmFyIG1heCA9IG9uZSA/IGluZGV4ICsgMSA6IG9wcy5sZW5ndGg7XFxuXFxuICAgICAgZm9yICh2YXIgaSA9IG9uZSA/IGluZGV4IDogMDsgaSA8IG1heDsgaSsrKSB7XFxuICAgICAgICB2YXIgb3AgPSBvcHNbaV07XFxuXFxuICAgICAgICBpZiAob3Auc2VsZWN0ZWQpIHtcXG4gICAgICAgICAgdmFyIHYgPSBvcC52YWx1ZTtcXG5cXG4gICAgICAgICAgaWYgKCF2KSB7XFxuICAgICAgICAgICAgLy8gZXh0cmEgcGFpbiBmb3IgSUUuLi5cXG4gICAgICAgICAgICB2ID0gb3AuYXR0cmlidXRlcyAmJiBvcC5hdHRyaWJ1dGVzLnZhbHVlICYmICFvcC5hdHRyaWJ1dGVzLnZhbHVlLnNwZWNpZmllZCA/IG9wLnRleHQgOiBvcC52YWx1ZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAob25lKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHY7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgYS5wdXNoKHYpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gYTtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gJChlbCkudmFsKCk7XFxuICB9O1xcbiAgLyoqXFxuICAgKiBDbGVhcnMgdGhlIGZvcm0gZGF0YS4gIFRha2VzIHRoZSBmb2xsb3dpbmcgYWN0aW9ucyBvbiB0aGUgZm9ybSdzIGlucHV0IGZpZWxkczpcXG4gICAqICAtIGlucHV0IHRleHQgZmllbGRzIHdpbGwgaGF2ZSB0aGVpciAndmFsdWUnIHByb3BlcnR5IHNldCB0byB0aGUgZW1wdHkgc3RyaW5nXFxuICAgKiAgLSBzZWxlY3QgZWxlbWVudHMgd2lsbCBoYXZlIHRoZWlyICdzZWxlY3RlZEluZGV4JyBwcm9wZXJ0eSBzZXQgdG8gLTFcXG4gICAqICAtIGNoZWNrYm94IGFuZCByYWRpbyBpbnB1dHMgd2lsbCBoYXZlIHRoZWlyICdjaGVja2VkJyBwcm9wZXJ0eSBzZXQgdG8gZmFsc2VcXG4gICAqICAtIGlucHV0cyBvZiB0eXBlIHN1Ym1pdCwgYnV0dG9uLCByZXNldCwgYW5kIGhpZGRlbiB3aWxsICpub3QqIGJlIGVmZmVjdGVkXFxuICAgKiAgLSBidXR0b24gZWxlbWVudHMgd2lsbCAqbm90KiBiZSBlZmZlY3RlZFxcbiAgICovXFxuXFxuXFxuICAkLmZuLmNsZWFyRm9ybSA9IGZ1bmN0aW9uIChpbmNsdWRlSGlkZGVuKSB7XFxuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICQoJ2lucHV0LHNlbGVjdCx0ZXh0YXJlYScsIHRoaXMpLmNsZWFyRmllbGRzKGluY2x1ZGVIaWRkZW4pO1xcbiAgICB9KTtcXG4gIH07XFxuICAvKipcXG4gICAqIENsZWFycyB0aGUgc2VsZWN0ZWQgZm9ybSBlbGVtZW50cy5cXG4gICAqL1xcblxcblxcbiAgJC5mbi5jbGVhckZpZWxkcyA9ICQuZm4uY2xlYXJJbnB1dHMgPSBmdW5jdGlvbiAoaW5jbHVkZUhpZGRlbikge1xcbiAgICB2YXIgcmUgPSAvXig/OmNvbG9yfGRhdGV8ZGF0ZXRpbWV8ZW1haWx8bW9udGh8bnVtYmVyfHBhc3N3b3JkfHJhbmdlfHNlYXJjaHx0ZWx8dGV4dHx0aW1lfHVybHx3ZWVrKSQvaTsgLy8gJ2hpZGRlbicgaXMgbm90IGluIHRoaXMgbGlzdFxcblxcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICB2YXIgdCA9IHRoaXMudHlwZSxcXG4gICAgICAgICAgdGFnID0gdGhpcy50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XFxuXFxuICAgICAgaWYgKHJlLnRlc3QodCkgfHwgdGFnID09ICd0ZXh0YXJlYScpIHtcXG4gICAgICAgIHRoaXMudmFsdWUgPSAnJztcXG4gICAgICB9IGVsc2UgaWYgKHQgPT0gJ2NoZWNrYm94JyB8fCB0ID09ICdyYWRpbycpIHtcXG4gICAgICAgIHRoaXMuY2hlY2tlZCA9IGZhbHNlO1xcbiAgICAgIH0gZWxzZSBpZiAodGFnID09ICdzZWxlY3QnKSB7XFxuICAgICAgICB0aGlzLnNlbGVjdGVkSW5kZXggPSAtMTtcXG4gICAgICB9IGVsc2UgaWYgKHQgPT0gXFxcImZpbGVcXFwiKSB7XFxuICAgICAgICBpZiAoL01TSUUvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcXG4gICAgICAgICAgJCh0aGlzKS5yZXBsYWNlV2l0aCgkKHRoaXMpLmNsb25lKHRydWUpKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICQodGhpcykudmFsKCcnKTtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2UgaWYgKGluY2x1ZGVIaWRkZW4pIHtcXG4gICAgICAgIC8vIGluY2x1ZGVIaWRkZW4gY2FuIGJlIHRoZSB2YWx1ZSB0cnVlLCBvciBpdCBjYW4gYmUgYSBzZWxlY3RvciBzdHJpbmdcXG4gICAgICAgIC8vIGluZGljYXRpbmcgYSBzcGVjaWFsIHRlc3Q7IGZvciBleGFtcGxlOlxcbiAgICAgICAgLy8gICQoJyNteUZvcm0nKS5jbGVhckZvcm0oJy5zcGVjaWFsOmhpZGRlbicpXFxuICAgICAgICAvLyB0aGUgYWJvdmUgd291bGQgY2xlYW4gaGlkZGVuIGlucHV0cyB0aGF0IGhhdmUgdGhlIGNsYXNzIG9mICdzcGVjaWFsJ1xcbiAgICAgICAgaWYgKGluY2x1ZGVIaWRkZW4gPT09IHRydWUgJiYgL2hpZGRlbi8udGVzdCh0KSB8fCB0eXBlb2YgaW5jbHVkZUhpZGRlbiA9PSAnc3RyaW5nJyAmJiAkKHRoaXMpLmlzKGluY2x1ZGVIaWRkZW4pKSB7XFxuICAgICAgICAgIHRoaXMudmFsdWUgPSAnJztcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH0pO1xcbiAgfTtcXG4gIC8qKlxcbiAgICogUmVzZXRzIHRoZSBmb3JtIGRhdGEuICBDYXVzZXMgYWxsIGZvcm0gZWxlbWVudHMgdG8gYmUgcmVzZXQgdG8gdGhlaXIgb3JpZ2luYWwgdmFsdWUuXFxuICAgKi9cXG5cXG5cXG4gICQuZm4ucmVzZXRGb3JtID0gZnVuY3Rpb24gKCkge1xcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAvLyBndWFyZCBhZ2FpbnN0IGFuIGlucHV0IHdpdGggdGhlIG5hbWUgb2YgJ3Jlc2V0J1xcbiAgICAgIC8vIG5vdGUgdGhhdCBJRSByZXBvcnRzIHRoZSByZXNldCBmdW5jdGlvbiBhcyBhbiAnb2JqZWN0J1xcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5yZXNldCA9PSAnZnVuY3Rpb24nIHx8IF90eXBlb2YodGhpcy5yZXNldCkgPT0gJ29iamVjdCcgJiYgIXRoaXMucmVzZXQubm9kZVR5cGUpIHtcXG4gICAgICAgIHRoaXMucmVzZXQoKTtcXG4gICAgICB9XFxuICAgIH0pO1xcbiAgfTtcXG4gIC8qKlxcbiAgICogRW5hYmxlcyBvciBkaXNhYmxlcyBhbnkgbWF0Y2hpbmcgZWxlbWVudHMuXFxuICAgKi9cXG5cXG5cXG4gICQuZm4uZW5hYmxlID0gZnVuY3Rpb24gKGIpIHtcXG4gICAgaWYgKGIgPT09IHVuZGVmaW5lZCkge1xcbiAgICAgIGIgPSB0cnVlO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgIHRoaXMuZGlzYWJsZWQgPSAhYjtcXG4gICAgfSk7XFxuICB9O1xcbiAgLyoqXFxuICAgKiBDaGVja3MvdW5jaGVja3MgYW55IG1hdGNoaW5nIGNoZWNrYm94ZXMgb3IgcmFkaW8gYnV0dG9ucyBhbmRcXG4gICAqIHNlbGVjdHMvZGVzZWxlY3RzIGFuZCBtYXRjaGluZyBvcHRpb24gZWxlbWVudHMuXFxuICAgKi9cXG5cXG5cXG4gICQuZm4uc2VsZWN0ZWQgPSBmdW5jdGlvbiAoc2VsZWN0KSB7XFxuICAgIGlmIChzZWxlY3QgPT09IHVuZGVmaW5lZCkge1xcbiAgICAgIHNlbGVjdCA9IHRydWU7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgdmFyIHQgPSB0aGlzLnR5cGU7XFxuXFxuICAgICAgaWYgKHQgPT0gJ2NoZWNrYm94JyB8fCB0ID09ICdyYWRpbycpIHtcXG4gICAgICAgIHRoaXMuY2hlY2tlZCA9IHNlbGVjdDtcXG4gICAgICB9IGVsc2UgaWYgKHRoaXMudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09ICdvcHRpb24nKSB7XFxuICAgICAgICB2YXIgJHNlbCA9ICQodGhpcykucGFyZW50KCdzZWxlY3QnKTtcXG5cXG4gICAgICAgIGlmIChzZWxlY3QgJiYgJHNlbFswXSAmJiAkc2VsWzBdLnR5cGUgPT0gJ3NlbGVjdC1vbmUnKSB7XFxuICAgICAgICAgIC8vIGRlc2VsZWN0IGFsbCBvdGhlciBvcHRpb25zXFxuICAgICAgICAgICRzZWwuZmluZCgnb3B0aW9uJykuc2VsZWN0ZWQoZmFsc2UpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdGhpcy5zZWxlY3RlZCA9IHNlbGVjdDtcXG4gICAgICB9XFxuICAgIH0pO1xcbiAgfTsgLy8gZXhwb3NlIGRlYnVnIHZhclxcblxcblxcbiAgJC5mbi5hamF4U3VibWl0LmRlYnVnID0gZmFsc2U7IC8vIGhlbHBlciBmbiBmb3IgY29uc29sZSBsb2dnaW5nXFxuXFxuICBmdW5jdGlvbiBsb2coKSB7XFxuICAgIGlmICghJC5mbi5hamF4U3VibWl0LmRlYnVnKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIHZhciBtc2cgPSAnW2pxdWVyeS5mb3JtXSAnICsgQXJyYXkucHJvdG90eXBlLmpvaW4uY2FsbChhcmd1bWVudHMsICcnKTtcXG5cXG4gICAgaWYgKHdpbmRvdy5jb25zb2xlICYmIHdpbmRvdy5jb25zb2xlLmxvZykge1xcbiAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyhtc2cpO1xcbiAgICB9IGVsc2UgaWYgKHdpbmRvdy5vcGVyYSAmJiB3aW5kb3cub3BlcmEucG9zdEVycm9yKSB7XFxuICAgICAgd2luZG93Lm9wZXJhLnBvc3RFcnJvcihtc2cpO1xcbiAgICB9XFxuICB9XFxufSk7XCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXFxcInN5bWJvbFxcXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFxcXCJzeW1ib2xcXFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XFxuXFxuLypcXG4gKiBxVGlwMiAtIFByZXR0eSBwb3dlcmZ1bCB0b29sdGlwcyAtIHYyLjIuMS0yOS1cXG4gKiBodHRwOi8vcXRpcDIuY29tXFxuICpcXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgXFxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlc1xcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcXG4gKlxcbiAqIERhdGU6IFR1ZSBEZWMgOCAyMDE1IDA1OjUwIEVTVC0wNTAwXFxuICogUGx1Z2luczogdGlwcyBtb2RhbCB2aWV3cG9ydCBzdmcgaW1hZ2VtYXAgaWU2XFxuICogU3R5bGVzOiBjb3JlIGJhc2ljIGNzczNcXG4gKi9cXG5cXG4vKmdsb2JhbCB3aW5kb3c6IGZhbHNlLCBqUXVlcnk6IGZhbHNlLCBjb25zb2xlOiBmYWxzZSwgZGVmaW5lOiBmYWxzZSAqL1xcblxcbi8qIENhY2hlIHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCAqL1xcbihmdW5jdGlvbiAod2luZG93LCBkb2N1bWVudCwgdW5kZWZpbmVkKSB7XFxuICAvLyBVc2VzIEFNRCBvciBicm93c2VyIGdsb2JhbHMgdG8gY3JlYXRlIGEgalF1ZXJ5IHBsdWdpbi5cXG4gIChmdW5jdGlvbiAoZmFjdG9yeSkge1xcbiAgICBcXFwidXNlIHN0cmljdFxcXCI7XFxuXFxuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcXG4gICAgICBkZWZpbmUoWydqcXVlcnknXSwgZmFjdG9yeSk7XFxuICAgIH0gZWxzZSBpZiAoalF1ZXJ5ICYmICFqUXVlcnkuZm4ucXRpcCkge1xcbiAgICAgIGZhY3RvcnkoalF1ZXJ5KTtcXG4gICAgfVxcbiAgfSkoZnVuY3Rpb24gKCQpIHtcXG4gICAgXFxcInVzZSBzdHJpY3RcXFwiOyAvLyBFbmFibGUgRUNNQVNjcmlwdCBcXFwic3RyaWN0XFxcIiBvcGVyYXRpb24gZm9yIHRoaXMgZnVuY3Rpb24uIFNlZSBtb3JlOiBodHRwOi8vZWpvaG4ub3JnL2Jsb2cvZWNtYXNjcmlwdC01LXN0cmljdC1tb2RlLWpzb24tYW5kLW1vcmUvXFxuXFxuICAgIDsgLy8gTXVuZ2UgdGhlIHByaW1pdGl2ZXMgLSBQYXVsIElyaXNoIHRpcFxcblxcbiAgICB2YXIgVFJVRSA9IHRydWUsXFxuICAgICAgICBGQUxTRSA9IGZhbHNlLFxcbiAgICAgICAgTlVMTCA9IG51bGwsXFxuICAgICAgICAvLyBDb21tb24gdmFyaWFibGVzXFxuICAgIFggPSAneCcsXFxuICAgICAgICBZID0gJ3knLFxcbiAgICAgICAgV0lEVEggPSAnd2lkdGgnLFxcbiAgICAgICAgSEVJR0hUID0gJ2hlaWdodCcsXFxuICAgICAgICAvLyBQb3NpdGlvbmluZyBzaWRlc1xcbiAgICBUT1AgPSAndG9wJyxcXG4gICAgICAgIExFRlQgPSAnbGVmdCcsXFxuICAgICAgICBCT1RUT00gPSAnYm90dG9tJyxcXG4gICAgICAgIFJJR0hUID0gJ3JpZ2h0JyxcXG4gICAgICAgIENFTlRFUiA9ICdjZW50ZXInLFxcbiAgICAgICAgLy8gUG9zaXRpb24gYWRqdXN0bWVudCB0eXBlc1xcbiAgICBGTElQID0gJ2ZsaXAnLFxcbiAgICAgICAgRkxJUElOVkVSVCA9ICdmbGlwaW52ZXJ0JyxcXG4gICAgICAgIFNISUZUID0gJ3NoaWZ0JyxcXG4gICAgICAgIC8vIFNob3J0Y3V0IHZhcnNcXG4gICAgUVRJUCxcXG4gICAgICAgIFBST1RPVFlQRSxcXG4gICAgICAgIENPUk5FUixcXG4gICAgICAgIENIRUNLUyxcXG4gICAgICAgIFBMVUdJTlMgPSB7fSxcXG4gICAgICAgIE5BTUVTUEFDRSA9ICdxdGlwJyxcXG4gICAgICAgIEFUVFJfSEFTID0gJ2RhdGEtaGFzcXRpcCcsXFxuICAgICAgICBBVFRSX0lEID0gJ2RhdGEtcXRpcC1pZCcsXFxuICAgICAgICBXSURHRVQgPSBbJ3VpLXdpZGdldCcsICd1aS10b29sdGlwJ10sXFxuICAgICAgICBTRUxFQ1RPUiA9ICcuJyArIE5BTUVTUEFDRSxcXG4gICAgICAgIElOQUNUSVZFX0VWRU5UUyA9ICdjbGljayBkYmxjbGljayBtb3VzZWRvd24gbW91c2V1cCBtb3VzZW1vdmUgbW91c2VsZWF2ZSBtb3VzZWVudGVyJy5zcGxpdCgnICcpLFxcbiAgICAgICAgQ0xBU1NfRklYRUQgPSBOQU1FU1BBQ0UgKyAnLWZpeGVkJyxcXG4gICAgICAgIENMQVNTX0RFRkFVTFQgPSBOQU1FU1BBQ0UgKyAnLWRlZmF1bHQnLFxcbiAgICAgICAgQ0xBU1NfRk9DVVMgPSBOQU1FU1BBQ0UgKyAnLWZvY3VzJyxcXG4gICAgICAgIENMQVNTX0hPVkVSID0gTkFNRVNQQUNFICsgJy1ob3ZlcicsXFxuICAgICAgICBDTEFTU19ESVNBQkxFRCA9IE5BTUVTUEFDRSArICctZGlzYWJsZWQnLFxcbiAgICAgICAgcmVwbGFjZVN1ZmZpeCA9ICdfcmVwbGFjZWRCeXFUaXAnLFxcbiAgICAgICAgb2xkdGl0bGUgPSAnb2xkdGl0bGUnLFxcbiAgICAgICAgdHJhY2tpbmdCb3VuZCxcXG4gICAgICAgIC8vIEJyb3dzZXIgZGV0ZWN0aW9uXFxuICAgIEJST1dTRVIgPSB7XFxuICAgICAgLypcXG4gICAgICAgKiBJRSB2ZXJzaW9uIGRldGVjdGlvblxcbiAgICAgICAqXFxuICAgICAgICogQWRhcHRlZCBmcm9tOiBodHRwOi8vYWpheGlhbi5jb20vYXJjaGl2ZXMvYXR0YWNrLW9mLXRoZS1pZS1jb25kaXRpb25hbC1jb21tZW50XFxuICAgICAgICogQ3JlZGl0IHRvIEphbWVzIFBhZG9sc2V5IGZvciB0aGUgb3JpZ2luYWwgaW1wbGVtbnRhdGlvbiFcXG4gICAgICAgKi9cXG4gICAgICBpZTogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgZm9yICh2YXIgdiA9IDQsIGkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxcXCJkaXZcXFwiKTsgKGkuaW5uZXJIVE1MID0gXFxcIjwhLS1baWYgZ3QgSUUgXFxcIiArIHYgKyBcXFwiXT48aT48L2k+PCFbZW5kaWZdLS0+XFxcIikgJiYgaS5nZXRFbGVtZW50c0J5VGFnTmFtZShcXFwiaVxcXCIpWzBdOyB2ICs9IDEpIHt9XFxuXFxuICAgICAgICByZXR1cm4gdiA+IDQgPyB2IDogTmFOO1xcbiAgICAgIH0oKSxcXG5cXG4gICAgICAvKlxcbiAgICAgICAqIGlPUyB2ZXJzaW9uIGRldGVjdGlvblxcbiAgICAgICAqL1xcbiAgICAgIGlPUzogcGFyc2VGbG9hdCgoJycgKyAoL0NQVS4qT1MgKFswLTlfXXsxLDV9KXwoQ1BVIGxpa2UpLipBcHBsZVdlYktpdC4qTW9iaWxlL2kuZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50KSB8fCBbMCwgJyddKVsxXSkucmVwbGFjZSgndW5kZWZpbmVkJywgJzNfMicpLnJlcGxhY2UoJ18nLCAnLicpLnJlcGxhY2UoJ18nLCAnJykpIHx8IEZBTFNFXFxuICAgIH07XFxuICAgIDtcXG5cXG4gICAgZnVuY3Rpb24gUVRpcCh0YXJnZXQsIG9wdGlvbnMsIGlkLCBhdHRyKSB7XFxuICAgICAgLy8gRWxlbWVudHMgYW5kIElEXFxuICAgICAgdGhpcy5pZCA9IGlkO1xcbiAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xcbiAgICAgIHRoaXMudG9vbHRpcCA9IE5VTEw7XFxuICAgICAgdGhpcy5lbGVtZW50cyA9IHtcXG4gICAgICAgIHRhcmdldDogdGFyZ2V0XFxuICAgICAgfTsgLy8gSW50ZXJuYWwgY29uc3RydWN0c1xcblxcbiAgICAgIHRoaXMuX2lkID0gTkFNRVNQQUNFICsgJy0nICsgaWQ7XFxuICAgICAgdGhpcy50aW1lcnMgPSB7XFxuICAgICAgICBpbWc6IHt9XFxuICAgICAgfTtcXG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xcbiAgICAgIHRoaXMucGx1Z2lucyA9IHt9OyAvLyBDYWNoZSBvYmplY3RcXG5cXG4gICAgICB0aGlzLmNhY2hlID0ge1xcbiAgICAgICAgZXZlbnQ6IHt9LFxcbiAgICAgICAgdGFyZ2V0OiAkKCksXFxuICAgICAgICBkaXNhYmxlZDogRkFMU0UsXFxuICAgICAgICBhdHRyOiBhdHRyLFxcbiAgICAgICAgb25Ub29sdGlwOiBGQUxTRSxcXG4gICAgICAgIGxhc3RDbGFzczogJydcXG4gICAgICB9OyAvLyBTZXQgdGhlIGluaXRpYWwgZmxhZ3NcXG5cXG4gICAgICB0aGlzLnJlbmRlcmVkID0gdGhpcy5kZXN0cm95ZWQgPSB0aGlzLmRpc2FibGVkID0gdGhpcy53YWl0aW5nID0gdGhpcy5oaWRkZW5EdXJpbmdXYWl0ID0gdGhpcy5wb3NpdGlvbmluZyA9IHRoaXMudHJpZ2dlcmluZyA9IEZBTFNFO1xcbiAgICB9XFxuXFxuICAgIFBST1RPVFlQRSA9IFFUaXAucHJvdG90eXBlO1xcblxcbiAgICBQUk9UT1RZUEUuX3doZW4gPSBmdW5jdGlvbiAoZGVmZXJyZWRzKSB7XFxuICAgICAgcmV0dXJuICQud2hlbi5hcHBseSgkLCBkZWZlcnJlZHMpO1xcbiAgICB9O1xcblxcbiAgICBQUk9UT1RZUEUucmVuZGVyID0gZnVuY3Rpb24gKHNob3cpIHtcXG4gICAgICBpZiAodGhpcy5yZW5kZXJlZCB8fCB0aGlzLmRlc3Ryb3llZCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXM7XFxuICAgICAgfSAvLyBJZiB0b29sdGlwIGhhcyBhbHJlYWR5IGJlZW4gcmVuZGVyZWQsIGV4aXRcXG5cXG5cXG4gICAgICB2YXIgc2VsZiA9IHRoaXMsXFxuICAgICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXFxuICAgICAgICAgIGNhY2hlID0gdGhpcy5jYWNoZSxcXG4gICAgICAgICAgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzLFxcbiAgICAgICAgICB0ZXh0ID0gb3B0aW9ucy5jb250ZW50LnRleHQsXFxuICAgICAgICAgIHRpdGxlID0gb3B0aW9ucy5jb250ZW50LnRpdGxlLFxcbiAgICAgICAgICBidXR0b24gPSBvcHRpb25zLmNvbnRlbnQuYnV0dG9uLFxcbiAgICAgICAgICBwb3NPcHRpb25zID0gb3B0aW9ucy5wb3NpdGlvbixcXG4gICAgICAgICAgbmFtZXNwYWNlID0gJy4nICsgdGhpcy5faWQgKyAnICcsXFxuICAgICAgICAgIGRlZmVycmVkcyA9IFtdLFxcbiAgICAgICAgICB0b29sdGlwOyAvLyBBZGQgQVJJQSBhdHRyaWJ1dGVzIHRvIHRhcmdldFxcblxcbiAgICAgICQuYXR0cih0aGlzLnRhcmdldFswXSwgJ2FyaWEtZGVzY3JpYmVkYnknLCB0aGlzLl9pZCk7IC8vIENyZWF0ZSBwdWJsaWMgcG9zaXRpb24gb2JqZWN0IHRoYXQgdHJhY2tzIGN1cnJlbnQgcG9zaXRpb24gY29ybmVyc1xcblxcbiAgICAgIGNhY2hlLnBvc0NsYXNzID0gdGhpcy5fY3JlYXRlUG9zQ2xhc3MoKHRoaXMucG9zaXRpb24gPSB7XFxuICAgICAgICBteTogcG9zT3B0aW9ucy5teSxcXG4gICAgICAgIGF0OiBwb3NPcHRpb25zLmF0XFxuICAgICAgfSkubXkpOyAvLyBDcmVhdGUgdG9vbHRpcCBlbGVtZW50XFxuXFxuICAgICAgdGhpcy50b29sdGlwID0gZWxlbWVudHMudG9vbHRpcCA9IHRvb2x0aXAgPSAkKCc8ZGl2Lz4nLCB7XFxuICAgICAgICAnaWQnOiB0aGlzLl9pZCxcXG4gICAgICAgICdjbGFzcyc6IFtOQU1FU1BBQ0UsIENMQVNTX0RFRkFVTFQsIG9wdGlvbnMuc3R5bGUuY2xhc3NlcywgY2FjaGUucG9zQ2xhc3NdLmpvaW4oJyAnKSxcXG4gICAgICAgICd3aWR0aCc6IG9wdGlvbnMuc3R5bGUud2lkdGggfHwgJycsXFxuICAgICAgICAnaGVpZ2h0Jzogb3B0aW9ucy5zdHlsZS5oZWlnaHQgfHwgJycsXFxuICAgICAgICAndHJhY2tpbmcnOiBwb3NPcHRpb25zLnRhcmdldCA9PT0gJ21vdXNlJyAmJiBwb3NPcHRpb25zLmFkanVzdC5tb3VzZSxcXG5cXG4gICAgICAgIC8qIEFSSUEgc3BlY2lmaWMgYXR0cmlidXRlcyAqL1xcbiAgICAgICAgJ3JvbGUnOiAnYWxlcnQnLFxcbiAgICAgICAgJ2FyaWEtbGl2ZSc6ICdwb2xpdGUnLFxcbiAgICAgICAgJ2FyaWEtYXRvbWljJzogRkFMU0UsXFxuICAgICAgICAnYXJpYS1kZXNjcmliZWRieSc6IHRoaXMuX2lkICsgJy1jb250ZW50JyxcXG4gICAgICAgICdhcmlhLWhpZGRlbic6IFRSVUVcXG4gICAgICB9KS50b2dnbGVDbGFzcyhDTEFTU19ESVNBQkxFRCwgdGhpcy5kaXNhYmxlZCkuYXR0cihBVFRSX0lELCB0aGlzLmlkKS5kYXRhKE5BTUVTUEFDRSwgdGhpcykuYXBwZW5kVG8ocG9zT3B0aW9ucy5jb250YWluZXIpLmFwcGVuZCggLy8gQ3JlYXRlIGNvbnRlbnQgZWxlbWVudFxcbiAgICAgIGVsZW1lbnRzLmNvbnRlbnQgPSAkKCc8ZGl2IC8+Jywge1xcbiAgICAgICAgJ2NsYXNzJzogTkFNRVNQQUNFICsgJy1jb250ZW50JyxcXG4gICAgICAgICdpZCc6IHRoaXMuX2lkICsgJy1jb250ZW50JyxcXG4gICAgICAgICdhcmlhLWF0b21pYyc6IFRSVUVcXG4gICAgICB9KSk7IC8vIFNldCByZW5kZXJlZCBmbGFnIGFuZCBwcmV2ZW50IHJlZHVuZGFudCByZXBvc2l0aW9uIGNhbGxzIGZvciBub3dcXG5cXG4gICAgICB0aGlzLnJlbmRlcmVkID0gLTE7XFxuICAgICAgdGhpcy5wb3NpdGlvbmluZyA9IFRSVUU7IC8vIENyZWF0ZSB0aXRsZS4uLlxcblxcbiAgICAgIGlmICh0aXRsZSkge1xcbiAgICAgICAgdGhpcy5fY3JlYXRlVGl0bGUoKTsgLy8gVXBkYXRlIHRpdGxlIG9ubHkgaWYgaXRzIG5vdCBhIGNhbGxiYWNrIChjYWxsZWQgaW4gdG9nZ2xlIGlmIHNvKVxcblxcblxcbiAgICAgICAgaWYgKCEkLmlzRnVuY3Rpb24odGl0bGUpKSB7XFxuICAgICAgICAgIGRlZmVycmVkcy5wdXNoKHRoaXMuX3VwZGF0ZVRpdGxlKHRpdGxlLCBGQUxTRSkpO1xcbiAgICAgICAgfVxcbiAgICAgIH0gLy8gQ3JlYXRlIGJ1dHRvblxcblxcblxcbiAgICAgIGlmIChidXR0b24pIHtcXG4gICAgICAgIHRoaXMuX2NyZWF0ZUJ1dHRvbigpO1xcbiAgICAgIH0gLy8gU2V0IHByb3BlciByZW5kZXJlZCBmbGFnIGFuZCB1cGRhdGUgY29udGVudCBpZiBub3QgYSBjYWxsYmFjayBmdW5jdGlvbiAoY2FsbGVkIGluIHRvZ2dsZSlcXG5cXG5cXG4gICAgICBpZiAoISQuaXNGdW5jdGlvbih0ZXh0KSkge1xcbiAgICAgICAgZGVmZXJyZWRzLnB1c2godGhpcy5fdXBkYXRlQ29udGVudCh0ZXh0LCBGQUxTRSkpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLnJlbmRlcmVkID0gVFJVRTsgLy8gU2V0dXAgd2lkZ2V0IGNsYXNzZXNcXG5cXG4gICAgICB0aGlzLl9zZXRXaWRnZXQoKTsgLy8gSW5pdGlhbGl6ZSAncmVuZGVyJyBwbHVnaW5zXFxuXFxuXFxuICAgICAgJC5lYWNoKFBMVUdJTlMsIGZ1bmN0aW9uIChuYW1lKSB7XFxuICAgICAgICB2YXIgaW5zdGFuY2U7XFxuXFxuICAgICAgICBpZiAodGhpcy5pbml0aWFsaXplID09PSAncmVuZGVyJyAmJiAoaW5zdGFuY2UgPSB0aGlzKHNlbGYpKSkge1xcbiAgICAgICAgICBzZWxmLnBsdWdpbnNbbmFtZV0gPSBpbnN0YW5jZTtcXG4gICAgICAgIH1cXG4gICAgICB9KTsgLy8gVW5hc3NpZ24gaW5pdGlhbCBldmVudHMgYW5kIGFzc2lnbiBwcm9wZXIgZXZlbnRzXFxuXFxuICAgICAgdGhpcy5fdW5hc3NpZ25FdmVudHMoKTtcXG5cXG4gICAgICB0aGlzLl9hc3NpZ25FdmVudHMoKTsgLy8gV2hlbiBkZWZlcnJlZHMgaGF2ZSBjb21wbGV0ZWRcXG5cXG5cXG4gICAgICB0aGlzLl93aGVuKGRlZmVycmVkcykudGhlbihmdW5jdGlvbiAoKSB7XFxuICAgICAgICAvLyB0b29sdGlwcmVuZGVyIGV2ZW50XFxuICAgICAgICBzZWxmLl90cmlnZ2VyKCdyZW5kZXInKTsgLy8gUmVzZXQgZmxhZ3NcXG5cXG5cXG4gICAgICAgIHNlbGYucG9zaXRpb25pbmcgPSBGQUxTRTsgLy8gU2hvdyB0b29sdGlwIGlmIG5vdCBoaWRkZW4gZHVyaW5nIHdhaXQgcGVyaW9kXFxuXFxuICAgICAgICBpZiAoIXNlbGYuaGlkZGVuRHVyaW5nV2FpdCAmJiAob3B0aW9ucy5zaG93LnJlYWR5IHx8IHNob3cpKSB7XFxuICAgICAgICAgIHNlbGYudG9nZ2xlKFRSVUUsIGNhY2hlLmV2ZW50LCBGQUxTRSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBzZWxmLmhpZGRlbkR1cmluZ1dhaXQgPSBGQUxTRTtcXG4gICAgICB9KTsgLy8gRXhwb3NlIEFQSVxcblxcblxcbiAgICAgIFFUSVAuYXBpW3RoaXMuaWRdID0gdGhpcztcXG4gICAgICByZXR1cm4gdGhpcztcXG4gICAgfTtcXG5cXG4gICAgUFJPVE9UWVBFLmRlc3Ryb3kgPSBmdW5jdGlvbiAoaW1tZWRpYXRlKSB7XFxuICAgICAgLy8gU2V0IGZsYWcgdGhlIHNpZ25pZnkgZGVzdHJveSBpcyB0YWtpbmcgcGxhY2UgdG8gcGx1Z2luc1xcbiAgICAgIC8vIGFuZCBlbnN1cmUgaXQgb25seSBnZXRzIGRlc3Ryb3llZCBvbmNlIVxcbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMudGFyZ2V0O1xcbiAgICAgIH1cXG5cXG4gICAgICBmdW5jdGlvbiBwcm9jZXNzKCkge1xcbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gVFJVRTtcXG4gICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLnRhcmdldCxcXG4gICAgICAgICAgICB0aXRsZSA9IHRhcmdldC5hdHRyKG9sZHRpdGxlKSxcXG4gICAgICAgICAgICB0aW1lcjsgLy8gRGVzdHJveSB0b29sdGlwIGlmIHJlbmRlcmVkXFxuXFxuICAgICAgICBpZiAodGhpcy5yZW5kZXJlZCkge1xcbiAgICAgICAgICB0aGlzLnRvb2x0aXAuc3RvcCgxLCAwKS5maW5kKCcqJykucmVtb3ZlKCkuZW5kKCkucmVtb3ZlKCk7XFxuICAgICAgICB9IC8vIERlc3Ryb3kgYWxsIHBsdWdpbnNcXG5cXG5cXG4gICAgICAgICQuZWFjaCh0aGlzLnBsdWdpbnMsIGZ1bmN0aW9uIChuYW1lKSB7XFxuICAgICAgICAgIHRoaXMuZGVzdHJveSAmJiB0aGlzLmRlc3Ryb3koKTtcXG4gICAgICAgIH0pOyAvLyBDbGVhciB0aW1lcnNcXG5cXG4gICAgICAgIGZvciAodGltZXIgaW4gdGhpcy50aW1lcnMpIHtcXG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXJzW3RpbWVyXSk7XFxuICAgICAgICB9IC8vIFJlbW92ZSBhcGkgb2JqZWN0IGFuZCBBUklBIGF0dHJpYnV0ZXNcXG5cXG5cXG4gICAgICAgIHRhcmdldC5yZW1vdmVEYXRhKE5BTUVTUEFDRSkucmVtb3ZlQXR0cihBVFRSX0lEKS5yZW1vdmVBdHRyKEFUVFJfSEFTKS5yZW1vdmVBdHRyKCdhcmlhLWRlc2NyaWJlZGJ5Jyk7IC8vIFJlc2V0IG9sZCB0aXRsZSBhdHRyaWJ1dGUgaWYgcmVtb3ZlZFxcblxcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdXBwcmVzcyAmJiB0aXRsZSkge1xcbiAgICAgICAgICB0YXJnZXQuYXR0cigndGl0bGUnLCB0aXRsZSkucmVtb3ZlQXR0cihvbGR0aXRsZSk7XFxuICAgICAgICB9IC8vIFJlbW92ZSBxVGlwIGV2ZW50cyBhc3NvY2lhdGVkIHdpdGggdGhpcyBBUElcXG5cXG5cXG4gICAgICAgIHRoaXMuX3VuYXNzaWduRXZlbnRzKCk7IC8vIFJlbW92ZSBJRCBmcm9tIHVzZWQgaWQgb2JqZWN0cywgYW5kIGRlbGV0ZSBvYmplY3QgcmVmZXJlbmNlc1xcbiAgICAgICAgLy8gZm9yIGJldHRlciBnYXJiYWdlIGNvbGxlY3Rpb24gYW5kIGxlYWsgcHJvdGVjdGlvblxcblxcblxcbiAgICAgICAgdGhpcy5vcHRpb25zID0gdGhpcy5lbGVtZW50cyA9IHRoaXMuY2FjaGUgPSB0aGlzLnRpbWVycyA9IHRoaXMucGx1Z2lucyA9IHRoaXMubW91c2UgPSBOVUxMOyAvLyBEZWxldGUgZXBveHNlZCBBUEkgb2JqZWN0XFxuXFxuICAgICAgICBkZWxldGUgUVRJUC5hcGlbdGhpcy5pZF07XFxuICAgICAgfSAvLyBJZiBhbiBpbW1lZGlhdGUgZGVzdHJveSBpcyBuZWVkZWRcXG5cXG5cXG4gICAgICBpZiAoKGltbWVkaWF0ZSAhPT0gVFJVRSB8fCB0aGlzLnRyaWdnZXJpbmcgPT09ICdoaWRlJykgJiYgdGhpcy5yZW5kZXJlZCkge1xcbiAgICAgICAgdGhpcy50b29sdGlwLm9uZSgndG9vbHRpcGhpZGRlbicsICQucHJveHkocHJvY2VzcywgdGhpcykpO1xcbiAgICAgICAgIXRoaXMudHJpZ2dlcmluZyAmJiB0aGlzLmhpZGUoKTtcXG4gICAgICB9IC8vIElmIHdlJ3JlIG5vdCBpbiB0aGUgcHJvY2VzcyBvZiBoaWRpbmcuLi4gcHJvY2Vzc1xcbiAgICAgIGVsc2Uge1xcbiAgICAgICAgICBwcm9jZXNzLmNhbGwodGhpcyk7XFxuICAgICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHRoaXMudGFyZ2V0O1xcbiAgICB9O1xcblxcbiAgICA7XFxuXFxuICAgIGZ1bmN0aW9uIGludmFsaWRPcHQoYSkge1xcbiAgICAgIHJldHVybiBhID09PSBOVUxMIHx8ICQudHlwZShhKSAhPT0gJ29iamVjdCc7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gaW52YWxpZENvbnRlbnQoYykge1xcbiAgICAgIHJldHVybiAhKCQuaXNGdW5jdGlvbihjKSB8fCBjICYmIGMuYXR0ciB8fCBjLmxlbmd0aCB8fCAkLnR5cGUoYykgPT09ICdvYmplY3QnICYmIChjLmpxdWVyeSB8fCBjLnRoZW4pKTtcXG4gICAgfSAvLyBPcHRpb24gb2JqZWN0IHNhbml0aXplclxcblxcblxcbiAgICBmdW5jdGlvbiBzYW5pdGl6ZU9wdGlvbnMob3B0cykge1xcbiAgICAgIHZhciBjb250ZW50LCB0ZXh0LCBhamF4LCBvbmNlO1xcblxcbiAgICAgIGlmIChpbnZhbGlkT3B0KG9wdHMpKSB7XFxuICAgICAgICByZXR1cm4gRkFMU0U7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChpbnZhbGlkT3B0KG9wdHMubWV0YWRhdGEpKSB7XFxuICAgICAgICBvcHRzLm1ldGFkYXRhID0ge1xcbiAgICAgICAgICB0eXBlOiBvcHRzLm1ldGFkYXRhXFxuICAgICAgICB9O1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoJ2NvbnRlbnQnIGluIG9wdHMpIHtcXG4gICAgICAgIGNvbnRlbnQgPSBvcHRzLmNvbnRlbnQ7XFxuXFxuICAgICAgICBpZiAoaW52YWxpZE9wdChjb250ZW50KSB8fCBjb250ZW50LmpxdWVyeSB8fCBjb250ZW50LmRvbmUpIHtcXG4gICAgICAgICAgY29udGVudCA9IG9wdHMuY29udGVudCA9IHtcXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0ID0gaW52YWxpZENvbnRlbnQoY29udGVudCkgPyBGQUxTRSA6IGNvbnRlbnRcXG4gICAgICAgICAgfTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHRleHQgPSBjb250ZW50LnRleHQ7XFxuICAgICAgICB9IC8vIERFUFJFQ0FURUQgLSBPbGQgY29udGVudC5hamF4IHBsdWdpbiBmdW5jdGlvbmFsaXR5XFxuICAgICAgICAvLyBDb252ZXJ0cyBpdCBpbnRvIHRoZSBwcm9wZXIgRGVmZXJyZWQgc3ludGF4XFxuXFxuXFxuICAgICAgICBpZiAoJ2FqYXgnIGluIGNvbnRlbnQpIHtcXG4gICAgICAgICAgYWpheCA9IGNvbnRlbnQuYWpheDtcXG4gICAgICAgICAgb25jZSA9IGFqYXggJiYgYWpheC5vbmNlICE9PSBGQUxTRTtcXG4gICAgICAgICAgZGVsZXRlIGNvbnRlbnQuYWpheDtcXG5cXG4gICAgICAgICAgY29udGVudC50ZXh0ID0gZnVuY3Rpb24gKGV2ZW50LCBhcGkpIHtcXG4gICAgICAgICAgICB2YXIgbG9hZGluZyA9IHRleHQgfHwgJCh0aGlzKS5hdHRyKGFwaS5vcHRpb25zLmNvbnRlbnQuYXR0cikgfHwgJ0xvYWRpbmcuLi4nLFxcbiAgICAgICAgICAgICAgICBkZWZlcnJlZCA9ICQuYWpheCgkLmV4dGVuZCh7fSwgYWpheCwge1xcbiAgICAgICAgICAgICAgY29udGV4dDogYXBpXFxuICAgICAgICAgICAgfSkpLnRoZW4oYWpheC5zdWNjZXNzLCBOVUxMLCBhamF4LmVycm9yKS50aGVuKGZ1bmN0aW9uIChjb250ZW50KSB7XFxuICAgICAgICAgICAgICBpZiAoY29udGVudCAmJiBvbmNlKSB7XFxuICAgICAgICAgICAgICAgIGFwaS5zZXQoJ2NvbnRlbnQudGV4dCcsIGNvbnRlbnQpO1xcbiAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XFxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKHhociwgc3RhdHVzLCBlcnJvcikge1xcbiAgICAgICAgICAgICAgaWYgKGFwaS5kZXN0cm95ZWQgfHwgeGhyLnN0YXR1cyA9PT0gMCkge1xcbiAgICAgICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICBhcGkuc2V0KCdjb250ZW50LnRleHQnLCBzdGF0dXMgKyAnOiAnICsgZXJyb3IpO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIHJldHVybiAhb25jZSA/IChhcGkuc2V0KCdjb250ZW50LnRleHQnLCBsb2FkaW5nKSwgZGVmZXJyZWQpIDogbG9hZGluZztcXG4gICAgICAgICAgfTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICgndGl0bGUnIGluIGNvbnRlbnQpIHtcXG4gICAgICAgICAgaWYgKCQuaXNQbGFpbk9iamVjdChjb250ZW50LnRpdGxlKSkge1xcbiAgICAgICAgICAgIGNvbnRlbnQuYnV0dG9uID0gY29udGVudC50aXRsZS5idXR0b247XFxuICAgICAgICAgICAgY29udGVudC50aXRsZSA9IGNvbnRlbnQudGl0bGUudGV4dDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAoaW52YWxpZENvbnRlbnQoY29udGVudC50aXRsZSB8fCBGQUxTRSkpIHtcXG4gICAgICAgICAgICBjb250ZW50LnRpdGxlID0gRkFMU0U7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCdwb3NpdGlvbicgaW4gb3B0cyAmJiBpbnZhbGlkT3B0KG9wdHMucG9zaXRpb24pKSB7XFxuICAgICAgICBvcHRzLnBvc2l0aW9uID0ge1xcbiAgICAgICAgICBteTogb3B0cy5wb3NpdGlvbixcXG4gICAgICAgICAgYXQ6IG9wdHMucG9zaXRpb25cXG4gICAgICAgIH07XFxuICAgICAgfVxcblxcbiAgICAgIGlmICgnc2hvdycgaW4gb3B0cyAmJiBpbnZhbGlkT3B0KG9wdHMuc2hvdykpIHtcXG4gICAgICAgIG9wdHMuc2hvdyA9IG9wdHMuc2hvdy5qcXVlcnkgPyB7XFxuICAgICAgICAgIHRhcmdldDogb3B0cy5zaG93XFxuICAgICAgICB9IDogb3B0cy5zaG93ID09PSBUUlVFID8ge1xcbiAgICAgICAgICByZWFkeTogVFJVRVxcbiAgICAgICAgfSA6IHtcXG4gICAgICAgICAgZXZlbnQ6IG9wdHMuc2hvd1xcbiAgICAgICAgfTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCdoaWRlJyBpbiBvcHRzICYmIGludmFsaWRPcHQob3B0cy5oaWRlKSkge1xcbiAgICAgICAgb3B0cy5oaWRlID0gb3B0cy5oaWRlLmpxdWVyeSA/IHtcXG4gICAgICAgICAgdGFyZ2V0OiBvcHRzLmhpZGVcXG4gICAgICAgIH0gOiB7XFxuICAgICAgICAgIGV2ZW50OiBvcHRzLmhpZGVcXG4gICAgICAgIH07XFxuICAgICAgfVxcblxcbiAgICAgIGlmICgnc3R5bGUnIGluIG9wdHMgJiYgaW52YWxpZE9wdChvcHRzLnN0eWxlKSkge1xcbiAgICAgICAgb3B0cy5zdHlsZSA9IHtcXG4gICAgICAgICAgY2xhc3Nlczogb3B0cy5zdHlsZVxcbiAgICAgICAgfTtcXG4gICAgICB9IC8vIFNhbml0aXplIHBsdWdpbiBvcHRpb25zXFxuXFxuXFxuICAgICAgJC5lYWNoKFBMVUdJTlMsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHRoaXMuc2FuaXRpemUgJiYgdGhpcy5zYW5pdGl6ZShvcHRzKTtcXG4gICAgICB9KTtcXG4gICAgICByZXR1cm4gb3B0cztcXG4gICAgfSAvLyBTZXR1cCBidWlsdGluIC5zZXQoKSBvcHRpb24gY2hlY2tzXFxuXFxuXFxuICAgIENIRUNLUyA9IFBST1RPVFlQRS5jaGVja3MgPSB7XFxuICAgICAgYnVpbHRpbjoge1xcbiAgICAgICAgLy8gQ29yZSBjaGVja3NcXG4gICAgICAgICdeaWQkJzogZnVuY3Rpb24gaWQkKG9iaiwgbywgdiwgcHJldikge1xcbiAgICAgICAgICB2YXIgaWQgPSB2ID09PSBUUlVFID8gUVRJUC5uZXh0aWQgOiB2LFxcbiAgICAgICAgICAgICAgbmV3X2lkID0gTkFNRVNQQUNFICsgJy0nICsgaWQ7XFxuXFxuICAgICAgICAgIGlmIChpZCAhPT0gRkFMU0UgJiYgaWQubGVuZ3RoID4gMCAmJiAhJCgnIycgKyBuZXdfaWQpLmxlbmd0aCkge1xcbiAgICAgICAgICAgIHRoaXMuX2lkID0gbmV3X2lkO1xcblxcbiAgICAgICAgICAgIGlmICh0aGlzLnJlbmRlcmVkKSB7XFxuICAgICAgICAgICAgICB0aGlzLnRvb2x0aXBbMF0uaWQgPSB0aGlzLl9pZDtcXG4gICAgICAgICAgICAgIHRoaXMuZWxlbWVudHMuY29udGVudFswXS5pZCA9IHRoaXMuX2lkICsgJy1jb250ZW50JztcXG4gICAgICAgICAgICAgIHRoaXMuZWxlbWVudHMudGl0bGVbMF0uaWQgPSB0aGlzLl9pZCArICctdGl0bGUnO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBvYmpbb10gPSBwcmV2O1xcbiAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgJ15wcmVyZW5kZXInOiBmdW5jdGlvbiBwcmVyZW5kZXIob2JqLCBvLCB2KSB7XFxuICAgICAgICAgIHYgJiYgIXRoaXMucmVuZGVyZWQgJiYgdGhpcy5yZW5kZXIodGhpcy5vcHRpb25zLnNob3cucmVhZHkpO1xcbiAgICAgICAgfSxcXG4gICAgICAgIC8vIENvbnRlbnQgY2hlY2tzXFxuICAgICAgICAnXmNvbnRlbnQudGV4dCQnOiBmdW5jdGlvbiBjb250ZW50VGV4dCQob2JqLCBvLCB2KSB7XFxuICAgICAgICAgIHRoaXMuX3VwZGF0ZUNvbnRlbnQodik7XFxuICAgICAgICB9LFxcbiAgICAgICAgJ15jb250ZW50LmF0dHIkJzogZnVuY3Rpb24gY29udGVudEF0dHIkKG9iaiwgbywgdiwgcHJldikge1xcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNvbnRlbnQudGV4dCA9PT0gdGhpcy50YXJnZXQuYXR0cihwcmV2KSkge1xcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUNvbnRlbnQodGhpcy50YXJnZXQuYXR0cih2KSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuICAgICAgICAnXmNvbnRlbnQudGl0bGUkJzogZnVuY3Rpb24gY29udGVudFRpdGxlJChvYmosIG8sIHYpIHtcXG4gICAgICAgICAgLy8gUmVtb3ZlIHRpdGxlIGlmIGNvbnRlbnQgaXMgbnVsbFxcbiAgICAgICAgICBpZiAoIXYpIHtcXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVtb3ZlVGl0bGUoKTtcXG4gICAgICAgICAgfSAvLyBJZiB0aXRsZSBpc24ndCBhbHJlYWR5IGNyZWF0ZWQsIGNyZWF0ZSBpdCBub3cgYW5kIHVwZGF0ZVxcblxcblxcbiAgICAgICAgICB2ICYmICF0aGlzLmVsZW1lbnRzLnRpdGxlICYmIHRoaXMuX2NyZWF0ZVRpdGxlKCk7XFxuXFxuICAgICAgICAgIHRoaXMuX3VwZGF0ZVRpdGxlKHYpO1xcbiAgICAgICAgfSxcXG4gICAgICAgICdeY29udGVudC5idXR0b24kJzogZnVuY3Rpb24gY29udGVudEJ1dHRvbiQob2JqLCBvLCB2KSB7XFxuICAgICAgICAgIHRoaXMuX3VwZGF0ZUJ1dHRvbih2KTtcXG4gICAgICAgIH0sXFxuICAgICAgICAnXmNvbnRlbnQudGl0bGUuKHRleHR8YnV0dG9uKSQnOiBmdW5jdGlvbiBjb250ZW50VGl0bGVUZXh0QnV0dG9uJChvYmosIG8sIHYpIHtcXG4gICAgICAgICAgdGhpcy5zZXQoJ2NvbnRlbnQuJyArIG8sIHYpOyAvLyBCYWNrd2FyZHMgdGl0bGUudGV4dC9idXR0b24gY29tcGF0XFxuICAgICAgICB9LFxcbiAgICAgICAgLy8gUG9zaXRpb24gY2hlY2tzXFxuICAgICAgICAnXnBvc2l0aW9uLihteXxhdCkkJzogZnVuY3Rpb24gcG9zaXRpb25NeUF0JChvYmosIG8sIHYpIHtcXG4gICAgICAgICAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2Ygdikge1xcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25bb10gPSBvYmpbb10gPSBuZXcgQ09STkVSKHYsIG8gPT09ICdhdCcpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgJ15wb3NpdGlvbi5jb250YWluZXIkJzogZnVuY3Rpb24gcG9zaXRpb25Db250YWluZXIkKG9iaiwgbywgdikge1xcbiAgICAgICAgICB0aGlzLnJlbmRlcmVkICYmIHRoaXMudG9vbHRpcC5hcHBlbmRUbyh2KTtcXG4gICAgICAgIH0sXFxuICAgICAgICAvLyBTaG93IGNoZWNrc1xcbiAgICAgICAgJ15zaG93LnJlYWR5JCc6IGZ1bmN0aW9uIHNob3dSZWFkeSQob2JqLCBvLCB2KSB7XFxuICAgICAgICAgIHYgJiYgKCF0aGlzLnJlbmRlcmVkICYmIHRoaXMucmVuZGVyKFRSVUUpIHx8IHRoaXMudG9nZ2xlKFRSVUUpKTtcXG4gICAgICAgIH0sXFxuICAgICAgICAvLyBTdHlsZSBjaGVja3NcXG4gICAgICAgICdec3R5bGUuY2xhc3NlcyQnOiBmdW5jdGlvbiBzdHlsZUNsYXNzZXMkKG9iaiwgbywgdiwgcCkge1xcbiAgICAgICAgICB0aGlzLnJlbmRlcmVkICYmIHRoaXMudG9vbHRpcC5yZW1vdmVDbGFzcyhwKS5hZGRDbGFzcyh2KTtcXG4gICAgICAgIH0sXFxuICAgICAgICAnXnN0eWxlLih3aWR0aHxoZWlnaHQpJzogZnVuY3Rpb24gc3R5bGVXaWR0aEhlaWdodChvYmosIG8sIHYpIHtcXG4gICAgICAgICAgdGhpcy5yZW5kZXJlZCAmJiB0aGlzLnRvb2x0aXAuY3NzKG8sIHYpO1xcbiAgICAgICAgfSxcXG4gICAgICAgICdec3R5bGUud2lkZ2V0fGNvbnRlbnQudGl0bGUnOiBmdW5jdGlvbiBzdHlsZVdpZGdldENvbnRlbnRUaXRsZSgpIHtcXG4gICAgICAgICAgdGhpcy5yZW5kZXJlZCAmJiB0aGlzLl9zZXRXaWRnZXQoKTtcXG4gICAgICAgIH0sXFxuICAgICAgICAnXnN0eWxlLmRlZic6IGZ1bmN0aW9uIHN0eWxlRGVmKG9iaiwgbywgdikge1xcbiAgICAgICAgICB0aGlzLnJlbmRlcmVkICYmIHRoaXMudG9vbHRpcC50b2dnbGVDbGFzcyhDTEFTU19ERUZBVUxULCAhIXYpO1xcbiAgICAgICAgfSxcXG4gICAgICAgIC8vIEV2ZW50cyBjaGVja1xcbiAgICAgICAgJ15ldmVudHMuKHJlbmRlcnxzaG93fG1vdmV8aGlkZXxmb2N1c3xibHVyKSQnOiBmdW5jdGlvbiBldmVudHNSZW5kZXJTaG93TW92ZUhpZGVGb2N1c0JsdXIkKG9iaiwgbywgdikge1xcbiAgICAgICAgICB0aGlzLnJlbmRlcmVkICYmIHRoaXMudG9vbHRpcFsoJC5pc0Z1bmN0aW9uKHYpID8gJycgOiAndW4nKSArICdiaW5kJ10oJ3Rvb2x0aXAnICsgbywgdik7XFxuICAgICAgICB9LFxcbiAgICAgICAgLy8gUHJvcGVydGllcyB3aGljaCByZXF1aXJlIGV2ZW50IHJlYXNzaWdubWVudFxcbiAgICAgICAgJ14oc2hvd3xoaWRlfHBvc2l0aW9uKS4oZXZlbnR8dGFyZ2V0fGZpeGVkfGluYWN0aXZlfGxlYXZlfGRpc3RhbmNlfHZpZXdwb3J0fGFkanVzdCknOiBmdW5jdGlvbiBzaG93SGlkZVBvc2l0aW9uRXZlbnRUYXJnZXRGaXhlZEluYWN0aXZlTGVhdmVEaXN0YW5jZVZpZXdwb3J0QWRqdXN0KCkge1xcbiAgICAgICAgICBpZiAoIXRoaXMucmVuZGVyZWQpIHtcXG4gICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgIH0gLy8gU2V0IHRyYWNraW5nIGZsYWdcXG5cXG5cXG4gICAgICAgICAgdmFyIHBvc09wdGlvbnMgPSB0aGlzLm9wdGlvbnMucG9zaXRpb247XFxuICAgICAgICAgIHRoaXMudG9vbHRpcC5hdHRyKCd0cmFja2luZycsIHBvc09wdGlvbnMudGFyZ2V0ID09PSAnbW91c2UnICYmIHBvc09wdGlvbnMuYWRqdXN0Lm1vdXNlKTsgLy8gUmVhc3NpZ24gZXZlbnRzXFxuXFxuICAgICAgICAgIHRoaXMuX3VuYXNzaWduRXZlbnRzKCk7XFxuXFxuICAgICAgICAgIHRoaXMuX2Fzc2lnbkV2ZW50cygpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfTsgLy8gRG90IG5vdGF0aW9uIGNvbnZlcnRlclxcblxcbiAgICBmdW5jdGlvbiBjb252ZXJ0Tm90YXRpb24ob3B0aW9ucywgbm90YXRpb24pIHtcXG4gICAgICB2YXIgaSA9IDAsXFxuICAgICAgICAgIG9iaixcXG4gICAgICAgICAgb3B0aW9uID0gb3B0aW9ucyxcXG4gICAgICAgICAgLy8gU3BsaXQgbm90YXRpb24gaW50byBhcnJheVxcbiAgICAgIGxldmVscyA9IG5vdGF0aW9uLnNwbGl0KCcuJyk7IC8vIExvb3AgdGhyb3VnaFxcblxcbiAgICAgIHdoaWxlIChvcHRpb24gPSBvcHRpb25bbGV2ZWxzW2krK11dKSB7XFxuICAgICAgICBpZiAoaSA8IGxldmVscy5sZW5ndGgpIHtcXG4gICAgICAgICAgb2JqID0gb3B0aW9uO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gW29iaiB8fCBvcHRpb25zLCBsZXZlbHMucG9wKCldO1xcbiAgICB9XFxuXFxuICAgIFBST1RPVFlQRS5nZXQgPSBmdW5jdGlvbiAobm90YXRpb24pIHtcXG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcXG4gICAgICAgIHJldHVybiB0aGlzO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgbyA9IGNvbnZlcnROb3RhdGlvbih0aGlzLm9wdGlvbnMsIG5vdGF0aW9uLnRvTG93ZXJDYXNlKCkpLFxcbiAgICAgICAgICByZXN1bHQgPSBvWzBdW29bMV1dO1xcbiAgICAgIHJldHVybiByZXN1bHQucHJlY2VkYW5jZSA/IHJlc3VsdC5zdHJpbmcoKSA6IHJlc3VsdDtcXG4gICAgfTtcXG5cXG4gICAgZnVuY3Rpb24gc2V0Q2FsbGJhY2sobm90YXRpb24sIGFyZ3MpIHtcXG4gICAgICB2YXIgY2F0ZWdvcnksIHJ1bGUsIG1hdGNoO1xcblxcbiAgICAgIGZvciAoY2F0ZWdvcnkgaW4gdGhpcy5jaGVja3MpIHtcXG4gICAgICAgIGZvciAocnVsZSBpbiB0aGlzLmNoZWNrc1tjYXRlZ29yeV0pIHtcXG4gICAgICAgICAgaWYgKG1hdGNoID0gbmV3IFJlZ0V4cChydWxlLCAnaScpLmV4ZWMobm90YXRpb24pKSB7XFxuICAgICAgICAgICAgYXJncy5wdXNoKG1hdGNoKTtcXG5cXG4gICAgICAgICAgICBpZiAoY2F0ZWdvcnkgPT09ICdidWlsdGluJyB8fCB0aGlzLnBsdWdpbnNbY2F0ZWdvcnldKSB7XFxuICAgICAgICAgICAgICB0aGlzLmNoZWNrc1tjYXRlZ29yeV1bcnVsZV0uYXBwbHkodGhpcy5wbHVnaW5zW2NhdGVnb3J5XSB8fCB0aGlzLCBhcmdzKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgdmFyIHJtb3ZlID0gL15wb3NpdGlvblxcXFwuKG15fGF0fGFkanVzdHx0YXJnZXR8Y29udGFpbmVyfHZpZXdwb3J0KXxzdHlsZXxjb250ZW50fHNob3dcXFxcLnJlYWR5L2ksXFxuICAgICAgICBycmVuZGVyID0gL15wcmVyZW5kZXJ8c2hvd1xcXFwucmVhZHkvaTtcXG5cXG4gICAgUFJPVE9UWVBFLnNldCA9IGZ1bmN0aW9uIChvcHRpb24sIHZhbHVlKSB7XFxuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XFxuICAgICAgICByZXR1cm4gdGhpcztcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIHJlbmRlcmVkID0gdGhpcy5yZW5kZXJlZCxcXG4gICAgICAgICAgcmVwb3NpdGlvbiA9IEZBTFNFLFxcbiAgICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxcbiAgICAgICAgICBjaGVja3MgPSB0aGlzLmNoZWNrcyxcXG4gICAgICAgICAgbmFtZTsgLy8gQ29udmVydCBzaW5ndWxhciBvcHRpb24vdmFsdWUgcGFpciBpbnRvIG9iamVjdCBmb3JtXFxuXFxuICAgICAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2Ygb3B0aW9uKSB7XFxuICAgICAgICBuYW1lID0gb3B0aW9uO1xcbiAgICAgICAgb3B0aW9uID0ge307XFxuICAgICAgICBvcHRpb25bbmFtZV0gPSB2YWx1ZTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgb3B0aW9uID0gJC5leHRlbmQoe30sIG9wdGlvbik7XFxuICAgICAgfSAvLyBTZXQgYWxsIG9mIHRoZSBkZWZpbmVkIG9wdGlvbnMgdG8gdGhlaXIgbmV3IHZhbHVlc1xcblxcblxcbiAgICAgICQuZWFjaChvcHRpb24sIGZ1bmN0aW9uIChub3RhdGlvbiwgdmFsdWUpIHtcXG4gICAgICAgIGlmIChyZW5kZXJlZCAmJiBycmVuZGVyLnRlc3Qobm90YXRpb24pKSB7XFxuICAgICAgICAgIGRlbGV0ZSBvcHRpb25bbm90YXRpb25dO1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9IC8vIFNldCBuZXcgb2JqIHZhbHVlXFxuXFxuXFxuICAgICAgICB2YXIgb2JqID0gY29udmVydE5vdGF0aW9uKG9wdGlvbnMsIG5vdGF0aW9uLnRvTG93ZXJDYXNlKCkpLFxcbiAgICAgICAgICAgIHByZXZpb3VzO1xcbiAgICAgICAgcHJldmlvdXMgPSBvYmpbMF1bb2JqWzFdXTtcXG4gICAgICAgIG9ialswXVtvYmpbMV1dID0gdmFsdWUgJiYgdmFsdWUubm9kZVR5cGUgPyAkKHZhbHVlKSA6IHZhbHVlOyAvLyBBbHNvIGNoZWNrIGlmIHdlIG5lZWQgdG8gcmVwb3NpdGlvblxcblxcbiAgICAgICAgcmVwb3NpdGlvbiA9IHJtb3ZlLnRlc3Qobm90YXRpb24pIHx8IHJlcG9zaXRpb247IC8vIFNldCB0aGUgbmV3IHBhcmFtcyBmb3IgdGhlIGNhbGxiYWNrXFxuXFxuICAgICAgICBvcHRpb25bbm90YXRpb25dID0gW29ialswXSwgb2JqWzFdLCB2YWx1ZSwgcHJldmlvdXNdO1xcbiAgICAgIH0pOyAvLyBSZS1zYW5pdGl6ZSBvcHRpb25zXFxuXFxuICAgICAgc2FuaXRpemVPcHRpb25zKG9wdGlvbnMpO1xcbiAgICAgIC8qXFxuICAgICAgICogRXhlY3V0ZSBhbnkgdmFsaWQgY2FsbGJhY2tzIGZvciB0aGUgc2V0IG9wdGlvbnNcXG4gICAgICAgKiBBbHNvIHNldCBwb3NpdGlvbmluZyBmbGFnIHNvIHdlIGRvbid0IGdldCBsb2FkcyBvZiByZWR1bmRhbnQgcmVwb3NpdGlvbmluZyBjYWxscy5cXG4gICAgICAgKi9cXG5cXG4gICAgICB0aGlzLnBvc2l0aW9uaW5nID0gVFJVRTtcXG4gICAgICAkLmVhY2gob3B0aW9uLCAkLnByb3h5KHNldENhbGxiYWNrLCB0aGlzKSk7XFxuICAgICAgdGhpcy5wb3NpdGlvbmluZyA9IEZBTFNFOyAvLyBVcGRhdGUgcG9zaXRpb24gaWYgbmVlZGVkXFxuXFxuICAgICAgaWYgKHRoaXMucmVuZGVyZWQgJiYgdGhpcy50b29sdGlwWzBdLm9mZnNldFdpZHRoID4gMCAmJiByZXBvc2l0aW9uKSB7XFxuICAgICAgICB0aGlzLnJlcG9zaXRpb24ob3B0aW9ucy5wb3NpdGlvbi50YXJnZXQgPT09ICdtb3VzZScgPyBOVUxMIDogdGhpcy5jYWNoZS5ldmVudCk7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiB0aGlzO1xcbiAgICB9O1xcblxcbiAgICA7XFxuXFxuICAgIFBST1RPVFlQRS5fdXBkYXRlID0gZnVuY3Rpb24gKGNvbnRlbnQsIGVsZW1lbnQsIHJlcG9zaXRpb24pIHtcXG4gICAgICB2YXIgc2VsZiA9IHRoaXMsXFxuICAgICAgICAgIGNhY2hlID0gdGhpcy5jYWNoZTsgLy8gTWFrZSBzdXJlIHRvb2x0aXAgaXMgcmVuZGVyZWQgYW5kIGNvbnRlbnQgaXMgZGVmaW5lZC4gSWYgbm90IHJldHVyblxcblxcbiAgICAgIGlmICghdGhpcy5yZW5kZXJlZCB8fCAhY29udGVudCkge1xcbiAgICAgICAgcmV0dXJuIEZBTFNFO1xcbiAgICAgIH0gLy8gVXNlIGZ1bmN0aW9uIHRvIHBhcnNlIGNvbnRlbnRcXG5cXG5cXG4gICAgICBpZiAoJC5pc0Z1bmN0aW9uKGNvbnRlbnQpKSB7XFxuICAgICAgICBjb250ZW50ID0gY29udGVudC5jYWxsKHRoaXMuZWxlbWVudHMudGFyZ2V0LCBjYWNoZS5ldmVudCwgdGhpcykgfHwgJyc7XFxuICAgICAgfSAvLyBIYW5kbGUgZGVmZXJyZWQgY29udGVudFxcblxcblxcbiAgICAgIGlmICgkLmlzRnVuY3Rpb24oY29udGVudC50aGVuKSkge1xcbiAgICAgICAgY2FjaGUud2FpdGluZyA9IFRSVUU7XFxuICAgICAgICByZXR1cm4gY29udGVudC50aGVuKGZ1bmN0aW9uIChjKSB7XFxuICAgICAgICAgIGNhY2hlLndhaXRpbmcgPSBGQUxTRTtcXG4gICAgICAgICAgcmV0dXJuIHNlbGYuX3VwZGF0ZShjLCBlbGVtZW50KTtcXG4gICAgICAgIH0sIE5VTEwsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICAgIHJldHVybiBzZWxmLl91cGRhdGUoZSwgZWxlbWVudCk7XFxuICAgICAgICB9KTtcXG4gICAgICB9IC8vIElmIGNvbnRlbnQgaXMgbnVsbC4uLiByZXR1cm4gZmFsc2VcXG5cXG5cXG4gICAgICBpZiAoY29udGVudCA9PT0gRkFMU0UgfHwgIWNvbnRlbnQgJiYgY29udGVudCAhPT0gJycpIHtcXG4gICAgICAgIHJldHVybiBGQUxTRTtcXG4gICAgICB9IC8vIEFwcGVuZCBuZXcgY29udGVudCBpZiBpdHMgYSBET00gYXJyYXkgYW5kIHNob3cgaXQgaWYgaGlkZGVuXFxuXFxuXFxuICAgICAgaWYgKGNvbnRlbnQuanF1ZXJ5ICYmIGNvbnRlbnQubGVuZ3RoID4gMCkge1xcbiAgICAgICAgZWxlbWVudC5lbXB0eSgpLmFwcGVuZChjb250ZW50LmNzcyh7XFxuICAgICAgICAgIGRpc3BsYXk6ICdibG9jaycsXFxuICAgICAgICAgIHZpc2liaWxpdHk6ICd2aXNpYmxlJ1xcbiAgICAgICAgfSkpO1xcbiAgICAgIH0gLy8gQ29udGVudCBpcyBhIHJlZ3VsYXIgc3RyaW5nLCBpbnNlcnQgdGhlIG5ldyBjb250ZW50XFxuICAgICAgZWxzZSB7XFxuICAgICAgICAgIGVsZW1lbnQuaHRtbChjb250ZW50KTtcXG4gICAgICAgIH0gLy8gV2FpdCBmb3IgY29udGVudCB0byBiZSBsb2FkZWQsIGFuZCByZXBvc2l0aW9uXFxuXFxuXFxuICAgICAgcmV0dXJuIHRoaXMuX3dhaXRGb3JDb250ZW50KGVsZW1lbnQpLnRoZW4oZnVuY3Rpb24gKGltYWdlcykge1xcbiAgICAgICAgaWYgKHNlbGYucmVuZGVyZWQgJiYgc2VsZi50b29sdGlwWzBdLm9mZnNldFdpZHRoID4gMCkge1xcbiAgICAgICAgICBzZWxmLnJlcG9zaXRpb24oY2FjaGUuZXZlbnQsICFpbWFnZXMubGVuZ3RoKTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgfTtcXG5cXG4gICAgUFJPVE9UWVBFLl93YWl0Rm9yQ29udGVudCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XFxuICAgICAgdmFyIGNhY2hlID0gdGhpcy5jYWNoZTsgLy8gU2V0IGZsYWdcXG5cXG4gICAgICBjYWNoZS53YWl0aW5nID0gVFJVRTsgLy8gSWYgaW1hZ2VzTG9hZGVkIGlzIGluY2x1ZGVkLCBlbnN1cmUgaW1hZ2VzIGhhdmUgbG9hZGVkIGFuZCByZXR1cm4gcHJvbWlzZVxcblxcbiAgICAgIHJldHVybiAoJC5mbi5pbWFnZXNMb2FkZWQgPyBlbGVtZW50LmltYWdlc0xvYWRlZCgpIDogJC5EZWZlcnJlZCgpLnJlc29sdmUoW10pKS5kb25lKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGNhY2hlLndhaXRpbmcgPSBGQUxTRTtcXG4gICAgICB9KS5wcm9taXNlKCk7XFxuICAgIH07XFxuXFxuICAgIFBST1RPVFlQRS5fdXBkYXRlQ29udGVudCA9IGZ1bmN0aW9uIChjb250ZW50LCByZXBvc2l0aW9uKSB7XFxuICAgICAgdGhpcy5fdXBkYXRlKGNvbnRlbnQsIHRoaXMuZWxlbWVudHMuY29udGVudCwgcmVwb3NpdGlvbik7XFxuICAgIH07XFxuXFxuICAgIFBST1RPVFlQRS5fdXBkYXRlVGl0bGUgPSBmdW5jdGlvbiAoY29udGVudCwgcmVwb3NpdGlvbikge1xcbiAgICAgIGlmICh0aGlzLl91cGRhdGUoY29udGVudCwgdGhpcy5lbGVtZW50cy50aXRsZSwgcmVwb3NpdGlvbikgPT09IEZBTFNFKSB7XFxuICAgICAgICB0aGlzLl9yZW1vdmVUaXRsZShGQUxTRSk7XFxuICAgICAgfVxcbiAgICB9O1xcblxcbiAgICBQUk9UT1RZUEUuX2NyZWF0ZVRpdGxlID0gZnVuY3Rpb24gKCkge1xcbiAgICAgIHZhciBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHMsXFxuICAgICAgICAgIGlkID0gdGhpcy5faWQgKyAnLXRpdGxlJzsgLy8gRGVzdHJveSBwcmV2aW91cyB0aXRsZSBlbGVtZW50LCBpZiBwcmVzZW50XFxuXFxuICAgICAgaWYgKGVsZW1lbnRzLnRpdGxlYmFyKSB7XFxuICAgICAgICB0aGlzLl9yZW1vdmVUaXRsZSgpO1xcbiAgICAgIH0gLy8gQ3JlYXRlIHRpdGxlIGJhciBhbmQgdGl0bGUgZWxlbWVudHNcXG5cXG5cXG4gICAgICBlbGVtZW50cy50aXRsZWJhciA9ICQoJzxkaXYgLz4nLCB7XFxuICAgICAgICAnY2xhc3MnOiBOQU1FU1BBQ0UgKyAnLXRpdGxlYmFyICcgKyAodGhpcy5vcHRpb25zLnN0eWxlLndpZGdldCA/IGNyZWF0ZVdpZGdldENsYXNzKCdoZWFkZXInKSA6ICcnKVxcbiAgICAgIH0pLmFwcGVuZChlbGVtZW50cy50aXRsZSA9ICQoJzxkaXYgLz4nLCB7XFxuICAgICAgICAnaWQnOiBpZCxcXG4gICAgICAgICdjbGFzcyc6IE5BTUVTUEFDRSArICctdGl0bGUnLFxcbiAgICAgICAgJ2FyaWEtYXRvbWljJzogVFJVRVxcbiAgICAgIH0pKS5pbnNlcnRCZWZvcmUoZWxlbWVudHMuY29udGVudCkgLy8gQnV0dG9uLXNwZWNpZmljIGV2ZW50c1xcbiAgICAgIC5kZWxlZ2F0ZSgnLnF0aXAtY2xvc2UnLCAnbW91c2Vkb3duIGtleWRvd24gbW91c2V1cCBrZXl1cCBtb3VzZW91dCcsIGZ1bmN0aW9uIChldmVudCkge1xcbiAgICAgICAgJCh0aGlzKS50b2dnbGVDbGFzcygndWktc3RhdGUtYWN0aXZlIHVpLXN0YXRlLWZvY3VzJywgZXZlbnQudHlwZS5zdWJzdHIoLTQpID09PSAnZG93bicpO1xcbiAgICAgIH0pLmRlbGVnYXRlKCcucXRpcC1jbG9zZScsICdtb3VzZW92ZXIgbW91c2VvdXQnLCBmdW5jdGlvbiAoZXZlbnQpIHtcXG4gICAgICAgICQodGhpcykudG9nZ2xlQ2xhc3MoJ3VpLXN0YXRlLWhvdmVyJywgZXZlbnQudHlwZSA9PT0gJ21vdXNlb3ZlcicpO1xcbiAgICAgIH0pOyAvLyBDcmVhdGUgYnV0dG9uIGlmIGVuYWJsZWRcXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmNvbnRlbnQuYnV0dG9uKSB7XFxuICAgICAgICB0aGlzLl9jcmVhdGVCdXR0b24oKTtcXG4gICAgICB9XFxuICAgIH07XFxuXFxuICAgIFBST1RPVFlQRS5fcmVtb3ZlVGl0bGUgPSBmdW5jdGlvbiAocmVwb3NpdGlvbikge1xcbiAgICAgIHZhciBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHM7XFxuXFxuICAgICAgaWYgKGVsZW1lbnRzLnRpdGxlKSB7XFxuICAgICAgICBlbGVtZW50cy50aXRsZWJhci5yZW1vdmUoKTtcXG4gICAgICAgIGVsZW1lbnRzLnRpdGxlYmFyID0gZWxlbWVudHMudGl0bGUgPSBlbGVtZW50cy5idXR0b24gPSBOVUxMOyAvLyBSZXBvc2l0aW9uIGlmIGVuYWJsZWRcXG5cXG4gICAgICAgIGlmIChyZXBvc2l0aW9uICE9PSBGQUxTRSkge1xcbiAgICAgICAgICB0aGlzLnJlcG9zaXRpb24oKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH07XFxuXFxuICAgIDtcXG5cXG4gICAgUFJPVE9UWVBFLl9jcmVhdGVQb3NDbGFzcyA9IGZ1bmN0aW9uIChteSkge1xcbiAgICAgIHJldHVybiBOQU1FU1BBQ0UgKyAnLXBvcy0nICsgKG15IHx8IHRoaXMub3B0aW9ucy5wb3NpdGlvbi5teSkuYWJicmV2KCk7XFxuICAgIH07XFxuXFxuICAgIFBST1RPVFlQRS5yZXBvc2l0aW9uID0gZnVuY3Rpb24gKGV2ZW50LCBlZmZlY3QpIHtcXG4gICAgICBpZiAoIXRoaXMucmVuZGVyZWQgfHwgdGhpcy5wb3NpdGlvbmluZyB8fCB0aGlzLmRlc3Ryb3llZCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXM7XFxuICAgICAgfSAvLyBTZXQgcG9zaXRpb25pbmcgZmxhZ1xcblxcblxcbiAgICAgIHRoaXMucG9zaXRpb25pbmcgPSBUUlVFO1xcbiAgICAgIHZhciBjYWNoZSA9IHRoaXMuY2FjaGUsXFxuICAgICAgICAgIHRvb2x0aXAgPSB0aGlzLnRvb2x0aXAsXFxuICAgICAgICAgIHBvc09wdGlvbnMgPSB0aGlzLm9wdGlvbnMucG9zaXRpb24sXFxuICAgICAgICAgIHRhcmdldCA9IHBvc09wdGlvbnMudGFyZ2V0LFxcbiAgICAgICAgICBteSA9IHBvc09wdGlvbnMubXksXFxuICAgICAgICAgIGF0ID0gcG9zT3B0aW9ucy5hdCxcXG4gICAgICAgICAgdmlld3BvcnQgPSBwb3NPcHRpb25zLnZpZXdwb3J0LFxcbiAgICAgICAgICBjb250YWluZXIgPSBwb3NPcHRpb25zLmNvbnRhaW5lcixcXG4gICAgICAgICAgYWRqdXN0ID0gcG9zT3B0aW9ucy5hZGp1c3QsXFxuICAgICAgICAgIG1ldGhvZCA9IGFkanVzdC5tZXRob2Quc3BsaXQoJyAnKSxcXG4gICAgICAgICAgdG9vbHRpcFdpZHRoID0gdG9vbHRpcC5vdXRlcldpZHRoKEZBTFNFKSxcXG4gICAgICAgICAgdG9vbHRpcEhlaWdodCA9IHRvb2x0aXAub3V0ZXJIZWlnaHQoRkFMU0UpLFxcbiAgICAgICAgICB0YXJnZXRXaWR0aCA9IDAsXFxuICAgICAgICAgIHRhcmdldEhlaWdodCA9IDAsXFxuICAgICAgICAgIHR5cGUgPSB0b29sdGlwLmNzcygncG9zaXRpb24nKSxcXG4gICAgICAgICAgcG9zaXRpb24gPSB7XFxuICAgICAgICBsZWZ0OiAwLFxcbiAgICAgICAgdG9wOiAwXFxuICAgICAgfSxcXG4gICAgICAgICAgdmlzaWJsZSA9IHRvb2x0aXBbMF0ub2Zmc2V0V2lkdGggPiAwLFxcbiAgICAgICAgICBpc1Njcm9sbCA9IGV2ZW50ICYmIGV2ZW50LnR5cGUgPT09ICdzY3JvbGwnLFxcbiAgICAgICAgICB3aW4gPSAkKHdpbmRvdyksXFxuICAgICAgICAgIGRvYyA9IGNvbnRhaW5lclswXS5vd25lckRvY3VtZW50LFxcbiAgICAgICAgICBtb3VzZSA9IHRoaXMubW91c2UsXFxuICAgICAgICAgIHBsdWdpbkNhbGN1bGF0aW9ucyxcXG4gICAgICAgICAgb2Zmc2V0LFxcbiAgICAgICAgICBhZGp1c3RlZCxcXG4gICAgICAgICAgbmV3Q2xhc3M7IC8vIENoZWNrIGlmIGFic29sdXRlIHBvc2l0aW9uIHdhcyBwYXNzZWRcXG5cXG4gICAgICBpZiAoJC5pc0FycmF5KHRhcmdldCkgJiYgdGFyZ2V0Lmxlbmd0aCA9PT0gMikge1xcbiAgICAgICAgLy8gRm9yY2UgbGVmdCB0b3AgYW5kIHNldCBwb3NpdGlvblxcbiAgICAgICAgYXQgPSB7XFxuICAgICAgICAgIHg6IExFRlQsXFxuICAgICAgICAgIHk6IFRPUFxcbiAgICAgICAgfTtcXG4gICAgICAgIHBvc2l0aW9uID0ge1xcbiAgICAgICAgICBsZWZ0OiB0YXJnZXRbMF0sXFxuICAgICAgICAgIHRvcDogdGFyZ2V0WzFdXFxuICAgICAgICB9O1xcbiAgICAgIH0gLy8gQ2hlY2sgaWYgbW91c2Ugd2FzIHRoZSB0YXJnZXRcXG4gICAgICBlbHNlIGlmICh0YXJnZXQgPT09ICdtb3VzZScpIHtcXG4gICAgICAgICAgLy8gRm9yY2UgbGVmdCB0b3AgdG8gYWxsb3cgZmxpcHBpbmdcXG4gICAgICAgICAgYXQgPSB7XFxuICAgICAgICAgICAgeDogTEVGVCxcXG4gICAgICAgICAgICB5OiBUT1BcXG4gICAgICAgICAgfTsgLy8gVXNlIHRoZSBtb3VzZSBvcmlnaW4gdGhhdCBjYXVzZWQgdGhlIHNob3cgZXZlbnQsIGlmIGRpc3RhbmNlIGhpZGluZyBpcyBlbmFibGVkXFxuXFxuICAgICAgICAgIGlmICgoIWFkanVzdC5tb3VzZSB8fCB0aGlzLm9wdGlvbnMuaGlkZS5kaXN0YW5jZSkgJiYgY2FjaGUub3JpZ2luICYmIGNhY2hlLm9yaWdpbi5wYWdlWCkge1xcbiAgICAgICAgICAgIGV2ZW50ID0gY2FjaGUub3JpZ2luO1xcbiAgICAgICAgICB9IC8vIFVzZSBjYWNoZWQgZXZlbnQgZm9yIHJlc2l6ZS9zY3JvbGwgZXZlbnRzXFxuICAgICAgICAgIGVsc2UgaWYgKCFldmVudCB8fCBldmVudCAmJiAoZXZlbnQudHlwZSA9PT0gJ3Jlc2l6ZScgfHwgZXZlbnQudHlwZSA9PT0gJ3Njcm9sbCcpKSB7XFxuICAgICAgICAgICAgICBldmVudCA9IGNhY2hlLmV2ZW50O1xcbiAgICAgICAgICAgIH0gLy8gT3RoZXJ3aXNlLCB1c2UgdGhlIGNhY2hlZCBtb3VzZSBjb29yZGluYXRlcyBpZiBhdmFpbGFibGVcXG4gICAgICAgICAgICBlbHNlIGlmIChtb3VzZSAmJiBtb3VzZS5wYWdlWCkge1xcbiAgICAgICAgICAgICAgICBldmVudCA9IG1vdXNlO1xcbiAgICAgICAgICAgICAgfSAvLyBDYWxjdWxhdGUgYm9keSBhbmQgY29udGFpbmVyIG9mZnNldCBhbmQgdGFrZSB0aGVtIGludG8gYWNjb3VudCBiZWxvd1xcblxcblxcbiAgICAgICAgICBpZiAodHlwZSAhPT0gJ3N0YXRpYycpIHtcXG4gICAgICAgICAgICBwb3NpdGlvbiA9IGNvbnRhaW5lci5vZmZzZXQoKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAoZG9jLmJvZHkub2Zmc2V0V2lkdGggIT09ICh3aW5kb3cuaW5uZXJXaWR0aCB8fCBkb2MuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoKSkge1xcbiAgICAgICAgICAgIG9mZnNldCA9ICQoZG9jdW1lbnQuYm9keSkub2Zmc2V0KCk7XFxuICAgICAgICAgIH0gLy8gVXNlIGV2ZW50IGNvb3JkaW5hdGVzIGZvciBwb3NpdGlvblxcblxcblxcbiAgICAgICAgICBwb3NpdGlvbiA9IHtcXG4gICAgICAgICAgICBsZWZ0OiBldmVudC5wYWdlWCAtIHBvc2l0aW9uLmxlZnQgKyAob2Zmc2V0ICYmIG9mZnNldC5sZWZ0IHx8IDApLFxcbiAgICAgICAgICAgIHRvcDogZXZlbnQucGFnZVkgLSBwb3NpdGlvbi50b3AgKyAob2Zmc2V0ICYmIG9mZnNldC50b3AgfHwgMClcXG4gICAgICAgICAgfTsgLy8gU2Nyb2xsIGV2ZW50cyBhcmUgYSBwYWluLCBzb21lIGJyb3dzZXJzXFxuXFxuICAgICAgICAgIGlmIChhZGp1c3QubW91c2UgJiYgaXNTY3JvbGwgJiYgbW91c2UpIHtcXG4gICAgICAgICAgICBwb3NpdGlvbi5sZWZ0IC09IChtb3VzZS5zY3JvbGxYIHx8IDApIC0gd2luLnNjcm9sbExlZnQoKTtcXG4gICAgICAgICAgICBwb3NpdGlvbi50b3AgLT0gKG1vdXNlLnNjcm9sbFkgfHwgMCkgLSB3aW4uc2Nyb2xsVG9wKCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gLy8gVGFyZ2V0IHdhc24ndCBtb3VzZSBvciBhYnNvbHV0ZS4uLlxcbiAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgZXZlbnQgdGFyZ2V0dGluZyBpcyBiZWluZyB1c2VkXFxuICAgICAgICAgICAgaWYgKHRhcmdldCA9PT0gJ2V2ZW50Jykge1xcbiAgICAgICAgICAgICAgaWYgKGV2ZW50ICYmIGV2ZW50LnRhcmdldCAmJiBldmVudC50eXBlICE9PSAnc2Nyb2xsJyAmJiBldmVudC50eXBlICE9PSAncmVzaXplJykge1xcbiAgICAgICAgICAgICAgICBjYWNoZS50YXJnZXQgPSAkKGV2ZW50LnRhcmdldCk7XFxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFldmVudC50YXJnZXQpIHtcXG4gICAgICAgICAgICAgICAgY2FjaGUudGFyZ2V0ID0gdGhpcy5lbGVtZW50cy50YXJnZXQ7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSBlbHNlIGlmICh0YXJnZXQgIT09ICdldmVudCcpIHtcXG4gICAgICAgICAgICAgIGNhY2hlLnRhcmdldCA9ICQodGFyZ2V0LmpxdWVyeSA/IHRhcmdldCA6IHRoaXMuZWxlbWVudHMudGFyZ2V0KTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgdGFyZ2V0ID0gY2FjaGUudGFyZ2V0OyAvLyBQYXJzZSB0aGUgdGFyZ2V0IGludG8gYSBqUXVlcnkgb2JqZWN0IGFuZCBtYWtlIHN1cmUgdGhlcmUncyBhbiBlbGVtZW50IHByZXNlbnRcXG5cXG4gICAgICAgICAgICB0YXJnZXQgPSAkKHRhcmdldCkuZXEoMCk7XFxuXFxuICAgICAgICAgICAgaWYgKHRhcmdldC5sZW5ndGggPT09IDApIHtcXG4gICAgICAgICAgICAgIHJldHVybiB0aGlzO1xcbiAgICAgICAgICAgIH0gLy8gQ2hlY2sgaWYgd2luZG93IG9yIGRvY3VtZW50IGlzIHRoZSB0YXJnZXRcXG4gICAgICAgICAgICBlbHNlIGlmICh0YXJnZXRbMF0gPT09IGRvY3VtZW50IHx8IHRhcmdldFswXSA9PT0gd2luZG93KSB7XFxuICAgICAgICAgICAgICAgIHRhcmdldFdpZHRoID0gQlJPV1NFUi5pT1MgPyB3aW5kb3cuaW5uZXJXaWR0aCA6IHRhcmdldC53aWR0aCgpO1xcbiAgICAgICAgICAgICAgICB0YXJnZXRIZWlnaHQgPSBCUk9XU0VSLmlPUyA/IHdpbmRvdy5pbm5lckhlaWdodCA6IHRhcmdldC5oZWlnaHQoKTtcXG5cXG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldFswXSA9PT0gd2luZG93KSB7XFxuICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSB7XFxuICAgICAgICAgICAgICAgICAgICB0b3A6ICh2aWV3cG9ydCB8fCB0YXJnZXQpLnNjcm9sbFRvcCgpLFxcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogKHZpZXdwb3J0IHx8IHRhcmdldCkuc2Nyb2xsTGVmdCgpXFxuICAgICAgICAgICAgICAgICAgfTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgfSAvLyBDaGVjayBpZiB0aGUgdGFyZ2V0IGlzIGFuIDxBUkVBPiBlbGVtZW50XFxuICAgICAgICAgICAgICBlbHNlIGlmIChQTFVHSU5TLmltYWdlbWFwICYmIHRhcmdldC5pcygnYXJlYScpKSB7XFxuICAgICAgICAgICAgICAgICAgcGx1Z2luQ2FsY3VsYXRpb25zID0gUExVR0lOUy5pbWFnZW1hcCh0aGlzLCB0YXJnZXQsIGF0LCBQTFVHSU5TLnZpZXdwb3J0ID8gbWV0aG9kIDogRkFMU0UpO1xcbiAgICAgICAgICAgICAgICB9IC8vIENoZWNrIGlmIHRoZSB0YXJnZXQgaXMgYW4gU1ZHIGVsZW1lbnRcXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoUExVR0lOUy5zdmcgJiYgdGFyZ2V0ICYmIHRhcmdldFswXS5vd25lclNWR0VsZW1lbnQpIHtcXG4gICAgICAgICAgICAgICAgICAgIHBsdWdpbkNhbGN1bGF0aW9ucyA9IFBMVUdJTlMuc3ZnKHRoaXMsIHRhcmdldCwgYXQsIFBMVUdJTlMudmlld3BvcnQgPyBtZXRob2QgOiBGQUxTRSk7XFxuICAgICAgICAgICAgICAgICAgfSAvLyBPdGhlcndpc2UgdXNlIHJlZ3VsYXIgalF1ZXJ5IG1ldGhvZHNcXG4gICAgICAgICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0V2lkdGggPSB0YXJnZXQub3V0ZXJXaWR0aChGQUxTRSk7XFxuICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEhlaWdodCA9IHRhcmdldC5vdXRlckhlaWdodChGQUxTRSk7XFxuICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gdGFyZ2V0Lm9mZnNldCgpO1xcbiAgICAgICAgICAgICAgICAgICAgfSAvLyBQYXJzZSByZXR1cm5lZCBwbHVnaW4gdmFsdWVzIGludG8gcHJvcGVyIHZhcmlhYmxlc1xcblxcblxcbiAgICAgICAgICAgIGlmIChwbHVnaW5DYWxjdWxhdGlvbnMpIHtcXG4gICAgICAgICAgICAgIHRhcmdldFdpZHRoID0gcGx1Z2luQ2FsY3VsYXRpb25zLndpZHRoO1xcbiAgICAgICAgICAgICAgdGFyZ2V0SGVpZ2h0ID0gcGx1Z2luQ2FsY3VsYXRpb25zLmhlaWdodDtcXG4gICAgICAgICAgICAgIG9mZnNldCA9IHBsdWdpbkNhbGN1bGF0aW9ucy5vZmZzZXQ7XFxuICAgICAgICAgICAgICBwb3NpdGlvbiA9IHBsdWdpbkNhbGN1bGF0aW9ucy5wb3NpdGlvbjtcXG4gICAgICAgICAgICB9IC8vIEFkanVzdCBwb3NpdGlvbiB0byB0YWtlIGludG8gYWNjb3VudCBvZmZzZXQgcGFyZW50c1xcblxcblxcbiAgICAgICAgICAgIHBvc2l0aW9uID0gdGhpcy5yZXBvc2l0aW9uLm9mZnNldCh0YXJnZXQsIHBvc2l0aW9uLCBjb250YWluZXIpOyAvLyBBZGp1c3QgZm9yIHBvc2l0aW9uLmZpeGVkIHRvb2x0aXBzIChhbmQgYWxzbyBpT1Mgc2Nyb2xsIGJ1ZyBpbiB2My4yLTQuMCAmIHY0LjMtNC4zLjIpXFxuXFxuICAgICAgICAgICAgaWYgKEJST1dTRVIuaU9TID4gMy4xICYmIEJST1dTRVIuaU9TIDwgNC4xIHx8IEJST1dTRVIuaU9TID49IDQuMyAmJiBCUk9XU0VSLmlPUyA8IDQuMzMgfHwgIUJST1dTRVIuaU9TICYmIHR5cGUgPT09ICdmaXhlZCcpIHtcXG4gICAgICAgICAgICAgIHBvc2l0aW9uLmxlZnQgLT0gd2luLnNjcm9sbExlZnQoKTtcXG4gICAgICAgICAgICAgIHBvc2l0aW9uLnRvcCAtPSB3aW4uc2Nyb2xsVG9wKCk7XFxuICAgICAgICAgICAgfSAvLyBBZGp1c3QgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGFyZ2V0XFxuXFxuXFxuICAgICAgICAgICAgaWYgKCFwbHVnaW5DYWxjdWxhdGlvbnMgfHwgcGx1Z2luQ2FsY3VsYXRpb25zICYmIHBsdWdpbkNhbGN1bGF0aW9ucy5hZGp1c3RhYmxlICE9PSBGQUxTRSkge1xcbiAgICAgICAgICAgICAgcG9zaXRpb24ubGVmdCArPSBhdC54ID09PSBSSUdIVCA/IHRhcmdldFdpZHRoIDogYXQueCA9PT0gQ0VOVEVSID8gdGFyZ2V0V2lkdGggLyAyIDogMDtcXG4gICAgICAgICAgICAgIHBvc2l0aW9uLnRvcCArPSBhdC55ID09PSBCT1RUT00gPyB0YXJnZXRIZWlnaHQgOiBhdC55ID09PSBDRU5URVIgPyB0YXJnZXRIZWlnaHQgLyAyIDogMDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH0gLy8gQWRqdXN0IHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRvb2x0aXBcXG5cXG5cXG4gICAgICBwb3NpdGlvbi5sZWZ0ICs9IGFkanVzdC54ICsgKG15LnggPT09IFJJR0hUID8gLXRvb2x0aXBXaWR0aCA6IG15LnggPT09IENFTlRFUiA/IC10b29sdGlwV2lkdGggLyAyIDogMCk7XFxuICAgICAgcG9zaXRpb24udG9wICs9IGFkanVzdC55ICsgKG15LnkgPT09IEJPVFRPTSA/IC10b29sdGlwSGVpZ2h0IDogbXkueSA9PT0gQ0VOVEVSID8gLXRvb2x0aXBIZWlnaHQgLyAyIDogMCk7IC8vIFVzZSB2aWV3cG9ydCBhZGp1c3RtZW50IHBsdWdpbiBpZiBlbmFibGVkXFxuXFxuICAgICAgaWYgKFBMVUdJTlMudmlld3BvcnQpIHtcXG4gICAgICAgIGFkanVzdGVkID0gcG9zaXRpb24uYWRqdXN0ZWQgPSBQTFVHSU5TLnZpZXdwb3J0KHRoaXMsIHBvc2l0aW9uLCBwb3NPcHRpb25zLCB0YXJnZXRXaWR0aCwgdGFyZ2V0SGVpZ2h0LCB0b29sdGlwV2lkdGgsIHRvb2x0aXBIZWlnaHQpOyAvLyBBcHBseSBvZmZzZXRzIHN1cHBsaWVkIGJ5IHBvc2l0aW9uaW5nIHBsdWdpbiAoaWYgdXNlZClcXG5cXG4gICAgICAgIGlmIChvZmZzZXQgJiYgYWRqdXN0ZWQubGVmdCkge1xcbiAgICAgICAgICBwb3NpdGlvbi5sZWZ0ICs9IG9mZnNldC5sZWZ0O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKG9mZnNldCAmJiBhZGp1c3RlZC50b3ApIHtcXG4gICAgICAgICAgcG9zaXRpb24udG9wICs9IG9mZnNldC50b3A7XFxuICAgICAgICB9IC8vIEFwcGx5IGFueSBuZXcgJ215JyBwb3NpdGlvblxcblxcblxcbiAgICAgICAgaWYgKGFkanVzdGVkLm15KSB7XFxuICAgICAgICAgIHRoaXMucG9zaXRpb24ubXkgPSBhZGp1c3RlZC5teTtcXG4gICAgICAgIH1cXG4gICAgICB9IC8vIFZpZXdwb3J0IGFkanVzdG1lbnQgaXMgZGlzYWJsZWQsIHNldCB2YWx1ZXMgdG8gemVyb1xcbiAgICAgIGVsc2Uge1xcbiAgICAgICAgICBwb3NpdGlvbi5hZGp1c3RlZCA9IHtcXG4gICAgICAgICAgICBsZWZ0OiAwLFxcbiAgICAgICAgICAgIHRvcDogMFxcbiAgICAgICAgICB9O1xcbiAgICAgICAgfSAvLyBTZXQgdG9vbHRpcCBwb3NpdGlvbiBjbGFzcyBpZiBpdCdzIGNoYW5nZWRcXG5cXG5cXG4gICAgICBpZiAoY2FjaGUucG9zQ2xhc3MgIT09IChuZXdDbGFzcyA9IHRoaXMuX2NyZWF0ZVBvc0NsYXNzKHRoaXMucG9zaXRpb24ubXkpKSkge1xcbiAgICAgICAgdG9vbHRpcC5yZW1vdmVDbGFzcyhjYWNoZS5wb3NDbGFzcykuYWRkQ2xhc3MoY2FjaGUucG9zQ2xhc3MgPSBuZXdDbGFzcyk7XFxuICAgICAgfSAvLyB0b29sdGlwbW92ZSBldmVudFxcblxcblxcbiAgICAgIGlmICghdGhpcy5fdHJpZ2dlcignbW92ZScsIFtwb3NpdGlvbiwgdmlld3BvcnQuZWxlbSB8fCB2aWV3cG9ydF0sIGV2ZW50KSkge1xcbiAgICAgICAgcmV0dXJuIHRoaXM7XFxuICAgICAgfVxcblxcbiAgICAgIGRlbGV0ZSBwb3NpdGlvbi5hZGp1c3RlZDsgLy8gSWYgZWZmZWN0IGlzIGRpc2FibGVkLCB0YXJnZXQgaXQgbW91c2UsIG5vIGFuaW1hdGlvbiBpcyBkZWZpbmVkIG9yIHBvc2l0aW9uaW5nIGdpdmVzIE5hTiBvdXQsIHNldCBDU1MgZGlyZWN0bHlcXG5cXG4gICAgICBpZiAoZWZmZWN0ID09PSBGQUxTRSB8fCAhdmlzaWJsZSB8fCBpc05hTihwb3NpdGlvbi5sZWZ0KSB8fCBpc05hTihwb3NpdGlvbi50b3ApIHx8IHRhcmdldCA9PT0gJ21vdXNlJyB8fCAhJC5pc0Z1bmN0aW9uKHBvc09wdGlvbnMuZWZmZWN0KSkge1xcbiAgICAgICAgdG9vbHRpcC5jc3MocG9zaXRpb24pO1xcbiAgICAgIH0gLy8gVXNlIGN1c3RvbSBmdW5jdGlvbiBpZiBwcm92aWRlZFxcbiAgICAgIGVsc2UgaWYgKCQuaXNGdW5jdGlvbihwb3NPcHRpb25zLmVmZmVjdCkpIHtcXG4gICAgICAgICAgcG9zT3B0aW9ucy5lZmZlY3QuY2FsbCh0b29sdGlwLCB0aGlzLCAkLmV4dGVuZCh7fSwgcG9zaXRpb24pKTtcXG4gICAgICAgICAgdG9vbHRpcC5xdWV1ZShmdW5jdGlvbiAobmV4dCkge1xcbiAgICAgICAgICAgIC8vIFJlc2V0IGF0dHJpYnV0ZXMgdG8gYXZvaWQgY3Jvc3MtYnJvd3NlciByZW5kZXJpbmcgYnVnc1xcbiAgICAgICAgICAgICQodGhpcykuY3NzKHtcXG4gICAgICAgICAgICAgIG9wYWNpdHk6ICcnLFxcbiAgICAgICAgICAgICAgaGVpZ2h0OiAnJ1xcbiAgICAgICAgICAgIH0pO1xcblxcbiAgICAgICAgICAgIGlmIChCUk9XU0VSLmllKSB7XFxuICAgICAgICAgICAgICB0aGlzLnN0eWxlLnJlbW92ZUF0dHJpYnV0ZSgnZmlsdGVyJyk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIG5leHQoKTtcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9IC8vIFNldCBwb3NpdGlvbmluZyBmbGFnXFxuXFxuXFxuICAgICAgdGhpcy5wb3NpdGlvbmluZyA9IEZBTFNFO1xcbiAgICAgIHJldHVybiB0aGlzO1xcbiAgICB9OyAvLyBDdXN0b20gKG1vcmUgY29ycmVjdCBmb3IgcVRpcCEpIG9mZnNldCBjYWxjdWxhdG9yXFxuXFxuXFxuICAgIFBST1RPVFlQRS5yZXBvc2l0aW9uLm9mZnNldCA9IGZ1bmN0aW9uIChlbGVtLCBwb3MsIGNvbnRhaW5lcikge1xcbiAgICAgIGlmICghY29udGFpbmVyWzBdKSB7XFxuICAgICAgICByZXR1cm4gcG9zO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgb3duZXJEb2N1bWVudCA9ICQoZWxlbVswXS5vd25lckRvY3VtZW50KSxcXG4gICAgICAgICAgcXVpcmtzID0gISFCUk9XU0VSLmllICYmIGRvY3VtZW50LmNvbXBhdE1vZGUgIT09ICdDU1MxQ29tcGF0JyxcXG4gICAgICAgICAgcGFyZW50ID0gY29udGFpbmVyWzBdLFxcbiAgICAgICAgICBzY3JvbGxlZCxcXG4gICAgICAgICAgcG9zaXRpb24sXFxuICAgICAgICAgIHBhcmVudE9mZnNldCxcXG4gICAgICAgICAgb3ZlcmZsb3c7XFxuXFxuICAgICAgZnVuY3Rpb24gc2Nyb2xsKGUsIGkpIHtcXG4gICAgICAgIHBvcy5sZWZ0ICs9IGkgKiBlLnNjcm9sbExlZnQoKTtcXG4gICAgICAgIHBvcy50b3AgKz0gaSAqIGUuc2Nyb2xsVG9wKCk7XFxuICAgICAgfSAvLyBDb21wZW5zYXRlIGZvciBub24tc3RhdGljIGNvbnRhaW5lcnMgb2Zmc2V0XFxuXFxuXFxuICAgICAgZG8ge1xcbiAgICAgICAgaWYgKChwb3NpdGlvbiA9ICQuY3NzKHBhcmVudCwgJ3Bvc2l0aW9uJykpICE9PSAnc3RhdGljJykge1xcbiAgICAgICAgICBpZiAocG9zaXRpb24gPT09ICdmaXhlZCcpIHtcXG4gICAgICAgICAgICBwYXJlbnRPZmZzZXQgPSBwYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XFxuICAgICAgICAgICAgc2Nyb2xsKG93bmVyRG9jdW1lbnQsIC0xKTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBwYXJlbnRPZmZzZXQgPSAkKHBhcmVudCkucG9zaXRpb24oKTtcXG4gICAgICAgICAgICBwYXJlbnRPZmZzZXQubGVmdCArPSBwYXJzZUZsb2F0KCQuY3NzKHBhcmVudCwgJ2JvcmRlckxlZnRXaWR0aCcpKSB8fCAwO1xcbiAgICAgICAgICAgIHBhcmVudE9mZnNldC50b3AgKz0gcGFyc2VGbG9hdCgkLmNzcyhwYXJlbnQsICdib3JkZXJUb3BXaWR0aCcpKSB8fCAwO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHBvcy5sZWZ0IC09IHBhcmVudE9mZnNldC5sZWZ0ICsgKHBhcnNlRmxvYXQoJC5jc3MocGFyZW50LCAnbWFyZ2luTGVmdCcpKSB8fCAwKTtcXG4gICAgICAgICAgcG9zLnRvcCAtPSBwYXJlbnRPZmZzZXQudG9wICsgKHBhcnNlRmxvYXQoJC5jc3MocGFyZW50LCAnbWFyZ2luVG9wJykpIHx8IDApOyAvLyBJZiB0aGlzIGlzIHRoZSBmaXJzdCBwYXJlbnQgZWxlbWVudCB3aXRoIGFuIG92ZXJmbG93IG9mIFxcXCJzY3JvbGxcXFwiIG9yIFxcXCJhdXRvXFxcIiwgc3RvcmUgaXRcXG5cXG4gICAgICAgICAgaWYgKCFzY3JvbGxlZCAmJiAob3ZlcmZsb3cgPSAkLmNzcyhwYXJlbnQsICdvdmVyZmxvdycpKSAhPT0gJ2hpZGRlbicgJiYgb3ZlcmZsb3cgIT09ICd2aXNpYmxlJykge1xcbiAgICAgICAgICAgIHNjcm9sbGVkID0gJChwYXJlbnQpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfSB3aGlsZSAocGFyZW50ID0gcGFyZW50Lm9mZnNldFBhcmVudCk7IC8vIENvbXBlbnNhdGUgZm9yIGNvbnRhaW5lcnMgc2Nyb2xsIGlmIGl0IGFsc28gaGFzIGFuIG9mZnNldFBhcmVudCAob3IgaW4gSUUgcXVpcmtzIG1vZGUpXFxuXFxuXFxuICAgICAgaWYgKHNjcm9sbGVkICYmIChzY3JvbGxlZFswXSAhPT0gb3duZXJEb2N1bWVudFswXSB8fCBxdWlya3MpKSB7XFxuICAgICAgICBzY3JvbGwoc2Nyb2xsZWQsIDEpO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gcG9zO1xcbiAgICB9OyAvLyBDb3JuZXIgY2xhc3NcXG5cXG5cXG4gICAgdmFyIEMgPSAoQ09STkVSID0gUFJPVE9UWVBFLnJlcG9zaXRpb24uQ29ybmVyID0gZnVuY3Rpb24gKGNvcm5lciwgZm9yY2VZKSB7XFxuICAgICAgY29ybmVyID0gKCcnICsgY29ybmVyKS5yZXBsYWNlKC8oW0EtWl0pLywgJyAkMScpLnJlcGxhY2UoL21pZGRsZS9naSwgQ0VOVEVSKS50b0xvd2VyQ2FzZSgpO1xcbiAgICAgIHRoaXMueCA9IChjb3JuZXIubWF0Y2goL2xlZnR8cmlnaHQvaSkgfHwgY29ybmVyLm1hdGNoKC9jZW50ZXIvKSB8fCBbJ2luaGVyaXQnXSlbMF0udG9Mb3dlckNhc2UoKTtcXG4gICAgICB0aGlzLnkgPSAoY29ybmVyLm1hdGNoKC90b3B8Ym90dG9tfGNlbnRlci9pKSB8fCBbJ2luaGVyaXQnXSlbMF0udG9Mb3dlckNhc2UoKTtcXG4gICAgICB0aGlzLmZvcmNlWSA9ICEhZm9yY2VZO1xcbiAgICAgIHZhciBmID0gY29ybmVyLmNoYXJBdCgwKTtcXG4gICAgICB0aGlzLnByZWNlZGFuY2UgPSBmID09PSAndCcgfHwgZiA9PT0gJ2InID8gWSA6IFg7XFxuICAgIH0pLnByb3RvdHlwZTtcXG5cXG4gICAgQy5pbnZlcnQgPSBmdW5jdGlvbiAoeiwgY2VudGVyKSB7XFxuICAgICAgdGhpc1t6XSA9IHRoaXNbel0gPT09IExFRlQgPyBSSUdIVCA6IHRoaXNbel0gPT09IFJJR0hUID8gTEVGVCA6IGNlbnRlciB8fCB0aGlzW3pdO1xcbiAgICB9O1xcblxcbiAgICBDLnN0cmluZyA9IGZ1bmN0aW9uIChqb2luKSB7XFxuICAgICAgdmFyIHggPSB0aGlzLngsXFxuICAgICAgICAgIHkgPSB0aGlzLnk7XFxuICAgICAgdmFyIHJlc3VsdCA9IHggIT09IHkgPyB4ID09PSAnY2VudGVyJyB8fCB5ICE9PSAnY2VudGVyJyAmJiAodGhpcy5wcmVjZWRhbmNlID09PSBZIHx8IHRoaXMuZm9yY2VZKSA/IFt5LCB4XSA6IFt4LCB5XSA6IFt4XTtcXG4gICAgICByZXR1cm4gam9pbiAhPT0gZmFsc2UgPyByZXN1bHQuam9pbignICcpIDogcmVzdWx0O1xcbiAgICB9O1xcblxcbiAgICBDLmFiYnJldiA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICB2YXIgcmVzdWx0ID0gdGhpcy5zdHJpbmcoZmFsc2UpO1xcbiAgICAgIHJldHVybiByZXN1bHRbMF0uY2hhckF0KDApICsgKHJlc3VsdFsxXSAmJiByZXN1bHRbMV0uY2hhckF0KDApIHx8ICcnKTtcXG4gICAgfTtcXG5cXG4gICAgQy5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICByZXR1cm4gbmV3IENPUk5FUih0aGlzLnN0cmluZygpLCB0aGlzLmZvcmNlWSk7XFxuICAgIH07XFxuXFxuICAgIDtcXG5cXG4gICAgUFJPVE9UWVBFLnRvZ2dsZSA9IGZ1bmN0aW9uIChzdGF0ZSwgZXZlbnQpIHtcXG4gICAgICB2YXIgY2FjaGUgPSB0aGlzLmNhY2hlLFxcbiAgICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxcbiAgICAgICAgICB0b29sdGlwID0gdGhpcy50b29sdGlwOyAvLyBUcnkgdG8gcHJldmVudCBmbGlja2VyaW5nIHdoZW4gdG9vbHRpcCBvdmVybGFwcyBzaG93IGVsZW1lbnRcXG5cXG4gICAgICBpZiAoZXZlbnQpIHtcXG4gICAgICAgIGlmICgvb3ZlcnxlbnRlci8udGVzdChldmVudC50eXBlKSAmJiBjYWNoZS5ldmVudCAmJiAvb3V0fGxlYXZlLy50ZXN0KGNhY2hlLmV2ZW50LnR5cGUpICYmIG9wdGlvbnMuc2hvdy50YXJnZXQuYWRkKGV2ZW50LnRhcmdldCkubGVuZ3RoID09PSBvcHRpb25zLnNob3cudGFyZ2V0Lmxlbmd0aCAmJiB0b29sdGlwLmhhcyhldmVudC5yZWxhdGVkVGFyZ2V0KS5sZW5ndGgpIHtcXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XFxuICAgICAgICB9IC8vIENhY2hlIGV2ZW50XFxuXFxuXFxuICAgICAgICBjYWNoZS5ldmVudCA9ICQuZXZlbnQuZml4KGV2ZW50KTtcXG4gICAgICB9IC8vIElmIHdlJ3JlIGN1cnJlbnRseSB3YWl0aW5nIGFuZCB3ZSd2ZSBqdXN0IGhpZGRlbi4uLiBzdG9wIGl0XFxuXFxuXFxuICAgICAgdGhpcy53YWl0aW5nICYmICFzdGF0ZSAmJiAodGhpcy5oaWRkZW5EdXJpbmdXYWl0ID0gVFJVRSk7IC8vIFJlbmRlciB0aGUgdG9vbHRpcCBpZiBzaG93aW5nIGFuZCBpdCBpc24ndCBhbHJlYWR5XFxuXFxuICAgICAgaWYgKCF0aGlzLnJlbmRlcmVkKSB7XFxuICAgICAgICByZXR1cm4gc3RhdGUgPyB0aGlzLnJlbmRlcigxKSA6IHRoaXM7XFxuICAgICAgfSBlbHNlIGlmICh0aGlzLmRlc3Ryb3llZCB8fCB0aGlzLmRpc2FibGVkKSB7XFxuICAgICAgICByZXR1cm4gdGhpcztcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIHR5cGUgPSBzdGF0ZSA/ICdzaG93JyA6ICdoaWRlJyxcXG4gICAgICAgICAgb3B0cyA9IHRoaXMub3B0aW9uc1t0eXBlXSxcXG4gICAgICAgICAgb3RoZXJPcHRzID0gdGhpcy5vcHRpb25zWyFzdGF0ZSA/ICdzaG93JyA6ICdoaWRlJ10sXFxuICAgICAgICAgIHBvc09wdGlvbnMgPSB0aGlzLm9wdGlvbnMucG9zaXRpb24sXFxuICAgICAgICAgIGNvbnRlbnRPcHRpb25zID0gdGhpcy5vcHRpb25zLmNvbnRlbnQsXFxuICAgICAgICAgIHdpZHRoID0gdGhpcy50b29sdGlwLmNzcygnd2lkdGgnKSxcXG4gICAgICAgICAgdmlzaWJsZSA9IHRoaXMudG9vbHRpcC5pcygnOnZpc2libGUnKSxcXG4gICAgICAgICAgYW5pbWF0ZSA9IHN0YXRlIHx8IG9wdHMudGFyZ2V0Lmxlbmd0aCA9PT0gMSxcXG4gICAgICAgICAgc2FtZVRhcmdldCA9ICFldmVudCB8fCBvcHRzLnRhcmdldC5sZW5ndGggPCAyIHx8IGNhY2hlLnRhcmdldFswXSA9PT0gZXZlbnQudGFyZ2V0LFxcbiAgICAgICAgICBpZGVudGljYWxTdGF0ZSxcXG4gICAgICAgICAgYWxsb3csXFxuICAgICAgICAgIHNob3dFdmVudCxcXG4gICAgICAgICAgZGVsYXksXFxuICAgICAgICAgIGFmdGVyOyAvLyBEZXRlY3Qgc3RhdGUgaWYgdmFsaWQgb25lIGlzbid0IHByb3ZpZGVkXFxuXFxuICAgICAgaWYgKF90eXBlb2Yoc3RhdGUpLnNlYXJjaCgnYm9vbGVhbnxudW1iZXInKSkge1xcbiAgICAgICAgc3RhdGUgPSAhdmlzaWJsZTtcXG4gICAgICB9IC8vIENoZWNrIGlmIHRoZSB0b29sdGlwIGlzIGluIGFuIGlkZW50aWNhbCBzdGF0ZSB0byB0aGUgbmV3IHdvdWxkLWJlIHN0YXRlXFxuXFxuXFxuICAgICAgaWRlbnRpY2FsU3RhdGUgPSAhdG9vbHRpcC5pcygnOmFuaW1hdGVkJykgJiYgdmlzaWJsZSA9PT0gc3RhdGUgJiYgc2FtZVRhcmdldDsgLy8gRmlyZSB0b29sdGlwKHNob3cvaGlkZSkgZXZlbnQgYW5kIGNoZWNrIGlmIGRlc3Ryb3llZFxcblxcbiAgICAgIGFsbG93ID0gIWlkZW50aWNhbFN0YXRlID8gISF0aGlzLl90cmlnZ2VyKHR5cGUsIFs5MF0pIDogTlVMTDsgLy8gQ2hlY2sgdG8gbWFrZSBzdXJlIHRoZSB0b29sdGlwIHdhc24ndCBkZXN0cm95ZWQgaW4gdGhlIGNhbGxiYWNrXFxuXFxuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XFxuICAgICAgICByZXR1cm4gdGhpcztcXG4gICAgICB9IC8vIElmIHRoZSB1c2VyIGRpZG4ndCBzdG9wIHRoZSBtZXRob2QgcHJlbWF0dXJlbHkgYW5kIHdlJ3JlIHNob3dpbmcgdGhlIHRvb2x0aXAsIGZvY3VzIGl0XFxuXFxuXFxuICAgICAgaWYgKGFsbG93ICE9PSBGQUxTRSAmJiBzdGF0ZSkge1xcbiAgICAgICAgdGhpcy5mb2N1cyhldmVudCk7XFxuICAgICAgfSAvLyBJZiB0aGUgc3RhdGUgaGFzbid0IGNoYW5nZWQgb3IgdGhlIHVzZXIgc3RvcHBlZCBpdCwgcmV0dXJuIGVhcmx5XFxuXFxuXFxuICAgICAgaWYgKCFhbGxvdyB8fCBpZGVudGljYWxTdGF0ZSkge1xcbiAgICAgICAgcmV0dXJuIHRoaXM7XFxuICAgICAgfSAvLyBTZXQgQVJJQSBoaWRkZW4gYXR0cmlidXRlXFxuXFxuXFxuICAgICAgJC5hdHRyKHRvb2x0aXBbMF0sICdhcmlhLWhpZGRlbicsICEhIXN0YXRlKTsgLy8gRXhlY3V0ZSBzdGF0ZSBzcGVjaWZpYyBwcm9wZXJ0aWVzXFxuXFxuICAgICAgaWYgKHN0YXRlKSB7XFxuICAgICAgICAvLyBTdG9yZSBzaG93IG9yaWdpbiBjb29yZGluYXRlc1xcbiAgICAgICAgdGhpcy5tb3VzZSAmJiAoY2FjaGUub3JpZ2luID0gJC5ldmVudC5maXgodGhpcy5tb3VzZSkpOyAvLyBVcGRhdGUgdG9vbHRpcCBjb250ZW50ICYgdGl0bGUgaWYgaXQncyBhIGR5bmFtaWMgZnVuY3Rpb25cXG5cXG4gICAgICAgIGlmICgkLmlzRnVuY3Rpb24oY29udGVudE9wdGlvbnMudGV4dCkpIHtcXG4gICAgICAgICAgdGhpcy5fdXBkYXRlQ29udGVudChjb250ZW50T3B0aW9ucy50ZXh0LCBGQUxTRSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoJC5pc0Z1bmN0aW9uKGNvbnRlbnRPcHRpb25zLnRpdGxlKSkge1xcbiAgICAgICAgICB0aGlzLl91cGRhdGVUaXRsZShjb250ZW50T3B0aW9ucy50aXRsZSwgRkFMU0UpO1xcbiAgICAgICAgfSAvLyBDYWNoZSBtb3VzZW1vdmUgZXZlbnRzIGZvciBwb3NpdGlvbmluZyBwdXJwb3NlcyAoaWYgbm90IGFscmVhZHkgdHJhY2tpbmcpXFxuXFxuXFxuICAgICAgICBpZiAoIXRyYWNraW5nQm91bmQgJiYgcG9zT3B0aW9ucy50YXJnZXQgPT09ICdtb3VzZScgJiYgcG9zT3B0aW9ucy5hZGp1c3QubW91c2UpIHtcXG4gICAgICAgICAgJChkb2N1bWVudCkuYmluZCgnbW91c2Vtb3ZlLicgKyBOQU1FU1BBQ0UsIHRoaXMuX3N0b3JlTW91c2UpO1xcbiAgICAgICAgICB0cmFja2luZ0JvdW5kID0gVFJVRTtcXG4gICAgICAgIH0gLy8gVXBkYXRlIHRoZSB0b29sdGlwIHBvc2l0aW9uIChzZXQgd2lkdGggZmlyc3QgdG8gcHJldmVudCB2aWV3cG9ydC9tYXgtd2lkdGggaXNzdWVzKVxcblxcblxcbiAgICAgICAgaWYgKCF3aWR0aCkge1xcbiAgICAgICAgICB0b29sdGlwLmNzcygnd2lkdGgnLCB0b29sdGlwLm91dGVyV2lkdGgoRkFMU0UpKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHRoaXMucmVwb3NpdGlvbihldmVudCwgYXJndW1lbnRzWzJdKTtcXG5cXG4gICAgICAgIGlmICghd2lkdGgpIHtcXG4gICAgICAgICAgdG9vbHRpcC5jc3MoJ3dpZHRoJywgJycpO1xcbiAgICAgICAgfSAvLyBIaWRlIG90aGVyIHRvb2x0aXBzIGlmIHRvb2x0aXAgaXMgc29sb1xcblxcblxcbiAgICAgICAgaWYgKCEhb3B0cy5zb2xvKSB7XFxuICAgICAgICAgICh0eXBlb2Ygb3B0cy5zb2xvID09PSAnc3RyaW5nJyA/ICQob3B0cy5zb2xvKSA6ICQoU0VMRUNUT1IsIG9wdHMuc29sbykpLm5vdCh0b29sdGlwKS5ub3Qob3B0cy50YXJnZXQpLnF0aXAoJ2hpZGUnLCAkLkV2ZW50KCd0b29sdGlwc29sbycpKTtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgLy8gQ2xlYXIgc2hvdyB0aW1lciBpZiB3ZSdyZSBoaWRpbmdcXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVycy5zaG93KTsgLy8gUmVtb3ZlIGNhY2hlZCBvcmlnaW4gb24gaGlkZVxcblxcbiAgICAgICAgZGVsZXRlIGNhY2hlLm9yaWdpbjsgLy8gUmVtb3ZlIG1vdXNlIHRyYWNraW5nIGV2ZW50IGlmIG5vdCBuZWVkZWQgKGFsbCB0cmFja2luZyBxVGlwcyBhcmUgaGlkZGVuKVxcblxcbiAgICAgICAgaWYgKHRyYWNraW5nQm91bmQgJiYgISQoU0VMRUNUT1IgKyAnW3RyYWNraW5nPVxcXCJ0cnVlXFxcIl06dmlzaWJsZScsIG9wdHMuc29sbykubm90KHRvb2x0aXApLmxlbmd0aCkge1xcbiAgICAgICAgICAkKGRvY3VtZW50KS51bmJpbmQoJ21vdXNlbW92ZS4nICsgTkFNRVNQQUNFKTtcXG4gICAgICAgICAgdHJhY2tpbmdCb3VuZCA9IEZBTFNFO1xcbiAgICAgICAgfSAvLyBCbHVyIHRoZSB0b29sdGlwXFxuXFxuXFxuICAgICAgICB0aGlzLmJsdXIoZXZlbnQpO1xcbiAgICAgIH0gLy8gRGVmaW5lIHBvc3QtYW5pbWF0aW9uLCBzdGF0ZSBzcGVjaWZpYyBwcm9wZXJ0aWVzXFxuXFxuXFxuICAgICAgYWZ0ZXIgPSAkLnByb3h5KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGlmIChzdGF0ZSkge1xcbiAgICAgICAgICAvLyBQcmV2ZW50IGFudGlhbGlhcyBmcm9tIGRpc2FwcGVhcmluZyBpbiBJRSBieSByZW1vdmluZyBmaWx0ZXJcXG4gICAgICAgICAgaWYgKEJST1dTRVIuaWUpIHtcXG4gICAgICAgICAgICB0b29sdGlwWzBdLnN0eWxlLnJlbW92ZUF0dHJpYnV0ZSgnZmlsdGVyJyk7XFxuICAgICAgICAgIH0gLy8gUmVtb3ZlIG92ZXJmbG93IHNldHRpbmcgdG8gcHJldmVudCB0aXAgYnVnc1xcblxcblxcbiAgICAgICAgICB0b29sdGlwLmNzcygnb3ZlcmZsb3cnLCAnJyk7IC8vIEF1dG9mb2N1cyBlbGVtZW50cyBpZiBlbmFibGVkXFxuXFxuICAgICAgICAgIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIG9wdHMuYXV0b2ZvY3VzKSB7XFxuICAgICAgICAgICAgJCh0aGlzLm9wdGlvbnMuc2hvdy5hdXRvZm9jdXMsIHRvb2x0aXApLmZvY3VzKCk7XFxuICAgICAgICAgIH0gLy8gSWYgc2V0LCBoaWRlIHRvb2x0aXAgd2hlbiBpbmFjdGl2ZSBmb3IgZGVsYXkgcGVyaW9kXFxuXFxuXFxuICAgICAgICAgIHRoaXMub3B0aW9ucy5zaG93LnRhcmdldC50cmlnZ2VyKCdxdGlwLScgKyB0aGlzLmlkICsgJy1pbmFjdGl2ZScpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgLy8gUmVzZXQgQ1NTIHN0YXRlc1xcbiAgICAgICAgICB0b29sdGlwLmNzcyh7XFxuICAgICAgICAgICAgZGlzcGxheTogJycsXFxuICAgICAgICAgICAgdmlzaWJpbGl0eTogJycsXFxuICAgICAgICAgICAgb3BhY2l0eTogJycsXFxuICAgICAgICAgICAgbGVmdDogJycsXFxuICAgICAgICAgICAgdG9wOiAnJ1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH0gLy8gdG9vbHRpcHZpc2libGUvdG9vbHRpcGhpZGRlbiBldmVudHNcXG5cXG5cXG4gICAgICAgIHRoaXMuX3RyaWdnZXIoc3RhdGUgPyAndmlzaWJsZScgOiAnaGlkZGVuJyk7XFxuICAgICAgfSwgdGhpcyk7IC8vIElmIG5vIGVmZmVjdCB0eXBlIGlzIHN1cHBsaWVkLCB1c2UgYSBzaW1wbGUgdG9nZ2xlXFxuXFxuICAgICAgaWYgKG9wdHMuZWZmZWN0ID09PSBGQUxTRSB8fCBhbmltYXRlID09PSBGQUxTRSkge1xcbiAgICAgICAgdG9vbHRpcFt0eXBlXSgpO1xcbiAgICAgICAgYWZ0ZXIoKTtcXG4gICAgICB9IC8vIFVzZSBjdXN0b20gZnVuY3Rpb24gaWYgcHJvdmlkZWRcXG4gICAgICBlbHNlIGlmICgkLmlzRnVuY3Rpb24ob3B0cy5lZmZlY3QpKSB7XFxuICAgICAgICAgIHRvb2x0aXAuc3RvcCgxLCAxKTtcXG4gICAgICAgICAgb3B0cy5lZmZlY3QuY2FsbCh0b29sdGlwLCB0aGlzKTtcXG4gICAgICAgICAgdG9vbHRpcC5xdWV1ZSgnZngnLCBmdW5jdGlvbiAobikge1xcbiAgICAgICAgICAgIGFmdGVyKCk7XFxuICAgICAgICAgICAgbigpO1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH0gLy8gVXNlIGJhc2ljIGZhZGUgZnVuY3Rpb24gYnkgZGVmYXVsdFxcbiAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgdG9vbHRpcC5mYWRlVG8oOTAsIHN0YXRlID8gMSA6IDAsIGFmdGVyKTtcXG4gICAgICAgICAgfSAvLyBJZiBpbmFjdGl2ZSBoaWRlIG1ldGhvZCBpcyBzZXQsIGFjdGl2ZSBpdFxcblxcblxcbiAgICAgIGlmIChzdGF0ZSkge1xcbiAgICAgICAgb3B0cy50YXJnZXQudHJpZ2dlcigncXRpcC0nICsgdGhpcy5pZCArICctaW5hY3RpdmUnKTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHRoaXM7XFxuICAgIH07XFxuXFxuICAgIFBST1RPVFlQRS5zaG93ID0gZnVuY3Rpb24gKGV2ZW50KSB7XFxuICAgICAgcmV0dXJuIHRoaXMudG9nZ2xlKFRSVUUsIGV2ZW50KTtcXG4gICAgfTtcXG5cXG4gICAgUFJPVE9UWVBFLmhpZGUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcXG4gICAgICByZXR1cm4gdGhpcy50b2dnbGUoRkFMU0UsIGV2ZW50KTtcXG4gICAgfTtcXG5cXG4gICAgO1xcblxcbiAgICBQUk9UT1RZUEUuZm9jdXMgPSBmdW5jdGlvbiAoZXZlbnQpIHtcXG4gICAgICBpZiAoIXRoaXMucmVuZGVyZWQgfHwgdGhpcy5kZXN0cm95ZWQpIHtcXG4gICAgICAgIHJldHVybiB0aGlzO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgcXRpcHMgPSAkKFNFTEVDVE9SKSxcXG4gICAgICAgICAgdG9vbHRpcCA9IHRoaXMudG9vbHRpcCxcXG4gICAgICAgICAgY3VySW5kZXggPSBwYXJzZUludCh0b29sdGlwWzBdLnN0eWxlLnpJbmRleCwgMTApLFxcbiAgICAgICAgICBuZXdJbmRleCA9IFFUSVAuemluZGV4ICsgcXRpcHMubGVuZ3RoLFxcbiAgICAgICAgICBmb2N1c2VkRWxlbTsgLy8gT25seSB1cGRhdGUgdGhlIHotaW5kZXggaWYgaXQgaGFzIGNoYW5nZWQgYW5kIHRvb2x0aXAgaXMgbm90IGFscmVhZHkgZm9jdXNlZFxcblxcbiAgICAgIGlmICghdG9vbHRpcC5oYXNDbGFzcyhDTEFTU19GT0NVUykpIHtcXG4gICAgICAgIC8vIHRvb2x0aXBmb2N1cyBldmVudFxcbiAgICAgICAgaWYgKHRoaXMuX3RyaWdnZXIoJ2ZvY3VzJywgW25ld0luZGV4XSwgZXZlbnQpKSB7XFxuICAgICAgICAgIC8vIE9ubHkgdXBkYXRlIHotaW5kZXgncyBpZiB0aGV5J3ZlIGNoYW5nZWRcXG4gICAgICAgICAgaWYgKGN1ckluZGV4ICE9PSBuZXdJbmRleCkge1xcbiAgICAgICAgICAgIC8vIFJlZHVjZSBvdXIgei1pbmRleCdzIGFuZCBrZWVwIHRoZW0gcHJvcGVybHkgb3JkZXJlZFxcbiAgICAgICAgICAgIHF0aXBzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgaWYgKHRoaXMuc3R5bGUuekluZGV4ID4gY3VySW5kZXgpIHtcXG4gICAgICAgICAgICAgICAgdGhpcy5zdHlsZS56SW5kZXggPSB0aGlzLnN0eWxlLnpJbmRleCAtIDE7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSk7IC8vIEZpcmUgYmx1ciBldmVudCBmb3IgZm9jdXNlZCB0b29sdGlwXFxuXFxuICAgICAgICAgICAgcXRpcHMuZmlsdGVyKCcuJyArIENMQVNTX0ZPQ1VTKS5xdGlwKCdibHVyJywgZXZlbnQpO1xcbiAgICAgICAgICB9IC8vIFNldCB0aGUgbmV3IHotaW5kZXhcXG5cXG5cXG4gICAgICAgICAgdG9vbHRpcC5hZGRDbGFzcyhDTEFTU19GT0NVUylbMF0uc3R5bGUuekluZGV4ID0gbmV3SW5kZXg7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiB0aGlzO1xcbiAgICB9O1xcblxcbiAgICBQUk9UT1RZUEUuYmx1ciA9IGZ1bmN0aW9uIChldmVudCkge1xcbiAgICAgIGlmICghdGhpcy5yZW5kZXJlZCB8fCB0aGlzLmRlc3Ryb3llZCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXM7XFxuICAgICAgfSAvLyBTZXQgZm9jdXNlZCBzdGF0dXMgdG8gRkFMU0VcXG5cXG5cXG4gICAgICB0aGlzLnRvb2x0aXAucmVtb3ZlQ2xhc3MoQ0xBU1NfRk9DVVMpOyAvLyB0b29sdGlwYmx1ciBldmVudFxcblxcbiAgICAgIHRoaXMuX3RyaWdnZXIoJ2JsdXInLCBbdGhpcy50b29sdGlwLmNzcygnekluZGV4JyldLCBldmVudCk7XFxuXFxuICAgICAgcmV0dXJuIHRoaXM7XFxuICAgIH07XFxuXFxuICAgIDtcXG5cXG4gICAgUFJPVE9UWVBFLmRpc2FibGUgPSBmdW5jdGlvbiAoc3RhdGUpIHtcXG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcXG4gICAgICAgIHJldHVybiB0aGlzO1xcbiAgICAgIH0gLy8gSWYgJ3RvZ2dsZScgaXMgcGFzc2VkLCB0b2dnbGUgdGhlIGN1cnJlbnQgc3RhdGVcXG5cXG5cXG4gICAgICBpZiAoc3RhdGUgPT09ICd0b2dnbGUnKSB7XFxuICAgICAgICBzdGF0ZSA9ICEodGhpcy5yZW5kZXJlZCA/IHRoaXMudG9vbHRpcC5oYXNDbGFzcyhDTEFTU19ESVNBQkxFRCkgOiB0aGlzLmRpc2FibGVkKTtcXG4gICAgICB9IC8vIERpc2FibGUgaWYgbm8gc3RhdGUgcGFzc2VkXFxuICAgICAgZWxzZSBpZiAoJ2Jvb2xlYW4nICE9PSB0eXBlb2Ygc3RhdGUpIHtcXG4gICAgICAgICAgc3RhdGUgPSBUUlVFO1xcbiAgICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLnJlbmRlcmVkKSB7XFxuICAgICAgICB0aGlzLnRvb2x0aXAudG9nZ2xlQ2xhc3MoQ0xBU1NfRElTQUJMRUQsIHN0YXRlKS5hdHRyKCdhcmlhLWRpc2FibGVkJywgc3RhdGUpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLmRpc2FibGVkID0gISFzdGF0ZTtcXG4gICAgICByZXR1cm4gdGhpcztcXG4gICAgfTtcXG5cXG4gICAgUFJPVE9UWVBFLmVuYWJsZSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICByZXR1cm4gdGhpcy5kaXNhYmxlKEZBTFNFKTtcXG4gICAgfTtcXG5cXG4gICAgO1xcblxcbiAgICBQUk9UT1RZUEUuX2NyZWF0ZUJ1dHRvbiA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICB2YXIgc2VsZiA9IHRoaXMsXFxuICAgICAgICAgIGVsZW1lbnRzID0gdGhpcy5lbGVtZW50cyxcXG4gICAgICAgICAgdG9vbHRpcCA9IGVsZW1lbnRzLnRvb2x0aXAsXFxuICAgICAgICAgIGJ1dHRvbiA9IHRoaXMub3B0aW9ucy5jb250ZW50LmJ1dHRvbixcXG4gICAgICAgICAgaXNTdHJpbmcgPSB0eXBlb2YgYnV0dG9uID09PSAnc3RyaW5nJyxcXG4gICAgICAgICAgY2xvc2UgPSBpc1N0cmluZyA/IGJ1dHRvbiA6ICdDbG9zZSB0b29sdGlwJztcXG5cXG4gICAgICBpZiAoZWxlbWVudHMuYnV0dG9uKSB7XFxuICAgICAgICBlbGVtZW50cy5idXR0b24ucmVtb3ZlKCk7XFxuICAgICAgfSAvLyBVc2UgY3VzdG9tIGJ1dHRvbiBpZiBvbmUgd2FzIHN1cHBsaWVkIGJ5IHVzZXIsIGVsc2UgdXNlIGRlZmF1bHRcXG5cXG5cXG4gICAgICBpZiAoYnV0dG9uLmpxdWVyeSkge1xcbiAgICAgICAgZWxlbWVudHMuYnV0dG9uID0gYnV0dG9uO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBlbGVtZW50cy5idXR0b24gPSAkKCc8YSAvPicsIHtcXG4gICAgICAgICAgJ2NsYXNzJzogJ3F0aXAtY2xvc2UgJyArICh0aGlzLm9wdGlvbnMuc3R5bGUud2lkZ2V0ID8gJycgOiBOQU1FU1BBQ0UgKyAnLWljb24nKSxcXG4gICAgICAgICAgJ3RpdGxlJzogY2xvc2UsXFxuICAgICAgICAgICdhcmlhLWxhYmVsJzogY2xvc2VcXG4gICAgICAgIH0pLnByZXBlbmQoJCgnPHNwYW4gLz4nLCB7XFxuICAgICAgICAgICdjbGFzcyc6ICd1aS1pY29uIHVpLWljb24tY2xvc2UnLFxcbiAgICAgICAgICAnaHRtbCc6ICcmdGltZXM7J1xcbiAgICAgICAgfSkpO1xcbiAgICAgIH0gLy8gQ3JlYXRlIGJ1dHRvbiBhbmQgc2V0dXAgYXR0cmlidXRlc1xcblxcblxcbiAgICAgIGVsZW1lbnRzLmJ1dHRvbi5hcHBlbmRUbyhlbGVtZW50cy50aXRsZWJhciB8fCB0b29sdGlwKS5hdHRyKCdyb2xlJywgJ2J1dHRvbicpLmNsaWNrKGZ1bmN0aW9uIChldmVudCkge1xcbiAgICAgICAgaWYgKCF0b29sdGlwLmhhc0NsYXNzKENMQVNTX0RJU0FCTEVEKSkge1xcbiAgICAgICAgICBzZWxmLmhpZGUoZXZlbnQpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIEZBTFNFO1xcbiAgICAgIH0pO1xcbiAgICB9O1xcblxcbiAgICBQUk9UT1RZUEUuX3VwZGF0ZUJ1dHRvbiA9IGZ1bmN0aW9uIChidXR0b24pIHtcXG4gICAgICAvLyBNYWtlIHN1cmUgdG9vbHRpcCBpcyByZW5kZXJlZCBhbmQgaWYgbm90LCByZXR1cm5cXG4gICAgICBpZiAoIXRoaXMucmVuZGVyZWQpIHtcXG4gICAgICAgIHJldHVybiBGQUxTRTtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIGVsZW0gPSB0aGlzLmVsZW1lbnRzLmJ1dHRvbjtcXG5cXG4gICAgICBpZiAoYnV0dG9uKSB7XFxuICAgICAgICB0aGlzLl9jcmVhdGVCdXR0b24oKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgZWxlbS5yZW1vdmUoKTtcXG4gICAgICB9XFxuICAgIH07XFxuXFxuICAgIDsgLy8gV2lkZ2V0IGNsYXNzIGNyZWF0b3JcXG5cXG4gICAgZnVuY3Rpb24gY3JlYXRlV2lkZ2V0Q2xhc3MoY2xzKSB7XFxuICAgICAgcmV0dXJuIFdJREdFVC5jb25jYXQoJycpLmpvaW4oY2xzID8gJy0nICsgY2xzICsgJyAnIDogJyAnKTtcXG4gICAgfSAvLyBXaWRnZXQgY2xhc3Mgc2V0dGVyIG1ldGhvZFxcblxcblxcbiAgICBQUk9UT1RZUEUuX3NldFdpZGdldCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICB2YXIgb24gPSB0aGlzLm9wdGlvbnMuc3R5bGUud2lkZ2V0LFxcbiAgICAgICAgICBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHMsXFxuICAgICAgICAgIHRvb2x0aXAgPSBlbGVtZW50cy50b29sdGlwLFxcbiAgICAgICAgICBkaXNhYmxlZCA9IHRvb2x0aXAuaGFzQ2xhc3MoQ0xBU1NfRElTQUJMRUQpO1xcbiAgICAgIHRvb2x0aXAucmVtb3ZlQ2xhc3MoQ0xBU1NfRElTQUJMRUQpO1xcbiAgICAgIENMQVNTX0RJU0FCTEVEID0gb24gPyAndWktc3RhdGUtZGlzYWJsZWQnIDogJ3F0aXAtZGlzYWJsZWQnO1xcbiAgICAgIHRvb2x0aXAudG9nZ2xlQ2xhc3MoQ0xBU1NfRElTQUJMRUQsIGRpc2FibGVkKTtcXG4gICAgICB0b29sdGlwLnRvZ2dsZUNsYXNzKCd1aS1oZWxwZXItcmVzZXQgJyArIGNyZWF0ZVdpZGdldENsYXNzKCksIG9uKS50b2dnbGVDbGFzcyhDTEFTU19ERUZBVUxULCB0aGlzLm9wdGlvbnMuc3R5bGUuZGVmICYmICFvbik7XFxuXFxuICAgICAgaWYgKGVsZW1lbnRzLmNvbnRlbnQpIHtcXG4gICAgICAgIGVsZW1lbnRzLmNvbnRlbnQudG9nZ2xlQ2xhc3MoY3JlYXRlV2lkZ2V0Q2xhc3MoJ2NvbnRlbnQnKSwgb24pO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoZWxlbWVudHMudGl0bGViYXIpIHtcXG4gICAgICAgIGVsZW1lbnRzLnRpdGxlYmFyLnRvZ2dsZUNsYXNzKGNyZWF0ZVdpZGdldENsYXNzKCdoZWFkZXInKSwgb24pO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoZWxlbWVudHMuYnV0dG9uKSB7XFxuICAgICAgICBlbGVtZW50cy5idXR0b24udG9nZ2xlQ2xhc3MoTkFNRVNQQUNFICsgJy1pY29uJywgIW9uKTtcXG4gICAgICB9XFxuICAgIH07XFxuXFxuICAgIDtcXG5cXG4gICAgZnVuY3Rpb24gZGVsYXkoY2FsbGJhY2ssIGR1cmF0aW9uKSB7XFxuICAgICAgLy8gSWYgdG9vbHRpcCBoYXMgZGlzcGxheWVkLCBzdGFydCBoaWRlIHRpbWVyXFxuICAgICAgaWYgKGR1cmF0aW9uID4gMCkge1xcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoJC5wcm94eShjYWxsYmFjaywgdGhpcyksIGR1cmF0aW9uKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzKTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gc2hvd01ldGhvZChldmVudCkge1xcbiAgICAgIGlmICh0aGlzLnRvb2x0aXAuaGFzQ2xhc3MoQ0xBU1NfRElTQUJMRUQpKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfSAvLyBDbGVhciBoaWRlIHRpbWVyc1xcblxcblxcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVycy5zaG93KTtcXG4gICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcnMuaGlkZSk7IC8vIFN0YXJ0IHNob3cgdGltZXJcXG5cXG4gICAgICB0aGlzLnRpbWVycy5zaG93ID0gZGVsYXkuY2FsbCh0aGlzLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICB0aGlzLnRvZ2dsZShUUlVFLCBldmVudCk7XFxuICAgICAgfSwgdGhpcy5vcHRpb25zLnNob3cuZGVsYXkpO1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIGhpZGVNZXRob2QoZXZlbnQpIHtcXG4gICAgICBpZiAodGhpcy50b29sdGlwLmhhc0NsYXNzKENMQVNTX0RJU0FCTEVEKSB8fCB0aGlzLmRlc3Ryb3llZCkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH0gLy8gQ2hlY2sgaWYgbmV3IHRhcmdldCB3YXMgYWN0dWFsbHkgdGhlIHRvb2x0aXAgZWxlbWVudFxcblxcblxcbiAgICAgIHZhciByZWxhdGVkVGFyZ2V0ID0gJChldmVudC5yZWxhdGVkVGFyZ2V0KSxcXG4gICAgICAgICAgb250b1Rvb2x0aXAgPSByZWxhdGVkVGFyZ2V0LmNsb3Nlc3QoU0VMRUNUT1IpWzBdID09PSB0aGlzLnRvb2x0aXBbMF0sXFxuICAgICAgICAgIG9udG9UYXJnZXQgPSByZWxhdGVkVGFyZ2V0WzBdID09PSB0aGlzLm9wdGlvbnMuc2hvdy50YXJnZXRbMF07IC8vIENsZWFyIHRpbWVycyBhbmQgc3RvcCBhbmltYXRpb24gcXVldWVcXG5cXG4gICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcnMuc2hvdyk7XFxuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXJzLmhpZGUpOyAvLyBQcmV2ZW50IGhpZGluZyBpZiB0b29sdGlwIGlzIGZpeGVkIGFuZCBldmVudCB0YXJnZXQgaXMgdGhlIHRvb2x0aXAuXFxuICAgICAgLy8gT3IgaWYgbW91c2UgcG9zaXRpb25pbmcgaXMgZW5hYmxlZCBhbmQgY3Vyc29yIG1vbWVudGFyaWx5IG92ZXJsYXBzXFxuXFxuICAgICAgaWYgKHRoaXMgIT09IHJlbGF0ZWRUYXJnZXRbMF0gJiYgdGhpcy5vcHRpb25zLnBvc2l0aW9uLnRhcmdldCA9PT0gJ21vdXNlJyAmJiBvbnRvVG9vbHRpcCB8fCB0aGlzLm9wdGlvbnMuaGlkZS5maXhlZCAmJiAvbW91c2Uob3V0fGxlYXZlfG1vdmUpLy50ZXN0KGV2ZW50LnR5cGUpICYmIChvbnRvVG9vbHRpcCB8fCBvbnRvVGFyZ2V0KSkge1xcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XFxuICAgICAgICB9IGNhdGNoIChlKSB7fVxcblxcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH0gLy8gSWYgdG9vbHRpcCBoYXMgZGlzcGxheWVkLCBzdGFydCBoaWRlIHRpbWVyXFxuXFxuXFxuICAgICAgdGhpcy50aW1lcnMuaGlkZSA9IGRlbGF5LmNhbGwodGhpcywgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdGhpcy50b2dnbGUoRkFMU0UsIGV2ZW50KTtcXG4gICAgICB9LCB0aGlzLm9wdGlvbnMuaGlkZS5kZWxheSwgdGhpcyk7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gaW5hY3RpdmVNZXRob2QoZXZlbnQpIHtcXG4gICAgICBpZiAodGhpcy50b29sdGlwLmhhc0NsYXNzKENMQVNTX0RJU0FCTEVEKSB8fCAhdGhpcy5vcHRpb25zLmhpZGUuaW5hY3RpdmUpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9IC8vIENsZWFyIHRpbWVyXFxuXFxuXFxuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXJzLmluYWN0aXZlKTtcXG4gICAgICB0aGlzLnRpbWVycy5pbmFjdGl2ZSA9IGRlbGF5LmNhbGwodGhpcywgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdGhpcy5oaWRlKGV2ZW50KTtcXG4gICAgICB9LCB0aGlzLm9wdGlvbnMuaGlkZS5pbmFjdGl2ZSk7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gcmVwb3NpdGlvbk1ldGhvZChldmVudCkge1xcbiAgICAgIGlmICh0aGlzLnJlbmRlcmVkICYmIHRoaXMudG9vbHRpcFswXS5vZmZzZXRXaWR0aCA+IDApIHtcXG4gICAgICAgIHRoaXMucmVwb3NpdGlvbihldmVudCk7XFxuICAgICAgfVxcbiAgICB9IC8vIFN0b3JlIG1vdXNlIGNvb3JkaW5hdGVzXFxuXFxuXFxuICAgIFBST1RPVFlQRS5fc3RvcmVNb3VzZSA9IGZ1bmN0aW9uIChldmVudCkge1xcbiAgICAgICh0aGlzLm1vdXNlID0gJC5ldmVudC5maXgoZXZlbnQpKS50eXBlID0gJ21vdXNlbW92ZSc7XFxuICAgICAgcmV0dXJuIHRoaXM7XFxuICAgIH07IC8vIEJpbmQgZXZlbnRzXFxuXFxuXFxuICAgIFBST1RPVFlQRS5fYmluZCA9IGZ1bmN0aW9uICh0YXJnZXRzLCBldmVudHMsIG1ldGhvZCwgc3VmZml4LCBjb250ZXh0KSB7XFxuICAgICAgaWYgKCF0YXJnZXRzIHx8ICFtZXRob2QgfHwgIWV2ZW50cy5sZW5ndGgpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIG5zID0gJy4nICsgdGhpcy5faWQgKyAoc3VmZml4ID8gJy0nICsgc3VmZml4IDogJycpO1xcbiAgICAgICQodGFyZ2V0cykuYmluZCgoZXZlbnRzLnNwbGl0ID8gZXZlbnRzIDogZXZlbnRzLmpvaW4obnMgKyAnICcpKSArIG5zLCAkLnByb3h5KG1ldGhvZCwgY29udGV4dCB8fCB0aGlzKSk7XFxuICAgICAgcmV0dXJuIHRoaXM7XFxuICAgIH07XFxuXFxuICAgIFBST1RPVFlQRS5fdW5iaW5kID0gZnVuY3Rpb24gKHRhcmdldHMsIHN1ZmZpeCkge1xcbiAgICAgIHRhcmdldHMgJiYgJCh0YXJnZXRzKS51bmJpbmQoJy4nICsgdGhpcy5faWQgKyAoc3VmZml4ID8gJy0nICsgc3VmZml4IDogJycpKTtcXG4gICAgICByZXR1cm4gdGhpcztcXG4gICAgfTsgLy8gR2xvYmFsIGRlbGVnYXRpb24gaGVscGVyXFxuXFxuXFxuICAgIGZ1bmN0aW9uIGRlbGVnYXRlKHNlbGVjdG9yLCBldmVudHMsIG1ldGhvZCkge1xcbiAgICAgICQoZG9jdW1lbnQuYm9keSkuZGVsZWdhdGUoc2VsZWN0b3IsIChldmVudHMuc3BsaXQgPyBldmVudHMgOiBldmVudHMuam9pbignLicgKyBOQU1FU1BBQ0UgKyAnICcpKSArICcuJyArIE5BTUVTUEFDRSwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIGFwaSA9IFFUSVAuYXBpWyQuYXR0cih0aGlzLCBBVFRSX0lEKV07XFxuICAgICAgICBhcGkgJiYgIWFwaS5kaXNhYmxlZCAmJiBtZXRob2QuYXBwbHkoYXBpLCBhcmd1bWVudHMpO1xcbiAgICAgIH0pO1xcbiAgICB9IC8vIEV2ZW50IHRyaWdnZXJcXG5cXG5cXG4gICAgUFJPVE9UWVBFLl90cmlnZ2VyID0gZnVuY3Rpb24gKHR5cGUsIGFyZ3MsIGV2ZW50KSB7XFxuICAgICAgdmFyIGNhbGxiYWNrID0gJC5FdmVudCgndG9vbHRpcCcgKyB0eXBlKTtcXG4gICAgICBjYWxsYmFjay5vcmlnaW5hbEV2ZW50ID0gZXZlbnQgJiYgJC5leHRlbmQoe30sIGV2ZW50KSB8fCB0aGlzLmNhY2hlLmV2ZW50IHx8IE5VTEw7XFxuICAgICAgdGhpcy50cmlnZ2VyaW5nID0gdHlwZTtcXG4gICAgICB0aGlzLnRvb2x0aXAudHJpZ2dlcihjYWxsYmFjaywgW3RoaXNdLmNvbmNhdChhcmdzIHx8IFtdKSk7XFxuICAgICAgdGhpcy50cmlnZ2VyaW5nID0gRkFMU0U7XFxuICAgICAgcmV0dXJuICFjYWxsYmFjay5pc0RlZmF1bHRQcmV2ZW50ZWQoKTtcXG4gICAgfTtcXG5cXG4gICAgUFJPVE9UWVBFLl9iaW5kRXZlbnRzID0gZnVuY3Rpb24gKHNob3dFdmVudHMsIGhpZGVFdmVudHMsIHNob3dUYXJnZXRzLCBoaWRlVGFyZ2V0cywgc2hvd01ldGhvZCwgaGlkZU1ldGhvZCkge1xcbiAgICAgIC8vIEdldCB0YXNyZ2V0cyB0aGF0IGx5ZSB3aXRoaW4gYm90aFxcbiAgICAgIHZhciBzaW1pbGFyVGFyZ2V0cyA9IHNob3dUYXJnZXRzLmZpbHRlcihoaWRlVGFyZ2V0cykuYWRkKGhpZGVUYXJnZXRzLmZpbHRlcihzaG93VGFyZ2V0cykpLFxcbiAgICAgICAgICB0b2dnbGVFdmVudHMgPSBbXTsgLy8gSWYgaGlkZSBhbmQgc2hvdyB0YXJnZXRzIGFyZSB0aGUgc2FtZS4uLlxcblxcbiAgICAgIGlmIChzaW1pbGFyVGFyZ2V0cy5sZW5ndGgpIHtcXG4gICAgICAgIC8vIEZpbHRlciBpZGVudGljYWwgc2hvdy9oaWRlIGV2ZW50c1xcbiAgICAgICAgJC5lYWNoKGhpZGVFdmVudHMsIGZ1bmN0aW9uIChpLCB0eXBlKSB7XFxuICAgICAgICAgIHZhciBzaG93SW5kZXggPSAkLmluQXJyYXkodHlwZSwgc2hvd0V2ZW50cyk7IC8vIEJvdGggZXZlbnRzIGFyZSBpZGVudGljYWwsIHJlbW92ZSBmcm9tIGJvdGggaGlkZSBhbmQgc2hvdyBldmVudHNcXG4gICAgICAgICAgLy8gYW5kIGFwcGVuZCB0byB0b2dnbGVFdmVudHNcXG5cXG4gICAgICAgICAgc2hvd0luZGV4ID4gLTEgJiYgdG9nZ2xlRXZlbnRzLnB1c2goc2hvd0V2ZW50cy5zcGxpY2Uoc2hvd0luZGV4LCAxKVswXSk7XFxuICAgICAgICB9KTsgLy8gVG9nZ2xlIGV2ZW50cyBhcmUgc3BlY2lhbCBjYXNlIG9mIGlkZW50aWNhbCBzaG93L2hpZGUgZXZlbnRzLCB3aGljaCBoYXBwZW4gaW4gc2VxdWVuY2VcXG5cXG4gICAgICAgIGlmICh0b2dnbGVFdmVudHMubGVuZ3RoKSB7XFxuICAgICAgICAgIC8vIEJpbmQgdG9nZ2xlIGV2ZW50cyB0byB0aGUgc2ltaWxhciB0YXJnZXRzXFxuICAgICAgICAgIHRoaXMuX2JpbmQoc2ltaWxhclRhcmdldHMsIHRvZ2dsZUV2ZW50cywgZnVuY3Rpb24gKGV2ZW50KSB7XFxuICAgICAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5yZW5kZXJlZCA/IHRoaXMudG9vbHRpcFswXS5vZmZzZXRXaWR0aCA+IDAgOiBmYWxzZTtcXG4gICAgICAgICAgICAoc3RhdGUgPyBoaWRlTWV0aG9kIDogc2hvd01ldGhvZCkuY2FsbCh0aGlzLCBldmVudCk7XFxuICAgICAgICAgIH0pOyAvLyBSZW1vdmUgdGhlIHNpbWlsYXIgdGFyZ2V0cyBmcm9tIHRoZSByZWd1bGFyIHNob3cvaGlkZSBiaW5kaW5nc1xcblxcblxcbiAgICAgICAgICBzaG93VGFyZ2V0cyA9IHNob3dUYXJnZXRzLm5vdChzaW1pbGFyVGFyZ2V0cyk7XFxuICAgICAgICAgIGhpZGVUYXJnZXRzID0gaGlkZVRhcmdldHMubm90KHNpbWlsYXJUYXJnZXRzKTtcXG4gICAgICAgIH1cXG4gICAgICB9IC8vIEFwcGx5IHNob3cvaGlkZS90b2dnbGUgZXZlbnRzXFxuXFxuXFxuICAgICAgdGhpcy5fYmluZChzaG93VGFyZ2V0cywgc2hvd0V2ZW50cywgc2hvd01ldGhvZCk7XFxuXFxuICAgICAgdGhpcy5fYmluZChoaWRlVGFyZ2V0cywgaGlkZUV2ZW50cywgaGlkZU1ldGhvZCk7XFxuICAgIH07XFxuXFxuICAgIFBST1RPVFlQRS5fYXNzaWduSW5pdGlhbEV2ZW50cyA9IGZ1bmN0aW9uIChldmVudCkge1xcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxcbiAgICAgICAgICBzaG93VGFyZ2V0ID0gb3B0aW9ucy5zaG93LnRhcmdldCxcXG4gICAgICAgICAgaGlkZVRhcmdldCA9IG9wdGlvbnMuaGlkZS50YXJnZXQsXFxuICAgICAgICAgIHNob3dFdmVudHMgPSBvcHRpb25zLnNob3cuZXZlbnQgPyAkLnRyaW0oJycgKyBvcHRpb25zLnNob3cuZXZlbnQpLnNwbGl0KCcgJykgOiBbXSxcXG4gICAgICAgICAgaGlkZUV2ZW50cyA9IG9wdGlvbnMuaGlkZS5ldmVudCA/ICQudHJpbSgnJyArIG9wdGlvbnMuaGlkZS5ldmVudCkuc3BsaXQoJyAnKSA6IFtdOyAvLyBDYXRjaCByZW1vdmUvcmVtb3ZlcXRpcCBldmVudHMgb24gdGFyZ2V0IGVsZW1lbnQgdG8gZGVzdHJveSByZWR1bmRhbnQgdG9vbHRpcHNcXG5cXG4gICAgICB0aGlzLl9iaW5kKHRoaXMuZWxlbWVudHMudGFyZ2V0LCBbJ3JlbW92ZScsICdyZW1vdmVxdGlwJ10sIGZ1bmN0aW9uIChldmVudCkge1xcbiAgICAgICAgdGhpcy5kZXN0cm95KHRydWUpO1xcbiAgICAgIH0sICdkZXN0cm95Jyk7XFxuICAgICAgLypcXG4gICAgICAgKiBNYWtlIHN1cmUgaG92ZXJJbnRlbnQgZnVuY3Rpb25zIHByb3Blcmx5IGJ5IHVzaW5nIG1vdXNlbGVhdmUgYXMgYSBoaWRlIGV2ZW50IGlmXFxuICAgICAgICogbW91c2VlbnRlci9tb3VzZW91dCBpcyB1c2VkIGZvciBzaG93LmV2ZW50LCBldmVuIGlmIGl0IGlzbid0IGluIHRoZSB1c2VycyBvcHRpb25zLlxcbiAgICAgICAqL1xcblxcblxcbiAgICAgIGlmICgvbW91c2Uob3ZlcnxlbnRlcikvaS50ZXN0KG9wdGlvbnMuc2hvdy5ldmVudCkgJiYgIS9tb3VzZShvdXR8bGVhdmUpL2kudGVzdChvcHRpb25zLmhpZGUuZXZlbnQpKSB7XFxuICAgICAgICBoaWRlRXZlbnRzLnB1c2goJ21vdXNlbGVhdmUnKTtcXG4gICAgICB9XFxuICAgICAgLypcXG4gICAgICAgKiBBbHNvIG1ha2Ugc3VyZSBpbml0aWFsIG1vdXNlIHRhcmdldHRpbmcgd29ya3MgY29ycmVjdGx5IGJ5IGNhY2hpbmcgbW91c2Vtb3ZlIGNvb3Jkc1xcbiAgICAgICAqIG9uIHNob3cgdGFyZ2V0cyBiZWZvcmUgdGhlIHRvb2x0aXAgaGFzIHJlbmRlcmVkLiBBbHNvIHNldCBvblRhcmdldCB3aGVuIHRyaWdnZXJlZCB0b1xcbiAgICAgICAqIGtlZXAgbW91c2UgdHJhY2tpbmcgd29ya2luZy5cXG4gICAgICAgKi9cXG5cXG5cXG4gICAgICB0aGlzLl9iaW5kKHNob3dUYXJnZXQsICdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZXZlbnQpIHtcXG4gICAgICAgIHRoaXMuX3N0b3JlTW91c2UoZXZlbnQpO1xcblxcbiAgICAgICAgdGhpcy5jYWNoZS5vblRhcmdldCA9IFRSVUU7XFxuICAgICAgfSk7IC8vIERlZmluZSBob3ZlckludGVudCBmdW5jdGlvblxcblxcblxcbiAgICAgIGZ1bmN0aW9uIGhvdmVySW50ZW50KGV2ZW50KSB7XFxuICAgICAgICAvLyBPbmx5IGNvbnRpbnVlIGlmIHRvb2x0aXAgaXNuJ3QgZGlzYWJsZWRcXG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkIHx8IHRoaXMuZGVzdHJveWVkKSB7XFxuICAgICAgICAgIHJldHVybiBGQUxTRTtcXG4gICAgICAgIH0gLy8gQ2FjaGUgdGhlIGV2ZW50IGRhdGFcXG5cXG5cXG4gICAgICAgIHRoaXMuY2FjaGUuZXZlbnQgPSBldmVudCAmJiAkLmV2ZW50LmZpeChldmVudCk7XFxuICAgICAgICB0aGlzLmNhY2hlLnRhcmdldCA9IGV2ZW50ICYmICQoZXZlbnQudGFyZ2V0KTsgLy8gU3RhcnQgdGhlIGV2ZW50IHNlcXVlbmNlXFxuXFxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcnMuc2hvdyk7XFxuICAgICAgICB0aGlzLnRpbWVycy5zaG93ID0gZGVsYXkuY2FsbCh0aGlzLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHRoaXMucmVuZGVyKF90eXBlb2YoZXZlbnQpID09PSAnb2JqZWN0JyB8fCBvcHRpb25zLnNob3cucmVhZHkpO1xcbiAgICAgICAgfSwgb3B0aW9ucy5wcmVyZW5kZXIgPyAwIDogb3B0aW9ucy5zaG93LmRlbGF5KTtcXG4gICAgICB9IC8vIEZpbHRlciBhbmQgYmluZCBldmVudHNcXG5cXG5cXG4gICAgICB0aGlzLl9iaW5kRXZlbnRzKHNob3dFdmVudHMsIGhpZGVFdmVudHMsIHNob3dUYXJnZXQsIGhpZGVUYXJnZXQsIGhvdmVySW50ZW50LCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICBpZiAoIXRoaXMudGltZXJzKSB7XFxuICAgICAgICAgIHJldHVybiBGQUxTRTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVycy5zaG93KTtcXG4gICAgICB9KTsgLy8gUHJlcmVuZGVyaW5nIGlzIGVuYWJsZWQsIGNyZWF0ZSB0b29sdGlwIG5vd1xcblxcblxcbiAgICAgIGlmIChvcHRpb25zLnNob3cucmVhZHkgfHwgb3B0aW9ucy5wcmVyZW5kZXIpIHtcXG4gICAgICAgIGhvdmVySW50ZW50LmNhbGwodGhpcywgZXZlbnQpO1xcbiAgICAgIH1cXG4gICAgfTsgLy8gRXZlbnQgYXNzaWdubWVudCBtZXRob2RcXG5cXG5cXG4gICAgUFJPVE9UWVBFLl9hc3NpZ25FdmVudHMgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgdmFyIHNlbGYgPSB0aGlzLFxcbiAgICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxcbiAgICAgICAgICBwb3NPcHRpb25zID0gb3B0aW9ucy5wb3NpdGlvbixcXG4gICAgICAgICAgdG9vbHRpcCA9IHRoaXMudG9vbHRpcCxcXG4gICAgICAgICAgc2hvd1RhcmdldCA9IG9wdGlvbnMuc2hvdy50YXJnZXQsXFxuICAgICAgICAgIGhpZGVUYXJnZXQgPSBvcHRpb25zLmhpZGUudGFyZ2V0LFxcbiAgICAgICAgICBjb250YWluZXJUYXJnZXQgPSBwb3NPcHRpb25zLmNvbnRhaW5lcixcXG4gICAgICAgICAgdmlld3BvcnRUYXJnZXQgPSBwb3NPcHRpb25zLnZpZXdwb3J0LFxcbiAgICAgICAgICBkb2N1bWVudFRhcmdldCA9ICQoZG9jdW1lbnQpLFxcbiAgICAgICAgICBib2R5VGFyZ2V0ID0gJChkb2N1bWVudC5ib2R5KSxcXG4gICAgICAgICAgd2luZG93VGFyZ2V0ID0gJCh3aW5kb3cpLFxcbiAgICAgICAgICBzaG93RXZlbnRzID0gb3B0aW9ucy5zaG93LmV2ZW50ID8gJC50cmltKCcnICsgb3B0aW9ucy5zaG93LmV2ZW50KS5zcGxpdCgnICcpIDogW10sXFxuICAgICAgICAgIGhpZGVFdmVudHMgPSBvcHRpb25zLmhpZGUuZXZlbnQgPyAkLnRyaW0oJycgKyBvcHRpb25zLmhpZGUuZXZlbnQpLnNwbGl0KCcgJykgOiBbXTsgLy8gQXNzaWduIHBhc3NlZCBldmVudCBjYWxsYmFja3NcXG5cXG4gICAgICAkLmVhY2gob3B0aW9ucy5ldmVudHMsIGZ1bmN0aW9uIChuYW1lLCBjYWxsYmFjaykge1xcbiAgICAgICAgc2VsZi5fYmluZCh0b29sdGlwLCBuYW1lID09PSAndG9nZ2xlJyA/IFsndG9vbHRpcHNob3cnLCAndG9vbHRpcGhpZGUnXSA6IFsndG9vbHRpcCcgKyBuYW1lXSwgY2FsbGJhY2ssIG51bGwsIHRvb2x0aXApO1xcbiAgICAgIH0pOyAvLyBIaWRlIHRvb2x0aXBzIHdoZW4gbGVhdmluZyBjdXJyZW50IHdpbmRvdy9mcmFtZSAoYnV0IG5vdCBzZWxlY3Qvb3B0aW9uIGVsZW1lbnRzKVxcblxcbiAgICAgIGlmICgvbW91c2Uob3V0fGxlYXZlKS9pLnRlc3Qob3B0aW9ucy5oaWRlLmV2ZW50KSAmJiBvcHRpb25zLmhpZGUubGVhdmUgPT09ICd3aW5kb3cnKSB7XFxuICAgICAgICB0aGlzLl9iaW5kKGRvY3VtZW50VGFyZ2V0LCBbJ21vdXNlb3V0JywgJ2JsdXInXSwgZnVuY3Rpb24gKGV2ZW50KSB7XFxuICAgICAgICAgIGlmICghL3NlbGVjdHxvcHRpb24vLnRlc3QoZXZlbnQudGFyZ2V0Lm5vZGVOYW1lKSAmJiAhZXZlbnQucmVsYXRlZFRhcmdldCkge1xcbiAgICAgICAgICAgIHRoaXMuaGlkZShldmVudCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICAgIH0gLy8gRW5hYmxlIGhpZGUuZml4ZWQgYnkgYWRkaW5nIGFwcHJvcHJpYXRlIGNsYXNzXFxuXFxuXFxuICAgICAgaWYgKG9wdGlvbnMuaGlkZS5maXhlZCkge1xcbiAgICAgICAgaGlkZVRhcmdldCA9IGhpZGVUYXJnZXQuYWRkKHRvb2x0aXAuYWRkQ2xhc3MoQ0xBU1NfRklYRUQpKTtcXG4gICAgICB9XFxuICAgICAgLypcXG4gICAgICAgKiBNYWtlIHN1cmUgaG92ZXJJbnRlbnQgZnVuY3Rpb25zIHByb3Blcmx5IGJ5IHVzaW5nIG1vdXNlbGVhdmUgdG8gY2xlYXIgc2hvdyB0aW1lciBpZlxcbiAgICAgICAqIG1vdXNlZW50ZXIvbW91c2VvdXQgaXMgdXNlZCBmb3Igc2hvdy5ldmVudCwgZXZlbiBpZiBpdCBpc24ndCBpbiB0aGUgdXNlcnMgb3B0aW9ucy5cXG4gICAgICAgKi9cXG4gICAgICBlbHNlIGlmICgvbW91c2Uob3ZlcnxlbnRlcikvaS50ZXN0KG9wdGlvbnMuc2hvdy5ldmVudCkpIHtcXG4gICAgICAgICAgdGhpcy5fYmluZChoaWRlVGFyZ2V0LCAnbW91c2VsZWF2ZScsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcnMuc2hvdyk7XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfSAvLyBIaWRlIHRvb2x0aXAgb24gZG9jdW1lbnQgbW91c2Vkb3duIGlmIHVuZm9jdXMgZXZlbnRzIGFyZSBlbmFibGVkXFxuXFxuXFxuICAgICAgaWYgKCgnJyArIG9wdGlvbnMuaGlkZS5ldmVudCkuaW5kZXhPZigndW5mb2N1cycpID4gLTEpIHtcXG4gICAgICAgIHRoaXMuX2JpbmQoY29udGFpbmVyVGFyZ2V0LmNsb3Nlc3QoJ2h0bWwnKSwgWydtb3VzZWRvd24nLCAndG91Y2hzdGFydCddLCBmdW5jdGlvbiAoZXZlbnQpIHtcXG4gICAgICAgICAgdmFyIGVsZW0gPSAkKGV2ZW50LnRhcmdldCksXFxuICAgICAgICAgICAgICBlbmFibGVkID0gdGhpcy5yZW5kZXJlZCAmJiAhdGhpcy50b29sdGlwLmhhc0NsYXNzKENMQVNTX0RJU0FCTEVEKSAmJiB0aGlzLnRvb2x0aXBbMF0ub2Zmc2V0V2lkdGggPiAwLFxcbiAgICAgICAgICAgICAgaXNBbmNlc3RvciA9IGVsZW0ucGFyZW50cyhTRUxFQ1RPUikuZmlsdGVyKHRoaXMudG9vbHRpcFswXSkubGVuZ3RoID4gMDtcXG5cXG4gICAgICAgICAgaWYgKGVsZW1bMF0gIT09IHRoaXMudGFyZ2V0WzBdICYmIGVsZW1bMF0gIT09IHRoaXMudG9vbHRpcFswXSAmJiAhaXNBbmNlc3RvciAmJiAhdGhpcy50YXJnZXQuaGFzKGVsZW1bMF0pLmxlbmd0aCAmJiBlbmFibGVkKSB7XFxuICAgICAgICAgICAgdGhpcy5oaWRlKGV2ZW50KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgICAgfSAvLyBDaGVjayBpZiB0aGUgdG9vbHRpcCBoaWRlcyB3aGVuIGluYWN0aXZlXFxuXFxuXFxuICAgICAgaWYgKCdudW1iZXInID09PSB0eXBlb2Ygb3B0aW9ucy5oaWRlLmluYWN0aXZlKSB7XFxuICAgICAgICAvLyBCaW5kIGluYWN0aXZlIG1ldGhvZCB0byBzaG93IHRhcmdldChzKSBhcyBhIGN1c3RvbSBldmVudFxcbiAgICAgICAgdGhpcy5fYmluZChzaG93VGFyZ2V0LCAncXRpcC0nICsgdGhpcy5pZCArICctaW5hY3RpdmUnLCBpbmFjdGl2ZU1ldGhvZCwgJ2luYWN0aXZlJyk7IC8vIERlZmluZSBldmVudHMgd2hpY2ggcmVzZXQgdGhlICdpbmFjdGl2ZScgZXZlbnQgaGFuZGxlclxcblxcblxcbiAgICAgICAgdGhpcy5fYmluZChoaWRlVGFyZ2V0LmFkZCh0b29sdGlwKSwgUVRJUC5pbmFjdGl2ZUV2ZW50cywgaW5hY3RpdmVNZXRob2QpO1xcbiAgICAgIH0gLy8gRmlsdGVyIGFuZCBiaW5kIGV2ZW50c1xcblxcblxcbiAgICAgIHRoaXMuX2JpbmRFdmVudHMoc2hvd0V2ZW50cywgaGlkZUV2ZW50cywgc2hvd1RhcmdldCwgaGlkZVRhcmdldCwgc2hvd01ldGhvZCwgaGlkZU1ldGhvZCk7IC8vIE1vdXNlIG1vdmVtZW50IGJpbmRpbmdzXFxuXFxuXFxuICAgICAgdGhpcy5fYmluZChzaG93VGFyZ2V0LmFkZCh0b29sdGlwKSwgJ21vdXNlbW92ZScsIGZ1bmN0aW9uIChldmVudCkge1xcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHRvb2x0aXAgaGlkZXMgd2hlbiBtb3VzZSBpcyBtb3ZlZCBhIGNlcnRhaW4gZGlzdGFuY2VcXG4gICAgICAgIGlmICgnbnVtYmVyJyA9PT0gdHlwZW9mIG9wdGlvbnMuaGlkZS5kaXN0YW5jZSkge1xcbiAgICAgICAgICB2YXIgb3JpZ2luID0gdGhpcy5jYWNoZS5vcmlnaW4gfHwge30sXFxuICAgICAgICAgICAgICBsaW1pdCA9IHRoaXMub3B0aW9ucy5oaWRlLmRpc3RhbmNlLFxcbiAgICAgICAgICAgICAgYWJzID0gTWF0aC5hYnM7IC8vIENoZWNrIGlmIHRoZSBtb3ZlbWVudCBoYXMgZ29uZSBiZXlvbmQgdGhlIGxpbWl0LCBhbmQgaGlkZSBpdCBpZiBzb1xcblxcbiAgICAgICAgICBpZiAoYWJzKGV2ZW50LnBhZ2VYIC0gb3JpZ2luLnBhZ2VYKSA+PSBsaW1pdCB8fCBhYnMoZXZlbnQucGFnZVkgLSBvcmlnaW4ucGFnZVkpID49IGxpbWl0KSB7XFxuICAgICAgICAgICAgdGhpcy5oaWRlKGV2ZW50KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSAvLyBDYWNoZSBtb3VzZW1vdmUgY29vcmRzIG9uIHNob3cgdGFyZ2V0c1xcblxcblxcbiAgICAgICAgdGhpcy5fc3RvcmVNb3VzZShldmVudCk7XFxuICAgICAgfSk7IC8vIE1vdXNlIHBvc2l0aW9uaW5nIGV2ZW50c1xcblxcblxcbiAgICAgIGlmIChwb3NPcHRpb25zLnRhcmdldCA9PT0gJ21vdXNlJykge1xcbiAgICAgICAgLy8gSWYgbW91c2UgYWRqdXN0bWVudCBpcyBvbi4uLlxcbiAgICAgICAgaWYgKHBvc09wdGlvbnMuYWRqdXN0Lm1vdXNlKSB7XFxuICAgICAgICAgIC8vIEFwcGx5IGEgbW91c2VsZWF2ZSBldmVudCBzbyB3ZSBkb24ndCBnZXQgcHJvYmxlbXMgd2l0aCBvdmVybGFwcGluZ1xcbiAgICAgICAgICBpZiAob3B0aW9ucy5oaWRlLmV2ZW50KSB7XFxuICAgICAgICAgICAgLy8gVHJhY2sgaWYgd2UncmUgb24gdGhlIHRhcmdldCBvciBub3RcXG4gICAgICAgICAgICB0aGlzLl9iaW5kKHNob3dUYXJnZXQsIFsnbW91c2VlbnRlcicsICdtb3VzZWxlYXZlJ10sIGZ1bmN0aW9uIChldmVudCkge1xcbiAgICAgICAgICAgICAgaWYgKCF0aGlzLmNhY2hlKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiBGQUxTRTtcXG4gICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgIHRoaXMuY2FjaGUub25UYXJnZXQgPSBldmVudC50eXBlID09PSAnbW91c2VlbnRlcic7XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgIH0gLy8gVXBkYXRlIHRvb2x0aXAgcG9zaXRpb24gb24gbW91c2Vtb3ZlXFxuXFxuXFxuICAgICAgICAgIHRoaXMuX2JpbmQoZG9jdW1lbnRUYXJnZXQsICdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZXZlbnQpIHtcXG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHRvb2x0aXAgcG9zaXRpb24gb25seSBpZiB0aGUgdG9vbHRpcCBpcyB2aXNpYmxlIGFuZCBhZGp1c3RtZW50IGlzIGVuYWJsZWRcXG4gICAgICAgICAgICBpZiAodGhpcy5yZW5kZXJlZCAmJiB0aGlzLmNhY2hlLm9uVGFyZ2V0ICYmICF0aGlzLnRvb2x0aXAuaGFzQ2xhc3MoQ0xBU1NfRElTQUJMRUQpICYmIHRoaXMudG9vbHRpcFswXS5vZmZzZXRXaWR0aCA+IDApIHtcXG4gICAgICAgICAgICAgIHRoaXMucmVwb3NpdGlvbihldmVudCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9IC8vIEFkanVzdCBwb3NpdGlvbnMgb2YgdGhlIHRvb2x0aXAgb24gd2luZG93IHJlc2l6ZSBpZiBlbmFibGVkXFxuXFxuXFxuICAgICAgaWYgKHBvc09wdGlvbnMuYWRqdXN0LnJlc2l6ZSB8fCB2aWV3cG9ydFRhcmdldC5sZW5ndGgpIHtcXG4gICAgICAgIHRoaXMuX2JpbmQoJC5ldmVudC5zcGVjaWFsLnJlc2l6ZSA/IHZpZXdwb3J0VGFyZ2V0IDogd2luZG93VGFyZ2V0LCAncmVzaXplJywgcmVwb3NpdGlvbk1ldGhvZCk7XFxuICAgICAgfSAvLyBBZGp1c3QgdG9vbHRpcCBwb3NpdGlvbiBvbiBzY3JvbGwgb2YgdGhlIHdpbmRvdyBvciB2aWV3cG9ydCBlbGVtZW50IGlmIHByZXNlbnRcXG5cXG5cXG4gICAgICBpZiAocG9zT3B0aW9ucy5hZGp1c3Quc2Nyb2xsKSB7XFxuICAgICAgICB0aGlzLl9iaW5kKHdpbmRvd1RhcmdldC5hZGQocG9zT3B0aW9ucy5jb250YWluZXIpLCAnc2Nyb2xsJywgcmVwb3NpdGlvbk1ldGhvZCk7XFxuICAgICAgfVxcbiAgICB9OyAvLyBVbi1hc3NpZ25tZW50IG1ldGhvZFxcblxcblxcbiAgICBQUk9UT1RZUEUuX3VuYXNzaWduRXZlbnRzID0gZnVuY3Rpb24gKCkge1xcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxcbiAgICAgICAgICBzaG93VGFyZ2V0cyA9IG9wdGlvbnMuc2hvdy50YXJnZXQsXFxuICAgICAgICAgIGhpZGVUYXJnZXRzID0gb3B0aW9ucy5oaWRlLnRhcmdldCxcXG4gICAgICAgICAgdGFyZ2V0cyA9ICQuZ3JlcChbdGhpcy5lbGVtZW50cy50YXJnZXRbMF0sIHRoaXMucmVuZGVyZWQgJiYgdGhpcy50b29sdGlwWzBdLCBvcHRpb25zLnBvc2l0aW9uLmNvbnRhaW5lclswXSwgb3B0aW9ucy5wb3NpdGlvbi52aWV3cG9ydFswXSwgb3B0aW9ucy5wb3NpdGlvbi5jb250YWluZXIuY2xvc2VzdCgnaHRtbCcpWzBdLCAvLyB1bmZvY3VzXFxuICAgICAgd2luZG93LCBkb2N1bWVudF0sIGZ1bmN0aW9uIChpKSB7XFxuICAgICAgICByZXR1cm4gX3R5cGVvZihpKSA9PT0gJ29iamVjdCc7XFxuICAgICAgfSk7IC8vIEFkZCBzaG93IGFuZCBoaWRlIHRhcmdldHMgaWYgdGhleSdyZSB2YWxpZFxcblxcbiAgICAgIGlmIChzaG93VGFyZ2V0cyAmJiBzaG93VGFyZ2V0cy50b0FycmF5KSB7XFxuICAgICAgICB0YXJnZXRzID0gdGFyZ2V0cy5jb25jYXQoc2hvd1RhcmdldHMudG9BcnJheSgpKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGhpZGVUYXJnZXRzICYmIGhpZGVUYXJnZXRzLnRvQXJyYXkpIHtcXG4gICAgICAgIHRhcmdldHMgPSB0YXJnZXRzLmNvbmNhdChoaWRlVGFyZ2V0cy50b0FycmF5KCkpO1xcbiAgICAgIH0gLy8gVW5iaW5kIHRoZSBldmVudHNcXG5cXG5cXG4gICAgICB0aGlzLl91bmJpbmQodGFyZ2V0cykuX3VuYmluZCh0YXJnZXRzLCAnZGVzdHJveScpLl91bmJpbmQodGFyZ2V0cywgJ2luYWN0aXZlJyk7XFxuICAgIH07IC8vIEFwcGx5IGNvbW1vbiBldmVudCBoYW5kbGVycyB1c2luZyBkZWxlZ2F0ZSAoYXZvaWRzIGV4Y2Vzc2l2ZSAuYmluZCBjYWxscyEpXFxuXFxuXFxuICAgICQoZnVuY3Rpb24gKCkge1xcbiAgICAgIGRlbGVnYXRlKFNFTEVDVE9SLCBbJ21vdXNlZW50ZXInLCAnbW91c2VsZWF2ZSddLCBmdW5jdGlvbiAoZXZlbnQpIHtcXG4gICAgICAgIHZhciBzdGF0ZSA9IGV2ZW50LnR5cGUgPT09ICdtb3VzZWVudGVyJyxcXG4gICAgICAgICAgICB0b29sdGlwID0gJChldmVudC5jdXJyZW50VGFyZ2V0KSxcXG4gICAgICAgICAgICB0YXJnZXQgPSAkKGV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgZXZlbnQudGFyZ2V0KSxcXG4gICAgICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zOyAvLyBPbiBtb3VzZWVudGVyLi4uXFxuXFxuICAgICAgICBpZiAoc3RhdGUpIHtcXG4gICAgICAgICAgLy8gRm9jdXMgdGhlIHRvb2x0aXAgb24gbW91c2VlbnRlciAoei1pbmRleCBzdGFja2luZylcXG4gICAgICAgICAgdGhpcy5mb2N1cyhldmVudCk7IC8vIENsZWFyIGhpZGUgdGltZXIgb24gdG9vbHRpcCBob3ZlciB0byBwcmV2ZW50IGl0IGZyb20gY2xvc2luZ1xcblxcbiAgICAgICAgICB0b29sdGlwLmhhc0NsYXNzKENMQVNTX0ZJWEVEKSAmJiAhdG9vbHRpcC5oYXNDbGFzcyhDTEFTU19ESVNBQkxFRCkgJiYgY2xlYXJUaW1lb3V0KHRoaXMudGltZXJzLmhpZGUpO1xcbiAgICAgICAgfSAvLyBPbiBtb3VzZWxlYXZlLi4uXFxuICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAvLyBXaGVuIG1vdXNlIHRyYWNraW5nIGlzIGVuYWJsZWQsIGhpZGUgd2hlbiB3ZSBsZWF2ZSB0aGUgdG9vbHRpcCBhbmQgbm90IG9udG8gdGhlIHNob3cgdGFyZ2V0IChpZiBhIGhpZGUgZXZlbnQgaXMgc2V0KVxcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnBvc2l0aW9uLnRhcmdldCA9PT0gJ21vdXNlJyAmJiBvcHRpb25zLnBvc2l0aW9uLmFkanVzdC5tb3VzZSAmJiBvcHRpb25zLmhpZGUuZXZlbnQgJiYgb3B0aW9ucy5zaG93LnRhcmdldCAmJiAhdGFyZ2V0LmNsb3Nlc3Qob3B0aW9ucy5zaG93LnRhcmdldFswXSkubGVuZ3RoKSB7XFxuICAgICAgICAgICAgICB0aGlzLmhpZGUoZXZlbnQpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSAvLyBBZGQgaG92ZXIgY2xhc3NcXG5cXG5cXG4gICAgICAgIHRvb2x0aXAudG9nZ2xlQ2xhc3MoQ0xBU1NfSE9WRVIsIHN0YXRlKTtcXG4gICAgICB9KTsgLy8gRGVmaW5lIGV2ZW50cyB3aGljaCByZXNldCB0aGUgJ2luYWN0aXZlJyBldmVudCBoYW5kbGVyXFxuXFxuICAgICAgZGVsZWdhdGUoJ1snICsgQVRUUl9JRCArICddJywgSU5BQ1RJVkVfRVZFTlRTLCBpbmFjdGl2ZU1ldGhvZCk7XFxuICAgIH0pO1xcbiAgICA7IC8vIEluaXRpYWxpemF0aW9uIG1ldGhvZFxcblxcbiAgICBmdW5jdGlvbiBpbml0KGVsZW0sIGlkLCBvcHRzKSB7XFxuICAgICAgdmFyIG9iaixcXG4gICAgICAgICAgcG9zT3B0aW9ucyxcXG4gICAgICAgICAgYXR0cixcXG4gICAgICAgICAgY29uZmlnLFxcbiAgICAgICAgICB0aXRsZSxcXG4gICAgICAgICAgLy8gU2V0dXAgZWxlbWVudCByZWZlcmVuY2VzXFxuICAgICAgZG9jQm9keSA9ICQoZG9jdW1lbnQuYm9keSksXFxuICAgICAgICAgIC8vIFVzZSBkb2N1bWVudCBib2R5IGluc3RlYWQgb2YgZG9jdW1lbnQgZWxlbWVudCBpZiBuZWVkZWRcXG4gICAgICBuZXdUYXJnZXQgPSBlbGVtWzBdID09PSBkb2N1bWVudCA/IGRvY0JvZHkgOiBlbGVtLFxcbiAgICAgICAgICAvLyBHcmFiIG1ldGFkYXRhIGZyb20gZWxlbWVudCBpZiBwbHVnaW4gaXMgcHJlc2VudFxcbiAgICAgIG1ldGFkYXRhID0gZWxlbS5tZXRhZGF0YSA/IGVsZW0ubWV0YWRhdGEob3B0cy5tZXRhZGF0YSkgOiBOVUxMLFxcbiAgICAgICAgICAvLyBJZiBtZXRhZGF0YSB0eXBlIGlmIEhUTUw1LCBncmFiICduYW1lJyBmcm9tIHRoZSBvYmplY3QgaW5zdGVhZCwgb3IgdXNlIHRoZSByZWd1bGFyIGRhdGEgb2JqZWN0IG90aGVyd2lzZVxcbiAgICAgIG1ldGFkYXRhNSA9IG9wdHMubWV0YWRhdGEudHlwZSA9PT0gJ2h0bWw1JyAmJiBtZXRhZGF0YSA/IG1ldGFkYXRhW29wdHMubWV0YWRhdGEubmFtZV0gOiBOVUxMLFxcbiAgICAgICAgICAvLyBHcmFiIGRhdGEgZnJvbSBtZXRhZGF0YS5uYW1lIChvciBkYXRhLXF0aXBvcHRzIGFzIGZhbGxiYWNrKSB1c2luZyAuZGF0YSgpIG1ldGhvZCxcXG4gICAgICBodG1sNSA9IGVsZW0uZGF0YShvcHRzLm1ldGFkYXRhLm5hbWUgfHwgJ3F0aXBvcHRzJyk7IC8vIElmIHdlIGRvbid0IGdldCBhbiBvYmplY3QgcmV0dXJuZWQgYXR0ZW1wdCB0byBwYXJzZSBpdCBtYW51YWx5bCB3aXRob3V0IHBhcnNlSlNPTlxcblxcbiAgICAgIHRyeSB7XFxuICAgICAgICBodG1sNSA9IHR5cGVvZiBodG1sNSA9PT0gJ3N0cmluZycgPyAkLnBhcnNlSlNPTihodG1sNSkgOiBodG1sNTtcXG4gICAgICB9IGNhdGNoIChlKSB7fSAvLyBNZXJnZSBpbiBhbmQgc2FuaXRpemUgbWV0YWRhdGFcXG5cXG5cXG4gICAgICBjb25maWcgPSAkLmV4dGVuZChUUlVFLCB7fSwgUVRJUC5kZWZhdWx0cywgb3B0cywgX3R5cGVvZihodG1sNSkgPT09ICdvYmplY3QnID8gc2FuaXRpemVPcHRpb25zKGh0bWw1KSA6IE5VTEwsIHNhbml0aXplT3B0aW9ucyhtZXRhZGF0YTUgfHwgbWV0YWRhdGEpKTsgLy8gUmUtZ3JhYiBvdXIgcG9zaXRpb25pbmcgb3B0aW9ucyBub3cgd2UndmUgbWVyZ2VkIG91ciBtZXRhZGF0YSBhbmQgc2V0IGlkIHRvIHBhc3NlZCB2YWx1ZVxcblxcbiAgICAgIHBvc09wdGlvbnMgPSBjb25maWcucG9zaXRpb247XFxuICAgICAgY29uZmlnLmlkID0gaWQ7IC8vIFNldHVwIG1pc3NpbmcgY29udGVudCBpZiBub25lIGlzIGRldGVjdGVkXFxuXFxuICAgICAgaWYgKCdib29sZWFuJyA9PT0gdHlwZW9mIGNvbmZpZy5jb250ZW50LnRleHQpIHtcXG4gICAgICAgIGF0dHIgPSBlbGVtLmF0dHIoY29uZmlnLmNvbnRlbnQuYXR0cik7IC8vIEdyYWIgZnJvbSBzdXBwbGllZCBhdHRyaWJ1dGUgaWYgYXZhaWxhYmxlXFxuXFxuICAgICAgICBpZiAoY29uZmlnLmNvbnRlbnQuYXR0ciAhPT0gRkFMU0UgJiYgYXR0cikge1xcbiAgICAgICAgICBjb25maWcuY29udGVudC50ZXh0ID0gYXR0cjtcXG4gICAgICAgIH0gLy8gTm8gdmFsaWQgY29udGVudCB3YXMgZm91bmQsIGFib3J0IHJlbmRlclxcbiAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgcmV0dXJuIEZBTFNFO1xcbiAgICAgICAgICB9XFxuICAgICAgfSAvLyBTZXR1cCB0YXJnZXQgb3B0aW9uc1xcblxcblxcbiAgICAgIGlmICghcG9zT3B0aW9ucy5jb250YWluZXIubGVuZ3RoKSB7XFxuICAgICAgICBwb3NPcHRpb25zLmNvbnRhaW5lciA9IGRvY0JvZHk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChwb3NPcHRpb25zLnRhcmdldCA9PT0gRkFMU0UpIHtcXG4gICAgICAgIHBvc09wdGlvbnMudGFyZ2V0ID0gbmV3VGFyZ2V0O1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoY29uZmlnLnNob3cudGFyZ2V0ID09PSBGQUxTRSkge1xcbiAgICAgICAgY29uZmlnLnNob3cudGFyZ2V0ID0gbmV3VGFyZ2V0O1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoY29uZmlnLnNob3cuc29sbyA9PT0gVFJVRSkge1xcbiAgICAgICAgY29uZmlnLnNob3cuc29sbyA9IHBvc09wdGlvbnMuY29udGFpbmVyLmNsb3Nlc3QoJ2JvZHknKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGNvbmZpZy5oaWRlLnRhcmdldCA9PT0gRkFMU0UpIHtcXG4gICAgICAgIGNvbmZpZy5oaWRlLnRhcmdldCA9IG5ld1RhcmdldDtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGNvbmZpZy5wb3NpdGlvbi52aWV3cG9ydCA9PT0gVFJVRSkge1xcbiAgICAgICAgY29uZmlnLnBvc2l0aW9uLnZpZXdwb3J0ID0gcG9zT3B0aW9ucy5jb250YWluZXI7XFxuICAgICAgfSAvLyBFbnN1cmUgd2Ugb25seSB1c2UgYSBzaW5nbGUgY29udGFpbmVyXFxuXFxuXFxuICAgICAgcG9zT3B0aW9ucy5jb250YWluZXIgPSBwb3NPcHRpb25zLmNvbnRhaW5lci5lcSgwKTsgLy8gQ29udmVydCBwb3NpdGlvbiBjb3JuZXIgdmFsdWVzIGludG8geCBhbmQgeSBzdHJpbmdzXFxuXFxuICAgICAgcG9zT3B0aW9ucy5hdCA9IG5ldyBDT1JORVIocG9zT3B0aW9ucy5hdCwgVFJVRSk7XFxuICAgICAgcG9zT3B0aW9ucy5teSA9IG5ldyBDT1JORVIocG9zT3B0aW9ucy5teSk7IC8vIERlc3Ryb3kgcHJldmlvdXMgdG9vbHRpcCBpZiBvdmVyd3JpdGUgaXMgZW5hYmxlZCwgb3Igc2tpcCBlbGVtZW50IGlmIG5vdFxcblxcbiAgICAgIGlmIChlbGVtLmRhdGEoTkFNRVNQQUNFKSkge1xcbiAgICAgICAgaWYgKGNvbmZpZy5vdmVyd3JpdGUpIHtcXG4gICAgICAgICAgZWxlbS5xdGlwKCdkZXN0cm95JywgdHJ1ZSk7XFxuICAgICAgICB9IGVsc2UgaWYgKGNvbmZpZy5vdmVyd3JpdGUgPT09IEZBTFNFKSB7XFxuICAgICAgICAgIHJldHVybiBGQUxTRTtcXG4gICAgICAgIH1cXG4gICAgICB9IC8vIEFkZCBoYXMtcXRpcCBhdHRyaWJ1dGVcXG5cXG5cXG4gICAgICBlbGVtLmF0dHIoQVRUUl9IQVMsIGlkKTsgLy8gUmVtb3ZlIHRpdGxlIGF0dHJpYnV0ZSBhbmQgc3RvcmUgaXQgaWYgcHJlc2VudFxcblxcbiAgICAgIGlmIChjb25maWcuc3VwcHJlc3MgJiYgKHRpdGxlID0gZWxlbS5hdHRyKCd0aXRsZScpKSkge1xcbiAgICAgICAgLy8gRmluYWwgYXR0ciBjYWxsIGZpeGVzIGV2ZW50IGRlbGVnYXRpb20gYW5kIElFIGRlZmF1bHQgdG9vbHRpcCBzaG93aW5nIHByb2JsZW1cXG4gICAgICAgIGVsZW0ucmVtb3ZlQXR0cigndGl0bGUnKS5hdHRyKG9sZHRpdGxlLCB0aXRsZSkuYXR0cigndGl0bGUnLCAnJyk7XFxuICAgICAgfSAvLyBJbml0aWFsaXplIHRoZSB0b29sdGlwIGFuZCBhZGQgQVBJIHJlZmVyZW5jZVxcblxcblxcbiAgICAgIG9iaiA9IG5ldyBRVGlwKGVsZW0sIGNvbmZpZywgaWQsICEhYXR0cik7XFxuICAgICAgZWxlbS5kYXRhKE5BTUVTUEFDRSwgb2JqKTtcXG4gICAgICByZXR1cm4gb2JqO1xcbiAgICB9IC8vIGpRdWVyeSAkLmZuIGV4dGVuc2lvbiBtZXRob2RcXG5cXG5cXG4gICAgUVRJUCA9ICQuZm4ucXRpcCA9IGZ1bmN0aW9uIChvcHRpb25zLCBub3RhdGlvbiwgbmV3VmFsdWUpIHtcXG4gICAgICB2YXIgY29tbWFuZCA9ICgnJyArIG9wdGlvbnMpLnRvTG93ZXJDYXNlKCksXFxuICAgICAgICAgIC8vIFBhcnNlIGNvbW1hbmRcXG4gICAgICByZXR1cm5lZCA9IE5VTEwsXFxuICAgICAgICAgIGFyZ3MgPSAkLm1ha2VBcnJheShhcmd1bWVudHMpLnNsaWNlKDEpLFxcbiAgICAgICAgICBldmVudCA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXSxcXG4gICAgICAgICAgb3B0cyA9IHRoaXNbMF0gPyAkLmRhdGEodGhpc1swXSwgTkFNRVNQQUNFKSA6IE5VTEw7IC8vIENoZWNrIGZvciBBUEkgcmVxdWVzdFxcblxcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCAmJiBvcHRzIHx8IGNvbW1hbmQgPT09ICdhcGknKSB7XFxuICAgICAgICByZXR1cm4gb3B0cztcXG4gICAgICB9IC8vIEV4ZWN1dGUgQVBJIGNvbW1hbmQgaWYgcHJlc2VudFxcbiAgICAgIGVsc2UgaWYgKCdzdHJpbmcnID09PSB0eXBlb2Ygb3B0aW9ucykge1xcbiAgICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIHZhciBhcGkgPSAkLmRhdGEodGhpcywgTkFNRVNQQUNFKTtcXG5cXG4gICAgICAgICAgICBpZiAoIWFwaSkge1xcbiAgICAgICAgICAgICAgcmV0dXJuIFRSVUU7XFxuICAgICAgICAgICAgfSAvLyBDYWNoZSB0aGUgZXZlbnQgaWYgcG9zc2libGVcXG5cXG5cXG4gICAgICAgICAgICBpZiAoZXZlbnQgJiYgZXZlbnQudGltZVN0YW1wKSB7XFxuICAgICAgICAgICAgICBhcGkuY2FjaGUuZXZlbnQgPSBldmVudDtcXG4gICAgICAgICAgICB9IC8vIENoZWNrIGZvciBzcGVjaWZpYyBBUEkgY29tbWFuZHNcXG5cXG5cXG4gICAgICAgICAgICBpZiAobm90YXRpb24gJiYgKGNvbW1hbmQgPT09ICdvcHRpb24nIHx8IGNvbW1hbmQgPT09ICdvcHRpb25zJykpIHtcXG4gICAgICAgICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gdW5kZWZpbmVkIHx8ICQuaXNQbGFpbk9iamVjdChub3RhdGlvbikpIHtcXG4gICAgICAgICAgICAgICAgYXBpLnNldChub3RhdGlvbiwgbmV3VmFsdWUpO1xcbiAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuZWQgPSBhcGkuZ2V0KG5vdGF0aW9uKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIEZBTFNFO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0gLy8gRXhlY3V0ZSBBUEkgY29tbWFuZFxcbiAgICAgICAgICAgIGVsc2UgaWYgKGFwaVtjb21tYW5kXSkge1xcbiAgICAgICAgICAgICAgICBhcGlbY29tbWFuZF0uYXBwbHkoYXBpLCBhcmdzKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSk7XFxuICAgICAgICAgIHJldHVybiByZXR1cm5lZCAhPT0gTlVMTCA/IHJldHVybmVkIDogdGhpcztcXG4gICAgICAgIH0gLy8gTm8gQVBJIGNvbW1hbmRzLiB2YWxpZGF0ZSBwcm92aWRlZCBvcHRpb25zIGFuZCBzZXR1cCBxVGlwc1xcbiAgICAgICAgZWxzZSBpZiAoJ29iamVjdCcgPT09IF90eXBlb2Yob3B0aW9ucykgfHwgIWFyZ3VtZW50cy5sZW5ndGgpIHtcXG4gICAgICAgICAgICAvLyBTYW5pdGl6ZSBvcHRpb25zIGZpcnN0XFxuICAgICAgICAgICAgb3B0cyA9IHNhbml0aXplT3B0aW9ucygkLmV4dGVuZChUUlVFLCB7fSwgb3B0aW9ucykpO1xcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKGkpIHtcXG4gICAgICAgICAgICAgIHZhciBhcGksIGlkOyAvLyBGaW5kIG5leHQgYXZhaWxhYmxlIElELCBvciB1c2UgY3VzdG9tIElEIGlmIHByb3ZpZGVkXFxuXFxuICAgICAgICAgICAgICBpZCA9ICQuaXNBcnJheShvcHRzLmlkKSA/IG9wdHMuaWRbaV0gOiBvcHRzLmlkO1xcbiAgICAgICAgICAgICAgaWQgPSAhaWQgfHwgaWQgPT09IEZBTFNFIHx8IGlkLmxlbmd0aCA8IDEgfHwgUVRJUC5hcGlbaWRdID8gUVRJUC5uZXh0aWQrKyA6IGlkOyAvLyBJbml0aWFsaXplIHRoZSBxVGlwIGFuZCByZS1ncmFiIG5ld2x5IHNhbml0aXplZCBvcHRpb25zXFxuXFxuICAgICAgICAgICAgICBhcGkgPSBpbml0KCQodGhpcyksIGlkLCBvcHRzKTtcXG5cXG4gICAgICAgICAgICAgIGlmIChhcGkgPT09IEZBTFNFKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiBUUlVFO1xcbiAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgUVRJUC5hcGlbaWRdID0gYXBpO1xcbiAgICAgICAgICAgICAgfSAvLyBJbml0aWFsaXplIHBsdWdpbnNcXG5cXG5cXG4gICAgICAgICAgICAgICQuZWFjaChQTFVHSU5TLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmluaXRpYWxpemUgPT09ICdpbml0aWFsaXplJykge1xcbiAgICAgICAgICAgICAgICAgIHRoaXMoYXBpKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgfSk7IC8vIEFzc2lnbiBpbml0aWFsIHByZS1yZW5kZXIgZXZlbnRzXFxuXFxuICAgICAgICAgICAgICBhcGkuX2Fzc2lnbkluaXRpYWxFdmVudHMoZXZlbnQpO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICB9XFxuICAgIH07IC8vIEV4cG9zZSBjbGFzc1xcblxcblxcbiAgICAkLnF0aXAgPSBRVGlwOyAvLyBQb3B1bGF0ZWQgaW4gcmVuZGVyIG1ldGhvZFxcblxcbiAgICBRVElQLmFwaSA9IHt9O1xcbiAgICA7XFxuICAgICQuZWFjaCh7XFxuICAgICAgLyogQWxsb3cgb3RoZXIgcGx1Z2lucyB0byBzdWNjZXNzZnVsbHkgcmV0cmlldmUgdGhlIHRpdGxlIG9mIGFuIGVsZW1lbnQgd2l0aCBhIHFUaXAgYXBwbGllZCAqL1xcbiAgICAgIGF0dHI6IGZ1bmN0aW9uIGF0dHIoX2F0dHIsIHZhbCkge1xcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoKSB7XFxuICAgICAgICAgIHZhciBzZWxmID0gdGhpc1swXSxcXG4gICAgICAgICAgICAgIHRpdGxlID0gJ3RpdGxlJyxcXG4gICAgICAgICAgICAgIGFwaSA9ICQuZGF0YShzZWxmLCAncXRpcCcpO1xcblxcbiAgICAgICAgICBpZiAoX2F0dHIgPT09IHRpdGxlICYmIGFwaSAmJiAnb2JqZWN0JyA9PT0gX3R5cGVvZihhcGkpICYmIGFwaS5vcHRpb25zLnN1cHByZXNzKSB7XFxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XFxuICAgICAgICAgICAgICByZXR1cm4gJC5hdHRyKHNlbGYsIG9sZHRpdGxlKTtcXG4gICAgICAgICAgICB9IC8vIElmIHFUaXAgaXMgcmVuZGVyZWQgYW5kIHRpdGxlIHdhcyBvcmlnaW5hbGx5IHVzZWQgYXMgY29udGVudCwgdXBkYXRlIGl0XFxuXFxuXFxuICAgICAgICAgICAgaWYgKGFwaSAmJiBhcGkub3B0aW9ucy5jb250ZW50LmF0dHIgPT09IHRpdGxlICYmIGFwaS5jYWNoZS5hdHRyKSB7XFxuICAgICAgICAgICAgICBhcGkuc2V0KCdjb250ZW50LnRleHQnLCB2YWwpO1xcbiAgICAgICAgICAgIH0gLy8gVXNlIHRoZSByZWd1bGFyIGF0dHIgbWV0aG9kIHRvIHNldCwgdGhlbiBjYWNoZSB0aGUgcmVzdWx0XFxuXFxuXFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXR0cihvbGR0aXRsZSwgdmFsKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuICQuZm5bJ2F0dHInICsgcmVwbGFjZVN1ZmZpeF0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gICAgICB9LFxcblxcbiAgICAgIC8qIEFsbG93IGNsb25lIHRvIGNvcnJlY3RseSByZXRyaWV2ZSBjYWNoZWQgdGl0bGUgYXR0cmlidXRlcyAqL1xcbiAgICAgIGNsb25lOiBmdW5jdGlvbiBjbG9uZShrZWVwRGF0YSkge1xcbiAgICAgICAgdmFyIHRpdGxlcyA9ICQoW10pLFxcbiAgICAgICAgICAgIHRpdGxlID0gJ3RpdGxlJyxcXG4gICAgICAgICAgICAvLyBDbG9uZSBvdXIgZWxlbWVudCB1c2luZyB0aGUgcmVhbCBjbG9uZSBtZXRob2RcXG4gICAgICAgIGVsZW1zID0gJC5mblsnY2xvbmUnICsgcmVwbGFjZVN1ZmZpeF0uYXBwbHkodGhpcywgYXJndW1lbnRzKTsgLy8gR3JhYiBhbGwgZWxlbWVudHMgd2l0aCBhbiBvbGR0aXRsZSBzZXQsIGFuZCBjaGFuZ2UgaXQgdG8gcmVndWxhciB0aXRsZSBhdHRyaWJ1dGUsIGlmIGtlZXBEYXRhIGlzIGZhbHNlXFxuXFxuICAgICAgICBpZiAoIWtlZXBEYXRhKSB7XFxuICAgICAgICAgIGVsZW1zLmZpbHRlcignWycgKyBvbGR0aXRsZSArICddJykuYXR0cigndGl0bGUnLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgcmV0dXJuICQuYXR0cih0aGlzLCBvbGR0aXRsZSk7XFxuICAgICAgICAgIH0pLnJlbW92ZUF0dHIob2xkdGl0bGUpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIGVsZW1zO1xcbiAgICAgIH1cXG4gICAgfSwgZnVuY3Rpb24gKG5hbWUsIGZ1bmMpIHtcXG4gICAgICBpZiAoIWZ1bmMgfHwgJC5mbltuYW1lICsgcmVwbGFjZVN1ZmZpeF0pIHtcXG4gICAgICAgIHJldHVybiBUUlVFO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgb2xkID0gJC5mbltuYW1lICsgcmVwbGFjZVN1ZmZpeF0gPSAkLmZuW25hbWVdO1xcblxcbiAgICAgICQuZm5bbmFtZV0gPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IG9sZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgICAgIH07XFxuICAgIH0pO1xcbiAgICAvKiBGaXJlIG9mZiAncmVtb3ZlcXRpcCcgaGFuZGxlciBpbiAkLmNsZWFuRGF0YSBpZiBqUXVlcnkgVUkgbm90IHByZXNlbnQgKGl0IGFscmVhZHkgZG9lcyBzaW1pbGFyKS5cXG4gICAgICogVGhpcyBzbmlwcGV0IGlzIHRha2VuIGRpcmVjdGx5IGZyb20galF1ZXJ5IFVJIHNvdXJjZSBjb2RlIGZvdW5kIGhlcmU6XFxuICAgICAqICAgICBodHRwOi8vY29kZS5qcXVlcnkuY29tL3VpL2pxdWVyeS11aS1naXQuanNcXG4gICAgICovXFxuXFxuICAgIGlmICghJC51aSkge1xcbiAgICAgICRbJ2NsZWFuRGF0YScgKyByZXBsYWNlU3VmZml4XSA9ICQuY2xlYW5EYXRhO1xcblxcbiAgICAgICQuY2xlYW5EYXRhID0gZnVuY3Rpb24gKGVsZW1zKSB7XFxuICAgICAgICBmb3IgKHZhciBpID0gMCwgZWxlbTsgKGVsZW0gPSAkKGVsZW1zW2ldKSkubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgaWYgKGVsZW0uYXR0cihBVFRSX0hBUykpIHtcXG4gICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgZWxlbS50cmlnZ2VySGFuZGxlcigncmVtb3ZlcXRpcCcpO1xcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgICRbJ2NsZWFuRGF0YScgKyByZXBsYWNlU3VmZml4XS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgICAgIH07XFxuICAgIH1cXG5cXG4gICAgOyAvLyBxVGlwIHZlcnNpb25cXG5cXG4gICAgUVRJUC52ZXJzaW9uID0gJzIuMi4xLTI5LSc7IC8vIEJhc2UgSUQgZm9yIGFsbCBxVGlwc1xcblxcbiAgICBRVElQLm5leHRpZCA9IDA7IC8vIEluYWN0aXZlIGV2ZW50cyBhcnJheVxcblxcbiAgICBRVElQLmluYWN0aXZlRXZlbnRzID0gSU5BQ1RJVkVfRVZFTlRTOyAvLyBCYXNlIHotaW5kZXggZm9yIGFsbCBxVGlwc1xcblxcbiAgICBRVElQLnppbmRleCA9IDE1MDAwOyAvLyBEZWZpbmUgY29uZmlndXJhdGlvbiBkZWZhdWx0c1xcblxcbiAgICBRVElQLmRlZmF1bHRzID0ge1xcbiAgICAgIHByZXJlbmRlcjogRkFMU0UsXFxuICAgICAgaWQ6IEZBTFNFLFxcbiAgICAgIG92ZXJ3cml0ZTogVFJVRSxcXG4gICAgICBzdXBwcmVzczogVFJVRSxcXG4gICAgICBjb250ZW50OiB7XFxuICAgICAgICB0ZXh0OiBUUlVFLFxcbiAgICAgICAgYXR0cjogJ3RpdGxlJyxcXG4gICAgICAgIHRpdGxlOiBGQUxTRSxcXG4gICAgICAgIGJ1dHRvbjogRkFMU0VcXG4gICAgICB9LFxcbiAgICAgIHBvc2l0aW9uOiB7XFxuICAgICAgICBteTogJ3RvcCBsZWZ0JyxcXG4gICAgICAgIGF0OiAnYm90dG9tIHJpZ2h0JyxcXG4gICAgICAgIHRhcmdldDogRkFMU0UsXFxuICAgICAgICBjb250YWluZXI6IEZBTFNFLFxcbiAgICAgICAgdmlld3BvcnQ6IEZBTFNFLFxcbiAgICAgICAgYWRqdXN0OiB7XFxuICAgICAgICAgIHg6IDAsXFxuICAgICAgICAgIHk6IDAsXFxuICAgICAgICAgIG1vdXNlOiBUUlVFLFxcbiAgICAgICAgICBzY3JvbGw6IFRSVUUsXFxuICAgICAgICAgIHJlc2l6ZTogVFJVRSxcXG4gICAgICAgICAgbWV0aG9kOiAnZmxpcGludmVydCBmbGlwaW52ZXJ0J1xcbiAgICAgICAgfSxcXG4gICAgICAgIGVmZmVjdDogZnVuY3Rpb24gZWZmZWN0KGFwaSwgcG9zLCB2aWV3cG9ydCkge1xcbiAgICAgICAgICAkKHRoaXMpLmFuaW1hdGUocG9zLCB7XFxuICAgICAgICAgICAgZHVyYXRpb246IDIwMCxcXG4gICAgICAgICAgICBxdWV1ZTogRkFMU0VcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgfSxcXG4gICAgICBzaG93OiB7XFxuICAgICAgICB0YXJnZXQ6IEZBTFNFLFxcbiAgICAgICAgZXZlbnQ6ICdtb3VzZWVudGVyJyxcXG4gICAgICAgIGVmZmVjdDogVFJVRSxcXG4gICAgICAgIGRlbGF5OiA5MCxcXG4gICAgICAgIHNvbG86IEZBTFNFLFxcbiAgICAgICAgcmVhZHk6IEZBTFNFLFxcbiAgICAgICAgYXV0b2ZvY3VzOiBGQUxTRVxcbiAgICAgIH0sXFxuICAgICAgaGlkZToge1xcbiAgICAgICAgdGFyZ2V0OiBGQUxTRSxcXG4gICAgICAgIGV2ZW50OiAnbW91c2VsZWF2ZScsXFxuICAgICAgICBlZmZlY3Q6IFRSVUUsXFxuICAgICAgICBkZWxheTogMCxcXG4gICAgICAgIGZpeGVkOiBGQUxTRSxcXG4gICAgICAgIGluYWN0aXZlOiBGQUxTRSxcXG4gICAgICAgIGxlYXZlOiAnd2luZG93JyxcXG4gICAgICAgIGRpc3RhbmNlOiBGQUxTRVxcbiAgICAgIH0sXFxuICAgICAgc3R5bGU6IHtcXG4gICAgICAgIGNsYXNzZXM6ICcnLFxcbiAgICAgICAgd2lkZ2V0OiBGQUxTRSxcXG4gICAgICAgIHdpZHRoOiBGQUxTRSxcXG4gICAgICAgIGhlaWdodDogRkFMU0UsXFxuICAgICAgICBkZWY6IFRSVUVcXG4gICAgICB9LFxcbiAgICAgIGV2ZW50czoge1xcbiAgICAgICAgcmVuZGVyOiBOVUxMLFxcbiAgICAgICAgbW92ZTogTlVMTCxcXG4gICAgICAgIHNob3c6IE5VTEwsXFxuICAgICAgICBoaWRlOiBOVUxMLFxcbiAgICAgICAgdG9nZ2xlOiBOVUxMLFxcbiAgICAgICAgdmlzaWJsZTogTlVMTCxcXG4gICAgICAgIGhpZGRlbjogTlVMTCxcXG4gICAgICAgIGZvY3VzOiBOVUxMLFxcbiAgICAgICAgYmx1cjogTlVMTFxcbiAgICAgIH1cXG4gICAgfTtcXG4gICAgO1xcbiAgICB2YXIgVElQLFxcbiAgICAgICAgLy8gLmJpbmQoKS8ub24oKSBuYW1lc3BhY2VcXG4gICAgVElQTlMgPSAnLnF0aXAtdGlwJyxcXG4gICAgICAgIC8vIENvbW1vbiBDU1Mgc3RyaW5nc1xcbiAgICBNQVJHSU4gPSAnbWFyZ2luJyxcXG4gICAgICAgIEJPUkRFUiA9ICdib3JkZXInLFxcbiAgICAgICAgQ09MT1IgPSAnY29sb3InLFxcbiAgICAgICAgQkdfQ09MT1IgPSAnYmFja2dyb3VuZC1jb2xvcicsXFxuICAgICAgICBUUkFOU1BBUkVOVCA9ICd0cmFuc3BhcmVudCcsXFxuICAgICAgICBJTVBPUlRBTlQgPSAnICFpbXBvcnRhbnQnLFxcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgPGNhbnZhcy8+IGVsZW1lbnRzXFxuICAgIEhBU0NBTlZBUyA9ICEhZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykuZ2V0Q29udGV4dCxcXG4gICAgICAgIC8vIEludmFsaWQgY29sb3VyIHZhbHVlcyB1c2VkIGluIHBhcnNlQ29sb3VycygpXFxuICAgIElOVkFMSUQgPSAvcmdiYT9cXFxcKDAsIDAsIDAoLCAwKT9cXFxcKXx0cmFuc3BhcmVudHwjMTIzNDU2L2k7IC8vIENhbWVsLWNhc2UgbWV0aG9kLCB0YWtlbiBmcm9tIGpRdWVyeSBzb3VyY2VcXG4gICAgLy8gaHR0cDovL2NvZGUuanF1ZXJ5LmNvbS9qcXVlcnktMS44LjAuanNcXG5cXG4gICAgZnVuY3Rpb24gY2FtZWwocykge1xcbiAgICAgIHJldHVybiBzLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcy5zbGljZSgxKTtcXG4gICAgfVxcbiAgICAvKlxcbiAgICAgKiBNb2RpZmllZCBmcm9tIE1vZGVybml6cidzIHRlc3RQcm9wc0FsbCgpXFxuICAgICAqIGh0dHA6Ly9tb2Rlcm5penIuY29tL2Rvd25sb2Fkcy9tb2Rlcm5penItbGF0ZXN0LmpzXFxuICAgICAqL1xcblxcblxcbiAgICB2YXIgY3NzUHJvcHMgPSB7fSxcXG4gICAgICAgIGNzc1ByZWZpeGVzID0gW1xcXCJXZWJraXRcXFwiLCBcXFwiT1xcXCIsIFxcXCJNb3pcXFwiLCBcXFwibXNcXFwiXTtcXG5cXG4gICAgZnVuY3Rpb24gdmVuZG9yQ3NzKGVsZW0sIHByb3ApIHtcXG4gICAgICB2YXIgdWNQcm9wID0gcHJvcC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3Auc2xpY2UoMSksXFxuICAgICAgICAgIHByb3BzID0gKHByb3AgKyAnICcgKyBjc3NQcmVmaXhlcy5qb2luKHVjUHJvcCArICcgJykgKyB1Y1Byb3ApLnNwbGl0KCcgJyksXFxuICAgICAgICAgIGN1cixcXG4gICAgICAgICAgdmFsLFxcbiAgICAgICAgICBpID0gMDsgLy8gSWYgdGhlIHByb3BlcnR5IGhhcyBhbHJlYWR5IGJlZW4gbWFwcGVkLi4uXFxuXFxuICAgICAgaWYgKGNzc1Byb3BzW3Byb3BdKSB7XFxuICAgICAgICByZXR1cm4gZWxlbS5jc3MoY3NzUHJvcHNbcHJvcF0pO1xcbiAgICAgIH1cXG5cXG4gICAgICB3aGlsZSAoY3VyID0gcHJvcHNbaSsrXSkge1xcbiAgICAgICAgaWYgKCh2YWwgPSBlbGVtLmNzcyhjdXIpKSAhPT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgIHJldHVybiBjc3NQcm9wc1twcm9wXSA9IGN1ciwgdmFsO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfSAvLyBQYXJzZSBhIGdpdmVuIGVsZW1lbnRzIENTUyBwcm9wZXJ0eSBpbnRvIGFuIGludFxcblxcblxcbiAgICBmdW5jdGlvbiBpbnRDc3MoZWxlbSwgcHJvcCkge1xcbiAgICAgIHJldHVybiBNYXRoLmNlaWwocGFyc2VGbG9hdCh2ZW5kb3JDc3MoZWxlbSwgcHJvcCkpKTtcXG4gICAgfSAvLyBWTUwgY3JlYXRpb24gKGZvciBJRSBvbmx5KVxcblxcblxcbiAgICBpZiAoIUhBU0NBTlZBUykge1xcbiAgICAgIHZhciBjcmVhdGVWTUwgPSBmdW5jdGlvbiBjcmVhdGVWTUwodGFnLCBwcm9wcywgc3R5bGUpIHtcXG4gICAgICAgIHJldHVybiAnPHF0aXB2bWw6JyArIHRhZyArICcgeG1sbnM9XFxcInVybjpzY2hlbWFzLW1pY3Jvc29mdC5jb206dm1sXFxcIiBjbGFzcz1cXFwicXRpcC12bWxcXFwiICcgKyAocHJvcHMgfHwgJycpICsgJyBzdHlsZT1cXFwiYmVoYXZpb3I6IHVybCgjZGVmYXVsdCNWTUwpOyAnICsgKHN0eWxlIHx8ICcnKSArICdcXFwiIC8+JztcXG4gICAgICB9O1xcbiAgICB9IC8vIENhbnZhcyBvbmx5IGRlZmluaXRpb25zXFxuICAgIGVsc2Uge1xcbiAgICAgICAgdmFyIFBJWEVMX1JBVElPID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSxcXG4gICAgICAgICAgICBCQUNLSU5HX1NUT1JFX1JBVElPID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICB2YXIgY29udGV4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLmdldENvbnRleHQoJzJkJyk7XFxuICAgICAgICAgIHJldHVybiBjb250ZXh0LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY29udGV4dC53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGNvbnRleHQubW96QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjb250ZXh0Lm1zQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjb250ZXh0Lm9CYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IDE7XFxuICAgICAgICB9KCksXFxuICAgICAgICAgICAgU0NBTEUgPSBQSVhFTF9SQVRJTyAvIEJBQ0tJTkdfU1RPUkVfUkFUSU87XFxuICAgICAgfVxcblxcbiAgICBmdW5jdGlvbiBUaXAocXRpcCwgb3B0aW9ucykge1xcbiAgICAgIHRoaXMuX25zID0gJ3RpcCc7XFxuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcXG4gICAgICB0aGlzLm9mZnNldCA9IG9wdGlvbnMub2Zmc2V0O1xcbiAgICAgIHRoaXMuc2l6ZSA9IFtvcHRpb25zLndpZHRoLCBvcHRpb25zLmhlaWdodF07IC8vIEluaXRpYWxpemVcXG5cXG4gICAgICB0aGlzLmluaXQodGhpcy5xdGlwID0gcXRpcCk7XFxuICAgIH1cXG5cXG4gICAgJC5leHRlbmQoVGlwLnByb3RvdHlwZSwge1xcbiAgICAgIGluaXQ6IGZ1bmN0aW9uIGluaXQocXRpcCkge1xcbiAgICAgICAgdmFyIGNvbnRleHQsIHRpcDsgLy8gQ3JlYXRlIHRpcCBlbGVtZW50IGFuZCBwcmVwZW5kIHRvIHRoZSB0b29sdGlwXFxuXFxuICAgICAgICB0aXAgPSB0aGlzLmVsZW1lbnQgPSBxdGlwLmVsZW1lbnRzLnRpcCA9ICQoJzxkaXYgLz4nLCB7XFxuICAgICAgICAgICdjbGFzcyc6IE5BTUVTUEFDRSArICctdGlwJ1xcbiAgICAgICAgfSkucHJlcGVuZFRvKHF0aXAudG9vbHRpcCk7IC8vIENyZWF0ZSB0aXAgZHJhd2luZyBlbGVtZW50KHMpXFxuXFxuICAgICAgICBpZiAoSEFTQ0FOVkFTKSB7XFxuICAgICAgICAgIC8vIHNhdmUoKSBhcyBzb29uIGFzIHdlIGNyZWF0ZSB0aGUgY2FudmFzIGVsZW1lbnQgc28gRkYyIGRvZXNuJ3QgYm9yayBvbiBvdXIgZmlyc3QgcmVzdG9yZSgpIVxcbiAgICAgICAgICBjb250ZXh0ID0gJCgnPGNhbnZhcyAvPicpLmFwcGVuZFRvKHRoaXMuZWxlbWVudClbMF0uZ2V0Q29udGV4dCgnMmQnKTsgLy8gU2V0dXAgY29uc3RhbnQgcGFyYW1ldGVyc1xcblxcbiAgICAgICAgICBjb250ZXh0LmxpbmVKb2luID0gJ21pdGVyJztcXG4gICAgICAgICAgY29udGV4dC5taXRlckxpbWl0ID0gMTAwMDAwO1xcbiAgICAgICAgICBjb250ZXh0LnNhdmUoKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGNvbnRleHQgPSBjcmVhdGVWTUwoJ3NoYXBlJywgJ2Nvb3Jkb3JpZ2luPVxcXCIwLDBcXFwiJywgJ3Bvc2l0aW9uOmFic29sdXRlOycpO1xcbiAgICAgICAgICB0aGlzLmVsZW1lbnQuaHRtbChjb250ZXh0ICsgY29udGV4dCk7IC8vIFByZXZlbnQgbW91c2luZyBkb3duIG9uIHRoZSB0aXAgc2luY2UgaXQgY2F1c2VzIHByb2JsZW1zIHdpdGggLmxpdmUoKSBoYW5kbGluZyBpbiBJRSBkdWUgdG8gVk1MXFxuXFxuICAgICAgICAgIHF0aXAuX2JpbmQoJCgnKicsIHRpcCkuYWRkKHRpcCksIFsnY2xpY2snLCAnbW91c2Vkb3duJ10sIGZ1bmN0aW9uIChldmVudCkge1xcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xcbiAgICAgICAgICB9LCB0aGlzLl9ucyk7XFxuICAgICAgICB9IC8vIEJpbmQgdXBkYXRlIGV2ZW50c1xcblxcblxcbiAgICAgICAgcXRpcC5fYmluZChxdGlwLnRvb2x0aXAsICd0b29sdGlwbW92ZScsIHRoaXMucmVwb3NpdGlvbiwgdGhpcy5fbnMsIHRoaXMpOyAvLyBDcmVhdGUgaXRcXG5cXG5cXG4gICAgICAgIHRoaXMuY3JlYXRlKCk7XFxuICAgICAgfSxcXG4gICAgICBfc3dhcERpbWVuc2lvbnM6IGZ1bmN0aW9uIF9zd2FwRGltZW5zaW9ucygpIHtcXG4gICAgICAgIHRoaXMuc2l6ZVswXSA9IHRoaXMub3B0aW9ucy5oZWlnaHQ7XFxuICAgICAgICB0aGlzLnNpemVbMV0gPSB0aGlzLm9wdGlvbnMud2lkdGg7XFxuICAgICAgfSxcXG4gICAgICBfcmVzZXREaW1lbnNpb25zOiBmdW5jdGlvbiBfcmVzZXREaW1lbnNpb25zKCkge1xcbiAgICAgICAgdGhpcy5zaXplWzBdID0gdGhpcy5vcHRpb25zLndpZHRoO1xcbiAgICAgICAgdGhpcy5zaXplWzFdID0gdGhpcy5vcHRpb25zLmhlaWdodDtcXG4gICAgICB9LFxcbiAgICAgIF91c2VUaXRsZTogZnVuY3Rpb24gX3VzZVRpdGxlKGNvcm5lcikge1xcbiAgICAgICAgdmFyIHRpdGxlYmFyID0gdGhpcy5xdGlwLmVsZW1lbnRzLnRpdGxlYmFyO1xcbiAgICAgICAgcmV0dXJuIHRpdGxlYmFyICYmIChjb3JuZXIueSA9PT0gVE9QIHx8IGNvcm5lci55ID09PSBDRU5URVIgJiYgdGhpcy5lbGVtZW50LnBvc2l0aW9uKCkudG9wICsgdGhpcy5zaXplWzFdIC8gMiArIHRoaXMub3B0aW9ucy5vZmZzZXQgPCB0aXRsZWJhci5vdXRlckhlaWdodChUUlVFKSk7XFxuICAgICAgfSxcXG4gICAgICBfcGFyc2VDb3JuZXI6IGZ1bmN0aW9uIF9wYXJzZUNvcm5lcihjb3JuZXIpIHtcXG4gICAgICAgIHZhciBteSA9IHRoaXMucXRpcC5vcHRpb25zLnBvc2l0aW9uLm15OyAvLyBEZXRlY3QgY29ybmVyIGFuZCBtaW1pYyBwcm9wZXJ0aWVzXFxuXFxuICAgICAgICBpZiAoY29ybmVyID09PSBGQUxTRSB8fCBteSA9PT0gRkFMU0UpIHtcXG4gICAgICAgICAgY29ybmVyID0gRkFMU0U7XFxuICAgICAgICB9IGVsc2UgaWYgKGNvcm5lciA9PT0gVFJVRSkge1xcbiAgICAgICAgICBjb3JuZXIgPSBuZXcgQ09STkVSKG15LnN0cmluZygpKTtcXG4gICAgICAgIH0gZWxzZSBpZiAoIWNvcm5lci5zdHJpbmcpIHtcXG4gICAgICAgICAgY29ybmVyID0gbmV3IENPUk5FUihjb3JuZXIpO1xcbiAgICAgICAgICBjb3JuZXIuZml4ZWQgPSBUUlVFO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIGNvcm5lcjtcXG4gICAgICB9LFxcbiAgICAgIF9wYXJzZVdpZHRoOiBmdW5jdGlvbiBfcGFyc2VXaWR0aChjb3JuZXIsIHNpZGUsIHVzZSkge1xcbiAgICAgICAgdmFyIGVsZW1lbnRzID0gdGhpcy5xdGlwLmVsZW1lbnRzLFxcbiAgICAgICAgICAgIHByb3AgPSBCT1JERVIgKyBjYW1lbChzaWRlKSArICdXaWR0aCc7XFxuICAgICAgICByZXR1cm4gKHVzZSA/IGludENzcyh1c2UsIHByb3ApIDogaW50Q3NzKGVsZW1lbnRzLmNvbnRlbnQsIHByb3ApIHx8IGludENzcyh0aGlzLl91c2VUaXRsZShjb3JuZXIpICYmIGVsZW1lbnRzLnRpdGxlYmFyIHx8IGVsZW1lbnRzLmNvbnRlbnQsIHByb3ApIHx8IGludENzcyhlbGVtZW50cy50b29sdGlwLCBwcm9wKSkgfHwgMDtcXG4gICAgICB9LFxcbiAgICAgIF9wYXJzZVJhZGl1czogZnVuY3Rpb24gX3BhcnNlUmFkaXVzKGNvcm5lcikge1xcbiAgICAgICAgdmFyIGVsZW1lbnRzID0gdGhpcy5xdGlwLmVsZW1lbnRzLFxcbiAgICAgICAgICAgIHByb3AgPSBCT1JERVIgKyBjYW1lbChjb3JuZXIueSkgKyBjYW1lbChjb3JuZXIueCkgKyAnUmFkaXVzJztcXG4gICAgICAgIHJldHVybiBCUk9XU0VSLmllIDwgOSA/IDAgOiBpbnRDc3ModGhpcy5fdXNlVGl0bGUoY29ybmVyKSAmJiBlbGVtZW50cy50aXRsZWJhciB8fCBlbGVtZW50cy5jb250ZW50LCBwcm9wKSB8fCBpbnRDc3MoZWxlbWVudHMudG9vbHRpcCwgcHJvcCkgfHwgMDtcXG4gICAgICB9LFxcbiAgICAgIF9pbnZhbGlkQ29sb3VyOiBmdW5jdGlvbiBfaW52YWxpZENvbG91cihlbGVtLCBwcm9wLCBjb21wYXJlKSB7XFxuICAgICAgICB2YXIgdmFsID0gZWxlbS5jc3MocHJvcCk7XFxuICAgICAgICByZXR1cm4gIXZhbCB8fCBjb21wYXJlICYmIHZhbCA9PT0gZWxlbS5jc3MoY29tcGFyZSkgfHwgSU5WQUxJRC50ZXN0KHZhbCkgPyBGQUxTRSA6IHZhbDtcXG4gICAgICB9LFxcbiAgICAgIF9wYXJzZUNvbG91cnM6IGZ1bmN0aW9uIF9wYXJzZUNvbG91cnMoY29ybmVyKSB7XFxuICAgICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLnF0aXAuZWxlbWVudHMsXFxuICAgICAgICAgICAgdGlwID0gdGhpcy5lbGVtZW50LmNzcygnY3NzVGV4dCcsICcnKSxcXG4gICAgICAgICAgICBib3JkZXJTaWRlID0gQk9SREVSICsgY2FtZWwoY29ybmVyW2Nvcm5lci5wcmVjZWRhbmNlXSkgKyBjYW1lbChDT0xPUiksXFxuICAgICAgICAgICAgY29sb3JFbGVtID0gdGhpcy5fdXNlVGl0bGUoY29ybmVyKSAmJiBlbGVtZW50cy50aXRsZWJhciB8fCBlbGVtZW50cy5jb250ZW50LFxcbiAgICAgICAgICAgIGNzcyA9IHRoaXMuX2ludmFsaWRDb2xvdXIsXFxuICAgICAgICAgICAgY29sb3IgPSBbXTsgLy8gQXR0ZW1wdCB0byBkZXRlY3QgdGhlIGJhY2tncm91bmQgY29sb3VyIGZyb20gdmFyaW91cyBlbGVtZW50cywgbGVmdC10by1yaWdodCBwcmVjZWRhbmNlXFxuXFxuICAgICAgICBjb2xvclswXSA9IGNzcyh0aXAsIEJHX0NPTE9SKSB8fCBjc3MoY29sb3JFbGVtLCBCR19DT0xPUikgfHwgY3NzKGVsZW1lbnRzLmNvbnRlbnQsIEJHX0NPTE9SKSB8fCBjc3MoZWxlbWVudHMudG9vbHRpcCwgQkdfQ09MT1IpIHx8IHRpcC5jc3MoQkdfQ09MT1IpOyAvLyBBdHRlbXB0IHRvIGRldGVjdCB0aGUgY29ycmVjdCBib3JkZXIgc2lkZSBjb2xvdXIgZnJvbSB2YXJpb3VzIGVsZW1lbnRzLCBsZWZ0LXRvLXJpZ2h0IHByZWNlZGFuY2VcXG5cXG4gICAgICAgIGNvbG9yWzFdID0gY3NzKHRpcCwgYm9yZGVyU2lkZSwgQ09MT1IpIHx8IGNzcyhjb2xvckVsZW0sIGJvcmRlclNpZGUsIENPTE9SKSB8fCBjc3MoZWxlbWVudHMuY29udGVudCwgYm9yZGVyU2lkZSwgQ09MT1IpIHx8IGNzcyhlbGVtZW50cy50b29sdGlwLCBib3JkZXJTaWRlLCBDT0xPUikgfHwgZWxlbWVudHMudG9vbHRpcC5jc3MoYm9yZGVyU2lkZSk7IC8vIFJlc2V0IGJhY2tncm91bmQgYW5kIGJvcmRlciBjb2xvdXJzXFxuXFxuICAgICAgICAkKCcqJywgdGlwKS5hZGQodGlwKS5jc3MoJ2Nzc1RleHQnLCBCR19DT0xPUiArICc6JyArIFRSQU5TUEFSRU5UICsgSU1QT1JUQU5UICsgJzsnICsgQk9SREVSICsgJzowJyArIElNUE9SVEFOVCArICc7Jyk7XFxuICAgICAgICByZXR1cm4gY29sb3I7XFxuICAgICAgfSxcXG4gICAgICBfY2FsY3VsYXRlU2l6ZTogZnVuY3Rpb24gX2NhbGN1bGF0ZVNpemUoY29ybmVyKSB7XFxuICAgICAgICB2YXIgeSA9IGNvcm5lci5wcmVjZWRhbmNlID09PSBZLFxcbiAgICAgICAgICAgIHdpZHRoID0gdGhpcy5vcHRpb25zWyd3aWR0aCddLFxcbiAgICAgICAgICAgIGhlaWdodCA9IHRoaXMub3B0aW9uc1snaGVpZ2h0J10sXFxuICAgICAgICAgICAgaXNDZW50ZXIgPSBjb3JuZXIuYWJicmV2KCkgPT09ICdjJyxcXG4gICAgICAgICAgICBiYXNlID0gKHkgPyB3aWR0aCA6IGhlaWdodCkgKiAoaXNDZW50ZXIgPyAwLjUgOiAxKSxcXG4gICAgICAgICAgICBwb3cgPSBNYXRoLnBvdyxcXG4gICAgICAgICAgICByb3VuZCA9IE1hdGgucm91bmQsXFxuICAgICAgICAgICAgYmlnSHlwLFxcbiAgICAgICAgICAgIHJhdGlvLFxcbiAgICAgICAgICAgIHJlc3VsdCxcXG4gICAgICAgICAgICBzbWFsbEh5cCA9IE1hdGguc3FydChwb3coYmFzZSwgMikgKyBwb3coaGVpZ2h0LCAyKSksXFxuICAgICAgICAgICAgaHlwID0gW3RoaXMuYm9yZGVyIC8gYmFzZSAqIHNtYWxsSHlwLCB0aGlzLmJvcmRlciAvIGhlaWdodCAqIHNtYWxsSHlwXTtcXG4gICAgICAgIGh5cFsyXSA9IE1hdGguc3FydChwb3coaHlwWzBdLCAyKSAtIHBvdyh0aGlzLmJvcmRlciwgMikpO1xcbiAgICAgICAgaHlwWzNdID0gTWF0aC5zcXJ0KHBvdyhoeXBbMV0sIDIpIC0gcG93KHRoaXMuYm9yZGVyLCAyKSk7XFxuICAgICAgICBiaWdIeXAgPSBzbWFsbEh5cCArIGh5cFsyXSArIGh5cFszXSArIChpc0NlbnRlciA/IDAgOiBoeXBbMF0pO1xcbiAgICAgICAgcmF0aW8gPSBiaWdIeXAgLyBzbWFsbEh5cDtcXG4gICAgICAgIHJlc3VsdCA9IFtyb3VuZChyYXRpbyAqIHdpZHRoKSwgcm91bmQocmF0aW8gKiBoZWlnaHQpXTtcXG4gICAgICAgIHJldHVybiB5ID8gcmVzdWx0IDogcmVzdWx0LnJldmVyc2UoKTtcXG4gICAgICB9LFxcbiAgICAgIC8vIFRpcCBjb29yZGluYXRlcyBjYWxjdWxhdG9yXFxuICAgICAgX2NhbGN1bGF0ZVRpcDogZnVuY3Rpb24gX2NhbGN1bGF0ZVRpcChjb3JuZXIsIHNpemUsIHNjYWxlKSB7XFxuICAgICAgICBzY2FsZSA9IHNjYWxlIHx8IDE7XFxuICAgICAgICBzaXplID0gc2l6ZSB8fCB0aGlzLnNpemU7XFxuICAgICAgICB2YXIgd2lkdGggPSBzaXplWzBdICogc2NhbGUsXFxuICAgICAgICAgICAgaGVpZ2h0ID0gc2l6ZVsxXSAqIHNjYWxlLFxcbiAgICAgICAgICAgIHdpZHRoMiA9IE1hdGguY2VpbCh3aWR0aCAvIDIpLFxcbiAgICAgICAgICAgIGhlaWdodDIgPSBNYXRoLmNlaWwoaGVpZ2h0IC8gMiksXFxuICAgICAgICAgICAgLy8gRGVmaW5lIHRpcCBjb29yZGluYXRlcyBpbiB0ZXJtcyBvZiBoZWlnaHQgYW5kIHdpZHRoIHZhbHVlc1xcbiAgICAgICAgdGlwcyA9IHtcXG4gICAgICAgICAgYnI6IFswLCAwLCB3aWR0aCwgaGVpZ2h0LCB3aWR0aCwgMF0sXFxuICAgICAgICAgIGJsOiBbMCwgMCwgd2lkdGgsIDAsIDAsIGhlaWdodF0sXFxuICAgICAgICAgIHRyOiBbMCwgaGVpZ2h0LCB3aWR0aCwgMCwgd2lkdGgsIGhlaWdodF0sXFxuICAgICAgICAgIHRsOiBbMCwgMCwgMCwgaGVpZ2h0LCB3aWR0aCwgaGVpZ2h0XSxcXG4gICAgICAgICAgdGM6IFswLCBoZWlnaHQsIHdpZHRoMiwgMCwgd2lkdGgsIGhlaWdodF0sXFxuICAgICAgICAgIGJjOiBbMCwgMCwgd2lkdGgsIDAsIHdpZHRoMiwgaGVpZ2h0XSxcXG4gICAgICAgICAgcmM6IFswLCAwLCB3aWR0aCwgaGVpZ2h0MiwgMCwgaGVpZ2h0XSxcXG4gICAgICAgICAgbGM6IFt3aWR0aCwgMCwgd2lkdGgsIGhlaWdodCwgMCwgaGVpZ2h0Ml1cXG4gICAgICAgIH07IC8vIFNldCBjb21tb24gc2lkZSBzaGFwZXNcXG5cXG4gICAgICAgIHRpcHMubHQgPSB0aXBzLmJyO1xcbiAgICAgICAgdGlwcy5ydCA9IHRpcHMuYmw7XFxuICAgICAgICB0aXBzLmxiID0gdGlwcy50cjtcXG4gICAgICAgIHRpcHMucmIgPSB0aXBzLnRsO1xcbiAgICAgICAgcmV0dXJuIHRpcHNbY29ybmVyLmFiYnJldigpXTtcXG4gICAgICB9LFxcbiAgICAgIC8vIFRpcCBjb29yZGluYXRlcyBkcmF3ZXIgKGNhbnZhcylcXG4gICAgICBfZHJhd0Nvb3JkczogZnVuY3Rpb24gX2RyYXdDb29yZHMoY29udGV4dCwgY29vcmRzKSB7XFxuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xcbiAgICAgICAgY29udGV4dC5tb3ZlVG8oY29vcmRzWzBdLCBjb29yZHNbMV0pO1xcbiAgICAgICAgY29udGV4dC5saW5lVG8oY29vcmRzWzJdLCBjb29yZHNbM10pO1xcbiAgICAgICAgY29udGV4dC5saW5lVG8oY29vcmRzWzRdLCBjb29yZHNbNV0pO1xcbiAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcXG4gICAgICB9LFxcbiAgICAgIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKCkge1xcbiAgICAgICAgLy8gRGV0ZXJtaW5lIHRpcCBjb3JuZXJcXG4gICAgICAgIHZhciBjID0gdGhpcy5jb3JuZXIgPSAoSEFTQ0FOVkFTIHx8IEJST1dTRVIuaWUpICYmIHRoaXMuX3BhcnNlQ29ybmVyKHRoaXMub3B0aW9ucy5jb3JuZXIpOyAvLyBJZiB3ZSBoYXZlIGEgdGlwIGNvcm5lci4uLlxcblxcblxcbiAgICAgICAgaWYgKHRoaXMuZW5hYmxlZCA9ICEhdGhpcy5jb3JuZXIgJiYgdGhpcy5jb3JuZXIuYWJicmV2KCkgIT09ICdjJykge1xcbiAgICAgICAgICAvLyBDYWNoZSBpdFxcbiAgICAgICAgICB0aGlzLnF0aXAuY2FjaGUuY29ybmVyID0gYy5jbG9uZSgpOyAvLyBDcmVhdGUgaXRcXG5cXG4gICAgICAgICAgdGhpcy51cGRhdGUoKTtcXG4gICAgICAgIH0gLy8gVG9nZ2xlIHRpcCBlbGVtZW50XFxuXFxuXFxuICAgICAgICB0aGlzLmVsZW1lbnQudG9nZ2xlKHRoaXMuZW5hYmxlZCk7XFxuICAgICAgICByZXR1cm4gdGhpcy5jb3JuZXI7XFxuICAgICAgfSxcXG4gICAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShjb3JuZXIsIHBvc2l0aW9uKSB7XFxuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZCkge1xcbiAgICAgICAgICByZXR1cm4gdGhpcztcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHZhciBlbGVtZW50cyA9IHRoaXMucXRpcC5lbGVtZW50cyxcXG4gICAgICAgICAgICB0aXAgPSB0aGlzLmVsZW1lbnQsXFxuICAgICAgICAgICAgaW5uZXIgPSB0aXAuY2hpbGRyZW4oKSxcXG4gICAgICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxcbiAgICAgICAgICAgIGN1clNpemUgPSB0aGlzLnNpemUsXFxuICAgICAgICAgICAgbWltaWMgPSBvcHRpb25zLm1pbWljLFxcbiAgICAgICAgICAgIHJvdW5kID0gTWF0aC5yb3VuZCxcXG4gICAgICAgICAgICBjb2xvcixcXG4gICAgICAgICAgICBwcmVjZWRhbmNlLFxcbiAgICAgICAgICAgIGNvbnRleHQsXFxuICAgICAgICAgICAgY29vcmRzLFxcbiAgICAgICAgICAgIGJpZ0Nvb3JkcyxcXG4gICAgICAgICAgICB0cmFuc2xhdGUsXFxuICAgICAgICAgICAgbmV3U2l6ZSxcXG4gICAgICAgICAgICBib3JkZXIsXFxuICAgICAgICAgICAgQkFDS0lOR19TVE9SRV9SQVRJTzsgLy8gUmUtZGV0ZXJtaW5lIHRpcCBpZiBub3QgYWxyZWFkeSBzZXRcXG5cXG4gICAgICAgIGlmICghY29ybmVyKSB7XFxuICAgICAgICAgIGNvcm5lciA9IHRoaXMucXRpcC5jYWNoZS5jb3JuZXIgfHwgdGhpcy5jb3JuZXI7XFxuICAgICAgICB9IC8vIFVzZSBjb3JuZXIgcHJvcGVydHkgaWYgd2UgZGV0ZWN0IGFuIGludmFsaWQgbWltaWMgdmFsdWVcXG5cXG5cXG4gICAgICAgIGlmIChtaW1pYyA9PT0gRkFMU0UpIHtcXG4gICAgICAgICAgbWltaWMgPSBjb3JuZXI7XFxuICAgICAgICB9IC8vIE90aGVyd2lzZSBpbmhlcml0IG1pbWljIHByb3BlcnRpZXMgZnJvbSB0aGUgY29ybmVyIG9iamVjdCBhcyBuZWNlc3NhcnlcXG4gICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgIG1pbWljID0gbmV3IENPUk5FUihtaW1pYyk7XFxuICAgICAgICAgICAgbWltaWMucHJlY2VkYW5jZSA9IGNvcm5lci5wcmVjZWRhbmNlO1xcblxcbiAgICAgICAgICAgIGlmIChtaW1pYy54ID09PSAnaW5oZXJpdCcpIHtcXG4gICAgICAgICAgICAgIG1pbWljLnggPSBjb3JuZXIueDtcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1pbWljLnkgPT09ICdpbmhlcml0Jykge1xcbiAgICAgICAgICAgICAgbWltaWMueSA9IGNvcm5lci55O1xcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWltaWMueCA9PT0gbWltaWMueSkge1xcbiAgICAgICAgICAgICAgbWltaWNbY29ybmVyLnByZWNlZGFuY2VdID0gY29ybmVyW2Nvcm5lci5wcmVjZWRhbmNlXTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgIHByZWNlZGFuY2UgPSBtaW1pYy5wcmVjZWRhbmNlOyAvLyBFbnN1cmUgdGhlIHRpcCB3aWR0aC5oZWlnaHQgYXJlIHJlbGF0aXZlIHRvIHRoZSB0aXAgcG9zaXRpb25cXG5cXG4gICAgICAgIGlmIChjb3JuZXIucHJlY2VkYW5jZSA9PT0gWCkge1xcbiAgICAgICAgICB0aGlzLl9zd2FwRGltZW5zaW9ucygpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgdGhpcy5fcmVzZXREaW1lbnNpb25zKCk7XFxuICAgICAgICB9IC8vIFVwZGF0ZSBvdXIgY29sb3Vyc1xcblxcblxcbiAgICAgICAgY29sb3IgPSB0aGlzLmNvbG9yID0gdGhpcy5fcGFyc2VDb2xvdXJzKGNvcm5lcik7IC8vIERldGVjdCBib3JkZXIgd2lkdGgsIHRha2luZyBpbnRvIGFjY291bnQgY29sb3Vyc1xcblxcbiAgICAgICAgaWYgKGNvbG9yWzFdICE9PSBUUkFOU1BBUkVOVCkge1xcbiAgICAgICAgICAvLyBHcmFiIGJvcmRlciB3aWR0aFxcbiAgICAgICAgICBib3JkZXIgPSB0aGlzLmJvcmRlciA9IHRoaXMuX3BhcnNlV2lkdGgoY29ybmVyLCBjb3JuZXJbY29ybmVyLnByZWNlZGFuY2VdKTsgLy8gSWYgYm9yZGVyIHdpZHRoIGlzbid0IHplcm8sIHVzZSBib3JkZXIgY29sb3IgYXMgZmlsbCBpZiBpdCdzIG5vdCBpbnZhbGlkICgxLjAgc3R5bGUgdGlwcylcXG5cXG4gICAgICAgICAgaWYgKG9wdGlvbnMuYm9yZGVyICYmIGJvcmRlciA8IDEgJiYgIUlOVkFMSUQudGVzdChjb2xvclsxXSkpIHtcXG4gICAgICAgICAgICBjb2xvclswXSA9IGNvbG9yWzFdO1xcbiAgICAgICAgICB9IC8vIFNldCBib3JkZXIgd2lkdGggKHVzZSBkZXRlY3RlZCBib3JkZXIgd2lkdGggaWYgb3B0aW9ucy5ib3JkZXIgaXMgdHJ1ZSlcXG5cXG5cXG4gICAgICAgICAgdGhpcy5ib3JkZXIgPSBib3JkZXIgPSBvcHRpb25zLmJvcmRlciAhPT0gVFJVRSA/IG9wdGlvbnMuYm9yZGVyIDogYm9yZGVyO1xcbiAgICAgICAgfSAvLyBCb3JkZXIgY29sb3VyIHdhcyBpbnZhbGlkLCBzZXQgYm9yZGVyIHRvIHplcm9cXG4gICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgIHRoaXMuYm9yZGVyID0gYm9yZGVyID0gMDtcXG4gICAgICAgICAgfSAvLyBEZXRlcm1pbmUgdGlwIHNpemVcXG5cXG5cXG4gICAgICAgIG5ld1NpemUgPSB0aGlzLnNpemUgPSB0aGlzLl9jYWxjdWxhdGVTaXplKGNvcm5lcik7XFxuICAgICAgICB0aXAuY3NzKHtcXG4gICAgICAgICAgd2lkdGg6IG5ld1NpemVbMF0sXFxuICAgICAgICAgIGhlaWdodDogbmV3U2l6ZVsxXSxcXG4gICAgICAgICAgbGluZUhlaWdodDogbmV3U2l6ZVsxXSArICdweCdcXG4gICAgICAgIH0pOyAvLyBDYWxjdWxhdGUgdGlwIHRyYW5zbGF0aW9uXFxuXFxuICAgICAgICBpZiAoY29ybmVyLnByZWNlZGFuY2UgPT09IFkpIHtcXG4gICAgICAgICAgdHJhbnNsYXRlID0gW3JvdW5kKG1pbWljLnggPT09IExFRlQgPyBib3JkZXIgOiBtaW1pYy54ID09PSBSSUdIVCA/IG5ld1NpemVbMF0gLSBjdXJTaXplWzBdIC0gYm9yZGVyIDogKG5ld1NpemVbMF0gLSBjdXJTaXplWzBdKSAvIDIpLCByb3VuZChtaW1pYy55ID09PSBUT1AgPyBuZXdTaXplWzFdIC0gY3VyU2l6ZVsxXSA6IDApXTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHRyYW5zbGF0ZSA9IFtyb3VuZChtaW1pYy54ID09PSBMRUZUID8gbmV3U2l6ZVswXSAtIGN1clNpemVbMF0gOiAwKSwgcm91bmQobWltaWMueSA9PT0gVE9QID8gYm9yZGVyIDogbWltaWMueSA9PT0gQk9UVE9NID8gbmV3U2l6ZVsxXSAtIGN1clNpemVbMV0gLSBib3JkZXIgOiAobmV3U2l6ZVsxXSAtIGN1clNpemVbMV0pIC8gMildO1xcbiAgICAgICAgfSAvLyBDYW52YXMgZHJhd2luZyBpbXBsZW1lbnRhdGlvblxcblxcblxcbiAgICAgICAgaWYgKEhBU0NBTlZBUykge1xcbiAgICAgICAgICAvLyBHcmFiIGNhbnZhcyBjb250ZXh0IGFuZCBjbGVhci9zYXZlIGl0XFxuICAgICAgICAgIGNvbnRleHQgPSBpbm5lclswXS5nZXRDb250ZXh0KCcyZCcpO1xcbiAgICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcXG4gICAgICAgICAgY29udGV4dC5zYXZlKCk7XFxuICAgICAgICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIDYwMDAsIDYwMDApOyAvLyBDYWxjdWxhdGUgY29vcmRpbmF0ZXNcXG5cXG4gICAgICAgICAgY29vcmRzID0gdGhpcy5fY2FsY3VsYXRlVGlwKG1pbWljLCBjdXJTaXplLCBTQ0FMRSk7XFxuICAgICAgICAgIGJpZ0Nvb3JkcyA9IHRoaXMuX2NhbGN1bGF0ZVRpcChtaW1pYywgdGhpcy5zaXplLCBTQ0FMRSk7IC8vIFNldCB0aGUgY2FudmFzIHNpemUgdXNpbmcgY2FsY3VsYXRlZCBzaXplXFxuXFxuICAgICAgICAgIGlubmVyLmF0dHIoV0lEVEgsIG5ld1NpemVbMF0gKiBTQ0FMRSkuYXR0cihIRUlHSFQsIG5ld1NpemVbMV0gKiBTQ0FMRSk7XFxuICAgICAgICAgIGlubmVyLmNzcyhXSURUSCwgbmV3U2l6ZVswXSkuY3NzKEhFSUdIVCwgbmV3U2l6ZVsxXSk7IC8vIERyYXcgdGhlIG91dGVyLXN0cm9rZSB0aXBcXG5cXG4gICAgICAgICAgdGhpcy5fZHJhd0Nvb3Jkcyhjb250ZXh0LCBiaWdDb29yZHMpO1xcblxcbiAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGNvbG9yWzFdO1xcbiAgICAgICAgICBjb250ZXh0LmZpbGwoKTsgLy8gRHJhdyB0aGUgYWN0dWFsIHRpcFxcblxcbiAgICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZSh0cmFuc2xhdGVbMF0gKiBTQ0FMRSwgdHJhbnNsYXRlWzFdICogU0NBTEUpO1xcblxcbiAgICAgICAgICB0aGlzLl9kcmF3Q29vcmRzKGNvbnRleHQsIGNvb3Jkcyk7XFxuXFxuICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gY29sb3JbMF07XFxuICAgICAgICAgIGNvbnRleHQuZmlsbCgpO1xcbiAgICAgICAgfSAvLyBWTUwgKElFIFByb3ByaWV0YXJ5IGltcGxlbWVudGF0aW9uKVxcbiAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIGNvb3JkaW5hdGVzXFxuICAgICAgICAgICAgY29vcmRzID0gdGhpcy5fY2FsY3VsYXRlVGlwKG1pbWljKTsgLy8gU2V0dXAgY29vcmRpbmF0ZXMgc3RyaW5nXFxuXFxuICAgICAgICAgICAgY29vcmRzID0gJ20nICsgY29vcmRzWzBdICsgJywnICsgY29vcmRzWzFdICsgJyBsJyArIGNvb3Jkc1syXSArICcsJyArIGNvb3Jkc1szXSArICcgJyArIGNvb3Jkc1s0XSArICcsJyArIGNvb3Jkc1s1XSArICcgeGUnOyAvLyBTZXR1cCBWTUwtc3BlY2lmaWMgb2Zmc2V0IGZvciBwaXhlbC1wZXJmZWN0aW9uXFxuXFxuICAgICAgICAgICAgdHJhbnNsYXRlWzJdID0gYm9yZGVyICYmIC9eKHJ8YikvaS50ZXN0KGNvcm5lci5zdHJpbmcoKSkgPyBCUk9XU0VSLmllID09PSA4ID8gMiA6IDEgOiAwOyAvLyBTZXQgaW5pdGlhbCBDU1NcXG5cXG4gICAgICAgICAgICBpbm5lci5jc3Moe1xcbiAgICAgICAgICAgICAgY29vcmRzaXplOiBuZXdTaXplWzBdICsgYm9yZGVyICsgJyAnICsgKG5ld1NpemVbMV0gKyBib3JkZXIpLFxcbiAgICAgICAgICAgICAgYW50aWFsaWFzOiAnJyArIChtaW1pYy5zdHJpbmcoKS5pbmRleE9mKENFTlRFUikgPiAtMSksXFxuICAgICAgICAgICAgICBsZWZ0OiB0cmFuc2xhdGVbMF0gLSB0cmFuc2xhdGVbMl0gKiBOdW1iZXIocHJlY2VkYW5jZSA9PT0gWCksXFxuICAgICAgICAgICAgICB0b3A6IHRyYW5zbGF0ZVsxXSAtIHRyYW5zbGF0ZVsyXSAqIE51bWJlcihwcmVjZWRhbmNlID09PSBZKSxcXG4gICAgICAgICAgICAgIHdpZHRoOiBuZXdTaXplWzBdICsgYm9yZGVyLFxcbiAgICAgICAgICAgICAgaGVpZ2h0OiBuZXdTaXplWzFdICsgYm9yZGVyXFxuICAgICAgICAgICAgfSkuZWFjaChmdW5jdGlvbiAoaSkge1xcbiAgICAgICAgICAgICAgdmFyICR0aGlzID0gJCh0aGlzKTsgLy8gU2V0IHNoYXBlIHNwZWNpZmljIGF0dHJpYnV0ZXNcXG5cXG4gICAgICAgICAgICAgICR0aGlzWyR0aGlzLnByb3AgPyAncHJvcCcgOiAnYXR0ciddKHtcXG4gICAgICAgICAgICAgICAgY29vcmRzaXplOiBuZXdTaXplWzBdICsgYm9yZGVyICsgJyAnICsgKG5ld1NpemVbMV0gKyBib3JkZXIpLFxcbiAgICAgICAgICAgICAgICBwYXRoOiBjb29yZHMsXFxuICAgICAgICAgICAgICAgIGZpbGxjb2xvcjogY29sb3JbMF0sXFxuICAgICAgICAgICAgICAgIGZpbGxlZDogISFpLFxcbiAgICAgICAgICAgICAgICBzdHJva2VkOiAhaVxcbiAgICAgICAgICAgICAgfSkudG9nZ2xlKCEhKGJvcmRlciB8fCBpKSk7IC8vIENoZWNrIGlmIGJvcmRlciBpcyBlbmFibGVkIGFuZCBhZGQgc3Ryb2tlIGVsZW1lbnRcXG5cXG4gICAgICAgICAgICAgICFpICYmICR0aGlzLmh0bWwoY3JlYXRlVk1MKCdzdHJva2UnLCAnd2VpZ2h0PVxcXCInICsgYm9yZGVyICogMiArICdweFxcXCIgY29sb3I9XFxcIicgKyBjb2xvclsxXSArICdcXFwiIG1pdGVybGltaXQ9XFxcIjEwMDBcXFwiIGpvaW5zdHlsZT1cXFwibWl0ZXJcXFwiJykpO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICB9IC8vIE9wZXJhIGJ1ZyAjMzU3IC0gSW5jb3JyZWN0IHRpcCBwb3NpdGlvblxcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0NyYWdhODkvcVRpcDIvaXNzdWVzLzM2N1xcblxcblxcbiAgICAgICAgd2luZG93Lm9wZXJhICYmIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBlbGVtZW50cy50aXAuY3NzKHtcXG4gICAgICAgICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcXG4gICAgICAgICAgICB2aXNpYmlsaXR5OiAndmlzaWJsZSdcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9LCAxKTsgLy8gUG9zaXRpb24gaWYgbmVlZGVkXFxuXFxuICAgICAgICBpZiAocG9zaXRpb24gIT09IEZBTFNFKSB7XFxuICAgICAgICAgIHRoaXMuY2FsY3VsYXRlKGNvcm5lciwgbmV3U2l6ZSk7XFxuICAgICAgICB9XFxuICAgICAgfSxcXG4gICAgICBjYWxjdWxhdGU6IGZ1bmN0aW9uIGNhbGN1bGF0ZShjb3JuZXIsIHNpemUpIHtcXG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKSB7XFxuICAgICAgICAgIHJldHVybiBGQUxTRTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcXG4gICAgICAgICAgICBlbGVtZW50cyA9IHRoaXMucXRpcC5lbGVtZW50cyxcXG4gICAgICAgICAgICB0aXAgPSB0aGlzLmVsZW1lbnQsXFxuICAgICAgICAgICAgdXNlck9mZnNldCA9IHRoaXMub3B0aW9ucy5vZmZzZXQsXFxuICAgICAgICAgICAgaXNXaWRnZXQgPSBlbGVtZW50cy50b29sdGlwLmhhc0NsYXNzKCd1aS13aWRnZXQnKSxcXG4gICAgICAgICAgICBwb3NpdGlvbiA9IHt9LFxcbiAgICAgICAgICAgIHByZWNlZGFuY2UsXFxuICAgICAgICAgICAgY29ybmVyczsgLy8gSW5oZXJpdCBjb3JuZXIgaWYgbm90IHByb3ZpZGVkXFxuXFxuICAgICAgICBjb3JuZXIgPSBjb3JuZXIgfHwgdGhpcy5jb3JuZXI7XFxuICAgICAgICBwcmVjZWRhbmNlID0gY29ybmVyLnByZWNlZGFuY2U7IC8vIERldGVybWluZSB3aGljaCB0aXAgZGltZW5zaW9uIHRvIHVzZSBmb3IgYWRqdXN0bWVudFxcblxcbiAgICAgICAgc2l6ZSA9IHNpemUgfHwgdGhpcy5fY2FsY3VsYXRlU2l6ZShjb3JuZXIpOyAvLyBTZXR1cCBjb3JuZXJzIGFuZCBvZmZzZXQgYXJyYXlcXG5cXG4gICAgICAgIGNvcm5lcnMgPSBbY29ybmVyLngsIGNvcm5lci55XTtcXG5cXG4gICAgICAgIGlmIChwcmVjZWRhbmNlID09PSBYKSB7XFxuICAgICAgICAgIGNvcm5lcnMucmV2ZXJzZSgpO1xcbiAgICAgICAgfSAvLyBDYWxjdWxhdGUgdGlwIHBvc2l0aW9uXFxuXFxuXFxuICAgICAgICAkLmVhY2goY29ybmVycywgZnVuY3Rpb24gKGksIHNpZGUpIHtcXG4gICAgICAgICAgdmFyIGIsIGJjLCBicjtcXG5cXG4gICAgICAgICAgaWYgKHNpZGUgPT09IENFTlRFUikge1xcbiAgICAgICAgICAgIGIgPSBwcmVjZWRhbmNlID09PSBZID8gTEVGVCA6IFRPUDtcXG4gICAgICAgICAgICBwb3NpdGlvbltiXSA9ICc1MCUnO1xcbiAgICAgICAgICAgIHBvc2l0aW9uW01BUkdJTiArICctJyArIGJdID0gLU1hdGgucm91bmQoc2l6ZVtwcmVjZWRhbmNlID09PSBZID8gMCA6IDFdIC8gMikgKyB1c2VyT2Zmc2V0O1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGIgPSBzZWxmLl9wYXJzZVdpZHRoKGNvcm5lciwgc2lkZSwgZWxlbWVudHMudG9vbHRpcCk7XFxuICAgICAgICAgICAgYmMgPSBzZWxmLl9wYXJzZVdpZHRoKGNvcm5lciwgc2lkZSwgZWxlbWVudHMuY29udGVudCk7XFxuICAgICAgICAgICAgYnIgPSBzZWxmLl9wYXJzZVJhZGl1cyhjb3JuZXIpO1xcbiAgICAgICAgICAgIHBvc2l0aW9uW3NpZGVdID0gTWF0aC5tYXgoLXNlbGYuYm9yZGVyLCBpID8gYmMgOiB1c2VyT2Zmc2V0ICsgKGJyID4gYiA/IGJyIDogLWIpKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSk7IC8vIEFkanVzdCBmb3IgdGlwIHNpemVcXG5cXG4gICAgICAgIHBvc2l0aW9uW2Nvcm5lcltwcmVjZWRhbmNlXV0gLT0gc2l6ZVtwcmVjZWRhbmNlID09PSBYID8gMCA6IDFdOyAvLyBTZXQgYW5kIHJldHVybiBuZXcgcG9zaXRpb25cXG5cXG4gICAgICAgIHRpcC5jc3Moe1xcbiAgICAgICAgICBtYXJnaW46ICcnLFxcbiAgICAgICAgICB0b3A6ICcnLFxcbiAgICAgICAgICBib3R0b206ICcnLFxcbiAgICAgICAgICBsZWZ0OiAnJyxcXG4gICAgICAgICAgcmlnaHQ6ICcnXFxuICAgICAgICB9KS5jc3MocG9zaXRpb24pO1xcbiAgICAgICAgcmV0dXJuIHBvc2l0aW9uO1xcbiAgICAgIH0sXFxuICAgICAgcmVwb3NpdGlvbjogZnVuY3Rpb24gcmVwb3NpdGlvbihldmVudCwgYXBpLCBwb3MsIHZpZXdwb3J0KSB7XFxuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZCkge1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICB2YXIgY2FjaGUgPSBhcGkuY2FjaGUsXFxuICAgICAgICAgICAgbmV3Q29ybmVyID0gdGhpcy5jb3JuZXIuY2xvbmUoKSxcXG4gICAgICAgICAgICBhZGp1c3QgPSBwb3MuYWRqdXN0ZWQsXFxuICAgICAgICAgICAgbWV0aG9kID0gYXBpLm9wdGlvbnMucG9zaXRpb24uYWRqdXN0Lm1ldGhvZC5zcGxpdCgnICcpLFxcbiAgICAgICAgICAgIGhvcml6b250YWwgPSBtZXRob2RbMF0sXFxuICAgICAgICAgICAgdmVydGljYWwgPSBtZXRob2RbMV0gfHwgbWV0aG9kWzBdLFxcbiAgICAgICAgICAgIHNoaWZ0ID0ge1xcbiAgICAgICAgICBsZWZ0OiBGQUxTRSxcXG4gICAgICAgICAgdG9wOiBGQUxTRSxcXG4gICAgICAgICAgeDogMCxcXG4gICAgICAgICAgeTogMFxcbiAgICAgICAgfSxcXG4gICAgICAgICAgICBvZmZzZXQsXFxuICAgICAgICAgICAgY3NzID0ge30sXFxuICAgICAgICAgICAgcHJvcHM7XFxuXFxuICAgICAgICBmdW5jdGlvbiBzaGlmdGZsaXAoZGlyZWN0aW9uLCBwcmVjZWRhbmNlLCBwb3Bwb3NpdGUsIHNpZGUsIG9wcG9zaXRlKSB7XFxuICAgICAgICAgIC8vIEhvcml6b250YWwgLSBTaGlmdCBvciBmbGlwIG1ldGhvZFxcbiAgICAgICAgICBpZiAoZGlyZWN0aW9uID09PSBTSElGVCAmJiBuZXdDb3JuZXIucHJlY2VkYW5jZSA9PT0gcHJlY2VkYW5jZSAmJiBhZGp1c3Rbc2lkZV0gJiYgbmV3Q29ybmVyW3BvcHBvc2l0ZV0gIT09IENFTlRFUikge1xcbiAgICAgICAgICAgIG5ld0Nvcm5lci5wcmVjZWRhbmNlID0gbmV3Q29ybmVyLnByZWNlZGFuY2UgPT09IFggPyBZIDogWDtcXG4gICAgICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gIT09IFNISUZUICYmIGFkanVzdFtzaWRlXSkge1xcbiAgICAgICAgICAgIG5ld0Nvcm5lcltwcmVjZWRhbmNlXSA9IG5ld0Nvcm5lcltwcmVjZWRhbmNlXSA9PT0gQ0VOVEVSID8gYWRqdXN0W3NpZGVdID4gMCA/IHNpZGUgOiBvcHBvc2l0ZSA6IG5ld0Nvcm5lcltwcmVjZWRhbmNlXSA9PT0gc2lkZSA/IG9wcG9zaXRlIDogc2lkZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgZnVuY3Rpb24gc2hpZnRvbmx5KHh5LCBzaWRlLCBvcHBvc2l0ZSkge1xcbiAgICAgICAgICBpZiAobmV3Q29ybmVyW3h5XSA9PT0gQ0VOVEVSKSB7XFxuICAgICAgICAgICAgY3NzW01BUkdJTiArICctJyArIHNpZGVdID0gc2hpZnRbeHldID0gb2Zmc2V0W01BUkdJTiArICctJyArIHNpZGVdIC0gYWRqdXN0W3NpZGVdO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHByb3BzID0gb2Zmc2V0W29wcG9zaXRlXSAhPT0gdW5kZWZpbmVkID8gW2FkanVzdFtzaWRlXSwgLW9mZnNldFtzaWRlXV0gOiBbLWFkanVzdFtzaWRlXSwgb2Zmc2V0W3NpZGVdXTtcXG5cXG4gICAgICAgICAgICBpZiAoKHNoaWZ0W3h5XSA9IE1hdGgubWF4KHByb3BzWzBdLCBwcm9wc1sxXSkpID4gcHJvcHNbMF0pIHtcXG4gICAgICAgICAgICAgIHBvc1tzaWRlXSAtPSBhZGp1c3Rbc2lkZV07XFxuICAgICAgICAgICAgICBzaGlmdFtzaWRlXSA9IEZBTFNFO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBjc3Nbb2Zmc2V0W29wcG9zaXRlXSAhPT0gdW5kZWZpbmVkID8gb3Bwb3NpdGUgOiBzaWRlXSA9IHNoaWZ0W3h5XTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSAvLyBJZiBvdXIgdGlwIHBvc2l0aW9uIGlzbid0IGZpeGVkIGUuZy4gZG9lc24ndCBhZGp1c3Qgd2l0aCB2aWV3cG9ydC4uLlxcblxcblxcbiAgICAgICAgaWYgKHRoaXMuY29ybmVyLmZpeGVkICE9PSBUUlVFKSB7XFxuICAgICAgICAgIC8vIFBlcmZvcm0gc2hpZnQvZmxpcCBhZGp1c3RtZW50c1xcbiAgICAgICAgICBzaGlmdGZsaXAoaG9yaXpvbnRhbCwgWCwgWSwgTEVGVCwgUklHSFQpO1xcbiAgICAgICAgICBzaGlmdGZsaXAodmVydGljYWwsIFksIFgsIFRPUCwgQk9UVE9NKTsgLy8gVXBkYXRlIGFuZCByZWRyYXcgdGhlIHRpcCBpZiBuZWVkZWQgKGNoZWNrIGNhY2hlZCBkZXRhaWxzIG9mIGxhc3QgZHJhd24gdGlwKVxcblxcbiAgICAgICAgICBpZiAobmV3Q29ybmVyLnN0cmluZygpICE9PSBjYWNoZS5jb3JuZXIuc3RyaW5nKCkgfHwgY2FjaGUuY29ybmVyVG9wICE9PSBhZGp1c3QudG9wIHx8IGNhY2hlLmNvcm5lckxlZnQgIT09IGFkanVzdC5sZWZ0KSB7XFxuICAgICAgICAgICAgdGhpcy51cGRhdGUobmV3Q29ybmVyLCBGQUxTRSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gLy8gU2V0dXAgdGlwIG9mZnNldCBwcm9wZXJ0aWVzXFxuXFxuXFxuICAgICAgICBvZmZzZXQgPSB0aGlzLmNhbGN1bGF0ZShuZXdDb3JuZXIpOyAvLyBSZWFkanVzdCBvZmZzZXQgb2JqZWN0IHRvIG1ha2UgaXQgbGVmdC90b3BcXG5cXG4gICAgICAgIGlmIChvZmZzZXQucmlnaHQgIT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgICBvZmZzZXQubGVmdCA9IC1vZmZzZXQucmlnaHQ7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAob2Zmc2V0LmJvdHRvbSAhPT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgIG9mZnNldC50b3AgPSAtb2Zmc2V0LmJvdHRvbTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIG9mZnNldC51c2VyID0gdGhpcy5vZmZzZXQ7IC8vIFBlcmZvcm0gc2hpZnQgYWRqdXN0bWVudHNcXG5cXG4gICAgICAgIGlmIChzaGlmdC5sZWZ0ID0gaG9yaXpvbnRhbCA9PT0gU0hJRlQgJiYgISFhZGp1c3QubGVmdCkge1xcbiAgICAgICAgICBzaGlmdG9ubHkoWCwgTEVGVCwgUklHSFQpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKHNoaWZ0LnRvcCA9IHZlcnRpY2FsID09PSBTSElGVCAmJiAhIWFkanVzdC50b3ApIHtcXG4gICAgICAgICAgc2hpZnRvbmx5KFksIFRPUCwgQk9UVE9NKTtcXG4gICAgICAgIH1cXG4gICAgICAgIC8qXFxuICAgICAgICAqIElmIHRoZSB0aXAgaXMgYWRqdXN0ZWQgaW4gYm90aCBkaW1lbnNpb25zLCBvciBpbiBhXFxuICAgICAgICAqIGRpcmVjdGlvbiB0aGF0IHdvdWxkIGNhdXNlIGl0IHRvIGJlIGFueXdoZXJlIGJ1dCB0aGVcXG4gICAgICAgICogb3V0ZXIgYm9yZGVyLCBoaWRlIGl0IVxcbiAgICAgICAgKi9cXG5cXG5cXG4gICAgICAgIHRoaXMuZWxlbWVudC5jc3MoY3NzKS50b2dnbGUoIShzaGlmdC54ICYmIHNoaWZ0LnkgfHwgbmV3Q29ybmVyLnggPT09IENFTlRFUiAmJiBzaGlmdC55IHx8IG5ld0Nvcm5lci55ID09PSBDRU5URVIgJiYgc2hpZnQueCkpOyAvLyBBZGp1c3QgcG9zaXRpb24gdG8gYWNjb21vZGF0ZSB0aXAgZGltZW5zaW9uc1xcblxcbiAgICAgICAgcG9zLmxlZnQgLT0gb2Zmc2V0LmxlZnQuY2hhckF0ID8gb2Zmc2V0LnVzZXIgOiBob3Jpem9udGFsICE9PSBTSElGVCB8fCBzaGlmdC50b3AgfHwgIXNoaWZ0LmxlZnQgJiYgIXNoaWZ0LnRvcCA/IG9mZnNldC5sZWZ0ICsgdGhpcy5ib3JkZXIgOiAwO1xcbiAgICAgICAgcG9zLnRvcCAtPSBvZmZzZXQudG9wLmNoYXJBdCA/IG9mZnNldC51c2VyIDogdmVydGljYWwgIT09IFNISUZUIHx8IHNoaWZ0LmxlZnQgfHwgIXNoaWZ0LmxlZnQgJiYgIXNoaWZ0LnRvcCA/IG9mZnNldC50b3AgKyB0aGlzLmJvcmRlciA6IDA7IC8vIENhY2hlIGRldGFpbHNcXG5cXG4gICAgICAgIGNhY2hlLmNvcm5lckxlZnQgPSBhZGp1c3QubGVmdDtcXG4gICAgICAgIGNhY2hlLmNvcm5lclRvcCA9IGFkanVzdC50b3A7XFxuICAgICAgICBjYWNoZS5jb3JuZXIgPSBuZXdDb3JuZXIuY2xvbmUoKTtcXG4gICAgICB9LFxcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XFxuICAgICAgICAvLyBVbmJpbmQgZXZlbnRzXFxuICAgICAgICB0aGlzLnF0aXAuX3VuYmluZCh0aGlzLnF0aXAudG9vbHRpcCwgdGhpcy5fbnMpOyAvLyBSZW1vdmUgdGhlIHRpcCBlbGVtZW50KHMpXFxuXFxuXFxuICAgICAgICBpZiAodGhpcy5xdGlwLmVsZW1lbnRzLnRpcCkge1xcbiAgICAgICAgICB0aGlzLnF0aXAuZWxlbWVudHMudGlwLmZpbmQoJyonKS5yZW1vdmUoKS5lbmQoKS5yZW1vdmUoKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH0pO1xcblxcbiAgICBUSVAgPSBQTFVHSU5TLnRpcCA9IGZ1bmN0aW9uIChhcGkpIHtcXG4gICAgICByZXR1cm4gbmV3IFRpcChhcGksIGFwaS5vcHRpb25zLnN0eWxlLnRpcCk7XFxuICAgIH07IC8vIEluaXRpYWxpemUgdGlwIG9uIHJlbmRlclxcblxcblxcbiAgICBUSVAuaW5pdGlhbGl6ZSA9ICdyZW5kZXInOyAvLyBTZXR1cCBwbHVnaW4gc2FuaXRpemF0aW9uIG9wdGlvbnNcXG5cXG4gICAgVElQLnNhbml0aXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcXG4gICAgICBpZiAob3B0aW9ucy5zdHlsZSAmJiAndGlwJyBpbiBvcHRpb25zLnN0eWxlKSB7XFxuICAgICAgICB2YXIgb3B0cyA9IG9wdGlvbnMuc3R5bGUudGlwO1xcblxcbiAgICAgICAgaWYgKF90eXBlb2Yob3B0cykgIT09ICdvYmplY3QnKSB7XFxuICAgICAgICAgIG9wdHMgPSBvcHRpb25zLnN0eWxlLnRpcCA9IHtcXG4gICAgICAgICAgICBjb3JuZXI6IG9wdHNcXG4gICAgICAgICAgfTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICghL3N0cmluZ3xib29sZWFuL2kudGVzdChfdHlwZW9mKG9wdHMuY29ybmVyKSkpIHtcXG4gICAgICAgICAgb3B0cy5jb3JuZXIgPSBUUlVFO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfTsgLy8gQWRkIG5ldyBvcHRpb24gY2hlY2tzIGZvciB0aGUgcGx1Z2luXFxuXFxuXFxuICAgIENIRUNLUy50aXAgPSB7XFxuICAgICAgJ15wb3NpdGlvbi5teXxzdHlsZS50aXAuKGNvcm5lcnxtaW1pY3xib3JkZXIpJCc6IGZ1bmN0aW9uIHBvc2l0aW9uTXlTdHlsZVRpcENvcm5lck1pbWljQm9yZGVyJCgpIHtcXG4gICAgICAgIC8vIE1ha2Ugc3VyZSBhIHRpcCBjYW4gYmUgZHJhd25cXG4gICAgICAgIHRoaXMuY3JlYXRlKCk7IC8vIFJlcG9zaXRpb24gdGhlIHRvb2x0aXBcXG5cXG4gICAgICAgIHRoaXMucXRpcC5yZXBvc2l0aW9uKCk7XFxuICAgICAgfSxcXG4gICAgICAnXnN0eWxlLnRpcC4oaGVpZ2h0fHdpZHRoKSQnOiBmdW5jdGlvbiBzdHlsZVRpcEhlaWdodFdpZHRoJChvYmopIHtcXG4gICAgICAgIC8vIFJlLXNldCBkaW1lbnNpb25zIGFuZCByZWRyYXcgdGhlIHRpcFxcbiAgICAgICAgdGhpcy5zaXplID0gW29iai53aWR0aCwgb2JqLmhlaWdodF07XFxuICAgICAgICB0aGlzLnVwZGF0ZSgpOyAvLyBSZXBvc2l0aW9uIHRoZSB0b29sdGlwXFxuXFxuICAgICAgICB0aGlzLnF0aXAucmVwb3NpdGlvbigpO1xcbiAgICAgIH0sXFxuICAgICAgJ15jb250ZW50LnRpdGxlfHN0eWxlLihjbGFzc2VzfHdpZGdldCkkJzogZnVuY3Rpb24gY29udGVudFRpdGxlU3R5bGVDbGFzc2VzV2lkZ2V0JCgpIHtcXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XFxuICAgICAgfVxcbiAgICB9OyAvLyBFeHRlbmQgb3JpZ2luYWwgcVRpcCBkZWZhdWx0c1xcblxcbiAgICAkLmV4dGVuZChUUlVFLCBRVElQLmRlZmF1bHRzLCB7XFxuICAgICAgc3R5bGU6IHtcXG4gICAgICAgIHRpcDoge1xcbiAgICAgICAgICBjb3JuZXI6IFRSVUUsXFxuICAgICAgICAgIG1pbWljOiBGQUxTRSxcXG4gICAgICAgICAgd2lkdGg6IDYsXFxuICAgICAgICAgIGhlaWdodDogNixcXG4gICAgICAgICAgYm9yZGVyOiBUUlVFLFxcbiAgICAgICAgICBvZmZzZXQ6IDBcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH0pO1xcbiAgICA7XFxuICAgIHZhciBNT0RBTCxcXG4gICAgICAgIE9WRVJMQVksXFxuICAgICAgICBNT0RBTENMQVNTID0gJ3F0aXAtbW9kYWwnLFxcbiAgICAgICAgTU9EQUxTRUxFQ1RPUiA9ICcuJyArIE1PREFMQ0xBU1M7XFxuXFxuICAgIE9WRVJMQVkgPSBmdW5jdGlvbiBPVkVSTEFZKCkge1xcbiAgICAgIHZhciBzZWxmID0gdGhpcyxcXG4gICAgICAgICAgZm9jdXNhYmxlRWxlbXMgPSB7fSxcXG4gICAgICAgICAgY3VycmVudCxcXG4gICAgICAgICAgb25MYXN0LFxcbiAgICAgICAgICBwcmV2U3RhdGUsXFxuICAgICAgICAgIGVsZW07IC8vIE1vZGlmaWVkIGNvZGUgZnJvbSBqUXVlcnkgVUkgMS4xMC4wIHNvdXJjZVxcbiAgICAgIC8vIGh0dHA6Ly9jb2RlLmpxdWVyeS5jb20vdWkvMS4xMC4wL2pxdWVyeS11aS5qc1xcblxcbiAgICAgIGZ1bmN0aW9uIGZvY3VzYWJsZShlbGVtZW50KSB7XFxuICAgICAgICAvLyBVc2UgdGhlIGRlZmluZWQgZm9jdXNhYmxlIGNoZWNrZXIgd2hlbiBwb3NzaWJsZVxcbiAgICAgICAgaWYgKCQuZXhwclsnOiddLmZvY3VzYWJsZSkge1xcbiAgICAgICAgICByZXR1cm4gJC5leHByWyc6J10uZm9jdXNhYmxlO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdmFyIGlzVGFiSW5kZXhOb3ROYU4gPSAhaXNOYU4oJC5hdHRyKGVsZW1lbnQsICd0YWJpbmRleCcpKSxcXG4gICAgICAgICAgICBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWUgJiYgZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxcbiAgICAgICAgICAgIG1hcCxcXG4gICAgICAgICAgICBtYXBOYW1lLFxcbiAgICAgICAgICAgIGltZztcXG5cXG4gICAgICAgIGlmICgnYXJlYScgPT09IG5vZGVOYW1lKSB7XFxuICAgICAgICAgIG1hcCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcXG4gICAgICAgICAgbWFwTmFtZSA9IG1hcC5uYW1lO1xcblxcbiAgICAgICAgICBpZiAoIWVsZW1lbnQuaHJlZiB8fCAhbWFwTmFtZSB8fCBtYXAubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gJ21hcCcpIHtcXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaW1nID0gJCgnaW1nW3VzZW1hcD0jJyArIG1hcE5hbWUgKyAnXScpWzBdO1xcbiAgICAgICAgICByZXR1cm4gISFpbWcgJiYgaW1nLmlzKCc6dmlzaWJsZScpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIC9pbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9ufG9iamVjdC8udGVzdChub2RlTmFtZSkgPyAhZWxlbWVudC5kaXNhYmxlZCA6ICdhJyA9PT0gbm9kZU5hbWUgPyBlbGVtZW50LmhyZWYgfHwgaXNUYWJJbmRleE5vdE5hTiA6IGlzVGFiSW5kZXhOb3ROYU47XFxuICAgICAgfSAvLyBGb2N1cyBpbnB1dHMgdXNpbmcgY2FjaGVkIGZvY3VzYWJsZSBlbGVtZW50cyAoc2VlIHVwZGF0ZSgpKVxcblxcblxcbiAgICAgIGZ1bmN0aW9uIGZvY3VzSW5wdXRzKGJsdXJFbGVtcykge1xcbiAgICAgICAgLy8gQmx1cnJpbmcgYm9keSBlbGVtZW50IGluIElFIGNhdXNlcyB3aW5kb3cub3BlbiB3aW5kb3dzIHRvIHVuZm9jdXMhXFxuICAgICAgICBpZiAoZm9jdXNhYmxlRWxlbXMubGVuZ3RoIDwgMSAmJiBibHVyRWxlbXMubGVuZ3RoKSB7XFxuICAgICAgICAgIGJsdXJFbGVtcy5ub3QoJ2JvZHknKS5ibHVyKCk7XFxuICAgICAgICB9IC8vIEZvY3VzIHRoZSBpbnB1dHNcXG4gICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgIGZvY3VzYWJsZUVsZW1zLmZpcnN0KCkuZm9jdXMoKTtcXG4gICAgICAgICAgfVxcbiAgICAgIH0gLy8gU3RlYWwgZm9jdXMgZnJvbSBlbGVtZW50cyBvdXRzaWRlIHRvb2x0aXBcXG5cXG5cXG4gICAgICBmdW5jdGlvbiBzdGVhbEZvY3VzKGV2ZW50KSB7XFxuICAgICAgICBpZiAoIWVsZW0uaXMoJzp2aXNpYmxlJykpIHtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdmFyIHRhcmdldCA9ICQoZXZlbnQudGFyZ2V0KSxcXG4gICAgICAgICAgICB0b29sdGlwID0gY3VycmVudC50b29sdGlwLFxcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IHRhcmdldC5jbG9zZXN0KFNFTEVDVE9SKSxcXG4gICAgICAgICAgICB0YXJnZXRPblRvcDsgLy8gRGV0ZXJtaW5lIGlmIGlucHV0IGNvbnRhaW5lciB0YXJnZXQgaXMgYWJvdmUgdGhpc1xcblxcbiAgICAgICAgdGFyZ2V0T25Ub3AgPSBjb250YWluZXIubGVuZ3RoIDwgMSA/IEZBTFNFIDogcGFyc2VJbnQoY29udGFpbmVyWzBdLnN0eWxlLnpJbmRleCwgMTApID4gcGFyc2VJbnQodG9vbHRpcFswXS5zdHlsZS56SW5kZXgsIDEwKTsgLy8gSWYgd2UncmUgc2hvd2luZyBhIG1vZGFsLCBidXQgZm9jdXMgaGFzIGxhbmRlZCBvbiBhbiBpbnB1dCBiZWxvd1xcbiAgICAgICAgLy8gdGhpcyBtb2RhbCwgZGl2ZXJ0IGZvY3VzIHRvIHRoZSBmaXJzdCB2aXNpYmxlIGlucHV0IGluIHRoaXMgbW9kYWxcXG4gICAgICAgIC8vIG9yIGlmIHdlIGNhbid0IGZpbmQgb25lLi4uIHRoZSB0b29sdGlwIGl0c2VsZlxcblxcbiAgICAgICAgaWYgKCF0YXJnZXRPblRvcCAmJiB0YXJnZXQuY2xvc2VzdChTRUxFQ1RPUilbMF0gIT09IHRvb2x0aXBbMF0pIHtcXG4gICAgICAgICAgZm9jdXNJbnB1dHModGFyZ2V0KTtcXG4gICAgICAgIH0gLy8gRGV0ZWN0IHdoZW4gd2UgbGVhdmUgdGhlIGxhc3QgZm9jdXNhYmxlIGVsZW1lbnQuLi5cXG5cXG5cXG4gICAgICAgIG9uTGFzdCA9IGV2ZW50LnRhcmdldCA9PT0gZm9jdXNhYmxlRWxlbXNbZm9jdXNhYmxlRWxlbXMubGVuZ3RoIC0gMV07XFxuICAgICAgfVxcblxcbiAgICAgICQuZXh0ZW5kKHNlbGYsIHtcXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uIGluaXQoKSB7XFxuICAgICAgICAgIC8vIENyZWF0ZSBkb2N1bWVudCBvdmVybGF5XFxuICAgICAgICAgIGVsZW0gPSBzZWxmLmVsZW0gPSAkKCc8ZGl2IC8+Jywge1xcbiAgICAgICAgICAgIGlkOiAncXRpcC1vdmVybGF5JyxcXG4gICAgICAgICAgICBodG1sOiAnPGRpdj48L2Rpdj4nLFxcbiAgICAgICAgICAgIG1vdXNlZG93bjogZnVuY3Rpb24gbW91c2Vkb3duKCkge1xcbiAgICAgICAgICAgICAgcmV0dXJuIEZBTFNFO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSkuaGlkZSgpOyAvLyBNYWtlIHN1cmUgd2UgY2FuJ3QgZm9jdXMgYW55dGhpbmcgb3V0c2lkZSB0aGUgdG9vbHRpcFxcblxcbiAgICAgICAgICAkKGRvY3VtZW50LmJvZHkpLmJpbmQoJ2ZvY3VzaW4nICsgTU9EQUxTRUxFQ1RPUiwgc3RlYWxGb2N1cyk7IC8vIEFwcGx5IGtleWJvYXJkIFxcXCJFc2NhcGUga2V5XFxcIiBjbG9zZSBoYW5kbGVyXFxuXFxuICAgICAgICAgICQoZG9jdW1lbnQpLmJpbmQoJ2tleWRvd24nICsgTU9EQUxTRUxFQ1RPUiwgZnVuY3Rpb24gKGV2ZW50KSB7XFxuICAgICAgICAgICAgaWYgKGN1cnJlbnQgJiYgY3VycmVudC5vcHRpb25zLnNob3cubW9kYWwuZXNjYXBlICYmIGV2ZW50LmtleUNvZGUgPT09IDI3KSB7XFxuICAgICAgICAgICAgICBjdXJyZW50LmhpZGUoZXZlbnQpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSk7IC8vIEFwcGx5IGNsaWNrIGhhbmRsZXIgZm9yIGJsdXIgb3B0aW9uXFxuXFxuICAgICAgICAgIGVsZW0uYmluZCgnY2xpY2snICsgTU9EQUxTRUxFQ1RPUiwgZnVuY3Rpb24gKGV2ZW50KSB7XFxuICAgICAgICAgICAgaWYgKGN1cnJlbnQgJiYgY3VycmVudC5vcHRpb25zLnNob3cubW9kYWwuYmx1cikge1xcbiAgICAgICAgICAgICAgY3VycmVudC5oaWRlKGV2ZW50KTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgICByZXR1cm4gc2VsZjtcXG4gICAgICAgIH0sXFxuICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShhcGkpIHtcXG4gICAgICAgICAgLy8gVXBkYXRlIGN1cnJlbnQgQVBJIHJlZmVyZW5jZVxcbiAgICAgICAgICBjdXJyZW50ID0gYXBpOyAvLyBVcGRhdGUgZm9jdXNhYmxlIGVsZW1lbnRzIGlmIGVuYWJsZWRcXG5cXG4gICAgICAgICAgaWYgKGFwaS5vcHRpb25zLnNob3cubW9kYWwuc3RlYWxmb2N1cyAhPT0gRkFMU0UpIHtcXG4gICAgICAgICAgICBmb2N1c2FibGVFbGVtcyA9IGFwaS50b29sdGlwLmZpbmQoJyonKS5maWx0ZXIoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgcmV0dXJuIGZvY3VzYWJsZSh0aGlzKTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBmb2N1c2FibGVFbGVtcyA9IFtdO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgdG9nZ2xlOiBmdW5jdGlvbiB0b2dnbGUoYXBpLCBzdGF0ZSwgZHVyYXRpb24pIHtcXG4gICAgICAgICAgdmFyIGRvY0JvZHkgPSAkKGRvY3VtZW50LmJvZHkpLFxcbiAgICAgICAgICAgICAgdG9vbHRpcCA9IGFwaS50b29sdGlwLFxcbiAgICAgICAgICAgICAgb3B0aW9ucyA9IGFwaS5vcHRpb25zLnNob3cubW9kYWwsXFxuICAgICAgICAgICAgICBlZmZlY3QgPSBvcHRpb25zLmVmZmVjdCxcXG4gICAgICAgICAgICAgIHR5cGUgPSBzdGF0ZSA/ICdzaG93JyA6ICdoaWRlJyxcXG4gICAgICAgICAgICAgIHZpc2libGUgPSBlbGVtLmlzKCc6dmlzaWJsZScpLFxcbiAgICAgICAgICAgICAgdmlzaWJsZU1vZGFscyA9ICQoTU9EQUxTRUxFQ1RPUikuZmlsdGVyKCc6dmlzaWJsZTpub3QoOmFuaW1hdGVkKScpLm5vdCh0b29sdGlwKSxcXG4gICAgICAgICAgICAgIHppbmRleDsgLy8gU2V0IGFjdGl2ZSB0b29sdGlwIEFQSSByZWZlcmVuY2VcXG5cXG4gICAgICAgICAgc2VsZi51cGRhdGUoYXBpKTsgLy8gSWYgdGhlIG1vZGFsIGNhbiBzdGVhbCB0aGUgZm9jdXMuLi5cXG4gICAgICAgICAgLy8gQmx1ciB0aGUgY3VycmVudCBpdGVtIGFuZCBmb2N1cyBhbnl0aGluZyBpbiB0aGUgbW9kYWwgd2UgYW5cXG5cXG4gICAgICAgICAgaWYgKHN0YXRlICYmIG9wdGlvbnMuc3RlYWxmb2N1cyAhPT0gRkFMU0UpIHtcXG4gICAgICAgICAgICBmb2N1c0lucHV0cygkKCc6Zm9jdXMnKSk7XFxuICAgICAgICAgIH0gLy8gVG9nZ2xlIGJhY2tkcm9wIGN1cnNvciBzdHlsZSBvbiBzaG93XFxuXFxuXFxuICAgICAgICAgIGVsZW0udG9nZ2xlQ2xhc3MoJ2JsdXJzJywgb3B0aW9ucy5ibHVyKTsgLy8gQXBwZW5kIHRvIGJvZHkgb24gc2hvd1xcblxcbiAgICAgICAgICBpZiAoc3RhdGUpIHtcXG4gICAgICAgICAgICBlbGVtLmFwcGVuZFRvKGRvY3VtZW50LmJvZHkpO1xcbiAgICAgICAgICB9IC8vIFByZXZlbnQgbW9kYWwgZnJvbSBjb25mbGljdGluZyB3aXRoIHNob3cuc29sbywgYW5kIGRvbid0IGhpZGUgYmFja2Ryb3AgaXMgb3RoZXIgbW9kYWxzIGFyZSB2aXNpYmxlXFxuXFxuXFxuICAgICAgICAgIGlmIChlbGVtLmlzKCc6YW5pbWF0ZWQnKSAmJiB2aXNpYmxlID09PSBzdGF0ZSAmJiBwcmV2U3RhdGUgIT09IEZBTFNFIHx8ICFzdGF0ZSAmJiB2aXNpYmxlTW9kYWxzLmxlbmd0aCkge1xcbiAgICAgICAgICAgIHJldHVybiBzZWxmO1xcbiAgICAgICAgICB9IC8vIFN0b3AgYWxsIGFuaW1hdGlvbnNcXG5cXG5cXG4gICAgICAgICAgZWxlbS5zdG9wKFRSVUUsIEZBTFNFKTsgLy8gVXNlIGN1c3RvbSBmdW5jdGlvbiBpZiBwcm92aWRlZFxcblxcbiAgICAgICAgICBpZiAoJC5pc0Z1bmN0aW9uKGVmZmVjdCkpIHtcXG4gICAgICAgICAgICBlZmZlY3QuY2FsbChlbGVtLCBzdGF0ZSk7XFxuICAgICAgICAgIH0gLy8gSWYgbm8gZWZmZWN0IHR5cGUgaXMgc3VwcGxpZWQsIHVzZSBhIHNpbXBsZSB0b2dnbGVcXG4gICAgICAgICAgZWxzZSBpZiAoZWZmZWN0ID09PSBGQUxTRSkge1xcbiAgICAgICAgICAgICAgZWxlbVt0eXBlXSgpO1xcbiAgICAgICAgICAgIH0gLy8gVXNlIGJhc2ljIGZhZGUgZnVuY3Rpb25cXG4gICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgICAgZWxlbS5mYWRlVG8ocGFyc2VJbnQoZHVyYXRpb24sIDEwKSB8fCA5MCwgc3RhdGUgPyAxIDogMCwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICAgIGlmICghc3RhdGUpIHtcXG4gICAgICAgICAgICAgICAgICAgIGVsZW0uaGlkZSgpO1xcbiAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICB9IC8vIFJlc2V0IHBvc2l0aW9uIGFuZCBkZXRhY2ggZnJvbSBib2R5IG9uIGhpZGVcXG5cXG5cXG4gICAgICAgICAgaWYgKCFzdGF0ZSkge1xcbiAgICAgICAgICAgIGVsZW0ucXVldWUoZnVuY3Rpb24gKG5leHQpIHtcXG4gICAgICAgICAgICAgIGVsZW0uY3NzKHtcXG4gICAgICAgICAgICAgICAgbGVmdDogJycsXFxuICAgICAgICAgICAgICAgIHRvcDogJydcXG4gICAgICAgICAgICAgIH0pO1xcblxcbiAgICAgICAgICAgICAgaWYgKCEkKE1PREFMU0VMRUNUT1IpLmxlbmd0aCkge1xcbiAgICAgICAgICAgICAgICBlbGVtLmRldGFjaCgpO1xcbiAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgbmV4dCgpO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICB9IC8vIENhY2hlIHRoZSBzdGF0ZVxcblxcblxcbiAgICAgICAgICBwcmV2U3RhdGUgPSBzdGF0ZTsgLy8gSWYgdGhlIHRvb2x0aXAgaXMgZGVzdHJveWVkLCBzZXQgcmVmZXJlbmNlIHRvIG51bGxcXG5cXG4gICAgICAgICAgaWYgKGN1cnJlbnQuZGVzdHJveWVkKSB7XFxuICAgICAgICAgICAgY3VycmVudCA9IE5VTEw7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgcmV0dXJuIHNlbGY7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgICAgc2VsZi5pbml0KCk7XFxuICAgIH07XFxuXFxuICAgIE9WRVJMQVkgPSBuZXcgT1ZFUkxBWSgpO1xcblxcbiAgICBmdW5jdGlvbiBNb2RhbChhcGksIG9wdGlvbnMpIHtcXG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xcbiAgICAgIHRoaXMuX25zID0gJy1tb2RhbCc7XFxuICAgICAgdGhpcy5pbml0KHRoaXMucXRpcCA9IGFwaSk7XFxuICAgIH1cXG5cXG4gICAgJC5leHRlbmQoTW9kYWwucHJvdG90eXBlLCB7XFxuICAgICAgaW5pdDogZnVuY3Rpb24gaW5pdChxdGlwKSB7XFxuICAgICAgICB2YXIgdG9vbHRpcCA9IHF0aXAudG9vbHRpcDsgLy8gSWYgbW9kYWwgaXMgZGlzYWJsZWQuLi4gcmV0dXJuXFxuXFxuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5vbikge1xcbiAgICAgICAgICByZXR1cm4gdGhpcztcXG4gICAgICAgIH0gLy8gU2V0IG92ZXJsYXkgcmVmZXJlbmNlXFxuXFxuXFxuICAgICAgICBxdGlwLmVsZW1lbnRzLm92ZXJsYXkgPSBPVkVSTEFZLmVsZW07IC8vIEFkZCB1bmlxdWUgYXR0cmlidXRlIHNvIHdlIGNhbiBncmFiIG1vZGFsIHRvb2x0aXBzIGVhc2lseSB2aWEgYSBTRUxFQ1RPUiwgYW5kIHNldCB6LWluZGV4XFxuXFxuICAgICAgICB0b29sdGlwLmFkZENsYXNzKE1PREFMQ0xBU1MpLmNzcygnei1pbmRleCcsIFFUSVAubW9kYWxfemluZGV4ICsgJChNT0RBTFNFTEVDVE9SKS5sZW5ndGgpOyAvLyBBcHBseSBvdXIgc2hvdy9oaWRlL2ZvY3VzIG1vZGFsIGV2ZW50c1xcblxcbiAgICAgICAgcXRpcC5fYmluZCh0b29sdGlwLCBbJ3Rvb2x0aXBzaG93JywgJ3Rvb2x0aXBoaWRlJ10sIGZ1bmN0aW9uIChldmVudCwgYXBpLCBkdXJhdGlvbikge1xcbiAgICAgICAgICB2YXIgb0V2ZW50ID0gZXZlbnQub3JpZ2luYWxFdmVudDsgLy8gTWFrZSBzdXJlIG1vdXNlb3V0IGRvZXNuJ3QgdHJpZ2dlciBhIGhpZGUgd2hlbiBzaG93aW5nIHRoZSBtb2RhbCBhbmQgbW91c2luZyBvbnRvIGJhY2tkcm9wXFxuXFxuICAgICAgICAgIGlmIChldmVudC50YXJnZXQgPT09IHRvb2x0aXBbMF0pIHtcXG4gICAgICAgICAgICBpZiAob0V2ZW50ICYmIGV2ZW50LnR5cGUgPT09ICd0b29sdGlwaGlkZScgJiYgL21vdXNlKGxlYXZlfGVudGVyKS8udGVzdChvRXZlbnQudHlwZSkgJiYgJChvRXZlbnQucmVsYXRlZFRhcmdldCkuY2xvc2VzdChPVkVSTEFZLmVsZW1bMF0pLmxlbmd0aCkge1xcbiAgICAgICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XFxuICAgICAgICAgICAgfSBlbHNlIGlmICghb0V2ZW50IHx8IG9FdmVudCAmJiBvRXZlbnQudHlwZSAhPT0gJ3Rvb2x0aXBzb2xvJykge1xcbiAgICAgICAgICAgICAgdGhpcy50b2dnbGUoZXZlbnQsIGV2ZW50LnR5cGUgPT09ICd0b29sdGlwc2hvdycsIGR1cmF0aW9uKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0sIHRoaXMuX25zLCB0aGlzKTsgLy8gQWRqdXN0IG1vZGFsIHotaW5kZXggb24gdG9vbHRpcCBmb2N1c1xcblxcblxcbiAgICAgICAgcXRpcC5fYmluZCh0b29sdGlwLCAndG9vbHRpcGZvY3VzJywgZnVuY3Rpb24gKGV2ZW50LCBhcGkpIHtcXG4gICAgICAgICAgLy8gSWYgZm9jdXMgd2FzIGNhbmNlbGxlZCBiZWZvcmUgaXQgcmVhY2hlZCB1cywgZG9uJ3QgZG8gYW55dGhpbmdcXG4gICAgICAgICAgaWYgKGV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpIHx8IGV2ZW50LnRhcmdldCAhPT0gdG9vbHRpcFswXSkge1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICB2YXIgcXRpcHMgPSAkKE1PREFMU0VMRUNUT1IpLFxcbiAgICAgICAgICAgICAgLy8gS2VlcCB0aGUgbW9kYWwncyBsb3dlciB0aGFuIG90aGVyLCByZWd1bGFyIHF0aXBzXFxuICAgICAgICAgIG5ld0luZGV4ID0gUVRJUC5tb2RhbF96aW5kZXggKyBxdGlwcy5sZW5ndGgsXFxuICAgICAgICAgICAgICBjdXJJbmRleCA9IHBhcnNlSW50KHRvb2x0aXBbMF0uc3R5bGUuekluZGV4LCAxMCk7IC8vIFNldCBvdmVybGF5IHotaW5kZXhcXG5cXG4gICAgICAgICAgT1ZFUkxBWS5lbGVtWzBdLnN0eWxlLnpJbmRleCA9IG5ld0luZGV4IC0gMTsgLy8gUmVkdWNlIG1vZGFsIHotaW5kZXgncyBhbmQga2VlcCB0aGVtIHByb3Blcmx5IG9yZGVyZWRcXG5cXG4gICAgICAgICAgcXRpcHMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgaWYgKHRoaXMuc3R5bGUuekluZGV4ID4gY3VySW5kZXgpIHtcXG4gICAgICAgICAgICAgIHRoaXMuc3R5bGUuekluZGV4IC09IDE7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9KTsgLy8gRmlyZSBibHVyIGV2ZW50IGZvciBmb2N1c2VkIHRvb2x0aXBcXG5cXG4gICAgICAgICAgcXRpcHMuZmlsdGVyKCcuJyArIENMQVNTX0ZPQ1VTKS5xdGlwKCdibHVyJywgZXZlbnQub3JpZ2luYWxFdmVudCk7IC8vIFNldCB0aGUgbmV3IHotaW5kZXhcXG5cXG4gICAgICAgICAgdG9vbHRpcC5hZGRDbGFzcyhDTEFTU19GT0NVUylbMF0uc3R5bGUuekluZGV4ID0gbmV3SW5kZXg7IC8vIFNldCBjdXJyZW50XFxuXFxuICAgICAgICAgIE9WRVJMQVkudXBkYXRlKGFwaSk7IC8vIFByZXZlbnQgZGVmYXVsdCBoYW5kbGluZ1xcblxcbiAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XFxuICAgICAgICB9LCB0aGlzLl9ucywgdGhpcyk7IC8vIEZvY3VzIGFueSBvdGhlciB2aXNpYmxlIG1vZGFscyB3aGVuIHRoaXMgb25lIGhpZGVzXFxuXFxuXFxuICAgICAgICBxdGlwLl9iaW5kKHRvb2x0aXAsICd0b29sdGlwaGlkZScsIGZ1bmN0aW9uIChldmVudCkge1xcbiAgICAgICAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSB0b29sdGlwWzBdKSB7XFxuICAgICAgICAgICAgJChNT0RBTFNFTEVDVE9SKS5maWx0ZXIoJzp2aXNpYmxlJykubm90KHRvb2x0aXApLmxhc3QoKS5xdGlwKCdmb2N1cycsIGV2ZW50KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSwgdGhpcy5fbnMsIHRoaXMpO1xcbiAgICAgIH0sXFxuICAgICAgdG9nZ2xlOiBmdW5jdGlvbiB0b2dnbGUoZXZlbnQsIHN0YXRlLCBkdXJhdGlvbikge1xcbiAgICAgICAgLy8gTWFrZSBzdXJlIGRlZmF1bHQgZXZlbnQgaGFzbid0IGJlZW4gcHJldmVudGVkXFxuICAgICAgICBpZiAoZXZlbnQgJiYgZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XFxuICAgICAgICB9IC8vIFRvZ2dsZSBpdFxcblxcblxcbiAgICAgICAgT1ZFUkxBWS50b2dnbGUodGhpcy5xdGlwLCAhIXN0YXRlLCBkdXJhdGlvbik7XFxuICAgICAgfSxcXG4gICAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xcbiAgICAgICAgLy8gUmVtb3ZlIG1vZGFsIGNsYXNzXFxuICAgICAgICB0aGlzLnF0aXAudG9vbHRpcC5yZW1vdmVDbGFzcyhNT0RBTENMQVNTKTsgLy8gUmVtb3ZlIGJvdW5kIGV2ZW50c1xcblxcbiAgICAgICAgdGhpcy5xdGlwLl91bmJpbmQodGhpcy5xdGlwLnRvb2x0aXAsIHRoaXMuX25zKTsgLy8gRGVsZXRlIGVsZW1lbnQgcmVmZXJlbmNlXFxuXFxuXFxuICAgICAgICBPVkVSTEFZLnRvZ2dsZSh0aGlzLnF0aXAsIEZBTFNFKTtcXG4gICAgICAgIGRlbGV0ZSB0aGlzLnF0aXAuZWxlbWVudHMub3ZlcmxheTtcXG4gICAgICB9XFxuICAgIH0pO1xcblxcbiAgICBNT0RBTCA9IFBMVUdJTlMubW9kYWwgPSBmdW5jdGlvbiAoYXBpKSB7XFxuICAgICAgcmV0dXJuIG5ldyBNb2RhbChhcGksIGFwaS5vcHRpb25zLnNob3cubW9kYWwpO1xcbiAgICB9OyAvLyBTZXR1cCBzYW5pdGl6dGlvbiBydWxlc1xcblxcblxcbiAgICBNT0RBTC5zYW5pdGl6ZSA9IGZ1bmN0aW9uIChvcHRzKSB7XFxuICAgICAgaWYgKG9wdHMuc2hvdykge1xcbiAgICAgICAgaWYgKF90eXBlb2Yob3B0cy5zaG93Lm1vZGFsKSAhPT0gJ29iamVjdCcpIHtcXG4gICAgICAgICAgb3B0cy5zaG93Lm1vZGFsID0ge1xcbiAgICAgICAgICAgIG9uOiAhIW9wdHMuc2hvdy5tb2RhbFxcbiAgICAgICAgICB9O1xcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0cy5zaG93Lm1vZGFsLm9uID09PSAndW5kZWZpbmVkJykge1xcbiAgICAgICAgICBvcHRzLnNob3cubW9kYWwub24gPSBUUlVFO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfTsgLy8gQmFzZSB6LWluZGV4IGZvciBhbGwgbW9kYWwgdG9vbHRpcHMgKHVzZSBxVGlwIGNvcmUgei1pbmRleCBhcyBhIGJhc2UpXFxuXFxuXFxuICAgIFFUSVAubW9kYWxfemluZGV4ID0gUVRJUC56aW5kZXggLSAyMDA7IC8vIFBsdWdpbiBuZWVkcyB0byBiZSBpbml0aWFsaXplZCBvbiByZW5kZXJcXG5cXG4gICAgTU9EQUwuaW5pdGlhbGl6ZSA9ICdyZW5kZXInOyAvLyBTZXR1cCBvcHRpb24gc2V0IGNoZWNrc1xcblxcbiAgICBDSEVDS1MubW9kYWwgPSB7XFxuICAgICAgJ15zaG93Lm1vZGFsLihvbnxibHVyKSQnOiBmdW5jdGlvbiBzaG93TW9kYWxPbkJsdXIkKCkge1xcbiAgICAgICAgLy8gSW5pdGlhbGlzZVxcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XFxuICAgICAgICB0aGlzLmluaXQoKTsgLy8gU2hvdyB0aGUgbW9kYWwgaWYgbm90IHZpc2libGUgYWxyZWFkeSBhbmQgdG9vbHRpcCBpcyB2aXNpYmxlXFxuXFxuICAgICAgICB0aGlzLnF0aXAuZWxlbXMub3ZlcmxheS50b2dnbGUodGhpcy5xdGlwLnRvb2x0aXBbMF0ub2Zmc2V0V2lkdGggPiAwKTtcXG4gICAgICB9XFxuICAgIH07IC8vIEV4dGVuZCBvcmlnaW5hbCBhcGkgZGVmYXVsdHNcXG5cXG4gICAgJC5leHRlbmQoVFJVRSwgUVRJUC5kZWZhdWx0cywge1xcbiAgICAgIHNob3c6IHtcXG4gICAgICAgIG1vZGFsOiB7XFxuICAgICAgICAgIG9uOiBGQUxTRSxcXG4gICAgICAgICAgZWZmZWN0OiBUUlVFLFxcbiAgICAgICAgICBibHVyOiBUUlVFLFxcbiAgICAgICAgICBzdGVhbGZvY3VzOiBUUlVFLFxcbiAgICAgICAgICBlc2NhcGU6IFRSVUVcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH0pO1xcbiAgICA7XFxuXFxuICAgIFBMVUdJTlMudmlld3BvcnQgPSBmdW5jdGlvbiAoYXBpLCBwb3NpdGlvbiwgcG9zT3B0aW9ucywgdGFyZ2V0V2lkdGgsIHRhcmdldEhlaWdodCwgZWxlbVdpZHRoLCBlbGVtSGVpZ2h0KSB7XFxuICAgICAgdmFyIHRhcmdldCA9IHBvc09wdGlvbnMudGFyZ2V0LFxcbiAgICAgICAgICB0b29sdGlwID0gYXBpLmVsZW1lbnRzLnRvb2x0aXAsXFxuICAgICAgICAgIG15ID0gcG9zT3B0aW9ucy5teSxcXG4gICAgICAgICAgYXQgPSBwb3NPcHRpb25zLmF0LFxcbiAgICAgICAgICBhZGp1c3QgPSBwb3NPcHRpb25zLmFkanVzdCxcXG4gICAgICAgICAgbWV0aG9kID0gYWRqdXN0Lm1ldGhvZC5zcGxpdCgnICcpLFxcbiAgICAgICAgICBtZXRob2RYID0gbWV0aG9kWzBdLFxcbiAgICAgICAgICBtZXRob2RZID0gbWV0aG9kWzFdIHx8IG1ldGhvZFswXSxcXG4gICAgICAgICAgdmlld3BvcnQgPSBwb3NPcHRpb25zLnZpZXdwb3J0LFxcbiAgICAgICAgICBjb250YWluZXIgPSBwb3NPcHRpb25zLmNvbnRhaW5lcixcXG4gICAgICAgICAgY2FjaGUgPSBhcGkuY2FjaGUsXFxuICAgICAgICAgIGFkanVzdGVkID0ge1xcbiAgICAgICAgbGVmdDogMCxcXG4gICAgICAgIHRvcDogMFxcbiAgICAgIH0sXFxuICAgICAgICAgIGZpeGVkLFxcbiAgICAgICAgICBuZXdNeSxcXG4gICAgICAgICAgY29udGFpbmVyT2Zmc2V0LFxcbiAgICAgICAgICBjb250YWluZXJTdGF0aWMsXFxuICAgICAgICAgIHZpZXdwb3J0V2lkdGgsXFxuICAgICAgICAgIHZpZXdwb3J0SGVpZ2h0LFxcbiAgICAgICAgICB2aWV3cG9ydFNjcm9sbCxcXG4gICAgICAgICAgdmlld3BvcnRPZmZzZXQ7IC8vIElmIHZpZXdwb3J0IGlzIG5vdCBhIGpRdWVyeSBlbGVtZW50LCBvciBpdCdzIHRoZSB3aW5kb3cvZG9jdW1lbnQsIG9yIG5vIGFkanVzdG1lbnQgbWV0aG9kIGlzIHVzZWQuLi4gcmV0dXJuXFxuXFxuICAgICAgaWYgKCF2aWV3cG9ydC5qcXVlcnkgfHwgdGFyZ2V0WzBdID09PSB3aW5kb3cgfHwgdGFyZ2V0WzBdID09PSBkb2N1bWVudC5ib2R5IHx8IGFkanVzdC5tZXRob2QgPT09ICdub25lJykge1xcbiAgICAgICAgcmV0dXJuIGFkanVzdGVkO1xcbiAgICAgIH0gLy8gQ2FjaCBjb250YWluZXIgZGV0YWlsc1xcblxcblxcbiAgICAgIGNvbnRhaW5lck9mZnNldCA9IGNvbnRhaW5lci5vZmZzZXQoKSB8fCBhZGp1c3RlZDtcXG4gICAgICBjb250YWluZXJTdGF0aWMgPSBjb250YWluZXIuY3NzKCdwb3NpdGlvbicpID09PSAnc3RhdGljJzsgLy8gQ2FjaGUgb3VyIHZpZXdwb3J0IGRldGFpbHNcXG5cXG4gICAgICBmaXhlZCA9IHRvb2x0aXAuY3NzKCdwb3NpdGlvbicpID09PSAnZml4ZWQnO1xcbiAgICAgIHZpZXdwb3J0V2lkdGggPSB2aWV3cG9ydFswXSA9PT0gd2luZG93ID8gdmlld3BvcnQud2lkdGgoKSA6IHZpZXdwb3J0Lm91dGVyV2lkdGgoRkFMU0UpO1xcbiAgICAgIHZpZXdwb3J0SGVpZ2h0ID0gdmlld3BvcnRbMF0gPT09IHdpbmRvdyA/IHZpZXdwb3J0LmhlaWdodCgpIDogdmlld3BvcnQub3V0ZXJIZWlnaHQoRkFMU0UpO1xcbiAgICAgIHZpZXdwb3J0U2Nyb2xsID0ge1xcbiAgICAgICAgbGVmdDogZml4ZWQgPyAwIDogdmlld3BvcnQuc2Nyb2xsTGVmdCgpLFxcbiAgICAgICAgdG9wOiBmaXhlZCA/IDAgOiB2aWV3cG9ydC5zY3JvbGxUb3AoKVxcbiAgICAgIH07XFxuICAgICAgdmlld3BvcnRPZmZzZXQgPSB2aWV3cG9ydC5vZmZzZXQoKSB8fCBhZGp1c3RlZDsgLy8gR2VuZXJpYyBjYWxjdWxhdGlvbiBtZXRob2RcXG5cXG4gICAgICBmdW5jdGlvbiBjYWxjdWxhdGUoc2lkZSwgb3RoZXJTaWRlLCB0eXBlLCBhZGp1c3QsIHNpZGUxLCBzaWRlMiwgbGVuZ3RoTmFtZSwgdGFyZ2V0TGVuZ3RoLCBlbGVtTGVuZ3RoKSB7XFxuICAgICAgICB2YXIgaW5pdGlhbFBvcyA9IHBvc2l0aW9uW3NpZGUxXSxcXG4gICAgICAgICAgICBteVNpZGUgPSBteVtzaWRlXSxcXG4gICAgICAgICAgICBhdFNpZGUgPSBhdFtzaWRlXSxcXG4gICAgICAgICAgICBpc1NoaWZ0ID0gdHlwZSA9PT0gU0hJRlQsXFxuICAgICAgICAgICAgbXlMZW5ndGggPSBteVNpZGUgPT09IHNpZGUxID8gZWxlbUxlbmd0aCA6IG15U2lkZSA9PT0gc2lkZTIgPyAtZWxlbUxlbmd0aCA6IC1lbGVtTGVuZ3RoIC8gMixcXG4gICAgICAgICAgICBhdExlbmd0aCA9IGF0U2lkZSA9PT0gc2lkZTEgPyB0YXJnZXRMZW5ndGggOiBhdFNpZGUgPT09IHNpZGUyID8gLXRhcmdldExlbmd0aCA6IC10YXJnZXRMZW5ndGggLyAyLFxcbiAgICAgICAgICAgIHNpZGVPZmZzZXQgPSB2aWV3cG9ydFNjcm9sbFtzaWRlMV0gKyB2aWV3cG9ydE9mZnNldFtzaWRlMV0gLSAoY29udGFpbmVyU3RhdGljID8gMCA6IGNvbnRhaW5lck9mZnNldFtzaWRlMV0pLFxcbiAgICAgICAgICAgIG92ZXJmbG93MSA9IHNpZGVPZmZzZXQgLSBpbml0aWFsUG9zLFxcbiAgICAgICAgICAgIG92ZXJmbG93MiA9IGluaXRpYWxQb3MgKyBlbGVtTGVuZ3RoIC0gKGxlbmd0aE5hbWUgPT09IFdJRFRIID8gdmlld3BvcnRXaWR0aCA6IHZpZXdwb3J0SGVpZ2h0KSAtIHNpZGVPZmZzZXQsXFxuICAgICAgICAgICAgb2Zmc2V0ID0gbXlMZW5ndGggLSAobXkucHJlY2VkYW5jZSA9PT0gc2lkZSB8fCBteVNpZGUgPT09IG15W290aGVyU2lkZV0gPyBhdExlbmd0aCA6IDApIC0gKGF0U2lkZSA9PT0gQ0VOVEVSID8gdGFyZ2V0TGVuZ3RoIC8gMiA6IDApOyAvLyBzaGlmdFxcblxcbiAgICAgICAgaWYgKGlzU2hpZnQpIHtcXG4gICAgICAgICAgb2Zmc2V0ID0gKG15U2lkZSA9PT0gc2lkZTEgPyAxIDogLTEpICogbXlMZW5ndGg7IC8vIEFkanVzdCBwb3NpdGlvbiBidXQga2VlcCBpdCB3aXRoaW4gdmlld3BvcnQgZGltZW5zaW9uc1xcblxcbiAgICAgICAgICBwb3NpdGlvbltzaWRlMV0gKz0gb3ZlcmZsb3cxID4gMCA/IG92ZXJmbG93MSA6IG92ZXJmbG93MiA+IDAgPyAtb3ZlcmZsb3cyIDogMDtcXG4gICAgICAgICAgcG9zaXRpb25bc2lkZTFdID0gTWF0aC5tYXgoLWNvbnRhaW5lck9mZnNldFtzaWRlMV0gKyB2aWV3cG9ydE9mZnNldFtzaWRlMV0sIGluaXRpYWxQb3MgLSBvZmZzZXQsIE1hdGgubWluKE1hdGgubWF4KC1jb250YWluZXJPZmZzZXRbc2lkZTFdICsgdmlld3BvcnRPZmZzZXRbc2lkZTFdICsgKGxlbmd0aE5hbWUgPT09IFdJRFRIID8gdmlld3BvcnRXaWR0aCA6IHZpZXdwb3J0SGVpZ2h0KSwgaW5pdGlhbFBvcyArIG9mZnNldCksIHBvc2l0aW9uW3NpZGUxXSwgLy8gTWFrZSBzdXJlIHdlIGRvbid0IGFkanVzdCBjb21wbGV0ZSBvZmYgdGhlIGVsZW1lbnQgd2hlbiB1c2luZyAnY2VudGVyJ1xcbiAgICAgICAgICBteVNpZGUgPT09ICdjZW50ZXInID8gaW5pdGlhbFBvcyAtIG15TGVuZ3RoIDogMUU5KSk7XFxuICAgICAgICB9IC8vIGZsaXAvZmxpcGludmVydFxcbiAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgLy8gVXBkYXRlIGFkanVzdG1lbnQgYW1vdW50IGRlcGVuZGluZyBvbiBpZiB1c2luZyBmbGlwaW52ZXJ0IG9yIGZsaXBcXG4gICAgICAgICAgICBhZGp1c3QgKj0gdHlwZSA9PT0gRkxJUElOVkVSVCA/IDIgOiAwOyAvLyBDaGVjayBmb3Igb3ZlcmZsb3cgb24gdGhlIGxlZnQvdG9wXFxuXFxuICAgICAgICAgICAgaWYgKG92ZXJmbG93MSA+IDAgJiYgKG15U2lkZSAhPT0gc2lkZTEgfHwgb3ZlcmZsb3cyID4gMCkpIHtcXG4gICAgICAgICAgICAgIHBvc2l0aW9uW3NpZGUxXSAtPSBvZmZzZXQgKyBhZGp1c3Q7XFxuICAgICAgICAgICAgICBuZXdNeS5pbnZlcnQoc2lkZSwgc2lkZTEpO1xcbiAgICAgICAgICAgIH0gLy8gQ2hlY2sgZm9yIG92ZXJmbG93IG9uIHRoZSBib3R0b20vcmlnaHRcXG4gICAgICAgICAgICBlbHNlIGlmIChvdmVyZmxvdzIgPiAwICYmIChteVNpZGUgIT09IHNpZGUyIHx8IG92ZXJmbG93MSA+IDApKSB7XFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uW3NpZGUxXSAtPSAobXlTaWRlID09PSBDRU5URVIgPyAtb2Zmc2V0IDogb2Zmc2V0KSArIGFkanVzdDtcXG4gICAgICAgICAgICAgICAgbmV3TXkuaW52ZXJ0KHNpZGUsIHNpZGUyKTtcXG4gICAgICAgICAgICAgIH0gLy8gTWFrZSBzdXJlIHdlIGhhdmVuJ3QgbWFkZSB0aGluZ3Mgd29yc2Ugd2l0aCB0aGUgYWRqdXN0bWVudCBhbmQgcmVzZXQgaWYgc29cXG5cXG5cXG4gICAgICAgICAgICBpZiAocG9zaXRpb25bc2lkZTFdIDwgdmlld3BvcnRTY3JvbGwgJiYgLXBvc2l0aW9uW3NpZGUxXSA+IG92ZXJmbG93Mikge1xcbiAgICAgICAgICAgICAgcG9zaXRpb25bc2lkZTFdID0gaW5pdGlhbFBvcztcXG4gICAgICAgICAgICAgIG5ld015ID0gbXkuY2xvbmUoKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiBwb3NpdGlvbltzaWRlMV0gLSBpbml0aWFsUG9zO1xcbiAgICAgIH0gLy8gU2V0IG5ld015IGlmIHVzaW5nIGZsaXAgb3IgZmxpcGludmVydCBtZXRob2RzXFxuXFxuXFxuICAgICAgaWYgKG1ldGhvZFggIT09ICdzaGlmdCcgfHwgbWV0aG9kWSAhPT0gJ3NoaWZ0Jykge1xcbiAgICAgICAgbmV3TXkgPSBteS5jbG9uZSgpO1xcbiAgICAgIH0gLy8gQWRqdXN0IHBvc2l0aW9uIGJhc2VkIG9udmlld3BvcnQgYW5kIGFkanVzdG1lbnQgb3B0aW9uc1xcblxcblxcbiAgICAgIGFkanVzdGVkID0ge1xcbiAgICAgICAgbGVmdDogbWV0aG9kWCAhPT0gJ25vbmUnID8gY2FsY3VsYXRlKFgsIFksIG1ldGhvZFgsIGFkanVzdC54LCBMRUZULCBSSUdIVCwgV0lEVEgsIHRhcmdldFdpZHRoLCBlbGVtV2lkdGgpIDogMCxcXG4gICAgICAgIHRvcDogbWV0aG9kWSAhPT0gJ25vbmUnID8gY2FsY3VsYXRlKFksIFgsIG1ldGhvZFksIGFkanVzdC55LCBUT1AsIEJPVFRPTSwgSEVJR0hULCB0YXJnZXRIZWlnaHQsIGVsZW1IZWlnaHQpIDogMCxcXG4gICAgICAgIG15OiBuZXdNeVxcbiAgICAgIH07XFxuICAgICAgcmV0dXJuIGFkanVzdGVkO1xcbiAgICB9O1xcblxcbiAgICA7XFxuICAgIFBMVUdJTlMucG9seXMgPSB7XFxuICAgICAgLy8gUE9MWSBhcmVhIGNvb3JkaW5hdGUgY2FsY3VsYXRvclxcbiAgICAgIC8vXFx0U3BlY2lhbCB0aGFua3MgdG8gRWQgQ3JhZG9jayBmb3IgaGVscGluZyBvdXQgd2l0aCB0aGlzLlxcbiAgICAgIC8vXFx0VXNlcyBhIGJpbmFyeSBzZWFyY2ggYWxnb3JpdGhtIHRvIGZpbmQgc3VpdGFibGUgY29vcmRpbmF0ZXMuXFxuICAgICAgcG9seWdvbjogZnVuY3Rpb24gcG9seWdvbihiYXNlQ29vcmRzLCBjb3JuZXIpIHtcXG4gICAgICAgIHZhciByZXN1bHQgPSB7XFxuICAgICAgICAgIHdpZHRoOiAwLFxcbiAgICAgICAgICBoZWlnaHQ6IDAsXFxuICAgICAgICAgIHBvc2l0aW9uOiB7XFxuICAgICAgICAgICAgdG9wOiAxZTEwLFxcbiAgICAgICAgICAgIHJpZ2h0OiAwLFxcbiAgICAgICAgICAgIGJvdHRvbTogMCxcXG4gICAgICAgICAgICBsZWZ0OiAxZTEwXFxuICAgICAgICAgIH0sXFxuICAgICAgICAgIGFkanVzdGFibGU6IEZBTFNFXFxuICAgICAgICB9LFxcbiAgICAgICAgICAgIGkgPSAwLFxcbiAgICAgICAgICAgIG5leHQsXFxuICAgICAgICAgICAgY29vcmRzID0gW10sXFxuICAgICAgICAgICAgY29tcGFyZVggPSAxLFxcbiAgICAgICAgICAgIGNvbXBhcmVZID0gMSxcXG4gICAgICAgICAgICByZWFsWCA9IDAsXFxuICAgICAgICAgICAgcmVhbFkgPSAwLFxcbiAgICAgICAgICAgIG5ld1dpZHRoLFxcbiAgICAgICAgICAgIG5ld0hlaWdodDsgLy8gRmlyc3QgcGFzcywgc2FuaXRpemUgY29vcmRzIGFuZCBkZXRlcm1pbmUgb3V0ZXIgZWRnZXNcXG5cXG4gICAgICAgIGkgPSBiYXNlQ29vcmRzLmxlbmd0aDtcXG5cXG4gICAgICAgIHdoaWxlIChpLS0pIHtcXG4gICAgICAgICAgbmV4dCA9IFtwYXJzZUludChiYXNlQ29vcmRzWy0taV0sIDEwKSwgcGFyc2VJbnQoYmFzZUNvb3Jkc1tpICsgMV0sIDEwKV07XFxuXFxuICAgICAgICAgIGlmIChuZXh0WzBdID4gcmVzdWx0LnBvc2l0aW9uLnJpZ2h0KSB7XFxuICAgICAgICAgICAgcmVzdWx0LnBvc2l0aW9uLnJpZ2h0ID0gbmV4dFswXTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAobmV4dFswXSA8IHJlc3VsdC5wb3NpdGlvbi5sZWZ0KSB7XFxuICAgICAgICAgICAgcmVzdWx0LnBvc2l0aW9uLmxlZnQgPSBuZXh0WzBdO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmIChuZXh0WzFdID4gcmVzdWx0LnBvc2l0aW9uLmJvdHRvbSkge1xcbiAgICAgICAgICAgIHJlc3VsdC5wb3NpdGlvbi5ib3R0b20gPSBuZXh0WzFdO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmIChuZXh0WzFdIDwgcmVzdWx0LnBvc2l0aW9uLnRvcCkge1xcbiAgICAgICAgICAgIHJlc3VsdC5wb3NpdGlvbi50b3AgPSBuZXh0WzFdO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGNvb3Jkcy5wdXNoKG5leHQpO1xcbiAgICAgICAgfSAvLyBDYWxjdWxhdGUgaGVpZ2h0IGFuZCB3aWR0aCBmcm9tIG91dGVyIGVkZ2VzXFxuXFxuXFxuICAgICAgICBuZXdXaWR0aCA9IHJlc3VsdC53aWR0aCA9IE1hdGguYWJzKHJlc3VsdC5wb3NpdGlvbi5yaWdodCAtIHJlc3VsdC5wb3NpdGlvbi5sZWZ0KTtcXG4gICAgICAgIG5ld0hlaWdodCA9IHJlc3VsdC5oZWlnaHQgPSBNYXRoLmFicyhyZXN1bHQucG9zaXRpb24uYm90dG9tIC0gcmVzdWx0LnBvc2l0aW9uLnRvcCk7IC8vIElmIGl0J3MgdGhlIGNlbnRlciBjb3JuZXIuLi5cXG5cXG4gICAgICAgIGlmIChjb3JuZXIuYWJicmV2KCkgPT09ICdjJykge1xcbiAgICAgICAgICByZXN1bHQucG9zaXRpb24gPSB7XFxuICAgICAgICAgICAgbGVmdDogcmVzdWx0LnBvc2l0aW9uLmxlZnQgKyByZXN1bHQud2lkdGggLyAyLFxcbiAgICAgICAgICAgIHRvcDogcmVzdWx0LnBvc2l0aW9uLnRvcCArIHJlc3VsdC5oZWlnaHQgLyAyXFxuICAgICAgICAgIH07XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAvLyBTZWNvbmQgcGFzcywgdXNlIGEgYmluYXJ5IHNlYXJjaCBhbGdvcml0aG0gdG8gbG9jYXRlIG1vc3Qgc3VpdGFibGUgY29vcmRpbmF0ZVxcbiAgICAgICAgICB3aGlsZSAobmV3V2lkdGggPiAwICYmIG5ld0hlaWdodCA+IDAgJiYgY29tcGFyZVggPiAwICYmIGNvbXBhcmVZID4gMCkge1xcbiAgICAgICAgICAgIG5ld1dpZHRoID0gTWF0aC5mbG9vcihuZXdXaWR0aCAvIDIpO1xcbiAgICAgICAgICAgIG5ld0hlaWdodCA9IE1hdGguZmxvb3IobmV3SGVpZ2h0IC8gMik7XFxuXFxuICAgICAgICAgICAgaWYgKGNvcm5lci54ID09PSBMRUZUKSB7XFxuICAgICAgICAgICAgICBjb21wYXJlWCA9IG5ld1dpZHRoO1xcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29ybmVyLnggPT09IFJJR0hUKSB7XFxuICAgICAgICAgICAgICBjb21wYXJlWCA9IHJlc3VsdC53aWR0aCAtIG5ld1dpZHRoO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICBjb21wYXJlWCArPSBNYXRoLmZsb29yKG5ld1dpZHRoIC8gMik7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmIChjb3JuZXIueSA9PT0gVE9QKSB7XFxuICAgICAgICAgICAgICBjb21wYXJlWSA9IG5ld0hlaWdodDtcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvcm5lci55ID09PSBCT1RUT00pIHtcXG4gICAgICAgICAgICAgIGNvbXBhcmVZID0gcmVzdWx0LmhlaWdodCAtIG5ld0hlaWdodDtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgY29tcGFyZVkgKz0gTWF0aC5mbG9vcihuZXdIZWlnaHQgLyAyKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaSA9IGNvb3Jkcy5sZW5ndGg7XFxuXFxuICAgICAgICAgICAgd2hpbGUgKGktLSkge1xcbiAgICAgICAgICAgICAgaWYgKGNvb3Jkcy5sZW5ndGggPCAyKSB7XFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgcmVhbFggPSBjb29yZHNbaV1bMF0gLSByZXN1bHQucG9zaXRpb24ubGVmdDtcXG4gICAgICAgICAgICAgIHJlYWxZID0gY29vcmRzW2ldWzFdIC0gcmVzdWx0LnBvc2l0aW9uLnRvcDtcXG5cXG4gICAgICAgICAgICAgIGlmIChjb3JuZXIueCA9PT0gTEVGVCAmJiByZWFsWCA+PSBjb21wYXJlWCB8fCBjb3JuZXIueCA9PT0gUklHSFQgJiYgcmVhbFggPD0gY29tcGFyZVggfHwgY29ybmVyLnggPT09IENFTlRFUiAmJiAocmVhbFggPCBjb21wYXJlWCB8fCByZWFsWCA+IHJlc3VsdC53aWR0aCAtIGNvbXBhcmVYKSB8fCBjb3JuZXIueSA9PT0gVE9QICYmIHJlYWxZID49IGNvbXBhcmVZIHx8IGNvcm5lci55ID09PSBCT1RUT00gJiYgcmVhbFkgPD0gY29tcGFyZVkgfHwgY29ybmVyLnkgPT09IENFTlRFUiAmJiAocmVhbFkgPCBjb21wYXJlWSB8fCByZWFsWSA+IHJlc3VsdC5oZWlnaHQgLSBjb21wYXJlWSkpIHtcXG4gICAgICAgICAgICAgICAgY29vcmRzLnNwbGljZShpLCAxKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgcmVzdWx0LnBvc2l0aW9uID0ge1xcbiAgICAgICAgICAgIGxlZnQ6IGNvb3Jkc1swXVswXSxcXG4gICAgICAgICAgICB0b3A6IGNvb3Jkc1swXVsxXVxcbiAgICAgICAgICB9O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgICB9LFxcbiAgICAgIHJlY3Q6IGZ1bmN0aW9uIHJlY3QoYXgsIGF5LCBieCwgYnkpIHtcXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgIHdpZHRoOiBNYXRoLmFicyhieCAtIGF4KSxcXG4gICAgICAgICAgaGVpZ2h0OiBNYXRoLmFicyhieSAtIGF5KSxcXG4gICAgICAgICAgcG9zaXRpb246IHtcXG4gICAgICAgICAgICBsZWZ0OiBNYXRoLm1pbihheCwgYngpLFxcbiAgICAgICAgICAgIHRvcDogTWF0aC5taW4oYXksIGJ5KVxcbiAgICAgICAgICB9XFxuICAgICAgICB9O1xcbiAgICAgIH0sXFxuICAgICAgX2FuZ2xlczoge1xcbiAgICAgICAgdGM6IDMgLyAyLFxcbiAgICAgICAgdHI6IDcgLyA0LFxcbiAgICAgICAgdGw6IDUgLyA0LFxcbiAgICAgICAgYmM6IDEgLyAyLFxcbiAgICAgICAgYnI6IDEgLyA0LFxcbiAgICAgICAgYmw6IDMgLyA0LFxcbiAgICAgICAgcmM6IDIsXFxuICAgICAgICBsYzogMSxcXG4gICAgICAgIGM6IDBcXG4gICAgICB9LFxcbiAgICAgIGVsbGlwc2U6IGZ1bmN0aW9uIGVsbGlwc2UoY3gsIGN5LCByeCwgcnksIGNvcm5lcikge1xcbiAgICAgICAgdmFyIGMgPSBQTFVHSU5TLnBvbHlzLl9hbmdsZXNbY29ybmVyLmFiYnJldigpXSxcXG4gICAgICAgICAgICByeGMgPSBjID09PSAwID8gMCA6IHJ4ICogTWF0aC5jb3MoYyAqIE1hdGguUEkpLFxcbiAgICAgICAgICAgIHJ5cyA9IHJ5ICogTWF0aC5zaW4oYyAqIE1hdGguUEkpO1xcblxcbiAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgd2lkdGg6IHJ4ICogMiAtIE1hdGguYWJzKHJ4YyksXFxuICAgICAgICAgIGhlaWdodDogcnkgKiAyIC0gTWF0aC5hYnMocnlzKSxcXG4gICAgICAgICAgcG9zaXRpb246IHtcXG4gICAgICAgICAgICBsZWZ0OiBjeCArIHJ4YyxcXG4gICAgICAgICAgICB0b3A6IGN5ICsgcnlzXFxuICAgICAgICAgIH0sXFxuICAgICAgICAgIGFkanVzdGFibGU6IEZBTFNFXFxuICAgICAgICB9O1xcbiAgICAgIH0sXFxuICAgICAgY2lyY2xlOiBmdW5jdGlvbiBjaXJjbGUoY3gsIGN5LCByLCBjb3JuZXIpIHtcXG4gICAgICAgIHJldHVybiBQTFVHSU5TLnBvbHlzLmVsbGlwc2UoY3gsIGN5LCByLCByLCBjb3JuZXIpO1xcbiAgICAgIH1cXG4gICAgfTtcXG4gICAgO1xcblxcbiAgICBQTFVHSU5TLnN2ZyA9IGZ1bmN0aW9uIChhcGksIHN2ZywgY29ybmVyKSB7XFxuICAgICAgdmFyIGRvYyA9ICQoZG9jdW1lbnQpLFxcbiAgICAgICAgICBlbGVtID0gc3ZnWzBdLFxcbiAgICAgICAgICByb290ID0gJChlbGVtLm93bmVyU1ZHRWxlbWVudCksXFxuICAgICAgICAgIG93bmVyRG9jdW1lbnQgPSBlbGVtLm93bmVyRG9jdW1lbnQsXFxuICAgICAgICAgIHN0cm9rZVdpZHRoMiA9IChwYXJzZUludChzdmcuY3NzKCdzdHJva2Utd2lkdGgnKSwgMTApIHx8IDApIC8gMixcXG4gICAgICAgICAgZnJhbWVPZmZzZXQsXFxuICAgICAgICAgIG10eCxcXG4gICAgICAgICAgdHJhbnNmb3JtZWQsXFxuICAgICAgICAgIHZpZXdCb3gsXFxuICAgICAgICAgIGxlbixcXG4gICAgICAgICAgbmV4dCxcXG4gICAgICAgICAgaSxcXG4gICAgICAgICAgcG9pbnRzLFxcbiAgICAgICAgICByZXN1bHQsXFxuICAgICAgICAgIHBvc2l0aW9uLFxcbiAgICAgICAgICBkaW1lbnNpb25zOyAvLyBBc2NlbmQgdGhlIHBhcmVudE5vZGUgY2hhaW4gdW50aWwgd2UgZmluZCBhbiBlbGVtZW50IHdpdGggZ2V0QkJveCgpXFxuXFxuICAgICAgd2hpbGUgKCFlbGVtLmdldEJCb3gpIHtcXG4gICAgICAgIGVsZW0gPSBlbGVtLnBhcmVudE5vZGU7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghZWxlbS5nZXRCQm94IHx8ICFlbGVtLnBhcmVudE5vZGUpIHtcXG4gICAgICAgIHJldHVybiBGQUxTRTtcXG4gICAgICB9IC8vIERldGVybWluZSB3aGljaCBzaGFwZSBjYWxjdWxhdGlvbiB0byB1c2VcXG5cXG5cXG4gICAgICBzd2l0Y2ggKGVsZW0ubm9kZU5hbWUpIHtcXG4gICAgICAgIGNhc2UgJ2VsbGlwc2UnOlxcbiAgICAgICAgY2FzZSAnY2lyY2xlJzpcXG4gICAgICAgICAgcmVzdWx0ID0gUExVR0lOUy5wb2x5cy5lbGxpcHNlKGVsZW0uY3guYmFzZVZhbC52YWx1ZSwgZWxlbS5jeS5iYXNlVmFsLnZhbHVlLCAoZWxlbS5yeCB8fCBlbGVtLnIpLmJhc2VWYWwudmFsdWUgKyBzdHJva2VXaWR0aDIsIChlbGVtLnJ5IHx8IGVsZW0ucikuYmFzZVZhbC52YWx1ZSArIHN0cm9rZVdpZHRoMiwgY29ybmVyKTtcXG4gICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICBjYXNlICdsaW5lJzpcXG4gICAgICAgIGNhc2UgJ3BvbHlnb24nOlxcbiAgICAgICAgY2FzZSAncG9seWxpbmUnOlxcbiAgICAgICAgICAvLyBEZXRlcm1pbmUgcG9pbnRzIG9iamVjdCAobGluZSBoYXMgbm9uZSwgc28gbWltaWMgdXNpbmcgYXJyYXkpXFxuICAgICAgICAgIHBvaW50cyA9IGVsZW0ucG9pbnRzIHx8IFt7XFxuICAgICAgICAgICAgeDogZWxlbS54MS5iYXNlVmFsLnZhbHVlLFxcbiAgICAgICAgICAgIHk6IGVsZW0ueTEuYmFzZVZhbC52YWx1ZVxcbiAgICAgICAgICB9LCB7XFxuICAgICAgICAgICAgeDogZWxlbS54Mi5iYXNlVmFsLnZhbHVlLFxcbiAgICAgICAgICAgIHk6IGVsZW0ueTIuYmFzZVZhbC52YWx1ZVxcbiAgICAgICAgICB9XTtcXG5cXG4gICAgICAgICAgZm9yIChyZXN1bHQgPSBbXSwgaSA9IC0xLCBsZW4gPSBwb2ludHMubnVtYmVyT2ZJdGVtcyB8fCBwb2ludHMubGVuZ3RoOyArK2kgPCBsZW47KSB7XFxuICAgICAgICAgICAgbmV4dCA9IHBvaW50cy5nZXRJdGVtID8gcG9pbnRzLmdldEl0ZW0oaSkgOiBwb2ludHNbaV07XFxuICAgICAgICAgICAgcmVzdWx0LnB1c2guYXBwbHkocmVzdWx0LCBbbmV4dC54LCBuZXh0LnldKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICByZXN1bHQgPSBQTFVHSU5TLnBvbHlzLnBvbHlnb24ocmVzdWx0LCBjb3JuZXIpO1xcbiAgICAgICAgICBicmVhaztcXG4gICAgICAgIC8vIFVua25vd24gc2hhcGUgb3IgcmVjdGFuZ2xlPyBVc2UgYm91bmRpbmcgYm94XFxuXFxuICAgICAgICBkZWZhdWx0OlxcbiAgICAgICAgICByZXN1bHQgPSBlbGVtLmdldEJCb3goKTtcXG4gICAgICAgICAgcmVzdWx0ID0ge1xcbiAgICAgICAgICAgIHdpZHRoOiByZXN1bHQud2lkdGgsXFxuICAgICAgICAgICAgaGVpZ2h0OiByZXN1bHQuaGVpZ2h0LFxcbiAgICAgICAgICAgIHBvc2l0aW9uOiB7XFxuICAgICAgICAgICAgICBsZWZ0OiByZXN1bHQueCxcXG4gICAgICAgICAgICAgIHRvcDogcmVzdWx0LnlcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH07XFxuICAgICAgICAgIGJyZWFrO1xcbiAgICAgIH0gLy8gU2hvcnRjdXQgYXNzaWdubWVudHNcXG5cXG5cXG4gICAgICBwb3NpdGlvbiA9IHJlc3VsdC5wb3NpdGlvbjtcXG4gICAgICByb290ID0gcm9vdFswXTsgLy8gQ29udmVydCBwb3NpdGlvbiBpbnRvIGEgcGl4ZWwgdmFsdWVcXG5cXG4gICAgICBpZiAocm9vdC5jcmVhdGVTVkdQb2ludCkge1xcbiAgICAgICAgbXR4ID0gZWxlbS5nZXRTY3JlZW5DVE0oKTtcXG4gICAgICAgIHBvaW50cyA9IHJvb3QuY3JlYXRlU1ZHUG9pbnQoKTtcXG4gICAgICAgIHBvaW50cy54ID0gcG9zaXRpb24ubGVmdDtcXG4gICAgICAgIHBvaW50cy55ID0gcG9zaXRpb24udG9wO1xcbiAgICAgICAgdHJhbnNmb3JtZWQgPSBwb2ludHMubWF0cml4VHJhbnNmb3JtKG10eCk7XFxuICAgICAgICBwb3NpdGlvbi5sZWZ0ID0gdHJhbnNmb3JtZWQueDtcXG4gICAgICAgIHBvc2l0aW9uLnRvcCA9IHRyYW5zZm9ybWVkLnk7XFxuICAgICAgfSAvLyBDaGVjayB0aGUgZWxlbWVudCBpcyBub3QgaW4gYSBjaGlsZCBkb2N1bWVudCwgYW5kIGlmIHNvLCBhZGp1c3QgZm9yIGZyYW1lIGVsZW1lbnRzIG9mZnNldFxcblxcblxcbiAgICAgIGlmIChvd25lckRvY3VtZW50ICE9PSBkb2N1bWVudCAmJiBhcGkucG9zaXRpb24udGFyZ2V0ICE9PSAnbW91c2UnKSB7XFxuICAgICAgICBmcmFtZU9mZnNldCA9ICQoKG93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgb3duZXJEb2N1bWVudC5wYXJlbnRXaW5kb3cpLmZyYW1lRWxlbWVudCkub2Zmc2V0KCk7XFxuXFxuICAgICAgICBpZiAoZnJhbWVPZmZzZXQpIHtcXG4gICAgICAgICAgcG9zaXRpb24ubGVmdCArPSBmcmFtZU9mZnNldC5sZWZ0O1xcbiAgICAgICAgICBwb3NpdGlvbi50b3AgKz0gZnJhbWVPZmZzZXQudG9wO1xcbiAgICAgICAgfVxcbiAgICAgIH0gLy8gQWRqdXN0IGJ5IHNjcm9sbCBvZmZzZXQgb2Ygb3duZXIgZG9jdW1lbnRcXG5cXG5cXG4gICAgICBvd25lckRvY3VtZW50ID0gJChvd25lckRvY3VtZW50KTtcXG4gICAgICBwb3NpdGlvbi5sZWZ0ICs9IG93bmVyRG9jdW1lbnQuc2Nyb2xsTGVmdCgpO1xcbiAgICAgIHBvc2l0aW9uLnRvcCArPSBvd25lckRvY3VtZW50LnNjcm9sbFRvcCgpO1xcbiAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgIH07XFxuXFxuICAgIDtcXG5cXG4gICAgUExVR0lOUy5pbWFnZW1hcCA9IGZ1bmN0aW9uIChhcGksIGFyZWEsIGNvcm5lciwgYWRqdXN0TWV0aG9kKSB7XFxuICAgICAgaWYgKCFhcmVhLmpxdWVyeSkge1xcbiAgICAgICAgYXJlYSA9ICQoYXJlYSk7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBzaGFwZSA9IChhcmVhLmF0dHIoJ3NoYXBlJykgfHwgJ3JlY3QnKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoJ3BvbHknLCAncG9seWdvbicpLFxcbiAgICAgICAgICBpbWFnZSA9ICQoJ2ltZ1t1c2VtYXA9XFxcIiMnICsgYXJlYS5wYXJlbnQoJ21hcCcpLmF0dHIoJ25hbWUnKSArICdcXFwiXScpLFxcbiAgICAgICAgICBjb29yZHNTdHJpbmcgPSAkLnRyaW0oYXJlYS5hdHRyKCdjb29yZHMnKSksXFxuICAgICAgICAgIGNvb3Jkc0FycmF5ID0gY29vcmRzU3RyaW5nLnJlcGxhY2UoLywkLywgJycpLnNwbGl0KCcsJyksXFxuICAgICAgICAgIGltYWdlT2Zmc2V0LFxcbiAgICAgICAgICBjb29yZHMsXFxuICAgICAgICAgIGksXFxuICAgICAgICAgIG5leHQsXFxuICAgICAgICAgIHJlc3VsdCxcXG4gICAgICAgICAgbGVuOyAvLyBJZiB3ZSBjYW4ndCBmaW5kIHRoZSBpbWFnZSB1c2luZyB0aGUgbWFwLi4uXFxuXFxuICAgICAgaWYgKCFpbWFnZS5sZW5ndGgpIHtcXG4gICAgICAgIHJldHVybiBGQUxTRTtcXG4gICAgICB9IC8vIFBhc3MgY29vcmRpbmF0ZXMgc3RyaW5nIGlmIHBvbHlnb25cXG5cXG5cXG4gICAgICBpZiAoc2hhcGUgPT09ICdwb2x5Z29uJykge1xcbiAgICAgICAgcmVzdWx0ID0gUExVR0lOUy5wb2x5cy5wb2x5Z29uKGNvb3Jkc0FycmF5LCBjb3JuZXIpO1xcbiAgICAgIH0gLy8gT3RoZXJ3aXNlIHBhcnNlIHRoZSBjb29yZGluYXRlcyBhbmQgcGFzcyB0aGVtIGFzIGFyZ3VtZW50c1xcbiAgICAgIGVsc2UgaWYgKFBMVUdJTlMucG9seXNbc2hhcGVdKSB7XFxuICAgICAgICAgIGZvciAoaSA9IC0xLCBsZW4gPSBjb29yZHNBcnJheS5sZW5ndGgsIGNvb3JkcyA9IFtdOyArK2kgPCBsZW47KSB7XFxuICAgICAgICAgICAgY29vcmRzLnB1c2gocGFyc2VJbnQoY29vcmRzQXJyYXlbaV0sIDEwKSk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgcmVzdWx0ID0gUExVR0lOUy5wb2x5c1tzaGFwZV0uYXBwbHkodGhpcywgY29vcmRzLmNvbmNhdChjb3JuZXIpKTtcXG4gICAgICAgIH0gLy8gSWYgbm8gc2hhcHJlIGNhbGN1bGF0aW9uIG1ldGhvZCB3YXMgZm91bmQsIHJldHVybiBmYWxzZVxcbiAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgcmV0dXJuIEZBTFNFO1xcbiAgICAgICAgICB9IC8vIE1ha2Ugc3VyZSB3ZSBhY2NvdW50IGZvciBwYWRkaW5nIGFuZCBib3JkZXJzIG9uIHRoZSBpbWFnZVxcblxcblxcbiAgICAgIGltYWdlT2Zmc2V0ID0gaW1hZ2Uub2Zmc2V0KCk7XFxuICAgICAgaW1hZ2VPZmZzZXQubGVmdCArPSBNYXRoLmNlaWwoKGltYWdlLm91dGVyV2lkdGgoRkFMU0UpIC0gaW1hZ2Uud2lkdGgoKSkgLyAyKTtcXG4gICAgICBpbWFnZU9mZnNldC50b3AgKz0gTWF0aC5jZWlsKChpbWFnZS5vdXRlckhlaWdodChGQUxTRSkgLSBpbWFnZS5oZWlnaHQoKSkgLyAyKTsgLy8gQWRkIGltYWdlIHBvc2l0aW9uIHRvIG9mZnNldCBjb29yZGluYXRlc1xcblxcbiAgICAgIHJlc3VsdC5wb3NpdGlvbi5sZWZ0ICs9IGltYWdlT2Zmc2V0LmxlZnQ7XFxuICAgICAgcmVzdWx0LnBvc2l0aW9uLnRvcCArPSBpbWFnZU9mZnNldC50b3A7XFxuICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgfTtcXG5cXG4gICAgO1xcbiAgICB2YXIgSUU2LFxcblxcbiAgICAvKlxcbiAgICAgKiBCR0lGcmFtZSBhZGFwdGlvbiAoaHR0cDovL3BsdWdpbnMuanF1ZXJ5LmNvbS9wcm9qZWN0L2JnaWZyYW1lKVxcbiAgICAgKiBTcGVjaWFsIHRoYW5rcyB0byBCcmFuZG9uIEFhcm9uXFxuICAgICAqL1xcbiAgICBCR0lGUkFNRSA9ICc8aWZyYW1lIGNsYXNzPVxcXCJxdGlwLWJnaWZyYW1lXFxcIiBmcmFtZWJvcmRlcj1cXFwiMFxcXCIgdGFiaW5kZXg9XFxcIi0xXFxcIiBzcmM9XFxcImphdmFzY3JpcHQ6XFxcXCdcXFxcJztcXFwiICcgKyAnIHN0eWxlPVxcXCJkaXNwbGF5OmJsb2NrOyBwb3NpdGlvbjphYnNvbHV0ZTsgei1pbmRleDotMTsgZmlsdGVyOmFscGhhKG9wYWNpdHk9MCk7ICcgKyAnLW1zLWZpbHRlcjpcXFwicHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LkFscGhhKE9wYWNpdHk9MClcXFwiO1xcXCI+PC9pZnJhbWU+JztcXG5cXG4gICAgZnVuY3Rpb24gSWU2KGFwaSwgcXRpcCkge1xcbiAgICAgIHRoaXMuX25zID0gJ2llNic7XFxuICAgICAgdGhpcy5pbml0KHRoaXMucXRpcCA9IGFwaSk7XFxuICAgIH1cXG5cXG4gICAgJC5leHRlbmQoSWU2LnByb3RvdHlwZSwge1xcbiAgICAgIF9zY3JvbGw6IGZ1bmN0aW9uIF9zY3JvbGwoKSB7XFxuICAgICAgICB2YXIgb3ZlcmxheSA9IHRoaXMucXRpcC5lbGVtZW50cy5vdmVybGF5O1xcbiAgICAgICAgb3ZlcmxheSAmJiAob3ZlcmxheVswXS5zdHlsZS50b3AgPSAkKHdpbmRvdykuc2Nyb2xsVG9wKCkgKyAncHgnKTtcXG4gICAgICB9LFxcbiAgICAgIGluaXQ6IGZ1bmN0aW9uIGluaXQocXRpcCkge1xcbiAgICAgICAgdmFyIHRvb2x0aXAgPSBxdGlwLnRvb2x0aXAsXFxuICAgICAgICAgICAgc2Nyb2xsOyAvLyBDcmVhdGUgdGhlIEJHSUZyYW1lIGVsZW1lbnQgaWYgbmVlZGVkXFxuXFxuICAgICAgICBpZiAoJCgnc2VsZWN0LCBvYmplY3QnKS5sZW5ndGggPCAxKSB7XFxuICAgICAgICAgIHRoaXMuYmdpZnJhbWUgPSBxdGlwLmVsZW1lbnRzLmJnaWZyYW1lID0gJChCR0lGUkFNRSkuYXBwZW5kVG8odG9vbHRpcCk7IC8vIFVwZGF0ZSBCR0lGcmFtZSBvbiB0b29sdGlwIG1vdmVcXG5cXG4gICAgICAgICAgcXRpcC5fYmluZCh0b29sdGlwLCAndG9vbHRpcG1vdmUnLCB0aGlzLmFkanVzdEJHSUZyYW1lLCB0aGlzLl9ucywgdGhpcyk7XFxuICAgICAgICB9IC8vIHJlZHJhdygpIGNvbnRhaW5lciBmb3Igd2lkdGgvaGVpZ2h0IGNhbGN1bGF0aW9uc1xcblxcblxcbiAgICAgICAgdGhpcy5yZWRyYXdDb250YWluZXIgPSAkKCc8ZGl2Lz4nLCB7XFxuICAgICAgICAgIGlkOiBOQU1FU1BBQ0UgKyAnLXJjb250YWluZXInXFxuICAgICAgICB9KS5hcHBlbmRUbyhkb2N1bWVudC5ib2R5KTsgLy8gRml4dXAgbW9kYWwgcGx1Z2luIGlmIHByZXNlbnQgdG9vXFxuXFxuICAgICAgICBpZiAocXRpcC5lbGVtZW50cy5vdmVybGF5ICYmIHF0aXAuZWxlbWVudHMub3ZlcmxheS5hZGRDbGFzcygncXRpcG1vZGFsLWllNmZpeCcpKSB7XFxuICAgICAgICAgIHF0aXAuX2JpbmQod2luZG93LCBbJ3Njcm9sbCcsICdyZXNpemUnXSwgdGhpcy5fc2Nyb2xsLCB0aGlzLl9ucywgdGhpcyk7XFxuXFxuICAgICAgICAgIHF0aXAuX2JpbmQodG9vbHRpcCwgWyd0b29sdGlwc2hvdyddLCB0aGlzLl9zY3JvbGwsIHRoaXMuX25zLCB0aGlzKTtcXG4gICAgICAgIH0gLy8gU2V0IGRpbWVuc2lvbnNcXG5cXG5cXG4gICAgICAgIHRoaXMucmVkcmF3KCk7XFxuICAgICAgfSxcXG4gICAgICBhZGp1c3RCR0lGcmFtZTogZnVuY3Rpb24gYWRqdXN0QkdJRnJhbWUoKSB7XFxuICAgICAgICB2YXIgdG9vbHRpcCA9IHRoaXMucXRpcC50b29sdGlwLFxcbiAgICAgICAgICAgIGRpbWVuc2lvbnMgPSB7XFxuICAgICAgICAgIGhlaWdodDogdG9vbHRpcC5vdXRlckhlaWdodChGQUxTRSksXFxuICAgICAgICAgIHdpZHRoOiB0b29sdGlwLm91dGVyV2lkdGgoRkFMU0UpXFxuICAgICAgICB9LFxcbiAgICAgICAgICAgIHBsdWdpbiA9IHRoaXMucXRpcC5wbHVnaW5zLnRpcCxcXG4gICAgICAgICAgICB0aXAgPSB0aGlzLnF0aXAuZWxlbWVudHMudGlwLFxcbiAgICAgICAgICAgIHRpcEFkanVzdCxcXG4gICAgICAgICAgICBvZmZzZXQ7IC8vIEFkanVzdCBib3JkZXIgb2Zmc2V0XFxuXFxuICAgICAgICBvZmZzZXQgPSBwYXJzZUludCh0b29sdGlwLmNzcygnYm9yZGVyTGVmdFdpZHRoJyksIDEwKSB8fCAwO1xcbiAgICAgICAgb2Zmc2V0ID0ge1xcbiAgICAgICAgICBsZWZ0OiAtb2Zmc2V0LFxcbiAgICAgICAgICB0b3A6IC1vZmZzZXRcXG4gICAgICAgIH07IC8vIEFkanVzdCBmb3IgdGlwcyBwbHVnaW5cXG5cXG4gICAgICAgIGlmIChwbHVnaW4gJiYgdGlwKSB7XFxuICAgICAgICAgIHRpcEFkanVzdCA9IHBsdWdpbi5jb3JuZXIucHJlY2VkYW5jZSA9PT0gJ3gnID8gW1dJRFRILCBMRUZUXSA6IFtIRUlHSFQsIFRPUF07XFxuICAgICAgICAgIG9mZnNldFt0aXBBZGp1c3RbMV1dIC09IHRpcFt0aXBBZGp1c3RbMF1dKCk7XFxuICAgICAgICB9IC8vIFVwZGF0ZSBiZ2lmcmFtZVxcblxcblxcbiAgICAgICAgdGhpcy5iZ2lmcmFtZS5jc3Mob2Zmc2V0KS5jc3MoZGltZW5zaW9ucyk7XFxuICAgICAgfSxcXG4gICAgICAvLyBNYXgvbWluIHdpZHRoIHNpbXVsYXRvciBmdW5jdGlvblxcbiAgICAgIHJlZHJhdzogZnVuY3Rpb24gcmVkcmF3KCkge1xcbiAgICAgICAgaWYgKHRoaXMucXRpcC5yZW5kZXJlZCA8IDEgfHwgdGhpcy5kcmF3aW5nKSB7XFxuICAgICAgICAgIHJldHVybiB0aGlzO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdmFyIHRvb2x0aXAgPSB0aGlzLnF0aXAudG9vbHRpcCxcXG4gICAgICAgICAgICBzdHlsZSA9IHRoaXMucXRpcC5vcHRpb25zLnN0eWxlLFxcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IHRoaXMucXRpcC5vcHRpb25zLnBvc2l0aW9uLmNvbnRhaW5lcixcXG4gICAgICAgICAgICBwZXJjLFxcbiAgICAgICAgICAgIHdpZHRoLFxcbiAgICAgICAgICAgIG1heCxcXG4gICAgICAgICAgICBtaW47IC8vIFNldCBkcmF3aW5nIGZsYWdcXG5cXG4gICAgICAgIHRoaXMucXRpcC5kcmF3aW5nID0gMTsgLy8gSWYgdG9vbHRpcCBoYXMgYSBzZXQgaGVpZ2h0L3dpZHRoLCBqdXN0IHNldCBpdC4uLiBsaWtlIGEgYm9zcyFcXG5cXG4gICAgICAgIGlmIChzdHlsZS5oZWlnaHQpIHtcXG4gICAgICAgICAgdG9vbHRpcC5jc3MoSEVJR0hULCBzdHlsZS5oZWlnaHQpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKHN0eWxlLndpZHRoKSB7XFxuICAgICAgICAgIHRvb2x0aXAuY3NzKFdJRFRILCBzdHlsZS53aWR0aCk7XFxuICAgICAgICB9IC8vIFNpbXVsYXRlIG1heC9taW4gd2lkdGggaWYgbm90IHNldCB3aWR0aCBwcmVzZW50Li4uXFxuICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAvLyBSZXNldCB3aWR0aCBhbmQgYWRkIGZsdWlkIGNsYXNzXFxuICAgICAgICAgICAgdG9vbHRpcC5jc3MoV0lEVEgsICcnKS5hcHBlbmRUbyh0aGlzLnJlZHJhd0NvbnRhaW5lcik7IC8vIEdyYWIgb3VyIHRvb2x0aXAgd2lkdGggKGFkZCAxIGlmIG9kZCBzbyB3ZSBkb24ndCBnZXQgd3JhcHBpbmcgcHJvYmxlbXMuLiBodXp6YWghKVxcblxcbiAgICAgICAgICAgIHdpZHRoID0gdG9vbHRpcC53aWR0aCgpO1xcblxcbiAgICAgICAgICAgIGlmICh3aWR0aCAlIDIgPCAxKSB7XFxuICAgICAgICAgICAgICB3aWR0aCArPSAxO1xcbiAgICAgICAgICAgIH0gLy8gR3JhYiBvdXIgbWF4L21pbiBwcm9wZXJ0aWVzXFxuXFxuXFxuICAgICAgICAgICAgbWF4ID0gdG9vbHRpcC5jc3MoJ21heFdpZHRoJykgfHwgJyc7XFxuICAgICAgICAgICAgbWluID0gdG9vbHRpcC5jc3MoJ21pbldpZHRoJykgfHwgJyc7IC8vIFBhcnNlIGludG8gcHJvcGVyIHBpeGVsIHZhbHVlc1xcblxcbiAgICAgICAgICAgIHBlcmMgPSAobWF4ICsgbWluKS5pbmRleE9mKCclJykgPiAtMSA/IGNvbnRhaW5lci53aWR0aCgpIC8gMTAwIDogMDtcXG4gICAgICAgICAgICBtYXggPSAobWF4LmluZGV4T2YoJyUnKSA+IC0xID8gcGVyYyA6IDEpICogcGFyc2VJbnQobWF4LCAxMCkgfHwgd2lkdGg7XFxuICAgICAgICAgICAgbWluID0gKG1pbi5pbmRleE9mKCclJykgPiAtMSA/IHBlcmMgOiAxKSAqIHBhcnNlSW50KG1pbiwgMTApIHx8IDA7IC8vIERldGVybWluZSBuZXcgZGltZW5zaW9uIHNpemUgYmFzZWQgb24gbWF4L21pbi9jdXJyZW50IHZhbHVlc1xcblxcbiAgICAgICAgICAgIHdpZHRoID0gbWF4ICsgbWluID8gTWF0aC5taW4oTWF0aC5tYXgod2lkdGgsIG1pbiksIG1heCkgOiB3aWR0aDsgLy8gU2V0IHRoZSBuZXdseSBjYWxjdWxhdGVkIHdpZHRoIGFuZCByZW12b2UgZmx1aWQgY2xhc3NcXG5cXG4gICAgICAgICAgICB0b29sdGlwLmNzcyhXSURUSCwgTWF0aC5yb3VuZCh3aWR0aCkpLmFwcGVuZFRvKGNvbnRhaW5lcik7XFxuICAgICAgICAgIH0gLy8gU2V0IGRyYXdpbmcgZmxhZ1xcblxcblxcbiAgICAgICAgdGhpcy5kcmF3aW5nID0gMDtcXG4gICAgICAgIHJldHVybiB0aGlzO1xcbiAgICAgIH0sXFxuICAgICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcXG4gICAgICAgIC8vIFJlbW92ZSBpZnJhbWVcXG4gICAgICAgIHRoaXMuYmdpZnJhbWUgJiYgdGhpcy5iZ2lmcmFtZS5yZW1vdmUoKTsgLy8gUmVtb3ZlIGJvdW5kIGV2ZW50c1xcblxcbiAgICAgICAgdGhpcy5xdGlwLl91bmJpbmQoW3dpbmRvdywgdGhpcy5xdGlwLnRvb2x0aXBdLCB0aGlzLl9ucyk7XFxuICAgICAgfVxcbiAgICB9KTtcXG5cXG4gICAgSUU2ID0gUExVR0lOUy5pZTYgPSBmdW5jdGlvbiAoYXBpKSB7XFxuICAgICAgLy8gUHJvY2VlZCBvbmx5IGlmIHRoZSBicm93c2VyIGlzIElFNlxcbiAgICAgIHJldHVybiBCUk9XU0VSLmllID09PSA2ID8gbmV3IEllNihhcGkpIDogRkFMU0U7XFxuICAgIH07XFxuXFxuICAgIElFNi5pbml0aWFsaXplID0gJ3JlbmRlcic7XFxuICAgIENIRUNLUy5pZTYgPSB7XFxuICAgICAgJ15jb250ZW50fHN0eWxlJCc6IGZ1bmN0aW9uIGNvbnRlbnRTdHlsZSQoKSB7XFxuICAgICAgICB0aGlzLnJlZHJhdygpO1xcbiAgICAgIH1cXG4gICAgfTtcXG4gICAgO1xcbiAgfSk7XFxufSkod2luZG93LCBkb2N1bWVudCk7XCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXFxcInN5bWJvbFxcXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFxcXCJzeW1ib2xcXFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XFxuXFxuLyohIGpRdWVyeSBVSSAtIHYxLjExLjQgLSAyMDE1LTAzLTExXFxuKiBodHRwOi8vanF1ZXJ5dWkuY29tXFxuKiBJbmNsdWRlczogY29yZS5qcywgd2lkZ2V0LmpzLCBtb3VzZS5qcywgcG9zaXRpb24uanMsIGFjY29yZGlvbi5qcywgYXV0b2NvbXBsZXRlLmpzLCBidXR0b24uanMsIGRhdGVwaWNrZXIuanMsIGRpYWxvZy5qcywgZHJhZ2dhYmxlLmpzLCBkcm9wcGFibGUuanMsIGVmZmVjdC5qcywgZWZmZWN0LWJsaW5kLmpzLCBlZmZlY3QtYm91bmNlLmpzLCBlZmZlY3QtY2xpcC5qcywgZWZmZWN0LWRyb3AuanMsIGVmZmVjdC1leHBsb2RlLmpzLCBlZmZlY3QtZmFkZS5qcywgZWZmZWN0LWZvbGQuanMsIGVmZmVjdC1oaWdobGlnaHQuanMsIGVmZmVjdC1wdWZmLmpzLCBlZmZlY3QtcHVsc2F0ZS5qcywgZWZmZWN0LXNjYWxlLmpzLCBlZmZlY3Qtc2hha2UuanMsIGVmZmVjdC1zaXplLmpzLCBlZmZlY3Qtc2xpZGUuanMsIGVmZmVjdC10cmFuc2Zlci5qcywgbWVudS5qcywgcHJvZ3Jlc3NiYXIuanMsIHJlc2l6YWJsZS5qcywgc2VsZWN0YWJsZS5qcywgc2VsZWN0bWVudS5qcywgc2xpZGVyLmpzLCBzb3J0YWJsZS5qcywgc3Bpbm5lci5qcywgdGFicy5qcywgdG9vbHRpcC5qc1xcbiogQ29weXJpZ2h0IDIwMTUgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yczsgTGljZW5zZWQgTUlUICovXFxuKGZ1bmN0aW9uIChmYWN0b3J5KSB7XFxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBkZWZpbmUuYW1kKSB7XFxuICAgIC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cXG4gICAgZGVmaW5lKFtcXFwianF1ZXJ5XFxcIl0sIGZhY3RvcnkpO1xcbiAgfSBlbHNlIHtcXG4gICAgLy8gQnJvd3NlciBnbG9iYWxzXFxuICAgIGZhY3RvcnkoalF1ZXJ5KTtcXG4gIH1cXG59KShmdW5jdGlvbiAoJCkge1xcbiAgLyohXFxuICAgKiBqUXVlcnkgVUkgQ29yZSAxLjExLjRcXG4gICAqIGh0dHA6Ly9qcXVlcnl1aS5jb21cXG4gICAqXFxuICAgKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xcbiAgICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxcbiAgICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxcbiAgICpcXG4gICAqIGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL2NhdGVnb3J5L3VpLWNvcmUvXFxuICAgKi9cXG4gIC8vICQudWkgbWlnaHQgZXhpc3QgZnJvbSBjb21wb25lbnRzIHdpdGggbm8gZGVwZW5kZW5jaWVzLCBlLmcuLCAkLnVpLnBvc2l0aW9uXFxuICAkLnVpID0gJC51aSB8fCB7fTtcXG4gICQuZXh0ZW5kKCQudWksIHtcXG4gICAgdmVyc2lvbjogXFxcIjEuMTEuNFxcXCIsXFxuICAgIGtleUNvZGU6IHtcXG4gICAgICBCQUNLU1BBQ0U6IDgsXFxuICAgICAgQ09NTUE6IDE4OCxcXG4gICAgICBERUxFVEU6IDQ2LFxcbiAgICAgIERPV046IDQwLFxcbiAgICAgIEVORDogMzUsXFxuICAgICAgRU5URVI6IDEzLFxcbiAgICAgIEVTQ0FQRTogMjcsXFxuICAgICAgSE9NRTogMzYsXFxuICAgICAgTEVGVDogMzcsXFxuICAgICAgUEFHRV9ET1dOOiAzNCxcXG4gICAgICBQQUdFX1VQOiAzMyxcXG4gICAgICBQRVJJT0Q6IDE5MCxcXG4gICAgICBSSUdIVDogMzksXFxuICAgICAgU1BBQ0U6IDMyLFxcbiAgICAgIFRBQjogOSxcXG4gICAgICBVUDogMzhcXG4gICAgfVxcbiAgfSk7IC8vIHBsdWdpbnNcXG5cXG4gICQuZm4uZXh0ZW5kKHtcXG4gICAgc2Nyb2xsUGFyZW50OiBmdW5jdGlvbiBzY3JvbGxQYXJlbnQoaW5jbHVkZUhpZGRlbikge1xcbiAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuY3NzKFxcXCJwb3NpdGlvblxcXCIpLFxcbiAgICAgICAgICBleGNsdWRlU3RhdGljUGFyZW50ID0gcG9zaXRpb24gPT09IFxcXCJhYnNvbHV0ZVxcXCIsXFxuICAgICAgICAgIG92ZXJmbG93UmVnZXggPSBpbmNsdWRlSGlkZGVuID8gLyhhdXRvfHNjcm9sbHxoaWRkZW4pLyA6IC8oYXV0b3xzY3JvbGwpLyxcXG4gICAgICAgICAgc2Nyb2xsUGFyZW50ID0gdGhpcy5wYXJlbnRzKCkuZmlsdGVyKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciBwYXJlbnQgPSAkKHRoaXMpO1xcblxcbiAgICAgICAgaWYgKGV4Y2x1ZGVTdGF0aWNQYXJlbnQgJiYgcGFyZW50LmNzcyhcXFwicG9zaXRpb25cXFwiKSA9PT0gXFxcInN0YXRpY1xcXCIpIHtcXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIG92ZXJmbG93UmVnZXgudGVzdChwYXJlbnQuY3NzKFxcXCJvdmVyZmxvd1xcXCIpICsgcGFyZW50LmNzcyhcXFwib3ZlcmZsb3cteVxcXCIpICsgcGFyZW50LmNzcyhcXFwib3ZlcmZsb3cteFxcXCIpKTtcXG4gICAgICB9KS5lcSgwKTtcXG4gICAgICByZXR1cm4gcG9zaXRpb24gPT09IFxcXCJmaXhlZFxcXCIgfHwgIXNjcm9sbFBhcmVudC5sZW5ndGggPyAkKHRoaXNbMF0ub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudCkgOiBzY3JvbGxQYXJlbnQ7XFxuICAgIH0sXFxuICAgIHVuaXF1ZUlkOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgdmFyIHV1aWQgPSAwO1xcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgaWYgKCF0aGlzLmlkKSB7XFxuICAgICAgICAgICAgdGhpcy5pZCA9IFxcXCJ1aS1pZC1cXFwiICsgKyt1dWlkO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgICB9O1xcbiAgICB9KCksXFxuICAgIHJlbW92ZVVuaXF1ZUlkOiBmdW5jdGlvbiByZW1vdmVVbmlxdWVJZCgpIHtcXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGlmICgvXnVpLWlkLVxcXFxkKyQvLnRlc3QodGhpcy5pZCkpIHtcXG4gICAgICAgICAgJCh0aGlzKS5yZW1vdmVBdHRyKFxcXCJpZFxcXCIpO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcbiAgICB9XFxuICB9KTsgLy8gc2VsZWN0b3JzXFxuXFxuICBmdW5jdGlvbiBfZm9jdXNhYmxlKGVsZW1lbnQsIGlzVGFiSW5kZXhOb3ROYU4pIHtcXG4gICAgdmFyIG1hcCxcXG4gICAgICAgIG1hcE5hbWUsXFxuICAgICAgICBpbWcsXFxuICAgICAgICBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcXG5cXG4gICAgaWYgKFxcXCJhcmVhXFxcIiA9PT0gbm9kZU5hbWUpIHtcXG4gICAgICBtYXAgPSBlbGVtZW50LnBhcmVudE5vZGU7XFxuICAgICAgbWFwTmFtZSA9IG1hcC5uYW1lO1xcblxcbiAgICAgIGlmICghZWxlbWVudC5ocmVmIHx8ICFtYXBOYW1lIHx8IG1hcC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcXFwibWFwXFxcIikge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICBpbWcgPSAkKFxcXCJpbWdbdXNlbWFwPScjXFxcIiArIG1hcE5hbWUgKyBcXFwiJ11cXFwiKVswXTtcXG4gICAgICByZXR1cm4gISFpbWcgJiYgdmlzaWJsZShpbWcpO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiAoL14oaW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbnxvYmplY3QpJC8udGVzdChub2RlTmFtZSkgPyAhZWxlbWVudC5kaXNhYmxlZCA6IFxcXCJhXFxcIiA9PT0gbm9kZU5hbWUgPyBlbGVtZW50LmhyZWYgfHwgaXNUYWJJbmRleE5vdE5hTiA6IGlzVGFiSW5kZXhOb3ROYU4pICYmIC8vIHRoZSBlbGVtZW50IGFuZCBhbGwgb2YgaXRzIGFuY2VzdG9ycyBtdXN0IGJlIHZpc2libGVcXG4gICAgdmlzaWJsZShlbGVtZW50KTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIHZpc2libGUoZWxlbWVudCkge1xcbiAgICByZXR1cm4gJC5leHByLmZpbHRlcnMudmlzaWJsZShlbGVtZW50KSAmJiAhJChlbGVtZW50KS5wYXJlbnRzKCkuYWRkQmFjaygpLmZpbHRlcihmdW5jdGlvbiAoKSB7XFxuICAgICAgcmV0dXJuICQuY3NzKHRoaXMsIFxcXCJ2aXNpYmlsaXR5XFxcIikgPT09IFxcXCJoaWRkZW5cXFwiO1xcbiAgICB9KS5sZW5ndGg7XFxuICB9XFxuXFxuICAkLmV4dGVuZCgkLmV4cHJbXFxcIjpcXFwiXSwge1xcbiAgICBkYXRhOiAkLmV4cHIuY3JlYXRlUHNldWRvID8gJC5leHByLmNyZWF0ZVBzZXVkbyhmdW5jdGlvbiAoZGF0YU5hbWUpIHtcXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGVsZW0pIHtcXG4gICAgICAgIHJldHVybiAhISQuZGF0YShlbGVtLCBkYXRhTmFtZSk7XFxuICAgICAgfTtcXG4gICAgfSkgOiAvLyBzdXBwb3J0OiBqUXVlcnkgPDEuOFxcbiAgICBmdW5jdGlvbiAoZWxlbSwgaSwgbWF0Y2gpIHtcXG4gICAgICByZXR1cm4gISEkLmRhdGEoZWxlbSwgbWF0Y2hbM10pO1xcbiAgICB9LFxcbiAgICBmb2N1c2FibGU6IGZ1bmN0aW9uIGZvY3VzYWJsZShlbGVtZW50KSB7XFxuICAgICAgcmV0dXJuIF9mb2N1c2FibGUoZWxlbWVudCwgIWlzTmFOKCQuYXR0cihlbGVtZW50LCBcXFwidGFiaW5kZXhcXFwiKSkpO1xcbiAgICB9LFxcbiAgICB0YWJiYWJsZTogZnVuY3Rpb24gdGFiYmFibGUoZWxlbWVudCkge1xcbiAgICAgIHZhciB0YWJJbmRleCA9ICQuYXR0cihlbGVtZW50LCBcXFwidGFiaW5kZXhcXFwiKSxcXG4gICAgICAgICAgaXNUYWJJbmRleE5hTiA9IGlzTmFOKHRhYkluZGV4KTtcXG4gICAgICByZXR1cm4gKGlzVGFiSW5kZXhOYU4gfHwgdGFiSW5kZXggPj0gMCkgJiYgX2ZvY3VzYWJsZShlbGVtZW50LCAhaXNUYWJJbmRleE5hTik7XFxuICAgIH1cXG4gIH0pOyAvLyBzdXBwb3J0OiBqUXVlcnkgPDEuOFxcblxcbiAgaWYgKCEkKFxcXCI8YT5cXFwiKS5vdXRlcldpZHRoKDEpLmpxdWVyeSkge1xcbiAgICAkLmVhY2goW1xcXCJXaWR0aFxcXCIsIFxcXCJIZWlnaHRcXFwiXSwgZnVuY3Rpb24gKGksIG5hbWUpIHtcXG4gICAgICB2YXIgc2lkZSA9IG5hbWUgPT09IFxcXCJXaWR0aFxcXCIgPyBbXFxcIkxlZnRcXFwiLCBcXFwiUmlnaHRcXFwiXSA6IFtcXFwiVG9wXFxcIiwgXFxcIkJvdHRvbVxcXCJdLFxcbiAgICAgICAgICB0eXBlID0gbmFtZS50b0xvd2VyQ2FzZSgpLFxcbiAgICAgICAgICBvcmlnID0ge1xcbiAgICAgICAgaW5uZXJXaWR0aDogJC5mbi5pbm5lcldpZHRoLFxcbiAgICAgICAgaW5uZXJIZWlnaHQ6ICQuZm4uaW5uZXJIZWlnaHQsXFxuICAgICAgICBvdXRlcldpZHRoOiAkLmZuLm91dGVyV2lkdGgsXFxuICAgICAgICBvdXRlckhlaWdodDogJC5mbi5vdXRlckhlaWdodFxcbiAgICAgIH07XFxuXFxuICAgICAgZnVuY3Rpb24gcmVkdWNlKGVsZW0sIHNpemUsIGJvcmRlciwgbWFyZ2luKSB7XFxuICAgICAgICAkLmVhY2goc2lkZSwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBzaXplIC09IHBhcnNlRmxvYXQoJC5jc3MoZWxlbSwgXFxcInBhZGRpbmdcXFwiICsgdGhpcykpIHx8IDA7XFxuXFxuICAgICAgICAgIGlmIChib3JkZXIpIHtcXG4gICAgICAgICAgICBzaXplIC09IHBhcnNlRmxvYXQoJC5jc3MoZWxlbSwgXFxcImJvcmRlclxcXCIgKyB0aGlzICsgXFxcIldpZHRoXFxcIikpIHx8IDA7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaWYgKG1hcmdpbikge1xcbiAgICAgICAgICAgIHNpemUgLT0gcGFyc2VGbG9hdCgkLmNzcyhlbGVtLCBcXFwibWFyZ2luXFxcIiArIHRoaXMpKSB8fCAwO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgICAgIHJldHVybiBzaXplO1xcbiAgICAgIH1cXG5cXG4gICAgICAkLmZuW1xcXCJpbm5lclxcXCIgKyBuYW1lXSA9IGZ1bmN0aW9uIChzaXplKSB7XFxuICAgICAgICBpZiAoc2l6ZSA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgIHJldHVybiBvcmlnW1xcXCJpbm5lclxcXCIgKyBuYW1lXS5jYWxsKHRoaXMpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICQodGhpcykuY3NzKHR5cGUsIHJlZHVjZSh0aGlzLCBzaXplKSArIFxcXCJweFxcXCIpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfTtcXG5cXG4gICAgICAkLmZuW1xcXCJvdXRlclxcXCIgKyBuYW1lXSA9IGZ1bmN0aW9uIChzaXplLCBtYXJnaW4pIHtcXG4gICAgICAgIGlmICh0eXBlb2Ygc2l6ZSAhPT0gXFxcIm51bWJlclxcXCIpIHtcXG4gICAgICAgICAgcmV0dXJuIG9yaWdbXFxcIm91dGVyXFxcIiArIG5hbWVdLmNhbGwodGhpcywgc2l6ZSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgJCh0aGlzKS5jc3ModHlwZSwgcmVkdWNlKHRoaXMsIHNpemUsIHRydWUsIG1hcmdpbikgKyBcXFwicHhcXFwiKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH07XFxuICAgIH0pO1xcbiAgfSAvLyBzdXBwb3J0OiBqUXVlcnkgPDEuOFxcblxcblxcbiAgaWYgKCEkLmZuLmFkZEJhY2spIHtcXG4gICAgJC5mbi5hZGRCYWNrID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuYWRkKHNlbGVjdG9yID09IG51bGwgPyB0aGlzLnByZXZPYmplY3QgOiB0aGlzLnByZXZPYmplY3QuZmlsdGVyKHNlbGVjdG9yKSk7XFxuICAgIH07XFxuICB9IC8vIHN1cHBvcnQ6IGpRdWVyeSAxLjYuMSwgMS42LjIgKGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0Lzk0MTMpXFxuXFxuXFxuICBpZiAoJChcXFwiPGE+XFxcIikuZGF0YShcXFwiYS1iXFxcIiwgXFxcImFcXFwiKS5yZW1vdmVEYXRhKFxcXCJhLWJcXFwiKS5kYXRhKFxcXCJhLWJcXFwiKSkge1xcbiAgICAkLmZuLnJlbW92ZURhdGEgPSBmdW5jdGlvbiAocmVtb3ZlRGF0YSkge1xcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoa2V5KSB7XFxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xcbiAgICAgICAgICByZXR1cm4gcmVtb3ZlRGF0YS5jYWxsKHRoaXMsICQuY2FtZWxDYXNlKGtleSkpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgcmV0dXJuIHJlbW92ZURhdGEuY2FsbCh0aGlzKTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICB9KCQuZm4ucmVtb3ZlRGF0YSk7XFxuICB9IC8vIGRlcHJlY2F0ZWRcXG5cXG5cXG4gICQudWkuaWUgPSAhIS9tc2llIFtcXFxcdy5dKy8uZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkpO1xcbiAgJC5mbi5leHRlbmQoe1xcbiAgICBmb2N1czogZnVuY3Rpb24gKG9yaWcpIHtcXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGRlbGF5LCBmbikge1xcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBkZWxheSA9PT0gXFxcIm51bWJlclxcXCIgPyB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICB2YXIgZWxlbSA9IHRoaXM7XFxuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICQoZWxlbSkuZm9jdXMoKTtcXG5cXG4gICAgICAgICAgICBpZiAoZm4pIHtcXG4gICAgICAgICAgICAgIGZuLmNhbGwoZWxlbSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9LCBkZWxheSk7XFxuICAgICAgICB9KSA6IG9yaWcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gICAgICB9O1xcbiAgICB9KCQuZm4uZm9jdXMpLFxcbiAgICBkaXNhYmxlU2VsZWN0aW9uOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgdmFyIGV2ZW50VHlwZSA9IFxcXCJvbnNlbGVjdHN0YXJ0XFxcIiBpbiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxcXCJkaXZcXFwiKSA/IFxcXCJzZWxlY3RzdGFydFxcXCIgOiBcXFwibW91c2Vkb3duXFxcIjtcXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuYmluZChldmVudFR5cGUgKyBcXFwiLnVpLWRpc2FibGVTZWxlY3Rpb25cXFwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcXG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH07XFxuICAgIH0oKSxcXG4gICAgZW5hYmxlU2VsZWN0aW9uOiBmdW5jdGlvbiBlbmFibGVTZWxlY3Rpb24oKSB7XFxuICAgICAgcmV0dXJuIHRoaXMudW5iaW5kKFxcXCIudWktZGlzYWJsZVNlbGVjdGlvblxcXCIpO1xcbiAgICB9LFxcbiAgICB6SW5kZXg6IGZ1bmN0aW9uIHpJbmRleChfekluZGV4KSB7XFxuICAgICAgaWYgKF96SW5kZXggIT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuY3NzKFxcXCJ6SW5kZXhcXFwiLCBfekluZGV4KTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMubGVuZ3RoKSB7XFxuICAgICAgICB2YXIgZWxlbSA9ICQodGhpc1swXSksXFxuICAgICAgICAgICAgcG9zaXRpb24sXFxuICAgICAgICAgICAgdmFsdWU7XFxuXFxuICAgICAgICB3aGlsZSAoZWxlbS5sZW5ndGggJiYgZWxlbVswXSAhPT0gZG9jdW1lbnQpIHtcXG4gICAgICAgICAgLy8gSWdub3JlIHotaW5kZXggaWYgcG9zaXRpb24gaXMgc2V0IHRvIGEgdmFsdWUgd2hlcmUgei1pbmRleCBpcyBpZ25vcmVkIGJ5IHRoZSBicm93c2VyXFxuICAgICAgICAgIC8vIFRoaXMgbWFrZXMgYmVoYXZpb3Igb2YgdGhpcyBmdW5jdGlvbiBjb25zaXN0ZW50IGFjcm9zcyBicm93c2Vyc1xcbiAgICAgICAgICAvLyBXZWJLaXQgYWx3YXlzIHJldHVybnMgYXV0byBpZiB0aGUgZWxlbWVudCBpcyBwb3NpdGlvbmVkXFxuICAgICAgICAgIHBvc2l0aW9uID0gZWxlbS5jc3MoXFxcInBvc2l0aW9uXFxcIik7XFxuXFxuICAgICAgICAgIGlmIChwb3NpdGlvbiA9PT0gXFxcImFic29sdXRlXFxcIiB8fCBwb3NpdGlvbiA9PT0gXFxcInJlbGF0aXZlXFxcIiB8fCBwb3NpdGlvbiA9PT0gXFxcImZpeGVkXFxcIikge1xcbiAgICAgICAgICAgIC8vIElFIHJldHVybnMgMCB3aGVuIHpJbmRleCBpcyBub3Qgc3BlY2lmaWVkXFxuICAgICAgICAgICAgLy8gb3RoZXIgYnJvd3NlcnMgcmV0dXJuIGEgc3RyaW5nXFxuICAgICAgICAgICAgLy8gd2UgaWdub3JlIHRoZSBjYXNlIG9mIG5lc3RlZCBlbGVtZW50cyB3aXRoIGFuIGV4cGxpY2l0IHZhbHVlIG9mIDBcXG4gICAgICAgICAgICAvLyA8ZGl2IHN0eWxlPVxcXCJ6LWluZGV4OiAtMTA7XFxcIj48ZGl2IHN0eWxlPVxcXCJ6LWluZGV4OiAwO1xcXCI+PC9kaXY+PC9kaXY+XFxuICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUludChlbGVtLmNzcyhcXFwiekluZGV4XFxcIiksIDEwKTtcXG5cXG4gICAgICAgICAgICBpZiAoIWlzTmFOKHZhbHVlKSAmJiB2YWx1ZSAhPT0gMCkge1xcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBlbGVtID0gZWxlbS5wYXJlbnQoKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIDA7XFxuICAgIH1cXG4gIH0pOyAvLyAkLnVpLnBsdWdpbiBpcyBkZXByZWNhdGVkLiBVc2UgJC53aWRnZXQoKSBleHRlbnNpb25zIGluc3RlYWQuXFxuXFxuICAkLnVpLnBsdWdpbiA9IHtcXG4gICAgYWRkOiBmdW5jdGlvbiBhZGQobW9kdWxlLCBvcHRpb24sIHNldCkge1xcbiAgICAgIHZhciBpLFxcbiAgICAgICAgICBwcm90byA9ICQudWlbbW9kdWxlXS5wcm90b3R5cGU7XFxuXFxuICAgICAgZm9yIChpIGluIHNldCkge1xcbiAgICAgICAgcHJvdG8ucGx1Z2luc1tpXSA9IHByb3RvLnBsdWdpbnNbaV0gfHwgW107XFxuICAgICAgICBwcm90by5wbHVnaW5zW2ldLnB1c2goW29wdGlvbiwgc2V0W2ldXSk7XFxuICAgICAgfVxcbiAgICB9LFxcbiAgICBjYWxsOiBmdW5jdGlvbiBjYWxsKGluc3RhbmNlLCBuYW1lLCBhcmdzLCBhbGxvd0Rpc2Nvbm5lY3RlZCkge1xcbiAgICAgIHZhciBpLFxcbiAgICAgICAgICBzZXQgPSBpbnN0YW5jZS5wbHVnaW5zW25hbWVdO1xcblxcbiAgICAgIGlmICghc2V0KSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghYWxsb3dEaXNjb25uZWN0ZWQgJiYgKCFpbnN0YW5jZS5lbGVtZW50WzBdLnBhcmVudE5vZGUgfHwgaW5zdGFuY2UuZWxlbWVudFswXS5wYXJlbnROb2RlLm5vZGVUeXBlID09PSAxMSkpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgZm9yIChpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgaWYgKGluc3RhbmNlLm9wdGlvbnNbc2V0W2ldWzBdXSkge1xcbiAgICAgICAgICBzZXRbaV1bMV0uYXBwbHkoaW5zdGFuY2UuZWxlbWVudCwgYXJncyk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuICB9O1xcbiAgLyohXFxuICAgKiBqUXVlcnkgVUkgV2lkZ2V0IDEuMTEuNFxcbiAgICogaHR0cDovL2pxdWVyeXVpLmNvbVxcbiAgICpcXG4gICAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXFxuICAgKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXFxuICAgKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXFxuICAgKlxcbiAgICogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20valF1ZXJ5LndpZGdldC9cXG4gICAqL1xcblxcbiAgdmFyIHdpZGdldF91dWlkID0gMCxcXG4gICAgICB3aWRnZXRfc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XFxuXFxuICAkLmNsZWFuRGF0YSA9IGZ1bmN0aW9uIChvcmlnKSB7XFxuICAgIHJldHVybiBmdW5jdGlvbiAoZWxlbXMpIHtcXG4gICAgICB2YXIgZXZlbnRzLCBlbGVtLCBpO1xcblxcbiAgICAgIGZvciAoaSA9IDA7IChlbGVtID0gZWxlbXNbaV0pICE9IG51bGw7IGkrKykge1xcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgLy8gT25seSB0cmlnZ2VyIHJlbW92ZSB3aGVuIG5lY2Vzc2FyeSB0byBzYXZlIHRpbWVcXG4gICAgICAgICAgZXZlbnRzID0gJC5fZGF0YShlbGVtLCBcXFwiZXZlbnRzXFxcIik7XFxuXFxuICAgICAgICAgIGlmIChldmVudHMgJiYgZXZlbnRzLnJlbW92ZSkge1xcbiAgICAgICAgICAgICQoZWxlbSkudHJpZ2dlckhhbmRsZXIoXFxcInJlbW92ZVxcXCIpO1xcbiAgICAgICAgICB9IC8vIGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzgyMzVcXG5cXG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XFxuICAgICAgfVxcblxcbiAgICAgIG9yaWcoZWxlbXMpO1xcbiAgICB9O1xcbiAgfSgkLmNsZWFuRGF0YSk7XFxuXFxuICAkLndpZGdldCA9IGZ1bmN0aW9uIChuYW1lLCBiYXNlLCBwcm90b3R5cGUpIHtcXG4gICAgdmFyIGZ1bGxOYW1lLFxcbiAgICAgICAgZXhpc3RpbmdDb25zdHJ1Y3RvcixcXG4gICAgICAgIGNvbnN0cnVjdG9yLFxcbiAgICAgICAgYmFzZVByb3RvdHlwZSxcXG4gICAgICAgIC8vIHByb3hpZWRQcm90b3R5cGUgYWxsb3dzIHRoZSBwcm92aWRlZCBwcm90b3R5cGUgdG8gcmVtYWluIHVubW9kaWZpZWRcXG4gICAgLy8gc28gdGhhdCBpdCBjYW4gYmUgdXNlZCBhcyBhIG1peGluIGZvciBtdWx0aXBsZSB3aWRnZXRzICgjODg3NilcXG4gICAgcHJveGllZFByb3RvdHlwZSA9IHt9LFxcbiAgICAgICAgbmFtZXNwYWNlID0gbmFtZS5zcGxpdChcXFwiLlxcXCIpWzBdO1xcbiAgICBuYW1lID0gbmFtZS5zcGxpdChcXFwiLlxcXCIpWzFdO1xcbiAgICBmdWxsTmFtZSA9IG5hbWVzcGFjZSArIFxcXCItXFxcIiArIG5hbWU7XFxuXFxuICAgIGlmICghcHJvdG90eXBlKSB7XFxuICAgICAgcHJvdG90eXBlID0gYmFzZTtcXG4gICAgICBiYXNlID0gJC5XaWRnZXQ7XFxuICAgIH0gLy8gY3JlYXRlIHNlbGVjdG9yIGZvciBwbHVnaW5cXG5cXG5cXG4gICAgJC5leHByW1xcXCI6XFxcIl1bZnVsbE5hbWUudG9Mb3dlckNhc2UoKV0gPSBmdW5jdGlvbiAoZWxlbSkge1xcbiAgICAgIHJldHVybiAhISQuZGF0YShlbGVtLCBmdWxsTmFtZSk7XFxuICAgIH07XFxuXFxuICAgICRbbmFtZXNwYWNlXSA9ICRbbmFtZXNwYWNlXSB8fCB7fTtcXG4gICAgZXhpc3RpbmdDb25zdHJ1Y3RvciA9ICRbbmFtZXNwYWNlXVtuYW1lXTtcXG5cXG4gICAgY29uc3RydWN0b3IgPSAkW25hbWVzcGFjZV1bbmFtZV0gPSBmdW5jdGlvbiAob3B0aW9ucywgZWxlbWVudCkge1xcbiAgICAgIC8vIGFsbG93IGluc3RhbnRpYXRpb24gd2l0aG91dCBcXFwibmV3XFxcIiBrZXl3b3JkXFxuICAgICAgaWYgKCF0aGlzLl9jcmVhdGVXaWRnZXQpIHtcXG4gICAgICAgIHJldHVybiBuZXcgY29uc3RydWN0b3Iob3B0aW9ucywgZWxlbWVudCk7XFxuICAgICAgfSAvLyBhbGxvdyBpbnN0YW50aWF0aW9uIHdpdGhvdXQgaW5pdGlhbGl6aW5nIGZvciBzaW1wbGUgaW5oZXJpdGFuY2VcXG4gICAgICAvLyBtdXN0IHVzZSBcXFwibmV3XFxcIiBrZXl3b3JkICh0aGUgY29kZSBhYm92ZSBhbHdheXMgcGFzc2VzIGFyZ3MpXFxuXFxuXFxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcXG4gICAgICAgIHRoaXMuX2NyZWF0ZVdpZGdldChvcHRpb25zLCBlbGVtZW50KTtcXG4gICAgICB9XFxuICAgIH07IC8vIGV4dGVuZCB3aXRoIHRoZSBleGlzdGluZyBjb25zdHJ1Y3RvciB0byBjYXJyeSBvdmVyIGFueSBzdGF0aWMgcHJvcGVydGllc1xcblxcblxcbiAgICAkLmV4dGVuZChjb25zdHJ1Y3RvciwgZXhpc3RpbmdDb25zdHJ1Y3Rvciwge1xcbiAgICAgIHZlcnNpb246IHByb3RvdHlwZS52ZXJzaW9uLFxcbiAgICAgIC8vIGNvcHkgdGhlIG9iamVjdCB1c2VkIHRvIGNyZWF0ZSB0aGUgcHJvdG90eXBlIGluIGNhc2Ugd2UgbmVlZCB0b1xcbiAgICAgIC8vIHJlZGVmaW5lIHRoZSB3aWRnZXQgbGF0ZXJcXG4gICAgICBfcHJvdG86ICQuZXh0ZW5kKHt9LCBwcm90b3R5cGUpLFxcbiAgICAgIC8vIHRyYWNrIHdpZGdldHMgdGhhdCBpbmhlcml0IGZyb20gdGhpcyB3aWRnZXQgaW4gY2FzZSB0aGlzIHdpZGdldCBpc1xcbiAgICAgIC8vIHJlZGVmaW5lZCBhZnRlciBhIHdpZGdldCBpbmhlcml0cyBmcm9tIGl0XFxuICAgICAgX2NoaWxkQ29uc3RydWN0b3JzOiBbXVxcbiAgICB9KTtcXG4gICAgYmFzZVByb3RvdHlwZSA9IG5ldyBiYXNlKCk7IC8vIHdlIG5lZWQgdG8gbWFrZSB0aGUgb3B0aW9ucyBoYXNoIGEgcHJvcGVydHkgZGlyZWN0bHkgb24gdGhlIG5ldyBpbnN0YW5jZVxcbiAgICAvLyBvdGhlcndpc2Ugd2UnbGwgbW9kaWZ5IHRoZSBvcHRpb25zIGhhc2ggb24gdGhlIHByb3RvdHlwZSB0aGF0IHdlJ3JlXFxuICAgIC8vIGluaGVyaXRpbmcgZnJvbVxcblxcbiAgICBiYXNlUHJvdG90eXBlLm9wdGlvbnMgPSAkLndpZGdldC5leHRlbmQoe30sIGJhc2VQcm90b3R5cGUub3B0aW9ucyk7XFxuICAgICQuZWFjaChwcm90b3R5cGUsIGZ1bmN0aW9uIChwcm9wLCB2YWx1ZSkge1xcbiAgICAgIGlmICghJC5pc0Z1bmN0aW9uKHZhbHVlKSkge1xcbiAgICAgICAgcHJveGllZFByb3RvdHlwZVtwcm9wXSA9IHZhbHVlO1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBwcm94aWVkUHJvdG90eXBlW3Byb3BdID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIF9zdXBlciA9IGZ1bmN0aW9uIF9zdXBlcigpIHtcXG4gICAgICAgICAgcmV0dXJuIGJhc2UucHJvdG90eXBlW3Byb3BdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICAgICAgICB9LFxcbiAgICAgICAgICAgIF9zdXBlckFwcGx5ID0gZnVuY3Rpb24gX3N1cGVyQXBwbHkoYXJncykge1xcbiAgICAgICAgICByZXR1cm4gYmFzZS5wcm90b3R5cGVbcHJvcF0uYXBwbHkodGhpcywgYXJncyk7XFxuICAgICAgICB9O1xcblxcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgdmFyIF9fc3VwZXIgPSB0aGlzLl9zdXBlcixcXG4gICAgICAgICAgICAgIF9fc3VwZXJBcHBseSA9IHRoaXMuX3N1cGVyQXBwbHksXFxuICAgICAgICAgICAgICByZXR1cm5WYWx1ZTtcXG4gICAgICAgICAgdGhpcy5fc3VwZXIgPSBfc3VwZXI7XFxuICAgICAgICAgIHRoaXMuX3N1cGVyQXBwbHkgPSBfc3VwZXJBcHBseTtcXG4gICAgICAgICAgcmV0dXJuVmFsdWUgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgICAgICAgICB0aGlzLl9zdXBlciA9IF9fc3VwZXI7XFxuICAgICAgICAgIHRoaXMuX3N1cGVyQXBwbHkgPSBfX3N1cGVyQXBwbHk7XFxuICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcXG4gICAgICAgIH07XFxuICAgICAgfSgpO1xcbiAgICB9KTtcXG4gICAgY29uc3RydWN0b3IucHJvdG90eXBlID0gJC53aWRnZXQuZXh0ZW5kKGJhc2VQcm90b3R5cGUsIHtcXG4gICAgICAvLyBUT0RPOiByZW1vdmUgc3VwcG9ydCBmb3Igd2lkZ2V0RXZlbnRQcmVmaXhcXG4gICAgICAvLyBhbHdheXMgdXNlIHRoZSBuYW1lICsgYSBjb2xvbiBhcyB0aGUgcHJlZml4LCBlLmcuLCBkcmFnZ2FibGU6c3RhcnRcXG4gICAgICAvLyBkb24ndCBwcmVmaXggZm9yIHdpZGdldHMgdGhhdCBhcmVuJ3QgRE9NLWJhc2VkXFxuICAgICAgd2lkZ2V0RXZlbnRQcmVmaXg6IGV4aXN0aW5nQ29uc3RydWN0b3IgPyBiYXNlUHJvdG90eXBlLndpZGdldEV2ZW50UHJlZml4IHx8IG5hbWUgOiBuYW1lXFxuICAgIH0sIHByb3hpZWRQcm90b3R5cGUsIHtcXG4gICAgICBjb25zdHJ1Y3RvcjogY29uc3RydWN0b3IsXFxuICAgICAgbmFtZXNwYWNlOiBuYW1lc3BhY2UsXFxuICAgICAgd2lkZ2V0TmFtZTogbmFtZSxcXG4gICAgICB3aWRnZXRGdWxsTmFtZTogZnVsbE5hbWVcXG4gICAgfSk7IC8vIElmIHRoaXMgd2lkZ2V0IGlzIGJlaW5nIHJlZGVmaW5lZCB0aGVuIHdlIG5lZWQgdG8gZmluZCBhbGwgd2lkZ2V0cyB0aGF0XFxuICAgIC8vIGFyZSBpbmhlcml0aW5nIGZyb20gaXQgYW5kIHJlZGVmaW5lIGFsbCBvZiB0aGVtIHNvIHRoYXQgdGhleSBpbmhlcml0IGZyb21cXG4gICAgLy8gdGhlIG5ldyB2ZXJzaW9uIG9mIHRoaXMgd2lkZ2V0LiBXZSdyZSBlc3NlbnRpYWxseSB0cnlpbmcgdG8gcmVwbGFjZSBvbmVcXG4gICAgLy8gbGV2ZWwgaW4gdGhlIHByb3RvdHlwZSBjaGFpbi5cXG5cXG4gICAgaWYgKGV4aXN0aW5nQ29uc3RydWN0b3IpIHtcXG4gICAgICAkLmVhY2goZXhpc3RpbmdDb25zdHJ1Y3Rvci5fY2hpbGRDb25zdHJ1Y3RvcnMsIGZ1bmN0aW9uIChpLCBjaGlsZCkge1xcbiAgICAgICAgdmFyIGNoaWxkUHJvdG90eXBlID0gY2hpbGQucHJvdG90eXBlOyAvLyByZWRlZmluZSB0aGUgY2hpbGQgd2lkZ2V0IHVzaW5nIHRoZSBzYW1lIHByb3RvdHlwZSB0aGF0IHdhc1xcbiAgICAgICAgLy8gb3JpZ2luYWxseSB1c2VkLCBidXQgaW5oZXJpdCBmcm9tIHRoZSBuZXcgdmVyc2lvbiBvZiB0aGUgYmFzZVxcblxcbiAgICAgICAgJC53aWRnZXQoY2hpbGRQcm90b3R5cGUubmFtZXNwYWNlICsgXFxcIi5cXFwiICsgY2hpbGRQcm90b3R5cGUud2lkZ2V0TmFtZSwgY29uc3RydWN0b3IsIGNoaWxkLl9wcm90byk7XFxuICAgICAgfSk7IC8vIHJlbW92ZSB0aGUgbGlzdCBvZiBleGlzdGluZyBjaGlsZCBjb25zdHJ1Y3RvcnMgZnJvbSB0aGUgb2xkIGNvbnN0cnVjdG9yXFxuICAgICAgLy8gc28gdGhlIG9sZCBjaGlsZCBjb25zdHJ1Y3RvcnMgY2FuIGJlIGdhcmJhZ2UgY29sbGVjdGVkXFxuXFxuICAgICAgZGVsZXRlIGV4aXN0aW5nQ29uc3RydWN0b3IuX2NoaWxkQ29uc3RydWN0b3JzO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGJhc2UuX2NoaWxkQ29uc3RydWN0b3JzLnB1c2goY29uc3RydWN0b3IpO1xcbiAgICB9XFxuXFxuICAgICQud2lkZ2V0LmJyaWRnZShuYW1lLCBjb25zdHJ1Y3Rvcik7XFxuICAgIHJldHVybiBjb25zdHJ1Y3RvcjtcXG4gIH07XFxuXFxuICAkLndpZGdldC5leHRlbmQgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XFxuICAgIHZhciBpbnB1dCA9IHdpZGdldF9zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXFxuICAgICAgICBpbnB1dEluZGV4ID0gMCxcXG4gICAgICAgIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoLFxcbiAgICAgICAga2V5LFxcbiAgICAgICAgdmFsdWU7XFxuXFxuICAgIGZvciAoOyBpbnB1dEluZGV4IDwgaW5wdXRMZW5ndGg7IGlucHV0SW5kZXgrKykge1xcbiAgICAgIGZvciAoa2V5IGluIGlucHV0W2lucHV0SW5kZXhdKSB7XFxuICAgICAgICB2YWx1ZSA9IGlucHV0W2lucHV0SW5kZXhdW2tleV07XFxuXFxuICAgICAgICBpZiAoaW5wdXRbaW5wdXRJbmRleF0uaGFzT3duUHJvcGVydHkoa2V5KSAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgIC8vIENsb25lIG9iamVjdHNcXG4gICAgICAgICAgaWYgKCQuaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcXG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9ICQuaXNQbGFpbk9iamVjdCh0YXJnZXRba2V5XSkgPyAkLndpZGdldC5leHRlbmQoe30sIHRhcmdldFtrZXldLCB2YWx1ZSkgOiAvLyBEb24ndCBleHRlbmQgc3RyaW5ncywgYXJyYXlzLCBldGMuIHdpdGggb2JqZWN0c1xcbiAgICAgICAgICAgICQud2lkZ2V0LmV4dGVuZCh7fSwgdmFsdWUpOyAvLyBDb3B5IGV2ZXJ5dGhpbmcgZWxzZSBieSByZWZlcmVuY2VcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHJldHVybiB0YXJnZXQ7XFxuICB9O1xcblxcbiAgJC53aWRnZXQuYnJpZGdlID0gZnVuY3Rpb24gKG5hbWUsIG9iamVjdCkge1xcbiAgICB2YXIgZnVsbE5hbWUgPSBvYmplY3QucHJvdG90eXBlLndpZGdldEZ1bGxOYW1lIHx8IG5hbWU7XFxuXFxuICAgICQuZm5bbmFtZV0gPSBmdW5jdGlvbiAob3B0aW9ucykge1xcbiAgICAgIHZhciBpc01ldGhvZENhbGwgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXFxcInN0cmluZ1xcXCIsXFxuICAgICAgICAgIGFyZ3MgPSB3aWRnZXRfc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLFxcbiAgICAgICAgICByZXR1cm5WYWx1ZSA9IHRoaXM7XFxuXFxuICAgICAgaWYgKGlzTWV0aG9kQ2FsbCkge1xcbiAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgdmFyIG1ldGhvZFZhbHVlLFxcbiAgICAgICAgICAgICAgaW5zdGFuY2UgPSAkLmRhdGEodGhpcywgZnVsbE5hbWUpO1xcblxcbiAgICAgICAgICBpZiAob3B0aW9ucyA9PT0gXFxcImluc3RhbmNlXFxcIikge1xcbiAgICAgICAgICAgIHJldHVyblZhbHVlID0gaW5zdGFuY2U7XFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmICghaW5zdGFuY2UpIHtcXG4gICAgICAgICAgICByZXR1cm4gJC5lcnJvcihcXFwiY2Fubm90IGNhbGwgbWV0aG9kcyBvbiBcXFwiICsgbmFtZSArIFxcXCIgcHJpb3IgdG8gaW5pdGlhbGl6YXRpb247IFxcXCIgKyBcXFwiYXR0ZW1wdGVkIHRvIGNhbGwgbWV0aG9kICdcXFwiICsgb3B0aW9ucyArIFxcXCInXFxcIik7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaWYgKCEkLmlzRnVuY3Rpb24oaW5zdGFuY2Vbb3B0aW9uc10pIHx8IG9wdGlvbnMuY2hhckF0KDApID09PSBcXFwiX1xcXCIpIHtcXG4gICAgICAgICAgICByZXR1cm4gJC5lcnJvcihcXFwibm8gc3VjaCBtZXRob2QgJ1xcXCIgKyBvcHRpb25zICsgXFxcIicgZm9yIFxcXCIgKyBuYW1lICsgXFxcIiB3aWRnZXQgaW5zdGFuY2VcXFwiKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBtZXRob2RWYWx1ZSA9IGluc3RhbmNlW29wdGlvbnNdLmFwcGx5KGluc3RhbmNlLCBhcmdzKTtcXG5cXG4gICAgICAgICAgaWYgKG1ldGhvZFZhbHVlICE9PSBpbnN0YW5jZSAmJiBtZXRob2RWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBtZXRob2RWYWx1ZSAmJiBtZXRob2RWYWx1ZS5qcXVlcnkgPyByZXR1cm5WYWx1ZS5wdXNoU3RhY2sobWV0aG9kVmFsdWUuZ2V0KCkpIDogbWV0aG9kVmFsdWU7XFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgLy8gQWxsb3cgbXVsdGlwbGUgaGFzaGVzIHRvIGJlIHBhc3NlZCBvbiBpbml0XFxuICAgICAgICBpZiAoYXJncy5sZW5ndGgpIHtcXG4gICAgICAgICAgb3B0aW9ucyA9ICQud2lkZ2V0LmV4dGVuZC5hcHBseShudWxsLCBbb3B0aW9uc10uY29uY2F0KGFyZ3MpKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHZhciBpbnN0YW5jZSA9ICQuZGF0YSh0aGlzLCBmdWxsTmFtZSk7XFxuXFxuICAgICAgICAgIGlmIChpbnN0YW5jZSkge1xcbiAgICAgICAgICAgIGluc3RhbmNlLm9wdGlvbihvcHRpb25zIHx8IHt9KTtcXG5cXG4gICAgICAgICAgICBpZiAoaW5zdGFuY2UuX2luaXQpIHtcXG4gICAgICAgICAgICAgIGluc3RhbmNlLl9pbml0KCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICQuZGF0YSh0aGlzLCBmdWxsTmFtZSwgbmV3IG9iamVjdChvcHRpb25zLCB0aGlzKSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XFxuICAgIH07XFxuICB9O1xcblxcbiAgJC5XaWRnZXQgPSBmdW5jdGlvbiAoKVxcbiAgLyogb3B0aW9ucywgZWxlbWVudCAqL1xcbiAge307XFxuXFxuICAkLldpZGdldC5fY2hpbGRDb25zdHJ1Y3RvcnMgPSBbXTtcXG4gICQuV2lkZ2V0LnByb3RvdHlwZSA9IHtcXG4gICAgd2lkZ2V0TmFtZTogXFxcIndpZGdldFxcXCIsXFxuICAgIHdpZGdldEV2ZW50UHJlZml4OiBcXFwiXFxcIixcXG4gICAgZGVmYXVsdEVsZW1lbnQ6IFxcXCI8ZGl2PlxcXCIsXFxuICAgIG9wdGlvbnM6IHtcXG4gICAgICBkaXNhYmxlZDogZmFsc2UsXFxuICAgICAgLy8gY2FsbGJhY2tzXFxuICAgICAgY3JlYXRlOiBudWxsXFxuICAgIH0sXFxuICAgIF9jcmVhdGVXaWRnZXQ6IGZ1bmN0aW9uIF9jcmVhdGVXaWRnZXQob3B0aW9ucywgZWxlbWVudCkge1xcbiAgICAgIGVsZW1lbnQgPSAkKGVsZW1lbnQgfHwgdGhpcy5kZWZhdWx0RWxlbWVudCB8fCB0aGlzKVswXTtcXG4gICAgICB0aGlzLmVsZW1lbnQgPSAkKGVsZW1lbnQpO1xcbiAgICAgIHRoaXMudXVpZCA9IHdpZGdldF91dWlkKys7XFxuICAgICAgdGhpcy5ldmVudE5hbWVzcGFjZSA9IFxcXCIuXFxcIiArIHRoaXMud2lkZ2V0TmFtZSArIHRoaXMudXVpZDtcXG4gICAgICB0aGlzLmJpbmRpbmdzID0gJCgpO1xcbiAgICAgIHRoaXMuaG92ZXJhYmxlID0gJCgpO1xcbiAgICAgIHRoaXMuZm9jdXNhYmxlID0gJCgpO1xcblxcbiAgICAgIGlmIChlbGVtZW50ICE9PSB0aGlzKSB7XFxuICAgICAgICAkLmRhdGEoZWxlbWVudCwgdGhpcy53aWRnZXRGdWxsTmFtZSwgdGhpcyk7XFxuXFxuICAgICAgICB0aGlzLl9vbih0cnVlLCB0aGlzLmVsZW1lbnQsIHtcXG4gICAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoZXZlbnQpIHtcXG4gICAgICAgICAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSBlbGVtZW50KSB7XFxuICAgICAgICAgICAgICB0aGlzLmRlc3Ryb3koKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcblxcbiAgICAgICAgdGhpcy5kb2N1bWVudCA9ICQoZWxlbWVudC5zdHlsZSA/IC8vIGVsZW1lbnQgd2l0aGluIHRoZSBkb2N1bWVudFxcbiAgICAgICAgZWxlbWVudC5vd25lckRvY3VtZW50IDogLy8gZWxlbWVudCBpcyB3aW5kb3cgb3IgZG9jdW1lbnRcXG4gICAgICAgIGVsZW1lbnQuZG9jdW1lbnQgfHwgZWxlbWVudCk7XFxuICAgICAgICB0aGlzLndpbmRvdyA9ICQodGhpcy5kb2N1bWVudFswXS5kZWZhdWx0VmlldyB8fCB0aGlzLmRvY3VtZW50WzBdLnBhcmVudFdpbmRvdyk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMub3B0aW9ucyA9ICQud2lkZ2V0LmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zLCB0aGlzLl9nZXRDcmVhdGVPcHRpb25zKCksIG9wdGlvbnMpO1xcblxcbiAgICAgIHRoaXMuX2NyZWF0ZSgpO1xcblxcbiAgICAgIHRoaXMuX3RyaWdnZXIoXFxcImNyZWF0ZVxcXCIsIG51bGwsIHRoaXMuX2dldENyZWF0ZUV2ZW50RGF0YSgpKTtcXG5cXG4gICAgICB0aGlzLl9pbml0KCk7XFxuICAgIH0sXFxuICAgIF9nZXRDcmVhdGVPcHRpb25zOiAkLm5vb3AsXFxuICAgIF9nZXRDcmVhdGVFdmVudERhdGE6ICQubm9vcCxcXG4gICAgX2NyZWF0ZTogJC5ub29wLFxcbiAgICBfaW5pdDogJC5ub29wLFxcbiAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xcbiAgICAgIHRoaXMuX2Rlc3Ryb3koKTsgLy8gd2UgY2FuIHByb2JhYmx5IHJlbW92ZSB0aGUgdW5iaW5kIGNhbGxzIGluIDIuMFxcbiAgICAgIC8vIGFsbCBldmVudCBiaW5kaW5ncyBzaG91bGQgZ28gdGhyb3VnaCB0aGlzLl9vbigpXFxuXFxuXFxuICAgICAgdGhpcy5lbGVtZW50LnVuYmluZCh0aGlzLmV2ZW50TmFtZXNwYWNlKS5yZW1vdmVEYXRhKHRoaXMud2lkZ2V0RnVsbE5hbWUpIC8vIHN1cHBvcnQ6IGpxdWVyeSA8MS42LjNcXG4gICAgICAvLyBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC85NDEzXFxuICAgICAgLnJlbW92ZURhdGEoJC5jYW1lbENhc2UodGhpcy53aWRnZXRGdWxsTmFtZSkpO1xcbiAgICAgIHRoaXMud2lkZ2V0KCkudW5iaW5kKHRoaXMuZXZlbnROYW1lc3BhY2UpLnJlbW92ZUF0dHIoXFxcImFyaWEtZGlzYWJsZWRcXFwiKS5yZW1vdmVDbGFzcyh0aGlzLndpZGdldEZ1bGxOYW1lICsgXFxcIi1kaXNhYmxlZCBcXFwiICsgXFxcInVpLXN0YXRlLWRpc2FibGVkXFxcIik7IC8vIGNsZWFuIHVwIGV2ZW50cyBhbmQgc3RhdGVzXFxuXFxuICAgICAgdGhpcy5iaW5kaW5ncy51bmJpbmQodGhpcy5ldmVudE5hbWVzcGFjZSk7XFxuICAgICAgdGhpcy5ob3ZlcmFibGUucmVtb3ZlQ2xhc3MoXFxcInVpLXN0YXRlLWhvdmVyXFxcIik7XFxuICAgICAgdGhpcy5mb2N1c2FibGUucmVtb3ZlQ2xhc3MoXFxcInVpLXN0YXRlLWZvY3VzXFxcIik7XFxuICAgIH0sXFxuICAgIF9kZXN0cm95OiAkLm5vb3AsXFxuICAgIHdpZGdldDogZnVuY3Rpb24gd2lkZ2V0KCkge1xcbiAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQ7XFxuICAgIH0sXFxuICAgIG9wdGlvbjogZnVuY3Rpb24gb3B0aW9uKGtleSwgdmFsdWUpIHtcXG4gICAgICB2YXIgb3B0aW9ucyA9IGtleSxcXG4gICAgICAgICAgcGFydHMsXFxuICAgICAgICAgIGN1ck9wdGlvbixcXG4gICAgICAgICAgaTtcXG5cXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xcbiAgICAgICAgLy8gZG9uJ3QgcmV0dXJuIGEgcmVmZXJlbmNlIHRvIHRoZSBpbnRlcm5hbCBoYXNoXFxuICAgICAgICByZXR1cm4gJC53aWRnZXQuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gXFxcInN0cmluZ1xcXCIpIHtcXG4gICAgICAgIC8vIGhhbmRsZSBuZXN0ZWQga2V5cywgZS5nLiwgXFxcImZvby5iYXJcXFwiID0+IHsgZm9vOiB7IGJhcjogX19fIH0gfVxcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xcbiAgICAgICAgcGFydHMgPSBrZXkuc3BsaXQoXFxcIi5cXFwiKTtcXG4gICAgICAgIGtleSA9IHBhcnRzLnNoaWZ0KCk7XFxuXFxuICAgICAgICBpZiAocGFydHMubGVuZ3RoKSB7XFxuICAgICAgICAgIGN1ck9wdGlvbiA9IG9wdGlvbnNba2V5XSA9ICQud2lkZ2V0LmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zW2tleV0pO1xcblxcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoIC0gMTsgaSsrKSB7XFxuICAgICAgICAgICAgY3VyT3B0aW9uW3BhcnRzW2ldXSA9IGN1ck9wdGlvbltwYXJ0c1tpXV0gfHwge307XFxuICAgICAgICAgICAgY3VyT3B0aW9uID0gY3VyT3B0aW9uW3BhcnRzW2ldXTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBrZXkgPSBwYXJ0cy5wb3AoKTtcXG5cXG4gICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcXG4gICAgICAgICAgICByZXR1cm4gY3VyT3B0aW9uW2tleV0gPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjdXJPcHRpb25ba2V5XTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBjdXJPcHRpb25ba2V5XSA9IHZhbHVlO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zW2tleV0gPT09IHVuZGVmaW5lZCA/IG51bGwgOiB0aGlzLm9wdGlvbnNba2V5XTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBvcHRpb25zW2tleV0gPSB2YWx1ZTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fc2V0T3B0aW9ucyhvcHRpb25zKTtcXG5cXG4gICAgICByZXR1cm4gdGhpcztcXG4gICAgfSxcXG4gICAgX3NldE9wdGlvbnM6IGZ1bmN0aW9uIF9zZXRPcHRpb25zKG9wdGlvbnMpIHtcXG4gICAgICB2YXIga2V5O1xcblxcbiAgICAgIGZvciAoa2V5IGluIG9wdGlvbnMpIHtcXG4gICAgICAgIHRoaXMuX3NldE9wdGlvbihrZXksIG9wdGlvbnNba2V5XSk7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiB0aGlzO1xcbiAgICB9LFxcbiAgICBfc2V0T3B0aW9uOiBmdW5jdGlvbiBfc2V0T3B0aW9uKGtleSwgdmFsdWUpIHtcXG4gICAgICB0aGlzLm9wdGlvbnNba2V5XSA9IHZhbHVlO1xcblxcbiAgICAgIGlmIChrZXkgPT09IFxcXCJkaXNhYmxlZFxcXCIpIHtcXG4gICAgICAgIHRoaXMud2lkZ2V0KCkudG9nZ2xlQ2xhc3ModGhpcy53aWRnZXRGdWxsTmFtZSArIFxcXCItZGlzYWJsZWRcXFwiLCAhIXZhbHVlKTsgLy8gSWYgdGhlIHdpZGdldCBpcyBiZWNvbWluZyBkaXNhYmxlZCwgdGhlbiBub3RoaW5nIGlzIGludGVyYWN0aXZlXFxuXFxuICAgICAgICBpZiAodmFsdWUpIHtcXG4gICAgICAgICAgdGhpcy5ob3ZlcmFibGUucmVtb3ZlQ2xhc3MoXFxcInVpLXN0YXRlLWhvdmVyXFxcIik7XFxuICAgICAgICAgIHRoaXMuZm9jdXNhYmxlLnJlbW92ZUNsYXNzKFxcXCJ1aS1zdGF0ZS1mb2N1c1xcXCIpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gdGhpcztcXG4gICAgfSxcXG4gICAgZW5hYmxlOiBmdW5jdGlvbiBlbmFibGUoKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuX3NldE9wdGlvbnMoe1xcbiAgICAgICAgZGlzYWJsZWQ6IGZhbHNlXFxuICAgICAgfSk7XFxuICAgIH0sXFxuICAgIGRpc2FibGU6IGZ1bmN0aW9uIGRpc2FibGUoKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuX3NldE9wdGlvbnMoe1xcbiAgICAgICAgZGlzYWJsZWQ6IHRydWVcXG4gICAgICB9KTtcXG4gICAgfSxcXG4gICAgX29uOiBmdW5jdGlvbiBfb24oc3VwcHJlc3NEaXNhYmxlZENoZWNrLCBlbGVtZW50LCBoYW5kbGVycykge1xcbiAgICAgIHZhciBkZWxlZ2F0ZUVsZW1lbnQsXFxuICAgICAgICAgIGluc3RhbmNlID0gdGhpczsgLy8gbm8gc3VwcHJlc3NEaXNhYmxlZENoZWNrIGZsYWcsIHNodWZmbGUgYXJndW1lbnRzXFxuXFxuICAgICAgaWYgKHR5cGVvZiBzdXBwcmVzc0Rpc2FibGVkQ2hlY2sgIT09IFxcXCJib29sZWFuXFxcIikge1xcbiAgICAgICAgaGFuZGxlcnMgPSBlbGVtZW50O1xcbiAgICAgICAgZWxlbWVudCA9IHN1cHByZXNzRGlzYWJsZWRDaGVjaztcXG4gICAgICAgIHN1cHByZXNzRGlzYWJsZWRDaGVjayA9IGZhbHNlO1xcbiAgICAgIH0gLy8gbm8gZWxlbWVudCBhcmd1bWVudCwgc2h1ZmZsZSBhbmQgdXNlIHRoaXMuZWxlbWVudFxcblxcblxcbiAgICAgIGlmICghaGFuZGxlcnMpIHtcXG4gICAgICAgIGhhbmRsZXJzID0gZWxlbWVudDtcXG4gICAgICAgIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XFxuICAgICAgICBkZWxlZ2F0ZUVsZW1lbnQgPSB0aGlzLndpZGdldCgpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBlbGVtZW50ID0gZGVsZWdhdGVFbGVtZW50ID0gJChlbGVtZW50KTtcXG4gICAgICAgIHRoaXMuYmluZGluZ3MgPSB0aGlzLmJpbmRpbmdzLmFkZChlbGVtZW50KTtcXG4gICAgICB9XFxuXFxuICAgICAgJC5lYWNoKGhhbmRsZXJzLCBmdW5jdGlvbiAoZXZlbnQsIGhhbmRsZXIpIHtcXG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZXJQcm94eSgpIHtcXG4gICAgICAgICAgLy8gYWxsb3cgd2lkZ2V0cyB0byBjdXN0b21pemUgdGhlIGRpc2FibGVkIGhhbmRsaW5nXFxuICAgICAgICAgIC8vIC0gZGlzYWJsZWQgYXMgYW4gYXJyYXkgaW5zdGVhZCBvZiBib29sZWFuXFxuICAgICAgICAgIC8vIC0gZGlzYWJsZWQgY2xhc3MgYXMgbWV0aG9kIGZvciBkaXNhYmxpbmcgaW5kaXZpZHVhbCBwYXJ0c1xcbiAgICAgICAgICBpZiAoIXN1cHByZXNzRGlzYWJsZWRDaGVjayAmJiAoaW5zdGFuY2Uub3B0aW9ucy5kaXNhYmxlZCA9PT0gdHJ1ZSB8fCAkKHRoaXMpLmhhc0NsYXNzKFxcXCJ1aS1zdGF0ZS1kaXNhYmxlZFxcXCIpKSkge1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICByZXR1cm4gKHR5cGVvZiBoYW5kbGVyID09PSBcXFwic3RyaW5nXFxcIiA/IGluc3RhbmNlW2hhbmRsZXJdIDogaGFuZGxlcikuYXBwbHkoaW5zdGFuY2UsIGFyZ3VtZW50cyk7XFxuICAgICAgICB9IC8vIGNvcHkgdGhlIGd1aWQgc28gZGlyZWN0IHVuYmluZGluZyB3b3Jrc1xcblxcblxcbiAgICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyICE9PSBcXFwic3RyaW5nXFxcIikge1xcbiAgICAgICAgICBoYW5kbGVyUHJveHkuZ3VpZCA9IGhhbmRsZXIuZ3VpZCA9IGhhbmRsZXIuZ3VpZCB8fCBoYW5kbGVyUHJveHkuZ3VpZCB8fCAkLmd1aWQrKztcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHZhciBtYXRjaCA9IGV2ZW50Lm1hdGNoKC9eKFtcXFxcdzotXSopXFxcXHMqKC4qKSQvKSxcXG4gICAgICAgICAgICBldmVudE5hbWUgPSBtYXRjaFsxXSArIGluc3RhbmNlLmV2ZW50TmFtZXNwYWNlLFxcbiAgICAgICAgICAgIHNlbGVjdG9yID0gbWF0Y2hbMl07XFxuXFxuICAgICAgICBpZiAoc2VsZWN0b3IpIHtcXG4gICAgICAgICAgZGVsZWdhdGVFbGVtZW50LmRlbGVnYXRlKHNlbGVjdG9yLCBldmVudE5hbWUsIGhhbmRsZXJQcm94eSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBlbGVtZW50LmJpbmQoZXZlbnROYW1lLCBoYW5kbGVyUHJveHkpO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcbiAgICB9LFxcbiAgICBfb2ZmOiBmdW5jdGlvbiBfb2ZmKGVsZW1lbnQsIGV2ZW50TmFtZSkge1xcbiAgICAgIGV2ZW50TmFtZSA9IChldmVudE5hbWUgfHwgXFxcIlxcXCIpLnNwbGl0KFxcXCIgXFxcIikuam9pbih0aGlzLmV2ZW50TmFtZXNwYWNlICsgXFxcIiBcXFwiKSArIHRoaXMuZXZlbnROYW1lc3BhY2U7XFxuICAgICAgZWxlbWVudC51bmJpbmQoZXZlbnROYW1lKS51bmRlbGVnYXRlKGV2ZW50TmFtZSk7IC8vIENsZWFyIHRoZSBzdGFjayB0byBhdm9pZCBtZW1vcnkgbGVha3MgKCMxMDA1NilcXG5cXG4gICAgICB0aGlzLmJpbmRpbmdzID0gJCh0aGlzLmJpbmRpbmdzLm5vdChlbGVtZW50KS5nZXQoKSk7XFxuICAgICAgdGhpcy5mb2N1c2FibGUgPSAkKHRoaXMuZm9jdXNhYmxlLm5vdChlbGVtZW50KS5nZXQoKSk7XFxuICAgICAgdGhpcy5ob3ZlcmFibGUgPSAkKHRoaXMuaG92ZXJhYmxlLm5vdChlbGVtZW50KS5nZXQoKSk7XFxuICAgIH0sXFxuICAgIF9kZWxheTogZnVuY3Rpb24gX2RlbGF5KGhhbmRsZXIsIGRlbGF5KSB7XFxuICAgICAgZnVuY3Rpb24gaGFuZGxlclByb3h5KCkge1xcbiAgICAgICAgcmV0dXJuICh0eXBlb2YgaGFuZGxlciA9PT0gXFxcInN0cmluZ1xcXCIgPyBpbnN0YW5jZVtoYW5kbGVyXSA6IGhhbmRsZXIpLmFwcGx5KGluc3RhbmNlLCBhcmd1bWVudHMpO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgaW5zdGFuY2UgPSB0aGlzO1xcbiAgICAgIHJldHVybiBzZXRUaW1lb3V0KGhhbmRsZXJQcm94eSwgZGVsYXkgfHwgMCk7XFxuICAgIH0sXFxuICAgIF9ob3ZlcmFibGU6IGZ1bmN0aW9uIF9ob3ZlcmFibGUoZWxlbWVudCkge1xcbiAgICAgIHRoaXMuaG92ZXJhYmxlID0gdGhpcy5ob3ZlcmFibGUuYWRkKGVsZW1lbnQpO1xcblxcbiAgICAgIHRoaXMuX29uKGVsZW1lbnQsIHtcXG4gICAgICAgIG1vdXNlZW50ZXI6IGZ1bmN0aW9uIG1vdXNlZW50ZXIoZXZlbnQpIHtcXG4gICAgICAgICAgJChldmVudC5jdXJyZW50VGFyZ2V0KS5hZGRDbGFzcyhcXFwidWktc3RhdGUtaG92ZXJcXFwiKTtcXG4gICAgICAgIH0sXFxuICAgICAgICBtb3VzZWxlYXZlOiBmdW5jdGlvbiBtb3VzZWxlYXZlKGV2ZW50KSB7XFxuICAgICAgICAgICQoZXZlbnQuY3VycmVudFRhcmdldCkucmVtb3ZlQ2xhc3MoXFxcInVpLXN0YXRlLWhvdmVyXFxcIik7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgIH0sXFxuICAgIF9mb2N1c2FibGU6IGZ1bmN0aW9uIF9mb2N1c2FibGUoZWxlbWVudCkge1xcbiAgICAgIHRoaXMuZm9jdXNhYmxlID0gdGhpcy5mb2N1c2FibGUuYWRkKGVsZW1lbnQpO1xcblxcbiAgICAgIHRoaXMuX29uKGVsZW1lbnQsIHtcXG4gICAgICAgIGZvY3VzaW46IGZ1bmN0aW9uIGZvY3VzaW4oZXZlbnQpIHtcXG4gICAgICAgICAgJChldmVudC5jdXJyZW50VGFyZ2V0KS5hZGRDbGFzcyhcXFwidWktc3RhdGUtZm9jdXNcXFwiKTtcXG4gICAgICAgIH0sXFxuICAgICAgICBmb2N1c291dDogZnVuY3Rpb24gZm9jdXNvdXQoZXZlbnQpIHtcXG4gICAgICAgICAgJChldmVudC5jdXJyZW50VGFyZ2V0KS5yZW1vdmVDbGFzcyhcXFwidWktc3RhdGUtZm9jdXNcXFwiKTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgfSxcXG4gICAgX3RyaWdnZXI6IGZ1bmN0aW9uIF90cmlnZ2VyKHR5cGUsIGV2ZW50LCBkYXRhKSB7XFxuICAgICAgdmFyIHByb3AsXFxuICAgICAgICAgIG9yaWcsXFxuICAgICAgICAgIGNhbGxiYWNrID0gdGhpcy5vcHRpb25zW3R5cGVdO1xcbiAgICAgIGRhdGEgPSBkYXRhIHx8IHt9O1xcbiAgICAgIGV2ZW50ID0gJC5FdmVudChldmVudCk7XFxuICAgICAgZXZlbnQudHlwZSA9ICh0eXBlID09PSB0aGlzLndpZGdldEV2ZW50UHJlZml4ID8gdHlwZSA6IHRoaXMud2lkZ2V0RXZlbnRQcmVmaXggKyB0eXBlKS50b0xvd2VyQ2FzZSgpOyAvLyB0aGUgb3JpZ2luYWwgZXZlbnQgbWF5IGNvbWUgZnJvbSBhbnkgZWxlbWVudFxcbiAgICAgIC8vIHNvIHdlIG5lZWQgdG8gcmVzZXQgdGhlIHRhcmdldCBvbiB0aGUgbmV3IGV2ZW50XFxuXFxuICAgICAgZXZlbnQudGFyZ2V0ID0gdGhpcy5lbGVtZW50WzBdOyAvLyBjb3B5IG9yaWdpbmFsIGV2ZW50IHByb3BlcnRpZXMgb3ZlciB0byB0aGUgbmV3IGV2ZW50XFxuXFxuICAgICAgb3JpZyA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQ7XFxuXFxuICAgICAgaWYgKG9yaWcpIHtcXG4gICAgICAgIGZvciAocHJvcCBpbiBvcmlnKSB7XFxuICAgICAgICAgIGlmICghKHByb3AgaW4gZXZlbnQpKSB7XFxuICAgICAgICAgICAgZXZlbnRbcHJvcF0gPSBvcmlnW3Byb3BdO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuZWxlbWVudC50cmlnZ2VyKGV2ZW50LCBkYXRhKTtcXG4gICAgICByZXR1cm4gISgkLmlzRnVuY3Rpb24oY2FsbGJhY2spICYmIGNhbGxiYWNrLmFwcGx5KHRoaXMuZWxlbWVudFswXSwgW2V2ZW50XS5jb25jYXQoZGF0YSkpID09PSBmYWxzZSB8fCBldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSk7XFxuICAgIH1cXG4gIH07XFxuICAkLmVhY2goe1xcbiAgICBzaG93OiBcXFwiZmFkZUluXFxcIixcXG4gICAgaGlkZTogXFxcImZhZGVPdXRcXFwiXFxuICB9LCBmdW5jdGlvbiAobWV0aG9kLCBkZWZhdWx0RWZmZWN0KSB7XFxuICAgICQuV2lkZ2V0LnByb3RvdHlwZVtcXFwiX1xcXCIgKyBtZXRob2RdID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XFxuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcXFwic3RyaW5nXFxcIikge1xcbiAgICAgICAgb3B0aW9ucyA9IHtcXG4gICAgICAgICAgZWZmZWN0OiBvcHRpb25zXFxuICAgICAgICB9O1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgaGFzT3B0aW9ucyxcXG4gICAgICAgICAgZWZmZWN0TmFtZSA9ICFvcHRpb25zID8gbWV0aG9kIDogb3B0aW9ucyA9PT0gdHJ1ZSB8fCB0eXBlb2Ygb3B0aW9ucyA9PT0gXFxcIm51bWJlclxcXCIgPyBkZWZhdWx0RWZmZWN0IDogb3B0aW9ucy5lZmZlY3QgfHwgZGVmYXVsdEVmZmVjdDtcXG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcXG5cXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFxcXCJudW1iZXJcXFwiKSB7XFxuICAgICAgICBvcHRpb25zID0ge1xcbiAgICAgICAgICBkdXJhdGlvbjogb3B0aW9uc1xcbiAgICAgICAgfTtcXG4gICAgICB9XFxuXFxuICAgICAgaGFzT3B0aW9ucyA9ICEkLmlzRW1wdHlPYmplY3Qob3B0aW9ucyk7XFxuICAgICAgb3B0aW9ucy5jb21wbGV0ZSA9IGNhbGxiYWNrO1xcblxcbiAgICAgIGlmIChvcHRpb25zLmRlbGF5KSB7XFxuICAgICAgICBlbGVtZW50LmRlbGF5KG9wdGlvbnMuZGVsYXkpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoaGFzT3B0aW9ucyAmJiAkLmVmZmVjdHMgJiYgJC5lZmZlY3RzLmVmZmVjdFtlZmZlY3ROYW1lXSkge1xcbiAgICAgICAgZWxlbWVudFttZXRob2RdKG9wdGlvbnMpO1xcbiAgICAgIH0gZWxzZSBpZiAoZWZmZWN0TmFtZSAhPT0gbWV0aG9kICYmIGVsZW1lbnRbZWZmZWN0TmFtZV0pIHtcXG4gICAgICAgIGVsZW1lbnRbZWZmZWN0TmFtZV0ob3B0aW9ucy5kdXJhdGlvbiwgb3B0aW9ucy5lYXNpbmcsIGNhbGxiYWNrKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgZWxlbWVudC5xdWV1ZShmdW5jdGlvbiAobmV4dCkge1xcbiAgICAgICAgICAkKHRoaXMpW21ldGhvZF0oKTtcXG5cXG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XFxuICAgICAgICAgICAgY2FsbGJhY2suY2FsbChlbGVtZW50WzBdKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBuZXh0KCk7XFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuICAgIH07XFxuICB9KTtcXG4gIHZhciB3aWRnZXQgPSAkLndpZGdldDtcXG4gIC8qIVxcbiAgICogalF1ZXJ5IFVJIE1vdXNlIDEuMTEuNFxcbiAgICogaHR0cDovL2pxdWVyeXVpLmNvbVxcbiAgICpcXG4gICAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXFxuICAgKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXFxuICAgKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXFxuICAgKlxcbiAgICogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20vbW91c2UvXFxuICAgKi9cXG5cXG4gIHZhciBtb3VzZUhhbmRsZWQgPSBmYWxzZTtcXG4gICQoZG9jdW1lbnQpLm1vdXNldXAoZnVuY3Rpb24gKCkge1xcbiAgICBtb3VzZUhhbmRsZWQgPSBmYWxzZTtcXG4gIH0pO1xcbiAgdmFyIG1vdXNlID0gJC53aWRnZXQoXFxcInVpLm1vdXNlXFxcIiwge1xcbiAgICB2ZXJzaW9uOiBcXFwiMS4xMS40XFxcIixcXG4gICAgb3B0aW9uczoge1xcbiAgICAgIGNhbmNlbDogXFxcImlucHV0LHRleHRhcmVhLGJ1dHRvbixzZWxlY3Qsb3B0aW9uXFxcIixcXG4gICAgICBkaXN0YW5jZTogMSxcXG4gICAgICBkZWxheTogMFxcbiAgICB9LFxcbiAgICBfbW91c2VJbml0OiBmdW5jdGlvbiBfbW91c2VJbml0KCkge1xcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcXG4gICAgICB0aGlzLmVsZW1lbnQuYmluZChcXFwibW91c2Vkb3duLlxcXCIgKyB0aGlzLndpZGdldE5hbWUsIGZ1bmN0aW9uIChldmVudCkge1xcbiAgICAgICAgcmV0dXJuIHRoYXQuX21vdXNlRG93bihldmVudCk7XFxuICAgICAgfSkuYmluZChcXFwiY2xpY2suXFxcIiArIHRoaXMud2lkZ2V0TmFtZSwgZnVuY3Rpb24gKGV2ZW50KSB7XFxuICAgICAgICBpZiAodHJ1ZSA9PT0gJC5kYXRhKGV2ZW50LnRhcmdldCwgdGhhdC53aWRnZXROYW1lICsgXFxcIi5wcmV2ZW50Q2xpY2tFdmVudFxcXCIpKSB7XFxuICAgICAgICAgICQucmVtb3ZlRGF0YShldmVudC50YXJnZXQsIHRoYXQud2lkZ2V0TmFtZSArIFxcXCIucHJldmVudENsaWNrRXZlbnRcXFwiKTtcXG4gICAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XFxuICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcXG4gICAgfSxcXG4gICAgLy8gVE9ETzogbWFrZSBzdXJlIGRlc3Ryb3lpbmcgb25lIGluc3RhbmNlIG9mIG1vdXNlIGRvZXNuJ3QgbWVzcyB3aXRoXFxuICAgIC8vIG90aGVyIGluc3RhbmNlcyBvZiBtb3VzZVxcbiAgICBfbW91c2VEZXN0cm95OiBmdW5jdGlvbiBfbW91c2VEZXN0cm95KCkge1xcbiAgICAgIHRoaXMuZWxlbWVudC51bmJpbmQoXFxcIi5cXFwiICsgdGhpcy53aWRnZXROYW1lKTtcXG5cXG4gICAgICBpZiAodGhpcy5fbW91c2VNb3ZlRGVsZWdhdGUpIHtcXG4gICAgICAgIHRoaXMuZG9jdW1lbnQudW5iaW5kKFxcXCJtb3VzZW1vdmUuXFxcIiArIHRoaXMud2lkZ2V0TmFtZSwgdGhpcy5fbW91c2VNb3ZlRGVsZWdhdGUpLnVuYmluZChcXFwibW91c2V1cC5cXFwiICsgdGhpcy53aWRnZXROYW1lLCB0aGlzLl9tb3VzZVVwRGVsZWdhdGUpO1xcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgX21vdXNlRG93bjogZnVuY3Rpb24gX21vdXNlRG93bihldmVudCkge1xcbiAgICAgIC8vIGRvbid0IGxldCBtb3JlIHRoYW4gb25lIHdpZGdldCBoYW5kbGUgbW91c2VTdGFydFxcbiAgICAgIGlmIChtb3VzZUhhbmRsZWQpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fbW91c2VNb3ZlZCA9IGZhbHNlOyAvLyB3ZSBtYXkgaGF2ZSBtaXNzZWQgbW91c2V1cCAob3V0IG9mIHdpbmRvdylcXG5cXG4gICAgICB0aGlzLl9tb3VzZVN0YXJ0ZWQgJiYgdGhpcy5fbW91c2VVcChldmVudCk7XFxuICAgICAgdGhpcy5fbW91c2VEb3duRXZlbnQgPSBldmVudDtcXG4gICAgICB2YXIgdGhhdCA9IHRoaXMsXFxuICAgICAgICAgIGJ0bklzTGVmdCA9IGV2ZW50LndoaWNoID09PSAxLFxcbiAgICAgICAgICAvLyBldmVudC50YXJnZXQubm9kZU5hbWUgd29ya3MgYXJvdW5kIGEgYnVnIGluIElFIDggd2l0aFxcbiAgICAgIC8vIGRpc2FibGVkIGlucHV0cyAoIzc2MjApXFxuICAgICAgZWxJc0NhbmNlbCA9IHR5cGVvZiB0aGlzLm9wdGlvbnMuY2FuY2VsID09PSBcXFwic3RyaW5nXFxcIiAmJiBldmVudC50YXJnZXQubm9kZU5hbWUgPyAkKGV2ZW50LnRhcmdldCkuY2xvc2VzdCh0aGlzLm9wdGlvbnMuY2FuY2VsKS5sZW5ndGggOiBmYWxzZTtcXG5cXG4gICAgICBpZiAoIWJ0bklzTGVmdCB8fCBlbElzQ2FuY2VsIHx8ICF0aGlzLl9tb3VzZUNhcHR1cmUoZXZlbnQpKSB7XFxuICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5tb3VzZURlbGF5TWV0ID0gIXRoaXMub3B0aW9ucy5kZWxheTtcXG5cXG4gICAgICBpZiAoIXRoaXMubW91c2VEZWxheU1ldCkge1xcbiAgICAgICAgdGhpcy5fbW91c2VEZWxheVRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHRoYXQubW91c2VEZWxheU1ldCA9IHRydWU7XFxuICAgICAgICB9LCB0aGlzLm9wdGlvbnMuZGVsYXkpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5fbW91c2VEaXN0YW5jZU1ldChldmVudCkgJiYgdGhpcy5fbW91c2VEZWxheU1ldChldmVudCkpIHtcXG4gICAgICAgIHRoaXMuX21vdXNlU3RhcnRlZCA9IHRoaXMuX21vdXNlU3RhcnQoZXZlbnQpICE9PSBmYWxzZTtcXG5cXG4gICAgICAgIGlmICghdGhpcy5fbW91c2VTdGFydGVkKSB7XFxuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgICAgfVxcbiAgICAgIH0gLy8gQ2xpY2sgZXZlbnQgbWF5IG5ldmVyIGhhdmUgZmlyZWQgKEdlY2tvICYgT3BlcmEpXFxuXFxuXFxuICAgICAgaWYgKHRydWUgPT09ICQuZGF0YShldmVudC50YXJnZXQsIHRoaXMud2lkZ2V0TmFtZSArIFxcXCIucHJldmVudENsaWNrRXZlbnRcXFwiKSkge1xcbiAgICAgICAgJC5yZW1vdmVEYXRhKGV2ZW50LnRhcmdldCwgdGhpcy53aWRnZXROYW1lICsgXFxcIi5wcmV2ZW50Q2xpY2tFdmVudFxcXCIpO1xcbiAgICAgIH0gLy8gdGhlc2UgZGVsZWdhdGVzIGFyZSByZXF1aXJlZCB0byBrZWVwIGNvbnRleHRcXG5cXG5cXG4gICAgICB0aGlzLl9tb3VzZU1vdmVEZWxlZ2F0ZSA9IGZ1bmN0aW9uIChldmVudCkge1xcbiAgICAgICAgcmV0dXJuIHRoYXQuX21vdXNlTW92ZShldmVudCk7XFxuICAgICAgfTtcXG5cXG4gICAgICB0aGlzLl9tb3VzZVVwRGVsZWdhdGUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcXG4gICAgICAgIHJldHVybiB0aGF0Ll9tb3VzZVVwKGV2ZW50KTtcXG4gICAgICB9O1xcblxcbiAgICAgIHRoaXMuZG9jdW1lbnQuYmluZChcXFwibW91c2Vtb3ZlLlxcXCIgKyB0aGlzLndpZGdldE5hbWUsIHRoaXMuX21vdXNlTW92ZURlbGVnYXRlKS5iaW5kKFxcXCJtb3VzZXVwLlxcXCIgKyB0aGlzLndpZGdldE5hbWUsIHRoaXMuX21vdXNlVXBEZWxlZ2F0ZSk7XFxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG4gICAgICBtb3VzZUhhbmRsZWQgPSB0cnVlO1xcbiAgICAgIHJldHVybiB0cnVlO1xcbiAgICB9LFxcbiAgICBfbW91c2VNb3ZlOiBmdW5jdGlvbiBfbW91c2VNb3ZlKGV2ZW50KSB7XFxuICAgICAgLy8gT25seSBjaGVjayBmb3IgbW91c2V1cHMgb3V0c2lkZSB0aGUgZG9jdW1lbnQgaWYgeW91J3ZlIG1vdmVkIGluc2lkZSB0aGUgZG9jdW1lbnRcXG4gICAgICAvLyBhdCBsZWFzdCBvbmNlLiBUaGlzIHByZXZlbnRzIHRoZSBmaXJpbmcgb2YgbW91c2V1cCBpbiB0aGUgY2FzZSBvZiBJRTw5LCB3aGljaCB3aWxsXFxuICAgICAgLy8gZmlyZSBhIG1vdXNlbW92ZSBldmVudCBpZiBjb250ZW50IGlzIHBsYWNlZCB1bmRlciB0aGUgY3Vyc29yLiBTZWUgIzc3NzhcXG4gICAgICAvLyBTdXBwb3J0OiBJRSA8OVxcbiAgICAgIGlmICh0aGlzLl9tb3VzZU1vdmVkKSB7XFxuICAgICAgICAvLyBJRSBtb3VzZXVwIGNoZWNrIC0gbW91c2V1cCBoYXBwZW5lZCB3aGVuIG1vdXNlIHdhcyBvdXQgb2Ygd2luZG93XFxuICAgICAgICBpZiAoJC51aS5pZSAmJiAoIWRvY3VtZW50LmRvY3VtZW50TW9kZSB8fCBkb2N1bWVudC5kb2N1bWVudE1vZGUgPCA5KSAmJiAhZXZlbnQuYnV0dG9uKSB7XFxuICAgICAgICAgIHJldHVybiB0aGlzLl9tb3VzZVVwKGV2ZW50KTsgLy8gSWZyYW1lIG1vdXNldXAgY2hlY2sgLSBtb3VzZXVwIG9jY3VycmVkIGluIGFub3RoZXIgZG9jdW1lbnRcXG4gICAgICAgIH0gZWxzZSBpZiAoIWV2ZW50LndoaWNoKSB7XFxuICAgICAgICAgIHJldHVybiB0aGlzLl9tb3VzZVVwKGV2ZW50KTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGV2ZW50LndoaWNoIHx8IGV2ZW50LmJ1dHRvbikge1xcbiAgICAgICAgdGhpcy5fbW91c2VNb3ZlZCA9IHRydWU7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLl9tb3VzZVN0YXJ0ZWQpIHtcXG4gICAgICAgIHRoaXMuX21vdXNlRHJhZyhldmVudCk7XFxuXFxuICAgICAgICByZXR1cm4gZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMuX21vdXNlRGlzdGFuY2VNZXQoZXZlbnQpICYmIHRoaXMuX21vdXNlRGVsYXlNZXQoZXZlbnQpKSB7XFxuICAgICAgICB0aGlzLl9tb3VzZVN0YXJ0ZWQgPSB0aGlzLl9tb3VzZVN0YXJ0KHRoaXMuX21vdXNlRG93bkV2ZW50LCBldmVudCkgIT09IGZhbHNlO1xcbiAgICAgICAgdGhpcy5fbW91c2VTdGFydGVkID8gdGhpcy5fbW91c2VEcmFnKGV2ZW50KSA6IHRoaXMuX21vdXNlVXAoZXZlbnQpO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gIXRoaXMuX21vdXNlU3RhcnRlZDtcXG4gICAgfSxcXG4gICAgX21vdXNlVXA6IGZ1bmN0aW9uIF9tb3VzZVVwKGV2ZW50KSB7XFxuICAgICAgdGhpcy5kb2N1bWVudC51bmJpbmQoXFxcIm1vdXNlbW92ZS5cXFwiICsgdGhpcy53aWRnZXROYW1lLCB0aGlzLl9tb3VzZU1vdmVEZWxlZ2F0ZSkudW5iaW5kKFxcXCJtb3VzZXVwLlxcXCIgKyB0aGlzLndpZGdldE5hbWUsIHRoaXMuX21vdXNlVXBEZWxlZ2F0ZSk7XFxuXFxuICAgICAgaWYgKHRoaXMuX21vdXNlU3RhcnRlZCkge1xcbiAgICAgICAgdGhpcy5fbW91c2VTdGFydGVkID0gZmFsc2U7XFxuXFxuICAgICAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSB0aGlzLl9tb3VzZURvd25FdmVudC50YXJnZXQpIHtcXG4gICAgICAgICAgJC5kYXRhKGV2ZW50LnRhcmdldCwgdGhpcy53aWRnZXROYW1lICsgXFxcIi5wcmV2ZW50Q2xpY2tFdmVudFxcXCIsIHRydWUpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdGhpcy5fbW91c2VTdG9wKGV2ZW50KTtcXG4gICAgICB9XFxuXFxuICAgICAgbW91c2VIYW5kbGVkID0gZmFsc2U7XFxuICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9LFxcbiAgICBfbW91c2VEaXN0YW5jZU1ldDogZnVuY3Rpb24gX21vdXNlRGlzdGFuY2VNZXQoZXZlbnQpIHtcXG4gICAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5hYnModGhpcy5fbW91c2VEb3duRXZlbnQucGFnZVggLSBldmVudC5wYWdlWCksIE1hdGguYWJzKHRoaXMuX21vdXNlRG93bkV2ZW50LnBhZ2VZIC0gZXZlbnQucGFnZVkpKSA+PSB0aGlzLm9wdGlvbnMuZGlzdGFuY2U7XFxuICAgIH0sXFxuICAgIF9tb3VzZURlbGF5TWV0OiBmdW5jdGlvbiBfbW91c2VEZWxheU1ldCgpXFxuICAgIC8qIGV2ZW50ICovXFxuICAgIHtcXG4gICAgICByZXR1cm4gdGhpcy5tb3VzZURlbGF5TWV0O1xcbiAgICB9LFxcbiAgICAvLyBUaGVzZSBhcmUgcGxhY2Vob2xkZXIgbWV0aG9kcywgdG8gYmUgb3ZlcnJpZGVuIGJ5IGV4dGVuZGluZyBwbHVnaW5cXG4gICAgX21vdXNlU3RhcnQ6IGZ1bmN0aW9uIF9tb3VzZVN0YXJ0KClcXG4gICAgLyogZXZlbnQgKi9cXG4gICAge30sXFxuICAgIF9tb3VzZURyYWc6IGZ1bmN0aW9uIF9tb3VzZURyYWcoKVxcbiAgICAvKiBldmVudCAqL1xcbiAgICB7fSxcXG4gICAgX21vdXNlU3RvcDogZnVuY3Rpb24gX21vdXNlU3RvcCgpXFxuICAgIC8qIGV2ZW50ICovXFxuICAgIHt9LFxcbiAgICBfbW91c2VDYXB0dXJlOiBmdW5jdGlvbiBfbW91c2VDYXB0dXJlKClcXG4gICAgLyogZXZlbnQgKi9cXG4gICAge1xcbiAgICAgIHJldHVybiB0cnVlO1xcbiAgICB9XFxuICB9KTtcXG4gIC8qIVxcbiAgICogalF1ZXJ5IFVJIFBvc2l0aW9uIDEuMTEuNFxcbiAgICogaHR0cDovL2pxdWVyeXVpLmNvbVxcbiAgICpcXG4gICAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXFxuICAgKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXFxuICAgKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXFxuICAgKlxcbiAgICogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20vcG9zaXRpb24vXFxuICAgKi9cXG5cXG4gIChmdW5jdGlvbiAoKSB7XFxuICAgICQudWkgPSAkLnVpIHx8IHt9O1xcbiAgICB2YXIgY2FjaGVkU2Nyb2xsYmFyV2lkdGgsXFxuICAgICAgICBzdXBwb3J0c09mZnNldEZyYWN0aW9ucyxcXG4gICAgICAgIG1heCA9IE1hdGgubWF4LFxcbiAgICAgICAgYWJzID0gTWF0aC5hYnMsXFxuICAgICAgICByb3VuZCA9IE1hdGgucm91bmQsXFxuICAgICAgICByaG9yaXpvbnRhbCA9IC9sZWZ0fGNlbnRlcnxyaWdodC8sXFxuICAgICAgICBydmVydGljYWwgPSAvdG9wfGNlbnRlcnxib3R0b20vLFxcbiAgICAgICAgcm9mZnNldCA9IC9bXFxcXCtcXFxcLV1cXFxcZCsoXFxcXC5bXFxcXGRdKyk/JT8vLFxcbiAgICAgICAgcnBvc2l0aW9uID0gL15cXFxcdysvLFxcbiAgICAgICAgcnBlcmNlbnQgPSAvJSQvLFxcbiAgICAgICAgX3Bvc2l0aW9uID0gJC5mbi5wb3NpdGlvbjtcXG5cXG4gICAgZnVuY3Rpb24gZ2V0T2Zmc2V0cyhvZmZzZXRzLCB3aWR0aCwgaGVpZ2h0KSB7XFxuICAgICAgcmV0dXJuIFtwYXJzZUZsb2F0KG9mZnNldHNbMF0pICogKHJwZXJjZW50LnRlc3Qob2Zmc2V0c1swXSkgPyB3aWR0aCAvIDEwMCA6IDEpLCBwYXJzZUZsb2F0KG9mZnNldHNbMV0pICogKHJwZXJjZW50LnRlc3Qob2Zmc2V0c1sxXSkgPyBoZWlnaHQgLyAxMDAgOiAxKV07XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gcGFyc2VDc3MoZWxlbWVudCwgcHJvcGVydHkpIHtcXG4gICAgICByZXR1cm4gcGFyc2VJbnQoJC5jc3MoZWxlbWVudCwgcHJvcGVydHkpLCAxMCkgfHwgMDtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBnZXREaW1lbnNpb25zKGVsZW0pIHtcXG4gICAgICB2YXIgcmF3ID0gZWxlbVswXTtcXG5cXG4gICAgICBpZiAocmF3Lm5vZGVUeXBlID09PSA5KSB7XFxuICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICB3aWR0aDogZWxlbS53aWR0aCgpLFxcbiAgICAgICAgICBoZWlnaHQ6IGVsZW0uaGVpZ2h0KCksXFxuICAgICAgICAgIG9mZnNldDoge1xcbiAgICAgICAgICAgIHRvcDogMCxcXG4gICAgICAgICAgICBsZWZ0OiAwXFxuICAgICAgICAgIH1cXG4gICAgICAgIH07XFxuICAgICAgfVxcblxcbiAgICAgIGlmICgkLmlzV2luZG93KHJhdykpIHtcXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgIHdpZHRoOiBlbGVtLndpZHRoKCksXFxuICAgICAgICAgIGhlaWdodDogZWxlbS5oZWlnaHQoKSxcXG4gICAgICAgICAgb2Zmc2V0OiB7XFxuICAgICAgICAgICAgdG9wOiBlbGVtLnNjcm9sbFRvcCgpLFxcbiAgICAgICAgICAgIGxlZnQ6IGVsZW0uc2Nyb2xsTGVmdCgpXFxuICAgICAgICAgIH1cXG4gICAgICAgIH07XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChyYXcucHJldmVudERlZmF1bHQpIHtcXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgIHdpZHRoOiAwLFxcbiAgICAgICAgICBoZWlnaHQ6IDAsXFxuICAgICAgICAgIG9mZnNldDoge1xcbiAgICAgICAgICAgIHRvcDogcmF3LnBhZ2VZLFxcbiAgICAgICAgICAgIGxlZnQ6IHJhdy5wYWdlWFxcbiAgICAgICAgICB9XFxuICAgICAgICB9O1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4ge1xcbiAgICAgICAgd2lkdGg6IGVsZW0ub3V0ZXJXaWR0aCgpLFxcbiAgICAgICAgaGVpZ2h0OiBlbGVtLm91dGVySGVpZ2h0KCksXFxuICAgICAgICBvZmZzZXQ6IGVsZW0ub2Zmc2V0KClcXG4gICAgICB9O1xcbiAgICB9XFxuXFxuICAgICQucG9zaXRpb24gPSB7XFxuICAgICAgc2Nyb2xsYmFyV2lkdGg6IGZ1bmN0aW9uIHNjcm9sbGJhcldpZHRoKCkge1xcbiAgICAgICAgaWYgKGNhY2hlZFNjcm9sbGJhcldpZHRoICE9PSB1bmRlZmluZWQpIHtcXG4gICAgICAgICAgcmV0dXJuIGNhY2hlZFNjcm9sbGJhcldpZHRoO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdmFyIHcxLFxcbiAgICAgICAgICAgIHcyLFxcbiAgICAgICAgICAgIGRpdiA9ICQoXFxcIjxkaXYgc3R5bGU9J2Rpc3BsYXk6YmxvY2s7cG9zaXRpb246YWJzb2x1dGU7d2lkdGg6NTBweDtoZWlnaHQ6NTBweDtvdmVyZmxvdzpoaWRkZW47Jz48ZGl2IHN0eWxlPSdoZWlnaHQ6MTAwcHg7d2lkdGg6YXV0bzsnPjwvZGl2PjwvZGl2PlxcXCIpLFxcbiAgICAgICAgICAgIGlubmVyRGl2ID0gZGl2LmNoaWxkcmVuKClbMF07XFxuICAgICAgICAkKFxcXCJib2R5XFxcIikuYXBwZW5kKGRpdik7XFxuICAgICAgICB3MSA9IGlubmVyRGl2Lm9mZnNldFdpZHRoO1xcbiAgICAgICAgZGl2LmNzcyhcXFwib3ZlcmZsb3dcXFwiLCBcXFwic2Nyb2xsXFxcIik7XFxuICAgICAgICB3MiA9IGlubmVyRGl2Lm9mZnNldFdpZHRoO1xcblxcbiAgICAgICAgaWYgKHcxID09PSB3Mikge1xcbiAgICAgICAgICB3MiA9IGRpdlswXS5jbGllbnRXaWR0aDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGRpdi5yZW1vdmUoKTtcXG4gICAgICAgIHJldHVybiBjYWNoZWRTY3JvbGxiYXJXaWR0aCA9IHcxIC0gdzI7XFxuICAgICAgfSxcXG4gICAgICBnZXRTY3JvbGxJbmZvOiBmdW5jdGlvbiBnZXRTY3JvbGxJbmZvKHdpdGhpbikge1xcbiAgICAgICAgdmFyIG92ZXJmbG93WCA9IHdpdGhpbi5pc1dpbmRvdyB8fCB3aXRoaW4uaXNEb2N1bWVudCA/IFxcXCJcXFwiIDogd2l0aGluLmVsZW1lbnQuY3NzKFxcXCJvdmVyZmxvdy14XFxcIiksXFxuICAgICAgICAgICAgb3ZlcmZsb3dZID0gd2l0aGluLmlzV2luZG93IHx8IHdpdGhpbi5pc0RvY3VtZW50ID8gXFxcIlxcXCIgOiB3aXRoaW4uZWxlbWVudC5jc3MoXFxcIm92ZXJmbG93LXlcXFwiKSxcXG4gICAgICAgICAgICBoYXNPdmVyZmxvd1ggPSBvdmVyZmxvd1ggPT09IFxcXCJzY3JvbGxcXFwiIHx8IG92ZXJmbG93WCA9PT0gXFxcImF1dG9cXFwiICYmIHdpdGhpbi53aWR0aCA8IHdpdGhpbi5lbGVtZW50WzBdLnNjcm9sbFdpZHRoLFxcbiAgICAgICAgICAgIGhhc092ZXJmbG93WSA9IG92ZXJmbG93WSA9PT0gXFxcInNjcm9sbFxcXCIgfHwgb3ZlcmZsb3dZID09PSBcXFwiYXV0b1xcXCIgJiYgd2l0aGluLmhlaWdodCA8IHdpdGhpbi5lbGVtZW50WzBdLnNjcm9sbEhlaWdodDtcXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgIHdpZHRoOiBoYXNPdmVyZmxvd1kgPyAkLnBvc2l0aW9uLnNjcm9sbGJhcldpZHRoKCkgOiAwLFxcbiAgICAgICAgICBoZWlnaHQ6IGhhc092ZXJmbG93WCA/ICQucG9zaXRpb24uc2Nyb2xsYmFyV2lkdGgoKSA6IDBcXG4gICAgICAgIH07XFxuICAgICAgfSxcXG4gICAgICBnZXRXaXRoaW5JbmZvOiBmdW5jdGlvbiBnZXRXaXRoaW5JbmZvKGVsZW1lbnQpIHtcXG4gICAgICAgIHZhciB3aXRoaW5FbGVtZW50ID0gJChlbGVtZW50IHx8IHdpbmRvdyksXFxuICAgICAgICAgICAgaXNXaW5kb3cgPSAkLmlzV2luZG93KHdpdGhpbkVsZW1lbnRbMF0pLFxcbiAgICAgICAgICAgIGlzRG9jdW1lbnQgPSAhIXdpdGhpbkVsZW1lbnRbMF0gJiYgd2l0aGluRWxlbWVudFswXS5ub2RlVHlwZSA9PT0gOTtcXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgIGVsZW1lbnQ6IHdpdGhpbkVsZW1lbnQsXFxuICAgICAgICAgIGlzV2luZG93OiBpc1dpbmRvdyxcXG4gICAgICAgICAgaXNEb2N1bWVudDogaXNEb2N1bWVudCxcXG4gICAgICAgICAgb2Zmc2V0OiB3aXRoaW5FbGVtZW50Lm9mZnNldCgpIHx8IHtcXG4gICAgICAgICAgICBsZWZ0OiAwLFxcbiAgICAgICAgICAgIHRvcDogMFxcbiAgICAgICAgICB9LFxcbiAgICAgICAgICBzY3JvbGxMZWZ0OiB3aXRoaW5FbGVtZW50LnNjcm9sbExlZnQoKSxcXG4gICAgICAgICAgc2Nyb2xsVG9wOiB3aXRoaW5FbGVtZW50LnNjcm9sbFRvcCgpLFxcbiAgICAgICAgICAvLyBzdXBwb3J0OiBqUXVlcnkgMS42LnhcXG4gICAgICAgICAgLy8galF1ZXJ5IDEuNiBkb2Vzbid0IHN1cHBvcnQgLm91dGVyV2lkdGgvSGVpZ2h0KCkgb24gZG9jdW1lbnRzIG9yIHdpbmRvd3NcXG4gICAgICAgICAgd2lkdGg6IGlzV2luZG93IHx8IGlzRG9jdW1lbnQgPyB3aXRoaW5FbGVtZW50LndpZHRoKCkgOiB3aXRoaW5FbGVtZW50Lm91dGVyV2lkdGgoKSxcXG4gICAgICAgICAgaGVpZ2h0OiBpc1dpbmRvdyB8fCBpc0RvY3VtZW50ID8gd2l0aGluRWxlbWVudC5oZWlnaHQoKSA6IHdpdGhpbkVsZW1lbnQub3V0ZXJIZWlnaHQoKVxcbiAgICAgICAgfTtcXG4gICAgICB9XFxuICAgIH07XFxuXFxuICAgICQuZm4ucG9zaXRpb24gPSBmdW5jdGlvbiAob3B0aW9ucykge1xcbiAgICAgIGlmICghb3B0aW9ucyB8fCAhb3B0aW9ucy5vZikge1xcbiAgICAgICAgcmV0dXJuIF9wb3NpdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgICAgIH0gLy8gbWFrZSBhIGNvcHksIHdlIGRvbid0IHdhbnQgdG8gbW9kaWZ5IGFyZ3VtZW50c1xcblxcblxcbiAgICAgIG9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgb3B0aW9ucyk7XFxuICAgICAgdmFyIGF0T2Zmc2V0LFxcbiAgICAgICAgICB0YXJnZXRXaWR0aCxcXG4gICAgICAgICAgdGFyZ2V0SGVpZ2h0LFxcbiAgICAgICAgICB0YXJnZXRPZmZzZXQsXFxuICAgICAgICAgIGJhc2VQb3NpdGlvbixcXG4gICAgICAgICAgZGltZW5zaW9ucyxcXG4gICAgICAgICAgdGFyZ2V0ID0gJChvcHRpb25zLm9mKSxcXG4gICAgICAgICAgd2l0aGluID0gJC5wb3NpdGlvbi5nZXRXaXRoaW5JbmZvKG9wdGlvbnMud2l0aGluKSxcXG4gICAgICAgICAgc2Nyb2xsSW5mbyA9ICQucG9zaXRpb24uZ2V0U2Nyb2xsSW5mbyh3aXRoaW4pLFxcbiAgICAgICAgICBjb2xsaXNpb24gPSAob3B0aW9ucy5jb2xsaXNpb24gfHwgXFxcImZsaXBcXFwiKS5zcGxpdChcXFwiIFxcXCIpLFxcbiAgICAgICAgICBvZmZzZXRzID0ge307XFxuICAgICAgZGltZW5zaW9ucyA9IGdldERpbWVuc2lvbnModGFyZ2V0KTtcXG5cXG4gICAgICBpZiAodGFyZ2V0WzBdLnByZXZlbnREZWZhdWx0KSB7XFxuICAgICAgICAvLyBmb3JjZSBsZWZ0IHRvcCB0byBhbGxvdyBmbGlwcGluZ1xcbiAgICAgICAgb3B0aW9ucy5hdCA9IFxcXCJsZWZ0IHRvcFxcXCI7XFxuICAgICAgfVxcblxcbiAgICAgIHRhcmdldFdpZHRoID0gZGltZW5zaW9ucy53aWR0aDtcXG4gICAgICB0YXJnZXRIZWlnaHQgPSBkaW1lbnNpb25zLmhlaWdodDtcXG4gICAgICB0YXJnZXRPZmZzZXQgPSBkaW1lbnNpb25zLm9mZnNldDsgLy8gY2xvbmUgdG8gcmV1c2Ugb3JpZ2luYWwgdGFyZ2V0T2Zmc2V0IGxhdGVyXFxuXFxuICAgICAgYmFzZVBvc2l0aW9uID0gJC5leHRlbmQoe30sIHRhcmdldE9mZnNldCk7IC8vIGZvcmNlIG15IGFuZCBhdCB0byBoYXZlIHZhbGlkIGhvcml6b250YWwgYW5kIHZlcnRpY2FsIHBvc2l0aW9uc1xcbiAgICAgIC8vIGlmIGEgdmFsdWUgaXMgbWlzc2luZyBvciBpbnZhbGlkLCBpdCB3aWxsIGJlIGNvbnZlcnRlZCB0byBjZW50ZXJcXG5cXG4gICAgICAkLmVhY2goW1xcXCJteVxcXCIsIFxcXCJhdFxcXCJdLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgcG9zID0gKG9wdGlvbnNbdGhpc10gfHwgXFxcIlxcXCIpLnNwbGl0KFxcXCIgXFxcIiksXFxuICAgICAgICAgICAgaG9yaXpvbnRhbE9mZnNldCxcXG4gICAgICAgICAgICB2ZXJ0aWNhbE9mZnNldDtcXG5cXG4gICAgICAgIGlmIChwb3MubGVuZ3RoID09PSAxKSB7XFxuICAgICAgICAgIHBvcyA9IHJob3Jpem9udGFsLnRlc3QocG9zWzBdKSA/IHBvcy5jb25jYXQoW1xcXCJjZW50ZXJcXFwiXSkgOiBydmVydGljYWwudGVzdChwb3NbMF0pID8gW1xcXCJjZW50ZXJcXFwiXS5jb25jYXQocG9zKSA6IFtcXFwiY2VudGVyXFxcIiwgXFxcImNlbnRlclxcXCJdO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcG9zWzBdID0gcmhvcml6b250YWwudGVzdChwb3NbMF0pID8gcG9zWzBdIDogXFxcImNlbnRlclxcXCI7XFxuICAgICAgICBwb3NbMV0gPSBydmVydGljYWwudGVzdChwb3NbMV0pID8gcG9zWzFdIDogXFxcImNlbnRlclxcXCI7IC8vIGNhbGN1bGF0ZSBvZmZzZXRzXFxuXFxuICAgICAgICBob3Jpem9udGFsT2Zmc2V0ID0gcm9mZnNldC5leGVjKHBvc1swXSk7XFxuICAgICAgICB2ZXJ0aWNhbE9mZnNldCA9IHJvZmZzZXQuZXhlYyhwb3NbMV0pO1xcbiAgICAgICAgb2Zmc2V0c1t0aGlzXSA9IFtob3Jpem9udGFsT2Zmc2V0ID8gaG9yaXpvbnRhbE9mZnNldFswXSA6IDAsIHZlcnRpY2FsT2Zmc2V0ID8gdmVydGljYWxPZmZzZXRbMF0gOiAwXTsgLy8gcmVkdWNlIHRvIGp1c3QgdGhlIHBvc2l0aW9ucyB3aXRob3V0IHRoZSBvZmZzZXRzXFxuXFxuICAgICAgICBvcHRpb25zW3RoaXNdID0gW3Jwb3NpdGlvbi5leGVjKHBvc1swXSlbMF0sIHJwb3NpdGlvbi5leGVjKHBvc1sxXSlbMF1dO1xcbiAgICAgIH0pOyAvLyBub3JtYWxpemUgY29sbGlzaW9uIG9wdGlvblxcblxcbiAgICAgIGlmIChjb2xsaXNpb24ubGVuZ3RoID09PSAxKSB7XFxuICAgICAgICBjb2xsaXNpb25bMV0gPSBjb2xsaXNpb25bMF07XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChvcHRpb25zLmF0WzBdID09PSBcXFwicmlnaHRcXFwiKSB7XFxuICAgICAgICBiYXNlUG9zaXRpb24ubGVmdCArPSB0YXJnZXRXaWR0aDtcXG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuYXRbMF0gPT09IFxcXCJjZW50ZXJcXFwiKSB7XFxuICAgICAgICBiYXNlUG9zaXRpb24ubGVmdCArPSB0YXJnZXRXaWR0aCAvIDI7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChvcHRpb25zLmF0WzFdID09PSBcXFwiYm90dG9tXFxcIikge1xcbiAgICAgICAgYmFzZVBvc2l0aW9uLnRvcCArPSB0YXJnZXRIZWlnaHQ7XFxuICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmF0WzFdID09PSBcXFwiY2VudGVyXFxcIikge1xcbiAgICAgICAgYmFzZVBvc2l0aW9uLnRvcCArPSB0YXJnZXRIZWlnaHQgLyAyO1xcbiAgICAgIH1cXG5cXG4gICAgICBhdE9mZnNldCA9IGdldE9mZnNldHMob2Zmc2V0cy5hdCwgdGFyZ2V0V2lkdGgsIHRhcmdldEhlaWdodCk7XFxuICAgICAgYmFzZVBvc2l0aW9uLmxlZnQgKz0gYXRPZmZzZXRbMF07XFxuICAgICAgYmFzZVBvc2l0aW9uLnRvcCArPSBhdE9mZnNldFsxXTtcXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciBjb2xsaXNpb25Qb3NpdGlvbixcXG4gICAgICAgICAgICB1c2luZyxcXG4gICAgICAgICAgICBlbGVtID0gJCh0aGlzKSxcXG4gICAgICAgICAgICBlbGVtV2lkdGggPSBlbGVtLm91dGVyV2lkdGgoKSxcXG4gICAgICAgICAgICBlbGVtSGVpZ2h0ID0gZWxlbS5vdXRlckhlaWdodCgpLFxcbiAgICAgICAgICAgIG1hcmdpbkxlZnQgPSBwYXJzZUNzcyh0aGlzLCBcXFwibWFyZ2luTGVmdFxcXCIpLFxcbiAgICAgICAgICAgIG1hcmdpblRvcCA9IHBhcnNlQ3NzKHRoaXMsIFxcXCJtYXJnaW5Ub3BcXFwiKSxcXG4gICAgICAgICAgICBjb2xsaXNpb25XaWR0aCA9IGVsZW1XaWR0aCArIG1hcmdpbkxlZnQgKyBwYXJzZUNzcyh0aGlzLCBcXFwibWFyZ2luUmlnaHRcXFwiKSArIHNjcm9sbEluZm8ud2lkdGgsXFxuICAgICAgICAgICAgY29sbGlzaW9uSGVpZ2h0ID0gZWxlbUhlaWdodCArIG1hcmdpblRvcCArIHBhcnNlQ3NzKHRoaXMsIFxcXCJtYXJnaW5Cb3R0b21cXFwiKSArIHNjcm9sbEluZm8uaGVpZ2h0LFxcbiAgICAgICAgICAgIHBvc2l0aW9uID0gJC5leHRlbmQoe30sIGJhc2VQb3NpdGlvbiksXFxuICAgICAgICAgICAgbXlPZmZzZXQgPSBnZXRPZmZzZXRzKG9mZnNldHMubXksIGVsZW0ub3V0ZXJXaWR0aCgpLCBlbGVtLm91dGVySGVpZ2h0KCkpO1xcblxcbiAgICAgICAgaWYgKG9wdGlvbnMubXlbMF0gPT09IFxcXCJyaWdodFxcXCIpIHtcXG4gICAgICAgICAgcG9zaXRpb24ubGVmdCAtPSBlbGVtV2lkdGg7XFxuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMubXlbMF0gPT09IFxcXCJjZW50ZXJcXFwiKSB7XFxuICAgICAgICAgIHBvc2l0aW9uLmxlZnQgLT0gZWxlbVdpZHRoIC8gMjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChvcHRpb25zLm15WzFdID09PSBcXFwiYm90dG9tXFxcIikge1xcbiAgICAgICAgICBwb3NpdGlvbi50b3AgLT0gZWxlbUhlaWdodDtcXG4gICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5teVsxXSA9PT0gXFxcImNlbnRlclxcXCIpIHtcXG4gICAgICAgICAgcG9zaXRpb24udG9wIC09IGVsZW1IZWlnaHQgLyAyO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcG9zaXRpb24ubGVmdCArPSBteU9mZnNldFswXTtcXG4gICAgICAgIHBvc2l0aW9uLnRvcCArPSBteU9mZnNldFsxXTsgLy8gaWYgdGhlIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IGZyYWN0aW9ucywgdGhlbiByb3VuZCBmb3IgY29uc2lzdGVudCByZXN1bHRzXFxuXFxuICAgICAgICBpZiAoIXN1cHBvcnRzT2Zmc2V0RnJhY3Rpb25zKSB7XFxuICAgICAgICAgIHBvc2l0aW9uLmxlZnQgPSByb3VuZChwb3NpdGlvbi5sZWZ0KTtcXG4gICAgICAgICAgcG9zaXRpb24udG9wID0gcm91bmQocG9zaXRpb24udG9wKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGNvbGxpc2lvblBvc2l0aW9uID0ge1xcbiAgICAgICAgICBtYXJnaW5MZWZ0OiBtYXJnaW5MZWZ0LFxcbiAgICAgICAgICBtYXJnaW5Ub3A6IG1hcmdpblRvcFxcbiAgICAgICAgfTtcXG4gICAgICAgICQuZWFjaChbXFxcImxlZnRcXFwiLCBcXFwidG9wXFxcIl0sIGZ1bmN0aW9uIChpLCBkaXIpIHtcXG4gICAgICAgICAgaWYgKCQudWkucG9zaXRpb25bY29sbGlzaW9uW2ldXSkge1xcbiAgICAgICAgICAgICQudWkucG9zaXRpb25bY29sbGlzaW9uW2ldXVtkaXJdKHBvc2l0aW9uLCB7XFxuICAgICAgICAgICAgICB0YXJnZXRXaWR0aDogdGFyZ2V0V2lkdGgsXFxuICAgICAgICAgICAgICB0YXJnZXRIZWlnaHQ6IHRhcmdldEhlaWdodCxcXG4gICAgICAgICAgICAgIGVsZW1XaWR0aDogZWxlbVdpZHRoLFxcbiAgICAgICAgICAgICAgZWxlbUhlaWdodDogZWxlbUhlaWdodCxcXG4gICAgICAgICAgICAgIGNvbGxpc2lvblBvc2l0aW9uOiBjb2xsaXNpb25Qb3NpdGlvbixcXG4gICAgICAgICAgICAgIGNvbGxpc2lvbldpZHRoOiBjb2xsaXNpb25XaWR0aCxcXG4gICAgICAgICAgICAgIGNvbGxpc2lvbkhlaWdodDogY29sbGlzaW9uSGVpZ2h0LFxcbiAgICAgICAgICAgICAgb2Zmc2V0OiBbYXRPZmZzZXRbMF0gKyBteU9mZnNldFswXSwgYXRPZmZzZXRbMV0gKyBteU9mZnNldFsxXV0sXFxuICAgICAgICAgICAgICBteTogb3B0aW9ucy5teSxcXG4gICAgICAgICAgICAgIGF0OiBvcHRpb25zLmF0LFxcbiAgICAgICAgICAgICAgd2l0aGluOiB3aXRoaW4sXFxuICAgICAgICAgICAgICBlbGVtOiBlbGVtXFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcblxcbiAgICAgICAgaWYgKG9wdGlvbnMudXNpbmcpIHtcXG4gICAgICAgICAgLy8gYWRkcyBmZWVkYmFjayBhcyBzZWNvbmQgYXJndW1lbnQgdG8gdXNpbmcgY2FsbGJhY2ssIGlmIHByZXNlbnRcXG4gICAgICAgICAgdXNpbmcgPSBmdW5jdGlvbiB1c2luZyhwcm9wcykge1xcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gdGFyZ2V0T2Zmc2V0LmxlZnQgLSBwb3NpdGlvbi5sZWZ0LFxcbiAgICAgICAgICAgICAgICByaWdodCA9IGxlZnQgKyB0YXJnZXRXaWR0aCAtIGVsZW1XaWR0aCxcXG4gICAgICAgICAgICAgICAgdG9wID0gdGFyZ2V0T2Zmc2V0LnRvcCAtIHBvc2l0aW9uLnRvcCxcXG4gICAgICAgICAgICAgICAgYm90dG9tID0gdG9wICsgdGFyZ2V0SGVpZ2h0IC0gZWxlbUhlaWdodCxcXG4gICAgICAgICAgICAgICAgZmVlZGJhY2sgPSB7XFxuICAgICAgICAgICAgICB0YXJnZXQ6IHtcXG4gICAgICAgICAgICAgICAgZWxlbWVudDogdGFyZ2V0LFxcbiAgICAgICAgICAgICAgICBsZWZ0OiB0YXJnZXRPZmZzZXQubGVmdCxcXG4gICAgICAgICAgICAgICAgdG9wOiB0YXJnZXRPZmZzZXQudG9wLFxcbiAgICAgICAgICAgICAgICB3aWR0aDogdGFyZ2V0V2lkdGgsXFxuICAgICAgICAgICAgICAgIGhlaWdodDogdGFyZ2V0SGVpZ2h0XFxuICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgZWxlbWVudDoge1xcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBlbGVtLFxcbiAgICAgICAgICAgICAgICBsZWZ0OiBwb3NpdGlvbi5sZWZ0LFxcbiAgICAgICAgICAgICAgICB0b3A6IHBvc2l0aW9uLnRvcCxcXG4gICAgICAgICAgICAgICAgd2lkdGg6IGVsZW1XaWR0aCxcXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBlbGVtSGVpZ2h0XFxuICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgaG9yaXpvbnRhbDogcmlnaHQgPCAwID8gXFxcImxlZnRcXFwiIDogbGVmdCA+IDAgPyBcXFwicmlnaHRcXFwiIDogXFxcImNlbnRlclxcXCIsXFxuICAgICAgICAgICAgICB2ZXJ0aWNhbDogYm90dG9tIDwgMCA/IFxcXCJ0b3BcXFwiIDogdG9wID4gMCA/IFxcXCJib3R0b21cXFwiIDogXFxcIm1pZGRsZVxcXCJcXG4gICAgICAgICAgICB9O1xcblxcbiAgICAgICAgICAgIGlmICh0YXJnZXRXaWR0aCA8IGVsZW1XaWR0aCAmJiBhYnMobGVmdCArIHJpZ2h0KSA8IHRhcmdldFdpZHRoKSB7XFxuICAgICAgICAgICAgICBmZWVkYmFjay5ob3Jpem9udGFsID0gXFxcImNlbnRlclxcXCI7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmICh0YXJnZXRIZWlnaHQgPCBlbGVtSGVpZ2h0ICYmIGFicyh0b3AgKyBib3R0b20pIDwgdGFyZ2V0SGVpZ2h0KSB7XFxuICAgICAgICAgICAgICBmZWVkYmFjay52ZXJ0aWNhbCA9IFxcXCJtaWRkbGVcXFwiO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpZiAobWF4KGFicyhsZWZ0KSwgYWJzKHJpZ2h0KSkgPiBtYXgoYWJzKHRvcCksIGFicyhib3R0b20pKSkge1xcbiAgICAgICAgICAgICAgZmVlZGJhY2suaW1wb3J0YW50ID0gXFxcImhvcml6b250YWxcXFwiO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICBmZWVkYmFjay5pbXBvcnRhbnQgPSBcXFwidmVydGljYWxcXFwiO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBvcHRpb25zLnVzaW5nLmNhbGwodGhpcywgcHJvcHMsIGZlZWRiYWNrKTtcXG4gICAgICAgICAgfTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGVsZW0ub2Zmc2V0KCQuZXh0ZW5kKHBvc2l0aW9uLCB7XFxuICAgICAgICAgIHVzaW5nOiB1c2luZ1xcbiAgICAgICAgfSkpO1xcbiAgICAgIH0pO1xcbiAgICB9O1xcblxcbiAgICAkLnVpLnBvc2l0aW9uID0ge1xcbiAgICAgIGZpdDoge1xcbiAgICAgICAgbGVmdDogZnVuY3Rpb24gbGVmdChwb3NpdGlvbiwgZGF0YSkge1xcbiAgICAgICAgICB2YXIgd2l0aGluID0gZGF0YS53aXRoaW4sXFxuICAgICAgICAgICAgICB3aXRoaW5PZmZzZXQgPSB3aXRoaW4uaXNXaW5kb3cgPyB3aXRoaW4uc2Nyb2xsTGVmdCA6IHdpdGhpbi5vZmZzZXQubGVmdCxcXG4gICAgICAgICAgICAgIG91dGVyV2lkdGggPSB3aXRoaW4ud2lkdGgsXFxuICAgICAgICAgICAgICBjb2xsaXNpb25Qb3NMZWZ0ID0gcG9zaXRpb24ubGVmdCAtIGRhdGEuY29sbGlzaW9uUG9zaXRpb24ubWFyZ2luTGVmdCxcXG4gICAgICAgICAgICAgIG92ZXJMZWZ0ID0gd2l0aGluT2Zmc2V0IC0gY29sbGlzaW9uUG9zTGVmdCxcXG4gICAgICAgICAgICAgIG92ZXJSaWdodCA9IGNvbGxpc2lvblBvc0xlZnQgKyBkYXRhLmNvbGxpc2lvbldpZHRoIC0gb3V0ZXJXaWR0aCAtIHdpdGhpbk9mZnNldCxcXG4gICAgICAgICAgICAgIG5ld092ZXJSaWdodDsgLy8gZWxlbWVudCBpcyB3aWRlciB0aGFuIHdpdGhpblxcblxcbiAgICAgICAgICBpZiAoZGF0YS5jb2xsaXNpb25XaWR0aCA+IG91dGVyV2lkdGgpIHtcXG4gICAgICAgICAgICAvLyBlbGVtZW50IGlzIGluaXRpYWxseSBvdmVyIHRoZSBsZWZ0IHNpZGUgb2Ygd2l0aGluXFxuICAgICAgICAgICAgaWYgKG92ZXJMZWZ0ID4gMCAmJiBvdmVyUmlnaHQgPD0gMCkge1xcbiAgICAgICAgICAgICAgbmV3T3ZlclJpZ2h0ID0gcG9zaXRpb24ubGVmdCArIG92ZXJMZWZ0ICsgZGF0YS5jb2xsaXNpb25XaWR0aCAtIG91dGVyV2lkdGggLSB3aXRoaW5PZmZzZXQ7XFxuICAgICAgICAgICAgICBwb3NpdGlvbi5sZWZ0ICs9IG92ZXJMZWZ0IC0gbmV3T3ZlclJpZ2h0OyAvLyBlbGVtZW50IGlzIGluaXRpYWxseSBvdmVyIHJpZ2h0IHNpZGUgb2Ygd2l0aGluXFxuICAgICAgICAgICAgfSBlbHNlIGlmIChvdmVyUmlnaHQgPiAwICYmIG92ZXJMZWZ0IDw9IDApIHtcXG4gICAgICAgICAgICAgIHBvc2l0aW9uLmxlZnQgPSB3aXRoaW5PZmZzZXQ7IC8vIGVsZW1lbnQgaXMgaW5pdGlhbGx5IG92ZXIgYm90aCBsZWZ0IGFuZCByaWdodCBzaWRlcyBvZiB3aXRoaW5cXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgaWYgKG92ZXJMZWZ0ID4gb3ZlclJpZ2h0KSB7XFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uLmxlZnQgPSB3aXRoaW5PZmZzZXQgKyBvdXRlcldpZHRoIC0gZGF0YS5jb2xsaXNpb25XaWR0aDtcXG4gICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uLmxlZnQgPSB3aXRoaW5PZmZzZXQ7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSAvLyB0b28gZmFyIGxlZnQgLT4gYWxpZ24gd2l0aCBsZWZ0IGVkZ2VcXG5cXG4gICAgICAgICAgfSBlbHNlIGlmIChvdmVyTGVmdCA+IDApIHtcXG4gICAgICAgICAgICBwb3NpdGlvbi5sZWZ0ICs9IG92ZXJMZWZ0OyAvLyB0b28gZmFyIHJpZ2h0IC0+IGFsaWduIHdpdGggcmlnaHQgZWRnZVxcbiAgICAgICAgICB9IGVsc2UgaWYgKG92ZXJSaWdodCA+IDApIHtcXG4gICAgICAgICAgICBwb3NpdGlvbi5sZWZ0IC09IG92ZXJSaWdodDsgLy8gYWRqdXN0IGJhc2VkIG9uIHBvc2l0aW9uIGFuZCBtYXJnaW5cXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBwb3NpdGlvbi5sZWZ0ID0gbWF4KHBvc2l0aW9uLmxlZnQgLSBjb2xsaXNpb25Qb3NMZWZ0LCBwb3NpdGlvbi5sZWZ0KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSxcXG4gICAgICAgIHRvcDogZnVuY3Rpb24gdG9wKHBvc2l0aW9uLCBkYXRhKSB7XFxuICAgICAgICAgIHZhciB3aXRoaW4gPSBkYXRhLndpdGhpbixcXG4gICAgICAgICAgICAgIHdpdGhpbk9mZnNldCA9IHdpdGhpbi5pc1dpbmRvdyA/IHdpdGhpbi5zY3JvbGxUb3AgOiB3aXRoaW4ub2Zmc2V0LnRvcCxcXG4gICAgICAgICAgICAgIG91dGVySGVpZ2h0ID0gZGF0YS53aXRoaW4uaGVpZ2h0LFxcbiAgICAgICAgICAgICAgY29sbGlzaW9uUG9zVG9wID0gcG9zaXRpb24udG9wIC0gZGF0YS5jb2xsaXNpb25Qb3NpdGlvbi5tYXJnaW5Ub3AsXFxuICAgICAgICAgICAgICBvdmVyVG9wID0gd2l0aGluT2Zmc2V0IC0gY29sbGlzaW9uUG9zVG9wLFxcbiAgICAgICAgICAgICAgb3ZlckJvdHRvbSA9IGNvbGxpc2lvblBvc1RvcCArIGRhdGEuY29sbGlzaW9uSGVpZ2h0IC0gb3V0ZXJIZWlnaHQgLSB3aXRoaW5PZmZzZXQsXFxuICAgICAgICAgICAgICBuZXdPdmVyQm90dG9tOyAvLyBlbGVtZW50IGlzIHRhbGxlciB0aGFuIHdpdGhpblxcblxcbiAgICAgICAgICBpZiAoZGF0YS5jb2xsaXNpb25IZWlnaHQgPiBvdXRlckhlaWdodCkge1xcbiAgICAgICAgICAgIC8vIGVsZW1lbnQgaXMgaW5pdGlhbGx5IG92ZXIgdGhlIHRvcCBvZiB3aXRoaW5cXG4gICAgICAgICAgICBpZiAob3ZlclRvcCA+IDAgJiYgb3ZlckJvdHRvbSA8PSAwKSB7XFxuICAgICAgICAgICAgICBuZXdPdmVyQm90dG9tID0gcG9zaXRpb24udG9wICsgb3ZlclRvcCArIGRhdGEuY29sbGlzaW9uSGVpZ2h0IC0gb3V0ZXJIZWlnaHQgLSB3aXRoaW5PZmZzZXQ7XFxuICAgICAgICAgICAgICBwb3NpdGlvbi50b3AgKz0gb3ZlclRvcCAtIG5ld092ZXJCb3R0b207IC8vIGVsZW1lbnQgaXMgaW5pdGlhbGx5IG92ZXIgYm90dG9tIG9mIHdpdGhpblxcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3ZlckJvdHRvbSA+IDAgJiYgb3ZlclRvcCA8PSAwKSB7XFxuICAgICAgICAgICAgICBwb3NpdGlvbi50b3AgPSB3aXRoaW5PZmZzZXQ7IC8vIGVsZW1lbnQgaXMgaW5pdGlhbGx5IG92ZXIgYm90aCB0b3AgYW5kIGJvdHRvbSBvZiB3aXRoaW5cXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgaWYgKG92ZXJUb3AgPiBvdmVyQm90dG9tKSB7XFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uLnRvcCA9IHdpdGhpbk9mZnNldCArIG91dGVySGVpZ2h0IC0gZGF0YS5jb2xsaXNpb25IZWlnaHQ7XFxuICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICBwb3NpdGlvbi50b3AgPSB3aXRoaW5PZmZzZXQ7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSAvLyB0b28gZmFyIHVwIC0+IGFsaWduIHdpdGggdG9wXFxuXFxuICAgICAgICAgIH0gZWxzZSBpZiAob3ZlclRvcCA+IDApIHtcXG4gICAgICAgICAgICBwb3NpdGlvbi50b3AgKz0gb3ZlclRvcDsgLy8gdG9vIGZhciBkb3duIC0+IGFsaWduIHdpdGggYm90dG9tIGVkZ2VcXG4gICAgICAgICAgfSBlbHNlIGlmIChvdmVyQm90dG9tID4gMCkge1xcbiAgICAgICAgICAgIHBvc2l0aW9uLnRvcCAtPSBvdmVyQm90dG9tOyAvLyBhZGp1c3QgYmFzZWQgb24gcG9zaXRpb24gYW5kIG1hcmdpblxcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHBvc2l0aW9uLnRvcCA9IG1heChwb3NpdGlvbi50b3AgLSBjb2xsaXNpb25Qb3NUb3AsIHBvc2l0aW9uLnRvcCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9LFxcbiAgICAgIGZsaXA6IHtcXG4gICAgICAgIGxlZnQ6IGZ1bmN0aW9uIGxlZnQocG9zaXRpb24sIGRhdGEpIHtcXG4gICAgICAgICAgdmFyIHdpdGhpbiA9IGRhdGEud2l0aGluLFxcbiAgICAgICAgICAgICAgd2l0aGluT2Zmc2V0ID0gd2l0aGluLm9mZnNldC5sZWZ0ICsgd2l0aGluLnNjcm9sbExlZnQsXFxuICAgICAgICAgICAgICBvdXRlcldpZHRoID0gd2l0aGluLndpZHRoLFxcbiAgICAgICAgICAgICAgb2Zmc2V0TGVmdCA9IHdpdGhpbi5pc1dpbmRvdyA/IHdpdGhpbi5zY3JvbGxMZWZ0IDogd2l0aGluLm9mZnNldC5sZWZ0LFxcbiAgICAgICAgICAgICAgY29sbGlzaW9uUG9zTGVmdCA9IHBvc2l0aW9uLmxlZnQgLSBkYXRhLmNvbGxpc2lvblBvc2l0aW9uLm1hcmdpbkxlZnQsXFxuICAgICAgICAgICAgICBvdmVyTGVmdCA9IGNvbGxpc2lvblBvc0xlZnQgLSBvZmZzZXRMZWZ0LFxcbiAgICAgICAgICAgICAgb3ZlclJpZ2h0ID0gY29sbGlzaW9uUG9zTGVmdCArIGRhdGEuY29sbGlzaW9uV2lkdGggLSBvdXRlcldpZHRoIC0gb2Zmc2V0TGVmdCxcXG4gICAgICAgICAgICAgIG15T2Zmc2V0ID0gZGF0YS5teVswXSA9PT0gXFxcImxlZnRcXFwiID8gLWRhdGEuZWxlbVdpZHRoIDogZGF0YS5teVswXSA9PT0gXFxcInJpZ2h0XFxcIiA/IGRhdGEuZWxlbVdpZHRoIDogMCxcXG4gICAgICAgICAgICAgIGF0T2Zmc2V0ID0gZGF0YS5hdFswXSA9PT0gXFxcImxlZnRcXFwiID8gZGF0YS50YXJnZXRXaWR0aCA6IGRhdGEuYXRbMF0gPT09IFxcXCJyaWdodFxcXCIgPyAtZGF0YS50YXJnZXRXaWR0aCA6IDAsXFxuICAgICAgICAgICAgICBvZmZzZXQgPSAtMiAqIGRhdGEub2Zmc2V0WzBdLFxcbiAgICAgICAgICAgICAgbmV3T3ZlclJpZ2h0LFxcbiAgICAgICAgICAgICAgbmV3T3ZlckxlZnQ7XFxuXFxuICAgICAgICAgIGlmIChvdmVyTGVmdCA8IDApIHtcXG4gICAgICAgICAgICBuZXdPdmVyUmlnaHQgPSBwb3NpdGlvbi5sZWZ0ICsgbXlPZmZzZXQgKyBhdE9mZnNldCArIG9mZnNldCArIGRhdGEuY29sbGlzaW9uV2lkdGggLSBvdXRlcldpZHRoIC0gd2l0aGluT2Zmc2V0O1xcblxcbiAgICAgICAgICAgIGlmIChuZXdPdmVyUmlnaHQgPCAwIHx8IG5ld092ZXJSaWdodCA8IGFicyhvdmVyTGVmdCkpIHtcXG4gICAgICAgICAgICAgIHBvc2l0aW9uLmxlZnQgKz0gbXlPZmZzZXQgKyBhdE9mZnNldCArIG9mZnNldDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH0gZWxzZSBpZiAob3ZlclJpZ2h0ID4gMCkge1xcbiAgICAgICAgICAgIG5ld092ZXJMZWZ0ID0gcG9zaXRpb24ubGVmdCAtIGRhdGEuY29sbGlzaW9uUG9zaXRpb24ubWFyZ2luTGVmdCArIG15T2Zmc2V0ICsgYXRPZmZzZXQgKyBvZmZzZXQgLSBvZmZzZXRMZWZ0O1xcblxcbiAgICAgICAgICAgIGlmIChuZXdPdmVyTGVmdCA+IDAgfHwgYWJzKG5ld092ZXJMZWZ0KSA8IG92ZXJSaWdodCkge1xcbiAgICAgICAgICAgICAgcG9zaXRpb24ubGVmdCArPSBteU9mZnNldCArIGF0T2Zmc2V0ICsgb2Zmc2V0O1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfSxcXG4gICAgICAgIHRvcDogZnVuY3Rpb24gdG9wKHBvc2l0aW9uLCBkYXRhKSB7XFxuICAgICAgICAgIHZhciB3aXRoaW4gPSBkYXRhLndpdGhpbixcXG4gICAgICAgICAgICAgIHdpdGhpbk9mZnNldCA9IHdpdGhpbi5vZmZzZXQudG9wICsgd2l0aGluLnNjcm9sbFRvcCxcXG4gICAgICAgICAgICAgIG91dGVySGVpZ2h0ID0gd2l0aGluLmhlaWdodCxcXG4gICAgICAgICAgICAgIG9mZnNldFRvcCA9IHdpdGhpbi5pc1dpbmRvdyA/IHdpdGhpbi5zY3JvbGxUb3AgOiB3aXRoaW4ub2Zmc2V0LnRvcCxcXG4gICAgICAgICAgICAgIGNvbGxpc2lvblBvc1RvcCA9IHBvc2l0aW9uLnRvcCAtIGRhdGEuY29sbGlzaW9uUG9zaXRpb24ubWFyZ2luVG9wLFxcbiAgICAgICAgICAgICAgb3ZlclRvcCA9IGNvbGxpc2lvblBvc1RvcCAtIG9mZnNldFRvcCxcXG4gICAgICAgICAgICAgIG92ZXJCb3R0b20gPSBjb2xsaXNpb25Qb3NUb3AgKyBkYXRhLmNvbGxpc2lvbkhlaWdodCAtIG91dGVySGVpZ2h0IC0gb2Zmc2V0VG9wLFxcbiAgICAgICAgICAgICAgdG9wID0gZGF0YS5teVsxXSA9PT0gXFxcInRvcFxcXCIsXFxuICAgICAgICAgICAgICBteU9mZnNldCA9IHRvcCA/IC1kYXRhLmVsZW1IZWlnaHQgOiBkYXRhLm15WzFdID09PSBcXFwiYm90dG9tXFxcIiA/IGRhdGEuZWxlbUhlaWdodCA6IDAsXFxuICAgICAgICAgICAgICBhdE9mZnNldCA9IGRhdGEuYXRbMV0gPT09IFxcXCJ0b3BcXFwiID8gZGF0YS50YXJnZXRIZWlnaHQgOiBkYXRhLmF0WzFdID09PSBcXFwiYm90dG9tXFxcIiA/IC1kYXRhLnRhcmdldEhlaWdodCA6IDAsXFxuICAgICAgICAgICAgICBvZmZzZXQgPSAtMiAqIGRhdGEub2Zmc2V0WzFdLFxcbiAgICAgICAgICAgICAgbmV3T3ZlclRvcCxcXG4gICAgICAgICAgICAgIG5ld092ZXJCb3R0b207XFxuXFxuICAgICAgICAgIGlmIChvdmVyVG9wIDwgMCkge1xcbiAgICAgICAgICAgIG5ld092ZXJCb3R0b20gPSBwb3NpdGlvbi50b3AgKyBteU9mZnNldCArIGF0T2Zmc2V0ICsgb2Zmc2V0ICsgZGF0YS5jb2xsaXNpb25IZWlnaHQgLSBvdXRlckhlaWdodCAtIHdpdGhpbk9mZnNldDtcXG5cXG4gICAgICAgICAgICBpZiAobmV3T3ZlckJvdHRvbSA8IDAgfHwgbmV3T3ZlckJvdHRvbSA8IGFicyhvdmVyVG9wKSkge1xcbiAgICAgICAgICAgICAgcG9zaXRpb24udG9wICs9IG15T2Zmc2V0ICsgYXRPZmZzZXQgKyBvZmZzZXQ7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9IGVsc2UgaWYgKG92ZXJCb3R0b20gPiAwKSB7XFxuICAgICAgICAgICAgbmV3T3ZlclRvcCA9IHBvc2l0aW9uLnRvcCAtIGRhdGEuY29sbGlzaW9uUG9zaXRpb24ubWFyZ2luVG9wICsgbXlPZmZzZXQgKyBhdE9mZnNldCArIG9mZnNldCAtIG9mZnNldFRvcDtcXG5cXG4gICAgICAgICAgICBpZiAobmV3T3ZlclRvcCA+IDAgfHwgYWJzKG5ld092ZXJUb3ApIDwgb3ZlckJvdHRvbSkge1xcbiAgICAgICAgICAgICAgcG9zaXRpb24udG9wICs9IG15T2Zmc2V0ICsgYXRPZmZzZXQgKyBvZmZzZXQ7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfSxcXG4gICAgICBmbGlwZml0OiB7XFxuICAgICAgICBsZWZ0OiBmdW5jdGlvbiBsZWZ0KCkge1xcbiAgICAgICAgICAkLnVpLnBvc2l0aW9uLmZsaXAubGVmdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgICAgICAgICAkLnVpLnBvc2l0aW9uLmZpdC5sZWZ0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICAgICAgICB9LFxcbiAgICAgICAgdG9wOiBmdW5jdGlvbiB0b3AoKSB7XFxuICAgICAgICAgICQudWkucG9zaXRpb24uZmxpcC50b3AuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gICAgICAgICAgJC51aS5wb3NpdGlvbi5maXQudG9wLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9OyAvLyBmcmFjdGlvbiBzdXBwb3J0IHRlc3RcXG5cXG4gICAgKGZ1bmN0aW9uICgpIHtcXG4gICAgICB2YXIgdGVzdEVsZW1lbnQsXFxuICAgICAgICAgIHRlc3RFbGVtZW50UGFyZW50LFxcbiAgICAgICAgICB0ZXN0RWxlbWVudFN0eWxlLFxcbiAgICAgICAgICBvZmZzZXRMZWZ0LFxcbiAgICAgICAgICBpLFxcbiAgICAgICAgICBib2R5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXFxcImJvZHlcXFwiKVswXSxcXG4gICAgICAgICAgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwiZGl2XFxcIik7IC8vQ3JlYXRlIGEgXFxcImZha2UgYm9keVxcXCIgZm9yIHRlc3RpbmcgYmFzZWQgb24gbWV0aG9kIHVzZWQgaW4galF1ZXJ5LnN1cHBvcnRcXG5cXG4gICAgICB0ZXN0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoYm9keSA/IFxcXCJkaXZcXFwiIDogXFxcImJvZHlcXFwiKTtcXG4gICAgICB0ZXN0RWxlbWVudFN0eWxlID0ge1xcbiAgICAgICAgdmlzaWJpbGl0eTogXFxcImhpZGRlblxcXCIsXFxuICAgICAgICB3aWR0aDogMCxcXG4gICAgICAgIGhlaWdodDogMCxcXG4gICAgICAgIGJvcmRlcjogMCxcXG4gICAgICAgIG1hcmdpbjogMCxcXG4gICAgICAgIGJhY2tncm91bmQ6IFxcXCJub25lXFxcIlxcbiAgICAgIH07XFxuXFxuICAgICAgaWYgKGJvZHkpIHtcXG4gICAgICAgICQuZXh0ZW5kKHRlc3RFbGVtZW50U3R5bGUsIHtcXG4gICAgICAgICAgcG9zaXRpb246IFxcXCJhYnNvbHV0ZVxcXCIsXFxuICAgICAgICAgIGxlZnQ6IFxcXCItMTAwMHB4XFxcIixcXG4gICAgICAgICAgdG9wOiBcXFwiLTEwMDBweFxcXCJcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG5cXG4gICAgICBmb3IgKGkgaW4gdGVzdEVsZW1lbnRTdHlsZSkge1xcbiAgICAgICAgdGVzdEVsZW1lbnQuc3R5bGVbaV0gPSB0ZXN0RWxlbWVudFN0eWxlW2ldO1xcbiAgICAgIH1cXG5cXG4gICAgICB0ZXN0RWxlbWVudC5hcHBlbmRDaGlsZChkaXYpO1xcbiAgICAgIHRlc3RFbGVtZW50UGFyZW50ID0gYm9keSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XFxuICAgICAgdGVzdEVsZW1lbnRQYXJlbnQuaW5zZXJ0QmVmb3JlKHRlc3RFbGVtZW50LCB0ZXN0RWxlbWVudFBhcmVudC5maXJzdENoaWxkKTtcXG4gICAgICBkaXYuc3R5bGUuY3NzVGV4dCA9IFxcXCJwb3NpdGlvbjogYWJzb2x1dGU7IGxlZnQ6IDEwLjc0MzIyMjJweDtcXFwiO1xcbiAgICAgIG9mZnNldExlZnQgPSAkKGRpdikub2Zmc2V0KCkubGVmdDtcXG4gICAgICBzdXBwb3J0c09mZnNldEZyYWN0aW9ucyA9IG9mZnNldExlZnQgPiAxMCAmJiBvZmZzZXRMZWZ0IDwgMTE7XFxuICAgICAgdGVzdEVsZW1lbnQuaW5uZXJIVE1MID0gXFxcIlxcXCI7XFxuICAgICAgdGVzdEVsZW1lbnRQYXJlbnQucmVtb3ZlQ2hpbGQodGVzdEVsZW1lbnQpO1xcbiAgICB9KSgpO1xcbiAgfSkoKTtcXG5cXG4gIHZhciBwb3NpdGlvbiA9ICQudWkucG9zaXRpb247XFxuICAvKiFcXG4gICAqIGpRdWVyeSBVSSBBY2NvcmRpb24gMS4xMS40XFxuICAgKiBodHRwOi8vanF1ZXJ5dWkuY29tXFxuICAgKlxcbiAgICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcXG4gICAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cXG4gICAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcXG4gICAqXFxuICAgKiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9hY2NvcmRpb24vXFxuICAgKi9cXG5cXG4gIHZhciBhY2NvcmRpb24gPSAkLndpZGdldChcXFwidWkuYWNjb3JkaW9uXFxcIiwge1xcbiAgICB2ZXJzaW9uOiBcXFwiMS4xMS40XFxcIixcXG4gICAgb3B0aW9uczoge1xcbiAgICAgIGFjdGl2ZTogMCxcXG4gICAgICBhbmltYXRlOiB7fSxcXG4gICAgICBjb2xsYXBzaWJsZTogZmFsc2UsXFxuICAgICAgZXZlbnQ6IFxcXCJjbGlja1xcXCIsXFxuICAgICAgaGVhZGVyOiBcXFwiPiBsaSA+IDpmaXJzdC1jaGlsZCw+IDpub3QobGkpOmV2ZW5cXFwiLFxcbiAgICAgIGhlaWdodFN0eWxlOiBcXFwiYXV0b1xcXCIsXFxuICAgICAgaWNvbnM6IHtcXG4gICAgICAgIGFjdGl2ZUhlYWRlcjogXFxcInVpLWljb24tdHJpYW5nbGUtMS1zXFxcIixcXG4gICAgICAgIGhlYWRlcjogXFxcInVpLWljb24tdHJpYW5nbGUtMS1lXFxcIlxcbiAgICAgIH0sXFxuICAgICAgLy8gY2FsbGJhY2tzXFxuICAgICAgYWN0aXZhdGU6IG51bGwsXFxuICAgICAgYmVmb3JlQWN0aXZhdGU6IG51bGxcXG4gICAgfSxcXG4gICAgaGlkZVByb3BzOiB7XFxuICAgICAgYm9yZGVyVG9wV2lkdGg6IFxcXCJoaWRlXFxcIixcXG4gICAgICBib3JkZXJCb3R0b21XaWR0aDogXFxcImhpZGVcXFwiLFxcbiAgICAgIHBhZGRpbmdUb3A6IFxcXCJoaWRlXFxcIixcXG4gICAgICBwYWRkaW5nQm90dG9tOiBcXFwiaGlkZVxcXCIsXFxuICAgICAgaGVpZ2h0OiBcXFwiaGlkZVxcXCJcXG4gICAgfSxcXG4gICAgc2hvd1Byb3BzOiB7XFxuICAgICAgYm9yZGVyVG9wV2lkdGg6IFxcXCJzaG93XFxcIixcXG4gICAgICBib3JkZXJCb3R0b21XaWR0aDogXFxcInNob3dcXFwiLFxcbiAgICAgIHBhZGRpbmdUb3A6IFxcXCJzaG93XFxcIixcXG4gICAgICBwYWRkaW5nQm90dG9tOiBcXFwic2hvd1xcXCIsXFxuICAgICAgaGVpZ2h0OiBcXFwic2hvd1xcXCJcXG4gICAgfSxcXG4gICAgX2NyZWF0ZTogZnVuY3Rpb24gX2NyZWF0ZSgpIHtcXG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcXG4gICAgICB0aGlzLnByZXZTaG93ID0gdGhpcy5wcmV2SGlkZSA9ICQoKTtcXG4gICAgICB0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoXFxcInVpLWFjY29yZGlvbiB1aS13aWRnZXQgdWktaGVscGVyLXJlc2V0XFxcIikgLy8gQVJJQVxcbiAgICAgIC5hdHRyKFxcXCJyb2xlXFxcIiwgXFxcInRhYmxpc3RcXFwiKTsgLy8gZG9uJ3QgYWxsb3cgY29sbGFwc2libGU6IGZhbHNlIGFuZCBhY3RpdmU6IGZhbHNlIC8gbnVsbFxcblxcbiAgICAgIGlmICghb3B0aW9ucy5jb2xsYXBzaWJsZSAmJiAob3B0aW9ucy5hY3RpdmUgPT09IGZhbHNlIHx8IG9wdGlvbnMuYWN0aXZlID09IG51bGwpKSB7XFxuICAgICAgICBvcHRpb25zLmFjdGl2ZSA9IDA7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX3Byb2Nlc3NQYW5lbHMoKTsgLy8gaGFuZGxlIG5lZ2F0aXZlIHZhbHVlc1xcblxcblxcbiAgICAgIGlmIChvcHRpb25zLmFjdGl2ZSA8IDApIHtcXG4gICAgICAgIG9wdGlvbnMuYWN0aXZlICs9IHRoaXMuaGVhZGVycy5sZW5ndGg7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX3JlZnJlc2goKTtcXG4gICAgfSxcXG4gICAgX2dldENyZWF0ZUV2ZW50RGF0YTogZnVuY3Rpb24gX2dldENyZWF0ZUV2ZW50RGF0YSgpIHtcXG4gICAgICByZXR1cm4ge1xcbiAgICAgICAgaGVhZGVyOiB0aGlzLmFjdGl2ZSxcXG4gICAgICAgIHBhbmVsOiAhdGhpcy5hY3RpdmUubGVuZ3RoID8gJCgpIDogdGhpcy5hY3RpdmUubmV4dCgpXFxuICAgICAgfTtcXG4gICAgfSxcXG4gICAgX2NyZWF0ZUljb25zOiBmdW5jdGlvbiBfY3JlYXRlSWNvbnMoKSB7XFxuICAgICAgdmFyIGljb25zID0gdGhpcy5vcHRpb25zLmljb25zO1xcblxcbiAgICAgIGlmIChpY29ucykge1xcbiAgICAgICAgJChcXFwiPHNwYW4+XFxcIikuYWRkQ2xhc3MoXFxcInVpLWFjY29yZGlvbi1oZWFkZXItaWNvbiB1aS1pY29uIFxcXCIgKyBpY29ucy5oZWFkZXIpLnByZXBlbmRUbyh0aGlzLmhlYWRlcnMpO1xcbiAgICAgICAgdGhpcy5hY3RpdmUuY2hpbGRyZW4oXFxcIi51aS1hY2NvcmRpb24taGVhZGVyLWljb25cXFwiKS5yZW1vdmVDbGFzcyhpY29ucy5oZWFkZXIpLmFkZENsYXNzKGljb25zLmFjdGl2ZUhlYWRlcik7XFxuICAgICAgICB0aGlzLmhlYWRlcnMuYWRkQ2xhc3MoXFxcInVpLWFjY29yZGlvbi1pY29uc1xcXCIpO1xcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgX2Rlc3Ryb3lJY29uczogZnVuY3Rpb24gX2Rlc3Ryb3lJY29ucygpIHtcXG4gICAgICB0aGlzLmhlYWRlcnMucmVtb3ZlQ2xhc3MoXFxcInVpLWFjY29yZGlvbi1pY29uc1xcXCIpLmNoaWxkcmVuKFxcXCIudWktYWNjb3JkaW9uLWhlYWRlci1pY29uXFxcIikucmVtb3ZlKCk7XFxuICAgIH0sXFxuICAgIF9kZXN0cm95OiBmdW5jdGlvbiBfZGVzdHJveSgpIHtcXG4gICAgICB2YXIgY29udGVudHM7IC8vIGNsZWFuIHVwIG1haW4gZWxlbWVudFxcblxcbiAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVDbGFzcyhcXFwidWktYWNjb3JkaW9uIHVpLXdpZGdldCB1aS1oZWxwZXItcmVzZXRcXFwiKS5yZW1vdmVBdHRyKFxcXCJyb2xlXFxcIik7IC8vIGNsZWFuIHVwIGhlYWRlcnNcXG5cXG4gICAgICB0aGlzLmhlYWRlcnMucmVtb3ZlQ2xhc3MoXFxcInVpLWFjY29yZGlvbi1oZWFkZXIgdWktYWNjb3JkaW9uLWhlYWRlci1hY3RpdmUgdWktc3RhdGUtZGVmYXVsdCBcXFwiICsgXFxcInVpLWNvcm5lci1hbGwgdWktc3RhdGUtYWN0aXZlIHVpLXN0YXRlLWRpc2FibGVkIHVpLWNvcm5lci10b3BcXFwiKS5yZW1vdmVBdHRyKFxcXCJyb2xlXFxcIikucmVtb3ZlQXR0cihcXFwiYXJpYS1leHBhbmRlZFxcXCIpLnJlbW92ZUF0dHIoXFxcImFyaWEtc2VsZWN0ZWRcXFwiKS5yZW1vdmVBdHRyKFxcXCJhcmlhLWNvbnRyb2xzXFxcIikucmVtb3ZlQXR0cihcXFwidGFiSW5kZXhcXFwiKS5yZW1vdmVVbmlxdWVJZCgpO1xcblxcbiAgICAgIHRoaXMuX2Rlc3Ryb3lJY29ucygpOyAvLyBjbGVhbiB1cCBjb250ZW50IHBhbmVsc1xcblxcblxcbiAgICAgIGNvbnRlbnRzID0gdGhpcy5oZWFkZXJzLm5leHQoKS5yZW1vdmVDbGFzcyhcXFwidWktaGVscGVyLXJlc2V0IHVpLXdpZGdldC1jb250ZW50IHVpLWNvcm5lci1ib3R0b20gXFxcIiArIFxcXCJ1aS1hY2NvcmRpb24tY29udGVudCB1aS1hY2NvcmRpb24tY29udGVudC1hY3RpdmUgdWktc3RhdGUtZGlzYWJsZWRcXFwiKS5jc3MoXFxcImRpc3BsYXlcXFwiLCBcXFwiXFxcIikucmVtb3ZlQXR0cihcXFwicm9sZVxcXCIpLnJlbW92ZUF0dHIoXFxcImFyaWEtaGlkZGVuXFxcIikucmVtb3ZlQXR0cihcXFwiYXJpYS1sYWJlbGxlZGJ5XFxcIikucmVtb3ZlVW5pcXVlSWQoKTtcXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmhlaWdodFN0eWxlICE9PSBcXFwiY29udGVudFxcXCIpIHtcXG4gICAgICAgIGNvbnRlbnRzLmNzcyhcXFwiaGVpZ2h0XFxcIiwgXFxcIlxcXCIpO1xcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgX3NldE9wdGlvbjogZnVuY3Rpb24gX3NldE9wdGlvbihrZXksIHZhbHVlKSB7XFxuICAgICAgaWYgKGtleSA9PT0gXFxcImFjdGl2ZVxcXCIpIHtcXG4gICAgICAgIC8vIF9hY3RpdmF0ZSgpIHdpbGwgaGFuZGxlIGludmFsaWQgdmFsdWVzIGFuZCB1cGRhdGUgdGhpcy5vcHRpb25zXFxuICAgICAgICB0aGlzLl9hY3RpdmF0ZSh2YWx1ZSk7XFxuXFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChrZXkgPT09IFxcXCJldmVudFxcXCIpIHtcXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXZlbnQpIHtcXG4gICAgICAgICAgdGhpcy5fb2ZmKHRoaXMuaGVhZGVycywgdGhpcy5vcHRpb25zLmV2ZW50KTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHRoaXMuX3NldHVwRXZlbnRzKHZhbHVlKTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fc3VwZXIoa2V5LCB2YWx1ZSk7IC8vIHNldHRpbmcgY29sbGFwc2libGU6IGZhbHNlIHdoaWxlIGNvbGxhcHNlZDsgb3BlbiBmaXJzdCBwYW5lbFxcblxcblxcbiAgICAgIGlmIChrZXkgPT09IFxcXCJjb2xsYXBzaWJsZVxcXCIgJiYgIXZhbHVlICYmIHRoaXMub3B0aW9ucy5hY3RpdmUgPT09IGZhbHNlKSB7XFxuICAgICAgICB0aGlzLl9hY3RpdmF0ZSgwKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGtleSA9PT0gXFxcImljb25zXFxcIikge1xcbiAgICAgICAgdGhpcy5fZGVzdHJveUljb25zKCk7XFxuXFxuICAgICAgICBpZiAodmFsdWUpIHtcXG4gICAgICAgICAgdGhpcy5fY3JlYXRlSWNvbnMoKTtcXG4gICAgICAgIH1cXG4gICAgICB9IC8vICM1MzMyIC0gb3BhY2l0eSBkb2Vzbid0IGNhc2NhZGUgdG8gcG9zaXRpb25lZCBlbGVtZW50cyBpbiBJRVxcbiAgICAgIC8vIHNvIHdlIG5lZWQgdG8gYWRkIHRoZSBkaXNhYmxlZCBjbGFzcyB0byB0aGUgaGVhZGVycyBhbmQgcGFuZWxzXFxuXFxuXFxuICAgICAgaWYgKGtleSA9PT0gXFxcImRpc2FibGVkXFxcIikge1xcbiAgICAgICAgdGhpcy5lbGVtZW50LnRvZ2dsZUNsYXNzKFxcXCJ1aS1zdGF0ZS1kaXNhYmxlZFxcXCIsICEhdmFsdWUpLmF0dHIoXFxcImFyaWEtZGlzYWJsZWRcXFwiLCB2YWx1ZSk7XFxuICAgICAgICB0aGlzLmhlYWRlcnMuYWRkKHRoaXMuaGVhZGVycy5uZXh0KCkpLnRvZ2dsZUNsYXNzKFxcXCJ1aS1zdGF0ZS1kaXNhYmxlZFxcXCIsICEhdmFsdWUpO1xcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgX2tleWRvd246IGZ1bmN0aW9uIF9rZXlkb3duKGV2ZW50KSB7XFxuICAgICAgaWYgKGV2ZW50LmFsdEtleSB8fCBldmVudC5jdHJsS2V5KSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBrZXlDb2RlID0gJC51aS5rZXlDb2RlLFxcbiAgICAgICAgICBsZW5ndGggPSB0aGlzLmhlYWRlcnMubGVuZ3RoLFxcbiAgICAgICAgICBjdXJyZW50SW5kZXggPSB0aGlzLmhlYWRlcnMuaW5kZXgoZXZlbnQudGFyZ2V0KSxcXG4gICAgICAgICAgdG9Gb2N1cyA9IGZhbHNlO1xcblxcbiAgICAgIHN3aXRjaCAoZXZlbnQua2V5Q29kZSkge1xcbiAgICAgICAgY2FzZSBrZXlDb2RlLlJJR0hUOlxcbiAgICAgICAgY2FzZSBrZXlDb2RlLkRPV046XFxuICAgICAgICAgIHRvRm9jdXMgPSB0aGlzLmhlYWRlcnNbKGN1cnJlbnRJbmRleCArIDEpICUgbGVuZ3RoXTtcXG4gICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICBjYXNlIGtleUNvZGUuTEVGVDpcXG4gICAgICAgIGNhc2Uga2V5Q29kZS5VUDpcXG4gICAgICAgICAgdG9Gb2N1cyA9IHRoaXMuaGVhZGVyc1soY3VycmVudEluZGV4IC0gMSArIGxlbmd0aCkgJSBsZW5ndGhdO1xcbiAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgIGNhc2Uga2V5Q29kZS5TUEFDRTpcXG4gICAgICAgIGNhc2Uga2V5Q29kZS5FTlRFUjpcXG4gICAgICAgICAgdGhpcy5fZXZlbnRIYW5kbGVyKGV2ZW50KTtcXG5cXG4gICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICBjYXNlIGtleUNvZGUuSE9NRTpcXG4gICAgICAgICAgdG9Gb2N1cyA9IHRoaXMuaGVhZGVyc1swXTtcXG4gICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICBjYXNlIGtleUNvZGUuRU5EOlxcbiAgICAgICAgICB0b0ZvY3VzID0gdGhpcy5oZWFkZXJzW2xlbmd0aCAtIDFdO1xcbiAgICAgICAgICBicmVhaztcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRvRm9jdXMpIHtcXG4gICAgICAgICQoZXZlbnQudGFyZ2V0KS5hdHRyKFxcXCJ0YWJJbmRleFxcXCIsIC0xKTtcXG4gICAgICAgICQodG9Gb2N1cykuYXR0cihcXFwidGFiSW5kZXhcXFwiLCAwKTtcXG4gICAgICAgIHRvRm9jdXMuZm9jdXMoKTtcXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgfVxcbiAgICB9LFxcbiAgICBfcGFuZWxLZXlEb3duOiBmdW5jdGlvbiBfcGFuZWxLZXlEb3duKGV2ZW50KSB7XFxuICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09ICQudWkua2V5Q29kZS5VUCAmJiBldmVudC5jdHJsS2V5KSB7XFxuICAgICAgICAkKGV2ZW50LmN1cnJlbnRUYXJnZXQpLnByZXYoKS5mb2N1cygpO1xcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgcmVmcmVzaDogZnVuY3Rpb24gcmVmcmVzaCgpIHtcXG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcXG5cXG4gICAgICB0aGlzLl9wcm9jZXNzUGFuZWxzKCk7IC8vIHdhcyBjb2xsYXBzZWQgb3Igbm8gcGFuZWxcXG5cXG5cXG4gICAgICBpZiAob3B0aW9ucy5hY3RpdmUgPT09IGZhbHNlICYmIG9wdGlvbnMuY29sbGFwc2libGUgPT09IHRydWUgfHwgIXRoaXMuaGVhZGVycy5sZW5ndGgpIHtcXG4gICAgICAgIG9wdGlvbnMuYWN0aXZlID0gZmFsc2U7XFxuICAgICAgICB0aGlzLmFjdGl2ZSA9ICQoKTsgLy8gYWN0aXZlIGZhbHNlIG9ubHkgd2hlbiBjb2xsYXBzaWJsZSBpcyB0cnVlXFxuICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmFjdGl2ZSA9PT0gZmFsc2UpIHtcXG4gICAgICAgIHRoaXMuX2FjdGl2YXRlKDApOyAvLyB3YXMgYWN0aXZlLCBidXQgYWN0aXZlIHBhbmVsIGlzIGdvbmVcXG5cXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuYWN0aXZlLmxlbmd0aCAmJiAhJC5jb250YWlucyh0aGlzLmVsZW1lbnRbMF0sIHRoaXMuYWN0aXZlWzBdKSkge1xcbiAgICAgICAgLy8gYWxsIHJlbWFpbmluZyBwYW5lbCBhcmUgZGlzYWJsZWRcXG4gICAgICAgIGlmICh0aGlzLmhlYWRlcnMubGVuZ3RoID09PSB0aGlzLmhlYWRlcnMuZmluZChcXFwiLnVpLXN0YXRlLWRpc2FibGVkXFxcIikubGVuZ3RoKSB7XFxuICAgICAgICAgIG9wdGlvbnMuYWN0aXZlID0gZmFsc2U7XFxuICAgICAgICAgIHRoaXMuYWN0aXZlID0gJCgpOyAvLyBhY3RpdmF0ZSBwcmV2aW91cyBwYW5lbFxcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgdGhpcy5fYWN0aXZhdGUoTWF0aC5tYXgoMCwgb3B0aW9ucy5hY3RpdmUgLSAxKSk7XFxuICAgICAgICB9IC8vIHdhcyBhY3RpdmUsIGFjdGl2ZSBwYW5lbCBzdGlsbCBleGlzdHNcXG5cXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgLy8gbWFrZSBzdXJlIGFjdGl2ZSBpbmRleCBpcyBjb3JyZWN0XFxuICAgICAgICBvcHRpb25zLmFjdGl2ZSA9IHRoaXMuaGVhZGVycy5pbmRleCh0aGlzLmFjdGl2ZSk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX2Rlc3Ryb3lJY29ucygpO1xcblxcbiAgICAgIHRoaXMuX3JlZnJlc2goKTtcXG4gICAgfSxcXG4gICAgX3Byb2Nlc3NQYW5lbHM6IGZ1bmN0aW9uIF9wcm9jZXNzUGFuZWxzKCkge1xcbiAgICAgIHZhciBwcmV2SGVhZGVycyA9IHRoaXMuaGVhZGVycyxcXG4gICAgICAgICAgcHJldlBhbmVscyA9IHRoaXMucGFuZWxzO1xcbiAgICAgIHRoaXMuaGVhZGVycyA9IHRoaXMuZWxlbWVudC5maW5kKHRoaXMub3B0aW9ucy5oZWFkZXIpLmFkZENsYXNzKFxcXCJ1aS1hY2NvcmRpb24taGVhZGVyIHVpLXN0YXRlLWRlZmF1bHQgdWktY29ybmVyLWFsbFxcXCIpO1xcbiAgICAgIHRoaXMucGFuZWxzID0gdGhpcy5oZWFkZXJzLm5leHQoKS5hZGRDbGFzcyhcXFwidWktYWNjb3JkaW9uLWNvbnRlbnQgdWktaGVscGVyLXJlc2V0IHVpLXdpZGdldC1jb250ZW50IHVpLWNvcm5lci1ib3R0b21cXFwiKS5maWx0ZXIoXFxcIjpub3QoLnVpLWFjY29yZGlvbi1jb250ZW50LWFjdGl2ZSlcXFwiKS5oaWRlKCk7IC8vIEF2b2lkIG1lbW9yeSBsZWFrcyAoIzEwMDU2KVxcblxcbiAgICAgIGlmIChwcmV2UGFuZWxzKSB7XFxuICAgICAgICB0aGlzLl9vZmYocHJldkhlYWRlcnMubm90KHRoaXMuaGVhZGVycykpO1xcblxcbiAgICAgICAgdGhpcy5fb2ZmKHByZXZQYW5lbHMubm90KHRoaXMucGFuZWxzKSk7XFxuICAgICAgfVxcbiAgICB9LFxcbiAgICBfcmVmcmVzaDogZnVuY3Rpb24gX3JlZnJlc2goKSB7XFxuICAgICAgdmFyIG1heEhlaWdodCxcXG4gICAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcXG4gICAgICAgICAgaGVpZ2h0U3R5bGUgPSBvcHRpb25zLmhlaWdodFN0eWxlLFxcbiAgICAgICAgICBwYXJlbnQgPSB0aGlzLmVsZW1lbnQucGFyZW50KCk7XFxuICAgICAgdGhpcy5hY3RpdmUgPSB0aGlzLl9maW5kQWN0aXZlKG9wdGlvbnMuYWN0aXZlKS5hZGRDbGFzcyhcXFwidWktYWNjb3JkaW9uLWhlYWRlci1hY3RpdmUgdWktc3RhdGUtYWN0aXZlIHVpLWNvcm5lci10b3BcXFwiKS5yZW1vdmVDbGFzcyhcXFwidWktY29ybmVyLWFsbFxcXCIpO1xcbiAgICAgIHRoaXMuYWN0aXZlLm5leHQoKS5hZGRDbGFzcyhcXFwidWktYWNjb3JkaW9uLWNvbnRlbnQtYWN0aXZlXFxcIikuc2hvdygpO1xcbiAgICAgIHRoaXMuaGVhZGVycy5hdHRyKFxcXCJyb2xlXFxcIiwgXFxcInRhYlxcXCIpLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIGhlYWRlciA9ICQodGhpcyksXFxuICAgICAgICAgICAgaGVhZGVySWQgPSBoZWFkZXIudW5pcXVlSWQoKS5hdHRyKFxcXCJpZFxcXCIpLFxcbiAgICAgICAgICAgIHBhbmVsID0gaGVhZGVyLm5leHQoKSxcXG4gICAgICAgICAgICBwYW5lbElkID0gcGFuZWwudW5pcXVlSWQoKS5hdHRyKFxcXCJpZFxcXCIpO1xcbiAgICAgICAgaGVhZGVyLmF0dHIoXFxcImFyaWEtY29udHJvbHNcXFwiLCBwYW5lbElkKTtcXG4gICAgICAgIHBhbmVsLmF0dHIoXFxcImFyaWEtbGFiZWxsZWRieVxcXCIsIGhlYWRlcklkKTtcXG4gICAgICB9KS5uZXh0KCkuYXR0cihcXFwicm9sZVxcXCIsIFxcXCJ0YWJwYW5lbFxcXCIpO1xcbiAgICAgIHRoaXMuaGVhZGVycy5ub3QodGhpcy5hY3RpdmUpLmF0dHIoe1xcbiAgICAgICAgXFxcImFyaWEtc2VsZWN0ZWRcXFwiOiBcXFwiZmFsc2VcXFwiLFxcbiAgICAgICAgXFxcImFyaWEtZXhwYW5kZWRcXFwiOiBcXFwiZmFsc2VcXFwiLFxcbiAgICAgICAgdGFiSW5kZXg6IC0xXFxuICAgICAgfSkubmV4dCgpLmF0dHIoe1xcbiAgICAgICAgXFxcImFyaWEtaGlkZGVuXFxcIjogXFxcInRydWVcXFwiXFxuICAgICAgfSkuaGlkZSgpOyAvLyBtYWtlIHN1cmUgYXQgbGVhc3Qgb25lIGhlYWRlciBpcyBpbiB0aGUgdGFiIG9yZGVyXFxuXFxuICAgICAgaWYgKCF0aGlzLmFjdGl2ZS5sZW5ndGgpIHtcXG4gICAgICAgIHRoaXMuaGVhZGVycy5lcSgwKS5hdHRyKFxcXCJ0YWJJbmRleFxcXCIsIDApO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB0aGlzLmFjdGl2ZS5hdHRyKHtcXG4gICAgICAgICAgXFxcImFyaWEtc2VsZWN0ZWRcXFwiOiBcXFwidHJ1ZVxcXCIsXFxuICAgICAgICAgIFxcXCJhcmlhLWV4cGFuZGVkXFxcIjogXFxcInRydWVcXFwiLFxcbiAgICAgICAgICB0YWJJbmRleDogMFxcbiAgICAgICAgfSkubmV4dCgpLmF0dHIoe1xcbiAgICAgICAgICBcXFwiYXJpYS1oaWRkZW5cXFwiOiBcXFwiZmFsc2VcXFwiXFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fY3JlYXRlSWNvbnMoKTtcXG5cXG4gICAgICB0aGlzLl9zZXR1cEV2ZW50cyhvcHRpb25zLmV2ZW50KTtcXG5cXG4gICAgICBpZiAoaGVpZ2h0U3R5bGUgPT09IFxcXCJmaWxsXFxcIikge1xcbiAgICAgICAgbWF4SGVpZ2h0ID0gcGFyZW50LmhlaWdodCgpO1xcbiAgICAgICAgdGhpcy5lbGVtZW50LnNpYmxpbmdzKFxcXCI6dmlzaWJsZVxcXCIpLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICB2YXIgZWxlbSA9ICQodGhpcyksXFxuICAgICAgICAgICAgICBwb3NpdGlvbiA9IGVsZW0uY3NzKFxcXCJwb3NpdGlvblxcXCIpO1xcblxcbiAgICAgICAgICBpZiAocG9zaXRpb24gPT09IFxcXCJhYnNvbHV0ZVxcXCIgfHwgcG9zaXRpb24gPT09IFxcXCJmaXhlZFxcXCIpIHtcXG4gICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgbWF4SGVpZ2h0IC09IGVsZW0ub3V0ZXJIZWlnaHQodHJ1ZSk7XFxuICAgICAgICB9KTtcXG4gICAgICAgIHRoaXMuaGVhZGVycy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgbWF4SGVpZ2h0IC09ICQodGhpcykub3V0ZXJIZWlnaHQodHJ1ZSk7XFxuICAgICAgICB9KTtcXG4gICAgICAgIHRoaXMuaGVhZGVycy5uZXh0KCkuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICQodGhpcykuaGVpZ2h0KE1hdGgubWF4KDAsIG1heEhlaWdodCAtICQodGhpcykuaW5uZXJIZWlnaHQoKSArICQodGhpcykuaGVpZ2h0KCkpKTtcXG4gICAgICAgIH0pLmNzcyhcXFwib3ZlcmZsb3dcXFwiLCBcXFwiYXV0b1xcXCIpO1xcbiAgICAgIH0gZWxzZSBpZiAoaGVpZ2h0U3R5bGUgPT09IFxcXCJhdXRvXFxcIikge1xcbiAgICAgICAgbWF4SGVpZ2h0ID0gMDtcXG4gICAgICAgIHRoaXMuaGVhZGVycy5uZXh0KCkuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIG1heEhlaWdodCA9IE1hdGgubWF4KG1heEhlaWdodCwgJCh0aGlzKS5jc3MoXFxcImhlaWdodFxcXCIsIFxcXCJcXFwiKS5oZWlnaHQoKSk7XFxuICAgICAgICB9KS5oZWlnaHQobWF4SGVpZ2h0KTtcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIF9hY3RpdmF0ZTogZnVuY3Rpb24gX2FjdGl2YXRlKGluZGV4KSB7XFxuICAgICAgdmFyIGFjdGl2ZSA9IHRoaXMuX2ZpbmRBY3RpdmUoaW5kZXgpWzBdOyAvLyB0cnlpbmcgdG8gYWN0aXZhdGUgdGhlIGFscmVhZHkgYWN0aXZlIHBhbmVsXFxuXFxuXFxuICAgICAgaWYgKGFjdGl2ZSA9PT0gdGhpcy5hY3RpdmVbMF0pIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9IC8vIHRyeWluZyB0byBjb2xsYXBzZSwgc2ltdWxhdGUgYSBjbGljayBvbiB0aGUgY3VycmVudGx5IGFjdGl2ZSBoZWFkZXJcXG5cXG5cXG4gICAgICBhY3RpdmUgPSBhY3RpdmUgfHwgdGhpcy5hY3RpdmVbMF07XFxuXFxuICAgICAgdGhpcy5fZXZlbnRIYW5kbGVyKHtcXG4gICAgICAgIHRhcmdldDogYWN0aXZlLFxcbiAgICAgICAgY3VycmVudFRhcmdldDogYWN0aXZlLFxcbiAgICAgICAgcHJldmVudERlZmF1bHQ6ICQubm9vcFxcbiAgICAgIH0pO1xcbiAgICB9LFxcbiAgICBfZmluZEFjdGl2ZTogZnVuY3Rpb24gX2ZpbmRBY3RpdmUoc2VsZWN0b3IpIHtcXG4gICAgICByZXR1cm4gdHlwZW9mIHNlbGVjdG9yID09PSBcXFwibnVtYmVyXFxcIiA/IHRoaXMuaGVhZGVycy5lcShzZWxlY3RvcikgOiAkKCk7XFxuICAgIH0sXFxuICAgIF9zZXR1cEV2ZW50czogZnVuY3Rpb24gX3NldHVwRXZlbnRzKGV2ZW50KSB7XFxuICAgICAgdmFyIGV2ZW50cyA9IHtcXG4gICAgICAgIGtleWRvd246IFxcXCJfa2V5ZG93blxcXCJcXG4gICAgICB9O1xcblxcbiAgICAgIGlmIChldmVudCkge1xcbiAgICAgICAgJC5lYWNoKGV2ZW50LnNwbGl0KFxcXCIgXFxcIiksIGZ1bmN0aW9uIChpbmRleCwgZXZlbnROYW1lKSB7XFxuICAgICAgICAgIGV2ZW50c1tldmVudE5hbWVdID0gXFxcIl9ldmVudEhhbmRsZXJcXFwiO1xcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX29mZih0aGlzLmhlYWRlcnMuYWRkKHRoaXMuaGVhZGVycy5uZXh0KCkpKTtcXG5cXG4gICAgICB0aGlzLl9vbih0aGlzLmhlYWRlcnMsIGV2ZW50cyk7XFxuXFxuICAgICAgdGhpcy5fb24odGhpcy5oZWFkZXJzLm5leHQoKSwge1xcbiAgICAgICAga2V5ZG93bjogXFxcIl9wYW5lbEtleURvd25cXFwiXFxuICAgICAgfSk7XFxuXFxuICAgICAgdGhpcy5faG92ZXJhYmxlKHRoaXMuaGVhZGVycyk7XFxuXFxuICAgICAgdGhpcy5fZm9jdXNhYmxlKHRoaXMuaGVhZGVycyk7XFxuICAgIH0sXFxuICAgIF9ldmVudEhhbmRsZXI6IGZ1bmN0aW9uIF9ldmVudEhhbmRsZXIoZXZlbnQpIHtcXG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcXG4gICAgICAgICAgYWN0aXZlID0gdGhpcy5hY3RpdmUsXFxuICAgICAgICAgIGNsaWNrZWQgPSAkKGV2ZW50LmN1cnJlbnRUYXJnZXQpLFxcbiAgICAgICAgICBjbGlja2VkSXNBY3RpdmUgPSBjbGlja2VkWzBdID09PSBhY3RpdmVbMF0sXFxuICAgICAgICAgIGNvbGxhcHNpbmcgPSBjbGlja2VkSXNBY3RpdmUgJiYgb3B0aW9ucy5jb2xsYXBzaWJsZSxcXG4gICAgICAgICAgdG9TaG93ID0gY29sbGFwc2luZyA/ICQoKSA6IGNsaWNrZWQubmV4dCgpLFxcbiAgICAgICAgICB0b0hpZGUgPSBhY3RpdmUubmV4dCgpLFxcbiAgICAgICAgICBldmVudERhdGEgPSB7XFxuICAgICAgICBvbGRIZWFkZXI6IGFjdGl2ZSxcXG4gICAgICAgIG9sZFBhbmVsOiB0b0hpZGUsXFxuICAgICAgICBuZXdIZWFkZXI6IGNvbGxhcHNpbmcgPyAkKCkgOiBjbGlja2VkLFxcbiAgICAgICAgbmV3UGFuZWw6IHRvU2hvd1xcbiAgICAgIH07XFxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG5cXG4gICAgICBpZiAoIC8vIGNsaWNrIG9uIGFjdGl2ZSBoZWFkZXIsIGJ1dCBub3QgY29sbGFwc2libGVcXG4gICAgICBjbGlja2VkSXNBY3RpdmUgJiYgIW9wdGlvbnMuY29sbGFwc2libGUgfHwgLy8gYWxsb3cgY2FuY2VsaW5nIGFjdGl2YXRpb25cXG4gICAgICB0aGlzLl90cmlnZ2VyKFxcXCJiZWZvcmVBY3RpdmF0ZVxcXCIsIGV2ZW50LCBldmVudERhdGEpID09PSBmYWxzZSkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBvcHRpb25zLmFjdGl2ZSA9IGNvbGxhcHNpbmcgPyBmYWxzZSA6IHRoaXMuaGVhZGVycy5pbmRleChjbGlja2VkKTsgLy8gd2hlbiB0aGUgY2FsbCB0byAuX3RvZ2dsZSgpIGNvbWVzIGFmdGVyIHRoZSBjbGFzcyBjaGFuZ2VzXFxuICAgICAgLy8gaXQgY2F1c2VzIGEgdmVyeSBvZGQgYnVnIGluIElFIDggKHNlZSAjNjcyMClcXG5cXG4gICAgICB0aGlzLmFjdGl2ZSA9IGNsaWNrZWRJc0FjdGl2ZSA/ICQoKSA6IGNsaWNrZWQ7XFxuXFxuICAgICAgdGhpcy5fdG9nZ2xlKGV2ZW50RGF0YSk7IC8vIHN3aXRjaCBjbGFzc2VzXFxuICAgICAgLy8gY29ybmVyIGNsYXNzZXMgb24gdGhlIHByZXZpb3VzbHkgYWN0aXZlIGhlYWRlciBzdGF5IGFmdGVyIHRoZSBhbmltYXRpb25cXG5cXG5cXG4gICAgICBhY3RpdmUucmVtb3ZlQ2xhc3MoXFxcInVpLWFjY29yZGlvbi1oZWFkZXItYWN0aXZlIHVpLXN0YXRlLWFjdGl2ZVxcXCIpO1xcblxcbiAgICAgIGlmIChvcHRpb25zLmljb25zKSB7XFxuICAgICAgICBhY3RpdmUuY2hpbGRyZW4oXFxcIi51aS1hY2NvcmRpb24taGVhZGVyLWljb25cXFwiKS5yZW1vdmVDbGFzcyhvcHRpb25zLmljb25zLmFjdGl2ZUhlYWRlcikuYWRkQ2xhc3Mob3B0aW9ucy5pY29ucy5oZWFkZXIpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIWNsaWNrZWRJc0FjdGl2ZSkge1xcbiAgICAgICAgY2xpY2tlZC5yZW1vdmVDbGFzcyhcXFwidWktY29ybmVyLWFsbFxcXCIpLmFkZENsYXNzKFxcXCJ1aS1hY2NvcmRpb24taGVhZGVyLWFjdGl2ZSB1aS1zdGF0ZS1hY3RpdmUgdWktY29ybmVyLXRvcFxcXCIpO1xcblxcbiAgICAgICAgaWYgKG9wdGlvbnMuaWNvbnMpIHtcXG4gICAgICAgICAgY2xpY2tlZC5jaGlsZHJlbihcXFwiLnVpLWFjY29yZGlvbi1oZWFkZXItaWNvblxcXCIpLnJlbW92ZUNsYXNzKG9wdGlvbnMuaWNvbnMuaGVhZGVyKS5hZGRDbGFzcyhvcHRpb25zLmljb25zLmFjdGl2ZUhlYWRlcik7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBjbGlja2VkLm5leHQoKS5hZGRDbGFzcyhcXFwidWktYWNjb3JkaW9uLWNvbnRlbnQtYWN0aXZlXFxcIik7XFxuICAgICAgfVxcbiAgICB9LFxcbiAgICBfdG9nZ2xlOiBmdW5jdGlvbiBfdG9nZ2xlKGRhdGEpIHtcXG4gICAgICB2YXIgdG9TaG93ID0gZGF0YS5uZXdQYW5lbCxcXG4gICAgICAgICAgdG9IaWRlID0gdGhpcy5wcmV2U2hvdy5sZW5ndGggPyB0aGlzLnByZXZTaG93IDogZGF0YS5vbGRQYW5lbDsgLy8gaGFuZGxlIGFjdGl2YXRpbmcgYSBwYW5lbCBkdXJpbmcgdGhlIGFuaW1hdGlvbiBmb3IgYW5vdGhlciBhY3RpdmF0aW9uXFxuXFxuICAgICAgdGhpcy5wcmV2U2hvdy5hZGQodGhpcy5wcmV2SGlkZSkuc3RvcCh0cnVlLCB0cnVlKTtcXG4gICAgICB0aGlzLnByZXZTaG93ID0gdG9TaG93O1xcbiAgICAgIHRoaXMucHJldkhpZGUgPSB0b0hpZGU7XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hbmltYXRlKSB7XFxuICAgICAgICB0aGlzLl9hbmltYXRlKHRvU2hvdywgdG9IaWRlLCBkYXRhKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdG9IaWRlLmhpZGUoKTtcXG4gICAgICAgIHRvU2hvdy5zaG93KCk7XFxuXFxuICAgICAgICB0aGlzLl90b2dnbGVDb21wbGV0ZShkYXRhKTtcXG4gICAgICB9XFxuXFxuICAgICAgdG9IaWRlLmF0dHIoe1xcbiAgICAgICAgXFxcImFyaWEtaGlkZGVuXFxcIjogXFxcInRydWVcXFwiXFxuICAgICAgfSk7XFxuICAgICAgdG9IaWRlLnByZXYoKS5hdHRyKHtcXG4gICAgICAgIFxcXCJhcmlhLXNlbGVjdGVkXFxcIjogXFxcImZhbHNlXFxcIixcXG4gICAgICAgIFxcXCJhcmlhLWV4cGFuZGVkXFxcIjogXFxcImZhbHNlXFxcIlxcbiAgICAgIH0pOyAvLyBpZiB3ZSdyZSBzd2l0Y2hpbmcgcGFuZWxzLCByZW1vdmUgdGhlIG9sZCBoZWFkZXIgZnJvbSB0aGUgdGFiIG9yZGVyXFxuICAgICAgLy8gaWYgd2UncmUgb3BlbmluZyBmcm9tIGNvbGxhcHNlZCBzdGF0ZSwgcmVtb3ZlIHRoZSBwcmV2aW91cyBoZWFkZXIgZnJvbSB0aGUgdGFiIG9yZGVyXFxuICAgICAgLy8gaWYgd2UncmUgY29sbGFwc2luZywgdGhlbiBrZWVwIHRoZSBjb2xsYXBzaW5nIGhlYWRlciBpbiB0aGUgdGFiIG9yZGVyXFxuXFxuICAgICAgaWYgKHRvU2hvdy5sZW5ndGggJiYgdG9IaWRlLmxlbmd0aCkge1xcbiAgICAgICAgdG9IaWRlLnByZXYoKS5hdHRyKHtcXG4gICAgICAgICAgXFxcInRhYkluZGV4XFxcIjogLTEsXFxuICAgICAgICAgIFxcXCJhcmlhLWV4cGFuZGVkXFxcIjogXFxcImZhbHNlXFxcIlxcbiAgICAgICAgfSk7XFxuICAgICAgfSBlbHNlIGlmICh0b1Nob3cubGVuZ3RoKSB7XFxuICAgICAgICB0aGlzLmhlYWRlcnMuZmlsdGVyKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgcmV0dXJuIHBhcnNlSW50KCQodGhpcykuYXR0cihcXFwidGFiSW5kZXhcXFwiKSwgMTApID09PSAwO1xcbiAgICAgICAgfSkuYXR0cihcXFwidGFiSW5kZXhcXFwiLCAtMSk7XFxuICAgICAgfVxcblxcbiAgICAgIHRvU2hvdy5hdHRyKFxcXCJhcmlhLWhpZGRlblxcXCIsIFxcXCJmYWxzZVxcXCIpLnByZXYoKS5hdHRyKHtcXG4gICAgICAgIFxcXCJhcmlhLXNlbGVjdGVkXFxcIjogXFxcInRydWVcXFwiLFxcbiAgICAgICAgXFxcImFyaWEtZXhwYW5kZWRcXFwiOiBcXFwidHJ1ZVxcXCIsXFxuICAgICAgICB0YWJJbmRleDogMFxcbiAgICAgIH0pO1xcbiAgICB9LFxcbiAgICBfYW5pbWF0ZTogZnVuY3Rpb24gX2FuaW1hdGUodG9TaG93LCB0b0hpZGUsIGRhdGEpIHtcXG4gICAgICB2YXIgdG90YWwsXFxuICAgICAgICAgIGVhc2luZyxcXG4gICAgICAgICAgZHVyYXRpb24sXFxuICAgICAgICAgIHRoYXQgPSB0aGlzLFxcbiAgICAgICAgICBhZGp1c3QgPSAwLFxcbiAgICAgICAgICBib3hTaXppbmcgPSB0b1Nob3cuY3NzKFxcXCJib3gtc2l6aW5nXFxcIiksXFxuICAgICAgICAgIGRvd24gPSB0b1Nob3cubGVuZ3RoICYmICghdG9IaWRlLmxlbmd0aCB8fCB0b1Nob3cuaW5kZXgoKSA8IHRvSGlkZS5pbmRleCgpKSxcXG4gICAgICAgICAgYW5pbWF0ZSA9IHRoaXMub3B0aW9ucy5hbmltYXRlIHx8IHt9LFxcbiAgICAgICAgICBvcHRpb25zID0gZG93biAmJiBhbmltYXRlLmRvd24gfHwgYW5pbWF0ZSxcXG4gICAgICAgICAgY29tcGxldGUgPSBmdW5jdGlvbiBjb21wbGV0ZSgpIHtcXG4gICAgICAgIHRoYXQuX3RvZ2dsZUNvbXBsZXRlKGRhdGEpO1xcbiAgICAgIH07XFxuXFxuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcXFwibnVtYmVyXFxcIikge1xcbiAgICAgICAgZHVyYXRpb24gPSBvcHRpb25zO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFxcXCJzdHJpbmdcXFwiKSB7XFxuICAgICAgICBlYXNpbmcgPSBvcHRpb25zO1xcbiAgICAgIH0gLy8gZmFsbCBiYWNrIGZyb20gb3B0aW9ucyB0byBhbmltYXRpb24gaW4gY2FzZSBvZiBwYXJ0aWFsIGRvd24gc2V0dGluZ3NcXG5cXG5cXG4gICAgICBlYXNpbmcgPSBlYXNpbmcgfHwgb3B0aW9ucy5lYXNpbmcgfHwgYW5pbWF0ZS5lYXNpbmc7XFxuICAgICAgZHVyYXRpb24gPSBkdXJhdGlvbiB8fCBvcHRpb25zLmR1cmF0aW9uIHx8IGFuaW1hdGUuZHVyYXRpb247XFxuXFxuICAgICAgaWYgKCF0b0hpZGUubGVuZ3RoKSB7XFxuICAgICAgICByZXR1cm4gdG9TaG93LmFuaW1hdGUodGhpcy5zaG93UHJvcHMsIGR1cmF0aW9uLCBlYXNpbmcsIGNvbXBsZXRlKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCF0b1Nob3cubGVuZ3RoKSB7XFxuICAgICAgICByZXR1cm4gdG9IaWRlLmFuaW1hdGUodGhpcy5oaWRlUHJvcHMsIGR1cmF0aW9uLCBlYXNpbmcsIGNvbXBsZXRlKTtcXG4gICAgICB9XFxuXFxuICAgICAgdG90YWwgPSB0b1Nob3cuc2hvdygpLm91dGVySGVpZ2h0KCk7XFxuICAgICAgdG9IaWRlLmFuaW1hdGUodGhpcy5oaWRlUHJvcHMsIHtcXG4gICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcXG4gICAgICAgIGVhc2luZzogZWFzaW5nLFxcbiAgICAgICAgc3RlcDogZnVuY3Rpb24gc3RlcChub3csIGZ4KSB7XFxuICAgICAgICAgIGZ4Lm5vdyA9IE1hdGgucm91bmQobm93KTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgICB0b1Nob3cuaGlkZSgpLmFuaW1hdGUodGhpcy5zaG93UHJvcHMsIHtcXG4gICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcXG4gICAgICAgIGVhc2luZzogZWFzaW5nLFxcbiAgICAgICAgY29tcGxldGU6IGNvbXBsZXRlLFxcbiAgICAgICAgc3RlcDogZnVuY3Rpb24gc3RlcChub3csIGZ4KSB7XFxuICAgICAgICAgIGZ4Lm5vdyA9IE1hdGgucm91bmQobm93KTtcXG5cXG4gICAgICAgICAgaWYgKGZ4LnByb3AgIT09IFxcXCJoZWlnaHRcXFwiKSB7XFxuICAgICAgICAgICAgaWYgKGJveFNpemluZyA9PT0gXFxcImNvbnRlbnQtYm94XFxcIikge1xcbiAgICAgICAgICAgICAgYWRqdXN0ICs9IGZ4Lm5vdztcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH0gZWxzZSBpZiAodGhhdC5vcHRpb25zLmhlaWdodFN0eWxlICE9PSBcXFwiY29udGVudFxcXCIpIHtcXG4gICAgICAgICAgICBmeC5ub3cgPSBNYXRoLnJvdW5kKHRvdGFsIC0gdG9IaWRlLm91dGVySGVpZ2h0KCkgLSBhZGp1c3QpO1xcbiAgICAgICAgICAgIGFkanVzdCA9IDA7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgfSxcXG4gICAgX3RvZ2dsZUNvbXBsZXRlOiBmdW5jdGlvbiBfdG9nZ2xlQ29tcGxldGUoZGF0YSkge1xcbiAgICAgIHZhciB0b0hpZGUgPSBkYXRhLm9sZFBhbmVsO1xcbiAgICAgIHRvSGlkZS5yZW1vdmVDbGFzcyhcXFwidWktYWNjb3JkaW9uLWNvbnRlbnQtYWN0aXZlXFxcIikucHJldigpLnJlbW92ZUNsYXNzKFxcXCJ1aS1jb3JuZXItdG9wXFxcIikuYWRkQ2xhc3MoXFxcInVpLWNvcm5lci1hbGxcXFwiKTsgLy8gV29yayBhcm91bmQgZm9yIHJlbmRlcmluZyBidWcgaW4gSUUgKCM1NDIxKVxcblxcbiAgICAgIGlmICh0b0hpZGUubGVuZ3RoKSB7XFxuICAgICAgICB0b0hpZGUucGFyZW50KClbMF0uY2xhc3NOYW1lID0gdG9IaWRlLnBhcmVudCgpWzBdLmNsYXNzTmFtZTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fdHJpZ2dlcihcXFwiYWN0aXZhdGVcXFwiLCBudWxsLCBkYXRhKTtcXG4gICAgfVxcbiAgfSk7XFxuICAvKiFcXG4gICAqIGpRdWVyeSBVSSBNZW51IDEuMTEuNFxcbiAgICogaHR0cDovL2pxdWVyeXVpLmNvbVxcbiAgICpcXG4gICAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXFxuICAgKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXFxuICAgKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXFxuICAgKlxcbiAgICogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20vbWVudS9cXG4gICAqL1xcblxcbiAgdmFyIG1lbnUgPSAkLndpZGdldChcXFwidWkubWVudVxcXCIsIHtcXG4gICAgdmVyc2lvbjogXFxcIjEuMTEuNFxcXCIsXFxuICAgIGRlZmF1bHRFbGVtZW50OiBcXFwiPHVsPlxcXCIsXFxuICAgIGRlbGF5OiAzMDAsXFxuICAgIG9wdGlvbnM6IHtcXG4gICAgICBpY29uczoge1xcbiAgICAgICAgc3VibWVudTogXFxcInVpLWljb24tY2FyYXQtMS1lXFxcIlxcbiAgICAgIH0sXFxuICAgICAgaXRlbXM6IFxcXCI+ICpcXFwiLFxcbiAgICAgIG1lbnVzOiBcXFwidWxcXFwiLFxcbiAgICAgIHBvc2l0aW9uOiB7XFxuICAgICAgICBteTogXFxcImxlZnQtMSB0b3BcXFwiLFxcbiAgICAgICAgYXQ6IFxcXCJyaWdodCB0b3BcXFwiXFxuICAgICAgfSxcXG4gICAgICByb2xlOiBcXFwibWVudVxcXCIsXFxuICAgICAgLy8gY2FsbGJhY2tzXFxuICAgICAgYmx1cjogbnVsbCxcXG4gICAgICBmb2N1czogbnVsbCxcXG4gICAgICBzZWxlY3Q6IG51bGxcXG4gICAgfSxcXG4gICAgX2NyZWF0ZTogZnVuY3Rpb24gX2NyZWF0ZSgpIHtcXG4gICAgICB0aGlzLmFjdGl2ZU1lbnUgPSB0aGlzLmVsZW1lbnQ7IC8vIEZsYWcgdXNlZCB0byBwcmV2ZW50IGZpcmluZyBvZiB0aGUgY2xpY2sgaGFuZGxlclxcbiAgICAgIC8vIGFzIHRoZSBldmVudCBidWJibGVzIHVwIHRocm91Z2ggbmVzdGVkIG1lbnVzXFxuXFxuICAgICAgdGhpcy5tb3VzZUhhbmRsZWQgPSBmYWxzZTtcXG4gICAgICB0aGlzLmVsZW1lbnQudW5pcXVlSWQoKS5hZGRDbGFzcyhcXFwidWktbWVudSB1aS13aWRnZXQgdWktd2lkZ2V0LWNvbnRlbnRcXFwiKS50b2dnbGVDbGFzcyhcXFwidWktbWVudS1pY29uc1xcXCIsICEhdGhpcy5lbGVtZW50LmZpbmQoXFxcIi51aS1pY29uXFxcIikubGVuZ3RoKS5hdHRyKHtcXG4gICAgICAgIHJvbGU6IHRoaXMub3B0aW9ucy5yb2xlLFxcbiAgICAgICAgdGFiSW5kZXg6IDBcXG4gICAgICB9KTtcXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmRpc2FibGVkKSB7XFxuICAgICAgICB0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoXFxcInVpLXN0YXRlLWRpc2FibGVkXFxcIikuYXR0cihcXFwiYXJpYS1kaXNhYmxlZFxcXCIsIFxcXCJ0cnVlXFxcIik7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX29uKHtcXG4gICAgICAgIC8vIFByZXZlbnQgZm9jdXMgZnJvbSBzdGlja2luZyB0byBsaW5rcyBpbnNpZGUgbWVudSBhZnRlciBjbGlja2luZ1xcbiAgICAgICAgLy8gdGhlbSAoZm9jdXMgc2hvdWxkIGFsd2F5cyBzdGF5IG9uIFVMIGR1cmluZyBuYXZpZ2F0aW9uKS5cXG4gICAgICAgIFxcXCJtb3VzZWRvd24gLnVpLW1lbnUtaXRlbVxcXCI6IGZ1bmN0aW9uIG1vdXNlZG93blVpTWVudUl0ZW0oZXZlbnQpIHtcXG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgIH0sXFxuICAgICAgICBcXFwiY2xpY2sgLnVpLW1lbnUtaXRlbVxcXCI6IGZ1bmN0aW9uIGNsaWNrVWlNZW51SXRlbShldmVudCkge1xcbiAgICAgICAgICB2YXIgdGFyZ2V0ID0gJChldmVudC50YXJnZXQpO1xcblxcbiAgICAgICAgICBpZiAoIXRoaXMubW91c2VIYW5kbGVkICYmIHRhcmdldC5ub3QoXFxcIi51aS1zdGF0ZS1kaXNhYmxlZFxcXCIpLmxlbmd0aCkge1xcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0KGV2ZW50KTsgLy8gT25seSBzZXQgdGhlIG1vdXNlSGFuZGxlZCBmbGFnIGlmIHRoZSBldmVudCB3aWxsIGJ1YmJsZSwgc2VlICM5NDY5LlxcblxcbiAgICAgICAgICAgIGlmICghZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xcbiAgICAgICAgICAgICAgdGhpcy5tb3VzZUhhbmRsZWQgPSB0cnVlO1xcbiAgICAgICAgICAgIH0gLy8gT3BlbiBzdWJtZW51IG9uIGNsaWNrXFxuXFxuXFxuICAgICAgICAgICAgaWYgKHRhcmdldC5oYXMoXFxcIi51aS1tZW51XFxcIikubGVuZ3RoKSB7XFxuICAgICAgICAgICAgICB0aGlzLmV4cGFuZChldmVudCk7XFxuICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5lbGVtZW50LmlzKFxcXCI6Zm9jdXNcXFwiKSAmJiAkKHRoaXMuZG9jdW1lbnRbMF0uYWN0aXZlRWxlbWVudCkuY2xvc2VzdChcXFwiLnVpLW1lbnVcXFwiKS5sZW5ndGgpIHtcXG4gICAgICAgICAgICAgIC8vIFJlZGlyZWN0IGZvY3VzIHRvIHRoZSBtZW51XFxuICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQudHJpZ2dlcihcXFwiZm9jdXNcXFwiLCBbdHJ1ZV0pOyAvLyBJZiB0aGUgYWN0aXZlIGl0ZW0gaXMgb24gdGhlIHRvcCBsZXZlbCwgbGV0IGl0IHN0YXkgYWN0aXZlLlxcbiAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBibHVyIHRoZSBhY3RpdmUgaXRlbSBzaW5jZSBpdCBpcyBubyBsb25nZXIgdmlzaWJsZS5cXG5cXG4gICAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZSAmJiB0aGlzLmFjdGl2ZS5wYXJlbnRzKFxcXCIudWktbWVudVxcXCIpLmxlbmd0aCA9PT0gMSkge1xcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgXFxcIm1vdXNlZW50ZXIgLnVpLW1lbnUtaXRlbVxcXCI6IGZ1bmN0aW9uIG1vdXNlZW50ZXJVaU1lbnVJdGVtKGV2ZW50KSB7XFxuICAgICAgICAgIC8vIElnbm9yZSBtb3VzZSBldmVudHMgd2hpbGUgdHlwZWFoZWFkIGlzIGFjdGl2ZSwgc2VlICMxMDQ1OC5cXG4gICAgICAgICAgLy8gUHJldmVudHMgZm9jdXNpbmcgdGhlIHdyb25nIGl0ZW0gd2hlbiB0eXBlYWhlYWQgY2F1c2VzIGEgc2Nyb2xsIHdoaWxlIHRoZSBtb3VzZVxcbiAgICAgICAgICAvLyBpcyBvdmVyIGFuIGl0ZW0gaW4gdGhlIG1lbnVcXG4gICAgICAgICAgaWYgKHRoaXMucHJldmlvdXNGaWx0ZXIpIHtcXG4gICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgdmFyIHRhcmdldCA9ICQoZXZlbnQuY3VycmVudFRhcmdldCk7IC8vIFJlbW92ZSB1aS1zdGF0ZS1hY3RpdmUgY2xhc3MgZnJvbSBzaWJsaW5ncyBvZiB0aGUgbmV3bHkgZm9jdXNlZCBtZW51IGl0ZW1cXG4gICAgICAgICAgLy8gdG8gYXZvaWQgYSBqdW1wIGNhdXNlZCBieSBhZGphY2VudCBlbGVtZW50cyBib3RoIGhhdmluZyBhIGNsYXNzIHdpdGggYSBib3JkZXJcXG5cXG4gICAgICAgICAgdGFyZ2V0LnNpYmxpbmdzKFxcXCIudWktc3RhdGUtYWN0aXZlXFxcIikucmVtb3ZlQ2xhc3MoXFxcInVpLXN0YXRlLWFjdGl2ZVxcXCIpO1xcbiAgICAgICAgICB0aGlzLmZvY3VzKGV2ZW50LCB0YXJnZXQpO1xcbiAgICAgICAgfSxcXG4gICAgICAgIG1vdXNlbGVhdmU6IFxcXCJjb2xsYXBzZUFsbFxcXCIsXFxuICAgICAgICBcXFwibW91c2VsZWF2ZSAudWktbWVudVxcXCI6IFxcXCJjb2xsYXBzZUFsbFxcXCIsXFxuICAgICAgICBmb2N1czogZnVuY3Rpb24gZm9jdXMoZXZlbnQsIGtlZXBBY3RpdmVJdGVtKSB7XFxuICAgICAgICAgIC8vIElmIHRoZXJlJ3MgYWxyZWFkeSBhbiBhY3RpdmUgaXRlbSwga2VlcCBpdCBhY3RpdmVcXG4gICAgICAgICAgLy8gSWYgbm90LCBhY3RpdmF0ZSB0aGUgZmlyc3QgaXRlbVxcbiAgICAgICAgICB2YXIgaXRlbSA9IHRoaXMuYWN0aXZlIHx8IHRoaXMuZWxlbWVudC5maW5kKHRoaXMub3B0aW9ucy5pdGVtcykuZXEoMCk7XFxuXFxuICAgICAgICAgIGlmICgha2VlcEFjdGl2ZUl0ZW0pIHtcXG4gICAgICAgICAgICB0aGlzLmZvY3VzKGV2ZW50LCBpdGVtKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSxcXG4gICAgICAgIGJsdXI6IGZ1bmN0aW9uIGJsdXIoZXZlbnQpIHtcXG4gICAgICAgICAgdGhpcy5fZGVsYXkoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIGlmICghJC5jb250YWlucyh0aGlzLmVsZW1lbnRbMF0sIHRoaXMuZG9jdW1lbnRbMF0uYWN0aXZlRWxlbWVudCkpIHtcXG4gICAgICAgICAgICAgIHRoaXMuY29sbGFwc2VBbGwoZXZlbnQpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9LFxcbiAgICAgICAga2V5ZG93bjogXFxcIl9rZXlkb3duXFxcIlxcbiAgICAgIH0pO1xcblxcbiAgICAgIHRoaXMucmVmcmVzaCgpOyAvLyBDbGlja3Mgb3V0c2lkZSBvZiBhIG1lbnUgY29sbGFwc2UgYW55IG9wZW4gbWVudXNcXG5cXG4gICAgICB0aGlzLl9vbih0aGlzLmRvY3VtZW50LCB7XFxuICAgICAgICBjbGljazogZnVuY3Rpb24gY2xpY2soZXZlbnQpIHtcXG4gICAgICAgICAgaWYgKHRoaXMuX2Nsb3NlT25Eb2N1bWVudENsaWNrKGV2ZW50KSkge1xcbiAgICAgICAgICAgIHRoaXMuY29sbGFwc2VBbGwoZXZlbnQpO1xcbiAgICAgICAgICB9IC8vIFJlc2V0IHRoZSBtb3VzZUhhbmRsZWQgZmxhZ1xcblxcblxcbiAgICAgICAgICB0aGlzLm1vdXNlSGFuZGxlZCA9IGZhbHNlO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcbiAgICB9LFxcbiAgICBfZGVzdHJveTogZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XFxuICAgICAgLy8gRGVzdHJveSAoc3ViKW1lbnVzXFxuICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZUF0dHIoXFxcImFyaWEtYWN0aXZlZGVzY2VuZGFudFxcXCIpLmZpbmQoXFxcIi51aS1tZW51XFxcIikuYWRkQmFjaygpLnJlbW92ZUNsYXNzKFxcXCJ1aS1tZW51IHVpLXdpZGdldCB1aS13aWRnZXQtY29udGVudCB1aS1tZW51LWljb25zIHVpLWZyb250XFxcIikucmVtb3ZlQXR0cihcXFwicm9sZVxcXCIpLnJlbW92ZUF0dHIoXFxcInRhYkluZGV4XFxcIikucmVtb3ZlQXR0cihcXFwiYXJpYS1sYWJlbGxlZGJ5XFxcIikucmVtb3ZlQXR0cihcXFwiYXJpYS1leHBhbmRlZFxcXCIpLnJlbW92ZUF0dHIoXFxcImFyaWEtaGlkZGVuXFxcIikucmVtb3ZlQXR0cihcXFwiYXJpYS1kaXNhYmxlZFxcXCIpLnJlbW92ZVVuaXF1ZUlkKCkuc2hvdygpOyAvLyBEZXN0cm95IG1lbnUgaXRlbXNcXG5cXG4gICAgICB0aGlzLmVsZW1lbnQuZmluZChcXFwiLnVpLW1lbnUtaXRlbVxcXCIpLnJlbW92ZUNsYXNzKFxcXCJ1aS1tZW51LWl0ZW1cXFwiKS5yZW1vdmVBdHRyKFxcXCJyb2xlXFxcIikucmVtb3ZlQXR0cihcXFwiYXJpYS1kaXNhYmxlZFxcXCIpLnJlbW92ZVVuaXF1ZUlkKCkucmVtb3ZlQ2xhc3MoXFxcInVpLXN0YXRlLWhvdmVyXFxcIikucmVtb3ZlQXR0cihcXFwidGFiSW5kZXhcXFwiKS5yZW1vdmVBdHRyKFxcXCJyb2xlXFxcIikucmVtb3ZlQXR0cihcXFwiYXJpYS1oYXNwb3B1cFxcXCIpLmNoaWxkcmVuKCkuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgZWxlbSA9ICQodGhpcyk7XFxuXFxuICAgICAgICBpZiAoZWxlbS5kYXRhKFxcXCJ1aS1tZW51LXN1Ym1lbnUtY2FyYXRcXFwiKSkge1xcbiAgICAgICAgICBlbGVtLnJlbW92ZSgpO1xcbiAgICAgICAgfVxcbiAgICAgIH0pOyAvLyBEZXN0cm95IG1lbnUgZGl2aWRlcnNcXG5cXG4gICAgICB0aGlzLmVsZW1lbnQuZmluZChcXFwiLnVpLW1lbnUtZGl2aWRlclxcXCIpLnJlbW92ZUNsYXNzKFxcXCJ1aS1tZW51LWRpdmlkZXIgdWktd2lkZ2V0LWNvbnRlbnRcXFwiKTtcXG4gICAgfSxcXG4gICAgX2tleWRvd246IGZ1bmN0aW9uIF9rZXlkb3duKGV2ZW50KSB7XFxuICAgICAgdmFyIG1hdGNoLFxcbiAgICAgICAgICBwcmV2LFxcbiAgICAgICAgICBjaGFyYWN0ZXIsXFxuICAgICAgICAgIHNraXAsXFxuICAgICAgICAgIHByZXZlbnREZWZhdWx0ID0gdHJ1ZTtcXG5cXG4gICAgICBzd2l0Y2ggKGV2ZW50LmtleUNvZGUpIHtcXG4gICAgICAgIGNhc2UgJC51aS5rZXlDb2RlLlBBR0VfVVA6XFxuICAgICAgICAgIHRoaXMucHJldmlvdXNQYWdlKGV2ZW50KTtcXG4gICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICBjYXNlICQudWkua2V5Q29kZS5QQUdFX0RPV046XFxuICAgICAgICAgIHRoaXMubmV4dFBhZ2UoZXZlbnQpO1xcbiAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgIGNhc2UgJC51aS5rZXlDb2RlLkhPTUU6XFxuICAgICAgICAgIHRoaXMuX21vdmUoXFxcImZpcnN0XFxcIiwgXFxcImZpcnN0XFxcIiwgZXZlbnQpO1xcblxcbiAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgIGNhc2UgJC51aS5rZXlDb2RlLkVORDpcXG4gICAgICAgICAgdGhpcy5fbW92ZShcXFwibGFzdFxcXCIsIFxcXCJsYXN0XFxcIiwgZXZlbnQpO1xcblxcbiAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgIGNhc2UgJC51aS5rZXlDb2RlLlVQOlxcbiAgICAgICAgICB0aGlzLnByZXZpb3VzKGV2ZW50KTtcXG4gICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICBjYXNlICQudWkua2V5Q29kZS5ET1dOOlxcbiAgICAgICAgICB0aGlzLm5leHQoZXZlbnQpO1xcbiAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgIGNhc2UgJC51aS5rZXlDb2RlLkxFRlQ6XFxuICAgICAgICAgIHRoaXMuY29sbGFwc2UoZXZlbnQpO1xcbiAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgIGNhc2UgJC51aS5rZXlDb2RlLlJJR0hUOlxcbiAgICAgICAgICBpZiAodGhpcy5hY3RpdmUgJiYgIXRoaXMuYWN0aXZlLmlzKFxcXCIudWktc3RhdGUtZGlzYWJsZWRcXFwiKSkge1xcbiAgICAgICAgICAgIHRoaXMuZXhwYW5kKGV2ZW50KTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgIGNhc2UgJC51aS5rZXlDb2RlLkVOVEVSOlxcbiAgICAgICAgY2FzZSAkLnVpLmtleUNvZGUuU1BBQ0U6XFxuICAgICAgICAgIHRoaXMuX2FjdGl2YXRlKGV2ZW50KTtcXG5cXG4gICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICBjYXNlICQudWkua2V5Q29kZS5FU0NBUEU6XFxuICAgICAgICAgIHRoaXMuY29sbGFwc2UoZXZlbnQpO1xcbiAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgIGRlZmF1bHQ6XFxuICAgICAgICAgIHByZXZlbnREZWZhdWx0ID0gZmFsc2U7XFxuICAgICAgICAgIHByZXYgPSB0aGlzLnByZXZpb3VzRmlsdGVyIHx8IFxcXCJcXFwiO1xcbiAgICAgICAgICBjaGFyYWN0ZXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGV2ZW50LmtleUNvZGUpO1xcbiAgICAgICAgICBza2lwID0gZmFsc2U7XFxuICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmZpbHRlclRpbWVyKTtcXG5cXG4gICAgICAgICAgaWYgKGNoYXJhY3RlciA9PT0gcHJldikge1xcbiAgICAgICAgICAgIHNraXAgPSB0cnVlO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGNoYXJhY3RlciA9IHByZXYgKyBjaGFyYWN0ZXI7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgbWF0Y2ggPSB0aGlzLl9maWx0ZXJNZW51SXRlbXMoY2hhcmFjdGVyKTtcXG4gICAgICAgICAgbWF0Y2ggPSBza2lwICYmIG1hdGNoLmluZGV4KHRoaXMuYWN0aXZlLm5leHQoKSkgIT09IC0xID8gdGhpcy5hY3RpdmUubmV4dEFsbChcXFwiLnVpLW1lbnUtaXRlbVxcXCIpIDogbWF0Y2g7IC8vIElmIG5vIG1hdGNoZXMgb24gdGhlIGN1cnJlbnQgZmlsdGVyLCByZXNldCB0byB0aGUgbGFzdCBjaGFyYWN0ZXIgcHJlc3NlZFxcbiAgICAgICAgICAvLyB0byBtb3ZlIGRvd24gdGhlIG1lbnUgdG8gdGhlIGZpcnN0IGl0ZW0gdGhhdCBzdGFydHMgd2l0aCB0aGF0IGNoYXJhY3RlclxcblxcbiAgICAgICAgICBpZiAoIW1hdGNoLmxlbmd0aCkge1xcbiAgICAgICAgICAgIGNoYXJhY3RlciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoZXZlbnQua2V5Q29kZSk7XFxuICAgICAgICAgICAgbWF0Y2ggPSB0aGlzLl9maWx0ZXJNZW51SXRlbXMoY2hhcmFjdGVyKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAobWF0Y2gubGVuZ3RoKSB7XFxuICAgICAgICAgICAgdGhpcy5mb2N1cyhldmVudCwgbWF0Y2gpO1xcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXNGaWx0ZXIgPSBjaGFyYWN0ZXI7XFxuICAgICAgICAgICAgdGhpcy5maWx0ZXJUaW1lciA9IHRoaXMuX2RlbGF5KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnByZXZpb3VzRmlsdGVyO1xcbiAgICAgICAgICAgIH0sIDEwMDApO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnByZXZpb3VzRmlsdGVyO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgfVxcblxcbiAgICAgIGlmIChwcmV2ZW50RGVmYXVsdCkge1xcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIF9hY3RpdmF0ZTogZnVuY3Rpb24gX2FjdGl2YXRlKGV2ZW50KSB7XFxuICAgICAgaWYgKCF0aGlzLmFjdGl2ZS5pcyhcXFwiLnVpLXN0YXRlLWRpc2FibGVkXFxcIikpIHtcXG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZS5pcyhcXFwiW2FyaWEtaGFzcG9wdXA9J3RydWUnXVxcXCIpKSB7XFxuICAgICAgICAgIHRoaXMuZXhwYW5kKGV2ZW50KTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHRoaXMuc2VsZWN0KGV2ZW50KTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH0sXFxuICAgIHJlZnJlc2g6IGZ1bmN0aW9uIHJlZnJlc2goKSB7XFxuICAgICAgdmFyIG1lbnVzLFxcbiAgICAgICAgICBpdGVtcyxcXG4gICAgICAgICAgdGhhdCA9IHRoaXMsXFxuICAgICAgICAgIGljb24gPSB0aGlzLm9wdGlvbnMuaWNvbnMuc3VibWVudSxcXG4gICAgICAgICAgc3VibWVudXMgPSB0aGlzLmVsZW1lbnQuZmluZCh0aGlzLm9wdGlvbnMubWVudXMpO1xcbiAgICAgIHRoaXMuZWxlbWVudC50b2dnbGVDbGFzcyhcXFwidWktbWVudS1pY29uc1xcXCIsICEhdGhpcy5lbGVtZW50LmZpbmQoXFxcIi51aS1pY29uXFxcIikubGVuZ3RoKTsgLy8gSW5pdGlhbGl6ZSBuZXN0ZWQgbWVudXNcXG5cXG4gICAgICBzdWJtZW51cy5maWx0ZXIoXFxcIjpub3QoLnVpLW1lbnUpXFxcIikuYWRkQ2xhc3MoXFxcInVpLW1lbnUgdWktd2lkZ2V0IHVpLXdpZGdldC1jb250ZW50IHVpLWZyb250XFxcIikuaGlkZSgpLmF0dHIoe1xcbiAgICAgICAgcm9sZTogdGhpcy5vcHRpb25zLnJvbGUsXFxuICAgICAgICBcXFwiYXJpYS1oaWRkZW5cXFwiOiBcXFwidHJ1ZVxcXCIsXFxuICAgICAgICBcXFwiYXJpYS1leHBhbmRlZFxcXCI6IFxcXCJmYWxzZVxcXCJcXG4gICAgICB9KS5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciBtZW51ID0gJCh0aGlzKSxcXG4gICAgICAgICAgICBpdGVtID0gbWVudS5wYXJlbnQoKSxcXG4gICAgICAgICAgICBzdWJtZW51Q2FyYXQgPSAkKFxcXCI8c3Bhbj5cXFwiKS5hZGRDbGFzcyhcXFwidWktbWVudS1pY29uIHVpLWljb24gXFxcIiArIGljb24pLmRhdGEoXFxcInVpLW1lbnUtc3VibWVudS1jYXJhdFxcXCIsIHRydWUpO1xcbiAgICAgICAgaXRlbS5hdHRyKFxcXCJhcmlhLWhhc3BvcHVwXFxcIiwgXFxcInRydWVcXFwiKS5wcmVwZW5kKHN1Ym1lbnVDYXJhdCk7XFxuICAgICAgICBtZW51LmF0dHIoXFxcImFyaWEtbGFiZWxsZWRieVxcXCIsIGl0ZW0uYXR0cihcXFwiaWRcXFwiKSk7XFxuICAgICAgfSk7XFxuICAgICAgbWVudXMgPSBzdWJtZW51cy5hZGQodGhpcy5lbGVtZW50KTtcXG4gICAgICBpdGVtcyA9IG1lbnVzLmZpbmQodGhpcy5vcHRpb25zLml0ZW1zKTsgLy8gSW5pdGlhbGl6ZSBtZW51LWl0ZW1zIGNvbnRhaW5pbmcgc3BhY2VzIGFuZC9vciBkYXNoZXMgb25seSBhcyBkaXZpZGVyc1xcblxcbiAgICAgIGl0ZW1zLm5vdChcXFwiLnVpLW1lbnUtaXRlbVxcXCIpLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIGl0ZW0gPSAkKHRoaXMpO1xcblxcbiAgICAgICAgaWYgKHRoYXQuX2lzRGl2aWRlcihpdGVtKSkge1xcbiAgICAgICAgICBpdGVtLmFkZENsYXNzKFxcXCJ1aS13aWRnZXQtY29udGVudCB1aS1tZW51LWRpdmlkZXJcXFwiKTtcXG4gICAgICAgIH1cXG4gICAgICB9KTsgLy8gRG9uJ3QgcmVmcmVzaCBsaXN0IGl0ZW1zIHRoYXQgYXJlIGFscmVhZHkgYWRhcHRlZFxcblxcbiAgICAgIGl0ZW1zLm5vdChcXFwiLnVpLW1lbnUtaXRlbSwgLnVpLW1lbnUtZGl2aWRlclxcXCIpLmFkZENsYXNzKFxcXCJ1aS1tZW51LWl0ZW1cXFwiKS51bmlxdWVJZCgpLmF0dHIoe1xcbiAgICAgICAgdGFiSW5kZXg6IC0xLFxcbiAgICAgICAgcm9sZTogdGhpcy5faXRlbVJvbGUoKVxcbiAgICAgIH0pOyAvLyBBZGQgYXJpYS1kaXNhYmxlZCBhdHRyaWJ1dGUgdG8gYW55IGRpc2FibGVkIG1lbnUgaXRlbVxcblxcbiAgICAgIGl0ZW1zLmZpbHRlcihcXFwiLnVpLXN0YXRlLWRpc2FibGVkXFxcIikuYXR0cihcXFwiYXJpYS1kaXNhYmxlZFxcXCIsIFxcXCJ0cnVlXFxcIik7IC8vIElmIHRoZSBhY3RpdmUgaXRlbSBoYXMgYmVlbiByZW1vdmVkLCBibHVyIHRoZSBtZW51XFxuXFxuICAgICAgaWYgKHRoaXMuYWN0aXZlICYmICEkLmNvbnRhaW5zKHRoaXMuZWxlbWVudFswXSwgdGhpcy5hY3RpdmVbMF0pKSB7XFxuICAgICAgICB0aGlzLmJsdXIoKTtcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIF9pdGVtUm9sZTogZnVuY3Rpb24gX2l0ZW1Sb2xlKCkge1xcbiAgICAgIHJldHVybiB7XFxuICAgICAgICBtZW51OiBcXFwibWVudWl0ZW1cXFwiLFxcbiAgICAgICAgbGlzdGJveDogXFxcIm9wdGlvblxcXCJcXG4gICAgICB9W3RoaXMub3B0aW9ucy5yb2xlXTtcXG4gICAgfSxcXG4gICAgX3NldE9wdGlvbjogZnVuY3Rpb24gX3NldE9wdGlvbihrZXksIHZhbHVlKSB7XFxuICAgICAgaWYgKGtleSA9PT0gXFxcImljb25zXFxcIikge1xcbiAgICAgICAgdGhpcy5lbGVtZW50LmZpbmQoXFxcIi51aS1tZW51LWljb25cXFwiKS5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuaWNvbnMuc3VibWVudSkuYWRkQ2xhc3ModmFsdWUuc3VibWVudSk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChrZXkgPT09IFxcXCJkaXNhYmxlZFxcXCIpIHtcXG4gICAgICAgIHRoaXMuZWxlbWVudC50b2dnbGVDbGFzcyhcXFwidWktc3RhdGUtZGlzYWJsZWRcXFwiLCAhIXZhbHVlKS5hdHRyKFxcXCJhcmlhLWRpc2FibGVkXFxcIiwgdmFsdWUpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9zdXBlcihrZXksIHZhbHVlKTtcXG4gICAgfSxcXG4gICAgZm9jdXM6IGZ1bmN0aW9uIGZvY3VzKGV2ZW50LCBpdGVtKSB7XFxuICAgICAgdmFyIG5lc3RlZCwgZm9jdXNlZDtcXG4gICAgICB0aGlzLmJsdXIoZXZlbnQsIGV2ZW50ICYmIGV2ZW50LnR5cGUgPT09IFxcXCJmb2N1c1xcXCIpO1xcblxcbiAgICAgIHRoaXMuX3Njcm9sbEludG9WaWV3KGl0ZW0pO1xcblxcbiAgICAgIHRoaXMuYWN0aXZlID0gaXRlbS5maXJzdCgpO1xcbiAgICAgIGZvY3VzZWQgPSB0aGlzLmFjdGl2ZS5hZGRDbGFzcyhcXFwidWktc3RhdGUtZm9jdXNcXFwiKS5yZW1vdmVDbGFzcyhcXFwidWktc3RhdGUtYWN0aXZlXFxcIik7IC8vIE9ubHkgdXBkYXRlIGFyaWEtYWN0aXZlZGVzY2VuZGFudCBpZiB0aGVyZSdzIGEgcm9sZVxcbiAgICAgIC8vIG90aGVyd2lzZSB3ZSBhc3N1bWUgZm9jdXMgaXMgbWFuYWdlZCBlbHNld2hlcmVcXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnJvbGUpIHtcXG4gICAgICAgIHRoaXMuZWxlbWVudC5hdHRyKFxcXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcXFwiLCBmb2N1c2VkLmF0dHIoXFxcImlkXFxcIikpO1xcbiAgICAgIH0gLy8gSGlnaGxpZ2h0IGFjdGl2ZSBwYXJlbnQgbWVudSBpdGVtLCBpZiBhbnlcXG5cXG5cXG4gICAgICB0aGlzLmFjdGl2ZS5wYXJlbnQoKS5jbG9zZXN0KFxcXCIudWktbWVudS1pdGVtXFxcIikuYWRkQ2xhc3MoXFxcInVpLXN0YXRlLWFjdGl2ZVxcXCIpO1xcblxcbiAgICAgIGlmIChldmVudCAmJiBldmVudC50eXBlID09PSBcXFwia2V5ZG93blxcXCIpIHtcXG4gICAgICAgIHRoaXMuX2Nsb3NlKCk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRoaXMudGltZXIgPSB0aGlzLl9kZWxheShmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHRoaXMuX2Nsb3NlKCk7XFxuICAgICAgICB9LCB0aGlzLmRlbGF5KTtcXG4gICAgICB9XFxuXFxuICAgICAgbmVzdGVkID0gaXRlbS5jaGlsZHJlbihcXFwiLnVpLW1lbnVcXFwiKTtcXG5cXG4gICAgICBpZiAobmVzdGVkLmxlbmd0aCAmJiBldmVudCAmJiAvXm1vdXNlLy50ZXN0KGV2ZW50LnR5cGUpKSB7XFxuICAgICAgICB0aGlzLl9zdGFydE9wZW5pbmcobmVzdGVkKTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5hY3RpdmVNZW51ID0gaXRlbS5wYXJlbnQoKTtcXG5cXG4gICAgICB0aGlzLl90cmlnZ2VyKFxcXCJmb2N1c1xcXCIsIGV2ZW50LCB7XFxuICAgICAgICBpdGVtOiBpdGVtXFxuICAgICAgfSk7XFxuICAgIH0sXFxuICAgIF9zY3JvbGxJbnRvVmlldzogZnVuY3Rpb24gX3Njcm9sbEludG9WaWV3KGl0ZW0pIHtcXG4gICAgICB2YXIgYm9yZGVyVG9wLCBwYWRkaW5nVG9wLCBvZmZzZXQsIHNjcm9sbCwgZWxlbWVudEhlaWdodCwgaXRlbUhlaWdodDtcXG5cXG4gICAgICBpZiAodGhpcy5faGFzU2Nyb2xsKCkpIHtcXG4gICAgICAgIGJvcmRlclRvcCA9IHBhcnNlRmxvYXQoJC5jc3ModGhpcy5hY3RpdmVNZW51WzBdLCBcXFwiYm9yZGVyVG9wV2lkdGhcXFwiKSkgfHwgMDtcXG4gICAgICAgIHBhZGRpbmdUb3AgPSBwYXJzZUZsb2F0KCQuY3NzKHRoaXMuYWN0aXZlTWVudVswXSwgXFxcInBhZGRpbmdUb3BcXFwiKSkgfHwgMDtcXG4gICAgICAgIG9mZnNldCA9IGl0ZW0ub2Zmc2V0KCkudG9wIC0gdGhpcy5hY3RpdmVNZW51Lm9mZnNldCgpLnRvcCAtIGJvcmRlclRvcCAtIHBhZGRpbmdUb3A7XFxuICAgICAgICBzY3JvbGwgPSB0aGlzLmFjdGl2ZU1lbnUuc2Nyb2xsVG9wKCk7XFxuICAgICAgICBlbGVtZW50SGVpZ2h0ID0gdGhpcy5hY3RpdmVNZW51LmhlaWdodCgpO1xcbiAgICAgICAgaXRlbUhlaWdodCA9IGl0ZW0ub3V0ZXJIZWlnaHQoKTtcXG5cXG4gICAgICAgIGlmIChvZmZzZXQgPCAwKSB7XFxuICAgICAgICAgIHRoaXMuYWN0aXZlTWVudS5zY3JvbGxUb3Aoc2Nyb2xsICsgb2Zmc2V0KTtcXG4gICAgICAgIH0gZWxzZSBpZiAob2Zmc2V0ICsgaXRlbUhlaWdodCA+IGVsZW1lbnRIZWlnaHQpIHtcXG4gICAgICAgICAgdGhpcy5hY3RpdmVNZW51LnNjcm9sbFRvcChzY3JvbGwgKyBvZmZzZXQgLSBlbGVtZW50SGVpZ2h0ICsgaXRlbUhlaWdodCk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9LFxcbiAgICBibHVyOiBmdW5jdGlvbiBibHVyKGV2ZW50LCBmcm9tRm9jdXMpIHtcXG4gICAgICBpZiAoIWZyb21Gb2N1cykge1xcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIXRoaXMuYWN0aXZlKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuYWN0aXZlLnJlbW92ZUNsYXNzKFxcXCJ1aS1zdGF0ZS1mb2N1c1xcXCIpO1xcbiAgICAgIHRoaXMuYWN0aXZlID0gbnVsbDtcXG5cXG4gICAgICB0aGlzLl90cmlnZ2VyKFxcXCJibHVyXFxcIiwgZXZlbnQsIHtcXG4gICAgICAgIGl0ZW06IHRoaXMuYWN0aXZlXFxuICAgICAgfSk7XFxuICAgIH0sXFxuICAgIF9zdGFydE9wZW5pbmc6IGZ1bmN0aW9uIF9zdGFydE9wZW5pbmcoc3VibWVudSkge1xcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTsgLy8gRG9uJ3Qgb3BlbiBpZiBhbHJlYWR5IG9wZW4gZml4ZXMgYSBGaXJlZm94IGJ1ZyB0aGF0IGNhdXNlZCBhIC41IHBpeGVsXFxuICAgICAgLy8gc2hpZnQgaW4gdGhlIHN1Ym1lbnUgcG9zaXRpb24gd2hlbiBtb3VzaW5nIG92ZXIgdGhlIGNhcmF0IGljb25cXG5cXG4gICAgICBpZiAoc3VibWVudS5hdHRyKFxcXCJhcmlhLWhpZGRlblxcXCIpICE9PSBcXFwidHJ1ZVxcXCIpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy50aW1lciA9IHRoaXMuX2RlbGF5KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHRoaXMuX2Nsb3NlKCk7XFxuXFxuICAgICAgICB0aGlzLl9vcGVuKHN1Ym1lbnUpO1xcbiAgICAgIH0sIHRoaXMuZGVsYXkpO1xcbiAgICB9LFxcbiAgICBfb3BlbjogZnVuY3Rpb24gX29wZW4oc3VibWVudSkge1xcbiAgICAgIHZhciBwb3NpdGlvbiA9ICQuZXh0ZW5kKHtcXG4gICAgICAgIG9mOiB0aGlzLmFjdGl2ZVxcbiAgICAgIH0sIHRoaXMub3B0aW9ucy5wb3NpdGlvbik7XFxuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xcbiAgICAgIHRoaXMuZWxlbWVudC5maW5kKFxcXCIudWktbWVudVxcXCIpLm5vdChzdWJtZW51LnBhcmVudHMoXFxcIi51aS1tZW51XFxcIikpLmhpZGUoKS5hdHRyKFxcXCJhcmlhLWhpZGRlblxcXCIsIFxcXCJ0cnVlXFxcIik7XFxuICAgICAgc3VibWVudS5zaG93KCkucmVtb3ZlQXR0cihcXFwiYXJpYS1oaWRkZW5cXFwiKS5hdHRyKFxcXCJhcmlhLWV4cGFuZGVkXFxcIiwgXFxcInRydWVcXFwiKS5wb3NpdGlvbihwb3NpdGlvbik7XFxuICAgIH0sXFxuICAgIGNvbGxhcHNlQWxsOiBmdW5jdGlvbiBjb2xsYXBzZUFsbChldmVudCwgYWxsKSB7XFxuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xcbiAgICAgIHRoaXMudGltZXIgPSB0aGlzLl9kZWxheShmdW5jdGlvbiAoKSB7XFxuICAgICAgICAvLyBJZiB3ZSB3ZXJlIHBhc3NlZCBhbiBldmVudCwgbG9vayBmb3IgdGhlIHN1Ym1lbnUgdGhhdCBjb250YWlucyB0aGUgZXZlbnRcXG4gICAgICAgIHZhciBjdXJyZW50TWVudSA9IGFsbCA/IHRoaXMuZWxlbWVudCA6ICQoZXZlbnQgJiYgZXZlbnQudGFyZ2V0KS5jbG9zZXN0KHRoaXMuZWxlbWVudC5maW5kKFxcXCIudWktbWVudVxcXCIpKTsgLy8gSWYgd2UgZm91bmQgbm8gdmFsaWQgc3VibWVudSBhbmNlc3RvciwgdXNlIHRoZSBtYWluIG1lbnUgdG8gY2xvc2UgYWxsIHN1YiBtZW51cyBhbnl3YXlcXG5cXG4gICAgICAgIGlmICghY3VycmVudE1lbnUubGVuZ3RoKSB7XFxuICAgICAgICAgIGN1cnJlbnRNZW51ID0gdGhpcy5lbGVtZW50O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdGhpcy5fY2xvc2UoY3VycmVudE1lbnUpO1xcblxcbiAgICAgICAgdGhpcy5ibHVyKGV2ZW50KTtcXG4gICAgICAgIHRoaXMuYWN0aXZlTWVudSA9IGN1cnJlbnRNZW51O1xcbiAgICAgIH0sIHRoaXMuZGVsYXkpO1xcbiAgICB9LFxcbiAgICAvLyBXaXRoIG5vIGFyZ3VtZW50cywgY2xvc2VzIHRoZSBjdXJyZW50bHkgYWN0aXZlIG1lbnUgLSBpZiBub3RoaW5nIGlzIGFjdGl2ZVxcbiAgICAvLyBpdCBjbG9zZXMgYWxsIG1lbnVzLiAgSWYgcGFzc2VkIGFuIGFyZ3VtZW50LCBpdCB3aWxsIHNlYXJjaCBmb3IgbWVudXMgQkVMT1dcXG4gICAgX2Nsb3NlOiBmdW5jdGlvbiBfY2xvc2Uoc3RhcnRNZW51KSB7XFxuICAgICAgaWYgKCFzdGFydE1lbnUpIHtcXG4gICAgICAgIHN0YXJ0TWVudSA9IHRoaXMuYWN0aXZlID8gdGhpcy5hY3RpdmUucGFyZW50KCkgOiB0aGlzLmVsZW1lbnQ7XFxuICAgICAgfVxcblxcbiAgICAgIHN0YXJ0TWVudS5maW5kKFxcXCIudWktbWVudVxcXCIpLmhpZGUoKS5hdHRyKFxcXCJhcmlhLWhpZGRlblxcXCIsIFxcXCJ0cnVlXFxcIikuYXR0cihcXFwiYXJpYS1leHBhbmRlZFxcXCIsIFxcXCJmYWxzZVxcXCIpLmVuZCgpLmZpbmQoXFxcIi51aS1zdGF0ZS1hY3RpdmVcXFwiKS5ub3QoXFxcIi51aS1zdGF0ZS1mb2N1c1xcXCIpLnJlbW92ZUNsYXNzKFxcXCJ1aS1zdGF0ZS1hY3RpdmVcXFwiKTtcXG4gICAgfSxcXG4gICAgX2Nsb3NlT25Eb2N1bWVudENsaWNrOiBmdW5jdGlvbiBfY2xvc2VPbkRvY3VtZW50Q2xpY2soZXZlbnQpIHtcXG4gICAgICByZXR1cm4gISQoZXZlbnQudGFyZ2V0KS5jbG9zZXN0KFxcXCIudWktbWVudVxcXCIpLmxlbmd0aDtcXG4gICAgfSxcXG4gICAgX2lzRGl2aWRlcjogZnVuY3Rpb24gX2lzRGl2aWRlcihpdGVtKSB7XFxuICAgICAgLy8gTWF0Y2ggaHlwaGVuLCBlbSBkYXNoLCBlbiBkYXNoXFxuICAgICAgcmV0dXJuICEvW15cXFxcLVxcXFx1MjAxNFxcXFx1MjAxM1xcXFxzXS8udGVzdChpdGVtLnRleHQoKSk7XFxuICAgIH0sXFxuICAgIGNvbGxhcHNlOiBmdW5jdGlvbiBjb2xsYXBzZShldmVudCkge1xcbiAgICAgIHZhciBuZXdJdGVtID0gdGhpcy5hY3RpdmUgJiYgdGhpcy5hY3RpdmUucGFyZW50KCkuY2xvc2VzdChcXFwiLnVpLW1lbnUtaXRlbVxcXCIsIHRoaXMuZWxlbWVudCk7XFxuXFxuICAgICAgaWYgKG5ld0l0ZW0gJiYgbmV3SXRlbS5sZW5ndGgpIHtcXG4gICAgICAgIHRoaXMuX2Nsb3NlKCk7XFxuXFxuICAgICAgICB0aGlzLmZvY3VzKGV2ZW50LCBuZXdJdGVtKTtcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIGV4cGFuZDogZnVuY3Rpb24gZXhwYW5kKGV2ZW50KSB7XFxuICAgICAgdmFyIG5ld0l0ZW0gPSB0aGlzLmFjdGl2ZSAmJiB0aGlzLmFjdGl2ZS5jaGlsZHJlbihcXFwiLnVpLW1lbnUgXFxcIikuZmluZCh0aGlzLm9wdGlvbnMuaXRlbXMpLmZpcnN0KCk7XFxuXFxuICAgICAgaWYgKG5ld0l0ZW0gJiYgbmV3SXRlbS5sZW5ndGgpIHtcXG4gICAgICAgIHRoaXMuX29wZW4obmV3SXRlbS5wYXJlbnQoKSk7IC8vIERlbGF5IHNvIEZpcmVmb3ggd2lsbCBub3QgaGlkZSBhY3RpdmVkZXNjZW5kYW50IGNoYW5nZSBpbiBleHBhbmRpbmcgc3VibWVudSBmcm9tIEFUXFxuXFxuXFxuICAgICAgICB0aGlzLl9kZWxheShmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHRoaXMuZm9jdXMoZXZlbnQsIG5ld0l0ZW0pO1xcbiAgICAgICAgfSk7XFxuICAgICAgfVxcbiAgICB9LFxcbiAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KGV2ZW50KSB7XFxuICAgICAgdGhpcy5fbW92ZShcXFwibmV4dFxcXCIsIFxcXCJmaXJzdFxcXCIsIGV2ZW50KTtcXG4gICAgfSxcXG4gICAgcHJldmlvdXM6IGZ1bmN0aW9uIHByZXZpb3VzKGV2ZW50KSB7XFxuICAgICAgdGhpcy5fbW92ZShcXFwicHJldlxcXCIsIFxcXCJsYXN0XFxcIiwgZXZlbnQpO1xcbiAgICB9LFxcbiAgICBpc0ZpcnN0SXRlbTogZnVuY3Rpb24gaXNGaXJzdEl0ZW0oKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlICYmICF0aGlzLmFjdGl2ZS5wcmV2QWxsKFxcXCIudWktbWVudS1pdGVtXFxcIikubGVuZ3RoO1xcbiAgICB9LFxcbiAgICBpc0xhc3RJdGVtOiBmdW5jdGlvbiBpc0xhc3RJdGVtKCkge1xcbiAgICAgIHJldHVybiB0aGlzLmFjdGl2ZSAmJiAhdGhpcy5hY3RpdmUubmV4dEFsbChcXFwiLnVpLW1lbnUtaXRlbVxcXCIpLmxlbmd0aDtcXG4gICAgfSxcXG4gICAgX21vdmU6IGZ1bmN0aW9uIF9tb3ZlKGRpcmVjdGlvbiwgZmlsdGVyLCBldmVudCkge1xcbiAgICAgIHZhciBuZXh0O1xcblxcbiAgICAgIGlmICh0aGlzLmFjdGl2ZSkge1xcbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gXFxcImZpcnN0XFxcIiB8fCBkaXJlY3Rpb24gPT09IFxcXCJsYXN0XFxcIikge1xcbiAgICAgICAgICBuZXh0ID0gdGhpcy5hY3RpdmVbZGlyZWN0aW9uID09PSBcXFwiZmlyc3RcXFwiID8gXFxcInByZXZBbGxcXFwiIDogXFxcIm5leHRBbGxcXFwiXShcXFwiLnVpLW1lbnUtaXRlbVxcXCIpLmVxKC0xKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIG5leHQgPSB0aGlzLmFjdGl2ZVtkaXJlY3Rpb24gKyBcXFwiQWxsXFxcIl0oXFxcIi51aS1tZW51LWl0ZW1cXFwiKS5lcSgwKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCFuZXh0IHx8ICFuZXh0Lmxlbmd0aCB8fCAhdGhpcy5hY3RpdmUpIHtcXG4gICAgICAgIG5leHQgPSB0aGlzLmFjdGl2ZU1lbnUuZmluZCh0aGlzLm9wdGlvbnMuaXRlbXMpW2ZpbHRlcl0oKTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5mb2N1cyhldmVudCwgbmV4dCk7XFxuICAgIH0sXFxuICAgIG5leHRQYWdlOiBmdW5jdGlvbiBuZXh0UGFnZShldmVudCkge1xcbiAgICAgIHZhciBpdGVtLCBiYXNlLCBoZWlnaHQ7XFxuXFxuICAgICAgaWYgKCF0aGlzLmFjdGl2ZSkge1xcbiAgICAgICAgdGhpcy5uZXh0KGV2ZW50KTtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMuaXNMYXN0SXRlbSgpKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLl9oYXNTY3JvbGwoKSkge1xcbiAgICAgICAgYmFzZSA9IHRoaXMuYWN0aXZlLm9mZnNldCgpLnRvcDtcXG4gICAgICAgIGhlaWdodCA9IHRoaXMuZWxlbWVudC5oZWlnaHQoKTtcXG4gICAgICAgIHRoaXMuYWN0aXZlLm5leHRBbGwoXFxcIi51aS1tZW51LWl0ZW1cXFwiKS5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgaXRlbSA9ICQodGhpcyk7XFxuICAgICAgICAgIHJldHVybiBpdGVtLm9mZnNldCgpLnRvcCAtIGJhc2UgLSBoZWlnaHQgPCAwO1xcbiAgICAgICAgfSk7XFxuICAgICAgICB0aGlzLmZvY3VzKGV2ZW50LCBpdGVtKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdGhpcy5mb2N1cyhldmVudCwgdGhpcy5hY3RpdmVNZW51LmZpbmQodGhpcy5vcHRpb25zLml0ZW1zKVshdGhpcy5hY3RpdmUgPyBcXFwiZmlyc3RcXFwiIDogXFxcImxhc3RcXFwiXSgpKTtcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIHByZXZpb3VzUGFnZTogZnVuY3Rpb24gcHJldmlvdXNQYWdlKGV2ZW50KSB7XFxuICAgICAgdmFyIGl0ZW0sIGJhc2UsIGhlaWdodDtcXG5cXG4gICAgICBpZiAoIXRoaXMuYWN0aXZlKSB7XFxuICAgICAgICB0aGlzLm5leHQoZXZlbnQpO1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5pc0ZpcnN0SXRlbSgpKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLl9oYXNTY3JvbGwoKSkge1xcbiAgICAgICAgYmFzZSA9IHRoaXMuYWN0aXZlLm9mZnNldCgpLnRvcDtcXG4gICAgICAgIGhlaWdodCA9IHRoaXMuZWxlbWVudC5oZWlnaHQoKTtcXG4gICAgICAgIHRoaXMuYWN0aXZlLnByZXZBbGwoXFxcIi51aS1tZW51LWl0ZW1cXFwiKS5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgaXRlbSA9ICQodGhpcyk7XFxuICAgICAgICAgIHJldHVybiBpdGVtLm9mZnNldCgpLnRvcCAtIGJhc2UgKyBoZWlnaHQgPiAwO1xcbiAgICAgICAgfSk7XFxuICAgICAgICB0aGlzLmZvY3VzKGV2ZW50LCBpdGVtKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdGhpcy5mb2N1cyhldmVudCwgdGhpcy5hY3RpdmVNZW51LmZpbmQodGhpcy5vcHRpb25zLml0ZW1zKS5maXJzdCgpKTtcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIF9oYXNTY3JvbGw6IGZ1bmN0aW9uIF9oYXNTY3JvbGwoKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC5vdXRlckhlaWdodCgpIDwgdGhpcy5lbGVtZW50LnByb3AoXFxcInNjcm9sbEhlaWdodFxcXCIpO1xcbiAgICB9LFxcbiAgICBzZWxlY3Q6IGZ1bmN0aW9uIHNlbGVjdChldmVudCkge1xcbiAgICAgIC8vIFRPRE86IEl0IHNob3VsZCBuZXZlciBiZSBwb3NzaWJsZSB0byBub3QgaGF2ZSBhbiBhY3RpdmUgaXRlbSBhdCB0aGlzXFxuICAgICAgLy8gcG9pbnQsIGJ1dCB0aGUgdGVzdHMgZG9uJ3QgdHJpZ2dlciBtb3VzZWVudGVyIGJlZm9yZSBjbGljay5cXG4gICAgICB0aGlzLmFjdGl2ZSA9IHRoaXMuYWN0aXZlIHx8ICQoZXZlbnQudGFyZ2V0KS5jbG9zZXN0KFxcXCIudWktbWVudS1pdGVtXFxcIik7XFxuICAgICAgdmFyIHVpID0ge1xcbiAgICAgICAgaXRlbTogdGhpcy5hY3RpdmVcXG4gICAgICB9O1xcblxcbiAgICAgIGlmICghdGhpcy5hY3RpdmUuaGFzKFxcXCIudWktbWVudVxcXCIpLmxlbmd0aCkge1xcbiAgICAgICAgdGhpcy5jb2xsYXBzZUFsbChldmVudCwgdHJ1ZSk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX3RyaWdnZXIoXFxcInNlbGVjdFxcXCIsIGV2ZW50LCB1aSk7XFxuICAgIH0sXFxuICAgIF9maWx0ZXJNZW51SXRlbXM6IGZ1bmN0aW9uIF9maWx0ZXJNZW51SXRlbXMoY2hhcmFjdGVyKSB7XFxuICAgICAgdmFyIGVzY2FwZWRDaGFyYWN0ZXIgPSBjaGFyYWN0ZXIucmVwbGFjZSgvW1xcXFwtXFxcXFtcXFxcXXt9KCkqKz8uLFxcXFxcXFxcXFxcXF4kfCNcXFxcc10vZywgXFxcIlxcXFxcXFxcJCZcXFwiKSxcXG4gICAgICAgICAgcmVnZXggPSBuZXcgUmVnRXhwKFxcXCJeXFxcIiArIGVzY2FwZWRDaGFyYWN0ZXIsIFxcXCJpXFxcIik7XFxuICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlTWVudS5maW5kKHRoaXMub3B0aW9ucy5pdGVtcykgLy8gT25seSBtYXRjaCBvbiBpdGVtcywgbm90IGRpdmlkZXJzIG9yIG90aGVyIGNvbnRlbnQgKCMxMDU3MSlcXG4gICAgICAuZmlsdGVyKFxcXCIudWktbWVudS1pdGVtXFxcIikuZmlsdGVyKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHJldHVybiByZWdleC50ZXN0KCQudHJpbSgkKHRoaXMpLnRleHQoKSkpO1xcbiAgICAgIH0pO1xcbiAgICB9XFxuICB9KTtcXG4gIC8qIVxcbiAgICogalF1ZXJ5IFVJIEF1dG9jb21wbGV0ZSAxLjExLjRcXG4gICAqIGh0dHA6Ly9qcXVlcnl1aS5jb21cXG4gICAqXFxuICAgKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xcbiAgICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxcbiAgICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxcbiAgICpcXG4gICAqIGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL2F1dG9jb21wbGV0ZS9cXG4gICAqL1xcblxcbiAgJC53aWRnZXQoXFxcInVpLmF1dG9jb21wbGV0ZVxcXCIsIHtcXG4gICAgdmVyc2lvbjogXFxcIjEuMTEuNFxcXCIsXFxuICAgIGRlZmF1bHRFbGVtZW50OiBcXFwiPGlucHV0PlxcXCIsXFxuICAgIG9wdGlvbnM6IHtcXG4gICAgICBhcHBlbmRUbzogbnVsbCxcXG4gICAgICBhdXRvRm9jdXM6IGZhbHNlLFxcbiAgICAgIGRlbGF5OiAzMDAsXFxuICAgICAgbWluTGVuZ3RoOiAxLFxcbiAgICAgIHBvc2l0aW9uOiB7XFxuICAgICAgICBteTogXFxcImxlZnQgdG9wXFxcIixcXG4gICAgICAgIGF0OiBcXFwibGVmdCBib3R0b21cXFwiLFxcbiAgICAgICAgY29sbGlzaW9uOiBcXFwibm9uZVxcXCJcXG4gICAgICB9LFxcbiAgICAgIHNvdXJjZTogbnVsbCxcXG4gICAgICAvLyBjYWxsYmFja3NcXG4gICAgICBjaGFuZ2U6IG51bGwsXFxuICAgICAgY2xvc2U6IG51bGwsXFxuICAgICAgZm9jdXM6IG51bGwsXFxuICAgICAgb3BlbjogbnVsbCxcXG4gICAgICByZXNwb25zZTogbnVsbCxcXG4gICAgICBzZWFyY2g6IG51bGwsXFxuICAgICAgc2VsZWN0OiBudWxsXFxuICAgIH0sXFxuICAgIHJlcXVlc3RJbmRleDogMCxcXG4gICAgcGVuZGluZzogMCxcXG4gICAgX2NyZWF0ZTogZnVuY3Rpb24gX2NyZWF0ZSgpIHtcXG4gICAgICAvLyBTb21lIGJyb3dzZXJzIG9ubHkgcmVwZWF0IGtleWRvd24gZXZlbnRzLCBub3Qga2V5cHJlc3MgZXZlbnRzLFxcbiAgICAgIC8vIHNvIHdlIHVzZSB0aGUgc3VwcHJlc3NLZXlQcmVzcyBmbGFnIHRvIGRldGVybWluZSBpZiB3ZSd2ZSBhbHJlYWR5XFxuICAgICAgLy8gaGFuZGxlZCB0aGUga2V5ZG93biBldmVudC4gIzcyNjlcXG4gICAgICAvLyBVbmZvcnR1bmF0ZWx5IHRoZSBjb2RlIGZvciAmIGluIGtleXByZXNzIGlzIHRoZSBzYW1lIGFzIHRoZSB1cCBhcnJvdyxcXG4gICAgICAvLyBzbyB3ZSB1c2UgdGhlIHN1cHByZXNzS2V5UHJlc3NSZXBlYXQgZmxhZyB0byBhdm9pZCBoYW5kbGluZyBrZXlwcmVzc1xcbiAgICAgIC8vIGV2ZW50cyB3aGVuIHdlIGtub3cgdGhlIGtleWRvd24gZXZlbnQgd2FzIHVzZWQgdG8gbW9kaWZ5IHRoZVxcbiAgICAgIC8vIHNlYXJjaCB0ZXJtLiAjNzc5OVxcbiAgICAgIHZhciBzdXBwcmVzc0tleVByZXNzLFxcbiAgICAgICAgICBzdXBwcmVzc0tleVByZXNzUmVwZWF0LFxcbiAgICAgICAgICBzdXBwcmVzc0lucHV0LFxcbiAgICAgICAgICBub2RlTmFtZSA9IHRoaXMuZWxlbWVudFswXS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxcbiAgICAgICAgICBpc1RleHRhcmVhID0gbm9kZU5hbWUgPT09IFxcXCJ0ZXh0YXJlYVxcXCIsXFxuICAgICAgICAgIGlzSW5wdXQgPSBub2RlTmFtZSA9PT0gXFxcImlucHV0XFxcIjtcXG4gICAgICB0aGlzLmlzTXVsdGlMaW5lID0gLy8gVGV4dGFyZWFzIGFyZSBhbHdheXMgbXVsdGktbGluZVxcbiAgICAgIGlzVGV4dGFyZWEgPyB0cnVlIDogLy8gSW5wdXRzIGFyZSBhbHdheXMgc2luZ2xlLWxpbmUsIGV2ZW4gaWYgaW5zaWRlIGEgY29udGVudEVkaXRhYmxlIGVsZW1lbnRcXG4gICAgICAvLyBJRSBhbHNvIHRyZWF0cyBpbnB1dHMgYXMgY29udGVudEVkaXRhYmxlXFxuICAgICAgaXNJbnB1dCA/IGZhbHNlIDogLy8gQWxsIG90aGVyIGVsZW1lbnQgdHlwZXMgYXJlIGRldGVybWluZWQgYnkgd2hldGhlciBvciBub3QgdGhleSdyZSBjb250ZW50RWRpdGFibGVcXG4gICAgICB0aGlzLmVsZW1lbnQucHJvcChcXFwiaXNDb250ZW50RWRpdGFibGVcXFwiKTtcXG4gICAgICB0aGlzLnZhbHVlTWV0aG9kID0gdGhpcy5lbGVtZW50W2lzVGV4dGFyZWEgfHwgaXNJbnB1dCA/IFxcXCJ2YWxcXFwiIDogXFxcInRleHRcXFwiXTtcXG4gICAgICB0aGlzLmlzTmV3TWVudSA9IHRydWU7XFxuICAgICAgdGhpcy5lbGVtZW50LmFkZENsYXNzKFxcXCJ1aS1hdXRvY29tcGxldGUtaW5wdXRcXFwiKS5hdHRyKFxcXCJhdXRvY29tcGxldGVcXFwiLCBcXFwib2ZmXFxcIik7XFxuXFxuICAgICAgdGhpcy5fb24odGhpcy5lbGVtZW50LCB7XFxuICAgICAgICBrZXlkb3duOiBmdW5jdGlvbiBrZXlkb3duKGV2ZW50KSB7XFxuICAgICAgICAgIGlmICh0aGlzLmVsZW1lbnQucHJvcChcXFwicmVhZE9ubHlcXFwiKSkge1xcbiAgICAgICAgICAgIHN1cHByZXNzS2V5UHJlc3MgPSB0cnVlO1xcbiAgICAgICAgICAgIHN1cHByZXNzSW5wdXQgPSB0cnVlO1xcbiAgICAgICAgICAgIHN1cHByZXNzS2V5UHJlc3NSZXBlYXQgPSB0cnVlO1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBzdXBwcmVzc0tleVByZXNzID0gZmFsc2U7XFxuICAgICAgICAgIHN1cHByZXNzSW5wdXQgPSBmYWxzZTtcXG4gICAgICAgICAgc3VwcHJlc3NLZXlQcmVzc1JlcGVhdCA9IGZhbHNlO1xcbiAgICAgICAgICB2YXIga2V5Q29kZSA9ICQudWkua2V5Q29kZTtcXG5cXG4gICAgICAgICAgc3dpdGNoIChldmVudC5rZXlDb2RlKSB7XFxuICAgICAgICAgICAgY2FzZSBrZXlDb2RlLlBBR0VfVVA6XFxuICAgICAgICAgICAgICBzdXBwcmVzc0tleVByZXNzID0gdHJ1ZTtcXG5cXG4gICAgICAgICAgICAgIHRoaXMuX21vdmUoXFxcInByZXZpb3VzUGFnZVxcXCIsIGV2ZW50KTtcXG5cXG4gICAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICAgIGNhc2Uga2V5Q29kZS5QQUdFX0RPV046XFxuICAgICAgICAgICAgICBzdXBwcmVzc0tleVByZXNzID0gdHJ1ZTtcXG5cXG4gICAgICAgICAgICAgIHRoaXMuX21vdmUoXFxcIm5leHRQYWdlXFxcIiwgZXZlbnQpO1xcblxcbiAgICAgICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICAgICAgY2FzZSBrZXlDb2RlLlVQOlxcbiAgICAgICAgICAgICAgc3VwcHJlc3NLZXlQcmVzcyA9IHRydWU7XFxuXFxuICAgICAgICAgICAgICB0aGlzLl9rZXlFdmVudChcXFwicHJldmlvdXNcXFwiLCBldmVudCk7XFxuXFxuICAgICAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgICAgICBjYXNlIGtleUNvZGUuRE9XTjpcXG4gICAgICAgICAgICAgIHN1cHByZXNzS2V5UHJlc3MgPSB0cnVlO1xcblxcbiAgICAgICAgICAgICAgdGhpcy5fa2V5RXZlbnQoXFxcIm5leHRcXFwiLCBldmVudCk7XFxuXFxuICAgICAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgICAgICBjYXNlIGtleUNvZGUuRU5URVI6XFxuICAgICAgICAgICAgICAvLyB3aGVuIG1lbnUgaXMgb3BlbiBhbmQgaGFzIGZvY3VzXFxuICAgICAgICAgICAgICBpZiAodGhpcy5tZW51LmFjdGl2ZSkge1xcbiAgICAgICAgICAgICAgICAvLyAjNjA1NSAtIE9wZXJhIHN0aWxsIGFsbG93cyB0aGUga2V5cHJlc3MgdG8gb2NjdXJcXG4gICAgICAgICAgICAgICAgLy8gd2hpY2ggY2F1c2VzIGZvcm1zIHRvIHN1Ym1pdFxcbiAgICAgICAgICAgICAgICBzdXBwcmVzc0tleVByZXNzID0gdHJ1ZTtcXG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgICAgICAgICAgdGhpcy5tZW51LnNlbGVjdChldmVudCk7XFxuICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgICAgICBjYXNlIGtleUNvZGUuVEFCOlxcbiAgICAgICAgICAgICAgaWYgKHRoaXMubWVudS5hY3RpdmUpIHtcXG4gICAgICAgICAgICAgICAgdGhpcy5tZW51LnNlbGVjdChldmVudCk7XFxuICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgICAgICBjYXNlIGtleUNvZGUuRVNDQVBFOlxcbiAgICAgICAgICAgICAgaWYgKHRoaXMubWVudS5lbGVtZW50LmlzKFxcXCI6dmlzaWJsZVxcXCIpKSB7XFxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc011bHRpTGluZSkge1xcbiAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlKHRoaXMudGVybSk7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZShldmVudCk7IC8vIERpZmZlcmVudCBicm93c2VycyBoYXZlIGRpZmZlcmVudCBkZWZhdWx0IGJlaGF2aW9yIGZvciBlc2NhcGVcXG4gICAgICAgICAgICAgICAgLy8gU2luZ2xlIHByZXNzIGNhbiBtZWFuIHVuZG8gb3IgY2xlYXJcXG4gICAgICAgICAgICAgICAgLy8gRG91YmxlIHByZXNzIGluIElFIG1lYW5zIGNsZWFyIHRoZSB3aG9sZSBmb3JtXFxuXFxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgICAgICBkZWZhdWx0OlxcbiAgICAgICAgICAgICAgc3VwcHJlc3NLZXlQcmVzc1JlcGVhdCA9IHRydWU7IC8vIHNlYXJjaCB0aW1lb3V0IHNob3VsZCBiZSB0cmlnZ2VyZWQgYmVmb3JlIHRoZSBpbnB1dCB2YWx1ZSBpcyBjaGFuZ2VkXFxuXFxuICAgICAgICAgICAgICB0aGlzLl9zZWFyY2hUaW1lb3V0KGV2ZW50KTtcXG5cXG4gICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAga2V5cHJlc3M6IGZ1bmN0aW9uIGtleXByZXNzKGV2ZW50KSB7XFxuICAgICAgICAgIGlmIChzdXBwcmVzc0tleVByZXNzKSB7XFxuICAgICAgICAgICAgc3VwcHJlc3NLZXlQcmVzcyA9IGZhbHNlO1xcblxcbiAgICAgICAgICAgIGlmICghdGhpcy5pc011bHRpTGluZSB8fCB0aGlzLm1lbnUuZWxlbWVudC5pcyhcXFwiOnZpc2libGVcXFwiKSkge1xcbiAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmIChzdXBwcmVzc0tleVByZXNzUmVwZWF0KSB7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICB9IC8vIHJlcGxpY2F0ZSBzb21lIGtleSBoYW5kbGVycyB0byBhbGxvdyB0aGVtIHRvIHJlcGVhdCBpbiBGaXJlZm94IGFuZCBPcGVyYVxcblxcblxcbiAgICAgICAgICB2YXIga2V5Q29kZSA9ICQudWkua2V5Q29kZTtcXG5cXG4gICAgICAgICAgc3dpdGNoIChldmVudC5rZXlDb2RlKSB7XFxuICAgICAgICAgICAgY2FzZSBrZXlDb2RlLlBBR0VfVVA6XFxuICAgICAgICAgICAgICB0aGlzLl9tb3ZlKFxcXCJwcmV2aW91c1BhZ2VcXFwiLCBldmVudCk7XFxuXFxuICAgICAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgICAgICBjYXNlIGtleUNvZGUuUEFHRV9ET1dOOlxcbiAgICAgICAgICAgICAgdGhpcy5fbW92ZShcXFwibmV4dFBhZ2VcXFwiLCBldmVudCk7XFxuXFxuICAgICAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgICAgICBjYXNlIGtleUNvZGUuVVA6XFxuICAgICAgICAgICAgICB0aGlzLl9rZXlFdmVudChcXFwicHJldmlvdXNcXFwiLCBldmVudCk7XFxuXFxuICAgICAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgICAgICBjYXNlIGtleUNvZGUuRE9XTjpcXG4gICAgICAgICAgICAgIHRoaXMuX2tleUV2ZW50KFxcXCJuZXh0XFxcIiwgZXZlbnQpO1xcblxcbiAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuICAgICAgICBpbnB1dDogZnVuY3Rpb24gaW5wdXQoZXZlbnQpIHtcXG4gICAgICAgICAgaWYgKHN1cHByZXNzSW5wdXQpIHtcXG4gICAgICAgICAgICBzdXBwcmVzc0lucHV0ID0gZmFsc2U7XFxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgdGhpcy5fc2VhcmNoVGltZW91dChldmVudCk7XFxuICAgICAgICB9LFxcbiAgICAgICAgZm9jdXM6IGZ1bmN0aW9uIGZvY3VzKCkge1xcbiAgICAgICAgICB0aGlzLnNlbGVjdGVkSXRlbSA9IG51bGw7XFxuICAgICAgICAgIHRoaXMucHJldmlvdXMgPSB0aGlzLl92YWx1ZSgpO1xcbiAgICAgICAgfSxcXG4gICAgICAgIGJsdXI6IGZ1bmN0aW9uIGJsdXIoZXZlbnQpIHtcXG4gICAgICAgICAgaWYgKHRoaXMuY2FuY2VsQmx1cikge1xcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmNhbmNlbEJsdXI7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnNlYXJjaGluZyk7XFxuICAgICAgICAgIHRoaXMuY2xvc2UoZXZlbnQpO1xcblxcbiAgICAgICAgICB0aGlzLl9jaGFuZ2UoZXZlbnQpO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcblxcbiAgICAgIHRoaXMuX2luaXRTb3VyY2UoKTtcXG5cXG4gICAgICB0aGlzLm1lbnUgPSAkKFxcXCI8dWw+XFxcIikuYWRkQ2xhc3MoXFxcInVpLWF1dG9jb21wbGV0ZSB1aS1mcm9udFxcXCIpLmFwcGVuZFRvKHRoaXMuX2FwcGVuZFRvKCkpLm1lbnUoe1xcbiAgICAgICAgLy8gZGlzYWJsZSBBUklBIHN1cHBvcnQsIHRoZSBsaXZlIHJlZ2lvbiB0YWtlcyBjYXJlIG9mIHRoYXRcXG4gICAgICAgIHJvbGU6IG51bGxcXG4gICAgICB9KS5oaWRlKCkubWVudShcXFwiaW5zdGFuY2VcXFwiKTtcXG5cXG4gICAgICB0aGlzLl9vbih0aGlzLm1lbnUuZWxlbWVudCwge1xcbiAgICAgICAgbW91c2Vkb3duOiBmdW5jdGlvbiBtb3VzZWRvd24oZXZlbnQpIHtcXG4gICAgICAgICAgLy8gcHJldmVudCBtb3ZpbmcgZm9jdXMgb3V0IG9mIHRoZSB0ZXh0IGZpZWxkXFxuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vIElFIGRvZXNuJ3QgcHJldmVudCBtb3ZpbmcgZm9jdXMgZXZlbiB3aXRoIGV2ZW50LnByZXZlbnREZWZhdWx0KClcXG4gICAgICAgICAgLy8gc28gd2Ugc2V0IGEgZmxhZyB0byBrbm93IHdoZW4gd2Ugc2hvdWxkIGlnbm9yZSB0aGUgYmx1ciBldmVudFxcblxcbiAgICAgICAgICB0aGlzLmNhbmNlbEJsdXIgPSB0cnVlO1xcblxcbiAgICAgICAgICB0aGlzLl9kZWxheShmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuY2FuY2VsQmx1cjtcXG4gICAgICAgICAgfSk7IC8vIGNsaWNraW5nIG9uIHRoZSBzY3JvbGxiYXIgY2F1c2VzIGZvY3VzIHRvIHNoaWZ0IHRvIHRoZSBib2R5XFxuICAgICAgICAgIC8vIGJ1dCB3ZSBjYW4ndCBkZXRlY3QgYSBtb3VzZXVwIG9yIGEgY2xpY2sgaW1tZWRpYXRlbHkgYWZ0ZXJ3YXJkXFxuICAgICAgICAgIC8vIHNvIHdlIGhhdmUgdG8gdHJhY2sgdGhlIG5leHQgbW91c2Vkb3duIGFuZCBjbG9zZSB0aGUgbWVudSBpZlxcbiAgICAgICAgICAvLyB0aGUgdXNlciBjbGlja3Mgc29tZXdoZXJlIG91dHNpZGUgb2YgdGhlIGF1dG9jb21wbGV0ZVxcblxcblxcbiAgICAgICAgICB2YXIgbWVudUVsZW1lbnQgPSB0aGlzLm1lbnUuZWxlbWVudFswXTtcXG5cXG4gICAgICAgICAgaWYgKCEkKGV2ZW50LnRhcmdldCkuY2xvc2VzdChcXFwiLnVpLW1lbnUtaXRlbVxcXCIpLmxlbmd0aCkge1xcbiAgICAgICAgICAgIHRoaXMuX2RlbGF5KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcXG4gICAgICAgICAgICAgIHRoaXMuZG9jdW1lbnQub25lKFxcXCJtb3VzZWRvd25cXFwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnRhcmdldCAhPT0gdGhhdC5lbGVtZW50WzBdICYmIGV2ZW50LnRhcmdldCAhPT0gbWVudUVsZW1lbnQgJiYgISQuY29udGFpbnMobWVudUVsZW1lbnQsIGV2ZW50LnRhcmdldCkpIHtcXG4gICAgICAgICAgICAgICAgICB0aGF0LmNsb3NlKCk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgbWVudWZvY3VzOiBmdW5jdGlvbiBtZW51Zm9jdXMoZXZlbnQsIHVpKSB7XFxuICAgICAgICAgIHZhciBsYWJlbCwgaXRlbTsgLy8gc3VwcG9ydDogRmlyZWZveFxcbiAgICAgICAgICAvLyBQcmV2ZW50IGFjY2lkZW50YWwgYWN0aXZhdGlvbiBvZiBtZW51IGl0ZW1zIGluIEZpcmVmb3ggKCM3MDI0ICM5MTE4KVxcblxcbiAgICAgICAgICBpZiAodGhpcy5pc05ld01lbnUpIHtcXG4gICAgICAgICAgICB0aGlzLmlzTmV3TWVudSA9IGZhbHNlO1xcblxcbiAgICAgICAgICAgIGlmIChldmVudC5vcmlnaW5hbEV2ZW50ICYmIC9ebW91c2UvLnRlc3QoZXZlbnQub3JpZ2luYWxFdmVudC50eXBlKSkge1xcbiAgICAgICAgICAgICAgdGhpcy5tZW51LmJsdXIoKTtcXG4gICAgICAgICAgICAgIHRoaXMuZG9jdW1lbnQub25lKFxcXCJtb3VzZW1vdmVcXFwiLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgICQoZXZlbnQudGFyZ2V0KS50cmlnZ2VyKGV2ZW50Lm9yaWdpbmFsRXZlbnQpO1xcbiAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGl0ZW0gPSB1aS5pdGVtLmRhdGEoXFxcInVpLWF1dG9jb21wbGV0ZS1pdGVtXFxcIik7XFxuXFxuICAgICAgICAgIGlmIChmYWxzZSAhPT0gdGhpcy5fdHJpZ2dlcihcXFwiZm9jdXNcXFwiLCBldmVudCwge1xcbiAgICAgICAgICAgIGl0ZW06IGl0ZW1cXG4gICAgICAgICAgfSkpIHtcXG4gICAgICAgICAgICAvLyB1c2UgdmFsdWUgdG8gbWF0Y2ggd2hhdCB3aWxsIGVuZCB1cCBpbiB0aGUgaW5wdXQsIGlmIGl0IHdhcyBhIGtleSBldmVudFxcbiAgICAgICAgICAgIGlmIChldmVudC5vcmlnaW5hbEV2ZW50ICYmIC9ea2V5Ly50ZXN0KGV2ZW50Lm9yaWdpbmFsRXZlbnQudHlwZSkpIHtcXG4gICAgICAgICAgICAgIHRoaXMuX3ZhbHVlKGl0ZW0udmFsdWUpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSAvLyBBbm5vdW5jZSB0aGUgdmFsdWUgaW4gdGhlIGxpdmVSZWdpb25cXG5cXG5cXG4gICAgICAgICAgbGFiZWwgPSB1aS5pdGVtLmF0dHIoXFxcImFyaWEtbGFiZWxcXFwiKSB8fCBpdGVtLnZhbHVlO1xcblxcbiAgICAgICAgICBpZiAobGFiZWwgJiYgJC50cmltKGxhYmVsKS5sZW5ndGgpIHtcXG4gICAgICAgICAgICB0aGlzLmxpdmVSZWdpb24uY2hpbGRyZW4oKS5oaWRlKCk7XFxuICAgICAgICAgICAgJChcXFwiPGRpdj5cXFwiKS50ZXh0KGxhYmVsKS5hcHBlbmRUbyh0aGlzLmxpdmVSZWdpb24pO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgbWVudXNlbGVjdDogZnVuY3Rpb24gbWVudXNlbGVjdChldmVudCwgdWkpIHtcXG4gICAgICAgICAgdmFyIGl0ZW0gPSB1aS5pdGVtLmRhdGEoXFxcInVpLWF1dG9jb21wbGV0ZS1pdGVtXFxcIiksXFxuICAgICAgICAgICAgICBwcmV2aW91cyA9IHRoaXMucHJldmlvdXM7IC8vIG9ubHkgdHJpZ2dlciB3aGVuIGZvY3VzIHdhcyBsb3N0IChjbGljayBvbiBtZW51KVxcblxcbiAgICAgICAgICBpZiAodGhpcy5lbGVtZW50WzBdICE9PSB0aGlzLmRvY3VtZW50WzBdLmFjdGl2ZUVsZW1lbnQpIHtcXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuZm9jdXMoKTtcXG4gICAgICAgICAgICB0aGlzLnByZXZpb3VzID0gcHJldmlvdXM7IC8vICM2MTA5IC0gSUUgdHJpZ2dlcnMgdHdvIGZvY3VzIGV2ZW50cyBhbmQgdGhlIHNlY29uZFxcbiAgICAgICAgICAgIC8vIGlzIGFzeW5jaHJvbm91cywgc28gd2UgbmVlZCB0byByZXNldCB0aGUgcHJldmlvdXNcXG4gICAgICAgICAgICAvLyB0ZXJtIHN5bmNocm9ub3VzbHkgYW5kIGFzeW5jaHJvbm91c2x5IDotKFxcblxcbiAgICAgICAgICAgIHRoaXMuX2RlbGF5KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgIHRoaXMucHJldmlvdXMgPSBwcmV2aW91cztcXG4gICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRJdGVtID0gaXRlbTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAoZmFsc2UgIT09IHRoaXMuX3RyaWdnZXIoXFxcInNlbGVjdFxcXCIsIGV2ZW50LCB7XFxuICAgICAgICAgICAgaXRlbTogaXRlbVxcbiAgICAgICAgICB9KSkge1xcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlKGl0ZW0udmFsdWUpO1xcbiAgICAgICAgICB9IC8vIHJlc2V0IHRoZSB0ZXJtIGFmdGVyIHRoZSBzZWxlY3QgZXZlbnRcXG4gICAgICAgICAgLy8gdGhpcyBhbGxvd3MgY3VzdG9tIHNlbGVjdCBoYW5kbGluZyB0byB3b3JrIHByb3Blcmx5XFxuXFxuXFxuICAgICAgICAgIHRoaXMudGVybSA9IHRoaXMuX3ZhbHVlKCk7XFxuICAgICAgICAgIHRoaXMuY2xvc2UoZXZlbnQpO1xcbiAgICAgICAgICB0aGlzLnNlbGVjdGVkSXRlbSA9IGl0ZW07XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuXFxuICAgICAgdGhpcy5saXZlUmVnaW9uID0gJChcXFwiPHNwYW4+XFxcIiwge1xcbiAgICAgICAgcm9sZTogXFxcInN0YXR1c1xcXCIsXFxuICAgICAgICBcXFwiYXJpYS1saXZlXFxcIjogXFxcImFzc2VydGl2ZVxcXCIsXFxuICAgICAgICBcXFwiYXJpYS1yZWxldmFudFxcXCI6IFxcXCJhZGRpdGlvbnNcXFwiXFxuICAgICAgfSkuYWRkQ2xhc3MoXFxcInVpLWhlbHBlci1oaWRkZW4tYWNjZXNzaWJsZVxcXCIpLmFwcGVuZFRvKHRoaXMuZG9jdW1lbnRbMF0uYm9keSk7IC8vIHR1cm5pbmcgb2ZmIGF1dG9jb21wbGV0ZSBwcmV2ZW50cyB0aGUgYnJvd3NlciBmcm9tIHJlbWVtYmVyaW5nIHRoZVxcbiAgICAgIC8vIHZhbHVlIHdoZW4gbmF2aWdhdGluZyB0aHJvdWdoIGhpc3RvcnksIHNvIHdlIHJlLWVuYWJsZSBhdXRvY29tcGxldGVcXG4gICAgICAvLyBpZiB0aGUgcGFnZSBpcyB1bmxvYWRlZCBiZWZvcmUgdGhlIHdpZGdldCBpcyBkZXN0cm95ZWQuICM3NzkwXFxuXFxuICAgICAgdGhpcy5fb24odGhpcy53aW5kb3csIHtcXG4gICAgICAgIGJlZm9yZXVubG9hZDogZnVuY3Rpb24gYmVmb3JldW5sb2FkKCkge1xcbiAgICAgICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlQXR0cihcXFwiYXV0b2NvbXBsZXRlXFxcIik7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgIH0sXFxuICAgIF9kZXN0cm95OiBmdW5jdGlvbiBfZGVzdHJveSgpIHtcXG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5zZWFyY2hpbmcpO1xcbiAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVDbGFzcyhcXFwidWktYXV0b2NvbXBsZXRlLWlucHV0XFxcIikucmVtb3ZlQXR0cihcXFwiYXV0b2NvbXBsZXRlXFxcIik7XFxuICAgICAgdGhpcy5tZW51LmVsZW1lbnQucmVtb3ZlKCk7XFxuICAgICAgdGhpcy5saXZlUmVnaW9uLnJlbW92ZSgpO1xcbiAgICB9LFxcbiAgICBfc2V0T3B0aW9uOiBmdW5jdGlvbiBfc2V0T3B0aW9uKGtleSwgdmFsdWUpIHtcXG4gICAgICB0aGlzLl9zdXBlcihrZXksIHZhbHVlKTtcXG5cXG4gICAgICBpZiAoa2V5ID09PSBcXFwic291cmNlXFxcIikge1xcbiAgICAgICAgdGhpcy5faW5pdFNvdXJjZSgpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoa2V5ID09PSBcXFwiYXBwZW5kVG9cXFwiKSB7XFxuICAgICAgICB0aGlzLm1lbnUuZWxlbWVudC5hcHBlbmRUbyh0aGlzLl9hcHBlbmRUbygpKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGtleSA9PT0gXFxcImRpc2FibGVkXFxcIiAmJiB2YWx1ZSAmJiB0aGlzLnhocikge1xcbiAgICAgICAgdGhpcy54aHIuYWJvcnQoKTtcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIF9hcHBlbmRUbzogZnVuY3Rpb24gX2FwcGVuZFRvKCkge1xcbiAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5vcHRpb25zLmFwcGVuZFRvO1xcblxcbiAgICAgIGlmIChlbGVtZW50KSB7XFxuICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5qcXVlcnkgfHwgZWxlbWVudC5ub2RlVHlwZSA/ICQoZWxlbWVudCkgOiB0aGlzLmRvY3VtZW50LmZpbmQoZWxlbWVudCkuZXEoMCk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghZWxlbWVudCB8fCAhZWxlbWVudFswXSkge1xcbiAgICAgICAgZWxlbWVudCA9IHRoaXMuZWxlbWVudC5jbG9zZXN0KFxcXCIudWktZnJvbnRcXFwiKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCFlbGVtZW50Lmxlbmd0aCkge1xcbiAgICAgICAgZWxlbWVudCA9IHRoaXMuZG9jdW1lbnRbMF0uYm9keTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIGVsZW1lbnQ7XFxuICAgIH0sXFxuICAgIF9pbml0U291cmNlOiBmdW5jdGlvbiBfaW5pdFNvdXJjZSgpIHtcXG4gICAgICB2YXIgYXJyYXksXFxuICAgICAgICAgIHVybCxcXG4gICAgICAgICAgdGhhdCA9IHRoaXM7XFxuXFxuICAgICAgaWYgKCQuaXNBcnJheSh0aGlzLm9wdGlvbnMuc291cmNlKSkge1xcbiAgICAgICAgYXJyYXkgPSB0aGlzLm9wdGlvbnMuc291cmNlO1xcblxcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBmdW5jdGlvbiAocmVxdWVzdCwgcmVzcG9uc2UpIHtcXG4gICAgICAgICAgcmVzcG9uc2UoJC51aS5hdXRvY29tcGxldGUuZmlsdGVyKGFycmF5LCByZXF1ZXN0LnRlcm0pKTtcXG4gICAgICAgIH07XFxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLnNvdXJjZSA9PT0gXFxcInN0cmluZ1xcXCIpIHtcXG4gICAgICAgIHVybCA9IHRoaXMub3B0aW9ucy5zb3VyY2U7XFxuXFxuICAgICAgICB0aGlzLnNvdXJjZSA9IGZ1bmN0aW9uIChyZXF1ZXN0LCByZXNwb25zZSkge1xcbiAgICAgICAgICBpZiAodGhhdC54aHIpIHtcXG4gICAgICAgICAgICB0aGF0Lnhoci5hYm9ydCgpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHRoYXQueGhyID0gJC5hamF4KHtcXG4gICAgICAgICAgICB1cmw6IHVybCxcXG4gICAgICAgICAgICBkYXRhOiByZXF1ZXN0LFxcbiAgICAgICAgICAgIGRhdGFUeXBlOiBcXFwianNvblxcXCIsXFxuICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gc3VjY2VzcyhkYXRhKSB7XFxuICAgICAgICAgICAgICByZXNwb25zZShkYXRhKTtcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbiBlcnJvcigpIHtcXG4gICAgICAgICAgICAgIHJlc3BvbnNlKFtdKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdGhpcy5zb3VyY2UgPSB0aGlzLm9wdGlvbnMuc291cmNlO1xcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgX3NlYXJjaFRpbWVvdXQ6IGZ1bmN0aW9uIF9zZWFyY2hUaW1lb3V0KGV2ZW50KSB7XFxuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuc2VhcmNoaW5nKTtcXG4gICAgICB0aGlzLnNlYXJjaGluZyA9IHRoaXMuX2RlbGF5KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIC8vIFNlYXJjaCBpZiB0aGUgdmFsdWUgaGFzIGNoYW5nZWQsIG9yIGlmIHRoZSB1c2VyIHJldHlwZXMgdGhlIHNhbWUgdmFsdWUgKHNlZSAjNzQzNClcXG4gICAgICAgIHZhciBlcXVhbFZhbHVlcyA9IHRoaXMudGVybSA9PT0gdGhpcy5fdmFsdWUoKSxcXG4gICAgICAgICAgICBtZW51VmlzaWJsZSA9IHRoaXMubWVudS5lbGVtZW50LmlzKFxcXCI6dmlzaWJsZVxcXCIpLFxcbiAgICAgICAgICAgIG1vZGlmaWVyS2V5ID0gZXZlbnQuYWx0S2V5IHx8IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSB8fCBldmVudC5zaGlmdEtleTtcXG5cXG4gICAgICAgIGlmICghZXF1YWxWYWx1ZXMgfHwgZXF1YWxWYWx1ZXMgJiYgIW1lbnVWaXNpYmxlICYmICFtb2RpZmllcktleSkge1xcbiAgICAgICAgICB0aGlzLnNlbGVjdGVkSXRlbSA9IG51bGw7XFxuICAgICAgICAgIHRoaXMuc2VhcmNoKG51bGwsIGV2ZW50KTtcXG4gICAgICAgIH1cXG4gICAgICB9LCB0aGlzLm9wdGlvbnMuZGVsYXkpO1xcbiAgICB9LFxcbiAgICBzZWFyY2g6IGZ1bmN0aW9uIHNlYXJjaCh2YWx1ZSwgZXZlbnQpIHtcXG4gICAgICB2YWx1ZSA9IHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IHRoaXMuX3ZhbHVlKCk7IC8vIGFsd2F5cyBzYXZlIHRoZSBhY3R1YWwgdmFsdWUsIG5vdCB0aGUgb25lIHBhc3NlZCBhcyBhbiBhcmd1bWVudFxcblxcbiAgICAgIHRoaXMudGVybSA9IHRoaXMuX3ZhbHVlKCk7XFxuXFxuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA8IHRoaXMub3B0aW9ucy5taW5MZW5ndGgpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLmNsb3NlKGV2ZW50KTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMuX3RyaWdnZXIoXFxcInNlYXJjaFxcXCIsIGV2ZW50KSA9PT0gZmFsc2UpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHRoaXMuX3NlYXJjaCh2YWx1ZSk7XFxuICAgIH0sXFxuICAgIF9zZWFyY2g6IGZ1bmN0aW9uIF9zZWFyY2godmFsdWUpIHtcXG4gICAgICB0aGlzLnBlbmRpbmcrKztcXG4gICAgICB0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoXFxcInVpLWF1dG9jb21wbGV0ZS1sb2FkaW5nXFxcIik7XFxuICAgICAgdGhpcy5jYW5jZWxTZWFyY2ggPSBmYWxzZTtcXG4gICAgICB0aGlzLnNvdXJjZSh7XFxuICAgICAgICB0ZXJtOiB2YWx1ZVxcbiAgICAgIH0sIHRoaXMuX3Jlc3BvbnNlKCkpO1xcbiAgICB9LFxcbiAgICBfcmVzcG9uc2U6IGZ1bmN0aW9uIF9yZXNwb25zZSgpIHtcXG4gICAgICB2YXIgaW5kZXggPSArK3RoaXMucmVxdWVzdEluZGV4O1xcbiAgICAgIHJldHVybiAkLnByb3h5KGZ1bmN0aW9uIChjb250ZW50KSB7XFxuICAgICAgICBpZiAoaW5kZXggPT09IHRoaXMucmVxdWVzdEluZGV4KSB7XFxuICAgICAgICAgIHRoaXMuX19yZXNwb25zZShjb250ZW50KTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHRoaXMucGVuZGluZy0tO1xcblxcbiAgICAgICAgaWYgKCF0aGlzLnBlbmRpbmcpIHtcXG4gICAgICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZUNsYXNzKFxcXCJ1aS1hdXRvY29tcGxldGUtbG9hZGluZ1xcXCIpO1xcbiAgICAgICAgfVxcbiAgICAgIH0sIHRoaXMpO1xcbiAgICB9LFxcbiAgICBfX3Jlc3BvbnNlOiBmdW5jdGlvbiBfX3Jlc3BvbnNlKGNvbnRlbnQpIHtcXG4gICAgICBpZiAoY29udGVudCkge1xcbiAgICAgICAgY29udGVudCA9IHRoaXMuX25vcm1hbGl6ZShjb250ZW50KTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fdHJpZ2dlcihcXFwicmVzcG9uc2VcXFwiLCBudWxsLCB7XFxuICAgICAgICBjb250ZW50OiBjb250ZW50XFxuICAgICAgfSk7XFxuXFxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZGlzYWJsZWQgJiYgY29udGVudCAmJiBjb250ZW50Lmxlbmd0aCAmJiAhdGhpcy5jYW5jZWxTZWFyY2gpIHtcXG4gICAgICAgIHRoaXMuX3N1Z2dlc3QoY29udGVudCk7XFxuXFxuICAgICAgICB0aGlzLl90cmlnZ2VyKFxcXCJvcGVuXFxcIik7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIC8vIHVzZSAuX2Nsb3NlKCkgaW5zdGVhZCBvZiAuY2xvc2UoKSBzbyB3ZSBkb24ndCBjYW5jZWwgZnV0dXJlIHNlYXJjaGVzXFxuICAgICAgICB0aGlzLl9jbG9zZSgpO1xcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgY2xvc2U6IGZ1bmN0aW9uIGNsb3NlKGV2ZW50KSB7XFxuICAgICAgdGhpcy5jYW5jZWxTZWFyY2ggPSB0cnVlO1xcblxcbiAgICAgIHRoaXMuX2Nsb3NlKGV2ZW50KTtcXG4gICAgfSxcXG4gICAgX2Nsb3NlOiBmdW5jdGlvbiBfY2xvc2UoZXZlbnQpIHtcXG4gICAgICBpZiAodGhpcy5tZW51LmVsZW1lbnQuaXMoXFxcIjp2aXNpYmxlXFxcIikpIHtcXG4gICAgICAgIHRoaXMubWVudS5lbGVtZW50LmhpZGUoKTtcXG4gICAgICAgIHRoaXMubWVudS5ibHVyKCk7XFxuICAgICAgICB0aGlzLmlzTmV3TWVudSA9IHRydWU7XFxuXFxuICAgICAgICB0aGlzLl90cmlnZ2VyKFxcXCJjbG9zZVxcXCIsIGV2ZW50KTtcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIF9jaGFuZ2U6IGZ1bmN0aW9uIF9jaGFuZ2UoZXZlbnQpIHtcXG4gICAgICBpZiAodGhpcy5wcmV2aW91cyAhPT0gdGhpcy5fdmFsdWUoKSkge1xcbiAgICAgICAgdGhpcy5fdHJpZ2dlcihcXFwiY2hhbmdlXFxcIiwgZXZlbnQsIHtcXG4gICAgICAgICAgaXRlbTogdGhpcy5zZWxlY3RlZEl0ZW1cXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgX25vcm1hbGl6ZTogZnVuY3Rpb24gX25vcm1hbGl6ZShpdGVtcykge1xcbiAgICAgIC8vIGFzc3VtZSBhbGwgaXRlbXMgaGF2ZSB0aGUgcmlnaHQgZm9ybWF0IHdoZW4gdGhlIGZpcnN0IGl0ZW0gaXMgY29tcGxldGVcXG4gICAgICBpZiAoaXRlbXMubGVuZ3RoICYmIGl0ZW1zWzBdLmxhYmVsICYmIGl0ZW1zWzBdLnZhbHVlKSB7XFxuICAgICAgICByZXR1cm4gaXRlbXM7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiAkLm1hcChpdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHtcXG4gICAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gXFxcInN0cmluZ1xcXCIpIHtcXG4gICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICBsYWJlbDogaXRlbSxcXG4gICAgICAgICAgICB2YWx1ZTogaXRlbVxcbiAgICAgICAgICB9O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuICQuZXh0ZW5kKHt9LCBpdGVtLCB7XFxuICAgICAgICAgIGxhYmVsOiBpdGVtLmxhYmVsIHx8IGl0ZW0udmFsdWUsXFxuICAgICAgICAgIHZhbHVlOiBpdGVtLnZhbHVlIHx8IGl0ZW0ubGFiZWxcXG4gICAgICAgIH0pO1xcbiAgICAgIH0pO1xcbiAgICB9LFxcbiAgICBfc3VnZ2VzdDogZnVuY3Rpb24gX3N1Z2dlc3QoaXRlbXMpIHtcXG4gICAgICB2YXIgdWwgPSB0aGlzLm1lbnUuZWxlbWVudC5lbXB0eSgpO1xcblxcbiAgICAgIHRoaXMuX3JlbmRlck1lbnUodWwsIGl0ZW1zKTtcXG5cXG4gICAgICB0aGlzLmlzTmV3TWVudSA9IHRydWU7XFxuICAgICAgdGhpcy5tZW51LnJlZnJlc2goKTsgLy8gc2l6ZSBhbmQgcG9zaXRpb24gbWVudVxcblxcbiAgICAgIHVsLnNob3coKTtcXG5cXG4gICAgICB0aGlzLl9yZXNpemVNZW51KCk7XFxuXFxuICAgICAgdWwucG9zaXRpb24oJC5leHRlbmQoe1xcbiAgICAgICAgb2Y6IHRoaXMuZWxlbWVudFxcbiAgICAgIH0sIHRoaXMub3B0aW9ucy5wb3NpdGlvbikpO1xcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b0ZvY3VzKSB7XFxuICAgICAgICB0aGlzLm1lbnUubmV4dCgpO1xcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgX3Jlc2l6ZU1lbnU6IGZ1bmN0aW9uIF9yZXNpemVNZW51KCkge1xcbiAgICAgIHZhciB1bCA9IHRoaXMubWVudS5lbGVtZW50O1xcbiAgICAgIHVsLm91dGVyV2lkdGgoTWF0aC5tYXgoIC8vIEZpcmVmb3ggd3JhcHMgbG9uZyB0ZXh0IChwb3NzaWJseSBhIHJvdW5kaW5nIGJ1ZylcXG4gICAgICAvLyBzbyB3ZSBhZGQgMXB4IHRvIGF2b2lkIHRoZSB3cmFwcGluZyAoIzc1MTMpXFxuICAgICAgdWwud2lkdGgoXFxcIlxcXCIpLm91dGVyV2lkdGgoKSArIDEsIHRoaXMuZWxlbWVudC5vdXRlcldpZHRoKCkpKTtcXG4gICAgfSxcXG4gICAgX3JlbmRlck1lbnU6IGZ1bmN0aW9uIF9yZW5kZXJNZW51KHVsLCBpdGVtcykge1xcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcXG4gICAgICAkLmVhY2goaXRlbXMsIGZ1bmN0aW9uIChpbmRleCwgaXRlbSkge1xcbiAgICAgICAgdGhhdC5fcmVuZGVySXRlbURhdGEodWwsIGl0ZW0pO1xcbiAgICAgIH0pO1xcbiAgICB9LFxcbiAgICBfcmVuZGVySXRlbURhdGE6IGZ1bmN0aW9uIF9yZW5kZXJJdGVtRGF0YSh1bCwgaXRlbSkge1xcbiAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJJdGVtKHVsLCBpdGVtKS5kYXRhKFxcXCJ1aS1hdXRvY29tcGxldGUtaXRlbVxcXCIsIGl0ZW0pO1xcbiAgICB9LFxcbiAgICBfcmVuZGVySXRlbTogZnVuY3Rpb24gX3JlbmRlckl0ZW0odWwsIGl0ZW0pIHtcXG4gICAgICByZXR1cm4gJChcXFwiPGxpPlxcXCIpLnRleHQoaXRlbS5sYWJlbCkuYXBwZW5kVG8odWwpO1xcbiAgICB9LFxcbiAgICBfbW92ZTogZnVuY3Rpb24gX21vdmUoZGlyZWN0aW9uLCBldmVudCkge1xcbiAgICAgIGlmICghdGhpcy5tZW51LmVsZW1lbnQuaXMoXFxcIjp2aXNpYmxlXFxcIikpIHtcXG4gICAgICAgIHRoaXMuc2VhcmNoKG51bGwsIGV2ZW50KTtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMubWVudS5pc0ZpcnN0SXRlbSgpICYmIC9ecHJldmlvdXMvLnRlc3QoZGlyZWN0aW9uKSB8fCB0aGlzLm1lbnUuaXNMYXN0SXRlbSgpICYmIC9ebmV4dC8udGVzdChkaXJlY3Rpb24pKSB7XFxuICAgICAgICBpZiAoIXRoaXMuaXNNdWx0aUxpbmUpIHtcXG4gICAgICAgICAgdGhpcy5fdmFsdWUodGhpcy50ZXJtKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHRoaXMubWVudS5ibHVyKCk7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMubWVudVtkaXJlY3Rpb25dKGV2ZW50KTtcXG4gICAgfSxcXG4gICAgd2lkZ2V0OiBmdW5jdGlvbiB3aWRnZXQoKSB7XFxuICAgICAgcmV0dXJuIHRoaXMubWVudS5lbGVtZW50O1xcbiAgICB9LFxcbiAgICBfdmFsdWU6IGZ1bmN0aW9uIF92YWx1ZSgpIHtcXG4gICAgICByZXR1cm4gdGhpcy52YWx1ZU1ldGhvZC5hcHBseSh0aGlzLmVsZW1lbnQsIGFyZ3VtZW50cyk7XFxuICAgIH0sXFxuICAgIF9rZXlFdmVudDogZnVuY3Rpb24gX2tleUV2ZW50KGtleUV2ZW50LCBldmVudCkge1xcbiAgICAgIGlmICghdGhpcy5pc011bHRpTGluZSB8fCB0aGlzLm1lbnUuZWxlbWVudC5pcyhcXFwiOnZpc2libGVcXFwiKSkge1xcbiAgICAgICAgdGhpcy5fbW92ZShrZXlFdmVudCwgZXZlbnQpOyAvLyBwcmV2ZW50cyBtb3ZpbmcgY3Vyc29yIHRvIGJlZ2lubmluZy9lbmQgb2YgdGhlIHRleHQgZmllbGQgaW4gc29tZSBicm93c2Vyc1xcblxcblxcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH0pO1xcbiAgJC5leHRlbmQoJC51aS5hdXRvY29tcGxldGUsIHtcXG4gICAgZXNjYXBlUmVnZXg6IGZ1bmN0aW9uIGVzY2FwZVJlZ2V4KHZhbHVlKSB7XFxuICAgICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoL1tcXFxcLVxcXFxbXFxcXF17fSgpKis/LixcXFxcXFxcXFxcXFxeJHwjXFxcXHNdL2csIFxcXCJcXFxcXFxcXCQmXFxcIik7XFxuICAgIH0sXFxuICAgIGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKGFycmF5LCB0ZXJtKSB7XFxuICAgICAgdmFyIG1hdGNoZXIgPSBuZXcgUmVnRXhwKCQudWkuYXV0b2NvbXBsZXRlLmVzY2FwZVJlZ2V4KHRlcm0pLCBcXFwiaVxcXCIpO1xcbiAgICAgIHJldHVybiAkLmdyZXAoYXJyYXksIGZ1bmN0aW9uICh2YWx1ZSkge1xcbiAgICAgICAgcmV0dXJuIG1hdGNoZXIudGVzdCh2YWx1ZS5sYWJlbCB8fCB2YWx1ZS52YWx1ZSB8fCB2YWx1ZSk7XFxuICAgICAgfSk7XFxuICAgIH1cXG4gIH0pOyAvLyBsaXZlIHJlZ2lvbiBleHRlbnNpb24sIGFkZGluZyBhIGBtZXNzYWdlc2Agb3B0aW9uXFxuICAvLyBOT1RFOiBUaGlzIGlzIGFuIGV4cGVyaW1lbnRhbCBBUEkuIFdlIGFyZSBzdGlsbCBpbnZlc3RpZ2F0aW5nXFxuICAvLyBhIGZ1bGwgc29sdXRpb24gZm9yIHN0cmluZyBtYW5pcHVsYXRpb24gYW5kIGludGVybmF0aW9uYWxpemF0aW9uLlxcblxcbiAgJC53aWRnZXQoXFxcInVpLmF1dG9jb21wbGV0ZVxcXCIsICQudWkuYXV0b2NvbXBsZXRlLCB7XFxuICAgIG9wdGlvbnM6IHtcXG4gICAgICBtZXNzYWdlczoge1xcbiAgICAgICAgbm9SZXN1bHRzOiBcXFwiTm8gc2VhcmNoIHJlc3VsdHMuXFxcIixcXG4gICAgICAgIHJlc3VsdHM6IGZ1bmN0aW9uIHJlc3VsdHMoYW1vdW50KSB7XFxuICAgICAgICAgIHJldHVybiBhbW91bnQgKyAoYW1vdW50ID4gMSA/IFxcXCIgcmVzdWx0cyBhcmVcXFwiIDogXFxcIiByZXN1bHQgaXNcXFwiKSArIFxcXCIgYXZhaWxhYmxlLCB1c2UgdXAgYW5kIGRvd24gYXJyb3cga2V5cyB0byBuYXZpZ2F0ZS5cXFwiO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgX19yZXNwb25zZTogZnVuY3Rpb24gX19yZXNwb25zZShjb250ZW50KSB7XFxuICAgICAgdmFyIG1lc3NhZ2U7XFxuXFxuICAgICAgdGhpcy5fc3VwZXJBcHBseShhcmd1bWVudHMpO1xcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGlzYWJsZWQgfHwgdGhpcy5jYW5jZWxTZWFyY2gpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGNvbnRlbnQgJiYgY29udGVudC5sZW5ndGgpIHtcXG4gICAgICAgIG1lc3NhZ2UgPSB0aGlzLm9wdGlvbnMubWVzc2FnZXMucmVzdWx0cyhjb250ZW50Lmxlbmd0aCk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIG1lc3NhZ2UgPSB0aGlzLm9wdGlvbnMubWVzc2FnZXMubm9SZXN1bHRzO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLmxpdmVSZWdpb24uY2hpbGRyZW4oKS5oaWRlKCk7XFxuICAgICAgJChcXFwiPGRpdj5cXFwiKS50ZXh0KG1lc3NhZ2UpLmFwcGVuZFRvKHRoaXMubGl2ZVJlZ2lvbik7XFxuICAgIH1cXG4gIH0pO1xcbiAgdmFyIGF1dG9jb21wbGV0ZSA9ICQudWkuYXV0b2NvbXBsZXRlO1xcbiAgLyohXFxuICAgKiBqUXVlcnkgVUkgQnV0dG9uIDEuMTEuNFxcbiAgICogaHR0cDovL2pxdWVyeXVpLmNvbVxcbiAgICpcXG4gICAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXFxuICAgKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXFxuICAgKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXFxuICAgKlxcbiAgICogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20vYnV0dG9uL1xcbiAgICovXFxuXFxuICB2YXIgbGFzdEFjdGl2ZSxcXG4gICAgICBiYXNlQ2xhc3NlcyA9IFxcXCJ1aS1idXR0b24gdWktd2lkZ2V0IHVpLXN0YXRlLWRlZmF1bHQgdWktY29ybmVyLWFsbFxcXCIsXFxuICAgICAgdHlwZUNsYXNzZXMgPSBcXFwidWktYnV0dG9uLWljb25zLW9ubHkgdWktYnV0dG9uLWljb24tb25seSB1aS1idXR0b24tdGV4dC1pY29ucyB1aS1idXR0b24tdGV4dC1pY29uLXByaW1hcnkgdWktYnV0dG9uLXRleHQtaWNvbi1zZWNvbmRhcnkgdWktYnV0dG9uLXRleHQtb25seVxcXCIsXFxuICAgICAgZm9ybVJlc2V0SGFuZGxlciA9IGZ1bmN0aW9uIGZvcm1SZXNldEhhbmRsZXIoKSB7XFxuICAgIHZhciBmb3JtID0gJCh0aGlzKTtcXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgZm9ybS5maW5kKFxcXCI6dWktYnV0dG9uXFxcIikuYnV0dG9uKFxcXCJyZWZyZXNoXFxcIik7XFxuICAgIH0sIDEpO1xcbiAgfSxcXG4gICAgICByYWRpb0dyb3VwID0gZnVuY3Rpb24gcmFkaW9Hcm91cChyYWRpbykge1xcbiAgICB2YXIgbmFtZSA9IHJhZGlvLm5hbWUsXFxuICAgICAgICBmb3JtID0gcmFkaW8uZm9ybSxcXG4gICAgICAgIHJhZGlvcyA9ICQoW10pO1xcblxcbiAgICBpZiAobmFtZSkge1xcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXFxcIlxcXFxcXFxcJ1xcXCIpO1xcblxcbiAgICAgIGlmIChmb3JtKSB7XFxuICAgICAgICByYWRpb3MgPSAkKGZvcm0pLmZpbmQoXFxcIltuYW1lPSdcXFwiICsgbmFtZSArIFxcXCInXVt0eXBlPXJhZGlvXVxcXCIpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICByYWRpb3MgPSAkKFxcXCJbbmFtZT0nXFxcIiArIG5hbWUgKyBcXFwiJ11bdHlwZT1yYWRpb11cXFwiLCByYWRpby5vd25lckRvY3VtZW50KS5maWx0ZXIoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICByZXR1cm4gIXRoaXMuZm9ybTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICByZXR1cm4gcmFkaW9zO1xcbiAgfTtcXG5cXG4gICQud2lkZ2V0KFxcXCJ1aS5idXR0b25cXFwiLCB7XFxuICAgIHZlcnNpb246IFxcXCIxLjExLjRcXFwiLFxcbiAgICBkZWZhdWx0RWxlbWVudDogXFxcIjxidXR0b24+XFxcIixcXG4gICAgb3B0aW9uczoge1xcbiAgICAgIGRpc2FibGVkOiBudWxsLFxcbiAgICAgIHRleHQ6IHRydWUsXFxuICAgICAgbGFiZWw6IG51bGwsXFxuICAgICAgaWNvbnM6IHtcXG4gICAgICAgIHByaW1hcnk6IG51bGwsXFxuICAgICAgICBzZWNvbmRhcnk6IG51bGxcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIF9jcmVhdGU6IGZ1bmN0aW9uIF9jcmVhdGUoKSB7XFxuICAgICAgdGhpcy5lbGVtZW50LmNsb3Nlc3QoXFxcImZvcm1cXFwiKS51bmJpbmQoXFxcInJlc2V0XFxcIiArIHRoaXMuZXZlbnROYW1lc3BhY2UpLmJpbmQoXFxcInJlc2V0XFxcIiArIHRoaXMuZXZlbnROYW1lc3BhY2UsIGZvcm1SZXNldEhhbmRsZXIpO1xcblxcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmRpc2FibGVkICE9PSBcXFwiYm9vbGVhblxcXCIpIHtcXG4gICAgICAgIHRoaXMub3B0aW9ucy5kaXNhYmxlZCA9ICEhdGhpcy5lbGVtZW50LnByb3AoXFxcImRpc2FibGVkXFxcIik7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRoaXMuZWxlbWVudC5wcm9wKFxcXCJkaXNhYmxlZFxcXCIsIHRoaXMub3B0aW9ucy5kaXNhYmxlZCk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX2RldGVybWluZUJ1dHRvblR5cGUoKTtcXG5cXG4gICAgICB0aGlzLmhhc1RpdGxlID0gISF0aGlzLmJ1dHRvbkVsZW1lbnQuYXR0cihcXFwidGl0bGVcXFwiKTtcXG4gICAgICB2YXIgdGhhdCA9IHRoaXMsXFxuICAgICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXFxuICAgICAgICAgIHRvZ2dsZUJ1dHRvbiA9IHRoaXMudHlwZSA9PT0gXFxcImNoZWNrYm94XFxcIiB8fCB0aGlzLnR5cGUgPT09IFxcXCJyYWRpb1xcXCIsXFxuICAgICAgICAgIGFjdGl2ZUNsYXNzID0gIXRvZ2dsZUJ1dHRvbiA/IFxcXCJ1aS1zdGF0ZS1hY3RpdmVcXFwiIDogXFxcIlxcXCI7XFxuXFxuICAgICAgaWYgKG9wdGlvbnMubGFiZWwgPT09IG51bGwpIHtcXG4gICAgICAgIG9wdGlvbnMubGFiZWwgPSB0aGlzLnR5cGUgPT09IFxcXCJpbnB1dFxcXCIgPyB0aGlzLmJ1dHRvbkVsZW1lbnQudmFsKCkgOiB0aGlzLmJ1dHRvbkVsZW1lbnQuaHRtbCgpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9ob3ZlcmFibGUodGhpcy5idXR0b25FbGVtZW50KTtcXG5cXG4gICAgICB0aGlzLmJ1dHRvbkVsZW1lbnQuYWRkQ2xhc3MoYmFzZUNsYXNzZXMpLmF0dHIoXFxcInJvbGVcXFwiLCBcXFwiYnV0dG9uXFxcIikuYmluZChcXFwibW91c2VlbnRlclxcXCIgKyB0aGlzLmV2ZW50TmFtZXNwYWNlLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICBpZiAob3B0aW9ucy5kaXNhYmxlZCkge1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAodGhpcyA9PT0gbGFzdEFjdGl2ZSkge1xcbiAgICAgICAgICAkKHRoaXMpLmFkZENsYXNzKFxcXCJ1aS1zdGF0ZS1hY3RpdmVcXFwiKTtcXG4gICAgICAgIH1cXG4gICAgICB9KS5iaW5kKFxcXCJtb3VzZWxlYXZlXFxcIiArIHRoaXMuZXZlbnROYW1lc3BhY2UsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGlmIChvcHRpb25zLmRpc2FibGVkKSB7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgICQodGhpcykucmVtb3ZlQ2xhc3MoYWN0aXZlQ2xhc3MpO1xcbiAgICAgIH0pLmJpbmQoXFxcImNsaWNrXFxcIiArIHRoaXMuZXZlbnROYW1lc3BhY2UsIGZ1bmN0aW9uIChldmVudCkge1xcbiAgICAgICAgaWYgKG9wdGlvbnMuZGlzYWJsZWQpIHtcXG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XFxuICAgICAgICB9XFxuICAgICAgfSk7IC8vIENhbid0IHVzZSBfZm9jdXNhYmxlKCkgYmVjYXVzZSB0aGUgZWxlbWVudCB0aGF0IHJlY2VpdmVzIGZvY3VzXFxuICAgICAgLy8gYW5kIHRoZSBlbGVtZW50IHRoYXQgZ2V0cyB0aGUgdWktc3RhdGUtZm9jdXMgY2xhc3MgYXJlIGRpZmZlcmVudFxcblxcbiAgICAgIHRoaXMuX29uKHtcXG4gICAgICAgIGZvY3VzOiBmdW5jdGlvbiBmb2N1cygpIHtcXG4gICAgICAgICAgdGhpcy5idXR0b25FbGVtZW50LmFkZENsYXNzKFxcXCJ1aS1zdGF0ZS1mb2N1c1xcXCIpO1xcbiAgICAgICAgfSxcXG4gICAgICAgIGJsdXI6IGZ1bmN0aW9uIGJsdXIoKSB7XFxuICAgICAgICAgIHRoaXMuYnV0dG9uRWxlbWVudC5yZW1vdmVDbGFzcyhcXFwidWktc3RhdGUtZm9jdXNcXFwiKTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG5cXG4gICAgICBpZiAodG9nZ2xlQnV0dG9uKSB7XFxuICAgICAgICB0aGlzLmVsZW1lbnQuYmluZChcXFwiY2hhbmdlXFxcIiArIHRoaXMuZXZlbnROYW1lc3BhY2UsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgdGhhdC5yZWZyZXNoKCk7XFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gXFxcImNoZWNrYm94XFxcIikge1xcbiAgICAgICAgdGhpcy5idXR0b25FbGVtZW50LmJpbmQoXFxcImNsaWNrXFxcIiArIHRoaXMuZXZlbnROYW1lc3BhY2UsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgaWYgKG9wdGlvbnMuZGlzYWJsZWQpIHtcXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSBcXFwicmFkaW9cXFwiKSB7XFxuICAgICAgICB0aGlzLmJ1dHRvbkVsZW1lbnQuYmluZChcXFwiY2xpY2tcXFwiICsgdGhpcy5ldmVudE5hbWVzcGFjZSwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBpZiAob3B0aW9ucy5kaXNhYmxlZCkge1xcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICAkKHRoaXMpLmFkZENsYXNzKFxcXCJ1aS1zdGF0ZS1hY3RpdmVcXFwiKTtcXG4gICAgICAgICAgdGhhdC5idXR0b25FbGVtZW50LmF0dHIoXFxcImFyaWEtcHJlc3NlZFxcXCIsIFxcXCJ0cnVlXFxcIik7XFxuICAgICAgICAgIHZhciByYWRpbyA9IHRoYXQuZWxlbWVudFswXTtcXG4gICAgICAgICAgcmFkaW9Hcm91cChyYWRpbykubm90KHJhZGlvKS5tYXAoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIHJldHVybiAkKHRoaXMpLmJ1dHRvbihcXFwid2lkZ2V0XFxcIilbMF07XFxuICAgICAgICAgIH0pLnJlbW92ZUNsYXNzKFxcXCJ1aS1zdGF0ZS1hY3RpdmVcXFwiKS5hdHRyKFxcXCJhcmlhLXByZXNzZWRcXFwiLCBcXFwiZmFsc2VcXFwiKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB0aGlzLmJ1dHRvbkVsZW1lbnQuYmluZChcXFwibW91c2Vkb3duXFxcIiArIHRoaXMuZXZlbnROYW1lc3BhY2UsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgaWYgKG9wdGlvbnMuZGlzYWJsZWQpIHtcXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgJCh0aGlzKS5hZGRDbGFzcyhcXFwidWktc3RhdGUtYWN0aXZlXFxcIik7XFxuICAgICAgICAgIGxhc3RBY3RpdmUgPSB0aGlzO1xcbiAgICAgICAgICB0aGF0LmRvY3VtZW50Lm9uZShcXFwibW91c2V1cFxcXCIsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBsYXN0QWN0aXZlID0gbnVsbDtcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9KS5iaW5kKFxcXCJtb3VzZXVwXFxcIiArIHRoaXMuZXZlbnROYW1lc3BhY2UsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgaWYgKG9wdGlvbnMuZGlzYWJsZWQpIHtcXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgJCh0aGlzKS5yZW1vdmVDbGFzcyhcXFwidWktc3RhdGUtYWN0aXZlXFxcIik7XFxuICAgICAgICB9KS5iaW5kKFxcXCJrZXlkb3duXFxcIiArIHRoaXMuZXZlbnROYW1lc3BhY2UsIGZ1bmN0aW9uIChldmVudCkge1xcbiAgICAgICAgICBpZiAob3B0aW9ucy5kaXNhYmxlZCkge1xcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gJC51aS5rZXlDb2RlLlNQQUNFIHx8IGV2ZW50LmtleUNvZGUgPT09ICQudWkua2V5Q29kZS5FTlRFUikge1xcbiAgICAgICAgICAgICQodGhpcykuYWRkQ2xhc3MoXFxcInVpLXN0YXRlLWFjdGl2ZVxcXCIpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9KSAvLyBzZWUgIzg1NTksIHdlIGJpbmQgdG8gYmx1ciBoZXJlIGluIGNhc2UgdGhlIGJ1dHRvbiBlbGVtZW50IGxvc2VzXFxuICAgICAgICAvLyBmb2N1cyBiZXR3ZWVuIGtleWRvd24gYW5kIGtleXVwLCBpdCB3b3VsZCBiZSBsZWZ0IGluIGFuIFxcXCJhY3RpdmVcXFwiIHN0YXRlXFxuICAgICAgICAuYmluZChcXFwia2V5dXBcXFwiICsgdGhpcy5ldmVudE5hbWVzcGFjZSArIFxcXCIgYmx1clxcXCIgKyB0aGlzLmV2ZW50TmFtZXNwYWNlLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICQodGhpcykucmVtb3ZlQ2xhc3MoXFxcInVpLXN0YXRlLWFjdGl2ZVxcXCIpO1xcbiAgICAgICAgfSk7XFxuXFxuICAgICAgICBpZiAodGhpcy5idXR0b25FbGVtZW50LmlzKFxcXCJhXFxcIikpIHtcXG4gICAgICAgICAgdGhpcy5idXR0b25FbGVtZW50LmtleXVwKGZ1bmN0aW9uIChldmVudCkge1xcbiAgICAgICAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSAkLnVpLmtleUNvZGUuU1BBQ0UpIHtcXG4gICAgICAgICAgICAgIC8vIFRPRE8gcGFzcyB0aHJvdWdoIG9yaWdpbmFsIGV2ZW50IGNvcnJlY3RseSAoanVzdCBhcyAybmQgYXJndW1lbnQgZG9lc24ndCB3b3JrKVxcbiAgICAgICAgICAgICAgJCh0aGlzKS5jbGljaygpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX3NldE9wdGlvbihcXFwiZGlzYWJsZWRcXFwiLCBvcHRpb25zLmRpc2FibGVkKTtcXG5cXG4gICAgICB0aGlzLl9yZXNldEJ1dHRvbigpO1xcbiAgICB9LFxcbiAgICBfZGV0ZXJtaW5lQnV0dG9uVHlwZTogZnVuY3Rpb24gX2RldGVybWluZUJ1dHRvblR5cGUoKSB7XFxuICAgICAgdmFyIGFuY2VzdG9yLCBsYWJlbFNlbGVjdG9yLCBjaGVja2VkO1xcblxcbiAgICAgIGlmICh0aGlzLmVsZW1lbnQuaXMoXFxcIlt0eXBlPWNoZWNrYm94XVxcXCIpKSB7XFxuICAgICAgICB0aGlzLnR5cGUgPSBcXFwiY2hlY2tib3hcXFwiO1xcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5lbGVtZW50LmlzKFxcXCJbdHlwZT1yYWRpb11cXFwiKSkge1xcbiAgICAgICAgdGhpcy50eXBlID0gXFxcInJhZGlvXFxcIjtcXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZWxlbWVudC5pcyhcXFwiaW5wdXRcXFwiKSkge1xcbiAgICAgICAgdGhpcy50eXBlID0gXFxcImlucHV0XFxcIjtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdGhpcy50eXBlID0gXFxcImJ1dHRvblxcXCI7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLnR5cGUgPT09IFxcXCJjaGVja2JveFxcXCIgfHwgdGhpcy50eXBlID09PSBcXFwicmFkaW9cXFwiKSB7XFxuICAgICAgICAvLyB3ZSBkb24ndCBzZWFyY2ggYWdhaW5zdCB0aGUgZG9jdW1lbnQgaW4gY2FzZSB0aGUgZWxlbWVudFxcbiAgICAgICAgLy8gaXMgZGlzY29ubmVjdGVkIGZyb20gdGhlIERPTVxcbiAgICAgICAgYW5jZXN0b3IgPSB0aGlzLmVsZW1lbnQucGFyZW50cygpLmxhc3QoKTtcXG4gICAgICAgIGxhYmVsU2VsZWN0b3IgPSBcXFwibGFiZWxbZm9yPSdcXFwiICsgdGhpcy5lbGVtZW50LmF0dHIoXFxcImlkXFxcIikgKyBcXFwiJ11cXFwiO1xcbiAgICAgICAgdGhpcy5idXR0b25FbGVtZW50ID0gYW5jZXN0b3IuZmluZChsYWJlbFNlbGVjdG9yKTtcXG5cXG4gICAgICAgIGlmICghdGhpcy5idXR0b25FbGVtZW50Lmxlbmd0aCkge1xcbiAgICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLmxlbmd0aCA/IGFuY2VzdG9yLnNpYmxpbmdzKCkgOiB0aGlzLmVsZW1lbnQuc2libGluZ3MoKTtcXG4gICAgICAgICAgdGhpcy5idXR0b25FbGVtZW50ID0gYW5jZXN0b3IuZmlsdGVyKGxhYmVsU2VsZWN0b3IpO1xcblxcbiAgICAgICAgICBpZiAoIXRoaXMuYnV0dG9uRWxlbWVudC5sZW5ndGgpIHtcXG4gICAgICAgICAgICB0aGlzLmJ1dHRvbkVsZW1lbnQgPSBhbmNlc3Rvci5maW5kKGxhYmVsU2VsZWN0b3IpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoXFxcInVpLWhlbHBlci1oaWRkZW4tYWNjZXNzaWJsZVxcXCIpO1xcbiAgICAgICAgY2hlY2tlZCA9IHRoaXMuZWxlbWVudC5pcyhcXFwiOmNoZWNrZWRcXFwiKTtcXG5cXG4gICAgICAgIGlmIChjaGVja2VkKSB7XFxuICAgICAgICAgIHRoaXMuYnV0dG9uRWxlbWVudC5hZGRDbGFzcyhcXFwidWktc3RhdGUtYWN0aXZlXFxcIik7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0aGlzLmJ1dHRvbkVsZW1lbnQucHJvcChcXFwiYXJpYS1wcmVzc2VkXFxcIiwgY2hlY2tlZCk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRoaXMuYnV0dG9uRWxlbWVudCA9IHRoaXMuZWxlbWVudDtcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIHdpZGdldDogZnVuY3Rpb24gd2lkZ2V0KCkge1xcbiAgICAgIHJldHVybiB0aGlzLmJ1dHRvbkVsZW1lbnQ7XFxuICAgIH0sXFxuICAgIF9kZXN0cm95OiBmdW5jdGlvbiBfZGVzdHJveSgpIHtcXG4gICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlQ2xhc3MoXFxcInVpLWhlbHBlci1oaWRkZW4tYWNjZXNzaWJsZVxcXCIpO1xcbiAgICAgIHRoaXMuYnV0dG9uRWxlbWVudC5yZW1vdmVDbGFzcyhiYXNlQ2xhc3NlcyArIFxcXCIgdWktc3RhdGUtYWN0aXZlIFxcXCIgKyB0eXBlQ2xhc3NlcykucmVtb3ZlQXR0cihcXFwicm9sZVxcXCIpLnJlbW92ZUF0dHIoXFxcImFyaWEtcHJlc3NlZFxcXCIpLmh0bWwodGhpcy5idXR0b25FbGVtZW50LmZpbmQoXFxcIi51aS1idXR0b24tdGV4dFxcXCIpLmh0bWwoKSk7XFxuXFxuICAgICAgaWYgKCF0aGlzLmhhc1RpdGxlKSB7XFxuICAgICAgICB0aGlzLmJ1dHRvbkVsZW1lbnQucmVtb3ZlQXR0cihcXFwidGl0bGVcXFwiKTtcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIF9zZXRPcHRpb246IGZ1bmN0aW9uIF9zZXRPcHRpb24oa2V5LCB2YWx1ZSkge1xcbiAgICAgIHRoaXMuX3N1cGVyKGtleSwgdmFsdWUpO1xcblxcbiAgICAgIGlmIChrZXkgPT09IFxcXCJkaXNhYmxlZFxcXCIpIHtcXG4gICAgICAgIHRoaXMud2lkZ2V0KCkudG9nZ2xlQ2xhc3MoXFxcInVpLXN0YXRlLWRpc2FibGVkXFxcIiwgISF2YWx1ZSk7XFxuICAgICAgICB0aGlzLmVsZW1lbnQucHJvcChcXFwiZGlzYWJsZWRcXFwiLCAhIXZhbHVlKTtcXG5cXG4gICAgICAgIGlmICh2YWx1ZSkge1xcbiAgICAgICAgICBpZiAodGhpcy50eXBlID09PSBcXFwiY2hlY2tib3hcXFwiIHx8IHRoaXMudHlwZSA9PT0gXFxcInJhZGlvXFxcIikge1xcbiAgICAgICAgICAgIHRoaXMuYnV0dG9uRWxlbWVudC5yZW1vdmVDbGFzcyhcXFwidWktc3RhdGUtZm9jdXNcXFwiKTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICB0aGlzLmJ1dHRvbkVsZW1lbnQucmVtb3ZlQ2xhc3MoXFxcInVpLXN0YXRlLWZvY3VzIHVpLXN0YXRlLWFjdGl2ZVxcXCIpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX3Jlc2V0QnV0dG9uKCk7XFxuICAgIH0sXFxuICAgIHJlZnJlc2g6IGZ1bmN0aW9uIHJlZnJlc2goKSB7XFxuICAgICAgLy9TZWUgIzgyMzcgJiAjODgyOFxcbiAgICAgIHZhciBpc0Rpc2FibGVkID0gdGhpcy5lbGVtZW50LmlzKFxcXCJpbnB1dCwgYnV0dG9uXFxcIikgPyB0aGlzLmVsZW1lbnQuaXMoXFxcIjpkaXNhYmxlZFxcXCIpIDogdGhpcy5lbGVtZW50Lmhhc0NsYXNzKFxcXCJ1aS1idXR0b24tZGlzYWJsZWRcXFwiKTtcXG5cXG4gICAgICBpZiAoaXNEaXNhYmxlZCAhPT0gdGhpcy5vcHRpb25zLmRpc2FibGVkKSB7XFxuICAgICAgICB0aGlzLl9zZXRPcHRpb24oXFxcImRpc2FibGVkXFxcIiwgaXNEaXNhYmxlZCk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLnR5cGUgPT09IFxcXCJyYWRpb1xcXCIpIHtcXG4gICAgICAgIHJhZGlvR3JvdXAodGhpcy5lbGVtZW50WzBdKS5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgaWYgKCQodGhpcykuaXMoXFxcIjpjaGVja2VkXFxcIikpIHtcXG4gICAgICAgICAgICAkKHRoaXMpLmJ1dHRvbihcXFwid2lkZ2V0XFxcIikuYWRkQ2xhc3MoXFxcInVpLXN0YXRlLWFjdGl2ZVxcXCIpLmF0dHIoXFxcImFyaWEtcHJlc3NlZFxcXCIsIFxcXCJ0cnVlXFxcIik7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgJCh0aGlzKS5idXR0b24oXFxcIndpZGdldFxcXCIpLnJlbW92ZUNsYXNzKFxcXCJ1aS1zdGF0ZS1hY3RpdmVcXFwiKS5hdHRyKFxcXCJhcmlhLXByZXNzZWRcXFwiLCBcXFwiZmFsc2VcXFwiKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgICAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09IFxcXCJjaGVja2JveFxcXCIpIHtcXG4gICAgICAgIGlmICh0aGlzLmVsZW1lbnQuaXMoXFxcIjpjaGVja2VkXFxcIikpIHtcXG4gICAgICAgICAgdGhpcy5idXR0b25FbGVtZW50LmFkZENsYXNzKFxcXCJ1aS1zdGF0ZS1hY3RpdmVcXFwiKS5hdHRyKFxcXCJhcmlhLXByZXNzZWRcXFwiLCBcXFwidHJ1ZVxcXCIpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgdGhpcy5idXR0b25FbGVtZW50LnJlbW92ZUNsYXNzKFxcXCJ1aS1zdGF0ZS1hY3RpdmVcXFwiKS5hdHRyKFxcXCJhcmlhLXByZXNzZWRcXFwiLCBcXFwiZmFsc2VcXFwiKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH0sXFxuICAgIF9yZXNldEJ1dHRvbjogZnVuY3Rpb24gX3Jlc2V0QnV0dG9uKCkge1xcbiAgICAgIGlmICh0aGlzLnR5cGUgPT09IFxcXCJpbnB1dFxcXCIpIHtcXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubGFiZWwpIHtcXG4gICAgICAgICAgdGhpcy5lbGVtZW50LnZhbCh0aGlzLm9wdGlvbnMubGFiZWwpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgYnV0dG9uRWxlbWVudCA9IHRoaXMuYnV0dG9uRWxlbWVudC5yZW1vdmVDbGFzcyh0eXBlQ2xhc3NlcyksXFxuICAgICAgICAgIGJ1dHRvblRleHQgPSAkKFxcXCI8c3Bhbj48L3NwYW4+XFxcIiwgdGhpcy5kb2N1bWVudFswXSkuYWRkQ2xhc3MoXFxcInVpLWJ1dHRvbi10ZXh0XFxcIikuaHRtbCh0aGlzLm9wdGlvbnMubGFiZWwpLmFwcGVuZFRvKGJ1dHRvbkVsZW1lbnQuZW1wdHkoKSkudGV4dCgpLFxcbiAgICAgICAgICBpY29ucyA9IHRoaXMub3B0aW9ucy5pY29ucyxcXG4gICAgICAgICAgbXVsdGlwbGVJY29ucyA9IGljb25zLnByaW1hcnkgJiYgaWNvbnMuc2Vjb25kYXJ5LFxcbiAgICAgICAgICBidXR0b25DbGFzc2VzID0gW107XFxuXFxuICAgICAgaWYgKGljb25zLnByaW1hcnkgfHwgaWNvbnMuc2Vjb25kYXJ5KSB7XFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRleHQpIHtcXG4gICAgICAgICAgYnV0dG9uQ2xhc3Nlcy5wdXNoKFxcXCJ1aS1idXR0b24tdGV4dC1pY29uXFxcIiArIChtdWx0aXBsZUljb25zID8gXFxcInNcXFwiIDogaWNvbnMucHJpbWFyeSA/IFxcXCItcHJpbWFyeVxcXCIgOiBcXFwiLXNlY29uZGFyeVxcXCIpKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChpY29ucy5wcmltYXJ5KSB7XFxuICAgICAgICAgIGJ1dHRvbkVsZW1lbnQucHJlcGVuZChcXFwiPHNwYW4gY2xhc3M9J3VpLWJ1dHRvbi1pY29uLXByaW1hcnkgdWktaWNvbiBcXFwiICsgaWNvbnMucHJpbWFyeSArIFxcXCInPjwvc3Bhbj5cXFwiKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChpY29ucy5zZWNvbmRhcnkpIHtcXG4gICAgICAgICAgYnV0dG9uRWxlbWVudC5hcHBlbmQoXFxcIjxzcGFuIGNsYXNzPSd1aS1idXR0b24taWNvbi1zZWNvbmRhcnkgdWktaWNvbiBcXFwiICsgaWNvbnMuc2Vjb25kYXJ5ICsgXFxcIic+PC9zcGFuPlxcXCIpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMudGV4dCkge1xcbiAgICAgICAgICBidXR0b25DbGFzc2VzLnB1c2gobXVsdGlwbGVJY29ucyA/IFxcXCJ1aS1idXR0b24taWNvbnMtb25seVxcXCIgOiBcXFwidWktYnV0dG9uLWljb24tb25seVxcXCIpO1xcblxcbiAgICAgICAgICBpZiAoIXRoaXMuaGFzVGl0bGUpIHtcXG4gICAgICAgICAgICBidXR0b25FbGVtZW50LmF0dHIoXFxcInRpdGxlXFxcIiwgJC50cmltKGJ1dHRvblRleHQpKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBidXR0b25DbGFzc2VzLnB1c2goXFxcInVpLWJ1dHRvbi10ZXh0LW9ubHlcXFwiKTtcXG4gICAgICB9XFxuXFxuICAgICAgYnV0dG9uRWxlbWVudC5hZGRDbGFzcyhidXR0b25DbGFzc2VzLmpvaW4oXFxcIiBcXFwiKSk7XFxuICAgIH1cXG4gIH0pO1xcbiAgJC53aWRnZXQoXFxcInVpLmJ1dHRvbnNldFxcXCIsIHtcXG4gICAgdmVyc2lvbjogXFxcIjEuMTEuNFxcXCIsXFxuICAgIG9wdGlvbnM6IHtcXG4gICAgICBpdGVtczogXFxcImJ1dHRvbiwgaW5wdXRbdHlwZT1idXR0b25dLCBpbnB1dFt0eXBlPXN1Ym1pdF0sIGlucHV0W3R5cGU9cmVzZXRdLCBpbnB1dFt0eXBlPWNoZWNrYm94XSwgaW5wdXRbdHlwZT1yYWRpb10sIGEsIDpkYXRhKHVpLWJ1dHRvbilcXFwiXFxuICAgIH0sXFxuICAgIF9jcmVhdGU6IGZ1bmN0aW9uIF9jcmVhdGUoKSB7XFxuICAgICAgdGhpcy5lbGVtZW50LmFkZENsYXNzKFxcXCJ1aS1idXR0b25zZXRcXFwiKTtcXG4gICAgfSxcXG4gICAgX2luaXQ6IGZ1bmN0aW9uIF9pbml0KCkge1xcbiAgICAgIHRoaXMucmVmcmVzaCgpO1xcbiAgICB9LFxcbiAgICBfc2V0T3B0aW9uOiBmdW5jdGlvbiBfc2V0T3B0aW9uKGtleSwgdmFsdWUpIHtcXG4gICAgICBpZiAoa2V5ID09PSBcXFwiZGlzYWJsZWRcXFwiKSB7XFxuICAgICAgICB0aGlzLmJ1dHRvbnMuYnV0dG9uKFxcXCJvcHRpb25cXFwiLCBrZXksIHZhbHVlKTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fc3VwZXIoa2V5LCB2YWx1ZSk7XFxuICAgIH0sXFxuICAgIHJlZnJlc2g6IGZ1bmN0aW9uIHJlZnJlc2goKSB7XFxuICAgICAgdmFyIHJ0bCA9IHRoaXMuZWxlbWVudC5jc3MoXFxcImRpcmVjdGlvblxcXCIpID09PSBcXFwicnRsXFxcIixcXG4gICAgICAgICAgYWxsQnV0dG9ucyA9IHRoaXMuZWxlbWVudC5maW5kKHRoaXMub3B0aW9ucy5pdGVtcyksXFxuICAgICAgICAgIGV4aXN0aW5nQnV0dG9ucyA9IGFsbEJ1dHRvbnMuZmlsdGVyKFxcXCI6dWktYnV0dG9uXFxcIik7IC8vIEluaXRpYWxpemUgbmV3IGJ1dHRvbnNcXG5cXG4gICAgICBhbGxCdXR0b25zLm5vdChcXFwiOnVpLWJ1dHRvblxcXCIpLmJ1dHRvbigpOyAvLyBSZWZyZXNoIGV4aXN0aW5nIGJ1dHRvbnNcXG5cXG4gICAgICBleGlzdGluZ0J1dHRvbnMuYnV0dG9uKFxcXCJyZWZyZXNoXFxcIik7XFxuICAgICAgdGhpcy5idXR0b25zID0gYWxsQnV0dG9ucy5tYXAoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgcmV0dXJuICQodGhpcykuYnV0dG9uKFxcXCJ3aWRnZXRcXFwiKVswXTtcXG4gICAgICB9KS5yZW1vdmVDbGFzcyhcXFwidWktY29ybmVyLWFsbCB1aS1jb3JuZXItbGVmdCB1aS1jb3JuZXItcmlnaHRcXFwiKS5maWx0ZXIoXFxcIjpmaXJzdFxcXCIpLmFkZENsYXNzKHJ0bCA/IFxcXCJ1aS1jb3JuZXItcmlnaHRcXFwiIDogXFxcInVpLWNvcm5lci1sZWZ0XFxcIikuZW5kKCkuZmlsdGVyKFxcXCI6bGFzdFxcXCIpLmFkZENsYXNzKHJ0bCA/IFxcXCJ1aS1jb3JuZXItbGVmdFxcXCIgOiBcXFwidWktY29ybmVyLXJpZ2h0XFxcIikuZW5kKCkuZW5kKCk7XFxuICAgIH0sXFxuICAgIF9kZXN0cm95OiBmdW5jdGlvbiBfZGVzdHJveSgpIHtcXG4gICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlQ2xhc3MoXFxcInVpLWJ1dHRvbnNldFxcXCIpO1xcbiAgICAgIHRoaXMuYnV0dG9ucy5tYXAoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgcmV0dXJuICQodGhpcykuYnV0dG9uKFxcXCJ3aWRnZXRcXFwiKVswXTtcXG4gICAgICB9KS5yZW1vdmVDbGFzcyhcXFwidWktY29ybmVyLWxlZnQgdWktY29ybmVyLXJpZ2h0XFxcIikuZW5kKCkuYnV0dG9uKFxcXCJkZXN0cm95XFxcIik7XFxuICAgIH1cXG4gIH0pO1xcbiAgdmFyIGJ1dHRvbiA9ICQudWkuYnV0dG9uO1xcbiAgLyohXFxuICAgKiBqUXVlcnkgVUkgRGF0ZXBpY2tlciAxLjExLjRcXG4gICAqIGh0dHA6Ly9qcXVlcnl1aS5jb21cXG4gICAqXFxuICAgKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xcbiAgICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxcbiAgICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxcbiAgICpcXG4gICAqIGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL2RhdGVwaWNrZXIvXFxuICAgKi9cXG5cXG4gICQuZXh0ZW5kKCQudWksIHtcXG4gICAgZGF0ZXBpY2tlcjoge1xcbiAgICAgIHZlcnNpb246IFxcXCIxLjExLjRcXFwiXFxuICAgIH1cXG4gIH0pO1xcbiAgdmFyIGRhdGVwaWNrZXJfaW5zdEFjdGl2ZTtcXG5cXG4gIGZ1bmN0aW9uIGRhdGVwaWNrZXJfZ2V0WmluZGV4KGVsZW0pIHtcXG4gICAgdmFyIHBvc2l0aW9uLCB2YWx1ZTtcXG5cXG4gICAgd2hpbGUgKGVsZW0ubGVuZ3RoICYmIGVsZW1bMF0gIT09IGRvY3VtZW50KSB7XFxuICAgICAgLy8gSWdub3JlIHotaW5kZXggaWYgcG9zaXRpb24gaXMgc2V0IHRvIGEgdmFsdWUgd2hlcmUgei1pbmRleCBpcyBpZ25vcmVkIGJ5IHRoZSBicm93c2VyXFxuICAgICAgLy8gVGhpcyBtYWtlcyBiZWhhdmlvciBvZiB0aGlzIGZ1bmN0aW9uIGNvbnNpc3RlbnQgYWNyb3NzIGJyb3dzZXJzXFxuICAgICAgLy8gV2ViS2l0IGFsd2F5cyByZXR1cm5zIGF1dG8gaWYgdGhlIGVsZW1lbnQgaXMgcG9zaXRpb25lZFxcbiAgICAgIHBvc2l0aW9uID0gZWxlbS5jc3MoXFxcInBvc2l0aW9uXFxcIik7XFxuXFxuICAgICAgaWYgKHBvc2l0aW9uID09PSBcXFwiYWJzb2x1dGVcXFwiIHx8IHBvc2l0aW9uID09PSBcXFwicmVsYXRpdmVcXFwiIHx8IHBvc2l0aW9uID09PSBcXFwiZml4ZWRcXFwiKSB7XFxuICAgICAgICAvLyBJRSByZXR1cm5zIDAgd2hlbiB6SW5kZXggaXMgbm90IHNwZWNpZmllZFxcbiAgICAgICAgLy8gb3RoZXIgYnJvd3NlcnMgcmV0dXJuIGEgc3RyaW5nXFxuICAgICAgICAvLyB3ZSBpZ25vcmUgdGhlIGNhc2Ugb2YgbmVzdGVkIGVsZW1lbnRzIHdpdGggYW4gZXhwbGljaXQgdmFsdWUgb2YgMFxcbiAgICAgICAgLy8gPGRpdiBzdHlsZT1cXFwiei1pbmRleDogLTEwO1xcXCI+PGRpdiBzdHlsZT1cXFwiei1pbmRleDogMDtcXFwiPjwvZGl2PjwvZGl2PlxcbiAgICAgICAgdmFsdWUgPSBwYXJzZUludChlbGVtLmNzcyhcXFwiekluZGV4XFxcIiksIDEwKTtcXG5cXG4gICAgICAgIGlmICghaXNOYU4odmFsdWUpICYmIHZhbHVlICE9PSAwKSB7XFxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgZWxlbSA9IGVsZW0ucGFyZW50KCk7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIDA7XFxuICB9XFxuICAvKiBEYXRlIHBpY2tlciBtYW5hZ2VyLlxcbiAgICAgVXNlIHRoZSBzaW5nbGV0b24gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcywgJC5kYXRlcGlja2VyLCB0byBpbnRlcmFjdCB3aXRoIHRoZSBkYXRlIHBpY2tlci5cXG4gICAgIFNldHRpbmdzIGZvciAoZ3JvdXBzIG9mKSBkYXRlIHBpY2tlcnMgYXJlIG1haW50YWluZWQgaW4gYW4gaW5zdGFuY2Ugb2JqZWN0LFxcbiAgICAgYWxsb3dpbmcgbXVsdGlwbGUgZGlmZmVyZW50IHNldHRpbmdzIG9uIHRoZSBzYW1lIHBhZ2UuICovXFxuXFxuXFxuICBmdW5jdGlvbiBEYXRlcGlja2VyKCkge1xcbiAgICB0aGlzLl9jdXJJbnN0ID0gbnVsbDsgLy8gVGhlIGN1cnJlbnQgaW5zdGFuY2UgaW4gdXNlXFxuXFxuICAgIHRoaXMuX2tleUV2ZW50ID0gZmFsc2U7IC8vIElmIHRoZSBsYXN0IGV2ZW50IHdhcyBhIGtleSBldmVudFxcblxcbiAgICB0aGlzLl9kaXNhYmxlZElucHV0cyA9IFtdOyAvLyBMaXN0IG9mIGRhdGUgcGlja2VyIGlucHV0cyB0aGF0IGhhdmUgYmVlbiBkaXNhYmxlZFxcblxcbiAgICB0aGlzLl9kYXRlcGlja2VyU2hvd2luZyA9IGZhbHNlOyAvLyBUcnVlIGlmIHRoZSBwb3B1cCBwaWNrZXIgaXMgc2hvd2luZyAsIGZhbHNlIGlmIG5vdFxcblxcbiAgICB0aGlzLl9pbkRpYWxvZyA9IGZhbHNlOyAvLyBUcnVlIGlmIHNob3dpbmcgd2l0aGluIGEgXFxcImRpYWxvZ1xcXCIsIGZhbHNlIGlmIG5vdFxcblxcbiAgICB0aGlzLl9tYWluRGl2SWQgPSBcXFwidWktZGF0ZXBpY2tlci1kaXZcXFwiOyAvLyBUaGUgSUQgb2YgdGhlIG1haW4gZGF0ZXBpY2tlciBkaXZpc2lvblxcblxcbiAgICB0aGlzLl9pbmxpbmVDbGFzcyA9IFxcXCJ1aS1kYXRlcGlja2VyLWlubGluZVxcXCI7IC8vIFRoZSBuYW1lIG9mIHRoZSBpbmxpbmUgbWFya2VyIGNsYXNzXFxuXFxuICAgIHRoaXMuX2FwcGVuZENsYXNzID0gXFxcInVpLWRhdGVwaWNrZXItYXBwZW5kXFxcIjsgLy8gVGhlIG5hbWUgb2YgdGhlIGFwcGVuZCBtYXJrZXIgY2xhc3NcXG5cXG4gICAgdGhpcy5fdHJpZ2dlckNsYXNzID0gXFxcInVpLWRhdGVwaWNrZXItdHJpZ2dlclxcXCI7IC8vIFRoZSBuYW1lIG9mIHRoZSB0cmlnZ2VyIG1hcmtlciBjbGFzc1xcblxcbiAgICB0aGlzLl9kaWFsb2dDbGFzcyA9IFxcXCJ1aS1kYXRlcGlja2VyLWRpYWxvZ1xcXCI7IC8vIFRoZSBuYW1lIG9mIHRoZSBkaWFsb2cgbWFya2VyIGNsYXNzXFxuXFxuICAgIHRoaXMuX2Rpc2FibGVDbGFzcyA9IFxcXCJ1aS1kYXRlcGlja2VyLWRpc2FibGVkXFxcIjsgLy8gVGhlIG5hbWUgb2YgdGhlIGRpc2FibGVkIGNvdmVyaW5nIG1hcmtlciBjbGFzc1xcblxcbiAgICB0aGlzLl91bnNlbGVjdGFibGVDbGFzcyA9IFxcXCJ1aS1kYXRlcGlja2VyLXVuc2VsZWN0YWJsZVxcXCI7IC8vIFRoZSBuYW1lIG9mIHRoZSB1bnNlbGVjdGFibGUgY2VsbCBtYXJrZXIgY2xhc3NcXG5cXG4gICAgdGhpcy5fY3VycmVudENsYXNzID0gXFxcInVpLWRhdGVwaWNrZXItY3VycmVudC1kYXlcXFwiOyAvLyBUaGUgbmFtZSBvZiB0aGUgY3VycmVudCBkYXkgbWFya2VyIGNsYXNzXFxuXFxuICAgIHRoaXMuX2RheU92ZXJDbGFzcyA9IFxcXCJ1aS1kYXRlcGlja2VyLWRheXMtY2VsbC1vdmVyXFxcIjsgLy8gVGhlIG5hbWUgb2YgdGhlIGRheSBob3ZlciBtYXJrZXIgY2xhc3NcXG5cXG4gICAgdGhpcy5yZWdpb25hbCA9IFtdOyAvLyBBdmFpbGFibGUgcmVnaW9uYWwgc2V0dGluZ3MsIGluZGV4ZWQgYnkgbGFuZ3VhZ2UgY29kZVxcblxcbiAgICB0aGlzLnJlZ2lvbmFsW1xcXCJcXFwiXSA9IHtcXG4gICAgICAvLyBEZWZhdWx0IHJlZ2lvbmFsIHNldHRpbmdzXFxuICAgICAgY2xvc2VUZXh0OiBcXFwiRG9uZVxcXCIsXFxuICAgICAgLy8gRGlzcGxheSB0ZXh0IGZvciBjbG9zZSBsaW5rXFxuICAgICAgcHJldlRleHQ6IFxcXCJQcmV2XFxcIixcXG4gICAgICAvLyBEaXNwbGF5IHRleHQgZm9yIHByZXZpb3VzIG1vbnRoIGxpbmtcXG4gICAgICBuZXh0VGV4dDogXFxcIk5leHRcXFwiLFxcbiAgICAgIC8vIERpc3BsYXkgdGV4dCBmb3IgbmV4dCBtb250aCBsaW5rXFxuICAgICAgY3VycmVudFRleHQ6IFxcXCJUb2RheVxcXCIsXFxuICAgICAgLy8gRGlzcGxheSB0ZXh0IGZvciBjdXJyZW50IG1vbnRoIGxpbmtcXG4gICAgICBtb250aE5hbWVzOiBbXFxcIkphbnVhcnlcXFwiLCBcXFwiRmVicnVhcnlcXFwiLCBcXFwiTWFyY2hcXFwiLCBcXFwiQXByaWxcXFwiLCBcXFwiTWF5XFxcIiwgXFxcIkp1bmVcXFwiLCBcXFwiSnVseVxcXCIsIFxcXCJBdWd1c3RcXFwiLCBcXFwiU2VwdGVtYmVyXFxcIiwgXFxcIk9jdG9iZXJcXFwiLCBcXFwiTm92ZW1iZXJcXFwiLCBcXFwiRGVjZW1iZXJcXFwiXSxcXG4gICAgICAvLyBOYW1lcyBvZiBtb250aHMgZm9yIGRyb3AtZG93biBhbmQgZm9ybWF0dGluZ1xcbiAgICAgIG1vbnRoTmFtZXNTaG9ydDogW1xcXCJKYW5cXFwiLCBcXFwiRmViXFxcIiwgXFxcIk1hclxcXCIsIFxcXCJBcHJcXFwiLCBcXFwiTWF5XFxcIiwgXFxcIkp1blxcXCIsIFxcXCJKdWxcXFwiLCBcXFwiQXVnXFxcIiwgXFxcIlNlcFxcXCIsIFxcXCJPY3RcXFwiLCBcXFwiTm92XFxcIiwgXFxcIkRlY1xcXCJdLFxcbiAgICAgIC8vIEZvciBmb3JtYXR0aW5nXFxuICAgICAgZGF5TmFtZXM6IFtcXFwiU3VuZGF5XFxcIiwgXFxcIk1vbmRheVxcXCIsIFxcXCJUdWVzZGF5XFxcIiwgXFxcIldlZG5lc2RheVxcXCIsIFxcXCJUaHVyc2RheVxcXCIsIFxcXCJGcmlkYXlcXFwiLCBcXFwiU2F0dXJkYXlcXFwiXSxcXG4gICAgICAvLyBGb3IgZm9ybWF0dGluZ1xcbiAgICAgIGRheU5hbWVzU2hvcnQ6IFtcXFwiU3VuXFxcIiwgXFxcIk1vblxcXCIsIFxcXCJUdWVcXFwiLCBcXFwiV2VkXFxcIiwgXFxcIlRodVxcXCIsIFxcXCJGcmlcXFwiLCBcXFwiU2F0XFxcIl0sXFxuICAgICAgLy8gRm9yIGZvcm1hdHRpbmdcXG4gICAgICBkYXlOYW1lc01pbjogW1xcXCJTdVxcXCIsIFxcXCJNb1xcXCIsIFxcXCJUdVxcXCIsIFxcXCJXZVxcXCIsIFxcXCJUaFxcXCIsIFxcXCJGclxcXCIsIFxcXCJTYVxcXCJdLFxcbiAgICAgIC8vIENvbHVtbiBoZWFkaW5ncyBmb3IgZGF5cyBzdGFydGluZyBhdCBTdW5kYXlcXG4gICAgICB3ZWVrSGVhZGVyOiBcXFwiV2tcXFwiLFxcbiAgICAgIC8vIENvbHVtbiBoZWFkZXIgZm9yIHdlZWsgb2YgdGhlIHllYXJcXG4gICAgICBkYXRlRm9ybWF0OiBcXFwibW0vZGQveXlcXFwiLFxcbiAgICAgIC8vIFNlZSBmb3JtYXQgb3B0aW9ucyBvbiBwYXJzZURhdGVcXG4gICAgICBmaXJzdERheTogMCxcXG4gICAgICAvLyBUaGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLCBTdW4gPSAwLCBNb24gPSAxLCAuLi5cXG4gICAgICBpc1JUTDogZmFsc2UsXFxuICAgICAgLy8gVHJ1ZSBpZiByaWdodC10by1sZWZ0IGxhbmd1YWdlLCBmYWxzZSBpZiBsZWZ0LXRvLXJpZ2h0XFxuICAgICAgc2hvd01vbnRoQWZ0ZXJZZWFyOiBmYWxzZSxcXG4gICAgICAvLyBUcnVlIGlmIHRoZSB5ZWFyIHNlbGVjdCBwcmVjZWRlcyBtb250aCwgZmFsc2UgZm9yIG1vbnRoIHRoZW4geWVhclxcbiAgICAgIHllYXJTdWZmaXg6IFxcXCJcXFwiIC8vIEFkZGl0aW9uYWwgdGV4dCB0byBhcHBlbmQgdG8gdGhlIHllYXIgaW4gdGhlIG1vbnRoIGhlYWRlcnNcXG5cXG4gICAgfTtcXG4gICAgdGhpcy5fZGVmYXVsdHMgPSB7XFxuICAgICAgLy8gR2xvYmFsIGRlZmF1bHRzIGZvciBhbGwgdGhlIGRhdGUgcGlja2VyIGluc3RhbmNlc1xcbiAgICAgIHNob3dPbjogXFxcImZvY3VzXFxcIixcXG4gICAgICAvLyBcXFwiZm9jdXNcXFwiIGZvciBwb3B1cCBvbiBmb2N1cyxcXG4gICAgICAvLyBcXFwiYnV0dG9uXFxcIiBmb3IgdHJpZ2dlciBidXR0b24sIG9yIFxcXCJib3RoXFxcIiBmb3IgZWl0aGVyXFxuICAgICAgc2hvd0FuaW06IFxcXCJmYWRlSW5cXFwiLFxcbiAgICAgIC8vIE5hbWUgb2YgalF1ZXJ5IGFuaW1hdGlvbiBmb3IgcG9wdXBcXG4gICAgICBzaG93T3B0aW9uczoge30sXFxuICAgICAgLy8gT3B0aW9ucyBmb3IgZW5oYW5jZWQgYW5pbWF0aW9uc1xcbiAgICAgIGRlZmF1bHREYXRlOiBudWxsLFxcbiAgICAgIC8vIFVzZWQgd2hlbiBmaWVsZCBpcyBibGFuazogYWN0dWFsIGRhdGUsXFxuICAgICAgLy8gKy8tbnVtYmVyIGZvciBvZmZzZXQgZnJvbSB0b2RheSwgbnVsbCBmb3IgdG9kYXlcXG4gICAgICBhcHBlbmRUZXh0OiBcXFwiXFxcIixcXG4gICAgICAvLyBEaXNwbGF5IHRleHQgZm9sbG93aW5nIHRoZSBpbnB1dCBib3gsIGUuZy4gc2hvd2luZyB0aGUgZm9ybWF0XFxuICAgICAgYnV0dG9uVGV4dDogXFxcIi4uLlxcXCIsXFxuICAgICAgLy8gVGV4dCBmb3IgdHJpZ2dlciBidXR0b25cXG4gICAgICBidXR0b25JbWFnZTogXFxcIlxcXCIsXFxuICAgICAgLy8gVVJMIGZvciB0cmlnZ2VyIGJ1dHRvbiBpbWFnZVxcbiAgICAgIGJ1dHRvbkltYWdlT25seTogZmFsc2UsXFxuICAgICAgLy8gVHJ1ZSBpZiB0aGUgaW1hZ2UgYXBwZWFycyBhbG9uZSwgZmFsc2UgaWYgaXQgYXBwZWFycyBvbiBhIGJ1dHRvblxcbiAgICAgIGhpZGVJZk5vUHJldk5leHQ6IGZhbHNlLFxcbiAgICAgIC8vIFRydWUgdG8gaGlkZSBuZXh0L3ByZXZpb3VzIG1vbnRoIGxpbmtzXFxuICAgICAgLy8gaWYgbm90IGFwcGxpY2FibGUsIGZhbHNlIHRvIGp1c3QgZGlzYWJsZSB0aGVtXFxuICAgICAgbmF2aWdhdGlvbkFzRGF0ZUZvcm1hdDogZmFsc2UsXFxuICAgICAgLy8gVHJ1ZSBpZiBkYXRlIGZvcm1hdHRpbmcgYXBwbGllZCB0byBwcmV2L3RvZGF5L25leHQgbGlua3NcXG4gICAgICBnb3RvQ3VycmVudDogZmFsc2UsXFxuICAgICAgLy8gVHJ1ZSBpZiB0b2RheSBsaW5rIGdvZXMgYmFjayB0byBjdXJyZW50IHNlbGVjdGlvbiBpbnN0ZWFkXFxuICAgICAgY2hhbmdlTW9udGg6IGZhbHNlLFxcbiAgICAgIC8vIFRydWUgaWYgbW9udGggY2FuIGJlIHNlbGVjdGVkIGRpcmVjdGx5LCBmYWxzZSBpZiBvbmx5IHByZXYvbmV4dFxcbiAgICAgIGNoYW5nZVllYXI6IGZhbHNlLFxcbiAgICAgIC8vIFRydWUgaWYgeWVhciBjYW4gYmUgc2VsZWN0ZWQgZGlyZWN0bHksIGZhbHNlIGlmIG9ubHkgcHJldi9uZXh0XFxuICAgICAgeWVhclJhbmdlOiBcXFwiYy0xMDpjKzEwXFxcIixcXG4gICAgICAvLyBSYW5nZSBvZiB5ZWFycyB0byBkaXNwbGF5IGluIGRyb3AtZG93bixcXG4gICAgICAvLyBlaXRoZXIgcmVsYXRpdmUgdG8gdG9kYXkncyB5ZWFyICgtbm46K25uKSwgcmVsYXRpdmUgdG8gY3VycmVudGx5IGRpc3BsYXllZCB5ZWFyXFxuICAgICAgLy8gKGMtbm46YytubiksIGFic29sdXRlIChubm5uOm5ubm4pLCBvciBhIGNvbWJpbmF0aW9uIG9mIHRoZSBhYm92ZSAobm5ubjotbilcXG4gICAgICBzaG93T3RoZXJNb250aHM6IGZhbHNlLFxcbiAgICAgIC8vIFRydWUgdG8gc2hvdyBkYXRlcyBpbiBvdGhlciBtb250aHMsIGZhbHNlIHRvIGxlYXZlIGJsYW5rXFxuICAgICAgc2VsZWN0T3RoZXJNb250aHM6IGZhbHNlLFxcbiAgICAgIC8vIFRydWUgdG8gYWxsb3cgc2VsZWN0aW9uIG9mIGRhdGVzIGluIG90aGVyIG1vbnRocywgZmFsc2UgZm9yIHVuc2VsZWN0YWJsZVxcbiAgICAgIHNob3dXZWVrOiBmYWxzZSxcXG4gICAgICAvLyBUcnVlIHRvIHNob3cgd2VlayBvZiB0aGUgeWVhciwgZmFsc2UgdG8gbm90IHNob3cgaXRcXG4gICAgICBjYWxjdWxhdGVXZWVrOiB0aGlzLmlzbzg2MDFXZWVrLFxcbiAgICAgIC8vIEhvdyB0byBjYWxjdWxhdGUgdGhlIHdlZWsgb2YgdGhlIHllYXIsXFxuICAgICAgLy8gdGFrZXMgYSBEYXRlIGFuZCByZXR1cm5zIHRoZSBudW1iZXIgb2YgdGhlIHdlZWsgZm9yIGl0XFxuICAgICAgc2hvcnRZZWFyQ3V0b2ZmOiBcXFwiKzEwXFxcIixcXG4gICAgICAvLyBTaG9ydCB5ZWFyIHZhbHVlcyA8IHRoaXMgYXJlIGluIHRoZSBjdXJyZW50IGNlbnR1cnksXFxuICAgICAgLy8gPiB0aGlzIGFyZSBpbiB0aGUgcHJldmlvdXMgY2VudHVyeSxcXG4gICAgICAvLyBzdHJpbmcgdmFsdWUgc3RhcnRpbmcgd2l0aCBcXFwiK1xcXCIgZm9yIGN1cnJlbnQgeWVhciArIHZhbHVlXFxuICAgICAgbWluRGF0ZTogbnVsbCxcXG4gICAgICAvLyBUaGUgZWFybGllc3Qgc2VsZWN0YWJsZSBkYXRlLCBvciBudWxsIGZvciBubyBsaW1pdFxcbiAgICAgIG1heERhdGU6IG51bGwsXFxuICAgICAgLy8gVGhlIGxhdGVzdCBzZWxlY3RhYmxlIGRhdGUsIG9yIG51bGwgZm9yIG5vIGxpbWl0XFxuICAgICAgZHVyYXRpb246IFxcXCJmYXN0XFxcIixcXG4gICAgICAvLyBEdXJhdGlvbiBvZiBkaXNwbGF5L2Nsb3N1cmVcXG4gICAgICBiZWZvcmVTaG93RGF5OiBudWxsLFxcbiAgICAgIC8vIEZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBkYXRlIGFuZCByZXR1cm5zIGFuIGFycmF5IHdpdGhcXG4gICAgICAvLyBbMF0gPSB0cnVlIGlmIHNlbGVjdGFibGUsIGZhbHNlIGlmIG5vdCwgWzFdID0gY3VzdG9tIENTUyBjbGFzcyBuYW1lKHMpIG9yIFxcXCJcXFwiLFxcbiAgICAgIC8vIFsyXSA9IGNlbGwgdGl0bGUgKG9wdGlvbmFsKSwgZS5nLiAkLmRhdGVwaWNrZXIubm9XZWVrZW5kc1xcbiAgICAgIGJlZm9yZVNob3c6IG51bGwsXFxuICAgICAgLy8gRnVuY3Rpb24gdGhhdCB0YWtlcyBhbiBpbnB1dCBmaWVsZCBhbmRcXG4gICAgICAvLyByZXR1cm5zIGEgc2V0IG9mIGN1c3RvbSBzZXR0aW5ncyBmb3IgdGhlIGRhdGUgcGlja2VyXFxuICAgICAgb25TZWxlY3Q6IG51bGwsXFxuICAgICAgLy8gRGVmaW5lIGEgY2FsbGJhY2sgZnVuY3Rpb24gd2hlbiBhIGRhdGUgaXMgc2VsZWN0ZWRcXG4gICAgICBvbkNoYW5nZU1vbnRoWWVhcjogbnVsbCxcXG4gICAgICAvLyBEZWZpbmUgYSBjYWxsYmFjayBmdW5jdGlvbiB3aGVuIHRoZSBtb250aCBvciB5ZWFyIGlzIGNoYW5nZWRcXG4gICAgICBvbkNsb3NlOiBudWxsLFxcbiAgICAgIC8vIERlZmluZSBhIGNhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gdGhlIGRhdGVwaWNrZXIgaXMgY2xvc2VkXFxuICAgICAgbnVtYmVyT2ZNb250aHM6IDEsXFxuICAgICAgLy8gTnVtYmVyIG9mIG1vbnRocyB0byBzaG93IGF0IGEgdGltZVxcbiAgICAgIHNob3dDdXJyZW50QXRQb3M6IDAsXFxuICAgICAgLy8gVGhlIHBvc2l0aW9uIGluIG11bHRpcGUgbW9udGhzIGF0IHdoaWNoIHRvIHNob3cgdGhlIGN1cnJlbnQgbW9udGggKHN0YXJ0aW5nIGF0IDApXFxuICAgICAgc3RlcE1vbnRoczogMSxcXG4gICAgICAvLyBOdW1iZXIgb2YgbW9udGhzIHRvIHN0ZXAgYmFjay9mb3J3YXJkXFxuICAgICAgc3RlcEJpZ01vbnRoczogMTIsXFxuICAgICAgLy8gTnVtYmVyIG9mIG1vbnRocyB0byBzdGVwIGJhY2svZm9yd2FyZCBmb3IgdGhlIGJpZyBsaW5rc1xcbiAgICAgIGFsdEZpZWxkOiBcXFwiXFxcIixcXG4gICAgICAvLyBTZWxlY3RvciBmb3IgYW4gYWx0ZXJuYXRlIGZpZWxkIHRvIHN0b3JlIHNlbGVjdGVkIGRhdGVzIGludG9cXG4gICAgICBhbHRGb3JtYXQ6IFxcXCJcXFwiLFxcbiAgICAgIC8vIFRoZSBkYXRlIGZvcm1hdCB0byB1c2UgZm9yIHRoZSBhbHRlcm5hdGUgZmllbGRcXG4gICAgICBjb25zdHJhaW5JbnB1dDogdHJ1ZSxcXG4gICAgICAvLyBUaGUgaW5wdXQgaXMgY29uc3RyYWluZWQgYnkgdGhlIGN1cnJlbnQgZGF0ZSBmb3JtYXRcXG4gICAgICBzaG93QnV0dG9uUGFuZWw6IGZhbHNlLFxcbiAgICAgIC8vIFRydWUgdG8gc2hvdyBidXR0b24gcGFuZWwsIGZhbHNlIHRvIG5vdCBzaG93IGl0XFxuICAgICAgYXV0b1NpemU6IGZhbHNlLFxcbiAgICAgIC8vIFRydWUgdG8gc2l6ZSB0aGUgaW5wdXQgZm9yIHRoZSBkYXRlIGZvcm1hdCwgZmFsc2UgdG8gbGVhdmUgYXMgaXNcXG4gICAgICBkaXNhYmxlZDogZmFsc2UgLy8gVGhlIGluaXRpYWwgZGlzYWJsZWQgc3RhdGVcXG5cXG4gICAgfTtcXG4gICAgJC5leHRlbmQodGhpcy5fZGVmYXVsdHMsIHRoaXMucmVnaW9uYWxbXFxcIlxcXCJdKTtcXG4gICAgdGhpcy5yZWdpb25hbC5lbiA9ICQuZXh0ZW5kKHRydWUsIHt9LCB0aGlzLnJlZ2lvbmFsW1xcXCJcXFwiXSk7XFxuICAgIHRoaXMucmVnaW9uYWxbXFxcImVuLVVTXFxcIl0gPSAkLmV4dGVuZCh0cnVlLCB7fSwgdGhpcy5yZWdpb25hbC5lbik7XFxuICAgIHRoaXMuZHBEaXYgPSBkYXRlcGlja2VyX2JpbmRIb3ZlcigkKFxcXCI8ZGl2IGlkPSdcXFwiICsgdGhpcy5fbWFpbkRpdklkICsgXFxcIicgY2xhc3M9J3VpLWRhdGVwaWNrZXIgdWktd2lkZ2V0IHVpLXdpZGdldC1jb250ZW50IHVpLWhlbHBlci1jbGVhcmZpeCB1aS1jb3JuZXItYWxsJz48L2Rpdj5cXFwiKSk7XFxuICB9XFxuXFxuICAkLmV4dGVuZChEYXRlcGlja2VyLnByb3RvdHlwZSwge1xcbiAgICAvKiBDbGFzcyBuYW1lIGFkZGVkIHRvIGVsZW1lbnRzIHRvIGluZGljYXRlIGFscmVhZHkgY29uZmlndXJlZCB3aXRoIGEgZGF0ZSBwaWNrZXIuICovXFxuICAgIG1hcmtlckNsYXNzTmFtZTogXFxcImhhc0RhdGVwaWNrZXJcXFwiLFxcbiAgICAvL0tlZXAgdHJhY2sgb2YgdGhlIG1heGltdW0gbnVtYmVyIG9mIHJvd3MgZGlzcGxheWVkIChzZWUgIzcwNDMpXFxuICAgIG1heFJvd3M6IDQsXFxuICAgIC8vIFRPRE8gcmVuYW1lIHRvIFxcXCJ3aWRnZXRcXFwiIHdoZW4gc3dpdGNoaW5nIHRvIHdpZGdldCBmYWN0b3J5XFxuICAgIF93aWRnZXREYXRlcGlja2VyOiBmdW5jdGlvbiBfd2lkZ2V0RGF0ZXBpY2tlcigpIHtcXG4gICAgICByZXR1cm4gdGhpcy5kcERpdjtcXG4gICAgfSxcXG5cXG4gICAgLyogT3ZlcnJpZGUgdGhlIGRlZmF1bHQgc2V0dGluZ3MgZm9yIGFsbCBpbnN0YW5jZXMgb2YgdGhlIGRhdGUgcGlja2VyLlxcbiAgICAgKiBAcGFyYW0gIHNldHRpbmdzICBvYmplY3QgLSB0aGUgbmV3IHNldHRpbmdzIHRvIHVzZSBhcyBkZWZhdWx0cyAoYW5vbnltb3VzIG9iamVjdClcXG4gICAgICogQHJldHVybiB0aGUgbWFuYWdlciBvYmplY3RcXG4gICAgICovXFxuICAgIHNldERlZmF1bHRzOiBmdW5jdGlvbiBzZXREZWZhdWx0cyhzZXR0aW5ncykge1xcbiAgICAgIGRhdGVwaWNrZXJfZXh0ZW5kUmVtb3ZlKHRoaXMuX2RlZmF1bHRzLCBzZXR0aW5ncyB8fCB7fSk7XFxuICAgICAgcmV0dXJuIHRoaXM7XFxuICAgIH0sXFxuXFxuICAgIC8qIEF0dGFjaCB0aGUgZGF0ZSBwaWNrZXIgdG8gYSBqUXVlcnkgc2VsZWN0aW9uLlxcbiAgICAgKiBAcGFyYW0gIHRhcmdldFxcdGVsZW1lbnQgLSB0aGUgdGFyZ2V0IGlucHV0IGZpZWxkIG9yIGRpdmlzaW9uIG9yIHNwYW5cXG4gICAgICogQHBhcmFtICBzZXR0aW5ncyAgb2JqZWN0IC0gdGhlIG5ldyBzZXR0aW5ncyB0byB1c2UgZm9yIHRoaXMgZGF0ZSBwaWNrZXIgaW5zdGFuY2UgKGFub255bW91cylcXG4gICAgICovXFxuICAgIF9hdHRhY2hEYXRlcGlja2VyOiBmdW5jdGlvbiBfYXR0YWNoRGF0ZXBpY2tlcih0YXJnZXQsIHNldHRpbmdzKSB7XFxuICAgICAgdmFyIG5vZGVOYW1lLCBpbmxpbmUsIGluc3Q7XFxuICAgICAgbm9kZU5hbWUgPSB0YXJnZXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcXG4gICAgICBpbmxpbmUgPSBub2RlTmFtZSA9PT0gXFxcImRpdlxcXCIgfHwgbm9kZU5hbWUgPT09IFxcXCJzcGFuXFxcIjtcXG5cXG4gICAgICBpZiAoIXRhcmdldC5pZCkge1xcbiAgICAgICAgdGhpcy51dWlkICs9IDE7XFxuICAgICAgICB0YXJnZXQuaWQgPSBcXFwiZHBcXFwiICsgdGhpcy51dWlkO1xcbiAgICAgIH1cXG5cXG4gICAgICBpbnN0ID0gdGhpcy5fbmV3SW5zdCgkKHRhcmdldCksIGlubGluZSk7XFxuICAgICAgaW5zdC5zZXR0aW5ncyA9ICQuZXh0ZW5kKHt9LCBzZXR0aW5ncyB8fCB7fSk7XFxuXFxuICAgICAgaWYgKG5vZGVOYW1lID09PSBcXFwiaW5wdXRcXFwiKSB7XFxuICAgICAgICB0aGlzLl9jb25uZWN0RGF0ZXBpY2tlcih0YXJnZXQsIGluc3QpO1xcbiAgICAgIH0gZWxzZSBpZiAoaW5saW5lKSB7XFxuICAgICAgICB0aGlzLl9pbmxpbmVEYXRlcGlja2VyKHRhcmdldCwgaW5zdCk7XFxuICAgICAgfVxcbiAgICB9LFxcblxcbiAgICAvKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2JqZWN0LiAqL1xcbiAgICBfbmV3SW5zdDogZnVuY3Rpb24gX25ld0luc3QodGFyZ2V0LCBpbmxpbmUpIHtcXG4gICAgICB2YXIgaWQgPSB0YXJnZXRbMF0uaWQucmVwbGFjZSgvKFteQS1aYS16MC05X1xcXFwtXSkvZywgXFxcIlxcXFxcXFxcXFxcXFxcXFwkMVxcXCIpOyAvLyBlc2NhcGUgalF1ZXJ5IG1ldGEgY2hhcnNcXG5cXG4gICAgICByZXR1cm4ge1xcbiAgICAgICAgaWQ6IGlkLFxcbiAgICAgICAgaW5wdXQ6IHRhcmdldCxcXG4gICAgICAgIC8vIGFzc29jaWF0ZWQgdGFyZ2V0XFxuICAgICAgICBzZWxlY3RlZERheTogMCxcXG4gICAgICAgIHNlbGVjdGVkTW9udGg6IDAsXFxuICAgICAgICBzZWxlY3RlZFllYXI6IDAsXFxuICAgICAgICAvLyBjdXJyZW50IHNlbGVjdGlvblxcbiAgICAgICAgZHJhd01vbnRoOiAwLFxcbiAgICAgICAgZHJhd1llYXI6IDAsXFxuICAgICAgICAvLyBtb250aCBiZWluZyBkcmF3blxcbiAgICAgICAgaW5saW5lOiBpbmxpbmUsXFxuICAgICAgICAvLyBpcyBkYXRlcGlja2VyIGlubGluZSBvciBub3RcXG4gICAgICAgIGRwRGl2OiAhaW5saW5lID8gdGhpcy5kcERpdiA6IC8vIHByZXNlbnRhdGlvbiBkaXZcXG4gICAgICAgIGRhdGVwaWNrZXJfYmluZEhvdmVyKCQoXFxcIjxkaXYgY2xhc3M9J1xcXCIgKyB0aGlzLl9pbmxpbmVDbGFzcyArIFxcXCIgdWktZGF0ZXBpY2tlciB1aS13aWRnZXQgdWktd2lkZ2V0LWNvbnRlbnQgdWktaGVscGVyLWNsZWFyZml4IHVpLWNvcm5lci1hbGwnPjwvZGl2PlxcXCIpKVxcbiAgICAgIH07XFxuICAgIH0sXFxuXFxuICAgIC8qIEF0dGFjaCB0aGUgZGF0ZSBwaWNrZXIgdG8gYW4gaW5wdXQgZmllbGQuICovXFxuICAgIF9jb25uZWN0RGF0ZXBpY2tlcjogZnVuY3Rpb24gX2Nvbm5lY3REYXRlcGlja2VyKHRhcmdldCwgaW5zdCkge1xcbiAgICAgIHZhciBpbnB1dCA9ICQodGFyZ2V0KTtcXG4gICAgICBpbnN0LmFwcGVuZCA9ICQoW10pO1xcbiAgICAgIGluc3QudHJpZ2dlciA9ICQoW10pO1xcblxcbiAgICAgIGlmIChpbnB1dC5oYXNDbGFzcyh0aGlzLm1hcmtlckNsYXNzTmFtZSkpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fYXR0YWNobWVudHMoaW5wdXQsIGluc3QpO1xcblxcbiAgICAgIGlucHV0LmFkZENsYXNzKHRoaXMubWFya2VyQ2xhc3NOYW1lKS5rZXlkb3duKHRoaXMuX2RvS2V5RG93bikua2V5cHJlc3ModGhpcy5fZG9LZXlQcmVzcykua2V5dXAodGhpcy5fZG9LZXlVcCk7XFxuXFxuICAgICAgdGhpcy5fYXV0b1NpemUoaW5zdCk7XFxuXFxuICAgICAgJC5kYXRhKHRhcmdldCwgXFxcImRhdGVwaWNrZXJcXFwiLCBpbnN0KTsgLy9JZiBkaXNhYmxlZCBvcHRpb24gaXMgdHJ1ZSwgZGlzYWJsZSB0aGUgZGF0ZXBpY2tlciBvbmNlIGl0IGhhcyBiZWVuIGF0dGFjaGVkIHRvIHRoZSBpbnB1dCAoc2VlIHRpY2tldCAjNTY2NSlcXG5cXG4gICAgICBpZiAoaW5zdC5zZXR0aW5ncy5kaXNhYmxlZCkge1xcbiAgICAgICAgdGhpcy5fZGlzYWJsZURhdGVwaWNrZXIodGFyZ2V0KTtcXG4gICAgICB9XFxuICAgIH0sXFxuXFxuICAgIC8qIE1ha2UgYXR0YWNobWVudHMgYmFzZWQgb24gc2V0dGluZ3MuICovXFxuICAgIF9hdHRhY2htZW50czogZnVuY3Rpb24gX2F0dGFjaG1lbnRzKGlucHV0LCBpbnN0KSB7XFxuICAgICAgdmFyIHNob3dPbixcXG4gICAgICAgICAgYnV0dG9uVGV4dCxcXG4gICAgICAgICAgYnV0dG9uSW1hZ2UsXFxuICAgICAgICAgIGFwcGVuZFRleHQgPSB0aGlzLl9nZXQoaW5zdCwgXFxcImFwcGVuZFRleHRcXFwiKSxcXG4gICAgICAgICAgaXNSVEwgPSB0aGlzLl9nZXQoaW5zdCwgXFxcImlzUlRMXFxcIik7XFxuXFxuICAgICAgaWYgKGluc3QuYXBwZW5kKSB7XFxuICAgICAgICBpbnN0LmFwcGVuZC5yZW1vdmUoKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGFwcGVuZFRleHQpIHtcXG4gICAgICAgIGluc3QuYXBwZW5kID0gJChcXFwiPHNwYW4gY2xhc3M9J1xcXCIgKyB0aGlzLl9hcHBlbmRDbGFzcyArIFxcXCInPlxcXCIgKyBhcHBlbmRUZXh0ICsgXFxcIjwvc3Bhbj5cXFwiKTtcXG4gICAgICAgIGlucHV0W2lzUlRMID8gXFxcImJlZm9yZVxcXCIgOiBcXFwiYWZ0ZXJcXFwiXShpbnN0LmFwcGVuZCk7XFxuICAgICAgfVxcblxcbiAgICAgIGlucHV0LnVuYmluZChcXFwiZm9jdXNcXFwiLCB0aGlzLl9zaG93RGF0ZXBpY2tlcik7XFxuXFxuICAgICAgaWYgKGluc3QudHJpZ2dlcikge1xcbiAgICAgICAgaW5zdC50cmlnZ2VyLnJlbW92ZSgpO1xcbiAgICAgIH1cXG5cXG4gICAgICBzaG93T24gPSB0aGlzLl9nZXQoaW5zdCwgXFxcInNob3dPblxcXCIpO1xcblxcbiAgICAgIGlmIChzaG93T24gPT09IFxcXCJmb2N1c1xcXCIgfHwgc2hvd09uID09PSBcXFwiYm90aFxcXCIpIHtcXG4gICAgICAgIC8vIHBvcC11cCBkYXRlIHBpY2tlciB3aGVuIGluIHRoZSBtYXJrZWQgZmllbGRcXG4gICAgICAgIGlucHV0LmZvY3VzKHRoaXMuX3Nob3dEYXRlcGlja2VyKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHNob3dPbiA9PT0gXFxcImJ1dHRvblxcXCIgfHwgc2hvd09uID09PSBcXFwiYm90aFxcXCIpIHtcXG4gICAgICAgIC8vIHBvcC11cCBkYXRlIHBpY2tlciB3aGVuIGJ1dHRvbiBjbGlja2VkXFxuICAgICAgICBidXR0b25UZXh0ID0gdGhpcy5fZ2V0KGluc3QsIFxcXCJidXR0b25UZXh0XFxcIik7XFxuICAgICAgICBidXR0b25JbWFnZSA9IHRoaXMuX2dldChpbnN0LCBcXFwiYnV0dG9uSW1hZ2VcXFwiKTtcXG4gICAgICAgIGluc3QudHJpZ2dlciA9ICQodGhpcy5fZ2V0KGluc3QsIFxcXCJidXR0b25JbWFnZU9ubHlcXFwiKSA/ICQoXFxcIjxpbWcvPlxcXCIpLmFkZENsYXNzKHRoaXMuX3RyaWdnZXJDbGFzcykuYXR0cih7XFxuICAgICAgICAgIHNyYzogYnV0dG9uSW1hZ2UsXFxuICAgICAgICAgIGFsdDogYnV0dG9uVGV4dCxcXG4gICAgICAgICAgdGl0bGU6IGJ1dHRvblRleHRcXG4gICAgICAgIH0pIDogJChcXFwiPGJ1dHRvbiB0eXBlPSdidXR0b24nPjwvYnV0dG9uPlxcXCIpLmFkZENsYXNzKHRoaXMuX3RyaWdnZXJDbGFzcykuaHRtbCghYnV0dG9uSW1hZ2UgPyBidXR0b25UZXh0IDogJChcXFwiPGltZy8+XFxcIikuYXR0cih7XFxuICAgICAgICAgIHNyYzogYnV0dG9uSW1hZ2UsXFxuICAgICAgICAgIGFsdDogYnV0dG9uVGV4dCxcXG4gICAgICAgICAgdGl0bGU6IGJ1dHRvblRleHRcXG4gICAgICAgIH0pKSk7XFxuICAgICAgICBpbnB1dFtpc1JUTCA/IFxcXCJiZWZvcmVcXFwiIDogXFxcImFmdGVyXFxcIl0oaW5zdC50cmlnZ2VyKTtcXG4gICAgICAgIGluc3QudHJpZ2dlci5jbGljayhmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIGlmICgkLmRhdGVwaWNrZXIuX2RhdGVwaWNrZXJTaG93aW5nICYmICQuZGF0ZXBpY2tlci5fbGFzdElucHV0ID09PSBpbnB1dFswXSkge1xcbiAgICAgICAgICAgICQuZGF0ZXBpY2tlci5faGlkZURhdGVwaWNrZXIoKTtcXG4gICAgICAgICAgfSBlbHNlIGlmICgkLmRhdGVwaWNrZXIuX2RhdGVwaWNrZXJTaG93aW5nICYmICQuZGF0ZXBpY2tlci5fbGFzdElucHV0ICE9PSBpbnB1dFswXSkge1xcbiAgICAgICAgICAgICQuZGF0ZXBpY2tlci5faGlkZURhdGVwaWNrZXIoKTtcXG5cXG4gICAgICAgICAgICAkLmRhdGVwaWNrZXIuX3Nob3dEYXRlcGlja2VyKGlucHV0WzBdKTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAkLmRhdGVwaWNrZXIuX3Nob3dEYXRlcGlja2VyKGlucHV0WzBdKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuICAgIH0sXFxuXFxuICAgIC8qIEFwcGx5IHRoZSBtYXhpbXVtIGxlbmd0aCBmb3IgdGhlIGRhdGUgZm9ybWF0LiAqL1xcbiAgICBfYXV0b1NpemU6IGZ1bmN0aW9uIF9hdXRvU2l6ZShpbnN0KSB7XFxuICAgICAgaWYgKHRoaXMuX2dldChpbnN0LCBcXFwiYXV0b1NpemVcXFwiKSAmJiAhaW5zdC5pbmxpbmUpIHtcXG4gICAgICAgIHZhciBmaW5kTWF4LFxcbiAgICAgICAgICAgIG1heCxcXG4gICAgICAgICAgICBtYXhJLFxcbiAgICAgICAgICAgIGksXFxuICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKDIwMDksIDEyIC0gMSwgMjApLFxcbiAgICAgICAgICAgIC8vIEVuc3VyZSBkb3VibGUgZGlnaXRzXFxuICAgICAgICBkYXRlRm9ybWF0ID0gdGhpcy5fZ2V0KGluc3QsIFxcXCJkYXRlRm9ybWF0XFxcIik7XFxuXFxuICAgICAgICBpZiAoZGF0ZUZvcm1hdC5tYXRjaCgvW0RNXS8pKSB7XFxuICAgICAgICAgIGZpbmRNYXggPSBmdW5jdGlvbiBmaW5kTWF4KG5hbWVzKSB7XFxuICAgICAgICAgICAgbWF4ID0gMDtcXG4gICAgICAgICAgICBtYXhJID0gMDtcXG5cXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgICAgIGlmIChuYW1lc1tpXS5sZW5ndGggPiBtYXgpIHtcXG4gICAgICAgICAgICAgICAgbWF4ID0gbmFtZXNbaV0ubGVuZ3RoO1xcbiAgICAgICAgICAgICAgICBtYXhJID0gaTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgcmV0dXJuIG1heEk7XFxuICAgICAgICAgIH07XFxuXFxuICAgICAgICAgIGRhdGUuc2V0TW9udGgoZmluZE1heCh0aGlzLl9nZXQoaW5zdCwgZGF0ZUZvcm1hdC5tYXRjaCgvTU0vKSA/IFxcXCJtb250aE5hbWVzXFxcIiA6IFxcXCJtb250aE5hbWVzU2hvcnRcXFwiKSkpO1xcbiAgICAgICAgICBkYXRlLnNldERhdGUoZmluZE1heCh0aGlzLl9nZXQoaW5zdCwgZGF0ZUZvcm1hdC5tYXRjaCgvREQvKSA/IFxcXCJkYXlOYW1lc1xcXCIgOiBcXFwiZGF5TmFtZXNTaG9ydFxcXCIpKSArIDIwIC0gZGF0ZS5nZXREYXkoKSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpbnN0LmlucHV0LmF0dHIoXFxcInNpemVcXFwiLCB0aGlzLl9mb3JtYXREYXRlKGluc3QsIGRhdGUpLmxlbmd0aCk7XFxuICAgICAgfVxcbiAgICB9LFxcblxcbiAgICAvKiBBdHRhY2ggYW4gaW5saW5lIGRhdGUgcGlja2VyIHRvIGEgZGl2LiAqL1xcbiAgICBfaW5saW5lRGF0ZXBpY2tlcjogZnVuY3Rpb24gX2lubGluZURhdGVwaWNrZXIodGFyZ2V0LCBpbnN0KSB7XFxuICAgICAgdmFyIGRpdlNwYW4gPSAkKHRhcmdldCk7XFxuXFxuICAgICAgaWYgKGRpdlNwYW4uaGFzQ2xhc3ModGhpcy5tYXJrZXJDbGFzc05hbWUpKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGRpdlNwYW4uYWRkQ2xhc3ModGhpcy5tYXJrZXJDbGFzc05hbWUpLmFwcGVuZChpbnN0LmRwRGl2KTtcXG4gICAgICAkLmRhdGEodGFyZ2V0LCBcXFwiZGF0ZXBpY2tlclxcXCIsIGluc3QpO1xcblxcbiAgICAgIHRoaXMuX3NldERhdGUoaW5zdCwgdGhpcy5fZ2V0RGVmYXVsdERhdGUoaW5zdCksIHRydWUpO1xcblxcbiAgICAgIHRoaXMuX3VwZGF0ZURhdGVwaWNrZXIoaW5zdCk7XFxuXFxuICAgICAgdGhpcy5fdXBkYXRlQWx0ZXJuYXRlKGluc3QpOyAvL0lmIGRpc2FibGVkIG9wdGlvbiBpcyB0cnVlLCBkaXNhYmxlIHRoZSBkYXRlcGlja2VyIGJlZm9yZSBzaG93aW5nIGl0IChzZWUgdGlja2V0ICM1NjY1KVxcblxcblxcbiAgICAgIGlmIChpbnN0LnNldHRpbmdzLmRpc2FibGVkKSB7XFxuICAgICAgICB0aGlzLl9kaXNhYmxlRGF0ZXBpY2tlcih0YXJnZXQpO1xcbiAgICAgIH0gLy8gU2V0IGRpc3BsYXk6YmxvY2sgaW4gcGxhY2Ugb2YgaW5zdC5kcERpdi5zaG93KCkgd2hpY2ggd29uJ3Qgd29yayBvbiBkaXNjb25uZWN0ZWQgZWxlbWVudHNcXG4gICAgICAvLyBodHRwOi8vYnVncy5qcXVlcnl1aS5jb20vdGlja2V0Lzc1NTIgLSBBIERhdGVwaWNrZXIgY3JlYXRlZCBvbiBhIGRldGFjaGVkIGRpdiBoYXMgemVybyBoZWlnaHRcXG5cXG5cXG4gICAgICBpbnN0LmRwRGl2LmNzcyhcXFwiZGlzcGxheVxcXCIsIFxcXCJibG9ja1xcXCIpO1xcbiAgICB9LFxcblxcbiAgICAvKiBQb3AtdXAgdGhlIGRhdGUgcGlja2VyIGluIGEgXFxcImRpYWxvZ1xcXCIgYm94LlxcbiAgICAgKiBAcGFyYW0gIGlucHV0IGVsZW1lbnQgLSBpZ25vcmVkXFxuICAgICAqIEBwYXJhbSAgZGF0ZVxcdHN0cmluZyBvciBEYXRlIC0gdGhlIGluaXRpYWwgZGF0ZSB0byBkaXNwbGF5XFxuICAgICAqIEBwYXJhbSAgb25TZWxlY3QgIGZ1bmN0aW9uIC0gdGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiBhIGRhdGUgaXMgc2VsZWN0ZWRcXG4gICAgICogQHBhcmFtICBzZXR0aW5ncyAgb2JqZWN0IC0gdXBkYXRlIHRoZSBkaWFsb2cgZGF0ZSBwaWNrZXIgaW5zdGFuY2UncyBzZXR0aW5ncyAoYW5vbnltb3VzIG9iamVjdClcXG4gICAgICogQHBhcmFtICBwb3MgaW50WzJdIC0gY29vcmRpbmF0ZXMgZm9yIHRoZSBkaWFsb2cncyBwb3NpdGlvbiB3aXRoaW4gdGhlIHNjcmVlbiBvclxcbiAgICAgKlxcdFxcdFxcdFxcdFxcdGV2ZW50IC0gd2l0aCB4L3kgY29vcmRpbmF0ZXMgb3JcXG4gICAgICpcXHRcXHRcXHRcXHRcXHRsZWF2ZSBlbXB0eSBmb3IgZGVmYXVsdCAoc2NyZWVuIGNlbnRyZSlcXG4gICAgICogQHJldHVybiB0aGUgbWFuYWdlciBvYmplY3RcXG4gICAgICovXFxuICAgIF9kaWFsb2dEYXRlcGlja2VyOiBmdW5jdGlvbiBfZGlhbG9nRGF0ZXBpY2tlcihpbnB1dCwgZGF0ZSwgb25TZWxlY3QsIHNldHRpbmdzLCBwb3MpIHtcXG4gICAgICB2YXIgaWQsXFxuICAgICAgICAgIGJyb3dzZXJXaWR0aCxcXG4gICAgICAgICAgYnJvd3NlckhlaWdodCxcXG4gICAgICAgICAgc2Nyb2xsWCxcXG4gICAgICAgICAgc2Nyb2xsWSxcXG4gICAgICAgICAgaW5zdCA9IHRoaXMuX2RpYWxvZ0luc3Q7IC8vIGludGVybmFsIGluc3RhbmNlXFxuXFxuICAgICAgaWYgKCFpbnN0KSB7XFxuICAgICAgICB0aGlzLnV1aWQgKz0gMTtcXG4gICAgICAgIGlkID0gXFxcImRwXFxcIiArIHRoaXMudXVpZDtcXG4gICAgICAgIHRoaXMuX2RpYWxvZ0lucHV0ID0gJChcXFwiPGlucHV0IHR5cGU9J3RleHQnIGlkPSdcXFwiICsgaWQgKyBcXFwiJyBzdHlsZT0ncG9zaXRpb246IGFic29sdXRlOyB0b3A6IC0xMDBweDsgd2lkdGg6IDBweDsnLz5cXFwiKTtcXG5cXG4gICAgICAgIHRoaXMuX2RpYWxvZ0lucHV0LmtleWRvd24odGhpcy5fZG9LZXlEb3duKTtcXG5cXG4gICAgICAgICQoXFxcImJvZHlcXFwiKS5hcHBlbmQodGhpcy5fZGlhbG9nSW5wdXQpO1xcbiAgICAgICAgaW5zdCA9IHRoaXMuX2RpYWxvZ0luc3QgPSB0aGlzLl9uZXdJbnN0KHRoaXMuX2RpYWxvZ0lucHV0LCBmYWxzZSk7XFxuICAgICAgICBpbnN0LnNldHRpbmdzID0ge307XFxuICAgICAgICAkLmRhdGEodGhpcy5fZGlhbG9nSW5wdXRbMF0sIFxcXCJkYXRlcGlja2VyXFxcIiwgaW5zdCk7XFxuICAgICAgfVxcblxcbiAgICAgIGRhdGVwaWNrZXJfZXh0ZW5kUmVtb3ZlKGluc3Quc2V0dGluZ3MsIHNldHRpbmdzIHx8IHt9KTtcXG4gICAgICBkYXRlID0gZGF0ZSAmJiBkYXRlLmNvbnN0cnVjdG9yID09PSBEYXRlID8gdGhpcy5fZm9ybWF0RGF0ZShpbnN0LCBkYXRlKSA6IGRhdGU7XFxuXFxuICAgICAgdGhpcy5fZGlhbG9nSW5wdXQudmFsKGRhdGUpO1xcblxcbiAgICAgIHRoaXMuX3BvcyA9IHBvcyA/IHBvcy5sZW5ndGggPyBwb3MgOiBbcG9zLnBhZ2VYLCBwb3MucGFnZVldIDogbnVsbDtcXG5cXG4gICAgICBpZiAoIXRoaXMuX3Bvcykge1xcbiAgICAgICAgYnJvd3NlcldpZHRoID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO1xcbiAgICAgICAgYnJvd3NlckhlaWdodCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7XFxuICAgICAgICBzY3JvbGxYID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0O1xcbiAgICAgICAgc2Nyb2xsWSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3A7XFxuICAgICAgICB0aGlzLl9wb3MgPSAvLyBzaG91bGQgdXNlIGFjdHVhbCB3aWR0aC9oZWlnaHQgYmVsb3dcXG4gICAgICAgIFticm93c2VyV2lkdGggLyAyIC0gMTAwICsgc2Nyb2xsWCwgYnJvd3NlckhlaWdodCAvIDIgLSAxNTAgKyBzY3JvbGxZXTtcXG4gICAgICB9IC8vIG1vdmUgaW5wdXQgb24gc2NyZWVuIGZvciBmb2N1cywgYnV0IGhpZGRlbiBiZWhpbmQgZGlhbG9nXFxuXFxuXFxuICAgICAgdGhpcy5fZGlhbG9nSW5wdXQuY3NzKFxcXCJsZWZ0XFxcIiwgdGhpcy5fcG9zWzBdICsgMjAgKyBcXFwicHhcXFwiKS5jc3MoXFxcInRvcFxcXCIsIHRoaXMuX3Bvc1sxXSArIFxcXCJweFxcXCIpO1xcblxcbiAgICAgIGluc3Quc2V0dGluZ3Mub25TZWxlY3QgPSBvblNlbGVjdDtcXG4gICAgICB0aGlzLl9pbkRpYWxvZyA9IHRydWU7XFxuICAgICAgdGhpcy5kcERpdi5hZGRDbGFzcyh0aGlzLl9kaWFsb2dDbGFzcyk7XFxuXFxuICAgICAgdGhpcy5fc2hvd0RhdGVwaWNrZXIodGhpcy5fZGlhbG9nSW5wdXRbMF0pO1xcblxcbiAgICAgIGlmICgkLmJsb2NrVUkpIHtcXG4gICAgICAgICQuYmxvY2tVSSh0aGlzLmRwRGl2KTtcXG4gICAgICB9XFxuXFxuICAgICAgJC5kYXRhKHRoaXMuX2RpYWxvZ0lucHV0WzBdLCBcXFwiZGF0ZXBpY2tlclxcXCIsIGluc3QpO1xcbiAgICAgIHJldHVybiB0aGlzO1xcbiAgICB9LFxcblxcbiAgICAvKiBEZXRhY2ggYSBkYXRlcGlja2VyIGZyb20gaXRzIGNvbnRyb2wuXFxuICAgICAqIEBwYXJhbSAgdGFyZ2V0XFx0ZWxlbWVudCAtIHRoZSB0YXJnZXQgaW5wdXQgZmllbGQgb3IgZGl2aXNpb24gb3Igc3BhblxcbiAgICAgKi9cXG4gICAgX2Rlc3Ryb3lEYXRlcGlja2VyOiBmdW5jdGlvbiBfZGVzdHJveURhdGVwaWNrZXIodGFyZ2V0KSB7XFxuICAgICAgdmFyIG5vZGVOYW1lLFxcbiAgICAgICAgICAkdGFyZ2V0ID0gJCh0YXJnZXQpLFxcbiAgICAgICAgICBpbnN0ID0gJC5kYXRhKHRhcmdldCwgXFxcImRhdGVwaWNrZXJcXFwiKTtcXG5cXG4gICAgICBpZiAoISR0YXJnZXQuaGFzQ2xhc3ModGhpcy5tYXJrZXJDbGFzc05hbWUpKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIG5vZGVOYW1lID0gdGFyZ2V0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XFxuICAgICAgJC5yZW1vdmVEYXRhKHRhcmdldCwgXFxcImRhdGVwaWNrZXJcXFwiKTtcXG5cXG4gICAgICBpZiAobm9kZU5hbWUgPT09IFxcXCJpbnB1dFxcXCIpIHtcXG4gICAgICAgIGluc3QuYXBwZW5kLnJlbW92ZSgpO1xcbiAgICAgICAgaW5zdC50cmlnZ2VyLnJlbW92ZSgpO1xcbiAgICAgICAgJHRhcmdldC5yZW1vdmVDbGFzcyh0aGlzLm1hcmtlckNsYXNzTmFtZSkudW5iaW5kKFxcXCJmb2N1c1xcXCIsIHRoaXMuX3Nob3dEYXRlcGlja2VyKS51bmJpbmQoXFxcImtleWRvd25cXFwiLCB0aGlzLl9kb0tleURvd24pLnVuYmluZChcXFwia2V5cHJlc3NcXFwiLCB0aGlzLl9kb0tleVByZXNzKS51bmJpbmQoXFxcImtleXVwXFxcIiwgdGhpcy5fZG9LZXlVcCk7XFxuICAgICAgfSBlbHNlIGlmIChub2RlTmFtZSA9PT0gXFxcImRpdlxcXCIgfHwgbm9kZU5hbWUgPT09IFxcXCJzcGFuXFxcIikge1xcbiAgICAgICAgJHRhcmdldC5yZW1vdmVDbGFzcyh0aGlzLm1hcmtlckNsYXNzTmFtZSkuZW1wdHkoKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGRhdGVwaWNrZXJfaW5zdEFjdGl2ZSA9PT0gaW5zdCkge1xcbiAgICAgICAgZGF0ZXBpY2tlcl9pbnN0QWN0aXZlID0gbnVsbDtcXG4gICAgICB9XFxuICAgIH0sXFxuXFxuICAgIC8qIEVuYWJsZSB0aGUgZGF0ZSBwaWNrZXIgdG8gYSBqUXVlcnkgc2VsZWN0aW9uLlxcbiAgICAgKiBAcGFyYW0gIHRhcmdldFxcdGVsZW1lbnQgLSB0aGUgdGFyZ2V0IGlucHV0IGZpZWxkIG9yIGRpdmlzaW9uIG9yIHNwYW5cXG4gICAgICovXFxuICAgIF9lbmFibGVEYXRlcGlja2VyOiBmdW5jdGlvbiBfZW5hYmxlRGF0ZXBpY2tlcih0YXJnZXQpIHtcXG4gICAgICB2YXIgbm9kZU5hbWUsXFxuICAgICAgICAgIGlubGluZSxcXG4gICAgICAgICAgJHRhcmdldCA9ICQodGFyZ2V0KSxcXG4gICAgICAgICAgaW5zdCA9ICQuZGF0YSh0YXJnZXQsIFxcXCJkYXRlcGlja2VyXFxcIik7XFxuXFxuICAgICAgaWYgKCEkdGFyZ2V0Lmhhc0NsYXNzKHRoaXMubWFya2VyQ2xhc3NOYW1lKSkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBub2RlTmFtZSA9IHRhcmdldC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xcblxcbiAgICAgIGlmIChub2RlTmFtZSA9PT0gXFxcImlucHV0XFxcIikge1xcbiAgICAgICAgdGFyZ2V0LmRpc2FibGVkID0gZmFsc2U7XFxuICAgICAgICBpbnN0LnRyaWdnZXIuZmlsdGVyKFxcXCJidXR0b25cXFwiKS5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGZhbHNlO1xcbiAgICAgICAgfSkuZW5kKCkuZmlsdGVyKFxcXCJpbWdcXFwiKS5jc3Moe1xcbiAgICAgICAgICBvcGFjaXR5OiBcXFwiMS4wXFxcIixcXG4gICAgICAgICAgY3Vyc29yOiBcXFwiXFxcIlxcbiAgICAgICAgfSk7XFxuICAgICAgfSBlbHNlIGlmIChub2RlTmFtZSA9PT0gXFxcImRpdlxcXCIgfHwgbm9kZU5hbWUgPT09IFxcXCJzcGFuXFxcIikge1xcbiAgICAgICAgaW5saW5lID0gJHRhcmdldC5jaGlsZHJlbihcXFwiLlxcXCIgKyB0aGlzLl9pbmxpbmVDbGFzcyk7XFxuICAgICAgICBpbmxpbmUuY2hpbGRyZW4oKS5yZW1vdmVDbGFzcyhcXFwidWktc3RhdGUtZGlzYWJsZWRcXFwiKTtcXG4gICAgICAgIGlubGluZS5maW5kKFxcXCJzZWxlY3QudWktZGF0ZXBpY2tlci1tb250aCwgc2VsZWN0LnVpLWRhdGVwaWNrZXIteWVhclxcXCIpLnByb3AoXFxcImRpc2FibGVkXFxcIiwgZmFsc2UpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9kaXNhYmxlZElucHV0cyA9ICQubWFwKHRoaXMuX2Rpc2FibGVkSW5wdXRzLCBmdW5jdGlvbiAodmFsdWUpIHtcXG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdGFyZ2V0ID8gbnVsbCA6IHZhbHVlO1xcbiAgICAgIH0pOyAvLyBkZWxldGUgZW50cnlcXG4gICAgfSxcXG5cXG4gICAgLyogRGlzYWJsZSB0aGUgZGF0ZSBwaWNrZXIgdG8gYSBqUXVlcnkgc2VsZWN0aW9uLlxcbiAgICAgKiBAcGFyYW0gIHRhcmdldFxcdGVsZW1lbnQgLSB0aGUgdGFyZ2V0IGlucHV0IGZpZWxkIG9yIGRpdmlzaW9uIG9yIHNwYW5cXG4gICAgICovXFxuICAgIF9kaXNhYmxlRGF0ZXBpY2tlcjogZnVuY3Rpb24gX2Rpc2FibGVEYXRlcGlja2VyKHRhcmdldCkge1xcbiAgICAgIHZhciBub2RlTmFtZSxcXG4gICAgICAgICAgaW5saW5lLFxcbiAgICAgICAgICAkdGFyZ2V0ID0gJCh0YXJnZXQpLFxcbiAgICAgICAgICBpbnN0ID0gJC5kYXRhKHRhcmdldCwgXFxcImRhdGVwaWNrZXJcXFwiKTtcXG5cXG4gICAgICBpZiAoISR0YXJnZXQuaGFzQ2xhc3ModGhpcy5tYXJrZXJDbGFzc05hbWUpKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIG5vZGVOYW1lID0gdGFyZ2V0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XFxuXFxuICAgICAgaWYgKG5vZGVOYW1lID09PSBcXFwiaW5wdXRcXFwiKSB7XFxuICAgICAgICB0YXJnZXQuZGlzYWJsZWQgPSB0cnVlO1xcbiAgICAgICAgaW5zdC50cmlnZ2VyLmZpbHRlcihcXFwiYnV0dG9uXFxcIikuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHRoaXMuZGlzYWJsZWQgPSB0cnVlO1xcbiAgICAgICAgfSkuZW5kKCkuZmlsdGVyKFxcXCJpbWdcXFwiKS5jc3Moe1xcbiAgICAgICAgICBvcGFjaXR5OiBcXFwiMC41XFxcIixcXG4gICAgICAgICAgY3Vyc29yOiBcXFwiZGVmYXVsdFxcXCJcXG4gICAgICAgIH0pO1xcbiAgICAgIH0gZWxzZSBpZiAobm9kZU5hbWUgPT09IFxcXCJkaXZcXFwiIHx8IG5vZGVOYW1lID09PSBcXFwic3BhblxcXCIpIHtcXG4gICAgICAgIGlubGluZSA9ICR0YXJnZXQuY2hpbGRyZW4oXFxcIi5cXFwiICsgdGhpcy5faW5saW5lQ2xhc3MpO1xcbiAgICAgICAgaW5saW5lLmNoaWxkcmVuKCkuYWRkQ2xhc3MoXFxcInVpLXN0YXRlLWRpc2FibGVkXFxcIik7XFxuICAgICAgICBpbmxpbmUuZmluZChcXFwic2VsZWN0LnVpLWRhdGVwaWNrZXItbW9udGgsIHNlbGVjdC51aS1kYXRlcGlja2VyLXllYXJcXFwiKS5wcm9wKFxcXCJkaXNhYmxlZFxcXCIsIHRydWUpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9kaXNhYmxlZElucHV0cyA9ICQubWFwKHRoaXMuX2Rpc2FibGVkSW5wdXRzLCBmdW5jdGlvbiAodmFsdWUpIHtcXG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdGFyZ2V0ID8gbnVsbCA6IHZhbHVlO1xcbiAgICAgIH0pOyAvLyBkZWxldGUgZW50cnlcXG5cXG4gICAgICB0aGlzLl9kaXNhYmxlZElucHV0c1t0aGlzLl9kaXNhYmxlZElucHV0cy5sZW5ndGhdID0gdGFyZ2V0O1xcbiAgICB9LFxcblxcbiAgICAvKiBJcyB0aGUgZmlyc3QgZmllbGQgaW4gYSBqUXVlcnkgY29sbGVjdGlvbiBkaXNhYmxlZCBhcyBhIGRhdGVwaWNrZXI/XFxuICAgICAqIEBwYXJhbSAgdGFyZ2V0XFx0ZWxlbWVudCAtIHRoZSB0YXJnZXQgaW5wdXQgZmllbGQgb3IgZGl2aXNpb24gb3Igc3BhblxcbiAgICAgKiBAcmV0dXJuIGJvb2xlYW4gLSB0cnVlIGlmIGRpc2FibGVkLCBmYWxzZSBpZiBlbmFibGVkXFxuICAgICAqL1xcbiAgICBfaXNEaXNhYmxlZERhdGVwaWNrZXI6IGZ1bmN0aW9uIF9pc0Rpc2FibGVkRGF0ZXBpY2tlcih0YXJnZXQpIHtcXG4gICAgICBpZiAoIXRhcmdldCkge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2Rpc2FibGVkSW5wdXRzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICBpZiAodGhpcy5fZGlzYWJsZWRJbnB1dHNbaV0gPT09IHRhcmdldCkge1xcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9LFxcblxcbiAgICAvKiBSZXRyaWV2ZSB0aGUgaW5zdGFuY2UgZGF0YSBmb3IgdGhlIHRhcmdldCBjb250cm9sLlxcbiAgICAgKiBAcGFyYW0gIHRhcmdldCAgZWxlbWVudCAtIHRoZSB0YXJnZXQgaW5wdXQgZmllbGQgb3IgZGl2aXNpb24gb3Igc3BhblxcbiAgICAgKiBAcmV0dXJuICBvYmplY3QgLSB0aGUgYXNzb2NpYXRlZCBpbnN0YW5jZSBkYXRhXFxuICAgICAqIEB0aHJvd3MgIGVycm9yIGlmIGEgalF1ZXJ5IHByb2JsZW0gZ2V0dGluZyBkYXRhXFxuICAgICAqL1xcbiAgICBfZ2V0SW5zdDogZnVuY3Rpb24gX2dldEluc3QodGFyZ2V0KSB7XFxuICAgICAgdHJ5IHtcXG4gICAgICAgIHJldHVybiAkLmRhdGEodGFyZ2V0LCBcXFwiZGF0ZXBpY2tlclxcXCIpO1xcbiAgICAgIH0gY2F0Y2ggKGVycikge1xcbiAgICAgICAgdGhyb3cgXFxcIk1pc3NpbmcgaW5zdGFuY2UgZGF0YSBmb3IgdGhpcyBkYXRlcGlja2VyXFxcIjtcXG4gICAgICB9XFxuICAgIH0sXFxuXFxuICAgIC8qIFVwZGF0ZSBvciByZXRyaWV2ZSB0aGUgc2V0dGluZ3MgZm9yIGEgZGF0ZSBwaWNrZXIgYXR0YWNoZWQgdG8gYW4gaW5wdXQgZmllbGQgb3IgZGl2aXNpb24uXFxuICAgICAqIEBwYXJhbSAgdGFyZ2V0ICBlbGVtZW50IC0gdGhlIHRhcmdldCBpbnB1dCBmaWVsZCBvciBkaXZpc2lvbiBvciBzcGFuXFxuICAgICAqIEBwYXJhbSAgbmFtZVxcdG9iamVjdCAtIHRoZSBuZXcgc2V0dGluZ3MgdG8gdXBkYXRlIG9yXFxuICAgICAqXFx0XFx0XFx0XFx0c3RyaW5nIC0gdGhlIG5hbWUgb2YgdGhlIHNldHRpbmcgdG8gY2hhbmdlIG9yIHJldHJpZXZlLFxcbiAgICAgKlxcdFxcdFxcdFxcdHdoZW4gcmV0cmlldmluZyBhbHNvIFxcXCJhbGxcXFwiIGZvciBhbGwgaW5zdGFuY2Ugc2V0dGluZ3Mgb3JcXG4gICAgICpcXHRcXHRcXHRcXHRcXFwiZGVmYXVsdHNcXFwiIGZvciBhbGwgZ2xvYmFsIGRlZmF1bHRzXFxuICAgICAqIEBwYXJhbSAgdmFsdWUgICBhbnkgLSB0aGUgbmV3IHZhbHVlIGZvciB0aGUgc2V0dGluZ1xcbiAgICAgKlxcdFxcdFxcdFxcdChvbWl0IGlmIGFib3ZlIGlzIGFuIG9iamVjdCBvciB0byByZXRyaWV2ZSBhIHZhbHVlKVxcbiAgICAgKi9cXG4gICAgX29wdGlvbkRhdGVwaWNrZXI6IGZ1bmN0aW9uIF9vcHRpb25EYXRlcGlja2VyKHRhcmdldCwgbmFtZSwgdmFsdWUpIHtcXG4gICAgICB2YXIgc2V0dGluZ3MsXFxuICAgICAgICAgIGRhdGUsXFxuICAgICAgICAgIG1pbkRhdGUsXFxuICAgICAgICAgIG1heERhdGUsXFxuICAgICAgICAgIGluc3QgPSB0aGlzLl9nZXRJbnN0KHRhcmdldCk7XFxuXFxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgdHlwZW9mIG5hbWUgPT09IFxcXCJzdHJpbmdcXFwiKSB7XFxuICAgICAgICByZXR1cm4gbmFtZSA9PT0gXFxcImRlZmF1bHRzXFxcIiA/ICQuZXh0ZW5kKHt9LCAkLmRhdGVwaWNrZXIuX2RlZmF1bHRzKSA6IGluc3QgPyBuYW1lID09PSBcXFwiYWxsXFxcIiA/ICQuZXh0ZW5kKHt9LCBpbnN0LnNldHRpbmdzKSA6IHRoaXMuX2dldChpbnN0LCBuYW1lKSA6IG51bGw7XFxuICAgICAgfVxcblxcbiAgICAgIHNldHRpbmdzID0gbmFtZSB8fCB7fTtcXG5cXG4gICAgICBpZiAodHlwZW9mIG5hbWUgPT09IFxcXCJzdHJpbmdcXFwiKSB7XFxuICAgICAgICBzZXR0aW5ncyA9IHt9O1xcbiAgICAgICAgc2V0dGluZ3NbbmFtZV0gPSB2YWx1ZTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGluc3QpIHtcXG4gICAgICAgIGlmICh0aGlzLl9jdXJJbnN0ID09PSBpbnN0KSB7XFxuICAgICAgICAgIHRoaXMuX2hpZGVEYXRlcGlja2VyKCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBkYXRlID0gdGhpcy5fZ2V0RGF0ZURhdGVwaWNrZXIodGFyZ2V0LCB0cnVlKTtcXG4gICAgICAgIG1pbkRhdGUgPSB0aGlzLl9nZXRNaW5NYXhEYXRlKGluc3QsIFxcXCJtaW5cXFwiKTtcXG4gICAgICAgIG1heERhdGUgPSB0aGlzLl9nZXRNaW5NYXhEYXRlKGluc3QsIFxcXCJtYXhcXFwiKTtcXG4gICAgICAgIGRhdGVwaWNrZXJfZXh0ZW5kUmVtb3ZlKGluc3Quc2V0dGluZ3MsIHNldHRpbmdzKTsgLy8gcmVmb3JtYXQgdGhlIG9sZCBtaW5EYXRlL21heERhdGUgdmFsdWVzIGlmIGRhdGVGb3JtYXQgY2hhbmdlcyBhbmQgYSBuZXcgbWluRGF0ZS9tYXhEYXRlIGlzbid0IHByb3ZpZGVkXFxuXFxuICAgICAgICBpZiAobWluRGF0ZSAhPT0gbnVsbCAmJiBzZXR0aW5ncy5kYXRlRm9ybWF0ICE9PSB1bmRlZmluZWQgJiYgc2V0dGluZ3MubWluRGF0ZSA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgIGluc3Quc2V0dGluZ3MubWluRGF0ZSA9IHRoaXMuX2Zvcm1hdERhdGUoaW5zdCwgbWluRGF0ZSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAobWF4RGF0ZSAhPT0gbnVsbCAmJiBzZXR0aW5ncy5kYXRlRm9ybWF0ICE9PSB1bmRlZmluZWQgJiYgc2V0dGluZ3MubWF4RGF0ZSA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgIGluc3Quc2V0dGluZ3MubWF4RGF0ZSA9IHRoaXMuX2Zvcm1hdERhdGUoaW5zdCwgbWF4RGF0ZSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoXFxcImRpc2FibGVkXFxcIiBpbiBzZXR0aW5ncykge1xcbiAgICAgICAgICBpZiAoc2V0dGluZ3MuZGlzYWJsZWQpIHtcXG4gICAgICAgICAgICB0aGlzLl9kaXNhYmxlRGF0ZXBpY2tlcih0YXJnZXQpO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHRoaXMuX2VuYWJsZURhdGVwaWNrZXIodGFyZ2V0KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgdGhpcy5fYXR0YWNobWVudHMoJCh0YXJnZXQpLCBpbnN0KTtcXG5cXG4gICAgICAgIHRoaXMuX2F1dG9TaXplKGluc3QpO1xcblxcbiAgICAgICAgdGhpcy5fc2V0RGF0ZShpbnN0LCBkYXRlKTtcXG5cXG4gICAgICAgIHRoaXMuX3VwZGF0ZUFsdGVybmF0ZShpbnN0KTtcXG5cXG4gICAgICAgIHRoaXMuX3VwZGF0ZURhdGVwaWNrZXIoaW5zdCk7XFxuICAgICAgfVxcbiAgICB9LFxcbiAgICAvLyBjaGFuZ2UgbWV0aG9kIGRlcHJlY2F0ZWRcXG4gICAgX2NoYW5nZURhdGVwaWNrZXI6IGZ1bmN0aW9uIF9jaGFuZ2VEYXRlcGlja2VyKHRhcmdldCwgbmFtZSwgdmFsdWUpIHtcXG4gICAgICB0aGlzLl9vcHRpb25EYXRlcGlja2VyKHRhcmdldCwgbmFtZSwgdmFsdWUpO1xcbiAgICB9LFxcblxcbiAgICAvKiBSZWRyYXcgdGhlIGRhdGUgcGlja2VyIGF0dGFjaGVkIHRvIGFuIGlucHV0IGZpZWxkIG9yIGRpdmlzaW9uLlxcbiAgICAgKiBAcGFyYW0gIHRhcmdldCAgZWxlbWVudCAtIHRoZSB0YXJnZXQgaW5wdXQgZmllbGQgb3IgZGl2aXNpb24gb3Igc3BhblxcbiAgICAgKi9cXG4gICAgX3JlZnJlc2hEYXRlcGlja2VyOiBmdW5jdGlvbiBfcmVmcmVzaERhdGVwaWNrZXIodGFyZ2V0KSB7XFxuICAgICAgdmFyIGluc3QgPSB0aGlzLl9nZXRJbnN0KHRhcmdldCk7XFxuXFxuICAgICAgaWYgKGluc3QpIHtcXG4gICAgICAgIHRoaXMuX3VwZGF0ZURhdGVwaWNrZXIoaW5zdCk7XFxuICAgICAgfVxcbiAgICB9LFxcblxcbiAgICAvKiBTZXQgdGhlIGRhdGVzIGZvciBhIGpRdWVyeSBzZWxlY3Rpb24uXFxuICAgICAqIEBwYXJhbSAgdGFyZ2V0IGVsZW1lbnQgLSB0aGUgdGFyZ2V0IGlucHV0IGZpZWxkIG9yIGRpdmlzaW9uIG9yIHNwYW5cXG4gICAgICogQHBhcmFtICBkYXRlXFx0RGF0ZSAtIHRoZSBuZXcgZGF0ZVxcbiAgICAgKi9cXG4gICAgX3NldERhdGVEYXRlcGlja2VyOiBmdW5jdGlvbiBfc2V0RGF0ZURhdGVwaWNrZXIodGFyZ2V0LCBkYXRlKSB7XFxuICAgICAgdmFyIGluc3QgPSB0aGlzLl9nZXRJbnN0KHRhcmdldCk7XFxuXFxuICAgICAgaWYgKGluc3QpIHtcXG4gICAgICAgIHRoaXMuX3NldERhdGUoaW5zdCwgZGF0ZSk7XFxuXFxuICAgICAgICB0aGlzLl91cGRhdGVEYXRlcGlja2VyKGluc3QpO1xcblxcbiAgICAgICAgdGhpcy5fdXBkYXRlQWx0ZXJuYXRlKGluc3QpO1xcbiAgICAgIH1cXG4gICAgfSxcXG5cXG4gICAgLyogR2V0IHRoZSBkYXRlKHMpIGZvciB0aGUgZmlyc3QgZW50cnkgaW4gYSBqUXVlcnkgc2VsZWN0aW9uLlxcbiAgICAgKiBAcGFyYW0gIHRhcmdldCBlbGVtZW50IC0gdGhlIHRhcmdldCBpbnB1dCBmaWVsZCBvciBkaXZpc2lvbiBvciBzcGFuXFxuICAgICAqIEBwYXJhbSAgbm9EZWZhdWx0IGJvb2xlYW4gLSB0cnVlIGlmIG5vIGRlZmF1bHQgZGF0ZSBpcyB0byBiZSB1c2VkXFxuICAgICAqIEByZXR1cm4gRGF0ZSAtIHRoZSBjdXJyZW50IGRhdGVcXG4gICAgICovXFxuICAgIF9nZXREYXRlRGF0ZXBpY2tlcjogZnVuY3Rpb24gX2dldERhdGVEYXRlcGlja2VyKHRhcmdldCwgbm9EZWZhdWx0KSB7XFxuICAgICAgdmFyIGluc3QgPSB0aGlzLl9nZXRJbnN0KHRhcmdldCk7XFxuXFxuICAgICAgaWYgKGluc3QgJiYgIWluc3QuaW5saW5lKSB7XFxuICAgICAgICB0aGlzLl9zZXREYXRlRnJvbUZpZWxkKGluc3QsIG5vRGVmYXVsdCk7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBpbnN0ID8gdGhpcy5fZ2V0RGF0ZShpbnN0KSA6IG51bGw7XFxuICAgIH0sXFxuXFxuICAgIC8qIEhhbmRsZSBrZXlzdHJva2VzLiAqL1xcbiAgICBfZG9LZXlEb3duOiBmdW5jdGlvbiBfZG9LZXlEb3duKGV2ZW50KSB7XFxuICAgICAgdmFyIG9uU2VsZWN0LFxcbiAgICAgICAgICBkYXRlU3RyLFxcbiAgICAgICAgICBzZWwsXFxuICAgICAgICAgIGluc3QgPSAkLmRhdGVwaWNrZXIuX2dldEluc3QoZXZlbnQudGFyZ2V0KSxcXG4gICAgICAgICAgaGFuZGxlZCA9IHRydWUsXFxuICAgICAgICAgIGlzUlRMID0gaW5zdC5kcERpdi5pcyhcXFwiLnVpLWRhdGVwaWNrZXItcnRsXFxcIik7XFxuXFxuICAgICAgaW5zdC5fa2V5RXZlbnQgPSB0cnVlO1xcblxcbiAgICAgIGlmICgkLmRhdGVwaWNrZXIuX2RhdGVwaWNrZXJTaG93aW5nKSB7XFxuICAgICAgICBzd2l0Y2ggKGV2ZW50LmtleUNvZGUpIHtcXG4gICAgICAgICAgY2FzZSA5OlxcbiAgICAgICAgICAgICQuZGF0ZXBpY2tlci5faGlkZURhdGVwaWNrZXIoKTtcXG5cXG4gICAgICAgICAgICBoYW5kbGVkID0gZmFsc2U7XFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgIC8vIGhpZGUgb24gdGFiIG91dFxcblxcbiAgICAgICAgICBjYXNlIDEzOlxcbiAgICAgICAgICAgIHNlbCA9ICQoXFxcInRkLlxcXCIgKyAkLmRhdGVwaWNrZXIuX2RheU92ZXJDbGFzcyArIFxcXCI6bm90KC5cXFwiICsgJC5kYXRlcGlja2VyLl9jdXJyZW50Q2xhc3MgKyBcXFwiKVxcXCIsIGluc3QuZHBEaXYpO1xcblxcbiAgICAgICAgICAgIGlmIChzZWxbMF0pIHtcXG4gICAgICAgICAgICAgICQuZGF0ZXBpY2tlci5fc2VsZWN0RGF5KGV2ZW50LnRhcmdldCwgaW5zdC5zZWxlY3RlZE1vbnRoLCBpbnN0LnNlbGVjdGVkWWVhciwgc2VsWzBdKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgb25TZWxlY3QgPSAkLmRhdGVwaWNrZXIuX2dldChpbnN0LCBcXFwib25TZWxlY3RcXFwiKTtcXG5cXG4gICAgICAgICAgICBpZiAob25TZWxlY3QpIHtcXG4gICAgICAgICAgICAgIGRhdGVTdHIgPSAkLmRhdGVwaWNrZXIuX2Zvcm1hdERhdGUoaW5zdCk7IC8vIHRyaWdnZXIgY3VzdG9tIGNhbGxiYWNrXFxuXFxuICAgICAgICAgICAgICBvblNlbGVjdC5hcHBseShpbnN0LmlucHV0ID8gaW5zdC5pbnB1dFswXSA6IG51bGwsIFtkYXRlU3RyLCBpbnN0XSk7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICQuZGF0ZXBpY2tlci5faGlkZURhdGVwaWNrZXIoKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgICAvLyBkb24ndCBzdWJtaXQgdGhlIGZvcm1cXG5cXG4gICAgICAgICAgY2FzZSAyNzpcXG4gICAgICAgICAgICAkLmRhdGVwaWNrZXIuX2hpZGVEYXRlcGlja2VyKCk7XFxuXFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgIC8vIGhpZGUgb24gZXNjYXBlXFxuXFxuICAgICAgICAgIGNhc2UgMzM6XFxuICAgICAgICAgICAgJC5kYXRlcGlja2VyLl9hZGp1c3REYXRlKGV2ZW50LnRhcmdldCwgZXZlbnQuY3RybEtleSA/IC0kLmRhdGVwaWNrZXIuX2dldChpbnN0LCBcXFwic3RlcEJpZ01vbnRoc1xcXCIpIDogLSQuZGF0ZXBpY2tlci5fZ2V0KGluc3QsIFxcXCJzdGVwTW9udGhzXFxcIiksIFxcXCJNXFxcIik7XFxuXFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgIC8vIHByZXZpb3VzIG1vbnRoL3llYXIgb24gcGFnZSB1cC8rIGN0cmxcXG5cXG4gICAgICAgICAgY2FzZSAzNDpcXG4gICAgICAgICAgICAkLmRhdGVwaWNrZXIuX2FkanVzdERhdGUoZXZlbnQudGFyZ2V0LCBldmVudC5jdHJsS2V5ID8gKyQuZGF0ZXBpY2tlci5fZ2V0KGluc3QsIFxcXCJzdGVwQmlnTW9udGhzXFxcIikgOiArJC5kYXRlcGlja2VyLl9nZXQoaW5zdCwgXFxcInN0ZXBNb250aHNcXFwiKSwgXFxcIk1cXFwiKTtcXG5cXG4gICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgLy8gbmV4dCBtb250aC95ZWFyIG9uIHBhZ2UgZG93bi8rIGN0cmxcXG5cXG4gICAgICAgICAgY2FzZSAzNTpcXG4gICAgICAgICAgICBpZiAoZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5KSB7XFxuICAgICAgICAgICAgICAkLmRhdGVwaWNrZXIuX2NsZWFyRGF0ZShldmVudC50YXJnZXQpO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBoYW5kbGVkID0gZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5O1xcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAvLyBjbGVhciBvbiBjdHJsIG9yIGNvbW1hbmQgK2VuZFxcblxcbiAgICAgICAgICBjYXNlIDM2OlxcbiAgICAgICAgICAgIGlmIChldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkpIHtcXG4gICAgICAgICAgICAgICQuZGF0ZXBpY2tlci5fZ290b1RvZGF5KGV2ZW50LnRhcmdldCk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGhhbmRsZWQgPSBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXk7XFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgIC8vIGN1cnJlbnQgb24gY3RybCBvciBjb21tYW5kICtob21lXFxuXFxuICAgICAgICAgIGNhc2UgMzc6XFxuICAgICAgICAgICAgaWYgKGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSkge1xcbiAgICAgICAgICAgICAgJC5kYXRlcGlja2VyLl9hZGp1c3REYXRlKGV2ZW50LnRhcmdldCwgaXNSVEwgPyArMSA6IC0xLCBcXFwiRFxcXCIpO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBoYW5kbGVkID0gZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5OyAvLyAtMSBkYXkgb24gY3RybCBvciBjb21tYW5kICtsZWZ0XFxuXFxuICAgICAgICAgICAgaWYgKGV2ZW50Lm9yaWdpbmFsRXZlbnQuYWx0S2V5KSB7XFxuICAgICAgICAgICAgICAkLmRhdGVwaWNrZXIuX2FkanVzdERhdGUoZXZlbnQudGFyZ2V0LCBldmVudC5jdHJsS2V5ID8gLSQuZGF0ZXBpY2tlci5fZ2V0KGluc3QsIFxcXCJzdGVwQmlnTW9udGhzXFxcIikgOiAtJC5kYXRlcGlja2VyLl9nZXQoaW5zdCwgXFxcInN0ZXBNb250aHNcXFwiKSwgXFxcIk1cXFwiKTtcXG4gICAgICAgICAgICB9IC8vIG5leHQgbW9udGgveWVhciBvbiBhbHQgK2xlZnQgb24gTWFjXFxuXFxuXFxuICAgICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICAgIGNhc2UgMzg6XFxuICAgICAgICAgICAgaWYgKGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSkge1xcbiAgICAgICAgICAgICAgJC5kYXRlcGlja2VyLl9hZGp1c3REYXRlKGV2ZW50LnRhcmdldCwgLTcsIFxcXCJEXFxcIik7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGhhbmRsZWQgPSBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXk7XFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgIC8vIC0xIHdlZWsgb24gY3RybCBvciBjb21tYW5kICt1cFxcblxcbiAgICAgICAgICBjYXNlIDM5OlxcbiAgICAgICAgICAgIGlmIChldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkpIHtcXG4gICAgICAgICAgICAgICQuZGF0ZXBpY2tlci5fYWRqdXN0RGF0ZShldmVudC50YXJnZXQsIGlzUlRMID8gLTEgOiArMSwgXFxcIkRcXFwiKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaGFuZGxlZCA9IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleTsgLy8gKzEgZGF5IG9uIGN0cmwgb3IgY29tbWFuZCArcmlnaHRcXG5cXG4gICAgICAgICAgICBpZiAoZXZlbnQub3JpZ2luYWxFdmVudC5hbHRLZXkpIHtcXG4gICAgICAgICAgICAgICQuZGF0ZXBpY2tlci5fYWRqdXN0RGF0ZShldmVudC50YXJnZXQsIGV2ZW50LmN0cmxLZXkgPyArJC5kYXRlcGlja2VyLl9nZXQoaW5zdCwgXFxcInN0ZXBCaWdNb250aHNcXFwiKSA6ICskLmRhdGVwaWNrZXIuX2dldChpbnN0LCBcXFwic3RlcE1vbnRoc1xcXCIpLCBcXFwiTVxcXCIpO1xcbiAgICAgICAgICAgIH0gLy8gbmV4dCBtb250aC95ZWFyIG9uIGFsdCArcmlnaHRcXG5cXG5cXG4gICAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgICAgY2FzZSA0MDpcXG4gICAgICAgICAgICBpZiAoZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5KSB7XFxuICAgICAgICAgICAgICAkLmRhdGVwaWNrZXIuX2FkanVzdERhdGUoZXZlbnQudGFyZ2V0LCArNywgXFxcIkRcXFwiKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaGFuZGxlZCA9IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleTtcXG4gICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgLy8gKzEgd2VlayBvbiBjdHJsIG9yIGNvbW1hbmQgK2Rvd25cXG5cXG4gICAgICAgICAgZGVmYXVsdDpcXG4gICAgICAgICAgICBoYW5kbGVkID0gZmFsc2U7XFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIGlmIChldmVudC5rZXlDb2RlID09PSAzNiAmJiBldmVudC5jdHJsS2V5KSB7XFxuICAgICAgICAvLyBkaXNwbGF5IHRoZSBkYXRlIHBpY2tlciBvbiBjdHJsK2hvbWVcXG4gICAgICAgICQuZGF0ZXBpY2tlci5fc2hvd0RhdGVwaWNrZXIodGhpcyk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGhhbmRsZWQgPSBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGhhbmRsZWQpIHtcXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcXG4gICAgICB9XFxuICAgIH0sXFxuXFxuICAgIC8qIEZpbHRlciBlbnRlcmVkIGNoYXJhY3RlcnMgLSBiYXNlZCBvbiBkYXRlIGZvcm1hdC4gKi9cXG4gICAgX2RvS2V5UHJlc3M6IGZ1bmN0aW9uIF9kb0tleVByZXNzKGV2ZW50KSB7XFxuICAgICAgdmFyIGNoYXJzLFxcbiAgICAgICAgICBjaHIsXFxuICAgICAgICAgIGluc3QgPSAkLmRhdGVwaWNrZXIuX2dldEluc3QoZXZlbnQudGFyZ2V0KTtcXG5cXG4gICAgICBpZiAoJC5kYXRlcGlja2VyLl9nZXQoaW5zdCwgXFxcImNvbnN0cmFpbklucHV0XFxcIikpIHtcXG4gICAgICAgIGNoYXJzID0gJC5kYXRlcGlja2VyLl9wb3NzaWJsZUNoYXJzKCQuZGF0ZXBpY2tlci5fZ2V0KGluc3QsIFxcXCJkYXRlRm9ybWF0XFxcIikpO1xcbiAgICAgICAgY2hyID0gU3RyaW5nLmZyb21DaGFyQ29kZShldmVudC5jaGFyQ29kZSA9PSBudWxsID8gZXZlbnQua2V5Q29kZSA6IGV2ZW50LmNoYXJDb2RlKTtcXG4gICAgICAgIHJldHVybiBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkgfHwgY2hyIDwgXFxcIiBcXFwiIHx8ICFjaGFycyB8fCBjaGFycy5pbmRleE9mKGNocikgPiAtMTtcXG4gICAgICB9XFxuICAgIH0sXFxuXFxuICAgIC8qIFN5bmNocm9uaXNlIG1hbnVhbCBlbnRyeSBhbmQgZmllbGQvYWx0ZXJuYXRlIGZpZWxkLiAqL1xcbiAgICBfZG9LZXlVcDogZnVuY3Rpb24gX2RvS2V5VXAoZXZlbnQpIHtcXG4gICAgICB2YXIgZGF0ZSxcXG4gICAgICAgICAgaW5zdCA9ICQuZGF0ZXBpY2tlci5fZ2V0SW5zdChldmVudC50YXJnZXQpO1xcblxcbiAgICAgIGlmIChpbnN0LmlucHV0LnZhbCgpICE9PSBpbnN0Lmxhc3RWYWwpIHtcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgIGRhdGUgPSAkLmRhdGVwaWNrZXIucGFyc2VEYXRlKCQuZGF0ZXBpY2tlci5fZ2V0KGluc3QsIFxcXCJkYXRlRm9ybWF0XFxcIiksIGluc3QuaW5wdXQgPyBpbnN0LmlucHV0LnZhbCgpIDogbnVsbCwgJC5kYXRlcGlja2VyLl9nZXRGb3JtYXRDb25maWcoaW5zdCkpO1xcblxcbiAgICAgICAgICBpZiAoZGF0ZSkge1xcbiAgICAgICAgICAgIC8vIG9ubHkgaWYgdmFsaWRcXG4gICAgICAgICAgICAkLmRhdGVwaWNrZXIuX3NldERhdGVGcm9tRmllbGQoaW5zdCk7XFxuXFxuICAgICAgICAgICAgJC5kYXRlcGlja2VyLl91cGRhdGVBbHRlcm5hdGUoaW5zdCk7XFxuXFxuICAgICAgICAgICAgJC5kYXRlcGlja2VyLl91cGRhdGVEYXRlcGlja2VyKGluc3QpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IGNhdGNoIChlcnIpIHt9XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiB0cnVlO1xcbiAgICB9LFxcblxcbiAgICAvKiBQb3AtdXAgdGhlIGRhdGUgcGlja2VyIGZvciBhIGdpdmVuIGlucHV0IGZpZWxkLlxcbiAgICAgKiBJZiBmYWxzZSByZXR1cm5lZCBmcm9tIGJlZm9yZVNob3cgZXZlbnQgaGFuZGxlciBkbyBub3Qgc2hvdy5cXG4gICAgICogQHBhcmFtICBpbnB1dCAgZWxlbWVudCAtIHRoZSBpbnB1dCBmaWVsZCBhdHRhY2hlZCB0byB0aGUgZGF0ZSBwaWNrZXIgb3JcXG4gICAgICpcXHRcXHRcXHRcXHRcXHRldmVudCAtIGlmIHRyaWdnZXJlZCBieSBmb2N1c1xcbiAgICAgKi9cXG4gICAgX3Nob3dEYXRlcGlja2VyOiBmdW5jdGlvbiBfc2hvd0RhdGVwaWNrZXIoaW5wdXQpIHtcXG4gICAgICBpbnB1dCA9IGlucHV0LnRhcmdldCB8fCBpbnB1dDtcXG5cXG4gICAgICBpZiAoaW5wdXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gXFxcImlucHV0XFxcIikge1xcbiAgICAgICAgLy8gZmluZCBmcm9tIGJ1dHRvbi9pbWFnZSB0cmlnZ2VyXFxuICAgICAgICBpbnB1dCA9ICQoXFxcImlucHV0XFxcIiwgaW5wdXQucGFyZW50Tm9kZSlbMF07XFxuICAgICAgfVxcblxcbiAgICAgIGlmICgkLmRhdGVwaWNrZXIuX2lzRGlzYWJsZWREYXRlcGlja2VyKGlucHV0KSB8fCAkLmRhdGVwaWNrZXIuX2xhc3RJbnB1dCA9PT0gaW5wdXQpIHtcXG4gICAgICAgIC8vIGFscmVhZHkgaGVyZVxcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgaW5zdCwgYmVmb3JlU2hvdywgYmVmb3JlU2hvd1NldHRpbmdzLCBpc0ZpeGVkLCBvZmZzZXQsIHNob3dBbmltLCBkdXJhdGlvbjtcXG4gICAgICBpbnN0ID0gJC5kYXRlcGlja2VyLl9nZXRJbnN0KGlucHV0KTtcXG5cXG4gICAgICBpZiAoJC5kYXRlcGlja2VyLl9jdXJJbnN0ICYmICQuZGF0ZXBpY2tlci5fY3VySW5zdCAhPT0gaW5zdCkge1xcbiAgICAgICAgJC5kYXRlcGlja2VyLl9jdXJJbnN0LmRwRGl2LnN0b3AodHJ1ZSwgdHJ1ZSk7XFxuXFxuICAgICAgICBpZiAoaW5zdCAmJiAkLmRhdGVwaWNrZXIuX2RhdGVwaWNrZXJTaG93aW5nKSB7XFxuICAgICAgICAgICQuZGF0ZXBpY2tlci5faGlkZURhdGVwaWNrZXIoJC5kYXRlcGlja2VyLl9jdXJJbnN0LmlucHV0WzBdKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgYmVmb3JlU2hvdyA9ICQuZGF0ZXBpY2tlci5fZ2V0KGluc3QsIFxcXCJiZWZvcmVTaG93XFxcIik7XFxuICAgICAgYmVmb3JlU2hvd1NldHRpbmdzID0gYmVmb3JlU2hvdyA/IGJlZm9yZVNob3cuYXBwbHkoaW5wdXQsIFtpbnB1dCwgaW5zdF0pIDoge307XFxuXFxuICAgICAgaWYgKGJlZm9yZVNob3dTZXR0aW5ncyA9PT0gZmFsc2UpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgZGF0ZXBpY2tlcl9leHRlbmRSZW1vdmUoaW5zdC5zZXR0aW5ncywgYmVmb3JlU2hvd1NldHRpbmdzKTtcXG4gICAgICBpbnN0Lmxhc3RWYWwgPSBudWxsO1xcbiAgICAgICQuZGF0ZXBpY2tlci5fbGFzdElucHV0ID0gaW5wdXQ7XFxuXFxuICAgICAgJC5kYXRlcGlja2VyLl9zZXREYXRlRnJvbUZpZWxkKGluc3QpO1xcblxcbiAgICAgIGlmICgkLmRhdGVwaWNrZXIuX2luRGlhbG9nKSB7XFxuICAgICAgICAvLyBoaWRlIGN1cnNvclxcbiAgICAgICAgaW5wdXQudmFsdWUgPSBcXFwiXFxcIjtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCEkLmRhdGVwaWNrZXIuX3Bvcykge1xcbiAgICAgICAgLy8gcG9zaXRpb24gYmVsb3cgaW5wdXRcXG4gICAgICAgICQuZGF0ZXBpY2tlci5fcG9zID0gJC5kYXRlcGlja2VyLl9maW5kUG9zKGlucHV0KTtcXG4gICAgICAgICQuZGF0ZXBpY2tlci5fcG9zWzFdICs9IGlucHV0Lm9mZnNldEhlaWdodDsgLy8gYWRkIHRoZSBoZWlnaHRcXG4gICAgICB9XFxuXFxuICAgICAgaXNGaXhlZCA9IGZhbHNlO1xcbiAgICAgICQoaW5wdXQpLnBhcmVudHMoKS5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGlzRml4ZWQgfD0gJCh0aGlzKS5jc3MoXFxcInBvc2l0aW9uXFxcIikgPT09IFxcXCJmaXhlZFxcXCI7XFxuICAgICAgICByZXR1cm4gIWlzRml4ZWQ7XFxuICAgICAgfSk7XFxuICAgICAgb2Zmc2V0ID0ge1xcbiAgICAgICAgbGVmdDogJC5kYXRlcGlja2VyLl9wb3NbMF0sXFxuICAgICAgICB0b3A6ICQuZGF0ZXBpY2tlci5fcG9zWzFdXFxuICAgICAgfTtcXG4gICAgICAkLmRhdGVwaWNrZXIuX3BvcyA9IG51bGw7IC8vdG8gYXZvaWQgZmxhc2hlcyBvbiBGaXJlZm94XFxuXFxuICAgICAgaW5zdC5kcERpdi5lbXB0eSgpOyAvLyBkZXRlcm1pbmUgc2l6aW5nIG9mZnNjcmVlblxcblxcbiAgICAgIGluc3QuZHBEaXYuY3NzKHtcXG4gICAgICAgIHBvc2l0aW9uOiBcXFwiYWJzb2x1dGVcXFwiLFxcbiAgICAgICAgZGlzcGxheTogXFxcImJsb2NrXFxcIixcXG4gICAgICAgIHRvcDogXFxcIi0xMDAwcHhcXFwiXFxuICAgICAgfSk7XFxuXFxuICAgICAgJC5kYXRlcGlja2VyLl91cGRhdGVEYXRlcGlja2VyKGluc3QpOyAvLyBmaXggd2lkdGggZm9yIGR5bmFtaWMgbnVtYmVyIG9mIGRhdGUgcGlja2Vyc1xcbiAgICAgIC8vIGFuZCBhZGp1c3QgcG9zaXRpb24gYmVmb3JlIHNob3dpbmdcXG5cXG5cXG4gICAgICBvZmZzZXQgPSAkLmRhdGVwaWNrZXIuX2NoZWNrT2Zmc2V0KGluc3QsIG9mZnNldCwgaXNGaXhlZCk7XFxuICAgICAgaW5zdC5kcERpdi5jc3Moe1xcbiAgICAgICAgcG9zaXRpb246ICQuZGF0ZXBpY2tlci5faW5EaWFsb2cgJiYgJC5ibG9ja1VJID8gXFxcInN0YXRpY1xcXCIgOiBpc0ZpeGVkID8gXFxcImZpeGVkXFxcIiA6IFxcXCJhYnNvbHV0ZVxcXCIsXFxuICAgICAgICBkaXNwbGF5OiBcXFwibm9uZVxcXCIsXFxuICAgICAgICBsZWZ0OiBvZmZzZXQubGVmdCArIFxcXCJweFxcXCIsXFxuICAgICAgICB0b3A6IG9mZnNldC50b3AgKyBcXFwicHhcXFwiXFxuICAgICAgfSk7XFxuXFxuICAgICAgaWYgKCFpbnN0LmlubGluZSkge1xcbiAgICAgICAgc2hvd0FuaW0gPSAkLmRhdGVwaWNrZXIuX2dldChpbnN0LCBcXFwic2hvd0FuaW1cXFwiKTtcXG4gICAgICAgIGR1cmF0aW9uID0gJC5kYXRlcGlja2VyLl9nZXQoaW5zdCwgXFxcImR1cmF0aW9uXFxcIik7XFxuICAgICAgICBpbnN0LmRwRGl2LmNzcyhcXFwiei1pbmRleFxcXCIsIGRhdGVwaWNrZXJfZ2V0WmluZGV4KCQoaW5wdXQpKSArIDEpO1xcbiAgICAgICAgJC5kYXRlcGlja2VyLl9kYXRlcGlja2VyU2hvd2luZyA9IHRydWU7XFxuXFxuICAgICAgICBpZiAoJC5lZmZlY3RzICYmICQuZWZmZWN0cy5lZmZlY3Rbc2hvd0FuaW1dKSB7XFxuICAgICAgICAgIGluc3QuZHBEaXYuc2hvdyhzaG93QW5pbSwgJC5kYXRlcGlja2VyLl9nZXQoaW5zdCwgXFxcInNob3dPcHRpb25zXFxcIiksIGR1cmF0aW9uKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGluc3QuZHBEaXZbc2hvd0FuaW0gfHwgXFxcInNob3dcXFwiXShzaG93QW5pbSA/IGR1cmF0aW9uIDogbnVsbCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoJC5kYXRlcGlja2VyLl9zaG91bGRGb2N1c0lucHV0KGluc3QpKSB7XFxuICAgICAgICAgIGluc3QuaW5wdXQuZm9jdXMoKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgICQuZGF0ZXBpY2tlci5fY3VySW5zdCA9IGluc3Q7XFxuICAgICAgfVxcbiAgICB9LFxcblxcbiAgICAvKiBHZW5lcmF0ZSB0aGUgZGF0ZSBwaWNrZXIgY29udGVudC4gKi9cXG4gICAgX3VwZGF0ZURhdGVwaWNrZXI6IGZ1bmN0aW9uIF91cGRhdGVEYXRlcGlja2VyKGluc3QpIHtcXG4gICAgICB0aGlzLm1heFJvd3MgPSA0OyAvL1Jlc2V0IHRoZSBtYXggbnVtYmVyIG9mIHJvd3MgYmVpbmcgZGlzcGxheWVkIChzZWUgIzcwNDMpXFxuXFxuICAgICAgZGF0ZXBpY2tlcl9pbnN0QWN0aXZlID0gaW5zdDsgLy8gZm9yIGRlbGVnYXRlIGhvdmVyIGV2ZW50c1xcblxcbiAgICAgIGluc3QuZHBEaXYuZW1wdHkoKS5hcHBlbmQodGhpcy5fZ2VuZXJhdGVIVE1MKGluc3QpKTtcXG5cXG4gICAgICB0aGlzLl9hdHRhY2hIYW5kbGVycyhpbnN0KTtcXG5cXG4gICAgICB2YXIgb3JpZ3llYXJzaHRtbCxcXG4gICAgICAgICAgbnVtTW9udGhzID0gdGhpcy5fZ2V0TnVtYmVyT2ZNb250aHMoaW5zdCksXFxuICAgICAgICAgIGNvbHMgPSBudW1Nb250aHNbMV0sXFxuICAgICAgICAgIHdpZHRoID0gMTcsXFxuICAgICAgICAgIGFjdGl2ZUNlbGwgPSBpbnN0LmRwRGl2LmZpbmQoXFxcIi5cXFwiICsgdGhpcy5fZGF5T3ZlckNsYXNzICsgXFxcIiBhXFxcIik7XFxuXFxuICAgICAgaWYgKGFjdGl2ZUNlbGwubGVuZ3RoID4gMCkge1xcbiAgICAgICAgZGF0ZXBpY2tlcl9oYW5kbGVNb3VzZW92ZXIuYXBwbHkoYWN0aXZlQ2VsbC5nZXQoMCkpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpbnN0LmRwRGl2LnJlbW92ZUNsYXNzKFxcXCJ1aS1kYXRlcGlja2VyLW11bHRpLTIgdWktZGF0ZXBpY2tlci1tdWx0aS0zIHVpLWRhdGVwaWNrZXItbXVsdGktNFxcXCIpLndpZHRoKFxcXCJcXFwiKTtcXG5cXG4gICAgICBpZiAoY29scyA+IDEpIHtcXG4gICAgICAgIGluc3QuZHBEaXYuYWRkQ2xhc3MoXFxcInVpLWRhdGVwaWNrZXItbXVsdGktXFxcIiArIGNvbHMpLmNzcyhcXFwid2lkdGhcXFwiLCB3aWR0aCAqIGNvbHMgKyBcXFwiZW1cXFwiKTtcXG4gICAgICB9XFxuXFxuICAgICAgaW5zdC5kcERpdlsobnVtTW9udGhzWzBdICE9PSAxIHx8IG51bU1vbnRoc1sxXSAhPT0gMSA/IFxcXCJhZGRcXFwiIDogXFxcInJlbW92ZVxcXCIpICsgXFxcIkNsYXNzXFxcIl0oXFxcInVpLWRhdGVwaWNrZXItbXVsdGlcXFwiKTtcXG4gICAgICBpbnN0LmRwRGl2Wyh0aGlzLl9nZXQoaW5zdCwgXFxcImlzUlRMXFxcIikgPyBcXFwiYWRkXFxcIiA6IFxcXCJyZW1vdmVcXFwiKSArIFxcXCJDbGFzc1xcXCJdKFxcXCJ1aS1kYXRlcGlja2VyLXJ0bFxcXCIpO1xcblxcbiAgICAgIGlmIChpbnN0ID09PSAkLmRhdGVwaWNrZXIuX2N1ckluc3QgJiYgJC5kYXRlcGlja2VyLl9kYXRlcGlja2VyU2hvd2luZyAmJiAkLmRhdGVwaWNrZXIuX3Nob3VsZEZvY3VzSW5wdXQoaW5zdCkpIHtcXG4gICAgICAgIGluc3QuaW5wdXQuZm9jdXMoKTtcXG4gICAgICB9IC8vIGRlZmZlcmVkIHJlbmRlciBvZiB0aGUgeWVhcnMgc2VsZWN0ICh0byBhdm9pZCBmbGFzaGVzIG9uIEZpcmVmb3gpXFxuXFxuXFxuICAgICAgaWYgKGluc3QueWVhcnNodG1sKSB7XFxuICAgICAgICBvcmlneWVhcnNodG1sID0gaW5zdC55ZWFyc2h0bWw7XFxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgLy9hc3N1cmUgdGhhdCBpbnN0LnllYXJzaHRtbCBkaWRuJ3QgY2hhbmdlLlxcbiAgICAgICAgICBpZiAob3JpZ3llYXJzaHRtbCA9PT0gaW5zdC55ZWFyc2h0bWwgJiYgaW5zdC55ZWFyc2h0bWwpIHtcXG4gICAgICAgICAgICBpbnN0LmRwRGl2LmZpbmQoXFxcInNlbGVjdC51aS1kYXRlcGlja2VyLXllYXI6Zmlyc3RcXFwiKS5yZXBsYWNlV2l0aChpbnN0LnllYXJzaHRtbCk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgb3JpZ3llYXJzaHRtbCA9IGluc3QueWVhcnNodG1sID0gbnVsbDtcXG4gICAgICAgIH0sIDApO1xcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgLy8gIzY2OTQgLSBkb24ndCBmb2N1cyB0aGUgaW5wdXQgaWYgaXQncyBhbHJlYWR5IGZvY3VzZWRcXG4gICAgLy8gdGhpcyBicmVha3MgdGhlIGNoYW5nZSBldmVudCBpbiBJRVxcbiAgICAvLyBTdXBwb3J0OiBJRSBhbmQgalF1ZXJ5IDwxLjlcXG4gICAgX3Nob3VsZEZvY3VzSW5wdXQ6IGZ1bmN0aW9uIF9zaG91bGRGb2N1c0lucHV0KGluc3QpIHtcXG4gICAgICByZXR1cm4gaW5zdC5pbnB1dCAmJiBpbnN0LmlucHV0LmlzKFxcXCI6dmlzaWJsZVxcXCIpICYmICFpbnN0LmlucHV0LmlzKFxcXCI6ZGlzYWJsZWRcXFwiKSAmJiAhaW5zdC5pbnB1dC5pcyhcXFwiOmZvY3VzXFxcIik7XFxuICAgIH0sXFxuXFxuICAgIC8qIENoZWNrIHBvc2l0aW9uaW5nIHRvIHJlbWFpbiBvbiBzY3JlZW4uICovXFxuICAgIF9jaGVja09mZnNldDogZnVuY3Rpb24gX2NoZWNrT2Zmc2V0KGluc3QsIG9mZnNldCwgaXNGaXhlZCkge1xcbiAgICAgIHZhciBkcFdpZHRoID0gaW5zdC5kcERpdi5vdXRlcldpZHRoKCksXFxuICAgICAgICAgIGRwSGVpZ2h0ID0gaW5zdC5kcERpdi5vdXRlckhlaWdodCgpLFxcbiAgICAgICAgICBpbnB1dFdpZHRoID0gaW5zdC5pbnB1dCA/IGluc3QuaW5wdXQub3V0ZXJXaWR0aCgpIDogMCxcXG4gICAgICAgICAgaW5wdXRIZWlnaHQgPSBpbnN0LmlucHV0ID8gaW5zdC5pbnB1dC5vdXRlckhlaWdodCgpIDogMCxcXG4gICAgICAgICAgdmlld1dpZHRoID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoICsgKGlzRml4ZWQgPyAwIDogJChkb2N1bWVudCkuc2Nyb2xsTGVmdCgpKSxcXG4gICAgICAgICAgdmlld0hlaWdodCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQgKyAoaXNGaXhlZCA/IDAgOiAkKGRvY3VtZW50KS5zY3JvbGxUb3AoKSk7XFxuICAgICAgb2Zmc2V0LmxlZnQgLT0gdGhpcy5fZ2V0KGluc3QsIFxcXCJpc1JUTFxcXCIpID8gZHBXaWR0aCAtIGlucHV0V2lkdGggOiAwO1xcbiAgICAgIG9mZnNldC5sZWZ0IC09IGlzRml4ZWQgJiYgb2Zmc2V0LmxlZnQgPT09IGluc3QuaW5wdXQub2Zmc2V0KCkubGVmdCA/ICQoZG9jdW1lbnQpLnNjcm9sbExlZnQoKSA6IDA7XFxuICAgICAgb2Zmc2V0LnRvcCAtPSBpc0ZpeGVkICYmIG9mZnNldC50b3AgPT09IGluc3QuaW5wdXQub2Zmc2V0KCkudG9wICsgaW5wdXRIZWlnaHQgPyAkKGRvY3VtZW50KS5zY3JvbGxUb3AoKSA6IDA7IC8vIG5vdyBjaGVjayBpZiBkYXRlcGlja2VyIGlzIHNob3dpbmcgb3V0c2lkZSB3aW5kb3cgdmlld3BvcnQgLSBtb3ZlIHRvIGEgYmV0dGVyIHBsYWNlIGlmIHNvLlxcblxcbiAgICAgIG9mZnNldC5sZWZ0IC09IE1hdGgubWluKG9mZnNldC5sZWZ0LCBvZmZzZXQubGVmdCArIGRwV2lkdGggPiB2aWV3V2lkdGggJiYgdmlld1dpZHRoID4gZHBXaWR0aCA/IE1hdGguYWJzKG9mZnNldC5sZWZ0ICsgZHBXaWR0aCAtIHZpZXdXaWR0aCkgOiAwKTtcXG4gICAgICBvZmZzZXQudG9wIC09IE1hdGgubWluKG9mZnNldC50b3AsIG9mZnNldC50b3AgKyBkcEhlaWdodCA+IHZpZXdIZWlnaHQgJiYgdmlld0hlaWdodCA+IGRwSGVpZ2h0ID8gTWF0aC5hYnMoZHBIZWlnaHQgKyBpbnB1dEhlaWdodCkgOiAwKTtcXG4gICAgICByZXR1cm4gb2Zmc2V0O1xcbiAgICB9LFxcblxcbiAgICAvKiBGaW5kIGFuIG9iamVjdCdzIHBvc2l0aW9uIG9uIHRoZSBzY3JlZW4uICovXFxuICAgIF9maW5kUG9zOiBmdW5jdGlvbiBfZmluZFBvcyhvYmopIHtcXG4gICAgICB2YXIgcG9zaXRpb24sXFxuICAgICAgICAgIGluc3QgPSB0aGlzLl9nZXRJbnN0KG9iaiksXFxuICAgICAgICAgIGlzUlRMID0gdGhpcy5fZ2V0KGluc3QsIFxcXCJpc1JUTFxcXCIpO1xcblxcbiAgICAgIHdoaWxlIChvYmogJiYgKG9iai50eXBlID09PSBcXFwiaGlkZGVuXFxcIiB8fCBvYmoubm9kZVR5cGUgIT09IDEgfHwgJC5leHByLmZpbHRlcnMuaGlkZGVuKG9iaikpKSB7XFxuICAgICAgICBvYmogPSBvYmpbaXNSVEwgPyBcXFwicHJldmlvdXNTaWJsaW5nXFxcIiA6IFxcXCJuZXh0U2libGluZ1xcXCJdO1xcbiAgICAgIH1cXG5cXG4gICAgICBwb3NpdGlvbiA9ICQob2JqKS5vZmZzZXQoKTtcXG4gICAgICByZXR1cm4gW3Bvc2l0aW9uLmxlZnQsIHBvc2l0aW9uLnRvcF07XFxuICAgIH0sXFxuXFxuICAgIC8qIEhpZGUgdGhlIGRhdGUgcGlja2VyIGZyb20gdmlldy5cXG4gICAgICogQHBhcmFtICBpbnB1dCAgZWxlbWVudCAtIHRoZSBpbnB1dCBmaWVsZCBhdHRhY2hlZCB0byB0aGUgZGF0ZSBwaWNrZXJcXG4gICAgICovXFxuICAgIF9oaWRlRGF0ZXBpY2tlcjogZnVuY3Rpb24gX2hpZGVEYXRlcGlja2VyKGlucHV0KSB7XFxuICAgICAgdmFyIHNob3dBbmltLFxcbiAgICAgICAgICBkdXJhdGlvbixcXG4gICAgICAgICAgcG9zdFByb2Nlc3MsXFxuICAgICAgICAgIG9uQ2xvc2UsXFxuICAgICAgICAgIGluc3QgPSB0aGlzLl9jdXJJbnN0O1xcblxcbiAgICAgIGlmICghaW5zdCB8fCBpbnB1dCAmJiBpbnN0ICE9PSAkLmRhdGEoaW5wdXQsIFxcXCJkYXRlcGlja2VyXFxcIikpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMuX2RhdGVwaWNrZXJTaG93aW5nKSB7XFxuICAgICAgICBzaG93QW5pbSA9IHRoaXMuX2dldChpbnN0LCBcXFwic2hvd0FuaW1cXFwiKTtcXG4gICAgICAgIGR1cmF0aW9uID0gdGhpcy5fZ2V0KGluc3QsIFxcXCJkdXJhdGlvblxcXCIpO1xcblxcbiAgICAgICAgcG9zdFByb2Nlc3MgPSBmdW5jdGlvbiBwb3N0UHJvY2VzcygpIHtcXG4gICAgICAgICAgJC5kYXRlcGlja2VyLl90aWR5RGlhbG9nKGluc3QpO1xcbiAgICAgICAgfTsgLy8gREVQUkVDQVRFRDogYWZ0ZXIgQkMgZm9yIDEuOC54ICQuZWZmZWN0c1sgc2hvd0FuaW0gXSBpcyBub3QgbmVlZGVkXFxuXFxuXFxuICAgICAgICBpZiAoJC5lZmZlY3RzICYmICgkLmVmZmVjdHMuZWZmZWN0W3Nob3dBbmltXSB8fCAkLmVmZmVjdHNbc2hvd0FuaW1dKSkge1xcbiAgICAgICAgICBpbnN0LmRwRGl2LmhpZGUoc2hvd0FuaW0sICQuZGF0ZXBpY2tlci5fZ2V0KGluc3QsIFxcXCJzaG93T3B0aW9uc1xcXCIpLCBkdXJhdGlvbiwgcG9zdFByb2Nlc3MpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgaW5zdC5kcERpdltzaG93QW5pbSA9PT0gXFxcInNsaWRlRG93blxcXCIgPyBcXFwic2xpZGVVcFxcXCIgOiBzaG93QW5pbSA9PT0gXFxcImZhZGVJblxcXCIgPyBcXFwiZmFkZU91dFxcXCIgOiBcXFwiaGlkZVxcXCJdKHNob3dBbmltID8gZHVyYXRpb24gOiBudWxsLCBwb3N0UHJvY2Vzcyk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoIXNob3dBbmltKSB7XFxuICAgICAgICAgIHBvc3RQcm9jZXNzKCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0aGlzLl9kYXRlcGlja2VyU2hvd2luZyA9IGZhbHNlO1xcbiAgICAgICAgb25DbG9zZSA9IHRoaXMuX2dldChpbnN0LCBcXFwib25DbG9zZVxcXCIpO1xcblxcbiAgICAgICAgaWYgKG9uQ2xvc2UpIHtcXG4gICAgICAgICAgb25DbG9zZS5hcHBseShpbnN0LmlucHV0ID8gaW5zdC5pbnB1dFswXSA6IG51bGwsIFtpbnN0LmlucHV0ID8gaW5zdC5pbnB1dC52YWwoKSA6IFxcXCJcXFwiLCBpbnN0XSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0aGlzLl9sYXN0SW5wdXQgPSBudWxsO1xcblxcbiAgICAgICAgaWYgKHRoaXMuX2luRGlhbG9nKSB7XFxuICAgICAgICAgIHRoaXMuX2RpYWxvZ0lucHV0LmNzcyh7XFxuICAgICAgICAgICAgcG9zaXRpb246IFxcXCJhYnNvbHV0ZVxcXCIsXFxuICAgICAgICAgICAgbGVmdDogXFxcIjBcXFwiLFxcbiAgICAgICAgICAgIHRvcDogXFxcIi0xMDBweFxcXCJcXG4gICAgICAgICAgfSk7XFxuXFxuICAgICAgICAgIGlmICgkLmJsb2NrVUkpIHtcXG4gICAgICAgICAgICAkLnVuYmxvY2tVSSgpO1xcbiAgICAgICAgICAgICQoXFxcImJvZHlcXFwiKS5hcHBlbmQodGhpcy5kcERpdik7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHRoaXMuX2luRGlhbG9nID0gZmFsc2U7XFxuICAgICAgfVxcbiAgICB9LFxcblxcbiAgICAvKiBUaWR5IHVwIGFmdGVyIGEgZGlhbG9nIGRpc3BsYXkuICovXFxuICAgIF90aWR5RGlhbG9nOiBmdW5jdGlvbiBfdGlkeURpYWxvZyhpbnN0KSB7XFxuICAgICAgaW5zdC5kcERpdi5yZW1vdmVDbGFzcyh0aGlzLl9kaWFsb2dDbGFzcykudW5iaW5kKFxcXCIudWktZGF0ZXBpY2tlci1jYWxlbmRhclxcXCIpO1xcbiAgICB9LFxcblxcbiAgICAvKiBDbG9zZSBkYXRlIHBpY2tlciBpZiBjbGlja2VkIGVsc2V3aGVyZS4gKi9cXG4gICAgX2NoZWNrRXh0ZXJuYWxDbGljazogZnVuY3Rpb24gX2NoZWNrRXh0ZXJuYWxDbGljayhldmVudCkge1xcbiAgICAgIGlmICghJC5kYXRlcGlja2VyLl9jdXJJbnN0KSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIHZhciAkdGFyZ2V0ID0gJChldmVudC50YXJnZXQpLFxcbiAgICAgICAgICBpbnN0ID0gJC5kYXRlcGlja2VyLl9nZXRJbnN0KCR0YXJnZXRbMF0pO1xcblxcbiAgICAgIGlmICgkdGFyZ2V0WzBdLmlkICE9PSAkLmRhdGVwaWNrZXIuX21haW5EaXZJZCAmJiAkdGFyZ2V0LnBhcmVudHMoXFxcIiNcXFwiICsgJC5kYXRlcGlja2VyLl9tYWluRGl2SWQpLmxlbmd0aCA9PT0gMCAmJiAhJHRhcmdldC5oYXNDbGFzcygkLmRhdGVwaWNrZXIubWFya2VyQ2xhc3NOYW1lKSAmJiAhJHRhcmdldC5jbG9zZXN0KFxcXCIuXFxcIiArICQuZGF0ZXBpY2tlci5fdHJpZ2dlckNsYXNzKS5sZW5ndGggJiYgJC5kYXRlcGlja2VyLl9kYXRlcGlja2VyU2hvd2luZyAmJiAhKCQuZGF0ZXBpY2tlci5faW5EaWFsb2cgJiYgJC5ibG9ja1VJKSB8fCAkdGFyZ2V0Lmhhc0NsYXNzKCQuZGF0ZXBpY2tlci5tYXJrZXJDbGFzc05hbWUpICYmICQuZGF0ZXBpY2tlci5fY3VySW5zdCAhPT0gaW5zdCkge1xcbiAgICAgICAgJC5kYXRlcGlja2VyLl9oaWRlRGF0ZXBpY2tlcigpO1xcbiAgICAgIH1cXG4gICAgfSxcXG5cXG4gICAgLyogQWRqdXN0IG9uZSBvZiB0aGUgZGF0ZSBzdWItZmllbGRzLiAqL1xcbiAgICBfYWRqdXN0RGF0ZTogZnVuY3Rpb24gX2FkanVzdERhdGUoaWQsIG9mZnNldCwgcGVyaW9kKSB7XFxuICAgICAgdmFyIHRhcmdldCA9ICQoaWQpLFxcbiAgICAgICAgICBpbnN0ID0gdGhpcy5fZ2V0SW5zdCh0YXJnZXRbMF0pO1xcblxcbiAgICAgIGlmICh0aGlzLl9pc0Rpc2FibGVkRGF0ZXBpY2tlcih0YXJnZXRbMF0pKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX2FkanVzdEluc3REYXRlKGluc3QsIG9mZnNldCArIChwZXJpb2QgPT09IFxcXCJNXFxcIiA/IHRoaXMuX2dldChpbnN0LCBcXFwic2hvd0N1cnJlbnRBdFBvc1xcXCIpIDogMCksIC8vIHVuZG8gcG9zaXRpb25pbmdcXG4gICAgICBwZXJpb2QpO1xcblxcbiAgICAgIHRoaXMuX3VwZGF0ZURhdGVwaWNrZXIoaW5zdCk7XFxuICAgIH0sXFxuXFxuICAgIC8qIEFjdGlvbiBmb3IgY3VycmVudCBsaW5rLiAqL1xcbiAgICBfZ290b1RvZGF5OiBmdW5jdGlvbiBfZ290b1RvZGF5KGlkKSB7XFxuICAgICAgdmFyIGRhdGUsXFxuICAgICAgICAgIHRhcmdldCA9ICQoaWQpLFxcbiAgICAgICAgICBpbnN0ID0gdGhpcy5fZ2V0SW5zdCh0YXJnZXRbMF0pO1xcblxcbiAgICAgIGlmICh0aGlzLl9nZXQoaW5zdCwgXFxcImdvdG9DdXJyZW50XFxcIikgJiYgaW5zdC5jdXJyZW50RGF5KSB7XFxuICAgICAgICBpbnN0LnNlbGVjdGVkRGF5ID0gaW5zdC5jdXJyZW50RGF5O1xcbiAgICAgICAgaW5zdC5kcmF3TW9udGggPSBpbnN0LnNlbGVjdGVkTW9udGggPSBpbnN0LmN1cnJlbnRNb250aDtcXG4gICAgICAgIGluc3QuZHJhd1llYXIgPSBpbnN0LnNlbGVjdGVkWWVhciA9IGluc3QuY3VycmVudFllYXI7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGRhdGUgPSBuZXcgRGF0ZSgpO1xcbiAgICAgICAgaW5zdC5zZWxlY3RlZERheSA9IGRhdGUuZ2V0RGF0ZSgpO1xcbiAgICAgICAgaW5zdC5kcmF3TW9udGggPSBpbnN0LnNlbGVjdGVkTW9udGggPSBkYXRlLmdldE1vbnRoKCk7XFxuICAgICAgICBpbnN0LmRyYXdZZWFyID0gaW5zdC5zZWxlY3RlZFllYXIgPSBkYXRlLmdldEZ1bGxZZWFyKCk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX25vdGlmeUNoYW5nZShpbnN0KTtcXG5cXG4gICAgICB0aGlzLl9hZGp1c3REYXRlKHRhcmdldCk7XFxuICAgIH0sXFxuXFxuICAgIC8qIEFjdGlvbiBmb3Igc2VsZWN0aW5nIGEgbmV3IG1vbnRoL3llYXIuICovXFxuICAgIF9zZWxlY3RNb250aFllYXI6IGZ1bmN0aW9uIF9zZWxlY3RNb250aFllYXIoaWQsIHNlbGVjdCwgcGVyaW9kKSB7XFxuICAgICAgdmFyIHRhcmdldCA9ICQoaWQpLFxcbiAgICAgICAgICBpbnN0ID0gdGhpcy5fZ2V0SW5zdCh0YXJnZXRbMF0pO1xcblxcbiAgICAgIGluc3RbXFxcInNlbGVjdGVkXFxcIiArIChwZXJpb2QgPT09IFxcXCJNXFxcIiA/IFxcXCJNb250aFxcXCIgOiBcXFwiWWVhclxcXCIpXSA9IGluc3RbXFxcImRyYXdcXFwiICsgKHBlcmlvZCA9PT0gXFxcIk1cXFwiID8gXFxcIk1vbnRoXFxcIiA6IFxcXCJZZWFyXFxcIildID0gcGFyc2VJbnQoc2VsZWN0Lm9wdGlvbnNbc2VsZWN0LnNlbGVjdGVkSW5kZXhdLnZhbHVlLCAxMCk7XFxuXFxuICAgICAgdGhpcy5fbm90aWZ5Q2hhbmdlKGluc3QpO1xcblxcbiAgICAgIHRoaXMuX2FkanVzdERhdGUodGFyZ2V0KTtcXG4gICAgfSxcXG5cXG4gICAgLyogQWN0aW9uIGZvciBzZWxlY3RpbmcgYSBkYXkuICovXFxuICAgIF9zZWxlY3REYXk6IGZ1bmN0aW9uIF9zZWxlY3REYXkoaWQsIG1vbnRoLCB5ZWFyLCB0ZCkge1xcbiAgICAgIHZhciBpbnN0LFxcbiAgICAgICAgICB0YXJnZXQgPSAkKGlkKTtcXG5cXG4gICAgICBpZiAoJCh0ZCkuaGFzQ2xhc3ModGhpcy5fdW5zZWxlY3RhYmxlQ2xhc3MpIHx8IHRoaXMuX2lzRGlzYWJsZWREYXRlcGlja2VyKHRhcmdldFswXSkpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgaW5zdCA9IHRoaXMuX2dldEluc3QodGFyZ2V0WzBdKTtcXG4gICAgICBpbnN0LnNlbGVjdGVkRGF5ID0gaW5zdC5jdXJyZW50RGF5ID0gJChcXFwiYVxcXCIsIHRkKS5odG1sKCk7XFxuICAgICAgaW5zdC5zZWxlY3RlZE1vbnRoID0gaW5zdC5jdXJyZW50TW9udGggPSBtb250aDtcXG4gICAgICBpbnN0LnNlbGVjdGVkWWVhciA9IGluc3QuY3VycmVudFllYXIgPSB5ZWFyO1xcblxcbiAgICAgIHRoaXMuX3NlbGVjdERhdGUoaWQsIHRoaXMuX2Zvcm1hdERhdGUoaW5zdCwgaW5zdC5jdXJyZW50RGF5LCBpbnN0LmN1cnJlbnRNb250aCwgaW5zdC5jdXJyZW50WWVhcikpO1xcbiAgICB9LFxcblxcbiAgICAvKiBFcmFzZSB0aGUgaW5wdXQgZmllbGQgYW5kIGhpZGUgdGhlIGRhdGUgcGlja2VyLiAqL1xcbiAgICBfY2xlYXJEYXRlOiBmdW5jdGlvbiBfY2xlYXJEYXRlKGlkKSB7XFxuICAgICAgdmFyIHRhcmdldCA9ICQoaWQpO1xcblxcbiAgICAgIHRoaXMuX3NlbGVjdERhdGUodGFyZ2V0LCBcXFwiXFxcIik7XFxuICAgIH0sXFxuXFxuICAgIC8qIFVwZGF0ZSB0aGUgaW5wdXQgZmllbGQgd2l0aCB0aGUgc2VsZWN0ZWQgZGF0ZS4gKi9cXG4gICAgX3NlbGVjdERhdGU6IGZ1bmN0aW9uIF9zZWxlY3REYXRlKGlkLCBkYXRlU3RyKSB7XFxuICAgICAgdmFyIG9uU2VsZWN0LFxcbiAgICAgICAgICB0YXJnZXQgPSAkKGlkKSxcXG4gICAgICAgICAgaW5zdCA9IHRoaXMuX2dldEluc3QodGFyZ2V0WzBdKTtcXG5cXG4gICAgICBkYXRlU3RyID0gZGF0ZVN0ciAhPSBudWxsID8gZGF0ZVN0ciA6IHRoaXMuX2Zvcm1hdERhdGUoaW5zdCk7XFxuXFxuICAgICAgaWYgKGluc3QuaW5wdXQpIHtcXG4gICAgICAgIGluc3QuaW5wdXQudmFsKGRhdGVTdHIpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl91cGRhdGVBbHRlcm5hdGUoaW5zdCk7XFxuXFxuICAgICAgb25TZWxlY3QgPSB0aGlzLl9nZXQoaW5zdCwgXFxcIm9uU2VsZWN0XFxcIik7XFxuXFxuICAgICAgaWYgKG9uU2VsZWN0KSB7XFxuICAgICAgICBvblNlbGVjdC5hcHBseShpbnN0LmlucHV0ID8gaW5zdC5pbnB1dFswXSA6IG51bGwsIFtkYXRlU3RyLCBpbnN0XSk7IC8vIHRyaWdnZXIgY3VzdG9tIGNhbGxiYWNrXFxuICAgICAgfSBlbHNlIGlmIChpbnN0LmlucHV0KSB7XFxuICAgICAgICBpbnN0LmlucHV0LnRyaWdnZXIoXFxcImNoYW5nZVxcXCIpOyAvLyBmaXJlIHRoZSBjaGFuZ2UgZXZlbnRcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGluc3QuaW5saW5lKSB7XFxuICAgICAgICB0aGlzLl91cGRhdGVEYXRlcGlja2VyKGluc3QpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB0aGlzLl9oaWRlRGF0ZXBpY2tlcigpO1xcblxcbiAgICAgICAgdGhpcy5fbGFzdElucHV0ID0gaW5zdC5pbnB1dFswXTtcXG5cXG4gICAgICAgIGlmIChfdHlwZW9mKGluc3QuaW5wdXRbMF0pICE9PSBcXFwib2JqZWN0XFxcIikge1xcbiAgICAgICAgICBpbnN0LmlucHV0LmZvY3VzKCk7IC8vIHJlc3RvcmUgZm9jdXNcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHRoaXMuX2xhc3RJbnB1dCA9IG51bGw7XFxuICAgICAgfVxcbiAgICB9LFxcblxcbiAgICAvKiBVcGRhdGUgYW55IGFsdGVybmF0ZSBmaWVsZCB0byBzeW5jaHJvbmlzZSB3aXRoIHRoZSBtYWluIGZpZWxkLiAqL1xcbiAgICBfdXBkYXRlQWx0ZXJuYXRlOiBmdW5jdGlvbiBfdXBkYXRlQWx0ZXJuYXRlKGluc3QpIHtcXG4gICAgICB2YXIgYWx0Rm9ybWF0LFxcbiAgICAgICAgICBkYXRlLFxcbiAgICAgICAgICBkYXRlU3RyLFxcbiAgICAgICAgICBhbHRGaWVsZCA9IHRoaXMuX2dldChpbnN0LCBcXFwiYWx0RmllbGRcXFwiKTtcXG5cXG4gICAgICBpZiAoYWx0RmllbGQpIHtcXG4gICAgICAgIC8vIHVwZGF0ZSBhbHRlcm5hdGUgZmllbGQgdG9vXFxuICAgICAgICBhbHRGb3JtYXQgPSB0aGlzLl9nZXQoaW5zdCwgXFxcImFsdEZvcm1hdFxcXCIpIHx8IHRoaXMuX2dldChpbnN0LCBcXFwiZGF0ZUZvcm1hdFxcXCIpO1xcbiAgICAgICAgZGF0ZSA9IHRoaXMuX2dldERhdGUoaW5zdCk7XFxuICAgICAgICBkYXRlU3RyID0gdGhpcy5mb3JtYXREYXRlKGFsdEZvcm1hdCwgZGF0ZSwgdGhpcy5fZ2V0Rm9ybWF0Q29uZmlnKGluc3QpKTtcXG4gICAgICAgICQoYWx0RmllbGQpLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAkKHRoaXMpLnZhbChkYXRlU3RyKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG4gICAgfSxcXG5cXG4gICAgLyogU2V0IGFzIGJlZm9yZVNob3dEYXkgZnVuY3Rpb24gdG8gcHJldmVudCBzZWxlY3Rpb24gb2Ygd2Vla2VuZHMuXFxuICAgICAqIEBwYXJhbSAgZGF0ZSAgRGF0ZSAtIHRoZSBkYXRlIHRvIGN1c3RvbWlzZVxcbiAgICAgKiBAcmV0dXJuIFtib29sZWFuLCBzdHJpbmddIC0gaXMgdGhpcyBkYXRlIHNlbGVjdGFibGU/LCB3aGF0IGlzIGl0cyBDU1MgY2xhc3M/XFxuICAgICAqL1xcbiAgICBub1dlZWtlbmRzOiBmdW5jdGlvbiBub1dlZWtlbmRzKGRhdGUpIHtcXG4gICAgICB2YXIgZGF5ID0gZGF0ZS5nZXREYXkoKTtcXG4gICAgICByZXR1cm4gW2RheSA+IDAgJiYgZGF5IDwgNiwgXFxcIlxcXCJdO1xcbiAgICB9LFxcblxcbiAgICAvKiBTZXQgYXMgY2FsY3VsYXRlV2VlayB0byBkZXRlcm1pbmUgdGhlIHdlZWsgb2YgdGhlIHllYXIgYmFzZWQgb24gdGhlIElTTyA4NjAxIGRlZmluaXRpb24uXFxuICAgICAqIEBwYXJhbSAgZGF0ZSAgRGF0ZSAtIHRoZSBkYXRlIHRvIGdldCB0aGUgd2VlayBmb3JcXG4gICAgICogQHJldHVybiAgbnVtYmVyIC0gdGhlIG51bWJlciBvZiB0aGUgd2VlayB3aXRoaW4gdGhlIHllYXIgdGhhdCBjb250YWlucyB0aGlzIGRhdGVcXG4gICAgICovXFxuICAgIGlzbzg2MDFXZWVrOiBmdW5jdGlvbiBpc284NjAxV2VlayhkYXRlKSB7XFxuICAgICAgdmFyIHRpbWUsXFxuICAgICAgICAgIGNoZWNrRGF0ZSA9IG5ldyBEYXRlKGRhdGUuZ2V0VGltZSgpKTsgLy8gRmluZCBUaHVyc2RheSBvZiB0aGlzIHdlZWsgc3RhcnRpbmcgb24gTW9uZGF5XFxuXFxuICAgICAgY2hlY2tEYXRlLnNldERhdGUoY2hlY2tEYXRlLmdldERhdGUoKSArIDQgLSAoY2hlY2tEYXRlLmdldERheSgpIHx8IDcpKTtcXG4gICAgICB0aW1lID0gY2hlY2tEYXRlLmdldFRpbWUoKTtcXG4gICAgICBjaGVja0RhdGUuc2V0TW9udGgoMCk7IC8vIENvbXBhcmUgd2l0aCBKYW4gMVxcblxcbiAgICAgIGNoZWNrRGF0ZS5zZXREYXRlKDEpO1xcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucm91bmQoKHRpbWUgLSBjaGVja0RhdGUpIC8gODY0MDAwMDApIC8gNykgKyAxO1xcbiAgICB9LFxcblxcbiAgICAvKiBQYXJzZSBhIHN0cmluZyB2YWx1ZSBpbnRvIGEgZGF0ZSBvYmplY3QuXFxuICAgICAqIFNlZSBmb3JtYXREYXRlIGJlbG93IGZvciB0aGUgcG9zc2libGUgZm9ybWF0cy5cXG4gICAgICpcXG4gICAgICogQHBhcmFtICBmb3JtYXQgc3RyaW5nIC0gdGhlIGV4cGVjdGVkIGZvcm1hdCBvZiB0aGUgZGF0ZVxcbiAgICAgKiBAcGFyYW0gIHZhbHVlIHN0cmluZyAtIHRoZSBkYXRlIGluIHRoZSBhYm92ZSBmb3JtYXRcXG4gICAgICogQHBhcmFtICBzZXR0aW5ncyBPYmplY3QgLSBhdHRyaWJ1dGVzIGluY2x1ZGU6XFxuICAgICAqXFx0XFx0XFx0XFx0XFx0c2hvcnRZZWFyQ3V0b2ZmICBudW1iZXIgLSB0aGUgY3V0b2ZmIHllYXIgZm9yIGRldGVybWluaW5nIHRoZSBjZW50dXJ5IChvcHRpb25hbClcXG4gICAgICpcXHRcXHRcXHRcXHRcXHRkYXlOYW1lc1Nob3J0XFx0c3RyaW5nWzddIC0gYWJicmV2aWF0ZWQgbmFtZXMgb2YgdGhlIGRheXMgZnJvbSBTdW5kYXkgKG9wdGlvbmFsKVxcbiAgICAgKlxcdFxcdFxcdFxcdFxcdGRheU5hbWVzXFx0XFx0c3RyaW5nWzddIC0gbmFtZXMgb2YgdGhlIGRheXMgZnJvbSBTdW5kYXkgKG9wdGlvbmFsKVxcbiAgICAgKlxcdFxcdFxcdFxcdFxcdG1vbnRoTmFtZXNTaG9ydCBzdHJpbmdbMTJdIC0gYWJicmV2aWF0ZWQgbmFtZXMgb2YgdGhlIG1vbnRocyAob3B0aW9uYWwpXFxuICAgICAqXFx0XFx0XFx0XFx0XFx0bW9udGhOYW1lc1xcdFxcdHN0cmluZ1sxMl0gLSBuYW1lcyBvZiB0aGUgbW9udGhzIChvcHRpb25hbClcXG4gICAgICogQHJldHVybiAgRGF0ZSAtIHRoZSBleHRyYWN0ZWQgZGF0ZSB2YWx1ZSBvciBudWxsIGlmIHZhbHVlIGlzIGJsYW5rXFxuICAgICAqL1xcbiAgICBwYXJzZURhdGU6IGZ1bmN0aW9uIHBhcnNlRGF0ZShmb3JtYXQsIHZhbHVlLCBzZXR0aW5ncykge1xcbiAgICAgIGlmIChmb3JtYXQgPT0gbnVsbCB8fCB2YWx1ZSA9PSBudWxsKSB7XFxuICAgICAgICB0aHJvdyBcXFwiSW52YWxpZCBhcmd1bWVudHNcXFwiO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YWx1ZSA9IF90eXBlb2YodmFsdWUpID09PSBcXFwib2JqZWN0XFxcIiA/IHZhbHVlLnRvU3RyaW5nKCkgOiB2YWx1ZSArIFxcXCJcXFwiO1xcblxcbiAgICAgIGlmICh2YWx1ZSA9PT0gXFxcIlxcXCIpIHtcXG4gICAgICAgIHJldHVybiBudWxsO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgaUZvcm1hdCxcXG4gICAgICAgICAgZGltLFxcbiAgICAgICAgICBleHRyYSxcXG4gICAgICAgICAgaVZhbHVlID0gMCxcXG4gICAgICAgICAgc2hvcnRZZWFyQ3V0b2ZmVGVtcCA9IChzZXR0aW5ncyA/IHNldHRpbmdzLnNob3J0WWVhckN1dG9mZiA6IG51bGwpIHx8IHRoaXMuX2RlZmF1bHRzLnNob3J0WWVhckN1dG9mZixcXG4gICAgICAgICAgc2hvcnRZZWFyQ3V0b2ZmID0gdHlwZW9mIHNob3J0WWVhckN1dG9mZlRlbXAgIT09IFxcXCJzdHJpbmdcXFwiID8gc2hvcnRZZWFyQ3V0b2ZmVGVtcCA6IG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKSAlIDEwMCArIHBhcnNlSW50KHNob3J0WWVhckN1dG9mZlRlbXAsIDEwKSxcXG4gICAgICAgICAgZGF5TmFtZXNTaG9ydCA9IChzZXR0aW5ncyA/IHNldHRpbmdzLmRheU5hbWVzU2hvcnQgOiBudWxsKSB8fCB0aGlzLl9kZWZhdWx0cy5kYXlOYW1lc1Nob3J0LFxcbiAgICAgICAgICBkYXlOYW1lcyA9IChzZXR0aW5ncyA/IHNldHRpbmdzLmRheU5hbWVzIDogbnVsbCkgfHwgdGhpcy5fZGVmYXVsdHMuZGF5TmFtZXMsXFxuICAgICAgICAgIG1vbnRoTmFtZXNTaG9ydCA9IChzZXR0aW5ncyA/IHNldHRpbmdzLm1vbnRoTmFtZXNTaG9ydCA6IG51bGwpIHx8IHRoaXMuX2RlZmF1bHRzLm1vbnRoTmFtZXNTaG9ydCxcXG4gICAgICAgICAgbW9udGhOYW1lcyA9IChzZXR0aW5ncyA/IHNldHRpbmdzLm1vbnRoTmFtZXMgOiBudWxsKSB8fCB0aGlzLl9kZWZhdWx0cy5tb250aE5hbWVzLFxcbiAgICAgICAgICB5ZWFyID0gLTEsXFxuICAgICAgICAgIG1vbnRoID0gLTEsXFxuICAgICAgICAgIGRheSA9IC0xLFxcbiAgICAgICAgICBkb3kgPSAtMSxcXG4gICAgICAgICAgbGl0ZXJhbCA9IGZhbHNlLFxcbiAgICAgICAgICBkYXRlLFxcbiAgICAgICAgICAvLyBDaGVjayB3aGV0aGVyIGEgZm9ybWF0IGNoYXJhY3RlciBpcyBkb3VibGVkXFxuICAgICAgbG9va0FoZWFkID0gZnVuY3Rpb24gbG9va0FoZWFkKG1hdGNoKSB7XFxuICAgICAgICB2YXIgbWF0Y2hlcyA9IGlGb3JtYXQgKyAxIDwgZm9ybWF0Lmxlbmd0aCAmJiBmb3JtYXQuY2hhckF0KGlGb3JtYXQgKyAxKSA9PT0gbWF0Y2g7XFxuXFxuICAgICAgICBpZiAobWF0Y2hlcykge1xcbiAgICAgICAgICBpRm9ybWF0Kys7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gbWF0Y2hlcztcXG4gICAgICB9LFxcbiAgICAgICAgICAvLyBFeHRyYWN0IGEgbnVtYmVyIGZyb20gdGhlIHN0cmluZyB2YWx1ZVxcbiAgICAgIGdldE51bWJlciA9IGZ1bmN0aW9uIGdldE51bWJlcihtYXRjaCkge1xcbiAgICAgICAgdmFyIGlzRG91YmxlZCA9IGxvb2tBaGVhZChtYXRjaCksXFxuICAgICAgICAgICAgc2l6ZSA9IG1hdGNoID09PSBcXFwiQFxcXCIgPyAxNCA6IG1hdGNoID09PSBcXFwiIVxcXCIgPyAyMCA6IG1hdGNoID09PSBcXFwieVxcXCIgJiYgaXNEb3VibGVkID8gNCA6IG1hdGNoID09PSBcXFwib1xcXCIgPyAzIDogMixcXG4gICAgICAgICAgICBtaW5TaXplID0gbWF0Y2ggPT09IFxcXCJ5XFxcIiA/IHNpemUgOiAxLFxcbiAgICAgICAgICAgIGRpZ2l0cyA9IG5ldyBSZWdFeHAoXFxcIl5cXFxcXFxcXGR7XFxcIiArIG1pblNpemUgKyBcXFwiLFxcXCIgKyBzaXplICsgXFxcIn1cXFwiKSxcXG4gICAgICAgICAgICBudW0gPSB2YWx1ZS5zdWJzdHJpbmcoaVZhbHVlKS5tYXRjaChkaWdpdHMpO1xcblxcbiAgICAgICAgaWYgKCFudW0pIHtcXG4gICAgICAgICAgdGhyb3cgXFxcIk1pc3NpbmcgbnVtYmVyIGF0IHBvc2l0aW9uIFxcXCIgKyBpVmFsdWU7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpVmFsdWUgKz0gbnVtWzBdLmxlbmd0aDtcXG4gICAgICAgIHJldHVybiBwYXJzZUludChudW1bMF0sIDEwKTtcXG4gICAgICB9LFxcbiAgICAgICAgICAvLyBFeHRyYWN0IGEgbmFtZSBmcm9tIHRoZSBzdHJpbmcgdmFsdWUgYW5kIGNvbnZlcnQgdG8gYW4gaW5kZXhcXG4gICAgICBnZXROYW1lID0gZnVuY3Rpb24gZ2V0TmFtZShtYXRjaCwgc2hvcnROYW1lcywgbG9uZ05hbWVzKSB7XFxuICAgICAgICB2YXIgaW5kZXggPSAtMSxcXG4gICAgICAgICAgICBuYW1lcyA9ICQubWFwKGxvb2tBaGVhZChtYXRjaCkgPyBsb25nTmFtZXMgOiBzaG9ydE5hbWVzLCBmdW5jdGlvbiAodiwgaykge1xcbiAgICAgICAgICByZXR1cm4gW1trLCB2XV07XFxuICAgICAgICB9KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgICAgICAgIHJldHVybiAtKGFbMV0ubGVuZ3RoIC0gYlsxXS5sZW5ndGgpO1xcbiAgICAgICAgfSk7XFxuICAgICAgICAkLmVhY2gobmFtZXMsIGZ1bmN0aW9uIChpLCBwYWlyKSB7XFxuICAgICAgICAgIHZhciBuYW1lID0gcGFpclsxXTtcXG5cXG4gICAgICAgICAgaWYgKHZhbHVlLnN1YnN0cihpVmFsdWUsIG5hbWUubGVuZ3RoKS50b0xvd2VyQ2FzZSgpID09PSBuYW1lLnRvTG93ZXJDYXNlKCkpIHtcXG4gICAgICAgICAgICBpbmRleCA9IHBhaXJbMF07XFxuICAgICAgICAgICAgaVZhbHVlICs9IG5hbWUubGVuZ3RoO1xcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuXFxuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XFxuICAgICAgICAgIHJldHVybiBpbmRleCArIDE7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICB0aHJvdyBcXFwiVW5rbm93biBuYW1lIGF0IHBvc2l0aW9uIFxcXCIgKyBpVmFsdWU7XFxuICAgICAgICB9XFxuICAgICAgfSxcXG4gICAgICAgICAgLy8gQ29uZmlybSB0aGF0IGEgbGl0ZXJhbCBjaGFyYWN0ZXIgbWF0Y2hlcyB0aGUgc3RyaW5nIHZhbHVlXFxuICAgICAgY2hlY2tMaXRlcmFsID0gZnVuY3Rpb24gY2hlY2tMaXRlcmFsKCkge1xcbiAgICAgICAgaWYgKHZhbHVlLmNoYXJBdChpVmFsdWUpICE9PSBmb3JtYXQuY2hhckF0KGlGb3JtYXQpKSB7XFxuICAgICAgICAgIHRocm93IFxcXCJVbmV4cGVjdGVkIGxpdGVyYWwgYXQgcG9zaXRpb24gXFxcIiArIGlWYWx1ZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlWYWx1ZSsrO1xcbiAgICAgIH07XFxuXFxuICAgICAgZm9yIChpRm9ybWF0ID0gMDsgaUZvcm1hdCA8IGZvcm1hdC5sZW5ndGg7IGlGb3JtYXQrKykge1xcbiAgICAgICAgaWYgKGxpdGVyYWwpIHtcXG4gICAgICAgICAgaWYgKGZvcm1hdC5jaGFyQXQoaUZvcm1hdCkgPT09IFxcXCInXFxcIiAmJiAhbG9va0FoZWFkKFxcXCInXFxcIikpIHtcXG4gICAgICAgICAgICBsaXRlcmFsID0gZmFsc2U7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgY2hlY2tMaXRlcmFsKCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHN3aXRjaCAoZm9ybWF0LmNoYXJBdChpRm9ybWF0KSkge1xcbiAgICAgICAgICAgIGNhc2UgXFxcImRcXFwiOlxcbiAgICAgICAgICAgICAgZGF5ID0gZ2V0TnVtYmVyKFxcXCJkXFxcIik7XFxuICAgICAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgICAgICBjYXNlIFxcXCJEXFxcIjpcXG4gICAgICAgICAgICAgIGdldE5hbWUoXFxcIkRcXFwiLCBkYXlOYW1lc1Nob3J0LCBkYXlOYW1lcyk7XFxuICAgICAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgICAgICBjYXNlIFxcXCJvXFxcIjpcXG4gICAgICAgICAgICAgIGRveSA9IGdldE51bWJlcihcXFwib1xcXCIpO1xcbiAgICAgICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICAgICAgY2FzZSBcXFwibVxcXCI6XFxuICAgICAgICAgICAgICBtb250aCA9IGdldE51bWJlcihcXFwibVxcXCIpO1xcbiAgICAgICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICAgICAgY2FzZSBcXFwiTVxcXCI6XFxuICAgICAgICAgICAgICBtb250aCA9IGdldE5hbWUoXFxcIk1cXFwiLCBtb250aE5hbWVzU2hvcnQsIG1vbnRoTmFtZXMpO1xcbiAgICAgICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICAgICAgY2FzZSBcXFwieVxcXCI6XFxuICAgICAgICAgICAgICB5ZWFyID0gZ2V0TnVtYmVyKFxcXCJ5XFxcIik7XFxuICAgICAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgICAgICBjYXNlIFxcXCJAXFxcIjpcXG4gICAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZShnZXROdW1iZXIoXFxcIkBcXFwiKSk7XFxuICAgICAgICAgICAgICB5ZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpO1xcbiAgICAgICAgICAgICAgbW9udGggPSBkYXRlLmdldE1vbnRoKCkgKyAxO1xcbiAgICAgICAgICAgICAgZGF5ID0gZGF0ZS5nZXREYXRlKCk7XFxuICAgICAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgICAgICBjYXNlIFxcXCIhXFxcIjpcXG4gICAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZSgoZ2V0TnVtYmVyKFxcXCIhXFxcIikgLSB0aGlzLl90aWNrc1RvMTk3MCkgLyAxMDAwMCk7XFxuICAgICAgICAgICAgICB5ZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpO1xcbiAgICAgICAgICAgICAgbW9udGggPSBkYXRlLmdldE1vbnRoKCkgKyAxO1xcbiAgICAgICAgICAgICAgZGF5ID0gZGF0ZS5nZXREYXRlKCk7XFxuICAgICAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgICAgICBjYXNlIFxcXCInXFxcIjpcXG4gICAgICAgICAgICAgIGlmIChsb29rQWhlYWQoXFxcIidcXFwiKSkge1xcbiAgICAgICAgICAgICAgICBjaGVja0xpdGVyYWwoKTtcXG4gICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIGxpdGVyYWwgPSB0cnVlO1xcbiAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICAgICAgZGVmYXVsdDpcXG4gICAgICAgICAgICAgIGNoZWNrTGl0ZXJhbCgpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChpVmFsdWUgPCB2YWx1ZS5sZW5ndGgpIHtcXG4gICAgICAgIGV4dHJhID0gdmFsdWUuc3Vic3RyKGlWYWx1ZSk7XFxuXFxuICAgICAgICBpZiAoIS9eXFxcXHMrLy50ZXN0KGV4dHJhKSkge1xcbiAgICAgICAgICB0aHJvdyBcXFwiRXh0cmEvdW5wYXJzZWQgY2hhcmFjdGVycyBmb3VuZCBpbiBkYXRlOiBcXFwiICsgZXh0cmE7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh5ZWFyID09PSAtMSkge1xcbiAgICAgICAgeWVhciA9IG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKTtcXG4gICAgICB9IGVsc2UgaWYgKHllYXIgPCAxMDApIHtcXG4gICAgICAgIHllYXIgKz0gbmV3IERhdGUoKS5nZXRGdWxsWWVhcigpIC0gbmV3IERhdGUoKS5nZXRGdWxsWWVhcigpICUgMTAwICsgKHllYXIgPD0gc2hvcnRZZWFyQ3V0b2ZmID8gMCA6IC0xMDApO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoZG95ID4gLTEpIHtcXG4gICAgICAgIG1vbnRoID0gMTtcXG4gICAgICAgIGRheSA9IGRveTtcXG5cXG4gICAgICAgIGRvIHtcXG4gICAgICAgICAgZGltID0gdGhpcy5fZ2V0RGF5c0luTW9udGgoeWVhciwgbW9udGggLSAxKTtcXG5cXG4gICAgICAgICAgaWYgKGRheSA8PSBkaW0pIHtcXG4gICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBtb250aCsrO1xcbiAgICAgICAgICBkYXkgLT0gZGltO1xcbiAgICAgICAgfSB3aGlsZSAodHJ1ZSk7XFxuICAgICAgfVxcblxcbiAgICAgIGRhdGUgPSB0aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdChuZXcgRGF0ZSh5ZWFyLCBtb250aCAtIDEsIGRheSkpO1xcblxcbiAgICAgIGlmIChkYXRlLmdldEZ1bGxZZWFyKCkgIT09IHllYXIgfHwgZGF0ZS5nZXRNb250aCgpICsgMSAhPT0gbW9udGggfHwgZGF0ZS5nZXREYXRlKCkgIT09IGRheSkge1xcbiAgICAgICAgdGhyb3cgXFxcIkludmFsaWQgZGF0ZVxcXCI7IC8vIEUuZy4gMzEvMDIvMDBcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIGRhdGU7XFxuICAgIH0sXFxuXFxuICAgIC8qIFN0YW5kYXJkIGRhdGUgZm9ybWF0cy4gKi9cXG4gICAgQVRPTTogXFxcInl5LW1tLWRkXFxcIixcXG4gICAgLy8gUkZDIDMzMzkgKElTTyA4NjAxKVxcbiAgICBDT09LSUU6IFxcXCJELCBkZCBNIHl5XFxcIixcXG4gICAgSVNPXzg2MDE6IFxcXCJ5eS1tbS1kZFxcXCIsXFxuICAgIFJGQ184MjI6IFxcXCJELCBkIE0geVxcXCIsXFxuICAgIFJGQ184NTA6IFxcXCJERCwgZGQtTS15XFxcIixcXG4gICAgUkZDXzEwMzY6IFxcXCJELCBkIE0geVxcXCIsXFxuICAgIFJGQ18xMTIzOiBcXFwiRCwgZCBNIHl5XFxcIixcXG4gICAgUkZDXzI4MjI6IFxcXCJELCBkIE0geXlcXFwiLFxcbiAgICBSU1M6IFxcXCJELCBkIE0geVxcXCIsXFxuICAgIC8vIFJGQyA4MjJcXG4gICAgVElDS1M6IFxcXCIhXFxcIixcXG4gICAgVElNRVNUQU1QOiBcXFwiQFxcXCIsXFxuICAgIFczQzogXFxcInl5LW1tLWRkXFxcIixcXG4gICAgLy8gSVNPIDg2MDFcXG4gICAgX3RpY2tzVG8xOTcwOiAoKDE5NzAgLSAxKSAqIDM2NSArIE1hdGguZmxvb3IoMTk3MCAvIDQpIC0gTWF0aC5mbG9vcigxOTcwIC8gMTAwKSArIE1hdGguZmxvb3IoMTk3MCAvIDQwMCkpICogMjQgKiA2MCAqIDYwICogMTAwMDAwMDAsXFxuXFxuICAgIC8qIEZvcm1hdCBhIGRhdGUgb2JqZWN0IGludG8gYSBzdHJpbmcgdmFsdWUuXFxuICAgICAqIFRoZSBmb3JtYXQgY2FuIGJlIGNvbWJpbmF0aW9ucyBvZiB0aGUgZm9sbG93aW5nOlxcbiAgICAgKiBkICAtIGRheSBvZiBtb250aCAobm8gbGVhZGluZyB6ZXJvKVxcbiAgICAgKiBkZCAtIGRheSBvZiBtb250aCAodHdvIGRpZ2l0KVxcbiAgICAgKiBvICAtIGRheSBvZiB5ZWFyIChubyBsZWFkaW5nIHplcm9zKVxcbiAgICAgKiBvbyAtIGRheSBvZiB5ZWFyICh0aHJlZSBkaWdpdClcXG4gICAgICogRCAgLSBkYXkgbmFtZSBzaG9ydFxcbiAgICAgKiBERCAtIGRheSBuYW1lIGxvbmdcXG4gICAgICogbSAgLSBtb250aCBvZiB5ZWFyIChubyBsZWFkaW5nIHplcm8pXFxuICAgICAqIG1tIC0gbW9udGggb2YgeWVhciAodHdvIGRpZ2l0KVxcbiAgICAgKiBNICAtIG1vbnRoIG5hbWUgc2hvcnRcXG4gICAgICogTU0gLSBtb250aCBuYW1lIGxvbmdcXG4gICAgICogeSAgLSB5ZWFyICh0d28gZGlnaXQpXFxuICAgICAqIHl5IC0geWVhciAoZm91ciBkaWdpdClcXG4gICAgICogQCAtIFVuaXggdGltZXN0YW1wIChtcyBzaW5jZSAwMS8wMS8xOTcwKVxcbiAgICAgKiAhIC0gV2luZG93cyB0aWNrcyAoMTAwbnMgc2luY2UgMDEvMDEvMDAwMSlcXG4gICAgICogXFxcIi4uLlxcXCIgLSBsaXRlcmFsIHRleHRcXG4gICAgICogJycgLSBzaW5nbGUgcXVvdGVcXG4gICAgICpcXG4gICAgICogQHBhcmFtICBmb3JtYXQgc3RyaW5nIC0gdGhlIGRlc2lyZWQgZm9ybWF0IG9mIHRoZSBkYXRlXFxuICAgICAqIEBwYXJhbSAgZGF0ZSBEYXRlIC0gdGhlIGRhdGUgdmFsdWUgdG8gZm9ybWF0XFxuICAgICAqIEBwYXJhbSAgc2V0dGluZ3MgT2JqZWN0IC0gYXR0cmlidXRlcyBpbmNsdWRlOlxcbiAgICAgKlxcdFxcdFxcdFxcdFxcdGRheU5hbWVzU2hvcnRcXHRzdHJpbmdbN10gLSBhYmJyZXZpYXRlZCBuYW1lcyBvZiB0aGUgZGF5cyBmcm9tIFN1bmRheSAob3B0aW9uYWwpXFxuICAgICAqXFx0XFx0XFx0XFx0XFx0ZGF5TmFtZXNcXHRcXHRzdHJpbmdbN10gLSBuYW1lcyBvZiB0aGUgZGF5cyBmcm9tIFN1bmRheSAob3B0aW9uYWwpXFxuICAgICAqXFx0XFx0XFx0XFx0XFx0bW9udGhOYW1lc1Nob3J0IHN0cmluZ1sxMl0gLSBhYmJyZXZpYXRlZCBuYW1lcyBvZiB0aGUgbW9udGhzIChvcHRpb25hbClcXG4gICAgICpcXHRcXHRcXHRcXHRcXHRtb250aE5hbWVzXFx0XFx0c3RyaW5nWzEyXSAtIG5hbWVzIG9mIHRoZSBtb250aHMgKG9wdGlvbmFsKVxcbiAgICAgKiBAcmV0dXJuICBzdHJpbmcgLSB0aGUgZGF0ZSBpbiB0aGUgYWJvdmUgZm9ybWF0XFxuICAgICAqL1xcbiAgICBmb3JtYXREYXRlOiBmdW5jdGlvbiBmb3JtYXREYXRlKGZvcm1hdCwgZGF0ZSwgc2V0dGluZ3MpIHtcXG4gICAgICBpZiAoIWRhdGUpIHtcXG4gICAgICAgIHJldHVybiBcXFwiXFxcIjtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIGlGb3JtYXQsXFxuICAgICAgICAgIGRheU5hbWVzU2hvcnQgPSAoc2V0dGluZ3MgPyBzZXR0aW5ncy5kYXlOYW1lc1Nob3J0IDogbnVsbCkgfHwgdGhpcy5fZGVmYXVsdHMuZGF5TmFtZXNTaG9ydCxcXG4gICAgICAgICAgZGF5TmFtZXMgPSAoc2V0dGluZ3MgPyBzZXR0aW5ncy5kYXlOYW1lcyA6IG51bGwpIHx8IHRoaXMuX2RlZmF1bHRzLmRheU5hbWVzLFxcbiAgICAgICAgICBtb250aE5hbWVzU2hvcnQgPSAoc2V0dGluZ3MgPyBzZXR0aW5ncy5tb250aE5hbWVzU2hvcnQgOiBudWxsKSB8fCB0aGlzLl9kZWZhdWx0cy5tb250aE5hbWVzU2hvcnQsXFxuICAgICAgICAgIG1vbnRoTmFtZXMgPSAoc2V0dGluZ3MgPyBzZXR0aW5ncy5tb250aE5hbWVzIDogbnVsbCkgfHwgdGhpcy5fZGVmYXVsdHMubW9udGhOYW1lcyxcXG4gICAgICAgICAgLy8gQ2hlY2sgd2hldGhlciBhIGZvcm1hdCBjaGFyYWN0ZXIgaXMgZG91YmxlZFxcbiAgICAgIGxvb2tBaGVhZCA9IGZ1bmN0aW9uIGxvb2tBaGVhZChtYXRjaCkge1xcbiAgICAgICAgdmFyIG1hdGNoZXMgPSBpRm9ybWF0ICsgMSA8IGZvcm1hdC5sZW5ndGggJiYgZm9ybWF0LmNoYXJBdChpRm9ybWF0ICsgMSkgPT09IG1hdGNoO1xcblxcbiAgICAgICAgaWYgKG1hdGNoZXMpIHtcXG4gICAgICAgICAgaUZvcm1hdCsrO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIG1hdGNoZXM7XFxuICAgICAgfSxcXG4gICAgICAgICAgLy8gRm9ybWF0IGEgbnVtYmVyLCB3aXRoIGxlYWRpbmcgemVybyBpZiBuZWNlc3NhcnlcXG4gICAgICBmb3JtYXROdW1iZXIgPSBmdW5jdGlvbiBmb3JtYXROdW1iZXIobWF0Y2gsIHZhbHVlLCBsZW4pIHtcXG4gICAgICAgIHZhciBudW0gPSBcXFwiXFxcIiArIHZhbHVlO1xcblxcbiAgICAgICAgaWYgKGxvb2tBaGVhZChtYXRjaCkpIHtcXG4gICAgICAgICAgd2hpbGUgKG51bS5sZW5ndGggPCBsZW4pIHtcXG4gICAgICAgICAgICBudW0gPSBcXFwiMFxcXCIgKyBudW07XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiBudW07XFxuICAgICAgfSxcXG4gICAgICAgICAgLy8gRm9ybWF0IGEgbmFtZSwgc2hvcnQgb3IgbG9uZyBhcyByZXF1ZXN0ZWRcXG4gICAgICBmb3JtYXROYW1lID0gZnVuY3Rpb24gZm9ybWF0TmFtZShtYXRjaCwgdmFsdWUsIHNob3J0TmFtZXMsIGxvbmdOYW1lcykge1xcbiAgICAgICAgcmV0dXJuIGxvb2tBaGVhZChtYXRjaCkgPyBsb25nTmFtZXNbdmFsdWVdIDogc2hvcnROYW1lc1t2YWx1ZV07XFxuICAgICAgfSxcXG4gICAgICAgICAgb3V0cHV0ID0gXFxcIlxcXCIsXFxuICAgICAgICAgIGxpdGVyYWwgPSBmYWxzZTtcXG5cXG4gICAgICBpZiAoZGF0ZSkge1xcbiAgICAgICAgZm9yIChpRm9ybWF0ID0gMDsgaUZvcm1hdCA8IGZvcm1hdC5sZW5ndGg7IGlGb3JtYXQrKykge1xcbiAgICAgICAgICBpZiAobGl0ZXJhbCkge1xcbiAgICAgICAgICAgIGlmIChmb3JtYXQuY2hhckF0KGlGb3JtYXQpID09PSBcXFwiJ1xcXCIgJiYgIWxvb2tBaGVhZChcXFwiJ1xcXCIpKSB7XFxuICAgICAgICAgICAgICBsaXRlcmFsID0gZmFsc2U7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgIG91dHB1dCArPSBmb3JtYXQuY2hhckF0KGlGb3JtYXQpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBzd2l0Y2ggKGZvcm1hdC5jaGFyQXQoaUZvcm1hdCkpIHtcXG4gICAgICAgICAgICAgIGNhc2UgXFxcImRcXFwiOlxcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gZm9ybWF0TnVtYmVyKFxcXCJkXFxcIiwgZGF0ZS5nZXREYXRlKCksIDIpO1xcbiAgICAgICAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgICAgICAgIGNhc2UgXFxcIkRcXFwiOlxcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gZm9ybWF0TmFtZShcXFwiRFxcXCIsIGRhdGUuZ2V0RGF5KCksIGRheU5hbWVzU2hvcnQsIGRheU5hbWVzKTtcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICAgICAgICBjYXNlIFxcXCJvXFxcIjpcXG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9IGZvcm1hdE51bWJlcihcXFwib1xcXCIsIE1hdGgucm91bmQoKG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpLCBkYXRlLmdldERhdGUoKSkuZ2V0VGltZSgpIC0gbmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCAwLCAwKS5nZXRUaW1lKCkpIC8gODY0MDAwMDApLCAzKTtcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICAgICAgICBjYXNlIFxcXCJtXFxcIjpcXG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9IGZvcm1hdE51bWJlcihcXFwibVxcXCIsIGRhdGUuZ2V0TW9udGgoKSArIDEsIDIpO1xcbiAgICAgICAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgICAgICAgIGNhc2UgXFxcIk1cXFwiOlxcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gZm9ybWF0TmFtZShcXFwiTVxcXCIsIGRhdGUuZ2V0TW9udGgoKSwgbW9udGhOYW1lc1Nob3J0LCBtb250aE5hbWVzKTtcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICAgICAgICBjYXNlIFxcXCJ5XFxcIjpcXG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9IGxvb2tBaGVhZChcXFwieVxcXCIpID8gZGF0ZS5nZXRGdWxsWWVhcigpIDogKGRhdGUuZ2V0WWVhcigpICUgMTAwIDwgMTAgPyBcXFwiMFxcXCIgOiBcXFwiXFxcIikgKyBkYXRlLmdldFllYXIoKSAlIDEwMDtcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICAgICAgICBjYXNlIFxcXCJAXFxcIjpcXG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9IGRhdGUuZ2V0VGltZSgpO1xcbiAgICAgICAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgICAgICAgIGNhc2UgXFxcIiFcXFwiOlxcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gZGF0ZS5nZXRUaW1lKCkgKiAxMDAwMCArIHRoaXMuX3RpY2tzVG8xOTcwO1xcbiAgICAgICAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgICAgICAgIGNhc2UgXFxcIidcXFwiOlxcbiAgICAgICAgICAgICAgICBpZiAobG9va0FoZWFkKFxcXCInXFxcIikpIHtcXG4gICAgICAgICAgICAgICAgICBvdXRwdXQgKz0gXFxcIidcXFwiO1xcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgIGxpdGVyYWwgPSB0cnVlO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICAgICAgZGVmYXVsdDpcXG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9IGZvcm1hdC5jaGFyQXQoaUZvcm1hdCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBvdXRwdXQ7XFxuICAgIH0sXFxuXFxuICAgIC8qIEV4dHJhY3QgYWxsIHBvc3NpYmxlIGNoYXJhY3RlcnMgZnJvbSB0aGUgZGF0ZSBmb3JtYXQuICovXFxuICAgIF9wb3NzaWJsZUNoYXJzOiBmdW5jdGlvbiBfcG9zc2libGVDaGFycyhmb3JtYXQpIHtcXG4gICAgICB2YXIgaUZvcm1hdCxcXG4gICAgICAgICAgY2hhcnMgPSBcXFwiXFxcIixcXG4gICAgICAgICAgbGl0ZXJhbCA9IGZhbHNlLFxcbiAgICAgICAgICAvLyBDaGVjayB3aGV0aGVyIGEgZm9ybWF0IGNoYXJhY3RlciBpcyBkb3VibGVkXFxuICAgICAgbG9va0FoZWFkID0gZnVuY3Rpb24gbG9va0FoZWFkKG1hdGNoKSB7XFxuICAgICAgICB2YXIgbWF0Y2hlcyA9IGlGb3JtYXQgKyAxIDwgZm9ybWF0Lmxlbmd0aCAmJiBmb3JtYXQuY2hhckF0KGlGb3JtYXQgKyAxKSA9PT0gbWF0Y2g7XFxuXFxuICAgICAgICBpZiAobWF0Y2hlcykge1xcbiAgICAgICAgICBpRm9ybWF0Kys7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gbWF0Y2hlcztcXG4gICAgICB9O1xcblxcbiAgICAgIGZvciAoaUZvcm1hdCA9IDA7IGlGb3JtYXQgPCBmb3JtYXQubGVuZ3RoOyBpRm9ybWF0KyspIHtcXG4gICAgICAgIGlmIChsaXRlcmFsKSB7XFxuICAgICAgICAgIGlmIChmb3JtYXQuY2hhckF0KGlGb3JtYXQpID09PSBcXFwiJ1xcXCIgJiYgIWxvb2tBaGVhZChcXFwiJ1xcXCIpKSB7XFxuICAgICAgICAgICAgbGl0ZXJhbCA9IGZhbHNlO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGNoYXJzICs9IGZvcm1hdC5jaGFyQXQoaUZvcm1hdCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHN3aXRjaCAoZm9ybWF0LmNoYXJBdChpRm9ybWF0KSkge1xcbiAgICAgICAgICAgIGNhc2UgXFxcImRcXFwiOlxcbiAgICAgICAgICAgIGNhc2UgXFxcIm1cXFwiOlxcbiAgICAgICAgICAgIGNhc2UgXFxcInlcXFwiOlxcbiAgICAgICAgICAgIGNhc2UgXFxcIkBcXFwiOlxcbiAgICAgICAgICAgICAgY2hhcnMgKz0gXFxcIjAxMjM0NTY3ODlcXFwiO1xcbiAgICAgICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICAgICAgY2FzZSBcXFwiRFxcXCI6XFxuICAgICAgICAgICAgY2FzZSBcXFwiTVxcXCI6XFxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcXG4gICAgICAgICAgICAvLyBBY2NlcHQgYW55dGhpbmdcXG5cXG4gICAgICAgICAgICBjYXNlIFxcXCInXFxcIjpcXG4gICAgICAgICAgICAgIGlmIChsb29rQWhlYWQoXFxcIidcXFwiKSkge1xcbiAgICAgICAgICAgICAgICBjaGFycyArPSBcXFwiJ1xcXCI7XFxuICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICBsaXRlcmFsID0gdHJ1ZTtcXG4gICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICAgIGRlZmF1bHQ6XFxuICAgICAgICAgICAgICBjaGFycyArPSBmb3JtYXQuY2hhckF0KGlGb3JtYXQpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBjaGFycztcXG4gICAgfSxcXG5cXG4gICAgLyogR2V0IGEgc2V0dGluZyB2YWx1ZSwgZGVmYXVsdGluZyBpZiBuZWNlc3NhcnkuICovXFxuICAgIF9nZXQ6IGZ1bmN0aW9uIF9nZXQoaW5zdCwgbmFtZSkge1xcbiAgICAgIHJldHVybiBpbnN0LnNldHRpbmdzW25hbWVdICE9PSB1bmRlZmluZWQgPyBpbnN0LnNldHRpbmdzW25hbWVdIDogdGhpcy5fZGVmYXVsdHNbbmFtZV07XFxuICAgIH0sXFxuXFxuICAgIC8qIFBhcnNlIGV4aXN0aW5nIGRhdGUgYW5kIGluaXRpYWxpc2UgZGF0ZSBwaWNrZXIuICovXFxuICAgIF9zZXREYXRlRnJvbUZpZWxkOiBmdW5jdGlvbiBfc2V0RGF0ZUZyb21GaWVsZChpbnN0LCBub0RlZmF1bHQpIHtcXG4gICAgICBpZiAoaW5zdC5pbnB1dC52YWwoKSA9PT0gaW5zdC5sYXN0VmFsKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBkYXRlRm9ybWF0ID0gdGhpcy5fZ2V0KGluc3QsIFxcXCJkYXRlRm9ybWF0XFxcIiksXFxuICAgICAgICAgIGRhdGVzID0gaW5zdC5sYXN0VmFsID0gaW5zdC5pbnB1dCA/IGluc3QuaW5wdXQudmFsKCkgOiBudWxsLFxcbiAgICAgICAgICBkZWZhdWx0RGF0ZSA9IHRoaXMuX2dldERlZmF1bHREYXRlKGluc3QpLFxcbiAgICAgICAgICBkYXRlID0gZGVmYXVsdERhdGUsXFxuICAgICAgICAgIHNldHRpbmdzID0gdGhpcy5fZ2V0Rm9ybWF0Q29uZmlnKGluc3QpO1xcblxcbiAgICAgIHRyeSB7XFxuICAgICAgICBkYXRlID0gdGhpcy5wYXJzZURhdGUoZGF0ZUZvcm1hdCwgZGF0ZXMsIHNldHRpbmdzKSB8fCBkZWZhdWx0RGF0ZTtcXG4gICAgICB9IGNhdGNoIChldmVudCkge1xcbiAgICAgICAgZGF0ZXMgPSBub0RlZmF1bHQgPyBcXFwiXFxcIiA6IGRhdGVzO1xcbiAgICAgIH1cXG5cXG4gICAgICBpbnN0LnNlbGVjdGVkRGF5ID0gZGF0ZS5nZXREYXRlKCk7XFxuICAgICAgaW5zdC5kcmF3TW9udGggPSBpbnN0LnNlbGVjdGVkTW9udGggPSBkYXRlLmdldE1vbnRoKCk7XFxuICAgICAgaW5zdC5kcmF3WWVhciA9IGluc3Quc2VsZWN0ZWRZZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpO1xcbiAgICAgIGluc3QuY3VycmVudERheSA9IGRhdGVzID8gZGF0ZS5nZXREYXRlKCkgOiAwO1xcbiAgICAgIGluc3QuY3VycmVudE1vbnRoID0gZGF0ZXMgPyBkYXRlLmdldE1vbnRoKCkgOiAwO1xcbiAgICAgIGluc3QuY3VycmVudFllYXIgPSBkYXRlcyA/IGRhdGUuZ2V0RnVsbFllYXIoKSA6IDA7XFxuXFxuICAgICAgdGhpcy5fYWRqdXN0SW5zdERhdGUoaW5zdCk7XFxuICAgIH0sXFxuXFxuICAgIC8qIFJldHJpZXZlIHRoZSBkZWZhdWx0IGRhdGUgc2hvd24gb24gb3BlbmluZy4gKi9cXG4gICAgX2dldERlZmF1bHREYXRlOiBmdW5jdGlvbiBfZ2V0RGVmYXVsdERhdGUoaW5zdCkge1xcbiAgICAgIHJldHVybiB0aGlzLl9yZXN0cmljdE1pbk1heChpbnN0LCB0aGlzLl9kZXRlcm1pbmVEYXRlKGluc3QsIHRoaXMuX2dldChpbnN0LCBcXFwiZGVmYXVsdERhdGVcXFwiKSwgbmV3IERhdGUoKSkpO1xcbiAgICB9LFxcblxcbiAgICAvKiBBIGRhdGUgbWF5IGJlIHNwZWNpZmllZCBhcyBhbiBleGFjdCB2YWx1ZSBvciBhIHJlbGF0aXZlIG9uZS4gKi9cXG4gICAgX2RldGVybWluZURhdGU6IGZ1bmN0aW9uIF9kZXRlcm1pbmVEYXRlKGluc3QsIGRhdGUsIGRlZmF1bHREYXRlKSB7XFxuICAgICAgdmFyIG9mZnNldE51bWVyaWMgPSBmdW5jdGlvbiBvZmZzZXROdW1lcmljKG9mZnNldCkge1xcbiAgICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSgpO1xcbiAgICAgICAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpICsgb2Zmc2V0KTtcXG4gICAgICAgIHJldHVybiBkYXRlO1xcbiAgICAgIH0sXFxuICAgICAgICAgIG9mZnNldFN0cmluZyA9IGZ1bmN0aW9uIG9mZnNldFN0cmluZyhvZmZzZXQpIHtcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgIHJldHVybiAkLmRhdGVwaWNrZXIucGFyc2VEYXRlKCQuZGF0ZXBpY2tlci5fZ2V0KGluc3QsIFxcXCJkYXRlRm9ybWF0XFxcIiksIG9mZnNldCwgJC5kYXRlcGlja2VyLl9nZXRGb3JtYXRDb25maWcoaW5zdCkpO1xcbiAgICAgICAgfSBjYXRjaCAoZSkgey8vIElnbm9yZVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgdmFyIGRhdGUgPSAob2Zmc2V0LnRvTG93ZXJDYXNlKCkubWF0Y2goL15jLykgPyAkLmRhdGVwaWNrZXIuX2dldERhdGUoaW5zdCkgOiBudWxsKSB8fCBuZXcgRGF0ZSgpLFxcbiAgICAgICAgICAgIHllYXIgPSBkYXRlLmdldEZ1bGxZZWFyKCksXFxuICAgICAgICAgICAgbW9udGggPSBkYXRlLmdldE1vbnRoKCksXFxuICAgICAgICAgICAgZGF5ID0gZGF0ZS5nZXREYXRlKCksXFxuICAgICAgICAgICAgcGF0dGVybiA9IC8oWytcXFxcLV0/WzAtOV0rKVxcXFxzKihkfER8d3xXfG18TXx5fFkpPy9nLFxcbiAgICAgICAgICAgIG1hdGNoZXMgPSBwYXR0ZXJuLmV4ZWMob2Zmc2V0KTtcXG5cXG4gICAgICAgIHdoaWxlIChtYXRjaGVzKSB7XFxuICAgICAgICAgIHN3aXRjaCAobWF0Y2hlc1syXSB8fCBcXFwiZFxcXCIpIHtcXG4gICAgICAgICAgICBjYXNlIFxcXCJkXFxcIjpcXG4gICAgICAgICAgICBjYXNlIFxcXCJEXFxcIjpcXG4gICAgICAgICAgICAgIGRheSArPSBwYXJzZUludChtYXRjaGVzWzFdLCAxMCk7XFxuICAgICAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgICAgICBjYXNlIFxcXCJ3XFxcIjpcXG4gICAgICAgICAgICBjYXNlIFxcXCJXXFxcIjpcXG4gICAgICAgICAgICAgIGRheSArPSBwYXJzZUludChtYXRjaGVzWzFdLCAxMCkgKiA3O1xcbiAgICAgICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICAgICAgY2FzZSBcXFwibVxcXCI6XFxuICAgICAgICAgICAgY2FzZSBcXFwiTVxcXCI6XFxuICAgICAgICAgICAgICBtb250aCArPSBwYXJzZUludChtYXRjaGVzWzFdLCAxMCk7XFxuICAgICAgICAgICAgICBkYXkgPSBNYXRoLm1pbihkYXksICQuZGF0ZXBpY2tlci5fZ2V0RGF5c0luTW9udGgoeWVhciwgbW9udGgpKTtcXG4gICAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICAgIGNhc2UgXFxcInlcXFwiOlxcbiAgICAgICAgICAgIGNhc2UgXFxcIllcXFwiOlxcbiAgICAgICAgICAgICAgeWVhciArPSBwYXJzZUludChtYXRjaGVzWzFdLCAxMCk7XFxuICAgICAgICAgICAgICBkYXkgPSBNYXRoLm1pbihkYXksICQuZGF0ZXBpY2tlci5fZ2V0RGF5c0luTW9udGgoeWVhciwgbW9udGgpKTtcXG4gICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIG1hdGNoZXMgPSBwYXR0ZXJuLmV4ZWMob2Zmc2V0KTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh5ZWFyLCBtb250aCwgZGF5KTtcXG4gICAgICB9LFxcbiAgICAgICAgICBuZXdEYXRlID0gZGF0ZSA9PSBudWxsIHx8IGRhdGUgPT09IFxcXCJcXFwiID8gZGVmYXVsdERhdGUgOiB0eXBlb2YgZGF0ZSA9PT0gXFxcInN0cmluZ1xcXCIgPyBvZmZzZXRTdHJpbmcoZGF0ZSkgOiB0eXBlb2YgZGF0ZSA9PT0gXFxcIm51bWJlclxcXCIgPyBpc05hTihkYXRlKSA/IGRlZmF1bHREYXRlIDogb2Zmc2V0TnVtZXJpYyhkYXRlKSA6IG5ldyBEYXRlKGRhdGUuZ2V0VGltZSgpKTtcXG5cXG4gICAgICBuZXdEYXRlID0gbmV3RGF0ZSAmJiBuZXdEYXRlLnRvU3RyaW5nKCkgPT09IFxcXCJJbnZhbGlkIERhdGVcXFwiID8gZGVmYXVsdERhdGUgOiBuZXdEYXRlO1xcblxcbiAgICAgIGlmIChuZXdEYXRlKSB7XFxuICAgICAgICBuZXdEYXRlLnNldEhvdXJzKDApO1xcbiAgICAgICAgbmV3RGF0ZS5zZXRNaW51dGVzKDApO1xcbiAgICAgICAgbmV3RGF0ZS5zZXRTZWNvbmRzKDApO1xcbiAgICAgICAgbmV3RGF0ZS5zZXRNaWxsaXNlY29uZHMoMCk7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiB0aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdChuZXdEYXRlKTtcXG4gICAgfSxcXG5cXG4gICAgLyogSGFuZGxlIHN3aXRjaCB0by9mcm9tIGRheWxpZ2h0IHNhdmluZy5cXG4gICAgICogSG91cnMgbWF5IGJlIG5vbi16ZXJvIG9uIGRheWxpZ2h0IHNhdmluZyBjdXQtb3ZlcjpcXG4gICAgICogPiAxMiB3aGVuIG1pZG5pZ2h0IGNoYW5nZW92ZXIsIGJ1dCB0aGVuIGNhbm5vdCBnZW5lcmF0ZVxcbiAgICAgKiBtaWRuaWdodCBkYXRldGltZSwgc28ganVtcCB0byAxQU0sIG90aGVyd2lzZSByZXNldC5cXG4gICAgICogQHBhcmFtICBkYXRlICAoRGF0ZSkgdGhlIGRhdGUgdG8gY2hlY2tcXG4gICAgICogQHJldHVybiAgKERhdGUpIHRoZSBjb3JyZWN0ZWQgZGF0ZVxcbiAgICAgKi9cXG4gICAgX2RheWxpZ2h0U2F2aW5nQWRqdXN0OiBmdW5jdGlvbiBfZGF5bGlnaHRTYXZpbmdBZGp1c3QoZGF0ZSkge1xcbiAgICAgIGlmICghZGF0ZSkge1xcbiAgICAgICAgcmV0dXJuIG51bGw7XFxuICAgICAgfVxcblxcbiAgICAgIGRhdGUuc2V0SG91cnMoZGF0ZS5nZXRIb3VycygpID4gMTIgPyBkYXRlLmdldEhvdXJzKCkgKyAyIDogMCk7XFxuICAgICAgcmV0dXJuIGRhdGU7XFxuICAgIH0sXFxuXFxuICAgIC8qIFNldCB0aGUgZGF0ZShzKSBkaXJlY3RseS4gKi9cXG4gICAgX3NldERhdGU6IGZ1bmN0aW9uIF9zZXREYXRlKGluc3QsIGRhdGUsIG5vQ2hhbmdlKSB7XFxuICAgICAgdmFyIGNsZWFyID0gIWRhdGUsXFxuICAgICAgICAgIG9yaWdNb250aCA9IGluc3Quc2VsZWN0ZWRNb250aCxcXG4gICAgICAgICAgb3JpZ1llYXIgPSBpbnN0LnNlbGVjdGVkWWVhcixcXG4gICAgICAgICAgbmV3RGF0ZSA9IHRoaXMuX3Jlc3RyaWN0TWluTWF4KGluc3QsIHRoaXMuX2RldGVybWluZURhdGUoaW5zdCwgZGF0ZSwgbmV3IERhdGUoKSkpO1xcblxcbiAgICAgIGluc3Quc2VsZWN0ZWREYXkgPSBpbnN0LmN1cnJlbnREYXkgPSBuZXdEYXRlLmdldERhdGUoKTtcXG4gICAgICBpbnN0LmRyYXdNb250aCA9IGluc3Quc2VsZWN0ZWRNb250aCA9IGluc3QuY3VycmVudE1vbnRoID0gbmV3RGF0ZS5nZXRNb250aCgpO1xcbiAgICAgIGluc3QuZHJhd1llYXIgPSBpbnN0LnNlbGVjdGVkWWVhciA9IGluc3QuY3VycmVudFllYXIgPSBuZXdEYXRlLmdldEZ1bGxZZWFyKCk7XFxuXFxuICAgICAgaWYgKChvcmlnTW9udGggIT09IGluc3Quc2VsZWN0ZWRNb250aCB8fCBvcmlnWWVhciAhPT0gaW5zdC5zZWxlY3RlZFllYXIpICYmICFub0NoYW5nZSkge1xcbiAgICAgICAgdGhpcy5fbm90aWZ5Q2hhbmdlKGluc3QpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9hZGp1c3RJbnN0RGF0ZShpbnN0KTtcXG5cXG4gICAgICBpZiAoaW5zdC5pbnB1dCkge1xcbiAgICAgICAgaW5zdC5pbnB1dC52YWwoY2xlYXIgPyBcXFwiXFxcIiA6IHRoaXMuX2Zvcm1hdERhdGUoaW5zdCkpO1xcbiAgICAgIH1cXG4gICAgfSxcXG5cXG4gICAgLyogUmV0cmlldmUgdGhlIGRhdGUocykgZGlyZWN0bHkuICovXFxuICAgIF9nZXREYXRlOiBmdW5jdGlvbiBfZ2V0RGF0ZShpbnN0KSB7XFxuICAgICAgdmFyIHN0YXJ0RGF0ZSA9ICFpbnN0LmN1cnJlbnRZZWFyIHx8IGluc3QuaW5wdXQgJiYgaW5zdC5pbnB1dC52YWwoKSA9PT0gXFxcIlxcXCIgPyBudWxsIDogdGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QobmV3IERhdGUoaW5zdC5jdXJyZW50WWVhciwgaW5zdC5jdXJyZW50TW9udGgsIGluc3QuY3VycmVudERheSkpO1xcbiAgICAgIHJldHVybiBzdGFydERhdGU7XFxuICAgIH0sXFxuXFxuICAgIC8qIEF0dGFjaCB0aGUgb254eHggaGFuZGxlcnMuICBUaGVzZSBhcmUgZGVjbGFyZWQgc3RhdGljYWxseSBzb1xcbiAgICAgKiB0aGV5IHdvcmsgd2l0aCBzdGF0aWMgY29kZSB0cmFuc2Zvcm1lcnMgbGlrZSBDYWphLlxcbiAgICAgKi9cXG4gICAgX2F0dGFjaEhhbmRsZXJzOiBmdW5jdGlvbiBfYXR0YWNoSGFuZGxlcnMoaW5zdCkge1xcbiAgICAgIHZhciBzdGVwTW9udGhzID0gdGhpcy5fZ2V0KGluc3QsIFxcXCJzdGVwTW9udGhzXFxcIiksXFxuICAgICAgICAgIGlkID0gXFxcIiNcXFwiICsgaW5zdC5pZC5yZXBsYWNlKC9cXFxcXFxcXFxcXFxcXFxcL2csIFxcXCJcXFxcXFxcXFxcXCIpO1xcblxcbiAgICAgIGluc3QuZHBEaXYuZmluZChcXFwiW2RhdGEtaGFuZGxlcl1cXFwiKS5tYXAoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIGhhbmRsZXIgPSB7XFxuICAgICAgICAgIHByZXY6IGZ1bmN0aW9uIHByZXYoKSB7XFxuICAgICAgICAgICAgJC5kYXRlcGlja2VyLl9hZGp1c3REYXRlKGlkLCAtc3RlcE1vbnRocywgXFxcIk1cXFwiKTtcXG4gICAgICAgICAgfSxcXG4gICAgICAgICAgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcXG4gICAgICAgICAgICAkLmRhdGVwaWNrZXIuX2FkanVzdERhdGUoaWQsICtzdGVwTW9udGhzLCBcXFwiTVxcXCIpO1xcbiAgICAgICAgICB9LFxcbiAgICAgICAgICBoaWRlOiBmdW5jdGlvbiBoaWRlKCkge1xcbiAgICAgICAgICAgICQuZGF0ZXBpY2tlci5faGlkZURhdGVwaWNrZXIoKTtcXG4gICAgICAgICAgfSxcXG4gICAgICAgICAgdG9kYXk6IGZ1bmN0aW9uIHRvZGF5KCkge1xcbiAgICAgICAgICAgICQuZGF0ZXBpY2tlci5fZ290b1RvZGF5KGlkKTtcXG4gICAgICAgICAgfSxcXG4gICAgICAgICAgc2VsZWN0RGF5OiBmdW5jdGlvbiBzZWxlY3REYXkoKSB7XFxuICAgICAgICAgICAgJC5kYXRlcGlja2VyLl9zZWxlY3REYXkoaWQsICt0aGlzLmdldEF0dHJpYnV0ZShcXFwiZGF0YS1tb250aFxcXCIpLCArdGhpcy5nZXRBdHRyaWJ1dGUoXFxcImRhdGEteWVhclxcXCIpLCB0aGlzKTtcXG5cXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICAgIH0sXFxuICAgICAgICAgIHNlbGVjdE1vbnRoOiBmdW5jdGlvbiBzZWxlY3RNb250aCgpIHtcXG4gICAgICAgICAgICAkLmRhdGVwaWNrZXIuX3NlbGVjdE1vbnRoWWVhcihpZCwgdGhpcywgXFxcIk1cXFwiKTtcXG5cXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICAgIH0sXFxuICAgICAgICAgIHNlbGVjdFllYXI6IGZ1bmN0aW9uIHNlbGVjdFllYXIoKSB7XFxuICAgICAgICAgICAgJC5kYXRlcGlja2VyLl9zZWxlY3RNb250aFllYXIoaWQsIHRoaXMsIFxcXCJZXFxcIik7XFxuXFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9O1xcbiAgICAgICAgJCh0aGlzKS5iaW5kKHRoaXMuZ2V0QXR0cmlidXRlKFxcXCJkYXRhLWV2ZW50XFxcIiksIGhhbmRsZXJbdGhpcy5nZXRBdHRyaWJ1dGUoXFxcImRhdGEtaGFuZGxlclxcXCIpXSk7XFxuICAgICAgfSk7XFxuICAgIH0sXFxuXFxuICAgIC8qIEdlbmVyYXRlIHRoZSBIVE1MIGZvciB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgZGF0ZSBwaWNrZXIuICovXFxuICAgIF9nZW5lcmF0ZUhUTUw6IGZ1bmN0aW9uIF9nZW5lcmF0ZUhUTUwoaW5zdCkge1xcbiAgICAgIHZhciBtYXhEcmF3LFxcbiAgICAgICAgICBwcmV2VGV4dCxcXG4gICAgICAgICAgcHJldixcXG4gICAgICAgICAgbmV4dFRleHQsXFxuICAgICAgICAgIG5leHQsXFxuICAgICAgICAgIGN1cnJlbnRUZXh0LFxcbiAgICAgICAgICBnb3RvRGF0ZSxcXG4gICAgICAgICAgY29udHJvbHMsXFxuICAgICAgICAgIGJ1dHRvblBhbmVsLFxcbiAgICAgICAgICBmaXJzdERheSxcXG4gICAgICAgICAgc2hvd1dlZWssXFxuICAgICAgICAgIGRheU5hbWVzLFxcbiAgICAgICAgICBkYXlOYW1lc01pbixcXG4gICAgICAgICAgbW9udGhOYW1lcyxcXG4gICAgICAgICAgbW9udGhOYW1lc1Nob3J0LFxcbiAgICAgICAgICBiZWZvcmVTaG93RGF5LFxcbiAgICAgICAgICBzaG93T3RoZXJNb250aHMsXFxuICAgICAgICAgIHNlbGVjdE90aGVyTW9udGhzLFxcbiAgICAgICAgICBkZWZhdWx0RGF0ZSxcXG4gICAgICAgICAgaHRtbCxcXG4gICAgICAgICAgZG93LFxcbiAgICAgICAgICByb3csXFxuICAgICAgICAgIGdyb3VwLFxcbiAgICAgICAgICBjb2wsXFxuICAgICAgICAgIHNlbGVjdGVkRGF0ZSxcXG4gICAgICAgICAgY29ybmVyQ2xhc3MsXFxuICAgICAgICAgIGNhbGVuZGVyLFxcbiAgICAgICAgICB0aGVhZCxcXG4gICAgICAgICAgZGF5LFxcbiAgICAgICAgICBkYXlzSW5Nb250aCxcXG4gICAgICAgICAgbGVhZERheXMsXFxuICAgICAgICAgIGN1clJvd3MsXFxuICAgICAgICAgIG51bVJvd3MsXFxuICAgICAgICAgIHByaW50RGF0ZSxcXG4gICAgICAgICAgZFJvdyxcXG4gICAgICAgICAgdGJvZHksXFxuICAgICAgICAgIGRheVNldHRpbmdzLFxcbiAgICAgICAgICBvdGhlck1vbnRoLFxcbiAgICAgICAgICB1bnNlbGVjdGFibGUsXFxuICAgICAgICAgIHRlbXBEYXRlID0gbmV3IERhdGUoKSxcXG4gICAgICAgICAgdG9kYXkgPSB0aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdChuZXcgRGF0ZSh0ZW1wRGF0ZS5nZXRGdWxsWWVhcigpLCB0ZW1wRGF0ZS5nZXRNb250aCgpLCB0ZW1wRGF0ZS5nZXREYXRlKCkpKSxcXG4gICAgICAgICAgLy8gY2xlYXIgdGltZVxcbiAgICAgIGlzUlRMID0gdGhpcy5fZ2V0KGluc3QsIFxcXCJpc1JUTFxcXCIpLFxcbiAgICAgICAgICBzaG93QnV0dG9uUGFuZWwgPSB0aGlzLl9nZXQoaW5zdCwgXFxcInNob3dCdXR0b25QYW5lbFxcXCIpLFxcbiAgICAgICAgICBoaWRlSWZOb1ByZXZOZXh0ID0gdGhpcy5fZ2V0KGluc3QsIFxcXCJoaWRlSWZOb1ByZXZOZXh0XFxcIiksXFxuICAgICAgICAgIG5hdmlnYXRpb25Bc0RhdGVGb3JtYXQgPSB0aGlzLl9nZXQoaW5zdCwgXFxcIm5hdmlnYXRpb25Bc0RhdGVGb3JtYXRcXFwiKSxcXG4gICAgICAgICAgbnVtTW9udGhzID0gdGhpcy5fZ2V0TnVtYmVyT2ZNb250aHMoaW5zdCksXFxuICAgICAgICAgIHNob3dDdXJyZW50QXRQb3MgPSB0aGlzLl9nZXQoaW5zdCwgXFxcInNob3dDdXJyZW50QXRQb3NcXFwiKSxcXG4gICAgICAgICAgc3RlcE1vbnRocyA9IHRoaXMuX2dldChpbnN0LCBcXFwic3RlcE1vbnRoc1xcXCIpLFxcbiAgICAgICAgICBpc011bHRpTW9udGggPSBudW1Nb250aHNbMF0gIT09IDEgfHwgbnVtTW9udGhzWzFdICE9PSAxLFxcbiAgICAgICAgICBjdXJyZW50RGF0ZSA9IHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KCFpbnN0LmN1cnJlbnREYXkgPyBuZXcgRGF0ZSg5OTk5LCA5LCA5KSA6IG5ldyBEYXRlKGluc3QuY3VycmVudFllYXIsIGluc3QuY3VycmVudE1vbnRoLCBpbnN0LmN1cnJlbnREYXkpKSxcXG4gICAgICAgICAgbWluRGF0ZSA9IHRoaXMuX2dldE1pbk1heERhdGUoaW5zdCwgXFxcIm1pblxcXCIpLFxcbiAgICAgICAgICBtYXhEYXRlID0gdGhpcy5fZ2V0TWluTWF4RGF0ZShpbnN0LCBcXFwibWF4XFxcIiksXFxuICAgICAgICAgIGRyYXdNb250aCA9IGluc3QuZHJhd01vbnRoIC0gc2hvd0N1cnJlbnRBdFBvcyxcXG4gICAgICAgICAgZHJhd1llYXIgPSBpbnN0LmRyYXdZZWFyO1xcblxcbiAgICAgIGlmIChkcmF3TW9udGggPCAwKSB7XFxuICAgICAgICBkcmF3TW9udGggKz0gMTI7XFxuICAgICAgICBkcmF3WWVhci0tO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAobWF4RGF0ZSkge1xcbiAgICAgICAgbWF4RHJhdyA9IHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KG5ldyBEYXRlKG1heERhdGUuZ2V0RnVsbFllYXIoKSwgbWF4RGF0ZS5nZXRNb250aCgpIC0gbnVtTW9udGhzWzBdICogbnVtTW9udGhzWzFdICsgMSwgbWF4RGF0ZS5nZXREYXRlKCkpKTtcXG4gICAgICAgIG1heERyYXcgPSBtaW5EYXRlICYmIG1heERyYXcgPCBtaW5EYXRlID8gbWluRGF0ZSA6IG1heERyYXc7XFxuXFxuICAgICAgICB3aGlsZSAodGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QobmV3IERhdGUoZHJhd1llYXIsIGRyYXdNb250aCwgMSkpID4gbWF4RHJhdykge1xcbiAgICAgICAgICBkcmF3TW9udGgtLTtcXG5cXG4gICAgICAgICAgaWYgKGRyYXdNb250aCA8IDApIHtcXG4gICAgICAgICAgICBkcmF3TW9udGggPSAxMTtcXG4gICAgICAgICAgICBkcmF3WWVhci0tO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGluc3QuZHJhd01vbnRoID0gZHJhd01vbnRoO1xcbiAgICAgIGluc3QuZHJhd1llYXIgPSBkcmF3WWVhcjtcXG4gICAgICBwcmV2VGV4dCA9IHRoaXMuX2dldChpbnN0LCBcXFwicHJldlRleHRcXFwiKTtcXG4gICAgICBwcmV2VGV4dCA9ICFuYXZpZ2F0aW9uQXNEYXRlRm9ybWF0ID8gcHJldlRleHQgOiB0aGlzLmZvcm1hdERhdGUocHJldlRleHQsIHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KG5ldyBEYXRlKGRyYXdZZWFyLCBkcmF3TW9udGggLSBzdGVwTW9udGhzLCAxKSksIHRoaXMuX2dldEZvcm1hdENvbmZpZyhpbnN0KSk7XFxuICAgICAgcHJldiA9IHRoaXMuX2NhbkFkanVzdE1vbnRoKGluc3QsIC0xLCBkcmF3WWVhciwgZHJhd01vbnRoKSA/IFxcXCI8YSBjbGFzcz0ndWktZGF0ZXBpY2tlci1wcmV2IHVpLWNvcm5lci1hbGwnIGRhdGEtaGFuZGxlcj0ncHJldicgZGF0YS1ldmVudD0nY2xpY2snXFxcIiArIFxcXCIgdGl0bGU9J1xcXCIgKyBwcmV2VGV4dCArIFxcXCInPjxzcGFuIGNsYXNzPSd1aS1pY29uIHVpLWljb24tY2lyY2xlLXRyaWFuZ2xlLVxcXCIgKyAoaXNSVEwgPyBcXFwiZVxcXCIgOiBcXFwid1xcXCIpICsgXFxcIic+XFxcIiArIHByZXZUZXh0ICsgXFxcIjwvc3Bhbj48L2E+XFxcIiA6IGhpZGVJZk5vUHJldk5leHQgPyBcXFwiXFxcIiA6IFxcXCI8YSBjbGFzcz0ndWktZGF0ZXBpY2tlci1wcmV2IHVpLWNvcm5lci1hbGwgdWktc3RhdGUtZGlzYWJsZWQnIHRpdGxlPSdcXFwiICsgcHJldlRleHQgKyBcXFwiJz48c3BhbiBjbGFzcz0ndWktaWNvbiB1aS1pY29uLWNpcmNsZS10cmlhbmdsZS1cXFwiICsgKGlzUlRMID8gXFxcImVcXFwiIDogXFxcIndcXFwiKSArIFxcXCInPlxcXCIgKyBwcmV2VGV4dCArIFxcXCI8L3NwYW4+PC9hPlxcXCI7XFxuICAgICAgbmV4dFRleHQgPSB0aGlzLl9nZXQoaW5zdCwgXFxcIm5leHRUZXh0XFxcIik7XFxuICAgICAgbmV4dFRleHQgPSAhbmF2aWdhdGlvbkFzRGF0ZUZvcm1hdCA/IG5leHRUZXh0IDogdGhpcy5mb3JtYXREYXRlKG5leHRUZXh0LCB0aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdChuZXcgRGF0ZShkcmF3WWVhciwgZHJhd01vbnRoICsgc3RlcE1vbnRocywgMSkpLCB0aGlzLl9nZXRGb3JtYXRDb25maWcoaW5zdCkpO1xcbiAgICAgIG5leHQgPSB0aGlzLl9jYW5BZGp1c3RNb250aChpbnN0LCArMSwgZHJhd1llYXIsIGRyYXdNb250aCkgPyBcXFwiPGEgY2xhc3M9J3VpLWRhdGVwaWNrZXItbmV4dCB1aS1jb3JuZXItYWxsJyBkYXRhLWhhbmRsZXI9J25leHQnIGRhdGEtZXZlbnQ9J2NsaWNrJ1xcXCIgKyBcXFwiIHRpdGxlPSdcXFwiICsgbmV4dFRleHQgKyBcXFwiJz48c3BhbiBjbGFzcz0ndWktaWNvbiB1aS1pY29uLWNpcmNsZS10cmlhbmdsZS1cXFwiICsgKGlzUlRMID8gXFxcIndcXFwiIDogXFxcImVcXFwiKSArIFxcXCInPlxcXCIgKyBuZXh0VGV4dCArIFxcXCI8L3NwYW4+PC9hPlxcXCIgOiBoaWRlSWZOb1ByZXZOZXh0ID8gXFxcIlxcXCIgOiBcXFwiPGEgY2xhc3M9J3VpLWRhdGVwaWNrZXItbmV4dCB1aS1jb3JuZXItYWxsIHVpLXN0YXRlLWRpc2FibGVkJyB0aXRsZT0nXFxcIiArIG5leHRUZXh0ICsgXFxcIic+PHNwYW4gY2xhc3M9J3VpLWljb24gdWktaWNvbi1jaXJjbGUtdHJpYW5nbGUtXFxcIiArIChpc1JUTCA/IFxcXCJ3XFxcIiA6IFxcXCJlXFxcIikgKyBcXFwiJz5cXFwiICsgbmV4dFRleHQgKyBcXFwiPC9zcGFuPjwvYT5cXFwiO1xcbiAgICAgIGN1cnJlbnRUZXh0ID0gdGhpcy5fZ2V0KGluc3QsIFxcXCJjdXJyZW50VGV4dFxcXCIpO1xcbiAgICAgIGdvdG9EYXRlID0gdGhpcy5fZ2V0KGluc3QsIFxcXCJnb3RvQ3VycmVudFxcXCIpICYmIGluc3QuY3VycmVudERheSA/IGN1cnJlbnREYXRlIDogdG9kYXk7XFxuICAgICAgY3VycmVudFRleHQgPSAhbmF2aWdhdGlvbkFzRGF0ZUZvcm1hdCA/IGN1cnJlbnRUZXh0IDogdGhpcy5mb3JtYXREYXRlKGN1cnJlbnRUZXh0LCBnb3RvRGF0ZSwgdGhpcy5fZ2V0Rm9ybWF0Q29uZmlnKGluc3QpKTtcXG4gICAgICBjb250cm9scyA9ICFpbnN0LmlubGluZSA/IFxcXCI8YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9J3VpLWRhdGVwaWNrZXItY2xvc2UgdWktc3RhdGUtZGVmYXVsdCB1aS1wcmlvcml0eS1wcmltYXJ5IHVpLWNvcm5lci1hbGwnIGRhdGEtaGFuZGxlcj0naGlkZScgZGF0YS1ldmVudD0nY2xpY2snPlxcXCIgKyB0aGlzLl9nZXQoaW5zdCwgXFxcImNsb3NlVGV4dFxcXCIpICsgXFxcIjwvYnV0dG9uPlxcXCIgOiBcXFwiXFxcIjtcXG4gICAgICBidXR0b25QYW5lbCA9IHNob3dCdXR0b25QYW5lbCA/IFxcXCI8ZGl2IGNsYXNzPSd1aS1kYXRlcGlja2VyLWJ1dHRvbnBhbmUgdWktd2lkZ2V0LWNvbnRlbnQnPlxcXCIgKyAoaXNSVEwgPyBjb250cm9scyA6IFxcXCJcXFwiKSArICh0aGlzLl9pc0luUmFuZ2UoaW5zdCwgZ290b0RhdGUpID8gXFxcIjxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz0ndWktZGF0ZXBpY2tlci1jdXJyZW50IHVpLXN0YXRlLWRlZmF1bHQgdWktcHJpb3JpdHktc2Vjb25kYXJ5IHVpLWNvcm5lci1hbGwnIGRhdGEtaGFuZGxlcj0ndG9kYXknIGRhdGEtZXZlbnQ9J2NsaWNrJ1xcXCIgKyBcXFwiPlxcXCIgKyBjdXJyZW50VGV4dCArIFxcXCI8L2J1dHRvbj5cXFwiIDogXFxcIlxcXCIpICsgKGlzUlRMID8gXFxcIlxcXCIgOiBjb250cm9scykgKyBcXFwiPC9kaXY+XFxcIiA6IFxcXCJcXFwiO1xcbiAgICAgIGZpcnN0RGF5ID0gcGFyc2VJbnQodGhpcy5fZ2V0KGluc3QsIFxcXCJmaXJzdERheVxcXCIpLCAxMCk7XFxuICAgICAgZmlyc3REYXkgPSBpc05hTihmaXJzdERheSkgPyAwIDogZmlyc3REYXk7XFxuICAgICAgc2hvd1dlZWsgPSB0aGlzLl9nZXQoaW5zdCwgXFxcInNob3dXZWVrXFxcIik7XFxuICAgICAgZGF5TmFtZXMgPSB0aGlzLl9nZXQoaW5zdCwgXFxcImRheU5hbWVzXFxcIik7XFxuICAgICAgZGF5TmFtZXNNaW4gPSB0aGlzLl9nZXQoaW5zdCwgXFxcImRheU5hbWVzTWluXFxcIik7XFxuICAgICAgbW9udGhOYW1lcyA9IHRoaXMuX2dldChpbnN0LCBcXFwibW9udGhOYW1lc1xcXCIpO1xcbiAgICAgIG1vbnRoTmFtZXNTaG9ydCA9IHRoaXMuX2dldChpbnN0LCBcXFwibW9udGhOYW1lc1Nob3J0XFxcIik7XFxuICAgICAgYmVmb3JlU2hvd0RheSA9IHRoaXMuX2dldChpbnN0LCBcXFwiYmVmb3JlU2hvd0RheVxcXCIpO1xcbiAgICAgIHNob3dPdGhlck1vbnRocyA9IHRoaXMuX2dldChpbnN0LCBcXFwic2hvd090aGVyTW9udGhzXFxcIik7XFxuICAgICAgc2VsZWN0T3RoZXJNb250aHMgPSB0aGlzLl9nZXQoaW5zdCwgXFxcInNlbGVjdE90aGVyTW9udGhzXFxcIik7XFxuICAgICAgZGVmYXVsdERhdGUgPSB0aGlzLl9nZXREZWZhdWx0RGF0ZShpbnN0KTtcXG4gICAgICBodG1sID0gXFxcIlxcXCI7XFxuICAgICAgZG93O1xcblxcbiAgICAgIGZvciAocm93ID0gMDsgcm93IDwgbnVtTW9udGhzWzBdOyByb3crKykge1xcbiAgICAgICAgZ3JvdXAgPSBcXFwiXFxcIjtcXG4gICAgICAgIHRoaXMubWF4Um93cyA9IDQ7XFxuXFxuICAgICAgICBmb3IgKGNvbCA9IDA7IGNvbCA8IG51bU1vbnRoc1sxXTsgY29sKyspIHtcXG4gICAgICAgICAgc2VsZWN0ZWREYXRlID0gdGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QobmV3IERhdGUoZHJhd1llYXIsIGRyYXdNb250aCwgaW5zdC5zZWxlY3RlZERheSkpO1xcbiAgICAgICAgICBjb3JuZXJDbGFzcyA9IFxcXCIgdWktY29ybmVyLWFsbFxcXCI7XFxuICAgICAgICAgIGNhbGVuZGVyID0gXFxcIlxcXCI7XFxuXFxuICAgICAgICAgIGlmIChpc011bHRpTW9udGgpIHtcXG4gICAgICAgICAgICBjYWxlbmRlciArPSBcXFwiPGRpdiBjbGFzcz0ndWktZGF0ZXBpY2tlci1ncm91cFxcXCI7XFxuXFxuICAgICAgICAgICAgaWYgKG51bU1vbnRoc1sxXSA+IDEpIHtcXG4gICAgICAgICAgICAgIHN3aXRjaCAoY29sKSB7XFxuICAgICAgICAgICAgICAgIGNhc2UgMDpcXG4gICAgICAgICAgICAgICAgICBjYWxlbmRlciArPSBcXFwiIHVpLWRhdGVwaWNrZXItZ3JvdXAtZmlyc3RcXFwiO1xcbiAgICAgICAgICAgICAgICAgIGNvcm5lckNsYXNzID0gXFxcIiB1aS1jb3JuZXItXFxcIiArIChpc1JUTCA/IFxcXCJyaWdodFxcXCIgOiBcXFwibGVmdFxcXCIpO1xcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICAgICAgICBjYXNlIG51bU1vbnRoc1sxXSAtIDE6XFxuICAgICAgICAgICAgICAgICAgY2FsZW5kZXIgKz0gXFxcIiB1aS1kYXRlcGlja2VyLWdyb3VwLWxhc3RcXFwiO1xcbiAgICAgICAgICAgICAgICAgIGNvcm5lckNsYXNzID0gXFxcIiB1aS1jb3JuZXItXFxcIiArIChpc1JUTCA/IFxcXCJsZWZ0XFxcIiA6IFxcXCJyaWdodFxcXCIpO1xcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxcbiAgICAgICAgICAgICAgICAgIGNhbGVuZGVyICs9IFxcXCIgdWktZGF0ZXBpY2tlci1ncm91cC1taWRkbGVcXFwiO1xcbiAgICAgICAgICAgICAgICAgIGNvcm5lckNsYXNzID0gXFxcIlxcXCI7XFxuICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGNhbGVuZGVyICs9IFxcXCInPlxcXCI7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgY2FsZW5kZXIgKz0gXFxcIjxkaXYgY2xhc3M9J3VpLWRhdGVwaWNrZXItaGVhZGVyIHVpLXdpZGdldC1oZWFkZXIgdWktaGVscGVyLWNsZWFyZml4XFxcIiArIGNvcm5lckNsYXNzICsgXFxcIic+XFxcIiArICgvYWxsfGxlZnQvLnRlc3QoY29ybmVyQ2xhc3MpICYmIHJvdyA9PT0gMCA/IGlzUlRMID8gbmV4dCA6IHByZXYgOiBcXFwiXFxcIikgKyAoL2FsbHxyaWdodC8udGVzdChjb3JuZXJDbGFzcykgJiYgcm93ID09PSAwID8gaXNSVEwgPyBwcmV2IDogbmV4dCA6IFxcXCJcXFwiKSArIHRoaXMuX2dlbmVyYXRlTW9udGhZZWFySGVhZGVyKGluc3QsIGRyYXdNb250aCwgZHJhd1llYXIsIG1pbkRhdGUsIG1heERhdGUsIHJvdyA+IDAgfHwgY29sID4gMCwgbW9udGhOYW1lcywgbW9udGhOYW1lc1Nob3J0KSArIC8vIGRyYXcgbW9udGggaGVhZGVyc1xcbiAgICAgICAgICBcXFwiPC9kaXY+PHRhYmxlIGNsYXNzPSd1aS1kYXRlcGlja2VyLWNhbGVuZGFyJz48dGhlYWQ+XFxcIiArIFxcXCI8dHI+XFxcIjtcXG4gICAgICAgICAgdGhlYWQgPSBzaG93V2VlayA/IFxcXCI8dGggY2xhc3M9J3VpLWRhdGVwaWNrZXItd2Vlay1jb2wnPlxcXCIgKyB0aGlzLl9nZXQoaW5zdCwgXFxcIndlZWtIZWFkZXJcXFwiKSArIFxcXCI8L3RoPlxcXCIgOiBcXFwiXFxcIjtcXG5cXG4gICAgICAgICAgZm9yIChkb3cgPSAwOyBkb3cgPCA3OyBkb3crKykge1xcbiAgICAgICAgICAgIC8vIGRheXMgb2YgdGhlIHdlZWtcXG4gICAgICAgICAgICBkYXkgPSAoZG93ICsgZmlyc3REYXkpICUgNztcXG4gICAgICAgICAgICB0aGVhZCArPSBcXFwiPHRoIHNjb3BlPSdjb2wnXFxcIiArICgoZG93ICsgZmlyc3REYXkgKyA2KSAlIDcgPj0gNSA/IFxcXCIgY2xhc3M9J3VpLWRhdGVwaWNrZXItd2Vlay1lbmQnXFxcIiA6IFxcXCJcXFwiKSArIFxcXCI+XFxcIiArIFxcXCI8c3BhbiB0aXRsZT0nXFxcIiArIGRheU5hbWVzW2RheV0gKyBcXFwiJz5cXFwiICsgZGF5TmFtZXNNaW5bZGF5XSArIFxcXCI8L3NwYW4+PC90aD5cXFwiO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGNhbGVuZGVyICs9IHRoZWFkICsgXFxcIjwvdHI+PC90aGVhZD48dGJvZHk+XFxcIjtcXG4gICAgICAgICAgZGF5c0luTW9udGggPSB0aGlzLl9nZXREYXlzSW5Nb250aChkcmF3WWVhciwgZHJhd01vbnRoKTtcXG5cXG4gICAgICAgICAgaWYgKGRyYXdZZWFyID09PSBpbnN0LnNlbGVjdGVkWWVhciAmJiBkcmF3TW9udGggPT09IGluc3Quc2VsZWN0ZWRNb250aCkge1xcbiAgICAgICAgICAgIGluc3Quc2VsZWN0ZWREYXkgPSBNYXRoLm1pbihpbnN0LnNlbGVjdGVkRGF5LCBkYXlzSW5Nb250aCk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgbGVhZERheXMgPSAodGhpcy5fZ2V0Rmlyc3REYXlPZk1vbnRoKGRyYXdZZWFyLCBkcmF3TW9udGgpIC0gZmlyc3REYXkgKyA3KSAlIDc7XFxuICAgICAgICAgIGN1clJvd3MgPSBNYXRoLmNlaWwoKGxlYWREYXlzICsgZGF5c0luTW9udGgpIC8gNyk7IC8vIGNhbGN1bGF0ZSB0aGUgbnVtYmVyIG9mIHJvd3MgdG8gZ2VuZXJhdGVcXG5cXG4gICAgICAgICAgbnVtUm93cyA9IGlzTXVsdGlNb250aCA/IHRoaXMubWF4Um93cyA+IGN1clJvd3MgPyB0aGlzLm1heFJvd3MgOiBjdXJSb3dzIDogY3VyUm93czsgLy9JZiBtdWx0aXBsZSBtb250aHMsIHVzZSB0aGUgaGlnaGVyIG51bWJlciBvZiByb3dzIChzZWUgIzcwNDMpXFxuXFxuICAgICAgICAgIHRoaXMubWF4Um93cyA9IG51bVJvd3M7XFxuICAgICAgICAgIHByaW50RGF0ZSA9IHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KG5ldyBEYXRlKGRyYXdZZWFyLCBkcmF3TW9udGgsIDEgLSBsZWFkRGF5cykpO1xcblxcbiAgICAgICAgICBmb3IgKGRSb3cgPSAwOyBkUm93IDwgbnVtUm93czsgZFJvdysrKSB7XFxuICAgICAgICAgICAgLy8gY3JlYXRlIGRhdGUgcGlja2VyIHJvd3NcXG4gICAgICAgICAgICBjYWxlbmRlciArPSBcXFwiPHRyPlxcXCI7XFxuICAgICAgICAgICAgdGJvZHkgPSAhc2hvd1dlZWsgPyBcXFwiXFxcIiA6IFxcXCI8dGQgY2xhc3M9J3VpLWRhdGVwaWNrZXItd2Vlay1jb2wnPlxcXCIgKyB0aGlzLl9nZXQoaW5zdCwgXFxcImNhbGN1bGF0ZVdlZWtcXFwiKShwcmludERhdGUpICsgXFxcIjwvdGQ+XFxcIjtcXG5cXG4gICAgICAgICAgICBmb3IgKGRvdyA9IDA7IGRvdyA8IDc7IGRvdysrKSB7XFxuICAgICAgICAgICAgICAvLyBjcmVhdGUgZGF0ZSBwaWNrZXIgZGF5c1xcbiAgICAgICAgICAgICAgZGF5U2V0dGluZ3MgPSBiZWZvcmVTaG93RGF5ID8gYmVmb3JlU2hvd0RheS5hcHBseShpbnN0LmlucHV0ID8gaW5zdC5pbnB1dFswXSA6IG51bGwsIFtwcmludERhdGVdKSA6IFt0cnVlLCBcXFwiXFxcIl07XFxuICAgICAgICAgICAgICBvdGhlck1vbnRoID0gcHJpbnREYXRlLmdldE1vbnRoKCkgIT09IGRyYXdNb250aDtcXG4gICAgICAgICAgICAgIHVuc2VsZWN0YWJsZSA9IG90aGVyTW9udGggJiYgIXNlbGVjdE90aGVyTW9udGhzIHx8ICFkYXlTZXR0aW5nc1swXSB8fCBtaW5EYXRlICYmIHByaW50RGF0ZSA8IG1pbkRhdGUgfHwgbWF4RGF0ZSAmJiBwcmludERhdGUgPiBtYXhEYXRlO1xcbiAgICAgICAgICAgICAgdGJvZHkgKz0gXFxcIjx0ZCBjbGFzcz0nXFxcIiArICgoZG93ICsgZmlyc3REYXkgKyA2KSAlIDcgPj0gNSA/IFxcXCIgdWktZGF0ZXBpY2tlci13ZWVrLWVuZFxcXCIgOiBcXFwiXFxcIikgKyAoIC8vIGhpZ2hsaWdodCB3ZWVrZW5kc1xcbiAgICAgICAgICAgICAgb3RoZXJNb250aCA/IFxcXCIgdWktZGF0ZXBpY2tlci1vdGhlci1tb250aFxcXCIgOiBcXFwiXFxcIikgKyAoIC8vIGhpZ2hsaWdodCBkYXlzIGZyb20gb3RoZXIgbW9udGhzXFxuICAgICAgICAgICAgICBwcmludERhdGUuZ2V0VGltZSgpID09PSBzZWxlY3RlZERhdGUuZ2V0VGltZSgpICYmIGRyYXdNb250aCA9PT0gaW5zdC5zZWxlY3RlZE1vbnRoICYmIGluc3QuX2tleUV2ZW50IHx8IC8vIHVzZXIgcHJlc3NlZCBrZXlcXG4gICAgICAgICAgICAgIGRlZmF1bHREYXRlLmdldFRpbWUoKSA9PT0gcHJpbnREYXRlLmdldFRpbWUoKSAmJiBkZWZhdWx0RGF0ZS5nZXRUaW1lKCkgPT09IHNlbGVjdGVkRGF0ZS5nZXRUaW1lKCkgPyAvLyBvciBkZWZhdWx0RGF0ZSBpcyBjdXJyZW50IHByaW50ZWREYXRlIGFuZCBkZWZhdWx0RGF0ZSBpcyBzZWxlY3RlZERhdGVcXG4gICAgICAgICAgICAgIFxcXCIgXFxcIiArIHRoaXMuX2RheU92ZXJDbGFzcyA6IFxcXCJcXFwiKSArICggLy8gaGlnaGxpZ2h0IHNlbGVjdGVkIGRheVxcbiAgICAgICAgICAgICAgdW5zZWxlY3RhYmxlID8gXFxcIiBcXFwiICsgdGhpcy5fdW5zZWxlY3RhYmxlQ2xhc3MgKyBcXFwiIHVpLXN0YXRlLWRpc2FibGVkXFxcIiA6IFxcXCJcXFwiKSArICggLy8gaGlnaGxpZ2h0IHVuc2VsZWN0YWJsZSBkYXlzXFxuICAgICAgICAgICAgICBvdGhlck1vbnRoICYmICFzaG93T3RoZXJNb250aHMgPyBcXFwiXFxcIiA6IFxcXCIgXFxcIiArIGRheVNldHRpbmdzWzFdICsgKCAvLyBoaWdobGlnaHQgY3VzdG9tIGRhdGVzXFxuICAgICAgICAgICAgICBwcmludERhdGUuZ2V0VGltZSgpID09PSBjdXJyZW50RGF0ZS5nZXRUaW1lKCkgPyBcXFwiIFxcXCIgKyB0aGlzLl9jdXJyZW50Q2xhc3MgOiBcXFwiXFxcIikgKyAoIC8vIGhpZ2hsaWdodCBzZWxlY3RlZCBkYXlcXG4gICAgICAgICAgICAgIHByaW50RGF0ZS5nZXRUaW1lKCkgPT09IHRvZGF5LmdldFRpbWUoKSA/IFxcXCIgdWktZGF0ZXBpY2tlci10b2RheVxcXCIgOiBcXFwiXFxcIikpICsgXFxcIidcXFwiICsgKCAvLyBoaWdobGlnaHQgdG9kYXkgKGlmIGRpZmZlcmVudClcXG4gICAgICAgICAgICAgICghb3RoZXJNb250aCB8fCBzaG93T3RoZXJNb250aHMpICYmIGRheVNldHRpbmdzWzJdID8gXFxcIiB0aXRsZT0nXFxcIiArIGRheVNldHRpbmdzWzJdLnJlcGxhY2UoLycvZywgXFxcIiYjMzk7XFxcIikgKyBcXFwiJ1xcXCIgOiBcXFwiXFxcIikgKyAoIC8vIGNlbGwgdGl0bGVcXG4gICAgICAgICAgICAgIHVuc2VsZWN0YWJsZSA/IFxcXCJcXFwiIDogXFxcIiBkYXRhLWhhbmRsZXI9J3NlbGVjdERheScgZGF0YS1ldmVudD0nY2xpY2snIGRhdGEtbW9udGg9J1xcXCIgKyBwcmludERhdGUuZ2V0TW9udGgoKSArIFxcXCInIGRhdGEteWVhcj0nXFxcIiArIHByaW50RGF0ZS5nZXRGdWxsWWVhcigpICsgXFxcIidcXFwiKSArIFxcXCI+XFxcIiArICggLy8gYWN0aW9uc1xcbiAgICAgICAgICAgICAgb3RoZXJNb250aCAmJiAhc2hvd090aGVyTW9udGhzID8gXFxcIiYjeGEwO1xcXCIgOiAvLyBkaXNwbGF5IGZvciBvdGhlciBtb250aHNcXG4gICAgICAgICAgICAgIHVuc2VsZWN0YWJsZSA/IFxcXCI8c3BhbiBjbGFzcz0ndWktc3RhdGUtZGVmYXVsdCc+XFxcIiArIHByaW50RGF0ZS5nZXREYXRlKCkgKyBcXFwiPC9zcGFuPlxcXCIgOiBcXFwiPGEgY2xhc3M9J3VpLXN0YXRlLWRlZmF1bHRcXFwiICsgKHByaW50RGF0ZS5nZXRUaW1lKCkgPT09IHRvZGF5LmdldFRpbWUoKSA/IFxcXCIgdWktc3RhdGUtaGlnaGxpZ2h0XFxcIiA6IFxcXCJcXFwiKSArIChwcmludERhdGUuZ2V0VGltZSgpID09PSBjdXJyZW50RGF0ZS5nZXRUaW1lKCkgPyBcXFwiIHVpLXN0YXRlLWFjdGl2ZVxcXCIgOiBcXFwiXFxcIikgKyAoIC8vIGhpZ2hsaWdodCBzZWxlY3RlZCBkYXlcXG4gICAgICAgICAgICAgIG90aGVyTW9udGggPyBcXFwiIHVpLXByaW9yaXR5LXNlY29uZGFyeVxcXCIgOiBcXFwiXFxcIikgKyAvLyBkaXN0aW5ndWlzaCBkYXRlcyBmcm9tIG90aGVyIG1vbnRoc1xcbiAgICAgICAgICAgICAgXFxcIicgaHJlZj0nIyc+XFxcIiArIHByaW50RGF0ZS5nZXREYXRlKCkgKyBcXFwiPC9hPlxcXCIpICsgXFxcIjwvdGQ+XFxcIjsgLy8gZGlzcGxheSBzZWxlY3RhYmxlIGRhdGVcXG5cXG4gICAgICAgICAgICAgIHByaW50RGF0ZS5zZXREYXRlKHByaW50RGF0ZS5nZXREYXRlKCkgKyAxKTtcXG4gICAgICAgICAgICAgIHByaW50RGF0ZSA9IHRoaXMuX2RheWxpZ2h0U2F2aW5nQWRqdXN0KHByaW50RGF0ZSk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGNhbGVuZGVyICs9IHRib2R5ICsgXFxcIjwvdHI+XFxcIjtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBkcmF3TW9udGgrKztcXG5cXG4gICAgICAgICAgaWYgKGRyYXdNb250aCA+IDExKSB7XFxuICAgICAgICAgICAgZHJhd01vbnRoID0gMDtcXG4gICAgICAgICAgICBkcmF3WWVhcisrO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGNhbGVuZGVyICs9IFxcXCI8L3Rib2R5PjwvdGFibGU+XFxcIiArIChpc011bHRpTW9udGggPyBcXFwiPC9kaXY+XFxcIiArIChudW1Nb250aHNbMF0gPiAwICYmIGNvbCA9PT0gbnVtTW9udGhzWzFdIC0gMSA/IFxcXCI8ZGl2IGNsYXNzPSd1aS1kYXRlcGlja2VyLXJvdy1icmVhayc+PC9kaXY+XFxcIiA6IFxcXCJcXFwiKSA6IFxcXCJcXFwiKTtcXG4gICAgICAgICAgZ3JvdXAgKz0gY2FsZW5kZXI7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBodG1sICs9IGdyb3VwO1xcbiAgICAgIH1cXG5cXG4gICAgICBodG1sICs9IGJ1dHRvblBhbmVsO1xcbiAgICAgIGluc3QuX2tleUV2ZW50ID0gZmFsc2U7XFxuICAgICAgcmV0dXJuIGh0bWw7XFxuICAgIH0sXFxuXFxuICAgIC8qIEdlbmVyYXRlIHRoZSBtb250aCBhbmQgeWVhciBoZWFkZXIuICovXFxuICAgIF9nZW5lcmF0ZU1vbnRoWWVhckhlYWRlcjogZnVuY3Rpb24gX2dlbmVyYXRlTW9udGhZZWFySGVhZGVyKGluc3QsIGRyYXdNb250aCwgZHJhd1llYXIsIG1pbkRhdGUsIG1heERhdGUsIHNlY29uZGFyeSwgbW9udGhOYW1lcywgbW9udGhOYW1lc1Nob3J0KSB7XFxuICAgICAgdmFyIGluTWluWWVhcixcXG4gICAgICAgICAgaW5NYXhZZWFyLFxcbiAgICAgICAgICBtb250aCxcXG4gICAgICAgICAgeWVhcnMsXFxuICAgICAgICAgIHRoaXNZZWFyLFxcbiAgICAgICAgICBkZXRlcm1pbmVZZWFyLFxcbiAgICAgICAgICB5ZWFyLFxcbiAgICAgICAgICBlbmRZZWFyLFxcbiAgICAgICAgICBjaGFuZ2VNb250aCA9IHRoaXMuX2dldChpbnN0LCBcXFwiY2hhbmdlTW9udGhcXFwiKSxcXG4gICAgICAgICAgY2hhbmdlWWVhciA9IHRoaXMuX2dldChpbnN0LCBcXFwiY2hhbmdlWWVhclxcXCIpLFxcbiAgICAgICAgICBzaG93TW9udGhBZnRlclllYXIgPSB0aGlzLl9nZXQoaW5zdCwgXFxcInNob3dNb250aEFmdGVyWWVhclxcXCIpLFxcbiAgICAgICAgICBodG1sID0gXFxcIjxkaXYgY2xhc3M9J3VpLWRhdGVwaWNrZXItdGl0bGUnPlxcXCIsXFxuICAgICAgICAgIG1vbnRoSHRtbCA9IFxcXCJcXFwiOyAvLyBtb250aCBzZWxlY3Rpb25cXG5cXG5cXG4gICAgICBpZiAoc2Vjb25kYXJ5IHx8ICFjaGFuZ2VNb250aCkge1xcbiAgICAgICAgbW9udGhIdG1sICs9IFxcXCI8c3BhbiBjbGFzcz0ndWktZGF0ZXBpY2tlci1tb250aCc+XFxcIiArIG1vbnRoTmFtZXNbZHJhd01vbnRoXSArIFxcXCI8L3NwYW4+XFxcIjtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgaW5NaW5ZZWFyID0gbWluRGF0ZSAmJiBtaW5EYXRlLmdldEZ1bGxZZWFyKCkgPT09IGRyYXdZZWFyO1xcbiAgICAgICAgaW5NYXhZZWFyID0gbWF4RGF0ZSAmJiBtYXhEYXRlLmdldEZ1bGxZZWFyKCkgPT09IGRyYXdZZWFyO1xcbiAgICAgICAgbW9udGhIdG1sICs9IFxcXCI8c2VsZWN0IGNsYXNzPSd1aS1kYXRlcGlja2VyLW1vbnRoJyBkYXRhLWhhbmRsZXI9J3NlbGVjdE1vbnRoJyBkYXRhLWV2ZW50PSdjaGFuZ2UnPlxcXCI7XFxuXFxuICAgICAgICBmb3IgKG1vbnRoID0gMDsgbW9udGggPCAxMjsgbW9udGgrKykge1xcbiAgICAgICAgICBpZiAoKCFpbk1pblllYXIgfHwgbW9udGggPj0gbWluRGF0ZS5nZXRNb250aCgpKSAmJiAoIWluTWF4WWVhciB8fCBtb250aCA8PSBtYXhEYXRlLmdldE1vbnRoKCkpKSB7XFxuICAgICAgICAgICAgbW9udGhIdG1sICs9IFxcXCI8b3B0aW9uIHZhbHVlPSdcXFwiICsgbW9udGggKyBcXFwiJ1xcXCIgKyAobW9udGggPT09IGRyYXdNb250aCA/IFxcXCIgc2VsZWN0ZWQ9J3NlbGVjdGVkJ1xcXCIgOiBcXFwiXFxcIikgKyBcXFwiPlxcXCIgKyBtb250aE5hbWVzU2hvcnRbbW9udGhdICsgXFxcIjwvb3B0aW9uPlxcXCI7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIG1vbnRoSHRtbCArPSBcXFwiPC9zZWxlY3Q+XFxcIjtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCFzaG93TW9udGhBZnRlclllYXIpIHtcXG4gICAgICAgIGh0bWwgKz0gbW9udGhIdG1sICsgKHNlY29uZGFyeSB8fCAhKGNoYW5nZU1vbnRoICYmIGNoYW5nZVllYXIpID8gXFxcIiYjeGEwO1xcXCIgOiBcXFwiXFxcIik7XFxuICAgICAgfSAvLyB5ZWFyIHNlbGVjdGlvblxcblxcblxcbiAgICAgIGlmICghaW5zdC55ZWFyc2h0bWwpIHtcXG4gICAgICAgIGluc3QueWVhcnNodG1sID0gXFxcIlxcXCI7XFxuXFxuICAgICAgICBpZiAoc2Vjb25kYXJ5IHx8ICFjaGFuZ2VZZWFyKSB7XFxuICAgICAgICAgIGh0bWwgKz0gXFxcIjxzcGFuIGNsYXNzPSd1aS1kYXRlcGlja2VyLXllYXInPlxcXCIgKyBkcmF3WWVhciArIFxcXCI8L3NwYW4+XFxcIjtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIC8vIGRldGVybWluZSByYW5nZSBvZiB5ZWFycyB0byBkaXNwbGF5XFxuICAgICAgICAgIHllYXJzID0gdGhpcy5fZ2V0KGluc3QsIFxcXCJ5ZWFyUmFuZ2VcXFwiKS5zcGxpdChcXFwiOlxcXCIpO1xcbiAgICAgICAgICB0aGlzWWVhciA9IG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKTtcXG5cXG4gICAgICAgICAgZGV0ZXJtaW5lWWVhciA9IGZ1bmN0aW9uIGRldGVybWluZVllYXIodmFsdWUpIHtcXG4gICAgICAgICAgICB2YXIgeWVhciA9IHZhbHVlLm1hdGNoKC9jWytcXFxcLV0uKi8pID8gZHJhd1llYXIgKyBwYXJzZUludCh2YWx1ZS5zdWJzdHJpbmcoMSksIDEwKSA6IHZhbHVlLm1hdGNoKC9bK1xcXFwtXS4qLykgPyB0aGlzWWVhciArIHBhcnNlSW50KHZhbHVlLCAxMCkgOiBwYXJzZUludCh2YWx1ZSwgMTApO1xcbiAgICAgICAgICAgIHJldHVybiBpc05hTih5ZWFyKSA/IHRoaXNZZWFyIDogeWVhcjtcXG4gICAgICAgICAgfTtcXG5cXG4gICAgICAgICAgeWVhciA9IGRldGVybWluZVllYXIoeWVhcnNbMF0pO1xcbiAgICAgICAgICBlbmRZZWFyID0gTWF0aC5tYXgoeWVhciwgZGV0ZXJtaW5lWWVhcih5ZWFyc1sxXSB8fCBcXFwiXFxcIikpO1xcbiAgICAgICAgICB5ZWFyID0gbWluRGF0ZSA/IE1hdGgubWF4KHllYXIsIG1pbkRhdGUuZ2V0RnVsbFllYXIoKSkgOiB5ZWFyO1xcbiAgICAgICAgICBlbmRZZWFyID0gbWF4RGF0ZSA/IE1hdGgubWluKGVuZFllYXIsIG1heERhdGUuZ2V0RnVsbFllYXIoKSkgOiBlbmRZZWFyO1xcbiAgICAgICAgICBpbnN0LnllYXJzaHRtbCArPSBcXFwiPHNlbGVjdCBjbGFzcz0ndWktZGF0ZXBpY2tlci15ZWFyJyBkYXRhLWhhbmRsZXI9J3NlbGVjdFllYXInIGRhdGEtZXZlbnQ9J2NoYW5nZSc+XFxcIjtcXG5cXG4gICAgICAgICAgZm9yICg7IHllYXIgPD0gZW5kWWVhcjsgeWVhcisrKSB7XFxuICAgICAgICAgICAgaW5zdC55ZWFyc2h0bWwgKz0gXFxcIjxvcHRpb24gdmFsdWU9J1xcXCIgKyB5ZWFyICsgXFxcIidcXFwiICsgKHllYXIgPT09IGRyYXdZZWFyID8gXFxcIiBzZWxlY3RlZD0nc2VsZWN0ZWQnXFxcIiA6IFxcXCJcXFwiKSArIFxcXCI+XFxcIiArIHllYXIgKyBcXFwiPC9vcHRpb24+XFxcIjtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpbnN0LnllYXJzaHRtbCArPSBcXFwiPC9zZWxlY3Q+XFxcIjtcXG4gICAgICAgICAgaHRtbCArPSBpbnN0LnllYXJzaHRtbDtcXG4gICAgICAgICAgaW5zdC55ZWFyc2h0bWwgPSBudWxsO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBodG1sICs9IHRoaXMuX2dldChpbnN0LCBcXFwieWVhclN1ZmZpeFxcXCIpO1xcblxcbiAgICAgIGlmIChzaG93TW9udGhBZnRlclllYXIpIHtcXG4gICAgICAgIGh0bWwgKz0gKHNlY29uZGFyeSB8fCAhKGNoYW5nZU1vbnRoICYmIGNoYW5nZVllYXIpID8gXFxcIiYjeGEwO1xcXCIgOiBcXFwiXFxcIikgKyBtb250aEh0bWw7XFxuICAgICAgfVxcblxcbiAgICAgIGh0bWwgKz0gXFxcIjwvZGl2PlxcXCI7IC8vIENsb3NlIGRhdGVwaWNrZXJfaGVhZGVyXFxuXFxuICAgICAgcmV0dXJuIGh0bWw7XFxuICAgIH0sXFxuXFxuICAgIC8qIEFkanVzdCBvbmUgb2YgdGhlIGRhdGUgc3ViLWZpZWxkcy4gKi9cXG4gICAgX2FkanVzdEluc3REYXRlOiBmdW5jdGlvbiBfYWRqdXN0SW5zdERhdGUoaW5zdCwgb2Zmc2V0LCBwZXJpb2QpIHtcXG4gICAgICB2YXIgeWVhciA9IGluc3QuZHJhd1llYXIgKyAocGVyaW9kID09PSBcXFwiWVxcXCIgPyBvZmZzZXQgOiAwKSxcXG4gICAgICAgICAgbW9udGggPSBpbnN0LmRyYXdNb250aCArIChwZXJpb2QgPT09IFxcXCJNXFxcIiA/IG9mZnNldCA6IDApLFxcbiAgICAgICAgICBkYXkgPSBNYXRoLm1pbihpbnN0LnNlbGVjdGVkRGF5LCB0aGlzLl9nZXREYXlzSW5Nb250aCh5ZWFyLCBtb250aCkpICsgKHBlcmlvZCA9PT0gXFxcIkRcXFwiID8gb2Zmc2V0IDogMCksXFxuICAgICAgICAgIGRhdGUgPSB0aGlzLl9yZXN0cmljdE1pbk1heChpbnN0LCB0aGlzLl9kYXlsaWdodFNhdmluZ0FkanVzdChuZXcgRGF0ZSh5ZWFyLCBtb250aCwgZGF5KSkpO1xcblxcbiAgICAgIGluc3Quc2VsZWN0ZWREYXkgPSBkYXRlLmdldERhdGUoKTtcXG4gICAgICBpbnN0LmRyYXdNb250aCA9IGluc3Quc2VsZWN0ZWRNb250aCA9IGRhdGUuZ2V0TW9udGgoKTtcXG4gICAgICBpbnN0LmRyYXdZZWFyID0gaW5zdC5zZWxlY3RlZFllYXIgPSBkYXRlLmdldEZ1bGxZZWFyKCk7XFxuXFxuICAgICAgaWYgKHBlcmlvZCA9PT0gXFxcIk1cXFwiIHx8IHBlcmlvZCA9PT0gXFxcIllcXFwiKSB7XFxuICAgICAgICB0aGlzLl9ub3RpZnlDaGFuZ2UoaW5zdCk7XFxuICAgICAgfVxcbiAgICB9LFxcblxcbiAgICAvKiBFbnN1cmUgYSBkYXRlIGlzIHdpdGhpbiBhbnkgbWluL21heCBib3VuZHMuICovXFxuICAgIF9yZXN0cmljdE1pbk1heDogZnVuY3Rpb24gX3Jlc3RyaWN0TWluTWF4KGluc3QsIGRhdGUpIHtcXG4gICAgICB2YXIgbWluRGF0ZSA9IHRoaXMuX2dldE1pbk1heERhdGUoaW5zdCwgXFxcIm1pblxcXCIpLFxcbiAgICAgICAgICBtYXhEYXRlID0gdGhpcy5fZ2V0TWluTWF4RGF0ZShpbnN0LCBcXFwibWF4XFxcIiksXFxuICAgICAgICAgIG5ld0RhdGUgPSBtaW5EYXRlICYmIGRhdGUgPCBtaW5EYXRlID8gbWluRGF0ZSA6IGRhdGU7XFxuXFxuICAgICAgcmV0dXJuIG1heERhdGUgJiYgbmV3RGF0ZSA+IG1heERhdGUgPyBtYXhEYXRlIDogbmV3RGF0ZTtcXG4gICAgfSxcXG5cXG4gICAgLyogTm90aWZ5IGNoYW5nZSBvZiBtb250aC95ZWFyLiAqL1xcbiAgICBfbm90aWZ5Q2hhbmdlOiBmdW5jdGlvbiBfbm90aWZ5Q2hhbmdlKGluc3QpIHtcXG4gICAgICB2YXIgb25DaGFuZ2UgPSB0aGlzLl9nZXQoaW5zdCwgXFxcIm9uQ2hhbmdlTW9udGhZZWFyXFxcIik7XFxuXFxuICAgICAgaWYgKG9uQ2hhbmdlKSB7XFxuICAgICAgICBvbkNoYW5nZS5hcHBseShpbnN0LmlucHV0ID8gaW5zdC5pbnB1dFswXSA6IG51bGwsIFtpbnN0LnNlbGVjdGVkWWVhciwgaW5zdC5zZWxlY3RlZE1vbnRoICsgMSwgaW5zdF0pO1xcbiAgICAgIH1cXG4gICAgfSxcXG5cXG4gICAgLyogRGV0ZXJtaW5lIHRoZSBudW1iZXIgb2YgbW9udGhzIHRvIHNob3cuICovXFxuICAgIF9nZXROdW1iZXJPZk1vbnRoczogZnVuY3Rpb24gX2dldE51bWJlck9mTW9udGhzKGluc3QpIHtcXG4gICAgICB2YXIgbnVtTW9udGhzID0gdGhpcy5fZ2V0KGluc3QsIFxcXCJudW1iZXJPZk1vbnRoc1xcXCIpO1xcblxcbiAgICAgIHJldHVybiBudW1Nb250aHMgPT0gbnVsbCA/IFsxLCAxXSA6IHR5cGVvZiBudW1Nb250aHMgPT09IFxcXCJudW1iZXJcXFwiID8gWzEsIG51bU1vbnRoc10gOiBudW1Nb250aHM7XFxuICAgIH0sXFxuXFxuICAgIC8qIERldGVybWluZSB0aGUgY3VycmVudCBtYXhpbXVtIGRhdGUgLSBlbnN1cmUgbm8gdGltZSBjb21wb25lbnRzIGFyZSBzZXQuICovXFxuICAgIF9nZXRNaW5NYXhEYXRlOiBmdW5jdGlvbiBfZ2V0TWluTWF4RGF0ZShpbnN0LCBtaW5NYXgpIHtcXG4gICAgICByZXR1cm4gdGhpcy5fZGV0ZXJtaW5lRGF0ZShpbnN0LCB0aGlzLl9nZXQoaW5zdCwgbWluTWF4ICsgXFxcIkRhdGVcXFwiKSwgbnVsbCk7XFxuICAgIH0sXFxuXFxuICAgIC8qIEZpbmQgdGhlIG51bWJlciBvZiBkYXlzIGluIGEgZ2l2ZW4gbW9udGguICovXFxuICAgIF9nZXREYXlzSW5Nb250aDogZnVuY3Rpb24gX2dldERheXNJbk1vbnRoKHllYXIsIG1vbnRoKSB7XFxuICAgICAgcmV0dXJuIDMyIC0gdGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QobmV3IERhdGUoeWVhciwgbW9udGgsIDMyKSkuZ2V0RGF0ZSgpO1xcbiAgICB9LFxcblxcbiAgICAvKiBGaW5kIHRoZSBkYXkgb2YgdGhlIHdlZWsgb2YgdGhlIGZpcnN0IG9mIGEgbW9udGguICovXFxuICAgIF9nZXRGaXJzdERheU9mTW9udGg6IGZ1bmN0aW9uIF9nZXRGaXJzdERheU9mTW9udGgoeWVhciwgbW9udGgpIHtcXG4gICAgICByZXR1cm4gbmV3IERhdGUoeWVhciwgbW9udGgsIDEpLmdldERheSgpO1xcbiAgICB9LFxcblxcbiAgICAvKiBEZXRlcm1pbmVzIGlmIHdlIHNob3VsZCBhbGxvdyBhIFxcXCJuZXh0L3ByZXZcXFwiIG1vbnRoIGRpc3BsYXkgY2hhbmdlLiAqL1xcbiAgICBfY2FuQWRqdXN0TW9udGg6IGZ1bmN0aW9uIF9jYW5BZGp1c3RNb250aChpbnN0LCBvZmZzZXQsIGN1clllYXIsIGN1ck1vbnRoKSB7XFxuICAgICAgdmFyIG51bU1vbnRocyA9IHRoaXMuX2dldE51bWJlck9mTW9udGhzKGluc3QpLFxcbiAgICAgICAgICBkYXRlID0gdGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QobmV3IERhdGUoY3VyWWVhciwgY3VyTW9udGggKyAob2Zmc2V0IDwgMCA/IG9mZnNldCA6IG51bU1vbnRoc1swXSAqIG51bU1vbnRoc1sxXSksIDEpKTtcXG5cXG4gICAgICBpZiAob2Zmc2V0IDwgMCkge1xcbiAgICAgICAgZGF0ZS5zZXREYXRlKHRoaXMuX2dldERheXNJbk1vbnRoKGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpKSk7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiB0aGlzLl9pc0luUmFuZ2UoaW5zdCwgZGF0ZSk7XFxuICAgIH0sXFxuXFxuICAgIC8qIElzIHRoZSBnaXZlbiBkYXRlIGluIHRoZSBhY2NlcHRlZCByYW5nZT8gKi9cXG4gICAgX2lzSW5SYW5nZTogZnVuY3Rpb24gX2lzSW5SYW5nZShpbnN0LCBkYXRlKSB7XFxuICAgICAgdmFyIHllYXJTcGxpdCxcXG4gICAgICAgICAgY3VycmVudFllYXIsXFxuICAgICAgICAgIG1pbkRhdGUgPSB0aGlzLl9nZXRNaW5NYXhEYXRlKGluc3QsIFxcXCJtaW5cXFwiKSxcXG4gICAgICAgICAgbWF4RGF0ZSA9IHRoaXMuX2dldE1pbk1heERhdGUoaW5zdCwgXFxcIm1heFxcXCIpLFxcbiAgICAgICAgICBtaW5ZZWFyID0gbnVsbCxcXG4gICAgICAgICAgbWF4WWVhciA9IG51bGwsXFxuICAgICAgICAgIHllYXJzID0gdGhpcy5fZ2V0KGluc3QsIFxcXCJ5ZWFyUmFuZ2VcXFwiKTtcXG5cXG4gICAgICBpZiAoeWVhcnMpIHtcXG4gICAgICAgIHllYXJTcGxpdCA9IHllYXJzLnNwbGl0KFxcXCI6XFxcIik7XFxuICAgICAgICBjdXJyZW50WWVhciA9IG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKTtcXG4gICAgICAgIG1pblllYXIgPSBwYXJzZUludCh5ZWFyU3BsaXRbMF0sIDEwKTtcXG4gICAgICAgIG1heFllYXIgPSBwYXJzZUludCh5ZWFyU3BsaXRbMV0sIDEwKTtcXG5cXG4gICAgICAgIGlmICh5ZWFyU3BsaXRbMF0ubWF0Y2goL1srXFxcXC1dLiovKSkge1xcbiAgICAgICAgICBtaW5ZZWFyICs9IGN1cnJlbnRZZWFyO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKHllYXJTcGxpdFsxXS5tYXRjaCgvWytcXFxcLV0uKi8pKSB7XFxuICAgICAgICAgIG1heFllYXIgKz0gY3VycmVudFllYXI7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiAoIW1pbkRhdGUgfHwgZGF0ZS5nZXRUaW1lKCkgPj0gbWluRGF0ZS5nZXRUaW1lKCkpICYmICghbWF4RGF0ZSB8fCBkYXRlLmdldFRpbWUoKSA8PSBtYXhEYXRlLmdldFRpbWUoKSkgJiYgKCFtaW5ZZWFyIHx8IGRhdGUuZ2V0RnVsbFllYXIoKSA+PSBtaW5ZZWFyKSAmJiAoIW1heFllYXIgfHwgZGF0ZS5nZXRGdWxsWWVhcigpIDw9IG1heFllYXIpO1xcbiAgICB9LFxcblxcbiAgICAvKiBQcm92aWRlIHRoZSBjb25maWd1cmF0aW9uIHNldHRpbmdzIGZvciBmb3JtYXR0aW5nL3BhcnNpbmcuICovXFxuICAgIF9nZXRGb3JtYXRDb25maWc6IGZ1bmN0aW9uIF9nZXRGb3JtYXRDb25maWcoaW5zdCkge1xcbiAgICAgIHZhciBzaG9ydFllYXJDdXRvZmYgPSB0aGlzLl9nZXQoaW5zdCwgXFxcInNob3J0WWVhckN1dG9mZlxcXCIpO1xcblxcbiAgICAgIHNob3J0WWVhckN1dG9mZiA9IHR5cGVvZiBzaG9ydFllYXJDdXRvZmYgIT09IFxcXCJzdHJpbmdcXFwiID8gc2hvcnRZZWFyQ3V0b2ZmIDogbmV3IERhdGUoKS5nZXRGdWxsWWVhcigpICUgMTAwICsgcGFyc2VJbnQoc2hvcnRZZWFyQ3V0b2ZmLCAxMCk7XFxuICAgICAgcmV0dXJuIHtcXG4gICAgICAgIHNob3J0WWVhckN1dG9mZjogc2hvcnRZZWFyQ3V0b2ZmLFxcbiAgICAgICAgZGF5TmFtZXNTaG9ydDogdGhpcy5fZ2V0KGluc3QsIFxcXCJkYXlOYW1lc1Nob3J0XFxcIiksXFxuICAgICAgICBkYXlOYW1lczogdGhpcy5fZ2V0KGluc3QsIFxcXCJkYXlOYW1lc1xcXCIpLFxcbiAgICAgICAgbW9udGhOYW1lc1Nob3J0OiB0aGlzLl9nZXQoaW5zdCwgXFxcIm1vbnRoTmFtZXNTaG9ydFxcXCIpLFxcbiAgICAgICAgbW9udGhOYW1lczogdGhpcy5fZ2V0KGluc3QsIFxcXCJtb250aE5hbWVzXFxcIilcXG4gICAgICB9O1xcbiAgICB9LFxcblxcbiAgICAvKiBGb3JtYXQgdGhlIGdpdmVuIGRhdGUgZm9yIGRpc3BsYXkuICovXFxuICAgIF9mb3JtYXREYXRlOiBmdW5jdGlvbiBfZm9ybWF0RGF0ZShpbnN0LCBkYXksIG1vbnRoLCB5ZWFyKSB7XFxuICAgICAgaWYgKCFkYXkpIHtcXG4gICAgICAgIGluc3QuY3VycmVudERheSA9IGluc3Quc2VsZWN0ZWREYXk7XFxuICAgICAgICBpbnN0LmN1cnJlbnRNb250aCA9IGluc3Quc2VsZWN0ZWRNb250aDtcXG4gICAgICAgIGluc3QuY3VycmVudFllYXIgPSBpbnN0LnNlbGVjdGVkWWVhcjtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIGRhdGUgPSBkYXkgPyBfdHlwZW9mKGRheSkgPT09IFxcXCJvYmplY3RcXFwiID8gZGF5IDogdGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QobmV3IERhdGUoeWVhciwgbW9udGgsIGRheSkpIDogdGhpcy5fZGF5bGlnaHRTYXZpbmdBZGp1c3QobmV3IERhdGUoaW5zdC5jdXJyZW50WWVhciwgaW5zdC5jdXJyZW50TW9udGgsIGluc3QuY3VycmVudERheSkpO1xcbiAgICAgIHJldHVybiB0aGlzLmZvcm1hdERhdGUodGhpcy5fZ2V0KGluc3QsIFxcXCJkYXRlRm9ybWF0XFxcIiksIGRhdGUsIHRoaXMuX2dldEZvcm1hdENvbmZpZyhpbnN0KSk7XFxuICAgIH1cXG4gIH0pO1xcbiAgLypcXG4gICAqIEJpbmQgaG92ZXIgZXZlbnRzIGZvciBkYXRlcGlja2VyIGVsZW1lbnRzLlxcbiAgICogRG9uZSB2aWEgZGVsZWdhdGUgc28gdGhlIGJpbmRpbmcgb25seSBvY2N1cnMgb25jZSBpbiB0aGUgbGlmZXRpbWUgb2YgdGhlIHBhcmVudCBkaXYuXFxuICAgKiBHbG9iYWwgZGF0ZXBpY2tlcl9pbnN0QWN0aXZlLCBzZXQgYnkgX3VwZGF0ZURhdGVwaWNrZXIgYWxsb3dzIHRoZSBoYW5kbGVycyB0byBmaW5kIHRoZWlyIHdheSBiYWNrIHRvIHRoZSBhY3RpdmUgcGlja2VyLlxcbiAgICovXFxuXFxuICBmdW5jdGlvbiBkYXRlcGlja2VyX2JpbmRIb3ZlcihkcERpdikge1xcbiAgICB2YXIgc2VsZWN0b3IgPSBcXFwiYnV0dG9uLCAudWktZGF0ZXBpY2tlci1wcmV2LCAudWktZGF0ZXBpY2tlci1uZXh0LCAudWktZGF0ZXBpY2tlci1jYWxlbmRhciB0ZCBhXFxcIjtcXG4gICAgcmV0dXJuIGRwRGl2LmRlbGVnYXRlKHNlbGVjdG9yLCBcXFwibW91c2VvdXRcXFwiLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgJCh0aGlzKS5yZW1vdmVDbGFzcyhcXFwidWktc3RhdGUtaG92ZXJcXFwiKTtcXG5cXG4gICAgICBpZiAodGhpcy5jbGFzc05hbWUuaW5kZXhPZihcXFwidWktZGF0ZXBpY2tlci1wcmV2XFxcIikgIT09IC0xKSB7XFxuICAgICAgICAkKHRoaXMpLnJlbW92ZUNsYXNzKFxcXCJ1aS1kYXRlcGlja2VyLXByZXYtaG92ZXJcXFwiKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMuY2xhc3NOYW1lLmluZGV4T2YoXFxcInVpLWRhdGVwaWNrZXItbmV4dFxcXCIpICE9PSAtMSkge1xcbiAgICAgICAgJCh0aGlzKS5yZW1vdmVDbGFzcyhcXFwidWktZGF0ZXBpY2tlci1uZXh0LWhvdmVyXFxcIik7XFxuICAgICAgfVxcbiAgICB9KS5kZWxlZ2F0ZShzZWxlY3RvciwgXFxcIm1vdXNlb3ZlclxcXCIsIGRhdGVwaWNrZXJfaGFuZGxlTW91c2VvdmVyKTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGRhdGVwaWNrZXJfaGFuZGxlTW91c2VvdmVyKCkge1xcbiAgICBpZiAoISQuZGF0ZXBpY2tlci5faXNEaXNhYmxlZERhdGVwaWNrZXIoZGF0ZXBpY2tlcl9pbnN0QWN0aXZlLmlubGluZSA/IGRhdGVwaWNrZXJfaW5zdEFjdGl2ZS5kcERpdi5wYXJlbnQoKVswXSA6IGRhdGVwaWNrZXJfaW5zdEFjdGl2ZS5pbnB1dFswXSkpIHtcXG4gICAgICAkKHRoaXMpLnBhcmVudHMoXFxcIi51aS1kYXRlcGlja2VyLWNhbGVuZGFyXFxcIikuZmluZChcXFwiYVxcXCIpLnJlbW92ZUNsYXNzKFxcXCJ1aS1zdGF0ZS1ob3ZlclxcXCIpO1xcbiAgICAgICQodGhpcykuYWRkQ2xhc3MoXFxcInVpLXN0YXRlLWhvdmVyXFxcIik7XFxuXFxuICAgICAgaWYgKHRoaXMuY2xhc3NOYW1lLmluZGV4T2YoXFxcInVpLWRhdGVwaWNrZXItcHJldlxcXCIpICE9PSAtMSkge1xcbiAgICAgICAgJCh0aGlzKS5hZGRDbGFzcyhcXFwidWktZGF0ZXBpY2tlci1wcmV2LWhvdmVyXFxcIik7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLmNsYXNzTmFtZS5pbmRleE9mKFxcXCJ1aS1kYXRlcGlja2VyLW5leHRcXFwiKSAhPT0gLTEpIHtcXG4gICAgICAgICQodGhpcykuYWRkQ2xhc3MoXFxcInVpLWRhdGVwaWNrZXItbmV4dC1ob3ZlclxcXCIpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcbiAgLyogalF1ZXJ5IGV4dGVuZCBub3cgaWdub3JlcyBudWxscyEgKi9cXG5cXG5cXG4gIGZ1bmN0aW9uIGRhdGVwaWNrZXJfZXh0ZW5kUmVtb3ZlKHRhcmdldCwgcHJvcHMpIHtcXG4gICAgJC5leHRlbmQodGFyZ2V0LCBwcm9wcyk7XFxuXFxuICAgIGZvciAodmFyIG5hbWUgaW4gcHJvcHMpIHtcXG4gICAgICBpZiAocHJvcHNbbmFtZV0gPT0gbnVsbCkge1xcbiAgICAgICAgdGFyZ2V0W25hbWVdID0gcHJvcHNbbmFtZV07XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHJldHVybiB0YXJnZXQ7XFxuICB9XFxuICAvKiBJbnZva2UgdGhlIGRhdGVwaWNrZXIgZnVuY3Rpb25hbGl0eS5cXG4gICAgIEBwYXJhbSAgb3B0aW9ucyAgc3RyaW5nIC0gYSBjb21tYW5kLCBvcHRpb25hbGx5IGZvbGxvd2VkIGJ5IGFkZGl0aW9uYWwgcGFyYW1ldGVycyBvclxcbiAgXFx0XFx0XFx0XFx0XFx0T2JqZWN0IC0gc2V0dGluZ3MgZm9yIGF0dGFjaGluZyBuZXcgZGF0ZXBpY2tlciBmdW5jdGlvbmFsaXR5XFxuICAgICBAcmV0dXJuICBqUXVlcnkgb2JqZWN0ICovXFxuXFxuXFxuICAkLmZuLmRhdGVwaWNrZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xcbiAgICAvKiBWZXJpZnkgYW4gZW1wdHkgY29sbGVjdGlvbiB3YXNuJ3QgcGFzc2VkIC0gRml4ZXMgIzY5NzYgKi9cXG4gICAgaWYgKCF0aGlzLmxlbmd0aCkge1xcbiAgICAgIHJldHVybiB0aGlzO1xcbiAgICB9XFxuICAgIC8qIEluaXRpYWxpc2UgdGhlIGRhdGUgcGlja2VyLiAqL1xcblxcblxcbiAgICBpZiAoISQuZGF0ZXBpY2tlci5pbml0aWFsaXplZCkge1xcbiAgICAgICQoZG9jdW1lbnQpLm1vdXNlZG93bigkLmRhdGVwaWNrZXIuX2NoZWNrRXh0ZXJuYWxDbGljayk7XFxuICAgICAgJC5kYXRlcGlja2VyLmluaXRpYWxpemVkID0gdHJ1ZTtcXG4gICAgfVxcbiAgICAvKiBBcHBlbmQgZGF0ZXBpY2tlciBtYWluIGNvbnRhaW5lciB0byBib2R5IGlmIG5vdCBleGlzdC4gKi9cXG5cXG5cXG4gICAgaWYgKCQoXFxcIiNcXFwiICsgJC5kYXRlcGlja2VyLl9tYWluRGl2SWQpLmxlbmd0aCA9PT0gMCkge1xcbiAgICAgICQoXFxcImJvZHlcXFwiKS5hcHBlbmQoJC5kYXRlcGlja2VyLmRwRGl2KTtcXG4gICAgfVxcblxcbiAgICB2YXIgb3RoZXJBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcXG5cXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcXFwic3RyaW5nXFxcIiAmJiAob3B0aW9ucyA9PT0gXFxcImlzRGlzYWJsZWRcXFwiIHx8IG9wdGlvbnMgPT09IFxcXCJnZXREYXRlXFxcIiB8fCBvcHRpb25zID09PSBcXFwid2lkZ2V0XFxcIikpIHtcXG4gICAgICByZXR1cm4gJC5kYXRlcGlja2VyW1xcXCJfXFxcIiArIG9wdGlvbnMgKyBcXFwiRGF0ZXBpY2tlclxcXCJdLmFwcGx5KCQuZGF0ZXBpY2tlciwgW3RoaXNbMF1dLmNvbmNhdChvdGhlckFyZ3MpKTtcXG4gICAgfVxcblxcbiAgICBpZiAob3B0aW9ucyA9PT0gXFxcIm9wdGlvblxcXCIgJiYgYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiB0eXBlb2YgYXJndW1lbnRzWzFdID09PSBcXFwic3RyaW5nXFxcIikge1xcbiAgICAgIHJldHVybiAkLmRhdGVwaWNrZXJbXFxcIl9cXFwiICsgb3B0aW9ucyArIFxcXCJEYXRlcGlja2VyXFxcIl0uYXBwbHkoJC5kYXRlcGlja2VyLCBbdGhpc1swXV0uY29uY2F0KG90aGVyQXJncykpO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgIHR5cGVvZiBvcHRpb25zID09PSBcXFwic3RyaW5nXFxcIiA/ICQuZGF0ZXBpY2tlcltcXFwiX1xcXCIgKyBvcHRpb25zICsgXFxcIkRhdGVwaWNrZXJcXFwiXS5hcHBseSgkLmRhdGVwaWNrZXIsIFt0aGlzXS5jb25jYXQob3RoZXJBcmdzKSkgOiAkLmRhdGVwaWNrZXIuX2F0dGFjaERhdGVwaWNrZXIodGhpcywgb3B0aW9ucyk7XFxuICAgIH0pO1xcbiAgfTtcXG5cXG4gICQuZGF0ZXBpY2tlciA9IG5ldyBEYXRlcGlja2VyKCk7IC8vIHNpbmdsZXRvbiBpbnN0YW5jZVxcblxcbiAgJC5kYXRlcGlja2VyLmluaXRpYWxpemVkID0gZmFsc2U7XFxuICAkLmRhdGVwaWNrZXIudXVpZCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xcbiAgJC5kYXRlcGlja2VyLnZlcnNpb24gPSBcXFwiMS4xMS40XFxcIjtcXG4gIHZhciBkYXRlcGlja2VyID0gJC5kYXRlcGlja2VyO1xcbiAgLyohXFxuICAgKiBqUXVlcnkgVUkgRHJhZ2dhYmxlIDEuMTEuNFxcbiAgICogaHR0cDovL2pxdWVyeXVpLmNvbVxcbiAgICpcXG4gICAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXFxuICAgKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXFxuICAgKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXFxuICAgKlxcbiAgICogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20vZHJhZ2dhYmxlL1xcbiAgICovXFxuXFxuICAkLndpZGdldChcXFwidWkuZHJhZ2dhYmxlXFxcIiwgJC51aS5tb3VzZSwge1xcbiAgICB2ZXJzaW9uOiBcXFwiMS4xMS40XFxcIixcXG4gICAgd2lkZ2V0RXZlbnRQcmVmaXg6IFxcXCJkcmFnXFxcIixcXG4gICAgb3B0aW9uczoge1xcbiAgICAgIGFkZENsYXNzZXM6IHRydWUsXFxuICAgICAgYXBwZW5kVG86IFxcXCJwYXJlbnRcXFwiLFxcbiAgICAgIGF4aXM6IGZhbHNlLFxcbiAgICAgIGNvbm5lY3RUb1NvcnRhYmxlOiBmYWxzZSxcXG4gICAgICBjb250YWlubWVudDogZmFsc2UsXFxuICAgICAgY3Vyc29yOiBcXFwiYXV0b1xcXCIsXFxuICAgICAgY3Vyc29yQXQ6IGZhbHNlLFxcbiAgICAgIGdyaWQ6IGZhbHNlLFxcbiAgICAgIGhhbmRsZTogZmFsc2UsXFxuICAgICAgaGVscGVyOiBcXFwib3JpZ2luYWxcXFwiLFxcbiAgICAgIGlmcmFtZUZpeDogZmFsc2UsXFxuICAgICAgb3BhY2l0eTogZmFsc2UsXFxuICAgICAgcmVmcmVzaFBvc2l0aW9uczogZmFsc2UsXFxuICAgICAgcmV2ZXJ0OiBmYWxzZSxcXG4gICAgICByZXZlcnREdXJhdGlvbjogNTAwLFxcbiAgICAgIHNjb3BlOiBcXFwiZGVmYXVsdFxcXCIsXFxuICAgICAgc2Nyb2xsOiB0cnVlLFxcbiAgICAgIHNjcm9sbFNlbnNpdGl2aXR5OiAyMCxcXG4gICAgICBzY3JvbGxTcGVlZDogMjAsXFxuICAgICAgc25hcDogZmFsc2UsXFxuICAgICAgc25hcE1vZGU6IFxcXCJib3RoXFxcIixcXG4gICAgICBzbmFwVG9sZXJhbmNlOiAyMCxcXG4gICAgICBzdGFjazogZmFsc2UsXFxuICAgICAgekluZGV4OiBmYWxzZSxcXG4gICAgICAvLyBjYWxsYmFja3NcXG4gICAgICBkcmFnOiBudWxsLFxcbiAgICAgIHN0YXJ0OiBudWxsLFxcbiAgICAgIHN0b3A6IG51bGxcXG4gICAgfSxcXG4gICAgX2NyZWF0ZTogZnVuY3Rpb24gX2NyZWF0ZSgpIHtcXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmhlbHBlciA9PT0gXFxcIm9yaWdpbmFsXFxcIikge1xcbiAgICAgICAgdGhpcy5fc2V0UG9zaXRpb25SZWxhdGl2ZSgpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmFkZENsYXNzZXMpIHtcXG4gICAgICAgIHRoaXMuZWxlbWVudC5hZGRDbGFzcyhcXFwidWktZHJhZ2dhYmxlXFxcIik7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGlzYWJsZWQpIHtcXG4gICAgICAgIHRoaXMuZWxlbWVudC5hZGRDbGFzcyhcXFwidWktZHJhZ2dhYmxlLWRpc2FibGVkXFxcIik7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX3NldEhhbmRsZUNsYXNzTmFtZSgpO1xcblxcbiAgICAgIHRoaXMuX21vdXNlSW5pdCgpO1xcbiAgICB9LFxcbiAgICBfc2V0T3B0aW9uOiBmdW5jdGlvbiBfc2V0T3B0aW9uKGtleSwgdmFsdWUpIHtcXG4gICAgICB0aGlzLl9zdXBlcihrZXksIHZhbHVlKTtcXG5cXG4gICAgICBpZiAoa2V5ID09PSBcXFwiaGFuZGxlXFxcIikge1xcbiAgICAgICAgdGhpcy5fcmVtb3ZlSGFuZGxlQ2xhc3NOYW1lKCk7XFxuXFxuICAgICAgICB0aGlzLl9zZXRIYW5kbGVDbGFzc05hbWUoKTtcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIF9kZXN0cm95OiBmdW5jdGlvbiBfZGVzdHJveSgpIHtcXG4gICAgICBpZiAoKHRoaXMuaGVscGVyIHx8IHRoaXMuZWxlbWVudCkuaXMoXFxcIi51aS1kcmFnZ2FibGUtZHJhZ2dpbmdcXFwiKSkge1xcbiAgICAgICAgdGhpcy5kZXN0cm95T25DbGVhciA9IHRydWU7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVDbGFzcyhcXFwidWktZHJhZ2dhYmxlIHVpLWRyYWdnYWJsZS1kcmFnZ2luZyB1aS1kcmFnZ2FibGUtZGlzYWJsZWRcXFwiKTtcXG5cXG4gICAgICB0aGlzLl9yZW1vdmVIYW5kbGVDbGFzc05hbWUoKTtcXG5cXG4gICAgICB0aGlzLl9tb3VzZURlc3Ryb3koKTtcXG4gICAgfSxcXG4gICAgX21vdXNlQ2FwdHVyZTogZnVuY3Rpb24gX21vdXNlQ2FwdHVyZShldmVudCkge1xcbiAgICAgIHZhciBvID0gdGhpcy5vcHRpb25zO1xcblxcbiAgICAgIHRoaXMuX2JsdXJBY3RpdmVFbGVtZW50KGV2ZW50KTsgLy8gYW1vbmcgb3RoZXJzLCBwcmV2ZW50IGEgZHJhZyBvbiBhIHJlc2l6YWJsZS1oYW5kbGVcXG5cXG5cXG4gICAgICBpZiAodGhpcy5oZWxwZXIgfHwgby5kaXNhYmxlZCB8fCAkKGV2ZW50LnRhcmdldCkuY2xvc2VzdChcXFwiLnVpLXJlc2l6YWJsZS1oYW5kbGVcXFwiKS5sZW5ndGggPiAwKSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfSAvL1F1aXQgaWYgd2UncmUgbm90IG9uIGEgdmFsaWQgaGFuZGxlXFxuXFxuXFxuICAgICAgdGhpcy5oYW5kbGUgPSB0aGlzLl9nZXRIYW5kbGUoZXZlbnQpO1xcblxcbiAgICAgIGlmICghdGhpcy5oYW5kbGUpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fYmxvY2tGcmFtZXMoby5pZnJhbWVGaXggPT09IHRydWUgPyBcXFwiaWZyYW1lXFxcIiA6IG8uaWZyYW1lRml4KTtcXG5cXG4gICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgfSxcXG4gICAgX2Jsb2NrRnJhbWVzOiBmdW5jdGlvbiBfYmxvY2tGcmFtZXMoc2VsZWN0b3IpIHtcXG4gICAgICB0aGlzLmlmcmFtZUJsb2NrcyA9IHRoaXMuZG9jdW1lbnQuZmluZChzZWxlY3RvcikubWFwKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciBpZnJhbWUgPSAkKHRoaXMpO1xcbiAgICAgICAgcmV0dXJuICQoXFxcIjxkaXY+XFxcIikuY3NzKFxcXCJwb3NpdGlvblxcXCIsIFxcXCJhYnNvbHV0ZVxcXCIpLmFwcGVuZFRvKGlmcmFtZS5wYXJlbnQoKSkub3V0ZXJXaWR0aChpZnJhbWUub3V0ZXJXaWR0aCgpKS5vdXRlckhlaWdodChpZnJhbWUub3V0ZXJIZWlnaHQoKSkub2Zmc2V0KGlmcmFtZS5vZmZzZXQoKSlbMF07XFxuICAgICAgfSk7XFxuICAgIH0sXFxuICAgIF91bmJsb2NrRnJhbWVzOiBmdW5jdGlvbiBfdW5ibG9ja0ZyYW1lcygpIHtcXG4gICAgICBpZiAodGhpcy5pZnJhbWVCbG9ja3MpIHtcXG4gICAgICAgIHRoaXMuaWZyYW1lQmxvY2tzLnJlbW92ZSgpO1xcbiAgICAgICAgZGVsZXRlIHRoaXMuaWZyYW1lQmxvY2tzO1xcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgX2JsdXJBY3RpdmVFbGVtZW50OiBmdW5jdGlvbiBfYmx1ckFjdGl2ZUVsZW1lbnQoZXZlbnQpIHtcXG4gICAgICB2YXIgZG9jdW1lbnQgPSB0aGlzLmRvY3VtZW50WzBdOyAvLyBPbmx5IG5lZWQgdG8gYmx1ciBpZiB0aGUgZXZlbnQgb2NjdXJyZWQgb24gdGhlIGRyYWdnYWJsZSBpdHNlbGYsIHNlZSAjMTA1MjdcXG5cXG4gICAgICBpZiAoIXRoaXMuaGFuZGxlRWxlbWVudC5pcyhldmVudC50YXJnZXQpKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfSAvLyBzdXBwb3J0OiBJRTlcXG4gICAgICAvLyBJRTkgdGhyb3dzIGFuIFxcXCJVbnNwZWNpZmllZCBlcnJvclxcXCIgYWNjZXNzaW5nIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgZnJvbSBhbiA8aWZyYW1lPlxcblxcblxcbiAgICAgIHRyeSB7XFxuICAgICAgICAvLyBTdXBwb3J0OiBJRTksIElFMTBcXG4gICAgICAgIC8vIElmIHRoZSA8Ym9keT4gaXMgYmx1cnJlZCwgSUUgd2lsbCBzd2l0Y2ggd2luZG93cywgc2VlICM5NTIwXFxuICAgICAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09IFxcXCJib2R5XFxcIikge1xcbiAgICAgICAgICAvLyBCbHVyIGFueSBlbGVtZW50IHRoYXQgY3VycmVudGx5IGhhcyBmb2N1cywgc2VlICM0MjYxXFxuICAgICAgICAgICQoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkuYmx1cigpO1xcbiAgICAgICAgfVxcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7fVxcbiAgICB9LFxcbiAgICBfbW91c2VTdGFydDogZnVuY3Rpb24gX21vdXNlU3RhcnQoZXZlbnQpIHtcXG4gICAgICB2YXIgbyA9IHRoaXMub3B0aW9uczsgLy9DcmVhdGUgYW5kIGFwcGVuZCB0aGUgdmlzaWJsZSBoZWxwZXJcXG5cXG4gICAgICB0aGlzLmhlbHBlciA9IHRoaXMuX2NyZWF0ZUhlbHBlcihldmVudCk7XFxuICAgICAgdGhpcy5oZWxwZXIuYWRkQ2xhc3MoXFxcInVpLWRyYWdnYWJsZS1kcmFnZ2luZ1xcXCIpOyAvL0NhY2hlIHRoZSBoZWxwZXIgc2l6ZVxcblxcbiAgICAgIHRoaXMuX2NhY2hlSGVscGVyUHJvcG9ydGlvbnMoKTsgLy9JZiBkZG1hbmFnZXIgaXMgdXNlZCBmb3IgZHJvcHBhYmxlcywgc2V0IHRoZSBnbG9iYWwgZHJhZ2dhYmxlXFxuXFxuXFxuICAgICAgaWYgKCQudWkuZGRtYW5hZ2VyKSB7XFxuICAgICAgICAkLnVpLmRkbWFuYWdlci5jdXJyZW50ID0gdGhpcztcXG4gICAgICB9XFxuICAgICAgLypcXG4gICAgICAgKiAtIFBvc2l0aW9uIGdlbmVyYXRpb24gLVxcbiAgICAgICAqIFRoaXMgYmxvY2sgZ2VuZXJhdGVzIGV2ZXJ5dGhpbmcgcG9zaXRpb24gcmVsYXRlZCAtIGl0J3MgdGhlIGNvcmUgb2YgZHJhZ2dhYmxlcy5cXG4gICAgICAgKi9cXG4gICAgICAvL0NhY2hlIHRoZSBtYXJnaW5zIG9mIHRoZSBvcmlnaW5hbCBlbGVtZW50XFxuXFxuXFxuICAgICAgdGhpcy5fY2FjaGVNYXJnaW5zKCk7IC8vU3RvcmUgdGhlIGhlbHBlcidzIGNzcyBwb3NpdGlvblxcblxcblxcbiAgICAgIHRoaXMuY3NzUG9zaXRpb24gPSB0aGlzLmhlbHBlci5jc3MoXFxcInBvc2l0aW9uXFxcIik7XFxuICAgICAgdGhpcy5zY3JvbGxQYXJlbnQgPSB0aGlzLmhlbHBlci5zY3JvbGxQYXJlbnQodHJ1ZSk7XFxuICAgICAgdGhpcy5vZmZzZXRQYXJlbnQgPSB0aGlzLmhlbHBlci5vZmZzZXRQYXJlbnQoKTtcXG4gICAgICB0aGlzLmhhc0ZpeGVkQW5jZXN0b3IgPSB0aGlzLmhlbHBlci5wYXJlbnRzKCkuZmlsdGVyKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHJldHVybiAkKHRoaXMpLmNzcyhcXFwicG9zaXRpb25cXFwiKSA9PT0gXFxcImZpeGVkXFxcIjtcXG4gICAgICB9KS5sZW5ndGggPiAwOyAvL1RoZSBlbGVtZW50J3MgYWJzb2x1dGUgcG9zaXRpb24gb24gdGhlIHBhZ2UgbWludXMgbWFyZ2luc1xcblxcbiAgICAgIHRoaXMucG9zaXRpb25BYnMgPSB0aGlzLmVsZW1lbnQub2Zmc2V0KCk7XFxuXFxuICAgICAgdGhpcy5fcmVmcmVzaE9mZnNldHMoZXZlbnQpOyAvL0dlbmVyYXRlIHRoZSBvcmlnaW5hbCBwb3NpdGlvblxcblxcblxcbiAgICAgIHRoaXMub3JpZ2luYWxQb3NpdGlvbiA9IHRoaXMucG9zaXRpb24gPSB0aGlzLl9nZW5lcmF0ZVBvc2l0aW9uKGV2ZW50LCBmYWxzZSk7XFxuICAgICAgdGhpcy5vcmlnaW5hbFBhZ2VYID0gZXZlbnQucGFnZVg7XFxuICAgICAgdGhpcy5vcmlnaW5hbFBhZ2VZID0gZXZlbnQucGFnZVk7IC8vQWRqdXN0IHRoZSBtb3VzZSBvZmZzZXQgcmVsYXRpdmUgdG8gdGhlIGhlbHBlciBpZiBcXFwiY3Vyc29yQXRcXFwiIGlzIHN1cHBsaWVkXFxuXFxuICAgICAgby5jdXJzb3JBdCAmJiB0aGlzLl9hZGp1c3RPZmZzZXRGcm9tSGVscGVyKG8uY3Vyc29yQXQpOyAvL1NldCBhIGNvbnRhaW5tZW50IGlmIGdpdmVuIGluIHRoZSBvcHRpb25zXFxuXFxuICAgICAgdGhpcy5fc2V0Q29udGFpbm1lbnQoKTsgLy9UcmlnZ2VyIGV2ZW50ICsgY2FsbGJhY2tzXFxuXFxuXFxuICAgICAgaWYgKHRoaXMuX3RyaWdnZXIoXFxcInN0YXJ0XFxcIiwgZXZlbnQpID09PSBmYWxzZSkge1xcbiAgICAgICAgdGhpcy5fY2xlYXIoKTtcXG5cXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9IC8vUmVjYWNoZSB0aGUgaGVscGVyIHNpemVcXG5cXG5cXG4gICAgICB0aGlzLl9jYWNoZUhlbHBlclByb3BvcnRpb25zKCk7IC8vUHJlcGFyZSB0aGUgZHJvcHBhYmxlIG9mZnNldHNcXG5cXG5cXG4gICAgICBpZiAoJC51aS5kZG1hbmFnZXIgJiYgIW8uZHJvcEJlaGF2aW91cikge1xcbiAgICAgICAgJC51aS5kZG1hbmFnZXIucHJlcGFyZU9mZnNldHModGhpcywgZXZlbnQpO1xcbiAgICAgIH0gLy8gUmVzZXQgaGVscGVyJ3MgcmlnaHQvYm90dG9tIGNzcyBpZiB0aGV5J3JlIHNldCBhbmQgc2V0IGV4cGxpY2l0IHdpZHRoL2hlaWdodCBpbnN0ZWFkXFxuICAgICAgLy8gYXMgdGhpcyBwcmV2ZW50cyByZXNpemluZyBvZiBlbGVtZW50cyB3aXRoIHJpZ2h0L2JvdHRvbSBzZXQgKHNlZSAjNzc3MilcXG5cXG5cXG4gICAgICB0aGlzLl9ub3JtYWxpemVSaWdodEJvdHRvbSgpO1xcblxcbiAgICAgIHRoaXMuX21vdXNlRHJhZyhldmVudCwgdHJ1ZSk7IC8vRXhlY3V0ZSB0aGUgZHJhZyBvbmNlIC0gdGhpcyBjYXVzZXMgdGhlIGhlbHBlciBub3QgdG8gYmUgdmlzaWJsZSBiZWZvcmUgZ2V0dGluZyBpdHMgY29ycmVjdCBwb3NpdGlvblxcbiAgICAgIC8vSWYgdGhlIGRkbWFuYWdlciBpcyB1c2VkIGZvciBkcm9wcGFibGVzLCBpbmZvcm0gdGhlIG1hbmFnZXIgdGhhdCBkcmFnZ2luZyBoYXMgc3RhcnRlZCAoc2VlICM1MDAzKVxcblxcblxcbiAgICAgIGlmICgkLnVpLmRkbWFuYWdlcikge1xcbiAgICAgICAgJC51aS5kZG1hbmFnZXIuZHJhZ1N0YXJ0KHRoaXMsIGV2ZW50KTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHRydWU7XFxuICAgIH0sXFxuICAgIF9yZWZyZXNoT2Zmc2V0czogZnVuY3Rpb24gX3JlZnJlc2hPZmZzZXRzKGV2ZW50KSB7XFxuICAgICAgdGhpcy5vZmZzZXQgPSB7XFxuICAgICAgICB0b3A6IHRoaXMucG9zaXRpb25BYnMudG9wIC0gdGhpcy5tYXJnaW5zLnRvcCxcXG4gICAgICAgIGxlZnQ6IHRoaXMucG9zaXRpb25BYnMubGVmdCAtIHRoaXMubWFyZ2lucy5sZWZ0LFxcbiAgICAgICAgc2Nyb2xsOiBmYWxzZSxcXG4gICAgICAgIHBhcmVudDogdGhpcy5fZ2V0UGFyZW50T2Zmc2V0KCksXFxuICAgICAgICByZWxhdGl2ZTogdGhpcy5fZ2V0UmVsYXRpdmVPZmZzZXQoKVxcbiAgICAgIH07XFxuICAgICAgdGhpcy5vZmZzZXQuY2xpY2sgPSB7XFxuICAgICAgICBsZWZ0OiBldmVudC5wYWdlWCAtIHRoaXMub2Zmc2V0LmxlZnQsXFxuICAgICAgICB0b3A6IGV2ZW50LnBhZ2VZIC0gdGhpcy5vZmZzZXQudG9wXFxuICAgICAgfTtcXG4gICAgfSxcXG4gICAgX21vdXNlRHJhZzogZnVuY3Rpb24gX21vdXNlRHJhZyhldmVudCwgbm9Qcm9wYWdhdGlvbikge1xcbiAgICAgIC8vIHJlc2V0IGFueSBuZWNlc3NhcnkgY2FjaGVkIHByb3BlcnRpZXMgKHNlZSAjNTAwOSlcXG4gICAgICBpZiAodGhpcy5oYXNGaXhlZEFuY2VzdG9yKSB7XFxuICAgICAgICB0aGlzLm9mZnNldC5wYXJlbnQgPSB0aGlzLl9nZXRQYXJlbnRPZmZzZXQoKTtcXG4gICAgICB9IC8vQ29tcHV0ZSB0aGUgaGVscGVycyBwb3NpdGlvblxcblxcblxcbiAgICAgIHRoaXMucG9zaXRpb24gPSB0aGlzLl9nZW5lcmF0ZVBvc2l0aW9uKGV2ZW50LCB0cnVlKTtcXG4gICAgICB0aGlzLnBvc2l0aW9uQWJzID0gdGhpcy5fY29udmVydFBvc2l0aW9uVG8oXFxcImFic29sdXRlXFxcIik7IC8vQ2FsbCBwbHVnaW5zIGFuZCBjYWxsYmFja3MgYW5kIHVzZSB0aGUgcmVzdWx0aW5nIHBvc2l0aW9uIGlmIHNvbWV0aGluZyBpcyByZXR1cm5lZFxcblxcbiAgICAgIGlmICghbm9Qcm9wYWdhdGlvbikge1xcbiAgICAgICAgdmFyIHVpID0gdGhpcy5fdWlIYXNoKCk7XFxuXFxuICAgICAgICBpZiAodGhpcy5fdHJpZ2dlcihcXFwiZHJhZ1xcXCIsIGV2ZW50LCB1aSkgPT09IGZhbHNlKSB7XFxuICAgICAgICAgIHRoaXMuX21vdXNlVXAoe30pO1xcblxcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gdWkucG9zaXRpb247XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuaGVscGVyWzBdLnN0eWxlLmxlZnQgPSB0aGlzLnBvc2l0aW9uLmxlZnQgKyBcXFwicHhcXFwiO1xcbiAgICAgIHRoaXMuaGVscGVyWzBdLnN0eWxlLnRvcCA9IHRoaXMucG9zaXRpb24udG9wICsgXFxcInB4XFxcIjtcXG5cXG4gICAgICBpZiAoJC51aS5kZG1hbmFnZXIpIHtcXG4gICAgICAgICQudWkuZGRtYW5hZ2VyLmRyYWcodGhpcywgZXZlbnQpO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH0sXFxuICAgIF9tb3VzZVN0b3A6IGZ1bmN0aW9uIF9tb3VzZVN0b3AoZXZlbnQpIHtcXG4gICAgICAvL0lmIHdlIGFyZSB1c2luZyBkcm9wcGFibGVzLCBpbmZvcm0gdGhlIG1hbmFnZXIgYWJvdXQgdGhlIGRyb3BcXG4gICAgICB2YXIgdGhhdCA9IHRoaXMsXFxuICAgICAgICAgIGRyb3BwZWQgPSBmYWxzZTtcXG5cXG4gICAgICBpZiAoJC51aS5kZG1hbmFnZXIgJiYgIXRoaXMub3B0aW9ucy5kcm9wQmVoYXZpb3VyKSB7XFxuICAgICAgICBkcm9wcGVkID0gJC51aS5kZG1hbmFnZXIuZHJvcCh0aGlzLCBldmVudCk7XFxuICAgICAgfSAvL2lmIGEgZHJvcCBjb21lcyBmcm9tIG91dHNpZGUgKGEgc29ydGFibGUpXFxuXFxuXFxuICAgICAgaWYgKHRoaXMuZHJvcHBlZCkge1xcbiAgICAgICAgZHJvcHBlZCA9IHRoaXMuZHJvcHBlZDtcXG4gICAgICAgIHRoaXMuZHJvcHBlZCA9IGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnJldmVydCA9PT0gXFxcImludmFsaWRcXFwiICYmICFkcm9wcGVkIHx8IHRoaXMub3B0aW9ucy5yZXZlcnQgPT09IFxcXCJ2YWxpZFxcXCIgJiYgZHJvcHBlZCB8fCB0aGlzLm9wdGlvbnMucmV2ZXJ0ID09PSB0cnVlIHx8ICQuaXNGdW5jdGlvbih0aGlzLm9wdGlvbnMucmV2ZXJ0KSAmJiB0aGlzLm9wdGlvbnMucmV2ZXJ0LmNhbGwodGhpcy5lbGVtZW50LCBkcm9wcGVkKSkge1xcbiAgICAgICAgJCh0aGlzLmhlbHBlcikuYW5pbWF0ZSh0aGlzLm9yaWdpbmFsUG9zaXRpb24sIHBhcnNlSW50KHRoaXMub3B0aW9ucy5yZXZlcnREdXJhdGlvbiwgMTApLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIGlmICh0aGF0Ll90cmlnZ2VyKFxcXCJzdG9wXFxcIiwgZXZlbnQpICE9PSBmYWxzZSkge1xcbiAgICAgICAgICAgIHRoYXQuX2NsZWFyKCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBpZiAodGhpcy5fdHJpZ2dlcihcXFwic3RvcFxcXCIsIGV2ZW50KSAhPT0gZmFsc2UpIHtcXG4gICAgICAgICAgdGhpcy5fY2xlYXIoKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9LFxcbiAgICBfbW91c2VVcDogZnVuY3Rpb24gX21vdXNlVXAoZXZlbnQpIHtcXG4gICAgICB0aGlzLl91bmJsb2NrRnJhbWVzKCk7IC8vSWYgdGhlIGRkbWFuYWdlciBpcyB1c2VkIGZvciBkcm9wcGFibGVzLCBpbmZvcm0gdGhlIG1hbmFnZXIgdGhhdCBkcmFnZ2luZyBoYXMgc3RvcHBlZCAoc2VlICM1MDAzKVxcblxcblxcbiAgICAgIGlmICgkLnVpLmRkbWFuYWdlcikge1xcbiAgICAgICAgJC51aS5kZG1hbmFnZXIuZHJhZ1N0b3AodGhpcywgZXZlbnQpO1xcbiAgICAgIH0gLy8gT25seSBuZWVkIHRvIGZvY3VzIGlmIHRoZSBldmVudCBvY2N1cnJlZCBvbiB0aGUgZHJhZ2dhYmxlIGl0c2VsZiwgc2VlICMxMDUyN1xcblxcblxcbiAgICAgIGlmICh0aGlzLmhhbmRsZUVsZW1lbnQuaXMoZXZlbnQudGFyZ2V0KSkge1xcbiAgICAgICAgLy8gVGhlIGludGVyYWN0aW9uIGlzIG92ZXI7IHdoZXRoZXIgb3Igbm90IHRoZSBjbGljayByZXN1bHRlZCBpbiBhIGRyYWcsIGZvY3VzIHRoZSBlbGVtZW50XFxuICAgICAgICB0aGlzLmVsZW1lbnQuZm9jdXMoKTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuICQudWkubW91c2UucHJvdG90eXBlLl9tb3VzZVVwLmNhbGwodGhpcywgZXZlbnQpO1xcbiAgICB9LFxcbiAgICBjYW5jZWw6IGZ1bmN0aW9uIGNhbmNlbCgpIHtcXG4gICAgICBpZiAodGhpcy5oZWxwZXIuaXMoXFxcIi51aS1kcmFnZ2FibGUtZHJhZ2dpbmdcXFwiKSkge1xcbiAgICAgICAgdGhpcy5fbW91c2VVcCh7fSk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRoaXMuX2NsZWFyKCk7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiB0aGlzO1xcbiAgICB9LFxcbiAgICBfZ2V0SGFuZGxlOiBmdW5jdGlvbiBfZ2V0SGFuZGxlKGV2ZW50KSB7XFxuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5oYW5kbGUgPyAhISQoZXZlbnQudGFyZ2V0KS5jbG9zZXN0KHRoaXMuZWxlbWVudC5maW5kKHRoaXMub3B0aW9ucy5oYW5kbGUpKS5sZW5ndGggOiB0cnVlO1xcbiAgICB9LFxcbiAgICBfc2V0SGFuZGxlQ2xhc3NOYW1lOiBmdW5jdGlvbiBfc2V0SGFuZGxlQ2xhc3NOYW1lKCkge1xcbiAgICAgIHRoaXMuaGFuZGxlRWxlbWVudCA9IHRoaXMub3B0aW9ucy5oYW5kbGUgPyB0aGlzLmVsZW1lbnQuZmluZCh0aGlzLm9wdGlvbnMuaGFuZGxlKSA6IHRoaXMuZWxlbWVudDtcXG4gICAgICB0aGlzLmhhbmRsZUVsZW1lbnQuYWRkQ2xhc3MoXFxcInVpLWRyYWdnYWJsZS1oYW5kbGVcXFwiKTtcXG4gICAgfSxcXG4gICAgX3JlbW92ZUhhbmRsZUNsYXNzTmFtZTogZnVuY3Rpb24gX3JlbW92ZUhhbmRsZUNsYXNzTmFtZSgpIHtcXG4gICAgICB0aGlzLmhhbmRsZUVsZW1lbnQucmVtb3ZlQ2xhc3MoXFxcInVpLWRyYWdnYWJsZS1oYW5kbGVcXFwiKTtcXG4gICAgfSxcXG4gICAgX2NyZWF0ZUhlbHBlcjogZnVuY3Rpb24gX2NyZWF0ZUhlbHBlcihldmVudCkge1xcbiAgICAgIHZhciBvID0gdGhpcy5vcHRpb25zLFxcbiAgICAgICAgICBoZWxwZXJJc0Z1bmN0aW9uID0gJC5pc0Z1bmN0aW9uKG8uaGVscGVyKSxcXG4gICAgICAgICAgaGVscGVyID0gaGVscGVySXNGdW5jdGlvbiA/ICQoby5oZWxwZXIuYXBwbHkodGhpcy5lbGVtZW50WzBdLCBbZXZlbnRdKSkgOiBvLmhlbHBlciA9PT0gXFxcImNsb25lXFxcIiA/IHRoaXMuZWxlbWVudC5jbG9uZSgpLnJlbW92ZUF0dHIoXFxcImlkXFxcIikgOiB0aGlzLmVsZW1lbnQ7XFxuXFxuICAgICAgaWYgKCFoZWxwZXIucGFyZW50cyhcXFwiYm9keVxcXCIpLmxlbmd0aCkge1xcbiAgICAgICAgaGVscGVyLmFwcGVuZFRvKG8uYXBwZW5kVG8gPT09IFxcXCJwYXJlbnRcXFwiID8gdGhpcy5lbGVtZW50WzBdLnBhcmVudE5vZGUgOiBvLmFwcGVuZFRvKTtcXG4gICAgICB9IC8vIGh0dHA6Ly9idWdzLmpxdWVyeXVpLmNvbS90aWNrZXQvOTQ0NlxcbiAgICAgIC8vIGEgaGVscGVyIGZ1bmN0aW9uIGNhbiByZXR1cm4gdGhlIG9yaWdpbmFsIGVsZW1lbnRcXG4gICAgICAvLyB3aGljaCB3b3VsZG4ndCBoYXZlIGJlZW4gc2V0IHRvIHJlbGF0aXZlIGluIF9jcmVhdGVcXG5cXG5cXG4gICAgICBpZiAoaGVscGVySXNGdW5jdGlvbiAmJiBoZWxwZXJbMF0gPT09IHRoaXMuZWxlbWVudFswXSkge1xcbiAgICAgICAgdGhpcy5fc2V0UG9zaXRpb25SZWxhdGl2ZSgpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoaGVscGVyWzBdICE9PSB0aGlzLmVsZW1lbnRbMF0gJiYgIS8oZml4ZWR8YWJzb2x1dGUpLy50ZXN0KGhlbHBlci5jc3MoXFxcInBvc2l0aW9uXFxcIikpKSB7XFxuICAgICAgICBoZWxwZXIuY3NzKFxcXCJwb3NpdGlvblxcXCIsIFxcXCJhYnNvbHV0ZVxcXCIpO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gaGVscGVyO1xcbiAgICB9LFxcbiAgICBfc2V0UG9zaXRpb25SZWxhdGl2ZTogZnVuY3Rpb24gX3NldFBvc2l0aW9uUmVsYXRpdmUoKSB7XFxuICAgICAgaWYgKCEvXig/OnJ8YXxmKS8udGVzdCh0aGlzLmVsZW1lbnQuY3NzKFxcXCJwb3NpdGlvblxcXCIpKSkge1xcbiAgICAgICAgdGhpcy5lbGVtZW50WzBdLnN0eWxlLnBvc2l0aW9uID0gXFxcInJlbGF0aXZlXFxcIjtcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIF9hZGp1c3RPZmZzZXRGcm9tSGVscGVyOiBmdW5jdGlvbiBfYWRqdXN0T2Zmc2V0RnJvbUhlbHBlcihvYmopIHtcXG4gICAgICBpZiAodHlwZW9mIG9iaiA9PT0gXFxcInN0cmluZ1xcXCIpIHtcXG4gICAgICAgIG9iaiA9IG9iai5zcGxpdChcXFwiIFxcXCIpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoJC5pc0FycmF5KG9iaikpIHtcXG4gICAgICAgIG9iaiA9IHtcXG4gICAgICAgICAgbGVmdDogK29ialswXSxcXG4gICAgICAgICAgdG9wOiArb2JqWzFdIHx8IDBcXG4gICAgICAgIH07XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChcXFwibGVmdFxcXCIgaW4gb2JqKSB7XFxuICAgICAgICB0aGlzLm9mZnNldC5jbGljay5sZWZ0ID0gb2JqLmxlZnQgKyB0aGlzLm1hcmdpbnMubGVmdDtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKFxcXCJyaWdodFxcXCIgaW4gb2JqKSB7XFxuICAgICAgICB0aGlzLm9mZnNldC5jbGljay5sZWZ0ID0gdGhpcy5oZWxwZXJQcm9wb3J0aW9ucy53aWR0aCAtIG9iai5yaWdodCArIHRoaXMubWFyZ2lucy5sZWZ0O1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoXFxcInRvcFxcXCIgaW4gb2JqKSB7XFxuICAgICAgICB0aGlzLm9mZnNldC5jbGljay50b3AgPSBvYmoudG9wICsgdGhpcy5tYXJnaW5zLnRvcDtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKFxcXCJib3R0b21cXFwiIGluIG9iaikge1xcbiAgICAgICAgdGhpcy5vZmZzZXQuY2xpY2sudG9wID0gdGhpcy5oZWxwZXJQcm9wb3J0aW9ucy5oZWlnaHQgLSBvYmouYm90dG9tICsgdGhpcy5tYXJnaW5zLnRvcDtcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIF9pc1Jvb3ROb2RlOiBmdW5jdGlvbiBfaXNSb290Tm9kZShlbGVtZW50KSB7XFxuICAgICAgcmV0dXJuIC8oaHRtbHxib2R5KS9pLnRlc3QoZWxlbWVudC50YWdOYW1lKSB8fCBlbGVtZW50ID09PSB0aGlzLmRvY3VtZW50WzBdO1xcbiAgICB9LFxcbiAgICBfZ2V0UGFyZW50T2Zmc2V0OiBmdW5jdGlvbiBfZ2V0UGFyZW50T2Zmc2V0KCkge1xcbiAgICAgIC8vR2V0IHRoZSBvZmZzZXRQYXJlbnQgYW5kIGNhY2hlIGl0cyBwb3NpdGlvblxcbiAgICAgIHZhciBwbyA9IHRoaXMub2Zmc2V0UGFyZW50Lm9mZnNldCgpLFxcbiAgICAgICAgICBkb2N1bWVudCA9IHRoaXMuZG9jdW1lbnRbMF07IC8vIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2Ugd2hlcmUgd2UgbmVlZCB0byBtb2RpZnkgYSBvZmZzZXQgY2FsY3VsYXRlZCBvbiBzdGFydCwgc2luY2UgdGhlIGZvbGxvd2luZyBoYXBwZW5lZDpcXG4gICAgICAvLyAxLiBUaGUgcG9zaXRpb24gb2YgdGhlIGhlbHBlciBpcyBhYnNvbHV0ZSwgc28gaXQncyBwb3NpdGlvbiBpcyBjYWxjdWxhdGVkIGJhc2VkIG9uIHRoZSBuZXh0IHBvc2l0aW9uZWQgcGFyZW50XFxuICAgICAgLy8gMi4gVGhlIGFjdHVhbCBvZmZzZXQgcGFyZW50IGlzIGEgY2hpbGQgb2YgdGhlIHNjcm9sbCBwYXJlbnQsIGFuZCB0aGUgc2Nyb2xsIHBhcmVudCBpc24ndCB0aGUgZG9jdW1lbnQsIHdoaWNoIG1lYW5zIHRoYXRcXG4gICAgICAvLyAgICB0aGUgc2Nyb2xsIGlzIGluY2x1ZGVkIGluIHRoZSBpbml0aWFsIGNhbGN1bGF0aW9uIG9mIHRoZSBvZmZzZXQgb2YgdGhlIHBhcmVudCwgYW5kIG5ldmVyIHJlY2FsY3VsYXRlZCB1cG9uIGRyYWdcXG5cXG4gICAgICBpZiAodGhpcy5jc3NQb3NpdGlvbiA9PT0gXFxcImFic29sdXRlXFxcIiAmJiB0aGlzLnNjcm9sbFBhcmVudFswXSAhPT0gZG9jdW1lbnQgJiYgJC5jb250YWlucyh0aGlzLnNjcm9sbFBhcmVudFswXSwgdGhpcy5vZmZzZXRQYXJlbnRbMF0pKSB7XFxuICAgICAgICBwby5sZWZ0ICs9IHRoaXMuc2Nyb2xsUGFyZW50LnNjcm9sbExlZnQoKTtcXG4gICAgICAgIHBvLnRvcCArPSB0aGlzLnNjcm9sbFBhcmVudC5zY3JvbGxUb3AoKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMuX2lzUm9vdE5vZGUodGhpcy5vZmZzZXRQYXJlbnRbMF0pKSB7XFxuICAgICAgICBwbyA9IHtcXG4gICAgICAgICAgdG9wOiAwLFxcbiAgICAgICAgICBsZWZ0OiAwXFxuICAgICAgICB9O1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4ge1xcbiAgICAgICAgdG9wOiBwby50b3AgKyAocGFyc2VJbnQodGhpcy5vZmZzZXRQYXJlbnQuY3NzKFxcXCJib3JkZXJUb3BXaWR0aFxcXCIpLCAxMCkgfHwgMCksXFxuICAgICAgICBsZWZ0OiBwby5sZWZ0ICsgKHBhcnNlSW50KHRoaXMub2Zmc2V0UGFyZW50LmNzcyhcXFwiYm9yZGVyTGVmdFdpZHRoXFxcIiksIDEwKSB8fCAwKVxcbiAgICAgIH07XFxuICAgIH0sXFxuICAgIF9nZXRSZWxhdGl2ZU9mZnNldDogZnVuY3Rpb24gX2dldFJlbGF0aXZlT2Zmc2V0KCkge1xcbiAgICAgIGlmICh0aGlzLmNzc1Bvc2l0aW9uICE9PSBcXFwicmVsYXRpdmVcXFwiKSB7XFxuICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICB0b3A6IDAsXFxuICAgICAgICAgIGxlZnQ6IDBcXG4gICAgICAgIH07XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBwID0gdGhpcy5lbGVtZW50LnBvc2l0aW9uKCksXFxuICAgICAgICAgIHNjcm9sbElzUm9vdE5vZGUgPSB0aGlzLl9pc1Jvb3ROb2RlKHRoaXMuc2Nyb2xsUGFyZW50WzBdKTtcXG5cXG4gICAgICByZXR1cm4ge1xcbiAgICAgICAgdG9wOiBwLnRvcCAtIChwYXJzZUludCh0aGlzLmhlbHBlci5jc3MoXFxcInRvcFxcXCIpLCAxMCkgfHwgMCkgKyAoIXNjcm9sbElzUm9vdE5vZGUgPyB0aGlzLnNjcm9sbFBhcmVudC5zY3JvbGxUb3AoKSA6IDApLFxcbiAgICAgICAgbGVmdDogcC5sZWZ0IC0gKHBhcnNlSW50KHRoaXMuaGVscGVyLmNzcyhcXFwibGVmdFxcXCIpLCAxMCkgfHwgMCkgKyAoIXNjcm9sbElzUm9vdE5vZGUgPyB0aGlzLnNjcm9sbFBhcmVudC5zY3JvbGxMZWZ0KCkgOiAwKVxcbiAgICAgIH07XFxuICAgIH0sXFxuICAgIF9jYWNoZU1hcmdpbnM6IGZ1bmN0aW9uIF9jYWNoZU1hcmdpbnMoKSB7XFxuICAgICAgdGhpcy5tYXJnaW5zID0ge1xcbiAgICAgICAgbGVmdDogcGFyc2VJbnQodGhpcy5lbGVtZW50LmNzcyhcXFwibWFyZ2luTGVmdFxcXCIpLCAxMCkgfHwgMCxcXG4gICAgICAgIHRvcDogcGFyc2VJbnQodGhpcy5lbGVtZW50LmNzcyhcXFwibWFyZ2luVG9wXFxcIiksIDEwKSB8fCAwLFxcbiAgICAgICAgcmlnaHQ6IHBhcnNlSW50KHRoaXMuZWxlbWVudC5jc3MoXFxcIm1hcmdpblJpZ2h0XFxcIiksIDEwKSB8fCAwLFxcbiAgICAgICAgYm90dG9tOiBwYXJzZUludCh0aGlzLmVsZW1lbnQuY3NzKFxcXCJtYXJnaW5Cb3R0b21cXFwiKSwgMTApIHx8IDBcXG4gICAgICB9O1xcbiAgICB9LFxcbiAgICBfY2FjaGVIZWxwZXJQcm9wb3J0aW9uczogZnVuY3Rpb24gX2NhY2hlSGVscGVyUHJvcG9ydGlvbnMoKSB7XFxuICAgICAgdGhpcy5oZWxwZXJQcm9wb3J0aW9ucyA9IHtcXG4gICAgICAgIHdpZHRoOiB0aGlzLmhlbHBlci5vdXRlcldpZHRoKCksXFxuICAgICAgICBoZWlnaHQ6IHRoaXMuaGVscGVyLm91dGVySGVpZ2h0KClcXG4gICAgICB9O1xcbiAgICB9LFxcbiAgICBfc2V0Q29udGFpbm1lbnQ6IGZ1bmN0aW9uIF9zZXRDb250YWlubWVudCgpIHtcXG4gICAgICB2YXIgaXNVc2VyU2Nyb2xsYWJsZSxcXG4gICAgICAgICAgYyxcXG4gICAgICAgICAgY2UsXFxuICAgICAgICAgIG8gPSB0aGlzLm9wdGlvbnMsXFxuICAgICAgICAgIGRvY3VtZW50ID0gdGhpcy5kb2N1bWVudFswXTtcXG4gICAgICB0aGlzLnJlbGF0aXZlQ29udGFpbmVyID0gbnVsbDtcXG5cXG4gICAgICBpZiAoIW8uY29udGFpbm1lbnQpIHtcXG4gICAgICAgIHRoaXMuY29udGFpbm1lbnQgPSBudWxsO1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoby5jb250YWlubWVudCA9PT0gXFxcIndpbmRvd1xcXCIpIHtcXG4gICAgICAgIHRoaXMuY29udGFpbm1lbnQgPSBbJCh3aW5kb3cpLnNjcm9sbExlZnQoKSAtIHRoaXMub2Zmc2V0LnJlbGF0aXZlLmxlZnQgLSB0aGlzLm9mZnNldC5wYXJlbnQubGVmdCwgJCh3aW5kb3cpLnNjcm9sbFRvcCgpIC0gdGhpcy5vZmZzZXQucmVsYXRpdmUudG9wIC0gdGhpcy5vZmZzZXQucGFyZW50LnRvcCwgJCh3aW5kb3cpLnNjcm9sbExlZnQoKSArICQod2luZG93KS53aWR0aCgpIC0gdGhpcy5oZWxwZXJQcm9wb3J0aW9ucy53aWR0aCAtIHRoaXMubWFyZ2lucy5sZWZ0LCAkKHdpbmRvdykuc2Nyb2xsVG9wKCkgKyAoJCh3aW5kb3cpLmhlaWdodCgpIHx8IGRvY3VtZW50LmJvZHkucGFyZW50Tm9kZS5zY3JvbGxIZWlnaHQpIC0gdGhpcy5oZWxwZXJQcm9wb3J0aW9ucy5oZWlnaHQgLSB0aGlzLm1hcmdpbnMudG9wXTtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKG8uY29udGFpbm1lbnQgPT09IFxcXCJkb2N1bWVudFxcXCIpIHtcXG4gICAgICAgIHRoaXMuY29udGFpbm1lbnQgPSBbMCwgMCwgJChkb2N1bWVudCkud2lkdGgoKSAtIHRoaXMuaGVscGVyUHJvcG9ydGlvbnMud2lkdGggLSB0aGlzLm1hcmdpbnMubGVmdCwgKCQoZG9jdW1lbnQpLmhlaWdodCgpIHx8IGRvY3VtZW50LmJvZHkucGFyZW50Tm9kZS5zY3JvbGxIZWlnaHQpIC0gdGhpcy5oZWxwZXJQcm9wb3J0aW9ucy5oZWlnaHQgLSB0aGlzLm1hcmdpbnMudG9wXTtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKG8uY29udGFpbm1lbnQuY29uc3RydWN0b3IgPT09IEFycmF5KSB7XFxuICAgICAgICB0aGlzLmNvbnRhaW5tZW50ID0gby5jb250YWlubWVudDtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKG8uY29udGFpbm1lbnQgPT09IFxcXCJwYXJlbnRcXFwiKSB7XFxuICAgICAgICBvLmNvbnRhaW5tZW50ID0gdGhpcy5oZWxwZXJbMF0ucGFyZW50Tm9kZTtcXG4gICAgICB9XFxuXFxuICAgICAgYyA9ICQoby5jb250YWlubWVudCk7XFxuICAgICAgY2UgPSBjWzBdO1xcblxcbiAgICAgIGlmICghY2UpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgaXNVc2VyU2Nyb2xsYWJsZSA9IC8oc2Nyb2xsfGF1dG8pLy50ZXN0KGMuY3NzKFxcXCJvdmVyZmxvd1xcXCIpKTtcXG4gICAgICB0aGlzLmNvbnRhaW5tZW50ID0gWyhwYXJzZUludChjLmNzcyhcXFwiYm9yZGVyTGVmdFdpZHRoXFxcIiksIDEwKSB8fCAwKSArIChwYXJzZUludChjLmNzcyhcXFwicGFkZGluZ0xlZnRcXFwiKSwgMTApIHx8IDApLCAocGFyc2VJbnQoYy5jc3MoXFxcImJvcmRlclRvcFdpZHRoXFxcIiksIDEwKSB8fCAwKSArIChwYXJzZUludChjLmNzcyhcXFwicGFkZGluZ1RvcFxcXCIpLCAxMCkgfHwgMCksIChpc1VzZXJTY3JvbGxhYmxlID8gTWF0aC5tYXgoY2Uuc2Nyb2xsV2lkdGgsIGNlLm9mZnNldFdpZHRoKSA6IGNlLm9mZnNldFdpZHRoKSAtIChwYXJzZUludChjLmNzcyhcXFwiYm9yZGVyUmlnaHRXaWR0aFxcXCIpLCAxMCkgfHwgMCkgLSAocGFyc2VJbnQoYy5jc3MoXFxcInBhZGRpbmdSaWdodFxcXCIpLCAxMCkgfHwgMCkgLSB0aGlzLmhlbHBlclByb3BvcnRpb25zLndpZHRoIC0gdGhpcy5tYXJnaW5zLmxlZnQgLSB0aGlzLm1hcmdpbnMucmlnaHQsIChpc1VzZXJTY3JvbGxhYmxlID8gTWF0aC5tYXgoY2Uuc2Nyb2xsSGVpZ2h0LCBjZS5vZmZzZXRIZWlnaHQpIDogY2Uub2Zmc2V0SGVpZ2h0KSAtIChwYXJzZUludChjLmNzcyhcXFwiYm9yZGVyQm90dG9tV2lkdGhcXFwiKSwgMTApIHx8IDApIC0gKHBhcnNlSW50KGMuY3NzKFxcXCJwYWRkaW5nQm90dG9tXFxcIiksIDEwKSB8fCAwKSAtIHRoaXMuaGVscGVyUHJvcG9ydGlvbnMuaGVpZ2h0IC0gdGhpcy5tYXJnaW5zLnRvcCAtIHRoaXMubWFyZ2lucy5ib3R0b21dO1xcbiAgICAgIHRoaXMucmVsYXRpdmVDb250YWluZXIgPSBjO1xcbiAgICB9LFxcbiAgICBfY29udmVydFBvc2l0aW9uVG86IGZ1bmN0aW9uIF9jb252ZXJ0UG9zaXRpb25UbyhkLCBwb3MpIHtcXG4gICAgICBpZiAoIXBvcykge1xcbiAgICAgICAgcG9zID0gdGhpcy5wb3NpdGlvbjtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIG1vZCA9IGQgPT09IFxcXCJhYnNvbHV0ZVxcXCIgPyAxIDogLTEsXFxuICAgICAgICAgIHNjcm9sbElzUm9vdE5vZGUgPSB0aGlzLl9pc1Jvb3ROb2RlKHRoaXMuc2Nyb2xsUGFyZW50WzBdKTtcXG5cXG4gICAgICByZXR1cm4ge1xcbiAgICAgICAgdG9wOiBwb3MudG9wICsgLy8gVGhlIGFic29sdXRlIG1vdXNlIHBvc2l0aW9uXFxuICAgICAgICB0aGlzLm9mZnNldC5yZWxhdGl2ZS50b3AgKiBtb2QgKyAvLyBPbmx5IGZvciByZWxhdGl2ZSBwb3NpdGlvbmVkIG5vZGVzOiBSZWxhdGl2ZSBvZmZzZXQgZnJvbSBlbGVtZW50IHRvIG9mZnNldCBwYXJlbnRcXG4gICAgICAgIHRoaXMub2Zmc2V0LnBhcmVudC50b3AgKiBtb2QgLSAvLyBUaGUgb2Zmc2V0UGFyZW50J3Mgb2Zmc2V0IHdpdGhvdXQgYm9yZGVycyAob2Zmc2V0ICsgYm9yZGVyKVxcbiAgICAgICAgKHRoaXMuY3NzUG9zaXRpb24gPT09IFxcXCJmaXhlZFxcXCIgPyAtdGhpcy5vZmZzZXQuc2Nyb2xsLnRvcCA6IHNjcm9sbElzUm9vdE5vZGUgPyAwIDogdGhpcy5vZmZzZXQuc2Nyb2xsLnRvcCkgKiBtb2QsXFxuICAgICAgICBsZWZ0OiBwb3MubGVmdCArIC8vIFRoZSBhYnNvbHV0ZSBtb3VzZSBwb3NpdGlvblxcbiAgICAgICAgdGhpcy5vZmZzZXQucmVsYXRpdmUubGVmdCAqIG1vZCArIC8vIE9ubHkgZm9yIHJlbGF0aXZlIHBvc2l0aW9uZWQgbm9kZXM6IFJlbGF0aXZlIG9mZnNldCBmcm9tIGVsZW1lbnQgdG8gb2Zmc2V0IHBhcmVudFxcbiAgICAgICAgdGhpcy5vZmZzZXQucGFyZW50LmxlZnQgKiBtb2QgLSAvLyBUaGUgb2Zmc2V0UGFyZW50J3Mgb2Zmc2V0IHdpdGhvdXQgYm9yZGVycyAob2Zmc2V0ICsgYm9yZGVyKVxcbiAgICAgICAgKHRoaXMuY3NzUG9zaXRpb24gPT09IFxcXCJmaXhlZFxcXCIgPyAtdGhpcy5vZmZzZXQuc2Nyb2xsLmxlZnQgOiBzY3JvbGxJc1Jvb3ROb2RlID8gMCA6IHRoaXMub2Zmc2V0LnNjcm9sbC5sZWZ0KSAqIG1vZFxcbiAgICAgIH07XFxuICAgIH0sXFxuICAgIF9nZW5lcmF0ZVBvc2l0aW9uOiBmdW5jdGlvbiBfZ2VuZXJhdGVQb3NpdGlvbihldmVudCwgY29uc3RyYWluUG9zaXRpb24pIHtcXG4gICAgICB2YXIgY29udGFpbm1lbnQsXFxuICAgICAgICAgIGNvLFxcbiAgICAgICAgICB0b3AsXFxuICAgICAgICAgIGxlZnQsXFxuICAgICAgICAgIG8gPSB0aGlzLm9wdGlvbnMsXFxuICAgICAgICAgIHNjcm9sbElzUm9vdE5vZGUgPSB0aGlzLl9pc1Jvb3ROb2RlKHRoaXMuc2Nyb2xsUGFyZW50WzBdKSxcXG4gICAgICAgICAgcGFnZVggPSBldmVudC5wYWdlWCxcXG4gICAgICAgICAgcGFnZVkgPSBldmVudC5wYWdlWTsgLy8gQ2FjaGUgdGhlIHNjcm9sbFxcblxcblxcbiAgICAgIGlmICghc2Nyb2xsSXNSb290Tm9kZSB8fCAhdGhpcy5vZmZzZXQuc2Nyb2xsKSB7XFxuICAgICAgICB0aGlzLm9mZnNldC5zY3JvbGwgPSB7XFxuICAgICAgICAgIHRvcDogdGhpcy5zY3JvbGxQYXJlbnQuc2Nyb2xsVG9wKCksXFxuICAgICAgICAgIGxlZnQ6IHRoaXMuc2Nyb2xsUGFyZW50LnNjcm9sbExlZnQoKVxcbiAgICAgICAgfTtcXG4gICAgICB9XFxuICAgICAgLypcXG4gICAgICAgKiAtIFBvc2l0aW9uIGNvbnN0cmFpbmluZyAtXFxuICAgICAgICogQ29uc3RyYWluIHRoZSBwb3NpdGlvbiB0byBhIG1peCBvZiBncmlkLCBjb250YWlubWVudC5cXG4gICAgICAgKi9cXG4gICAgICAvLyBJZiB3ZSBhcmUgbm90IGRyYWdnaW5nIHlldCwgd2Ugd29uJ3QgY2hlY2sgZm9yIG9wdGlvbnNcXG5cXG5cXG4gICAgICBpZiAoY29uc3RyYWluUG9zaXRpb24pIHtcXG4gICAgICAgIGlmICh0aGlzLmNvbnRhaW5tZW50KSB7XFxuICAgICAgICAgIGlmICh0aGlzLnJlbGF0aXZlQ29udGFpbmVyKSB7XFxuICAgICAgICAgICAgY28gPSB0aGlzLnJlbGF0aXZlQ29udGFpbmVyLm9mZnNldCgpO1xcbiAgICAgICAgICAgIGNvbnRhaW5tZW50ID0gW3RoaXMuY29udGFpbm1lbnRbMF0gKyBjby5sZWZ0LCB0aGlzLmNvbnRhaW5tZW50WzFdICsgY28udG9wLCB0aGlzLmNvbnRhaW5tZW50WzJdICsgY28ubGVmdCwgdGhpcy5jb250YWlubWVudFszXSArIGNvLnRvcF07XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgY29udGFpbm1lbnQgPSB0aGlzLmNvbnRhaW5tZW50O1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmIChldmVudC5wYWdlWCAtIHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQgPCBjb250YWlubWVudFswXSkge1xcbiAgICAgICAgICAgIHBhZ2VYID0gY29udGFpbm1lbnRbMF0gKyB0aGlzLm9mZnNldC5jbGljay5sZWZ0O1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmIChldmVudC5wYWdlWSAtIHRoaXMub2Zmc2V0LmNsaWNrLnRvcCA8IGNvbnRhaW5tZW50WzFdKSB7XFxuICAgICAgICAgICAgcGFnZVkgPSBjb250YWlubWVudFsxXSArIHRoaXMub2Zmc2V0LmNsaWNrLnRvcDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAoZXZlbnQucGFnZVggLSB0aGlzLm9mZnNldC5jbGljay5sZWZ0ID4gY29udGFpbm1lbnRbMl0pIHtcXG4gICAgICAgICAgICBwYWdlWCA9IGNvbnRhaW5tZW50WzJdICsgdGhpcy5vZmZzZXQuY2xpY2subGVmdDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAoZXZlbnQucGFnZVkgLSB0aGlzLm9mZnNldC5jbGljay50b3AgPiBjb250YWlubWVudFszXSkge1xcbiAgICAgICAgICAgIHBhZ2VZID0gY29udGFpbm1lbnRbM10gKyB0aGlzLm9mZnNldC5jbGljay50b3A7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChvLmdyaWQpIHtcXG4gICAgICAgICAgLy9DaGVjayBmb3IgZ3JpZCBlbGVtZW50cyBzZXQgdG8gMCB0byBwcmV2ZW50IGRpdmlkZSBieSAwIGVycm9yIGNhdXNpbmcgaW52YWxpZCBhcmd1bWVudCBlcnJvcnMgaW4gSUUgKHNlZSB0aWNrZXQgIzY5NTApXFxuICAgICAgICAgIHRvcCA9IG8uZ3JpZFsxXSA/IHRoaXMub3JpZ2luYWxQYWdlWSArIE1hdGgucm91bmQoKHBhZ2VZIC0gdGhpcy5vcmlnaW5hbFBhZ2VZKSAvIG8uZ3JpZFsxXSkgKiBvLmdyaWRbMV0gOiB0aGlzLm9yaWdpbmFsUGFnZVk7XFxuICAgICAgICAgIHBhZ2VZID0gY29udGFpbm1lbnQgPyB0b3AgLSB0aGlzLm9mZnNldC5jbGljay50b3AgPj0gY29udGFpbm1lbnRbMV0gfHwgdG9wIC0gdGhpcy5vZmZzZXQuY2xpY2sudG9wID4gY29udGFpbm1lbnRbM10gPyB0b3AgOiB0b3AgLSB0aGlzLm9mZnNldC5jbGljay50b3AgPj0gY29udGFpbm1lbnRbMV0gPyB0b3AgLSBvLmdyaWRbMV0gOiB0b3AgKyBvLmdyaWRbMV0gOiB0b3A7XFxuICAgICAgICAgIGxlZnQgPSBvLmdyaWRbMF0gPyB0aGlzLm9yaWdpbmFsUGFnZVggKyBNYXRoLnJvdW5kKChwYWdlWCAtIHRoaXMub3JpZ2luYWxQYWdlWCkgLyBvLmdyaWRbMF0pICogby5ncmlkWzBdIDogdGhpcy5vcmlnaW5hbFBhZ2VYO1xcbiAgICAgICAgICBwYWdlWCA9IGNvbnRhaW5tZW50ID8gbGVmdCAtIHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQgPj0gY29udGFpbm1lbnRbMF0gfHwgbGVmdCAtIHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQgPiBjb250YWlubWVudFsyXSA/IGxlZnQgOiBsZWZ0IC0gdGhpcy5vZmZzZXQuY2xpY2subGVmdCA+PSBjb250YWlubWVudFswXSA/IGxlZnQgLSBvLmdyaWRbMF0gOiBsZWZ0ICsgby5ncmlkWzBdIDogbGVmdDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChvLmF4aXMgPT09IFxcXCJ5XFxcIikge1xcbiAgICAgICAgICBwYWdlWCA9IHRoaXMub3JpZ2luYWxQYWdlWDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChvLmF4aXMgPT09IFxcXCJ4XFxcIikge1xcbiAgICAgICAgICBwYWdlWSA9IHRoaXMub3JpZ2luYWxQYWdlWTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHtcXG4gICAgICAgIHRvcDogcGFnZVkgLSAvLyBUaGUgYWJzb2x1dGUgbW91c2UgcG9zaXRpb25cXG4gICAgICAgIHRoaXMub2Zmc2V0LmNsaWNrLnRvcCAtIC8vIENsaWNrIG9mZnNldCAocmVsYXRpdmUgdG8gdGhlIGVsZW1lbnQpXFxuICAgICAgICB0aGlzLm9mZnNldC5yZWxhdGl2ZS50b3AgLSAvLyBPbmx5IGZvciByZWxhdGl2ZSBwb3NpdGlvbmVkIG5vZGVzOiBSZWxhdGl2ZSBvZmZzZXQgZnJvbSBlbGVtZW50IHRvIG9mZnNldCBwYXJlbnRcXG4gICAgICAgIHRoaXMub2Zmc2V0LnBhcmVudC50b3AgKyAoIC8vIFRoZSBvZmZzZXRQYXJlbnQncyBvZmZzZXQgd2l0aG91dCBib3JkZXJzIChvZmZzZXQgKyBib3JkZXIpXFxuICAgICAgICB0aGlzLmNzc1Bvc2l0aW9uID09PSBcXFwiZml4ZWRcXFwiID8gLXRoaXMub2Zmc2V0LnNjcm9sbC50b3AgOiBzY3JvbGxJc1Jvb3ROb2RlID8gMCA6IHRoaXMub2Zmc2V0LnNjcm9sbC50b3ApLFxcbiAgICAgICAgbGVmdDogcGFnZVggLSAvLyBUaGUgYWJzb2x1dGUgbW91c2UgcG9zaXRpb25cXG4gICAgICAgIHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQgLSAvLyBDbGljayBvZmZzZXQgKHJlbGF0aXZlIHRvIHRoZSBlbGVtZW50KVxcbiAgICAgICAgdGhpcy5vZmZzZXQucmVsYXRpdmUubGVmdCAtIC8vIE9ubHkgZm9yIHJlbGF0aXZlIHBvc2l0aW9uZWQgbm9kZXM6IFJlbGF0aXZlIG9mZnNldCBmcm9tIGVsZW1lbnQgdG8gb2Zmc2V0IHBhcmVudFxcbiAgICAgICAgdGhpcy5vZmZzZXQucGFyZW50LmxlZnQgKyAoIC8vIFRoZSBvZmZzZXRQYXJlbnQncyBvZmZzZXQgd2l0aG91dCBib3JkZXJzIChvZmZzZXQgKyBib3JkZXIpXFxuICAgICAgICB0aGlzLmNzc1Bvc2l0aW9uID09PSBcXFwiZml4ZWRcXFwiID8gLXRoaXMub2Zmc2V0LnNjcm9sbC5sZWZ0IDogc2Nyb2xsSXNSb290Tm9kZSA/IDAgOiB0aGlzLm9mZnNldC5zY3JvbGwubGVmdClcXG4gICAgICB9O1xcbiAgICB9LFxcbiAgICBfY2xlYXI6IGZ1bmN0aW9uIF9jbGVhcigpIHtcXG4gICAgICB0aGlzLmhlbHBlci5yZW1vdmVDbGFzcyhcXFwidWktZHJhZ2dhYmxlLWRyYWdnaW5nXFxcIik7XFxuXFxuICAgICAgaWYgKHRoaXMuaGVscGVyWzBdICE9PSB0aGlzLmVsZW1lbnRbMF0gJiYgIXRoaXMuY2FuY2VsSGVscGVyUmVtb3ZhbCkge1xcbiAgICAgICAgdGhpcy5oZWxwZXIucmVtb3ZlKCk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuaGVscGVyID0gbnVsbDtcXG4gICAgICB0aGlzLmNhbmNlbEhlbHBlclJlbW92YWwgPSBmYWxzZTtcXG5cXG4gICAgICBpZiAodGhpcy5kZXN0cm95T25DbGVhcikge1xcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XFxuICAgICAgfVxcbiAgICB9LFxcbiAgICBfbm9ybWFsaXplUmlnaHRCb3R0b206IGZ1bmN0aW9uIF9ub3JtYWxpemVSaWdodEJvdHRvbSgpIHtcXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmF4aXMgIT09IFxcXCJ5XFxcIiAmJiB0aGlzLmhlbHBlci5jc3MoXFxcInJpZ2h0XFxcIikgIT09IFxcXCJhdXRvXFxcIikge1xcbiAgICAgICAgdGhpcy5oZWxwZXIud2lkdGgodGhpcy5oZWxwZXIud2lkdGgoKSk7XFxuICAgICAgICB0aGlzLmhlbHBlci5jc3MoXFxcInJpZ2h0XFxcIiwgXFxcImF1dG9cXFwiKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5heGlzICE9PSBcXFwieFxcXCIgJiYgdGhpcy5oZWxwZXIuY3NzKFxcXCJib3R0b21cXFwiKSAhPT0gXFxcImF1dG9cXFwiKSB7XFxuICAgICAgICB0aGlzLmhlbHBlci5oZWlnaHQodGhpcy5oZWxwZXIuaGVpZ2h0KCkpO1xcbiAgICAgICAgdGhpcy5oZWxwZXIuY3NzKFxcXCJib3R0b21cXFwiLCBcXFwiYXV0b1xcXCIpO1xcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgLy8gRnJvbSBub3cgb24gYnVsayBzdHVmZiAtIG1haW5seSBoZWxwZXJzXFxuICAgIF90cmlnZ2VyOiBmdW5jdGlvbiBfdHJpZ2dlcih0eXBlLCBldmVudCwgdWkpIHtcXG4gICAgICB1aSA9IHVpIHx8IHRoaXMuX3VpSGFzaCgpO1xcbiAgICAgICQudWkucGx1Z2luLmNhbGwodGhpcywgdHlwZSwgW2V2ZW50LCB1aSwgdGhpc10sIHRydWUpOyAvLyBBYnNvbHV0ZSBwb3NpdGlvbiBhbmQgb2Zmc2V0IChzZWUgIzY4ODQgKSBoYXZlIHRvIGJlIHJlY2FsY3VsYXRlZCBhZnRlciBwbHVnaW5zXFxuXFxuICAgICAgaWYgKC9eKGRyYWd8c3RhcnR8c3RvcCkvLnRlc3QodHlwZSkpIHtcXG4gICAgICAgIHRoaXMucG9zaXRpb25BYnMgPSB0aGlzLl9jb252ZXJ0UG9zaXRpb25UbyhcXFwiYWJzb2x1dGVcXFwiKTtcXG4gICAgICAgIHVpLm9mZnNldCA9IHRoaXMucG9zaXRpb25BYnM7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiAkLldpZGdldC5wcm90b3R5cGUuX3RyaWdnZXIuY2FsbCh0aGlzLCB0eXBlLCBldmVudCwgdWkpO1xcbiAgICB9LFxcbiAgICBwbHVnaW5zOiB7fSxcXG4gICAgX3VpSGFzaDogZnVuY3Rpb24gX3VpSGFzaCgpIHtcXG4gICAgICByZXR1cm4ge1xcbiAgICAgICAgaGVscGVyOiB0aGlzLmhlbHBlcixcXG4gICAgICAgIHBvc2l0aW9uOiB0aGlzLnBvc2l0aW9uLFxcbiAgICAgICAgb3JpZ2luYWxQb3NpdGlvbjogdGhpcy5vcmlnaW5hbFBvc2l0aW9uLFxcbiAgICAgICAgb2Zmc2V0OiB0aGlzLnBvc2l0aW9uQWJzXFxuICAgICAgfTtcXG4gICAgfVxcbiAgfSk7XFxuICAkLnVpLnBsdWdpbi5hZGQoXFxcImRyYWdnYWJsZVxcXCIsIFxcXCJjb25uZWN0VG9Tb3J0YWJsZVxcXCIsIHtcXG4gICAgc3RhcnQ6IGZ1bmN0aW9uIHN0YXJ0KGV2ZW50LCB1aSwgZHJhZ2dhYmxlKSB7XFxuICAgICAgdmFyIHVpU29ydGFibGUgPSAkLmV4dGVuZCh7fSwgdWksIHtcXG4gICAgICAgIGl0ZW06IGRyYWdnYWJsZS5lbGVtZW50XFxuICAgICAgfSk7XFxuICAgICAgZHJhZ2dhYmxlLnNvcnRhYmxlcyA9IFtdO1xcbiAgICAgICQoZHJhZ2dhYmxlLm9wdGlvbnMuY29ubmVjdFRvU29ydGFibGUpLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIHNvcnRhYmxlID0gJCh0aGlzKS5zb3J0YWJsZShcXFwiaW5zdGFuY2VcXFwiKTtcXG5cXG4gICAgICAgIGlmIChzb3J0YWJsZSAmJiAhc29ydGFibGUub3B0aW9ucy5kaXNhYmxlZCkge1xcbiAgICAgICAgICBkcmFnZ2FibGUuc29ydGFibGVzLnB1c2goc29ydGFibGUpOyAvLyByZWZyZXNoUG9zaXRpb25zIGlzIGNhbGxlZCBhdCBkcmFnIHN0YXJ0IHRvIHJlZnJlc2ggdGhlIGNvbnRhaW5lckNhY2hlXFxuICAgICAgICAgIC8vIHdoaWNoIGlzIHVzZWQgaW4gZHJhZy4gVGhpcyBlbnN1cmVzIGl0J3MgaW5pdGlhbGl6ZWQgYW5kIHN5bmNocm9uaXplZFxcbiAgICAgICAgICAvLyB3aXRoIGFueSBjaGFuZ2VzIHRoYXQgbWlnaHQgaGF2ZSBoYXBwZW5lZCBvbiB0aGUgcGFnZSBzaW5jZSBpbml0aWFsaXphdGlvbi5cXG5cXG4gICAgICAgICAgc29ydGFibGUucmVmcmVzaFBvc2l0aW9ucygpO1xcblxcbiAgICAgICAgICBzb3J0YWJsZS5fdHJpZ2dlcihcXFwiYWN0aXZhdGVcXFwiLCBldmVudCwgdWlTb3J0YWJsZSk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgIH0sXFxuICAgIHN0b3A6IGZ1bmN0aW9uIHN0b3AoZXZlbnQsIHVpLCBkcmFnZ2FibGUpIHtcXG4gICAgICB2YXIgdWlTb3J0YWJsZSA9ICQuZXh0ZW5kKHt9LCB1aSwge1xcbiAgICAgICAgaXRlbTogZHJhZ2dhYmxlLmVsZW1lbnRcXG4gICAgICB9KTtcXG4gICAgICBkcmFnZ2FibGUuY2FuY2VsSGVscGVyUmVtb3ZhbCA9IGZhbHNlO1xcbiAgICAgICQuZWFjaChkcmFnZ2FibGUuc29ydGFibGVzLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgc29ydGFibGUgPSB0aGlzO1xcblxcbiAgICAgICAgaWYgKHNvcnRhYmxlLmlzT3Zlcikge1xcbiAgICAgICAgICBzb3J0YWJsZS5pc092ZXIgPSAwOyAvLyBBbGxvdyB0aGlzIHNvcnRhYmxlIHRvIGhhbmRsZSByZW1vdmluZyB0aGUgaGVscGVyXFxuXFxuICAgICAgICAgIGRyYWdnYWJsZS5jYW5jZWxIZWxwZXJSZW1vdmFsID0gdHJ1ZTtcXG4gICAgICAgICAgc29ydGFibGUuY2FuY2VsSGVscGVyUmVtb3ZhbCA9IGZhbHNlOyAvLyBVc2UgX3N0b3JlZENTUyBUbyByZXN0b3JlIHByb3BlcnRpZXMgaW4gdGhlIHNvcnRhYmxlLFxcbiAgICAgICAgICAvLyBhcyB0aGlzIGFsc28gaGFuZGxlcyByZXZlcnQgKCM5Njc1KSBzaW5jZSB0aGUgZHJhZ2dhYmxlXFxuICAgICAgICAgIC8vIG1heSBoYXZlIG1vZGlmaWVkIHRoZW0gaW4gdW5leHBlY3RlZCB3YXlzICgjODgwOSlcXG5cXG4gICAgICAgICAgc29ydGFibGUuX3N0b3JlZENTUyA9IHtcXG4gICAgICAgICAgICBwb3NpdGlvbjogc29ydGFibGUucGxhY2Vob2xkZXIuY3NzKFxcXCJwb3NpdGlvblxcXCIpLFxcbiAgICAgICAgICAgIHRvcDogc29ydGFibGUucGxhY2Vob2xkZXIuY3NzKFxcXCJ0b3BcXFwiKSxcXG4gICAgICAgICAgICBsZWZ0OiBzb3J0YWJsZS5wbGFjZWhvbGRlci5jc3MoXFxcImxlZnRcXFwiKVxcbiAgICAgICAgICB9O1xcblxcbiAgICAgICAgICBzb3J0YWJsZS5fbW91c2VTdG9wKGV2ZW50KTsgLy8gT25jZSBkcmFnIGhhcyBlbmRlZCwgdGhlIHNvcnRhYmxlIHNob3VsZCByZXR1cm4gdG8gdXNpbmdcXG4gICAgICAgICAgLy8gaXRzIG9yaWdpbmFsIGhlbHBlciwgbm90IHRoZSBzaGFyZWQgaGVscGVyIGZyb20gZHJhZ2dhYmxlXFxuXFxuXFxuICAgICAgICAgIHNvcnRhYmxlLm9wdGlvbnMuaGVscGVyID0gc29ydGFibGUub3B0aW9ucy5faGVscGVyO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgLy8gUHJldmVudCB0aGlzIFNvcnRhYmxlIGZyb20gcmVtb3ZpbmcgdGhlIGhlbHBlci5cXG4gICAgICAgICAgLy8gSG93ZXZlciwgZG9uJ3Qgc2V0IHRoZSBkcmFnZ2FibGUgdG8gcmVtb3ZlIHRoZSBoZWxwZXJcXG4gICAgICAgICAgLy8gZWl0aGVyIGFzIGFub3RoZXIgY29ubmVjdGVkIFNvcnRhYmxlIG1heSB5ZXQgaGFuZGxlIHRoZSByZW1vdmFsLlxcbiAgICAgICAgICBzb3J0YWJsZS5jYW5jZWxIZWxwZXJSZW1vdmFsID0gdHJ1ZTtcXG5cXG4gICAgICAgICAgc29ydGFibGUuX3RyaWdnZXIoXFxcImRlYWN0aXZhdGVcXFwiLCBldmVudCwgdWlTb3J0YWJsZSk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgIH0sXFxuICAgIGRyYWc6IGZ1bmN0aW9uIGRyYWcoZXZlbnQsIHVpLCBkcmFnZ2FibGUpIHtcXG4gICAgICAkLmVhY2goZHJhZ2dhYmxlLnNvcnRhYmxlcywgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIGlubmVybW9zdEludGVyc2VjdGluZyA9IGZhbHNlLFxcbiAgICAgICAgICAgIHNvcnRhYmxlID0gdGhpczsgLy8gQ29weSBvdmVyIHZhcmlhYmxlcyB0aGF0IHNvcnRhYmxlJ3MgX2ludGVyc2VjdHNXaXRoIHVzZXNcXG5cXG4gICAgICAgIHNvcnRhYmxlLnBvc2l0aW9uQWJzID0gZHJhZ2dhYmxlLnBvc2l0aW9uQWJzO1xcbiAgICAgICAgc29ydGFibGUuaGVscGVyUHJvcG9ydGlvbnMgPSBkcmFnZ2FibGUuaGVscGVyUHJvcG9ydGlvbnM7XFxuICAgICAgICBzb3J0YWJsZS5vZmZzZXQuY2xpY2sgPSBkcmFnZ2FibGUub2Zmc2V0LmNsaWNrO1xcblxcbiAgICAgICAgaWYgKHNvcnRhYmxlLl9pbnRlcnNlY3RzV2l0aChzb3J0YWJsZS5jb250YWluZXJDYWNoZSkpIHtcXG4gICAgICAgICAgaW5uZXJtb3N0SW50ZXJzZWN0aW5nID0gdHJ1ZTtcXG4gICAgICAgICAgJC5lYWNoKGRyYWdnYWJsZS5zb3J0YWJsZXMsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAvLyBDb3B5IG92ZXIgdmFyaWFibGVzIHRoYXQgc29ydGFibGUncyBfaW50ZXJzZWN0c1dpdGggdXNlc1xcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25BYnMgPSBkcmFnZ2FibGUucG9zaXRpb25BYnM7XFxuICAgICAgICAgICAgdGhpcy5oZWxwZXJQcm9wb3J0aW9ucyA9IGRyYWdnYWJsZS5oZWxwZXJQcm9wb3J0aW9ucztcXG4gICAgICAgICAgICB0aGlzLm9mZnNldC5jbGljayA9IGRyYWdnYWJsZS5vZmZzZXQuY2xpY2s7XFxuXFxuICAgICAgICAgICAgaWYgKHRoaXMgIT09IHNvcnRhYmxlICYmIHRoaXMuX2ludGVyc2VjdHNXaXRoKHRoaXMuY29udGFpbmVyQ2FjaGUpICYmICQuY29udGFpbnMoc29ydGFibGUuZWxlbWVudFswXSwgdGhpcy5lbGVtZW50WzBdKSkge1xcbiAgICAgICAgICAgICAgaW5uZXJtb3N0SW50ZXJzZWN0aW5nID0gZmFsc2U7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIHJldHVybiBpbm5lcm1vc3RJbnRlcnNlY3Rpbmc7XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKGlubmVybW9zdEludGVyc2VjdGluZykge1xcbiAgICAgICAgICAvLyBJZiBpdCBpbnRlcnNlY3RzLCB3ZSB1c2UgYSBsaXR0bGUgaXNPdmVyIHZhcmlhYmxlIGFuZCBzZXQgaXQgb25jZSxcXG4gICAgICAgICAgLy8gc28gdGhhdCB0aGUgbW92ZS1pbiBzdHVmZiBnZXRzIGZpcmVkIG9ubHkgb25jZS5cXG4gICAgICAgICAgaWYgKCFzb3J0YWJsZS5pc092ZXIpIHtcXG4gICAgICAgICAgICBzb3J0YWJsZS5pc092ZXIgPSAxOyAvLyBTdG9yZSBkcmFnZ2FibGUncyBwYXJlbnQgaW4gY2FzZSB3ZSBuZWVkIHRvIHJlYXBwZW5kIHRvIGl0IGxhdGVyLlxcblxcbiAgICAgICAgICAgIGRyYWdnYWJsZS5fcGFyZW50ID0gdWkuaGVscGVyLnBhcmVudCgpO1xcbiAgICAgICAgICAgIHNvcnRhYmxlLmN1cnJlbnRJdGVtID0gdWkuaGVscGVyLmFwcGVuZFRvKHNvcnRhYmxlLmVsZW1lbnQpLmRhdGEoXFxcInVpLXNvcnRhYmxlLWl0ZW1cXFwiLCB0cnVlKTsgLy8gU3RvcmUgaGVscGVyIG9wdGlvbiB0byBsYXRlciByZXN0b3JlIGl0XFxuXFxuICAgICAgICAgICAgc29ydGFibGUub3B0aW9ucy5faGVscGVyID0gc29ydGFibGUub3B0aW9ucy5oZWxwZXI7XFxuXFxuICAgICAgICAgICAgc29ydGFibGUub3B0aW9ucy5oZWxwZXIgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICByZXR1cm4gdWkuaGVscGVyWzBdO1xcbiAgICAgICAgICAgIH07IC8vIEZpcmUgdGhlIHN0YXJ0IGV2ZW50cyBvZiB0aGUgc29ydGFibGUgd2l0aCBvdXIgcGFzc2VkIGJyb3dzZXIgZXZlbnQsXFxuICAgICAgICAgICAgLy8gYW5kIG91ciBvd24gaGVscGVyIChzbyBpdCBkb2Vzbid0IGNyZWF0ZSBhIG5ldyBvbmUpXFxuXFxuXFxuICAgICAgICAgICAgZXZlbnQudGFyZ2V0ID0gc29ydGFibGUuY3VycmVudEl0ZW1bMF07XFxuXFxuICAgICAgICAgICAgc29ydGFibGUuX21vdXNlQ2FwdHVyZShldmVudCwgdHJ1ZSk7XFxuXFxuICAgICAgICAgICAgc29ydGFibGUuX21vdXNlU3RhcnQoZXZlbnQsIHRydWUsIHRydWUpOyAvLyBCZWNhdXNlIHRoZSBicm93c2VyIGV2ZW50IGlzIHdheSBvZmYgdGhlIG5ldyBhcHBlbmRlZCBwb3J0bGV0LFxcbiAgICAgICAgICAgIC8vIG1vZGlmeSBuZWNlc3NhcnkgdmFyaWFibGVzIHRvIHJlZmxlY3QgdGhlIGNoYW5nZXNcXG5cXG5cXG4gICAgICAgICAgICBzb3J0YWJsZS5vZmZzZXQuY2xpY2sudG9wID0gZHJhZ2dhYmxlLm9mZnNldC5jbGljay50b3A7XFxuICAgICAgICAgICAgc29ydGFibGUub2Zmc2V0LmNsaWNrLmxlZnQgPSBkcmFnZ2FibGUub2Zmc2V0LmNsaWNrLmxlZnQ7XFxuICAgICAgICAgICAgc29ydGFibGUub2Zmc2V0LnBhcmVudC5sZWZ0IC09IGRyYWdnYWJsZS5vZmZzZXQucGFyZW50LmxlZnQgLSBzb3J0YWJsZS5vZmZzZXQucGFyZW50LmxlZnQ7XFxuICAgICAgICAgICAgc29ydGFibGUub2Zmc2V0LnBhcmVudC50b3AgLT0gZHJhZ2dhYmxlLm9mZnNldC5wYXJlbnQudG9wIC0gc29ydGFibGUub2Zmc2V0LnBhcmVudC50b3A7XFxuXFxuICAgICAgICAgICAgZHJhZ2dhYmxlLl90cmlnZ2VyKFxcXCJ0b1NvcnRhYmxlXFxcIiwgZXZlbnQpOyAvLyBJbmZvcm0gZHJhZ2dhYmxlIHRoYXQgdGhlIGhlbHBlciBpcyBpbiBhIHZhbGlkIGRyb3Agem9uZSxcXG4gICAgICAgICAgICAvLyB1c2VkIHNvbGVseSBpbiB0aGUgcmV2ZXJ0IG9wdGlvbiB0byBoYW5kbGUgXFxcInZhbGlkL2ludmFsaWRcXFwiLlxcblxcblxcbiAgICAgICAgICAgIGRyYWdnYWJsZS5kcm9wcGVkID0gc29ydGFibGUuZWxlbWVudDsgLy8gTmVlZCB0byByZWZyZXNoUG9zaXRpb25zIG9mIGFsbCBzb3J0YWJsZXMgaW4gdGhlIGNhc2UgdGhhdFxcbiAgICAgICAgICAgIC8vIGFkZGluZyB0byBvbmUgc29ydGFibGUgY2hhbmdlcyB0aGUgbG9jYXRpb24gb2YgdGhlIG90aGVyIHNvcnRhYmxlcyAoIzk2NzUpXFxuXFxuICAgICAgICAgICAgJC5lYWNoKGRyYWdnYWJsZS5zb3J0YWJsZXMsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgIHRoaXMucmVmcmVzaFBvc2l0aW9ucygpO1xcbiAgICAgICAgICAgIH0pOyAvLyBoYWNrIHNvIHJlY2VpdmUvdXBkYXRlIGNhbGxiYWNrcyB3b3JrIChtb3N0bHkpXFxuXFxuICAgICAgICAgICAgZHJhZ2dhYmxlLmN1cnJlbnRJdGVtID0gZHJhZ2dhYmxlLmVsZW1lbnQ7XFxuICAgICAgICAgICAgc29ydGFibGUuZnJvbU91dHNpZGUgPSBkcmFnZ2FibGU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaWYgKHNvcnRhYmxlLmN1cnJlbnRJdGVtKSB7XFxuICAgICAgICAgICAgc29ydGFibGUuX21vdXNlRHJhZyhldmVudCk7IC8vIENvcHkgdGhlIHNvcnRhYmxlJ3MgcG9zaXRpb24gYmVjYXVzZSB0aGUgZHJhZ2dhYmxlJ3MgY2FuIHBvdGVudGlhbGx5IHJlZmxlY3RcXG4gICAgICAgICAgICAvLyBhIHJlbGF0aXZlIHBvc2l0aW9uLCB3aGlsZSBzb3J0YWJsZSBpcyBhbHdheXMgYWJzb2x1dGUsIHdoaWNoIHRoZSBkcmFnZ2VkXFxuICAgICAgICAgICAgLy8gZWxlbWVudCBoYXMgbm93IGJlY29tZS4gKCM4ODA5KVxcblxcblxcbiAgICAgICAgICAgIHVpLnBvc2l0aW9uID0gc29ydGFibGUucG9zaXRpb247XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIC8vIElmIGl0IGRvZXNuJ3QgaW50ZXJzZWN0IHdpdGggdGhlIHNvcnRhYmxlLCBhbmQgaXQgaW50ZXJzZWN0ZWQgYmVmb3JlLFxcbiAgICAgICAgICAvLyB3ZSBmYWtlIHRoZSBkcmFnIHN0b3Agb2YgdGhlIHNvcnRhYmxlLCBidXQgbWFrZSBzdXJlIGl0IGRvZXNuJ3QgcmVtb3ZlXFxuICAgICAgICAgIC8vIHRoZSBoZWxwZXIgYnkgdXNpbmcgY2FuY2VsSGVscGVyUmVtb3ZhbC5cXG4gICAgICAgICAgaWYgKHNvcnRhYmxlLmlzT3Zlcikge1xcbiAgICAgICAgICAgIHNvcnRhYmxlLmlzT3ZlciA9IDA7XFxuICAgICAgICAgICAgc29ydGFibGUuY2FuY2VsSGVscGVyUmVtb3ZhbCA9IHRydWU7IC8vIENhbGxpbmcgc29ydGFibGUncyBtb3VzZVN0b3Agd291bGQgdHJpZ2dlciBhIHJldmVydCxcXG4gICAgICAgICAgICAvLyBzbyByZXZlcnQgbXVzdCBiZSB0ZW1wb3JhcmlseSBmYWxzZSB1bnRpbCBhZnRlciBtb3VzZVN0b3AgaXMgY2FsbGVkLlxcblxcbiAgICAgICAgICAgIHNvcnRhYmxlLm9wdGlvbnMuX3JldmVydCA9IHNvcnRhYmxlLm9wdGlvbnMucmV2ZXJ0O1xcbiAgICAgICAgICAgIHNvcnRhYmxlLm9wdGlvbnMucmV2ZXJ0ID0gZmFsc2U7XFxuXFxuICAgICAgICAgICAgc29ydGFibGUuX3RyaWdnZXIoXFxcIm91dFxcXCIsIGV2ZW50LCBzb3J0YWJsZS5fdWlIYXNoKHNvcnRhYmxlKSk7XFxuXFxuICAgICAgICAgICAgc29ydGFibGUuX21vdXNlU3RvcChldmVudCwgdHJ1ZSk7IC8vIHJlc3RvcmUgc29ydGFibGUgYmVoYXZpb3JzIHRoYXQgd2VyZSBtb2RmaWVkXFxuICAgICAgICAgICAgLy8gd2hlbiB0aGUgZHJhZ2dhYmxlIGVudGVyZWQgdGhlIHNvcnRhYmxlIGFyZWEgKCM5NDgxKVxcblxcblxcbiAgICAgICAgICAgIHNvcnRhYmxlLm9wdGlvbnMucmV2ZXJ0ID0gc29ydGFibGUub3B0aW9ucy5fcmV2ZXJ0O1xcbiAgICAgICAgICAgIHNvcnRhYmxlLm9wdGlvbnMuaGVscGVyID0gc29ydGFibGUub3B0aW9ucy5faGVscGVyO1xcblxcbiAgICAgICAgICAgIGlmIChzb3J0YWJsZS5wbGFjZWhvbGRlcikge1xcbiAgICAgICAgICAgICAgc29ydGFibGUucGxhY2Vob2xkZXIucmVtb3ZlKCk7XFxuICAgICAgICAgICAgfSAvLyBSZXN0b3JlIGFuZCByZWNhbGN1bGF0ZSB0aGUgZHJhZ2dhYmxlJ3Mgb2Zmc2V0IGNvbnNpZGVyaW5nIHRoZSBzb3J0YWJsZVxcbiAgICAgICAgICAgIC8vIG1heSBoYXZlIG1vZGlmaWVkIHRoZW0gaW4gdW5leHBlY3RlZCB3YXlzLiAoIzg4MDksICMxMDY2OSlcXG5cXG5cXG4gICAgICAgICAgICB1aS5oZWxwZXIuYXBwZW5kVG8oZHJhZ2dhYmxlLl9wYXJlbnQpO1xcblxcbiAgICAgICAgICAgIGRyYWdnYWJsZS5fcmVmcmVzaE9mZnNldHMoZXZlbnQpO1xcblxcbiAgICAgICAgICAgIHVpLnBvc2l0aW9uID0gZHJhZ2dhYmxlLl9nZW5lcmF0ZVBvc2l0aW9uKGV2ZW50LCB0cnVlKTtcXG5cXG4gICAgICAgICAgICBkcmFnZ2FibGUuX3RyaWdnZXIoXFxcImZyb21Tb3J0YWJsZVxcXCIsIGV2ZW50KTsgLy8gSW5mb3JtIGRyYWdnYWJsZSB0aGF0IHRoZSBoZWxwZXIgaXMgbm8gbG9uZ2VyIGluIGEgdmFsaWQgZHJvcCB6b25lXFxuXFxuXFxuICAgICAgICAgICAgZHJhZ2dhYmxlLmRyb3BwZWQgPSBmYWxzZTsgLy8gTmVlZCB0byByZWZyZXNoUG9zaXRpb25zIG9mIGFsbCBzb3J0YWJsZXMganVzdCBpbiBjYXNlIHJlbW92aW5nXFxuICAgICAgICAgICAgLy8gZnJvbSBvbmUgc29ydGFibGUgY2hhbmdlcyB0aGUgbG9jYXRpb24gb2Ygb3RoZXIgc29ydGFibGVzICgjOTY3NSlcXG5cXG4gICAgICAgICAgICAkLmVhY2goZHJhZ2dhYmxlLnNvcnRhYmxlcywgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoUG9zaXRpb25zKCk7XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgfVxcbiAgfSk7XFxuICAkLnVpLnBsdWdpbi5hZGQoXFxcImRyYWdnYWJsZVxcXCIsIFxcXCJjdXJzb3JcXFwiLCB7XFxuICAgIHN0YXJ0OiBmdW5jdGlvbiBzdGFydChldmVudCwgdWksIGluc3RhbmNlKSB7XFxuICAgICAgdmFyIHQgPSAkKFxcXCJib2R5XFxcIiksXFxuICAgICAgICAgIG8gPSBpbnN0YW5jZS5vcHRpb25zO1xcblxcbiAgICAgIGlmICh0LmNzcyhcXFwiY3Vyc29yXFxcIikpIHtcXG4gICAgICAgIG8uX2N1cnNvciA9IHQuY3NzKFxcXCJjdXJzb3JcXFwiKTtcXG4gICAgICB9XFxuXFxuICAgICAgdC5jc3MoXFxcImN1cnNvclxcXCIsIG8uY3Vyc29yKTtcXG4gICAgfSxcXG4gICAgc3RvcDogZnVuY3Rpb24gc3RvcChldmVudCwgdWksIGluc3RhbmNlKSB7XFxuICAgICAgdmFyIG8gPSBpbnN0YW5jZS5vcHRpb25zO1xcblxcbiAgICAgIGlmIChvLl9jdXJzb3IpIHtcXG4gICAgICAgICQoXFxcImJvZHlcXFwiKS5jc3MoXFxcImN1cnNvclxcXCIsIG8uX2N1cnNvcik7XFxuICAgICAgfVxcbiAgICB9XFxuICB9KTtcXG4gICQudWkucGx1Z2luLmFkZChcXFwiZHJhZ2dhYmxlXFxcIiwgXFxcIm9wYWNpdHlcXFwiLCB7XFxuICAgIHN0YXJ0OiBmdW5jdGlvbiBzdGFydChldmVudCwgdWksIGluc3RhbmNlKSB7XFxuICAgICAgdmFyIHQgPSAkKHVpLmhlbHBlciksXFxuICAgICAgICAgIG8gPSBpbnN0YW5jZS5vcHRpb25zO1xcblxcbiAgICAgIGlmICh0LmNzcyhcXFwib3BhY2l0eVxcXCIpKSB7XFxuICAgICAgICBvLl9vcGFjaXR5ID0gdC5jc3MoXFxcIm9wYWNpdHlcXFwiKTtcXG4gICAgICB9XFxuXFxuICAgICAgdC5jc3MoXFxcIm9wYWNpdHlcXFwiLCBvLm9wYWNpdHkpO1xcbiAgICB9LFxcbiAgICBzdG9wOiBmdW5jdGlvbiBzdG9wKGV2ZW50LCB1aSwgaW5zdGFuY2UpIHtcXG4gICAgICB2YXIgbyA9IGluc3RhbmNlLm9wdGlvbnM7XFxuXFxuICAgICAgaWYgKG8uX29wYWNpdHkpIHtcXG4gICAgICAgICQodWkuaGVscGVyKS5jc3MoXFxcIm9wYWNpdHlcXFwiLCBvLl9vcGFjaXR5KTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH0pO1xcbiAgJC51aS5wbHVnaW4uYWRkKFxcXCJkcmFnZ2FibGVcXFwiLCBcXFwic2Nyb2xsXFxcIiwge1xcbiAgICBzdGFydDogZnVuY3Rpb24gc3RhcnQoZXZlbnQsIHVpLCBpKSB7XFxuICAgICAgaWYgKCFpLnNjcm9sbFBhcmVudE5vdEhpZGRlbikge1xcbiAgICAgICAgaS5zY3JvbGxQYXJlbnROb3RIaWRkZW4gPSBpLmhlbHBlci5zY3JvbGxQYXJlbnQoZmFsc2UpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoaS5zY3JvbGxQYXJlbnROb3RIaWRkZW5bMF0gIT09IGkuZG9jdW1lbnRbMF0gJiYgaS5zY3JvbGxQYXJlbnROb3RIaWRkZW5bMF0udGFnTmFtZSAhPT0gXFxcIkhUTUxcXFwiKSB7XFxuICAgICAgICBpLm92ZXJmbG93T2Zmc2V0ID0gaS5zY3JvbGxQYXJlbnROb3RIaWRkZW4ub2Zmc2V0KCk7XFxuICAgICAgfVxcbiAgICB9LFxcbiAgICBkcmFnOiBmdW5jdGlvbiBkcmFnKGV2ZW50LCB1aSwgaSkge1xcbiAgICAgIHZhciBvID0gaS5vcHRpb25zLFxcbiAgICAgICAgICBzY3JvbGxlZCA9IGZhbHNlLFxcbiAgICAgICAgICBzY3JvbGxQYXJlbnQgPSBpLnNjcm9sbFBhcmVudE5vdEhpZGRlblswXSxcXG4gICAgICAgICAgZG9jdW1lbnQgPSBpLmRvY3VtZW50WzBdO1xcblxcbiAgICAgIGlmIChzY3JvbGxQYXJlbnQgIT09IGRvY3VtZW50ICYmIHNjcm9sbFBhcmVudC50YWdOYW1lICE9PSBcXFwiSFRNTFxcXCIpIHtcXG4gICAgICAgIGlmICghby5heGlzIHx8IG8uYXhpcyAhPT0gXFxcInhcXFwiKSB7XFxuICAgICAgICAgIGlmIChpLm92ZXJmbG93T2Zmc2V0LnRvcCArIHNjcm9sbFBhcmVudC5vZmZzZXRIZWlnaHQgLSBldmVudC5wYWdlWSA8IG8uc2Nyb2xsU2Vuc2l0aXZpdHkpIHtcXG4gICAgICAgICAgICBzY3JvbGxQYXJlbnQuc2Nyb2xsVG9wID0gc2Nyb2xsZWQgPSBzY3JvbGxQYXJlbnQuc2Nyb2xsVG9wICsgby5zY3JvbGxTcGVlZDtcXG4gICAgICAgICAgfSBlbHNlIGlmIChldmVudC5wYWdlWSAtIGkub3ZlcmZsb3dPZmZzZXQudG9wIDwgby5zY3JvbGxTZW5zaXRpdml0eSkge1xcbiAgICAgICAgICAgIHNjcm9sbFBhcmVudC5zY3JvbGxUb3AgPSBzY3JvbGxlZCA9IHNjcm9sbFBhcmVudC5zY3JvbGxUb3AgLSBvLnNjcm9sbFNwZWVkO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoIW8uYXhpcyB8fCBvLmF4aXMgIT09IFxcXCJ5XFxcIikge1xcbiAgICAgICAgICBpZiAoaS5vdmVyZmxvd09mZnNldC5sZWZ0ICsgc2Nyb2xsUGFyZW50Lm9mZnNldFdpZHRoIC0gZXZlbnQucGFnZVggPCBvLnNjcm9sbFNlbnNpdGl2aXR5KSB7XFxuICAgICAgICAgICAgc2Nyb2xsUGFyZW50LnNjcm9sbExlZnQgPSBzY3JvbGxlZCA9IHNjcm9sbFBhcmVudC5zY3JvbGxMZWZ0ICsgby5zY3JvbGxTcGVlZDtcXG4gICAgICAgICAgfSBlbHNlIGlmIChldmVudC5wYWdlWCAtIGkub3ZlcmZsb3dPZmZzZXQubGVmdCA8IG8uc2Nyb2xsU2Vuc2l0aXZpdHkpIHtcXG4gICAgICAgICAgICBzY3JvbGxQYXJlbnQuc2Nyb2xsTGVmdCA9IHNjcm9sbGVkID0gc2Nyb2xsUGFyZW50LnNjcm9sbExlZnQgLSBvLnNjcm9sbFNwZWVkO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGlmICghby5heGlzIHx8IG8uYXhpcyAhPT0gXFxcInhcXFwiKSB7XFxuICAgICAgICAgIGlmIChldmVudC5wYWdlWSAtICQoZG9jdW1lbnQpLnNjcm9sbFRvcCgpIDwgby5zY3JvbGxTZW5zaXRpdml0eSkge1xcbiAgICAgICAgICAgIHNjcm9sbGVkID0gJChkb2N1bWVudCkuc2Nyb2xsVG9wKCQoZG9jdW1lbnQpLnNjcm9sbFRvcCgpIC0gby5zY3JvbGxTcGVlZCk7XFxuICAgICAgICAgIH0gZWxzZSBpZiAoJCh3aW5kb3cpLmhlaWdodCgpIC0gKGV2ZW50LnBhZ2VZIC0gJChkb2N1bWVudCkuc2Nyb2xsVG9wKCkpIDwgby5zY3JvbGxTZW5zaXRpdml0eSkge1xcbiAgICAgICAgICAgIHNjcm9sbGVkID0gJChkb2N1bWVudCkuc2Nyb2xsVG9wKCQoZG9jdW1lbnQpLnNjcm9sbFRvcCgpICsgby5zY3JvbGxTcGVlZCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICghby5heGlzIHx8IG8uYXhpcyAhPT0gXFxcInlcXFwiKSB7XFxuICAgICAgICAgIGlmIChldmVudC5wYWdlWCAtICQoZG9jdW1lbnQpLnNjcm9sbExlZnQoKSA8IG8uc2Nyb2xsU2Vuc2l0aXZpdHkpIHtcXG4gICAgICAgICAgICBzY3JvbGxlZCA9ICQoZG9jdW1lbnQpLnNjcm9sbExlZnQoJChkb2N1bWVudCkuc2Nyb2xsTGVmdCgpIC0gby5zY3JvbGxTcGVlZCk7XFxuICAgICAgICAgIH0gZWxzZSBpZiAoJCh3aW5kb3cpLndpZHRoKCkgLSAoZXZlbnQucGFnZVggLSAkKGRvY3VtZW50KS5zY3JvbGxMZWZ0KCkpIDwgby5zY3JvbGxTZW5zaXRpdml0eSkge1xcbiAgICAgICAgICAgIHNjcm9sbGVkID0gJChkb2N1bWVudCkuc2Nyb2xsTGVmdCgkKGRvY3VtZW50KS5zY3JvbGxMZWZ0KCkgKyBvLnNjcm9sbFNwZWVkKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoc2Nyb2xsZWQgIT09IGZhbHNlICYmICQudWkuZGRtYW5hZ2VyICYmICFvLmRyb3BCZWhhdmlvdXIpIHtcXG4gICAgICAgICQudWkuZGRtYW5hZ2VyLnByZXBhcmVPZmZzZXRzKGksIGV2ZW50KTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH0pO1xcbiAgJC51aS5wbHVnaW4uYWRkKFxcXCJkcmFnZ2FibGVcXFwiLCBcXFwic25hcFxcXCIsIHtcXG4gICAgc3RhcnQ6IGZ1bmN0aW9uIHN0YXJ0KGV2ZW50LCB1aSwgaSkge1xcbiAgICAgIHZhciBvID0gaS5vcHRpb25zO1xcbiAgICAgIGkuc25hcEVsZW1lbnRzID0gW107XFxuICAgICAgJChvLnNuYXAuY29uc3RydWN0b3IgIT09IFN0cmluZyA/IG8uc25hcC5pdGVtcyB8fCBcXFwiOmRhdGEodWktZHJhZ2dhYmxlKVxcXCIgOiBvLnNuYXApLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyICR0ID0gJCh0aGlzKSxcXG4gICAgICAgICAgICAkbyA9ICR0Lm9mZnNldCgpO1xcblxcbiAgICAgICAgaWYgKHRoaXMgIT09IGkuZWxlbWVudFswXSkge1xcbiAgICAgICAgICBpLnNuYXBFbGVtZW50cy5wdXNoKHtcXG4gICAgICAgICAgICBpdGVtOiB0aGlzLFxcbiAgICAgICAgICAgIHdpZHRoOiAkdC5vdXRlcldpZHRoKCksXFxuICAgICAgICAgICAgaGVpZ2h0OiAkdC5vdXRlckhlaWdodCgpLFxcbiAgICAgICAgICAgIHRvcDogJG8udG9wLFxcbiAgICAgICAgICAgIGxlZnQ6ICRvLmxlZnRcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgIH0sXFxuICAgIGRyYWc6IGZ1bmN0aW9uIGRyYWcoZXZlbnQsIHVpLCBpbnN0KSB7XFxuICAgICAgdmFyIHRzLFxcbiAgICAgICAgICBicyxcXG4gICAgICAgICAgbHMsXFxuICAgICAgICAgIHJzLFxcbiAgICAgICAgICBsLFxcbiAgICAgICAgICByLFxcbiAgICAgICAgICB0LFxcbiAgICAgICAgICBiLFxcbiAgICAgICAgICBpLFxcbiAgICAgICAgICBmaXJzdCxcXG4gICAgICAgICAgbyA9IGluc3Qub3B0aW9ucyxcXG4gICAgICAgICAgZCA9IG8uc25hcFRvbGVyYW5jZSxcXG4gICAgICAgICAgeDEgPSB1aS5vZmZzZXQubGVmdCxcXG4gICAgICAgICAgeDIgPSB4MSArIGluc3QuaGVscGVyUHJvcG9ydGlvbnMud2lkdGgsXFxuICAgICAgICAgIHkxID0gdWkub2Zmc2V0LnRvcCxcXG4gICAgICAgICAgeTIgPSB5MSArIGluc3QuaGVscGVyUHJvcG9ydGlvbnMuaGVpZ2h0O1xcblxcbiAgICAgIGZvciAoaSA9IGluc3Quc25hcEVsZW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XFxuICAgICAgICBsID0gaW5zdC5zbmFwRWxlbWVudHNbaV0ubGVmdCAtIGluc3QubWFyZ2lucy5sZWZ0O1xcbiAgICAgICAgciA9IGwgKyBpbnN0LnNuYXBFbGVtZW50c1tpXS53aWR0aDtcXG4gICAgICAgIHQgPSBpbnN0LnNuYXBFbGVtZW50c1tpXS50b3AgLSBpbnN0Lm1hcmdpbnMudG9wO1xcbiAgICAgICAgYiA9IHQgKyBpbnN0LnNuYXBFbGVtZW50c1tpXS5oZWlnaHQ7XFxuXFxuICAgICAgICBpZiAoeDIgPCBsIC0gZCB8fCB4MSA+IHIgKyBkIHx8IHkyIDwgdCAtIGQgfHwgeTEgPiBiICsgZCB8fCAhJC5jb250YWlucyhpbnN0LnNuYXBFbGVtZW50c1tpXS5pdGVtLm93bmVyRG9jdW1lbnQsIGluc3Quc25hcEVsZW1lbnRzW2ldLml0ZW0pKSB7XFxuICAgICAgICAgIGlmIChpbnN0LnNuYXBFbGVtZW50c1tpXS5zbmFwcGluZykge1xcbiAgICAgICAgICAgIGluc3Qub3B0aW9ucy5zbmFwLnJlbGVhc2UgJiYgaW5zdC5vcHRpb25zLnNuYXAucmVsZWFzZS5jYWxsKGluc3QuZWxlbWVudCwgZXZlbnQsICQuZXh0ZW5kKGluc3QuX3VpSGFzaCgpLCB7XFxuICAgICAgICAgICAgICBzbmFwSXRlbTogaW5zdC5zbmFwRWxlbWVudHNbaV0uaXRlbVxcbiAgICAgICAgICAgIH0pKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpbnN0LnNuYXBFbGVtZW50c1tpXS5zbmFwcGluZyA9IGZhbHNlO1xcbiAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChvLnNuYXBNb2RlICE9PSBcXFwiaW5uZXJcXFwiKSB7XFxuICAgICAgICAgIHRzID0gTWF0aC5hYnModCAtIHkyKSA8PSBkO1xcbiAgICAgICAgICBicyA9IE1hdGguYWJzKGIgLSB5MSkgPD0gZDtcXG4gICAgICAgICAgbHMgPSBNYXRoLmFicyhsIC0geDIpIDw9IGQ7XFxuICAgICAgICAgIHJzID0gTWF0aC5hYnMociAtIHgxKSA8PSBkO1xcblxcbiAgICAgICAgICBpZiAodHMpIHtcXG4gICAgICAgICAgICB1aS5wb3NpdGlvbi50b3AgPSBpbnN0Ll9jb252ZXJ0UG9zaXRpb25UbyhcXFwicmVsYXRpdmVcXFwiLCB7XFxuICAgICAgICAgICAgICB0b3A6IHQgLSBpbnN0LmhlbHBlclByb3BvcnRpb25zLmhlaWdodCxcXG4gICAgICAgICAgICAgIGxlZnQ6IDBcXG4gICAgICAgICAgICB9KS50b3A7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaWYgKGJzKSB7XFxuICAgICAgICAgICAgdWkucG9zaXRpb24udG9wID0gaW5zdC5fY29udmVydFBvc2l0aW9uVG8oXFxcInJlbGF0aXZlXFxcIiwge1xcbiAgICAgICAgICAgICAgdG9wOiBiLFxcbiAgICAgICAgICAgICAgbGVmdDogMFxcbiAgICAgICAgICAgIH0pLnRvcDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAobHMpIHtcXG4gICAgICAgICAgICB1aS5wb3NpdGlvbi5sZWZ0ID0gaW5zdC5fY29udmVydFBvc2l0aW9uVG8oXFxcInJlbGF0aXZlXFxcIiwge1xcbiAgICAgICAgICAgICAgdG9wOiAwLFxcbiAgICAgICAgICAgICAgbGVmdDogbCAtIGluc3QuaGVscGVyUHJvcG9ydGlvbnMud2lkdGhcXG4gICAgICAgICAgICB9KS5sZWZ0O1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmIChycykge1xcbiAgICAgICAgICAgIHVpLnBvc2l0aW9uLmxlZnQgPSBpbnN0Ll9jb252ZXJ0UG9zaXRpb25UbyhcXFwicmVsYXRpdmVcXFwiLCB7XFxuICAgICAgICAgICAgICB0b3A6IDAsXFxuICAgICAgICAgICAgICBsZWZ0OiByXFxuICAgICAgICAgICAgfSkubGVmdDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgZmlyc3QgPSB0cyB8fCBicyB8fCBscyB8fCBycztcXG5cXG4gICAgICAgIGlmIChvLnNuYXBNb2RlICE9PSBcXFwib3V0ZXJcXFwiKSB7XFxuICAgICAgICAgIHRzID0gTWF0aC5hYnModCAtIHkxKSA8PSBkO1xcbiAgICAgICAgICBicyA9IE1hdGguYWJzKGIgLSB5MikgPD0gZDtcXG4gICAgICAgICAgbHMgPSBNYXRoLmFicyhsIC0geDEpIDw9IGQ7XFxuICAgICAgICAgIHJzID0gTWF0aC5hYnMociAtIHgyKSA8PSBkO1xcblxcbiAgICAgICAgICBpZiAodHMpIHtcXG4gICAgICAgICAgICB1aS5wb3NpdGlvbi50b3AgPSBpbnN0Ll9jb252ZXJ0UG9zaXRpb25UbyhcXFwicmVsYXRpdmVcXFwiLCB7XFxuICAgICAgICAgICAgICB0b3A6IHQsXFxuICAgICAgICAgICAgICBsZWZ0OiAwXFxuICAgICAgICAgICAgfSkudG9wO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmIChicykge1xcbiAgICAgICAgICAgIHVpLnBvc2l0aW9uLnRvcCA9IGluc3QuX2NvbnZlcnRQb3NpdGlvblRvKFxcXCJyZWxhdGl2ZVxcXCIsIHtcXG4gICAgICAgICAgICAgIHRvcDogYiAtIGluc3QuaGVscGVyUHJvcG9ydGlvbnMuaGVpZ2h0LFxcbiAgICAgICAgICAgICAgbGVmdDogMFxcbiAgICAgICAgICAgIH0pLnRvcDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAobHMpIHtcXG4gICAgICAgICAgICB1aS5wb3NpdGlvbi5sZWZ0ID0gaW5zdC5fY29udmVydFBvc2l0aW9uVG8oXFxcInJlbGF0aXZlXFxcIiwge1xcbiAgICAgICAgICAgICAgdG9wOiAwLFxcbiAgICAgICAgICAgICAgbGVmdDogbFxcbiAgICAgICAgICAgIH0pLmxlZnQ7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaWYgKHJzKSB7XFxuICAgICAgICAgICAgdWkucG9zaXRpb24ubGVmdCA9IGluc3QuX2NvbnZlcnRQb3NpdGlvblRvKFxcXCJyZWxhdGl2ZVxcXCIsIHtcXG4gICAgICAgICAgICAgIHRvcDogMCxcXG4gICAgICAgICAgICAgIGxlZnQ6IHIgLSBpbnN0LmhlbHBlclByb3BvcnRpb25zLndpZHRoXFxuICAgICAgICAgICAgfSkubGVmdDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKCFpbnN0LnNuYXBFbGVtZW50c1tpXS5zbmFwcGluZyAmJiAodHMgfHwgYnMgfHwgbHMgfHwgcnMgfHwgZmlyc3QpKSB7XFxuICAgICAgICAgIGluc3Qub3B0aW9ucy5zbmFwLnNuYXAgJiYgaW5zdC5vcHRpb25zLnNuYXAuc25hcC5jYWxsKGluc3QuZWxlbWVudCwgZXZlbnQsICQuZXh0ZW5kKGluc3QuX3VpSGFzaCgpLCB7XFxuICAgICAgICAgICAgc25hcEl0ZW06IGluc3Quc25hcEVsZW1lbnRzW2ldLml0ZW1cXG4gICAgICAgICAgfSkpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaW5zdC5zbmFwRWxlbWVudHNbaV0uc25hcHBpbmcgPSB0cyB8fCBicyB8fCBscyB8fCBycyB8fCBmaXJzdDtcXG4gICAgICB9XFxuICAgIH1cXG4gIH0pO1xcbiAgJC51aS5wbHVnaW4uYWRkKFxcXCJkcmFnZ2FibGVcXFwiLCBcXFwic3RhY2tcXFwiLCB7XFxuICAgIHN0YXJ0OiBmdW5jdGlvbiBzdGFydChldmVudCwgdWksIGluc3RhbmNlKSB7XFxuICAgICAgdmFyIG1pbixcXG4gICAgICAgICAgbyA9IGluc3RhbmNlLm9wdGlvbnMsXFxuICAgICAgICAgIGdyb3VwID0gJC5tYWtlQXJyYXkoJChvLnN0YWNrKSkuc29ydChmdW5jdGlvbiAoYSwgYikge1xcbiAgICAgICAgcmV0dXJuIChwYXJzZUludCgkKGEpLmNzcyhcXFwiekluZGV4XFxcIiksIDEwKSB8fCAwKSAtIChwYXJzZUludCgkKGIpLmNzcyhcXFwiekluZGV4XFxcIiksIDEwKSB8fCAwKTtcXG4gICAgICB9KTtcXG5cXG4gICAgICBpZiAoIWdyb3VwLmxlbmd0aCkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBtaW4gPSBwYXJzZUludCgkKGdyb3VwWzBdKS5jc3MoXFxcInpJbmRleFxcXCIpLCAxMCkgfHwgMDtcXG4gICAgICAkKGdyb3VwKS5lYWNoKGZ1bmN0aW9uIChpKSB7XFxuICAgICAgICAkKHRoaXMpLmNzcyhcXFwiekluZGV4XFxcIiwgbWluICsgaSk7XFxuICAgICAgfSk7XFxuICAgICAgdGhpcy5jc3MoXFxcInpJbmRleFxcXCIsIG1pbiArIGdyb3VwLmxlbmd0aCk7XFxuICAgIH1cXG4gIH0pO1xcbiAgJC51aS5wbHVnaW4uYWRkKFxcXCJkcmFnZ2FibGVcXFwiLCBcXFwiekluZGV4XFxcIiwge1xcbiAgICBzdGFydDogZnVuY3Rpb24gc3RhcnQoZXZlbnQsIHVpLCBpbnN0YW5jZSkge1xcbiAgICAgIHZhciB0ID0gJCh1aS5oZWxwZXIpLFxcbiAgICAgICAgICBvID0gaW5zdGFuY2Uub3B0aW9ucztcXG5cXG4gICAgICBpZiAodC5jc3MoXFxcInpJbmRleFxcXCIpKSB7XFxuICAgICAgICBvLl96SW5kZXggPSB0LmNzcyhcXFwiekluZGV4XFxcIik7XFxuICAgICAgfVxcblxcbiAgICAgIHQuY3NzKFxcXCJ6SW5kZXhcXFwiLCBvLnpJbmRleCk7XFxuICAgIH0sXFxuICAgIHN0b3A6IGZ1bmN0aW9uIHN0b3AoZXZlbnQsIHVpLCBpbnN0YW5jZSkge1xcbiAgICAgIHZhciBvID0gaW5zdGFuY2Uub3B0aW9ucztcXG5cXG4gICAgICBpZiAoby5fekluZGV4KSB7XFxuICAgICAgICAkKHVpLmhlbHBlcikuY3NzKFxcXCJ6SW5kZXhcXFwiLCBvLl96SW5kZXgpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfSk7XFxuICB2YXIgZHJhZ2dhYmxlID0gJC51aS5kcmFnZ2FibGU7XFxuICAvKiFcXG4gICAqIGpRdWVyeSBVSSBSZXNpemFibGUgMS4xMS40XFxuICAgKiBodHRwOi8vanF1ZXJ5dWkuY29tXFxuICAgKlxcbiAgICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcXG4gICAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cXG4gICAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcXG4gICAqXFxuICAgKiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9yZXNpemFibGUvXFxuICAgKi9cXG5cXG4gICQud2lkZ2V0KFxcXCJ1aS5yZXNpemFibGVcXFwiLCAkLnVpLm1vdXNlLCB7XFxuICAgIHZlcnNpb246IFxcXCIxLjExLjRcXFwiLFxcbiAgICB3aWRnZXRFdmVudFByZWZpeDogXFxcInJlc2l6ZVxcXCIsXFxuICAgIG9wdGlvbnM6IHtcXG4gICAgICBhbHNvUmVzaXplOiBmYWxzZSxcXG4gICAgICBhbmltYXRlOiBmYWxzZSxcXG4gICAgICBhbmltYXRlRHVyYXRpb246IFxcXCJzbG93XFxcIixcXG4gICAgICBhbmltYXRlRWFzaW5nOiBcXFwic3dpbmdcXFwiLFxcbiAgICAgIGFzcGVjdFJhdGlvOiBmYWxzZSxcXG4gICAgICBhdXRvSGlkZTogZmFsc2UsXFxuICAgICAgY29udGFpbm1lbnQ6IGZhbHNlLFxcbiAgICAgIGdob3N0OiBmYWxzZSxcXG4gICAgICBncmlkOiBmYWxzZSxcXG4gICAgICBoYW5kbGVzOiBcXFwiZSxzLHNlXFxcIixcXG4gICAgICBoZWxwZXI6IGZhbHNlLFxcbiAgICAgIG1heEhlaWdodDogbnVsbCxcXG4gICAgICBtYXhXaWR0aDogbnVsbCxcXG4gICAgICBtaW5IZWlnaHQ6IDEwLFxcbiAgICAgIG1pbldpZHRoOiAxMCxcXG4gICAgICAvLyBTZWUgIzc5NjBcXG4gICAgICB6SW5kZXg6IDkwLFxcbiAgICAgIC8vIGNhbGxiYWNrc1xcbiAgICAgIHJlc2l6ZTogbnVsbCxcXG4gICAgICBzdGFydDogbnVsbCxcXG4gICAgICBzdG9wOiBudWxsXFxuICAgIH0sXFxuICAgIF9udW06IGZ1bmN0aW9uIF9udW0odmFsdWUpIHtcXG4gICAgICByZXR1cm4gcGFyc2VJbnQodmFsdWUsIDEwKSB8fCAwO1xcbiAgICB9LFxcbiAgICBfaXNOdW1iZXI6IGZ1bmN0aW9uIF9pc051bWJlcih2YWx1ZSkge1xcbiAgICAgIHJldHVybiAhaXNOYU4ocGFyc2VJbnQodmFsdWUsIDEwKSk7XFxuICAgIH0sXFxuICAgIF9oYXNTY3JvbGw6IGZ1bmN0aW9uIF9oYXNTY3JvbGwoZWwsIGEpIHtcXG4gICAgICBpZiAoJChlbCkuY3NzKFxcXCJvdmVyZmxvd1xcXCIpID09PSBcXFwiaGlkZGVuXFxcIikge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgc2Nyb2xsID0gYSAmJiBhID09PSBcXFwibGVmdFxcXCIgPyBcXFwic2Nyb2xsTGVmdFxcXCIgOiBcXFwic2Nyb2xsVG9wXFxcIixcXG4gICAgICAgICAgaGFzID0gZmFsc2U7XFxuXFxuICAgICAgaWYgKGVsW3Njcm9sbF0gPiAwKSB7XFxuICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICB9IC8vIFRPRE86IGRldGVybWluZSB3aGljaCBjYXNlcyBhY3R1YWxseSBjYXVzZSB0aGlzIHRvIGhhcHBlblxcbiAgICAgIC8vIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSB0aGUgc2Nyb2xsIHNldCwgc2VlIGlmIGl0J3MgcG9zc2libGUgdG9cXG4gICAgICAvLyBzZXQgdGhlIHNjcm9sbFxcblxcblxcbiAgICAgIGVsW3Njcm9sbF0gPSAxO1xcbiAgICAgIGhhcyA9IGVsW3Njcm9sbF0gPiAwO1xcbiAgICAgIGVsW3Njcm9sbF0gPSAwO1xcbiAgICAgIHJldHVybiBoYXM7XFxuICAgIH0sXFxuICAgIF9jcmVhdGU6IGZ1bmN0aW9uIF9jcmVhdGUoKSB7XFxuICAgICAgdmFyIG4sXFxuICAgICAgICAgIGksXFxuICAgICAgICAgIGhhbmRsZSxcXG4gICAgICAgICAgYXhpcyxcXG4gICAgICAgICAgaG5hbWUsXFxuICAgICAgICAgIHRoYXQgPSB0aGlzLFxcbiAgICAgICAgICBvID0gdGhpcy5vcHRpb25zO1xcbiAgICAgIHRoaXMuZWxlbWVudC5hZGRDbGFzcyhcXFwidWktcmVzaXphYmxlXFxcIik7XFxuICAgICAgJC5leHRlbmQodGhpcywge1xcbiAgICAgICAgX2FzcGVjdFJhdGlvOiAhIW8uYXNwZWN0UmF0aW8sXFxuICAgICAgICBhc3BlY3RSYXRpbzogby5hc3BlY3RSYXRpbyxcXG4gICAgICAgIG9yaWdpbmFsRWxlbWVudDogdGhpcy5lbGVtZW50LFxcbiAgICAgICAgX3Byb3BvcnRpb25hbGx5UmVzaXplRWxlbWVudHM6IFtdLFxcbiAgICAgICAgX2hlbHBlcjogby5oZWxwZXIgfHwgby5naG9zdCB8fCBvLmFuaW1hdGUgPyBvLmhlbHBlciB8fCBcXFwidWktcmVzaXphYmxlLWhlbHBlclxcXCIgOiBudWxsXFxuICAgICAgfSk7IC8vIFdyYXAgdGhlIGVsZW1lbnQgaWYgaXQgY2Fubm90IGhvbGQgY2hpbGQgbm9kZXNcXG5cXG4gICAgICBpZiAodGhpcy5lbGVtZW50WzBdLm5vZGVOYW1lLm1hdGNoKC9eKGNhbnZhc3x0ZXh0YXJlYXxpbnB1dHxzZWxlY3R8YnV0dG9ufGltZykkL2kpKSB7XFxuICAgICAgICB0aGlzLmVsZW1lbnQud3JhcCgkKFxcXCI8ZGl2IGNsYXNzPSd1aS13cmFwcGVyJyBzdHlsZT0nb3ZlcmZsb3c6IGhpZGRlbjsnPjwvZGl2PlxcXCIpLmNzcyh7XFxuICAgICAgICAgIHBvc2l0aW9uOiB0aGlzLmVsZW1lbnQuY3NzKFxcXCJwb3NpdGlvblxcXCIpLFxcbiAgICAgICAgICB3aWR0aDogdGhpcy5lbGVtZW50Lm91dGVyV2lkdGgoKSxcXG4gICAgICAgICAgaGVpZ2h0OiB0aGlzLmVsZW1lbnQub3V0ZXJIZWlnaHQoKSxcXG4gICAgICAgICAgdG9wOiB0aGlzLmVsZW1lbnQuY3NzKFxcXCJ0b3BcXFwiKSxcXG4gICAgICAgICAgbGVmdDogdGhpcy5lbGVtZW50LmNzcyhcXFwibGVmdFxcXCIpXFxuICAgICAgICB9KSk7XFxuICAgICAgICB0aGlzLmVsZW1lbnQgPSB0aGlzLmVsZW1lbnQucGFyZW50KCkuZGF0YShcXFwidWktcmVzaXphYmxlXFxcIiwgdGhpcy5lbGVtZW50LnJlc2l6YWJsZShcXFwiaW5zdGFuY2VcXFwiKSk7XFxuICAgICAgICB0aGlzLmVsZW1lbnRJc1dyYXBwZXIgPSB0cnVlO1xcbiAgICAgICAgdGhpcy5lbGVtZW50LmNzcyh7XFxuICAgICAgICAgIG1hcmdpbkxlZnQ6IHRoaXMub3JpZ2luYWxFbGVtZW50LmNzcyhcXFwibWFyZ2luTGVmdFxcXCIpLFxcbiAgICAgICAgICBtYXJnaW5Ub3A6IHRoaXMub3JpZ2luYWxFbGVtZW50LmNzcyhcXFwibWFyZ2luVG9wXFxcIiksXFxuICAgICAgICAgIG1hcmdpblJpZ2h0OiB0aGlzLm9yaWdpbmFsRWxlbWVudC5jc3MoXFxcIm1hcmdpblJpZ2h0XFxcIiksXFxuICAgICAgICAgIG1hcmdpbkJvdHRvbTogdGhpcy5vcmlnaW5hbEVsZW1lbnQuY3NzKFxcXCJtYXJnaW5Cb3R0b21cXFwiKVxcbiAgICAgICAgfSk7XFxuICAgICAgICB0aGlzLm9yaWdpbmFsRWxlbWVudC5jc3Moe1xcbiAgICAgICAgICBtYXJnaW5MZWZ0OiAwLFxcbiAgICAgICAgICBtYXJnaW5Ub3A6IDAsXFxuICAgICAgICAgIG1hcmdpblJpZ2h0OiAwLFxcbiAgICAgICAgICBtYXJnaW5Cb3R0b206IDBcXG4gICAgICAgIH0pOyAvLyBzdXBwb3J0OiBTYWZhcmlcXG4gICAgICAgIC8vIFByZXZlbnQgU2FmYXJpIHRleHRhcmVhIHJlc2l6ZVxcblxcbiAgICAgICAgdGhpcy5vcmlnaW5hbFJlc2l6ZVN0eWxlID0gdGhpcy5vcmlnaW5hbEVsZW1lbnQuY3NzKFxcXCJyZXNpemVcXFwiKTtcXG4gICAgICAgIHRoaXMub3JpZ2luYWxFbGVtZW50LmNzcyhcXFwicmVzaXplXFxcIiwgXFxcIm5vbmVcXFwiKTtcXG5cXG4gICAgICAgIHRoaXMuX3Byb3BvcnRpb25hbGx5UmVzaXplRWxlbWVudHMucHVzaCh0aGlzLm9yaWdpbmFsRWxlbWVudC5jc3Moe1xcbiAgICAgICAgICBwb3NpdGlvbjogXFxcInN0YXRpY1xcXCIsXFxuICAgICAgICAgIHpvb206IDEsXFxuICAgICAgICAgIGRpc3BsYXk6IFxcXCJibG9ja1xcXCJcXG4gICAgICAgIH0pKTsgLy8gc3VwcG9ydDogSUU5XFxuICAgICAgICAvLyBhdm9pZCBJRSBqdW1wIChoYXJkIHNldCB0aGUgbWFyZ2luKVxcblxcblxcbiAgICAgICAgdGhpcy5vcmlnaW5hbEVsZW1lbnQuY3NzKHtcXG4gICAgICAgICAgbWFyZ2luOiB0aGlzLm9yaWdpbmFsRWxlbWVudC5jc3MoXFxcIm1hcmdpblxcXCIpXFxuICAgICAgICB9KTtcXG5cXG4gICAgICAgIHRoaXMuX3Byb3BvcnRpb25hbGx5UmVzaXplKCk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuaGFuZGxlcyA9IG8uaGFuZGxlcyB8fCAoISQoXFxcIi51aS1yZXNpemFibGUtaGFuZGxlXFxcIiwgdGhpcy5lbGVtZW50KS5sZW5ndGggPyBcXFwiZSxzLHNlXFxcIiA6IHtcXG4gICAgICAgIG46IFxcXCIudWktcmVzaXphYmxlLW5cXFwiLFxcbiAgICAgICAgZTogXFxcIi51aS1yZXNpemFibGUtZVxcXCIsXFxuICAgICAgICBzOiBcXFwiLnVpLXJlc2l6YWJsZS1zXFxcIixcXG4gICAgICAgIHc6IFxcXCIudWktcmVzaXphYmxlLXdcXFwiLFxcbiAgICAgICAgc2U6IFxcXCIudWktcmVzaXphYmxlLXNlXFxcIixcXG4gICAgICAgIHN3OiBcXFwiLnVpLXJlc2l6YWJsZS1zd1xcXCIsXFxuICAgICAgICBuZTogXFxcIi51aS1yZXNpemFibGUtbmVcXFwiLFxcbiAgICAgICAgbnc6IFxcXCIudWktcmVzaXphYmxlLW53XFxcIlxcbiAgICAgIH0pO1xcbiAgICAgIHRoaXMuX2hhbmRsZXMgPSAkKCk7XFxuXFxuICAgICAgaWYgKHRoaXMuaGFuZGxlcy5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nKSB7XFxuICAgICAgICBpZiAodGhpcy5oYW5kbGVzID09PSBcXFwiYWxsXFxcIikge1xcbiAgICAgICAgICB0aGlzLmhhbmRsZXMgPSBcXFwibixlLHMsdyxzZSxzdyxuZSxud1xcXCI7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBuID0gdGhpcy5oYW5kbGVzLnNwbGl0KFxcXCIsXFxcIik7XFxuICAgICAgICB0aGlzLmhhbmRsZXMgPSB7fTtcXG5cXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgIGhhbmRsZSA9ICQudHJpbShuW2ldKTtcXG4gICAgICAgICAgaG5hbWUgPSBcXFwidWktcmVzaXphYmxlLVxcXCIgKyBoYW5kbGU7XFxuICAgICAgICAgIGF4aXMgPSAkKFxcXCI8ZGl2IGNsYXNzPSd1aS1yZXNpemFibGUtaGFuZGxlIFxcXCIgKyBobmFtZSArIFxcXCInPjwvZGl2PlxcXCIpO1xcbiAgICAgICAgICBheGlzLmNzcyh7XFxuICAgICAgICAgICAgekluZGV4OiBvLnpJbmRleFxcbiAgICAgICAgICB9KTsgLy8gVE9ETyA6IFdoYXQncyBnb2luZyBvbiBoZXJlP1xcblxcbiAgICAgICAgICBpZiAoXFxcInNlXFxcIiA9PT0gaGFuZGxlKSB7XFxuICAgICAgICAgICAgYXhpcy5hZGRDbGFzcyhcXFwidWktaWNvbiB1aS1pY29uLWdyaXBzbWFsbC1kaWFnb25hbC1zZVxcXCIpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHRoaXMuaGFuZGxlc1toYW5kbGVdID0gXFxcIi51aS1yZXNpemFibGUtXFxcIiArIGhhbmRsZTtcXG4gICAgICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZChheGlzKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fcmVuZGVyQXhpcyA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcXG4gICAgICAgIHZhciBpLCBheGlzLCBwYWRQb3MsIHBhZFdyYXBwZXI7XFxuICAgICAgICB0YXJnZXQgPSB0YXJnZXQgfHwgdGhpcy5lbGVtZW50O1xcblxcbiAgICAgICAgZm9yIChpIGluIHRoaXMuaGFuZGxlcykge1xcbiAgICAgICAgICBpZiAodGhpcy5oYW5kbGVzW2ldLmNvbnN0cnVjdG9yID09PSBTdHJpbmcpIHtcXG4gICAgICAgICAgICB0aGlzLmhhbmRsZXNbaV0gPSB0aGlzLmVsZW1lbnQuY2hpbGRyZW4odGhpcy5oYW5kbGVzW2ldKS5maXJzdCgpLnNob3coKTtcXG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmhhbmRsZXNbaV0uanF1ZXJ5IHx8IHRoaXMuaGFuZGxlc1tpXS5ub2RlVHlwZSkge1xcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlc1tpXSA9ICQodGhpcy5oYW5kbGVzW2ldKTtcXG5cXG4gICAgICAgICAgICB0aGlzLl9vbih0aGlzLmhhbmRsZXNbaV0sIHtcXG4gICAgICAgICAgICAgIFxcXCJtb3VzZWRvd25cXFwiOiB0aGF0Ll9tb3VzZURvd25cXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAodGhpcy5lbGVtZW50SXNXcmFwcGVyICYmIHRoaXMub3JpZ2luYWxFbGVtZW50WzBdLm5vZGVOYW1lLm1hdGNoKC9eKHRleHRhcmVhfGlucHV0fHNlbGVjdHxidXR0b24pJC9pKSkge1xcbiAgICAgICAgICAgIGF4aXMgPSAkKHRoaXMuaGFuZGxlc1tpXSwgdGhpcy5lbGVtZW50KTtcXG4gICAgICAgICAgICBwYWRXcmFwcGVyID0gL3N3fG5lfG53fHNlfG58cy8udGVzdChpKSA/IGF4aXMub3V0ZXJIZWlnaHQoKSA6IGF4aXMub3V0ZXJXaWR0aCgpO1xcbiAgICAgICAgICAgIHBhZFBvcyA9IFtcXFwicGFkZGluZ1xcXCIsIC9uZXxud3xuLy50ZXN0KGkpID8gXFxcIlRvcFxcXCIgOiAvc2V8c3d8cy8udGVzdChpKSA/IFxcXCJCb3R0b21cXFwiIDogL15lJC8udGVzdChpKSA/IFxcXCJSaWdodFxcXCIgOiBcXFwiTGVmdFxcXCJdLmpvaW4oXFxcIlxcXCIpO1xcbiAgICAgICAgICAgIHRhcmdldC5jc3MocGFkUG9zLCBwYWRXcmFwcGVyKTtcXG5cXG4gICAgICAgICAgICB0aGlzLl9wcm9wb3J0aW9uYWxseVJlc2l6ZSgpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHRoaXMuX2hhbmRsZXMgPSB0aGlzLl9oYW5kbGVzLmFkZCh0aGlzLmhhbmRsZXNbaV0pO1xcbiAgICAgICAgfVxcbiAgICAgIH07IC8vIFRPRE86IG1ha2UgcmVuZGVyQXhpcyBhIHByb3RvdHlwZSBmdW5jdGlvblxcblxcblxcbiAgICAgIHRoaXMuX3JlbmRlckF4aXModGhpcy5lbGVtZW50KTtcXG5cXG4gICAgICB0aGlzLl9oYW5kbGVzID0gdGhpcy5faGFuZGxlcy5hZGQodGhpcy5lbGVtZW50LmZpbmQoXFxcIi51aS1yZXNpemFibGUtaGFuZGxlXFxcIikpO1xcblxcbiAgICAgIHRoaXMuX2hhbmRsZXMuZGlzYWJsZVNlbGVjdGlvbigpO1xcblxcbiAgICAgIHRoaXMuX2hhbmRsZXMubW91c2VvdmVyKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGlmICghdGhhdC5yZXNpemluZykge1xcbiAgICAgICAgICBpZiAodGhpcy5jbGFzc05hbWUpIHtcXG4gICAgICAgICAgICBheGlzID0gdGhpcy5jbGFzc05hbWUubWF0Y2goL3VpLXJlc2l6YWJsZS0oc2V8c3d8bmV8bnd8bnxlfHN8dykvaSk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgdGhhdC5heGlzID0gYXhpcyAmJiBheGlzWzFdID8gYXhpc1sxXSA6IFxcXCJzZVxcXCI7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuXFxuICAgICAgaWYgKG8uYXV0b0hpZGUpIHtcXG4gICAgICAgIHRoaXMuX2hhbmRsZXMuaGlkZSgpO1xcblxcbiAgICAgICAgJCh0aGlzLmVsZW1lbnQpLmFkZENsYXNzKFxcXCJ1aS1yZXNpemFibGUtYXV0b2hpZGVcXFwiKS5tb3VzZWVudGVyKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgaWYgKG8uZGlzYWJsZWQpIHtcXG4gICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgJCh0aGlzKS5yZW1vdmVDbGFzcyhcXFwidWktcmVzaXphYmxlLWF1dG9oaWRlXFxcIik7XFxuXFxuICAgICAgICAgIHRoYXQuX2hhbmRsZXMuc2hvdygpO1xcbiAgICAgICAgfSkubW91c2VsZWF2ZShmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIGlmIChvLmRpc2FibGVkKSB7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmICghdGhhdC5yZXNpemluZykge1xcbiAgICAgICAgICAgICQodGhpcykuYWRkQ2xhc3MoXFxcInVpLXJlc2l6YWJsZS1hdXRvaGlkZVxcXCIpO1xcblxcbiAgICAgICAgICAgIHRoYXQuX2hhbmRsZXMuaGlkZSgpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fbW91c2VJbml0KCk7XFxuICAgIH0sXFxuICAgIF9kZXN0cm95OiBmdW5jdGlvbiBfZGVzdHJveSgpIHtcXG4gICAgICB0aGlzLl9tb3VzZURlc3Ryb3koKTtcXG5cXG4gICAgICB2YXIgd3JhcHBlcixcXG4gICAgICAgICAgX2Rlc3Ryb3kgPSBmdW5jdGlvbiBfZGVzdHJveShleHApIHtcXG4gICAgICAgICQoZXhwKS5yZW1vdmVDbGFzcyhcXFwidWktcmVzaXphYmxlIHVpLXJlc2l6YWJsZS1kaXNhYmxlZCB1aS1yZXNpemFibGUtcmVzaXppbmdcXFwiKS5yZW1vdmVEYXRhKFxcXCJyZXNpemFibGVcXFwiKS5yZW1vdmVEYXRhKFxcXCJ1aS1yZXNpemFibGVcXFwiKS51bmJpbmQoXFxcIi5yZXNpemFibGVcXFwiKS5maW5kKFxcXCIudWktcmVzaXphYmxlLWhhbmRsZVxcXCIpLnJlbW92ZSgpO1xcbiAgICAgIH07IC8vIFRPRE86IFVud3JhcCBhdCBzYW1lIERPTSBwb3NpdGlvblxcblxcblxcbiAgICAgIGlmICh0aGlzLmVsZW1lbnRJc1dyYXBwZXIpIHtcXG4gICAgICAgIF9kZXN0cm95KHRoaXMuZWxlbWVudCk7XFxuXFxuICAgICAgICB3cmFwcGVyID0gdGhpcy5lbGVtZW50O1xcbiAgICAgICAgdGhpcy5vcmlnaW5hbEVsZW1lbnQuY3NzKHtcXG4gICAgICAgICAgcG9zaXRpb246IHdyYXBwZXIuY3NzKFxcXCJwb3NpdGlvblxcXCIpLFxcbiAgICAgICAgICB3aWR0aDogd3JhcHBlci5vdXRlcldpZHRoKCksXFxuICAgICAgICAgIGhlaWdodDogd3JhcHBlci5vdXRlckhlaWdodCgpLFxcbiAgICAgICAgICB0b3A6IHdyYXBwZXIuY3NzKFxcXCJ0b3BcXFwiKSxcXG4gICAgICAgICAgbGVmdDogd3JhcHBlci5jc3MoXFxcImxlZnRcXFwiKVxcbiAgICAgICAgfSkuaW5zZXJ0QWZ0ZXIod3JhcHBlcik7XFxuICAgICAgICB3cmFwcGVyLnJlbW92ZSgpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLm9yaWdpbmFsRWxlbWVudC5jc3MoXFxcInJlc2l6ZVxcXCIsIHRoaXMub3JpZ2luYWxSZXNpemVTdHlsZSk7XFxuXFxuICAgICAgX2Rlc3Ryb3kodGhpcy5vcmlnaW5hbEVsZW1lbnQpO1xcblxcbiAgICAgIHJldHVybiB0aGlzO1xcbiAgICB9LFxcbiAgICBfbW91c2VDYXB0dXJlOiBmdW5jdGlvbiBfbW91c2VDYXB0dXJlKGV2ZW50KSB7XFxuICAgICAgdmFyIGksXFxuICAgICAgICAgIGhhbmRsZSxcXG4gICAgICAgICAgY2FwdHVyZSA9IGZhbHNlO1xcblxcbiAgICAgIGZvciAoaSBpbiB0aGlzLmhhbmRsZXMpIHtcXG4gICAgICAgIGhhbmRsZSA9ICQodGhpcy5oYW5kbGVzW2ldKVswXTtcXG5cXG4gICAgICAgIGlmIChoYW5kbGUgPT09IGV2ZW50LnRhcmdldCB8fCAkLmNvbnRhaW5zKGhhbmRsZSwgZXZlbnQudGFyZ2V0KSkge1xcbiAgICAgICAgICBjYXB0dXJlID0gdHJ1ZTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuICF0aGlzLm9wdGlvbnMuZGlzYWJsZWQgJiYgY2FwdHVyZTtcXG4gICAgfSxcXG4gICAgX21vdXNlU3RhcnQ6IGZ1bmN0aW9uIF9tb3VzZVN0YXJ0KGV2ZW50KSB7XFxuICAgICAgdmFyIGN1cmxlZnQsXFxuICAgICAgICAgIGN1cnRvcCxcXG4gICAgICAgICAgY3Vyc29yLFxcbiAgICAgICAgICBvID0gdGhpcy5vcHRpb25zLFxcbiAgICAgICAgICBlbCA9IHRoaXMuZWxlbWVudDtcXG4gICAgICB0aGlzLnJlc2l6aW5nID0gdHJ1ZTtcXG5cXG4gICAgICB0aGlzLl9yZW5kZXJQcm94eSgpO1xcblxcbiAgICAgIGN1cmxlZnQgPSB0aGlzLl9udW0odGhpcy5oZWxwZXIuY3NzKFxcXCJsZWZ0XFxcIikpO1xcbiAgICAgIGN1cnRvcCA9IHRoaXMuX251bSh0aGlzLmhlbHBlci5jc3MoXFxcInRvcFxcXCIpKTtcXG5cXG4gICAgICBpZiAoby5jb250YWlubWVudCkge1xcbiAgICAgICAgY3VybGVmdCArPSAkKG8uY29udGFpbm1lbnQpLnNjcm9sbExlZnQoKSB8fCAwO1xcbiAgICAgICAgY3VydG9wICs9ICQoby5jb250YWlubWVudCkuc2Nyb2xsVG9wKCkgfHwgMDtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5vZmZzZXQgPSB0aGlzLmhlbHBlci5vZmZzZXQoKTtcXG4gICAgICB0aGlzLnBvc2l0aW9uID0ge1xcbiAgICAgICAgbGVmdDogY3VybGVmdCxcXG4gICAgICAgIHRvcDogY3VydG9wXFxuICAgICAgfTtcXG4gICAgICB0aGlzLnNpemUgPSB0aGlzLl9oZWxwZXIgPyB7XFxuICAgICAgICB3aWR0aDogdGhpcy5oZWxwZXIud2lkdGgoKSxcXG4gICAgICAgIGhlaWdodDogdGhpcy5oZWxwZXIuaGVpZ2h0KClcXG4gICAgICB9IDoge1xcbiAgICAgICAgd2lkdGg6IGVsLndpZHRoKCksXFxuICAgICAgICBoZWlnaHQ6IGVsLmhlaWdodCgpXFxuICAgICAgfTtcXG4gICAgICB0aGlzLm9yaWdpbmFsU2l6ZSA9IHRoaXMuX2hlbHBlciA/IHtcXG4gICAgICAgIHdpZHRoOiBlbC5vdXRlcldpZHRoKCksXFxuICAgICAgICBoZWlnaHQ6IGVsLm91dGVySGVpZ2h0KClcXG4gICAgICB9IDoge1xcbiAgICAgICAgd2lkdGg6IGVsLndpZHRoKCksXFxuICAgICAgICBoZWlnaHQ6IGVsLmhlaWdodCgpXFxuICAgICAgfTtcXG4gICAgICB0aGlzLnNpemVEaWZmID0ge1xcbiAgICAgICAgd2lkdGg6IGVsLm91dGVyV2lkdGgoKSAtIGVsLndpZHRoKCksXFxuICAgICAgICBoZWlnaHQ6IGVsLm91dGVySGVpZ2h0KCkgLSBlbC5oZWlnaHQoKVxcbiAgICAgIH07XFxuICAgICAgdGhpcy5vcmlnaW5hbFBvc2l0aW9uID0ge1xcbiAgICAgICAgbGVmdDogY3VybGVmdCxcXG4gICAgICAgIHRvcDogY3VydG9wXFxuICAgICAgfTtcXG4gICAgICB0aGlzLm9yaWdpbmFsTW91c2VQb3NpdGlvbiA9IHtcXG4gICAgICAgIGxlZnQ6IGV2ZW50LnBhZ2VYLFxcbiAgICAgICAgdG9wOiBldmVudC5wYWdlWVxcbiAgICAgIH07XFxuICAgICAgdGhpcy5hc3BlY3RSYXRpbyA9IHR5cGVvZiBvLmFzcGVjdFJhdGlvID09PSBcXFwibnVtYmVyXFxcIiA/IG8uYXNwZWN0UmF0aW8gOiB0aGlzLm9yaWdpbmFsU2l6ZS53aWR0aCAvIHRoaXMub3JpZ2luYWxTaXplLmhlaWdodCB8fCAxO1xcbiAgICAgIGN1cnNvciA9ICQoXFxcIi51aS1yZXNpemFibGUtXFxcIiArIHRoaXMuYXhpcykuY3NzKFxcXCJjdXJzb3JcXFwiKTtcXG4gICAgICAkKFxcXCJib2R5XFxcIikuY3NzKFxcXCJjdXJzb3JcXFwiLCBjdXJzb3IgPT09IFxcXCJhdXRvXFxcIiA/IHRoaXMuYXhpcyArIFxcXCItcmVzaXplXFxcIiA6IGN1cnNvcik7XFxuICAgICAgZWwuYWRkQ2xhc3MoXFxcInVpLXJlc2l6YWJsZS1yZXNpemluZ1xcXCIpO1xcblxcbiAgICAgIHRoaXMuX3Byb3BhZ2F0ZShcXFwic3RhcnRcXFwiLCBldmVudCk7XFxuXFxuICAgICAgcmV0dXJuIHRydWU7XFxuICAgIH0sXFxuICAgIF9tb3VzZURyYWc6IGZ1bmN0aW9uIF9tb3VzZURyYWcoZXZlbnQpIHtcXG4gICAgICB2YXIgZGF0YSxcXG4gICAgICAgICAgcHJvcHMsXFxuICAgICAgICAgIHNtcCA9IHRoaXMub3JpZ2luYWxNb3VzZVBvc2l0aW9uLFxcbiAgICAgICAgICBhID0gdGhpcy5heGlzLFxcbiAgICAgICAgICBkeCA9IGV2ZW50LnBhZ2VYIC0gc21wLmxlZnQgfHwgMCxcXG4gICAgICAgICAgZHkgPSBldmVudC5wYWdlWSAtIHNtcC50b3AgfHwgMCxcXG4gICAgICAgICAgdHJpZ2dlciA9IHRoaXMuX2NoYW5nZVthXTtcXG5cXG4gICAgICB0aGlzLl91cGRhdGVQcmV2UHJvcGVydGllcygpO1xcblxcbiAgICAgIGlmICghdHJpZ2dlcikge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICBkYXRhID0gdHJpZ2dlci5hcHBseSh0aGlzLCBbZXZlbnQsIGR4LCBkeV0pO1xcblxcbiAgICAgIHRoaXMuX3VwZGF0ZVZpcnR1YWxCb3VuZGFyaWVzKGV2ZW50LnNoaWZ0S2V5KTtcXG5cXG4gICAgICBpZiAodGhpcy5fYXNwZWN0UmF0aW8gfHwgZXZlbnQuc2hpZnRLZXkpIHtcXG4gICAgICAgIGRhdGEgPSB0aGlzLl91cGRhdGVSYXRpbyhkYXRhLCBldmVudCk7XFxuICAgICAgfVxcblxcbiAgICAgIGRhdGEgPSB0aGlzLl9yZXNwZWN0U2l6ZShkYXRhLCBldmVudCk7XFxuXFxuICAgICAgdGhpcy5fdXBkYXRlQ2FjaGUoZGF0YSk7XFxuXFxuICAgICAgdGhpcy5fcHJvcGFnYXRlKFxcXCJyZXNpemVcXFwiLCBldmVudCk7XFxuXFxuICAgICAgcHJvcHMgPSB0aGlzLl9hcHBseUNoYW5nZXMoKTtcXG5cXG4gICAgICBpZiAoIXRoaXMuX2hlbHBlciAmJiB0aGlzLl9wcm9wb3J0aW9uYWxseVJlc2l6ZUVsZW1lbnRzLmxlbmd0aCkge1xcbiAgICAgICAgdGhpcy5fcHJvcG9ydGlvbmFsbHlSZXNpemUoKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCEkLmlzRW1wdHlPYmplY3QocHJvcHMpKSB7XFxuICAgICAgICB0aGlzLl91cGRhdGVQcmV2UHJvcGVydGllcygpO1xcblxcbiAgICAgICAgdGhpcy5fdHJpZ2dlcihcXFwicmVzaXplXFxcIiwgZXZlbnQsIHRoaXMudWkoKSk7XFxuXFxuICAgICAgICB0aGlzLl9hcHBseUNoYW5nZXMoKTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9LFxcbiAgICBfbW91c2VTdG9wOiBmdW5jdGlvbiBfbW91c2VTdG9wKGV2ZW50KSB7XFxuICAgICAgdGhpcy5yZXNpemluZyA9IGZhbHNlO1xcbiAgICAgIHZhciBwcixcXG4gICAgICAgICAgaXN0YSxcXG4gICAgICAgICAgc29mZnNldGgsXFxuICAgICAgICAgIHNvZmZzZXR3LFxcbiAgICAgICAgICBzLFxcbiAgICAgICAgICBsZWZ0LFxcbiAgICAgICAgICB0b3AsXFxuICAgICAgICAgIG8gPSB0aGlzLm9wdGlvbnMsXFxuICAgICAgICAgIHRoYXQgPSB0aGlzO1xcblxcbiAgICAgIGlmICh0aGlzLl9oZWxwZXIpIHtcXG4gICAgICAgIHByID0gdGhpcy5fcHJvcG9ydGlvbmFsbHlSZXNpemVFbGVtZW50cztcXG4gICAgICAgIGlzdGEgPSBwci5sZW5ndGggJiYgL3RleHRhcmVhL2kudGVzdChwclswXS5ub2RlTmFtZSk7XFxuICAgICAgICBzb2Zmc2V0aCA9IGlzdGEgJiYgdGhpcy5faGFzU2Nyb2xsKHByWzBdLCBcXFwibGVmdFxcXCIpID8gMCA6IHRoYXQuc2l6ZURpZmYuaGVpZ2h0O1xcbiAgICAgICAgc29mZnNldHcgPSBpc3RhID8gMCA6IHRoYXQuc2l6ZURpZmYud2lkdGg7XFxuICAgICAgICBzID0ge1xcbiAgICAgICAgICB3aWR0aDogdGhhdC5oZWxwZXIud2lkdGgoKSAtIHNvZmZzZXR3LFxcbiAgICAgICAgICBoZWlnaHQ6IHRoYXQuaGVscGVyLmhlaWdodCgpIC0gc29mZnNldGhcXG4gICAgICAgIH07XFxuICAgICAgICBsZWZ0ID0gcGFyc2VJbnQodGhhdC5lbGVtZW50LmNzcyhcXFwibGVmdFxcXCIpLCAxMCkgKyAodGhhdC5wb3NpdGlvbi5sZWZ0IC0gdGhhdC5vcmlnaW5hbFBvc2l0aW9uLmxlZnQpIHx8IG51bGw7XFxuICAgICAgICB0b3AgPSBwYXJzZUludCh0aGF0LmVsZW1lbnQuY3NzKFxcXCJ0b3BcXFwiKSwgMTApICsgKHRoYXQucG9zaXRpb24udG9wIC0gdGhhdC5vcmlnaW5hbFBvc2l0aW9uLnRvcCkgfHwgbnVsbDtcXG5cXG4gICAgICAgIGlmICghby5hbmltYXRlKSB7XFxuICAgICAgICAgIHRoaXMuZWxlbWVudC5jc3MoJC5leHRlbmQocywge1xcbiAgICAgICAgICAgIHRvcDogdG9wLFxcbiAgICAgICAgICAgIGxlZnQ6IGxlZnRcXG4gICAgICAgICAgfSkpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdGhhdC5oZWxwZXIuaGVpZ2h0KHRoYXQuc2l6ZS5oZWlnaHQpO1xcbiAgICAgICAgdGhhdC5oZWxwZXIud2lkdGgodGhhdC5zaXplLndpZHRoKTtcXG5cXG4gICAgICAgIGlmICh0aGlzLl9oZWxwZXIgJiYgIW8uYW5pbWF0ZSkge1xcbiAgICAgICAgICB0aGlzLl9wcm9wb3J0aW9uYWxseVJlc2l6ZSgpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICAkKFxcXCJib2R5XFxcIikuY3NzKFxcXCJjdXJzb3JcXFwiLCBcXFwiYXV0b1xcXCIpO1xcbiAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVDbGFzcyhcXFwidWktcmVzaXphYmxlLXJlc2l6aW5nXFxcIik7XFxuXFxuICAgICAgdGhpcy5fcHJvcGFnYXRlKFxcXCJzdG9wXFxcIiwgZXZlbnQpO1xcblxcbiAgICAgIGlmICh0aGlzLl9oZWxwZXIpIHtcXG4gICAgICAgIHRoaXMuaGVscGVyLnJlbW92ZSgpO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH0sXFxuICAgIF91cGRhdGVQcmV2UHJvcGVydGllczogZnVuY3Rpb24gX3VwZGF0ZVByZXZQcm9wZXJ0aWVzKCkge1xcbiAgICAgIHRoaXMucHJldlBvc2l0aW9uID0ge1xcbiAgICAgICAgdG9wOiB0aGlzLnBvc2l0aW9uLnRvcCxcXG4gICAgICAgIGxlZnQ6IHRoaXMucG9zaXRpb24ubGVmdFxcbiAgICAgIH07XFxuICAgICAgdGhpcy5wcmV2U2l6ZSA9IHtcXG4gICAgICAgIHdpZHRoOiB0aGlzLnNpemUud2lkdGgsXFxuICAgICAgICBoZWlnaHQ6IHRoaXMuc2l6ZS5oZWlnaHRcXG4gICAgICB9O1xcbiAgICB9LFxcbiAgICBfYXBwbHlDaGFuZ2VzOiBmdW5jdGlvbiBfYXBwbHlDaGFuZ2VzKCkge1xcbiAgICAgIHZhciBwcm9wcyA9IHt9O1xcblxcbiAgICAgIGlmICh0aGlzLnBvc2l0aW9uLnRvcCAhPT0gdGhpcy5wcmV2UG9zaXRpb24udG9wKSB7XFxuICAgICAgICBwcm9wcy50b3AgPSB0aGlzLnBvc2l0aW9uLnRvcCArIFxcXCJweFxcXCI7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLnBvc2l0aW9uLmxlZnQgIT09IHRoaXMucHJldlBvc2l0aW9uLmxlZnQpIHtcXG4gICAgICAgIHByb3BzLmxlZnQgPSB0aGlzLnBvc2l0aW9uLmxlZnQgKyBcXFwicHhcXFwiO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5zaXplLndpZHRoICE9PSB0aGlzLnByZXZTaXplLndpZHRoKSB7XFxuICAgICAgICBwcm9wcy53aWR0aCA9IHRoaXMuc2l6ZS53aWR0aCArIFxcXCJweFxcXCI7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLnNpemUuaGVpZ2h0ICE9PSB0aGlzLnByZXZTaXplLmhlaWdodCkge1xcbiAgICAgICAgcHJvcHMuaGVpZ2h0ID0gdGhpcy5zaXplLmhlaWdodCArIFxcXCJweFxcXCI7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuaGVscGVyLmNzcyhwcm9wcyk7XFxuICAgICAgcmV0dXJuIHByb3BzO1xcbiAgICB9LFxcbiAgICBfdXBkYXRlVmlydHVhbEJvdW5kYXJpZXM6IGZ1bmN0aW9uIF91cGRhdGVWaXJ0dWFsQm91bmRhcmllcyhmb3JjZUFzcGVjdFJhdGlvKSB7XFxuICAgICAgdmFyIHBNaW5XaWR0aCxcXG4gICAgICAgICAgcE1heFdpZHRoLFxcbiAgICAgICAgICBwTWluSGVpZ2h0LFxcbiAgICAgICAgICBwTWF4SGVpZ2h0LFxcbiAgICAgICAgICBiLFxcbiAgICAgICAgICBvID0gdGhpcy5vcHRpb25zO1xcbiAgICAgIGIgPSB7XFxuICAgICAgICBtaW5XaWR0aDogdGhpcy5faXNOdW1iZXIoby5taW5XaWR0aCkgPyBvLm1pbldpZHRoIDogMCxcXG4gICAgICAgIG1heFdpZHRoOiB0aGlzLl9pc051bWJlcihvLm1heFdpZHRoKSA/IG8ubWF4V2lkdGggOiBJbmZpbml0eSxcXG4gICAgICAgIG1pbkhlaWdodDogdGhpcy5faXNOdW1iZXIoby5taW5IZWlnaHQpID8gby5taW5IZWlnaHQgOiAwLFxcbiAgICAgICAgbWF4SGVpZ2h0OiB0aGlzLl9pc051bWJlcihvLm1heEhlaWdodCkgPyBvLm1heEhlaWdodCA6IEluZmluaXR5XFxuICAgICAgfTtcXG5cXG4gICAgICBpZiAodGhpcy5fYXNwZWN0UmF0aW8gfHwgZm9yY2VBc3BlY3RSYXRpbykge1xcbiAgICAgICAgcE1pbldpZHRoID0gYi5taW5IZWlnaHQgKiB0aGlzLmFzcGVjdFJhdGlvO1xcbiAgICAgICAgcE1pbkhlaWdodCA9IGIubWluV2lkdGggLyB0aGlzLmFzcGVjdFJhdGlvO1xcbiAgICAgICAgcE1heFdpZHRoID0gYi5tYXhIZWlnaHQgKiB0aGlzLmFzcGVjdFJhdGlvO1xcbiAgICAgICAgcE1heEhlaWdodCA9IGIubWF4V2lkdGggLyB0aGlzLmFzcGVjdFJhdGlvO1xcblxcbiAgICAgICAgaWYgKHBNaW5XaWR0aCA+IGIubWluV2lkdGgpIHtcXG4gICAgICAgICAgYi5taW5XaWR0aCA9IHBNaW5XaWR0aDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChwTWluSGVpZ2h0ID4gYi5taW5IZWlnaHQpIHtcXG4gICAgICAgICAgYi5taW5IZWlnaHQgPSBwTWluSGVpZ2h0O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKHBNYXhXaWR0aCA8IGIubWF4V2lkdGgpIHtcXG4gICAgICAgICAgYi5tYXhXaWR0aCA9IHBNYXhXaWR0aDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChwTWF4SGVpZ2h0IDwgYi5tYXhIZWlnaHQpIHtcXG4gICAgICAgICAgYi5tYXhIZWlnaHQgPSBwTWF4SGVpZ2h0O1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl92Qm91bmRhcmllcyA9IGI7XFxuICAgIH0sXFxuICAgIF91cGRhdGVDYWNoZTogZnVuY3Rpb24gX3VwZGF0ZUNhY2hlKGRhdGEpIHtcXG4gICAgICB0aGlzLm9mZnNldCA9IHRoaXMuaGVscGVyLm9mZnNldCgpO1xcblxcbiAgICAgIGlmICh0aGlzLl9pc051bWJlcihkYXRhLmxlZnQpKSB7XFxuICAgICAgICB0aGlzLnBvc2l0aW9uLmxlZnQgPSBkYXRhLmxlZnQ7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLl9pc051bWJlcihkYXRhLnRvcCkpIHtcXG4gICAgICAgIHRoaXMucG9zaXRpb24udG9wID0gZGF0YS50b3A7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLl9pc051bWJlcihkYXRhLmhlaWdodCkpIHtcXG4gICAgICAgIHRoaXMuc2l6ZS5oZWlnaHQgPSBkYXRhLmhlaWdodDtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMuX2lzTnVtYmVyKGRhdGEud2lkdGgpKSB7XFxuICAgICAgICB0aGlzLnNpemUud2lkdGggPSBkYXRhLndpZHRoO1xcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgX3VwZGF0ZVJhdGlvOiBmdW5jdGlvbiBfdXBkYXRlUmF0aW8oZGF0YSkge1xcbiAgICAgIHZhciBjcG9zID0gdGhpcy5wb3NpdGlvbixcXG4gICAgICAgICAgY3NpemUgPSB0aGlzLnNpemUsXFxuICAgICAgICAgIGEgPSB0aGlzLmF4aXM7XFxuXFxuICAgICAgaWYgKHRoaXMuX2lzTnVtYmVyKGRhdGEuaGVpZ2h0KSkge1xcbiAgICAgICAgZGF0YS53aWR0aCA9IGRhdGEuaGVpZ2h0ICogdGhpcy5hc3BlY3RSYXRpbztcXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2lzTnVtYmVyKGRhdGEud2lkdGgpKSB7XFxuICAgICAgICBkYXRhLmhlaWdodCA9IGRhdGEud2lkdGggLyB0aGlzLmFzcGVjdFJhdGlvO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoYSA9PT0gXFxcInN3XFxcIikge1xcbiAgICAgICAgZGF0YS5sZWZ0ID0gY3Bvcy5sZWZ0ICsgKGNzaXplLndpZHRoIC0gZGF0YS53aWR0aCk7XFxuICAgICAgICBkYXRhLnRvcCA9IG51bGw7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChhID09PSBcXFwibndcXFwiKSB7XFxuICAgICAgICBkYXRhLnRvcCA9IGNwb3MudG9wICsgKGNzaXplLmhlaWdodCAtIGRhdGEuaGVpZ2h0KTtcXG4gICAgICAgIGRhdGEubGVmdCA9IGNwb3MubGVmdCArIChjc2l6ZS53aWR0aCAtIGRhdGEud2lkdGgpO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gZGF0YTtcXG4gICAgfSxcXG4gICAgX3Jlc3BlY3RTaXplOiBmdW5jdGlvbiBfcmVzcGVjdFNpemUoZGF0YSkge1xcbiAgICAgIHZhciBvID0gdGhpcy5fdkJvdW5kYXJpZXMsXFxuICAgICAgICAgIGEgPSB0aGlzLmF4aXMsXFxuICAgICAgICAgIGlzbWF4dyA9IHRoaXMuX2lzTnVtYmVyKGRhdGEud2lkdGgpICYmIG8ubWF4V2lkdGggJiYgby5tYXhXaWR0aCA8IGRhdGEud2lkdGgsXFxuICAgICAgICAgIGlzbWF4aCA9IHRoaXMuX2lzTnVtYmVyKGRhdGEuaGVpZ2h0KSAmJiBvLm1heEhlaWdodCAmJiBvLm1heEhlaWdodCA8IGRhdGEuaGVpZ2h0LFxcbiAgICAgICAgICBpc21pbncgPSB0aGlzLl9pc051bWJlcihkYXRhLndpZHRoKSAmJiBvLm1pbldpZHRoICYmIG8ubWluV2lkdGggPiBkYXRhLndpZHRoLFxcbiAgICAgICAgICBpc21pbmggPSB0aGlzLl9pc051bWJlcihkYXRhLmhlaWdodCkgJiYgby5taW5IZWlnaHQgJiYgby5taW5IZWlnaHQgPiBkYXRhLmhlaWdodCxcXG4gICAgICAgICAgZHcgPSB0aGlzLm9yaWdpbmFsUG9zaXRpb24ubGVmdCArIHRoaXMub3JpZ2luYWxTaXplLndpZHRoLFxcbiAgICAgICAgICBkaCA9IHRoaXMucG9zaXRpb24udG9wICsgdGhpcy5zaXplLmhlaWdodCxcXG4gICAgICAgICAgY3cgPSAvc3d8bnd8dy8udGVzdChhKSxcXG4gICAgICAgICAgY2ggPSAvbnd8bmV8bi8udGVzdChhKTtcXG5cXG4gICAgICBpZiAoaXNtaW53KSB7XFxuICAgICAgICBkYXRhLndpZHRoID0gby5taW5XaWR0aDtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGlzbWluaCkge1xcbiAgICAgICAgZGF0YS5oZWlnaHQgPSBvLm1pbkhlaWdodDtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGlzbWF4dykge1xcbiAgICAgICAgZGF0YS53aWR0aCA9IG8ubWF4V2lkdGg7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChpc21heGgpIHtcXG4gICAgICAgIGRhdGEuaGVpZ2h0ID0gby5tYXhIZWlnaHQ7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChpc21pbncgJiYgY3cpIHtcXG4gICAgICAgIGRhdGEubGVmdCA9IGR3IC0gby5taW5XaWR0aDtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGlzbWF4dyAmJiBjdykge1xcbiAgICAgICAgZGF0YS5sZWZ0ID0gZHcgLSBvLm1heFdpZHRoO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoaXNtaW5oICYmIGNoKSB7XFxuICAgICAgICBkYXRhLnRvcCA9IGRoIC0gby5taW5IZWlnaHQ7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChpc21heGggJiYgY2gpIHtcXG4gICAgICAgIGRhdGEudG9wID0gZGggLSBvLm1heEhlaWdodDtcXG4gICAgICB9IC8vIEZpeGluZyBqdW1wIGVycm9yIG9uIHRvcC9sZWZ0IC0gYnVnICMyMzMwXFxuXFxuXFxuICAgICAgaWYgKCFkYXRhLndpZHRoICYmICFkYXRhLmhlaWdodCAmJiAhZGF0YS5sZWZ0ICYmIGRhdGEudG9wKSB7XFxuICAgICAgICBkYXRhLnRvcCA9IG51bGw7XFxuICAgICAgfSBlbHNlIGlmICghZGF0YS53aWR0aCAmJiAhZGF0YS5oZWlnaHQgJiYgIWRhdGEudG9wICYmIGRhdGEubGVmdCkge1xcbiAgICAgICAgZGF0YS5sZWZ0ID0gbnVsbDtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIGRhdGE7XFxuICAgIH0sXFxuICAgIF9nZXRQYWRkaW5nUGx1c0JvcmRlckRpbWVuc2lvbnM6IGZ1bmN0aW9uIF9nZXRQYWRkaW5nUGx1c0JvcmRlckRpbWVuc2lvbnMoZWxlbWVudCkge1xcbiAgICAgIHZhciBpID0gMCxcXG4gICAgICAgICAgd2lkdGhzID0gW10sXFxuICAgICAgICAgIGJvcmRlcnMgPSBbZWxlbWVudC5jc3MoXFxcImJvcmRlclRvcFdpZHRoXFxcIiksIGVsZW1lbnQuY3NzKFxcXCJib3JkZXJSaWdodFdpZHRoXFxcIiksIGVsZW1lbnQuY3NzKFxcXCJib3JkZXJCb3R0b21XaWR0aFxcXCIpLCBlbGVtZW50LmNzcyhcXFwiYm9yZGVyTGVmdFdpZHRoXFxcIildLFxcbiAgICAgICAgICBwYWRkaW5ncyA9IFtlbGVtZW50LmNzcyhcXFwicGFkZGluZ1RvcFxcXCIpLCBlbGVtZW50LmNzcyhcXFwicGFkZGluZ1JpZ2h0XFxcIiksIGVsZW1lbnQuY3NzKFxcXCJwYWRkaW5nQm90dG9tXFxcIiksIGVsZW1lbnQuY3NzKFxcXCJwYWRkaW5nTGVmdFxcXCIpXTtcXG5cXG4gICAgICBmb3IgKDsgaSA8IDQ7IGkrKykge1xcbiAgICAgICAgd2lkdGhzW2ldID0gcGFyc2VJbnQoYm9yZGVyc1tpXSwgMTApIHx8IDA7XFxuICAgICAgICB3aWR0aHNbaV0gKz0gcGFyc2VJbnQocGFkZGluZ3NbaV0sIDEwKSB8fCAwO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4ge1xcbiAgICAgICAgaGVpZ2h0OiB3aWR0aHNbMF0gKyB3aWR0aHNbMl0sXFxuICAgICAgICB3aWR0aDogd2lkdGhzWzFdICsgd2lkdGhzWzNdXFxuICAgICAgfTtcXG4gICAgfSxcXG4gICAgX3Byb3BvcnRpb25hbGx5UmVzaXplOiBmdW5jdGlvbiBfcHJvcG9ydGlvbmFsbHlSZXNpemUoKSB7XFxuICAgICAgaWYgKCF0aGlzLl9wcm9wb3J0aW9uYWxseVJlc2l6ZUVsZW1lbnRzLmxlbmd0aCkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgcHJlbCxcXG4gICAgICAgICAgaSA9IDAsXFxuICAgICAgICAgIGVsZW1lbnQgPSB0aGlzLmhlbHBlciB8fCB0aGlzLmVsZW1lbnQ7XFxuXFxuICAgICAgZm9yICg7IGkgPCB0aGlzLl9wcm9wb3J0aW9uYWxseVJlc2l6ZUVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICBwcmVsID0gdGhpcy5fcHJvcG9ydGlvbmFsbHlSZXNpemVFbGVtZW50c1tpXTsgLy8gVE9ETzogU2VlbXMgbGlrZSBhIGJ1ZyB0byBjYWNoZSB0aGlzLm91dGVyRGltZW5zaW9uc1xcbiAgICAgICAgLy8gY29uc2lkZXJpbmcgdGhhdCB3ZSBhcmUgaW4gYSBsb29wLlxcblxcbiAgICAgICAgaWYgKCF0aGlzLm91dGVyRGltZW5zaW9ucykge1xcbiAgICAgICAgICB0aGlzLm91dGVyRGltZW5zaW9ucyA9IHRoaXMuX2dldFBhZGRpbmdQbHVzQm9yZGVyRGltZW5zaW9ucyhwcmVsKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHByZWwuY3NzKHtcXG4gICAgICAgICAgaGVpZ2h0OiBlbGVtZW50LmhlaWdodCgpIC0gdGhpcy5vdXRlckRpbWVuc2lvbnMuaGVpZ2h0IHx8IDAsXFxuICAgICAgICAgIHdpZHRoOiBlbGVtZW50LndpZHRoKCkgLSB0aGlzLm91dGVyRGltZW5zaW9ucy53aWR0aCB8fCAwXFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIF9yZW5kZXJQcm94eTogZnVuY3Rpb24gX3JlbmRlclByb3h5KCkge1xcbiAgICAgIHZhciBlbCA9IHRoaXMuZWxlbWVudCxcXG4gICAgICAgICAgbyA9IHRoaXMub3B0aW9ucztcXG4gICAgICB0aGlzLmVsZW1lbnRPZmZzZXQgPSBlbC5vZmZzZXQoKTtcXG5cXG4gICAgICBpZiAodGhpcy5faGVscGVyKSB7XFxuICAgICAgICB0aGlzLmhlbHBlciA9IHRoaXMuaGVscGVyIHx8ICQoXFxcIjxkaXYgc3R5bGU9J292ZXJmbG93OmhpZGRlbjsnPjwvZGl2PlxcXCIpO1xcbiAgICAgICAgdGhpcy5oZWxwZXIuYWRkQ2xhc3ModGhpcy5faGVscGVyKS5jc3Moe1xcbiAgICAgICAgICB3aWR0aDogdGhpcy5lbGVtZW50Lm91dGVyV2lkdGgoKSAtIDEsXFxuICAgICAgICAgIGhlaWdodDogdGhpcy5lbGVtZW50Lm91dGVySGVpZ2h0KCkgLSAxLFxcbiAgICAgICAgICBwb3NpdGlvbjogXFxcImFic29sdXRlXFxcIixcXG4gICAgICAgICAgbGVmdDogdGhpcy5lbGVtZW50T2Zmc2V0LmxlZnQgKyBcXFwicHhcXFwiLFxcbiAgICAgICAgICB0b3A6IHRoaXMuZWxlbWVudE9mZnNldC50b3AgKyBcXFwicHhcXFwiLFxcbiAgICAgICAgICB6SW5kZXg6ICsrby56SW5kZXggLy9UT0RPOiBEb24ndCBtb2RpZnkgb3B0aW9uXFxuXFxuICAgICAgICB9KTtcXG4gICAgICAgIHRoaXMuaGVscGVyLmFwcGVuZFRvKFxcXCJib2R5XFxcIikuZGlzYWJsZVNlbGVjdGlvbigpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB0aGlzLmhlbHBlciA9IHRoaXMuZWxlbWVudDtcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIF9jaGFuZ2U6IHtcXG4gICAgICBlOiBmdW5jdGlvbiBlKGV2ZW50LCBkeCkge1xcbiAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgd2lkdGg6IHRoaXMub3JpZ2luYWxTaXplLndpZHRoICsgZHhcXG4gICAgICAgIH07XFxuICAgICAgfSxcXG4gICAgICB3OiBmdW5jdGlvbiB3KGV2ZW50LCBkeCkge1xcbiAgICAgICAgdmFyIGNzID0gdGhpcy5vcmlnaW5hbFNpemUsXFxuICAgICAgICAgICAgc3AgPSB0aGlzLm9yaWdpbmFsUG9zaXRpb247XFxuICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICBsZWZ0OiBzcC5sZWZ0ICsgZHgsXFxuICAgICAgICAgIHdpZHRoOiBjcy53aWR0aCAtIGR4XFxuICAgICAgICB9O1xcbiAgICAgIH0sXFxuICAgICAgbjogZnVuY3Rpb24gbihldmVudCwgZHgsIGR5KSB7XFxuICAgICAgICB2YXIgY3MgPSB0aGlzLm9yaWdpbmFsU2l6ZSxcXG4gICAgICAgICAgICBzcCA9IHRoaXMub3JpZ2luYWxQb3NpdGlvbjtcXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgIHRvcDogc3AudG9wICsgZHksXFxuICAgICAgICAgIGhlaWdodDogY3MuaGVpZ2h0IC0gZHlcXG4gICAgICAgIH07XFxuICAgICAgfSxcXG4gICAgICBzOiBmdW5jdGlvbiBzKGV2ZW50LCBkeCwgZHkpIHtcXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgIGhlaWdodDogdGhpcy5vcmlnaW5hbFNpemUuaGVpZ2h0ICsgZHlcXG4gICAgICAgIH07XFxuICAgICAgfSxcXG4gICAgICBzZTogZnVuY3Rpb24gc2UoZXZlbnQsIGR4LCBkeSkge1xcbiAgICAgICAgcmV0dXJuICQuZXh0ZW5kKHRoaXMuX2NoYW5nZS5zLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHRoaXMuX2NoYW5nZS5lLmFwcGx5KHRoaXMsIFtldmVudCwgZHgsIGR5XSkpO1xcbiAgICAgIH0sXFxuICAgICAgc3c6IGZ1bmN0aW9uIHN3KGV2ZW50LCBkeCwgZHkpIHtcXG4gICAgICAgIHJldHVybiAkLmV4dGVuZCh0aGlzLl9jaGFuZ2Uucy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCB0aGlzLl9jaGFuZ2Uudy5hcHBseSh0aGlzLCBbZXZlbnQsIGR4LCBkeV0pKTtcXG4gICAgICB9LFxcbiAgICAgIG5lOiBmdW5jdGlvbiBuZShldmVudCwgZHgsIGR5KSB7XFxuICAgICAgICByZXR1cm4gJC5leHRlbmQodGhpcy5fY2hhbmdlLm4uYXBwbHkodGhpcywgYXJndW1lbnRzKSwgdGhpcy5fY2hhbmdlLmUuYXBwbHkodGhpcywgW2V2ZW50LCBkeCwgZHldKSk7XFxuICAgICAgfSxcXG4gICAgICBudzogZnVuY3Rpb24gbncoZXZlbnQsIGR4LCBkeSkge1xcbiAgICAgICAgcmV0dXJuICQuZXh0ZW5kKHRoaXMuX2NoYW5nZS5uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHRoaXMuX2NoYW5nZS53LmFwcGx5KHRoaXMsIFtldmVudCwgZHgsIGR5XSkpO1xcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgX3Byb3BhZ2F0ZTogZnVuY3Rpb24gX3Byb3BhZ2F0ZShuLCBldmVudCkge1xcbiAgICAgICQudWkucGx1Z2luLmNhbGwodGhpcywgbiwgW2V2ZW50LCB0aGlzLnVpKCldKTtcXG4gICAgICBuICE9PSBcXFwicmVzaXplXFxcIiAmJiB0aGlzLl90cmlnZ2VyKG4sIGV2ZW50LCB0aGlzLnVpKCkpO1xcbiAgICB9LFxcbiAgICBwbHVnaW5zOiB7fSxcXG4gICAgdWk6IGZ1bmN0aW9uIHVpKCkge1xcbiAgICAgIHJldHVybiB7XFxuICAgICAgICBvcmlnaW5hbEVsZW1lbnQ6IHRoaXMub3JpZ2luYWxFbGVtZW50LFxcbiAgICAgICAgZWxlbWVudDogdGhpcy5lbGVtZW50LFxcbiAgICAgICAgaGVscGVyOiB0aGlzLmhlbHBlcixcXG4gICAgICAgIHBvc2l0aW9uOiB0aGlzLnBvc2l0aW9uLFxcbiAgICAgICAgc2l6ZTogdGhpcy5zaXplLFxcbiAgICAgICAgb3JpZ2luYWxTaXplOiB0aGlzLm9yaWdpbmFsU2l6ZSxcXG4gICAgICAgIG9yaWdpbmFsUG9zaXRpb246IHRoaXMub3JpZ2luYWxQb3NpdGlvblxcbiAgICAgIH07XFxuICAgIH1cXG4gIH0pO1xcbiAgLypcXG4gICAqIFJlc2l6YWJsZSBFeHRlbnNpb25zXFxuICAgKi9cXG5cXG4gICQudWkucGx1Z2luLmFkZChcXFwicmVzaXphYmxlXFxcIiwgXFxcImFuaW1hdGVcXFwiLCB7XFxuICAgIHN0b3A6IGZ1bmN0aW9uIHN0b3AoZXZlbnQpIHtcXG4gICAgICB2YXIgdGhhdCA9ICQodGhpcykucmVzaXphYmxlKFxcXCJpbnN0YW5jZVxcXCIpLFxcbiAgICAgICAgICBvID0gdGhhdC5vcHRpb25zLFxcbiAgICAgICAgICBwciA9IHRoYXQuX3Byb3BvcnRpb25hbGx5UmVzaXplRWxlbWVudHMsXFxuICAgICAgICAgIGlzdGEgPSBwci5sZW5ndGggJiYgL3RleHRhcmVhL2kudGVzdChwclswXS5ub2RlTmFtZSksXFxuICAgICAgICAgIHNvZmZzZXRoID0gaXN0YSAmJiB0aGF0Ll9oYXNTY3JvbGwocHJbMF0sIFxcXCJsZWZ0XFxcIikgPyAwIDogdGhhdC5zaXplRGlmZi5oZWlnaHQsXFxuICAgICAgICAgIHNvZmZzZXR3ID0gaXN0YSA/IDAgOiB0aGF0LnNpemVEaWZmLndpZHRoLFxcbiAgICAgICAgICBzdHlsZSA9IHtcXG4gICAgICAgIHdpZHRoOiB0aGF0LnNpemUud2lkdGggLSBzb2Zmc2V0dyxcXG4gICAgICAgIGhlaWdodDogdGhhdC5zaXplLmhlaWdodCAtIHNvZmZzZXRoXFxuICAgICAgfSxcXG4gICAgICAgICAgbGVmdCA9IHBhcnNlSW50KHRoYXQuZWxlbWVudC5jc3MoXFxcImxlZnRcXFwiKSwgMTApICsgKHRoYXQucG9zaXRpb24ubGVmdCAtIHRoYXQub3JpZ2luYWxQb3NpdGlvbi5sZWZ0KSB8fCBudWxsLFxcbiAgICAgICAgICB0b3AgPSBwYXJzZUludCh0aGF0LmVsZW1lbnQuY3NzKFxcXCJ0b3BcXFwiKSwgMTApICsgKHRoYXQucG9zaXRpb24udG9wIC0gdGhhdC5vcmlnaW5hbFBvc2l0aW9uLnRvcCkgfHwgbnVsbDtcXG4gICAgICB0aGF0LmVsZW1lbnQuYW5pbWF0ZSgkLmV4dGVuZChzdHlsZSwgdG9wICYmIGxlZnQgPyB7XFxuICAgICAgICB0b3A6IHRvcCxcXG4gICAgICAgIGxlZnQ6IGxlZnRcXG4gICAgICB9IDoge30pLCB7XFxuICAgICAgICBkdXJhdGlvbjogby5hbmltYXRlRHVyYXRpb24sXFxuICAgICAgICBlYXNpbmc6IG8uYW5pbWF0ZUVhc2luZyxcXG4gICAgICAgIHN0ZXA6IGZ1bmN0aW9uIHN0ZXAoKSB7XFxuICAgICAgICAgIHZhciBkYXRhID0ge1xcbiAgICAgICAgICAgIHdpZHRoOiBwYXJzZUludCh0aGF0LmVsZW1lbnQuY3NzKFxcXCJ3aWR0aFxcXCIpLCAxMCksXFxuICAgICAgICAgICAgaGVpZ2h0OiBwYXJzZUludCh0aGF0LmVsZW1lbnQuY3NzKFxcXCJoZWlnaHRcXFwiKSwgMTApLFxcbiAgICAgICAgICAgIHRvcDogcGFyc2VJbnQodGhhdC5lbGVtZW50LmNzcyhcXFwidG9wXFxcIiksIDEwKSxcXG4gICAgICAgICAgICBsZWZ0OiBwYXJzZUludCh0aGF0LmVsZW1lbnQuY3NzKFxcXCJsZWZ0XFxcIiksIDEwKVxcbiAgICAgICAgICB9O1xcblxcbiAgICAgICAgICBpZiAocHIgJiYgcHIubGVuZ3RoKSB7XFxuICAgICAgICAgICAgJChwclswXSkuY3NzKHtcXG4gICAgICAgICAgICAgIHdpZHRoOiBkYXRhLndpZHRoLFxcbiAgICAgICAgICAgICAgaGVpZ2h0OiBkYXRhLmhlaWdodFxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICB9IC8vIHByb3BhZ2F0aW5nIHJlc2l6ZSwgYW5kIHVwZGF0aW5nIHZhbHVlcyBmb3IgZWFjaCBhbmltYXRpb24gc3RlcFxcblxcblxcbiAgICAgICAgICB0aGF0Ll91cGRhdGVDYWNoZShkYXRhKTtcXG5cXG4gICAgICAgICAgdGhhdC5fcHJvcGFnYXRlKFxcXCJyZXNpemVcXFwiLCBldmVudCk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgIH1cXG4gIH0pO1xcbiAgJC51aS5wbHVnaW4uYWRkKFxcXCJyZXNpemFibGVcXFwiLCBcXFwiY29udGFpbm1lbnRcXFwiLCB7XFxuICAgIHN0YXJ0OiBmdW5jdGlvbiBzdGFydCgpIHtcXG4gICAgICB2YXIgZWxlbWVudCxcXG4gICAgICAgICAgcCxcXG4gICAgICAgICAgY28sXFxuICAgICAgICAgIGNoLFxcbiAgICAgICAgICBjdyxcXG4gICAgICAgICAgd2lkdGgsXFxuICAgICAgICAgIGhlaWdodCxcXG4gICAgICAgICAgdGhhdCA9ICQodGhpcykucmVzaXphYmxlKFxcXCJpbnN0YW5jZVxcXCIpLFxcbiAgICAgICAgICBvID0gdGhhdC5vcHRpb25zLFxcbiAgICAgICAgICBlbCA9IHRoYXQuZWxlbWVudCxcXG4gICAgICAgICAgb2MgPSBvLmNvbnRhaW5tZW50LFxcbiAgICAgICAgICBjZSA9IG9jIGluc3RhbmNlb2YgJCA/IG9jLmdldCgwKSA6IC9wYXJlbnQvLnRlc3Qob2MpID8gZWwucGFyZW50KCkuZ2V0KDApIDogb2M7XFxuXFxuICAgICAgaWYgKCFjZSkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGF0LmNvbnRhaW5lckVsZW1lbnQgPSAkKGNlKTtcXG5cXG4gICAgICBpZiAoL2RvY3VtZW50Ly50ZXN0KG9jKSB8fCBvYyA9PT0gZG9jdW1lbnQpIHtcXG4gICAgICAgIHRoYXQuY29udGFpbmVyT2Zmc2V0ID0ge1xcbiAgICAgICAgICBsZWZ0OiAwLFxcbiAgICAgICAgICB0b3A6IDBcXG4gICAgICAgIH07XFxuICAgICAgICB0aGF0LmNvbnRhaW5lclBvc2l0aW9uID0ge1xcbiAgICAgICAgICBsZWZ0OiAwLFxcbiAgICAgICAgICB0b3A6IDBcXG4gICAgICAgIH07XFxuICAgICAgICB0aGF0LnBhcmVudERhdGEgPSB7XFxuICAgICAgICAgIGVsZW1lbnQ6ICQoZG9jdW1lbnQpLFxcbiAgICAgICAgICBsZWZ0OiAwLFxcbiAgICAgICAgICB0b3A6IDAsXFxuICAgICAgICAgIHdpZHRoOiAkKGRvY3VtZW50KS53aWR0aCgpLFxcbiAgICAgICAgICBoZWlnaHQ6ICQoZG9jdW1lbnQpLmhlaWdodCgpIHx8IGRvY3VtZW50LmJvZHkucGFyZW50Tm9kZS5zY3JvbGxIZWlnaHRcXG4gICAgICAgIH07XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGVsZW1lbnQgPSAkKGNlKTtcXG4gICAgICAgIHAgPSBbXTtcXG4gICAgICAgICQoW1xcXCJUb3BcXFwiLCBcXFwiUmlnaHRcXFwiLCBcXFwiTGVmdFxcXCIsIFxcXCJCb3R0b21cXFwiXSkuZWFjaChmdW5jdGlvbiAoaSwgbmFtZSkge1xcbiAgICAgICAgICBwW2ldID0gdGhhdC5fbnVtKGVsZW1lbnQuY3NzKFxcXCJwYWRkaW5nXFxcIiArIG5hbWUpKTtcXG4gICAgICAgIH0pO1xcbiAgICAgICAgdGhhdC5jb250YWluZXJPZmZzZXQgPSBlbGVtZW50Lm9mZnNldCgpO1xcbiAgICAgICAgdGhhdC5jb250YWluZXJQb3NpdGlvbiA9IGVsZW1lbnQucG9zaXRpb24oKTtcXG4gICAgICAgIHRoYXQuY29udGFpbmVyU2l6ZSA9IHtcXG4gICAgICAgICAgaGVpZ2h0OiBlbGVtZW50LmlubmVySGVpZ2h0KCkgLSBwWzNdLFxcbiAgICAgICAgICB3aWR0aDogZWxlbWVudC5pbm5lcldpZHRoKCkgLSBwWzFdXFxuICAgICAgICB9O1xcbiAgICAgICAgY28gPSB0aGF0LmNvbnRhaW5lck9mZnNldDtcXG4gICAgICAgIGNoID0gdGhhdC5jb250YWluZXJTaXplLmhlaWdodDtcXG4gICAgICAgIGN3ID0gdGhhdC5jb250YWluZXJTaXplLndpZHRoO1xcbiAgICAgICAgd2lkdGggPSB0aGF0Ll9oYXNTY3JvbGwoY2UsIFxcXCJsZWZ0XFxcIikgPyBjZS5zY3JvbGxXaWR0aCA6IGN3O1xcbiAgICAgICAgaGVpZ2h0ID0gdGhhdC5faGFzU2Nyb2xsKGNlKSA/IGNlLnNjcm9sbEhlaWdodCA6IGNoO1xcbiAgICAgICAgdGhhdC5wYXJlbnREYXRhID0ge1xcbiAgICAgICAgICBlbGVtZW50OiBjZSxcXG4gICAgICAgICAgbGVmdDogY28ubGVmdCxcXG4gICAgICAgICAgdG9wOiBjby50b3AsXFxuICAgICAgICAgIHdpZHRoOiB3aWR0aCxcXG4gICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcXG4gICAgICAgIH07XFxuICAgICAgfVxcbiAgICB9LFxcbiAgICByZXNpemU6IGZ1bmN0aW9uIHJlc2l6ZShldmVudCkge1xcbiAgICAgIHZhciB3b3NldCxcXG4gICAgICAgICAgaG9zZXQsXFxuICAgICAgICAgIGlzUGFyZW50LFxcbiAgICAgICAgICBpc09mZnNldFJlbGF0aXZlLFxcbiAgICAgICAgICB0aGF0ID0gJCh0aGlzKS5yZXNpemFibGUoXFxcImluc3RhbmNlXFxcIiksXFxuICAgICAgICAgIG8gPSB0aGF0Lm9wdGlvbnMsXFxuICAgICAgICAgIGNvID0gdGhhdC5jb250YWluZXJPZmZzZXQsXFxuICAgICAgICAgIGNwID0gdGhhdC5wb3NpdGlvbixcXG4gICAgICAgICAgcFJhdGlvID0gdGhhdC5fYXNwZWN0UmF0aW8gfHwgZXZlbnQuc2hpZnRLZXksXFxuICAgICAgICAgIGNvcCA9IHtcXG4gICAgICAgIHRvcDogMCxcXG4gICAgICAgIGxlZnQ6IDBcXG4gICAgICB9LFxcbiAgICAgICAgICBjZSA9IHRoYXQuY29udGFpbmVyRWxlbWVudCxcXG4gICAgICAgICAgY29udGludWVSZXNpemUgPSB0cnVlO1xcblxcbiAgICAgIGlmIChjZVswXSAhPT0gZG9jdW1lbnQgJiYgL3N0YXRpYy8udGVzdChjZS5jc3MoXFxcInBvc2l0aW9uXFxcIikpKSB7XFxuICAgICAgICBjb3AgPSBjbztcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGNwLmxlZnQgPCAodGhhdC5faGVscGVyID8gY28ubGVmdCA6IDApKSB7XFxuICAgICAgICB0aGF0LnNpemUud2lkdGggPSB0aGF0LnNpemUud2lkdGggKyAodGhhdC5faGVscGVyID8gdGhhdC5wb3NpdGlvbi5sZWZ0IC0gY28ubGVmdCA6IHRoYXQucG9zaXRpb24ubGVmdCAtIGNvcC5sZWZ0KTtcXG5cXG4gICAgICAgIGlmIChwUmF0aW8pIHtcXG4gICAgICAgICAgdGhhdC5zaXplLmhlaWdodCA9IHRoYXQuc2l6ZS53aWR0aCAvIHRoYXQuYXNwZWN0UmF0aW87XFxuICAgICAgICAgIGNvbnRpbnVlUmVzaXplID0gZmFsc2U7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0aGF0LnBvc2l0aW9uLmxlZnQgPSBvLmhlbHBlciA/IGNvLmxlZnQgOiAwO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoY3AudG9wIDwgKHRoYXQuX2hlbHBlciA/IGNvLnRvcCA6IDApKSB7XFxuICAgICAgICB0aGF0LnNpemUuaGVpZ2h0ID0gdGhhdC5zaXplLmhlaWdodCArICh0aGF0Ll9oZWxwZXIgPyB0aGF0LnBvc2l0aW9uLnRvcCAtIGNvLnRvcCA6IHRoYXQucG9zaXRpb24udG9wKTtcXG5cXG4gICAgICAgIGlmIChwUmF0aW8pIHtcXG4gICAgICAgICAgdGhhdC5zaXplLndpZHRoID0gdGhhdC5zaXplLmhlaWdodCAqIHRoYXQuYXNwZWN0UmF0aW87XFxuICAgICAgICAgIGNvbnRpbnVlUmVzaXplID0gZmFsc2U7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0aGF0LnBvc2l0aW9uLnRvcCA9IHRoYXQuX2hlbHBlciA/IGNvLnRvcCA6IDA7XFxuICAgICAgfVxcblxcbiAgICAgIGlzUGFyZW50ID0gdGhhdC5jb250YWluZXJFbGVtZW50LmdldCgwKSA9PT0gdGhhdC5lbGVtZW50LnBhcmVudCgpLmdldCgwKTtcXG4gICAgICBpc09mZnNldFJlbGF0aXZlID0gL3JlbGF0aXZlfGFic29sdXRlLy50ZXN0KHRoYXQuY29udGFpbmVyRWxlbWVudC5jc3MoXFxcInBvc2l0aW9uXFxcIikpO1xcblxcbiAgICAgIGlmIChpc1BhcmVudCAmJiBpc09mZnNldFJlbGF0aXZlKSB7XFxuICAgICAgICB0aGF0Lm9mZnNldC5sZWZ0ID0gdGhhdC5wYXJlbnREYXRhLmxlZnQgKyB0aGF0LnBvc2l0aW9uLmxlZnQ7XFxuICAgICAgICB0aGF0Lm9mZnNldC50b3AgPSB0aGF0LnBhcmVudERhdGEudG9wICsgdGhhdC5wb3NpdGlvbi50b3A7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRoYXQub2Zmc2V0LmxlZnQgPSB0aGF0LmVsZW1lbnQub2Zmc2V0KCkubGVmdDtcXG4gICAgICAgIHRoYXQub2Zmc2V0LnRvcCA9IHRoYXQuZWxlbWVudC5vZmZzZXQoKS50b3A7XFxuICAgICAgfVxcblxcbiAgICAgIHdvc2V0ID0gTWF0aC5hYnModGhhdC5zaXplRGlmZi53aWR0aCArICh0aGF0Ll9oZWxwZXIgPyB0aGF0Lm9mZnNldC5sZWZ0IC0gY29wLmxlZnQgOiB0aGF0Lm9mZnNldC5sZWZ0IC0gY28ubGVmdCkpO1xcbiAgICAgIGhvc2V0ID0gTWF0aC5hYnModGhhdC5zaXplRGlmZi5oZWlnaHQgKyAodGhhdC5faGVscGVyID8gdGhhdC5vZmZzZXQudG9wIC0gY29wLnRvcCA6IHRoYXQub2Zmc2V0LnRvcCAtIGNvLnRvcCkpO1xcblxcbiAgICAgIGlmICh3b3NldCArIHRoYXQuc2l6ZS53aWR0aCA+PSB0aGF0LnBhcmVudERhdGEud2lkdGgpIHtcXG4gICAgICAgIHRoYXQuc2l6ZS53aWR0aCA9IHRoYXQucGFyZW50RGF0YS53aWR0aCAtIHdvc2V0O1xcblxcbiAgICAgICAgaWYgKHBSYXRpbykge1xcbiAgICAgICAgICB0aGF0LnNpemUuaGVpZ2h0ID0gdGhhdC5zaXplLndpZHRoIC8gdGhhdC5hc3BlY3RSYXRpbztcXG4gICAgICAgICAgY29udGludWVSZXNpemUgPSBmYWxzZTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGhvc2V0ICsgdGhhdC5zaXplLmhlaWdodCA+PSB0aGF0LnBhcmVudERhdGEuaGVpZ2h0KSB7XFxuICAgICAgICB0aGF0LnNpemUuaGVpZ2h0ID0gdGhhdC5wYXJlbnREYXRhLmhlaWdodCAtIGhvc2V0O1xcblxcbiAgICAgICAgaWYgKHBSYXRpbykge1xcbiAgICAgICAgICB0aGF0LnNpemUud2lkdGggPSB0aGF0LnNpemUuaGVpZ2h0ICogdGhhdC5hc3BlY3RSYXRpbztcXG4gICAgICAgICAgY29udGludWVSZXNpemUgPSBmYWxzZTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCFjb250aW51ZVJlc2l6ZSkge1xcbiAgICAgICAgdGhhdC5wb3NpdGlvbi5sZWZ0ID0gdGhhdC5wcmV2UG9zaXRpb24ubGVmdDtcXG4gICAgICAgIHRoYXQucG9zaXRpb24udG9wID0gdGhhdC5wcmV2UG9zaXRpb24udG9wO1xcbiAgICAgICAgdGhhdC5zaXplLndpZHRoID0gdGhhdC5wcmV2U2l6ZS53aWR0aDtcXG4gICAgICAgIHRoYXQuc2l6ZS5oZWlnaHQgPSB0aGF0LnByZXZTaXplLmhlaWdodDtcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIHN0b3A6IGZ1bmN0aW9uIHN0b3AoKSB7XFxuICAgICAgdmFyIHRoYXQgPSAkKHRoaXMpLnJlc2l6YWJsZShcXFwiaW5zdGFuY2VcXFwiKSxcXG4gICAgICAgICAgbyA9IHRoYXQub3B0aW9ucyxcXG4gICAgICAgICAgY28gPSB0aGF0LmNvbnRhaW5lck9mZnNldCxcXG4gICAgICAgICAgY29wID0gdGhhdC5jb250YWluZXJQb3NpdGlvbixcXG4gICAgICAgICAgY2UgPSB0aGF0LmNvbnRhaW5lckVsZW1lbnQsXFxuICAgICAgICAgIGhlbHBlciA9ICQodGhhdC5oZWxwZXIpLFxcbiAgICAgICAgICBobyA9IGhlbHBlci5vZmZzZXQoKSxcXG4gICAgICAgICAgdyA9IGhlbHBlci5vdXRlcldpZHRoKCkgLSB0aGF0LnNpemVEaWZmLndpZHRoLFxcbiAgICAgICAgICBoID0gaGVscGVyLm91dGVySGVpZ2h0KCkgLSB0aGF0LnNpemVEaWZmLmhlaWdodDtcXG5cXG4gICAgICBpZiAodGhhdC5faGVscGVyICYmICFvLmFuaW1hdGUgJiYgL3JlbGF0aXZlLy50ZXN0KGNlLmNzcyhcXFwicG9zaXRpb25cXFwiKSkpIHtcXG4gICAgICAgICQodGhpcykuY3NzKHtcXG4gICAgICAgICAgbGVmdDogaG8ubGVmdCAtIGNvcC5sZWZ0IC0gY28ubGVmdCxcXG4gICAgICAgICAgd2lkdGg6IHcsXFxuICAgICAgICAgIGhlaWdodDogaFxcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGF0Ll9oZWxwZXIgJiYgIW8uYW5pbWF0ZSAmJiAvc3RhdGljLy50ZXN0KGNlLmNzcyhcXFwicG9zaXRpb25cXFwiKSkpIHtcXG4gICAgICAgICQodGhpcykuY3NzKHtcXG4gICAgICAgICAgbGVmdDogaG8ubGVmdCAtIGNvcC5sZWZ0IC0gY28ubGVmdCxcXG4gICAgICAgICAgd2lkdGg6IHcsXFxuICAgICAgICAgIGhlaWdodDogaFxcbiAgICAgICAgfSk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9KTtcXG4gICQudWkucGx1Z2luLmFkZChcXFwicmVzaXphYmxlXFxcIiwgXFxcImFsc29SZXNpemVcXFwiLCB7XFxuICAgIHN0YXJ0OiBmdW5jdGlvbiBzdGFydCgpIHtcXG4gICAgICB2YXIgdGhhdCA9ICQodGhpcykucmVzaXphYmxlKFxcXCJpbnN0YW5jZVxcXCIpLFxcbiAgICAgICAgICBvID0gdGhhdC5vcHRpb25zO1xcbiAgICAgICQoby5hbHNvUmVzaXplKS5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciBlbCA9ICQodGhpcyk7XFxuICAgICAgICBlbC5kYXRhKFxcXCJ1aS1yZXNpemFibGUtYWxzb3Jlc2l6ZVxcXCIsIHtcXG4gICAgICAgICAgd2lkdGg6IHBhcnNlSW50KGVsLndpZHRoKCksIDEwKSxcXG4gICAgICAgICAgaGVpZ2h0OiBwYXJzZUludChlbC5oZWlnaHQoKSwgMTApLFxcbiAgICAgICAgICBsZWZ0OiBwYXJzZUludChlbC5jc3MoXFxcImxlZnRcXFwiKSwgMTApLFxcbiAgICAgICAgICB0b3A6IHBhcnNlSW50KGVsLmNzcyhcXFwidG9wXFxcIiksIDEwKVxcbiAgICAgICAgfSk7XFxuICAgICAgfSk7XFxuICAgIH0sXFxuICAgIHJlc2l6ZTogZnVuY3Rpb24gcmVzaXplKGV2ZW50LCB1aSkge1xcbiAgICAgIHZhciB0aGF0ID0gJCh0aGlzKS5yZXNpemFibGUoXFxcImluc3RhbmNlXFxcIiksXFxuICAgICAgICAgIG8gPSB0aGF0Lm9wdGlvbnMsXFxuICAgICAgICAgIG9zID0gdGhhdC5vcmlnaW5hbFNpemUsXFxuICAgICAgICAgIG9wID0gdGhhdC5vcmlnaW5hbFBvc2l0aW9uLFxcbiAgICAgICAgICBkZWx0YSA9IHtcXG4gICAgICAgIGhlaWdodDogdGhhdC5zaXplLmhlaWdodCAtIG9zLmhlaWdodCB8fCAwLFxcbiAgICAgICAgd2lkdGg6IHRoYXQuc2l6ZS53aWR0aCAtIG9zLndpZHRoIHx8IDAsXFxuICAgICAgICB0b3A6IHRoYXQucG9zaXRpb24udG9wIC0gb3AudG9wIHx8IDAsXFxuICAgICAgICBsZWZ0OiB0aGF0LnBvc2l0aW9uLmxlZnQgLSBvcC5sZWZ0IHx8IDBcXG4gICAgICB9O1xcbiAgICAgICQoby5hbHNvUmVzaXplKS5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciBlbCA9ICQodGhpcyksXFxuICAgICAgICAgICAgc3RhcnQgPSAkKHRoaXMpLmRhdGEoXFxcInVpLXJlc2l6YWJsZS1hbHNvcmVzaXplXFxcIiksXFxuICAgICAgICAgICAgc3R5bGUgPSB7fSxcXG4gICAgICAgICAgICBjc3MgPSBlbC5wYXJlbnRzKHVpLm9yaWdpbmFsRWxlbWVudFswXSkubGVuZ3RoID8gW1xcXCJ3aWR0aFxcXCIsIFxcXCJoZWlnaHRcXFwiXSA6IFtcXFwid2lkdGhcXFwiLCBcXFwiaGVpZ2h0XFxcIiwgXFxcInRvcFxcXCIsIFxcXCJsZWZ0XFxcIl07XFxuICAgICAgICAkLmVhY2goY3NzLCBmdW5jdGlvbiAoaSwgcHJvcCkge1xcbiAgICAgICAgICB2YXIgc3VtID0gKHN0YXJ0W3Byb3BdIHx8IDApICsgKGRlbHRhW3Byb3BdIHx8IDApO1xcblxcbiAgICAgICAgICBpZiAoc3VtICYmIHN1bSA+PSAwKSB7XFxuICAgICAgICAgICAgc3R5bGVbcHJvcF0gPSBzdW0gfHwgbnVsbDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgICAgICBlbC5jc3Moc3R5bGUpO1xcbiAgICAgIH0pO1xcbiAgICB9LFxcbiAgICBzdG9wOiBmdW5jdGlvbiBzdG9wKCkge1xcbiAgICAgICQodGhpcykucmVtb3ZlRGF0YShcXFwicmVzaXphYmxlLWFsc29yZXNpemVcXFwiKTtcXG4gICAgfVxcbiAgfSk7XFxuICAkLnVpLnBsdWdpbi5hZGQoXFxcInJlc2l6YWJsZVxcXCIsIFxcXCJnaG9zdFxcXCIsIHtcXG4gICAgc3RhcnQ6IGZ1bmN0aW9uIHN0YXJ0KCkge1xcbiAgICAgIHZhciB0aGF0ID0gJCh0aGlzKS5yZXNpemFibGUoXFxcImluc3RhbmNlXFxcIiksXFxuICAgICAgICAgIG8gPSB0aGF0Lm9wdGlvbnMsXFxuICAgICAgICAgIGNzID0gdGhhdC5zaXplO1xcbiAgICAgIHRoYXQuZ2hvc3QgPSB0aGF0Lm9yaWdpbmFsRWxlbWVudC5jbG9uZSgpO1xcbiAgICAgIHRoYXQuZ2hvc3QuY3NzKHtcXG4gICAgICAgIG9wYWNpdHk6IDAuMjUsXFxuICAgICAgICBkaXNwbGF5OiBcXFwiYmxvY2tcXFwiLFxcbiAgICAgICAgcG9zaXRpb246IFxcXCJyZWxhdGl2ZVxcXCIsXFxuICAgICAgICBoZWlnaHQ6IGNzLmhlaWdodCxcXG4gICAgICAgIHdpZHRoOiBjcy53aWR0aCxcXG4gICAgICAgIG1hcmdpbjogMCxcXG4gICAgICAgIGxlZnQ6IDAsXFxuICAgICAgICB0b3A6IDBcXG4gICAgICB9KS5hZGRDbGFzcyhcXFwidWktcmVzaXphYmxlLWdob3N0XFxcIikuYWRkQ2xhc3ModHlwZW9mIG8uZ2hvc3QgPT09IFxcXCJzdHJpbmdcXFwiID8gby5naG9zdCA6IFxcXCJcXFwiKTtcXG4gICAgICB0aGF0Lmdob3N0LmFwcGVuZFRvKHRoYXQuaGVscGVyKTtcXG4gICAgfSxcXG4gICAgcmVzaXplOiBmdW5jdGlvbiByZXNpemUoKSB7XFxuICAgICAgdmFyIHRoYXQgPSAkKHRoaXMpLnJlc2l6YWJsZShcXFwiaW5zdGFuY2VcXFwiKTtcXG5cXG4gICAgICBpZiAodGhhdC5naG9zdCkge1xcbiAgICAgICAgdGhhdC5naG9zdC5jc3Moe1xcbiAgICAgICAgICBwb3NpdGlvbjogXFxcInJlbGF0aXZlXFxcIixcXG4gICAgICAgICAgaGVpZ2h0OiB0aGF0LnNpemUuaGVpZ2h0LFxcbiAgICAgICAgICB3aWR0aDogdGhhdC5zaXplLndpZHRoXFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIHN0b3A6IGZ1bmN0aW9uIHN0b3AoKSB7XFxuICAgICAgdmFyIHRoYXQgPSAkKHRoaXMpLnJlc2l6YWJsZShcXFwiaW5zdGFuY2VcXFwiKTtcXG5cXG4gICAgICBpZiAodGhhdC5naG9zdCAmJiB0aGF0LmhlbHBlcikge1xcbiAgICAgICAgdGhhdC5oZWxwZXIuZ2V0KDApLnJlbW92ZUNoaWxkKHRoYXQuZ2hvc3QuZ2V0KDApKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH0pO1xcbiAgJC51aS5wbHVnaW4uYWRkKFxcXCJyZXNpemFibGVcXFwiLCBcXFwiZ3JpZFxcXCIsIHtcXG4gICAgcmVzaXplOiBmdW5jdGlvbiByZXNpemUoKSB7XFxuICAgICAgdmFyIG91dGVyRGltZW5zaW9ucyxcXG4gICAgICAgICAgdGhhdCA9ICQodGhpcykucmVzaXphYmxlKFxcXCJpbnN0YW5jZVxcXCIpLFxcbiAgICAgICAgICBvID0gdGhhdC5vcHRpb25zLFxcbiAgICAgICAgICBjcyA9IHRoYXQuc2l6ZSxcXG4gICAgICAgICAgb3MgPSB0aGF0Lm9yaWdpbmFsU2l6ZSxcXG4gICAgICAgICAgb3AgPSB0aGF0Lm9yaWdpbmFsUG9zaXRpb24sXFxuICAgICAgICAgIGEgPSB0aGF0LmF4aXMsXFxuICAgICAgICAgIGdyaWQgPSB0eXBlb2Ygby5ncmlkID09PSBcXFwibnVtYmVyXFxcIiA/IFtvLmdyaWQsIG8uZ3JpZF0gOiBvLmdyaWQsXFxuICAgICAgICAgIGdyaWRYID0gZ3JpZFswXSB8fCAxLFxcbiAgICAgICAgICBncmlkWSA9IGdyaWRbMV0gfHwgMSxcXG4gICAgICAgICAgb3ggPSBNYXRoLnJvdW5kKChjcy53aWR0aCAtIG9zLndpZHRoKSAvIGdyaWRYKSAqIGdyaWRYLFxcbiAgICAgICAgICBveSA9IE1hdGgucm91bmQoKGNzLmhlaWdodCAtIG9zLmhlaWdodCkgLyBncmlkWSkgKiBncmlkWSxcXG4gICAgICAgICAgbmV3V2lkdGggPSBvcy53aWR0aCArIG94LFxcbiAgICAgICAgICBuZXdIZWlnaHQgPSBvcy5oZWlnaHQgKyBveSxcXG4gICAgICAgICAgaXNNYXhXaWR0aCA9IG8ubWF4V2lkdGggJiYgby5tYXhXaWR0aCA8IG5ld1dpZHRoLFxcbiAgICAgICAgICBpc01heEhlaWdodCA9IG8ubWF4SGVpZ2h0ICYmIG8ubWF4SGVpZ2h0IDwgbmV3SGVpZ2h0LFxcbiAgICAgICAgICBpc01pbldpZHRoID0gby5taW5XaWR0aCAmJiBvLm1pbldpZHRoID4gbmV3V2lkdGgsXFxuICAgICAgICAgIGlzTWluSGVpZ2h0ID0gby5taW5IZWlnaHQgJiYgby5taW5IZWlnaHQgPiBuZXdIZWlnaHQ7XFxuICAgICAgby5ncmlkID0gZ3JpZDtcXG5cXG4gICAgICBpZiAoaXNNaW5XaWR0aCkge1xcbiAgICAgICAgbmV3V2lkdGggKz0gZ3JpZFg7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChpc01pbkhlaWdodCkge1xcbiAgICAgICAgbmV3SGVpZ2h0ICs9IGdyaWRZO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoaXNNYXhXaWR0aCkge1xcbiAgICAgICAgbmV3V2lkdGggLT0gZ3JpZFg7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChpc01heEhlaWdodCkge1xcbiAgICAgICAgbmV3SGVpZ2h0IC09IGdyaWRZO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoL14oc2V8c3xlKSQvLnRlc3QoYSkpIHtcXG4gICAgICAgIHRoYXQuc2l6ZS53aWR0aCA9IG5ld1dpZHRoO1xcbiAgICAgICAgdGhhdC5zaXplLmhlaWdodCA9IG5ld0hlaWdodDtcXG4gICAgICB9IGVsc2UgaWYgKC9eKG5lKSQvLnRlc3QoYSkpIHtcXG4gICAgICAgIHRoYXQuc2l6ZS53aWR0aCA9IG5ld1dpZHRoO1xcbiAgICAgICAgdGhhdC5zaXplLmhlaWdodCA9IG5ld0hlaWdodDtcXG4gICAgICAgIHRoYXQucG9zaXRpb24udG9wID0gb3AudG9wIC0gb3k7XFxuICAgICAgfSBlbHNlIGlmICgvXihzdykkLy50ZXN0KGEpKSB7XFxuICAgICAgICB0aGF0LnNpemUud2lkdGggPSBuZXdXaWR0aDtcXG4gICAgICAgIHRoYXQuc2l6ZS5oZWlnaHQgPSBuZXdIZWlnaHQ7XFxuICAgICAgICB0aGF0LnBvc2l0aW9uLmxlZnQgPSBvcC5sZWZ0IC0gb3g7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGlmIChuZXdIZWlnaHQgLSBncmlkWSA8PSAwIHx8IG5ld1dpZHRoIC0gZ3JpZFggPD0gMCkge1xcbiAgICAgICAgICBvdXRlckRpbWVuc2lvbnMgPSB0aGF0Ll9nZXRQYWRkaW5nUGx1c0JvcmRlckRpbWVuc2lvbnModGhpcyk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAobmV3SGVpZ2h0IC0gZ3JpZFkgPiAwKSB7XFxuICAgICAgICAgIHRoYXQuc2l6ZS5oZWlnaHQgPSBuZXdIZWlnaHQ7XFxuICAgICAgICAgIHRoYXQucG9zaXRpb24udG9wID0gb3AudG9wIC0gb3k7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBuZXdIZWlnaHQgPSBncmlkWSAtIG91dGVyRGltZW5zaW9ucy5oZWlnaHQ7XFxuICAgICAgICAgIHRoYXQuc2l6ZS5oZWlnaHQgPSBuZXdIZWlnaHQ7XFxuICAgICAgICAgIHRoYXQucG9zaXRpb24udG9wID0gb3AudG9wICsgb3MuaGVpZ2h0IC0gbmV3SGVpZ2h0O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKG5ld1dpZHRoIC0gZ3JpZFggPiAwKSB7XFxuICAgICAgICAgIHRoYXQuc2l6ZS53aWR0aCA9IG5ld1dpZHRoO1xcbiAgICAgICAgICB0aGF0LnBvc2l0aW9uLmxlZnQgPSBvcC5sZWZ0IC0gb3g7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBuZXdXaWR0aCA9IGdyaWRYIC0gb3V0ZXJEaW1lbnNpb25zLndpZHRoO1xcbiAgICAgICAgICB0aGF0LnNpemUud2lkdGggPSBuZXdXaWR0aDtcXG4gICAgICAgICAgdGhhdC5wb3NpdGlvbi5sZWZ0ID0gb3AubGVmdCArIG9zLndpZHRoIC0gbmV3V2lkdGg7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuICB9KTtcXG4gIHZhciByZXNpemFibGUgPSAkLnVpLnJlc2l6YWJsZTtcXG4gIC8qIVxcbiAgICogalF1ZXJ5IFVJIERpYWxvZyAxLjExLjRcXG4gICAqIGh0dHA6Ly9qcXVlcnl1aS5jb21cXG4gICAqXFxuICAgKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xcbiAgICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxcbiAgICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxcbiAgICpcXG4gICAqIGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL2RpYWxvZy9cXG4gICAqL1xcblxcbiAgdmFyIGRpYWxvZyA9ICQud2lkZ2V0KFxcXCJ1aS5kaWFsb2dcXFwiLCB7XFxuICAgIHZlcnNpb246IFxcXCIxLjExLjRcXFwiLFxcbiAgICBvcHRpb25zOiB7XFxuICAgICAgYXBwZW5kVG86IFxcXCJib2R5XFxcIixcXG4gICAgICBhdXRvT3BlbjogdHJ1ZSxcXG4gICAgICBidXR0b25zOiBbXSxcXG4gICAgICBjbG9zZU9uRXNjYXBlOiB0cnVlLFxcbiAgICAgIGNsb3NlVGV4dDogXFxcIkNsb3NlXFxcIixcXG4gICAgICBkaWFsb2dDbGFzczogXFxcIlxcXCIsXFxuICAgICAgZHJhZ2dhYmxlOiB0cnVlLFxcbiAgICAgIGhpZGU6IG51bGwsXFxuICAgICAgaGVpZ2h0OiBcXFwiYXV0b1xcXCIsXFxuICAgICAgbWF4SGVpZ2h0OiBudWxsLFxcbiAgICAgIG1heFdpZHRoOiBudWxsLFxcbiAgICAgIG1pbkhlaWdodDogMTUwLFxcbiAgICAgIG1pbldpZHRoOiAxNTAsXFxuICAgICAgbW9kYWw6IGZhbHNlLFxcbiAgICAgIHBvc2l0aW9uOiB7XFxuICAgICAgICBteTogXFxcImNlbnRlclxcXCIsXFxuICAgICAgICBhdDogXFxcImNlbnRlclxcXCIsXFxuICAgICAgICBvZjogd2luZG93LFxcbiAgICAgICAgY29sbGlzaW9uOiBcXFwiZml0XFxcIixcXG4gICAgICAgIC8vIEVuc3VyZSB0aGUgdGl0bGViYXIgaXMgYWx3YXlzIHZpc2libGVcXG4gICAgICAgIHVzaW5nOiBmdW5jdGlvbiB1c2luZyhwb3MpIHtcXG4gICAgICAgICAgdmFyIHRvcE9mZnNldCA9ICQodGhpcykuY3NzKHBvcykub2Zmc2V0KCkudG9wO1xcblxcbiAgICAgICAgICBpZiAodG9wT2Zmc2V0IDwgMCkge1xcbiAgICAgICAgICAgICQodGhpcykuY3NzKFxcXCJ0b3BcXFwiLCBwb3MudG9wIC0gdG9wT2Zmc2V0KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH0sXFxuICAgICAgcmVzaXphYmxlOiB0cnVlLFxcbiAgICAgIHNob3c6IG51bGwsXFxuICAgICAgdGl0bGU6IG51bGwsXFxuICAgICAgd2lkdGg6IDMwMCxcXG4gICAgICAvLyBjYWxsYmFja3NcXG4gICAgICBiZWZvcmVDbG9zZTogbnVsbCxcXG4gICAgICBjbG9zZTogbnVsbCxcXG4gICAgICBkcmFnOiBudWxsLFxcbiAgICAgIGRyYWdTdGFydDogbnVsbCxcXG4gICAgICBkcmFnU3RvcDogbnVsbCxcXG4gICAgICBmb2N1czogbnVsbCxcXG4gICAgICBvcGVuOiBudWxsLFxcbiAgICAgIHJlc2l6ZTogbnVsbCxcXG4gICAgICByZXNpemVTdGFydDogbnVsbCxcXG4gICAgICByZXNpemVTdG9wOiBudWxsXFxuICAgIH0sXFxuICAgIHNpemVSZWxhdGVkT3B0aW9uczoge1xcbiAgICAgIGJ1dHRvbnM6IHRydWUsXFxuICAgICAgaGVpZ2h0OiB0cnVlLFxcbiAgICAgIG1heEhlaWdodDogdHJ1ZSxcXG4gICAgICBtYXhXaWR0aDogdHJ1ZSxcXG4gICAgICBtaW5IZWlnaHQ6IHRydWUsXFxuICAgICAgbWluV2lkdGg6IHRydWUsXFxuICAgICAgd2lkdGg6IHRydWVcXG4gICAgfSxcXG4gICAgcmVzaXphYmxlUmVsYXRlZE9wdGlvbnM6IHtcXG4gICAgICBtYXhIZWlnaHQ6IHRydWUsXFxuICAgICAgbWF4V2lkdGg6IHRydWUsXFxuICAgICAgbWluSGVpZ2h0OiB0cnVlLFxcbiAgICAgIG1pbldpZHRoOiB0cnVlXFxuICAgIH0sXFxuICAgIF9jcmVhdGU6IGZ1bmN0aW9uIF9jcmVhdGUoKSB7XFxuICAgICAgdGhpcy5vcmlnaW5hbENzcyA9IHtcXG4gICAgICAgIGRpc3BsYXk6IHRoaXMuZWxlbWVudFswXS5zdHlsZS5kaXNwbGF5LFxcbiAgICAgICAgd2lkdGg6IHRoaXMuZWxlbWVudFswXS5zdHlsZS53aWR0aCxcXG4gICAgICAgIG1pbkhlaWdodDogdGhpcy5lbGVtZW50WzBdLnN0eWxlLm1pbkhlaWdodCxcXG4gICAgICAgIG1heEhlaWdodDogdGhpcy5lbGVtZW50WzBdLnN0eWxlLm1heEhlaWdodCxcXG4gICAgICAgIGhlaWdodDogdGhpcy5lbGVtZW50WzBdLnN0eWxlLmhlaWdodFxcbiAgICAgIH07XFxuICAgICAgdGhpcy5vcmlnaW5hbFBvc2l0aW9uID0ge1xcbiAgICAgICAgcGFyZW50OiB0aGlzLmVsZW1lbnQucGFyZW50KCksXFxuICAgICAgICBpbmRleDogdGhpcy5lbGVtZW50LnBhcmVudCgpLmNoaWxkcmVuKCkuaW5kZXgodGhpcy5lbGVtZW50KVxcbiAgICAgIH07XFxuICAgICAgdGhpcy5vcmlnaW5hbFRpdGxlID0gdGhpcy5lbGVtZW50LmF0dHIoXFxcInRpdGxlXFxcIik7XFxuICAgICAgdGhpcy5vcHRpb25zLnRpdGxlID0gdGhpcy5vcHRpb25zLnRpdGxlIHx8IHRoaXMub3JpZ2luYWxUaXRsZTtcXG5cXG4gICAgICB0aGlzLl9jcmVhdGVXcmFwcGVyKCk7XFxuXFxuICAgICAgdGhpcy5lbGVtZW50LnNob3coKS5yZW1vdmVBdHRyKFxcXCJ0aXRsZVxcXCIpLmFkZENsYXNzKFxcXCJ1aS1kaWFsb2ctY29udGVudCB1aS13aWRnZXQtY29udGVudFxcXCIpLmFwcGVuZFRvKHRoaXMudWlEaWFsb2cpO1xcblxcbiAgICAgIHRoaXMuX2NyZWF0ZVRpdGxlYmFyKCk7XFxuXFxuICAgICAgdGhpcy5fY3JlYXRlQnV0dG9uUGFuZSgpO1xcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlICYmICQuZm4uZHJhZ2dhYmxlKSB7XFxuICAgICAgICB0aGlzLl9tYWtlRHJhZ2dhYmxlKCk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucmVzaXphYmxlICYmICQuZm4ucmVzaXphYmxlKSB7XFxuICAgICAgICB0aGlzLl9tYWtlUmVzaXphYmxlKCk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX2lzT3BlbiA9IGZhbHNlO1xcblxcbiAgICAgIHRoaXMuX3RyYWNrRm9jdXMoKTtcXG4gICAgfSxcXG4gICAgX2luaXQ6IGZ1bmN0aW9uIF9pbml0KCkge1xcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b09wZW4pIHtcXG4gICAgICAgIHRoaXMub3BlbigpO1xcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgX2FwcGVuZFRvOiBmdW5jdGlvbiBfYXBwZW5kVG8oKSB7XFxuICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLm9wdGlvbnMuYXBwZW5kVG87XFxuXFxuICAgICAgaWYgKGVsZW1lbnQgJiYgKGVsZW1lbnQuanF1ZXJ5IHx8IGVsZW1lbnQubm9kZVR5cGUpKSB7XFxuICAgICAgICByZXR1cm4gJChlbGVtZW50KTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnQuZmluZChlbGVtZW50IHx8IFxcXCJib2R5XFxcIikuZXEoMCk7XFxuICAgIH0sXFxuICAgIF9kZXN0cm95OiBmdW5jdGlvbiBfZGVzdHJveSgpIHtcXG4gICAgICB2YXIgbmV4dCxcXG4gICAgICAgICAgb3JpZ2luYWxQb3NpdGlvbiA9IHRoaXMub3JpZ2luYWxQb3NpdGlvbjtcXG5cXG4gICAgICB0aGlzLl91bnRyYWNrSW5zdGFuY2UoKTtcXG5cXG4gICAgICB0aGlzLl9kZXN0cm95T3ZlcmxheSgpO1xcblxcbiAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVVbmlxdWVJZCgpLnJlbW92ZUNsYXNzKFxcXCJ1aS1kaWFsb2ctY29udGVudCB1aS13aWRnZXQtY29udGVudFxcXCIpLmNzcyh0aGlzLm9yaWdpbmFsQ3NzKSAvLyBXaXRob3V0IGRldGFjaGluZyBmaXJzdCwgdGhlIGZvbGxvd2luZyBiZWNvbWVzIHJlYWxseSBzbG93XFxuICAgICAgLmRldGFjaCgpO1xcbiAgICAgIHRoaXMudWlEaWFsb2cuc3RvcCh0cnVlLCB0cnVlKS5yZW1vdmUoKTtcXG5cXG4gICAgICBpZiAodGhpcy5vcmlnaW5hbFRpdGxlKSB7XFxuICAgICAgICB0aGlzLmVsZW1lbnQuYXR0cihcXFwidGl0bGVcXFwiLCB0aGlzLm9yaWdpbmFsVGl0bGUpO1xcbiAgICAgIH1cXG5cXG4gICAgICBuZXh0ID0gb3JpZ2luYWxQb3NpdGlvbi5wYXJlbnQuY2hpbGRyZW4oKS5lcShvcmlnaW5hbFBvc2l0aW9uLmluZGV4KTsgLy8gRG9uJ3QgdHJ5IHRvIHBsYWNlIHRoZSBkaWFsb2cgbmV4dCB0byBpdHNlbGYgKCM4NjEzKVxcblxcbiAgICAgIGlmIChuZXh0Lmxlbmd0aCAmJiBuZXh0WzBdICE9PSB0aGlzLmVsZW1lbnRbMF0pIHtcXG4gICAgICAgIG5leHQuYmVmb3JlKHRoaXMuZWxlbWVudCk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIG9yaWdpbmFsUG9zaXRpb24ucGFyZW50LmFwcGVuZCh0aGlzLmVsZW1lbnQpO1xcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgd2lkZ2V0OiBmdW5jdGlvbiB3aWRnZXQoKSB7XFxuICAgICAgcmV0dXJuIHRoaXMudWlEaWFsb2c7XFxuICAgIH0sXFxuICAgIGRpc2FibGU6ICQubm9vcCxcXG4gICAgZW5hYmxlOiAkLm5vb3AsXFxuICAgIGNsb3NlOiBmdW5jdGlvbiBjbG9zZShldmVudCkge1xcbiAgICAgIHZhciBhY3RpdmVFbGVtZW50LFxcbiAgICAgICAgICB0aGF0ID0gdGhpcztcXG5cXG4gICAgICBpZiAoIXRoaXMuX2lzT3BlbiB8fCB0aGlzLl90cmlnZ2VyKFxcXCJiZWZvcmVDbG9zZVxcXCIsIGV2ZW50KSA9PT0gZmFsc2UpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5faXNPcGVuID0gZmFsc2U7XFxuICAgICAgdGhpcy5fZm9jdXNlZEVsZW1lbnQgPSBudWxsO1xcblxcbiAgICAgIHRoaXMuX2Rlc3Ryb3lPdmVybGF5KCk7XFxuXFxuICAgICAgdGhpcy5fdW50cmFja0luc3RhbmNlKCk7XFxuXFxuICAgICAgaWYgKCF0aGlzLm9wZW5lci5maWx0ZXIoXFxcIjpmb2N1c2FibGVcXFwiKS5mb2N1cygpLmxlbmd0aCkge1xcbiAgICAgICAgLy8gc3VwcG9ydDogSUU5XFxuICAgICAgICAvLyBJRTkgdGhyb3dzIGFuIFxcXCJVbnNwZWNpZmllZCBlcnJvclxcXCIgYWNjZXNzaW5nIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgZnJvbSBhbiA8aWZyYW1lPlxcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgYWN0aXZlRWxlbWVudCA9IHRoaXMuZG9jdW1lbnRbMF0uYWN0aXZlRWxlbWVudDsgLy8gU3VwcG9ydDogSUU5LCBJRTEwXFxuICAgICAgICAgIC8vIElmIHRoZSA8Ym9keT4gaXMgYmx1cnJlZCwgSUUgd2lsbCBzd2l0Y2ggd2luZG93cywgc2VlICM0NTIwXFxuXFxuICAgICAgICAgIGlmIChhY3RpdmVFbGVtZW50ICYmIGFjdGl2ZUVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gXFxcImJvZHlcXFwiKSB7XFxuICAgICAgICAgICAgLy8gSGlkaW5nIGEgZm9jdXNlZCBlbGVtZW50IGRvZXNuJ3QgdHJpZ2dlciBibHVyIGluIFdlYktpdFxcbiAgICAgICAgICAgIC8vIHNvIGluIGNhc2Ugd2UgaGF2ZSBub3RoaW5nIHRvIGZvY3VzIG9uLCBleHBsaWNpdGx5IGJsdXIgdGhlIGFjdGl2ZSBlbGVtZW50XFxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTQ3MTgyXFxuICAgICAgICAgICAgJChhY3RpdmVFbGVtZW50KS5ibHVyKCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7fVxcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9oaWRlKHRoaXMudWlEaWFsb2csIHRoaXMub3B0aW9ucy5oaWRlLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICB0aGF0Ll90cmlnZ2VyKFxcXCJjbG9zZVxcXCIsIGV2ZW50KTtcXG4gICAgICB9KTtcXG4gICAgfSxcXG4gICAgaXNPcGVuOiBmdW5jdGlvbiBpc09wZW4oKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuX2lzT3BlbjtcXG4gICAgfSxcXG4gICAgbW92ZVRvVG9wOiBmdW5jdGlvbiBtb3ZlVG9Ub3AoKSB7XFxuICAgICAgdGhpcy5fbW92ZVRvVG9wKCk7XFxuICAgIH0sXFxuICAgIF9tb3ZlVG9Ub3A6IGZ1bmN0aW9uIF9tb3ZlVG9Ub3AoZXZlbnQsIHNpbGVudCkge1xcbiAgICAgIHZhciBtb3ZlZCA9IGZhbHNlLFxcbiAgICAgICAgICB6SW5kaWNlcyA9IHRoaXMudWlEaWFsb2cuc2libGluZ3MoXFxcIi51aS1mcm9udDp2aXNpYmxlXFxcIikubWFwKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHJldHVybiArJCh0aGlzKS5jc3MoXFxcInotaW5kZXhcXFwiKTtcXG4gICAgICB9KS5nZXQoKSxcXG4gICAgICAgICAgekluZGV4TWF4ID0gTWF0aC5tYXguYXBwbHkobnVsbCwgekluZGljZXMpO1xcblxcbiAgICAgIGlmICh6SW5kZXhNYXggPj0gK3RoaXMudWlEaWFsb2cuY3NzKFxcXCJ6LWluZGV4XFxcIikpIHtcXG4gICAgICAgIHRoaXMudWlEaWFsb2cuY3NzKFxcXCJ6LWluZGV4XFxcIiwgekluZGV4TWF4ICsgMSk7XFxuICAgICAgICBtb3ZlZCA9IHRydWU7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChtb3ZlZCAmJiAhc2lsZW50KSB7XFxuICAgICAgICB0aGlzLl90cmlnZ2VyKFxcXCJmb2N1c1xcXCIsIGV2ZW50KTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIG1vdmVkO1xcbiAgICB9LFxcbiAgICBvcGVuOiBmdW5jdGlvbiBvcGVuKCkge1xcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcXG5cXG4gICAgICBpZiAodGhpcy5faXNPcGVuKSB7XFxuICAgICAgICBpZiAodGhpcy5fbW92ZVRvVG9wKCkpIHtcXG4gICAgICAgICAgdGhpcy5fZm9jdXNUYWJiYWJsZSgpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9pc09wZW4gPSB0cnVlO1xcbiAgICAgIHRoaXMub3BlbmVyID0gJCh0aGlzLmRvY3VtZW50WzBdLmFjdGl2ZUVsZW1lbnQpO1xcblxcbiAgICAgIHRoaXMuX3NpemUoKTtcXG5cXG4gICAgICB0aGlzLl9wb3NpdGlvbigpO1xcblxcbiAgICAgIHRoaXMuX2NyZWF0ZU92ZXJsYXkoKTtcXG5cXG4gICAgICB0aGlzLl9tb3ZlVG9Ub3AobnVsbCwgdHJ1ZSk7IC8vIEVuc3VyZSB0aGUgb3ZlcmxheSBpcyBtb3ZlZCB0byB0aGUgdG9wIHdpdGggdGhlIGRpYWxvZywgYnV0IG9ubHkgd2hlblxcbiAgICAgIC8vIG9wZW5pbmcuIFRoZSBvdmVybGF5IHNob3VsZG4ndCBtb3ZlIGFmdGVyIHRoZSBkaWFsb2cgaXMgb3BlbiBzbyB0aGF0XFxuICAgICAgLy8gbW9kZWxlc3MgZGlhbG9ncyBvcGVuZWQgYWZ0ZXIgdGhlIG1vZGFsIGRpYWxvZyBzdGFjayBwcm9wZXJseS5cXG5cXG5cXG4gICAgICBpZiAodGhpcy5vdmVybGF5KSB7XFxuICAgICAgICB0aGlzLm92ZXJsYXkuY3NzKFxcXCJ6LWluZGV4XFxcIiwgdGhpcy51aURpYWxvZy5jc3MoXFxcInotaW5kZXhcXFwiKSAtIDEpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9zaG93KHRoaXMudWlEaWFsb2csIHRoaXMub3B0aW9ucy5zaG93LCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICB0aGF0Ll9mb2N1c1RhYmJhYmxlKCk7XFxuXFxuICAgICAgICB0aGF0Ll90cmlnZ2VyKFxcXCJmb2N1c1xcXCIpO1xcbiAgICAgIH0pOyAvLyBUcmFjayB0aGUgZGlhbG9nIGltbWVkaWF0ZWx5IHVwb24gb3BlbmVuaW5nIGluIGNhc2UgYSBmb2N1cyBldmVudFxcbiAgICAgIC8vIHNvbWVob3cgb2NjdXJzIG91dHNpZGUgb2YgdGhlIGRpYWxvZyBiZWZvcmUgYW4gZWxlbWVudCBpbnNpZGUgdGhlXFxuICAgICAgLy8gZGlhbG9nIGlzIGZvY3VzZWQgKCMxMDE1MilcXG5cXG5cXG4gICAgICB0aGlzLl9tYWtlRm9jdXNUYXJnZXQoKTtcXG5cXG4gICAgICB0aGlzLl90cmlnZ2VyKFxcXCJvcGVuXFxcIik7XFxuICAgIH0sXFxuICAgIF9mb2N1c1RhYmJhYmxlOiBmdW5jdGlvbiBfZm9jdXNUYWJiYWJsZSgpIHtcXG4gICAgICAvLyBTZXQgZm9jdXMgdG8gdGhlIGZpcnN0IG1hdGNoOlxcbiAgICAgIC8vIDEuIEFuIGVsZW1lbnQgdGhhdCB3YXMgZm9jdXNlZCBwcmV2aW91c2x5XFxuICAgICAgLy8gMi4gRmlyc3QgZWxlbWVudCBpbnNpZGUgdGhlIGRpYWxvZyBtYXRjaGluZyBbYXV0b2ZvY3VzXVxcbiAgICAgIC8vIDMuIFRhYmJhYmxlIGVsZW1lbnQgaW5zaWRlIHRoZSBjb250ZW50IGVsZW1lbnRcXG4gICAgICAvLyA0LiBUYWJiYWJsZSBlbGVtZW50IGluc2lkZSB0aGUgYnV0dG9ucGFuZVxcbiAgICAgIC8vIDUuIFRoZSBjbG9zZSBidXR0b25cXG4gICAgICAvLyA2LiBUaGUgZGlhbG9nIGl0c2VsZlxcbiAgICAgIHZhciBoYXNGb2N1cyA9IHRoaXMuX2ZvY3VzZWRFbGVtZW50O1xcblxcbiAgICAgIGlmICghaGFzRm9jdXMpIHtcXG4gICAgICAgIGhhc0ZvY3VzID0gdGhpcy5lbGVtZW50LmZpbmQoXFxcIlthdXRvZm9jdXNdXFxcIik7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghaGFzRm9jdXMubGVuZ3RoKSB7XFxuICAgICAgICBoYXNGb2N1cyA9IHRoaXMuZWxlbWVudC5maW5kKFxcXCI6dGFiYmFibGVcXFwiKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCFoYXNGb2N1cy5sZW5ndGgpIHtcXG4gICAgICAgIGhhc0ZvY3VzID0gdGhpcy51aURpYWxvZ0J1dHRvblBhbmUuZmluZChcXFwiOnRhYmJhYmxlXFxcIik7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghaGFzRm9jdXMubGVuZ3RoKSB7XFxuICAgICAgICBoYXNGb2N1cyA9IHRoaXMudWlEaWFsb2dUaXRsZWJhckNsb3NlLmZpbHRlcihcXFwiOnRhYmJhYmxlXFxcIik7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghaGFzRm9jdXMubGVuZ3RoKSB7XFxuICAgICAgICBoYXNGb2N1cyA9IHRoaXMudWlEaWFsb2c7XFxuICAgICAgfVxcblxcbiAgICAgIGhhc0ZvY3VzLmVxKDApLmZvY3VzKCk7XFxuICAgIH0sXFxuICAgIF9rZWVwRm9jdXM6IGZ1bmN0aW9uIF9rZWVwRm9jdXMoZXZlbnQpIHtcXG4gICAgICBmdW5jdGlvbiBjaGVja0ZvY3VzKCkge1xcbiAgICAgICAgdmFyIGFjdGl2ZUVsZW1lbnQgPSB0aGlzLmRvY3VtZW50WzBdLmFjdGl2ZUVsZW1lbnQsXFxuICAgICAgICAgICAgaXNBY3RpdmUgPSB0aGlzLnVpRGlhbG9nWzBdID09PSBhY3RpdmVFbGVtZW50IHx8ICQuY29udGFpbnModGhpcy51aURpYWxvZ1swXSwgYWN0aXZlRWxlbWVudCk7XFxuXFxuICAgICAgICBpZiAoIWlzQWN0aXZlKSB7XFxuICAgICAgICAgIHRoaXMuX2ZvY3VzVGFiYmFibGUoKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG4gICAgICBjaGVja0ZvY3VzLmNhbGwodGhpcyk7IC8vIHN1cHBvcnQ6IElFXFxuICAgICAgLy8gSUUgPD0gOCBkb2Vzbid0IHByZXZlbnQgbW92aW5nIGZvY3VzIGV2ZW4gd2l0aCBldmVudC5wcmV2ZW50RGVmYXVsdCgpXFxuICAgICAgLy8gc28gd2UgY2hlY2sgYWdhaW4gbGF0ZXJcXG5cXG4gICAgICB0aGlzLl9kZWxheShjaGVja0ZvY3VzKTtcXG4gICAgfSxcXG4gICAgX2NyZWF0ZVdyYXBwZXI6IGZ1bmN0aW9uIF9jcmVhdGVXcmFwcGVyKCkge1xcbiAgICAgIHRoaXMudWlEaWFsb2cgPSAkKFxcXCI8ZGl2PlxcXCIpLmFkZENsYXNzKFxcXCJ1aS1kaWFsb2cgdWktd2lkZ2V0IHVpLXdpZGdldC1jb250ZW50IHVpLWNvcm5lci1hbGwgdWktZnJvbnQgXFxcIiArIHRoaXMub3B0aW9ucy5kaWFsb2dDbGFzcykuaGlkZSgpLmF0dHIoe1xcbiAgICAgICAgLy8gU2V0dGluZyB0YWJJbmRleCBtYWtlcyB0aGUgZGl2IGZvY3VzYWJsZVxcbiAgICAgICAgdGFiSW5kZXg6IC0xLFxcbiAgICAgICAgcm9sZTogXFxcImRpYWxvZ1xcXCJcXG4gICAgICB9KS5hcHBlbmRUbyh0aGlzLl9hcHBlbmRUbygpKTtcXG5cXG4gICAgICB0aGlzLl9vbih0aGlzLnVpRGlhbG9nLCB7XFxuICAgICAgICBrZXlkb3duOiBmdW5jdGlvbiBrZXlkb3duKGV2ZW50KSB7XFxuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY2xvc2VPbkVzY2FwZSAmJiAhZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgJiYgZXZlbnQua2V5Q29kZSAmJiBldmVudC5rZXlDb2RlID09PSAkLnVpLmtleUNvZGUuRVNDQVBFKSB7XFxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgICAgICB0aGlzLmNsb3NlKGV2ZW50KTtcXG4gICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgIH0gLy8gcHJldmVudCB0YWJiaW5nIG91dCBvZiBkaWFsb2dzXFxuXFxuXFxuICAgICAgICAgIGlmIChldmVudC5rZXlDb2RlICE9PSAkLnVpLmtleUNvZGUuVEFCIHx8IGV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHZhciB0YWJiYWJsZXMgPSB0aGlzLnVpRGlhbG9nLmZpbmQoXFxcIjp0YWJiYWJsZVxcXCIpLFxcbiAgICAgICAgICAgICAgZmlyc3QgPSB0YWJiYWJsZXMuZmlsdGVyKFxcXCI6Zmlyc3RcXFwiKSxcXG4gICAgICAgICAgICAgIGxhc3QgPSB0YWJiYWJsZXMuZmlsdGVyKFxcXCI6bGFzdFxcXCIpO1xcblxcbiAgICAgICAgICBpZiAoKGV2ZW50LnRhcmdldCA9PT0gbGFzdFswXSB8fCBldmVudC50YXJnZXQgPT09IHRoaXMudWlEaWFsb2dbMF0pICYmICFldmVudC5zaGlmdEtleSkge1xcbiAgICAgICAgICAgIHRoaXMuX2RlbGF5KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgIGZpcnN0LmZvY3VzKCk7XFxuICAgICAgICAgICAgfSk7XFxuXFxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgICAgfSBlbHNlIGlmICgoZXZlbnQudGFyZ2V0ID09PSBmaXJzdFswXSB8fCBldmVudC50YXJnZXQgPT09IHRoaXMudWlEaWFsb2dbMF0pICYmIGV2ZW50LnNoaWZ0S2V5KSB7XFxuICAgICAgICAgICAgdGhpcy5fZGVsYXkoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgbGFzdC5mb2N1cygpO1xcbiAgICAgICAgICAgIH0pO1xcblxcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuICAgICAgICBtb3VzZWRvd246IGZ1bmN0aW9uIG1vdXNlZG93bihldmVudCkge1xcbiAgICAgICAgICBpZiAodGhpcy5fbW92ZVRvVG9wKGV2ZW50KSkge1xcbiAgICAgICAgICAgIHRoaXMuX2ZvY3VzVGFiYmFibGUoKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH0pOyAvLyBXZSBhc3N1bWUgdGhhdCBhbnkgZXhpc3RpbmcgYXJpYS1kZXNjcmliZWRieSBhdHRyaWJ1dGUgbWVhbnNcXG4gICAgICAvLyB0aGF0IHRoZSBkaWFsb2cgY29udGVudCBpcyBtYXJrZWQgdXAgcHJvcGVybHlcXG4gICAgICAvLyBvdGhlcndpc2Ugd2UgYnJ1dGUgZm9yY2UgdGhlIGNvbnRlbnQgYXMgdGhlIGRlc2NyaXB0aW9uXFxuXFxuXFxuICAgICAgaWYgKCF0aGlzLmVsZW1lbnQuZmluZChcXFwiW2FyaWEtZGVzY3JpYmVkYnldXFxcIikubGVuZ3RoKSB7XFxuICAgICAgICB0aGlzLnVpRGlhbG9nLmF0dHIoe1xcbiAgICAgICAgICBcXFwiYXJpYS1kZXNjcmliZWRieVxcXCI6IHRoaXMuZWxlbWVudC51bmlxdWVJZCgpLmF0dHIoXFxcImlkXFxcIilcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgX2NyZWF0ZVRpdGxlYmFyOiBmdW5jdGlvbiBfY3JlYXRlVGl0bGViYXIoKSB7XFxuICAgICAgdmFyIHVpRGlhbG9nVGl0bGU7XFxuICAgICAgdGhpcy51aURpYWxvZ1RpdGxlYmFyID0gJChcXFwiPGRpdj5cXFwiKS5hZGRDbGFzcyhcXFwidWktZGlhbG9nLXRpdGxlYmFyIHVpLXdpZGdldC1oZWFkZXIgdWktY29ybmVyLWFsbCB1aS1oZWxwZXItY2xlYXJmaXhcXFwiKS5wcmVwZW5kVG8odGhpcy51aURpYWxvZyk7XFxuXFxuICAgICAgdGhpcy5fb24odGhpcy51aURpYWxvZ1RpdGxlYmFyLCB7XFxuICAgICAgICBtb3VzZWRvd246IGZ1bmN0aW9uIG1vdXNlZG93bihldmVudCkge1xcbiAgICAgICAgICAvLyBEb24ndCBwcmV2ZW50IGNsaWNrIG9uIGNsb3NlIGJ1dHRvbiAoIzg4MzgpXFxuICAgICAgICAgIC8vIEZvY3VzaW5nIGEgZGlhbG9nIHRoYXQgaXMgcGFydGlhbGx5IHNjcm9sbGVkIG91dCBvZiB2aWV3XFxuICAgICAgICAgIC8vIGNhdXNlcyB0aGUgYnJvd3NlciB0byBzY3JvbGwgaXQgaW50byB2aWV3LCBwcmV2ZW50aW5nIHRoZSBjbGljayBldmVudFxcbiAgICAgICAgICBpZiAoISQoZXZlbnQudGFyZ2V0KS5jbG9zZXN0KFxcXCIudWktZGlhbG9nLXRpdGxlYmFyLWNsb3NlXFxcIikpIHtcXG4gICAgICAgICAgICAvLyBEaWFsb2cgaXNuJ3QgZ2V0dGluZyBmb2N1cyB3aGVuIGRyYWdnaW5nICgjODA2MylcXG4gICAgICAgICAgICB0aGlzLnVpRGlhbG9nLmZvY3VzKCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9KTsgLy8gc3VwcG9ydDogSUVcXG4gICAgICAvLyBVc2UgdHlwZT1cXFwiYnV0dG9uXFxcIiB0byBwcmV2ZW50IGVudGVyIGtleXByZXNzZXMgaW4gdGV4dGJveGVzIGZyb20gY2xvc2luZyB0aGVcXG4gICAgICAvLyBkaWFsb2cgaW4gSUUgKCM5MzEyKVxcblxcblxcbiAgICAgIHRoaXMudWlEaWFsb2dUaXRsZWJhckNsb3NlID0gJChcXFwiPGJ1dHRvbiB0eXBlPSdidXR0b24nPjwvYnV0dG9uPlxcXCIpLmJ1dHRvbih7XFxuICAgICAgICBsYWJlbDogdGhpcy5vcHRpb25zLmNsb3NlVGV4dCxcXG4gICAgICAgIGljb25zOiB7XFxuICAgICAgICAgIHByaW1hcnk6IFxcXCJ1aS1pY29uLWNsb3NldGhpY2tcXFwiXFxuICAgICAgICB9LFxcbiAgICAgICAgdGV4dDogZmFsc2VcXG4gICAgICB9KS5hZGRDbGFzcyhcXFwidWktZGlhbG9nLXRpdGxlYmFyLWNsb3NlXFxcIikuYXBwZW5kVG8odGhpcy51aURpYWxvZ1RpdGxlYmFyKTtcXG5cXG4gICAgICB0aGlzLl9vbih0aGlzLnVpRGlhbG9nVGl0bGViYXJDbG9zZSwge1xcbiAgICAgICAgY2xpY2s6IGZ1bmN0aW9uIGNsaWNrKGV2ZW50KSB7XFxuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICAgIHRoaXMuY2xvc2UoZXZlbnQpO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcblxcbiAgICAgIHVpRGlhbG9nVGl0bGUgPSAkKFxcXCI8c3Bhbj5cXFwiKS51bmlxdWVJZCgpLmFkZENsYXNzKFxcXCJ1aS1kaWFsb2ctdGl0bGVcXFwiKS5wcmVwZW5kVG8odGhpcy51aURpYWxvZ1RpdGxlYmFyKTtcXG5cXG4gICAgICB0aGlzLl90aXRsZSh1aURpYWxvZ1RpdGxlKTtcXG5cXG4gICAgICB0aGlzLnVpRGlhbG9nLmF0dHIoe1xcbiAgICAgICAgXFxcImFyaWEtbGFiZWxsZWRieVxcXCI6IHVpRGlhbG9nVGl0bGUuYXR0cihcXFwiaWRcXFwiKVxcbiAgICAgIH0pO1xcbiAgICB9LFxcbiAgICBfdGl0bGU6IGZ1bmN0aW9uIF90aXRsZSh0aXRsZSkge1xcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLnRpdGxlKSB7XFxuICAgICAgICB0aXRsZS5odG1sKFxcXCImIzE2MDtcXFwiKTtcXG4gICAgICB9XFxuXFxuICAgICAgdGl0bGUudGV4dCh0aGlzLm9wdGlvbnMudGl0bGUpO1xcbiAgICB9LFxcbiAgICBfY3JlYXRlQnV0dG9uUGFuZTogZnVuY3Rpb24gX2NyZWF0ZUJ1dHRvblBhbmUoKSB7XFxuICAgICAgdGhpcy51aURpYWxvZ0J1dHRvblBhbmUgPSAkKFxcXCI8ZGl2PlxcXCIpLmFkZENsYXNzKFxcXCJ1aS1kaWFsb2ctYnV0dG9ucGFuZSB1aS13aWRnZXQtY29udGVudCB1aS1oZWxwZXItY2xlYXJmaXhcXFwiKTtcXG4gICAgICB0aGlzLnVpQnV0dG9uU2V0ID0gJChcXFwiPGRpdj5cXFwiKS5hZGRDbGFzcyhcXFwidWktZGlhbG9nLWJ1dHRvbnNldFxcXCIpLmFwcGVuZFRvKHRoaXMudWlEaWFsb2dCdXR0b25QYW5lKTtcXG5cXG4gICAgICB0aGlzLl9jcmVhdGVCdXR0b25zKCk7XFxuICAgIH0sXFxuICAgIF9jcmVhdGVCdXR0b25zOiBmdW5jdGlvbiBfY3JlYXRlQnV0dG9ucygpIHtcXG4gICAgICB2YXIgdGhhdCA9IHRoaXMsXFxuICAgICAgICAgIGJ1dHRvbnMgPSB0aGlzLm9wdGlvbnMuYnV0dG9uczsgLy8gaWYgd2UgYWxyZWFkeSBoYXZlIGEgYnV0dG9uIHBhbmUsIHJlbW92ZSBpdFxcblxcbiAgICAgIHRoaXMudWlEaWFsb2dCdXR0b25QYW5lLnJlbW92ZSgpO1xcbiAgICAgIHRoaXMudWlCdXR0b25TZXQuZW1wdHkoKTtcXG5cXG4gICAgICBpZiAoJC5pc0VtcHR5T2JqZWN0KGJ1dHRvbnMpIHx8ICQuaXNBcnJheShidXR0b25zKSAmJiAhYnV0dG9ucy5sZW5ndGgpIHtcXG4gICAgICAgIHRoaXMudWlEaWFsb2cucmVtb3ZlQ2xhc3MoXFxcInVpLWRpYWxvZy1idXR0b25zXFxcIik7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgICQuZWFjaChidXR0b25zLCBmdW5jdGlvbiAobmFtZSwgcHJvcHMpIHtcXG4gICAgICAgIHZhciBjbGljaywgYnV0dG9uT3B0aW9ucztcXG4gICAgICAgIHByb3BzID0gJC5pc0Z1bmN0aW9uKHByb3BzKSA/IHtcXG4gICAgICAgICAgY2xpY2s6IHByb3BzLFxcbiAgICAgICAgICB0ZXh0OiBuYW1lXFxuICAgICAgICB9IDogcHJvcHM7IC8vIERlZmF1bHQgdG8gYSBub24tc3VibWl0dGluZyBidXR0b25cXG5cXG4gICAgICAgIHByb3BzID0gJC5leHRlbmQoe1xcbiAgICAgICAgICB0eXBlOiBcXFwiYnV0dG9uXFxcIlxcbiAgICAgICAgfSwgcHJvcHMpOyAvLyBDaGFuZ2UgdGhlIGNvbnRleHQgZm9yIHRoZSBjbGljayBjYWxsYmFjayB0byBiZSB0aGUgbWFpbiBlbGVtZW50XFxuXFxuICAgICAgICBjbGljayA9IHByb3BzLmNsaWNrO1xcblxcbiAgICAgICAgcHJvcHMuY2xpY2sgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIGNsaWNrLmFwcGx5KHRoYXQuZWxlbWVudFswXSwgYXJndW1lbnRzKTtcXG4gICAgICAgIH07XFxuXFxuICAgICAgICBidXR0b25PcHRpb25zID0ge1xcbiAgICAgICAgICBpY29uczogcHJvcHMuaWNvbnMsXFxuICAgICAgICAgIHRleHQ6IHByb3BzLnNob3dUZXh0XFxuICAgICAgICB9O1xcbiAgICAgICAgZGVsZXRlIHByb3BzLmljb25zO1xcbiAgICAgICAgZGVsZXRlIHByb3BzLnNob3dUZXh0O1xcbiAgICAgICAgJChcXFwiPGJ1dHRvbj48L2J1dHRvbj5cXFwiLCBwcm9wcykuYnV0dG9uKGJ1dHRvbk9wdGlvbnMpLmFwcGVuZFRvKHRoYXQudWlCdXR0b25TZXQpO1xcbiAgICAgIH0pO1xcbiAgICAgIHRoaXMudWlEaWFsb2cuYWRkQ2xhc3MoXFxcInVpLWRpYWxvZy1idXR0b25zXFxcIik7XFxuICAgICAgdGhpcy51aURpYWxvZ0J1dHRvblBhbmUuYXBwZW5kVG8odGhpcy51aURpYWxvZyk7XFxuICAgIH0sXFxuICAgIF9tYWtlRHJhZ2dhYmxlOiBmdW5jdGlvbiBfbWFrZURyYWdnYWJsZSgpIHtcXG4gICAgICB2YXIgdGhhdCA9IHRoaXMsXFxuICAgICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XFxuXFxuICAgICAgZnVuY3Rpb24gZmlsdGVyZWRVaSh1aSkge1xcbiAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgcG9zaXRpb246IHVpLnBvc2l0aW9uLFxcbiAgICAgICAgICBvZmZzZXQ6IHVpLm9mZnNldFxcbiAgICAgICAgfTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy51aURpYWxvZy5kcmFnZ2FibGUoe1xcbiAgICAgICAgY2FuY2VsOiBcXFwiLnVpLWRpYWxvZy1jb250ZW50LCAudWktZGlhbG9nLXRpdGxlYmFyLWNsb3NlXFxcIixcXG4gICAgICAgIGhhbmRsZTogXFxcIi51aS1kaWFsb2ctdGl0bGViYXJcXFwiLFxcbiAgICAgICAgY29udGFpbm1lbnQ6IFxcXCJkb2N1bWVudFxcXCIsXFxuICAgICAgICBzdGFydDogZnVuY3Rpb24gc3RhcnQoZXZlbnQsIHVpKSB7XFxuICAgICAgICAgICQodGhpcykuYWRkQ2xhc3MoXFxcInVpLWRpYWxvZy1kcmFnZ2luZ1xcXCIpO1xcblxcbiAgICAgICAgICB0aGF0Ll9ibG9ja0ZyYW1lcygpO1xcblxcbiAgICAgICAgICB0aGF0Ll90cmlnZ2VyKFxcXCJkcmFnU3RhcnRcXFwiLCBldmVudCwgZmlsdGVyZWRVaSh1aSkpO1xcbiAgICAgICAgfSxcXG4gICAgICAgIGRyYWc6IGZ1bmN0aW9uIGRyYWcoZXZlbnQsIHVpKSB7XFxuICAgICAgICAgIHRoYXQuX3RyaWdnZXIoXFxcImRyYWdcXFwiLCBldmVudCwgZmlsdGVyZWRVaSh1aSkpO1xcbiAgICAgICAgfSxcXG4gICAgICAgIHN0b3A6IGZ1bmN0aW9uIHN0b3AoZXZlbnQsIHVpKSB7XFxuICAgICAgICAgIHZhciBsZWZ0ID0gdWkub2Zmc2V0LmxlZnQgLSB0aGF0LmRvY3VtZW50LnNjcm9sbExlZnQoKSxcXG4gICAgICAgICAgICAgIHRvcCA9IHVpLm9mZnNldC50b3AgLSB0aGF0LmRvY3VtZW50LnNjcm9sbFRvcCgpO1xcbiAgICAgICAgICBvcHRpb25zLnBvc2l0aW9uID0ge1xcbiAgICAgICAgICAgIG15OiBcXFwibGVmdCB0b3BcXFwiLFxcbiAgICAgICAgICAgIGF0OiBcXFwibGVmdFxcXCIgKyAobGVmdCA+PSAwID8gXFxcIitcXFwiIDogXFxcIlxcXCIpICsgbGVmdCArIFxcXCIgXFxcIiArIFxcXCJ0b3BcXFwiICsgKHRvcCA+PSAwID8gXFxcIitcXFwiIDogXFxcIlxcXCIpICsgdG9wLFxcbiAgICAgICAgICAgIG9mOiB0aGF0LndpbmRvd1xcbiAgICAgICAgICB9O1xcbiAgICAgICAgICAkKHRoaXMpLnJlbW92ZUNsYXNzKFxcXCJ1aS1kaWFsb2ctZHJhZ2dpbmdcXFwiKTtcXG5cXG4gICAgICAgICAgdGhhdC5fdW5ibG9ja0ZyYW1lcygpO1xcblxcbiAgICAgICAgICB0aGF0Ll90cmlnZ2VyKFxcXCJkcmFnU3RvcFxcXCIsIGV2ZW50LCBmaWx0ZXJlZFVpKHVpKSk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgIH0sXFxuICAgIF9tYWtlUmVzaXphYmxlOiBmdW5jdGlvbiBfbWFrZVJlc2l6YWJsZSgpIHtcXG4gICAgICB2YXIgdGhhdCA9IHRoaXMsXFxuICAgICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXFxuICAgICAgICAgIGhhbmRsZXMgPSBvcHRpb25zLnJlc2l6YWJsZSxcXG4gICAgICAgICAgLy8gLnVpLXJlc2l6YWJsZSBoYXMgcG9zaXRpb246IHJlbGF0aXZlIGRlZmluZWQgaW4gdGhlIHN0eWxlc2hlZXRcXG4gICAgICAvLyBidXQgZGlhbG9ncyBoYXZlIHRvIHVzZSBhYnNvbHV0ZSBvciBmaXhlZCBwb3NpdGlvbmluZ1xcbiAgICAgIHBvc2l0aW9uID0gdGhpcy51aURpYWxvZy5jc3MoXFxcInBvc2l0aW9uXFxcIiksXFxuICAgICAgICAgIHJlc2l6ZUhhbmRsZXMgPSB0eXBlb2YgaGFuZGxlcyA9PT0gXFxcInN0cmluZ1xcXCIgPyBoYW5kbGVzIDogXFxcIm4sZSxzLHcsc2Usc3csbmUsbndcXFwiO1xcblxcbiAgICAgIGZ1bmN0aW9uIGZpbHRlcmVkVWkodWkpIHtcXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgIG9yaWdpbmFsUG9zaXRpb246IHVpLm9yaWdpbmFsUG9zaXRpb24sXFxuICAgICAgICAgIG9yaWdpbmFsU2l6ZTogdWkub3JpZ2luYWxTaXplLFxcbiAgICAgICAgICBwb3NpdGlvbjogdWkucG9zaXRpb24sXFxuICAgICAgICAgIHNpemU6IHVpLnNpemVcXG4gICAgICAgIH07XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMudWlEaWFsb2cucmVzaXphYmxlKHtcXG4gICAgICAgIGNhbmNlbDogXFxcIi51aS1kaWFsb2ctY29udGVudFxcXCIsXFxuICAgICAgICBjb250YWlubWVudDogXFxcImRvY3VtZW50XFxcIixcXG4gICAgICAgIGFsc29SZXNpemU6IHRoaXMuZWxlbWVudCxcXG4gICAgICAgIG1heFdpZHRoOiBvcHRpb25zLm1heFdpZHRoLFxcbiAgICAgICAgbWF4SGVpZ2h0OiBvcHRpb25zLm1heEhlaWdodCxcXG4gICAgICAgIG1pbldpZHRoOiBvcHRpb25zLm1pbldpZHRoLFxcbiAgICAgICAgbWluSGVpZ2h0OiB0aGlzLl9taW5IZWlnaHQoKSxcXG4gICAgICAgIGhhbmRsZXM6IHJlc2l6ZUhhbmRsZXMsXFxuICAgICAgICBzdGFydDogZnVuY3Rpb24gc3RhcnQoZXZlbnQsIHVpKSB7XFxuICAgICAgICAgICQodGhpcykuYWRkQ2xhc3MoXFxcInVpLWRpYWxvZy1yZXNpemluZ1xcXCIpO1xcblxcbiAgICAgICAgICB0aGF0Ll9ibG9ja0ZyYW1lcygpO1xcblxcbiAgICAgICAgICB0aGF0Ll90cmlnZ2VyKFxcXCJyZXNpemVTdGFydFxcXCIsIGV2ZW50LCBmaWx0ZXJlZFVpKHVpKSk7XFxuICAgICAgICB9LFxcbiAgICAgICAgcmVzaXplOiBmdW5jdGlvbiByZXNpemUoZXZlbnQsIHVpKSB7XFxuICAgICAgICAgIHRoYXQuX3RyaWdnZXIoXFxcInJlc2l6ZVxcXCIsIGV2ZW50LCBmaWx0ZXJlZFVpKHVpKSk7XFxuICAgICAgICB9LFxcbiAgICAgICAgc3RvcDogZnVuY3Rpb24gc3RvcChldmVudCwgdWkpIHtcXG4gICAgICAgICAgdmFyIG9mZnNldCA9IHRoYXQudWlEaWFsb2cub2Zmc2V0KCksXFxuICAgICAgICAgICAgICBsZWZ0ID0gb2Zmc2V0LmxlZnQgLSB0aGF0LmRvY3VtZW50LnNjcm9sbExlZnQoKSxcXG4gICAgICAgICAgICAgIHRvcCA9IG9mZnNldC50b3AgLSB0aGF0LmRvY3VtZW50LnNjcm9sbFRvcCgpO1xcbiAgICAgICAgICBvcHRpb25zLmhlaWdodCA9IHRoYXQudWlEaWFsb2cuaGVpZ2h0KCk7XFxuICAgICAgICAgIG9wdGlvbnMud2lkdGggPSB0aGF0LnVpRGlhbG9nLndpZHRoKCk7XFxuICAgICAgICAgIG9wdGlvbnMucG9zaXRpb24gPSB7XFxuICAgICAgICAgICAgbXk6IFxcXCJsZWZ0IHRvcFxcXCIsXFxuICAgICAgICAgICAgYXQ6IFxcXCJsZWZ0XFxcIiArIChsZWZ0ID49IDAgPyBcXFwiK1xcXCIgOiBcXFwiXFxcIikgKyBsZWZ0ICsgXFxcIiBcXFwiICsgXFxcInRvcFxcXCIgKyAodG9wID49IDAgPyBcXFwiK1xcXCIgOiBcXFwiXFxcIikgKyB0b3AsXFxuICAgICAgICAgICAgb2Y6IHRoYXQud2luZG93XFxuICAgICAgICAgIH07XFxuICAgICAgICAgICQodGhpcykucmVtb3ZlQ2xhc3MoXFxcInVpLWRpYWxvZy1yZXNpemluZ1xcXCIpO1xcblxcbiAgICAgICAgICB0aGF0Ll91bmJsb2NrRnJhbWVzKCk7XFxuXFxuICAgICAgICAgIHRoYXQuX3RyaWdnZXIoXFxcInJlc2l6ZVN0b3BcXFwiLCBldmVudCwgZmlsdGVyZWRVaSh1aSkpO1xcbiAgICAgICAgfVxcbiAgICAgIH0pLmNzcyhcXFwicG9zaXRpb25cXFwiLCBwb3NpdGlvbik7XFxuICAgIH0sXFxuICAgIF90cmFja0ZvY3VzOiBmdW5jdGlvbiBfdHJhY2tGb2N1cygpIHtcXG4gICAgICB0aGlzLl9vbih0aGlzLndpZGdldCgpLCB7XFxuICAgICAgICBmb2N1c2luOiBmdW5jdGlvbiBmb2N1c2luKGV2ZW50KSB7XFxuICAgICAgICAgIHRoaXMuX21ha2VGb2N1c1RhcmdldCgpO1xcblxcbiAgICAgICAgICB0aGlzLl9mb2N1c2VkRWxlbWVudCA9ICQoZXZlbnQudGFyZ2V0KTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgfSxcXG4gICAgX21ha2VGb2N1c1RhcmdldDogZnVuY3Rpb24gX21ha2VGb2N1c1RhcmdldCgpIHtcXG4gICAgICB0aGlzLl91bnRyYWNrSW5zdGFuY2UoKTtcXG5cXG4gICAgICB0aGlzLl90cmFja2luZ0luc3RhbmNlcygpLnVuc2hpZnQodGhpcyk7XFxuICAgIH0sXFxuICAgIF91bnRyYWNrSW5zdGFuY2U6IGZ1bmN0aW9uIF91bnRyYWNrSW5zdGFuY2UoKSB7XFxuICAgICAgdmFyIGluc3RhbmNlcyA9IHRoaXMuX3RyYWNraW5nSW5zdGFuY2VzKCksXFxuICAgICAgICAgIGV4aXN0cyA9ICQuaW5BcnJheSh0aGlzLCBpbnN0YW5jZXMpO1xcblxcbiAgICAgIGlmIChleGlzdHMgIT09IC0xKSB7XFxuICAgICAgICBpbnN0YW5jZXMuc3BsaWNlKGV4aXN0cywgMSk7XFxuICAgICAgfVxcbiAgICB9LFxcbiAgICBfdHJhY2tpbmdJbnN0YW5jZXM6IGZ1bmN0aW9uIF90cmFja2luZ0luc3RhbmNlcygpIHtcXG4gICAgICB2YXIgaW5zdGFuY2VzID0gdGhpcy5kb2N1bWVudC5kYXRhKFxcXCJ1aS1kaWFsb2ctaW5zdGFuY2VzXFxcIik7XFxuXFxuICAgICAgaWYgKCFpbnN0YW5jZXMpIHtcXG4gICAgICAgIGluc3RhbmNlcyA9IFtdO1xcbiAgICAgICAgdGhpcy5kb2N1bWVudC5kYXRhKFxcXCJ1aS1kaWFsb2ctaW5zdGFuY2VzXFxcIiwgaW5zdGFuY2VzKTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIGluc3RhbmNlcztcXG4gICAgfSxcXG4gICAgX21pbkhlaWdodDogZnVuY3Rpb24gX21pbkhlaWdodCgpIHtcXG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcXG4gICAgICByZXR1cm4gb3B0aW9ucy5oZWlnaHQgPT09IFxcXCJhdXRvXFxcIiA/IG9wdGlvbnMubWluSGVpZ2h0IDogTWF0aC5taW4ob3B0aW9ucy5taW5IZWlnaHQsIG9wdGlvbnMuaGVpZ2h0KTtcXG4gICAgfSxcXG4gICAgX3Bvc2l0aW9uOiBmdW5jdGlvbiBfcG9zaXRpb24oKSB7XFxuICAgICAgLy8gTmVlZCB0byBzaG93IHRoZSBkaWFsb2cgdG8gZ2V0IHRoZSBhY3R1YWwgb2Zmc2V0IGluIHRoZSBwb3NpdGlvbiBwbHVnaW5cXG4gICAgICB2YXIgaXNWaXNpYmxlID0gdGhpcy51aURpYWxvZy5pcyhcXFwiOnZpc2libGVcXFwiKTtcXG5cXG4gICAgICBpZiAoIWlzVmlzaWJsZSkge1xcbiAgICAgICAgdGhpcy51aURpYWxvZy5zaG93KCk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMudWlEaWFsb2cucG9zaXRpb24odGhpcy5vcHRpb25zLnBvc2l0aW9uKTtcXG5cXG4gICAgICBpZiAoIWlzVmlzaWJsZSkge1xcbiAgICAgICAgdGhpcy51aURpYWxvZy5oaWRlKCk7XFxuICAgICAgfVxcbiAgICB9LFxcbiAgICBfc2V0T3B0aW9uczogZnVuY3Rpb24gX3NldE9wdGlvbnMob3B0aW9ucykge1xcbiAgICAgIHZhciB0aGF0ID0gdGhpcyxcXG4gICAgICAgICAgcmVzaXplID0gZmFsc2UsXFxuICAgICAgICAgIHJlc2l6YWJsZU9wdGlvbnMgPSB7fTtcXG4gICAgICAkLmVhY2gob3B0aW9ucywgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcXG4gICAgICAgIHRoYXQuX3NldE9wdGlvbihrZXksIHZhbHVlKTtcXG5cXG4gICAgICAgIGlmIChrZXkgaW4gdGhhdC5zaXplUmVsYXRlZE9wdGlvbnMpIHtcXG4gICAgICAgICAgcmVzaXplID0gdHJ1ZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChrZXkgaW4gdGhhdC5yZXNpemFibGVSZWxhdGVkT3B0aW9ucykge1xcbiAgICAgICAgICByZXNpemFibGVPcHRpb25zW2tleV0gPSB2YWx1ZTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG5cXG4gICAgICBpZiAocmVzaXplKSB7XFxuICAgICAgICB0aGlzLl9zaXplKCk7XFxuXFxuICAgICAgICB0aGlzLl9wb3NpdGlvbigpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy51aURpYWxvZy5pcyhcXFwiOmRhdGEodWktcmVzaXphYmxlKVxcXCIpKSB7XFxuICAgICAgICB0aGlzLnVpRGlhbG9nLnJlc2l6YWJsZShcXFwib3B0aW9uXFxcIiwgcmVzaXphYmxlT3B0aW9ucyk7XFxuICAgICAgfVxcbiAgICB9LFxcbiAgICBfc2V0T3B0aW9uOiBmdW5jdGlvbiBfc2V0T3B0aW9uKGtleSwgdmFsdWUpIHtcXG4gICAgICB2YXIgaXNEcmFnZ2FibGUsXFxuICAgICAgICAgIGlzUmVzaXphYmxlLFxcbiAgICAgICAgICB1aURpYWxvZyA9IHRoaXMudWlEaWFsb2c7XFxuXFxuICAgICAgaWYgKGtleSA9PT0gXFxcImRpYWxvZ0NsYXNzXFxcIikge1xcbiAgICAgICAgdWlEaWFsb2cucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmRpYWxvZ0NsYXNzKS5hZGRDbGFzcyh2YWx1ZSk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChrZXkgPT09IFxcXCJkaXNhYmxlZFxcXCIpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fc3VwZXIoa2V5LCB2YWx1ZSk7XFxuXFxuICAgICAgaWYgKGtleSA9PT0gXFxcImFwcGVuZFRvXFxcIikge1xcbiAgICAgICAgdGhpcy51aURpYWxvZy5hcHBlbmRUbyh0aGlzLl9hcHBlbmRUbygpKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGtleSA9PT0gXFxcImJ1dHRvbnNcXFwiKSB7XFxuICAgICAgICB0aGlzLl9jcmVhdGVCdXR0b25zKCk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChrZXkgPT09IFxcXCJjbG9zZVRleHRcXFwiKSB7XFxuICAgICAgICB0aGlzLnVpRGlhbG9nVGl0bGViYXJDbG9zZS5idXR0b24oe1xcbiAgICAgICAgICAvLyBFbnN1cmUgdGhhdCB3ZSBhbHdheXMgcGFzcyBhIHN0cmluZ1xcbiAgICAgICAgICBsYWJlbDogXFxcIlxcXCIgKyB2YWx1ZVxcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChrZXkgPT09IFxcXCJkcmFnZ2FibGVcXFwiKSB7XFxuICAgICAgICBpc0RyYWdnYWJsZSA9IHVpRGlhbG9nLmlzKFxcXCI6ZGF0YSh1aS1kcmFnZ2FibGUpXFxcIik7XFxuXFxuICAgICAgICBpZiAoaXNEcmFnZ2FibGUgJiYgIXZhbHVlKSB7XFxuICAgICAgICAgIHVpRGlhbG9nLmRyYWdnYWJsZShcXFwiZGVzdHJveVxcXCIpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKCFpc0RyYWdnYWJsZSAmJiB2YWx1ZSkge1xcbiAgICAgICAgICB0aGlzLl9tYWtlRHJhZ2dhYmxlKCk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChrZXkgPT09IFxcXCJwb3NpdGlvblxcXCIpIHtcXG4gICAgICAgIHRoaXMuX3Bvc2l0aW9uKCk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChrZXkgPT09IFxcXCJyZXNpemFibGVcXFwiKSB7XFxuICAgICAgICAvLyBjdXJyZW50bHkgcmVzaXphYmxlLCBiZWNvbWluZyBub24tcmVzaXphYmxlXFxuICAgICAgICBpc1Jlc2l6YWJsZSA9IHVpRGlhbG9nLmlzKFxcXCI6ZGF0YSh1aS1yZXNpemFibGUpXFxcIik7XFxuXFxuICAgICAgICBpZiAoaXNSZXNpemFibGUgJiYgIXZhbHVlKSB7XFxuICAgICAgICAgIHVpRGlhbG9nLnJlc2l6YWJsZShcXFwiZGVzdHJveVxcXCIpO1xcbiAgICAgICAgfSAvLyBjdXJyZW50bHkgcmVzaXphYmxlLCBjaGFuZ2luZyBoYW5kbGVzXFxuXFxuXFxuICAgICAgICBpZiAoaXNSZXNpemFibGUgJiYgdHlwZW9mIHZhbHVlID09PSBcXFwic3RyaW5nXFxcIikge1xcbiAgICAgICAgICB1aURpYWxvZy5yZXNpemFibGUoXFxcIm9wdGlvblxcXCIsIFxcXCJoYW5kbGVzXFxcIiwgdmFsdWUpO1xcbiAgICAgICAgfSAvLyBjdXJyZW50bHkgbm9uLXJlc2l6YWJsZSwgYmVjb21pbmcgcmVzaXphYmxlXFxuXFxuXFxuICAgICAgICBpZiAoIWlzUmVzaXphYmxlICYmIHZhbHVlICE9PSBmYWxzZSkge1xcbiAgICAgICAgICB0aGlzLl9tYWtlUmVzaXphYmxlKCk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChrZXkgPT09IFxcXCJ0aXRsZVxcXCIpIHtcXG4gICAgICAgIHRoaXMuX3RpdGxlKHRoaXMudWlEaWFsb2dUaXRsZWJhci5maW5kKFxcXCIudWktZGlhbG9nLXRpdGxlXFxcIikpO1xcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgX3NpemU6IGZ1bmN0aW9uIF9zaXplKCkge1xcbiAgICAgIC8vIElmIHRoZSB1c2VyIGhhcyByZXNpemVkIHRoZSBkaWFsb2csIHRoZSAudWktZGlhbG9nIGFuZCAudWktZGlhbG9nLWNvbnRlbnRcXG4gICAgICAvLyBkaXZzIHdpbGwgYm90aCBoYXZlIHdpZHRoIGFuZCBoZWlnaHQgc2V0LCBzbyB3ZSBuZWVkIHRvIHJlc2V0IHRoZW1cXG4gICAgICB2YXIgbm9uQ29udGVudEhlaWdodCxcXG4gICAgICAgICAgbWluQ29udGVudEhlaWdodCxcXG4gICAgICAgICAgbWF4Q29udGVudEhlaWdodCxcXG4gICAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9uczsgLy8gUmVzZXQgY29udGVudCBzaXppbmdcXG5cXG4gICAgICB0aGlzLmVsZW1lbnQuc2hvdygpLmNzcyh7XFxuICAgICAgICB3aWR0aDogXFxcImF1dG9cXFwiLFxcbiAgICAgICAgbWluSGVpZ2h0OiAwLFxcbiAgICAgICAgbWF4SGVpZ2h0OiBcXFwibm9uZVxcXCIsXFxuICAgICAgICBoZWlnaHQ6IDBcXG4gICAgICB9KTtcXG5cXG4gICAgICBpZiAob3B0aW9ucy5taW5XaWR0aCA+IG9wdGlvbnMud2lkdGgpIHtcXG4gICAgICAgIG9wdGlvbnMud2lkdGggPSBvcHRpb25zLm1pbldpZHRoO1xcbiAgICAgIH0gLy8gcmVzZXQgd3JhcHBlciBzaXppbmdcXG4gICAgICAvLyBkZXRlcm1pbmUgdGhlIGhlaWdodCBvZiBhbGwgdGhlIG5vbi1jb250ZW50IGVsZW1lbnRzXFxuXFxuXFxuICAgICAgbm9uQ29udGVudEhlaWdodCA9IHRoaXMudWlEaWFsb2cuY3NzKHtcXG4gICAgICAgIGhlaWdodDogXFxcImF1dG9cXFwiLFxcbiAgICAgICAgd2lkdGg6IG9wdGlvbnMud2lkdGhcXG4gICAgICB9KS5vdXRlckhlaWdodCgpO1xcbiAgICAgIG1pbkNvbnRlbnRIZWlnaHQgPSBNYXRoLm1heCgwLCBvcHRpb25zLm1pbkhlaWdodCAtIG5vbkNvbnRlbnRIZWlnaHQpO1xcbiAgICAgIG1heENvbnRlbnRIZWlnaHQgPSB0eXBlb2Ygb3B0aW9ucy5tYXhIZWlnaHQgPT09IFxcXCJudW1iZXJcXFwiID8gTWF0aC5tYXgoMCwgb3B0aW9ucy5tYXhIZWlnaHQgLSBub25Db250ZW50SGVpZ2h0KSA6IFxcXCJub25lXFxcIjtcXG5cXG4gICAgICBpZiAob3B0aW9ucy5oZWlnaHQgPT09IFxcXCJhdXRvXFxcIikge1xcbiAgICAgICAgdGhpcy5lbGVtZW50LmNzcyh7XFxuICAgICAgICAgIG1pbkhlaWdodDogbWluQ29udGVudEhlaWdodCxcXG4gICAgICAgICAgbWF4SGVpZ2h0OiBtYXhDb250ZW50SGVpZ2h0LFxcbiAgICAgICAgICBoZWlnaHQ6IFxcXCJhdXRvXFxcIlxcbiAgICAgICAgfSk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRoaXMuZWxlbWVudC5oZWlnaHQoTWF0aC5tYXgoMCwgb3B0aW9ucy5oZWlnaHQgLSBub25Db250ZW50SGVpZ2h0KSk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLnVpRGlhbG9nLmlzKFxcXCI6ZGF0YSh1aS1yZXNpemFibGUpXFxcIikpIHtcXG4gICAgICAgIHRoaXMudWlEaWFsb2cucmVzaXphYmxlKFxcXCJvcHRpb25cXFwiLCBcXFwibWluSGVpZ2h0XFxcIiwgdGhpcy5fbWluSGVpZ2h0KCkpO1xcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgX2Jsb2NrRnJhbWVzOiBmdW5jdGlvbiBfYmxvY2tGcmFtZXMoKSB7XFxuICAgICAgdGhpcy5pZnJhbWVCbG9ja3MgPSB0aGlzLmRvY3VtZW50LmZpbmQoXFxcImlmcmFtZVxcXCIpLm1hcChmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgaWZyYW1lID0gJCh0aGlzKTtcXG4gICAgICAgIHJldHVybiAkKFxcXCI8ZGl2PlxcXCIpLmNzcyh7XFxuICAgICAgICAgIHBvc2l0aW9uOiBcXFwiYWJzb2x1dGVcXFwiLFxcbiAgICAgICAgICB3aWR0aDogaWZyYW1lLm91dGVyV2lkdGgoKSxcXG4gICAgICAgICAgaGVpZ2h0OiBpZnJhbWUub3V0ZXJIZWlnaHQoKVxcbiAgICAgICAgfSkuYXBwZW5kVG8oaWZyYW1lLnBhcmVudCgpKS5vZmZzZXQoaWZyYW1lLm9mZnNldCgpKVswXTtcXG4gICAgICB9KTtcXG4gICAgfSxcXG4gICAgX3VuYmxvY2tGcmFtZXM6IGZ1bmN0aW9uIF91bmJsb2NrRnJhbWVzKCkge1xcbiAgICAgIGlmICh0aGlzLmlmcmFtZUJsb2Nrcykge1xcbiAgICAgICAgdGhpcy5pZnJhbWVCbG9ja3MucmVtb3ZlKCk7XFxuICAgICAgICBkZWxldGUgdGhpcy5pZnJhbWVCbG9ja3M7XFxuICAgICAgfVxcbiAgICB9LFxcbiAgICBfYWxsb3dJbnRlcmFjdGlvbjogZnVuY3Rpb24gX2FsbG93SW50ZXJhY3Rpb24oZXZlbnQpIHtcXG4gICAgICBpZiAoJChldmVudC50YXJnZXQpLmNsb3Nlc3QoXFxcIi51aS1kaWFsb2dcXFwiKS5sZW5ndGgpIHtcXG4gICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgIH0gLy8gVE9ETzogUmVtb3ZlIGhhY2sgd2hlbiBkYXRlcGlja2VyIGltcGxlbWVudHNcXG4gICAgICAvLyB0aGUgLnVpLWZyb250IGxvZ2ljICgjODk4OSlcXG5cXG5cXG4gICAgICByZXR1cm4gISEkKGV2ZW50LnRhcmdldCkuY2xvc2VzdChcXFwiLnVpLWRhdGVwaWNrZXJcXFwiKS5sZW5ndGg7XFxuICAgIH0sXFxuICAgIF9jcmVhdGVPdmVybGF5OiBmdW5jdGlvbiBfY3JlYXRlT3ZlcmxheSgpIHtcXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5tb2RhbCkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH0gLy8gV2UgdXNlIGEgZGVsYXkgaW4gY2FzZSB0aGUgb3ZlcmxheSBpcyBjcmVhdGVkIGZyb20gYW5cXG4gICAgICAvLyBldmVudCB0aGF0IHdlJ3JlIGdvaW5nIHRvIGJlIGNhbmNlbGxpbmcgKCMyODA0KVxcblxcblxcbiAgICAgIHZhciBpc09wZW5pbmcgPSB0cnVlO1xcblxcbiAgICAgIHRoaXMuX2RlbGF5KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGlzT3BlbmluZyA9IGZhbHNlO1xcbiAgICAgIH0pO1xcblxcbiAgICAgIGlmICghdGhpcy5kb2N1bWVudC5kYXRhKFxcXCJ1aS1kaWFsb2ctb3ZlcmxheXNcXFwiKSkge1xcbiAgICAgICAgLy8gUHJldmVudCB1c2Ugb2YgYW5jaG9ycyBhbmQgaW5wdXRzXFxuICAgICAgICAvLyBVc2luZyBfb24oKSBmb3IgYW4gZXZlbnQgaGFuZGxlciBzaGFyZWQgYWNyb3NzIG1hbnkgaW5zdGFuY2VzIGlzXFxuICAgICAgICAvLyBzYWZlIGJlY2F1c2UgdGhlIGRpYWxvZ3Mgc3RhY2sgYW5kIG11c3QgYmUgY2xvc2VkIGluIHJldmVyc2Ugb3JkZXJcXG4gICAgICAgIHRoaXMuX29uKHRoaXMuZG9jdW1lbnQsIHtcXG4gICAgICAgICAgZm9jdXNpbjogZnVuY3Rpb24gZm9jdXNpbihldmVudCkge1xcbiAgICAgICAgICAgIGlmIChpc09wZW5pbmcpIHtcXG4gICAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaWYgKCF0aGlzLl9hbGxvd0ludGVyYWN0aW9uKGV2ZW50KSkge1xcbiAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG5cXG4gICAgICAgICAgICAgIHRoaXMuX3RyYWNraW5nSW5zdGFuY2VzKClbMF0uX2ZvY3VzVGFiYmFibGUoKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLm92ZXJsYXkgPSAkKFxcXCI8ZGl2PlxcXCIpLmFkZENsYXNzKFxcXCJ1aS13aWRnZXQtb3ZlcmxheSB1aS1mcm9udFxcXCIpLmFwcGVuZFRvKHRoaXMuX2FwcGVuZFRvKCkpO1xcblxcbiAgICAgIHRoaXMuX29uKHRoaXMub3ZlcmxheSwge1xcbiAgICAgICAgbW91c2Vkb3duOiBcXFwiX2tlZXBGb2N1c1xcXCJcXG4gICAgICB9KTtcXG5cXG4gICAgICB0aGlzLmRvY3VtZW50LmRhdGEoXFxcInVpLWRpYWxvZy1vdmVybGF5c1xcXCIsICh0aGlzLmRvY3VtZW50LmRhdGEoXFxcInVpLWRpYWxvZy1vdmVybGF5c1xcXCIpIHx8IDApICsgMSk7XFxuICAgIH0sXFxuICAgIF9kZXN0cm95T3ZlcmxheTogZnVuY3Rpb24gX2Rlc3Ryb3lPdmVybGF5KCkge1xcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLm1vZGFsKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLm92ZXJsYXkpIHtcXG4gICAgICAgIHZhciBvdmVybGF5cyA9IHRoaXMuZG9jdW1lbnQuZGF0YShcXFwidWktZGlhbG9nLW92ZXJsYXlzXFxcIikgLSAxO1xcblxcbiAgICAgICAgaWYgKCFvdmVybGF5cykge1xcbiAgICAgICAgICB0aGlzLmRvY3VtZW50LnVuYmluZChcXFwiZm9jdXNpblxcXCIpLnJlbW92ZURhdGEoXFxcInVpLWRpYWxvZy1vdmVybGF5c1xcXCIpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgdGhpcy5kb2N1bWVudC5kYXRhKFxcXCJ1aS1kaWFsb2ctb3ZlcmxheXNcXFwiLCBvdmVybGF5cyk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0aGlzLm92ZXJsYXkucmVtb3ZlKCk7XFxuICAgICAgICB0aGlzLm92ZXJsYXkgPSBudWxsO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfSk7XFxuICAvKiFcXG4gICAqIGpRdWVyeSBVSSBEcm9wcGFibGUgMS4xMS40XFxuICAgKiBodHRwOi8vanF1ZXJ5dWkuY29tXFxuICAgKlxcbiAgICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcXG4gICAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cXG4gICAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcXG4gICAqXFxuICAgKiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9kcm9wcGFibGUvXFxuICAgKi9cXG5cXG4gICQud2lkZ2V0KFxcXCJ1aS5kcm9wcGFibGVcXFwiLCB7XFxuICAgIHZlcnNpb246IFxcXCIxLjExLjRcXFwiLFxcbiAgICB3aWRnZXRFdmVudFByZWZpeDogXFxcImRyb3BcXFwiLFxcbiAgICBvcHRpb25zOiB7XFxuICAgICAgYWNjZXB0OiBcXFwiKlxcXCIsXFxuICAgICAgYWN0aXZlQ2xhc3M6IGZhbHNlLFxcbiAgICAgIGFkZENsYXNzZXM6IHRydWUsXFxuICAgICAgZ3JlZWR5OiBmYWxzZSxcXG4gICAgICBob3ZlckNsYXNzOiBmYWxzZSxcXG4gICAgICBzY29wZTogXFxcImRlZmF1bHRcXFwiLFxcbiAgICAgIHRvbGVyYW5jZTogXFxcImludGVyc2VjdFxcXCIsXFxuICAgICAgLy8gY2FsbGJhY2tzXFxuICAgICAgYWN0aXZhdGU6IG51bGwsXFxuICAgICAgZGVhY3RpdmF0ZTogbnVsbCxcXG4gICAgICBkcm9wOiBudWxsLFxcbiAgICAgIG91dDogbnVsbCxcXG4gICAgICBvdmVyOiBudWxsXFxuICAgIH0sXFxuICAgIF9jcmVhdGU6IGZ1bmN0aW9uIF9jcmVhdGUoKSB7XFxuICAgICAgdmFyIHByb3BvcnRpb25zLFxcbiAgICAgICAgICBvID0gdGhpcy5vcHRpb25zLFxcbiAgICAgICAgICBhY2NlcHQgPSBvLmFjY2VwdDtcXG4gICAgICB0aGlzLmlzb3ZlciA9IGZhbHNlO1xcbiAgICAgIHRoaXMuaXNvdXQgPSB0cnVlO1xcbiAgICAgIHRoaXMuYWNjZXB0ID0gJC5pc0Z1bmN0aW9uKGFjY2VwdCkgPyBhY2NlcHQgOiBmdW5jdGlvbiAoZCkge1xcbiAgICAgICAgcmV0dXJuIGQuaXMoYWNjZXB0KTtcXG4gICAgICB9O1xcblxcbiAgICAgIHRoaXMucHJvcG9ydGlvbnMgPSBmdW5jdGlvbiAoKVxcbiAgICAgIC8qIHZhbHVlVG9Xcml0ZSAqL1xcbiAgICAgIHtcXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XFxuICAgICAgICAgIC8vIFN0b3JlIHRoZSBkcm9wcGFibGUncyBwcm9wb3J0aW9uc1xcbiAgICAgICAgICBwcm9wb3J0aW9ucyA9IGFyZ3VtZW50c1swXTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIC8vIFJldHJpZXZlIG9yIGRlcml2ZSB0aGUgZHJvcHBhYmxlJ3MgcHJvcG9ydGlvbnNcXG4gICAgICAgICAgcmV0dXJuIHByb3BvcnRpb25zID8gcHJvcG9ydGlvbnMgOiBwcm9wb3J0aW9ucyA9IHtcXG4gICAgICAgICAgICB3aWR0aDogdGhpcy5lbGVtZW50WzBdLm9mZnNldFdpZHRoLFxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5lbGVtZW50WzBdLm9mZnNldEhlaWdodFxcbiAgICAgICAgICB9O1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuXFxuICAgICAgdGhpcy5fYWRkVG9NYW5hZ2VyKG8uc2NvcGUpO1xcblxcbiAgICAgIG8uYWRkQ2xhc3NlcyAmJiB0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoXFxcInVpLWRyb3BwYWJsZVxcXCIpO1xcbiAgICB9LFxcbiAgICBfYWRkVG9NYW5hZ2VyOiBmdW5jdGlvbiBfYWRkVG9NYW5hZ2VyKHNjb3BlKSB7XFxuICAgICAgLy8gQWRkIHRoZSByZWZlcmVuY2UgYW5kIHBvc2l0aW9ucyB0byB0aGUgbWFuYWdlclxcbiAgICAgICQudWkuZGRtYW5hZ2VyLmRyb3BwYWJsZXNbc2NvcGVdID0gJC51aS5kZG1hbmFnZXIuZHJvcHBhYmxlc1tzY29wZV0gfHwgW107XFxuICAgICAgJC51aS5kZG1hbmFnZXIuZHJvcHBhYmxlc1tzY29wZV0ucHVzaCh0aGlzKTtcXG4gICAgfSxcXG4gICAgX3NwbGljZTogZnVuY3Rpb24gX3NwbGljZShkcm9wKSB7XFxuICAgICAgdmFyIGkgPSAwO1xcblxcbiAgICAgIGZvciAoOyBpIDwgZHJvcC5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgaWYgKGRyb3BbaV0gPT09IHRoaXMpIHtcXG4gICAgICAgICAgZHJvcC5zcGxpY2UoaSwgMSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9LFxcbiAgICBfZGVzdHJveTogZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XFxuICAgICAgdmFyIGRyb3AgPSAkLnVpLmRkbWFuYWdlci5kcm9wcGFibGVzW3RoaXMub3B0aW9ucy5zY29wZV07XFxuXFxuICAgICAgdGhpcy5fc3BsaWNlKGRyb3ApO1xcblxcbiAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVDbGFzcyhcXFwidWktZHJvcHBhYmxlIHVpLWRyb3BwYWJsZS1kaXNhYmxlZFxcXCIpO1xcbiAgICB9LFxcbiAgICBfc2V0T3B0aW9uOiBmdW5jdGlvbiBfc2V0T3B0aW9uKGtleSwgdmFsdWUpIHtcXG4gICAgICBpZiAoa2V5ID09PSBcXFwiYWNjZXB0XFxcIikge1xcbiAgICAgICAgdGhpcy5hY2NlcHQgPSAkLmlzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUgOiBmdW5jdGlvbiAoZCkge1xcbiAgICAgICAgICByZXR1cm4gZC5pcyh2YWx1ZSk7XFxuICAgICAgICB9O1xcbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcXFwic2NvcGVcXFwiKSB7XFxuICAgICAgICB2YXIgZHJvcCA9ICQudWkuZGRtYW5hZ2VyLmRyb3BwYWJsZXNbdGhpcy5vcHRpb25zLnNjb3BlXTtcXG5cXG4gICAgICAgIHRoaXMuX3NwbGljZShkcm9wKTtcXG5cXG4gICAgICAgIHRoaXMuX2FkZFRvTWFuYWdlcih2YWx1ZSk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX3N1cGVyKGtleSwgdmFsdWUpO1xcbiAgICB9LFxcbiAgICBfYWN0aXZhdGU6IGZ1bmN0aW9uIF9hY3RpdmF0ZShldmVudCkge1xcbiAgICAgIHZhciBkcmFnZ2FibGUgPSAkLnVpLmRkbWFuYWdlci5jdXJyZW50O1xcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYWN0aXZlQ2xhc3MpIHtcXG4gICAgICAgIHRoaXMuZWxlbWVudC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuYWN0aXZlQ2xhc3MpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoZHJhZ2dhYmxlKSB7XFxuICAgICAgICB0aGlzLl90cmlnZ2VyKFxcXCJhY3RpdmF0ZVxcXCIsIGV2ZW50LCB0aGlzLnVpKGRyYWdnYWJsZSkpO1xcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgX2RlYWN0aXZhdGU6IGZ1bmN0aW9uIF9kZWFjdGl2YXRlKGV2ZW50KSB7XFxuICAgICAgdmFyIGRyYWdnYWJsZSA9ICQudWkuZGRtYW5hZ2VyLmN1cnJlbnQ7XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hY3RpdmVDbGFzcykge1xcbiAgICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5hY3RpdmVDbGFzcyk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChkcmFnZ2FibGUpIHtcXG4gICAgICAgIHRoaXMuX3RyaWdnZXIoXFxcImRlYWN0aXZhdGVcXFwiLCBldmVudCwgdGhpcy51aShkcmFnZ2FibGUpKTtcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIF9vdmVyOiBmdW5jdGlvbiBfb3ZlcihldmVudCkge1xcbiAgICAgIHZhciBkcmFnZ2FibGUgPSAkLnVpLmRkbWFuYWdlci5jdXJyZW50OyAvLyBCYWlsIGlmIGRyYWdnYWJsZSBhbmQgZHJvcHBhYmxlIGFyZSBzYW1lIGVsZW1lbnRcXG5cXG4gICAgICBpZiAoIWRyYWdnYWJsZSB8fCAoZHJhZ2dhYmxlLmN1cnJlbnRJdGVtIHx8IGRyYWdnYWJsZS5lbGVtZW50KVswXSA9PT0gdGhpcy5lbGVtZW50WzBdKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLmFjY2VwdC5jYWxsKHRoaXMuZWxlbWVudFswXSwgZHJhZ2dhYmxlLmN1cnJlbnRJdGVtIHx8IGRyYWdnYWJsZS5lbGVtZW50KSkge1xcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ob3ZlckNsYXNzKSB7XFxuICAgICAgICAgIHRoaXMuZWxlbWVudC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuaG92ZXJDbGFzcyk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0aGlzLl90cmlnZ2VyKFxcXCJvdmVyXFxcIiwgZXZlbnQsIHRoaXMudWkoZHJhZ2dhYmxlKSk7XFxuICAgICAgfVxcbiAgICB9LFxcbiAgICBfb3V0OiBmdW5jdGlvbiBfb3V0KGV2ZW50KSB7XFxuICAgICAgdmFyIGRyYWdnYWJsZSA9ICQudWkuZGRtYW5hZ2VyLmN1cnJlbnQ7IC8vIEJhaWwgaWYgZHJhZ2dhYmxlIGFuZCBkcm9wcGFibGUgYXJlIHNhbWUgZWxlbWVudFxcblxcbiAgICAgIGlmICghZHJhZ2dhYmxlIHx8IChkcmFnZ2FibGUuY3VycmVudEl0ZW0gfHwgZHJhZ2dhYmxlLmVsZW1lbnQpWzBdID09PSB0aGlzLmVsZW1lbnRbMF0pIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMuYWNjZXB0LmNhbGwodGhpcy5lbGVtZW50WzBdLCBkcmFnZ2FibGUuY3VycmVudEl0ZW0gfHwgZHJhZ2dhYmxlLmVsZW1lbnQpKSB7XFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmhvdmVyQ2xhc3MpIHtcXG4gICAgICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5ob3ZlckNsYXNzKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHRoaXMuX3RyaWdnZXIoXFxcIm91dFxcXCIsIGV2ZW50LCB0aGlzLnVpKGRyYWdnYWJsZSkpO1xcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgX2Ryb3A6IGZ1bmN0aW9uIF9kcm9wKGV2ZW50LCBjdXN0b20pIHtcXG4gICAgICB2YXIgZHJhZ2dhYmxlID0gY3VzdG9tIHx8ICQudWkuZGRtYW5hZ2VyLmN1cnJlbnQsXFxuICAgICAgICAgIGNoaWxkcmVuSW50ZXJzZWN0aW9uID0gZmFsc2U7IC8vIEJhaWwgaWYgZHJhZ2dhYmxlIGFuZCBkcm9wcGFibGUgYXJlIHNhbWUgZWxlbWVudFxcblxcbiAgICAgIGlmICghZHJhZ2dhYmxlIHx8IChkcmFnZ2FibGUuY3VycmVudEl0ZW0gfHwgZHJhZ2dhYmxlLmVsZW1lbnQpWzBdID09PSB0aGlzLmVsZW1lbnRbMF0pIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5lbGVtZW50LmZpbmQoXFxcIjpkYXRhKHVpLWRyb3BwYWJsZSlcXFwiKS5ub3QoXFxcIi51aS1kcmFnZ2FibGUtZHJhZ2dpbmdcXFwiKS5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciBpbnN0ID0gJCh0aGlzKS5kcm9wcGFibGUoXFxcImluc3RhbmNlXFxcIik7XFxuXFxuICAgICAgICBpZiAoaW5zdC5vcHRpb25zLmdyZWVkeSAmJiAhaW5zdC5vcHRpb25zLmRpc2FibGVkICYmIGluc3Qub3B0aW9ucy5zY29wZSA9PT0gZHJhZ2dhYmxlLm9wdGlvbnMuc2NvcGUgJiYgaW5zdC5hY2NlcHQuY2FsbChpbnN0LmVsZW1lbnRbMF0sIGRyYWdnYWJsZS5jdXJyZW50SXRlbSB8fCBkcmFnZ2FibGUuZWxlbWVudCkgJiYgJC51aS5pbnRlcnNlY3QoZHJhZ2dhYmxlLCAkLmV4dGVuZChpbnN0LCB7XFxuICAgICAgICAgIG9mZnNldDogaW5zdC5lbGVtZW50Lm9mZnNldCgpXFxuICAgICAgICB9KSwgaW5zdC5vcHRpb25zLnRvbGVyYW5jZSwgZXZlbnQpKSB7XFxuICAgICAgICAgIGNoaWxkcmVuSW50ZXJzZWN0aW9uID0gdHJ1ZTtcXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcblxcbiAgICAgIGlmIChjaGlsZHJlbkludGVyc2VjdGlvbikge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5hY2NlcHQuY2FsbCh0aGlzLmVsZW1lbnRbMF0sIGRyYWdnYWJsZS5jdXJyZW50SXRlbSB8fCBkcmFnZ2FibGUuZWxlbWVudCkpIHtcXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYWN0aXZlQ2xhc3MpIHtcXG4gICAgICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5hY3RpdmVDbGFzcyk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmhvdmVyQ2xhc3MpIHtcXG4gICAgICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5ob3ZlckNsYXNzKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHRoaXMuX3RyaWdnZXIoXFxcImRyb3BcXFwiLCBldmVudCwgdGhpcy51aShkcmFnZ2FibGUpKTtcXG5cXG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQ7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfSxcXG4gICAgdWk6IGZ1bmN0aW9uIHVpKGMpIHtcXG4gICAgICByZXR1cm4ge1xcbiAgICAgICAgZHJhZ2dhYmxlOiBjLmN1cnJlbnRJdGVtIHx8IGMuZWxlbWVudCxcXG4gICAgICAgIGhlbHBlcjogYy5oZWxwZXIsXFxuICAgICAgICBwb3NpdGlvbjogYy5wb3NpdGlvbixcXG4gICAgICAgIG9mZnNldDogYy5wb3NpdGlvbkFic1xcbiAgICAgIH07XFxuICAgIH1cXG4gIH0pO1xcblxcbiAgJC51aS5pbnRlcnNlY3QgPSBmdW5jdGlvbiAoKSB7XFxuICAgIGZ1bmN0aW9uIGlzT3ZlckF4aXMoeCwgcmVmZXJlbmNlLCBzaXplKSB7XFxuICAgICAgcmV0dXJuIHggPj0gcmVmZXJlbmNlICYmIHggPCByZWZlcmVuY2UgKyBzaXplO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBmdW5jdGlvbiAoZHJhZ2dhYmxlLCBkcm9wcGFibGUsIHRvbGVyYW5jZU1vZGUsIGV2ZW50KSB7XFxuICAgICAgaWYgKCFkcm9wcGFibGUub2Zmc2V0KSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciB4MSA9IChkcmFnZ2FibGUucG9zaXRpb25BYnMgfHwgZHJhZ2dhYmxlLnBvc2l0aW9uLmFic29sdXRlKS5sZWZ0ICsgZHJhZ2dhYmxlLm1hcmdpbnMubGVmdCxcXG4gICAgICAgICAgeTEgPSAoZHJhZ2dhYmxlLnBvc2l0aW9uQWJzIHx8IGRyYWdnYWJsZS5wb3NpdGlvbi5hYnNvbHV0ZSkudG9wICsgZHJhZ2dhYmxlLm1hcmdpbnMudG9wLFxcbiAgICAgICAgICB4MiA9IHgxICsgZHJhZ2dhYmxlLmhlbHBlclByb3BvcnRpb25zLndpZHRoLFxcbiAgICAgICAgICB5MiA9IHkxICsgZHJhZ2dhYmxlLmhlbHBlclByb3BvcnRpb25zLmhlaWdodCxcXG4gICAgICAgICAgbCA9IGRyb3BwYWJsZS5vZmZzZXQubGVmdCxcXG4gICAgICAgICAgdCA9IGRyb3BwYWJsZS5vZmZzZXQudG9wLFxcbiAgICAgICAgICByID0gbCArIGRyb3BwYWJsZS5wcm9wb3J0aW9ucygpLndpZHRoLFxcbiAgICAgICAgICBiID0gdCArIGRyb3BwYWJsZS5wcm9wb3J0aW9ucygpLmhlaWdodDtcXG5cXG4gICAgICBzd2l0Y2ggKHRvbGVyYW5jZU1vZGUpIHtcXG4gICAgICAgIGNhc2UgXFxcImZpdFxcXCI6XFxuICAgICAgICAgIHJldHVybiBsIDw9IHgxICYmIHgyIDw9IHIgJiYgdCA8PSB5MSAmJiB5MiA8PSBiO1xcblxcbiAgICAgICAgY2FzZSBcXFwiaW50ZXJzZWN0XFxcIjpcXG4gICAgICAgICAgcmV0dXJuIGwgPCB4MSArIGRyYWdnYWJsZS5oZWxwZXJQcm9wb3J0aW9ucy53aWR0aCAvIDIgJiYgLy8gUmlnaHQgSGFsZlxcbiAgICAgICAgICB4MiAtIGRyYWdnYWJsZS5oZWxwZXJQcm9wb3J0aW9ucy53aWR0aCAvIDIgPCByICYmIC8vIExlZnQgSGFsZlxcbiAgICAgICAgICB0IDwgeTEgKyBkcmFnZ2FibGUuaGVscGVyUHJvcG9ydGlvbnMuaGVpZ2h0IC8gMiAmJiAvLyBCb3R0b20gSGFsZlxcbiAgICAgICAgICB5MiAtIGRyYWdnYWJsZS5oZWxwZXJQcm9wb3J0aW9ucy5oZWlnaHQgLyAyIDwgYjtcXG4gICAgICAgIC8vIFRvcCBIYWxmXFxuXFxuICAgICAgICBjYXNlIFxcXCJwb2ludGVyXFxcIjpcXG4gICAgICAgICAgcmV0dXJuIGlzT3ZlckF4aXMoZXZlbnQucGFnZVksIHQsIGRyb3BwYWJsZS5wcm9wb3J0aW9ucygpLmhlaWdodCkgJiYgaXNPdmVyQXhpcyhldmVudC5wYWdlWCwgbCwgZHJvcHBhYmxlLnByb3BvcnRpb25zKCkud2lkdGgpO1xcblxcbiAgICAgICAgY2FzZSBcXFwidG91Y2hcXFwiOlxcbiAgICAgICAgICByZXR1cm4gKHkxID49IHQgJiYgeTEgPD0gYiB8fCAvLyBUb3AgZWRnZSB0b3VjaGluZ1xcbiAgICAgICAgICB5MiA+PSB0ICYmIHkyIDw9IGIgfHwgLy8gQm90dG9tIGVkZ2UgdG91Y2hpbmdcXG4gICAgICAgICAgeTEgPCB0ICYmIHkyID4gYiAvLyBTdXJyb3VuZGVkIHZlcnRpY2FsbHlcXG4gICAgICAgICAgKSAmJiAoeDEgPj0gbCAmJiB4MSA8PSByIHx8IC8vIExlZnQgZWRnZSB0b3VjaGluZ1xcbiAgICAgICAgICB4MiA+PSBsICYmIHgyIDw9IHIgfHwgLy8gUmlnaHQgZWRnZSB0b3VjaGluZ1xcbiAgICAgICAgICB4MSA8IGwgJiYgeDIgPiByIC8vIFN1cnJvdW5kZWQgaG9yaXpvbnRhbGx5XFxuICAgICAgICAgICk7XFxuXFxuICAgICAgICBkZWZhdWx0OlxcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcbiAgICB9O1xcbiAgfSgpO1xcbiAgLypcXG4gIFxcdFRoaXMgbWFuYWdlciB0cmFja3Mgb2Zmc2V0cyBvZiBkcmFnZ2FibGVzIGFuZCBkcm9wcGFibGVzXFxuICAqL1xcblxcblxcbiAgJC51aS5kZG1hbmFnZXIgPSB7XFxuICAgIGN1cnJlbnQ6IG51bGwsXFxuICAgIGRyb3BwYWJsZXM6IHtcXG4gICAgICBcXFwiZGVmYXVsdFxcXCI6IFtdXFxuICAgIH0sXFxuICAgIHByZXBhcmVPZmZzZXRzOiBmdW5jdGlvbiBwcmVwYXJlT2Zmc2V0cyh0LCBldmVudCkge1xcbiAgICAgIHZhciBpLFxcbiAgICAgICAgICBqLFxcbiAgICAgICAgICBtID0gJC51aS5kZG1hbmFnZXIuZHJvcHBhYmxlc1t0Lm9wdGlvbnMuc2NvcGVdIHx8IFtdLFxcbiAgICAgICAgICB0eXBlID0gZXZlbnQgPyBldmVudC50eXBlIDogbnVsbCxcXG4gICAgICAgICAgLy8gd29ya2Fyb3VuZCBmb3IgIzIzMTdcXG4gICAgICBsaXN0ID0gKHQuY3VycmVudEl0ZW0gfHwgdC5lbGVtZW50KS5maW5kKFxcXCI6ZGF0YSh1aS1kcm9wcGFibGUpXFxcIikuYWRkQmFjaygpO1xcblxcbiAgICAgIGRyb3BwYWJsZXNMb29wOiBmb3IgKGkgPSAwOyBpIDwgbS5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgLy8gTm8gZGlzYWJsZWQgYW5kIG5vbi1hY2NlcHRlZFxcbiAgICAgICAgaWYgKG1baV0ub3B0aW9ucy5kaXNhYmxlZCB8fCB0ICYmICFtW2ldLmFjY2VwdC5jYWxsKG1baV0uZWxlbWVudFswXSwgdC5jdXJyZW50SXRlbSB8fCB0LmVsZW1lbnQpKSB7XFxuICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgfSAvLyBGaWx0ZXIgb3V0IGVsZW1lbnRzIGluIHRoZSBjdXJyZW50IGRyYWdnZWQgaXRlbVxcblxcblxcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGxpc3QubGVuZ3RoOyBqKyspIHtcXG4gICAgICAgICAgaWYgKGxpc3Rbal0gPT09IG1baV0uZWxlbWVudFswXSkge1xcbiAgICAgICAgICAgIG1baV0ucHJvcG9ydGlvbnMoKS5oZWlnaHQgPSAwO1xcbiAgICAgICAgICAgIGNvbnRpbnVlIGRyb3BwYWJsZXNMb29wO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICBtW2ldLnZpc2libGUgPSBtW2ldLmVsZW1lbnQuY3NzKFxcXCJkaXNwbGF5XFxcIikgIT09IFxcXCJub25lXFxcIjtcXG5cXG4gICAgICAgIGlmICghbVtpXS52aXNpYmxlKSB7XFxuICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgfSAvLyBBY3RpdmF0ZSB0aGUgZHJvcHBhYmxlIGlmIHVzZWQgZGlyZWN0bHkgZnJvbSBkcmFnZ2FibGVzXFxuXFxuXFxuICAgICAgICBpZiAodHlwZSA9PT0gXFxcIm1vdXNlZG93blxcXCIpIHtcXG4gICAgICAgICAgbVtpXS5fYWN0aXZhdGUuY2FsbChtW2ldLCBldmVudCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBtW2ldLm9mZnNldCA9IG1baV0uZWxlbWVudC5vZmZzZXQoKTtcXG4gICAgICAgIG1baV0ucHJvcG9ydGlvbnMoe1xcbiAgICAgICAgICB3aWR0aDogbVtpXS5lbGVtZW50WzBdLm9mZnNldFdpZHRoLFxcbiAgICAgICAgICBoZWlnaHQ6IG1baV0uZWxlbWVudFswXS5vZmZzZXRIZWlnaHRcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgZHJvcDogZnVuY3Rpb24gZHJvcChkcmFnZ2FibGUsIGV2ZW50KSB7XFxuICAgICAgdmFyIGRyb3BwZWQgPSBmYWxzZTsgLy8gQ3JlYXRlIGEgY29weSBvZiB0aGUgZHJvcHBhYmxlcyBpbiBjYXNlIHRoZSBsaXN0IGNoYW5nZXMgZHVyaW5nIHRoZSBkcm9wICgjOTExNilcXG5cXG4gICAgICAkLmVhY2goKCQudWkuZGRtYW5hZ2VyLmRyb3BwYWJsZXNbZHJhZ2dhYmxlLm9wdGlvbnMuc2NvcGVdIHx8IFtdKS5zbGljZSgpLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucykge1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5kaXNhYmxlZCAmJiB0aGlzLnZpc2libGUgJiYgJC51aS5pbnRlcnNlY3QoZHJhZ2dhYmxlLCB0aGlzLCB0aGlzLm9wdGlvbnMudG9sZXJhbmNlLCBldmVudCkpIHtcXG4gICAgICAgICAgZHJvcHBlZCA9IHRoaXMuX2Ryb3AuY2FsbCh0aGlzLCBldmVudCkgfHwgZHJvcHBlZDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmRpc2FibGVkICYmIHRoaXMudmlzaWJsZSAmJiB0aGlzLmFjY2VwdC5jYWxsKHRoaXMuZWxlbWVudFswXSwgZHJhZ2dhYmxlLmN1cnJlbnRJdGVtIHx8IGRyYWdnYWJsZS5lbGVtZW50KSkge1xcbiAgICAgICAgICB0aGlzLmlzb3V0ID0gdHJ1ZTtcXG4gICAgICAgICAgdGhpcy5pc292ZXIgPSBmYWxzZTtcXG5cXG4gICAgICAgICAgdGhpcy5fZGVhY3RpdmF0ZS5jYWxsKHRoaXMsIGV2ZW50KTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgICByZXR1cm4gZHJvcHBlZDtcXG4gICAgfSxcXG4gICAgZHJhZ1N0YXJ0OiBmdW5jdGlvbiBkcmFnU3RhcnQoZHJhZ2dhYmxlLCBldmVudCkge1xcbiAgICAgIC8vIExpc3RlbiBmb3Igc2Nyb2xsaW5nIHNvIHRoYXQgaWYgdGhlIGRyYWdnaW5nIGNhdXNlcyBzY3JvbGxpbmcgdGhlIHBvc2l0aW9uIG9mIHRoZSBkcm9wcGFibGVzIGNhbiBiZSByZWNhbGN1bGF0ZWQgKHNlZSAjNTAwMylcXG4gICAgICBkcmFnZ2FibGUuZWxlbWVudC5wYXJlbnRzVW50aWwoXFxcImJvZHlcXFwiKS5iaW5kKFxcXCJzY3JvbGwuZHJvcHBhYmxlXFxcIiwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgaWYgKCFkcmFnZ2FibGUub3B0aW9ucy5yZWZyZXNoUG9zaXRpb25zKSB7XFxuICAgICAgICAgICQudWkuZGRtYW5hZ2VyLnByZXBhcmVPZmZzZXRzKGRyYWdnYWJsZSwgZXZlbnQpO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcbiAgICB9LFxcbiAgICBkcmFnOiBmdW5jdGlvbiBkcmFnKGRyYWdnYWJsZSwgZXZlbnQpIHtcXG4gICAgICAvLyBJZiB5b3UgaGF2ZSBhIGhpZ2hseSBkeW5hbWljIHBhZ2UsIHlvdSBtaWdodCB0cnkgdGhpcyBvcHRpb24uIEl0IHJlbmRlcnMgcG9zaXRpb25zIGV2ZXJ5IHRpbWUgeW91IG1vdmUgdGhlIG1vdXNlLlxcbiAgICAgIGlmIChkcmFnZ2FibGUub3B0aW9ucy5yZWZyZXNoUG9zaXRpb25zKSB7XFxuICAgICAgICAkLnVpLmRkbWFuYWdlci5wcmVwYXJlT2Zmc2V0cyhkcmFnZ2FibGUsIGV2ZW50KTtcXG4gICAgICB9IC8vIFJ1biB0aHJvdWdoIGFsbCBkcm9wcGFibGVzIGFuZCBjaGVjayB0aGVpciBwb3NpdGlvbnMgYmFzZWQgb24gc3BlY2lmaWMgdG9sZXJhbmNlIG9wdGlvbnNcXG5cXG5cXG4gICAgICAkLmVhY2goJC51aS5kZG1hbmFnZXIuZHJvcHBhYmxlc1tkcmFnZ2FibGUub3B0aW9ucy5zY29wZV0gfHwgW10sIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGlzYWJsZWQgfHwgdGhpcy5ncmVlZHlDaGlsZCB8fCAhdGhpcy52aXNpYmxlKSB7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHZhciBwYXJlbnRJbnN0YW5jZSxcXG4gICAgICAgICAgICBzY29wZSxcXG4gICAgICAgICAgICBwYXJlbnQsXFxuICAgICAgICAgICAgaW50ZXJzZWN0cyA9ICQudWkuaW50ZXJzZWN0KGRyYWdnYWJsZSwgdGhpcywgdGhpcy5vcHRpb25zLnRvbGVyYW5jZSwgZXZlbnQpLFxcbiAgICAgICAgICAgIGMgPSAhaW50ZXJzZWN0cyAmJiB0aGlzLmlzb3ZlciA/IFxcXCJpc291dFxcXCIgOiBpbnRlcnNlY3RzICYmICF0aGlzLmlzb3ZlciA/IFxcXCJpc292ZXJcXFwiIDogbnVsbDtcXG5cXG4gICAgICAgIGlmICghYykge1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmdyZWVkeSkge1xcbiAgICAgICAgICAvLyBmaW5kIGRyb3BwYWJsZSBwYXJlbnRzIHdpdGggc2FtZSBzY29wZVxcbiAgICAgICAgICBzY29wZSA9IHRoaXMub3B0aW9ucy5zY29wZTtcXG4gICAgICAgICAgcGFyZW50ID0gdGhpcy5lbGVtZW50LnBhcmVudHMoXFxcIjpkYXRhKHVpLWRyb3BwYWJsZSlcXFwiKS5maWx0ZXIoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIHJldHVybiAkKHRoaXMpLmRyb3BwYWJsZShcXFwiaW5zdGFuY2VcXFwiKS5vcHRpb25zLnNjb3BlID09PSBzY29wZTtcXG4gICAgICAgICAgfSk7XFxuXFxuICAgICAgICAgIGlmIChwYXJlbnQubGVuZ3RoKSB7XFxuICAgICAgICAgICAgcGFyZW50SW5zdGFuY2UgPSAkKHBhcmVudFswXSkuZHJvcHBhYmxlKFxcXCJpbnN0YW5jZVxcXCIpO1xcbiAgICAgICAgICAgIHBhcmVudEluc3RhbmNlLmdyZWVkeUNoaWxkID0gYyA9PT0gXFxcImlzb3ZlclxcXCI7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gLy8gd2UganVzdCBtb3ZlZCBpbnRvIGEgZ3JlZWR5IGNoaWxkXFxuXFxuXFxuICAgICAgICBpZiAocGFyZW50SW5zdGFuY2UgJiYgYyA9PT0gXFxcImlzb3ZlclxcXCIpIHtcXG4gICAgICAgICAgcGFyZW50SW5zdGFuY2UuaXNvdmVyID0gZmFsc2U7XFxuICAgICAgICAgIHBhcmVudEluc3RhbmNlLmlzb3V0ID0gdHJ1ZTtcXG5cXG4gICAgICAgICAgcGFyZW50SW5zdGFuY2UuX291dC5jYWxsKHBhcmVudEluc3RhbmNlLCBldmVudCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0aGlzW2NdID0gdHJ1ZTtcXG4gICAgICAgIHRoaXNbYyA9PT0gXFxcImlzb3V0XFxcIiA/IFxcXCJpc292ZXJcXFwiIDogXFxcImlzb3V0XFxcIl0gPSBmYWxzZTtcXG4gICAgICAgIHRoaXNbYyA9PT0gXFxcImlzb3ZlclxcXCIgPyBcXFwiX292ZXJcXFwiIDogXFxcIl9vdXRcXFwiXS5jYWxsKHRoaXMsIGV2ZW50KTsgLy8gd2UganVzdCBtb3ZlZCBvdXQgb2YgYSBncmVlZHkgY2hpbGRcXG5cXG4gICAgICAgIGlmIChwYXJlbnRJbnN0YW5jZSAmJiBjID09PSBcXFwiaXNvdXRcXFwiKSB7XFxuICAgICAgICAgIHBhcmVudEluc3RhbmNlLmlzb3V0ID0gZmFsc2U7XFxuICAgICAgICAgIHBhcmVudEluc3RhbmNlLmlzb3ZlciA9IHRydWU7XFxuXFxuICAgICAgICAgIHBhcmVudEluc3RhbmNlLl9vdmVyLmNhbGwocGFyZW50SW5zdGFuY2UsIGV2ZW50KTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgfSxcXG4gICAgZHJhZ1N0b3A6IGZ1bmN0aW9uIGRyYWdTdG9wKGRyYWdnYWJsZSwgZXZlbnQpIHtcXG4gICAgICBkcmFnZ2FibGUuZWxlbWVudC5wYXJlbnRzVW50aWwoXFxcImJvZHlcXFwiKS51bmJpbmQoXFxcInNjcm9sbC5kcm9wcGFibGVcXFwiKTsgLy8gQ2FsbCBwcmVwYXJlT2Zmc2V0cyBvbmUgZmluYWwgdGltZSBzaW5jZSBJRSBkb2VzIG5vdCBmaXJlIHJldHVybiBzY3JvbGwgZXZlbnRzIHdoZW4gb3ZlcmZsb3cgd2FzIGNhdXNlZCBieSBkcmFnIChzZWUgIzUwMDMpXFxuXFxuICAgICAgaWYgKCFkcmFnZ2FibGUub3B0aW9ucy5yZWZyZXNoUG9zaXRpb25zKSB7XFxuICAgICAgICAkLnVpLmRkbWFuYWdlci5wcmVwYXJlT2Zmc2V0cyhkcmFnZ2FibGUsIGV2ZW50KTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH07XFxuICB2YXIgZHJvcHBhYmxlID0gJC51aS5kcm9wcGFibGU7XFxuICAvKiFcXG4gICAqIGpRdWVyeSBVSSBFZmZlY3RzIDEuMTEuNFxcbiAgICogaHR0cDovL2pxdWVyeXVpLmNvbVxcbiAgICpcXG4gICAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXFxuICAgKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXFxuICAgKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXFxuICAgKlxcbiAgICogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20vY2F0ZWdvcnkvZWZmZWN0cy1jb3JlL1xcbiAgICovXFxuXFxuICB2YXIgZGF0YVNwYWNlID0gXFxcInVpLWVmZmVjdHMtXFxcIixcXG4gICAgICAvLyBDcmVhdGUgYSBsb2NhbCBqUXVlcnkgYmVjYXVzZSBqUXVlcnkgQ29sb3IgcmVsaWVzIG9uIGl0IGFuZCB0aGVcXG4gIC8vIGdsb2JhbCBtYXkgbm90IGV4aXN0IHdpdGggQU1EIGFuZCBhIGN1c3RvbSBidWlsZCAoIzEwMTk5KVxcbiAgalF1ZXJ5ID0gJDtcXG4gICQuZWZmZWN0cyA9IHtcXG4gICAgZWZmZWN0OiB7fVxcbiAgfTtcXG4gIC8qIVxcbiAgICogalF1ZXJ5IENvbG9yIEFuaW1hdGlvbnMgdjIuMS4yXFxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS1jb2xvclxcbiAgICpcXG4gICAqIENvcHlyaWdodCAyMDE0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcXG4gICAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cXG4gICAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcXG4gICAqXFxuICAgKiBEYXRlOiBXZWQgSmFuIDE2IDA4OjQ3OjA5IDIwMTMgLTA2MDBcXG4gICAqL1xcblxcbiAgKGZ1bmN0aW9uIChqUXVlcnksIHVuZGVmaW5lZCkge1xcbiAgICB2YXIgc3RlcEhvb2tzID0gXFxcImJhY2tncm91bmRDb2xvciBib3JkZXJCb3R0b21Db2xvciBib3JkZXJMZWZ0Q29sb3IgYm9yZGVyUmlnaHRDb2xvciBib3JkZXJUb3BDb2xvciBjb2xvciBjb2x1bW5SdWxlQ29sb3Igb3V0bGluZUNvbG9yIHRleHREZWNvcmF0aW9uQ29sb3IgdGV4dEVtcGhhc2lzQ29sb3JcXFwiLFxcbiAgICAgICAgLy8gcGx1c2VxdWFscyB0ZXN0IGZvciArPSAxMDAgLT0gMTAwXFxuICAgIHJwbHVzZXF1YWxzID0gL14oW1xcXFwtK10pPVxcXFxzKihcXFxcZCtcXFxcLj9cXFxcZCopLyxcXG4gICAgICAgIC8vIGEgc2V0IG9mIFJFJ3MgdGhhdCBjYW4gbWF0Y2ggc3RyaW5ncyBhbmQgZ2VuZXJhdGUgY29sb3IgdHVwbGVzLlxcbiAgICBzdHJpbmdQYXJzZXJzID0gW3tcXG4gICAgICByZTogL3JnYmE/XFxcXChcXFxccyooXFxcXGR7MSwzfSlcXFxccyosXFxcXHMqKFxcXFxkezEsM30pXFxcXHMqLFxcXFxzKihcXFxcZHsxLDN9KVxcXFxzKig/OixcXFxccyooXFxcXGQ/KD86XFxcXC5cXFxcZCspPylcXFxccyopP1xcXFwpLyxcXG4gICAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2UoZXhlY1Jlc3VsdCkge1xcbiAgICAgICAgcmV0dXJuIFtleGVjUmVzdWx0WzFdLCBleGVjUmVzdWx0WzJdLCBleGVjUmVzdWx0WzNdLCBleGVjUmVzdWx0WzRdXTtcXG4gICAgICB9XFxuICAgIH0sIHtcXG4gICAgICByZTogL3JnYmE/XFxcXChcXFxccyooXFxcXGQrKD86XFxcXC5cXFxcZCspPylcXFxcJVxcXFxzKixcXFxccyooXFxcXGQrKD86XFxcXC5cXFxcZCspPylcXFxcJVxcXFxzKixcXFxccyooXFxcXGQrKD86XFxcXC5cXFxcZCspPylcXFxcJVxcXFxzKig/OixcXFxccyooXFxcXGQ/KD86XFxcXC5cXFxcZCspPylcXFxccyopP1xcXFwpLyxcXG4gICAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2UoZXhlY1Jlc3VsdCkge1xcbiAgICAgICAgcmV0dXJuIFtleGVjUmVzdWx0WzFdICogMi41NSwgZXhlY1Jlc3VsdFsyXSAqIDIuNTUsIGV4ZWNSZXN1bHRbM10gKiAyLjU1LCBleGVjUmVzdWx0WzRdXTtcXG4gICAgICB9XFxuICAgIH0sIHtcXG4gICAgICAvLyB0aGlzIHJlZ2V4IGlnbm9yZXMgQS1GIGJlY2F1c2UgaXQncyBjb21wYXJlZCBhZ2FpbnN0IGFuIGFscmVhZHkgbG93ZXJjYXNlZCBzdHJpbmdcXG4gICAgICByZTogLyMoW2EtZjAtOV17Mn0pKFthLWYwLTldezJ9KShbYS1mMC05XXsyfSkvLFxcbiAgICAgIHBhcnNlOiBmdW5jdGlvbiBwYXJzZShleGVjUmVzdWx0KSB7XFxuICAgICAgICByZXR1cm4gW3BhcnNlSW50KGV4ZWNSZXN1bHRbMV0sIDE2KSwgcGFyc2VJbnQoZXhlY1Jlc3VsdFsyXSwgMTYpLCBwYXJzZUludChleGVjUmVzdWx0WzNdLCAxNildO1xcbiAgICAgIH1cXG4gICAgfSwge1xcbiAgICAgIC8vIHRoaXMgcmVnZXggaWdub3JlcyBBLUYgYmVjYXVzZSBpdCdzIGNvbXBhcmVkIGFnYWluc3QgYW4gYWxyZWFkeSBsb3dlcmNhc2VkIHN0cmluZ1xcbiAgICAgIHJlOiAvIyhbYS1mMC05XSkoW2EtZjAtOV0pKFthLWYwLTldKS8sXFxuICAgICAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlKGV4ZWNSZXN1bHQpIHtcXG4gICAgICAgIHJldHVybiBbcGFyc2VJbnQoZXhlY1Jlc3VsdFsxXSArIGV4ZWNSZXN1bHRbMV0sIDE2KSwgcGFyc2VJbnQoZXhlY1Jlc3VsdFsyXSArIGV4ZWNSZXN1bHRbMl0sIDE2KSwgcGFyc2VJbnQoZXhlY1Jlc3VsdFszXSArIGV4ZWNSZXN1bHRbM10sIDE2KV07XFxuICAgICAgfVxcbiAgICB9LCB7XFxuICAgICAgcmU6IC9oc2xhP1xcXFwoXFxcXHMqKFxcXFxkKyg/OlxcXFwuXFxcXGQrKT8pXFxcXHMqLFxcXFxzKihcXFxcZCsoPzpcXFxcLlxcXFxkKyk/KVxcXFwlXFxcXHMqLFxcXFxzKihcXFxcZCsoPzpcXFxcLlxcXFxkKyk/KVxcXFwlXFxcXHMqKD86LFxcXFxzKihcXFxcZD8oPzpcXFxcLlxcXFxkKyk/KVxcXFxzKik/XFxcXCkvLFxcbiAgICAgIHNwYWNlOiBcXFwiaHNsYVxcXCIsXFxuICAgICAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlKGV4ZWNSZXN1bHQpIHtcXG4gICAgICAgIHJldHVybiBbZXhlY1Jlc3VsdFsxXSwgZXhlY1Jlc3VsdFsyXSAvIDEwMCwgZXhlY1Jlc3VsdFszXSAvIDEwMCwgZXhlY1Jlc3VsdFs0XV07XFxuICAgICAgfVxcbiAgICB9XSxcXG4gICAgICAgIC8vIGpRdWVyeS5Db2xvciggKVxcbiAgICBjb2xvciA9IGpRdWVyeS5Db2xvciA9IGZ1bmN0aW9uIChjb2xvciwgZ3JlZW4sIGJsdWUsIGFscGhhKSB7XFxuICAgICAgcmV0dXJuIG5ldyBqUXVlcnkuQ29sb3IuZm4ucGFyc2UoY29sb3IsIGdyZWVuLCBibHVlLCBhbHBoYSk7XFxuICAgIH0sXFxuICAgICAgICBzcGFjZXMgPSB7XFxuICAgICAgcmdiYToge1xcbiAgICAgICAgcHJvcHM6IHtcXG4gICAgICAgICAgcmVkOiB7XFxuICAgICAgICAgICAgaWR4OiAwLFxcbiAgICAgICAgICAgIHR5cGU6IFxcXCJieXRlXFxcIlxcbiAgICAgICAgICB9LFxcbiAgICAgICAgICBncmVlbjoge1xcbiAgICAgICAgICAgIGlkeDogMSxcXG4gICAgICAgICAgICB0eXBlOiBcXFwiYnl0ZVxcXCJcXG4gICAgICAgICAgfSxcXG4gICAgICAgICAgYmx1ZToge1xcbiAgICAgICAgICAgIGlkeDogMixcXG4gICAgICAgICAgICB0eXBlOiBcXFwiYnl0ZVxcXCJcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH0sXFxuICAgICAgaHNsYToge1xcbiAgICAgICAgcHJvcHM6IHtcXG4gICAgICAgICAgaHVlOiB7XFxuICAgICAgICAgICAgaWR4OiAwLFxcbiAgICAgICAgICAgIHR5cGU6IFxcXCJkZWdyZWVzXFxcIlxcbiAgICAgICAgICB9LFxcbiAgICAgICAgICBzYXR1cmF0aW9uOiB7XFxuICAgICAgICAgICAgaWR4OiAxLFxcbiAgICAgICAgICAgIHR5cGU6IFxcXCJwZXJjZW50XFxcIlxcbiAgICAgICAgICB9LFxcbiAgICAgICAgICBsaWdodG5lc3M6IHtcXG4gICAgICAgICAgICBpZHg6IDIsXFxuICAgICAgICAgICAgdHlwZTogXFxcInBlcmNlbnRcXFwiXFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH0sXFxuICAgICAgICBwcm9wVHlwZXMgPSB7XFxuICAgICAgXFxcImJ5dGVcXFwiOiB7XFxuICAgICAgICBmbG9vcjogdHJ1ZSxcXG4gICAgICAgIG1heDogMjU1XFxuICAgICAgfSxcXG4gICAgICBcXFwicGVyY2VudFxcXCI6IHtcXG4gICAgICAgIG1heDogMVxcbiAgICAgIH0sXFxuICAgICAgXFxcImRlZ3JlZXNcXFwiOiB7XFxuICAgICAgICBtb2Q6IDM2MCxcXG4gICAgICAgIGZsb29yOiB0cnVlXFxuICAgICAgfVxcbiAgICB9LFxcbiAgICAgICAgc3VwcG9ydCA9IGNvbG9yLnN1cHBvcnQgPSB7fSxcXG4gICAgICAgIC8vIGVsZW1lbnQgZm9yIHN1cHBvcnQgdGVzdHNcXG4gICAgc3VwcG9ydEVsZW0gPSBqUXVlcnkoXFxcIjxwPlxcXCIpWzBdLFxcbiAgICAgICAgLy8gY29sb3JzID0galF1ZXJ5LkNvbG9yLm5hbWVzXFxuICAgIGNvbG9ycyxcXG4gICAgICAgIC8vIGxvY2FsIGFsaWFzZXMgb2YgZnVuY3Rpb25zIGNhbGxlZCBvZnRlblxcbiAgICBlYWNoID0galF1ZXJ5LmVhY2g7IC8vIGRldGVybWluZSByZ2JhIHN1cHBvcnQgaW1tZWRpYXRlbHlcXG5cXG5cXG4gICAgc3VwcG9ydEVsZW0uc3R5bGUuY3NzVGV4dCA9IFxcXCJiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMSwxLDEsLjUpXFxcIjtcXG4gICAgc3VwcG9ydC5yZ2JhID0gc3VwcG9ydEVsZW0uc3R5bGUuYmFja2dyb3VuZENvbG9yLmluZGV4T2YoXFxcInJnYmFcXFwiKSA+IC0xOyAvLyBkZWZpbmUgY2FjaGUgbmFtZSBhbmQgYWxwaGEgcHJvcGVydGllc1xcbiAgICAvLyBmb3IgcmdiYSBhbmQgaHNsYSBzcGFjZXNcXG5cXG4gICAgZWFjaChzcGFjZXMsIGZ1bmN0aW9uIChzcGFjZU5hbWUsIHNwYWNlKSB7XFxuICAgICAgc3BhY2UuY2FjaGUgPSBcXFwiX1xcXCIgKyBzcGFjZU5hbWU7XFxuICAgICAgc3BhY2UucHJvcHMuYWxwaGEgPSB7XFxuICAgICAgICBpZHg6IDMsXFxuICAgICAgICB0eXBlOiBcXFwicGVyY2VudFxcXCIsXFxuICAgICAgICBkZWY6IDFcXG4gICAgICB9O1xcbiAgICB9KTtcXG5cXG4gICAgZnVuY3Rpb24gY2xhbXAodmFsdWUsIHByb3AsIGFsbG93RW1wdHkpIHtcXG4gICAgICB2YXIgdHlwZSA9IHByb3BUeXBlc1twcm9wLnR5cGVdIHx8IHt9O1xcblxcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XFxuICAgICAgICByZXR1cm4gYWxsb3dFbXB0eSB8fCAhcHJvcC5kZWYgPyBudWxsIDogcHJvcC5kZWY7XFxuICAgICAgfSAvLyB+fiBpcyBhbiBzaG9ydCB3YXkgb2YgZG9pbmcgZmxvb3IgZm9yIHBvc2l0aXZlIG51bWJlcnNcXG5cXG5cXG4gICAgICB2YWx1ZSA9IHR5cGUuZmxvb3IgPyB+fnZhbHVlIDogcGFyc2VGbG9hdCh2YWx1ZSk7IC8vIElFIHdpbGwgcGFzcyBpbiBlbXB0eSBzdHJpbmdzIGFzIHZhbHVlIGZvciBhbHBoYSxcXG4gICAgICAvLyB3aGljaCB3aWxsIGhpdCB0aGlzIGNhc2VcXG5cXG4gICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XFxuICAgICAgICByZXR1cm4gcHJvcC5kZWY7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0eXBlLm1vZCkge1xcbiAgICAgICAgLy8gd2UgYWRkIG1vZCBiZWZvcmUgbW9kZGluZyB0byBtYWtlIHN1cmUgdGhhdCBuZWdhdGl2ZXMgdmFsdWVzXFxuICAgICAgICAvLyBnZXQgY29udmVydGVkIHByb3Blcmx5OiAtMTAgLT4gMzUwXFxuICAgICAgICByZXR1cm4gKHZhbHVlICsgdHlwZS5tb2QpICUgdHlwZS5tb2Q7XFxuICAgICAgfSAvLyBmb3Igbm93IGFsbCBwcm9wZXJ0eSB0eXBlcyB3aXRob3V0IG1vZCBoYXZlIG1pbiBhbmQgbWF4XFxuXFxuXFxuICAgICAgcmV0dXJuIDAgPiB2YWx1ZSA/IDAgOiB0eXBlLm1heCA8IHZhbHVlID8gdHlwZS5tYXggOiB2YWx1ZTtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBzdHJpbmdQYXJzZShzdHJpbmcpIHtcXG4gICAgICB2YXIgaW5zdCA9IGNvbG9yKCksXFxuICAgICAgICAgIHJnYmEgPSBpbnN0Ll9yZ2JhID0gW107XFxuICAgICAgc3RyaW5nID0gc3RyaW5nLnRvTG93ZXJDYXNlKCk7XFxuICAgICAgZWFjaChzdHJpbmdQYXJzZXJzLCBmdW5jdGlvbiAoaSwgcGFyc2VyKSB7XFxuICAgICAgICB2YXIgcGFyc2VkLFxcbiAgICAgICAgICAgIG1hdGNoID0gcGFyc2VyLnJlLmV4ZWMoc3RyaW5nKSxcXG4gICAgICAgICAgICB2YWx1ZXMgPSBtYXRjaCAmJiBwYXJzZXIucGFyc2UobWF0Y2gpLFxcbiAgICAgICAgICAgIHNwYWNlTmFtZSA9IHBhcnNlci5zcGFjZSB8fCBcXFwicmdiYVxcXCI7XFxuXFxuICAgICAgICBpZiAodmFsdWVzKSB7XFxuICAgICAgICAgIHBhcnNlZCA9IGluc3Rbc3BhY2VOYW1lXSh2YWx1ZXMpOyAvLyBpZiB0aGlzIHdhcyBhbiByZ2JhIHBhcnNlIHRoZSBhc3NpZ25tZW50IG1pZ2h0IGhhcHBlbiB0d2ljZVxcbiAgICAgICAgICAvLyBvaCB3ZWxsLi4uLlxcblxcbiAgICAgICAgICBpbnN0W3NwYWNlc1tzcGFjZU5hbWVdLmNhY2hlXSA9IHBhcnNlZFtzcGFjZXNbc3BhY2VOYW1lXS5jYWNoZV07XFxuICAgICAgICAgIHJnYmEgPSBpbnN0Ll9yZ2JhID0gcGFyc2VkLl9yZ2JhOyAvLyBleGl0IGVhY2goIHN0cmluZ1BhcnNlcnMgKSBoZXJlIGJlY2F1c2Ugd2UgbWF0Y2hlZFxcblxcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICB9XFxuICAgICAgfSk7IC8vIEZvdW5kIGEgc3RyaW5nUGFyc2VyIHRoYXQgaGFuZGxlZCBpdFxcblxcbiAgICAgIGlmIChyZ2JhLmxlbmd0aCkge1xcbiAgICAgICAgLy8gaWYgdGhpcyBjYW1lIGZyb20gYSBwYXJzZWQgc3RyaW5nLCBmb3JjZSBcXFwidHJhbnNwYXJlbnRcXFwiIHdoZW4gYWxwaGEgaXMgMFxcbiAgICAgICAgLy8gY2hyb21lLCAoYW5kIG1heWJlIG90aGVycykgcmV0dXJuIFxcXCJ0cmFuc3BhcmVudFxcXCIgYXMgcmdiYSgwLDAsMCwwKVxcbiAgICAgICAgaWYgKHJnYmEuam9pbigpID09PSBcXFwiMCwwLDAsMFxcXCIpIHtcXG4gICAgICAgICAgalF1ZXJ5LmV4dGVuZChyZ2JhLCBjb2xvcnMudHJhbnNwYXJlbnQpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIGluc3Q7XFxuICAgICAgfSAvLyBuYW1lZCBjb2xvcnNcXG5cXG5cXG4gICAgICByZXR1cm4gY29sb3JzW3N0cmluZ107XFxuICAgIH1cXG5cXG4gICAgY29sb3IuZm4gPSBqUXVlcnkuZXh0ZW5kKGNvbG9yLnByb3RvdHlwZSwge1xcbiAgICAgIHBhcnNlOiBmdW5jdGlvbiBwYXJzZShyZWQsIGdyZWVuLCBibHVlLCBhbHBoYSkge1xcbiAgICAgICAgaWYgKHJlZCA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgIHRoaXMuX3JnYmEgPSBbbnVsbCwgbnVsbCwgbnVsbCwgbnVsbF07XFxuICAgICAgICAgIHJldHVybiB0aGlzO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKHJlZC5qcXVlcnkgfHwgcmVkLm5vZGVUeXBlKSB7XFxuICAgICAgICAgIHJlZCA9IGpRdWVyeShyZWQpLmNzcyhncmVlbik7XFxuICAgICAgICAgIGdyZWVuID0gdW5kZWZpbmVkO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdmFyIGluc3QgPSB0aGlzLFxcbiAgICAgICAgICAgIHR5cGUgPSBqUXVlcnkudHlwZShyZWQpLFxcbiAgICAgICAgICAgIHJnYmEgPSB0aGlzLl9yZ2JhID0gW107IC8vIG1vcmUgdGhhbiAxIGFyZ3VtZW50IHNwZWNpZmllZCAtIGFzc3VtZSAoIHJlZCwgZ3JlZW4sIGJsdWUsIGFscGhhIClcXG5cXG4gICAgICAgIGlmIChncmVlbiAhPT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgIHJlZCA9IFtyZWQsIGdyZWVuLCBibHVlLCBhbHBoYV07XFxuICAgICAgICAgIHR5cGUgPSBcXFwiYXJyYXlcXFwiO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKHR5cGUgPT09IFxcXCJzdHJpbmdcXFwiKSB7XFxuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlKHN0cmluZ1BhcnNlKHJlZCkgfHwgY29sb3JzLl9kZWZhdWx0KTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICh0eXBlID09PSBcXFwiYXJyYXlcXFwiKSB7XFxuICAgICAgICAgIGVhY2goc3BhY2VzLnJnYmEucHJvcHMsIGZ1bmN0aW9uIChrZXksIHByb3ApIHtcXG4gICAgICAgICAgICByZ2JhW3Byb3AuaWR4XSA9IGNsYW1wKHJlZFtwcm9wLmlkeF0sIHByb3ApO1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAodHlwZSA9PT0gXFxcIm9iamVjdFxcXCIpIHtcXG4gICAgICAgICAgaWYgKHJlZCBpbnN0YW5jZW9mIGNvbG9yKSB7XFxuICAgICAgICAgICAgZWFjaChzcGFjZXMsIGZ1bmN0aW9uIChzcGFjZU5hbWUsIHNwYWNlKSB7XFxuICAgICAgICAgICAgICBpZiAocmVkW3NwYWNlLmNhY2hlXSkge1xcbiAgICAgICAgICAgICAgICBpbnN0W3NwYWNlLmNhY2hlXSA9IHJlZFtzcGFjZS5jYWNoZV0uc2xpY2UoKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBlYWNoKHNwYWNlcywgZnVuY3Rpb24gKHNwYWNlTmFtZSwgc3BhY2UpIHtcXG4gICAgICAgICAgICAgIHZhciBjYWNoZSA9IHNwYWNlLmNhY2hlO1xcbiAgICAgICAgICAgICAgZWFjaChzcGFjZS5wcm9wcywgZnVuY3Rpb24gKGtleSwgcHJvcCkge1xcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgY2FjaGUgZG9lc24ndCBleGlzdCwgYW5kIHdlIGtub3cgaG93IHRvIGNvbnZlcnRcXG4gICAgICAgICAgICAgICAgaWYgKCFpbnN0W2NhY2hlXSAmJiBzcGFjZS50bykge1xcbiAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSB2YWx1ZSB3YXMgbnVsbCwgd2UgZG9uJ3QgbmVlZCB0byBjb3B5IGl0XFxuICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGtleSB3YXMgYWxwaGEsIHdlIGRvbid0IG5lZWQgdG8gY29weSBpdCBlaXRoZXJcXG4gICAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSBcXFwiYWxwaGFcXFwiIHx8IHJlZFtrZXldID09IG51bGwpIHtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgICAgaW5zdFtjYWNoZV0gPSBzcGFjZS50byhpbnN0Ll9yZ2JhKTtcXG4gICAgICAgICAgICAgICAgfSAvLyB0aGlzIGlzIHRoZSBvbmx5IGNhc2Ugd2hlcmUgd2UgYWxsb3cgbnVsbHMgZm9yIEFMTCBwcm9wZXJ0aWVzLlxcbiAgICAgICAgICAgICAgICAvLyBjYWxsIGNsYW1wIHdpdGggYWx3YXlzQWxsb3dFbXB0eVxcblxcblxcbiAgICAgICAgICAgICAgICBpbnN0W2NhY2hlXVtwcm9wLmlkeF0gPSBjbGFtcChyZWRba2V5XSwgcHJvcCwgdHJ1ZSk7XFxuICAgICAgICAgICAgICB9KTsgLy8gZXZlcnl0aGluZyBkZWZpbmVkIGJ1dCBhbHBoYT9cXG5cXG4gICAgICAgICAgICAgIGlmIChpbnN0W2NhY2hlXSAmJiBqUXVlcnkuaW5BcnJheShudWxsLCBpbnN0W2NhY2hlXS5zbGljZSgwLCAzKSkgPCAwKSB7XFxuICAgICAgICAgICAgICAgIC8vIHVzZSB0aGUgZGVmYXVsdCBvZiAxXFxuICAgICAgICAgICAgICAgIGluc3RbY2FjaGVdWzNdID0gMTtcXG5cXG4gICAgICAgICAgICAgICAgaWYgKHNwYWNlLmZyb20pIHtcXG4gICAgICAgICAgICAgICAgICBpbnN0Ll9yZ2JhID0gc3BhY2UuZnJvbShpbnN0W2NhY2hlXSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICByZXR1cm4gdGhpcztcXG4gICAgICAgIH1cXG4gICAgICB9LFxcbiAgICAgIGlzOiBmdW5jdGlvbiBpcyhjb21wYXJlKSB7XFxuICAgICAgICB2YXIgaXMgPSBjb2xvcihjb21wYXJlKSxcXG4gICAgICAgICAgICBzYW1lID0gdHJ1ZSxcXG4gICAgICAgICAgICBpbnN0ID0gdGhpcztcXG4gICAgICAgIGVhY2goc3BhY2VzLCBmdW5jdGlvbiAoXywgc3BhY2UpIHtcXG4gICAgICAgICAgdmFyIGxvY2FsQ2FjaGUsXFxuICAgICAgICAgICAgICBpc0NhY2hlID0gaXNbc3BhY2UuY2FjaGVdO1xcblxcbiAgICAgICAgICBpZiAoaXNDYWNoZSkge1xcbiAgICAgICAgICAgIGxvY2FsQ2FjaGUgPSBpbnN0W3NwYWNlLmNhY2hlXSB8fCBzcGFjZS50byAmJiBzcGFjZS50byhpbnN0Ll9yZ2JhKSB8fCBbXTtcXG4gICAgICAgICAgICBlYWNoKHNwYWNlLnByb3BzLCBmdW5jdGlvbiAoXywgcHJvcCkge1xcbiAgICAgICAgICAgICAgaWYgKGlzQ2FjaGVbcHJvcC5pZHhdICE9IG51bGwpIHtcXG4gICAgICAgICAgICAgICAgc2FtZSA9IGlzQ2FjaGVbcHJvcC5pZHhdID09PSBsb2NhbENhY2hlW3Byb3AuaWR4XTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNhbWU7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgcmV0dXJuIHNhbWU7XFxuICAgICAgICB9KTtcXG4gICAgICAgIHJldHVybiBzYW1lO1xcbiAgICAgIH0sXFxuICAgICAgX3NwYWNlOiBmdW5jdGlvbiBfc3BhY2UoKSB7XFxuICAgICAgICB2YXIgdXNlZCA9IFtdLFxcbiAgICAgICAgICAgIGluc3QgPSB0aGlzO1xcbiAgICAgICAgZWFjaChzcGFjZXMsIGZ1bmN0aW9uIChzcGFjZU5hbWUsIHNwYWNlKSB7XFxuICAgICAgICAgIGlmIChpbnN0W3NwYWNlLmNhY2hlXSkge1xcbiAgICAgICAgICAgIHVzZWQucHVzaChzcGFjZU5hbWUpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgICAgIHJldHVybiB1c2VkLnBvcCgpO1xcbiAgICAgIH0sXFxuICAgICAgdHJhbnNpdGlvbjogZnVuY3Rpb24gdHJhbnNpdGlvbihvdGhlciwgZGlzdGFuY2UpIHtcXG4gICAgICAgIHZhciBlbmQgPSBjb2xvcihvdGhlciksXFxuICAgICAgICAgICAgc3BhY2VOYW1lID0gZW5kLl9zcGFjZSgpLFxcbiAgICAgICAgICAgIHNwYWNlID0gc3BhY2VzW3NwYWNlTmFtZV0sXFxuICAgICAgICAgICAgc3RhcnRDb2xvciA9IHRoaXMuYWxwaGEoKSA9PT0gMCA/IGNvbG9yKFxcXCJ0cmFuc3BhcmVudFxcXCIpIDogdGhpcyxcXG4gICAgICAgICAgICBzdGFydCA9IHN0YXJ0Q29sb3Jbc3BhY2UuY2FjaGVdIHx8IHNwYWNlLnRvKHN0YXJ0Q29sb3IuX3JnYmEpLFxcbiAgICAgICAgICAgIHJlc3VsdCA9IHN0YXJ0LnNsaWNlKCk7XFxuXFxuICAgICAgICBlbmQgPSBlbmRbc3BhY2UuY2FjaGVdO1xcbiAgICAgICAgZWFjaChzcGFjZS5wcm9wcywgZnVuY3Rpb24gKGtleSwgcHJvcCkge1xcbiAgICAgICAgICB2YXIgaW5kZXggPSBwcm9wLmlkeCxcXG4gICAgICAgICAgICAgIHN0YXJ0VmFsdWUgPSBzdGFydFtpbmRleF0sXFxuICAgICAgICAgICAgICBlbmRWYWx1ZSA9IGVuZFtpbmRleF0sXFxuICAgICAgICAgICAgICB0eXBlID0gcHJvcFR5cGVzW3Byb3AudHlwZV0gfHwge307IC8vIGlmIG51bGwsIGRvbid0IG92ZXJyaWRlIHN0YXJ0IHZhbHVlXFxuXFxuICAgICAgICAgIGlmIChlbmRWYWx1ZSA9PT0gbnVsbCkge1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgfSAvLyBpZiBudWxsIC0gdXNlIGVuZFxcblxcblxcbiAgICAgICAgICBpZiAoc3RhcnRWYWx1ZSA9PT0gbnVsbCkge1xcbiAgICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSBlbmRWYWx1ZTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBpZiAodHlwZS5tb2QpIHtcXG4gICAgICAgICAgICAgIGlmIChlbmRWYWx1ZSAtIHN0YXJ0VmFsdWUgPiB0eXBlLm1vZCAvIDIpIHtcXG4gICAgICAgICAgICAgICAgc3RhcnRWYWx1ZSArPSB0eXBlLm1vZDtcXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhcnRWYWx1ZSAtIGVuZFZhbHVlID4gdHlwZS5tb2QgLyAyKSB7XFxuICAgICAgICAgICAgICAgIHN0YXJ0VmFsdWUgLT0gdHlwZS5tb2Q7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSBjbGFtcCgoZW5kVmFsdWUgLSBzdGFydFZhbHVlKSAqIGRpc3RhbmNlICsgc3RhcnRWYWx1ZSwgcHJvcCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICAgICAgcmV0dXJuIHRoaXNbc3BhY2VOYW1lXShyZXN1bHQpO1xcbiAgICAgIH0sXFxuICAgICAgYmxlbmQ6IGZ1bmN0aW9uIGJsZW5kKG9wYXF1ZSkge1xcbiAgICAgICAgLy8gaWYgd2UgYXJlIGFscmVhZHkgb3BhcXVlIC0gcmV0dXJuIG91cnNlbGZcXG4gICAgICAgIGlmICh0aGlzLl9yZ2JhWzNdID09PSAxKSB7XFxuICAgICAgICAgIHJldHVybiB0aGlzO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdmFyIHJnYiA9IHRoaXMuX3JnYmEuc2xpY2UoKSxcXG4gICAgICAgICAgICBhID0gcmdiLnBvcCgpLFxcbiAgICAgICAgICAgIGJsZW5kID0gY29sb3Iob3BhcXVlKS5fcmdiYTtcXG5cXG4gICAgICAgIHJldHVybiBjb2xvcihqUXVlcnkubWFwKHJnYiwgZnVuY3Rpb24gKHYsIGkpIHtcXG4gICAgICAgICAgcmV0dXJuICgxIC0gYSkgKiBibGVuZFtpXSArIGEgKiB2O1xcbiAgICAgICAgfSkpO1xcbiAgICAgIH0sXFxuICAgICAgdG9SZ2JhU3RyaW5nOiBmdW5jdGlvbiB0b1JnYmFTdHJpbmcoKSB7XFxuICAgICAgICB2YXIgcHJlZml4ID0gXFxcInJnYmEoXFxcIixcXG4gICAgICAgICAgICByZ2JhID0galF1ZXJ5Lm1hcCh0aGlzLl9yZ2JhLCBmdW5jdGlvbiAodiwgaSkge1xcbiAgICAgICAgICByZXR1cm4gdiA9PSBudWxsID8gaSA+IDIgPyAxIDogMCA6IHY7XFxuICAgICAgICB9KTtcXG5cXG4gICAgICAgIGlmIChyZ2JhWzNdID09PSAxKSB7XFxuICAgICAgICAgIHJnYmEucG9wKCk7XFxuICAgICAgICAgIHByZWZpeCA9IFxcXCJyZ2IoXFxcIjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiBwcmVmaXggKyByZ2JhLmpvaW4oKSArIFxcXCIpXFxcIjtcXG4gICAgICB9LFxcbiAgICAgIHRvSHNsYVN0cmluZzogZnVuY3Rpb24gdG9Ic2xhU3RyaW5nKCkge1xcbiAgICAgICAgdmFyIHByZWZpeCA9IFxcXCJoc2xhKFxcXCIsXFxuICAgICAgICAgICAgaHNsYSA9IGpRdWVyeS5tYXAodGhpcy5oc2xhKCksIGZ1bmN0aW9uICh2LCBpKSB7XFxuICAgICAgICAgIGlmICh2ID09IG51bGwpIHtcXG4gICAgICAgICAgICB2ID0gaSA+IDIgPyAxIDogMDtcXG4gICAgICAgICAgfSAvLyBjYXRjaCAxIGFuZCAyXFxuXFxuXFxuICAgICAgICAgIGlmIChpICYmIGkgPCAzKSB7XFxuICAgICAgICAgICAgdiA9IE1hdGgucm91bmQodiAqIDEwMCkgKyBcXFwiJVxcXCI7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgcmV0dXJuIHY7XFxuICAgICAgICB9KTtcXG5cXG4gICAgICAgIGlmIChoc2xhWzNdID09PSAxKSB7XFxuICAgICAgICAgIGhzbGEucG9wKCk7XFxuICAgICAgICAgIHByZWZpeCA9IFxcXCJoc2woXFxcIjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiBwcmVmaXggKyBoc2xhLmpvaW4oKSArIFxcXCIpXFxcIjtcXG4gICAgICB9LFxcbiAgICAgIHRvSGV4U3RyaW5nOiBmdW5jdGlvbiB0b0hleFN0cmluZyhpbmNsdWRlQWxwaGEpIHtcXG4gICAgICAgIHZhciByZ2JhID0gdGhpcy5fcmdiYS5zbGljZSgpLFxcbiAgICAgICAgICAgIGFscGhhID0gcmdiYS5wb3AoKTtcXG5cXG4gICAgICAgIGlmIChpbmNsdWRlQWxwaGEpIHtcXG4gICAgICAgICAgcmdiYS5wdXNoKH5+KGFscGhhICogMjU1KSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gXFxcIiNcXFwiICsgalF1ZXJ5Lm1hcChyZ2JhLCBmdW5jdGlvbiAodikge1xcbiAgICAgICAgICAvLyBkZWZhdWx0IHRvIDAgd2hlbiBudWxscyBleGlzdFxcbiAgICAgICAgICB2ID0gKHYgfHwgMCkudG9TdHJpbmcoMTYpO1xcbiAgICAgICAgICByZXR1cm4gdi5sZW5ndGggPT09IDEgPyBcXFwiMFxcXCIgKyB2IDogdjtcXG4gICAgICAgIH0pLmpvaW4oXFxcIlxcXCIpO1xcbiAgICAgIH0sXFxuICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JnYmFbM10gPT09IDAgPyBcXFwidHJhbnNwYXJlbnRcXFwiIDogdGhpcy50b1JnYmFTdHJpbmcoKTtcXG4gICAgICB9XFxuICAgIH0pO1xcbiAgICBjb2xvci5mbi5wYXJzZS5wcm90b3R5cGUgPSBjb2xvci5mbjsgLy8gaHNsYSBjb252ZXJzaW9ucyBhZGFwdGVkIGZyb206XFxuICAgIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvbWFhc2hhYWNrL3NvdXJjZS9icm93c2UvcGFja2FnZXMvZ3JhcGhpY3MvdHJ1bmsvc3JjL2dyYXBoaWNzL2NvbG9ycy9IVUUyUkdCLmFzP3I9NTAyMVxcblxcbiAgICBmdW5jdGlvbiBodWUycmdiKHAsIHEsIGgpIHtcXG4gICAgICBoID0gKGggKyAxKSAlIDE7XFxuXFxuICAgICAgaWYgKGggKiA2IDwgMSkge1xcbiAgICAgICAgcmV0dXJuIHAgKyAocSAtIHApICogaCAqIDY7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChoICogMiA8IDEpIHtcXG4gICAgICAgIHJldHVybiBxO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoaCAqIDMgPCAyKSB7XFxuICAgICAgICByZXR1cm4gcCArIChxIC0gcCkgKiAoMiAvIDMgLSBoKSAqIDY7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBwO1xcbiAgICB9XFxuXFxuICAgIHNwYWNlcy5oc2xhLnRvID0gZnVuY3Rpb24gKHJnYmEpIHtcXG4gICAgICBpZiAocmdiYVswXSA9PSBudWxsIHx8IHJnYmFbMV0gPT0gbnVsbCB8fCByZ2JhWzJdID09IG51bGwpIHtcXG4gICAgICAgIHJldHVybiBbbnVsbCwgbnVsbCwgbnVsbCwgcmdiYVszXV07XFxuICAgICAgfVxcblxcbiAgICAgIHZhciByID0gcmdiYVswXSAvIDI1NSxcXG4gICAgICAgICAgZyA9IHJnYmFbMV0gLyAyNTUsXFxuICAgICAgICAgIGIgPSByZ2JhWzJdIC8gMjU1LFxcbiAgICAgICAgICBhID0gcmdiYVszXSxcXG4gICAgICAgICAgbWF4ID0gTWF0aC5tYXgociwgZywgYiksXFxuICAgICAgICAgIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpLFxcbiAgICAgICAgICBkaWZmID0gbWF4IC0gbWluLFxcbiAgICAgICAgICBhZGQgPSBtYXggKyBtaW4sXFxuICAgICAgICAgIGwgPSBhZGQgKiAwLjUsXFxuICAgICAgICAgIGgsXFxuICAgICAgICAgIHM7XFxuXFxuICAgICAgaWYgKG1pbiA9PT0gbWF4KSB7XFxuICAgICAgICBoID0gMDtcXG4gICAgICB9IGVsc2UgaWYgKHIgPT09IG1heCkge1xcbiAgICAgICAgaCA9IDYwICogKGcgLSBiKSAvIGRpZmYgKyAzNjA7XFxuICAgICAgfSBlbHNlIGlmIChnID09PSBtYXgpIHtcXG4gICAgICAgIGggPSA2MCAqIChiIC0gcikgLyBkaWZmICsgMTIwO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBoID0gNjAgKiAociAtIGcpIC8gZGlmZiArIDI0MDtcXG4gICAgICB9IC8vIGNocm9tYSAoZGlmZikgPT0gMCBtZWFucyBncmV5c2NhbGUgd2hpY2gsIGJ5IGRlZmluaXRpb24sIHNhdHVyYXRpb24gPSAwJVxcbiAgICAgIC8vIG90aGVyd2lzZSwgc2F0dXJhdGlvbiBpcyBiYXNlZCBvbiB0aGUgcmF0aW8gb2YgY2hyb21hIChkaWZmKSB0byBsaWdodG5lc3MgKGFkZClcXG5cXG5cXG4gICAgICBpZiAoZGlmZiA9PT0gMCkge1xcbiAgICAgICAgcyA9IDA7XFxuICAgICAgfSBlbHNlIGlmIChsIDw9IDAuNSkge1xcbiAgICAgICAgcyA9IGRpZmYgLyBhZGQ7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHMgPSBkaWZmIC8gKDIgLSBhZGQpO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gW01hdGgucm91bmQoaCkgJSAzNjAsIHMsIGwsIGEgPT0gbnVsbCA/IDEgOiBhXTtcXG4gICAgfTtcXG5cXG4gICAgc3BhY2VzLmhzbGEuZnJvbSA9IGZ1bmN0aW9uIChoc2xhKSB7XFxuICAgICAgaWYgKGhzbGFbMF0gPT0gbnVsbCB8fCBoc2xhWzFdID09IG51bGwgfHwgaHNsYVsyXSA9PSBudWxsKSB7XFxuICAgICAgICByZXR1cm4gW251bGwsIG51bGwsIG51bGwsIGhzbGFbM11dO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgaCA9IGhzbGFbMF0gLyAzNjAsXFxuICAgICAgICAgIHMgPSBoc2xhWzFdLFxcbiAgICAgICAgICBsID0gaHNsYVsyXSxcXG4gICAgICAgICAgYSA9IGhzbGFbM10sXFxuICAgICAgICAgIHEgPSBsIDw9IDAuNSA/IGwgKiAoMSArIHMpIDogbCArIHMgLSBsICogcyxcXG4gICAgICAgICAgcCA9IDIgKiBsIC0gcTtcXG4gICAgICByZXR1cm4gW01hdGgucm91bmQoaHVlMnJnYihwLCBxLCBoICsgMSAvIDMpICogMjU1KSwgTWF0aC5yb3VuZChodWUycmdiKHAsIHEsIGgpICogMjU1KSwgTWF0aC5yb3VuZChodWUycmdiKHAsIHEsIGggLSAxIC8gMykgKiAyNTUpLCBhXTtcXG4gICAgfTtcXG5cXG4gICAgZWFjaChzcGFjZXMsIGZ1bmN0aW9uIChzcGFjZU5hbWUsIHNwYWNlKSB7XFxuICAgICAgdmFyIHByb3BzID0gc3BhY2UucHJvcHMsXFxuICAgICAgICAgIGNhY2hlID0gc3BhY2UuY2FjaGUsXFxuICAgICAgICAgIHRvID0gc3BhY2UudG8sXFxuICAgICAgICAgIGZyb20gPSBzcGFjZS5mcm9tOyAvLyBtYWtlcyByZ2JhKCkgYW5kIGhzbGEoKVxcblxcbiAgICAgIGNvbG9yLmZuW3NwYWNlTmFtZV0gPSBmdW5jdGlvbiAodmFsdWUpIHtcXG4gICAgICAgIC8vIGdlbmVyYXRlIGEgY2FjaGUgZm9yIHRoaXMgc3BhY2UgaWYgaXQgZG9lc24ndCBleGlzdFxcbiAgICAgICAgaWYgKHRvICYmICF0aGlzW2NhY2hlXSkge1xcbiAgICAgICAgICB0aGlzW2NhY2hlXSA9IHRvKHRoaXMuX3JnYmEpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcXG4gICAgICAgICAgcmV0dXJuIHRoaXNbY2FjaGVdLnNsaWNlKCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB2YXIgcmV0LFxcbiAgICAgICAgICAgIHR5cGUgPSBqUXVlcnkudHlwZSh2YWx1ZSksXFxuICAgICAgICAgICAgYXJyID0gdHlwZSA9PT0gXFxcImFycmF5XFxcIiB8fCB0eXBlID09PSBcXFwib2JqZWN0XFxcIiA/IHZhbHVlIDogYXJndW1lbnRzLFxcbiAgICAgICAgICAgIGxvY2FsID0gdGhpc1tjYWNoZV0uc2xpY2UoKTtcXG4gICAgICAgIGVhY2gocHJvcHMsIGZ1bmN0aW9uIChrZXksIHByb3ApIHtcXG4gICAgICAgICAgdmFyIHZhbCA9IGFyclt0eXBlID09PSBcXFwib2JqZWN0XFxcIiA/IGtleSA6IHByb3AuaWR4XTtcXG5cXG4gICAgICAgICAgaWYgKHZhbCA9PSBudWxsKSB7XFxuICAgICAgICAgICAgdmFsID0gbG9jYWxbcHJvcC5pZHhdO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGxvY2FsW3Byb3AuaWR4XSA9IGNsYW1wKHZhbCwgcHJvcCk7XFxuICAgICAgICB9KTtcXG5cXG4gICAgICAgIGlmIChmcm9tKSB7XFxuICAgICAgICAgIHJldCA9IGNvbG9yKGZyb20obG9jYWwpKTtcXG4gICAgICAgICAgcmV0W2NhY2hlXSA9IGxvY2FsO1xcbiAgICAgICAgICByZXR1cm4gcmV0O1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgcmV0dXJuIGNvbG9yKGxvY2FsKTtcXG4gICAgICAgIH1cXG4gICAgICB9OyAvLyBtYWtlcyByZWQoKSBncmVlbigpIGJsdWUoKSBhbHBoYSgpIGh1ZSgpIHNhdHVyYXRpb24oKSBsaWdodG5lc3MoKVxcblxcblxcbiAgICAgIGVhY2gocHJvcHMsIGZ1bmN0aW9uIChrZXksIHByb3ApIHtcXG4gICAgICAgIC8vIGFscGhhIGlzIGluY2x1ZGVkIGluIG1vcmUgdGhhbiBvbmUgc3BhY2VcXG4gICAgICAgIGlmIChjb2xvci5mbltrZXldKSB7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGNvbG9yLmZuW2tleV0gPSBmdW5jdGlvbiAodmFsdWUpIHtcXG4gICAgICAgICAgdmFyIHZ0eXBlID0galF1ZXJ5LnR5cGUodmFsdWUpLFxcbiAgICAgICAgICAgICAgZm4gPSBrZXkgPT09IFxcXCJhbHBoYVxcXCIgPyB0aGlzLl9oc2xhID8gXFxcImhzbGFcXFwiIDogXFxcInJnYmFcXFwiIDogc3BhY2VOYW1lLFxcbiAgICAgICAgICAgICAgbG9jYWwgPSB0aGlzW2ZuXSgpLFxcbiAgICAgICAgICAgICAgY3VyID0gbG9jYWxbcHJvcC5pZHhdLFxcbiAgICAgICAgICAgICAgbWF0Y2g7XFxuXFxuICAgICAgICAgIGlmICh2dHlwZSA9PT0gXFxcInVuZGVmaW5lZFxcXCIpIHtcXG4gICAgICAgICAgICByZXR1cm4gY3VyO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmICh2dHlwZSA9PT0gXFxcImZ1bmN0aW9uXFxcIikge1xcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuY2FsbCh0aGlzLCBjdXIpO1xcbiAgICAgICAgICAgIHZ0eXBlID0galF1ZXJ5LnR5cGUodmFsdWUpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsICYmIHByb3AuZW1wdHkpIHtcXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAodnR5cGUgPT09IFxcXCJzdHJpbmdcXFwiKSB7XFxuICAgICAgICAgICAgbWF0Y2ggPSBycGx1c2VxdWFscy5leGVjKHZhbHVlKTtcXG5cXG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcXG4gICAgICAgICAgICAgIHZhbHVlID0gY3VyICsgcGFyc2VGbG9hdChtYXRjaFsyXSkgKiAobWF0Y2hbMV0gPT09IFxcXCIrXFxcIiA/IDEgOiAtMSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGxvY2FsW3Byb3AuaWR4XSA9IHZhbHVlO1xcbiAgICAgICAgICByZXR1cm4gdGhpc1tmbl0obG9jYWwpO1xcbiAgICAgICAgfTtcXG4gICAgICB9KTtcXG4gICAgfSk7IC8vIGFkZCBjc3NIb29rIGFuZCAuZnguc3RlcCBmdW5jdGlvbiBmb3IgZWFjaCBuYW1lZCBob29rLlxcbiAgICAvLyBhY2NlcHQgYSBzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nIG9mIHByb3BlcnRpZXNcXG5cXG4gICAgY29sb3IuaG9vayA9IGZ1bmN0aW9uIChob29rKSB7XFxuICAgICAgdmFyIGhvb2tzID0gaG9vay5zcGxpdChcXFwiIFxcXCIpO1xcbiAgICAgIGVhY2goaG9va3MsIGZ1bmN0aW9uIChpLCBob29rKSB7XFxuICAgICAgICBqUXVlcnkuY3NzSG9va3NbaG9va10gPSB7XFxuICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGVsZW0sIHZhbHVlKSB7XFxuICAgICAgICAgICAgdmFyIHBhcnNlZCxcXG4gICAgICAgICAgICAgICAgY3VyRWxlbSxcXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yID0gXFxcIlxcXCI7XFxuXFxuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBcXFwidHJhbnNwYXJlbnRcXFwiICYmIChqUXVlcnkudHlwZSh2YWx1ZSkgIT09IFxcXCJzdHJpbmdcXFwiIHx8IChwYXJzZWQgPSBzdHJpbmdQYXJzZSh2YWx1ZSkpKSkge1xcbiAgICAgICAgICAgICAgdmFsdWUgPSBjb2xvcihwYXJzZWQgfHwgdmFsdWUpO1xcblxcbiAgICAgICAgICAgICAgaWYgKCFzdXBwb3J0LnJnYmEgJiYgdmFsdWUuX3JnYmFbM10gIT09IDEpIHtcXG4gICAgICAgICAgICAgICAgY3VyRWxlbSA9IGhvb2sgPT09IFxcXCJiYWNrZ3JvdW5kQ29sb3JcXFwiID8gZWxlbS5wYXJlbnROb2RlIDogZWxlbTtcXG5cXG4gICAgICAgICAgICAgICAgd2hpbGUgKChiYWNrZ3JvdW5kQ29sb3IgPT09IFxcXCJcXFwiIHx8IGJhY2tncm91bmRDb2xvciA9PT0gXFxcInRyYW5zcGFyZW50XFxcIikgJiYgY3VyRWxlbSAmJiBjdXJFbGVtLnN0eWxlKSB7XFxuICAgICAgICAgICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvciA9IGpRdWVyeS5jc3MoY3VyRWxlbSwgXFxcImJhY2tncm91bmRDb2xvclxcXCIpO1xcbiAgICAgICAgICAgICAgICAgICAgY3VyRWxlbSA9IGN1ckVsZW0ucGFyZW50Tm9kZTtcXG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuYmxlbmQoYmFja2dyb3VuZENvbG9yICYmIGJhY2tncm91bmRDb2xvciAhPT0gXFxcInRyYW5zcGFyZW50XFxcIiA/IGJhY2tncm91bmRDb2xvciA6IFxcXCJfZGVmYXVsdFxcXCIpO1xcbiAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1JnYmFTdHJpbmcoKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAgIGVsZW0uc3R5bGVbaG9va10gPSB2YWx1ZTtcXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7Ly8gd3JhcHBlZCB0byBwcmV2ZW50IElFIGZyb20gdGhyb3dpbmcgZXJyb3JzIG9uIFxcXCJpbnZhbGlkXFxcIiB2YWx1ZXMgbGlrZSAnYXV0bycgb3IgJ2luaGVyaXQnXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9O1xcblxcbiAgICAgICAgalF1ZXJ5LmZ4LnN0ZXBbaG9va10gPSBmdW5jdGlvbiAoZngpIHtcXG4gICAgICAgICAgaWYgKCFmeC5jb2xvckluaXQpIHtcXG4gICAgICAgICAgICBmeC5zdGFydCA9IGNvbG9yKGZ4LmVsZW0sIGhvb2spO1xcbiAgICAgICAgICAgIGZ4LmVuZCA9IGNvbG9yKGZ4LmVuZCk7XFxuICAgICAgICAgICAgZnguY29sb3JJbml0ID0gdHJ1ZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBqUXVlcnkuY3NzSG9va3NbaG9va10uc2V0KGZ4LmVsZW0sIGZ4LnN0YXJ0LnRyYW5zaXRpb24oZnguZW5kLCBmeC5wb3MpKTtcXG4gICAgICAgIH07XFxuICAgICAgfSk7XFxuICAgIH07XFxuXFxuICAgIGNvbG9yLmhvb2soc3RlcEhvb2tzKTtcXG4gICAgalF1ZXJ5LmNzc0hvb2tzLmJvcmRlckNvbG9yID0ge1xcbiAgICAgIGV4cGFuZDogZnVuY3Rpb24gZXhwYW5kKHZhbHVlKSB7XFxuICAgICAgICB2YXIgZXhwYW5kZWQgPSB7fTtcXG4gICAgICAgIGVhY2goW1xcXCJUb3BcXFwiLCBcXFwiUmlnaHRcXFwiLCBcXFwiQm90dG9tXFxcIiwgXFxcIkxlZnRcXFwiXSwgZnVuY3Rpb24gKGksIHBhcnQpIHtcXG4gICAgICAgICAgZXhwYW5kZWRbXFxcImJvcmRlclxcXCIgKyBwYXJ0ICsgXFxcIkNvbG9yXFxcIl0gPSB2YWx1ZTtcXG4gICAgICAgIH0pO1xcbiAgICAgICAgcmV0dXJuIGV4cGFuZGVkO1xcbiAgICAgIH1cXG4gICAgfTsgLy8gQmFzaWMgY29sb3IgbmFtZXMgb25seS5cXG4gICAgLy8gVXNhZ2Ugb2YgYW55IG9mIHRoZSBvdGhlciBjb2xvciBuYW1lcyByZXF1aXJlcyBhZGRpbmcgeW91cnNlbGYgb3IgaW5jbHVkaW5nXFxuICAgIC8vIGpxdWVyeS5jb2xvci5zdmctbmFtZXMuanMuXFxuXFxuICAgIGNvbG9ycyA9IGpRdWVyeS5Db2xvci5uYW1lcyA9IHtcXG4gICAgICAvLyA0LjEuIEJhc2ljIGNvbG9yIGtleXdvcmRzXFxuICAgICAgYXF1YTogXFxcIiMwMGZmZmZcXFwiLFxcbiAgICAgIGJsYWNrOiBcXFwiIzAwMDAwMFxcXCIsXFxuICAgICAgYmx1ZTogXFxcIiMwMDAwZmZcXFwiLFxcbiAgICAgIGZ1Y2hzaWE6IFxcXCIjZmYwMGZmXFxcIixcXG4gICAgICBncmF5OiBcXFwiIzgwODA4MFxcXCIsXFxuICAgICAgZ3JlZW46IFxcXCIjMDA4MDAwXFxcIixcXG4gICAgICBsaW1lOiBcXFwiIzAwZmYwMFxcXCIsXFxuICAgICAgbWFyb29uOiBcXFwiIzgwMDAwMFxcXCIsXFxuICAgICAgbmF2eTogXFxcIiMwMDAwODBcXFwiLFxcbiAgICAgIG9saXZlOiBcXFwiIzgwODAwMFxcXCIsXFxuICAgICAgcHVycGxlOiBcXFwiIzgwMDA4MFxcXCIsXFxuICAgICAgcmVkOiBcXFwiI2ZmMDAwMFxcXCIsXFxuICAgICAgc2lsdmVyOiBcXFwiI2MwYzBjMFxcXCIsXFxuICAgICAgdGVhbDogXFxcIiMwMDgwODBcXFwiLFxcbiAgICAgIHdoaXRlOiBcXFwiI2ZmZmZmZlxcXCIsXFxuICAgICAgeWVsbG93OiBcXFwiI2ZmZmYwMFxcXCIsXFxuICAgICAgLy8gNC4yLjMuIFxcXCJ0cmFuc3BhcmVudFxcXCIgY29sb3Iga2V5d29yZFxcbiAgICAgIHRyYW5zcGFyZW50OiBbbnVsbCwgbnVsbCwgbnVsbCwgMF0sXFxuICAgICAgX2RlZmF1bHQ6IFxcXCIjZmZmZmZmXFxcIlxcbiAgICB9O1xcbiAgfSkoalF1ZXJ5KTtcXG4gIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuXFxuICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIENMQVNTIEFOSU1BVElPTlMgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcblxcbiAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG5cXG5cXG4gIChmdW5jdGlvbiAoKSB7XFxuICAgIHZhciBjbGFzc0FuaW1hdGlvbkFjdGlvbnMgPSBbXFxcImFkZFxcXCIsIFxcXCJyZW1vdmVcXFwiLCBcXFwidG9nZ2xlXFxcIl0sXFxuICAgICAgICBzaG9ydGhhbmRTdHlsZXMgPSB7XFxuICAgICAgYm9yZGVyOiAxLFxcbiAgICAgIGJvcmRlckJvdHRvbTogMSxcXG4gICAgICBib3JkZXJDb2xvcjogMSxcXG4gICAgICBib3JkZXJMZWZ0OiAxLFxcbiAgICAgIGJvcmRlclJpZ2h0OiAxLFxcbiAgICAgIGJvcmRlclRvcDogMSxcXG4gICAgICBib3JkZXJXaWR0aDogMSxcXG4gICAgICBtYXJnaW46IDEsXFxuICAgICAgcGFkZGluZzogMVxcbiAgICB9O1xcbiAgICAkLmVhY2goW1xcXCJib3JkZXJMZWZ0U3R5bGVcXFwiLCBcXFwiYm9yZGVyUmlnaHRTdHlsZVxcXCIsIFxcXCJib3JkZXJCb3R0b21TdHlsZVxcXCIsIFxcXCJib3JkZXJUb3BTdHlsZVxcXCJdLCBmdW5jdGlvbiAoXywgcHJvcCkge1xcbiAgICAgICQuZnguc3RlcFtwcm9wXSA9IGZ1bmN0aW9uIChmeCkge1xcbiAgICAgICAgaWYgKGZ4LmVuZCAhPT0gXFxcIm5vbmVcXFwiICYmICFmeC5zZXRBdHRyIHx8IGZ4LnBvcyA9PT0gMSAmJiAhZnguc2V0QXR0cikge1xcbiAgICAgICAgICBqUXVlcnkuc3R5bGUoZnguZWxlbSwgcHJvcCwgZnguZW5kKTtcXG4gICAgICAgICAgZnguc2V0QXR0ciA9IHRydWU7XFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgfSk7XFxuXFxuICAgIGZ1bmN0aW9uIGdldEVsZW1lbnRTdHlsZXMoZWxlbSkge1xcbiAgICAgIHZhciBrZXksXFxuICAgICAgICAgIGxlbixcXG4gICAgICAgICAgc3R5bGUgPSBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgPyBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtLCBudWxsKSA6IGVsZW0uY3VycmVudFN0eWxlLFxcbiAgICAgICAgICBzdHlsZXMgPSB7fTtcXG5cXG4gICAgICBpZiAoc3R5bGUgJiYgc3R5bGUubGVuZ3RoICYmIHN0eWxlWzBdICYmIHN0eWxlW3N0eWxlWzBdXSkge1xcbiAgICAgICAgbGVuID0gc3R5bGUubGVuZ3RoO1xcblxcbiAgICAgICAgd2hpbGUgKGxlbi0tKSB7XFxuICAgICAgICAgIGtleSA9IHN0eWxlW2xlbl07XFxuXFxuICAgICAgICAgIGlmICh0eXBlb2Ygc3R5bGVba2V5XSA9PT0gXFxcInN0cmluZ1xcXCIpIHtcXG4gICAgICAgICAgICBzdHlsZXNbJC5jYW1lbENhc2Uoa2V5KV0gPSBzdHlsZVtrZXldO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IC8vIHN1cHBvcnQ6IE9wZXJhLCBJRSA8OVxcblxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBmb3IgKGtleSBpbiBzdHlsZSkge1xcbiAgICAgICAgICBpZiAodHlwZW9mIHN0eWxlW2tleV0gPT09IFxcXCJzdHJpbmdcXFwiKSB7XFxuICAgICAgICAgICAgc3R5bGVzW2tleV0gPSBzdHlsZVtrZXldO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBzdHlsZXM7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gc3R5bGVEaWZmZXJlbmNlKG9sZFN0eWxlLCBuZXdTdHlsZSkge1xcbiAgICAgIHZhciBkaWZmID0ge30sXFxuICAgICAgICAgIG5hbWUsXFxuICAgICAgICAgIHZhbHVlO1xcblxcbiAgICAgIGZvciAobmFtZSBpbiBuZXdTdHlsZSkge1xcbiAgICAgICAgdmFsdWUgPSBuZXdTdHlsZVtuYW1lXTtcXG5cXG4gICAgICAgIGlmIChvbGRTdHlsZVtuYW1lXSAhPT0gdmFsdWUpIHtcXG4gICAgICAgICAgaWYgKCFzaG9ydGhhbmRTdHlsZXNbbmFtZV0pIHtcXG4gICAgICAgICAgICBpZiAoJC5meC5zdGVwW25hbWVdIHx8ICFpc05hTihwYXJzZUZsb2F0KHZhbHVlKSkpIHtcXG4gICAgICAgICAgICAgIGRpZmZbbmFtZV0gPSB2YWx1ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIGRpZmY7XFxuICAgIH0gLy8gc3VwcG9ydDogalF1ZXJ5IDwxLjhcXG5cXG5cXG4gICAgaWYgKCEkLmZuLmFkZEJhY2spIHtcXG4gICAgICAkLmZuLmFkZEJhY2sgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLmFkZChzZWxlY3RvciA9PSBudWxsID8gdGhpcy5wcmV2T2JqZWN0IDogdGhpcy5wcmV2T2JqZWN0LmZpbHRlcihzZWxlY3RvcikpO1xcbiAgICAgIH07XFxuICAgIH1cXG5cXG4gICAgJC5lZmZlY3RzLmFuaW1hdGVDbGFzcyA9IGZ1bmN0aW9uICh2YWx1ZSwgZHVyYXRpb24sIGVhc2luZywgY2FsbGJhY2spIHtcXG4gICAgICB2YXIgbyA9ICQuc3BlZWQoZHVyYXRpb24sIGVhc2luZywgY2FsbGJhY2spO1xcbiAgICAgIHJldHVybiB0aGlzLnF1ZXVlKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciBhbmltYXRlZCA9ICQodGhpcyksXFxuICAgICAgICAgICAgYmFzZUNsYXNzID0gYW5pbWF0ZWQuYXR0cihcXFwiY2xhc3NcXFwiKSB8fCBcXFwiXFxcIixcXG4gICAgICAgICAgICBhcHBseUNsYXNzQ2hhbmdlLFxcbiAgICAgICAgICAgIGFsbEFuaW1hdGlvbnMgPSBvLmNoaWxkcmVuID8gYW5pbWF0ZWQuZmluZChcXFwiKlxcXCIpLmFkZEJhY2soKSA6IGFuaW1hdGVkOyAvLyBtYXAgdGhlIGFuaW1hdGVkIG9iamVjdHMgdG8gc3RvcmUgdGhlIG9yaWdpbmFsIHN0eWxlcy5cXG5cXG4gICAgICAgIGFsbEFuaW1hdGlvbnMgPSBhbGxBbmltYXRpb25zLm1hcChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHZhciBlbCA9ICQodGhpcyk7XFxuICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgZWw6IGVsLFxcbiAgICAgICAgICAgIHN0YXJ0OiBnZXRFbGVtZW50U3R5bGVzKHRoaXMpXFxuICAgICAgICAgIH07XFxuICAgICAgICB9KTsgLy8gYXBwbHkgY2xhc3MgY2hhbmdlXFxuXFxuICAgICAgICBhcHBseUNsYXNzQ2hhbmdlID0gZnVuY3Rpb24gYXBwbHlDbGFzc0NoYW5nZSgpIHtcXG4gICAgICAgICAgJC5lYWNoKGNsYXNzQW5pbWF0aW9uQWN0aW9ucywgZnVuY3Rpb24gKGksIGFjdGlvbikge1xcbiAgICAgICAgICAgIGlmICh2YWx1ZVthY3Rpb25dKSB7XFxuICAgICAgICAgICAgICBhbmltYXRlZFthY3Rpb24gKyBcXFwiQ2xhc3NcXFwiXSh2YWx1ZVthY3Rpb25dKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfTtcXG5cXG4gICAgICAgIGFwcGx5Q2xhc3NDaGFuZ2UoKTsgLy8gbWFwIGFsbCBhbmltYXRlZCBvYmplY3RzIGFnYWluIC0gY2FsY3VsYXRlIG5ldyBzdHlsZXMgYW5kIGRpZmZcXG5cXG4gICAgICAgIGFsbEFuaW1hdGlvbnMgPSBhbGxBbmltYXRpb25zLm1hcChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHRoaXMuZW5kID0gZ2V0RWxlbWVudFN0eWxlcyh0aGlzLmVsWzBdKTtcXG4gICAgICAgICAgdGhpcy5kaWZmID0gc3R5bGVEaWZmZXJlbmNlKHRoaXMuc3RhcnQsIHRoaXMuZW5kKTtcXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XFxuICAgICAgICB9KTsgLy8gYXBwbHkgb3JpZ2luYWwgY2xhc3NcXG5cXG4gICAgICAgIGFuaW1hdGVkLmF0dHIoXFxcImNsYXNzXFxcIiwgYmFzZUNsYXNzKTsgLy8gbWFwIGFsbCBhbmltYXRlZCBvYmplY3RzIGFnYWluIC0gdGhpcyB0aW1lIGNvbGxlY3RpbmcgYSBwcm9taXNlXFxuXFxuICAgICAgICBhbGxBbmltYXRpb25zID0gYWxsQW5pbWF0aW9ucy5tYXAoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICB2YXIgc3R5bGVJbmZvID0gdGhpcyxcXG4gICAgICAgICAgICAgIGRmZCA9ICQuRGVmZXJyZWQoKSxcXG4gICAgICAgICAgICAgIG9wdHMgPSAkLmV4dGVuZCh7fSwgbywge1xcbiAgICAgICAgICAgIHF1ZXVlOiBmYWxzZSxcXG4gICAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gY29tcGxldGUoKSB7XFxuICAgICAgICAgICAgICBkZmQucmVzb2x2ZShzdHlsZUluZm8pO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSk7XFxuICAgICAgICAgIHRoaXMuZWwuYW5pbWF0ZSh0aGlzLmRpZmYsIG9wdHMpO1xcbiAgICAgICAgICByZXR1cm4gZGZkLnByb21pc2UoKTtcXG4gICAgICAgIH0pOyAvLyBvbmNlIGFsbCBhbmltYXRpb25zIGhhdmUgY29tcGxldGVkOlxcblxcbiAgICAgICAgJC53aGVuLmFwcGx5KCQsIGFsbEFuaW1hdGlvbnMuZ2V0KCkpLmRvbmUoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAvLyBzZXQgdGhlIGZpbmFsIGNsYXNzXFxuICAgICAgICAgIGFwcGx5Q2xhc3NDaGFuZ2UoKTsgLy8gZm9yIGVhY2ggYW5pbWF0ZWQgZWxlbWVudCxcXG4gICAgICAgICAgLy8gY2xlYXIgYWxsIGNzcyBwcm9wZXJ0aWVzIHRoYXQgd2VyZSBhbmltYXRlZFxcblxcbiAgICAgICAgICAkLmVhY2goYXJndW1lbnRzLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgdmFyIGVsID0gdGhpcy5lbDtcXG4gICAgICAgICAgICAkLmVhY2godGhpcy5kaWZmLCBmdW5jdGlvbiAoa2V5KSB7XFxuICAgICAgICAgICAgICBlbC5jc3Moa2V5LCBcXFwiXFxcIik7XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgIH0pOyAvLyB0aGlzIGlzIGd1YXJudGVlZCB0byBiZSB0aGVyZSBpZiB5b3UgdXNlIGpRdWVyeS5zcGVlZCgpXFxuICAgICAgICAgIC8vIGl0IGFsc28gaGFuZGxlcyBkZXF1ZXVpbmcgdGhlIG5leHQgYW5pbS4uLlxcblxcbiAgICAgICAgICBvLmNvbXBsZXRlLmNhbGwoYW5pbWF0ZWRbMF0pO1xcbiAgICAgICAgfSk7XFxuICAgICAgfSk7XFxuICAgIH07XFxuXFxuICAgICQuZm4uZXh0ZW5kKHtcXG4gICAgICBhZGRDbGFzczogZnVuY3Rpb24gKG9yaWcpIHtcXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoY2xhc3NOYW1lcywgc3BlZWQsIGVhc2luZywgY2FsbGJhY2spIHtcXG4gICAgICAgICAgcmV0dXJuIHNwZWVkID8gJC5lZmZlY3RzLmFuaW1hdGVDbGFzcy5jYWxsKHRoaXMsIHtcXG4gICAgICAgICAgICBhZGQ6IGNsYXNzTmFtZXNcXG4gICAgICAgICAgfSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2spIDogb3JpZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgICAgICAgfTtcXG4gICAgICB9KCQuZm4uYWRkQ2xhc3MpLFxcbiAgICAgIHJlbW92ZUNsYXNzOiBmdW5jdGlvbiAob3JpZykge1xcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjbGFzc05hbWVzLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjaykge1xcbiAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyAkLmVmZmVjdHMuYW5pbWF0ZUNsYXNzLmNhbGwodGhpcywge1xcbiAgICAgICAgICAgIHJlbW92ZTogY2xhc3NOYW1lc1xcbiAgICAgICAgICB9LCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjaykgOiBvcmlnLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICAgICAgICB9O1xcbiAgICAgIH0oJC5mbi5yZW1vdmVDbGFzcyksXFxuICAgICAgdG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uIChvcmlnKSB7XFxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGNsYXNzTmFtZXMsIGZvcmNlLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjaykge1xcbiAgICAgICAgICBpZiAodHlwZW9mIGZvcmNlID09PSBcXFwiYm9vbGVhblxcXCIgfHwgZm9yY2UgPT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgICAgIGlmICghc3BlZWQpIHtcXG4gICAgICAgICAgICAgIC8vIHdpdGhvdXQgc3BlZWQgcGFyYW1ldGVyXFxuICAgICAgICAgICAgICByZXR1cm4gb3JpZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICByZXR1cm4gJC5lZmZlY3RzLmFuaW1hdGVDbGFzcy5jYWxsKHRoaXMsIGZvcmNlID8ge1xcbiAgICAgICAgICAgICAgICBhZGQ6IGNsYXNzTmFtZXNcXG4gICAgICAgICAgICAgIH0gOiB7XFxuICAgICAgICAgICAgICAgIHJlbW92ZTogY2xhc3NOYW1lc1xcbiAgICAgICAgICAgICAgfSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2spO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAvLyB3aXRob3V0IGZvcmNlIHBhcmFtZXRlclxcbiAgICAgICAgICAgIHJldHVybiAkLmVmZmVjdHMuYW5pbWF0ZUNsYXNzLmNhbGwodGhpcywge1xcbiAgICAgICAgICAgICAgdG9nZ2xlOiBjbGFzc05hbWVzXFxuICAgICAgICAgICAgfSwgZm9yY2UsIHNwZWVkLCBlYXNpbmcpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9O1xcbiAgICAgIH0oJC5mbi50b2dnbGVDbGFzcyksXFxuICAgICAgc3dpdGNoQ2xhc3M6IGZ1bmN0aW9uIHN3aXRjaENsYXNzKHJlbW92ZSwgYWRkLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjaykge1xcbiAgICAgICAgcmV0dXJuICQuZWZmZWN0cy5hbmltYXRlQ2xhc3MuY2FsbCh0aGlzLCB7XFxuICAgICAgICAgIGFkZDogYWRkLFxcbiAgICAgICAgICByZW1vdmU6IHJlbW92ZVxcbiAgICAgICAgfSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2spO1xcbiAgICAgIH1cXG4gICAgfSk7XFxuICB9KSgpO1xcbiAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG5cXG4gIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBFRkZFQ1RTICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuXFxuICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcblxcblxcbiAgKGZ1bmN0aW9uICgpIHtcXG4gICAgJC5leHRlbmQoJC5lZmZlY3RzLCB7XFxuICAgICAgdmVyc2lvbjogXFxcIjEuMTEuNFxcXCIsXFxuICAgICAgLy8gU2F2ZXMgYSBzZXQgb2YgcHJvcGVydGllcyBpbiBhIGRhdGEgc3RvcmFnZVxcbiAgICAgIHNhdmU6IGZ1bmN0aW9uIHNhdmUoZWxlbWVudCwgc2V0KSB7XFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgICBpZiAoc2V0W2ldICE9PSBudWxsKSB7XFxuICAgICAgICAgICAgZWxlbWVudC5kYXRhKGRhdGFTcGFjZSArIHNldFtpXSwgZWxlbWVudFswXS5zdHlsZVtzZXRbaV1dKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH0sXFxuICAgICAgLy8gUmVzdG9yZXMgYSBzZXQgb2YgcHJldmlvdXNseSBzYXZlZCBwcm9wZXJ0aWVzIGZyb20gYSBkYXRhIHN0b3JhZ2VcXG4gICAgICByZXN0b3JlOiBmdW5jdGlvbiByZXN0b3JlKGVsZW1lbnQsIHNldCkge1xcbiAgICAgICAgdmFyIHZhbCwgaTtcXG5cXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgaWYgKHNldFtpXSAhPT0gbnVsbCkge1xcbiAgICAgICAgICAgIHZhbCA9IGVsZW1lbnQuZGF0YShkYXRhU3BhY2UgKyBzZXRbaV0pOyAvLyBzdXBwb3J0OiBqUXVlcnkgMS42LjJcXG4gICAgICAgICAgICAvLyBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC85OTE3XFxuICAgICAgICAgICAgLy8galF1ZXJ5IDEuNi4yIGluY29ycmVjdGx5IHJldHVybnMgdW5kZWZpbmVkIGZvciBhbnkgZmFsc3kgdmFsdWUuXFxuICAgICAgICAgICAgLy8gV2UgY2FuJ3QgZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIFxcXCJcXFwiIGFuZCAwIGhlcmUsIHNvIHdlIGp1c3QgYXNzdW1lXFxuICAgICAgICAgICAgLy8gZW1wdHkgc3RyaW5nIHNpbmNlIGl0J3MgbGlrZWx5IHRvIGJlIGEgbW9yZSBjb21tb24gdmFsdWUuLi5cXG5cXG4gICAgICAgICAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcXG4gICAgICAgICAgICAgIHZhbCA9IFxcXCJcXFwiO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBlbGVtZW50LmNzcyhzZXRbaV0sIHZhbCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9LFxcbiAgICAgIHNldE1vZGU6IGZ1bmN0aW9uIHNldE1vZGUoZWwsIG1vZGUpIHtcXG4gICAgICAgIGlmIChtb2RlID09PSBcXFwidG9nZ2xlXFxcIikge1xcbiAgICAgICAgICBtb2RlID0gZWwuaXMoXFxcIjpoaWRkZW5cXFwiKSA/IFxcXCJzaG93XFxcIiA6IFxcXCJoaWRlXFxcIjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiBtb2RlO1xcbiAgICAgIH0sXFxuICAgICAgLy8gVHJhbnNsYXRlcyBhIFt0b3AsbGVmdF0gYXJyYXkgaW50byBhIGJhc2VsaW5lIHZhbHVlXFxuICAgICAgLy8gdGhpcyBzaG91bGQgYmUgYSBsaXR0bGUgbW9yZSBmbGV4aWJsZSBpbiB0aGUgZnV0dXJlIHRvIGhhbmRsZSBhIHN0cmluZyAmIGhhc2hcXG4gICAgICBnZXRCYXNlbGluZTogZnVuY3Rpb24gZ2V0QmFzZWxpbmUob3JpZ2luLCBvcmlnaW5hbCkge1xcbiAgICAgICAgdmFyIHksIHg7XFxuXFxuICAgICAgICBzd2l0Y2ggKG9yaWdpblswXSkge1xcbiAgICAgICAgICBjYXNlIFxcXCJ0b3BcXFwiOlxcbiAgICAgICAgICAgIHkgPSAwO1xcbiAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICBjYXNlIFxcXCJtaWRkbGVcXFwiOlxcbiAgICAgICAgICAgIHkgPSAwLjU7XFxuICAgICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICAgIGNhc2UgXFxcImJvdHRvbVxcXCI6XFxuICAgICAgICAgICAgeSA9IDE7XFxuICAgICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICAgIGRlZmF1bHQ6XFxuICAgICAgICAgICAgeSA9IG9yaWdpblswXSAvIG9yaWdpbmFsLmhlaWdodDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHN3aXRjaCAob3JpZ2luWzFdKSB7XFxuICAgICAgICAgIGNhc2UgXFxcImxlZnRcXFwiOlxcbiAgICAgICAgICAgIHggPSAwO1xcbiAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICBjYXNlIFxcXCJjZW50ZXJcXFwiOlxcbiAgICAgICAgICAgIHggPSAwLjU7XFxuICAgICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICAgIGNhc2UgXFxcInJpZ2h0XFxcIjpcXG4gICAgICAgICAgICB4ID0gMTtcXG4gICAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgICAgZGVmYXVsdDpcXG4gICAgICAgICAgICB4ID0gb3JpZ2luWzFdIC8gb3JpZ2luYWwud2lkdGg7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICB4OiB4LFxcbiAgICAgICAgICB5OiB5XFxuICAgICAgICB9O1xcbiAgICAgIH0sXFxuICAgICAgLy8gV3JhcHMgdGhlIGVsZW1lbnQgYXJvdW5kIGEgd3JhcHBlciB0aGF0IGNvcGllcyBwb3NpdGlvbiBwcm9wZXJ0aWVzXFxuICAgICAgY3JlYXRlV3JhcHBlcjogZnVuY3Rpb24gY3JlYXRlV3JhcHBlcihlbGVtZW50KSB7XFxuICAgICAgICAvLyBpZiB0aGUgZWxlbWVudCBpcyBhbHJlYWR5IHdyYXBwZWQsIHJldHVybiBpdFxcbiAgICAgICAgaWYgKGVsZW1lbnQucGFyZW50KCkuaXMoXFxcIi51aS1lZmZlY3RzLXdyYXBwZXJcXFwiKSkge1xcbiAgICAgICAgICByZXR1cm4gZWxlbWVudC5wYXJlbnQoKTtcXG4gICAgICAgIH0gLy8gd3JhcCB0aGUgZWxlbWVudFxcblxcblxcbiAgICAgICAgdmFyIHByb3BzID0ge1xcbiAgICAgICAgICB3aWR0aDogZWxlbWVudC5vdXRlcldpZHRoKHRydWUpLFxcbiAgICAgICAgICBoZWlnaHQ6IGVsZW1lbnQub3V0ZXJIZWlnaHQodHJ1ZSksXFxuICAgICAgICAgIFxcXCJmbG9hdFxcXCI6IGVsZW1lbnQuY3NzKFxcXCJmbG9hdFxcXCIpXFxuICAgICAgICB9LFxcbiAgICAgICAgICAgIHdyYXBwZXIgPSAkKFxcXCI8ZGl2PjwvZGl2PlxcXCIpLmFkZENsYXNzKFxcXCJ1aS1lZmZlY3RzLXdyYXBwZXJcXFwiKS5jc3Moe1xcbiAgICAgICAgICBmb250U2l6ZTogXFxcIjEwMCVcXFwiLFxcbiAgICAgICAgICBiYWNrZ3JvdW5kOiBcXFwidHJhbnNwYXJlbnRcXFwiLFxcbiAgICAgICAgICBib3JkZXI6IFxcXCJub25lXFxcIixcXG4gICAgICAgICAgbWFyZ2luOiAwLFxcbiAgICAgICAgICBwYWRkaW5nOiAwXFxuICAgICAgICB9KSxcXG4gICAgICAgICAgICAvLyBTdG9yZSB0aGUgc2l6ZSBpbiBjYXNlIHdpZHRoL2hlaWdodCBhcmUgZGVmaW5lZCBpbiAlIC0gRml4ZXMgIzUyNDVcXG4gICAgICAgIHNpemUgPSB7XFxuICAgICAgICAgIHdpZHRoOiBlbGVtZW50LndpZHRoKCksXFxuICAgICAgICAgIGhlaWdodDogZWxlbWVudC5oZWlnaHQoKVxcbiAgICAgICAgfSxcXG4gICAgICAgICAgICBhY3RpdmUgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50OyAvLyBzdXBwb3J0OiBGaXJlZm94XFxuICAgICAgICAvLyBGaXJlZm94IGluY29ycmVjdGx5IGV4cG9zZXMgYW5vbnltb3VzIGNvbnRlbnRcXG4gICAgICAgIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTU2MTY2NFxcblxcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgYWN0aXZlLmlkO1xcbiAgICAgICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgICBhY3RpdmUgPSBkb2N1bWVudC5ib2R5O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZWxlbWVudC53cmFwKHdyYXBwZXIpOyAvLyBGaXhlcyAjNzU5NSAtIEVsZW1lbnRzIGxvc2UgZm9jdXMgd2hlbiB3cmFwcGVkLlxcblxcbiAgICAgICAgaWYgKGVsZW1lbnRbMF0gPT09IGFjdGl2ZSB8fCAkLmNvbnRhaW5zKGVsZW1lbnRbMF0sIGFjdGl2ZSkpIHtcXG4gICAgICAgICAgJChhY3RpdmUpLmZvY3VzKCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB3cmFwcGVyID0gZWxlbWVudC5wYXJlbnQoKTsgLy9Ib3RmaXggZm9yIGpRdWVyeSAxLjQgc2luY2Ugc29tZSBjaGFuZ2UgaW4gd3JhcCgpIHNlZW1zIHRvIGFjdHVhbGx5IGxvc2UgdGhlIHJlZmVyZW5jZSB0byB0aGUgd3JhcHBlZCBlbGVtZW50XFxuICAgICAgICAvLyB0cmFuc2ZlciBwb3NpdGlvbmluZyBwcm9wZXJ0aWVzIHRvIHRoZSB3cmFwcGVyXFxuXFxuICAgICAgICBpZiAoZWxlbWVudC5jc3MoXFxcInBvc2l0aW9uXFxcIikgPT09IFxcXCJzdGF0aWNcXFwiKSB7XFxuICAgICAgICAgIHdyYXBwZXIuY3NzKHtcXG4gICAgICAgICAgICBwb3NpdGlvbjogXFxcInJlbGF0aXZlXFxcIlxcbiAgICAgICAgICB9KTtcXG4gICAgICAgICAgZWxlbWVudC5jc3Moe1xcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcXFwicmVsYXRpdmVcXFwiXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgJC5leHRlbmQocHJvcHMsIHtcXG4gICAgICAgICAgICBwb3NpdGlvbjogZWxlbWVudC5jc3MoXFxcInBvc2l0aW9uXFxcIiksXFxuICAgICAgICAgICAgekluZGV4OiBlbGVtZW50LmNzcyhcXFwiei1pbmRleFxcXCIpXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgICAkLmVhY2goW1xcXCJ0b3BcXFwiLCBcXFwibGVmdFxcXCIsIFxcXCJib3R0b21cXFwiLCBcXFwicmlnaHRcXFwiXSwgZnVuY3Rpb24gKGksIHBvcykge1xcbiAgICAgICAgICAgIHByb3BzW3Bvc10gPSBlbGVtZW50LmNzcyhwb3MpO1xcblxcbiAgICAgICAgICAgIGlmIChpc05hTihwYXJzZUludChwcm9wc1twb3NdLCAxMCkpKSB7XFxuICAgICAgICAgICAgICBwcm9wc1twb3NdID0gXFxcImF1dG9cXFwiO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSk7XFxuICAgICAgICAgIGVsZW1lbnQuY3NzKHtcXG4gICAgICAgICAgICBwb3NpdGlvbjogXFxcInJlbGF0aXZlXFxcIixcXG4gICAgICAgICAgICB0b3A6IDAsXFxuICAgICAgICAgICAgbGVmdDogMCxcXG4gICAgICAgICAgICByaWdodDogXFxcImF1dG9cXFwiLFxcbiAgICAgICAgICAgIGJvdHRvbTogXFxcImF1dG9cXFwiXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZWxlbWVudC5jc3Moc2l6ZSk7XFxuICAgICAgICByZXR1cm4gd3JhcHBlci5jc3MocHJvcHMpLnNob3coKTtcXG4gICAgICB9LFxcbiAgICAgIHJlbW92ZVdyYXBwZXI6IGZ1bmN0aW9uIHJlbW92ZVdyYXBwZXIoZWxlbWVudCkge1xcbiAgICAgICAgdmFyIGFjdGl2ZSA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XFxuXFxuICAgICAgICBpZiAoZWxlbWVudC5wYXJlbnQoKS5pcyhcXFwiLnVpLWVmZmVjdHMtd3JhcHBlclxcXCIpKSB7XFxuICAgICAgICAgIGVsZW1lbnQucGFyZW50KCkucmVwbGFjZVdpdGgoZWxlbWVudCk7IC8vIEZpeGVzICM3NTk1IC0gRWxlbWVudHMgbG9zZSBmb2N1cyB3aGVuIHdyYXBwZWQuXFxuXFxuICAgICAgICAgIGlmIChlbGVtZW50WzBdID09PSBhY3RpdmUgfHwgJC5jb250YWlucyhlbGVtZW50WzBdLCBhY3RpdmUpKSB7XFxuICAgICAgICAgICAgJChhY3RpdmUpLmZvY3VzKCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiBlbGVtZW50O1xcbiAgICAgIH0sXFxuICAgICAgc2V0VHJhbnNpdGlvbjogZnVuY3Rpb24gc2V0VHJhbnNpdGlvbihlbGVtZW50LCBsaXN0LCBmYWN0b3IsIHZhbHVlKSB7XFxuICAgICAgICB2YWx1ZSA9IHZhbHVlIHx8IHt9O1xcbiAgICAgICAgJC5lYWNoKGxpc3QsIGZ1bmN0aW9uIChpLCB4KSB7XFxuICAgICAgICAgIHZhciB1bml0ID0gZWxlbWVudC5jc3NVbml0KHgpO1xcblxcbiAgICAgICAgICBpZiAodW5pdFswXSA+IDApIHtcXG4gICAgICAgICAgICB2YWx1ZVt4XSA9IHVuaXRbMF0gKiBmYWN0b3IgKyB1bml0WzFdO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgICAgIHJldHVybiB2YWx1ZTtcXG4gICAgICB9XFxuICAgIH0pOyAvLyByZXR1cm4gYW4gZWZmZWN0IG9wdGlvbnMgb2JqZWN0IGZvciB0aGUgZ2l2ZW4gcGFyYW1ldGVyczpcXG5cXG4gICAgZnVuY3Rpb24gX25vcm1hbGl6ZUFyZ3VtZW50cyhlZmZlY3QsIG9wdGlvbnMsIHNwZWVkLCBjYWxsYmFjaykge1xcbiAgICAgIC8vIGFsbG93IHBhc3NpbmcgYWxsIG9wdGlvbnMgYXMgdGhlIGZpcnN0IHBhcmFtZXRlclxcbiAgICAgIGlmICgkLmlzUGxhaW5PYmplY3QoZWZmZWN0KSkge1xcbiAgICAgICAgb3B0aW9ucyA9IGVmZmVjdDtcXG4gICAgICAgIGVmZmVjdCA9IGVmZmVjdC5lZmZlY3Q7XFxuICAgICAgfSAvLyBjb252ZXJ0IHRvIGFuIG9iamVjdFxcblxcblxcbiAgICAgIGVmZmVjdCA9IHtcXG4gICAgICAgIGVmZmVjdDogZWZmZWN0XFxuICAgICAgfTsgLy8gY2F0Y2ggKGVmZmVjdCwgbnVsbCwgLi4uKVxcblxcbiAgICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcXG4gICAgICAgIG9wdGlvbnMgPSB7fTtcXG4gICAgICB9IC8vIGNhdGNoIChlZmZlY3QsIGNhbGxiYWNrKVxcblxcblxcbiAgICAgIGlmICgkLmlzRnVuY3Rpb24ob3B0aW9ucykpIHtcXG4gICAgICAgIGNhbGxiYWNrID0gb3B0aW9ucztcXG4gICAgICAgIHNwZWVkID0gbnVsbDtcXG4gICAgICAgIG9wdGlvbnMgPSB7fTtcXG4gICAgICB9IC8vIGNhdGNoIChlZmZlY3QsIHNwZWVkLCA/KVxcblxcblxcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXFxcIm51bWJlclxcXCIgfHwgJC5meC5zcGVlZHNbb3B0aW9uc10pIHtcXG4gICAgICAgIGNhbGxiYWNrID0gc3BlZWQ7XFxuICAgICAgICBzcGVlZCA9IG9wdGlvbnM7XFxuICAgICAgICBvcHRpb25zID0ge307XFxuICAgICAgfSAvLyBjYXRjaCAoZWZmZWN0LCBvcHRpb25zLCBjYWxsYmFjaylcXG5cXG5cXG4gICAgICBpZiAoJC5pc0Z1bmN0aW9uKHNwZWVkKSkge1xcbiAgICAgICAgY2FsbGJhY2sgPSBzcGVlZDtcXG4gICAgICAgIHNwZWVkID0gbnVsbDtcXG4gICAgICB9IC8vIGFkZCBvcHRpb25zIHRvIGVmZmVjdFxcblxcblxcbiAgICAgIGlmIChvcHRpb25zKSB7XFxuICAgICAgICAkLmV4dGVuZChlZmZlY3QsIG9wdGlvbnMpO1xcbiAgICAgIH1cXG5cXG4gICAgICBzcGVlZCA9IHNwZWVkIHx8IG9wdGlvbnMuZHVyYXRpb247XFxuICAgICAgZWZmZWN0LmR1cmF0aW9uID0gJC5meC5vZmYgPyAwIDogdHlwZW9mIHNwZWVkID09PSBcXFwibnVtYmVyXFxcIiA/IHNwZWVkIDogc3BlZWQgaW4gJC5meC5zcGVlZHMgPyAkLmZ4LnNwZWVkc1tzcGVlZF0gOiAkLmZ4LnNwZWVkcy5fZGVmYXVsdDtcXG4gICAgICBlZmZlY3QuY29tcGxldGUgPSBjYWxsYmFjayB8fCBvcHRpb25zLmNvbXBsZXRlO1xcbiAgICAgIHJldHVybiBlZmZlY3Q7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gc3RhbmRhcmRBbmltYXRpb25PcHRpb24ob3B0aW9uKSB7XFxuICAgICAgLy8gVmFsaWQgc3RhbmRhcmQgc3BlZWRzIChub3RoaW5nLCBudW1iZXIsIG5hbWVkIHNwZWVkKVxcbiAgICAgIGlmICghb3B0aW9uIHx8IHR5cGVvZiBvcHRpb24gPT09IFxcXCJudW1iZXJcXFwiIHx8ICQuZnguc3BlZWRzW29wdGlvbl0pIHtcXG4gICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgIH0gLy8gSW52YWxpZCBzdHJpbmdzIC0gdHJlYXQgYXMgXFxcIm5vcm1hbFxcXCIgc3BlZWRcXG5cXG5cXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbiA9PT0gXFxcInN0cmluZ1xcXCIgJiYgISQuZWZmZWN0cy5lZmZlY3Rbb3B0aW9uXSkge1xcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgfSAvLyBDb21wbGV0ZSBjYWxsYmFja1xcblxcblxcbiAgICAgIGlmICgkLmlzRnVuY3Rpb24ob3B0aW9uKSkge1xcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgfSAvLyBPcHRpb25zIGhhc2ggKGJ1dCBub3QgbmFtaW5nIGFuIGVmZmVjdClcXG5cXG5cXG4gICAgICBpZiAoX3R5cGVvZihvcHRpb24pID09PSBcXFwib2JqZWN0XFxcIiAmJiAhb3B0aW9uLmVmZmVjdCkge1xcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgfSAvLyBEaWRuJ3QgbWF0Y2ggYW55IHN0YW5kYXJkIEFQSVxcblxcblxcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcblxcbiAgICAkLmZuLmV4dGVuZCh7XFxuICAgICAgZWZmZWN0OiBmdW5jdGlvbiBlZmZlY3QoKVxcbiAgICAgIC8qIGVmZmVjdCwgb3B0aW9ucywgc3BlZWQsIGNhbGxiYWNrICovXFxuICAgICAge1xcbiAgICAgICAgdmFyIGFyZ3MgPSBfbm9ybWFsaXplQXJndW1lbnRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXFxuICAgICAgICAgICAgbW9kZSA9IGFyZ3MubW9kZSxcXG4gICAgICAgICAgICBxdWV1ZSA9IGFyZ3MucXVldWUsXFxuICAgICAgICAgICAgZWZmZWN0TWV0aG9kID0gJC5lZmZlY3RzLmVmZmVjdFthcmdzLmVmZmVjdF07XFxuXFxuICAgICAgICBpZiAoJC5meC5vZmYgfHwgIWVmZmVjdE1ldGhvZCkge1xcbiAgICAgICAgICAvLyBkZWxlZ2F0ZSB0byB0aGUgb3JpZ2luYWwgbWV0aG9kIChlLmcuLCAuc2hvdygpKSBpZiBwb3NzaWJsZVxcbiAgICAgICAgICBpZiAobW9kZSkge1xcbiAgICAgICAgICAgIHJldHVybiB0aGlzW21vZGVdKGFyZ3MuZHVyYXRpb24sIGFyZ3MuY29tcGxldGUpO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgaWYgKGFyZ3MuY29tcGxldGUpIHtcXG4gICAgICAgICAgICAgICAgYXJncy5jb21wbGV0ZS5jYWxsKHRoaXMpO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICBmdW5jdGlvbiBydW4obmV4dCkge1xcbiAgICAgICAgICB2YXIgZWxlbSA9ICQodGhpcyksXFxuICAgICAgICAgICAgICBjb21wbGV0ZSA9IGFyZ3MuY29tcGxldGUsXFxuICAgICAgICAgICAgICBtb2RlID0gYXJncy5tb2RlO1xcblxcbiAgICAgICAgICBmdW5jdGlvbiBkb25lKCkge1xcbiAgICAgICAgICAgIGlmICgkLmlzRnVuY3Rpb24oY29tcGxldGUpKSB7XFxuICAgICAgICAgICAgICBjb21wbGV0ZS5jYWxsKGVsZW1bMF0pO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpZiAoJC5pc0Z1bmN0aW9uKG5leHQpKSB7XFxuICAgICAgICAgICAgICBuZXh0KCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9IC8vIElmIHRoZSBlbGVtZW50IGFscmVhZHkgaGFzIHRoZSBjb3JyZWN0IGZpbmFsIHN0YXRlLCBkZWxlZ2F0ZSB0b1xcbiAgICAgICAgICAvLyB0aGUgY29yZSBtZXRob2RzIHNvIHRoZSBpbnRlcm5hbCB0cmFja2luZyBvZiBcXFwib2xkZGlzcGxheVxcXCIgd29ya3MuXFxuXFxuXFxuICAgICAgICAgIGlmIChlbGVtLmlzKFxcXCI6aGlkZGVuXFxcIikgPyBtb2RlID09PSBcXFwiaGlkZVxcXCIgOiBtb2RlID09PSBcXFwic2hvd1xcXCIpIHtcXG4gICAgICAgICAgICBlbGVtW21vZGVdKCk7XFxuICAgICAgICAgICAgZG9uZSgpO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGVmZmVjdE1ldGhvZC5jYWxsKGVsZW1bMF0sIGFyZ3MsIGRvbmUpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gcXVldWUgPT09IGZhbHNlID8gdGhpcy5lYWNoKHJ1bikgOiB0aGlzLnF1ZXVlKHF1ZXVlIHx8IFxcXCJmeFxcXCIsIHJ1bik7XFxuICAgICAgfSxcXG4gICAgICBzaG93OiBmdW5jdGlvbiAob3JpZykge1xcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChvcHRpb24pIHtcXG4gICAgICAgICAgaWYgKHN0YW5kYXJkQW5pbWF0aW9uT3B0aW9uKG9wdGlvbikpIHtcXG4gICAgICAgICAgICByZXR1cm4gb3JpZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHZhciBhcmdzID0gX25vcm1hbGl6ZUFyZ3VtZW50cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcblxcbiAgICAgICAgICAgIGFyZ3MubW9kZSA9IFxcXCJzaG93XFxcIjtcXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lZmZlY3QuY2FsbCh0aGlzLCBhcmdzKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfTtcXG4gICAgICB9KCQuZm4uc2hvdyksXFxuICAgICAgaGlkZTogZnVuY3Rpb24gKG9yaWcpIHtcXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAob3B0aW9uKSB7XFxuICAgICAgICAgIGlmIChzdGFuZGFyZEFuaW1hdGlvbk9wdGlvbihvcHRpb24pKSB7XFxuICAgICAgICAgICAgcmV0dXJuIG9yaWcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICB2YXIgYXJncyA9IF9ub3JtYWxpemVBcmd1bWVudHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG5cXG4gICAgICAgICAgICBhcmdzLm1vZGUgPSBcXFwiaGlkZVxcXCI7XFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWZmZWN0LmNhbGwodGhpcywgYXJncyk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH07XFxuICAgICAgfSgkLmZuLmhpZGUpLFxcbiAgICAgIHRvZ2dsZTogZnVuY3Rpb24gKG9yaWcpIHtcXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAob3B0aW9uKSB7XFxuICAgICAgICAgIGlmIChzdGFuZGFyZEFuaW1hdGlvbk9wdGlvbihvcHRpb24pIHx8IHR5cGVvZiBvcHRpb24gPT09IFxcXCJib29sZWFuXFxcIikge1xcbiAgICAgICAgICAgIHJldHVybiBvcmlnLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBfbm9ybWFsaXplQXJndW1lbnRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuXFxuICAgICAgICAgICAgYXJncy5tb2RlID0gXFxcInRvZ2dsZVxcXCI7XFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWZmZWN0LmNhbGwodGhpcywgYXJncyk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH07XFxuICAgICAgfSgkLmZuLnRvZ2dsZSksXFxuICAgICAgLy8gaGVscGVyIGZ1bmN0aW9uc1xcbiAgICAgIGNzc1VuaXQ6IGZ1bmN0aW9uIGNzc1VuaXQoa2V5KSB7XFxuICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLmNzcyhrZXkpLFxcbiAgICAgICAgICAgIHZhbCA9IFtdO1xcbiAgICAgICAgJC5lYWNoKFtcXFwiZW1cXFwiLCBcXFwicHhcXFwiLCBcXFwiJVxcXCIsIFxcXCJwdFxcXCJdLCBmdW5jdGlvbiAoaSwgdW5pdCkge1xcbiAgICAgICAgICBpZiAoc3R5bGUuaW5kZXhPZih1bml0KSA+IDApIHtcXG4gICAgICAgICAgICB2YWwgPSBbcGFyc2VGbG9hdChzdHlsZSksIHVuaXRdO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgICAgIHJldHVybiB2YWw7XFxuICAgICAgfVxcbiAgICB9KTtcXG4gIH0pKCk7XFxuICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcblxcbiAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqIEVBU0lORyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG5cXG4gIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuXFxuXFxuICAoZnVuY3Rpb24gKCkge1xcbiAgICAvLyBiYXNlZCBvbiBlYXNpbmcgZXF1YXRpb25zIGZyb20gUm9iZXJ0IFBlbm5lciAoaHR0cDovL3d3dy5yb2JlcnRwZW5uZXIuY29tL2Vhc2luZylcXG4gICAgdmFyIGJhc2VFYXNpbmdzID0ge307XFxuICAgICQuZWFjaChbXFxcIlF1YWRcXFwiLCBcXFwiQ3ViaWNcXFwiLCBcXFwiUXVhcnRcXFwiLCBcXFwiUXVpbnRcXFwiLCBcXFwiRXhwb1xcXCJdLCBmdW5jdGlvbiAoaSwgbmFtZSkge1xcbiAgICAgIGJhc2VFYXNpbmdzW25hbWVdID0gZnVuY3Rpb24gKHApIHtcXG4gICAgICAgIHJldHVybiBNYXRoLnBvdyhwLCBpICsgMik7XFxuICAgICAgfTtcXG4gICAgfSk7XFxuICAgICQuZXh0ZW5kKGJhc2VFYXNpbmdzLCB7XFxuICAgICAgU2luZTogZnVuY3Rpb24gU2luZShwKSB7XFxuICAgICAgICByZXR1cm4gMSAtIE1hdGguY29zKHAgKiBNYXRoLlBJIC8gMik7XFxuICAgICAgfSxcXG4gICAgICBDaXJjOiBmdW5jdGlvbiBDaXJjKHApIHtcXG4gICAgICAgIHJldHVybiAxIC0gTWF0aC5zcXJ0KDEgLSBwICogcCk7XFxuICAgICAgfSxcXG4gICAgICBFbGFzdGljOiBmdW5jdGlvbiBFbGFzdGljKHApIHtcXG4gICAgICAgIHJldHVybiBwID09PSAwIHx8IHAgPT09IDEgPyBwIDogLU1hdGgucG93KDIsIDggKiAocCAtIDEpKSAqIE1hdGguc2luKCgocCAtIDEpICogODAgLSA3LjUpICogTWF0aC5QSSAvIDE1KTtcXG4gICAgICB9LFxcbiAgICAgIEJhY2s6IGZ1bmN0aW9uIEJhY2socCkge1xcbiAgICAgICAgcmV0dXJuIHAgKiBwICogKDMgKiBwIC0gMik7XFxuICAgICAgfSxcXG4gICAgICBCb3VuY2U6IGZ1bmN0aW9uIEJvdW5jZShwKSB7XFxuICAgICAgICB2YXIgcG93MixcXG4gICAgICAgICAgICBib3VuY2UgPSA0O1xcblxcbiAgICAgICAgd2hpbGUgKHAgPCAoKHBvdzIgPSBNYXRoLnBvdygyLCAtLWJvdW5jZSkpIC0gMSkgLyAxMSkge31cXG5cXG4gICAgICAgIHJldHVybiAxIC8gTWF0aC5wb3coNCwgMyAtIGJvdW5jZSkgLSA3LjU2MjUgKiBNYXRoLnBvdygocG93MiAqIDMgLSAyKSAvIDIyIC0gcCwgMik7XFxuICAgICAgfVxcbiAgICB9KTtcXG4gICAgJC5lYWNoKGJhc2VFYXNpbmdzLCBmdW5jdGlvbiAobmFtZSwgZWFzZUluKSB7XFxuICAgICAgJC5lYXNpbmdbXFxcImVhc2VJblxcXCIgKyBuYW1lXSA9IGVhc2VJbjtcXG5cXG4gICAgICAkLmVhc2luZ1tcXFwiZWFzZU91dFxcXCIgKyBuYW1lXSA9IGZ1bmN0aW9uIChwKSB7XFxuICAgICAgICByZXR1cm4gMSAtIGVhc2VJbigxIC0gcCk7XFxuICAgICAgfTtcXG5cXG4gICAgICAkLmVhc2luZ1tcXFwiZWFzZUluT3V0XFxcIiArIG5hbWVdID0gZnVuY3Rpb24gKHApIHtcXG4gICAgICAgIHJldHVybiBwIDwgMC41ID8gZWFzZUluKHAgKiAyKSAvIDIgOiAxIC0gZWFzZUluKHAgKiAtMiArIDIpIC8gMjtcXG4gICAgICB9O1xcbiAgICB9KTtcXG4gIH0pKCk7XFxuXFxuICB2YXIgZWZmZWN0ID0gJC5lZmZlY3RzO1xcbiAgLyohXFxuICAgKiBqUXVlcnkgVUkgRWZmZWN0cyBCbGluZCAxLjExLjRcXG4gICAqIGh0dHA6Ly9qcXVlcnl1aS5jb21cXG4gICAqXFxuICAgKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xcbiAgICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxcbiAgICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxcbiAgICpcXG4gICAqIGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL2JsaW5kLWVmZmVjdC9cXG4gICAqL1xcblxcbiAgdmFyIGVmZmVjdEJsaW5kID0gJC5lZmZlY3RzLmVmZmVjdC5ibGluZCA9IGZ1bmN0aW9uIChvLCBkb25lKSB7XFxuICAgIC8vIENyZWF0ZSBlbGVtZW50XFxuICAgIHZhciBlbCA9ICQodGhpcyksXFxuICAgICAgICBydmVydGljYWwgPSAvdXB8ZG93bnx2ZXJ0aWNhbC8sXFxuICAgICAgICBycG9zaXRpdmVtb3Rpb24gPSAvdXB8bGVmdHx2ZXJ0aWNhbHxob3Jpem9udGFsLyxcXG4gICAgICAgIHByb3BzID0gW1xcXCJwb3NpdGlvblxcXCIsIFxcXCJ0b3BcXFwiLCBcXFwiYm90dG9tXFxcIiwgXFxcImxlZnRcXFwiLCBcXFwicmlnaHRcXFwiLCBcXFwiaGVpZ2h0XFxcIiwgXFxcIndpZHRoXFxcIl0sXFxuICAgICAgICBtb2RlID0gJC5lZmZlY3RzLnNldE1vZGUoZWwsIG8ubW9kZSB8fCBcXFwiaGlkZVxcXCIpLFxcbiAgICAgICAgZGlyZWN0aW9uID0gby5kaXJlY3Rpb24gfHwgXFxcInVwXFxcIixcXG4gICAgICAgIHZlcnRpY2FsID0gcnZlcnRpY2FsLnRlc3QoZGlyZWN0aW9uKSxcXG4gICAgICAgIHJlZiA9IHZlcnRpY2FsID8gXFxcImhlaWdodFxcXCIgOiBcXFwid2lkdGhcXFwiLFxcbiAgICAgICAgcmVmMiA9IHZlcnRpY2FsID8gXFxcInRvcFxcXCIgOiBcXFwibGVmdFxcXCIsXFxuICAgICAgICBtb3Rpb24gPSBycG9zaXRpdmVtb3Rpb24udGVzdChkaXJlY3Rpb24pLFxcbiAgICAgICAgYW5pbWF0aW9uID0ge30sXFxuICAgICAgICBzaG93ID0gbW9kZSA9PT0gXFxcInNob3dcXFwiLFxcbiAgICAgICAgd3JhcHBlcixcXG4gICAgICAgIGRpc3RhbmNlLFxcbiAgICAgICAgbWFyZ2luOyAvLyBpZiBhbHJlYWR5IHdyYXBwZWQsIHRoZSB3cmFwcGVyJ3MgcHJvcGVydGllcyBhcmUgbXkgcHJvcGVydHkuICM2MjQ1XFxuXFxuICAgIGlmIChlbC5wYXJlbnQoKS5pcyhcXFwiLnVpLWVmZmVjdHMtd3JhcHBlclxcXCIpKSB7XFxuICAgICAgJC5lZmZlY3RzLnNhdmUoZWwucGFyZW50KCksIHByb3BzKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAkLmVmZmVjdHMuc2F2ZShlbCwgcHJvcHMpO1xcbiAgICB9XFxuXFxuICAgIGVsLnNob3coKTtcXG4gICAgd3JhcHBlciA9ICQuZWZmZWN0cy5jcmVhdGVXcmFwcGVyKGVsKS5jc3Moe1xcbiAgICAgIG92ZXJmbG93OiBcXFwiaGlkZGVuXFxcIlxcbiAgICB9KTtcXG4gICAgZGlzdGFuY2UgPSB3cmFwcGVyW3JlZl0oKTtcXG4gICAgbWFyZ2luID0gcGFyc2VGbG9hdCh3cmFwcGVyLmNzcyhyZWYyKSkgfHwgMDtcXG4gICAgYW5pbWF0aW9uW3JlZl0gPSBzaG93ID8gZGlzdGFuY2UgOiAwO1xcblxcbiAgICBpZiAoIW1vdGlvbikge1xcbiAgICAgIGVsLmNzcyh2ZXJ0aWNhbCA/IFxcXCJib3R0b21cXFwiIDogXFxcInJpZ2h0XFxcIiwgMCkuY3NzKHZlcnRpY2FsID8gXFxcInRvcFxcXCIgOiBcXFwibGVmdFxcXCIsIFxcXCJhdXRvXFxcIikuY3NzKHtcXG4gICAgICAgIHBvc2l0aW9uOiBcXFwiYWJzb2x1dGVcXFwiXFxuICAgICAgfSk7XFxuICAgICAgYW5pbWF0aW9uW3JlZjJdID0gc2hvdyA/IG1hcmdpbiA6IGRpc3RhbmNlICsgbWFyZ2luO1xcbiAgICB9IC8vIHN0YXJ0IGF0IDAgaWYgd2UgYXJlIHNob3dpbmdcXG5cXG5cXG4gICAgaWYgKHNob3cpIHtcXG4gICAgICB3cmFwcGVyLmNzcyhyZWYsIDApO1xcblxcbiAgICAgIGlmICghbW90aW9uKSB7XFxuICAgICAgICB3cmFwcGVyLmNzcyhyZWYyLCBtYXJnaW4gKyBkaXN0YW5jZSk7XFxuICAgICAgfVxcbiAgICB9IC8vIEFuaW1hdGVcXG5cXG5cXG4gICAgd3JhcHBlci5hbmltYXRlKGFuaW1hdGlvbiwge1xcbiAgICAgIGR1cmF0aW9uOiBvLmR1cmF0aW9uLFxcbiAgICAgIGVhc2luZzogby5lYXNpbmcsXFxuICAgICAgcXVldWU6IGZhbHNlLFxcbiAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiBjb21wbGV0ZSgpIHtcXG4gICAgICAgIGlmIChtb2RlID09PSBcXFwiaGlkZVxcXCIpIHtcXG4gICAgICAgICAgZWwuaGlkZSgpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgJC5lZmZlY3RzLnJlc3RvcmUoZWwsIHByb3BzKTtcXG4gICAgICAgICQuZWZmZWN0cy5yZW1vdmVXcmFwcGVyKGVsKTtcXG4gICAgICAgIGRvbmUoKTtcXG4gICAgICB9XFxuICAgIH0pO1xcbiAgfTtcXG4gIC8qIVxcbiAgICogalF1ZXJ5IFVJIEVmZmVjdHMgQm91bmNlIDEuMTEuNFxcbiAgICogaHR0cDovL2pxdWVyeXVpLmNvbVxcbiAgICpcXG4gICAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXFxuICAgKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXFxuICAgKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXFxuICAgKlxcbiAgICogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20vYm91bmNlLWVmZmVjdC9cXG4gICAqL1xcblxcblxcbiAgdmFyIGVmZmVjdEJvdW5jZSA9ICQuZWZmZWN0cy5lZmZlY3QuYm91bmNlID0gZnVuY3Rpb24gKG8sIGRvbmUpIHtcXG4gICAgdmFyIGVsID0gJCh0aGlzKSxcXG4gICAgICAgIHByb3BzID0gW1xcXCJwb3NpdGlvblxcXCIsIFxcXCJ0b3BcXFwiLCBcXFwiYm90dG9tXFxcIiwgXFxcImxlZnRcXFwiLCBcXFwicmlnaHRcXFwiLCBcXFwiaGVpZ2h0XFxcIiwgXFxcIndpZHRoXFxcIl0sXFxuICAgICAgICAvLyBkZWZhdWx0czpcXG4gICAgbW9kZSA9ICQuZWZmZWN0cy5zZXRNb2RlKGVsLCBvLm1vZGUgfHwgXFxcImVmZmVjdFxcXCIpLFxcbiAgICAgICAgaGlkZSA9IG1vZGUgPT09IFxcXCJoaWRlXFxcIixcXG4gICAgICAgIHNob3cgPSBtb2RlID09PSBcXFwic2hvd1xcXCIsXFxuICAgICAgICBkaXJlY3Rpb24gPSBvLmRpcmVjdGlvbiB8fCBcXFwidXBcXFwiLFxcbiAgICAgICAgZGlzdGFuY2UgPSBvLmRpc3RhbmNlLFxcbiAgICAgICAgdGltZXMgPSBvLnRpbWVzIHx8IDUsXFxuICAgICAgICAvLyBudW1iZXIgb2YgaW50ZXJuYWwgYW5pbWF0aW9uc1xcbiAgICBhbmltcyA9IHRpbWVzICogMiArIChzaG93IHx8IGhpZGUgPyAxIDogMCksXFxuICAgICAgICBzcGVlZCA9IG8uZHVyYXRpb24gLyBhbmltcyxcXG4gICAgICAgIGVhc2luZyA9IG8uZWFzaW5nLFxcbiAgICAgICAgLy8gdXRpbGl0eTpcXG4gICAgcmVmID0gZGlyZWN0aW9uID09PSBcXFwidXBcXFwiIHx8IGRpcmVjdGlvbiA9PT0gXFxcImRvd25cXFwiID8gXFxcInRvcFxcXCIgOiBcXFwibGVmdFxcXCIsXFxuICAgICAgICBtb3Rpb24gPSBkaXJlY3Rpb24gPT09IFxcXCJ1cFxcXCIgfHwgZGlyZWN0aW9uID09PSBcXFwibGVmdFxcXCIsXFxuICAgICAgICBpLFxcbiAgICAgICAgdXBBbmltLFxcbiAgICAgICAgZG93bkFuaW0sXFxuICAgICAgICAvLyB3ZSB3aWxsIG5lZWQgdG8gcmUtYXNzZW1ibGUgdGhlIHF1ZXVlIHRvIHN0YWNrIG91ciBhbmltYXRpb25zIGluIHBsYWNlXFxuICAgIHF1ZXVlID0gZWwucXVldWUoKSxcXG4gICAgICAgIHF1ZXVlbGVuID0gcXVldWUubGVuZ3RoOyAvLyBBdm9pZCB0b3VjaGluZyBvcGFjaXR5IHRvIHByZXZlbnQgY2xlYXJUeXBlIGFuZCBQTkcgaXNzdWVzIGluIElFXFxuXFxuICAgIGlmIChzaG93IHx8IGhpZGUpIHtcXG4gICAgICBwcm9wcy5wdXNoKFxcXCJvcGFjaXR5XFxcIik7XFxuICAgIH1cXG5cXG4gICAgJC5lZmZlY3RzLnNhdmUoZWwsIHByb3BzKTtcXG4gICAgZWwuc2hvdygpO1xcbiAgICAkLmVmZmVjdHMuY3JlYXRlV3JhcHBlcihlbCk7IC8vIENyZWF0ZSBXcmFwcGVyXFxuICAgIC8vIGRlZmF1bHQgZGlzdGFuY2UgZm9yIHRoZSBCSUdHRVNUIGJvdW5jZSBpcyB0aGUgb3V0ZXIgRGlzdGFuY2UgLyAzXFxuXFxuICAgIGlmICghZGlzdGFuY2UpIHtcXG4gICAgICBkaXN0YW5jZSA9IGVsW3JlZiA9PT0gXFxcInRvcFxcXCIgPyBcXFwib3V0ZXJIZWlnaHRcXFwiIDogXFxcIm91dGVyV2lkdGhcXFwiXSgpIC8gMztcXG4gICAgfVxcblxcbiAgICBpZiAoc2hvdykge1xcbiAgICAgIGRvd25BbmltID0ge1xcbiAgICAgICAgb3BhY2l0eTogMVxcbiAgICAgIH07XFxuICAgICAgZG93bkFuaW1bcmVmXSA9IDA7IC8vIGlmIHdlIGFyZSBzaG93aW5nLCBmb3JjZSBvcGFjaXR5IDAgYW5kIHNldCB0aGUgaW5pdGlhbCBwb3NpdGlvblxcbiAgICAgIC8vIHRoZW4gZG8gdGhlIFxcXCJmaXJzdFxcXCIgYW5pbWF0aW9uXFxuXFxuICAgICAgZWwuY3NzKFxcXCJvcGFjaXR5XFxcIiwgMCkuY3NzKHJlZiwgbW90aW9uID8gLWRpc3RhbmNlICogMiA6IGRpc3RhbmNlICogMikuYW5pbWF0ZShkb3duQW5pbSwgc3BlZWQsIGVhc2luZyk7XFxuICAgIH0gLy8gc3RhcnQgYXQgdGhlIHNtYWxsZXN0IGRpc3RhbmNlIGlmIHdlIGFyZSBoaWRpbmdcXG5cXG5cXG4gICAgaWYgKGhpZGUpIHtcXG4gICAgICBkaXN0YW5jZSA9IGRpc3RhbmNlIC8gTWF0aC5wb3coMiwgdGltZXMgLSAxKTtcXG4gICAgfVxcblxcbiAgICBkb3duQW5pbSA9IHt9O1xcbiAgICBkb3duQW5pbVtyZWZdID0gMDsgLy8gQm91bmNlcyB1cC9kb3duL2xlZnQvcmlnaHQgdGhlbiBiYWNrIHRvIDAgLS0gdGltZXMgKiAyIGFuaW1hdGlvbnMgaGFwcGVuIGhlcmVcXG5cXG4gICAgZm9yIChpID0gMDsgaSA8IHRpbWVzOyBpKyspIHtcXG4gICAgICB1cEFuaW0gPSB7fTtcXG4gICAgICB1cEFuaW1bcmVmXSA9IChtb3Rpb24gPyBcXFwiLT1cXFwiIDogXFxcIis9XFxcIikgKyBkaXN0YW5jZTtcXG4gICAgICBlbC5hbmltYXRlKHVwQW5pbSwgc3BlZWQsIGVhc2luZykuYW5pbWF0ZShkb3duQW5pbSwgc3BlZWQsIGVhc2luZyk7XFxuICAgICAgZGlzdGFuY2UgPSBoaWRlID8gZGlzdGFuY2UgKiAyIDogZGlzdGFuY2UgLyAyO1xcbiAgICB9IC8vIExhc3QgQm91bmNlIHdoZW4gSGlkaW5nXFxuXFxuXFxuICAgIGlmIChoaWRlKSB7XFxuICAgICAgdXBBbmltID0ge1xcbiAgICAgICAgb3BhY2l0eTogMFxcbiAgICAgIH07XFxuICAgICAgdXBBbmltW3JlZl0gPSAobW90aW9uID8gXFxcIi09XFxcIiA6IFxcXCIrPVxcXCIpICsgZGlzdGFuY2U7XFxuICAgICAgZWwuYW5pbWF0ZSh1cEFuaW0sIHNwZWVkLCBlYXNpbmcpO1xcbiAgICB9XFxuXFxuICAgIGVsLnF1ZXVlKGZ1bmN0aW9uICgpIHtcXG4gICAgICBpZiAoaGlkZSkge1xcbiAgICAgICAgZWwuaGlkZSgpO1xcbiAgICAgIH1cXG5cXG4gICAgICAkLmVmZmVjdHMucmVzdG9yZShlbCwgcHJvcHMpO1xcbiAgICAgICQuZWZmZWN0cy5yZW1vdmVXcmFwcGVyKGVsKTtcXG4gICAgICBkb25lKCk7XFxuICAgIH0pOyAvLyBpbmplY3QgYWxsIHRoZSBhbmltYXRpb25zIHdlIGp1c3QgcXVldWVkIHRvIGJlIGZpcnN0IGluIGxpbmUgKGFmdGVyIFxcXCJpbnByb2dyZXNzXFxcIilcXG5cXG4gICAgaWYgKHF1ZXVlbGVuID4gMSkge1xcbiAgICAgIHF1ZXVlLnNwbGljZS5hcHBseShxdWV1ZSwgWzEsIDBdLmNvbmNhdChxdWV1ZS5zcGxpY2UocXVldWVsZW4sIGFuaW1zICsgMSkpKTtcXG4gICAgfVxcblxcbiAgICBlbC5kZXF1ZXVlKCk7XFxuICB9O1xcbiAgLyohXFxuICAgKiBqUXVlcnkgVUkgRWZmZWN0cyBDbGlwIDEuMTEuNFxcbiAgICogaHR0cDovL2pxdWVyeXVpLmNvbVxcbiAgICpcXG4gICAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXFxuICAgKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXFxuICAgKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXFxuICAgKlxcbiAgICogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20vY2xpcC1lZmZlY3QvXFxuICAgKi9cXG5cXG5cXG4gIHZhciBlZmZlY3RDbGlwID0gJC5lZmZlY3RzLmVmZmVjdC5jbGlwID0gZnVuY3Rpb24gKG8sIGRvbmUpIHtcXG4gICAgLy8gQ3JlYXRlIGVsZW1lbnRcXG4gICAgdmFyIGVsID0gJCh0aGlzKSxcXG4gICAgICAgIHByb3BzID0gW1xcXCJwb3NpdGlvblxcXCIsIFxcXCJ0b3BcXFwiLCBcXFwiYm90dG9tXFxcIiwgXFxcImxlZnRcXFwiLCBcXFwicmlnaHRcXFwiLCBcXFwiaGVpZ2h0XFxcIiwgXFxcIndpZHRoXFxcIl0sXFxuICAgICAgICBtb2RlID0gJC5lZmZlY3RzLnNldE1vZGUoZWwsIG8ubW9kZSB8fCBcXFwiaGlkZVxcXCIpLFxcbiAgICAgICAgc2hvdyA9IG1vZGUgPT09IFxcXCJzaG93XFxcIixcXG4gICAgICAgIGRpcmVjdGlvbiA9IG8uZGlyZWN0aW9uIHx8IFxcXCJ2ZXJ0aWNhbFxcXCIsXFxuICAgICAgICB2ZXJ0ID0gZGlyZWN0aW9uID09PSBcXFwidmVydGljYWxcXFwiLFxcbiAgICAgICAgc2l6ZSA9IHZlcnQgPyBcXFwiaGVpZ2h0XFxcIiA6IFxcXCJ3aWR0aFxcXCIsXFxuICAgICAgICBwb3NpdGlvbiA9IHZlcnQgPyBcXFwidG9wXFxcIiA6IFxcXCJsZWZ0XFxcIixcXG4gICAgICAgIGFuaW1hdGlvbiA9IHt9LFxcbiAgICAgICAgd3JhcHBlcixcXG4gICAgICAgIGFuaW1hdGUsXFxuICAgICAgICBkaXN0YW5jZTsgLy8gU2F2ZSAmIFNob3dcXG5cXG4gICAgJC5lZmZlY3RzLnNhdmUoZWwsIHByb3BzKTtcXG4gICAgZWwuc2hvdygpOyAvLyBDcmVhdGUgV3JhcHBlclxcblxcbiAgICB3cmFwcGVyID0gJC5lZmZlY3RzLmNyZWF0ZVdyYXBwZXIoZWwpLmNzcyh7XFxuICAgICAgb3ZlcmZsb3c6IFxcXCJoaWRkZW5cXFwiXFxuICAgIH0pO1xcbiAgICBhbmltYXRlID0gZWxbMF0udGFnTmFtZSA9PT0gXFxcIklNR1xcXCIgPyB3cmFwcGVyIDogZWw7XFxuICAgIGRpc3RhbmNlID0gYW5pbWF0ZVtzaXplXSgpOyAvLyBTaGlmdFxcblxcbiAgICBpZiAoc2hvdykge1xcbiAgICAgIGFuaW1hdGUuY3NzKHNpemUsIDApO1xcbiAgICAgIGFuaW1hdGUuY3NzKHBvc2l0aW9uLCBkaXN0YW5jZSAvIDIpO1xcbiAgICB9IC8vIENyZWF0ZSBBbmltYXRpb24gT2JqZWN0OlxcblxcblxcbiAgICBhbmltYXRpb25bc2l6ZV0gPSBzaG93ID8gZGlzdGFuY2UgOiAwO1xcbiAgICBhbmltYXRpb25bcG9zaXRpb25dID0gc2hvdyA/IDAgOiBkaXN0YW5jZSAvIDI7IC8vIEFuaW1hdGVcXG5cXG4gICAgYW5pbWF0ZS5hbmltYXRlKGFuaW1hdGlvbiwge1xcbiAgICAgIHF1ZXVlOiBmYWxzZSxcXG4gICAgICBkdXJhdGlvbjogby5kdXJhdGlvbixcXG4gICAgICBlYXNpbmc6IG8uZWFzaW5nLFxcbiAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiBjb21wbGV0ZSgpIHtcXG4gICAgICAgIGlmICghc2hvdykge1xcbiAgICAgICAgICBlbC5oaWRlKCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICAkLmVmZmVjdHMucmVzdG9yZShlbCwgcHJvcHMpO1xcbiAgICAgICAgJC5lZmZlY3RzLnJlbW92ZVdyYXBwZXIoZWwpO1xcbiAgICAgICAgZG9uZSgpO1xcbiAgICAgIH1cXG4gICAgfSk7XFxuICB9O1xcbiAgLyohXFxuICAgKiBqUXVlcnkgVUkgRWZmZWN0cyBEcm9wIDEuMTEuNFxcbiAgICogaHR0cDovL2pxdWVyeXVpLmNvbVxcbiAgICpcXG4gICAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXFxuICAgKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXFxuICAgKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXFxuICAgKlxcbiAgICogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20vZHJvcC1lZmZlY3QvXFxuICAgKi9cXG5cXG5cXG4gIHZhciBlZmZlY3REcm9wID0gJC5lZmZlY3RzLmVmZmVjdC5kcm9wID0gZnVuY3Rpb24gKG8sIGRvbmUpIHtcXG4gICAgdmFyIGVsID0gJCh0aGlzKSxcXG4gICAgICAgIHByb3BzID0gW1xcXCJwb3NpdGlvblxcXCIsIFxcXCJ0b3BcXFwiLCBcXFwiYm90dG9tXFxcIiwgXFxcImxlZnRcXFwiLCBcXFwicmlnaHRcXFwiLCBcXFwib3BhY2l0eVxcXCIsIFxcXCJoZWlnaHRcXFwiLCBcXFwid2lkdGhcXFwiXSxcXG4gICAgICAgIG1vZGUgPSAkLmVmZmVjdHMuc2V0TW9kZShlbCwgby5tb2RlIHx8IFxcXCJoaWRlXFxcIiksXFxuICAgICAgICBzaG93ID0gbW9kZSA9PT0gXFxcInNob3dcXFwiLFxcbiAgICAgICAgZGlyZWN0aW9uID0gby5kaXJlY3Rpb24gfHwgXFxcImxlZnRcXFwiLFxcbiAgICAgICAgcmVmID0gZGlyZWN0aW9uID09PSBcXFwidXBcXFwiIHx8IGRpcmVjdGlvbiA9PT0gXFxcImRvd25cXFwiID8gXFxcInRvcFxcXCIgOiBcXFwibGVmdFxcXCIsXFxuICAgICAgICBtb3Rpb24gPSBkaXJlY3Rpb24gPT09IFxcXCJ1cFxcXCIgfHwgZGlyZWN0aW9uID09PSBcXFwibGVmdFxcXCIgPyBcXFwicG9zXFxcIiA6IFxcXCJuZWdcXFwiLFxcbiAgICAgICAgYW5pbWF0aW9uID0ge1xcbiAgICAgIG9wYWNpdHk6IHNob3cgPyAxIDogMFxcbiAgICB9LFxcbiAgICAgICAgZGlzdGFuY2U7IC8vIEFkanVzdFxcblxcbiAgICAkLmVmZmVjdHMuc2F2ZShlbCwgcHJvcHMpO1xcbiAgICBlbC5zaG93KCk7XFxuICAgICQuZWZmZWN0cy5jcmVhdGVXcmFwcGVyKGVsKTtcXG4gICAgZGlzdGFuY2UgPSBvLmRpc3RhbmNlIHx8IGVsW3JlZiA9PT0gXFxcInRvcFxcXCIgPyBcXFwib3V0ZXJIZWlnaHRcXFwiIDogXFxcIm91dGVyV2lkdGhcXFwiXSh0cnVlKSAvIDI7XFxuXFxuICAgIGlmIChzaG93KSB7XFxuICAgICAgZWwuY3NzKFxcXCJvcGFjaXR5XFxcIiwgMCkuY3NzKHJlZiwgbW90aW9uID09PSBcXFwicG9zXFxcIiA/IC1kaXN0YW5jZSA6IGRpc3RhbmNlKTtcXG4gICAgfSAvLyBBbmltYXRpb25cXG5cXG5cXG4gICAgYW5pbWF0aW9uW3JlZl0gPSAoc2hvdyA/IG1vdGlvbiA9PT0gXFxcInBvc1xcXCIgPyBcXFwiKz1cXFwiIDogXFxcIi09XFxcIiA6IG1vdGlvbiA9PT0gXFxcInBvc1xcXCIgPyBcXFwiLT1cXFwiIDogXFxcIis9XFxcIikgKyBkaXN0YW5jZTsgLy8gQW5pbWF0ZVxcblxcbiAgICBlbC5hbmltYXRlKGFuaW1hdGlvbiwge1xcbiAgICAgIHF1ZXVlOiBmYWxzZSxcXG4gICAgICBkdXJhdGlvbjogby5kdXJhdGlvbixcXG4gICAgICBlYXNpbmc6IG8uZWFzaW5nLFxcbiAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiBjb21wbGV0ZSgpIHtcXG4gICAgICAgIGlmIChtb2RlID09PSBcXFwiaGlkZVxcXCIpIHtcXG4gICAgICAgICAgZWwuaGlkZSgpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgJC5lZmZlY3RzLnJlc3RvcmUoZWwsIHByb3BzKTtcXG4gICAgICAgICQuZWZmZWN0cy5yZW1vdmVXcmFwcGVyKGVsKTtcXG4gICAgICAgIGRvbmUoKTtcXG4gICAgICB9XFxuICAgIH0pO1xcbiAgfTtcXG4gIC8qIVxcbiAgICogalF1ZXJ5IFVJIEVmZmVjdHMgRXhwbG9kZSAxLjExLjRcXG4gICAqIGh0dHA6Ly9qcXVlcnl1aS5jb21cXG4gICAqXFxuICAgKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xcbiAgICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxcbiAgICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxcbiAgICpcXG4gICAqIGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL2V4cGxvZGUtZWZmZWN0L1xcbiAgICovXFxuXFxuXFxuICB2YXIgZWZmZWN0RXhwbG9kZSA9ICQuZWZmZWN0cy5lZmZlY3QuZXhwbG9kZSA9IGZ1bmN0aW9uIChvLCBkb25lKSB7XFxuICAgIHZhciByb3dzID0gby5waWVjZXMgPyBNYXRoLnJvdW5kKE1hdGguc3FydChvLnBpZWNlcykpIDogMyxcXG4gICAgICAgIGNlbGxzID0gcm93cyxcXG4gICAgICAgIGVsID0gJCh0aGlzKSxcXG4gICAgICAgIG1vZGUgPSAkLmVmZmVjdHMuc2V0TW9kZShlbCwgby5tb2RlIHx8IFxcXCJoaWRlXFxcIiksXFxuICAgICAgICBzaG93ID0gbW9kZSA9PT0gXFxcInNob3dcXFwiLFxcbiAgICAgICAgLy8gc2hvdyBhbmQgdGhlbiB2aXNpYmlsaXR5OmhpZGRlbiB0aGUgZWxlbWVudCBiZWZvcmUgY2FsY3VsYXRpbmcgb2Zmc2V0XFxuICAgIG9mZnNldCA9IGVsLnNob3coKS5jc3MoXFxcInZpc2liaWxpdHlcXFwiLCBcXFwiaGlkZGVuXFxcIikub2Zmc2V0KCksXFxuICAgICAgICAvLyB3aWR0aCBhbmQgaGVpZ2h0IG9mIGEgcGllY2VcXG4gICAgd2lkdGggPSBNYXRoLmNlaWwoZWwub3V0ZXJXaWR0aCgpIC8gY2VsbHMpLFxcbiAgICAgICAgaGVpZ2h0ID0gTWF0aC5jZWlsKGVsLm91dGVySGVpZ2h0KCkgLyByb3dzKSxcXG4gICAgICAgIHBpZWNlcyA9IFtdLFxcbiAgICAgICAgLy8gbG9vcFxcbiAgICBpLFxcbiAgICAgICAgaixcXG4gICAgICAgIGxlZnQsXFxuICAgICAgICB0b3AsXFxuICAgICAgICBteCxcXG4gICAgICAgIG15OyAvLyBjaGlsZHJlbiBhbmltYXRlIGNvbXBsZXRlOlxcblxcbiAgICBmdW5jdGlvbiBjaGlsZENvbXBsZXRlKCkge1xcbiAgICAgIHBpZWNlcy5wdXNoKHRoaXMpO1xcblxcbiAgICAgIGlmIChwaWVjZXMubGVuZ3RoID09PSByb3dzICogY2VsbHMpIHtcXG4gICAgICAgIGFuaW1Db21wbGV0ZSgpO1xcbiAgICAgIH1cXG4gICAgfSAvLyBjbG9uZSB0aGUgZWxlbWVudCBmb3IgZWFjaCByb3cgYW5kIGNlbGwuXFxuXFxuXFxuICAgIGZvciAoaSA9IDA7IGkgPCByb3dzOyBpKyspIHtcXG4gICAgICAvLyA9PT0+XFxuICAgICAgdG9wID0gb2Zmc2V0LnRvcCArIGkgKiBoZWlnaHQ7XFxuICAgICAgbXkgPSBpIC0gKHJvd3MgLSAxKSAvIDI7XFxuXFxuICAgICAgZm9yIChqID0gMDsgaiA8IGNlbGxzOyBqKyspIHtcXG4gICAgICAgIC8vIHx8fFxcbiAgICAgICAgbGVmdCA9IG9mZnNldC5sZWZ0ICsgaiAqIHdpZHRoO1xcbiAgICAgICAgbXggPSBqIC0gKGNlbGxzIC0gMSkgLyAyOyAvLyBDcmVhdGUgYSBjbG9uZSBvZiB0aGUgbm93IGhpZGRlbiBtYWluIGVsZW1lbnQgdGhhdCB3aWxsIGJlIGFic29sdXRlIHBvc2l0aW9uZWRcXG4gICAgICAgIC8vIHdpdGhpbiBhIHdyYXBwZXIgZGl2IG9mZiB0aGUgLWxlZnQgYW5kIC10b3AgZXF1YWwgdG8gc2l6ZSBvZiBvdXIgcGllY2VzXFxuXFxuICAgICAgICBlbC5jbG9uZSgpLmFwcGVuZFRvKFxcXCJib2R5XFxcIikud3JhcChcXFwiPGRpdj48L2Rpdj5cXFwiKS5jc3Moe1xcbiAgICAgICAgICBwb3NpdGlvbjogXFxcImFic29sdXRlXFxcIixcXG4gICAgICAgICAgdmlzaWJpbGl0eTogXFxcInZpc2libGVcXFwiLFxcbiAgICAgICAgICBsZWZ0OiAtaiAqIHdpZHRoLFxcbiAgICAgICAgICB0b3A6IC1pICogaGVpZ2h0XFxuICAgICAgICB9KSAvLyBzZWxlY3QgdGhlIHdyYXBwZXIgLSBtYWtlIGl0IG92ZXJmbG93OiBoaWRkZW4gYW5kIGFic29sdXRlIHBvc2l0aW9uZWQgYmFzZWQgb25cXG4gICAgICAgIC8vIHdoZXJlIHRoZSBvcmlnaW5hbCB3YXMgbG9jYXRlZCArbGVmdCBhbmQgK3RvcCBlcXVhbCB0byB0aGUgc2l6ZSBvZiBwaWVjZXNcXG4gICAgICAgIC5wYXJlbnQoKS5hZGRDbGFzcyhcXFwidWktZWZmZWN0cy1leHBsb2RlXFxcIikuY3NzKHtcXG4gICAgICAgICAgcG9zaXRpb246IFxcXCJhYnNvbHV0ZVxcXCIsXFxuICAgICAgICAgIG92ZXJmbG93OiBcXFwiaGlkZGVuXFxcIixcXG4gICAgICAgICAgd2lkdGg6IHdpZHRoLFxcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcXG4gICAgICAgICAgbGVmdDogbGVmdCArIChzaG93ID8gbXggKiB3aWR0aCA6IDApLFxcbiAgICAgICAgICB0b3A6IHRvcCArIChzaG93ID8gbXkgKiBoZWlnaHQgOiAwKSxcXG4gICAgICAgICAgb3BhY2l0eTogc2hvdyA/IDAgOiAxXFxuICAgICAgICB9KS5hbmltYXRlKHtcXG4gICAgICAgICAgbGVmdDogbGVmdCArIChzaG93ID8gMCA6IG14ICogd2lkdGgpLFxcbiAgICAgICAgICB0b3A6IHRvcCArIChzaG93ID8gMCA6IG15ICogaGVpZ2h0KSxcXG4gICAgICAgICAgb3BhY2l0eTogc2hvdyA/IDEgOiAwXFxuICAgICAgICB9LCBvLmR1cmF0aW9uIHx8IDUwMCwgby5lYXNpbmcsIGNoaWxkQ29tcGxldGUpO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBhbmltQ29tcGxldGUoKSB7XFxuICAgICAgZWwuY3NzKHtcXG4gICAgICAgIHZpc2liaWxpdHk6IFxcXCJ2aXNpYmxlXFxcIlxcbiAgICAgIH0pO1xcbiAgICAgICQocGllY2VzKS5yZW1vdmUoKTtcXG5cXG4gICAgICBpZiAoIXNob3cpIHtcXG4gICAgICAgIGVsLmhpZGUoKTtcXG4gICAgICB9XFxuXFxuICAgICAgZG9uZSgpO1xcbiAgICB9XFxuICB9O1xcbiAgLyohXFxuICAgKiBqUXVlcnkgVUkgRWZmZWN0cyBGYWRlIDEuMTEuNFxcbiAgICogaHR0cDovL2pxdWVyeXVpLmNvbVxcbiAgICpcXG4gICAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXFxuICAgKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXFxuICAgKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXFxuICAgKlxcbiAgICogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20vZmFkZS1lZmZlY3QvXFxuICAgKi9cXG5cXG5cXG4gIHZhciBlZmZlY3RGYWRlID0gJC5lZmZlY3RzLmVmZmVjdC5mYWRlID0gZnVuY3Rpb24gKG8sIGRvbmUpIHtcXG4gICAgdmFyIGVsID0gJCh0aGlzKSxcXG4gICAgICAgIG1vZGUgPSAkLmVmZmVjdHMuc2V0TW9kZShlbCwgby5tb2RlIHx8IFxcXCJ0b2dnbGVcXFwiKTtcXG4gICAgZWwuYW5pbWF0ZSh7XFxuICAgICAgb3BhY2l0eTogbW9kZVxcbiAgICB9LCB7XFxuICAgICAgcXVldWU6IGZhbHNlLFxcbiAgICAgIGR1cmF0aW9uOiBvLmR1cmF0aW9uLFxcbiAgICAgIGVhc2luZzogby5lYXNpbmcsXFxuICAgICAgY29tcGxldGU6IGRvbmVcXG4gICAgfSk7XFxuICB9O1xcbiAgLyohXFxuICAgKiBqUXVlcnkgVUkgRWZmZWN0cyBGb2xkIDEuMTEuNFxcbiAgICogaHR0cDovL2pxdWVyeXVpLmNvbVxcbiAgICpcXG4gICAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXFxuICAgKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXFxuICAgKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXFxuICAgKlxcbiAgICogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20vZm9sZC1lZmZlY3QvXFxuICAgKi9cXG5cXG5cXG4gIHZhciBlZmZlY3RGb2xkID0gJC5lZmZlY3RzLmVmZmVjdC5mb2xkID0gZnVuY3Rpb24gKG8sIGRvbmUpIHtcXG4gICAgLy8gQ3JlYXRlIGVsZW1lbnRcXG4gICAgdmFyIGVsID0gJCh0aGlzKSxcXG4gICAgICAgIHByb3BzID0gW1xcXCJwb3NpdGlvblxcXCIsIFxcXCJ0b3BcXFwiLCBcXFwiYm90dG9tXFxcIiwgXFxcImxlZnRcXFwiLCBcXFwicmlnaHRcXFwiLCBcXFwiaGVpZ2h0XFxcIiwgXFxcIndpZHRoXFxcIl0sXFxuICAgICAgICBtb2RlID0gJC5lZmZlY3RzLnNldE1vZGUoZWwsIG8ubW9kZSB8fCBcXFwiaGlkZVxcXCIpLFxcbiAgICAgICAgc2hvdyA9IG1vZGUgPT09IFxcXCJzaG93XFxcIixcXG4gICAgICAgIGhpZGUgPSBtb2RlID09PSBcXFwiaGlkZVxcXCIsXFxuICAgICAgICBzaXplID0gby5zaXplIHx8IDE1LFxcbiAgICAgICAgcGVyY2VudCA9IC8oWzAtOV0rKSUvLmV4ZWMoc2l6ZSksXFxuICAgICAgICBob3JpekZpcnN0ID0gISFvLmhvcml6Rmlyc3QsXFxuICAgICAgICB3aWR0aEZpcnN0ID0gc2hvdyAhPT0gaG9yaXpGaXJzdCxcXG4gICAgICAgIHJlZiA9IHdpZHRoRmlyc3QgPyBbXFxcIndpZHRoXFxcIiwgXFxcImhlaWdodFxcXCJdIDogW1xcXCJoZWlnaHRcXFwiLCBcXFwid2lkdGhcXFwiXSxcXG4gICAgICAgIGR1cmF0aW9uID0gby5kdXJhdGlvbiAvIDIsXFxuICAgICAgICB3cmFwcGVyLFxcbiAgICAgICAgZGlzdGFuY2UsXFxuICAgICAgICBhbmltYXRpb24xID0ge30sXFxuICAgICAgICBhbmltYXRpb24yID0ge307XFxuICAgICQuZWZmZWN0cy5zYXZlKGVsLCBwcm9wcyk7XFxuICAgIGVsLnNob3coKTsgLy8gQ3JlYXRlIFdyYXBwZXJcXG5cXG4gICAgd3JhcHBlciA9ICQuZWZmZWN0cy5jcmVhdGVXcmFwcGVyKGVsKS5jc3Moe1xcbiAgICAgIG92ZXJmbG93OiBcXFwiaGlkZGVuXFxcIlxcbiAgICB9KTtcXG4gICAgZGlzdGFuY2UgPSB3aWR0aEZpcnN0ID8gW3dyYXBwZXIud2lkdGgoKSwgd3JhcHBlci5oZWlnaHQoKV0gOiBbd3JhcHBlci5oZWlnaHQoKSwgd3JhcHBlci53aWR0aCgpXTtcXG5cXG4gICAgaWYgKHBlcmNlbnQpIHtcXG4gICAgICBzaXplID0gcGFyc2VJbnQocGVyY2VudFsxXSwgMTApIC8gMTAwICogZGlzdGFuY2VbaGlkZSA/IDAgOiAxXTtcXG4gICAgfVxcblxcbiAgICBpZiAoc2hvdykge1xcbiAgICAgIHdyYXBwZXIuY3NzKGhvcml6Rmlyc3QgPyB7XFxuICAgICAgICBoZWlnaHQ6IDAsXFxuICAgICAgICB3aWR0aDogc2l6ZVxcbiAgICAgIH0gOiB7XFxuICAgICAgICBoZWlnaHQ6IHNpemUsXFxuICAgICAgICB3aWR0aDogMFxcbiAgICAgIH0pO1xcbiAgICB9IC8vIEFuaW1hdGlvblxcblxcblxcbiAgICBhbmltYXRpb24xW3JlZlswXV0gPSBzaG93ID8gZGlzdGFuY2VbMF0gOiBzaXplO1xcbiAgICBhbmltYXRpb24yW3JlZlsxXV0gPSBzaG93ID8gZGlzdGFuY2VbMV0gOiAwOyAvLyBBbmltYXRlXFxuXFxuICAgIHdyYXBwZXIuYW5pbWF0ZShhbmltYXRpb24xLCBkdXJhdGlvbiwgby5lYXNpbmcpLmFuaW1hdGUoYW5pbWF0aW9uMiwgZHVyYXRpb24sIG8uZWFzaW5nLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgaWYgKGhpZGUpIHtcXG4gICAgICAgIGVsLmhpZGUoKTtcXG4gICAgICB9XFxuXFxuICAgICAgJC5lZmZlY3RzLnJlc3RvcmUoZWwsIHByb3BzKTtcXG4gICAgICAkLmVmZmVjdHMucmVtb3ZlV3JhcHBlcihlbCk7XFxuICAgICAgZG9uZSgpO1xcbiAgICB9KTtcXG4gIH07XFxuICAvKiFcXG4gICAqIGpRdWVyeSBVSSBFZmZlY3RzIEhpZ2hsaWdodCAxLjExLjRcXG4gICAqIGh0dHA6Ly9qcXVlcnl1aS5jb21cXG4gICAqXFxuICAgKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xcbiAgICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxcbiAgICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxcbiAgICpcXG4gICAqIGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL2hpZ2hsaWdodC1lZmZlY3QvXFxuICAgKi9cXG5cXG5cXG4gIHZhciBlZmZlY3RIaWdobGlnaHQgPSAkLmVmZmVjdHMuZWZmZWN0LmhpZ2hsaWdodCA9IGZ1bmN0aW9uIChvLCBkb25lKSB7XFxuICAgIHZhciBlbGVtID0gJCh0aGlzKSxcXG4gICAgICAgIHByb3BzID0gW1xcXCJiYWNrZ3JvdW5kSW1hZ2VcXFwiLCBcXFwiYmFja2dyb3VuZENvbG9yXFxcIiwgXFxcIm9wYWNpdHlcXFwiXSxcXG4gICAgICAgIG1vZGUgPSAkLmVmZmVjdHMuc2V0TW9kZShlbGVtLCBvLm1vZGUgfHwgXFxcInNob3dcXFwiKSxcXG4gICAgICAgIGFuaW1hdGlvbiA9IHtcXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IGVsZW0uY3NzKFxcXCJiYWNrZ3JvdW5kQ29sb3JcXFwiKVxcbiAgICB9O1xcblxcbiAgICBpZiAobW9kZSA9PT0gXFxcImhpZGVcXFwiKSB7XFxuICAgICAgYW5pbWF0aW9uLm9wYWNpdHkgPSAwO1xcbiAgICB9XFxuXFxuICAgICQuZWZmZWN0cy5zYXZlKGVsZW0sIHByb3BzKTtcXG4gICAgZWxlbS5zaG93KCkuY3NzKHtcXG4gICAgICBiYWNrZ3JvdW5kSW1hZ2U6IFxcXCJub25lXFxcIixcXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IG8uY29sb3IgfHwgXFxcIiNmZmZmOTlcXFwiXFxuICAgIH0pLmFuaW1hdGUoYW5pbWF0aW9uLCB7XFxuICAgICAgcXVldWU6IGZhbHNlLFxcbiAgICAgIGR1cmF0aW9uOiBvLmR1cmF0aW9uLFxcbiAgICAgIGVhc2luZzogby5lYXNpbmcsXFxuICAgICAgY29tcGxldGU6IGZ1bmN0aW9uIGNvbXBsZXRlKCkge1xcbiAgICAgICAgaWYgKG1vZGUgPT09IFxcXCJoaWRlXFxcIikge1xcbiAgICAgICAgICBlbGVtLmhpZGUoKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgICQuZWZmZWN0cy5yZXN0b3JlKGVsZW0sIHByb3BzKTtcXG4gICAgICAgIGRvbmUoKTtcXG4gICAgICB9XFxuICAgIH0pO1xcbiAgfTtcXG4gIC8qIVxcbiAgICogalF1ZXJ5IFVJIEVmZmVjdHMgU2l6ZSAxLjExLjRcXG4gICAqIGh0dHA6Ly9qcXVlcnl1aS5jb21cXG4gICAqXFxuICAgKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xcbiAgICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxcbiAgICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxcbiAgICpcXG4gICAqIGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL3NpemUtZWZmZWN0L1xcbiAgICovXFxuXFxuXFxuICB2YXIgZWZmZWN0U2l6ZSA9ICQuZWZmZWN0cy5lZmZlY3Quc2l6ZSA9IGZ1bmN0aW9uIChvLCBkb25lKSB7XFxuICAgIC8vIENyZWF0ZSBlbGVtZW50XFxuICAgIHZhciBvcmlnaW5hbCxcXG4gICAgICAgIGJhc2VsaW5lLFxcbiAgICAgICAgZmFjdG9yLFxcbiAgICAgICAgZWwgPSAkKHRoaXMpLFxcbiAgICAgICAgcHJvcHMwID0gW1xcXCJwb3NpdGlvblxcXCIsIFxcXCJ0b3BcXFwiLCBcXFwiYm90dG9tXFxcIiwgXFxcImxlZnRcXFwiLCBcXFwicmlnaHRcXFwiLCBcXFwid2lkdGhcXFwiLCBcXFwiaGVpZ2h0XFxcIiwgXFxcIm92ZXJmbG93XFxcIiwgXFxcIm9wYWNpdHlcXFwiXSxcXG4gICAgICAgIC8vIEFsd2F5cyByZXN0b3JlXFxuICAgIHByb3BzMSA9IFtcXFwicG9zaXRpb25cXFwiLCBcXFwidG9wXFxcIiwgXFxcImJvdHRvbVxcXCIsIFxcXCJsZWZ0XFxcIiwgXFxcInJpZ2h0XFxcIiwgXFxcIm92ZXJmbG93XFxcIiwgXFxcIm9wYWNpdHlcXFwiXSxcXG4gICAgICAgIC8vIENvcHkgZm9yIGNoaWxkcmVuXFxuICAgIHByb3BzMiA9IFtcXFwid2lkdGhcXFwiLCBcXFwiaGVpZ2h0XFxcIiwgXFxcIm92ZXJmbG93XFxcIl0sXFxuICAgICAgICBjUHJvcHMgPSBbXFxcImZvbnRTaXplXFxcIl0sXFxuICAgICAgICB2UHJvcHMgPSBbXFxcImJvcmRlclRvcFdpZHRoXFxcIiwgXFxcImJvcmRlckJvdHRvbVdpZHRoXFxcIiwgXFxcInBhZGRpbmdUb3BcXFwiLCBcXFwicGFkZGluZ0JvdHRvbVxcXCJdLFxcbiAgICAgICAgaFByb3BzID0gW1xcXCJib3JkZXJMZWZ0V2lkdGhcXFwiLCBcXFwiYm9yZGVyUmlnaHRXaWR0aFxcXCIsIFxcXCJwYWRkaW5nTGVmdFxcXCIsIFxcXCJwYWRkaW5nUmlnaHRcXFwiXSxcXG4gICAgICAgIC8vIFNldCBvcHRpb25zXFxuICAgIG1vZGUgPSAkLmVmZmVjdHMuc2V0TW9kZShlbCwgby5tb2RlIHx8IFxcXCJlZmZlY3RcXFwiKSxcXG4gICAgICAgIHJlc3RvcmUgPSBvLnJlc3RvcmUgfHwgbW9kZSAhPT0gXFxcImVmZmVjdFxcXCIsXFxuICAgICAgICBzY2FsZSA9IG8uc2NhbGUgfHwgXFxcImJvdGhcXFwiLFxcbiAgICAgICAgb3JpZ2luID0gby5vcmlnaW4gfHwgW1xcXCJtaWRkbGVcXFwiLCBcXFwiY2VudGVyXFxcIl0sXFxuICAgICAgICBwb3NpdGlvbiA9IGVsLmNzcyhcXFwicG9zaXRpb25cXFwiKSxcXG4gICAgICAgIHByb3BzID0gcmVzdG9yZSA/IHByb3BzMCA6IHByb3BzMSxcXG4gICAgICAgIHplcm8gPSB7XFxuICAgICAgaGVpZ2h0OiAwLFxcbiAgICAgIHdpZHRoOiAwLFxcbiAgICAgIG91dGVySGVpZ2h0OiAwLFxcbiAgICAgIG91dGVyV2lkdGg6IDBcXG4gICAgfTtcXG5cXG4gICAgaWYgKG1vZGUgPT09IFxcXCJzaG93XFxcIikge1xcbiAgICAgIGVsLnNob3coKTtcXG4gICAgfVxcblxcbiAgICBvcmlnaW5hbCA9IHtcXG4gICAgICBoZWlnaHQ6IGVsLmhlaWdodCgpLFxcbiAgICAgIHdpZHRoOiBlbC53aWR0aCgpLFxcbiAgICAgIG91dGVySGVpZ2h0OiBlbC5vdXRlckhlaWdodCgpLFxcbiAgICAgIG91dGVyV2lkdGg6IGVsLm91dGVyV2lkdGgoKVxcbiAgICB9O1xcblxcbiAgICBpZiAoby5tb2RlID09PSBcXFwidG9nZ2xlXFxcIiAmJiBtb2RlID09PSBcXFwic2hvd1xcXCIpIHtcXG4gICAgICBlbC5mcm9tID0gby50byB8fCB6ZXJvO1xcbiAgICAgIGVsLnRvID0gby5mcm9tIHx8IG9yaWdpbmFsO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGVsLmZyb20gPSBvLmZyb20gfHwgKG1vZGUgPT09IFxcXCJzaG93XFxcIiA/IHplcm8gOiBvcmlnaW5hbCk7XFxuICAgICAgZWwudG8gPSBvLnRvIHx8IChtb2RlID09PSBcXFwiaGlkZVxcXCIgPyB6ZXJvIDogb3JpZ2luYWwpO1xcbiAgICB9IC8vIFNldCBzY2FsaW5nIGZhY3RvclxcblxcblxcbiAgICBmYWN0b3IgPSB7XFxuICAgICAgZnJvbToge1xcbiAgICAgICAgeTogZWwuZnJvbS5oZWlnaHQgLyBvcmlnaW5hbC5oZWlnaHQsXFxuICAgICAgICB4OiBlbC5mcm9tLndpZHRoIC8gb3JpZ2luYWwud2lkdGhcXG4gICAgICB9LFxcbiAgICAgIHRvOiB7XFxuICAgICAgICB5OiBlbC50by5oZWlnaHQgLyBvcmlnaW5hbC5oZWlnaHQsXFxuICAgICAgICB4OiBlbC50by53aWR0aCAvIG9yaWdpbmFsLndpZHRoXFxuICAgICAgfVxcbiAgICB9OyAvLyBTY2FsZSB0aGUgY3NzIGJveFxcblxcbiAgICBpZiAoc2NhbGUgPT09IFxcXCJib3hcXFwiIHx8IHNjYWxlID09PSBcXFwiYm90aFxcXCIpIHtcXG4gICAgICAvLyBWZXJ0aWNhbCBwcm9wcyBzY2FsaW5nXFxuICAgICAgaWYgKGZhY3Rvci5mcm9tLnkgIT09IGZhY3Rvci50by55KSB7XFxuICAgICAgICBwcm9wcyA9IHByb3BzLmNvbmNhdCh2UHJvcHMpO1xcbiAgICAgICAgZWwuZnJvbSA9ICQuZWZmZWN0cy5zZXRUcmFuc2l0aW9uKGVsLCB2UHJvcHMsIGZhY3Rvci5mcm9tLnksIGVsLmZyb20pO1xcbiAgICAgICAgZWwudG8gPSAkLmVmZmVjdHMuc2V0VHJhbnNpdGlvbihlbCwgdlByb3BzLCBmYWN0b3IudG8ueSwgZWwudG8pO1xcbiAgICAgIH0gLy8gSG9yaXpvbnRhbCBwcm9wcyBzY2FsaW5nXFxuXFxuXFxuICAgICAgaWYgKGZhY3Rvci5mcm9tLnggIT09IGZhY3Rvci50by54KSB7XFxuICAgICAgICBwcm9wcyA9IHByb3BzLmNvbmNhdChoUHJvcHMpO1xcbiAgICAgICAgZWwuZnJvbSA9ICQuZWZmZWN0cy5zZXRUcmFuc2l0aW9uKGVsLCBoUHJvcHMsIGZhY3Rvci5mcm9tLngsIGVsLmZyb20pO1xcbiAgICAgICAgZWwudG8gPSAkLmVmZmVjdHMuc2V0VHJhbnNpdGlvbihlbCwgaFByb3BzLCBmYWN0b3IudG8ueCwgZWwudG8pO1xcbiAgICAgIH1cXG4gICAgfSAvLyBTY2FsZSB0aGUgY29udGVudFxcblxcblxcbiAgICBpZiAoc2NhbGUgPT09IFxcXCJjb250ZW50XFxcIiB8fCBzY2FsZSA9PT0gXFxcImJvdGhcXFwiKSB7XFxuICAgICAgLy8gVmVydGljYWwgcHJvcHMgc2NhbGluZ1xcbiAgICAgIGlmIChmYWN0b3IuZnJvbS55ICE9PSBmYWN0b3IudG8ueSkge1xcbiAgICAgICAgcHJvcHMgPSBwcm9wcy5jb25jYXQoY1Byb3BzKS5jb25jYXQocHJvcHMyKTtcXG4gICAgICAgIGVsLmZyb20gPSAkLmVmZmVjdHMuc2V0VHJhbnNpdGlvbihlbCwgY1Byb3BzLCBmYWN0b3IuZnJvbS55LCBlbC5mcm9tKTtcXG4gICAgICAgIGVsLnRvID0gJC5lZmZlY3RzLnNldFRyYW5zaXRpb24oZWwsIGNQcm9wcywgZmFjdG9yLnRvLnksIGVsLnRvKTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgJC5lZmZlY3RzLnNhdmUoZWwsIHByb3BzKTtcXG4gICAgZWwuc2hvdygpO1xcbiAgICAkLmVmZmVjdHMuY3JlYXRlV3JhcHBlcihlbCk7XFxuICAgIGVsLmNzcyhcXFwib3ZlcmZsb3dcXFwiLCBcXFwiaGlkZGVuXFxcIikuY3NzKGVsLmZyb20pOyAvLyBBZGp1c3RcXG5cXG4gICAgaWYgKG9yaWdpbikge1xcbiAgICAgIC8vIENhbGN1bGF0ZSBiYXNlbGluZSBzaGlmdHNcXG4gICAgICBiYXNlbGluZSA9ICQuZWZmZWN0cy5nZXRCYXNlbGluZShvcmlnaW4sIG9yaWdpbmFsKTtcXG4gICAgICBlbC5mcm9tLnRvcCA9IChvcmlnaW5hbC5vdXRlckhlaWdodCAtIGVsLm91dGVySGVpZ2h0KCkpICogYmFzZWxpbmUueTtcXG4gICAgICBlbC5mcm9tLmxlZnQgPSAob3JpZ2luYWwub3V0ZXJXaWR0aCAtIGVsLm91dGVyV2lkdGgoKSkgKiBiYXNlbGluZS54O1xcbiAgICAgIGVsLnRvLnRvcCA9IChvcmlnaW5hbC5vdXRlckhlaWdodCAtIGVsLnRvLm91dGVySGVpZ2h0KSAqIGJhc2VsaW5lLnk7XFxuICAgICAgZWwudG8ubGVmdCA9IChvcmlnaW5hbC5vdXRlcldpZHRoIC0gZWwudG8ub3V0ZXJXaWR0aCkgKiBiYXNlbGluZS54O1xcbiAgICB9XFxuXFxuICAgIGVsLmNzcyhlbC5mcm9tKTsgLy8gc2V0IHRvcCAmIGxlZnRcXG4gICAgLy8gQW5pbWF0ZVxcblxcbiAgICBpZiAoc2NhbGUgPT09IFxcXCJjb250ZW50XFxcIiB8fCBzY2FsZSA9PT0gXFxcImJvdGhcXFwiKSB7XFxuICAgICAgLy8gU2NhbGUgdGhlIGNoaWxkcmVuXFxuICAgICAgLy8gQWRkIG1hcmdpbnMvZm9udC1zaXplXFxuICAgICAgdlByb3BzID0gdlByb3BzLmNvbmNhdChbXFxcIm1hcmdpblRvcFxcXCIsIFxcXCJtYXJnaW5Cb3R0b21cXFwiXSkuY29uY2F0KGNQcm9wcyk7XFxuICAgICAgaFByb3BzID0gaFByb3BzLmNvbmNhdChbXFxcIm1hcmdpbkxlZnRcXFwiLCBcXFwibWFyZ2luUmlnaHRcXFwiXSk7XFxuICAgICAgcHJvcHMyID0gcHJvcHMwLmNvbmNhdCh2UHJvcHMpLmNvbmNhdChoUHJvcHMpO1xcbiAgICAgIGVsLmZpbmQoXFxcIipbd2lkdGhdXFxcIikuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgY2hpbGQgPSAkKHRoaXMpLFxcbiAgICAgICAgICAgIGNfb3JpZ2luYWwgPSB7XFxuICAgICAgICAgIGhlaWdodDogY2hpbGQuaGVpZ2h0KCksXFxuICAgICAgICAgIHdpZHRoOiBjaGlsZC53aWR0aCgpLFxcbiAgICAgICAgICBvdXRlckhlaWdodDogY2hpbGQub3V0ZXJIZWlnaHQoKSxcXG4gICAgICAgICAgb3V0ZXJXaWR0aDogY2hpbGQub3V0ZXJXaWR0aCgpXFxuICAgICAgICB9O1xcblxcbiAgICAgICAgaWYgKHJlc3RvcmUpIHtcXG4gICAgICAgICAgJC5lZmZlY3RzLnNhdmUoY2hpbGQsIHByb3BzMik7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBjaGlsZC5mcm9tID0ge1xcbiAgICAgICAgICBoZWlnaHQ6IGNfb3JpZ2luYWwuaGVpZ2h0ICogZmFjdG9yLmZyb20ueSxcXG4gICAgICAgICAgd2lkdGg6IGNfb3JpZ2luYWwud2lkdGggKiBmYWN0b3IuZnJvbS54LFxcbiAgICAgICAgICBvdXRlckhlaWdodDogY19vcmlnaW5hbC5vdXRlckhlaWdodCAqIGZhY3Rvci5mcm9tLnksXFxuICAgICAgICAgIG91dGVyV2lkdGg6IGNfb3JpZ2luYWwub3V0ZXJXaWR0aCAqIGZhY3Rvci5mcm9tLnhcXG4gICAgICAgIH07XFxuICAgICAgICBjaGlsZC50byA9IHtcXG4gICAgICAgICAgaGVpZ2h0OiBjX29yaWdpbmFsLmhlaWdodCAqIGZhY3Rvci50by55LFxcbiAgICAgICAgICB3aWR0aDogY19vcmlnaW5hbC53aWR0aCAqIGZhY3Rvci50by54LFxcbiAgICAgICAgICBvdXRlckhlaWdodDogY19vcmlnaW5hbC5oZWlnaHQgKiBmYWN0b3IudG8ueSxcXG4gICAgICAgICAgb3V0ZXJXaWR0aDogY19vcmlnaW5hbC53aWR0aCAqIGZhY3Rvci50by54XFxuICAgICAgICB9OyAvLyBWZXJ0aWNhbCBwcm9wcyBzY2FsaW5nXFxuXFxuICAgICAgICBpZiAoZmFjdG9yLmZyb20ueSAhPT0gZmFjdG9yLnRvLnkpIHtcXG4gICAgICAgICAgY2hpbGQuZnJvbSA9ICQuZWZmZWN0cy5zZXRUcmFuc2l0aW9uKGNoaWxkLCB2UHJvcHMsIGZhY3Rvci5mcm9tLnksIGNoaWxkLmZyb20pO1xcbiAgICAgICAgICBjaGlsZC50byA9ICQuZWZmZWN0cy5zZXRUcmFuc2l0aW9uKGNoaWxkLCB2UHJvcHMsIGZhY3Rvci50by55LCBjaGlsZC50byk7XFxuICAgICAgICB9IC8vIEhvcml6b250YWwgcHJvcHMgc2NhbGluZ1xcblxcblxcbiAgICAgICAgaWYgKGZhY3Rvci5mcm9tLnggIT09IGZhY3Rvci50by54KSB7XFxuICAgICAgICAgIGNoaWxkLmZyb20gPSAkLmVmZmVjdHMuc2V0VHJhbnNpdGlvbihjaGlsZCwgaFByb3BzLCBmYWN0b3IuZnJvbS54LCBjaGlsZC5mcm9tKTtcXG4gICAgICAgICAgY2hpbGQudG8gPSAkLmVmZmVjdHMuc2V0VHJhbnNpdGlvbihjaGlsZCwgaFByb3BzLCBmYWN0b3IudG8ueCwgY2hpbGQudG8pO1xcbiAgICAgICAgfSAvLyBBbmltYXRlIGNoaWxkcmVuXFxuXFxuXFxuICAgICAgICBjaGlsZC5jc3MoY2hpbGQuZnJvbSk7XFxuICAgICAgICBjaGlsZC5hbmltYXRlKGNoaWxkLnRvLCBvLmR1cmF0aW9uLCBvLmVhc2luZywgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAvLyBSZXN0b3JlIGNoaWxkcmVuXFxuICAgICAgICAgIGlmIChyZXN0b3JlKSB7XFxuICAgICAgICAgICAgJC5lZmZlY3RzLnJlc3RvcmUoY2hpbGQsIHByb3BzMik7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICAgIH0pO1xcbiAgICB9IC8vIEFuaW1hdGVcXG5cXG5cXG4gICAgZWwuYW5pbWF0ZShlbC50bywge1xcbiAgICAgIHF1ZXVlOiBmYWxzZSxcXG4gICAgICBkdXJhdGlvbjogby5kdXJhdGlvbixcXG4gICAgICBlYXNpbmc6IG8uZWFzaW5nLFxcbiAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiBjb21wbGV0ZSgpIHtcXG4gICAgICAgIGlmIChlbC50by5vcGFjaXR5ID09PSAwKSB7XFxuICAgICAgICAgIGVsLmNzcyhcXFwib3BhY2l0eVxcXCIsIGVsLmZyb20ub3BhY2l0eSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAobW9kZSA9PT0gXFxcImhpZGVcXFwiKSB7XFxuICAgICAgICAgIGVsLmhpZGUoKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgICQuZWZmZWN0cy5yZXN0b3JlKGVsLCBwcm9wcyk7XFxuXFxuICAgICAgICBpZiAoIXJlc3RvcmUpIHtcXG4gICAgICAgICAgLy8gd2UgbmVlZCB0byBjYWxjdWxhdGUgb3VyIG5ldyBwb3NpdGlvbmluZyBiYXNlZCBvbiB0aGUgc2NhbGluZ1xcbiAgICAgICAgICBpZiAocG9zaXRpb24gPT09IFxcXCJzdGF0aWNcXFwiKSB7XFxuICAgICAgICAgICAgZWwuY3NzKHtcXG4gICAgICAgICAgICAgIHBvc2l0aW9uOiBcXFwicmVsYXRpdmVcXFwiLFxcbiAgICAgICAgICAgICAgdG9wOiBlbC50by50b3AsXFxuICAgICAgICAgICAgICBsZWZ0OiBlbC50by5sZWZ0XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgJC5lYWNoKFtcXFwidG9wXFxcIiwgXFxcImxlZnRcXFwiXSwgZnVuY3Rpb24gKGlkeCwgcG9zKSB7XFxuICAgICAgICAgICAgICBlbC5jc3MocG9zLCBmdW5jdGlvbiAoXywgc3RyKSB7XFxuICAgICAgICAgICAgICAgIHZhciB2YWwgPSBwYXJzZUludChzdHIsIDEwKSxcXG4gICAgICAgICAgICAgICAgICAgIHRvUmVmID0gaWR4ID8gZWwudG8ubGVmdCA6IGVsLnRvLnRvcDsgLy8gaWYgb3JpZ2luYWwgd2FzIFxcXCJhdXRvXFxcIiwgcmVjYWxjdWxhdGUgdGhlIG5ldyB2YWx1ZSBmcm9tIHdyYXBwZXJcXG5cXG4gICAgICAgICAgICAgICAgaWYgKHN0ciA9PT0gXFxcImF1dG9cXFwiKSB7XFxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRvUmVmICsgXFxcInB4XFxcIjtcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsICsgdG9SZWYgKyBcXFwicHhcXFwiO1xcbiAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgICQuZWZmZWN0cy5yZW1vdmVXcmFwcGVyKGVsKTtcXG4gICAgICAgIGRvbmUoKTtcXG4gICAgICB9XFxuICAgIH0pO1xcbiAgfTtcXG4gIC8qIVxcbiAgICogalF1ZXJ5IFVJIEVmZmVjdHMgU2NhbGUgMS4xMS40XFxuICAgKiBodHRwOi8vanF1ZXJ5dWkuY29tXFxuICAgKlxcbiAgICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcXG4gICAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cXG4gICAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcXG4gICAqXFxuICAgKiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9zY2FsZS1lZmZlY3QvXFxuICAgKi9cXG5cXG5cXG4gIHZhciBlZmZlY3RTY2FsZSA9ICQuZWZmZWN0cy5lZmZlY3Quc2NhbGUgPSBmdW5jdGlvbiAobywgZG9uZSkge1xcbiAgICAvLyBDcmVhdGUgZWxlbWVudFxcbiAgICB2YXIgZWwgPSAkKHRoaXMpLFxcbiAgICAgICAgb3B0aW9ucyA9ICQuZXh0ZW5kKHRydWUsIHt9LCBvKSxcXG4gICAgICAgIG1vZGUgPSAkLmVmZmVjdHMuc2V0TW9kZShlbCwgby5tb2RlIHx8IFxcXCJlZmZlY3RcXFwiKSxcXG4gICAgICAgIHBlcmNlbnQgPSBwYXJzZUludChvLnBlcmNlbnQsIDEwKSB8fCAocGFyc2VJbnQoby5wZXJjZW50LCAxMCkgPT09IDAgPyAwIDogbW9kZSA9PT0gXFxcImhpZGVcXFwiID8gMCA6IDEwMCksXFxuICAgICAgICBkaXJlY3Rpb24gPSBvLmRpcmVjdGlvbiB8fCBcXFwiYm90aFxcXCIsXFxuICAgICAgICBvcmlnaW4gPSBvLm9yaWdpbixcXG4gICAgICAgIG9yaWdpbmFsID0ge1xcbiAgICAgIGhlaWdodDogZWwuaGVpZ2h0KCksXFxuICAgICAgd2lkdGg6IGVsLndpZHRoKCksXFxuICAgICAgb3V0ZXJIZWlnaHQ6IGVsLm91dGVySGVpZ2h0KCksXFxuICAgICAgb3V0ZXJXaWR0aDogZWwub3V0ZXJXaWR0aCgpXFxuICAgIH0sXFxuICAgICAgICBmYWN0b3IgPSB7XFxuICAgICAgeTogZGlyZWN0aW9uICE9PSBcXFwiaG9yaXpvbnRhbFxcXCIgPyBwZXJjZW50IC8gMTAwIDogMSxcXG4gICAgICB4OiBkaXJlY3Rpb24gIT09IFxcXCJ2ZXJ0aWNhbFxcXCIgPyBwZXJjZW50IC8gMTAwIDogMVxcbiAgICB9OyAvLyBXZSBhcmUgZ29pbmcgdG8gcGFzcyB0aGlzIGVmZmVjdCB0byB0aGUgc2l6ZSBlZmZlY3Q6XFxuXFxuICAgIG9wdGlvbnMuZWZmZWN0ID0gXFxcInNpemVcXFwiO1xcbiAgICBvcHRpb25zLnF1ZXVlID0gZmFsc2U7XFxuICAgIG9wdGlvbnMuY29tcGxldGUgPSBkb25lOyAvLyBTZXQgZGVmYXVsdCBvcmlnaW4gYW5kIHJlc3RvcmUgZm9yIHNob3cvaGlkZVxcblxcbiAgICBpZiAobW9kZSAhPT0gXFxcImVmZmVjdFxcXCIpIHtcXG4gICAgICBvcHRpb25zLm9yaWdpbiA9IG9yaWdpbiB8fCBbXFxcIm1pZGRsZVxcXCIsIFxcXCJjZW50ZXJcXFwiXTtcXG4gICAgICBvcHRpb25zLnJlc3RvcmUgPSB0cnVlO1xcbiAgICB9XFxuXFxuICAgIG9wdGlvbnMuZnJvbSA9IG8uZnJvbSB8fCAobW9kZSA9PT0gXFxcInNob3dcXFwiID8ge1xcbiAgICAgIGhlaWdodDogMCxcXG4gICAgICB3aWR0aDogMCxcXG4gICAgICBvdXRlckhlaWdodDogMCxcXG4gICAgICBvdXRlcldpZHRoOiAwXFxuICAgIH0gOiBvcmlnaW5hbCk7XFxuICAgIG9wdGlvbnMudG8gPSB7XFxuICAgICAgaGVpZ2h0OiBvcmlnaW5hbC5oZWlnaHQgKiBmYWN0b3IueSxcXG4gICAgICB3aWR0aDogb3JpZ2luYWwud2lkdGggKiBmYWN0b3IueCxcXG4gICAgICBvdXRlckhlaWdodDogb3JpZ2luYWwub3V0ZXJIZWlnaHQgKiBmYWN0b3IueSxcXG4gICAgICBvdXRlcldpZHRoOiBvcmlnaW5hbC5vdXRlcldpZHRoICogZmFjdG9yLnhcXG4gICAgfTsgLy8gRmFkZSBvcHRpb24gdG8gc3VwcG9ydCBwdWZmXFxuXFxuICAgIGlmIChvcHRpb25zLmZhZGUpIHtcXG4gICAgICBpZiAobW9kZSA9PT0gXFxcInNob3dcXFwiKSB7XFxuICAgICAgICBvcHRpb25zLmZyb20ub3BhY2l0eSA9IDA7XFxuICAgICAgICBvcHRpb25zLnRvLm9wYWNpdHkgPSAxO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAobW9kZSA9PT0gXFxcImhpZGVcXFwiKSB7XFxuICAgICAgICBvcHRpb25zLmZyb20ub3BhY2l0eSA9IDE7XFxuICAgICAgICBvcHRpb25zLnRvLm9wYWNpdHkgPSAwO1xcbiAgICAgIH1cXG4gICAgfSAvLyBBbmltYXRlXFxuXFxuXFxuICAgIGVsLmVmZmVjdChvcHRpb25zKTtcXG4gIH07XFxuICAvKiFcXG4gICAqIGpRdWVyeSBVSSBFZmZlY3RzIFB1ZmYgMS4xMS40XFxuICAgKiBodHRwOi8vanF1ZXJ5dWkuY29tXFxuICAgKlxcbiAgICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcXG4gICAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cXG4gICAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcXG4gICAqXFxuICAgKiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9wdWZmLWVmZmVjdC9cXG4gICAqL1xcblxcblxcbiAgdmFyIGVmZmVjdFB1ZmYgPSAkLmVmZmVjdHMuZWZmZWN0LnB1ZmYgPSBmdW5jdGlvbiAobywgZG9uZSkge1xcbiAgICB2YXIgZWxlbSA9ICQodGhpcyksXFxuICAgICAgICBtb2RlID0gJC5lZmZlY3RzLnNldE1vZGUoZWxlbSwgby5tb2RlIHx8IFxcXCJoaWRlXFxcIiksXFxuICAgICAgICBoaWRlID0gbW9kZSA9PT0gXFxcImhpZGVcXFwiLFxcbiAgICAgICAgcGVyY2VudCA9IHBhcnNlSW50KG8ucGVyY2VudCwgMTApIHx8IDE1MCxcXG4gICAgICAgIGZhY3RvciA9IHBlcmNlbnQgLyAxMDAsXFxuICAgICAgICBvcmlnaW5hbCA9IHtcXG4gICAgICBoZWlnaHQ6IGVsZW0uaGVpZ2h0KCksXFxuICAgICAgd2lkdGg6IGVsZW0ud2lkdGgoKSxcXG4gICAgICBvdXRlckhlaWdodDogZWxlbS5vdXRlckhlaWdodCgpLFxcbiAgICAgIG91dGVyV2lkdGg6IGVsZW0ub3V0ZXJXaWR0aCgpXFxuICAgIH07XFxuICAgICQuZXh0ZW5kKG8sIHtcXG4gICAgICBlZmZlY3Q6IFxcXCJzY2FsZVxcXCIsXFxuICAgICAgcXVldWU6IGZhbHNlLFxcbiAgICAgIGZhZGU6IHRydWUsXFxuICAgICAgbW9kZTogbW9kZSxcXG4gICAgICBjb21wbGV0ZTogZG9uZSxcXG4gICAgICBwZXJjZW50OiBoaWRlID8gcGVyY2VudCA6IDEwMCxcXG4gICAgICBmcm9tOiBoaWRlID8gb3JpZ2luYWwgOiB7XFxuICAgICAgICBoZWlnaHQ6IG9yaWdpbmFsLmhlaWdodCAqIGZhY3RvcixcXG4gICAgICAgIHdpZHRoOiBvcmlnaW5hbC53aWR0aCAqIGZhY3RvcixcXG4gICAgICAgIG91dGVySGVpZ2h0OiBvcmlnaW5hbC5vdXRlckhlaWdodCAqIGZhY3RvcixcXG4gICAgICAgIG91dGVyV2lkdGg6IG9yaWdpbmFsLm91dGVyV2lkdGggKiBmYWN0b3JcXG4gICAgICB9XFxuICAgIH0pO1xcbiAgICBlbGVtLmVmZmVjdChvKTtcXG4gIH07XFxuICAvKiFcXG4gICAqIGpRdWVyeSBVSSBFZmZlY3RzIFB1bHNhdGUgMS4xMS40XFxuICAgKiBodHRwOi8vanF1ZXJ5dWkuY29tXFxuICAgKlxcbiAgICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcXG4gICAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cXG4gICAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcXG4gICAqXFxuICAgKiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9wdWxzYXRlLWVmZmVjdC9cXG4gICAqL1xcblxcblxcbiAgdmFyIGVmZmVjdFB1bHNhdGUgPSAkLmVmZmVjdHMuZWZmZWN0LnB1bHNhdGUgPSBmdW5jdGlvbiAobywgZG9uZSkge1xcbiAgICB2YXIgZWxlbSA9ICQodGhpcyksXFxuICAgICAgICBtb2RlID0gJC5lZmZlY3RzLnNldE1vZGUoZWxlbSwgby5tb2RlIHx8IFxcXCJzaG93XFxcIiksXFxuICAgICAgICBzaG93ID0gbW9kZSA9PT0gXFxcInNob3dcXFwiLFxcbiAgICAgICAgaGlkZSA9IG1vZGUgPT09IFxcXCJoaWRlXFxcIixcXG4gICAgICAgIHNob3doaWRlID0gc2hvdyB8fCBtb2RlID09PSBcXFwiaGlkZVxcXCIsXFxuICAgICAgICAvLyBzaG93aW5nIG9yIGhpZGluZyBsZWF2ZXMgb2YgdGhlIFxcXCJsYXN0XFxcIiBhbmltYXRpb25cXG4gICAgYW5pbXMgPSAoby50aW1lcyB8fCA1KSAqIDIgKyAoc2hvd2hpZGUgPyAxIDogMCksXFxuICAgICAgICBkdXJhdGlvbiA9IG8uZHVyYXRpb24gLyBhbmltcyxcXG4gICAgICAgIGFuaW1hdGVUbyA9IDAsXFxuICAgICAgICBxdWV1ZSA9IGVsZW0ucXVldWUoKSxcXG4gICAgICAgIHF1ZXVlbGVuID0gcXVldWUubGVuZ3RoLFxcbiAgICAgICAgaTtcXG5cXG4gICAgaWYgKHNob3cgfHwgIWVsZW0uaXMoXFxcIjp2aXNpYmxlXFxcIikpIHtcXG4gICAgICBlbGVtLmNzcyhcXFwib3BhY2l0eVxcXCIsIDApLnNob3coKTtcXG4gICAgICBhbmltYXRlVG8gPSAxO1xcbiAgICB9IC8vIGFuaW1zIC0gMSBvcGFjaXR5IFxcXCJ0b2dnbGVzXFxcIlxcblxcblxcbiAgICBmb3IgKGkgPSAxOyBpIDwgYW5pbXM7IGkrKykge1xcbiAgICAgIGVsZW0uYW5pbWF0ZSh7XFxuICAgICAgICBvcGFjaXR5OiBhbmltYXRlVG9cXG4gICAgICB9LCBkdXJhdGlvbiwgby5lYXNpbmcpO1xcbiAgICAgIGFuaW1hdGVUbyA9IDEgLSBhbmltYXRlVG87XFxuICAgIH1cXG5cXG4gICAgZWxlbS5hbmltYXRlKHtcXG4gICAgICBvcGFjaXR5OiBhbmltYXRlVG9cXG4gICAgfSwgZHVyYXRpb24sIG8uZWFzaW5nKTtcXG4gICAgZWxlbS5xdWV1ZShmdW5jdGlvbiAoKSB7XFxuICAgICAgaWYgKGhpZGUpIHtcXG4gICAgICAgIGVsZW0uaGlkZSgpO1xcbiAgICAgIH1cXG5cXG4gICAgICBkb25lKCk7XFxuICAgIH0pOyAvLyBXZSBqdXN0IHF1ZXVlZCB1cCBcXFwiYW5pbXNcXFwiIGFuaW1hdGlvbnMsIHdlIG5lZWQgdG8gcHV0IHRoZW0gbmV4dCBpbiB0aGUgcXVldWVcXG5cXG4gICAgaWYgKHF1ZXVlbGVuID4gMSkge1xcbiAgICAgIHF1ZXVlLnNwbGljZS5hcHBseShxdWV1ZSwgWzEsIDBdLmNvbmNhdChxdWV1ZS5zcGxpY2UocXVldWVsZW4sIGFuaW1zICsgMSkpKTtcXG4gICAgfVxcblxcbiAgICBlbGVtLmRlcXVldWUoKTtcXG4gIH07XFxuICAvKiFcXG4gICAqIGpRdWVyeSBVSSBFZmZlY3RzIFNoYWtlIDEuMTEuNFxcbiAgICogaHR0cDovL2pxdWVyeXVpLmNvbVxcbiAgICpcXG4gICAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXFxuICAgKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXFxuICAgKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXFxuICAgKlxcbiAgICogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20vc2hha2UtZWZmZWN0L1xcbiAgICovXFxuXFxuXFxuICB2YXIgZWZmZWN0U2hha2UgPSAkLmVmZmVjdHMuZWZmZWN0LnNoYWtlID0gZnVuY3Rpb24gKG8sIGRvbmUpIHtcXG4gICAgdmFyIGVsID0gJCh0aGlzKSxcXG4gICAgICAgIHByb3BzID0gW1xcXCJwb3NpdGlvblxcXCIsIFxcXCJ0b3BcXFwiLCBcXFwiYm90dG9tXFxcIiwgXFxcImxlZnRcXFwiLCBcXFwicmlnaHRcXFwiLCBcXFwiaGVpZ2h0XFxcIiwgXFxcIndpZHRoXFxcIl0sXFxuICAgICAgICBtb2RlID0gJC5lZmZlY3RzLnNldE1vZGUoZWwsIG8ubW9kZSB8fCBcXFwiZWZmZWN0XFxcIiksXFxuICAgICAgICBkaXJlY3Rpb24gPSBvLmRpcmVjdGlvbiB8fCBcXFwibGVmdFxcXCIsXFxuICAgICAgICBkaXN0YW5jZSA9IG8uZGlzdGFuY2UgfHwgMjAsXFxuICAgICAgICB0aW1lcyA9IG8udGltZXMgfHwgMyxcXG4gICAgICAgIGFuaW1zID0gdGltZXMgKiAyICsgMSxcXG4gICAgICAgIHNwZWVkID0gTWF0aC5yb3VuZChvLmR1cmF0aW9uIC8gYW5pbXMpLFxcbiAgICAgICAgcmVmID0gZGlyZWN0aW9uID09PSBcXFwidXBcXFwiIHx8IGRpcmVjdGlvbiA9PT0gXFxcImRvd25cXFwiID8gXFxcInRvcFxcXCIgOiBcXFwibGVmdFxcXCIsXFxuICAgICAgICBwb3NpdGl2ZU1vdGlvbiA9IGRpcmVjdGlvbiA9PT0gXFxcInVwXFxcIiB8fCBkaXJlY3Rpb24gPT09IFxcXCJsZWZ0XFxcIixcXG4gICAgICAgIGFuaW1hdGlvbiA9IHt9LFxcbiAgICAgICAgYW5pbWF0aW9uMSA9IHt9LFxcbiAgICAgICAgYW5pbWF0aW9uMiA9IHt9LFxcbiAgICAgICAgaSxcXG4gICAgICAgIC8vIHdlIHdpbGwgbmVlZCB0byByZS1hc3NlbWJsZSB0aGUgcXVldWUgdG8gc3RhY2sgb3VyIGFuaW1hdGlvbnMgaW4gcGxhY2VcXG4gICAgcXVldWUgPSBlbC5xdWV1ZSgpLFxcbiAgICAgICAgcXVldWVsZW4gPSBxdWV1ZS5sZW5ndGg7XFxuICAgICQuZWZmZWN0cy5zYXZlKGVsLCBwcm9wcyk7XFxuICAgIGVsLnNob3coKTtcXG4gICAgJC5lZmZlY3RzLmNyZWF0ZVdyYXBwZXIoZWwpOyAvLyBBbmltYXRpb25cXG5cXG4gICAgYW5pbWF0aW9uW3JlZl0gPSAocG9zaXRpdmVNb3Rpb24gPyBcXFwiLT1cXFwiIDogXFxcIis9XFxcIikgKyBkaXN0YW5jZTtcXG4gICAgYW5pbWF0aW9uMVtyZWZdID0gKHBvc2l0aXZlTW90aW9uID8gXFxcIis9XFxcIiA6IFxcXCItPVxcXCIpICsgZGlzdGFuY2UgKiAyO1xcbiAgICBhbmltYXRpb24yW3JlZl0gPSAocG9zaXRpdmVNb3Rpb24gPyBcXFwiLT1cXFwiIDogXFxcIis9XFxcIikgKyBkaXN0YW5jZSAqIDI7IC8vIEFuaW1hdGVcXG5cXG4gICAgZWwuYW5pbWF0ZShhbmltYXRpb24sIHNwZWVkLCBvLmVhc2luZyk7IC8vIFNoYWtlc1xcblxcbiAgICBmb3IgKGkgPSAxOyBpIDwgdGltZXM7IGkrKykge1xcbiAgICAgIGVsLmFuaW1hdGUoYW5pbWF0aW9uMSwgc3BlZWQsIG8uZWFzaW5nKS5hbmltYXRlKGFuaW1hdGlvbjIsIHNwZWVkLCBvLmVhc2luZyk7XFxuICAgIH1cXG5cXG4gICAgZWwuYW5pbWF0ZShhbmltYXRpb24xLCBzcGVlZCwgby5lYXNpbmcpLmFuaW1hdGUoYW5pbWF0aW9uLCBzcGVlZCAvIDIsIG8uZWFzaW5nKS5xdWV1ZShmdW5jdGlvbiAoKSB7XFxuICAgICAgaWYgKG1vZGUgPT09IFxcXCJoaWRlXFxcIikge1xcbiAgICAgICAgZWwuaGlkZSgpO1xcbiAgICAgIH1cXG5cXG4gICAgICAkLmVmZmVjdHMucmVzdG9yZShlbCwgcHJvcHMpO1xcbiAgICAgICQuZWZmZWN0cy5yZW1vdmVXcmFwcGVyKGVsKTtcXG4gICAgICBkb25lKCk7XFxuICAgIH0pOyAvLyBpbmplY3QgYWxsIHRoZSBhbmltYXRpb25zIHdlIGp1c3QgcXVldWVkIHRvIGJlIGZpcnN0IGluIGxpbmUgKGFmdGVyIFxcXCJpbnByb2dyZXNzXFxcIilcXG5cXG4gICAgaWYgKHF1ZXVlbGVuID4gMSkge1xcbiAgICAgIHF1ZXVlLnNwbGljZS5hcHBseShxdWV1ZSwgWzEsIDBdLmNvbmNhdChxdWV1ZS5zcGxpY2UocXVldWVsZW4sIGFuaW1zICsgMSkpKTtcXG4gICAgfVxcblxcbiAgICBlbC5kZXF1ZXVlKCk7XFxuICB9O1xcbiAgLyohXFxuICAgKiBqUXVlcnkgVUkgRWZmZWN0cyBTbGlkZSAxLjExLjRcXG4gICAqIGh0dHA6Ly9qcXVlcnl1aS5jb21cXG4gICAqXFxuICAgKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xcbiAgICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxcbiAgICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxcbiAgICpcXG4gICAqIGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL3NsaWRlLWVmZmVjdC9cXG4gICAqL1xcblxcblxcbiAgdmFyIGVmZmVjdFNsaWRlID0gJC5lZmZlY3RzLmVmZmVjdC5zbGlkZSA9IGZ1bmN0aW9uIChvLCBkb25lKSB7XFxuICAgIC8vIENyZWF0ZSBlbGVtZW50XFxuICAgIHZhciBlbCA9ICQodGhpcyksXFxuICAgICAgICBwcm9wcyA9IFtcXFwicG9zaXRpb25cXFwiLCBcXFwidG9wXFxcIiwgXFxcImJvdHRvbVxcXCIsIFxcXCJsZWZ0XFxcIiwgXFxcInJpZ2h0XFxcIiwgXFxcIndpZHRoXFxcIiwgXFxcImhlaWdodFxcXCJdLFxcbiAgICAgICAgbW9kZSA9ICQuZWZmZWN0cy5zZXRNb2RlKGVsLCBvLm1vZGUgfHwgXFxcInNob3dcXFwiKSxcXG4gICAgICAgIHNob3cgPSBtb2RlID09PSBcXFwic2hvd1xcXCIsXFxuICAgICAgICBkaXJlY3Rpb24gPSBvLmRpcmVjdGlvbiB8fCBcXFwibGVmdFxcXCIsXFxuICAgICAgICByZWYgPSBkaXJlY3Rpb24gPT09IFxcXCJ1cFxcXCIgfHwgZGlyZWN0aW9uID09PSBcXFwiZG93blxcXCIgPyBcXFwidG9wXFxcIiA6IFxcXCJsZWZ0XFxcIixcXG4gICAgICAgIHBvc2l0aXZlTW90aW9uID0gZGlyZWN0aW9uID09PSBcXFwidXBcXFwiIHx8IGRpcmVjdGlvbiA9PT0gXFxcImxlZnRcXFwiLFxcbiAgICAgICAgZGlzdGFuY2UsXFxuICAgICAgICBhbmltYXRpb24gPSB7fTsgLy8gQWRqdXN0XFxuXFxuICAgICQuZWZmZWN0cy5zYXZlKGVsLCBwcm9wcyk7XFxuICAgIGVsLnNob3coKTtcXG4gICAgZGlzdGFuY2UgPSBvLmRpc3RhbmNlIHx8IGVsW3JlZiA9PT0gXFxcInRvcFxcXCIgPyBcXFwib3V0ZXJIZWlnaHRcXFwiIDogXFxcIm91dGVyV2lkdGhcXFwiXSh0cnVlKTtcXG4gICAgJC5lZmZlY3RzLmNyZWF0ZVdyYXBwZXIoZWwpLmNzcyh7XFxuICAgICAgb3ZlcmZsb3c6IFxcXCJoaWRkZW5cXFwiXFxuICAgIH0pO1xcblxcbiAgICBpZiAoc2hvdykge1xcbiAgICAgIGVsLmNzcyhyZWYsIHBvc2l0aXZlTW90aW9uID8gaXNOYU4oZGlzdGFuY2UpID8gXFxcIi1cXFwiICsgZGlzdGFuY2UgOiAtZGlzdGFuY2UgOiBkaXN0YW5jZSk7XFxuICAgIH0gLy8gQW5pbWF0aW9uXFxuXFxuXFxuICAgIGFuaW1hdGlvbltyZWZdID0gKHNob3cgPyBwb3NpdGl2ZU1vdGlvbiA/IFxcXCIrPVxcXCIgOiBcXFwiLT1cXFwiIDogcG9zaXRpdmVNb3Rpb24gPyBcXFwiLT1cXFwiIDogXFxcIis9XFxcIikgKyBkaXN0YW5jZTsgLy8gQW5pbWF0ZVxcblxcbiAgICBlbC5hbmltYXRlKGFuaW1hdGlvbiwge1xcbiAgICAgIHF1ZXVlOiBmYWxzZSxcXG4gICAgICBkdXJhdGlvbjogby5kdXJhdGlvbixcXG4gICAgICBlYXNpbmc6IG8uZWFzaW5nLFxcbiAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiBjb21wbGV0ZSgpIHtcXG4gICAgICAgIGlmIChtb2RlID09PSBcXFwiaGlkZVxcXCIpIHtcXG4gICAgICAgICAgZWwuaGlkZSgpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgJC5lZmZlY3RzLnJlc3RvcmUoZWwsIHByb3BzKTtcXG4gICAgICAgICQuZWZmZWN0cy5yZW1vdmVXcmFwcGVyKGVsKTtcXG4gICAgICAgIGRvbmUoKTtcXG4gICAgICB9XFxuICAgIH0pO1xcbiAgfTtcXG4gIC8qIVxcbiAgICogalF1ZXJ5IFVJIEVmZmVjdHMgVHJhbnNmZXIgMS4xMS40XFxuICAgKiBodHRwOi8vanF1ZXJ5dWkuY29tXFxuICAgKlxcbiAgICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcXG4gICAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cXG4gICAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcXG4gICAqXFxuICAgKiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS90cmFuc2Zlci1lZmZlY3QvXFxuICAgKi9cXG5cXG5cXG4gIHZhciBlZmZlY3RUcmFuc2ZlciA9ICQuZWZmZWN0cy5lZmZlY3QudHJhbnNmZXIgPSBmdW5jdGlvbiAobywgZG9uZSkge1xcbiAgICB2YXIgZWxlbSA9ICQodGhpcyksXFxuICAgICAgICB0YXJnZXQgPSAkKG8udG8pLFxcbiAgICAgICAgdGFyZ2V0Rml4ZWQgPSB0YXJnZXQuY3NzKFxcXCJwb3NpdGlvblxcXCIpID09PSBcXFwiZml4ZWRcXFwiLFxcbiAgICAgICAgYm9keSA9ICQoXFxcImJvZHlcXFwiKSxcXG4gICAgICAgIGZpeFRvcCA9IHRhcmdldEZpeGVkID8gYm9keS5zY3JvbGxUb3AoKSA6IDAsXFxuICAgICAgICBmaXhMZWZ0ID0gdGFyZ2V0Rml4ZWQgPyBib2R5LnNjcm9sbExlZnQoKSA6IDAsXFxuICAgICAgICBlbmRQb3NpdGlvbiA9IHRhcmdldC5vZmZzZXQoKSxcXG4gICAgICAgIGFuaW1hdGlvbiA9IHtcXG4gICAgICB0b3A6IGVuZFBvc2l0aW9uLnRvcCAtIGZpeFRvcCxcXG4gICAgICBsZWZ0OiBlbmRQb3NpdGlvbi5sZWZ0IC0gZml4TGVmdCxcXG4gICAgICBoZWlnaHQ6IHRhcmdldC5pbm5lckhlaWdodCgpLFxcbiAgICAgIHdpZHRoOiB0YXJnZXQuaW5uZXJXaWR0aCgpXFxuICAgIH0sXFxuICAgICAgICBzdGFydFBvc2l0aW9uID0gZWxlbS5vZmZzZXQoKSxcXG4gICAgICAgIHRyYW5zZmVyID0gJChcXFwiPGRpdiBjbGFzcz0ndWktZWZmZWN0cy10cmFuc2Zlcic+PC9kaXY+XFxcIikuYXBwZW5kVG8oZG9jdW1lbnQuYm9keSkuYWRkQ2xhc3Moby5jbGFzc05hbWUpLmNzcyh7XFxuICAgICAgdG9wOiBzdGFydFBvc2l0aW9uLnRvcCAtIGZpeFRvcCxcXG4gICAgICBsZWZ0OiBzdGFydFBvc2l0aW9uLmxlZnQgLSBmaXhMZWZ0LFxcbiAgICAgIGhlaWdodDogZWxlbS5pbm5lckhlaWdodCgpLFxcbiAgICAgIHdpZHRoOiBlbGVtLmlubmVyV2lkdGgoKSxcXG4gICAgICBwb3NpdGlvbjogdGFyZ2V0Rml4ZWQgPyBcXFwiZml4ZWRcXFwiIDogXFxcImFic29sdXRlXFxcIlxcbiAgICB9KS5hbmltYXRlKGFuaW1hdGlvbiwgby5kdXJhdGlvbiwgby5lYXNpbmcsIGZ1bmN0aW9uICgpIHtcXG4gICAgICB0cmFuc2Zlci5yZW1vdmUoKTtcXG4gICAgICBkb25lKCk7XFxuICAgIH0pO1xcbiAgfTtcXG4gIC8qIVxcbiAgICogalF1ZXJ5IFVJIFByb2dyZXNzYmFyIDEuMTEuNFxcbiAgICogaHR0cDovL2pxdWVyeXVpLmNvbVxcbiAgICpcXG4gICAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXFxuICAgKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXFxuICAgKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXFxuICAgKlxcbiAgICogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20vcHJvZ3Jlc3NiYXIvXFxuICAgKi9cXG5cXG5cXG4gIHZhciBwcm9ncmVzc2JhciA9ICQud2lkZ2V0KFxcXCJ1aS5wcm9ncmVzc2JhclxcXCIsIHtcXG4gICAgdmVyc2lvbjogXFxcIjEuMTEuNFxcXCIsXFxuICAgIG9wdGlvbnM6IHtcXG4gICAgICBtYXg6IDEwMCxcXG4gICAgICB2YWx1ZTogMCxcXG4gICAgICBjaGFuZ2U6IG51bGwsXFxuICAgICAgY29tcGxldGU6IG51bGxcXG4gICAgfSxcXG4gICAgbWluOiAwLFxcbiAgICBfY3JlYXRlOiBmdW5jdGlvbiBfY3JlYXRlKCkge1xcbiAgICAgIC8vIENvbnN0cmFpbiBpbml0aWFsIHZhbHVlXFxuICAgICAgdGhpcy5vbGRWYWx1ZSA9IHRoaXMub3B0aW9ucy52YWx1ZSA9IHRoaXMuX2NvbnN0cmFpbmVkVmFsdWUoKTtcXG4gICAgICB0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoXFxcInVpLXByb2dyZXNzYmFyIHVpLXdpZGdldCB1aS13aWRnZXQtY29udGVudCB1aS1jb3JuZXItYWxsXFxcIikuYXR0cih7XFxuICAgICAgICAvLyBPbmx5IHNldCBzdGF0aWMgdmFsdWVzLCBhcmlhLXZhbHVlbm93IGFuZCBhcmlhLXZhbHVlbWF4IGFyZVxcbiAgICAgICAgLy8gc2V0IGluc2lkZSBfcmVmcmVzaFZhbHVlKClcXG4gICAgICAgIHJvbGU6IFxcXCJwcm9ncmVzc2JhclxcXCIsXFxuICAgICAgICBcXFwiYXJpYS12YWx1ZW1pblxcXCI6IHRoaXMubWluXFxuICAgICAgfSk7XFxuICAgICAgdGhpcy52YWx1ZURpdiA9ICQoXFxcIjxkaXYgY2xhc3M9J3VpLXByb2dyZXNzYmFyLXZhbHVlIHVpLXdpZGdldC1oZWFkZXIgdWktY29ybmVyLWxlZnQnPjwvZGl2PlxcXCIpLmFwcGVuZFRvKHRoaXMuZWxlbWVudCk7XFxuXFxuICAgICAgdGhpcy5fcmVmcmVzaFZhbHVlKCk7XFxuICAgIH0sXFxuICAgIF9kZXN0cm95OiBmdW5jdGlvbiBfZGVzdHJveSgpIHtcXG4gICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlQ2xhc3MoXFxcInVpLXByb2dyZXNzYmFyIHVpLXdpZGdldCB1aS13aWRnZXQtY29udGVudCB1aS1jb3JuZXItYWxsXFxcIikucmVtb3ZlQXR0cihcXFwicm9sZVxcXCIpLnJlbW92ZUF0dHIoXFxcImFyaWEtdmFsdWVtaW5cXFwiKS5yZW1vdmVBdHRyKFxcXCJhcmlhLXZhbHVlbWF4XFxcIikucmVtb3ZlQXR0cihcXFwiYXJpYS12YWx1ZW5vd1xcXCIpO1xcbiAgICAgIHRoaXMudmFsdWVEaXYucmVtb3ZlKCk7XFxuICAgIH0sXFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShuZXdWYWx1ZSkge1xcbiAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnZhbHVlO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLm9wdGlvbnMudmFsdWUgPSB0aGlzLl9jb25zdHJhaW5lZFZhbHVlKG5ld1ZhbHVlKTtcXG5cXG4gICAgICB0aGlzLl9yZWZyZXNoVmFsdWUoKTtcXG4gICAgfSxcXG4gICAgX2NvbnN0cmFpbmVkVmFsdWU6IGZ1bmN0aW9uIF9jb25zdHJhaW5lZFZhbHVlKG5ld1ZhbHVlKSB7XFxuICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcXG4gICAgICAgIG5ld1ZhbHVlID0gdGhpcy5vcHRpb25zLnZhbHVlO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLmluZGV0ZXJtaW5hdGUgPSBuZXdWYWx1ZSA9PT0gZmFsc2U7IC8vIHNhbml0aXplIHZhbHVlXFxuXFxuICAgICAgaWYgKHR5cGVvZiBuZXdWYWx1ZSAhPT0gXFxcIm51bWJlclxcXCIpIHtcXG4gICAgICAgIG5ld1ZhbHVlID0gMDtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHRoaXMuaW5kZXRlcm1pbmF0ZSA/IGZhbHNlIDogTWF0aC5taW4odGhpcy5vcHRpb25zLm1heCwgTWF0aC5tYXgodGhpcy5taW4sIG5ld1ZhbHVlKSk7XFxuICAgIH0sXFxuICAgIF9zZXRPcHRpb25zOiBmdW5jdGlvbiBfc2V0T3B0aW9ucyhvcHRpb25zKSB7XFxuICAgICAgLy8gRW5zdXJlIFxcXCJ2YWx1ZVxcXCIgb3B0aW9uIGlzIHNldCBhZnRlciBvdGhlciB2YWx1ZXMgKGxpa2UgbWF4KVxcbiAgICAgIHZhciB2YWx1ZSA9IG9wdGlvbnMudmFsdWU7XFxuICAgICAgZGVsZXRlIG9wdGlvbnMudmFsdWU7XFxuXFxuICAgICAgdGhpcy5fc3VwZXIob3B0aW9ucyk7XFxuXFxuICAgICAgdGhpcy5vcHRpb25zLnZhbHVlID0gdGhpcy5fY29uc3RyYWluZWRWYWx1ZSh2YWx1ZSk7XFxuXFxuICAgICAgdGhpcy5fcmVmcmVzaFZhbHVlKCk7XFxuICAgIH0sXFxuICAgIF9zZXRPcHRpb246IGZ1bmN0aW9uIF9zZXRPcHRpb24oa2V5LCB2YWx1ZSkge1xcbiAgICAgIGlmIChrZXkgPT09IFxcXCJtYXhcXFwiKSB7XFxuICAgICAgICAvLyBEb24ndCBhbGxvdyBhIG1heCBsZXNzIHRoYW4gbWluXFxuICAgICAgICB2YWx1ZSA9IE1hdGgubWF4KHRoaXMubWluLCB2YWx1ZSk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChrZXkgPT09IFxcXCJkaXNhYmxlZFxcXCIpIHtcXG4gICAgICAgIHRoaXMuZWxlbWVudC50b2dnbGVDbGFzcyhcXFwidWktc3RhdGUtZGlzYWJsZWRcXFwiLCAhIXZhbHVlKS5hdHRyKFxcXCJhcmlhLWRpc2FibGVkXFxcIiwgdmFsdWUpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9zdXBlcihrZXksIHZhbHVlKTtcXG4gICAgfSxcXG4gICAgX3BlcmNlbnRhZ2U6IGZ1bmN0aW9uIF9wZXJjZW50YWdlKCkge1xcbiAgICAgIHJldHVybiB0aGlzLmluZGV0ZXJtaW5hdGUgPyAxMDAgOiAxMDAgKiAodGhpcy5vcHRpb25zLnZhbHVlIC0gdGhpcy5taW4pIC8gKHRoaXMub3B0aW9ucy5tYXggLSB0aGlzLm1pbik7XFxuICAgIH0sXFxuICAgIF9yZWZyZXNoVmFsdWU6IGZ1bmN0aW9uIF9yZWZyZXNoVmFsdWUoKSB7XFxuICAgICAgdmFyIHZhbHVlID0gdGhpcy5vcHRpb25zLnZhbHVlLFxcbiAgICAgICAgICBwZXJjZW50YWdlID0gdGhpcy5fcGVyY2VudGFnZSgpO1xcblxcbiAgICAgIHRoaXMudmFsdWVEaXYudG9nZ2xlKHRoaXMuaW5kZXRlcm1pbmF0ZSB8fCB2YWx1ZSA+IHRoaXMubWluKS50b2dnbGVDbGFzcyhcXFwidWktY29ybmVyLXJpZ2h0XFxcIiwgdmFsdWUgPT09IHRoaXMub3B0aW9ucy5tYXgpLndpZHRoKHBlcmNlbnRhZ2UudG9GaXhlZCgwKSArIFxcXCIlXFxcIik7XFxuICAgICAgdGhpcy5lbGVtZW50LnRvZ2dsZUNsYXNzKFxcXCJ1aS1wcm9ncmVzc2Jhci1pbmRldGVybWluYXRlXFxcIiwgdGhpcy5pbmRldGVybWluYXRlKTtcXG5cXG4gICAgICBpZiAodGhpcy5pbmRldGVybWluYXRlKSB7XFxuICAgICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlQXR0cihcXFwiYXJpYS12YWx1ZW5vd1xcXCIpO1xcblxcbiAgICAgICAgaWYgKCF0aGlzLm92ZXJsYXlEaXYpIHtcXG4gICAgICAgICAgdGhpcy5vdmVybGF5RGl2ID0gJChcXFwiPGRpdiBjbGFzcz0ndWktcHJvZ3Jlc3NiYXItb3ZlcmxheSc+PC9kaXY+XFxcIikuYXBwZW5kVG8odGhpcy52YWx1ZURpdik7XFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRoaXMuZWxlbWVudC5hdHRyKHtcXG4gICAgICAgICAgXFxcImFyaWEtdmFsdWVtYXhcXFwiOiB0aGlzLm9wdGlvbnMubWF4LFxcbiAgICAgICAgICBcXFwiYXJpYS12YWx1ZW5vd1xcXCI6IHZhbHVlXFxuICAgICAgICB9KTtcXG5cXG4gICAgICAgIGlmICh0aGlzLm92ZXJsYXlEaXYpIHtcXG4gICAgICAgICAgdGhpcy5vdmVybGF5RGl2LnJlbW92ZSgpO1xcbiAgICAgICAgICB0aGlzLm92ZXJsYXlEaXYgPSBudWxsO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5vbGRWYWx1ZSAhPT0gdmFsdWUpIHtcXG4gICAgICAgIHRoaXMub2xkVmFsdWUgPSB2YWx1ZTtcXG5cXG4gICAgICAgIHRoaXMuX3RyaWdnZXIoXFxcImNoYW5nZVxcXCIpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodmFsdWUgPT09IHRoaXMub3B0aW9ucy5tYXgpIHtcXG4gICAgICAgIHRoaXMuX3RyaWdnZXIoXFxcImNvbXBsZXRlXFxcIik7XFxuICAgICAgfVxcbiAgICB9XFxuICB9KTtcXG4gIC8qIVxcbiAgICogalF1ZXJ5IFVJIFNlbGVjdGFibGUgMS4xMS40XFxuICAgKiBodHRwOi8vanF1ZXJ5dWkuY29tXFxuICAgKlxcbiAgICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcXG4gICAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cXG4gICAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcXG4gICAqXFxuICAgKiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9zZWxlY3RhYmxlL1xcbiAgICovXFxuXFxuICB2YXIgc2VsZWN0YWJsZSA9ICQud2lkZ2V0KFxcXCJ1aS5zZWxlY3RhYmxlXFxcIiwgJC51aS5tb3VzZSwge1xcbiAgICB2ZXJzaW9uOiBcXFwiMS4xMS40XFxcIixcXG4gICAgb3B0aW9uczoge1xcbiAgICAgIGFwcGVuZFRvOiBcXFwiYm9keVxcXCIsXFxuICAgICAgYXV0b1JlZnJlc2g6IHRydWUsXFxuICAgICAgZGlzdGFuY2U6IDAsXFxuICAgICAgZmlsdGVyOiBcXFwiKlxcXCIsXFxuICAgICAgdG9sZXJhbmNlOiBcXFwidG91Y2hcXFwiLFxcbiAgICAgIC8vIGNhbGxiYWNrc1xcbiAgICAgIHNlbGVjdGVkOiBudWxsLFxcbiAgICAgIHNlbGVjdGluZzogbnVsbCxcXG4gICAgICBzdGFydDogbnVsbCxcXG4gICAgICBzdG9wOiBudWxsLFxcbiAgICAgIHVuc2VsZWN0ZWQ6IG51bGwsXFxuICAgICAgdW5zZWxlY3Rpbmc6IG51bGxcXG4gICAgfSxcXG4gICAgX2NyZWF0ZTogZnVuY3Rpb24gX2NyZWF0ZSgpIHtcXG4gICAgICB2YXIgc2VsZWN0ZWVzLFxcbiAgICAgICAgICB0aGF0ID0gdGhpcztcXG4gICAgICB0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoXFxcInVpLXNlbGVjdGFibGVcXFwiKTtcXG4gICAgICB0aGlzLmRyYWdnZWQgPSBmYWxzZTsgLy8gY2FjaGUgc2VsZWN0ZWUgY2hpbGRyZW4gYmFzZWQgb24gZmlsdGVyXFxuXFxuICAgICAgdGhpcy5yZWZyZXNoID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgc2VsZWN0ZWVzID0gJCh0aGF0Lm9wdGlvbnMuZmlsdGVyLCB0aGF0LmVsZW1lbnRbMF0pO1xcbiAgICAgICAgc2VsZWN0ZWVzLmFkZENsYXNzKFxcXCJ1aS1zZWxlY3RlZVxcXCIpO1xcbiAgICAgICAgc2VsZWN0ZWVzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpLFxcbiAgICAgICAgICAgICAgcG9zID0gJHRoaXMub2Zmc2V0KCk7XFxuICAgICAgICAgICQuZGF0YSh0aGlzLCBcXFwic2VsZWN0YWJsZS1pdGVtXFxcIiwge1xcbiAgICAgICAgICAgIGVsZW1lbnQ6IHRoaXMsXFxuICAgICAgICAgICAgJGVsZW1lbnQ6ICR0aGlzLFxcbiAgICAgICAgICAgIGxlZnQ6IHBvcy5sZWZ0LFxcbiAgICAgICAgICAgIHRvcDogcG9zLnRvcCxcXG4gICAgICAgICAgICByaWdodDogcG9zLmxlZnQgKyAkdGhpcy5vdXRlcldpZHRoKCksXFxuICAgICAgICAgICAgYm90dG9tOiBwb3MudG9wICsgJHRoaXMub3V0ZXJIZWlnaHQoKSxcXG4gICAgICAgICAgICBzdGFydHNlbGVjdGVkOiBmYWxzZSxcXG4gICAgICAgICAgICBzZWxlY3RlZDogJHRoaXMuaGFzQ2xhc3MoXFxcInVpLXNlbGVjdGVkXFxcIiksXFxuICAgICAgICAgICAgc2VsZWN0aW5nOiAkdGhpcy5oYXNDbGFzcyhcXFwidWktc2VsZWN0aW5nXFxcIiksXFxuICAgICAgICAgICAgdW5zZWxlY3Rpbmc6ICR0aGlzLmhhc0NsYXNzKFxcXCJ1aS11bnNlbGVjdGluZ1xcXCIpXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfSk7XFxuICAgICAgfTtcXG5cXG4gICAgICB0aGlzLnJlZnJlc2goKTtcXG4gICAgICB0aGlzLnNlbGVjdGVlcyA9IHNlbGVjdGVlcy5hZGRDbGFzcyhcXFwidWktc2VsZWN0ZWVcXFwiKTtcXG5cXG4gICAgICB0aGlzLl9tb3VzZUluaXQoKTtcXG5cXG4gICAgICB0aGlzLmhlbHBlciA9ICQoXFxcIjxkaXYgY2xhc3M9J3VpLXNlbGVjdGFibGUtaGVscGVyJz48L2Rpdj5cXFwiKTtcXG4gICAgfSxcXG4gICAgX2Rlc3Ryb3k6IGZ1bmN0aW9uIF9kZXN0cm95KCkge1xcbiAgICAgIHRoaXMuc2VsZWN0ZWVzLnJlbW92ZUNsYXNzKFxcXCJ1aS1zZWxlY3RlZVxcXCIpLnJlbW92ZURhdGEoXFxcInNlbGVjdGFibGUtaXRlbVxcXCIpO1xcbiAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVDbGFzcyhcXFwidWktc2VsZWN0YWJsZSB1aS1zZWxlY3RhYmxlLWRpc2FibGVkXFxcIik7XFxuXFxuICAgICAgdGhpcy5fbW91c2VEZXN0cm95KCk7XFxuICAgIH0sXFxuICAgIF9tb3VzZVN0YXJ0OiBmdW5jdGlvbiBfbW91c2VTdGFydChldmVudCkge1xcbiAgICAgIHZhciB0aGF0ID0gdGhpcyxcXG4gICAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcXG4gICAgICB0aGlzLm9wb3MgPSBbZXZlbnQucGFnZVgsIGV2ZW50LnBhZ2VZXTtcXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmRpc2FibGVkKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuc2VsZWN0ZWVzID0gJChvcHRpb25zLmZpbHRlciwgdGhpcy5lbGVtZW50WzBdKTtcXG5cXG4gICAgICB0aGlzLl90cmlnZ2VyKFxcXCJzdGFydFxcXCIsIGV2ZW50KTtcXG5cXG4gICAgICAkKG9wdGlvbnMuYXBwZW5kVG8pLmFwcGVuZCh0aGlzLmhlbHBlcik7IC8vIHBvc2l0aW9uIGhlbHBlciAobGFzc28pXFxuXFxuICAgICAgdGhpcy5oZWxwZXIuY3NzKHtcXG4gICAgICAgIFxcXCJsZWZ0XFxcIjogZXZlbnQucGFnZVgsXFxuICAgICAgICBcXFwidG9wXFxcIjogZXZlbnQucGFnZVksXFxuICAgICAgICBcXFwid2lkdGhcXFwiOiAwLFxcbiAgICAgICAgXFxcImhlaWdodFxcXCI6IDBcXG4gICAgICB9KTtcXG5cXG4gICAgICBpZiAob3B0aW9ucy5hdXRvUmVmcmVzaCkge1xcbiAgICAgICAgdGhpcy5yZWZyZXNoKCk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuc2VsZWN0ZWVzLmZpbHRlcihcXFwiLnVpLXNlbGVjdGVkXFxcIikuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgc2VsZWN0ZWUgPSAkLmRhdGEodGhpcywgXFxcInNlbGVjdGFibGUtaXRlbVxcXCIpO1xcbiAgICAgICAgc2VsZWN0ZWUuc3RhcnRzZWxlY3RlZCA9IHRydWU7XFxuXFxuICAgICAgICBpZiAoIWV2ZW50Lm1ldGFLZXkgJiYgIWV2ZW50LmN0cmxLZXkpIHtcXG4gICAgICAgICAgc2VsZWN0ZWUuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoXFxcInVpLXNlbGVjdGVkXFxcIik7XFxuICAgICAgICAgIHNlbGVjdGVlLnNlbGVjdGVkID0gZmFsc2U7XFxuICAgICAgICAgIHNlbGVjdGVlLiRlbGVtZW50LmFkZENsYXNzKFxcXCJ1aS11bnNlbGVjdGluZ1xcXCIpO1xcbiAgICAgICAgICBzZWxlY3RlZS51bnNlbGVjdGluZyA9IHRydWU7IC8vIHNlbGVjdGFibGUgVU5TRUxFQ1RJTkcgY2FsbGJhY2tcXG5cXG4gICAgICAgICAgdGhhdC5fdHJpZ2dlcihcXFwidW5zZWxlY3RpbmdcXFwiLCBldmVudCwge1xcbiAgICAgICAgICAgIHVuc2VsZWN0aW5nOiBzZWxlY3RlZS5lbGVtZW50XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcbiAgICAgICQoZXZlbnQudGFyZ2V0KS5wYXJlbnRzKCkuYWRkQmFjaygpLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIGRvU2VsZWN0LFxcbiAgICAgICAgICAgIHNlbGVjdGVlID0gJC5kYXRhKHRoaXMsIFxcXCJzZWxlY3RhYmxlLWl0ZW1cXFwiKTtcXG5cXG4gICAgICAgIGlmIChzZWxlY3RlZSkge1xcbiAgICAgICAgICBkb1NlbGVjdCA9ICFldmVudC5tZXRhS2V5ICYmICFldmVudC5jdHJsS2V5IHx8ICFzZWxlY3RlZS4kZWxlbWVudC5oYXNDbGFzcyhcXFwidWktc2VsZWN0ZWRcXFwiKTtcXG4gICAgICAgICAgc2VsZWN0ZWUuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoZG9TZWxlY3QgPyBcXFwidWktdW5zZWxlY3RpbmdcXFwiIDogXFxcInVpLXNlbGVjdGVkXFxcIikuYWRkQ2xhc3MoZG9TZWxlY3QgPyBcXFwidWktc2VsZWN0aW5nXFxcIiA6IFxcXCJ1aS11bnNlbGVjdGluZ1xcXCIpO1xcbiAgICAgICAgICBzZWxlY3RlZS51bnNlbGVjdGluZyA9ICFkb1NlbGVjdDtcXG4gICAgICAgICAgc2VsZWN0ZWUuc2VsZWN0aW5nID0gZG9TZWxlY3Q7XFxuICAgICAgICAgIHNlbGVjdGVlLnNlbGVjdGVkID0gZG9TZWxlY3Q7IC8vIHNlbGVjdGFibGUgKFVOKVNFTEVDVElORyBjYWxsYmFja1xcblxcbiAgICAgICAgICBpZiAoZG9TZWxlY3QpIHtcXG4gICAgICAgICAgICB0aGF0Ll90cmlnZ2VyKFxcXCJzZWxlY3RpbmdcXFwiLCBldmVudCwge1xcbiAgICAgICAgICAgICAgc2VsZWN0aW5nOiBzZWxlY3RlZS5lbGVtZW50XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgdGhhdC5fdHJpZ2dlcihcXFwidW5zZWxlY3RpbmdcXFwiLCBldmVudCwge1xcbiAgICAgICAgICAgICAgdW5zZWxlY3Rpbmc6IHNlbGVjdGVlLmVsZW1lbnRcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgIH0sXFxuICAgIF9tb3VzZURyYWc6IGZ1bmN0aW9uIF9tb3VzZURyYWcoZXZlbnQpIHtcXG4gICAgICB0aGlzLmRyYWdnZWQgPSB0cnVlO1xcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGlzYWJsZWQpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIHRtcCxcXG4gICAgICAgICAgdGhhdCA9IHRoaXMsXFxuICAgICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXFxuICAgICAgICAgIHgxID0gdGhpcy5vcG9zWzBdLFxcbiAgICAgICAgICB5MSA9IHRoaXMub3Bvc1sxXSxcXG4gICAgICAgICAgeDIgPSBldmVudC5wYWdlWCxcXG4gICAgICAgICAgeTIgPSBldmVudC5wYWdlWTtcXG5cXG4gICAgICBpZiAoeDEgPiB4Mikge1xcbiAgICAgICAgdG1wID0geDI7XFxuICAgICAgICB4MiA9IHgxO1xcbiAgICAgICAgeDEgPSB0bXA7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh5MSA+IHkyKSB7XFxuICAgICAgICB0bXAgPSB5MjtcXG4gICAgICAgIHkyID0geTE7XFxuICAgICAgICB5MSA9IHRtcDtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5oZWxwZXIuY3NzKHtcXG4gICAgICAgIGxlZnQ6IHgxLFxcbiAgICAgICAgdG9wOiB5MSxcXG4gICAgICAgIHdpZHRoOiB4MiAtIHgxLFxcbiAgICAgICAgaGVpZ2h0OiB5MiAtIHkxXFxuICAgICAgfSk7XFxuICAgICAgdGhpcy5zZWxlY3RlZXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgc2VsZWN0ZWUgPSAkLmRhdGEodGhpcywgXFxcInNlbGVjdGFibGUtaXRlbVxcXCIpLFxcbiAgICAgICAgICAgIGhpdCA9IGZhbHNlOyAvL3ByZXZlbnQgaGVscGVyIGZyb20gYmVpbmcgc2VsZWN0ZWQgaWYgYXBwZW5kVG86IHNlbGVjdGFibGVcXG5cXG4gICAgICAgIGlmICghc2VsZWN0ZWUgfHwgc2VsZWN0ZWUuZWxlbWVudCA9PT0gdGhhdC5lbGVtZW50WzBdKSB7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChvcHRpb25zLnRvbGVyYW5jZSA9PT0gXFxcInRvdWNoXFxcIikge1xcbiAgICAgICAgICBoaXQgPSAhKHNlbGVjdGVlLmxlZnQgPiB4MiB8fCBzZWxlY3RlZS5yaWdodCA8IHgxIHx8IHNlbGVjdGVlLnRvcCA+IHkyIHx8IHNlbGVjdGVlLmJvdHRvbSA8IHkxKTtcXG4gICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy50b2xlcmFuY2UgPT09IFxcXCJmaXRcXFwiKSB7XFxuICAgICAgICAgIGhpdCA9IHNlbGVjdGVlLmxlZnQgPiB4MSAmJiBzZWxlY3RlZS5yaWdodCA8IHgyICYmIHNlbGVjdGVlLnRvcCA+IHkxICYmIHNlbGVjdGVlLmJvdHRvbSA8IHkyO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKGhpdCkge1xcbiAgICAgICAgICAvLyBTRUxFQ1RcXG4gICAgICAgICAgaWYgKHNlbGVjdGVlLnNlbGVjdGVkKSB7XFxuICAgICAgICAgICAgc2VsZWN0ZWUuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoXFxcInVpLXNlbGVjdGVkXFxcIik7XFxuICAgICAgICAgICAgc2VsZWN0ZWUuc2VsZWN0ZWQgPSBmYWxzZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAoc2VsZWN0ZWUudW5zZWxlY3RpbmcpIHtcXG4gICAgICAgICAgICBzZWxlY3RlZS4kZWxlbWVudC5yZW1vdmVDbGFzcyhcXFwidWktdW5zZWxlY3RpbmdcXFwiKTtcXG4gICAgICAgICAgICBzZWxlY3RlZS51bnNlbGVjdGluZyA9IGZhbHNlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmICghc2VsZWN0ZWUuc2VsZWN0aW5nKSB7XFxuICAgICAgICAgICAgc2VsZWN0ZWUuJGVsZW1lbnQuYWRkQ2xhc3MoXFxcInVpLXNlbGVjdGluZ1xcXCIpO1xcbiAgICAgICAgICAgIHNlbGVjdGVlLnNlbGVjdGluZyA9IHRydWU7IC8vIHNlbGVjdGFibGUgU0VMRUNUSU5HIGNhbGxiYWNrXFxuXFxuICAgICAgICAgICAgdGhhdC5fdHJpZ2dlcihcXFwic2VsZWN0aW5nXFxcIiwgZXZlbnQsIHtcXG4gICAgICAgICAgICAgIHNlbGVjdGluZzogc2VsZWN0ZWUuZWxlbWVudFxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAvLyBVTlNFTEVDVFxcbiAgICAgICAgICBpZiAoc2VsZWN0ZWUuc2VsZWN0aW5nKSB7XFxuICAgICAgICAgICAgaWYgKChldmVudC5tZXRhS2V5IHx8IGV2ZW50LmN0cmxLZXkpICYmIHNlbGVjdGVlLnN0YXJ0c2VsZWN0ZWQpIHtcXG4gICAgICAgICAgICAgIHNlbGVjdGVlLiRlbGVtZW50LnJlbW92ZUNsYXNzKFxcXCJ1aS1zZWxlY3RpbmdcXFwiKTtcXG4gICAgICAgICAgICAgIHNlbGVjdGVlLnNlbGVjdGluZyA9IGZhbHNlO1xcbiAgICAgICAgICAgICAgc2VsZWN0ZWUuJGVsZW1lbnQuYWRkQ2xhc3MoXFxcInVpLXNlbGVjdGVkXFxcIik7XFxuICAgICAgICAgICAgICBzZWxlY3RlZS5zZWxlY3RlZCA9IHRydWU7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgIHNlbGVjdGVlLiRlbGVtZW50LnJlbW92ZUNsYXNzKFxcXCJ1aS1zZWxlY3RpbmdcXFwiKTtcXG4gICAgICAgICAgICAgIHNlbGVjdGVlLnNlbGVjdGluZyA9IGZhbHNlO1xcblxcbiAgICAgICAgICAgICAgaWYgKHNlbGVjdGVlLnN0YXJ0c2VsZWN0ZWQpIHtcXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWUuJGVsZW1lbnQuYWRkQ2xhc3MoXFxcInVpLXVuc2VsZWN0aW5nXFxcIik7XFxuICAgICAgICAgICAgICAgIHNlbGVjdGVlLnVuc2VsZWN0aW5nID0gdHJ1ZTtcXG4gICAgICAgICAgICAgIH0gLy8gc2VsZWN0YWJsZSBVTlNFTEVDVElORyBjYWxsYmFja1xcblxcblxcbiAgICAgICAgICAgICAgdGhhdC5fdHJpZ2dlcihcXFwidW5zZWxlY3RpbmdcXFwiLCBldmVudCwge1xcbiAgICAgICAgICAgICAgICB1bnNlbGVjdGluZzogc2VsZWN0ZWUuZWxlbWVudFxcbiAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmIChzZWxlY3RlZS5zZWxlY3RlZCkge1xcbiAgICAgICAgICAgIGlmICghZXZlbnQubWV0YUtleSAmJiAhZXZlbnQuY3RybEtleSAmJiAhc2VsZWN0ZWUuc3RhcnRzZWxlY3RlZCkge1xcbiAgICAgICAgICAgICAgc2VsZWN0ZWUuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoXFxcInVpLXNlbGVjdGVkXFxcIik7XFxuICAgICAgICAgICAgICBzZWxlY3RlZS5zZWxlY3RlZCA9IGZhbHNlO1xcbiAgICAgICAgICAgICAgc2VsZWN0ZWUuJGVsZW1lbnQuYWRkQ2xhc3MoXFxcInVpLXVuc2VsZWN0aW5nXFxcIik7XFxuICAgICAgICAgICAgICBzZWxlY3RlZS51bnNlbGVjdGluZyA9IHRydWU7IC8vIHNlbGVjdGFibGUgVU5TRUxFQ1RJTkcgY2FsbGJhY2tcXG5cXG4gICAgICAgICAgICAgIHRoYXQuX3RyaWdnZXIoXFxcInVuc2VsZWN0aW5nXFxcIiwgZXZlbnQsIHtcXG4gICAgICAgICAgICAgICAgdW5zZWxlY3Rpbmc6IHNlbGVjdGVlLmVsZW1lbnRcXG4gICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfSxcXG4gICAgX21vdXNlU3RvcDogZnVuY3Rpb24gX21vdXNlU3RvcChldmVudCkge1xcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcXG4gICAgICB0aGlzLmRyYWdnZWQgPSBmYWxzZTtcXG4gICAgICAkKFxcXCIudWktdW5zZWxlY3RpbmdcXFwiLCB0aGlzLmVsZW1lbnRbMF0pLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIHNlbGVjdGVlID0gJC5kYXRhKHRoaXMsIFxcXCJzZWxlY3RhYmxlLWl0ZW1cXFwiKTtcXG4gICAgICAgIHNlbGVjdGVlLiRlbGVtZW50LnJlbW92ZUNsYXNzKFxcXCJ1aS11bnNlbGVjdGluZ1xcXCIpO1xcbiAgICAgICAgc2VsZWN0ZWUudW5zZWxlY3RpbmcgPSBmYWxzZTtcXG4gICAgICAgIHNlbGVjdGVlLnN0YXJ0c2VsZWN0ZWQgPSBmYWxzZTtcXG5cXG4gICAgICAgIHRoYXQuX3RyaWdnZXIoXFxcInVuc2VsZWN0ZWRcXFwiLCBldmVudCwge1xcbiAgICAgICAgICB1bnNlbGVjdGVkOiBzZWxlY3RlZS5lbGVtZW50XFxuICAgICAgICB9KTtcXG4gICAgICB9KTtcXG4gICAgICAkKFxcXCIudWktc2VsZWN0aW5nXFxcIiwgdGhpcy5lbGVtZW50WzBdKS5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciBzZWxlY3RlZSA9ICQuZGF0YSh0aGlzLCBcXFwic2VsZWN0YWJsZS1pdGVtXFxcIik7XFxuICAgICAgICBzZWxlY3RlZS4kZWxlbWVudC5yZW1vdmVDbGFzcyhcXFwidWktc2VsZWN0aW5nXFxcIikuYWRkQ2xhc3MoXFxcInVpLXNlbGVjdGVkXFxcIik7XFxuICAgICAgICBzZWxlY3RlZS5zZWxlY3RpbmcgPSBmYWxzZTtcXG4gICAgICAgIHNlbGVjdGVlLnNlbGVjdGVkID0gdHJ1ZTtcXG4gICAgICAgIHNlbGVjdGVlLnN0YXJ0c2VsZWN0ZWQgPSB0cnVlO1xcblxcbiAgICAgICAgdGhhdC5fdHJpZ2dlcihcXFwic2VsZWN0ZWRcXFwiLCBldmVudCwge1xcbiAgICAgICAgICBzZWxlY3RlZDogc2VsZWN0ZWUuZWxlbWVudFxcbiAgICAgICAgfSk7XFxuICAgICAgfSk7XFxuXFxuICAgICAgdGhpcy5fdHJpZ2dlcihcXFwic3RvcFxcXCIsIGV2ZW50KTtcXG5cXG4gICAgICB0aGlzLmhlbHBlci5yZW1vdmUoKTtcXG4gICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG4gIH0pO1xcbiAgLyohXFxuICAgKiBqUXVlcnkgVUkgU2VsZWN0bWVudSAxLjExLjRcXG4gICAqIGh0dHA6Ly9qcXVlcnl1aS5jb21cXG4gICAqXFxuICAgKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xcbiAgICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxcbiAgICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxcbiAgICpcXG4gICAqIGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL3NlbGVjdG1lbnVcXG4gICAqL1xcblxcbiAgdmFyIHNlbGVjdG1lbnUgPSAkLndpZGdldChcXFwidWkuc2VsZWN0bWVudVxcXCIsIHtcXG4gICAgdmVyc2lvbjogXFxcIjEuMTEuNFxcXCIsXFxuICAgIGRlZmF1bHRFbGVtZW50OiBcXFwiPHNlbGVjdD5cXFwiLFxcbiAgICBvcHRpb25zOiB7XFxuICAgICAgYXBwZW5kVG86IG51bGwsXFxuICAgICAgZGlzYWJsZWQ6IG51bGwsXFxuICAgICAgaWNvbnM6IHtcXG4gICAgICAgIGJ1dHRvbjogXFxcInVpLWljb24tdHJpYW5nbGUtMS1zXFxcIlxcbiAgICAgIH0sXFxuICAgICAgcG9zaXRpb246IHtcXG4gICAgICAgIG15OiBcXFwibGVmdCB0b3BcXFwiLFxcbiAgICAgICAgYXQ6IFxcXCJsZWZ0IGJvdHRvbVxcXCIsXFxuICAgICAgICBjb2xsaXNpb246IFxcXCJub25lXFxcIlxcbiAgICAgIH0sXFxuICAgICAgd2lkdGg6IG51bGwsXFxuICAgICAgLy8gY2FsbGJhY2tzXFxuICAgICAgY2hhbmdlOiBudWxsLFxcbiAgICAgIGNsb3NlOiBudWxsLFxcbiAgICAgIGZvY3VzOiBudWxsLFxcbiAgICAgIG9wZW46IG51bGwsXFxuICAgICAgc2VsZWN0OiBudWxsXFxuICAgIH0sXFxuICAgIF9jcmVhdGU6IGZ1bmN0aW9uIF9jcmVhdGUoKSB7XFxuICAgICAgdmFyIHNlbGVjdG1lbnVJZCA9IHRoaXMuZWxlbWVudC51bmlxdWVJZCgpLmF0dHIoXFxcImlkXFxcIik7XFxuICAgICAgdGhpcy5pZHMgPSB7XFxuICAgICAgICBlbGVtZW50OiBzZWxlY3RtZW51SWQsXFxuICAgICAgICBidXR0b246IHNlbGVjdG1lbnVJZCArIFxcXCItYnV0dG9uXFxcIixcXG4gICAgICAgIG1lbnU6IHNlbGVjdG1lbnVJZCArIFxcXCItbWVudVxcXCJcXG4gICAgICB9O1xcblxcbiAgICAgIHRoaXMuX2RyYXdCdXR0b24oKTtcXG5cXG4gICAgICB0aGlzLl9kcmF3TWVudSgpO1xcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGlzYWJsZWQpIHtcXG4gICAgICAgIHRoaXMuZGlzYWJsZSgpO1xcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgX2RyYXdCdXR0b246IGZ1bmN0aW9uIF9kcmF3QnV0dG9uKCkge1xcbiAgICAgIHZhciB0aGF0ID0gdGhpczsgLy8gQXNzb2NpYXRlIGV4aXN0aW5nIGxhYmVsIHdpdGggdGhlIG5ldyBidXR0b25cXG5cXG4gICAgICB0aGlzLmxhYmVsID0gJChcXFwibGFiZWxbZm9yPSdcXFwiICsgdGhpcy5pZHMuZWxlbWVudCArIFxcXCInXVxcXCIpLmF0dHIoXFxcImZvclxcXCIsIHRoaXMuaWRzLmJ1dHRvbik7XFxuXFxuICAgICAgdGhpcy5fb24odGhpcy5sYWJlbCwge1xcbiAgICAgICAgY2xpY2s6IGZ1bmN0aW9uIGNsaWNrKGV2ZW50KSB7XFxuICAgICAgICAgIHRoaXMuYnV0dG9uLmZvY3VzKCk7XFxuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICB9XFxuICAgICAgfSk7IC8vIEhpZGUgb3JpZ2luYWwgc2VsZWN0IGVsZW1lbnRcXG5cXG5cXG4gICAgICB0aGlzLmVsZW1lbnQuaGlkZSgpOyAvLyBDcmVhdGUgYnV0dG9uXFxuXFxuICAgICAgdGhpcy5idXR0b24gPSAkKFxcXCI8c3Bhbj5cXFwiLCB7XFxuICAgICAgICBcXFwiY2xhc3NcXFwiOiBcXFwidWktc2VsZWN0bWVudS1idXR0b24gdWktd2lkZ2V0IHVpLXN0YXRlLWRlZmF1bHQgdWktY29ybmVyLWFsbFxcXCIsXFxuICAgICAgICB0YWJpbmRleDogdGhpcy5vcHRpb25zLmRpc2FibGVkID8gLTEgOiAwLFxcbiAgICAgICAgaWQ6IHRoaXMuaWRzLmJ1dHRvbixcXG4gICAgICAgIHJvbGU6IFxcXCJjb21ib2JveFxcXCIsXFxuICAgICAgICBcXFwiYXJpYS1leHBhbmRlZFxcXCI6IFxcXCJmYWxzZVxcXCIsXFxuICAgICAgICBcXFwiYXJpYS1hdXRvY29tcGxldGVcXFwiOiBcXFwibGlzdFxcXCIsXFxuICAgICAgICBcXFwiYXJpYS1vd25zXFxcIjogdGhpcy5pZHMubWVudSxcXG4gICAgICAgIFxcXCJhcmlhLWhhc3BvcHVwXFxcIjogXFxcInRydWVcXFwiXFxuICAgICAgfSkuaW5zZXJ0QWZ0ZXIodGhpcy5lbGVtZW50KTtcXG4gICAgICAkKFxcXCI8c3Bhbj5cXFwiLCB7XFxuICAgICAgICBcXFwiY2xhc3NcXFwiOiBcXFwidWktaWNvbiBcXFwiICsgdGhpcy5vcHRpb25zLmljb25zLmJ1dHRvblxcbiAgICAgIH0pLnByZXBlbmRUbyh0aGlzLmJ1dHRvbik7XFxuICAgICAgdGhpcy5idXR0b25UZXh0ID0gJChcXFwiPHNwYW4+XFxcIiwge1xcbiAgICAgICAgXFxcImNsYXNzXFxcIjogXFxcInVpLXNlbGVjdG1lbnUtdGV4dFxcXCJcXG4gICAgICB9KS5hcHBlbmRUbyh0aGlzLmJ1dHRvbik7XFxuXFxuICAgICAgdGhpcy5fc2V0VGV4dCh0aGlzLmJ1dHRvblRleHQsIHRoaXMuZWxlbWVudC5maW5kKFxcXCJvcHRpb246c2VsZWN0ZWRcXFwiKS50ZXh0KCkpO1xcblxcbiAgICAgIHRoaXMuX3Jlc2l6ZUJ1dHRvbigpO1xcblxcbiAgICAgIHRoaXMuX29uKHRoaXMuYnV0dG9uLCB0aGlzLl9idXR0b25FdmVudHMpO1xcblxcbiAgICAgIHRoaXMuYnV0dG9uLm9uZShcXFwiZm9jdXNpblxcXCIsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIC8vIERlbGF5IHJlbmRlcmluZyB0aGUgbWVudSBpdGVtcyB1bnRpbCB0aGUgYnV0dG9uIHJlY2VpdmVzIGZvY3VzLlxcbiAgICAgICAgLy8gVGhlIG1lbnUgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIHJlbmRlcmVkIHZpYSBhIHByb2dyYW1tYXRpYyBvcGVuLlxcbiAgICAgICAgaWYgKCF0aGF0Lm1lbnVJdGVtcykge1xcbiAgICAgICAgICB0aGF0Ll9yZWZyZXNoTWVudSgpO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcblxcbiAgICAgIHRoaXMuX2hvdmVyYWJsZSh0aGlzLmJ1dHRvbik7XFxuXFxuICAgICAgdGhpcy5fZm9jdXNhYmxlKHRoaXMuYnV0dG9uKTtcXG4gICAgfSxcXG4gICAgX2RyYXdNZW51OiBmdW5jdGlvbiBfZHJhd01lbnUoKSB7XFxuICAgICAgdmFyIHRoYXQgPSB0aGlzOyAvLyBDcmVhdGUgbWVudVxcblxcbiAgICAgIHRoaXMubWVudSA9ICQoXFxcIjx1bD5cXFwiLCB7XFxuICAgICAgICBcXFwiYXJpYS1oaWRkZW5cXFwiOiBcXFwidHJ1ZVxcXCIsXFxuICAgICAgICBcXFwiYXJpYS1sYWJlbGxlZGJ5XFxcIjogdGhpcy5pZHMuYnV0dG9uLFxcbiAgICAgICAgaWQ6IHRoaXMuaWRzLm1lbnVcXG4gICAgICB9KTsgLy8gV3JhcCBtZW51XFxuXFxuICAgICAgdGhpcy5tZW51V3JhcCA9ICQoXFxcIjxkaXY+XFxcIiwge1xcbiAgICAgICAgXFxcImNsYXNzXFxcIjogXFxcInVpLXNlbGVjdG1lbnUtbWVudSB1aS1mcm9udFxcXCJcXG4gICAgICB9KS5hcHBlbmQodGhpcy5tZW51KS5hcHBlbmRUbyh0aGlzLl9hcHBlbmRUbygpKTsgLy8gSW5pdGlhbGl6ZSBtZW51IHdpZGdldFxcblxcbiAgICAgIHRoaXMubWVudUluc3RhbmNlID0gdGhpcy5tZW51Lm1lbnUoe1xcbiAgICAgICAgcm9sZTogXFxcImxpc3Rib3hcXFwiLFxcbiAgICAgICAgc2VsZWN0OiBmdW5jdGlvbiBzZWxlY3QoZXZlbnQsIHVpKSB7XFxuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vIHN1cHBvcnQ6IElFOFxcbiAgICAgICAgICAvLyBJZiB0aGUgaXRlbSB3YXMgc2VsZWN0ZWQgdmlhIGEgY2xpY2ssIHRoZSB0ZXh0IHNlbGVjdGlvblxcbiAgICAgICAgICAvLyB3aWxsIGJlIGRlc3Ryb3llZCBpbiBJRVxcblxcbiAgICAgICAgICB0aGF0Ll9zZXRTZWxlY3Rpb24oKTtcXG5cXG4gICAgICAgICAgdGhhdC5fc2VsZWN0KHVpLml0ZW0uZGF0YShcXFwidWktc2VsZWN0bWVudS1pdGVtXFxcIiksIGV2ZW50KTtcXG4gICAgICAgIH0sXFxuICAgICAgICBmb2N1czogZnVuY3Rpb24gZm9jdXMoZXZlbnQsIHVpKSB7XFxuICAgICAgICAgIHZhciBpdGVtID0gdWkuaXRlbS5kYXRhKFxcXCJ1aS1zZWxlY3RtZW51LWl0ZW1cXFwiKTsgLy8gUHJldmVudCBpbml0YWwgZm9jdXMgZnJvbSBmaXJpbmcgYW5kIGNoZWNrIGlmIGl0cyBhIG5ld2x5IGZvY3VzZWQgaXRlbVxcblxcbiAgICAgICAgICBpZiAodGhhdC5mb2N1c0luZGV4ICE9IG51bGwgJiYgaXRlbS5pbmRleCAhPT0gdGhhdC5mb2N1c0luZGV4KSB7XFxuICAgICAgICAgICAgdGhhdC5fdHJpZ2dlcihcXFwiZm9jdXNcXFwiLCBldmVudCwge1xcbiAgICAgICAgICAgICAgaXRlbTogaXRlbVxcbiAgICAgICAgICAgIH0pO1xcblxcbiAgICAgICAgICAgIGlmICghdGhhdC5pc09wZW4pIHtcXG4gICAgICAgICAgICAgIHRoYXQuX3NlbGVjdChpdGVtLCBldmVudCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHRoYXQuZm9jdXNJbmRleCA9IGl0ZW0uaW5kZXg7XFxuICAgICAgICAgIHRoYXQuYnV0dG9uLmF0dHIoXFxcImFyaWEtYWN0aXZlZGVzY2VuZGFudFxcXCIsIHRoYXQubWVudUl0ZW1zLmVxKGl0ZW0uaW5kZXgpLmF0dHIoXFxcImlkXFxcIikpO1xcbiAgICAgICAgfVxcbiAgICAgIH0pLm1lbnUoXFxcImluc3RhbmNlXFxcIik7IC8vIEFkanVzdCBtZW51IHN0eWxlcyB0byBkcm9wZG93blxcblxcbiAgICAgIHRoaXMubWVudS5hZGRDbGFzcyhcXFwidWktY29ybmVyLWJvdHRvbVxcXCIpLnJlbW92ZUNsYXNzKFxcXCJ1aS1jb3JuZXItYWxsXFxcIik7IC8vIERvbid0IGNsb3NlIHRoZSBtZW51IG9uIG1vdXNlbGVhdmVcXG5cXG4gICAgICB0aGlzLm1lbnVJbnN0YW5jZS5fb2ZmKHRoaXMubWVudSwgXFxcIm1vdXNlbGVhdmVcXFwiKTsgLy8gQ2FuY2VsIHRoZSBtZW51J3MgY29sbGFwc2VBbGwgb24gZG9jdW1lbnQgY2xpY2tcXG5cXG5cXG4gICAgICB0aGlzLm1lbnVJbnN0YW5jZS5fY2xvc2VPbkRvY3VtZW50Q2xpY2sgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfTsgLy8gU2VsZWN0cyBvZnRlbiBjb250YWluIGVtcHR5IGl0ZW1zLCBidXQgbmV2ZXIgY29udGFpbiBkaXZpZGVyc1xcblxcblxcbiAgICAgIHRoaXMubWVudUluc3RhbmNlLl9pc0RpdmlkZXIgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfTtcXG4gICAgfSxcXG4gICAgcmVmcmVzaDogZnVuY3Rpb24gcmVmcmVzaCgpIHtcXG4gICAgICB0aGlzLl9yZWZyZXNoTWVudSgpO1xcblxcbiAgICAgIHRoaXMuX3NldFRleHQodGhpcy5idXR0b25UZXh0LCB0aGlzLl9nZXRTZWxlY3RlZEl0ZW0oKS50ZXh0KCkpO1xcblxcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLndpZHRoKSB7XFxuICAgICAgICB0aGlzLl9yZXNpemVCdXR0b24oKTtcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIF9yZWZyZXNoTWVudTogZnVuY3Rpb24gX3JlZnJlc2hNZW51KCkge1xcbiAgICAgIHRoaXMubWVudS5lbXB0eSgpO1xcbiAgICAgIHZhciBpdGVtLFxcbiAgICAgICAgICBvcHRpb25zID0gdGhpcy5lbGVtZW50LmZpbmQoXFxcIm9wdGlvblxcXCIpO1xcblxcbiAgICAgIGlmICghb3B0aW9ucy5sZW5ndGgpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fcGFyc2VPcHRpb25zKG9wdGlvbnMpO1xcblxcbiAgICAgIHRoaXMuX3JlbmRlck1lbnUodGhpcy5tZW51LCB0aGlzLml0ZW1zKTtcXG5cXG4gICAgICB0aGlzLm1lbnVJbnN0YW5jZS5yZWZyZXNoKCk7XFxuICAgICAgdGhpcy5tZW51SXRlbXMgPSB0aGlzLm1lbnUuZmluZChcXFwibGlcXFwiKS5ub3QoXFxcIi51aS1zZWxlY3RtZW51LW9wdGdyb3VwXFxcIik7XFxuICAgICAgaXRlbSA9IHRoaXMuX2dldFNlbGVjdGVkSXRlbSgpOyAvLyBVcGRhdGUgdGhlIG1lbnUgdG8gaGF2ZSB0aGUgY29ycmVjdCBpdGVtIGZvY3VzZWRcXG5cXG4gICAgICB0aGlzLm1lbnVJbnN0YW5jZS5mb2N1cyhudWxsLCBpdGVtKTtcXG5cXG4gICAgICB0aGlzLl9zZXRBcmlhKGl0ZW0uZGF0YShcXFwidWktc2VsZWN0bWVudS1pdGVtXFxcIikpOyAvLyBTZXQgZGlzYWJsZWQgc3RhdGVcXG5cXG5cXG4gICAgICB0aGlzLl9zZXRPcHRpb24oXFxcImRpc2FibGVkXFxcIiwgdGhpcy5lbGVtZW50LnByb3AoXFxcImRpc2FibGVkXFxcIikpO1xcbiAgICB9LFxcbiAgICBvcGVuOiBmdW5jdGlvbiBvcGVuKGV2ZW50KSB7XFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5kaXNhYmxlZCkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH0gLy8gSWYgdGhpcyBpcyB0aGUgZmlyc3QgdGltZSB0aGUgbWVudSBpcyBiZWluZyBvcGVuZWQsIHJlbmRlciB0aGUgaXRlbXNcXG5cXG5cXG4gICAgICBpZiAoIXRoaXMubWVudUl0ZW1zKSB7XFxuICAgICAgICB0aGlzLl9yZWZyZXNoTWVudSgpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICAvLyBNZW51IGNsZWFycyBmb2N1cyBvbiBjbG9zZSwgcmVzZXQgZm9jdXMgdG8gc2VsZWN0ZWQgaXRlbVxcbiAgICAgICAgdGhpcy5tZW51LmZpbmQoXFxcIi51aS1zdGF0ZS1mb2N1c1xcXCIpLnJlbW92ZUNsYXNzKFxcXCJ1aS1zdGF0ZS1mb2N1c1xcXCIpO1xcbiAgICAgICAgdGhpcy5tZW51SW5zdGFuY2UuZm9jdXMobnVsbCwgdGhpcy5fZ2V0U2VsZWN0ZWRJdGVtKCkpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLmlzT3BlbiA9IHRydWU7XFxuXFxuICAgICAgdGhpcy5fdG9nZ2xlQXR0cigpO1xcblxcbiAgICAgIHRoaXMuX3Jlc2l6ZU1lbnUoKTtcXG5cXG4gICAgICB0aGlzLl9wb3NpdGlvbigpO1xcblxcbiAgICAgIHRoaXMuX29uKHRoaXMuZG9jdW1lbnQsIHRoaXMuX2RvY3VtZW50Q2xpY2spO1xcblxcbiAgICAgIHRoaXMuX3RyaWdnZXIoXFxcIm9wZW5cXFwiLCBldmVudCk7XFxuICAgIH0sXFxuICAgIF9wb3NpdGlvbjogZnVuY3Rpb24gX3Bvc2l0aW9uKCkge1xcbiAgICAgIHRoaXMubWVudVdyYXAucG9zaXRpb24oJC5leHRlbmQoe1xcbiAgICAgICAgb2Y6IHRoaXMuYnV0dG9uXFxuICAgICAgfSwgdGhpcy5vcHRpb25zLnBvc2l0aW9uKSk7XFxuICAgIH0sXFxuICAgIGNsb3NlOiBmdW5jdGlvbiBjbG9zZShldmVudCkge1xcbiAgICAgIGlmICghdGhpcy5pc09wZW4pIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5pc09wZW4gPSBmYWxzZTtcXG5cXG4gICAgICB0aGlzLl90b2dnbGVBdHRyKCk7XFxuXFxuICAgICAgdGhpcy5yYW5nZSA9IG51bGw7XFxuXFxuICAgICAgdGhpcy5fb2ZmKHRoaXMuZG9jdW1lbnQpO1xcblxcbiAgICAgIHRoaXMuX3RyaWdnZXIoXFxcImNsb3NlXFxcIiwgZXZlbnQpO1xcbiAgICB9LFxcbiAgICB3aWRnZXQ6IGZ1bmN0aW9uIHdpZGdldCgpIHtcXG4gICAgICByZXR1cm4gdGhpcy5idXR0b247XFxuICAgIH0sXFxuICAgIG1lbnVXaWRnZXQ6IGZ1bmN0aW9uIG1lbnVXaWRnZXQoKSB7XFxuICAgICAgcmV0dXJuIHRoaXMubWVudTtcXG4gICAgfSxcXG4gICAgX3JlbmRlck1lbnU6IGZ1bmN0aW9uIF9yZW5kZXJNZW51KHVsLCBpdGVtcykge1xcbiAgICAgIHZhciB0aGF0ID0gdGhpcyxcXG4gICAgICAgICAgY3VycmVudE9wdGdyb3VwID0gXFxcIlxcXCI7XFxuICAgICAgJC5lYWNoKGl0ZW1zLCBmdW5jdGlvbiAoaW5kZXgsIGl0ZW0pIHtcXG4gICAgICAgIGlmIChpdGVtLm9wdGdyb3VwICE9PSBjdXJyZW50T3B0Z3JvdXApIHtcXG4gICAgICAgICAgJChcXFwiPGxpPlxcXCIsIHtcXG4gICAgICAgICAgICBcXFwiY2xhc3NcXFwiOiBcXFwidWktc2VsZWN0bWVudS1vcHRncm91cCB1aS1tZW51LWRpdmlkZXJcXFwiICsgKGl0ZW0uZWxlbWVudC5wYXJlbnQoXFxcIm9wdGdyb3VwXFxcIikucHJvcChcXFwiZGlzYWJsZWRcXFwiKSA/IFxcXCIgdWktc3RhdGUtZGlzYWJsZWRcXFwiIDogXFxcIlxcXCIpLFxcbiAgICAgICAgICAgIHRleHQ6IGl0ZW0ub3B0Z3JvdXBcXG4gICAgICAgICAgfSkuYXBwZW5kVG8odWwpO1xcbiAgICAgICAgICBjdXJyZW50T3B0Z3JvdXAgPSBpdGVtLm9wdGdyb3VwO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdGhhdC5fcmVuZGVySXRlbURhdGEodWwsIGl0ZW0pO1xcbiAgICAgIH0pO1xcbiAgICB9LFxcbiAgICBfcmVuZGVySXRlbURhdGE6IGZ1bmN0aW9uIF9yZW5kZXJJdGVtRGF0YSh1bCwgaXRlbSkge1xcbiAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJJdGVtKHVsLCBpdGVtKS5kYXRhKFxcXCJ1aS1zZWxlY3RtZW51LWl0ZW1cXFwiLCBpdGVtKTtcXG4gICAgfSxcXG4gICAgX3JlbmRlckl0ZW06IGZ1bmN0aW9uIF9yZW5kZXJJdGVtKHVsLCBpdGVtKSB7XFxuICAgICAgdmFyIGxpID0gJChcXFwiPGxpPlxcXCIpO1xcblxcbiAgICAgIGlmIChpdGVtLmRpc2FibGVkKSB7XFxuICAgICAgICBsaS5hZGRDbGFzcyhcXFwidWktc3RhdGUtZGlzYWJsZWRcXFwiKTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fc2V0VGV4dChsaSwgaXRlbS5sYWJlbCk7XFxuXFxuICAgICAgcmV0dXJuIGxpLmFwcGVuZFRvKHVsKTtcXG4gICAgfSxcXG4gICAgX3NldFRleHQ6IGZ1bmN0aW9uIF9zZXRUZXh0KGVsZW1lbnQsIHZhbHVlKSB7XFxuICAgICAgaWYgKHZhbHVlKSB7XFxuICAgICAgICBlbGVtZW50LnRleHQodmFsdWUpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBlbGVtZW50Lmh0bWwoXFxcIiYjMTYwO1xcXCIpO1xcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgX21vdmU6IGZ1bmN0aW9uIF9tb3ZlKGRpcmVjdGlvbiwgZXZlbnQpIHtcXG4gICAgICB2YXIgaXRlbSxcXG4gICAgICAgICAgbmV4dCxcXG4gICAgICAgICAgZmlsdGVyID0gXFxcIi51aS1tZW51LWl0ZW1cXFwiO1xcblxcbiAgICAgIGlmICh0aGlzLmlzT3Blbikge1xcbiAgICAgICAgaXRlbSA9IHRoaXMubWVudUl0ZW1zLmVxKHRoaXMuZm9jdXNJbmRleCk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGl0ZW0gPSB0aGlzLm1lbnVJdGVtcy5lcSh0aGlzLmVsZW1lbnRbMF0uc2VsZWN0ZWRJbmRleCk7XFxuICAgICAgICBmaWx0ZXIgKz0gXFxcIjpub3QoLnVpLXN0YXRlLWRpc2FibGVkKVxcXCI7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChkaXJlY3Rpb24gPT09IFxcXCJmaXJzdFxcXCIgfHwgZGlyZWN0aW9uID09PSBcXFwibGFzdFxcXCIpIHtcXG4gICAgICAgIG5leHQgPSBpdGVtW2RpcmVjdGlvbiA9PT0gXFxcImZpcnN0XFxcIiA/IFxcXCJwcmV2QWxsXFxcIiA6IFxcXCJuZXh0QWxsXFxcIl0oZmlsdGVyKS5lcSgtMSk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIG5leHQgPSBpdGVtW2RpcmVjdGlvbiArIFxcXCJBbGxcXFwiXShmaWx0ZXIpLmVxKDApO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAobmV4dC5sZW5ndGgpIHtcXG4gICAgICAgIHRoaXMubWVudUluc3RhbmNlLmZvY3VzKGV2ZW50LCBuZXh0KTtcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIF9nZXRTZWxlY3RlZEl0ZW06IGZ1bmN0aW9uIF9nZXRTZWxlY3RlZEl0ZW0oKSB7XFxuICAgICAgcmV0dXJuIHRoaXMubWVudUl0ZW1zLmVxKHRoaXMuZWxlbWVudFswXS5zZWxlY3RlZEluZGV4KTtcXG4gICAgfSxcXG4gICAgX3RvZ2dsZTogZnVuY3Rpb24gX3RvZ2dsZShldmVudCkge1xcbiAgICAgIHRoaXNbdGhpcy5pc09wZW4gPyBcXFwiY2xvc2VcXFwiIDogXFxcIm9wZW5cXFwiXShldmVudCk7XFxuICAgIH0sXFxuICAgIF9zZXRTZWxlY3Rpb246IGZ1bmN0aW9uIF9zZXRTZWxlY3Rpb24oKSB7XFxuICAgICAgdmFyIHNlbGVjdGlvbjtcXG5cXG4gICAgICBpZiAoIXRoaXMucmFuZ2UpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHdpbmRvdy5nZXRTZWxlY3Rpb24pIHtcXG4gICAgICAgIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcXG4gICAgICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcXG4gICAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZSh0aGlzLnJhbmdlKTsgLy8gc3VwcG9ydDogSUU4XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRoaXMucmFuZ2Uuc2VsZWN0KCk7XFxuICAgICAgfSAvLyBzdXBwb3J0OiBJRVxcbiAgICAgIC8vIFNldHRpbmcgdGhlIHRleHQgc2VsZWN0aW9uIGtpbGxzIHRoZSBidXR0b24gZm9jdXMgaW4gSUUsIGJ1dFxcbiAgICAgIC8vIHJlc3RvcmluZyB0aGUgZm9jdXMgZG9lc24ndCBraWxsIHRoZSBzZWxlY3Rpb24uXFxuXFxuXFxuICAgICAgdGhpcy5idXR0b24uZm9jdXMoKTtcXG4gICAgfSxcXG4gICAgX2RvY3VtZW50Q2xpY2s6IHtcXG4gICAgICBtb3VzZWRvd246IGZ1bmN0aW9uIG1vdXNlZG93bihldmVudCkge1xcbiAgICAgICAgaWYgKCF0aGlzLmlzT3Blbikge1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoISQoZXZlbnQudGFyZ2V0KS5jbG9zZXN0KFxcXCIudWktc2VsZWN0bWVudS1tZW51LCAjXFxcIiArIHRoaXMuaWRzLmJ1dHRvbikubGVuZ3RoKSB7XFxuICAgICAgICAgIHRoaXMuY2xvc2UoZXZlbnQpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgX2J1dHRvbkV2ZW50czoge1xcbiAgICAgIC8vIFByZXZlbnQgdGV4dCBzZWxlY3Rpb24gZnJvbSBiZWluZyByZXNldCB3aGVuIGludGVyYWN0aW5nIHdpdGggdGhlIHNlbGVjdG1lbnUgKCMxMDE0NClcXG4gICAgICBtb3VzZWRvd246IGZ1bmN0aW9uIG1vdXNlZG93bigpIHtcXG4gICAgICAgIHZhciBzZWxlY3Rpb247XFxuXFxuICAgICAgICBpZiAod2luZG93LmdldFNlbGVjdGlvbikge1xcbiAgICAgICAgICBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XFxuXFxuICAgICAgICAgIGlmIChzZWxlY3Rpb24ucmFuZ2VDb3VudCkge1xcbiAgICAgICAgICAgIHRoaXMucmFuZ2UgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKTtcXG4gICAgICAgICAgfSAvLyBzdXBwb3J0OiBJRThcXG5cXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHRoaXMucmFuZ2UgPSBkb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcXG4gICAgICAgIH1cXG4gICAgICB9LFxcbiAgICAgIGNsaWNrOiBmdW5jdGlvbiBjbGljayhldmVudCkge1xcbiAgICAgICAgdGhpcy5fc2V0U2VsZWN0aW9uKCk7XFxuXFxuICAgICAgICB0aGlzLl90b2dnbGUoZXZlbnQpO1xcbiAgICAgIH0sXFxuICAgICAga2V5ZG93bjogZnVuY3Rpb24ga2V5ZG93bihldmVudCkge1xcbiAgICAgICAgdmFyIHByZXZlbnREZWZhdWx0ID0gdHJ1ZTtcXG5cXG4gICAgICAgIHN3aXRjaCAoZXZlbnQua2V5Q29kZSkge1xcbiAgICAgICAgICBjYXNlICQudWkua2V5Q29kZS5UQUI6XFxuICAgICAgICAgIGNhc2UgJC51aS5rZXlDb2RlLkVTQ0FQRTpcXG4gICAgICAgICAgICB0aGlzLmNsb3NlKGV2ZW50KTtcXG4gICAgICAgICAgICBwcmV2ZW50RGVmYXVsdCA9IGZhbHNlO1xcbiAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICBjYXNlICQudWkua2V5Q29kZS5FTlRFUjpcXG4gICAgICAgICAgICBpZiAodGhpcy5pc09wZW4pIHtcXG4gICAgICAgICAgICAgIHRoaXMuX3NlbGVjdEZvY3VzZWRJdGVtKGV2ZW50KTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICAgIGNhc2UgJC51aS5rZXlDb2RlLlVQOlxcbiAgICAgICAgICAgIGlmIChldmVudC5hbHRLZXkpIHtcXG4gICAgICAgICAgICAgIHRoaXMuX3RvZ2dsZShldmVudCk7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgIHRoaXMuX21vdmUoXFxcInByZXZcXFwiLCBldmVudCk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICBjYXNlICQudWkua2V5Q29kZS5ET1dOOlxcbiAgICAgICAgICAgIGlmIChldmVudC5hbHRLZXkpIHtcXG4gICAgICAgICAgICAgIHRoaXMuX3RvZ2dsZShldmVudCk7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgIHRoaXMuX21vdmUoXFxcIm5leHRcXFwiLCBldmVudCk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICBjYXNlICQudWkua2V5Q29kZS5TUEFDRTpcXG4gICAgICAgICAgICBpZiAodGhpcy5pc09wZW4pIHtcXG4gICAgICAgICAgICAgIHRoaXMuX3NlbGVjdEZvY3VzZWRJdGVtKGV2ZW50KTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgdGhpcy5fdG9nZ2xlKGV2ZW50KTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICAgIGNhc2UgJC51aS5rZXlDb2RlLkxFRlQ6XFxuICAgICAgICAgICAgdGhpcy5fbW92ZShcXFwicHJldlxcXCIsIGV2ZW50KTtcXG5cXG4gICAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgICAgY2FzZSAkLnVpLmtleUNvZGUuUklHSFQ6XFxuICAgICAgICAgICAgdGhpcy5fbW92ZShcXFwibmV4dFxcXCIsIGV2ZW50KTtcXG5cXG4gICAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgICAgY2FzZSAkLnVpLmtleUNvZGUuSE9NRTpcXG4gICAgICAgICAgY2FzZSAkLnVpLmtleUNvZGUuUEFHRV9VUDpcXG4gICAgICAgICAgICB0aGlzLl9tb3ZlKFxcXCJmaXJzdFxcXCIsIGV2ZW50KTtcXG5cXG4gICAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgICAgY2FzZSAkLnVpLmtleUNvZGUuRU5EOlxcbiAgICAgICAgICBjYXNlICQudWkua2V5Q29kZS5QQUdFX0RPV046XFxuICAgICAgICAgICAgdGhpcy5fbW92ZShcXFwibGFzdFxcXCIsIGV2ZW50KTtcXG5cXG4gICAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgICAgZGVmYXVsdDpcXG4gICAgICAgICAgICB0aGlzLm1lbnUudHJpZ2dlcihldmVudCk7XFxuICAgICAgICAgICAgcHJldmVudERlZmF1bHQgPSBmYWxzZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChwcmV2ZW50RGVmYXVsdCkge1xcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgX3NlbGVjdEZvY3VzZWRJdGVtOiBmdW5jdGlvbiBfc2VsZWN0Rm9jdXNlZEl0ZW0oZXZlbnQpIHtcXG4gICAgICB2YXIgaXRlbSA9IHRoaXMubWVudUl0ZW1zLmVxKHRoaXMuZm9jdXNJbmRleCk7XFxuXFxuICAgICAgaWYgKCFpdGVtLmhhc0NsYXNzKFxcXCJ1aS1zdGF0ZS1kaXNhYmxlZFxcXCIpKSB7XFxuICAgICAgICB0aGlzLl9zZWxlY3QoaXRlbS5kYXRhKFxcXCJ1aS1zZWxlY3RtZW51LWl0ZW1cXFwiKSwgZXZlbnQpO1xcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgX3NlbGVjdDogZnVuY3Rpb24gX3NlbGVjdChpdGVtLCBldmVudCkge1xcbiAgICAgIHZhciBvbGRJbmRleCA9IHRoaXMuZWxlbWVudFswXS5zZWxlY3RlZEluZGV4OyAvLyBDaGFuZ2UgbmF0aXZlIHNlbGVjdCBlbGVtZW50XFxuXFxuICAgICAgdGhpcy5lbGVtZW50WzBdLnNlbGVjdGVkSW5kZXggPSBpdGVtLmluZGV4O1xcblxcbiAgICAgIHRoaXMuX3NldFRleHQodGhpcy5idXR0b25UZXh0LCBpdGVtLmxhYmVsKTtcXG5cXG4gICAgICB0aGlzLl9zZXRBcmlhKGl0ZW0pO1xcblxcbiAgICAgIHRoaXMuX3RyaWdnZXIoXFxcInNlbGVjdFxcXCIsIGV2ZW50LCB7XFxuICAgICAgICBpdGVtOiBpdGVtXFxuICAgICAgfSk7XFxuXFxuICAgICAgaWYgKGl0ZW0uaW5kZXggIT09IG9sZEluZGV4KSB7XFxuICAgICAgICB0aGlzLl90cmlnZ2VyKFxcXCJjaGFuZ2VcXFwiLCBldmVudCwge1xcbiAgICAgICAgICBpdGVtOiBpdGVtXFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5jbG9zZShldmVudCk7XFxuICAgIH0sXFxuICAgIF9zZXRBcmlhOiBmdW5jdGlvbiBfc2V0QXJpYShpdGVtKSB7XFxuICAgICAgdmFyIGlkID0gdGhpcy5tZW51SXRlbXMuZXEoaXRlbS5pbmRleCkuYXR0cihcXFwiaWRcXFwiKTtcXG4gICAgICB0aGlzLmJ1dHRvbi5hdHRyKHtcXG4gICAgICAgIFxcXCJhcmlhLWxhYmVsbGVkYnlcXFwiOiBpZCxcXG4gICAgICAgIFxcXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcXFwiOiBpZFxcbiAgICAgIH0pO1xcbiAgICAgIHRoaXMubWVudS5hdHRyKFxcXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcXFwiLCBpZCk7XFxuICAgIH0sXFxuICAgIF9zZXRPcHRpb246IGZ1bmN0aW9uIF9zZXRPcHRpb24oa2V5LCB2YWx1ZSkge1xcbiAgICAgIGlmIChrZXkgPT09IFxcXCJpY29uc1xcXCIpIHtcXG4gICAgICAgIHRoaXMuYnV0dG9uLmZpbmQoXFxcInNwYW4udWktaWNvblxcXCIpLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5pY29ucy5idXR0b24pLmFkZENsYXNzKHZhbHVlLmJ1dHRvbik7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX3N1cGVyKGtleSwgdmFsdWUpO1xcblxcbiAgICAgIGlmIChrZXkgPT09IFxcXCJhcHBlbmRUb1xcXCIpIHtcXG4gICAgICAgIHRoaXMubWVudVdyYXAuYXBwZW5kVG8odGhpcy5fYXBwZW5kVG8oKSk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChrZXkgPT09IFxcXCJkaXNhYmxlZFxcXCIpIHtcXG4gICAgICAgIHRoaXMubWVudUluc3RhbmNlLm9wdGlvbihcXFwiZGlzYWJsZWRcXFwiLCB2YWx1ZSk7XFxuICAgICAgICB0aGlzLmJ1dHRvbi50b2dnbGVDbGFzcyhcXFwidWktc3RhdGUtZGlzYWJsZWRcXFwiLCB2YWx1ZSkuYXR0cihcXFwiYXJpYS1kaXNhYmxlZFxcXCIsIHZhbHVlKTtcXG4gICAgICAgIHRoaXMuZWxlbWVudC5wcm9wKFxcXCJkaXNhYmxlZFxcXCIsIHZhbHVlKTtcXG5cXG4gICAgICAgIGlmICh2YWx1ZSkge1xcbiAgICAgICAgICB0aGlzLmJ1dHRvbi5hdHRyKFxcXCJ0YWJpbmRleFxcXCIsIC0xKTtcXG4gICAgICAgICAgdGhpcy5jbG9zZSgpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgdGhpcy5idXR0b24uYXR0cihcXFwidGFiaW5kZXhcXFwiLCAwKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGtleSA9PT0gXFxcIndpZHRoXFxcIikge1xcbiAgICAgICAgdGhpcy5fcmVzaXplQnV0dG9uKCk7XFxuICAgICAgfVxcbiAgICB9LFxcbiAgICBfYXBwZW5kVG86IGZ1bmN0aW9uIF9hcHBlbmRUbygpIHtcXG4gICAgICB2YXIgZWxlbWVudCA9IHRoaXMub3B0aW9ucy5hcHBlbmRUbztcXG5cXG4gICAgICBpZiAoZWxlbWVudCkge1xcbiAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQuanF1ZXJ5IHx8IGVsZW1lbnQubm9kZVR5cGUgPyAkKGVsZW1lbnQpIDogdGhpcy5kb2N1bWVudC5maW5kKGVsZW1lbnQpLmVxKDApO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIWVsZW1lbnQgfHwgIWVsZW1lbnRbMF0pIHtcXG4gICAgICAgIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQuY2xvc2VzdChcXFwiLnVpLWZyb250XFxcIik7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghZWxlbWVudC5sZW5ndGgpIHtcXG4gICAgICAgIGVsZW1lbnQgPSB0aGlzLmRvY3VtZW50WzBdLmJvZHk7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBlbGVtZW50O1xcbiAgICB9LFxcbiAgICBfdG9nZ2xlQXR0cjogZnVuY3Rpb24gX3RvZ2dsZUF0dHIoKSB7XFxuICAgICAgdGhpcy5idXR0b24udG9nZ2xlQ2xhc3MoXFxcInVpLWNvcm5lci10b3BcXFwiLCB0aGlzLmlzT3BlbikudG9nZ2xlQ2xhc3MoXFxcInVpLWNvcm5lci1hbGxcXFwiLCAhdGhpcy5pc09wZW4pLmF0dHIoXFxcImFyaWEtZXhwYW5kZWRcXFwiLCB0aGlzLmlzT3Blbik7XFxuICAgICAgdGhpcy5tZW51V3JhcC50b2dnbGVDbGFzcyhcXFwidWktc2VsZWN0bWVudS1vcGVuXFxcIiwgdGhpcy5pc09wZW4pO1xcbiAgICAgIHRoaXMubWVudS5hdHRyKFxcXCJhcmlhLWhpZGRlblxcXCIsICF0aGlzLmlzT3Blbik7XFxuICAgIH0sXFxuICAgIF9yZXNpemVCdXR0b246IGZ1bmN0aW9uIF9yZXNpemVCdXR0b24oKSB7XFxuICAgICAgdmFyIHdpZHRoID0gdGhpcy5vcHRpb25zLndpZHRoO1xcblxcbiAgICAgIGlmICghd2lkdGgpIHtcXG4gICAgICAgIHdpZHRoID0gdGhpcy5lbGVtZW50LnNob3coKS5vdXRlcldpZHRoKCk7XFxuICAgICAgICB0aGlzLmVsZW1lbnQuaGlkZSgpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLmJ1dHRvbi5vdXRlcldpZHRoKHdpZHRoKTtcXG4gICAgfSxcXG4gICAgX3Jlc2l6ZU1lbnU6IGZ1bmN0aW9uIF9yZXNpemVNZW51KCkge1xcbiAgICAgIHRoaXMubWVudS5vdXRlcldpZHRoKE1hdGgubWF4KHRoaXMuYnV0dG9uLm91dGVyV2lkdGgoKSwgLy8gc3VwcG9ydDogSUUxMFxcbiAgICAgIC8vIElFMTAgd3JhcHMgbG9uZyB0ZXh0IChwb3NzaWJseSBhIHJvdW5kaW5nIGJ1ZylcXG4gICAgICAvLyBzbyB3ZSBhZGQgMXB4IHRvIGF2b2lkIHRoZSB3cmFwcGluZ1xcbiAgICAgIHRoaXMubWVudS53aWR0aChcXFwiXFxcIikub3V0ZXJXaWR0aCgpICsgMSkpO1xcbiAgICB9LFxcbiAgICBfZ2V0Q3JlYXRlT3B0aW9uczogZnVuY3Rpb24gX2dldENyZWF0ZU9wdGlvbnMoKSB7XFxuICAgICAgcmV0dXJuIHtcXG4gICAgICAgIGRpc2FibGVkOiB0aGlzLmVsZW1lbnQucHJvcChcXFwiZGlzYWJsZWRcXFwiKVxcbiAgICAgIH07XFxuICAgIH0sXFxuICAgIF9wYXJzZU9wdGlvbnM6IGZ1bmN0aW9uIF9wYXJzZU9wdGlvbnMob3B0aW9ucykge1xcbiAgICAgIHZhciBkYXRhID0gW107XFxuICAgICAgb3B0aW9ucy5lYWNoKGZ1bmN0aW9uIChpbmRleCwgaXRlbSkge1xcbiAgICAgICAgdmFyIG9wdGlvbiA9ICQoaXRlbSksXFxuICAgICAgICAgICAgb3B0Z3JvdXAgPSBvcHRpb24ucGFyZW50KFxcXCJvcHRncm91cFxcXCIpO1xcbiAgICAgICAgZGF0YS5wdXNoKHtcXG4gICAgICAgICAgZWxlbWVudDogb3B0aW9uLFxcbiAgICAgICAgICBpbmRleDogaW5kZXgsXFxuICAgICAgICAgIHZhbHVlOiBvcHRpb24udmFsKCksXFxuICAgICAgICAgIGxhYmVsOiBvcHRpb24udGV4dCgpLFxcbiAgICAgICAgICBvcHRncm91cDogb3B0Z3JvdXAuYXR0cihcXFwibGFiZWxcXFwiKSB8fCBcXFwiXFxcIixcXG4gICAgICAgICAgZGlzYWJsZWQ6IG9wdGdyb3VwLnByb3AoXFxcImRpc2FibGVkXFxcIikgfHwgb3B0aW9uLnByb3AoXFxcImRpc2FibGVkXFxcIilcXG4gICAgICAgIH0pO1xcbiAgICAgIH0pO1xcbiAgICAgIHRoaXMuaXRlbXMgPSBkYXRhO1xcbiAgICB9LFxcbiAgICBfZGVzdHJveTogZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XFxuICAgICAgdGhpcy5tZW51V3JhcC5yZW1vdmUoKTtcXG4gICAgICB0aGlzLmJ1dHRvbi5yZW1vdmUoKTtcXG4gICAgICB0aGlzLmVsZW1lbnQuc2hvdygpO1xcbiAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVVbmlxdWVJZCgpO1xcbiAgICAgIHRoaXMubGFiZWwuYXR0cihcXFwiZm9yXFxcIiwgdGhpcy5pZHMuZWxlbWVudCk7XFxuICAgIH1cXG4gIH0pO1xcbiAgLyohXFxuICAgKiBqUXVlcnkgVUkgU2xpZGVyIDEuMTEuNFxcbiAgICogaHR0cDovL2pxdWVyeXVpLmNvbVxcbiAgICpcXG4gICAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXFxuICAgKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXFxuICAgKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXFxuICAgKlxcbiAgICogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20vc2xpZGVyL1xcbiAgICovXFxuXFxuICB2YXIgc2xpZGVyID0gJC53aWRnZXQoXFxcInVpLnNsaWRlclxcXCIsICQudWkubW91c2UsIHtcXG4gICAgdmVyc2lvbjogXFxcIjEuMTEuNFxcXCIsXFxuICAgIHdpZGdldEV2ZW50UHJlZml4OiBcXFwic2xpZGVcXFwiLFxcbiAgICBvcHRpb25zOiB7XFxuICAgICAgYW5pbWF0ZTogZmFsc2UsXFxuICAgICAgZGlzdGFuY2U6IDAsXFxuICAgICAgbWF4OiAxMDAsXFxuICAgICAgbWluOiAwLFxcbiAgICAgIG9yaWVudGF0aW9uOiBcXFwiaG9yaXpvbnRhbFxcXCIsXFxuICAgICAgcmFuZ2U6IGZhbHNlLFxcbiAgICAgIHN0ZXA6IDEsXFxuICAgICAgdmFsdWU6IDAsXFxuICAgICAgdmFsdWVzOiBudWxsLFxcbiAgICAgIC8vIGNhbGxiYWNrc1xcbiAgICAgIGNoYW5nZTogbnVsbCxcXG4gICAgICBzbGlkZTogbnVsbCxcXG4gICAgICBzdGFydDogbnVsbCxcXG4gICAgICBzdG9wOiBudWxsXFxuICAgIH0sXFxuICAgIC8vIG51bWJlciBvZiBwYWdlcyBpbiBhIHNsaWRlclxcbiAgICAvLyAoaG93IG1hbnkgdGltZXMgY2FuIHlvdSBwYWdlIHVwL2Rvd24gdG8gZ28gdGhyb3VnaCB0aGUgd2hvbGUgcmFuZ2UpXFxuICAgIG51bVBhZ2VzOiA1LFxcbiAgICBfY3JlYXRlOiBmdW5jdGlvbiBfY3JlYXRlKCkge1xcbiAgICAgIHRoaXMuX2tleVNsaWRpbmcgPSBmYWxzZTtcXG4gICAgICB0aGlzLl9tb3VzZVNsaWRpbmcgPSBmYWxzZTtcXG4gICAgICB0aGlzLl9hbmltYXRlT2ZmID0gdHJ1ZTtcXG4gICAgICB0aGlzLl9oYW5kbGVJbmRleCA9IG51bGw7XFxuXFxuICAgICAgdGhpcy5fZGV0ZWN0T3JpZW50YXRpb24oKTtcXG5cXG4gICAgICB0aGlzLl9tb3VzZUluaXQoKTtcXG5cXG4gICAgICB0aGlzLl9jYWxjdWxhdGVOZXdNYXgoKTtcXG5cXG4gICAgICB0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoXFxcInVpLXNsaWRlclxcXCIgKyBcXFwiIHVpLXNsaWRlci1cXFwiICsgdGhpcy5vcmllbnRhdGlvbiArIFxcXCIgdWktd2lkZ2V0XFxcIiArIFxcXCIgdWktd2lkZ2V0LWNvbnRlbnRcXFwiICsgXFxcIiB1aS1jb3JuZXItYWxsXFxcIik7XFxuXFxuICAgICAgdGhpcy5fcmVmcmVzaCgpO1xcblxcbiAgICAgIHRoaXMuX3NldE9wdGlvbihcXFwiZGlzYWJsZWRcXFwiLCB0aGlzLm9wdGlvbnMuZGlzYWJsZWQpO1xcblxcbiAgICAgIHRoaXMuX2FuaW1hdGVPZmYgPSBmYWxzZTtcXG4gICAgfSxcXG4gICAgX3JlZnJlc2g6IGZ1bmN0aW9uIF9yZWZyZXNoKCkge1xcbiAgICAgIHRoaXMuX2NyZWF0ZVJhbmdlKCk7XFxuXFxuICAgICAgdGhpcy5fY3JlYXRlSGFuZGxlcygpO1xcblxcbiAgICAgIHRoaXMuX3NldHVwRXZlbnRzKCk7XFxuXFxuICAgICAgdGhpcy5fcmVmcmVzaFZhbHVlKCk7XFxuICAgIH0sXFxuICAgIF9jcmVhdGVIYW5kbGVzOiBmdW5jdGlvbiBfY3JlYXRlSGFuZGxlcygpIHtcXG4gICAgICB2YXIgaSxcXG4gICAgICAgICAgaGFuZGxlQ291bnQsXFxuICAgICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXFxuICAgICAgICAgIGV4aXN0aW5nSGFuZGxlcyA9IHRoaXMuZWxlbWVudC5maW5kKFxcXCIudWktc2xpZGVyLWhhbmRsZVxcXCIpLmFkZENsYXNzKFxcXCJ1aS1zdGF0ZS1kZWZhdWx0IHVpLWNvcm5lci1hbGxcXFwiKSxcXG4gICAgICAgICAgaGFuZGxlID0gXFxcIjxzcGFuIGNsYXNzPSd1aS1zbGlkZXItaGFuZGxlIHVpLXN0YXRlLWRlZmF1bHQgdWktY29ybmVyLWFsbCcgdGFiaW5kZXg9JzAnPjwvc3Bhbj5cXFwiLFxcbiAgICAgICAgICBoYW5kbGVzID0gW107XFxuICAgICAgaGFuZGxlQ291bnQgPSBvcHRpb25zLnZhbHVlcyAmJiBvcHRpb25zLnZhbHVlcy5sZW5ndGggfHwgMTtcXG5cXG4gICAgICBpZiAoZXhpc3RpbmdIYW5kbGVzLmxlbmd0aCA+IGhhbmRsZUNvdW50KSB7XFxuICAgICAgICBleGlzdGluZ0hhbmRsZXMuc2xpY2UoaGFuZGxlQ291bnQpLnJlbW92ZSgpO1xcbiAgICAgICAgZXhpc3RpbmdIYW5kbGVzID0gZXhpc3RpbmdIYW5kbGVzLnNsaWNlKDAsIGhhbmRsZUNvdW50KTtcXG4gICAgICB9XFxuXFxuICAgICAgZm9yIChpID0gZXhpc3RpbmdIYW5kbGVzLmxlbmd0aDsgaSA8IGhhbmRsZUNvdW50OyBpKyspIHtcXG4gICAgICAgIGhhbmRsZXMucHVzaChoYW5kbGUpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLmhhbmRsZXMgPSBleGlzdGluZ0hhbmRsZXMuYWRkKCQoaGFuZGxlcy5qb2luKFxcXCJcXFwiKSkuYXBwZW5kVG8odGhpcy5lbGVtZW50KSk7XFxuICAgICAgdGhpcy5oYW5kbGUgPSB0aGlzLmhhbmRsZXMuZXEoMCk7XFxuICAgICAgdGhpcy5oYW5kbGVzLmVhY2goZnVuY3Rpb24gKGkpIHtcXG4gICAgICAgICQodGhpcykuZGF0YShcXFwidWktc2xpZGVyLWhhbmRsZS1pbmRleFxcXCIsIGkpO1xcbiAgICAgIH0pO1xcbiAgICB9LFxcbiAgICBfY3JlYXRlUmFuZ2U6IGZ1bmN0aW9uIF9jcmVhdGVSYW5nZSgpIHtcXG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcXG4gICAgICAgICAgY2xhc3NlcyA9IFxcXCJcXFwiO1xcblxcbiAgICAgIGlmIChvcHRpb25zLnJhbmdlKSB7XFxuICAgICAgICBpZiAob3B0aW9ucy5yYW5nZSA9PT0gdHJ1ZSkge1xcbiAgICAgICAgICBpZiAoIW9wdGlvbnMudmFsdWVzKSB7XFxuICAgICAgICAgICAgb3B0aW9ucy52YWx1ZXMgPSBbdGhpcy5fdmFsdWVNaW4oKSwgdGhpcy5fdmFsdWVNaW4oKV07XFxuICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy52YWx1ZXMubGVuZ3RoICYmIG9wdGlvbnMudmFsdWVzLmxlbmd0aCAhPT0gMikge1xcbiAgICAgICAgICAgIG9wdGlvbnMudmFsdWVzID0gW29wdGlvbnMudmFsdWVzWzBdLCBvcHRpb25zLnZhbHVlc1swXV07XFxuICAgICAgICAgIH0gZWxzZSBpZiAoJC5pc0FycmF5KG9wdGlvbnMudmFsdWVzKSkge1xcbiAgICAgICAgICAgIG9wdGlvbnMudmFsdWVzID0gb3B0aW9ucy52YWx1ZXMuc2xpY2UoMCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICghdGhpcy5yYW5nZSB8fCAhdGhpcy5yYW5nZS5sZW5ndGgpIHtcXG4gICAgICAgICAgdGhpcy5yYW5nZSA9ICQoXFxcIjxkaXY+PC9kaXY+XFxcIikuYXBwZW5kVG8odGhpcy5lbGVtZW50KTtcXG4gICAgICAgICAgY2xhc3NlcyA9IFxcXCJ1aS1zbGlkZXItcmFuZ2VcXFwiICsgLy8gbm90ZTogdGhpcyBpc24ndCB0aGUgbW9zdCBmaXR0aW5nbHkgc2VtYW50aWMgZnJhbWV3b3JrIGNsYXNzIGZvciB0aGlzIGVsZW1lbnQsXFxuICAgICAgICAgIC8vIGJ1dCB3b3JrZWQgYmVzdCB2aXN1YWxseSB3aXRoIGEgdmFyaWV0eSBvZiB0aGVtZXNcXG4gICAgICAgICAgXFxcIiB1aS13aWRnZXQtaGVhZGVyIHVpLWNvcm5lci1hbGxcXFwiO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgdGhpcy5yYW5nZS5yZW1vdmVDbGFzcyhcXFwidWktc2xpZGVyLXJhbmdlLW1pbiB1aS1zbGlkZXItcmFuZ2UtbWF4XFxcIikgLy8gSGFuZGxlIHJhbmdlIHN3aXRjaGluZyBmcm9tIHRydWUgdG8gbWluL21heFxcbiAgICAgICAgICAuY3NzKHtcXG4gICAgICAgICAgICBcXFwibGVmdFxcXCI6IFxcXCJcXFwiLFxcbiAgICAgICAgICAgIFxcXCJib3R0b21cXFwiOiBcXFwiXFxcIlxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHRoaXMucmFuZ2UuYWRkQ2xhc3MoY2xhc3NlcyArIChvcHRpb25zLnJhbmdlID09PSBcXFwibWluXFxcIiB8fCBvcHRpb25zLnJhbmdlID09PSBcXFwibWF4XFxcIiA/IFxcXCIgdWktc2xpZGVyLXJhbmdlLVxcXCIgKyBvcHRpb25zLnJhbmdlIDogXFxcIlxcXCIpKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgaWYgKHRoaXMucmFuZ2UpIHtcXG4gICAgICAgICAgdGhpcy5yYW5nZS5yZW1vdmUoKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHRoaXMucmFuZ2UgPSBudWxsO1xcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgX3NldHVwRXZlbnRzOiBmdW5jdGlvbiBfc2V0dXBFdmVudHMoKSB7XFxuICAgICAgdGhpcy5fb2ZmKHRoaXMuaGFuZGxlcyk7XFxuXFxuICAgICAgdGhpcy5fb24odGhpcy5oYW5kbGVzLCB0aGlzLl9oYW5kbGVFdmVudHMpO1xcblxcbiAgICAgIHRoaXMuX2hvdmVyYWJsZSh0aGlzLmhhbmRsZXMpO1xcblxcbiAgICAgIHRoaXMuX2ZvY3VzYWJsZSh0aGlzLmhhbmRsZXMpO1xcbiAgICB9LFxcbiAgICBfZGVzdHJveTogZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XFxuICAgICAgdGhpcy5oYW5kbGVzLnJlbW92ZSgpO1xcblxcbiAgICAgIGlmICh0aGlzLnJhbmdlKSB7XFxuICAgICAgICB0aGlzLnJhbmdlLnJlbW92ZSgpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlQ2xhc3MoXFxcInVpLXNsaWRlclxcXCIgKyBcXFwiIHVpLXNsaWRlci1ob3Jpem9udGFsXFxcIiArIFxcXCIgdWktc2xpZGVyLXZlcnRpY2FsXFxcIiArIFxcXCIgdWktd2lkZ2V0XFxcIiArIFxcXCIgdWktd2lkZ2V0LWNvbnRlbnRcXFwiICsgXFxcIiB1aS1jb3JuZXItYWxsXFxcIik7XFxuXFxuICAgICAgdGhpcy5fbW91c2VEZXN0cm95KCk7XFxuICAgIH0sXFxuICAgIF9tb3VzZUNhcHR1cmU6IGZ1bmN0aW9uIF9tb3VzZUNhcHR1cmUoZXZlbnQpIHtcXG4gICAgICB2YXIgcG9zaXRpb24sXFxuICAgICAgICAgIG5vcm1WYWx1ZSxcXG4gICAgICAgICAgZGlzdGFuY2UsXFxuICAgICAgICAgIGNsb3Nlc3RIYW5kbGUsXFxuICAgICAgICAgIGluZGV4LFxcbiAgICAgICAgICBhbGxvd2VkLFxcbiAgICAgICAgICBvZmZzZXQsXFxuICAgICAgICAgIG1vdXNlT3ZlckhhbmRsZSxcXG4gICAgICAgICAgdGhhdCA9IHRoaXMsXFxuICAgICAgICAgIG8gPSB0aGlzLm9wdGlvbnM7XFxuXFxuICAgICAgaWYgKG8uZGlzYWJsZWQpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5lbGVtZW50U2l6ZSA9IHtcXG4gICAgICAgIHdpZHRoOiB0aGlzLmVsZW1lbnQub3V0ZXJXaWR0aCgpLFxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLmVsZW1lbnQub3V0ZXJIZWlnaHQoKVxcbiAgICAgIH07XFxuICAgICAgdGhpcy5lbGVtZW50T2Zmc2V0ID0gdGhpcy5lbGVtZW50Lm9mZnNldCgpO1xcbiAgICAgIHBvc2l0aW9uID0ge1xcbiAgICAgICAgeDogZXZlbnQucGFnZVgsXFxuICAgICAgICB5OiBldmVudC5wYWdlWVxcbiAgICAgIH07XFxuICAgICAgbm9ybVZhbHVlID0gdGhpcy5fbm9ybVZhbHVlRnJvbU1vdXNlKHBvc2l0aW9uKTtcXG4gICAgICBkaXN0YW5jZSA9IHRoaXMuX3ZhbHVlTWF4KCkgLSB0aGlzLl92YWx1ZU1pbigpICsgMTtcXG4gICAgICB0aGlzLmhhbmRsZXMuZWFjaChmdW5jdGlvbiAoaSkge1xcbiAgICAgICAgdmFyIHRoaXNEaXN0YW5jZSA9IE1hdGguYWJzKG5vcm1WYWx1ZSAtIHRoYXQudmFsdWVzKGkpKTtcXG5cXG4gICAgICAgIGlmIChkaXN0YW5jZSA+IHRoaXNEaXN0YW5jZSB8fCBkaXN0YW5jZSA9PT0gdGhpc0Rpc3RhbmNlICYmIChpID09PSB0aGF0Ll9sYXN0Q2hhbmdlZFZhbHVlIHx8IHRoYXQudmFsdWVzKGkpID09PSBvLm1pbikpIHtcXG4gICAgICAgICAgZGlzdGFuY2UgPSB0aGlzRGlzdGFuY2U7XFxuICAgICAgICAgIGNsb3Nlc3RIYW5kbGUgPSAkKHRoaXMpO1xcbiAgICAgICAgICBpbmRleCA9IGk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgICAgYWxsb3dlZCA9IHRoaXMuX3N0YXJ0KGV2ZW50LCBpbmRleCk7XFxuXFxuICAgICAgaWYgKGFsbG93ZWQgPT09IGZhbHNlKSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX21vdXNlU2xpZGluZyA9IHRydWU7XFxuICAgICAgdGhpcy5faGFuZGxlSW5kZXggPSBpbmRleDtcXG4gICAgICBjbG9zZXN0SGFuZGxlLmFkZENsYXNzKFxcXCJ1aS1zdGF0ZS1hY3RpdmVcXFwiKS5mb2N1cygpO1xcbiAgICAgIG9mZnNldCA9IGNsb3Nlc3RIYW5kbGUub2Zmc2V0KCk7XFxuICAgICAgbW91c2VPdmVySGFuZGxlID0gISQoZXZlbnQudGFyZ2V0KS5wYXJlbnRzKCkuYWRkQmFjaygpLmlzKFxcXCIudWktc2xpZGVyLWhhbmRsZVxcXCIpO1xcbiAgICAgIHRoaXMuX2NsaWNrT2Zmc2V0ID0gbW91c2VPdmVySGFuZGxlID8ge1xcbiAgICAgICAgbGVmdDogMCxcXG4gICAgICAgIHRvcDogMFxcbiAgICAgIH0gOiB7XFxuICAgICAgICBsZWZ0OiBldmVudC5wYWdlWCAtIG9mZnNldC5sZWZ0IC0gY2xvc2VzdEhhbmRsZS53aWR0aCgpIC8gMixcXG4gICAgICAgIHRvcDogZXZlbnQucGFnZVkgLSBvZmZzZXQudG9wIC0gY2xvc2VzdEhhbmRsZS5oZWlnaHQoKSAvIDIgLSAocGFyc2VJbnQoY2xvc2VzdEhhbmRsZS5jc3MoXFxcImJvcmRlclRvcFdpZHRoXFxcIiksIDEwKSB8fCAwKSAtIChwYXJzZUludChjbG9zZXN0SGFuZGxlLmNzcyhcXFwiYm9yZGVyQm90dG9tV2lkdGhcXFwiKSwgMTApIHx8IDApICsgKHBhcnNlSW50KGNsb3Nlc3RIYW5kbGUuY3NzKFxcXCJtYXJnaW5Ub3BcXFwiKSwgMTApIHx8IDApXFxuICAgICAgfTtcXG5cXG4gICAgICBpZiAoIXRoaXMuaGFuZGxlcy5oYXNDbGFzcyhcXFwidWktc3RhdGUtaG92ZXJcXFwiKSkge1xcbiAgICAgICAgdGhpcy5fc2xpZGUoZXZlbnQsIGluZGV4LCBub3JtVmFsdWUpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9hbmltYXRlT2ZmID0gdHJ1ZTtcXG4gICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgfSxcXG4gICAgX21vdXNlU3RhcnQ6IGZ1bmN0aW9uIF9tb3VzZVN0YXJ0KCkge1xcbiAgICAgIHJldHVybiB0cnVlO1xcbiAgICB9LFxcbiAgICBfbW91c2VEcmFnOiBmdW5jdGlvbiBfbW91c2VEcmFnKGV2ZW50KSB7XFxuICAgICAgdmFyIHBvc2l0aW9uID0ge1xcbiAgICAgICAgeDogZXZlbnQucGFnZVgsXFxuICAgICAgICB5OiBldmVudC5wYWdlWVxcbiAgICAgIH0sXFxuICAgICAgICAgIG5vcm1WYWx1ZSA9IHRoaXMuX25vcm1WYWx1ZUZyb21Nb3VzZShwb3NpdGlvbik7XFxuXFxuICAgICAgdGhpcy5fc2xpZGUoZXZlbnQsIHRoaXMuX2hhbmRsZUluZGV4LCBub3JtVmFsdWUpO1xcblxcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfSxcXG4gICAgX21vdXNlU3RvcDogZnVuY3Rpb24gX21vdXNlU3RvcChldmVudCkge1xcbiAgICAgIHRoaXMuaGFuZGxlcy5yZW1vdmVDbGFzcyhcXFwidWktc3RhdGUtYWN0aXZlXFxcIik7XFxuICAgICAgdGhpcy5fbW91c2VTbGlkaW5nID0gZmFsc2U7XFxuXFxuICAgICAgdGhpcy5fc3RvcChldmVudCwgdGhpcy5faGFuZGxlSW5kZXgpO1xcblxcbiAgICAgIHRoaXMuX2NoYW5nZShldmVudCwgdGhpcy5faGFuZGxlSW5kZXgpO1xcblxcbiAgICAgIHRoaXMuX2hhbmRsZUluZGV4ID0gbnVsbDtcXG4gICAgICB0aGlzLl9jbGlja09mZnNldCA9IG51bGw7XFxuICAgICAgdGhpcy5fYW5pbWF0ZU9mZiA9IGZhbHNlO1xcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfSxcXG4gICAgX2RldGVjdE9yaWVudGF0aW9uOiBmdW5jdGlvbiBfZGV0ZWN0T3JpZW50YXRpb24oKSB7XFxuICAgICAgdGhpcy5vcmllbnRhdGlvbiA9IHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbiA9PT0gXFxcInZlcnRpY2FsXFxcIiA/IFxcXCJ2ZXJ0aWNhbFxcXCIgOiBcXFwiaG9yaXpvbnRhbFxcXCI7XFxuICAgIH0sXFxuICAgIF9ub3JtVmFsdWVGcm9tTW91c2U6IGZ1bmN0aW9uIF9ub3JtVmFsdWVGcm9tTW91c2UocG9zaXRpb24pIHtcXG4gICAgICB2YXIgcGl4ZWxUb3RhbCwgcGl4ZWxNb3VzZSwgcGVyY2VudE1vdXNlLCB2YWx1ZVRvdGFsLCB2YWx1ZU1vdXNlO1xcblxcbiAgICAgIGlmICh0aGlzLm9yaWVudGF0aW9uID09PSBcXFwiaG9yaXpvbnRhbFxcXCIpIHtcXG4gICAgICAgIHBpeGVsVG90YWwgPSB0aGlzLmVsZW1lbnRTaXplLndpZHRoO1xcbiAgICAgICAgcGl4ZWxNb3VzZSA9IHBvc2l0aW9uLnggLSB0aGlzLmVsZW1lbnRPZmZzZXQubGVmdCAtICh0aGlzLl9jbGlja09mZnNldCA/IHRoaXMuX2NsaWNrT2Zmc2V0LmxlZnQgOiAwKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgcGl4ZWxUb3RhbCA9IHRoaXMuZWxlbWVudFNpemUuaGVpZ2h0O1xcbiAgICAgICAgcGl4ZWxNb3VzZSA9IHBvc2l0aW9uLnkgLSB0aGlzLmVsZW1lbnRPZmZzZXQudG9wIC0gKHRoaXMuX2NsaWNrT2Zmc2V0ID8gdGhpcy5fY2xpY2tPZmZzZXQudG9wIDogMCk7XFxuICAgICAgfVxcblxcbiAgICAgIHBlcmNlbnRNb3VzZSA9IHBpeGVsTW91c2UgLyBwaXhlbFRvdGFsO1xcblxcbiAgICAgIGlmIChwZXJjZW50TW91c2UgPiAxKSB7XFxuICAgICAgICBwZXJjZW50TW91c2UgPSAxO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAocGVyY2VudE1vdXNlIDwgMCkge1xcbiAgICAgICAgcGVyY2VudE1vdXNlID0gMDtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMub3JpZW50YXRpb24gPT09IFxcXCJ2ZXJ0aWNhbFxcXCIpIHtcXG4gICAgICAgIHBlcmNlbnRNb3VzZSA9IDEgLSBwZXJjZW50TW91c2U7XFxuICAgICAgfVxcblxcbiAgICAgIHZhbHVlVG90YWwgPSB0aGlzLl92YWx1ZU1heCgpIC0gdGhpcy5fdmFsdWVNaW4oKTtcXG4gICAgICB2YWx1ZU1vdXNlID0gdGhpcy5fdmFsdWVNaW4oKSArIHBlcmNlbnRNb3VzZSAqIHZhbHVlVG90YWw7XFxuICAgICAgcmV0dXJuIHRoaXMuX3RyaW1BbGlnblZhbHVlKHZhbHVlTW91c2UpO1xcbiAgICB9LFxcbiAgICBfc3RhcnQ6IGZ1bmN0aW9uIF9zdGFydChldmVudCwgaW5kZXgpIHtcXG4gICAgICB2YXIgdWlIYXNoID0ge1xcbiAgICAgICAgaGFuZGxlOiB0aGlzLmhhbmRsZXNbaW5kZXhdLFxcbiAgICAgICAgdmFsdWU6IHRoaXMudmFsdWUoKVxcbiAgICAgIH07XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy52YWx1ZXMgJiYgdGhpcy5vcHRpb25zLnZhbHVlcy5sZW5ndGgpIHtcXG4gICAgICAgIHVpSGFzaC52YWx1ZSA9IHRoaXMudmFsdWVzKGluZGV4KTtcXG4gICAgICAgIHVpSGFzaC52YWx1ZXMgPSB0aGlzLnZhbHVlcygpO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gdGhpcy5fdHJpZ2dlcihcXFwic3RhcnRcXFwiLCBldmVudCwgdWlIYXNoKTtcXG4gICAgfSxcXG4gICAgX3NsaWRlOiBmdW5jdGlvbiBfc2xpZGUoZXZlbnQsIGluZGV4LCBuZXdWYWwpIHtcXG4gICAgICB2YXIgb3RoZXJWYWwsIG5ld1ZhbHVlcywgYWxsb3dlZDtcXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnZhbHVlcyAmJiB0aGlzLm9wdGlvbnMudmFsdWVzLmxlbmd0aCkge1xcbiAgICAgICAgb3RoZXJWYWwgPSB0aGlzLnZhbHVlcyhpbmRleCA/IDAgOiAxKTtcXG5cXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudmFsdWVzLmxlbmd0aCA9PT0gMiAmJiB0aGlzLm9wdGlvbnMucmFuZ2UgPT09IHRydWUgJiYgKGluZGV4ID09PSAwICYmIG5ld1ZhbCA+IG90aGVyVmFsIHx8IGluZGV4ID09PSAxICYmIG5ld1ZhbCA8IG90aGVyVmFsKSkge1xcbiAgICAgICAgICBuZXdWYWwgPSBvdGhlclZhbDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChuZXdWYWwgIT09IHRoaXMudmFsdWVzKGluZGV4KSkge1xcbiAgICAgICAgICBuZXdWYWx1ZXMgPSB0aGlzLnZhbHVlcygpO1xcbiAgICAgICAgICBuZXdWYWx1ZXNbaW5kZXhdID0gbmV3VmFsOyAvLyBBIHNsaWRlIGNhbiBiZSBjYW5jZWxlZCBieSByZXR1cm5pbmcgZmFsc2UgZnJvbSB0aGUgc2xpZGUgY2FsbGJhY2tcXG5cXG4gICAgICAgICAgYWxsb3dlZCA9IHRoaXMuX3RyaWdnZXIoXFxcInNsaWRlXFxcIiwgZXZlbnQsIHtcXG4gICAgICAgICAgICBoYW5kbGU6IHRoaXMuaGFuZGxlc1tpbmRleF0sXFxuICAgICAgICAgICAgdmFsdWU6IG5ld1ZhbCxcXG4gICAgICAgICAgICB2YWx1ZXM6IG5ld1ZhbHVlc1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgICAgb3RoZXJWYWwgPSB0aGlzLnZhbHVlcyhpbmRleCA/IDAgOiAxKTtcXG5cXG4gICAgICAgICAgaWYgKGFsbG93ZWQgIT09IGZhbHNlKSB7XFxuICAgICAgICAgICAgdGhpcy52YWx1ZXMoaW5kZXgsIG5ld1ZhbCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgaWYgKG5ld1ZhbCAhPT0gdGhpcy52YWx1ZSgpKSB7XFxuICAgICAgICAgIC8vIEEgc2xpZGUgY2FuIGJlIGNhbmNlbGVkIGJ5IHJldHVybmluZyBmYWxzZSBmcm9tIHRoZSBzbGlkZSBjYWxsYmFja1xcbiAgICAgICAgICBhbGxvd2VkID0gdGhpcy5fdHJpZ2dlcihcXFwic2xpZGVcXFwiLCBldmVudCwge1xcbiAgICAgICAgICAgIGhhbmRsZTogdGhpcy5oYW5kbGVzW2luZGV4XSxcXG4gICAgICAgICAgICB2YWx1ZTogbmV3VmFsXFxuICAgICAgICAgIH0pO1xcblxcbiAgICAgICAgICBpZiAoYWxsb3dlZCAhPT0gZmFsc2UpIHtcXG4gICAgICAgICAgICB0aGlzLnZhbHVlKG5ld1ZhbCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH0sXFxuICAgIF9zdG9wOiBmdW5jdGlvbiBfc3RvcChldmVudCwgaW5kZXgpIHtcXG4gICAgICB2YXIgdWlIYXNoID0ge1xcbiAgICAgICAgaGFuZGxlOiB0aGlzLmhhbmRsZXNbaW5kZXhdLFxcbiAgICAgICAgdmFsdWU6IHRoaXMudmFsdWUoKVxcbiAgICAgIH07XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy52YWx1ZXMgJiYgdGhpcy5vcHRpb25zLnZhbHVlcy5sZW5ndGgpIHtcXG4gICAgICAgIHVpSGFzaC52YWx1ZSA9IHRoaXMudmFsdWVzKGluZGV4KTtcXG4gICAgICAgIHVpSGFzaC52YWx1ZXMgPSB0aGlzLnZhbHVlcygpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl90cmlnZ2VyKFxcXCJzdG9wXFxcIiwgZXZlbnQsIHVpSGFzaCk7XFxuICAgIH0sXFxuICAgIF9jaGFuZ2U6IGZ1bmN0aW9uIF9jaGFuZ2UoZXZlbnQsIGluZGV4KSB7XFxuICAgICAgaWYgKCF0aGlzLl9rZXlTbGlkaW5nICYmICF0aGlzLl9tb3VzZVNsaWRpbmcpIHtcXG4gICAgICAgIHZhciB1aUhhc2ggPSB7XFxuICAgICAgICAgIGhhbmRsZTogdGhpcy5oYW5kbGVzW2luZGV4XSxcXG4gICAgICAgICAgdmFsdWU6IHRoaXMudmFsdWUoKVxcbiAgICAgICAgfTtcXG5cXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudmFsdWVzICYmIHRoaXMub3B0aW9ucy52YWx1ZXMubGVuZ3RoKSB7XFxuICAgICAgICAgIHVpSGFzaC52YWx1ZSA9IHRoaXMudmFsdWVzKGluZGV4KTtcXG4gICAgICAgICAgdWlIYXNoLnZhbHVlcyA9IHRoaXMudmFsdWVzKCk7XFxuICAgICAgICB9IC8vc3RvcmUgdGhlIGxhc3QgY2hhbmdlZCB2YWx1ZSBpbmRleCBmb3IgcmVmZXJlbmNlIHdoZW4gaGFuZGxlcyBvdmVybGFwXFxuXFxuXFxuICAgICAgICB0aGlzLl9sYXN0Q2hhbmdlZFZhbHVlID0gaW5kZXg7XFxuXFxuICAgICAgICB0aGlzLl90cmlnZ2VyKFxcXCJjaGFuZ2VcXFwiLCBldmVudCwgdWlIYXNoKTtcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShuZXdWYWx1ZSkge1xcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XFxuICAgICAgICB0aGlzLm9wdGlvbnMudmFsdWUgPSB0aGlzLl90cmltQWxpZ25WYWx1ZShuZXdWYWx1ZSk7XFxuXFxuICAgICAgICB0aGlzLl9yZWZyZXNoVmFsdWUoKTtcXG5cXG4gICAgICAgIHRoaXMuX2NoYW5nZShudWxsLCAwKTtcXG5cXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlKCk7XFxuICAgIH0sXFxuICAgIHZhbHVlczogZnVuY3Rpb24gdmFsdWVzKGluZGV4LCBuZXdWYWx1ZSkge1xcbiAgICAgIHZhciB2YWxzLCBuZXdWYWx1ZXMsIGk7XFxuXFxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XFxuICAgICAgICB0aGlzLm9wdGlvbnMudmFsdWVzW2luZGV4XSA9IHRoaXMuX3RyaW1BbGlnblZhbHVlKG5ld1ZhbHVlKTtcXG5cXG4gICAgICAgIHRoaXMuX3JlZnJlc2hWYWx1ZSgpO1xcblxcbiAgICAgICAgdGhpcy5fY2hhbmdlKG51bGwsIGluZGV4KTtcXG5cXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcXG4gICAgICAgIGlmICgkLmlzQXJyYXkoYXJndW1lbnRzWzBdKSkge1xcbiAgICAgICAgICB2YWxzID0gdGhpcy5vcHRpb25zLnZhbHVlcztcXG4gICAgICAgICAgbmV3VmFsdWVzID0gYXJndW1lbnRzWzBdO1xcblxcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmFscy5sZW5ndGg7IGkgKz0gMSkge1xcbiAgICAgICAgICAgIHZhbHNbaV0gPSB0aGlzLl90cmltQWxpZ25WYWx1ZShuZXdWYWx1ZXNbaV0pO1xcblxcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZShudWxsLCBpKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICB0aGlzLl9yZWZyZXNoVmFsdWUoKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudmFsdWVzICYmIHRoaXMub3B0aW9ucy52YWx1ZXMubGVuZ3RoKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlcyhpbmRleCk7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUoKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWVzKCk7XFxuICAgICAgfVxcbiAgICB9LFxcbiAgICBfc2V0T3B0aW9uOiBmdW5jdGlvbiBfc2V0T3B0aW9uKGtleSwgdmFsdWUpIHtcXG4gICAgICB2YXIgaSxcXG4gICAgICAgICAgdmFsc0xlbmd0aCA9IDA7XFxuXFxuICAgICAgaWYgKGtleSA9PT0gXFxcInJhbmdlXFxcIiAmJiB0aGlzLm9wdGlvbnMucmFuZ2UgPT09IHRydWUpIHtcXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gXFxcIm1pblxcXCIpIHtcXG4gICAgICAgICAgdGhpcy5vcHRpb25zLnZhbHVlID0gdGhpcy5fdmFsdWVzKDApO1xcbiAgICAgICAgICB0aGlzLm9wdGlvbnMudmFsdWVzID0gbnVsbDtcXG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IFxcXCJtYXhcXFwiKSB7XFxuICAgICAgICAgIHRoaXMub3B0aW9ucy52YWx1ZSA9IHRoaXMuX3ZhbHVlcyh0aGlzLm9wdGlvbnMudmFsdWVzLmxlbmd0aCAtIDEpO1xcbiAgICAgICAgICB0aGlzLm9wdGlvbnMudmFsdWVzID0gbnVsbDtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCQuaXNBcnJheSh0aGlzLm9wdGlvbnMudmFsdWVzKSkge1xcbiAgICAgICAgdmFsc0xlbmd0aCA9IHRoaXMub3B0aW9ucy52YWx1ZXMubGVuZ3RoO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoa2V5ID09PSBcXFwiZGlzYWJsZWRcXFwiKSB7XFxuICAgICAgICB0aGlzLmVsZW1lbnQudG9nZ2xlQ2xhc3MoXFxcInVpLXN0YXRlLWRpc2FibGVkXFxcIiwgISF2YWx1ZSk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX3N1cGVyKGtleSwgdmFsdWUpO1xcblxcbiAgICAgIHN3aXRjaCAoa2V5KSB7XFxuICAgICAgICBjYXNlIFxcXCJvcmllbnRhdGlvblxcXCI6XFxuICAgICAgICAgIHRoaXMuX2RldGVjdE9yaWVudGF0aW9uKCk7XFxuXFxuICAgICAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVDbGFzcyhcXFwidWktc2xpZGVyLWhvcml6b250YWwgdWktc2xpZGVyLXZlcnRpY2FsXFxcIikuYWRkQ2xhc3MoXFxcInVpLXNsaWRlci1cXFwiICsgdGhpcy5vcmllbnRhdGlvbik7XFxuXFxuICAgICAgICAgIHRoaXMuX3JlZnJlc2hWYWx1ZSgpOyAvLyBSZXNldCBwb3NpdGlvbmluZyBmcm9tIHByZXZpb3VzIG9yaWVudGF0aW9uXFxuXFxuXFxuICAgICAgICAgIHRoaXMuaGFuZGxlcy5jc3ModmFsdWUgPT09IFxcXCJob3Jpem9udGFsXFxcIiA/IFxcXCJib3R0b21cXFwiIDogXFxcImxlZnRcXFwiLCBcXFwiXFxcIik7XFxuICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgY2FzZSBcXFwidmFsdWVcXFwiOlxcbiAgICAgICAgICB0aGlzLl9hbmltYXRlT2ZmID0gdHJ1ZTtcXG5cXG4gICAgICAgICAgdGhpcy5fcmVmcmVzaFZhbHVlKCk7XFxuXFxuICAgICAgICAgIHRoaXMuX2NoYW5nZShudWxsLCAwKTtcXG5cXG4gICAgICAgICAgdGhpcy5fYW5pbWF0ZU9mZiA9IGZhbHNlO1xcbiAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgIGNhc2UgXFxcInZhbHVlc1xcXCI6XFxuICAgICAgICAgIHRoaXMuX2FuaW1hdGVPZmYgPSB0cnVlO1xcblxcbiAgICAgICAgICB0aGlzLl9yZWZyZXNoVmFsdWUoKTtcXG5cXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IHZhbHNMZW5ndGg7IGkgKz0gMSkge1xcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZShudWxsLCBpKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICB0aGlzLl9hbmltYXRlT2ZmID0gZmFsc2U7XFxuICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgY2FzZSBcXFwic3RlcFxcXCI6XFxuICAgICAgICBjYXNlIFxcXCJtaW5cXFwiOlxcbiAgICAgICAgY2FzZSBcXFwibWF4XFxcIjpcXG4gICAgICAgICAgdGhpcy5fYW5pbWF0ZU9mZiA9IHRydWU7XFxuXFxuICAgICAgICAgIHRoaXMuX2NhbGN1bGF0ZU5ld01heCgpO1xcblxcbiAgICAgICAgICB0aGlzLl9yZWZyZXNoVmFsdWUoKTtcXG5cXG4gICAgICAgICAgdGhpcy5fYW5pbWF0ZU9mZiA9IGZhbHNlO1xcbiAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgIGNhc2UgXFxcInJhbmdlXFxcIjpcXG4gICAgICAgICAgdGhpcy5fYW5pbWF0ZU9mZiA9IHRydWU7XFxuXFxuICAgICAgICAgIHRoaXMuX3JlZnJlc2goKTtcXG5cXG4gICAgICAgICAgdGhpcy5fYW5pbWF0ZU9mZiA9IGZhbHNlO1xcbiAgICAgICAgICBicmVhaztcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIC8vaW50ZXJuYWwgdmFsdWUgZ2V0dGVyXFxuICAgIC8vIF92YWx1ZSgpIHJldHVybnMgdmFsdWUgdHJpbW1lZCBieSBtaW4gYW5kIG1heCwgYWxpZ25lZCBieSBzdGVwXFxuICAgIF92YWx1ZTogZnVuY3Rpb24gX3ZhbHVlKCkge1xcbiAgICAgIHZhciB2YWwgPSB0aGlzLm9wdGlvbnMudmFsdWU7XFxuICAgICAgdmFsID0gdGhpcy5fdHJpbUFsaWduVmFsdWUodmFsKTtcXG4gICAgICByZXR1cm4gdmFsO1xcbiAgICB9LFxcbiAgICAvL2ludGVybmFsIHZhbHVlcyBnZXR0ZXJcXG4gICAgLy8gX3ZhbHVlcygpIHJldHVybnMgYXJyYXkgb2YgdmFsdWVzIHRyaW1tZWQgYnkgbWluIGFuZCBtYXgsIGFsaWduZWQgYnkgc3RlcFxcbiAgICAvLyBfdmFsdWVzKCBpbmRleCApIHJldHVybnMgc2luZ2xlIHZhbHVlIHRyaW1tZWQgYnkgbWluIGFuZCBtYXgsIGFsaWduZWQgYnkgc3RlcFxcbiAgICBfdmFsdWVzOiBmdW5jdGlvbiBfdmFsdWVzKGluZGV4KSB7XFxuICAgICAgdmFyIHZhbCwgdmFscywgaTtcXG5cXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xcbiAgICAgICAgdmFsID0gdGhpcy5vcHRpb25zLnZhbHVlc1tpbmRleF07XFxuICAgICAgICB2YWwgPSB0aGlzLl90cmltQWxpZ25WYWx1ZSh2YWwpO1xcbiAgICAgICAgcmV0dXJuIHZhbDtcXG4gICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy52YWx1ZXMgJiYgdGhpcy5vcHRpb25zLnZhbHVlcy5sZW5ndGgpIHtcXG4gICAgICAgIC8vIC5zbGljZSgpIGNyZWF0ZXMgYSBjb3B5IG9mIHRoZSBhcnJheVxcbiAgICAgICAgLy8gdGhpcyBjb3B5IGdldHMgdHJpbW1lZCBieSBtaW4gYW5kIG1heCBhbmQgdGhlbiByZXR1cm5lZFxcbiAgICAgICAgdmFscyA9IHRoaXMub3B0aW9ucy52YWx1ZXMuc2xpY2UoKTtcXG5cXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWxzLmxlbmd0aDsgaSArPSAxKSB7XFxuICAgICAgICAgIHZhbHNbaV0gPSB0aGlzLl90cmltQWxpZ25WYWx1ZSh2YWxzW2ldKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiB2YWxzO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICByZXR1cm4gW107XFxuICAgICAgfVxcbiAgICB9LFxcbiAgICAvLyByZXR1cm5zIHRoZSBzdGVwLWFsaWduZWQgdmFsdWUgdGhhdCB2YWwgaXMgY2xvc2VzdCB0bywgYmV0d2VlbiAoaW5jbHVzaXZlKSBtaW4gYW5kIG1heFxcbiAgICBfdHJpbUFsaWduVmFsdWU6IGZ1bmN0aW9uIF90cmltQWxpZ25WYWx1ZSh2YWwpIHtcXG4gICAgICBpZiAodmFsIDw9IHRoaXMuX3ZhbHVlTWluKCkpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZU1pbigpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodmFsID49IHRoaXMuX3ZhbHVlTWF4KCkpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZU1heCgpO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgc3RlcCA9IHRoaXMub3B0aW9ucy5zdGVwID4gMCA/IHRoaXMub3B0aW9ucy5zdGVwIDogMSxcXG4gICAgICAgICAgdmFsTW9kU3RlcCA9ICh2YWwgLSB0aGlzLl92YWx1ZU1pbigpKSAlIHN0ZXAsXFxuICAgICAgICAgIGFsaWduVmFsdWUgPSB2YWwgLSB2YWxNb2RTdGVwO1xcblxcbiAgICAgIGlmIChNYXRoLmFicyh2YWxNb2RTdGVwKSAqIDIgPj0gc3RlcCkge1xcbiAgICAgICAgYWxpZ25WYWx1ZSArPSB2YWxNb2RTdGVwID4gMCA/IHN0ZXAgOiAtc3RlcDtcXG4gICAgICB9IC8vIFNpbmNlIEphdmFTY3JpcHQgaGFzIHByb2JsZW1zIHdpdGggbGFyZ2UgZmxvYXRzLCByb3VuZFxcbiAgICAgIC8vIHRoZSBmaW5hbCB2YWx1ZSB0byA1IGRpZ2l0cyBhZnRlciB0aGUgZGVjaW1hbCBwb2ludCAoc2VlICM0MTI0KVxcblxcblxcbiAgICAgIHJldHVybiBwYXJzZUZsb2F0KGFsaWduVmFsdWUudG9GaXhlZCg1KSk7XFxuICAgIH0sXFxuICAgIF9jYWxjdWxhdGVOZXdNYXg6IGZ1bmN0aW9uIF9jYWxjdWxhdGVOZXdNYXgoKSB7XFxuICAgICAgdmFyIG1heCA9IHRoaXMub3B0aW9ucy5tYXgsXFxuICAgICAgICAgIG1pbiA9IHRoaXMuX3ZhbHVlTWluKCksXFxuICAgICAgICAgIHN0ZXAgPSB0aGlzLm9wdGlvbnMuc3RlcCxcXG4gICAgICAgICAgYWJvdmVNaW4gPSBNYXRoLmZsb29yKCsobWF4IC0gbWluKS50b0ZpeGVkKHRoaXMuX3ByZWNpc2lvbigpKSAvIHN0ZXApICogc3RlcDtcXG5cXG4gICAgICBtYXggPSBhYm92ZU1pbiArIG1pbjtcXG4gICAgICB0aGlzLm1heCA9IHBhcnNlRmxvYXQobWF4LnRvRml4ZWQodGhpcy5fcHJlY2lzaW9uKCkpKTtcXG4gICAgfSxcXG4gICAgX3ByZWNpc2lvbjogZnVuY3Rpb24gX3ByZWNpc2lvbigpIHtcXG4gICAgICB2YXIgcHJlY2lzaW9uID0gdGhpcy5fcHJlY2lzaW9uT2YodGhpcy5vcHRpb25zLnN0ZXApO1xcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubWluICE9PSBudWxsKSB7XFxuICAgICAgICBwcmVjaXNpb24gPSBNYXRoLm1heChwcmVjaXNpb24sIHRoaXMuX3ByZWNpc2lvbk9mKHRoaXMub3B0aW9ucy5taW4pKTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHByZWNpc2lvbjtcXG4gICAgfSxcXG4gICAgX3ByZWNpc2lvbk9mOiBmdW5jdGlvbiBfcHJlY2lzaW9uT2YobnVtKSB7XFxuICAgICAgdmFyIHN0ciA9IG51bS50b1N0cmluZygpLFxcbiAgICAgICAgICBkZWNpbWFsID0gc3RyLmluZGV4T2YoXFxcIi5cXFwiKTtcXG4gICAgICByZXR1cm4gZGVjaW1hbCA9PT0gLTEgPyAwIDogc3RyLmxlbmd0aCAtIGRlY2ltYWwgLSAxO1xcbiAgICB9LFxcbiAgICBfdmFsdWVNaW46IGZ1bmN0aW9uIF92YWx1ZU1pbigpIHtcXG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLm1pbjtcXG4gICAgfSxcXG4gICAgX3ZhbHVlTWF4OiBmdW5jdGlvbiBfdmFsdWVNYXgoKSB7XFxuICAgICAgcmV0dXJuIHRoaXMubWF4O1xcbiAgICB9LFxcbiAgICBfcmVmcmVzaFZhbHVlOiBmdW5jdGlvbiBfcmVmcmVzaFZhbHVlKCkge1xcbiAgICAgIHZhciBsYXN0VmFsUGVyY2VudCxcXG4gICAgICAgICAgdmFsUGVyY2VudCxcXG4gICAgICAgICAgdmFsdWUsXFxuICAgICAgICAgIHZhbHVlTWluLFxcbiAgICAgICAgICB2YWx1ZU1heCxcXG4gICAgICAgICAgb1JhbmdlID0gdGhpcy5vcHRpb25zLnJhbmdlLFxcbiAgICAgICAgICBvID0gdGhpcy5vcHRpb25zLFxcbiAgICAgICAgICB0aGF0ID0gdGhpcyxcXG4gICAgICAgICAgYW5pbWF0ZSA9ICF0aGlzLl9hbmltYXRlT2ZmID8gby5hbmltYXRlIDogZmFsc2UsXFxuICAgICAgICAgIF9zZXQgPSB7fTtcXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnZhbHVlcyAmJiB0aGlzLm9wdGlvbnMudmFsdWVzLmxlbmd0aCkge1xcbiAgICAgICAgdGhpcy5oYW5kbGVzLmVhY2goZnVuY3Rpb24gKGkpIHtcXG4gICAgICAgICAgdmFsUGVyY2VudCA9ICh0aGF0LnZhbHVlcyhpKSAtIHRoYXQuX3ZhbHVlTWluKCkpIC8gKHRoYXQuX3ZhbHVlTWF4KCkgLSB0aGF0Ll92YWx1ZU1pbigpKSAqIDEwMDtcXG4gICAgICAgICAgX3NldFt0aGF0Lm9yaWVudGF0aW9uID09PSBcXFwiaG9yaXpvbnRhbFxcXCIgPyBcXFwibGVmdFxcXCIgOiBcXFwiYm90dG9tXFxcIl0gPSB2YWxQZXJjZW50ICsgXFxcIiVcXFwiO1xcbiAgICAgICAgICAkKHRoaXMpLnN0b3AoMSwgMSlbYW5pbWF0ZSA/IFxcXCJhbmltYXRlXFxcIiA6IFxcXCJjc3NcXFwiXShfc2V0LCBvLmFuaW1hdGUpO1xcblxcbiAgICAgICAgICBpZiAodGhhdC5vcHRpb25zLnJhbmdlID09PSB0cnVlKSB7XFxuICAgICAgICAgICAgaWYgKHRoYXQub3JpZW50YXRpb24gPT09IFxcXCJob3Jpem9udGFsXFxcIikge1xcbiAgICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcXG4gICAgICAgICAgICAgICAgdGhhdC5yYW5nZS5zdG9wKDEsIDEpW2FuaW1hdGUgPyBcXFwiYW5pbWF0ZVxcXCIgOiBcXFwiY3NzXFxcIl0oe1xcbiAgICAgICAgICAgICAgICAgIGxlZnQ6IHZhbFBlcmNlbnQgKyBcXFwiJVxcXCJcXG4gICAgICAgICAgICAgICAgfSwgby5hbmltYXRlKTtcXG4gICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgIGlmIChpID09PSAxKSB7XFxuICAgICAgICAgICAgICAgIHRoYXQucmFuZ2VbYW5pbWF0ZSA/IFxcXCJhbmltYXRlXFxcIiA6IFxcXCJjc3NcXFwiXSh7XFxuICAgICAgICAgICAgICAgICAgd2lkdGg6IHZhbFBlcmNlbnQgLSBsYXN0VmFsUGVyY2VudCArIFxcXCIlXFxcIlxcbiAgICAgICAgICAgICAgICB9LCB7XFxuICAgICAgICAgICAgICAgICAgcXVldWU6IGZhbHNlLFxcbiAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBvLmFuaW1hdGVcXG4gICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgIGlmIChpID09PSAwKSB7XFxuICAgICAgICAgICAgICAgIHRoYXQucmFuZ2Uuc3RvcCgxLCAxKVthbmltYXRlID8gXFxcImFuaW1hdGVcXFwiIDogXFxcImNzc1xcXCJdKHtcXG4gICAgICAgICAgICAgICAgICBib3R0b206IHZhbFBlcmNlbnQgKyBcXFwiJVxcXCJcXG4gICAgICAgICAgICAgICAgfSwgby5hbmltYXRlKTtcXG4gICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgIGlmIChpID09PSAxKSB7XFxuICAgICAgICAgICAgICAgIHRoYXQucmFuZ2VbYW5pbWF0ZSA/IFxcXCJhbmltYXRlXFxcIiA6IFxcXCJjc3NcXFwiXSh7XFxuICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB2YWxQZXJjZW50IC0gbGFzdFZhbFBlcmNlbnQgKyBcXFwiJVxcXCJcXG4gICAgICAgICAgICAgICAgfSwge1xcbiAgICAgICAgICAgICAgICAgIHF1ZXVlOiBmYWxzZSxcXG4gICAgICAgICAgICAgICAgICBkdXJhdGlvbjogby5hbmltYXRlXFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBsYXN0VmFsUGVyY2VudCA9IHZhbFBlcmNlbnQ7XFxuICAgICAgICB9KTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdmFsdWUgPSB0aGlzLnZhbHVlKCk7XFxuICAgICAgICB2YWx1ZU1pbiA9IHRoaXMuX3ZhbHVlTWluKCk7XFxuICAgICAgICB2YWx1ZU1heCA9IHRoaXMuX3ZhbHVlTWF4KCk7XFxuICAgICAgICB2YWxQZXJjZW50ID0gdmFsdWVNYXggIT09IHZhbHVlTWluID8gKHZhbHVlIC0gdmFsdWVNaW4pIC8gKHZhbHVlTWF4IC0gdmFsdWVNaW4pICogMTAwIDogMDtcXG4gICAgICAgIF9zZXRbdGhpcy5vcmllbnRhdGlvbiA9PT0gXFxcImhvcml6b250YWxcXFwiID8gXFxcImxlZnRcXFwiIDogXFxcImJvdHRvbVxcXCJdID0gdmFsUGVyY2VudCArIFxcXCIlXFxcIjtcXG4gICAgICAgIHRoaXMuaGFuZGxlLnN0b3AoMSwgMSlbYW5pbWF0ZSA/IFxcXCJhbmltYXRlXFxcIiA6IFxcXCJjc3NcXFwiXShfc2V0LCBvLmFuaW1hdGUpO1xcblxcbiAgICAgICAgaWYgKG9SYW5nZSA9PT0gXFxcIm1pblxcXCIgJiYgdGhpcy5vcmllbnRhdGlvbiA9PT0gXFxcImhvcml6b250YWxcXFwiKSB7XFxuICAgICAgICAgIHRoaXMucmFuZ2Uuc3RvcCgxLCAxKVthbmltYXRlID8gXFxcImFuaW1hdGVcXFwiIDogXFxcImNzc1xcXCJdKHtcXG4gICAgICAgICAgICB3aWR0aDogdmFsUGVyY2VudCArIFxcXCIlXFxcIlxcbiAgICAgICAgICB9LCBvLmFuaW1hdGUpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKG9SYW5nZSA9PT0gXFxcIm1heFxcXCIgJiYgdGhpcy5vcmllbnRhdGlvbiA9PT0gXFxcImhvcml6b250YWxcXFwiKSB7XFxuICAgICAgICAgIHRoaXMucmFuZ2VbYW5pbWF0ZSA/IFxcXCJhbmltYXRlXFxcIiA6IFxcXCJjc3NcXFwiXSh7XFxuICAgICAgICAgICAgd2lkdGg6IDEwMCAtIHZhbFBlcmNlbnQgKyBcXFwiJVxcXCJcXG4gICAgICAgICAgfSwge1xcbiAgICAgICAgICAgIHF1ZXVlOiBmYWxzZSxcXG4gICAgICAgICAgICBkdXJhdGlvbjogby5hbmltYXRlXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKG9SYW5nZSA9PT0gXFxcIm1pblxcXCIgJiYgdGhpcy5vcmllbnRhdGlvbiA9PT0gXFxcInZlcnRpY2FsXFxcIikge1xcbiAgICAgICAgICB0aGlzLnJhbmdlLnN0b3AoMSwgMSlbYW5pbWF0ZSA/IFxcXCJhbmltYXRlXFxcIiA6IFxcXCJjc3NcXFwiXSh7XFxuICAgICAgICAgICAgaGVpZ2h0OiB2YWxQZXJjZW50ICsgXFxcIiVcXFwiXFxuICAgICAgICAgIH0sIG8uYW5pbWF0ZSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAob1JhbmdlID09PSBcXFwibWF4XFxcIiAmJiB0aGlzLm9yaWVudGF0aW9uID09PSBcXFwidmVydGljYWxcXFwiKSB7XFxuICAgICAgICAgIHRoaXMucmFuZ2VbYW5pbWF0ZSA/IFxcXCJhbmltYXRlXFxcIiA6IFxcXCJjc3NcXFwiXSh7XFxuICAgICAgICAgICAgaGVpZ2h0OiAxMDAgLSB2YWxQZXJjZW50ICsgXFxcIiVcXFwiXFxuICAgICAgICAgIH0sIHtcXG4gICAgICAgICAgICBxdWV1ZTogZmFsc2UsXFxuICAgICAgICAgICAgZHVyYXRpb246IG8uYW5pbWF0ZVxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH0sXFxuICAgIF9oYW5kbGVFdmVudHM6IHtcXG4gICAgICBrZXlkb3duOiBmdW5jdGlvbiBrZXlkb3duKGV2ZW50KSB7XFxuICAgICAgICB2YXIgYWxsb3dlZCxcXG4gICAgICAgICAgICBjdXJWYWwsXFxuICAgICAgICAgICAgbmV3VmFsLFxcbiAgICAgICAgICAgIHN0ZXAsXFxuICAgICAgICAgICAgaW5kZXggPSAkKGV2ZW50LnRhcmdldCkuZGF0YShcXFwidWktc2xpZGVyLWhhbmRsZS1pbmRleFxcXCIpO1xcblxcbiAgICAgICAgc3dpdGNoIChldmVudC5rZXlDb2RlKSB7XFxuICAgICAgICAgIGNhc2UgJC51aS5rZXlDb2RlLkhPTUU6XFxuICAgICAgICAgIGNhc2UgJC51aS5rZXlDb2RlLkVORDpcXG4gICAgICAgICAgY2FzZSAkLnVpLmtleUNvZGUuUEFHRV9VUDpcXG4gICAgICAgICAgY2FzZSAkLnVpLmtleUNvZGUuUEFHRV9ET1dOOlxcbiAgICAgICAgICBjYXNlICQudWkua2V5Q29kZS5VUDpcXG4gICAgICAgICAgY2FzZSAkLnVpLmtleUNvZGUuUklHSFQ6XFxuICAgICAgICAgIGNhc2UgJC51aS5rZXlDb2RlLkRPV046XFxuICAgICAgICAgIGNhc2UgJC51aS5rZXlDb2RlLkxFRlQ6XFxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG5cXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2tleVNsaWRpbmcpIHtcXG4gICAgICAgICAgICAgIHRoaXMuX2tleVNsaWRpbmcgPSB0cnVlO1xcbiAgICAgICAgICAgICAgJChldmVudC50YXJnZXQpLmFkZENsYXNzKFxcXCJ1aS1zdGF0ZS1hY3RpdmVcXFwiKTtcXG4gICAgICAgICAgICAgIGFsbG93ZWQgPSB0aGlzLl9zdGFydChldmVudCwgaW5kZXgpO1xcblxcbiAgICAgICAgICAgICAgaWYgKGFsbG93ZWQgPT09IGZhbHNlKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBzdGVwID0gdGhpcy5vcHRpb25zLnN0ZXA7XFxuXFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnZhbHVlcyAmJiB0aGlzLm9wdGlvbnMudmFsdWVzLmxlbmd0aCkge1xcbiAgICAgICAgICBjdXJWYWwgPSBuZXdWYWwgPSB0aGlzLnZhbHVlcyhpbmRleCk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBjdXJWYWwgPSBuZXdWYWwgPSB0aGlzLnZhbHVlKCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBzd2l0Y2ggKGV2ZW50LmtleUNvZGUpIHtcXG4gICAgICAgICAgY2FzZSAkLnVpLmtleUNvZGUuSE9NRTpcXG4gICAgICAgICAgICBuZXdWYWwgPSB0aGlzLl92YWx1ZU1pbigpO1xcbiAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICBjYXNlICQudWkua2V5Q29kZS5FTkQ6XFxuICAgICAgICAgICAgbmV3VmFsID0gdGhpcy5fdmFsdWVNYXgoKTtcXG4gICAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgICAgY2FzZSAkLnVpLmtleUNvZGUuUEFHRV9VUDpcXG4gICAgICAgICAgICBuZXdWYWwgPSB0aGlzLl90cmltQWxpZ25WYWx1ZShjdXJWYWwgKyAodGhpcy5fdmFsdWVNYXgoKSAtIHRoaXMuX3ZhbHVlTWluKCkpIC8gdGhpcy5udW1QYWdlcyk7XFxuICAgICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICAgIGNhc2UgJC51aS5rZXlDb2RlLlBBR0VfRE9XTjpcXG4gICAgICAgICAgICBuZXdWYWwgPSB0aGlzLl90cmltQWxpZ25WYWx1ZShjdXJWYWwgLSAodGhpcy5fdmFsdWVNYXgoKSAtIHRoaXMuX3ZhbHVlTWluKCkpIC8gdGhpcy5udW1QYWdlcyk7XFxuICAgICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICAgIGNhc2UgJC51aS5rZXlDb2RlLlVQOlxcbiAgICAgICAgICBjYXNlICQudWkua2V5Q29kZS5SSUdIVDpcXG4gICAgICAgICAgICBpZiAoY3VyVmFsID09PSB0aGlzLl92YWx1ZU1heCgpKSB7XFxuICAgICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIG5ld1ZhbCA9IHRoaXMuX3RyaW1BbGlnblZhbHVlKGN1clZhbCArIHN0ZXApO1xcbiAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICBjYXNlICQudWkua2V5Q29kZS5ET1dOOlxcbiAgICAgICAgICBjYXNlICQudWkua2V5Q29kZS5MRUZUOlxcbiAgICAgICAgICAgIGlmIChjdXJWYWwgPT09IHRoaXMuX3ZhbHVlTWluKCkpIHtcXG4gICAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgbmV3VmFsID0gdGhpcy5fdHJpbUFsaWduVmFsdWUoY3VyVmFsIC0gc3RlcCk7XFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0aGlzLl9zbGlkZShldmVudCwgaW5kZXgsIG5ld1ZhbCk7XFxuICAgICAgfSxcXG4gICAgICBrZXl1cDogZnVuY3Rpb24ga2V5dXAoZXZlbnQpIHtcXG4gICAgICAgIHZhciBpbmRleCA9ICQoZXZlbnQudGFyZ2V0KS5kYXRhKFxcXCJ1aS1zbGlkZXItaGFuZGxlLWluZGV4XFxcIik7XFxuXFxuICAgICAgICBpZiAodGhpcy5fa2V5U2xpZGluZykge1xcbiAgICAgICAgICB0aGlzLl9rZXlTbGlkaW5nID0gZmFsc2U7XFxuXFxuICAgICAgICAgIHRoaXMuX3N0b3AoZXZlbnQsIGluZGV4KTtcXG5cXG4gICAgICAgICAgdGhpcy5fY2hhbmdlKGV2ZW50LCBpbmRleCk7XFxuXFxuICAgICAgICAgICQoZXZlbnQudGFyZ2V0KS5yZW1vdmVDbGFzcyhcXFwidWktc3RhdGUtYWN0aXZlXFxcIik7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuICB9KTtcXG4gIC8qIVxcbiAgICogalF1ZXJ5IFVJIFNvcnRhYmxlIDEuMTEuNFxcbiAgICogaHR0cDovL2pxdWVyeXVpLmNvbVxcbiAgICpcXG4gICAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXFxuICAgKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXFxuICAgKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXFxuICAgKlxcbiAgICogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20vc29ydGFibGUvXFxuICAgKi9cXG5cXG4gIHZhciBzb3J0YWJsZSA9ICQud2lkZ2V0KFxcXCJ1aS5zb3J0YWJsZVxcXCIsICQudWkubW91c2UsIHtcXG4gICAgdmVyc2lvbjogXFxcIjEuMTEuNFxcXCIsXFxuICAgIHdpZGdldEV2ZW50UHJlZml4OiBcXFwic29ydFxcXCIsXFxuICAgIHJlYWR5OiBmYWxzZSxcXG4gICAgb3B0aW9uczoge1xcbiAgICAgIGFwcGVuZFRvOiBcXFwicGFyZW50XFxcIixcXG4gICAgICBheGlzOiBmYWxzZSxcXG4gICAgICBjb25uZWN0V2l0aDogZmFsc2UsXFxuICAgICAgY29udGFpbm1lbnQ6IGZhbHNlLFxcbiAgICAgIGN1cnNvcjogXFxcImF1dG9cXFwiLFxcbiAgICAgIGN1cnNvckF0OiBmYWxzZSxcXG4gICAgICBkcm9wT25FbXB0eTogdHJ1ZSxcXG4gICAgICBmb3JjZVBsYWNlaG9sZGVyU2l6ZTogZmFsc2UsXFxuICAgICAgZm9yY2VIZWxwZXJTaXplOiBmYWxzZSxcXG4gICAgICBncmlkOiBmYWxzZSxcXG4gICAgICBoYW5kbGU6IGZhbHNlLFxcbiAgICAgIGhlbHBlcjogXFxcIm9yaWdpbmFsXFxcIixcXG4gICAgICBpdGVtczogXFxcIj4gKlxcXCIsXFxuICAgICAgb3BhY2l0eTogZmFsc2UsXFxuICAgICAgcGxhY2Vob2xkZXI6IGZhbHNlLFxcbiAgICAgIHJldmVydDogZmFsc2UsXFxuICAgICAgc2Nyb2xsOiB0cnVlLFxcbiAgICAgIHNjcm9sbFNlbnNpdGl2aXR5OiAyMCxcXG4gICAgICBzY3JvbGxTcGVlZDogMjAsXFxuICAgICAgc2NvcGU6IFxcXCJkZWZhdWx0XFxcIixcXG4gICAgICB0b2xlcmFuY2U6IFxcXCJpbnRlcnNlY3RcXFwiLFxcbiAgICAgIHpJbmRleDogMTAwMCxcXG4gICAgICAvLyBjYWxsYmFja3NcXG4gICAgICBhY3RpdmF0ZTogbnVsbCxcXG4gICAgICBiZWZvcmVTdG9wOiBudWxsLFxcbiAgICAgIGNoYW5nZTogbnVsbCxcXG4gICAgICBkZWFjdGl2YXRlOiBudWxsLFxcbiAgICAgIG91dDogbnVsbCxcXG4gICAgICBvdmVyOiBudWxsLFxcbiAgICAgIHJlY2VpdmU6IG51bGwsXFxuICAgICAgcmVtb3ZlOiBudWxsLFxcbiAgICAgIHNvcnQ6IG51bGwsXFxuICAgICAgc3RhcnQ6IG51bGwsXFxuICAgICAgc3RvcDogbnVsbCxcXG4gICAgICB1cGRhdGU6IG51bGxcXG4gICAgfSxcXG4gICAgX2lzT3ZlckF4aXM6IGZ1bmN0aW9uIF9pc092ZXJBeGlzKHgsIHJlZmVyZW5jZSwgc2l6ZSkge1xcbiAgICAgIHJldHVybiB4ID49IHJlZmVyZW5jZSAmJiB4IDwgcmVmZXJlbmNlICsgc2l6ZTtcXG4gICAgfSxcXG4gICAgX2lzRmxvYXRpbmc6IGZ1bmN0aW9uIF9pc0Zsb2F0aW5nKGl0ZW0pIHtcXG4gICAgICByZXR1cm4gL2xlZnR8cmlnaHQvLnRlc3QoaXRlbS5jc3MoXFxcImZsb2F0XFxcIikpIHx8IC9pbmxpbmV8dGFibGUtY2VsbC8udGVzdChpdGVtLmNzcyhcXFwiZGlzcGxheVxcXCIpKTtcXG4gICAgfSxcXG4gICAgX2NyZWF0ZTogZnVuY3Rpb24gX2NyZWF0ZSgpIHtcXG4gICAgICB0aGlzLmNvbnRhaW5lckNhY2hlID0ge307XFxuICAgICAgdGhpcy5lbGVtZW50LmFkZENsYXNzKFxcXCJ1aS1zb3J0YWJsZVxcXCIpOyAvL0dldCB0aGUgaXRlbXNcXG5cXG4gICAgICB0aGlzLnJlZnJlc2goKTsgLy9MZXQncyBkZXRlcm1pbmUgdGhlIHBhcmVudCdzIG9mZnNldFxcblxcbiAgICAgIHRoaXMub2Zmc2V0ID0gdGhpcy5lbGVtZW50Lm9mZnNldCgpOyAvL0luaXRpYWxpemUgbW91c2UgZXZlbnRzIGZvciBpbnRlcmFjdGlvblxcblxcbiAgICAgIHRoaXMuX21vdXNlSW5pdCgpO1xcblxcbiAgICAgIHRoaXMuX3NldEhhbmRsZUNsYXNzTmFtZSgpOyAvL1dlJ3JlIHJlYWR5IHRvIGdvXFxuXFxuXFxuICAgICAgdGhpcy5yZWFkeSA9IHRydWU7XFxuICAgIH0sXFxuICAgIF9zZXRPcHRpb246IGZ1bmN0aW9uIF9zZXRPcHRpb24oa2V5LCB2YWx1ZSkge1xcbiAgICAgIHRoaXMuX3N1cGVyKGtleSwgdmFsdWUpO1xcblxcbiAgICAgIGlmIChrZXkgPT09IFxcXCJoYW5kbGVcXFwiKSB7XFxuICAgICAgICB0aGlzLl9zZXRIYW5kbGVDbGFzc05hbWUoKTtcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIF9zZXRIYW5kbGVDbGFzc05hbWU6IGZ1bmN0aW9uIF9zZXRIYW5kbGVDbGFzc05hbWUoKSB7XFxuICAgICAgdGhpcy5lbGVtZW50LmZpbmQoXFxcIi51aS1zb3J0YWJsZS1oYW5kbGVcXFwiKS5yZW1vdmVDbGFzcyhcXFwidWktc29ydGFibGUtaGFuZGxlXFxcIik7XFxuICAgICAgJC5lYWNoKHRoaXMuaXRlbXMsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICh0aGlzLmluc3RhbmNlLm9wdGlvbnMuaGFuZGxlID8gdGhpcy5pdGVtLmZpbmQodGhpcy5pbnN0YW5jZS5vcHRpb25zLmhhbmRsZSkgOiB0aGlzLml0ZW0pLmFkZENsYXNzKFxcXCJ1aS1zb3J0YWJsZS1oYW5kbGVcXFwiKTtcXG4gICAgICB9KTtcXG4gICAgfSxcXG4gICAgX2Rlc3Ryb3k6IGZ1bmN0aW9uIF9kZXN0cm95KCkge1xcbiAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVDbGFzcyhcXFwidWktc29ydGFibGUgdWktc29ydGFibGUtZGlzYWJsZWRcXFwiKS5maW5kKFxcXCIudWktc29ydGFibGUtaGFuZGxlXFxcIikucmVtb3ZlQ2xhc3MoXFxcInVpLXNvcnRhYmxlLWhhbmRsZVxcXCIpO1xcblxcbiAgICAgIHRoaXMuX21vdXNlRGVzdHJveSgpO1xcblxcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLml0ZW1zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XFxuICAgICAgICB0aGlzLml0ZW1zW2ldLml0ZW0ucmVtb3ZlRGF0YSh0aGlzLndpZGdldE5hbWUgKyBcXFwiLWl0ZW1cXFwiKTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHRoaXM7XFxuICAgIH0sXFxuICAgIF9tb3VzZUNhcHR1cmU6IGZ1bmN0aW9uIF9tb3VzZUNhcHR1cmUoZXZlbnQsIG92ZXJyaWRlSGFuZGxlKSB7XFxuICAgICAgdmFyIGN1cnJlbnRJdGVtID0gbnVsbCxcXG4gICAgICAgICAgdmFsaWRIYW5kbGUgPSBmYWxzZSxcXG4gICAgICAgICAgdGhhdCA9IHRoaXM7XFxuXFxuICAgICAgaWYgKHRoaXMucmV2ZXJ0aW5nKSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGlzYWJsZWQgfHwgdGhpcy5vcHRpb25zLnR5cGUgPT09IFxcXCJzdGF0aWNcXFwiKSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfSAvL1dlIGhhdmUgdG8gcmVmcmVzaCB0aGUgaXRlbXMgZGF0YSBvbmNlIGZpcnN0XFxuXFxuXFxuICAgICAgdGhpcy5fcmVmcmVzaEl0ZW1zKGV2ZW50KTsgLy9GaW5kIG91dCBpZiB0aGUgY2xpY2tlZCBub2RlIChvciBvbmUgb2YgaXRzIHBhcmVudHMpIGlzIGEgYWN0dWFsIGl0ZW0gaW4gdGhpcy5pdGVtc1xcblxcblxcbiAgICAgICQoZXZlbnQudGFyZ2V0KS5wYXJlbnRzKCkuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICBpZiAoJC5kYXRhKHRoaXMsIHRoYXQud2lkZ2V0TmFtZSArIFxcXCItaXRlbVxcXCIpID09PSB0aGF0KSB7XFxuICAgICAgICAgIGN1cnJlbnRJdGVtID0gJCh0aGlzKTtcXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcblxcbiAgICAgIGlmICgkLmRhdGEoZXZlbnQudGFyZ2V0LCB0aGF0LndpZGdldE5hbWUgKyBcXFwiLWl0ZW1cXFwiKSA9PT0gdGhhdCkge1xcbiAgICAgICAgY3VycmVudEl0ZW0gPSAkKGV2ZW50LnRhcmdldCk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghY3VycmVudEl0ZW0pIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5oYW5kbGUgJiYgIW92ZXJyaWRlSGFuZGxlKSB7XFxuICAgICAgICAkKHRoaXMub3B0aW9ucy5oYW5kbGUsIGN1cnJlbnRJdGVtKS5maW5kKFxcXCIqXFxcIikuYWRkQmFjaygpLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBpZiAodGhpcyA9PT0gZXZlbnQudGFyZ2V0KSB7XFxuICAgICAgICAgICAgdmFsaWRIYW5kbGUgPSB0cnVlO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG5cXG4gICAgICAgIGlmICghdmFsaWRIYW5kbGUpIHtcXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLmN1cnJlbnRJdGVtID0gY3VycmVudEl0ZW07XFxuXFxuICAgICAgdGhpcy5fcmVtb3ZlQ3VycmVudHNGcm9tSXRlbXMoKTtcXG5cXG4gICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgfSxcXG4gICAgX21vdXNlU3RhcnQ6IGZ1bmN0aW9uIF9tb3VzZVN0YXJ0KGV2ZW50LCBvdmVycmlkZUhhbmRsZSwgbm9BY3RpdmF0aW9uKSB7XFxuICAgICAgdmFyIGksXFxuICAgICAgICAgIGJvZHksXFxuICAgICAgICAgIG8gPSB0aGlzLm9wdGlvbnM7XFxuICAgICAgdGhpcy5jdXJyZW50Q29udGFpbmVyID0gdGhpczsgLy9XZSBvbmx5IG5lZWQgdG8gY2FsbCByZWZyZXNoUG9zaXRpb25zLCBiZWNhdXNlIHRoZSByZWZyZXNoSXRlbXMgY2FsbCBoYXMgYmVlbiBtb3ZlZCB0byBtb3VzZUNhcHR1cmVcXG5cXG4gICAgICB0aGlzLnJlZnJlc2hQb3NpdGlvbnMoKTsgLy9DcmVhdGUgYW5kIGFwcGVuZCB0aGUgdmlzaWJsZSBoZWxwZXJcXG5cXG4gICAgICB0aGlzLmhlbHBlciA9IHRoaXMuX2NyZWF0ZUhlbHBlcihldmVudCk7IC8vQ2FjaGUgdGhlIGhlbHBlciBzaXplXFxuXFxuICAgICAgdGhpcy5fY2FjaGVIZWxwZXJQcm9wb3J0aW9ucygpO1xcbiAgICAgIC8qXFxuICAgICAgICogLSBQb3NpdGlvbiBnZW5lcmF0aW9uIC1cXG4gICAgICAgKiBUaGlzIGJsb2NrIGdlbmVyYXRlcyBldmVyeXRoaW5nIHBvc2l0aW9uIHJlbGF0ZWQgLSBpdCdzIHRoZSBjb3JlIG9mIGRyYWdnYWJsZXMuXFxuICAgICAgICovXFxuICAgICAgLy9DYWNoZSB0aGUgbWFyZ2lucyBvZiB0aGUgb3JpZ2luYWwgZWxlbWVudFxcblxcblxcbiAgICAgIHRoaXMuX2NhY2hlTWFyZ2lucygpOyAvL0dldCB0aGUgbmV4dCBzY3JvbGxpbmcgcGFyZW50XFxuXFxuXFxuICAgICAgdGhpcy5zY3JvbGxQYXJlbnQgPSB0aGlzLmhlbHBlci5zY3JvbGxQYXJlbnQoKTsgLy9UaGUgZWxlbWVudCdzIGFic29sdXRlIHBvc2l0aW9uIG9uIHRoZSBwYWdlIG1pbnVzIG1hcmdpbnNcXG5cXG4gICAgICB0aGlzLm9mZnNldCA9IHRoaXMuY3VycmVudEl0ZW0ub2Zmc2V0KCk7XFxuICAgICAgdGhpcy5vZmZzZXQgPSB7XFxuICAgICAgICB0b3A6IHRoaXMub2Zmc2V0LnRvcCAtIHRoaXMubWFyZ2lucy50b3AsXFxuICAgICAgICBsZWZ0OiB0aGlzLm9mZnNldC5sZWZ0IC0gdGhpcy5tYXJnaW5zLmxlZnRcXG4gICAgICB9O1xcbiAgICAgICQuZXh0ZW5kKHRoaXMub2Zmc2V0LCB7XFxuICAgICAgICBjbGljazoge1xcbiAgICAgICAgICAvL1doZXJlIHRoZSBjbGljayBoYXBwZW5lZCwgcmVsYXRpdmUgdG8gdGhlIGVsZW1lbnRcXG4gICAgICAgICAgbGVmdDogZXZlbnQucGFnZVggLSB0aGlzLm9mZnNldC5sZWZ0LFxcbiAgICAgICAgICB0b3A6IGV2ZW50LnBhZ2VZIC0gdGhpcy5vZmZzZXQudG9wXFxuICAgICAgICB9LFxcbiAgICAgICAgcGFyZW50OiB0aGlzLl9nZXRQYXJlbnRPZmZzZXQoKSxcXG4gICAgICAgIHJlbGF0aXZlOiB0aGlzLl9nZXRSZWxhdGl2ZU9mZnNldCgpIC8vVGhpcyBpcyBhIHJlbGF0aXZlIHRvIGFic29sdXRlIHBvc2l0aW9uIG1pbnVzIHRoZSBhY3R1YWwgcG9zaXRpb24gY2FsY3VsYXRpb24gLSBvbmx5IHVzZWQgZm9yIHJlbGF0aXZlIHBvc2l0aW9uZWQgaGVscGVyXFxuXFxuICAgICAgfSk7IC8vIE9ubHkgYWZ0ZXIgd2UgZ290IHRoZSBvZmZzZXQsIHdlIGNhbiBjaGFuZ2UgdGhlIGhlbHBlcidzIHBvc2l0aW9uIHRvIGFic29sdXRlXFxuICAgICAgLy8gVE9ETzogU3RpbGwgbmVlZCB0byBmaWd1cmUgb3V0IGEgd2F5IHRvIG1ha2UgcmVsYXRpdmUgc29ydGluZyBwb3NzaWJsZVxcblxcbiAgICAgIHRoaXMuaGVscGVyLmNzcyhcXFwicG9zaXRpb25cXFwiLCBcXFwiYWJzb2x1dGVcXFwiKTtcXG4gICAgICB0aGlzLmNzc1Bvc2l0aW9uID0gdGhpcy5oZWxwZXIuY3NzKFxcXCJwb3NpdGlvblxcXCIpOyAvL0dlbmVyYXRlIHRoZSBvcmlnaW5hbCBwb3NpdGlvblxcblxcbiAgICAgIHRoaXMub3JpZ2luYWxQb3NpdGlvbiA9IHRoaXMuX2dlbmVyYXRlUG9zaXRpb24oZXZlbnQpO1xcbiAgICAgIHRoaXMub3JpZ2luYWxQYWdlWCA9IGV2ZW50LnBhZ2VYO1xcbiAgICAgIHRoaXMub3JpZ2luYWxQYWdlWSA9IGV2ZW50LnBhZ2VZOyAvL0FkanVzdCB0aGUgbW91c2Ugb2Zmc2V0IHJlbGF0aXZlIHRvIHRoZSBoZWxwZXIgaWYgXFxcImN1cnNvckF0XFxcIiBpcyBzdXBwbGllZFxcblxcbiAgICAgIG8uY3Vyc29yQXQgJiYgdGhpcy5fYWRqdXN0T2Zmc2V0RnJvbUhlbHBlcihvLmN1cnNvckF0KTsgLy9DYWNoZSB0aGUgZm9ybWVyIERPTSBwb3NpdGlvblxcblxcbiAgICAgIHRoaXMuZG9tUG9zaXRpb24gPSB7XFxuICAgICAgICBwcmV2OiB0aGlzLmN1cnJlbnRJdGVtLnByZXYoKVswXSxcXG4gICAgICAgIHBhcmVudDogdGhpcy5jdXJyZW50SXRlbS5wYXJlbnQoKVswXVxcbiAgICAgIH07IC8vSWYgdGhlIGhlbHBlciBpcyBub3QgdGhlIG9yaWdpbmFsLCBoaWRlIHRoZSBvcmlnaW5hbCBzbyBpdCdzIG5vdCBwbGF5aW5nIGFueSByb2xlIGR1cmluZyB0aGUgZHJhZywgd29uJ3QgY2F1c2UgYW55dGhpbmcgYmFkIHRoaXMgd2F5XFxuXFxuICAgICAgaWYgKHRoaXMuaGVscGVyWzBdICE9PSB0aGlzLmN1cnJlbnRJdGVtWzBdKSB7XFxuICAgICAgICB0aGlzLmN1cnJlbnRJdGVtLmhpZGUoKTtcXG4gICAgICB9IC8vQ3JlYXRlIHRoZSBwbGFjZWhvbGRlclxcblxcblxcbiAgICAgIHRoaXMuX2NyZWF0ZVBsYWNlaG9sZGVyKCk7IC8vU2V0IGEgY29udGFpbm1lbnQgaWYgZ2l2ZW4gaW4gdGhlIG9wdGlvbnNcXG5cXG5cXG4gICAgICBpZiAoby5jb250YWlubWVudCkge1xcbiAgICAgICAgdGhpcy5fc2V0Q29udGFpbm1lbnQoKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKG8uY3Vyc29yICYmIG8uY3Vyc29yICE9PSBcXFwiYXV0b1xcXCIpIHtcXG4gICAgICAgIC8vIGN1cnNvciBvcHRpb25cXG4gICAgICAgIGJvZHkgPSB0aGlzLmRvY3VtZW50LmZpbmQoXFxcImJvZHlcXFwiKTsgLy8gc3VwcG9ydDogSUVcXG5cXG4gICAgICAgIHRoaXMuc3RvcmVkQ3Vyc29yID0gYm9keS5jc3MoXFxcImN1cnNvclxcXCIpO1xcbiAgICAgICAgYm9keS5jc3MoXFxcImN1cnNvclxcXCIsIG8uY3Vyc29yKTtcXG4gICAgICAgIHRoaXMuc3RvcmVkU3R5bGVzaGVldCA9ICQoXFxcIjxzdHlsZT4qeyBjdXJzb3I6IFxcXCIgKyBvLmN1cnNvciArIFxcXCIgIWltcG9ydGFudDsgfTwvc3R5bGU+XFxcIikuYXBwZW5kVG8oYm9keSk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChvLm9wYWNpdHkpIHtcXG4gICAgICAgIC8vIG9wYWNpdHkgb3B0aW9uXFxuICAgICAgICBpZiAodGhpcy5oZWxwZXIuY3NzKFxcXCJvcGFjaXR5XFxcIikpIHtcXG4gICAgICAgICAgdGhpcy5fc3RvcmVkT3BhY2l0eSA9IHRoaXMuaGVscGVyLmNzcyhcXFwib3BhY2l0eVxcXCIpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdGhpcy5oZWxwZXIuY3NzKFxcXCJvcGFjaXR5XFxcIiwgby5vcGFjaXR5KTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKG8uekluZGV4KSB7XFxuICAgICAgICAvLyB6SW5kZXggb3B0aW9uXFxuICAgICAgICBpZiAodGhpcy5oZWxwZXIuY3NzKFxcXCJ6SW5kZXhcXFwiKSkge1xcbiAgICAgICAgICB0aGlzLl9zdG9yZWRaSW5kZXggPSB0aGlzLmhlbHBlci5jc3MoXFxcInpJbmRleFxcXCIpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdGhpcy5oZWxwZXIuY3NzKFxcXCJ6SW5kZXhcXFwiLCBvLnpJbmRleCk7XFxuICAgICAgfSAvL1ByZXBhcmUgc2Nyb2xsaW5nXFxuXFxuXFxuICAgICAgaWYgKHRoaXMuc2Nyb2xsUGFyZW50WzBdICE9PSB0aGlzLmRvY3VtZW50WzBdICYmIHRoaXMuc2Nyb2xsUGFyZW50WzBdLnRhZ05hbWUgIT09IFxcXCJIVE1MXFxcIikge1xcbiAgICAgICAgdGhpcy5vdmVyZmxvd09mZnNldCA9IHRoaXMuc2Nyb2xsUGFyZW50Lm9mZnNldCgpO1xcbiAgICAgIH0gLy9DYWxsIGNhbGxiYWNrc1xcblxcblxcbiAgICAgIHRoaXMuX3RyaWdnZXIoXFxcInN0YXJ0XFxcIiwgZXZlbnQsIHRoaXMuX3VpSGFzaCgpKTsgLy9SZWNhY2hlIHRoZSBoZWxwZXIgc2l6ZVxcblxcblxcbiAgICAgIGlmICghdGhpcy5fcHJlc2VydmVIZWxwZXJQcm9wb3J0aW9ucykge1xcbiAgICAgICAgdGhpcy5fY2FjaGVIZWxwZXJQcm9wb3J0aW9ucygpO1xcbiAgICAgIH0gLy9Qb3N0IFxcXCJhY3RpdmF0ZVxcXCIgZXZlbnRzIHRvIHBvc3NpYmxlIGNvbnRhaW5lcnNcXG5cXG5cXG4gICAgICBpZiAoIW5vQWN0aXZhdGlvbikge1xcbiAgICAgICAgZm9yIChpID0gdGhpcy5jb250YWluZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XFxuICAgICAgICAgIHRoaXMuY29udGFpbmVyc1tpXS5fdHJpZ2dlcihcXFwiYWN0aXZhdGVcXFwiLCBldmVudCwgdGhpcy5fdWlIYXNoKHRoaXMpKTtcXG4gICAgICAgIH1cXG4gICAgICB9IC8vUHJlcGFyZSBwb3NzaWJsZSBkcm9wcGFibGVzXFxuXFxuXFxuICAgICAgaWYgKCQudWkuZGRtYW5hZ2VyKSB7XFxuICAgICAgICAkLnVpLmRkbWFuYWdlci5jdXJyZW50ID0gdGhpcztcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCQudWkuZGRtYW5hZ2VyICYmICFvLmRyb3BCZWhhdmlvdXIpIHtcXG4gICAgICAgICQudWkuZGRtYW5hZ2VyLnByZXBhcmVPZmZzZXRzKHRoaXMsIGV2ZW50KTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5kcmFnZ2luZyA9IHRydWU7XFxuICAgICAgdGhpcy5oZWxwZXIuYWRkQ2xhc3MoXFxcInVpLXNvcnRhYmxlLWhlbHBlclxcXCIpO1xcblxcbiAgICAgIHRoaXMuX21vdXNlRHJhZyhldmVudCk7IC8vRXhlY3V0ZSB0aGUgZHJhZyBvbmNlIC0gdGhpcyBjYXVzZXMgdGhlIGhlbHBlciBub3QgdG8gYmUgdmlzaWJsZSBiZWZvcmUgZ2V0dGluZyBpdHMgY29ycmVjdCBwb3NpdGlvblxcblxcblxcbiAgICAgIHJldHVybiB0cnVlO1xcbiAgICB9LFxcbiAgICBfbW91c2VEcmFnOiBmdW5jdGlvbiBfbW91c2VEcmFnKGV2ZW50KSB7XFxuICAgICAgdmFyIGksXFxuICAgICAgICAgIGl0ZW0sXFxuICAgICAgICAgIGl0ZW1FbGVtZW50LFxcbiAgICAgICAgICBpbnRlcnNlY3Rpb24sXFxuICAgICAgICAgIG8gPSB0aGlzLm9wdGlvbnMsXFxuICAgICAgICAgIHNjcm9sbGVkID0gZmFsc2U7IC8vQ29tcHV0ZSB0aGUgaGVscGVycyBwb3NpdGlvblxcblxcbiAgICAgIHRoaXMucG9zaXRpb24gPSB0aGlzLl9nZW5lcmF0ZVBvc2l0aW9uKGV2ZW50KTtcXG4gICAgICB0aGlzLnBvc2l0aW9uQWJzID0gdGhpcy5fY29udmVydFBvc2l0aW9uVG8oXFxcImFic29sdXRlXFxcIik7XFxuXFxuICAgICAgaWYgKCF0aGlzLmxhc3RQb3NpdGlvbkFicykge1xcbiAgICAgICAgdGhpcy5sYXN0UG9zaXRpb25BYnMgPSB0aGlzLnBvc2l0aW9uQWJzO1xcbiAgICAgIH0gLy9EbyBzY3JvbGxpbmdcXG5cXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnNjcm9sbCkge1xcbiAgICAgICAgaWYgKHRoaXMuc2Nyb2xsUGFyZW50WzBdICE9PSB0aGlzLmRvY3VtZW50WzBdICYmIHRoaXMuc2Nyb2xsUGFyZW50WzBdLnRhZ05hbWUgIT09IFxcXCJIVE1MXFxcIikge1xcbiAgICAgICAgICBpZiAodGhpcy5vdmVyZmxvd09mZnNldC50b3AgKyB0aGlzLnNjcm9sbFBhcmVudFswXS5vZmZzZXRIZWlnaHQgLSBldmVudC5wYWdlWSA8IG8uc2Nyb2xsU2Vuc2l0aXZpdHkpIHtcXG4gICAgICAgICAgICB0aGlzLnNjcm9sbFBhcmVudFswXS5zY3JvbGxUb3AgPSBzY3JvbGxlZCA9IHRoaXMuc2Nyb2xsUGFyZW50WzBdLnNjcm9sbFRvcCArIG8uc2Nyb2xsU3BlZWQ7XFxuICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQucGFnZVkgLSB0aGlzLm92ZXJmbG93T2Zmc2V0LnRvcCA8IG8uc2Nyb2xsU2Vuc2l0aXZpdHkpIHtcXG4gICAgICAgICAgICB0aGlzLnNjcm9sbFBhcmVudFswXS5zY3JvbGxUb3AgPSBzY3JvbGxlZCA9IHRoaXMuc2Nyb2xsUGFyZW50WzBdLnNjcm9sbFRvcCAtIG8uc2Nyb2xsU3BlZWQ7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaWYgKHRoaXMub3ZlcmZsb3dPZmZzZXQubGVmdCArIHRoaXMuc2Nyb2xsUGFyZW50WzBdLm9mZnNldFdpZHRoIC0gZXZlbnQucGFnZVggPCBvLnNjcm9sbFNlbnNpdGl2aXR5KSB7XFxuICAgICAgICAgICAgdGhpcy5zY3JvbGxQYXJlbnRbMF0uc2Nyb2xsTGVmdCA9IHNjcm9sbGVkID0gdGhpcy5zY3JvbGxQYXJlbnRbMF0uc2Nyb2xsTGVmdCArIG8uc2Nyb2xsU3BlZWQ7XFxuICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQucGFnZVggLSB0aGlzLm92ZXJmbG93T2Zmc2V0LmxlZnQgPCBvLnNjcm9sbFNlbnNpdGl2aXR5KSB7XFxuICAgICAgICAgICAgdGhpcy5zY3JvbGxQYXJlbnRbMF0uc2Nyb2xsTGVmdCA9IHNjcm9sbGVkID0gdGhpcy5zY3JvbGxQYXJlbnRbMF0uc2Nyb2xsTGVmdCAtIG8uc2Nyb2xsU3BlZWQ7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGlmIChldmVudC5wYWdlWSAtIHRoaXMuZG9jdW1lbnQuc2Nyb2xsVG9wKCkgPCBvLnNjcm9sbFNlbnNpdGl2aXR5KSB7XFxuICAgICAgICAgICAgc2Nyb2xsZWQgPSB0aGlzLmRvY3VtZW50LnNjcm9sbFRvcCh0aGlzLmRvY3VtZW50LnNjcm9sbFRvcCgpIC0gby5zY3JvbGxTcGVlZCk7XFxuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy53aW5kb3cuaGVpZ2h0KCkgLSAoZXZlbnQucGFnZVkgLSB0aGlzLmRvY3VtZW50LnNjcm9sbFRvcCgpKSA8IG8uc2Nyb2xsU2Vuc2l0aXZpdHkpIHtcXG4gICAgICAgICAgICBzY3JvbGxlZCA9IHRoaXMuZG9jdW1lbnQuc2Nyb2xsVG9wKHRoaXMuZG9jdW1lbnQuc2Nyb2xsVG9wKCkgKyBvLnNjcm9sbFNwZWVkKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAoZXZlbnQucGFnZVggLSB0aGlzLmRvY3VtZW50LnNjcm9sbExlZnQoKSA8IG8uc2Nyb2xsU2Vuc2l0aXZpdHkpIHtcXG4gICAgICAgICAgICBzY3JvbGxlZCA9IHRoaXMuZG9jdW1lbnQuc2Nyb2xsTGVmdCh0aGlzLmRvY3VtZW50LnNjcm9sbExlZnQoKSAtIG8uc2Nyb2xsU3BlZWQpO1xcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMud2luZG93LndpZHRoKCkgLSAoZXZlbnQucGFnZVggLSB0aGlzLmRvY3VtZW50LnNjcm9sbExlZnQoKSkgPCBvLnNjcm9sbFNlbnNpdGl2aXR5KSB7XFxuICAgICAgICAgICAgc2Nyb2xsZWQgPSB0aGlzLmRvY3VtZW50LnNjcm9sbExlZnQodGhpcy5kb2N1bWVudC5zY3JvbGxMZWZ0KCkgKyBvLnNjcm9sbFNwZWVkKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKHNjcm9sbGVkICE9PSBmYWxzZSAmJiAkLnVpLmRkbWFuYWdlciAmJiAhby5kcm9wQmVoYXZpb3VyKSB7XFxuICAgICAgICAgICQudWkuZGRtYW5hZ2VyLnByZXBhcmVPZmZzZXRzKHRoaXMsIGV2ZW50KTtcXG4gICAgICAgIH1cXG4gICAgICB9IC8vUmVnZW5lcmF0ZSB0aGUgYWJzb2x1dGUgcG9zaXRpb24gdXNlZCBmb3IgcG9zaXRpb24gY2hlY2tzXFxuXFxuXFxuICAgICAgdGhpcy5wb3NpdGlvbkFicyA9IHRoaXMuX2NvbnZlcnRQb3NpdGlvblRvKFxcXCJhYnNvbHV0ZVxcXCIpOyAvL1NldCB0aGUgaGVscGVyIHBvc2l0aW9uXFxuXFxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuYXhpcyB8fCB0aGlzLm9wdGlvbnMuYXhpcyAhPT0gXFxcInlcXFwiKSB7XFxuICAgICAgICB0aGlzLmhlbHBlclswXS5zdHlsZS5sZWZ0ID0gdGhpcy5wb3NpdGlvbi5sZWZ0ICsgXFxcInB4XFxcIjtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuYXhpcyB8fCB0aGlzLm9wdGlvbnMuYXhpcyAhPT0gXFxcInhcXFwiKSB7XFxuICAgICAgICB0aGlzLmhlbHBlclswXS5zdHlsZS50b3AgPSB0aGlzLnBvc2l0aW9uLnRvcCArIFxcXCJweFxcXCI7XFxuICAgICAgfSAvL1JlYXJyYW5nZVxcblxcblxcbiAgICAgIGZvciAoaSA9IHRoaXMuaXRlbXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcXG4gICAgICAgIC8vQ2FjaGUgdmFyaWFibGVzIGFuZCBpbnRlcnNlY3Rpb24sIGNvbnRpbnVlIGlmIG5vIGludGVyc2VjdGlvblxcbiAgICAgICAgaXRlbSA9IHRoaXMuaXRlbXNbaV07XFxuICAgICAgICBpdGVtRWxlbWVudCA9IGl0ZW0uaXRlbVswXTtcXG4gICAgICAgIGludGVyc2VjdGlvbiA9IHRoaXMuX2ludGVyc2VjdHNXaXRoUG9pbnRlcihpdGVtKTtcXG5cXG4gICAgICAgIGlmICghaW50ZXJzZWN0aW9uKSB7XFxuICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgfSAvLyBPbmx5IHB1dCB0aGUgcGxhY2Vob2xkZXIgaW5zaWRlIHRoZSBjdXJyZW50IENvbnRhaW5lciwgc2tpcCBhbGxcXG4gICAgICAgIC8vIGl0ZW1zIGZyb20gb3RoZXIgY29udGFpbmVycy4gVGhpcyB3b3JrcyBiZWNhdXNlIHdoZW4gbW92aW5nXFxuICAgICAgICAvLyBhbiBpdGVtIGZyb20gb25lIGNvbnRhaW5lciB0byBhbm90aGVyIHRoZVxcbiAgICAgICAgLy8gY3VycmVudENvbnRhaW5lciBpcyBzd2l0Y2hlZCBiZWZvcmUgdGhlIHBsYWNlaG9sZGVyIGlzIG1vdmVkLlxcbiAgICAgICAgLy9cXG4gICAgICAgIC8vIFdpdGhvdXQgdGhpcywgbW92aW5nIGl0ZW1zIGluIFxcXCJzdWItc29ydGFibGVzXFxcIiBjYW4gY2F1c2VcXG4gICAgICAgIC8vIHRoZSBwbGFjZWhvbGRlciB0byBqaXR0ZXIgYmV0d2VlbiB0aGUgb3V0ZXIgYW5kIGlubmVyIGNvbnRhaW5lci5cXG5cXG5cXG4gICAgICAgIGlmIChpdGVtLmluc3RhbmNlICE9PSB0aGlzLmN1cnJlbnRDb250YWluZXIpIHtcXG4gICAgICAgICAgY29udGludWU7XFxuICAgICAgICB9IC8vIGNhbm5vdCBpbnRlcnNlY3Qgd2l0aCBpdHNlbGZcXG4gICAgICAgIC8vIG5vIHVzZWxlc3MgYWN0aW9ucyB0aGF0IGhhdmUgYmVlbiBkb25lIGJlZm9yZVxcbiAgICAgICAgLy8gbm8gYWN0aW9uIGlmIHRoZSBpdGVtIG1vdmVkIGlzIHRoZSBwYXJlbnQgb2YgdGhlIGl0ZW0gY2hlY2tlZFxcblxcblxcbiAgICAgICAgaWYgKGl0ZW1FbGVtZW50ICE9PSB0aGlzLmN1cnJlbnRJdGVtWzBdICYmIHRoaXMucGxhY2Vob2xkZXJbaW50ZXJzZWN0aW9uID09PSAxID8gXFxcIm5leHRcXFwiIDogXFxcInByZXZcXFwiXSgpWzBdICE9PSBpdGVtRWxlbWVudCAmJiAhJC5jb250YWlucyh0aGlzLnBsYWNlaG9sZGVyWzBdLCBpdGVtRWxlbWVudCkgJiYgKHRoaXMub3B0aW9ucy50eXBlID09PSBcXFwic2VtaS1keW5hbWljXFxcIiA/ICEkLmNvbnRhaW5zKHRoaXMuZWxlbWVudFswXSwgaXRlbUVsZW1lbnQpIDogdHJ1ZSkpIHtcXG4gICAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSBpbnRlcnNlY3Rpb24gPT09IDEgPyBcXFwiZG93blxcXCIgOiBcXFwidXBcXFwiO1xcblxcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRvbGVyYW5jZSA9PT0gXFxcInBvaW50ZXJcXFwiIHx8IHRoaXMuX2ludGVyc2VjdHNXaXRoU2lkZXMoaXRlbSkpIHtcXG4gICAgICAgICAgICB0aGlzLl9yZWFycmFuZ2UoZXZlbnQsIGl0ZW0pO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHRoaXMuX3RyaWdnZXIoXFxcImNoYW5nZVxcXCIsIGV2ZW50LCB0aGlzLl91aUhhc2goKSk7XFxuXFxuICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgfVxcbiAgICAgIH0gLy9Qb3N0IGV2ZW50cyB0byBjb250YWluZXJzXFxuXFxuXFxuICAgICAgdGhpcy5fY29udGFjdENvbnRhaW5lcnMoZXZlbnQpOyAvL0ludGVyY29ubmVjdCB3aXRoIGRyb3BwYWJsZXNcXG5cXG5cXG4gICAgICBpZiAoJC51aS5kZG1hbmFnZXIpIHtcXG4gICAgICAgICQudWkuZGRtYW5hZ2VyLmRyYWcodGhpcywgZXZlbnQpO1xcbiAgICAgIH0gLy9DYWxsIGNhbGxiYWNrc1xcblxcblxcbiAgICAgIHRoaXMuX3RyaWdnZXIoXFxcInNvcnRcXFwiLCBldmVudCwgdGhpcy5fdWlIYXNoKCkpO1xcblxcbiAgICAgIHRoaXMubGFzdFBvc2l0aW9uQWJzID0gdGhpcy5wb3NpdGlvbkFicztcXG4gICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH0sXFxuICAgIF9tb3VzZVN0b3A6IGZ1bmN0aW9uIF9tb3VzZVN0b3AoZXZlbnQsIG5vUHJvcGFnYXRpb24pIHtcXG4gICAgICBpZiAoIWV2ZW50KSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfSAvL0lmIHdlIGFyZSB1c2luZyBkcm9wcGFibGVzLCBpbmZvcm0gdGhlIG1hbmFnZXIgYWJvdXQgdGhlIGRyb3BcXG5cXG5cXG4gICAgICBpZiAoJC51aS5kZG1hbmFnZXIgJiYgIXRoaXMub3B0aW9ucy5kcm9wQmVoYXZpb3VyKSB7XFxuICAgICAgICAkLnVpLmRkbWFuYWdlci5kcm9wKHRoaXMsIGV2ZW50KTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZXZlcnQpIHtcXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcyxcXG4gICAgICAgICAgICBjdXIgPSB0aGlzLnBsYWNlaG9sZGVyLm9mZnNldCgpLFxcbiAgICAgICAgICAgIGF4aXMgPSB0aGlzLm9wdGlvbnMuYXhpcyxcXG4gICAgICAgICAgICBhbmltYXRpb24gPSB7fTtcXG5cXG4gICAgICAgIGlmICghYXhpcyB8fCBheGlzID09PSBcXFwieFxcXCIpIHtcXG4gICAgICAgICAgYW5pbWF0aW9uLmxlZnQgPSBjdXIubGVmdCAtIHRoaXMub2Zmc2V0LnBhcmVudC5sZWZ0IC0gdGhpcy5tYXJnaW5zLmxlZnQgKyAodGhpcy5vZmZzZXRQYXJlbnRbMF0gPT09IHRoaXMuZG9jdW1lbnRbMF0uYm9keSA/IDAgOiB0aGlzLm9mZnNldFBhcmVudFswXS5zY3JvbGxMZWZ0KTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICghYXhpcyB8fCBheGlzID09PSBcXFwieVxcXCIpIHtcXG4gICAgICAgICAgYW5pbWF0aW9uLnRvcCA9IGN1ci50b3AgLSB0aGlzLm9mZnNldC5wYXJlbnQudG9wIC0gdGhpcy5tYXJnaW5zLnRvcCArICh0aGlzLm9mZnNldFBhcmVudFswXSA9PT0gdGhpcy5kb2N1bWVudFswXS5ib2R5ID8gMCA6IHRoaXMub2Zmc2V0UGFyZW50WzBdLnNjcm9sbFRvcCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0aGlzLnJldmVydGluZyA9IHRydWU7XFxuICAgICAgICAkKHRoaXMuaGVscGVyKS5hbmltYXRlKGFuaW1hdGlvbiwgcGFyc2VJbnQodGhpcy5vcHRpb25zLnJldmVydCwgMTApIHx8IDUwMCwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICB0aGF0Ll9jbGVhcihldmVudCk7XFxuICAgICAgICB9KTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdGhpcy5fY2xlYXIoZXZlbnQsIG5vUHJvcGFnYXRpb24pO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH0sXFxuICAgIGNhbmNlbDogZnVuY3Rpb24gY2FuY2VsKCkge1xcbiAgICAgIGlmICh0aGlzLmRyYWdnaW5nKSB7XFxuICAgICAgICB0aGlzLl9tb3VzZVVwKHtcXG4gICAgICAgICAgdGFyZ2V0OiBudWxsXFxuICAgICAgICB9KTtcXG5cXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGVscGVyID09PSBcXFwib3JpZ2luYWxcXFwiKSB7XFxuICAgICAgICAgIHRoaXMuY3VycmVudEl0ZW0uY3NzKHRoaXMuX3N0b3JlZENTUykucmVtb3ZlQ2xhc3MoXFxcInVpLXNvcnRhYmxlLWhlbHBlclxcXCIpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgdGhpcy5jdXJyZW50SXRlbS5zaG93KCk7XFxuICAgICAgICB9IC8vUG9zdCBkZWFjdGl2YXRpbmcgZXZlbnRzIHRvIGNvbnRhaW5lcnNcXG5cXG5cXG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLmNvbnRhaW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcXG4gICAgICAgICAgdGhpcy5jb250YWluZXJzW2ldLl90cmlnZ2VyKFxcXCJkZWFjdGl2YXRlXFxcIiwgbnVsbCwgdGhpcy5fdWlIYXNoKHRoaXMpKTtcXG5cXG4gICAgICAgICAgaWYgKHRoaXMuY29udGFpbmVyc1tpXS5jb250YWluZXJDYWNoZS5vdmVyKSB7XFxuICAgICAgICAgICAgdGhpcy5jb250YWluZXJzW2ldLl90cmlnZ2VyKFxcXCJvdXRcXFwiLCBudWxsLCB0aGlzLl91aUhhc2godGhpcykpO1xcblxcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyc1tpXS5jb250YWluZXJDYWNoZS5vdmVyID0gMDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5wbGFjZWhvbGRlcikge1xcbiAgICAgICAgLy8kKHRoaXMucGxhY2Vob2xkZXJbMF0pLnJlbW92ZSgpOyB3b3VsZCBoYXZlIGJlZW4gdGhlIGpRdWVyeSB3YXkgLSB1bmZvcnR1bmF0ZWx5LCBpdCB1bmJpbmRzIEFMTCBldmVudHMgZnJvbSB0aGUgb3JpZ2luYWwgbm9kZSFcXG4gICAgICAgIGlmICh0aGlzLnBsYWNlaG9sZGVyWzBdLnBhcmVudE5vZGUpIHtcXG4gICAgICAgICAgdGhpcy5wbGFjZWhvbGRlclswXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMucGxhY2Vob2xkZXJbMF0pO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5oZWxwZXIgIT09IFxcXCJvcmlnaW5hbFxcXCIgJiYgdGhpcy5oZWxwZXIgJiYgdGhpcy5oZWxwZXJbMF0ucGFyZW50Tm9kZSkge1xcbiAgICAgICAgICB0aGlzLmhlbHBlci5yZW1vdmUoKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgICQuZXh0ZW5kKHRoaXMsIHtcXG4gICAgICAgICAgaGVscGVyOiBudWxsLFxcbiAgICAgICAgICBkcmFnZ2luZzogZmFsc2UsXFxuICAgICAgICAgIHJldmVydGluZzogZmFsc2UsXFxuICAgICAgICAgIF9ub0ZpbmFsU29ydDogbnVsbFxcbiAgICAgICAgfSk7XFxuXFxuICAgICAgICBpZiAodGhpcy5kb21Qb3NpdGlvbi5wcmV2KSB7XFxuICAgICAgICAgICQodGhpcy5kb21Qb3NpdGlvbi5wcmV2KS5hZnRlcih0aGlzLmN1cnJlbnRJdGVtKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICQodGhpcy5kb21Qb3NpdGlvbi5wYXJlbnQpLnByZXBlbmQodGhpcy5jdXJyZW50SXRlbSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiB0aGlzO1xcbiAgICB9LFxcbiAgICBzZXJpYWxpemU6IGZ1bmN0aW9uIHNlcmlhbGl6ZShvKSB7XFxuICAgICAgdmFyIGl0ZW1zID0gdGhpcy5fZ2V0SXRlbXNBc2pRdWVyeShvICYmIG8uY29ubmVjdGVkKSxcXG4gICAgICAgICAgc3RyID0gW107XFxuXFxuICAgICAgbyA9IG8gfHwge307XFxuICAgICAgJChpdGVtcykuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgcmVzID0gKCQoby5pdGVtIHx8IHRoaXMpLmF0dHIoby5hdHRyaWJ1dGUgfHwgXFxcImlkXFxcIikgfHwgXFxcIlxcXCIpLm1hdGNoKG8uZXhwcmVzc2lvbiB8fCAvKC4rKVtcXFxcLT1fXSguKykvKTtcXG5cXG4gICAgICAgIGlmIChyZXMpIHtcXG4gICAgICAgICAgc3RyLnB1c2goKG8ua2V5IHx8IHJlc1sxXSArIFxcXCJbXVxcXCIpICsgXFxcIj1cXFwiICsgKG8ua2V5ICYmIG8uZXhwcmVzc2lvbiA/IHJlc1sxXSA6IHJlc1syXSkpO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcblxcbiAgICAgIGlmICghc3RyLmxlbmd0aCAmJiBvLmtleSkge1xcbiAgICAgICAgc3RyLnB1c2goby5rZXkgKyBcXFwiPVxcXCIpO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gc3RyLmpvaW4oXFxcIiZcXFwiKTtcXG4gICAgfSxcXG4gICAgdG9BcnJheTogZnVuY3Rpb24gdG9BcnJheShvKSB7XFxuICAgICAgdmFyIGl0ZW1zID0gdGhpcy5fZ2V0SXRlbXNBc2pRdWVyeShvICYmIG8uY29ubmVjdGVkKSxcXG4gICAgICAgICAgcmV0ID0gW107XFxuXFxuICAgICAgbyA9IG8gfHwge307XFxuICAgICAgaXRlbXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICByZXQucHVzaCgkKG8uaXRlbSB8fCB0aGlzKS5hdHRyKG8uYXR0cmlidXRlIHx8IFxcXCJpZFxcXCIpIHx8IFxcXCJcXFwiKTtcXG4gICAgICB9KTtcXG4gICAgICByZXR1cm4gcmV0O1xcbiAgICB9LFxcblxcbiAgICAvKiBCZSBjYXJlZnVsIHdpdGggdGhlIGZvbGxvd2luZyBjb3JlIGZ1bmN0aW9ucyAqL1xcbiAgICBfaW50ZXJzZWN0c1dpdGg6IGZ1bmN0aW9uIF9pbnRlcnNlY3RzV2l0aChpdGVtKSB7XFxuICAgICAgdmFyIHgxID0gdGhpcy5wb3NpdGlvbkFicy5sZWZ0LFxcbiAgICAgICAgICB4MiA9IHgxICsgdGhpcy5oZWxwZXJQcm9wb3J0aW9ucy53aWR0aCxcXG4gICAgICAgICAgeTEgPSB0aGlzLnBvc2l0aW9uQWJzLnRvcCxcXG4gICAgICAgICAgeTIgPSB5MSArIHRoaXMuaGVscGVyUHJvcG9ydGlvbnMuaGVpZ2h0LFxcbiAgICAgICAgICBsID0gaXRlbS5sZWZ0LFxcbiAgICAgICAgICByID0gbCArIGl0ZW0ud2lkdGgsXFxuICAgICAgICAgIHQgPSBpdGVtLnRvcCxcXG4gICAgICAgICAgYiA9IHQgKyBpdGVtLmhlaWdodCxcXG4gICAgICAgICAgZHlDbGljayA9IHRoaXMub2Zmc2V0LmNsaWNrLnRvcCxcXG4gICAgICAgICAgZHhDbGljayA9IHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQsXFxuICAgICAgICAgIGlzT3ZlckVsZW1lbnRIZWlnaHQgPSB0aGlzLm9wdGlvbnMuYXhpcyA9PT0gXFxcInhcXFwiIHx8IHkxICsgZHlDbGljayA+IHQgJiYgeTEgKyBkeUNsaWNrIDwgYixcXG4gICAgICAgICAgaXNPdmVyRWxlbWVudFdpZHRoID0gdGhpcy5vcHRpb25zLmF4aXMgPT09IFxcXCJ5XFxcIiB8fCB4MSArIGR4Q2xpY2sgPiBsICYmIHgxICsgZHhDbGljayA8IHIsXFxuICAgICAgICAgIGlzT3ZlckVsZW1lbnQgPSBpc092ZXJFbGVtZW50SGVpZ2h0ICYmIGlzT3ZlckVsZW1lbnRXaWR0aDtcXG5cXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnRvbGVyYW5jZSA9PT0gXFxcInBvaW50ZXJcXFwiIHx8IHRoaXMub3B0aW9ucy5mb3JjZVBvaW50ZXJGb3JDb250YWluZXJzIHx8IHRoaXMub3B0aW9ucy50b2xlcmFuY2UgIT09IFxcXCJwb2ludGVyXFxcIiAmJiB0aGlzLmhlbHBlclByb3BvcnRpb25zW3RoaXMuZmxvYXRpbmcgPyBcXFwid2lkdGhcXFwiIDogXFxcImhlaWdodFxcXCJdID4gaXRlbVt0aGlzLmZsb2F0aW5nID8gXFxcIndpZHRoXFxcIiA6IFxcXCJoZWlnaHRcXFwiXSkge1xcbiAgICAgICAgcmV0dXJuIGlzT3ZlckVsZW1lbnQ7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHJldHVybiBsIDwgeDEgKyB0aGlzLmhlbHBlclByb3BvcnRpb25zLndpZHRoIC8gMiAmJiAvLyBSaWdodCBIYWxmXFxuICAgICAgICB4MiAtIHRoaXMuaGVscGVyUHJvcG9ydGlvbnMud2lkdGggLyAyIDwgciAmJiAvLyBMZWZ0IEhhbGZcXG4gICAgICAgIHQgPCB5MSArIHRoaXMuaGVscGVyUHJvcG9ydGlvbnMuaGVpZ2h0IC8gMiAmJiAvLyBCb3R0b20gSGFsZlxcbiAgICAgICAgeTIgLSB0aGlzLmhlbHBlclByb3BvcnRpb25zLmhlaWdodCAvIDIgPCBiOyAvLyBUb3AgSGFsZlxcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgX2ludGVyc2VjdHNXaXRoUG9pbnRlcjogZnVuY3Rpb24gX2ludGVyc2VjdHNXaXRoUG9pbnRlcihpdGVtKSB7XFxuICAgICAgdmFyIGlzT3ZlckVsZW1lbnRIZWlnaHQgPSB0aGlzLm9wdGlvbnMuYXhpcyA9PT0gXFxcInhcXFwiIHx8IHRoaXMuX2lzT3ZlckF4aXModGhpcy5wb3NpdGlvbkFicy50b3AgKyB0aGlzLm9mZnNldC5jbGljay50b3AsIGl0ZW0udG9wLCBpdGVtLmhlaWdodCksXFxuICAgICAgICAgIGlzT3ZlckVsZW1lbnRXaWR0aCA9IHRoaXMub3B0aW9ucy5heGlzID09PSBcXFwieVxcXCIgfHwgdGhpcy5faXNPdmVyQXhpcyh0aGlzLnBvc2l0aW9uQWJzLmxlZnQgKyB0aGlzLm9mZnNldC5jbGljay5sZWZ0LCBpdGVtLmxlZnQsIGl0ZW0ud2lkdGgpLFxcbiAgICAgICAgICBpc092ZXJFbGVtZW50ID0gaXNPdmVyRWxlbWVudEhlaWdodCAmJiBpc092ZXJFbGVtZW50V2lkdGgsXFxuICAgICAgICAgIHZlcnRpY2FsRGlyZWN0aW9uID0gdGhpcy5fZ2V0RHJhZ1ZlcnRpY2FsRGlyZWN0aW9uKCksXFxuICAgICAgICAgIGhvcml6b250YWxEaXJlY3Rpb24gPSB0aGlzLl9nZXREcmFnSG9yaXpvbnRhbERpcmVjdGlvbigpO1xcblxcbiAgICAgIGlmICghaXNPdmVyRWxlbWVudCkge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gdGhpcy5mbG9hdGluZyA/IGhvcml6b250YWxEaXJlY3Rpb24gJiYgaG9yaXpvbnRhbERpcmVjdGlvbiA9PT0gXFxcInJpZ2h0XFxcIiB8fCB2ZXJ0aWNhbERpcmVjdGlvbiA9PT0gXFxcImRvd25cXFwiID8gMiA6IDEgOiB2ZXJ0aWNhbERpcmVjdGlvbiAmJiAodmVydGljYWxEaXJlY3Rpb24gPT09IFxcXCJkb3duXFxcIiA/IDIgOiAxKTtcXG4gICAgfSxcXG4gICAgX2ludGVyc2VjdHNXaXRoU2lkZXM6IGZ1bmN0aW9uIF9pbnRlcnNlY3RzV2l0aFNpZGVzKGl0ZW0pIHtcXG4gICAgICB2YXIgaXNPdmVyQm90dG9tSGFsZiA9IHRoaXMuX2lzT3ZlckF4aXModGhpcy5wb3NpdGlvbkFicy50b3AgKyB0aGlzLm9mZnNldC5jbGljay50b3AsIGl0ZW0udG9wICsgaXRlbS5oZWlnaHQgLyAyLCBpdGVtLmhlaWdodCksXFxuICAgICAgICAgIGlzT3ZlclJpZ2h0SGFsZiA9IHRoaXMuX2lzT3ZlckF4aXModGhpcy5wb3NpdGlvbkFicy5sZWZ0ICsgdGhpcy5vZmZzZXQuY2xpY2subGVmdCwgaXRlbS5sZWZ0ICsgaXRlbS53aWR0aCAvIDIsIGl0ZW0ud2lkdGgpLFxcbiAgICAgICAgICB2ZXJ0aWNhbERpcmVjdGlvbiA9IHRoaXMuX2dldERyYWdWZXJ0aWNhbERpcmVjdGlvbigpLFxcbiAgICAgICAgICBob3Jpem9udGFsRGlyZWN0aW9uID0gdGhpcy5fZ2V0RHJhZ0hvcml6b250YWxEaXJlY3Rpb24oKTtcXG5cXG4gICAgICBpZiAodGhpcy5mbG9hdGluZyAmJiBob3Jpem9udGFsRGlyZWN0aW9uKSB7XFxuICAgICAgICByZXR1cm4gaG9yaXpvbnRhbERpcmVjdGlvbiA9PT0gXFxcInJpZ2h0XFxcIiAmJiBpc092ZXJSaWdodEhhbGYgfHwgaG9yaXpvbnRhbERpcmVjdGlvbiA9PT0gXFxcImxlZnRcXFwiICYmICFpc092ZXJSaWdodEhhbGY7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHJldHVybiB2ZXJ0aWNhbERpcmVjdGlvbiAmJiAodmVydGljYWxEaXJlY3Rpb24gPT09IFxcXCJkb3duXFxcIiAmJiBpc092ZXJCb3R0b21IYWxmIHx8IHZlcnRpY2FsRGlyZWN0aW9uID09PSBcXFwidXBcXFwiICYmICFpc092ZXJCb3R0b21IYWxmKTtcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIF9nZXREcmFnVmVydGljYWxEaXJlY3Rpb246IGZ1bmN0aW9uIF9nZXREcmFnVmVydGljYWxEaXJlY3Rpb24oKSB7XFxuICAgICAgdmFyIGRlbHRhID0gdGhpcy5wb3NpdGlvbkFicy50b3AgLSB0aGlzLmxhc3RQb3NpdGlvbkFicy50b3A7XFxuICAgICAgcmV0dXJuIGRlbHRhICE9PSAwICYmIChkZWx0YSA+IDAgPyBcXFwiZG93blxcXCIgOiBcXFwidXBcXFwiKTtcXG4gICAgfSxcXG4gICAgX2dldERyYWdIb3Jpem9udGFsRGlyZWN0aW9uOiBmdW5jdGlvbiBfZ2V0RHJhZ0hvcml6b250YWxEaXJlY3Rpb24oKSB7XFxuICAgICAgdmFyIGRlbHRhID0gdGhpcy5wb3NpdGlvbkFicy5sZWZ0IC0gdGhpcy5sYXN0UG9zaXRpb25BYnMubGVmdDtcXG4gICAgICByZXR1cm4gZGVsdGEgIT09IDAgJiYgKGRlbHRhID4gMCA/IFxcXCJyaWdodFxcXCIgOiBcXFwibGVmdFxcXCIpO1xcbiAgICB9LFxcbiAgICByZWZyZXNoOiBmdW5jdGlvbiByZWZyZXNoKGV2ZW50KSB7XFxuICAgICAgdGhpcy5fcmVmcmVzaEl0ZW1zKGV2ZW50KTtcXG5cXG4gICAgICB0aGlzLl9zZXRIYW5kbGVDbGFzc05hbWUoKTtcXG5cXG4gICAgICB0aGlzLnJlZnJlc2hQb3NpdGlvbnMoKTtcXG4gICAgICByZXR1cm4gdGhpcztcXG4gICAgfSxcXG4gICAgX2Nvbm5lY3RXaXRoOiBmdW5jdGlvbiBfY29ubmVjdFdpdGgoKSB7XFxuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XFxuICAgICAgcmV0dXJuIG9wdGlvbnMuY29ubmVjdFdpdGguY29uc3RydWN0b3IgPT09IFN0cmluZyA/IFtvcHRpb25zLmNvbm5lY3RXaXRoXSA6IG9wdGlvbnMuY29ubmVjdFdpdGg7XFxuICAgIH0sXFxuICAgIF9nZXRJdGVtc0FzalF1ZXJ5OiBmdW5jdGlvbiBfZ2V0SXRlbXNBc2pRdWVyeShjb25uZWN0ZWQpIHtcXG4gICAgICB2YXIgaSxcXG4gICAgICAgICAgaixcXG4gICAgICAgICAgY3VyLFxcbiAgICAgICAgICBpbnN0LFxcbiAgICAgICAgICBpdGVtcyA9IFtdLFxcbiAgICAgICAgICBxdWVyaWVzID0gW10sXFxuICAgICAgICAgIGNvbm5lY3RXaXRoID0gdGhpcy5fY29ubmVjdFdpdGgoKTtcXG5cXG4gICAgICBpZiAoY29ubmVjdFdpdGggJiYgY29ubmVjdGVkKSB7XFxuICAgICAgICBmb3IgKGkgPSBjb25uZWN0V2l0aC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xcbiAgICAgICAgICBjdXIgPSAkKGNvbm5lY3RXaXRoW2ldLCB0aGlzLmRvY3VtZW50WzBdKTtcXG5cXG4gICAgICAgICAgZm9yIChqID0gY3VyLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XFxuICAgICAgICAgICAgaW5zdCA9ICQuZGF0YShjdXJbal0sIHRoaXMud2lkZ2V0RnVsbE5hbWUpO1xcblxcbiAgICAgICAgICAgIGlmIChpbnN0ICYmIGluc3QgIT09IHRoaXMgJiYgIWluc3Qub3B0aW9ucy5kaXNhYmxlZCkge1xcbiAgICAgICAgICAgICAgcXVlcmllcy5wdXNoKFskLmlzRnVuY3Rpb24oaW5zdC5vcHRpb25zLml0ZW1zKSA/IGluc3Qub3B0aW9ucy5pdGVtcy5jYWxsKGluc3QuZWxlbWVudCkgOiAkKGluc3Qub3B0aW9ucy5pdGVtcywgaW5zdC5lbGVtZW50KS5ub3QoXFxcIi51aS1zb3J0YWJsZS1oZWxwZXJcXFwiKS5ub3QoXFxcIi51aS1zb3J0YWJsZS1wbGFjZWhvbGRlclxcXCIpLCBpbnN0XSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHF1ZXJpZXMucHVzaChbJC5pc0Z1bmN0aW9uKHRoaXMub3B0aW9ucy5pdGVtcykgPyB0aGlzLm9wdGlvbnMuaXRlbXMuY2FsbCh0aGlzLmVsZW1lbnQsIG51bGwsIHtcXG4gICAgICAgIG9wdGlvbnM6IHRoaXMub3B0aW9ucyxcXG4gICAgICAgIGl0ZW06IHRoaXMuY3VycmVudEl0ZW1cXG4gICAgICB9KSA6ICQodGhpcy5vcHRpb25zLml0ZW1zLCB0aGlzLmVsZW1lbnQpLm5vdChcXFwiLnVpLXNvcnRhYmxlLWhlbHBlclxcXCIpLm5vdChcXFwiLnVpLXNvcnRhYmxlLXBsYWNlaG9sZGVyXFxcIiksIHRoaXNdKTtcXG5cXG4gICAgICBmdW5jdGlvbiBhZGRJdGVtcygpIHtcXG4gICAgICAgIGl0ZW1zLnB1c2godGhpcyk7XFxuICAgICAgfVxcblxcbiAgICAgIGZvciAoaSA9IHF1ZXJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcXG4gICAgICAgIHF1ZXJpZXNbaV1bMF0uZWFjaChhZGRJdGVtcyk7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiAkKGl0ZW1zKTtcXG4gICAgfSxcXG4gICAgX3JlbW92ZUN1cnJlbnRzRnJvbUl0ZW1zOiBmdW5jdGlvbiBfcmVtb3ZlQ3VycmVudHNGcm9tSXRlbXMoKSB7XFxuICAgICAgdmFyIGxpc3QgPSB0aGlzLmN1cnJlbnRJdGVtLmZpbmQoXFxcIjpkYXRhKFxcXCIgKyB0aGlzLndpZGdldE5hbWUgKyBcXFwiLWl0ZW0pXFxcIik7XFxuICAgICAgdGhpcy5pdGVtcyA9ICQuZ3JlcCh0aGlzLml0ZW1zLCBmdW5jdGlvbiAoaXRlbSkge1xcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsaXN0Lmxlbmd0aDsgaisrKSB7XFxuICAgICAgICAgIGlmIChsaXN0W2pdID09PSBpdGVtLml0ZW1bMF0pIHtcXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgIH0pO1xcbiAgICB9LFxcbiAgICBfcmVmcmVzaEl0ZW1zOiBmdW5jdGlvbiBfcmVmcmVzaEl0ZW1zKGV2ZW50KSB7XFxuICAgICAgdGhpcy5pdGVtcyA9IFtdO1xcbiAgICAgIHRoaXMuY29udGFpbmVycyA9IFt0aGlzXTtcXG5cXG4gICAgICB2YXIgaSxcXG4gICAgICAgICAgaixcXG4gICAgICAgICAgY3VyLFxcbiAgICAgICAgICBpbnN0LFxcbiAgICAgICAgICB0YXJnZXREYXRhLFxcbiAgICAgICAgICBfcXVlcmllcyxcXG4gICAgICAgICAgaXRlbSxcXG4gICAgICAgICAgcXVlcmllc0xlbmd0aCxcXG4gICAgICAgICAgaXRlbXMgPSB0aGlzLml0ZW1zLFxcbiAgICAgICAgICBxdWVyaWVzID0gW1skLmlzRnVuY3Rpb24odGhpcy5vcHRpb25zLml0ZW1zKSA/IHRoaXMub3B0aW9ucy5pdGVtcy5jYWxsKHRoaXMuZWxlbWVudFswXSwgZXZlbnQsIHtcXG4gICAgICAgIGl0ZW06IHRoaXMuY3VycmVudEl0ZW1cXG4gICAgICB9KSA6ICQodGhpcy5vcHRpb25zLml0ZW1zLCB0aGlzLmVsZW1lbnQpLCB0aGlzXV0sXFxuICAgICAgICAgIGNvbm5lY3RXaXRoID0gdGhpcy5fY29ubmVjdFdpdGgoKTtcXG5cXG4gICAgICBpZiAoY29ubmVjdFdpdGggJiYgdGhpcy5yZWFkeSkge1xcbiAgICAgICAgLy9TaG91bGRuJ3QgYmUgcnVuIHRoZSBmaXJzdCB0aW1lIHRocm91Z2ggZHVlIHRvIG1hc3NpdmUgc2xvdy1kb3duXFxuICAgICAgICBmb3IgKGkgPSBjb25uZWN0V2l0aC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xcbiAgICAgICAgICBjdXIgPSAkKGNvbm5lY3RXaXRoW2ldLCB0aGlzLmRvY3VtZW50WzBdKTtcXG5cXG4gICAgICAgICAgZm9yIChqID0gY3VyLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XFxuICAgICAgICAgICAgaW5zdCA9ICQuZGF0YShjdXJbal0sIHRoaXMud2lkZ2V0RnVsbE5hbWUpO1xcblxcbiAgICAgICAgICAgIGlmIChpbnN0ICYmIGluc3QgIT09IHRoaXMgJiYgIWluc3Qub3B0aW9ucy5kaXNhYmxlZCkge1xcbiAgICAgICAgICAgICAgcXVlcmllcy5wdXNoKFskLmlzRnVuY3Rpb24oaW5zdC5vcHRpb25zLml0ZW1zKSA/IGluc3Qub3B0aW9ucy5pdGVtcy5jYWxsKGluc3QuZWxlbWVudFswXSwgZXZlbnQsIHtcXG4gICAgICAgICAgICAgICAgaXRlbTogdGhpcy5jdXJyZW50SXRlbVxcbiAgICAgICAgICAgICAgfSkgOiAkKGluc3Qub3B0aW9ucy5pdGVtcywgaW5zdC5lbGVtZW50KSwgaW5zdF0pO1xcbiAgICAgICAgICAgICAgdGhpcy5jb250YWluZXJzLnB1c2goaW5zdCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGZvciAoaSA9IHF1ZXJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcXG4gICAgICAgIHRhcmdldERhdGEgPSBxdWVyaWVzW2ldWzFdO1xcbiAgICAgICAgX3F1ZXJpZXMgPSBxdWVyaWVzW2ldWzBdO1xcblxcbiAgICAgICAgZm9yIChqID0gMCwgcXVlcmllc0xlbmd0aCA9IF9xdWVyaWVzLmxlbmd0aDsgaiA8IHF1ZXJpZXNMZW5ndGg7IGorKykge1xcbiAgICAgICAgICBpdGVtID0gJChfcXVlcmllc1tqXSk7XFxuICAgICAgICAgIGl0ZW0uZGF0YSh0aGlzLndpZGdldE5hbWUgKyBcXFwiLWl0ZW1cXFwiLCB0YXJnZXREYXRhKTsgLy8gRGF0YSBmb3IgdGFyZ2V0IGNoZWNraW5nIChtb3VzZSBtYW5hZ2VyKVxcblxcbiAgICAgICAgICBpdGVtcy5wdXNoKHtcXG4gICAgICAgICAgICBpdGVtOiBpdGVtLFxcbiAgICAgICAgICAgIGluc3RhbmNlOiB0YXJnZXREYXRhLFxcbiAgICAgICAgICAgIHdpZHRoOiAwLFxcbiAgICAgICAgICAgIGhlaWdodDogMCxcXG4gICAgICAgICAgICBsZWZ0OiAwLFxcbiAgICAgICAgICAgIHRvcDogMFxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH0sXFxuICAgIHJlZnJlc2hQb3NpdGlvbnM6IGZ1bmN0aW9uIHJlZnJlc2hQb3NpdGlvbnMoZmFzdCkge1xcbiAgICAgIC8vIERldGVybWluZSB3aGV0aGVyIGl0ZW1zIGFyZSBiZWluZyBkaXNwbGF5ZWQgaG9yaXpvbnRhbGx5XFxuICAgICAgdGhpcy5mbG9hdGluZyA9IHRoaXMuaXRlbXMubGVuZ3RoID8gdGhpcy5vcHRpb25zLmF4aXMgPT09IFxcXCJ4XFxcIiB8fCB0aGlzLl9pc0Zsb2F0aW5nKHRoaXMuaXRlbXNbMF0uaXRlbSkgOiBmYWxzZTsgLy9UaGlzIGhhcyB0byBiZSByZWRvbmUgYmVjYXVzZSBkdWUgdG8gdGhlIGl0ZW0gYmVpbmcgbW92ZWQgb3V0L2ludG8gdGhlIG9mZnNldFBhcmVudCwgdGhlIG9mZnNldFBhcmVudCdzIHBvc2l0aW9uIHdpbGwgY2hhbmdlXFxuXFxuICAgICAgaWYgKHRoaXMub2Zmc2V0UGFyZW50ICYmIHRoaXMuaGVscGVyKSB7XFxuICAgICAgICB0aGlzLm9mZnNldC5wYXJlbnQgPSB0aGlzLl9nZXRQYXJlbnRPZmZzZXQoKTtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIGksIGl0ZW0sIHQsIHA7XFxuXFxuICAgICAgZm9yIChpID0gdGhpcy5pdGVtcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xcbiAgICAgICAgaXRlbSA9IHRoaXMuaXRlbXNbaV07IC8vV2UgaWdub3JlIGNhbGN1bGF0aW5nIHBvc2l0aW9ucyBvZiBhbGwgY29ubmVjdGVkIGNvbnRhaW5lcnMgd2hlbiB3ZSdyZSBub3Qgb3ZlciB0aGVtXFxuXFxuICAgICAgICBpZiAoaXRlbS5pbnN0YW5jZSAhPT0gdGhpcy5jdXJyZW50Q29udGFpbmVyICYmIHRoaXMuY3VycmVudENvbnRhaW5lciAmJiBpdGVtLml0ZW1bMF0gIT09IHRoaXMuY3VycmVudEl0ZW1bMF0pIHtcXG4gICAgICAgICAgY29udGludWU7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0ID0gdGhpcy5vcHRpb25zLnRvbGVyYW5jZUVsZW1lbnQgPyAkKHRoaXMub3B0aW9ucy50b2xlcmFuY2VFbGVtZW50LCBpdGVtLml0ZW0pIDogaXRlbS5pdGVtO1xcblxcbiAgICAgICAgaWYgKCFmYXN0KSB7XFxuICAgICAgICAgIGl0ZW0ud2lkdGggPSB0Lm91dGVyV2lkdGgoKTtcXG4gICAgICAgICAgaXRlbS5oZWlnaHQgPSB0Lm91dGVySGVpZ2h0KCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBwID0gdC5vZmZzZXQoKTtcXG4gICAgICAgIGl0ZW0ubGVmdCA9IHAubGVmdDtcXG4gICAgICAgIGl0ZW0udG9wID0gcC50b3A7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuY3VzdG9tICYmIHRoaXMub3B0aW9ucy5jdXN0b20ucmVmcmVzaENvbnRhaW5lcnMpIHtcXG4gICAgICAgIHRoaXMub3B0aW9ucy5jdXN0b20ucmVmcmVzaENvbnRhaW5lcnMuY2FsbCh0aGlzKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgZm9yIChpID0gdGhpcy5jb250YWluZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XFxuICAgICAgICAgIHAgPSB0aGlzLmNvbnRhaW5lcnNbaV0uZWxlbWVudC5vZmZzZXQoKTtcXG4gICAgICAgICAgdGhpcy5jb250YWluZXJzW2ldLmNvbnRhaW5lckNhY2hlLmxlZnQgPSBwLmxlZnQ7XFxuICAgICAgICAgIHRoaXMuY29udGFpbmVyc1tpXS5jb250YWluZXJDYWNoZS50b3AgPSBwLnRvcDtcXG4gICAgICAgICAgdGhpcy5jb250YWluZXJzW2ldLmNvbnRhaW5lckNhY2hlLndpZHRoID0gdGhpcy5jb250YWluZXJzW2ldLmVsZW1lbnQub3V0ZXJXaWR0aCgpO1xcbiAgICAgICAgICB0aGlzLmNvbnRhaW5lcnNbaV0uY29udGFpbmVyQ2FjaGUuaGVpZ2h0ID0gdGhpcy5jb250YWluZXJzW2ldLmVsZW1lbnQub3V0ZXJIZWlnaHQoKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHRoaXM7XFxuICAgIH0sXFxuICAgIF9jcmVhdGVQbGFjZWhvbGRlcjogZnVuY3Rpb24gX2NyZWF0ZVBsYWNlaG9sZGVyKHRoYXQpIHtcXG4gICAgICB0aGF0ID0gdGhhdCB8fCB0aGlzO1xcbiAgICAgIHZhciBjbGFzc05hbWUsXFxuICAgICAgICAgIG8gPSB0aGF0Lm9wdGlvbnM7XFxuXFxuICAgICAgaWYgKCFvLnBsYWNlaG9sZGVyIHx8IG8ucGxhY2Vob2xkZXIuY29uc3RydWN0b3IgPT09IFN0cmluZykge1xcbiAgICAgICAgY2xhc3NOYW1lID0gby5wbGFjZWhvbGRlcjtcXG4gICAgICAgIG8ucGxhY2Vob2xkZXIgPSB7XFxuICAgICAgICAgIGVsZW1lbnQ6IGZ1bmN0aW9uIGVsZW1lbnQoKSB7XFxuICAgICAgICAgICAgdmFyIG5vZGVOYW1lID0gdGhhdC5jdXJyZW50SXRlbVswXS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxcbiAgICAgICAgICAgICAgICBlbGVtZW50ID0gJChcXFwiPFxcXCIgKyBub2RlTmFtZSArIFxcXCI+XFxcIiwgdGhhdC5kb2N1bWVudFswXSkuYWRkQ2xhc3MoY2xhc3NOYW1lIHx8IHRoYXQuY3VycmVudEl0ZW1bMF0uY2xhc3NOYW1lICsgXFxcIiB1aS1zb3J0YWJsZS1wbGFjZWhvbGRlclxcXCIpLnJlbW92ZUNsYXNzKFxcXCJ1aS1zb3J0YWJsZS1oZWxwZXJcXFwiKTtcXG5cXG4gICAgICAgICAgICBpZiAobm9kZU5hbWUgPT09IFxcXCJ0Ym9keVxcXCIpIHtcXG4gICAgICAgICAgICAgIHRoYXQuX2NyZWF0ZVRyUGxhY2Vob2xkZXIodGhhdC5jdXJyZW50SXRlbS5maW5kKFxcXCJ0clxcXCIpLmVxKDApLCAkKFxcXCI8dHI+XFxcIiwgdGhhdC5kb2N1bWVudFswXSkuYXBwZW5kVG8oZWxlbWVudCkpO1xcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZU5hbWUgPT09IFxcXCJ0clxcXCIpIHtcXG4gICAgICAgICAgICAgIHRoYXQuX2NyZWF0ZVRyUGxhY2Vob2xkZXIodGhhdC5jdXJyZW50SXRlbSwgZWxlbWVudCk7XFxuICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlTmFtZSA9PT0gXFxcImltZ1xcXCIpIHtcXG4gICAgICAgICAgICAgIGVsZW1lbnQuYXR0cihcXFwic3JjXFxcIiwgdGhhdC5jdXJyZW50SXRlbS5hdHRyKFxcXCJzcmNcXFwiKSk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmICghY2xhc3NOYW1lKSB7XFxuICAgICAgICAgICAgICBlbGVtZW50LmNzcyhcXFwidmlzaWJpbGl0eVxcXCIsIFxcXCJoaWRkZW5cXFwiKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XFxuICAgICAgICAgIH0sXFxuICAgICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKGNvbnRhaW5lciwgcCkge1xcbiAgICAgICAgICAgIC8vIDEuIElmIGEgY2xhc3NOYW1lIGlzIHNldCBhcyAncGxhY2Vob2xkZXIgb3B0aW9uLCB3ZSBkb24ndCBmb3JjZSBzaXplcyAtIHRoZSBjbGFzcyBpcyByZXNwb25zaWJsZSBmb3IgdGhhdFxcbiAgICAgICAgICAgIC8vIDIuIFRoZSBvcHRpb24gJ2ZvcmNlUGxhY2Vob2xkZXJTaXplIGNhbiBiZSBlbmFibGVkIHRvIGZvcmNlIGl0IGV2ZW4gaWYgYSBjbGFzcyBuYW1lIGlzIHNwZWNpZmllZFxcbiAgICAgICAgICAgIGlmIChjbGFzc05hbWUgJiYgIW8uZm9yY2VQbGFjZWhvbGRlclNpemUpIHtcXG4gICAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgICB9IC8vSWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGEgYWN0dWFsIGhlaWdodCBieSBpdHNlbGYgKHdpdGhvdXQgc3R5bGVzIGNvbWluZyBmcm9tIGEgc3R5bGVzaGVldCksIGl0IHJlY2VpdmVzIHRoZSBpbmxpbmUgaGVpZ2h0IGZyb20gdGhlIGRyYWdnZWQgaXRlbVxcblxcblxcbiAgICAgICAgICAgIGlmICghcC5oZWlnaHQoKSkge1xcbiAgICAgICAgICAgICAgcC5oZWlnaHQodGhhdC5jdXJyZW50SXRlbS5pbm5lckhlaWdodCgpIC0gcGFyc2VJbnQodGhhdC5jdXJyZW50SXRlbS5jc3MoXFxcInBhZGRpbmdUb3BcXFwiKSB8fCAwLCAxMCkgLSBwYXJzZUludCh0aGF0LmN1cnJlbnRJdGVtLmNzcyhcXFwicGFkZGluZ0JvdHRvbVxcXCIpIHx8IDAsIDEwKSk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmICghcC53aWR0aCgpKSB7XFxuICAgICAgICAgICAgICBwLndpZHRoKHRoYXQuY3VycmVudEl0ZW0uaW5uZXJXaWR0aCgpIC0gcGFyc2VJbnQodGhhdC5jdXJyZW50SXRlbS5jc3MoXFxcInBhZGRpbmdMZWZ0XFxcIikgfHwgMCwgMTApIC0gcGFyc2VJbnQodGhhdC5jdXJyZW50SXRlbS5jc3MoXFxcInBhZGRpbmdSaWdodFxcXCIpIHx8IDAsIDEwKSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9O1xcbiAgICAgIH0gLy9DcmVhdGUgdGhlIHBsYWNlaG9sZGVyXFxuXFxuXFxuICAgICAgdGhhdC5wbGFjZWhvbGRlciA9ICQoby5wbGFjZWhvbGRlci5lbGVtZW50LmNhbGwodGhhdC5lbGVtZW50LCB0aGF0LmN1cnJlbnRJdGVtKSk7IC8vQXBwZW5kIGl0IGFmdGVyIHRoZSBhY3R1YWwgY3VycmVudCBpdGVtXFxuXFxuICAgICAgdGhhdC5jdXJyZW50SXRlbS5hZnRlcih0aGF0LnBsYWNlaG9sZGVyKTsgLy9VcGRhdGUgdGhlIHNpemUgb2YgdGhlIHBsYWNlaG9sZGVyIChUT0RPOiBMb2dpYyB0byBmdXp6eSwgc2VlIGxpbmUgMzE2LzMxNylcXG5cXG4gICAgICBvLnBsYWNlaG9sZGVyLnVwZGF0ZSh0aGF0LCB0aGF0LnBsYWNlaG9sZGVyKTtcXG4gICAgfSxcXG4gICAgX2NyZWF0ZVRyUGxhY2Vob2xkZXI6IGZ1bmN0aW9uIF9jcmVhdGVUclBsYWNlaG9sZGVyKHNvdXJjZVRyLCB0YXJnZXRUcikge1xcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcXG4gICAgICBzb3VyY2VUci5jaGlsZHJlbigpLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgJChcXFwiPHRkPiYjMTYwOzwvdGQ+XFxcIiwgdGhhdC5kb2N1bWVudFswXSkuYXR0cihcXFwiY29sc3BhblxcXCIsICQodGhpcykuYXR0cihcXFwiY29sc3BhblxcXCIpIHx8IDEpLmFwcGVuZFRvKHRhcmdldFRyKTtcXG4gICAgICB9KTtcXG4gICAgfSxcXG4gICAgX2NvbnRhY3RDb250YWluZXJzOiBmdW5jdGlvbiBfY29udGFjdENvbnRhaW5lcnMoZXZlbnQpIHtcXG4gICAgICB2YXIgaSxcXG4gICAgICAgICAgaixcXG4gICAgICAgICAgZGlzdCxcXG4gICAgICAgICAgaXRlbVdpdGhMZWFzdERpc3RhbmNlLFxcbiAgICAgICAgICBwb3NQcm9wZXJ0eSxcXG4gICAgICAgICAgc2l6ZVByb3BlcnR5LFxcbiAgICAgICAgICBjdXIsXFxuICAgICAgICAgIG5lYXJCb3R0b20sXFxuICAgICAgICAgIGZsb2F0aW5nLFxcbiAgICAgICAgICBheGlzLFxcbiAgICAgICAgICBpbm5lcm1vc3RDb250YWluZXIgPSBudWxsLFxcbiAgICAgICAgICBpbm5lcm1vc3RJbmRleCA9IG51bGw7IC8vIGdldCBpbm5lcm1vc3QgY29udGFpbmVyIHRoYXQgaW50ZXJzZWN0cyB3aXRoIGl0ZW1cXG5cXG4gICAgICBmb3IgKGkgPSB0aGlzLmNvbnRhaW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcXG4gICAgICAgIC8vIG5ldmVyIGNvbnNpZGVyIGEgY29udGFpbmVyIHRoYXQncyBsb2NhdGVkIHdpdGhpbiB0aGUgaXRlbSBpdHNlbGZcXG4gICAgICAgIGlmICgkLmNvbnRhaW5zKHRoaXMuY3VycmVudEl0ZW1bMF0sIHRoaXMuY29udGFpbmVyc1tpXS5lbGVtZW50WzBdKSkge1xcbiAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICh0aGlzLl9pbnRlcnNlY3RzV2l0aCh0aGlzLmNvbnRhaW5lcnNbaV0uY29udGFpbmVyQ2FjaGUpKSB7XFxuICAgICAgICAgIC8vIGlmIHdlJ3ZlIGFscmVhZHkgZm91bmQgYSBjb250YWluZXIgYW5kIGl0J3MgbW9yZSBcXFwiaW5uZXJcXFwiIHRoYW4gdGhpcywgdGhlbiBjb250aW51ZVxcbiAgICAgICAgICBpZiAoaW5uZXJtb3N0Q29udGFpbmVyICYmICQuY29udGFpbnModGhpcy5jb250YWluZXJzW2ldLmVsZW1lbnRbMF0sIGlubmVybW9zdENvbnRhaW5lci5lbGVtZW50WzBdKSkge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlubmVybW9zdENvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyc1tpXTtcXG4gICAgICAgICAgaW5uZXJtb3N0SW5kZXggPSBpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgLy8gY29udGFpbmVyIGRvZXNuJ3QgaW50ZXJzZWN0LiB0cmlnZ2VyIFxcXCJvdXRcXFwiIGV2ZW50IGlmIG5lY2Vzc2FyeVxcbiAgICAgICAgICBpZiAodGhpcy5jb250YWluZXJzW2ldLmNvbnRhaW5lckNhY2hlLm92ZXIpIHtcXG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lcnNbaV0uX3RyaWdnZXIoXFxcIm91dFxcXCIsIGV2ZW50LCB0aGlzLl91aUhhc2godGhpcykpO1xcblxcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyc1tpXS5jb250YWluZXJDYWNoZS5vdmVyID0gMDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH0gLy8gaWYgbm8gaW50ZXJzZWN0aW5nIGNvbnRhaW5lcnMgZm91bmQsIHJldHVyblxcblxcblxcbiAgICAgIGlmICghaW5uZXJtb3N0Q29udGFpbmVyKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfSAvLyBtb3ZlIHRoZSBpdGVtIGludG8gdGhlIGNvbnRhaW5lciBpZiBpdCdzIG5vdCB0aGVyZSBhbHJlYWR5XFxuXFxuXFxuICAgICAgaWYgKHRoaXMuY29udGFpbmVycy5sZW5ndGggPT09IDEpIHtcXG4gICAgICAgIGlmICghdGhpcy5jb250YWluZXJzW2lubmVybW9zdEluZGV4XS5jb250YWluZXJDYWNoZS5vdmVyKSB7XFxuICAgICAgICAgIHRoaXMuY29udGFpbmVyc1tpbm5lcm1vc3RJbmRleF0uX3RyaWdnZXIoXFxcIm92ZXJcXFwiLCBldmVudCwgdGhpcy5fdWlIYXNoKHRoaXMpKTtcXG5cXG4gICAgICAgICAgdGhpcy5jb250YWluZXJzW2lubmVybW9zdEluZGV4XS5jb250YWluZXJDYWNoZS5vdmVyID0gMTtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgLy9XaGVuIGVudGVyaW5nIGEgbmV3IGNvbnRhaW5lciwgd2Ugd2lsbCBmaW5kIHRoZSBpdGVtIHdpdGggdGhlIGxlYXN0IGRpc3RhbmNlIGFuZCBhcHBlbmQgb3VyIGl0ZW0gbmVhciBpdFxcbiAgICAgICAgZGlzdCA9IDEwMDAwO1xcbiAgICAgICAgaXRlbVdpdGhMZWFzdERpc3RhbmNlID0gbnVsbDtcXG4gICAgICAgIGZsb2F0aW5nID0gaW5uZXJtb3N0Q29udGFpbmVyLmZsb2F0aW5nIHx8IHRoaXMuX2lzRmxvYXRpbmcodGhpcy5jdXJyZW50SXRlbSk7XFxuICAgICAgICBwb3NQcm9wZXJ0eSA9IGZsb2F0aW5nID8gXFxcImxlZnRcXFwiIDogXFxcInRvcFxcXCI7XFxuICAgICAgICBzaXplUHJvcGVydHkgPSBmbG9hdGluZyA/IFxcXCJ3aWR0aFxcXCIgOiBcXFwiaGVpZ2h0XFxcIjtcXG4gICAgICAgIGF4aXMgPSBmbG9hdGluZyA/IFxcXCJjbGllbnRYXFxcIiA6IFxcXCJjbGllbnRZXFxcIjtcXG5cXG4gICAgICAgIGZvciAoaiA9IHRoaXMuaXRlbXMubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcXG4gICAgICAgICAgaWYgKCEkLmNvbnRhaW5zKHRoaXMuY29udGFpbmVyc1tpbm5lcm1vc3RJbmRleF0uZWxlbWVudFswXSwgdGhpcy5pdGVtc1tqXS5pdGVtWzBdKSkge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmICh0aGlzLml0ZW1zW2pdLml0ZW1bMF0gPT09IHRoaXMuY3VycmVudEl0ZW1bMF0pIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBjdXIgPSB0aGlzLml0ZW1zW2pdLml0ZW0ub2Zmc2V0KClbcG9zUHJvcGVydHldO1xcbiAgICAgICAgICBuZWFyQm90dG9tID0gZmFsc2U7XFxuXFxuICAgICAgICAgIGlmIChldmVudFtheGlzXSAtIGN1ciA+IHRoaXMuaXRlbXNbal1bc2l6ZVByb3BlcnR5XSAvIDIpIHtcXG4gICAgICAgICAgICBuZWFyQm90dG9tID0gdHJ1ZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAoTWF0aC5hYnMoZXZlbnRbYXhpc10gLSBjdXIpIDwgZGlzdCkge1xcbiAgICAgICAgICAgIGRpc3QgPSBNYXRoLmFicyhldmVudFtheGlzXSAtIGN1cik7XFxuICAgICAgICAgICAgaXRlbVdpdGhMZWFzdERpc3RhbmNlID0gdGhpcy5pdGVtc1tqXTtcXG4gICAgICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IG5lYXJCb3R0b20gPyBcXFwidXBcXFwiIDogXFxcImRvd25cXFwiO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IC8vQ2hlY2sgaWYgZHJvcE9uRW1wdHkgaXMgZW5hYmxlZFxcblxcblxcbiAgICAgICAgaWYgKCFpdGVtV2l0aExlYXN0RGlzdGFuY2UgJiYgIXRoaXMub3B0aW9ucy5kcm9wT25FbXB0eSkge1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAodGhpcy5jdXJyZW50Q29udGFpbmVyID09PSB0aGlzLmNvbnRhaW5lcnNbaW5uZXJtb3N0SW5kZXhdKSB7XFxuICAgICAgICAgIGlmICghdGhpcy5jdXJyZW50Q29udGFpbmVyLmNvbnRhaW5lckNhY2hlLm92ZXIpIHtcXG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lcnNbaW5uZXJtb3N0SW5kZXhdLl90cmlnZ2VyKFxcXCJvdmVyXFxcIiwgZXZlbnQsIHRoaXMuX3VpSGFzaCgpKTtcXG5cXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDb250YWluZXIuY29udGFpbmVyQ2FjaGUub3ZlciA9IDE7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaXRlbVdpdGhMZWFzdERpc3RhbmNlID8gdGhpcy5fcmVhcnJhbmdlKGV2ZW50LCBpdGVtV2l0aExlYXN0RGlzdGFuY2UsIG51bGwsIHRydWUpIDogdGhpcy5fcmVhcnJhbmdlKGV2ZW50LCBudWxsLCB0aGlzLmNvbnRhaW5lcnNbaW5uZXJtb3N0SW5kZXhdLmVsZW1lbnQsIHRydWUpO1xcblxcbiAgICAgICAgdGhpcy5fdHJpZ2dlcihcXFwiY2hhbmdlXFxcIiwgZXZlbnQsIHRoaXMuX3VpSGFzaCgpKTtcXG5cXG4gICAgICAgIHRoaXMuY29udGFpbmVyc1tpbm5lcm1vc3RJbmRleF0uX3RyaWdnZXIoXFxcImNoYW5nZVxcXCIsIGV2ZW50LCB0aGlzLl91aUhhc2godGhpcykpO1xcblxcbiAgICAgICAgdGhpcy5jdXJyZW50Q29udGFpbmVyID0gdGhpcy5jb250YWluZXJzW2lubmVybW9zdEluZGV4XTsgLy9VcGRhdGUgdGhlIHBsYWNlaG9sZGVyXFxuXFxuICAgICAgICB0aGlzLm9wdGlvbnMucGxhY2Vob2xkZXIudXBkYXRlKHRoaXMuY3VycmVudENvbnRhaW5lciwgdGhpcy5wbGFjZWhvbGRlcik7XFxuXFxuICAgICAgICB0aGlzLmNvbnRhaW5lcnNbaW5uZXJtb3N0SW5kZXhdLl90cmlnZ2VyKFxcXCJvdmVyXFxcIiwgZXZlbnQsIHRoaXMuX3VpSGFzaCh0aGlzKSk7XFxuXFxuICAgICAgICB0aGlzLmNvbnRhaW5lcnNbaW5uZXJtb3N0SW5kZXhdLmNvbnRhaW5lckNhY2hlLm92ZXIgPSAxO1xcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgX2NyZWF0ZUhlbHBlcjogZnVuY3Rpb24gX2NyZWF0ZUhlbHBlcihldmVudCkge1xcbiAgICAgIHZhciBvID0gdGhpcy5vcHRpb25zLFxcbiAgICAgICAgICBoZWxwZXIgPSAkLmlzRnVuY3Rpb24oby5oZWxwZXIpID8gJChvLmhlbHBlci5hcHBseSh0aGlzLmVsZW1lbnRbMF0sIFtldmVudCwgdGhpcy5jdXJyZW50SXRlbV0pKSA6IG8uaGVscGVyID09PSBcXFwiY2xvbmVcXFwiID8gdGhpcy5jdXJyZW50SXRlbS5jbG9uZSgpIDogdGhpcy5jdXJyZW50SXRlbTsgLy9BZGQgdGhlIGhlbHBlciB0byB0aGUgRE9NIGlmIHRoYXQgZGlkbid0IGhhcHBlbiBhbHJlYWR5XFxuXFxuICAgICAgaWYgKCFoZWxwZXIucGFyZW50cyhcXFwiYm9keVxcXCIpLmxlbmd0aCkge1xcbiAgICAgICAgJChvLmFwcGVuZFRvICE9PSBcXFwicGFyZW50XFxcIiA/IG8uYXBwZW5kVG8gOiB0aGlzLmN1cnJlbnRJdGVtWzBdLnBhcmVudE5vZGUpWzBdLmFwcGVuZENoaWxkKGhlbHBlclswXSk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChoZWxwZXJbMF0gPT09IHRoaXMuY3VycmVudEl0ZW1bMF0pIHtcXG4gICAgICAgIHRoaXMuX3N0b3JlZENTUyA9IHtcXG4gICAgICAgICAgd2lkdGg6IHRoaXMuY3VycmVudEl0ZW1bMF0uc3R5bGUud2lkdGgsXFxuICAgICAgICAgIGhlaWdodDogdGhpcy5jdXJyZW50SXRlbVswXS5zdHlsZS5oZWlnaHQsXFxuICAgICAgICAgIHBvc2l0aW9uOiB0aGlzLmN1cnJlbnRJdGVtLmNzcyhcXFwicG9zaXRpb25cXFwiKSxcXG4gICAgICAgICAgdG9wOiB0aGlzLmN1cnJlbnRJdGVtLmNzcyhcXFwidG9wXFxcIiksXFxuICAgICAgICAgIGxlZnQ6IHRoaXMuY3VycmVudEl0ZW0uY3NzKFxcXCJsZWZ0XFxcIilcXG4gICAgICAgIH07XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghaGVscGVyWzBdLnN0eWxlLndpZHRoIHx8IG8uZm9yY2VIZWxwZXJTaXplKSB7XFxuICAgICAgICBoZWxwZXIud2lkdGgodGhpcy5jdXJyZW50SXRlbS53aWR0aCgpKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCFoZWxwZXJbMF0uc3R5bGUuaGVpZ2h0IHx8IG8uZm9yY2VIZWxwZXJTaXplKSB7XFxuICAgICAgICBoZWxwZXIuaGVpZ2h0KHRoaXMuY3VycmVudEl0ZW0uaGVpZ2h0KCkpO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gaGVscGVyO1xcbiAgICB9LFxcbiAgICBfYWRqdXN0T2Zmc2V0RnJvbUhlbHBlcjogZnVuY3Rpb24gX2FkanVzdE9mZnNldEZyb21IZWxwZXIob2JqKSB7XFxuICAgICAgaWYgKHR5cGVvZiBvYmogPT09IFxcXCJzdHJpbmdcXFwiKSB7XFxuICAgICAgICBvYmogPSBvYmouc3BsaXQoXFxcIiBcXFwiKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCQuaXNBcnJheShvYmopKSB7XFxuICAgICAgICBvYmogPSB7XFxuICAgICAgICAgIGxlZnQ6ICtvYmpbMF0sXFxuICAgICAgICAgIHRvcDogK29ialsxXSB8fCAwXFxuICAgICAgICB9O1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoXFxcImxlZnRcXFwiIGluIG9iaikge1xcbiAgICAgICAgdGhpcy5vZmZzZXQuY2xpY2subGVmdCA9IG9iai5sZWZ0ICsgdGhpcy5tYXJnaW5zLmxlZnQ7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChcXFwicmlnaHRcXFwiIGluIG9iaikge1xcbiAgICAgICAgdGhpcy5vZmZzZXQuY2xpY2subGVmdCA9IHRoaXMuaGVscGVyUHJvcG9ydGlvbnMud2lkdGggLSBvYmoucmlnaHQgKyB0aGlzLm1hcmdpbnMubGVmdDtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKFxcXCJ0b3BcXFwiIGluIG9iaikge1xcbiAgICAgICAgdGhpcy5vZmZzZXQuY2xpY2sudG9wID0gb2JqLnRvcCArIHRoaXMubWFyZ2lucy50b3A7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChcXFwiYm90dG9tXFxcIiBpbiBvYmopIHtcXG4gICAgICAgIHRoaXMub2Zmc2V0LmNsaWNrLnRvcCA9IHRoaXMuaGVscGVyUHJvcG9ydGlvbnMuaGVpZ2h0IC0gb2JqLmJvdHRvbSArIHRoaXMubWFyZ2lucy50b3A7XFxuICAgICAgfVxcbiAgICB9LFxcbiAgICBfZ2V0UGFyZW50T2Zmc2V0OiBmdW5jdGlvbiBfZ2V0UGFyZW50T2Zmc2V0KCkge1xcbiAgICAgIC8vR2V0IHRoZSBvZmZzZXRQYXJlbnQgYW5kIGNhY2hlIGl0cyBwb3NpdGlvblxcbiAgICAgIHRoaXMub2Zmc2V0UGFyZW50ID0gdGhpcy5oZWxwZXIub2Zmc2V0UGFyZW50KCk7XFxuICAgICAgdmFyIHBvID0gdGhpcy5vZmZzZXRQYXJlbnQub2Zmc2V0KCk7IC8vIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2Ugd2hlcmUgd2UgbmVlZCB0byBtb2RpZnkgYSBvZmZzZXQgY2FsY3VsYXRlZCBvbiBzdGFydCwgc2luY2UgdGhlIGZvbGxvd2luZyBoYXBwZW5lZDpcXG4gICAgICAvLyAxLiBUaGUgcG9zaXRpb24gb2YgdGhlIGhlbHBlciBpcyBhYnNvbHV0ZSwgc28gaXQncyBwb3NpdGlvbiBpcyBjYWxjdWxhdGVkIGJhc2VkIG9uIHRoZSBuZXh0IHBvc2l0aW9uZWQgcGFyZW50XFxuICAgICAgLy8gMi4gVGhlIGFjdHVhbCBvZmZzZXQgcGFyZW50IGlzIGEgY2hpbGQgb2YgdGhlIHNjcm9sbCBwYXJlbnQsIGFuZCB0aGUgc2Nyb2xsIHBhcmVudCBpc24ndCB0aGUgZG9jdW1lbnQsIHdoaWNoIG1lYW5zIHRoYXRcXG4gICAgICAvLyAgICB0aGUgc2Nyb2xsIGlzIGluY2x1ZGVkIGluIHRoZSBpbml0aWFsIGNhbGN1bGF0aW9uIG9mIHRoZSBvZmZzZXQgb2YgdGhlIHBhcmVudCwgYW5kIG5ldmVyIHJlY2FsY3VsYXRlZCB1cG9uIGRyYWdcXG5cXG4gICAgICBpZiAodGhpcy5jc3NQb3NpdGlvbiA9PT0gXFxcImFic29sdXRlXFxcIiAmJiB0aGlzLnNjcm9sbFBhcmVudFswXSAhPT0gdGhpcy5kb2N1bWVudFswXSAmJiAkLmNvbnRhaW5zKHRoaXMuc2Nyb2xsUGFyZW50WzBdLCB0aGlzLm9mZnNldFBhcmVudFswXSkpIHtcXG4gICAgICAgIHBvLmxlZnQgKz0gdGhpcy5zY3JvbGxQYXJlbnQuc2Nyb2xsTGVmdCgpO1xcbiAgICAgICAgcG8udG9wICs9IHRoaXMuc2Nyb2xsUGFyZW50LnNjcm9sbFRvcCgpO1xcbiAgICAgIH0gLy8gVGhpcyBuZWVkcyB0byBiZSBhY3R1YWxseSBkb25lIGZvciBhbGwgYnJvd3NlcnMsIHNpbmNlIHBhZ2VYL3BhZ2VZIGluY2x1ZGVzIHRoaXMgaW5mb3JtYXRpb25cXG4gICAgICAvLyB3aXRoIGFuIHVnbHkgSUUgZml4XFxuXFxuXFxuICAgICAgaWYgKHRoaXMub2Zmc2V0UGFyZW50WzBdID09PSB0aGlzLmRvY3VtZW50WzBdLmJvZHkgfHwgdGhpcy5vZmZzZXRQYXJlbnRbMF0udGFnTmFtZSAmJiB0aGlzLm9mZnNldFBhcmVudFswXS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFxcXCJodG1sXFxcIiAmJiAkLnVpLmllKSB7XFxuICAgICAgICBwbyA9IHtcXG4gICAgICAgICAgdG9wOiAwLFxcbiAgICAgICAgICBsZWZ0OiAwXFxuICAgICAgICB9O1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4ge1xcbiAgICAgICAgdG9wOiBwby50b3AgKyAocGFyc2VJbnQodGhpcy5vZmZzZXRQYXJlbnQuY3NzKFxcXCJib3JkZXJUb3BXaWR0aFxcXCIpLCAxMCkgfHwgMCksXFxuICAgICAgICBsZWZ0OiBwby5sZWZ0ICsgKHBhcnNlSW50KHRoaXMub2Zmc2V0UGFyZW50LmNzcyhcXFwiYm9yZGVyTGVmdFdpZHRoXFxcIiksIDEwKSB8fCAwKVxcbiAgICAgIH07XFxuICAgIH0sXFxuICAgIF9nZXRSZWxhdGl2ZU9mZnNldDogZnVuY3Rpb24gX2dldFJlbGF0aXZlT2Zmc2V0KCkge1xcbiAgICAgIGlmICh0aGlzLmNzc1Bvc2l0aW9uID09PSBcXFwicmVsYXRpdmVcXFwiKSB7XFxuICAgICAgICB2YXIgcCA9IHRoaXMuY3VycmVudEl0ZW0ucG9zaXRpb24oKTtcXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgIHRvcDogcC50b3AgLSAocGFyc2VJbnQodGhpcy5oZWxwZXIuY3NzKFxcXCJ0b3BcXFwiKSwgMTApIHx8IDApICsgdGhpcy5zY3JvbGxQYXJlbnQuc2Nyb2xsVG9wKCksXFxuICAgICAgICAgIGxlZnQ6IHAubGVmdCAtIChwYXJzZUludCh0aGlzLmhlbHBlci5jc3MoXFxcImxlZnRcXFwiKSwgMTApIHx8IDApICsgdGhpcy5zY3JvbGxQYXJlbnQuc2Nyb2xsTGVmdCgpXFxuICAgICAgICB9O1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICB0b3A6IDAsXFxuICAgICAgICAgIGxlZnQ6IDBcXG4gICAgICAgIH07XFxuICAgICAgfVxcbiAgICB9LFxcbiAgICBfY2FjaGVNYXJnaW5zOiBmdW5jdGlvbiBfY2FjaGVNYXJnaW5zKCkge1xcbiAgICAgIHRoaXMubWFyZ2lucyA9IHtcXG4gICAgICAgIGxlZnQ6IHBhcnNlSW50KHRoaXMuY3VycmVudEl0ZW0uY3NzKFxcXCJtYXJnaW5MZWZ0XFxcIiksIDEwKSB8fCAwLFxcbiAgICAgICAgdG9wOiBwYXJzZUludCh0aGlzLmN1cnJlbnRJdGVtLmNzcyhcXFwibWFyZ2luVG9wXFxcIiksIDEwKSB8fCAwXFxuICAgICAgfTtcXG4gICAgfSxcXG4gICAgX2NhY2hlSGVscGVyUHJvcG9ydGlvbnM6IGZ1bmN0aW9uIF9jYWNoZUhlbHBlclByb3BvcnRpb25zKCkge1xcbiAgICAgIHRoaXMuaGVscGVyUHJvcG9ydGlvbnMgPSB7XFxuICAgICAgICB3aWR0aDogdGhpcy5oZWxwZXIub3V0ZXJXaWR0aCgpLFxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLmhlbHBlci5vdXRlckhlaWdodCgpXFxuICAgICAgfTtcXG4gICAgfSxcXG4gICAgX3NldENvbnRhaW5tZW50OiBmdW5jdGlvbiBfc2V0Q29udGFpbm1lbnQoKSB7XFxuICAgICAgdmFyIGNlLFxcbiAgICAgICAgICBjbyxcXG4gICAgICAgICAgb3ZlcixcXG4gICAgICAgICAgbyA9IHRoaXMub3B0aW9ucztcXG5cXG4gICAgICBpZiAoby5jb250YWlubWVudCA9PT0gXFxcInBhcmVudFxcXCIpIHtcXG4gICAgICAgIG8uY29udGFpbm1lbnQgPSB0aGlzLmhlbHBlclswXS5wYXJlbnROb2RlO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoby5jb250YWlubWVudCA9PT0gXFxcImRvY3VtZW50XFxcIiB8fCBvLmNvbnRhaW5tZW50ID09PSBcXFwid2luZG93XFxcIikge1xcbiAgICAgICAgdGhpcy5jb250YWlubWVudCA9IFswIC0gdGhpcy5vZmZzZXQucmVsYXRpdmUubGVmdCAtIHRoaXMub2Zmc2V0LnBhcmVudC5sZWZ0LCAwIC0gdGhpcy5vZmZzZXQucmVsYXRpdmUudG9wIC0gdGhpcy5vZmZzZXQucGFyZW50LnRvcCwgby5jb250YWlubWVudCA9PT0gXFxcImRvY3VtZW50XFxcIiA/IHRoaXMuZG9jdW1lbnQud2lkdGgoKSA6IHRoaXMud2luZG93LndpZHRoKCkgLSB0aGlzLmhlbHBlclByb3BvcnRpb25zLndpZHRoIC0gdGhpcy5tYXJnaW5zLmxlZnQsIChvLmNvbnRhaW5tZW50ID09PSBcXFwiZG9jdW1lbnRcXFwiID8gdGhpcy5kb2N1bWVudC53aWR0aCgpIDogdGhpcy53aW5kb3cuaGVpZ2h0KCkgfHwgdGhpcy5kb2N1bWVudFswXS5ib2R5LnBhcmVudE5vZGUuc2Nyb2xsSGVpZ2h0KSAtIHRoaXMuaGVscGVyUHJvcG9ydGlvbnMuaGVpZ2h0IC0gdGhpcy5tYXJnaW5zLnRvcF07XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghL14oZG9jdW1lbnR8d2luZG93fHBhcmVudCkkLy50ZXN0KG8uY29udGFpbm1lbnQpKSB7XFxuICAgICAgICBjZSA9ICQoby5jb250YWlubWVudClbMF07XFxuICAgICAgICBjbyA9ICQoby5jb250YWlubWVudCkub2Zmc2V0KCk7XFxuICAgICAgICBvdmVyID0gJChjZSkuY3NzKFxcXCJvdmVyZmxvd1xcXCIpICE9PSBcXFwiaGlkZGVuXFxcIjtcXG4gICAgICAgIHRoaXMuY29udGFpbm1lbnQgPSBbY28ubGVmdCArIChwYXJzZUludCgkKGNlKS5jc3MoXFxcImJvcmRlckxlZnRXaWR0aFxcXCIpLCAxMCkgfHwgMCkgKyAocGFyc2VJbnQoJChjZSkuY3NzKFxcXCJwYWRkaW5nTGVmdFxcXCIpLCAxMCkgfHwgMCkgLSB0aGlzLm1hcmdpbnMubGVmdCwgY28udG9wICsgKHBhcnNlSW50KCQoY2UpLmNzcyhcXFwiYm9yZGVyVG9wV2lkdGhcXFwiKSwgMTApIHx8IDApICsgKHBhcnNlSW50KCQoY2UpLmNzcyhcXFwicGFkZGluZ1RvcFxcXCIpLCAxMCkgfHwgMCkgLSB0aGlzLm1hcmdpbnMudG9wLCBjby5sZWZ0ICsgKG92ZXIgPyBNYXRoLm1heChjZS5zY3JvbGxXaWR0aCwgY2Uub2Zmc2V0V2lkdGgpIDogY2Uub2Zmc2V0V2lkdGgpIC0gKHBhcnNlSW50KCQoY2UpLmNzcyhcXFwiYm9yZGVyTGVmdFdpZHRoXFxcIiksIDEwKSB8fCAwKSAtIChwYXJzZUludCgkKGNlKS5jc3MoXFxcInBhZGRpbmdSaWdodFxcXCIpLCAxMCkgfHwgMCkgLSB0aGlzLmhlbHBlclByb3BvcnRpb25zLndpZHRoIC0gdGhpcy5tYXJnaW5zLmxlZnQsIGNvLnRvcCArIChvdmVyID8gTWF0aC5tYXgoY2Uuc2Nyb2xsSGVpZ2h0LCBjZS5vZmZzZXRIZWlnaHQpIDogY2Uub2Zmc2V0SGVpZ2h0KSAtIChwYXJzZUludCgkKGNlKS5jc3MoXFxcImJvcmRlclRvcFdpZHRoXFxcIiksIDEwKSB8fCAwKSAtIChwYXJzZUludCgkKGNlKS5jc3MoXFxcInBhZGRpbmdCb3R0b21cXFwiKSwgMTApIHx8IDApIC0gdGhpcy5oZWxwZXJQcm9wb3J0aW9ucy5oZWlnaHQgLSB0aGlzLm1hcmdpbnMudG9wXTtcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIF9jb252ZXJ0UG9zaXRpb25UbzogZnVuY3Rpb24gX2NvbnZlcnRQb3NpdGlvblRvKGQsIHBvcykge1xcbiAgICAgIGlmICghcG9zKSB7XFxuICAgICAgICBwb3MgPSB0aGlzLnBvc2l0aW9uO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgbW9kID0gZCA9PT0gXFxcImFic29sdXRlXFxcIiA/IDEgOiAtMSxcXG4gICAgICAgICAgc2Nyb2xsID0gdGhpcy5jc3NQb3NpdGlvbiA9PT0gXFxcImFic29sdXRlXFxcIiAmJiAhKHRoaXMuc2Nyb2xsUGFyZW50WzBdICE9PSB0aGlzLmRvY3VtZW50WzBdICYmICQuY29udGFpbnModGhpcy5zY3JvbGxQYXJlbnRbMF0sIHRoaXMub2Zmc2V0UGFyZW50WzBdKSkgPyB0aGlzLm9mZnNldFBhcmVudCA6IHRoaXMuc2Nyb2xsUGFyZW50LFxcbiAgICAgICAgICBzY3JvbGxJc1Jvb3ROb2RlID0gLyhodG1sfGJvZHkpL2kudGVzdChzY3JvbGxbMF0udGFnTmFtZSk7XFxuICAgICAgcmV0dXJuIHtcXG4gICAgICAgIHRvcDogcG9zLnRvcCArIC8vIFRoZSBhYnNvbHV0ZSBtb3VzZSBwb3NpdGlvblxcbiAgICAgICAgdGhpcy5vZmZzZXQucmVsYXRpdmUudG9wICogbW9kICsgLy8gT25seSBmb3IgcmVsYXRpdmUgcG9zaXRpb25lZCBub2RlczogUmVsYXRpdmUgb2Zmc2V0IGZyb20gZWxlbWVudCB0byBvZmZzZXQgcGFyZW50XFxuICAgICAgICB0aGlzLm9mZnNldC5wYXJlbnQudG9wICogbW9kIC0gLy8gVGhlIG9mZnNldFBhcmVudCdzIG9mZnNldCB3aXRob3V0IGJvcmRlcnMgKG9mZnNldCArIGJvcmRlcilcXG4gICAgICAgICh0aGlzLmNzc1Bvc2l0aW9uID09PSBcXFwiZml4ZWRcXFwiID8gLXRoaXMuc2Nyb2xsUGFyZW50LnNjcm9sbFRvcCgpIDogc2Nyb2xsSXNSb290Tm9kZSA/IDAgOiBzY3JvbGwuc2Nyb2xsVG9wKCkpICogbW9kLFxcbiAgICAgICAgbGVmdDogcG9zLmxlZnQgKyAvLyBUaGUgYWJzb2x1dGUgbW91c2UgcG9zaXRpb25cXG4gICAgICAgIHRoaXMub2Zmc2V0LnJlbGF0aXZlLmxlZnQgKiBtb2QgKyAvLyBPbmx5IGZvciByZWxhdGl2ZSBwb3NpdGlvbmVkIG5vZGVzOiBSZWxhdGl2ZSBvZmZzZXQgZnJvbSBlbGVtZW50IHRvIG9mZnNldCBwYXJlbnRcXG4gICAgICAgIHRoaXMub2Zmc2V0LnBhcmVudC5sZWZ0ICogbW9kIC0gLy8gVGhlIG9mZnNldFBhcmVudCdzIG9mZnNldCB3aXRob3V0IGJvcmRlcnMgKG9mZnNldCArIGJvcmRlcilcXG4gICAgICAgICh0aGlzLmNzc1Bvc2l0aW9uID09PSBcXFwiZml4ZWRcXFwiID8gLXRoaXMuc2Nyb2xsUGFyZW50LnNjcm9sbExlZnQoKSA6IHNjcm9sbElzUm9vdE5vZGUgPyAwIDogc2Nyb2xsLnNjcm9sbExlZnQoKSkgKiBtb2RcXG4gICAgICB9O1xcbiAgICB9LFxcbiAgICBfZ2VuZXJhdGVQb3NpdGlvbjogZnVuY3Rpb24gX2dlbmVyYXRlUG9zaXRpb24oZXZlbnQpIHtcXG4gICAgICB2YXIgdG9wLFxcbiAgICAgICAgICBsZWZ0LFxcbiAgICAgICAgICBvID0gdGhpcy5vcHRpb25zLFxcbiAgICAgICAgICBwYWdlWCA9IGV2ZW50LnBhZ2VYLFxcbiAgICAgICAgICBwYWdlWSA9IGV2ZW50LnBhZ2VZLFxcbiAgICAgICAgICBzY3JvbGwgPSB0aGlzLmNzc1Bvc2l0aW9uID09PSBcXFwiYWJzb2x1dGVcXFwiICYmICEodGhpcy5zY3JvbGxQYXJlbnRbMF0gIT09IHRoaXMuZG9jdW1lbnRbMF0gJiYgJC5jb250YWlucyh0aGlzLnNjcm9sbFBhcmVudFswXSwgdGhpcy5vZmZzZXRQYXJlbnRbMF0pKSA/IHRoaXMub2Zmc2V0UGFyZW50IDogdGhpcy5zY3JvbGxQYXJlbnQsXFxuICAgICAgICAgIHNjcm9sbElzUm9vdE5vZGUgPSAvKGh0bWx8Ym9keSkvaS50ZXN0KHNjcm9sbFswXS50YWdOYW1lKTsgLy8gVGhpcyBpcyBhbm90aGVyIHZlcnkgd2VpcmQgc3BlY2lhbCBjYXNlIHRoYXQgb25seSBoYXBwZW5zIGZvciByZWxhdGl2ZSBlbGVtZW50czpcXG4gICAgICAvLyAxLiBJZiB0aGUgY3NzIHBvc2l0aW9uIGlzIHJlbGF0aXZlXFxuICAgICAgLy8gMi4gYW5kIHRoZSBzY3JvbGwgcGFyZW50IGlzIHRoZSBkb2N1bWVudCBvciBzaW1pbGFyIHRvIHRoZSBvZmZzZXQgcGFyZW50XFxuICAgICAgLy8gd2UgaGF2ZSB0byByZWZyZXNoIHRoZSByZWxhdGl2ZSBvZmZzZXQgZHVyaW5nIHRoZSBzY3JvbGwgc28gdGhlcmUgYXJlIG5vIGp1bXBzXFxuXFxuICAgICAgaWYgKHRoaXMuY3NzUG9zaXRpb24gPT09IFxcXCJyZWxhdGl2ZVxcXCIgJiYgISh0aGlzLnNjcm9sbFBhcmVudFswXSAhPT0gdGhpcy5kb2N1bWVudFswXSAmJiB0aGlzLnNjcm9sbFBhcmVudFswXSAhPT0gdGhpcy5vZmZzZXRQYXJlbnRbMF0pKSB7XFxuICAgICAgICB0aGlzLm9mZnNldC5yZWxhdGl2ZSA9IHRoaXMuX2dldFJlbGF0aXZlT2Zmc2V0KCk7XFxuICAgICAgfVxcbiAgICAgIC8qXFxuICAgICAgICogLSBQb3NpdGlvbiBjb25zdHJhaW5pbmcgLVxcbiAgICAgICAqIENvbnN0cmFpbiB0aGUgcG9zaXRpb24gdG8gYSBtaXggb2YgZ3JpZCwgY29udGFpbm1lbnQuXFxuICAgICAgICovXFxuXFxuXFxuICAgICAgaWYgKHRoaXMub3JpZ2luYWxQb3NpdGlvbikge1xcbiAgICAgICAgLy9JZiB3ZSBhcmUgbm90IGRyYWdnaW5nIHlldCwgd2Ugd29uJ3QgY2hlY2sgZm9yIG9wdGlvbnNcXG4gICAgICAgIGlmICh0aGlzLmNvbnRhaW5tZW50KSB7XFxuICAgICAgICAgIGlmIChldmVudC5wYWdlWCAtIHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQgPCB0aGlzLmNvbnRhaW5tZW50WzBdKSB7XFxuICAgICAgICAgICAgcGFnZVggPSB0aGlzLmNvbnRhaW5tZW50WzBdICsgdGhpcy5vZmZzZXQuY2xpY2subGVmdDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAoZXZlbnQucGFnZVkgLSB0aGlzLm9mZnNldC5jbGljay50b3AgPCB0aGlzLmNvbnRhaW5tZW50WzFdKSB7XFxuICAgICAgICAgICAgcGFnZVkgPSB0aGlzLmNvbnRhaW5tZW50WzFdICsgdGhpcy5vZmZzZXQuY2xpY2sudG9wO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmIChldmVudC5wYWdlWCAtIHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQgPiB0aGlzLmNvbnRhaW5tZW50WzJdKSB7XFxuICAgICAgICAgICAgcGFnZVggPSB0aGlzLmNvbnRhaW5tZW50WzJdICsgdGhpcy5vZmZzZXQuY2xpY2subGVmdDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAoZXZlbnQucGFnZVkgLSB0aGlzLm9mZnNldC5jbGljay50b3AgPiB0aGlzLmNvbnRhaW5tZW50WzNdKSB7XFxuICAgICAgICAgICAgcGFnZVkgPSB0aGlzLmNvbnRhaW5tZW50WzNdICsgdGhpcy5vZmZzZXQuY2xpY2sudG9wO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoby5ncmlkKSB7XFxuICAgICAgICAgIHRvcCA9IHRoaXMub3JpZ2luYWxQYWdlWSArIE1hdGgucm91bmQoKHBhZ2VZIC0gdGhpcy5vcmlnaW5hbFBhZ2VZKSAvIG8uZ3JpZFsxXSkgKiBvLmdyaWRbMV07XFxuICAgICAgICAgIHBhZ2VZID0gdGhpcy5jb250YWlubWVudCA/IHRvcCAtIHRoaXMub2Zmc2V0LmNsaWNrLnRvcCA+PSB0aGlzLmNvbnRhaW5tZW50WzFdICYmIHRvcCAtIHRoaXMub2Zmc2V0LmNsaWNrLnRvcCA8PSB0aGlzLmNvbnRhaW5tZW50WzNdID8gdG9wIDogdG9wIC0gdGhpcy5vZmZzZXQuY2xpY2sudG9wID49IHRoaXMuY29udGFpbm1lbnRbMV0gPyB0b3AgLSBvLmdyaWRbMV0gOiB0b3AgKyBvLmdyaWRbMV0gOiB0b3A7XFxuICAgICAgICAgIGxlZnQgPSB0aGlzLm9yaWdpbmFsUGFnZVggKyBNYXRoLnJvdW5kKChwYWdlWCAtIHRoaXMub3JpZ2luYWxQYWdlWCkgLyBvLmdyaWRbMF0pICogby5ncmlkWzBdO1xcbiAgICAgICAgICBwYWdlWCA9IHRoaXMuY29udGFpbm1lbnQgPyBsZWZ0IC0gdGhpcy5vZmZzZXQuY2xpY2subGVmdCA+PSB0aGlzLmNvbnRhaW5tZW50WzBdICYmIGxlZnQgLSB0aGlzLm9mZnNldC5jbGljay5sZWZ0IDw9IHRoaXMuY29udGFpbm1lbnRbMl0gPyBsZWZ0IDogbGVmdCAtIHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQgPj0gdGhpcy5jb250YWlubWVudFswXSA/IGxlZnQgLSBvLmdyaWRbMF0gOiBsZWZ0ICsgby5ncmlkWzBdIDogbGVmdDtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHtcXG4gICAgICAgIHRvcDogcGFnZVkgLSAvLyBUaGUgYWJzb2x1dGUgbW91c2UgcG9zaXRpb25cXG4gICAgICAgIHRoaXMub2Zmc2V0LmNsaWNrLnRvcCAtIC8vIENsaWNrIG9mZnNldCAocmVsYXRpdmUgdG8gdGhlIGVsZW1lbnQpXFxuICAgICAgICB0aGlzLm9mZnNldC5yZWxhdGl2ZS50b3AgLSAvLyBPbmx5IGZvciByZWxhdGl2ZSBwb3NpdGlvbmVkIG5vZGVzOiBSZWxhdGl2ZSBvZmZzZXQgZnJvbSBlbGVtZW50IHRvIG9mZnNldCBwYXJlbnRcXG4gICAgICAgIHRoaXMub2Zmc2V0LnBhcmVudC50b3AgKyAoIC8vIFRoZSBvZmZzZXRQYXJlbnQncyBvZmZzZXQgd2l0aG91dCBib3JkZXJzIChvZmZzZXQgKyBib3JkZXIpXFxuICAgICAgICB0aGlzLmNzc1Bvc2l0aW9uID09PSBcXFwiZml4ZWRcXFwiID8gLXRoaXMuc2Nyb2xsUGFyZW50LnNjcm9sbFRvcCgpIDogc2Nyb2xsSXNSb290Tm9kZSA/IDAgOiBzY3JvbGwuc2Nyb2xsVG9wKCkpLFxcbiAgICAgICAgbGVmdDogcGFnZVggLSAvLyBUaGUgYWJzb2x1dGUgbW91c2UgcG9zaXRpb25cXG4gICAgICAgIHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQgLSAvLyBDbGljayBvZmZzZXQgKHJlbGF0aXZlIHRvIHRoZSBlbGVtZW50KVxcbiAgICAgICAgdGhpcy5vZmZzZXQucmVsYXRpdmUubGVmdCAtIC8vIE9ubHkgZm9yIHJlbGF0aXZlIHBvc2l0aW9uZWQgbm9kZXM6IFJlbGF0aXZlIG9mZnNldCBmcm9tIGVsZW1lbnQgdG8gb2Zmc2V0IHBhcmVudFxcbiAgICAgICAgdGhpcy5vZmZzZXQucGFyZW50LmxlZnQgKyAoIC8vIFRoZSBvZmZzZXRQYXJlbnQncyBvZmZzZXQgd2l0aG91dCBib3JkZXJzIChvZmZzZXQgKyBib3JkZXIpXFxuICAgICAgICB0aGlzLmNzc1Bvc2l0aW9uID09PSBcXFwiZml4ZWRcXFwiID8gLXRoaXMuc2Nyb2xsUGFyZW50LnNjcm9sbExlZnQoKSA6IHNjcm9sbElzUm9vdE5vZGUgPyAwIDogc2Nyb2xsLnNjcm9sbExlZnQoKSlcXG4gICAgICB9O1xcbiAgICB9LFxcbiAgICBfcmVhcnJhbmdlOiBmdW5jdGlvbiBfcmVhcnJhbmdlKGV2ZW50LCBpLCBhLCBoYXJkUmVmcmVzaCkge1xcbiAgICAgIGEgPyBhWzBdLmFwcGVuZENoaWxkKHRoaXMucGxhY2Vob2xkZXJbMF0pIDogaS5pdGVtWzBdLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMucGxhY2Vob2xkZXJbMF0sIHRoaXMuZGlyZWN0aW9uID09PSBcXFwiZG93blxcXCIgPyBpLml0ZW1bMF0gOiBpLml0ZW1bMF0ubmV4dFNpYmxpbmcpOyAvL1ZhcmlvdXMgdGhpbmdzIGRvbmUgaGVyZSB0byBpbXByb3ZlIHRoZSBwZXJmb3JtYW5jZTpcXG4gICAgICAvLyAxLiB3ZSBjcmVhdGUgYSBzZXRUaW1lb3V0LCB0aGF0IGNhbGxzIHJlZnJlc2hQb3NpdGlvbnNcXG4gICAgICAvLyAyLiBvbiB0aGUgaW5zdGFuY2UsIHdlIGhhdmUgYSBjb3VudGVyIHZhcmlhYmxlLCB0aGF0IGdldCdzIGhpZ2hlciBhZnRlciBldmVyeSBhcHBlbmRcXG4gICAgICAvLyAzLiBvbiB0aGUgbG9jYWwgc2NvcGUsIHdlIGNvcHkgdGhlIGNvdW50ZXIgdmFyaWFibGUsIGFuZCBjaGVjayBpbiB0aGUgdGltZW91dCwgaWYgaXQncyBzdGlsbCB0aGUgc2FtZVxcbiAgICAgIC8vIDQuIHRoaXMgbGV0cyBvbmx5IHRoZSBsYXN0IGFkZGl0aW9uIHRvIHRoZSB0aW1lb3V0IHN0YWNrIHRocm91Z2hcXG5cXG4gICAgICB0aGlzLmNvdW50ZXIgPSB0aGlzLmNvdW50ZXIgPyArK3RoaXMuY291bnRlciA6IDE7XFxuICAgICAgdmFyIGNvdW50ZXIgPSB0aGlzLmNvdW50ZXI7XFxuXFxuICAgICAgdGhpcy5fZGVsYXkoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgaWYgKGNvdW50ZXIgPT09IHRoaXMuY291bnRlcikge1xcbiAgICAgICAgICB0aGlzLnJlZnJlc2hQb3NpdGlvbnMoIWhhcmRSZWZyZXNoKTsgLy9QcmVjb21wdXRlIGFmdGVyIGVhY2ggRE9NIGluc2VydGlvbiwgTk9UIG9uIG1vdXNlbW92ZVxcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcbiAgICB9LFxcbiAgICBfY2xlYXI6IGZ1bmN0aW9uIF9jbGVhcihldmVudCwgbm9Qcm9wYWdhdGlvbikge1xcbiAgICAgIHRoaXMucmV2ZXJ0aW5nID0gZmFsc2U7IC8vIFdlIGRlbGF5IGFsbCBldmVudHMgdGhhdCBoYXZlIHRvIGJlIHRyaWdnZXJlZCB0byBhZnRlciB0aGUgcG9pbnQgd2hlcmUgdGhlIHBsYWNlaG9sZGVyIGhhcyBiZWVuIHJlbW92ZWQgYW5kXFxuICAgICAgLy8gZXZlcnl0aGluZyBlbHNlIG5vcm1hbGl6ZWQgYWdhaW5cXG5cXG4gICAgICB2YXIgaSxcXG4gICAgICAgICAgZGVsYXllZFRyaWdnZXJzID0gW107IC8vIFdlIGZpcnN0IGhhdmUgdG8gdXBkYXRlIHRoZSBkb20gcG9zaXRpb24gb2YgdGhlIGFjdHVhbCBjdXJyZW50SXRlbVxcbiAgICAgIC8vIE5vdGU6IGRvbid0IGRvIGl0IGlmIHRoZSBjdXJyZW50IGl0ZW0gaXMgYWxyZWFkeSByZW1vdmVkIChieSBhIHVzZXIpLCBvciBpdCBnZXRzIHJlYXBwZW5kZWQgKHNlZSAjNDA4OClcXG5cXG4gICAgICBpZiAoIXRoaXMuX25vRmluYWxTb3J0ICYmIHRoaXMuY3VycmVudEl0ZW0ucGFyZW50KCkubGVuZ3RoKSB7XFxuICAgICAgICB0aGlzLnBsYWNlaG9sZGVyLmJlZm9yZSh0aGlzLmN1cnJlbnRJdGVtKTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fbm9GaW5hbFNvcnQgPSBudWxsO1xcblxcbiAgICAgIGlmICh0aGlzLmhlbHBlclswXSA9PT0gdGhpcy5jdXJyZW50SXRlbVswXSkge1xcbiAgICAgICAgZm9yIChpIGluIHRoaXMuX3N0b3JlZENTUykge1xcbiAgICAgICAgICBpZiAodGhpcy5fc3RvcmVkQ1NTW2ldID09PSBcXFwiYXV0b1xcXCIgfHwgdGhpcy5fc3RvcmVkQ1NTW2ldID09PSBcXFwic3RhdGljXFxcIikge1xcbiAgICAgICAgICAgIHRoaXMuX3N0b3JlZENTU1tpXSA9IFxcXCJcXFwiO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0aGlzLmN1cnJlbnRJdGVtLmNzcyh0aGlzLl9zdG9yZWRDU1MpLnJlbW92ZUNsYXNzKFxcXCJ1aS1zb3J0YWJsZS1oZWxwZXJcXFwiKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdGhpcy5jdXJyZW50SXRlbS5zaG93KCk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLmZyb21PdXRzaWRlICYmICFub1Byb3BhZ2F0aW9uKSB7XFxuICAgICAgICBkZWxheWVkVHJpZ2dlcnMucHVzaChmdW5jdGlvbiAoZXZlbnQpIHtcXG4gICAgICAgICAgdGhpcy5fdHJpZ2dlcihcXFwicmVjZWl2ZVxcXCIsIGV2ZW50LCB0aGlzLl91aUhhc2godGhpcy5mcm9tT3V0c2lkZSkpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICgodGhpcy5mcm9tT3V0c2lkZSB8fCB0aGlzLmRvbVBvc2l0aW9uLnByZXYgIT09IHRoaXMuY3VycmVudEl0ZW0ucHJldigpLm5vdChcXFwiLnVpLXNvcnRhYmxlLWhlbHBlclxcXCIpWzBdIHx8IHRoaXMuZG9tUG9zaXRpb24ucGFyZW50ICE9PSB0aGlzLmN1cnJlbnRJdGVtLnBhcmVudCgpWzBdKSAmJiAhbm9Qcm9wYWdhdGlvbikge1xcbiAgICAgICAgZGVsYXllZFRyaWdnZXJzLnB1c2goZnVuY3Rpb24gKGV2ZW50KSB7XFxuICAgICAgICAgIHRoaXMuX3RyaWdnZXIoXFxcInVwZGF0ZVxcXCIsIGV2ZW50LCB0aGlzLl91aUhhc2goKSk7XFxuICAgICAgICB9KTsgLy9UcmlnZ2VyIHVwZGF0ZSBjYWxsYmFjayBpZiB0aGUgRE9NIHBvc2l0aW9uIGhhcyBjaGFuZ2VkXFxuICAgICAgfSAvLyBDaGVjayBpZiB0aGUgaXRlbXMgQ29udGFpbmVyIGhhcyBDaGFuZ2VkIGFuZCB0cmlnZ2VyIGFwcHJvcHJpYXRlXFxuICAgICAgLy8gZXZlbnRzLlxcblxcblxcbiAgICAgIGlmICh0aGlzICE9PSB0aGlzLmN1cnJlbnRDb250YWluZXIpIHtcXG4gICAgICAgIGlmICghbm9Qcm9wYWdhdGlvbikge1xcbiAgICAgICAgICBkZWxheWVkVHJpZ2dlcnMucHVzaChmdW5jdGlvbiAoZXZlbnQpIHtcXG4gICAgICAgICAgICB0aGlzLl90cmlnZ2VyKFxcXCJyZW1vdmVcXFwiLCBldmVudCwgdGhpcy5fdWlIYXNoKCkpO1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgICAgZGVsYXllZFRyaWdnZXJzLnB1c2goZnVuY3Rpb24gKGMpIHtcXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XFxuICAgICAgICAgICAgICBjLl90cmlnZ2VyKFxcXCJyZWNlaXZlXFxcIiwgZXZlbnQsIHRoaXMuX3VpSGFzaCh0aGlzKSk7XFxuICAgICAgICAgICAgfTtcXG4gICAgICAgICAgfS5jYWxsKHRoaXMsIHRoaXMuY3VycmVudENvbnRhaW5lcikpO1xcbiAgICAgICAgICBkZWxheWVkVHJpZ2dlcnMucHVzaChmdW5jdGlvbiAoYykge1xcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcXG4gICAgICAgICAgICAgIGMuX3RyaWdnZXIoXFxcInVwZGF0ZVxcXCIsIGV2ZW50LCB0aGlzLl91aUhhc2godGhpcykpO1xcbiAgICAgICAgICAgIH07XFxuICAgICAgICAgIH0uY2FsbCh0aGlzLCB0aGlzLmN1cnJlbnRDb250YWluZXIpKTtcXG4gICAgICAgIH1cXG4gICAgICB9IC8vUG9zdCBldmVudHMgdG8gY29udGFpbmVyc1xcblxcblxcbiAgICAgIGZ1bmN0aW9uIGRlbGF5RXZlbnQodHlwZSwgaW5zdGFuY2UsIGNvbnRhaW5lcikge1xcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xcbiAgICAgICAgICBjb250YWluZXIuX3RyaWdnZXIodHlwZSwgZXZlbnQsIGluc3RhbmNlLl91aUhhc2goaW5zdGFuY2UpKTtcXG4gICAgICAgIH07XFxuICAgICAgfVxcblxcbiAgICAgIGZvciAoaSA9IHRoaXMuY29udGFpbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xcbiAgICAgICAgaWYgKCFub1Byb3BhZ2F0aW9uKSB7XFxuICAgICAgICAgIGRlbGF5ZWRUcmlnZ2Vycy5wdXNoKGRlbGF5RXZlbnQoXFxcImRlYWN0aXZhdGVcXFwiLCB0aGlzLCB0aGlzLmNvbnRhaW5lcnNbaV0pKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICh0aGlzLmNvbnRhaW5lcnNbaV0uY29udGFpbmVyQ2FjaGUub3Zlcikge1xcbiAgICAgICAgICBkZWxheWVkVHJpZ2dlcnMucHVzaChkZWxheUV2ZW50KFxcXCJvdXRcXFwiLCB0aGlzLCB0aGlzLmNvbnRhaW5lcnNbaV0pKTtcXG4gICAgICAgICAgdGhpcy5jb250YWluZXJzW2ldLmNvbnRhaW5lckNhY2hlLm92ZXIgPSAwO1xcbiAgICAgICAgfVxcbiAgICAgIH0gLy9EbyB3aGF0IHdhcyBvcmlnaW5hbGx5IGluIHBsdWdpbnNcXG5cXG5cXG4gICAgICBpZiAodGhpcy5zdG9yZWRDdXJzb3IpIHtcXG4gICAgICAgIHRoaXMuZG9jdW1lbnQuZmluZChcXFwiYm9keVxcXCIpLmNzcyhcXFwiY3Vyc29yXFxcIiwgdGhpcy5zdG9yZWRDdXJzb3IpO1xcbiAgICAgICAgdGhpcy5zdG9yZWRTdHlsZXNoZWV0LnJlbW92ZSgpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5fc3RvcmVkT3BhY2l0eSkge1xcbiAgICAgICAgdGhpcy5oZWxwZXIuY3NzKFxcXCJvcGFjaXR5XFxcIiwgdGhpcy5fc3RvcmVkT3BhY2l0eSk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLl9zdG9yZWRaSW5kZXgpIHtcXG4gICAgICAgIHRoaXMuaGVscGVyLmNzcyhcXFwiekluZGV4XFxcIiwgdGhpcy5fc3RvcmVkWkluZGV4ID09PSBcXFwiYXV0b1xcXCIgPyBcXFwiXFxcIiA6IHRoaXMuX3N0b3JlZFpJbmRleCk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcXG5cXG4gICAgICBpZiAoIW5vUHJvcGFnYXRpb24pIHtcXG4gICAgICAgIHRoaXMuX3RyaWdnZXIoXFxcImJlZm9yZVN0b3BcXFwiLCBldmVudCwgdGhpcy5fdWlIYXNoKCkpO1xcbiAgICAgIH0gLy8kKHRoaXMucGxhY2Vob2xkZXJbMF0pLnJlbW92ZSgpOyB3b3VsZCBoYXZlIGJlZW4gdGhlIGpRdWVyeSB3YXkgLSB1bmZvcnR1bmF0ZWx5LCBpdCB1bmJpbmRzIEFMTCBldmVudHMgZnJvbSB0aGUgb3JpZ2luYWwgbm9kZSFcXG5cXG5cXG4gICAgICB0aGlzLnBsYWNlaG9sZGVyWzBdLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5wbGFjZWhvbGRlclswXSk7XFxuXFxuICAgICAgaWYgKCF0aGlzLmNhbmNlbEhlbHBlclJlbW92YWwpIHtcXG4gICAgICAgIGlmICh0aGlzLmhlbHBlclswXSAhPT0gdGhpcy5jdXJyZW50SXRlbVswXSkge1xcbiAgICAgICAgICB0aGlzLmhlbHBlci5yZW1vdmUoKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHRoaXMuaGVscGVyID0gbnVsbDtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCFub1Byb3BhZ2F0aW9uKSB7XFxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGVsYXllZFRyaWdnZXJzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgIGRlbGF5ZWRUcmlnZ2Vyc1tpXS5jYWxsKHRoaXMsIGV2ZW50KTtcXG4gICAgICAgIH0gLy9UcmlnZ2VyIGFsbCBkZWxheWVkIGV2ZW50c1xcblxcblxcbiAgICAgICAgdGhpcy5fdHJpZ2dlcihcXFwic3RvcFxcXCIsIGV2ZW50LCB0aGlzLl91aUhhc2goKSk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuZnJvbU91dHNpZGUgPSBmYWxzZTtcXG4gICAgICByZXR1cm4gIXRoaXMuY2FuY2VsSGVscGVyUmVtb3ZhbDtcXG4gICAgfSxcXG4gICAgX3RyaWdnZXI6IGZ1bmN0aW9uIF90cmlnZ2VyKCkge1xcbiAgICAgIGlmICgkLldpZGdldC5wcm90b3R5cGUuX3RyaWdnZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSA9PT0gZmFsc2UpIHtcXG4gICAgICAgIHRoaXMuY2FuY2VsKCk7XFxuICAgICAgfVxcbiAgICB9LFxcbiAgICBfdWlIYXNoOiBmdW5jdGlvbiBfdWlIYXNoKF9pbnN0KSB7XFxuICAgICAgdmFyIGluc3QgPSBfaW5zdCB8fCB0aGlzO1xcbiAgICAgIHJldHVybiB7XFxuICAgICAgICBoZWxwZXI6IGluc3QuaGVscGVyLFxcbiAgICAgICAgcGxhY2Vob2xkZXI6IGluc3QucGxhY2Vob2xkZXIgfHwgJChbXSksXFxuICAgICAgICBwb3NpdGlvbjogaW5zdC5wb3NpdGlvbixcXG4gICAgICAgIG9yaWdpbmFsUG9zaXRpb246IGluc3Qub3JpZ2luYWxQb3NpdGlvbixcXG4gICAgICAgIG9mZnNldDogaW5zdC5wb3NpdGlvbkFicyxcXG4gICAgICAgIGl0ZW06IGluc3QuY3VycmVudEl0ZW0sXFxuICAgICAgICBzZW5kZXI6IF9pbnN0ID8gX2luc3QuZWxlbWVudCA6IG51bGxcXG4gICAgICB9O1xcbiAgICB9XFxuICB9KTtcXG4gIC8qIVxcbiAgICogalF1ZXJ5IFVJIFNwaW5uZXIgMS4xMS40XFxuICAgKiBodHRwOi8vanF1ZXJ5dWkuY29tXFxuICAgKlxcbiAgICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcXG4gICAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cXG4gICAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcXG4gICAqXFxuICAgKiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9zcGlubmVyL1xcbiAgICovXFxuXFxuICBmdW5jdGlvbiBzcGlubmVyX21vZGlmaWVyKGZuKSB7XFxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XFxuICAgICAgdmFyIHByZXZpb3VzID0gdGhpcy5lbGVtZW50LnZhbCgpO1xcbiAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuXFxuICAgICAgdGhpcy5fcmVmcmVzaCgpO1xcblxcbiAgICAgIGlmIChwcmV2aW91cyAhPT0gdGhpcy5lbGVtZW50LnZhbCgpKSB7XFxuICAgICAgICB0aGlzLl90cmlnZ2VyKFxcXCJjaGFuZ2VcXFwiKTtcXG4gICAgICB9XFxuICAgIH07XFxuICB9XFxuXFxuICB2YXIgc3Bpbm5lciA9ICQud2lkZ2V0KFxcXCJ1aS5zcGlubmVyXFxcIiwge1xcbiAgICB2ZXJzaW9uOiBcXFwiMS4xMS40XFxcIixcXG4gICAgZGVmYXVsdEVsZW1lbnQ6IFxcXCI8aW5wdXQ+XFxcIixcXG4gICAgd2lkZ2V0RXZlbnRQcmVmaXg6IFxcXCJzcGluXFxcIixcXG4gICAgb3B0aW9uczoge1xcbiAgICAgIGN1bHR1cmU6IG51bGwsXFxuICAgICAgaWNvbnM6IHtcXG4gICAgICAgIGRvd246IFxcXCJ1aS1pY29uLXRyaWFuZ2xlLTEtc1xcXCIsXFxuICAgICAgICB1cDogXFxcInVpLWljb24tdHJpYW5nbGUtMS1uXFxcIlxcbiAgICAgIH0sXFxuICAgICAgaW5jcmVtZW50YWw6IHRydWUsXFxuICAgICAgbWF4OiBudWxsLFxcbiAgICAgIG1pbjogbnVsbCxcXG4gICAgICBudW1iZXJGb3JtYXQ6IG51bGwsXFxuICAgICAgcGFnZTogMTAsXFxuICAgICAgc3RlcDogMSxcXG4gICAgICBjaGFuZ2U6IG51bGwsXFxuICAgICAgc3BpbjogbnVsbCxcXG4gICAgICBzdGFydDogbnVsbCxcXG4gICAgICBzdG9wOiBudWxsXFxuICAgIH0sXFxuICAgIF9jcmVhdGU6IGZ1bmN0aW9uIF9jcmVhdGUoKSB7XFxuICAgICAgLy8gaGFuZGxlIHN0cmluZyB2YWx1ZXMgdGhhdCBuZWVkIHRvIGJlIHBhcnNlZFxcbiAgICAgIHRoaXMuX3NldE9wdGlvbihcXFwibWF4XFxcIiwgdGhpcy5vcHRpb25zLm1heCk7XFxuXFxuICAgICAgdGhpcy5fc2V0T3B0aW9uKFxcXCJtaW5cXFwiLCB0aGlzLm9wdGlvbnMubWluKTtcXG5cXG4gICAgICB0aGlzLl9zZXRPcHRpb24oXFxcInN0ZXBcXFwiLCB0aGlzLm9wdGlvbnMuc3RlcCk7IC8vIE9ubHkgZm9ybWF0IGlmIHRoZXJlIGlzIGEgdmFsdWUsIHByZXZlbnRzIHRoZSBmaWVsZCBmcm9tIGJlaW5nIG1hcmtlZFxcbiAgICAgIC8vIGFzIGludmFsaWQgaW4gRmlyZWZveCwgc2VlICM5NTczLlxcblxcblxcbiAgICAgIGlmICh0aGlzLnZhbHVlKCkgIT09IFxcXCJcXFwiKSB7XFxuICAgICAgICAvLyBGb3JtYXQgdGhlIHZhbHVlLCBidXQgZG9uJ3QgY29uc3RyYWluLlxcbiAgICAgICAgdGhpcy5fdmFsdWUodGhpcy5lbGVtZW50LnZhbCgpLCB0cnVlKTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fZHJhdygpO1xcblxcbiAgICAgIHRoaXMuX29uKHRoaXMuX2V2ZW50cyk7XFxuXFxuICAgICAgdGhpcy5fcmVmcmVzaCgpOyAvLyB0dXJuaW5nIG9mZiBhdXRvY29tcGxldGUgcHJldmVudHMgdGhlIGJyb3dzZXIgZnJvbSByZW1lbWJlcmluZyB0aGVcXG4gICAgICAvLyB2YWx1ZSB3aGVuIG5hdmlnYXRpbmcgdGhyb3VnaCBoaXN0b3J5LCBzbyB3ZSByZS1lbmFibGUgYXV0b2NvbXBsZXRlXFxuICAgICAgLy8gaWYgdGhlIHBhZ2UgaXMgdW5sb2FkZWQgYmVmb3JlIHRoZSB3aWRnZXQgaXMgZGVzdHJveWVkLiAjNzc5MFxcblxcblxcbiAgICAgIHRoaXMuX29uKHRoaXMud2luZG93LCB7XFxuICAgICAgICBiZWZvcmV1bmxvYWQ6IGZ1bmN0aW9uIGJlZm9yZXVubG9hZCgpIHtcXG4gICAgICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZUF0dHIoXFxcImF1dG9jb21wbGV0ZVxcXCIpO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcbiAgICB9LFxcbiAgICBfZ2V0Q3JlYXRlT3B0aW9uczogZnVuY3Rpb24gX2dldENyZWF0ZU9wdGlvbnMoKSB7XFxuICAgICAgdmFyIG9wdGlvbnMgPSB7fSxcXG4gICAgICAgICAgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcXG4gICAgICAkLmVhY2goW1xcXCJtaW5cXFwiLCBcXFwibWF4XFxcIiwgXFxcInN0ZXBcXFwiXSwgZnVuY3Rpb24gKGksIG9wdGlvbikge1xcbiAgICAgICAgdmFyIHZhbHVlID0gZWxlbWVudC5hdHRyKG9wdGlvbik7XFxuXFxuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZS5sZW5ndGgpIHtcXG4gICAgICAgICAgb3B0aW9uc1tvcHRpb25dID0gdmFsdWU7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgICAgcmV0dXJuIG9wdGlvbnM7XFxuICAgIH0sXFxuICAgIF9ldmVudHM6IHtcXG4gICAgICBrZXlkb3duOiBmdW5jdGlvbiBrZXlkb3duKGV2ZW50KSB7XFxuICAgICAgICBpZiAodGhpcy5fc3RhcnQoZXZlbnQpICYmIHRoaXMuX2tleWRvd24oZXZlbnQpKSB7XFxuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICB9XFxuICAgICAgfSxcXG4gICAgICBrZXl1cDogXFxcIl9zdG9wXFxcIixcXG4gICAgICBmb2N1czogZnVuY3Rpb24gZm9jdXMoKSB7XFxuICAgICAgICB0aGlzLnByZXZpb3VzID0gdGhpcy5lbGVtZW50LnZhbCgpO1xcbiAgICAgIH0sXFxuICAgICAgYmx1cjogZnVuY3Rpb24gYmx1cihldmVudCkge1xcbiAgICAgICAgaWYgKHRoaXMuY2FuY2VsQmx1cikge1xcbiAgICAgICAgICBkZWxldGUgdGhpcy5jYW5jZWxCbHVyO1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0aGlzLl9zdG9wKCk7XFxuXFxuICAgICAgICB0aGlzLl9yZWZyZXNoKCk7XFxuXFxuICAgICAgICBpZiAodGhpcy5wcmV2aW91cyAhPT0gdGhpcy5lbGVtZW50LnZhbCgpKSB7XFxuICAgICAgICAgIHRoaXMuX3RyaWdnZXIoXFxcImNoYW5nZVxcXCIsIGV2ZW50KTtcXG4gICAgICAgIH1cXG4gICAgICB9LFxcbiAgICAgIG1vdXNld2hlZWw6IGZ1bmN0aW9uIG1vdXNld2hlZWwoZXZlbnQsIGRlbHRhKSB7XFxuICAgICAgICBpZiAoIWRlbHRhKSB7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICghdGhpcy5zcGlubmluZyAmJiAhdGhpcy5fc3RhcnQoZXZlbnQpKSB7XFxuICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHRoaXMuX3NwaW4oKGRlbHRhID4gMCA/IDEgOiAtMSkgKiB0aGlzLm9wdGlvbnMuc3RlcCwgZXZlbnQpO1xcblxcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMubW91c2V3aGVlbFRpbWVyKTtcXG4gICAgICAgIHRoaXMubW91c2V3aGVlbFRpbWVyID0gdGhpcy5fZGVsYXkoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBpZiAodGhpcy5zcGlubmluZykge1xcbiAgICAgICAgICAgIHRoaXMuX3N0b3AoZXZlbnQpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9LCAxMDApO1xcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG4gICAgICB9LFxcbiAgICAgIFxcXCJtb3VzZWRvd24gLnVpLXNwaW5uZXItYnV0dG9uXFxcIjogZnVuY3Rpb24gbW91c2Vkb3duVWlTcGlubmVyQnV0dG9uKGV2ZW50KSB7XFxuICAgICAgICB2YXIgcHJldmlvdXM7IC8vIFdlIG5ldmVyIHdhbnQgdGhlIGJ1dHRvbnMgdG8gaGF2ZSBmb2N1czsgd2hlbmV2ZXIgdGhlIHVzZXIgaXNcXG4gICAgICAgIC8vIGludGVyYWN0aW5nIHdpdGggdGhlIHNwaW5uZXIsIHRoZSBmb2N1cyBzaG91bGQgYmUgb24gdGhlIGlucHV0LlxcbiAgICAgICAgLy8gSWYgdGhlIGlucHV0IGlzIGZvY3VzZWQgdGhlbiB0aGlzLnByZXZpb3VzIGlzIHByb3Blcmx5IHNldCBmcm9tXFxuICAgICAgICAvLyB3aGVuIHRoZSBpbnB1dCBmaXJzdCByZWNlaXZlZCBmb2N1cy4gSWYgdGhlIGlucHV0IGlzIG5vdCBmb2N1c2VkXFxuICAgICAgICAvLyB0aGVuIHdlIG5lZWQgdG8gc2V0IHRoaXMucHJldmlvdXMgYmFzZWQgb24gdGhlIHZhbHVlIGJlZm9yZSBzcGlubmluZy5cXG5cXG4gICAgICAgIHByZXZpb3VzID0gdGhpcy5lbGVtZW50WzBdID09PSB0aGlzLmRvY3VtZW50WzBdLmFjdGl2ZUVsZW1lbnQgPyB0aGlzLnByZXZpb3VzIDogdGhpcy5lbGVtZW50LnZhbCgpO1xcblxcbiAgICAgICAgZnVuY3Rpb24gY2hlY2tGb2N1cygpIHtcXG4gICAgICAgICAgdmFyIGlzQWN0aXZlID0gdGhpcy5lbGVtZW50WzBdID09PSB0aGlzLmRvY3VtZW50WzBdLmFjdGl2ZUVsZW1lbnQ7XFxuXFxuICAgICAgICAgIGlmICghaXNBY3RpdmUpIHtcXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuZm9jdXMoKTtcXG4gICAgICAgICAgICB0aGlzLnByZXZpb3VzID0gcHJldmlvdXM7IC8vIHN1cHBvcnQ6IElFXFxuICAgICAgICAgICAgLy8gSUUgc2V0cyBmb2N1cyBhc3luY2hyb25vdXNseSwgc28gd2UgbmVlZCB0byBjaGVjayBpZiBmb2N1c1xcbiAgICAgICAgICAgIC8vIG1vdmVkIG9mZiBvZiB0aGUgaW5wdXQgYmVjYXVzZSB0aGUgdXNlciBjbGlja2VkIG9uIHRoZSBidXR0b24uXFxuXFxuICAgICAgICAgICAgdGhpcy5fZGVsYXkoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgdGhpcy5wcmV2aW91cyA9IHByZXZpb3VzO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IC8vIGVuc3VyZSBmb2N1cyBpcyBvbiAob3Igc3RheXMgb24pIHRoZSB0ZXh0IGZpZWxkXFxuXFxuXFxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgY2hlY2tGb2N1cy5jYWxsKHRoaXMpOyAvLyBzdXBwb3J0OiBJRVxcbiAgICAgICAgLy8gSUUgZG9lc24ndCBwcmV2ZW50IG1vdmluZyBmb2N1cyBldmVuIHdpdGggZXZlbnQucHJldmVudERlZmF1bHQoKVxcbiAgICAgICAgLy8gc28gd2Ugc2V0IGEgZmxhZyB0byBrbm93IHdoZW4gd2Ugc2hvdWxkIGlnbm9yZSB0aGUgYmx1ciBldmVudFxcbiAgICAgICAgLy8gYW5kIGNoZWNrIChhZ2FpbikgaWYgZm9jdXMgbW92ZWQgb2ZmIG9mIHRoZSBpbnB1dC5cXG5cXG4gICAgICAgIHRoaXMuY2FuY2VsQmx1ciA9IHRydWU7XFxuXFxuICAgICAgICB0aGlzLl9kZWxheShmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIGRlbGV0ZSB0aGlzLmNhbmNlbEJsdXI7XFxuICAgICAgICAgIGNoZWNrRm9jdXMuY2FsbCh0aGlzKTtcXG4gICAgICAgIH0pO1xcblxcbiAgICAgICAgaWYgKHRoaXMuX3N0YXJ0KGV2ZW50KSA9PT0gZmFsc2UpIHtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdGhpcy5fcmVwZWF0KG51bGwsICQoZXZlbnQuY3VycmVudFRhcmdldCkuaGFzQ2xhc3MoXFxcInVpLXNwaW5uZXItdXBcXFwiKSA/IDEgOiAtMSwgZXZlbnQpO1xcbiAgICAgIH0sXFxuICAgICAgXFxcIm1vdXNldXAgLnVpLXNwaW5uZXItYnV0dG9uXFxcIjogXFxcIl9zdG9wXFxcIixcXG4gICAgICBcXFwibW91c2VlbnRlciAudWktc3Bpbm5lci1idXR0b25cXFwiOiBmdW5jdGlvbiBtb3VzZWVudGVyVWlTcGlubmVyQnV0dG9uKGV2ZW50KSB7XFxuICAgICAgICAvLyBidXR0b24gd2lsbCBhZGQgdWktc3RhdGUtYWN0aXZlIGlmIG1vdXNlIHdhcyBkb3duIHdoaWxlIG1vdXNlbGVhdmUgYW5kIGtlcHQgZG93blxcbiAgICAgICAgaWYgKCEkKGV2ZW50LmN1cnJlbnRUYXJnZXQpLmhhc0NsYXNzKFxcXCJ1aS1zdGF0ZS1hY3RpdmVcXFwiKSkge1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAodGhpcy5fc3RhcnQoZXZlbnQpID09PSBmYWxzZSkge1xcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0aGlzLl9yZXBlYXQobnVsbCwgJChldmVudC5jdXJyZW50VGFyZ2V0KS5oYXNDbGFzcyhcXFwidWktc3Bpbm5lci11cFxcXCIpID8gMSA6IC0xLCBldmVudCk7XFxuICAgICAgfSxcXG4gICAgICAvLyBUT0RPOiBkbyB3ZSByZWFsbHkgd2FudCB0byBjb25zaWRlciB0aGlzIGEgc3RvcD9cXG4gICAgICAvLyBzaG91bGRuJ3Qgd2UganVzdCBzdG9wIHRoZSByZXBlYXRlciBhbmQgd2FpdCB1bnRpbCBtb3VzZXVwIGJlZm9yZVxcbiAgICAgIC8vIHdlIHRyaWdnZXIgdGhlIHN0b3AgZXZlbnQ/XFxuICAgICAgXFxcIm1vdXNlbGVhdmUgLnVpLXNwaW5uZXItYnV0dG9uXFxcIjogXFxcIl9zdG9wXFxcIlxcbiAgICB9LFxcbiAgICBfZHJhdzogZnVuY3Rpb24gX2RyYXcoKSB7XFxuICAgICAgdmFyIHVpU3Bpbm5lciA9IHRoaXMudWlTcGlubmVyID0gdGhpcy5lbGVtZW50LmFkZENsYXNzKFxcXCJ1aS1zcGlubmVyLWlucHV0XFxcIikuYXR0cihcXFwiYXV0b2NvbXBsZXRlXFxcIiwgXFxcIm9mZlxcXCIpLndyYXAodGhpcy5fdWlTcGlubmVySHRtbCgpKS5wYXJlbnQoKSAvLyBhZGQgYnV0dG9uc1xcbiAgICAgIC5hcHBlbmQodGhpcy5fYnV0dG9uSHRtbCgpKTtcXG4gICAgICB0aGlzLmVsZW1lbnQuYXR0cihcXFwicm9sZVxcXCIsIFxcXCJzcGluYnV0dG9uXFxcIik7IC8vIGJ1dHRvbiBiaW5kaW5nc1xcblxcbiAgICAgIHRoaXMuYnV0dG9ucyA9IHVpU3Bpbm5lci5maW5kKFxcXCIudWktc3Bpbm5lci1idXR0b25cXFwiKS5hdHRyKFxcXCJ0YWJJbmRleFxcXCIsIC0xKS5idXR0b24oKS5yZW1vdmVDbGFzcyhcXFwidWktY29ybmVyLWFsbFxcXCIpOyAvLyBJRSA2IGRvZXNuJ3QgdW5kZXJzdGFuZCBoZWlnaHQ6IDUwJSBmb3IgdGhlIGJ1dHRvbnNcXG4gICAgICAvLyB1bmxlc3MgdGhlIHdyYXBwZXIgaGFzIGFuIGV4cGxpY2l0IGhlaWdodFxcblxcbiAgICAgIGlmICh0aGlzLmJ1dHRvbnMuaGVpZ2h0KCkgPiBNYXRoLmNlaWwodWlTcGlubmVyLmhlaWdodCgpICogMC41KSAmJiB1aVNwaW5uZXIuaGVpZ2h0KCkgPiAwKSB7XFxuICAgICAgICB1aVNwaW5uZXIuaGVpZ2h0KHVpU3Bpbm5lci5oZWlnaHQoKSk7XFxuICAgICAgfSAvLyBkaXNhYmxlIHNwaW5uZXIgaWYgZWxlbWVudCB3YXMgYWxyZWFkeSBkaXNhYmxlZFxcblxcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGlzYWJsZWQpIHtcXG4gICAgICAgIHRoaXMuZGlzYWJsZSgpO1xcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgX2tleWRvd246IGZ1bmN0aW9uIF9rZXlkb3duKGV2ZW50KSB7XFxuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXFxuICAgICAgICAgIGtleUNvZGUgPSAkLnVpLmtleUNvZGU7XFxuXFxuICAgICAgc3dpdGNoIChldmVudC5rZXlDb2RlKSB7XFxuICAgICAgICBjYXNlIGtleUNvZGUuVVA6XFxuICAgICAgICAgIHRoaXMuX3JlcGVhdChudWxsLCAxLCBldmVudCk7XFxuXFxuICAgICAgICAgIHJldHVybiB0cnVlO1xcblxcbiAgICAgICAgY2FzZSBrZXlDb2RlLkRPV046XFxuICAgICAgICAgIHRoaXMuX3JlcGVhdChudWxsLCAtMSwgZXZlbnQpO1xcblxcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG5cXG4gICAgICAgIGNhc2Uga2V5Q29kZS5QQUdFX1VQOlxcbiAgICAgICAgICB0aGlzLl9yZXBlYXQobnVsbCwgb3B0aW9ucy5wYWdlLCBldmVudCk7XFxuXFxuICAgICAgICAgIHJldHVybiB0cnVlO1xcblxcbiAgICAgICAgY2FzZSBrZXlDb2RlLlBBR0VfRE9XTjpcXG4gICAgICAgICAgdGhpcy5fcmVwZWF0KG51bGwsIC1vcHRpb25zLnBhZ2UsIGV2ZW50KTtcXG5cXG4gICAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfSxcXG4gICAgX3VpU3Bpbm5lckh0bWw6IGZ1bmN0aW9uIF91aVNwaW5uZXJIdG1sKCkge1xcbiAgICAgIHJldHVybiBcXFwiPHNwYW4gY2xhc3M9J3VpLXNwaW5uZXIgdWktd2lkZ2V0IHVpLXdpZGdldC1jb250ZW50IHVpLWNvcm5lci1hbGwnPjwvc3Bhbj5cXFwiO1xcbiAgICB9LFxcbiAgICBfYnV0dG9uSHRtbDogZnVuY3Rpb24gX2J1dHRvbkh0bWwoKSB7XFxuICAgICAgcmV0dXJuIFxcXCJcXFwiICsgXFxcIjxhIGNsYXNzPSd1aS1zcGlubmVyLWJ1dHRvbiB1aS1zcGlubmVyLXVwIHVpLWNvcm5lci10cic+XFxcIiArIFxcXCI8c3BhbiBjbGFzcz0ndWktaWNvbiBcXFwiICsgdGhpcy5vcHRpb25zLmljb25zLnVwICsgXFxcIic+JiM5NjUwOzwvc3Bhbj5cXFwiICsgXFxcIjwvYT5cXFwiICsgXFxcIjxhIGNsYXNzPSd1aS1zcGlubmVyLWJ1dHRvbiB1aS1zcGlubmVyLWRvd24gdWktY29ybmVyLWJyJz5cXFwiICsgXFxcIjxzcGFuIGNsYXNzPSd1aS1pY29uIFxcXCIgKyB0aGlzLm9wdGlvbnMuaWNvbnMuZG93biArIFxcXCInPiYjOTY2MDs8L3NwYW4+XFxcIiArIFxcXCI8L2E+XFxcIjtcXG4gICAgfSxcXG4gICAgX3N0YXJ0OiBmdW5jdGlvbiBfc3RhcnQoZXZlbnQpIHtcXG4gICAgICBpZiAoIXRoaXMuc3Bpbm5pbmcgJiYgdGhpcy5fdHJpZ2dlcihcXFwic3RhcnRcXFwiLCBldmVudCkgPT09IGZhbHNlKSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghdGhpcy5jb3VudGVyKSB7XFxuICAgICAgICB0aGlzLmNvdW50ZXIgPSAxO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLnNwaW5uaW5nID0gdHJ1ZTtcXG4gICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgfSxcXG4gICAgX3JlcGVhdDogZnVuY3Rpb24gX3JlcGVhdChpLCBzdGVwcywgZXZlbnQpIHtcXG4gICAgICBpID0gaSB8fCA1MDA7XFxuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xcbiAgICAgIHRoaXMudGltZXIgPSB0aGlzLl9kZWxheShmdW5jdGlvbiAoKSB7XFxuICAgICAgICB0aGlzLl9yZXBlYXQoNDAsIHN0ZXBzLCBldmVudCk7XFxuICAgICAgfSwgaSk7XFxuXFxuICAgICAgdGhpcy5fc3BpbihzdGVwcyAqIHRoaXMub3B0aW9ucy5zdGVwLCBldmVudCk7XFxuICAgIH0sXFxuICAgIF9zcGluOiBmdW5jdGlvbiBfc3BpbihzdGVwLCBldmVudCkge1xcbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWUoKSB8fCAwO1xcblxcbiAgICAgIGlmICghdGhpcy5jb3VudGVyKSB7XFxuICAgICAgICB0aGlzLmNvdW50ZXIgPSAxO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YWx1ZSA9IHRoaXMuX2FkanVzdFZhbHVlKHZhbHVlICsgc3RlcCAqIHRoaXMuX2luY3JlbWVudCh0aGlzLmNvdW50ZXIpKTtcXG5cXG4gICAgICBpZiAoIXRoaXMuc3Bpbm5pbmcgfHwgdGhpcy5fdHJpZ2dlcihcXFwic3BpblxcXCIsIGV2ZW50LCB7XFxuICAgICAgICB2YWx1ZTogdmFsdWVcXG4gICAgICB9KSAhPT0gZmFsc2UpIHtcXG4gICAgICAgIHRoaXMuX3ZhbHVlKHZhbHVlKTtcXG5cXG4gICAgICAgIHRoaXMuY291bnRlcisrO1xcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgX2luY3JlbWVudDogZnVuY3Rpb24gX2luY3JlbWVudChpKSB7XFxuICAgICAgdmFyIGluY3JlbWVudGFsID0gdGhpcy5vcHRpb25zLmluY3JlbWVudGFsO1xcblxcbiAgICAgIGlmIChpbmNyZW1lbnRhbCkge1xcbiAgICAgICAgcmV0dXJuICQuaXNGdW5jdGlvbihpbmNyZW1lbnRhbCkgPyBpbmNyZW1lbnRhbChpKSA6IE1hdGguZmxvb3IoaSAqIGkgKiBpIC8gNTAwMDAgLSBpICogaSAvIDUwMCArIDE3ICogaSAvIDIwMCArIDEpO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gMTtcXG4gICAgfSxcXG4gICAgX3ByZWNpc2lvbjogZnVuY3Rpb24gX3ByZWNpc2lvbigpIHtcXG4gICAgICB2YXIgcHJlY2lzaW9uID0gdGhpcy5fcHJlY2lzaW9uT2YodGhpcy5vcHRpb25zLnN0ZXApO1xcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubWluICE9PSBudWxsKSB7XFxuICAgICAgICBwcmVjaXNpb24gPSBNYXRoLm1heChwcmVjaXNpb24sIHRoaXMuX3ByZWNpc2lvbk9mKHRoaXMub3B0aW9ucy5taW4pKTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHByZWNpc2lvbjtcXG4gICAgfSxcXG4gICAgX3ByZWNpc2lvbk9mOiBmdW5jdGlvbiBfcHJlY2lzaW9uT2YobnVtKSB7XFxuICAgICAgdmFyIHN0ciA9IG51bS50b1N0cmluZygpLFxcbiAgICAgICAgICBkZWNpbWFsID0gc3RyLmluZGV4T2YoXFxcIi5cXFwiKTtcXG4gICAgICByZXR1cm4gZGVjaW1hbCA9PT0gLTEgPyAwIDogc3RyLmxlbmd0aCAtIGRlY2ltYWwgLSAxO1xcbiAgICB9LFxcbiAgICBfYWRqdXN0VmFsdWU6IGZ1bmN0aW9uIF9hZGp1c3RWYWx1ZSh2YWx1ZSkge1xcbiAgICAgIHZhciBiYXNlLFxcbiAgICAgICAgICBhYm92ZU1pbixcXG4gICAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9uczsgLy8gbWFrZSBzdXJlIHdlJ3JlIGF0IGEgdmFsaWQgc3RlcFxcbiAgICAgIC8vIC0gZmluZCBvdXQgd2hlcmUgd2UgYXJlIHJlbGF0aXZlIHRvIHRoZSBiYXNlIChtaW4gb3IgMClcXG5cXG4gICAgICBiYXNlID0gb3B0aW9ucy5taW4gIT09IG51bGwgPyBvcHRpb25zLm1pbiA6IDA7XFxuICAgICAgYWJvdmVNaW4gPSB2YWx1ZSAtIGJhc2U7IC8vIC0gcm91bmQgdG8gdGhlIG5lYXJlc3Qgc3RlcFxcblxcbiAgICAgIGFib3ZlTWluID0gTWF0aC5yb3VuZChhYm92ZU1pbiAvIG9wdGlvbnMuc3RlcCkgKiBvcHRpb25zLnN0ZXA7IC8vIC0gcm91bmRpbmcgaXMgYmFzZWQgb24gMCwgc28gYWRqdXN0IGJhY2sgdG8gb3VyIGJhc2VcXG5cXG4gICAgICB2YWx1ZSA9IGJhc2UgKyBhYm92ZU1pbjsgLy8gZml4IHByZWNpc2lvbiBmcm9tIGJhZCBKUyBmbG9hdGluZyBwb2ludCBtYXRoXFxuXFxuICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlLnRvRml4ZWQodGhpcy5fcHJlY2lzaW9uKCkpKTsgLy8gY2xhbXAgdGhlIHZhbHVlXFxuXFxuICAgICAgaWYgKG9wdGlvbnMubWF4ICE9PSBudWxsICYmIHZhbHVlID4gb3B0aW9ucy5tYXgpIHtcXG4gICAgICAgIHJldHVybiBvcHRpb25zLm1heDtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKG9wdGlvbnMubWluICE9PSBudWxsICYmIHZhbHVlIDwgb3B0aW9ucy5taW4pIHtcXG4gICAgICAgIHJldHVybiBvcHRpb25zLm1pbjtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHZhbHVlO1xcbiAgICB9LFxcbiAgICBfc3RvcDogZnVuY3Rpb24gX3N0b3AoZXZlbnQpIHtcXG4gICAgICBpZiAoIXRoaXMuc3Bpbm5pbmcpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLm1vdXNld2hlZWxUaW1lcik7XFxuICAgICAgdGhpcy5jb3VudGVyID0gMDtcXG4gICAgICB0aGlzLnNwaW5uaW5nID0gZmFsc2U7XFxuXFxuICAgICAgdGhpcy5fdHJpZ2dlcihcXFwic3RvcFxcXCIsIGV2ZW50KTtcXG4gICAgfSxcXG4gICAgX3NldE9wdGlvbjogZnVuY3Rpb24gX3NldE9wdGlvbihrZXksIHZhbHVlKSB7XFxuICAgICAgaWYgKGtleSA9PT0gXFxcImN1bHR1cmVcXFwiIHx8IGtleSA9PT0gXFxcIm51bWJlckZvcm1hdFxcXCIpIHtcXG4gICAgICAgIHZhciBwcmV2VmFsdWUgPSB0aGlzLl9wYXJzZSh0aGlzLmVsZW1lbnQudmFsKCkpO1xcblxcbiAgICAgICAgdGhpcy5vcHRpb25zW2tleV0gPSB2YWx1ZTtcXG4gICAgICAgIHRoaXMuZWxlbWVudC52YWwodGhpcy5fZm9ybWF0KHByZXZWYWx1ZSkpO1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoa2V5ID09PSBcXFwibWF4XFxcIiB8fCBrZXkgPT09IFxcXCJtaW5cXFwiIHx8IGtleSA9PT0gXFxcInN0ZXBcXFwiKSB7XFxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcXFwic3RyaW5nXFxcIikge1xcbiAgICAgICAgICB2YWx1ZSA9IHRoaXMuX3BhcnNlKHZhbHVlKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGtleSA9PT0gXFxcImljb25zXFxcIikge1xcbiAgICAgICAgdGhpcy5idXR0b25zLmZpcnN0KCkuZmluZChcXFwiLnVpLWljb25cXFwiKS5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuaWNvbnMudXApLmFkZENsYXNzKHZhbHVlLnVwKTtcXG4gICAgICAgIHRoaXMuYnV0dG9ucy5sYXN0KCkuZmluZChcXFwiLnVpLWljb25cXFwiKS5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuaWNvbnMuZG93bikuYWRkQ2xhc3ModmFsdWUuZG93bik7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX3N1cGVyKGtleSwgdmFsdWUpO1xcblxcbiAgICAgIGlmIChrZXkgPT09IFxcXCJkaXNhYmxlZFxcXCIpIHtcXG4gICAgICAgIHRoaXMud2lkZ2V0KCkudG9nZ2xlQ2xhc3MoXFxcInVpLXN0YXRlLWRpc2FibGVkXFxcIiwgISF2YWx1ZSk7XFxuICAgICAgICB0aGlzLmVsZW1lbnQucHJvcChcXFwiZGlzYWJsZWRcXFwiLCAhIXZhbHVlKTtcXG4gICAgICAgIHRoaXMuYnV0dG9ucy5idXR0b24odmFsdWUgPyBcXFwiZGlzYWJsZVxcXCIgOiBcXFwiZW5hYmxlXFxcIik7XFxuICAgICAgfVxcbiAgICB9LFxcbiAgICBfc2V0T3B0aW9uczogc3Bpbm5lcl9tb2RpZmllcihmdW5jdGlvbiAob3B0aW9ucykge1xcbiAgICAgIHRoaXMuX3N1cGVyKG9wdGlvbnMpO1xcbiAgICB9KSxcXG4gICAgX3BhcnNlOiBmdW5jdGlvbiBfcGFyc2UodmFsKSB7XFxuICAgICAgaWYgKHR5cGVvZiB2YWwgPT09IFxcXCJzdHJpbmdcXFwiICYmIHZhbCAhPT0gXFxcIlxcXCIpIHtcXG4gICAgICAgIHZhbCA9IHdpbmRvdy5HbG9iYWxpemUgJiYgdGhpcy5vcHRpb25zLm51bWJlckZvcm1hdCA/IEdsb2JhbGl6ZS5wYXJzZUZsb2F0KHZhbCwgMTAsIHRoaXMub3B0aW9ucy5jdWx0dXJlKSA6ICt2YWw7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiB2YWwgPT09IFxcXCJcXFwiIHx8IGlzTmFOKHZhbCkgPyBudWxsIDogdmFsO1xcbiAgICB9LFxcbiAgICBfZm9ybWF0OiBmdW5jdGlvbiBfZm9ybWF0KHZhbHVlKSB7XFxuICAgICAgaWYgKHZhbHVlID09PSBcXFwiXFxcIikge1xcbiAgICAgICAgcmV0dXJuIFxcXCJcXFwiO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gd2luZG93Lkdsb2JhbGl6ZSAmJiB0aGlzLm9wdGlvbnMubnVtYmVyRm9ybWF0ID8gR2xvYmFsaXplLmZvcm1hdCh2YWx1ZSwgdGhpcy5vcHRpb25zLm51bWJlckZvcm1hdCwgdGhpcy5vcHRpb25zLmN1bHR1cmUpIDogdmFsdWU7XFxuICAgIH0sXFxuICAgIF9yZWZyZXNoOiBmdW5jdGlvbiBfcmVmcmVzaCgpIHtcXG4gICAgICB0aGlzLmVsZW1lbnQuYXR0cih7XFxuICAgICAgICBcXFwiYXJpYS12YWx1ZW1pblxcXCI6IHRoaXMub3B0aW9ucy5taW4sXFxuICAgICAgICBcXFwiYXJpYS12YWx1ZW1heFxcXCI6IHRoaXMub3B0aW9ucy5tYXgsXFxuICAgICAgICAvLyBUT0RPOiB3aGF0IHNob3VsZCB3ZSBkbyB3aXRoIHZhbHVlcyB0aGF0IGNhbid0IGJlIHBhcnNlZD9cXG4gICAgICAgIFxcXCJhcmlhLXZhbHVlbm93XFxcIjogdGhpcy5fcGFyc2UodGhpcy5lbGVtZW50LnZhbCgpKVxcbiAgICAgIH0pO1xcbiAgICB9LFxcbiAgICBpc1ZhbGlkOiBmdW5jdGlvbiBpc1ZhbGlkKCkge1xcbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWUoKTsgLy8gbnVsbCBpcyBpbnZhbGlkXFxuXFxuICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfSAvLyBpZiB2YWx1ZSBnZXRzIGFkanVzdGVkLCBpdCdzIGludmFsaWRcXG5cXG5cXG4gICAgICByZXR1cm4gdmFsdWUgPT09IHRoaXMuX2FkanVzdFZhbHVlKHZhbHVlKTtcXG4gICAgfSxcXG4gICAgLy8gdXBkYXRlIHRoZSB2YWx1ZSB3aXRob3V0IHRyaWdnZXJpbmcgY2hhbmdlXFxuICAgIF92YWx1ZTogZnVuY3Rpb24gX3ZhbHVlKHZhbHVlLCBhbGxvd0FueSkge1xcbiAgICAgIHZhciBwYXJzZWQ7XFxuXFxuICAgICAgaWYgKHZhbHVlICE9PSBcXFwiXFxcIikge1xcbiAgICAgICAgcGFyc2VkID0gdGhpcy5fcGFyc2UodmFsdWUpO1xcblxcbiAgICAgICAgaWYgKHBhcnNlZCAhPT0gbnVsbCkge1xcbiAgICAgICAgICBpZiAoIWFsbG93QW55KSB7XFxuICAgICAgICAgICAgcGFyc2VkID0gdGhpcy5fYWRqdXN0VmFsdWUocGFyc2VkKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICB2YWx1ZSA9IHRoaXMuX2Zvcm1hdChwYXJzZWQpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLmVsZW1lbnQudmFsKHZhbHVlKTtcXG5cXG4gICAgICB0aGlzLl9yZWZyZXNoKCk7XFxuICAgIH0sXFxuICAgIF9kZXN0cm95OiBmdW5jdGlvbiBfZGVzdHJveSgpIHtcXG4gICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlQ2xhc3MoXFxcInVpLXNwaW5uZXItaW5wdXRcXFwiKS5wcm9wKFxcXCJkaXNhYmxlZFxcXCIsIGZhbHNlKS5yZW1vdmVBdHRyKFxcXCJhdXRvY29tcGxldGVcXFwiKS5yZW1vdmVBdHRyKFxcXCJyb2xlXFxcIikucmVtb3ZlQXR0cihcXFwiYXJpYS12YWx1ZW1pblxcXCIpLnJlbW92ZUF0dHIoXFxcImFyaWEtdmFsdWVtYXhcXFwiKS5yZW1vdmVBdHRyKFxcXCJhcmlhLXZhbHVlbm93XFxcIik7XFxuICAgICAgdGhpcy51aVNwaW5uZXIucmVwbGFjZVdpdGgodGhpcy5lbGVtZW50KTtcXG4gICAgfSxcXG4gICAgc3RlcFVwOiBzcGlubmVyX21vZGlmaWVyKGZ1bmN0aW9uIChzdGVwcykge1xcbiAgICAgIHRoaXMuX3N0ZXBVcChzdGVwcyk7XFxuICAgIH0pLFxcbiAgICBfc3RlcFVwOiBmdW5jdGlvbiBfc3RlcFVwKHN0ZXBzKSB7XFxuICAgICAgaWYgKHRoaXMuX3N0YXJ0KCkpIHtcXG4gICAgICAgIHRoaXMuX3NwaW4oKHN0ZXBzIHx8IDEpICogdGhpcy5vcHRpb25zLnN0ZXApO1xcblxcbiAgICAgICAgdGhpcy5fc3RvcCgpO1xcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgc3RlcERvd246IHNwaW5uZXJfbW9kaWZpZXIoZnVuY3Rpb24gKHN0ZXBzKSB7XFxuICAgICAgdGhpcy5fc3RlcERvd24oc3RlcHMpO1xcbiAgICB9KSxcXG4gICAgX3N0ZXBEb3duOiBmdW5jdGlvbiBfc3RlcERvd24oc3RlcHMpIHtcXG4gICAgICBpZiAodGhpcy5fc3RhcnQoKSkge1xcbiAgICAgICAgdGhpcy5fc3Bpbigoc3RlcHMgfHwgMSkgKiAtdGhpcy5vcHRpb25zLnN0ZXApO1xcblxcbiAgICAgICAgdGhpcy5fc3RvcCgpO1xcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgcGFnZVVwOiBzcGlubmVyX21vZGlmaWVyKGZ1bmN0aW9uIChwYWdlcykge1xcbiAgICAgIHRoaXMuX3N0ZXBVcCgocGFnZXMgfHwgMSkgKiB0aGlzLm9wdGlvbnMucGFnZSk7XFxuICAgIH0pLFxcbiAgICBwYWdlRG93bjogc3Bpbm5lcl9tb2RpZmllcihmdW5jdGlvbiAocGFnZXMpIHtcXG4gICAgICB0aGlzLl9zdGVwRG93bigocGFnZXMgfHwgMSkgKiB0aGlzLm9wdGlvbnMucGFnZSk7XFxuICAgIH0pLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUobmV3VmFsKSB7XFxuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5fcGFyc2UodGhpcy5lbGVtZW50LnZhbCgpKTtcXG4gICAgICB9XFxuXFxuICAgICAgc3Bpbm5lcl9tb2RpZmllcih0aGlzLl92YWx1ZSkuY2FsbCh0aGlzLCBuZXdWYWwpO1xcbiAgICB9LFxcbiAgICB3aWRnZXQ6IGZ1bmN0aW9uIHdpZGdldCgpIHtcXG4gICAgICByZXR1cm4gdGhpcy51aVNwaW5uZXI7XFxuICAgIH1cXG4gIH0pO1xcbiAgLyohXFxuICAgKiBqUXVlcnkgVUkgVGFicyAxLjExLjRcXG4gICAqIGh0dHA6Ly9qcXVlcnl1aS5jb21cXG4gICAqXFxuICAgKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xcbiAgICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxcbiAgICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxcbiAgICpcXG4gICAqIGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL3RhYnMvXFxuICAgKi9cXG5cXG4gIHZhciB0YWJzID0gJC53aWRnZXQoXFxcInVpLnRhYnNcXFwiLCB7XFxuICAgIHZlcnNpb246IFxcXCIxLjExLjRcXFwiLFxcbiAgICBkZWxheTogMzAwLFxcbiAgICBvcHRpb25zOiB7XFxuICAgICAgYWN0aXZlOiBudWxsLFxcbiAgICAgIGNvbGxhcHNpYmxlOiBmYWxzZSxcXG4gICAgICBldmVudDogXFxcImNsaWNrXFxcIixcXG4gICAgICBoZWlnaHRTdHlsZTogXFxcImNvbnRlbnRcXFwiLFxcbiAgICAgIGhpZGU6IG51bGwsXFxuICAgICAgc2hvdzogbnVsbCxcXG4gICAgICAvLyBjYWxsYmFja3NcXG4gICAgICBhY3RpdmF0ZTogbnVsbCxcXG4gICAgICBiZWZvcmVBY3RpdmF0ZTogbnVsbCxcXG4gICAgICBiZWZvcmVMb2FkOiBudWxsLFxcbiAgICAgIGxvYWQ6IG51bGxcXG4gICAgfSxcXG4gICAgX2lzTG9jYWw6IGZ1bmN0aW9uICgpIHtcXG4gICAgICB2YXIgcmhhc2ggPSAvIy4qJC87XFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhbmNob3IpIHtcXG4gICAgICAgIHZhciBhbmNob3JVcmwsIGxvY2F0aW9uVXJsOyAvLyBzdXBwb3J0OiBJRTdcXG4gICAgICAgIC8vIElFNyBkb2Vzbid0IG5vcm1hbGl6ZSB0aGUgaHJlZiBwcm9wZXJ0eSB3aGVuIHNldCB2aWEgc2NyaXB0ICgjOTMxNylcXG5cXG4gICAgICAgIGFuY2hvciA9IGFuY2hvci5jbG9uZU5vZGUoZmFsc2UpO1xcbiAgICAgICAgYW5jaG9yVXJsID0gYW5jaG9yLmhyZWYucmVwbGFjZShyaGFzaCwgXFxcIlxcXCIpO1xcbiAgICAgICAgbG9jYXRpb25VcmwgPSBsb2NhdGlvbi5ocmVmLnJlcGxhY2Uocmhhc2gsIFxcXCJcXFwiKTsgLy8gZGVjb2RpbmcgbWF5IHRocm93IGFuIGVycm9yIGlmIHRoZSBVUkwgaXNuJ3QgVVRGLTggKCM5NTE4KVxcblxcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgYW5jaG9yVXJsID0gZGVjb2RlVVJJQ29tcG9uZW50KGFuY2hvclVybCk7XFxuICAgICAgICB9IGNhdGNoIChlcnJvcikge31cXG5cXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgIGxvY2F0aW9uVXJsID0gZGVjb2RlVVJJQ29tcG9uZW50KGxvY2F0aW9uVXJsKTtcXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7fVxcblxcbiAgICAgICAgcmV0dXJuIGFuY2hvci5oYXNoLmxlbmd0aCA+IDEgJiYgYW5jaG9yVXJsID09PSBsb2NhdGlvblVybDtcXG4gICAgICB9O1xcbiAgICB9KCksXFxuICAgIF9jcmVhdGU6IGZ1bmN0aW9uIF9jcmVhdGUoKSB7XFxuICAgICAgdmFyIHRoYXQgPSB0aGlzLFxcbiAgICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xcbiAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xcbiAgICAgIHRoaXMuZWxlbWVudC5hZGRDbGFzcyhcXFwidWktdGFicyB1aS13aWRnZXQgdWktd2lkZ2V0LWNvbnRlbnQgdWktY29ybmVyLWFsbFxcXCIpLnRvZ2dsZUNsYXNzKFxcXCJ1aS10YWJzLWNvbGxhcHNpYmxlXFxcIiwgb3B0aW9ucy5jb2xsYXBzaWJsZSk7XFxuXFxuICAgICAgdGhpcy5fcHJvY2Vzc1RhYnMoKTtcXG5cXG4gICAgICBvcHRpb25zLmFjdGl2ZSA9IHRoaXMuX2luaXRpYWxBY3RpdmUoKTsgLy8gVGFrZSBkaXNhYmxpbmcgdGFicyB2aWEgY2xhc3MgYXR0cmlidXRlIGZyb20gSFRNTFxcbiAgICAgIC8vIGludG8gYWNjb3VudCBhbmQgdXBkYXRlIG9wdGlvbiBwcm9wZXJseS5cXG5cXG4gICAgICBpZiAoJC5pc0FycmF5KG9wdGlvbnMuZGlzYWJsZWQpKSB7XFxuICAgICAgICBvcHRpb25zLmRpc2FibGVkID0gJC51bmlxdWUob3B0aW9ucy5kaXNhYmxlZC5jb25jYXQoJC5tYXAodGhpcy50YWJzLmZpbHRlcihcXFwiLnVpLXN0YXRlLWRpc2FibGVkXFxcIiksIGZ1bmN0aW9uIChsaSkge1xcbiAgICAgICAgICByZXR1cm4gdGhhdC50YWJzLmluZGV4KGxpKTtcXG4gICAgICAgIH0pKSkuc29ydCgpO1xcbiAgICAgIH0gLy8gY2hlY2sgZm9yIGxlbmd0aCBhdm9pZHMgZXJyb3Igd2hlbiBpbml0aWFsaXppbmcgZW1wdHkgbGlzdFxcblxcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYWN0aXZlICE9PSBmYWxzZSAmJiB0aGlzLmFuY2hvcnMubGVuZ3RoKSB7XFxuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRoaXMuX2ZpbmRBY3RpdmUob3B0aW9ucy5hY3RpdmUpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB0aGlzLmFjdGl2ZSA9ICQoKTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fcmVmcmVzaCgpO1xcblxcbiAgICAgIGlmICh0aGlzLmFjdGl2ZS5sZW5ndGgpIHtcXG4gICAgICAgIHRoaXMubG9hZChvcHRpb25zLmFjdGl2ZSk7XFxuICAgICAgfVxcbiAgICB9LFxcbiAgICBfaW5pdGlhbEFjdGl2ZTogZnVuY3Rpb24gX2luaXRpYWxBY3RpdmUoKSB7XFxuICAgICAgdmFyIGFjdGl2ZSA9IHRoaXMub3B0aW9ucy5hY3RpdmUsXFxuICAgICAgICAgIGNvbGxhcHNpYmxlID0gdGhpcy5vcHRpb25zLmNvbGxhcHNpYmxlLFxcbiAgICAgICAgICBsb2NhdGlvbkhhc2ggPSBsb2NhdGlvbi5oYXNoLnN1YnN0cmluZygxKTtcXG5cXG4gICAgICBpZiAoYWN0aXZlID09PSBudWxsKSB7XFxuICAgICAgICAvLyBjaGVjayB0aGUgZnJhZ21lbnQgaWRlbnRpZmllciBpbiB0aGUgVVJMXFxuICAgICAgICBpZiAobG9jYXRpb25IYXNoKSB7XFxuICAgICAgICAgIHRoaXMudGFicy5lYWNoKGZ1bmN0aW9uIChpLCB0YWIpIHtcXG4gICAgICAgICAgICBpZiAoJCh0YWIpLmF0dHIoXFxcImFyaWEtY29udHJvbHNcXFwiKSA9PT0gbG9jYXRpb25IYXNoKSB7XFxuICAgICAgICAgICAgICBhY3RpdmUgPSBpO1xcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9IC8vIGNoZWNrIGZvciBhIHRhYiBtYXJrZWQgYWN0aXZlIHZpYSBhIGNsYXNzXFxuXFxuXFxuICAgICAgICBpZiAoYWN0aXZlID09PSBudWxsKSB7XFxuICAgICAgICAgIGFjdGl2ZSA9IHRoaXMudGFicy5pbmRleCh0aGlzLnRhYnMuZmlsdGVyKFxcXCIudWktdGFicy1hY3RpdmVcXFwiKSk7XFxuICAgICAgICB9IC8vIG5vIGFjdGl2ZSB0YWIsIHNldCB0byBmYWxzZVxcblxcblxcbiAgICAgICAgaWYgKGFjdGl2ZSA9PT0gbnVsbCB8fCBhY3RpdmUgPT09IC0xKSB7XFxuICAgICAgICAgIGFjdGl2ZSA9IHRoaXMudGFicy5sZW5ndGggPyAwIDogZmFsc2U7XFxuICAgICAgICB9XFxuICAgICAgfSAvLyBoYW5kbGUgbnVtYmVyczogbmVnYXRpdmUsIG91dCBvZiByYW5nZVxcblxcblxcbiAgICAgIGlmIChhY3RpdmUgIT09IGZhbHNlKSB7XFxuICAgICAgICBhY3RpdmUgPSB0aGlzLnRhYnMuaW5kZXgodGhpcy50YWJzLmVxKGFjdGl2ZSkpO1xcblxcbiAgICAgICAgaWYgKGFjdGl2ZSA9PT0gLTEpIHtcXG4gICAgICAgICAgYWN0aXZlID0gY29sbGFwc2libGUgPyBmYWxzZSA6IDA7XFxuICAgICAgICB9XFxuICAgICAgfSAvLyBkb24ndCBhbGxvdyBjb2xsYXBzaWJsZTogZmFsc2UgYW5kIGFjdGl2ZTogZmFsc2VcXG5cXG5cXG4gICAgICBpZiAoIWNvbGxhcHNpYmxlICYmIGFjdGl2ZSA9PT0gZmFsc2UgJiYgdGhpcy5hbmNob3JzLmxlbmd0aCkge1xcbiAgICAgICAgYWN0aXZlID0gMDtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIGFjdGl2ZTtcXG4gICAgfSxcXG4gICAgX2dldENyZWF0ZUV2ZW50RGF0YTogZnVuY3Rpb24gX2dldENyZWF0ZUV2ZW50RGF0YSgpIHtcXG4gICAgICByZXR1cm4ge1xcbiAgICAgICAgdGFiOiB0aGlzLmFjdGl2ZSxcXG4gICAgICAgIHBhbmVsOiAhdGhpcy5hY3RpdmUubGVuZ3RoID8gJCgpIDogdGhpcy5fZ2V0UGFuZWxGb3JUYWIodGhpcy5hY3RpdmUpXFxuICAgICAgfTtcXG4gICAgfSxcXG4gICAgX3RhYktleWRvd246IGZ1bmN0aW9uIF90YWJLZXlkb3duKGV2ZW50KSB7XFxuICAgICAgdmFyIGZvY3VzZWRUYWIgPSAkKHRoaXMuZG9jdW1lbnRbMF0uYWN0aXZlRWxlbWVudCkuY2xvc2VzdChcXFwibGlcXFwiKSxcXG4gICAgICAgICAgc2VsZWN0ZWRJbmRleCA9IHRoaXMudGFicy5pbmRleChmb2N1c2VkVGFiKSxcXG4gICAgICAgICAgZ29pbmdGb3J3YXJkID0gdHJ1ZTtcXG5cXG4gICAgICBpZiAodGhpcy5faGFuZGxlUGFnZU5hdihldmVudCkpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgc3dpdGNoIChldmVudC5rZXlDb2RlKSB7XFxuICAgICAgICBjYXNlICQudWkua2V5Q29kZS5SSUdIVDpcXG4gICAgICAgIGNhc2UgJC51aS5rZXlDb2RlLkRPV046XFxuICAgICAgICAgIHNlbGVjdGVkSW5kZXgrKztcXG4gICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICBjYXNlICQudWkua2V5Q29kZS5VUDpcXG4gICAgICAgIGNhc2UgJC51aS5rZXlDb2RlLkxFRlQ6XFxuICAgICAgICAgIGdvaW5nRm9yd2FyZCA9IGZhbHNlO1xcbiAgICAgICAgICBzZWxlY3RlZEluZGV4LS07XFxuICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgY2FzZSAkLnVpLmtleUNvZGUuRU5EOlxcbiAgICAgICAgICBzZWxlY3RlZEluZGV4ID0gdGhpcy5hbmNob3JzLmxlbmd0aCAtIDE7XFxuICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgY2FzZSAkLnVpLmtleUNvZGUuSE9NRTpcXG4gICAgICAgICAgc2VsZWN0ZWRJbmRleCA9IDA7XFxuICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgY2FzZSAkLnVpLmtleUNvZGUuU1BBQ0U6XFxuICAgICAgICAgIC8vIEFjdGl2YXRlIG9ubHksIG5vIGNvbGxhcHNpbmdcXG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuYWN0aXZhdGluZyk7XFxuXFxuICAgICAgICAgIHRoaXMuX2FjdGl2YXRlKHNlbGVjdGVkSW5kZXgpO1xcblxcbiAgICAgICAgICByZXR1cm47XFxuXFxuICAgICAgICBjYXNlICQudWkua2V5Q29kZS5FTlRFUjpcXG4gICAgICAgICAgLy8gVG9nZ2xlIChjYW5jZWwgZGVsYXllZCBhY3RpdmF0aW9uLCBhbGxvdyBjb2xsYXBzaW5nKVxcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5hY3RpdmF0aW5nKTsgLy8gRGV0ZXJtaW5lIGlmIHdlIHNob3VsZCBjb2xsYXBzZSBvciBhY3RpdmF0ZVxcblxcbiAgICAgICAgICB0aGlzLl9hY3RpdmF0ZShzZWxlY3RlZEluZGV4ID09PSB0aGlzLm9wdGlvbnMuYWN0aXZlID8gZmFsc2UgOiBzZWxlY3RlZEluZGV4KTtcXG5cXG4gICAgICAgICAgcmV0dXJuO1xcblxcbiAgICAgICAgZGVmYXVsdDpcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgIH0gLy8gRm9jdXMgdGhlIGFwcHJvcHJpYXRlIHRhYiwgYmFzZWQgb24gd2hpY2gga2V5IHdhcyBwcmVzc2VkXFxuXFxuXFxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5hY3RpdmF0aW5nKTtcXG4gICAgICBzZWxlY3RlZEluZGV4ID0gdGhpcy5fZm9jdXNOZXh0VGFiKHNlbGVjdGVkSW5kZXgsIGdvaW5nRm9yd2FyZCk7IC8vIE5hdmlnYXRpbmcgd2l0aCBjb250cm9sL2NvbW1hbmQga2V5IHdpbGwgcHJldmVudCBhdXRvbWF0aWMgYWN0aXZhdGlvblxcblxcbiAgICAgIGlmICghZXZlbnQuY3RybEtleSAmJiAhZXZlbnQubWV0YUtleSkge1xcbiAgICAgICAgLy8gVXBkYXRlIGFyaWEtc2VsZWN0ZWQgaW1tZWRpYXRlbHkgc28gdGhhdCBBVCB0aGluayB0aGUgdGFiIGlzIGFscmVhZHkgc2VsZWN0ZWQuXFxuICAgICAgICAvLyBPdGhlcndpc2UgQVQgbWF5IGNvbmZ1c2UgdGhlIHVzZXIgYnkgc3RhdGluZyB0aGF0IHRoZXkgbmVlZCB0byBhY3RpdmF0ZSB0aGUgdGFiLFxcbiAgICAgICAgLy8gYnV0IHRoZSB0YWIgd2lsbCBhbHJlYWR5IGJlIGFjdGl2YXRlZCBieSB0aGUgdGltZSB0aGUgYW5ub3VuY2VtZW50IGZpbmlzaGVzLlxcbiAgICAgICAgZm9jdXNlZFRhYi5hdHRyKFxcXCJhcmlhLXNlbGVjdGVkXFxcIiwgXFxcImZhbHNlXFxcIik7XFxuICAgICAgICB0aGlzLnRhYnMuZXEoc2VsZWN0ZWRJbmRleCkuYXR0cihcXFwiYXJpYS1zZWxlY3RlZFxcXCIsIFxcXCJ0cnVlXFxcIik7XFxuICAgICAgICB0aGlzLmFjdGl2YXRpbmcgPSB0aGlzLl9kZWxheShmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHRoaXMub3B0aW9uKFxcXCJhY3RpdmVcXFwiLCBzZWxlY3RlZEluZGV4KTtcXG4gICAgICAgIH0sIHRoaXMuZGVsYXkpO1xcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgX3BhbmVsS2V5ZG93bjogZnVuY3Rpb24gX3BhbmVsS2V5ZG93bihldmVudCkge1xcbiAgICAgIGlmICh0aGlzLl9oYW5kbGVQYWdlTmF2KGV2ZW50KSkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH0gLy8gQ3RybCt1cCBtb3ZlcyBmb2N1cyB0byB0aGUgY3VycmVudCB0YWJcXG5cXG5cXG4gICAgICBpZiAoZXZlbnQuY3RybEtleSAmJiBldmVudC5rZXlDb2RlID09PSAkLnVpLmtleUNvZGUuVVApIHtcXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICB0aGlzLmFjdGl2ZS5mb2N1cygpO1xcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgLy8gQWx0K3BhZ2UgdXAvZG93biBtb3ZlcyBmb2N1cyB0byB0aGUgcHJldmlvdXMvbmV4dCB0YWIgKGFuZCBhY3RpdmF0ZXMpXFxuICAgIF9oYW5kbGVQYWdlTmF2OiBmdW5jdGlvbiBfaGFuZGxlUGFnZU5hdihldmVudCkge1xcbiAgICAgIGlmIChldmVudC5hbHRLZXkgJiYgZXZlbnQua2V5Q29kZSA9PT0gJC51aS5rZXlDb2RlLlBBR0VfVVApIHtcXG4gICAgICAgIHRoaXMuX2FjdGl2YXRlKHRoaXMuX2ZvY3VzTmV4dFRhYih0aGlzLm9wdGlvbnMuYWN0aXZlIC0gMSwgZmFsc2UpKTtcXG5cXG4gICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoZXZlbnQuYWx0S2V5ICYmIGV2ZW50LmtleUNvZGUgPT09ICQudWkua2V5Q29kZS5QQUdFX0RPV04pIHtcXG4gICAgICAgIHRoaXMuX2FjdGl2YXRlKHRoaXMuX2ZvY3VzTmV4dFRhYih0aGlzLm9wdGlvbnMuYWN0aXZlICsgMSwgdHJ1ZSkpO1xcblxcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgfVxcbiAgICB9LFxcbiAgICBfZmluZE5leHRUYWI6IGZ1bmN0aW9uIF9maW5kTmV4dFRhYihpbmRleCwgZ29pbmdGb3J3YXJkKSB7XFxuICAgICAgdmFyIGxhc3RUYWJJbmRleCA9IHRoaXMudGFicy5sZW5ndGggLSAxO1xcblxcbiAgICAgIGZ1bmN0aW9uIGNvbnN0cmFpbigpIHtcXG4gICAgICAgIGlmIChpbmRleCA+IGxhc3RUYWJJbmRleCkge1xcbiAgICAgICAgICBpbmRleCA9IDA7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoaW5kZXggPCAwKSB7XFxuICAgICAgICAgIGluZGV4ID0gbGFzdFRhYkluZGV4O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIGluZGV4O1xcbiAgICAgIH1cXG5cXG4gICAgICB3aGlsZSAoJC5pbkFycmF5KGNvbnN0cmFpbigpLCB0aGlzLm9wdGlvbnMuZGlzYWJsZWQpICE9PSAtMSkge1xcbiAgICAgICAgaW5kZXggPSBnb2luZ0ZvcndhcmQgPyBpbmRleCArIDEgOiBpbmRleCAtIDE7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBpbmRleDtcXG4gICAgfSxcXG4gICAgX2ZvY3VzTmV4dFRhYjogZnVuY3Rpb24gX2ZvY3VzTmV4dFRhYihpbmRleCwgZ29pbmdGb3J3YXJkKSB7XFxuICAgICAgaW5kZXggPSB0aGlzLl9maW5kTmV4dFRhYihpbmRleCwgZ29pbmdGb3J3YXJkKTtcXG4gICAgICB0aGlzLnRhYnMuZXEoaW5kZXgpLmZvY3VzKCk7XFxuICAgICAgcmV0dXJuIGluZGV4O1xcbiAgICB9LFxcbiAgICBfc2V0T3B0aW9uOiBmdW5jdGlvbiBfc2V0T3B0aW9uKGtleSwgdmFsdWUpIHtcXG4gICAgICBpZiAoa2V5ID09PSBcXFwiYWN0aXZlXFxcIikge1xcbiAgICAgICAgLy8gX2FjdGl2YXRlKCkgd2lsbCBoYW5kbGUgaW52YWxpZCB2YWx1ZXMgYW5kIHVwZGF0ZSB0aGlzLm9wdGlvbnNcXG4gICAgICAgIHRoaXMuX2FjdGl2YXRlKHZhbHVlKTtcXG5cXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGtleSA9PT0gXFxcImRpc2FibGVkXFxcIikge1xcbiAgICAgICAgLy8gZG9uJ3QgdXNlIHRoZSB3aWRnZXQgZmFjdG9yeSdzIGRpc2FibGVkIGhhbmRsaW5nXFxuICAgICAgICB0aGlzLl9zZXR1cERpc2FibGVkKHZhbHVlKTtcXG5cXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fc3VwZXIoa2V5LCB2YWx1ZSk7XFxuXFxuICAgICAgaWYgKGtleSA9PT0gXFxcImNvbGxhcHNpYmxlXFxcIikge1xcbiAgICAgICAgdGhpcy5lbGVtZW50LnRvZ2dsZUNsYXNzKFxcXCJ1aS10YWJzLWNvbGxhcHNpYmxlXFxcIiwgdmFsdWUpOyAvLyBTZXR0aW5nIGNvbGxhcHNpYmxlOiBmYWxzZSB3aGlsZSBjb2xsYXBzZWQ7IG9wZW4gZmlyc3QgcGFuZWxcXG5cXG4gICAgICAgIGlmICghdmFsdWUgJiYgdGhpcy5vcHRpb25zLmFjdGl2ZSA9PT0gZmFsc2UpIHtcXG4gICAgICAgICAgdGhpcy5fYWN0aXZhdGUoMCk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChrZXkgPT09IFxcXCJldmVudFxcXCIpIHtcXG4gICAgICAgIHRoaXMuX3NldHVwRXZlbnRzKHZhbHVlKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGtleSA9PT0gXFxcImhlaWdodFN0eWxlXFxcIikge1xcbiAgICAgICAgdGhpcy5fc2V0dXBIZWlnaHRTdHlsZSh2YWx1ZSk7XFxuICAgICAgfVxcbiAgICB9LFxcbiAgICBfc2FuaXRpemVTZWxlY3RvcjogZnVuY3Rpb24gX3Nhbml0aXplU2VsZWN0b3IoaGFzaCkge1xcbiAgICAgIHJldHVybiBoYXNoID8gaGFzaC5yZXBsYWNlKC9bIVxcXCIkJSYnKCkqKywuXFxcXC86Ozw9Pj9AXFxcXFtcXFxcXVxcXFxeYHt8fX5dL2csIFxcXCJcXFxcXFxcXCQmXFxcIikgOiBcXFwiXFxcIjtcXG4gICAgfSxcXG4gICAgcmVmcmVzaDogZnVuY3Rpb24gcmVmcmVzaCgpIHtcXG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcXG4gICAgICAgICAgbGlzID0gdGhpcy50YWJsaXN0LmNoaWxkcmVuKFxcXCI6aGFzKGFbaHJlZl0pXFxcIik7IC8vIGdldCBkaXNhYmxlZCB0YWJzIGZyb20gY2xhc3MgYXR0cmlidXRlIGZyb20gSFRNTFxcbiAgICAgIC8vIHRoaXMgd2lsbCBnZXQgY29udmVydGVkIHRvIGEgYm9vbGVhbiBpZiBuZWVkZWQgaW4gX3JlZnJlc2goKVxcblxcbiAgICAgIG9wdGlvbnMuZGlzYWJsZWQgPSAkLm1hcChsaXMuZmlsdGVyKFxcXCIudWktc3RhdGUtZGlzYWJsZWRcXFwiKSwgZnVuY3Rpb24gKHRhYikge1xcbiAgICAgICAgcmV0dXJuIGxpcy5pbmRleCh0YWIpO1xcbiAgICAgIH0pO1xcblxcbiAgICAgIHRoaXMuX3Byb2Nlc3NUYWJzKCk7IC8vIHdhcyBjb2xsYXBzZWQgb3Igbm8gdGFic1xcblxcblxcbiAgICAgIGlmIChvcHRpb25zLmFjdGl2ZSA9PT0gZmFsc2UgfHwgIXRoaXMuYW5jaG9ycy5sZW5ndGgpIHtcXG4gICAgICAgIG9wdGlvbnMuYWN0aXZlID0gZmFsc2U7XFxuICAgICAgICB0aGlzLmFjdGl2ZSA9ICQoKTsgLy8gd2FzIGFjdGl2ZSwgYnV0IGFjdGl2ZSB0YWIgaXMgZ29uZVxcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5hY3RpdmUubGVuZ3RoICYmICEkLmNvbnRhaW5zKHRoaXMudGFibGlzdFswXSwgdGhpcy5hY3RpdmVbMF0pKSB7XFxuICAgICAgICAvLyBhbGwgcmVtYWluaW5nIHRhYnMgYXJlIGRpc2FibGVkXFxuICAgICAgICBpZiAodGhpcy50YWJzLmxlbmd0aCA9PT0gb3B0aW9ucy5kaXNhYmxlZC5sZW5ndGgpIHtcXG4gICAgICAgICAgb3B0aW9ucy5hY3RpdmUgPSBmYWxzZTtcXG4gICAgICAgICAgdGhpcy5hY3RpdmUgPSAkKCk7IC8vIGFjdGl2YXRlIHByZXZpb3VzIHRhYlxcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgdGhpcy5fYWN0aXZhdGUodGhpcy5fZmluZE5leHRUYWIoTWF0aC5tYXgoMCwgb3B0aW9ucy5hY3RpdmUgLSAxKSwgZmFsc2UpKTtcXG4gICAgICAgIH0gLy8gd2FzIGFjdGl2ZSwgYWN0aXZlIHRhYiBzdGlsbCBleGlzdHNcXG5cXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgLy8gbWFrZSBzdXJlIGFjdGl2ZSBpbmRleCBpcyBjb3JyZWN0XFxuICAgICAgICBvcHRpb25zLmFjdGl2ZSA9IHRoaXMudGFicy5pbmRleCh0aGlzLmFjdGl2ZSk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX3JlZnJlc2goKTtcXG4gICAgfSxcXG4gICAgX3JlZnJlc2g6IGZ1bmN0aW9uIF9yZWZyZXNoKCkge1xcbiAgICAgIHRoaXMuX3NldHVwRGlzYWJsZWQodGhpcy5vcHRpb25zLmRpc2FibGVkKTtcXG5cXG4gICAgICB0aGlzLl9zZXR1cEV2ZW50cyh0aGlzLm9wdGlvbnMuZXZlbnQpO1xcblxcbiAgICAgIHRoaXMuX3NldHVwSGVpZ2h0U3R5bGUodGhpcy5vcHRpb25zLmhlaWdodFN0eWxlKTtcXG5cXG4gICAgICB0aGlzLnRhYnMubm90KHRoaXMuYWN0aXZlKS5hdHRyKHtcXG4gICAgICAgIFxcXCJhcmlhLXNlbGVjdGVkXFxcIjogXFxcImZhbHNlXFxcIixcXG4gICAgICAgIFxcXCJhcmlhLWV4cGFuZGVkXFxcIjogXFxcImZhbHNlXFxcIixcXG4gICAgICAgIHRhYkluZGV4OiAtMVxcbiAgICAgIH0pO1xcbiAgICAgIHRoaXMucGFuZWxzLm5vdCh0aGlzLl9nZXRQYW5lbEZvclRhYih0aGlzLmFjdGl2ZSkpLmhpZGUoKS5hdHRyKHtcXG4gICAgICAgIFxcXCJhcmlhLWhpZGRlblxcXCI6IFxcXCJ0cnVlXFxcIlxcbiAgICAgIH0pOyAvLyBNYWtlIHN1cmUgb25lIHRhYiBpcyBpbiB0aGUgdGFiIG9yZGVyXFxuXFxuICAgICAgaWYgKCF0aGlzLmFjdGl2ZS5sZW5ndGgpIHtcXG4gICAgICAgIHRoaXMudGFicy5lcSgwKS5hdHRyKFxcXCJ0YWJJbmRleFxcXCIsIDApO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB0aGlzLmFjdGl2ZS5hZGRDbGFzcyhcXFwidWktdGFicy1hY3RpdmUgdWktc3RhdGUtYWN0aXZlXFxcIikuYXR0cih7XFxuICAgICAgICAgIFxcXCJhcmlhLXNlbGVjdGVkXFxcIjogXFxcInRydWVcXFwiLFxcbiAgICAgICAgICBcXFwiYXJpYS1leHBhbmRlZFxcXCI6IFxcXCJ0cnVlXFxcIixcXG4gICAgICAgICAgdGFiSW5kZXg6IDBcXG4gICAgICAgIH0pO1xcblxcbiAgICAgICAgdGhpcy5fZ2V0UGFuZWxGb3JUYWIodGhpcy5hY3RpdmUpLnNob3coKS5hdHRyKHtcXG4gICAgICAgICAgXFxcImFyaWEtaGlkZGVuXFxcIjogXFxcImZhbHNlXFxcIlxcbiAgICAgICAgfSk7XFxuICAgICAgfVxcbiAgICB9LFxcbiAgICBfcHJvY2Vzc1RhYnM6IGZ1bmN0aW9uIF9wcm9jZXNzVGFicygpIHtcXG4gICAgICB2YXIgdGhhdCA9IHRoaXMsXFxuICAgICAgICAgIHByZXZUYWJzID0gdGhpcy50YWJzLFxcbiAgICAgICAgICBwcmV2QW5jaG9ycyA9IHRoaXMuYW5jaG9ycyxcXG4gICAgICAgICAgcHJldlBhbmVscyA9IHRoaXMucGFuZWxzO1xcbiAgICAgIHRoaXMudGFibGlzdCA9IHRoaXMuX2dldExpc3QoKS5hZGRDbGFzcyhcXFwidWktdGFicy1uYXYgdWktaGVscGVyLXJlc2V0IHVpLWhlbHBlci1jbGVhcmZpeCB1aS13aWRnZXQtaGVhZGVyIHVpLWNvcm5lci1hbGxcXFwiKS5hdHRyKFxcXCJyb2xlXFxcIiwgXFxcInRhYmxpc3RcXFwiKSAvLyBQcmV2ZW50IHVzZXJzIGZyb20gZm9jdXNpbmcgZGlzYWJsZWQgdGFicyB2aWEgY2xpY2tcXG4gICAgICAuZGVsZWdhdGUoXFxcIj4gbGlcXFwiLCBcXFwibW91c2Vkb3duXFxcIiArIHRoaXMuZXZlbnROYW1lc3BhY2UsIGZ1bmN0aW9uIChldmVudCkge1xcbiAgICAgICAgaWYgKCQodGhpcykuaXMoXFxcIi51aS1zdGF0ZS1kaXNhYmxlZFxcXCIpKSB7XFxuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICB9XFxuICAgICAgfSkgLy8gc3VwcG9ydDogSUUgPDlcXG4gICAgICAvLyBQcmV2ZW50aW5nIHRoZSBkZWZhdWx0IGFjdGlvbiBpbiBtb3VzZWRvd24gZG9lc24ndCBwcmV2ZW50IElFXFxuICAgICAgLy8gZnJvbSBmb2N1c2luZyB0aGUgZWxlbWVudCwgc28gaWYgdGhlIGFuY2hvciBnZXRzIGZvY3VzZWQsIGJsdXIuXFxuICAgICAgLy8gV2UgZG9uJ3QgaGF2ZSB0byB3b3JyeSBhYm91dCBmb2N1c2luZyB0aGUgcHJldmlvdXNseSBmb2N1c2VkXFxuICAgICAgLy8gZWxlbWVudCBzaW5jZSBjbGlja2luZyBvbiBhIG5vbi1mb2N1c2FibGUgZWxlbWVudCBzaG91bGQgZm9jdXNcXG4gICAgICAvLyB0aGUgYm9keSBhbnl3YXkuXFxuICAgICAgLmRlbGVnYXRlKFxcXCIudWktdGFicy1hbmNob3JcXFwiLCBcXFwiZm9jdXNcXFwiICsgdGhpcy5ldmVudE5hbWVzcGFjZSwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgaWYgKCQodGhpcykuY2xvc2VzdChcXFwibGlcXFwiKS5pcyhcXFwiLnVpLXN0YXRlLWRpc2FibGVkXFxcIikpIHtcXG4gICAgICAgICAgdGhpcy5ibHVyKCk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgICAgdGhpcy50YWJzID0gdGhpcy50YWJsaXN0LmZpbmQoXFxcIj4gbGk6aGFzKGFbaHJlZl0pXFxcIikuYWRkQ2xhc3MoXFxcInVpLXN0YXRlLWRlZmF1bHQgdWktY29ybmVyLXRvcFxcXCIpLmF0dHIoe1xcbiAgICAgICAgcm9sZTogXFxcInRhYlxcXCIsXFxuICAgICAgICB0YWJJbmRleDogLTFcXG4gICAgICB9KTtcXG4gICAgICB0aGlzLmFuY2hvcnMgPSB0aGlzLnRhYnMubWFwKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHJldHVybiAkKFxcXCJhXFxcIiwgdGhpcylbMF07XFxuICAgICAgfSkuYWRkQ2xhc3MoXFxcInVpLXRhYnMtYW5jaG9yXFxcIikuYXR0cih7XFxuICAgICAgICByb2xlOiBcXFwicHJlc2VudGF0aW9uXFxcIixcXG4gICAgICAgIHRhYkluZGV4OiAtMVxcbiAgICAgIH0pO1xcbiAgICAgIHRoaXMucGFuZWxzID0gJCgpO1xcbiAgICAgIHRoaXMuYW5jaG9ycy5lYWNoKGZ1bmN0aW9uIChpLCBhbmNob3IpIHtcXG4gICAgICAgIHZhciBzZWxlY3RvcixcXG4gICAgICAgICAgICBwYW5lbCxcXG4gICAgICAgICAgICBwYW5lbElkLFxcbiAgICAgICAgICAgIGFuY2hvcklkID0gJChhbmNob3IpLnVuaXF1ZUlkKCkuYXR0cihcXFwiaWRcXFwiKSxcXG4gICAgICAgICAgICB0YWIgPSAkKGFuY2hvcikuY2xvc2VzdChcXFwibGlcXFwiKSxcXG4gICAgICAgICAgICBvcmlnaW5hbEFyaWFDb250cm9scyA9IHRhYi5hdHRyKFxcXCJhcmlhLWNvbnRyb2xzXFxcIik7IC8vIGlubGluZSB0YWJcXG5cXG4gICAgICAgIGlmICh0aGF0Ll9pc0xvY2FsKGFuY2hvcikpIHtcXG4gICAgICAgICAgc2VsZWN0b3IgPSBhbmNob3IuaGFzaDtcXG4gICAgICAgICAgcGFuZWxJZCA9IHNlbGVjdG9yLnN1YnN0cmluZygxKTtcXG4gICAgICAgICAgcGFuZWwgPSB0aGF0LmVsZW1lbnQuZmluZCh0aGF0Ll9zYW5pdGl6ZVNlbGVjdG9yKHNlbGVjdG9yKSk7IC8vIHJlbW90ZSB0YWJcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIC8vIElmIHRoZSB0YWIgZG9lc24ndCBhbHJlYWR5IGhhdmUgYXJpYS1jb250cm9scyxcXG4gICAgICAgICAgLy8gZ2VuZXJhdGUgYW4gaWQgYnkgdXNpbmcgYSB0aHJvdy1hd2F5IGVsZW1lbnRcXG4gICAgICAgICAgcGFuZWxJZCA9IHRhYi5hdHRyKFxcXCJhcmlhLWNvbnRyb2xzXFxcIikgfHwgJCh7fSkudW5pcXVlSWQoKVswXS5pZDtcXG4gICAgICAgICAgc2VsZWN0b3IgPSBcXFwiI1xcXCIgKyBwYW5lbElkO1xcbiAgICAgICAgICBwYW5lbCA9IHRoYXQuZWxlbWVudC5maW5kKHNlbGVjdG9yKTtcXG5cXG4gICAgICAgICAgaWYgKCFwYW5lbC5sZW5ndGgpIHtcXG4gICAgICAgICAgICBwYW5lbCA9IHRoYXQuX2NyZWF0ZVBhbmVsKHBhbmVsSWQpO1xcbiAgICAgICAgICAgIHBhbmVsLmluc2VydEFmdGVyKHRoYXQucGFuZWxzW2kgLSAxXSB8fCB0aGF0LnRhYmxpc3QpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHBhbmVsLmF0dHIoXFxcImFyaWEtbGl2ZVxcXCIsIFxcXCJwb2xpdGVcXFwiKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChwYW5lbC5sZW5ndGgpIHtcXG4gICAgICAgICAgdGhhdC5wYW5lbHMgPSB0aGF0LnBhbmVscy5hZGQocGFuZWwpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKG9yaWdpbmFsQXJpYUNvbnRyb2xzKSB7XFxuICAgICAgICAgIHRhYi5kYXRhKFxcXCJ1aS10YWJzLWFyaWEtY29udHJvbHNcXFwiLCBvcmlnaW5hbEFyaWFDb250cm9scyk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0YWIuYXR0cih7XFxuICAgICAgICAgIFxcXCJhcmlhLWNvbnRyb2xzXFxcIjogcGFuZWxJZCxcXG4gICAgICAgICAgXFxcImFyaWEtbGFiZWxsZWRieVxcXCI6IGFuY2hvcklkXFxuICAgICAgICB9KTtcXG4gICAgICAgIHBhbmVsLmF0dHIoXFxcImFyaWEtbGFiZWxsZWRieVxcXCIsIGFuY2hvcklkKTtcXG4gICAgICB9KTtcXG4gICAgICB0aGlzLnBhbmVscy5hZGRDbGFzcyhcXFwidWktdGFicy1wYW5lbCB1aS13aWRnZXQtY29udGVudCB1aS1jb3JuZXItYm90dG9tXFxcIikuYXR0cihcXFwicm9sZVxcXCIsIFxcXCJ0YWJwYW5lbFxcXCIpOyAvLyBBdm9pZCBtZW1vcnkgbGVha3MgKCMxMDA1NilcXG5cXG4gICAgICBpZiAocHJldlRhYnMpIHtcXG4gICAgICAgIHRoaXMuX29mZihwcmV2VGFicy5ub3QodGhpcy50YWJzKSk7XFxuXFxuICAgICAgICB0aGlzLl9vZmYocHJldkFuY2hvcnMubm90KHRoaXMuYW5jaG9ycykpO1xcblxcbiAgICAgICAgdGhpcy5fb2ZmKHByZXZQYW5lbHMubm90KHRoaXMucGFuZWxzKSk7XFxuICAgICAgfVxcbiAgICB9LFxcbiAgICAvLyBhbGxvdyBvdmVycmlkaW5nIGhvdyB0byBmaW5kIHRoZSBsaXN0IGZvciByYXJlIHVzYWdlIHNjZW5hcmlvcyAoIzc3MTUpXFxuICAgIF9nZXRMaXN0OiBmdW5jdGlvbiBfZ2V0TGlzdCgpIHtcXG4gICAgICByZXR1cm4gdGhpcy50YWJsaXN0IHx8IHRoaXMuZWxlbWVudC5maW5kKFxcXCJvbCx1bFxcXCIpLmVxKDApO1xcbiAgICB9LFxcbiAgICBfY3JlYXRlUGFuZWw6IGZ1bmN0aW9uIF9jcmVhdGVQYW5lbChpZCkge1xcbiAgICAgIHJldHVybiAkKFxcXCI8ZGl2PlxcXCIpLmF0dHIoXFxcImlkXFxcIiwgaWQpLmFkZENsYXNzKFxcXCJ1aS10YWJzLXBhbmVsIHVpLXdpZGdldC1jb250ZW50IHVpLWNvcm5lci1ib3R0b21cXFwiKS5kYXRhKFxcXCJ1aS10YWJzLWRlc3Ryb3lcXFwiLCB0cnVlKTtcXG4gICAgfSxcXG4gICAgX3NldHVwRGlzYWJsZWQ6IGZ1bmN0aW9uIF9zZXR1cERpc2FibGVkKGRpc2FibGVkKSB7XFxuICAgICAgaWYgKCQuaXNBcnJheShkaXNhYmxlZCkpIHtcXG4gICAgICAgIGlmICghZGlzYWJsZWQubGVuZ3RoKSB7XFxuICAgICAgICAgIGRpc2FibGVkID0gZmFsc2U7XFxuICAgICAgICB9IGVsc2UgaWYgKGRpc2FibGVkLmxlbmd0aCA9PT0gdGhpcy5hbmNob3JzLmxlbmd0aCkge1xcbiAgICAgICAgICBkaXNhYmxlZCA9IHRydWU7XFxuICAgICAgICB9XFxuICAgICAgfSAvLyBkaXNhYmxlIHRhYnNcXG5cXG5cXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGk7IGxpID0gdGhpcy50YWJzW2ldOyBpKyspIHtcXG4gICAgICAgIGlmIChkaXNhYmxlZCA9PT0gdHJ1ZSB8fCAkLmluQXJyYXkoaSwgZGlzYWJsZWQpICE9PSAtMSkge1xcbiAgICAgICAgICAkKGxpKS5hZGRDbGFzcyhcXFwidWktc3RhdGUtZGlzYWJsZWRcXFwiKS5hdHRyKFxcXCJhcmlhLWRpc2FibGVkXFxcIiwgXFxcInRydWVcXFwiKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICQobGkpLnJlbW92ZUNsYXNzKFxcXCJ1aS1zdGF0ZS1kaXNhYmxlZFxcXCIpLnJlbW92ZUF0dHIoXFxcImFyaWEtZGlzYWJsZWRcXFwiKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5vcHRpb25zLmRpc2FibGVkID0gZGlzYWJsZWQ7XFxuICAgIH0sXFxuICAgIF9zZXR1cEV2ZW50czogZnVuY3Rpb24gX3NldHVwRXZlbnRzKGV2ZW50KSB7XFxuICAgICAgdmFyIGV2ZW50cyA9IHt9O1xcblxcbiAgICAgIGlmIChldmVudCkge1xcbiAgICAgICAgJC5lYWNoKGV2ZW50LnNwbGl0KFxcXCIgXFxcIiksIGZ1bmN0aW9uIChpbmRleCwgZXZlbnROYW1lKSB7XFxuICAgICAgICAgIGV2ZW50c1tldmVudE5hbWVdID0gXFxcIl9ldmVudEhhbmRsZXJcXFwiO1xcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX29mZih0aGlzLmFuY2hvcnMuYWRkKHRoaXMudGFicykuYWRkKHRoaXMucGFuZWxzKSk7IC8vIEFsd2F5cyBwcmV2ZW50IHRoZSBkZWZhdWx0IGFjdGlvbiwgZXZlbiB3aGVuIGRpc2FibGVkXFxuXFxuXFxuICAgICAgdGhpcy5fb24odHJ1ZSwgdGhpcy5hbmNob3JzLCB7XFxuICAgICAgICBjbGljazogZnVuY3Rpb24gY2xpY2soZXZlbnQpIHtcXG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG5cXG4gICAgICB0aGlzLl9vbih0aGlzLmFuY2hvcnMsIGV2ZW50cyk7XFxuXFxuICAgICAgdGhpcy5fb24odGhpcy50YWJzLCB7XFxuICAgICAgICBrZXlkb3duOiBcXFwiX3RhYktleWRvd25cXFwiXFxuICAgICAgfSk7XFxuXFxuICAgICAgdGhpcy5fb24odGhpcy5wYW5lbHMsIHtcXG4gICAgICAgIGtleWRvd246IFxcXCJfcGFuZWxLZXlkb3duXFxcIlxcbiAgICAgIH0pO1xcblxcbiAgICAgIHRoaXMuX2ZvY3VzYWJsZSh0aGlzLnRhYnMpO1xcblxcbiAgICAgIHRoaXMuX2hvdmVyYWJsZSh0aGlzLnRhYnMpO1xcbiAgICB9LFxcbiAgICBfc2V0dXBIZWlnaHRTdHlsZTogZnVuY3Rpb24gX3NldHVwSGVpZ2h0U3R5bGUoaGVpZ2h0U3R5bGUpIHtcXG4gICAgICB2YXIgbWF4SGVpZ2h0LFxcbiAgICAgICAgICBwYXJlbnQgPSB0aGlzLmVsZW1lbnQucGFyZW50KCk7XFxuXFxuICAgICAgaWYgKGhlaWdodFN0eWxlID09PSBcXFwiZmlsbFxcXCIpIHtcXG4gICAgICAgIG1heEhlaWdodCA9IHBhcmVudC5oZWlnaHQoKTtcXG4gICAgICAgIG1heEhlaWdodCAtPSB0aGlzLmVsZW1lbnQub3V0ZXJIZWlnaHQoKSAtIHRoaXMuZWxlbWVudC5oZWlnaHQoKTtcXG4gICAgICAgIHRoaXMuZWxlbWVudC5zaWJsaW5ncyhcXFwiOnZpc2libGVcXFwiKS5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgdmFyIGVsZW0gPSAkKHRoaXMpLFxcbiAgICAgICAgICAgICAgcG9zaXRpb24gPSBlbGVtLmNzcyhcXFwicG9zaXRpb25cXFwiKTtcXG5cXG4gICAgICAgICAgaWYgKHBvc2l0aW9uID09PSBcXFwiYWJzb2x1dGVcXFwiIHx8IHBvc2l0aW9uID09PSBcXFwiZml4ZWRcXFwiKSB7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIG1heEhlaWdodCAtPSBlbGVtLm91dGVySGVpZ2h0KHRydWUpO1xcbiAgICAgICAgfSk7XFxuICAgICAgICB0aGlzLmVsZW1lbnQuY2hpbGRyZW4oKS5ub3QodGhpcy5wYW5lbHMpLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBtYXhIZWlnaHQgLT0gJCh0aGlzKS5vdXRlckhlaWdodCh0cnVlKTtcXG4gICAgICAgIH0pO1xcbiAgICAgICAgdGhpcy5wYW5lbHMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICQodGhpcykuaGVpZ2h0KE1hdGgubWF4KDAsIG1heEhlaWdodCAtICQodGhpcykuaW5uZXJIZWlnaHQoKSArICQodGhpcykuaGVpZ2h0KCkpKTtcXG4gICAgICAgIH0pLmNzcyhcXFwib3ZlcmZsb3dcXFwiLCBcXFwiYXV0b1xcXCIpO1xcbiAgICAgIH0gZWxzZSBpZiAoaGVpZ2h0U3R5bGUgPT09IFxcXCJhdXRvXFxcIikge1xcbiAgICAgICAgbWF4SGVpZ2h0ID0gMDtcXG4gICAgICAgIHRoaXMucGFuZWxzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBtYXhIZWlnaHQgPSBNYXRoLm1heChtYXhIZWlnaHQsICQodGhpcykuaGVpZ2h0KFxcXCJcXFwiKS5oZWlnaHQoKSk7XFxuICAgICAgICB9KS5oZWlnaHQobWF4SGVpZ2h0KTtcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIF9ldmVudEhhbmRsZXI6IGZ1bmN0aW9uIF9ldmVudEhhbmRsZXIoZXZlbnQpIHtcXG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyxcXG4gICAgICAgICAgYWN0aXZlID0gdGhpcy5hY3RpdmUsXFxuICAgICAgICAgIGFuY2hvciA9ICQoZXZlbnQuY3VycmVudFRhcmdldCksXFxuICAgICAgICAgIHRhYiA9IGFuY2hvci5jbG9zZXN0KFxcXCJsaVxcXCIpLFxcbiAgICAgICAgICBjbGlja2VkSXNBY3RpdmUgPSB0YWJbMF0gPT09IGFjdGl2ZVswXSxcXG4gICAgICAgICAgY29sbGFwc2luZyA9IGNsaWNrZWRJc0FjdGl2ZSAmJiBvcHRpb25zLmNvbGxhcHNpYmxlLFxcbiAgICAgICAgICB0b1Nob3cgPSBjb2xsYXBzaW5nID8gJCgpIDogdGhpcy5fZ2V0UGFuZWxGb3JUYWIodGFiKSxcXG4gICAgICAgICAgdG9IaWRlID0gIWFjdGl2ZS5sZW5ndGggPyAkKCkgOiB0aGlzLl9nZXRQYW5lbEZvclRhYihhY3RpdmUpLFxcbiAgICAgICAgICBldmVudERhdGEgPSB7XFxuICAgICAgICBvbGRUYWI6IGFjdGl2ZSxcXG4gICAgICAgIG9sZFBhbmVsOiB0b0hpZGUsXFxuICAgICAgICBuZXdUYWI6IGNvbGxhcHNpbmcgPyAkKCkgOiB0YWIsXFxuICAgICAgICBuZXdQYW5lbDogdG9TaG93XFxuICAgICAgfTtcXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xcblxcbiAgICAgIGlmICh0YWIuaGFzQ2xhc3MoXFxcInVpLXN0YXRlLWRpc2FibGVkXFxcIikgfHwgLy8gdGFiIGlzIGFscmVhZHkgbG9hZGluZ1xcbiAgICAgIHRhYi5oYXNDbGFzcyhcXFwidWktdGFicy1sb2FkaW5nXFxcIikgfHwgLy8gY2FuJ3Qgc3dpdGNoIGR1cm5pbmcgYW4gYW5pbWF0aW9uXFxuICAgICAgdGhpcy5ydW5uaW5nIHx8IC8vIGNsaWNrIG9uIGFjdGl2ZSBoZWFkZXIsIGJ1dCBub3QgY29sbGFwc2libGVcXG4gICAgICBjbGlja2VkSXNBY3RpdmUgJiYgIW9wdGlvbnMuY29sbGFwc2libGUgfHwgLy8gYWxsb3cgY2FuY2VsaW5nIGFjdGl2YXRpb25cXG4gICAgICB0aGlzLl90cmlnZ2VyKFxcXCJiZWZvcmVBY3RpdmF0ZVxcXCIsIGV2ZW50LCBldmVudERhdGEpID09PSBmYWxzZSkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBvcHRpb25zLmFjdGl2ZSA9IGNvbGxhcHNpbmcgPyBmYWxzZSA6IHRoaXMudGFicy5pbmRleCh0YWIpO1xcbiAgICAgIHRoaXMuYWN0aXZlID0gY2xpY2tlZElzQWN0aXZlID8gJCgpIDogdGFiO1xcblxcbiAgICAgIGlmICh0aGlzLnhocikge1xcbiAgICAgICAgdGhpcy54aHIuYWJvcnQoKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCF0b0hpZGUubGVuZ3RoICYmICF0b1Nob3cubGVuZ3RoKSB7XFxuICAgICAgICAkLmVycm9yKFxcXCJqUXVlcnkgVUkgVGFiczogTWlzbWF0Y2hpbmcgZnJhZ21lbnQgaWRlbnRpZmllci5cXFwiKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRvU2hvdy5sZW5ndGgpIHtcXG4gICAgICAgIHRoaXMubG9hZCh0aGlzLnRhYnMuaW5kZXgodGFiKSwgZXZlbnQpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl90b2dnbGUoZXZlbnQsIGV2ZW50RGF0YSk7XFxuICAgIH0sXFxuICAgIC8vIGhhbmRsZXMgc2hvdy9oaWRlIGZvciBzZWxlY3RpbmcgdGFic1xcbiAgICBfdG9nZ2xlOiBmdW5jdGlvbiBfdG9nZ2xlKGV2ZW50LCBldmVudERhdGEpIHtcXG4gICAgICB2YXIgdGhhdCA9IHRoaXMsXFxuICAgICAgICAgIHRvU2hvdyA9IGV2ZW50RGF0YS5uZXdQYW5lbCxcXG4gICAgICAgICAgdG9IaWRlID0gZXZlbnREYXRhLm9sZFBhbmVsO1xcbiAgICAgIHRoaXMucnVubmluZyA9IHRydWU7XFxuXFxuICAgICAgZnVuY3Rpb24gY29tcGxldGUoKSB7XFxuICAgICAgICB0aGF0LnJ1bm5pbmcgPSBmYWxzZTtcXG5cXG4gICAgICAgIHRoYXQuX3RyaWdnZXIoXFxcImFjdGl2YXRlXFxcIiwgZXZlbnQsIGV2ZW50RGF0YSk7XFxuICAgICAgfVxcblxcbiAgICAgIGZ1bmN0aW9uIHNob3coKSB7XFxuICAgICAgICBldmVudERhdGEubmV3VGFiLmNsb3Nlc3QoXFxcImxpXFxcIikuYWRkQ2xhc3MoXFxcInVpLXRhYnMtYWN0aXZlIHVpLXN0YXRlLWFjdGl2ZVxcXCIpO1xcblxcbiAgICAgICAgaWYgKHRvU2hvdy5sZW5ndGggJiYgdGhhdC5vcHRpb25zLnNob3cpIHtcXG4gICAgICAgICAgdGhhdC5fc2hvdyh0b1Nob3csIHRoYXQub3B0aW9ucy5zaG93LCBjb21wbGV0ZSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICB0b1Nob3cuc2hvdygpO1xcbiAgICAgICAgICBjb21wbGV0ZSgpO1xcbiAgICAgICAgfVxcbiAgICAgIH0gLy8gc3RhcnQgb3V0IGJ5IGhpZGluZywgdGhlbiBzaG93aW5nLCB0aGVuIGNvbXBsZXRpbmdcXG5cXG5cXG4gICAgICBpZiAodG9IaWRlLmxlbmd0aCAmJiB0aGlzLm9wdGlvbnMuaGlkZSkge1xcbiAgICAgICAgdGhpcy5faGlkZSh0b0hpZGUsIHRoaXMub3B0aW9ucy5oaWRlLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIGV2ZW50RGF0YS5vbGRUYWIuY2xvc2VzdChcXFwibGlcXFwiKS5yZW1vdmVDbGFzcyhcXFwidWktdGFicy1hY3RpdmUgdWktc3RhdGUtYWN0aXZlXFxcIik7XFxuICAgICAgICAgIHNob3coKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBldmVudERhdGEub2xkVGFiLmNsb3Nlc3QoXFxcImxpXFxcIikucmVtb3ZlQ2xhc3MoXFxcInVpLXRhYnMtYWN0aXZlIHVpLXN0YXRlLWFjdGl2ZVxcXCIpO1xcbiAgICAgICAgdG9IaWRlLmhpZGUoKTtcXG4gICAgICAgIHNob3coKTtcXG4gICAgICB9XFxuXFxuICAgICAgdG9IaWRlLmF0dHIoXFxcImFyaWEtaGlkZGVuXFxcIiwgXFxcInRydWVcXFwiKTtcXG4gICAgICBldmVudERhdGEub2xkVGFiLmF0dHIoe1xcbiAgICAgICAgXFxcImFyaWEtc2VsZWN0ZWRcXFwiOiBcXFwiZmFsc2VcXFwiLFxcbiAgICAgICAgXFxcImFyaWEtZXhwYW5kZWRcXFwiOiBcXFwiZmFsc2VcXFwiXFxuICAgICAgfSk7IC8vIElmIHdlJ3JlIHN3aXRjaGluZyB0YWJzLCByZW1vdmUgdGhlIG9sZCB0YWIgZnJvbSB0aGUgdGFiIG9yZGVyLlxcbiAgICAgIC8vIElmIHdlJ3JlIG9wZW5pbmcgZnJvbSBjb2xsYXBzZWQgc3RhdGUsIHJlbW92ZSB0aGUgcHJldmlvdXMgdGFiIGZyb20gdGhlIHRhYiBvcmRlci5cXG4gICAgICAvLyBJZiB3ZSdyZSBjb2xsYXBzaW5nLCB0aGVuIGtlZXAgdGhlIGNvbGxhcHNpbmcgdGFiIGluIHRoZSB0YWIgb3JkZXIuXFxuXFxuICAgICAgaWYgKHRvU2hvdy5sZW5ndGggJiYgdG9IaWRlLmxlbmd0aCkge1xcbiAgICAgICAgZXZlbnREYXRhLm9sZFRhYi5hdHRyKFxcXCJ0YWJJbmRleFxcXCIsIC0xKTtcXG4gICAgICB9IGVsc2UgaWYgKHRvU2hvdy5sZW5ndGgpIHtcXG4gICAgICAgIHRoaXMudGFicy5maWx0ZXIoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICByZXR1cm4gJCh0aGlzKS5hdHRyKFxcXCJ0YWJJbmRleFxcXCIpID09PSAwO1xcbiAgICAgICAgfSkuYXR0cihcXFwidGFiSW5kZXhcXFwiLCAtMSk7XFxuICAgICAgfVxcblxcbiAgICAgIHRvU2hvdy5hdHRyKFxcXCJhcmlhLWhpZGRlblxcXCIsIFxcXCJmYWxzZVxcXCIpO1xcbiAgICAgIGV2ZW50RGF0YS5uZXdUYWIuYXR0cih7XFxuICAgICAgICBcXFwiYXJpYS1zZWxlY3RlZFxcXCI6IFxcXCJ0cnVlXFxcIixcXG4gICAgICAgIFxcXCJhcmlhLWV4cGFuZGVkXFxcIjogXFxcInRydWVcXFwiLFxcbiAgICAgICAgdGFiSW5kZXg6IDBcXG4gICAgICB9KTtcXG4gICAgfSxcXG4gICAgX2FjdGl2YXRlOiBmdW5jdGlvbiBfYWN0aXZhdGUoaW5kZXgpIHtcXG4gICAgICB2YXIgYW5jaG9yLFxcbiAgICAgICAgICBhY3RpdmUgPSB0aGlzLl9maW5kQWN0aXZlKGluZGV4KTsgLy8gdHJ5aW5nIHRvIGFjdGl2YXRlIHRoZSBhbHJlYWR5IGFjdGl2ZSBwYW5lbFxcblxcblxcbiAgICAgIGlmIChhY3RpdmVbMF0gPT09IHRoaXMuYWN0aXZlWzBdKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfSAvLyB0cnlpbmcgdG8gY29sbGFwc2UsIHNpbXVsYXRlIGEgY2xpY2sgb24gdGhlIGN1cnJlbnQgYWN0aXZlIGhlYWRlclxcblxcblxcbiAgICAgIGlmICghYWN0aXZlLmxlbmd0aCkge1xcbiAgICAgICAgYWN0aXZlID0gdGhpcy5hY3RpdmU7XFxuICAgICAgfVxcblxcbiAgICAgIGFuY2hvciA9IGFjdGl2ZS5maW5kKFxcXCIudWktdGFicy1hbmNob3JcXFwiKVswXTtcXG5cXG4gICAgICB0aGlzLl9ldmVudEhhbmRsZXIoe1xcbiAgICAgICAgdGFyZ2V0OiBhbmNob3IsXFxuICAgICAgICBjdXJyZW50VGFyZ2V0OiBhbmNob3IsXFxuICAgICAgICBwcmV2ZW50RGVmYXVsdDogJC5ub29wXFxuICAgICAgfSk7XFxuICAgIH0sXFxuICAgIF9maW5kQWN0aXZlOiBmdW5jdGlvbiBfZmluZEFjdGl2ZShpbmRleCkge1xcbiAgICAgIHJldHVybiBpbmRleCA9PT0gZmFsc2UgPyAkKCkgOiB0aGlzLnRhYnMuZXEoaW5kZXgpO1xcbiAgICB9LFxcbiAgICBfZ2V0SW5kZXg6IGZ1bmN0aW9uIF9nZXRJbmRleChpbmRleCkge1xcbiAgICAgIC8vIG1ldGEtZnVuY3Rpb24gdG8gZ2l2ZSB1c2VycyBvcHRpb24gdG8gcHJvdmlkZSBhIGhyZWYgc3RyaW5nIGluc3RlYWQgb2YgYSBudW1lcmljYWwgaW5kZXguXFxuICAgICAgaWYgKHR5cGVvZiBpbmRleCA9PT0gXFxcInN0cmluZ1xcXCIpIHtcXG4gICAgICAgIGluZGV4ID0gdGhpcy5hbmNob3JzLmluZGV4KHRoaXMuYW5jaG9ycy5maWx0ZXIoXFxcIltocmVmJD0nXFxcIiArIGluZGV4ICsgXFxcIiddXFxcIikpO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gaW5kZXg7XFxuICAgIH0sXFxuICAgIF9kZXN0cm95OiBmdW5jdGlvbiBfZGVzdHJveSgpIHtcXG4gICAgICBpZiAodGhpcy54aHIpIHtcXG4gICAgICAgIHRoaXMueGhyLmFib3J0KCk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVDbGFzcyhcXFwidWktdGFicyB1aS13aWRnZXQgdWktd2lkZ2V0LWNvbnRlbnQgdWktY29ybmVyLWFsbCB1aS10YWJzLWNvbGxhcHNpYmxlXFxcIik7XFxuICAgICAgdGhpcy50YWJsaXN0LnJlbW92ZUNsYXNzKFxcXCJ1aS10YWJzLW5hdiB1aS1oZWxwZXItcmVzZXQgdWktaGVscGVyLWNsZWFyZml4IHVpLXdpZGdldC1oZWFkZXIgdWktY29ybmVyLWFsbFxcXCIpLnJlbW92ZUF0dHIoXFxcInJvbGVcXFwiKTtcXG4gICAgICB0aGlzLmFuY2hvcnMucmVtb3ZlQ2xhc3MoXFxcInVpLXRhYnMtYW5jaG9yXFxcIikucmVtb3ZlQXR0cihcXFwicm9sZVxcXCIpLnJlbW92ZUF0dHIoXFxcInRhYkluZGV4XFxcIikucmVtb3ZlVW5pcXVlSWQoKTtcXG4gICAgICB0aGlzLnRhYmxpc3QudW5iaW5kKHRoaXMuZXZlbnROYW1lc3BhY2UpO1xcbiAgICAgIHRoaXMudGFicy5hZGQodGhpcy5wYW5lbHMpLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgaWYgKCQuZGF0YSh0aGlzLCBcXFwidWktdGFicy1kZXN0cm95XFxcIikpIHtcXG4gICAgICAgICAgJCh0aGlzKS5yZW1vdmUoKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICQodGhpcykucmVtb3ZlQ2xhc3MoXFxcInVpLXN0YXRlLWRlZmF1bHQgdWktc3RhdGUtYWN0aXZlIHVpLXN0YXRlLWRpc2FibGVkIFxcXCIgKyBcXFwidWktY29ybmVyLXRvcCB1aS1jb3JuZXItYm90dG9tIHVpLXdpZGdldC1jb250ZW50IHVpLXRhYnMtYWN0aXZlIHVpLXRhYnMtcGFuZWxcXFwiKS5yZW1vdmVBdHRyKFxcXCJ0YWJJbmRleFxcXCIpLnJlbW92ZUF0dHIoXFxcImFyaWEtbGl2ZVxcXCIpLnJlbW92ZUF0dHIoXFxcImFyaWEtYnVzeVxcXCIpLnJlbW92ZUF0dHIoXFxcImFyaWEtc2VsZWN0ZWRcXFwiKS5yZW1vdmVBdHRyKFxcXCJhcmlhLWxhYmVsbGVkYnlcXFwiKS5yZW1vdmVBdHRyKFxcXCJhcmlhLWhpZGRlblxcXCIpLnJlbW92ZUF0dHIoXFxcImFyaWEtZXhwYW5kZWRcXFwiKS5yZW1vdmVBdHRyKFxcXCJyb2xlXFxcIik7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgICAgdGhpcy50YWJzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIGxpID0gJCh0aGlzKSxcXG4gICAgICAgICAgICBwcmV2ID0gbGkuZGF0YShcXFwidWktdGFicy1hcmlhLWNvbnRyb2xzXFxcIik7XFxuXFxuICAgICAgICBpZiAocHJldikge1xcbiAgICAgICAgICBsaS5hdHRyKFxcXCJhcmlhLWNvbnRyb2xzXFxcIiwgcHJldikucmVtb3ZlRGF0YShcXFwidWktdGFicy1hcmlhLWNvbnRyb2xzXFxcIik7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBsaS5yZW1vdmVBdHRyKFxcXCJhcmlhLWNvbnRyb2xzXFxcIik7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgICAgdGhpcy5wYW5lbHMuc2hvdygpO1xcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGVpZ2h0U3R5bGUgIT09IFxcXCJjb250ZW50XFxcIikge1xcbiAgICAgICAgdGhpcy5wYW5lbHMuY3NzKFxcXCJoZWlnaHRcXFwiLCBcXFwiXFxcIik7XFxuICAgICAgfVxcbiAgICB9LFxcbiAgICBlbmFibGU6IGZ1bmN0aW9uIGVuYWJsZShpbmRleCkge1xcbiAgICAgIHZhciBkaXNhYmxlZCA9IHRoaXMub3B0aW9ucy5kaXNhYmxlZDtcXG5cXG4gICAgICBpZiAoZGlzYWJsZWQgPT09IGZhbHNlKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICBkaXNhYmxlZCA9IGZhbHNlO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBpbmRleCA9IHRoaXMuX2dldEluZGV4KGluZGV4KTtcXG5cXG4gICAgICAgIGlmICgkLmlzQXJyYXkoZGlzYWJsZWQpKSB7XFxuICAgICAgICAgIGRpc2FibGVkID0gJC5tYXAoZGlzYWJsZWQsIGZ1bmN0aW9uIChudW0pIHtcXG4gICAgICAgICAgICByZXR1cm4gbnVtICE9PSBpbmRleCA/IG51bSA6IG51bGw7XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgZGlzYWJsZWQgPSAkLm1hcCh0aGlzLnRhYnMsIGZ1bmN0aW9uIChsaSwgbnVtKSB7XFxuICAgICAgICAgICAgcmV0dXJuIG51bSAhPT0gaW5kZXggPyBudW0gOiBudWxsO1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fc2V0dXBEaXNhYmxlZChkaXNhYmxlZCk7XFxuICAgIH0sXFxuICAgIGRpc2FibGU6IGZ1bmN0aW9uIGRpc2FibGUoaW5kZXgpIHtcXG4gICAgICB2YXIgZGlzYWJsZWQgPSB0aGlzLm9wdGlvbnMuZGlzYWJsZWQ7XFxuXFxuICAgICAgaWYgKGRpc2FibGVkID09PSB0cnVlKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICBkaXNhYmxlZCA9IHRydWU7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGluZGV4ID0gdGhpcy5fZ2V0SW5kZXgoaW5kZXgpO1xcblxcbiAgICAgICAgaWYgKCQuaW5BcnJheShpbmRleCwgZGlzYWJsZWQpICE9PSAtMSkge1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoJC5pc0FycmF5KGRpc2FibGVkKSkge1xcbiAgICAgICAgICBkaXNhYmxlZCA9ICQubWVyZ2UoW2luZGV4XSwgZGlzYWJsZWQpLnNvcnQoKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGRpc2FibGVkID0gW2luZGV4XTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fc2V0dXBEaXNhYmxlZChkaXNhYmxlZCk7XFxuICAgIH0sXFxuICAgIGxvYWQ6IGZ1bmN0aW9uIGxvYWQoaW5kZXgsIGV2ZW50KSB7XFxuICAgICAgaW5kZXggPSB0aGlzLl9nZXRJbmRleChpbmRleCk7XFxuXFxuICAgICAgdmFyIHRoYXQgPSB0aGlzLFxcbiAgICAgICAgICB0YWIgPSB0aGlzLnRhYnMuZXEoaW5kZXgpLFxcbiAgICAgICAgICBhbmNob3IgPSB0YWIuZmluZChcXFwiLnVpLXRhYnMtYW5jaG9yXFxcIiksXFxuICAgICAgICAgIHBhbmVsID0gdGhpcy5fZ2V0UGFuZWxGb3JUYWIodGFiKSxcXG4gICAgICAgICAgZXZlbnREYXRhID0ge1xcbiAgICAgICAgdGFiOiB0YWIsXFxuICAgICAgICBwYW5lbDogcGFuZWxcXG4gICAgICB9LFxcbiAgICAgICAgICBjb21wbGV0ZSA9IGZ1bmN0aW9uIGNvbXBsZXRlKGpxWEhSLCBzdGF0dXMpIHtcXG4gICAgICAgIGlmIChzdGF0dXMgPT09IFxcXCJhYm9ydFxcXCIpIHtcXG4gICAgICAgICAgdGhhdC5wYW5lbHMuc3RvcChmYWxzZSwgdHJ1ZSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0YWIucmVtb3ZlQ2xhc3MoXFxcInVpLXRhYnMtbG9hZGluZ1xcXCIpO1xcbiAgICAgICAgcGFuZWwucmVtb3ZlQXR0cihcXFwiYXJpYS1idXN5XFxcIik7XFxuXFxuICAgICAgICBpZiAoanFYSFIgPT09IHRoYXQueGhyKSB7XFxuICAgICAgICAgIGRlbGV0ZSB0aGF0LnhocjtcXG4gICAgICAgIH1cXG4gICAgICB9OyAvLyBub3QgcmVtb3RlXFxuXFxuXFxuICAgICAgaWYgKHRoaXMuX2lzTG9jYWwoYW5jaG9yWzBdKSkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLnhociA9ICQuYWpheCh0aGlzLl9hamF4U2V0dGluZ3MoYW5jaG9yLCBldmVudCwgZXZlbnREYXRhKSk7IC8vIHN1cHBvcnQ6IGpRdWVyeSA8MS44XFxuICAgICAgLy8galF1ZXJ5IDwxLjggcmV0dXJucyBmYWxzZSBpZiB0aGUgcmVxdWVzdCBpcyBjYW5jZWxlZCBpbiBiZWZvcmVTZW5kLFxcbiAgICAgIC8vIGJ1dCBhcyBvZiAxLjgsICQuYWpheCgpIGFsd2F5cyByZXR1cm5zIGEganFYSFIgb2JqZWN0LlxcblxcbiAgICAgIGlmICh0aGlzLnhociAmJiB0aGlzLnhoci5zdGF0dXNUZXh0ICE9PSBcXFwiY2FuY2VsZWRcXFwiKSB7XFxuICAgICAgICB0YWIuYWRkQ2xhc3MoXFxcInVpLXRhYnMtbG9hZGluZ1xcXCIpO1xcbiAgICAgICAgcGFuZWwuYXR0cihcXFwiYXJpYS1idXN5XFxcIiwgXFxcInRydWVcXFwiKTtcXG4gICAgICAgIHRoaXMueGhyLmRvbmUoZnVuY3Rpb24gKHJlc3BvbnNlLCBzdGF0dXMsIGpxWEhSKSB7XFxuICAgICAgICAgIC8vIHN1cHBvcnQ6IGpRdWVyeSA8MS44XFxuICAgICAgICAgIC8vIGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzExNzc4XFxuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIHBhbmVsLmh0bWwocmVzcG9uc2UpO1xcblxcbiAgICAgICAgICAgIHRoYXQuX3RyaWdnZXIoXFxcImxvYWRcXFwiLCBldmVudCwgZXZlbnREYXRhKTtcXG5cXG4gICAgICAgICAgICBjb21wbGV0ZShqcVhIUiwgc3RhdHVzKTtcXG4gICAgICAgICAgfSwgMSk7XFxuICAgICAgICB9KS5mYWlsKGZ1bmN0aW9uIChqcVhIUiwgc3RhdHVzKSB7XFxuICAgICAgICAgIC8vIHN1cHBvcnQ6IGpRdWVyeSA8MS44XFxuICAgICAgICAgIC8vIGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzExNzc4XFxuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIGNvbXBsZXRlKGpxWEhSLCBzdGF0dXMpO1xcbiAgICAgICAgICB9LCAxKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgX2FqYXhTZXR0aW5nczogZnVuY3Rpb24gX2FqYXhTZXR0aW5ncyhhbmNob3IsIGV2ZW50LCBldmVudERhdGEpIHtcXG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XFxuICAgICAgcmV0dXJuIHtcXG4gICAgICAgIHVybDogYW5jaG9yLmF0dHIoXFxcImhyZWZcXFwiKSxcXG4gICAgICAgIGJlZm9yZVNlbmQ6IGZ1bmN0aW9uIGJlZm9yZVNlbmQoanFYSFIsIHNldHRpbmdzKSB7XFxuICAgICAgICAgIHJldHVybiB0aGF0Ll90cmlnZ2VyKFxcXCJiZWZvcmVMb2FkXFxcIiwgZXZlbnQsICQuZXh0ZW5kKHtcXG4gICAgICAgICAgICBqcVhIUjoganFYSFIsXFxuICAgICAgICAgICAgYWpheFNldHRpbmdzOiBzZXR0aW5nc1xcbiAgICAgICAgICB9LCBldmVudERhdGEpKTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICB9LFxcbiAgICBfZ2V0UGFuZWxGb3JUYWI6IGZ1bmN0aW9uIF9nZXRQYW5lbEZvclRhYih0YWIpIHtcXG4gICAgICB2YXIgaWQgPSAkKHRhYikuYXR0cihcXFwiYXJpYS1jb250cm9sc1xcXCIpO1xcbiAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQuZmluZCh0aGlzLl9zYW5pdGl6ZVNlbGVjdG9yKFxcXCIjXFxcIiArIGlkKSk7XFxuICAgIH1cXG4gIH0pO1xcbiAgLyohXFxuICAgKiBqUXVlcnkgVUkgVG9vbHRpcCAxLjExLjRcXG4gICAqIGh0dHA6Ly9qcXVlcnl1aS5jb21cXG4gICAqXFxuICAgKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xcbiAgICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxcbiAgICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxcbiAgICpcXG4gICAqIGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL3Rvb2x0aXAvXFxuICAgKi9cXG5cXG4gIHZhciB0b29sdGlwID0gJC53aWRnZXQoXFxcInVpLnRvb2x0aXBcXFwiLCB7XFxuICAgIHZlcnNpb246IFxcXCIxLjExLjRcXFwiLFxcbiAgICBvcHRpb25zOiB7XFxuICAgICAgY29udGVudDogZnVuY3Rpb24gY29udGVudCgpIHtcXG4gICAgICAgIC8vIHN1cHBvcnQ6IElFPDksIE9wZXJhIGluIGpRdWVyeSA8MS43XFxuICAgICAgICAvLyAudGV4dCgpIGNhbid0IGFjY2VwdCB1bmRlZmluZWQsIHNvIGNvZXJjZSB0byBhIHN0cmluZ1xcbiAgICAgICAgdmFyIHRpdGxlID0gJCh0aGlzKS5hdHRyKFxcXCJ0aXRsZVxcXCIpIHx8IFxcXCJcXFwiOyAvLyBFc2NhcGUgdGl0bGUsIHNpbmNlIHdlJ3JlIGdvaW5nIGZyb20gYW4gYXR0cmlidXRlIHRvIHJhdyBIVE1MXFxuXFxuICAgICAgICByZXR1cm4gJChcXFwiPGE+XFxcIikudGV4dCh0aXRsZSkuaHRtbCgpO1xcbiAgICAgIH0sXFxuICAgICAgaGlkZTogdHJ1ZSxcXG4gICAgICAvLyBEaXNhYmxlZCBlbGVtZW50cyBoYXZlIGluY29uc2lzdGVudCBiZWhhdmlvciBhY3Jvc3MgYnJvd3NlcnMgKCM4NjYxKVxcbiAgICAgIGl0ZW1zOiBcXFwiW3RpdGxlXTpub3QoW2Rpc2FibGVkXSlcXFwiLFxcbiAgICAgIHBvc2l0aW9uOiB7XFxuICAgICAgICBteTogXFxcImxlZnQgdG9wKzE1XFxcIixcXG4gICAgICAgIGF0OiBcXFwibGVmdCBib3R0b21cXFwiLFxcbiAgICAgICAgY29sbGlzaW9uOiBcXFwiZmxpcGZpdCBmbGlwXFxcIlxcbiAgICAgIH0sXFxuICAgICAgc2hvdzogdHJ1ZSxcXG4gICAgICB0b29sdGlwQ2xhc3M6IG51bGwsXFxuICAgICAgdHJhY2s6IGZhbHNlLFxcbiAgICAgIC8vIGNhbGxiYWNrc1xcbiAgICAgIGNsb3NlOiBudWxsLFxcbiAgICAgIG9wZW46IG51bGxcXG4gICAgfSxcXG4gICAgX2FkZERlc2NyaWJlZEJ5OiBmdW5jdGlvbiBfYWRkRGVzY3JpYmVkQnkoZWxlbSwgaWQpIHtcXG4gICAgICB2YXIgZGVzY3JpYmVkYnkgPSAoZWxlbS5hdHRyKFxcXCJhcmlhLWRlc2NyaWJlZGJ5XFxcIikgfHwgXFxcIlxcXCIpLnNwbGl0KC9cXFxccysvKTtcXG4gICAgICBkZXNjcmliZWRieS5wdXNoKGlkKTtcXG4gICAgICBlbGVtLmRhdGEoXFxcInVpLXRvb2x0aXAtaWRcXFwiLCBpZCkuYXR0cihcXFwiYXJpYS1kZXNjcmliZWRieVxcXCIsICQudHJpbShkZXNjcmliZWRieS5qb2luKFxcXCIgXFxcIikpKTtcXG4gICAgfSxcXG4gICAgX3JlbW92ZURlc2NyaWJlZEJ5OiBmdW5jdGlvbiBfcmVtb3ZlRGVzY3JpYmVkQnkoZWxlbSkge1xcbiAgICAgIHZhciBpZCA9IGVsZW0uZGF0YShcXFwidWktdG9vbHRpcC1pZFxcXCIpLFxcbiAgICAgICAgICBkZXNjcmliZWRieSA9IChlbGVtLmF0dHIoXFxcImFyaWEtZGVzY3JpYmVkYnlcXFwiKSB8fCBcXFwiXFxcIikuc3BsaXQoL1xcXFxzKy8pLFxcbiAgICAgICAgICBpbmRleCA9ICQuaW5BcnJheShpZCwgZGVzY3JpYmVkYnkpO1xcblxcbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcXG4gICAgICAgIGRlc2NyaWJlZGJ5LnNwbGljZShpbmRleCwgMSk7XFxuICAgICAgfVxcblxcbiAgICAgIGVsZW0ucmVtb3ZlRGF0YShcXFwidWktdG9vbHRpcC1pZFxcXCIpO1xcbiAgICAgIGRlc2NyaWJlZGJ5ID0gJC50cmltKGRlc2NyaWJlZGJ5LmpvaW4oXFxcIiBcXFwiKSk7XFxuXFxuICAgICAgaWYgKGRlc2NyaWJlZGJ5KSB7XFxuICAgICAgICBlbGVtLmF0dHIoXFxcImFyaWEtZGVzY3JpYmVkYnlcXFwiLCBkZXNjcmliZWRieSk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGVsZW0ucmVtb3ZlQXR0cihcXFwiYXJpYS1kZXNjcmliZWRieVxcXCIpO1xcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgX2NyZWF0ZTogZnVuY3Rpb24gX2NyZWF0ZSgpIHtcXG4gICAgICB0aGlzLl9vbih7XFxuICAgICAgICBtb3VzZW92ZXI6IFxcXCJvcGVuXFxcIixcXG4gICAgICAgIGZvY3VzaW46IFxcXCJvcGVuXFxcIlxcbiAgICAgIH0pOyAvLyBJRHMgb2YgZ2VuZXJhdGVkIHRvb2x0aXBzLCBuZWVkZWQgZm9yIGRlc3Ryb3lcXG5cXG5cXG4gICAgICB0aGlzLnRvb2x0aXBzID0ge307IC8vIElEcyBvZiBwYXJlbnQgdG9vbHRpcHMgd2hlcmUgd2UgcmVtb3ZlZCB0aGUgdGl0bGUgYXR0cmlidXRlXFxuXFxuICAgICAgdGhpcy5wYXJlbnRzID0ge307XFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5kaXNhYmxlZCkge1xcbiAgICAgICAgdGhpcy5fZGlzYWJsZSgpO1xcbiAgICAgIH0gLy8gQXBwZW5kIHRoZSBhcmlhLWxpdmUgcmVnaW9uIHNvIHRvb2x0aXBzIGFubm91bmNlIGNvcnJlY3RseVxcblxcblxcbiAgICAgIHRoaXMubGl2ZVJlZ2lvbiA9ICQoXFxcIjxkaXY+XFxcIikuYXR0cih7XFxuICAgICAgICByb2xlOiBcXFwibG9nXFxcIixcXG4gICAgICAgIFxcXCJhcmlhLWxpdmVcXFwiOiBcXFwiYXNzZXJ0aXZlXFxcIixcXG4gICAgICAgIFxcXCJhcmlhLXJlbGV2YW50XFxcIjogXFxcImFkZGl0aW9uc1xcXCJcXG4gICAgICB9KS5hZGRDbGFzcyhcXFwidWktaGVscGVyLWhpZGRlbi1hY2Nlc3NpYmxlXFxcIikuYXBwZW5kVG8odGhpcy5kb2N1bWVudFswXS5ib2R5KTtcXG4gICAgfSxcXG4gICAgX3NldE9wdGlvbjogZnVuY3Rpb24gX3NldE9wdGlvbihrZXksIHZhbHVlKSB7XFxuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xcblxcbiAgICAgIGlmIChrZXkgPT09IFxcXCJkaXNhYmxlZFxcXCIpIHtcXG4gICAgICAgIHRoaXNbdmFsdWUgPyBcXFwiX2Rpc2FibGVcXFwiIDogXFxcIl9lbmFibGVcXFwiXSgpO1xcbiAgICAgICAgdGhpcy5vcHRpb25zW2tleV0gPSB2YWx1ZTsgLy8gZGlzYWJsZSBlbGVtZW50IHN0eWxlIGNoYW5nZXNcXG5cXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fc3VwZXIoa2V5LCB2YWx1ZSk7XFxuXFxuICAgICAgaWYgKGtleSA9PT0gXFxcImNvbnRlbnRcXFwiKSB7XFxuICAgICAgICAkLmVhY2godGhpcy50b29sdGlwcywgZnVuY3Rpb24gKGlkLCB0b29sdGlwRGF0YSkge1xcbiAgICAgICAgICB0aGF0Ll91cGRhdGVDb250ZW50KHRvb2x0aXBEYXRhLmVsZW1lbnQpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfVxcbiAgICB9LFxcbiAgICBfZGlzYWJsZTogZnVuY3Rpb24gX2Rpc2FibGUoKSB7XFxuICAgICAgdmFyIHRoYXQgPSB0aGlzOyAvLyBjbG9zZSBvcGVuIHRvb2x0aXBzXFxuXFxuICAgICAgJC5lYWNoKHRoaXMudG9vbHRpcHMsIGZ1bmN0aW9uIChpZCwgdG9vbHRpcERhdGEpIHtcXG4gICAgICAgIHZhciBldmVudCA9ICQuRXZlbnQoXFxcImJsdXJcXFwiKTtcXG4gICAgICAgIGV2ZW50LnRhcmdldCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQgPSB0b29sdGlwRGF0YS5lbGVtZW50WzBdO1xcbiAgICAgICAgdGhhdC5jbG9zZShldmVudCwgdHJ1ZSk7XFxuICAgICAgfSk7IC8vIHJlbW92ZSB0aXRsZSBhdHRyaWJ1dGVzIHRvIHByZXZlbnQgbmF0aXZlIHRvb2x0aXBzXFxuXFxuICAgICAgdGhpcy5lbGVtZW50LmZpbmQodGhpcy5vcHRpb25zLml0ZW1zKS5hZGRCYWNrKCkuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgZWxlbWVudCA9ICQodGhpcyk7XFxuXFxuICAgICAgICBpZiAoZWxlbWVudC5pcyhcXFwiW3RpdGxlXVxcXCIpKSB7XFxuICAgICAgICAgIGVsZW1lbnQuZGF0YShcXFwidWktdG9vbHRpcC10aXRsZVxcXCIsIGVsZW1lbnQuYXR0cihcXFwidGl0bGVcXFwiKSkucmVtb3ZlQXR0cihcXFwidGl0bGVcXFwiKTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgfSxcXG4gICAgX2VuYWJsZTogZnVuY3Rpb24gX2VuYWJsZSgpIHtcXG4gICAgICAvLyByZXN0b3JlIHRpdGxlIGF0dHJpYnV0ZXNcXG4gICAgICB0aGlzLmVsZW1lbnQuZmluZCh0aGlzLm9wdGlvbnMuaXRlbXMpLmFkZEJhY2soKS5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciBlbGVtZW50ID0gJCh0aGlzKTtcXG5cXG4gICAgICAgIGlmIChlbGVtZW50LmRhdGEoXFxcInVpLXRvb2x0aXAtdGl0bGVcXFwiKSkge1xcbiAgICAgICAgICBlbGVtZW50LmF0dHIoXFxcInRpdGxlXFxcIiwgZWxlbWVudC5kYXRhKFxcXCJ1aS10b29sdGlwLXRpdGxlXFxcIikpO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcbiAgICB9LFxcbiAgICBvcGVuOiBmdW5jdGlvbiBvcGVuKGV2ZW50KSB7XFxuICAgICAgdmFyIHRoYXQgPSB0aGlzLFxcbiAgICAgICAgICB0YXJnZXQgPSAkKGV2ZW50ID8gZXZlbnQudGFyZ2V0IDogdGhpcy5lbGVtZW50KSAvLyB3ZSBuZWVkIGNsb3Nlc3QgaGVyZSBkdWUgdG8gbW91c2VvdmVyIGJ1YmJsaW5nLFxcbiAgICAgIC8vIGJ1dCBhbHdheXMgcG9pbnRpbmcgYXQgdGhlIHNhbWUgZXZlbnQgdGFyZ2V0XFxuICAgICAgLmNsb3Nlc3QodGhpcy5vcHRpb25zLml0ZW1zKTsgLy8gTm8gZWxlbWVudCB0byBzaG93IGEgdG9vbHRpcCBmb3Igb3IgdGhlIHRvb2x0aXAgaXMgYWxyZWFkeSBvcGVuXFxuXFxuICAgICAgaWYgKCF0YXJnZXQubGVuZ3RoIHx8IHRhcmdldC5kYXRhKFxcXCJ1aS10b29sdGlwLWlkXFxcIikpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRhcmdldC5hdHRyKFxcXCJ0aXRsZVxcXCIpKSB7XFxuICAgICAgICB0YXJnZXQuZGF0YShcXFwidWktdG9vbHRpcC10aXRsZVxcXCIsIHRhcmdldC5hdHRyKFxcXCJ0aXRsZVxcXCIpKTtcXG4gICAgICB9XFxuXFxuICAgICAgdGFyZ2V0LmRhdGEoXFxcInVpLXRvb2x0aXAtb3BlblxcXCIsIHRydWUpOyAvLyBraWxsIHBhcmVudCB0b29sdGlwcywgY3VzdG9tIG9yIG5hdGl2ZSwgZm9yIGhvdmVyXFxuXFxuICAgICAgaWYgKGV2ZW50ICYmIGV2ZW50LnR5cGUgPT09IFxcXCJtb3VzZW92ZXJcXFwiKSB7XFxuICAgICAgICB0YXJnZXQucGFyZW50cygpLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICB2YXIgcGFyZW50ID0gJCh0aGlzKSxcXG4gICAgICAgICAgICAgIGJsdXJFdmVudDtcXG5cXG4gICAgICAgICAgaWYgKHBhcmVudC5kYXRhKFxcXCJ1aS10b29sdGlwLW9wZW5cXFwiKSkge1xcbiAgICAgICAgICAgIGJsdXJFdmVudCA9ICQuRXZlbnQoXFxcImJsdXJcXFwiKTtcXG4gICAgICAgICAgICBibHVyRXZlbnQudGFyZ2V0ID0gYmx1ckV2ZW50LmN1cnJlbnRUYXJnZXQgPSB0aGlzO1xcbiAgICAgICAgICAgIHRoYXQuY2xvc2UoYmx1ckV2ZW50LCB0cnVlKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAocGFyZW50LmF0dHIoXFxcInRpdGxlXFxcIikpIHtcXG4gICAgICAgICAgICBwYXJlbnQudW5pcXVlSWQoKTtcXG4gICAgICAgICAgICB0aGF0LnBhcmVudHNbdGhpcy5pZF0gPSB7XFxuICAgICAgICAgICAgICBlbGVtZW50OiB0aGlzLFxcbiAgICAgICAgICAgICAgdGl0bGU6IHBhcmVudC5hdHRyKFxcXCJ0aXRsZVxcXCIpXFxuICAgICAgICAgICAgfTtcXG4gICAgICAgICAgICBwYXJlbnQuYXR0cihcXFwidGl0bGVcXFwiLCBcXFwiXFxcIik7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9yZWdpc3RlckNsb3NlSGFuZGxlcnMoZXZlbnQsIHRhcmdldCk7XFxuXFxuICAgICAgdGhpcy5fdXBkYXRlQ29udGVudCh0YXJnZXQsIGV2ZW50KTtcXG4gICAgfSxcXG4gICAgX3VwZGF0ZUNvbnRlbnQ6IGZ1bmN0aW9uIF91cGRhdGVDb250ZW50KHRhcmdldCwgZXZlbnQpIHtcXG4gICAgICB2YXIgY29udGVudCxcXG4gICAgICAgICAgY29udGVudE9wdGlvbiA9IHRoaXMub3B0aW9ucy5jb250ZW50LFxcbiAgICAgICAgICB0aGF0ID0gdGhpcyxcXG4gICAgICAgICAgZXZlbnRUeXBlID0gZXZlbnQgPyBldmVudC50eXBlIDogbnVsbDtcXG5cXG4gICAgICBpZiAodHlwZW9mIGNvbnRlbnRPcHRpb24gPT09IFxcXCJzdHJpbmdcXFwiKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5fb3BlbihldmVudCwgdGFyZ2V0LCBjb250ZW50T3B0aW9uKTtcXG4gICAgICB9XFxuXFxuICAgICAgY29udGVudCA9IGNvbnRlbnRPcHRpb24uY2FsbCh0YXJnZXRbMF0sIGZ1bmN0aW9uIChyZXNwb25zZSkge1xcbiAgICAgICAgLy8gSUUgbWF5IGluc3RhbnRseSBzZXJ2ZSBhIGNhY2hlZCByZXNwb25zZSBmb3IgYWpheCByZXF1ZXN0c1xcbiAgICAgICAgLy8gZGVsYXkgdGhpcyBjYWxsIHRvIF9vcGVuIHNvIHRoZSBvdGhlciBjYWxsIHRvIF9vcGVuIHJ1bnMgZmlyc3RcXG4gICAgICAgIHRoYXQuX2RlbGF5KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgLy8gSWdub3JlIGFzeW5jIHJlc3BvbnNlIGlmIHRvb2x0aXAgd2FzIGNsb3NlZCBhbHJlYWR5XFxuICAgICAgICAgIGlmICghdGFyZ2V0LmRhdGEoXFxcInVpLXRvb2x0aXAtb3BlblxcXCIpKSB7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICB9IC8vIGpRdWVyeSBjcmVhdGVzIGEgc3BlY2lhbCBldmVudCBmb3IgZm9jdXNpbiB3aGVuIGl0IGRvZXNuJ3RcXG4gICAgICAgICAgLy8gZXhpc3QgbmF0aXZlbHkuIFRvIGltcHJvdmUgcGVyZm9ybWFuY2UsIHRoZSBuYXRpdmUgZXZlbnRcXG4gICAgICAgICAgLy8gb2JqZWN0IGlzIHJldXNlZCBhbmQgdGhlIHR5cGUgaXMgY2hhbmdlZC4gVGhlcmVmb3JlLCB3ZSBjYW4ndFxcbiAgICAgICAgICAvLyByZWx5IG9uIHRoZSB0eXBlIGJlaW5nIGNvcnJlY3QgYWZ0ZXIgdGhlIGV2ZW50IGZpbmlzaGVkXFxuICAgICAgICAgIC8vIGJ1YmJsaW5nLCBzbyB3ZSBzZXQgaXQgYmFjayB0byB0aGUgcHJldmlvdXMgdmFsdWUuICgjODc0MClcXG5cXG5cXG4gICAgICAgICAgaWYgKGV2ZW50KSB7XFxuICAgICAgICAgICAgZXZlbnQudHlwZSA9IGV2ZW50VHlwZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICB0aGlzLl9vcGVuKGV2ZW50LCB0YXJnZXQsIHJlc3BvbnNlKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH0pO1xcblxcbiAgICAgIGlmIChjb250ZW50KSB7XFxuICAgICAgICB0aGlzLl9vcGVuKGV2ZW50LCB0YXJnZXQsIGNvbnRlbnQpO1xcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgX29wZW46IGZ1bmN0aW9uIF9vcGVuKGV2ZW50LCB0YXJnZXQsIGNvbnRlbnQpIHtcXG4gICAgICB2YXIgdG9vbHRpcERhdGEsXFxuICAgICAgICAgIHRvb2x0aXAsXFxuICAgICAgICAgIGRlbGF5ZWRTaG93LFxcbiAgICAgICAgICBhMTF5Q29udGVudCxcXG4gICAgICAgICAgcG9zaXRpb25PcHRpb24gPSAkLmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zLnBvc2l0aW9uKTtcXG5cXG4gICAgICBpZiAoIWNvbnRlbnQpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9IC8vIENvbnRlbnQgY2FuIGJlIHVwZGF0ZWQgbXVsdGlwbGUgdGltZXMuIElmIHRoZSB0b29sdGlwIGFscmVhZHlcXG4gICAgICAvLyBleGlzdHMsIHRoZW4ganVzdCB1cGRhdGUgdGhlIGNvbnRlbnQgYW5kIGJhaWwuXFxuXFxuXFxuICAgICAgdG9vbHRpcERhdGEgPSB0aGlzLl9maW5kKHRhcmdldCk7XFxuXFxuICAgICAgaWYgKHRvb2x0aXBEYXRhKSB7XFxuICAgICAgICB0b29sdGlwRGF0YS50b29sdGlwLmZpbmQoXFxcIi51aS10b29sdGlwLWNvbnRlbnRcXFwiKS5odG1sKGNvbnRlbnQpO1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH0gLy8gaWYgd2UgaGF2ZSBhIHRpdGxlLCBjbGVhciBpdCB0byBwcmV2ZW50IHRoZSBuYXRpdmUgdG9vbHRpcFxcbiAgICAgIC8vIHdlIGhhdmUgdG8gY2hlY2sgZmlyc3QgdG8gYXZvaWQgZGVmaW5pbmcgYSB0aXRsZSBpZiBub25lIGV4aXN0c1xcbiAgICAgIC8vICh3ZSBkb24ndCB3YW50IHRvIGNhdXNlIGFuIGVsZW1lbnQgdG8gc3RhcnQgbWF0Y2hpbmcgW3RpdGxlXSlcXG4gICAgICAvL1xcbiAgICAgIC8vIFdlIHVzZSByZW1vdmVBdHRyIG9ubHkgZm9yIGtleSBldmVudHMsIHRvIGFsbG93IElFIHRvIGV4cG9ydCB0aGUgY29ycmVjdFxcbiAgICAgIC8vIGFjY2Vzc2libGUgYXR0cmlidXRlcy4gRm9yIG1vdXNlIGV2ZW50cywgc2V0IHRvIGVtcHR5IHN0cmluZyB0byBhdm9pZFxcbiAgICAgIC8vIG5hdGl2ZSB0b29sdGlwIHNob3dpbmcgdXAgKGhhcHBlbnMgb25seSB3aGVuIHJlbW92aW5nIGluc2lkZSBtb3VzZW92ZXIpLlxcblxcblxcbiAgICAgIGlmICh0YXJnZXQuaXMoXFxcIlt0aXRsZV1cXFwiKSkge1xcbiAgICAgICAgaWYgKGV2ZW50ICYmIGV2ZW50LnR5cGUgPT09IFxcXCJtb3VzZW92ZXJcXFwiKSB7XFxuICAgICAgICAgIHRhcmdldC5hdHRyKFxcXCJ0aXRsZVxcXCIsIFxcXCJcXFwiKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHRhcmdldC5yZW1vdmVBdHRyKFxcXCJ0aXRsZVxcXCIpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICB0b29sdGlwRGF0YSA9IHRoaXMuX3Rvb2x0aXAodGFyZ2V0KTtcXG4gICAgICB0b29sdGlwID0gdG9vbHRpcERhdGEudG9vbHRpcDtcXG5cXG4gICAgICB0aGlzLl9hZGREZXNjcmliZWRCeSh0YXJnZXQsIHRvb2x0aXAuYXR0cihcXFwiaWRcXFwiKSk7XFxuXFxuICAgICAgdG9vbHRpcC5maW5kKFxcXCIudWktdG9vbHRpcC1jb250ZW50XFxcIikuaHRtbChjb250ZW50KTsgLy8gU3VwcG9ydDogVm9pY2VvdmVyIG9uIE9TIFgsIEpBV1Mgb24gSUUgPD0gOVxcbiAgICAgIC8vIEpBV1MgYW5ub3VuY2VzIGRlbGV0aW9ucyBldmVuIHdoZW4gYXJpYS1yZWxldmFudD1cXFwiYWRkaXRpb25zXFxcIlxcbiAgICAgIC8vIFZvaWNlb3ZlciB3aWxsIHNvbWV0aW1lcyByZS1yZWFkIHRoZSBlbnRpcmUgbG9nIHJlZ2lvbidzIGNvbnRlbnRzIGZyb20gdGhlIGJlZ2lubmluZ1xcblxcbiAgICAgIHRoaXMubGl2ZVJlZ2lvbi5jaGlsZHJlbigpLmhpZGUoKTtcXG5cXG4gICAgICBpZiAoY29udGVudC5jbG9uZSkge1xcbiAgICAgICAgYTExeUNvbnRlbnQgPSBjb250ZW50LmNsb25lKCk7XFxuICAgICAgICBhMTF5Q29udGVudC5yZW1vdmVBdHRyKFxcXCJpZFxcXCIpLmZpbmQoXFxcIltpZF1cXFwiKS5yZW1vdmVBdHRyKFxcXCJpZFxcXCIpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBhMTF5Q29udGVudCA9IGNvbnRlbnQ7XFxuICAgICAgfVxcblxcbiAgICAgICQoXFxcIjxkaXY+XFxcIikuaHRtbChhMTF5Q29udGVudCkuYXBwZW5kVG8odGhpcy5saXZlUmVnaW9uKTtcXG5cXG4gICAgICBmdW5jdGlvbiBwb3NpdGlvbihldmVudCkge1xcbiAgICAgICAgcG9zaXRpb25PcHRpb24ub2YgPSBldmVudDtcXG5cXG4gICAgICAgIGlmICh0b29sdGlwLmlzKFxcXCI6aGlkZGVuXFxcIikpIHtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdG9vbHRpcC5wb3NpdGlvbihwb3NpdGlvbk9wdGlvbik7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudHJhY2sgJiYgZXZlbnQgJiYgL15tb3VzZS8udGVzdChldmVudC50eXBlKSkge1xcbiAgICAgICAgdGhpcy5fb24odGhpcy5kb2N1bWVudCwge1xcbiAgICAgICAgICBtb3VzZW1vdmU6IHBvc2l0aW9uXFxuICAgICAgICB9KTsgLy8gdHJpZ2dlciBvbmNlIHRvIG92ZXJyaWRlIGVsZW1lbnQtcmVsYXRpdmUgcG9zaXRpb25pbmdcXG5cXG5cXG4gICAgICAgIHBvc2l0aW9uKGV2ZW50KTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdG9vbHRpcC5wb3NpdGlvbigkLmV4dGVuZCh7XFxuICAgICAgICAgIG9mOiB0YXJnZXRcXG4gICAgICAgIH0sIHRoaXMub3B0aW9ucy5wb3NpdGlvbikpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0b29sdGlwLmhpZGUoKTtcXG5cXG4gICAgICB0aGlzLl9zaG93KHRvb2x0aXAsIHRoaXMub3B0aW9ucy5zaG93KTsgLy8gSGFuZGxlIHRyYWNraW5nIHRvb2x0aXBzIHRoYXQgYXJlIHNob3duIHdpdGggYSBkZWxheSAoIzg2NDQpLiBBcyBzb29uXFxuICAgICAgLy8gYXMgdGhlIHRvb2x0aXAgaXMgdmlzaWJsZSwgcG9zaXRpb24gdGhlIHRvb2x0aXAgdXNpbmcgdGhlIG1vc3QgcmVjZW50XFxuICAgICAgLy8gZXZlbnQuXFxuXFxuXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaG93ICYmIHRoaXMub3B0aW9ucy5zaG93LmRlbGF5KSB7XFxuICAgICAgICBkZWxheWVkU2hvdyA9IHRoaXMuZGVsYXllZFNob3cgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIGlmICh0b29sdGlwLmlzKFxcXCI6dmlzaWJsZVxcXCIpKSB7XFxuICAgICAgICAgICAgcG9zaXRpb24ocG9zaXRpb25PcHRpb24ub2YpO1xcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoZGVsYXllZFNob3cpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9LCAkLmZ4LmludGVydmFsKTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fdHJpZ2dlcihcXFwib3BlblxcXCIsIGV2ZW50LCB7XFxuICAgICAgICB0b29sdGlwOiB0b29sdGlwXFxuICAgICAgfSk7XFxuICAgIH0sXFxuICAgIF9yZWdpc3RlckNsb3NlSGFuZGxlcnM6IGZ1bmN0aW9uIF9yZWdpc3RlckNsb3NlSGFuZGxlcnMoZXZlbnQsIHRhcmdldCkge1xcbiAgICAgIHZhciBldmVudHMgPSB7XFxuICAgICAgICBrZXl1cDogZnVuY3Rpb24ga2V5dXAoZXZlbnQpIHtcXG4gICAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09ICQudWkua2V5Q29kZS5FU0NBUEUpIHtcXG4gICAgICAgICAgICB2YXIgZmFrZUV2ZW50ID0gJC5FdmVudChldmVudCk7XFxuICAgICAgICAgICAgZmFrZUV2ZW50LmN1cnJlbnRUYXJnZXQgPSB0YXJnZXRbMF07XFxuICAgICAgICAgICAgdGhpcy5jbG9zZShmYWtlRXZlbnQsIHRydWUpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfTsgLy8gT25seSBiaW5kIHJlbW92ZSBoYW5kbGVyIGZvciBkZWxlZ2F0ZWQgdGFyZ2V0cy4gTm9uLWRlbGVnYXRlZFxcbiAgICAgIC8vIHRvb2x0aXBzIHdpbGwgaGFuZGxlIHRoaXMgaW4gZGVzdHJveS5cXG5cXG4gICAgICBpZiAodGFyZ2V0WzBdICE9PSB0aGlzLmVsZW1lbnRbMF0pIHtcXG4gICAgICAgIGV2ZW50cy5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHRoaXMuX3JlbW92ZVRvb2x0aXAodGhpcy5fZmluZCh0YXJnZXQpLnRvb2x0aXApO1xcbiAgICAgICAgfTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCFldmVudCB8fCBldmVudC50eXBlID09PSBcXFwibW91c2VvdmVyXFxcIikge1xcbiAgICAgICAgZXZlbnRzLm1vdXNlbGVhdmUgPSBcXFwiY2xvc2VcXFwiO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIWV2ZW50IHx8IGV2ZW50LnR5cGUgPT09IFxcXCJmb2N1c2luXFxcIikge1xcbiAgICAgICAgZXZlbnRzLmZvY3Vzb3V0ID0gXFxcImNsb3NlXFxcIjtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fb24odHJ1ZSwgdGFyZ2V0LCBldmVudHMpO1xcbiAgICB9LFxcbiAgICBjbG9zZTogZnVuY3Rpb24gY2xvc2UoZXZlbnQpIHtcXG4gICAgICB2YXIgdG9vbHRpcCxcXG4gICAgICAgICAgdGhhdCA9IHRoaXMsXFxuICAgICAgICAgIHRhcmdldCA9ICQoZXZlbnQgPyBldmVudC5jdXJyZW50VGFyZ2V0IDogdGhpcy5lbGVtZW50KSxcXG4gICAgICAgICAgdG9vbHRpcERhdGEgPSB0aGlzLl9maW5kKHRhcmdldCk7IC8vIFRoZSB0b29sdGlwIG1heSBhbHJlYWR5IGJlIGNsb3NlZFxcblxcblxcbiAgICAgIGlmICghdG9vbHRpcERhdGEpIHtcXG4gICAgICAgIC8vIFdlIHNldCB1aS10b29sdGlwLW9wZW4gaW1tZWRpYXRlbHkgdXBvbiBvcGVuIChpbiBvcGVuKCkpLCBidXQgb25seSBzZXQgdGhlXFxuICAgICAgICAvLyBhZGRpdGlvbmFsIGRhdGEgb25jZSB0aGVyZSdzIGFjdHVhbGx5IGNvbnRlbnQgdG8gc2hvdyAoaW4gX29wZW4oKSkuIFNvIGV2ZW4gaWYgdGhlXFxuICAgICAgICAvLyB0b29sdGlwIGRvZXNuJ3QgaGF2ZSBmdWxsIGRhdGEsIHdlIGFsd2F5cyByZW1vdmUgdWktdG9vbHRpcC1vcGVuIGluIGNhc2Ugd2UncmUgaW5cXG4gICAgICAgIC8vIHRoZSBwZXJpb2QgYmV0d2VlbiBvcGVuKCkgYW5kIF9vcGVuKCkuXFxuICAgICAgICB0YXJnZXQucmVtb3ZlRGF0YShcXFwidWktdG9vbHRpcC1vcGVuXFxcIik7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIHRvb2x0aXAgPSB0b29sdGlwRGF0YS50b29sdGlwOyAvLyBkaXNhYmxpbmcgY2xvc2VzIHRoZSB0b29sdGlwLCBzbyB3ZSBuZWVkIHRvIHRyYWNrIHdoZW4gd2UncmUgY2xvc2luZ1xcbiAgICAgIC8vIHRvIGF2b2lkIGFuIGluZmluaXRlIGxvb3AgaW4gY2FzZSB0aGUgdG9vbHRpcCBiZWNvbWVzIGRpc2FibGVkIG9uIGNsb3NlXFxuXFxuICAgICAgaWYgKHRvb2x0aXBEYXRhLmNsb3NpbmcpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9IC8vIENsZWFyIHRoZSBpbnRlcnZhbCBmb3IgZGVsYXllZCB0cmFja2luZyB0b29sdGlwc1xcblxcblxcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5kZWxheWVkU2hvdyk7IC8vIG9ubHkgc2V0IHRpdGxlIGlmIHdlIGhhZCBvbmUgYmVmb3JlIChzZWUgY29tbWVudCBpbiBfb3BlbigpKVxcbiAgICAgIC8vIElmIHRoZSB0aXRsZSBhdHRyaWJ1dGUgaGFzIGNoYW5nZWQgc2luY2Ugb3BlbigpLCBkb24ndCByZXN0b3JlXFxuXFxuICAgICAgaWYgKHRhcmdldC5kYXRhKFxcXCJ1aS10b29sdGlwLXRpdGxlXFxcIikgJiYgIXRhcmdldC5hdHRyKFxcXCJ0aXRsZVxcXCIpKSB7XFxuICAgICAgICB0YXJnZXQuYXR0cihcXFwidGl0bGVcXFwiLCB0YXJnZXQuZGF0YShcXFwidWktdG9vbHRpcC10aXRsZVxcXCIpKTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fcmVtb3ZlRGVzY3JpYmVkQnkodGFyZ2V0KTtcXG5cXG4gICAgICB0b29sdGlwRGF0YS5oaWRpbmcgPSB0cnVlO1xcbiAgICAgIHRvb2x0aXAuc3RvcCh0cnVlKTtcXG5cXG4gICAgICB0aGlzLl9oaWRlKHRvb2x0aXAsIHRoaXMub3B0aW9ucy5oaWRlLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICB0aGF0Ll9yZW1vdmVUb29sdGlwKCQodGhpcykpO1xcbiAgICAgIH0pO1xcblxcbiAgICAgIHRhcmdldC5yZW1vdmVEYXRhKFxcXCJ1aS10b29sdGlwLW9wZW5cXFwiKTtcXG5cXG4gICAgICB0aGlzLl9vZmYodGFyZ2V0LCBcXFwibW91c2VsZWF2ZSBmb2N1c291dCBrZXl1cFxcXCIpOyAvLyBSZW1vdmUgJ3JlbW92ZScgYmluZGluZyBvbmx5IG9uIGRlbGVnYXRlZCB0YXJnZXRzXFxuXFxuXFxuICAgICAgaWYgKHRhcmdldFswXSAhPT0gdGhpcy5lbGVtZW50WzBdKSB7XFxuICAgICAgICB0aGlzLl9vZmYodGFyZ2V0LCBcXFwicmVtb3ZlXFxcIik7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX29mZih0aGlzLmRvY3VtZW50LCBcXFwibW91c2Vtb3ZlXFxcIik7XFxuXFxuICAgICAgaWYgKGV2ZW50ICYmIGV2ZW50LnR5cGUgPT09IFxcXCJtb3VzZWxlYXZlXFxcIikge1xcbiAgICAgICAgJC5lYWNoKHRoaXMucGFyZW50cywgZnVuY3Rpb24gKGlkLCBwYXJlbnQpIHtcXG4gICAgICAgICAgJChwYXJlbnQuZWxlbWVudCkuYXR0cihcXFwidGl0bGVcXFwiLCBwYXJlbnQudGl0bGUpO1xcbiAgICAgICAgICBkZWxldGUgdGhhdC5wYXJlbnRzW2lkXTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG5cXG4gICAgICB0b29sdGlwRGF0YS5jbG9zaW5nID0gdHJ1ZTtcXG5cXG4gICAgICB0aGlzLl90cmlnZ2VyKFxcXCJjbG9zZVxcXCIsIGV2ZW50LCB7XFxuICAgICAgICB0b29sdGlwOiB0b29sdGlwXFxuICAgICAgfSk7XFxuXFxuICAgICAgaWYgKCF0b29sdGlwRGF0YS5oaWRpbmcpIHtcXG4gICAgICAgIHRvb2x0aXBEYXRhLmNsb3NpbmcgPSBmYWxzZTtcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIF90b29sdGlwOiBmdW5jdGlvbiBfdG9vbHRpcChlbGVtZW50KSB7XFxuICAgICAgdmFyIHRvb2x0aXAgPSAkKFxcXCI8ZGl2PlxcXCIpLmF0dHIoXFxcInJvbGVcXFwiLCBcXFwidG9vbHRpcFxcXCIpLmFkZENsYXNzKFxcXCJ1aS10b29sdGlwIHVpLXdpZGdldCB1aS1jb3JuZXItYWxsIHVpLXdpZGdldC1jb250ZW50IFxcXCIgKyAodGhpcy5vcHRpb25zLnRvb2x0aXBDbGFzcyB8fCBcXFwiXFxcIikpLFxcbiAgICAgICAgICBpZCA9IHRvb2x0aXAudW5pcXVlSWQoKS5hdHRyKFxcXCJpZFxcXCIpO1xcbiAgICAgICQoXFxcIjxkaXY+XFxcIikuYWRkQ2xhc3MoXFxcInVpLXRvb2x0aXAtY29udGVudFxcXCIpLmFwcGVuZFRvKHRvb2x0aXApO1xcbiAgICAgIHRvb2x0aXAuYXBwZW5kVG8odGhpcy5kb2N1bWVudFswXS5ib2R5KTtcXG4gICAgICByZXR1cm4gdGhpcy50b29sdGlwc1tpZF0gPSB7XFxuICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxcbiAgICAgICAgdG9vbHRpcDogdG9vbHRpcFxcbiAgICAgIH07XFxuICAgIH0sXFxuICAgIF9maW5kOiBmdW5jdGlvbiBfZmluZCh0YXJnZXQpIHtcXG4gICAgICB2YXIgaWQgPSB0YXJnZXQuZGF0YShcXFwidWktdG9vbHRpcC1pZFxcXCIpO1xcbiAgICAgIHJldHVybiBpZCA/IHRoaXMudG9vbHRpcHNbaWRdIDogbnVsbDtcXG4gICAgfSxcXG4gICAgX3JlbW92ZVRvb2x0aXA6IGZ1bmN0aW9uIF9yZW1vdmVUb29sdGlwKHRvb2x0aXApIHtcXG4gICAgICB0b29sdGlwLnJlbW92ZSgpO1xcbiAgICAgIGRlbGV0ZSB0aGlzLnRvb2x0aXBzW3Rvb2x0aXAuYXR0cihcXFwiaWRcXFwiKV07XFxuICAgIH0sXFxuICAgIF9kZXN0cm95OiBmdW5jdGlvbiBfZGVzdHJveSgpIHtcXG4gICAgICB2YXIgdGhhdCA9IHRoaXM7IC8vIGNsb3NlIG9wZW4gdG9vbHRpcHNcXG5cXG4gICAgICAkLmVhY2godGhpcy50b29sdGlwcywgZnVuY3Rpb24gKGlkLCB0b29sdGlwRGF0YSkge1xcbiAgICAgICAgLy8gRGVsZWdhdGUgdG8gY2xvc2UgbWV0aG9kIHRvIGhhbmRsZSBjb21tb24gY2xlYW51cFxcbiAgICAgICAgdmFyIGV2ZW50ID0gJC5FdmVudChcXFwiYmx1clxcXCIpLFxcbiAgICAgICAgICAgIGVsZW1lbnQgPSB0b29sdGlwRGF0YS5lbGVtZW50O1xcbiAgICAgICAgZXZlbnQudGFyZ2V0ID0gZXZlbnQuY3VycmVudFRhcmdldCA9IGVsZW1lbnRbMF07XFxuICAgICAgICB0aGF0LmNsb3NlKGV2ZW50LCB0cnVlKTsgLy8gUmVtb3ZlIGltbWVkaWF0ZWx5OyBkZXN0cm95aW5nIGFuIG9wZW4gdG9vbHRpcCBkb2Vzbid0IHVzZSB0aGVcXG4gICAgICAgIC8vIGhpZGUgYW5pbWF0aW9uXFxuXFxuICAgICAgICAkKFxcXCIjXFxcIiArIGlkKS5yZW1vdmUoKTsgLy8gUmVzdG9yZSB0aGUgdGl0bGVcXG5cXG4gICAgICAgIGlmIChlbGVtZW50LmRhdGEoXFxcInVpLXRvb2x0aXAtdGl0bGVcXFwiKSkge1xcbiAgICAgICAgICAvLyBJZiB0aGUgdGl0bGUgYXR0cmlidXRlIGhhcyBjaGFuZ2VkIHNpbmNlIG9wZW4oKSwgZG9uJ3QgcmVzdG9yZVxcbiAgICAgICAgICBpZiAoIWVsZW1lbnQuYXR0cihcXFwidGl0bGVcXFwiKSkge1xcbiAgICAgICAgICAgIGVsZW1lbnQuYXR0cihcXFwidGl0bGVcXFwiLCBlbGVtZW50LmRhdGEoXFxcInVpLXRvb2x0aXAtdGl0bGVcXFwiKSk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZWxlbWVudC5yZW1vdmVEYXRhKFxcXCJ1aS10b29sdGlwLXRpdGxlXFxcIik7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgICAgdGhpcy5saXZlUmVnaW9uLnJlbW92ZSgpO1xcbiAgICB9XFxuICB9KTtcXG59KTtcIiIsIm1vZHVsZS5leHBvcnRzID0gXCIvKiFcXG4gKiBqUXVlcnkgVXBsb2FkIEZpbGUgUGx1Z2luXFxuICogdmVyc2lvbjogNC4wLjExXFxuICogQHJlcXVpcmVzIGpRdWVyeSB2MS41IG9yIGxhdGVyICYgZm9ybSBwbHVnaW5cXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMgUmF2aXNoYW5rZXIgS3VzdW1hXFxuICogaHR0cDovL2hheWFnZWVrLmNvbS9cXG4gKi9cXG4oZnVuY3Rpb24gKCQpIHtcXG4gIGlmICgkLmZuLmFqYXhGb3JtID09IHVuZGVmaW5lZCkge1xcbiAgICAkLmdldFNjcmlwdCgoXFxcImh0dHBzOlxcXCIgPT0gZG9jdW1lbnQubG9jYXRpb24ucHJvdG9jb2wgPyBcXFwiaHR0cHM6Ly9cXFwiIDogXFxcImh0dHA6Ly9cXFwiKSArIFxcXCJtYWxzdXAuZ2l0aHViLmlvL2pxdWVyeS5mb3JtLmpzXFxcIik7XFxuICB9XFxuXFxuICB2YXIgZmVhdHVyZSA9IHt9O1xcbiAgZmVhdHVyZS5maWxlYXBpID0gJChcXFwiPGlucHV0IHR5cGU9J2ZpbGUnLz5cXFwiKS5nZXQoMCkuZmlsZXMgIT09IHVuZGVmaW5lZDtcXG4gIGZlYXR1cmUuZm9ybWRhdGEgPSB3aW5kb3cuRm9ybURhdGEgIT09IHVuZGVmaW5lZDtcXG5cXG4gICQuZm4udXBsb2FkRmlsZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XFxuICAgIC8vIFRoaXMgaXMgdGhlIGVhc2llc3Qgd2F5IHRvIGhhdmUgZGVmYXVsdCBvcHRpb25zLlxcbiAgICB2YXIgcyA9ICQuZXh0ZW5kKHtcXG4gICAgICAvLyBUaGVzZSBhcmUgdGhlIGRlZmF1bHRzLlxcbiAgICAgIHVybDogXFxcIlxcXCIsXFxuICAgICAgbWV0aG9kOiBcXFwiUE9TVFxcXCIsXFxuICAgICAgZW5jdHlwZTogXFxcIm11bHRpcGFydC9mb3JtLWRhdGFcXFwiLFxcbiAgICAgIHJldHVyblR5cGU6IG51bGwsXFxuICAgICAgYWxsb3dEdXBsaWNhdGVzOiB0cnVlLFxcbiAgICAgIGR1cGxpY2F0ZVN0cmljdDogZmFsc2UsXFxuICAgICAgYWxsb3dlZFR5cGVzOiBcXFwiKlxcXCIsXFxuICAgICAgLy9Gb3IgbGlzdCBvZiBhY2NlcHRGaWxlc1xcbiAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTE4MzI5MzAvaHRtbC1pbnB1dC1maWxlLWFjY2VwdC1hdHRyaWJ1dGUtZmlsZS10eXBlLWNzdlxcbiAgICAgIGFjY2VwdEZpbGVzOiBcXFwiKlxcXCIsXFxuICAgICAgZmlsZU5hbWU6IFxcXCJmaWxlXFxcIixcXG4gICAgICBmb3JtRGF0YTogZmFsc2UsXFxuICAgICAgZHluYW1pY0Zvcm1EYXRhOiBmYWxzZSxcXG4gICAgICBtYXhGaWxlU2l6ZTogLTEsXFxuICAgICAgbWF4RmlsZUNvdW50OiAtMSxcXG4gICAgICBtdWx0aXBsZTogdHJ1ZSxcXG4gICAgICBkcmFnRHJvcDogdHJ1ZSxcXG4gICAgICBhdXRvU3VibWl0OiB0cnVlLFxcbiAgICAgIHNob3dDYW5jZWw6IHRydWUsXFxuICAgICAgc2hvd0Fib3J0OiB0cnVlLFxcbiAgICAgIHNob3dEb25lOiBmYWxzZSxcXG4gICAgICBzaG93RGVsZXRlOiBmYWxzZSxcXG4gICAgICBzaG93RXJyb3I6IHRydWUsXFxuICAgICAgc2hvd1N0YXR1c0FmdGVyU3VjY2VzczogdHJ1ZSxcXG4gICAgICBzaG93U3RhdHVzQWZ0ZXJFcnJvcjogdHJ1ZSxcXG4gICAgICBzaG93RmlsZUNvdW50ZXI6IHRydWUsXFxuICAgICAgZmlsZUNvdW50ZXJTdHlsZTogXFxcIikuIFxcXCIsXFxuICAgICAgc2hvd0ZpbGVTaXplOiB0cnVlLFxcbiAgICAgIHNob3dQcm9ncmVzczogZmFsc2UsXFxuICAgICAgbmVzdGVkRm9ybXM6IHRydWUsXFxuICAgICAgc2hvd0Rvd25sb2FkOiBmYWxzZSxcXG4gICAgICBvbkxvYWQ6IGZ1bmN0aW9uIG9uTG9hZChvYmopIHt9LFxcbiAgICAgIG9uU2VsZWN0OiBmdW5jdGlvbiBvblNlbGVjdChmaWxlcykge1xcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgfSxcXG4gICAgICBvblN1Ym1pdDogZnVuY3Rpb24gb25TdWJtaXQoZmlsZXMsIHhocikge30sXFxuICAgICAgb25TdWNjZXNzOiBmdW5jdGlvbiBvblN1Y2Nlc3MoZmlsZXMsIHJlc3BvbnNlLCB4aHIsIHBkKSB7fSxcXG4gICAgICBvbkVycm9yOiBmdW5jdGlvbiBvbkVycm9yKGZpbGVzLCBzdGF0dXMsIG1lc3NhZ2UsIHBkKSB7fSxcXG4gICAgICBvbkNhbmNlbDogZnVuY3Rpb24gb25DYW5jZWwoZmlsZXMsIHBkKSB7fSxcXG4gICAgICBvbkFib3J0OiBmdW5jdGlvbiBvbkFib3J0KGZpbGVzLCBwZCkge30sXFxuICAgICAgZG93bmxvYWRDYWxsYmFjazogZmFsc2UsXFxuICAgICAgZGVsZXRlQ2FsbGJhY2s6IGZhbHNlLFxcbiAgICAgIGFmdGVyVXBsb2FkQWxsOiBmYWxzZSxcXG4gICAgICBzZXJpYWxpemU6IHRydWUsXFxuICAgICAgc2VxdWVudGlhbDogZmFsc2UsXFxuICAgICAgc2VxdWVudGlhbENvdW50OiAyLFxcbiAgICAgIGN1c3RvbVByb2dyZXNzQmFyOiBmYWxzZSxcXG4gICAgICBhYm9ydEJ1dHRvbkNsYXNzOiBcXFwiYWpheC1maWxlLXVwbG9hZC1hYm9ydFxcXCIsXFxuICAgICAgY2FuY2VsQnV0dG9uQ2xhc3M6IFxcXCJhamF4LWZpbGUtdXBsb2FkLWNhbmNlbFxcXCIsXFxuICAgICAgZHJhZ0Ryb3BDb250YWluZXJDbGFzczogXFxcImFqYXgtdXBsb2FkLWRyYWdkcm9wXFxcIixcXG4gICAgICBkcmFnRHJvcEhvdmVyQ2xhc3M6IFxcXCJzdGF0ZS1ob3ZlclxcXCIsXFxuICAgICAgZXJyb3JDbGFzczogXFxcImFqYXgtZmlsZS11cGxvYWQtZXJyb3JcXFwiLFxcbiAgICAgIHVwbG9hZEJ1dHRvbkNsYXNzOiBcXFwiYWpheC1maWxlLXVwbG9hZFxcXCIsXFxuICAgICAgZHJhZ0Ryb3BTdHI6IFxcXCI8c3Bhbj48Yj5EcmFnICZhbXA7IERyb3AgRmlsZXM8L2I+PC9zcGFuPlxcXCIsXFxuICAgICAgdXBsb2FkU3RyOiBcXFwiVXBsb2FkXFxcIixcXG4gICAgICBhYm9ydFN0cjogXFxcIkFib3J0XFxcIixcXG4gICAgICBjYW5jZWxTdHI6IFxcXCJDYW5jZWxcXFwiLFxcbiAgICAgIGRlbGV0ZVN0cjogXFxcIkRlbGV0ZVxcXCIsXFxuICAgICAgZG9uZVN0cjogXFxcIkRvbmVcXFwiLFxcbiAgICAgIG11bHRpRHJhZ0Vycm9yU3RyOiBcXFwiTXVsdGlwbGUgRmlsZSBEcmFnICZhbXA7IERyb3AgaXMgbm90IGFsbG93ZWQuXFxcIixcXG4gICAgICBleHRFcnJvclN0cjogXFxcImlzIG5vdCBhbGxvd2VkLiBBbGxvd2VkIGV4dGVuc2lvbnM6IFxcXCIsXFxuICAgICAgZHVwbGljYXRlRXJyb3JTdHI6IFxcXCJpcyBub3QgYWxsb3dlZC4gRmlsZSBhbHJlYWR5IGV4aXN0cy5cXFwiLFxcbiAgICAgIHNpemVFcnJvclN0cjogXFxcImlzIG5vdCBhbGxvd2VkLiBBbGxvd2VkIE1heCBzaXplOiBcXFwiLFxcbiAgICAgIHVwbG9hZEVycm9yU3RyOiBcXFwiVXBsb2FkIGlzIG5vdCBhbGxvd2VkXFxcIixcXG4gICAgICBtYXhGaWxlQ291bnRFcnJvclN0cjogXFxcIiBpcyBub3QgYWxsb3dlZC4gTWF4aW11bSBhbGxvd2VkIGZpbGVzIGFyZTpcXFwiLFxcbiAgICAgIGRvd25sb2FkU3RyOiBcXFwiRG93bmxvYWRcXFwiLFxcbiAgICAgIGN1c3RvbUVycm9yS2V5U3RyOiBcXFwianF1ZXJ5LXVwbG9hZC1maWxlLWVycm9yXFxcIixcXG4gICAgICBzaG93UXVldWVEaXY6IGZhbHNlLFxcbiAgICAgIHN0YXR1c0JhcldpZHRoOiA0MDAsXFxuICAgICAgZHJhZ2Ryb3BXaWR0aDogNDAwLFxcbiAgICAgIHNob3dQcmV2aWV3OiBmYWxzZSxcXG4gICAgICBwcmV2aWV3SGVpZ2h0OiBcXFwiYXV0b1xcXCIsXFxuICAgICAgcHJldmlld1dpZHRoOiBcXFwiMTAwJVxcXCIsXFxuICAgICAgZXh0cmFIVE1MOiBmYWxzZSxcXG4gICAgICB1cGxvYWRRdWV1ZU9yZGVyOiAndG9wJyxcXG4gICAgICBoZWFkZXJzOiB7fVxcbiAgICB9LCBvcHRpb25zKTtcXG4gICAgdGhpcy5maWxlQ291bnRlciA9IDE7XFxuICAgIHRoaXMuc2VsZWN0ZWRGaWxlcyA9IDA7XFxuICAgIHZhciBmb3JtR3JvdXAgPSBcXFwiYWpheC1maWxlLXVwbG9hZC1cXFwiICsgbmV3IERhdGUoKS5nZXRUaW1lKCk7XFxuICAgIHRoaXMuZm9ybUdyb3VwID0gZm9ybUdyb3VwO1xcbiAgICB0aGlzLmVycm9yTG9nID0gJChcXFwiPGRpdj48L2Rpdj5cXFwiKTsgLy9Xcml0aW5nIGVycm9yc1xcblxcbiAgICB0aGlzLnJlc3BvbnNlcyA9IFtdO1xcbiAgICB0aGlzLmV4aXN0aW5nRmlsZU5hbWVzID0gW107XFxuXFxuICAgIGlmICghZmVhdHVyZS5mb3JtZGF0YSkgLy9jaGVjayBkcmFnIGRyb3AgZW5hYmxlZC5cXG4gICAgICB7XFxuICAgICAgICBzLmRyYWdEcm9wID0gZmFsc2U7XFxuICAgICAgfVxcblxcbiAgICBpZiAoIWZlYXR1cmUuZm9ybWRhdGEgfHwgcy5tYXhGaWxlQ291bnQgPT09IDEpIHtcXG4gICAgICBzLm11bHRpcGxlID0gZmFsc2U7XFxuICAgIH1cXG5cXG4gICAgJCh0aGlzKS5odG1sKFxcXCJcXFwiKTtcXG4gICAgdmFyIG9iaiA9IHRoaXM7XFxuICAgIHZhciB1cGxvYWRMYWJlbCA9ICQoJzxkaXY+JyArIHMudXBsb2FkU3RyICsgJzwvZGl2PicpO1xcbiAgICAkKHVwbG9hZExhYmVsKS5hZGRDbGFzcyhzLnVwbG9hZEJ1dHRvbkNsYXNzKTsgLy8gd2FpdCBmb3JtIGFqYXggRm9ybSBwbHVnaW4gYW5kIGluaXRpYWxpemVcXG5cXG4gICAgKGZ1bmN0aW9uIGNoZWNrQWpheEZvcm1Mb2FkZWQoKSB7XFxuICAgICAgaWYgKCQuZm4uYWpheEZvcm0pIHtcXG4gICAgICAgIGlmIChzLmRyYWdEcm9wKSB7XFxuICAgICAgICAgIHZhciBkcmFnRHJvcCA9ICQoJzxkaXYgY2xhc3M9XFxcIicgKyBzLmRyYWdEcm9wQ29udGFpbmVyQ2xhc3MgKyAnXFxcIiBzdHlsZT1cXFwidmVydGljYWwtYWxpZ246dG9wO1xcXCI+PC9kaXY+Jykud2lkdGgocy5kcmFnZHJvcFdpZHRoKTtcXG4gICAgICAgICAgJChvYmopLmFwcGVuZChkcmFnRHJvcCk7XFxuICAgICAgICAgICQoZHJhZ0Ryb3ApLmFwcGVuZCh1cGxvYWRMYWJlbCk7XFxuICAgICAgICAgICQoZHJhZ0Ryb3ApLmFwcGVuZCgkKHMuZHJhZ0Ryb3BTdHIpKTtcXG4gICAgICAgICAgc2V0RHJhZ0Ryb3BIYW5kbGVycyhvYmosIHMsIGRyYWdEcm9wKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICQob2JqKS5hcHBlbmQodXBsb2FkTGFiZWwpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgJChvYmopLmFwcGVuZChvYmouZXJyb3JMb2cpO1xcbiAgICAgICAgaWYgKHMuc2hvd1F1ZXVlRGl2KSBvYmouY29udGFpbmVyID0gJChcXFwiI1xcXCIgKyBzLnNob3dRdWV1ZURpdik7ZWxzZSBvYmouY29udGFpbmVyID0gJChcXFwiPGRpdiBjbGFzcz0nYWpheC1maWxlLXVwbG9hZC1jb250YWluZXInPjwvZGl2PlxcXCIpLmluc2VydEFmdGVyKCQob2JqKSk7XFxuICAgICAgICBzLm9uTG9hZC5jYWxsKHRoaXMsIG9iaik7XFxuICAgICAgICBjcmVhdGVDdXN0b21JbnB1dEZpbGUob2JqLCBmb3JtR3JvdXAsIHMsIHVwbG9hZExhYmVsKTtcXG4gICAgICB9IGVsc2Ugd2luZG93LnNldFRpbWVvdXQoY2hlY2tBamF4Rm9ybUxvYWRlZCwgMTApO1xcbiAgICB9KSgpO1xcblxcbiAgICB0aGlzLnN0YXJ0VXBsb2FkID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICQoXFxcImZvcm1cXFwiKS5lYWNoKGZ1bmN0aW9uIChpLCBpdGVtcykge1xcbiAgICAgICAgaWYgKCQodGhpcykuaGFzQ2xhc3Mob2JqLmZvcm1Hcm91cCkpIHtcXG4gICAgICAgICAgbWFpblEucHVzaCgkKHRoaXMpKTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgICBpZiAobWFpblEubGVuZ3RoID49IDEpIHN1Ym1pdFBlbmRpbmdVcGxvYWRzKCk7XFxuICAgIH07XFxuXFxuICAgIHRoaXMuZ2V0RmlsZUNvdW50ID0gZnVuY3Rpb24gKCkge1xcbiAgICAgIHJldHVybiBvYmouc2VsZWN0ZWRGaWxlcztcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5zdG9wVXBsb2FkID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICQoXFxcIi5cXFwiICsgcy5hYm9ydEJ1dHRvbkNsYXNzKS5lYWNoKGZ1bmN0aW9uIChpLCBpdGVtcykge1xcbiAgICAgICAgaWYgKCQodGhpcykuaGFzQ2xhc3Mob2JqLmZvcm1Hcm91cCkpICQodGhpcykuY2xpY2soKTtcXG4gICAgICB9KTtcXG4gICAgICAkKFxcXCIuXFxcIiArIHMuY2FuY2VsQnV0dG9uQ2xhc3MpLmVhY2goZnVuY3Rpb24gKGksIGl0ZW1zKSB7XFxuICAgICAgICBpZiAoJCh0aGlzKS5oYXNDbGFzcyhvYmouZm9ybUdyb3VwKSkgJCh0aGlzKS5jbGljaygpO1xcbiAgICAgIH0pO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLmNhbmNlbEFsbCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAkKFxcXCIuXFxcIiArIHMuY2FuY2VsQnV0dG9uQ2xhc3MpLmVhY2goZnVuY3Rpb24gKGksIGl0ZW1zKSB7XFxuICAgICAgICBpZiAoJCh0aGlzKS5oYXNDbGFzcyhvYmouZm9ybUdyb3VwKSkgJCh0aGlzKS5jbGljaygpO1xcbiAgICAgIH0pO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLnVwZGF0ZSA9IGZ1bmN0aW9uIChzZXR0aW5ncykge1xcbiAgICAgIC8vdXBkYXRlIG5ldyBzZXR0aW5nc1xcbiAgICAgIHMgPSAkLmV4dGVuZChzLCBzZXR0aW5ncyk7IC8vV2UgbmVlZCB0byB1cGRhdGUgYWN0aW9uIGZvciBhbHJlYWR5IGNyZWF0ZWQgRm9ybS4gICAgICAgICAgICBcXG5cXG4gICAgICBpZiAoc2V0dGluZ3MuaGFzT3duUHJvcGVydHkoJ3VybCcpKSB7XFxuICAgICAgICAkKFxcXCJmb3JtXFxcIikuZWFjaChmdW5jdGlvbiAoaSwgaXRlbXMpIHtcXG4gICAgICAgICAgJCh0aGlzKS5hdHRyKCdhY3Rpb24nLCBzZXR0aW5nc1sndXJsJ10pO1xcbiAgICAgICAgfSk7XFxuICAgICAgfVxcbiAgICB9O1xcblxcbiAgICB0aGlzLmVucXVldWVGaWxlID0gZnVuY3Rpb24gKGZpbGUpIHtcXG4gICAgICBpZiAoIShmaWxlIGluc3RhbmNlb2YgRmlsZSkpIHJldHVybjtcXG4gICAgICB2YXIgZmlsZXMgPSBbZmlsZV07XFxuICAgICAgc2VyaWFsaXplQW5kVXBsb2FkRmlsZXMocywgb2JqLCBmaWxlcyk7XFxuICAgIH07XFxuXFxuICAgIHRoaXMucmVzZXQgPSBmdW5jdGlvbiAocmVtb3ZlU3RhdHVzQmFycykge1xcbiAgICAgIG9iai5maWxlQ291bnRlciA9IDE7XFxuICAgICAgb2JqLnNlbGVjdGVkRmlsZXMgPSAwO1xcbiAgICAgIG9iai5lcnJvckxvZy5odG1sKFxcXCJcXFwiKTsgLy9yZW1vdmUgYWxsIHRoZSBzdGF0dXMgYmFycy5cXG5cXG4gICAgICBpZiAocmVtb3ZlU3RhdHVzQmFycyAhPSBmYWxzZSkge1xcbiAgICAgICAgb2JqLmNvbnRhaW5lci5odG1sKFxcXCJcXFwiKTtcXG4gICAgICB9XFxuICAgIH07XFxuXFxuICAgIHRoaXMucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xcbiAgICAgIG9iai5jb250YWluZXIuaHRtbChcXFwiXFxcIik7XFxuICAgICAgJChvYmopLnJlbW92ZSgpO1xcbiAgICB9OyAvL1RoaXMgaXMgZm9yIHNob3dpbmcgT2xkIGZpbGVzIHRvIHVzZXIuXFxuXFxuXFxuICAgIHRoaXMuY3JlYXRlUHJvZ3Jlc3MgPSBmdW5jdGlvbiAoZmlsZW5hbWUsIGZpbGVwYXRoLCBmaWxlc2l6ZSkge1xcbiAgICAgIHZhciBwZCA9IG5ldyBjcmVhdGVQcm9ncmVzc0Rpdih0aGlzLCBzKTtcXG4gICAgICBwZC5wcm9ncmVzc0Rpdi5zaG93KCk7XFxuICAgICAgcGQucHJvZ3Jlc3NiYXIud2lkdGgoJzEwMCUnKTtcXG4gICAgICB2YXIgZmlsZU5hbWVTdHIgPSBcXFwiXFxcIjtcXG4gICAgICBpZiAocy5zaG93RmlsZUNvdW50ZXIpIGZpbGVOYW1lU3RyID0gb2JqLmZpbGVDb3VudGVyICsgcy5maWxlQ291bnRlclN0eWxlICsgZmlsZW5hbWU7ZWxzZSBmaWxlTmFtZVN0ciA9IGZpbGVuYW1lO1xcbiAgICAgIGlmIChzLnNob3dGaWxlU2l6ZSkgZmlsZU5hbWVTdHIgKz0gXFxcIiAoXFxcIiArIGdldFNpemVTdHIoZmlsZXNpemUpICsgXFxcIilcXFwiO1xcbiAgICAgIHBkLmZpbGVuYW1lLmh0bWwoZmlsZU5hbWVTdHIpO1xcbiAgICAgIG9iai5maWxlQ291bnRlcisrO1xcbiAgICAgIG9iai5zZWxlY3RlZEZpbGVzKys7XFxuXFxuICAgICAgaWYgKHMuc2hvd1ByZXZpZXcpIHtcXG4gICAgICAgIHBkLnByZXZpZXcuYXR0cignc3JjJywgZmlsZXBhdGgpO1xcbiAgICAgICAgcGQucHJldmlldy5zaG93KCk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChzLnNob3dEb3dubG9hZCkge1xcbiAgICAgICAgcGQuZG93bmxvYWQuc2hvdygpO1xcbiAgICAgICAgcGQuZG93bmxvYWQuY2xpY2soZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBpZiAocy5kb3dubG9hZENhbGxiYWNrKSBzLmRvd25sb2FkQ2FsbGJhY2suY2FsbChvYmosIFtmaWxlbmFtZV0sIHBkKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAocy5zaG93RGVsZXRlKSB7XFxuICAgICAgICBwZC5kZWwuc2hvdygpO1xcbiAgICAgICAgcGQuZGVsLmNsaWNrKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgcGQuc3RhdHVzYmFyLmhpZGUoKS5yZW1vdmUoKTtcXG4gICAgICAgICAgdmFyIGFyciA9IFtmaWxlbmFtZV07XFxuICAgICAgICAgIGlmIChzLmRlbGV0ZUNhbGxiYWNrKSBzLmRlbGV0ZUNhbGxiYWNrLmNhbGwodGhpcywgYXJyLCBwZCk7XFxuICAgICAgICAgIG9iai5zZWxlY3RlZEZpbGVzIC09IDE7XFxuICAgICAgICAgIHVwZGF0ZUZpbGVDb3VudGVyKHMsIG9iaik7XFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHBkO1xcbiAgICB9O1xcblxcbiAgICB0aGlzLmdldFJlc3BvbnNlcyA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICByZXR1cm4gdGhpcy5yZXNwb25zZXM7XFxuICAgIH07XFxuXFxuICAgIHZhciBtYWluUSA9IFtdO1xcbiAgICB2YXIgcHJvZ3Jlc3NRID0gW107XFxuICAgIHZhciBydW5uaW5nID0gZmFsc2U7XFxuXFxuICAgIGZ1bmN0aW9uIHN1Ym1pdFBlbmRpbmdVcGxvYWRzKCkge1xcbiAgICAgIGlmIChydW5uaW5nKSByZXR1cm47XFxuICAgICAgcnVubmluZyA9IHRydWU7XFxuXFxuICAgICAgKGZ1bmN0aW9uIGNoZWNrUGVuZGluZ0Zvcm1zKCkge1xcbiAgICAgICAgLy9pZiBub3Qgc2VxdWVudGlhbCB1cGxvYWQgYWxsIGZpbGVzXFxuICAgICAgICBpZiAoIXMuc2VxdWVudGlhbCkgcy5zZXF1ZW50aWFsQ291bnQgPSA5OTk5OTtcXG5cXG4gICAgICAgIGlmIChtYWluUS5sZW5ndGggPT0gMCAmJiBwcm9ncmVzc1EubGVuZ3RoID09IDApIHtcXG4gICAgICAgICAgaWYgKHMuYWZ0ZXJVcGxvYWRBbGwpIHMuYWZ0ZXJVcGxvYWRBbGwob2JqKTtcXG4gICAgICAgICAgcnVubmluZyA9IGZhbHNlO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgaWYgKHByb2dyZXNzUS5sZW5ndGggPCBzLnNlcXVlbnRpYWxDb3VudCkge1xcbiAgICAgICAgICAgIHZhciBmcm0gPSBtYWluUS5zaGlmdCgpO1xcblxcbiAgICAgICAgICAgIGlmIChmcm0gIT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgICAgICBwcm9ncmVzc1EucHVzaChmcm0pOyAvL1JlbW92ZSB0aGUgY2xhc3MgZ3JvdXAuXFxuXFxuICAgICAgICAgICAgICBmcm0ucmVtb3ZlQ2xhc3Mob2JqLmZvcm1Hcm91cCk7XFxuICAgICAgICAgICAgICBmcm0uc3VibWl0KCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGNoZWNrUGVuZGluZ0Zvcm1zLCAxMDApO1xcbiAgICAgICAgfVxcbiAgICAgIH0pKCk7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gc2V0RHJhZ0Ryb3BIYW5kbGVycyhvYmosIHMsIGRkT2JqKSB7XFxuICAgICAgZGRPYmoub24oJ2RyYWdlbnRlcicsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgJCh0aGlzKS5hZGRDbGFzcyhzLmRyYWdEcm9wSG92ZXJDbGFzcyk7XFxuICAgICAgfSk7XFxuICAgICAgZGRPYmoub24oJ2RyYWdvdmVyJywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XFxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICB2YXIgdGhhdCA9ICQodGhpcyk7XFxuXFxuICAgICAgICBpZiAodGhhdC5oYXNDbGFzcyhzLmRyYWdEcm9wQ29udGFpbmVyQ2xhc3MpICYmICF0aGF0Lmhhc0NsYXNzKHMuZHJhZ0Ryb3BIb3ZlckNsYXNzKSkge1xcbiAgICAgICAgICB0aGF0LmFkZENsYXNzKHMuZHJhZ0Ryb3BIb3ZlckNsYXNzKTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgICBkZE9iai5vbignZHJvcCcsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICAkKHRoaXMpLnJlbW92ZUNsYXNzKHMuZHJhZ0Ryb3BIb3ZlckNsYXNzKTtcXG4gICAgICAgIG9iai5lcnJvckxvZy5odG1sKFxcXCJcXFwiKTtcXG4gICAgICAgIHZhciBmaWxlcyA9IGUub3JpZ2luYWxFdmVudC5kYXRhVHJhbnNmZXIuZmlsZXM7XFxuXFxuICAgICAgICBpZiAoIXMubXVsdGlwbGUgJiYgZmlsZXMubGVuZ3RoID4gMSkge1xcbiAgICAgICAgICBpZiAocy5zaG93RXJyb3IpICQoXFxcIjxkaXYgY2xhc3M9J1xcXCIgKyBzLmVycm9yQ2xhc3MgKyBcXFwiJz5cXFwiICsgcy5tdWx0aURyYWdFcnJvclN0ciArIFxcXCI8L2Rpdj5cXFwiKS5hcHBlbmRUbyhvYmouZXJyb3JMb2cpO1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAocy5vblNlbGVjdChmaWxlcykgPT0gZmFsc2UpIHJldHVybjtcXG4gICAgICAgIHNlcmlhbGl6ZUFuZFVwbG9hZEZpbGVzKHMsIG9iaiwgZmlsZXMpO1xcbiAgICAgIH0pO1xcbiAgICAgIGRkT2JqLm9uKCdkcmFnbGVhdmUnLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgJCh0aGlzKS5yZW1vdmVDbGFzcyhzLmRyYWdEcm9wSG92ZXJDbGFzcyk7XFxuICAgICAgfSk7XFxuICAgICAgJChkb2N1bWVudCkub24oJ2RyYWdlbnRlcicsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgIH0pO1xcbiAgICAgICQoZG9jdW1lbnQpLm9uKCdkcmFnb3ZlcicsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgdmFyIHRoYXQgPSAkKHRoaXMpO1xcblxcbiAgICAgICAgaWYgKCF0aGF0Lmhhc0NsYXNzKHMuZHJhZ0Ryb3BDb250YWluZXJDbGFzcykpIHtcXG4gICAgICAgICAgdGhhdC5yZW1vdmVDbGFzcyhzLmRyYWdEcm9wSG92ZXJDbGFzcyk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgICAgJChkb2N1bWVudCkub24oJ2Ryb3AnLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgICQodGhpcykucmVtb3ZlQ2xhc3Mocy5kcmFnRHJvcEhvdmVyQ2xhc3MpO1xcbiAgICAgIH0pO1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIGdldFNpemVTdHIoc2l6ZSkge1xcbiAgICAgIHZhciBzaXplU3RyID0gXFxcIlxcXCI7XFxuICAgICAgdmFyIHNpemVLQiA9IHNpemUgLyAxMDI0O1xcblxcbiAgICAgIGlmIChwYXJzZUludChzaXplS0IpID4gMTAyNCkge1xcbiAgICAgICAgdmFyIHNpemVNQiA9IHNpemVLQiAvIDEwMjQ7XFxuICAgICAgICBzaXplU3RyID0gc2l6ZU1CLnRvRml4ZWQoMikgKyBcXFwiIE1CXFxcIjtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgc2l6ZVN0ciA9IHNpemVLQi50b0ZpeGVkKDIpICsgXFxcIiBLQlxcXCI7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBzaXplU3RyO1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIHNlcmlhbGl6ZURhdGEoZXh0cmFEYXRhKSB7XFxuICAgICAgdmFyIHNlcmlhbGl6ZWQgPSBbXTtcXG5cXG4gICAgICBpZiAoalF1ZXJ5LnR5cGUoZXh0cmFEYXRhKSA9PSBcXFwic3RyaW5nXFxcIikge1xcbiAgICAgICAgc2VyaWFsaXplZCA9IGV4dHJhRGF0YS5zcGxpdCgnJicpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBzZXJpYWxpemVkID0gJC5wYXJhbShleHRyYURhdGEpLnNwbGl0KCcmJyk7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBsZW4gPSBzZXJpYWxpemVkLmxlbmd0aDtcXG4gICAgICB2YXIgcmVzdWx0ID0gW107XFxuICAgICAgdmFyIGksIHBhcnQ7XFxuXFxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XFxuICAgICAgICBzZXJpYWxpemVkW2ldID0gc2VyaWFsaXplZFtpXS5yZXBsYWNlKC9cXFxcKy9nLCAnICcpO1xcbiAgICAgICAgcGFydCA9IHNlcmlhbGl6ZWRbaV0uc3BsaXQoJz0nKTtcXG4gICAgICAgIHJlc3VsdC5wdXNoKFtkZWNvZGVVUklDb21wb25lbnQocGFydFswXSksIGRlY29kZVVSSUNvbXBvbmVudChwYXJ0WzFdKV0pO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIG5vc2VyaWFsaXplQW5kVXBsb2FkRmlsZXMocywgb2JqLCBmaWxlcykge1xcbiAgICAgIHZhciB0cyA9ICQuZXh0ZW5kKHt9LCBzKTtcXG4gICAgICB2YXIgZmQgPSBuZXcgRm9ybURhdGEoKTtcXG4gICAgICB2YXIgZmlsZUFycmF5ID0gW107XFxuICAgICAgdmFyIGZpbGVOYW1lID0gcy5maWxlTmFtZS5yZXBsYWNlKFxcXCJbXVxcXCIsIFxcXCJcXFwiKTtcXG4gICAgICB2YXIgZmlsZUxpc3RTdHIgPSBcXFwiXFxcIjtcXG5cXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICBpZiAoIWlzRmlsZVR5cGVBbGxvd2VkKG9iaiwgcywgZmlsZXNbaV0ubmFtZSkpIHtcXG4gICAgICAgICAgaWYgKHMuc2hvd0Vycm9yKSAkKFxcXCI8ZGl2Pjxmb250IGNvbG9yPSdyZWQnPjxiPlxcXCIgKyBmaWxlc1tpXS5uYW1lICsgXFxcIjwvYj4gXFxcIiArIHMuZXh0RXJyb3JTdHIgKyBzLmFsbG93ZWRUeXBlcyArIFxcXCI8L2ZvbnQ+PC9kaXY+XFxcIikuYXBwZW5kVG8ob2JqLmVycm9yTG9nKTtcXG4gICAgICAgICAgY29udGludWU7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAocy5tYXhGaWxlU2l6ZSAhPSAtMSAmJiBmaWxlc1tpXS5zaXplID4gcy5tYXhGaWxlU2l6ZSkge1xcbiAgICAgICAgICBpZiAocy5zaG93RXJyb3IpICQoXFxcIjxkaXY+PGZvbnQgY29sb3I9J3JlZCc+PGI+XFxcIiArIGZpbGVzW2ldLm5hbWUgKyBcXFwiPC9iPiBcXFwiICsgcy5zaXplRXJyb3JTdHIgKyBnZXRTaXplU3RyKHMubWF4RmlsZVNpemUpICsgXFxcIjwvZm9udD48L2Rpdj5cXFwiKS5hcHBlbmRUbyhvYmouZXJyb3JMb2cpO1xcbiAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGZkLmFwcGVuZChmaWxlTmFtZSArIFxcXCJbXVxcXCIsIGZpbGVzW2ldKTtcXG4gICAgICAgIGZpbGVBcnJheS5wdXNoKGZpbGVzW2ldLm5hbWUpO1xcbiAgICAgICAgZmlsZUxpc3RTdHIgKz0gb2JqLmZpbGVDb3VudGVyICsgXFxcIikuIFxcXCIgKyBmaWxlc1tpXS5uYW1lICsgXFxcIjxicj5cXFwiO1xcbiAgICAgICAgb2JqLmZpbGVDb3VudGVyKys7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChmaWxlQXJyYXkubGVuZ3RoID09IDApIHJldHVybjtcXG4gICAgICB2YXIgZXh0cmFEYXRhID0gcy5mb3JtRGF0YTtcXG5cXG4gICAgICBpZiAoZXh0cmFEYXRhKSB7XFxuICAgICAgICB2YXIgc0RhdGEgPSBzZXJpYWxpemVEYXRhKGV4dHJhRGF0YSk7XFxuXFxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNEYXRhLmxlbmd0aDsgaisrKSB7XFxuICAgICAgICAgIGlmIChzRGF0YVtqXSkge1xcbiAgICAgICAgICAgIGZkLmFwcGVuZChzRGF0YVtqXVswXSwgc0RhdGFbal1bMV0pO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHRzLmZpbGVEYXRhID0gZmQ7XFxuICAgICAgdmFyIHBkID0gbmV3IGNyZWF0ZVByb2dyZXNzRGl2KG9iaiwgcyk7XFxuICAgICAgcGQuZmlsZW5hbWUuaHRtbChmaWxlTGlzdFN0cik7XFxuICAgICAgdmFyIGZvcm0gPSAkKFxcXCI8Zm9ybSBzdHlsZT0nZGlzcGxheTpibG9jazsgcG9zaXRpb246YWJzb2x1dGU7bGVmdDogMTUwcHg7JyBjbGFzcz0nXFxcIiArIG9iai5mb3JtR3JvdXAgKyBcXFwiJyBtZXRob2Q9J1xcXCIgKyBzLm1ldGhvZCArIFxcXCInIGFjdGlvbj0nXFxcIiArIHMudXJsICsgXFxcIicgZW5jdHlwZT0nXFxcIiArIHMuZW5jdHlwZSArIFxcXCInPjwvZm9ybT5cXFwiKTtcXG4gICAgICBmb3JtLmFwcGVuZFRvKCdib2R5Jyk7XFxuICAgICAgYWpheEZvcm1TdWJtaXQoZm9ybSwgdHMsIHBkLCBmaWxlQXJyYXksIG9iaik7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gc2VyaWFsaXplQW5kVXBsb2FkRmlsZXMocywgb2JqLCBmaWxlcykge1xcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgIGlmICghaXNGaWxlVHlwZUFsbG93ZWQob2JqLCBzLCBmaWxlc1tpXS5uYW1lKSkge1xcbiAgICAgICAgICBpZiAocy5zaG93RXJyb3IpICQoXFxcIjxkaXYgY2xhc3M9J1xcXCIgKyBzLmVycm9yQ2xhc3MgKyBcXFwiJz48Yj5cXFwiICsgZmlsZXNbaV0ubmFtZSArIFxcXCI8L2I+IFxcXCIgKyBzLmV4dEVycm9yU3RyICsgcy5hbGxvd2VkVHlwZXMgKyBcXFwiPC9kaXY+XFxcIikuYXBwZW5kVG8ob2JqLmVycm9yTG9nKTtcXG4gICAgICAgICAgY29udGludWU7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoIXMuYWxsb3dEdXBsaWNhdGVzICYmIGlzRmlsZUR1cGxpY2F0ZShvYmosIGZpbGVzW2ldLm5hbWUpKSB7XFxuICAgICAgICAgIGlmIChzLnNob3dFcnJvcikgJChcXFwiPGRpdiBjbGFzcz0nXFxcIiArIHMuZXJyb3JDbGFzcyArIFxcXCInPjxiPlxcXCIgKyBmaWxlc1tpXS5uYW1lICsgXFxcIjwvYj4gXFxcIiArIHMuZHVwbGljYXRlRXJyb3JTdHIgKyBcXFwiPC9kaXY+XFxcIikuYXBwZW5kVG8ob2JqLmVycm9yTG9nKTtcXG4gICAgICAgICAgY29udGludWU7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAocy5tYXhGaWxlU2l6ZSAhPSAtMSAmJiBmaWxlc1tpXS5zaXplID4gcy5tYXhGaWxlU2l6ZSkge1xcbiAgICAgICAgICBpZiAocy5zaG93RXJyb3IpICQoXFxcIjxkaXYgY2xhc3M9J1xcXCIgKyBzLmVycm9yQ2xhc3MgKyBcXFwiJz48Yj5cXFwiICsgZmlsZXNbaV0ubmFtZSArIFxcXCI8L2I+IFxcXCIgKyBzLnNpemVFcnJvclN0ciArIGdldFNpemVTdHIocy5tYXhGaWxlU2l6ZSkgKyBcXFwiPC9kaXY+XFxcIikuYXBwZW5kVG8ob2JqLmVycm9yTG9nKTtcXG4gICAgICAgICAgY29udGludWU7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAocy5tYXhGaWxlQ291bnQgIT0gLTEgJiYgb2JqLnNlbGVjdGVkRmlsZXMgPj0gcy5tYXhGaWxlQ291bnQpIHtcXG4gICAgICAgICAgaWYgKHMuc2hvd0Vycm9yKSAkKFxcXCI8ZGl2IGNsYXNzPSdcXFwiICsgcy5lcnJvckNsYXNzICsgXFxcIic+PGI+XFxcIiArIGZpbGVzW2ldLm5hbWUgKyBcXFwiPC9iPiBcXFwiICsgcy5tYXhGaWxlQ291bnRFcnJvclN0ciArIHMubWF4RmlsZUNvdW50ICsgXFxcIjwvZGl2PlxcXCIpLmFwcGVuZFRvKG9iai5lcnJvckxvZyk7XFxuICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgb2JqLnNlbGVjdGVkRmlsZXMrKztcXG4gICAgICAgIG9iai5leGlzdGluZ0ZpbGVOYW1lcy5wdXNoKGZpbGVzW2ldLm5hbWUpOyAvLyBNYWtlIG9iamVjdCBpbW11dGFibGVcXG5cXG4gICAgICAgIHZhciB0cyA9ICQuZXh0ZW5kKHt9LCBzKTtcXG4gICAgICAgIHZhciBmZCA9IG5ldyBGb3JtRGF0YSgpO1xcbiAgICAgICAgdmFyIGZpbGVOYW1lID0gcy5maWxlTmFtZS5yZXBsYWNlKFxcXCJbXVxcXCIsIFxcXCJcXFwiKTtcXG4gICAgICAgIGZkLmFwcGVuZChmaWxlTmFtZSwgZmlsZXNbaV0pO1xcbiAgICAgICAgdmFyIGV4dHJhRGF0YSA9IHMuZm9ybURhdGE7XFxuXFxuICAgICAgICBpZiAoZXh0cmFEYXRhKSB7XFxuICAgICAgICAgIHZhciBzRGF0YSA9IHNlcmlhbGl6ZURhdGEoZXh0cmFEYXRhKTtcXG5cXG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzRGF0YS5sZW5ndGg7IGorKykge1xcbiAgICAgICAgICAgIGlmIChzRGF0YVtqXSkge1xcbiAgICAgICAgICAgICAgZmQuYXBwZW5kKHNEYXRhW2pdWzBdLCBzRGF0YVtqXVsxXSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0cy5maWxlRGF0YSA9IGZkO1xcbiAgICAgICAgdmFyIHBkID0gbmV3IGNyZWF0ZVByb2dyZXNzRGl2KG9iaiwgcyk7XFxuICAgICAgICB2YXIgZmlsZU5hbWVTdHIgPSBcXFwiXFxcIjtcXG4gICAgICAgIGlmIChzLnNob3dGaWxlQ291bnRlcikgZmlsZU5hbWVTdHIgPSBvYmouZmlsZUNvdW50ZXIgKyBzLmZpbGVDb3VudGVyU3R5bGUgKyBmaWxlc1tpXS5uYW1lO2Vsc2UgZmlsZU5hbWVTdHIgPSBmaWxlc1tpXS5uYW1lO1xcbiAgICAgICAgaWYgKHMuc2hvd0ZpbGVTaXplKSBmaWxlTmFtZVN0ciArPSBcXFwiIChcXFwiICsgZ2V0U2l6ZVN0cihmaWxlc1tpXS5zaXplKSArIFxcXCIpXFxcIjtcXG4gICAgICAgIHBkLmZpbGVuYW1lLmh0bWwoZmlsZU5hbWVTdHIpO1xcbiAgICAgICAgdmFyIGZvcm0gPSAkKFxcXCI8Zm9ybSBzdHlsZT0nZGlzcGxheTpibG9jazsgcG9zaXRpb246YWJzb2x1dGU7bGVmdDogMTUwcHg7JyBjbGFzcz0nXFxcIiArIG9iai5mb3JtR3JvdXAgKyBcXFwiJyBtZXRob2Q9J1xcXCIgKyBzLm1ldGhvZCArIFxcXCInIGFjdGlvbj0nXFxcIiArIHMudXJsICsgXFxcIicgZW5jdHlwZT0nXFxcIiArIHMuZW5jdHlwZSArIFxcXCInPjwvZm9ybT5cXFwiKTtcXG4gICAgICAgIGZvcm0uYXBwZW5kVG8oJ2JvZHknKTtcXG4gICAgICAgIHZhciBmaWxlQXJyYXkgPSBbXTtcXG4gICAgICAgIGZpbGVBcnJheS5wdXNoKGZpbGVzW2ldLm5hbWUpO1xcbiAgICAgICAgYWpheEZvcm1TdWJtaXQoZm9ybSwgdHMsIHBkLCBmaWxlQXJyYXksIG9iaiwgZmlsZXNbaV0pO1xcbiAgICAgICAgb2JqLmZpbGVDb3VudGVyKys7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIGlzRmlsZVR5cGVBbGxvd2VkKG9iaiwgcywgZmlsZU5hbWUpIHtcXG4gICAgICB2YXIgZmlsZUV4dGVuc2lvbnMgPSBzLmFsbG93ZWRUeXBlcy50b0xvd2VyQ2FzZSgpLnNwbGl0KC9bXFxcXHMsXSsvZyk7XFxuICAgICAgdmFyIGV4dCA9IGZpbGVOYW1lLnNwbGl0KCcuJykucG9wKCkudG9Mb3dlckNhc2UoKTtcXG5cXG4gICAgICBpZiAocy5hbGxvd2VkVHlwZXMgIT0gXFxcIipcXFwiICYmIGpRdWVyeS5pbkFycmF5KGV4dCwgZmlsZUV4dGVuc2lvbnMpIDwgMCkge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBpc0ZpbGVEdXBsaWNhdGUob2JqLCBmaWxlbmFtZSkge1xcbiAgICAgIHZhciBkdXBsaWNhdGUgPSBmYWxzZTtcXG5cXG4gICAgICBpZiAob2JqLmV4aXN0aW5nRmlsZU5hbWVzLmxlbmd0aCkge1xcbiAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBvYmouZXhpc3RpbmdGaWxlTmFtZXMubGVuZ3RoOyB4KyspIHtcXG4gICAgICAgICAgaWYgKG9iai5leGlzdGluZ0ZpbGVOYW1lc1t4XSA9PSBmaWxlbmFtZSB8fCBzLmR1cGxpY2F0ZVN0cmljdCAmJiBvYmouZXhpc3RpbmdGaWxlTmFtZXNbeF0udG9Mb3dlckNhc2UoKSA9PSBmaWxlbmFtZS50b0xvd2VyQ2FzZSgpKSB7XFxuICAgICAgICAgICAgZHVwbGljYXRlID0gdHJ1ZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gZHVwbGljYXRlO1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIHJlbW92ZUV4aXN0aW5nRmlsZU5hbWUob2JqLCBmaWxlQXJyKSB7XFxuICAgICAgaWYgKG9iai5leGlzdGluZ0ZpbGVOYW1lcy5sZW5ndGgpIHtcXG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgZmlsZUFyci5sZW5ndGg7IHgrKykge1xcbiAgICAgICAgICB2YXIgcG9zID0gb2JqLmV4aXN0aW5nRmlsZU5hbWVzLmluZGV4T2YoZmlsZUFyclt4XSk7XFxuXFxuICAgICAgICAgIGlmIChwb3MgIT0gLTEpIHtcXG4gICAgICAgICAgICBvYmouZXhpc3RpbmdGaWxlTmFtZXMuc3BsaWNlKHBvcywgMSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gZ2V0U3JjVG9QcmV2aWV3KGZpbGUsIG9iaikge1xcbiAgICAgIGlmIChmaWxlKSB7XFxuICAgICAgICBvYmouc2hvdygpO1xcbiAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XFxuXFxuICAgICAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgb2JqLmF0dHIoJ3NyYycsIGUudGFyZ2V0LnJlc3VsdCk7XFxuICAgICAgICB9O1xcblxcbiAgICAgICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoZmlsZSk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIHVwZGF0ZUZpbGVDb3VudGVyKHMsIG9iaikge1xcbiAgICAgIGlmIChzLnNob3dGaWxlQ291bnRlcikge1xcbiAgICAgICAgdmFyIGNvdW50ID0gJChvYmouY29udGFpbmVyKS5maW5kKFxcXCIuYWpheC1maWxlLXVwbG9hZC1maWxlbmFtZVxcXCIpLmxlbmd0aDtcXG4gICAgICAgIG9iai5maWxlQ291bnRlciA9IGNvdW50ICsgMTtcXG4gICAgICAgICQob2JqLmNvbnRhaW5lcikuZmluZChcXFwiLmFqYXgtZmlsZS11cGxvYWQtZmlsZW5hbWVcXFwiKS5lYWNoKGZ1bmN0aW9uIChpLCBpdGVtcykge1xcbiAgICAgICAgICB2YXIgYXJyID0gJCh0aGlzKS5odG1sKCkuc3BsaXQocy5maWxlQ291bnRlclN0eWxlKTtcXG4gICAgICAgICAgdmFyIGZpbGVOdW0gPSBwYXJzZUludChhcnJbMF0pIC0gMTsgLy9kZWNyZW1lbnQ7XFxuXFxuICAgICAgICAgIHZhciBuYW1lID0gY291bnQgKyBzLmZpbGVDb3VudGVyU3R5bGUgKyBhcnJbMV07XFxuICAgICAgICAgICQodGhpcykuaHRtbChuYW1lKTtcXG4gICAgICAgICAgY291bnQtLTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBjcmVhdGVDdXN0b21JbnB1dEZpbGUob2JqLCBncm91cCwgcywgdXBsb2FkTGFiZWwpIHtcXG4gICAgICB2YXIgZmlsZVVwbG9hZElkID0gXFxcImFqYXgtdXBsb2FkLWlkLVxcXCIgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcXG4gICAgICB2YXIgZm9ybSA9ICQoXFxcIjxmb3JtIG1ldGhvZD0nXFxcIiArIHMubWV0aG9kICsgXFxcIicgYWN0aW9uPSdcXFwiICsgcy51cmwgKyBcXFwiJyBlbmN0eXBlPSdcXFwiICsgcy5lbmN0eXBlICsgXFxcIic+PC9mb3JtPlxcXCIpO1xcbiAgICAgIHZhciBmaWxlSW5wdXRTdHIgPSBcXFwiPGlucHV0IHR5cGU9J2ZpbGUnIGlkPSdcXFwiICsgZmlsZVVwbG9hZElkICsgXFxcIicgbmFtZT0nXFxcIiArIHMuZmlsZU5hbWUgKyBcXFwiJyBhY2NlcHQ9J1xcXCIgKyBzLmFjY2VwdEZpbGVzICsgXFxcIicvPlxcXCI7XFxuXFxuICAgICAgaWYgKHMubXVsdGlwbGUpIHtcXG4gICAgICAgIGlmIChzLmZpbGVOYW1lLmluZGV4T2YoXFxcIltdXFxcIikgIT0gcy5maWxlTmFtZS5sZW5ndGggLSAyKSAvLyBpZiBpdCBkb2VzIG5vdCBlbmR3aXRoXFxuICAgICAgICAgIHtcXG4gICAgICAgICAgICBzLmZpbGVOYW1lICs9IFxcXCJbXVxcXCI7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgIGZpbGVJbnB1dFN0ciA9IFxcXCI8aW5wdXQgdHlwZT0nZmlsZScgaWQ9J1xcXCIgKyBmaWxlVXBsb2FkSWQgKyBcXFwiJyBuYW1lPSdcXFwiICsgcy5maWxlTmFtZSArIFxcXCInIGFjY2VwdD0nXFxcIiArIHMuYWNjZXB0RmlsZXMgKyBcXFwiJyBtdWx0aXBsZS8+XFxcIjtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIGZpbGVJbnB1dCA9ICQoZmlsZUlucHV0U3RyKS5hcHBlbmRUbyhmb3JtKTtcXG4gICAgICBmaWxlSW5wdXQuY2hhbmdlKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIG9iai5lcnJvckxvZy5odG1sKFxcXCJcXFwiKTtcXG4gICAgICAgIHZhciBmaWxlRXh0ZW5zaW9ucyA9IHMuYWxsb3dlZFR5cGVzLnRvTG93ZXJDYXNlKCkuc3BsaXQoXFxcIixcXFwiKTtcXG4gICAgICAgIHZhciBmaWxlQXJyYXkgPSBbXTtcXG5cXG4gICAgICAgIGlmICh0aGlzLmZpbGVzKSAvL3N1cHBvcnQgcmVhZGluZyBmaWxlc1xcbiAgICAgICAgICB7XFxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuZmlsZXMubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgICAgIGZpbGVBcnJheS5wdXNoKHRoaXMuZmlsZXNbaV0ubmFtZSk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmIChzLm9uU2VsZWN0KHRoaXMuZmlsZXMpID09IGZhbHNlKSByZXR1cm47XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHZhciBmaWxlbmFtZVN0ciA9ICQodGhpcykudmFsKCk7XFxuICAgICAgICAgIHZhciBmbGlzdCA9IFtdO1xcbiAgICAgICAgICBmaWxlQXJyYXkucHVzaChmaWxlbmFtZVN0cik7XFxuXFxuICAgICAgICAgIGlmICghaXNGaWxlVHlwZUFsbG93ZWQob2JqLCBzLCBmaWxlbmFtZVN0cikpIHtcXG4gICAgICAgICAgICBpZiAocy5zaG93RXJyb3IpICQoXFxcIjxkaXYgY2xhc3M9J1xcXCIgKyBzLmVycm9yQ2xhc3MgKyBcXFwiJz48Yj5cXFwiICsgZmlsZW5hbWVTdHIgKyBcXFwiPC9iPiBcXFwiICsgcy5leHRFcnJvclN0ciArIHMuYWxsb3dlZFR5cGVzICsgXFxcIjwvZGl2PlxcXCIpLmFwcGVuZFRvKG9iai5lcnJvckxvZyk7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICB9IC8vZmFsbGJhY2sgZm9yIGJyb3dzZXIgd2l0aG91dCBGaWxlQVBJXFxuXFxuXFxuICAgICAgICAgIGZsaXN0LnB1c2goe1xcbiAgICAgICAgICAgIG5hbWU6IGZpbGVuYW1lU3RyLFxcbiAgICAgICAgICAgIHNpemU6ICdOQSdcXG4gICAgICAgICAgfSk7XFxuICAgICAgICAgIGlmIChzLm9uU2VsZWN0KGZsaXN0KSA9PSBmYWxzZSkgcmV0dXJuO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdXBkYXRlRmlsZUNvdW50ZXIocywgb2JqKTtcXG4gICAgICAgIHVwbG9hZExhYmVsLnVuYmluZChcXFwiY2xpY2tcXFwiKTtcXG4gICAgICAgIGZvcm0uaGlkZSgpO1xcbiAgICAgICAgY3JlYXRlQ3VzdG9tSW5wdXRGaWxlKG9iaiwgZ3JvdXAsIHMsIHVwbG9hZExhYmVsKTtcXG4gICAgICAgIGZvcm0uYWRkQ2xhc3MoZ3JvdXApO1xcblxcbiAgICAgICAgaWYgKHMuc2VyaWFsaXplICYmIGZlYXR1cmUuZmlsZWFwaSAmJiBmZWF0dXJlLmZvcm1kYXRhKSAvL3VzZSBIVE1MNSBzdXBwb3J0IGFuZCBzcGxpdCBmaWxlIHN1Ym1pc3Npb25cXG4gICAgICAgICAge1xcbiAgICAgICAgICAgIGZvcm0ucmVtb3ZlQ2xhc3MoZ3JvdXApOyAvL1N0b3AgU3VibWl0dGluZyB3aGVuLlxcblxcbiAgICAgICAgICAgIHZhciBmaWxlcyA9IHRoaXMuZmlsZXM7XFxuICAgICAgICAgICAgZm9ybS5yZW1vdmUoKTtcXG4gICAgICAgICAgICBzZXJpYWxpemVBbmRVcGxvYWRGaWxlcyhzLCBvYmosIGZpbGVzKTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgdmFyIGZpbGVMaXN0ID0gXFxcIlxcXCI7XFxuXFxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlsZUFycmF5Lmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgICAgaWYgKHMuc2hvd0ZpbGVDb3VudGVyKSBmaWxlTGlzdCArPSBvYmouZmlsZUNvdW50ZXIgKyBzLmZpbGVDb3VudGVyU3R5bGUgKyBmaWxlQXJyYXlbaV0gKyBcXFwiPGJyPlxcXCI7ZWxzZSBmaWxlTGlzdCArPSBmaWxlQXJyYXlbaV0gKyBcXFwiPGJyPlxcXCI7XFxuICAgICAgICAgICAgO1xcbiAgICAgICAgICAgIG9iai5maWxlQ291bnRlcisrO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmIChzLm1heEZpbGVDb3VudCAhPSAtMSAmJiBvYmouc2VsZWN0ZWRGaWxlcyArIGZpbGVBcnJheS5sZW5ndGggPiBzLm1heEZpbGVDb3VudCkge1xcbiAgICAgICAgICAgIGlmIChzLnNob3dFcnJvcikgJChcXFwiPGRpdiBjbGFzcz0nXFxcIiArIHMuZXJyb3JDbGFzcyArIFxcXCInPjxiPlxcXCIgKyBmaWxlTGlzdCArIFxcXCI8L2I+IFxcXCIgKyBzLm1heEZpbGVDb3VudEVycm9yU3RyICsgcy5tYXhGaWxlQ291bnQgKyBcXFwiPC9kaXY+XFxcIikuYXBwZW5kVG8ob2JqLmVycm9yTG9nKTtcXG4gICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgb2JqLnNlbGVjdGVkRmlsZXMgKz0gZmlsZUFycmF5Lmxlbmd0aDtcXG4gICAgICAgICAgdmFyIHBkID0gbmV3IGNyZWF0ZVByb2dyZXNzRGl2KG9iaiwgcyk7XFxuICAgICAgICAgIHBkLmZpbGVuYW1lLmh0bWwoZmlsZUxpc3QpO1xcbiAgICAgICAgICBhamF4Rm9ybVN1Ym1pdChmb3JtLCBzLCBwZCwgZmlsZUFycmF5LCBvYmosIG51bGwpO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcblxcbiAgICAgIGlmIChzLm5lc3RlZEZvcm1zKSB7XFxuICAgICAgICBmb3JtLmNzcyh7XFxuICAgICAgICAgICdtYXJnaW4nOiAwLFxcbiAgICAgICAgICAncGFkZGluZyc6IDBcXG4gICAgICAgIH0pO1xcbiAgICAgICAgdXBsb2FkTGFiZWwuY3NzKHtcXG4gICAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXFxuICAgICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcXG4gICAgICAgICAgY3Vyc29yOiAnZGVmYXVsdCdcXG4gICAgICAgIH0pO1xcbiAgICAgICAgZmlsZUlucHV0LmNzcyh7XFxuICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxcbiAgICAgICAgICAnY3Vyc29yJzogJ3BvaW50ZXInLFxcbiAgICAgICAgICAndG9wJzogJzBweCcsXFxuICAgICAgICAgICd3aWR0aCc6ICcxMDAlJyxcXG4gICAgICAgICAgJ2hlaWdodCc6ICcxMDAlJyxcXG4gICAgICAgICAgJ2xlZnQnOiAnMHB4JyxcXG4gICAgICAgICAgJ3otaW5kZXgnOiAnMTAwJyxcXG4gICAgICAgICAgJ29wYWNpdHknOiAnMC4wJyxcXG4gICAgICAgICAgJ2ZpbHRlcic6ICdhbHBoYShvcGFjaXR5PTApJyxcXG4gICAgICAgICAgJy1tcy1maWx0ZXInOiBcXFwiYWxwaGEob3BhY2l0eT0wKVxcXCIsXFxuICAgICAgICAgICcta2h0bWwtb3BhY2l0eSc6ICcwLjAnLFxcbiAgICAgICAgICAnLW1vei1vcGFjaXR5JzogJzAuMCdcXG4gICAgICAgIH0pO1xcbiAgICAgICAgZm9ybS5hcHBlbmRUbyh1cGxvYWRMYWJlbCk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGZvcm0uYXBwZW5kVG8oJCgnYm9keScpKTtcXG4gICAgICAgIGZvcm0uY3NzKHtcXG4gICAgICAgICAgbWFyZ2luOiAwLFxcbiAgICAgICAgICBwYWRkaW5nOiAwLFxcbiAgICAgICAgICBkaXNwbGF5OiAnYmxvY2snLFxcbiAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcXG4gICAgICAgICAgbGVmdDogJy0yNTBweCdcXG4gICAgICAgIH0pO1xcblxcbiAgICAgICAgaWYgKG5hdmlnYXRvci5hcHBWZXJzaW9uLmluZGV4T2YoXFxcIk1TSUUgXFxcIikgIT0gLTEpIC8vSUUgQnJvd3NlclxcbiAgICAgICAgICB7XFxuICAgICAgICAgICAgdXBsb2FkTGFiZWwuYXR0cignZm9yJywgZmlsZVVwbG9hZElkKTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgdXBsb2FkTGFiZWwuY2xpY2soZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIGZpbGVJbnB1dC5jbGljaygpO1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gZGVmYXVsdFByb2dyZXNzQmFyKG9iaiwgcykge1xcbiAgICAgIHRoaXMuc3RhdHVzYmFyID0gJChcXFwiPGRpdiBjbGFzcz0nYWpheC1maWxlLXVwbG9hZC1zdGF0dXNiYXInPjwvZGl2PlxcXCIpLndpZHRoKHMuc3RhdHVzQmFyV2lkdGgpO1xcbiAgICAgIHRoaXMucHJldmlldyA9ICQoXFxcIjxpbWcgY2xhc3M9J2FqYXgtZmlsZS11cGxvYWQtcHJldmlldycgLz5cXFwiKS53aWR0aChzLnByZXZpZXdXaWR0aCkuaGVpZ2h0KHMucHJldmlld0hlaWdodCkuYXBwZW5kVG8odGhpcy5zdGF0dXNiYXIpLmhpZGUoKTtcXG4gICAgICB0aGlzLmZpbGVuYW1lID0gJChcXFwiPGRpdiBjbGFzcz0nYWpheC1maWxlLXVwbG9hZC1maWxlbmFtZSc+PC9kaXY+XFxcIikuYXBwZW5kVG8odGhpcy5zdGF0dXNiYXIpO1xcbiAgICAgIHRoaXMucHJvZ3Jlc3NEaXYgPSAkKFxcXCI8ZGl2IGNsYXNzPSdhamF4LWZpbGUtdXBsb2FkLXByb2dyZXNzJz5cXFwiKS5hcHBlbmRUbyh0aGlzLnN0YXR1c2JhcikuaGlkZSgpO1xcbiAgICAgIHRoaXMucHJvZ3Jlc3NiYXIgPSAkKFxcXCI8ZGl2IGNsYXNzPSdhamF4LWZpbGUtdXBsb2FkLWJhcic+PC9kaXY+XFxcIikuYXBwZW5kVG8odGhpcy5wcm9ncmVzc0Rpdik7XFxuICAgICAgdGhpcy5hYm9ydCA9ICQoXFxcIjxkaXY+XFxcIiArIHMuYWJvcnRTdHIgKyBcXFwiPC9kaXY+XFxcIikuYXBwZW5kVG8odGhpcy5zdGF0dXNiYXIpLmhpZGUoKTtcXG4gICAgICB0aGlzLmNhbmNlbCA9ICQoXFxcIjxkaXY+XFxcIiArIHMuY2FuY2VsU3RyICsgXFxcIjwvZGl2PlxcXCIpLmFwcGVuZFRvKHRoaXMuc3RhdHVzYmFyKS5oaWRlKCk7XFxuICAgICAgdGhpcy5kb25lID0gJChcXFwiPGRpdj5cXFwiICsgcy5kb25lU3RyICsgXFxcIjwvZGl2PlxcXCIpLmFwcGVuZFRvKHRoaXMuc3RhdHVzYmFyKS5oaWRlKCk7XFxuICAgICAgdGhpcy5kb3dubG9hZCA9ICQoXFxcIjxkaXY+XFxcIiArIHMuZG93bmxvYWRTdHIgKyBcXFwiPC9kaXY+XFxcIikuYXBwZW5kVG8odGhpcy5zdGF0dXNiYXIpLmhpZGUoKTtcXG4gICAgICB0aGlzLmRlbCA9ICQoXFxcIjxkaXY+XFxcIiArIHMuZGVsZXRlU3RyICsgXFxcIjwvZGl2PlxcXCIpLmFwcGVuZFRvKHRoaXMuc3RhdHVzYmFyKS5oaWRlKCk7XFxuICAgICAgdGhpcy5hYm9ydC5hZGRDbGFzcyhcXFwiYWpheC1maWxlLXVwbG9hZC1yZWRcXFwiKTtcXG4gICAgICB0aGlzLmRvbmUuYWRkQ2xhc3MoXFxcImFqYXgtZmlsZS11cGxvYWQtZ3JlZW5cXFwiKTtcXG4gICAgICB0aGlzLmRvd25sb2FkLmFkZENsYXNzKFxcXCJhamF4LWZpbGUtdXBsb2FkLWdyZWVuXFxcIik7XFxuICAgICAgdGhpcy5jYW5jZWwuYWRkQ2xhc3MoXFxcImFqYXgtZmlsZS11cGxvYWQtcmVkXFxcIik7XFxuICAgICAgdGhpcy5kZWwuYWRkQ2xhc3MoXFxcImFqYXgtZmlsZS11cGxvYWQtcmVkXFxcIik7XFxuICAgICAgcmV0dXJuIHRoaXM7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gY3JlYXRlUHJvZ3Jlc3NEaXYob2JqLCBzKSB7XFxuICAgICAgdmFyIGJhciA9IG51bGw7XFxuICAgICAgaWYgKHMuY3VzdG9tUHJvZ3Jlc3NCYXIpIGJhciA9IG5ldyBzLmN1c3RvbVByb2dyZXNzQmFyKG9iaiwgcyk7ZWxzZSBiYXIgPSBuZXcgZGVmYXVsdFByb2dyZXNzQmFyKG9iaiwgcyk7XFxuICAgICAgYmFyLmFib3J0LmFkZENsYXNzKG9iai5mb3JtR3JvdXApO1xcbiAgICAgIGJhci5hYm9ydC5hZGRDbGFzcyhzLmFib3J0QnV0dG9uQ2xhc3MpO1xcbiAgICAgIGJhci5jYW5jZWwuYWRkQ2xhc3Mob2JqLmZvcm1Hcm91cCk7XFxuICAgICAgYmFyLmNhbmNlbC5hZGRDbGFzcyhzLmNhbmNlbEJ1dHRvbkNsYXNzKTtcXG4gICAgICBpZiAocy5leHRyYUhUTUwpIGJhci5leHRyYUhUTUwgPSAkKFxcXCI8ZGl2IGNsYXNzPSdleHRyYWh0bWwnPlxcXCIgKyBzLmV4dHJhSFRNTCgpICsgXFxcIjwvZGl2PlxcXCIpLmluc2VydEFmdGVyKGJhci5maWxlbmFtZSk7XFxuICAgICAgaWYgKHMudXBsb2FkUXVldWVPcmRlciA9PSAnYm90dG9tJykgJChvYmouY29udGFpbmVyKS5hcHBlbmQoYmFyLnN0YXR1c2Jhcik7ZWxzZSAkKG9iai5jb250YWluZXIpLnByZXBlbmQoYmFyLnN0YXR1c2Jhcik7XFxuICAgICAgcmV0dXJuIGJhcjtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBhamF4Rm9ybVN1Ym1pdChmb3JtLCBzLCBwZCwgZmlsZUFycmF5LCBvYmosIGZpbGUpIHtcXG4gICAgICB2YXIgY3VycmVudFhIUiA9IG51bGw7XFxuICAgICAgdmFyIG9wdGlvbnMgPSB7XFxuICAgICAgICBjYWNoZTogZmFsc2UsXFxuICAgICAgICBjb250ZW50VHlwZTogZmFsc2UsXFxuICAgICAgICBwcm9jZXNzRGF0YTogZmFsc2UsXFxuICAgICAgICBmb3JjZVN5bmM6IGZhbHNlLFxcbiAgICAgICAgdHlwZTogcy5tZXRob2QsXFxuICAgICAgICBkYXRhOiBzLmZvcm1EYXRhLFxcbiAgICAgICAgZm9ybURhdGE6IHMuZmlsZURhdGEsXFxuICAgICAgICBkYXRhVHlwZTogcy5yZXR1cm5UeXBlLFxcbiAgICAgICAgaGVhZGVyczogcy5oZWFkZXJzLFxcbiAgICAgICAgYmVmb3JlU3VibWl0OiBmdW5jdGlvbiBiZWZvcmVTdWJtaXQoZm9ybURhdGEsICRmb3JtLCBvcHRpb25zKSB7XFxuICAgICAgICAgIGlmIChzLm9uU3VibWl0LmNhbGwodGhpcywgZmlsZUFycmF5KSAhPSBmYWxzZSkge1xcbiAgICAgICAgICAgIGlmIChzLmR5bmFtaWNGb3JtRGF0YSkge1xcbiAgICAgICAgICAgICAgdmFyIHNEYXRhID0gc2VyaWFsaXplRGF0YShzLmR5bmFtaWNGb3JtRGF0YSgpKTtcXG5cXG4gICAgICAgICAgICAgIGlmIChzRGF0YSkge1xcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNEYXRhLmxlbmd0aDsgaisrKSB7XFxuICAgICAgICAgICAgICAgICAgaWYgKHNEYXRhW2pdKSB7XFxuICAgICAgICAgICAgICAgICAgICBpZiAocy5zZXJpYWxpemUgJiYgcy5maWxlRGF0YSAhPSB1bmRlZmluZWQpIG9wdGlvbnMuZm9ybURhdGEuYXBwZW5kKHNEYXRhW2pdWzBdLCBzRGF0YVtqXVsxXSk7ZWxzZSBvcHRpb25zLmRhdGFbc0RhdGFbal1bMF1dID0gc0RhdGFbal1bMV07XFxuICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmIChzLmV4dHJhSFRNTCkge1xcbiAgICAgICAgICAgICAgJChwZC5leHRyYUhUTUwpLmZpbmQoXFxcImlucHV0LHNlbGVjdCx0ZXh0YXJlYVxcXCIpLmVhY2goZnVuY3Rpb24gKGksIGl0ZW1zKSB7XFxuICAgICAgICAgICAgICAgIGlmIChzLnNlcmlhbGl6ZSAmJiBzLmZpbGVEYXRhICE9IHVuZGVmaW5lZCkgb3B0aW9ucy5mb3JtRGF0YS5hcHBlbmQoJCh0aGlzKS5hdHRyKCduYW1lJyksICQodGhpcykudmFsKCkpO2Vsc2Ugb3B0aW9ucy5kYXRhWyQodGhpcykuYXR0cignbmFtZScpXSA9ICQodGhpcykudmFsKCk7XFxuICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgcGQuc3RhdHVzYmFyLmFwcGVuZChcXFwiPGRpdiBjbGFzcz0nXFxcIiArIHMuZXJyb3JDbGFzcyArIFxcXCInPlxcXCIgKyBzLnVwbG9hZEVycm9yU3RyICsgXFxcIjwvZGl2PlxcXCIpO1xcbiAgICAgICAgICBwZC5jYW5jZWwuc2hvdygpO1xcbiAgICAgICAgICBmb3JtLnJlbW92ZSgpO1xcbiAgICAgICAgICBwZC5jYW5jZWwuY2xpY2soZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIG1haW5RLnNwbGljZShtYWluUS5pbmRleE9mKGZvcm0pLCAxKTtcXG4gICAgICAgICAgICByZW1vdmVFeGlzdGluZ0ZpbGVOYW1lKG9iaiwgZmlsZUFycmF5KTtcXG4gICAgICAgICAgICBwZC5zdGF0dXNiYXIucmVtb3ZlKCk7XFxuICAgICAgICAgICAgcy5vbkNhbmNlbC5jYWxsKG9iaiwgZmlsZUFycmF5LCBwZCk7XFxuICAgICAgICAgICAgb2JqLnNlbGVjdGVkRmlsZXMgLT0gZmlsZUFycmF5Lmxlbmd0aDsgLy9yZWR1Y2Ugc2VsZWN0ZWQgRmlsZSBjb3VudFxcblxcbiAgICAgICAgICAgIHVwZGF0ZUZpbGVDb3VudGVyKHMsIG9iaik7XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICB9LFxcbiAgICAgICAgYmVmb3JlU2VuZDogZnVuY3Rpb24gYmVmb3JlU2VuZCh4aHIsIG8pIHtcXG4gICAgICAgICAgZm9yICh2YXIga2V5IGluIG8uaGVhZGVycykge1xcbiAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgby5oZWFkZXJzW2tleV0pO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHBkLnByb2dyZXNzRGl2LnNob3coKTtcXG4gICAgICAgICAgcGQuY2FuY2VsLmhpZGUoKTtcXG4gICAgICAgICAgcGQuZG9uZS5oaWRlKCk7XFxuXFxuICAgICAgICAgIGlmIChzLnNob3dBYm9ydCkge1xcbiAgICAgICAgICAgIHBkLmFib3J0LnNob3coKTtcXG4gICAgICAgICAgICBwZC5hYm9ydC5jbGljayhmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICByZW1vdmVFeGlzdGluZ0ZpbGVOYW1lKG9iaiwgZmlsZUFycmF5KTtcXG4gICAgICAgICAgICAgIHhoci5hYm9ydCgpO1xcbiAgICAgICAgICAgICAgb2JqLnNlbGVjdGVkRmlsZXMgLT0gZmlsZUFycmF5Lmxlbmd0aDsgLy9yZWR1Y2Ugc2VsZWN0ZWQgRmlsZSBjb3VudFxcblxcbiAgICAgICAgICAgICAgcy5vbkFib3J0LmNhbGwob2JqLCBmaWxlQXJyYXksIHBkKTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAoIWZlYXR1cmUuZm9ybWRhdGEpIC8vRm9yIGlmcmFtZSBiYXNlZCBwdXNoXFxuICAgICAgICAgICAge1xcbiAgICAgICAgICAgICAgcGQucHJvZ3Jlc3NiYXIud2lkdGgoJzUlJyk7XFxuICAgICAgICAgICAgfSBlbHNlIHBkLnByb2dyZXNzYmFyLndpZHRoKCcxJScpOyAvL0ZpeCBmb3Igc21hbGwgZmlsZXNcXG5cXG4gICAgICAgIH0sXFxuICAgICAgICB1cGxvYWRQcm9ncmVzczogZnVuY3Rpb24gdXBsb2FkUHJvZ3Jlc3MoZXZlbnQsIHBvc2l0aW9uLCB0b3RhbCwgcGVyY2VudENvbXBsZXRlKSB7XFxuICAgICAgICAgIC8vRml4IGZvciBzbWFsbGVyIGZpbGUgdXBsb2FkcyBpbiBNQUNcXG4gICAgICAgICAgaWYgKHBlcmNlbnRDb21wbGV0ZSA+IDk4KSBwZXJjZW50Q29tcGxldGUgPSA5ODtcXG4gICAgICAgICAgdmFyIHBlcmNlbnRWYWwgPSBwZXJjZW50Q29tcGxldGUgKyAnJSc7XFxuICAgICAgICAgIGlmIChwZXJjZW50Q29tcGxldGUgPiAxKSBwZC5wcm9ncmVzc2Jhci53aWR0aChwZXJjZW50VmFsKTtcXG5cXG4gICAgICAgICAgaWYgKHMuc2hvd1Byb2dyZXNzKSB7XFxuICAgICAgICAgICAgcGQucHJvZ3Jlc3NiYXIuaHRtbChwZXJjZW50VmFsKTtcXG4gICAgICAgICAgICBwZC5wcm9ncmVzc2Jhci5jc3MoJ3RleHQtYWxpZ24nLCAnY2VudGVyJyk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiBzdWNjZXNzKGRhdGEsIG1lc3NhZ2UsIHhocikge1xcbiAgICAgICAgICBwZC5jYW5jZWwucmVtb3ZlKCk7XFxuICAgICAgICAgIHByb2dyZXNzUS5wb3AoKTsgLy9Gb3IgY3VzdG9tIGVycm9ycy5cXG5cXG4gICAgICAgICAgaWYgKHMucmV0dXJuVHlwZSA9PSBcXFwianNvblxcXCIgJiYgJC50eXBlKGRhdGEpID09IFxcXCJvYmplY3RcXFwiICYmIGRhdGEuaGFzT3duUHJvcGVydHkocy5jdXN0b21FcnJvcktleVN0cikpIHtcXG4gICAgICAgICAgICBwZC5hYm9ydC5oaWRlKCk7XFxuICAgICAgICAgICAgdmFyIG1zZyA9IGRhdGFbcy5jdXN0b21FcnJvcktleVN0cl07XFxuICAgICAgICAgICAgcy5vbkVycm9yLmNhbGwodGhpcywgZmlsZUFycmF5LCAyMDAsIG1zZywgcGQpO1xcblxcbiAgICAgICAgICAgIGlmIChzLnNob3dTdGF0dXNBZnRlckVycm9yKSB7XFxuICAgICAgICAgICAgICBwZC5wcm9ncmVzc0Rpdi5oaWRlKCk7XFxuICAgICAgICAgICAgICBwZC5zdGF0dXNiYXIuYXBwZW5kKFxcXCI8c3BhbiBjbGFzcz0nXFxcIiArIHMuZXJyb3JDbGFzcyArIFxcXCInPkVSUk9SOiBcXFwiICsgbXNnICsgXFxcIjwvc3Bhbj5cXFwiKTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgcGQuc3RhdHVzYmFyLmhpZGUoKTtcXG4gICAgICAgICAgICAgIHBkLnN0YXR1c2Jhci5yZW1vdmUoKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgb2JqLnNlbGVjdGVkRmlsZXMgLT0gZmlsZUFycmF5Lmxlbmd0aDsgLy9yZWR1Y2Ugc2VsZWN0ZWQgRmlsZSBjb3VudFxcblxcbiAgICAgICAgICAgIGZvcm0ucmVtb3ZlKCk7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIG9iai5yZXNwb25zZXMucHVzaChkYXRhKTtcXG4gICAgICAgICAgcGQucHJvZ3Jlc3NiYXIud2lkdGgoJzEwMCUnKTtcXG5cXG4gICAgICAgICAgaWYgKHMuc2hvd1Byb2dyZXNzKSB7XFxuICAgICAgICAgICAgcGQucHJvZ3Jlc3NiYXIuaHRtbCgnMTAwJScpO1xcbiAgICAgICAgICAgIHBkLnByb2dyZXNzYmFyLmNzcygndGV4dC1hbGlnbicsICdjZW50ZXInKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBwZC5hYm9ydC5oaWRlKCk7XFxuICAgICAgICAgIHMub25TdWNjZXNzLmNhbGwodGhpcywgZmlsZUFycmF5LCBkYXRhLCB4aHIsIHBkKTtcXG5cXG4gICAgICAgICAgaWYgKHMuc2hvd1N0YXR1c0FmdGVyU3VjY2Vzcykge1xcbiAgICAgICAgICAgIGlmIChzLnNob3dEb25lKSB7XFxuICAgICAgICAgICAgICBwZC5kb25lLnNob3coKTtcXG4gICAgICAgICAgICAgIHBkLmRvbmUuY2xpY2soZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICBwZC5zdGF0dXNiYXIuaGlkZShcXFwic2xvd1xcXCIpO1xcbiAgICAgICAgICAgICAgICBwZC5zdGF0dXNiYXIucmVtb3ZlKCk7XFxuICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgcGQuZG9uZS5oaWRlKCk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmIChzLnNob3dEZWxldGUpIHtcXG4gICAgICAgICAgICAgIHBkLmRlbC5zaG93KCk7XFxuICAgICAgICAgICAgICBwZC5kZWwuY2xpY2soZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICByZW1vdmVFeGlzdGluZ0ZpbGVOYW1lKG9iaiwgZmlsZUFycmF5KTtcXG4gICAgICAgICAgICAgICAgcGQuc3RhdHVzYmFyLmhpZGUoKS5yZW1vdmUoKTtcXG4gICAgICAgICAgICAgICAgaWYgKHMuZGVsZXRlQ2FsbGJhY2spIHMuZGVsZXRlQ2FsbGJhY2suY2FsbCh0aGlzLCBkYXRhLCBwZCk7XFxuICAgICAgICAgICAgICAgIG9iai5zZWxlY3RlZEZpbGVzIC09IGZpbGVBcnJheS5sZW5ndGg7IC8vcmVkdWNlIHNlbGVjdGVkIEZpbGUgY291bnRcXG5cXG4gICAgICAgICAgICAgICAgdXBkYXRlRmlsZUNvdW50ZXIocywgb2JqKTtcXG4gICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICBwZC5kZWwuaGlkZSgpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBwZC5zdGF0dXNiYXIuaGlkZShcXFwic2xvd1xcXCIpO1xcbiAgICAgICAgICAgIHBkLnN0YXR1c2Jhci5yZW1vdmUoKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAocy5zaG93RG93bmxvYWQpIHtcXG4gICAgICAgICAgICBwZC5kb3dubG9hZC5zaG93KCk7XFxuICAgICAgICAgICAgcGQuZG93bmxvYWQuY2xpY2soZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgaWYgKHMuZG93bmxvYWRDYWxsYmFjaykgcy5kb3dubG9hZENhbGxiYWNrKGRhdGEsIHBkKTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBmb3JtLnJlbW92ZSgpO1xcbiAgICAgICAgfSxcXG4gICAgICAgIGVycm9yOiBmdW5jdGlvbiBlcnJvcih4aHIsIHN0YXR1cywgZXJyTXNnKSB7XFxuICAgICAgICAgIHBkLmNhbmNlbC5yZW1vdmUoKTtcXG4gICAgICAgICAgcHJvZ3Jlc3NRLnBvcCgpO1xcbiAgICAgICAgICBwZC5hYm9ydC5oaWRlKCk7XFxuXFxuICAgICAgICAgIGlmICh4aHIuc3RhdHVzVGV4dCA9PSBcXFwiYWJvcnRcXFwiKSAvL3dlIGFib3J0ZWQgaXRcXG4gICAgICAgICAgICB7XFxuICAgICAgICAgICAgICBwZC5zdGF0dXNiYXIuaGlkZShcXFwic2xvd1xcXCIpLnJlbW92ZSgpO1xcbiAgICAgICAgICAgICAgdXBkYXRlRmlsZUNvdW50ZXIocywgb2JqKTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHMub25FcnJvci5jYWxsKHRoaXMsIGZpbGVBcnJheSwgc3RhdHVzLCBlcnJNc2csIHBkKTtcXG5cXG4gICAgICAgICAgICBpZiAocy5zaG93U3RhdHVzQWZ0ZXJFcnJvcikge1xcbiAgICAgICAgICAgICAgcGQucHJvZ3Jlc3NEaXYuaGlkZSgpO1xcbiAgICAgICAgICAgICAgcGQuc3RhdHVzYmFyLmFwcGVuZChcXFwiPHNwYW4gY2xhc3M9J1xcXCIgKyBzLmVycm9yQ2xhc3MgKyBcXFwiJz5FUlJPUjogXFxcIiArIGVyck1zZyArIFxcXCI8L3NwYW4+XFxcIik7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgIHBkLnN0YXR1c2Jhci5oaWRlKCk7XFxuICAgICAgICAgICAgICBwZC5zdGF0dXNiYXIucmVtb3ZlKCk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIG9iai5zZWxlY3RlZEZpbGVzIC09IGZpbGVBcnJheS5sZW5ndGg7IC8vcmVkdWNlIHNlbGVjdGVkIEZpbGUgY291bnRcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBmb3JtLnJlbW92ZSgpO1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuXFxuICAgICAgaWYgKHMuc2hvd1ByZXZpZXcgJiYgZmlsZSAhPSBudWxsKSB7XFxuICAgICAgICBpZiAoZmlsZS50eXBlLnRvTG93ZXJDYXNlKCkuc3BsaXQoXFxcIi9cXFwiKS5zaGlmdCgpID09IFxcXCJpbWFnZVxcXCIpIGdldFNyY1RvUHJldmlldyhmaWxlLCBwZC5wcmV2aWV3KTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHMuYXV0b1N1Ym1pdCkge1xcbiAgICAgICAgZm9ybS5hamF4Rm9ybShvcHRpb25zKTtcXG4gICAgICAgIG1haW5RLnB1c2goZm9ybSk7XFxuICAgICAgICBzdWJtaXRQZW5kaW5nVXBsb2FkcygpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBpZiAocy5zaG93Q2FuY2VsKSB7XFxuICAgICAgICAgIHBkLmNhbmNlbC5zaG93KCk7XFxuICAgICAgICAgIHBkLmNhbmNlbC5jbGljayhmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgbWFpblEuc3BsaWNlKG1haW5RLmluZGV4T2YoZm9ybSksIDEpO1xcbiAgICAgICAgICAgIHJlbW92ZUV4aXN0aW5nRmlsZU5hbWUob2JqLCBmaWxlQXJyYXkpO1xcbiAgICAgICAgICAgIGZvcm0ucmVtb3ZlKCk7XFxuICAgICAgICAgICAgcGQuc3RhdHVzYmFyLnJlbW92ZSgpO1xcbiAgICAgICAgICAgIHMub25DYW5jZWwuY2FsbChvYmosIGZpbGVBcnJheSwgcGQpO1xcbiAgICAgICAgICAgIG9iai5zZWxlY3RlZEZpbGVzIC09IGZpbGVBcnJheS5sZW5ndGg7IC8vcmVkdWNlIHNlbGVjdGVkIEZpbGUgY291bnRcXG5cXG4gICAgICAgICAgICB1cGRhdGVGaWxlQ291bnRlcihzLCBvYmopO1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGZvcm0uYWpheEZvcm0ob3B0aW9ucyk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHJldHVybiB0aGlzO1xcbiAgfTtcXG59KShqUXVlcnkpO1wiIiwiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc3JjKSB7XG5cdGZ1bmN0aW9uIGxvZyhlcnJvcikge1xuXHRcdCh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIilcblx0XHQmJiAoY29uc29sZS5lcnJvciB8fCBjb25zb2xlLmxvZykoXCJbU2NyaXB0IExvYWRlcl1cIiwgZXJyb3IpO1xuXHR9XG5cblx0Ly8gQ2hlY2sgZm9yIElFID08IDhcblx0ZnVuY3Rpb24gaXNJRSgpIHtcblx0XHRyZXR1cm4gdHlwZW9mIGF0dGFjaEV2ZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBhZGRFdmVudExpc3RlbmVyID09PSBcInVuZGVmaW5lZFwiO1xuXHR9XG5cblx0dHJ5IHtcblx0XHRpZiAodHlwZW9mIGV4ZWNTY3JpcHQgIT09IFwidW5kZWZpbmVkXCIgJiYgaXNJRSgpKSB7XG5cdFx0XHRleGVjU2NyaXB0KHNyYyk7XG5cdFx0fSBlbHNlIGlmICh0eXBlb2YgZXZhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0ZXZhbC5jYWxsKG51bGwsIHNyYyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxvZyhcIkV2YWxFcnJvcjogTm8gZXZhbCBmdW5jdGlvbiBhdmFpbGFibGVcIik7XG5cdFx0fVxuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdGxvZyhlcnJvcik7XG5cdH1cbn1cbiIsInJlcXVpcmUoXCIhIS9ob21lL29zYm94ZXMvd29ya3NwYWNlL21sYWIubG9jYWwudGVzdC9ub2RlX21vZHVsZXMvc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanNcIikocmVxdWlyZShcIiEhL2hvbWUvb3Nib3hlcy93b3Jrc3BhY2UvbWxhYi5sb2NhbC50ZXN0L25vZGVfbW9kdWxlcy9yYXctbG9hZGVyL2luZGV4LmpzIS9ob21lL29zYm94ZXMvd29ya3NwYWNlL21sYWIubG9jYWwudGVzdC9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS00LTAhL2hvbWUvb3Nib3hlcy93b3Jrc3BhY2UvbWxhYi5sb2NhbC50ZXN0L2Fzc2V0cy9qcy9ib3dzZXIuanNcIikrXCJcXG5cXG4vLyBTQ1JJUFQtTE9BREVSIEZPT1RFUlxcbi8vIyBzb3VyY2VVUkw9c2NyaXB0Oi8vL2hvbWUvb3Nib3hlcy93b3Jrc3BhY2UvbWxhYi5sb2NhbC50ZXN0L25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzJTNGP3JlZi0tNC0wIS9ob21lL29zYm94ZXMvd29ya3NwYWNlL21sYWIubG9jYWwudGVzdC9hc3NldHMvanMvYm93c2VyLmpzXCIpIiwicmVxdWlyZShcIiEhL2hvbWUvb3Nib3hlcy93b3Jrc3BhY2UvbWxhYi5sb2NhbC50ZXN0L25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qc1wiKShyZXF1aXJlKFwiISEvaG9tZS9vc2JveGVzL3dvcmtzcGFjZS9tbGFiLmxvY2FsLnRlc3Qvbm9kZV9tb2R1bGVzL3Jhdy1sb2FkZXIvaW5kZXguanMhL2hvbWUvb3Nib3hlcy93b3Jrc3BhY2UvbWxhYi5sb2NhbC50ZXN0L25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTQtMCEvaG9tZS9vc2JveGVzL3dvcmtzcGFjZS9tbGFiLmxvY2FsLnRlc3QvYXNzZXRzL2pzL2pxdWVyeS0yLjEuNC5qc1wiKStcIlxcblxcbi8vIFNDUklQVC1MT0FERVIgRk9PVEVSXFxuLy8jIHNvdXJjZVVSTD1zY3JpcHQ6Ly8vaG9tZS9vc2JveGVzL3dvcmtzcGFjZS9tbGFiLmxvY2FsLnRlc3Qvbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMlM0Y/cmVmLS00LTAhL2hvbWUvb3Nib3hlcy93b3Jrc3BhY2UvbWxhYi5sb2NhbC50ZXN0L2Fzc2V0cy9qcy9qcXVlcnktMi4xLjQuanNcIikiLCJyZXF1aXJlKFwiISEvaG9tZS9vc2JveGVzL3dvcmtzcGFjZS9tbGFiLmxvY2FsLnRlc3Qvbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzXCIpKHJlcXVpcmUoXCIhIS9ob21lL29zYm94ZXMvd29ya3NwYWNlL21sYWIubG9jYWwudGVzdC9ub2RlX21vZHVsZXMvcmF3LWxvYWRlci9pbmRleC5qcyEvaG9tZS9vc2JveGVzL3dvcmtzcGFjZS9tbGFiLmxvY2FsLnRlc3Qvbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tNC0wIS9ob21lL29zYm94ZXMvd29ya3NwYWNlL21sYWIubG9jYWwudGVzdC9hc3NldHMvanMvanF1ZXJ5LmZvcm0uanNcIikrXCJcXG5cXG4vLyBTQ1JJUFQtTE9BREVSIEZPT1RFUlxcbi8vIyBzb3VyY2VVUkw9c2NyaXB0Oi8vL2hvbWUvb3Nib3hlcy93b3Jrc3BhY2UvbWxhYi5sb2NhbC50ZXN0L25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzJTNGP3JlZi0tNC0wIS9ob21lL29zYm94ZXMvd29ya3NwYWNlL21sYWIubG9jYWwudGVzdC9hc3NldHMvanMvanF1ZXJ5LmZvcm0uanNcIikiLCJyZXF1aXJlKFwiISEvaG9tZS9vc2JveGVzL3dvcmtzcGFjZS9tbGFiLmxvY2FsLnRlc3Qvbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzXCIpKHJlcXVpcmUoXCIhIS9ob21lL29zYm94ZXMvd29ya3NwYWNlL21sYWIubG9jYWwudGVzdC9ub2RlX21vZHVsZXMvcmF3LWxvYWRlci9pbmRleC5qcyEvaG9tZS9vc2JveGVzL3dvcmtzcGFjZS9tbGFiLmxvY2FsLnRlc3Qvbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tNC0wIS9ob21lL29zYm94ZXMvd29ya3NwYWNlL21sYWIubG9jYWwudGVzdC9hc3NldHMvanMvanF1ZXJ5LnF0aXAubmlnaHRseS5qc1wiKStcIlxcblxcbi8vIFNDUklQVC1MT0FERVIgRk9PVEVSXFxuLy8jIHNvdXJjZVVSTD1zY3JpcHQ6Ly8vaG9tZS9vc2JveGVzL3dvcmtzcGFjZS9tbGFiLmxvY2FsLnRlc3Qvbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMlM0Y/cmVmLS00LTAhL2hvbWUvb3Nib3hlcy93b3Jrc3BhY2UvbWxhYi5sb2NhbC50ZXN0L2Fzc2V0cy9qcy9qcXVlcnkucXRpcC5uaWdodGx5LmpzXCIpIiwicmVxdWlyZShcIiEhL2hvbWUvb3Nib3hlcy93b3Jrc3BhY2UvbWxhYi5sb2NhbC50ZXN0L25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qc1wiKShyZXF1aXJlKFwiISEvaG9tZS9vc2JveGVzL3dvcmtzcGFjZS9tbGFiLmxvY2FsLnRlc3Qvbm9kZV9tb2R1bGVzL3Jhdy1sb2FkZXIvaW5kZXguanMhL2hvbWUvb3Nib3hlcy93b3Jrc3BhY2UvbWxhYi5sb2NhbC50ZXN0L25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTQtMCEvaG9tZS9vc2JveGVzL3dvcmtzcGFjZS9tbGFiLmxvY2FsLnRlc3QvYXNzZXRzL2pzL2pxdWVyeS51aS0xLjExLjQuanNcIikrXCJcXG5cXG4vLyBTQ1JJUFQtTE9BREVSIEZPT1RFUlxcbi8vIyBzb3VyY2VVUkw9c2NyaXB0Oi8vL2hvbWUvb3Nib3hlcy93b3Jrc3BhY2UvbWxhYi5sb2NhbC50ZXN0L25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzJTNGP3JlZi0tNC0wIS9ob21lL29zYm94ZXMvd29ya3NwYWNlL21sYWIubG9jYWwudGVzdC9hc3NldHMvanMvanF1ZXJ5LnVpLTEuMTEuNC5qc1wiKSIsInJlcXVpcmUoXCIhIS9ob21lL29zYm94ZXMvd29ya3NwYWNlL21sYWIubG9jYWwudGVzdC9ub2RlX21vZHVsZXMvc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanNcIikocmVxdWlyZShcIiEhL2hvbWUvb3Nib3hlcy93b3Jrc3BhY2UvbWxhYi5sb2NhbC50ZXN0L25vZGVfbW9kdWxlcy9yYXctbG9hZGVyL2luZGV4LmpzIS9ob21lL29zYm94ZXMvd29ya3NwYWNlL21sYWIubG9jYWwudGVzdC9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS00LTAhL2hvbWUvb3Nib3hlcy93b3Jrc3BhY2UvbWxhYi5sb2NhbC50ZXN0L2Fzc2V0cy9qcy9qcXVlcnkudXBsb2FkZmlsZS00LjAuMTEuanNcIikrXCJcXG5cXG4vLyBTQ1JJUFQtTE9BREVSIEZPT1RFUlxcbi8vIyBzb3VyY2VVUkw9c2NyaXB0Oi8vL2hvbWUvb3Nib3hlcy93b3Jrc3BhY2UvbWxhYi5sb2NhbC50ZXN0L25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzJTNGP3JlZi0tNC0wIS9ob21lL29zYm94ZXMvd29ya3NwYWNlL21sYWIubG9jYWwudGVzdC9hc3NldHMvanMvanF1ZXJ5LnVwbG9hZGZpbGUtNC4wLjExLmpzXCIpIl0sInNvdXJjZVJvb3QiOiIifQ==